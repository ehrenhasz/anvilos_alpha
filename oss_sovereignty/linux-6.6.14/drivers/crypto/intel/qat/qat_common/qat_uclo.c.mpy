{
  "module_name": "qat_uclo.c",
  "hash_id": "24dbd032a15c14643970cbd538fd1a94219f613f9fccb6a663bc96dca87c2943",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/intel/qat/qat_common/qat_uclo.c",
  "human_readable_source": "\n \n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/kernel.h>\n#include <linux/delay.h>\n#include <linux/pci_ids.h>\n#include \"adf_accel_devices.h\"\n#include \"adf_common_drv.h\"\n#include \"icp_qat_uclo.h\"\n#include \"icp_qat_hal.h\"\n#include \"icp_qat_fw_loader_handle.h\"\n\n#define UWORD_CPYBUF_SIZE 1024U\n#define INVLD_UWORD 0xffffffffffull\n#define PID_MINOR_REV 0xf\n#define PID_MAJOR_REV (0xf << 4)\n\nstatic int qat_uclo_init_ae_data(struct icp_qat_uclo_objhandle *obj_handle,\n\t\t\t\t unsigned int ae, unsigned int image_num)\n{\n\tstruct icp_qat_uclo_aedata *ae_data;\n\tstruct icp_qat_uclo_encapme *encap_image;\n\tstruct icp_qat_uclo_page *page = NULL;\n\tstruct icp_qat_uclo_aeslice *ae_slice = NULL;\n\n\tae_data = &obj_handle->ae_data[ae];\n\tencap_image = &obj_handle->ae_uimage[image_num];\n\tae_slice = &ae_data->ae_slices[ae_data->slice_num];\n\tae_slice->encap_image = encap_image;\n\n\tif (encap_image->img_ptr) {\n\t\tae_slice->ctx_mask_assigned =\n\t\t\t\t\tencap_image->img_ptr->ctx_assigned;\n\t\tae_data->eff_ustore_size = obj_handle->ustore_phy_size;\n\t} else {\n\t\tae_slice->ctx_mask_assigned = 0;\n\t}\n\tae_slice->region = kzalloc(sizeof(*ae_slice->region), GFP_KERNEL);\n\tif (!ae_slice->region)\n\t\treturn -ENOMEM;\n\tae_slice->page = kzalloc(sizeof(*ae_slice->page), GFP_KERNEL);\n\tif (!ae_slice->page)\n\t\tgoto out_err;\n\tpage = ae_slice->page;\n\tpage->encap_page = encap_image->page;\n\tae_slice->page->region = ae_slice->region;\n\tae_data->slice_num++;\n\treturn 0;\nout_err:\n\tkfree(ae_slice->region);\n\tae_slice->region = NULL;\n\treturn -ENOMEM;\n}\n\nstatic int qat_uclo_free_ae_data(struct icp_qat_uclo_aedata *ae_data)\n{\n\tunsigned int i;\n\n\tif (!ae_data) {\n\t\tpr_err(\"QAT: bad argument, ae_data is NULL\\n \");\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < ae_data->slice_num; i++) {\n\t\tkfree(ae_data->ae_slices[i].region);\n\t\tae_data->ae_slices[i].region = NULL;\n\t\tkfree(ae_data->ae_slices[i].page);\n\t\tae_data->ae_slices[i].page = NULL;\n\t}\n\treturn 0;\n}\n\nstatic char *qat_uclo_get_string(struct icp_qat_uof_strtable *str_table,\n\t\t\t\t unsigned int str_offset)\n{\n\tif (!str_table->table_len || str_offset > str_table->table_len)\n\t\treturn NULL;\n\treturn (char *)(((uintptr_t)(str_table->strings)) + str_offset);\n}\n\nstatic int qat_uclo_check_uof_format(struct icp_qat_uof_filehdr *hdr)\n{\n\tint maj = hdr->maj_ver & 0xff;\n\tint min = hdr->min_ver & 0xff;\n\n\tif (hdr->file_id != ICP_QAT_UOF_FID) {\n\t\tpr_err(\"QAT: Invalid header 0x%x\\n\", hdr->file_id);\n\t\treturn -EINVAL;\n\t}\n\tif (min != ICP_QAT_UOF_MINVER || maj != ICP_QAT_UOF_MAJVER) {\n\t\tpr_err(\"QAT: bad UOF version, major 0x%x, minor 0x%x\\n\",\n\t\t       maj, min);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int qat_uclo_check_suof_format(struct icp_qat_suof_filehdr *suof_hdr)\n{\n\tint maj = suof_hdr->maj_ver & 0xff;\n\tint min = suof_hdr->min_ver & 0xff;\n\n\tif (suof_hdr->file_id != ICP_QAT_SUOF_FID) {\n\t\tpr_err(\"QAT: invalid header 0x%x\\n\", suof_hdr->file_id);\n\t\treturn -EINVAL;\n\t}\n\tif (suof_hdr->fw_type != 0) {\n\t\tpr_err(\"QAT: unsupported firmware type\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (suof_hdr->num_chunks <= 0x1) {\n\t\tpr_err(\"QAT: SUOF chunk amount is incorrect\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (maj != ICP_QAT_SUOF_MAJVER || min != ICP_QAT_SUOF_MINVER) {\n\t\tpr_err(\"QAT: bad SUOF version, major 0x%x, minor 0x%x\\n\",\n\t\t       maj, min);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic void qat_uclo_wr_sram_by_words(struct icp_qat_fw_loader_handle *handle,\n\t\t\t\t      unsigned int addr, unsigned int *val,\n\t\t\t\t      unsigned int num_in_bytes)\n{\n\tunsigned int outval;\n\tunsigned char *ptr = (unsigned char *)val;\n\n\twhile (num_in_bytes) {\n\t\tmemcpy(&outval, ptr, 4);\n\t\tSRAM_WRITE(handle, addr, outval);\n\t\tnum_in_bytes -= 4;\n\t\tptr += 4;\n\t\taddr += 4;\n\t}\n}\n\nstatic void qat_uclo_wr_umem_by_words(struct icp_qat_fw_loader_handle *handle,\n\t\t\t\t      unsigned char ae, unsigned int addr,\n\t\t\t\t      unsigned int *val,\n\t\t\t\t      unsigned int num_in_bytes)\n{\n\tunsigned int outval;\n\tunsigned char *ptr = (unsigned char *)val;\n\n\taddr >>= 0x2;  \n\n\twhile (num_in_bytes) {\n\t\tmemcpy(&outval, ptr, 4);\n\t\tqat_hal_wr_umem(handle, ae, addr++, 1, &outval);\n\t\tnum_in_bytes -= 4;\n\t\tptr += 4;\n\t}\n}\n\nstatic void qat_uclo_batch_wr_umem(struct icp_qat_fw_loader_handle *handle,\n\t\t\t\t   unsigned char ae,\n\t\t\t\t   struct icp_qat_uof_batch_init\n\t\t\t\t   *umem_init_header)\n{\n\tstruct icp_qat_uof_batch_init *umem_init;\n\n\tif (!umem_init_header)\n\t\treturn;\n\tumem_init = umem_init_header->next;\n\twhile (umem_init) {\n\t\tunsigned int addr, *value, size;\n\n\t\tae = umem_init->ae;\n\t\taddr = umem_init->addr;\n\t\tvalue = umem_init->value;\n\t\tsize = umem_init->size;\n\t\tqat_uclo_wr_umem_by_words(handle, ae, addr, value, size);\n\t\tumem_init = umem_init->next;\n\t}\n}\n\nstatic void\nqat_uclo_cleanup_batch_init_list(struct icp_qat_fw_loader_handle *handle,\n\t\t\t\t struct icp_qat_uof_batch_init **base)\n{\n\tstruct icp_qat_uof_batch_init *umem_init;\n\n\tumem_init = *base;\n\twhile (umem_init) {\n\t\tstruct icp_qat_uof_batch_init *pre;\n\n\t\tpre = umem_init;\n\t\tumem_init = umem_init->next;\n\t\tkfree(pre);\n\t}\n\t*base = NULL;\n}\n\nstatic int qat_uclo_parse_num(char *str, unsigned int *num)\n{\n\tchar buf[16] = {0};\n\tunsigned long ae = 0;\n\tint i;\n\n\tstrncpy(buf, str, 15);\n\tfor (i = 0; i < 16; i++) {\n\t\tif (!isdigit(buf[i])) {\n\t\t\tbuf[i] = '\\0';\n\t\t\tbreak;\n\t\t}\n\t}\n\tif ((kstrtoul(buf, 10, &ae)))\n\t\treturn -EFAULT;\n\n\t*num = (unsigned int)ae;\n\treturn 0;\n}\n\nstatic int qat_uclo_fetch_initmem_ae(struct icp_qat_fw_loader_handle *handle,\n\t\t\t\t     struct icp_qat_uof_initmem *init_mem,\n\t\t\t\t     unsigned int size_range, unsigned int *ae)\n{\n\tstruct icp_qat_uclo_objhandle *obj_handle = handle->obj_handle;\n\tchar *str;\n\n\tif ((init_mem->addr + init_mem->num_in_bytes) > (size_range << 0x2)) {\n\t\tpr_err(\"QAT: initmem is out of range\");\n\t\treturn -EINVAL;\n\t}\n\tif (init_mem->scope != ICP_QAT_UOF_LOCAL_SCOPE) {\n\t\tpr_err(\"QAT: Memory scope for init_mem error\\n\");\n\t\treturn -EINVAL;\n\t}\n\tstr = qat_uclo_get_string(&obj_handle->str_table, init_mem->sym_name);\n\tif (!str) {\n\t\tpr_err(\"QAT: AE name assigned in UOF init table is NULL\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (qat_uclo_parse_num(str, ae)) {\n\t\tpr_err(\"QAT: Parse num for AE number failed\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (*ae >= ICP_QAT_UCLO_MAX_AE) {\n\t\tpr_err(\"QAT: ae %d out of range\\n\", *ae);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int qat_uclo_create_batch_init_list(struct icp_qat_fw_loader_handle\n\t\t\t\t\t   *handle, struct icp_qat_uof_initmem\n\t\t\t\t\t   *init_mem, unsigned int ae,\n\t\t\t\t\t   struct icp_qat_uof_batch_init\n\t\t\t\t\t   **init_tab_base)\n{\n\tstruct icp_qat_uof_batch_init *init_header, *tail;\n\tstruct icp_qat_uof_batch_init *mem_init, *tail_old;\n\tstruct icp_qat_uof_memvar_attr *mem_val_attr;\n\tunsigned int i, flag = 0;\n\n\tmem_val_attr =\n\t\t(struct icp_qat_uof_memvar_attr *)((uintptr_t)init_mem +\n\t\tsizeof(struct icp_qat_uof_initmem));\n\n\tinit_header = *init_tab_base;\n\tif (!init_header) {\n\t\tinit_header = kzalloc(sizeof(*init_header), GFP_KERNEL);\n\t\tif (!init_header)\n\t\t\treturn -ENOMEM;\n\t\tinit_header->size = 1;\n\t\t*init_tab_base = init_header;\n\t\tflag = 1;\n\t}\n\ttail_old = init_header;\n\twhile (tail_old->next)\n\t\ttail_old = tail_old->next;\n\ttail = tail_old;\n\tfor (i = 0; i < init_mem->val_attr_num; i++) {\n\t\tmem_init = kzalloc(sizeof(*mem_init), GFP_KERNEL);\n\t\tif (!mem_init)\n\t\t\tgoto out_err;\n\t\tmem_init->ae = ae;\n\t\tmem_init->addr = init_mem->addr + mem_val_attr->offset_in_byte;\n\t\tmem_init->value = &mem_val_attr->value;\n\t\tmem_init->size = 4;\n\t\tmem_init->next = NULL;\n\t\ttail->next = mem_init;\n\t\ttail = mem_init;\n\t\tinit_header->size += qat_hal_get_ins_num();\n\t\tmem_val_attr++;\n\t}\n\treturn 0;\nout_err:\n\t \n\ttail_old = tail_old->next;\n\tif (flag) {\n\t\tkfree(*init_tab_base);\n\t\t*init_tab_base = NULL;\n\t}\n\n\twhile (tail_old) {\n\t\tmem_init = tail_old->next;\n\t\tkfree(tail_old);\n\t\ttail_old = mem_init;\n\t}\n\treturn -ENOMEM;\n}\n\nstatic int qat_uclo_init_lmem_seg(struct icp_qat_fw_loader_handle *handle,\n\t\t\t\t  struct icp_qat_uof_initmem *init_mem)\n{\n\tstruct icp_qat_uclo_objhandle *obj_handle = handle->obj_handle;\n\tunsigned int ae;\n\n\tif (qat_uclo_fetch_initmem_ae(handle, init_mem,\n\t\t\t\t      handle->chip_info->lm_size, &ae))\n\t\treturn -EINVAL;\n\tif (qat_uclo_create_batch_init_list(handle, init_mem, ae,\n\t\t\t\t\t    &obj_handle->lm_init_tab[ae]))\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic int qat_uclo_init_umem_seg(struct icp_qat_fw_loader_handle *handle,\n\t\t\t\t  struct icp_qat_uof_initmem *init_mem)\n{\n\tstruct icp_qat_uclo_objhandle *obj_handle = handle->obj_handle;\n\tunsigned int ae, ustore_size, uaddr, i;\n\tstruct icp_qat_uclo_aedata *aed;\n\n\tustore_size = obj_handle->ustore_phy_size;\n\tif (qat_uclo_fetch_initmem_ae(handle, init_mem, ustore_size, &ae))\n\t\treturn -EINVAL;\n\tif (qat_uclo_create_batch_init_list(handle, init_mem, ae,\n\t\t\t\t\t    &obj_handle->umem_init_tab[ae]))\n\t\treturn -EINVAL;\n\t \n\tuaddr = (init_mem->addr + init_mem->num_in_bytes) >> 0x2;\n\taed = &obj_handle->ae_data[ae];\n\tfor (i = 0; i < aed->slice_num; i++) {\n\t\tif (aed->ae_slices[i].encap_image->uwords_num < uaddr)\n\t\t\taed->ae_slices[i].encap_image->uwords_num = uaddr;\n\t}\n\treturn 0;\n}\n\nstatic int qat_uclo_init_ae_memory(struct icp_qat_fw_loader_handle *handle,\n\t\t\t\t   struct icp_qat_uof_initmem *init_mem)\n{\n\tswitch (init_mem->region) {\n\tcase ICP_QAT_UOF_LMEM_REGION:\n\t\tif (qat_uclo_init_lmem_seg(handle, init_mem))\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase ICP_QAT_UOF_UMEM_REGION:\n\t\tif (qat_uclo_init_umem_seg(handle, init_mem))\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"QAT: initmem region error. region type=0x%x\\n\",\n\t\t       init_mem->region);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int qat_uclo_init_ustore(struct icp_qat_fw_loader_handle *handle,\n\t\t\t\tstruct icp_qat_uclo_encapme *image)\n{\n\tunsigned int i;\n\tstruct icp_qat_uclo_encap_page *page;\n\tstruct icp_qat_uof_image *uof_image;\n\tunsigned char ae;\n\tunsigned int ustore_size;\n\tunsigned int patt_pos;\n\tstruct icp_qat_uclo_objhandle *obj_handle = handle->obj_handle;\n\tunsigned long ae_mask = handle->hal_handle->ae_mask;\n\tunsigned long cfg_ae_mask = handle->cfg_ae_mask;\n\tu64 *fill_data;\n\n\tuof_image = image->img_ptr;\n\tfill_data = kcalloc(ICP_QAT_UCLO_MAX_USTORE, sizeof(u64),\n\t\t\t    GFP_KERNEL);\n\tif (!fill_data)\n\t\treturn -ENOMEM;\n\tfor (i = 0; i < ICP_QAT_UCLO_MAX_USTORE; i++)\n\t\tmemcpy(&fill_data[i], &uof_image->fill_pattern,\n\t\t       sizeof(u64));\n\tpage = image->page;\n\n\tfor_each_set_bit(ae, &ae_mask, handle->hal_handle->ae_max_num) {\n\t\tunsigned long ae_assigned = uof_image->ae_assigned;\n\n\t\tif (!test_bit(ae, &ae_assigned))\n\t\t\tcontinue;\n\n\t\tif (!test_bit(ae, &cfg_ae_mask))\n\t\t\tcontinue;\n\n\t\tustore_size = obj_handle->ae_data[ae].eff_ustore_size;\n\t\tpatt_pos = page->beg_addr_p + page->micro_words_num;\n\n\t\tqat_hal_wr_uwords(handle, (unsigned char)ae, 0,\n\t\t\t\t  page->beg_addr_p, &fill_data[0]);\n\t\tqat_hal_wr_uwords(handle, (unsigned char)ae, patt_pos,\n\t\t\t\t  ustore_size - patt_pos + 1,\n\t\t\t\t  &fill_data[page->beg_addr_p]);\n\t}\n\tkfree(fill_data);\n\treturn 0;\n}\n\nstatic int qat_uclo_init_memory(struct icp_qat_fw_loader_handle *handle)\n{\n\tint i, ae;\n\tstruct icp_qat_uclo_objhandle *obj_handle = handle->obj_handle;\n\tstruct icp_qat_uof_initmem *initmem = obj_handle->init_mem_tab.init_mem;\n\tunsigned long ae_mask = handle->hal_handle->ae_mask;\n\n\tfor (i = 0; i < obj_handle->init_mem_tab.entry_num; i++) {\n\t\tif (initmem->num_in_bytes) {\n\t\t\tif (qat_uclo_init_ae_memory(handle, initmem))\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\tinitmem = (struct icp_qat_uof_initmem *)((uintptr_t)(\n\t\t\t(uintptr_t)initmem +\n\t\t\tsizeof(struct icp_qat_uof_initmem)) +\n\t\t\t(sizeof(struct icp_qat_uof_memvar_attr) *\n\t\t\tinitmem->val_attr_num));\n\t}\n\n\tfor_each_set_bit(ae, &ae_mask, handle->hal_handle->ae_max_num) {\n\t\tif (qat_hal_batch_wr_lm(handle, ae,\n\t\t\t\t\tobj_handle->lm_init_tab[ae])) {\n\t\t\tpr_err(\"QAT: fail to batch init lmem for AE %d\\n\", ae);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tqat_uclo_cleanup_batch_init_list(handle,\n\t\t\t\t\t\t &obj_handle->lm_init_tab[ae]);\n\t\tqat_uclo_batch_wr_umem(handle, ae,\n\t\t\t\t       obj_handle->umem_init_tab[ae]);\n\t\tqat_uclo_cleanup_batch_init_list(handle,\n\t\t\t\t\t\t &obj_handle->\n\t\t\t\t\t\t umem_init_tab[ae]);\n\t}\n\treturn 0;\n}\n\nstatic void *qat_uclo_find_chunk(struct icp_qat_uof_objhdr *obj_hdr,\n\t\t\t\t char *chunk_id, void *cur)\n{\n\tint i;\n\tstruct icp_qat_uof_chunkhdr *chunk_hdr =\n\t    (struct icp_qat_uof_chunkhdr *)\n\t    ((uintptr_t)obj_hdr + sizeof(struct icp_qat_uof_objhdr));\n\n\tfor (i = 0; i < obj_hdr->num_chunks; i++) {\n\t\tif ((cur < (void *)&chunk_hdr[i]) &&\n\t\t    !strncmp(chunk_hdr[i].chunk_id, chunk_id,\n\t\t\t     ICP_QAT_UOF_OBJID_LEN)) {\n\t\t\treturn &chunk_hdr[i];\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic unsigned int qat_uclo_calc_checksum(unsigned int reg, int ch)\n{\n\tint i;\n\tunsigned int topbit = 1 << 0xF;\n\tunsigned int inbyte = (unsigned int)((reg >> 0x18) ^ ch);\n\n\treg ^= inbyte << 0x8;\n\tfor (i = 0; i < 0x8; i++) {\n\t\tif (reg & topbit)\n\t\t\treg = (reg << 1) ^ 0x1021;\n\t\telse\n\t\t\treg <<= 1;\n\t}\n\treturn reg & 0xFFFF;\n}\n\nstatic unsigned int qat_uclo_calc_str_checksum(char *ptr, int num)\n{\n\tunsigned int chksum = 0;\n\n\tif (ptr)\n\t\twhile (num--)\n\t\t\tchksum = qat_uclo_calc_checksum(chksum, *ptr++);\n\treturn chksum;\n}\n\nstatic struct icp_qat_uclo_objhdr *\nqat_uclo_map_chunk(char *buf, struct icp_qat_uof_filehdr *file_hdr,\n\t\t   char *chunk_id)\n{\n\tstruct icp_qat_uof_filechunkhdr *file_chunk;\n\tstruct icp_qat_uclo_objhdr *obj_hdr;\n\tchar *chunk;\n\tint i;\n\n\tfile_chunk = (struct icp_qat_uof_filechunkhdr *)\n\t\t(buf + sizeof(struct icp_qat_uof_filehdr));\n\tfor (i = 0; i < file_hdr->num_chunks; i++) {\n\t\tif (!strncmp(file_chunk->chunk_id, chunk_id,\n\t\t\t     ICP_QAT_UOF_OBJID_LEN)) {\n\t\t\tchunk = buf + file_chunk->offset;\n\t\t\tif (file_chunk->checksum != qat_uclo_calc_str_checksum(\n\t\t\t\tchunk, file_chunk->size))\n\t\t\t\tbreak;\n\t\t\tobj_hdr = kzalloc(sizeof(*obj_hdr), GFP_KERNEL);\n\t\t\tif (!obj_hdr)\n\t\t\t\tbreak;\n\t\t\tobj_hdr->file_buff = chunk;\n\t\t\tobj_hdr->checksum = file_chunk->checksum;\n\t\t\tobj_hdr->size = file_chunk->size;\n\t\t\treturn obj_hdr;\n\t\t}\n\t\tfile_chunk++;\n\t}\n\treturn NULL;\n}\n\nstatic int\nqat_uclo_check_image_compat(struct icp_qat_uof_encap_obj *encap_uof_obj,\n\t\t\t    struct icp_qat_uof_image *image)\n{\n\tstruct icp_qat_uof_objtable *uc_var_tab, *imp_var_tab, *imp_expr_tab;\n\tstruct icp_qat_uof_objtable *neigh_reg_tab;\n\tstruct icp_qat_uof_code_page *code_page;\n\n\tcode_page = (struct icp_qat_uof_code_page *)\n\t\t\t((char *)image + sizeof(struct icp_qat_uof_image));\n\tuc_var_tab = (struct icp_qat_uof_objtable *)(encap_uof_obj->beg_uof +\n\t\t     code_page->uc_var_tab_offset);\n\timp_var_tab = (struct icp_qat_uof_objtable *)(encap_uof_obj->beg_uof +\n\t\t      code_page->imp_var_tab_offset);\n\timp_expr_tab = (struct icp_qat_uof_objtable *)\n\t\t       (encap_uof_obj->beg_uof +\n\t\t       code_page->imp_expr_tab_offset);\n\tif (uc_var_tab->entry_num || imp_var_tab->entry_num ||\n\t    imp_expr_tab->entry_num) {\n\t\tpr_err(\"QAT: UOF can't contain imported variable to be parsed\\n\");\n\t\treturn -EINVAL;\n\t}\n\tneigh_reg_tab = (struct icp_qat_uof_objtable *)\n\t\t\t(encap_uof_obj->beg_uof +\n\t\t\tcode_page->neigh_reg_tab_offset);\n\tif (neigh_reg_tab->entry_num) {\n\t\tpr_err(\"QAT: UOF can't contain neighbor register table\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (image->numpages > 1) {\n\t\tpr_err(\"QAT: UOF can't contain multiple pages\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (ICP_QAT_SHARED_USTORE_MODE(image->ae_mode)) {\n\t\tpr_err(\"QAT: UOF can't use shared control store feature\\n\");\n\t\treturn -EFAULT;\n\t}\n\tif (RELOADABLE_CTX_SHARED_MODE(image->ae_mode)) {\n\t\tpr_err(\"QAT: UOF can't use reloadable feature\\n\");\n\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}\n\nstatic void qat_uclo_map_image_page(struct icp_qat_uof_encap_obj\n\t\t\t\t     *encap_uof_obj,\n\t\t\t\t     struct icp_qat_uof_image *img,\n\t\t\t\t     struct icp_qat_uclo_encap_page *page)\n{\n\tstruct icp_qat_uof_code_page *code_page;\n\tstruct icp_qat_uof_code_area *code_area;\n\tstruct icp_qat_uof_objtable *uword_block_tab;\n\tstruct icp_qat_uof_uword_block *uwblock;\n\tint i;\n\n\tcode_page = (struct icp_qat_uof_code_page *)\n\t\t\t((char *)img + sizeof(struct icp_qat_uof_image));\n\tpage->def_page = code_page->def_page;\n\tpage->page_region = code_page->page_region;\n\tpage->beg_addr_v = code_page->beg_addr_v;\n\tpage->beg_addr_p = code_page->beg_addr_p;\n\tcode_area = (struct icp_qat_uof_code_area *)(encap_uof_obj->beg_uof +\n\t\t\t\t\t\tcode_page->code_area_offset);\n\tpage->micro_words_num = code_area->micro_words_num;\n\tuword_block_tab = (struct icp_qat_uof_objtable *)\n\t\t\t  (encap_uof_obj->beg_uof +\n\t\t\t  code_area->uword_block_tab);\n\tpage->uwblock_num = uword_block_tab->entry_num;\n\tuwblock = (struct icp_qat_uof_uword_block *)((char *)uword_block_tab +\n\t\t\tsizeof(struct icp_qat_uof_objtable));\n\tpage->uwblock = (struct icp_qat_uclo_encap_uwblock *)uwblock;\n\tfor (i = 0; i < uword_block_tab->entry_num; i++)\n\t\tpage->uwblock[i].micro_words =\n\t\t(uintptr_t)encap_uof_obj->beg_uof + uwblock[i].uword_offset;\n}\n\nstatic int qat_uclo_map_uimage(struct icp_qat_uclo_objhandle *obj_handle,\n\t\t\t       struct icp_qat_uclo_encapme *ae_uimage,\n\t\t\t       int max_image)\n{\n\tint i, j;\n\tstruct icp_qat_uof_chunkhdr *chunk_hdr = NULL;\n\tstruct icp_qat_uof_image *image;\n\tstruct icp_qat_uof_objtable *ae_regtab;\n\tstruct icp_qat_uof_objtable *init_reg_sym_tab;\n\tstruct icp_qat_uof_objtable *sbreak_tab;\n\tstruct icp_qat_uof_encap_obj *encap_uof_obj =\n\t\t\t\t\t&obj_handle->encap_uof_obj;\n\n\tfor (j = 0; j < max_image; j++) {\n\t\tchunk_hdr = qat_uclo_find_chunk(encap_uof_obj->obj_hdr,\n\t\t\t\t\t\tICP_QAT_UOF_IMAG, chunk_hdr);\n\t\tif (!chunk_hdr)\n\t\t\tbreak;\n\t\timage = (struct icp_qat_uof_image *)(encap_uof_obj->beg_uof +\n\t\t\t\t\t\t     chunk_hdr->offset);\n\t\tae_regtab = (struct icp_qat_uof_objtable *)\n\t\t\t   (image->reg_tab_offset +\n\t\t\t   obj_handle->obj_hdr->file_buff);\n\t\tae_uimage[j].ae_reg_num = ae_regtab->entry_num;\n\t\tae_uimage[j].ae_reg = (struct icp_qat_uof_ae_reg *)\n\t\t\t(((char *)ae_regtab) +\n\t\t\tsizeof(struct icp_qat_uof_objtable));\n\t\tinit_reg_sym_tab = (struct icp_qat_uof_objtable *)\n\t\t\t\t   (image->init_reg_sym_tab +\n\t\t\t\t   obj_handle->obj_hdr->file_buff);\n\t\tae_uimage[j].init_regsym_num = init_reg_sym_tab->entry_num;\n\t\tae_uimage[j].init_regsym = (struct icp_qat_uof_init_regsym *)\n\t\t\t(((char *)init_reg_sym_tab) +\n\t\t\tsizeof(struct icp_qat_uof_objtable));\n\t\tsbreak_tab = (struct icp_qat_uof_objtable *)\n\t\t\t(image->sbreak_tab + obj_handle->obj_hdr->file_buff);\n\t\tae_uimage[j].sbreak_num = sbreak_tab->entry_num;\n\t\tae_uimage[j].sbreak = (struct icp_qat_uof_sbreak *)\n\t\t\t\t      (((char *)sbreak_tab) +\n\t\t\t\t      sizeof(struct icp_qat_uof_objtable));\n\t\tae_uimage[j].img_ptr = image;\n\t\tif (qat_uclo_check_image_compat(encap_uof_obj, image))\n\t\t\tgoto out_err;\n\t\tae_uimage[j].page =\n\t\t\tkzalloc(sizeof(struct icp_qat_uclo_encap_page),\n\t\t\t\tGFP_KERNEL);\n\t\tif (!ae_uimage[j].page)\n\t\t\tgoto out_err;\n\t\tqat_uclo_map_image_page(encap_uof_obj, image,\n\t\t\t\t\tae_uimage[j].page);\n\t}\n\treturn j;\nout_err:\n\tfor (i = 0; i < j; i++)\n\t\tkfree(ae_uimage[i].page);\n\treturn 0;\n}\n\nstatic int qat_uclo_map_ae(struct icp_qat_fw_loader_handle *handle, int max_ae)\n{\n\tint i, ae;\n\tint mflag = 0;\n\tstruct icp_qat_uclo_objhandle *obj_handle = handle->obj_handle;\n\tunsigned long ae_mask = handle->hal_handle->ae_mask;\n\tunsigned long cfg_ae_mask = handle->cfg_ae_mask;\n\n\tfor_each_set_bit(ae, &ae_mask, max_ae) {\n\t\tif (!test_bit(ae, &cfg_ae_mask))\n\t\t\tcontinue;\n\n\t\tfor (i = 0; i < obj_handle->uimage_num; i++) {\n\t\t\tunsigned long ae_assigned = obj_handle->ae_uimage[i].img_ptr->ae_assigned;\n\n\t\t\tif (!test_bit(ae, &ae_assigned))\n\t\t\t\tcontinue;\n\t\t\tmflag = 1;\n\t\t\tif (qat_uclo_init_ae_data(obj_handle, ae, i))\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tif (!mflag) {\n\t\tpr_err(\"QAT: uimage uses AE not set\\n\");\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic struct icp_qat_uof_strtable *\nqat_uclo_map_str_table(struct icp_qat_uclo_objhdr *obj_hdr,\n\t\t       char *tab_name, struct icp_qat_uof_strtable *str_table)\n{\n\tstruct icp_qat_uof_chunkhdr *chunk_hdr;\n\n\tchunk_hdr = qat_uclo_find_chunk((struct icp_qat_uof_objhdr *)\n\t\t\t\t\tobj_hdr->file_buff, tab_name, NULL);\n\tif (chunk_hdr) {\n\t\tint hdr_size;\n\n\t\tmemcpy(&str_table->table_len, obj_hdr->file_buff +\n\t\t       chunk_hdr->offset, sizeof(str_table->table_len));\n\t\thdr_size = (char *)&str_table->strings - (char *)str_table;\n\t\tstr_table->strings = (uintptr_t)obj_hdr->file_buff +\n\t\t\t\t\tchunk_hdr->offset + hdr_size;\n\t\treturn str_table;\n\t}\n\treturn NULL;\n}\n\nstatic void\nqat_uclo_map_initmem_table(struct icp_qat_uof_encap_obj *encap_uof_obj,\n\t\t\t   struct icp_qat_uclo_init_mem_table *init_mem_tab)\n{\n\tstruct icp_qat_uof_chunkhdr *chunk_hdr;\n\n\tchunk_hdr = qat_uclo_find_chunk(encap_uof_obj->obj_hdr,\n\t\t\t\t\tICP_QAT_UOF_IMEM, NULL);\n\tif (chunk_hdr) {\n\t\tmemmove(&init_mem_tab->entry_num, encap_uof_obj->beg_uof +\n\t\t\tchunk_hdr->offset, sizeof(unsigned int));\n\t\tinit_mem_tab->init_mem = (struct icp_qat_uof_initmem *)\n\t\t(encap_uof_obj->beg_uof + chunk_hdr->offset +\n\t\tsizeof(unsigned int));\n\t}\n}\n\nstatic unsigned int\nqat_uclo_get_dev_type(struct icp_qat_fw_loader_handle *handle)\n{\n\tswitch (handle->pci_dev->device) {\n\tcase PCI_DEVICE_ID_INTEL_QAT_DH895XCC:\n\t\treturn ICP_QAT_AC_895XCC_DEV_TYPE;\n\tcase PCI_DEVICE_ID_INTEL_QAT_C62X:\n\t\treturn ICP_QAT_AC_C62X_DEV_TYPE;\n\tcase PCI_DEVICE_ID_INTEL_QAT_C3XXX:\n\t\treturn ICP_QAT_AC_C3XXX_DEV_TYPE;\n\tcase ADF_4XXX_PCI_DEVICE_ID:\n\tcase ADF_401XX_PCI_DEVICE_ID:\n\tcase ADF_402XX_PCI_DEVICE_ID:\n\t\treturn ICP_QAT_AC_4XXX_A_DEV_TYPE;\n\tdefault:\n\t\tpr_err(\"QAT: unsupported device 0x%x\\n\",\n\t\t       handle->pci_dev->device);\n\t\treturn 0;\n\t}\n}\n\nstatic int qat_uclo_check_uof_compat(struct icp_qat_uclo_objhandle *obj_handle)\n{\n\tunsigned int maj_ver, prod_type = obj_handle->prod_type;\n\n\tif (!(prod_type & obj_handle->encap_uof_obj.obj_hdr->ac_dev_type)) {\n\t\tpr_err(\"QAT: UOF type 0x%x doesn't match with platform 0x%x\\n\",\n\t\t       obj_handle->encap_uof_obj.obj_hdr->ac_dev_type,\n\t\t       prod_type);\n\t\treturn -EINVAL;\n\t}\n\tmaj_ver = obj_handle->prod_rev & 0xff;\n\tif (obj_handle->encap_uof_obj.obj_hdr->max_cpu_ver < maj_ver ||\n\t    obj_handle->encap_uof_obj.obj_hdr->min_cpu_ver > maj_ver) {\n\t\tpr_err(\"QAT: UOF majVer 0x%x out of range\\n\", maj_ver);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int qat_uclo_init_reg(struct icp_qat_fw_loader_handle *handle,\n\t\t\t     unsigned char ae, unsigned char ctx_mask,\n\t\t\t     enum icp_qat_uof_regtype reg_type,\n\t\t\t     unsigned short reg_addr, unsigned int value)\n{\n\tswitch (reg_type) {\n\tcase ICP_GPA_ABS:\n\tcase ICP_GPB_ABS:\n\t\tctx_mask = 0;\n\t\tfallthrough;\n\tcase ICP_GPA_REL:\n\tcase ICP_GPB_REL:\n\t\treturn qat_hal_init_gpr(handle, ae, ctx_mask, reg_type,\n\t\t\t\t\treg_addr, value);\n\tcase ICP_SR_ABS:\n\tcase ICP_DR_ABS:\n\tcase ICP_SR_RD_ABS:\n\tcase ICP_DR_RD_ABS:\n\t\tctx_mask = 0;\n\t\tfallthrough;\n\tcase ICP_SR_REL:\n\tcase ICP_DR_REL:\n\tcase ICP_SR_RD_REL:\n\tcase ICP_DR_RD_REL:\n\t\treturn qat_hal_init_rd_xfer(handle, ae, ctx_mask, reg_type,\n\t\t\t\t\t    reg_addr, value);\n\tcase ICP_SR_WR_ABS:\n\tcase ICP_DR_WR_ABS:\n\t\tctx_mask = 0;\n\t\tfallthrough;\n\tcase ICP_SR_WR_REL:\n\tcase ICP_DR_WR_REL:\n\t\treturn qat_hal_init_wr_xfer(handle, ae, ctx_mask, reg_type,\n\t\t\t\t\t    reg_addr, value);\n\tcase ICP_NEIGH_REL:\n\t\treturn qat_hal_init_nn(handle, ae, ctx_mask, reg_addr, value);\n\tdefault:\n\t\tpr_err(\"QAT: UOF uses not supported reg type 0x%x\\n\", reg_type);\n\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}\n\nstatic int qat_uclo_init_reg_sym(struct icp_qat_fw_loader_handle *handle,\n\t\t\t\t unsigned int ae,\n\t\t\t\t struct icp_qat_uclo_encapme *encap_ae)\n{\n\tunsigned int i;\n\tunsigned char ctx_mask;\n\tstruct icp_qat_uof_init_regsym *init_regsym;\n\n\tif (ICP_QAT_CTX_MODE(encap_ae->img_ptr->ae_mode) ==\n\t    ICP_QAT_UCLO_MAX_CTX)\n\t\tctx_mask = 0xff;\n\telse\n\t\tctx_mask = 0x55;\n\n\tfor (i = 0; i < encap_ae->init_regsym_num; i++) {\n\t\tunsigned int exp_res;\n\n\t\tinit_regsym = &encap_ae->init_regsym[i];\n\t\texp_res = init_regsym->value;\n\t\tswitch (init_regsym->init_type) {\n\t\tcase ICP_QAT_UOF_INIT_REG:\n\t\t\tqat_uclo_init_reg(handle, ae, ctx_mask,\n\t\t\t\t\t  (enum icp_qat_uof_regtype)\n\t\t\t\t\t  init_regsym->reg_type,\n\t\t\t\t\t  (unsigned short)init_regsym->reg_addr,\n\t\t\t\t\t  exp_res);\n\t\t\tbreak;\n\t\tcase ICP_QAT_UOF_INIT_REG_CTX:\n\t\t\t \n\t\t\tif (!((1 << init_regsym->ctx) & ctx_mask)) {\n\t\t\t\tpr_err(\"QAT: invalid ctx num = 0x%x\\n\",\n\t\t\t\t       init_regsym->ctx);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tqat_uclo_init_reg(handle, ae,\n\t\t\t\t\t  (unsigned char)\n\t\t\t\t\t  (1 << init_regsym->ctx),\n\t\t\t\t\t  (enum icp_qat_uof_regtype)\n\t\t\t\t\t  init_regsym->reg_type,\n\t\t\t\t\t  (unsigned short)init_regsym->reg_addr,\n\t\t\t\t\t  exp_res);\n\t\t\tbreak;\n\t\tcase ICP_QAT_UOF_INIT_EXPR:\n\t\t\tpr_err(\"QAT: INIT_EXPR feature not supported\\n\");\n\t\t\treturn -EINVAL;\n\t\tcase ICP_QAT_UOF_INIT_EXPR_ENDIAN_SWAP:\n\t\t\tpr_err(\"QAT: INIT_EXPR_ENDIAN_SWAP feature not supported\\n\");\n\t\t\treturn -EINVAL;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int qat_uclo_init_globals(struct icp_qat_fw_loader_handle *handle)\n{\n\tstruct icp_qat_uclo_objhandle *obj_handle = handle->obj_handle;\n\tunsigned long ae_mask = handle->hal_handle->ae_mask;\n\tstruct icp_qat_uclo_aedata *aed;\n\tunsigned int s, ae;\n\n\tif (obj_handle->global_inited)\n\t\treturn 0;\n\tif (obj_handle->init_mem_tab.entry_num) {\n\t\tif (qat_uclo_init_memory(handle)) {\n\t\t\tpr_err(\"QAT: initialize memory failed\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tfor_each_set_bit(ae, &ae_mask, handle->hal_handle->ae_max_num) {\n\t\taed = &obj_handle->ae_data[ae];\n\t\tfor (s = 0; s < aed->slice_num; s++) {\n\t\t\tif (!aed->ae_slices[s].encap_image)\n\t\t\t\tcontinue;\n\t\t\tif (qat_uclo_init_reg_sym(handle, ae, aed->ae_slices[s].encap_image))\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tobj_handle->global_inited = 1;\n\treturn 0;\n}\n\nstatic int qat_hal_set_modes(struct icp_qat_fw_loader_handle *handle,\n\t\t\t     struct icp_qat_uclo_objhandle *obj_handle,\n\t\t\t     unsigned char ae,\n\t\t\t     struct icp_qat_uof_image *uof_image)\n{\n\tunsigned char mode;\n\tint ret;\n\n\tmode = ICP_QAT_CTX_MODE(uof_image->ae_mode);\n\tret = qat_hal_set_ae_ctx_mode(handle, ae, mode);\n\tif (ret) {\n\t\tpr_err(\"QAT: qat_hal_set_ae_ctx_mode error\\n\");\n\t\treturn ret;\n\t}\n\tif (handle->chip_info->nn) {\n\t\tmode = ICP_QAT_NN_MODE(uof_image->ae_mode);\n\t\tret = qat_hal_set_ae_nn_mode(handle, ae, mode);\n\t\tif (ret) {\n\t\t\tpr_err(\"QAT: qat_hal_set_ae_nn_mode error\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\tmode = ICP_QAT_LOC_MEM0_MODE(uof_image->ae_mode);\n\tret = qat_hal_set_ae_lm_mode(handle, ae, ICP_LMEM0, mode);\n\tif (ret) {\n\t\tpr_err(\"QAT: qat_hal_set_ae_lm_mode LMEM0 error\\n\");\n\t\treturn ret;\n\t}\n\tmode = ICP_QAT_LOC_MEM1_MODE(uof_image->ae_mode);\n\tret = qat_hal_set_ae_lm_mode(handle, ae, ICP_LMEM1, mode);\n\tif (ret) {\n\t\tpr_err(\"QAT: qat_hal_set_ae_lm_mode LMEM1 error\\n\");\n\t\treturn ret;\n\t}\n\tif (handle->chip_info->lm2lm3) {\n\t\tmode = ICP_QAT_LOC_MEM2_MODE(uof_image->ae_mode);\n\t\tret = qat_hal_set_ae_lm_mode(handle, ae, ICP_LMEM2, mode);\n\t\tif (ret) {\n\t\t\tpr_err(\"QAT: qat_hal_set_ae_lm_mode LMEM2 error\\n\");\n\t\t\treturn ret;\n\t\t}\n\t\tmode = ICP_QAT_LOC_MEM3_MODE(uof_image->ae_mode);\n\t\tret = qat_hal_set_ae_lm_mode(handle, ae, ICP_LMEM3, mode);\n\t\tif (ret) {\n\t\t\tpr_err(\"QAT: qat_hal_set_ae_lm_mode LMEM3 error\\n\");\n\t\t\treturn ret;\n\t\t}\n\t\tmode = ICP_QAT_LOC_TINDEX_MODE(uof_image->ae_mode);\n\t\tqat_hal_set_ae_tindex_mode(handle, ae, mode);\n\t}\n\treturn 0;\n}\n\nstatic int qat_uclo_set_ae_mode(struct icp_qat_fw_loader_handle *handle)\n{\n\tstruct icp_qat_uof_image *uof_image;\n\tstruct icp_qat_uclo_aedata *ae_data;\n\tstruct icp_qat_uclo_objhandle *obj_handle = handle->obj_handle;\n\tunsigned long ae_mask = handle->hal_handle->ae_mask;\n\tunsigned long cfg_ae_mask = handle->cfg_ae_mask;\n\tunsigned char ae, s;\n\tint error;\n\n\tfor_each_set_bit(ae, &ae_mask, handle->hal_handle->ae_max_num) {\n\t\tif (!test_bit(ae, &cfg_ae_mask))\n\t\t\tcontinue;\n\n\t\tae_data = &obj_handle->ae_data[ae];\n\t\tfor (s = 0; s < min_t(unsigned int, ae_data->slice_num,\n\t\t\t\t      ICP_QAT_UCLO_MAX_CTX); s++) {\n\t\t\tif (!obj_handle->ae_data[ae].ae_slices[s].encap_image)\n\t\t\t\tcontinue;\n\t\t\tuof_image = ae_data->ae_slices[s].encap_image->img_ptr;\n\t\t\terror = qat_hal_set_modes(handle, obj_handle, ae,\n\t\t\t\t\t\t  uof_image);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void qat_uclo_init_uword_num(struct icp_qat_fw_loader_handle *handle)\n{\n\tstruct icp_qat_uclo_objhandle *obj_handle = handle->obj_handle;\n\tstruct icp_qat_uclo_encapme *image;\n\tint a;\n\n\tfor (a = 0; a < obj_handle->uimage_num; a++) {\n\t\timage = &obj_handle->ae_uimage[a];\n\t\timage->uwords_num = image->page->beg_addr_p +\n\t\t\t\t\timage->page->micro_words_num;\n\t}\n}\n\nstatic int qat_uclo_parse_uof_obj(struct icp_qat_fw_loader_handle *handle)\n{\n\tstruct icp_qat_uclo_objhandle *obj_handle = handle->obj_handle;\n\tunsigned int ae;\n\n\tobj_handle->encap_uof_obj.beg_uof = obj_handle->obj_hdr->file_buff;\n\tobj_handle->encap_uof_obj.obj_hdr = (struct icp_qat_uof_objhdr *)\n\t\t\t\t\t     obj_handle->obj_hdr->file_buff;\n\tobj_handle->uword_in_bytes = 6;\n\tobj_handle->prod_type = qat_uclo_get_dev_type(handle);\n\tobj_handle->prod_rev = PID_MAJOR_REV |\n\t\t\t(PID_MINOR_REV & handle->hal_handle->revision_id);\n\tif (qat_uclo_check_uof_compat(obj_handle)) {\n\t\tpr_err(\"QAT: UOF incompatible\\n\");\n\t\treturn -EINVAL;\n\t}\n\tobj_handle->uword_buf = kcalloc(UWORD_CPYBUF_SIZE, sizeof(u64),\n\t\t\t\t\tGFP_KERNEL);\n\tif (!obj_handle->uword_buf)\n\t\treturn -ENOMEM;\n\tobj_handle->ustore_phy_size = ICP_QAT_UCLO_MAX_USTORE;\n\tif (!obj_handle->obj_hdr->file_buff ||\n\t    !qat_uclo_map_str_table(obj_handle->obj_hdr, ICP_QAT_UOF_STRT,\n\t\t\t\t    &obj_handle->str_table)) {\n\t\tpr_err(\"QAT: UOF doesn't have effective images\\n\");\n\t\tgoto out_err;\n\t}\n\tobj_handle->uimage_num =\n\t\tqat_uclo_map_uimage(obj_handle, obj_handle->ae_uimage,\n\t\t\t\t    ICP_QAT_UCLO_MAX_AE * ICP_QAT_UCLO_MAX_CTX);\n\tif (!obj_handle->uimage_num)\n\t\tgoto out_err;\n\tif (qat_uclo_map_ae(handle, handle->hal_handle->ae_max_num)) {\n\t\tpr_err(\"QAT: Bad object\\n\");\n\t\tgoto out_check_uof_aemask_err;\n\t}\n\tqat_uclo_init_uword_num(handle);\n\tqat_uclo_map_initmem_table(&obj_handle->encap_uof_obj,\n\t\t\t\t   &obj_handle->init_mem_tab);\n\tif (qat_uclo_set_ae_mode(handle))\n\t\tgoto out_check_uof_aemask_err;\n\treturn 0;\nout_check_uof_aemask_err:\n\tfor (ae = 0; ae < obj_handle->uimage_num; ae++)\n\t\tkfree(obj_handle->ae_uimage[ae].page);\nout_err:\n\tkfree(obj_handle->uword_buf);\n\treturn -EFAULT;\n}\n\nstatic int qat_uclo_map_suof_file_hdr(struct icp_qat_fw_loader_handle *handle,\n\t\t\t\t      struct icp_qat_suof_filehdr *suof_ptr,\n\t\t\t\t      int suof_size)\n{\n\tunsigned int check_sum = 0;\n\tunsigned int min_ver_offset = 0;\n\tstruct icp_qat_suof_handle *suof_handle = handle->sobj_handle;\n\n\tsuof_handle->file_id = ICP_QAT_SUOF_FID;\n\tsuof_handle->suof_buf = (char *)suof_ptr;\n\tsuof_handle->suof_size = suof_size;\n\tmin_ver_offset = suof_size - offsetof(struct icp_qat_suof_filehdr,\n\t\t\t\t\t      min_ver);\n\tcheck_sum = qat_uclo_calc_str_checksum((char *)&suof_ptr->min_ver,\n\t\t\t\t\t       min_ver_offset);\n\tif (check_sum != suof_ptr->check_sum) {\n\t\tpr_err(\"QAT: incorrect SUOF checksum\\n\");\n\t\treturn -EINVAL;\n\t}\n\tsuof_handle->check_sum = suof_ptr->check_sum;\n\tsuof_handle->min_ver = suof_ptr->min_ver;\n\tsuof_handle->maj_ver = suof_ptr->maj_ver;\n\tsuof_handle->fw_type = suof_ptr->fw_type;\n\treturn 0;\n}\n\nstatic void qat_uclo_map_simg(struct icp_qat_fw_loader_handle *handle,\n\t\t\t      struct icp_qat_suof_img_hdr *suof_img_hdr,\n\t\t\t      struct icp_qat_suof_chunk_hdr *suof_chunk_hdr)\n{\n\tstruct icp_qat_suof_handle *suof_handle = handle->sobj_handle;\n\tstruct icp_qat_simg_ae_mode *ae_mode;\n\tstruct icp_qat_suof_objhdr *suof_objhdr;\n\n\tsuof_img_hdr->simg_buf  = (suof_handle->suof_buf +\n\t\t\t\t   suof_chunk_hdr->offset +\n\t\t\t\t   sizeof(*suof_objhdr));\n\tsuof_img_hdr->simg_len = ((struct icp_qat_suof_objhdr *)(uintptr_t)\n\t\t\t\t  (suof_handle->suof_buf +\n\t\t\t\t   suof_chunk_hdr->offset))->img_length;\n\n\tsuof_img_hdr->css_header = suof_img_hdr->simg_buf;\n\tsuof_img_hdr->css_key = (suof_img_hdr->css_header +\n\t\t\t\t sizeof(struct icp_qat_css_hdr));\n\tsuof_img_hdr->css_signature = suof_img_hdr->css_key +\n\t\t\t\t      ICP_QAT_CSS_FWSK_MODULUS_LEN(handle) +\n\t\t\t\t      ICP_QAT_CSS_FWSK_EXPONENT_LEN(handle);\n\tsuof_img_hdr->css_simg = suof_img_hdr->css_signature +\n\t\t\t\t ICP_QAT_CSS_SIGNATURE_LEN(handle);\n\n\tae_mode = (struct icp_qat_simg_ae_mode *)(suof_img_hdr->css_simg);\n\tsuof_img_hdr->ae_mask = ae_mode->ae_mask;\n\tsuof_img_hdr->simg_name = (unsigned long)&ae_mode->simg_name;\n\tsuof_img_hdr->appmeta_data = (unsigned long)&ae_mode->appmeta_data;\n\tsuof_img_hdr->fw_type = ae_mode->fw_type;\n}\n\nstatic void\nqat_uclo_map_suof_symobjs(struct icp_qat_suof_handle *suof_handle,\n\t\t\t  struct icp_qat_suof_chunk_hdr *suof_chunk_hdr)\n{\n\tchar **sym_str = (char **)&suof_handle->sym_str;\n\tunsigned int *sym_size = &suof_handle->sym_size;\n\tstruct icp_qat_suof_strtable *str_table_obj;\n\n\t*sym_size = *(unsigned int *)(uintptr_t)\n\t\t   (suof_chunk_hdr->offset + suof_handle->suof_buf);\n\t*sym_str = (char *)(uintptr_t)\n\t\t   (suof_handle->suof_buf + suof_chunk_hdr->offset +\n\t\t   sizeof(str_table_obj->tab_length));\n}\n\nstatic int qat_uclo_check_simg_compat(struct icp_qat_fw_loader_handle *handle,\n\t\t\t\t      struct icp_qat_suof_img_hdr *img_hdr)\n{\n\tstruct icp_qat_simg_ae_mode *img_ae_mode = NULL;\n\tunsigned int prod_rev, maj_ver, prod_type;\n\n\tprod_type = qat_uclo_get_dev_type(handle);\n\timg_ae_mode = (struct icp_qat_simg_ae_mode *)img_hdr->css_simg;\n\tprod_rev = PID_MAJOR_REV |\n\t\t\t (PID_MINOR_REV & handle->hal_handle->revision_id);\n\tif (img_ae_mode->dev_type != prod_type) {\n\t\tpr_err(\"QAT: incompatible product type %x\\n\",\n\t\t       img_ae_mode->dev_type);\n\t\treturn -EINVAL;\n\t}\n\tmaj_ver = prod_rev & 0xff;\n\tif (maj_ver > img_ae_mode->devmax_ver ||\n\t    maj_ver < img_ae_mode->devmin_ver) {\n\t\tpr_err(\"QAT: incompatible device majver 0x%x\\n\", maj_ver);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic void qat_uclo_del_suof(struct icp_qat_fw_loader_handle *handle)\n{\n\tstruct icp_qat_suof_handle *sobj_handle = handle->sobj_handle;\n\n\tkfree(sobj_handle->img_table.simg_hdr);\n\tsobj_handle->img_table.simg_hdr = NULL;\n\tkfree(handle->sobj_handle);\n\thandle->sobj_handle = NULL;\n}\n\nstatic void qat_uclo_tail_img(struct icp_qat_suof_img_hdr *suof_img_hdr,\n\t\t\t      unsigned int img_id, unsigned int num_simgs)\n{\n\tstruct icp_qat_suof_img_hdr img_header;\n\n\tif (img_id != num_simgs - 1) {\n\t\tmemcpy(&img_header, &suof_img_hdr[num_simgs - 1],\n\t\t       sizeof(*suof_img_hdr));\n\t\tmemcpy(&suof_img_hdr[num_simgs - 1], &suof_img_hdr[img_id],\n\t\t       sizeof(*suof_img_hdr));\n\t\tmemcpy(&suof_img_hdr[img_id], &img_header,\n\t\t       sizeof(*suof_img_hdr));\n\t}\n}\n\nstatic int qat_uclo_map_suof(struct icp_qat_fw_loader_handle *handle,\n\t\t\t     struct icp_qat_suof_filehdr *suof_ptr,\n\t\t\t     int suof_size)\n{\n\tstruct icp_qat_suof_handle *suof_handle = handle->sobj_handle;\n\tstruct icp_qat_suof_chunk_hdr *suof_chunk_hdr = NULL;\n\tstruct icp_qat_suof_img_hdr *suof_img_hdr = NULL;\n\tint ret = 0, ae0_img = ICP_QAT_UCLO_MAX_AE;\n\tunsigned int i = 0;\n\tstruct icp_qat_suof_img_hdr img_header;\n\n\tif (!suof_ptr || suof_size == 0) {\n\t\tpr_err(\"QAT: input parameter SUOF pointer/size is NULL\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (qat_uclo_check_suof_format(suof_ptr))\n\t\treturn -EINVAL;\n\tret = qat_uclo_map_suof_file_hdr(handle, suof_ptr, suof_size);\n\tif (ret)\n\t\treturn ret;\n\tsuof_chunk_hdr = (struct icp_qat_suof_chunk_hdr *)\n\t\t\t ((uintptr_t)suof_ptr + sizeof(*suof_ptr));\n\n\tqat_uclo_map_suof_symobjs(suof_handle, suof_chunk_hdr);\n\tsuof_handle->img_table.num_simgs = suof_ptr->num_chunks - 1;\n\n\tif (suof_handle->img_table.num_simgs != 0) {\n\t\tsuof_img_hdr = kcalloc(suof_handle->img_table.num_simgs,\n\t\t\t\t       sizeof(img_header),\n\t\t\t\t       GFP_KERNEL);\n\t\tif (!suof_img_hdr)\n\t\t\treturn -ENOMEM;\n\t\tsuof_handle->img_table.simg_hdr = suof_img_hdr;\n\n\t\tfor (i = 0; i < suof_handle->img_table.num_simgs; i++) {\n\t\t\tqat_uclo_map_simg(handle, &suof_img_hdr[i],\n\t\t\t\t\t  &suof_chunk_hdr[1 + i]);\n\t\t\tret = qat_uclo_check_simg_compat(handle,\n\t\t\t\t\t\t\t &suof_img_hdr[i]);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tsuof_img_hdr[i].ae_mask &= handle->cfg_ae_mask;\n\t\t\tif ((suof_img_hdr[i].ae_mask & 0x1) != 0)\n\t\t\t\tae0_img = i;\n\t\t}\n\n\t\tif (!handle->chip_info->tgroup_share_ustore) {\n\t\t\tqat_uclo_tail_img(suof_img_hdr, ae0_img,\n\t\t\t\t\t  suof_handle->img_table.num_simgs);\n\t\t}\n\t}\n\treturn 0;\n}\n\n#define ADD_ADDR(high, low)  ((((u64)high) << 32) + low)\n#define BITS_IN_DWORD 32\n\nstatic int qat_uclo_auth_fw(struct icp_qat_fw_loader_handle *handle,\n\t\t\t    struct icp_qat_fw_auth_desc *desc)\n{\n\tu32 fcu_sts, retry = 0;\n\tu32 fcu_ctl_csr, fcu_sts_csr;\n\tu32 fcu_dram_hi_csr, fcu_dram_lo_csr;\n\tu64 bus_addr;\n\n\tbus_addr = ADD_ADDR(desc->css_hdr_high, desc->css_hdr_low)\n\t\t\t   - sizeof(struct icp_qat_auth_chunk);\n\n\tfcu_ctl_csr = handle->chip_info->fcu_ctl_csr;\n\tfcu_sts_csr = handle->chip_info->fcu_sts_csr;\n\tfcu_dram_hi_csr = handle->chip_info->fcu_dram_addr_hi;\n\tfcu_dram_lo_csr = handle->chip_info->fcu_dram_addr_lo;\n\n\tSET_CAP_CSR(handle, fcu_dram_hi_csr, (bus_addr >> BITS_IN_DWORD));\n\tSET_CAP_CSR(handle, fcu_dram_lo_csr, bus_addr);\n\tSET_CAP_CSR(handle, fcu_ctl_csr, FCU_CTRL_CMD_AUTH);\n\n\tdo {\n\t\tmsleep(FW_AUTH_WAIT_PERIOD);\n\t\tfcu_sts = GET_CAP_CSR(handle, fcu_sts_csr);\n\t\tif ((fcu_sts & FCU_AUTH_STS_MASK) == FCU_STS_VERI_FAIL)\n\t\t\tgoto auth_fail;\n\t\tif (((fcu_sts >> FCU_STS_AUTHFWLD_POS) & 0x1))\n\t\t\tif ((fcu_sts & FCU_AUTH_STS_MASK) == FCU_STS_VERI_DONE)\n\t\t\t\treturn 0;\n\t} while (retry++ < FW_AUTH_MAX_RETRY);\nauth_fail:\n\tpr_err(\"QAT: authentication error (FCU_STATUS = 0x%x),retry = %d\\n\",\n\t       fcu_sts & FCU_AUTH_STS_MASK, retry);\n\treturn -EINVAL;\n}\n\nstatic bool qat_uclo_is_broadcast(struct icp_qat_fw_loader_handle *handle,\n\t\t\t\t  int imgid)\n{\n\tstruct icp_qat_suof_handle *sobj_handle;\n\n\tif (!handle->chip_info->tgroup_share_ustore)\n\t\treturn false;\n\n\tsobj_handle = (struct icp_qat_suof_handle *)handle->sobj_handle;\n\tif (handle->hal_handle->admin_ae_mask &\n\t    sobj_handle->img_table.simg_hdr[imgid].ae_mask)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic int qat_uclo_broadcast_load_fw(struct icp_qat_fw_loader_handle *handle,\n\t\t\t\t      struct icp_qat_fw_auth_desc *desc)\n{\n\tunsigned long ae_mask = handle->hal_handle->ae_mask;\n\tunsigned long desc_ae_mask = desc->ae_mask;\n\tu32 fcu_sts, ae_broadcast_mask = 0;\n\tu32 fcu_loaded_csr, ae_loaded;\n\tu32 fcu_sts_csr, fcu_ctl_csr;\n\tunsigned int ae, retry = 0;\n\n\tif (handle->chip_info->tgroup_share_ustore) {\n\t\tfcu_ctl_csr = handle->chip_info->fcu_ctl_csr;\n\t\tfcu_sts_csr = handle->chip_info->fcu_sts_csr;\n\t\tfcu_loaded_csr = handle->chip_info->fcu_loaded_ae_csr;\n\t} else {\n\t\tpr_err(\"Chip 0x%x doesn't support broadcast load\\n\",\n\t\t       handle->pci_dev->device);\n\t\treturn -EINVAL;\n\t}\n\n\tfor_each_set_bit(ae, &ae_mask, handle->hal_handle->ae_max_num) {\n\t\tif (qat_hal_check_ae_active(handle, (unsigned char)ae)) {\n\t\t\tpr_err(\"QAT: Broadcast load failed. AE is not enabled or active.\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (test_bit(ae, &desc_ae_mask))\n\t\t\tae_broadcast_mask |= 1 << ae;\n\t}\n\n\tif (ae_broadcast_mask) {\n\t\tSET_CAP_CSR(handle, FCU_ME_BROADCAST_MASK_TYPE,\n\t\t\t    ae_broadcast_mask);\n\n\t\tSET_CAP_CSR(handle, fcu_ctl_csr, FCU_CTRL_CMD_LOAD);\n\n\t\tdo {\n\t\t\tmsleep(FW_AUTH_WAIT_PERIOD);\n\t\t\tfcu_sts = GET_CAP_CSR(handle, fcu_sts_csr);\n\t\t\tfcu_sts &= FCU_AUTH_STS_MASK;\n\n\t\t\tif (fcu_sts == FCU_STS_LOAD_FAIL) {\n\t\t\t\tpr_err(\"Broadcast load failed: 0x%x)\\n\", fcu_sts);\n\t\t\t\treturn -EINVAL;\n\t\t\t} else if (fcu_sts == FCU_STS_LOAD_DONE) {\n\t\t\t\tae_loaded = GET_CAP_CSR(handle, fcu_loaded_csr);\n\t\t\t\tae_loaded >>= handle->chip_info->fcu_loaded_ae_pos;\n\n\t\t\t\tif ((ae_loaded & ae_broadcast_mask) == ae_broadcast_mask)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (retry++ < FW_AUTH_MAX_RETRY);\n\n\t\tif (retry > FW_AUTH_MAX_RETRY) {\n\t\t\tpr_err(\"QAT: broadcast load failed timeout %d\\n\", retry);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int qat_uclo_simg_alloc(struct icp_qat_fw_loader_handle *handle,\n\t\t\t       struct icp_firml_dram_desc *dram_desc,\n\t\t\t       unsigned int size)\n{\n\tvoid *vptr;\n\tdma_addr_t ptr;\n\n\tvptr = dma_alloc_coherent(&handle->pci_dev->dev,\n\t\t\t\t  size, &ptr, GFP_KERNEL);\n\tif (!vptr)\n\t\treturn -ENOMEM;\n\tdram_desc->dram_base_addr_v = vptr;\n\tdram_desc->dram_bus_addr = ptr;\n\tdram_desc->dram_size = size;\n\treturn 0;\n}\n\nstatic void qat_uclo_simg_free(struct icp_qat_fw_loader_handle *handle,\n\t\t\t       struct icp_firml_dram_desc *dram_desc)\n{\n\tif (handle && dram_desc && dram_desc->dram_base_addr_v) {\n\t\tdma_free_coherent(&handle->pci_dev->dev,\n\t\t\t\t  (size_t)(dram_desc->dram_size),\n\t\t\t\t  dram_desc->dram_base_addr_v,\n\t\t\t\t  dram_desc->dram_bus_addr);\n\t}\n\n\tif (dram_desc)\n\t\tmemset(dram_desc, 0, sizeof(*dram_desc));\n}\n\nstatic void qat_uclo_ummap_auth_fw(struct icp_qat_fw_loader_handle *handle,\n\t\t\t\t   struct icp_qat_fw_auth_desc **desc)\n{\n\tstruct icp_firml_dram_desc dram_desc;\n\n\tif (*desc) {\n\t\tdram_desc.dram_base_addr_v = *desc;\n\t\tdram_desc.dram_bus_addr = ((struct icp_qat_auth_chunk *)\n\t\t\t\t\t   (*desc))->chunk_bus_addr;\n\t\tdram_desc.dram_size = ((struct icp_qat_auth_chunk *)\n\t\t\t\t       (*desc))->chunk_size;\n\t\tqat_uclo_simg_free(handle, &dram_desc);\n\t}\n}\n\nstatic int qat_uclo_check_image(struct icp_qat_fw_loader_handle *handle,\n\t\t\t\tchar *image, unsigned int size,\n\t\t\t\tunsigned int fw_type)\n{\n\tchar *fw_type_name = fw_type ? \"MMP\" : \"AE\";\n\tunsigned int css_dword_size = sizeof(u32);\n\n\tif (handle->chip_info->fw_auth) {\n\t\tstruct icp_qat_css_hdr *css_hdr = (struct icp_qat_css_hdr *)image;\n\t\tunsigned int header_len = ICP_QAT_AE_IMG_OFFSET(handle);\n\n\t\tif ((css_hdr->header_len * css_dword_size) != header_len)\n\t\t\tgoto err;\n\t\tif ((css_hdr->size * css_dword_size) != size)\n\t\t\tgoto err;\n\t\tif (fw_type != css_hdr->fw_type)\n\t\t\tgoto err;\n\t\tif (size <= header_len)\n\t\t\tgoto err;\n\t\tsize -= header_len;\n\t}\n\n\tif (fw_type == CSS_AE_FIRMWARE) {\n\t\tif (size < sizeof(struct icp_qat_simg_ae_mode *) +\n\t\t    ICP_QAT_SIMG_AE_INIT_SEQ_LEN)\n\t\t\tgoto err;\n\t\tif (size > ICP_QAT_CSS_RSA4K_MAX_IMAGE_LEN)\n\t\t\tgoto err;\n\t} else if (fw_type == CSS_MMP_FIRMWARE) {\n\t\tif (size > ICP_QAT_CSS_RSA3K_MAX_IMAGE_LEN)\n\t\t\tgoto err;\n\t} else {\n\t\tpr_err(\"QAT: Unsupported firmware type\\n\");\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n\nerr:\n\tpr_err(\"QAT: Invalid %s firmware image\\n\", fw_type_name);\n\treturn -EINVAL;\n}\n\nstatic int qat_uclo_map_auth_fw(struct icp_qat_fw_loader_handle *handle,\n\t\t\t\tchar *image, unsigned int size,\n\t\t\t\tstruct icp_qat_fw_auth_desc **desc)\n{\n\tstruct icp_qat_css_hdr *css_hdr = (struct icp_qat_css_hdr *)image;\n\tstruct icp_qat_fw_auth_desc *auth_desc;\n\tstruct icp_qat_auth_chunk *auth_chunk;\n\tu64 virt_addr,  bus_addr, virt_base;\n\tunsigned int length, simg_offset = sizeof(*auth_chunk);\n\tstruct icp_qat_simg_ae_mode *simg_ae_mode;\n\tstruct icp_firml_dram_desc img_desc;\n\n\tif (size > (ICP_QAT_AE_IMG_OFFSET(handle) + ICP_QAT_CSS_RSA4K_MAX_IMAGE_LEN)) {\n\t\tpr_err(\"QAT: error, input image size overflow %d\\n\", size);\n\t\treturn -EINVAL;\n\t}\n\tlength = (css_hdr->fw_type == CSS_AE_FIRMWARE) ?\n\t\t ICP_QAT_CSS_AE_SIMG_LEN(handle) + simg_offset :\n\t\t size + ICP_QAT_CSS_FWSK_PAD_LEN(handle) + simg_offset;\n\tif (qat_uclo_simg_alloc(handle, &img_desc, length)) {\n\t\tpr_err(\"QAT: error, allocate continuous dram fail\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tauth_chunk = img_desc.dram_base_addr_v;\n\tauth_chunk->chunk_size = img_desc.dram_size;\n\tauth_chunk->chunk_bus_addr = img_desc.dram_bus_addr;\n\tvirt_base = (uintptr_t)img_desc.dram_base_addr_v + simg_offset;\n\tbus_addr  = img_desc.dram_bus_addr + simg_offset;\n\tauth_desc = img_desc.dram_base_addr_v;\n\tauth_desc->css_hdr_high = (unsigned int)(bus_addr >> BITS_IN_DWORD);\n\tauth_desc->css_hdr_low = (unsigned int)bus_addr;\n\tvirt_addr = virt_base;\n\n\tmemcpy((void *)(uintptr_t)virt_addr, image, sizeof(*css_hdr));\n\t \n\tbus_addr = ADD_ADDR(auth_desc->css_hdr_high, auth_desc->css_hdr_low) +\n\t\t\t   sizeof(*css_hdr);\n\tvirt_addr = virt_addr + sizeof(*css_hdr);\n\n\tauth_desc->fwsk_pub_high = (unsigned int)(bus_addr >> BITS_IN_DWORD);\n\tauth_desc->fwsk_pub_low = (unsigned int)bus_addr;\n\n\tmemcpy((void *)(uintptr_t)virt_addr,\n\t       (void *)(image + sizeof(*css_hdr)),\n\t       ICP_QAT_CSS_FWSK_MODULUS_LEN(handle));\n\t \n\tmemset((void *)(uintptr_t)(virt_addr + ICP_QAT_CSS_FWSK_MODULUS_LEN(handle)),\n\t       0, ICP_QAT_CSS_FWSK_PAD_LEN(handle));\n\n\t \n\tmemcpy((void *)(uintptr_t)(virt_addr + ICP_QAT_CSS_FWSK_MODULUS_LEN(handle) +\n\t       ICP_QAT_CSS_FWSK_PAD_LEN(handle)),\n\t       (void *)(image + sizeof(*css_hdr) +\n\t\t\tICP_QAT_CSS_FWSK_MODULUS_LEN(handle)),\n\t       sizeof(unsigned int));\n\n\t \n\tbus_addr = ADD_ADDR(auth_desc->fwsk_pub_high,\n\t\t\t    auth_desc->fwsk_pub_low) +\n\t\t   ICP_QAT_CSS_FWSK_PUB_LEN(handle);\n\tvirt_addr = virt_addr + ICP_QAT_CSS_FWSK_PUB_LEN(handle);\n\tauth_desc->signature_high = (unsigned int)(bus_addr >> BITS_IN_DWORD);\n\tauth_desc->signature_low = (unsigned int)bus_addr;\n\n\tmemcpy((void *)(uintptr_t)virt_addr,\n\t       (void *)(image + sizeof(*css_hdr) +\n\t       ICP_QAT_CSS_FWSK_MODULUS_LEN(handle) +\n\t       ICP_QAT_CSS_FWSK_EXPONENT_LEN(handle)),\n\t       ICP_QAT_CSS_SIGNATURE_LEN(handle));\n\n\tbus_addr = ADD_ADDR(auth_desc->signature_high,\n\t\t\t    auth_desc->signature_low) +\n\t\t   ICP_QAT_CSS_SIGNATURE_LEN(handle);\n\tvirt_addr += ICP_QAT_CSS_SIGNATURE_LEN(handle);\n\n\tauth_desc->img_high = (unsigned int)(bus_addr >> BITS_IN_DWORD);\n\tauth_desc->img_low = (unsigned int)bus_addr;\n\tauth_desc->img_len = size - ICP_QAT_AE_IMG_OFFSET(handle);\n\tmemcpy((void *)(uintptr_t)virt_addr,\n\t       (void *)(image + ICP_QAT_AE_IMG_OFFSET(handle)),\n\t       auth_desc->img_len);\n\tvirt_addr = virt_base;\n\t \n\tif (((struct icp_qat_css_hdr *)(uintptr_t)virt_addr)->fw_type ==\n\t    CSS_AE_FIRMWARE) {\n\t\tauth_desc->img_ae_mode_data_high = auth_desc->img_high;\n\t\tauth_desc->img_ae_mode_data_low = auth_desc->img_low;\n\t\tbus_addr = ADD_ADDR(auth_desc->img_ae_mode_data_high,\n\t\t\t\t    auth_desc->img_ae_mode_data_low) +\n\t\t\t   sizeof(struct icp_qat_simg_ae_mode);\n\n\t\tauth_desc->img_ae_init_data_high = (unsigned int)\n\t\t\t\t\t\t (bus_addr >> BITS_IN_DWORD);\n\t\tauth_desc->img_ae_init_data_low = (unsigned int)bus_addr;\n\t\tbus_addr += ICP_QAT_SIMG_AE_INIT_SEQ_LEN;\n\t\tauth_desc->img_ae_insts_high = (unsigned int)\n\t\t\t\t\t     (bus_addr >> BITS_IN_DWORD);\n\t\tauth_desc->img_ae_insts_low = (unsigned int)bus_addr;\n\t\tvirt_addr += sizeof(struct icp_qat_css_hdr);\n\t\tvirt_addr += ICP_QAT_CSS_FWSK_PUB_LEN(handle);\n\t\tvirt_addr += ICP_QAT_CSS_SIGNATURE_LEN(handle);\n\t\tsimg_ae_mode = (struct icp_qat_simg_ae_mode *)(uintptr_t)virt_addr;\n\t\tauth_desc->ae_mask = simg_ae_mode->ae_mask & handle->cfg_ae_mask;\n\t} else {\n\t\tauth_desc->img_ae_insts_high = auth_desc->img_high;\n\t\tauth_desc->img_ae_insts_low = auth_desc->img_low;\n\t}\n\t*desc = auth_desc;\n\treturn 0;\n}\n\nstatic int qat_uclo_load_fw(struct icp_qat_fw_loader_handle *handle,\n\t\t\t    struct icp_qat_fw_auth_desc *desc)\n{\n\tunsigned long ae_mask = handle->hal_handle->ae_mask;\n\tu32 fcu_sts_csr, fcu_ctl_csr;\n\tu32 loaded_aes, loaded_csr;\n\tunsigned int i;\n\tu32 fcu_sts;\n\n\tfcu_ctl_csr = handle->chip_info->fcu_ctl_csr;\n\tfcu_sts_csr = handle->chip_info->fcu_sts_csr;\n\tloaded_csr = handle->chip_info->fcu_loaded_ae_csr;\n\n\tfor_each_set_bit(i, &ae_mask, handle->hal_handle->ae_max_num) {\n\t\tint retry = 0;\n\n\t\tif (!((desc->ae_mask >> i) & 0x1))\n\t\t\tcontinue;\n\t\tif (qat_hal_check_ae_active(handle, i)) {\n\t\t\tpr_err(\"QAT: AE %d is active\\n\", i);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tSET_CAP_CSR(handle, fcu_ctl_csr,\n\t\t\t    (FCU_CTRL_CMD_LOAD |\n\t\t\t    (1 << FCU_CTRL_BROADCAST_POS) |\n\t\t\t    (i << FCU_CTRL_AE_POS)));\n\n\t\tdo {\n\t\t\tmsleep(FW_AUTH_WAIT_PERIOD);\n\t\t\tfcu_sts = GET_CAP_CSR(handle, fcu_sts_csr);\n\t\t\tif ((fcu_sts & FCU_AUTH_STS_MASK) ==\n\t\t\t    FCU_STS_LOAD_DONE) {\n\t\t\t\tloaded_aes = GET_CAP_CSR(handle, loaded_csr);\n\t\t\t\tloaded_aes >>= handle->chip_info->fcu_loaded_ae_pos;\n\t\t\t\tif (loaded_aes & (1 << i))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (retry++ < FW_AUTH_MAX_RETRY);\n\t\tif (retry > FW_AUTH_MAX_RETRY) {\n\t\t\tpr_err(\"QAT: firmware load failed timeout %x\\n\", retry);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int qat_uclo_map_suof_obj(struct icp_qat_fw_loader_handle *handle,\n\t\t\t\t void *addr_ptr, int mem_size)\n{\n\tstruct icp_qat_suof_handle *suof_handle;\n\n\tsuof_handle = kzalloc(sizeof(*suof_handle), GFP_KERNEL);\n\tif (!suof_handle)\n\t\treturn -ENOMEM;\n\thandle->sobj_handle = suof_handle;\n\tif (qat_uclo_map_suof(handle, addr_ptr, mem_size)) {\n\t\tqat_uclo_del_suof(handle);\n\t\tpr_err(\"QAT: map SUOF failed\\n\");\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nint qat_uclo_wr_mimage(struct icp_qat_fw_loader_handle *handle,\n\t\t       void *addr_ptr, int mem_size)\n{\n\tstruct icp_qat_fw_auth_desc *desc = NULL;\n\tint status = 0;\n\tint ret;\n\n\tret = qat_uclo_check_image(handle, addr_ptr, mem_size, CSS_MMP_FIRMWARE);\n\tif (ret)\n\t\treturn ret;\n\n\tif (handle->chip_info->fw_auth) {\n\t\tstatus = qat_uclo_map_auth_fw(handle, addr_ptr, mem_size, &desc);\n\t\tif (!status)\n\t\t\tstatus = qat_uclo_auth_fw(handle, desc);\n\t\tqat_uclo_ummap_auth_fw(handle, &desc);\n\t} else {\n\t\tif (handle->chip_info->mmp_sram_size < mem_size) {\n\t\t\tpr_err(\"QAT: MMP size is too large: 0x%x\\n\", mem_size);\n\t\t\treturn -EFBIG;\n\t\t}\n\t\tqat_uclo_wr_sram_by_words(handle, 0, addr_ptr, mem_size);\n\t}\n\treturn status;\n}\n\nstatic int qat_uclo_map_uof_obj(struct icp_qat_fw_loader_handle *handle,\n\t\t\t\tvoid *addr_ptr, int mem_size)\n{\n\tstruct icp_qat_uof_filehdr *filehdr;\n\tstruct icp_qat_uclo_objhandle *objhdl;\n\n\tobjhdl = kzalloc(sizeof(*objhdl), GFP_KERNEL);\n\tif (!objhdl)\n\t\treturn -ENOMEM;\n\tobjhdl->obj_buf = kmemdup(addr_ptr, mem_size, GFP_KERNEL);\n\tif (!objhdl->obj_buf)\n\t\tgoto out_objbuf_err;\n\tfilehdr = (struct icp_qat_uof_filehdr *)objhdl->obj_buf;\n\tif (qat_uclo_check_uof_format(filehdr))\n\t\tgoto out_objhdr_err;\n\tobjhdl->obj_hdr = qat_uclo_map_chunk((char *)objhdl->obj_buf, filehdr,\n\t\t\t\t\t     ICP_QAT_UOF_OBJS);\n\tif (!objhdl->obj_hdr) {\n\t\tpr_err(\"QAT: object file chunk is null\\n\");\n\t\tgoto out_objhdr_err;\n\t}\n\thandle->obj_handle = objhdl;\n\tif (qat_uclo_parse_uof_obj(handle))\n\t\tgoto out_overlay_obj_err;\n\treturn 0;\n\nout_overlay_obj_err:\n\thandle->obj_handle = NULL;\n\tkfree(objhdl->obj_hdr);\nout_objhdr_err:\n\tkfree(objhdl->obj_buf);\nout_objbuf_err:\n\tkfree(objhdl);\n\treturn -ENOMEM;\n}\n\nstatic int qat_uclo_map_mof_file_hdr(struct icp_qat_fw_loader_handle *handle,\n\t\t\t\t     struct icp_qat_mof_file_hdr *mof_ptr,\n\t\t\t\t     u32 mof_size)\n{\n\tstruct icp_qat_mof_handle *mobj_handle = handle->mobj_handle;\n\tunsigned int min_ver_offset;\n\tunsigned int checksum;\n\n\tmobj_handle->file_id = ICP_QAT_MOF_FID;\n\tmobj_handle->mof_buf = (char *)mof_ptr;\n\tmobj_handle->mof_size = mof_size;\n\n\tmin_ver_offset = mof_size - offsetof(struct icp_qat_mof_file_hdr,\n\t\t\t\t\t     min_ver);\n\tchecksum = qat_uclo_calc_str_checksum(&mof_ptr->min_ver,\n\t\t\t\t\t      min_ver_offset);\n\tif (checksum != mof_ptr->checksum) {\n\t\tpr_err(\"QAT: incorrect MOF checksum\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmobj_handle->checksum = mof_ptr->checksum;\n\tmobj_handle->min_ver = mof_ptr->min_ver;\n\tmobj_handle->maj_ver = mof_ptr->maj_ver;\n\treturn 0;\n}\n\nstatic void qat_uclo_del_mof(struct icp_qat_fw_loader_handle *handle)\n{\n\tstruct icp_qat_mof_handle *mobj_handle = handle->mobj_handle;\n\n\tkfree(mobj_handle->obj_table.obj_hdr);\n\tmobj_handle->obj_table.obj_hdr = NULL;\n\tkfree(handle->mobj_handle);\n\thandle->mobj_handle = NULL;\n}\n\nstatic int qat_uclo_seek_obj_inside_mof(struct icp_qat_mof_handle *mobj_handle,\n\t\t\t\t\tconst char *obj_name, char **obj_ptr,\n\t\t\t\t\tunsigned int *obj_size)\n{\n\tstruct icp_qat_mof_objhdr *obj_hdr = mobj_handle->obj_table.obj_hdr;\n\tunsigned int i;\n\n\tfor (i = 0; i < mobj_handle->obj_table.num_objs; i++) {\n\t\tif (!strncmp(obj_hdr[i].obj_name, obj_name,\n\t\t\t     ICP_QAT_SUOF_OBJ_NAME_LEN)) {\n\t\t\t*obj_ptr  = obj_hdr[i].obj_buf;\n\t\t\t*obj_size = obj_hdr[i].obj_size;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tpr_err(\"QAT: object %s is not found inside MOF\\n\", obj_name);\n\treturn -EINVAL;\n}\n\nstatic int qat_uclo_map_obj_from_mof(struct icp_qat_mof_handle *mobj_handle,\n\t\t\t\t     struct icp_qat_mof_objhdr *mobj_hdr,\n\t\t\t\t     struct icp_qat_mof_obj_chunkhdr *obj_chunkhdr)\n{\n\tu8 *obj;\n\n\tif (!strncmp(obj_chunkhdr->chunk_id, ICP_QAT_UOF_IMAG,\n\t\t     ICP_QAT_MOF_OBJ_CHUNKID_LEN)) {\n\t\tobj = mobj_handle->uobjs_hdr + obj_chunkhdr->offset;\n\t} else if (!strncmp(obj_chunkhdr->chunk_id, ICP_QAT_SUOF_IMAG,\n\t\t\t    ICP_QAT_MOF_OBJ_CHUNKID_LEN)) {\n\t\tobj = mobj_handle->sobjs_hdr + obj_chunkhdr->offset;\n\t} else {\n\t\tpr_err(\"QAT: unsupported chunk id\\n\");\n\t\treturn -EINVAL;\n\t}\n\tmobj_hdr->obj_buf = obj;\n\tmobj_hdr->obj_size = (unsigned int)obj_chunkhdr->size;\n\tmobj_hdr->obj_name = obj_chunkhdr->name + mobj_handle->sym_str;\n\treturn 0;\n}\n\nstatic int qat_uclo_map_objs_from_mof(struct icp_qat_mof_handle *mobj_handle)\n{\n\tstruct icp_qat_mof_obj_chunkhdr *uobj_chunkhdr;\n\tstruct icp_qat_mof_obj_chunkhdr *sobj_chunkhdr;\n\tstruct icp_qat_mof_obj_hdr *uobj_hdr;\n\tstruct icp_qat_mof_obj_hdr *sobj_hdr;\n\tstruct icp_qat_mof_objhdr *mobj_hdr;\n\tunsigned int uobj_chunk_num = 0;\n\tunsigned int sobj_chunk_num = 0;\n\tunsigned int *valid_chunk;\n\tint ret, i;\n\n\tuobj_hdr = (struct icp_qat_mof_obj_hdr *)mobj_handle->uobjs_hdr;\n\tsobj_hdr = (struct icp_qat_mof_obj_hdr *)mobj_handle->sobjs_hdr;\n\tif (uobj_hdr)\n\t\tuobj_chunk_num = uobj_hdr->num_chunks;\n\tif (sobj_hdr)\n\t\tsobj_chunk_num = sobj_hdr->num_chunks;\n\n\tmobj_hdr = kzalloc((uobj_chunk_num + sobj_chunk_num) *\n\t\t\t   sizeof(*mobj_hdr), GFP_KERNEL);\n\tif (!mobj_hdr)\n\t\treturn -ENOMEM;\n\n\tmobj_handle->obj_table.obj_hdr = mobj_hdr;\n\tvalid_chunk = &mobj_handle->obj_table.num_objs;\n\tuobj_chunkhdr = (struct icp_qat_mof_obj_chunkhdr *)\n\t\t\t ((uintptr_t)uobj_hdr + sizeof(*uobj_hdr));\n\tsobj_chunkhdr = (struct icp_qat_mof_obj_chunkhdr *)\n\t\t\t((uintptr_t)sobj_hdr + sizeof(*sobj_hdr));\n\n\t \n\tfor (i = 0; i < uobj_chunk_num; i++) {\n\t\tret = qat_uclo_map_obj_from_mof(mobj_handle,\n\t\t\t\t\t\t&mobj_hdr[*valid_chunk],\n\t\t\t\t\t\t&uobj_chunkhdr[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\t(*valid_chunk)++;\n\t}\n\n\t \n\tfor (i = 0; i < sobj_chunk_num; i++) {\n\t\tret = qat_uclo_map_obj_from_mof(mobj_handle,\n\t\t\t\t\t\t&mobj_hdr[*valid_chunk],\n\t\t\t\t\t\t&sobj_chunkhdr[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\t(*valid_chunk)++;\n\t}\n\n\tif ((uobj_chunk_num + sobj_chunk_num) != *valid_chunk) {\n\t\tpr_err(\"QAT: inconsistent UOF/SUOF chunk amount\\n\");\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic void qat_uclo_map_mof_symobjs(struct icp_qat_mof_handle *mobj_handle,\n\t\t\t\t     struct icp_qat_mof_chunkhdr *mof_chunkhdr)\n{\n\tchar **sym_str = (char **)&mobj_handle->sym_str;\n\tunsigned int *sym_size = &mobj_handle->sym_size;\n\tstruct icp_qat_mof_str_table *str_table_obj;\n\n\t*sym_size = *(unsigned int *)(uintptr_t)\n\t\t    (mof_chunkhdr->offset + mobj_handle->mof_buf);\n\t*sym_str = (char *)(uintptr_t)\n\t\t   (mobj_handle->mof_buf + mof_chunkhdr->offset +\n\t\t    sizeof(str_table_obj->tab_len));\n}\n\nstatic void qat_uclo_map_mof_chunk(struct icp_qat_mof_handle *mobj_handle,\n\t\t\t\t   struct icp_qat_mof_chunkhdr *mof_chunkhdr)\n{\n\tchar *chunk_id = mof_chunkhdr->chunk_id;\n\n\tif (!strncmp(chunk_id, ICP_QAT_MOF_SYM_OBJS, ICP_QAT_MOF_OBJ_ID_LEN))\n\t\tqat_uclo_map_mof_symobjs(mobj_handle, mof_chunkhdr);\n\telse if (!strncmp(chunk_id, ICP_QAT_UOF_OBJS, ICP_QAT_MOF_OBJ_ID_LEN))\n\t\tmobj_handle->uobjs_hdr = mobj_handle->mof_buf +\n\t\t\t\t\t mof_chunkhdr->offset;\n\telse if (!strncmp(chunk_id, ICP_QAT_SUOF_OBJS, ICP_QAT_MOF_OBJ_ID_LEN))\n\t\tmobj_handle->sobjs_hdr = mobj_handle->mof_buf +\n\t\t\t\t\t mof_chunkhdr->offset;\n}\n\nstatic int qat_uclo_check_mof_format(struct icp_qat_mof_file_hdr *mof_hdr)\n{\n\tint maj = mof_hdr->maj_ver & 0xff;\n\tint min = mof_hdr->min_ver & 0xff;\n\n\tif (mof_hdr->file_id != ICP_QAT_MOF_FID) {\n\t\tpr_err(\"QAT: invalid header 0x%x\\n\", mof_hdr->file_id);\n\t\treturn -EINVAL;\n\t}\n\n\tif (mof_hdr->num_chunks <= 0x1) {\n\t\tpr_err(\"QAT: MOF chunk amount is incorrect\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (maj != ICP_QAT_MOF_MAJVER || min != ICP_QAT_MOF_MINVER) {\n\t\tpr_err(\"QAT: bad MOF version, major 0x%x, minor 0x%x\\n\",\n\t\t       maj, min);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int qat_uclo_map_mof_obj(struct icp_qat_fw_loader_handle *handle,\n\t\t\t\tstruct icp_qat_mof_file_hdr *mof_ptr,\n\t\t\t\tu32 mof_size, const char *obj_name,\n\t\t\t\tchar **obj_ptr, unsigned int *obj_size)\n{\n\tstruct icp_qat_mof_chunkhdr *mof_chunkhdr;\n\tunsigned int file_id = mof_ptr->file_id;\n\tstruct icp_qat_mof_handle *mobj_handle;\n\tunsigned short chunks_num;\n\tunsigned int i;\n\tint ret;\n\n\tif (file_id == ICP_QAT_UOF_FID || file_id == ICP_QAT_SUOF_FID) {\n\t\tif (obj_ptr)\n\t\t\t*obj_ptr = (char *)mof_ptr;\n\t\tif (obj_size)\n\t\t\t*obj_size = mof_size;\n\t\treturn 0;\n\t}\n\tif (qat_uclo_check_mof_format(mof_ptr))\n\t\treturn -EINVAL;\n\n\tmobj_handle = kzalloc(sizeof(*mobj_handle), GFP_KERNEL);\n\tif (!mobj_handle)\n\t\treturn -ENOMEM;\n\n\thandle->mobj_handle = mobj_handle;\n\tret = qat_uclo_map_mof_file_hdr(handle, mof_ptr, mof_size);\n\tif (ret)\n\t\treturn ret;\n\n\tmof_chunkhdr = (void *)mof_ptr + sizeof(*mof_ptr);\n\tchunks_num = mof_ptr->num_chunks;\n\n\t \n\tfor (i = 0; i < chunks_num; i++)\n\t\tqat_uclo_map_mof_chunk(mobj_handle, &mof_chunkhdr[i]);\n\n\t \n\tif (!mobj_handle->sym_str ||\n\t    (!mobj_handle->uobjs_hdr && !mobj_handle->sobjs_hdr))\n\t\treturn -EINVAL;\n\n\tret = qat_uclo_map_objs_from_mof(mobj_handle);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\treturn qat_uclo_seek_obj_inside_mof(mobj_handle, obj_name,\n\t\t\t\t\t    obj_ptr, obj_size);\n}\n\nint qat_uclo_map_obj(struct icp_qat_fw_loader_handle *handle,\n\t\t     void *addr_ptr, u32 mem_size, const char *obj_name)\n{\n\tchar *obj_addr;\n\tu32 obj_size;\n\tint ret;\n\n\tBUILD_BUG_ON(ICP_QAT_UCLO_MAX_AE >=\n\t\t     (sizeof(handle->hal_handle->ae_mask) * 8));\n\n\tif (!handle || !addr_ptr || mem_size < 24)\n\t\treturn -EINVAL;\n\n\tif (obj_name) {\n\t\tret = qat_uclo_map_mof_obj(handle, addr_ptr, mem_size, obj_name,\n\t\t\t\t\t   &obj_addr, &obj_size);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\tobj_addr = addr_ptr;\n\t\tobj_size = mem_size;\n\t}\n\n\treturn (handle->chip_info->fw_auth) ?\n\t\t\tqat_uclo_map_suof_obj(handle, obj_addr, obj_size) :\n\t\t\tqat_uclo_map_uof_obj(handle, obj_addr, obj_size);\n}\n\nvoid qat_uclo_del_obj(struct icp_qat_fw_loader_handle *handle)\n{\n\tstruct icp_qat_uclo_objhandle *obj_handle = handle->obj_handle;\n\tunsigned int a;\n\n\tif (handle->mobj_handle)\n\t\tqat_uclo_del_mof(handle);\n\tif (handle->sobj_handle)\n\t\tqat_uclo_del_suof(handle);\n\tif (!obj_handle)\n\t\treturn;\n\n\tkfree(obj_handle->uword_buf);\n\tfor (a = 0; a < obj_handle->uimage_num; a++)\n\t\tkfree(obj_handle->ae_uimage[a].page);\n\n\tfor (a = 0; a < handle->hal_handle->ae_max_num; a++)\n\t\tqat_uclo_free_ae_data(&obj_handle->ae_data[a]);\n\n\tkfree(obj_handle->obj_hdr);\n\tkfree(obj_handle->obj_buf);\n\tkfree(obj_handle);\n\thandle->obj_handle = NULL;\n}\n\nstatic void qat_uclo_fill_uwords(struct icp_qat_uclo_objhandle *obj_handle,\n\t\t\t\t struct icp_qat_uclo_encap_page *encap_page,\n\t\t\t\t u64 *uword, unsigned int addr_p,\n\t\t\t\t unsigned int raddr, u64 fill)\n{\n\tunsigned int i, addr;\n\tu64 uwrd = 0;\n\n\tif (!encap_page) {\n\t\t*uword = fill;\n\t\treturn;\n\t}\n\taddr = (encap_page->page_region) ? raddr : addr_p;\n\tfor (i = 0; i < encap_page->uwblock_num; i++) {\n\t\tif (addr >= encap_page->uwblock[i].start_addr &&\n\t\t    addr <= encap_page->uwblock[i].start_addr +\n\t\t    encap_page->uwblock[i].words_num - 1) {\n\t\t\taddr -= encap_page->uwblock[i].start_addr;\n\t\t\taddr *= obj_handle->uword_in_bytes;\n\t\t\tmemcpy(&uwrd, (void *)(((uintptr_t)\n\t\t\t       encap_page->uwblock[i].micro_words) + addr),\n\t\t\t       obj_handle->uword_in_bytes);\n\t\t\tuwrd = uwrd & GENMASK_ULL(43, 0);\n\t\t}\n\t}\n\t*uword = uwrd;\n\tif (*uword == INVLD_UWORD)\n\t\t*uword = fill;\n}\n\nstatic void qat_uclo_wr_uimage_raw_page(struct icp_qat_fw_loader_handle *handle,\n\t\t\t\t\tstruct icp_qat_uclo_encap_page\n\t\t\t\t\t*encap_page, unsigned int ae)\n{\n\tunsigned int uw_physical_addr, uw_relative_addr, i, words_num, cpylen;\n\tstruct icp_qat_uclo_objhandle *obj_handle = handle->obj_handle;\n\tu64 fill_pat;\n\n\t \n\t \n\tmemcpy(&fill_pat, obj_handle->ae_uimage[0].img_ptr->fill_pattern,\n\t       sizeof(u64));\n\tuw_physical_addr = encap_page->beg_addr_p;\n\tuw_relative_addr = 0;\n\twords_num = encap_page->micro_words_num;\n\twhile (words_num) {\n\t\tcpylen = min(words_num, UWORD_CPYBUF_SIZE);\n\n\t\t \n\t\tfor (i = 0; i < cpylen; i++)\n\t\t\tqat_uclo_fill_uwords(obj_handle, encap_page,\n\t\t\t\t\t     &obj_handle->uword_buf[i],\n\t\t\t\t\t     uw_physical_addr + i,\n\t\t\t\t\t     uw_relative_addr + i, fill_pat);\n\n\t\t \n\t\tqat_hal_wr_uwords(handle, (unsigned char)ae,\n\t\t\t\t  uw_physical_addr, cpylen,\n\t\t\t\t  obj_handle->uword_buf);\n\n\t\tuw_physical_addr += cpylen;\n\t\tuw_relative_addr += cpylen;\n\t\twords_num -= cpylen;\n\t}\n}\n\nstatic void qat_uclo_wr_uimage_page(struct icp_qat_fw_loader_handle *handle,\n\t\t\t\t    struct icp_qat_uof_image *image)\n{\n\tstruct icp_qat_uclo_objhandle *obj_handle = handle->obj_handle;\n\tunsigned long ae_mask = handle->hal_handle->ae_mask;\n\tunsigned long cfg_ae_mask = handle->cfg_ae_mask;\n\tunsigned long ae_assigned = image->ae_assigned;\n\tstruct icp_qat_uclo_aedata *aed;\n\tunsigned int ctx_mask, s;\n\tstruct icp_qat_uclo_page *page;\n\tunsigned char ae;\n\tint ctx;\n\n\tif (ICP_QAT_CTX_MODE(image->ae_mode) == ICP_QAT_UCLO_MAX_CTX)\n\t\tctx_mask = 0xff;\n\telse\n\t\tctx_mask = 0x55;\n\t \n\tfor_each_set_bit(ae, &ae_mask, handle->hal_handle->ae_max_num) {\n\t\tif (!test_bit(ae, &cfg_ae_mask))\n\t\t\tcontinue;\n\n\t\tif (!test_bit(ae, &ae_assigned))\n\t\t\tcontinue;\n\n\t\taed = &obj_handle->ae_data[ae];\n\t\t \n\t\tfor (s = 0; s < aed->slice_num; s++) {\n\t\t\tif (image->ctx_assigned &\n\t\t\t    aed->ae_slices[s].ctx_mask_assigned)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (s >= aed->slice_num)\n\t\t\tcontinue;\n\t\tpage = aed->ae_slices[s].page;\n\t\tif (!page->encap_page->def_page)\n\t\t\tcontinue;\n\t\tqat_uclo_wr_uimage_raw_page(handle, page->encap_page, ae);\n\n\t\tpage = aed->ae_slices[s].page;\n\t\tfor (ctx = 0; ctx < ICP_QAT_UCLO_MAX_CTX; ctx++)\n\t\t\taed->ae_slices[s].cur_page[ctx] =\n\t\t\t\t\t(ctx_mask & (1 << ctx)) ? page : NULL;\n\t\tqat_hal_set_live_ctx(handle, (unsigned char)ae,\n\t\t\t\t     image->ctx_assigned);\n\t\tqat_hal_set_pc(handle, (unsigned char)ae, image->ctx_assigned,\n\t\t\t       image->entry_address);\n\t}\n}\n\nstatic int qat_uclo_wr_suof_img(struct icp_qat_fw_loader_handle *handle)\n{\n\tunsigned int i;\n\tstruct icp_qat_fw_auth_desc *desc = NULL;\n\tstruct icp_qat_suof_handle *sobj_handle = handle->sobj_handle;\n\tstruct icp_qat_suof_img_hdr *simg_hdr = sobj_handle->img_table.simg_hdr;\n\tint ret;\n\n\tfor (i = 0; i < sobj_handle->img_table.num_simgs; i++) {\n\t\tret = qat_uclo_check_image(handle, simg_hdr[i].simg_buf,\n\t\t\t\t\t   simg_hdr[i].simg_len,\n\t\t\t\t\t   CSS_AE_FIRMWARE);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (qat_uclo_map_auth_fw(handle,\n\t\t\t\t\t (char *)simg_hdr[i].simg_buf,\n\t\t\t\t\t (unsigned int)\n\t\t\t\t\t simg_hdr[i].simg_len,\n\t\t\t\t\t &desc))\n\t\t\tgoto wr_err;\n\t\tif (qat_uclo_auth_fw(handle, desc))\n\t\t\tgoto wr_err;\n\t\tif (qat_uclo_is_broadcast(handle, i)) {\n\t\t\tif (qat_uclo_broadcast_load_fw(handle, desc))\n\t\t\t\tgoto wr_err;\n\t\t} else {\n\t\t\tif (qat_uclo_load_fw(handle, desc))\n\t\t\t\tgoto wr_err;\n\t\t}\n\t\tqat_uclo_ummap_auth_fw(handle, &desc);\n\t}\n\treturn 0;\nwr_err:\n\tqat_uclo_ummap_auth_fw(handle, &desc);\n\treturn -EINVAL;\n}\n\nstatic int qat_uclo_wr_uof_img(struct icp_qat_fw_loader_handle *handle)\n{\n\tstruct icp_qat_uclo_objhandle *obj_handle = handle->obj_handle;\n\tunsigned int i;\n\n\tif (qat_uclo_init_globals(handle))\n\t\treturn -EINVAL;\n\tfor (i = 0; i < obj_handle->uimage_num; i++) {\n\t\tif (!obj_handle->ae_uimage[i].img_ptr)\n\t\t\treturn -EINVAL;\n\t\tif (qat_uclo_init_ustore(handle, &obj_handle->ae_uimage[i]))\n\t\t\treturn -EINVAL;\n\t\tqat_uclo_wr_uimage_page(handle,\n\t\t\t\t\tobj_handle->ae_uimage[i].img_ptr);\n\t}\n\treturn 0;\n}\n\nint qat_uclo_wr_all_uimage(struct icp_qat_fw_loader_handle *handle)\n{\n\treturn (handle->chip_info->fw_auth) ? qat_uclo_wr_suof_img(handle) :\n\t\t\t\t   qat_uclo_wr_uof_img(handle);\n}\n\nint qat_uclo_set_cfg_ae_mask(struct icp_qat_fw_loader_handle *handle,\n\t\t\t     unsigned int cfg_ae_mask)\n{\n\tif (!cfg_ae_mask)\n\t\treturn -EINVAL;\n\n\thandle->cfg_ae_mask = cfg_ae_mask;\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}