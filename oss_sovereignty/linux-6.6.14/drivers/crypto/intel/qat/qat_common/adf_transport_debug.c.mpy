{
  "module_name": "adf_transport_debug.c",
  "hash_id": "11955ef131dc0185531eebe43f8b9cbf5057c60ae4c1ade8560bfb7ed2512c0c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/intel/qat/qat_common/adf_transport_debug.c",
  "human_readable_source": "\n \n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include \"adf_accel_devices.h\"\n#include \"adf_transport_internal.h\"\n#include \"adf_transport_access_macros.h\"\n\nstatic DEFINE_MUTEX(ring_read_lock);\nstatic DEFINE_MUTEX(bank_read_lock);\n\nstatic void *adf_ring_start(struct seq_file *sfile, loff_t *pos)\n{\n\tstruct adf_etr_ring_data *ring = sfile->private;\n\n\tmutex_lock(&ring_read_lock);\n\tif (*pos == 0)\n\t\treturn SEQ_START_TOKEN;\n\n\tif (*pos >= (ADF_SIZE_TO_RING_SIZE_IN_BYTES(ring->ring_size) /\n\t\t     ADF_MSG_SIZE_TO_BYTES(ring->msg_size)))\n\t\treturn NULL;\n\n\treturn ring->base_addr +\n\t\t(ADF_MSG_SIZE_TO_BYTES(ring->msg_size) * (*pos)++);\n}\n\nstatic void *adf_ring_next(struct seq_file *sfile, void *v, loff_t *pos)\n{\n\tstruct adf_etr_ring_data *ring = sfile->private;\n\n\tif (*pos >= (ADF_SIZE_TO_RING_SIZE_IN_BYTES(ring->ring_size) /\n\t\t     ADF_MSG_SIZE_TO_BYTES(ring->msg_size)))\n\t\treturn NULL;\n\n\treturn ring->base_addr +\n\t\t(ADF_MSG_SIZE_TO_BYTES(ring->msg_size) * (*pos)++);\n}\n\nstatic int adf_ring_show(struct seq_file *sfile, void *v)\n{\n\tstruct adf_etr_ring_data *ring = sfile->private;\n\tstruct adf_etr_bank_data *bank = ring->bank;\n\tstruct adf_hw_csr_ops *csr_ops = GET_CSR_OPS(bank->accel_dev);\n\tvoid __iomem *csr = ring->bank->csr_addr;\n\n\tif (v == SEQ_START_TOKEN) {\n\t\tint head, tail, empty;\n\n\t\thead = csr_ops->read_csr_ring_head(csr, bank->bank_number,\n\t\t\t\t\t\t   ring->ring_number);\n\t\ttail = csr_ops->read_csr_ring_tail(csr, bank->bank_number,\n\t\t\t\t\t\t   ring->ring_number);\n\t\tempty = csr_ops->read_csr_e_stat(csr, bank->bank_number);\n\n\t\tseq_puts(sfile, \"------- Ring configuration -------\\n\");\n\t\tseq_printf(sfile, \"ring name: %s\\n\",\n\t\t\t   ring->ring_debug->ring_name);\n\t\tseq_printf(sfile, \"ring num %d, bank num %d\\n\",\n\t\t\t   ring->ring_number, ring->bank->bank_number);\n\t\tseq_printf(sfile, \"head %x, tail %x, empty: %d\\n\",\n\t\t\t   head, tail, (empty & 1 << ring->ring_number)\n\t\t\t   >> ring->ring_number);\n\t\tseq_printf(sfile, \"ring size %lld, msg size %d\\n\",\n\t\t\t   (long long)ADF_SIZE_TO_RING_SIZE_IN_BYTES(ring->ring_size),\n\t\t\t   ADF_MSG_SIZE_TO_BYTES(ring->msg_size));\n\t\tseq_puts(sfile, \"----------- Ring data ------------\\n\");\n\t\treturn 0;\n\t}\n\tseq_hex_dump(sfile, \"\", DUMP_PREFIX_ADDRESS, 32, 4,\n\t\t     v, ADF_MSG_SIZE_TO_BYTES(ring->msg_size), false);\n\treturn 0;\n}\n\nstatic void adf_ring_stop(struct seq_file *sfile, void *v)\n{\n\tmutex_unlock(&ring_read_lock);\n}\n\nstatic const struct seq_operations adf_ring_debug_sops = {\n\t.start = adf_ring_start,\n\t.next = adf_ring_next,\n\t.stop = adf_ring_stop,\n\t.show = adf_ring_show\n};\n\nDEFINE_SEQ_ATTRIBUTE(adf_ring_debug);\n\nint adf_ring_debugfs_add(struct adf_etr_ring_data *ring, const char *name)\n{\n\tstruct adf_etr_ring_debug_entry *ring_debug;\n\tchar entry_name[16];\n\n\tring_debug = kzalloc(sizeof(*ring_debug), GFP_KERNEL);\n\tif (!ring_debug)\n\t\treturn -ENOMEM;\n\n\tstrscpy(ring_debug->ring_name, name, sizeof(ring_debug->ring_name));\n\tsnprintf(entry_name, sizeof(entry_name), \"ring_%02d\",\n\t\t ring->ring_number);\n\n\tring_debug->debug = debugfs_create_file(entry_name, S_IRUSR,\n\t\t\t\t\t\tring->bank->bank_debug_dir,\n\t\t\t\t\t\tring, &adf_ring_debug_fops);\n\tring->ring_debug = ring_debug;\n\treturn 0;\n}\n\nvoid adf_ring_debugfs_rm(struct adf_etr_ring_data *ring)\n{\n\tif (ring->ring_debug) {\n\t\tdebugfs_remove(ring->ring_debug->debug);\n\t\tkfree(ring->ring_debug);\n\t\tring->ring_debug = NULL;\n\t}\n}\n\nstatic void *adf_bank_start(struct seq_file *sfile, loff_t *pos)\n{\n\tstruct adf_etr_bank_data *bank = sfile->private;\n\tu8 num_rings_per_bank = GET_NUM_RINGS_PER_BANK(bank->accel_dev);\n\n\tmutex_lock(&bank_read_lock);\n\tif (*pos == 0)\n\t\treturn SEQ_START_TOKEN;\n\n\tif (*pos >= num_rings_per_bank)\n\t\treturn NULL;\n\n\treturn pos;\n}\n\nstatic void *adf_bank_next(struct seq_file *sfile, void *v, loff_t *pos)\n{\n\tstruct adf_etr_bank_data *bank = sfile->private;\n\tu8 num_rings_per_bank = GET_NUM_RINGS_PER_BANK(bank->accel_dev);\n\n\tif (++(*pos) >= num_rings_per_bank)\n\t\treturn NULL;\n\n\treturn pos;\n}\n\nstatic int adf_bank_show(struct seq_file *sfile, void *v)\n{\n\tstruct adf_etr_bank_data *bank = sfile->private;\n\tstruct adf_hw_csr_ops *csr_ops = GET_CSR_OPS(bank->accel_dev);\n\n\tif (v == SEQ_START_TOKEN) {\n\t\tseq_printf(sfile, \"------- Bank %d configuration -------\\n\",\n\t\t\t   bank->bank_number);\n\t} else {\n\t\tint ring_id = *((int *)v) - 1;\n\t\tstruct adf_etr_ring_data *ring = &bank->rings[ring_id];\n\t\tvoid __iomem *csr = bank->csr_addr;\n\t\tint head, tail, empty;\n\n\t\tif (!(bank->ring_mask & 1 << ring_id))\n\t\t\treturn 0;\n\n\t\thead = csr_ops->read_csr_ring_head(csr, bank->bank_number,\n\t\t\t\t\t\t   ring->ring_number);\n\t\ttail = csr_ops->read_csr_ring_tail(csr, bank->bank_number,\n\t\t\t\t\t\t   ring->ring_number);\n\t\tempty = csr_ops->read_csr_e_stat(csr, bank->bank_number);\n\n\t\tseq_printf(sfile,\n\t\t\t   \"ring num %02d, head %04x, tail %04x, empty: %d\\n\",\n\t\t\t   ring->ring_number, head, tail,\n\t\t\t   (empty & 1 << ring->ring_number) >>\n\t\t\t   ring->ring_number);\n\t}\n\treturn 0;\n}\n\nstatic void adf_bank_stop(struct seq_file *sfile, void *v)\n{\n\tmutex_unlock(&bank_read_lock);\n}\n\nstatic const struct seq_operations adf_bank_debug_sops = {\n\t.start = adf_bank_start,\n\t.next = adf_bank_next,\n\t.stop = adf_bank_stop,\n\t.show = adf_bank_show\n};\n\nDEFINE_SEQ_ATTRIBUTE(adf_bank_debug);\n\nint adf_bank_debugfs_add(struct adf_etr_bank_data *bank)\n{\n\tstruct adf_accel_dev *accel_dev = bank->accel_dev;\n\tstruct dentry *parent = accel_dev->transport->debug;\n\tchar name[16];\n\n\tsnprintf(name, sizeof(name), \"bank_%02d\", bank->bank_number);\n\tbank->bank_debug_dir = debugfs_create_dir(name, parent);\n\tbank->bank_debug_cfg = debugfs_create_file(\"config\", S_IRUSR,\n\t\t\t\t\t\t   bank->bank_debug_dir, bank,\n\t\t\t\t\t\t   &adf_bank_debug_fops);\n\treturn 0;\n}\n\nvoid adf_bank_debugfs_rm(struct adf_etr_bank_data *bank)\n{\n\tdebugfs_remove(bank->bank_debug_cfg);\n\tdebugfs_remove(bank->bank_debug_dir);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}