{
  "module_name": "adf_drv.c",
  "hash_id": "52e6349a24417023ab1254d5aa7b1c6ab6f1a515674c2ccb8ff682b2457bce4e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/intel/qat/qat_c62xvf/adf_drv.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/init.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/device.h>\n#include <linux/dma-mapping.h>\n#include <linux/platform_device.h>\n#include <linux/workqueue.h>\n#include <linux/io.h>\n#include <adf_accel_devices.h>\n#include <adf_common_drv.h>\n#include <adf_cfg.h>\n#include <adf_dbgfs.h>\n#include \"adf_c62xvf_hw_data.h\"\n\nstatic const struct pci_device_id adf_pci_tbl[] = {\n\t{ PCI_VDEVICE(INTEL, PCI_DEVICE_ID_INTEL_QAT_C62X_VF), },\n\t{ }\n};\nMODULE_DEVICE_TABLE(pci, adf_pci_tbl);\n\nstatic int adf_probe(struct pci_dev *dev, const struct pci_device_id *ent);\nstatic void adf_remove(struct pci_dev *dev);\n\nstatic struct pci_driver adf_driver = {\n\t.id_table = adf_pci_tbl,\n\t.name = ADF_C62XVF_DEVICE_NAME,\n\t.probe = adf_probe,\n\t.remove = adf_remove,\n};\n\nstatic void adf_cleanup_pci_dev(struct adf_accel_dev *accel_dev)\n{\n\tpci_release_regions(accel_dev->accel_pci_dev.pci_dev);\n\tpci_disable_device(accel_dev->accel_pci_dev.pci_dev);\n}\n\nstatic void adf_cleanup_accel(struct adf_accel_dev *accel_dev)\n{\n\tstruct adf_accel_pci *accel_pci_dev = &accel_dev->accel_pci_dev;\n\tstruct adf_accel_dev *pf;\n\tint i;\n\n\tfor (i = 0; i < ADF_PCI_MAX_BARS; i++) {\n\t\tstruct adf_bar *bar = &accel_pci_dev->pci_bars[i];\n\n\t\tif (bar->virt_addr)\n\t\t\tpci_iounmap(accel_pci_dev->pci_dev, bar->virt_addr);\n\t}\n\n\tif (accel_dev->hw_device) {\n\t\tswitch (accel_pci_dev->pci_dev->device) {\n\t\tcase PCI_DEVICE_ID_INTEL_QAT_C62X_VF:\n\t\t\tadf_clean_hw_data_c62xiov(accel_dev->hw_device);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tkfree(accel_dev->hw_device);\n\t\taccel_dev->hw_device = NULL;\n\t}\n\tadf_dbgfs_exit(accel_dev);\n\tadf_cfg_dev_remove(accel_dev);\n\tpf = adf_devmgr_pci_to_accel_dev(accel_pci_dev->pci_dev->physfn);\n\tadf_devmgr_rm_dev(accel_dev, pf);\n}\n\nstatic int adf_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tstruct adf_accel_dev *accel_dev;\n\tstruct adf_accel_dev *pf;\n\tstruct adf_accel_pci *accel_pci_dev;\n\tstruct adf_hw_device_data *hw_data;\n\tunsigned int i, bar_nr;\n\tunsigned long bar_mask;\n\tint ret;\n\n\tswitch (ent->device) {\n\tcase PCI_DEVICE_ID_INTEL_QAT_C62X_VF:\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&pdev->dev, \"Invalid device 0x%x.\\n\", ent->device);\n\t\treturn -ENODEV;\n\t}\n\n\taccel_dev = kzalloc_node(sizeof(*accel_dev), GFP_KERNEL,\n\t\t\t\t dev_to_node(&pdev->dev));\n\tif (!accel_dev)\n\t\treturn -ENOMEM;\n\n\taccel_dev->is_vf = true;\n\tpf = adf_devmgr_pci_to_accel_dev(pdev->physfn);\n\taccel_pci_dev = &accel_dev->accel_pci_dev;\n\taccel_pci_dev->pci_dev = pdev;\n\n\t \n\tif (adf_devmgr_add_dev(accel_dev, pf)) {\n\t\tdev_err(&pdev->dev, \"Failed to add new accelerator device.\\n\");\n\t\tkfree(accel_dev);\n\t\treturn -EFAULT;\n\t}\n\tINIT_LIST_HEAD(&accel_dev->crypto_list);\n\n\taccel_dev->owner = THIS_MODULE;\n\t \n\thw_data = kzalloc_node(sizeof(*hw_data), GFP_KERNEL,\n\t\t\t       dev_to_node(&pdev->dev));\n\tif (!hw_data) {\n\t\tret = -ENOMEM;\n\t\tgoto out_err;\n\t}\n\taccel_dev->hw_device = hw_data;\n\tadf_init_hw_data_c62xiov(accel_dev->hw_device);\n\n\t \n\thw_data->accel_mask = hw_data->get_accel_mask(hw_data);\n\thw_data->ae_mask = hw_data->get_ae_mask(hw_data);\n\taccel_pci_dev->sku = hw_data->get_sku(hw_data);\n\n\t \n\tret = adf_cfg_dev_add(accel_dev);\n\tif (ret)\n\t\tgoto out_err;\n\n\t \n\tif (pci_enable_device(pdev)) {\n\t\tret = -EFAULT;\n\t\tgoto out_err;\n\t}\n\n\t \n\tret = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(48));\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"No usable DMA configuration\\n\");\n\t\tgoto out_err_disable;\n\t}\n\n\tif (pci_request_regions(pdev, ADF_C62XVF_DEVICE_NAME)) {\n\t\tret = -EFAULT;\n\t\tgoto out_err_disable;\n\t}\n\n\t \n\ti = 0;\n\tbar_mask = pci_select_bars(pdev, IORESOURCE_MEM);\n\tfor_each_set_bit(bar_nr, &bar_mask, ADF_PCI_MAX_BARS * 2) {\n\t\tstruct adf_bar *bar = &accel_pci_dev->pci_bars[i++];\n\n\t\tbar->base_addr = pci_resource_start(pdev, bar_nr);\n\t\tif (!bar->base_addr)\n\t\t\tbreak;\n\t\tbar->size = pci_resource_len(pdev, bar_nr);\n\t\tbar->virt_addr = pci_iomap(accel_pci_dev->pci_dev, bar_nr, 0);\n\t\tif (!bar->virt_addr) {\n\t\t\tdev_err(&pdev->dev, \"Failed to map BAR %d\\n\", bar_nr);\n\t\t\tret = -EFAULT;\n\t\t\tgoto out_err_free_reg;\n\t\t}\n\t}\n\tpci_set_master(pdev);\n\t \n\tinit_completion(&accel_dev->vf.msg_received);\n\n\tadf_dbgfs_init(accel_dev);\n\n\tret = adf_dev_up(accel_dev, false);\n\tif (ret)\n\t\tgoto out_err_dev_stop;\n\n\treturn ret;\n\nout_err_dev_stop:\n\tadf_dev_down(accel_dev, false);\nout_err_free_reg:\n\tpci_release_regions(accel_pci_dev->pci_dev);\nout_err_disable:\n\tpci_disable_device(accel_pci_dev->pci_dev);\nout_err:\n\tadf_cleanup_accel(accel_dev);\n\tkfree(accel_dev);\n\treturn ret;\n}\n\nstatic void adf_remove(struct pci_dev *pdev)\n{\n\tstruct adf_accel_dev *accel_dev = adf_devmgr_pci_to_accel_dev(pdev);\n\n\tif (!accel_dev) {\n\t\tpr_err(\"QAT: Driver removal failed\\n\");\n\t\treturn;\n\t}\n\tadf_flush_vf_wq(accel_dev);\n\tadf_dev_down(accel_dev, false);\n\tadf_cleanup_accel(accel_dev);\n\tadf_cleanup_pci_dev(accel_dev);\n\tkfree(accel_dev);\n}\n\nstatic int __init adfdrv_init(void)\n{\n\trequest_module(\"intel_qat\");\n\n\tif (pci_register_driver(&adf_driver)) {\n\t\tpr_err(\"QAT: Driver initialization failed\\n\");\n\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}\n\nstatic void __exit adfdrv_release(void)\n{\n\tpci_unregister_driver(&adf_driver);\n\tadf_clean_vf_map(true);\n}\n\nmodule_init(adfdrv_init);\nmodule_exit(adfdrv_release);\n\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_AUTHOR(\"Intel\");\nMODULE_DESCRIPTION(\"Intel(R) QuickAssist Technology\");\nMODULE_VERSION(ADF_DRV_VERSION);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}