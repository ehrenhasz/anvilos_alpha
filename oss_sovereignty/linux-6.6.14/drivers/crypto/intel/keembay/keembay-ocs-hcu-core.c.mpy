{
  "module_name": "keembay-ocs-hcu-core.c",
  "hash_id": "ad131eda3a50f0f8cae7a3e9621eb4cac36f08fc2ead4c153b6720fcd5bfd0ec",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/intel/keembay/keembay-ocs-hcu-core.c",
  "human_readable_source": "\n \n\n#include <crypto/engine.h>\n#include <crypto/hmac.h>\n#include <crypto/internal/hash.h>\n#include <crypto/scatterwalk.h>\n#include <crypto/sha2.h>\n#include <crypto/sm3.h>\n#include <linux/completion.h>\n#include <linux/dma-mapping.h>\n#include <linux/err.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/string.h>\n\n#include \"ocs-hcu.h\"\n\n#define DRV_NAME\t\"keembay-ocs-hcu\"\n\n \n#define REQ_FINAL\t\t\tBIT(0)\n \n#define REQ_FLAGS_HMAC\t\t\tBIT(1)\n \n#define REQ_FLAGS_HMAC_HW\t\tBIT(2)\n \n#define REQ_FLAGS_HMAC_SW\t\tBIT(3)\n\n \nstruct ocs_hcu_ctx {\n\tstruct ocs_hcu_dev *hcu_dev;\n\tu8 key[SHA512_BLOCK_SIZE];\n\tsize_t key_len;\n\tbool is_sm3_tfm;\n\tbool is_hmac_tfm;\n};\n\n \nstruct ocs_hcu_rctx {\n\tstruct ocs_hcu_dev\t*hcu_dev;\n\tu32\t\t\tflags;\n\tenum ocs_hcu_algo\talgo;\n\tsize_t\t\t\tblk_sz;\n\tsize_t\t\t\tdig_sz;\n\tstruct ocs_hcu_dma_list\t*dma_list;\n\tstruct ocs_hcu_hash_ctx\thash_ctx;\n\t \n\tu8\t\t\tbuffer[2 * SHA512_BLOCK_SIZE];\n\tsize_t\t\t\tbuf_cnt;\n\tdma_addr_t\t\tbuf_dma_addr;\n\tsize_t\t\t\tbuf_dma_count;\n\tstruct scatterlist\t*sg;\n\tunsigned int\t\tsg_data_total;\n\tunsigned int\t\tsg_data_offset;\n\tunsigned int\t\tsg_dma_nents;\n};\n\n \nstruct ocs_hcu_drv {\n\tstruct list_head dev_list;\n\tspinlock_t lock;  \n};\n\nstatic struct ocs_hcu_drv ocs_hcu = {\n\t.dev_list = LIST_HEAD_INIT(ocs_hcu.dev_list),\n\t.lock = __SPIN_LOCK_UNLOCKED(ocs_hcu.lock),\n};\n\n \nstatic inline unsigned int kmb_get_total_data(struct ocs_hcu_rctx *rctx)\n{\n\treturn rctx->sg_data_total + rctx->buf_cnt;\n}\n\n \nstatic int flush_sg_to_ocs_buffer(struct ocs_hcu_rctx *rctx)\n{\n\tsize_t count;\n\n\tif (rctx->sg_data_total > (sizeof(rctx->buffer) - rctx->buf_cnt)) {\n\t\tWARN(1, \"%s: sg data does not fit in buffer\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\twhile (rctx->sg_data_total) {\n\t\tif (!rctx->sg) {\n\t\t\tWARN(1, \"%s: unexpected NULL sg\\n\", __func__);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t \n\t\tif (rctx->sg_data_offset == rctx->sg->length) {\n\t\t\trctx->sg = sg_next(rctx->sg);\n\t\t\trctx->sg_data_offset = 0;\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\tcount = min(rctx->sg->length - rctx->sg_data_offset,\n\t\t\t    rctx->sg_data_total);\n\t\t \n\t\tscatterwalk_map_and_copy(&rctx->buffer[rctx->buf_cnt],\n\t\t\t\t\t rctx->sg, rctx->sg_data_offset,\n\t\t\t\t\t count, 0);\n\n\t\trctx->sg_data_offset += count;\n\t\trctx->sg_data_total -= count;\n\t\trctx->buf_cnt += count;\n\t}\n\n\treturn 0;\n}\n\nstatic struct ocs_hcu_dev *kmb_ocs_hcu_find_dev(struct ahash_request *req)\n{\n\tstruct crypto_ahash *tfm = crypto_ahash_reqtfm(req);\n\tstruct ocs_hcu_ctx *tctx = crypto_ahash_ctx(tfm);\n\n\t \n\tif (tctx->hcu_dev)\n\t\treturn tctx->hcu_dev;\n\n\t \n\tspin_lock_bh(&ocs_hcu.lock);\n\ttctx->hcu_dev = list_first_entry_or_null(&ocs_hcu.dev_list,\n\t\t\t\t\t\t struct ocs_hcu_dev,\n\t\t\t\t\t\t list);\n\tspin_unlock_bh(&ocs_hcu.lock);\n\n\treturn tctx->hcu_dev;\n}\n\n \nstatic void kmb_ocs_hcu_dma_cleanup(struct ahash_request *req,\n\t\t\t\t    struct ocs_hcu_rctx *rctx)\n{\n\tstruct ocs_hcu_dev *hcu_dev = rctx->hcu_dev;\n\tstruct device *dev = hcu_dev->dev;\n\n\t \n\tif (rctx->buf_dma_count) {\n\t\tdma_unmap_single(dev, rctx->buf_dma_addr, rctx->buf_dma_count,\n\t\t\t\t DMA_TO_DEVICE);\n\t\trctx->buf_dma_count = 0;\n\t}\n\n\t \n\tif (rctx->sg_dma_nents) {\n\t\tdma_unmap_sg(dev, req->src, rctx->sg_dma_nents, DMA_TO_DEVICE);\n\t\trctx->sg_dma_nents = 0;\n\t}\n\n\t \n\tif (rctx->dma_list) {\n\t\tocs_hcu_dma_list_free(hcu_dev, rctx->dma_list);\n\t\trctx->dma_list = NULL;\n\t}\n}\n\n \nstatic int kmb_ocs_dma_prepare(struct ahash_request *req)\n{\n\tstruct ocs_hcu_rctx *rctx = ahash_request_ctx_dma(req);\n\tstruct device *dev = rctx->hcu_dev->dev;\n\tunsigned int remainder = 0;\n\tunsigned int total;\n\tsize_t nents;\n\tsize_t count;\n\tint rc;\n\tint i;\n\n\t \n\ttotal = kmb_get_total_data(rctx);\n\tif (!total)\n\t\treturn -EINVAL;\n\n\t \n\tif (!(rctx->flags & REQ_FINAL))\n\t\tremainder = total % rctx->blk_sz;\n\n\t \n\tnents = sg_nents_for_len(req->src, rctx->sg_data_total - remainder);\n\n\t \n\tif (nents) {\n\t\trctx->sg_dma_nents = dma_map_sg(dev, req->src, nents,\n\t\t\t\t\t\tDMA_TO_DEVICE);\n\t\tif (!rctx->sg_dma_nents) {\n\t\t\tdev_err(dev, \"Failed to MAP SG\\n\");\n\t\t\trc = -ENOMEM;\n\t\t\tgoto cleanup;\n\t\t}\n\t\t \n\t\tnents = rctx->sg_dma_nents;\n\t}\n\n\t \n\tif (rctx->buf_cnt) {\n\t\trctx->buf_dma_addr = dma_map_single(dev, rctx->buffer,\n\t\t\t\t\t\t    rctx->buf_cnt,\n\t\t\t\t\t\t    DMA_TO_DEVICE);\n\t\tif (dma_mapping_error(dev, rctx->buf_dma_addr)) {\n\t\t\tdev_err(dev, \"Failed to map request context buffer\\n\");\n\t\t\trc = -ENOMEM;\n\t\t\tgoto cleanup;\n\t\t}\n\t\trctx->buf_dma_count = rctx->buf_cnt;\n\t\t \n\t\tnents++;\n\t}\n\n\t \n\trctx->dma_list = ocs_hcu_dma_list_alloc(rctx->hcu_dev, nents);\n\tif (!rctx->dma_list) {\n\t\trc = -ENOMEM;\n\t\tgoto cleanup;\n\t}\n\n\t \n\tif (rctx->buf_dma_count) {\n\t\trc = ocs_hcu_dma_list_add_tail(rctx->hcu_dev, rctx->dma_list,\n\t\t\t\t\t       rctx->buf_dma_addr,\n\t\t\t\t\t       rctx->buf_dma_count);\n\t\tif (rc)\n\t\t\tgoto cleanup;\n\t}\n\n\t \n\tfor_each_sg(req->src, rctx->sg, rctx->sg_dma_nents, i) {\n\t\t \n\t\tcount = min(rctx->sg_data_total - remainder,\n\t\t\t    sg_dma_len(rctx->sg) - rctx->sg_data_offset);\n\t\t \n\t\tif (count == 0)\n\t\t\tcontinue;\n\t\t \n\t\trc = ocs_hcu_dma_list_add_tail(rctx->hcu_dev,\n\t\t\t\t\t       rctx->dma_list,\n\t\t\t\t\t       rctx->sg->dma_address,\n\t\t\t\t\t       count);\n\t\tif (rc)\n\t\t\tgoto cleanup;\n\n\t\t \n\t\trctx->sg_data_total -= count;\n\n\t\t \n\t\tif (rctx->sg_data_total <= remainder) {\n\t\t\tWARN_ON(rctx->sg_data_total < remainder);\n\t\t\trctx->sg_data_offset += count;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\trctx->sg_data_offset = 0;\n\t}\n\n\treturn 0;\ncleanup:\n\tdev_err(dev, \"Failed to prepare DMA.\\n\");\n\tkmb_ocs_hcu_dma_cleanup(req, rctx);\n\n\treturn rc;\n}\n\nstatic void kmb_ocs_hcu_secure_cleanup(struct ahash_request *req)\n{\n\tstruct ocs_hcu_rctx *rctx = ahash_request_ctx_dma(req);\n\n\t \n\tmemzero_explicit(rctx->buffer, sizeof(rctx->buffer));\n}\n\nstatic int kmb_ocs_hcu_handle_queue(struct ahash_request *req)\n{\n\tstruct ocs_hcu_dev *hcu_dev = kmb_ocs_hcu_find_dev(req);\n\n\tif (!hcu_dev)\n\t\treturn -ENOENT;\n\n\treturn crypto_transfer_hash_request_to_engine(hcu_dev->engine, req);\n}\n\nstatic int prepare_ipad(struct ahash_request *req)\n{\n\tstruct ocs_hcu_rctx *rctx = ahash_request_ctx_dma(req);\n\tstruct crypto_ahash *tfm = crypto_ahash_reqtfm(req);\n\tstruct ocs_hcu_ctx *ctx = crypto_ahash_ctx(tfm);\n\tint i;\n\n\tWARN(rctx->buf_cnt, \"%s: Context buffer is not empty\\n\", __func__);\n\tWARN(!(rctx->flags & REQ_FLAGS_HMAC_SW),\n\t     \"%s: HMAC_SW flag is not set\\n\", __func__);\n\t \n\tif (ctx->key_len > rctx->blk_sz) {\n\t\tWARN(1, \"%s: Invalid key length in tfm context\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\tmemzero_explicit(&ctx->key[ctx->key_len],\n\t\t\t rctx->blk_sz - ctx->key_len);\n\tctx->key_len = rctx->blk_sz;\n\t \n\tfor (i = 0; i < rctx->blk_sz; i++)\n\t\trctx->buffer[i] = ctx->key[i] ^ HMAC_IPAD_VALUE;\n\trctx->buf_cnt = rctx->blk_sz;\n\n\treturn 0;\n}\n\nstatic int kmb_ocs_hcu_do_one_request(struct crypto_engine *engine, void *areq)\n{\n\tstruct ahash_request *req = container_of(areq, struct ahash_request,\n\t\t\t\t\t\t base);\n\tstruct ocs_hcu_dev *hcu_dev = kmb_ocs_hcu_find_dev(req);\n\tstruct crypto_ahash *tfm = crypto_ahash_reqtfm(req);\n\tstruct ocs_hcu_rctx *rctx = ahash_request_ctx_dma(req);\n\tstruct ocs_hcu_ctx *tctx = crypto_ahash_ctx(tfm);\n\tint rc;\n\tint i;\n\n\tif (!hcu_dev) {\n\t\trc = -ENOENT;\n\t\tgoto error;\n\t}\n\n\t \n\tif (rctx->flags & REQ_FLAGS_HMAC_HW) {\n\t\t \n\t\trc = kmb_ocs_dma_prepare(req);\n\t\tif (rc)\n\t\t\tgoto error;\n\n\t\trc = ocs_hcu_hmac(hcu_dev, rctx->algo, tctx->key, tctx->key_len,\n\t\t\t\t  rctx->dma_list, req->result, rctx->dig_sz);\n\n\t\t \n\t\tkmb_ocs_hcu_dma_cleanup(req, rctx);\n\n\t\t \n\t\tif (rc)\n\t\t\tgoto error;\n\n\t\tgoto done;\n\t}\n\n\t \n\tif (!(rctx->flags & REQ_FINAL)) {\n\t\t \n\t\tif (!kmb_get_total_data(rctx))\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\trc = kmb_ocs_dma_prepare(req);\n\t\tif (rc)\n\t\t\tgoto error;\n\n\t\t \n\t\trc = ocs_hcu_hash_update(hcu_dev, &rctx->hash_ctx,\n\t\t\t\t\t rctx->dma_list);\n\n\t\t \n\t\tkmb_ocs_hcu_dma_cleanup(req, rctx);\n\n\t\t \n\t\tif (rc)\n\t\t\tgoto error;\n\n\t\t \n\t\trctx->buf_cnt = 0;\n\t\t \n\t\trc = flush_sg_to_ocs_buffer(rctx);\n\t\tif (rc)\n\t\t\tgoto error;\n\n\t\tgoto done;\n\t}\n\n\t \n\n\t \n\tif (kmb_get_total_data(rctx)) {\n\t\t \n\t\trc = kmb_ocs_dma_prepare(req);\n\t\tif (rc)\n\t\t\tgoto error;\n\n\t\t \n\t\trc = ocs_hcu_hash_finup(hcu_dev, &rctx->hash_ctx,\n\t\t\t\t\trctx->dma_list,\n\t\t\t\t\treq->result, rctx->dig_sz);\n\t\t \n\t\tkmb_ocs_hcu_dma_cleanup(req, rctx);\n\n\t\t \n\t\tif (rc)\n\t\t\tgoto error;\n\n\t} else {   \n\t\trc = ocs_hcu_hash_final(hcu_dev, &rctx->hash_ctx, req->result,\n\t\t\t\t\trctx->dig_sz);\n\t\tif (rc)\n\t\t\tgoto error;\n\t}\n\n\t \n\tif (rctx->flags & REQ_FLAGS_HMAC_SW) {\n\t\t \n\t\tWARN_ON(tctx->key_len != rctx->blk_sz);\n\t\tfor (i = 0; i < rctx->blk_sz; i++)\n\t\t\trctx->buffer[i] = tctx->key[i] ^ HMAC_OPAD_VALUE;\n\t\t \n\t\tfor (i = 0; (i < rctx->dig_sz); i++)\n\t\t\trctx->buffer[rctx->blk_sz + i] = req->result[i];\n\n\t\t \n\t\trc = ocs_hcu_digest(hcu_dev, rctx->algo, rctx->buffer,\n\t\t\t\t    rctx->blk_sz + rctx->dig_sz, req->result,\n\t\t\t\t    rctx->dig_sz);\n\t\tif (rc)\n\t\t\tgoto error;\n\t}\n\n\t \n\tkmb_ocs_hcu_secure_cleanup(req);\ndone:\n\tcrypto_finalize_hash_request(hcu_dev->engine, req, 0);\n\n\treturn 0;\n\nerror:\n\tkmb_ocs_hcu_secure_cleanup(req);\n\treturn rc;\n}\n\nstatic int kmb_ocs_hcu_init(struct ahash_request *req)\n{\n\tstruct ocs_hcu_dev *hcu_dev = kmb_ocs_hcu_find_dev(req);\n\tstruct ocs_hcu_rctx *rctx = ahash_request_ctx_dma(req);\n\tstruct crypto_ahash *tfm = crypto_ahash_reqtfm(req);\n\tstruct ocs_hcu_ctx *ctx = crypto_ahash_ctx(tfm);\n\n\tif (!hcu_dev)\n\t\treturn -ENOENT;\n\n\t \n\tmemset(rctx, 0, sizeof(*rctx));\n\n\trctx->hcu_dev = hcu_dev;\n\trctx->dig_sz = crypto_ahash_digestsize(tfm);\n\n\tswitch (rctx->dig_sz) {\n#ifdef CONFIG_CRYPTO_DEV_KEEMBAY_OCS_HCU_HMAC_SHA224\n\tcase SHA224_DIGEST_SIZE:\n\t\trctx->blk_sz = SHA224_BLOCK_SIZE;\n\t\trctx->algo = OCS_HCU_ALGO_SHA224;\n\t\tbreak;\n#endif  \n\tcase SHA256_DIGEST_SIZE:\n\t\trctx->blk_sz = SHA256_BLOCK_SIZE;\n\t\t \n\t\trctx->algo = ctx->is_sm3_tfm ? OCS_HCU_ALGO_SM3 :\n\t\t\t\t\t       OCS_HCU_ALGO_SHA256;\n\t\tbreak;\n\tcase SHA384_DIGEST_SIZE:\n\t\trctx->blk_sz = SHA384_BLOCK_SIZE;\n\t\trctx->algo = OCS_HCU_ALGO_SHA384;\n\t\tbreak;\n\tcase SHA512_DIGEST_SIZE:\n\t\trctx->blk_sz = SHA512_BLOCK_SIZE;\n\t\trctx->algo = OCS_HCU_ALGO_SHA512;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tocs_hcu_hash_init(&rctx->hash_ctx, rctx->algo);\n\n\t \n\tif (ctx->is_hmac_tfm)\n\t\trctx->flags |= REQ_FLAGS_HMAC;\n\n\treturn 0;\n}\n\nstatic int kmb_ocs_hcu_update(struct ahash_request *req)\n{\n\tstruct ocs_hcu_rctx *rctx = ahash_request_ctx_dma(req);\n\tint rc;\n\n\tif (!req->nbytes)\n\t\treturn 0;\n\n\trctx->sg_data_total = req->nbytes;\n\trctx->sg_data_offset = 0;\n\trctx->sg = req->src;\n\n\t \n\tif (rctx->flags & REQ_FLAGS_HMAC &&\n\t    !(rctx->flags & REQ_FLAGS_HMAC_SW)) {\n\t\trctx->flags |= REQ_FLAGS_HMAC_SW;\n\t\trc = prepare_ipad(req);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\t \n\tif (rctx->sg_data_total <= (sizeof(rctx->buffer) - rctx->buf_cnt))\n\t\treturn flush_sg_to_ocs_buffer(rctx);\n\n\treturn kmb_ocs_hcu_handle_queue(req);\n}\n\n \nstatic int kmb_ocs_hcu_fin_common(struct ahash_request *req)\n{\n\tstruct ocs_hcu_rctx *rctx = ahash_request_ctx_dma(req);\n\tstruct crypto_ahash *tfm = crypto_ahash_reqtfm(req);\n\tstruct ocs_hcu_ctx *ctx = crypto_ahash_ctx(tfm);\n\tint rc;\n\n\trctx->flags |= REQ_FINAL;\n\n\t \n\tif (rctx->flags & REQ_FLAGS_HMAC &&\n\t    !(rctx->flags & REQ_FLAGS_HMAC_SW)) {\n\t\t \n\t\tif (kmb_get_total_data(rctx) &&\n\t\t    ctx->key_len <= OCS_HCU_HW_KEY_LEN) {\n\t\t\trctx->flags |= REQ_FLAGS_HMAC_HW;\n\t\t} else {\n\t\t\trctx->flags |= REQ_FLAGS_HMAC_SW;\n\t\t\trc = prepare_ipad(req);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t}\n\t}\n\n\treturn kmb_ocs_hcu_handle_queue(req);\n}\n\nstatic int kmb_ocs_hcu_final(struct ahash_request *req)\n{\n\tstruct ocs_hcu_rctx *rctx = ahash_request_ctx_dma(req);\n\n\trctx->sg_data_total = 0;\n\trctx->sg_data_offset = 0;\n\trctx->sg = NULL;\n\n\treturn kmb_ocs_hcu_fin_common(req);\n}\n\nstatic int kmb_ocs_hcu_finup(struct ahash_request *req)\n{\n\tstruct ocs_hcu_rctx *rctx = ahash_request_ctx_dma(req);\n\n\trctx->sg_data_total = req->nbytes;\n\trctx->sg_data_offset = 0;\n\trctx->sg = req->src;\n\n\treturn kmb_ocs_hcu_fin_common(req);\n}\n\nstatic int kmb_ocs_hcu_digest(struct ahash_request *req)\n{\n\tint rc = 0;\n\tstruct ocs_hcu_dev *hcu_dev = kmb_ocs_hcu_find_dev(req);\n\n\tif (!hcu_dev)\n\t\treturn -ENOENT;\n\n\trc = kmb_ocs_hcu_init(req);\n\tif (rc)\n\t\treturn rc;\n\n\trc = kmb_ocs_hcu_finup(req);\n\n\treturn rc;\n}\n\nstatic int kmb_ocs_hcu_export(struct ahash_request *req, void *out)\n{\n\tstruct ocs_hcu_rctx *rctx = ahash_request_ctx_dma(req);\n\n\t \n\tmemcpy(out, rctx, sizeof(*rctx));\n\n\treturn 0;\n}\n\nstatic int kmb_ocs_hcu_import(struct ahash_request *req, const void *in)\n{\n\tstruct ocs_hcu_rctx *rctx = ahash_request_ctx_dma(req);\n\n\t \n\tmemcpy(rctx, in, sizeof(*rctx));\n\n\treturn 0;\n}\n\nstatic int kmb_ocs_hcu_setkey(struct crypto_ahash *tfm, const u8 *key,\n\t\t\t      unsigned int keylen)\n{\n\tunsigned int digestsize = crypto_ahash_digestsize(tfm);\n\tstruct ocs_hcu_ctx *ctx = crypto_ahash_ctx(tfm);\n\tsize_t blk_sz = crypto_ahash_blocksize(tfm);\n\tstruct crypto_ahash *ahash_tfm;\n\tstruct ahash_request *req;\n\tstruct crypto_wait wait;\n\tstruct scatterlist sg;\n\tconst char *alg_name;\n\tint rc;\n\n\t \n\tif (keylen <= blk_sz) {\n\t\tmemcpy(ctx->key, key, keylen);\n\t\tctx->key_len = keylen;\n\t\treturn 0;\n\t}\n\n\tswitch (digestsize) {\n#ifdef CONFIG_CRYPTO_DEV_KEEMBAY_OCS_HCU_HMAC_SHA224\n\tcase SHA224_DIGEST_SIZE:\n\t\talg_name = \"sha224-keembay-ocs\";\n\t\tbreak;\n#endif  \n\tcase SHA256_DIGEST_SIZE:\n\t\talg_name = ctx->is_sm3_tfm ? \"sm3-keembay-ocs\" :\n\t\t\t\t\t     \"sha256-keembay-ocs\";\n\t\tbreak;\n\tcase SHA384_DIGEST_SIZE:\n\t\talg_name = \"sha384-keembay-ocs\";\n\t\tbreak;\n\tcase SHA512_DIGEST_SIZE:\n\t\talg_name = \"sha512-keembay-ocs\";\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tahash_tfm = crypto_alloc_ahash(alg_name, 0, 0);\n\tif (IS_ERR(ahash_tfm))\n\t\treturn PTR_ERR(ahash_tfm);\n\n\treq = ahash_request_alloc(ahash_tfm, GFP_KERNEL);\n\tif (!req) {\n\t\trc = -ENOMEM;\n\t\tgoto err_free_ahash;\n\t}\n\n\tcrypto_init_wait(&wait);\n\tahash_request_set_callback(req, CRYPTO_TFM_REQ_MAY_BACKLOG,\n\t\t\t\t   crypto_req_done, &wait);\n\tcrypto_ahash_clear_flags(ahash_tfm, ~0);\n\n\tsg_init_one(&sg, key, keylen);\n\tahash_request_set_crypt(req, &sg, ctx->key, keylen);\n\n\trc = crypto_wait_req(crypto_ahash_digest(req), &wait);\n\tif (rc == 0)\n\t\tctx->key_len = digestsize;\n\n\tahash_request_free(req);\nerr_free_ahash:\n\tcrypto_free_ahash(ahash_tfm);\n\n\treturn rc;\n}\n\n \nstatic void __cra_init(struct crypto_tfm *tfm, struct ocs_hcu_ctx *ctx)\n{\n\tcrypto_ahash_set_reqsize_dma(__crypto_ahash_cast(tfm),\n\t\t\t\t     sizeof(struct ocs_hcu_rctx));\n}\n\nstatic int kmb_ocs_hcu_sha_cra_init(struct crypto_tfm *tfm)\n{\n\tstruct ocs_hcu_ctx *ctx = crypto_tfm_ctx(tfm);\n\n\t__cra_init(tfm, ctx);\n\n\treturn 0;\n}\n\nstatic int kmb_ocs_hcu_sm3_cra_init(struct crypto_tfm *tfm)\n{\n\tstruct ocs_hcu_ctx *ctx = crypto_tfm_ctx(tfm);\n\n\t__cra_init(tfm, ctx);\n\n\tctx->is_sm3_tfm = true;\n\n\treturn 0;\n}\n\nstatic int kmb_ocs_hcu_hmac_sm3_cra_init(struct crypto_tfm *tfm)\n{\n\tstruct ocs_hcu_ctx *ctx = crypto_tfm_ctx(tfm);\n\n\t__cra_init(tfm, ctx);\n\n\tctx->is_sm3_tfm = true;\n\tctx->is_hmac_tfm = true;\n\n\treturn 0;\n}\n\nstatic int kmb_ocs_hcu_hmac_cra_init(struct crypto_tfm *tfm)\n{\n\tstruct ocs_hcu_ctx *ctx = crypto_tfm_ctx(tfm);\n\n\t__cra_init(tfm, ctx);\n\n\tctx->is_hmac_tfm = true;\n\n\treturn 0;\n}\n\n \nstatic void kmb_ocs_hcu_hmac_cra_exit(struct crypto_tfm *tfm)\n{\n\tstruct ocs_hcu_ctx *ctx = crypto_tfm_ctx(tfm);\n\n\t \n\tmemzero_explicit(ctx->key, sizeof(ctx->key));\n}\n\nstatic struct ahash_engine_alg ocs_hcu_algs[] = {\n#ifdef CONFIG_CRYPTO_DEV_KEEMBAY_OCS_HCU_HMAC_SHA224\n{\n\t.base.init\t\t= kmb_ocs_hcu_init,\n\t.base.update\t\t= kmb_ocs_hcu_update,\n\t.base.final\t\t= kmb_ocs_hcu_final,\n\t.base.finup\t\t= kmb_ocs_hcu_finup,\n\t.base.digest\t\t= kmb_ocs_hcu_digest,\n\t.base.export\t\t= kmb_ocs_hcu_export,\n\t.base.import\t\t= kmb_ocs_hcu_import,\n\t.base.halg = {\n\t\t.digestsize\t= SHA224_DIGEST_SIZE,\n\t\t.statesize\t= sizeof(struct ocs_hcu_rctx),\n\t\t.base\t= {\n\t\t\t.cra_name\t\t= \"sha224\",\n\t\t\t.cra_driver_name\t= \"sha224-keembay-ocs\",\n\t\t\t.cra_priority\t\t= 255,\n\t\t\t.cra_flags\t\t= CRYPTO_ALG_ASYNC,\n\t\t\t.cra_blocksize\t\t= SHA224_BLOCK_SIZE,\n\t\t\t.cra_ctxsize\t\t= sizeof(struct ocs_hcu_ctx),\n\t\t\t.cra_alignmask\t\t= 0,\n\t\t\t.cra_module\t\t= THIS_MODULE,\n\t\t\t.cra_init\t\t= kmb_ocs_hcu_sha_cra_init,\n\t\t}\n\t},\n\t.op.do_one_request = kmb_ocs_hcu_do_one_request,\n},\n{\n\t.base.init\t\t= kmb_ocs_hcu_init,\n\t.base.update\t\t= kmb_ocs_hcu_update,\n\t.base.final\t\t= kmb_ocs_hcu_final,\n\t.base.finup\t\t= kmb_ocs_hcu_finup,\n\t.base.digest\t\t= kmb_ocs_hcu_digest,\n\t.base.export\t\t= kmb_ocs_hcu_export,\n\t.base.import\t\t= kmb_ocs_hcu_import,\n\t.base.setkey\t\t= kmb_ocs_hcu_setkey,\n\t.base.halg = {\n\t\t.digestsize\t= SHA224_DIGEST_SIZE,\n\t\t.statesize\t= sizeof(struct ocs_hcu_rctx),\n\t\t.base\t= {\n\t\t\t.cra_name\t\t= \"hmac(sha224)\",\n\t\t\t.cra_driver_name\t= \"hmac-sha224-keembay-ocs\",\n\t\t\t.cra_priority\t\t= 255,\n\t\t\t.cra_flags\t\t= CRYPTO_ALG_ASYNC,\n\t\t\t.cra_blocksize\t\t= SHA224_BLOCK_SIZE,\n\t\t\t.cra_ctxsize\t\t= sizeof(struct ocs_hcu_ctx),\n\t\t\t.cra_alignmask\t\t= 0,\n\t\t\t.cra_module\t\t= THIS_MODULE,\n\t\t\t.cra_init\t\t= kmb_ocs_hcu_hmac_cra_init,\n\t\t\t.cra_exit\t\t= kmb_ocs_hcu_hmac_cra_exit,\n\t\t}\n\t},\n\t.op.do_one_request = kmb_ocs_hcu_do_one_request,\n},\n#endif  \n{\n\t.base.init\t\t= kmb_ocs_hcu_init,\n\t.base.update\t\t= kmb_ocs_hcu_update,\n\t.base.final\t\t= kmb_ocs_hcu_final,\n\t.base.finup\t\t= kmb_ocs_hcu_finup,\n\t.base.digest\t\t= kmb_ocs_hcu_digest,\n\t.base.export\t\t= kmb_ocs_hcu_export,\n\t.base.import\t\t= kmb_ocs_hcu_import,\n\t.base.halg = {\n\t\t.digestsize\t= SHA256_DIGEST_SIZE,\n\t\t.statesize\t= sizeof(struct ocs_hcu_rctx),\n\t\t.base\t= {\n\t\t\t.cra_name\t\t= \"sha256\",\n\t\t\t.cra_driver_name\t= \"sha256-keembay-ocs\",\n\t\t\t.cra_priority\t\t= 255,\n\t\t\t.cra_flags\t\t= CRYPTO_ALG_ASYNC,\n\t\t\t.cra_blocksize\t\t= SHA256_BLOCK_SIZE,\n\t\t\t.cra_ctxsize\t\t= sizeof(struct ocs_hcu_ctx),\n\t\t\t.cra_alignmask\t\t= 0,\n\t\t\t.cra_module\t\t= THIS_MODULE,\n\t\t\t.cra_init\t\t= kmb_ocs_hcu_sha_cra_init,\n\t\t}\n\t},\n\t.op.do_one_request = kmb_ocs_hcu_do_one_request,\n},\n{\n\t.base.init\t\t= kmb_ocs_hcu_init,\n\t.base.update\t\t= kmb_ocs_hcu_update,\n\t.base.final\t\t= kmb_ocs_hcu_final,\n\t.base.finup\t\t= kmb_ocs_hcu_finup,\n\t.base.digest\t\t= kmb_ocs_hcu_digest,\n\t.base.export\t\t= kmb_ocs_hcu_export,\n\t.base.import\t\t= kmb_ocs_hcu_import,\n\t.base.setkey\t\t= kmb_ocs_hcu_setkey,\n\t.base.halg = {\n\t\t.digestsize\t= SHA256_DIGEST_SIZE,\n\t\t.statesize\t= sizeof(struct ocs_hcu_rctx),\n\t\t.base\t= {\n\t\t\t.cra_name\t\t= \"hmac(sha256)\",\n\t\t\t.cra_driver_name\t= \"hmac-sha256-keembay-ocs\",\n\t\t\t.cra_priority\t\t= 255,\n\t\t\t.cra_flags\t\t= CRYPTO_ALG_ASYNC,\n\t\t\t.cra_blocksize\t\t= SHA256_BLOCK_SIZE,\n\t\t\t.cra_ctxsize\t\t= sizeof(struct ocs_hcu_ctx),\n\t\t\t.cra_alignmask\t\t= 0,\n\t\t\t.cra_module\t\t= THIS_MODULE,\n\t\t\t.cra_init\t\t= kmb_ocs_hcu_hmac_cra_init,\n\t\t\t.cra_exit\t\t= kmb_ocs_hcu_hmac_cra_exit,\n\t\t}\n\t},\n\t.op.do_one_request = kmb_ocs_hcu_do_one_request,\n},\n{\n\t.base.init\t\t= kmb_ocs_hcu_init,\n\t.base.update\t\t= kmb_ocs_hcu_update,\n\t.base.final\t\t= kmb_ocs_hcu_final,\n\t.base.finup\t\t= kmb_ocs_hcu_finup,\n\t.base.digest\t\t= kmb_ocs_hcu_digest,\n\t.base.export\t\t= kmb_ocs_hcu_export,\n\t.base.import\t\t= kmb_ocs_hcu_import,\n\t.base.halg = {\n\t\t.digestsize\t= SM3_DIGEST_SIZE,\n\t\t.statesize\t= sizeof(struct ocs_hcu_rctx),\n\t\t.base\t= {\n\t\t\t.cra_name\t\t= \"sm3\",\n\t\t\t.cra_driver_name\t= \"sm3-keembay-ocs\",\n\t\t\t.cra_priority\t\t= 255,\n\t\t\t.cra_flags\t\t= CRYPTO_ALG_ASYNC,\n\t\t\t.cra_blocksize\t\t= SM3_BLOCK_SIZE,\n\t\t\t.cra_ctxsize\t\t= sizeof(struct ocs_hcu_ctx),\n\t\t\t.cra_alignmask\t\t= 0,\n\t\t\t.cra_module\t\t= THIS_MODULE,\n\t\t\t.cra_init\t\t= kmb_ocs_hcu_sm3_cra_init,\n\t\t}\n\t},\n\t.op.do_one_request = kmb_ocs_hcu_do_one_request,\n},\n{\n\t.base.init\t\t= kmb_ocs_hcu_init,\n\t.base.update\t\t= kmb_ocs_hcu_update,\n\t.base.final\t\t= kmb_ocs_hcu_final,\n\t.base.finup\t\t= kmb_ocs_hcu_finup,\n\t.base.digest\t\t= kmb_ocs_hcu_digest,\n\t.base.export\t\t= kmb_ocs_hcu_export,\n\t.base.import\t\t= kmb_ocs_hcu_import,\n\t.base.setkey\t\t= kmb_ocs_hcu_setkey,\n\t.base.halg = {\n\t\t.digestsize\t= SM3_DIGEST_SIZE,\n\t\t.statesize\t= sizeof(struct ocs_hcu_rctx),\n\t\t.base\t= {\n\t\t\t.cra_name\t\t= \"hmac(sm3)\",\n\t\t\t.cra_driver_name\t= \"hmac-sm3-keembay-ocs\",\n\t\t\t.cra_priority\t\t= 255,\n\t\t\t.cra_flags\t\t= CRYPTO_ALG_ASYNC,\n\t\t\t.cra_blocksize\t\t= SM3_BLOCK_SIZE,\n\t\t\t.cra_ctxsize\t\t= sizeof(struct ocs_hcu_ctx),\n\t\t\t.cra_alignmask\t\t= 0,\n\t\t\t.cra_module\t\t= THIS_MODULE,\n\t\t\t.cra_init\t\t= kmb_ocs_hcu_hmac_sm3_cra_init,\n\t\t\t.cra_exit\t\t= kmb_ocs_hcu_hmac_cra_exit,\n\t\t}\n\t},\n\t.op.do_one_request = kmb_ocs_hcu_do_one_request,\n},\n{\n\t.base.init\t\t= kmb_ocs_hcu_init,\n\t.base.update\t\t= kmb_ocs_hcu_update,\n\t.base.final\t\t= kmb_ocs_hcu_final,\n\t.base.finup\t\t= kmb_ocs_hcu_finup,\n\t.base.digest\t\t= kmb_ocs_hcu_digest,\n\t.base.export\t\t= kmb_ocs_hcu_export,\n\t.base.import\t\t= kmb_ocs_hcu_import,\n\t.base.halg = {\n\t\t.digestsize\t= SHA384_DIGEST_SIZE,\n\t\t.statesize\t= sizeof(struct ocs_hcu_rctx),\n\t\t.base\t= {\n\t\t\t.cra_name\t\t= \"sha384\",\n\t\t\t.cra_driver_name\t= \"sha384-keembay-ocs\",\n\t\t\t.cra_priority\t\t= 255,\n\t\t\t.cra_flags\t\t= CRYPTO_ALG_ASYNC,\n\t\t\t.cra_blocksize\t\t= SHA384_BLOCK_SIZE,\n\t\t\t.cra_ctxsize\t\t= sizeof(struct ocs_hcu_ctx),\n\t\t\t.cra_alignmask\t\t= 0,\n\t\t\t.cra_module\t\t= THIS_MODULE,\n\t\t\t.cra_init\t\t= kmb_ocs_hcu_sha_cra_init,\n\t\t}\n\t},\n\t.op.do_one_request = kmb_ocs_hcu_do_one_request,\n},\n{\n\t.base.init\t\t= kmb_ocs_hcu_init,\n\t.base.update\t\t= kmb_ocs_hcu_update,\n\t.base.final\t\t= kmb_ocs_hcu_final,\n\t.base.finup\t\t= kmb_ocs_hcu_finup,\n\t.base.digest\t\t= kmb_ocs_hcu_digest,\n\t.base.export\t\t= kmb_ocs_hcu_export,\n\t.base.import\t\t= kmb_ocs_hcu_import,\n\t.base.setkey\t\t= kmb_ocs_hcu_setkey,\n\t.base.halg = {\n\t\t.digestsize\t= SHA384_DIGEST_SIZE,\n\t\t.statesize\t= sizeof(struct ocs_hcu_rctx),\n\t\t.base\t= {\n\t\t\t.cra_name\t\t= \"hmac(sha384)\",\n\t\t\t.cra_driver_name\t= \"hmac-sha384-keembay-ocs\",\n\t\t\t.cra_priority\t\t= 255,\n\t\t\t.cra_flags\t\t= CRYPTO_ALG_ASYNC,\n\t\t\t.cra_blocksize\t\t= SHA384_BLOCK_SIZE,\n\t\t\t.cra_ctxsize\t\t= sizeof(struct ocs_hcu_ctx),\n\t\t\t.cra_alignmask\t\t= 0,\n\t\t\t.cra_module\t\t= THIS_MODULE,\n\t\t\t.cra_init\t\t= kmb_ocs_hcu_hmac_cra_init,\n\t\t\t.cra_exit\t\t= kmb_ocs_hcu_hmac_cra_exit,\n\t\t}\n\t},\n\t.op.do_one_request = kmb_ocs_hcu_do_one_request,\n},\n{\n\t.base.init\t\t= kmb_ocs_hcu_init,\n\t.base.update\t\t= kmb_ocs_hcu_update,\n\t.base.final\t\t= kmb_ocs_hcu_final,\n\t.base.finup\t\t= kmb_ocs_hcu_finup,\n\t.base.digest\t\t= kmb_ocs_hcu_digest,\n\t.base.export\t\t= kmb_ocs_hcu_export,\n\t.base.import\t\t= kmb_ocs_hcu_import,\n\t.base.halg = {\n\t\t.digestsize\t= SHA512_DIGEST_SIZE,\n\t\t.statesize\t= sizeof(struct ocs_hcu_rctx),\n\t\t.base\t= {\n\t\t\t.cra_name\t\t= \"sha512\",\n\t\t\t.cra_driver_name\t= \"sha512-keembay-ocs\",\n\t\t\t.cra_priority\t\t= 255,\n\t\t\t.cra_flags\t\t= CRYPTO_ALG_ASYNC,\n\t\t\t.cra_blocksize\t\t= SHA512_BLOCK_SIZE,\n\t\t\t.cra_ctxsize\t\t= sizeof(struct ocs_hcu_ctx),\n\t\t\t.cra_alignmask\t\t= 0,\n\t\t\t.cra_module\t\t= THIS_MODULE,\n\t\t\t.cra_init\t\t= kmb_ocs_hcu_sha_cra_init,\n\t\t}\n\t},\n\t.op.do_one_request = kmb_ocs_hcu_do_one_request,\n},\n{\n\t.base.init\t\t= kmb_ocs_hcu_init,\n\t.base.update\t\t= kmb_ocs_hcu_update,\n\t.base.final\t\t= kmb_ocs_hcu_final,\n\t.base.finup\t\t= kmb_ocs_hcu_finup,\n\t.base.digest\t\t= kmb_ocs_hcu_digest,\n\t.base.export\t\t= kmb_ocs_hcu_export,\n\t.base.import\t\t= kmb_ocs_hcu_import,\n\t.base.setkey\t\t= kmb_ocs_hcu_setkey,\n\t.base.halg = {\n\t\t.digestsize\t= SHA512_DIGEST_SIZE,\n\t\t.statesize\t= sizeof(struct ocs_hcu_rctx),\n\t\t.base\t= {\n\t\t\t.cra_name\t\t= \"hmac(sha512)\",\n\t\t\t.cra_driver_name\t= \"hmac-sha512-keembay-ocs\",\n\t\t\t.cra_priority\t\t= 255,\n\t\t\t.cra_flags\t\t= CRYPTO_ALG_ASYNC,\n\t\t\t.cra_blocksize\t\t= SHA512_BLOCK_SIZE,\n\t\t\t.cra_ctxsize\t\t= sizeof(struct ocs_hcu_ctx),\n\t\t\t.cra_alignmask\t\t= 0,\n\t\t\t.cra_module\t\t= THIS_MODULE,\n\t\t\t.cra_init\t\t= kmb_ocs_hcu_hmac_cra_init,\n\t\t\t.cra_exit\t\t= kmb_ocs_hcu_hmac_cra_exit,\n\t\t}\n\t},\n\t.op.do_one_request = kmb_ocs_hcu_do_one_request,\n},\n};\n\n \nstatic const struct of_device_id kmb_ocs_hcu_of_match[] = {\n\t{\n\t\t.compatible = \"intel,keembay-ocs-hcu\",\n\t},\n\t{}\n};\n\nstatic int kmb_ocs_hcu_remove(struct platform_device *pdev)\n{\n\tstruct ocs_hcu_dev *hcu_dev;\n\tint rc;\n\n\thcu_dev = platform_get_drvdata(pdev);\n\tif (!hcu_dev)\n\t\treturn -ENODEV;\n\n\tcrypto_engine_unregister_ahashes(ocs_hcu_algs, ARRAY_SIZE(ocs_hcu_algs));\n\n\trc = crypto_engine_exit(hcu_dev->engine);\n\n\tspin_lock_bh(&ocs_hcu.lock);\n\tlist_del(&hcu_dev->list);\n\tspin_unlock_bh(&ocs_hcu.lock);\n\n\treturn rc;\n}\n\nstatic int kmb_ocs_hcu_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct ocs_hcu_dev *hcu_dev;\n\tint rc;\n\n\thcu_dev = devm_kzalloc(dev, sizeof(*hcu_dev), GFP_KERNEL);\n\tif (!hcu_dev)\n\t\treturn -ENOMEM;\n\n\thcu_dev->dev = dev;\n\n\tplatform_set_drvdata(pdev, hcu_dev);\n\trc = dma_set_mask_and_coherent(&pdev->dev, OCS_HCU_DMA_BIT_MASK);\n\tif (rc)\n\t\treturn rc;\n\n\thcu_dev->io_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(hcu_dev->io_base))\n\t\treturn PTR_ERR(hcu_dev->io_base);\n\n\tinit_completion(&hcu_dev->irq_done);\n\n\t \n\thcu_dev->irq = platform_get_irq(pdev, 0);\n\tif (hcu_dev->irq < 0)\n\t\treturn hcu_dev->irq;\n\n\trc = devm_request_threaded_irq(&pdev->dev, hcu_dev->irq,\n\t\t\t\t       ocs_hcu_irq_handler, NULL, 0,\n\t\t\t\t       \"keembay-ocs-hcu\", hcu_dev);\n\tif (rc < 0) {\n\t\tdev_err(dev, \"Could not request IRQ.\\n\");\n\t\treturn rc;\n\t}\n\n\tINIT_LIST_HEAD(&hcu_dev->list);\n\n\tspin_lock_bh(&ocs_hcu.lock);\n\tlist_add_tail(&hcu_dev->list, &ocs_hcu.dev_list);\n\tspin_unlock_bh(&ocs_hcu.lock);\n\n\t \n\thcu_dev->engine = crypto_engine_alloc_init(dev, 1);\n\tif (!hcu_dev->engine) {\n\t\trc = -ENOMEM;\n\t\tgoto list_del;\n\t}\n\n\trc = crypto_engine_start(hcu_dev->engine);\n\tif (rc) {\n\t\tdev_err(dev, \"Could not start engine.\\n\");\n\t\tgoto cleanup;\n\t}\n\n\t \n\n\trc = crypto_engine_register_ahashes(ocs_hcu_algs, ARRAY_SIZE(ocs_hcu_algs));\n\tif (rc) {\n\t\tdev_err(dev, \"Could not register algorithms.\\n\");\n\t\tgoto cleanup;\n\t}\n\n\treturn 0;\n\ncleanup:\n\tcrypto_engine_exit(hcu_dev->engine);\nlist_del:\n\tspin_lock_bh(&ocs_hcu.lock);\n\tlist_del(&hcu_dev->list);\n\tspin_unlock_bh(&ocs_hcu.lock);\n\n\treturn rc;\n}\n\n \nstatic struct platform_driver kmb_ocs_hcu_driver = {\n\t.probe = kmb_ocs_hcu_probe,\n\t.remove = kmb_ocs_hcu_remove,\n\t.driver = {\n\t\t\t.name = DRV_NAME,\n\t\t\t.of_match_table = kmb_ocs_hcu_of_match,\n\t\t},\n};\n\nmodule_platform_driver(kmb_ocs_hcu_driver);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}