{
  "module_name": "keembay-ocs-ecc.c",
  "hash_id": "544b2d91dacbe466884fa8016aac8e1668812ace1de8d7ae2d98ea3add2fddbc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/intel/keembay/keembay-ocs-ecc.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <crypto/ecc_curve.h>\n#include <crypto/ecdh.h>\n#include <crypto/engine.h>\n#include <crypto/internal/ecc.h>\n#include <crypto/internal/kpp.h>\n#include <crypto/kpp.h>\n#include <crypto/rng.h>\n#include <linux/clk.h>\n#include <linux/completion.h>\n#include <linux/err.h>\n#include <linux/fips.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/irq.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/scatterlist.h>\n#include <linux/string.h>\n\n#define DRV_NAME\t\t\t\"keembay-ocs-ecc\"\n\n#define KMB_OCS_ECC_PRIORITY\t\t350\n\n#define HW_OFFS_OCS_ECC_COMMAND\t\t0x00000000\n#define HW_OFFS_OCS_ECC_STATUS\t\t0x00000004\n#define HW_OFFS_OCS_ECC_DATA_IN\t\t0x00000080\n#define HW_OFFS_OCS_ECC_CX_DATA_OUT\t0x00000100\n#define HW_OFFS_OCS_ECC_CY_DATA_OUT\t0x00000180\n#define HW_OFFS_OCS_ECC_ISR\t\t0x00000400\n#define HW_OFFS_OCS_ECC_IER\t\t0x00000404\n\n#define HW_OCS_ECC_ISR_INT_STATUS_DONE\tBIT(0)\n#define HW_OCS_ECC_COMMAND_INS_BP\tBIT(0)\n\n#define HW_OCS_ECC_COMMAND_START_VAL\tBIT(0)\n\n#define OCS_ECC_OP_SIZE_384\t\tBIT(8)\n#define OCS_ECC_OP_SIZE_256\t\t0\n\n \n#define OCS_ECC_INST_WRITE_AX\t\t(0x1 << HW_OCS_ECC_COMMAND_INS_BP)\n#define OCS_ECC_INST_WRITE_AY\t\t(0x2 << HW_OCS_ECC_COMMAND_INS_BP)\n#define OCS_ECC_INST_WRITE_BX_D\t\t(0x3 << HW_OCS_ECC_COMMAND_INS_BP)\n#define OCS_ECC_INST_WRITE_BY_L\t\t(0x4 << HW_OCS_ECC_COMMAND_INS_BP)\n#define OCS_ECC_INST_WRITE_P\t\t(0x5 << HW_OCS_ECC_COMMAND_INS_BP)\n#define OCS_ECC_INST_WRITE_A\t\t(0x6 << HW_OCS_ECC_COMMAND_INS_BP)\n#define OCS_ECC_INST_CALC_D_IDX_A\t(0x8 << HW_OCS_ECC_COMMAND_INS_BP)\n#define OCS_ECC_INST_CALC_A_POW_B_MODP\t(0xB << HW_OCS_ECC_COMMAND_INS_BP)\n#define OCS_ECC_INST_CALC_A_MUL_B_MODP\t(0xC  << HW_OCS_ECC_COMMAND_INS_BP)\n#define OCS_ECC_INST_CALC_A_ADD_B_MODP\t(0xD << HW_OCS_ECC_COMMAND_INS_BP)\n\n#define ECC_ENABLE_INTR\t\t\t1\n\n#define POLL_USEC\t\t\t100\n#define TIMEOUT_USEC\t\t\t10000\n\n#define KMB_ECC_VLI_MAX_DIGITS\t\tECC_CURVE_NIST_P384_DIGITS\n#define KMB_ECC_VLI_MAX_BYTES\t\t(KMB_ECC_VLI_MAX_DIGITS \\\n\t\t\t\t\t << ECC_DIGITS_TO_BYTES_SHIFT)\n\n#define POW_CUBE\t\t\t3\n\n \nstruct ocs_ecc_dev {\n\tstruct list_head list;\n\tstruct device *dev;\n\tvoid __iomem *base_reg;\n\tstruct crypto_engine *engine;\n\tstruct completion irq_done;\n\tint irq;\n};\n\n \nstruct ocs_ecc_ctx {\n\tstruct ocs_ecc_dev *ecc_dev;\n\tconst struct ecc_curve *curve;\n\tu64 private_key[KMB_ECC_VLI_MAX_DIGITS];\n};\n\n \nstruct ocs_ecc_drv {\n\tstruct list_head dev_list;\n\tspinlock_t lock;\t \n};\n\n \nstatic struct ocs_ecc_drv ocs_ecc = {\n\t.dev_list = LIST_HEAD_INIT(ocs_ecc.dev_list),\n\t.lock = __SPIN_LOCK_UNLOCKED(ocs_ecc.lock),\n};\n\n \nstatic inline struct ocs_ecc_ctx *kmb_ocs_ecc_tctx(struct kpp_request *req)\n{\n\treturn kpp_tfm_ctx(crypto_kpp_reqtfm(req));\n}\n\n \nstatic inline unsigned int digits_to_bytes(unsigned int n)\n{\n\treturn n << ECC_DIGITS_TO_BYTES_SHIFT;\n}\n\n \nstatic inline int ocs_ecc_wait_idle(struct ocs_ecc_dev *dev)\n{\n\tu32 value;\n\n\treturn readl_poll_timeout((dev->base_reg + HW_OFFS_OCS_ECC_STATUS),\n\t\t\t\t  value,\n\t\t\t\t  !(value & HW_OCS_ECC_ISR_INT_STATUS_DONE),\n\t\t\t\t  POLL_USEC, TIMEOUT_USEC);\n}\n\nstatic void ocs_ecc_cmd_start(struct ocs_ecc_dev *ecc_dev, u32 op_size)\n{\n\tiowrite32(op_size | HW_OCS_ECC_COMMAND_START_VAL,\n\t\t  ecc_dev->base_reg + HW_OFFS_OCS_ECC_COMMAND);\n}\n\n \nstatic void ocs_ecc_write_cmd_and_data(struct ocs_ecc_dev *dev,\n\t\t\t\t       u32 op_size,\n\t\t\t\t       u32 inst,\n\t\t\t\t       const void *data_in,\n\t\t\t\t       size_t data_size)\n{\n\tiowrite32(op_size | inst, dev->base_reg + HW_OFFS_OCS_ECC_COMMAND);\n\n\t \n\tmemcpy_toio(dev->base_reg + HW_OFFS_OCS_ECC_DATA_IN, data_in,\n\t\t    data_size);\n}\n\n \nstatic int ocs_ecc_trigger_op(struct ocs_ecc_dev *ecc_dev, u32 op_size,\n\t\t\t      u32 inst)\n{\n\treinit_completion(&ecc_dev->irq_done);\n\n\tiowrite32(ECC_ENABLE_INTR, ecc_dev->base_reg + HW_OFFS_OCS_ECC_IER);\n\tiowrite32(op_size | inst, ecc_dev->base_reg + HW_OFFS_OCS_ECC_COMMAND);\n\n\treturn wait_for_completion_interruptible(&ecc_dev->irq_done);\n}\n\n \nstatic inline void ocs_ecc_read_cx_out(struct ocs_ecc_dev *dev, void *cx_out,\n\t\t\t\t       size_t byte_count)\n{\n\tmemcpy_fromio(cx_out, dev->base_reg + HW_OFFS_OCS_ECC_CX_DATA_OUT,\n\t\t      byte_count);\n}\n\n \nstatic inline void ocs_ecc_read_cy_out(struct ocs_ecc_dev *dev, void *cy_out,\n\t\t\t\t       size_t byte_count)\n{\n\tmemcpy_fromio(cy_out, dev->base_reg + HW_OFFS_OCS_ECC_CY_DATA_OUT,\n\t\t      byte_count);\n}\n\nstatic struct ocs_ecc_dev *kmb_ocs_ecc_find_dev(struct ocs_ecc_ctx *tctx)\n{\n\tif (tctx->ecc_dev)\n\t\treturn tctx->ecc_dev;\n\n\tspin_lock(&ocs_ecc.lock);\n\n\t \n\ttctx->ecc_dev = list_first_entry(&ocs_ecc.dev_list, struct ocs_ecc_dev,\n\t\t\t\t\t list);\n\n\tspin_unlock(&ocs_ecc.lock);\n\n\treturn tctx->ecc_dev;\n}\n\n \nstatic int kmb_ecc_point_mult(struct ocs_ecc_dev *ecc_dev,\n\t\t\t      struct ecc_point *result,\n\t\t\t      const struct ecc_point *point,\n\t\t\t      u64 *scalar,\n\t\t\t      const struct ecc_curve *curve)\n{\n\tu8 sca[KMB_ECC_VLI_MAX_BYTES];  \n\tu32 op_size = (curve->g.ndigits > ECC_CURVE_NIST_P256_DIGITS) ?\n\t\t      OCS_ECC_OP_SIZE_384 : OCS_ECC_OP_SIZE_256;\n\tsize_t nbytes = digits_to_bytes(curve->g.ndigits);\n\tint rc = 0;\n\n\t \n\trc = crypto_get_default_rng();\n\tif (rc)\n\t\treturn rc;\n\n\trc = crypto_rng_get_bytes(crypto_default_rng, sca, nbytes);\n\tcrypto_put_default_rng();\n\tif (rc)\n\t\treturn rc;\n\n\t \n\trc = ocs_ecc_wait_idle(ecc_dev);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tocs_ecc_cmd_start(ecc_dev, op_size);\n\n\t \n\tocs_ecc_write_cmd_and_data(ecc_dev, op_size, OCS_ECC_INST_WRITE_AX,\n\t\t\t\t   point->x, nbytes);\n\n\t \n\tocs_ecc_write_cmd_and_data(ecc_dev, op_size, OCS_ECC_INST_WRITE_AY,\n\t\t\t\t   point->y, nbytes);\n\n\t \n\tocs_ecc_write_cmd_and_data(ecc_dev, op_size, OCS_ECC_INST_WRITE_BX_D,\n\t\t\t\t   scalar, nbytes);\n\n\t \n\tocs_ecc_write_cmd_and_data(ecc_dev, op_size, OCS_ECC_INST_WRITE_BY_L,\n\t\t\t\t   sca, nbytes);\n\tmemzero_explicit(sca, sizeof(sca));\n\n\t \n\tocs_ecc_write_cmd_and_data(ecc_dev, op_size, OCS_ECC_INST_WRITE_P,\n\t\t\t\t   curve->p, nbytes);\n\n\t \n\tocs_ecc_write_cmd_and_data(ecc_dev, op_size, OCS_ECC_INST_WRITE_A,\n\t\t\t\t   curve->a, nbytes);\n\n\t \n\trc = ocs_ecc_trigger_op(ecc_dev, op_size, OCS_ECC_INST_CALC_D_IDX_A);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tocs_ecc_read_cx_out(ecc_dev, result->x, nbytes);\n\tocs_ecc_read_cy_out(ecc_dev, result->y, nbytes);\n\n\treturn 0;\n}\n\n \nstatic int kmb_ecc_do_scalar_op(struct ocs_ecc_dev *ecc_dev, u64 *scalar_out,\n\t\t\t\tconst u64 *scalar_a, const u64 *scalar_b,\n\t\t\t\tconst struct ecc_curve *curve,\n\t\t\t\tunsigned int ndigits, const u32 inst)\n{\n\tu32 op_size = (ndigits > ECC_CURVE_NIST_P256_DIGITS) ?\n\t\t      OCS_ECC_OP_SIZE_384 : OCS_ECC_OP_SIZE_256;\n\tsize_t nbytes = digits_to_bytes(ndigits);\n\tint rc;\n\n\t \n\trc = ocs_ecc_wait_idle(ecc_dev);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tocs_ecc_cmd_start(ecc_dev, op_size);\n\n\t \n\tocs_ecc_write_cmd_and_data(ecc_dev, op_size, OCS_ECC_INST_WRITE_AX,\n\t\t\t\t   scalar_a, nbytes);\n\n\t \n\tocs_ecc_write_cmd_and_data(ecc_dev, op_size, OCS_ECC_INST_WRITE_AY,\n\t\t\t\t   scalar_b, nbytes);\n\n\t \n\tocs_ecc_write_cmd_and_data(ecc_dev, op_size, OCS_ECC_INST_WRITE_P,\n\t\t\t\t   curve->p, nbytes);\n\n\t \n\trc = ocs_ecc_trigger_op(ecc_dev, op_size, inst);\n\tif (rc)\n\t\treturn rc;\n\n\tocs_ecc_read_cx_out(ecc_dev, scalar_out, nbytes);\n\n\tif (vli_is_zero(scalar_out, ndigits))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n \nstatic int kmb_ocs_ecc_is_pubkey_valid_partial(struct ocs_ecc_dev *ecc_dev,\n\t\t\t\t\t       const struct ecc_curve *curve,\n\t\t\t\t\t       struct ecc_point *pk)\n{\n\tu64 xxx[KMB_ECC_VLI_MAX_DIGITS] = { 0 };\n\tu64 yy[KMB_ECC_VLI_MAX_DIGITS] = { 0 };\n\tu64 w[KMB_ECC_VLI_MAX_DIGITS] = { 0 };\n\tint rc;\n\n\tif (WARN_ON(pk->ndigits != curve->g.ndigits))\n\t\treturn -EINVAL;\n\n\t \n\tif (ecc_point_is_zero(pk))\n\t\treturn -EINVAL;\n\n\t \n\tif (vli_cmp(curve->p, pk->x, pk->ndigits) != 1)\n\t\treturn -EINVAL;\n\n\tif (vli_cmp(curve->p, pk->y, pk->ndigits) != 1)\n\t\treturn -EINVAL;\n\n\t \n\n\t  \n\t \n\trc = kmb_ecc_do_scalar_op(ecc_dev, yy, pk->y, pk->y, curve, pk->ndigits,\n\t\t\t\t  OCS_ECC_INST_CALC_A_MUL_B_MODP);\n\tif (rc)\n\t\tgoto exit;\n\n\t \n\t \n\tw[0] = POW_CUBE;\n\t \n\trc = kmb_ecc_do_scalar_op(ecc_dev, xxx, pk->x, w, curve, pk->ndigits,\n\t\t\t\t  OCS_ECC_INST_CALC_A_POW_B_MODP);\n\tif (rc)\n\t\tgoto exit;\n\n\t \n\trc = kmb_ecc_do_scalar_op(ecc_dev, w, curve->a, pk->x, curve,\n\t\t\t\t  pk->ndigits,\n\t\t\t\t  OCS_ECC_INST_CALC_A_MUL_B_MODP);\n\tif (rc)\n\t\tgoto exit;\n\n\t \n\trc = kmb_ecc_do_scalar_op(ecc_dev, w, w, curve->b, curve,\n\t\t\t\t  pk->ndigits,\n\t\t\t\t  OCS_ECC_INST_CALC_A_ADD_B_MODP);\n\tif (rc)\n\t\tgoto exit;\n\n\t \n\trc = kmb_ecc_do_scalar_op(ecc_dev, w, xxx, w, curve, pk->ndigits,\n\t\t\t\t  OCS_ECC_INST_CALC_A_ADD_B_MODP);\n\tif (rc)\n\t\tgoto exit;\n\n\t \n\trc = vli_cmp(yy, w, pk->ndigits);\n\tif (rc)\n\t\trc = -EINVAL;\n\nexit:\n\tmemzero_explicit(xxx, sizeof(xxx));\n\tmemzero_explicit(yy, sizeof(yy));\n\tmemzero_explicit(w, sizeof(w));\n\n\treturn rc;\n}\n\n \nstatic int kmb_ocs_ecc_is_pubkey_valid_full(struct ocs_ecc_dev *ecc_dev,\n\t\t\t\t\t    const struct ecc_curve *curve,\n\t\t\t\t\t    struct ecc_point *pk)\n{\n\tstruct ecc_point *nQ;\n\tint rc;\n\n\t \n\trc = kmb_ocs_ecc_is_pubkey_valid_partial(ecc_dev, curve, pk);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tnQ = ecc_alloc_point(pk->ndigits);\n\tif (!nQ)\n\t\treturn -ENOMEM;\n\n\trc = kmb_ecc_point_mult(ecc_dev, nQ, pk, curve->n, curve);\n\tif (rc)\n\t\tgoto exit;\n\n\tif (!ecc_point_is_zero(nQ))\n\t\trc = -EINVAL;\n\nexit:\n\tecc_free_point(nQ);\n\n\treturn rc;\n}\n\nstatic int kmb_ecc_is_key_valid(const struct ecc_curve *curve,\n\t\t\t\tconst u64 *private_key, size_t private_key_len)\n{\n\tsize_t ndigits = curve->g.ndigits;\n\tu64 one[KMB_ECC_VLI_MAX_DIGITS] = {1};\n\tu64 res[KMB_ECC_VLI_MAX_DIGITS];\n\n\tif (private_key_len != digits_to_bytes(ndigits))\n\t\treturn -EINVAL;\n\n\tif (!private_key)\n\t\treturn -EINVAL;\n\n\t \n\tif (vli_cmp(one, private_key, ndigits) != -1)\n\t\treturn -EINVAL;\n\n\tvli_sub(res, curve->n, one, ndigits);\n\tvli_sub(res, res, one, ndigits);\n\tif (vli_cmp(res, private_key, ndigits) != 1)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n \nstatic int kmb_ecc_gen_privkey(const struct ecc_curve *curve, u64 *privkey)\n{\n\tsize_t nbytes = digits_to_bytes(curve->g.ndigits);\n\tu64 priv[KMB_ECC_VLI_MAX_DIGITS];\n\tsize_t nbits;\n\tint rc;\n\n\tnbits = vli_num_bits(curve->n, curve->g.ndigits);\n\n\t \n\tif (nbits < 160 || curve->g.ndigits > ARRAY_SIZE(priv))\n\t\treturn -EINVAL;\n\n\t \n\tif (crypto_get_default_rng())\n\t\treturn -EFAULT;\n\n\trc = crypto_rng_get_bytes(crypto_default_rng, (u8 *)priv, nbytes);\n\tcrypto_put_default_rng();\n\tif (rc)\n\t\tgoto cleanup;\n\n\trc = kmb_ecc_is_key_valid(curve, priv, nbytes);\n\tif (rc)\n\t\tgoto cleanup;\n\n\tecc_swap_digits(priv, privkey, curve->g.ndigits);\n\ncleanup:\n\tmemzero_explicit(&priv, sizeof(priv));\n\n\treturn rc;\n}\n\nstatic int kmb_ocs_ecdh_set_secret(struct crypto_kpp *tfm, const void *buf,\n\t\t\t\t   unsigned int len)\n{\n\tstruct ocs_ecc_ctx *tctx = kpp_tfm_ctx(tfm);\n\tstruct ecdh params;\n\tint rc = 0;\n\n\trc = crypto_ecdh_decode_key(buf, len, &params);\n\tif (rc)\n\t\tgoto cleanup;\n\n\t \n\tif (params.key_size > digits_to_bytes(tctx->curve->g.ndigits)) {\n\t\trc = -EINVAL;\n\t\tgoto cleanup;\n\t}\n\n\t \n\tif (!params.key || !params.key_size) {\n\t\trc = kmb_ecc_gen_privkey(tctx->curve, tctx->private_key);\n\t\tgoto cleanup;\n\t}\n\n\trc = kmb_ecc_is_key_valid(tctx->curve, (const u64 *)params.key,\n\t\t\t\t  params.key_size);\n\tif (rc)\n\t\tgoto cleanup;\n\n\tecc_swap_digits((const u64 *)params.key, tctx->private_key,\n\t\t\ttctx->curve->g.ndigits);\ncleanup:\n\tmemzero_explicit(&params, sizeof(params));\n\n\tif (rc)\n\t\ttctx->curve = NULL;\n\n\treturn rc;\n}\n\n \nstatic int kmb_ecc_do_shared_secret(struct ocs_ecc_ctx *tctx,\n\t\t\t\t    struct kpp_request *req)\n{\n\tstruct ocs_ecc_dev *ecc_dev = tctx->ecc_dev;\n\tconst struct ecc_curve *curve = tctx->curve;\n\tu64 shared_secret[KMB_ECC_VLI_MAX_DIGITS];\n\tu64 pubk_buf[KMB_ECC_VLI_MAX_DIGITS * 2];\n\tsize_t copied, nbytes, pubk_len;\n\tstruct ecc_point *pk, *result;\n\tint rc;\n\n\tnbytes = digits_to_bytes(curve->g.ndigits);\n\n\t \n\tpubk_len = 2 * nbytes;\n\n\t \n\tcopied = sg_copy_to_buffer(req->src,\n\t\t\t\t   sg_nents_for_len(req->src, pubk_len),\n\t\t\t\t   pubk_buf, pubk_len);\n\tif (copied != pubk_len)\n\t\treturn -EINVAL;\n\n\t \n\tpk = ecc_alloc_point(curve->g.ndigits);\n\tif (!pk)\n\t\treturn -ENOMEM;\n\n\tecc_swap_digits(pubk_buf, pk->x, curve->g.ndigits);\n\tecc_swap_digits(&pubk_buf[curve->g.ndigits], pk->y, curve->g.ndigits);\n\n\t \n\trc = kmb_ocs_ecc_is_pubkey_valid_partial(ecc_dev, curve, pk);\n\tif (rc)\n\t\tgoto exit_free_pk;\n\n\t \n\tresult = ecc_alloc_point(pk->ndigits);\n\tif (!result) {\n\t\trc = -ENOMEM;\n\t\tgoto exit_free_pk;\n\t}\n\n\t \n\trc = kmb_ecc_point_mult(ecc_dev, result, pk, tctx->private_key, curve);\n\tif (rc)\n\t\tgoto exit_free_result;\n\n\tif (ecc_point_is_zero(result)) {\n\t\trc = -EFAULT;\n\t\tgoto exit_free_result;\n\t}\n\n\t \n\tecc_swap_digits(result->x, shared_secret, result->ndigits);\n\n\t \n\tnbytes = min_t(size_t, nbytes, req->dst_len);\n\n\tcopied = sg_copy_from_buffer(req->dst,\n\t\t\t\t     sg_nents_for_len(req->dst, nbytes),\n\t\t\t\t     shared_secret, nbytes);\n\n\tif (copied != nbytes)\n\t\trc = -EINVAL;\n\n\tmemzero_explicit(shared_secret, sizeof(shared_secret));\n\nexit_free_result:\n\tecc_free_point(result);\n\nexit_free_pk:\n\tecc_free_point(pk);\n\n\treturn rc;\n}\n\n \nstatic int kmb_ecc_do_public_key(struct ocs_ecc_ctx *tctx,\n\t\t\t\t struct kpp_request *req)\n{\n\tconst struct ecc_curve *curve = tctx->curve;\n\tu64 pubk_buf[KMB_ECC_VLI_MAX_DIGITS * 2];\n\tstruct ecc_point *pk;\n\tsize_t pubk_len;\n\tsize_t copied;\n\tint rc;\n\n\t \n\tpubk_len = 2 * digits_to_bytes(curve->g.ndigits);\n\n\tpk = ecc_alloc_point(curve->g.ndigits);\n\tif (!pk)\n\t\treturn -ENOMEM;\n\n\t \n\trc = kmb_ecc_point_mult(tctx->ecc_dev, pk, &curve->g, tctx->private_key,\n\t\t\t\tcurve);\n\tif (rc)\n\t\tgoto exit;\n\n\t \n\tif (kmb_ocs_ecc_is_pubkey_valid_full(tctx->ecc_dev, curve, pk)) {\n\t\trc = -EAGAIN;\n\t\tgoto exit;\n\t}\n\n\t \n\tecc_swap_digits(pk->x, pubk_buf, pk->ndigits);\n\tecc_swap_digits(pk->y, &pubk_buf[pk->ndigits], pk->ndigits);\n\n\t \n\tcopied = sg_copy_from_buffer(req->dst,\n\t\t\t\t     sg_nents_for_len(req->dst, pubk_len),\n\t\t\t\t     pubk_buf, pubk_len);\n\n\tif (copied != pubk_len)\n\t\trc = -EINVAL;\n\nexit:\n\tecc_free_point(pk);\n\n\treturn rc;\n}\n\nstatic int kmb_ocs_ecc_do_one_request(struct crypto_engine *engine,\n\t\t\t\t      void *areq)\n{\n\tstruct kpp_request *req = container_of(areq, struct kpp_request, base);\n\tstruct ocs_ecc_ctx *tctx = kmb_ocs_ecc_tctx(req);\n\tstruct ocs_ecc_dev *ecc_dev = tctx->ecc_dev;\n\tint rc;\n\n\tif (req->src)\n\t\trc = kmb_ecc_do_shared_secret(tctx, req);\n\telse\n\t\trc = kmb_ecc_do_public_key(tctx, req);\n\n\tcrypto_finalize_kpp_request(ecc_dev->engine, req, rc);\n\n\treturn 0;\n}\n\nstatic int kmb_ocs_ecdh_generate_public_key(struct kpp_request *req)\n{\n\tstruct ocs_ecc_ctx *tctx = kmb_ocs_ecc_tctx(req);\n\tconst struct ecc_curve *curve = tctx->curve;\n\n\t \n\tif (!tctx->curve)\n\t\treturn -EINVAL;\n\n\t \n\tif (!req->dst)\n\t\treturn -EINVAL;\n\n\t \n\tif (req->dst_len < (2 * digits_to_bytes(curve->g.ndigits)))\n\t\treturn -EINVAL;\n\n\t \n\tif (req->src)\n\t\treturn -EINVAL;\n\n\treturn crypto_transfer_kpp_request_to_engine(tctx->ecc_dev->engine,\n\t\t\t\t\t\t     req);\n}\n\nstatic int kmb_ocs_ecdh_compute_shared_secret(struct kpp_request *req)\n{\n\tstruct ocs_ecc_ctx *tctx = kmb_ocs_ecc_tctx(req);\n\tconst struct ecc_curve *curve = tctx->curve;\n\n\t \n\tif (!tctx->curve)\n\t\treturn -EINVAL;\n\n\t \n\tif (!req->dst)\n\t\treturn -EINVAL;\n\n\t \n\tif (!req->src)\n\t\treturn -EINVAL;\n\n\t \n\tif (req->src_len != 2 * digits_to_bytes(curve->g.ndigits))\n\t\treturn -EINVAL;\n\n\treturn crypto_transfer_kpp_request_to_engine(tctx->ecc_dev->engine,\n\t\t\t\t\t\t     req);\n}\n\nstatic int kmb_ecc_tctx_init(struct ocs_ecc_ctx *tctx, unsigned int curve_id)\n{\n\tmemset(tctx, 0, sizeof(*tctx));\n\n\ttctx->ecc_dev = kmb_ocs_ecc_find_dev(tctx);\n\n\tif (IS_ERR(tctx->ecc_dev)) {\n\t\tpr_err(\"Failed to find the device : %ld\\n\",\n\t\t       PTR_ERR(tctx->ecc_dev));\n\t\treturn PTR_ERR(tctx->ecc_dev);\n\t}\n\n\ttctx->curve = ecc_get_curve(curve_id);\n\tif (!tctx->curve)\n\t\treturn -EOPNOTSUPP;\n\n\treturn 0;\n}\n\nstatic int kmb_ocs_ecdh_nist_p256_init_tfm(struct crypto_kpp *tfm)\n{\n\tstruct ocs_ecc_ctx *tctx = kpp_tfm_ctx(tfm);\n\n\treturn kmb_ecc_tctx_init(tctx, ECC_CURVE_NIST_P256);\n}\n\nstatic int kmb_ocs_ecdh_nist_p384_init_tfm(struct crypto_kpp *tfm)\n{\n\tstruct ocs_ecc_ctx *tctx = kpp_tfm_ctx(tfm);\n\n\treturn kmb_ecc_tctx_init(tctx, ECC_CURVE_NIST_P384);\n}\n\nstatic void kmb_ocs_ecdh_exit_tfm(struct crypto_kpp *tfm)\n{\n\tstruct ocs_ecc_ctx *tctx = kpp_tfm_ctx(tfm);\n\n\tmemzero_explicit(tctx->private_key, sizeof(*tctx->private_key));\n}\n\nstatic unsigned int kmb_ocs_ecdh_max_size(struct crypto_kpp *tfm)\n{\n\tstruct ocs_ecc_ctx *tctx = kpp_tfm_ctx(tfm);\n\n\t \n\treturn digits_to_bytes(tctx->curve->g.ndigits) * 2;\n}\n\nstatic struct kpp_engine_alg ocs_ecdh_p256 = {\n\t.base.set_secret = kmb_ocs_ecdh_set_secret,\n\t.base.generate_public_key = kmb_ocs_ecdh_generate_public_key,\n\t.base.compute_shared_secret = kmb_ocs_ecdh_compute_shared_secret,\n\t.base.init = kmb_ocs_ecdh_nist_p256_init_tfm,\n\t.base.exit = kmb_ocs_ecdh_exit_tfm,\n\t.base.max_size = kmb_ocs_ecdh_max_size,\n\t.base.base = {\n\t\t.cra_name = \"ecdh-nist-p256\",\n\t\t.cra_driver_name = \"ecdh-nist-p256-keembay-ocs\",\n\t\t.cra_priority = KMB_OCS_ECC_PRIORITY,\n\t\t.cra_module = THIS_MODULE,\n\t\t.cra_ctxsize = sizeof(struct ocs_ecc_ctx),\n\t},\n\t.op.do_one_request = kmb_ocs_ecc_do_one_request,\n};\n\nstatic struct kpp_engine_alg ocs_ecdh_p384 = {\n\t.base.set_secret = kmb_ocs_ecdh_set_secret,\n\t.base.generate_public_key = kmb_ocs_ecdh_generate_public_key,\n\t.base.compute_shared_secret = kmb_ocs_ecdh_compute_shared_secret,\n\t.base.init = kmb_ocs_ecdh_nist_p384_init_tfm,\n\t.base.exit = kmb_ocs_ecdh_exit_tfm,\n\t.base.max_size = kmb_ocs_ecdh_max_size,\n\t.base.base = {\n\t\t.cra_name = \"ecdh-nist-p384\",\n\t\t.cra_driver_name = \"ecdh-nist-p384-keembay-ocs\",\n\t\t.cra_priority = KMB_OCS_ECC_PRIORITY,\n\t\t.cra_module = THIS_MODULE,\n\t\t.cra_ctxsize = sizeof(struct ocs_ecc_ctx),\n\t},\n\t.op.do_one_request = kmb_ocs_ecc_do_one_request,\n};\n\nstatic irqreturn_t ocs_ecc_irq_handler(int irq, void *dev_id)\n{\n\tstruct ocs_ecc_dev *ecc_dev = dev_id;\n\tu32 status;\n\n\t \n\tstatus = ioread32(ecc_dev->base_reg + HW_OFFS_OCS_ECC_ISR);\n\tiowrite32(status, ecc_dev->base_reg + HW_OFFS_OCS_ECC_ISR);\n\n\tif (!(status & HW_OCS_ECC_ISR_INT_STATUS_DONE))\n\t\treturn IRQ_NONE;\n\n\tcomplete(&ecc_dev->irq_done);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int kmb_ocs_ecc_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct ocs_ecc_dev *ecc_dev;\n\tint rc;\n\n\tecc_dev = devm_kzalloc(dev, sizeof(*ecc_dev), GFP_KERNEL);\n\tif (!ecc_dev)\n\t\treturn -ENOMEM;\n\n\tecc_dev->dev = dev;\n\n\tplatform_set_drvdata(pdev, ecc_dev);\n\n\tINIT_LIST_HEAD(&ecc_dev->list);\n\tinit_completion(&ecc_dev->irq_done);\n\n\t \n\tecc_dev->base_reg = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(ecc_dev->base_reg)) {\n\t\tdev_err(dev, \"Failed to get base address\\n\");\n\t\trc = PTR_ERR(ecc_dev->base_reg);\n\t\tgoto list_del;\n\t}\n\n\t \n\tecc_dev->irq = platform_get_irq(pdev, 0);\n\tif (ecc_dev->irq < 0) {\n\t\trc = ecc_dev->irq;\n\t\tgoto list_del;\n\t}\n\n\trc = devm_request_threaded_irq(dev, ecc_dev->irq, ocs_ecc_irq_handler,\n\t\t\t\t       NULL, 0, \"keembay-ocs-ecc\", ecc_dev);\n\tif (rc < 0) {\n\t\tdev_err(dev, \"Could not request IRQ\\n\");\n\t\tgoto list_del;\n\t}\n\n\t \n\tspin_lock(&ocs_ecc.lock);\n\tlist_add_tail(&ecc_dev->list, &ocs_ecc.dev_list);\n\tspin_unlock(&ocs_ecc.lock);\n\n\t \n\tecc_dev->engine = crypto_engine_alloc_init(dev, 1);\n\tif (!ecc_dev->engine) {\n\t\tdev_err(dev, \"Could not allocate crypto engine\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto list_del;\n\t}\n\n\trc = crypto_engine_start(ecc_dev->engine);\n\tif (rc) {\n\t\tdev_err(dev, \"Could not start crypto engine\\n\");\n\t\tgoto cleanup;\n\t}\n\n\t \n\trc = crypto_engine_register_kpp(&ocs_ecdh_p256);\n\tif (rc) {\n\t\tdev_err(dev,\n\t\t\t\"Could not register OCS algorithms with Crypto API\\n\");\n\t\tgoto cleanup;\n\t}\n\n\trc = crypto_engine_register_kpp(&ocs_ecdh_p384);\n\tif (rc) {\n\t\tdev_err(dev,\n\t\t\t\"Could not register OCS algorithms with Crypto API\\n\");\n\t\tgoto ocs_ecdh_p384_error;\n\t}\n\n\treturn 0;\n\nocs_ecdh_p384_error:\n\tcrypto_engine_unregister_kpp(&ocs_ecdh_p256);\n\ncleanup:\n\tcrypto_engine_exit(ecc_dev->engine);\n\nlist_del:\n\tspin_lock(&ocs_ecc.lock);\n\tlist_del(&ecc_dev->list);\n\tspin_unlock(&ocs_ecc.lock);\n\n\treturn rc;\n}\n\nstatic int kmb_ocs_ecc_remove(struct platform_device *pdev)\n{\n\tstruct ocs_ecc_dev *ecc_dev;\n\n\tecc_dev = platform_get_drvdata(pdev);\n\n\tcrypto_engine_unregister_kpp(&ocs_ecdh_p384);\n\tcrypto_engine_unregister_kpp(&ocs_ecdh_p256);\n\n\tspin_lock(&ocs_ecc.lock);\n\tlist_del(&ecc_dev->list);\n\tspin_unlock(&ocs_ecc.lock);\n\n\tcrypto_engine_exit(ecc_dev->engine);\n\n\treturn 0;\n}\n\n \nstatic const struct of_device_id kmb_ocs_ecc_of_match[] = {\n\t{\n\t\t.compatible = \"intel,keembay-ocs-ecc\",\n\t},\n\t{}\n};\n\n \nstatic struct platform_driver kmb_ocs_ecc_driver = {\n\t.probe = kmb_ocs_ecc_probe,\n\t.remove = kmb_ocs_ecc_remove,\n\t.driver = {\n\t\t\t.name = DRV_NAME,\n\t\t\t.of_match_table = kmb_ocs_ecc_of_match,\n\t\t},\n};\nmodule_platform_driver(kmb_ocs_ecc_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Intel Keem Bay OCS ECC Driver\");\nMODULE_ALIAS_CRYPTO(\"ecdh-nist-p256\");\nMODULE_ALIAS_CRYPTO(\"ecdh-nist-p384\");\nMODULE_ALIAS_CRYPTO(\"ecdh-nist-p256-keembay-ocs\");\nMODULE_ALIAS_CRYPTO(\"ecdh-nist-p384-keembay-ocs\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}