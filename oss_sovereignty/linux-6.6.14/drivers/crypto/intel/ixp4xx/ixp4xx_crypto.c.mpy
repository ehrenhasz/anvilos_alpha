{
  "module_name": "ixp4xx_crypto.c",
  "hash_id": "5a0470de4eae9830bc9d9e78eaa03b5a7ac50403e3e16bba55604a70b5c0f8e3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/intel/ixp4xx/ixp4xx_crypto.c",
  "human_readable_source": "\n \n\n#include <linux/platform_device.h>\n#include <linux/dma-mapping.h>\n#include <linux/dmapool.h>\n#include <linux/crypto.h>\n#include <linux/kernel.h>\n#include <linux/rtnetlink.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/of.h>\n\n#include <crypto/ctr.h>\n#include <crypto/internal/des.h>\n#include <crypto/aes.h>\n#include <crypto/hmac.h>\n#include <crypto/sha1.h>\n#include <crypto/algapi.h>\n#include <crypto/internal/aead.h>\n#include <crypto/internal/skcipher.h>\n#include <crypto/authenc.h>\n#include <crypto/scatterwalk.h>\n\n#include <linux/soc/ixp4xx/npe.h>\n#include <linux/soc/ixp4xx/qmgr.h>\n\n \n#include <linux/soc/ixp4xx/cpu.h>\n\n#define MAX_KEYLEN 32\n\n \n#define NPE_CTX_LEN 80\n#define AES_BLOCK128 16\n\n#define NPE_OP_HASH_VERIFY   0x01\n#define NPE_OP_CCM_ENABLE    0x04\n#define NPE_OP_CRYPT_ENABLE  0x08\n#define NPE_OP_HASH_ENABLE   0x10\n#define NPE_OP_NOT_IN_PLACE  0x20\n#define NPE_OP_HMAC_DISABLE  0x40\n#define NPE_OP_CRYPT_ENCRYPT 0x80\n\n#define NPE_OP_CCM_GEN_MIC   0xcc\n#define NPE_OP_HASH_GEN_ICV  0x50\n#define NPE_OP_ENC_GEN_KEY   0xc9\n\n#define MOD_ECB     0x0000\n#define MOD_CTR     0x1000\n#define MOD_CBC_ENC 0x2000\n#define MOD_CBC_DEC 0x3000\n#define MOD_CCM_ENC 0x4000\n#define MOD_CCM_DEC 0x5000\n\n#define KEYLEN_128  4\n#define KEYLEN_192  6\n#define KEYLEN_256  8\n\n#define CIPH_DECR   0x0000\n#define CIPH_ENCR   0x0400\n\n#define MOD_DES     0x0000\n#define MOD_TDEA2   0x0100\n#define MOD_3DES   0x0200\n#define MOD_AES     0x0800\n#define MOD_AES128  (0x0800 | KEYLEN_128)\n#define MOD_AES192  (0x0900 | KEYLEN_192)\n#define MOD_AES256  (0x0a00 | KEYLEN_256)\n\n#define MAX_IVLEN   16\n#define NPE_QLEN    16\n \n#define NPE_QLEN_TOTAL 64\n\n#define CTL_FLAG_UNUSED\t\t0x0000\n#define CTL_FLAG_USED\t\t0x1000\n#define CTL_FLAG_PERFORM_ABLK\t0x0001\n#define CTL_FLAG_GEN_ICV\t0x0002\n#define CTL_FLAG_GEN_REVAES\t0x0004\n#define CTL_FLAG_PERFORM_AEAD\t0x0008\n#define CTL_FLAG_MASK\t\t0x000f\n\n#define HMAC_PAD_BLOCKLEN SHA1_BLOCK_SIZE\n\n#define MD5_DIGEST_SIZE   16\n\nstruct buffer_desc {\n\tu32 phys_next;\n#ifdef __ARMEB__\n\tu16 buf_len;\n\tu16 pkt_len;\n#else\n\tu16 pkt_len;\n\tu16 buf_len;\n#endif\n\tdma_addr_t phys_addr;\n\tu32 __reserved[4];\n\tstruct buffer_desc *next;\n\tenum dma_data_direction dir;\n};\n\nstruct crypt_ctl {\n#ifdef __ARMEB__\n\tu8 mode;\t\t \n\tu8 init_len;\n\tu16 reserved;\n#else\n\tu16 reserved;\n\tu8 init_len;\n\tu8 mode;\t\t \n#endif\n\tu8 iv[MAX_IVLEN];\t \n\tu32 icv_rev_aes;\t \n\tu32 src_buf;\n\tu32 dst_buf;\n#ifdef __ARMEB__\n\tu16 auth_offs;\t\t \n\tu16 auth_len;\t\t \n\tu16 crypt_offs;\t\t \n\tu16 crypt_len;\t\t \n#else\n\tu16 auth_len;\t\t \n\tu16 auth_offs;\t\t \n\tu16 crypt_len;\t\t \n\tu16 crypt_offs;\t\t \n#endif\n\tu32 aadAddr;\t\t \n\tu32 crypto_ctx;\t\t \n\n\t \n\tunsigned int ctl_flags;\n\tunion {\n\t\tstruct skcipher_request *ablk_req;\n\t\tstruct aead_request *aead_req;\n\t\tstruct crypto_tfm *tfm;\n\t} data;\n\tstruct buffer_desc *regist_buf;\n\tu8 *regist_ptr;\n};\n\nstruct ablk_ctx {\n\tstruct buffer_desc *src;\n\tstruct buffer_desc *dst;\n\tu8 iv[MAX_IVLEN];\n\tbool encrypt;\n\tstruct skcipher_request fallback_req;   \n};\n\nstruct aead_ctx {\n\tstruct buffer_desc *src;\n\tstruct buffer_desc *dst;\n\tstruct scatterlist ivlist;\n\t \n\tu8 *hmac_virt;\n\tint encrypt;\n};\n\nstruct ix_hash_algo {\n\tu32 cfgword;\n\tunsigned char *icv;\n};\n\nstruct ix_sa_dir {\n\tunsigned char *npe_ctx;\n\tdma_addr_t npe_ctx_phys;\n\tint npe_ctx_idx;\n\tu8 npe_mode;\n};\n\nstruct ixp_ctx {\n\tstruct ix_sa_dir encrypt;\n\tstruct ix_sa_dir decrypt;\n\tint authkey_len;\n\tu8 authkey[MAX_KEYLEN];\n\tint enckey_len;\n\tu8 enckey[MAX_KEYLEN];\n\tu8 salt[MAX_IVLEN];\n\tu8 nonce[CTR_RFC3686_NONCE_SIZE];\n\tunsigned int salted;\n\tatomic_t configuring;\n\tstruct completion completion;\n\tstruct crypto_skcipher *fallback_tfm;\n};\n\nstruct ixp_alg {\n\tstruct skcipher_alg crypto;\n\tconst struct ix_hash_algo *hash;\n\tu32 cfg_enc;\n\tu32 cfg_dec;\n\n\tint registered;\n};\n\nstruct ixp_aead_alg {\n\tstruct aead_alg crypto;\n\tconst struct ix_hash_algo *hash;\n\tu32 cfg_enc;\n\tu32 cfg_dec;\n\n\tint registered;\n};\n\nstatic const struct ix_hash_algo hash_alg_md5 = {\n\t.cfgword\t= 0xAA010004,\n\t.icv\t\t= \"\\x01\\x23\\x45\\x67\\x89\\xAB\\xCD\\xEF\"\n\t\t\t  \"\\xFE\\xDC\\xBA\\x98\\x76\\x54\\x32\\x10\",\n};\n\nstatic const struct ix_hash_algo hash_alg_sha1 = {\n\t.cfgword\t= 0x00000005,\n\t.icv\t\t= \"\\x67\\x45\\x23\\x01\\xEF\\xCD\\xAB\\x89\\x98\\xBA\"\n\t\t\t  \"\\xDC\\xFE\\x10\\x32\\x54\\x76\\xC3\\xD2\\xE1\\xF0\",\n};\n\nstatic struct npe *npe_c;\n\nstatic unsigned int send_qid;\nstatic unsigned int recv_qid;\nstatic struct dma_pool *buffer_pool;\nstatic struct dma_pool *ctx_pool;\n\nstatic struct crypt_ctl *crypt_virt;\nstatic dma_addr_t crypt_phys;\n\nstatic int support_aes = 1;\n\nstatic struct platform_device *pdev;\n\nstatic inline dma_addr_t crypt_virt2phys(struct crypt_ctl *virt)\n{\n\treturn crypt_phys + (virt - crypt_virt) * sizeof(struct crypt_ctl);\n}\n\nstatic inline struct crypt_ctl *crypt_phys2virt(dma_addr_t phys)\n{\n\treturn crypt_virt + (phys - crypt_phys) / sizeof(struct crypt_ctl);\n}\n\nstatic inline u32 cipher_cfg_enc(struct crypto_tfm *tfm)\n{\n\treturn container_of(tfm->__crt_alg, struct ixp_alg, crypto.base)->cfg_enc;\n}\n\nstatic inline u32 cipher_cfg_dec(struct crypto_tfm *tfm)\n{\n\treturn container_of(tfm->__crt_alg, struct ixp_alg, crypto.base)->cfg_dec;\n}\n\nstatic inline const struct ix_hash_algo *ix_hash(struct crypto_tfm *tfm)\n{\n\treturn container_of(tfm->__crt_alg, struct ixp_alg, crypto.base)->hash;\n}\n\nstatic int setup_crypt_desc(void)\n{\n\tstruct device *dev = &pdev->dev;\n\n\tBUILD_BUG_ON(!(IS_ENABLED(CONFIG_COMPILE_TEST) &&\n\t\t       IS_ENABLED(CONFIG_64BIT)) &&\n\t\t     sizeof(struct crypt_ctl) != 64);\n\tcrypt_virt = dma_alloc_coherent(dev,\n\t\t\t\t\tNPE_QLEN * sizeof(struct crypt_ctl),\n\t\t\t\t\t&crypt_phys, GFP_ATOMIC);\n\tif (!crypt_virt)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nstatic DEFINE_SPINLOCK(desc_lock);\nstatic struct crypt_ctl *get_crypt_desc(void)\n{\n\tint i;\n\tstatic int idx;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&desc_lock, flags);\n\n\tif (unlikely(!crypt_virt))\n\t\tsetup_crypt_desc();\n\tif (unlikely(!crypt_virt)) {\n\t\tspin_unlock_irqrestore(&desc_lock, flags);\n\t\treturn NULL;\n\t}\n\ti = idx;\n\tif (crypt_virt[i].ctl_flags == CTL_FLAG_UNUSED) {\n\t\tif (++idx >= NPE_QLEN)\n\t\t\tidx = 0;\n\t\tcrypt_virt[i].ctl_flags = CTL_FLAG_USED;\n\t\tspin_unlock_irqrestore(&desc_lock, flags);\n\t\treturn crypt_virt + i;\n\t} else {\n\t\tspin_unlock_irqrestore(&desc_lock, flags);\n\t\treturn NULL;\n\t}\n}\n\nstatic DEFINE_SPINLOCK(emerg_lock);\nstatic struct crypt_ctl *get_crypt_desc_emerg(void)\n{\n\tint i;\n\tstatic int idx = NPE_QLEN;\n\tstruct crypt_ctl *desc;\n\tunsigned long flags;\n\n\tdesc = get_crypt_desc();\n\tif (desc)\n\t\treturn desc;\n\tif (unlikely(!crypt_virt))\n\t\treturn NULL;\n\n\tspin_lock_irqsave(&emerg_lock, flags);\n\ti = idx;\n\tif (crypt_virt[i].ctl_flags == CTL_FLAG_UNUSED) {\n\t\tif (++idx >= NPE_QLEN_TOTAL)\n\t\t\tidx = NPE_QLEN;\n\t\tcrypt_virt[i].ctl_flags = CTL_FLAG_USED;\n\t\tspin_unlock_irqrestore(&emerg_lock, flags);\n\t\treturn crypt_virt + i;\n\t} else {\n\t\tspin_unlock_irqrestore(&emerg_lock, flags);\n\t\treturn NULL;\n\t}\n}\n\nstatic void free_buf_chain(struct device *dev, struct buffer_desc *buf,\n\t\t\t   dma_addr_t phys)\n{\n\twhile (buf) {\n\t\tstruct buffer_desc *buf1;\n\t\tu32 phys1;\n\n\t\tbuf1 = buf->next;\n\t\tphys1 = buf->phys_next;\n\t\tdma_unmap_single(dev, buf->phys_addr, buf->buf_len, buf->dir);\n\t\tdma_pool_free(buffer_pool, buf, phys);\n\t\tbuf = buf1;\n\t\tphys = phys1;\n\t}\n}\n\nstatic struct tasklet_struct crypto_done_tasklet;\n\nstatic void finish_scattered_hmac(struct crypt_ctl *crypt)\n{\n\tstruct aead_request *req = crypt->data.aead_req;\n\tstruct aead_ctx *req_ctx = aead_request_ctx(req);\n\tstruct crypto_aead *tfm = crypto_aead_reqtfm(req);\n\tint authsize = crypto_aead_authsize(tfm);\n\tint decryptlen = req->assoclen + req->cryptlen - authsize;\n\n\tif (req_ctx->encrypt) {\n\t\tscatterwalk_map_and_copy(req_ctx->hmac_virt, req->dst,\n\t\t\t\t\t decryptlen, authsize, 1);\n\t}\n\tdma_pool_free(buffer_pool, req_ctx->hmac_virt, crypt->icv_rev_aes);\n}\n\nstatic void one_packet(dma_addr_t phys)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct crypt_ctl *crypt;\n\tstruct ixp_ctx *ctx;\n\tint failed;\n\n\tfailed = phys & 0x1 ? -EBADMSG : 0;\n\tphys &= ~0x3;\n\tcrypt = crypt_phys2virt(phys);\n\n\tswitch (crypt->ctl_flags & CTL_FLAG_MASK) {\n\tcase CTL_FLAG_PERFORM_AEAD: {\n\t\tstruct aead_request *req = crypt->data.aead_req;\n\t\tstruct aead_ctx *req_ctx = aead_request_ctx(req);\n\n\t\tfree_buf_chain(dev, req_ctx->src, crypt->src_buf);\n\t\tfree_buf_chain(dev, req_ctx->dst, crypt->dst_buf);\n\t\tif (req_ctx->hmac_virt)\n\t\t\tfinish_scattered_hmac(crypt);\n\n\t\taead_request_complete(req, failed);\n\t\tbreak;\n\t}\n\tcase CTL_FLAG_PERFORM_ABLK: {\n\t\tstruct skcipher_request *req = crypt->data.ablk_req;\n\t\tstruct ablk_ctx *req_ctx = skcipher_request_ctx(req);\n\t\tstruct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);\n\t\tunsigned int ivsize = crypto_skcipher_ivsize(tfm);\n\t\tunsigned int offset;\n\n\t\tif (ivsize > 0) {\n\t\t\toffset = req->cryptlen - ivsize;\n\t\t\tif (req_ctx->encrypt) {\n\t\t\t\tscatterwalk_map_and_copy(req->iv, req->dst,\n\t\t\t\t\t\t\t offset, ivsize, 0);\n\t\t\t} else {\n\t\t\t\tmemcpy(req->iv, req_ctx->iv, ivsize);\n\t\t\t\tmemzero_explicit(req_ctx->iv, ivsize);\n\t\t\t}\n\t\t}\n\n\t\tif (req_ctx->dst)\n\t\t\tfree_buf_chain(dev, req_ctx->dst, crypt->dst_buf);\n\n\t\tfree_buf_chain(dev, req_ctx->src, crypt->src_buf);\n\t\tskcipher_request_complete(req, failed);\n\t\tbreak;\n\t}\n\tcase CTL_FLAG_GEN_ICV:\n\t\tctx = crypto_tfm_ctx(crypt->data.tfm);\n\t\tdma_pool_free(ctx_pool, crypt->regist_ptr,\n\t\t\t      crypt->regist_buf->phys_addr);\n\t\tdma_pool_free(buffer_pool, crypt->regist_buf, crypt->src_buf);\n\t\tif (atomic_dec_and_test(&ctx->configuring))\n\t\t\tcomplete(&ctx->completion);\n\t\tbreak;\n\tcase CTL_FLAG_GEN_REVAES:\n\t\tctx = crypto_tfm_ctx(crypt->data.tfm);\n\t\t*(__be32 *)ctx->decrypt.npe_ctx &= cpu_to_be32(~CIPH_ENCR);\n\t\tif (atomic_dec_and_test(&ctx->configuring))\n\t\t\tcomplete(&ctx->completion);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\tcrypt->ctl_flags = CTL_FLAG_UNUSED;\n}\n\nstatic void irqhandler(void *_unused)\n{\n\ttasklet_schedule(&crypto_done_tasklet);\n}\n\nstatic void crypto_done_action(unsigned long arg)\n{\n\tint i;\n\n\tfor (i = 0; i < 4; i++) {\n\t\tdma_addr_t phys = qmgr_get_entry(recv_qid);\n\t\tif (!phys)\n\t\t\treturn;\n\t\tone_packet(phys);\n\t}\n\ttasklet_schedule(&crypto_done_tasklet);\n}\n\nstatic int init_ixp_crypto(struct device *dev)\n{\n\tstruct device_node *np = dev->of_node;\n\tu32 msg[2] = { 0, 0 };\n\tint ret = -ENODEV;\n\tu32 npe_id;\n\n\tdev_info(dev, \"probing...\\n\");\n\n\t \n\tif (IS_ENABLED(CONFIG_OF) && np) {\n\t\tstruct of_phandle_args queue_spec;\n\t\tstruct of_phandle_args npe_spec;\n\n\t\tret = of_parse_phandle_with_fixed_args(np, \"intel,npe-handle\",\n\t\t\t\t\t\t       1, 0, &npe_spec);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"no NPE engine specified\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t\tnpe_id = npe_spec.args[0];\n\n\t\tret = of_parse_phandle_with_fixed_args(np, \"queue-rx\", 1, 0,\n\t\t\t\t\t\t       &queue_spec);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"no rx queue phandle\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t\trecv_qid = queue_spec.args[0];\n\n\t\tret = of_parse_phandle_with_fixed_args(np, \"queue-txready\", 1, 0,\n\t\t\t\t\t\t       &queue_spec);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"no txready queue phandle\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t\tsend_qid = queue_spec.args[0];\n\t} else {\n\t\t \n\t\tnpe_id = 2;\n\t\tsend_qid = 29;\n\t\trecv_qid = 30;\n\t}\n\n\tnpe_c = npe_request(npe_id);\n\tif (!npe_c)\n\t\treturn ret;\n\n\tif (!npe_running(npe_c)) {\n\t\tret = npe_load_firmware(npe_c, npe_name(npe_c), dev);\n\t\tif (ret)\n\t\t\tgoto npe_release;\n\t\tif (npe_recv_message(npe_c, msg, \"STATUS_MSG\"))\n\t\t\tgoto npe_error;\n\t} else {\n\t\tif (npe_send_message(npe_c, msg, \"STATUS_MSG\"))\n\t\t\tgoto npe_error;\n\n\t\tif (npe_recv_message(npe_c, msg, \"STATUS_MSG\"))\n\t\t\tgoto npe_error;\n\t}\n\n\tswitch ((msg[1] >> 16) & 0xff) {\n\tcase 3:\n\t\tdev_warn(dev, \"Firmware of %s lacks AES support\\n\", npe_name(npe_c));\n\t\tsupport_aes = 0;\n\t\tbreak;\n\tcase 4:\n\tcase 5:\n\t\tsupport_aes = 1;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"Firmware of %s lacks crypto support\\n\", npe_name(npe_c));\n\t\tret = -ENODEV;\n\t\tgoto npe_release;\n\t}\n\t \n\tBUILD_BUG_ON(SHA1_DIGEST_SIZE > sizeof(struct buffer_desc));\n\tbuffer_pool = dma_pool_create(\"buffer\", dev, sizeof(struct buffer_desc),\n\t\t\t\t      32, 0);\n\tret = -ENOMEM;\n\tif (!buffer_pool)\n\t\tgoto err;\n\n\tctx_pool = dma_pool_create(\"context\", dev, NPE_CTX_LEN, 16, 0);\n\tif (!ctx_pool)\n\t\tgoto err;\n\n\tret = qmgr_request_queue(send_qid, NPE_QLEN_TOTAL, 0, 0,\n\t\t\t\t \"ixp_crypto:out\", NULL);\n\tif (ret)\n\t\tgoto err;\n\tret = qmgr_request_queue(recv_qid, NPE_QLEN, 0, 0,\n\t\t\t\t \"ixp_crypto:in\", NULL);\n\tif (ret) {\n\t\tqmgr_release_queue(send_qid);\n\t\tgoto err;\n\t}\n\tqmgr_set_irq(recv_qid, QUEUE_IRQ_SRC_NOT_EMPTY, irqhandler, NULL);\n\ttasklet_init(&crypto_done_tasklet, crypto_done_action, 0);\n\n\tqmgr_enable_irq(recv_qid);\n\treturn 0;\n\nnpe_error:\n\tdev_err(dev, \"%s not responding\\n\", npe_name(npe_c));\n\tret = -EIO;\nerr:\n\tdma_pool_destroy(ctx_pool);\n\tdma_pool_destroy(buffer_pool);\nnpe_release:\n\tnpe_release(npe_c);\n\treturn ret;\n}\n\nstatic void release_ixp_crypto(struct device *dev)\n{\n\tqmgr_disable_irq(recv_qid);\n\ttasklet_kill(&crypto_done_tasklet);\n\n\tqmgr_release_queue(send_qid);\n\tqmgr_release_queue(recv_qid);\n\n\tdma_pool_destroy(ctx_pool);\n\tdma_pool_destroy(buffer_pool);\n\n\tnpe_release(npe_c);\n\n\tif (crypt_virt)\n\t\tdma_free_coherent(dev, NPE_QLEN * sizeof(struct crypt_ctl),\n\t\t\t\t  crypt_virt, crypt_phys);\n}\n\nstatic void reset_sa_dir(struct ix_sa_dir *dir)\n{\n\tmemset(dir->npe_ctx, 0, NPE_CTX_LEN);\n\tdir->npe_ctx_idx = 0;\n\tdir->npe_mode = 0;\n}\n\nstatic int init_sa_dir(struct ix_sa_dir *dir)\n{\n\tdir->npe_ctx = dma_pool_alloc(ctx_pool, GFP_KERNEL, &dir->npe_ctx_phys);\n\tif (!dir->npe_ctx)\n\t\treturn -ENOMEM;\n\n\treset_sa_dir(dir);\n\treturn 0;\n}\n\nstatic void free_sa_dir(struct ix_sa_dir *dir)\n{\n\tmemset(dir->npe_ctx, 0, NPE_CTX_LEN);\n\tdma_pool_free(ctx_pool, dir->npe_ctx, dir->npe_ctx_phys);\n}\n\nstatic int init_tfm(struct crypto_tfm *tfm)\n{\n\tstruct ixp_ctx *ctx = crypto_tfm_ctx(tfm);\n\tint ret;\n\n\tatomic_set(&ctx->configuring, 0);\n\tret = init_sa_dir(&ctx->encrypt);\n\tif (ret)\n\t\treturn ret;\n\tret = init_sa_dir(&ctx->decrypt);\n\tif (ret)\n\t\tfree_sa_dir(&ctx->encrypt);\n\n\treturn ret;\n}\n\nstatic int init_tfm_ablk(struct crypto_skcipher *tfm)\n{\n\tstruct crypto_tfm *ctfm = crypto_skcipher_tfm(tfm);\n\tstruct ixp_ctx *ctx = crypto_tfm_ctx(ctfm);\n\tconst char *name = crypto_tfm_alg_name(ctfm);\n\n\tctx->fallback_tfm = crypto_alloc_skcipher(name, 0, CRYPTO_ALG_NEED_FALLBACK);\n\tif (IS_ERR(ctx->fallback_tfm)) {\n\t\tpr_err(\"ERROR: Cannot allocate fallback for %s %ld\\n\",\n\t\t\tname, PTR_ERR(ctx->fallback_tfm));\n\t\treturn PTR_ERR(ctx->fallback_tfm);\n\t}\n\n\tpr_info(\"Fallback for %s is %s\\n\",\n\t\t crypto_tfm_alg_driver_name(&tfm->base),\n\t\t crypto_tfm_alg_driver_name(crypto_skcipher_tfm(ctx->fallback_tfm))\n\t\t );\n\n\tcrypto_skcipher_set_reqsize(tfm, sizeof(struct ablk_ctx) + crypto_skcipher_reqsize(ctx->fallback_tfm));\n\treturn init_tfm(crypto_skcipher_tfm(tfm));\n}\n\nstatic int init_tfm_aead(struct crypto_aead *tfm)\n{\n\tcrypto_aead_set_reqsize(tfm, sizeof(struct aead_ctx));\n\treturn init_tfm(crypto_aead_tfm(tfm));\n}\n\nstatic void exit_tfm(struct crypto_tfm *tfm)\n{\n\tstruct ixp_ctx *ctx = crypto_tfm_ctx(tfm);\n\n\tfree_sa_dir(&ctx->encrypt);\n\tfree_sa_dir(&ctx->decrypt);\n}\n\nstatic void exit_tfm_ablk(struct crypto_skcipher *tfm)\n{\n\tstruct crypto_tfm *ctfm = crypto_skcipher_tfm(tfm);\n\tstruct ixp_ctx *ctx = crypto_tfm_ctx(ctfm);\n\n\tcrypto_free_skcipher(ctx->fallback_tfm);\n\texit_tfm(crypto_skcipher_tfm(tfm));\n}\n\nstatic void exit_tfm_aead(struct crypto_aead *tfm)\n{\n\texit_tfm(crypto_aead_tfm(tfm));\n}\n\nstatic int register_chain_var(struct crypto_tfm *tfm, u8 xpad, u32 target,\n\t\t\t      int init_len, u32 ctx_addr, const u8 *key,\n\t\t\t      int key_len)\n{\n\tstruct ixp_ctx *ctx = crypto_tfm_ctx(tfm);\n\tstruct crypt_ctl *crypt;\n\tstruct buffer_desc *buf;\n\tint i;\n\tu8 *pad;\n\tdma_addr_t pad_phys, buf_phys;\n\n\tBUILD_BUG_ON(NPE_CTX_LEN < HMAC_PAD_BLOCKLEN);\n\tpad = dma_pool_alloc(ctx_pool, GFP_KERNEL, &pad_phys);\n\tif (!pad)\n\t\treturn -ENOMEM;\n\tbuf = dma_pool_alloc(buffer_pool, GFP_KERNEL, &buf_phys);\n\tif (!buf) {\n\t\tdma_pool_free(ctx_pool, pad, pad_phys);\n\t\treturn -ENOMEM;\n\t}\n\tcrypt = get_crypt_desc_emerg();\n\tif (!crypt) {\n\t\tdma_pool_free(ctx_pool, pad, pad_phys);\n\t\tdma_pool_free(buffer_pool, buf, buf_phys);\n\t\treturn -EAGAIN;\n\t}\n\n\tmemcpy(pad, key, key_len);\n\tmemset(pad + key_len, 0, HMAC_PAD_BLOCKLEN - key_len);\n\tfor (i = 0; i < HMAC_PAD_BLOCKLEN; i++)\n\t\tpad[i] ^= xpad;\n\n\tcrypt->data.tfm = tfm;\n\tcrypt->regist_ptr = pad;\n\tcrypt->regist_buf = buf;\n\n\tcrypt->auth_offs = 0;\n\tcrypt->auth_len = HMAC_PAD_BLOCKLEN;\n\tcrypt->crypto_ctx = ctx_addr;\n\tcrypt->src_buf = buf_phys;\n\tcrypt->icv_rev_aes = target;\n\tcrypt->mode = NPE_OP_HASH_GEN_ICV;\n\tcrypt->init_len = init_len;\n\tcrypt->ctl_flags |= CTL_FLAG_GEN_ICV;\n\n\tbuf->next = NULL;\n\tbuf->buf_len = HMAC_PAD_BLOCKLEN;\n\tbuf->pkt_len = 0;\n\tbuf->phys_addr = pad_phys;\n\n\tatomic_inc(&ctx->configuring);\n\tqmgr_put_entry(send_qid, crypt_virt2phys(crypt));\n\tBUG_ON(qmgr_stat_overflow(send_qid));\n\treturn 0;\n}\n\nstatic int setup_auth(struct crypto_tfm *tfm, int encrypt, unsigned int authsize,\n\t\t      const u8 *key, int key_len, unsigned int digest_len)\n{\n\tu32 itarget, otarget, npe_ctx_addr;\n\tunsigned char *cinfo;\n\tint init_len, ret = 0;\n\tu32 cfgword;\n\tstruct ix_sa_dir *dir;\n\tstruct ixp_ctx *ctx = crypto_tfm_ctx(tfm);\n\tconst struct ix_hash_algo *algo;\n\n\tdir = encrypt ? &ctx->encrypt : &ctx->decrypt;\n\tcinfo = dir->npe_ctx + dir->npe_ctx_idx;\n\talgo = ix_hash(tfm);\n\n\t \n\tcfgword = algo->cfgword | (authsize << 6);  \n#ifndef __ARMEB__\n\tcfgword ^= 0xAA000000;  \n#endif\n\t*(__be32 *)cinfo = cpu_to_be32(cfgword);\n\tcinfo += sizeof(cfgword);\n\n\t \n\tmemcpy(cinfo, algo->icv, digest_len);\n\tcinfo += digest_len;\n\n\titarget = dir->npe_ctx_phys + dir->npe_ctx_idx\n\t\t\t\t+ sizeof(algo->cfgword);\n\totarget = itarget + digest_len;\n\tinit_len = cinfo - (dir->npe_ctx + dir->npe_ctx_idx);\n\tnpe_ctx_addr = dir->npe_ctx_phys + dir->npe_ctx_idx;\n\n\tdir->npe_ctx_idx += init_len;\n\tdir->npe_mode |= NPE_OP_HASH_ENABLE;\n\n\tif (!encrypt)\n\t\tdir->npe_mode |= NPE_OP_HASH_VERIFY;\n\n\tret = register_chain_var(tfm, HMAC_OPAD_VALUE, otarget,\n\t\t\t\t init_len, npe_ctx_addr, key, key_len);\n\tif (ret)\n\t\treturn ret;\n\treturn register_chain_var(tfm, HMAC_IPAD_VALUE, itarget,\n\t\t\t\t  init_len, npe_ctx_addr, key, key_len);\n}\n\nstatic int gen_rev_aes_key(struct crypto_tfm *tfm)\n{\n\tstruct crypt_ctl *crypt;\n\tstruct ixp_ctx *ctx = crypto_tfm_ctx(tfm);\n\tstruct ix_sa_dir *dir = &ctx->decrypt;\n\n\tcrypt = get_crypt_desc_emerg();\n\tif (!crypt)\n\t\treturn -EAGAIN;\n\n\t*(__be32 *)dir->npe_ctx |= cpu_to_be32(CIPH_ENCR);\n\n\tcrypt->data.tfm = tfm;\n\tcrypt->crypt_offs = 0;\n\tcrypt->crypt_len = AES_BLOCK128;\n\tcrypt->src_buf = 0;\n\tcrypt->crypto_ctx = dir->npe_ctx_phys;\n\tcrypt->icv_rev_aes = dir->npe_ctx_phys + sizeof(u32);\n\tcrypt->mode = NPE_OP_ENC_GEN_KEY;\n\tcrypt->init_len = dir->npe_ctx_idx;\n\tcrypt->ctl_flags |= CTL_FLAG_GEN_REVAES;\n\n\tatomic_inc(&ctx->configuring);\n\tqmgr_put_entry(send_qid, crypt_virt2phys(crypt));\n\tBUG_ON(qmgr_stat_overflow(send_qid));\n\treturn 0;\n}\n\nstatic int setup_cipher(struct crypto_tfm *tfm, int encrypt, const u8 *key,\n\t\t\tint key_len)\n{\n\tu8 *cinfo;\n\tu32 cipher_cfg;\n\tu32 keylen_cfg = 0;\n\tstruct ix_sa_dir *dir;\n\tstruct ixp_ctx *ctx = crypto_tfm_ctx(tfm);\n\tint err;\n\n\tdir = encrypt ? &ctx->encrypt : &ctx->decrypt;\n\tcinfo = dir->npe_ctx;\n\n\tif (encrypt) {\n\t\tcipher_cfg = cipher_cfg_enc(tfm);\n\t\tdir->npe_mode |= NPE_OP_CRYPT_ENCRYPT;\n\t} else {\n\t\tcipher_cfg = cipher_cfg_dec(tfm);\n\t}\n\tif (cipher_cfg & MOD_AES) {\n\t\tswitch (key_len) {\n\t\tcase 16:\n\t\t\tkeylen_cfg = MOD_AES128;\n\t\t\tbreak;\n\t\tcase 24:\n\t\t\tkeylen_cfg = MOD_AES192;\n\t\t\tbreak;\n\t\tcase 32:\n\t\t\tkeylen_cfg = MOD_AES256;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tcipher_cfg |= keylen_cfg;\n\t} else {\n\t\terr = crypto_des_verify_key(tfm, key);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\t \n\t*(__be32 *)cinfo = cpu_to_be32(cipher_cfg);\n\tcinfo += sizeof(cipher_cfg);\n\n\t \n\tmemcpy(cinfo, key, key_len);\n\t \n\tif (key_len < DES3_EDE_KEY_SIZE && !(cipher_cfg & MOD_AES)) {\n\t\tmemset(cinfo + key_len, 0, DES3_EDE_KEY_SIZE - key_len);\n\t\tkey_len = DES3_EDE_KEY_SIZE;\n\t}\n\tdir->npe_ctx_idx = sizeof(cipher_cfg) + key_len;\n\tdir->npe_mode |= NPE_OP_CRYPT_ENABLE;\n\tif ((cipher_cfg & MOD_AES) && !encrypt)\n\t\treturn gen_rev_aes_key(tfm);\n\n\treturn 0;\n}\n\nstatic struct buffer_desc *chainup_buffers(struct device *dev,\n\t\tstruct scatterlist *sg,\tunsigned int nbytes,\n\t\tstruct buffer_desc *buf, gfp_t flags,\n\t\tenum dma_data_direction dir)\n{\n\tfor (; nbytes > 0; sg = sg_next(sg)) {\n\t\tunsigned int len = min(nbytes, sg->length);\n\t\tstruct buffer_desc *next_buf;\n\t\tdma_addr_t next_buf_phys;\n\t\tvoid *ptr;\n\n\t\tnbytes -= len;\n\t\tptr = sg_virt(sg);\n\t\tnext_buf = dma_pool_alloc(buffer_pool, flags, &next_buf_phys);\n\t\tif (!next_buf) {\n\t\t\tbuf = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tsg_dma_address(sg) = dma_map_single(dev, ptr, len, dir);\n\t\tbuf->next = next_buf;\n\t\tbuf->phys_next = next_buf_phys;\n\t\tbuf = next_buf;\n\n\t\tbuf->phys_addr = sg_dma_address(sg);\n\t\tbuf->buf_len = len;\n\t\tbuf->dir = dir;\n\t}\n\tbuf->next = NULL;\n\tbuf->phys_next = 0;\n\treturn buf;\n}\n\nstatic int ablk_setkey(struct crypto_skcipher *tfm, const u8 *key,\n\t\t       unsigned int key_len)\n{\n\tstruct ixp_ctx *ctx = crypto_skcipher_ctx(tfm);\n\tint ret;\n\n\tinit_completion(&ctx->completion);\n\tatomic_inc(&ctx->configuring);\n\n\treset_sa_dir(&ctx->encrypt);\n\treset_sa_dir(&ctx->decrypt);\n\n\tctx->encrypt.npe_mode = NPE_OP_HMAC_DISABLE;\n\tctx->decrypt.npe_mode = NPE_OP_HMAC_DISABLE;\n\n\tret = setup_cipher(&tfm->base, 0, key, key_len);\n\tif (ret)\n\t\tgoto out;\n\tret = setup_cipher(&tfm->base, 1, key, key_len);\nout:\n\tif (!atomic_dec_and_test(&ctx->configuring))\n\t\twait_for_completion(&ctx->completion);\n\tif (ret)\n\t\treturn ret;\n\tcrypto_skcipher_clear_flags(ctx->fallback_tfm, CRYPTO_TFM_REQ_MASK);\n\tcrypto_skcipher_set_flags(ctx->fallback_tfm, tfm->base.crt_flags & CRYPTO_TFM_REQ_MASK);\n\n\treturn crypto_skcipher_setkey(ctx->fallback_tfm, key, key_len);\n}\n\nstatic int ablk_des3_setkey(struct crypto_skcipher *tfm, const u8 *key,\n\t\t\t    unsigned int key_len)\n{\n\treturn verify_skcipher_des3_key(tfm, key) ?:\n\t       ablk_setkey(tfm, key, key_len);\n}\n\nstatic int ablk_rfc3686_setkey(struct crypto_skcipher *tfm, const u8 *key,\n\t\t\t       unsigned int key_len)\n{\n\tstruct ixp_ctx *ctx = crypto_skcipher_ctx(tfm);\n\n\t \n\tif (key_len < CTR_RFC3686_NONCE_SIZE)\n\t\treturn -EINVAL;\n\n\tmemcpy(ctx->nonce, key + (key_len - CTR_RFC3686_NONCE_SIZE),\n\t       CTR_RFC3686_NONCE_SIZE);\n\n\tkey_len -= CTR_RFC3686_NONCE_SIZE;\n\treturn ablk_setkey(tfm, key, key_len);\n}\n\nstatic int ixp4xx_cipher_fallback(struct skcipher_request *areq, int encrypt)\n{\n\tstruct crypto_skcipher *tfm = crypto_skcipher_reqtfm(areq);\n\tstruct ixp_ctx *op = crypto_skcipher_ctx(tfm);\n\tstruct ablk_ctx *rctx = skcipher_request_ctx(areq);\n\tint err;\n\n\tskcipher_request_set_tfm(&rctx->fallback_req, op->fallback_tfm);\n\tskcipher_request_set_callback(&rctx->fallback_req, areq->base.flags,\n\t\t\t\t      areq->base.complete, areq->base.data);\n\tskcipher_request_set_crypt(&rctx->fallback_req, areq->src, areq->dst,\n\t\t\t\t   areq->cryptlen, areq->iv);\n\tif (encrypt)\n\t\terr = crypto_skcipher_encrypt(&rctx->fallback_req);\n\telse\n\t\terr = crypto_skcipher_decrypt(&rctx->fallback_req);\n\treturn err;\n}\n\nstatic int ablk_perform(struct skcipher_request *req, int encrypt)\n{\n\tstruct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);\n\tstruct ixp_ctx *ctx = crypto_skcipher_ctx(tfm);\n\tunsigned int ivsize = crypto_skcipher_ivsize(tfm);\n\tstruct ix_sa_dir *dir;\n\tstruct crypt_ctl *crypt;\n\tunsigned int nbytes = req->cryptlen;\n\tenum dma_data_direction src_direction = DMA_BIDIRECTIONAL;\n\tstruct ablk_ctx *req_ctx = skcipher_request_ctx(req);\n\tstruct buffer_desc src_hook;\n\tstruct device *dev = &pdev->dev;\n\tunsigned int offset;\n\tgfp_t flags = req->base.flags & CRYPTO_TFM_REQ_MAY_SLEEP ?\n\t\t\t\tGFP_KERNEL : GFP_ATOMIC;\n\n\tif (sg_nents(req->src) > 1 || sg_nents(req->dst) > 1)\n\t\treturn ixp4xx_cipher_fallback(req, encrypt);\n\n\tif (qmgr_stat_full(send_qid))\n\t\treturn -EAGAIN;\n\tif (atomic_read(&ctx->configuring))\n\t\treturn -EAGAIN;\n\n\tdir = encrypt ? &ctx->encrypt : &ctx->decrypt;\n\treq_ctx->encrypt = encrypt;\n\n\tcrypt = get_crypt_desc();\n\tif (!crypt)\n\t\treturn -ENOMEM;\n\n\tcrypt->data.ablk_req = req;\n\tcrypt->crypto_ctx = dir->npe_ctx_phys;\n\tcrypt->mode = dir->npe_mode;\n\tcrypt->init_len = dir->npe_ctx_idx;\n\n\tcrypt->crypt_offs = 0;\n\tcrypt->crypt_len = nbytes;\n\n\tBUG_ON(ivsize && !req->iv);\n\tmemcpy(crypt->iv, req->iv, ivsize);\n\tif (ivsize > 0 && !encrypt) {\n\t\toffset = req->cryptlen - ivsize;\n\t\tscatterwalk_map_and_copy(req_ctx->iv, req->src, offset, ivsize, 0);\n\t}\n\tif (req->src != req->dst) {\n\t\tstruct buffer_desc dst_hook;\n\n\t\tcrypt->mode |= NPE_OP_NOT_IN_PLACE;\n\t\t \n\t\treq_ctx->dst = NULL;\n\t\tif (!chainup_buffers(dev, req->dst, nbytes, &dst_hook,\n\t\t\t\t     flags, DMA_FROM_DEVICE))\n\t\t\tgoto free_buf_dest;\n\t\tsrc_direction = DMA_TO_DEVICE;\n\t\treq_ctx->dst = dst_hook.next;\n\t\tcrypt->dst_buf = dst_hook.phys_next;\n\t} else {\n\t\treq_ctx->dst = NULL;\n\t}\n\treq_ctx->src = NULL;\n\tif (!chainup_buffers(dev, req->src, nbytes, &src_hook, flags,\n\t\t\t     src_direction))\n\t\tgoto free_buf_src;\n\n\treq_ctx->src = src_hook.next;\n\tcrypt->src_buf = src_hook.phys_next;\n\tcrypt->ctl_flags |= CTL_FLAG_PERFORM_ABLK;\n\tqmgr_put_entry(send_qid, crypt_virt2phys(crypt));\n\tBUG_ON(qmgr_stat_overflow(send_qid));\n\treturn -EINPROGRESS;\n\nfree_buf_src:\n\tfree_buf_chain(dev, req_ctx->src, crypt->src_buf);\nfree_buf_dest:\n\tif (req->src != req->dst)\n\t\tfree_buf_chain(dev, req_ctx->dst, crypt->dst_buf);\n\n\tcrypt->ctl_flags = CTL_FLAG_UNUSED;\n\treturn -ENOMEM;\n}\n\nstatic int ablk_encrypt(struct skcipher_request *req)\n{\n\treturn ablk_perform(req, 1);\n}\n\nstatic int ablk_decrypt(struct skcipher_request *req)\n{\n\treturn ablk_perform(req, 0);\n}\n\nstatic int ablk_rfc3686_crypt(struct skcipher_request *req)\n{\n\tstruct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);\n\tstruct ixp_ctx *ctx = crypto_skcipher_ctx(tfm);\n\tu8 iv[CTR_RFC3686_BLOCK_SIZE];\n\tu8 *info = req->iv;\n\tint ret;\n\n\t \n\tmemcpy(iv, ctx->nonce, CTR_RFC3686_NONCE_SIZE);\n\tmemcpy(iv + CTR_RFC3686_NONCE_SIZE, info, CTR_RFC3686_IV_SIZE);\n\n\t \n\t*(__be32 *)(iv + CTR_RFC3686_NONCE_SIZE + CTR_RFC3686_IV_SIZE) =\n\t\tcpu_to_be32(1);\n\n\treq->iv = iv;\n\tret = ablk_perform(req, 1);\n\treq->iv = info;\n\treturn ret;\n}\n\nstatic int aead_perform(struct aead_request *req, int encrypt,\n\t\t\tint cryptoffset, int eff_cryptlen, u8 *iv)\n{\n\tstruct crypto_aead *tfm = crypto_aead_reqtfm(req);\n\tstruct ixp_ctx *ctx = crypto_aead_ctx(tfm);\n\tunsigned int ivsize = crypto_aead_ivsize(tfm);\n\tunsigned int authsize = crypto_aead_authsize(tfm);\n\tstruct ix_sa_dir *dir;\n\tstruct crypt_ctl *crypt;\n\tunsigned int cryptlen;\n\tstruct buffer_desc *buf, src_hook;\n\tstruct aead_ctx *req_ctx = aead_request_ctx(req);\n\tstruct device *dev = &pdev->dev;\n\tgfp_t flags = req->base.flags & CRYPTO_TFM_REQ_MAY_SLEEP ?\n\t\t\t\tGFP_KERNEL : GFP_ATOMIC;\n\tenum dma_data_direction src_direction = DMA_BIDIRECTIONAL;\n\tunsigned int lastlen;\n\n\tif (qmgr_stat_full(send_qid))\n\t\treturn -EAGAIN;\n\tif (atomic_read(&ctx->configuring))\n\t\treturn -EAGAIN;\n\n\tif (encrypt) {\n\t\tdir = &ctx->encrypt;\n\t\tcryptlen = req->cryptlen;\n\t} else {\n\t\tdir = &ctx->decrypt;\n\t\t \n\t\tcryptlen = req->cryptlen - authsize;\n\t\teff_cryptlen -= authsize;\n\t}\n\tcrypt = get_crypt_desc();\n\tif (!crypt)\n\t\treturn -ENOMEM;\n\n\tcrypt->data.aead_req = req;\n\tcrypt->crypto_ctx = dir->npe_ctx_phys;\n\tcrypt->mode = dir->npe_mode;\n\tcrypt->init_len = dir->npe_ctx_idx;\n\n\tcrypt->crypt_offs = cryptoffset;\n\tcrypt->crypt_len = eff_cryptlen;\n\n\tcrypt->auth_offs = 0;\n\tcrypt->auth_len = req->assoclen + cryptlen;\n\tBUG_ON(ivsize && !req->iv);\n\tmemcpy(crypt->iv, req->iv, ivsize);\n\n\tbuf = chainup_buffers(dev, req->src, crypt->auth_len,\n\t\t\t      &src_hook, flags, src_direction);\n\treq_ctx->src = src_hook.next;\n\tcrypt->src_buf = src_hook.phys_next;\n\tif (!buf)\n\t\tgoto free_buf_src;\n\n\tlastlen = buf->buf_len;\n\tif (lastlen >= authsize)\n\t\tcrypt->icv_rev_aes = buf->phys_addr +\n\t\t\t\t     buf->buf_len - authsize;\n\n\treq_ctx->dst = NULL;\n\n\tif (req->src != req->dst) {\n\t\tstruct buffer_desc dst_hook;\n\n\t\tcrypt->mode |= NPE_OP_NOT_IN_PLACE;\n\t\tsrc_direction = DMA_TO_DEVICE;\n\n\t\tbuf = chainup_buffers(dev, req->dst, crypt->auth_len,\n\t\t\t\t      &dst_hook, flags, DMA_FROM_DEVICE);\n\t\treq_ctx->dst = dst_hook.next;\n\t\tcrypt->dst_buf = dst_hook.phys_next;\n\n\t\tif (!buf)\n\t\t\tgoto free_buf_dst;\n\n\t\tif (encrypt) {\n\t\t\tlastlen = buf->buf_len;\n\t\t\tif (lastlen >= authsize)\n\t\t\t\tcrypt->icv_rev_aes = buf->phys_addr +\n\t\t\t\t\t\t     buf->buf_len - authsize;\n\t\t}\n\t}\n\n\tif (unlikely(lastlen < authsize)) {\n\t\tdma_addr_t dma;\n\t\t \n\t\treq_ctx->hmac_virt = dma_pool_alloc(buffer_pool, flags, &dma);\n\t\tif (unlikely(!req_ctx->hmac_virt))\n\t\t\tgoto free_buf_dst;\n\t\tcrypt->icv_rev_aes = dma;\n\t\tif (!encrypt) {\n\t\t\tscatterwalk_map_and_copy(req_ctx->hmac_virt,\n\t\t\t\t\t\t req->src, cryptlen, authsize, 0);\n\t\t}\n\t\treq_ctx->encrypt = encrypt;\n\t} else {\n\t\treq_ctx->hmac_virt = NULL;\n\t}\n\n\tcrypt->ctl_flags |= CTL_FLAG_PERFORM_AEAD;\n\tqmgr_put_entry(send_qid, crypt_virt2phys(crypt));\n\tBUG_ON(qmgr_stat_overflow(send_qid));\n\treturn -EINPROGRESS;\n\nfree_buf_dst:\n\tfree_buf_chain(dev, req_ctx->dst, crypt->dst_buf);\nfree_buf_src:\n\tfree_buf_chain(dev, req_ctx->src, crypt->src_buf);\n\tcrypt->ctl_flags = CTL_FLAG_UNUSED;\n\treturn -ENOMEM;\n}\n\nstatic int aead_setup(struct crypto_aead *tfm, unsigned int authsize)\n{\n\tstruct ixp_ctx *ctx = crypto_aead_ctx(tfm);\n\tunsigned int digest_len = crypto_aead_maxauthsize(tfm);\n\tint ret;\n\n\tif (!ctx->enckey_len && !ctx->authkey_len)\n\t\treturn 0;\n\tinit_completion(&ctx->completion);\n\tatomic_inc(&ctx->configuring);\n\n\treset_sa_dir(&ctx->encrypt);\n\treset_sa_dir(&ctx->decrypt);\n\n\tret = setup_cipher(&tfm->base, 0, ctx->enckey, ctx->enckey_len);\n\tif (ret)\n\t\tgoto out;\n\tret = setup_cipher(&tfm->base, 1, ctx->enckey, ctx->enckey_len);\n\tif (ret)\n\t\tgoto out;\n\tret = setup_auth(&tfm->base, 0, authsize, ctx->authkey,\n\t\t\t ctx->authkey_len, digest_len);\n\tif (ret)\n\t\tgoto out;\n\tret = setup_auth(&tfm->base, 1, authsize,  ctx->authkey,\n\t\t\t ctx->authkey_len, digest_len);\nout:\n\tif (!atomic_dec_and_test(&ctx->configuring))\n\t\twait_for_completion(&ctx->completion);\n\treturn ret;\n}\n\nstatic int aead_setauthsize(struct crypto_aead *tfm, unsigned int authsize)\n{\n\tint max = crypto_aead_maxauthsize(tfm) >> 2;\n\n\tif ((authsize >> 2) < 1 || (authsize >> 2) > max || (authsize & 3))\n\t\treturn -EINVAL;\n\treturn aead_setup(tfm, authsize);\n}\n\nstatic int aead_setkey(struct crypto_aead *tfm, const u8 *key,\n\t\t       unsigned int keylen)\n{\n\tstruct ixp_ctx *ctx = crypto_aead_ctx(tfm);\n\tstruct crypto_authenc_keys keys;\n\n\tif (crypto_authenc_extractkeys(&keys, key, keylen) != 0)\n\t\tgoto badkey;\n\n\tif (keys.authkeylen > sizeof(ctx->authkey))\n\t\tgoto badkey;\n\n\tif (keys.enckeylen > sizeof(ctx->enckey))\n\t\tgoto badkey;\n\n\tmemcpy(ctx->authkey, keys.authkey, keys.authkeylen);\n\tmemcpy(ctx->enckey, keys.enckey, keys.enckeylen);\n\tctx->authkey_len = keys.authkeylen;\n\tctx->enckey_len = keys.enckeylen;\n\n\tmemzero_explicit(&keys, sizeof(keys));\n\treturn aead_setup(tfm, crypto_aead_authsize(tfm));\nbadkey:\n\tmemzero_explicit(&keys, sizeof(keys));\n\treturn -EINVAL;\n}\n\nstatic int des3_aead_setkey(struct crypto_aead *tfm, const u8 *key,\n\t\t\t    unsigned int keylen)\n{\n\tstruct ixp_ctx *ctx = crypto_aead_ctx(tfm);\n\tstruct crypto_authenc_keys keys;\n\tint err;\n\n\terr = crypto_authenc_extractkeys(&keys, key, keylen);\n\tif (unlikely(err))\n\t\tgoto badkey;\n\n\terr = -EINVAL;\n\tif (keys.authkeylen > sizeof(ctx->authkey))\n\t\tgoto badkey;\n\n\terr = verify_aead_des3_key(tfm, keys.enckey, keys.enckeylen);\n\tif (err)\n\t\tgoto badkey;\n\n\tmemcpy(ctx->authkey, keys.authkey, keys.authkeylen);\n\tmemcpy(ctx->enckey, keys.enckey, keys.enckeylen);\n\tctx->authkey_len = keys.authkeylen;\n\tctx->enckey_len = keys.enckeylen;\n\n\tmemzero_explicit(&keys, sizeof(keys));\n\treturn aead_setup(tfm, crypto_aead_authsize(tfm));\nbadkey:\n\tmemzero_explicit(&keys, sizeof(keys));\n\treturn err;\n}\n\nstatic int aead_encrypt(struct aead_request *req)\n{\n\treturn aead_perform(req, 1, req->assoclen, req->cryptlen, req->iv);\n}\n\nstatic int aead_decrypt(struct aead_request *req)\n{\n\treturn aead_perform(req, 0, req->assoclen, req->cryptlen, req->iv);\n}\n\nstatic struct ixp_alg ixp4xx_algos[] = {\n{\n\t.crypto\t= {\n\t\t.base.cra_name\t\t= \"cbc(des)\",\n\t\t.base.cra_blocksize\t= DES_BLOCK_SIZE,\n\n\t\t.min_keysize\t\t= DES_KEY_SIZE,\n\t\t.max_keysize\t\t= DES_KEY_SIZE,\n\t\t.ivsize\t\t\t= DES_BLOCK_SIZE,\n\t},\n\t.cfg_enc = CIPH_ENCR | MOD_DES | MOD_CBC_ENC | KEYLEN_192,\n\t.cfg_dec = CIPH_DECR | MOD_DES | MOD_CBC_DEC | KEYLEN_192,\n\n}, {\n\t.crypto\t= {\n\t\t.base.cra_name\t\t= \"ecb(des)\",\n\t\t.base.cra_blocksize\t= DES_BLOCK_SIZE,\n\t\t.min_keysize\t\t= DES_KEY_SIZE,\n\t\t.max_keysize\t\t= DES_KEY_SIZE,\n\t},\n\t.cfg_enc = CIPH_ENCR | MOD_DES | MOD_ECB | KEYLEN_192,\n\t.cfg_dec = CIPH_DECR | MOD_DES | MOD_ECB | KEYLEN_192,\n}, {\n\t.crypto\t= {\n\t\t.base.cra_name\t\t= \"cbc(des3_ede)\",\n\t\t.base.cra_blocksize\t= DES3_EDE_BLOCK_SIZE,\n\n\t\t.min_keysize\t\t= DES3_EDE_KEY_SIZE,\n\t\t.max_keysize\t\t= DES3_EDE_KEY_SIZE,\n\t\t.ivsize\t\t\t= DES3_EDE_BLOCK_SIZE,\n\t\t.setkey\t\t\t= ablk_des3_setkey,\n\t},\n\t.cfg_enc = CIPH_ENCR | MOD_3DES | MOD_CBC_ENC | KEYLEN_192,\n\t.cfg_dec = CIPH_DECR | MOD_3DES | MOD_CBC_DEC | KEYLEN_192,\n}, {\n\t.crypto\t= {\n\t\t.base.cra_name\t\t= \"ecb(des3_ede)\",\n\t\t.base.cra_blocksize\t= DES3_EDE_BLOCK_SIZE,\n\n\t\t.min_keysize\t\t= DES3_EDE_KEY_SIZE,\n\t\t.max_keysize\t\t= DES3_EDE_KEY_SIZE,\n\t\t.setkey\t\t\t= ablk_des3_setkey,\n\t},\n\t.cfg_enc = CIPH_ENCR | MOD_3DES | MOD_ECB | KEYLEN_192,\n\t.cfg_dec = CIPH_DECR | MOD_3DES | MOD_ECB | KEYLEN_192,\n}, {\n\t.crypto\t= {\n\t\t.base.cra_name\t\t= \"cbc(aes)\",\n\t\t.base.cra_blocksize\t= AES_BLOCK_SIZE,\n\n\t\t.min_keysize\t\t= AES_MIN_KEY_SIZE,\n\t\t.max_keysize\t\t= AES_MAX_KEY_SIZE,\n\t\t.ivsize\t\t\t= AES_BLOCK_SIZE,\n\t},\n\t.cfg_enc = CIPH_ENCR | MOD_AES | MOD_CBC_ENC,\n\t.cfg_dec = CIPH_DECR | MOD_AES | MOD_CBC_DEC,\n}, {\n\t.crypto\t= {\n\t\t.base.cra_name\t\t= \"ecb(aes)\",\n\t\t.base.cra_blocksize\t= AES_BLOCK_SIZE,\n\n\t\t.min_keysize\t\t= AES_MIN_KEY_SIZE,\n\t\t.max_keysize\t\t= AES_MAX_KEY_SIZE,\n\t},\n\t.cfg_enc = CIPH_ENCR | MOD_AES | MOD_ECB,\n\t.cfg_dec = CIPH_DECR | MOD_AES | MOD_ECB,\n}, {\n\t.crypto\t= {\n\t\t.base.cra_name\t\t= \"ctr(aes)\",\n\t\t.base.cra_blocksize\t= 1,\n\n\t\t.min_keysize\t\t= AES_MIN_KEY_SIZE,\n\t\t.max_keysize\t\t= AES_MAX_KEY_SIZE,\n\t\t.ivsize\t\t\t= AES_BLOCK_SIZE,\n\t},\n\t.cfg_enc = CIPH_ENCR | MOD_AES | MOD_CTR,\n\t.cfg_dec = CIPH_ENCR | MOD_AES | MOD_CTR,\n}, {\n\t.crypto\t= {\n\t\t.base.cra_name\t\t= \"rfc3686(ctr(aes))\",\n\t\t.base.cra_blocksize\t= 1,\n\n\t\t.min_keysize\t\t= AES_MIN_KEY_SIZE,\n\t\t.max_keysize\t\t= AES_MAX_KEY_SIZE,\n\t\t.ivsize\t\t\t= AES_BLOCK_SIZE,\n\t\t.setkey\t\t\t= ablk_rfc3686_setkey,\n\t\t.encrypt\t\t= ablk_rfc3686_crypt,\n\t\t.decrypt\t\t= ablk_rfc3686_crypt,\n\t},\n\t.cfg_enc = CIPH_ENCR | MOD_AES | MOD_CTR,\n\t.cfg_dec = CIPH_ENCR | MOD_AES | MOD_CTR,\n} };\n\nstatic struct ixp_aead_alg ixp4xx_aeads[] = {\n{\n\t.crypto\t= {\n\t\t.base = {\n\t\t\t.cra_name\t= \"authenc(hmac(md5),cbc(des))\",\n\t\t\t.cra_blocksize\t= DES_BLOCK_SIZE,\n\t\t},\n\t\t.ivsize\t\t= DES_BLOCK_SIZE,\n\t\t.maxauthsize\t= MD5_DIGEST_SIZE,\n\t},\n\t.hash = &hash_alg_md5,\n\t.cfg_enc = CIPH_ENCR | MOD_DES | MOD_CBC_ENC | KEYLEN_192,\n\t.cfg_dec = CIPH_DECR | MOD_DES | MOD_CBC_DEC | KEYLEN_192,\n}, {\n\t.crypto\t= {\n\t\t.base = {\n\t\t\t.cra_name\t= \"authenc(hmac(md5),cbc(des3_ede))\",\n\t\t\t.cra_blocksize\t= DES3_EDE_BLOCK_SIZE,\n\t\t},\n\t\t.ivsize\t\t= DES3_EDE_BLOCK_SIZE,\n\t\t.maxauthsize\t= MD5_DIGEST_SIZE,\n\t\t.setkey\t\t= des3_aead_setkey,\n\t},\n\t.hash = &hash_alg_md5,\n\t.cfg_enc = CIPH_ENCR | MOD_3DES | MOD_CBC_ENC | KEYLEN_192,\n\t.cfg_dec = CIPH_DECR | MOD_3DES | MOD_CBC_DEC | KEYLEN_192,\n}, {\n\t.crypto\t= {\n\t\t.base = {\n\t\t\t.cra_name\t= \"authenc(hmac(sha1),cbc(des))\",\n\t\t\t.cra_blocksize\t= DES_BLOCK_SIZE,\n\t\t},\n\t\t\t.ivsize\t\t= DES_BLOCK_SIZE,\n\t\t\t.maxauthsize\t= SHA1_DIGEST_SIZE,\n\t},\n\t.hash = &hash_alg_sha1,\n\t.cfg_enc = CIPH_ENCR | MOD_DES | MOD_CBC_ENC | KEYLEN_192,\n\t.cfg_dec = CIPH_DECR | MOD_DES | MOD_CBC_DEC | KEYLEN_192,\n}, {\n\t.crypto\t= {\n\t\t.base = {\n\t\t\t.cra_name\t= \"authenc(hmac(sha1),cbc(des3_ede))\",\n\t\t\t.cra_blocksize\t= DES3_EDE_BLOCK_SIZE,\n\t\t},\n\t\t.ivsize\t\t= DES3_EDE_BLOCK_SIZE,\n\t\t.maxauthsize\t= SHA1_DIGEST_SIZE,\n\t\t.setkey\t\t= des3_aead_setkey,\n\t},\n\t.hash = &hash_alg_sha1,\n\t.cfg_enc = CIPH_ENCR | MOD_3DES | MOD_CBC_ENC | KEYLEN_192,\n\t.cfg_dec = CIPH_DECR | MOD_3DES | MOD_CBC_DEC | KEYLEN_192,\n}, {\n\t.crypto\t= {\n\t\t.base = {\n\t\t\t.cra_name\t= \"authenc(hmac(md5),cbc(aes))\",\n\t\t\t.cra_blocksize\t= AES_BLOCK_SIZE,\n\t\t},\n\t\t.ivsize\t\t= AES_BLOCK_SIZE,\n\t\t.maxauthsize\t= MD5_DIGEST_SIZE,\n\t},\n\t.hash = &hash_alg_md5,\n\t.cfg_enc = CIPH_ENCR | MOD_AES | MOD_CBC_ENC,\n\t.cfg_dec = CIPH_DECR | MOD_AES | MOD_CBC_DEC,\n}, {\n\t.crypto\t= {\n\t\t.base = {\n\t\t\t.cra_name\t= \"authenc(hmac(sha1),cbc(aes))\",\n\t\t\t.cra_blocksize\t= AES_BLOCK_SIZE,\n\t\t},\n\t\t.ivsize\t\t= AES_BLOCK_SIZE,\n\t\t.maxauthsize\t= SHA1_DIGEST_SIZE,\n\t},\n\t.hash = &hash_alg_sha1,\n\t.cfg_enc = CIPH_ENCR | MOD_AES | MOD_CBC_ENC,\n\t.cfg_dec = CIPH_DECR | MOD_AES | MOD_CBC_DEC,\n} };\n\n#define IXP_POSTFIX \"-ixp4xx\"\n\nstatic int ixp_crypto_probe(struct platform_device *_pdev)\n{\n\tstruct device *dev = &_pdev->dev;\n\tint num = ARRAY_SIZE(ixp4xx_algos);\n\tint i, err;\n\n\tpdev = _pdev;\n\n\terr = init_ixp_crypto(dev);\n\tif (err)\n\t\treturn err;\n\n\tfor (i = 0; i < num; i++) {\n\t\tstruct skcipher_alg *cra = &ixp4xx_algos[i].crypto;\n\n\t\tif (snprintf(cra->base.cra_driver_name, CRYPTO_MAX_ALG_NAME,\n\t\t\t     \"%s\"IXP_POSTFIX, cra->base.cra_name) >=\n\t\t\t     CRYPTO_MAX_ALG_NAME)\n\t\t\tcontinue;\n\t\tif (!support_aes && (ixp4xx_algos[i].cfg_enc & MOD_AES))\n\t\t\tcontinue;\n\n\t\t \n\t\tcra->base.cra_flags = CRYPTO_ALG_KERN_DRIVER_ONLY |\n\t\t\t\t      CRYPTO_ALG_ASYNC |\n\t\t\t\t      CRYPTO_ALG_ALLOCATES_MEMORY |\n\t\t\t\t      CRYPTO_ALG_NEED_FALLBACK;\n\t\tif (!cra->setkey)\n\t\t\tcra->setkey = ablk_setkey;\n\t\tif (!cra->encrypt)\n\t\t\tcra->encrypt = ablk_encrypt;\n\t\tif (!cra->decrypt)\n\t\t\tcra->decrypt = ablk_decrypt;\n\t\tcra->init = init_tfm_ablk;\n\t\tcra->exit = exit_tfm_ablk;\n\n\t\tcra->base.cra_ctxsize = sizeof(struct ixp_ctx);\n\t\tcra->base.cra_module = THIS_MODULE;\n\t\tcra->base.cra_alignmask = 3;\n\t\tcra->base.cra_priority = 300;\n\t\tif (crypto_register_skcipher(cra))\n\t\t\tdev_err(&pdev->dev, \"Failed to register '%s'\\n\",\n\t\t\t\tcra->base.cra_name);\n\t\telse\n\t\t\tixp4xx_algos[i].registered = 1;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(ixp4xx_aeads); i++) {\n\t\tstruct aead_alg *cra = &ixp4xx_aeads[i].crypto;\n\n\t\tif (snprintf(cra->base.cra_driver_name, CRYPTO_MAX_ALG_NAME,\n\t\t\t     \"%s\"IXP_POSTFIX, cra->base.cra_name) >=\n\t\t    CRYPTO_MAX_ALG_NAME)\n\t\t\tcontinue;\n\t\tif (!support_aes && (ixp4xx_algos[i].cfg_enc & MOD_AES))\n\t\t\tcontinue;\n\n\t\t \n\t\tcra->base.cra_flags = CRYPTO_ALG_KERN_DRIVER_ONLY |\n\t\t\t\t      CRYPTO_ALG_ASYNC |\n\t\t\t\t      CRYPTO_ALG_ALLOCATES_MEMORY;\n\t\tcra->setkey = cra->setkey ?: aead_setkey;\n\t\tcra->setauthsize = aead_setauthsize;\n\t\tcra->encrypt = aead_encrypt;\n\t\tcra->decrypt = aead_decrypt;\n\t\tcra->init = init_tfm_aead;\n\t\tcra->exit = exit_tfm_aead;\n\n\t\tcra->base.cra_ctxsize = sizeof(struct ixp_ctx);\n\t\tcra->base.cra_module = THIS_MODULE;\n\t\tcra->base.cra_alignmask = 3;\n\t\tcra->base.cra_priority = 300;\n\n\t\tif (crypto_register_aead(cra))\n\t\t\tdev_err(&pdev->dev, \"Failed to register '%s'\\n\",\n\t\t\t\tcra->base.cra_driver_name);\n\t\telse\n\t\t\tixp4xx_aeads[i].registered = 1;\n\t}\n\treturn 0;\n}\n\nstatic int ixp_crypto_remove(struct platform_device *pdev)\n{\n\tint num = ARRAY_SIZE(ixp4xx_algos);\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(ixp4xx_aeads); i++) {\n\t\tif (ixp4xx_aeads[i].registered)\n\t\t\tcrypto_unregister_aead(&ixp4xx_aeads[i].crypto);\n\t}\n\n\tfor (i = 0; i < num; i++) {\n\t\tif (ixp4xx_algos[i].registered)\n\t\t\tcrypto_unregister_skcipher(&ixp4xx_algos[i].crypto);\n\t}\n\trelease_ixp_crypto(&pdev->dev);\n\n\treturn 0;\n}\nstatic const struct of_device_id ixp4xx_crypto_of_match[] = {\n\t{\n\t\t.compatible = \"intel,ixp4xx-crypto\",\n\t},\n\t{},\n};\n\nstatic struct platform_driver ixp_crypto_driver = {\n\t.probe = ixp_crypto_probe,\n\t.remove = ixp_crypto_remove,\n\t.driver = {\n\t\t.name = \"ixp4xx_crypto\",\n\t\t.of_match_table = ixp4xx_crypto_of_match,\n\t},\n};\nmodule_platform_driver(ixp_crypto_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Christian Hohnstaedt <chohnstaedt@innominate.com>\");\nMODULE_DESCRIPTION(\"IXP4xx hardware crypto\");\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}