{
  "module_name": "omap-aes-gcm.c",
  "hash_id": "8ad0ff027856ce8d3eb4da35c53cfebb9bdaf45e47673dedcbb42024fe602180",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/omap-aes-gcm.c",
  "human_readable_source": "\n \n\n#include <crypto/aes.h>\n#include <crypto/engine.h>\n#include <crypto/gcm.h>\n#include <crypto/internal/aead.h>\n#include <crypto/scatterwalk.h>\n#include <crypto/skcipher.h>\n#include <linux/errno.h>\n#include <linux/dma-mapping.h>\n#include <linux/dmaengine.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/omap-dma.h>\n#include <linux/pm_runtime.h>\n#include <linux/scatterlist.h>\n#include <linux/string.h>\n\n#include \"omap-crypto.h\"\n#include \"omap-aes.h\"\n\nstatic int omap_aes_gcm_handle_queue(struct omap_aes_dev *dd,\n\t\t\t\t     struct aead_request *req);\n\nstatic void omap_aes_gcm_finish_req(struct omap_aes_dev *dd, int ret)\n{\n\tstruct aead_request *req = dd->aead_req;\n\n\tdd->in_sg = NULL;\n\tdd->out_sg = NULL;\n\n\tcrypto_finalize_aead_request(dd->engine, req, ret);\n\n\tpm_runtime_mark_last_busy(dd->dev);\n\tpm_runtime_put_autosuspend(dd->dev);\n}\n\nstatic void omap_aes_gcm_done_task(struct omap_aes_dev *dd)\n{\n\tu8 *tag;\n\tint alen, clen, i, ret = 0, nsg;\n\tstruct omap_aes_reqctx *rctx;\n\n\talen = ALIGN(dd->assoc_len, AES_BLOCK_SIZE);\n\tclen = ALIGN(dd->total, AES_BLOCK_SIZE);\n\trctx = aead_request_ctx(dd->aead_req);\n\n\tnsg = !!(dd->assoc_len && dd->total);\n\n\tdma_sync_sg_for_device(dd->dev, dd->out_sg, dd->out_sg_len,\n\t\t\t       DMA_FROM_DEVICE);\n\tdma_unmap_sg(dd->dev, dd->in_sg, dd->in_sg_len, DMA_TO_DEVICE);\n\tdma_unmap_sg(dd->dev, dd->out_sg, dd->out_sg_len, DMA_FROM_DEVICE);\n\tomap_aes_crypt_dma_stop(dd);\n\n\tomap_crypto_cleanup(dd->out_sg, dd->orig_out,\n\t\t\t    dd->aead_req->assoclen, dd->total,\n\t\t\t    FLAGS_OUT_DATA_ST_SHIFT, dd->flags);\n\n\tif (dd->flags & FLAGS_ENCRYPT)\n\t\tscatterwalk_map_and_copy(rctx->auth_tag,\n\t\t\t\t\t dd->aead_req->dst,\n\t\t\t\t\t dd->total + dd->aead_req->assoclen,\n\t\t\t\t\t dd->authsize, 1);\n\n\tomap_crypto_cleanup(&dd->in_sgl[0], NULL, 0, alen,\n\t\t\t    FLAGS_ASSOC_DATA_ST_SHIFT, dd->flags);\n\n\tomap_crypto_cleanup(&dd->in_sgl[nsg], NULL, 0, clen,\n\t\t\t    FLAGS_IN_DATA_ST_SHIFT, dd->flags);\n\n\tif (!(dd->flags & FLAGS_ENCRYPT)) {\n\t\ttag = (u8 *)rctx->auth_tag;\n\t\tfor (i = 0; i < dd->authsize; i++) {\n\t\t\tif (tag[i]) {\n\t\t\t\tret = -EBADMSG;\n\t\t\t}\n\t\t}\n\t}\n\n\tomap_aes_gcm_finish_req(dd, ret);\n}\n\nstatic int omap_aes_gcm_copy_buffers(struct omap_aes_dev *dd,\n\t\t\t\t     struct aead_request *req)\n{\n\tint alen, clen, cryptlen, assoclen, ret;\n\tstruct crypto_aead *aead = crypto_aead_reqtfm(req);\n\tunsigned int authlen = crypto_aead_authsize(aead);\n\tstruct scatterlist *tmp, sg_arr[2];\n\tint nsg;\n\tu16 flags;\n\n\tassoclen = req->assoclen;\n\tcryptlen = req->cryptlen;\n\n\tif (dd->flags & FLAGS_RFC4106_GCM)\n\t\tassoclen -= 8;\n\n\tif (!(dd->flags & FLAGS_ENCRYPT))\n\t\tcryptlen -= authlen;\n\n\talen = ALIGN(assoclen, AES_BLOCK_SIZE);\n\tclen = ALIGN(cryptlen, AES_BLOCK_SIZE);\n\n\tnsg = !!(assoclen && cryptlen);\n\n\tomap_aes_clear_copy_flags(dd);\n\n\tsg_init_table(dd->in_sgl, nsg + 1);\n\tif (assoclen) {\n\t\ttmp = req->src;\n\t\tret = omap_crypto_align_sg(&tmp, assoclen,\n\t\t\t\t\t   AES_BLOCK_SIZE, dd->in_sgl,\n\t\t\t\t\t   OMAP_CRYPTO_COPY_DATA |\n\t\t\t\t\t   OMAP_CRYPTO_ZERO_BUF |\n\t\t\t\t\t   OMAP_CRYPTO_FORCE_SINGLE_ENTRY,\n\t\t\t\t\t   FLAGS_ASSOC_DATA_ST_SHIFT,\n\t\t\t\t\t   &dd->flags);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (cryptlen) {\n\t\ttmp = scatterwalk_ffwd(sg_arr, req->src, req->assoclen);\n\n\t\tif (nsg)\n\t\t\tsg_unmark_end(dd->in_sgl);\n\n\t\tret = omap_crypto_align_sg(&tmp, cryptlen,\n\t\t\t\t\t   AES_BLOCK_SIZE, &dd->in_sgl[nsg],\n\t\t\t\t\t   OMAP_CRYPTO_COPY_DATA |\n\t\t\t\t\t   OMAP_CRYPTO_ZERO_BUF |\n\t\t\t\t\t   OMAP_CRYPTO_FORCE_SINGLE_ENTRY,\n\t\t\t\t\t   FLAGS_IN_DATA_ST_SHIFT,\n\t\t\t\t\t   &dd->flags);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tdd->in_sg = dd->in_sgl;\n\tdd->total = cryptlen;\n\tdd->assoc_len = assoclen;\n\tdd->authsize = authlen;\n\n\tdd->out_sg = req->dst;\n\tdd->orig_out = req->dst;\n\n\tdd->out_sg = scatterwalk_ffwd(sg_arr, req->dst, req->assoclen);\n\n\tflags = 0;\n\tif (req->src == req->dst || dd->out_sg == sg_arr)\n\t\tflags |= OMAP_CRYPTO_FORCE_COPY;\n\n\tif (cryptlen) {\n\t\tret = omap_crypto_align_sg(&dd->out_sg, cryptlen,\n\t\t\t\t\t   AES_BLOCK_SIZE, &dd->out_sgl,\n\t\t\t\t\t   flags,\n\t\t\t\t\t   FLAGS_OUT_DATA_ST_SHIFT, &dd->flags);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tdd->in_sg_len = sg_nents_for_len(dd->in_sg, alen + clen);\n\tdd->out_sg_len = sg_nents_for_len(dd->out_sg, clen);\n\n\treturn 0;\n}\n\nstatic int do_encrypt_iv(struct aead_request *req, u32 *tag, u32 *iv)\n{\n\tstruct omap_aes_gcm_ctx *ctx = crypto_aead_ctx(crypto_aead_reqtfm(req));\n\n\taes_encrypt(&ctx->actx, (u8 *)tag, (u8 *)iv);\n\treturn 0;\n}\n\nvoid omap_aes_gcm_dma_out_callback(void *data)\n{\n\tstruct omap_aes_dev *dd = data;\n\tstruct omap_aes_reqctx *rctx;\n\tint i, val;\n\tu32 *auth_tag, tag[4];\n\n\tif (!(dd->flags & FLAGS_ENCRYPT))\n\t\tscatterwalk_map_and_copy(tag, dd->aead_req->src,\n\t\t\t\t\t dd->total + dd->aead_req->assoclen,\n\t\t\t\t\t dd->authsize, 0);\n\n\trctx = aead_request_ctx(dd->aead_req);\n\tauth_tag = (u32 *)rctx->auth_tag;\n\tfor (i = 0; i < 4; i++) {\n\t\tval = omap_aes_read(dd, AES_REG_TAG_N(dd, i));\n\t\tauth_tag[i] = val ^ auth_tag[i];\n\t\tif (!(dd->flags & FLAGS_ENCRYPT))\n\t\t\tauth_tag[i] = auth_tag[i] ^ tag[i];\n\t}\n\n\tomap_aes_gcm_done_task(dd);\n}\n\nstatic int omap_aes_gcm_handle_queue(struct omap_aes_dev *dd,\n\t\t\t\t     struct aead_request *req)\n{\n\tif (req)\n\t\treturn crypto_transfer_aead_request_to_engine(dd->engine, req);\n\n\treturn 0;\n}\n\nstatic int omap_aes_gcm_prepare_req(struct aead_request *req,\n\t\t\t\t    struct omap_aes_dev *dd)\n{\n\tstruct omap_aes_reqctx *rctx = aead_request_ctx(req);\n\tstruct omap_aes_gcm_ctx *ctx = crypto_aead_ctx(crypto_aead_reqtfm(req));\n\tint err;\n\n\tdd->aead_req = req;\n\n\trctx->mode &= FLAGS_MODE_MASK;\n\tdd->flags = (dd->flags & ~FLAGS_MODE_MASK) | rctx->mode;\n\n\terr = omap_aes_gcm_copy_buffers(dd, req);\n\tif (err)\n\t\treturn err;\n\n\tdd->ctx = &ctx->octx;\n\n\treturn omap_aes_write_ctrl(dd);\n}\n\nstatic int omap_aes_gcm_crypt(struct aead_request *req, unsigned long mode)\n{\n\tstruct omap_aes_reqctx *rctx = aead_request_ctx(req);\n\tstruct crypto_aead *aead = crypto_aead_reqtfm(req);\n\tunsigned int authlen = crypto_aead_authsize(aead);\n\tstruct omap_aes_dev *dd;\n\t__be32 counter = cpu_to_be32(1);\n\tint err, assoclen;\n\n\tmemset(rctx->auth_tag, 0, sizeof(rctx->auth_tag));\n\tmemcpy(rctx->iv + GCM_AES_IV_SIZE, &counter, 4);\n\n\terr = do_encrypt_iv(req, (u32 *)rctx->auth_tag, (u32 *)rctx->iv);\n\tif (err)\n\t\treturn err;\n\n\tif (mode & FLAGS_RFC4106_GCM)\n\t\tassoclen = req->assoclen - 8;\n\telse\n\t\tassoclen = req->assoclen;\n\tif (assoclen + req->cryptlen == 0) {\n\t\tscatterwalk_map_and_copy(rctx->auth_tag, req->dst, 0, authlen,\n\t\t\t\t\t 1);\n\t\treturn 0;\n\t}\n\n\tdd = omap_aes_find_dev(rctx);\n\tif (!dd)\n\t\treturn -ENODEV;\n\trctx->mode = mode;\n\n\treturn omap_aes_gcm_handle_queue(dd, req);\n}\n\nint omap_aes_gcm_encrypt(struct aead_request *req)\n{\n\tstruct omap_aes_reqctx *rctx = aead_request_ctx(req);\n\n\tmemcpy(rctx->iv, req->iv, GCM_AES_IV_SIZE);\n\treturn omap_aes_gcm_crypt(req, FLAGS_ENCRYPT | FLAGS_GCM);\n}\n\nint omap_aes_gcm_decrypt(struct aead_request *req)\n{\n\tstruct omap_aes_reqctx *rctx = aead_request_ctx(req);\n\n\tmemcpy(rctx->iv, req->iv, GCM_AES_IV_SIZE);\n\treturn omap_aes_gcm_crypt(req, FLAGS_GCM);\n}\n\nint omap_aes_4106gcm_encrypt(struct aead_request *req)\n{\n\tstruct omap_aes_gcm_ctx *ctx = crypto_aead_ctx(crypto_aead_reqtfm(req));\n\tstruct omap_aes_reqctx *rctx = aead_request_ctx(req);\n\n\tmemcpy(rctx->iv, ctx->octx.nonce, 4);\n\tmemcpy(rctx->iv + 4, req->iv, 8);\n\treturn crypto_ipsec_check_assoclen(req->assoclen) ?:\n\t       omap_aes_gcm_crypt(req, FLAGS_ENCRYPT | FLAGS_GCM |\n\t\t\t\t  FLAGS_RFC4106_GCM);\n}\n\nint omap_aes_4106gcm_decrypt(struct aead_request *req)\n{\n\tstruct omap_aes_gcm_ctx *ctx = crypto_aead_ctx(crypto_aead_reqtfm(req));\n\tstruct omap_aes_reqctx *rctx = aead_request_ctx(req);\n\n\tmemcpy(rctx->iv, ctx->octx.nonce, 4);\n\tmemcpy(rctx->iv + 4, req->iv, 8);\n\treturn crypto_ipsec_check_assoclen(req->assoclen) ?:\n\t       omap_aes_gcm_crypt(req, FLAGS_GCM | FLAGS_RFC4106_GCM);\n}\n\nint omap_aes_gcm_setkey(struct crypto_aead *tfm, const u8 *key,\n\t\t\tunsigned int keylen)\n{\n\tstruct omap_aes_gcm_ctx *ctx = crypto_aead_ctx(tfm);\n\tint ret;\n\n\tret = aes_expandkey(&ctx->actx, key, keylen);\n\tif (ret)\n\t\treturn ret;\n\n\tmemcpy(ctx->octx.key, key, keylen);\n\tctx->octx.keylen = keylen;\n\n\treturn 0;\n}\n\nint omap_aes_4106gcm_setkey(struct crypto_aead *tfm, const u8 *key,\n\t\t\t    unsigned int keylen)\n{\n\tstruct omap_aes_gcm_ctx *ctx = crypto_aead_ctx(tfm);\n\tint ret;\n\n\tif (keylen < 4)\n\t\treturn -EINVAL;\n\tkeylen -= 4;\n\n\tret = aes_expandkey(&ctx->actx, key, keylen);\n\tif (ret)\n\t\treturn ret;\n\n\tmemcpy(ctx->octx.key, key, keylen);\n\tmemcpy(ctx->octx.nonce, key + keylen, 4);\n\tctx->octx.keylen = keylen;\n\n\treturn 0;\n}\n\nint omap_aes_gcm_setauthsize(struct crypto_aead *tfm, unsigned int authsize)\n{\n\treturn crypto_gcm_check_authsize(authsize);\n}\n\nint omap_aes_4106gcm_setauthsize(struct crypto_aead *parent,\n\t\t\t\t unsigned int authsize)\n{\n\treturn crypto_rfc4106_check_authsize(authsize);\n}\n\nint omap_aes_gcm_crypt_req(struct crypto_engine *engine, void *areq)\n{\n\tstruct aead_request *req = container_of(areq, struct aead_request,\n\t\t\t\t\t\tbase);\n\tstruct omap_aes_reqctx *rctx = aead_request_ctx(req);\n\tstruct omap_aes_dev *dd = rctx->dd;\n\tint ret;\n\n\tif (!dd)\n\t\treturn -ENODEV;\n\n\tret = omap_aes_gcm_prepare_req(req, dd);\n\tif (ret)\n\t\treturn ret;\n\n\tif (dd->in_sg_len)\n\t\tret = omap_aes_crypt_dma_start(dd);\n\telse\n\t\tomap_aes_gcm_dma_out_callback(dd);\n\n\treturn ret;\n}\n\nint omap_aes_gcm_cra_init(struct crypto_aead *tfm)\n{\n\tcrypto_aead_set_reqsize(tfm, sizeof(struct omap_aes_reqctx));\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}