{
  "module_name": "amlogic-gxl-core.c",
  "hash_id": "0e192c82abc312b401a541268722b8fae79a0d3bdf27357f639a51a3cd23013a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/amlogic/amlogic-gxl-core.c",
  "human_readable_source": "\n \n\n#include <crypto/engine.h>\n#include <crypto/internal/skcipher.h>\n#include <linux/clk.h>\n#include <linux/dma-mapping.h>\n#include <linux/err.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/irq.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n\n#include \"amlogic-gxl.h\"\n\nstatic irqreturn_t meson_irq_handler(int irq, void *data)\n{\n\tstruct meson_dev *mc = (struct meson_dev *)data;\n\tint flow;\n\tu32 p;\n\n\tfor (flow = 0; flow < MAXFLOW; flow++) {\n\t\tif (mc->irqs[flow] == irq) {\n\t\t\tp = readl(mc->base + ((0x04 + flow) << 2));\n\t\t\tif (p) {\n\t\t\t\twritel_relaxed(0xF, mc->base + ((0x4 + flow) << 2));\n\t\t\t\tmc->chanlist[flow].status = 1;\n\t\t\t\tcomplete(&mc->chanlist[flow].complete);\n\t\t\t\treturn IRQ_HANDLED;\n\t\t\t}\n\t\t\tdev_err(mc->dev, \"%s %d Got irq for flow %d but ctrl is empty\\n\", __func__, irq, flow);\n\t\t}\n\t}\n\n\tdev_err(mc->dev, \"%s %d from unknown irq\\n\", __func__, irq);\n\treturn IRQ_HANDLED;\n}\n\nstatic struct meson_alg_template mc_algs[] = {\n{\n\t.type = CRYPTO_ALG_TYPE_SKCIPHER,\n\t.blockmode = MESON_OPMODE_CBC,\n\t.alg.skcipher.base = {\n\t\t.base = {\n\t\t\t.cra_name = \"cbc(aes)\",\n\t\t\t.cra_driver_name = \"cbc-aes-gxl\",\n\t\t\t.cra_priority = 400,\n\t\t\t.cra_blocksize = AES_BLOCK_SIZE,\n\t\t\t.cra_flags = CRYPTO_ALG_TYPE_SKCIPHER |\n\t\t\t\tCRYPTO_ALG_ASYNC | CRYPTO_ALG_ALLOCATES_MEMORY |\n\t\t\t\tCRYPTO_ALG_NEED_FALLBACK,\n\t\t\t.cra_ctxsize = sizeof(struct meson_cipher_tfm_ctx),\n\t\t\t.cra_module = THIS_MODULE,\n\t\t\t.cra_alignmask = 0xf,\n\t\t\t.cra_init = meson_cipher_init,\n\t\t\t.cra_exit = meson_cipher_exit,\n\t\t},\n\t\t.min_keysize\t= AES_MIN_KEY_SIZE,\n\t\t.max_keysize\t= AES_MAX_KEY_SIZE,\n\t\t.ivsize\t\t= AES_BLOCK_SIZE,\n\t\t.setkey\t\t= meson_aes_setkey,\n\t\t.encrypt\t= meson_skencrypt,\n\t\t.decrypt\t= meson_skdecrypt,\n\t},\n\t.alg.skcipher.op = {\n\t\t.do_one_request = meson_handle_cipher_request,\n\t},\n},\n{\n\t.type = CRYPTO_ALG_TYPE_SKCIPHER,\n\t.blockmode = MESON_OPMODE_ECB,\n\t.alg.skcipher.base = {\n\t\t.base = {\n\t\t\t.cra_name = \"ecb(aes)\",\n\t\t\t.cra_driver_name = \"ecb-aes-gxl\",\n\t\t\t.cra_priority = 400,\n\t\t\t.cra_blocksize = AES_BLOCK_SIZE,\n\t\t\t.cra_flags = CRYPTO_ALG_TYPE_SKCIPHER |\n\t\t\t\tCRYPTO_ALG_ASYNC | CRYPTO_ALG_ALLOCATES_MEMORY |\n\t\t\t\tCRYPTO_ALG_NEED_FALLBACK,\n\t\t\t.cra_ctxsize = sizeof(struct meson_cipher_tfm_ctx),\n\t\t\t.cra_module = THIS_MODULE,\n\t\t\t.cra_alignmask = 0xf,\n\t\t\t.cra_init = meson_cipher_init,\n\t\t\t.cra_exit = meson_cipher_exit,\n\t\t},\n\t\t.min_keysize\t= AES_MIN_KEY_SIZE,\n\t\t.max_keysize\t= AES_MAX_KEY_SIZE,\n\t\t.setkey\t\t= meson_aes_setkey,\n\t\t.encrypt\t= meson_skencrypt,\n\t\t.decrypt\t= meson_skdecrypt,\n\t},\n\t.alg.skcipher.op = {\n\t\t.do_one_request = meson_handle_cipher_request,\n\t},\n},\n};\n\nstatic int meson_debugfs_show(struct seq_file *seq, void *v)\n{\n\tstruct meson_dev *mc __maybe_unused = seq->private;\n\tint i;\n\n\tfor (i = 0; i < MAXFLOW; i++)\n\t\tseq_printf(seq, \"Channel %d: nreq %lu\\n\", i,\n#ifdef CONFIG_CRYPTO_DEV_AMLOGIC_GXL_DEBUG\n\t\t\t   mc->chanlist[i].stat_req);\n#else\n\t\t\t   0ul);\n#endif\n\n\tfor (i = 0; i < ARRAY_SIZE(mc_algs); i++) {\n\t\tswitch (mc_algs[i].type) {\n\t\tcase CRYPTO_ALG_TYPE_SKCIPHER:\n\t\t\tseq_printf(seq, \"%s %s %lu %lu\\n\",\n\t\t\t\t   mc_algs[i].alg.skcipher.base.base.cra_driver_name,\n\t\t\t\t   mc_algs[i].alg.skcipher.base.base.cra_name,\n#ifdef CONFIG_CRYPTO_DEV_AMLOGIC_GXL_DEBUG\n\t\t\t\t   mc_algs[i].stat_req, mc_algs[i].stat_fb);\n#else\n\t\t\t\t   0ul, 0ul);\n#endif\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(meson_debugfs);\n\nstatic void meson_free_chanlist(struct meson_dev *mc, int i)\n{\n\twhile (i >= 0) {\n\t\tcrypto_engine_exit(mc->chanlist[i].engine);\n\t\tif (mc->chanlist[i].tl)\n\t\t\tdma_free_coherent(mc->dev, sizeof(struct meson_desc) * MAXDESC,\n\t\t\t\t\t  mc->chanlist[i].tl,\n\t\t\t\t\t  mc->chanlist[i].t_phy);\n\t\ti--;\n\t}\n}\n\n \nstatic int meson_allocate_chanlist(struct meson_dev *mc)\n{\n\tint i, err;\n\n\tmc->chanlist = devm_kcalloc(mc->dev, MAXFLOW,\n\t\t\t\t    sizeof(struct meson_flow), GFP_KERNEL);\n\tif (!mc->chanlist)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < MAXFLOW; i++) {\n\t\tinit_completion(&mc->chanlist[i].complete);\n\n\t\tmc->chanlist[i].engine = crypto_engine_alloc_init(mc->dev, true);\n\t\tif (!mc->chanlist[i].engine) {\n\t\t\tdev_err(mc->dev, \"Cannot allocate engine\\n\");\n\t\t\ti--;\n\t\t\terr = -ENOMEM;\n\t\t\tgoto error_engine;\n\t\t}\n\t\terr = crypto_engine_start(mc->chanlist[i].engine);\n\t\tif (err) {\n\t\t\tdev_err(mc->dev, \"Cannot start engine\\n\");\n\t\t\tgoto error_engine;\n\t\t}\n\t\tmc->chanlist[i].tl = dma_alloc_coherent(mc->dev,\n\t\t\t\t\t\t\tsizeof(struct meson_desc) * MAXDESC,\n\t\t\t\t\t\t\t&mc->chanlist[i].t_phy,\n\t\t\t\t\t\t\tGFP_KERNEL);\n\t\tif (!mc->chanlist[i].tl) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto error_engine;\n\t\t}\n\t}\n\treturn 0;\nerror_engine:\n\tmeson_free_chanlist(mc, i);\n\treturn err;\n}\n\nstatic int meson_register_algs(struct meson_dev *mc)\n{\n\tint err, i;\n\n\tfor (i = 0; i < ARRAY_SIZE(mc_algs); i++) {\n\t\tmc_algs[i].mc = mc;\n\t\tswitch (mc_algs[i].type) {\n\t\tcase CRYPTO_ALG_TYPE_SKCIPHER:\n\t\t\terr = crypto_engine_register_skcipher(&mc_algs[i].alg.skcipher);\n\t\t\tif (err) {\n\t\t\t\tdev_err(mc->dev, \"Fail to register %s\\n\",\n\t\t\t\t\tmc_algs[i].alg.skcipher.base.base.cra_name);\n\t\t\t\tmc_algs[i].mc = NULL;\n\t\t\t\treturn err;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void meson_unregister_algs(struct meson_dev *mc)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(mc_algs); i++) {\n\t\tif (!mc_algs[i].mc)\n\t\t\tcontinue;\n\t\tswitch (mc_algs[i].type) {\n\t\tcase CRYPTO_ALG_TYPE_SKCIPHER:\n\t\t\tcrypto_engine_unregister_skcipher(&mc_algs[i].alg.skcipher);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic int meson_crypto_probe(struct platform_device *pdev)\n{\n\tstruct meson_dev *mc;\n\tint err, i;\n\n\tmc = devm_kzalloc(&pdev->dev, sizeof(*mc), GFP_KERNEL);\n\tif (!mc)\n\t\treturn -ENOMEM;\n\n\tmc->dev = &pdev->dev;\n\tplatform_set_drvdata(pdev, mc);\n\n\tmc->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(mc->base)) {\n\t\terr = PTR_ERR(mc->base);\n\t\tdev_err(&pdev->dev, \"Cannot request MMIO err=%d\\n\", err);\n\t\treturn err;\n\t}\n\tmc->busclk = devm_clk_get(&pdev->dev, \"blkmv\");\n\tif (IS_ERR(mc->busclk)) {\n\t\terr = PTR_ERR(mc->busclk);\n\t\tdev_err(&pdev->dev, \"Cannot get core clock err=%d\\n\", err);\n\t\treturn err;\n\t}\n\n\tfor (i = 0; i < MAXFLOW; i++) {\n\t\tmc->irqs[i] = platform_get_irq(pdev, i);\n\t\tif (mc->irqs[i] < 0)\n\t\t\treturn mc->irqs[i];\n\n\t\terr = devm_request_irq(&pdev->dev, mc->irqs[i], meson_irq_handler, 0,\n\t\t\t\t       \"gxl-crypto\", mc);\n\t\tif (err < 0) {\n\t\t\tdev_err(mc->dev, \"Cannot request IRQ for flow %d\\n\", i);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\terr = clk_prepare_enable(mc->busclk);\n\tif (err != 0) {\n\t\tdev_err(&pdev->dev, \"Cannot prepare_enable busclk\\n\");\n\t\treturn err;\n\t}\n\n\terr = meson_allocate_chanlist(mc);\n\tif (err)\n\t\tgoto error_flow;\n\n\terr = meson_register_algs(mc);\n\tif (err)\n\t\tgoto error_alg;\n\n\tif (IS_ENABLED(CONFIG_CRYPTO_DEV_AMLOGIC_GXL_DEBUG)) {\n\t\tstruct dentry *dbgfs_dir;\n\n\t\tdbgfs_dir = debugfs_create_dir(\"gxl-crypto\", NULL);\n\t\tdebugfs_create_file(\"stats\", 0444, dbgfs_dir, mc, &meson_debugfs_fops);\n\n#ifdef CONFIG_CRYPTO_DEV_AMLOGIC_GXL_DEBUG\n\t\tmc->dbgfs_dir = dbgfs_dir;\n#endif\n\t}\n\n\treturn 0;\nerror_alg:\n\tmeson_unregister_algs(mc);\nerror_flow:\n\tmeson_free_chanlist(mc, MAXFLOW - 1);\n\tclk_disable_unprepare(mc->busclk);\n\treturn err;\n}\n\nstatic int meson_crypto_remove(struct platform_device *pdev)\n{\n\tstruct meson_dev *mc = platform_get_drvdata(pdev);\n\n#ifdef CONFIG_CRYPTO_DEV_AMLOGIC_GXL_DEBUG\n\tdebugfs_remove_recursive(mc->dbgfs_dir);\n#endif\n\n\tmeson_unregister_algs(mc);\n\n\tmeson_free_chanlist(mc, MAXFLOW - 1);\n\n\tclk_disable_unprepare(mc->busclk);\n\treturn 0;\n}\n\nstatic const struct of_device_id meson_crypto_of_match_table[] = {\n\t{ .compatible = \"amlogic,gxl-crypto\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, meson_crypto_of_match_table);\n\nstatic struct platform_driver meson_crypto_driver = {\n\t.probe\t\t = meson_crypto_probe,\n\t.remove\t\t = meson_crypto_remove,\n\t.driver\t\t = {\n\t\t.name\t\t   = \"gxl-crypto\",\n\t\t.of_match_table\t= meson_crypto_of_match_table,\n\t},\n};\n\nmodule_platform_driver(meson_crypto_driver);\n\nMODULE_DESCRIPTION(\"Amlogic GXL cryptographic offloader\");\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Corentin Labbe <clabbe@baylibre.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}