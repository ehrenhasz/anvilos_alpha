{
  "module_name": "qcom_hwspinlock.c",
  "hash_id": "6a92d21c948b22b8cefe3ce363d1e895ca03dcf20e9f3b230d87cfb98bb93649",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwspinlock/qcom_hwspinlock.c",
  "human_readable_source": "\n \n\n#include <linux/hwspinlock.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n\n#include \"hwspinlock_internal.h\"\n\n#define QCOM_MUTEX_APPS_PROC_ID\t1\n#define QCOM_MUTEX_NUM_LOCKS\t32\n\nstruct qcom_hwspinlock_of_data {\n\tu32 offset;\n\tu32 stride;\n\tconst struct regmap_config *regmap_config;\n};\n\nstatic int qcom_hwspinlock_trylock(struct hwspinlock *lock)\n{\n\tstruct regmap_field *field = lock->priv;\n\tu32 lock_owner;\n\tint ret;\n\n\tret = regmap_field_write(field, QCOM_MUTEX_APPS_PROC_ID);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_field_read(field, &lock_owner);\n\tif (ret)\n\t\treturn ret;\n\n\treturn lock_owner == QCOM_MUTEX_APPS_PROC_ID;\n}\n\nstatic void qcom_hwspinlock_unlock(struct hwspinlock *lock)\n{\n\tstruct regmap_field *field = lock->priv;\n\tu32 lock_owner;\n\tint ret;\n\n\tret = regmap_field_read(field, &lock_owner);\n\tif (ret) {\n\t\tpr_err(\"%s: unable to query spinlock owner\\n\", __func__);\n\t\treturn;\n\t}\n\n\tif (lock_owner != QCOM_MUTEX_APPS_PROC_ID) {\n\t\tpr_err(\"%s: spinlock not owned by us (actual owner is %d)\\n\",\n\t\t\t\t__func__, lock_owner);\n\t}\n\n\tret = regmap_field_write(field, 0);\n\tif (ret)\n\t\tpr_err(\"%s: failed to unlock spinlock\\n\", __func__);\n}\n\nstatic const struct hwspinlock_ops qcom_hwspinlock_ops = {\n\t.trylock\t= qcom_hwspinlock_trylock,\n\t.unlock\t\t= qcom_hwspinlock_unlock,\n};\n\nstatic const struct regmap_config sfpb_mutex_config = {\n\t.reg_bits\t\t= 32,\n\t.reg_stride\t\t= 4,\n\t.val_bits\t\t= 32,\n\t.max_register\t\t= 0x100,\n\t.fast_io\t\t= true,\n};\n\nstatic const struct qcom_hwspinlock_of_data of_sfpb_mutex = {\n\t.offset = 0x4,\n\t.stride = 0x4,\n\t.regmap_config = &sfpb_mutex_config,\n};\n\nstatic const struct regmap_config tcsr_msm8226_mutex_config = {\n\t.reg_bits\t\t= 32,\n\t.reg_stride\t\t= 4,\n\t.val_bits\t\t= 32,\n\t.max_register\t\t= 0x1000,\n\t.fast_io\t\t= true,\n};\n\nstatic const struct qcom_hwspinlock_of_data of_msm8226_tcsr_mutex = {\n\t.offset = 0,\n\t.stride = 0x80,\n\t.regmap_config = &tcsr_msm8226_mutex_config,\n};\n\nstatic const struct regmap_config tcsr_mutex_config = {\n\t.reg_bits\t\t= 32,\n\t.reg_stride\t\t= 4,\n\t.val_bits\t\t= 32,\n\t.max_register\t\t= 0x20000,\n\t.fast_io\t\t= true,\n};\n\nstatic const struct qcom_hwspinlock_of_data of_tcsr_mutex = {\n\t.offset = 0,\n\t.stride = 0x1000,\n\t.regmap_config = &tcsr_mutex_config,\n};\n\nstatic const struct of_device_id qcom_hwspinlock_of_match[] = {\n\t{ .compatible = \"qcom,sfpb-mutex\", .data = &of_sfpb_mutex },\n\t{ .compatible = \"qcom,tcsr-mutex\", .data = &of_tcsr_mutex },\n\t{ .compatible = \"qcom,apq8084-tcsr-mutex\", .data = &of_msm8226_tcsr_mutex },\n\t{ .compatible = \"qcom,ipq6018-tcsr-mutex\", .data = &of_msm8226_tcsr_mutex },\n\t{ .compatible = \"qcom,msm8226-tcsr-mutex\", .data = &of_msm8226_tcsr_mutex },\n\t{ .compatible = \"qcom,msm8974-tcsr-mutex\", .data = &of_msm8226_tcsr_mutex },\n\t{ .compatible = \"qcom,msm8994-tcsr-mutex\", .data = &of_msm8226_tcsr_mutex },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, qcom_hwspinlock_of_match);\n\nstatic struct regmap *qcom_hwspinlock_probe_syscon(struct platform_device *pdev,\n\t\t\t\t\t\t   u32 *base, u32 *stride)\n{\n\tstruct device_node *syscon;\n\tstruct regmap *regmap;\n\tint ret;\n\n\tsyscon = of_parse_phandle(pdev->dev.of_node, \"syscon\", 0);\n\tif (!syscon)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tregmap = syscon_node_to_regmap(syscon);\n\tof_node_put(syscon);\n\tif (IS_ERR(regmap))\n\t\treturn regmap;\n\n\tret = of_property_read_u32_index(pdev->dev.of_node, \"syscon\", 1, base);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"no offset in syscon\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tret = of_property_read_u32_index(pdev->dev.of_node, \"syscon\", 2, stride);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"no stride syscon\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn regmap;\n}\n\nstatic struct regmap *qcom_hwspinlock_probe_mmio(struct platform_device *pdev,\n\t\t\t\t\t\t u32 *offset, u32 *stride)\n{\n\tconst struct qcom_hwspinlock_of_data *data;\n\tstruct device *dev = &pdev->dev;\n\tvoid __iomem *base;\n\n\tdata = of_device_get_match_data(dev);\n\tif (!data->regmap_config)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t*offset = data->offset;\n\t*stride = data->stride;\n\n\tbase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(base))\n\t\treturn ERR_CAST(base);\n\n\treturn devm_regmap_init_mmio(dev, base, data->regmap_config);\n}\n\nstatic int qcom_hwspinlock_probe(struct platform_device *pdev)\n{\n\tstruct hwspinlock_device *bank;\n\tstruct reg_field field;\n\tstruct regmap *regmap;\n\tsize_t array_size;\n\tu32 stride;\n\tu32 base;\n\tint i;\n\n\tregmap = qcom_hwspinlock_probe_syscon(pdev, &base, &stride);\n\tif (IS_ERR(regmap) && PTR_ERR(regmap) == -ENODEV)\n\t\tregmap = qcom_hwspinlock_probe_mmio(pdev, &base, &stride);\n\n\tif (IS_ERR(regmap))\n\t\treturn PTR_ERR(regmap);\n\n\tarray_size = QCOM_MUTEX_NUM_LOCKS * sizeof(struct hwspinlock);\n\tbank = devm_kzalloc(&pdev->dev, sizeof(*bank) + array_size, GFP_KERNEL);\n\tif (!bank)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, bank);\n\n\tfor (i = 0; i < QCOM_MUTEX_NUM_LOCKS; i++) {\n\t\tfield.reg = base + i * stride;\n\t\tfield.lsb = 0;\n\t\tfield.msb = 31;\n\n\t\tbank->lock[i].priv = devm_regmap_field_alloc(&pdev->dev,\n\t\t\t\t\t\t\t     regmap, field);\n\t\tif (IS_ERR(bank->lock[i].priv))\n\t\t\treturn PTR_ERR(bank->lock[i].priv);\n\t}\n\n\treturn devm_hwspin_lock_register(&pdev->dev, bank, &qcom_hwspinlock_ops,\n\t\t\t\t\t 0, QCOM_MUTEX_NUM_LOCKS);\n}\n\nstatic struct platform_driver qcom_hwspinlock_driver = {\n\t.probe\t\t= qcom_hwspinlock_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"qcom_hwspinlock\",\n\t\t.of_match_table = qcom_hwspinlock_of_match,\n\t},\n};\n\nstatic int __init qcom_hwspinlock_init(void)\n{\n\treturn platform_driver_register(&qcom_hwspinlock_driver);\n}\n \npostcore_initcall(qcom_hwspinlock_init);\n\nstatic void __exit qcom_hwspinlock_exit(void)\n{\n\tplatform_driver_unregister(&qcom_hwspinlock_driver);\n}\nmodule_exit(qcom_hwspinlock_exit);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"Hardware spinlock driver for Qualcomm SoCs\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}