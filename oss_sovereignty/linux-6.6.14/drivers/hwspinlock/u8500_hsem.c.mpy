{
  "module_name": "u8500_hsem.c",
  "hash_id": "5b2b9f2045eff4134696b272264c7a3129b136f984717dbd5fbea33af8f9a4bf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwspinlock/u8500_hsem.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/hwspinlock.h>\n#include <linux/platform_device.h>\n\n#include \"hwspinlock_internal.h\"\n\n \n\n#define U8500_MAX_SEMAPHORE\t\t32\t \n#define RESET_SEMAPHORE\t\t\t(0)\t \n\n \n#define HSEM_MASTER_ID\t\t\t0x01\n\n#define HSEM_REGISTER_OFFSET\t\t0x08\n\n#define HSEM_CTRL_REG\t\t\t0x00\n#define HSEM_ICRALL\t\t\t0x90\n#define HSEM_PROTOCOL_1\t\t\t0x01\n\nstatic int u8500_hsem_trylock(struct hwspinlock *lock)\n{\n\tvoid __iomem *lock_addr = lock->priv;\n\n\twritel(HSEM_MASTER_ID, lock_addr);\n\n\t \n\treturn (HSEM_MASTER_ID == (0x0F & readl(lock_addr)));\n}\n\nstatic void u8500_hsem_unlock(struct hwspinlock *lock)\n{\n\tvoid __iomem *lock_addr = lock->priv;\n\n\t \n\twritel(RESET_SEMAPHORE, lock_addr);\n}\n\n \nstatic void u8500_hsem_relax(struct hwspinlock *lock)\n{\n\tndelay(50);\n}\n\nstatic const struct hwspinlock_ops u8500_hwspinlock_ops = {\n\t.trylock\t= u8500_hsem_trylock,\n\t.unlock\t\t= u8500_hsem_unlock,\n\t.relax\t\t= u8500_hsem_relax,\n};\n\nstatic int u8500_hsem_probe(struct platform_device *pdev)\n{\n\tstruct hwspinlock_pdata *pdata = pdev->dev.platform_data;\n\tstruct hwspinlock_device *bank;\n\tstruct hwspinlock *hwlock;\n\tvoid __iomem *io_base;\n\tint i, num_locks = U8500_MAX_SEMAPHORE;\n\tulong val;\n\n\tif (!pdata)\n\t\treturn -ENODEV;\n\n\tio_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(io_base))\n\t\treturn PTR_ERR(io_base);\n\n\t \n\tval = readl(io_base + HSEM_CTRL_REG);\n\twritel((val & ~HSEM_PROTOCOL_1), io_base + HSEM_CTRL_REG);\n\n\t \n\twritel(0xFFFF, io_base + HSEM_ICRALL);\n\n\tbank = devm_kzalloc(&pdev->dev, struct_size(bank, lock, num_locks),\n\t\t\t    GFP_KERNEL);\n\tif (!bank)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, bank);\n\n\tfor (i = 0, hwlock = &bank->lock[0]; i < num_locks; i++, hwlock++)\n\t\thwlock->priv = io_base + HSEM_REGISTER_OFFSET + sizeof(u32) * i;\n\n\treturn devm_hwspin_lock_register(&pdev->dev, bank,\n\t\t\t\t\t &u8500_hwspinlock_ops,\n\t\t\t\t\t pdata->base_id, num_locks);\n}\n\nstatic void u8500_hsem_remove(struct platform_device *pdev)\n{\n\tstruct hwspinlock_device *bank = platform_get_drvdata(pdev);\n\tvoid __iomem *io_base = bank->lock[0].priv - HSEM_REGISTER_OFFSET;\n\n\t \n\twritel(0xFFFF, io_base + HSEM_ICRALL);\n}\n\nstatic struct platform_driver u8500_hsem_driver = {\n\t.probe\t\t= u8500_hsem_probe,\n\t.remove_new\t= u8500_hsem_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"u8500_hsem\",\n\t},\n};\n\nstatic int __init u8500_hsem_init(void)\n{\n\treturn platform_driver_register(&u8500_hsem_driver);\n}\n \npostcore_initcall(u8500_hsem_init);\n\nstatic void __exit u8500_hsem_exit(void)\n{\n\tplatform_driver_unregister(&u8500_hsem_driver);\n}\nmodule_exit(u8500_hsem_exit);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"Hardware Spinlock driver for u8500\");\nMODULE_AUTHOR(\"Mathieu Poirier <mathieu.poirier@linaro.org>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}