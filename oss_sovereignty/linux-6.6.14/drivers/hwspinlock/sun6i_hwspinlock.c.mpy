{
  "module_name": "sun6i_hwspinlock.c",
  "hash_id": "87869b567e337970fd944c59b7f823788ec7c69766c243a565a2a3131c90360d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwspinlock/sun6i_hwspinlock.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/debugfs.h>\n#include <linux/errno.h>\n#include <linux/hwspinlock.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/reset.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n\n#include \"hwspinlock_internal.h\"\n\n#define DRIVER_NAME\t\t\"sun6i_hwspinlock\"\n\n#define SPINLOCK_BASE_ID\t0  \n#define SPINLOCK_SYSSTATUS_REG\t0x0000\n#define SPINLOCK_LOCK_REGN\t0x0100\n#define SPINLOCK_NOTTAKEN\t0\n\nstruct sun6i_hwspinlock_data {\n\tstruct hwspinlock_device *bank;\n\tstruct reset_control *reset;\n\tstruct clk *ahb_clk;\n\tstruct dentry *debugfs;\n\tint nlocks;\n};\n\n#ifdef CONFIG_DEBUG_FS\n\nstatic int hwlocks_supported_show(struct seq_file *seqf, void *unused)\n{\n\tstruct sun6i_hwspinlock_data *priv = seqf->private;\n\n\tseq_printf(seqf, \"%d\\n\", priv->nlocks);\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(hwlocks_supported);\n\nstatic void sun6i_hwspinlock_debugfs_init(struct sun6i_hwspinlock_data *priv)\n{\n\tpriv->debugfs = debugfs_create_dir(DRIVER_NAME, NULL);\n\tdebugfs_create_file(\"supported\", 0444, priv->debugfs, priv, &hwlocks_supported_fops);\n}\n\n#else\n\nstatic void sun6i_hwspinlock_debugfs_init(struct sun6i_hwspinlock_data *priv)\n{\n}\n\n#endif\n\nstatic int sun6i_hwspinlock_trylock(struct hwspinlock *lock)\n{\n\tvoid __iomem *lock_addr = lock->priv;\n\n\treturn (readl(lock_addr) == SPINLOCK_NOTTAKEN);\n}\n\nstatic void sun6i_hwspinlock_unlock(struct hwspinlock *lock)\n{\n\tvoid __iomem *lock_addr = lock->priv;\n\n\twritel(SPINLOCK_NOTTAKEN, lock_addr);\n}\n\nstatic const struct hwspinlock_ops sun6i_hwspinlock_ops = {\n\t.trylock\t= sun6i_hwspinlock_trylock,\n\t.unlock\t\t= sun6i_hwspinlock_unlock,\n};\n\nstatic void sun6i_hwspinlock_disable(void *data)\n{\n\tstruct sun6i_hwspinlock_data *priv = data;\n\n\tdebugfs_remove_recursive(priv->debugfs);\n\tclk_disable_unprepare(priv->ahb_clk);\n\treset_control_assert(priv->reset);\n}\n\nstatic int sun6i_hwspinlock_probe(struct platform_device *pdev)\n{\n\tstruct sun6i_hwspinlock_data *priv;\n\tstruct hwspinlock *hwlock;\n\tvoid __iomem *io_base;\n\tu32 num_banks;\n\tint err, i;\n\n\tio_base = devm_platform_ioremap_resource(pdev, SPINLOCK_BASE_ID);\n\tif (IS_ERR(io_base))\n\t\treturn PTR_ERR(io_base);\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->ahb_clk = devm_clk_get(&pdev->dev, \"ahb\");\n\tif (IS_ERR(priv->ahb_clk)) {\n\t\terr = PTR_ERR(priv->ahb_clk);\n\t\tdev_err(&pdev->dev, \"unable to get AHB clock (%d)\\n\", err);\n\t\treturn err;\n\t}\n\n\tpriv->reset = devm_reset_control_get(&pdev->dev, \"ahb\");\n\tif (IS_ERR(priv->reset))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(priv->reset),\n\t\t\t\t     \"unable to get reset control\\n\");\n\n\terr = reset_control_deassert(priv->reset);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"deassert reset control failure (%d)\\n\", err);\n\t\treturn err;\n\t}\n\n\terr = clk_prepare_enable(priv->ahb_clk);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"unable to prepare AHB clk (%d)\\n\", err);\n\t\tgoto clk_fail;\n\t}\n\n\t \n\tnum_banks = readl(io_base + SPINLOCK_SYSSTATUS_REG) >> 28;\n\tswitch (num_banks) {\n\tcase 1 ... 4:\n\t\tpriv->nlocks = 1 << (4 + num_banks);\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t\tdev_err(&pdev->dev, \"unsupported hwspinlock setup (%d)\\n\", num_banks);\n\t\tgoto bank_fail;\n\t}\n\n\tpriv->bank = devm_kzalloc(&pdev->dev, struct_size(priv->bank, lock, priv->nlocks),\n\t\t\t\t  GFP_KERNEL);\n\tif (!priv->bank) {\n\t\terr = -ENOMEM;\n\t\tgoto bank_fail;\n\t}\n\n\tfor (i = 0; i < priv->nlocks; ++i) {\n\t\thwlock = &priv->bank->lock[i];\n\t\thwlock->priv = io_base + SPINLOCK_LOCK_REGN + sizeof(u32) * i;\n\t}\n\n\t \n\tsun6i_hwspinlock_debugfs_init(priv);\n\tif (IS_ERR(priv->debugfs))\n\t\tpriv->debugfs = NULL;\n\n\terr = devm_add_action_or_reset(&pdev->dev, sun6i_hwspinlock_disable, priv);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"failed to add hwspinlock disable action\\n\");\n\t\tgoto bank_fail;\n\t}\n\n\tplatform_set_drvdata(pdev, priv);\n\n\treturn devm_hwspin_lock_register(&pdev->dev, priv->bank, &sun6i_hwspinlock_ops,\n\t\t\t\t\t SPINLOCK_BASE_ID, priv->nlocks);\n\nbank_fail:\n\tclk_disable_unprepare(priv->ahb_clk);\nclk_fail:\n\treset_control_assert(priv->reset);\n\n\treturn err;\n}\n\nstatic const struct of_device_id sun6i_hwspinlock_ids[] = {\n\t{ .compatible = \"allwinner,sun6i-a31-hwspinlock\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, sun6i_hwspinlock_ids);\n\nstatic struct platform_driver sun6i_hwspinlock_driver = {\n\t.probe\t= sun6i_hwspinlock_probe,\n\t.driver\t= {\n\t\t.name\t\t= DRIVER_NAME,\n\t\t.of_match_table\t= sun6i_hwspinlock_ids,\n\t},\n};\nmodule_platform_driver(sun6i_hwspinlock_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"SUN6I hardware spinlock driver\");\nMODULE_AUTHOR(\"Wilken Gottwalt <wilken.gottwalt@posteo.net>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}