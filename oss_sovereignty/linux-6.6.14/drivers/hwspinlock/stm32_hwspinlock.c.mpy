{
  "module_name": "stm32_hwspinlock.c",
  "hash_id": "4de55d09ff2f70681a1dbb97aa4ca4e27f626f2ad836dd74aab28393fb9bc27a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwspinlock/stm32_hwspinlock.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/hwspinlock.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n\n#include \"hwspinlock_internal.h\"\n\n#define STM32_MUTEX_COREID\tBIT(8)\n#define STM32_MUTEX_LOCK_BIT\tBIT(31)\n#define STM32_MUTEX_NUM_LOCKS\t32\n\nstruct stm32_hwspinlock {\n\tstruct clk *clk;\n\tstruct hwspinlock_device bank;\n};\n\nstatic int stm32_hwspinlock_trylock(struct hwspinlock *lock)\n{\n\tvoid __iomem *lock_addr = lock->priv;\n\tu32 status;\n\n\twritel(STM32_MUTEX_LOCK_BIT | STM32_MUTEX_COREID, lock_addr);\n\tstatus = readl(lock_addr);\n\n\treturn status == (STM32_MUTEX_LOCK_BIT | STM32_MUTEX_COREID);\n}\n\nstatic void stm32_hwspinlock_unlock(struct hwspinlock *lock)\n{\n\tvoid __iomem *lock_addr = lock->priv;\n\n\twritel(STM32_MUTEX_COREID, lock_addr);\n}\n\nstatic void stm32_hwspinlock_relax(struct hwspinlock *lock)\n{\n\tndelay(50);\n}\n\nstatic const struct hwspinlock_ops stm32_hwspinlock_ops = {\n\t.trylock\t= stm32_hwspinlock_trylock,\n\t.unlock\t\t= stm32_hwspinlock_unlock,\n\t.relax\t\t= stm32_hwspinlock_relax,\n};\n\nstatic void stm32_hwspinlock_disable_clk(void *data)\n{\n\tstruct platform_device *pdev = data;\n\tstruct stm32_hwspinlock *hw = platform_get_drvdata(pdev);\n\tstruct device *dev = &pdev->dev;\n\n\tpm_runtime_get_sync(dev);\n\tpm_runtime_disable(dev);\n\tpm_runtime_set_suspended(dev);\n\tpm_runtime_put_noidle(dev);\n\n\tclk_disable_unprepare(hw->clk);\n}\n\nstatic int stm32_hwspinlock_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct stm32_hwspinlock *hw;\n\tvoid __iomem *io_base;\n\tint i, ret;\n\n\tio_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(io_base))\n\t\treturn PTR_ERR(io_base);\n\n\thw = devm_kzalloc(dev, struct_size(hw, bank.lock, STM32_MUTEX_NUM_LOCKS), GFP_KERNEL);\n\tif (!hw)\n\t\treturn -ENOMEM;\n\n\thw->clk = devm_clk_get(dev, \"hsem\");\n\tif (IS_ERR(hw->clk))\n\t\treturn PTR_ERR(hw->clk);\n\n\tret = clk_prepare_enable(hw->clk);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to prepare_enable clock\\n\");\n\t\treturn ret;\n\t}\n\n\tplatform_set_drvdata(pdev, hw);\n\n\tpm_runtime_get_noresume(dev);\n\tpm_runtime_set_active(dev);\n\tpm_runtime_enable(dev);\n\tpm_runtime_put(dev);\n\n\tret = devm_add_action_or_reset(dev, stm32_hwspinlock_disable_clk, pdev);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to register action\\n\");\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < STM32_MUTEX_NUM_LOCKS; i++)\n\t\thw->bank.lock[i].priv = io_base + i * sizeof(u32);\n\n\tret = devm_hwspin_lock_register(dev, &hw->bank, &stm32_hwspinlock_ops,\n\t\t\t\t\t0, STM32_MUTEX_NUM_LOCKS);\n\n\tif (ret)\n\t\tdev_err(dev, \"Failed to register hwspinlock\\n\");\n\n\treturn ret;\n}\n\nstatic int __maybe_unused stm32_hwspinlock_runtime_suspend(struct device *dev)\n{\n\tstruct stm32_hwspinlock *hw = dev_get_drvdata(dev);\n\n\tclk_disable_unprepare(hw->clk);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused stm32_hwspinlock_runtime_resume(struct device *dev)\n{\n\tstruct stm32_hwspinlock *hw = dev_get_drvdata(dev);\n\n\tclk_prepare_enable(hw->clk);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops stm32_hwspinlock_pm_ops = {\n\tSET_RUNTIME_PM_OPS(stm32_hwspinlock_runtime_suspend,\n\t\t\t   stm32_hwspinlock_runtime_resume,\n\t\t\t   NULL)\n};\n\nstatic const struct of_device_id stm32_hwpinlock_ids[] = {\n\t{ .compatible = \"st,stm32-hwspinlock\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, stm32_hwpinlock_ids);\n\nstatic struct platform_driver stm32_hwspinlock_driver = {\n\t.probe\t\t= stm32_hwspinlock_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"stm32_hwspinlock\",\n\t\t.of_match_table = stm32_hwpinlock_ids,\n\t\t.pm\t= &stm32_hwspinlock_pm_ops,\n\t},\n};\n\nstatic int __init stm32_hwspinlock_init(void)\n{\n\treturn platform_driver_register(&stm32_hwspinlock_driver);\n}\n \npostcore_initcall(stm32_hwspinlock_init);\n\nstatic void __exit stm32_hwspinlock_exit(void)\n{\n\tplatform_driver_unregister(&stm32_hwspinlock_driver);\n}\nmodule_exit(stm32_hwspinlock_exit);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"Hardware spinlock driver for STM32 SoCs\");\nMODULE_AUTHOR(\"Benjamin Gaignard <benjamin.gaignard@st.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}