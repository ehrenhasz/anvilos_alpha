{
  "module_name": "omap_hwspinlock.c",
  "hash_id": "45ca00d400e6bf83f12aa0ccf763e81ada73ac7f6e71703967e560d64058e65f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/hwspinlock/omap_hwspinlock.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/bitops.h>\n#include <linux/pm_runtime.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/hwspinlock.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n\n#include \"hwspinlock_internal.h\"\n\n \n#define SYSSTATUS_OFFSET\t\t0x0014\n#define LOCK_BASE_OFFSET\t\t0x0800\n\n#define SPINLOCK_NUMLOCKS_BIT_OFFSET\t(24)\n\n \n#define SPINLOCK_NOTTAKEN\t\t(0)\t \n#define SPINLOCK_TAKEN\t\t\t(1)\t \n\nstatic int omap_hwspinlock_trylock(struct hwspinlock *lock)\n{\n\tvoid __iomem *lock_addr = lock->priv;\n\n\t \n\treturn (SPINLOCK_NOTTAKEN == readl(lock_addr));\n}\n\nstatic void omap_hwspinlock_unlock(struct hwspinlock *lock)\n{\n\tvoid __iomem *lock_addr = lock->priv;\n\n\t \n\twritel(SPINLOCK_NOTTAKEN, lock_addr);\n}\n\n \nstatic void omap_hwspinlock_relax(struct hwspinlock *lock)\n{\n\tndelay(50);\n}\n\nstatic const struct hwspinlock_ops omap_hwspinlock_ops = {\n\t.trylock = omap_hwspinlock_trylock,\n\t.unlock = omap_hwspinlock_unlock,\n\t.relax = omap_hwspinlock_relax,\n};\n\nstatic int omap_hwspinlock_probe(struct platform_device *pdev)\n{\n\tstruct device_node *node = pdev->dev.of_node;\n\tstruct hwspinlock_device *bank;\n\tstruct hwspinlock *hwlock;\n\tvoid __iomem *io_base;\n\tint num_locks, i, ret;\n\t \n\tint base_id = 0;\n\n\tif (!node)\n\t\treturn -ENODEV;\n\n\tio_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(io_base))\n\t\treturn PTR_ERR(io_base);\n\n\t \n\tpm_runtime_enable(&pdev->dev);\n\tret = pm_runtime_resume_and_get(&pdev->dev);\n\tif (ret < 0)\n\t\tgoto runtime_err;\n\n\t \n\ti = readl(io_base + SYSSTATUS_OFFSET);\n\ti >>= SPINLOCK_NUMLOCKS_BIT_OFFSET;\n\n\t \n\tret = pm_runtime_put(&pdev->dev);\n\tif (ret < 0)\n\t\tgoto runtime_err;\n\n\t \n\tif (hweight_long(i & 0xf) != 1 || i > 8) {\n\t\tret = -EINVAL;\n\t\tgoto runtime_err;\n\t}\n\n\tnum_locks = i * 32;  \n\n\tbank = devm_kzalloc(&pdev->dev, struct_size(bank, lock, num_locks),\n\t\t\t    GFP_KERNEL);\n\tif (!bank) {\n\t\tret = -ENOMEM;\n\t\tgoto runtime_err;\n\t}\n\n\tplatform_set_drvdata(pdev, bank);\n\n\tfor (i = 0, hwlock = &bank->lock[0]; i < num_locks; i++, hwlock++)\n\t\thwlock->priv = io_base + LOCK_BASE_OFFSET + sizeof(u32) * i;\n\n\tret = hwspin_lock_register(bank, &pdev->dev, &omap_hwspinlock_ops,\n\t\t\t\t\t\tbase_id, num_locks);\n\tif (ret)\n\t\tgoto runtime_err;\n\n\tdev_dbg(&pdev->dev, \"Registered %d locks with HwSpinlock core\\n\",\n\t\tnum_locks);\n\n\treturn 0;\n\nruntime_err:\n\tpm_runtime_disable(&pdev->dev);\n\treturn ret;\n}\n\nstatic void omap_hwspinlock_remove(struct platform_device *pdev)\n{\n\tstruct hwspinlock_device *bank = platform_get_drvdata(pdev);\n\tint ret;\n\n\tret = hwspin_lock_unregister(bank);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"%s failed: %d\\n\", __func__, ret);\n\t\treturn;\n\t}\n\n\tpm_runtime_disable(&pdev->dev);\n}\n\nstatic const struct of_device_id omap_hwspinlock_of_match[] = {\n\t{ .compatible = \"ti,omap4-hwspinlock\", },\n\t{ .compatible = \"ti,am64-hwspinlock\", },\n\t{ .compatible = \"ti,am654-hwspinlock\", },\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, omap_hwspinlock_of_match);\n\nstatic struct platform_driver omap_hwspinlock_driver = {\n\t.probe\t\t= omap_hwspinlock_probe,\n\t.remove_new\t= omap_hwspinlock_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"omap_hwspinlock\",\n\t\t.of_match_table = omap_hwspinlock_of_match,\n\t},\n};\n\nstatic int __init omap_hwspinlock_init(void)\n{\n\treturn platform_driver_register(&omap_hwspinlock_driver);\n}\n \npostcore_initcall(omap_hwspinlock_init);\n\nstatic void __exit omap_hwspinlock_exit(void)\n{\n\tplatform_driver_unregister(&omap_hwspinlock_driver);\n}\nmodule_exit(omap_hwspinlock_exit);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"Hardware spinlock driver for OMAP\");\nMODULE_AUTHOR(\"Simon Que <sque@ti.com>\");\nMODULE_AUTHOR(\"Hari Kanigeri <h-kanigeri2@ti.com>\");\nMODULE_AUTHOR(\"Ohad Ben-Cohen <ohad@wizery.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}