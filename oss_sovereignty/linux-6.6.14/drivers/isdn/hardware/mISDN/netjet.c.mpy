{
  "module_name": "netjet.c",
  "hash_id": "4078c8166eb61f60c15a32a255410335fe0b37a93cbe7aa2ddd0f04795ee293c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/isdn/hardware/mISDN/netjet.c",
  "human_readable_source": "\n \n\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/delay.h>\n#include <linux/mISDNhw.h>\n#include <linux/slab.h>\n#include \"ipac.h\"\n#include \"iohelper.h\"\n#include \"netjet.h\"\n#include \"isdnhdlc.h\"\n\n#define NETJET_REV\t\"2.0\"\n\nenum nj_types {\n\tNETJET_S_TJ300,\n\tNETJET_S_TJ320,\n\tENTERNOW__TJ320,\n};\n\nstruct tiger_dma {\n\tsize_t\t\tsize;\n\tu32\t\t*start;\n\tint\t\tidx;\n\tu32\t\tdmastart;\n\tu32\t\tdmairq;\n\tu32\t\tdmaend;\n\tu32\t\tdmacur;\n};\n\nstruct tiger_hw;\n\nstruct tiger_ch {\n\tstruct bchannel\t\tbch;\n\tstruct tiger_hw\t\t*nj;\n\tint\t\t\tidx;\n\tint\t\t\tfree;\n\tint\t\t\tlastrx;\n\tu16\t\t\trxstate;\n\tu16\t\t\ttxstate;\n\tstruct isdnhdlc_vars\thsend;\n\tstruct isdnhdlc_vars\threcv;\n\tu8\t\t\t*hsbuf;\n\tu8\t\t\t*hrbuf;\n};\n\n#define TX_INIT\t\t0x0001\n#define TX_IDLE\t\t0x0002\n#define TX_RUN\t\t0x0004\n#define TX_UNDERRUN\t0x0100\n#define RX_OVERRUN\t0x0100\n\n#define LOG_SIZE\t64\n\nstruct tiger_hw {\n\tstruct list_head\tlist;\n\tstruct pci_dev\t\t*pdev;\n\tchar\t\t\tname[MISDN_MAX_IDLEN];\n\tenum nj_types\t\ttyp;\n\tint\t\t\tirq;\n\tu32\t\t\tirqcnt;\n\tu32\t\t\tbase;\n\tsize_t\t\t\tbase_s;\n\tdma_addr_t\t\tdma;\n\tvoid\t\t\t*dma_p;\n\tspinlock_t\t\tlock;\t \n\tstruct isac_hw\t\tisac;\n\tstruct tiger_dma\tsend;\n\tstruct tiger_dma\trecv;\n\tstruct tiger_ch\t\tbc[2];\n\tu8\t\t\tctrlreg;\n\tu8\t\t\tdmactrl;\n\tu8\t\t\tauxd;\n\tu8\t\t\tlast_is0;\n\tu8\t\t\tirqmask0;\n\tchar\t\t\tlog[LOG_SIZE];\n};\n\nstatic LIST_HEAD(Cards);\nstatic DEFINE_RWLOCK(card_lock);  \nstatic u32 debug;\nstatic int nj_cnt;\n\nstatic void\n_set_debug(struct tiger_hw *card)\n{\n\tcard->isac.dch.debug = debug;\n\tcard->bc[0].bch.debug = debug;\n\tcard->bc[1].bch.debug = debug;\n}\n\nstatic int\nset_debug(const char *val, const struct kernel_param *kp)\n{\n\tint ret;\n\tstruct tiger_hw *card;\n\n\tret = param_set_uint(val, kp);\n\tif (!ret) {\n\t\tread_lock(&card_lock);\n\t\tlist_for_each_entry(card, &Cards, list)\n\t\t\t_set_debug(card);\n\t\tread_unlock(&card_lock);\n\t}\n\treturn ret;\n}\n\nMODULE_AUTHOR(\"Karsten Keil\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_VERSION(NETJET_REV);\nmodule_param_call(debug, set_debug, param_get_uint, &debug, S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(debug, \"Netjet debug mask\");\n\nstatic void\nnj_disable_hwirq(struct tiger_hw *card)\n{\n\toutb(0, card->base + NJ_IRQMASK0);\n\toutb(0, card->base + NJ_IRQMASK1);\n}\n\n\nstatic u8\nReadISAC_nj(void *p, u8 offset)\n{\n\tstruct tiger_hw *card = p;\n\tu8 ret;\n\n\tcard->auxd &= 0xfc;\n\tcard->auxd |= (offset >> 4) & 3;\n\toutb(card->auxd, card->base + NJ_AUXDATA);\n\tret = inb(card->base + NJ_ISAC_OFF + ((offset & 0x0f) << 2));\n\treturn ret;\n}\n\nstatic void\nWriteISAC_nj(void *p, u8 offset, u8 value)\n{\n\tstruct tiger_hw *card = p;\n\n\tcard->auxd &= 0xfc;\n\tcard->auxd |= (offset >> 4) & 3;\n\toutb(card->auxd, card->base + NJ_AUXDATA);\n\toutb(value, card->base + NJ_ISAC_OFF + ((offset & 0x0f) << 2));\n}\n\nstatic void\nReadFiFoISAC_nj(void *p, u8 offset, u8 *data, int size)\n{\n\tstruct tiger_hw *card = p;\n\n\tcard->auxd &= 0xfc;\n\toutb(card->auxd, card->base + NJ_AUXDATA);\n\tinsb(card->base + NJ_ISAC_OFF, data, size);\n}\n\nstatic void\nWriteFiFoISAC_nj(void *p, u8 offset, u8 *data, int size)\n{\n\tstruct tiger_hw *card = p;\n\n\tcard->auxd &= 0xfc;\n\toutb(card->auxd, card->base + NJ_AUXDATA);\n\toutsb(card->base + NJ_ISAC_OFF, data, size);\n}\n\nstatic void\nfill_mem(struct tiger_ch *bc, u32 idx, u32 cnt, u32 fill)\n{\n\tstruct tiger_hw *card = bc->bch.hw;\n\tu32 mask = 0xff, val;\n\n\tpr_debug(\"%s: B%1d fill %02x len %d idx %d/%d\\n\", card->name,\n\t\t bc->bch.nr, fill, cnt, idx, card->send.idx);\n\tif (bc->bch.nr & 2) {\n\t\tfill  <<= 8;\n\t\tmask <<= 8;\n\t}\n\tmask ^= 0xffffffff;\n\twhile (cnt--) {\n\t\tval = card->send.start[idx];\n\t\tval &= mask;\n\t\tval |= fill;\n\t\tcard->send.start[idx++] = val;\n\t\tif (idx >= card->send.size)\n\t\t\tidx = 0;\n\t}\n}\n\nstatic int\nmode_tiger(struct tiger_ch *bc, u32 protocol)\n{\n\tstruct tiger_hw *card = bc->bch.hw;\n\n\tpr_debug(\"%s: B%1d protocol %x-->%x\\n\", card->name,\n\t\t bc->bch.nr, bc->bch.state, protocol);\n\tswitch (protocol) {\n\tcase ISDN_P_NONE:\n\t\tif (bc->bch.state == ISDN_P_NONE)\n\t\t\tbreak;\n\t\tfill_mem(bc, 0, card->send.size, 0xff);\n\t\tbc->bch.state = protocol;\n\t\t \n\t\tif ((card->bc[0].bch.state == ISDN_P_NONE) &&\n\t\t    (card->bc[1].bch.state == ISDN_P_NONE)) {\n\t\t\tcard->dmactrl = 0;\n\t\t\toutb(card->dmactrl, card->base + NJ_DMACTRL);\n\t\t\toutb(0, card->base + NJ_IRQMASK0);\n\t\t}\n\t\ttest_and_clear_bit(FLG_HDLC, &bc->bch.Flags);\n\t\ttest_and_clear_bit(FLG_TRANSPARENT, &bc->bch.Flags);\n\t\tbc->txstate = 0;\n\t\tbc->rxstate = 0;\n\t\tbc->lastrx = -1;\n\t\tbreak;\n\tcase ISDN_P_B_RAW:\n\t\ttest_and_set_bit(FLG_TRANSPARENT, &bc->bch.Flags);\n\t\tbc->bch.state = protocol;\n\t\tbc->idx = 0;\n\t\tbc->free = card->send.size / 2;\n\t\tbc->rxstate = 0;\n\t\tbc->txstate = TX_INIT | TX_IDLE;\n\t\tbc->lastrx = -1;\n\t\tif (!card->dmactrl) {\n\t\t\tcard->dmactrl = 1;\n\t\t\toutb(card->dmactrl, card->base + NJ_DMACTRL);\n\t\t\toutb(0x0f, card->base + NJ_IRQMASK0);\n\t\t}\n\t\tbreak;\n\tcase ISDN_P_B_HDLC:\n\t\ttest_and_set_bit(FLG_HDLC, &bc->bch.Flags);\n\t\tbc->bch.state = protocol;\n\t\tbc->idx = 0;\n\t\tbc->free = card->send.size / 2;\n\t\tbc->rxstate = 0;\n\t\tbc->txstate = TX_INIT | TX_IDLE;\n\t\tisdnhdlc_rcv_init(&bc->hrecv, 0);\n\t\tisdnhdlc_out_init(&bc->hsend, 0);\n\t\tbc->lastrx = -1;\n\t\tif (!card->dmactrl) {\n\t\t\tcard->dmactrl = 1;\n\t\t\toutb(card->dmactrl, card->base + NJ_DMACTRL);\n\t\t\toutb(0x0f, card->base + NJ_IRQMASK0);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tpr_info(\"%s: %s protocol %x not handled\\n\", card->name,\n\t\t\t__func__, protocol);\n\t\treturn -ENOPROTOOPT;\n\t}\n\tcard->send.dmacur = inl(card->base + NJ_DMA_READ_ADR);\n\tcard->recv.dmacur = inl(card->base + NJ_DMA_WRITE_ADR);\n\tcard->send.idx = (card->send.dmacur - card->send.dmastart) >> 2;\n\tcard->recv.idx = (card->recv.dmacur - card->recv.dmastart) >> 2;\n\tpr_debug(\"%s: %s ctrl %x irq  %02x/%02x idx %d/%d\\n\",\n\t\t card->name, __func__,\n\t\t inb(card->base + NJ_DMACTRL),\n\t\t inb(card->base + NJ_IRQMASK0),\n\t\t inb(card->base + NJ_IRQSTAT0),\n\t\t card->send.idx,\n\t\t card->recv.idx);\n\treturn 0;\n}\n\nstatic void\nnj_reset(struct tiger_hw *card)\n{\n\toutb(0xff, card->base + NJ_CTRL);  \n\tmdelay(1);\n\n\t \n\t \n\tif (card->typ == NETJET_S_TJ320)  \n\t\tcard->ctrlreg = 0x40;   \n\telse\n\t\tcard->ctrlreg = 0x00;   \n\toutb(card->ctrlreg, card->base + NJ_CTRL);\n\tmdelay(10);\n\n\t \n\tcard->auxd = 0;\n\tcard->dmactrl = 0;\n\toutb(~NJ_ISACIRQ, card->base + NJ_AUXCTRL);\n\toutb(NJ_ISACIRQ,  card->base + NJ_IRQMASK1);\n\toutb(card->auxd, card->base + NJ_AUXDATA);\n}\n\nstatic int\ninittiger(struct tiger_hw *card)\n{\n\tint i;\n\n\tcard->dma_p = dma_alloc_coherent(&card->pdev->dev, NJ_DMA_SIZE,\n\t\t\t\t\t &card->dma, GFP_ATOMIC);\n\tif (!card->dma_p) {\n\t\tpr_info(\"%s: No DMA memory\\n\", card->name);\n\t\treturn -ENOMEM;\n\t}\n\tif ((u64)card->dma > 0xffffffff) {\n\t\tpr_info(\"%s: DMA outside 32 bit\\n\", card->name);\n\t\treturn -ENOMEM;\n\t}\n\tfor (i = 0; i < 2; i++) {\n\t\tcard->bc[i].hsbuf = kmalloc(NJ_DMA_TXSIZE, GFP_ATOMIC);\n\t\tif (!card->bc[i].hsbuf) {\n\t\t\tpr_info(\"%s: no B%d send buffer\\n\", card->name, i + 1);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tcard->bc[i].hrbuf = kmalloc(NJ_DMA_RXSIZE, GFP_ATOMIC);\n\t\tif (!card->bc[i].hrbuf) {\n\t\t\tpr_info(\"%s: no B%d recv buffer\\n\", card->name, i + 1);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\tmemset(card->dma_p, 0xff, NJ_DMA_SIZE);\n\n\tcard->send.start = card->dma_p;\n\tcard->send.dmastart = (u32)card->dma;\n\tcard->send.dmaend = card->send.dmastart +\n\t\t(4 * (NJ_DMA_TXSIZE - 1));\n\tcard->send.dmairq = card->send.dmastart +\n\t\t(4 * ((NJ_DMA_TXSIZE / 2) - 1));\n\tcard->send.size = NJ_DMA_TXSIZE;\n\n\tif (debug & DEBUG_HW)\n\t\tpr_notice(\"%s: send buffer phy %#x - %#x - %#x  virt %p\"\n\t\t\t  \" size %zu u32\\n\", card->name,\n\t\t\t  card->send.dmastart, card->send.dmairq,\n\t\t\t  card->send.dmaend, card->send.start, card->send.size);\n\n\toutl(card->send.dmastart, card->base + NJ_DMA_READ_START);\n\toutl(card->send.dmairq, card->base + NJ_DMA_READ_IRQ);\n\toutl(card->send.dmaend, card->base + NJ_DMA_READ_END);\n\n\tcard->recv.start = card->dma_p + (NJ_DMA_SIZE / 2);\n\tcard->recv.dmastart = (u32)card->dma  + (NJ_DMA_SIZE / 2);\n\tcard->recv.dmaend = card->recv.dmastart +\n\t\t(4 * (NJ_DMA_RXSIZE - 1));\n\tcard->recv.dmairq = card->recv.dmastart +\n\t\t(4 * ((NJ_DMA_RXSIZE / 2) - 1));\n\tcard->recv.size = NJ_DMA_RXSIZE;\n\n\tif (debug & DEBUG_HW)\n\t\tpr_notice(\"%s: recv buffer phy %#x - %#x - %#x  virt %p\"\n\t\t\t  \" size %zu u32\\n\", card->name,\n\t\t\t  card->recv.dmastart, card->recv.dmairq,\n\t\t\t  card->recv.dmaend, card->recv.start, card->recv.size);\n\n\toutl(card->recv.dmastart, card->base + NJ_DMA_WRITE_START);\n\toutl(card->recv.dmairq, card->base + NJ_DMA_WRITE_IRQ);\n\toutl(card->recv.dmaend, card->base + NJ_DMA_WRITE_END);\n\treturn 0;\n}\n\nstatic void\nread_dma(struct tiger_ch *bc, u32 idx, int cnt)\n{\n\tstruct tiger_hw *card = bc->bch.hw;\n\tint i, stat;\n\tu32 val;\n\tu8 *p, *pn;\n\n\tif (bc->lastrx == idx) {\n\t\tbc->rxstate |= RX_OVERRUN;\n\t\tpr_info(\"%s: B%1d overrun at idx %d\\n\", card->name,\n\t\t\tbc->bch.nr, idx);\n\t}\n\tbc->lastrx = idx;\n\tif (test_bit(FLG_RX_OFF, &bc->bch.Flags)) {\n\t\tbc->bch.dropcnt += cnt;\n\t\treturn;\n\t}\n\tstat = bchannel_get_rxbuf(&bc->bch, cnt);\n\t \n\tif (stat == -ENOMEM) {\n\t\tpr_warn(\"%s.B%d: No memory for %d bytes\\n\",\n\t\t\tcard->name, bc->bch.nr, cnt);\n\t\treturn;\n\t}\n\tif (test_bit(FLG_TRANSPARENT, &bc->bch.Flags))\n\t\tp = skb_put(bc->bch.rx_skb, cnt);\n\telse\n\t\tp = bc->hrbuf;\n\n\tfor (i = 0; i < cnt; i++) {\n\t\tval = card->recv.start[idx++];\n\t\tif (bc->bch.nr & 2)\n\t\t\tval >>= 8;\n\t\tif (idx >= card->recv.size)\n\t\t\tidx = 0;\n\t\tp[i] = val & 0xff;\n\t}\n\n\tif (test_bit(FLG_TRANSPARENT, &bc->bch.Flags)) {\n\t\trecv_Bchannel(&bc->bch, 0, false);\n\t\treturn;\n\t}\n\n\tpn = bc->hrbuf;\n\twhile (cnt > 0) {\n\t\tstat = isdnhdlc_decode(&bc->hrecv, pn, cnt, &i,\n\t\t\t\t       bc->bch.rx_skb->data, bc->bch.maxlen);\n\t\tif (stat > 0) {  \n\t\t\tp = skb_put(bc->bch.rx_skb, stat);\n\t\t\tif (debug & DEBUG_HW_BFIFO) {\n\t\t\t\tsnprintf(card->log, LOG_SIZE,\n\t\t\t\t\t \"B%1d-recv %s %d \", bc->bch.nr,\n\t\t\t\t\t card->name, stat);\n\t\t\t\tprint_hex_dump_bytes(card->log,\n\t\t\t\t\t\t     DUMP_PREFIX_OFFSET, p,\n\t\t\t\t\t\t     stat);\n\t\t\t}\n\t\t\trecv_Bchannel(&bc->bch, 0, false);\n\t\t\tstat = bchannel_get_rxbuf(&bc->bch, bc->bch.maxlen);\n\t\t\tif (stat < 0) {\n\t\t\t\tpr_warn(\"%s.B%d: No memory for %d bytes\\n\",\n\t\t\t\t\tcard->name, bc->bch.nr, cnt);\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else if (stat == -HDLC_CRC_ERROR) {\n\t\t\tpr_info(\"%s: B%1d receive frame CRC error\\n\",\n\t\t\t\tcard->name, bc->bch.nr);\n\t\t} else if (stat == -HDLC_FRAMING_ERROR) {\n\t\t\tpr_info(\"%s: B%1d receive framing error\\n\",\n\t\t\t\tcard->name, bc->bch.nr);\n\t\t} else if (stat == -HDLC_LENGTH_ERROR) {\n\t\t\tpr_info(\"%s: B%1d receive frame too long (> %d)\\n\",\n\t\t\t\tcard->name, bc->bch.nr, bc->bch.maxlen);\n\t\t}\n\t\tpn += i;\n\t\tcnt -= i;\n\t}\n}\n\nstatic void\nrecv_tiger(struct tiger_hw *card, u8 irq_stat)\n{\n\tu32 idx;\n\tint cnt = card->recv.size / 2;\n\n\t \n\tcard->last_is0 &= ~NJ_IRQM0_WR_MASK;\n\tcard->last_is0 |= (irq_stat & NJ_IRQM0_WR_MASK);\n\n\tif (irq_stat & NJ_IRQM0_WR_END)\n\t\tidx = cnt - 1;\n\telse\n\t\tidx = card->recv.size - 1;\n\n\tif (test_bit(FLG_ACTIVE, &card->bc[0].bch.Flags))\n\t\tread_dma(&card->bc[0], idx, cnt);\n\tif (test_bit(FLG_ACTIVE, &card->bc[1].bch.Flags))\n\t\tread_dma(&card->bc[1], idx, cnt);\n}\n\n \nstatic void\nresync(struct tiger_ch *bc, struct tiger_hw *card)\n{\n\tcard->send.dmacur = inl(card->base | NJ_DMA_READ_ADR);\n\tcard->send.idx = (card->send.dmacur - card->send.dmastart) >> 2;\n\tif (bc->free > card->send.size / 2)\n\t\tbc->free = card->send.size / 2;\n\t \n\tif (card->send.idx < ((card->send.size / 2) - 1))\n\t\tbc->idx = (card->recv.size / 2) - 1;\n\telse\n\t\tbc->idx = card->recv.size - 1;\n\tbc->txstate = TX_RUN;\n\tpr_debug(\"%s: %s B%1d free %d idx %d/%d\\n\", card->name,\n\t\t __func__, bc->bch.nr, bc->free, bc->idx, card->send.idx);\n}\n\nstatic int bc_next_frame(struct tiger_ch *);\n\nstatic void\nfill_hdlc_flag(struct tiger_ch *bc)\n{\n\tstruct tiger_hw *card = bc->bch.hw;\n\tint count, i;\n\tu32 m, v;\n\tu8  *p;\n\n\tif (bc->free == 0)\n\t\treturn;\n\tpr_debug(\"%s: %s B%1d %d state %x idx %d/%d\\n\", card->name,\n\t\t __func__, bc->bch.nr, bc->free, bc->txstate,\n\t\t bc->idx, card->send.idx);\n\tif (bc->txstate & (TX_IDLE | TX_INIT | TX_UNDERRUN))\n\t\tresync(bc, card);\n\tcount = isdnhdlc_encode(&bc->hsend, NULL, 0, &i,\n\t\t\t\tbc->hsbuf, bc->free);\n\tpr_debug(\"%s: B%1d hdlc encoded %d flags\\n\", card->name,\n\t\t bc->bch.nr, count);\n\tbc->free -= count;\n\tp = bc->hsbuf;\n\tm = (bc->bch.nr & 1) ? 0xffffff00 : 0xffff00ff;\n\tfor (i = 0; i < count; i++) {\n\t\tif (bc->idx >= card->send.size)\n\t\t\tbc->idx = 0;\n\t\tv = card->send.start[bc->idx];\n\t\tv &= m;\n\t\tv |= (bc->bch.nr & 1) ? (u32)(p[i]) : ((u32)(p[i])) << 8;\n\t\tcard->send.start[bc->idx++] = v;\n\t}\n\tif (debug & DEBUG_HW_BFIFO) {\n\t\tsnprintf(card->log, LOG_SIZE, \"B%1d-send %s %d \",\n\t\t\t bc->bch.nr, card->name, count);\n\t\tprint_hex_dump_bytes(card->log, DUMP_PREFIX_OFFSET, p, count);\n\t}\n}\n\nstatic void\nfill_dma(struct tiger_ch *bc)\n{\n\tstruct tiger_hw *card = bc->bch.hw;\n\tint count, i, fillempty = 0;\n\tu32 m, v, n = 0;\n\tu8  *p;\n\n\tif (bc->free == 0)\n\t\treturn;\n\tif (!bc->bch.tx_skb) {\n\t\tif (!test_bit(FLG_TX_EMPTY, &bc->bch.Flags))\n\t\t\treturn;\n\t\tfillempty = 1;\n\t\tcount = card->send.size >> 1;\n\t\tp = bc->bch.fill;\n\t} else {\n\t\tcount = bc->bch.tx_skb->len - bc->bch.tx_idx;\n\t\tif (count <= 0)\n\t\t\treturn;\n\t\tpr_debug(\"%s: %s B%1d %d/%d/%d/%d state %x idx %d/%d\\n\",\n\t\t\t card->name, __func__, bc->bch.nr, count, bc->free,\n\t\t\t bc->bch.tx_idx, bc->bch.tx_skb->len, bc->txstate,\n\t\t\t bc->idx, card->send.idx);\n\t\tp = bc->bch.tx_skb->data + bc->bch.tx_idx;\n\t}\n\tif (bc->txstate & (TX_IDLE | TX_INIT | TX_UNDERRUN))\n\t\tresync(bc, card);\n\tif (test_bit(FLG_HDLC, &bc->bch.Flags) && !fillempty) {\n\t\tcount = isdnhdlc_encode(&bc->hsend, p, count, &i,\n\t\t\t\t\tbc->hsbuf, bc->free);\n\t\tpr_debug(\"%s: B%1d hdlc encoded %d in %d\\n\", card->name,\n\t\t\t bc->bch.nr, i, count);\n\t\tbc->bch.tx_idx += i;\n\t\tbc->free -= count;\n\t\tp = bc->hsbuf;\n\t} else {\n\t\tif (count > bc->free)\n\t\t\tcount = bc->free;\n\t\tif (!fillempty)\n\t\t\tbc->bch.tx_idx += count;\n\t\tbc->free -= count;\n\t}\n\tm = (bc->bch.nr & 1) ? 0xffffff00 : 0xffff00ff;\n\tif (fillempty) {\n\t\tn = p[0];\n\t\tif (!(bc->bch.nr & 1))\n\t\t\tn <<= 8;\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tif (bc->idx >= card->send.size)\n\t\t\t\tbc->idx = 0;\n\t\t\tv = card->send.start[bc->idx];\n\t\t\tv &= m;\n\t\t\tv |= n;\n\t\t\tcard->send.start[bc->idx++] = v;\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tif (bc->idx >= card->send.size)\n\t\t\t\tbc->idx = 0;\n\t\t\tv = card->send.start[bc->idx];\n\t\t\tv &= m;\n\t\t\tn = p[i];\n\t\t\tv |= (bc->bch.nr & 1) ? n : n << 8;\n\t\t\tcard->send.start[bc->idx++] = v;\n\t\t}\n\t}\n\tif (debug & DEBUG_HW_BFIFO) {\n\t\tsnprintf(card->log, LOG_SIZE, \"B%1d-send %s %d \",\n\t\t\t bc->bch.nr, card->name, count);\n\t\tprint_hex_dump_bytes(card->log, DUMP_PREFIX_OFFSET, p, count);\n\t}\n\tif (bc->free)\n\t\tbc_next_frame(bc);\n}\n\n\nstatic int\nbc_next_frame(struct tiger_ch *bc)\n{\n\tint ret = 1;\n\n\tif (bc->bch.tx_skb && bc->bch.tx_idx < bc->bch.tx_skb->len) {\n\t\tfill_dma(bc);\n\t} else {\n\t\tdev_kfree_skb(bc->bch.tx_skb);\n\t\tif (get_next_bframe(&bc->bch)) {\n\t\t\tfill_dma(bc);\n\t\t\ttest_and_clear_bit(FLG_TX_EMPTY, &bc->bch.Flags);\n\t\t} else if (test_bit(FLG_TX_EMPTY, &bc->bch.Flags)) {\n\t\t\tfill_dma(bc);\n\t\t} else if (test_bit(FLG_FILLEMPTY, &bc->bch.Flags)) {\n\t\t\ttest_and_set_bit(FLG_TX_EMPTY, &bc->bch.Flags);\n\t\t\tret = 0;\n\t\t} else {\n\t\t\tret = 0;\n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic void\nsend_tiger_bc(struct tiger_hw *card, struct tiger_ch *bc)\n{\n\tint ret;\n\n\tbc->free += card->send.size / 2;\n\tif (bc->free >= card->send.size) {\n\t\tif (!(bc->txstate & (TX_UNDERRUN | TX_INIT))) {\n\t\t\tpr_info(\"%s: B%1d TX underrun state %x\\n\", card->name,\n\t\t\t\tbc->bch.nr, bc->txstate);\n\t\t\tbc->txstate |= TX_UNDERRUN;\n\t\t}\n\t\tbc->free = card->send.size;\n\t}\n\tret = bc_next_frame(bc);\n\tif (!ret) {\n\t\tif (test_bit(FLG_HDLC, &bc->bch.Flags)) {\n\t\t\tfill_hdlc_flag(bc);\n\t\t\treturn;\n\t\t}\n\t\tpr_debug(\"%s: B%1d TX no data free %d idx %d/%d\\n\", card->name,\n\t\t\t bc->bch.nr, bc->free, bc->idx, card->send.idx);\n\t\tif (!(bc->txstate & (TX_IDLE | TX_INIT))) {\n\t\t\tfill_mem(bc, bc->idx, bc->free, 0xff);\n\t\t\tif (bc->free == card->send.size)\n\t\t\t\tbc->txstate |= TX_IDLE;\n\t\t}\n\t}\n}\n\nstatic void\nsend_tiger(struct tiger_hw *card, u8 irq_stat)\n{\n\tint i;\n\n\t \n\tif ((irq_stat & card->last_is0) & NJ_IRQM0_RD_MASK) {\n\t\tpr_info(\"%s: tiger warn write double dma %x/%x\\n\",\n\t\t\tcard->name, irq_stat, card->last_is0);\n\t\treturn;\n\t} else {\n\t\tcard->last_is0 &= ~NJ_IRQM0_RD_MASK;\n\t\tcard->last_is0 |= (irq_stat & NJ_IRQM0_RD_MASK);\n\t}\n\tfor (i = 0; i < 2; i++) {\n\t\tif (test_bit(FLG_ACTIVE, &card->bc[i].bch.Flags))\n\t\t\tsend_tiger_bc(card, &card->bc[i]);\n\t}\n}\n\nstatic irqreturn_t\nnj_irq(int intno, void *dev_id)\n{\n\tstruct tiger_hw *card = dev_id;\n\tu8 val, s1val, s0val;\n\n\tspin_lock(&card->lock);\n\ts0val = inb(card->base | NJ_IRQSTAT0);\n\ts1val = inb(card->base | NJ_IRQSTAT1);\n\tif ((s1val & NJ_ISACIRQ) && (s0val == 0)) {\n\t\t \n\t\tspin_unlock(&card->lock);\n\t\treturn IRQ_NONE;\n\t}\n\tpr_debug(\"%s: IRQSTAT0 %02x IRQSTAT1 %02x\\n\", card->name, s0val, s1val);\n\tcard->irqcnt++;\n\tif (!(s1val & NJ_ISACIRQ)) {\n\t\tval = ReadISAC_nj(card, ISAC_ISTA);\n\t\tif (val)\n\t\t\tmISDNisac_irq(&card->isac, val);\n\t}\n\n\tif (s0val)\n\t\t \n\t\toutb(s0val, card->base | NJ_IRQSTAT0);\n\telse\n\t\tgoto end;\n\ts1val = s0val;\n\t \n\tcard->recv.dmacur = inl(card->base | NJ_DMA_WRITE_ADR);\n\tcard->recv.idx = (card->recv.dmacur - card->recv.dmastart) >> 2;\n\tif (card->recv.dmacur < card->recv.dmairq)\n\t\ts0val = 0x08;\t \n\telse\n\t\ts0val = 0x04;\t \n\n\tcard->send.dmacur = inl(card->base | NJ_DMA_READ_ADR);\n\tcard->send.idx = (card->send.dmacur - card->send.dmastart) >> 2;\n\tif (card->send.dmacur < card->send.dmairq)\n\t\ts0val |= 0x02;\t \n\telse\n\t\ts0val |= 0x01;\t \n\n\tpr_debug(\"%s: DMA Status %02x/%02x/%02x %d/%d\\n\", card->name,\n\t\t s1val, s0val, card->last_is0,\n\t\t card->recv.idx, card->send.idx);\n\t \n\tif (s0val != card->last_is0) {\n\t\tif ((s0val & NJ_IRQM0_RD_MASK) !=\n\t\t    (card->last_is0 & NJ_IRQM0_RD_MASK))\n\t\t\t \n\t\t\tsend_tiger(card, s0val);\n\t\tif ((s0val & NJ_IRQM0_WR_MASK) !=\n\t\t    (card->last_is0 & NJ_IRQM0_WR_MASK))\n\t\t\t \n\t\t\trecv_tiger(card, s0val);\n\t}\nend:\n\tspin_unlock(&card->lock);\n\treturn IRQ_HANDLED;\n}\n\nstatic int\nnj_l2l1B(struct mISDNchannel *ch, struct sk_buff *skb)\n{\n\tint ret = -EINVAL;\n\tstruct bchannel *bch = container_of(ch, struct bchannel, ch);\n\tstruct tiger_ch *bc = container_of(bch, struct tiger_ch, bch);\n\tstruct tiger_hw *card = bch->hw;\n\tstruct mISDNhead *hh = mISDN_HEAD_P(skb);\n\tunsigned long flags;\n\n\tswitch (hh->prim) {\n\tcase PH_DATA_REQ:\n\t\tspin_lock_irqsave(&card->lock, flags);\n\t\tret = bchannel_senddata(bch, skb);\n\t\tif (ret > 0) {  \n\t\t\tfill_dma(bc);\n\t\t\tret = 0;\n\t\t}\n\t\tspin_unlock_irqrestore(&card->lock, flags);\n\t\treturn ret;\n\tcase PH_ACTIVATE_REQ:\n\t\tspin_lock_irqsave(&card->lock, flags);\n\t\tif (!test_and_set_bit(FLG_ACTIVE, &bch->Flags))\n\t\t\tret = mode_tiger(bc, ch->protocol);\n\t\telse\n\t\t\tret = 0;\n\t\tspin_unlock_irqrestore(&card->lock, flags);\n\t\tif (!ret)\n\t\t\t_queue_data(ch, PH_ACTIVATE_IND, MISDN_ID_ANY, 0,\n\t\t\t\t    NULL, GFP_KERNEL);\n\t\tbreak;\n\tcase PH_DEACTIVATE_REQ:\n\t\tspin_lock_irqsave(&card->lock, flags);\n\t\tmISDN_clear_bchannel(bch);\n\t\tmode_tiger(bc, ISDN_P_NONE);\n\t\tspin_unlock_irqrestore(&card->lock, flags);\n\t\t_queue_data(ch, PH_DEACTIVATE_IND, MISDN_ID_ANY, 0,\n\t\t\t    NULL, GFP_KERNEL);\n\t\tret = 0;\n\t\tbreak;\n\t}\n\tif (!ret)\n\t\tdev_kfree_skb(skb);\n\treturn ret;\n}\n\nstatic int\nchannel_bctrl(struct tiger_ch *bc, struct mISDN_ctrl_req *cq)\n{\n\treturn mISDN_ctrl_bchannel(&bc->bch, cq);\n}\n\nstatic int\nnj_bctrl(struct mISDNchannel *ch, u32 cmd, void *arg)\n{\n\tstruct bchannel *bch = container_of(ch, struct bchannel, ch);\n\tstruct tiger_ch *bc = container_of(bch, struct tiger_ch, bch);\n\tstruct tiger_hw *card  = bch->hw;\n\tint ret = -EINVAL;\n\tu_long flags;\n\n\tpr_debug(\"%s: %s cmd:%x %p\\n\", card->name, __func__, cmd, arg);\n\tswitch (cmd) {\n\tcase CLOSE_CHANNEL:\n\t\ttest_and_clear_bit(FLG_OPEN, &bch->Flags);\n\t\tcancel_work_sync(&bch->workq);\n\t\tspin_lock_irqsave(&card->lock, flags);\n\t\tmISDN_clear_bchannel(bch);\n\t\tmode_tiger(bc, ISDN_P_NONE);\n\t\tspin_unlock_irqrestore(&card->lock, flags);\n\t\tch->protocol = ISDN_P_NONE;\n\t\tch->peer = NULL;\n\t\tmodule_put(THIS_MODULE);\n\t\tret = 0;\n\t\tbreak;\n\tcase CONTROL_CHANNEL:\n\t\tret = channel_bctrl(bc, arg);\n\t\tbreak;\n\tdefault:\n\t\tpr_info(\"%s: %s unknown prim(%x)\\n\", card->name, __func__, cmd);\n\t}\n\treturn ret;\n}\n\nstatic int\nchannel_ctrl(struct tiger_hw *card, struct mISDN_ctrl_req *cq)\n{\n\tint\tret = 0;\n\n\tswitch (cq->op) {\n\tcase MISDN_CTRL_GETOP:\n\t\tcq->op = MISDN_CTRL_LOOP | MISDN_CTRL_L1_TIMER3;\n\t\tbreak;\n\tcase MISDN_CTRL_LOOP:\n\t\t \n\t\tif (cq->channel < 0 || cq->channel > 3) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tret = card->isac.ctrl(&card->isac, HW_TESTLOOP, cq->channel);\n\t\tbreak;\n\tcase MISDN_CTRL_L1_TIMER3:\n\t\tret = card->isac.ctrl(&card->isac, HW_TIMER3_VALUE, cq->p1);\n\t\tbreak;\n\tdefault:\n\t\tpr_info(\"%s: %s unknown Op %x\\n\", card->name, __func__, cq->op);\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic int\nopen_bchannel(struct tiger_hw *card, struct channel_req *rq)\n{\n\tstruct bchannel *bch;\n\n\tif (rq->adr.channel == 0 || rq->adr.channel > 2)\n\t\treturn -EINVAL;\n\tif (rq->protocol == ISDN_P_NONE)\n\t\treturn -EINVAL;\n\tbch = &card->bc[rq->adr.channel - 1].bch;\n\tif (test_and_set_bit(FLG_OPEN, &bch->Flags))\n\t\treturn -EBUSY;  \n\ttest_and_clear_bit(FLG_FILLEMPTY, &bch->Flags);\n\tbch->ch.protocol = rq->protocol;\n\trq->ch = &bch->ch;\n\treturn 0;\n}\n\n \nstatic int\nnj_dctrl(struct mISDNchannel *ch, u32 cmd, void *arg)\n{\n\tstruct mISDNdevice\t*dev = container_of(ch, struct mISDNdevice, D);\n\tstruct dchannel\t\t*dch = container_of(dev, struct dchannel, dev);\n\tstruct tiger_hw\t*card = dch->hw;\n\tstruct channel_req\t*rq;\n\tint\t\t\terr = 0;\n\n\tpr_debug(\"%s: %s cmd:%x %p\\n\", card->name, __func__, cmd, arg);\n\tswitch (cmd) {\n\tcase OPEN_CHANNEL:\n\t\trq = arg;\n\t\tif (rq->protocol == ISDN_P_TE_S0)\n\t\t\terr = card->isac.open(&card->isac, rq);\n\t\telse\n\t\t\terr = open_bchannel(card, rq);\n\t\tif (err)\n\t\t\tbreak;\n\t\tif (!try_module_get(THIS_MODULE))\n\t\t\tpr_info(\"%s: cannot get module\\n\", card->name);\n\t\tbreak;\n\tcase CLOSE_CHANNEL:\n\t\tpr_debug(\"%s: dev(%d) close from %p\\n\", card->name, dch->dev.id,\n\t\t\t __builtin_return_address(0));\n\t\tmodule_put(THIS_MODULE);\n\t\tbreak;\n\tcase CONTROL_CHANNEL:\n\t\terr = channel_ctrl(card, arg);\n\t\tbreak;\n\tdefault:\n\t\tpr_debug(\"%s: %s unknown command %x\\n\",\n\t\t\t card->name, __func__, cmd);\n\t\treturn -EINVAL;\n\t}\n\treturn err;\n}\n\nstatic int\nnj_init_card(struct tiger_hw *card)\n{\n\tu_long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&card->lock, flags);\n\tnj_disable_hwirq(card);\n\tspin_unlock_irqrestore(&card->lock, flags);\n\n\tcard->irq = card->pdev->irq;\n\tif (request_irq(card->irq, nj_irq, IRQF_SHARED, card->name, card)) {\n\t\tpr_info(\"%s: couldn't get interrupt %d\\n\",\n\t\t\tcard->name, card->irq);\n\t\tcard->irq = -1;\n\t\treturn -EIO;\n\t}\n\n\tspin_lock_irqsave(&card->lock, flags);\n\tnj_reset(card);\n\tret = card->isac.init(&card->isac);\n\tif (ret)\n\t\tgoto error;\n\tret = inittiger(card);\n\tif (ret)\n\t\tgoto error;\n\tmode_tiger(&card->bc[0], ISDN_P_NONE);\n\tmode_tiger(&card->bc[1], ISDN_P_NONE);\nerror:\n\tspin_unlock_irqrestore(&card->lock, flags);\n\treturn ret;\n}\n\n\nstatic void\nnj_release(struct tiger_hw *card)\n{\n\tu_long flags;\n\tint i;\n\n\tif (card->base_s) {\n\t\tspin_lock_irqsave(&card->lock, flags);\n\t\tnj_disable_hwirq(card);\n\t\tmode_tiger(&card->bc[0], ISDN_P_NONE);\n\t\tmode_tiger(&card->bc[1], ISDN_P_NONE);\n\t\tspin_unlock_irqrestore(&card->lock, flags);\n\t\tcard->isac.release(&card->isac);\n\t\trelease_region(card->base, card->base_s);\n\t\tcard->base_s = 0;\n\t}\n\tif (card->irq > 0)\n\t\tfree_irq(card->irq, card);\n\tif (device_is_registered(&card->isac.dch.dev.dev))\n\t\tmISDN_unregister_device(&card->isac.dch.dev);\n\n\tfor (i = 0; i < 2; i++) {\n\t\tmISDN_freebchannel(&card->bc[i].bch);\n\t\tkfree(card->bc[i].hsbuf);\n\t\tkfree(card->bc[i].hrbuf);\n\t}\n\tif (card->dma_p)\n\t\tdma_free_coherent(&card->pdev->dev, NJ_DMA_SIZE, card->dma_p,\n\t\t\t\t  card->dma);\n\twrite_lock_irqsave(&card_lock, flags);\n\tlist_del(&card->list);\n\twrite_unlock_irqrestore(&card_lock, flags);\n\tpci_disable_device(card->pdev);\n\tpci_set_drvdata(card->pdev, NULL);\n\tkfree(card);\n}\n\n\nstatic int\nnj_setup(struct tiger_hw *card)\n{\n\tcard->base = pci_resource_start(card->pdev, 0);\n\tcard->base_s = pci_resource_len(card->pdev, 0);\n\tif (!request_region(card->base, card->base_s, card->name)) {\n\t\tpr_info(\"%s: NETjet config port %#x-%#x already in use\\n\",\n\t\t\tcard->name, card->base,\n\t\t\t(u32)(card->base + card->base_s - 1));\n\t\tcard->base_s = 0;\n\t\treturn -EIO;\n\t}\n\tASSIGN_FUNC(nj, ISAC, card->isac);\n\treturn 0;\n}\n\n\nstatic int\nsetup_instance(struct tiger_hw *card)\n{\n\tint i, err;\n\tu_long flags;\n\n\tsnprintf(card->name, MISDN_MAX_IDLEN - 1, \"netjet.%d\", nj_cnt + 1);\n\twrite_lock_irqsave(&card_lock, flags);\n\tlist_add_tail(&card->list, &Cards);\n\twrite_unlock_irqrestore(&card_lock, flags);\n\n\t_set_debug(card);\n\tcard->isac.name = card->name;\n\tspin_lock_init(&card->lock);\n\tcard->isac.hwlock = &card->lock;\n\tmISDNisac_init(&card->isac, card);\n\n\tcard->isac.dch.dev.Bprotocols = (1 << (ISDN_P_B_RAW & ISDN_P_B_MASK)) |\n\t\t(1 << (ISDN_P_B_HDLC & ISDN_P_B_MASK));\n\tcard->isac.dch.dev.D.ctrl = nj_dctrl;\n\tfor (i = 0; i < 2; i++) {\n\t\tcard->bc[i].bch.nr = i + 1;\n\t\tset_channelmap(i + 1, card->isac.dch.dev.channelmap);\n\t\tmISDN_initbchannel(&card->bc[i].bch, MAX_DATA_MEM,\n\t\t\t\t   NJ_DMA_RXSIZE >> 1);\n\t\tcard->bc[i].bch.hw = card;\n\t\tcard->bc[i].bch.ch.send = nj_l2l1B;\n\t\tcard->bc[i].bch.ch.ctrl = nj_bctrl;\n\t\tcard->bc[i].bch.ch.nr = i + 1;\n\t\tlist_add(&card->bc[i].bch.ch.list,\n\t\t\t &card->isac.dch.dev.bchannels);\n\t\tcard->bc[i].bch.hw = card;\n\t}\n\terr = nj_setup(card);\n\tif (err)\n\t\tgoto error;\n\terr = mISDN_register_device(&card->isac.dch.dev, &card->pdev->dev,\n\t\t\t\t    card->name);\n\tif (err)\n\t\tgoto error;\n\terr = nj_init_card(card);\n\tif (!err)  {\n\t\tnj_cnt++;\n\t\tpr_notice(\"Netjet %d cards installed\\n\", nj_cnt);\n\t\treturn 0;\n\t}\nerror:\n\tnj_release(card);\n\treturn err;\n}\n\nstatic int\nnj_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tint err = -ENOMEM;\n\tint cfg;\n\tstruct tiger_hw *card;\n\n\tif (pdev->subsystem_vendor == 0x8086 &&\n\t    pdev->subsystem_device == 0x0003) {\n\t\tpr_notice(\"Netjet: Digium X100P/X101P not handled\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (pdev->subsystem_vendor == 0x55 &&\n\t    pdev->subsystem_device == 0x02) {\n\t\tpr_notice(\"Netjet: Enter!Now not handled yet\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (pdev->subsystem_vendor == 0xb100 &&\n\t    pdev->subsystem_device == 0x0003) {\n\t\tpr_notice(\"Netjet: Digium TDM400P not handled yet\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tcard = kzalloc(sizeof(struct tiger_hw), GFP_KERNEL);\n\tif (!card) {\n\t\tpr_info(\"No kmem for Netjet\\n\");\n\t\treturn err;\n\t}\n\n\tcard->pdev = pdev;\n\n\terr = pci_enable_device(pdev);\n\tif (err) {\n\t\tkfree(card);\n\t\treturn err;\n\t}\n\n\tprintk(KERN_INFO \"nj_probe(mISDN): found adapter at %s\\n\",\n\t       pci_name(pdev));\n\n\tpci_set_master(pdev);\n\n\t \n\tpci_read_config_dword(pdev, 0x04, &cfg);\n\tif (cfg & 0x00100000)\n\t\tcard->typ = NETJET_S_TJ320;\n\telse\n\t\tcard->typ = NETJET_S_TJ300;\n\n\tcard->base = pci_resource_start(pdev, 0);\n\tpci_set_drvdata(pdev, card);\n\terr = setup_instance(card);\n\tif (err)\n\t\tpci_set_drvdata(pdev, NULL);\n\n\treturn err;\n}\n\n\nstatic void nj_remove(struct pci_dev *pdev)\n{\n\tstruct tiger_hw *card = pci_get_drvdata(pdev);\n\n\tif (card)\n\t\tnj_release(card);\n\telse\n\t\tpr_info(\"%s drvdata already removed\\n\", __func__);\n}\n\n \nstatic const struct pci_device_id nj_pci_ids[] = {\n\t{ PCI_VENDOR_ID_TIGERJET, PCI_DEVICE_ID_TIGERJET_300,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},\n\t{ }\n};\nMODULE_DEVICE_TABLE(pci, nj_pci_ids);\n\nstatic struct pci_driver nj_driver = {\n\t.name = \"netjet\",\n\t.probe = nj_probe,\n\t.remove = nj_remove,\n\t.id_table = nj_pci_ids,\n};\n\nstatic int __init nj_init(void)\n{\n\tint err;\n\n\tpr_notice(\"Netjet PCI driver Rev. %s\\n\", NETJET_REV);\n\terr = pci_register_driver(&nj_driver);\n\treturn err;\n}\n\nstatic void __exit nj_cleanup(void)\n{\n\tpci_unregister_driver(&nj_driver);\n}\n\nmodule_init(nj_init);\nmodule_exit(nj_cleanup);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}