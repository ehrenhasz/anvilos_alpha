{
  "module_name": "mISDNinfineon.c",
  "hash_id": "b1ffb47b0e637b95d161d856af3eee0ba3df2b563b5572c47c1e0f91a89c8d93",
  "original_prompt": "Ingested from linux-6.6.14/drivers/isdn/hardware/mISDN/mISDNinfineon.c",
  "human_readable_source": "\n \n\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/delay.h>\n#include <linux/mISDNhw.h>\n#include <linux/slab.h>\n#include \"ipac.h\"\n\n#define INFINEON_REV\t\"1.0\"\n\nstatic int inf_cnt;\nstatic u32 debug;\nstatic u32 irqloops = 4;\n\nenum inf_types {\n\tINF_NONE,\n\tINF_DIVA20,\n\tINF_DIVA20U,\n\tINF_DIVA201,\n\tINF_DIVA202,\n\tINF_SPEEDWIN,\n\tINF_SAPHIR3,\n\tINF_QS1000,\n\tINF_QS3000,\n\tINF_NICCY,\n\tINF_SCT_1,\n\tINF_SCT_2,\n\tINF_SCT_3,\n\tINF_SCT_4,\n\tINF_GAZEL_R685,\n\tINF_GAZEL_R753\n};\n\nenum addr_mode {\n\tAM_NONE = 0,\n\tAM_IO,\n\tAM_MEMIO,\n\tAM_IND_IO,\n};\n\nstruct inf_cinfo {\n\tenum inf_types\ttyp;\n\tconst char\t*full;\n\tconst char\t*name;\n\tenum addr_mode\tcfg_mode;\n\tenum addr_mode\taddr_mode;\n\tu8\t\tcfg_bar;\n\tu8\t\taddr_bar;\n\tvoid\t\t*irqfunc;\n};\n\nstruct _ioaddr {\n\tenum addr_mode\tmode;\n\tunion {\n\t\tvoid __iomem\t*p;\n\t\tstruct _ioport\tio;\n\t} a;\n};\n\nstruct _iohandle {\n\tenum addr_mode\tmode;\n\tresource_size_t\tsize;\n\tresource_size_t\tstart;\n\tvoid __iomem\t*p;\n};\n\nstruct inf_hw {\n\tstruct list_head\tlist;\n\tstruct pci_dev\t\t*pdev;\n\tconst struct inf_cinfo\t*ci;\n\tchar\t\t\tname[MISDN_MAX_IDLEN];\n\tu32\t\t\tirq;\n\tu32\t\t\tirqcnt;\n\tstruct _iohandle\tcfg;\n\tstruct _iohandle\taddr;\n\tstruct _ioaddr\t\tisac;\n\tstruct _ioaddr\t\thscx;\n\tspinlock_t\t\tlock;\t \n\tstruct ipac_hw\t\tipac;\n\tstruct inf_hw\t\t*sc[3];\t \n};\n\n\n#define PCI_SUBVENDOR_HST_SAPHIR3       0x52\n#define PCI_SUBVENDOR_SEDLBAUER_PCI     0x53\n#define PCI_SUB_ID_SEDLBAUER            0x01\n\nstatic struct pci_device_id infineon_ids[] = {\n\t{ PCI_VDEVICE(EICON, PCI_DEVICE_ID_EICON_DIVA20), INF_DIVA20 },\n\t{ PCI_VDEVICE(EICON, PCI_DEVICE_ID_EICON_DIVA20_U), INF_DIVA20U },\n\t{ PCI_VDEVICE(EICON, PCI_DEVICE_ID_EICON_DIVA201), INF_DIVA201 },\n\t{ PCI_VDEVICE(EICON, PCI_DEVICE_ID_EICON_DIVA202), INF_DIVA202 },\n\t{ PCI_VENDOR_ID_TIGERJET, PCI_DEVICE_ID_TIGERJET_100,\n\t  PCI_SUBVENDOR_SEDLBAUER_PCI, PCI_SUB_ID_SEDLBAUER, 0, 0,\n\t  INF_SPEEDWIN },\n\t{ PCI_VENDOR_ID_TIGERJET, PCI_DEVICE_ID_TIGERJET_100,\n\t  PCI_SUBVENDOR_HST_SAPHIR3, PCI_SUB_ID_SEDLBAUER, 0, 0, INF_SAPHIR3 },\n\t{ PCI_VDEVICE(ELSA, PCI_DEVICE_ID_ELSA_MICROLINK), INF_QS1000 },\n\t{ PCI_VDEVICE(ELSA, PCI_DEVICE_ID_ELSA_QS3000), INF_QS3000 },\n\t{ PCI_VDEVICE(SATSAGEM, PCI_DEVICE_ID_SATSAGEM_NICCY), INF_NICCY },\n\t{ PCI_VENDOR_ID_PLX, PCI_DEVICE_ID_PLX_9050,\n\t  PCI_VENDOR_ID_BERKOM, PCI_DEVICE_ID_BERKOM_SCITEL_QUADRO, 0, 0,\n\t  INF_SCT_1 },\n\t{ PCI_VDEVICE(PLX, PCI_DEVICE_ID_PLX_R685), INF_GAZEL_R685 },\n\t{ PCI_VDEVICE(PLX, PCI_DEVICE_ID_PLX_R753), INF_GAZEL_R753 },\n\t{ PCI_VDEVICE(PLX, PCI_DEVICE_ID_PLX_DJINN_ITOO), INF_GAZEL_R753 },\n\t{ PCI_VDEVICE(PLX, PCI_DEVICE_ID_PLX_OLITEC), INF_GAZEL_R753 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(pci, infineon_ids);\n\n \n \n#define DIVA_HSCX_PORT\t\t0x00\n#define DIVA_HSCX_ALE\t\t0x04\n#define DIVA_ISAC_PORT\t\t0x08\n#define DIVA_ISAC_ALE\t\t0x0C\n#define DIVA_PCI_CTRL           0x10\n\n \n#define DIVA_IRQ_BIT\t\t0x01\n#define DIVA_RESET_BIT\t\t0x08\n#define DIVA_EEPROM_CLK\t\t0x40\n#define DIVA_LED_A\t\t0x10\n#define DIVA_LED_B\t\t0x20\n#define DIVA_IRQ_CLR\t\t0x80\n\n \n \n#define PITA_ICR_REG\t\t0x00\n#define PITA_INT0_STATUS\t0x02\n\n#define PITA_MISC_REG\t\t0x1c\n#define PITA_PARA_SOFTRESET\t0x01000000\n#define PITA_SER_SOFTRESET\t0x02000000\n#define PITA_PARA_MPX_MODE\t0x04000000\n#define PITA_INT0_ENABLE\t0x00020000\n\n \n#define TIGER_RESET_ADDR\t0x00\n#define TIGER_EXTERN_RESET\t0x01\n#define TIGER_AUX_CTRL\t\t0x02\n#define TIGER_AUX_DATA\t\t0x03\n#define TIGER_AUX_IRQMASK\t0x05\n#define TIGER_AUX_STATUS\t0x07\n\n \n#define TIGER_IOMASK\t\t0xdd\t \n#define TIGER_IRQ_BIT\t\t0x02\n\n#define TIGER_IPAC_ALE\t\t0xC0\n#define TIGER_IPAC_PORT\t\t0xC8\n\n \n#define ELSA_IRQ_ADDR\t\t0x4c\n#define ELSA_IRQ_MASK\t\t0x04\n#define QS1000_IRQ_OFF\t\t0x01\n#define QS3000_IRQ_OFF\t\t0x03\n#define QS1000_IRQ_ON\t\t0x41\n#define QS3000_IRQ_ON\t\t0x43\n\n \n#define NICCY_ISAC_PORT\t\t0x00\n#define NICCY_HSCX_PORT\t\t0x01\n#define NICCY_ISAC_ALE\t\t0x02\n#define NICCY_HSCX_ALE\t\t0x03\n\n#define NICCY_IRQ_CTRL_REG\t0x38\n#define NICCY_IRQ_ENABLE\t0x001f00\n#define NICCY_IRQ_DISABLE\t0xff0000\n#define NICCY_IRQ_BIT\t\t0x800000\n\n\n \n#define SCT_PLX_IRQ_ADDR\t0x4c\n#define SCT_PLX_RESET_ADDR\t0x50\n#define SCT_PLX_IRQ_ENABLE\t0x41\n#define SCT_PLX_RESET_BIT\t0x04\n\n \n#define\tGAZEL_IPAC_DATA_PORT\t0x04\n \n#define GAZEL_CNTRL\t\t0x50\n#define GAZEL_RESET\t\t0x04\n#define GAZEL_RESET_9050\t0x40000000\n#define GAZEL_INCSR\t\t0x4C\n#define GAZEL_ISAC_EN\t\t0x08\n#define GAZEL_INT_ISAC\t\t0x20\n#define GAZEL_HSCX_EN\t\t0x01\n#define GAZEL_INT_HSCX\t\t0x04\n#define GAZEL_PCI_EN\t\t0x40\n#define GAZEL_IPAC_EN\t\t0x03\n\n\nstatic LIST_HEAD(Cards);\nstatic DEFINE_RWLOCK(card_lock);  \n\nstatic void\n_set_debug(struct inf_hw *card)\n{\n\tcard->ipac.isac.dch.debug = debug;\n\tcard->ipac.hscx[0].bch.debug = debug;\n\tcard->ipac.hscx[1].bch.debug = debug;\n}\n\nstatic int\nset_debug(const char *val, const struct kernel_param *kp)\n{\n\tint ret;\n\tstruct inf_hw *card;\n\n\tret = param_set_uint(val, kp);\n\tif (!ret) {\n\t\tread_lock(&card_lock);\n\t\tlist_for_each_entry(card, &Cards, list)\n\t\t\t_set_debug(card);\n\t\tread_unlock(&card_lock);\n\t}\n\treturn ret;\n}\n\nMODULE_AUTHOR(\"Karsten Keil\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_VERSION(INFINEON_REV);\nmodule_param_call(debug, set_debug, param_get_uint, &debug, S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(debug, \"infineon debug mask\");\nmodule_param(irqloops, uint, S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(irqloops, \"infineon maximal irqloops (default 4)\");\n\n \n\nIOFUNC_IO(ISAC, inf_hw, isac.a.io)\nIOFUNC_IO(IPAC, inf_hw, hscx.a.io)\nIOFUNC_IND(ISAC, inf_hw, isac.a.io)\nIOFUNC_IND(IPAC, inf_hw, hscx.a.io)\nIOFUNC_MEMIO(ISAC, inf_hw, u32, isac.a.p)\nIOFUNC_MEMIO(IPAC, inf_hw, u32, hscx.a.p)\n\nstatic irqreturn_t\ndiva_irq(int intno, void *dev_id)\n{\n\tstruct inf_hw *hw = dev_id;\n\tu8 val;\n\n\tspin_lock(&hw->lock);\n\tval = inb((u32)hw->cfg.start + DIVA_PCI_CTRL);\n\tif (!(val & DIVA_IRQ_BIT)) {  \n\t\tspin_unlock(&hw->lock);\n\t\treturn IRQ_NONE;  \n\t}\n\thw->irqcnt++;\n\tmISDNipac_irq(&hw->ipac, irqloops);\n\tspin_unlock(&hw->lock);\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t\ndiva20x_irq(int intno, void *dev_id)\n{\n\tstruct inf_hw *hw = dev_id;\n\tu8 val;\n\n\tspin_lock(&hw->lock);\n\tval = readb(hw->cfg.p);\n\tif (!(val & PITA_INT0_STATUS)) {  \n\t\tspin_unlock(&hw->lock);\n\t\treturn IRQ_NONE;  \n\t}\n\thw->irqcnt++;\n\tmISDNipac_irq(&hw->ipac, irqloops);\n\twriteb(PITA_INT0_STATUS, hw->cfg.p);  \n\tspin_unlock(&hw->lock);\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t\ntiger_irq(int intno, void *dev_id)\n{\n\tstruct inf_hw *hw = dev_id;\n\tu8 val;\n\n\tspin_lock(&hw->lock);\n\tval = inb((u32)hw->cfg.start + TIGER_AUX_STATUS);\n\tif (val & TIGER_IRQ_BIT) {  \n\t\tspin_unlock(&hw->lock);\n\t\treturn IRQ_NONE;  \n\t}\n\thw->irqcnt++;\n\tmISDNipac_irq(&hw->ipac, irqloops);\n\tspin_unlock(&hw->lock);\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t\nelsa_irq(int intno, void *dev_id)\n{\n\tstruct inf_hw *hw = dev_id;\n\tu8 val;\n\n\tspin_lock(&hw->lock);\n\tval = inb((u32)hw->cfg.start + ELSA_IRQ_ADDR);\n\tif (!(val & ELSA_IRQ_MASK)) {\n\t\tspin_unlock(&hw->lock);\n\t\treturn IRQ_NONE;  \n\t}\n\thw->irqcnt++;\n\tmISDNipac_irq(&hw->ipac, irqloops);\n\tspin_unlock(&hw->lock);\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t\nniccy_irq(int intno, void *dev_id)\n{\n\tstruct inf_hw *hw = dev_id;\n\tu32 val;\n\n\tspin_lock(&hw->lock);\n\tval = inl((u32)hw->cfg.start + NICCY_IRQ_CTRL_REG);\n\tif (!(val & NICCY_IRQ_BIT)) {  \n\t\tspin_unlock(&hw->lock);\n\t\treturn IRQ_NONE;  \n\t}\n\toutl(val, (u32)hw->cfg.start + NICCY_IRQ_CTRL_REG);\n\thw->irqcnt++;\n\tmISDNipac_irq(&hw->ipac, irqloops);\n\tspin_unlock(&hw->lock);\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t\ngazel_irq(int intno, void *dev_id)\n{\n\tstruct inf_hw *hw = dev_id;\n\tirqreturn_t ret;\n\n\tspin_lock(&hw->lock);\n\tret = mISDNipac_irq(&hw->ipac, irqloops);\n\tspin_unlock(&hw->lock);\n\treturn ret;\n}\n\nstatic irqreturn_t\nipac_irq(int intno, void *dev_id)\n{\n\tstruct inf_hw *hw = dev_id;\n\tu8 val;\n\n\tspin_lock(&hw->lock);\n\tval = hw->ipac.read_reg(hw, IPAC_ISTA);\n\tif (!(val & 0x3f)) {\n\t\tspin_unlock(&hw->lock);\n\t\treturn IRQ_NONE;  \n\t}\n\thw->irqcnt++;\n\tmISDNipac_irq(&hw->ipac, irqloops);\n\tspin_unlock(&hw->lock);\n\treturn IRQ_HANDLED;\n}\n\nstatic void\nenable_hwirq(struct inf_hw *hw)\n{\n\tu16 w;\n\tu32 val;\n\n\tswitch (hw->ci->typ) {\n\tcase INF_DIVA201:\n\tcase INF_DIVA202:\n\t\twritel(PITA_INT0_ENABLE, hw->cfg.p);\n\t\tbreak;\n\tcase INF_SPEEDWIN:\n\tcase INF_SAPHIR3:\n\t\toutb(TIGER_IRQ_BIT, (u32)hw->cfg.start + TIGER_AUX_IRQMASK);\n\t\tbreak;\n\tcase INF_QS1000:\n\t\toutb(QS1000_IRQ_ON, (u32)hw->cfg.start + ELSA_IRQ_ADDR);\n\t\tbreak;\n\tcase INF_QS3000:\n\t\toutb(QS3000_IRQ_ON, (u32)hw->cfg.start + ELSA_IRQ_ADDR);\n\t\tbreak;\n\tcase INF_NICCY:\n\t\tval = inl((u32)hw->cfg.start + NICCY_IRQ_CTRL_REG);\n\t\tval |= NICCY_IRQ_ENABLE;\n\t\toutl(val, (u32)hw->cfg.start + NICCY_IRQ_CTRL_REG);\n\t\tbreak;\n\tcase INF_SCT_1:\n\t\tw = inw((u32)hw->cfg.start + SCT_PLX_IRQ_ADDR);\n\t\tw |= SCT_PLX_IRQ_ENABLE;\n\t\toutw(w, (u32)hw->cfg.start + SCT_PLX_IRQ_ADDR);\n\t\tbreak;\n\tcase INF_GAZEL_R685:\n\t\toutb(GAZEL_ISAC_EN + GAZEL_HSCX_EN + GAZEL_PCI_EN,\n\t\t     (u32)hw->cfg.start + GAZEL_INCSR);\n\t\tbreak;\n\tcase INF_GAZEL_R753:\n\t\toutb(GAZEL_IPAC_EN + GAZEL_PCI_EN,\n\t\t     (u32)hw->cfg.start + GAZEL_INCSR);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void\ndisable_hwirq(struct inf_hw *hw)\n{\n\tu16 w;\n\tu32 val;\n\n\tswitch (hw->ci->typ) {\n\tcase INF_DIVA201:\n\tcase INF_DIVA202:\n\t\twritel(0, hw->cfg.p);\n\t\tbreak;\n\tcase INF_SPEEDWIN:\n\tcase INF_SAPHIR3:\n\t\toutb(0, (u32)hw->cfg.start + TIGER_AUX_IRQMASK);\n\t\tbreak;\n\tcase INF_QS1000:\n\t\toutb(QS1000_IRQ_OFF, (u32)hw->cfg.start + ELSA_IRQ_ADDR);\n\t\tbreak;\n\tcase INF_QS3000:\n\t\toutb(QS3000_IRQ_OFF, (u32)hw->cfg.start + ELSA_IRQ_ADDR);\n\t\tbreak;\n\tcase INF_NICCY:\n\t\tval = inl((u32)hw->cfg.start + NICCY_IRQ_CTRL_REG);\n\t\tval &= NICCY_IRQ_DISABLE;\n\t\toutl(val, (u32)hw->cfg.start + NICCY_IRQ_CTRL_REG);\n\t\tbreak;\n\tcase INF_SCT_1:\n\t\tw = inw((u32)hw->cfg.start + SCT_PLX_IRQ_ADDR);\n\t\tw &= (~SCT_PLX_IRQ_ENABLE);\n\t\toutw(w, (u32)hw->cfg.start + SCT_PLX_IRQ_ADDR);\n\t\tbreak;\n\tcase INF_GAZEL_R685:\n\tcase INF_GAZEL_R753:\n\t\toutb(0, (u32)hw->cfg.start + GAZEL_INCSR);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void\nipac_chip_reset(struct inf_hw *hw)\n{\n\thw->ipac.write_reg(hw, IPAC_POTA2, 0x20);\n\tmdelay(5);\n\thw->ipac.write_reg(hw, IPAC_POTA2, 0x00);\n\tmdelay(5);\n\thw->ipac.write_reg(hw, IPAC_CONF, hw->ipac.conf);\n\thw->ipac.write_reg(hw, IPAC_MASK, 0xc0);\n}\n\nstatic void\nreset_inf(struct inf_hw *hw)\n{\n\tu16 w;\n\tu32 val;\n\n\tif (debug & DEBUG_HW)\n\t\tpr_notice(\"%s: resetting card\\n\", hw->name);\n\tswitch (hw->ci->typ) {\n\tcase INF_DIVA20:\n\tcase INF_DIVA20U:\n\t\toutb(0, (u32)hw->cfg.start + DIVA_PCI_CTRL);\n\t\tmdelay(10);\n\t\toutb(DIVA_RESET_BIT, (u32)hw->cfg.start + DIVA_PCI_CTRL);\n\t\tmdelay(10);\n\t\t \n\t\toutb(9, (u32)hw->cfg.start + 0x69);\n\t\toutb(DIVA_RESET_BIT | DIVA_LED_A,\n\t\t     (u32)hw->cfg.start + DIVA_PCI_CTRL);\n\t\tbreak;\n\tcase INF_DIVA201:\n\t\twritel(PITA_PARA_SOFTRESET | PITA_PARA_MPX_MODE,\n\t\t       hw->cfg.p + PITA_MISC_REG);\n\t\tmdelay(1);\n\t\twritel(PITA_PARA_MPX_MODE, hw->cfg.p + PITA_MISC_REG);\n\t\tmdelay(10);\n\t\tbreak;\n\tcase INF_DIVA202:\n\t\twritel(PITA_PARA_SOFTRESET | PITA_PARA_MPX_MODE,\n\t\t       hw->cfg.p + PITA_MISC_REG);\n\t\tmdelay(1);\n\t\twritel(PITA_PARA_MPX_MODE | PITA_SER_SOFTRESET,\n\t\t       hw->cfg.p + PITA_MISC_REG);\n\t\tmdelay(10);\n\t\tbreak;\n\tcase INF_SPEEDWIN:\n\tcase INF_SAPHIR3:\n\t\tipac_chip_reset(hw);\n\t\thw->ipac.write_reg(hw, IPAC_ACFG, 0xff);\n\t\thw->ipac.write_reg(hw, IPAC_AOE, 0x00);\n\t\thw->ipac.write_reg(hw, IPAC_PCFG, 0x12);\n\t\tbreak;\n\tcase INF_QS1000:\n\tcase INF_QS3000:\n\t\tipac_chip_reset(hw);\n\t\thw->ipac.write_reg(hw, IPAC_ACFG, 0x00);\n\t\thw->ipac.write_reg(hw, IPAC_AOE, 0x3c);\n\t\thw->ipac.write_reg(hw, IPAC_ATX, 0xff);\n\t\tbreak;\n\tcase INF_NICCY:\n\t\tbreak;\n\tcase INF_SCT_1:\n\t\tw = inw((u32)hw->cfg.start + SCT_PLX_RESET_ADDR);\n\t\tw &= (~SCT_PLX_RESET_BIT);\n\t\toutw(w, (u32)hw->cfg.start + SCT_PLX_RESET_ADDR);\n\t\tmdelay(10);\n\t\tw = inw((u32)hw->cfg.start + SCT_PLX_RESET_ADDR);\n\t\tw |= SCT_PLX_RESET_BIT;\n\t\toutw(w, (u32)hw->cfg.start + SCT_PLX_RESET_ADDR);\n\t\tmdelay(10);\n\t\tbreak;\n\tcase INF_GAZEL_R685:\n\t\tval = inl((u32)hw->cfg.start + GAZEL_CNTRL);\n\t\tval |= (GAZEL_RESET_9050 + GAZEL_RESET);\n\t\toutl(val, (u32)hw->cfg.start + GAZEL_CNTRL);\n\t\tval &= ~(GAZEL_RESET_9050 + GAZEL_RESET);\n\t\tmdelay(4);\n\t\toutl(val, (u32)hw->cfg.start + GAZEL_CNTRL);\n\t\tmdelay(10);\n\t\thw->ipac.isac.adf2 = 0x87;\n\t\thw->ipac.hscx[0].slot = 0x1f;\n\t\thw->ipac.hscx[1].slot = 0x23;\n\t\tbreak;\n\tcase INF_GAZEL_R753:\n\t\tval = inl((u32)hw->cfg.start + GAZEL_CNTRL);\n\t\tval |= (GAZEL_RESET_9050 + GAZEL_RESET);\n\t\toutl(val, (u32)hw->cfg.start + GAZEL_CNTRL);\n\t\tval &= ~(GAZEL_RESET_9050 + GAZEL_RESET);\n\t\tmdelay(4);\n\t\toutl(val, (u32)hw->cfg.start + GAZEL_CNTRL);\n\t\tmdelay(10);\n\t\tipac_chip_reset(hw);\n\t\thw->ipac.write_reg(hw, IPAC_ACFG, 0xff);\n\t\thw->ipac.write_reg(hw, IPAC_AOE, 0x00);\n\t\thw->ipac.conf = 0x01;  \n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\tenable_hwirq(hw);\n}\n\nstatic int\ninf_ctrl(struct inf_hw *hw, u32 cmd, u_long arg)\n{\n\tint ret = 0;\n\n\tswitch (cmd) {\n\tcase HW_RESET_REQ:\n\t\treset_inf(hw);\n\t\tbreak;\n\tdefault:\n\t\tpr_info(\"%s: %s unknown command %x %lx\\n\",\n\t\t\thw->name, __func__, cmd, arg);\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic int\ninit_irq(struct inf_hw *hw)\n{\n\tint\tret, cnt = 3;\n\tu_long\tflags;\n\n\tif (!hw->ci->irqfunc)\n\t\treturn -EINVAL;\n\tret = request_irq(hw->irq, hw->ci->irqfunc, IRQF_SHARED, hw->name, hw);\n\tif (ret) {\n\t\tpr_info(\"%s: couldn't get interrupt %d\\n\", hw->name, hw->irq);\n\t\treturn ret;\n\t}\n\twhile (cnt--) {\n\t\tspin_lock_irqsave(&hw->lock, flags);\n\t\treset_inf(hw);\n\t\tret = hw->ipac.init(&hw->ipac);\n\t\tif (ret) {\n\t\t\tspin_unlock_irqrestore(&hw->lock, flags);\n\t\t\tpr_info(\"%s: ISAC init failed with %d\\n\",\n\t\t\t\thw->name, ret);\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock_irqrestore(&hw->lock, flags);\n\t\tmsleep_interruptible(10);\n\t\tif (debug & DEBUG_HW)\n\t\t\tpr_notice(\"%s: IRQ %d count %d\\n\", hw->name,\n\t\t\t\t  hw->irq, hw->irqcnt);\n\t\tif (!hw->irqcnt) {\n\t\t\tpr_info(\"%s: IRQ(%d) got no requests during init %d\\n\",\n\t\t\t\thw->name, hw->irq, 3 - cnt);\n\t\t} else\n\t\t\treturn 0;\n\t}\n\tfree_irq(hw->irq, hw);\n\treturn -EIO;\n}\n\nstatic void\nrelease_io(struct inf_hw *hw)\n{\n\tif (hw->cfg.mode) {\n\t\tif (hw->cfg.mode == AM_MEMIO) {\n\t\t\trelease_mem_region(hw->cfg.start, hw->cfg.size);\n\t\t\tif (hw->cfg.p)\n\t\t\t\tiounmap(hw->cfg.p);\n\t\t} else\n\t\t\trelease_region(hw->cfg.start, hw->cfg.size);\n\t\thw->cfg.mode = AM_NONE;\n\t}\n\tif (hw->addr.mode) {\n\t\tif (hw->addr.mode == AM_MEMIO) {\n\t\t\trelease_mem_region(hw->addr.start, hw->addr.size);\n\t\t\tif (hw->addr.p)\n\t\t\t\tiounmap(hw->addr.p);\n\t\t} else\n\t\t\trelease_region(hw->addr.start, hw->addr.size);\n\t\thw->addr.mode = AM_NONE;\n\t}\n}\n\nstatic int\nsetup_io(struct inf_hw *hw)\n{\n\tint err = 0;\n\n\tif (hw->ci->cfg_mode) {\n\t\thw->cfg.start = pci_resource_start(hw->pdev, hw->ci->cfg_bar);\n\t\thw->cfg.size = pci_resource_len(hw->pdev, hw->ci->cfg_bar);\n\t\tif (hw->ci->cfg_mode == AM_MEMIO) {\n\t\t\tif (!request_mem_region(hw->cfg.start, hw->cfg.size,\n\t\t\t\t\t\thw->name))\n\t\t\t\terr = -EBUSY;\n\t\t} else {\n\t\t\tif (!request_region(hw->cfg.start, hw->cfg.size,\n\t\t\t\t\t    hw->name))\n\t\t\t\terr = -EBUSY;\n\t\t}\n\t\tif (err) {\n\t\t\tpr_info(\"mISDN: %s config port %lx (%lu bytes)\"\n\t\t\t\t\"already in use\\n\", hw->name,\n\t\t\t\t(ulong)hw->cfg.start, (ulong)hw->cfg.size);\n\t\t\treturn err;\n\t\t}\n\t\thw->cfg.mode = hw->ci->cfg_mode;\n\t\tif (hw->ci->cfg_mode == AM_MEMIO) {\n\t\t\thw->cfg.p = ioremap(hw->cfg.start, hw->cfg.size);\n\t\t\tif (!hw->cfg.p)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t\tif (debug & DEBUG_HW)\n\t\t\tpr_notice(\"%s: IO cfg %lx (%lu bytes) mode%d\\n\",\n\t\t\t\t  hw->name, (ulong)hw->cfg.start,\n\t\t\t\t  (ulong)hw->cfg.size, hw->ci->cfg_mode);\n\n\t}\n\tif (hw->ci->addr_mode) {\n\t\thw->addr.start = pci_resource_start(hw->pdev, hw->ci->addr_bar);\n\t\thw->addr.size = pci_resource_len(hw->pdev, hw->ci->addr_bar);\n\t\tif (hw->ci->addr_mode == AM_MEMIO) {\n\t\t\tif (!request_mem_region(hw->addr.start, hw->addr.size,\n\t\t\t\t\t\thw->name))\n\t\t\t\terr = -EBUSY;\n\t\t} else {\n\t\t\tif (!request_region(hw->addr.start, hw->addr.size,\n\t\t\t\t\t    hw->name))\n\t\t\t\terr = -EBUSY;\n\t\t}\n\t\tif (err) {\n\t\t\tpr_info(\"mISDN: %s address port %lx (%lu bytes)\"\n\t\t\t\t\"already in use\\n\", hw->name,\n\t\t\t\t(ulong)hw->addr.start, (ulong)hw->addr.size);\n\t\t\treturn err;\n\t\t}\n\t\thw->addr.mode = hw->ci->addr_mode;\n\t\tif (hw->ci->addr_mode == AM_MEMIO) {\n\t\t\thw->addr.p = ioremap(hw->addr.start, hw->addr.size);\n\t\t\tif (!hw->addr.p)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t\tif (debug & DEBUG_HW)\n\t\t\tpr_notice(\"%s: IO addr %lx (%lu bytes) mode%d\\n\",\n\t\t\t\t  hw->name, (ulong)hw->addr.start,\n\t\t\t\t  (ulong)hw->addr.size, hw->ci->addr_mode);\n\n\t}\n\n\tswitch (hw->ci->typ) {\n\tcase INF_DIVA20:\n\tcase INF_DIVA20U:\n\t\thw->ipac.type = IPAC_TYPE_ISAC | IPAC_TYPE_HSCX;\n\t\thw->isac.mode = hw->cfg.mode;\n\t\thw->isac.a.io.ale = (u32)hw->cfg.start + DIVA_ISAC_ALE;\n\t\thw->isac.a.io.port = (u32)hw->cfg.start + DIVA_ISAC_PORT;\n\t\thw->hscx.mode = hw->cfg.mode;\n\t\thw->hscx.a.io.ale = (u32)hw->cfg.start + DIVA_HSCX_ALE;\n\t\thw->hscx.a.io.port = (u32)hw->cfg.start + DIVA_HSCX_PORT;\n\t\tbreak;\n\tcase INF_DIVA201:\n\t\thw->ipac.type = IPAC_TYPE_IPAC;\n\t\thw->ipac.isac.off = 0x80;\n\t\thw->isac.mode = hw->addr.mode;\n\t\thw->isac.a.p = hw->addr.p;\n\t\thw->hscx.mode = hw->addr.mode;\n\t\thw->hscx.a.p = hw->addr.p;\n\t\tbreak;\n\tcase INF_DIVA202:\n\t\thw->ipac.type = IPAC_TYPE_IPACX;\n\t\thw->isac.mode = hw->addr.mode;\n\t\thw->isac.a.p = hw->addr.p;\n\t\thw->hscx.mode = hw->addr.mode;\n\t\thw->hscx.a.p = hw->addr.p;\n\t\tbreak;\n\tcase INF_SPEEDWIN:\n\tcase INF_SAPHIR3:\n\t\thw->ipac.type = IPAC_TYPE_IPAC;\n\t\thw->ipac.isac.off = 0x80;\n\t\thw->isac.mode = hw->cfg.mode;\n\t\thw->isac.a.io.ale = (u32)hw->cfg.start + TIGER_IPAC_ALE;\n\t\thw->isac.a.io.port = (u32)hw->cfg.start + TIGER_IPAC_PORT;\n\t\thw->hscx.mode = hw->cfg.mode;\n\t\thw->hscx.a.io.ale = (u32)hw->cfg.start + TIGER_IPAC_ALE;\n\t\thw->hscx.a.io.port = (u32)hw->cfg.start + TIGER_IPAC_PORT;\n\t\toutb(0xff, (ulong)hw->cfg.start);\n\t\tmdelay(1);\n\t\toutb(0x00, (ulong)hw->cfg.start);\n\t\tmdelay(1);\n\t\toutb(TIGER_IOMASK, (ulong)hw->cfg.start + TIGER_AUX_CTRL);\n\t\tbreak;\n\tcase INF_QS1000:\n\tcase INF_QS3000:\n\t\thw->ipac.type = IPAC_TYPE_IPAC;\n\t\thw->ipac.isac.off = 0x80;\n\t\thw->isac.a.io.ale = (u32)hw->addr.start;\n\t\thw->isac.a.io.port = (u32)hw->addr.start + 1;\n\t\thw->isac.mode = hw->addr.mode;\n\t\thw->hscx.a.io.ale = (u32)hw->addr.start;\n\t\thw->hscx.a.io.port = (u32)hw->addr.start + 1;\n\t\thw->hscx.mode = hw->addr.mode;\n\t\tbreak;\n\tcase INF_NICCY:\n\t\thw->ipac.type = IPAC_TYPE_ISAC | IPAC_TYPE_HSCX;\n\t\thw->isac.mode = hw->addr.mode;\n\t\thw->isac.a.io.ale = (u32)hw->addr.start + NICCY_ISAC_ALE;\n\t\thw->isac.a.io.port = (u32)hw->addr.start + NICCY_ISAC_PORT;\n\t\thw->hscx.mode = hw->addr.mode;\n\t\thw->hscx.a.io.ale = (u32)hw->addr.start + NICCY_HSCX_ALE;\n\t\thw->hscx.a.io.port = (u32)hw->addr.start + NICCY_HSCX_PORT;\n\t\tbreak;\n\tcase INF_SCT_1:\n\t\thw->ipac.type = IPAC_TYPE_IPAC;\n\t\thw->ipac.isac.off = 0x80;\n\t\thw->isac.a.io.ale = (u32)hw->addr.start;\n\t\thw->isac.a.io.port = hw->isac.a.io.ale + 4;\n\t\thw->isac.mode = hw->addr.mode;\n\t\thw->hscx.a.io.ale = hw->isac.a.io.ale;\n\t\thw->hscx.a.io.port = hw->isac.a.io.port;\n\t\thw->hscx.mode = hw->addr.mode;\n\t\tbreak;\n\tcase INF_SCT_2:\n\t\thw->ipac.type = IPAC_TYPE_IPAC;\n\t\thw->ipac.isac.off = 0x80;\n\t\thw->isac.a.io.ale = (u32)hw->addr.start + 0x08;\n\t\thw->isac.a.io.port = hw->isac.a.io.ale + 4;\n\t\thw->isac.mode = hw->addr.mode;\n\t\thw->hscx.a.io.ale = hw->isac.a.io.ale;\n\t\thw->hscx.a.io.port = hw->isac.a.io.port;\n\t\thw->hscx.mode = hw->addr.mode;\n\t\tbreak;\n\tcase INF_SCT_3:\n\t\thw->ipac.type = IPAC_TYPE_IPAC;\n\t\thw->ipac.isac.off = 0x80;\n\t\thw->isac.a.io.ale = (u32)hw->addr.start + 0x10;\n\t\thw->isac.a.io.port = hw->isac.a.io.ale + 4;\n\t\thw->isac.mode = hw->addr.mode;\n\t\thw->hscx.a.io.ale = hw->isac.a.io.ale;\n\t\thw->hscx.a.io.port = hw->isac.a.io.port;\n\t\thw->hscx.mode = hw->addr.mode;\n\t\tbreak;\n\tcase INF_SCT_4:\n\t\thw->ipac.type = IPAC_TYPE_IPAC;\n\t\thw->ipac.isac.off = 0x80;\n\t\thw->isac.a.io.ale = (u32)hw->addr.start + 0x20;\n\t\thw->isac.a.io.port = hw->isac.a.io.ale + 4;\n\t\thw->isac.mode = hw->addr.mode;\n\t\thw->hscx.a.io.ale = hw->isac.a.io.ale;\n\t\thw->hscx.a.io.port = hw->isac.a.io.port;\n\t\thw->hscx.mode = hw->addr.mode;\n\t\tbreak;\n\tcase INF_GAZEL_R685:\n\t\thw->ipac.type = IPAC_TYPE_ISAC | IPAC_TYPE_HSCX;\n\t\thw->ipac.isac.off = 0x80;\n\t\thw->isac.mode = hw->addr.mode;\n\t\thw->isac.a.io.port = (u32)hw->addr.start;\n\t\thw->hscx.mode = hw->addr.mode;\n\t\thw->hscx.a.io.port = hw->isac.a.io.port;\n\t\tbreak;\n\tcase INF_GAZEL_R753:\n\t\thw->ipac.type = IPAC_TYPE_IPAC;\n\t\thw->ipac.isac.off = 0x80;\n\t\thw->isac.mode = hw->addr.mode;\n\t\thw->isac.a.io.ale = (u32)hw->addr.start;\n\t\thw->isac.a.io.port = (u32)hw->addr.start + GAZEL_IPAC_DATA_PORT;\n\t\thw->hscx.mode = hw->addr.mode;\n\t\thw->hscx.a.io.ale = hw->isac.a.io.ale;\n\t\thw->hscx.a.io.port = hw->isac.a.io.port;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tswitch (hw->isac.mode) {\n\tcase AM_MEMIO:\n\t\tASSIGN_FUNC_IPAC(MIO, hw->ipac);\n\t\tbreak;\n\tcase AM_IND_IO:\n\t\tASSIGN_FUNC_IPAC(IND, hw->ipac);\n\t\tbreak;\n\tcase AM_IO:\n\t\tASSIGN_FUNC_IPAC(IO, hw->ipac);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic void\nrelease_card(struct inf_hw *card) {\n\tulong\tflags;\n\tint\ti;\n\n\tspin_lock_irqsave(&card->lock, flags);\n\tdisable_hwirq(card);\n\tspin_unlock_irqrestore(&card->lock, flags);\n\tcard->ipac.isac.release(&card->ipac.isac);\n\tfree_irq(card->irq, card);\n\tmISDN_unregister_device(&card->ipac.isac.dch.dev);\n\trelease_io(card);\n\twrite_lock_irqsave(&card_lock, flags);\n\tlist_del(&card->list);\n\twrite_unlock_irqrestore(&card_lock, flags);\n\tswitch (card->ci->typ) {\n\tcase INF_SCT_2:\n\tcase INF_SCT_3:\n\tcase INF_SCT_4:\n\t\tbreak;\n\tcase INF_SCT_1:\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tif (card->sc[i])\n\t\t\t\trelease_card(card->sc[i]);\n\t\t\tcard->sc[i] = NULL;\n\t\t}\n\t\tfallthrough;\n\tdefault:\n\t\tpci_disable_device(card->pdev);\n\t\tpci_set_drvdata(card->pdev, NULL);\n\t\tbreak;\n\t}\n\tkfree(card);\n\tinf_cnt--;\n}\n\nstatic int\nsetup_instance(struct inf_hw *card)\n{\n\tint err;\n\tulong flags;\n\n\tsnprintf(card->name, MISDN_MAX_IDLEN - 1, \"%s.%d\", card->ci->name,\n\t\t inf_cnt + 1);\n\twrite_lock_irqsave(&card_lock, flags);\n\tlist_add_tail(&card->list, &Cards);\n\twrite_unlock_irqrestore(&card_lock, flags);\n\n\t_set_debug(card);\n\tcard->ipac.isac.name = card->name;\n\tcard->ipac.name = card->name;\n\tcard->ipac.owner = THIS_MODULE;\n\tspin_lock_init(&card->lock);\n\tcard->ipac.isac.hwlock = &card->lock;\n\tcard->ipac.hwlock = &card->lock;\n\tcard->ipac.ctrl = (void *)&inf_ctrl;\n\n\terr = setup_io(card);\n\tif (err)\n\t\tgoto error_setup;\n\n\tcard->ipac.isac.dch.dev.Bprotocols =\n\t\tmISDNipac_init(&card->ipac, card);\n\n\tif (card->ipac.isac.dch.dev.Bprotocols == 0)\n\t\tgoto error_setup;\n\n\terr = mISDN_register_device(&card->ipac.isac.dch.dev,\n\t\t\t\t    &card->pdev->dev, card->name);\n\tif (err)\n\t\tgoto error;\n\n\terr = init_irq(card);\n\tif (!err)  {\n\t\tinf_cnt++;\n\t\tpr_notice(\"Infineon %d cards installed\\n\", inf_cnt);\n\t\treturn 0;\n\t}\n\tmISDN_unregister_device(&card->ipac.isac.dch.dev);\nerror:\n\tcard->ipac.release(&card->ipac);\nerror_setup:\n\trelease_io(card);\n\twrite_lock_irqsave(&card_lock, flags);\n\tlist_del(&card->list);\n\twrite_unlock_irqrestore(&card_lock, flags);\n\treturn err;\n}\n\nstatic const struct inf_cinfo inf_card_info[] = {\n\t{\n\t\tINF_DIVA20,\n\t\t\"Dialogic Diva 2.0\",\n\t\t\"diva20\",\n\t\tAM_IND_IO, AM_NONE, 2, 0,\n\t\t&diva_irq\n\t},\n\t{\n\t\tINF_DIVA20U,\n\t\t\"Dialogic Diva 2.0U\",\n\t\t\"diva20U\",\n\t\tAM_IND_IO, AM_NONE, 2, 0,\n\t\t&diva_irq\n\t},\n\t{\n\t\tINF_DIVA201,\n\t\t\"Dialogic Diva 2.01\",\n\t\t\"diva201\",\n\t\tAM_MEMIO, AM_MEMIO, 0, 1,\n\t\t&diva20x_irq\n\t},\n\t{\n\t\tINF_DIVA202,\n\t\t\"Dialogic Diva 2.02\",\n\t\t\"diva202\",\n\t\tAM_MEMIO, AM_MEMIO, 0, 1,\n\t\t&diva20x_irq\n\t},\n\t{\n\t\tINF_SPEEDWIN,\n\t\t\"Sedlbauer SpeedWin PCI\",\n\t\t\"speedwin\",\n\t\tAM_IND_IO, AM_NONE, 0, 0,\n\t\t&tiger_irq\n\t},\n\t{\n\t\tINF_SAPHIR3,\n\t\t\"HST Saphir 3\",\n\t\t\"saphir\",\n\t\tAM_IND_IO, AM_NONE, 0, 0,\n\t\t&tiger_irq\n\t},\n\t{\n\t\tINF_QS1000,\n\t\t\"Develo Microlink PCI\",\n\t\t\"qs1000\",\n\t\tAM_IO, AM_IND_IO, 1, 3,\n\t\t&elsa_irq\n\t},\n\t{\n\t\tINF_QS3000,\n\t\t\"Develo QuickStep 3000\",\n\t\t\"qs3000\",\n\t\tAM_IO, AM_IND_IO, 1, 3,\n\t\t&elsa_irq\n\t},\n\t{\n\t\tINF_NICCY,\n\t\t\"Sagem NICCY\",\n\t\t\"niccy\",\n\t\tAM_IO, AM_IND_IO, 0, 1,\n\t\t&niccy_irq\n\t},\n\t{\n\t\tINF_SCT_1,\n\t\t\"SciTel Quadro\",\n\t\t\"p1_scitel\",\n\t\tAM_IO, AM_IND_IO, 1, 5,\n\t\t&ipac_irq\n\t},\n\t{\n\t\tINF_SCT_2,\n\t\t\"SciTel Quadro\",\n\t\t\"p2_scitel\",\n\t\tAM_NONE, AM_IND_IO, 0, 4,\n\t\t&ipac_irq\n\t},\n\t{\n\t\tINF_SCT_3,\n\t\t\"SciTel Quadro\",\n\t\t\"p3_scitel\",\n\t\tAM_NONE, AM_IND_IO, 0, 3,\n\t\t&ipac_irq\n\t},\n\t{\n\t\tINF_SCT_4,\n\t\t\"SciTel Quadro\",\n\t\t\"p4_scitel\",\n\t\tAM_NONE, AM_IND_IO, 0, 2,\n\t\t&ipac_irq\n\t},\n\t{\n\t\tINF_GAZEL_R685,\n\t\t\"Gazel R685\",\n\t\t\"gazel685\",\n\t\tAM_IO, AM_IO, 1, 2,\n\t\t&gazel_irq\n\t},\n\t{\n\t\tINF_GAZEL_R753,\n\t\t\"Gazel R753\",\n\t\t\"gazel753\",\n\t\tAM_IO, AM_IND_IO, 1, 2,\n\t\t&ipac_irq\n\t},\n\t{\n\t\tINF_NONE,\n\t}\n};\n\nstatic const struct inf_cinfo *\nget_card_info(enum inf_types typ)\n{\n\tconst struct inf_cinfo *ci = inf_card_info;\n\n\twhile (ci->typ != INF_NONE) {\n\t\tif (ci->typ == typ)\n\t\t\treturn ci;\n\t\tci++;\n\t}\n\treturn NULL;\n}\n\nstatic int\ninf_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tint err = -ENOMEM;\n\tstruct inf_hw *card;\n\n\tcard = kzalloc(sizeof(struct inf_hw), GFP_KERNEL);\n\tif (!card) {\n\t\tpr_info(\"No memory for Infineon ISDN card\\n\");\n\t\treturn err;\n\t}\n\tcard->pdev = pdev;\n\terr = pci_enable_device(pdev);\n\tif (err) {\n\t\tkfree(card);\n\t\treturn err;\n\t}\n\tcard->ci = get_card_info(ent->driver_data);\n\tif (!card->ci) {\n\t\tpr_info(\"mISDN: do not have information about adapter at %s\\n\",\n\t\t\tpci_name(pdev));\n\t\tkfree(card);\n\t\tpci_disable_device(pdev);\n\t\treturn -EINVAL;\n\t} else\n\t\tpr_notice(\"mISDN: found adapter %s at %s\\n\",\n\t\t\t  card->ci->full, pci_name(pdev));\n\n\tcard->irq = pdev->irq;\n\tpci_set_drvdata(pdev, card);\n\terr = setup_instance(card);\n\tif (err) {\n\t\tpci_disable_device(pdev);\n\t\tkfree(card);\n\t\tpci_set_drvdata(pdev, NULL);\n\t} else if (ent->driver_data == INF_SCT_1) {\n\t\tint i;\n\t\tstruct inf_hw *sc;\n\n\t\tfor (i = 1; i < 4; i++) {\n\t\t\tsc = kzalloc(sizeof(struct inf_hw), GFP_KERNEL);\n\t\t\tif (!sc) {\n\t\t\t\trelease_card(card);\n\t\t\t\tpci_disable_device(pdev);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tsc->irq = card->irq;\n\t\t\tsc->pdev = card->pdev;\n\t\t\tsc->ci = card->ci + i;\n\t\t\terr = setup_instance(sc);\n\t\t\tif (err) {\n\t\t\t\tpci_disable_device(pdev);\n\t\t\t\tkfree(sc);\n\t\t\t\trelease_card(card);\n\t\t\t\tbreak;\n\t\t\t} else\n\t\t\t\tcard->sc[i - 1] = sc;\n\t\t}\n\t}\n\treturn err;\n}\n\nstatic void\ninf_remove(struct pci_dev *pdev)\n{\n\tstruct inf_hw\t*card = pci_get_drvdata(pdev);\n\n\tif (card)\n\t\trelease_card(card);\n\telse\n\t\tpr_debug(\"%s: drvdata already removed\\n\", __func__);\n}\n\nstatic struct pci_driver infineon_driver = {\n\t.name = \"ISDN Infineon pci\",\n\t.probe = inf_probe,\n\t.remove = inf_remove,\n\t.id_table = infineon_ids,\n};\n\nstatic int __init\ninfineon_init(void)\n{\n\tint err;\n\n\tpr_notice(\"Infineon ISDN Driver Rev. %s\\n\", INFINEON_REV);\n\terr = pci_register_driver(&infineon_driver);\n\treturn err;\n}\n\nstatic void __exit\ninfineon_cleanup(void)\n{\n\tpci_unregister_driver(&infineon_driver);\n}\n\nmodule_init(infineon_init);\nmodule_exit(infineon_cleanup);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}