{
  "module_name": "hfcpci.c",
  "hash_id": "ef306039e6f767b2f454d31c7c4fcd7d583f979afa5915752e240d72ef469365",
  "original_prompt": "Ingested from linux-6.6.14/drivers/isdn/hardware/mISDN/hfcpci.c",
  "human_readable_source": "\n \n\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/delay.h>\n#include <linux/mISDNhw.h>\n#include <linux/slab.h>\n\n#include \"hfc_pci.h\"\n\nstatic const char *hfcpci_revision = \"2.0\";\n\nstatic int HFC_cnt;\nstatic uint debug;\nstatic uint poll, tics;\nstatic struct timer_list hfc_tl;\nstatic unsigned long hfc_jiffies;\n\nMODULE_AUTHOR(\"Karsten Keil\");\nMODULE_LICENSE(\"GPL\");\nmodule_param(debug, uint, S_IRUGO | S_IWUSR);\nmodule_param(poll, uint, S_IRUGO | S_IWUSR);\n\nenum {\n\tHFC_CCD_2BD0,\n\tHFC_CCD_B000,\n\tHFC_CCD_B006,\n\tHFC_CCD_B007,\n\tHFC_CCD_B008,\n\tHFC_CCD_B009,\n\tHFC_CCD_B00A,\n\tHFC_CCD_B00B,\n\tHFC_CCD_B00C,\n\tHFC_CCD_B100,\n\tHFC_CCD_B700,\n\tHFC_CCD_B701,\n\tHFC_ASUS_0675,\n\tHFC_BERKOM_A1T,\n\tHFC_BERKOM_TCONCEPT,\n\tHFC_ANIGMA_MC145575,\n\tHFC_ZOLTRIX_2BD0,\n\tHFC_DIGI_DF_M_IOM2_E,\n\tHFC_DIGI_DF_M_E,\n\tHFC_DIGI_DF_M_IOM2_A,\n\tHFC_DIGI_DF_M_A,\n\tHFC_ABOCOM_2BD1,\n\tHFC_SITECOM_DC105V2,\n};\n\nstruct hfcPCI_hw {\n\tunsigned char\t\tcirm;\n\tunsigned char\t\tctmt;\n\tunsigned char\t\tclkdel;\n\tunsigned char\t\tstates;\n\tunsigned char\t\tconn;\n\tunsigned char\t\tmst_m;\n\tunsigned char\t\tint_m1;\n\tunsigned char\t\tint_m2;\n\tunsigned char\t\tsctrl;\n\tunsigned char\t\tsctrl_r;\n\tunsigned char\t\tsctrl_e;\n\tunsigned char\t\ttrm;\n\tunsigned char\t\tfifo_en;\n\tunsigned char\t\tbswapped;\n\tunsigned char\t\tprotocol;\n\tint\t\t\tnt_timer;\n\tunsigned char __iomem\t*pci_io;  \n\tdma_addr_t\t\tdmahandle;\n\tvoid\t\t\t*fifos;  \n\tint\t\t\tlast_bfifo_cnt[2];\n\t \n\tstruct timer_list\ttimer;\n};\n\n#define\tHFC_CFG_MASTER\t\t1\n#define HFC_CFG_SLAVE\t\t2\n#define\tHFC_CFG_PCM\t\t3\n#define HFC_CFG_2HFC\t\t4\n#define HFC_CFG_SLAVEHFC\t5\n#define HFC_CFG_NEG_F0\t\t6\n#define HFC_CFG_SW_DD_DU\t7\n\n#define FLG_HFC_TIMER_T1\t16\n#define FLG_HFC_TIMER_T3\t17\n\n#define NT_T1_COUNT\t1120\t \n#define NT_T3_COUNT\t31\t \n#define CLKDEL_TE\t0x0e\t \n#define CLKDEL_NT\t0x6c\t \n\n\nstruct hfc_pci {\n\tu_char\t\t\tsubtype;\n\tu_char\t\t\tchanlimit;\n\tu_char\t\t\tinitdone;\n\tu_long\t\t\tcfg;\n\tu_int\t\t\tirq;\n\tu_int\t\t\tirqcnt;\n\tstruct pci_dev\t\t*pdev;\n\tstruct hfcPCI_hw\thw;\n\tspinlock_t\t\tlock;\t \n\tstruct dchannel\t\tdch;\n\tstruct bchannel\t\tbch[2];\n};\n\n \nstatic void\nenable_hwirq(struct hfc_pci *hc)\n{\n\thc->hw.int_m2 |= HFCPCI_IRQ_ENABLE;\n\tWrite_hfc(hc, HFCPCI_INT_M2, hc->hw.int_m2);\n}\n\nstatic void\ndisable_hwirq(struct hfc_pci *hc)\n{\n\thc->hw.int_m2 &= ~((u_char)HFCPCI_IRQ_ENABLE);\n\tWrite_hfc(hc, HFCPCI_INT_M2, hc->hw.int_m2);\n}\n\n \nstatic void\nrelease_io_hfcpci(struct hfc_pci *hc)\n{\n\t \n\tpci_write_config_word(hc->pdev, PCI_COMMAND, 0);\n\tdel_timer(&hc->hw.timer);\n\tdma_free_coherent(&hc->pdev->dev, 0x8000, hc->hw.fifos,\n\t\t\t  hc->hw.dmahandle);\n\tiounmap(hc->hw.pci_io);\n}\n\n \nstatic void\nhfcpci_setmode(struct hfc_pci *hc)\n{\n\tif (hc->hw.protocol == ISDN_P_NT_S0) {\n\t\thc->hw.clkdel = CLKDEL_NT;\t \n\t\thc->hw.sctrl |= SCTRL_MODE_NT;\t \n\t\thc->hw.states = 1;\t\t \n\t} else {\n\t\thc->hw.clkdel = CLKDEL_TE;\t \n\t\thc->hw.sctrl &= ~SCTRL_MODE_NT;\t \n\t\thc->hw.states = 2;\t\t \n\t}\n\tWrite_hfc(hc, HFCPCI_CLKDEL, hc->hw.clkdel);\n\tWrite_hfc(hc, HFCPCI_STATES, HFCPCI_LOAD_STATE | hc->hw.states);\n\tudelay(10);\n\tWrite_hfc(hc, HFCPCI_STATES, hc->hw.states | 0x40);  \n\tWrite_hfc(hc, HFCPCI_SCTRL, hc->hw.sctrl);\n}\n\n \nstatic void\nreset_hfcpci(struct hfc_pci *hc)\n{\n\tu_char\tval;\n\tint\tcnt = 0;\n\n\tprintk(KERN_DEBUG \"reset_hfcpci: entered\\n\");\n\tval = Read_hfc(hc, HFCPCI_CHIP_ID);\n\tprintk(KERN_INFO \"HFC_PCI: resetting HFC ChipId(%x)\\n\", val);\n\t \n\tpci_write_config_word(hc->pdev, PCI_COMMAND, PCI_ENA_MEMIO);\n\tdisable_hwirq(hc);\n\t \n\tpci_write_config_word(hc->pdev, PCI_COMMAND,\n\t\t\t      PCI_ENA_MEMIO + PCI_ENA_MASTER);\n\tval = Read_hfc(hc, HFCPCI_STATUS);\n\tprintk(KERN_DEBUG \"HFC-PCI status(%x) before reset\\n\", val);\n\thc->hw.cirm = HFCPCI_RESET;\t \n\tWrite_hfc(hc, HFCPCI_CIRM, hc->hw.cirm);\n\tset_current_state(TASK_UNINTERRUPTIBLE);\n\tmdelay(10);\t\t\t \n\thc->hw.cirm = 0;\t\t \n\tWrite_hfc(hc, HFCPCI_CIRM, hc->hw.cirm);\n\tval = Read_hfc(hc, HFCPCI_STATUS);\n\tprintk(KERN_DEBUG \"HFC-PCI status(%x) after reset\\n\", val);\n\twhile (cnt < 50000) {  \n\t\tudelay(5);\n\t\tcnt += 5;\n\t\tval = Read_hfc(hc, HFCPCI_STATUS);\n\t\tif (!(val & 2))\n\t\t\tbreak;\n\t}\n\tprintk(KERN_DEBUG \"HFC-PCI status(%x) after %dus\\n\", val, cnt);\n\n\thc->hw.fifo_en = 0x30;\t \n\n\thc->hw.bswapped = 0;\t \n\thc->hw.ctmt = HFCPCI_TIM3_125 | HFCPCI_AUTO_TIMER;\n\thc->hw.trm = HFCPCI_BTRANS_THRESMASK;  \n\thc->hw.sctrl = 0x40;\t \n\thc->hw.sctrl_r = 0;\n\thc->hw.sctrl_e = HFCPCI_AUTO_AWAKE;\t \n\thc->hw.mst_m = 0;\n\tif (test_bit(HFC_CFG_MASTER, &hc->cfg))\n\t\thc->hw.mst_m |= HFCPCI_MASTER;\t \n\tif (test_bit(HFC_CFG_NEG_F0, &hc->cfg))\n\t\thc->hw.mst_m |= HFCPCI_F0_NEGATIV;\n\tWrite_hfc(hc, HFCPCI_FIFO_EN, hc->hw.fifo_en);\n\tWrite_hfc(hc, HFCPCI_TRM, hc->hw.trm);\n\tWrite_hfc(hc, HFCPCI_SCTRL_E, hc->hw.sctrl_e);\n\tWrite_hfc(hc, HFCPCI_CTMT, hc->hw.ctmt);\n\n\thc->hw.int_m1 = HFCPCI_INTS_DTRANS | HFCPCI_INTS_DREC |\n\t\tHFCPCI_INTS_L1STATE | HFCPCI_INTS_TIMER;\n\tWrite_hfc(hc, HFCPCI_INT_M1, hc->hw.int_m1);\n\n\t \n\tval = Read_hfc(hc, HFCPCI_INT_S1);\n\n\t \n\thfcpci_setmode(hc);\n\n\tWrite_hfc(hc, HFCPCI_MST_MODE, hc->hw.mst_m);\n\tWrite_hfc(hc, HFCPCI_SCTRL_R, hc->hw.sctrl_r);\n\n\t \n\tif (test_bit(HFC_CFG_PCM, &hc->cfg)) {\n\t\t \n\t\thc->hw.conn = 0x09;\n\t} else {\n\t\thc->hw.conn = 0x36;\t \n\t\tif (test_bit(HFC_CFG_SW_DD_DU, &hc->cfg)) {\n\t\t\tWrite_hfc(hc, HFCPCI_B1_SSL, 0xC0);\n\t\t\tWrite_hfc(hc, HFCPCI_B2_SSL, 0xC1);\n\t\t\tWrite_hfc(hc, HFCPCI_B1_RSL, 0xC0);\n\t\t\tWrite_hfc(hc, HFCPCI_B2_RSL, 0xC1);\n\t\t} else {\n\t\t\tWrite_hfc(hc, HFCPCI_B1_SSL, 0x80);\n\t\t\tWrite_hfc(hc, HFCPCI_B2_SSL, 0x81);\n\t\t\tWrite_hfc(hc, HFCPCI_B1_RSL, 0x80);\n\t\t\tWrite_hfc(hc, HFCPCI_B2_RSL, 0x81);\n\t\t}\n\t}\n\tWrite_hfc(hc, HFCPCI_CONNECT, hc->hw.conn);\n\tval = Read_hfc(hc, HFCPCI_INT_S2);\n}\n\n \nstatic void\nhfcpci_Timer(struct timer_list *t)\n{\n\tstruct hfc_pci *hc = from_timer(hc, t, hw.timer);\n\thc->hw.timer.expires = jiffies + 75;\n\t \n \n}\n\n\n \nstatic struct bchannel *\nSel_BCS(struct hfc_pci *hc, int channel)\n{\n\tif (test_bit(FLG_ACTIVE, &hc->bch[0].Flags) &&\n\t    (hc->bch[0].nr & channel))\n\t\treturn &hc->bch[0];\n\telse if (test_bit(FLG_ACTIVE, &hc->bch[1].Flags) &&\n\t\t (hc->bch[1].nr & channel))\n\t\treturn &hc->bch[1];\n\telse\n\t\treturn NULL;\n}\n\n \nstatic void\nhfcpci_clear_fifo_rx(struct hfc_pci *hc, int fifo)\n{\n\tu_char\t\tfifo_state;\n\tstruct bzfifo\t*bzr;\n\n\tif (fifo) {\n\t\tbzr = &((union fifo_area *)(hc->hw.fifos))->b_chans.rxbz_b2;\n\t\tfifo_state = hc->hw.fifo_en & HFCPCI_FIFOEN_B2RX;\n\t} else {\n\t\tbzr = &((union fifo_area *)(hc->hw.fifos))->b_chans.rxbz_b1;\n\t\tfifo_state = hc->hw.fifo_en & HFCPCI_FIFOEN_B1RX;\n\t}\n\tif (fifo_state)\n\t\thc->hw.fifo_en ^= fifo_state;\n\tWrite_hfc(hc, HFCPCI_FIFO_EN, hc->hw.fifo_en);\n\thc->hw.last_bfifo_cnt[fifo] = 0;\n\tbzr->f1 = MAX_B_FRAMES;\n\tbzr->f2 = bzr->f1;\t \n\tbzr->za[MAX_B_FRAMES].z1 = cpu_to_le16(B_FIFO_SIZE + B_SUB_VAL - 1);\n\tbzr->za[MAX_B_FRAMES].z2 = cpu_to_le16(\n\t\tle16_to_cpu(bzr->za[MAX_B_FRAMES].z1));\n\tif (fifo_state)\n\t\thc->hw.fifo_en |= fifo_state;\n\tWrite_hfc(hc, HFCPCI_FIFO_EN, hc->hw.fifo_en);\n}\n\n \nstatic void hfcpci_clear_fifo_tx(struct hfc_pci *hc, int fifo)\n{\n\tu_char\t\tfifo_state;\n\tstruct bzfifo\t*bzt;\n\n\tif (fifo) {\n\t\tbzt = &((union fifo_area *)(hc->hw.fifos))->b_chans.txbz_b2;\n\t\tfifo_state = hc->hw.fifo_en & HFCPCI_FIFOEN_B2TX;\n\t} else {\n\t\tbzt = &((union fifo_area *)(hc->hw.fifos))->b_chans.txbz_b1;\n\t\tfifo_state = hc->hw.fifo_en & HFCPCI_FIFOEN_B1TX;\n\t}\n\tif (fifo_state)\n\t\thc->hw.fifo_en ^= fifo_state;\n\tWrite_hfc(hc, HFCPCI_FIFO_EN, hc->hw.fifo_en);\n\tif (hc->bch[fifo].debug & DEBUG_HW_BCHANNEL)\n\t\tprintk(KERN_DEBUG \"hfcpci_clear_fifo_tx%d f1(%x) f2(%x) \"\n\t\t       \"z1(%x) z2(%x) state(%x)\\n\",\n\t\t       fifo, bzt->f1, bzt->f2,\n\t\t       le16_to_cpu(bzt->za[MAX_B_FRAMES].z1),\n\t\t       le16_to_cpu(bzt->za[MAX_B_FRAMES].z2),\n\t\t       fifo_state);\n\tbzt->f2 = MAX_B_FRAMES;\n\tbzt->f1 = bzt->f2;\t \n\tbzt->za[MAX_B_FRAMES].z1 = cpu_to_le16(B_FIFO_SIZE + B_SUB_VAL - 1);\n\tbzt->za[MAX_B_FRAMES].z2 = cpu_to_le16(B_FIFO_SIZE + B_SUB_VAL - 2);\n\tif (fifo_state)\n\t\thc->hw.fifo_en |= fifo_state;\n\tWrite_hfc(hc, HFCPCI_FIFO_EN, hc->hw.fifo_en);\n\tif (hc->bch[fifo].debug & DEBUG_HW_BCHANNEL)\n\t\tprintk(KERN_DEBUG\n\t\t       \"hfcpci_clear_fifo_tx%d f1(%x) f2(%x) z1(%x) z2(%x)\\n\",\n\t\t       fifo, bzt->f1, bzt->f2,\n\t\t       le16_to_cpu(bzt->za[MAX_B_FRAMES].z1),\n\t\t       le16_to_cpu(bzt->za[MAX_B_FRAMES].z2));\n}\n\n \nstatic void\nhfcpci_empty_bfifo(struct bchannel *bch, struct bzfifo *bz,\n\t\t   u_char *bdata, int count)\n{\n\tu_char\t\t*ptr, *ptr1, new_f2;\n\tint\t\tmaxlen, new_z2;\n\tstruct zt\t*zp;\n\n\tif ((bch->debug & DEBUG_HW_BCHANNEL) && !(bch->debug & DEBUG_HW_BFIFO))\n\t\tprintk(KERN_DEBUG \"hfcpci_empty_fifo\\n\");\n\tzp = &bz->za[bz->f2];\t \n\tnew_z2 = le16_to_cpu(zp->z2) + count;\t \n\tif (new_z2 >= (B_FIFO_SIZE + B_SUB_VAL))\n\t\tnew_z2 -= B_FIFO_SIZE;\t \n\tnew_f2 = (bz->f2 + 1) & MAX_B_FRAMES;\n\tif ((count > MAX_DATA_SIZE + 3) || (count < 4) ||\n\t    (*(bdata + (le16_to_cpu(zp->z1) - B_SUB_VAL)))) {\n\t\tif (bch->debug & DEBUG_HW)\n\t\t\tprintk(KERN_DEBUG \"hfcpci_empty_fifo: incoming packet \"\n\t\t\t       \"invalid length %d or crc\\n\", count);\n#ifdef ERROR_STATISTIC\n\t\tbch->err_inv++;\n#endif\n\t\tbz->za[new_f2].z2 = cpu_to_le16(new_z2);\n\t\tbz->f2 = new_f2;\t \n\t} else {\n\t\tbch->rx_skb = mI_alloc_skb(count - 3, GFP_ATOMIC);\n\t\tif (!bch->rx_skb) {\n\t\t\tprintk(KERN_WARNING \"HFCPCI: receive out of memory\\n\");\n\t\t\treturn;\n\t\t}\n\t\tcount -= 3;\n\t\tptr = skb_put(bch->rx_skb, count);\n\n\t\tif (le16_to_cpu(zp->z2) + count <= B_FIFO_SIZE + B_SUB_VAL)\n\t\t\tmaxlen = count;\t\t \n\t\telse\n\t\t\tmaxlen = B_FIFO_SIZE + B_SUB_VAL -\n\t\t\t\tle16_to_cpu(zp->z2);\t \n\n\t\tptr1 = bdata + (le16_to_cpu(zp->z2) - B_SUB_VAL);\n\t\t \n\t\tmemcpy(ptr, ptr1, maxlen);\t \n\t\tcount -= maxlen;\n\n\t\tif (count) {\t \n\t\t\tptr += maxlen;\n\t\t\tptr1 = bdata;\t \n\t\t\tmemcpy(ptr, ptr1, count);\t \n\t\t}\n\t\tbz->za[new_f2].z2 = cpu_to_le16(new_z2);\n\t\tbz->f2 = new_f2;\t \n\t\trecv_Bchannel(bch, MISDN_ID_ANY, false);\n\t}\n}\n\n \nstatic int\nreceive_dmsg(struct hfc_pci *hc)\n{\n\tstruct dchannel\t*dch = &hc->dch;\n\tint\t\tmaxlen;\n\tint\t\trcnt, total;\n\tint\t\tcount = 5;\n\tu_char\t\t*ptr, *ptr1;\n\tstruct dfifo\t*df;\n\tstruct zt\t*zp;\n\n\tdf = &((union fifo_area *)(hc->hw.fifos))->d_chan.d_rx;\n\twhile (((df->f1 & D_FREG_MASK) != (df->f2 & D_FREG_MASK)) && count--) {\n\t\tzp = &df->za[df->f2 & D_FREG_MASK];\n\t\trcnt = le16_to_cpu(zp->z1) - le16_to_cpu(zp->z2);\n\t\tif (rcnt < 0)\n\t\t\trcnt += D_FIFO_SIZE;\n\t\trcnt++;\n\t\tif (dch->debug & DEBUG_HW_DCHANNEL)\n\t\t\tprintk(KERN_DEBUG\n\t\t\t       \"hfcpci recd f1(%d) f2(%d) z1(%x) z2(%x) cnt(%d)\\n\",\n\t\t\t       df->f1, df->f2,\n\t\t\t       le16_to_cpu(zp->z1),\n\t\t\t       le16_to_cpu(zp->z2),\n\t\t\t       rcnt);\n\n\t\tif ((rcnt > MAX_DFRAME_LEN + 3) || (rcnt < 4) ||\n\t\t    (df->data[le16_to_cpu(zp->z1)])) {\n\t\t\tif (dch->debug & DEBUG_HW)\n\t\t\t\tprintk(KERN_DEBUG\n\t\t\t\t       \"empty_fifo hfcpci packet inv. len \"\n\t\t\t\t       \"%d or crc %d\\n\",\n\t\t\t\t       rcnt,\n\t\t\t\t       df->data[le16_to_cpu(zp->z1)]);\n#ifdef ERROR_STATISTIC\n\t\t\tcs->err_rx++;\n#endif\n\t\t\tdf->f2 = ((df->f2 + 1) & MAX_D_FRAMES) |\n\t\t\t\t(MAX_D_FRAMES + 1);\t \n\t\t\tdf->za[df->f2 & D_FREG_MASK].z2 =\n\t\t\t\tcpu_to_le16((le16_to_cpu(zp->z2) + rcnt) &\n\t\t\t\t\t    (D_FIFO_SIZE - 1));\n\t\t} else {\n\t\t\tdch->rx_skb = mI_alloc_skb(rcnt - 3, GFP_ATOMIC);\n\t\t\tif (!dch->rx_skb) {\n\t\t\t\tprintk(KERN_WARNING\n\t\t\t\t       \"HFC-PCI: D receive out of memory\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttotal = rcnt;\n\t\t\trcnt -= 3;\n\t\t\tptr = skb_put(dch->rx_skb, rcnt);\n\n\t\t\tif (le16_to_cpu(zp->z2) + rcnt <= D_FIFO_SIZE)\n\t\t\t\tmaxlen = rcnt;\t \n\t\t\telse\n\t\t\t\tmaxlen = D_FIFO_SIZE - le16_to_cpu(zp->z2);\n\t\t\t \n\n\t\t\tptr1 = df->data + le16_to_cpu(zp->z2);\n\t\t\t \n\t\t\tmemcpy(ptr, ptr1, maxlen);\t \n\t\t\trcnt -= maxlen;\n\n\t\t\tif (rcnt) {\t \n\t\t\t\tptr += maxlen;\n\t\t\t\tptr1 = df->data;\t \n\t\t\t\tmemcpy(ptr, ptr1, rcnt);\t \n\t\t\t}\n\t\t\tdf->f2 = ((df->f2 + 1) & MAX_D_FRAMES) |\n\t\t\t\t(MAX_D_FRAMES + 1);\t \n\t\t\tdf->za[df->f2 & D_FREG_MASK].z2 = cpu_to_le16((\n\t\t\t\t\t\t\t\t\t      le16_to_cpu(zp->z2) + total) & (D_FIFO_SIZE - 1));\n\t\t\trecv_Dchannel(dch);\n\t\t}\n\t}\n\treturn 1;\n}\n\n \nstatic void\nhfcpci_empty_fifo_trans(struct bchannel *bch, struct bzfifo *rxbz,\n\t\t\tstruct bzfifo *txbz, u_char *bdata)\n{\n\t__le16\t*z1r, *z2r, *z1t, *z2t;\n\tint\tnew_z2, fcnt_rx, fcnt_tx, maxlen;\n\tu_char\t*ptr, *ptr1;\n\n\tz1r = &rxbz->za[MAX_B_FRAMES].z1;\t \n\tz2r = z1r + 1;\n\tz1t = &txbz->za[MAX_B_FRAMES].z1;\n\tz2t = z1t + 1;\n\n\tfcnt_rx = le16_to_cpu(*z1r) - le16_to_cpu(*z2r);\n\tif (!fcnt_rx)\n\t\treturn;\t \n\n\tif (fcnt_rx <= 0)\n\t\tfcnt_rx += B_FIFO_SIZE;\t \n\tnew_z2 = le16_to_cpu(*z2r) + fcnt_rx;\t \n\tif (new_z2 >= (B_FIFO_SIZE + B_SUB_VAL))\n\t\tnew_z2 -= B_FIFO_SIZE;\t \n\n\tfcnt_tx = le16_to_cpu(*z2t) - le16_to_cpu(*z1t);\n\tif (fcnt_tx <= 0)\n\t\tfcnt_tx += B_FIFO_SIZE;\n\t \n\tfcnt_tx = B_FIFO_SIZE - fcnt_tx;\n\t \n\n\tif (test_bit(FLG_RX_OFF, &bch->Flags)) {\n\t\tbch->dropcnt += fcnt_rx;\n\t\t*z2r = cpu_to_le16(new_z2);\n\t\treturn;\n\t}\n\tmaxlen = bchannel_get_rxbuf(bch, fcnt_rx);\n\tif (maxlen < 0) {\n\t\tpr_warn(\"B%d: No bufferspace for %d bytes\\n\", bch->nr, fcnt_rx);\n\t} else {\n\t\tptr = skb_put(bch->rx_skb, fcnt_rx);\n\t\tif (le16_to_cpu(*z2r) + fcnt_rx <= B_FIFO_SIZE + B_SUB_VAL)\n\t\t\tmaxlen = fcnt_rx;\t \n\t\telse\n\t\t\tmaxlen = B_FIFO_SIZE + B_SUB_VAL - le16_to_cpu(*z2r);\n\t\t \n\n\t\tptr1 = bdata + (le16_to_cpu(*z2r) - B_SUB_VAL);\n\t\t \n\t\tmemcpy(ptr, ptr1, maxlen);\t \n\t\tfcnt_rx -= maxlen;\n\n\t\tif (fcnt_rx) {\t \n\t\t\tptr += maxlen;\n\t\t\tptr1 = bdata;\t \n\t\t\tmemcpy(ptr, ptr1, fcnt_rx);\t \n\t\t}\n\t\trecv_Bchannel(bch, fcnt_tx, false);  \n\t}\n\t*z2r = cpu_to_le16(new_z2);\t\t \n}\n\n \nstatic void\nmain_rec_hfcpci(struct bchannel *bch)\n{\n\tstruct hfc_pci\t*hc = bch->hw;\n\tint\t\trcnt, real_fifo;\n\tint\t\treceive = 0, count = 5;\n\tstruct bzfifo\t*txbz, *rxbz;\n\tu_char\t\t*bdata;\n\tstruct zt\t*zp;\n\n\tif ((bch->nr & 2) && (!hc->hw.bswapped)) {\n\t\trxbz = &((union fifo_area *)(hc->hw.fifos))->b_chans.rxbz_b2;\n\t\ttxbz = &((union fifo_area *)(hc->hw.fifos))->b_chans.txbz_b2;\n\t\tbdata = ((union fifo_area *)(hc->hw.fifos))->b_chans.rxdat_b2;\n\t\treal_fifo = 1;\n\t} else {\n\t\trxbz = &((union fifo_area *)(hc->hw.fifos))->b_chans.rxbz_b1;\n\t\ttxbz = &((union fifo_area *)(hc->hw.fifos))->b_chans.txbz_b1;\n\t\tbdata = ((union fifo_area *)(hc->hw.fifos))->b_chans.rxdat_b1;\n\t\treal_fifo = 0;\n\t}\nBegin:\n\tcount--;\n\tif (rxbz->f1 != rxbz->f2) {\n\t\tif (bch->debug & DEBUG_HW_BCHANNEL)\n\t\t\tprintk(KERN_DEBUG \"hfcpci rec ch(%x) f1(%d) f2(%d)\\n\",\n\t\t\t       bch->nr, rxbz->f1, rxbz->f2);\n\t\tzp = &rxbz->za[rxbz->f2];\n\n\t\trcnt = le16_to_cpu(zp->z1) - le16_to_cpu(zp->z2);\n\t\tif (rcnt < 0)\n\t\t\trcnt += B_FIFO_SIZE;\n\t\trcnt++;\n\t\tif (bch->debug & DEBUG_HW_BCHANNEL)\n\t\t\tprintk(KERN_DEBUG\n\t\t\t       \"hfcpci rec ch(%x) z1(%x) z2(%x) cnt(%d)\\n\",\n\t\t\t       bch->nr, le16_to_cpu(zp->z1),\n\t\t\t       le16_to_cpu(zp->z2), rcnt);\n\t\thfcpci_empty_bfifo(bch, rxbz, bdata, rcnt);\n\t\trcnt = rxbz->f1 - rxbz->f2;\n\t\tif (rcnt < 0)\n\t\t\trcnt += MAX_B_FRAMES + 1;\n\t\tif (hc->hw.last_bfifo_cnt[real_fifo] > rcnt + 1) {\n\t\t\trcnt = 0;\n\t\t\thfcpci_clear_fifo_rx(hc, real_fifo);\n\t\t}\n\t\thc->hw.last_bfifo_cnt[real_fifo] = rcnt;\n\t\tif (rcnt > 1)\n\t\t\treceive = 1;\n\t\telse\n\t\t\treceive = 0;\n\t} else if (test_bit(FLG_TRANSPARENT, &bch->Flags)) {\n\t\thfcpci_empty_fifo_trans(bch, rxbz, txbz, bdata);\n\t\treturn;\n\t} else\n\t\treceive = 0;\n\tif (count && receive)\n\t\tgoto Begin;\n\n}\n\n \nstatic void\nhfcpci_fill_dfifo(struct hfc_pci *hc)\n{\n\tstruct dchannel\t*dch = &hc->dch;\n\tint\t\tfcnt;\n\tint\t\tcount, new_z1, maxlen;\n\tstruct dfifo\t*df;\n\tu_char\t\t*src, *dst, new_f1;\n\n\tif ((dch->debug & DEBUG_HW_DCHANNEL) && !(dch->debug & DEBUG_HW_DFIFO))\n\t\tprintk(KERN_DEBUG \"%s\\n\", __func__);\n\n\tif (!dch->tx_skb)\n\t\treturn;\n\tcount = dch->tx_skb->len - dch->tx_idx;\n\tif (count <= 0)\n\t\treturn;\n\tdf = &((union fifo_area *) (hc->hw.fifos))->d_chan.d_tx;\n\n\tif (dch->debug & DEBUG_HW_DFIFO)\n\t\tprintk(KERN_DEBUG \"%s:f1(%d) f2(%d) z1(f1)(%x)\\n\", __func__,\n\t\t       df->f1, df->f2,\n\t\t       le16_to_cpu(df->za[df->f1 & D_FREG_MASK].z1));\n\tfcnt = df->f1 - df->f2;\t \n\tif (fcnt < 0)\n\t\tfcnt += (MAX_D_FRAMES + 1);\t \n\tif (fcnt > (MAX_D_FRAMES - 1)) {\n\t\tif (dch->debug & DEBUG_HW_DCHANNEL)\n\t\t\tprintk(KERN_DEBUG\n\t\t\t       \"hfcpci_fill_Dfifo more as 14 frames\\n\");\n#ifdef ERROR_STATISTIC\n\t\tcs->err_tx++;\n#endif\n\t\treturn;\n\t}\n\t \n\tmaxlen = le16_to_cpu(df->za[df->f2 & D_FREG_MASK].z2) -\n\t\tle16_to_cpu(df->za[df->f1 & D_FREG_MASK].z1) - 1;\n\tif (maxlen <= 0)\n\t\tmaxlen += D_FIFO_SIZE;\t \n\n\tif (dch->debug & DEBUG_HW_DCHANNEL)\n\t\tprintk(KERN_DEBUG \"hfcpci_fill_Dfifo count(%d/%d)\\n\",\n\t\t       count, maxlen);\n\tif (count > maxlen) {\n\t\tif (dch->debug & DEBUG_HW_DCHANNEL)\n\t\t\tprintk(KERN_DEBUG \"hfcpci_fill_Dfifo no fifo mem\\n\");\n\t\treturn;\n\t}\n\tnew_z1 = (le16_to_cpu(df->za[df->f1 & D_FREG_MASK].z1) + count) &\n\t\t(D_FIFO_SIZE - 1);\n\tnew_f1 = ((df->f1 + 1) & D_FREG_MASK) | (D_FREG_MASK + 1);\n\tsrc = dch->tx_skb->data + dch->tx_idx;\t \n\tdst = df->data + le16_to_cpu(df->za[df->f1 & D_FREG_MASK].z1);\n\tmaxlen = D_FIFO_SIZE - le16_to_cpu(df->za[df->f1 & D_FREG_MASK].z1);\n\t \n\tif (maxlen > count)\n\t\tmaxlen = count;\t \n\tmemcpy(dst, src, maxlen);\t \n\n\tcount -= maxlen;\t \n\tif (count) {\n\t\tdst = df->data;\t \n\t\tsrc += maxlen;\t \n\t\tmemcpy(dst, src, count);\n\t}\n\tdf->za[new_f1 & D_FREG_MASK].z1 = cpu_to_le16(new_z1);\n\t \n\tdf->za[df->f1 & D_FREG_MASK].z1 = cpu_to_le16(new_z1);\n\t \n\tdf->f1 = new_f1;\t \n\tdch->tx_idx = dch->tx_skb->len;\n}\n\n \nstatic void\nhfcpci_fill_fifo(struct bchannel *bch)\n{\n\tstruct hfc_pci\t*hc = bch->hw;\n\tint\t\tmaxlen, fcnt;\n\tint\t\tcount, new_z1;\n\tstruct bzfifo\t*bz;\n\tu_char\t\t*bdata;\n\tu_char\t\tnew_f1, *src, *dst;\n\t__le16 *z1t, *z2t;\n\n\tif ((bch->debug & DEBUG_HW_BCHANNEL) && !(bch->debug & DEBUG_HW_BFIFO))\n\t\tprintk(KERN_DEBUG \"%s\\n\", __func__);\n\tif ((!bch->tx_skb) || bch->tx_skb->len == 0) {\n\t\tif (!test_bit(FLG_FILLEMPTY, &bch->Flags) &&\n\t\t    !test_bit(FLG_TRANSPARENT, &bch->Flags))\n\t\t\treturn;\n\t\tcount = HFCPCI_FILLEMPTY;\n\t} else {\n\t\tcount = bch->tx_skb->len - bch->tx_idx;\n\t}\n\tif ((bch->nr & 2) && (!hc->hw.bswapped)) {\n\t\tbz = &((union fifo_area *)(hc->hw.fifos))->b_chans.txbz_b2;\n\t\tbdata = ((union fifo_area *)(hc->hw.fifos))->b_chans.txdat_b2;\n\t} else {\n\t\tbz = &((union fifo_area *)(hc->hw.fifos))->b_chans.txbz_b1;\n\t\tbdata = ((union fifo_area *)(hc->hw.fifos))->b_chans.txdat_b1;\n\t}\n\n\tif (test_bit(FLG_TRANSPARENT, &bch->Flags)) {\n\t\tz1t = &bz->za[MAX_B_FRAMES].z1;\n\t\tz2t = z1t + 1;\n\t\tif (bch->debug & DEBUG_HW_BCHANNEL)\n\t\t\tprintk(KERN_DEBUG \"hfcpci_fill_fifo_trans ch(%x) \"\n\t\t\t       \"cnt(%d) z1(%x) z2(%x)\\n\", bch->nr, count,\n\t\t\t       le16_to_cpu(*z1t), le16_to_cpu(*z2t));\n\t\tfcnt = le16_to_cpu(*z2t) - le16_to_cpu(*z1t);\n\t\tif (fcnt <= 0)\n\t\t\tfcnt += B_FIFO_SIZE;\n\t\tif (test_bit(FLG_FILLEMPTY, &bch->Flags)) {\n\t\t\t \n\t\t\tif (count > fcnt)\n\t\t\t\tcount = fcnt;\n\t\t\tnew_z1 = le16_to_cpu(*z1t) + count;\n\t\t\t \n\t\t\tif (new_z1 >= (B_FIFO_SIZE + B_SUB_VAL))\n\t\t\t\tnew_z1 -= B_FIFO_SIZE;\t \n\t\t\tdst = bdata + (le16_to_cpu(*z1t) - B_SUB_VAL);\n\t\t\tmaxlen = (B_FIFO_SIZE + B_SUB_VAL) - le16_to_cpu(*z1t);\n\t\t\t \n\t\t\tif (bch->debug & DEBUG_HW_BFIFO)\n\t\t\t\tprintk(KERN_DEBUG \"hfcpci_FFt fillempty \"\n\t\t\t\t       \"fcnt(%d) maxl(%d) nz1(%x) dst(%p)\\n\",\n\t\t\t\t       fcnt, maxlen, new_z1, dst);\n\t\t\tif (maxlen > count)\n\t\t\t\tmaxlen = count;\t\t \n\t\t\tmemset(dst, bch->fill[0], maxlen);  \n\t\t\tcount -= maxlen;\t\t \n\t\t\tif (count) {\n\t\t\t\tdst = bdata;\t\t \n\t\t\t\tmemset(dst, bch->fill[0], count);\n\t\t\t}\n\t\t\t*z1t = cpu_to_le16(new_z1);\t \n\t\t\treturn;\n\t\t}\n\t\t \n\t\tfcnt = B_FIFO_SIZE - fcnt;\n\t\t \n\n\tnext_t_frame:\n\t\tcount = bch->tx_skb->len - bch->tx_idx;\n\t\t \n\t\tif (count > (poll << 1) - fcnt)\n\t\t\tcount = (poll << 1) - fcnt;\n\t\tif (count <= 0)\n\t\t\treturn;\n\t\t \n\t\tnew_z1 = le16_to_cpu(*z1t) + count;\n\t\t \n\t\tif (new_z1 >= (B_FIFO_SIZE + B_SUB_VAL))\n\t\t\tnew_z1 -= B_FIFO_SIZE;\t \n\t\tsrc = bch->tx_skb->data + bch->tx_idx;\n\t\t \n\t\tdst = bdata + (le16_to_cpu(*z1t) - B_SUB_VAL);\n\t\tmaxlen = (B_FIFO_SIZE + B_SUB_VAL) - le16_to_cpu(*z1t);\n\t\t \n\t\tif (bch->debug & DEBUG_HW_BFIFO)\n\t\t\tprintk(KERN_DEBUG \"hfcpci_FFt fcnt(%d) \"\n\t\t\t       \"maxl(%d) nz1(%x) dst(%p)\\n\",\n\t\t\t       fcnt, maxlen, new_z1, dst);\n\t\tfcnt += count;\n\t\tbch->tx_idx += count;\n\t\tif (maxlen > count)\n\t\t\tmaxlen = count;\t\t \n\t\tmemcpy(dst, src, maxlen);\t \n\t\tcount -= maxlen;\t \n\t\tif (count) {\n\t\t\tdst = bdata;\t \n\t\t\tsrc += maxlen;\t \n\t\t\tmemcpy(dst, src, count);\n\t\t}\n\t\t*z1t = cpu_to_le16(new_z1);\t \n\t\tif (bch->tx_idx < bch->tx_skb->len)\n\t\t\treturn;\n\t\tdev_kfree_skb_any(bch->tx_skb);\n\t\tif (get_next_bframe(bch))\n\t\t\tgoto next_t_frame;\n\t\treturn;\n\t}\n\tif (bch->debug & DEBUG_HW_BCHANNEL)\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s: ch(%x) f1(%d) f2(%d) z1(f1)(%x)\\n\",\n\t\t       __func__, bch->nr, bz->f1, bz->f2,\n\t\t       bz->za[bz->f1].z1);\n\tfcnt = bz->f1 - bz->f2;\t \n\tif (fcnt < 0)\n\t\tfcnt += (MAX_B_FRAMES + 1);\t \n\tif (fcnt > (MAX_B_FRAMES - 1)) {\n\t\tif (bch->debug & DEBUG_HW_BCHANNEL)\n\t\t\tprintk(KERN_DEBUG\n\t\t\t       \"hfcpci_fill_Bfifo more as 14 frames\\n\");\n\t\treturn;\n\t}\n\t \n\tmaxlen = le16_to_cpu(bz->za[bz->f2].z2) -\n\t\tle16_to_cpu(bz->za[bz->f1].z1) - 1;\n\tif (maxlen <= 0)\n\t\tmaxlen += B_FIFO_SIZE;\t \n\n\tif (bch->debug & DEBUG_HW_BCHANNEL)\n\t\tprintk(KERN_DEBUG \"hfcpci_fill_fifo ch(%x) count(%d/%d)\\n\",\n\t\t       bch->nr, count, maxlen);\n\n\tif (maxlen < count) {\n\t\tif (bch->debug & DEBUG_HW_BCHANNEL)\n\t\t\tprintk(KERN_DEBUG \"hfcpci_fill_fifo no fifo mem\\n\");\n\t\treturn;\n\t}\n\tnew_z1 = le16_to_cpu(bz->za[bz->f1].z1) + count;\n\t \n\tif (new_z1 >= (B_FIFO_SIZE + B_SUB_VAL))\n\t\tnew_z1 -= B_FIFO_SIZE;\t \n\n\tnew_f1 = ((bz->f1 + 1) & MAX_B_FRAMES);\n\tsrc = bch->tx_skb->data + bch->tx_idx;\t \n\tdst = bdata + (le16_to_cpu(bz->za[bz->f1].z1) - B_SUB_VAL);\n\tmaxlen = (B_FIFO_SIZE + B_SUB_VAL) - le16_to_cpu(bz->za[bz->f1].z1);\n\t \n\tif (maxlen > count)\n\t\tmaxlen = count;\t \n\tmemcpy(dst, src, maxlen);\t \n\n\tcount -= maxlen;\t \n\tif (count) {\n\t\tdst = bdata;\t \n\t\tsrc += maxlen;\t \n\t\tmemcpy(dst, src, count);\n\t}\n\tbz->za[new_f1].z1 = cpu_to_le16(new_z1);\t \n\tbz->f1 = new_f1;\t \n\tdev_kfree_skb_any(bch->tx_skb);\n\tget_next_bframe(bch);\n}\n\n\n\n \n\nstatic void\nph_state_te(struct dchannel *dch)\n{\n\tif (dch->debug)\n\t\tprintk(KERN_DEBUG \"%s: TE newstate %x\\n\",\n\t\t       __func__, dch->state);\n\tswitch (dch->state) {\n\tcase 0:\n\t\tl1_event(dch->l1, HW_RESET_IND);\n\t\tbreak;\n\tcase 3:\n\t\tl1_event(dch->l1, HW_DEACT_IND);\n\t\tbreak;\n\tcase 5:\n\tcase 8:\n\t\tl1_event(dch->l1, ANYSIGNAL);\n\t\tbreak;\n\tcase 6:\n\t\tl1_event(dch->l1, INFO2);\n\t\tbreak;\n\tcase 7:\n\t\tl1_event(dch->l1, INFO4_P8);\n\t\tbreak;\n\t}\n}\n\n \n\nstatic void\nhandle_nt_timer3(struct dchannel *dch) {\n\tstruct hfc_pci\t*hc = dch->hw;\n\n\ttest_and_clear_bit(FLG_HFC_TIMER_T3, &dch->Flags);\n\thc->hw.int_m1 &= ~HFCPCI_INTS_TIMER;\n\tWrite_hfc(hc, HFCPCI_INT_M1, hc->hw.int_m1);\n\thc->hw.nt_timer = 0;\n\ttest_and_set_bit(FLG_ACTIVE, &dch->Flags);\n\tif (test_bit(HFC_CFG_MASTER, &hc->cfg))\n\t\thc->hw.mst_m |= HFCPCI_MASTER;\n\tWrite_hfc(hc, HFCPCI_MST_MODE, hc->hw.mst_m);\n\t_queue_data(&dch->dev.D, PH_ACTIVATE_IND,\n\t\t    MISDN_ID_ANY, 0, NULL, GFP_ATOMIC);\n}\n\nstatic void\nph_state_nt(struct dchannel *dch)\n{\n\tstruct hfc_pci\t*hc = dch->hw;\n\n\tif (dch->debug)\n\t\tprintk(KERN_DEBUG \"%s: NT newstate %x\\n\",\n\t\t       __func__, dch->state);\n\tswitch (dch->state) {\n\tcase 2:\n\t\tif (hc->hw.nt_timer < 0) {\n\t\t\thc->hw.nt_timer = 0;\n\t\t\ttest_and_clear_bit(FLG_HFC_TIMER_T3, &dch->Flags);\n\t\t\ttest_and_clear_bit(FLG_HFC_TIMER_T1, &dch->Flags);\n\t\t\thc->hw.int_m1 &= ~HFCPCI_INTS_TIMER;\n\t\t\tWrite_hfc(hc, HFCPCI_INT_M1, hc->hw.int_m1);\n\t\t\t \n\t\t\t(void) Read_hfc(hc, HFCPCI_INT_S1);\n\t\t\tWrite_hfc(hc, HFCPCI_STATES, 4 | HFCPCI_LOAD_STATE);\n\t\t\tudelay(10);\n\t\t\tWrite_hfc(hc, HFCPCI_STATES, 4);\n\t\t\tdch->state = 4;\n\t\t} else if (hc->hw.nt_timer == 0) {\n\t\t\thc->hw.int_m1 |= HFCPCI_INTS_TIMER;\n\t\t\tWrite_hfc(hc, HFCPCI_INT_M1, hc->hw.int_m1);\n\t\t\thc->hw.nt_timer = NT_T1_COUNT;\n\t\t\thc->hw.ctmt &= ~HFCPCI_AUTO_TIMER;\n\t\t\thc->hw.ctmt |= HFCPCI_TIM3_125;\n\t\t\tWrite_hfc(hc, HFCPCI_CTMT, hc->hw.ctmt |\n\t\t\t\t  HFCPCI_CLTIMER);\n\t\t\ttest_and_clear_bit(FLG_HFC_TIMER_T3, &dch->Flags);\n\t\t\ttest_and_set_bit(FLG_HFC_TIMER_T1, &dch->Flags);\n\t\t\t \n\t\t\tWrite_hfc(hc, HFCPCI_STATES, 2 | HFCPCI_NT_G2_G3);\n\t\t} else {\n\t\t\tWrite_hfc(hc, HFCPCI_STATES, 2 | HFCPCI_NT_G2_G3);\n\t\t}\n\t\tbreak;\n\tcase 1:\n\t\thc->hw.nt_timer = 0;\n\t\ttest_and_clear_bit(FLG_HFC_TIMER_T3, &dch->Flags);\n\t\ttest_and_clear_bit(FLG_HFC_TIMER_T1, &dch->Flags);\n\t\thc->hw.int_m1 &= ~HFCPCI_INTS_TIMER;\n\t\tWrite_hfc(hc, HFCPCI_INT_M1, hc->hw.int_m1);\n\t\ttest_and_clear_bit(FLG_ACTIVE, &dch->Flags);\n\t\thc->hw.mst_m &= ~HFCPCI_MASTER;\n\t\tWrite_hfc(hc, HFCPCI_MST_MODE, hc->hw.mst_m);\n\t\ttest_and_clear_bit(FLG_L2_ACTIVATED, &dch->Flags);\n\t\t_queue_data(&dch->dev.D, PH_DEACTIVATE_IND,\n\t\t\t    MISDN_ID_ANY, 0, NULL, GFP_ATOMIC);\n\t\tbreak;\n\tcase 4:\n\t\thc->hw.nt_timer = 0;\n\t\ttest_and_clear_bit(FLG_HFC_TIMER_T3, &dch->Flags);\n\t\ttest_and_clear_bit(FLG_HFC_TIMER_T1, &dch->Flags);\n\t\thc->hw.int_m1 &= ~HFCPCI_INTS_TIMER;\n\t\tWrite_hfc(hc, HFCPCI_INT_M1, hc->hw.int_m1);\n\t\tbreak;\n\tcase 3:\n\t\tif (!test_and_set_bit(FLG_HFC_TIMER_T3, &dch->Flags)) {\n\t\t\tif (!test_and_clear_bit(FLG_L2_ACTIVATED,\n\t\t\t\t\t\t&dch->Flags)) {\n\t\t\t\thandle_nt_timer3(dch);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttest_and_clear_bit(FLG_HFC_TIMER_T1, &dch->Flags);\n\t\t\thc->hw.int_m1 |= HFCPCI_INTS_TIMER;\n\t\t\tWrite_hfc(hc, HFCPCI_INT_M1, hc->hw.int_m1);\n\t\t\thc->hw.nt_timer = NT_T3_COUNT;\n\t\t\thc->hw.ctmt &= ~HFCPCI_AUTO_TIMER;\n\t\t\thc->hw.ctmt |= HFCPCI_TIM3_125;\n\t\t\tWrite_hfc(hc, HFCPCI_CTMT, hc->hw.ctmt |\n\t\t\t\t  HFCPCI_CLTIMER);\n\t\t}\n\t\tbreak;\n\t}\n}\n\nstatic void\nph_state(struct dchannel *dch)\n{\n\tstruct hfc_pci\t*hc = dch->hw;\n\n\tif (hc->hw.protocol == ISDN_P_NT_S0) {\n\t\tif (test_bit(FLG_HFC_TIMER_T3, &dch->Flags) &&\n\t\t    hc->hw.nt_timer < 0)\n\t\t\thandle_nt_timer3(dch);\n\t\telse\n\t\t\tph_state_nt(dch);\n\t} else\n\t\tph_state_te(dch);\n}\n\n \nstatic int\nhfc_l1callback(struct dchannel *dch, u_int cmd)\n{\n\tstruct hfc_pci\t\t*hc = dch->hw;\n\n\tswitch (cmd) {\n\tcase INFO3_P8:\n\tcase INFO3_P10:\n\t\tif (test_bit(HFC_CFG_MASTER, &hc->cfg))\n\t\t\thc->hw.mst_m |= HFCPCI_MASTER;\n\t\tWrite_hfc(hc, HFCPCI_MST_MODE, hc->hw.mst_m);\n\t\tbreak;\n\tcase HW_RESET_REQ:\n\t\tWrite_hfc(hc, HFCPCI_STATES, HFCPCI_LOAD_STATE | 3);\n\t\t \n\t\tudelay(6);\n\t\tWrite_hfc(hc, HFCPCI_STATES, 3);\t \n\t\tif (test_bit(HFC_CFG_MASTER, &hc->cfg))\n\t\t\thc->hw.mst_m |= HFCPCI_MASTER;\n\t\tWrite_hfc(hc, HFCPCI_MST_MODE, hc->hw.mst_m);\n\t\tWrite_hfc(hc, HFCPCI_STATES, HFCPCI_ACTIVATE |\n\t\t\t  HFCPCI_DO_ACTION);\n\t\tl1_event(dch->l1, HW_POWERUP_IND);\n\t\tbreak;\n\tcase HW_DEACT_REQ:\n\t\thc->hw.mst_m &= ~HFCPCI_MASTER;\n\t\tWrite_hfc(hc, HFCPCI_MST_MODE, hc->hw.mst_m);\n\t\tskb_queue_purge(&dch->squeue);\n\t\tif (dch->tx_skb) {\n\t\t\tdev_kfree_skb(dch->tx_skb);\n\t\t\tdch->tx_skb = NULL;\n\t\t}\n\t\tdch->tx_idx = 0;\n\t\tif (dch->rx_skb) {\n\t\t\tdev_kfree_skb(dch->rx_skb);\n\t\t\tdch->rx_skb = NULL;\n\t\t}\n\t\ttest_and_clear_bit(FLG_TX_BUSY, &dch->Flags);\n\t\tif (test_and_clear_bit(FLG_BUSY_TIMER, &dch->Flags))\n\t\t\tdel_timer(&dch->timer);\n\t\tbreak;\n\tcase HW_POWERUP_REQ:\n\t\tWrite_hfc(hc, HFCPCI_STATES, HFCPCI_DO_ACTION);\n\t\tbreak;\n\tcase PH_ACTIVATE_IND:\n\t\ttest_and_set_bit(FLG_ACTIVE, &dch->Flags);\n\t\t_queue_data(&dch->dev.D, cmd, MISDN_ID_ANY, 0, NULL,\n\t\t\t    GFP_ATOMIC);\n\t\tbreak;\n\tcase PH_DEACTIVATE_IND:\n\t\ttest_and_clear_bit(FLG_ACTIVE, &dch->Flags);\n\t\t_queue_data(&dch->dev.D, cmd, MISDN_ID_ANY, 0, NULL,\n\t\t\t    GFP_ATOMIC);\n\t\tbreak;\n\tdefault:\n\t\tif (dch->debug & DEBUG_HW)\n\t\t\tprintk(KERN_DEBUG \"%s: unknown command %x\\n\",\n\t\t\t       __func__, cmd);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\n \nstatic inline void\ntx_birq(struct bchannel *bch)\n{\n\tif (bch->tx_skb && bch->tx_idx < bch->tx_skb->len)\n\t\thfcpci_fill_fifo(bch);\n\telse {\n\t\tdev_kfree_skb_any(bch->tx_skb);\n\t\tif (get_next_bframe(bch))\n\t\t\thfcpci_fill_fifo(bch);\n\t}\n}\n\nstatic inline void\ntx_dirq(struct dchannel *dch)\n{\n\tif (dch->tx_skb && dch->tx_idx < dch->tx_skb->len)\n\t\thfcpci_fill_dfifo(dch->hw);\n\telse {\n\t\tdev_kfree_skb(dch->tx_skb);\n\t\tif (get_next_dframe(dch))\n\t\t\thfcpci_fill_dfifo(dch->hw);\n\t}\n}\n\nstatic irqreturn_t\nhfcpci_int(int intno, void *dev_id)\n{\n\tstruct hfc_pci\t*hc = dev_id;\n\tu_char\t\texval;\n\tstruct bchannel\t*bch;\n\tu_char\t\tval, stat;\n\n\tspin_lock(&hc->lock);\n\tif (!(hc->hw.int_m2 & 0x08)) {\n\t\tspin_unlock(&hc->lock);\n\t\treturn IRQ_NONE;  \n\t}\n\tstat = Read_hfc(hc, HFCPCI_STATUS);\n\tif (HFCPCI_ANYINT & stat) {\n\t\tval = Read_hfc(hc, HFCPCI_INT_S1);\n\t\tif (hc->dch.debug & DEBUG_HW_DCHANNEL)\n\t\t\tprintk(KERN_DEBUG\n\t\t\t       \"HFC-PCI: stat(%02x) s1(%02x)\\n\", stat, val);\n\t} else {\n\t\t \n\t\tspin_unlock(&hc->lock);\n\t\treturn IRQ_NONE;\n\t}\n\thc->irqcnt++;\n\n\tif (hc->dch.debug & DEBUG_HW_DCHANNEL)\n\t\tprintk(KERN_DEBUG \"HFC-PCI irq %x\\n\", val);\n\tval &= hc->hw.int_m1;\n\tif (val & 0x40) {\t \n\t\texval = Read_hfc(hc, HFCPCI_STATES) & 0xf;\n\t\tif (hc->dch.debug & DEBUG_HW_DCHANNEL)\n\t\t\tprintk(KERN_DEBUG \"ph_state chg %d->%d\\n\",\n\t\t\t       hc->dch.state, exval);\n\t\thc->dch.state = exval;\n\t\tschedule_event(&hc->dch, FLG_PHCHANGE);\n\t\tval &= ~0x40;\n\t}\n\tif (val & 0x80) {\t \n\t\tif (hc->hw.protocol == ISDN_P_NT_S0) {\n\t\t\tif ((--hc->hw.nt_timer) < 0)\n\t\t\t\tschedule_event(&hc->dch, FLG_PHCHANGE);\n\t\t}\n\t\tval &= ~0x80;\n\t\tWrite_hfc(hc, HFCPCI_CTMT, hc->hw.ctmt | HFCPCI_CLTIMER);\n\t}\n\tif (val & 0x08) {\t \n\t\tbch = Sel_BCS(hc, hc->hw.bswapped ? 2 : 1);\n\t\tif (bch)\n\t\t\tmain_rec_hfcpci(bch);\n\t\telse if (hc->dch.debug)\n\t\t\tprintk(KERN_DEBUG \"hfcpci spurious 0x08 IRQ\\n\");\n\t}\n\tif (val & 0x10) {\t \n\t\tbch = Sel_BCS(hc, 2);\n\t\tif (bch)\n\t\t\tmain_rec_hfcpci(bch);\n\t\telse if (hc->dch.debug)\n\t\t\tprintk(KERN_DEBUG \"hfcpci spurious 0x10 IRQ\\n\");\n\t}\n\tif (val & 0x01) {\t \n\t\tbch = Sel_BCS(hc, hc->hw.bswapped ? 2 : 1);\n\t\tif (bch)\n\t\t\ttx_birq(bch);\n\t\telse if (hc->dch.debug)\n\t\t\tprintk(KERN_DEBUG \"hfcpci spurious 0x01 IRQ\\n\");\n\t}\n\tif (val & 0x02) {\t \n\t\tbch = Sel_BCS(hc, 2);\n\t\tif (bch)\n\t\t\ttx_birq(bch);\n\t\telse if (hc->dch.debug)\n\t\t\tprintk(KERN_DEBUG \"hfcpci spurious 0x02 IRQ\\n\");\n\t}\n\tif (val & 0x20)\t\t \n\t\treceive_dmsg(hc);\n\tif (val & 0x04) {\t \n\t\tif (test_and_clear_bit(FLG_BUSY_TIMER, &hc->dch.Flags))\n\t\t\tdel_timer(&hc->dch.timer);\n\t\ttx_dirq(&hc->dch);\n\t}\n\tspin_unlock(&hc->lock);\n\treturn IRQ_HANDLED;\n}\n\n \nstatic void\nhfcpci_dbusy_timer(struct timer_list *t)\n{\n}\n\n \nstatic int\nmode_hfcpci(struct bchannel *bch, int bc, int protocol)\n{\n\tstruct hfc_pci\t*hc = bch->hw;\n\tint\t\tfifo2;\n\tu_char\t\trx_slot = 0, tx_slot = 0, pcm_mode;\n\n\tif (bch->debug & DEBUG_HW_BCHANNEL)\n\t\tprintk(KERN_DEBUG\n\t\t       \"HFCPCI bchannel protocol %x-->%x ch %x-->%x\\n\",\n\t\t       bch->state, protocol, bch->nr, bc);\n\n\tfifo2 = bc;\n\tpcm_mode = (bc >> 24) & 0xff;\n\tif (pcm_mode) {  \n\t\tif (!test_bit(HFC_CFG_PCM, &hc->cfg))\n\t\t\tprintk(KERN_WARNING\n\t\t\t       \"%s: pcm channel id without HFC_CFG_PCM\\n\",\n\t\t\t       __func__);\n\t\trx_slot = (bc >> 8) & 0xff;\n\t\ttx_slot = (bc >> 16) & 0xff;\n\t\tbc = bc & 0xff;\n\t} else if (test_bit(HFC_CFG_PCM, &hc->cfg) && (protocol > ISDN_P_NONE))\n\t\tprintk(KERN_WARNING \"%s: no pcm channel id but HFC_CFG_PCM\\n\",\n\t\t       __func__);\n\tif (hc->chanlimit > 1) {\n\t\thc->hw.bswapped = 0;\t \n\t\thc->hw.sctrl_e &= ~0x80;\n\t} else {\n\t\tif (bc & 2) {\n\t\t\tif (protocol != ISDN_P_NONE) {\n\t\t\t\thc->hw.bswapped = 1;  \n\t\t\t\thc->hw.sctrl_e |= 0x80;\n\t\t\t} else {\n\t\t\t\thc->hw.bswapped = 0;  \n\t\t\t\thc->hw.sctrl_e &= ~0x80;\n\t\t\t}\n\t\t\tfifo2 = 1;\n\t\t} else {\n\t\t\thc->hw.bswapped = 0;\t \n\t\t\thc->hw.sctrl_e &= ~0x80;\n\t\t}\n\t}\n\tswitch (protocol) {\n\tcase (-1):  \n\t\tbch->state = -1;\n\t\tbch->nr = bc;\n\t\tfallthrough;\n\tcase (ISDN_P_NONE):\n\t\tif (bch->state == ISDN_P_NONE)\n\t\t\treturn 0;\n\t\tif (bc & 2) {\n\t\t\thc->hw.sctrl &= ~SCTRL_B2_ENA;\n\t\t\thc->hw.sctrl_r &= ~SCTRL_B2_ENA;\n\t\t} else {\n\t\t\thc->hw.sctrl &= ~SCTRL_B1_ENA;\n\t\t\thc->hw.sctrl_r &= ~SCTRL_B1_ENA;\n\t\t}\n\t\tif (fifo2 & 2) {\n\t\t\thc->hw.fifo_en &= ~HFCPCI_FIFOEN_B2;\n\t\t\thc->hw.int_m1 &= ~(HFCPCI_INTS_B2TRANS |\n\t\t\t\t\t   HFCPCI_INTS_B2REC);\n\t\t} else {\n\t\t\thc->hw.fifo_en &= ~HFCPCI_FIFOEN_B1;\n\t\t\thc->hw.int_m1 &= ~(HFCPCI_INTS_B1TRANS |\n\t\t\t\t\t   HFCPCI_INTS_B1REC);\n\t\t}\n#ifdef REVERSE_BITORDER\n\t\tif (bch->nr & 2)\n\t\t\thc->hw.cirm &= 0x7f;\n\t\telse\n\t\t\thc->hw.cirm &= 0xbf;\n#endif\n\t\tbch->state = ISDN_P_NONE;\n\t\tbch->nr = bc;\n\t\ttest_and_clear_bit(FLG_HDLC, &bch->Flags);\n\t\ttest_and_clear_bit(FLG_TRANSPARENT, &bch->Flags);\n\t\tbreak;\n\tcase (ISDN_P_B_RAW):\n\t\tbch->state = protocol;\n\t\tbch->nr = bc;\n\t\thfcpci_clear_fifo_rx(hc, (fifo2 & 2) ? 1 : 0);\n\t\thfcpci_clear_fifo_tx(hc, (fifo2 & 2) ? 1 : 0);\n\t\tif (bc & 2) {\n\t\t\thc->hw.sctrl |= SCTRL_B2_ENA;\n\t\t\thc->hw.sctrl_r |= SCTRL_B2_ENA;\n#ifdef REVERSE_BITORDER\n\t\t\thc->hw.cirm |= 0x80;\n#endif\n\t\t} else {\n\t\t\thc->hw.sctrl |= SCTRL_B1_ENA;\n\t\t\thc->hw.sctrl_r |= SCTRL_B1_ENA;\n#ifdef REVERSE_BITORDER\n\t\t\thc->hw.cirm |= 0x40;\n#endif\n\t\t}\n\t\tif (fifo2 & 2) {\n\t\t\thc->hw.fifo_en |= HFCPCI_FIFOEN_B2;\n\t\t\tif (!tics)\n\t\t\t\thc->hw.int_m1 |= (HFCPCI_INTS_B2TRANS |\n\t\t\t\t\t\t  HFCPCI_INTS_B2REC);\n\t\t\thc->hw.ctmt |= 2;\n\t\t\thc->hw.conn &= ~0x18;\n\t\t} else {\n\t\t\thc->hw.fifo_en |= HFCPCI_FIFOEN_B1;\n\t\t\tif (!tics)\n\t\t\t\thc->hw.int_m1 |= (HFCPCI_INTS_B1TRANS |\n\t\t\t\t\t\t  HFCPCI_INTS_B1REC);\n\t\t\thc->hw.ctmt |= 1;\n\t\t\thc->hw.conn &= ~0x03;\n\t\t}\n\t\ttest_and_set_bit(FLG_TRANSPARENT, &bch->Flags);\n\t\tbreak;\n\tcase (ISDN_P_B_HDLC):\n\t\tbch->state = protocol;\n\t\tbch->nr = bc;\n\t\thfcpci_clear_fifo_rx(hc, (fifo2 & 2) ? 1 : 0);\n\t\thfcpci_clear_fifo_tx(hc, (fifo2 & 2) ? 1 : 0);\n\t\tif (bc & 2) {\n\t\t\thc->hw.sctrl |= SCTRL_B2_ENA;\n\t\t\thc->hw.sctrl_r |= SCTRL_B2_ENA;\n\t\t} else {\n\t\t\thc->hw.sctrl |= SCTRL_B1_ENA;\n\t\t\thc->hw.sctrl_r |= SCTRL_B1_ENA;\n\t\t}\n\t\tif (fifo2 & 2) {\n\t\t\thc->hw.last_bfifo_cnt[1] = 0;\n\t\t\thc->hw.fifo_en |= HFCPCI_FIFOEN_B2;\n\t\t\thc->hw.int_m1 |= (HFCPCI_INTS_B2TRANS |\n\t\t\t\t\t  HFCPCI_INTS_B2REC);\n\t\t\thc->hw.ctmt &= ~2;\n\t\t\thc->hw.conn &= ~0x18;\n\t\t} else {\n\t\t\thc->hw.last_bfifo_cnt[0] = 0;\n\t\t\thc->hw.fifo_en |= HFCPCI_FIFOEN_B1;\n\t\t\thc->hw.int_m1 |= (HFCPCI_INTS_B1TRANS |\n\t\t\t\t\t  HFCPCI_INTS_B1REC);\n\t\t\thc->hw.ctmt &= ~1;\n\t\t\thc->hw.conn &= ~0x03;\n\t\t}\n\t\ttest_and_set_bit(FLG_HDLC, &bch->Flags);\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_DEBUG \"prot not known %x\\n\", protocol);\n\t\treturn -ENOPROTOOPT;\n\t}\n\tif (test_bit(HFC_CFG_PCM, &hc->cfg)) {\n\t\tif ((protocol == ISDN_P_NONE) ||\n\t\t    (protocol == -1)) {\t \n\t\t\trx_slot = 0;\n\t\t\ttx_slot = 0;\n\t\t} else {\n\t\t\tif (test_bit(HFC_CFG_SW_DD_DU, &hc->cfg)) {\n\t\t\t\trx_slot |= 0xC0;\n\t\t\t\ttx_slot |= 0xC0;\n\t\t\t} else {\n\t\t\t\trx_slot |= 0x80;\n\t\t\t\ttx_slot |= 0x80;\n\t\t\t}\n\t\t}\n\t\tif (bc & 2) {\n\t\t\thc->hw.conn &= 0xc7;\n\t\t\thc->hw.conn |= 0x08;\n\t\t\tprintk(KERN_DEBUG \"%s: Write_hfc: B2_SSL 0x%x\\n\",\n\t\t\t       __func__, tx_slot);\n\t\t\tprintk(KERN_DEBUG \"%s: Write_hfc: B2_RSL 0x%x\\n\",\n\t\t\t       __func__, rx_slot);\n\t\t\tWrite_hfc(hc, HFCPCI_B2_SSL, tx_slot);\n\t\t\tWrite_hfc(hc, HFCPCI_B2_RSL, rx_slot);\n\t\t} else {\n\t\t\thc->hw.conn &= 0xf8;\n\t\t\thc->hw.conn |= 0x01;\n\t\t\tprintk(KERN_DEBUG \"%s: Write_hfc: B1_SSL 0x%x\\n\",\n\t\t\t       __func__, tx_slot);\n\t\t\tprintk(KERN_DEBUG \"%s: Write_hfc: B1_RSL 0x%x\\n\",\n\t\t\t       __func__, rx_slot);\n\t\t\tWrite_hfc(hc, HFCPCI_B1_SSL, tx_slot);\n\t\t\tWrite_hfc(hc, HFCPCI_B1_RSL, rx_slot);\n\t\t}\n\t}\n\tWrite_hfc(hc, HFCPCI_SCTRL_E, hc->hw.sctrl_e);\n\tWrite_hfc(hc, HFCPCI_INT_M1, hc->hw.int_m1);\n\tWrite_hfc(hc, HFCPCI_FIFO_EN, hc->hw.fifo_en);\n\tWrite_hfc(hc, HFCPCI_SCTRL, hc->hw.sctrl);\n\tWrite_hfc(hc, HFCPCI_SCTRL_R, hc->hw.sctrl_r);\n\tWrite_hfc(hc, HFCPCI_CTMT, hc->hw.ctmt);\n\tWrite_hfc(hc, HFCPCI_CONNECT, hc->hw.conn);\n#ifdef REVERSE_BITORDER\n\tWrite_hfc(hc, HFCPCI_CIRM, hc->hw.cirm);\n#endif\n\treturn 0;\n}\n\nstatic int\nset_hfcpci_rxtest(struct bchannel *bch, int protocol, int chan)\n{\n\tstruct hfc_pci\t*hc = bch->hw;\n\n\tif (bch->debug & DEBUG_HW_BCHANNEL)\n\t\tprintk(KERN_DEBUG\n\t\t       \"HFCPCI bchannel test rx protocol %x-->%x ch %x-->%x\\n\",\n\t\t       bch->state, protocol, bch->nr, chan);\n\tif (bch->nr != chan) {\n\t\tprintk(KERN_DEBUG\n\t\t       \"HFCPCI rxtest wrong channel parameter %x/%x\\n\",\n\t\t       bch->nr, chan);\n\t\treturn -EINVAL;\n\t}\n\tswitch (protocol) {\n\tcase (ISDN_P_B_RAW):\n\t\tbch->state = protocol;\n\t\thfcpci_clear_fifo_rx(hc, (chan & 2) ? 1 : 0);\n\t\tif (chan & 2) {\n\t\t\thc->hw.sctrl_r |= SCTRL_B2_ENA;\n\t\t\thc->hw.fifo_en |= HFCPCI_FIFOEN_B2RX;\n\t\t\tif (!tics)\n\t\t\t\thc->hw.int_m1 |= HFCPCI_INTS_B2REC;\n\t\t\thc->hw.ctmt |= 2;\n\t\t\thc->hw.conn &= ~0x18;\n#ifdef REVERSE_BITORDER\n\t\t\thc->hw.cirm |= 0x80;\n#endif\n\t\t} else {\n\t\t\thc->hw.sctrl_r |= SCTRL_B1_ENA;\n\t\t\thc->hw.fifo_en |= HFCPCI_FIFOEN_B1RX;\n\t\t\tif (!tics)\n\t\t\t\thc->hw.int_m1 |= HFCPCI_INTS_B1REC;\n\t\t\thc->hw.ctmt |= 1;\n\t\t\thc->hw.conn &= ~0x03;\n#ifdef REVERSE_BITORDER\n\t\t\thc->hw.cirm |= 0x40;\n#endif\n\t\t}\n\t\tbreak;\n\tcase (ISDN_P_B_HDLC):\n\t\tbch->state = protocol;\n\t\thfcpci_clear_fifo_rx(hc, (chan & 2) ? 1 : 0);\n\t\tif (chan & 2) {\n\t\t\thc->hw.sctrl_r |= SCTRL_B2_ENA;\n\t\t\thc->hw.last_bfifo_cnt[1] = 0;\n\t\t\thc->hw.fifo_en |= HFCPCI_FIFOEN_B2RX;\n\t\t\thc->hw.int_m1 |= HFCPCI_INTS_B2REC;\n\t\t\thc->hw.ctmt &= ~2;\n\t\t\thc->hw.conn &= ~0x18;\n\t\t} else {\n\t\t\thc->hw.sctrl_r |= SCTRL_B1_ENA;\n\t\t\thc->hw.last_bfifo_cnt[0] = 0;\n\t\t\thc->hw.fifo_en |= HFCPCI_FIFOEN_B1RX;\n\t\t\thc->hw.int_m1 |= HFCPCI_INTS_B1REC;\n\t\t\thc->hw.ctmt &= ~1;\n\t\t\thc->hw.conn &= ~0x03;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_DEBUG \"prot not known %x\\n\", protocol);\n\t\treturn -ENOPROTOOPT;\n\t}\n\tWrite_hfc(hc, HFCPCI_INT_M1, hc->hw.int_m1);\n\tWrite_hfc(hc, HFCPCI_FIFO_EN, hc->hw.fifo_en);\n\tWrite_hfc(hc, HFCPCI_SCTRL_R, hc->hw.sctrl_r);\n\tWrite_hfc(hc, HFCPCI_CTMT, hc->hw.ctmt);\n\tWrite_hfc(hc, HFCPCI_CONNECT, hc->hw.conn);\n#ifdef REVERSE_BITORDER\n\tWrite_hfc(hc, HFCPCI_CIRM, hc->hw.cirm);\n#endif\n\treturn 0;\n}\n\nstatic void\ndeactivate_bchannel(struct bchannel *bch)\n{\n\tstruct hfc_pci\t*hc = bch->hw;\n\tu_long\t\tflags;\n\n\tspin_lock_irqsave(&hc->lock, flags);\n\tmISDN_clear_bchannel(bch);\n\tmode_hfcpci(bch, bch->nr, ISDN_P_NONE);\n\tspin_unlock_irqrestore(&hc->lock, flags);\n}\n\n \nstatic int\nchannel_bctrl(struct bchannel *bch, struct mISDN_ctrl_req *cq)\n{\n\treturn mISDN_ctrl_bchannel(bch, cq);\n}\nstatic int\nhfc_bctrl(struct mISDNchannel *ch, u_int cmd, void *arg)\n{\n\tstruct bchannel\t*bch = container_of(ch, struct bchannel, ch);\n\tstruct hfc_pci\t*hc = bch->hw;\n\tint\t\tret = -EINVAL;\n\tu_long\t\tflags;\n\n\tif (bch->debug & DEBUG_HW)\n\t\tprintk(KERN_DEBUG \"%s: cmd:%x %p\\n\", __func__, cmd, arg);\n\tswitch (cmd) {\n\tcase HW_TESTRX_RAW:\n\t\tspin_lock_irqsave(&hc->lock, flags);\n\t\tret = set_hfcpci_rxtest(bch, ISDN_P_B_RAW, (int)(long)arg);\n\t\tspin_unlock_irqrestore(&hc->lock, flags);\n\t\tbreak;\n\tcase HW_TESTRX_HDLC:\n\t\tspin_lock_irqsave(&hc->lock, flags);\n\t\tret = set_hfcpci_rxtest(bch, ISDN_P_B_HDLC, (int)(long)arg);\n\t\tspin_unlock_irqrestore(&hc->lock, flags);\n\t\tbreak;\n\tcase HW_TESTRX_OFF:\n\t\tspin_lock_irqsave(&hc->lock, flags);\n\t\tmode_hfcpci(bch, bch->nr, ISDN_P_NONE);\n\t\tspin_unlock_irqrestore(&hc->lock, flags);\n\t\tret = 0;\n\t\tbreak;\n\tcase CLOSE_CHANNEL:\n\t\ttest_and_clear_bit(FLG_OPEN, &bch->Flags);\n\t\tdeactivate_bchannel(bch);\n\t\tch->protocol = ISDN_P_NONE;\n\t\tch->peer = NULL;\n\t\tmodule_put(THIS_MODULE);\n\t\tret = 0;\n\t\tbreak;\n\tcase CONTROL_CHANNEL:\n\t\tret = channel_bctrl(bch, arg);\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_WARNING \"%s: unknown prim(%x)\\n\",\n\t\t       __func__, cmd);\n\t}\n\treturn ret;\n}\n\n \nstatic int\nhfcpci_l2l1D(struct mISDNchannel *ch, struct sk_buff *skb)\n{\n\tstruct mISDNdevice\t*dev = container_of(ch, struct mISDNdevice, D);\n\tstruct dchannel\t\t*dch = container_of(dev, struct dchannel, dev);\n\tstruct hfc_pci\t\t*hc = dch->hw;\n\tint\t\t\tret = -EINVAL;\n\tstruct mISDNhead\t*hh = mISDN_HEAD_P(skb);\n\tunsigned int\t\tid;\n\tu_long\t\t\tflags;\n\n\tswitch (hh->prim) {\n\tcase PH_DATA_REQ:\n\t\tspin_lock_irqsave(&hc->lock, flags);\n\t\tret = dchannel_senddata(dch, skb);\n\t\tif (ret > 0) {  \n\t\t\tid = hh->id;  \n\t\t\thfcpci_fill_dfifo(dch->hw);\n\t\t\tret = 0;\n\t\t\tspin_unlock_irqrestore(&hc->lock, flags);\n\t\t\tqueue_ch_frame(ch, PH_DATA_CNF, id, NULL);\n\t\t} else\n\t\t\tspin_unlock_irqrestore(&hc->lock, flags);\n\t\treturn ret;\n\tcase PH_ACTIVATE_REQ:\n\t\tspin_lock_irqsave(&hc->lock, flags);\n\t\tif (hc->hw.protocol == ISDN_P_NT_S0) {\n\t\t\tret = 0;\n\t\t\tif (test_bit(HFC_CFG_MASTER, &hc->cfg))\n\t\t\t\thc->hw.mst_m |= HFCPCI_MASTER;\n\t\t\tWrite_hfc(hc, HFCPCI_MST_MODE, hc->hw.mst_m);\n\t\t\tif (test_bit(FLG_ACTIVE, &dch->Flags)) {\n\t\t\t\tspin_unlock_irqrestore(&hc->lock, flags);\n\t\t\t\t_queue_data(&dch->dev.D, PH_ACTIVATE_IND,\n\t\t\t\t\t    MISDN_ID_ANY, 0, NULL, GFP_ATOMIC);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttest_and_set_bit(FLG_L2_ACTIVATED, &dch->Flags);\n\t\t\tWrite_hfc(hc, HFCPCI_STATES, HFCPCI_ACTIVATE |\n\t\t\t\t  HFCPCI_DO_ACTION | 1);\n\t\t} else\n\t\t\tret = l1_event(dch->l1, hh->prim);\n\t\tspin_unlock_irqrestore(&hc->lock, flags);\n\t\tbreak;\n\tcase PH_DEACTIVATE_REQ:\n\t\ttest_and_clear_bit(FLG_L2_ACTIVATED, &dch->Flags);\n\t\tspin_lock_irqsave(&hc->lock, flags);\n\t\tif (hc->hw.protocol == ISDN_P_NT_S0) {\n\t\t\tstruct sk_buff_head free_queue;\n\n\t\t\t__skb_queue_head_init(&free_queue);\n\t\t\t \n\t\t\tWrite_hfc(hc, HFCPCI_STATES, 0x40);\n\t\t\tskb_queue_splice_init(&dch->squeue, &free_queue);\n\t\t\tif (dch->tx_skb) {\n\t\t\t\t__skb_queue_tail(&free_queue, dch->tx_skb);\n\t\t\t\tdch->tx_skb = NULL;\n\t\t\t}\n\t\t\tdch->tx_idx = 0;\n\t\t\tif (dch->rx_skb) {\n\t\t\t\t__skb_queue_tail(&free_queue, dch->rx_skb);\n\t\t\t\tdch->rx_skb = NULL;\n\t\t\t}\n\t\t\ttest_and_clear_bit(FLG_TX_BUSY, &dch->Flags);\n\t\t\tif (test_and_clear_bit(FLG_BUSY_TIMER, &dch->Flags))\n\t\t\t\tdel_timer(&dch->timer);\n#ifdef FIXME\n\t\t\tif (test_and_clear_bit(FLG_L1_BUSY, &dch->Flags))\n\t\t\t\tdchannel_sched_event(&hc->dch, D_CLEARBUSY);\n#endif\n\t\t\thc->hw.mst_m &= ~HFCPCI_MASTER;\n\t\t\tWrite_hfc(hc, HFCPCI_MST_MODE, hc->hw.mst_m);\n\t\t\tret = 0;\n\t\t\tspin_unlock_irqrestore(&hc->lock, flags);\n\t\t\t__skb_queue_purge(&free_queue);\n\t\t} else {\n\t\t\tret = l1_event(dch->l1, hh->prim);\n\t\t\tspin_unlock_irqrestore(&hc->lock, flags);\n\t\t}\n\t\tbreak;\n\t}\n\tif (!ret)\n\t\tdev_kfree_skb(skb);\n\treturn ret;\n}\n\n \nstatic int\nhfcpci_l2l1B(struct mISDNchannel *ch, struct sk_buff *skb)\n{\n\tstruct bchannel\t\t*bch = container_of(ch, struct bchannel, ch);\n\tstruct hfc_pci\t\t*hc = bch->hw;\n\tint\t\t\tret = -EINVAL;\n\tstruct mISDNhead\t*hh = mISDN_HEAD_P(skb);\n\tunsigned long\t\tflags;\n\n\tswitch (hh->prim) {\n\tcase PH_DATA_REQ:\n\t\tspin_lock_irqsave(&hc->lock, flags);\n\t\tret = bchannel_senddata(bch, skb);\n\t\tif (ret > 0) {  \n\t\t\thfcpci_fill_fifo(bch);\n\t\t\tret = 0;\n\t\t}\n\t\tspin_unlock_irqrestore(&hc->lock, flags);\n\t\treturn ret;\n\tcase PH_ACTIVATE_REQ:\n\t\tspin_lock_irqsave(&hc->lock, flags);\n\t\tif (!test_and_set_bit(FLG_ACTIVE, &bch->Flags))\n\t\t\tret = mode_hfcpci(bch, bch->nr, ch->protocol);\n\t\telse\n\t\t\tret = 0;\n\t\tspin_unlock_irqrestore(&hc->lock, flags);\n\t\tif (!ret)\n\t\t\t_queue_data(ch, PH_ACTIVATE_IND, MISDN_ID_ANY, 0,\n\t\t\t\t    NULL, GFP_KERNEL);\n\t\tbreak;\n\tcase PH_DEACTIVATE_REQ:\n\t\tdeactivate_bchannel(bch);\n\t\t_queue_data(ch, PH_DEACTIVATE_IND, MISDN_ID_ANY, 0,\n\t\t\t    NULL, GFP_KERNEL);\n\t\tret = 0;\n\t\tbreak;\n\t}\n\tif (!ret)\n\t\tdev_kfree_skb(skb);\n\treturn ret;\n}\n\n \n\nstatic void\ninithfcpci(struct hfc_pci *hc)\n{\n\tprintk(KERN_DEBUG \"inithfcpci: entered\\n\");\n\ttimer_setup(&hc->dch.timer, hfcpci_dbusy_timer, 0);\n\thc->chanlimit = 2;\n\tmode_hfcpci(&hc->bch[0], 1, -1);\n\tmode_hfcpci(&hc->bch[1], 2, -1);\n}\n\n\nstatic int\ninit_card(struct hfc_pci *hc)\n{\n\tint\tcnt = 3;\n\tu_long\tflags;\n\n\tprintk(KERN_DEBUG \"init_card: entered\\n\");\n\n\n\tspin_lock_irqsave(&hc->lock, flags);\n\tdisable_hwirq(hc);\n\tspin_unlock_irqrestore(&hc->lock, flags);\n\tif (request_irq(hc->irq, hfcpci_int, IRQF_SHARED, \"HFC PCI\", hc)) {\n\t\tprintk(KERN_WARNING\n\t\t       \"mISDN: couldn't get interrupt %d\\n\", hc->irq);\n\t\treturn -EIO;\n\t}\n\tspin_lock_irqsave(&hc->lock, flags);\n\treset_hfcpci(hc);\n\twhile (cnt) {\n\t\tinithfcpci(hc);\n\t\t \n\t\tenable_hwirq(hc);\n\t\tspin_unlock_irqrestore(&hc->lock, flags);\n\t\t \n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tschedule_timeout((80 * HZ) / 1000);\n\t\tprintk(KERN_INFO \"HFC PCI: IRQ %d count %d\\n\",\n\t\t       hc->irq, hc->irqcnt);\n\t\t \n\t\tspin_lock_irqsave(&hc->lock, flags);\n\t\thc->hw.int_m1 &= ~HFCPCI_INTS_TIMER;\n\t\tWrite_hfc(hc, HFCPCI_INT_M1, hc->hw.int_m1);\n\t\t \n\t\tWrite_hfc(hc, HFCPCI_MST_MODE, hc->hw.mst_m);\n\t\tif (!hc->irqcnt) {\n\t\t\tprintk(KERN_WARNING\n\t\t\t       \"HFC PCI: IRQ(%d) getting no interrupts \"\n\t\t\t       \"during init %d\\n\", hc->irq, 4 - cnt);\n\t\t\tif (cnt == 1)\n\t\t\t\tbreak;\n\t\t\telse {\n\t\t\t\treset_hfcpci(hc);\n\t\t\t\tcnt--;\n\t\t\t}\n\t\t} else {\n\t\t\tspin_unlock_irqrestore(&hc->lock, flags);\n\t\t\thc->initdone = 1;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tdisable_hwirq(hc);\n\tspin_unlock_irqrestore(&hc->lock, flags);\n\tfree_irq(hc->irq, hc);\n\treturn -EIO;\n}\n\nstatic int\nchannel_ctrl(struct hfc_pci *hc, struct mISDN_ctrl_req *cq)\n{\n\tint\tret = 0;\n\tu_char\tslot;\n\n\tswitch (cq->op) {\n\tcase MISDN_CTRL_GETOP:\n\t\tcq->op = MISDN_CTRL_LOOP | MISDN_CTRL_CONNECT |\n\t\t\t MISDN_CTRL_DISCONNECT | MISDN_CTRL_L1_TIMER3;\n\t\tbreak;\n\tcase MISDN_CTRL_LOOP:\n\t\t \n\t\tif (cq->channel < 0 || cq->channel > 2) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tif (cq->channel & 1) {\n\t\t\tif (test_bit(HFC_CFG_SW_DD_DU, &hc->cfg))\n\t\t\t\tslot = 0xC0;\n\t\t\telse\n\t\t\t\tslot = 0x80;\n\t\t\tprintk(KERN_DEBUG \"%s: Write_hfc: B1_SSL/RSL 0x%x\\n\",\n\t\t\t       __func__, slot);\n\t\t\tWrite_hfc(hc, HFCPCI_B1_SSL, slot);\n\t\t\tWrite_hfc(hc, HFCPCI_B1_RSL, slot);\n\t\t\thc->hw.conn = (hc->hw.conn & ~7) | 6;\n\t\t\tWrite_hfc(hc, HFCPCI_CONNECT, hc->hw.conn);\n\t\t}\n\t\tif (cq->channel & 2) {\n\t\t\tif (test_bit(HFC_CFG_SW_DD_DU, &hc->cfg))\n\t\t\t\tslot = 0xC1;\n\t\t\telse\n\t\t\t\tslot = 0x81;\n\t\t\tprintk(KERN_DEBUG \"%s: Write_hfc: B2_SSL/RSL 0x%x\\n\",\n\t\t\t       __func__, slot);\n\t\t\tWrite_hfc(hc, HFCPCI_B2_SSL, slot);\n\t\t\tWrite_hfc(hc, HFCPCI_B2_RSL, slot);\n\t\t\thc->hw.conn = (hc->hw.conn & ~0x38) | 0x30;\n\t\t\tWrite_hfc(hc, HFCPCI_CONNECT, hc->hw.conn);\n\t\t}\n\t\tif (cq->channel & 3)\n\t\t\thc->hw.trm |= 0x80;\t \n\t\telse {\n\t\t\thc->hw.conn = (hc->hw.conn & ~0x3f) | 0x09;\n\t\t\tWrite_hfc(hc, HFCPCI_CONNECT, hc->hw.conn);\n\t\t\thc->hw.trm &= 0x7f;\t \n\t\t}\n\t\tWrite_hfc(hc, HFCPCI_TRM, hc->hw.trm);\n\t\tbreak;\n\tcase MISDN_CTRL_CONNECT:\n\t\tif (cq->channel == cq->p1) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tif (cq->channel < 1 || cq->channel > 2 ||\n\t\t    cq->p1 < 1 || cq->p1 > 2) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tif (test_bit(HFC_CFG_SW_DD_DU, &hc->cfg))\n\t\t\tslot = 0xC0;\n\t\telse\n\t\t\tslot = 0x80;\n\t\tprintk(KERN_DEBUG \"%s: Write_hfc: B1_SSL/RSL 0x%x\\n\",\n\t\t       __func__, slot);\n\t\tWrite_hfc(hc, HFCPCI_B1_SSL, slot);\n\t\tWrite_hfc(hc, HFCPCI_B2_RSL, slot);\n\t\tif (test_bit(HFC_CFG_SW_DD_DU, &hc->cfg))\n\t\t\tslot = 0xC1;\n\t\telse\n\t\t\tslot = 0x81;\n\t\tprintk(KERN_DEBUG \"%s: Write_hfc: B2_SSL/RSL 0x%x\\n\",\n\t\t       __func__, slot);\n\t\tWrite_hfc(hc, HFCPCI_B2_SSL, slot);\n\t\tWrite_hfc(hc, HFCPCI_B1_RSL, slot);\n\t\thc->hw.conn = (hc->hw.conn & ~0x3f) | 0x36;\n\t\tWrite_hfc(hc, HFCPCI_CONNECT, hc->hw.conn);\n\t\thc->hw.trm |= 0x80;\n\t\tWrite_hfc(hc, HFCPCI_TRM, hc->hw.trm);\n\t\tbreak;\n\tcase MISDN_CTRL_DISCONNECT:\n\t\thc->hw.conn = (hc->hw.conn & ~0x3f) | 0x09;\n\t\tWrite_hfc(hc, HFCPCI_CONNECT, hc->hw.conn);\n\t\thc->hw.trm &= 0x7f;\t \n\t\tbreak;\n\tcase MISDN_CTRL_L1_TIMER3:\n\t\tret = l1_event(hc->dch.l1, HW_TIMER3_VALUE | (cq->p1 & 0xff));\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_WARNING \"%s: unknown Op %x\\n\",\n\t\t       __func__, cq->op);\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic int\nopen_dchannel(struct hfc_pci *hc, struct mISDNchannel *ch,\n\t      struct channel_req *rq)\n{\n\tint err = 0;\n\n\tif (debug & DEBUG_HW_OPEN)\n\t\tprintk(KERN_DEBUG \"%s: dev(%d) open from %p\\n\", __func__,\n\t\t       hc->dch.dev.id, __builtin_return_address(0));\n\tif (rq->protocol == ISDN_P_NONE)\n\t\treturn -EINVAL;\n\tif (rq->adr.channel == 1) {\n\t\t \n\t\treturn -EINVAL;\n\t}\n\tif (!hc->initdone) {\n\t\tif (rq->protocol == ISDN_P_TE_S0) {\n\t\t\terr = create_l1(&hc->dch, hfc_l1callback);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\thc->hw.protocol = rq->protocol;\n\t\tch->protocol = rq->protocol;\n\t\terr = init_card(hc);\n\t\tif (err)\n\t\t\treturn err;\n\t} else {\n\t\tif (rq->protocol != ch->protocol) {\n\t\t\tif (hc->hw.protocol == ISDN_P_TE_S0)\n\t\t\t\tl1_event(hc->dch.l1, CLOSE_CHANNEL);\n\t\t\tif (rq->protocol == ISDN_P_TE_S0) {\n\t\t\t\terr = create_l1(&hc->dch, hfc_l1callback);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t}\n\t\t\thc->hw.protocol = rq->protocol;\n\t\t\tch->protocol = rq->protocol;\n\t\t\thfcpci_setmode(hc);\n\t\t}\n\t}\n\n\tif (((ch->protocol == ISDN_P_NT_S0) && (hc->dch.state == 3)) ||\n\t    ((ch->protocol == ISDN_P_TE_S0) && (hc->dch.state == 7))) {\n\t\t_queue_data(ch, PH_ACTIVATE_IND, MISDN_ID_ANY,\n\t\t\t    0, NULL, GFP_KERNEL);\n\t}\n\trq->ch = ch;\n\tif (!try_module_get(THIS_MODULE))\n\t\tprintk(KERN_WARNING \"%s:cannot get module\\n\", __func__);\n\treturn 0;\n}\n\nstatic int\nopen_bchannel(struct hfc_pci *hc, struct channel_req *rq)\n{\n\tstruct bchannel\t\t*bch;\n\n\tif (rq->adr.channel == 0 || rq->adr.channel > 2)\n\t\treturn -EINVAL;\n\tif (rq->protocol == ISDN_P_NONE)\n\t\treturn -EINVAL;\n\tbch = &hc->bch[rq->adr.channel - 1];\n\tif (test_and_set_bit(FLG_OPEN, &bch->Flags))\n\t\treturn -EBUSY;  \n\tbch->ch.protocol = rq->protocol;\n\trq->ch = &bch->ch;  \n\tif (!try_module_get(THIS_MODULE))\n\t\tprintk(KERN_WARNING \"%s:cannot get module\\n\", __func__);\n\treturn 0;\n}\n\n \nstatic int\nhfc_dctrl(struct mISDNchannel *ch, u_int cmd, void *arg)\n{\n\tstruct mISDNdevice\t*dev = container_of(ch, struct mISDNdevice, D);\n\tstruct dchannel\t\t*dch = container_of(dev, struct dchannel, dev);\n\tstruct hfc_pci\t\t*hc = dch->hw;\n\tstruct channel_req\t*rq;\n\tint\t\t\terr = 0;\n\n\tif (dch->debug & DEBUG_HW)\n\t\tprintk(KERN_DEBUG \"%s: cmd:%x %p\\n\",\n\t\t       __func__, cmd, arg);\n\tswitch (cmd) {\n\tcase OPEN_CHANNEL:\n\t\trq = arg;\n\t\tif ((rq->protocol == ISDN_P_TE_S0) ||\n\t\t    (rq->protocol == ISDN_P_NT_S0))\n\t\t\terr = open_dchannel(hc, ch, rq);\n\t\telse\n\t\t\terr = open_bchannel(hc, rq);\n\t\tbreak;\n\tcase CLOSE_CHANNEL:\n\t\tif (debug & DEBUG_HW_OPEN)\n\t\t\tprintk(KERN_DEBUG \"%s: dev(%d) close from %p\\n\",\n\t\t\t       __func__, hc->dch.dev.id,\n\t\t\t       __builtin_return_address(0));\n\t\tmodule_put(THIS_MODULE);\n\t\tbreak;\n\tcase CONTROL_CHANNEL:\n\t\terr = channel_ctrl(hc, arg);\n\t\tbreak;\n\tdefault:\n\t\tif (dch->debug & DEBUG_HW)\n\t\t\tprintk(KERN_DEBUG \"%s: unknown command %x\\n\",\n\t\t\t       __func__, cmd);\n\t\treturn -EINVAL;\n\t}\n\treturn err;\n}\n\nstatic int\nsetup_hw(struct hfc_pci *hc)\n{\n\tvoid\t*buffer;\n\n\tprintk(KERN_INFO \"mISDN: HFC-PCI driver %s\\n\", hfcpci_revision);\n\thc->hw.cirm = 0;\n\thc->dch.state = 0;\n\tpci_set_master(hc->pdev);\n\tif (!hc->irq) {\n\t\tprintk(KERN_WARNING \"HFC-PCI: No IRQ for PCI card found\\n\");\n\t\treturn -EINVAL;\n\t}\n\thc->hw.pci_io =\n\t\t(char __iomem *)(unsigned long)hc->pdev->resource[1].start;\n\n\tif (!hc->hw.pci_io) {\n\t\tprintk(KERN_WARNING \"HFC-PCI: No IO-Mem for PCI card found\\n\");\n\t\treturn -ENOMEM;\n\t}\n\t \n\t \n\tif (dma_set_mask(&hc->pdev->dev, 0xFFFF8000)) {\n\t\tprintk(KERN_WARNING\n\t\t       \"HFC-PCI: No usable DMA configuration!\\n\");\n\t\treturn -EIO;\n\t}\n\tbuffer = dma_alloc_coherent(&hc->pdev->dev, 0x8000, &hc->hw.dmahandle,\n\t\t\t\t    GFP_KERNEL);\n\t \n\tif (!buffer) {\n\t\tprintk(KERN_WARNING\n\t\t       \"HFC-PCI: Error allocating memory for FIFO!\\n\");\n\t\treturn -ENOMEM;\n\t}\n\thc->hw.fifos = buffer;\n\tpci_write_config_dword(hc->pdev, 0x80, hc->hw.dmahandle);\n\thc->hw.pci_io = ioremap((ulong) hc->hw.pci_io, 256);\n\tif (unlikely(!hc->hw.pci_io)) {\n\t\tprintk(KERN_WARNING\n\t\t       \"HFC-PCI: Error in ioremap for PCI!\\n\");\n\t\tdma_free_coherent(&hc->pdev->dev, 0x8000, hc->hw.fifos,\n\t\t\t\t  hc->hw.dmahandle);\n\t\treturn -ENOMEM;\n\t}\n\n\tprintk(KERN_INFO\n\t       \"HFC-PCI: defined at mem %#lx fifo %p(%pad) IRQ %d HZ %d\\n\",\n\t       (u_long) hc->hw.pci_io, hc->hw.fifos,\n\t       &hc->hw.dmahandle, hc->irq, HZ);\n\n\t \n\tpci_write_config_word(hc->pdev, PCI_COMMAND, PCI_ENA_MEMIO);\n\thc->hw.int_m2 = 0;\n\tdisable_hwirq(hc);\n\thc->hw.int_m1 = 0;\n\tWrite_hfc(hc, HFCPCI_INT_M1, hc->hw.int_m1);\n\t \n\t \n\ttimer_setup(&hc->hw.timer, hfcpci_Timer, 0);\n\t \n\ttest_and_set_bit(HFC_CFG_MASTER, &hc->cfg);\n\treturn 0;\n}\n\nstatic void\nrelease_card(struct hfc_pci *hc) {\n\tu_long\tflags;\n\n\tspin_lock_irqsave(&hc->lock, flags);\n\thc->hw.int_m2 = 0;  \n\tdisable_hwirq(hc);\n\tmode_hfcpci(&hc->bch[0], 1, ISDN_P_NONE);\n\tmode_hfcpci(&hc->bch[1], 2, ISDN_P_NONE);\n\tif (hc->dch.timer.function != NULL) {\n\t\tdel_timer(&hc->dch.timer);\n\t\thc->dch.timer.function = NULL;\n\t}\n\tspin_unlock_irqrestore(&hc->lock, flags);\n\tif (hc->hw.protocol == ISDN_P_TE_S0)\n\t\tl1_event(hc->dch.l1, CLOSE_CHANNEL);\n\tif (hc->initdone)\n\t\tfree_irq(hc->irq, hc);\n\trelease_io_hfcpci(hc);  \n\tmISDN_unregister_device(&hc->dch.dev);\n\tmISDN_freebchannel(&hc->bch[1]);\n\tmISDN_freebchannel(&hc->bch[0]);\n\tmISDN_freedchannel(&hc->dch);\n\tpci_set_drvdata(hc->pdev, NULL);\n\tkfree(hc);\n}\n\nstatic int\nsetup_card(struct hfc_pci *card)\n{\n\tint\t\terr = -EINVAL;\n\tu_int\t\ti;\n\tchar\t\tname[MISDN_MAX_IDLEN];\n\n\tcard->dch.debug = debug;\n\tspin_lock_init(&card->lock);\n\tmISDN_initdchannel(&card->dch, MAX_DFRAME_LEN_L1, ph_state);\n\tcard->dch.hw = card;\n\tcard->dch.dev.Dprotocols = (1 << ISDN_P_TE_S0) | (1 << ISDN_P_NT_S0);\n\tcard->dch.dev.Bprotocols = (1 << (ISDN_P_B_RAW & ISDN_P_B_MASK)) |\n\t\t(1 << (ISDN_P_B_HDLC & ISDN_P_B_MASK));\n\tcard->dch.dev.D.send = hfcpci_l2l1D;\n\tcard->dch.dev.D.ctrl = hfc_dctrl;\n\tcard->dch.dev.nrbchan = 2;\n\tfor (i = 0; i < 2; i++) {\n\t\tcard->bch[i].nr = i + 1;\n\t\tset_channelmap(i + 1, card->dch.dev.channelmap);\n\t\tcard->bch[i].debug = debug;\n\t\tmISDN_initbchannel(&card->bch[i], MAX_DATA_MEM, poll >> 1);\n\t\tcard->bch[i].hw = card;\n\t\tcard->bch[i].ch.send = hfcpci_l2l1B;\n\t\tcard->bch[i].ch.ctrl = hfc_bctrl;\n\t\tcard->bch[i].ch.nr = i + 1;\n\t\tlist_add(&card->bch[i].ch.list, &card->dch.dev.bchannels);\n\t}\n\terr = setup_hw(card);\n\tif (err)\n\t\tgoto error;\n\tsnprintf(name, MISDN_MAX_IDLEN - 1, \"hfc-pci.%d\", HFC_cnt + 1);\n\terr = mISDN_register_device(&card->dch.dev, &card->pdev->dev, name);\n\tif (err)\n\t\tgoto error;\n\tHFC_cnt++;\n\tprintk(KERN_INFO \"HFC %d cards installed\\n\", HFC_cnt);\n\treturn 0;\nerror:\n\tmISDN_freebchannel(&card->bch[1]);\n\tmISDN_freebchannel(&card->bch[0]);\n\tmISDN_freedchannel(&card->dch);\n\tkfree(card);\n\treturn err;\n}\n\n \nstruct _hfc_map {\n\tu_int\tsubtype;\n\tu_int\tflag;\n\tchar\t*name;\n};\n\nstatic const struct _hfc_map hfc_map[] =\n{\n\t{HFC_CCD_2BD0, 0, \"CCD/Billion/Asuscom 2BD0\"},\n\t{HFC_CCD_B000, 0, \"Billion B000\"},\n\t{HFC_CCD_B006, 0, \"Billion B006\"},\n\t{HFC_CCD_B007, 0, \"Billion B007\"},\n\t{HFC_CCD_B008, 0, \"Billion B008\"},\n\t{HFC_CCD_B009, 0, \"Billion B009\"},\n\t{HFC_CCD_B00A, 0, \"Billion B00A\"},\n\t{HFC_CCD_B00B, 0, \"Billion B00B\"},\n\t{HFC_CCD_B00C, 0, \"Billion B00C\"},\n\t{HFC_CCD_B100, 0, \"Seyeon B100\"},\n\t{HFC_CCD_B700, 0, \"Primux II S0 B700\"},\n\t{HFC_CCD_B701, 0, \"Primux II S0 NT B701\"},\n\t{HFC_ABOCOM_2BD1, 0, \"Abocom/Magitek 2BD1\"},\n\t{HFC_ASUS_0675, 0, \"Asuscom/Askey 675\"},\n\t{HFC_BERKOM_TCONCEPT, 0, \"German telekom T-Concept\"},\n\t{HFC_BERKOM_A1T, 0, \"German telekom A1T\"},\n\t{HFC_ANIGMA_MC145575, 0, \"Motorola MC145575\"},\n\t{HFC_ZOLTRIX_2BD0, 0, \"Zoltrix 2BD0\"},\n\t{HFC_DIGI_DF_M_IOM2_E, 0,\n\t \"Digi International DataFire Micro V IOM2 (Europe)\"},\n\t{HFC_DIGI_DF_M_E, 0,\n\t \"Digi International DataFire Micro V (Europe)\"},\n\t{HFC_DIGI_DF_M_IOM2_A, 0,\n\t \"Digi International DataFire Micro V IOM2 (North America)\"},\n\t{HFC_DIGI_DF_M_A, 0,\n\t \"Digi International DataFire Micro V (North America)\"},\n\t{HFC_SITECOM_DC105V2, 0, \"Sitecom Connectivity DC-105 ISDN TA\"},\n\t{},\n};\n\nstatic const struct pci_device_id hfc_ids[] =\n{\n\t{ PCI_VDEVICE(CCD, PCI_DEVICE_ID_CCD_2BD0),\n\t  (unsigned long) &hfc_map[0] },\n\t{ PCI_VDEVICE(CCD, PCI_DEVICE_ID_CCD_B000),\n\t  (unsigned long) &hfc_map[1] },\n\t{ PCI_VDEVICE(CCD, PCI_DEVICE_ID_CCD_B006),\n\t  (unsigned long) &hfc_map[2] },\n\t{ PCI_VDEVICE(CCD, PCI_DEVICE_ID_CCD_B007),\n\t  (unsigned long) &hfc_map[3] },\n\t{ PCI_VDEVICE(CCD, PCI_DEVICE_ID_CCD_B008),\n\t  (unsigned long) &hfc_map[4] },\n\t{ PCI_VDEVICE(CCD, PCI_DEVICE_ID_CCD_B009),\n\t  (unsigned long) &hfc_map[5] },\n\t{ PCI_VDEVICE(CCD, PCI_DEVICE_ID_CCD_B00A),\n\t  (unsigned long) &hfc_map[6] },\n\t{ PCI_VDEVICE(CCD, PCI_DEVICE_ID_CCD_B00B),\n\t  (unsigned long) &hfc_map[7] },\n\t{ PCI_VDEVICE(CCD, PCI_DEVICE_ID_CCD_B00C),\n\t  (unsigned long) &hfc_map[8] },\n\t{ PCI_VDEVICE(CCD, PCI_DEVICE_ID_CCD_B100),\n\t  (unsigned long) &hfc_map[9] },\n\t{ PCI_VDEVICE(CCD, PCI_DEVICE_ID_CCD_B700),\n\t  (unsigned long) &hfc_map[10] },\n\t{ PCI_VDEVICE(CCD, PCI_DEVICE_ID_CCD_B701),\n\t  (unsigned long) &hfc_map[11] },\n\t{ PCI_VDEVICE(ABOCOM, PCI_DEVICE_ID_ABOCOM_2BD1),\n\t  (unsigned long) &hfc_map[12] },\n\t{ PCI_VDEVICE(ASUSTEK, PCI_DEVICE_ID_ASUSTEK_0675),\n\t  (unsigned long) &hfc_map[13] },\n\t{ PCI_VDEVICE(BERKOM, PCI_DEVICE_ID_BERKOM_T_CONCEPT),\n\t  (unsigned long) &hfc_map[14] },\n\t{ PCI_VDEVICE(BERKOM, PCI_DEVICE_ID_BERKOM_A1T),\n\t  (unsigned long) &hfc_map[15] },\n\t{ PCI_VDEVICE(ANIGMA, PCI_DEVICE_ID_ANIGMA_MC145575),\n\t  (unsigned long) &hfc_map[16] },\n\t{ PCI_VDEVICE(ZOLTRIX, PCI_DEVICE_ID_ZOLTRIX_2BD0),\n\t  (unsigned long) &hfc_map[17] },\n\t{ PCI_VDEVICE(DIGI, PCI_DEVICE_ID_DIGI_DF_M_IOM2_E),\n\t  (unsigned long) &hfc_map[18] },\n\t{ PCI_VDEVICE(DIGI, PCI_DEVICE_ID_DIGI_DF_M_E),\n\t  (unsigned long) &hfc_map[19] },\n\t{ PCI_VDEVICE(DIGI, PCI_DEVICE_ID_DIGI_DF_M_IOM2_A),\n\t  (unsigned long) &hfc_map[20] },\n\t{ PCI_VDEVICE(DIGI, PCI_DEVICE_ID_DIGI_DF_M_A),\n\t  (unsigned long) &hfc_map[21] },\n\t{ PCI_VDEVICE(SITECOM, PCI_DEVICE_ID_SITECOM_DC105V2),\n\t  (unsigned long) &hfc_map[22] },\n\t{},\n};\n\nstatic int\nhfc_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tint\t\terr = -ENOMEM;\n\tstruct hfc_pci\t*card;\n\tstruct _hfc_map\t*m = (struct _hfc_map *)ent->driver_data;\n\n\tcard = kzalloc(sizeof(struct hfc_pci), GFP_KERNEL);\n\tif (!card) {\n\t\tprintk(KERN_ERR \"No kmem for HFC card\\n\");\n\t\treturn err;\n\t}\n\tcard->pdev = pdev;\n\tcard->subtype = m->subtype;\n\terr = pci_enable_device(pdev);\n\tif (err) {\n\t\tkfree(card);\n\t\treturn err;\n\t}\n\n\tprintk(KERN_INFO \"mISDN_hfcpci: found adapter %s at %s\\n\",\n\t       m->name, pci_name(pdev));\n\n\tcard->irq = pdev->irq;\n\tpci_set_drvdata(pdev, card);\n\terr = setup_card(card);\n\tif (err)\n\t\tpci_set_drvdata(pdev, NULL);\n\treturn err;\n}\n\nstatic void\nhfc_remove_pci(struct pci_dev *pdev)\n{\n\tstruct hfc_pci\t*card = pci_get_drvdata(pdev);\n\n\tif (card)\n\t\trelease_card(card);\n\telse\n\t\tif (debug)\n\t\t\tprintk(KERN_DEBUG \"%s: drvdata already removed\\n\",\n\t\t\t       __func__);\n}\n\n\nstatic struct pci_driver hfc_driver = {\n\t.name = \"hfcpci\",\n\t.probe = hfc_probe,\n\t.remove = hfc_remove_pci,\n\t.id_table = hfc_ids,\n};\n\nstatic int\n_hfcpci_softirq(struct device *dev, void *unused)\n{\n\tstruct hfc_pci  *hc = dev_get_drvdata(dev);\n\tstruct bchannel *bch;\n\tif (hc == NULL)\n\t\treturn 0;\n\n\tif (hc->hw.int_m2 & HFCPCI_IRQ_ENABLE) {\n\t\tspin_lock_irq(&hc->lock);\n\t\tbch = Sel_BCS(hc, hc->hw.bswapped ? 2 : 1);\n\t\tif (bch && bch->state == ISDN_P_B_RAW) {  \n\t\t\tmain_rec_hfcpci(bch);\n\t\t\ttx_birq(bch);\n\t\t}\n\t\tbch = Sel_BCS(hc, hc->hw.bswapped ? 1 : 2);\n\t\tif (bch && bch->state == ISDN_P_B_RAW) {  \n\t\t\tmain_rec_hfcpci(bch);\n\t\t\ttx_birq(bch);\n\t\t}\n\t\tspin_unlock_irq(&hc->lock);\n\t}\n\treturn 0;\n}\n\nstatic void\nhfcpci_softirq(struct timer_list *unused)\n{\n\tWARN_ON_ONCE(driver_for_each_device(&hfc_driver.driver, NULL, NULL,\n\t\t\t\t      _hfcpci_softirq) != 0);\n\n\t \n\tif ((s32)(hfc_jiffies + tics - jiffies) <= 0)\n\t\thfc_jiffies = jiffies + 1;\n\telse\n\t\thfc_jiffies += tics;\n\thfc_tl.expires = hfc_jiffies;\n\tadd_timer(&hfc_tl);\n}\n\nstatic int __init\nHFC_init(void)\n{\n\tint\t\terr;\n\n\tif (!poll)\n\t\tpoll = HFCPCI_BTRANS_THRESHOLD;\n\n\tif (poll != HFCPCI_BTRANS_THRESHOLD) {\n\t\ttics = (poll * HZ) / 8000;\n\t\tif (tics < 1)\n\t\t\ttics = 1;\n\t\tpoll = (tics * 8000) / HZ;\n\t\tif (poll > 256 || poll < 8) {\n\t\t\tprintk(KERN_ERR \"%s: Wrong poll value %d not in range \"\n\t\t\t       \"of 8..256.\\n\", __func__, poll);\n\t\t\terr = -EINVAL;\n\t\t\treturn err;\n\t\t}\n\t}\n\tif (poll != HFCPCI_BTRANS_THRESHOLD) {\n\t\tprintk(KERN_INFO \"%s: Using alternative poll value of %d\\n\",\n\t\t       __func__, poll);\n\t\ttimer_setup(&hfc_tl, hfcpci_softirq, 0);\n\t\thfc_tl.expires = jiffies + tics;\n\t\thfc_jiffies = hfc_tl.expires;\n\t\tadd_timer(&hfc_tl);\n\t} else\n\t\ttics = 0;  \n\n\terr = pci_register_driver(&hfc_driver);\n\tif (err) {\n\t\tif (timer_pending(&hfc_tl))\n\t\t\tdel_timer(&hfc_tl);\n\t}\n\n\treturn err;\n}\n\nstatic void __exit\nHFC_cleanup(void)\n{\n\tdel_timer_sync(&hfc_tl);\n\n\tpci_unregister_driver(&hfc_driver);\n}\n\nmodule_init(HFC_init);\nmodule_exit(HFC_cleanup);\n\nMODULE_DEVICE_TABLE(pci, hfc_ids);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}