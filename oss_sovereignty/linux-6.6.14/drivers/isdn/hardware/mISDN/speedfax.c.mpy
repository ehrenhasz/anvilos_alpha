{
  "module_name": "speedfax.c",
  "hash_id": "dcac8147e004ff19f7f35d6e26114a4eef1d9ebd4957b656cad2b9fe060933f2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/isdn/hardware/mISDN/speedfax.c",
  "human_readable_source": "\n \n\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/delay.h>\n#include <linux/mISDNhw.h>\n#include <linux/firmware.h>\n#include \"ipac.h\"\n#include \"isar.h\"\n\n#define SPEEDFAX_REV\t\"2.0\"\n\n#define PCI_SUBVENDOR_SPEEDFAX_PYRAMID\t0x51\n#define PCI_SUBVENDOR_SPEEDFAX_PCI\t0x54\n#define PCI_SUB_ID_SEDLBAUER\t\t0x01\n\n#define SFAX_PCI_ADDR\t\t0xc8\n#define SFAX_PCI_ISAC\t\t0xd0\n#define SFAX_PCI_ISAR\t\t0xe0\n\n \n\n#define TIGER_RESET_ADDR\t0x00\n#define TIGER_EXTERN_RESET_ON\t0x01\n#define TIGER_EXTERN_RESET_OFF\t0x00\n#define TIGER_AUX_CTRL\t\t0x02\n#define TIGER_AUX_DATA\t\t0x03\n#define TIGER_AUX_IRQMASK\t0x05\n#define TIGER_AUX_STATUS\t0x07\n\n \n#define SFAX_AUX_IOMASK\t\t0xdd\t \n#define SFAX_ISAR_RESET_BIT_OFF 0x00\n#define SFAX_ISAR_RESET_BIT_ON\t0x01\n#define SFAX_TIGER_IRQ_BIT\t0x02\n#define SFAX_LED1_BIT\t\t0x08\n#define SFAX_LED2_BIT\t\t0x10\n\n#define SFAX_PCI_RESET_ON\t(SFAX_ISAR_RESET_BIT_ON)\n#define SFAX_PCI_RESET_OFF\t(SFAX_LED1_BIT | SFAX_LED2_BIT)\n\nstatic int sfax_cnt;\nstatic u32 debug;\nstatic u32 irqloops = 4;\n\nstruct sfax_hw {\n\tstruct list_head\tlist;\n\tstruct pci_dev\t\t*pdev;\n\tchar\t\t\tname[MISDN_MAX_IDLEN];\n\tu32\t\t\tirq;\n\tu32\t\t\tirqcnt;\n\tu32\t\t\tcfg;\n\tstruct _ioport\t\tp_isac;\n\tstruct _ioport\t\tp_isar;\n\tu8\t\t\taux_data;\n\tspinlock_t\t\tlock;\t \n\tstruct isac_hw\t\tisac;\n\tstruct isar_hw\t\tisar;\n};\n\nstatic LIST_HEAD(Cards);\nstatic DEFINE_RWLOCK(card_lock);  \n\nstatic void\n_set_debug(struct sfax_hw *card)\n{\n\tcard->isac.dch.debug = debug;\n\tcard->isar.ch[0].bch.debug = debug;\n\tcard->isar.ch[1].bch.debug = debug;\n}\n\nstatic int\nset_debug(const char *val, const struct kernel_param *kp)\n{\n\tint ret;\n\tstruct sfax_hw *card;\n\n\tret = param_set_uint(val, kp);\n\tif (!ret) {\n\t\tread_lock(&card_lock);\n\t\tlist_for_each_entry(card, &Cards, list)\n\t\t\t_set_debug(card);\n\t\tread_unlock(&card_lock);\n\t}\n\treturn ret;\n}\n\nMODULE_AUTHOR(\"Karsten Keil\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_VERSION(SPEEDFAX_REV);\nMODULE_FIRMWARE(\"isdn/ISAR.BIN\");\nmodule_param_call(debug, set_debug, param_get_uint, &debug, S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(debug, \"Speedfax debug mask\");\nmodule_param(irqloops, uint, S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(irqloops, \"Speedfax maximal irqloops (default 4)\");\n\nIOFUNC_IND(ISAC, sfax_hw, p_isac)\nIOFUNC_IND(ISAR, sfax_hw, p_isar)\n\nstatic irqreturn_t\nspeedfax_irq(int intno, void *dev_id)\n{\n\tstruct sfax_hw\t*sf = dev_id;\n\tu8 val;\n\tint cnt = irqloops;\n\n\tspin_lock(&sf->lock);\n\tval = inb(sf->cfg + TIGER_AUX_STATUS);\n\tif (val & SFAX_TIGER_IRQ_BIT) {  \n\t\tspin_unlock(&sf->lock);\n\t\treturn IRQ_NONE;  \n\t}\n\tsf->irqcnt++;\n\tval = ReadISAR_IND(sf, ISAR_IRQBIT);\nStart_ISAR:\n\tif (val & ISAR_IRQSTA)\n\t\tmISDNisar_irq(&sf->isar);\n\tval = ReadISAC_IND(sf, ISAC_ISTA);\n\tif (val)\n\t\tmISDNisac_irq(&sf->isac, val);\n\tval = ReadISAR_IND(sf, ISAR_IRQBIT);\n\tif ((val & ISAR_IRQSTA) && cnt--)\n\t\tgoto Start_ISAR;\n\tif (cnt < irqloops)\n\t\tpr_debug(\"%s: %d irqloops cpu%d\\n\", sf->name,\n\t\t\t irqloops - cnt, smp_processor_id());\n\tif (irqloops && !cnt)\n\t\tpr_notice(\"%s: %d IRQ LOOP cpu%d\\n\", sf->name,\n\t\t\t  irqloops, smp_processor_id());\n\tspin_unlock(&sf->lock);\n\treturn IRQ_HANDLED;\n}\n\nstatic void\nenable_hwirq(struct sfax_hw *sf)\n{\n\tWriteISAC_IND(sf, ISAC_MASK, 0);\n\tWriteISAR_IND(sf, ISAR_IRQBIT, ISAR_IRQMSK);\n\toutb(SFAX_TIGER_IRQ_BIT, sf->cfg + TIGER_AUX_IRQMASK);\n}\n\nstatic void\ndisable_hwirq(struct sfax_hw *sf)\n{\n\tWriteISAC_IND(sf, ISAC_MASK, 0xFF);\n\tWriteISAR_IND(sf, ISAR_IRQBIT, 0);\n\toutb(0, sf->cfg + TIGER_AUX_IRQMASK);\n}\n\nstatic void\nreset_speedfax(struct sfax_hw *sf)\n{\n\n\tpr_debug(\"%s: resetting card\\n\", sf->name);\n\toutb(TIGER_EXTERN_RESET_ON, sf->cfg + TIGER_RESET_ADDR);\n\toutb(SFAX_PCI_RESET_ON, sf->cfg + TIGER_AUX_DATA);\n\tmdelay(1);\n\toutb(TIGER_EXTERN_RESET_OFF, sf->cfg + TIGER_RESET_ADDR);\n\tsf->aux_data = SFAX_PCI_RESET_OFF;\n\toutb(sf->aux_data, sf->cfg + TIGER_AUX_DATA);\n\tmdelay(1);\n}\n\nstatic int\nsfax_ctrl(struct sfax_hw  *sf, u32 cmd, u_long arg)\n{\n\tint ret = 0;\n\n\tswitch (cmd) {\n\tcase HW_RESET_REQ:\n\t\treset_speedfax(sf);\n\t\tbreak;\n\tcase HW_ACTIVATE_IND:\n\t\tif (arg & 1)\n\t\t\tsf->aux_data &= ~SFAX_LED1_BIT;\n\t\tif (arg & 2)\n\t\t\tsf->aux_data &= ~SFAX_LED2_BIT;\n\t\toutb(sf->aux_data, sf->cfg + TIGER_AUX_DATA);\n\t\tbreak;\n\tcase HW_DEACT_IND:\n\t\tif (arg & 1)\n\t\t\tsf->aux_data |= SFAX_LED1_BIT;\n\t\tif (arg & 2)\n\t\t\tsf->aux_data |= SFAX_LED2_BIT;\n\t\toutb(sf->aux_data, sf->cfg + TIGER_AUX_DATA);\n\t\tbreak;\n\tdefault:\n\t\tpr_info(\"%s: %s unknown command %x %lx\\n\",\n\t\t\tsf->name, __func__, cmd, arg);\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic int\nchannel_ctrl(struct sfax_hw  *sf, struct mISDN_ctrl_req *cq)\n{\n\tint\tret = 0;\n\n\tswitch (cq->op) {\n\tcase MISDN_CTRL_GETOP:\n\t\tcq->op = MISDN_CTRL_LOOP | MISDN_CTRL_L1_TIMER3;\n\t\tbreak;\n\tcase MISDN_CTRL_LOOP:\n\t\t \n\t\tif (cq->channel < 0 || cq->channel > 3) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tret = sf->isac.ctrl(&sf->isac, HW_TESTLOOP, cq->channel);\n\t\tbreak;\n\tcase MISDN_CTRL_L1_TIMER3:\n\t\tret = sf->isac.ctrl(&sf->isac, HW_TIMER3_VALUE, cq->p1);\n\t\tbreak;\n\tdefault:\n\t\tpr_info(\"%s: unknown Op %x\\n\", sf->name, cq->op);\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic int\nsfax_dctrl(struct mISDNchannel *ch, u32 cmd, void *arg)\n{\n\tstruct mISDNdevice\t*dev = container_of(ch, struct mISDNdevice, D);\n\tstruct dchannel\t\t*dch = container_of(dev, struct dchannel, dev);\n\tstruct sfax_hw\t\t*sf = dch->hw;\n\tstruct channel_req\t*rq;\n\tint\t\t\terr = 0;\n\n\tpr_debug(\"%s: cmd:%x %p\\n\", sf->name, cmd, arg);\n\tswitch (cmd) {\n\tcase OPEN_CHANNEL:\n\t\trq = arg;\n\t\tif (rq->protocol == ISDN_P_TE_S0)\n\t\t\terr = sf->isac.open(&sf->isac, rq);\n\t\telse\n\t\t\terr = sf->isar.open(&sf->isar, rq);\n\t\tif (err)\n\t\t\tbreak;\n\t\tif (!try_module_get(THIS_MODULE))\n\t\t\tpr_info(\"%s: cannot get module\\n\", sf->name);\n\t\tbreak;\n\tcase CLOSE_CHANNEL:\n\t\tpr_debug(\"%s: dev(%d) close from %p\\n\", sf->name,\n\t\t\t dch->dev.id, __builtin_return_address(0));\n\t\tmodule_put(THIS_MODULE);\n\t\tbreak;\n\tcase CONTROL_CHANNEL:\n\t\terr = channel_ctrl(sf, arg);\n\t\tbreak;\n\tdefault:\n\t\tpr_debug(\"%s: unknown command %x\\n\", sf->name, cmd);\n\t\treturn -EINVAL;\n\t}\n\treturn err;\n}\n\nstatic int\ninit_card(struct sfax_hw *sf)\n{\n\tint\tret, cnt = 3;\n\tu_long\tflags;\n\n\tret = request_irq(sf->irq, speedfax_irq, IRQF_SHARED, sf->name, sf);\n\tif (ret) {\n\t\tpr_info(\"%s: couldn't get interrupt %d\\n\", sf->name, sf->irq);\n\t\treturn ret;\n\t}\n\twhile (cnt--) {\n\t\tspin_lock_irqsave(&sf->lock, flags);\n\t\tret = sf->isac.init(&sf->isac);\n\t\tif (ret) {\n\t\t\tspin_unlock_irqrestore(&sf->lock, flags);\n\t\t\tpr_info(\"%s: ISAC init failed with %d\\n\",\n\t\t\t\tsf->name, ret);\n\t\t\tbreak;\n\t\t}\n\t\tenable_hwirq(sf);\n\t\t \n\t\tWriteISAC_IND(sf, ISAC_CMDR, 0x41);\n\t\tspin_unlock_irqrestore(&sf->lock, flags);\n\t\tmsleep_interruptible(10);\n\t\tif (debug & DEBUG_HW)\n\t\t\tpr_notice(\"%s: IRQ %d count %d\\n\", sf->name,\n\t\t\t\t  sf->irq, sf->irqcnt);\n\t\tif (!sf->irqcnt) {\n\t\t\tpr_info(\"%s: IRQ(%d) got no requests during init %d\\n\",\n\t\t\t\tsf->name, sf->irq, 3 - cnt);\n\t\t} else\n\t\t\treturn 0;\n\t}\n\tfree_irq(sf->irq, sf);\n\treturn -EIO;\n}\n\n\nstatic int\nsetup_speedfax(struct sfax_hw *sf)\n{\n\tu_long flags;\n\n\tif (!request_region(sf->cfg, 256, sf->name)) {\n\t\tpr_info(\"mISDN: %s config port %x-%x already in use\\n\",\n\t\t\tsf->name, sf->cfg, sf->cfg + 255);\n\t\treturn -EIO;\n\t}\n\toutb(0xff, sf->cfg);\n\toutb(0, sf->cfg);\n\toutb(0xdd, sf->cfg + TIGER_AUX_CTRL);\n\toutb(0, sf->cfg + TIGER_AUX_IRQMASK);\n\n\tsf->isac.type = IPAC_TYPE_ISAC;\n\tsf->p_isac.ale = sf->cfg + SFAX_PCI_ADDR;\n\tsf->p_isac.port = sf->cfg + SFAX_PCI_ISAC;\n\tsf->p_isar.ale = sf->cfg + SFAX_PCI_ADDR;\n\tsf->p_isar.port = sf->cfg + SFAX_PCI_ISAR;\n\tASSIGN_FUNC(IND, ISAC, sf->isac);\n\tASSIGN_FUNC(IND, ISAR, sf->isar);\n\tspin_lock_irqsave(&sf->lock, flags);\n\treset_speedfax(sf);\n\tdisable_hwirq(sf);\n\tspin_unlock_irqrestore(&sf->lock, flags);\n\treturn 0;\n}\n\nstatic void\nrelease_card(struct sfax_hw *card) {\n\tu_long\tflags;\n\n\tspin_lock_irqsave(&card->lock, flags);\n\tdisable_hwirq(card);\n\tspin_unlock_irqrestore(&card->lock, flags);\n\tcard->isac.release(&card->isac);\n\tfree_irq(card->irq, card);\n\tcard->isar.release(&card->isar);\n\tmISDN_unregister_device(&card->isac.dch.dev);\n\trelease_region(card->cfg, 256);\n\tpci_disable_device(card->pdev);\n\tpci_set_drvdata(card->pdev, NULL);\n\twrite_lock_irqsave(&card_lock, flags);\n\tlist_del(&card->list);\n\twrite_unlock_irqrestore(&card_lock, flags);\n\tkfree(card);\n\tsfax_cnt--;\n}\n\nstatic int\nsetup_instance(struct sfax_hw *card)\n{\n\tconst struct firmware *firmware;\n\tint i, err;\n\tu_long flags;\n\n\tsnprintf(card->name, MISDN_MAX_IDLEN - 1, \"Speedfax.%d\", sfax_cnt + 1);\n\twrite_lock_irqsave(&card_lock, flags);\n\tlist_add_tail(&card->list, &Cards);\n\twrite_unlock_irqrestore(&card_lock, flags);\n\t_set_debug(card);\n\tspin_lock_init(&card->lock);\n\tcard->isac.hwlock = &card->lock;\n\tcard->isar.hwlock = &card->lock;\n\tcard->isar.ctrl = (void *)&sfax_ctrl;\n\tcard->isac.name = card->name;\n\tcard->isar.name = card->name;\n\tcard->isar.owner = THIS_MODULE;\n\n\terr = request_firmware(&firmware, \"isdn/ISAR.BIN\", &card->pdev->dev);\n\tif (err < 0) {\n\t\tpr_info(\"%s: firmware request failed %d\\n\",\n\t\t\tcard->name, err);\n\t\tgoto error_fw;\n\t}\n\tif (debug & DEBUG_HW)\n\t\tpr_notice(\"%s: got firmware %zu bytes\\n\",\n\t\t\t  card->name, firmware->size);\n\n\tmISDNisac_init(&card->isac, card);\n\n\tcard->isac.dch.dev.D.ctrl = sfax_dctrl;\n\tcard->isac.dch.dev.Bprotocols =\n\t\tmISDNisar_init(&card->isar, card);\n\tfor (i = 0; i < 2; i++) {\n\t\tset_channelmap(i + 1, card->isac.dch.dev.channelmap);\n\t\tlist_add(&card->isar.ch[i].bch.ch.list,\n\t\t\t &card->isac.dch.dev.bchannels);\n\t}\n\n\terr = setup_speedfax(card);\n\tif (err)\n\t\tgoto error_setup;\n\terr = card->isar.init(&card->isar);\n\tif (err)\n\t\tgoto error;\n\terr = mISDN_register_device(&card->isac.dch.dev,\n\t\t\t\t    &card->pdev->dev, card->name);\n\tif (err)\n\t\tgoto error;\n\terr = init_card(card);\n\tif (err)\n\t\tgoto error_init;\n\terr = card->isar.firmware(&card->isar, firmware->data, firmware->size);\n\tif (!err)  {\n\t\trelease_firmware(firmware);\n\t\tsfax_cnt++;\n\t\tpr_notice(\"SpeedFax %d cards installed\\n\", sfax_cnt);\n\t\treturn 0;\n\t}\n\tdisable_hwirq(card);\n\tfree_irq(card->irq, card);\nerror_init:\n\tmISDN_unregister_device(&card->isac.dch.dev);\nerror:\n\trelease_region(card->cfg, 256);\nerror_setup:\n\tcard->isac.release(&card->isac);\n\tcard->isar.release(&card->isar);\n\trelease_firmware(firmware);\nerror_fw:\n\tpci_disable_device(card->pdev);\n\twrite_lock_irqsave(&card_lock, flags);\n\tlist_del(&card->list);\n\twrite_unlock_irqrestore(&card_lock, flags);\n\tkfree(card);\n\treturn err;\n}\n\nstatic int\nsfaxpci_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tint err = -ENOMEM;\n\tstruct sfax_hw *card = kzalloc(sizeof(struct sfax_hw), GFP_KERNEL);\n\n\tif (!card) {\n\t\tpr_info(\"No memory for Speedfax+ PCI\\n\");\n\t\treturn err;\n\t}\n\tcard->pdev = pdev;\n\terr = pci_enable_device(pdev);\n\tif (err) {\n\t\tkfree(card);\n\t\treturn err;\n\t}\n\n\tpr_notice(\"mISDN: Speedfax found adapter %s at %s\\n\",\n\t\t  (char *)ent->driver_data, pci_name(pdev));\n\n\tcard->cfg = pci_resource_start(pdev, 0);\n\tcard->irq = pdev->irq;\n\tpci_set_drvdata(pdev, card);\n\terr = setup_instance(card);\n\tif (err)\n\t\tpci_set_drvdata(pdev, NULL);\n\treturn err;\n}\n\nstatic void\nsfax_remove_pci(struct pci_dev *pdev)\n{\n\tstruct sfax_hw\t*card = pci_get_drvdata(pdev);\n\n\tif (card)\n\t\trelease_card(card);\n\telse\n\t\tpr_debug(\"%s: drvdata already removed\\n\", __func__);\n}\n\nstatic struct pci_device_id sfaxpci_ids[] = {\n\t{ PCI_VENDOR_ID_TIGERJET, PCI_DEVICE_ID_TIGERJET_100,\n\t  PCI_SUBVENDOR_SPEEDFAX_PYRAMID, PCI_SUB_ID_SEDLBAUER,\n\t  0, 0, (unsigned long) \"Pyramid Speedfax + PCI\"\n\t},\n\t{ PCI_VENDOR_ID_TIGERJET, PCI_DEVICE_ID_TIGERJET_100,\n\t  PCI_SUBVENDOR_SPEEDFAX_PCI, PCI_SUB_ID_SEDLBAUER,\n\t  0, 0, (unsigned long) \"Sedlbauer Speedfax + PCI\"\n\t},\n\t{ }\n};\nMODULE_DEVICE_TABLE(pci, sfaxpci_ids);\n\nstatic struct pci_driver sfaxpci_driver = {\n\t.name = \"speedfax+ pci\",\n\t.probe = sfaxpci_probe,\n\t.remove = sfax_remove_pci,\n\t.id_table = sfaxpci_ids,\n};\n\nstatic int __init\nSpeedfax_init(void)\n{\n\tint err;\n\n\tpr_notice(\"Sedlbauer Speedfax+ Driver Rev. %s\\n\",\n\t\t  SPEEDFAX_REV);\n\terr = pci_register_driver(&sfaxpci_driver);\n\treturn err;\n}\n\nstatic void __exit\nSpeedfax_cleanup(void)\n{\n\tpci_unregister_driver(&sfaxpci_driver);\n}\n\nmodule_init(Speedfax_init);\nmodule_exit(Speedfax_cleanup);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}