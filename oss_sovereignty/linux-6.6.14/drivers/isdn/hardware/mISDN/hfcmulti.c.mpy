{
  "module_name": "hfcmulti.c",
  "hash_id": "8632d2037971f4026b10e7737e716796012948e6ece7ae8474dca9cf91f6726f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/isdn/hardware/mISDN/hfcmulti.c",
  "human_readable_source": "\n \n\n \n\n \n\n#define HFC_MULTI_VERSION\t\"2.03\"\n\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/delay.h>\n#include <linux/mISDNhw.h>\n#include <linux/mISDNdsp.h>\n\n \n\n#include \"hfc_multi.h\"\n#ifdef ECHOPREP\n#include \"gaintab.h\"\n#endif\n\n#define\tMAX_CARDS\t8\n#define\tMAX_PORTS\t(8 * MAX_CARDS)\n#define\tMAX_FRAGS\t(32 * MAX_CARDS)\n\nstatic LIST_HEAD(HFClist);\nstatic DEFINE_SPINLOCK(HFClock);  \n\nstatic void ph_state_change(struct dchannel *);\n\nstatic struct hfc_multi *syncmaster;\nstatic int plxsd_master;  \nstatic DEFINE_SPINLOCK(plx_lock);  \n\n#define\tTYP_E1\t\t1\n#define\tTYP_4S\t\t4\n#define TYP_8S\t\t8\n\nstatic int poll_timer = 6;\t \n \nstatic int nt_t1_count[] = { 3840, 1920, 960, 480, 240, 120, 60, 30  };\n#define\tCLKDEL_TE\t0x0f\t \n#define\tCLKDEL_NT\t0x6c\t \n\n#define\tDIP_4S\t0x1\t\t \n#define\tDIP_8S\t0x2\t\t \n#define\tDIP_E1\t0x3\t\t \n\n \n\nstatic uint\ttype[MAX_CARDS];\nstatic int\tpcm[MAX_CARDS];\nstatic uint\tdmask[MAX_CARDS];\nstatic uint\tbmask[MAX_FRAGS];\nstatic uint\tiomode[MAX_CARDS];\nstatic uint\tport[MAX_PORTS];\nstatic uint\tdebug;\nstatic uint\tpoll;\nstatic int\tclock;\nstatic uint\ttimer;\nstatic uint\tclockdelay_te = CLKDEL_TE;\nstatic uint\tclockdelay_nt = CLKDEL_NT;\n#define HWID_NONE\t0\n#define HWID_MINIP4\t1\n#define HWID_MINIP8\t2\n#define HWID_MINIP16\t3\nstatic uint\thwid = HWID_NONE;\n\nstatic int\tHFC_cnt, E1_cnt, bmask_cnt, Port_cnt, PCM_cnt = 99;\n\nMODULE_AUTHOR(\"Andreas Eversberg\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(HFC_MULTI_VERSION);\nmodule_param(debug, uint, S_IRUGO | S_IWUSR);\nmodule_param(poll, uint, S_IRUGO | S_IWUSR);\nmodule_param(clock, int, S_IRUGO | S_IWUSR);\nmodule_param(timer, uint, S_IRUGO | S_IWUSR);\nmodule_param(clockdelay_te, uint, S_IRUGO | S_IWUSR);\nmodule_param(clockdelay_nt, uint, S_IRUGO | S_IWUSR);\nmodule_param_array(type, uint, NULL, S_IRUGO | S_IWUSR);\nmodule_param_array(pcm, int, NULL, S_IRUGO | S_IWUSR);\nmodule_param_array(dmask, uint, NULL, S_IRUGO | S_IWUSR);\nmodule_param_array(bmask, uint, NULL, S_IRUGO | S_IWUSR);\nmodule_param_array(iomode, uint, NULL, S_IRUGO | S_IWUSR);\nmodule_param_array(port, uint, NULL, S_IRUGO | S_IWUSR);\nmodule_param(hwid, uint, S_IRUGO | S_IWUSR);  \n\n#ifdef HFC_REGISTER_DEBUG\n#define HFC_outb(hc, reg, val)\t\t\t\t\t\\\n\t(hc->HFC_outb(hc, reg, val, __func__, __LINE__))\n#define HFC_outb_nodebug(hc, reg, val)\t\t\t\t\t\\\n\t(hc->HFC_outb_nodebug(hc, reg, val, __func__, __LINE__))\n#define HFC_inb(hc, reg)\t\t\t\t\\\n\t(hc->HFC_inb(hc, reg, __func__, __LINE__))\n#define HFC_inb_nodebug(hc, reg)\t\t\t\t\\\n\t(hc->HFC_inb_nodebug(hc, reg, __func__, __LINE__))\n#define HFC_inw(hc, reg)\t\t\t\t\\\n\t(hc->HFC_inw(hc, reg, __func__, __LINE__))\n#define HFC_inw_nodebug(hc, reg)\t\t\t\t\\\n\t(hc->HFC_inw_nodebug(hc, reg, __func__, __LINE__))\n#define HFC_wait(hc)\t\t\t\t\\\n\t(hc->HFC_wait(hc, __func__, __LINE__))\n#define HFC_wait_nodebug(hc)\t\t\t\t\\\n\t(hc->HFC_wait_nodebug(hc, __func__, __LINE__))\n#else\n#define HFC_outb(hc, reg, val)\t\t(hc->HFC_outb(hc, reg, val))\n#define HFC_outb_nodebug(hc, reg, val)\t(hc->HFC_outb_nodebug(hc, reg, val))\n#define HFC_inb(hc, reg)\t\t(hc->HFC_inb(hc, reg))\n#define HFC_inb_nodebug(hc, reg)\t(hc->HFC_inb_nodebug(hc, reg))\n#define HFC_inw(hc, reg)\t\t(hc->HFC_inw(hc, reg))\n#define HFC_inw_nodebug(hc, reg)\t(hc->HFC_inw_nodebug(hc, reg))\n#define HFC_wait(hc)\t\t\t(hc->HFC_wait(hc))\n#define HFC_wait_nodebug(hc)\t\t(hc->HFC_wait_nodebug(hc))\n#endif\n\n#ifdef CONFIG_MISDN_HFCMULTI_8xx\n#include \"hfc_multi_8xx.h\"\n#endif\n\n \nstatic void\n#ifdef HFC_REGISTER_DEBUG\nHFC_outb_pcimem(struct hfc_multi *hc, u_char reg, u_char val,\n\t\tconst char *function, int line)\n#else\n\tHFC_outb_pcimem(struct hfc_multi *hc, u_char reg, u_char val)\n#endif\n{\n\twriteb(val, hc->pci_membase + reg);\n}\nstatic u_char\n#ifdef HFC_REGISTER_DEBUG\nHFC_inb_pcimem(struct hfc_multi *hc, u_char reg, const char *function, int line)\n#else\n\tHFC_inb_pcimem(struct hfc_multi *hc, u_char reg)\n#endif\n{\n\treturn readb(hc->pci_membase + reg);\n}\nstatic u_short\n#ifdef HFC_REGISTER_DEBUG\nHFC_inw_pcimem(struct hfc_multi *hc, u_char reg, const char *function, int line)\n#else\n\tHFC_inw_pcimem(struct hfc_multi *hc, u_char reg)\n#endif\n{\n\treturn readw(hc->pci_membase + reg);\n}\nstatic void\n#ifdef HFC_REGISTER_DEBUG\nHFC_wait_pcimem(struct hfc_multi *hc, const char *function, int line)\n#else\n\tHFC_wait_pcimem(struct hfc_multi *hc)\n#endif\n{\n\twhile (readb(hc->pci_membase + R_STATUS) & V_BUSY)\n\t\tcpu_relax();\n}\n\n \nstatic void\n#ifdef HFC_REGISTER_DEBUG\nHFC_outb_regio(struct hfc_multi *hc, u_char reg, u_char val,\n\t       const char *function, int line)\n#else\n\tHFC_outb_regio(struct hfc_multi *hc, u_char reg, u_char val)\n#endif\n{\n\toutb(reg, hc->pci_iobase + 4);\n\toutb(val, hc->pci_iobase);\n}\nstatic u_char\n#ifdef HFC_REGISTER_DEBUG\nHFC_inb_regio(struct hfc_multi *hc, u_char reg, const char *function, int line)\n#else\n\tHFC_inb_regio(struct hfc_multi *hc, u_char reg)\n#endif\n{\n\toutb(reg, hc->pci_iobase + 4);\n\treturn inb(hc->pci_iobase);\n}\nstatic u_short\n#ifdef HFC_REGISTER_DEBUG\nHFC_inw_regio(struct hfc_multi *hc, u_char reg, const char *function, int line)\n#else\n\tHFC_inw_regio(struct hfc_multi *hc, u_char reg)\n#endif\n{\n\toutb(reg, hc->pci_iobase + 4);\n\treturn inw(hc->pci_iobase);\n}\nstatic void\n#ifdef HFC_REGISTER_DEBUG\nHFC_wait_regio(struct hfc_multi *hc, const char *function, int line)\n#else\n\tHFC_wait_regio(struct hfc_multi *hc)\n#endif\n{\n\toutb(R_STATUS, hc->pci_iobase + 4);\n\twhile (inb(hc->pci_iobase) & V_BUSY)\n\t\tcpu_relax();\n}\n\n#ifdef HFC_REGISTER_DEBUG\nstatic void\nHFC_outb_debug(struct hfc_multi *hc, u_char reg, u_char val,\n\t       const char *function, int line)\n{\n\tchar regname[256] = \"\", bits[9] = \"xxxxxxxx\";\n\tint i;\n\n\ti = -1;\n\twhile (hfc_register_names[++i].name) {\n\t\tif (hfc_register_names[i].reg == reg)\n\t\t\tstrcat(regname, hfc_register_names[i].name);\n\t}\n\tif (regname[0] == '\\0')\n\t\tstrcpy(regname, \"register\");\n\n\tbits[7] = '0' + (!!(val & 1));\n\tbits[6] = '0' + (!!(val & 2));\n\tbits[5] = '0' + (!!(val & 4));\n\tbits[4] = '0' + (!!(val & 8));\n\tbits[3] = '0' + (!!(val & 16));\n\tbits[2] = '0' + (!!(val & 32));\n\tbits[1] = '0' + (!!(val & 64));\n\tbits[0] = '0' + (!!(val & 128));\n\tprintk(KERN_DEBUG\n\t       \"HFC_outb(chip %d, %02x=%s, 0x%02x=%s); in %s() line %d\\n\",\n\t       hc->id, reg, regname, val, bits, function, line);\n\tHFC_outb_nodebug(hc, reg, val);\n}\nstatic u_char\nHFC_inb_debug(struct hfc_multi *hc, u_char reg, const char *function, int line)\n{\n\tchar regname[256] = \"\", bits[9] = \"xxxxxxxx\";\n\tu_char val = HFC_inb_nodebug(hc, reg);\n\tint i;\n\n\ti = 0;\n\twhile (hfc_register_names[i++].name)\n\t\t;\n\twhile (hfc_register_names[++i].name) {\n\t\tif (hfc_register_names[i].reg == reg)\n\t\t\tstrcat(regname, hfc_register_names[i].name);\n\t}\n\tif (regname[0] == '\\0')\n\t\tstrcpy(regname, \"register\");\n\n\tbits[7] = '0' + (!!(val & 1));\n\tbits[6] = '0' + (!!(val & 2));\n\tbits[5] = '0' + (!!(val & 4));\n\tbits[4] = '0' + (!!(val & 8));\n\tbits[3] = '0' + (!!(val & 16));\n\tbits[2] = '0' + (!!(val & 32));\n\tbits[1] = '0' + (!!(val & 64));\n\tbits[0] = '0' + (!!(val & 128));\n\tprintk(KERN_DEBUG\n\t       \"HFC_inb(chip %d, %02x=%s) = 0x%02x=%s; in %s() line %d\\n\",\n\t       hc->id, reg, regname, val, bits, function, line);\n\treturn val;\n}\nstatic u_short\nHFC_inw_debug(struct hfc_multi *hc, u_char reg, const char *function, int line)\n{\n\tchar regname[256] = \"\";\n\tu_short val = HFC_inw_nodebug(hc, reg);\n\tint i;\n\n\ti = 0;\n\twhile (hfc_register_names[i++].name)\n\t\t;\n\twhile (hfc_register_names[++i].name) {\n\t\tif (hfc_register_names[i].reg == reg)\n\t\t\tstrcat(regname, hfc_register_names[i].name);\n\t}\n\tif (regname[0] == '\\0')\n\t\tstrcpy(regname, \"register\");\n\n\tprintk(KERN_DEBUG\n\t       \"HFC_inw(chip %d, %02x=%s) = 0x%04x; in %s() line %d\\n\",\n\t       hc->id, reg, regname, val, function, line);\n\treturn val;\n}\nstatic void\nHFC_wait_debug(struct hfc_multi *hc, const char *function, int line)\n{\n\tprintk(KERN_DEBUG \"HFC_wait(chip %d); in %s() line %d\\n\",\n\t       hc->id, function, line);\n\tHFC_wait_nodebug(hc);\n}\n#endif\n\n \nstatic void\nwrite_fifo_regio(struct hfc_multi *hc, u_char *data, int len)\n{\n\toutb(A_FIFO_DATA0, (hc->pci_iobase) + 4);\n\twhile (len >> 2) {\n\t\toutl(cpu_to_le32(*(u32 *)data), hc->pci_iobase);\n\t\tdata += 4;\n\t\tlen -= 4;\n\t}\n\twhile (len >> 1) {\n\t\toutw(cpu_to_le16(*(u16 *)data), hc->pci_iobase);\n\t\tdata += 2;\n\t\tlen -= 2;\n\t}\n\twhile (len) {\n\t\toutb(*data, hc->pci_iobase);\n\t\tdata++;\n\t\tlen--;\n\t}\n}\n \nstatic void\nwrite_fifo_pcimem(struct hfc_multi *hc, u_char *data, int len)\n{\n\twhile (len >> 2) {\n\t\twritel(cpu_to_le32(*(u32 *)data),\n\t\t       hc->pci_membase + A_FIFO_DATA0);\n\t\tdata += 4;\n\t\tlen -= 4;\n\t}\n\twhile (len >> 1) {\n\t\twritew(cpu_to_le16(*(u16 *)data),\n\t\t       hc->pci_membase + A_FIFO_DATA0);\n\t\tdata += 2;\n\t\tlen -= 2;\n\t}\n\twhile (len) {\n\t\twriteb(*data, hc->pci_membase + A_FIFO_DATA0);\n\t\tdata++;\n\t\tlen--;\n\t}\n}\n\n \nstatic void\nread_fifo_regio(struct hfc_multi *hc, u_char *data, int len)\n{\n\toutb(A_FIFO_DATA0, (hc->pci_iobase) + 4);\n\twhile (len >> 2) {\n\t\t*(u32 *)data = le32_to_cpu(inl(hc->pci_iobase));\n\t\tdata += 4;\n\t\tlen -= 4;\n\t}\n\twhile (len >> 1) {\n\t\t*(u16 *)data = le16_to_cpu(inw(hc->pci_iobase));\n\t\tdata += 2;\n\t\tlen -= 2;\n\t}\n\twhile (len) {\n\t\t*data = inb(hc->pci_iobase);\n\t\tdata++;\n\t\tlen--;\n\t}\n}\n\n \nstatic void\nread_fifo_pcimem(struct hfc_multi *hc, u_char *data, int len)\n{\n\twhile (len >> 2) {\n\t\t*(u32 *)data =\n\t\t\tle32_to_cpu(readl(hc->pci_membase + A_FIFO_DATA0));\n\t\tdata += 4;\n\t\tlen -= 4;\n\t}\n\twhile (len >> 1) {\n\t\t*(u16 *)data =\n\t\t\tle16_to_cpu(readw(hc->pci_membase + A_FIFO_DATA0));\n\t\tdata += 2;\n\t\tlen -= 2;\n\t}\n\twhile (len) {\n\t\t*data = readb(hc->pci_membase + A_FIFO_DATA0);\n\t\tdata++;\n\t\tlen--;\n\t}\n}\n\nstatic void\nenable_hwirq(struct hfc_multi *hc)\n{\n\thc->hw.r_irq_ctrl |= V_GLOB_IRQ_EN;\n\tHFC_outb(hc, R_IRQ_CTRL, hc->hw.r_irq_ctrl);\n}\n\nstatic void\ndisable_hwirq(struct hfc_multi *hc)\n{\n\thc->hw.r_irq_ctrl &= ~((u_char)V_GLOB_IRQ_EN);\n\tHFC_outb(hc, R_IRQ_CTRL, hc->hw.r_irq_ctrl);\n}\n\n#define\tNUM_EC 2\n#define\tMAX_TDM_CHAN 32\n\n\nstatic inline void\nenablepcibridge(struct hfc_multi *c)\n{\n\tHFC_outb(c, R_BRG_PCM_CFG, (0x0 << 6) | 0x3);  \n}\n\nstatic inline void\ndisablepcibridge(struct hfc_multi *c)\n{\n\tHFC_outb(c, R_BRG_PCM_CFG, (0x0 << 6) | 0x2);  \n}\n\nstatic inline unsigned char\nreadpcibridge(struct hfc_multi *hc, unsigned char address)\n{\n\tunsigned short cipv;\n\tunsigned char data;\n\n\tif (!hc->pci_iobase)\n\t\treturn 0;\n\n\t \n\tHFC_outb(hc, R_CTRL, 0x4);  \n\n\tif (address == 0)\n\t\tcipv = 0x4000;\n\telse\n\t\tcipv = 0x5800;\n\n\t \n\t \n\toutw(cipv, hc->pci_iobase + 4);\n\tdata = inb(hc->pci_iobase);\n\n\t \n\tHFC_outb(hc, R_CTRL, 0x0);  \n\n\treturn data;\n}\n\nstatic inline void\nwritepcibridge(struct hfc_multi *hc, unsigned char address, unsigned char data)\n{\n\tunsigned short cipv;\n\tunsigned int datav;\n\n\tif (!hc->pci_iobase)\n\t\treturn;\n\n\tif (address == 0)\n\t\tcipv = 0x4000;\n\telse\n\t\tcipv = 0x5800;\n\n\t \n\toutw(cipv, hc->pci_iobase + 4);\n\t \n\tdatav = data | ((__u32) data << 8) | ((__u32) data << 16) |\n\t\t((__u32) data << 24);\n\n\t \n\toutl(datav, hc->pci_iobase);\n}\n\nstatic inline void\ncpld_set_reg(struct hfc_multi *hc, unsigned char reg)\n{\n\t \n\tHFC_outb(hc, R_GPIO_OUT1, reg);\n}\n\nstatic inline void\ncpld_write_reg(struct hfc_multi *hc, unsigned char reg, unsigned char val)\n{\n\tcpld_set_reg(hc, reg);\n\n\tenablepcibridge(hc);\n\twritepcibridge(hc, 1, val);\n\tdisablepcibridge(hc);\n\n\treturn;\n}\n\nstatic inline void\nvpm_write_address(struct hfc_multi *hc, unsigned short addr)\n{\n\tcpld_write_reg(hc, 0, 0xff & addr);\n\tcpld_write_reg(hc, 1, 0x01 & (addr >> 8));\n}\n\nstatic inline unsigned char\nvpm_in(struct hfc_multi *c, int which, unsigned short addr)\n{\n\tunsigned char res;\n\n\tvpm_write_address(c, addr);\n\n\tif (!which)\n\t\tcpld_set_reg(c, 2);\n\telse\n\t\tcpld_set_reg(c, 3);\n\n\tenablepcibridge(c);\n\tres = readpcibridge(c, 1);\n\tdisablepcibridge(c);\n\n\tcpld_set_reg(c, 0);\n\n\treturn res;\n}\n\nstatic inline void\nvpm_out(struct hfc_multi *c, int which, unsigned short addr,\n\tunsigned char data)\n{\n\tvpm_write_address(c, addr);\n\n\tenablepcibridge(c);\n\n\tif (!which)\n\t\tcpld_set_reg(c, 2);\n\telse\n\t\tcpld_set_reg(c, 3);\n\n\twritepcibridge(c, 1, data);\n\n\tcpld_set_reg(c, 0);\n\n\tdisablepcibridge(c);\n\n\t{\n\t\tunsigned char regin;\n\t\tregin = vpm_in(c, which, addr);\n\t\tif (regin != data)\n\t\t\tprintk(KERN_DEBUG \"Wrote 0x%x to register 0x%x but got back \"\n\t\t\t       \"0x%x\\n\", data, addr, regin);\n\t}\n\n}\n\n\nstatic void\nvpm_init(struct hfc_multi *wc)\n{\n\tunsigned char reg;\n\tunsigned int mask;\n\tunsigned int i, x, y;\n\tunsigned int ver;\n\n\tfor (x = 0; x < NUM_EC; x++) {\n\t\t \n\t\tif (!x) {\n\t\t\tver = vpm_in(wc, x, 0x1a0);\n\t\t\tprintk(KERN_DEBUG \"VPM: Chip %d: ver %02x\\n\", x, ver);\n\t\t}\n\n\t\tfor (y = 0; y < 4; y++) {\n\t\t\tvpm_out(wc, x, 0x1a8 + y, 0x00);  \n\t\t\tvpm_out(wc, x, 0x1ac + y, 0x00);  \n\t\t\tvpm_out(wc, x, 0x1b0 + y, 0x00);  \n\t\t}\n\n\t\t \n\t\treg = vpm_in(wc, x, 0x1a3);  \n\t\tvpm_out(wc, x, 0x1a3, reg & ~2);\n\n\t\t \n\t\tvpm_out(wc, x, 0x022, 1);\n\t\tvpm_out(wc, x, 0x023, 0xff);\n\n\t\t \n\t\tvpm_out(wc, x, 0x02f, 0x00);\n\t\tmask = 0x02020202 << (x * 4);\n\n\t\t \n\t\tfor (i = 0; i < 4; i++)\n\t\t\tvpm_out(wc, x, 0x33 - i, (mask >> (i << 3)) & 0xff);\n\n\t\t \n\t\tprintk(KERN_DEBUG \"VPM: A-law mode\\n\");\n\t\treg = 0x00 | 0x10 | 0x01;\n\t\tvpm_out(wc, x, 0x20, reg);\n\t\tprintk(KERN_DEBUG \"VPM reg 0x20 is %x\\n\", reg);\n\t\t \n\n\t\tvpm_out(wc, x, 0x24, 0x02);\n\t\treg = vpm_in(wc, x, 0x24);\n\t\tprintk(KERN_DEBUG \"NLP Thresh is set to %d (0x%x)\\n\", reg, reg);\n\n\t\t \n\t\tfor (i = 0; i < MAX_TDM_CHAN; i++) {\n\t\t\tif (mask & (0x00000001 << i))\n\t\t\t\tvpm_out(wc, x, i, 0x00);\n\t\t}\n\n\t\t \n\n\t\tudelay(2000);\n\t\tudelay(2000);\n\t\tudelay(2000);\n\t\tudelay(2000);\n\t\tudelay(2000);\n\n\t\t \n\t\tfor (i = 0; i < MAX_TDM_CHAN; i++) {\n\t\t\tif (mask & (0x00000001 << i))\n\t\t\t\tvpm_out(wc, x, i, 0x01);\n\t\t}\n\n\t\t \n\t\tfor (i = 0; i < MAX_TDM_CHAN; i++) {\n\t\t\tif (mask & (0x00000001 << i))\n\t\t\t\tvpm_out(wc, x, 0x78 + i, 0x01);\n\t\t}\n\n\t}\n}\n\n#ifdef UNUSED\nstatic void\nvpm_check(struct hfc_multi *hctmp)\n{\n\tunsigned char gpi2;\n\n\tgpi2 = HFC_inb(hctmp, R_GPI_IN2);\n\n\tif ((gpi2 & 0x3) != 0x3)\n\t\tprintk(KERN_DEBUG \"Got interrupt 0x%x from VPM!\\n\", gpi2);\n}\n#endif  \n\n\n \n\nstatic void\nvpm_echocan_on(struct hfc_multi *hc, int ch, int taps)\n{\n\tunsigned int timeslot;\n\tunsigned int unit;\n\tstruct bchannel *bch = hc->chan[ch].bch;\n#ifdef TXADJ\n\tint txadj = -4;\n\tstruct sk_buff *skb;\n#endif\n\tif (hc->chan[ch].protocol != ISDN_P_B_RAW)\n\t\treturn;\n\n\tif (!bch)\n\t\treturn;\n\n#ifdef TXADJ\n\tskb = _alloc_mISDN_skb(PH_CONTROL_IND, HFC_VOL_CHANGE_TX,\n\t\t\t       sizeof(int), &txadj, GFP_ATOMIC);\n\tif (skb)\n\t\trecv_Bchannel_skb(bch, skb);\n#endif\n\n\ttimeslot = ((ch / 4) * 8) + ((ch % 4) * 4) + 1;\n\tunit = ch % 4;\n\n\tprintk(KERN_NOTICE \"vpm_echocan_on called taps [%d] on timeslot %d\\n\",\n\t       taps, timeslot);\n\n\tvpm_out(hc, unit, timeslot, 0x7e);\n}\n\nstatic void\nvpm_echocan_off(struct hfc_multi *hc, int ch)\n{\n\tunsigned int timeslot;\n\tunsigned int unit;\n\tstruct bchannel *bch = hc->chan[ch].bch;\n#ifdef TXADJ\n\tint txadj = 0;\n\tstruct sk_buff *skb;\n#endif\n\n\tif (hc->chan[ch].protocol != ISDN_P_B_RAW)\n\t\treturn;\n\n\tif (!bch)\n\t\treturn;\n\n#ifdef TXADJ\n\tskb = _alloc_mISDN_skb(PH_CONTROL_IND, HFC_VOL_CHANGE_TX,\n\t\t\t       sizeof(int), &txadj, GFP_ATOMIC);\n\tif (skb)\n\t\trecv_Bchannel_skb(bch, skb);\n#endif\n\n\ttimeslot = ((ch / 4) * 8) + ((ch % 4) * 4) + 1;\n\tunit = ch % 4;\n\n\tprintk(KERN_NOTICE \"vpm_echocan_off called on timeslot %d\\n\",\n\t       timeslot);\n\t \n\tvpm_out(hc, unit, timeslot, 0x01);\n}\n\n\n \nstatic inline void\nhfcmulti_resync(struct hfc_multi *locked, struct hfc_multi *newmaster, int rm)\n{\n\tstruct hfc_multi *hc, *next, *pcmmaster = NULL;\n\tvoid __iomem *plx_acc_32;\n\tu_int pv;\n\tu_long flags;\n\n\tspin_lock_irqsave(&HFClock, flags);\n\tspin_lock(&plx_lock);  \n\n\tif (debug & DEBUG_HFCMULTI_PLXSD)\n\t\tprintk(KERN_DEBUG \"%s: RESYNC(syncmaster=0x%p)\\n\",\n\t\t       __func__, syncmaster);\n\n\t \n\tif (newmaster) {\n\t\tif (debug & DEBUG_HFCMULTI_PLXSD)\n\t\t\tprintk(KERN_DEBUG \"using provided controller\\n\");\n\t} else {\n\t\tlist_for_each_entry_safe(hc, next, &HFClist, list) {\n\t\t\tif (test_bit(HFC_CHIP_PLXSD, &hc->chip)) {\n\t\t\t\tif (hc->syncronized) {\n\t\t\t\t\tnewmaster = hc;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tlist_for_each_entry_safe(hc, next, &HFClist, list) {\n\t\tif (test_bit(HFC_CHIP_PLXSD, &hc->chip)) {\n\t\t\tplx_acc_32 = hc->plx_membase + PLX_GPIOC;\n\t\t\tpv = readl(plx_acc_32);\n\t\t\tpv &= ~PLX_SYNC_O_EN;\n\t\t\twritel(pv, plx_acc_32);\n\t\t\tif (test_bit(HFC_CHIP_PCM_MASTER, &hc->chip)) {\n\t\t\t\tpcmmaster = hc;\n\t\t\t\tif (hc->ctype == HFC_TYPE_E1) {\n\t\t\t\t\tif (debug & DEBUG_HFCMULTI_PLXSD)\n\t\t\t\t\t\tprintk(KERN_DEBUG\n\t\t\t\t\t\t       \"Schedule SYNC_I\\n\");\n\t\t\t\t\thc->e1_resync |= 1;  \n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (newmaster) {\n\t\thc = newmaster;\n\t\tif (debug & DEBUG_HFCMULTI_PLXSD)\n\t\t\tprintk(KERN_DEBUG \"id=%d (0x%p) = syncronized with \"\n\t\t\t       \"interface.\\n\", hc->id, hc);\n\t\t \n\t\tplx_acc_32 = hc->plx_membase + PLX_GPIOC;\n\t\tpv = readl(plx_acc_32);\n\t\tpv |= PLX_SYNC_O_EN;\n\t\twritel(pv, plx_acc_32);\n\t\t \n\t\tif (hc->ctype == HFC_TYPE_E1\n\t\t    && !test_bit(HFC_CHIP_RX_SYNC, &hc->chip)) {\n\t\t\tif (debug & DEBUG_HFCMULTI_PLXSD)\n\t\t\t\tprintk(KERN_DEBUG \"Schedule jatt PLL\\n\");\n\t\t\thc->e1_resync |= 2;  \n\t\t}\n\t} else {\n\t\tif (pcmmaster) {\n\t\t\thc = pcmmaster;\n\t\t\tif (debug & DEBUG_HFCMULTI_PLXSD)\n\t\t\t\tprintk(KERN_DEBUG\n\t\t\t\t       \"id=%d (0x%p) = PCM master syncronized \"\n\t\t\t\t       \"with QUARTZ\\n\", hc->id, hc);\n\t\t\tif (hc->ctype == HFC_TYPE_E1) {\n\t\t\t\t \n\t\t\t\tif (debug & DEBUG_HFCMULTI_PLXSD)\n\t\t\t\t\tprintk(KERN_DEBUG\n\t\t\t\t\t       \"Schedule QUARTZ for HFC-E1\\n\");\n\t\t\t\thc->e1_resync |= 4;  \n\t\t\t} else {\n\t\t\t\tif (debug & DEBUG_HFCMULTI_PLXSD)\n\t\t\t\t\tprintk(KERN_DEBUG\n\t\t\t\t\t       \"QUARTZ is automatically \"\n\t\t\t\t\t       \"enabled by HFC-%dS\\n\", hc->ctype);\n\t\t\t}\n\t\t\tplx_acc_32 = hc->plx_membase + PLX_GPIOC;\n\t\t\tpv = readl(plx_acc_32);\n\t\t\tpv |= PLX_SYNC_O_EN;\n\t\t\twritel(pv, plx_acc_32);\n\t\t} else\n\t\t\tif (!rm)\n\t\t\t\tprintk(KERN_ERR \"%s no pcm master, this MUST \"\n\t\t\t\t       \"not happen!\\n\", __func__);\n\t}\n\tsyncmaster = newmaster;\n\n\tspin_unlock(&plx_lock);\n\tspin_unlock_irqrestore(&HFClock, flags);\n}\n\n \nstatic inline void\nplxsd_checksync(struct hfc_multi *hc, int rm)\n{\n\tif (hc->syncronized) {\n\t\tif (syncmaster == NULL) {\n\t\t\tif (debug & DEBUG_HFCMULTI_PLXSD)\n\t\t\t\tprintk(KERN_DEBUG \"%s: GOT sync on card %d\"\n\t\t\t\t       \" (id=%d)\\n\", __func__, hc->id + 1,\n\t\t\t\t       hc->id);\n\t\t\thfcmulti_resync(hc, hc, rm);\n\t\t}\n\t} else {\n\t\tif (syncmaster == hc) {\n\t\t\tif (debug & DEBUG_HFCMULTI_PLXSD)\n\t\t\t\tprintk(KERN_DEBUG \"%s: LOST sync on card %d\"\n\t\t\t\t       \" (id=%d)\\n\", __func__, hc->id + 1,\n\t\t\t\t       hc->id);\n\t\t\thfcmulti_resync(hc, NULL, rm);\n\t\t}\n\t}\n}\n\n\n \nstatic void\nrelease_io_hfcmulti(struct hfc_multi *hc)\n{\n\tvoid __iomem *plx_acc_32;\n\tu_int\tpv;\n\tu_long\tplx_flags;\n\n\tif (debug & DEBUG_HFCMULTI_INIT)\n\t\tprintk(KERN_DEBUG \"%s: entered\\n\", __func__);\n\n\t \n\thc->hw.r_cirm |= V_SRES;\n\tHFC_outb(hc, R_CIRM, hc->hw.r_cirm);\n\tudelay(1000);\n\thc->hw.r_cirm &= ~V_SRES;\n\tHFC_outb(hc, R_CIRM, hc->hw.r_cirm);\n\tudelay(1000);  \n\n\t \n\tif (test_bit(HFC_CHIP_PLXSD, &hc->chip) && hc->plx_membase) {\n\t\tif (debug & DEBUG_HFCMULTI_PLXSD)\n\t\t\tprintk(KERN_DEBUG \"%s: release PLXSD card %d\\n\",\n\t\t\t       __func__, hc->id + 1);\n\t\tspin_lock_irqsave(&plx_lock, plx_flags);\n\t\tplx_acc_32 = hc->plx_membase + PLX_GPIOC;\n\t\twritel(PLX_GPIOC_INIT, plx_acc_32);\n\t\tpv = readl(plx_acc_32);\n\t\t \n\t\tpv &= ~PLX_TERM_ON;\n\t\t \n\t\tpv |= PLX_SLAVE_EN_N;\n\t\tpv &= ~PLX_MASTER_EN;\n\t\tpv &= ~PLX_SYNC_O_EN;\n\t\t \n\t\tpv &= ~PLX_DSP_RES_N;\n\t\twritel(pv, plx_acc_32);\n\t\tif (debug & DEBUG_HFCMULTI_INIT)\n\t\t\tprintk(KERN_DEBUG \"%s: PCM off: PLX_GPIO=%x\\n\",\n\t\t\t       __func__, pv);\n\t\tspin_unlock_irqrestore(&plx_lock, plx_flags);\n\t}\n\n\t \n\ttest_and_clear_bit(HFC_CHIP_PLXSD, &hc->chip);  \n\tif (hc->pci_dev)\n\t\tpci_write_config_word(hc->pci_dev, PCI_COMMAND, 0);\n\tif (hc->pci_membase)\n\t\tiounmap(hc->pci_membase);\n\tif (hc->plx_membase)\n\t\tiounmap(hc->plx_membase);\n\tif (hc->pci_iobase)\n\t\trelease_region(hc->pci_iobase, 8);\n\tif (hc->xhfc_membase)\n\t\tiounmap((void *)hc->xhfc_membase);\n\n\tif (hc->pci_dev) {\n\t\tpci_disable_device(hc->pci_dev);\n\t\tpci_set_drvdata(hc->pci_dev, NULL);\n\t}\n\tif (debug & DEBUG_HFCMULTI_INIT)\n\t\tprintk(KERN_DEBUG \"%s: done\\n\", __func__);\n}\n\n \n\nstatic int\ninit_chip(struct hfc_multi *hc)\n{\n\tu_long\t\t\tflags, val, val2 = 0, rev;\n\tint\t\t\ti, err = 0;\n\tu_char\t\t\tr_conf_en, rval;\n\tvoid __iomem\t\t*plx_acc_32;\n\tu_int\t\t\tpv;\n\tu_long\t\t\tplx_flags, hfc_flags;\n\tint\t\t\tplx_count;\n\tstruct hfc_multi\t*pos, *next, *plx_last_hc;\n\n\tspin_lock_irqsave(&hc->lock, flags);\n\t \n\tmemset(&hc->hw, 0, sizeof(struct hfcm_hw));\n\n\t \n\tif (debug & DEBUG_HFCMULTI_INIT)\n\t\tprintk(KERN_DEBUG \"%s: entered\\n\", __func__);\n\tval = HFC_inb(hc, R_CHIP_ID);\n\tif ((val >> 4) != 0x8 && (val >> 4) != 0xc && (val >> 4) != 0xe &&\n\t    (val >> 1) != 0x31) {\n\t\tprintk(KERN_INFO \"HFC_multi: unknown CHIP_ID:%x\\n\", (u_int)val);\n\t\terr = -EIO;\n\t\tgoto out;\n\t}\n\trev = HFC_inb(hc, R_CHIP_RV);\n\tprintk(KERN_INFO\n\t       \"HFC_multi: detected HFC with chip ID=0x%lx revision=%ld%s\\n\",\n\t       val, rev, (rev == 0 && (hc->ctype != HFC_TYPE_XHFC)) ?\n\t       \" (old FIFO handling)\" : \"\");\n\tif (hc->ctype != HFC_TYPE_XHFC && rev == 0) {\n\t\ttest_and_set_bit(HFC_CHIP_REVISION0, &hc->chip);\n\t\tprintk(KERN_WARNING\n\t\t       \"HFC_multi: NOTE: Your chip is revision 0, \"\n\t\t       \"ask Cologne Chip for update. Newer chips \"\n\t\t       \"have a better FIFO handling. Old chips \"\n\t\t       \"still work but may have slightly lower \"\n\t\t       \"HDLC transmit performance.\\n\");\n\t}\n\tif (rev > 1) {\n\t\tprintk(KERN_WARNING \"HFC_multi: WARNING: This driver doesn't \"\n\t\t       \"consider chip revision = %ld. The chip / \"\n\t\t       \"bridge may not work.\\n\", rev);\n\t}\n\n\t \n\thc->Flen = 0x10;\n\thc->Zmin = 0x80;\n\thc->Zlen = 384;\n\thc->DTMFbase = 0x1000;\n\tif (test_bit(HFC_CHIP_EXRAM_128, &hc->chip)) {\n\t\tif (debug & DEBUG_HFCMULTI_INIT)\n\t\t\tprintk(KERN_DEBUG \"%s: changing to 128K external RAM\\n\",\n\t\t\t       __func__);\n\t\thc->hw.r_ctrl |= V_EXT_RAM;\n\t\thc->hw.r_ram_sz = 1;\n\t\thc->Flen = 0x20;\n\t\thc->Zmin = 0xc0;\n\t\thc->Zlen = 1856;\n\t\thc->DTMFbase = 0x2000;\n\t}\n\tif (test_bit(HFC_CHIP_EXRAM_512, &hc->chip)) {\n\t\tif (debug & DEBUG_HFCMULTI_INIT)\n\t\t\tprintk(KERN_DEBUG \"%s: changing to 512K external RAM\\n\",\n\t\t\t       __func__);\n\t\thc->hw.r_ctrl |= V_EXT_RAM;\n\t\thc->hw.r_ram_sz = 2;\n\t\thc->Flen = 0x20;\n\t\thc->Zmin = 0xc0;\n\t\thc->Zlen = 8000;\n\t\thc->DTMFbase = 0x2000;\n\t}\n\tif (hc->ctype == HFC_TYPE_XHFC) {\n\t\thc->Flen = 0x8;\n\t\thc->Zmin = 0x0;\n\t\thc->Zlen = 64;\n\t\thc->DTMFbase = 0x0;\n\t}\n\thc->max_trans = poll << 1;\n\tif (hc->max_trans > hc->Zlen)\n\t\thc->max_trans = hc->Zlen;\n\n\t \n\tif (test_bit(HFC_CHIP_PLXSD, &hc->chip)) {\n\t\tif (debug & DEBUG_HFCMULTI_PLXSD)\n\t\t\tprintk(KERN_DEBUG \"%s: initializing PLXSD card %d\\n\",\n\t\t\t       __func__, hc->id + 1);\n\t\tspin_lock_irqsave(&plx_lock, plx_flags);\n\t\tplx_acc_32 = hc->plx_membase + PLX_GPIOC;\n\t\twritel(PLX_GPIOC_INIT, plx_acc_32);\n\t\tpv = readl(plx_acc_32);\n\t\t \n\t\tpv |= PLX_TERM_ON;  \n\t\t \n\t\tpv |= PLX_SLAVE_EN_N;\n\t\tpv &= ~PLX_MASTER_EN;\n\t\tpv &= ~PLX_SYNC_O_EN;\n\t\t \n\t\tpv &= ~PLX_DSP_RES_N;\n\t\twritel(pv, plx_acc_32);\n\t\tspin_unlock_irqrestore(&plx_lock, plx_flags);\n\t\tif (debug & DEBUG_HFCMULTI_INIT)\n\t\t\tprintk(KERN_DEBUG \"%s: slave/term: PLX_GPIO=%x\\n\",\n\t\t\t       __func__, pv);\n\t\t \n\t\tspin_lock_irqsave(&HFClock, hfc_flags);\n\t\tplx_count = 0;\n\t\tplx_last_hc = NULL;\n\t\tlist_for_each_entry_safe(pos, next, &HFClist, list) {\n\t\t\tif (test_bit(HFC_CHIP_PLXSD, &pos->chip)) {\n\t\t\t\tplx_count++;\n\t\t\t\tif (pos != hc)\n\t\t\t\t\tplx_last_hc = pos;\n\t\t\t}\n\t\t}\n\t\tif (plx_count >= 3) {\n\t\t\tif (debug & DEBUG_HFCMULTI_PLXSD)\n\t\t\t\tprintk(KERN_DEBUG \"%s: card %d is between, so \"\n\t\t\t\t       \"we disable termination\\n\",\n\t\t\t\t       __func__, plx_last_hc->id + 1);\n\t\t\tspin_lock_irqsave(&plx_lock, plx_flags);\n\t\t\tplx_acc_32 = plx_last_hc->plx_membase + PLX_GPIOC;\n\t\t\tpv = readl(plx_acc_32);\n\t\t\tpv &= ~PLX_TERM_ON;\n\t\t\twritel(pv, plx_acc_32);\n\t\t\tspin_unlock_irqrestore(&plx_lock, plx_flags);\n\t\t\tif (debug & DEBUG_HFCMULTI_INIT)\n\t\t\t\tprintk(KERN_DEBUG\n\t\t\t\t       \"%s: term off: PLX_GPIO=%x\\n\",\n\t\t\t\t       __func__, pv);\n\t\t}\n\t\tspin_unlock_irqrestore(&HFClock, hfc_flags);\n\t\thc->hw.r_pcm_md0 = V_F0_LEN;  \n\t}\n\n\tif (test_bit(HFC_CHIP_EMBSD, &hc->chip))\n\t\thc->hw.r_pcm_md0 = V_F0_LEN;  \n\n\t \n\tif (!test_bit(HFC_CHIP_REVISION0, &hc->chip))\n\t\thc->hw.r_ram_sz |= V_FZ_MD;\n\n\t \n\tif (test_bit(HFC_CHIP_PCM_SLAVE, &hc->chip)) {\n\t\tif (debug & DEBUG_HFCMULTI_INIT)\n\t\t\tprintk(KERN_DEBUG \"%s: setting PCM into slave mode\\n\",\n\t\t\t       __func__);\n\t} else\n\t\tif (test_bit(HFC_CHIP_PCM_MASTER, &hc->chip) && !plxsd_master) {\n\t\t\tif (debug & DEBUG_HFCMULTI_INIT)\n\t\t\t\tprintk(KERN_DEBUG \"%s: setting PCM into master mode\\n\",\n\t\t\t\t       __func__);\n\t\t\thc->hw.r_pcm_md0 |= V_PCM_MD;\n\t\t} else {\n\t\t\tif (debug & DEBUG_HFCMULTI_INIT)\n\t\t\t\tprintk(KERN_DEBUG \"%s: performing PCM auto detect\\n\",\n\t\t\t\t       __func__);\n\t\t}\n\n\t \n\tHFC_outb(hc, R_CTRL, hc->hw.r_ctrl);\n\tif (hc->ctype == HFC_TYPE_XHFC)\n\t\tHFC_outb(hc, 0x0C  ,\n\t\t\t 0x11  );\n\telse\n\t\tHFC_outb(hc, R_RAM_SZ, hc->hw.r_ram_sz);\n\tHFC_outb(hc, R_FIFO_MD, 0);\n\tif (hc->ctype == HFC_TYPE_XHFC)\n\t\thc->hw.r_cirm = V_SRES | V_HFCRES | V_PCMRES | V_STRES;\n\telse\n\t\thc->hw.r_cirm = V_SRES | V_HFCRES | V_PCMRES | V_STRES\n\t\t\t| V_RLD_EPR;\n\tHFC_outb(hc, R_CIRM, hc->hw.r_cirm);\n\tudelay(100);\n\thc->hw.r_cirm = 0;\n\tHFC_outb(hc, R_CIRM, hc->hw.r_cirm);\n\tudelay(100);\n\tif (hc->ctype != HFC_TYPE_XHFC)\n\t\tHFC_outb(hc, R_RAM_SZ, hc->hw.r_ram_sz);\n\n\t \n\tif (test_bit(HFC_CHIP_PLXSD, &hc->chip)) {\n\t\tspin_lock_irqsave(&plx_lock, plx_flags);\n\t\tplx_acc_32 = hc->plx_membase + PLX_GPIOC;\n\t\tpv = readl(plx_acc_32);\n\t\t \n\t\tif (hc->hw.r_pcm_md0 & V_PCM_MD) {\n\t\t\tpv |= PLX_MASTER_EN | PLX_SLAVE_EN_N;\n\t\t\tpv |= PLX_SYNC_O_EN;\n\t\t\tif (debug & DEBUG_HFCMULTI_INIT)\n\t\t\t\tprintk(KERN_DEBUG \"%s: master: PLX_GPIO=%x\\n\",\n\t\t\t\t       __func__, pv);\n\t\t} else {\n\t\t\tpv &= ~(PLX_MASTER_EN | PLX_SLAVE_EN_N);\n\t\t\tpv &= ~PLX_SYNC_O_EN;\n\t\t\tif (debug & DEBUG_HFCMULTI_INIT)\n\t\t\t\tprintk(KERN_DEBUG \"%s: slave: PLX_GPIO=%x\\n\",\n\t\t\t\t       __func__, pv);\n\t\t}\n\t\twritel(pv, plx_acc_32);\n\t\tspin_unlock_irqrestore(&plx_lock, plx_flags);\n\t}\n\n\t \n\tHFC_outb(hc, R_PCM_MD0, hc->hw.r_pcm_md0 | 0x90);\n\tif (hc->slots == 32)\n\t\tHFC_outb(hc, R_PCM_MD1, 0x00);\n\tif (hc->slots == 64)\n\t\tHFC_outb(hc, R_PCM_MD1, 0x10);\n\tif (hc->slots == 128)\n\t\tHFC_outb(hc, R_PCM_MD1, 0x20);\n\tHFC_outb(hc, R_PCM_MD0, hc->hw.r_pcm_md0 | 0xa0);\n\tif (test_bit(HFC_CHIP_PLXSD, &hc->chip))\n\t\tHFC_outb(hc, R_PCM_MD2, V_SYNC_SRC);  \n\telse if (test_bit(HFC_CHIP_EMBSD, &hc->chip))\n\t\tHFC_outb(hc, R_PCM_MD2, 0x10);  \n\telse\n\t\tHFC_outb(hc, R_PCM_MD2, 0x00);  \n\tHFC_outb(hc, R_PCM_MD0, hc->hw.r_pcm_md0 | 0x00);\n\tfor (i = 0; i < 256; i++) {\n\t\tHFC_outb_nodebug(hc, R_SLOT, i);\n\t\tHFC_outb_nodebug(hc, A_SL_CFG, 0);\n\t\tif (hc->ctype != HFC_TYPE_XHFC)\n\t\t\tHFC_outb_nodebug(hc, A_CONF, 0);\n\t\thc->slot_owner[i] = -1;\n\t}\n\n\t \n\tif (test_bit(HFC_CHIP_CLOCK2, &hc->chip)) {\n\t\tif (debug & DEBUG_HFCMULTI_INIT)\n\t\t\tprintk(KERN_DEBUG\n\t\t\t       \"%s: setting double clock\\n\", __func__);\n\t\tHFC_outb(hc, R_BRG_PCM_CFG, V_PCM_CLK);\n\t}\n\n\tif (test_bit(HFC_CHIP_EMBSD, &hc->chip))\n\t\tHFC_outb(hc, 0x02  , 0x40  );\n\n\t \n\tif (test_bit(HFC_CHIP_B410P, &hc->chip)) {\n\t\tprintk(KERN_NOTICE \"Setting GPIOs\\n\");\n\t\tHFC_outb(hc, R_GPIO_SEL, 0x30);\n\t\tHFC_outb(hc, R_GPIO_EN1, 0x3);\n\t\tudelay(1000);\n\t\tprintk(KERN_NOTICE \"calling vpm_init\\n\");\n\t\tvpm_init(hc);\n\t}\n\n\t \n\tval = HFC_inb(hc, R_F0_CNTL);\n\tval += HFC_inb(hc, R_F0_CNTH) << 8;\n\tif (debug & DEBUG_HFCMULTI_INIT)\n\t\tprintk(KERN_DEBUG\n\t\t       \"HFC_multi F0_CNT %ld after reset\\n\", val);\n\tspin_unlock_irqrestore(&hc->lock, flags);\n\tset_current_state(TASK_UNINTERRUPTIBLE);\n\tschedule_timeout((HZ / 100) ? : 1);  \n\tspin_lock_irqsave(&hc->lock, flags);\n\tval2 = HFC_inb(hc, R_F0_CNTL);\n\tval2 += HFC_inb(hc, R_F0_CNTH) << 8;\n\tif (debug & DEBUG_HFCMULTI_INIT)\n\t\tprintk(KERN_DEBUG\n\t\t       \"HFC_multi F0_CNT %ld after 10 ms (1st try)\\n\",\n\t\t       val2);\n\tif (val2 >= val + 8) {  \n\t\t \n\t\tif (test_bit(HFC_CHIP_PCM_MASTER, &hc->chip))\n\t\t\tprintk(KERN_INFO \"controller is PCM bus MASTER\\n\");\n\t\telse\n\t\t\tif (test_bit(HFC_CHIP_PCM_SLAVE, &hc->chip))\n\t\t\t\tprintk(KERN_INFO \"controller is PCM bus SLAVE\\n\");\n\t\t\telse {\n\t\t\t\ttest_and_set_bit(HFC_CHIP_PCM_SLAVE, &hc->chip);\n\t\t\t\tprintk(KERN_INFO \"controller is PCM bus SLAVE \"\n\t\t\t\t       \"(auto detected)\\n\");\n\t\t\t}\n\t} else {\n\t\t \n\t\tif (test_bit(HFC_CHIP_PCM_MASTER, &hc->chip)) {\n\t\tcontroller_fail:\n\t\t\tprintk(KERN_ERR \"HFC_multi ERROR, getting no 125us \"\n\t\t\t       \"pulse. Seems that controller fails.\\n\");\n\t\t\terr = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tif (test_bit(HFC_CHIP_PCM_SLAVE, &hc->chip)) {\n\t\t\tprintk(KERN_INFO \"controller is PCM bus SLAVE \"\n\t\t\t       \"(ignoring missing PCM clock)\\n\");\n\t\t} else {\n\t\t\t \n\t\t\tif (test_bit(HFC_CHIP_PLXSD, &hc->chip)\n\t\t\t    && plxsd_master) {\n\t\t\t\tprintk(KERN_ERR \"HFC_multi ERROR, no clock \"\n\t\t\t\t       \"on another Speech Design card found. \"\n\t\t\t\t       \"Please be sure to connect PCM cable.\\n\");\n\t\t\t\terr = -EIO;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\t \n\t\t\tif (test_bit(HFC_CHIP_PLXSD, &hc->chip)) {\n\t\t\t\tspin_lock_irqsave(&plx_lock, plx_flags);\n\t\t\t\tplx_acc_32 = hc->plx_membase + PLX_GPIOC;\n\t\t\t\tpv = readl(plx_acc_32);\n\t\t\t\tpv |= PLX_MASTER_EN | PLX_SLAVE_EN_N;\n\t\t\t\tpv |= PLX_SYNC_O_EN;\n\t\t\t\twritel(pv, plx_acc_32);\n\t\t\t\tspin_unlock_irqrestore(&plx_lock, plx_flags);\n\t\t\t\tif (debug & DEBUG_HFCMULTI_INIT)\n\t\t\t\t\tprintk(KERN_DEBUG \"%s: master: \"\n\t\t\t\t\t       \"PLX_GPIO=%x\\n\", __func__, pv);\n\t\t\t}\n\t\t\thc->hw.r_pcm_md0 |= V_PCM_MD;\n\t\t\tHFC_outb(hc, R_PCM_MD0, hc->hw.r_pcm_md0 | 0x00);\n\t\t\tspin_unlock_irqrestore(&hc->lock, flags);\n\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\tschedule_timeout((HZ / 100) ?: 1);  \n\t\t\tspin_lock_irqsave(&hc->lock, flags);\n\t\t\tval2 = HFC_inb(hc, R_F0_CNTL);\n\t\t\tval2 += HFC_inb(hc, R_F0_CNTH) << 8;\n\t\t\tif (debug & DEBUG_HFCMULTI_INIT)\n\t\t\t\tprintk(KERN_DEBUG \"HFC_multi F0_CNT %ld after \"\n\t\t\t\t       \"10 ms (2nd try)\\n\", val2);\n\t\t\tif (val2 >= val + 8) {  \n\t\t\t\ttest_and_set_bit(HFC_CHIP_PCM_MASTER,\n\t\t\t\t\t\t &hc->chip);\n\t\t\t\tprintk(KERN_INFO \"controller is PCM bus MASTER \"\n\t\t\t\t       \"(auto detected)\\n\");\n\t\t\t} else\n\t\t\t\tgoto controller_fail;\n\t\t}\n\t}\n\n\t \n\tif (test_bit(HFC_CHIP_PLXSD, &hc->chip)) {\n\t\tif (test_bit(HFC_CHIP_PCM_MASTER, &hc->chip))\n\t\t\tplxsd_master = 1;\n\t\tspin_lock_irqsave(&plx_lock, plx_flags);\n\t\tplx_acc_32 = hc->plx_membase + PLX_GPIOC;\n\t\tpv = readl(plx_acc_32);\n\t\tpv |=  PLX_DSP_RES_N;\n\t\twritel(pv, plx_acc_32);\n\t\tspin_unlock_irqrestore(&plx_lock, plx_flags);\n\t\tif (debug & DEBUG_HFCMULTI_INIT)\n\t\t\tprintk(KERN_DEBUG \"%s: reset off: PLX_GPIO=%x\\n\",\n\t\t\t       __func__, pv);\n\t}\n\n\t \n\tif (hc->pcm)\n\t\tprintk(KERN_INFO \"controller has given PCM BUS ID %d\\n\",\n\t\t       hc->pcm);\n\telse {\n\t\tif (test_bit(HFC_CHIP_PCM_MASTER, &hc->chip)\n\t\t    || test_bit(HFC_CHIP_PLXSD, &hc->chip)) {\n\t\t\tPCM_cnt++;  \n\t\t}\n\t\thc->pcm = PCM_cnt;\n\t\tprintk(KERN_INFO \"controller has PCM BUS ID %d \"\n\t\t       \"(auto selected)\\n\", hc->pcm);\n\t}\n\n\t \n\tHFC_outb(hc, R_TI_WD, poll_timer);\n\thc->hw.r_irqmsk_misc |= V_TI_IRQMSK;\n\n\t \n\tif (hc->ctype == HFC_TYPE_E1)\n\t\thc->hw.r_irqmsk_misc |= V_STA_IRQMSK;\n\n\t \n\tif (test_bit(HFC_CHIP_DTMF, &hc->chip)) {\n\t\tif (debug & DEBUG_HFCMULTI_INIT)\n\t\t\tprintk(KERN_DEBUG \"%s: enabling DTMF detection \"\n\t\t\t       \"for all B-channel\\n\", __func__);\n\t\thc->hw.r_dtmf = V_DTMF_EN | V_DTMF_STOP;\n\t\tif (test_bit(HFC_CHIP_ULAW, &hc->chip))\n\t\t\thc->hw.r_dtmf |= V_ULAW_SEL;\n\t\tHFC_outb(hc, R_DTMF_N, 102 - 1);\n\t\thc->hw.r_irqmsk_misc |= V_DTMF_IRQMSK;\n\t}\n\n\t \n\tif (test_bit(HFC_CHIP_ULAW, &hc->chip))\n\t\tr_conf_en = V_CONF_EN | V_ULAW;\n\telse\n\t\tr_conf_en = V_CONF_EN;\n\tif (hc->ctype != HFC_TYPE_XHFC)\n\t\tHFC_outb(hc, R_CONF_EN, r_conf_en);\n\n\t \n\tswitch (hc->leds) {\n\tcase 1:  \n\t\tif (test_bit(HFC_CHIP_WATCHDOG, &hc->chip))\n\t\t\tHFC_outb(hc, R_GPIO_SEL, 0x32);\n\t\telse\n\t\t\tHFC_outb(hc, R_GPIO_SEL, 0x30);\n\n\t\tHFC_outb(hc, R_GPIO_EN1, 0x0f);\n\t\tHFC_outb(hc, R_GPIO_OUT1, 0x00);\n\n\t\tHFC_outb(hc, R_GPIO_EN0, V_GPIO_EN2 | V_GPIO_EN3);\n\t\tbreak;\n\n\tcase 2:  \n\tcase 3:\n\t\tHFC_outb(hc, R_GPIO_SEL, 0xf0);\n\t\tHFC_outb(hc, R_GPIO_EN1, 0xff);\n\t\tHFC_outb(hc, R_GPIO_OUT1, 0x00);\n\t\tbreak;\n\t}\n\n\tif (test_bit(HFC_CHIP_EMBSD, &hc->chip)) {\n\t\thc->hw.r_st_sync = 0x10;  \n\t\tHFC_outb(hc, R_ST_SYNC, hc->hw.r_st_sync);\n\t}\n\n\t \n\tif (hc->masterclk >= 0) {\n\t\tif (debug & DEBUG_HFCMULTI_INIT)\n\t\t\tprintk(KERN_DEBUG \"%s: setting ST master clock \"\n\t\t\t       \"to port %d (0..%d)\\n\",\n\t\t\t       __func__, hc->masterclk, hc->ports - 1);\n\t\thc->hw.r_st_sync |= (hc->masterclk | V_AUTO_SYNC);\n\t\tHFC_outb(hc, R_ST_SYNC, hc->hw.r_st_sync);\n\t}\n\n\n\n\t \n\tHFC_outb(hc, R_IRQMSK_MISC, hc->hw.r_irqmsk_misc);\n\tif (debug & DEBUG_HFCMULTI_INIT)\n\t\tprintk(KERN_DEBUG \"r_irqmsk_misc.2: 0x%x\\n\",\n\t\t       hc->hw.r_irqmsk_misc);\n\n\t \n\tHFC_outb(hc, R_RAM_ADDR0, 0);\n\tHFC_outb(hc, R_RAM_ADDR1, 0);\n\tHFC_outb(hc, R_RAM_ADDR2, 0);\n\tfor (i = 0; i < 256; i++) {\n\t\tHFC_outb_nodebug(hc, R_RAM_ADDR0, i);\n\t\tHFC_outb_nodebug(hc, R_RAM_DATA, ((i * 3) & 0xff));\n\t}\n\tfor (i = 0; i < 256; i++) {\n\t\tHFC_outb_nodebug(hc, R_RAM_ADDR0, i);\n\t\tHFC_inb_nodebug(hc, R_RAM_DATA);\n\t\trval = HFC_inb_nodebug(hc, R_INT_DATA);\n\t\tif (rval != ((i * 3) & 0xff)) {\n\t\t\tprintk(KERN_DEBUG\n\t\t\t       \"addr:%x val:%x should:%x\\n\", i, rval,\n\t\t\t       (i * 3) & 0xff);\n\t\t\terr++;\n\t\t}\n\t}\n\tif (err) {\n\t\tprintk(KERN_DEBUG \"aborting - %d RAM access errors\\n\", err);\n\t\terr = -EIO;\n\t\tgoto out;\n\t}\n\n\tif (debug & DEBUG_HFCMULTI_INIT)\n\t\tprintk(KERN_DEBUG \"%s: done\\n\", __func__);\nout:\n\tspin_unlock_irqrestore(&hc->lock, flags);\n\treturn err;\n}\n\n\n \nstatic void\nhfcmulti_watchdog(struct hfc_multi *hc)\n{\n\thc->wdcount++;\n\n\tif (hc->wdcount > 10) {\n\t\thc->wdcount = 0;\n\t\thc->wdbyte = hc->wdbyte == V_GPIO_OUT2 ?\n\t\t\tV_GPIO_OUT3 : V_GPIO_OUT2;\n\n\t\t \n\t\tHFC_outb(hc, R_GPIO_EN0, V_GPIO_EN2 | V_GPIO_EN3);\n\t\tHFC_outb(hc, R_GPIO_OUT0, hc->wdbyte);\n\t}\n}\n\n\n\n \nstatic void\nhfcmulti_leds(struct hfc_multi *hc)\n{\n\tunsigned long lled;\n\tunsigned long leddw;\n\tint i, state, active, leds;\n\tstruct dchannel *dch;\n\tint led[4];\n\n\tswitch (hc->leds) {\n\tcase 1:  \n\t\t \n\t\tled[0] = 0;\n\t\tled[1] = 0;\n\t\tled[2] = 0;\n\t\tled[3] = 0;\n\t\tdch = hc->chan[hc->dnum[0]].dch;\n\t\tif (dch) {\n\t\t\tif (hc->chan[hc->dnum[0]].los)\n\t\t\t\tled[1] = 1;\n\t\t\tif (hc->e1_state != 1) {\n\t\t\t\tled[0] = 1;\n\t\t\t\thc->flash[2] = 0;\n\t\t\t\thc->flash[3] = 0;\n\t\t\t} else {\n\t\t\t\tled[2] = 1;\n\t\t\t\tled[3] = 1;\n\t\t\t\tif (!hc->flash[2] && hc->activity_tx)\n\t\t\t\t\thc->flash[2] = poll;\n\t\t\t\tif (!hc->flash[3] && hc->activity_rx)\n\t\t\t\t\thc->flash[3] = poll;\n\t\t\t\tif (hc->flash[2] && hc->flash[2] < 1024)\n\t\t\t\t\tled[2] = 0;\n\t\t\t\tif (hc->flash[3] && hc->flash[3] < 1024)\n\t\t\t\t\tled[3] = 0;\n\t\t\t\tif (hc->flash[2] >= 2048)\n\t\t\t\t\thc->flash[2] = 0;\n\t\t\t\tif (hc->flash[3] >= 2048)\n\t\t\t\t\thc->flash[3] = 0;\n\t\t\t\tif (hc->flash[2])\n\t\t\t\t\thc->flash[2] += poll;\n\t\t\t\tif (hc->flash[3])\n\t\t\t\t\thc->flash[3] += poll;\n\t\t\t}\n\t\t}\n\t\tleds = (led[0] | (led[1]<<2) | (led[2]<<1) | (led[3]<<3))^0xF;\n\t\t \n\t\tif (leds != (int)hc->ledstate) {\n\t\t\tHFC_outb_nodebug(hc, R_GPIO_OUT1, leds);\n\t\t\thc->ledstate = leds;\n\t\t}\n\t\tbreak;\n\n\tcase 2:  \n\t\t \n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tstate = 0;\n\t\t\tactive = -1;\n\t\t\tdch = hc->chan[(i << 2) | 2].dch;\n\t\t\tif (dch) {\n\t\t\t\tstate = dch->state;\n\t\t\t\tif (dch->dev.D.protocol == ISDN_P_NT_S0)\n\t\t\t\t\tactive = 3;\n\t\t\t\telse\n\t\t\t\t\tactive = 7;\n\t\t\t}\n\t\t\tif (state) {\n\t\t\t\tif (state == active) {\n\t\t\t\t\tled[i] = 1;  \n\t\t\t\t\thc->activity_tx |= hc->activity_rx;\n\t\t\t\t\tif (!hc->flash[i] &&\n\t\t\t\t\t\t(hc->activity_tx & (1 << i)))\n\t\t\t\t\t\t\thc->flash[i] = poll;\n\t\t\t\t\tif (hc->flash[i] && hc->flash[i] < 1024)\n\t\t\t\t\t\tled[i] = 0;  \n\t\t\t\t\tif (hc->flash[i] >= 2048)\n\t\t\t\t\t\thc->flash[i] = 0;\n\t\t\t\t\tif (hc->flash[i])\n\t\t\t\t\t\thc->flash[i] += poll;\n\t\t\t\t} else {\n\t\t\t\t\tled[i] = 2;  \n\t\t\t\t\thc->flash[i] = 0;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\tled[i] = 0;  \n\t\t}\n\t\tif (test_bit(HFC_CHIP_B410P, &hc->chip)) {\n\t\t\tleds = 0;\n\t\t\tfor (i = 0; i < 4; i++) {\n\t\t\t\tif (led[i] == 1) {\n\t\t\t\t\t \n\t\t\t\t\tleds |= (0x2 << (i * 2));\n\t\t\t\t} else if (led[i] == 2) {\n\t\t\t\t\t \n\t\t\t\t\tleds |= (0x1 << (i * 2));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (leds != (int)hc->ledstate) {\n\t\t\t\tvpm_out(hc, 0, 0x1a8 + 3, leds);\n\t\t\t\thc->ledstate = leds;\n\t\t\t}\n\t\t} else {\n\t\t\tleds = ((led[3] > 0) << 0) | ((led[1] > 0) << 1) |\n\t\t\t\t((led[0] > 0) << 2) | ((led[2] > 0) << 3) |\n\t\t\t\t((led[3] & 1) << 4) | ((led[1] & 1) << 5) |\n\t\t\t\t((led[0] & 1) << 6) | ((led[2] & 1) << 7);\n\t\t\tif (leds != (int)hc->ledstate) {\n\t\t\t\tHFC_outb_nodebug(hc, R_GPIO_EN1, leds & 0x0F);\n\t\t\t\tHFC_outb_nodebug(hc, R_GPIO_OUT1, leds >> 4);\n\t\t\t\thc->ledstate = leds;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase 3:  \n\t\t \n\t\tfor (i = 0; i < 2; i++) {\n\t\t\tstate = 0;\n\t\t\tactive = -1;\n\t\t\tdch = hc->chan[(i << 2) | 2].dch;\n\t\t\tif (dch) {\n\t\t\t\tstate = dch->state;\n\t\t\t\tif (dch->dev.D.protocol == ISDN_P_NT_S0)\n\t\t\t\t\tactive = 3;\n\t\t\t\telse\n\t\t\t\t\tactive = 7;\n\t\t\t}\n\t\t\tif (state) {\n\t\t\t\tif (state == active) {\n\t\t\t\t\tled[i] = 1;  \n\t\t\t\t\thc->activity_tx |= hc->activity_rx;\n\t\t\t\t\tif (!hc->flash[i] &&\n\t\t\t\t\t\t(hc->activity_tx & (1 << i)))\n\t\t\t\t\t\t\thc->flash[i] = poll;\n\t\t\t\t\tif (hc->flash[i] < 1024)\n\t\t\t\t\t\tled[i] = 0;  \n\t\t\t\t\tif (hc->flash[i] >= 2048)\n\t\t\t\t\t\thc->flash[i] = 0;\n\t\t\t\t\tif (hc->flash[i])\n\t\t\t\t\t\thc->flash[i] += poll;\n\t\t\t\t} else {\n\t\t\t\t\tled[i] = 2;  \n\t\t\t\t\thc->flash[i] = 0;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\tled[i] = 0;  \n\t\t}\n\t\tleds = (led[0] > 0) | ((led[1] > 0) << 1) | ((led[0]&1) << 2)\n\t\t\t| ((led[1]&1) << 3);\n\t\tif (leds != (int)hc->ledstate) {\n\t\t\tHFC_outb_nodebug(hc, R_GPIO_EN1,\n\t\t\t\t\t ((led[0] > 0) << 2) | ((led[1] > 0) << 3));\n\t\t\tHFC_outb_nodebug(hc, R_GPIO_OUT1,\n\t\t\t\t\t ((led[0] & 1) << 2) | ((led[1] & 1) << 3));\n\t\t\thc->ledstate = leds;\n\t\t}\n\t\tbreak;\n\tcase 8:  \n\t\t \n\t\tlled = 0xff;  \n\t\tfor (i = 0; i < 8; i++) {\n\t\t\tstate = 0;\n\t\t\tactive = -1;\n\t\t\tdch = hc->chan[(i << 2) | 2].dch;\n\t\t\tif (dch) {\n\t\t\t\tstate = dch->state;\n\t\t\t\tif (dch->dev.D.protocol == ISDN_P_NT_S0)\n\t\t\t\t\tactive = 3;\n\t\t\t\telse\n\t\t\t\t\tactive = 7;\n\t\t\t}\n\t\t\tif (state) {\n\t\t\t\tif (state == active) {\n\t\t\t\t\tlled &= ~(1 << i);  \n\t\t\t\t\thc->activity_tx |= hc->activity_rx;\n\t\t\t\t\tif (!hc->flash[i] &&\n\t\t\t\t\t\t(hc->activity_tx & (1 << i)))\n\t\t\t\t\t\t\thc->flash[i] = poll;\n\t\t\t\t\tif (hc->flash[i] < 1024)\n\t\t\t\t\t\tlled |= 1 << i;  \n\t\t\t\t\tif (hc->flash[i] >= 2048)\n\t\t\t\t\t\thc->flash[i] = 0;\n\t\t\t\t\tif (hc->flash[i])\n\t\t\t\t\t\thc->flash[i] += poll;\n\t\t\t\t} else\n\t\t\t\t\thc->flash[i] = 0;\n\t\t\t}\n\t\t}\n\t\tleddw = lled << 24 | lled << 16 | lled << 8 | lled;\n\t\tif (leddw != hc->ledstate) {\n\t\t\t \n\t\t\t \n\t\t\tHFC_outb_nodebug(hc, R_BRG_PCM_CFG, 1 | V_PCM_CLK);\n\t\t\toutw(0x4000, hc->pci_iobase + 4);\n\t\t\toutl(leddw, hc->pci_iobase);\n\t\t\tHFC_outb_nodebug(hc, R_BRG_PCM_CFG, V_PCM_CLK);\n\t\t\thc->ledstate = leddw;\n\t\t}\n\t\tbreak;\n\t}\n\thc->activity_tx = 0;\n\thc->activity_rx = 0;\n}\n \n\nstatic void\nhfcmulti_dtmf(struct hfc_multi *hc)\n{\n\ts32\t\t*coeff;\n\tu_int\t\tmantissa;\n\tint\t\tco, ch;\n\tstruct bchannel\t*bch = NULL;\n\tu8\t\texponent;\n\tint\t\tdtmf = 0;\n\tint\t\taddr;\n\tu16\t\tw_float;\n\tstruct sk_buff\t*skb;\n\tstruct mISDNhead *hh;\n\n\tif (debug & DEBUG_HFCMULTI_DTMF)\n\t\tprintk(KERN_DEBUG \"%s: dtmf detection irq\\n\", __func__);\n\tfor (ch = 0; ch <= 31; ch++) {\n\t\t \n\t\tbch = hc->chan[ch].bch;\n\t\tif (!bch)\n\t\t\tcontinue;\n\t\tif (!hc->created[hc->chan[ch].port])\n\t\t\tcontinue;\n\t\tif (!test_bit(FLG_TRANSPARENT, &bch->Flags))\n\t\t\tcontinue;\n\t\tif (debug & DEBUG_HFCMULTI_DTMF)\n\t\t\tprintk(KERN_DEBUG \"%s: dtmf channel %d:\",\n\t\t\t       __func__, ch);\n\t\tcoeff = &(hc->chan[ch].coeff[hc->chan[ch].coeff_count * 16]);\n\t\tdtmf = 1;\n\t\tfor (co = 0; co < 8; co++) {\n\t\t\t \n\t\t\taddr = hc->DTMFbase + ((co << 7) | (ch << 2));\n\t\t\tHFC_outb_nodebug(hc, R_RAM_ADDR0, addr);\n\t\t\tHFC_outb_nodebug(hc, R_RAM_ADDR1, addr >> 8);\n\t\t\tHFC_outb_nodebug(hc, R_RAM_ADDR2, (addr >> 16)\n\t\t\t\t\t | V_ADDR_INC);\n\t\t\tw_float = HFC_inb_nodebug(hc, R_RAM_DATA);\n\t\t\tw_float |= (HFC_inb_nodebug(hc, R_RAM_DATA) << 8);\n\t\t\tif (debug & DEBUG_HFCMULTI_DTMF)\n\t\t\t\tprintk(\" %04x\", w_float);\n\n\t\t\t \n\t\t\tmantissa = w_float & 0x0fff;\n\t\t\tif (w_float & 0x8000)\n\t\t\t\tmantissa |= 0xfffff000;\n\t\t\texponent = (w_float >> 12) & 0x7;\n\t\t\tif (exponent) {\n\t\t\t\tmantissa ^= 0x1000;\n\t\t\t\tmantissa <<= (exponent - 1);\n\t\t\t}\n\n\t\t\t \n\t\t\tcoeff[co << 1] = mantissa;\n\n\t\t\t \n\t\t\tw_float = HFC_inb_nodebug(hc, R_RAM_DATA);\n\t\t\tw_float |= (HFC_inb_nodebug(hc, R_RAM_DATA) << 8);\n\t\t\tif (debug & DEBUG_HFCMULTI_DTMF)\n\t\t\t\tprintk(\" %04x\", w_float);\n\n\t\t\t \n\t\t\tmantissa = w_float & 0x0fff;\n\t\t\tif (w_float & 0x8000)\n\t\t\t\tmantissa |= 0xfffff000;\n\t\t\texponent = (w_float >> 12) & 0x7;\n\t\t\tif (exponent) {\n\t\t\t\tmantissa ^= 0x1000;\n\t\t\t\tmantissa <<= (exponent - 1);\n\t\t\t}\n\n\t\t\t \n\t\t\tcoeff[(co << 1) | 1] = mantissa;\n\t\t}\n\t\tif (debug & DEBUG_HFCMULTI_DTMF)\n\t\t\tprintk(\" DTMF ready %08x %08x %08x %08x \"\n\t\t\t       \"%08x %08x %08x %08x\\n\",\n\t\t\t       coeff[0], coeff[1], coeff[2], coeff[3],\n\t\t\t       coeff[4], coeff[5], coeff[6], coeff[7]);\n\t\thc->chan[ch].coeff_count++;\n\t\tif (hc->chan[ch].coeff_count == 8) {\n\t\t\thc->chan[ch].coeff_count = 0;\n\t\t\tskb = mI_alloc_skb(512, GFP_ATOMIC);\n\t\t\tif (!skb) {\n\t\t\t\tprintk(KERN_DEBUG \"%s: No memory for skb\\n\",\n\t\t\t\t       __func__);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\thh = mISDN_HEAD_P(skb);\n\t\t\thh->prim = PH_CONTROL_IND;\n\t\t\thh->id = DTMF_HFC_COEF;\n\t\t\tskb_put_data(skb, hc->chan[ch].coeff, 512);\n\t\t\trecv_Bchannel_skb(bch, skb);\n\t\t}\n\t}\n\n\t \n\thc->dtmf = dtmf;\n\tif (dtmf)\n\t\tHFC_outb_nodebug(hc, R_DTMF, hc->hw.r_dtmf | V_RST_DTMF);\n}\n\n\n \n\nstatic void\nhfcmulti_tx(struct hfc_multi *hc, int ch)\n{\n\tint i, ii, temp, len = 0;\n\tint Zspace, z1, z2;  \n\tint Fspace, f1, f2;\n\tu_char *d;\n\tint *txpending, slot_tx;\n\tstruct\tbchannel *bch;\n\tstruct  dchannel *dch;\n\tstruct  sk_buff **sp = NULL;\n\tint *idxp;\n\n\tbch = hc->chan[ch].bch;\n\tdch = hc->chan[ch].dch;\n\tif ((!dch) && (!bch))\n\t\treturn;\n\n\ttxpending = &hc->chan[ch].txpending;\n\tslot_tx = hc->chan[ch].slot_tx;\n\tif (dch) {\n\t\tif (!test_bit(FLG_ACTIVE, &dch->Flags))\n\t\t\treturn;\n\t\tsp = &dch->tx_skb;\n\t\tidxp = &dch->tx_idx;\n\t} else {\n\t\tif (!test_bit(FLG_ACTIVE, &bch->Flags))\n\t\t\treturn;\n\t\tsp = &bch->tx_skb;\n\t\tidxp = &bch->tx_idx;\n\t}\n\tif (*sp)\n\t\tlen = (*sp)->len;\n\n\tif ((!len) && *txpending != 1)\n\t\treturn;  \n\n\tif (test_bit(HFC_CHIP_B410P, &hc->chip) &&\n\t    (hc->chan[ch].protocol == ISDN_P_B_RAW) &&\n\t    (hc->chan[ch].slot_rx < 0) &&\n\t    (hc->chan[ch].slot_tx < 0))\n\t\tHFC_outb_nodebug(hc, R_FIFO, 0x20 | (ch << 1));\n\telse\n\t\tHFC_outb_nodebug(hc, R_FIFO, ch << 1);\n\tHFC_wait_nodebug(hc);\n\n\tif (*txpending == 2) {\n\t\t \n\t\tHFC_outb_nodebug(hc, R_INC_RES_FIFO, V_RES_F);\n\t\tHFC_wait_nodebug(hc);\n\t\tHFC_outb(hc, A_SUBCH_CFG, 0);\n\t\t*txpending = 1;\n\t}\nnext_frame:\n\tif (dch || test_bit(FLG_HDLC, &bch->Flags)) {\n\t\tf1 = HFC_inb_nodebug(hc, A_F1);\n\t\tf2 = HFC_inb_nodebug(hc, A_F2);\n\t\twhile (f2 != (temp = HFC_inb_nodebug(hc, A_F2))) {\n\t\t\tif (debug & DEBUG_HFCMULTI_FIFO)\n\t\t\t\tprintk(KERN_DEBUG\n\t\t\t\t       \"%s(card %d): reread f2 because %d!=%d\\n\",\n\t\t\t\t       __func__, hc->id + 1, temp, f2);\n\t\t\tf2 = temp;  \n\t\t}\n\t\tFspace = f2 - f1 - 1;\n\t\tif (Fspace < 0)\n\t\t\tFspace += hc->Flen;\n\t\t \n\t\tif (test_bit(HFC_CHIP_REVISION0, &hc->chip)) {\n\t\t\tif (f1 != f2)\n\t\t\t\tFspace = 0;\n\t\t\telse\n\t\t\t\tFspace = 1;\n\t\t}\n\t\t \n\t\tif (hc->ctype != HFC_TYPE_E1 && dch) {\n\t\t\tif (f1 != f2)\n\t\t\t\tFspace = 0;\n\t\t}\n\t\t \n\t\tif (Fspace == 0)\n\t\t\treturn;\n\t}\n\tz1 = HFC_inw_nodebug(hc, A_Z1) - hc->Zmin;\n\tz2 = HFC_inw_nodebug(hc, A_Z2) - hc->Zmin;\n\twhile (z2 != (temp = (HFC_inw_nodebug(hc, A_Z2) - hc->Zmin))) {\n\t\tif (debug & DEBUG_HFCMULTI_FIFO)\n\t\t\tprintk(KERN_DEBUG \"%s(card %d): reread z2 because \"\n\t\t\t       \"%d!=%d\\n\", __func__, hc->id + 1, temp, z2);\n\t\tz2 = temp;  \n\t}\n\thc->chan[ch].Zfill = z1 - z2;\n\tif (hc->chan[ch].Zfill < 0)\n\t\thc->chan[ch].Zfill += hc->Zlen;\n\tZspace = z2 - z1;\n\tif (Zspace <= 0)\n\t\tZspace += hc->Zlen;\n\tZspace -= 4;  \n\t \n\tif (bch && test_bit(FLG_TRANSPARENT, &bch->Flags))\n\t\tZspace = Zspace - hc->Zlen + hc->max_trans;\n\tif (Zspace <= 0)  \n\t\treturn;\n\n\t \n\tif (!len) {\n\t\tif (z1 == z2) {  \n\t\t\t \n\t\t\tif (bch && (!test_bit(FLG_HDLC, &bch->Flags)) &&\n\t\t\t    *txpending && slot_tx >= 0) {\n\t\t\t\tif (debug & DEBUG_HFCMULTI_MODE)\n\t\t\t\t\tprintk(KERN_DEBUG\n\t\t\t\t\t       \"%s: reconnecting PCM due to no \"\n\t\t\t\t\t       \"more FIFO data: channel %d \"\n\t\t\t\t\t       \"slot_tx %d\\n\",\n\t\t\t\t\t       __func__, ch, slot_tx);\n\t\t\t\t \n\t\t\t\tif (hc->ctype == HFC_TYPE_XHFC)\n\t\t\t\t\tHFC_outb(hc, A_CON_HDLC, 0xc0\n\t\t\t\t\t\t | 0x07 << 2 | V_HDLC_TRP | V_IFF);\n\t\t\t\t \n\t\t\t\telse\n\t\t\t\t\tHFC_outb(hc, A_CON_HDLC, 0xc0 | 0x00 |\n\t\t\t\t\t\t V_HDLC_TRP | V_IFF);\n\t\t\t\tHFC_outb_nodebug(hc, R_FIFO, ch << 1 | 1);\n\t\t\t\tHFC_wait_nodebug(hc);\n\t\t\t\tif (hc->ctype == HFC_TYPE_XHFC)\n\t\t\t\t\tHFC_outb(hc, A_CON_HDLC, 0xc0\n\t\t\t\t\t\t | 0x07 << 2 | V_HDLC_TRP | V_IFF);\n\t\t\t\t \n\t\t\t\telse\n\t\t\t\t\tHFC_outb(hc, A_CON_HDLC, 0xc0 | 0x00 |\n\t\t\t\t\t\t V_HDLC_TRP | V_IFF);\n\t\t\t\tHFC_outb_nodebug(hc, R_FIFO, ch << 1);\n\t\t\t\tHFC_wait_nodebug(hc);\n\t\t\t}\n\t\t\t*txpending = 0;\n\t\t}\n\t\treturn;  \n\t}\n\n\t \n\tif (bch && test_bit(FLG_FILLEMPTY, &bch->Flags)\n\t    && !test_bit(FLG_HDLC, &bch->Flags) && z2 == z1) {\n\t\tif (debug & DEBUG_HFCMULTI_FILL)\n\t\t\tprintk(KERN_DEBUG \"%s: buffer empty, so we have \"\n\t\t\t       \"underrun\\n\", __func__);\n\t\t \n\t\thc->write_fifo(hc, hc->silence_data, poll >> 1);\n\t\tZspace -= (poll >> 1);\n\t}\n\n\t \n\tif (bch && (!test_bit(FLG_HDLC, &bch->Flags)) && (!*txpending)\n\t    && slot_tx >= 0) {\n\t\tif (debug & DEBUG_HFCMULTI_MODE)\n\t\t\tprintk(KERN_DEBUG \"%s: disconnecting PCM due to \"\n\t\t\t       \"FIFO data: channel %d slot_tx %d\\n\",\n\t\t\t       __func__, ch, slot_tx);\n\t\t \n\t\tif (hc->ctype == HFC_TYPE_XHFC)\n\t\t\tHFC_outb(hc, A_CON_HDLC, 0x80\n\t\t\t\t | 0x07 << 2 | V_HDLC_TRP | V_IFF);\n\t\t \n\t\telse\n\t\t\tHFC_outb(hc, A_CON_HDLC, 0x80 | 0x00 |\n\t\t\t\t V_HDLC_TRP | V_IFF);\n\t\tHFC_outb_nodebug(hc, R_FIFO, ch << 1 | 1);\n\t\tHFC_wait_nodebug(hc);\n\t\tif (hc->ctype == HFC_TYPE_XHFC)\n\t\t\tHFC_outb(hc, A_CON_HDLC, 0x80\n\t\t\t\t | 0x07 << 2 | V_HDLC_TRP | V_IFF);\n\t\t \n\t\telse\n\t\t\tHFC_outb(hc, A_CON_HDLC, 0x80 | 0x00 |\n\t\t\t\t V_HDLC_TRP | V_IFF);\n\t\tHFC_outb_nodebug(hc, R_FIFO, ch << 1);\n\t\tHFC_wait_nodebug(hc);\n\t}\n\t*txpending = 1;\n\n\t \n\tif (dch)\n\t\thc->activity_tx |= 1 << hc->chan[ch].port;\n\n\t \n\tii = len;\n\tif (dch || test_bit(FLG_HDLC, &bch->Flags))\n\t\ttemp = 1;\n\telse\n\t\ttemp = 0;\n\ti = *idxp;\n\td = (*sp)->data + i;\n\tif (ii - i > Zspace)\n\t\tii = Zspace + i;\n\tif (debug & DEBUG_HFCMULTI_FIFO)\n\t\tprintk(KERN_DEBUG \"%s(card %d): fifo(%d) has %d bytes space \"\n\t\t       \"left (z1=%04x, z2=%04x) sending %d of %d bytes %s\\n\",\n\t\t       __func__, hc->id + 1, ch, Zspace, z1, z2, ii-i, len-i,\n\t\t       temp ? \"HDLC\" : \"TRANS\");\n\n\t \n\thc->write_fifo(hc, d, ii - i);\n\thc->chan[ch].Zfill += ii - i;\n\t*idxp = ii;\n\n\t \n\tif (ii != len) {\n\t\t \n\t\treturn;\n\t}\n\n\t \n\tif (dch || test_bit(FLG_HDLC, &bch->Flags)) {\n\t\t \n\t\tHFC_outb_nodebug(hc, R_INC_RES_FIFO, V_INC_F);\n\t\tHFC_wait_nodebug(hc);\n\t}\n\n\tdev_kfree_skb(*sp);\n\t \n\tif (bch && get_next_bframe(bch)) {\n\t\tlen = (*sp)->len;\n\t\tgoto next_frame;\n\t}\n\tif (dch && get_next_dframe(dch)) {\n\t\tlen = (*sp)->len;\n\t\tgoto next_frame;\n\t}\n\n\t \n\tif (bch && test_bit(FLG_TRANSPARENT, &bch->Flags))\n\t\tHFC_outb_nodebug(hc, A_FIFO_DATA0_NOINC, hc->silence);\n}\n\n\n \nstatic void\nhfcmulti_rx(struct hfc_multi *hc, int ch)\n{\n\tint temp;\n\tint Zsize, z1, z2 = 0;  \n\tint f1 = 0, f2 = 0;  \n\tint again = 0;\n\tstruct\tbchannel *bch;\n\tstruct  dchannel *dch = NULL;\n\tstruct sk_buff\t*skb, **sp = NULL;\n\tint\tmaxlen;\n\n\tbch = hc->chan[ch].bch;\n\tif (bch) {\n\t\tif (!test_bit(FLG_ACTIVE, &bch->Flags))\n\t\t\treturn;\n\t} else if (hc->chan[ch].dch) {\n\t\tdch = hc->chan[ch].dch;\n\t\tif (!test_bit(FLG_ACTIVE, &dch->Flags))\n\t\t\treturn;\n\t} else {\n\t\treturn;\n\t}\nnext_frame:\n\t \n\tif (test_bit(HFC_CHIP_B410P, &hc->chip) &&\n\t    (hc->chan[ch].protocol == ISDN_P_B_RAW) &&\n\t    (hc->chan[ch].slot_rx < 0) &&\n\t    (hc->chan[ch].slot_tx < 0))\n\t\tHFC_outb_nodebug(hc, R_FIFO, 0x20 | (ch << 1) | 1);\n\telse\n\t\tHFC_outb_nodebug(hc, R_FIFO, (ch << 1) | 1);\n\tHFC_wait_nodebug(hc);\n\n\t \n\tif (hc->chan[ch].rx_off) {\n\t\tif (bch)\n\t\t\tbch->dropcnt += poll;  \n\t\treturn;\n\t}\n\n\tif (dch || test_bit(FLG_HDLC, &bch->Flags)) {\n\t\tf1 = HFC_inb_nodebug(hc, A_F1);\n\t\twhile (f1 != (temp = HFC_inb_nodebug(hc, A_F1))) {\n\t\t\tif (debug & DEBUG_HFCMULTI_FIFO)\n\t\t\t\tprintk(KERN_DEBUG\n\t\t\t\t       \"%s(card %d): reread f1 because %d!=%d\\n\",\n\t\t\t\t       __func__, hc->id + 1, temp, f1);\n\t\t\tf1 = temp;  \n\t\t}\n\t\tf2 = HFC_inb_nodebug(hc, A_F2);\n\t}\n\tz1 = HFC_inw_nodebug(hc, A_Z1) - hc->Zmin;\n\twhile (z1 != (temp = (HFC_inw_nodebug(hc, A_Z1) - hc->Zmin))) {\n\t\tif (debug & DEBUG_HFCMULTI_FIFO)\n\t\t\tprintk(KERN_DEBUG \"%s(card %d): reread z2 because \"\n\t\t\t       \"%d!=%d\\n\", __func__, hc->id + 1, temp, z2);\n\t\tz1 = temp;  \n\t}\n\tz2 = HFC_inw_nodebug(hc, A_Z2) - hc->Zmin;\n\tZsize = z1 - z2;\n\tif ((dch || test_bit(FLG_HDLC, &bch->Flags)) && f1 != f2)\n\t\t \n\t\tZsize++;\n\tif (Zsize < 0)\n\t\tZsize += hc->Zlen;\n\t \n\tif (Zsize <= 0)\n\t\treturn;\n\n\tif (bch) {\n\t\tmaxlen = bchannel_get_rxbuf(bch, Zsize);\n\t\tif (maxlen < 0) {\n\t\t\tpr_warn(\"card%d.B%d: No bufferspace for %d bytes\\n\",\n\t\t\t\thc->id + 1, bch->nr, Zsize);\n\t\t\treturn;\n\t\t}\n\t\tsp = &bch->rx_skb;\n\t\tmaxlen = bch->maxlen;\n\t} else {  \n\t\tsp = &dch->rx_skb;\n\t\tmaxlen = dch->maxlen + 3;\n\t\tif (*sp == NULL) {\n\t\t\t*sp = mI_alloc_skb(maxlen, GFP_ATOMIC);\n\t\t\tif (*sp == NULL) {\n\t\t\t\tpr_warn(\"card%d: No mem for dch rx_skb\\n\",\n\t\t\t\t\thc->id + 1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\t \n\tif (dch)\n\t\thc->activity_rx |= 1 << hc->chan[ch].port;\n\n\t \n\tif (dch || test_bit(FLG_HDLC, &bch->Flags)) {\n\t\tif (debug & DEBUG_HFCMULTI_FIFO)\n\t\t\tprintk(KERN_DEBUG \"%s(card %d): fifo(%d) reading %d \"\n\t\t\t       \"bytes (z1=%04x, z2=%04x) HDLC %s (f1=%d, f2=%d) \"\n\t\t\t       \"got=%d (again %d)\\n\", __func__, hc->id + 1, ch,\n\t\t\t       Zsize, z1, z2, (f1 == f2) ? \"fragment\" : \"COMPLETE\",\n\t\t\t       f1, f2, Zsize + (*sp)->len, again);\n\t\t \n\t\tif ((Zsize + (*sp)->len) > maxlen) {\n\t\t\tif (debug & DEBUG_HFCMULTI_FIFO)\n\t\t\t\tprintk(KERN_DEBUG\n\t\t\t\t       \"%s(card %d): hdlc-frame too large.\\n\",\n\t\t\t\t       __func__, hc->id + 1);\n\t\t\tskb_trim(*sp, 0);\n\t\t\tHFC_outb_nodebug(hc, R_INC_RES_FIFO, V_RES_F);\n\t\t\tHFC_wait_nodebug(hc);\n\t\t\treturn;\n\t\t}\n\n\t\thc->read_fifo(hc, skb_put(*sp, Zsize), Zsize);\n\n\t\tif (f1 != f2) {\n\t\t\t \n\t\t\tHFC_outb_nodebug(hc, R_INC_RES_FIFO, V_INC_F);\n\t\t\tHFC_wait_nodebug(hc);\n\t\t\t \n\t\t\tif ((*sp)->len < 4) {\n\t\t\t\tif (debug & DEBUG_HFCMULTI_FIFO)\n\t\t\t\t\tprintk(KERN_DEBUG\n\t\t\t\t\t       \"%s(card %d): Frame below minimum \"\n\t\t\t\t\t       \"size\\n\", __func__, hc->id + 1);\n\t\t\t\tskb_trim(*sp, 0);\n\t\t\t\tgoto next_frame;\n\t\t\t}\n\t\t\t \n\t\t\tif ((*sp)->data[(*sp)->len - 1]) {\n\t\t\t\tif (debug & DEBUG_HFCMULTI_CRC)\n\t\t\t\t\tprintk(KERN_DEBUG\n\t\t\t\t\t       \"%s: CRC-error\\n\", __func__);\n\t\t\t\tskb_trim(*sp, 0);\n\t\t\t\tgoto next_frame;\n\t\t\t}\n\t\t\tskb_trim(*sp, (*sp)->len - 3);\n\t\t\tif ((*sp)->len < MISDN_COPY_SIZE) {\n\t\t\t\tskb = *sp;\n\t\t\t\t*sp = mI_alloc_skb(skb->len, GFP_ATOMIC);\n\t\t\t\tif (*sp) {\n\t\t\t\t\tskb_put_data(*sp, skb->data, skb->len);\n\t\t\t\t\tskb_trim(skb, 0);\n\t\t\t\t} else {\n\t\t\t\t\tprintk(KERN_DEBUG \"%s: No mem\\n\",\n\t\t\t\t\t       __func__);\n\t\t\t\t\t*sp = skb;\n\t\t\t\t\tskb = NULL;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tskb = NULL;\n\t\t\t}\n\t\t\tif (debug & DEBUG_HFCMULTI_FIFO) {\n\t\t\t\tprintk(KERN_DEBUG \"%s(card %d):\",\n\t\t\t\t       __func__, hc->id + 1);\n\t\t\t\ttemp = 0;\n\t\t\t\twhile (temp < (*sp)->len)\n\t\t\t\t\tprintk(\" %02x\", (*sp)->data[temp++]);\n\t\t\t\tprintk(\"\\n\");\n\t\t\t}\n\t\t\tif (dch)\n\t\t\t\trecv_Dchannel(dch);\n\t\t\telse\n\t\t\t\trecv_Bchannel(bch, MISDN_ID_ANY, false);\n\t\t\t*sp = skb;\n\t\t\tagain++;\n\t\t\tgoto next_frame;\n\t\t}\n\t\t \n\t} else {\n\t\t \n\t\thc->read_fifo(hc, skb_put(*sp, Zsize), Zsize);\n\t\tif (debug & DEBUG_HFCMULTI_FIFO)\n\t\t\tprintk(KERN_DEBUG\n\t\t\t       \"%s(card %d): fifo(%d) reading %d bytes \"\n\t\t\t       \"(z1=%04x, z2=%04x) TRANS\\n\",\n\t\t\t       __func__, hc->id + 1, ch, Zsize, z1, z2);\n\t\t \n\t\trecv_Bchannel(bch, hc->chan[ch].Zfill, false);\n\t}\n}\n\n\n \nstatic void\nsignal_state_up(struct dchannel *dch, int info, char *msg)\n{\n\tstruct sk_buff\t*skb;\n\tint\t\tid, data = info;\n\n\tif (debug & DEBUG_HFCMULTI_STATE)\n\t\tprintk(KERN_DEBUG \"%s: %s\\n\", __func__, msg);\n\n\tid = TEI_SAPI | (GROUP_TEI << 8);  \n\n\tskb = _alloc_mISDN_skb(MPH_INFORMATION_IND, id, sizeof(data), &data,\n\t\t\t       GFP_ATOMIC);\n\tif (!skb)\n\t\treturn;\n\trecv_Dchannel_skb(dch, skb);\n}\n\nstatic inline void\nhandle_timer_irq(struct hfc_multi *hc)\n{\n\tint\t\tch, temp;\n\tstruct dchannel\t*dch;\n\tu_long\t\tflags;\n\n\t \n\tif (hc->e1_resync) {\n\t\t \n\t\tspin_lock_irqsave(&HFClock, flags);\n\t\tif (hc->e1_resync & 1) {\n\t\t\tif (debug & DEBUG_HFCMULTI_PLXSD)\n\t\t\t\tprintk(KERN_DEBUG \"Enable SYNC_I\\n\");\n\t\t\tHFC_outb(hc, R_SYNC_CTRL, V_EXT_CLK_SYNC);\n\t\t\t \n\t\t\tif (test_bit(HFC_CHIP_RX_SYNC, &hc->chip))\n\t\t\t\tHFC_outb(hc, R_SYNC_OUT, V_SYNC_E1_RX);\n\t\t}\n\t\tif (hc->e1_resync & 2) {\n\t\t\tif (debug & DEBUG_HFCMULTI_PLXSD)\n\t\t\t\tprintk(KERN_DEBUG \"Enable jatt PLL\\n\");\n\t\t\tHFC_outb(hc, R_SYNC_CTRL, V_SYNC_OFFS);\n\t\t}\n\t\tif (hc->e1_resync & 4) {\n\t\t\tif (debug & DEBUG_HFCMULTI_PLXSD)\n\t\t\t\tprintk(KERN_DEBUG\n\t\t\t\t       \"Enable QUARTZ for HFC-E1\\n\");\n\t\t\t \n\t\t\tHFC_outb(hc, R_SYNC_CTRL, V_EXT_CLK_SYNC\n\t\t\t\t | V_JATT_OFF);\n\t\t\t \n\t\t\tHFC_outb(hc, R_SYNC_OUT, 0);\n\t\t}\n\t\thc->e1_resync = 0;\n\t\tspin_unlock_irqrestore(&HFClock, flags);\n\t}\n\n\tif (hc->ctype != HFC_TYPE_E1 || hc->e1_state == 1)\n\t\tfor (ch = 0; ch <= 31; ch++) {\n\t\t\tif (hc->created[hc->chan[ch].port]) {\n\t\t\t\thfcmulti_tx(hc, ch);\n\t\t\t\t \n\t\t\t\thfcmulti_rx(hc, ch);\n\t\t\t\tif (hc->chan[ch].dch &&\n\t\t\t\t    hc->chan[ch].nt_timer > -1) {\n\t\t\t\t\tdch = hc->chan[ch].dch;\n\t\t\t\t\tif (!(--hc->chan[ch].nt_timer)) {\n\t\t\t\t\t\tschedule_event(dch,\n\t\t\t\t\t\t\t       FLG_PHCHANGE);\n\t\t\t\t\t\tif (debug &\n\t\t\t\t\t\t    DEBUG_HFCMULTI_STATE)\n\t\t\t\t\t\t\tprintk(KERN_DEBUG\n\t\t\t\t\t\t\t       \"%s: nt_timer at \"\n\t\t\t\t\t\t\t       \"state %x\\n\",\n\t\t\t\t\t\t\t       __func__,\n\t\t\t\t\t\t\t       dch->state);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tif (hc->ctype == HFC_TYPE_E1 && hc->created[0]) {\n\t\tdch = hc->chan[hc->dnum[0]].dch;\n\t\t \n\t\ttemp = HFC_inb_nodebug(hc, R_SYNC_STA) & V_SIG_LOS;\n\t\thc->chan[hc->dnum[0]].los = temp;\n\t\tif (test_bit(HFC_CFG_REPORT_LOS, &hc->chan[hc->dnum[0]].cfg)) {\n\t\t\tif (!temp && hc->chan[hc->dnum[0]].los)\n\t\t\t\tsignal_state_up(dch, L1_SIGNAL_LOS_ON,\n\t\t\t\t\t\t\"LOS detected\");\n\t\t\tif (temp && !hc->chan[hc->dnum[0]].los)\n\t\t\t\tsignal_state_up(dch, L1_SIGNAL_LOS_OFF,\n\t\t\t\t\t\t\"LOS gone\");\n\t\t}\n\t\tif (test_bit(HFC_CFG_REPORT_AIS, &hc->chan[hc->dnum[0]].cfg)) {\n\t\t\t \n\t\t\ttemp = HFC_inb_nodebug(hc, R_SYNC_STA) & V_AIS;\n\t\t\tif (!temp && hc->chan[hc->dnum[0]].ais)\n\t\t\t\tsignal_state_up(dch, L1_SIGNAL_AIS_ON,\n\t\t\t\t\t\t\"AIS detected\");\n\t\t\tif (temp && !hc->chan[hc->dnum[0]].ais)\n\t\t\t\tsignal_state_up(dch, L1_SIGNAL_AIS_OFF,\n\t\t\t\t\t\t\"AIS gone\");\n\t\t\thc->chan[hc->dnum[0]].ais = temp;\n\t\t}\n\t\tif (test_bit(HFC_CFG_REPORT_SLIP, &hc->chan[hc->dnum[0]].cfg)) {\n\t\t\t \n\t\t\ttemp = HFC_inb_nodebug(hc, R_SLIP) & V_FOSLIP_RX;\n\t\t\tif (!temp && hc->chan[hc->dnum[0]].slip_rx)\n\t\t\t\tsignal_state_up(dch, L1_SIGNAL_SLIP_RX,\n\t\t\t\t\t\t\" bit SLIP detected RX\");\n\t\t\thc->chan[hc->dnum[0]].slip_rx = temp;\n\t\t\ttemp = HFC_inb_nodebug(hc, R_SLIP) & V_FOSLIP_TX;\n\t\t\tif (!temp && hc->chan[hc->dnum[0]].slip_tx)\n\t\t\t\tsignal_state_up(dch, L1_SIGNAL_SLIP_TX,\n\t\t\t\t\t\t\" bit SLIP detected TX\");\n\t\t\thc->chan[hc->dnum[0]].slip_tx = temp;\n\t\t}\n\t\tif (test_bit(HFC_CFG_REPORT_RDI, &hc->chan[hc->dnum[0]].cfg)) {\n\t\t\t \n\t\t\ttemp = HFC_inb_nodebug(hc, R_RX_SL0_0) & V_A;\n\t\t\tif (!temp && hc->chan[hc->dnum[0]].rdi)\n\t\t\t\tsignal_state_up(dch, L1_SIGNAL_RDI_ON,\n\t\t\t\t\t\t\"RDI detected\");\n\t\t\tif (temp && !hc->chan[hc->dnum[0]].rdi)\n\t\t\t\tsignal_state_up(dch, L1_SIGNAL_RDI_OFF,\n\t\t\t\t\t\t\"RDI gone\");\n\t\t\thc->chan[hc->dnum[0]].rdi = temp;\n\t\t}\n\t\ttemp = HFC_inb_nodebug(hc, R_JATT_DIR);\n\t\tswitch (hc->chan[hc->dnum[0]].sync) {\n\t\tcase 0:\n\t\t\tif ((temp & 0x60) == 0x60) {\n\t\t\t\tif (debug & DEBUG_HFCMULTI_SYNC)\n\t\t\t\t\tprintk(KERN_DEBUG\n\t\t\t\t\t       \"%s: (id=%d) E1 now \"\n\t\t\t\t\t       \"in clock sync\\n\",\n\t\t\t\t\t       __func__, hc->id);\n\t\t\t\tHFC_outb(hc, R_RX_OFF,\n\t\t\t\t    hc->chan[hc->dnum[0]].jitter | V_RX_INIT);\n\t\t\t\tHFC_outb(hc, R_TX_OFF,\n\t\t\t\t    hc->chan[hc->dnum[0]].jitter | V_RX_INIT);\n\t\t\t\thc->chan[hc->dnum[0]].sync = 1;\n\t\t\t\tgoto check_framesync;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif ((temp & 0x60) != 0x60) {\n\t\t\t\tif (debug & DEBUG_HFCMULTI_SYNC)\n\t\t\t\t\tprintk(KERN_DEBUG\n\t\t\t\t\t       \"%s: (id=%d) E1 \"\n\t\t\t\t\t       \"lost clock sync\\n\",\n\t\t\t\t\t       __func__, hc->id);\n\t\t\t\thc->chan[hc->dnum[0]].sync = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tcheck_framesync:\n\t\t\ttemp = HFC_inb_nodebug(hc, R_SYNC_STA);\n\t\t\tif (temp == 0x27) {\n\t\t\t\tif (debug & DEBUG_HFCMULTI_SYNC)\n\t\t\t\t\tprintk(KERN_DEBUG\n\t\t\t\t\t       \"%s: (id=%d) E1 \"\n\t\t\t\t\t       \"now in frame sync\\n\",\n\t\t\t\t\t       __func__, hc->id);\n\t\t\t\thc->chan[hc->dnum[0]].sync = 2;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tif ((temp & 0x60) != 0x60) {\n\t\t\t\tif (debug & DEBUG_HFCMULTI_SYNC)\n\t\t\t\t\tprintk(KERN_DEBUG\n\t\t\t\t\t       \"%s: (id=%d) E1 lost \"\n\t\t\t\t\t       \"clock & frame sync\\n\",\n\t\t\t\t\t       __func__, hc->id);\n\t\t\t\thc->chan[hc->dnum[0]].sync = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttemp = HFC_inb_nodebug(hc, R_SYNC_STA);\n\t\t\tif (temp != 0x27) {\n\t\t\t\tif (debug & DEBUG_HFCMULTI_SYNC)\n\t\t\t\t\tprintk(KERN_DEBUG\n\t\t\t\t\t       \"%s: (id=%d) E1 \"\n\t\t\t\t\t       \"lost frame sync\\n\",\n\t\t\t\t\t       __func__, hc->id);\n\t\t\t\thc->chan[hc->dnum[0]].sync = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (test_bit(HFC_CHIP_WATCHDOG, &hc->chip))\n\t\thfcmulti_watchdog(hc);\n\n\tif (hc->leds)\n\t\thfcmulti_leds(hc);\n}\n\nstatic void\nph_state_irq(struct hfc_multi *hc, u_char r_irq_statech)\n{\n\tstruct dchannel\t*dch;\n\tint\t\tch;\n\tint\t\tactive;\n\tu_char\t\tst_status, temp;\n\n\t \n\tfor (ch = 0; ch <= 31; ch++) {\n\t\tif (hc->chan[ch].dch) {\n\t\t\tdch = hc->chan[ch].dch;\n\t\t\tif (r_irq_statech & 1) {\n\t\t\t\tHFC_outb_nodebug(hc, R_ST_SEL,\n\t\t\t\t\t\t hc->chan[ch].port);\n\t\t\t\t \n\t\t\t\tudelay(1);\n\t\t\t\t \n\t\t\t\tst_status = HFC_inb_nodebug(hc, A_ST_RD_STATE);\n\t\t\t\twhile (st_status != (temp =\n\t\t\t\t\t\t     HFC_inb_nodebug(hc, A_ST_RD_STATE))) {\n\t\t\t\t\tif (debug & DEBUG_HFCMULTI_STATE)\n\t\t\t\t\t\tprintk(KERN_DEBUG \"%s: reread \"\n\t\t\t\t\t\t       \"STATE because %d!=%d\\n\",\n\t\t\t\t\t\t       __func__, temp,\n\t\t\t\t\t\t       st_status);\n\t\t\t\t\tst_status = temp;  \n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tif (test_bit(HFC_CHIP_PLXSD, &hc->chip) &&\n\t\t\t\t    dch->dev.D.protocol == ISDN_P_TE_S0) {\n\t\t\t\t\tif (st_status & V_FR_SYNC_ST)\n\t\t\t\t\t\thc->syncronized |=\n\t\t\t\t\t\t\t(1 << hc->chan[ch].port);\n\t\t\t\t\telse\n\t\t\t\t\t\thc->syncronized &=\n\t\t\t\t\t\t\t~(1 << hc->chan[ch].port);\n\t\t\t\t}\n\t\t\t\tdch->state = st_status & 0x0f;\n\t\t\t\tif (dch->dev.D.protocol == ISDN_P_NT_S0)\n\t\t\t\t\tactive = 3;\n\t\t\t\telse\n\t\t\t\t\tactive = 7;\n\t\t\t\tif (dch->state == active) {\n\t\t\t\t\tHFC_outb_nodebug(hc, R_FIFO,\n\t\t\t\t\t\t\t (ch << 1) | 1);\n\t\t\t\t\tHFC_wait_nodebug(hc);\n\t\t\t\t\tHFC_outb_nodebug(hc,\n\t\t\t\t\t\t\t R_INC_RES_FIFO, V_RES_F);\n\t\t\t\t\tHFC_wait_nodebug(hc);\n\t\t\t\t\tdch->tx_idx = 0;\n\t\t\t\t}\n\t\t\t\tschedule_event(dch, FLG_PHCHANGE);\n\t\t\t\tif (debug & DEBUG_HFCMULTI_STATE)\n\t\t\t\t\tprintk(KERN_DEBUG\n\t\t\t\t\t       \"%s: S/T newstate %x port %d\\n\",\n\t\t\t\t\t       __func__, dch->state,\n\t\t\t\t\t       hc->chan[ch].port);\n\t\t\t}\n\t\t\tr_irq_statech >>= 1;\n\t\t}\n\t}\n\tif (test_bit(HFC_CHIP_PLXSD, &hc->chip))\n\t\tplxsd_checksync(hc, 0);\n}\n\nstatic void\nfifo_irq(struct hfc_multi *hc, int block)\n{\n\tint\tch, j;\n\tstruct dchannel\t*dch;\n\tstruct bchannel\t*bch;\n\tu_char r_irq_fifo_bl;\n\n\tr_irq_fifo_bl = HFC_inb_nodebug(hc, R_IRQ_FIFO_BL0 + block);\n\tj = 0;\n\twhile (j < 8) {\n\t\tch = (block << 2) + (j >> 1);\n\t\tdch = hc->chan[ch].dch;\n\t\tbch = hc->chan[ch].bch;\n\t\tif (((!dch) && (!bch)) || (!hc->created[hc->chan[ch].port])) {\n\t\t\tj += 2;\n\t\t\tcontinue;\n\t\t}\n\t\tif (dch && (r_irq_fifo_bl & (1 << j)) &&\n\t\t    test_bit(FLG_ACTIVE, &dch->Flags)) {\n\t\t\thfcmulti_tx(hc, ch);\n\t\t\t \n\t\t\tHFC_outb_nodebug(hc, R_FIFO, 0);\n\t\t\tHFC_wait_nodebug(hc);\n\t\t}\n\t\tif (bch && (r_irq_fifo_bl & (1 << j)) &&\n\t\t    test_bit(FLG_ACTIVE, &bch->Flags)) {\n\t\t\thfcmulti_tx(hc, ch);\n\t\t\t \n\t\t\tHFC_outb_nodebug(hc, R_FIFO, 0);\n\t\t\tHFC_wait_nodebug(hc);\n\t\t}\n\t\tj++;\n\t\tif (dch && (r_irq_fifo_bl & (1 << j)) &&\n\t\t    test_bit(FLG_ACTIVE, &dch->Flags)) {\n\t\t\thfcmulti_rx(hc, ch);\n\t\t}\n\t\tif (bch && (r_irq_fifo_bl & (1 << j)) &&\n\t\t    test_bit(FLG_ACTIVE, &bch->Flags)) {\n\t\t\thfcmulti_rx(hc, ch);\n\t\t}\n\t\tj++;\n\t}\n}\n\n#ifdef IRQ_DEBUG\nint irqsem;\n#endif\nstatic irqreturn_t\nhfcmulti_interrupt(int intno, void *dev_id)\n{\n#ifdef IRQCOUNT_DEBUG\n\tstatic int iq1 = 0, iq2 = 0, iq3 = 0, iq4 = 0,\n\t\tiq5 = 0, iq6 = 0, iqcnt = 0;\n#endif\n\tstruct hfc_multi\t*hc = dev_id;\n\tstruct dchannel\t\t*dch;\n\tu_char\t\t\tr_irq_statech, status, r_irq_misc, r_irq_oview;\n\tint\t\t\ti;\n\tvoid __iomem\t\t*plx_acc;\n\tu_short\t\t\twval;\n\tu_char\t\t\te1_syncsta, temp, temp2;\n\tu_long\t\t\tflags;\n\n\tif (!hc) {\n\t\tprintk(KERN_ERR \"HFC-multi: Spurious interrupt!\\n\");\n\t\treturn IRQ_NONE;\n\t}\n\n\tspin_lock(&hc->lock);\n\n#ifdef IRQ_DEBUG\n\tif (irqsem)\n\t\tprintk(KERN_ERR \"irq for card %d during irq from \"\n\t\t       \"card %d, this is no bug.\\n\", hc->id + 1, irqsem);\n\tirqsem = hc->id + 1;\n#endif\n#ifdef CONFIG_MISDN_HFCMULTI_8xx\n\tif (hc->immap->im_cpm.cp_pbdat & hc->pb_irqmsk)\n\t\tgoto irq_notforus;\n#endif\n\tif (test_bit(HFC_CHIP_PLXSD, &hc->chip)) {\n\t\tspin_lock_irqsave(&plx_lock, flags);\n\t\tplx_acc = hc->plx_membase + PLX_INTCSR;\n\t\twval = readw(plx_acc);\n\t\tspin_unlock_irqrestore(&plx_lock, flags);\n\t\tif (!(wval & PLX_INTCSR_LINTI1_STATUS))\n\t\t\tgoto irq_notforus;\n\t}\n\n\tstatus = HFC_inb_nodebug(hc, R_STATUS);\n\tr_irq_statech = HFC_inb_nodebug(hc, R_IRQ_STATECH);\n#ifdef IRQCOUNT_DEBUG\n\tif (r_irq_statech)\n\t\tiq1++;\n\tif (status & V_DTMF_STA)\n\t\tiq2++;\n\tif (status & V_LOST_STA)\n\t\tiq3++;\n\tif (status & V_EXT_IRQSTA)\n\t\tiq4++;\n\tif (status & V_MISC_IRQSTA)\n\t\tiq5++;\n\tif (status & V_FR_IRQSTA)\n\t\tiq6++;\n\tif (iqcnt++ > 5000) {\n\t\tprintk(KERN_ERR \"iq1:%x iq2:%x iq3:%x iq4:%x iq5:%x iq6:%x\\n\",\n\t\t       iq1, iq2, iq3, iq4, iq5, iq6);\n\t\tiqcnt = 0;\n\t}\n#endif\n\n\tif (!r_irq_statech &&\n\t    !(status & (V_DTMF_STA | V_LOST_STA | V_EXT_IRQSTA |\n\t\t\tV_MISC_IRQSTA | V_FR_IRQSTA))) {\n\t\t \n\t\tgoto irq_notforus;\n\t}\n\thc->irqcnt++;\n\tif (r_irq_statech) {\n\t\tif (hc->ctype != HFC_TYPE_E1)\n\t\t\tph_state_irq(hc, r_irq_statech);\n\t}\n\tif (status & V_LOST_STA) {\n\t\t \n\t\tHFC_outb(hc, R_INC_RES_FIFO, V_RES_LOST);  \n\t}\n\tif (status & V_MISC_IRQSTA) {\n\t\t \n\t\tr_irq_misc = HFC_inb_nodebug(hc, R_IRQ_MISC);\n\t\tr_irq_misc &= hc->hw.r_irqmsk_misc;  \n\t\tif (r_irq_misc & V_STA_IRQ) {\n\t\t\tif (hc->ctype == HFC_TYPE_E1) {\n\t\t\t\t \n\t\t\t\tdch = hc->chan[hc->dnum[0]].dch;\n\t\t\t\te1_syncsta = HFC_inb_nodebug(hc, R_SYNC_STA);\n\t\t\t\tif (test_bit(HFC_CHIP_PLXSD, &hc->chip)\n\t\t\t\t    && hc->e1_getclock) {\n\t\t\t\t\tif (e1_syncsta & V_FR_SYNC_E1)\n\t\t\t\t\t\thc->syncronized = 1;\n\t\t\t\t\telse\n\t\t\t\t\t\thc->syncronized = 0;\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\ttemp = HFC_inb_nodebug(hc, R_E1_RD_STA);\n\t\t\t\twhile (temp != (temp2 =\n\t\t\t\t\t\t      HFC_inb_nodebug(hc, R_E1_RD_STA))) {\n\t\t\t\t\tif (debug & DEBUG_HFCMULTI_STATE)\n\t\t\t\t\t\tprintk(KERN_DEBUG \"%s: reread \"\n\t\t\t\t\t\t       \"STATE because %d!=%d\\n\",\n\t\t\t\t\t\t    __func__, temp, temp2);\n\t\t\t\t\ttemp = temp2;  \n\t\t\t\t}\n\t\t\t\t \n\t\t\t\tif (debug & DEBUG_HFCMULTI_STATE)\n\t\t\t\t\tprintk(KERN_DEBUG\n\t\t\t\t\t       \"%s: E1 (id=%d) newstate %x\\n\",\n\t\t\t\t\t    __func__, hc->id, temp & 0x7);\n\t\t\t\tfor (i = 0; i < hc->ports; i++) {\n\t\t\t\t\tdch = hc->chan[hc->dnum[i]].dch;\n\t\t\t\t\tdch->state = temp & 0x7;\n\t\t\t\t\tschedule_event(dch, FLG_PHCHANGE);\n\t\t\t\t}\n\n\t\t\t\tif (test_bit(HFC_CHIP_PLXSD, &hc->chip))\n\t\t\t\t\tplxsd_checksync(hc, 0);\n\t\t\t}\n\t\t}\n\t\tif (r_irq_misc & V_TI_IRQ) {\n\t\t\tif (hc->iclock_on)\n\t\t\t\tmISDN_clock_update(hc->iclock, poll, NULL);\n\t\t\thandle_timer_irq(hc);\n\t\t}\n\n\t\tif (r_irq_misc & V_DTMF_IRQ)\n\t\t\thfcmulti_dtmf(hc);\n\n\t\tif (r_irq_misc & V_IRQ_PROC) {\n\t\t\tstatic int irq_proc_cnt;\n\t\t\tif (!irq_proc_cnt++)\n\t\t\t\tprintk(KERN_DEBUG \"%s: got V_IRQ_PROC -\"\n\t\t\t\t       \" this should not happen\\n\", __func__);\n\t\t}\n\n\t}\n\tif (status & V_FR_IRQSTA) {\n\t\t \n\t\tr_irq_oview = HFC_inb_nodebug(hc, R_IRQ_OVIEW);\n\t\tfor (i = 0; i < 8; i++) {\n\t\t\tif (r_irq_oview & (1 << i))\n\t\t\t\tfifo_irq(hc, i);\n\t\t}\n\t}\n\n#ifdef IRQ_DEBUG\n\tirqsem = 0;\n#endif\n\tspin_unlock(&hc->lock);\n\treturn IRQ_HANDLED;\n\nirq_notforus:\n#ifdef IRQ_DEBUG\n\tirqsem = 0;\n#endif\n\tspin_unlock(&hc->lock);\n\treturn IRQ_NONE;\n}\n\n\n \n\nstatic void\nhfcmulti_dbusy_timer(struct timer_list *t)\n{\n}\n\n\n \nstatic int\nmode_hfcmulti(struct hfc_multi *hc, int ch, int protocol, int slot_tx,\n\t      int bank_tx, int slot_rx, int bank_rx)\n{\n\tint flow_tx = 0, flow_rx = 0, routing = 0;\n\tint oslot_tx, oslot_rx;\n\tint conf;\n\n\tif (ch < 0 || ch > 31)\n\t\treturn -EINVAL;\n\toslot_tx = hc->chan[ch].slot_tx;\n\toslot_rx = hc->chan[ch].slot_rx;\n\tconf = hc->chan[ch].conf;\n\n\tif (debug & DEBUG_HFCMULTI_MODE)\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s: card %d channel %d protocol %x slot old=%d new=%d \"\n\t\t       \"bank new=%d (TX) slot old=%d new=%d bank new=%d (RX)\\n\",\n\t\t       __func__, hc->id, ch, protocol, oslot_tx, slot_tx,\n\t\t       bank_tx, oslot_rx, slot_rx, bank_rx);\n\n\tif (oslot_tx >= 0 && slot_tx != oslot_tx) {\n\t\t \n\t\tif (debug & DEBUG_HFCMULTI_MODE)\n\t\t\tprintk(KERN_DEBUG \"%s: remove from slot %d (TX)\\n\",\n\t\t\t       __func__, oslot_tx);\n\t\tif (hc->slot_owner[oslot_tx << 1] == ch) {\n\t\t\tHFC_outb(hc, R_SLOT, oslot_tx << 1);\n\t\t\tHFC_outb(hc, A_SL_CFG, 0);\n\t\t\tif (hc->ctype != HFC_TYPE_XHFC)\n\t\t\t\tHFC_outb(hc, A_CONF, 0);\n\t\t\thc->slot_owner[oslot_tx << 1] = -1;\n\t\t} else {\n\t\t\tif (debug & DEBUG_HFCMULTI_MODE)\n\t\t\t\tprintk(KERN_DEBUG\n\t\t\t\t       \"%s: we are not owner of this tx slot \"\n\t\t\t\t       \"anymore, channel %d is.\\n\",\n\t\t\t\t       __func__, hc->slot_owner[oslot_tx << 1]);\n\t\t}\n\t}\n\n\tif (oslot_rx >= 0 && slot_rx != oslot_rx) {\n\t\t \n\t\tif (debug & DEBUG_HFCMULTI_MODE)\n\t\t\tprintk(KERN_DEBUG\n\t\t\t       \"%s: remove from slot %d (RX)\\n\",\n\t\t\t       __func__, oslot_rx);\n\t\tif (hc->slot_owner[(oslot_rx << 1) | 1] == ch) {\n\t\t\tHFC_outb(hc, R_SLOT, (oslot_rx << 1) | V_SL_DIR);\n\t\t\tHFC_outb(hc, A_SL_CFG, 0);\n\t\t\thc->slot_owner[(oslot_rx << 1) | 1] = -1;\n\t\t} else {\n\t\t\tif (debug & DEBUG_HFCMULTI_MODE)\n\t\t\t\tprintk(KERN_DEBUG\n\t\t\t\t       \"%s: we are not owner of this rx slot \"\n\t\t\t\t       \"anymore, channel %d is.\\n\",\n\t\t\t\t       __func__,\n\t\t\t\t       hc->slot_owner[(oslot_rx << 1) | 1]);\n\t\t}\n\t}\n\n\tif (slot_tx < 0) {\n\t\tflow_tx = 0x80;  \n\t\t \n\t\thc->chan[ch].slot_tx = -1;\n\t\thc->chan[ch].bank_tx = 0;\n\t} else {\n\t\t \n\t\tif (hc->chan[ch].txpending)\n\t\t\tflow_tx = 0x80;  \n\t\telse\n\t\t\tflow_tx = 0xc0;  \n\t\t \n\t\trouting = bank_tx ? 0xc0 : 0x80;\n\t\tif (conf >= 0 || bank_tx > 1)\n\t\t\trouting = 0x40;  \n\t\tif (debug & DEBUG_HFCMULTI_MODE)\n\t\t\tprintk(KERN_DEBUG \"%s: put channel %d to slot %d bank\"\n\t\t\t       \" %d flow %02x routing %02x conf %d (TX)\\n\",\n\t\t\t       __func__, ch, slot_tx, bank_tx,\n\t\t\t       flow_tx, routing, conf);\n\t\tHFC_outb(hc, R_SLOT, slot_tx << 1);\n\t\tHFC_outb(hc, A_SL_CFG, (ch << 1) | routing);\n\t\tif (hc->ctype != HFC_TYPE_XHFC)\n\t\t\tHFC_outb(hc, A_CONF,\n\t\t\t\t (conf < 0) ? 0 : (conf | V_CONF_SL));\n\t\thc->slot_owner[slot_tx << 1] = ch;\n\t\thc->chan[ch].slot_tx = slot_tx;\n\t\thc->chan[ch].bank_tx = bank_tx;\n\t}\n\tif (slot_rx < 0) {\n\t\t \n\t\tflow_rx = 0x80;  \n\t\thc->chan[ch].slot_rx = -1;\n\t\thc->chan[ch].bank_rx = 0;\n\t} else {\n\t\t \n\t\tif (hc->chan[ch].txpending)\n\t\t\tflow_rx = 0x80;  \n\t\telse\n\t\t\tflow_rx = 0xc0;  \n\t\t \n\t\trouting = bank_rx ? 0x80 : 0xc0;  \n\t\tif (conf >= 0 || bank_rx > 1)\n\t\t\trouting = 0x40;  \n\t\tif (debug & DEBUG_HFCMULTI_MODE)\n\t\t\tprintk(KERN_DEBUG \"%s: put channel %d to slot %d bank\"\n\t\t\t       \" %d flow %02x routing %02x conf %d (RX)\\n\",\n\t\t\t       __func__, ch, slot_rx, bank_rx,\n\t\t\t       flow_rx, routing, conf);\n\t\tHFC_outb(hc, R_SLOT, (slot_rx << 1) | V_SL_DIR);\n\t\tHFC_outb(hc, A_SL_CFG, (ch << 1) | V_CH_DIR | routing);\n\t\thc->slot_owner[(slot_rx << 1) | 1] = ch;\n\t\thc->chan[ch].slot_rx = slot_rx;\n\t\thc->chan[ch].bank_rx = bank_rx;\n\t}\n\n\tswitch (protocol) {\n\tcase (ISDN_P_NONE):\n\t\t \n\t\tHFC_outb(hc, R_FIFO, ch << 1);\n\t\tHFC_wait(hc);\n\t\tHFC_outb(hc, A_CON_HDLC, flow_tx | 0x00 | V_IFF);\n\t\tHFC_outb(hc, A_SUBCH_CFG, 0);\n\t\tHFC_outb(hc, A_IRQ_MSK, 0);\n\t\tHFC_outb(hc, R_INC_RES_FIFO, V_RES_F);\n\t\tHFC_wait(hc);\n\t\t \n\t\tHFC_outb(hc, R_FIFO, (ch << 1) | 1);\n\t\tHFC_wait(hc);\n\t\tHFC_outb(hc, A_CON_HDLC, flow_rx | 0x00);\n\t\tHFC_outb(hc, A_SUBCH_CFG, 0);\n\t\tHFC_outb(hc, A_IRQ_MSK, 0);\n\t\tHFC_outb(hc, R_INC_RES_FIFO, V_RES_F);\n\t\tHFC_wait(hc);\n\t\tif (hc->chan[ch].bch && hc->ctype != HFC_TYPE_E1) {\n\t\t\thc->hw.a_st_ctrl0[hc->chan[ch].port] &=\n\t\t\t\t((ch & 0x3) == 0) ? ~V_B1_EN : ~V_B2_EN;\n\t\t\tHFC_outb(hc, R_ST_SEL, hc->chan[ch].port);\n\t\t\t \n\t\t\tudelay(1);\n\t\t\tHFC_outb(hc, A_ST_CTRL0,\n\t\t\t\t hc->hw.a_st_ctrl0[hc->chan[ch].port]);\n\t\t}\n\t\tif (hc->chan[ch].bch) {\n\t\t\ttest_and_clear_bit(FLG_HDLC, &hc->chan[ch].bch->Flags);\n\t\t\ttest_and_clear_bit(FLG_TRANSPARENT,\n\t\t\t\t\t   &hc->chan[ch].bch->Flags);\n\t\t}\n\t\tbreak;\n\tcase (ISDN_P_B_RAW):  \n\n\t\tif (test_bit(HFC_CHIP_B410P, &hc->chip) &&\n\t\t    (hc->chan[ch].slot_rx < 0) &&\n\t\t    (hc->chan[ch].slot_tx < 0)) {\n\n\t\t\tprintk(KERN_DEBUG\n\t\t\t       \"Setting B-channel %d to echo cancelable \"\n\t\t\t       \"state on PCM slot %d\\n\", ch,\n\t\t\t       ((ch / 4) * 8) + ((ch % 4) * 4) + 1);\n\t\t\tprintk(KERN_DEBUG\n\t\t\t       \"Enabling pass through for channel\\n\");\n\t\t\tvpm_out(hc, ch, ((ch / 4) * 8) +\n\t\t\t\t((ch % 4) * 4) + 1, 0x01);\n\t\t\t \n\t\t\t \n\t\t\tHFC_outb(hc, R_FIFO, (ch << 1));\n\t\t\tHFC_wait(hc);\n\t\t\tHFC_outb(hc, A_CON_HDLC, 0xc0 | V_HDLC_TRP | V_IFF);\n\t\t\tHFC_outb(hc, R_SLOT, (((ch / 4) * 8) +\n\t\t\t\t\t      ((ch % 4) * 4) + 1) << 1);\n\t\t\tHFC_outb(hc, A_SL_CFG, 0x80 | (ch << 1));\n\n\t\t\t \n\t\t\tHFC_outb(hc, R_FIFO, 0x20 | (ch << 1) | 1);\n\t\t\tHFC_wait(hc);\n\t\t\tHFC_outb(hc, A_CON_HDLC, 0x20 | V_HDLC_TRP | V_IFF);\n\t\t\tHFC_outb(hc, A_SUBCH_CFG, 0);\n\t\t\tHFC_outb(hc, A_IRQ_MSK, 0);\n\t\t\tif (hc->chan[ch].protocol != protocol) {\n\t\t\t\tHFC_outb(hc, R_INC_RES_FIFO, V_RES_F);\n\t\t\t\tHFC_wait(hc);\n\t\t\t}\n\t\t\tHFC_outb(hc, R_SLOT, ((((ch / 4) * 8) +\n\t\t\t\t\t       ((ch % 4) * 4) + 1) << 1) | 1);\n\t\t\tHFC_outb(hc, A_SL_CFG, 0x80 | 0x20 | (ch << 1) | 1);\n\n\t\t\t \n\t\t\t \n\t\t\tHFC_outb(hc, R_FIFO, (ch << 1) | 1);\n\t\t\tHFC_wait(hc);\n\t\t\tHFC_outb(hc, A_CON_HDLC, 0xc0 | V_HDLC_TRP | V_IFF);\n\t\t\tHFC_outb(hc, R_SLOT, ((((ch / 4) * 8) +\n\t\t\t\t\t       ((ch % 4) * 4)) << 1) | 1);\n\t\t\tHFC_outb(hc, A_SL_CFG, 0x80 | 0x40 | (ch << 1) | 1);\n\n\t\t\t \n\t\t\tHFC_outb(hc, R_FIFO, 0x20 | (ch << 1));\n\t\t\tHFC_wait(hc);\n\t\t\tHFC_outb(hc, A_CON_HDLC, 0x20 | V_HDLC_TRP | V_IFF);\n\t\t\tHFC_outb(hc, A_SUBCH_CFG, 0);\n\t\t\tHFC_outb(hc, A_IRQ_MSK, 0);\n\t\t\tif (hc->chan[ch].protocol != protocol) {\n\t\t\t\tHFC_outb(hc, R_INC_RES_FIFO, V_RES_F);\n\t\t\t\tHFC_wait(hc);\n\t\t\t}\n\t\t\t \n\t\t\tHFC_outb_nodebug(hc, A_FIFO_DATA0_NOINC, hc->silence);\n\t\t\tHFC_outb(hc, R_SLOT, (((ch / 4) * 8) +\n\t\t\t\t\t      ((ch % 4) * 4)) << 1);\n\t\t\tHFC_outb(hc, A_SL_CFG, 0x80 | 0x20 | (ch << 1));\n\t\t} else {\n\t\t\t \n\t\t\tHFC_outb(hc, R_FIFO, ch << 1);\n\t\t\tHFC_wait(hc);\n\t\t\tif (hc->ctype == HFC_TYPE_XHFC)\n\t\t\t\tHFC_outb(hc, A_CON_HDLC, flow_tx | 0x07 << 2 |\n\t\t\t\t\t V_HDLC_TRP | V_IFF);\n\t\t\t \n\t\t\telse\n\t\t\t\tHFC_outb(hc, A_CON_HDLC, flow_tx | 0x00 |\n\t\t\t\t\t V_HDLC_TRP | V_IFF);\n\t\t\tHFC_outb(hc, A_SUBCH_CFG, 0);\n\t\t\tHFC_outb(hc, A_IRQ_MSK, 0);\n\t\t\tif (hc->chan[ch].protocol != protocol) {\n\t\t\t\tHFC_outb(hc, R_INC_RES_FIFO, V_RES_F);\n\t\t\t\tHFC_wait(hc);\n\t\t\t}\n\t\t\t \n\t\t\tHFC_outb_nodebug(hc, A_FIFO_DATA0_NOINC, hc->silence);\n\t\t\t \n\t\t\tHFC_outb(hc, R_FIFO, (ch << 1) | 1);\n\t\t\tHFC_wait(hc);\n\t\t\tif (hc->ctype == HFC_TYPE_XHFC)\n\t\t\t\tHFC_outb(hc, A_CON_HDLC, flow_rx | 0x07 << 2 |\n\t\t\t\t\t V_HDLC_TRP);\n\t\t\t \n\t\t\telse\n\t\t\t\tHFC_outb(hc, A_CON_HDLC, flow_rx | 0x00 |\n\t\t\t\t\t V_HDLC_TRP);\n\t\t\tHFC_outb(hc, A_SUBCH_CFG, 0);\n\t\t\tHFC_outb(hc, A_IRQ_MSK, 0);\n\t\t\tif (hc->chan[ch].protocol != protocol) {\n\t\t\t\tHFC_outb(hc, R_INC_RES_FIFO, V_RES_F);\n\t\t\t\tHFC_wait(hc);\n\t\t\t}\n\t\t}\n\t\tif (hc->ctype != HFC_TYPE_E1) {\n\t\t\thc->hw.a_st_ctrl0[hc->chan[ch].port] |=\n\t\t\t\t((ch & 0x3) == 0) ? V_B1_EN : V_B2_EN;\n\t\t\tHFC_outb(hc, R_ST_SEL, hc->chan[ch].port);\n\t\t\t \n\t\t\tudelay(1);\n\t\t\tHFC_outb(hc, A_ST_CTRL0,\n\t\t\t\t hc->hw.a_st_ctrl0[hc->chan[ch].port]);\n\t\t}\n\t\tif (hc->chan[ch].bch)\n\t\t\ttest_and_set_bit(FLG_TRANSPARENT,\n\t\t\t\t\t &hc->chan[ch].bch->Flags);\n\t\tbreak;\n\tcase (ISDN_P_B_HDLC):  \n\tcase (ISDN_P_TE_S0):  \n\tcase (ISDN_P_NT_S0):\n\tcase (ISDN_P_TE_E1):\n\tcase (ISDN_P_NT_E1):\n\t\t \n\t\tHFC_outb(hc, R_FIFO, ch << 1);\n\t\tHFC_wait(hc);\n\t\tif (hc->ctype == HFC_TYPE_E1 || hc->chan[ch].bch) {\n\t\t\t \n\t\t\tHFC_outb(hc, A_CON_HDLC, flow_tx | 0x04);\n\t\t\tHFC_outb(hc, A_SUBCH_CFG, 0);\n\t\t} else {\n\t\t\t \n\t\t\tHFC_outb(hc, A_CON_HDLC, flow_tx | 0x04 | V_IFF);\n\t\t\tHFC_outb(hc, A_SUBCH_CFG, 2);\n\t\t}\n\t\tHFC_outb(hc, A_IRQ_MSK, V_IRQ);\n\t\tHFC_outb(hc, R_INC_RES_FIFO, V_RES_F);\n\t\tHFC_wait(hc);\n\t\t \n\t\tHFC_outb(hc, R_FIFO, (ch << 1) | 1);\n\t\tHFC_wait(hc);\n\t\tHFC_outb(hc, A_CON_HDLC, flow_rx | 0x04);\n\t\tif (hc->ctype == HFC_TYPE_E1 || hc->chan[ch].bch)\n\t\t\tHFC_outb(hc, A_SUBCH_CFG, 0);  \n\t\telse\n\t\t\tHFC_outb(hc, A_SUBCH_CFG, 2);  \n\t\tHFC_outb(hc, A_IRQ_MSK, V_IRQ);\n\t\tHFC_outb(hc, R_INC_RES_FIFO, V_RES_F);\n\t\tHFC_wait(hc);\n\t\tif (hc->chan[ch].bch) {\n\t\t\ttest_and_set_bit(FLG_HDLC, &hc->chan[ch].bch->Flags);\n\t\t\tif (hc->ctype != HFC_TYPE_E1) {\n\t\t\t\thc->hw.a_st_ctrl0[hc->chan[ch].port] |=\n\t\t\t\t\t((ch & 0x3) == 0) ? V_B1_EN : V_B2_EN;\n\t\t\t\tHFC_outb(hc, R_ST_SEL, hc->chan[ch].port);\n\t\t\t\t \n\t\t\t\tudelay(1);\n\t\t\t\tHFC_outb(hc, A_ST_CTRL0,\n\t\t\t\t\t hc->hw.a_st_ctrl0[hc->chan[ch].port]);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_DEBUG \"%s: protocol not known %x\\n\",\n\t\t       __func__, protocol);\n\t\thc->chan[ch].protocol = ISDN_P_NONE;\n\t\treturn -ENOPROTOOPT;\n\t}\n\thc->chan[ch].protocol = protocol;\n\treturn 0;\n}\n\n\n \n\nstatic void\nhfcmulti_pcm(struct hfc_multi *hc, int ch, int slot_tx, int bank_tx,\n\t     int slot_rx, int bank_rx)\n{\n\tif (slot_tx < 0 || slot_rx < 0 || bank_tx < 0 || bank_rx < 0) {\n\t\t \n\t\tmode_hfcmulti(hc, ch, hc->chan[ch].protocol, -1, 0, -1, 0);\n\t\treturn;\n\t}\n\n\t \n\tmode_hfcmulti(hc, ch, hc->chan[ch].protocol, slot_tx, bank_tx,\n\t\t      slot_rx, bank_rx);\n}\n\n \n\nstatic void\nhfcmulti_conf(struct hfc_multi *hc, int ch, int num)\n{\n\tif (num >= 0 && num <= 7)\n\t\thc->chan[ch].conf = num;\n\telse\n\t\thc->chan[ch].conf = -1;\n\tmode_hfcmulti(hc, ch, hc->chan[ch].protocol, hc->chan[ch].slot_tx,\n\t\t      hc->chan[ch].bank_tx, hc->chan[ch].slot_rx,\n\t\t      hc->chan[ch].bank_rx);\n}\n\n\n \n\n \n\n \nstatic int\nhfcm_l1callback(struct dchannel *dch, u_int cmd)\n{\n\tstruct hfc_multi\t*hc = dch->hw;\n\tstruct sk_buff_head\tfree_queue;\n\tu_long\tflags;\n\n\tswitch (cmd) {\n\tcase INFO3_P8:\n\tcase INFO3_P10:\n\t\tbreak;\n\tcase HW_RESET_REQ:\n\t\t \n\t\tspin_lock_irqsave(&hc->lock, flags);\n\t\tif (hc->ctype == HFC_TYPE_E1) {\n\t\t\tif (debug & DEBUG_HFCMULTI_MSG)\n\t\t\t\tprintk(KERN_DEBUG\n\t\t\t\t       \"%s: HW_RESET_REQ no BRI\\n\",\n\t\t\t\t       __func__);\n\t\t} else {\n\t\t\tHFC_outb(hc, R_ST_SEL, hc->chan[dch->slot].port);\n\t\t\t \n\t\t\tudelay(1);\n\t\t\tHFC_outb(hc, A_ST_WR_STATE, V_ST_LD_STA | 3);  \n\t\t\tudelay(6);  \n\t\t\tHFC_outb(hc, A_ST_WR_STATE, 3);\n\t\t\tHFC_outb(hc, A_ST_WR_STATE, 3 | (V_ST_ACT * 3));\n\t\t\t \n\t\t}\n\t\tspin_unlock_irqrestore(&hc->lock, flags);\n\t\tl1_event(dch->l1, HW_POWERUP_IND);\n\t\tbreak;\n\tcase HW_DEACT_REQ:\n\t\t__skb_queue_head_init(&free_queue);\n\t\t \n\t\tspin_lock_irqsave(&hc->lock, flags);\n\t\tif (hc->ctype == HFC_TYPE_E1) {\n\t\t\tif (debug & DEBUG_HFCMULTI_MSG)\n\t\t\t\tprintk(KERN_DEBUG\n\t\t\t\t       \"%s: HW_DEACT_REQ no BRI\\n\",\n\t\t\t\t       __func__);\n\t\t} else {\n\t\t\tHFC_outb(hc, R_ST_SEL, hc->chan[dch->slot].port);\n\t\t\t \n\t\t\tudelay(1);\n\t\t\tHFC_outb(hc, A_ST_WR_STATE, V_ST_ACT * 2);\n\t\t\t \n\t\t\tif (test_bit(HFC_CHIP_PLXSD, &hc->chip)) {\n\t\t\t\thc->syncronized &=\n\t\t\t\t\t~(1 << hc->chan[dch->slot].port);\n\t\t\t\tplxsd_checksync(hc, 0);\n\t\t\t}\n\t\t}\n\t\tskb_queue_splice_init(&dch->squeue, &free_queue);\n\t\tif (dch->tx_skb) {\n\t\t\t__skb_queue_tail(&free_queue, dch->tx_skb);\n\t\t\tdch->tx_skb = NULL;\n\t\t}\n\t\tdch->tx_idx = 0;\n\t\tif (dch->rx_skb) {\n\t\t\t__skb_queue_tail(&free_queue, dch->rx_skb);\n\t\t\tdch->rx_skb = NULL;\n\t\t}\n\t\ttest_and_clear_bit(FLG_TX_BUSY, &dch->Flags);\n\t\tif (test_and_clear_bit(FLG_BUSY_TIMER, &dch->Flags))\n\t\t\tdel_timer(&dch->timer);\n\t\tspin_unlock_irqrestore(&hc->lock, flags);\n\t\t__skb_queue_purge(&free_queue);\n\t\tbreak;\n\tcase HW_POWERUP_REQ:\n\t\tspin_lock_irqsave(&hc->lock, flags);\n\t\tif (hc->ctype == HFC_TYPE_E1) {\n\t\t\tif (debug & DEBUG_HFCMULTI_MSG)\n\t\t\t\tprintk(KERN_DEBUG\n\t\t\t\t       \"%s: HW_POWERUP_REQ no BRI\\n\",\n\t\t\t\t       __func__);\n\t\t} else {\n\t\t\tHFC_outb(hc, R_ST_SEL, hc->chan[dch->slot].port);\n\t\t\t \n\t\t\tudelay(1);\n\t\t\tHFC_outb(hc, A_ST_WR_STATE, 3 | 0x10);  \n\t\t\tudelay(6);  \n\t\t\tHFC_outb(hc, A_ST_WR_STATE, 3);  \n\t\t}\n\t\tspin_unlock_irqrestore(&hc->lock, flags);\n\t\tbreak;\n\tcase PH_ACTIVATE_IND:\n\t\ttest_and_set_bit(FLG_ACTIVE, &dch->Flags);\n\t\t_queue_data(&dch->dev.D, cmd, MISDN_ID_ANY, 0, NULL,\n\t\t\t    GFP_ATOMIC);\n\t\tbreak;\n\tcase PH_DEACTIVATE_IND:\n\t\ttest_and_clear_bit(FLG_ACTIVE, &dch->Flags);\n\t\t_queue_data(&dch->dev.D, cmd, MISDN_ID_ANY, 0, NULL,\n\t\t\t    GFP_ATOMIC);\n\t\tbreak;\n\tdefault:\n\t\tif (dch->debug & DEBUG_HW)\n\t\t\tprintk(KERN_DEBUG \"%s: unknown command %x\\n\",\n\t\t\t       __func__, cmd);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\n \n\nstatic int\nhandle_dmsg(struct mISDNchannel *ch, struct sk_buff *skb)\n{\n\tstruct mISDNdevice\t*dev = container_of(ch, struct mISDNdevice, D);\n\tstruct dchannel\t\t*dch = container_of(dev, struct dchannel, dev);\n\tstruct hfc_multi\t*hc = dch->hw;\n\tstruct mISDNhead\t*hh = mISDN_HEAD_P(skb);\n\tint\t\t\tret = -EINVAL;\n\tunsigned int\t\tid;\n\tu_long\t\t\tflags;\n\n\tswitch (hh->prim) {\n\tcase PH_DATA_REQ:\n\t\tif (skb->len < 1)\n\t\t\tbreak;\n\t\tspin_lock_irqsave(&hc->lock, flags);\n\t\tret = dchannel_senddata(dch, skb);\n\t\tif (ret > 0) {  \n\t\t\tid = hh->id;  \n\t\t\thfcmulti_tx(hc, dch->slot);\n\t\t\tret = 0;\n\t\t\t \n\t\t\tHFC_outb(hc, R_FIFO, 0);\n\t\t\tHFC_wait(hc);\n\t\t\tspin_unlock_irqrestore(&hc->lock, flags);\n\t\t\tqueue_ch_frame(ch, PH_DATA_CNF, id, NULL);\n\t\t} else\n\t\t\tspin_unlock_irqrestore(&hc->lock, flags);\n\t\treturn ret;\n\tcase PH_ACTIVATE_REQ:\n\t\tif (dch->dev.D.protocol != ISDN_P_TE_S0) {\n\t\t\tspin_lock_irqsave(&hc->lock, flags);\n\t\t\tret = 0;\n\t\t\tif (debug & DEBUG_HFCMULTI_MSG)\n\t\t\t\tprintk(KERN_DEBUG\n\t\t\t\t       \"%s: PH_ACTIVATE port %d (0..%d)\\n\",\n\t\t\t\t       __func__, hc->chan[dch->slot].port,\n\t\t\t\t       hc->ports - 1);\n\t\t\t \n\t\t\tif (hc->ctype == HFC_TYPE_E1) {\n\t\t\t\tph_state_change(dch);\n\t\t\t\tif (debug & DEBUG_HFCMULTI_STATE)\n\t\t\t\t\tprintk(KERN_DEBUG\n\t\t\t\t\t       \"%s: E1 report state %x \\n\",\n\t\t\t\t\t       __func__, dch->state);\n\t\t\t} else {\n\t\t\t\tHFC_outb(hc, R_ST_SEL,\n\t\t\t\t\t hc->chan[dch->slot].port);\n\t\t\t\t \n\t\t\t\tudelay(1);\n\t\t\t\tHFC_outb(hc, A_ST_WR_STATE, V_ST_LD_STA | 1);\n\t\t\t\t \n\t\t\t\tudelay(6);  \n\t\t\t\tHFC_outb(hc, A_ST_WR_STATE, 1);\n\t\t\t\tHFC_outb(hc, A_ST_WR_STATE, 1 |\n\t\t\t\t\t (V_ST_ACT * 3));  \n\t\t\t\tdch->state = 1;\n\t\t\t}\n\t\t\tspin_unlock_irqrestore(&hc->lock, flags);\n\t\t} else\n\t\t\tret = l1_event(dch->l1, hh->prim);\n\t\tbreak;\n\tcase PH_DEACTIVATE_REQ:\n\t\ttest_and_clear_bit(FLG_L2_ACTIVATED, &dch->Flags);\n\t\tif (dch->dev.D.protocol != ISDN_P_TE_S0) {\n\t\t\tstruct sk_buff_head free_queue;\n\n\t\t\t__skb_queue_head_init(&free_queue);\n\t\t\tspin_lock_irqsave(&hc->lock, flags);\n\t\t\tif (debug & DEBUG_HFCMULTI_MSG)\n\t\t\t\tprintk(KERN_DEBUG\n\t\t\t\t       \"%s: PH_DEACTIVATE port %d (0..%d)\\n\",\n\t\t\t\t       __func__, hc->chan[dch->slot].port,\n\t\t\t\t       hc->ports - 1);\n\t\t\t \n\t\t\tif (hc->ctype == HFC_TYPE_E1) {\n\t\t\t\tif (debug & DEBUG_HFCMULTI_MSG)\n\t\t\t\t\tprintk(KERN_DEBUG\n\t\t\t\t\t       \"%s: PH_DEACTIVATE no BRI\\n\",\n\t\t\t\t\t       __func__);\n\t\t\t} else {\n\t\t\t\tHFC_outb(hc, R_ST_SEL,\n\t\t\t\t\t hc->chan[dch->slot].port);\n\t\t\t\t \n\t\t\t\tudelay(1);\n\t\t\t\tHFC_outb(hc, A_ST_WR_STATE, V_ST_ACT * 2);\n\t\t\t\t \n\t\t\t\tdch->state = 1;\n\t\t\t}\n\t\t\tskb_queue_splice_init(&dch->squeue, &free_queue);\n\t\t\tif (dch->tx_skb) {\n\t\t\t\t__skb_queue_tail(&free_queue, dch->tx_skb);\n\t\t\t\tdch->tx_skb = NULL;\n\t\t\t}\n\t\t\tdch->tx_idx = 0;\n\t\t\tif (dch->rx_skb) {\n\t\t\t\t__skb_queue_tail(&free_queue, dch->rx_skb);\n\t\t\t\tdch->rx_skb = NULL;\n\t\t\t}\n\t\t\ttest_and_clear_bit(FLG_TX_BUSY, &dch->Flags);\n\t\t\tif (test_and_clear_bit(FLG_BUSY_TIMER, &dch->Flags))\n\t\t\t\tdel_timer(&dch->timer);\n#ifdef FIXME\n\t\t\tif (test_and_clear_bit(FLG_L1_BUSY, &dch->Flags))\n\t\t\t\tdchannel_sched_event(&hc->dch, D_CLEARBUSY);\n#endif\n\t\t\tret = 0;\n\t\t\tspin_unlock_irqrestore(&hc->lock, flags);\n\t\t\t__skb_queue_purge(&free_queue);\n\t\t} else\n\t\t\tret = l1_event(dch->l1, hh->prim);\n\t\tbreak;\n\t}\n\tif (!ret)\n\t\tdev_kfree_skb(skb);\n\treturn ret;\n}\n\nstatic void\ndeactivate_bchannel(struct bchannel *bch)\n{\n\tstruct hfc_multi\t*hc = bch->hw;\n\tu_long\t\t\tflags;\n\n\tspin_lock_irqsave(&hc->lock, flags);\n\tmISDN_clear_bchannel(bch);\n\thc->chan[bch->slot].coeff_count = 0;\n\thc->chan[bch->slot].rx_off = 0;\n\thc->chan[bch->slot].conf = -1;\n\tmode_hfcmulti(hc, bch->slot, ISDN_P_NONE, -1, 0, -1, 0);\n\tspin_unlock_irqrestore(&hc->lock, flags);\n}\n\nstatic int\nhandle_bmsg(struct mISDNchannel *ch, struct sk_buff *skb)\n{\n\tstruct bchannel\t\t*bch = container_of(ch, struct bchannel, ch);\n\tstruct hfc_multi\t*hc = bch->hw;\n\tint\t\t\tret = -EINVAL;\n\tstruct mISDNhead\t*hh = mISDN_HEAD_P(skb);\n\tunsigned long\t\tflags;\n\n\tswitch (hh->prim) {\n\tcase PH_DATA_REQ:\n\t\tif (!skb->len)\n\t\t\tbreak;\n\t\tspin_lock_irqsave(&hc->lock, flags);\n\t\tret = bchannel_senddata(bch, skb);\n\t\tif (ret > 0) {  \n\t\t\thfcmulti_tx(hc, bch->slot);\n\t\t\tret = 0;\n\t\t\t \n\t\t\tHFC_outb_nodebug(hc, R_FIFO, 0);\n\t\t\tHFC_wait_nodebug(hc);\n\t\t}\n\t\tspin_unlock_irqrestore(&hc->lock, flags);\n\t\treturn ret;\n\tcase PH_ACTIVATE_REQ:\n\t\tif (debug & DEBUG_HFCMULTI_MSG)\n\t\t\tprintk(KERN_DEBUG \"%s: PH_ACTIVATE ch %d (0..32)\\n\",\n\t\t\t       __func__, bch->slot);\n\t\tspin_lock_irqsave(&hc->lock, flags);\n\t\t \n\t\tif (!test_and_set_bit(FLG_ACTIVE, &bch->Flags)) {\n\t\t\thc->chan[bch->slot].txpending = 0;\n\t\t\tret = mode_hfcmulti(hc, bch->slot,\n\t\t\t\t\t    ch->protocol,\n\t\t\t\t\t    hc->chan[bch->slot].slot_tx,\n\t\t\t\t\t    hc->chan[bch->slot].bank_tx,\n\t\t\t\t\t    hc->chan[bch->slot].slot_rx,\n\t\t\t\t\t    hc->chan[bch->slot].bank_rx);\n\t\t\tif (!ret) {\n\t\t\t\tif (ch->protocol == ISDN_P_B_RAW && !hc->dtmf\n\t\t\t\t    && test_bit(HFC_CHIP_DTMF, &hc->chip)) {\n\t\t\t\t\t \n\t\t\t\t\thc->dtmf = 1;\n\t\t\t\t\tif (debug & DEBUG_HFCMULTI_DTMF)\n\t\t\t\t\t\tprintk(KERN_DEBUG\n\t\t\t\t\t\t       \"%s: start dtmf decoder\\n\",\n\t\t\t\t\t\t       __func__);\n\t\t\t\t\tHFC_outb(hc, R_DTMF, hc->hw.r_dtmf |\n\t\t\t\t\t\t V_RST_DTMF);\n\t\t\t\t}\n\t\t\t}\n\t\t} else\n\t\t\tret = 0;\n\t\tspin_unlock_irqrestore(&hc->lock, flags);\n\t\tif (!ret)\n\t\t\t_queue_data(ch, PH_ACTIVATE_IND, MISDN_ID_ANY, 0, NULL,\n\t\t\t\t    GFP_KERNEL);\n\t\tbreak;\n\tcase PH_CONTROL_REQ:\n\t\tspin_lock_irqsave(&hc->lock, flags);\n\t\tswitch (hh->id) {\n\t\tcase HFC_SPL_LOOP_ON:  \n\t\t\tif (debug & DEBUG_HFCMULTI_MSG)\n\t\t\t\tprintk(KERN_DEBUG\n\t\t\t\t       \"%s: HFC_SPL_LOOP_ON (len = %d)\\n\",\n\t\t\t\t       __func__, skb->len);\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\tcase HFC_SPL_LOOP_OFF:  \n\t\t\tif (debug & DEBUG_HFCMULTI_MSG)\n\t\t\t\tprintk(KERN_DEBUG \"%s: HFC_SPL_LOOP_OFF\\n\",\n\t\t\t\t       __func__);\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintk(KERN_ERR\n\t\t\t       \"%s: unknown PH_CONTROL_REQ info %x\\n\",\n\t\t\t       __func__, hh->id);\n\t\t\tret = -EINVAL;\n\t\t}\n\t\tspin_unlock_irqrestore(&hc->lock, flags);\n\t\tbreak;\n\tcase PH_DEACTIVATE_REQ:\n\t\tdeactivate_bchannel(bch);  \n\t\t_queue_data(ch, PH_DEACTIVATE_IND, MISDN_ID_ANY, 0, NULL,\n\t\t\t    GFP_KERNEL);\n\t\tret = 0;\n\t\tbreak;\n\t}\n\tif (!ret)\n\t\tdev_kfree_skb(skb);\n\treturn ret;\n}\n\n \nstatic int\nchannel_bctrl(struct bchannel *bch, struct mISDN_ctrl_req *cq)\n{\n\tint\t\t\tret = 0;\n\tstruct dsp_features\t*features =\n\t\t(struct dsp_features *)(*((u_long *)&cq->p1));\n\tstruct hfc_multi\t*hc = bch->hw;\n\tint\t\t\tslot_tx;\n\tint\t\t\tbank_tx;\n\tint\t\t\tslot_rx;\n\tint\t\t\tbank_rx;\n\tint\t\t\tnum;\n\n\tswitch (cq->op) {\n\tcase MISDN_CTRL_GETOP:\n\t\tret = mISDN_ctrl_bchannel(bch, cq);\n\t\tcq->op |= MISDN_CTRL_HFC_OP | MISDN_CTRL_HW_FEATURES_OP;\n\t\tbreak;\n\tcase MISDN_CTRL_RX_OFF:  \n\t\tret = mISDN_ctrl_bchannel(bch, cq);\n\t\thc->chan[bch->slot].rx_off = !!cq->p1;\n\t\tif (!hc->chan[bch->slot].rx_off) {\n\t\t\t \n\t\t\tHFC_outb_nodebug(hc, R_FIFO, (bch->slot << 1) | 1);\n\t\t\tHFC_wait_nodebug(hc);\n\t\t\tHFC_outb_nodebug(hc, R_INC_RES_FIFO, V_RES_F);\n\t\t\tHFC_wait_nodebug(hc);\n\t\t}\n\t\tif (debug & DEBUG_HFCMULTI_MSG)\n\t\t\tprintk(KERN_DEBUG \"%s: RX_OFF request (nr=%d off=%d)\\n\",\n\t\t\t       __func__, bch->nr, hc->chan[bch->slot].rx_off);\n\t\tbreak;\n\tcase MISDN_CTRL_FILL_EMPTY:\n\t\tret = mISDN_ctrl_bchannel(bch, cq);\n\t\thc->silence = bch->fill[0];\n\t\tmemset(hc->silence_data, hc->silence, sizeof(hc->silence_data));\n\t\tbreak;\n\tcase MISDN_CTRL_HW_FEATURES:  \n\t\tif (debug & DEBUG_HFCMULTI_MSG)\n\t\t\tprintk(KERN_DEBUG \"%s: HW_FEATURE request\\n\",\n\t\t\t       __func__);\n\t\t \n\t\tfeatures->hfc_id = hc->id;\n\t\tif (test_bit(HFC_CHIP_DTMF, &hc->chip))\n\t\t\tfeatures->hfc_dtmf = 1;\n\t\tif (test_bit(HFC_CHIP_CONF, &hc->chip))\n\t\t\tfeatures->hfc_conf = 1;\n\t\tfeatures->hfc_loops = 0;\n\t\tif (test_bit(HFC_CHIP_B410P, &hc->chip)) {\n\t\t\tfeatures->hfc_echocanhw = 1;\n\t\t} else {\n\t\t\tfeatures->pcm_id = hc->pcm;\n\t\t\tfeatures->pcm_slots = hc->slots;\n\t\t\tfeatures->pcm_banks = 2;\n\t\t}\n\t\tbreak;\n\tcase MISDN_CTRL_HFC_PCM_CONN:  \n\t\tslot_tx = cq->p1 & 0xff;\n\t\tbank_tx = cq->p1 >> 8;\n\t\tslot_rx = cq->p2 & 0xff;\n\t\tbank_rx = cq->p2 >> 8;\n\t\tif (debug & DEBUG_HFCMULTI_MSG)\n\t\t\tprintk(KERN_DEBUG\n\t\t\t       \"%s: HFC_PCM_CONN slot %d bank %d (TX) \"\n\t\t\t       \"slot %d bank %d (RX)\\n\",\n\t\t\t       __func__, slot_tx, bank_tx,\n\t\t\t       slot_rx, bank_rx);\n\t\tif (slot_tx < hc->slots && bank_tx <= 2 &&\n\t\t    slot_rx < hc->slots && bank_rx <= 2)\n\t\t\thfcmulti_pcm(hc, bch->slot,\n\t\t\t\t     slot_tx, bank_tx, slot_rx, bank_rx);\n\t\telse {\n\t\t\tprintk(KERN_WARNING\n\t\t\t       \"%s: HFC_PCM_CONN slot %d bank %d (TX) \"\n\t\t\t       \"slot %d bank %d (RX) out of range\\n\",\n\t\t\t       __func__, slot_tx, bank_tx,\n\t\t\t       slot_rx, bank_rx);\n\t\t\tret = -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase MISDN_CTRL_HFC_PCM_DISC:  \n\t\tif (debug & DEBUG_HFCMULTI_MSG)\n\t\t\tprintk(KERN_DEBUG \"%s: HFC_PCM_DISC\\n\",\n\t\t\t       __func__);\n\t\thfcmulti_pcm(hc, bch->slot, -1, 0, -1, 0);\n\t\tbreak;\n\tcase MISDN_CTRL_HFC_CONF_JOIN:  \n\t\tnum = cq->p1 & 0xff;\n\t\tif (debug & DEBUG_HFCMULTI_MSG)\n\t\t\tprintk(KERN_DEBUG \"%s: HFC_CONF_JOIN conf %d\\n\",\n\t\t\t       __func__, num);\n\t\tif (num <= 7)\n\t\t\thfcmulti_conf(hc, bch->slot, num);\n\t\telse {\n\t\t\tprintk(KERN_WARNING\n\t\t\t       \"%s: HW_CONF_JOIN conf %d out of range\\n\",\n\t\t\t       __func__, num);\n\t\t\tret = -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase MISDN_CTRL_HFC_CONF_SPLIT:  \n\t\tif (debug & DEBUG_HFCMULTI_MSG)\n\t\t\tprintk(KERN_DEBUG \"%s: HFC_CONF_SPLIT\\n\", __func__);\n\t\thfcmulti_conf(hc, bch->slot, -1);\n\t\tbreak;\n\tcase MISDN_CTRL_HFC_ECHOCAN_ON:\n\t\tif (debug & DEBUG_HFCMULTI_MSG)\n\t\t\tprintk(KERN_DEBUG \"%s: HFC_ECHOCAN_ON\\n\", __func__);\n\t\tif (test_bit(HFC_CHIP_B410P, &hc->chip))\n\t\t\tvpm_echocan_on(hc, bch->slot, cq->p1);\n\t\telse\n\t\t\tret = -EINVAL;\n\t\tbreak;\n\n\tcase MISDN_CTRL_HFC_ECHOCAN_OFF:\n\t\tif (debug & DEBUG_HFCMULTI_MSG)\n\t\t\tprintk(KERN_DEBUG \"%s: HFC_ECHOCAN_OFF\\n\",\n\t\t\t       __func__);\n\t\tif (test_bit(HFC_CHIP_B410P, &hc->chip))\n\t\t\tvpm_echocan_off(hc, bch->slot);\n\t\telse\n\t\t\tret = -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\tret = mISDN_ctrl_bchannel(bch, cq);\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic int\nhfcm_bctrl(struct mISDNchannel *ch, u_int cmd, void *arg)\n{\n\tstruct bchannel\t\t*bch = container_of(ch, struct bchannel, ch);\n\tstruct hfc_multi\t*hc = bch->hw;\n\tint\t\t\terr = -EINVAL;\n\tu_long\tflags;\n\n\tif (bch->debug & DEBUG_HW)\n\t\tprintk(KERN_DEBUG \"%s: cmd:%x %p\\n\",\n\t\t       __func__, cmd, arg);\n\tswitch (cmd) {\n\tcase CLOSE_CHANNEL:\n\t\ttest_and_clear_bit(FLG_OPEN, &bch->Flags);\n\t\tdeactivate_bchannel(bch);  \n\t\tch->protocol = ISDN_P_NONE;\n\t\tch->peer = NULL;\n\t\tmodule_put(THIS_MODULE);\n\t\terr = 0;\n\t\tbreak;\n\tcase CONTROL_CHANNEL:\n\t\tspin_lock_irqsave(&hc->lock, flags);\n\t\terr = channel_bctrl(bch, arg);\n\t\tspin_unlock_irqrestore(&hc->lock, flags);\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_WARNING \"%s: unknown prim(%x)\\n\",\n\t\t       __func__, cmd);\n\t}\n\treturn err;\n}\n\n \nstatic void\nph_state_change(struct dchannel *dch)\n{\n\tstruct hfc_multi *hc;\n\tint ch, i;\n\n\tif (!dch) {\n\t\tprintk(KERN_WARNING \"%s: ERROR given dch is NULL\\n\", __func__);\n\t\treturn;\n\t}\n\thc = dch->hw;\n\tch = dch->slot;\n\n\tif (hc->ctype == HFC_TYPE_E1) {\n\t\tif (dch->dev.D.protocol == ISDN_P_TE_E1) {\n\t\t\tif (debug & DEBUG_HFCMULTI_STATE)\n\t\t\t\tprintk(KERN_DEBUG\n\t\t\t\t       \"%s: E1 TE (id=%d) newstate %x\\n\",\n\t\t\t\t       __func__, hc->id, dch->state);\n\t\t} else {\n\t\t\tif (debug & DEBUG_HFCMULTI_STATE)\n\t\t\t\tprintk(KERN_DEBUG\n\t\t\t\t       \"%s: E1 NT (id=%d) newstate %x\\n\",\n\t\t\t\t       __func__, hc->id, dch->state);\n\t\t}\n\t\tswitch (dch->state) {\n\t\tcase (1):\n\t\t\tif (hc->e1_state != 1) {\n\t\t\t\tfor (i = 1; i <= 31; i++) {\n\t\t\t\t\t \n\t\t\t\t\tHFC_outb_nodebug(hc, R_FIFO,\n\t\t\t\t\t\t\t (i << 1) | 1);\n\t\t\t\t\tHFC_wait_nodebug(hc);\n\t\t\t\t\tHFC_outb_nodebug(hc, R_INC_RES_FIFO,\n\t\t\t\t\t\t\t V_RES_F);\n\t\t\t\t\tHFC_wait_nodebug(hc);\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest_and_set_bit(FLG_ACTIVE, &dch->Flags);\n\t\t\t_queue_data(&dch->dev.D, PH_ACTIVATE_IND,\n\t\t\t\t    MISDN_ID_ANY, 0, NULL, GFP_ATOMIC);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tif (hc->e1_state != 1)\n\t\t\t\treturn;\n\t\t\ttest_and_clear_bit(FLG_ACTIVE, &dch->Flags);\n\t\t\t_queue_data(&dch->dev.D, PH_DEACTIVATE_IND,\n\t\t\t\t    MISDN_ID_ANY, 0, NULL, GFP_ATOMIC);\n\t\t}\n\t\thc->e1_state = dch->state;\n\t} else {\n\t\tif (dch->dev.D.protocol == ISDN_P_TE_S0) {\n\t\t\tif (debug & DEBUG_HFCMULTI_STATE)\n\t\t\t\tprintk(KERN_DEBUG\n\t\t\t\t       \"%s: S/T TE newstate %x\\n\",\n\t\t\t\t       __func__, dch->state);\n\t\t\tswitch (dch->state) {\n\t\t\tcase (0):\n\t\t\t\tl1_event(dch->l1, HW_RESET_IND);\n\t\t\t\tbreak;\n\t\t\tcase (3):\n\t\t\t\tl1_event(dch->l1, HW_DEACT_IND);\n\t\t\t\tbreak;\n\t\t\tcase (5):\n\t\t\tcase (8):\n\t\t\t\tl1_event(dch->l1, ANYSIGNAL);\n\t\t\t\tbreak;\n\t\t\tcase (6):\n\t\t\t\tl1_event(dch->l1, INFO2);\n\t\t\t\tbreak;\n\t\t\tcase (7):\n\t\t\t\tl1_event(dch->l1, INFO4_P8);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tif (debug & DEBUG_HFCMULTI_STATE)\n\t\t\t\tprintk(KERN_DEBUG \"%s: S/T NT newstate %x\\n\",\n\t\t\t\t       __func__, dch->state);\n\t\t\tswitch (dch->state) {\n\t\t\tcase (2):\n\t\t\t\tif (hc->chan[ch].nt_timer == 0) {\n\t\t\t\t\thc->chan[ch].nt_timer = -1;\n\t\t\t\t\tHFC_outb(hc, R_ST_SEL,\n\t\t\t\t\t\t hc->chan[ch].port);\n\t\t\t\t\t \n\t\t\t\t\tudelay(1);\n\t\t\t\t\tHFC_outb(hc, A_ST_WR_STATE, 4 |\n\t\t\t\t\t\t V_ST_LD_STA);  \n\t\t\t\t\tudelay(6);  \n\t\t\t\t\tHFC_outb(hc, A_ST_WR_STATE, 4);\n\t\t\t\t\tdch->state = 4;\n\t\t\t\t} else {\n\t\t\t\t\t \n\t\t\t\t\thc->chan[ch].nt_timer =\n\t\t\t\t\t\tnt_t1_count[poll_timer] + 1;\n\t\t\t\t\tHFC_outb(hc, R_ST_SEL,\n\t\t\t\t\t\t hc->chan[ch].port);\n\t\t\t\t\t \n\t\t\t\t\tudelay(1);\n\t\t\t\t\t \n\t\t\t\t\tHFC_outb(hc, A_ST_WR_STATE, 2 |\n\t\t\t\t\t\t V_SET_G2_G3);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase (1):\n\t\t\t\thc->chan[ch].nt_timer = -1;\n\t\t\t\ttest_and_clear_bit(FLG_ACTIVE, &dch->Flags);\n\t\t\t\t_queue_data(&dch->dev.D, PH_DEACTIVATE_IND,\n\t\t\t\t\t    MISDN_ID_ANY, 0, NULL, GFP_ATOMIC);\n\t\t\t\tbreak;\n\t\t\tcase (4):\n\t\t\t\thc->chan[ch].nt_timer = -1;\n\t\t\t\tbreak;\n\t\t\tcase (3):\n\t\t\t\thc->chan[ch].nt_timer = -1;\n\t\t\t\ttest_and_set_bit(FLG_ACTIVE, &dch->Flags);\n\t\t\t\t_queue_data(&dch->dev.D, PH_ACTIVATE_IND,\n\t\t\t\t\t    MISDN_ID_ANY, 0, NULL, GFP_ATOMIC);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\n \n\nstatic void\nhfcmulti_initmode(struct dchannel *dch)\n{\n\tstruct hfc_multi *hc = dch->hw;\n\tu_char\t\ta_st_wr_state, r_e1_wr_sta;\n\tint\t\ti, pt;\n\n\tif (debug & DEBUG_HFCMULTI_INIT)\n\t\tprintk(KERN_DEBUG \"%s: entered\\n\", __func__);\n\n\ti = dch->slot;\n\tpt = hc->chan[i].port;\n\tif (hc->ctype == HFC_TYPE_E1) {\n\t\t \n\t\thc->chan[hc->dnum[pt]].slot_tx = -1;\n\t\thc->chan[hc->dnum[pt]].slot_rx = -1;\n\t\thc->chan[hc->dnum[pt]].conf = -1;\n\t\tif (hc->dnum[pt]) {\n\t\t\tmode_hfcmulti(hc, dch->slot, dch->dev.D.protocol,\n\t\t\t\t      -1, 0, -1, 0);\n\t\t\ttimer_setup(&dch->timer, hfcmulti_dbusy_timer, 0);\n\t\t}\n\t\tfor (i = 1; i <= 31; i++) {\n\t\t\tif (!((1 << i) & hc->bmask[pt]))  \n\t\t\t\tcontinue;\n\t\t\thc->chan[i].slot_tx = -1;\n\t\t\thc->chan[i].slot_rx = -1;\n\t\t\thc->chan[i].conf = -1;\n\t\t\tmode_hfcmulti(hc, i, ISDN_P_NONE, -1, 0, -1, 0);\n\t\t}\n\t}\n\tif (hc->ctype == HFC_TYPE_E1 && pt == 0) {\n\t\t \n\t\tdch = hc->chan[hc->dnum[0]].dch;\n\t\tif (test_bit(HFC_CFG_REPORT_LOS, &hc->chan[hc->dnum[0]].cfg)) {\n\t\t\tHFC_outb(hc, R_LOS0, 255);  \n\t\t\tHFC_outb(hc, R_LOS1, 255);  \n\t\t}\n\t\tif (test_bit(HFC_CFG_OPTICAL, &hc->chan[hc->dnum[0]].cfg)) {\n\t\t\tHFC_outb(hc, R_RX0, 0);\n\t\t\thc->hw.r_tx0 = 0 | V_OUT_EN;\n\t\t} else {\n\t\t\tHFC_outb(hc, R_RX0, 1);\n\t\t\thc->hw.r_tx0 = 1 | V_OUT_EN;\n\t\t}\n\t\thc->hw.r_tx1 = V_ATX | V_NTRI;\n\t\tHFC_outb(hc, R_TX0, hc->hw.r_tx0);\n\t\tHFC_outb(hc, R_TX1, hc->hw.r_tx1);\n\t\tHFC_outb(hc, R_TX_FR0, 0x00);\n\t\tHFC_outb(hc, R_TX_FR1, 0xf8);\n\n\t\tif (test_bit(HFC_CFG_CRC4, &hc->chan[hc->dnum[0]].cfg))\n\t\t\tHFC_outb(hc, R_TX_FR2, V_TX_MF | V_TX_E | V_NEG_E);\n\n\t\tHFC_outb(hc, R_RX_FR0, V_AUTO_RESYNC | V_AUTO_RECO | 0);\n\n\t\tif (test_bit(HFC_CFG_CRC4, &hc->chan[hc->dnum[0]].cfg))\n\t\t\tHFC_outb(hc, R_RX_FR1, V_RX_MF | V_RX_MF_SYNC);\n\n\t\tif (dch->dev.D.protocol == ISDN_P_NT_E1) {\n\t\t\tif (debug & DEBUG_HFCMULTI_INIT)\n\t\t\t\tprintk(KERN_DEBUG \"%s: E1 port is NT-mode\\n\",\n\t\t\t\t       __func__);\n\t\t\tr_e1_wr_sta = 0;  \n\t\t\thc->e1_getclock = 0;\n\t\t} else {\n\t\t\tif (debug & DEBUG_HFCMULTI_INIT)\n\t\t\t\tprintk(KERN_DEBUG \"%s: E1 port is TE-mode\\n\",\n\t\t\t\t       __func__);\n\t\t\tr_e1_wr_sta = 0;  \n\t\t\thc->e1_getclock = 1;\n\t\t}\n\t\tif (test_bit(HFC_CHIP_RX_SYNC, &hc->chip))\n\t\t\tHFC_outb(hc, R_SYNC_OUT, V_SYNC_E1_RX);\n\t\telse\n\t\t\tHFC_outb(hc, R_SYNC_OUT, 0);\n\t\tif (test_bit(HFC_CHIP_E1CLOCK_GET, &hc->chip))\n\t\t\thc->e1_getclock = 1;\n\t\tif (test_bit(HFC_CHIP_E1CLOCK_PUT, &hc->chip))\n\t\t\thc->e1_getclock = 0;\n\t\tif (test_bit(HFC_CHIP_PCM_SLAVE, &hc->chip)) {\n\t\t\t \n\t\t\tif (debug & DEBUG_HFCMULTI_INIT)\n\t\t\t\tprintk(KERN_DEBUG\n\t\t\t\t       \"%s: E1 port is clock master \"\n\t\t\t\t       \"(clock from PCM)\\n\", __func__);\n\t\t\tHFC_outb(hc, R_SYNC_CTRL, V_EXT_CLK_SYNC | V_PCM_SYNC);\n\t\t} else {\n\t\t\tif (hc->e1_getclock) {\n\t\t\t\t \n\t\t\t\tif (debug & DEBUG_HFCMULTI_INIT)\n\t\t\t\t\tprintk(KERN_DEBUG\n\t\t\t\t\t       \"%s: E1 port is clock slave \"\n\t\t\t\t\t       \"(clock to PCM)\\n\", __func__);\n\t\t\t\tHFC_outb(hc, R_SYNC_CTRL, V_SYNC_OFFS);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tif (debug & DEBUG_HFCMULTI_INIT)\n\t\t\t\t\tprintk(KERN_DEBUG \"%s: E1 port is \"\n\t\t\t\t\t       \"clock master \"\n\t\t\t\t\t       \"(clock from QUARTZ)\\n\",\n\t\t\t\t\t       __func__);\n\t\t\t\tHFC_outb(hc, R_SYNC_CTRL, V_EXT_CLK_SYNC |\n\t\t\t\t\t V_PCM_SYNC | V_JATT_OFF);\n\t\t\t\tHFC_outb(hc, R_SYNC_OUT, 0);\n\t\t\t}\n\t\t}\n\t\tHFC_outb(hc, R_JATT_ATT, 0x9c);  \n\t\tHFC_outb(hc, R_PWM_MD, V_PWM0_MD);\n\t\tHFC_outb(hc, R_PWM0, 0x50);\n\t\tHFC_outb(hc, R_PWM1, 0xff);\n\t\t \n\t\tHFC_outb(hc, R_E1_WR_STA, r_e1_wr_sta | V_E1_LD_STA);\n\t\tudelay(6);  \n\t\tHFC_outb(hc, R_E1_WR_STA, r_e1_wr_sta);\n\t\tif (test_bit(HFC_CHIP_PLXSD, &hc->chip)) {\n\t\t\thc->syncronized = 0;\n\t\t\tplxsd_checksync(hc, 0);\n\t\t}\n\t}\n\tif (hc->ctype != HFC_TYPE_E1) {\n\t\t \n\t\thc->chan[i].slot_tx = -1;\n\t\thc->chan[i].slot_rx = -1;\n\t\thc->chan[i].conf = -1;\n\t\tmode_hfcmulti(hc, i, dch->dev.D.protocol, -1, 0, -1, 0);\n\t\ttimer_setup(&dch->timer, hfcmulti_dbusy_timer, 0);\n\t\thc->chan[i - 2].slot_tx = -1;\n\t\thc->chan[i - 2].slot_rx = -1;\n\t\thc->chan[i - 2].conf = -1;\n\t\tmode_hfcmulti(hc, i - 2, ISDN_P_NONE, -1, 0, -1, 0);\n\t\thc->chan[i - 1].slot_tx = -1;\n\t\thc->chan[i - 1].slot_rx = -1;\n\t\thc->chan[i - 1].conf = -1;\n\t\tmode_hfcmulti(hc, i - 1, ISDN_P_NONE, -1, 0, -1, 0);\n\t\t \n\t\tHFC_outb(hc, R_ST_SEL, pt);\n\t\t \n\t\tudelay(1);\n\t\tif (dch->dev.D.protocol == ISDN_P_NT_S0) {\n\t\t\tif (debug & DEBUG_HFCMULTI_INIT)\n\t\t\t\tprintk(KERN_DEBUG\n\t\t\t\t       \"%s: ST port %d is NT-mode\\n\",\n\t\t\t\t       __func__, pt);\n\t\t\t \n\t\t\tHFC_outb(hc, A_ST_CLK_DLY, clockdelay_nt);\n\t\t\ta_st_wr_state = 1;  \n\t\t\thc->hw.a_st_ctrl0[pt] = V_ST_MD;\n\t\t} else {\n\t\t\tif (debug & DEBUG_HFCMULTI_INIT)\n\t\t\t\tprintk(KERN_DEBUG\n\t\t\t\t       \"%s: ST port %d is TE-mode\\n\",\n\t\t\t\t       __func__, pt);\n\t\t\t \n\t\t\tHFC_outb(hc, A_ST_CLK_DLY, clockdelay_te);\n\t\t\ta_st_wr_state = 2;  \n\t\t\thc->hw.a_st_ctrl0[pt] = 0;\n\t\t}\n\t\tif (!test_bit(HFC_CFG_NONCAP_TX, &hc->chan[i].cfg))\n\t\t\thc->hw.a_st_ctrl0[pt] |= V_TX_LI;\n\t\tif (hc->ctype == HFC_TYPE_XHFC) {\n\t\t\thc->hw.a_st_ctrl0[pt] |= 0x40  ;\n\t\t\tHFC_outb(hc, 0x35  ,\n\t\t\t\t 0x7c << 1  );\n\t\t}\n\t\t \n\t\tHFC_outb(hc, A_ST_CTRL0,  hc->hw.a_st_ctrl0[pt]);\n\t\t \n\t\tif ((dch->dev.D.protocol == ISDN_P_NT_S0) ||\n\t\t    test_bit(HFC_CFG_DIS_ECHANNEL, &hc->chan[i].cfg))\n\t\t\tHFC_outb(hc, A_ST_CTRL1, V_E_IGNO);\n\t\telse\n\t\t\tHFC_outb(hc, A_ST_CTRL1, 0);\n\t\t \n\t\tHFC_outb(hc, A_ST_CTRL2,  V_B1_RX_EN | V_B2_RX_EN);\n\t\t \n\t\tHFC_outb(hc, A_ST_WR_STATE, a_st_wr_state | V_ST_LD_STA);\n\t\tudelay(6);  \n\t\tHFC_outb(hc, A_ST_WR_STATE, a_st_wr_state);\n\t\thc->hw.r_sci_msk |= 1 << pt;\n\t\t \n\t\tHFC_outb(hc, R_SCI_MSK, hc->hw.r_sci_msk);\n\t\t \n\t\tif (test_bit(HFC_CHIP_PLXSD, &hc->chip)) {\n\t\t\thc->syncronized &=\n\t\t\t\t~(1 << hc->chan[dch->slot].port);\n\t\t\tplxsd_checksync(hc, 0);\n\t\t}\n\t}\n\tif (debug & DEBUG_HFCMULTI_INIT)\n\t\tprintk(\"%s: done\\n\", __func__);\n}\n\n\nstatic int\nopen_dchannel(struct hfc_multi *hc, struct dchannel *dch,\n\t      struct channel_req *rq)\n{\n\tint\terr = 0;\n\tu_long\tflags;\n\n\tif (debug & DEBUG_HW_OPEN)\n\t\tprintk(KERN_DEBUG \"%s: dev(%d) open from %p\\n\", __func__,\n\t\t       dch->dev.id, __builtin_return_address(0));\n\tif (rq->protocol == ISDN_P_NONE)\n\t\treturn -EINVAL;\n\tif ((dch->dev.D.protocol != ISDN_P_NONE) &&\n\t    (dch->dev.D.protocol != rq->protocol)) {\n\t\tif (debug & DEBUG_HFCMULTI_MODE)\n\t\t\tprintk(KERN_DEBUG \"%s: change protocol %x to %x\\n\",\n\t\t\t       __func__, dch->dev.D.protocol, rq->protocol);\n\t}\n\tif ((dch->dev.D.protocol == ISDN_P_TE_S0) &&\n\t    (rq->protocol != ISDN_P_TE_S0))\n\t\tl1_event(dch->l1, CLOSE_CHANNEL);\n\tif (dch->dev.D.protocol != rq->protocol) {\n\t\tif (rq->protocol == ISDN_P_TE_S0) {\n\t\t\terr = create_l1(dch, hfcm_l1callback);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\tdch->dev.D.protocol = rq->protocol;\n\t\tspin_lock_irqsave(&hc->lock, flags);\n\t\thfcmulti_initmode(dch);\n\t\tspin_unlock_irqrestore(&hc->lock, flags);\n\t}\n\tif (test_bit(FLG_ACTIVE, &dch->Flags))\n\t\t_queue_data(&dch->dev.D, PH_ACTIVATE_IND, MISDN_ID_ANY,\n\t\t\t    0, NULL, GFP_KERNEL);\n\trq->ch = &dch->dev.D;\n\tif (!try_module_get(THIS_MODULE))\n\t\tprintk(KERN_WARNING \"%s:cannot get module\\n\", __func__);\n\treturn 0;\n}\n\nstatic int\nopen_bchannel(struct hfc_multi *hc, struct dchannel *dch,\n\t      struct channel_req *rq)\n{\n\tstruct bchannel\t*bch;\n\tint\t\tch;\n\n\tif (!test_channelmap(rq->adr.channel, dch->dev.channelmap))\n\t\treturn -EINVAL;\n\tif (rq->protocol == ISDN_P_NONE)\n\t\treturn -EINVAL;\n\tif (hc->ctype == HFC_TYPE_E1)\n\t\tch = rq->adr.channel;\n\telse\n\t\tch = (rq->adr.channel - 1) + (dch->slot - 2);\n\tbch = hc->chan[ch].bch;\n\tif (!bch) {\n\t\tprintk(KERN_ERR \"%s:internal error ch %d has no bch\\n\",\n\t\t       __func__, ch);\n\t\treturn -EINVAL;\n\t}\n\tif (test_and_set_bit(FLG_OPEN, &bch->Flags))\n\t\treturn -EBUSY;  \n\tbch->ch.protocol = rq->protocol;\n\thc->chan[ch].rx_off = 0;\n\trq->ch = &bch->ch;\n\tif (!try_module_get(THIS_MODULE))\n\t\tprintk(KERN_WARNING \"%s:cannot get module\\n\", __func__);\n\treturn 0;\n}\n\n \nstatic int\nchannel_dctrl(struct dchannel *dch, struct mISDN_ctrl_req *cq)\n{\n\tstruct hfc_multi\t*hc = dch->hw;\n\tint\tret = 0;\n\tint\twd_mode, wd_cnt;\n\n\tswitch (cq->op) {\n\tcase MISDN_CTRL_GETOP:\n\t\tcq->op = MISDN_CTRL_HFC_OP | MISDN_CTRL_L1_TIMER3;\n\t\tbreak;\n\tcase MISDN_CTRL_HFC_WD_INIT:  \n\t\twd_cnt = cq->p1 & 0xf;\n\t\twd_mode = !!(cq->p1 >> 4);\n\t\tif (debug & DEBUG_HFCMULTI_MSG)\n\t\t\tprintk(KERN_DEBUG \"%s: MISDN_CTRL_HFC_WD_INIT mode %s\"\n\t\t\t       \", counter 0x%x\\n\", __func__,\n\t\t\t       wd_mode ? \"AUTO\" : \"MANUAL\", wd_cnt);\n\t\t \n\t\tHFC_outb(hc, R_TI_WD, poll_timer | (wd_cnt << 4));\n\t\thc->hw.r_bert_wd_md = (wd_mode ? V_AUTO_WD_RES : 0);\n\t\tif (hc->ctype == HFC_TYPE_XHFC)\n\t\t\thc->hw.r_bert_wd_md |= 0x40  ;\n\t\t \n\t\tHFC_outb(hc, R_BERT_WD_MD, hc->hw.r_bert_wd_md | V_WD_RES);\n\t\tif (test_bit(HFC_CHIP_PLXSD, &hc->chip)) {\n\t\t\t \n\t\t\tHFC_outb(hc, R_GPIO_SEL,  V_GPIO_SEL7);\n\t\t\tHFC_outb(hc, R_GPIO_EN1,  V_GPIO_EN15);\n\t\t\tHFC_outb(hc, R_GPIO_OUT1, 0);\n\t\t\tHFC_outb(hc, R_GPIO_OUT1, V_GPIO_OUT15);\n\t\t}\n\t\tbreak;\n\tcase MISDN_CTRL_HFC_WD_RESET:  \n\t\tif (debug & DEBUG_HFCMULTI_MSG)\n\t\t\tprintk(KERN_DEBUG \"%s: MISDN_CTRL_HFC_WD_RESET\\n\",\n\t\t\t       __func__);\n\t\tHFC_outb(hc, R_BERT_WD_MD, hc->hw.r_bert_wd_md | V_WD_RES);\n\t\tbreak;\n\tcase MISDN_CTRL_L1_TIMER3:\n\t\tret = l1_event(dch->l1, HW_TIMER3_VALUE | (cq->p1 & 0xff));\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_WARNING \"%s: unknown Op %x\\n\",\n\t\t       __func__, cq->op);\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic int\nhfcm_dctrl(struct mISDNchannel *ch, u_int cmd, void *arg)\n{\n\tstruct mISDNdevice\t*dev = container_of(ch, struct mISDNdevice, D);\n\tstruct dchannel\t\t*dch = container_of(dev, struct dchannel, dev);\n\tstruct hfc_multi\t*hc = dch->hw;\n\tstruct channel_req\t*rq;\n\tint\t\t\terr = 0;\n\tu_long\t\t\tflags;\n\n\tif (dch->debug & DEBUG_HW)\n\t\tprintk(KERN_DEBUG \"%s: cmd:%x %p\\n\",\n\t\t       __func__, cmd, arg);\n\tswitch (cmd) {\n\tcase OPEN_CHANNEL:\n\t\trq = arg;\n\t\tswitch (rq->protocol) {\n\t\tcase ISDN_P_TE_S0:\n\t\tcase ISDN_P_NT_S0:\n\t\t\tif (hc->ctype == HFC_TYPE_E1) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\terr = open_dchannel(hc, dch, rq);  \n\t\t\tbreak;\n\t\tcase ISDN_P_TE_E1:\n\t\tcase ISDN_P_NT_E1:\n\t\t\tif (hc->ctype != HFC_TYPE_E1) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\terr = open_dchannel(hc, dch, rq);  \n\t\t\tbreak;\n\t\tdefault:\n\t\t\tspin_lock_irqsave(&hc->lock, flags);\n\t\t\terr = open_bchannel(hc, dch, rq);\n\t\t\tspin_unlock_irqrestore(&hc->lock, flags);\n\t\t}\n\t\tbreak;\n\tcase CLOSE_CHANNEL:\n\t\tif (debug & DEBUG_HW_OPEN)\n\t\t\tprintk(KERN_DEBUG \"%s: dev(%d) close from %p\\n\",\n\t\t\t       __func__, dch->dev.id,\n\t\t\t       __builtin_return_address(0));\n\t\tmodule_put(THIS_MODULE);\n\t\tbreak;\n\tcase CONTROL_CHANNEL:\n\t\tspin_lock_irqsave(&hc->lock, flags);\n\t\terr = channel_dctrl(dch, arg);\n\t\tspin_unlock_irqrestore(&hc->lock, flags);\n\t\tbreak;\n\tdefault:\n\t\tif (dch->debug & DEBUG_HW)\n\t\t\tprintk(KERN_DEBUG \"%s: unknown command %x\\n\",\n\t\t\t       __func__, cmd);\n\t\terr = -EINVAL;\n\t}\n\treturn err;\n}\n\nstatic int\nclockctl(void *priv, int enable)\n{\n\tstruct hfc_multi *hc = priv;\n\n\thc->iclock_on = enable;\n\treturn 0;\n}\n\n \n\n \nstatic int\ninit_card(struct hfc_multi *hc)\n{\n\tint\terr = -EIO;\n\tu_long\tflags;\n\tvoid\t__iomem *plx_acc;\n\tu_long\tplx_flags;\n\n\tif (debug & DEBUG_HFCMULTI_INIT)\n\t\tprintk(KERN_DEBUG \"%s: entered\\n\", __func__);\n\n\tspin_lock_irqsave(&hc->lock, flags);\n\t \n\thc->hw.r_irq_ctrl = V_FIFO_IRQ;\n\tdisable_hwirq(hc);\n\tspin_unlock_irqrestore(&hc->lock, flags);\n\n\tif (request_irq(hc->irq, hfcmulti_interrupt, IRQF_SHARED,\n\t\t\t\"HFC-multi\", hc)) {\n\t\tprintk(KERN_WARNING \"mISDN: Could not get interrupt %d.\\n\",\n\t\t       hc->irq);\n\t\thc->irq = 0;\n\t\treturn -EIO;\n\t}\n\n\tif (test_bit(HFC_CHIP_PLXSD, &hc->chip)) {\n\t\tspin_lock_irqsave(&plx_lock, plx_flags);\n\t\tplx_acc = hc->plx_membase + PLX_INTCSR;\n\t\twritew((PLX_INTCSR_PCIINT_ENABLE | PLX_INTCSR_LINTI1_ENABLE),\n\t\t       plx_acc);  \n\t\tspin_unlock_irqrestore(&plx_lock, plx_flags);\n\t}\n\n\tif (debug & DEBUG_HFCMULTI_INIT)\n\t\tprintk(KERN_DEBUG \"%s: IRQ %d count %d\\n\",\n\t\t       __func__, hc->irq, hc->irqcnt);\n\terr = init_chip(hc);\n\tif (err)\n\t\tgoto error;\n\t \n\tspin_lock_irqsave(&hc->lock, flags);\n\tenable_hwirq(hc);\n\tspin_unlock_irqrestore(&hc->lock, flags);\n\t \n\tset_current_state(TASK_UNINTERRUPTIBLE);\n\tschedule_timeout((100 * HZ) / 1000);  \n\t \n\tspin_lock_irqsave(&hc->lock, flags);\n\tdisable_hwirq(hc);\n\tspin_unlock_irqrestore(&hc->lock, flags);\n\tif (debug & DEBUG_HFCMULTI_INIT)\n\t\tprintk(KERN_DEBUG \"%s: IRQ %d count %d\\n\",\n\t\t       __func__, hc->irq, hc->irqcnt);\n\tif (hc->irqcnt) {\n\t\tif (debug & DEBUG_HFCMULTI_INIT)\n\t\t\tprintk(KERN_DEBUG \"%s: done\\n\", __func__);\n\n\t\treturn 0;\n\t}\n\tif (test_bit(HFC_CHIP_PCM_SLAVE, &hc->chip)) {\n\t\tprintk(KERN_INFO \"ignoring missing interrupts\\n\");\n\t\treturn 0;\n\t}\n\n\tprintk(KERN_ERR \"HFC PCI: IRQ(%d) getting no interrupts during init.\\n\",\n\t       hc->irq);\n\n\terr = -EIO;\n\nerror:\n\tif (test_bit(HFC_CHIP_PLXSD, &hc->chip)) {\n\t\tspin_lock_irqsave(&plx_lock, plx_flags);\n\t\tplx_acc = hc->plx_membase + PLX_INTCSR;\n\t\twritew(0x00, plx_acc);  \n\t\tspin_unlock_irqrestore(&plx_lock, plx_flags);\n\t}\n\n\tif (debug & DEBUG_HFCMULTI_INIT)\n\t\tprintk(KERN_DEBUG \"%s: free irq %d\\n\", __func__, hc->irq);\n\tif (hc->irq) {\n\t\tfree_irq(hc->irq, hc);\n\t\thc->irq = 0;\n\t}\n\n\tif (debug & DEBUG_HFCMULTI_INIT)\n\t\tprintk(KERN_DEBUG \"%s: done (err=%d)\\n\", __func__, err);\n\treturn err;\n}\n\n \n\nstatic int\nsetup_pci(struct hfc_multi *hc, struct pci_dev *pdev,\n\t  const struct pci_device_id *ent)\n{\n\tstruct hm_map\t*m = (struct hm_map *)ent->driver_data;\n\n\tprintk(KERN_INFO\n\t       \"HFC-multi: card manufacturer: '%s' card name: '%s' clock: %s\\n\",\n\t       m->vendor_name, m->card_name, m->clock2 ? \"double\" : \"normal\");\n\n\thc->pci_dev = pdev;\n\tif (m->clock2)\n\t\ttest_and_set_bit(HFC_CHIP_CLOCK2, &hc->chip);\n\n\tif (ent->vendor == PCI_VENDOR_ID_DIGIUM &&\n\t    ent->device == PCI_DEVICE_ID_DIGIUM_HFC4S) {\n\t\ttest_and_set_bit(HFC_CHIP_B410P, &hc->chip);\n\t\ttest_and_set_bit(HFC_CHIP_PCM_MASTER, &hc->chip);\n\t\ttest_and_clear_bit(HFC_CHIP_PCM_SLAVE, &hc->chip);\n\t\thc->slots = 32;\n\t}\n\n\tif (hc->pci_dev->irq <= 0) {\n\t\tprintk(KERN_WARNING \"HFC-multi: No IRQ for PCI card found.\\n\");\n\t\treturn -EIO;\n\t}\n\tif (pci_enable_device(hc->pci_dev)) {\n\t\tprintk(KERN_WARNING \"HFC-multi: Error enabling PCI card.\\n\");\n\t\treturn -EIO;\n\t}\n\thc->leds = m->leds;\n\thc->ledstate = 0xAFFEAFFE;\n\thc->opticalsupport = m->opticalsupport;\n\n\thc->pci_iobase = 0;\n\thc->pci_membase = NULL;\n\thc->plx_membase = NULL;\n\n\t \n\tif (m->io_mode)  \n\t\thc->io_mode = m->io_mode;\n\tswitch (hc->io_mode) {\n\tcase HFC_IO_MODE_PLXSD:\n\t\ttest_and_set_bit(HFC_CHIP_PLXSD, &hc->chip);\n\t\thc->slots = 128;  \n\t\thc->HFC_outb = HFC_outb_pcimem;\n\t\thc->HFC_inb = HFC_inb_pcimem;\n\t\thc->HFC_inw = HFC_inw_pcimem;\n\t\thc->HFC_wait = HFC_wait_pcimem;\n\t\thc->read_fifo = read_fifo_pcimem;\n\t\thc->write_fifo = write_fifo_pcimem;\n\t\thc->plx_origmembase =  hc->pci_dev->resource[0].start;\n\t\t \n\n\t\tif (!hc->plx_origmembase) {\n\t\t\tprintk(KERN_WARNING\n\t\t\t       \"HFC-multi: No IO-Memory for PCI PLX bridge found\\n\");\n\t\t\tpci_disable_device(hc->pci_dev);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\thc->plx_membase = ioremap(hc->plx_origmembase, 0x80);\n\t\tif (!hc->plx_membase) {\n\t\t\tprintk(KERN_WARNING\n\t\t\t       \"HFC-multi: failed to remap plx address space. \"\n\t\t\t       \"(internal error)\\n\");\n\t\t\tpci_disable_device(hc->pci_dev);\n\t\t\treturn -EIO;\n\t\t}\n\t\tprintk(KERN_INFO\n\t\t       \"HFC-multi: plx_membase:%#lx plx_origmembase:%#lx\\n\",\n\t\t       (u_long)hc->plx_membase, hc->plx_origmembase);\n\n\t\thc->pci_origmembase =  hc->pci_dev->resource[2].start;\n\t\t \n\t\tif (!hc->pci_origmembase) {\n\t\t\tprintk(KERN_WARNING\n\t\t\t       \"HFC-multi: No IO-Memory for PCI card found\\n\");\n\t\t\tpci_disable_device(hc->pci_dev);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\thc->pci_membase = ioremap(hc->pci_origmembase, 0x400);\n\t\tif (!hc->pci_membase) {\n\t\t\tprintk(KERN_WARNING \"HFC-multi: failed to remap io \"\n\t\t\t       \"address space. (internal error)\\n\");\n\t\t\tpci_disable_device(hc->pci_dev);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tprintk(KERN_INFO\n\t\t       \"card %d: defined at MEMBASE %#lx (%#lx) IRQ %d HZ %d \"\n\t\t       \"leds-type %d\\n\",\n\t\t       hc->id, (u_long)hc->pci_membase, hc->pci_origmembase,\n\t\t       hc->pci_dev->irq, HZ, hc->leds);\n\t\tpci_write_config_word(hc->pci_dev, PCI_COMMAND, PCI_ENA_MEMIO);\n\t\tbreak;\n\tcase HFC_IO_MODE_PCIMEM:\n\t\thc->HFC_outb = HFC_outb_pcimem;\n\t\thc->HFC_inb = HFC_inb_pcimem;\n\t\thc->HFC_inw = HFC_inw_pcimem;\n\t\thc->HFC_wait = HFC_wait_pcimem;\n\t\thc->read_fifo = read_fifo_pcimem;\n\t\thc->write_fifo = write_fifo_pcimem;\n\t\thc->pci_origmembase = hc->pci_dev->resource[1].start;\n\t\tif (!hc->pci_origmembase) {\n\t\t\tprintk(KERN_WARNING\n\t\t\t       \"HFC-multi: No IO-Memory for PCI card found\\n\");\n\t\t\tpci_disable_device(hc->pci_dev);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\thc->pci_membase = ioremap(hc->pci_origmembase, 256);\n\t\tif (!hc->pci_membase) {\n\t\t\tprintk(KERN_WARNING\n\t\t\t       \"HFC-multi: failed to remap io address space. \"\n\t\t\t       \"(internal error)\\n\");\n\t\t\tpci_disable_device(hc->pci_dev);\n\t\t\treturn -EIO;\n\t\t}\n\t\tprintk(KERN_INFO \"card %d: defined at MEMBASE %#lx (%#lx) IRQ \"\n\t\t       \"%d HZ %d leds-type %d\\n\", hc->id, (u_long)hc->pci_membase,\n\t\t       hc->pci_origmembase, hc->pci_dev->irq, HZ, hc->leds);\n\t\tpci_write_config_word(hc->pci_dev, PCI_COMMAND, PCI_ENA_MEMIO);\n\t\tbreak;\n\tcase HFC_IO_MODE_REGIO:\n\t\thc->HFC_outb = HFC_outb_regio;\n\t\thc->HFC_inb = HFC_inb_regio;\n\t\thc->HFC_inw = HFC_inw_regio;\n\t\thc->HFC_wait = HFC_wait_regio;\n\t\thc->read_fifo = read_fifo_regio;\n\t\thc->write_fifo = write_fifo_regio;\n\t\thc->pci_iobase = (u_int) hc->pci_dev->resource[0].start;\n\t\tif (!hc->pci_iobase) {\n\t\t\tprintk(KERN_WARNING\n\t\t\t       \"HFC-multi: No IO for PCI card found\\n\");\n\t\t\tpci_disable_device(hc->pci_dev);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tif (!request_region(hc->pci_iobase, 8, \"hfcmulti\")) {\n\t\t\tprintk(KERN_WARNING \"HFC-multi: failed to request \"\n\t\t\t       \"address space at 0x%08lx (internal error)\\n\",\n\t\t\t       hc->pci_iobase);\n\t\t\tpci_disable_device(hc->pci_dev);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tprintk(KERN_INFO\n\t\t       \"%s %s: defined at IOBASE %#x IRQ %d HZ %d leds-type %d\\n\",\n\t\t       m->vendor_name, m->card_name, (u_int) hc->pci_iobase,\n\t\t       hc->pci_dev->irq, HZ, hc->leds);\n\t\tpci_write_config_word(hc->pci_dev, PCI_COMMAND, PCI_ENA_REGIO);\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_WARNING \"HFC-multi: Invalid IO mode.\\n\");\n\t\tpci_disable_device(hc->pci_dev);\n\t\treturn -EIO;\n\t}\n\n\tpci_set_drvdata(hc->pci_dev, hc);\n\n\t \n\t \n\treturn 0;\n}\n\n\n \n\nstatic void\nrelease_port(struct hfc_multi *hc, struct dchannel *dch)\n{\n\tint\tpt, ci, i = 0;\n\tu_long\tflags;\n\tstruct bchannel *pb;\n\n\tci = dch->slot;\n\tpt = hc->chan[ci].port;\n\n\tif (debug & DEBUG_HFCMULTI_INIT)\n\t\tprintk(KERN_DEBUG \"%s: entered for port %d\\n\",\n\t\t       __func__, pt + 1);\n\n\tif (pt >= hc->ports) {\n\t\tprintk(KERN_WARNING \"%s: ERROR port out of range (%d).\\n\",\n\t\t       __func__, pt + 1);\n\t\treturn;\n\t}\n\n\tif (debug & DEBUG_HFCMULTI_INIT)\n\t\tprintk(KERN_DEBUG \"%s: releasing port=%d\\n\",\n\t\t       __func__, pt + 1);\n\n\tif (dch->dev.D.protocol == ISDN_P_TE_S0)\n\t\tl1_event(dch->l1, CLOSE_CHANNEL);\n\n\thc->chan[ci].dch = NULL;\n\n\tif (hc->created[pt]) {\n\t\thc->created[pt] = 0;\n\t\tmISDN_unregister_device(&dch->dev);\n\t}\n\n\tspin_lock_irqsave(&hc->lock, flags);\n\n\tif (dch->timer.function) {\n\t\tdel_timer(&dch->timer);\n\t\tdch->timer.function = NULL;\n\t}\n\n\tif (hc->ctype == HFC_TYPE_E1) {  \n\t\t \n\t\tif (test_bit(HFC_CHIP_PLXSD, &hc->chip)) {\n\t\t\thc->syncronized = 0;\n\t\t\tplxsd_checksync(hc, 1);\n\t\t}\n\t\t \n\t\tfor (i = 0; i <= 31; i++) {\n\t\t\tif (!((1 << i) & hc->bmask[pt]))  \n\t\t\t\tcontinue;\n\t\t\tif (hc->chan[i].bch) {\n\t\t\t\tif (debug & DEBUG_HFCMULTI_INIT)\n\t\t\t\t\tprintk(KERN_DEBUG\n\t\t\t\t\t       \"%s: free port %d channel %d\\n\",\n\t\t\t\t\t       __func__, hc->chan[i].port + 1, i);\n\t\t\t\tpb = hc->chan[i].bch;\n\t\t\t\thc->chan[i].bch = NULL;\n\t\t\t\tspin_unlock_irqrestore(&hc->lock, flags);\n\t\t\t\tmISDN_freebchannel(pb);\n\t\t\t\tkfree(pb);\n\t\t\t\tkfree(hc->chan[i].coeff);\n\t\t\t\tspin_lock_irqsave(&hc->lock, flags);\n\t\t\t}\n\t\t}\n\t} else {\n\t\t \n\t\tif (test_bit(HFC_CHIP_PLXSD, &hc->chip)) {\n\t\t\thc->syncronized &=\n\t\t\t\t~(1 << hc->chan[ci].port);\n\t\t\tplxsd_checksync(hc, 1);\n\t\t}\n\t\t \n\t\tif (hc->chan[ci - 2].bch) {\n\t\t\tif (debug & DEBUG_HFCMULTI_INIT)\n\t\t\t\tprintk(KERN_DEBUG\n\t\t\t\t       \"%s: free port %d channel %d\\n\",\n\t\t\t\t       __func__, hc->chan[ci - 2].port + 1,\n\t\t\t\t       ci - 2);\n\t\t\tpb = hc->chan[ci - 2].bch;\n\t\t\thc->chan[ci - 2].bch = NULL;\n\t\t\tspin_unlock_irqrestore(&hc->lock, flags);\n\t\t\tmISDN_freebchannel(pb);\n\t\t\tkfree(pb);\n\t\t\tkfree(hc->chan[ci - 2].coeff);\n\t\t\tspin_lock_irqsave(&hc->lock, flags);\n\t\t}\n\t\tif (hc->chan[ci - 1].bch) {\n\t\t\tif (debug & DEBUG_HFCMULTI_INIT)\n\t\t\t\tprintk(KERN_DEBUG\n\t\t\t\t       \"%s: free port %d channel %d\\n\",\n\t\t\t\t       __func__, hc->chan[ci - 1].port + 1,\n\t\t\t\t       ci - 1);\n\t\t\tpb = hc->chan[ci - 1].bch;\n\t\t\thc->chan[ci - 1].bch = NULL;\n\t\t\tspin_unlock_irqrestore(&hc->lock, flags);\n\t\t\tmISDN_freebchannel(pb);\n\t\t\tkfree(pb);\n\t\t\tkfree(hc->chan[ci - 1].coeff);\n\t\t\tspin_lock_irqsave(&hc->lock, flags);\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&hc->lock, flags);\n\n\tif (debug & DEBUG_HFCMULTI_INIT)\n\t\tprintk(KERN_DEBUG \"%s: free port %d channel D(%d)\\n\", __func__,\n\t\t\tpt+1, ci);\n\tmISDN_freedchannel(dch);\n\tkfree(dch);\n\n\tif (debug & DEBUG_HFCMULTI_INIT)\n\t\tprintk(KERN_DEBUG \"%s: done!\\n\", __func__);\n}\n\nstatic void\nrelease_card(struct hfc_multi *hc)\n{\n\tu_long\tflags;\n\tint\tch;\n\n\tif (debug & DEBUG_HFCMULTI_INIT)\n\t\tprintk(KERN_DEBUG \"%s: release card (%d) entered\\n\",\n\t\t       __func__, hc->id);\n\n\t \n\tif (hc->iclock)\n\t\tmISDN_unregister_clock(hc->iclock);\n\n\t \n\tspin_lock_irqsave(&hc->lock, flags);\n\tdisable_hwirq(hc);\n\tspin_unlock_irqrestore(&hc->lock, flags);\n\tudelay(1000);\n\tif (hc->irq) {\n\t\tif (debug & DEBUG_HFCMULTI_INIT)\n\t\t\tprintk(KERN_DEBUG \"%s: free irq %d (hc=%p)\\n\",\n\t\t\t    __func__, hc->irq, hc);\n\t\tfree_irq(hc->irq, hc);\n\t\thc->irq = 0;\n\n\t}\n\n\t \n\tif (debug & DEBUG_HFCMULTI_INIT)\n\t\tprintk(KERN_DEBUG \"%s: disable all channels (d and b)\\n\",\n\t\t       __func__);\n\tfor (ch = 0; ch <= 31; ch++) {\n\t\tif (hc->chan[ch].dch)\n\t\t\trelease_port(hc, hc->chan[ch].dch);\n\t}\n\n\t \n\tif (hc->leds)\n\t\thfcmulti_leds(hc);\n\n\t \n\trelease_io_hfcmulti(hc);\n\n\tif (debug & DEBUG_HFCMULTI_INIT)\n\t\tprintk(KERN_DEBUG \"%s: remove instance from list\\n\",\n\t\t       __func__);\n\tlist_del(&hc->list);\n\n\tif (debug & DEBUG_HFCMULTI_INIT)\n\t\tprintk(KERN_DEBUG \"%s: delete instance\\n\", __func__);\n\tif (hc == syncmaster)\n\t\tsyncmaster = NULL;\n\tkfree(hc);\n\tif (debug & DEBUG_HFCMULTI_INIT)\n\t\tprintk(KERN_DEBUG \"%s: card successfully removed\\n\",\n\t\t       __func__);\n}\n\nstatic void\ninit_e1_port_hw(struct hfc_multi *hc, struct hm_map *m)\n{\n\t \n\tif (port[Port_cnt] & 0x001) {\n\t\tif (!m->opticalsupport)  {\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"This board has no optical \"\n\t\t\t       \"support\\n\");\n\t\t} else {\n\t\t\tif (debug & DEBUG_HFCMULTI_INIT)\n\t\t\t\tprintk(KERN_DEBUG\n\t\t\t\t       \"%s: PORT set optical \"\n\t\t\t\t       \"interfacs: card(%d) \"\n\t\t\t\t       \"port(%d)\\n\",\n\t\t\t\t       __func__,\n\t\t\t\t       HFC_cnt + 1, 1);\n\t\t\ttest_and_set_bit(HFC_CFG_OPTICAL,\n\t\t\t    &hc->chan[hc->dnum[0]].cfg);\n\t\t}\n\t}\n\t \n\tif (port[Port_cnt] & 0x004) {\n\t\tif (debug & DEBUG_HFCMULTI_INIT)\n\t\t\tprintk(KERN_DEBUG \"%s: PORT set \"\n\t\t\t       \"LOS report: card(%d) port(%d)\\n\",\n\t\t\t       __func__, HFC_cnt + 1, 1);\n\t\ttest_and_set_bit(HFC_CFG_REPORT_LOS,\n\t\t    &hc->chan[hc->dnum[0]].cfg);\n\t}\n\t \n\tif (port[Port_cnt] & 0x008) {\n\t\tif (debug & DEBUG_HFCMULTI_INIT)\n\t\t\tprintk(KERN_DEBUG \"%s: PORT set \"\n\t\t\t       \"AIS report: card(%d) port(%d)\\n\",\n\t\t\t       __func__, HFC_cnt + 1, 1);\n\t\ttest_and_set_bit(HFC_CFG_REPORT_AIS,\n\t\t    &hc->chan[hc->dnum[0]].cfg);\n\t}\n\t \n\tif (port[Port_cnt] & 0x010) {\n\t\tif (debug & DEBUG_HFCMULTI_INIT)\n\t\t\tprintk(KERN_DEBUG\n\t\t\t       \"%s: PORT set SLIP report: \"\n\t\t\t       \"card(%d) port(%d)\\n\",\n\t\t\t       __func__, HFC_cnt + 1, 1);\n\t\ttest_and_set_bit(HFC_CFG_REPORT_SLIP,\n\t\t    &hc->chan[hc->dnum[0]].cfg);\n\t}\n\t \n\tif (port[Port_cnt] & 0x020) {\n\t\tif (debug & DEBUG_HFCMULTI_INIT)\n\t\t\tprintk(KERN_DEBUG\n\t\t\t       \"%s: PORT set RDI report: \"\n\t\t\t       \"card(%d) port(%d)\\n\",\n\t\t\t       __func__, HFC_cnt + 1, 1);\n\t\ttest_and_set_bit(HFC_CFG_REPORT_RDI,\n\t\t    &hc->chan[hc->dnum[0]].cfg);\n\t}\n\t \n\tif (!(port[Port_cnt] & 0x100)) {\n\t\tif (debug & DEBUG_HFCMULTI_INIT)\n\t\t\tprintk(KERN_DEBUG \"%s: PORT turn on CRC4 report:\"\n\t\t\t       \" card(%d) port(%d)\\n\",\n\t\t\t       __func__, HFC_cnt + 1, 1);\n\t\ttest_and_set_bit(HFC_CFG_CRC4,\n\t\t    &hc->chan[hc->dnum[0]].cfg);\n\t} else {\n\t\tif (debug & DEBUG_HFCMULTI_INIT)\n\t\t\tprintk(KERN_DEBUG \"%s: PORT turn off CRC4\"\n\t\t\t       \" report: card(%d) port(%d)\\n\",\n\t\t\t       __func__, HFC_cnt + 1, 1);\n\t}\n\t \n\tif (port[Port_cnt] & 0x0200) {\n\t\tif (debug & DEBUG_HFCMULTI_INIT)\n\t\t\tprintk(KERN_DEBUG \"%s: PORT force getting clock from \"\n\t\t\t       \"E1: card(%d) port(%d)\\n\",\n\t\t\t       __func__, HFC_cnt + 1, 1);\n\t\ttest_and_set_bit(HFC_CHIP_E1CLOCK_GET, &hc->chip);\n\t} else\n\t\tif (port[Port_cnt] & 0x0400) {\n\t\t\tif (debug & DEBUG_HFCMULTI_INIT)\n\t\t\t\tprintk(KERN_DEBUG \"%s: PORT force putting clock to \"\n\t\t\t\t       \"E1: card(%d) port(%d)\\n\",\n\t\t\t\t       __func__, HFC_cnt + 1, 1);\n\t\t\ttest_and_set_bit(HFC_CHIP_E1CLOCK_PUT, &hc->chip);\n\t\t}\n\t \n\tif (port[Port_cnt] & 0x0800) {\n\t\tif (debug & DEBUG_HFCMULTI_INIT)\n\t\t\tprintk(KERN_DEBUG \"%s: PORT disable JATT PLL on \"\n\t\t\t       \"E1: card(%d) port(%d)\\n\",\n\t\t\t       __func__, HFC_cnt + 1, 1);\n\t\ttest_and_set_bit(HFC_CHIP_RX_SYNC, &hc->chip);\n\t}\n\t \n\tif (port[Port_cnt] & 0x3000) {\n\t\thc->chan[hc->dnum[0]].jitter = (port[Port_cnt]>>12) & 0x3;\n\t\tif (debug & DEBUG_HFCMULTI_INIT)\n\t\t\tprintk(KERN_DEBUG\n\t\t\t       \"%s: PORT set elastic \"\n\t\t\t       \"buffer to %d: card(%d) port(%d)\\n\",\n\t\t\t    __func__, hc->chan[hc->dnum[0]].jitter,\n\t\t\t       HFC_cnt + 1, 1);\n\t} else\n\t\thc->chan[hc->dnum[0]].jitter = 2;  \n}\n\nstatic int\ninit_e1_port(struct hfc_multi *hc, struct hm_map *m, int pt)\n{\n\tstruct dchannel\t*dch;\n\tstruct bchannel\t*bch;\n\tint\t\tch, ret = 0;\n\tchar\t\tname[MISDN_MAX_IDLEN];\n\tint\t\tbcount = 0;\n\n\tdch = kzalloc(sizeof(struct dchannel), GFP_KERNEL);\n\tif (!dch)\n\t\treturn -ENOMEM;\n\tdch->debug = debug;\n\tmISDN_initdchannel(dch, MAX_DFRAME_LEN_L1, ph_state_change);\n\tdch->hw = hc;\n\tdch->dev.Dprotocols = (1 << ISDN_P_TE_E1) | (1 << ISDN_P_NT_E1);\n\tdch->dev.Bprotocols = (1 << (ISDN_P_B_RAW & ISDN_P_B_MASK)) |\n\t    (1 << (ISDN_P_B_HDLC & ISDN_P_B_MASK));\n\tdch->dev.D.send = handle_dmsg;\n\tdch->dev.D.ctrl = hfcm_dctrl;\n\tdch->slot = hc->dnum[pt];\n\thc->chan[hc->dnum[pt]].dch = dch;\n\thc->chan[hc->dnum[pt]].port = pt;\n\thc->chan[hc->dnum[pt]].nt_timer = -1;\n\tfor (ch = 1; ch <= 31; ch++) {\n\t\tif (!((1 << ch) & hc->bmask[pt]))  \n\t\t\tcontinue;\n\t\tbch = kzalloc(sizeof(struct bchannel), GFP_KERNEL);\n\t\tif (!bch) {\n\t\t\tprintk(KERN_ERR \"%s: no memory for bchannel\\n\",\n\t\t\t    __func__);\n\t\t\tret = -ENOMEM;\n\t\t\tgoto free_chan;\n\t\t}\n\t\thc->chan[ch].coeff = kzalloc(512, GFP_KERNEL);\n\t\tif (!hc->chan[ch].coeff) {\n\t\t\tprintk(KERN_ERR \"%s: no memory for coeffs\\n\",\n\t\t\t    __func__);\n\t\t\tret = -ENOMEM;\n\t\t\tkfree(bch);\n\t\t\tgoto free_chan;\n\t\t}\n\t\tbch->nr = ch;\n\t\tbch->slot = ch;\n\t\tbch->debug = debug;\n\t\tmISDN_initbchannel(bch, MAX_DATA_MEM, poll >> 1);\n\t\tbch->hw = hc;\n\t\tbch->ch.send = handle_bmsg;\n\t\tbch->ch.ctrl = hfcm_bctrl;\n\t\tbch->ch.nr = ch;\n\t\tlist_add(&bch->ch.list, &dch->dev.bchannels);\n\t\thc->chan[ch].bch = bch;\n\t\thc->chan[ch].port = pt;\n\t\tset_channelmap(bch->nr, dch->dev.channelmap);\n\t\tbcount++;\n\t}\n\tdch->dev.nrbchan = bcount;\n\tif (pt == 0)\n\t\tinit_e1_port_hw(hc, m);\n\tif (hc->ports > 1)\n\t\tsnprintf(name, MISDN_MAX_IDLEN - 1, \"hfc-e1.%d-%d\",\n\t\t\t\tHFC_cnt + 1, pt+1);\n\telse\n\t\tsnprintf(name, MISDN_MAX_IDLEN - 1, \"hfc-e1.%d\", HFC_cnt + 1);\n\tret = mISDN_register_device(&dch->dev, &hc->pci_dev->dev, name);\n\tif (ret)\n\t\tgoto free_chan;\n\thc->created[pt] = 1;\n\treturn ret;\nfree_chan:\n\trelease_port(hc, dch);\n\treturn ret;\n}\n\nstatic int\ninit_multi_port(struct hfc_multi *hc, int pt)\n{\n\tstruct dchannel\t*dch;\n\tstruct bchannel\t*bch;\n\tint\t\tch, i, ret = 0;\n\tchar\t\tname[MISDN_MAX_IDLEN];\n\n\tdch = kzalloc(sizeof(struct dchannel), GFP_KERNEL);\n\tif (!dch)\n\t\treturn -ENOMEM;\n\tdch->debug = debug;\n\tmISDN_initdchannel(dch, MAX_DFRAME_LEN_L1, ph_state_change);\n\tdch->hw = hc;\n\tdch->dev.Dprotocols = (1 << ISDN_P_TE_S0) | (1 << ISDN_P_NT_S0);\n\tdch->dev.Bprotocols = (1 << (ISDN_P_B_RAW & ISDN_P_B_MASK)) |\n\t\t(1 << (ISDN_P_B_HDLC & ISDN_P_B_MASK));\n\tdch->dev.D.send = handle_dmsg;\n\tdch->dev.D.ctrl = hfcm_dctrl;\n\tdch->dev.nrbchan = 2;\n\ti = pt << 2;\n\tdch->slot = i + 2;\n\thc->chan[i + 2].dch = dch;\n\thc->chan[i + 2].port = pt;\n\thc->chan[i + 2].nt_timer = -1;\n\tfor (ch = 0; ch < dch->dev.nrbchan; ch++) {\n\t\tbch = kzalloc(sizeof(struct bchannel), GFP_KERNEL);\n\t\tif (!bch) {\n\t\t\tprintk(KERN_ERR \"%s: no memory for bchannel\\n\",\n\t\t\t       __func__);\n\t\t\tret = -ENOMEM;\n\t\t\tgoto free_chan;\n\t\t}\n\t\thc->chan[i + ch].coeff = kzalloc(512, GFP_KERNEL);\n\t\tif (!hc->chan[i + ch].coeff) {\n\t\t\tprintk(KERN_ERR \"%s: no memory for coeffs\\n\",\n\t\t\t       __func__);\n\t\t\tret = -ENOMEM;\n\t\t\tkfree(bch);\n\t\t\tgoto free_chan;\n\t\t}\n\t\tbch->nr = ch + 1;\n\t\tbch->slot = i + ch;\n\t\tbch->debug = debug;\n\t\tmISDN_initbchannel(bch, MAX_DATA_MEM, poll >> 1);\n\t\tbch->hw = hc;\n\t\tbch->ch.send = handle_bmsg;\n\t\tbch->ch.ctrl = hfcm_bctrl;\n\t\tbch->ch.nr = ch + 1;\n\t\tlist_add(&bch->ch.list, &dch->dev.bchannels);\n\t\thc->chan[i + ch].bch = bch;\n\t\thc->chan[i + ch].port = pt;\n\t\tset_channelmap(bch->nr, dch->dev.channelmap);\n\t}\n\t \n\tif (port[Port_cnt] & 0x001) {\n\t\tif (debug & DEBUG_HFCMULTI_INIT)\n\t\t\tprintk(KERN_DEBUG\n\t\t\t       \"%s: PROTOCOL set master clock: \"\n\t\t\t       \"card(%d) port(%d)\\n\",\n\t\t\t       __func__, HFC_cnt + 1, pt + 1);\n\t\tif (dch->dev.D.protocol != ISDN_P_TE_S0) {\n\t\t\tprintk(KERN_ERR \"Error: Master clock \"\n\t\t\t       \"for port(%d) of card(%d) is only\"\n\t\t\t       \" possible with TE-mode\\n\",\n\t\t\t       pt + 1, HFC_cnt + 1);\n\t\t\tret = -EINVAL;\n\t\t\tgoto free_chan;\n\t\t}\n\t\tif (hc->masterclk >= 0) {\n\t\t\tprintk(KERN_ERR \"Error: Master clock \"\n\t\t\t       \"for port(%d) of card(%d) already \"\n\t\t\t       \"defined for port(%d)\\n\",\n\t\t\t       pt + 1, HFC_cnt + 1, hc->masterclk + 1);\n\t\t\tret = -EINVAL;\n\t\t\tgoto free_chan;\n\t\t}\n\t\thc->masterclk = pt;\n\t}\n\t \n\tif (port[Port_cnt] & 0x002) {\n\t\tif (debug & DEBUG_HFCMULTI_INIT)\n\t\t\tprintk(KERN_DEBUG\n\t\t\t       \"%s: PROTOCOL set non capacitive \"\n\t\t\t       \"transmitter: card(%d) port(%d)\\n\",\n\t\t\t       __func__, HFC_cnt + 1, pt + 1);\n\t\ttest_and_set_bit(HFC_CFG_NONCAP_TX,\n\t\t\t\t &hc->chan[i + 2].cfg);\n\t}\n\t \n\tif (port[Port_cnt] & 0x004) {\n\t\tif (debug & DEBUG_HFCMULTI_INIT)\n\t\t\tprintk(KERN_DEBUG\n\t\t\t       \"%s: PROTOCOL disable E-channel: \"\n\t\t\t       \"card(%d) port(%d)\\n\",\n\t\t\t       __func__, HFC_cnt + 1, pt + 1);\n\t\ttest_and_set_bit(HFC_CFG_DIS_ECHANNEL,\n\t\t\t\t &hc->chan[i + 2].cfg);\n\t}\n\tif (hc->ctype == HFC_TYPE_XHFC) {\n\t\tsnprintf(name, MISDN_MAX_IDLEN - 1, \"xhfc.%d-%d\",\n\t\t\t HFC_cnt + 1, pt + 1);\n\t\tret = mISDN_register_device(&dch->dev, NULL, name);\n\t} else {\n\t\tsnprintf(name, MISDN_MAX_IDLEN - 1, \"hfc-%ds.%d-%d\",\n\t\t\t hc->ctype, HFC_cnt + 1, pt + 1);\n\t\tret = mISDN_register_device(&dch->dev, &hc->pci_dev->dev, name);\n\t}\n\tif (ret)\n\t\tgoto free_chan;\n\thc->created[pt] = 1;\n\treturn ret;\nfree_chan:\n\trelease_port(hc, dch);\n\treturn ret;\n}\n\nstatic int\nhfcmulti_init(struct hm_map *m, struct pci_dev *pdev,\n\t      const struct pci_device_id *ent)\n{\n\tint\t\tret_err = 0;\n\tint\t\tpt;\n\tstruct hfc_multi\t*hc;\n\tu_long\t\tflags;\n\tu_char\t\tdips = 0, pmj = 0;  \n\tint\t\ti, ch;\n\tu_int\t\tmaskcheck;\n\n\tif (HFC_cnt >= MAX_CARDS) {\n\t\tprintk(KERN_ERR \"too many cards (max=%d).\\n\",\n\t\t       MAX_CARDS);\n\t\treturn -EINVAL;\n\t}\n\tif ((type[HFC_cnt] & 0xff) && (type[HFC_cnt] & 0xff) != m->type) {\n\t\tprintk(KERN_WARNING \"HFC-MULTI: Card '%s:%s' type %d found but \"\n\t\t       \"type[%d] %d was supplied as module parameter\\n\",\n\t\t       m->vendor_name, m->card_name, m->type, HFC_cnt,\n\t\t       type[HFC_cnt] & 0xff);\n\t\tprintk(KERN_WARNING \"HFC-MULTI: Load module without parameters \"\n\t\t       \"first, to see cards and their types.\");\n\t\treturn -EINVAL;\n\t}\n\tif (debug & DEBUG_HFCMULTI_INIT)\n\t\tprintk(KERN_DEBUG \"%s: Registering %s:%s chip type %d (0x%x)\\n\",\n\t\t       __func__, m->vendor_name, m->card_name, m->type,\n\t\t       type[HFC_cnt]);\n\n\t \n\thc = kzalloc(sizeof(struct hfc_multi), GFP_KERNEL);\n\tif (!hc) {\n\t\tprintk(KERN_ERR \"No kmem for HFC-Multi card\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tspin_lock_init(&hc->lock);\n\thc->mtyp = m;\n\thc->ctype =  m->type;\n\thc->ports = m->ports;\n\thc->id = HFC_cnt;\n\thc->pcm = pcm[HFC_cnt];\n\thc->io_mode = iomode[HFC_cnt];\n\tif (hc->ctype == HFC_TYPE_E1 && dmask[E1_cnt]) {\n\t\t \n\t\tpt = 0;\n\t\tmaskcheck = 0;\n\t\tfor (ch = 0; ch <= 31; ch++) {\n\t\t\tif (!((1 << ch) & dmask[E1_cnt]))\n\t\t\t\tcontinue;\n\t\t\thc->dnum[pt] = ch;\n\t\t\thc->bmask[pt] = bmask[bmask_cnt++];\n\t\t\tif ((maskcheck & hc->bmask[pt])\n\t\t\t || (dmask[E1_cnt] & hc->bmask[pt])) {\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"HFC-E1 #%d has overlapping B-channels on fragment #%d\\n\",\n\t\t\t\t       E1_cnt + 1, pt);\n\t\t\t\tkfree(hc);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tmaskcheck |= hc->bmask[pt];\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"HFC-E1 #%d uses D-channel on slot %d and a B-channel map of 0x%08x\\n\",\n\t\t\t\tE1_cnt + 1, ch, hc->bmask[pt]);\n\t\t\tpt++;\n\t\t}\n\t\thc->ports = pt;\n\t}\n\tif (hc->ctype == HFC_TYPE_E1 && !dmask[E1_cnt]) {\n\t\t \n\t\thc->dnum[0] = 16;\n\t\thc->bmask[0] = 0xfffefffe;\n\t\thc->ports = 1;\n\t}\n\n\t \n\thc->masterclk = -1;\n\tif (type[HFC_cnt] & 0x100) {\n\t\ttest_and_set_bit(HFC_CHIP_ULAW, &hc->chip);\n\t\thc->silence = 0xff;  \n\t} else\n\t\thc->silence = 0x2a;  \n\tif ((poll >> 1) > sizeof(hc->silence_data)) {\n\t\tprintk(KERN_ERR \"HFCMULTI error: silence_data too small, \"\n\t\t       \"please fix\\n\");\n\t\tkfree(hc);\n\t\treturn -EINVAL;\n\t}\n\tfor (i = 0; i < (poll >> 1); i++)\n\t\thc->silence_data[i] = hc->silence;\n\n\tif (hc->ctype != HFC_TYPE_XHFC) {\n\t\tif (!(type[HFC_cnt] & 0x200))\n\t\t\ttest_and_set_bit(HFC_CHIP_DTMF, &hc->chip);\n\t\ttest_and_set_bit(HFC_CHIP_CONF, &hc->chip);\n\t}\n\n\tif (type[HFC_cnt] & 0x800)\n\t\ttest_and_set_bit(HFC_CHIP_PCM_SLAVE, &hc->chip);\n\tif (type[HFC_cnt] & 0x1000) {\n\t\ttest_and_set_bit(HFC_CHIP_PCM_MASTER, &hc->chip);\n\t\ttest_and_clear_bit(HFC_CHIP_PCM_SLAVE, &hc->chip);\n\t}\n\tif (type[HFC_cnt] & 0x4000)\n\t\ttest_and_set_bit(HFC_CHIP_EXRAM_128, &hc->chip);\n\tif (type[HFC_cnt] & 0x8000)\n\t\ttest_and_set_bit(HFC_CHIP_EXRAM_512, &hc->chip);\n\thc->slots = 32;\n\tif (type[HFC_cnt] & 0x10000)\n\t\thc->slots = 64;\n\tif (type[HFC_cnt] & 0x20000)\n\t\thc->slots = 128;\n\tif (type[HFC_cnt] & 0x80000) {\n\t\ttest_and_set_bit(HFC_CHIP_WATCHDOG, &hc->chip);\n\t\thc->wdcount = 0;\n\t\thc->wdbyte = V_GPIO_OUT2;\n\t\tprintk(KERN_NOTICE \"Watchdog enabled\\n\");\n\t}\n\n\tif (pdev && ent)\n\t\t \n\t\tret_err = setup_pci(hc, pdev, ent);\n\telse\n#ifdef CONFIG_MISDN_HFCMULTI_8xx\n\t\tret_err = setup_embedded(hc, m);\n#else\n\t{\n\t\tprintk(KERN_WARNING \"Embedded IO Mode not selected\\n\");\n\t\tret_err = -EIO;\n\t}\n#endif\n\tif (ret_err) {\n\t\tif (hc == syncmaster)\n\t\t\tsyncmaster = NULL;\n\t\tkfree(hc);\n\t\treturn ret_err;\n\t}\n\n\thc->HFC_outb_nodebug = hc->HFC_outb;\n\thc->HFC_inb_nodebug = hc->HFC_inb;\n\thc->HFC_inw_nodebug = hc->HFC_inw;\n\thc->HFC_wait_nodebug = hc->HFC_wait;\n#ifdef HFC_REGISTER_DEBUG\n\thc->HFC_outb = HFC_outb_debug;\n\thc->HFC_inb = HFC_inb_debug;\n\thc->HFC_inw = HFC_inw_debug;\n\thc->HFC_wait = HFC_wait_debug;\n#endif\n\t \n\tfor (pt = 0; pt < hc->ports; pt++) {\n\t\tif (Port_cnt >= MAX_PORTS) {\n\t\t\tprintk(KERN_ERR \"too many ports (max=%d).\\n\",\n\t\t\t       MAX_PORTS);\n\t\t\tret_err = -EINVAL;\n\t\t\tgoto free_card;\n\t\t}\n\t\tif (hc->ctype == HFC_TYPE_E1)\n\t\t\tret_err = init_e1_port(hc, m, pt);\n\t\telse\n\t\t\tret_err = init_multi_port(hc, pt);\n\t\tif (debug & DEBUG_HFCMULTI_INIT)\n\t\t\tprintk(KERN_DEBUG\n\t\t\t    \"%s: Registering D-channel, card(%d) port(%d) \"\n\t\t\t       \"result %d\\n\",\n\t\t\t    __func__, HFC_cnt + 1, pt + 1, ret_err);\n\n\t\tif (ret_err) {\n\t\t\twhile (pt) {  \n\t\t\t\tpt--;\n\t\t\t\tif (hc->ctype == HFC_TYPE_E1)\n\t\t\t\t\trelease_port(hc,\n\t\t\t\t\t\thc->chan[hc->dnum[pt]].dch);\n\t\t\t\telse\n\t\t\t\t\trelease_port(hc,\n\t\t\t\t\t\thc->chan[(pt << 2) + 2].dch);\n\t\t\t}\n\t\t\tgoto free_card;\n\t\t}\n\t\tif (hc->ctype != HFC_TYPE_E1)\n\t\t\tPort_cnt++;  \n\t}\n\tif (hc->ctype == HFC_TYPE_E1) {\n\t\tPort_cnt++;  \n\t\tE1_cnt++;\n\t}\n\n\t \n\tswitch (m->dip_type) {\n\tcase DIP_4S:\n\t\t \n\t\tdips = ((~HFC_inb(hc, R_GPIO_IN1) & 0xE0) >> 5) |\n\t\t\t((~HFC_inb(hc, R_GPI_IN2) & 0x80) >> 3) |\n\t\t\t(~HFC_inb(hc, R_GPI_IN2) & 0x08);\n\n\t\t \n\t\tpmj = ((HFC_inb(hc, R_GPI_IN3) >> 4)  & 0xf);\n\n\t\tif (test_bit(HFC_CHIP_B410P, &hc->chip))\n\t\t\tpmj = ~pmj & 0xf;\n\n\t\tprintk(KERN_INFO \"%s: %s DIPs(0x%x) jumpers(0x%x)\\n\",\n\t\t       m->vendor_name, m->card_name, dips, pmj);\n\t\tbreak;\n\tcase DIP_8S:\n\t\t \n\t\tHFC_outb(hc, R_BRG_PCM_CFG, 1 | V_PCM_CLK);\n\t\t \n\t\toutw(0x4000, hc->pci_iobase + 4);\n\t\t \n\t\tdips = inb(hc->pci_iobase);\n\t\tdips = inb(hc->pci_iobase);\n\t\tdips = inb(hc->pci_iobase);\n\t\tdips = ~inb(hc->pci_iobase) & 0x3F;\n\t\toutw(0x0, hc->pci_iobase + 4);\n\t\t \n\t\tHFC_outb(hc, R_BRG_PCM_CFG, V_PCM_CLK);\n\t\tprintk(KERN_INFO \"%s: %s DIPs(0x%x)\\n\",\n\t\t       m->vendor_name, m->card_name, dips);\n\t\tbreak;\n\tcase DIP_E1:\n\t\t \n\t\tdips = (~HFC_inb(hc, R_GPI_IN0) & 0xF0) >> 4;\n\t\tprintk(KERN_INFO \"%s: %s DIPs(0x%x)\\n\",\n\t\t       m->vendor_name, m->card_name, dips);\n\t\tbreak;\n\t}\n\n\t \n\tspin_lock_irqsave(&HFClock, flags);\n\tlist_add_tail(&hc->list, &HFClist);\n\tspin_unlock_irqrestore(&HFClock, flags);\n\n\t \n\tif (clock == HFC_cnt + 1)\n\t\thc->iclock = mISDN_register_clock(\"HFCMulti\", 0, clockctl, hc);\n\n\t \n\thc->irq = (m->irq) ? : hc->pci_dev->irq;\n\tret_err = init_card(hc);\n\tif (ret_err) {\n\t\tprintk(KERN_ERR \"init card returns %d\\n\", ret_err);\n\t\trelease_card(hc);\n\t\treturn ret_err;\n\t}\n\n\t \n\tspin_lock_irqsave(&hc->lock, flags);\n\tenable_hwirq(hc);\n\tspin_unlock_irqrestore(&hc->lock, flags);\n\treturn 0;\n\nfree_card:\n\trelease_io_hfcmulti(hc);\n\tif (hc == syncmaster)\n\t\tsyncmaster = NULL;\n\tkfree(hc);\n\treturn ret_err;\n}\n\nstatic void hfc_remove_pci(struct pci_dev *pdev)\n{\n\tstruct hfc_multi\t*card = pci_get_drvdata(pdev);\n\tu_long\t\t\tflags;\n\n\tif (debug)\n\t\tprintk(KERN_INFO \"removing hfc_multi card vendor:%x \"\n\t\t       \"device:%x subvendor:%x subdevice:%x\\n\",\n\t\t       pdev->vendor, pdev->device,\n\t\t       pdev->subsystem_vendor, pdev->subsystem_device);\n\n\tif (card) {\n\t\tspin_lock_irqsave(&HFClock, flags);\n\t\trelease_card(card);\n\t\tspin_unlock_irqrestore(&HFClock, flags);\n\t}  else {\n\t\tif (debug)\n\t\t\tprintk(KERN_DEBUG \"%s: drvdata already removed\\n\",\n\t\t\t       __func__);\n\t}\n}\n\n#define\tVENDOR_CCD\t\"Cologne Chip AG\"\n#define\tVENDOR_BN\t\"beroNet GmbH\"\n#define\tVENDOR_DIG\t\"Digium Inc.\"\n#define VENDOR_JH\t\"Junghanns.NET GmbH\"\n#define VENDOR_PRIM\t\"PrimuX\"\n\nstatic const struct hm_map hfcm_map[] = {\n\t \t{VENDOR_BN, \"HFC-1S Card (mini PCI)\", 4, 1, 1, 3, 0, DIP_4S, 0, 0},\n\t \t{VENDOR_BN, \"HFC-2S Card\", 4, 2, 1, 3, 0, DIP_4S, 0, 0},\n\t \t{VENDOR_BN, \"HFC-2S Card (mini PCI)\", 4, 2, 1, 3, 0, DIP_4S, 0, 0},\n\t \t{VENDOR_BN, \"HFC-4S Card\", 4, 4, 1, 2, 0, DIP_4S, 0, 0},\n\t \t{VENDOR_BN, \"HFC-4S Card (mini PCI)\", 4, 4, 1, 2, 0, 0, 0, 0},\n\t \t{VENDOR_CCD, \"HFC-4S Eval (old)\", 4, 4, 0, 0, 0, 0, 0, 0},\n\t \t{VENDOR_CCD, \"HFC-4S IOB4ST\", 4, 4, 1, 2, 0, DIP_4S, 0, 0},\n\t \t{VENDOR_CCD, \"HFC-4S\", 4, 4, 1, 2, 0, 0, 0, 0},\n\t \t{VENDOR_DIG, \"HFC-4S Card\", 4, 4, 0, 2, 0, 0, HFC_IO_MODE_REGIO, 0},\n\t \t{VENDOR_CCD, \"HFC-4S Swyx 4xS0 SX2 QuadBri\", 4, 4, 1, 2, 0, 0, 0, 0},\n\t \t{VENDOR_JH, \"HFC-4S (junghanns 2.0)\", 4, 4, 1, 2, 0, 0, 0, 0},\n\t \t{VENDOR_PRIM, \"HFC-2S Primux Card\", 4, 2, 0, 0, 0, 0, 0, 0},\n\n\t \t{VENDOR_BN, \"HFC-8S Card\", 8, 8, 1, 0, 0, 0, 0, 0},\n\t \t{VENDOR_BN, \"HFC-8S Card (+)\", 8, 8, 1, 8, 0, DIP_8S,\n\t\t HFC_IO_MODE_REGIO, 0},\n\t \t{VENDOR_CCD, \"HFC-8S Eval (old)\", 8, 8, 0, 0, 0, 0, 0, 0},\n\t \t{VENDOR_CCD, \"HFC-8S IOB4ST Recording\", 8, 8, 1, 0, 0, 0, 0, 0},\n\n\t \t{VENDOR_CCD, \"HFC-8S IOB8ST\", 8, 8, 1, 0, 0, 0, 0, 0},\n\t \t{VENDOR_CCD, \"HFC-8S\", 8, 8, 1, 0, 0, 0, 0, 0},\n\t \t{VENDOR_CCD, \"HFC-8S\", 8, 8, 1, 0, 0, 0, 0, 0},\n\n\t \t{VENDOR_BN, \"HFC-E1 Card\", 1, 1, 0, 1, 0, DIP_E1, 0, 0},\n\t \t{VENDOR_BN, \"HFC-E1 Card (mini PCI)\", 1, 1, 0, 1, 0, 0, 0, 0},\n\t \t{VENDOR_BN, \"HFC-E1+ Card (Dual)\", 1, 1, 0, 1, 0, DIP_E1, 0, 0},\n\t \t{VENDOR_BN, \"HFC-E1 Card (Dual)\", 1, 1, 0, 1, 0, DIP_E1, 0, 0},\n\n\t \t{VENDOR_CCD, \"HFC-E1 Eval (old)\", 1, 1, 0, 0, 0, 0, 0, 0},\n\t \t{VENDOR_CCD, \"HFC-E1 IOB1E1\", 1, 1, 0, 1, 0, 0, 0, 0},\n\t \t{VENDOR_CCD, \"HFC-E1\", 1, 1, 0, 1, 0, 0, 0, 0},\n\n\t \t{VENDOR_CCD, \"HFC-4S Speech Design\", 4, 4, 0, 0, 0, 0,\n\t\t HFC_IO_MODE_PLXSD, 0},\n\t \t{VENDOR_CCD, \"HFC-E1 Speech Design\", 1, 1, 0, 0, 0, 0,\n\t\t HFC_IO_MODE_PLXSD, 0},\n\t \t{VENDOR_CCD, \"HFC-4S OpenVox\", 4, 4, 1, 0, 0, 0, 0, 0},\n\t \t{VENDOR_CCD, \"HFC-2S OpenVox\", 4, 2, 1, 0, 0, 0, 0, 0},\n\t \t{VENDOR_CCD, \"HFC-8S OpenVox\", 8, 8, 1, 0, 0, 0, 0, 0},\n\t \t{VENDOR_CCD, \"XHFC-4S Speech Design\", 5, 4, 0, 0, 0, 0,\n\t\t HFC_IO_MODE_EMBSD, XHFC_IRQ},\n\t \t{VENDOR_JH, \"HFC-8S (junghanns)\", 8, 8, 1, 0, 0, 0, 0, 0},\n\t \t{VENDOR_BN, \"HFC-2S Beronet Card PCIe\", 4, 2, 1, 3, 0, DIP_4S, 0, 0},\n\t \t{VENDOR_BN, \"HFC-4S Beronet Card PCIe\", 4, 4, 1, 2, 0, DIP_4S, 0, 0},\n};\n\n#undef H\n#define H(x)\t((unsigned long)&hfcm_map[x])\nstatic const struct pci_device_id hfmultipci_ids[] = {\n\n\t \n\t{ PCI_VENDOR_ID_CCD, PCI_DEVICE_ID_CCD_HFC4S, PCI_VENDOR_ID_CCD,\n\t  PCI_SUBDEVICE_ID_CCD_BN1SM, 0, 0, H(0)},  \n\t{ PCI_VENDOR_ID_CCD, PCI_DEVICE_ID_CCD_HFC4S, PCI_VENDOR_ID_CCD,\n\t  PCI_SUBDEVICE_ID_CCD_BN2S, 0, 0, H(1)},  \n\t{ PCI_VENDOR_ID_CCD, PCI_DEVICE_ID_CCD_HFC4S, PCI_VENDOR_ID_CCD,\n\t  PCI_SUBDEVICE_ID_CCD_BN2SM, 0, 0, H(2)},  \n\t{ PCI_VENDOR_ID_CCD, PCI_DEVICE_ID_CCD_HFC4S, PCI_VENDOR_ID_CCD,\n\t  PCI_SUBDEVICE_ID_CCD_BN4S, 0, 0, H(3)},  \n\t{ PCI_VENDOR_ID_CCD, PCI_DEVICE_ID_CCD_HFC4S, PCI_VENDOR_ID_CCD,\n\t  PCI_SUBDEVICE_ID_CCD_BN4SM, 0, 0, H(4)},  \n\t{ PCI_VENDOR_ID_CCD, PCI_DEVICE_ID_CCD_HFC4S, PCI_VENDOR_ID_CCD,\n\t  PCI_DEVICE_ID_CCD_HFC4S, 0, 0, H(5)},  \n\t{ PCI_VENDOR_ID_CCD, PCI_DEVICE_ID_CCD_HFC4S, PCI_VENDOR_ID_CCD,\n\t  PCI_SUBDEVICE_ID_CCD_IOB4ST, 0, 0, H(6)},  \n\t{ PCI_VENDOR_ID_CCD, PCI_DEVICE_ID_CCD_HFC4S, PCI_VENDOR_ID_CCD,\n\t  PCI_SUBDEVICE_ID_CCD_HFC4S, 0, 0, H(7)},  \n\t{ PCI_VENDOR_ID_DIGIUM, PCI_DEVICE_ID_DIGIUM_HFC4S,\n\t  PCI_VENDOR_ID_DIGIUM, PCI_DEVICE_ID_DIGIUM_HFC4S, 0, 0, H(8)},\n\t{ PCI_VENDOR_ID_CCD, PCI_DEVICE_ID_CCD_HFC4S, PCI_VENDOR_ID_CCD,\n\t  PCI_SUBDEVICE_ID_CCD_SWYX4S, 0, 0, H(9)},  \n\t{ PCI_VENDOR_ID_CCD, PCI_DEVICE_ID_CCD_HFC4S, PCI_VENDOR_ID_CCD,\n\t  PCI_SUBDEVICE_ID_CCD_JH4S20, 0, 0, H(10)},\n\t{ PCI_VENDOR_ID_CCD, PCI_DEVICE_ID_CCD_HFC4S, PCI_VENDOR_ID_CCD,\n\t  PCI_SUBDEVICE_ID_CCD_PMX2S, 0, 0, H(11)},  \n\t{ PCI_VENDOR_ID_CCD, PCI_DEVICE_ID_CCD_HFC4S, PCI_VENDOR_ID_CCD,\n\t  PCI_SUBDEVICE_ID_CCD_OV4S, 0, 0, H(28)},  \n\t{ PCI_VENDOR_ID_CCD, PCI_DEVICE_ID_CCD_HFC4S, PCI_VENDOR_ID_CCD,\n\t  PCI_SUBDEVICE_ID_CCD_OV2S, 0, 0, H(29)},  \n\t{ PCI_VENDOR_ID_CCD, PCI_DEVICE_ID_CCD_HFC4S, PCI_VENDOR_ID_CCD,\n\t  0xb761, 0, 0, H(33)},  \n\t{ PCI_VENDOR_ID_CCD, PCI_DEVICE_ID_CCD_HFC4S, PCI_VENDOR_ID_CCD,\n\t  0xb762, 0, 0, H(34)},  \n\n\t \n\t{ PCI_VENDOR_ID_CCD, PCI_DEVICE_ID_CCD_HFC8S, PCI_VENDOR_ID_CCD,\n\t  PCI_SUBDEVICE_ID_CCD_BN8S, 0, 0, H(12)},  \n\t{ PCI_VENDOR_ID_CCD, PCI_DEVICE_ID_CCD_HFC8S, PCI_VENDOR_ID_CCD,\n\t  PCI_SUBDEVICE_ID_CCD_BN8SP, 0, 0, H(13)},  \n\t{ PCI_VENDOR_ID_CCD, PCI_DEVICE_ID_CCD_HFC8S, PCI_VENDOR_ID_CCD,\n\t  PCI_DEVICE_ID_CCD_HFC8S, 0, 0, H(14)},  \n\t{ PCI_VENDOR_ID_CCD, PCI_DEVICE_ID_CCD_HFC8S, PCI_VENDOR_ID_CCD,\n\t  PCI_SUBDEVICE_ID_CCD_IOB8STR, 0, 0, H(15)},  \n\t{ PCI_VENDOR_ID_CCD, PCI_DEVICE_ID_CCD_HFC8S, PCI_VENDOR_ID_CCD,\n\t  PCI_SUBDEVICE_ID_CCD_IOB8ST, 0, 0, H(16)},  \n\t{ PCI_VENDOR_ID_CCD, PCI_DEVICE_ID_CCD_HFC8S, PCI_VENDOR_ID_CCD,\n\t  PCI_SUBDEVICE_ID_CCD_IOB8ST_1, 0, 0, H(17)},  \n\t{ PCI_VENDOR_ID_CCD, PCI_DEVICE_ID_CCD_HFC8S, PCI_VENDOR_ID_CCD,\n\t  PCI_SUBDEVICE_ID_CCD_HFC8S, 0, 0, H(18)},  \n\t{ PCI_VENDOR_ID_CCD, PCI_DEVICE_ID_CCD_HFC8S, PCI_VENDOR_ID_CCD,\n\t  PCI_SUBDEVICE_ID_CCD_OV8S, 0, 0, H(30)},  \n\t{ PCI_VENDOR_ID_CCD, PCI_DEVICE_ID_CCD_HFC8S, PCI_VENDOR_ID_CCD,\n\t  PCI_SUBDEVICE_ID_CCD_JH8S, 0, 0, H(32)},  \n\n\n\t \n\t{ PCI_VENDOR_ID_CCD, PCI_DEVICE_ID_CCD_HFCE1, PCI_VENDOR_ID_CCD,\n\t  PCI_SUBDEVICE_ID_CCD_BNE1, 0, 0, H(19)},  \n\t{ PCI_VENDOR_ID_CCD, PCI_DEVICE_ID_CCD_HFCE1, PCI_VENDOR_ID_CCD,\n\t  PCI_SUBDEVICE_ID_CCD_BNE1M, 0, 0, H(20)},  \n\t{ PCI_VENDOR_ID_CCD, PCI_DEVICE_ID_CCD_HFCE1, PCI_VENDOR_ID_CCD,\n\t  PCI_SUBDEVICE_ID_CCD_BNE1DP, 0, 0, H(21)},  \n\t{ PCI_VENDOR_ID_CCD, PCI_DEVICE_ID_CCD_HFCE1, PCI_VENDOR_ID_CCD,\n\t  PCI_SUBDEVICE_ID_CCD_BNE1D, 0, 0, H(22)},  \n\n\t{ PCI_VENDOR_ID_CCD, PCI_DEVICE_ID_CCD_HFCE1, PCI_VENDOR_ID_CCD,\n\t  PCI_DEVICE_ID_CCD_HFCE1, 0, 0, H(23)},  \n\t{ PCI_VENDOR_ID_CCD, PCI_DEVICE_ID_CCD_HFCE1, PCI_VENDOR_ID_CCD,\n\t  PCI_SUBDEVICE_ID_CCD_IOB1E1, 0, 0, H(24)},  \n\t{ PCI_VENDOR_ID_CCD, PCI_DEVICE_ID_CCD_HFCE1, PCI_VENDOR_ID_CCD,\n\t  PCI_SUBDEVICE_ID_CCD_HFCE1, 0, 0, H(25)},  \n\n\t{ PCI_VENDOR_ID_PLX, PCI_DEVICE_ID_PLX_9030, PCI_VENDOR_ID_CCD,\n\t  PCI_SUBDEVICE_ID_CCD_SPD4S, 0, 0, H(26)},  \n\t{ PCI_VENDOR_ID_PLX, PCI_DEVICE_ID_PLX_9030, PCI_VENDOR_ID_CCD,\n\t  PCI_SUBDEVICE_ID_CCD_SPDE1, 0, 0, H(27)},  \n\n\t{ PCI_VENDOR_ID_CCD, PCI_DEVICE_ID_CCD_HFCE1, PCI_VENDOR_ID_CCD,\n\t  PCI_SUBDEVICE_ID_CCD_JHSE1, 0, 0, H(25)},  \n\n\t{ PCI_VDEVICE(CCD, PCI_DEVICE_ID_CCD_HFC4S), 0 },\n\t{ PCI_VDEVICE(CCD, PCI_DEVICE_ID_CCD_HFC8S), 0 },\n\t{ PCI_VDEVICE(CCD, PCI_DEVICE_ID_CCD_HFCE1), 0 },\n\t{0, }\n};\n#undef H\n\nMODULE_DEVICE_TABLE(pci, hfmultipci_ids);\n\nstatic int\nhfcmulti_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tstruct hm_map\t*m = (struct hm_map *)ent->driver_data;\n\tint\t\tret;\n\n\tif (m == NULL && ent->vendor == PCI_VENDOR_ID_CCD && (\n\t\t    ent->device == PCI_DEVICE_ID_CCD_HFC4S ||\n\t\t    ent->device == PCI_DEVICE_ID_CCD_HFC8S ||\n\t\t    ent->device == PCI_DEVICE_ID_CCD_HFCE1)) {\n\t\tprintk(KERN_ERR\n\t\t       \"Unknown HFC multiport controller (vendor:%04x device:%04x \"\n\t\t       \"subvendor:%04x subdevice:%04x)\\n\", pdev->vendor,\n\t\t       pdev->device, pdev->subsystem_vendor,\n\t\t       pdev->subsystem_device);\n\t\tprintk(KERN_ERR\n\t\t       \"Please contact the driver maintainer for support.\\n\");\n\t\treturn -ENODEV;\n\t}\n\tret = hfcmulti_init(m, pdev, ent);\n\tif (ret)\n\t\treturn ret;\n\tHFC_cnt++;\n\tprintk(KERN_INFO \"%d devices registered\\n\", HFC_cnt);\n\treturn 0;\n}\n\nstatic struct pci_driver hfcmultipci_driver = {\n\t.name\t\t= \"hfc_multi\",\n\t.probe\t\t= hfcmulti_probe,\n\t.remove\t\t= hfc_remove_pci,\n\t.id_table\t= hfmultipci_ids,\n};\n\nstatic void __exit\nHFCmulti_cleanup(void)\n{\n\tstruct hfc_multi *card, *next;\n\n\t \n\tlist_for_each_entry_safe(card, next, &HFClist, list)\n\t\trelease_card(card);\n\tpci_unregister_driver(&hfcmultipci_driver);\n}\n\nstatic int __init\nHFCmulti_init(void)\n{\n\tint err;\n\tint i, xhfc = 0;\n\tstruct hm_map m;\n\n\tprintk(KERN_INFO \"mISDN: HFC-multi driver %s\\n\", HFC_MULTI_VERSION);\n\n#ifdef IRQ_DEBUG\n\tprintk(KERN_DEBUG \"%s: IRQ_DEBUG IS ENABLED!\\n\", __func__);\n#endif\n\n\tif (debug & DEBUG_HFCMULTI_INIT)\n\t\tprintk(KERN_DEBUG \"%s: init entered\\n\", __func__);\n\n\tswitch (poll) {\n\tcase 0:\n\t\tpoll_timer = 6;\n\t\tpoll = 128;\n\t\tbreak;\n\tcase 8:\n\t\tpoll_timer = 2;\n\t\tbreak;\n\tcase 16:\n\t\tpoll_timer = 3;\n\t\tbreak;\n\tcase 32:\n\t\tpoll_timer = 4;\n\t\tbreak;\n\tcase 64:\n\t\tpoll_timer = 5;\n\t\tbreak;\n\tcase 128:\n\t\tpoll_timer = 6;\n\t\tbreak;\n\tcase 256:\n\t\tpoll_timer = 7;\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_ERR\n\t\t       \"%s: Wrong poll value (%d).\\n\", __func__, poll);\n\t\terr = -EINVAL;\n\t\treturn err;\n\n\t}\n\n\tif (!clock)\n\t\tclock = 1;\n\n\t \n\tswitch (hwid) {\n\tcase HWID_MINIP4:\n\t\txhfc = 1;\n\t\tm = hfcm_map[31];\n\t\tbreak;\n\tcase HWID_MINIP8:\n\t\txhfc = 2;\n\t\tm = hfcm_map[31];\n\t\tbreak;\n\tcase HWID_MINIP16:\n\t\txhfc = 4;\n\t\tm = hfcm_map[31];\n\t\tbreak;\n\tdefault:\n\t\txhfc = 0;\n\t}\n\n\tfor (i = 0; i < xhfc; ++i) {\n\t\terr = hfcmulti_init(&m, NULL, NULL);\n\t\tif (err) {\n\t\t\tprintk(KERN_ERR \"error registering embedded driver: \"\n\t\t\t       \"%x\\n\", err);\n\t\t\treturn err;\n\t\t}\n\t\tHFC_cnt++;\n\t\tprintk(KERN_INFO \"%d devices registered\\n\", HFC_cnt);\n\t}\n\n\t \n\terr = pci_register_driver(&hfcmultipci_driver);\n\tif (err < 0) {\n\t\tprintk(KERN_ERR \"error registering pci driver: %x\\n\", err);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\n\nmodule_init(HFCmulti_init);\nmodule_exit(HFCmulti_cleanup);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}