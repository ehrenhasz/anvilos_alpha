{
  "module_name": "mISDNisar.c",
  "hash_id": "35a0928122a3bd21d16c02cd8aea4e7be642efb451bfc6e120e6bc95bfe9bd34",
  "original_prompt": "Ingested from linux-6.6.14/drivers/isdn/hardware/mISDN/mISDNisar.c",
  "human_readable_source": "\n \n\n \n \n\n#include <linux/gfp.h>\n#include <linux/delay.h>\n#include <linux/vmalloc.h>\n#include <linux/mISDNhw.h>\n#include <linux/module.h>\n#include \"isar.h\"\n\n#define ISAR_REV\t\"2.1\"\n\nMODULE_AUTHOR(\"Karsten Keil\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_VERSION(ISAR_REV);\n\n#define DEBUG_HW_FIRMWARE_FIFO\t0x10000\n\nstatic const u8 faxmodulation[] = {3, 24, 48, 72, 73, 74, 96, 97, 98, 121,\n\t\t\t\t   122, 145, 146};\n#define FAXMODCNT 13\n\nstatic void isar_setup(struct isar_hw *);\n\nstatic inline int\nwaitforHIA(struct isar_hw *isar, int timeout)\n{\n\tint t = timeout;\n\tu8 val = isar->read_reg(isar->hw, ISAR_HIA);\n\n\twhile ((val & 1) && t) {\n\t\tudelay(1);\n\t\tt--;\n\t\tval = isar->read_reg(isar->hw, ISAR_HIA);\n\t}\n\tpr_debug(\"%s: HIA after %dus\\n\", isar->name, timeout - t);\n\treturn timeout;\n}\n\n \nstatic int\nsend_mbox(struct isar_hw *isar, u8 his, u8 creg, u8 len, u8 *msg)\n{\n\tif (!waitforHIA(isar, 1000))\n\t\treturn 0;\n\tpr_debug(\"send_mbox(%02x,%02x,%d)\\n\", his, creg, len);\n\tisar->write_reg(isar->hw, ISAR_CTRL_H, creg);\n\tisar->write_reg(isar->hw, ISAR_CTRL_L, len);\n\tisar->write_reg(isar->hw, ISAR_WADR, 0);\n\tif (!msg)\n\t\tmsg = isar->buf;\n\tif (msg && len) {\n\t\tisar->write_fifo(isar->hw, ISAR_MBOX, msg, len);\n\t\tif (isar->ch[0].bch.debug & DEBUG_HW_BFIFO) {\n\t\t\tint l = 0;\n\n\t\t\twhile (l < (int)len) {\n\t\t\t\thex_dump_to_buffer(msg + l, len - l, 32, 1,\n\t\t\t\t\t\t   isar->log, 256, 1);\n\t\t\t\tpr_debug(\"%s: %s %02x: %s\\n\", isar->name,\n\t\t\t\t\t __func__, l, isar->log);\n\t\t\t\tl += 32;\n\t\t\t}\n\t\t}\n\t}\n\tisar->write_reg(isar->hw, ISAR_HIS, his);\n\twaitforHIA(isar, 1000);\n\treturn 1;\n}\n\n \nstatic void\nrcv_mbox(struct isar_hw *isar, u8 *msg)\n{\n\tif (!msg)\n\t\tmsg = isar->buf;\n\tisar->write_reg(isar->hw, ISAR_RADR, 0);\n\tif (msg && isar->clsb) {\n\t\tisar->read_fifo(isar->hw, ISAR_MBOX, msg, isar->clsb);\n\t\tif (isar->ch[0].bch.debug & DEBUG_HW_BFIFO) {\n\t\t\tint l = 0;\n\n\t\t\twhile (l < (int)isar->clsb) {\n\t\t\t\thex_dump_to_buffer(msg + l, isar->clsb - l, 32,\n\t\t\t\t\t\t   1, isar->log, 256, 1);\n\t\t\t\tpr_debug(\"%s: %s %02x: %s\\n\", isar->name,\n\t\t\t\t\t __func__, l, isar->log);\n\t\t\t\tl += 32;\n\t\t\t}\n\t\t}\n\t}\n\tisar->write_reg(isar->hw, ISAR_IIA, 0);\n}\n\nstatic inline void\nget_irq_infos(struct isar_hw *isar)\n{\n\tisar->iis = isar->read_reg(isar->hw, ISAR_IIS);\n\tisar->cmsb = isar->read_reg(isar->hw, ISAR_CTRL_H);\n\tisar->clsb = isar->read_reg(isar->hw, ISAR_CTRL_L);\n\tpr_debug(\"%s: rcv_mbox(%02x,%02x,%d)\\n\", isar->name,\n\t\t isar->iis, isar->cmsb, isar->clsb);\n}\n\n \nstatic int\npoll_mbox(struct isar_hw *isar, int maxdelay)\n{\n\tint t = maxdelay;\n\tu8 irq;\n\n\tirq = isar->read_reg(isar->hw, ISAR_IRQBIT);\n\twhile (t && !(irq & ISAR_IRQSTA)) {\n\t\tudelay(1);\n\t\tt--;\n\t}\n\tif (t)\t{\n\t\tget_irq_infos(isar);\n\t\trcv_mbox(isar, NULL);\n\t}\n\tpr_debug(\"%s: pulled %d bytes after %d us\\n\",\n\t\t isar->name, isar->clsb, maxdelay - t);\n\treturn t;\n}\n\nstatic int\nISARVersion(struct isar_hw *isar)\n{\n\tint ver;\n\n\t \n\tisar->write_reg(isar->hw, ISAR_IRQBIT, 0);\n\tisar->buf[0] = ISAR_MSG_HWVER;\n\tisar->buf[1] = 0;\n\tisar->buf[2] = 1;\n\tif (!send_mbox(isar, ISAR_HIS_VNR, 0, 3, NULL))\n\t\treturn -1;\n\tif (!poll_mbox(isar, 1000))\n\t\treturn -2;\n\tif (isar->iis == ISAR_IIS_VNR) {\n\t\tif (isar->clsb == 1) {\n\t\t\tver = isar->buf[0] & 0xf;\n\t\t\treturn ver;\n\t\t}\n\t\treturn -3;\n\t}\n\treturn -4;\n}\n\nstatic int\nload_firmware(struct isar_hw *isar, const u8 *buf, int size)\n{\n\tu32\tsaved_debug = isar->ch[0].bch.debug;\n\tint\tret, cnt;\n\tu8\tnom, noc;\n\tu16\tleft, val, *sp = (u16 *)buf;\n\tu8\t*mp;\n\tu_long\tflags;\n\n\tstruct {\n\t\tu16 sadr;\n\t\tu16 len;\n\t\tu16 d_key;\n\t} blk_head;\n\n\tif (1 != isar->version) {\n\t\tpr_err(\"%s: ISAR wrong version %d firmware download aborted\\n\",\n\t\t       isar->name, isar->version);\n\t\treturn -EINVAL;\n\t}\n\tif (!(saved_debug & DEBUG_HW_FIRMWARE_FIFO))\n\t\tisar->ch[0].bch.debug &= ~DEBUG_HW_BFIFO;\n\tpr_debug(\"%s: load firmware %d words (%d bytes)\\n\",\n\t\t isar->name, size / 2, size);\n\tcnt = 0;\n\tsize /= 2;\n\t \n\tspin_lock_irqsave(isar->hwlock, flags);\n\tisar->write_reg(isar->hw, ISAR_IRQBIT, 0);\n\tspin_unlock_irqrestore(isar->hwlock, flags);\n\twhile (cnt < size) {\n\t\tblk_head.sadr = le16_to_cpu(*sp++);\n\t\tblk_head.len = le16_to_cpu(*sp++);\n\t\tblk_head.d_key = le16_to_cpu(*sp++);\n\t\tcnt += 3;\n\t\tpr_debug(\"ISAR firmware block (%#x,%d,%#x)\\n\",\n\t\t\t blk_head.sadr, blk_head.len, blk_head.d_key & 0xff);\n\t\tleft = blk_head.len;\n\t\tif (cnt + left > size) {\n\t\t\tpr_info(\"%s: firmware error have %d need %d words\\n\",\n\t\t\t\tisar->name, size, cnt + left);\n\t\t\tret = -EINVAL;\n\t\t\tgoto reterrflg;\n\t\t}\n\t\tspin_lock_irqsave(isar->hwlock, flags);\n\t\tif (!send_mbox(isar, ISAR_HIS_DKEY, blk_head.d_key & 0xff,\n\t\t\t       0, NULL)) {\n\t\t\tpr_info(\"ISAR send_mbox dkey failed\\n\");\n\t\t\tret = -ETIME;\n\t\t\tgoto reterror;\n\t\t}\n\t\tif (!poll_mbox(isar, 1000)) {\n\t\t\tpr_warn(\"ISAR poll_mbox dkey failed\\n\");\n\t\t\tret = -ETIME;\n\t\t\tgoto reterror;\n\t\t}\n\t\tspin_unlock_irqrestore(isar->hwlock, flags);\n\t\tif ((isar->iis != ISAR_IIS_DKEY) || isar->cmsb || isar->clsb) {\n\t\t\tpr_info(\"ISAR wrong dkey response (%x,%x,%x)\\n\",\n\t\t\t\tisar->iis, isar->cmsb, isar->clsb);\n\t\t\tret = 1;\n\t\t\tgoto reterrflg;\n\t\t}\n\t\twhile (left > 0) {\n\t\t\tif (left > 126)\n\t\t\t\tnoc = 126;\n\t\t\telse\n\t\t\t\tnoc = left;\n\t\t\tnom = (2 * noc) + 3;\n\t\t\tmp  = isar->buf;\n\t\t\t \n\t\t\t*mp++ = blk_head.sadr >> 8;\n\t\t\t*mp++ = blk_head.sadr & 0xFF;\n\t\t\tleft -= noc;\n\t\t\tcnt += noc;\n\t\t\t*mp++ = noc;\n\t\t\tpr_debug(\"%s: load %3d words at %04x\\n\", isar->name,\n\t\t\t\t noc, blk_head.sadr);\n\t\t\tblk_head.sadr += noc;\n\t\t\twhile (noc) {\n\t\t\t\tval = le16_to_cpu(*sp++);\n\t\t\t\t*mp++ = val >> 8;\n\t\t\t\t*mp++ = val & 0xFF;\n\t\t\t\tnoc--;\n\t\t\t}\n\t\t\tspin_lock_irqsave(isar->hwlock, flags);\n\t\t\tif (!send_mbox(isar, ISAR_HIS_FIRM, 0, nom, NULL)) {\n\t\t\t\tpr_info(\"ISAR send_mbox prog failed\\n\");\n\t\t\t\tret = -ETIME;\n\t\t\t\tgoto reterror;\n\t\t\t}\n\t\t\tif (!poll_mbox(isar, 1000)) {\n\t\t\t\tpr_info(\"ISAR poll_mbox prog failed\\n\");\n\t\t\t\tret = -ETIME;\n\t\t\t\tgoto reterror;\n\t\t\t}\n\t\t\tspin_unlock_irqrestore(isar->hwlock, flags);\n\t\t\tif ((isar->iis != ISAR_IIS_FIRM) ||\n\t\t\t    isar->cmsb || isar->clsb) {\n\t\t\t\tpr_info(\"ISAR wrong prog response (%x,%x,%x)\\n\",\n\t\t\t\t\tisar->iis, isar->cmsb, isar->clsb);\n\t\t\t\tret = -EIO;\n\t\t\t\tgoto reterrflg;\n\t\t\t}\n\t\t}\n\t\tpr_debug(\"%s: ISAR firmware block %d words loaded\\n\",\n\t\t\t isar->name, blk_head.len);\n\t}\n\tisar->ch[0].bch.debug = saved_debug;\n\t \n\tcnt = 10;\n\twhile (cnt--)\n\t\tmdelay(1);\n\tisar->buf[0] = 0xff;\n\tisar->buf[1] = 0xfe;\n\tisar->bstat = 0;\n\tspin_lock_irqsave(isar->hwlock, flags);\n\tif (!send_mbox(isar, ISAR_HIS_STDSP, 0, 2, NULL)) {\n\t\tpr_info(\"ISAR send_mbox start dsp failed\\n\");\n\t\tret = -ETIME;\n\t\tgoto reterror;\n\t}\n\tif (!poll_mbox(isar, 1000)) {\n\t\tpr_info(\"ISAR poll_mbox start dsp failed\\n\");\n\t\tret = -ETIME;\n\t\tgoto reterror;\n\t}\n\tif ((isar->iis != ISAR_IIS_STDSP) || isar->cmsb || isar->clsb) {\n\t\tpr_info(\"ISAR wrong start dsp response (%x,%x,%x)\\n\",\n\t\t\tisar->iis, isar->cmsb, isar->clsb);\n\t\tret = -EIO;\n\t\tgoto reterror;\n\t} else\n\t\tpr_debug(\"%s: ISAR start dsp success\\n\", isar->name);\n\n\t \n\t \n\tisar->write_reg(isar->hw, ISAR_IRQBIT, ISAR_IRQSTA);\n\tspin_unlock_irqrestore(isar->hwlock, flags);\n\tcnt = 1000;  \n\twhile ((!isar->bstat) && cnt) {\n\t\tmdelay(1);\n\t\tcnt--;\n\t}\n\tif (!cnt) {\n\t\tpr_info(\"ISAR no general status event received\\n\");\n\t\tret = -ETIME;\n\t\tgoto reterrflg;\n\t} else\n\t\tpr_debug(\"%s: ISAR general status event %x\\n\",\n\t\t\t isar->name, isar->bstat);\n\t \n\tcnt = 10;\n\twhile (cnt--)\n\t\tmdelay(1);\n\tisar->iis = 0;\n\tspin_lock_irqsave(isar->hwlock, flags);\n\tif (!send_mbox(isar, ISAR_HIS_DIAG, ISAR_CTRL_STST, 0, NULL)) {\n\t\tpr_info(\"ISAR send_mbox self tst failed\\n\");\n\t\tret = -ETIME;\n\t\tgoto reterror;\n\t}\n\tspin_unlock_irqrestore(isar->hwlock, flags);\n\tcnt = 10000;  \n\twhile ((isar->iis != ISAR_IIS_DIAG) && cnt) {\n\t\tudelay(10);\n\t\tcnt--;\n\t}\n\tmdelay(1);\n\tif (!cnt) {\n\t\tpr_info(\"ISAR no self tst response\\n\");\n\t\tret = -ETIME;\n\t\tgoto reterrflg;\n\t}\n\tif ((isar->cmsb == ISAR_CTRL_STST) && (isar->clsb == 1)\n\t    && (isar->buf[0] == 0))\n\t\tpr_debug(\"%s: ISAR selftest OK\\n\", isar->name);\n\telse {\n\t\tpr_info(\"ISAR selftest not OK %x/%x/%x\\n\",\n\t\t\tisar->cmsb, isar->clsb, isar->buf[0]);\n\t\tret = -EIO;\n\t\tgoto reterrflg;\n\t}\n\tspin_lock_irqsave(isar->hwlock, flags);\n\tisar->iis = 0;\n\tif (!send_mbox(isar, ISAR_HIS_DIAG, ISAR_CTRL_SWVER, 0, NULL)) {\n\t\tpr_info(\"ISAR RQST SVN failed\\n\");\n\t\tret = -ETIME;\n\t\tgoto reterror;\n\t}\n\tspin_unlock_irqrestore(isar->hwlock, flags);\n\tcnt = 30000;  \n\twhile ((isar->iis != ISAR_IIS_DIAG) && cnt) {\n\t\tudelay(10);\n\t\tcnt--;\n\t}\n\tmdelay(1);\n\tif (!cnt) {\n\t\tpr_info(\"ISAR no SVN response\\n\");\n\t\tret = -ETIME;\n\t\tgoto reterrflg;\n\t} else {\n\t\tif ((isar->cmsb == ISAR_CTRL_SWVER) && (isar->clsb == 1)) {\n\t\t\tpr_notice(\"%s: ISAR software version %#x\\n\",\n\t\t\t\t  isar->name, isar->buf[0]);\n\t\t} else {\n\t\t\tpr_info(\"%s: ISAR wrong swver response (%x,%x)\"\n\t\t\t\t\" cnt(%d)\\n\", isar->name, isar->cmsb,\n\t\t\t\tisar->clsb, cnt);\n\t\t\tret = -EIO;\n\t\t\tgoto reterrflg;\n\t\t}\n\t}\n\tspin_lock_irqsave(isar->hwlock, flags);\n\tisar_setup(isar);\n\tspin_unlock_irqrestore(isar->hwlock, flags);\n\tret = 0;\nreterrflg:\n\tspin_lock_irqsave(isar->hwlock, flags);\nreterror:\n\tisar->ch[0].bch.debug = saved_debug;\n\tif (ret)\n\t\t \n\t\tisar->write_reg(isar->hw, ISAR_IRQBIT, 0);\n\tspin_unlock_irqrestore(isar->hwlock, flags);\n\treturn ret;\n}\n\nstatic inline void\ndeliver_status(struct isar_ch *ch, int status)\n{\n\tpr_debug(\"%s: HL->LL FAXIND %x\\n\", ch->is->name, status);\n\t_queue_data(&ch->bch.ch, PH_CONTROL_IND, status, 0, NULL, GFP_ATOMIC);\n}\n\nstatic inline void\nisar_rcv_frame(struct isar_ch *ch)\n{\n\tu8\t*ptr;\n\tint\tmaxlen;\n\n\tif (!ch->is->clsb) {\n\t\tpr_debug(\"%s; ISAR zero len frame\\n\", ch->is->name);\n\t\tch->is->write_reg(ch->is->hw, ISAR_IIA, 0);\n\t\treturn;\n\t}\n\tif (test_bit(FLG_RX_OFF, &ch->bch.Flags)) {\n\t\tch->bch.dropcnt += ch->is->clsb;\n\t\tch->is->write_reg(ch->is->hw, ISAR_IIA, 0);\n\t\treturn;\n\t}\n\tswitch (ch->bch.state) {\n\tcase ISDN_P_NONE:\n\t\tpr_debug(\"%s: ISAR protocol 0 spurious IIS_RDATA %x/%x/%x\\n\",\n\t\t\t ch->is->name, ch->is->iis, ch->is->cmsb, ch->is->clsb);\n\t\tch->is->write_reg(ch->is->hw, ISAR_IIA, 0);\n\t\tbreak;\n\tcase ISDN_P_B_RAW:\n\tcase ISDN_P_B_L2DTMF:\n\tcase ISDN_P_B_MODEM_ASYNC:\n\t\tmaxlen = bchannel_get_rxbuf(&ch->bch, ch->is->clsb);\n\t\tif (maxlen < 0) {\n\t\t\tpr_warn(\"%s.B%d: No bufferspace for %d bytes\\n\",\n\t\t\t\tch->is->name, ch->bch.nr, ch->is->clsb);\n\t\t\tch->is->write_reg(ch->is->hw, ISAR_IIA, 0);\n\t\t\tbreak;\n\t\t}\n\t\trcv_mbox(ch->is, skb_put(ch->bch.rx_skb, ch->is->clsb));\n\t\trecv_Bchannel(&ch->bch, 0, false);\n\t\tbreak;\n\tcase ISDN_P_B_HDLC:\n\t\tmaxlen = bchannel_get_rxbuf(&ch->bch, ch->is->clsb);\n\t\tif (maxlen < 0) {\n\t\t\tpr_warn(\"%s.B%d: No bufferspace for %d bytes\\n\",\n\t\t\t\tch->is->name, ch->bch.nr, ch->is->clsb);\n\t\t\tch->is->write_reg(ch->is->hw, ISAR_IIA, 0);\n\t\t\tbreak;\n\t\t}\n\t\tif (ch->is->cmsb & HDLC_ERROR) {\n\t\t\tpr_debug(\"%s: ISAR frame error %x len %d\\n\",\n\t\t\t\t ch->is->name, ch->is->cmsb, ch->is->clsb);\n#ifdef ERROR_STATISTIC\n\t\t\tif (ch->is->cmsb & HDLC_ERR_RER)\n\t\t\t\tch->bch.err_inv++;\n\t\t\tif (ch->is->cmsb & HDLC_ERR_CER)\n\t\t\t\tch->bch.err_crc++;\n#endif\n\t\t\tskb_trim(ch->bch.rx_skb, 0);\n\t\t\tch->is->write_reg(ch->is->hw, ISAR_IIA, 0);\n\t\t\tbreak;\n\t\t}\n\t\tif (ch->is->cmsb & HDLC_FSD)\n\t\t\tskb_trim(ch->bch.rx_skb, 0);\n\t\tptr = skb_put(ch->bch.rx_skb, ch->is->clsb);\n\t\trcv_mbox(ch->is, ptr);\n\t\tif (ch->is->cmsb & HDLC_FED) {\n\t\t\tif (ch->bch.rx_skb->len < 3) {  \n\t\t\t\tpr_debug(\"%s: ISAR frame too short %d\\n\",\n\t\t\t\t\t ch->is->name, ch->bch.rx_skb->len);\n\t\t\t\tskb_trim(ch->bch.rx_skb, 0);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tskb_trim(ch->bch.rx_skb, ch->bch.rx_skb->len - 2);\n\t\t\trecv_Bchannel(&ch->bch, 0, false);\n\t\t}\n\t\tbreak;\n\tcase ISDN_P_B_T30_FAX:\n\t\tif (ch->state != STFAX_ACTIV) {\n\t\t\tpr_debug(\"%s: isar_rcv_frame: not ACTIV\\n\",\n\t\t\t\t ch->is->name);\n\t\t\tch->is->write_reg(ch->is->hw, ISAR_IIA, 0);\n\t\t\tif (ch->bch.rx_skb)\n\t\t\t\tskb_trim(ch->bch.rx_skb, 0);\n\t\t\tbreak;\n\t\t}\n\t\tif (!ch->bch.rx_skb) {\n\t\t\tch->bch.rx_skb = mI_alloc_skb(ch->bch.maxlen,\n\t\t\t\t\t\t      GFP_ATOMIC);\n\t\t\tif (unlikely(!ch->bch.rx_skb)) {\n\t\t\t\tpr_info(\"%s: B receive out of memory\\n\",\n\t\t\t\t\t__func__);\n\t\t\t\tch->is->write_reg(ch->is->hw, ISAR_IIA, 0);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (ch->cmd == PCTRL_CMD_FRM) {\n\t\t\trcv_mbox(ch->is, skb_put(ch->bch.rx_skb, ch->is->clsb));\n\t\t\tpr_debug(\"%s: isar_rcv_frame: %d\\n\",\n\t\t\t\t ch->is->name, ch->bch.rx_skb->len);\n\t\t\tif (ch->is->cmsb & SART_NMD) {  \n\t\t\t\tpr_debug(\"%s: isar_rcv_frame: no more data\\n\",\n\t\t\t\t\t ch->is->name);\n\t\t\t\tch->is->write_reg(ch->is->hw, ISAR_IIA, 0);\n\t\t\t\tsend_mbox(ch->is, SET_DPS(ch->dpath) |\n\t\t\t\t\t  ISAR_HIS_PUMPCTRL, PCTRL_CMD_ESC,\n\t\t\t\t\t  0, NULL);\n\t\t\t\tch->state = STFAX_ESCAPE;\n\t\t\t\t \n\t\t\t}\n\t\t\trecv_Bchannel(&ch->bch, 0, false);\n\t\t\tif (ch->is->cmsb & SART_NMD)\n\t\t\t\tdeliver_status(ch, HW_MOD_NOCARR);\n\t\t\tbreak;\n\t\t}\n\t\tif (ch->cmd != PCTRL_CMD_FRH) {\n\t\t\tpr_debug(\"%s: isar_rcv_frame: unknown fax mode %x\\n\",\n\t\t\t\t ch->is->name, ch->cmd);\n\t\t\tch->is->write_reg(ch->is->hw, ISAR_IIA, 0);\n\t\t\tif (ch->bch.rx_skb)\n\t\t\t\tskb_trim(ch->bch.rx_skb, 0);\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tif ((ch->bch.rx_skb->len + ch->is->clsb) >\n\t\t    (ch->bch.maxlen + 2)) {\n\t\t\tpr_info(\"%s: %s incoming packet too large\\n\",\n\t\t\t\tch->is->name, __func__);\n\t\t\tch->is->write_reg(ch->is->hw, ISAR_IIA, 0);\n\t\t\tskb_trim(ch->bch.rx_skb, 0);\n\t\t\tbreak;\n\t\t}  else if (ch->is->cmsb & HDLC_ERROR) {\n\t\t\tpr_info(\"%s: ISAR frame error %x len %d\\n\",\n\t\t\t\tch->is->name, ch->is->cmsb, ch->is->clsb);\n\t\t\tskb_trim(ch->bch.rx_skb, 0);\n\t\t\tch->is->write_reg(ch->is->hw, ISAR_IIA, 0);\n\t\t\tbreak;\n\t\t}\n\t\tif (ch->is->cmsb & HDLC_FSD)\n\t\t\tskb_trim(ch->bch.rx_skb, 0);\n\t\tptr = skb_put(ch->bch.rx_skb, ch->is->clsb);\n\t\trcv_mbox(ch->is, ptr);\n\t\tif (ch->is->cmsb & HDLC_FED) {\n\t\t\tif (ch->bch.rx_skb->len < 3) {  \n\t\t\t\tpr_info(\"%s: ISAR frame too short %d\\n\",\n\t\t\t\t\tch->is->name, ch->bch.rx_skb->len);\n\t\t\t\tskb_trim(ch->bch.rx_skb, 0);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tskb_trim(ch->bch.rx_skb, ch->bch.rx_skb->len - 2);\n\t\t\trecv_Bchannel(&ch->bch, 0, false);\n\t\t}\n\t\tif (ch->is->cmsb & SART_NMD) {  \n\t\t\tpr_debug(\"%s: isar_rcv_frame: no more data\\n\",\n\t\t\t\t ch->is->name);\n\t\t\tch->is->write_reg(ch->is->hw, ISAR_IIA, 0);\n\t\t\tif (ch->bch.rx_skb)\n\t\t\t\tskb_trim(ch->bch.rx_skb, 0);\n\t\t\tsend_mbox(ch->is, SET_DPS(ch->dpath) |\n\t\t\t\t  ISAR_HIS_PUMPCTRL, PCTRL_CMD_ESC, 0, NULL);\n\t\t\tch->state = STFAX_ESCAPE;\n\t\t\tdeliver_status(ch, HW_MOD_NOCARR);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tpr_info(\"isar_rcv_frame protocol (%x)error\\n\", ch->bch.state);\n\t\tch->is->write_reg(ch->is->hw, ISAR_IIA, 0);\n\t\tbreak;\n\t}\n}\n\nstatic void\nisar_fill_fifo(struct isar_ch *ch)\n{\n\tint count;\n\tu8 msb;\n\tu8 *ptr;\n\n\tpr_debug(\"%s: ch%d  tx_skb %d tx_idx %d\\n\", ch->is->name, ch->bch.nr,\n\t\t ch->bch.tx_skb ? ch->bch.tx_skb->len : -1, ch->bch.tx_idx);\n\tif (!(ch->is->bstat &\n\t      (ch->dpath == 1 ? BSTAT_RDM1 : BSTAT_RDM2)))\n\t\treturn;\n\tif (!ch->bch.tx_skb) {\n\t\tif (!test_bit(FLG_TX_EMPTY, &ch->bch.Flags) ||\n\t\t    (ch->bch.state != ISDN_P_B_RAW))\n\t\t\treturn;\n\t\tcount = ch->mml;\n\t\t \n\t\tmemset(ch->is->buf, ch->bch.fill[0], count);\n\t\tsend_mbox(ch->is, SET_DPS(ch->dpath) | ISAR_HIS_SDATA,\n\t\t\t  0, count, ch->is->buf);\n\t\treturn;\n\t}\n\tcount = ch->bch.tx_skb->len - ch->bch.tx_idx;\n\tif (count <= 0)\n\t\treturn;\n\tif (count > ch->mml) {\n\t\tmsb = 0;\n\t\tcount = ch->mml;\n\t} else {\n\t\tmsb = HDLC_FED;\n\t}\n\tptr = ch->bch.tx_skb->data + ch->bch.tx_idx;\n\tif (!ch->bch.tx_idx) {\n\t\tpr_debug(\"%s: frame start\\n\", ch->is->name);\n\t\tif ((ch->bch.state == ISDN_P_B_T30_FAX) &&\n\t\t    (ch->cmd == PCTRL_CMD_FTH)) {\n\t\t\tif (count > 1) {\n\t\t\t\tif ((ptr[0] == 0xff) && (ptr[1] == 0x13)) {\n\t\t\t\t\t \n\t\t\t\t\ttest_and_set_bit(FLG_LASTDATA,\n\t\t\t\t\t\t\t &ch->bch.Flags);\n\t\t\t\t\tpr_debug(\"%s: set LASTDATA\\n\",\n\t\t\t\t\t\t ch->is->name);\n\t\t\t\t\tif (msb == HDLC_FED)\n\t\t\t\t\t\ttest_and_set_bit(FLG_DLEETX,\n\t\t\t\t\t\t\t\t &ch->bch.Flags);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmsb |= HDLC_FST;\n\t}\n\tch->bch.tx_idx += count;\n\tswitch (ch->bch.state) {\n\tcase ISDN_P_NONE:\n\t\tpr_info(\"%s: wrong protocol 0\\n\", __func__);\n\t\tbreak;\n\tcase ISDN_P_B_RAW:\n\tcase ISDN_P_B_L2DTMF:\n\tcase ISDN_P_B_MODEM_ASYNC:\n\t\tsend_mbox(ch->is, SET_DPS(ch->dpath) | ISAR_HIS_SDATA,\n\t\t\t  0, count, ptr);\n\t\tbreak;\n\tcase ISDN_P_B_HDLC:\n\t\tsend_mbox(ch->is, SET_DPS(ch->dpath) | ISAR_HIS_SDATA,\n\t\t\t  msb, count, ptr);\n\t\tbreak;\n\tcase ISDN_P_B_T30_FAX:\n\t\tif (ch->state != STFAX_ACTIV)\n\t\t\tpr_debug(\"%s: not ACTIV\\n\", ch->is->name);\n\t\telse if (ch->cmd == PCTRL_CMD_FTH)\n\t\t\tsend_mbox(ch->is, SET_DPS(ch->dpath) | ISAR_HIS_SDATA,\n\t\t\t\t  msb, count, ptr);\n\t\telse if (ch->cmd == PCTRL_CMD_FTM)\n\t\t\tsend_mbox(ch->is, SET_DPS(ch->dpath) | ISAR_HIS_SDATA,\n\t\t\t\t  0, count, ptr);\n\t\telse\n\t\t\tpr_debug(\"%s: not FTH/FTM\\n\", ch->is->name);\n\t\tbreak;\n\tdefault:\n\t\tpr_info(\"%s: protocol(%x) error\\n\",\n\t\t\t__func__, ch->bch.state);\n\t\tbreak;\n\t}\n}\n\nstatic inline struct isar_ch *\nsel_bch_isar(struct isar_hw *isar, u8 dpath)\n{\n\tstruct isar_ch\t*base = &isar->ch[0];\n\n\tif ((!dpath) || (dpath > 2))\n\t\treturn NULL;\n\tif (base->dpath == dpath)\n\t\treturn base;\n\tbase++;\n\tif (base->dpath == dpath)\n\t\treturn base;\n\treturn NULL;\n}\n\nstatic void\nsend_next(struct isar_ch *ch)\n{\n\tpr_debug(\"%s: %s ch%d tx_skb %d tx_idx %d\\n\", ch->is->name, __func__,\n\t\t ch->bch.nr, ch->bch.tx_skb ? ch->bch.tx_skb->len : -1,\n\t\t ch->bch.tx_idx);\n\tif (ch->bch.state == ISDN_P_B_T30_FAX) {\n\t\tif (ch->cmd == PCTRL_CMD_FTH) {\n\t\t\tif (test_bit(FLG_LASTDATA, &ch->bch.Flags)) {\n\t\t\t\tpr_debug(\"set NMD_DATA\\n\");\n\t\t\t\ttest_and_set_bit(FLG_NMD_DATA, &ch->bch.Flags);\n\t\t\t}\n\t\t} else if (ch->cmd == PCTRL_CMD_FTM) {\n\t\t\tif (test_bit(FLG_DLEETX, &ch->bch.Flags)) {\n\t\t\t\ttest_and_set_bit(FLG_LASTDATA, &ch->bch.Flags);\n\t\t\t\ttest_and_set_bit(FLG_NMD_DATA, &ch->bch.Flags);\n\t\t\t}\n\t\t}\n\t}\n\tdev_kfree_skb(ch->bch.tx_skb);\n\tif (get_next_bframe(&ch->bch)) {\n\t\tisar_fill_fifo(ch);\n\t\ttest_and_clear_bit(FLG_TX_EMPTY, &ch->bch.Flags);\n\t} else if (test_bit(FLG_TX_EMPTY, &ch->bch.Flags)) {\n\t\tisar_fill_fifo(ch);\n\t} else {\n\t\tif (test_and_clear_bit(FLG_DLEETX, &ch->bch.Flags)) {\n\t\t\tif (test_and_clear_bit(FLG_LASTDATA,\n\t\t\t\t\t       &ch->bch.Flags)) {\n\t\t\t\tif (test_and_clear_bit(FLG_NMD_DATA,\n\t\t\t\t\t\t       &ch->bch.Flags)) {\n\t\t\t\t\tu8 zd = 0;\n\t\t\t\t\tsend_mbox(ch->is, SET_DPS(ch->dpath) |\n\t\t\t\t\t\t  ISAR_HIS_SDATA, 0x01, 1, &zd);\n\t\t\t\t}\n\t\t\t\ttest_and_set_bit(FLG_LL_OK, &ch->bch.Flags);\n\t\t\t} else {\n\t\t\t\tdeliver_status(ch, HW_MOD_CONNECT);\n\t\t\t}\n\t\t} else if (test_bit(FLG_FILLEMPTY, &ch->bch.Flags)) {\n\t\t\ttest_and_set_bit(FLG_TX_EMPTY, &ch->bch.Flags);\n\t\t}\n\t}\n}\n\nstatic void\ncheck_send(struct isar_hw *isar, u8 rdm)\n{\n\tstruct isar_ch\t*ch;\n\n\tpr_debug(\"%s: rdm %x\\n\", isar->name, rdm);\n\tif (rdm & BSTAT_RDM1) {\n\t\tch = sel_bch_isar(isar, 1);\n\t\tif (ch && test_bit(FLG_ACTIVE, &ch->bch.Flags)) {\n\t\t\tif (ch->bch.tx_skb && (ch->bch.tx_skb->len >\n\t\t\t\t\t       ch->bch.tx_idx))\n\t\t\t\tisar_fill_fifo(ch);\n\t\t\telse\n\t\t\t\tsend_next(ch);\n\t\t}\n\t}\n\tif (rdm & BSTAT_RDM2) {\n\t\tch = sel_bch_isar(isar, 2);\n\t\tif (ch && test_bit(FLG_ACTIVE, &ch->bch.Flags)) {\n\t\t\tif (ch->bch.tx_skb && (ch->bch.tx_skb->len >\n\t\t\t\t\t       ch->bch.tx_idx))\n\t\t\t\tisar_fill_fifo(ch);\n\t\t\telse\n\t\t\t\tsend_next(ch);\n\t\t}\n\t}\n}\n\nstatic const char *dmril[] = {\"NO SPEED\", \"1200/75\", \"NODEF2\", \"75/1200\", \"NODEF4\",\n\t\t       \"300\", \"600\", \"1200\", \"2400\", \"4800\", \"7200\",\n\t\t       \"9600nt\", \"9600t\", \"12000\", \"14400\", \"WRONG\"};\nstatic const char *dmrim[] = {\"NO MOD\", \"NO DEF\", \"V32/V32b\", \"V22\", \"V21\",\n\t\t       \"Bell103\", \"V23\", \"Bell202\", \"V17\", \"V29\", \"V27ter\"};\n\nstatic void\nisar_pump_status_rsp(struct isar_ch *ch) {\n\tu8 ril = ch->is->buf[0];\n\tu8 rim;\n\n\tif (!test_and_clear_bit(ISAR_RATE_REQ, &ch->is->Flags))\n\t\treturn;\n\tif (ril > 14) {\n\t\tpr_info(\"%s: wrong pstrsp ril=%d\\n\", ch->is->name, ril);\n\t\tril = 15;\n\t}\n\tswitch (ch->is->buf[1]) {\n\tcase 0:\n\t\trim = 0;\n\t\tbreak;\n\tcase 0x20:\n\t\trim = 2;\n\t\tbreak;\n\tcase 0x40:\n\t\trim = 3;\n\t\tbreak;\n\tcase 0x41:\n\t\trim = 4;\n\t\tbreak;\n\tcase 0x51:\n\t\trim = 5;\n\t\tbreak;\n\tcase 0x61:\n\t\trim = 6;\n\t\tbreak;\n\tcase 0x71:\n\t\trim = 7;\n\t\tbreak;\n\tcase 0x82:\n\t\trim = 8;\n\t\tbreak;\n\tcase 0x92:\n\t\trim = 9;\n\t\tbreak;\n\tcase 0xa2:\n\t\trim = 10;\n\t\tbreak;\n\tdefault:\n\t\trim = 1;\n\t\tbreak;\n\t}\n\tsprintf(ch->conmsg, \"%s %s\", dmril[ril], dmrim[rim]);\n\tpr_debug(\"%s: pump strsp %s\\n\", ch->is->name, ch->conmsg);\n}\n\nstatic void\nisar_pump_statev_modem(struct isar_ch *ch, u8 devt) {\n\tu8 dps = SET_DPS(ch->dpath);\n\n\tswitch (devt) {\n\tcase PSEV_10MS_TIMER:\n\t\tpr_debug(\"%s: pump stev TIMER\\n\", ch->is->name);\n\t\tbreak;\n\tcase PSEV_CON_ON:\n\t\tpr_debug(\"%s: pump stev CONNECT\\n\", ch->is->name);\n\t\tdeliver_status(ch, HW_MOD_CONNECT);\n\t\tbreak;\n\tcase PSEV_CON_OFF:\n\t\tpr_debug(\"%s: pump stev NO CONNECT\\n\", ch->is->name);\n\t\tsend_mbox(ch->is, dps | ISAR_HIS_PSTREQ, 0, 0, NULL);\n\t\tdeliver_status(ch, HW_MOD_NOCARR);\n\t\tbreak;\n\tcase PSEV_V24_OFF:\n\t\tpr_debug(\"%s: pump stev V24 OFF\\n\", ch->is->name);\n\t\tbreak;\n\tcase PSEV_CTS_ON:\n\t\tpr_debug(\"%s: pump stev CTS ON\\n\", ch->is->name);\n\t\tbreak;\n\tcase PSEV_CTS_OFF:\n\t\tpr_debug(\"%s pump stev CTS OFF\\n\", ch->is->name);\n\t\tbreak;\n\tcase PSEV_DCD_ON:\n\t\tpr_debug(\"%s: pump stev CARRIER ON\\n\", ch->is->name);\n\t\ttest_and_set_bit(ISAR_RATE_REQ, &ch->is->Flags);\n\t\tsend_mbox(ch->is, dps | ISAR_HIS_PSTREQ, 0, 0, NULL);\n\t\tbreak;\n\tcase PSEV_DCD_OFF:\n\t\tpr_debug(\"%s: pump stev CARRIER OFF\\n\", ch->is->name);\n\t\tbreak;\n\tcase PSEV_DSR_ON:\n\t\tpr_debug(\"%s: pump stev DSR ON\\n\", ch->is->name);\n\t\tbreak;\n\tcase PSEV_DSR_OFF:\n\t\tpr_debug(\"%s: pump stev DSR_OFF\\n\", ch->is->name);\n\t\tbreak;\n\tcase PSEV_REM_RET:\n\t\tpr_debug(\"%s: pump stev REMOTE RETRAIN\\n\", ch->is->name);\n\t\tbreak;\n\tcase PSEV_REM_REN:\n\t\tpr_debug(\"%s: pump stev REMOTE RENEGOTIATE\\n\", ch->is->name);\n\t\tbreak;\n\tcase PSEV_GSTN_CLR:\n\t\tpr_debug(\"%s: pump stev GSTN CLEAR\\n\", ch->is->name);\n\t\tbreak;\n\tdefault:\n\t\tpr_info(\"u%s: unknown pump stev %x\\n\", ch->is->name, devt);\n\t\tbreak;\n\t}\n}\n\nstatic void\nisar_pump_statev_fax(struct isar_ch *ch, u8 devt) {\n\tu8 dps = SET_DPS(ch->dpath);\n\tu8 p1;\n\n\tswitch (devt) {\n\tcase PSEV_10MS_TIMER:\n\t\tpr_debug(\"%s: pump stev TIMER\\n\", ch->is->name);\n\t\tbreak;\n\tcase PSEV_RSP_READY:\n\t\tpr_debug(\"%s: pump stev RSP_READY\\n\", ch->is->name);\n\t\tch->state = STFAX_READY;\n\t\tdeliver_status(ch, HW_MOD_READY);\n#ifdef AUTOCON\n\t\tif (test_bit(BC_FLG_ORIG, &ch->bch.Flags))\n\t\t\tisar_pump_cmd(bch, HW_MOD_FRH, 3);\n\t\telse\n\t\t\tisar_pump_cmd(bch, HW_MOD_FTH, 3);\n#endif\n\t\tbreak;\n\tcase PSEV_LINE_TX_H:\n\t\tif (ch->state == STFAX_LINE) {\n\t\t\tpr_debug(\"%s: pump stev LINE_TX_H\\n\", ch->is->name);\n\t\t\tch->state = STFAX_CONT;\n\t\t\tsend_mbox(ch->is, dps | ISAR_HIS_PUMPCTRL,\n\t\t\t\t  PCTRL_CMD_CONT, 0, NULL);\n\t\t} else {\n\t\t\tpr_debug(\"%s: pump stev LINE_TX_H wrong st %x\\n\",\n\t\t\t\t ch->is->name, ch->state);\n\t\t}\n\t\tbreak;\n\tcase PSEV_LINE_RX_H:\n\t\tif (ch->state == STFAX_LINE) {\n\t\t\tpr_debug(\"%s: pump stev LINE_RX_H\\n\", ch->is->name);\n\t\t\tch->state = STFAX_CONT;\n\t\t\tsend_mbox(ch->is, dps | ISAR_HIS_PUMPCTRL,\n\t\t\t\t  PCTRL_CMD_CONT, 0, NULL);\n\t\t} else {\n\t\t\tpr_debug(\"%s: pump stev LINE_RX_H wrong st %x\\n\",\n\t\t\t\t ch->is->name, ch->state);\n\t\t}\n\t\tbreak;\n\tcase PSEV_LINE_TX_B:\n\t\tif (ch->state == STFAX_LINE) {\n\t\t\tpr_debug(\"%s: pump stev LINE_TX_B\\n\", ch->is->name);\n\t\t\tch->state = STFAX_CONT;\n\t\t\tsend_mbox(ch->is, dps | ISAR_HIS_PUMPCTRL,\n\t\t\t\t  PCTRL_CMD_CONT, 0, NULL);\n\t\t} else {\n\t\t\tpr_debug(\"%s: pump stev LINE_TX_B wrong st %x\\n\",\n\t\t\t\t ch->is->name, ch->state);\n\t\t}\n\t\tbreak;\n\tcase PSEV_LINE_RX_B:\n\t\tif (ch->state == STFAX_LINE) {\n\t\t\tpr_debug(\"%s: pump stev LINE_RX_B\\n\", ch->is->name);\n\t\t\tch->state = STFAX_CONT;\n\t\t\tsend_mbox(ch->is, dps | ISAR_HIS_PUMPCTRL,\n\t\t\t\t  PCTRL_CMD_CONT, 0, NULL);\n\t\t} else {\n\t\t\tpr_debug(\"%s: pump stev LINE_RX_B wrong st %x\\n\",\n\t\t\t\t ch->is->name, ch->state);\n\t\t}\n\t\tbreak;\n\tcase PSEV_RSP_CONN:\n\t\tif (ch->state == STFAX_CONT) {\n\t\t\tpr_debug(\"%s: pump stev RSP_CONN\\n\", ch->is->name);\n\t\t\tch->state = STFAX_ACTIV;\n\t\t\ttest_and_set_bit(ISAR_RATE_REQ, &ch->is->Flags);\n\t\t\tsend_mbox(ch->is, dps | ISAR_HIS_PSTREQ, 0, 0, NULL);\n\t\t\tif (ch->cmd == PCTRL_CMD_FTH) {\n\t\t\t\tint delay = (ch->mod == 3) ? 1000 : 200;\n\t\t\t\t \n\t\t\t\tif (test_and_set_bit(FLG_FTI_RUN,\n\t\t\t\t\t\t     &ch->bch.Flags))\n\t\t\t\t\tdel_timer(&ch->ftimer);\n\t\t\t\tch->ftimer.expires =\n\t\t\t\t\tjiffies + ((delay * HZ) / 1000);\n\t\t\t\ttest_and_set_bit(FLG_LL_CONN,\n\t\t\t\t\t\t &ch->bch.Flags);\n\t\t\t\tadd_timer(&ch->ftimer);\n\t\t\t} else {\n\t\t\t\tdeliver_status(ch, HW_MOD_CONNECT);\n\t\t\t}\n\t\t} else {\n\t\t\tpr_debug(\"%s: pump stev RSP_CONN wrong st %x\\n\",\n\t\t\t\t ch->is->name, ch->state);\n\t\t}\n\t\tbreak;\n\tcase PSEV_FLAGS_DET:\n\t\tpr_debug(\"%s: pump stev FLAGS_DET\\n\", ch->is->name);\n\t\tbreak;\n\tcase PSEV_RSP_DISC:\n\t\tpr_debug(\"%s: pump stev RSP_DISC state(%d)\\n\",\n\t\t\t ch->is->name, ch->state);\n\t\tif (ch->state == STFAX_ESCAPE) {\n\t\t\tp1 = 5;\n\t\t\tswitch (ch->newcmd) {\n\t\t\tcase 0:\n\t\t\t\tch->state = STFAX_READY;\n\t\t\t\tbreak;\n\t\t\tcase PCTRL_CMD_FTM:\n\t\t\t\tp1 = 2;\n\t\t\t\tfallthrough;\n\t\t\tcase PCTRL_CMD_FTH:\n\t\t\t\tsend_mbox(ch->is, dps | ISAR_HIS_PUMPCTRL,\n\t\t\t\t\t  PCTRL_CMD_SILON, 1, &p1);\n\t\t\t\tch->state = STFAX_SILDET;\n\t\t\t\tbreak;\n\t\t\tcase PCTRL_CMD_FRH:\n\t\t\tcase PCTRL_CMD_FRM:\n\t\t\t\tch->mod = ch->newmod;\n\t\t\t\tp1 = ch->newmod;\n\t\t\t\tch->newmod = 0;\n\t\t\t\tch->cmd = ch->newcmd;\n\t\t\t\tch->newcmd = 0;\n\t\t\t\tsend_mbox(ch->is, dps | ISAR_HIS_PUMPCTRL,\n\t\t\t\t\t  ch->cmd, 1, &p1);\n\t\t\t\tch->state = STFAX_LINE;\n\t\t\t\tch->try_mod = 3;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tpr_debug(\"%s: RSP_DISC unknown newcmd %x\\n\",\n\t\t\t\t\t ch->is->name, ch->newcmd);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (ch->state == STFAX_ACTIV) {\n\t\t\tif (test_and_clear_bit(FLG_LL_OK, &ch->bch.Flags))\n\t\t\t\tdeliver_status(ch, HW_MOD_OK);\n\t\t\telse if (ch->cmd == PCTRL_CMD_FRM)\n\t\t\t\tdeliver_status(ch, HW_MOD_NOCARR);\n\t\t\telse\n\t\t\t\tdeliver_status(ch, HW_MOD_FCERROR);\n\t\t\tch->state = STFAX_READY;\n\t\t} else if (ch->state != STFAX_SILDET) {\n\t\t\t \n\t\t\tch->state = STFAX_READY;\n\t\t\tdeliver_status(ch, HW_MOD_FCERROR);\n\t\t}\n\t\tbreak;\n\tcase PSEV_RSP_SILDET:\n\t\tpr_debug(\"%s: pump stev RSP_SILDET\\n\", ch->is->name);\n\t\tif (ch->state == STFAX_SILDET) {\n\t\t\tch->mod = ch->newmod;\n\t\t\tp1 = ch->newmod;\n\t\t\tch->newmod = 0;\n\t\t\tch->cmd = ch->newcmd;\n\t\t\tch->newcmd = 0;\n\t\t\tsend_mbox(ch->is, dps | ISAR_HIS_PUMPCTRL,\n\t\t\t\t  ch->cmd, 1, &p1);\n\t\t\tch->state = STFAX_LINE;\n\t\t\tch->try_mod = 3;\n\t\t}\n\t\tbreak;\n\tcase PSEV_RSP_SILOFF:\n\t\tpr_debug(\"%s: pump stev RSP_SILOFF\\n\", ch->is->name);\n\t\tbreak;\n\tcase PSEV_RSP_FCERR:\n\t\tif (ch->state == STFAX_LINE) {\n\t\t\tpr_debug(\"%s: pump stev RSP_FCERR try %d\\n\",\n\t\t\t\t ch->is->name, ch->try_mod);\n\t\t\tif (ch->try_mod--) {\n\t\t\t\tsend_mbox(ch->is, dps | ISAR_HIS_PUMPCTRL,\n\t\t\t\t\t  ch->cmd, 1, &ch->mod);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tpr_debug(\"%s: pump stev RSP_FCERR\\n\", ch->is->name);\n\t\tch->state = STFAX_ESCAPE;\n\t\tsend_mbox(ch->is, dps | ISAR_HIS_PUMPCTRL, PCTRL_CMD_ESC,\n\t\t\t  0, NULL);\n\t\tdeliver_status(ch, HW_MOD_FCERROR);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nvoid\nmISDNisar_irq(struct isar_hw *isar)\n{\n\tstruct isar_ch *ch;\n\n\tget_irq_infos(isar);\n\tswitch (isar->iis & ISAR_IIS_MSCMSD) {\n\tcase ISAR_IIS_RDATA:\n\t\tch = sel_bch_isar(isar, isar->iis >> 6);\n\t\tif (ch)\n\t\t\tisar_rcv_frame(ch);\n\t\telse {\n\t\t\tpr_debug(\"%s: ISAR spurious IIS_RDATA %x/%x/%x\\n\",\n\t\t\t\t isar->name, isar->iis, isar->cmsb,\n\t\t\t\t isar->clsb);\n\t\t\tisar->write_reg(isar->hw, ISAR_IIA, 0);\n\t\t}\n\t\tbreak;\n\tcase ISAR_IIS_GSTEV:\n\t\tisar->write_reg(isar->hw, ISAR_IIA, 0);\n\t\tisar->bstat |= isar->cmsb;\n\t\tcheck_send(isar, isar->cmsb);\n\t\tbreak;\n\tcase ISAR_IIS_BSTEV:\n#ifdef ERROR_STATISTIC\n\t\tch = sel_bch_isar(isar, isar->iis >> 6);\n\t\tif (ch) {\n\t\t\tif (isar->cmsb == BSTEV_TBO)\n\t\t\t\tch->bch.err_tx++;\n\t\t\tif (isar->cmsb == BSTEV_RBO)\n\t\t\t\tch->bch.err_rdo++;\n\t\t}\n#endif\n\t\tpr_debug(\"%s: Buffer STEV dpath%d msb(%x)\\n\",\n\t\t\t isar->name, isar->iis >> 6, isar->cmsb);\n\t\tisar->write_reg(isar->hw, ISAR_IIA, 0);\n\t\tbreak;\n\tcase ISAR_IIS_PSTEV:\n\t\tch = sel_bch_isar(isar, isar->iis >> 6);\n\t\tif (ch) {\n\t\t\trcv_mbox(isar, NULL);\n\t\t\tif (ch->bch.state == ISDN_P_B_MODEM_ASYNC)\n\t\t\t\tisar_pump_statev_modem(ch, isar->cmsb);\n\t\t\telse if (ch->bch.state == ISDN_P_B_T30_FAX)\n\t\t\t\tisar_pump_statev_fax(ch, isar->cmsb);\n\t\t\telse if (ch->bch.state == ISDN_P_B_RAW) {\n\t\t\t\tint\ttt;\n\t\t\t\ttt = isar->cmsb | 0x30;\n\t\t\t\tif (tt == 0x3e)\n\t\t\t\t\ttt = '*';\n\t\t\t\telse if (tt == 0x3f)\n\t\t\t\t\ttt = '#';\n\t\t\t\telse if (tt > '9')\n\t\t\t\t\ttt += 7;\n\t\t\t\ttt |= DTMF_TONE_VAL;\n\t\t\t\t_queue_data(&ch->bch.ch, PH_CONTROL_IND,\n\t\t\t\t\t    MISDN_ID_ANY, sizeof(tt), &tt,\n\t\t\t\t\t    GFP_ATOMIC);\n\t\t\t} else\n\t\t\t\tpr_debug(\"%s: ISAR IIS_PSTEV pm %d sta %x\\n\",\n\t\t\t\t\t isar->name, ch->bch.state,\n\t\t\t\t\t isar->cmsb);\n\t\t} else {\n\t\t\tpr_debug(\"%s: ISAR spurious IIS_PSTEV %x/%x/%x\\n\",\n\t\t\t\t isar->name, isar->iis, isar->cmsb,\n\t\t\t\t isar->clsb);\n\t\t\tisar->write_reg(isar->hw, ISAR_IIA, 0);\n\t\t}\n\t\tbreak;\n\tcase ISAR_IIS_PSTRSP:\n\t\tch = sel_bch_isar(isar, isar->iis >> 6);\n\t\tif (ch) {\n\t\t\trcv_mbox(isar, NULL);\n\t\t\tisar_pump_status_rsp(ch);\n\t\t} else {\n\t\t\tpr_debug(\"%s: ISAR spurious IIS_PSTRSP %x/%x/%x\\n\",\n\t\t\t\t isar->name, isar->iis, isar->cmsb,\n\t\t\t\t isar->clsb);\n\t\t\tisar->write_reg(isar->hw, ISAR_IIA, 0);\n\t\t}\n\t\tbreak;\n\tcase ISAR_IIS_DIAG:\n\tcase ISAR_IIS_BSTRSP:\n\tcase ISAR_IIS_IOM2RSP:\n\t\trcv_mbox(isar, NULL);\n\t\tbreak;\n\tcase ISAR_IIS_INVMSG:\n\t\trcv_mbox(isar, NULL);\n\t\tpr_debug(\"%s: invalid msg his:%x\\n\", isar->name, isar->cmsb);\n\t\tbreak;\n\tdefault:\n\t\trcv_mbox(isar, NULL);\n\t\tpr_debug(\"%s: unhandled msg iis(%x) ctrl(%x/%x)\\n\",\n\t\t\t isar->name, isar->iis, isar->cmsb, isar->clsb);\n\t\tbreak;\n\t}\n}\nEXPORT_SYMBOL(mISDNisar_irq);\n\nstatic void\nftimer_handler(struct timer_list *t)\n{\n\tstruct isar_ch *ch = from_timer(ch, t, ftimer);\n\n\tpr_debug(\"%s: ftimer flags %lx\\n\", ch->is->name, ch->bch.Flags);\n\ttest_and_clear_bit(FLG_FTI_RUN, &ch->bch.Flags);\n\tif (test_and_clear_bit(FLG_LL_CONN, &ch->bch.Flags))\n\t\tdeliver_status(ch, HW_MOD_CONNECT);\n}\n\nstatic void\nsetup_pump(struct isar_ch *ch) {\n\tu8 dps = SET_DPS(ch->dpath);\n\tu8 ctrl, param[6];\n\n\tswitch (ch->bch.state) {\n\tcase ISDN_P_NONE:\n\tcase ISDN_P_B_RAW:\n\tcase ISDN_P_B_HDLC:\n\t\tsend_mbox(ch->is, dps | ISAR_HIS_PUMPCFG, PMOD_BYPASS, 0, NULL);\n\t\tbreak;\n\tcase ISDN_P_B_L2DTMF:\n\t\tif (test_bit(FLG_DTMFSEND, &ch->bch.Flags)) {\n\t\t\tparam[0] = 5;  \n\t\t\tsend_mbox(ch->is, dps | ISAR_HIS_PUMPCFG,\n\t\t\t\t  PMOD_DTMF_TRANS, 1, param);\n\t\t} else {\n\t\t\tparam[0] = 40;  \n\t\t\tsend_mbox(ch->is, dps | ISAR_HIS_PUMPCFG,\n\t\t\t\t  PMOD_DTMF, 1, param);\n\t\t}\n\t\tfallthrough;\n\tcase ISDN_P_B_MODEM_ASYNC:\n\t\tctrl = PMOD_DATAMODEM;\n\t\tif (test_bit(FLG_ORIGIN, &ch->bch.Flags)) {\n\t\t\tctrl |= PCTRL_ORIG;\n\t\t\tparam[5] = PV32P6_CTN;\n\t\t} else {\n\t\t\tparam[5] = PV32P6_ATN;\n\t\t}\n\t\tparam[0] = 6;  \n\t\tparam[1] = PV32P2_V23R | PV32P2_V22A | PV32P2_V22B |\n\t\t\tPV32P2_V22C | PV32P2_V21 | PV32P2_BEL;\n\t\tparam[2] = PV32P3_AMOD | PV32P3_V32B | PV32P3_V23B;\n\t\tparam[3] = PV32P4_UT144;\n\t\tparam[4] = PV32P5_UT144;\n\t\tsend_mbox(ch->is, dps | ISAR_HIS_PUMPCFG, ctrl, 6, param);\n\t\tbreak;\n\tcase ISDN_P_B_T30_FAX:\n\t\tctrl = PMOD_FAX;\n\t\tif (test_bit(FLG_ORIGIN, &ch->bch.Flags)) {\n\t\t\tctrl |= PCTRL_ORIG;\n\t\t\tparam[1] = PFAXP2_CTN;\n\t\t} else {\n\t\t\tparam[1] = PFAXP2_ATN;\n\t\t}\n\t\tparam[0] = 6;  \n\t\tsend_mbox(ch->is, dps | ISAR_HIS_PUMPCFG, ctrl, 2, param);\n\t\tch->state = STFAX_NULL;\n\t\tch->newcmd = 0;\n\t\tch->newmod = 0;\n\t\ttest_and_set_bit(FLG_FTI_RUN, &ch->bch.Flags);\n\t\tbreak;\n\t}\n\tudelay(1000);\n\tsend_mbox(ch->is, dps | ISAR_HIS_PSTREQ, 0, 0, NULL);\n\tudelay(1000);\n}\n\nstatic void\nsetup_sart(struct isar_ch *ch) {\n\tu8 dps = SET_DPS(ch->dpath);\n\tu8 ctrl, param[2] = {0, 0};\n\n\tswitch (ch->bch.state) {\n\tcase ISDN_P_NONE:\n\t\tsend_mbox(ch->is, dps | ISAR_HIS_SARTCFG, SMODE_DISABLE,\n\t\t\t  0, NULL);\n\t\tbreak;\n\tcase ISDN_P_B_RAW:\n\tcase ISDN_P_B_L2DTMF:\n\t\tsend_mbox(ch->is, dps | ISAR_HIS_SARTCFG, SMODE_BINARY,\n\t\t\t  2, param);\n\t\tbreak;\n\tcase ISDN_P_B_HDLC:\n\tcase ISDN_P_B_T30_FAX:\n\t\tsend_mbox(ch->is, dps | ISAR_HIS_SARTCFG, SMODE_HDLC,\n\t\t\t  1, param);\n\t\tbreak;\n\tcase ISDN_P_B_MODEM_ASYNC:\n\t\tctrl = SMODE_V14 | SCTRL_HDMC_BOTH;\n\t\tparam[0] = S_P1_CHS_8;\n\t\tparam[1] = S_P2_BFT_DEF;\n\t\tsend_mbox(ch->is, dps | ISAR_HIS_SARTCFG, ctrl, 2, param);\n\t\tbreak;\n\t}\n\tudelay(1000);\n\tsend_mbox(ch->is, dps | ISAR_HIS_BSTREQ, 0, 0, NULL);\n\tudelay(1000);\n}\n\nstatic void\nsetup_iom2(struct isar_ch *ch) {\n\tu8 dps = SET_DPS(ch->dpath);\n\tu8 cmsb = IOM_CTRL_ENA, msg[5] = {IOM_P1_TXD, 0, 0, 0, 0};\n\n\tif (ch->bch.nr == 2) {\n\t\tmsg[1] = 1;\n\t\tmsg[3] = 1;\n\t}\n\tswitch (ch->bch.state) {\n\tcase ISDN_P_NONE:\n\t\tcmsb = 0;\n\t\t \n\t\tmsg[1] = ch->dpath + 2;\n\t\tmsg[3] = ch->dpath + 2;\n\t\tbreak;\n\tcase ISDN_P_B_RAW:\n\tcase ISDN_P_B_HDLC:\n\t\tbreak;\n\tcase ISDN_P_B_MODEM_ASYNC:\n\tcase ISDN_P_B_T30_FAX:\n\t\tcmsb |= IOM_CTRL_RCV;\n\t\tfallthrough;\n\tcase ISDN_P_B_L2DTMF:\n\t\tif (test_bit(FLG_DTMFSEND, &ch->bch.Flags))\n\t\t\tcmsb |= IOM_CTRL_RCV;\n\t\tcmsb |= IOM_CTRL_ALAW;\n\t\tbreak;\n\t}\n\tsend_mbox(ch->is, dps | ISAR_HIS_IOM2CFG, cmsb, 5, msg);\n\tudelay(1000);\n\tsend_mbox(ch->is, dps | ISAR_HIS_IOM2REQ, 0, 0, NULL);\n\tudelay(1000);\n}\n\nstatic int\nmodeisar(struct isar_ch *ch, u32 bprotocol)\n{\n\t \n\tif (ch->bch.state == ISDN_P_NONE) {  \n\t\tswitch (bprotocol) {\n\t\tcase ISDN_P_NONE:  \n\t\t\tif (!ch->dpath)\n\t\t\t\t \n\t\t\t\treturn 0;\n\t\t\ttest_and_clear_bit(FLG_HDLC, &ch->bch.Flags);\n\t\t\ttest_and_clear_bit(FLG_TRANSPARENT, &ch->bch.Flags);\n\t\t\tbreak;\n\t\tcase ISDN_P_B_RAW:\n\t\tcase ISDN_P_B_HDLC:\n\t\t\t \n\t\t\tif (!test_and_set_bit(ISAR_DP2_USE, &ch->is->Flags))\n\t\t\t\tch->dpath = 2;\n\t\t\telse if (!test_and_set_bit(ISAR_DP1_USE,\n\t\t\t\t\t\t   &ch->is->Flags))\n\t\t\t\tch->dpath = 1;\n\t\t\telse {\n\t\t\t\tpr_info(\"modeisar both paths in use\\n\");\n\t\t\t\treturn -EBUSY;\n\t\t\t}\n\t\t\tif (bprotocol == ISDN_P_B_HDLC)\n\t\t\t\ttest_and_set_bit(FLG_HDLC, &ch->bch.Flags);\n\t\t\telse\n\t\t\t\ttest_and_set_bit(FLG_TRANSPARENT,\n\t\t\t\t\t\t &ch->bch.Flags);\n\t\t\tbreak;\n\t\tcase ISDN_P_B_MODEM_ASYNC:\n\t\tcase ISDN_P_B_T30_FAX:\n\t\tcase ISDN_P_B_L2DTMF:\n\t\t\t \n\t\t\tif (!test_and_set_bit(ISAR_DP1_USE, &ch->is->Flags))\n\t\t\t\tch->dpath = 1;\n\t\t\telse {\n\t\t\t\tpr_info(\"%s: ISAR modeisar analog functions\"\n\t\t\t\t\t\"only with DP1\\n\", ch->is->name);\n\t\t\t\treturn -EBUSY;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_info(\"%s: protocol not known %x\\n\", ch->is->name,\n\t\t\t\tbprotocol);\n\t\t\treturn -ENOPROTOOPT;\n\t\t}\n\t}\n\tpr_debug(\"%s: ISAR ch%d dp%d protocol %x->%x\\n\", ch->is->name,\n\t\t ch->bch.nr, ch->dpath, ch->bch.state, bprotocol);\n\tch->bch.state = bprotocol;\n\tsetup_pump(ch);\n\tsetup_iom2(ch);\n\tsetup_sart(ch);\n\tif (ch->bch.state == ISDN_P_NONE) {\n\t\t \n\t\tif (ch->dpath == 1)\n\t\t\ttest_and_clear_bit(ISAR_DP1_USE, &ch->is->Flags);\n\t\telse if (ch->dpath == 2)\n\t\t\ttest_and_clear_bit(ISAR_DP2_USE, &ch->is->Flags);\n\t\tch->dpath = 0;\n\t\tch->is->ctrl(ch->is->hw, HW_DEACT_IND, ch->bch.nr);\n\t} else\n\t\tch->is->ctrl(ch->is->hw, HW_ACTIVATE_IND, ch->bch.nr);\n\treturn 0;\n}\n\nstatic void\nisar_pump_cmd(struct isar_ch *ch, u32 cmd, u8 para)\n{\n\tu8 dps = SET_DPS(ch->dpath);\n\tu8 ctrl = 0, nom = 0, p1 = 0;\n\n\tpr_debug(\"%s: isar_pump_cmd %x/%x state(%x)\\n\",\n\t\t ch->is->name, cmd, para, ch->bch.state);\n\tswitch (cmd) {\n\tcase HW_MOD_FTM:\n\t\tif (ch->state == STFAX_READY) {\n\t\t\tp1 = para;\n\t\t\tctrl = PCTRL_CMD_FTM;\n\t\t\tnom = 1;\n\t\t\tch->state = STFAX_LINE;\n\t\t\tch->cmd = ctrl;\n\t\t\tch->mod = para;\n\t\t\tch->newmod = 0;\n\t\t\tch->newcmd = 0;\n\t\t\tch->try_mod = 3;\n\t\t} else if ((ch->state == STFAX_ACTIV) &&\n\t\t\t   (ch->cmd == PCTRL_CMD_FTM) && (ch->mod == para))\n\t\t\tdeliver_status(ch, HW_MOD_CONNECT);\n\t\telse {\n\t\t\tch->newmod = para;\n\t\t\tch->newcmd = PCTRL_CMD_FTM;\n\t\t\tnom = 0;\n\t\t\tctrl = PCTRL_CMD_ESC;\n\t\t\tch->state = STFAX_ESCAPE;\n\t\t}\n\t\tbreak;\n\tcase HW_MOD_FTH:\n\t\tif (ch->state == STFAX_READY) {\n\t\t\tp1 = para;\n\t\t\tctrl = PCTRL_CMD_FTH;\n\t\t\tnom = 1;\n\t\t\tch->state = STFAX_LINE;\n\t\t\tch->cmd = ctrl;\n\t\t\tch->mod = para;\n\t\t\tch->newmod = 0;\n\t\t\tch->newcmd = 0;\n\t\t\tch->try_mod = 3;\n\t\t} else if ((ch->state == STFAX_ACTIV) &&\n\t\t\t   (ch->cmd == PCTRL_CMD_FTH) && (ch->mod == para))\n\t\t\tdeliver_status(ch, HW_MOD_CONNECT);\n\t\telse {\n\t\t\tch->newmod = para;\n\t\t\tch->newcmd = PCTRL_CMD_FTH;\n\t\t\tnom = 0;\n\t\t\tctrl = PCTRL_CMD_ESC;\n\t\t\tch->state = STFAX_ESCAPE;\n\t\t}\n\t\tbreak;\n\tcase HW_MOD_FRM:\n\t\tif (ch->state == STFAX_READY) {\n\t\t\tp1 = para;\n\t\t\tctrl = PCTRL_CMD_FRM;\n\t\t\tnom = 1;\n\t\t\tch->state = STFAX_LINE;\n\t\t\tch->cmd = ctrl;\n\t\t\tch->mod = para;\n\t\t\tch->newmod = 0;\n\t\t\tch->newcmd = 0;\n\t\t\tch->try_mod = 3;\n\t\t} else if ((ch->state == STFAX_ACTIV) &&\n\t\t\t   (ch->cmd == PCTRL_CMD_FRM) && (ch->mod == para))\n\t\t\tdeliver_status(ch, HW_MOD_CONNECT);\n\t\telse {\n\t\t\tch->newmod = para;\n\t\t\tch->newcmd = PCTRL_CMD_FRM;\n\t\t\tnom = 0;\n\t\t\tctrl = PCTRL_CMD_ESC;\n\t\t\tch->state = STFAX_ESCAPE;\n\t\t}\n\t\tbreak;\n\tcase HW_MOD_FRH:\n\t\tif (ch->state == STFAX_READY) {\n\t\t\tp1 = para;\n\t\t\tctrl = PCTRL_CMD_FRH;\n\t\t\tnom = 1;\n\t\t\tch->state = STFAX_LINE;\n\t\t\tch->cmd = ctrl;\n\t\t\tch->mod = para;\n\t\t\tch->newmod = 0;\n\t\t\tch->newcmd = 0;\n\t\t\tch->try_mod = 3;\n\t\t} else if ((ch->state == STFAX_ACTIV) &&\n\t\t\t   (ch->cmd == PCTRL_CMD_FRH) && (ch->mod == para))\n\t\t\tdeliver_status(ch, HW_MOD_CONNECT);\n\t\telse {\n\t\t\tch->newmod = para;\n\t\t\tch->newcmd = PCTRL_CMD_FRH;\n\t\t\tnom = 0;\n\t\t\tctrl = PCTRL_CMD_ESC;\n\t\t\tch->state = STFAX_ESCAPE;\n\t\t}\n\t\tbreak;\n\tcase PCTRL_CMD_TDTMF:\n\t\tp1 = para;\n\t\tnom = 1;\n\t\tctrl = PCTRL_CMD_TDTMF;\n\t\tbreak;\n\t}\n\tif (ctrl)\n\t\tsend_mbox(ch->is, dps | ISAR_HIS_PUMPCTRL, ctrl, nom, &p1);\n}\n\nstatic void\nisar_setup(struct isar_hw *isar)\n{\n\tu8 msg;\n\tint i;\n\n\t \n\tmsg = 61;\n\tfor (i = 0; i < 2; i++) {\n\t\t \n\t\tsend_mbox(isar, (i ? ISAR_HIS_DPS2 : ISAR_HIS_DPS1) |\n\t\t\t  ISAR_HIS_P12CFG, 4, 1, &msg);\n\t\tisar->ch[i].mml = msg;\n\t\tisar->ch[i].bch.state = 0;\n\t\tisar->ch[i].dpath = i + 1;\n\t\tmodeisar(&isar->ch[i], ISDN_P_NONE);\n\t}\n}\n\nstatic int\nisar_l2l1(struct mISDNchannel *ch, struct sk_buff *skb)\n{\n\tstruct bchannel *bch = container_of(ch, struct bchannel, ch);\n\tstruct isar_ch *ich = container_of(bch, struct isar_ch, bch);\n\tint ret = -EINVAL;\n\tstruct mISDNhead *hh = mISDN_HEAD_P(skb);\n\tu32 id, *val;\n\tu_long flags;\n\n\tswitch (hh->prim) {\n\tcase PH_DATA_REQ:\n\t\tspin_lock_irqsave(ich->is->hwlock, flags);\n\t\tret = bchannel_senddata(bch, skb);\n\t\tif (ret > 0) {  \n\t\t\tret = 0;\n\t\t\tisar_fill_fifo(ich);\n\t\t}\n\t\tspin_unlock_irqrestore(ich->is->hwlock, flags);\n\t\treturn ret;\n\tcase PH_ACTIVATE_REQ:\n\t\tspin_lock_irqsave(ich->is->hwlock, flags);\n\t\tif (!test_and_set_bit(FLG_ACTIVE, &bch->Flags))\n\t\t\tret = modeisar(ich, ch->protocol);\n\t\telse\n\t\t\tret = 0;\n\t\tspin_unlock_irqrestore(ich->is->hwlock, flags);\n\t\tif (!ret)\n\t\t\t_queue_data(ch, PH_ACTIVATE_IND, MISDN_ID_ANY, 0,\n\t\t\t\t    NULL, GFP_KERNEL);\n\t\tbreak;\n\tcase PH_DEACTIVATE_REQ:\n\t\tspin_lock_irqsave(ich->is->hwlock, flags);\n\t\tmISDN_clear_bchannel(bch);\n\t\tmodeisar(ich, ISDN_P_NONE);\n\t\tspin_unlock_irqrestore(ich->is->hwlock, flags);\n\t\t_queue_data(ch, PH_DEACTIVATE_IND, MISDN_ID_ANY, 0,\n\t\t\t    NULL, GFP_KERNEL);\n\t\tret = 0;\n\t\tbreak;\n\tcase PH_CONTROL_REQ:\n\t\tval = (u32 *)skb->data;\n\t\tpr_debug(\"%s: PH_CONTROL | REQUEST %x/%x\\n\", ich->is->name,\n\t\t\t hh->id, *val);\n\t\tif ((hh->id == 0) && ((*val & ~DTMF_TONE_MASK) ==\n\t\t\t\t      DTMF_TONE_VAL)) {\n\t\t\tif (bch->state == ISDN_P_B_L2DTMF) {\n\t\t\t\tchar tt = *val & DTMF_TONE_MASK;\n\n\t\t\t\tif (tt == '*')\n\t\t\t\t\ttt = 0x1e;\n\t\t\t\telse if (tt == '#')\n\t\t\t\t\ttt = 0x1f;\n\t\t\t\telse if (tt > '9')\n\t\t\t\t\ttt -= 7;\n\t\t\t\ttt &= 0x1f;\n\t\t\t\tspin_lock_irqsave(ich->is->hwlock, flags);\n\t\t\t\tisar_pump_cmd(ich, PCTRL_CMD_TDTMF, tt);\n\t\t\t\tspin_unlock_irqrestore(ich->is->hwlock, flags);\n\t\t\t} else {\n\t\t\t\tpr_info(\"%s: DTMF send wrong protocol %x\\n\",\n\t\t\t\t\t__func__, bch->state);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t} else if ((hh->id == HW_MOD_FRM) || (hh->id == HW_MOD_FRH) ||\n\t\t\t   (hh->id == HW_MOD_FTM) || (hh->id == HW_MOD_FTH)) {\n\t\t\tfor (id = 0; id < FAXMODCNT; id++)\n\t\t\t\tif (faxmodulation[id] == *val)\n\t\t\t\t\tbreak;\n\t\t\tif ((FAXMODCNT > id) &&\n\t\t\t    test_bit(FLG_INITIALIZED, &bch->Flags)) {\n\t\t\t\tpr_debug(\"%s: isar: new mod\\n\", ich->is->name);\n\t\t\t\tisar_pump_cmd(ich, hh->id, *val);\n\t\t\t\tret = 0;\n\t\t\t} else {\n\t\t\t\tpr_info(\"%s: wrong modulation\\n\",\n\t\t\t\t\tich->is->name);\n\t\t\t\tret = -EINVAL;\n\t\t\t}\n\t\t} else if (hh->id == HW_MOD_LASTDATA)\n\t\t\ttest_and_set_bit(FLG_DLEETX, &bch->Flags);\n\t\telse {\n\t\t\tpr_info(\"%s: unknown PH_CONTROL_REQ %x\\n\",\n\t\t\t\tich->is->name, hh->id);\n\t\t\tret = -EINVAL;\n\t\t}\n\t\tfallthrough;\n\tdefault:\n\t\tpr_info(\"%s: %s unknown prim(%x,%x)\\n\",\n\t\t\tich->is->name, __func__, hh->prim, hh->id);\n\t\tret = -EINVAL;\n\t}\n\tif (!ret)\n\t\tdev_kfree_skb(skb);\n\treturn ret;\n}\n\nstatic int\nchannel_bctrl(struct bchannel *bch, struct mISDN_ctrl_req *cq)\n{\n\treturn mISDN_ctrl_bchannel(bch, cq);\n}\n\nstatic int\nisar_bctrl(struct mISDNchannel *ch, u32 cmd, void *arg)\n{\n\tstruct bchannel *bch = container_of(ch, struct bchannel, ch);\n\tstruct isar_ch *ich = container_of(bch, struct isar_ch, bch);\n\tint ret = -EINVAL;\n\tu_long flags;\n\n\tpr_debug(\"%s: %s cmd:%x %p\\n\", ich->is->name, __func__, cmd, arg);\n\tswitch (cmd) {\n\tcase CLOSE_CHANNEL:\n\t\ttest_and_clear_bit(FLG_OPEN, &bch->Flags);\n\t\tcancel_work_sync(&bch->workq);\n\t\tspin_lock_irqsave(ich->is->hwlock, flags);\n\t\tmISDN_clear_bchannel(bch);\n\t\tmodeisar(ich, ISDN_P_NONE);\n\t\tspin_unlock_irqrestore(ich->is->hwlock, flags);\n\t\tch->protocol = ISDN_P_NONE;\n\t\tch->peer = NULL;\n\t\tmodule_put(ich->is->owner);\n\t\tret = 0;\n\t\tbreak;\n\tcase CONTROL_CHANNEL:\n\t\tret = channel_bctrl(bch, arg);\n\t\tbreak;\n\tdefault:\n\t\tpr_info(\"%s: %s unknown prim(%x)\\n\",\n\t\t\tich->is->name, __func__, cmd);\n\t}\n\treturn ret;\n}\n\nstatic void\nfree_isar(struct isar_hw *isar)\n{\n\tmodeisar(&isar->ch[0], ISDN_P_NONE);\n\tmodeisar(&isar->ch[1], ISDN_P_NONE);\n\tdel_timer(&isar->ch[0].ftimer);\n\tdel_timer(&isar->ch[1].ftimer);\n\ttest_and_clear_bit(FLG_INITIALIZED, &isar->ch[0].bch.Flags);\n\ttest_and_clear_bit(FLG_INITIALIZED, &isar->ch[1].bch.Flags);\n}\n\nstatic int\ninit_isar(struct isar_hw *isar)\n{\n\tint\tcnt = 3;\n\n\twhile (cnt--) {\n\t\tisar->version = ISARVersion(isar);\n\t\tif (isar->ch[0].bch.debug & DEBUG_HW)\n\t\t\tpr_notice(\"%s: Testing version %d (%d time)\\n\",\n\t\t\t\t  isar->name, isar->version, 3 - cnt);\n\t\tif (isar->version == 1)\n\t\t\tbreak;\n\t\tisar->ctrl(isar->hw, HW_RESET_REQ, 0);\n\t}\n\tif (isar->version != 1)\n\t\treturn -EINVAL;\n\ttimer_setup(&isar->ch[0].ftimer, ftimer_handler, 0);\n\ttest_and_set_bit(FLG_INITIALIZED, &isar->ch[0].bch.Flags);\n\ttimer_setup(&isar->ch[1].ftimer, ftimer_handler, 0);\n\ttest_and_set_bit(FLG_INITIALIZED, &isar->ch[1].bch.Flags);\n\treturn 0;\n}\n\nstatic int\nisar_open(struct isar_hw *isar, struct channel_req *rq)\n{\n\tstruct bchannel\t\t*bch;\n\n\tif (rq->adr.channel == 0 || rq->adr.channel > 2)\n\t\treturn -EINVAL;\n\tif (rq->protocol == ISDN_P_NONE)\n\t\treturn -EINVAL;\n\tbch = &isar->ch[rq->adr.channel - 1].bch;\n\tif (test_and_set_bit(FLG_OPEN, &bch->Flags))\n\t\treturn -EBUSY;  \n\tbch->ch.protocol = rq->protocol;\n\trq->ch = &bch->ch;\n\treturn 0;\n}\n\nu32\nmISDNisar_init(struct isar_hw *isar, void *hw)\n{\n\tu32 ret, i;\n\n\tisar->hw = hw;\n\tfor (i = 0; i < 2; i++) {\n\t\tisar->ch[i].bch.nr = i + 1;\n\t\tmISDN_initbchannel(&isar->ch[i].bch, MAX_DATA_MEM, 32);\n\t\tisar->ch[i].bch.ch.nr = i + 1;\n\t\tisar->ch[i].bch.ch.send = &isar_l2l1;\n\t\tisar->ch[i].bch.ch.ctrl = isar_bctrl;\n\t\tisar->ch[i].bch.hw = hw;\n\t\tisar->ch[i].is = isar;\n\t}\n\n\tisar->init = &init_isar;\n\tisar->release = &free_isar;\n\tisar->firmware = &load_firmware;\n\tisar->open = &isar_open;\n\n\tret =\t(1 << (ISDN_P_B_RAW & ISDN_P_B_MASK)) |\n\t\t(1 << (ISDN_P_B_HDLC & ISDN_P_B_MASK)) |\n\t\t(1 << (ISDN_P_B_L2DTMF & ISDN_P_B_MASK)) |\n\t\t(1 << (ISDN_P_B_MODEM_ASYNC & ISDN_P_B_MASK)) |\n\t\t(1 << (ISDN_P_B_T30_FAX & ISDN_P_B_MASK));\n\n\treturn ret;\n}\nEXPORT_SYMBOL(mISDNisar_init);\n\nstatic int __init isar_mod_init(void)\n{\n\tpr_notice(\"mISDN: ISAR driver Rev. %s\\n\", ISAR_REV);\n\treturn 0;\n}\n\nstatic void __exit isar_mod_cleanup(void)\n{\n\tpr_notice(\"mISDN: ISAR module unloaded\\n\");\n}\nmodule_init(isar_mod_init);\nmodule_exit(isar_mod_cleanup);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}