{
  "module_name": "hfcsusb.c",
  "hash_id": "83ff60c850488418feebada0b21ec59c0cd3c5e8eda616e249d7e439049280cf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/isdn/hardware/mISDN/hfcsusb.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/usb.h>\n#include <linux/mISDNhw.h>\n#include <linux/slab.h>\n#include \"hfcsusb.h\"\n\nstatic unsigned int debug;\nstatic int poll = DEFAULT_TRANSP_BURST_SZ;\n\nstatic LIST_HEAD(HFClist);\nstatic DEFINE_RWLOCK(HFClock);\n\n\nMODULE_AUTHOR(\"Martin Bachem\");\nMODULE_LICENSE(\"GPL\");\nmodule_param(debug, uint, S_IRUGO | S_IWUSR);\nmodule_param(poll, int, 0);\n\nstatic int hfcsusb_cnt;\n\n \nstatic void hfcsusb_ph_command(struct hfcsusb *hw, u_char command);\nstatic void release_hw(struct hfcsusb *hw);\nstatic void reset_hfcsusb(struct hfcsusb *hw);\nstatic void setPortMode(struct hfcsusb *hw);\nstatic void hfcsusb_start_endpoint(struct hfcsusb *hw, int channel);\nstatic void hfcsusb_stop_endpoint(struct hfcsusb *hw, int channel);\nstatic int  hfcsusb_setup_bch(struct bchannel *bch, int protocol);\nstatic void deactivate_bchannel(struct bchannel *bch);\nstatic int  hfcsusb_ph_info(struct hfcsusb *hw);\n\n \nstatic void\nctrl_start_transfer(struct hfcsusb *hw)\n{\n\tif (debug & DBG_HFC_CALL_TRACE)\n\t\tprintk(KERN_DEBUG \"%s: %s\\n\", hw->name, __func__);\n\n\tif (hw->ctrl_cnt) {\n\t\thw->ctrl_urb->pipe = hw->ctrl_out_pipe;\n\t\thw->ctrl_urb->setup_packet = (u_char *)&hw->ctrl_write;\n\t\thw->ctrl_urb->transfer_buffer = NULL;\n\t\thw->ctrl_urb->transfer_buffer_length = 0;\n\t\thw->ctrl_write.wIndex =\n\t\t\tcpu_to_le16(hw->ctrl_buff[hw->ctrl_out_idx].hfcs_reg);\n\t\thw->ctrl_write.wValue =\n\t\t\tcpu_to_le16(hw->ctrl_buff[hw->ctrl_out_idx].reg_val);\n\n\t\tusb_submit_urb(hw->ctrl_urb, GFP_ATOMIC);\n\t}\n}\n\n \nstatic int write_reg(struct hfcsusb *hw, __u8 reg, __u8 val)\n{\n\tstruct ctrl_buf *buf;\n\n\tif (debug & DBG_HFC_CALL_TRACE)\n\t\tprintk(KERN_DEBUG \"%s: %s reg(0x%02x) val(0x%02x)\\n\",\n\t\t       hw->name, __func__, reg, val);\n\n\tspin_lock(&hw->ctrl_lock);\n\tif (hw->ctrl_cnt >= HFC_CTRL_BUFSIZE) {\n\t\tspin_unlock(&hw->ctrl_lock);\n\t\treturn 1;\n\t}\n\tbuf = &hw->ctrl_buff[hw->ctrl_in_idx];\n\tbuf->hfcs_reg = reg;\n\tbuf->reg_val = val;\n\tif (++hw->ctrl_in_idx >= HFC_CTRL_BUFSIZE)\n\t\thw->ctrl_in_idx = 0;\n\tif (++hw->ctrl_cnt == 1)\n\t\tctrl_start_transfer(hw);\n\tspin_unlock(&hw->ctrl_lock);\n\n\treturn 0;\n}\n\n \nstatic void\nctrl_complete(struct urb *urb)\n{\n\tstruct hfcsusb *hw = (struct hfcsusb *) urb->context;\n\n\tif (debug & DBG_HFC_CALL_TRACE)\n\t\tprintk(KERN_DEBUG \"%s: %s\\n\", hw->name, __func__);\n\n\turb->dev = hw->dev;\n\tif (hw->ctrl_cnt) {\n\t\thw->ctrl_cnt--;\t \n\t\tif (++hw->ctrl_out_idx >= HFC_CTRL_BUFSIZE)\n\t\t\thw->ctrl_out_idx = 0;\t \n\n\t\tctrl_start_transfer(hw);  \n\t}\n}\n\n \nstatic void\nset_led_bit(struct hfcsusb *hw, signed short led_bits, int set_on)\n{\n\tif (set_on) {\n\t\tif (led_bits < 0)\n\t\t\thw->led_state &= ~abs(led_bits);\n\t\telse\n\t\t\thw->led_state |= led_bits;\n\t} else {\n\t\tif (led_bits < 0)\n\t\t\thw->led_state |= abs(led_bits);\n\t\telse\n\t\t\thw->led_state &= ~led_bits;\n\t}\n}\n\n \nstatic void\nhandle_led(struct hfcsusb *hw, int event)\n{\n\tstruct hfcsusb_vdata *driver_info = (struct hfcsusb_vdata *)\n\t\thfcsusb_idtab[hw->vend_idx].driver_info;\n\t__u8 tmpled;\n\n\tif (driver_info->led_scheme == LED_OFF)\n\t\treturn;\n\ttmpled = hw->led_state;\n\n\tswitch (event) {\n\tcase LED_POWER_ON:\n\t\tset_led_bit(hw, driver_info->led_bits[0], 1);\n\t\tset_led_bit(hw, driver_info->led_bits[1], 0);\n\t\tset_led_bit(hw, driver_info->led_bits[2], 0);\n\t\tset_led_bit(hw, driver_info->led_bits[3], 0);\n\t\tbreak;\n\tcase LED_POWER_OFF:\n\t\tset_led_bit(hw, driver_info->led_bits[0], 0);\n\t\tset_led_bit(hw, driver_info->led_bits[1], 0);\n\t\tset_led_bit(hw, driver_info->led_bits[2], 0);\n\t\tset_led_bit(hw, driver_info->led_bits[3], 0);\n\t\tbreak;\n\tcase LED_S0_ON:\n\t\tset_led_bit(hw, driver_info->led_bits[1], 1);\n\t\tbreak;\n\tcase LED_S0_OFF:\n\t\tset_led_bit(hw, driver_info->led_bits[1], 0);\n\t\tbreak;\n\tcase LED_B1_ON:\n\t\tset_led_bit(hw, driver_info->led_bits[2], 1);\n\t\tbreak;\n\tcase LED_B1_OFF:\n\t\tset_led_bit(hw, driver_info->led_bits[2], 0);\n\t\tbreak;\n\tcase LED_B2_ON:\n\t\tset_led_bit(hw, driver_info->led_bits[3], 1);\n\t\tbreak;\n\tcase LED_B2_OFF:\n\t\tset_led_bit(hw, driver_info->led_bits[3], 0);\n\t\tbreak;\n\t}\n\n\tif (hw->led_state != tmpled) {\n\t\tif (debug & DBG_HFC_CALL_TRACE)\n\t\t\tprintk(KERN_DEBUG \"%s: %s reg(0x%02x) val(x%02x)\\n\",\n\t\t\t       hw->name, __func__,\n\t\t\t       HFCUSB_P_DATA, hw->led_state);\n\n\t\twrite_reg(hw, HFCUSB_P_DATA, hw->led_state);\n\t}\n}\n\n \nstatic int\nhfcusb_l2l1B(struct mISDNchannel *ch, struct sk_buff *skb)\n{\n\tstruct bchannel\t\t*bch = container_of(ch, struct bchannel, ch);\n\tstruct hfcsusb\t\t*hw = bch->hw;\n\tint\t\t\tret = -EINVAL;\n\tstruct mISDNhead\t*hh = mISDN_HEAD_P(skb);\n\tu_long\t\t\tflags;\n\n\tif (debug & DBG_HFC_CALL_TRACE)\n\t\tprintk(KERN_DEBUG \"%s: %s\\n\", hw->name, __func__);\n\n\tswitch (hh->prim) {\n\tcase PH_DATA_REQ:\n\t\tspin_lock_irqsave(&hw->lock, flags);\n\t\tret = bchannel_senddata(bch, skb);\n\t\tspin_unlock_irqrestore(&hw->lock, flags);\n\t\tif (debug & DBG_HFC_CALL_TRACE)\n\t\t\tprintk(KERN_DEBUG \"%s: %s PH_DATA_REQ ret(%i)\\n\",\n\t\t\t       hw->name, __func__, ret);\n\t\tif (ret > 0)\n\t\t\tret = 0;\n\t\treturn ret;\n\tcase PH_ACTIVATE_REQ:\n\t\tif (!test_and_set_bit(FLG_ACTIVE, &bch->Flags)) {\n\t\t\thfcsusb_start_endpoint(hw, bch->nr - 1);\n\t\t\tret = hfcsusb_setup_bch(bch, ch->protocol);\n\t\t} else\n\t\t\tret = 0;\n\t\tif (!ret)\n\t\t\t_queue_data(ch, PH_ACTIVATE_IND, MISDN_ID_ANY,\n\t\t\t\t    0, NULL, GFP_KERNEL);\n\t\tbreak;\n\tcase PH_DEACTIVATE_REQ:\n\t\tdeactivate_bchannel(bch);\n\t\t_queue_data(ch, PH_DEACTIVATE_IND, MISDN_ID_ANY,\n\t\t\t    0, NULL, GFP_KERNEL);\n\t\tret = 0;\n\t\tbreak;\n\t}\n\tif (!ret)\n\t\tdev_kfree_skb(skb);\n\treturn ret;\n}\n\n \nstatic int\nhfcsusb_ph_info(struct hfcsusb *hw)\n{\n\tstruct ph_info *phi;\n\tstruct dchannel *dch = &hw->dch;\n\tint i;\n\n\tphi = kzalloc(struct_size(phi, bch, dch->dev.nrbchan), GFP_ATOMIC);\n\tif (!phi)\n\t\treturn -ENOMEM;\n\n\tphi->dch.ch.protocol = hw->protocol;\n\tphi->dch.ch.Flags = dch->Flags;\n\tphi->dch.state = dch->state;\n\tphi->dch.num_bch = dch->dev.nrbchan;\n\tfor (i = 0; i < dch->dev.nrbchan; i++) {\n\t\tphi->bch[i].protocol = hw->bch[i].ch.protocol;\n\t\tphi->bch[i].Flags = hw->bch[i].Flags;\n\t}\n\t_queue_data(&dch->dev.D, MPH_INFORMATION_IND, MISDN_ID_ANY,\n\t\t    struct_size(phi, bch, dch->dev.nrbchan), phi, GFP_ATOMIC);\n\tkfree(phi);\n\n\treturn 0;\n}\n\n \nstatic int\nhfcusb_l2l1D(struct mISDNchannel *ch, struct sk_buff *skb)\n{\n\tstruct mISDNdevice\t*dev = container_of(ch, struct mISDNdevice, D);\n\tstruct dchannel\t\t*dch = container_of(dev, struct dchannel, dev);\n\tstruct mISDNhead\t*hh = mISDN_HEAD_P(skb);\n\tstruct hfcsusb\t\t*hw = dch->hw;\n\tint\t\t\tret = -EINVAL;\n\tu_long\t\t\tflags;\n\n\tswitch (hh->prim) {\n\tcase PH_DATA_REQ:\n\t\tif (debug & DBG_HFC_CALL_TRACE)\n\t\t\tprintk(KERN_DEBUG \"%s: %s: PH_DATA_REQ\\n\",\n\t\t\t       hw->name, __func__);\n\n\t\tspin_lock_irqsave(&hw->lock, flags);\n\t\tret = dchannel_senddata(dch, skb);\n\t\tspin_unlock_irqrestore(&hw->lock, flags);\n\t\tif (ret > 0) {\n\t\t\tret = 0;\n\t\t\tqueue_ch_frame(ch, PH_DATA_CNF, hh->id, NULL);\n\t\t}\n\t\tbreak;\n\n\tcase PH_ACTIVATE_REQ:\n\t\tif (debug & DBG_HFC_CALL_TRACE)\n\t\t\tprintk(KERN_DEBUG \"%s: %s: PH_ACTIVATE_REQ %s\\n\",\n\t\t\t       hw->name, __func__,\n\t\t\t       (hw->protocol == ISDN_P_NT_S0) ? \"NT\" : \"TE\");\n\n\t\tif (hw->protocol == ISDN_P_NT_S0) {\n\t\t\tret = 0;\n\t\t\tif (test_bit(FLG_ACTIVE, &dch->Flags)) {\n\t\t\t\t_queue_data(&dch->dev.D,\n\t\t\t\t\t    PH_ACTIVATE_IND, MISDN_ID_ANY, 0,\n\t\t\t\t\t    NULL, GFP_ATOMIC);\n\t\t\t} else {\n\t\t\t\thfcsusb_ph_command(hw,\n\t\t\t\t\t\t   HFC_L1_ACTIVATE_NT);\n\t\t\t\ttest_and_set_bit(FLG_L2_ACTIVATED,\n\t\t\t\t\t\t &dch->Flags);\n\t\t\t}\n\t\t} else {\n\t\t\thfcsusb_ph_command(hw, HFC_L1_ACTIVATE_TE);\n\t\t\tret = l1_event(dch->l1, hh->prim);\n\t\t}\n\t\tbreak;\n\n\tcase PH_DEACTIVATE_REQ:\n\t\tif (debug & DBG_HFC_CALL_TRACE)\n\t\t\tprintk(KERN_DEBUG \"%s: %s: PH_DEACTIVATE_REQ\\n\",\n\t\t\t       hw->name, __func__);\n\t\ttest_and_clear_bit(FLG_L2_ACTIVATED, &dch->Flags);\n\n\t\tif (hw->protocol == ISDN_P_NT_S0) {\n\t\t\tstruct sk_buff_head free_queue;\n\n\t\t\t__skb_queue_head_init(&free_queue);\n\t\t\thfcsusb_ph_command(hw, HFC_L1_DEACTIVATE_NT);\n\t\t\tspin_lock_irqsave(&hw->lock, flags);\n\t\t\tskb_queue_splice_init(&dch->squeue, &free_queue);\n\t\t\tif (dch->tx_skb) {\n\t\t\t\t__skb_queue_tail(&free_queue, dch->tx_skb);\n\t\t\t\tdch->tx_skb = NULL;\n\t\t\t}\n\t\t\tdch->tx_idx = 0;\n\t\t\tif (dch->rx_skb) {\n\t\t\t\t__skb_queue_tail(&free_queue, dch->rx_skb);\n\t\t\t\tdch->rx_skb = NULL;\n\t\t\t}\n\t\t\ttest_and_clear_bit(FLG_TX_BUSY, &dch->Flags);\n\t\t\tspin_unlock_irqrestore(&hw->lock, flags);\n\t\t\t__skb_queue_purge(&free_queue);\n#ifdef FIXME\n\t\t\tif (test_and_clear_bit(FLG_L1_BUSY, &dch->Flags))\n\t\t\t\tdchannel_sched_event(&hc->dch, D_CLEARBUSY);\n#endif\n\t\t\tret = 0;\n\t\t} else\n\t\t\tret = l1_event(dch->l1, hh->prim);\n\t\tbreak;\n\tcase MPH_INFORMATION_REQ:\n\t\tret = hfcsusb_ph_info(hw);\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\n \nstatic int\nhfc_l1callback(struct dchannel *dch, u_int cmd)\n{\n\tstruct hfcsusb *hw = dch->hw;\n\n\tif (debug & DBG_HFC_CALL_TRACE)\n\t\tprintk(KERN_DEBUG \"%s: %s cmd 0x%x\\n\",\n\t\t       hw->name, __func__, cmd);\n\n\tswitch (cmd) {\n\tcase INFO3_P8:\n\tcase INFO3_P10:\n\tcase HW_RESET_REQ:\n\tcase HW_POWERUP_REQ:\n\t\tbreak;\n\n\tcase HW_DEACT_REQ:\n\t\tskb_queue_purge(&dch->squeue);\n\t\tif (dch->tx_skb) {\n\t\t\tdev_kfree_skb(dch->tx_skb);\n\t\t\tdch->tx_skb = NULL;\n\t\t}\n\t\tdch->tx_idx = 0;\n\t\tif (dch->rx_skb) {\n\t\t\tdev_kfree_skb(dch->rx_skb);\n\t\t\tdch->rx_skb = NULL;\n\t\t}\n\t\ttest_and_clear_bit(FLG_TX_BUSY, &dch->Flags);\n\t\tbreak;\n\tcase PH_ACTIVATE_IND:\n\t\ttest_and_set_bit(FLG_ACTIVE, &dch->Flags);\n\t\t_queue_data(&dch->dev.D, cmd, MISDN_ID_ANY, 0, NULL,\n\t\t\t    GFP_ATOMIC);\n\t\tbreak;\n\tcase PH_DEACTIVATE_IND:\n\t\ttest_and_clear_bit(FLG_ACTIVE, &dch->Flags);\n\t\t_queue_data(&dch->dev.D, cmd, MISDN_ID_ANY, 0, NULL,\n\t\t\t    GFP_ATOMIC);\n\t\tbreak;\n\tdefault:\n\t\tif (dch->debug & DEBUG_HW)\n\t\t\tprintk(KERN_DEBUG \"%s: %s: unknown cmd %x\\n\",\n\t\t\t       hw->name, __func__, cmd);\n\t\treturn -1;\n\t}\n\treturn hfcsusb_ph_info(hw);\n}\n\nstatic int\nopen_dchannel(struct hfcsusb *hw, struct mISDNchannel *ch,\n\t      struct channel_req *rq)\n{\n\tint err = 0;\n\n\tif (debug & DEBUG_HW_OPEN)\n\t\tprintk(KERN_DEBUG \"%s: %s: dev(%d) open addr(%i) from %p\\n\",\n\t\t       hw->name, __func__, hw->dch.dev.id, rq->adr.channel,\n\t\t       __builtin_return_address(0));\n\tif (rq->protocol == ISDN_P_NONE)\n\t\treturn -EINVAL;\n\n\ttest_and_clear_bit(FLG_ACTIVE, &hw->dch.Flags);\n\ttest_and_clear_bit(FLG_ACTIVE, &hw->ech.Flags);\n\thfcsusb_start_endpoint(hw, HFC_CHAN_D);\n\n\t \n\tif (rq->adr.channel == 1) {\n\t\tif (hw->fifos[HFCUSB_PCM_RX].pipe) {\n\t\t\thfcsusb_start_endpoint(hw, HFC_CHAN_E);\n\t\t\tset_bit(FLG_ACTIVE, &hw->ech.Flags);\n\t\t\t_queue_data(&hw->ech.dev.D, PH_ACTIVATE_IND,\n\t\t\t\t    MISDN_ID_ANY, 0, NULL, GFP_ATOMIC);\n\t\t} else\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (!hw->initdone) {\n\t\thw->protocol = rq->protocol;\n\t\tif (rq->protocol == ISDN_P_TE_S0) {\n\t\t\terr = create_l1(&hw->dch, hfc_l1callback);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\tsetPortMode(hw);\n\t\tch->protocol = rq->protocol;\n\t\thw->initdone = 1;\n\t} else {\n\t\tif (rq->protocol != ch->protocol)\n\t\t\treturn -EPROTONOSUPPORT;\n\t}\n\n\tif (((ch->protocol == ISDN_P_NT_S0) && (hw->dch.state == 3)) ||\n\t    ((ch->protocol == ISDN_P_TE_S0) && (hw->dch.state == 7)))\n\t\t_queue_data(ch, PH_ACTIVATE_IND, MISDN_ID_ANY,\n\t\t\t    0, NULL, GFP_KERNEL);\n\trq->ch = ch;\n\tif (!try_module_get(THIS_MODULE))\n\t\tprintk(KERN_WARNING \"%s: %s: cannot get module\\n\",\n\t\t       hw->name, __func__);\n\treturn 0;\n}\n\nstatic int\nopen_bchannel(struct hfcsusb *hw, struct channel_req *rq)\n{\n\tstruct bchannel\t\t*bch;\n\n\tif (rq->adr.channel == 0 || rq->adr.channel > 2)\n\t\treturn -EINVAL;\n\tif (rq->protocol == ISDN_P_NONE)\n\t\treturn -EINVAL;\n\n\tif (debug & DBG_HFC_CALL_TRACE)\n\t\tprintk(KERN_DEBUG \"%s: %s B%i\\n\",\n\t\t       hw->name, __func__, rq->adr.channel);\n\n\tbch = &hw->bch[rq->adr.channel - 1];\n\tif (test_and_set_bit(FLG_OPEN, &bch->Flags))\n\t\treturn -EBUSY;  \n\tbch->ch.protocol = rq->protocol;\n\trq->ch = &bch->ch;\n\n\tif (!try_module_get(THIS_MODULE))\n\t\tprintk(KERN_WARNING \"%s: %s:cannot get module\\n\",\n\t\t       hw->name, __func__);\n\treturn 0;\n}\n\nstatic int\nchannel_ctrl(struct hfcsusb *hw, struct mISDN_ctrl_req *cq)\n{\n\tint ret = 0;\n\n\tif (debug & DBG_HFC_CALL_TRACE)\n\t\tprintk(KERN_DEBUG \"%s: %s op(0x%x) channel(0x%x)\\n\",\n\t\t       hw->name, __func__, (cq->op), (cq->channel));\n\n\tswitch (cq->op) {\n\tcase MISDN_CTRL_GETOP:\n\t\tcq->op = MISDN_CTRL_LOOP | MISDN_CTRL_CONNECT |\n\t\t\tMISDN_CTRL_DISCONNECT;\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_WARNING \"%s: %s: unknown Op %x\\n\",\n\t\t       hw->name, __func__, cq->op);\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\n \nstatic int\nhfc_dctrl(struct mISDNchannel *ch, u_int cmd, void *arg)\n{\n\tstruct mISDNdevice\t*dev = container_of(ch, struct mISDNdevice, D);\n\tstruct dchannel\t\t*dch = container_of(dev, struct dchannel, dev);\n\tstruct hfcsusb\t\t*hw = dch->hw;\n\tstruct channel_req\t*rq;\n\tint\t\t\terr = 0;\n\n\tif (dch->debug & DEBUG_HW)\n\t\tprintk(KERN_DEBUG \"%s: %s: cmd:%x %p\\n\",\n\t\t       hw->name, __func__, cmd, arg);\n\tswitch (cmd) {\n\tcase OPEN_CHANNEL:\n\t\trq = arg;\n\t\tif ((rq->protocol == ISDN_P_TE_S0) ||\n\t\t    (rq->protocol == ISDN_P_NT_S0))\n\t\t\terr = open_dchannel(hw, ch, rq);\n\t\telse\n\t\t\terr = open_bchannel(hw, rq);\n\t\tif (!err)\n\t\t\thw->open++;\n\t\tbreak;\n\tcase CLOSE_CHANNEL:\n\t\thw->open--;\n\t\tif (debug & DEBUG_HW_OPEN)\n\t\t\tprintk(KERN_DEBUG\n\t\t\t       \"%s: %s: dev(%d) close from %p (open %d)\\n\",\n\t\t\t       hw->name, __func__, hw->dch.dev.id,\n\t\t\t       __builtin_return_address(0), hw->open);\n\t\tif (!hw->open) {\n\t\t\thfcsusb_stop_endpoint(hw, HFC_CHAN_D);\n\t\t\tif (hw->fifos[HFCUSB_PCM_RX].pipe)\n\t\t\t\thfcsusb_stop_endpoint(hw, HFC_CHAN_E);\n\t\t\thandle_led(hw, LED_POWER_ON);\n\t\t}\n\t\tmodule_put(THIS_MODULE);\n\t\tbreak;\n\tcase CONTROL_CHANNEL:\n\t\terr = channel_ctrl(hw, arg);\n\t\tbreak;\n\tdefault:\n\t\tif (dch->debug & DEBUG_HW)\n\t\t\tprintk(KERN_DEBUG \"%s: %s: unknown command %x\\n\",\n\t\t\t       hw->name, __func__, cmd);\n\t\treturn -EINVAL;\n\t}\n\treturn err;\n}\n\n \nstatic void\nph_state_te(struct dchannel *dch)\n{\n\tstruct hfcsusb *hw = dch->hw;\n\n\tif (debug & DEBUG_HW) {\n\t\tif (dch->state <= HFC_MAX_TE_LAYER1_STATE)\n\t\t\tprintk(KERN_DEBUG \"%s: %s: %s\\n\", hw->name, __func__,\n\t\t\t       HFC_TE_LAYER1_STATES[dch->state]);\n\t\telse\n\t\t\tprintk(KERN_DEBUG \"%s: %s: TE F%d\\n\",\n\t\t\t       hw->name, __func__, dch->state);\n\t}\n\n\tswitch (dch->state) {\n\tcase 0:\n\t\tl1_event(dch->l1, HW_RESET_IND);\n\t\tbreak;\n\tcase 3:\n\t\tl1_event(dch->l1, HW_DEACT_IND);\n\t\tbreak;\n\tcase 5:\n\tcase 8:\n\t\tl1_event(dch->l1, ANYSIGNAL);\n\t\tbreak;\n\tcase 6:\n\t\tl1_event(dch->l1, INFO2);\n\t\tbreak;\n\tcase 7:\n\t\tl1_event(dch->l1, INFO4_P8);\n\t\tbreak;\n\t}\n\tif (dch->state == 7)\n\t\thandle_led(hw, LED_S0_ON);\n\telse\n\t\thandle_led(hw, LED_S0_OFF);\n}\n\n \nstatic void\nph_state_nt(struct dchannel *dch)\n{\n\tstruct hfcsusb *hw = dch->hw;\n\n\tif (debug & DEBUG_HW) {\n\t\tif (dch->state <= HFC_MAX_NT_LAYER1_STATE)\n\t\t\tprintk(KERN_DEBUG \"%s: %s: %s\\n\",\n\t\t\t       hw->name, __func__,\n\t\t\t       HFC_NT_LAYER1_STATES[dch->state]);\n\n\t\telse\n\t\t\tprintk(KERN_INFO DRIVER_NAME \"%s: %s: NT G%d\\n\",\n\t\t\t       hw->name, __func__, dch->state);\n\t}\n\n\tswitch (dch->state) {\n\tcase (1):\n\t\ttest_and_clear_bit(FLG_ACTIVE, &dch->Flags);\n\t\ttest_and_clear_bit(FLG_L2_ACTIVATED, &dch->Flags);\n\t\thw->nt_timer = 0;\n\t\thw->timers &= ~NT_ACTIVATION_TIMER;\n\t\thandle_led(hw, LED_S0_OFF);\n\t\tbreak;\n\n\tcase (2):\n\t\tif (hw->nt_timer < 0) {\n\t\t\thw->nt_timer = 0;\n\t\t\thw->timers &= ~NT_ACTIVATION_TIMER;\n\t\t\thfcsusb_ph_command(dch->hw, HFC_L1_DEACTIVATE_NT);\n\t\t} else {\n\t\t\thw->timers |= NT_ACTIVATION_TIMER;\n\t\t\thw->nt_timer = NT_T1_COUNT;\n\t\t\t \n\t\t\twrite_reg(hw, HFCUSB_STATES, 2 | HFCUSB_NT_G2_G3);\n\t\t}\n\t\tbreak;\n\tcase (3):\n\t\thw->nt_timer = 0;\n\t\thw->timers &= ~NT_ACTIVATION_TIMER;\n\t\ttest_and_set_bit(FLG_ACTIVE, &dch->Flags);\n\t\t_queue_data(&dch->dev.D, PH_ACTIVATE_IND,\n\t\t\t    MISDN_ID_ANY, 0, NULL, GFP_ATOMIC);\n\t\thandle_led(hw, LED_S0_ON);\n\t\tbreak;\n\tcase (4):\n\t\thw->nt_timer = 0;\n\t\thw->timers &= ~NT_ACTIVATION_TIMER;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\thfcsusb_ph_info(hw);\n}\n\nstatic void\nph_state(struct dchannel *dch)\n{\n\tstruct hfcsusb *hw = dch->hw;\n\n\tif (hw->protocol == ISDN_P_NT_S0)\n\t\tph_state_nt(dch);\n\telse if (hw->protocol == ISDN_P_TE_S0)\n\t\tph_state_te(dch);\n}\n\n \nstatic int\nhfcsusb_setup_bch(struct bchannel *bch, int protocol)\n{\n\tstruct hfcsusb *hw = bch->hw;\n\t__u8 conhdlc, sctrl, sctrl_r;\n\n\tif (debug & DEBUG_HW)\n\t\tprintk(KERN_DEBUG \"%s: %s: protocol %x-->%x B%d\\n\",\n\t\t       hw->name, __func__, bch->state, protocol,\n\t\t       bch->nr);\n\n\t \n\tconhdlc = 0;\n\tif (protocol > ISDN_P_NONE)\n\t\tconhdlc = 8;\t \n\n\tswitch (protocol) {\n\tcase (-1):\t \n\t\tbch->state = -1;\n\t\tfallthrough;\n\tcase (ISDN_P_NONE):\n\t\tif (bch->state == ISDN_P_NONE)\n\t\t\treturn 0;  \n\t\tbch->state = ISDN_P_NONE;\n\t\tclear_bit(FLG_HDLC, &bch->Flags);\n\t\tclear_bit(FLG_TRANSPARENT, &bch->Flags);\n\t\tbreak;\n\tcase (ISDN_P_B_RAW):\n\t\tconhdlc |= 2;\n\t\tbch->state = protocol;\n\t\tset_bit(FLG_TRANSPARENT, &bch->Flags);\n\t\tbreak;\n\tcase (ISDN_P_B_HDLC):\n\t\tbch->state = protocol;\n\t\tset_bit(FLG_HDLC, &bch->Flags);\n\t\tbreak;\n\tdefault:\n\t\tif (debug & DEBUG_HW)\n\t\t\tprintk(KERN_DEBUG \"%s: %s: prot not known %x\\n\",\n\t\t\t       hw->name, __func__, protocol);\n\t\treturn -ENOPROTOOPT;\n\t}\n\n\tif (protocol >= ISDN_P_NONE) {\n\t\twrite_reg(hw, HFCUSB_FIFO, (bch->nr == 1) ? 0 : 2);\n\t\twrite_reg(hw, HFCUSB_CON_HDLC, conhdlc);\n\t\twrite_reg(hw, HFCUSB_INC_RES_F, 2);\n\t\twrite_reg(hw, HFCUSB_FIFO, (bch->nr == 1) ? 1 : 3);\n\t\twrite_reg(hw, HFCUSB_CON_HDLC, conhdlc);\n\t\twrite_reg(hw, HFCUSB_INC_RES_F, 2);\n\n\t\tsctrl = 0x40 + ((hw->protocol == ISDN_P_TE_S0) ? 0x00 : 0x04);\n\t\tsctrl_r = 0x0;\n\t\tif (test_bit(FLG_ACTIVE, &hw->bch[0].Flags)) {\n\t\t\tsctrl |= 1;\n\t\t\tsctrl_r |= 1;\n\t\t}\n\t\tif (test_bit(FLG_ACTIVE, &hw->bch[1].Flags)) {\n\t\t\tsctrl |= 2;\n\t\t\tsctrl_r |= 2;\n\t\t}\n\t\twrite_reg(hw, HFCUSB_SCTRL, sctrl);\n\t\twrite_reg(hw, HFCUSB_SCTRL_R, sctrl_r);\n\n\t\tif (protocol > ISDN_P_NONE)\n\t\t\thandle_led(hw, (bch->nr == 1) ? LED_B1_ON : LED_B2_ON);\n\t\telse\n\t\t\thandle_led(hw, (bch->nr == 1) ? LED_B1_OFF :\n\t\t\t\t   LED_B2_OFF);\n\t}\n\treturn hfcsusb_ph_info(hw);\n}\n\nstatic void\nhfcsusb_ph_command(struct hfcsusb *hw, u_char command)\n{\n\tif (debug & DEBUG_HW)\n\t\tprintk(KERN_DEBUG \"%s: %s: %x\\n\",\n\t\t       hw->name, __func__, command);\n\n\tswitch (command) {\n\tcase HFC_L1_ACTIVATE_TE:\n\t\t \n\t\twrite_reg(hw, HFCUSB_STATES, 0x14);\n\t\t \n\t\twrite_reg(hw, HFCUSB_STATES, 0x04);\n\t\tbreak;\n\n\tcase HFC_L1_FORCE_DEACTIVATE_TE:\n\t\twrite_reg(hw, HFCUSB_STATES, 0x10);\n\t\twrite_reg(hw, HFCUSB_STATES, 0x03);\n\t\tbreak;\n\n\tcase HFC_L1_ACTIVATE_NT:\n\t\tif (hw->dch.state == 3)\n\t\t\t_queue_data(&hw->dch.dev.D, PH_ACTIVATE_IND,\n\t\t\t\t    MISDN_ID_ANY, 0, NULL, GFP_ATOMIC);\n\t\telse\n\t\t\twrite_reg(hw, HFCUSB_STATES, HFCUSB_ACTIVATE |\n\t\t\t\t  HFCUSB_DO_ACTION | HFCUSB_NT_G2_G3);\n\t\tbreak;\n\n\tcase HFC_L1_DEACTIVATE_NT:\n\t\twrite_reg(hw, HFCUSB_STATES,\n\t\t\t  HFCUSB_DO_ACTION);\n\t\tbreak;\n\t}\n}\n\n \nstatic int\nchannel_bctrl(struct bchannel *bch, struct mISDN_ctrl_req *cq)\n{\n\treturn mISDN_ctrl_bchannel(bch, cq);\n}\n\n \nstatic void\nhfcsusb_rx_frame(struct usb_fifo *fifo, __u8 *data, unsigned int len,\n\t\t int finish)\n{\n\tstruct hfcsusb\t*hw = fifo->hw;\n\tstruct sk_buff\t*rx_skb = NULL;\n\tint\t\tmaxlen = 0;\n\tint\t\tfifon = fifo->fifonum;\n\tint\t\ti;\n\tint\t\thdlc = 0;\n\tunsigned long\tflags;\n\n\tif (debug & DBG_HFC_CALL_TRACE)\n\t\tprintk(KERN_DEBUG \"%s: %s: fifo(%i) len(%i) \"\n\t\t       \"dch(%p) bch(%p) ech(%p)\\n\",\n\t\t       hw->name, __func__, fifon, len,\n\t\t       fifo->dch, fifo->bch, fifo->ech);\n\n\tif (!len)\n\t\treturn;\n\n\tif ((!!fifo->dch + !!fifo->bch + !!fifo->ech) != 1) {\n\t\tprintk(KERN_DEBUG \"%s: %s: undefined channel\\n\",\n\t\t       hw->name, __func__);\n\t\treturn;\n\t}\n\n\tspin_lock_irqsave(&hw->lock, flags);\n\tif (fifo->dch) {\n\t\trx_skb = fifo->dch->rx_skb;\n\t\tmaxlen = fifo->dch->maxlen;\n\t\thdlc = 1;\n\t}\n\tif (fifo->bch) {\n\t\tif (test_bit(FLG_RX_OFF, &fifo->bch->Flags)) {\n\t\t\tfifo->bch->dropcnt += len;\n\t\t\tspin_unlock_irqrestore(&hw->lock, flags);\n\t\t\treturn;\n\t\t}\n\t\tmaxlen = bchannel_get_rxbuf(fifo->bch, len);\n\t\trx_skb = fifo->bch->rx_skb;\n\t\tif (maxlen < 0) {\n\t\t\tif (rx_skb)\n\t\t\t\tskb_trim(rx_skb, 0);\n\t\t\tpr_warn(\"%s.B%d: No bufferspace for %d bytes\\n\",\n\t\t\t\thw->name, fifo->bch->nr, len);\n\t\t\tspin_unlock_irqrestore(&hw->lock, flags);\n\t\t\treturn;\n\t\t}\n\t\tmaxlen = fifo->bch->maxlen;\n\t\thdlc = test_bit(FLG_HDLC, &fifo->bch->Flags);\n\t}\n\tif (fifo->ech) {\n\t\trx_skb = fifo->ech->rx_skb;\n\t\tmaxlen = fifo->ech->maxlen;\n\t\thdlc = 1;\n\t}\n\n\tif (fifo->dch || fifo->ech) {\n\t\tif (!rx_skb) {\n\t\t\trx_skb = mI_alloc_skb(maxlen, GFP_ATOMIC);\n\t\t\tif (rx_skb) {\n\t\t\t\tif (fifo->dch)\n\t\t\t\t\tfifo->dch->rx_skb = rx_skb;\n\t\t\t\tif (fifo->ech)\n\t\t\t\t\tfifo->ech->rx_skb = rx_skb;\n\t\t\t\tskb_trim(rx_skb, 0);\n\t\t\t} else {\n\t\t\t\tprintk(KERN_DEBUG \"%s: %s: No mem for rx_skb\\n\",\n\t\t\t\t       hw->name, __func__);\n\t\t\t\tspin_unlock_irqrestore(&hw->lock, flags);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t \n\t\tif ((rx_skb->len + len) >= MAX_DFRAME_LEN_L1) {\n\t\t\tprintk(KERN_DEBUG \"%s: %s: sbk mem exceeded \"\n\t\t\t       \"for fifo(%d) HFCUSB_D_RX\\n\",\n\t\t\t       hw->name, __func__, fifon);\n\t\t\tskb_trim(rx_skb, 0);\n\t\t\tspin_unlock_irqrestore(&hw->lock, flags);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tskb_put_data(rx_skb, data, len);\n\n\tif (hdlc) {\n\t\t \n\t\tif (finish) {\n\t\t\tif ((rx_skb->len > 3) &&\n\t\t\t    (!(rx_skb->data[rx_skb->len - 1]))) {\n\t\t\t\tif (debug & DBG_HFC_FIFO_VERBOSE) {\n\t\t\t\t\tprintk(KERN_DEBUG \"%s: %s: fifon(%i)\"\n\t\t\t\t\t       \" new RX len(%i): \",\n\t\t\t\t\t       hw->name, __func__, fifon,\n\t\t\t\t\t       rx_skb->len);\n\t\t\t\t\ti = 0;\n\t\t\t\t\twhile (i < rx_skb->len)\n\t\t\t\t\t\tprintk(\"%02x \",\n\t\t\t\t\t\t       rx_skb->data[i++]);\n\t\t\t\t\tprintk(\"\\n\");\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tskb_trim(rx_skb, rx_skb->len - 3);\n\n\t\t\t\tif (fifo->dch)\n\t\t\t\t\trecv_Dchannel(fifo->dch);\n\t\t\t\tif (fifo->bch)\n\t\t\t\t\trecv_Bchannel(fifo->bch, MISDN_ID_ANY,\n\t\t\t\t\t\t      0);\n\t\t\t\tif (fifo->ech)\n\t\t\t\t\trecv_Echannel(fifo->ech,\n\t\t\t\t\t\t      &hw->dch);\n\t\t\t} else {\n\t\t\t\tif (debug & DBG_HFC_FIFO_VERBOSE) {\n\t\t\t\t\tprintk(KERN_DEBUG\n\t\t\t\t\t       \"%s: CRC or minlen ERROR fifon(%i) \"\n\t\t\t\t\t       \"RX len(%i): \",\n\t\t\t\t\t       hw->name, fifon, rx_skb->len);\n\t\t\t\t\ti = 0;\n\t\t\t\t\twhile (i < rx_skb->len)\n\t\t\t\t\t\tprintk(\"%02x \",\n\t\t\t\t\t\t       rx_skb->data[i++]);\n\t\t\t\t\tprintk(\"\\n\");\n\t\t\t\t}\n\t\t\t\tskb_trim(rx_skb, 0);\n\t\t\t}\n\t\t}\n\t} else {\n\t\t \n\t\trecv_Bchannel(fifo->bch, MISDN_ID_ANY, false);\n\t}\n\tspin_unlock_irqrestore(&hw->lock, flags);\n}\n\nstatic void\nfill_isoc_urb(struct urb *urb, struct usb_device *dev, unsigned int pipe,\n\t      void *buf, int num_packets, int packet_size, int interval,\n\t      usb_complete_t complete, void *context)\n{\n\tint k;\n\n\tusb_fill_bulk_urb(urb, dev, pipe, buf, packet_size * num_packets,\n\t\t\t  complete, context);\n\n\turb->number_of_packets = num_packets;\n\turb->transfer_flags = URB_ISO_ASAP;\n\turb->actual_length = 0;\n\turb->interval = interval;\n\n\tfor (k = 0; k < num_packets; k++) {\n\t\turb->iso_frame_desc[k].offset = packet_size * k;\n\t\turb->iso_frame_desc[k].length = packet_size;\n\t\turb->iso_frame_desc[k].actual_length = 0;\n\t}\n}\n\n \nstatic void\nrx_iso_complete(struct urb *urb)\n{\n\tstruct iso_urb *context_iso_urb = (struct iso_urb *) urb->context;\n\tstruct usb_fifo *fifo = context_iso_urb->owner_fifo;\n\tstruct hfcsusb *hw = fifo->hw;\n\tint k, len, errcode, offset, num_isoc_packets, fifon, maxlen,\n\t\tstatus, iso_status, i;\n\t__u8 *buf;\n\tstatic __u8 eof[8];\n\t__u8 s0_state;\n\tunsigned long flags;\n\n\tfifon = fifo->fifonum;\n\tstatus = urb->status;\n\n\tspin_lock_irqsave(&hw->lock, flags);\n\tif (fifo->stop_gracefull) {\n\t\tfifo->stop_gracefull = 0;\n\t\tfifo->active = 0;\n\t\tspin_unlock_irqrestore(&hw->lock, flags);\n\t\treturn;\n\t}\n\tspin_unlock_irqrestore(&hw->lock, flags);\n\n\t \n\tif (status == -EXDEV) {\n\t\tif (debug & DEBUG_HW)\n\t\t\tprintk(KERN_DEBUG \"%s: %s: with -EXDEV \"\n\t\t\t       \"urb->status %d, fifonum %d\\n\",\n\t\t\t       hw->name, __func__,  status, fifon);\n\n\t\t \n\t\tstatus = 0;\n\t}\n\n\ts0_state = 0;\n\tif (fifo->active && !status) {\n\t\tnum_isoc_packets = iso_packets[fifon];\n\t\tmaxlen = fifo->usb_packet_maxlen;\n\n\t\tfor (k = 0; k < num_isoc_packets; ++k) {\n\t\t\tlen = urb->iso_frame_desc[k].actual_length;\n\t\t\toffset = urb->iso_frame_desc[k].offset;\n\t\t\tbuf = context_iso_urb->buffer + offset;\n\t\t\tiso_status = urb->iso_frame_desc[k].status;\n\n\t\t\tif (iso_status && (debug & DBG_HFC_FIFO_VERBOSE)) {\n\t\t\t\tprintk(KERN_DEBUG \"%s: %s: \"\n\t\t\t\t       \"ISO packet %i, status: %i\\n\",\n\t\t\t\t       hw->name, __func__, k, iso_status);\n\t\t\t}\n\n\t\t\t \n\t\t\tif ((fifon == HFCUSB_D_RX) &&\n\t\t\t    (debug & DBG_HFC_USB_VERBOSE)) {\n\t\t\t\tprintk(KERN_DEBUG\n\t\t\t\t       \"%s: %s: %d (%d/%d) len(%d) \",\n\t\t\t\t       hw->name, __func__, urb->start_frame,\n\t\t\t\t       k, num_isoc_packets - 1,\n\t\t\t\t       len);\n\t\t\t\tfor (i = 0; i < len; i++)\n\t\t\t\t\tprintk(\"%x \", buf[i]);\n\t\t\t\tprintk(\"\\n\");\n\t\t\t}\n\n\t\t\tif (!iso_status) {\n\t\t\t\tif (fifo->last_urblen != maxlen) {\n\t\t\t\t\t \n\t\t\t\t\thw->threshold_mask = buf[1];\n\n\t\t\t\t\tif (fifon == HFCUSB_D_RX)\n\t\t\t\t\t\ts0_state = (buf[0] >> 4);\n\n\t\t\t\t\teof[fifon] = buf[0] & 1;\n\t\t\t\t\tif (len > 2)\n\t\t\t\t\t\thfcsusb_rx_frame(fifo, buf + 2,\n\t\t\t\t\t\t\t\t len - 2, (len < maxlen)\n\t\t\t\t\t\t\t\t ? eof[fifon] : 0);\n\t\t\t\t} else\n\t\t\t\t\thfcsusb_rx_frame(fifo, buf, len,\n\t\t\t\t\t\t\t (len < maxlen) ?\n\t\t\t\t\t\t\t eof[fifon] : 0);\n\t\t\t\tfifo->last_urblen = len;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif ((s0_state) && (hw->initdone) &&\n\t\t    (s0_state != hw->dch.state)) {\n\t\t\thw->dch.state = s0_state;\n\t\t\tschedule_event(&hw->dch, FLG_PHCHANGE);\n\t\t}\n\n\t\tfill_isoc_urb(urb, fifo->hw->dev, fifo->pipe,\n\t\t\t      context_iso_urb->buffer, num_isoc_packets,\n\t\t\t      fifo->usb_packet_maxlen, fifo->intervall,\n\t\t\t      (usb_complete_t)rx_iso_complete, urb->context);\n\t\terrcode = usb_submit_urb(urb, GFP_ATOMIC);\n\t\tif (errcode < 0) {\n\t\t\tif (debug & DEBUG_HW)\n\t\t\t\tprintk(KERN_DEBUG \"%s: %s: error submitting \"\n\t\t\t\t       \"ISO URB: %d\\n\",\n\t\t\t\t       hw->name, __func__, errcode);\n\t\t}\n\t} else {\n\t\tif (status && (debug & DBG_HFC_URB_INFO))\n\t\t\tprintk(KERN_DEBUG \"%s: %s: rx_iso_complete : \"\n\t\t\t       \"urb->status %d, fifonum %d\\n\",\n\t\t\t       hw->name, __func__, status, fifon);\n\t}\n}\n\n \nstatic void\nrx_int_complete(struct urb *urb)\n{\n\tint len, status, i;\n\t__u8 *buf, maxlen, fifon;\n\tstruct usb_fifo *fifo = (struct usb_fifo *) urb->context;\n\tstruct hfcsusb *hw = fifo->hw;\n\tstatic __u8 eof[8];\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&hw->lock, flags);\n\tif (fifo->stop_gracefull) {\n\t\tfifo->stop_gracefull = 0;\n\t\tfifo->active = 0;\n\t\tspin_unlock_irqrestore(&hw->lock, flags);\n\t\treturn;\n\t}\n\tspin_unlock_irqrestore(&hw->lock, flags);\n\n\tfifon = fifo->fifonum;\n\tif ((!fifo->active) || (urb->status)) {\n\t\tif (debug & DBG_HFC_URB_ERROR)\n\t\t\tprintk(KERN_DEBUG\n\t\t\t       \"%s: %s: RX-Fifo %i is going down (%i)\\n\",\n\t\t\t       hw->name, __func__, fifon, urb->status);\n\n\t\tfifo->urb->interval = 0;  \n\t\treturn;\n\t}\n\tlen = urb->actual_length;\n\tbuf = fifo->buffer;\n\tmaxlen = fifo->usb_packet_maxlen;\n\n\t \n\tif ((fifon == HFCUSB_D_RX) && (debug & DBG_HFC_USB_VERBOSE)) {\n\t\tprintk(KERN_DEBUG \"%s: %s: D RX INT len(%d) \",\n\t\t       hw->name, __func__, len);\n\t\tfor (i = 0; i < len; i++)\n\t\t\tprintk(\"%02x \", buf[i]);\n\t\tprintk(\"\\n\");\n\t}\n\n\tif (fifo->last_urblen != fifo->usb_packet_maxlen) {\n\t\t \n\t\thw->threshold_mask = buf[1];\n\n\t\t \n\t\tif (hw->initdone && ((buf[0] >> 4) != hw->dch.state)) {\n\t\t\thw->dch.state = (buf[0] >> 4);\n\t\t\tschedule_event(&hw->dch, FLG_PHCHANGE);\n\t\t}\n\n\t\teof[fifon] = buf[0] & 1;\n\t\t \n\t\tif (len > 2)\n\t\t\thfcsusb_rx_frame(fifo, buf + 2,\n\t\t\t\t\t urb->actual_length - 2,\n\t\t\t\t\t (len < maxlen) ? eof[fifon] : 0);\n\t} else {\n\t\thfcsusb_rx_frame(fifo, buf, urb->actual_length,\n\t\t\t\t (len < maxlen) ? eof[fifon] : 0);\n\t}\n\tfifo->last_urblen = urb->actual_length;\n\n\tstatus = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (status) {\n\t\tif (debug & DEBUG_HW)\n\t\t\tprintk(KERN_DEBUG \"%s: %s: error resubmitting USB\\n\",\n\t\t\t       hw->name, __func__);\n\t}\n}\n\n \nstatic void\ntx_iso_complete(struct urb *urb)\n{\n\tstruct iso_urb *context_iso_urb = (struct iso_urb *) urb->context;\n\tstruct usb_fifo *fifo = context_iso_urb->owner_fifo;\n\tstruct hfcsusb *hw = fifo->hw;\n\tstruct sk_buff *tx_skb;\n\tint k, tx_offset, num_isoc_packets, sink, remain, current_len,\n\t\terrcode, hdlc, i;\n\tint *tx_idx;\n\tint frame_complete, fifon, status, fillempty = 0;\n\t__u8 threshbit, *p;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&hw->lock, flags);\n\tif (fifo->stop_gracefull) {\n\t\tfifo->stop_gracefull = 0;\n\t\tfifo->active = 0;\n\t\tspin_unlock_irqrestore(&hw->lock, flags);\n\t\treturn;\n\t}\n\n\tif (fifo->dch) {\n\t\ttx_skb = fifo->dch->tx_skb;\n\t\ttx_idx = &fifo->dch->tx_idx;\n\t\thdlc = 1;\n\t} else if (fifo->bch) {\n\t\ttx_skb = fifo->bch->tx_skb;\n\t\ttx_idx = &fifo->bch->tx_idx;\n\t\thdlc = test_bit(FLG_HDLC, &fifo->bch->Flags);\n\t\tif (!tx_skb && !hdlc &&\n\t\t    test_bit(FLG_FILLEMPTY, &fifo->bch->Flags))\n\t\t\tfillempty = 1;\n\t} else {\n\t\tprintk(KERN_DEBUG \"%s: %s: neither BCH nor DCH\\n\",\n\t\t       hw->name, __func__);\n\t\tspin_unlock_irqrestore(&hw->lock, flags);\n\t\treturn;\n\t}\n\n\tfifon = fifo->fifonum;\n\tstatus = urb->status;\n\n\ttx_offset = 0;\n\n\t \n\tif (status == -EXDEV) {\n\t\tif (debug & DBG_HFC_URB_ERROR)\n\t\t\tprintk(KERN_DEBUG \"%s: %s: \"\n\t\t\t       \"-EXDEV (%i) fifon (%d)\\n\",\n\t\t\t       hw->name, __func__, status, fifon);\n\n\t\t \n\t\tstatus = 0;\n\t}\n\n\tif (fifo->active && !status) {\n\t\t \n\t\tthreshbit = (hw->threshold_mask & (1 << fifon));\n\t\tnum_isoc_packets = iso_packets[fifon];\n\n\t\t \n\t\tif (fifon >= HFCUSB_D_TX)\n\t\t\tsink = (threshbit) ? SINK_DMIN : SINK_DMAX;\n\t\telse\n\t\t\tsink = (threshbit) ? SINK_MIN : SINK_MAX;\n\t\tfill_isoc_urb(urb, fifo->hw->dev, fifo->pipe,\n\t\t\t      context_iso_urb->buffer, num_isoc_packets,\n\t\t\t      fifo->usb_packet_maxlen, fifo->intervall,\n\t\t\t      (usb_complete_t)tx_iso_complete, urb->context);\n\t\tmemset(context_iso_urb->buffer, 0,\n\t\t       sizeof(context_iso_urb->buffer));\n\t\tframe_complete = 0;\n\n\t\tfor (k = 0; k < num_isoc_packets; ++k) {\n\t\t\t \n\t\t\tif (debug & DBG_HFC_URB_ERROR) {\n\t\t\t\terrcode = urb->iso_frame_desc[k].status;\n\t\t\t\tif (errcode) {\n\t\t\t\t\tprintk(KERN_DEBUG \"%s: %s: \"\n\t\t\t\t\t       \"ISO packet %i, status: %i\\n\",\n\t\t\t\t\t       hw->name, __func__, k, errcode);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t \n\t\t\tif (tx_skb)\n\t\t\t\tremain = tx_skb->len - *tx_idx;\n\t\t\telse if (fillempty)\n\t\t\t\tremain = 15;  \n\t\t\telse\n\t\t\t\tremain = 0;\n\n\t\t\tif (remain > 0) {\n\t\t\t\tfifo->bit_line -= sink;\n\t\t\t\tcurrent_len = (0 - fifo->bit_line) / 8;\n\t\t\t\tif (current_len > 14)\n\t\t\t\t\tcurrent_len = 14;\n\t\t\t\tif (current_len < 0)\n\t\t\t\t\tcurrent_len = 0;\n\t\t\t\tif (remain < current_len)\n\t\t\t\t\tcurrent_len = remain;\n\n\t\t\t\t \n\t\t\t\tfifo->bit_line += current_len * 8;\n\n\t\t\t\tcontext_iso_urb->buffer[tx_offset] = 0;\n\t\t\t\tif (current_len == remain) {\n\t\t\t\t\tif (hdlc) {\n\t\t\t\t\t\t \n\t\t\t\t\t\tcontext_iso_urb->\n\t\t\t\t\t\t\tbuffer[tx_offset] = 1;\n\t\t\t\t\t\t \n\t\t\t\t\t\tfifo->bit_line += 32;\n\t\t\t\t\t}\n\t\t\t\t\tframe_complete = 1;\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tp = context_iso_urb->buffer + tx_offset + 1;\n\t\t\t\tif (fillempty) {\n\t\t\t\t\tmemset(p, fifo->bch->fill[0],\n\t\t\t\t\t       current_len);\n\t\t\t\t} else {\n\t\t\t\t\tmemcpy(p, (tx_skb->data + *tx_idx),\n\t\t\t\t\t       current_len);\n\t\t\t\t\t*tx_idx += current_len;\n\t\t\t\t}\n\t\t\t\turb->iso_frame_desc[k].offset = tx_offset;\n\t\t\t\turb->iso_frame_desc[k].length = current_len + 1;\n\n\t\t\t\t \n\t\t\t\tif ((fifon == HFCUSB_D_RX) && !fillempty &&\n\t\t\t\t    (debug & DBG_HFC_USB_VERBOSE)) {\n\t\t\t\t\tprintk(KERN_DEBUG\n\t\t\t\t\t       \"%s: %s (%d/%d) offs(%d) len(%d) \",\n\t\t\t\t\t       hw->name, __func__,\n\t\t\t\t\t       k, num_isoc_packets - 1,\n\t\t\t\t\t       urb->iso_frame_desc[k].offset,\n\t\t\t\t\t       urb->iso_frame_desc[k].length);\n\n\t\t\t\t\tfor (i = urb->iso_frame_desc[k].offset;\n\t\t\t\t\t     i < (urb->iso_frame_desc[k].offset\n\t\t\t\t\t\t  + urb->iso_frame_desc[k].length);\n\t\t\t\t\t     i++)\n\t\t\t\t\t\tprintk(\"%x \",\n\t\t\t\t\t\t       context_iso_urb->buffer[i]);\n\n\t\t\t\t\tprintk(\" skb->len(%i) tx-idx(%d)\\n\",\n\t\t\t\t\t       tx_skb->len, *tx_idx);\n\t\t\t\t}\n\n\t\t\t\ttx_offset += (current_len + 1);\n\t\t\t} else {\n\t\t\t\turb->iso_frame_desc[k].offset = tx_offset++;\n\t\t\t\turb->iso_frame_desc[k].length = 1;\n\t\t\t\t \n\t\t\t\tfifo->bit_line -= sink;\n\t\t\t\tif (fifo->bit_line < BITLINE_INF)\n\t\t\t\t\tfifo->bit_line = BITLINE_INF;\n\t\t\t}\n\n\t\t\tif (frame_complete) {\n\t\t\t\tframe_complete = 0;\n\n\t\t\t\tif (debug & DBG_HFC_FIFO_VERBOSE) {\n\t\t\t\t\tprintk(KERN_DEBUG  \"%s: %s: \"\n\t\t\t\t\t       \"fifon(%i) new TX len(%i): \",\n\t\t\t\t\t       hw->name, __func__,\n\t\t\t\t\t       fifon, tx_skb->len);\n\t\t\t\t\ti = 0;\n\t\t\t\t\twhile (i < tx_skb->len)\n\t\t\t\t\t\tprintk(\"%02x \",\n\t\t\t\t\t\t       tx_skb->data[i++]);\n\t\t\t\t\tprintk(\"\\n\");\n\t\t\t\t}\n\n\t\t\t\tdev_consume_skb_irq(tx_skb);\n\t\t\t\ttx_skb = NULL;\n\t\t\t\tif (fifo->dch && get_next_dframe(fifo->dch))\n\t\t\t\t\ttx_skb = fifo->dch->tx_skb;\n\t\t\t\telse if (fifo->bch &&\n\t\t\t\t\t get_next_bframe(fifo->bch))\n\t\t\t\t\ttx_skb = fifo->bch->tx_skb;\n\t\t\t}\n\t\t}\n\t\terrcode = usb_submit_urb(urb, GFP_ATOMIC);\n\t\tif (errcode < 0) {\n\t\t\tif (debug & DEBUG_HW)\n\t\t\t\tprintk(KERN_DEBUG\n\t\t\t\t       \"%s: %s: error submitting ISO URB: %d \\n\",\n\t\t\t\t       hw->name, __func__, errcode);\n\t\t}\n\n\t\t \n\t\tif ((fifon == HFCUSB_D_TX) && (hw->protocol == ISDN_P_NT_S0)\n\t\t    && (hw->timers & NT_ACTIVATION_TIMER)) {\n\t\t\tif ((--hw->nt_timer) < 0)\n\t\t\t\tschedule_event(&hw->dch, FLG_PHCHANGE);\n\t\t}\n\n\t} else {\n\t\tif (status && (debug & DBG_HFC_URB_ERROR))\n\t\t\tprintk(KERN_DEBUG  \"%s: %s: urb->status %s (%i)\"\n\t\t\t       \"fifonum=%d\\n\",\n\t\t\t       hw->name, __func__,\n\t\t\t       symbolic(urb_errlist, status), status, fifon);\n\t}\n\tspin_unlock_irqrestore(&hw->lock, flags);\n}\n\n \nstatic int\nstart_isoc_chain(struct usb_fifo *fifo, int num_packets_per_urb,\n\t\t usb_complete_t complete, int packet_size)\n{\n\tstruct hfcsusb *hw = fifo->hw;\n\tint i, k, errcode;\n\n\tif (debug)\n\t\tprintk(KERN_DEBUG \"%s: %s: fifo %i\\n\",\n\t\t       hw->name, __func__, fifo->fifonum);\n\n\t \n\tfor (i = 0; i < 2; i++) {\n\t\tif (!(fifo->iso[i].urb)) {\n\t\t\tfifo->iso[i].urb =\n\t\t\t\tusb_alloc_urb(num_packets_per_urb, GFP_KERNEL);\n\t\t\tif (!(fifo->iso[i].urb)) {\n\t\t\t\tprintk(KERN_DEBUG\n\t\t\t\t       \"%s: %s: alloc urb for fifo %i failed\",\n\t\t\t\t       hw->name, __func__, fifo->fifonum);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfifo->iso[i].owner_fifo = (struct usb_fifo *) fifo;\n\t\t\tfifo->iso[i].indx = i;\n\n\t\t\t \n\t\t\tif (ISO_BUFFER_SIZE >=\n\t\t\t    (fifo->usb_packet_maxlen *\n\t\t\t     num_packets_per_urb)) {\n\t\t\t\tfill_isoc_urb(fifo->iso[i].urb,\n\t\t\t\t\t      fifo->hw->dev, fifo->pipe,\n\t\t\t\t\t      fifo->iso[i].buffer,\n\t\t\t\t\t      num_packets_per_urb,\n\t\t\t\t\t      fifo->usb_packet_maxlen,\n\t\t\t\t\t      fifo->intervall, complete,\n\t\t\t\t\t      &fifo->iso[i]);\n\t\t\t\tmemset(fifo->iso[i].buffer, 0,\n\t\t\t\t       sizeof(fifo->iso[i].buffer));\n\n\t\t\t\tfor (k = 0; k < num_packets_per_urb; k++) {\n\t\t\t\t\tfifo->iso[i].urb->\n\t\t\t\t\t\tiso_frame_desc[k].offset =\n\t\t\t\t\t\tk * packet_size;\n\t\t\t\t\tfifo->iso[i].urb->\n\t\t\t\t\t\tiso_frame_desc[k].length =\n\t\t\t\t\t\tpacket_size;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tprintk(KERN_DEBUG\n\t\t\t\t       \"%s: %s: ISO Buffer size to small!\\n\",\n\t\t\t\t       hw->name, __func__);\n\t\t\t}\n\t\t}\n\t\tfifo->bit_line = BITLINE_INF;\n\n\t\terrcode = usb_submit_urb(fifo->iso[i].urb, GFP_KERNEL);\n\t\tfifo->active = (errcode >= 0) ? 1 : 0;\n\t\tfifo->stop_gracefull = 0;\n\t\tif (errcode < 0) {\n\t\t\tprintk(KERN_DEBUG \"%s: %s: %s URB nr:%d\\n\",\n\t\t\t       hw->name, __func__,\n\t\t\t       symbolic(urb_errlist, errcode), i);\n\t\t}\n\t}\n\treturn fifo->active;\n}\n\nstatic void\nstop_iso_gracefull(struct usb_fifo *fifo)\n{\n\tstruct hfcsusb *hw = fifo->hw;\n\tint i, timeout;\n\tu_long flags;\n\n\tfor (i = 0; i < 2; i++) {\n\t\tspin_lock_irqsave(&hw->lock, flags);\n\t\tif (debug)\n\t\t\tprintk(KERN_DEBUG \"%s: %s for fifo %i.%i\\n\",\n\t\t\t       hw->name, __func__, fifo->fifonum, i);\n\t\tfifo->stop_gracefull = 1;\n\t\tspin_unlock_irqrestore(&hw->lock, flags);\n\t}\n\n\tfor (i = 0; i < 2; i++) {\n\t\ttimeout = 3;\n\t\twhile (fifo->stop_gracefull && timeout--)\n\t\t\tschedule_timeout_interruptible((HZ / 1000) * 16);\n\t\tif (debug && fifo->stop_gracefull)\n\t\t\tprintk(KERN_DEBUG \"%s: ERROR %s for fifo %i.%i\\n\",\n\t\t\t       hw->name, __func__, fifo->fifonum, i);\n\t}\n}\n\nstatic void\nstop_int_gracefull(struct usb_fifo *fifo)\n{\n\tstruct hfcsusb *hw = fifo->hw;\n\tint timeout;\n\tu_long flags;\n\n\tspin_lock_irqsave(&hw->lock, flags);\n\tif (debug)\n\t\tprintk(KERN_DEBUG \"%s: %s for fifo %i\\n\",\n\t\t       hw->name, __func__, fifo->fifonum);\n\tfifo->stop_gracefull = 1;\n\tspin_unlock_irqrestore(&hw->lock, flags);\n\n\ttimeout = 3;\n\twhile (fifo->stop_gracefull && timeout--)\n\t\tschedule_timeout_interruptible((HZ / 1000) * 3);\n\tif (debug && fifo->stop_gracefull)\n\t\tprintk(KERN_DEBUG \"%s: ERROR %s for fifo %i\\n\",\n\t\t       hw->name, __func__, fifo->fifonum);\n}\n\n \nstatic void\nstart_int_fifo(struct usb_fifo *fifo)\n{\n\tstruct hfcsusb *hw = fifo->hw;\n\tint errcode;\n\n\tif (debug)\n\t\tprintk(KERN_DEBUG \"%s: %s: INT IN fifo:%d\\n\",\n\t\t       hw->name, __func__, fifo->fifonum);\n\n\tif (!fifo->urb) {\n\t\tfifo->urb = usb_alloc_urb(0, GFP_KERNEL);\n\t\tif (!fifo->urb)\n\t\t\treturn;\n\t}\n\tusb_fill_int_urb(fifo->urb, fifo->hw->dev, fifo->pipe,\n\t\t\t fifo->buffer, fifo->usb_packet_maxlen,\n\t\t\t (usb_complete_t)rx_int_complete, fifo, fifo->intervall);\n\tfifo->active = 1;\n\tfifo->stop_gracefull = 0;\n\terrcode = usb_submit_urb(fifo->urb, GFP_KERNEL);\n\tif (errcode) {\n\t\tprintk(KERN_DEBUG \"%s: %s: submit URB: status:%i\\n\",\n\t\t       hw->name, __func__, errcode);\n\t\tfifo->active = 0;\n\t}\n}\n\nstatic void\nsetPortMode(struct hfcsusb *hw)\n{\n\tif (debug & DEBUG_HW)\n\t\tprintk(KERN_DEBUG \"%s: %s %s\\n\", hw->name, __func__,\n\t\t       (hw->protocol == ISDN_P_TE_S0) ? \"TE\" : \"NT\");\n\n\tif (hw->protocol == ISDN_P_TE_S0) {\n\t\twrite_reg(hw, HFCUSB_SCTRL, 0x40);\n\t\twrite_reg(hw, HFCUSB_SCTRL_E, 0x00);\n\t\twrite_reg(hw, HFCUSB_CLKDEL, CLKDEL_TE);\n\t\twrite_reg(hw, HFCUSB_STATES, 3 | 0x10);\n\t\twrite_reg(hw, HFCUSB_STATES, 3);\n\t} else {\n\t\twrite_reg(hw, HFCUSB_SCTRL, 0x44);\n\t\twrite_reg(hw, HFCUSB_SCTRL_E, 0x09);\n\t\twrite_reg(hw, HFCUSB_CLKDEL, CLKDEL_NT);\n\t\twrite_reg(hw, HFCUSB_STATES, 1 | 0x10);\n\t\twrite_reg(hw, HFCUSB_STATES, 1);\n\t}\n}\n\nstatic void\nreset_hfcsusb(struct hfcsusb *hw)\n{\n\tstruct usb_fifo *fifo;\n\tint i;\n\n\tif (debug & DEBUG_HW)\n\t\tprintk(KERN_DEBUG \"%s: %s\\n\", hw->name, __func__);\n\n\t \n\twrite_reg(hw, HFCUSB_CIRM, 8);\n\n\t \n\twrite_reg(hw, HFCUSB_CIRM, 0x10);\n\n\t \n\twrite_reg(hw, HFCUSB_USB_SIZE, (hw->packet_size / 8) |\n\t\t  ((hw->packet_size / 8) << 4));\n\n\t \n\twrite_reg(hw, HFCUSB_USB_SIZE_I, hw->iso_packet_size);\n\n\t \n\twrite_reg(hw, HFCUSB_MST_MODE1, 0);\t \n\twrite_reg(hw, HFCUSB_MST_MODE0, 1);\t \n\n\t \n\twrite_reg(hw, HFCUSB_F_THRES,\n\t\t  (HFCUSB_TX_THRESHOLD / 8) | ((HFCUSB_RX_THRESHOLD / 8) << 4));\n\n\tfifo = hw->fifos;\n\tfor (i = 0; i < HFCUSB_NUM_FIFOS; i++) {\n\t\twrite_reg(hw, HFCUSB_FIFO, i);\t \n\t\tfifo[i].max_size =\n\t\t\t(i <= HFCUSB_B2_RX) ? MAX_BCH_SIZE : MAX_DFRAME_LEN;\n\t\tfifo[i].last_urblen = 0;\n\n\t\t \n\t\twrite_reg(hw, HFCUSB_HDLC_PAR, ((i <= HFCUSB_B2_RX) ? 0 : 2));\n\n\t\t \n\t\tif (i == HFCUSB_D_TX)\n\t\t\twrite_reg(hw, HFCUSB_CON_HDLC,\n\t\t\t\t  (hw->protocol == ISDN_P_NT_S0) ? 0x08 : 0x09);\n\t\telse\n\t\t\twrite_reg(hw, HFCUSB_CON_HDLC, 0x08);\n\t\twrite_reg(hw, HFCUSB_INC_RES_F, 2);  \n\t}\n\n\twrite_reg(hw, HFCUSB_SCTRL_R, 0);  \n\thandle_led(hw, LED_POWER_ON);\n}\n\n \nstatic void\nhfcsusb_start_endpoint(struct hfcsusb *hw, int channel)\n{\n\t \n\tif ((channel == HFC_CHAN_D) && (hw->fifos[HFCUSB_D_RX].active))\n\t\treturn;\n\tif ((channel == HFC_CHAN_B1) && (hw->fifos[HFCUSB_B1_RX].active))\n\t\treturn;\n\tif ((channel == HFC_CHAN_B2) && (hw->fifos[HFCUSB_B2_RX].active))\n\t\treturn;\n\tif ((channel == HFC_CHAN_E) && (hw->fifos[HFCUSB_PCM_RX].active))\n\t\treturn;\n\n\t \n\tif (hw->cfg_used == CNF_3INT3ISO || hw->cfg_used == CNF_4INT3ISO)\n\t\tstart_int_fifo(hw->fifos + channel * 2 + 1);\n\n\t \n\tif (hw->cfg_used == CNF_3ISO3ISO || hw->cfg_used == CNF_4ISO3ISO) {\n\t\tswitch (channel) {\n\t\tcase HFC_CHAN_D:\n\t\t\tstart_isoc_chain(hw->fifos + HFCUSB_D_RX,\n\t\t\t\t\t ISOC_PACKETS_D,\n\t\t\t\t\t (usb_complete_t)rx_iso_complete,\n\t\t\t\t\t 16);\n\t\t\tbreak;\n\t\tcase HFC_CHAN_E:\n\t\t\tstart_isoc_chain(hw->fifos + HFCUSB_PCM_RX,\n\t\t\t\t\t ISOC_PACKETS_D,\n\t\t\t\t\t (usb_complete_t)rx_iso_complete,\n\t\t\t\t\t 16);\n\t\t\tbreak;\n\t\tcase HFC_CHAN_B1:\n\t\t\tstart_isoc_chain(hw->fifos + HFCUSB_B1_RX,\n\t\t\t\t\t ISOC_PACKETS_B,\n\t\t\t\t\t (usb_complete_t)rx_iso_complete,\n\t\t\t\t\t 16);\n\t\t\tbreak;\n\t\tcase HFC_CHAN_B2:\n\t\t\tstart_isoc_chain(hw->fifos + HFCUSB_B2_RX,\n\t\t\t\t\t ISOC_PACKETS_B,\n\t\t\t\t\t (usb_complete_t)rx_iso_complete,\n\t\t\t\t\t 16);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tswitch (channel) {\n\tcase HFC_CHAN_D:\n\t\tstart_isoc_chain(hw->fifos + HFCUSB_D_TX,\n\t\t\t\t ISOC_PACKETS_B,\n\t\t\t\t (usb_complete_t)tx_iso_complete, 1);\n\t\tbreak;\n\tcase HFC_CHAN_B1:\n\t\tstart_isoc_chain(hw->fifos + HFCUSB_B1_TX,\n\t\t\t\t ISOC_PACKETS_D,\n\t\t\t\t (usb_complete_t)tx_iso_complete, 1);\n\t\tbreak;\n\tcase HFC_CHAN_B2:\n\t\tstart_isoc_chain(hw->fifos + HFCUSB_B2_TX,\n\t\t\t\t ISOC_PACKETS_B,\n\t\t\t\t (usb_complete_t)tx_iso_complete, 1);\n\t\tbreak;\n\t}\n}\n\n \nstatic void\nhfcsusb_stop_endpoint(struct hfcsusb *hw, int channel)\n{\n\t \n\tif ((channel == HFC_CHAN_D) && (!hw->fifos[HFCUSB_D_RX].active))\n\t\treturn;\n\tif ((channel == HFC_CHAN_B1) && (!hw->fifos[HFCUSB_B1_RX].active))\n\t\treturn;\n\tif ((channel == HFC_CHAN_B2) && (!hw->fifos[HFCUSB_B2_RX].active))\n\t\treturn;\n\tif ((channel == HFC_CHAN_E) && (!hw->fifos[HFCUSB_PCM_RX].active))\n\t\treturn;\n\n\t \n\tif (hw->cfg_used == CNF_3INT3ISO || hw->cfg_used == CNF_4INT3ISO)\n\t\tstop_int_gracefull(hw->fifos + channel * 2 + 1);\n\n\t \n\tif (hw->cfg_used == CNF_3ISO3ISO || hw->cfg_used == CNF_4ISO3ISO)\n\t\tstop_iso_gracefull(hw->fifos + channel * 2 + 1);\n\n\t \n\tif (channel != HFC_CHAN_E)\n\t\tstop_iso_gracefull(hw->fifos + channel * 2);\n}\n\n\n \nstatic int\nsetup_hfcsusb(struct hfcsusb *hw)\n{\n\tvoid *dmabuf = kmalloc(sizeof(u_char), GFP_KERNEL);\n\tu_char b;\n\tint ret;\n\n\tif (debug & DBG_HFC_CALL_TRACE)\n\t\tprintk(KERN_DEBUG \"%s: %s\\n\", hw->name, __func__);\n\n\tif (!dmabuf)\n\t\treturn -ENOMEM;\n\n\tret = read_reg_atomic(hw, HFCUSB_CHIP_ID, dmabuf);\n\n\tmemcpy(&b, dmabuf, sizeof(u_char));\n\tkfree(dmabuf);\n\n\t \n\tif (ret != 1) {\n\t\tprintk(KERN_DEBUG \"%s: %s: cannot read chip id\\n\",\n\t\t       hw->name, __func__);\n\t\treturn 1;\n\t}\n\tif (b != HFCUSB_CHIPID) {\n\t\tprintk(KERN_DEBUG \"%s: %s: Invalid chip id 0x%02x\\n\",\n\t\t       hw->name, __func__, b);\n\t\treturn 1;\n\t}\n\n\t \n\t(void) usb_set_interface(hw->dev, hw->if_used, hw->alt_used);\n\n\thw->led_state = 0;\n\n\t \n\thw->ctrl_read.bRequestType = 0xc0;\n\thw->ctrl_read.bRequest = 1;\n\thw->ctrl_read.wLength = cpu_to_le16(1);\n\thw->ctrl_write.bRequestType = 0x40;\n\thw->ctrl_write.bRequest = 0;\n\thw->ctrl_write.wLength = 0;\n\tusb_fill_control_urb(hw->ctrl_urb, hw->dev, hw->ctrl_out_pipe,\n\t\t\t     (u_char *)&hw->ctrl_write, NULL, 0,\n\t\t\t     (usb_complete_t)ctrl_complete, hw);\n\n\treset_hfcsusb(hw);\n\treturn 0;\n}\n\nstatic void\nrelease_hw(struct hfcsusb *hw)\n{\n\tif (debug & DBG_HFC_CALL_TRACE)\n\t\tprintk(KERN_DEBUG \"%s: %s\\n\", hw->name, __func__);\n\n\t \n\thfcsusb_stop_endpoint(hw, HFC_CHAN_D);\n\thfcsusb_stop_endpoint(hw, HFC_CHAN_B1);\n\thfcsusb_stop_endpoint(hw, HFC_CHAN_B2);\n\tif (hw->fifos[HFCUSB_PCM_RX].pipe)\n\t\thfcsusb_stop_endpoint(hw, HFC_CHAN_E);\n\tif (hw->protocol == ISDN_P_TE_S0)\n\t\tl1_event(hw->dch.l1, CLOSE_CHANNEL);\n\n\tmISDN_unregister_device(&hw->dch.dev);\n\tmISDN_freebchannel(&hw->bch[1]);\n\tmISDN_freebchannel(&hw->bch[0]);\n\tmISDN_freedchannel(&hw->dch);\n\n\tif (hw->ctrl_urb) {\n\t\tusb_kill_urb(hw->ctrl_urb);\n\t\tusb_free_urb(hw->ctrl_urb);\n\t\thw->ctrl_urb = NULL;\n\t}\n\n\tif (hw->intf)\n\t\tusb_set_intfdata(hw->intf, NULL);\n\tlist_del(&hw->list);\n\tkfree(hw);\n\thw = NULL;\n}\n\nstatic void\ndeactivate_bchannel(struct bchannel *bch)\n{\n\tstruct hfcsusb *hw = bch->hw;\n\tu_long flags;\n\n\tif (bch->debug & DEBUG_HW)\n\t\tprintk(KERN_DEBUG \"%s: %s: bch->nr(%i)\\n\",\n\t\t       hw->name, __func__, bch->nr);\n\n\tspin_lock_irqsave(&hw->lock, flags);\n\tmISDN_clear_bchannel(bch);\n\tspin_unlock_irqrestore(&hw->lock, flags);\n\thfcsusb_setup_bch(bch, ISDN_P_NONE);\n\thfcsusb_stop_endpoint(hw, bch->nr - 1);\n}\n\n \nstatic int\nhfc_bctrl(struct mISDNchannel *ch, u_int cmd, void *arg)\n{\n\tstruct bchannel\t*bch = container_of(ch, struct bchannel, ch);\n\tint\t\tret = -EINVAL;\n\n\tif (bch->debug & DEBUG_HW)\n\t\tprintk(KERN_DEBUG \"%s: cmd:%x %p\\n\", __func__, cmd, arg);\n\n\tswitch (cmd) {\n\tcase HW_TESTRX_RAW:\n\tcase HW_TESTRX_HDLC:\n\tcase HW_TESTRX_OFF:\n\t\tret = -EINVAL;\n\t\tbreak;\n\n\tcase CLOSE_CHANNEL:\n\t\ttest_and_clear_bit(FLG_OPEN, &bch->Flags);\n\t\tdeactivate_bchannel(bch);\n\t\tch->protocol = ISDN_P_NONE;\n\t\tch->peer = NULL;\n\t\tmodule_put(THIS_MODULE);\n\t\tret = 0;\n\t\tbreak;\n\tcase CONTROL_CHANNEL:\n\t\tret = channel_bctrl(bch, arg);\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_WARNING \"%s: unknown prim(%x)\\n\",\n\t\t       __func__, cmd);\n\t}\n\treturn ret;\n}\n\nstatic int\nsetup_instance(struct hfcsusb *hw, struct device *parent)\n{\n\tu_long\tflags;\n\tint\terr, i;\n\n\tif (debug & DBG_HFC_CALL_TRACE)\n\t\tprintk(KERN_DEBUG \"%s: %s\\n\", hw->name, __func__);\n\n\tspin_lock_init(&hw->ctrl_lock);\n\tspin_lock_init(&hw->lock);\n\n\tmISDN_initdchannel(&hw->dch, MAX_DFRAME_LEN_L1, ph_state);\n\thw->dch.debug = debug & 0xFFFF;\n\thw->dch.hw = hw;\n\thw->dch.dev.Dprotocols = (1 << ISDN_P_TE_S0) | (1 << ISDN_P_NT_S0);\n\thw->dch.dev.D.send = hfcusb_l2l1D;\n\thw->dch.dev.D.ctrl = hfc_dctrl;\n\n\t \n\tif (hw->fifos[HFCUSB_PCM_RX].pipe)\n\t\tmISDN_initdchannel(&hw->ech, MAX_DFRAME_LEN_L1, NULL);\n\n\thw->dch.dev.Bprotocols = (1 << (ISDN_P_B_RAW & ISDN_P_B_MASK)) |\n\t\t(1 << (ISDN_P_B_HDLC & ISDN_P_B_MASK));\n\thw->dch.dev.nrbchan = 2;\n\tfor (i = 0; i < 2; i++) {\n\t\thw->bch[i].nr = i + 1;\n\t\tset_channelmap(i + 1, hw->dch.dev.channelmap);\n\t\thw->bch[i].debug = debug;\n\t\tmISDN_initbchannel(&hw->bch[i], MAX_DATA_MEM, poll >> 1);\n\t\thw->bch[i].hw = hw;\n\t\thw->bch[i].ch.send = hfcusb_l2l1B;\n\t\thw->bch[i].ch.ctrl = hfc_bctrl;\n\t\thw->bch[i].ch.nr = i + 1;\n\t\tlist_add(&hw->bch[i].ch.list, &hw->dch.dev.bchannels);\n\t}\n\n\thw->fifos[HFCUSB_B1_TX].bch = &hw->bch[0];\n\thw->fifos[HFCUSB_B1_RX].bch = &hw->bch[0];\n\thw->fifos[HFCUSB_B2_TX].bch = &hw->bch[1];\n\thw->fifos[HFCUSB_B2_RX].bch = &hw->bch[1];\n\thw->fifos[HFCUSB_D_TX].dch = &hw->dch;\n\thw->fifos[HFCUSB_D_RX].dch = &hw->dch;\n\thw->fifos[HFCUSB_PCM_RX].ech = &hw->ech;\n\thw->fifos[HFCUSB_PCM_TX].ech = &hw->ech;\n\n\terr = setup_hfcsusb(hw);\n\tif (err)\n\t\tgoto out;\n\n\tsnprintf(hw->name, MISDN_MAX_IDLEN - 1, \"%s.%d\", DRIVER_NAME,\n\t\t hfcsusb_cnt + 1);\n\tprintk(KERN_INFO \"%s: registered as '%s'\\n\",\n\t       DRIVER_NAME, hw->name);\n\n\terr = mISDN_register_device(&hw->dch.dev, parent, hw->name);\n\tif (err)\n\t\tgoto out;\n\n\thfcsusb_cnt++;\n\twrite_lock_irqsave(&HFClock, flags);\n\tlist_add_tail(&hw->list, &HFClist);\n\twrite_unlock_irqrestore(&HFClock, flags);\n\treturn 0;\n\nout:\n\tmISDN_freebchannel(&hw->bch[1]);\n\tmISDN_freebchannel(&hw->bch[0]);\n\tmISDN_freedchannel(&hw->dch);\n\tkfree(hw);\n\treturn err;\n}\n\nstatic int\nhfcsusb_probe(struct usb_interface *intf, const struct usb_device_id *id)\n{\n\tstruct hfcsusb\t\t\t*hw;\n\tstruct usb_device\t\t*dev = interface_to_usbdev(intf);\n\tstruct usb_host_interface\t*iface = intf->cur_altsetting;\n\tstruct usb_host_interface\t*iface_used = NULL;\n\tstruct usb_host_endpoint\t*ep;\n\tstruct hfcsusb_vdata\t\t*driver_info;\n\tint ifnum = iface->desc.bInterfaceNumber, i, idx, alt_idx,\n\t\tprobe_alt_setting, vend_idx, cfg_used, *vcf, attr, cfg_found,\n\t\tep_addr, cmptbl[16], small_match, iso_packet_size, packet_size,\n\t\talt_used = 0;\n\n\tvend_idx = 0xffff;\n\tfor (i = 0; hfcsusb_idtab[i].idVendor; i++) {\n\t\tif ((le16_to_cpu(dev->descriptor.idVendor)\n\t\t     == hfcsusb_idtab[i].idVendor) &&\n\t\t    (le16_to_cpu(dev->descriptor.idProduct)\n\t\t     == hfcsusb_idtab[i].idProduct)) {\n\t\t\tvend_idx = i;\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\tprintk(KERN_DEBUG\n\t       \"%s: interface(%d) actalt(%d) minor(%d) vend_idx(%d)\\n\",\n\t       __func__, ifnum, iface->desc.bAlternateSetting,\n\t       intf->minor, vend_idx);\n\n\tif (vend_idx == 0xffff) {\n\t\tprintk(KERN_WARNING\n\t\t       \"%s: no valid vendor found in USB descriptor\\n\",\n\t\t       __func__);\n\t\treturn -EIO;\n\t}\n\t \n\talt_idx = 0;\n\tsmall_match = -1;\n\n\t \n\tiso_packet_size = 16;\n\tpacket_size = 64;\n\n\twhile (alt_idx < intf->num_altsetting) {\n\t\tiface = intf->altsetting + alt_idx;\n\t\tprobe_alt_setting = iface->desc.bAlternateSetting;\n\t\tcfg_used = 0;\n\n\t\twhile (validconf[cfg_used][0]) {\n\t\t\tcfg_found = 1;\n\t\t\tvcf = validconf[cfg_used];\n\t\t\tep = iface->endpoint;\n\t\t\tmemcpy(cmptbl, vcf, 16 * sizeof(int));\n\n\t\t\t \n\t\t\tfor (i = 0; i < iface->desc.bNumEndpoints; i++) {\n\t\t\t\tep_addr = ep->desc.bEndpointAddress;\n\n\t\t\t\t \n\t\t\t\tidx = ((ep_addr & 0x7f) - 1) * 2;\n\t\t\t\tif (idx > 15)\n\t\t\t\t\treturn -EIO;\n\n\t\t\t\tif (ep_addr & 0x80)\n\t\t\t\t\tidx++;\n\t\t\t\tattr = ep->desc.bmAttributes;\n\n\t\t\t\tif (cmptbl[idx] != EP_NOP) {\n\t\t\t\t\tif (cmptbl[idx] == EP_NUL)\n\t\t\t\t\t\tcfg_found = 0;\n\t\t\t\t\tif (attr == USB_ENDPOINT_XFER_INT\n\t\t\t\t\t    && cmptbl[idx] == EP_INT)\n\t\t\t\t\t\tcmptbl[idx] = EP_NUL;\n\t\t\t\t\tif (attr == USB_ENDPOINT_XFER_BULK\n\t\t\t\t\t    && cmptbl[idx] == EP_BLK)\n\t\t\t\t\t\tcmptbl[idx] = EP_NUL;\n\t\t\t\t\tif (attr == USB_ENDPOINT_XFER_ISOC\n\t\t\t\t\t    && cmptbl[idx] == EP_ISO)\n\t\t\t\t\t\tcmptbl[idx] = EP_NUL;\n\n\t\t\t\t\tif (attr == USB_ENDPOINT_XFER_INT &&\n\t\t\t\t\t    ep->desc.bInterval < vcf[17]) {\n\t\t\t\t\t\tcfg_found = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tep++;\n\t\t\t}\n\n\t\t\tfor (i = 0; i < 16; i++)\n\t\t\t\tif (cmptbl[i] != EP_NOP && cmptbl[i] != EP_NUL)\n\t\t\t\t\tcfg_found = 0;\n\n\t\t\tif (cfg_found) {\n\t\t\t\tif (small_match < cfg_used) {\n\t\t\t\t\tsmall_match = cfg_used;\n\t\t\t\t\talt_used = probe_alt_setting;\n\t\t\t\t\tiface_used = iface;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcfg_used++;\n\t\t}\n\t\talt_idx++;\n\t}\t \n\n\t \n\tif (small_match == -1)\n\t\treturn -EIO;\n\n\tiface = iface_used;\n\thw = kzalloc(sizeof(struct hfcsusb), GFP_KERNEL);\n\tif (!hw)\n\t\treturn -ENOMEM;\t \n\tsnprintf(hw->name, MISDN_MAX_IDLEN - 1, \"%s\", DRIVER_NAME);\n\n\tep = iface->endpoint;\n\tvcf = validconf[small_match];\n\n\tfor (i = 0; i < iface->desc.bNumEndpoints; i++) {\n\t\tstruct usb_fifo *f;\n\n\t\tep_addr = ep->desc.bEndpointAddress;\n\t\t \n\t\tidx = ((ep_addr & 0x7f) - 1) * 2;\n\t\tif (ep_addr & 0x80)\n\t\t\tidx++;\n\t\tf = &hw->fifos[idx & 7];\n\n\t\t \n\t\tif (vcf[idx] == EP_NOP || vcf[idx] == EP_NUL) {\n\t\t\tep++;\n\t\t\tcontinue;\n\t\t}\n\t\tswitch (ep->desc.bmAttributes) {\n\t\tcase USB_ENDPOINT_XFER_INT:\n\t\t\tf->pipe = usb_rcvintpipe(dev,\n\t\t\t\t\t\t ep->desc.bEndpointAddress);\n\t\t\tf->usb_transfer_mode = USB_INT;\n\t\t\tpacket_size = le16_to_cpu(ep->desc.wMaxPacketSize);\n\t\t\tbreak;\n\t\tcase USB_ENDPOINT_XFER_BULK:\n\t\t\tif (ep_addr & 0x80)\n\t\t\t\tf->pipe = usb_rcvbulkpipe(dev,\n\t\t\t\t\t\t\t  ep->desc.bEndpointAddress);\n\t\t\telse\n\t\t\t\tf->pipe = usb_sndbulkpipe(dev,\n\t\t\t\t\t\t\t  ep->desc.bEndpointAddress);\n\t\t\tf->usb_transfer_mode = USB_BULK;\n\t\t\tpacket_size = le16_to_cpu(ep->desc.wMaxPacketSize);\n\t\t\tbreak;\n\t\tcase USB_ENDPOINT_XFER_ISOC:\n\t\t\tif (ep_addr & 0x80)\n\t\t\t\tf->pipe = usb_rcvisocpipe(dev,\n\t\t\t\t\t\t\t  ep->desc.bEndpointAddress);\n\t\t\telse\n\t\t\t\tf->pipe = usb_sndisocpipe(dev,\n\t\t\t\t\t\t\t  ep->desc.bEndpointAddress);\n\t\t\tf->usb_transfer_mode = USB_ISOC;\n\t\t\tiso_packet_size = le16_to_cpu(ep->desc.wMaxPacketSize);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tf->pipe = 0;\n\t\t}\n\n\t\tif (f->pipe) {\n\t\t\tf->fifonum = idx & 7;\n\t\t\tf->hw = hw;\n\t\t\tf->usb_packet_maxlen =\n\t\t\t\tle16_to_cpu(ep->desc.wMaxPacketSize);\n\t\t\tf->intervall = ep->desc.bInterval;\n\t\t}\n\t\tep++;\n\t}\n\thw->dev = dev;  \n\thw->if_used = ifnum;  \n\thw->alt_used = alt_used;  \n\thw->ctrl_paksize = dev->descriptor.bMaxPacketSize0;  \n\thw->cfg_used = vcf[16];\t \n\thw->vend_idx = vend_idx;  \n\thw->packet_size = packet_size;\n\thw->iso_packet_size = iso_packet_size;\n\n\t \n\thw->ctrl_in_pipe = usb_rcvctrlpipe(hw->dev, 0);\n\thw->ctrl_out_pipe = usb_sndctrlpipe(hw->dev, 0);\n\n\tdriver_info = (struct hfcsusb_vdata *)\n\t\t      hfcsusb_idtab[vend_idx].driver_info;\n\n\thw->ctrl_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!hw->ctrl_urb) {\n\t\tpr_warn(\"%s: No memory for control urb\\n\",\n\t\t\tdriver_info->vend_name);\n\t\tkfree(hw);\n\t\treturn -ENOMEM;\n\t}\n\n\tpr_info(\"%s: %s: detected \\\"%s\\\" (%s, if=%d alt=%d)\\n\",\n\t\thw->name, __func__, driver_info->vend_name,\n\t\tconf_str[small_match], ifnum, alt_used);\n\n\tif (setup_instance(hw, dev->dev.parent))\n\t\treturn -EIO;\n\n\thw->intf = intf;\n\tusb_set_intfdata(hw->intf, hw);\n\treturn 0;\n}\n\n \nstatic void\nhfcsusb_disconnect(struct usb_interface *intf)\n{\n\tstruct hfcsusb *hw = usb_get_intfdata(intf);\n\tstruct hfcsusb *next;\n\tint cnt = 0;\n\n\tprintk(KERN_INFO \"%s: device disconnected\\n\", hw->name);\n\n\thandle_led(hw, LED_POWER_OFF);\n\trelease_hw(hw);\n\n\tlist_for_each_entry_safe(hw, next, &HFClist, list)\n\t\tcnt++;\n\tif (!cnt)\n\t\thfcsusb_cnt = 0;\n\n\tusb_set_intfdata(intf, NULL);\n}\n\nstatic struct usb_driver hfcsusb_drv = {\n\t.name = DRIVER_NAME,\n\t.id_table = hfcsusb_idtab,\n\t.probe = hfcsusb_probe,\n\t.disconnect = hfcsusb_disconnect,\n\t.disable_hub_initiated_lpm = 1,\n};\n\nmodule_usb_driver(hfcsusb_drv);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}