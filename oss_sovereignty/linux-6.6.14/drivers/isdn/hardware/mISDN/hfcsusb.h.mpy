{
  "module_name": "hfcsusb.h",
  "hash_id": "7fe51fd32bf15a9feb6c3b113576233e3fa9d08b3b3538d12b18e6efedfb7b5a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/isdn/hardware/mISDN/hfcsusb.h",
  "human_readable_source": " \n \n\n#ifndef __HFCSUSB_H__\n#define __HFCSUSB_H__\n\n\n#define DRIVER_NAME \"HFC-S_USB\"\n\n#define DBG_HFC_CALL_TRACE\t0x00010000\n#define DBG_HFC_FIFO_VERBOSE\t0x00020000\n#define DBG_HFC_USB_VERBOSE\t0x00100000\n#define DBG_HFC_URB_INFO\t0x00200000\n#define DBG_HFC_URB_ERROR\t0x00400000\n\n#define DEFAULT_TRANSP_BURST_SZ 128\n\n#define HFC_CTRL_TIMEOUT\t20\t \n#define CLKDEL_TE\t\t0x0f\t \n#define CLKDEL_NT\t\t0x6c\t \n\n \n#define HFC_L1_ACTIVATE_TE\t\t1\n#define HFC_L1_ACTIVATE_NT\t\t2\n#define HFC_L1_DEACTIVATE_NT\t\t3\n#define HFC_L1_FORCE_DEACTIVATE_TE\t4\n\n \n#define HFCUSB_LOAD_STATE\t0x10\n#define HFCUSB_ACTIVATE\t\t0x20\n#define HFCUSB_DO_ACTION\t0x40\n#define HFCUSB_NT_G2_G3\t\t0x80\n\n \n#define NT_ACTIVATION_TIMER\t0x01\t \n#define NT_T1_COUNT\t\t10\n\n#define MAX_BCH_SIZE\t\t2048\t \n\n#define HFCUSB_RX_THRESHOLD\t64\t \n#define HFCUSB_TX_THRESHOLD\t96\t \n\n#define HFCUSB_CHIP_ID\t\t0x16\t \n#define HFCUSB_CIRM\t\t0x00\t \n#define HFCUSB_USB_SIZE\t\t0x07\t \n#define HFCUSB_USB_SIZE_I\t0x06\t \n#define HFCUSB_F_CROSS\t\t0x0b\t \n#define HFCUSB_CLKDEL\t\t0x37\t \n#define HFCUSB_CON_HDLC\t\t0xfa\t \n#define HFCUSB_HDLC_PAR\t\t0xfb\n#define HFCUSB_SCTRL\t\t0x31\t \n#define HFCUSB_SCTRL_E\t\t0x32\t \n#define HFCUSB_SCTRL_R\t\t0x33\t \n#define HFCUSB_F_THRES\t\t0x0c\t \n#define HFCUSB_FIFO\t\t0x0f\t \n#define HFCUSB_F_USAGE\t\t0x1a\t \n#define HFCUSB_MST_MODE0\t0x14\n#define HFCUSB_MST_MODE1\t0x15\n#define HFCUSB_P_DATA\t\t0x1f\n#define HFCUSB_INC_RES_F\t0x0e\n#define HFCUSB_B1_SSL\t\t0x20\n#define HFCUSB_B2_SSL\t\t0x21\n#define HFCUSB_B1_RSL\t\t0x24\n#define HFCUSB_B2_RSL\t\t0x25\n#define HFCUSB_STATES\t\t0x30\n\n\n#define HFCUSB_CHIPID\t\t0x40\t \n\n \n#define HFCUSB_NUM_FIFOS\t8\t \n#define HFCUSB_B1_TX\t\t0\t \n#define HFCUSB_B1_RX\t\t1\t \n#define HFCUSB_B2_TX\t\t2\n#define HFCUSB_B2_RX\t\t3\n#define HFCUSB_D_TX\t\t4\n#define HFCUSB_D_RX\t\t5\n#define HFCUSB_PCM_TX\t\t6\n#define HFCUSB_PCM_RX\t\t7\n\n\n#define USB_INT\t\t0\n#define USB_BULK\t1\n#define USB_ISOC\t2\n\n#define ISOC_PACKETS_D\t8\n#define ISOC_PACKETS_B\t8\n#define ISO_BUFFER_SIZE\t128\n\n \nstatic int iso_packets[8] =\n{ ISOC_PACKETS_B, ISOC_PACKETS_B, ISOC_PACKETS_B, ISOC_PACKETS_B,\n  ISOC_PACKETS_D, ISOC_PACKETS_D, ISOC_PACKETS_D, ISOC_PACKETS_D\n};\n\n\n \n#define SINK_MAX\t68\n#define SINK_MIN\t48\n#define SINK_DMIN\t12\n#define SINK_DMAX\t18\n#define BITLINE_INF\t(-96 * 8)\n\n \n#define write_reg_atomic(a, b, c)\t\t\t\t\t\\\n\tusb_control_msg((a)->dev, (a)->ctrl_out_pipe, 0, 0x40, (c), (b), \\\n\t\t\t0, 0, HFC_CTRL_TIMEOUT)\n#define read_reg_atomic(a, b, c)\t\t\t\t\t\\\n\tusb_control_msg((a)->dev, (a)->ctrl_in_pipe, 1, 0xC0, 0, (b), (c), \\\n\t\t\t1, HFC_CTRL_TIMEOUT)\n#define HFC_CTRL_BUFSIZE 64\n\nstruct ctrl_buf {\n\t__u8 hfcs_reg;\t\t \n\t__u8 reg_val;\t\t \n};\n\n \nstruct hfcusb_symbolic_list {\n\tconst int num;\n\tconst char *name;\n};\n\nstatic struct hfcusb_symbolic_list urb_errlist[] = {\n\t{-ENOMEM, \"No memory for allocation of internal structures\"},\n\t{-ENOSPC, \"The host controller's bandwidth is already consumed\"},\n\t{-ENOENT, \"URB was canceled by unlink_urb\"},\n\t{-EXDEV, \"ISO transfer only partially completed\"},\n\t{-EAGAIN, \"Too match scheduled for the future\"},\n\t{-ENXIO, \"URB already queued\"},\n\t{-EFBIG, \"Too much ISO frames requested\"},\n\t{-ENOSR, \"Buffer error (overrun)\"},\n\t{-EPIPE, \"Specified endpoint is stalled (device not responding)\"},\n\t{-EOVERFLOW, \"Babble (bad cable?)\"},\n\t{-EPROTO, \"Bit-stuff error (bad cable?)\"},\n\t{-EILSEQ, \"CRC/Timeout\"},\n\t{-ETIMEDOUT, \"NAK (device does not respond)\"},\n\t{-ESHUTDOWN, \"Device unplugged\"},\n\t{-1, NULL}\n};\n\nstatic inline const char *\nsymbolic(struct hfcusb_symbolic_list list[], const int num)\n{\n\tint i;\n\tfor (i = 0; list[i].name != NULL; i++)\n\t\tif (list[i].num == num)\n\t\t\treturn list[i].name;\n\treturn \"<unknown USB Error>\";\n}\n\n \n#define CNF_4INT3ISO\t1\t \n#define CNF_3INT3ISO\t2\t \n#define CNF_4ISO3ISO\t3\t \n#define CNF_3ISO3ISO\t4\t \n\n#define EP_NUL 1\t \n#define EP_NOP 2\t \n#define EP_ISO 3\t \n#define EP_BLK 4\t \n#define EP_INT 5\t \n\n#define HFC_CHAN_B1\t0\n#define HFC_CHAN_B2\t1\n#define HFC_CHAN_D\t2\n#define HFC_CHAN_E\t3\n\n\n \nstatic int\nvalidconf[][19] = {\n\t \n\t{EP_NUL, EP_INT, EP_NUL, EP_INT, EP_NUL, EP_INT, EP_NOP, EP_INT,\n\t EP_ISO, EP_NUL, EP_ISO, EP_NUL, EP_ISO, EP_NUL, EP_NUL, EP_NUL,\n\t CNF_4INT3ISO, 2, 1},\n\t{EP_NUL, EP_INT, EP_NUL, EP_INT, EP_NUL, EP_INT, EP_NUL, EP_NUL,\n\t EP_ISO, EP_NUL, EP_ISO, EP_NUL, EP_ISO, EP_NUL, EP_NUL, EP_NUL,\n\t CNF_3INT3ISO, 2, 0},\n\t \n\t{EP_NOP, EP_NOP, EP_NOP, EP_NOP, EP_NOP, EP_NOP, EP_NOP, EP_NOP,\n\t EP_ISO, EP_ISO, EP_ISO, EP_ISO, EP_ISO, EP_ISO, EP_NOP, EP_ISO,\n\t CNF_4ISO3ISO, 2, 1},\n\t{EP_NUL, EP_NUL, EP_NUL, EP_NUL, EP_NUL, EP_NUL, EP_NUL, EP_NUL,\n\t EP_ISO, EP_ISO, EP_ISO, EP_ISO, EP_ISO, EP_ISO, EP_NUL, EP_NUL,\n\t CNF_3ISO3ISO, 2, 0},\n\t{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}  \n};\n\n \nstatic char *conf_str[] = {\n\t\"4 Interrupt IN + 3 Isochron OUT\",\n\t\"3 Interrupt IN + 3 Isochron OUT\",\n\t\"4 Isochron IN + 3 Isochron OUT\",\n\t\"3 Isochron IN + 3 Isochron OUT\"\n};\n\n\n#define LED_OFF\t\t0\t \n#define LED_SCHEME1\t1\t \n#define LED_SCHEME2\t2\t \n\n#define LED_POWER_ON\t1\n#define LED_POWER_OFF\t2\n#define LED_S0_ON\t3\n#define LED_S0_OFF\t4\n#define LED_B1_ON\t5\n#define LED_B1_OFF\t6\n#define LED_B1_DATA\t7\n#define LED_B2_ON\t8\n#define LED_B2_OFF\t9\n#define LED_B2_DATA\t10\n\n#define LED_NORMAL\t0\t \n#define LED_INVERTED\t1\t \n\n \n#define LED_TIME      250\n\n\n\nstruct hfcsusb;\nstruct usb_fifo;\n\n \nstruct iso_urb {\n\tstruct urb *urb;\n\t__u8 buffer[ISO_BUFFER_SIZE];\t \n\tstruct usb_fifo *owner_fifo;\t \n\t__u8 indx;  \n#ifdef ISO_FRAME_START_DEBUG\n\tint start_frames[ISO_FRAME_START_RING_COUNT];\n\t__u8 iso_frm_strt_pos;  \n#endif\n};\n\nstruct usb_fifo {\n\tint fifonum;\t\t \n\tint active;\t\t \n\tstruct hfcsusb *hw;\t \n\tint pipe;\t\t \n\t__u8 usb_packet_maxlen;\t \n\tunsigned int max_size;\t \n\t__u8 intervall;\t\t \n\tstruct urb *urb;\t \n\t__u8 buffer[128];\t \n\tint bit_line;\t\t \n\n\t__u8 usb_transfer_mode;  \n\tstruct iso_urb\tiso[2];  \n\n\tstruct dchannel *dch;\t \n\tstruct bchannel *bch;\t \n\tstruct dchannel *ech;\t \n\tint last_urblen;\t \n\t__u8 stop_gracefull;\t \n};\n\nstruct hfcsusb {\n\tstruct list_head\tlist;\n\tstruct dchannel\t\tdch;\n\tstruct bchannel\t\tbch[2];\n\tstruct dchannel\t\tech;  \n\n\tstruct usb_device\t*dev;\t\t \n\tstruct usb_interface\t*intf;\t\t \n\tint\t\t\tif_used;\t \n\tint\t\t\talt_used;\t \n\tint\t\t\tcfg_used;\t \n\tint\t\t\tvend_idx;\t \n\tint\t\t\tpacket_size;\n\tint\t\t\tiso_packet_size;\n\tstruct usb_fifo\t\tfifos[HFCUSB_NUM_FIFOS];\n\n\t \n\tstruct ctrl_buf\t\tctrl_buff[HFC_CTRL_BUFSIZE];\n\tint\t\t\tctrl_in_idx, ctrl_out_idx, ctrl_cnt;\n\tstruct urb\t\t*ctrl_urb;\n\tstruct usb_ctrlrequest\tctrl_write;\n\tstruct usb_ctrlrequest\tctrl_read;\n\tint\t\t\tctrl_paksize;\n\tint\t\t\tctrl_in_pipe, ctrl_out_pipe;\n\tspinlock_t\t\tctrl_lock;  \n\tspinlock_t              lock;\n\n\t__u8\t\t\tthreshold_mask;\n\t__u8\t\t\tled_state;\n\n\t__u8\t\t\tprotocol;\n\tint\t\t\tnt_timer;\n\tint\t\t\topen;\n\t__u8\t\t\ttimers;\n\t__u8\t\t\tinitdone;\n\tchar\t\t\tname[MISDN_MAX_IDLEN];\n};\n\n \nstruct hfcsusb_vdata {\n\t__u8\t\tled_scheme;   \n\tsigned short\tled_bits[8];  \n\tchar\t\t*vend_name;   \n};\n\n\n#define HFC_MAX_TE_LAYER1_STATE 8\n#define HFC_MAX_NT_LAYER1_STATE 4\n\nstatic const char *HFC_TE_LAYER1_STATES[HFC_MAX_TE_LAYER1_STATE + 1] = {\n\t\"TE F0 - Reset\",\n\t\"TE F1 - Reset\",\n\t\"TE F2 - Sensing\",\n\t\"TE F3 - Deactivated\",\n\t\"TE F4 - Awaiting signal\",\n\t\"TE F5 - Identifying input\",\n\t\"TE F6 - Synchronized\",\n\t\"TE F7 - Activated\",\n\t\"TE F8 - Lost framing\",\n};\n\nstatic const char *HFC_NT_LAYER1_STATES[HFC_MAX_NT_LAYER1_STATE + 1] = {\n\t\"NT G0 - Reset\",\n\t\"NT G1 - Deactive\",\n\t\"NT G2 - Pending activation\",\n\t\"NT G3 - Active\",\n\t\"NT G4 - Pending deactivation\",\n};\n\n \nstatic const struct usb_device_id hfcsusb_idtab[] = {\n\t{\n\t\tUSB_DEVICE(0x0959, 0x2bd0),\n\t\t.driver_info = (unsigned long) &((struct hfcsusb_vdata)\n\t\t\t{LED_OFF, {4, 0, 2, 1},\n\t\t\t\t\t\"ISDN USB TA (Cologne Chip HFC-S USB based)\"}),\n\t},\n\t{\n\t\tUSB_DEVICE(0x0675, 0x1688),\n\t\t.driver_info = (unsigned long) &((struct hfcsusb_vdata)\n\t\t\t{LED_SCHEME1, {1, 2, 0, 0},\n\t\t\t\t\t\"DrayTek miniVigor 128 USB ISDN TA\"}),\n\t},\n\t{\n\t\tUSB_DEVICE(0x07b0, 0x0007),\n\t\t.driver_info = (unsigned long) &((struct hfcsusb_vdata)\n\t\t\t{LED_SCHEME1, {0x80, -64, -32, -16},\n\t\t\t\t\t\"Billion tiny USB ISDN TA 128\"}),\n\t},\n\t{\n\t\tUSB_DEVICE(0x0742, 0x2008),\n\t\t.driver_info = (unsigned long) &((struct hfcsusb_vdata)\n\t\t\t{LED_SCHEME1, {4, 0, 2, 1},\n\t\t\t\t\t\"Stollmann USB TA\"}),\n\t},\n\t{\n\t\tUSB_DEVICE(0x0742, 0x2009),\n\t\t.driver_info = (unsigned long) &((struct hfcsusb_vdata)\n\t\t\t{LED_SCHEME1, {4, 0, 2, 1},\n\t\t\t\t\t\"Aceex USB ISDN TA\"}),\n\t},\n\t{\n\t\tUSB_DEVICE(0x0742, 0x200A),\n\t\t.driver_info = (unsigned long) &((struct hfcsusb_vdata)\n\t\t\t{LED_SCHEME1, {4, 0, 2, 1},\n\t\t\t\t\t\"OEM USB ISDN TA\"}),\n\t},\n\t{\n\t\tUSB_DEVICE(0x08e3, 0x0301),\n\t\t.driver_info = (unsigned long) &((struct hfcsusb_vdata)\n\t\t\t{LED_SCHEME1, {2, 0, 1, 4},\n\t\t\t\t\t\"Olitec USB RNIS\"}),\n\t},\n\t{\n\t\tUSB_DEVICE(0x07fa, 0x0846),\n\t\t.driver_info = (unsigned long) &((struct hfcsusb_vdata)\n\t\t\t{LED_SCHEME1, {0x80, -64, -32, -16},\n\t\t\t\t\t\"Bewan Modem RNIS USB\"}),\n\t},\n\t{\n\t\tUSB_DEVICE(0x07fa, 0x0847),\n\t\t.driver_info = (unsigned long) &((struct hfcsusb_vdata)\n\t\t\t{LED_SCHEME1, {0x80, -64, -32, -16},\n\t\t\t\t\t\"Djinn Numeris USB\"}),\n\t},\n\t{\n\t\tUSB_DEVICE(0x07b0, 0x0006),\n\t\t.driver_info = (unsigned long) &((struct hfcsusb_vdata)\n\t\t\t{LED_SCHEME1, {0x80, -64, -32, -16},\n\t\t\t\t\t\"Twister ISDN TA\"}),\n\t},\n\t{\n\t\tUSB_DEVICE(0x071d, 0x1005),\n\t\t.driver_info = (unsigned long) &((struct hfcsusb_vdata)\n\t\t\t{LED_SCHEME1, {0x02, 0, 0x01, 0x04},\n\t\t\t\t\t\"Eicon DIVA USB 4.0\"}),\n\t},\n\t{\n\t\tUSB_DEVICE(0x0586, 0x0102),\n\t\t.driver_info = (unsigned long) &((struct hfcsusb_vdata)\n\t\t\t{LED_SCHEME1, {0x88, -64, -32, -16},\n\t\t\t\t\t\"ZyXEL OMNI.NET USB II\"}),\n\t},\n\t{\n\t\tUSB_DEVICE(0x1ae7, 0x0525),\n\t\t.driver_info = (unsigned long) &((struct hfcsusb_vdata)\n\t\t\t{LED_SCHEME1, {0x88, -64, -32, -16},\n\t\t\t\t\t\"X-Tensions USB ISDN TA XC-525\"}),\n\t},\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(usb, hfcsusb_idtab);\n\n#endif\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}