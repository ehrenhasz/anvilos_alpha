{
  "module_name": "avmfritz.c",
  "hash_id": "ab24086446b25b0c893cfd4e1ef32a8481735066228f224bc9c8bebf5268db8a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/isdn/hardware/mISDN/avmfritz.c",
  "human_readable_source": "\n \n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/delay.h>\n#include <linux/mISDNhw.h>\n#include <linux/slab.h>\n#include <asm/unaligned.h>\n#include \"ipac.h\"\n\n\n#define AVMFRITZ_REV\t\"2.3\"\n\nstatic int AVM_cnt;\nstatic int debug;\n\nenum {\n\tAVM_FRITZ_PCI,\n\tAVM_FRITZ_PCIV2,\n};\n\n#define HDLC_FIFO\t\t0x0\n#define HDLC_STATUS\t\t0x4\n#define CHIP_WINDOW\t\t0x10\n\n#define CHIP_INDEX\t\t0x4\n#define AVM_HDLC_1\t\t0x00\n#define AVM_HDLC_2\t\t0x01\n#define AVM_ISAC_FIFO\t\t0x02\n#define AVM_ISAC_REG_LOW\t0x04\n#define AVM_ISAC_REG_HIGH\t0x06\n\n#define AVM_STATUS0_IRQ_ISAC\t0x01\n#define AVM_STATUS0_IRQ_HDLC\t0x02\n#define AVM_STATUS0_IRQ_TIMER\t0x04\n#define AVM_STATUS0_IRQ_MASK\t0x07\n\n#define AVM_STATUS0_RESET\t0x01\n#define AVM_STATUS0_DIS_TIMER\t0x02\n#define AVM_STATUS0_RES_TIMER\t0x04\n#define AVM_STATUS0_ENA_IRQ\t0x08\n#define AVM_STATUS0_TESTBIT\t0x10\n\n#define AVM_STATUS1_INT_SEL\t0x0f\n#define AVM_STATUS1_ENA_IOM\t0x80\n\n#define HDLC_MODE_ITF_FLG\t0x01\n#define HDLC_MODE_TRANS\t\t0x02\n#define HDLC_MODE_CCR_7\t\t0x04\n#define HDLC_MODE_CCR_16\t0x08\n#define HDLC_FIFO_SIZE_128\t0x20\n#define HDLC_MODE_TESTLOOP\t0x80\n\n#define HDLC_INT_XPR\t\t0x80\n#define HDLC_INT_XDU\t\t0x40\n#define HDLC_INT_RPR\t\t0x20\n#define HDLC_INT_MASK\t\t0xE0\n\n#define HDLC_STAT_RME\t\t0x01\n#define HDLC_STAT_RDO\t\t0x10\n#define HDLC_STAT_CRCVFRRAB\t0x0E\n#define HDLC_STAT_CRCVFR\t0x06\n#define HDLC_STAT_RML_MASK_V1\t0x3f00\n#define HDLC_STAT_RML_MASK_V2\t0x7f00\n\n#define HDLC_CMD_XRS\t\t0x80\n#define HDLC_CMD_XME\t\t0x01\n#define HDLC_CMD_RRS\t\t0x20\n#define HDLC_CMD_XML_MASK\t0x3f00\n\n#define HDLC_FIFO_SIZE_V1\t32\n#define HDLC_FIFO_SIZE_V2\t128\n\n \n\n#define AVM_HDLC_FIFO_1\t\t0x10\n#define AVM_HDLC_FIFO_2\t\t0x18\n\n#define AVM_HDLC_STATUS_1\t0x14\n#define AVM_HDLC_STATUS_2\t0x1c\n\n#define AVM_ISACX_INDEX\t\t0x04\n#define AVM_ISACX_DATA\t\t0x08\n\n \n#define LOG_SIZE\t\t63\n\nstruct hdlc_stat_reg {\n#ifdef __BIG_ENDIAN\n\tu8 fill;\n\tu8 mode;\n\tu8 xml;\n\tu8 cmd;\n#else\n\tu8 cmd;\n\tu8 xml;\n\tu8 mode;\n\tu8 fill;\n#endif\n} __attribute__((packed));\n\nstruct hdlc_hw {\n\tunion {\n\t\tu32 ctrl;\n\t\tstruct hdlc_stat_reg sr;\n\t} ctrl;\n\tu32 stat;\n};\n\nstruct fritzcard {\n\tstruct list_head\tlist;\n\tstruct pci_dev\t\t*pdev;\n\tchar\t\t\tname[MISDN_MAX_IDLEN];\n\tu8\t\t\ttype;\n\tu8\t\t\tctrlreg;\n\tu16\t\t\tirq;\n\tu32\t\t\tirqcnt;\n\tu32\t\t\taddr;\n\tspinlock_t\t\tlock;  \n\tstruct isac_hw\t\tisac;\n\tstruct hdlc_hw\t\thdlc[2];\n\tstruct bchannel\t\tbch[2];\n\tchar\t\t\tlog[LOG_SIZE + 1];\n};\n\nstatic LIST_HEAD(Cards);\nstatic DEFINE_RWLOCK(card_lock);  \n\nstatic void\n_set_debug(struct fritzcard *card)\n{\n\tcard->isac.dch.debug = debug;\n\tcard->bch[0].debug = debug;\n\tcard->bch[1].debug = debug;\n}\n\nstatic int\nset_debug(const char *val, const struct kernel_param *kp)\n{\n\tint ret;\n\tstruct fritzcard *card;\n\n\tret = param_set_uint(val, kp);\n\tif (!ret) {\n\t\tread_lock(&card_lock);\n\t\tlist_for_each_entry(card, &Cards, list)\n\t\t\t_set_debug(card);\n\t\tread_unlock(&card_lock);\n\t}\n\treturn ret;\n}\n\nMODULE_AUTHOR(\"Karsten Keil\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_VERSION(AVMFRITZ_REV);\nmodule_param_call(debug, set_debug, param_get_uint, &debug, S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(debug, \"avmfritz debug mask\");\n\n \n\nstatic u8\nReadISAC_V1(void *p, u8 offset)\n{\n\tstruct fritzcard *fc = p;\n\tu8 idx = (offset > 0x2f) ? AVM_ISAC_REG_HIGH : AVM_ISAC_REG_LOW;\n\n\toutb(idx, fc->addr + CHIP_INDEX);\n\treturn inb(fc->addr + CHIP_WINDOW + (offset & 0xf));\n}\n\nstatic void\nWriteISAC_V1(void *p, u8 offset, u8 value)\n{\n\tstruct fritzcard *fc = p;\n\tu8 idx = (offset > 0x2f) ? AVM_ISAC_REG_HIGH : AVM_ISAC_REG_LOW;\n\n\toutb(idx, fc->addr + CHIP_INDEX);\n\toutb(value, fc->addr + CHIP_WINDOW + (offset & 0xf));\n}\n\nstatic void\nReadFiFoISAC_V1(void *p, u8 off, u8 *data, int size)\n{\n\tstruct fritzcard *fc = p;\n\n\toutb(AVM_ISAC_FIFO, fc->addr + CHIP_INDEX);\n\tinsb(fc->addr + CHIP_WINDOW, data, size);\n}\n\nstatic void\nWriteFiFoISAC_V1(void *p, u8 off, u8 *data, int size)\n{\n\tstruct fritzcard *fc = p;\n\n\toutb(AVM_ISAC_FIFO, fc->addr + CHIP_INDEX);\n\toutsb(fc->addr + CHIP_WINDOW, data, size);\n}\n\nstatic u8\nReadISAC_V2(void *p, u8 offset)\n{\n\tstruct fritzcard *fc = p;\n\n\toutl(offset, fc->addr + AVM_ISACX_INDEX);\n\treturn 0xff & inl(fc->addr + AVM_ISACX_DATA);\n}\n\nstatic void\nWriteISAC_V2(void *p, u8 offset, u8 value)\n{\n\tstruct fritzcard *fc = p;\n\n\toutl(offset, fc->addr + AVM_ISACX_INDEX);\n\toutl(value, fc->addr + AVM_ISACX_DATA);\n}\n\nstatic void\nReadFiFoISAC_V2(void *p, u8 off, u8 *data, int size)\n{\n\tstruct fritzcard *fc = p;\n\tint i;\n\n\toutl(off, fc->addr + AVM_ISACX_INDEX);\n\tfor (i = 0; i < size; i++)\n\t\tdata[i] = 0xff & inl(fc->addr + AVM_ISACX_DATA);\n}\n\nstatic void\nWriteFiFoISAC_V2(void *p, u8 off, u8 *data, int size)\n{\n\tstruct fritzcard *fc = p;\n\tint i;\n\n\toutl(off, fc->addr + AVM_ISACX_INDEX);\n\tfor (i = 0; i < size; i++)\n\t\toutl(data[i], fc->addr + AVM_ISACX_DATA);\n}\n\nstatic struct bchannel *\nSel_BCS(struct fritzcard *fc, u32 channel)\n{\n\tif (test_bit(FLG_ACTIVE, &fc->bch[0].Flags) &&\n\t    (fc->bch[0].nr & channel))\n\t\treturn &fc->bch[0];\n\telse if (test_bit(FLG_ACTIVE, &fc->bch[1].Flags) &&\n\t\t (fc->bch[1].nr & channel))\n\t\treturn &fc->bch[1];\n\telse\n\t\treturn NULL;\n}\n\nstatic inline void\n__write_ctrl_pci(struct fritzcard *fc, struct hdlc_hw *hdlc, u32 channel) {\n\tu32 idx = channel == 2 ? AVM_HDLC_2 : AVM_HDLC_1;\n\n\toutl(idx, fc->addr + CHIP_INDEX);\n\toutl(hdlc->ctrl.ctrl, fc->addr + CHIP_WINDOW + HDLC_STATUS);\n}\n\nstatic inline void\n__write_ctrl_pciv2(struct fritzcard *fc, struct hdlc_hw *hdlc, u32 channel) {\n\toutl(hdlc->ctrl.ctrl, fc->addr + (channel == 2 ? AVM_HDLC_STATUS_2 :\n\t\t\t\t\t  AVM_HDLC_STATUS_1));\n}\n\nstatic void\nwrite_ctrl(struct bchannel *bch, int which) {\n\tstruct fritzcard *fc = bch->hw;\n\tstruct hdlc_hw *hdlc;\n\n\thdlc = &fc->hdlc[(bch->nr - 1) & 1];\n\tpr_debug(\"%s: hdlc %c wr%x ctrl %x\\n\", fc->name, '@' + bch->nr,\n\t\t which, hdlc->ctrl.ctrl);\n\tswitch (fc->type) {\n\tcase AVM_FRITZ_PCIV2:\n\t\t__write_ctrl_pciv2(fc, hdlc, bch->nr);\n\t\tbreak;\n\tcase AVM_FRITZ_PCI:\n\t\t__write_ctrl_pci(fc, hdlc, bch->nr);\n\t\tbreak;\n\t}\n}\n\n\nstatic inline u32\n__read_status_pci(u_long addr, u32 channel)\n{\n\toutl(channel == 2 ? AVM_HDLC_2 : AVM_HDLC_1, addr + CHIP_INDEX);\n\treturn inl(addr + CHIP_WINDOW + HDLC_STATUS);\n}\n\nstatic inline u32\n__read_status_pciv2(u_long addr, u32 channel)\n{\n\treturn inl(addr + (channel == 2 ? AVM_HDLC_STATUS_2 :\n\t\t\t   AVM_HDLC_STATUS_1));\n}\n\n\nstatic u32\nread_status(struct fritzcard *fc, u32 channel)\n{\n\tswitch (fc->type) {\n\tcase AVM_FRITZ_PCIV2:\n\t\treturn __read_status_pciv2(fc->addr, channel);\n\tcase AVM_FRITZ_PCI:\n\t\treturn __read_status_pci(fc->addr, channel);\n\t}\n\t \n\treturn 0;\n}\n\nstatic void\nenable_hwirq(struct fritzcard *fc)\n{\n\tfc->ctrlreg |= AVM_STATUS0_ENA_IRQ;\n\toutb(fc->ctrlreg, fc->addr + 2);\n}\n\nstatic void\ndisable_hwirq(struct fritzcard *fc)\n{\n\tfc->ctrlreg &= ~AVM_STATUS0_ENA_IRQ;\n\toutb(fc->ctrlreg, fc->addr + 2);\n}\n\nstatic int\nmodehdlc(struct bchannel *bch, int protocol)\n{\n\tstruct fritzcard *fc = bch->hw;\n\tstruct hdlc_hw *hdlc;\n\tu8 mode;\n\n\thdlc = &fc->hdlc[(bch->nr - 1) & 1];\n\tpr_debug(\"%s: hdlc %c protocol %x-->%x ch %d\\n\", fc->name,\n\t\t '@' + bch->nr, bch->state, protocol, bch->nr);\n\thdlc->ctrl.ctrl = 0;\n\tmode = (fc->type == AVM_FRITZ_PCIV2) ? HDLC_FIFO_SIZE_128 : 0;\n\n\tswitch (protocol) {\n\tcase -1:  \n\t\tbch->state = -1;\n\t\tfallthrough;\n\tcase ISDN_P_NONE:\n\t\tif (bch->state == ISDN_P_NONE)\n\t\t\tbreak;\n\t\thdlc->ctrl.sr.cmd  = HDLC_CMD_XRS | HDLC_CMD_RRS;\n\t\thdlc->ctrl.sr.mode = mode | HDLC_MODE_TRANS;\n\t\twrite_ctrl(bch, 5);\n\t\tbch->state = ISDN_P_NONE;\n\t\ttest_and_clear_bit(FLG_HDLC, &bch->Flags);\n\t\ttest_and_clear_bit(FLG_TRANSPARENT, &bch->Flags);\n\t\tbreak;\n\tcase ISDN_P_B_RAW:\n\t\tbch->state = protocol;\n\t\thdlc->ctrl.sr.cmd  = HDLC_CMD_XRS | HDLC_CMD_RRS;\n\t\thdlc->ctrl.sr.mode = mode | HDLC_MODE_TRANS;\n\t\twrite_ctrl(bch, 5);\n\t\thdlc->ctrl.sr.cmd = HDLC_CMD_XRS;\n\t\twrite_ctrl(bch, 1);\n\t\thdlc->ctrl.sr.cmd = 0;\n\t\ttest_and_set_bit(FLG_TRANSPARENT, &bch->Flags);\n\t\tbreak;\n\tcase ISDN_P_B_HDLC:\n\t\tbch->state = protocol;\n\t\thdlc->ctrl.sr.cmd  = HDLC_CMD_XRS | HDLC_CMD_RRS;\n\t\thdlc->ctrl.sr.mode = mode | HDLC_MODE_ITF_FLG;\n\t\twrite_ctrl(bch, 5);\n\t\thdlc->ctrl.sr.cmd = HDLC_CMD_XRS;\n\t\twrite_ctrl(bch, 1);\n\t\thdlc->ctrl.sr.cmd = 0;\n\t\ttest_and_set_bit(FLG_HDLC, &bch->Flags);\n\t\tbreak;\n\tdefault:\n\t\tpr_info(\"%s: protocol not known %x\\n\", fc->name, protocol);\n\t\treturn -ENOPROTOOPT;\n\t}\n\treturn 0;\n}\n\nstatic void\nhdlc_empty_fifo(struct bchannel *bch, int count)\n{\n\tu32 *ptr;\n\tu8 *p;\n\tu32  val, addr;\n\tint cnt;\n\tstruct fritzcard *fc = bch->hw;\n\n\tpr_debug(\"%s: %s %d\\n\", fc->name, __func__, count);\n\tif (test_bit(FLG_RX_OFF, &bch->Flags)) {\n\t\tp = NULL;\n\t\tbch->dropcnt += count;\n\t} else {\n\t\tcnt = bchannel_get_rxbuf(bch, count);\n\t\tif (cnt < 0) {\n\t\t\tpr_warn(\"%s.B%d: No bufferspace for %d bytes\\n\",\n\t\t\t\tfc->name, bch->nr, count);\n\t\t\treturn;\n\t\t}\n\t\tp = skb_put(bch->rx_skb, count);\n\t}\n\tptr = (u32 *)p;\n\tif (fc->type == AVM_FRITZ_PCIV2)\n\t\taddr = fc->addr + (bch->nr == 2 ?\n\t\t\t\t   AVM_HDLC_FIFO_2 : AVM_HDLC_FIFO_1);\n\telse {\n\t\taddr = fc->addr + CHIP_WINDOW;\n\t\toutl(bch->nr == 2 ? AVM_HDLC_2 : AVM_HDLC_1, fc->addr);\n\t}\n\tcnt = 0;\n\twhile (cnt < count) {\n\t\tval = le32_to_cpu(inl(addr));\n\t\tif (p) {\n\t\t\tput_unaligned(val, ptr);\n\t\t\tptr++;\n\t\t}\n\t\tcnt += 4;\n\t}\n\tif (p && (debug & DEBUG_HW_BFIFO)) {\n\t\tsnprintf(fc->log, LOG_SIZE, \"B%1d-recv %s %d \",\n\t\t\t bch->nr, fc->name, count);\n\t\tprint_hex_dump_bytes(fc->log, DUMP_PREFIX_OFFSET, p, count);\n\t}\n}\n\nstatic void\nhdlc_fill_fifo(struct bchannel *bch)\n{\n\tstruct fritzcard *fc = bch->hw;\n\tstruct hdlc_hw *hdlc;\n\tint count, fs, cnt = 0, idx;\n\tbool fillempty = false;\n\tu8 *p;\n\tu32 *ptr, val, addr;\n\n\tidx = (bch->nr - 1) & 1;\n\thdlc = &fc->hdlc[idx];\n\tfs = (fc->type == AVM_FRITZ_PCIV2) ?\n\t\tHDLC_FIFO_SIZE_V2 : HDLC_FIFO_SIZE_V1;\n\tif (!bch->tx_skb) {\n\t\tif (!test_bit(FLG_TX_EMPTY, &bch->Flags))\n\t\t\treturn;\n\t\tcount = fs;\n\t\tp = bch->fill;\n\t\tfillempty = true;\n\t} else {\n\t\tcount = bch->tx_skb->len - bch->tx_idx;\n\t\tif (count <= 0)\n\t\t\treturn;\n\t\tp = bch->tx_skb->data + bch->tx_idx;\n\t}\n\thdlc->ctrl.sr.cmd &= ~HDLC_CMD_XME;\n\tif (count > fs) {\n\t\tcount = fs;\n\t} else {\n\t\tif (test_bit(FLG_HDLC, &bch->Flags))\n\t\t\thdlc->ctrl.sr.cmd |= HDLC_CMD_XME;\n\t}\n\tptr = (u32 *)p;\n\tif (!fillempty) {\n\t\tpr_debug(\"%s.B%d: %d/%d/%d\", fc->name, bch->nr, count,\n\t\t\t bch->tx_idx, bch->tx_skb->len);\n\t\tbch->tx_idx += count;\n\t} else {\n\t\tpr_debug(\"%s.B%d: fillempty %d\\n\", fc->name, bch->nr, count);\n\t}\n\thdlc->ctrl.sr.xml = ((count == fs) ? 0 : count);\n\tif (fc->type == AVM_FRITZ_PCIV2) {\n\t\t__write_ctrl_pciv2(fc, hdlc, bch->nr);\n\t\taddr = fc->addr + (bch->nr == 2 ?\n\t\t\t\t   AVM_HDLC_FIFO_2 : AVM_HDLC_FIFO_1);\n\t} else {\n\t\t__write_ctrl_pci(fc, hdlc, bch->nr);\n\t\taddr = fc->addr + CHIP_WINDOW;\n\t}\n\tif (fillempty) {\n\t\twhile (cnt < count) {\n\t\t\t \n\t\t\toutl(*ptr, addr);\n\t\t\tcnt += 4;\n\t\t}\n\t} else {\n\t\twhile (cnt < count) {\n\t\t\tval = get_unaligned(ptr);\n\t\t\toutl(cpu_to_le32(val), addr);\n\t\t\tptr++;\n\t\t\tcnt += 4;\n\t\t}\n\t}\n\tif ((debug & DEBUG_HW_BFIFO) && !fillempty) {\n\t\tsnprintf(fc->log, LOG_SIZE, \"B%1d-send %s %d \",\n\t\t\t bch->nr, fc->name, count);\n\t\tprint_hex_dump_bytes(fc->log, DUMP_PREFIX_OFFSET, p, count);\n\t}\n}\n\nstatic void\nHDLC_irq_xpr(struct bchannel *bch)\n{\n\tif (bch->tx_skb && bch->tx_idx < bch->tx_skb->len) {\n\t\thdlc_fill_fifo(bch);\n\t} else {\n\t\tdev_kfree_skb(bch->tx_skb);\n\t\tif (get_next_bframe(bch)) {\n\t\t\thdlc_fill_fifo(bch);\n\t\t\ttest_and_clear_bit(FLG_TX_EMPTY, &bch->Flags);\n\t\t} else if (test_bit(FLG_TX_EMPTY, &bch->Flags)) {\n\t\t\thdlc_fill_fifo(bch);\n\t\t}\n\t}\n}\n\nstatic void\nHDLC_irq(struct bchannel *bch, u32 stat)\n{\n\tstruct fritzcard *fc = bch->hw;\n\tint\t\tlen, fs;\n\tu32\t\trmlMask;\n\tstruct hdlc_hw\t*hdlc;\n\n\thdlc = &fc->hdlc[(bch->nr - 1) & 1];\n\tpr_debug(\"%s: ch%d stat %#x\\n\", fc->name, bch->nr, stat);\n\tif (fc->type == AVM_FRITZ_PCIV2) {\n\t\trmlMask = HDLC_STAT_RML_MASK_V2;\n\t\tfs = HDLC_FIFO_SIZE_V2;\n\t} else {\n\t\trmlMask = HDLC_STAT_RML_MASK_V1;\n\t\tfs = HDLC_FIFO_SIZE_V1;\n\t}\n\tif (stat & HDLC_INT_RPR) {\n\t\tif (stat & HDLC_STAT_RDO) {\n\t\t\tpr_warn(\"%s: ch%d stat %x RDO\\n\",\n\t\t\t\tfc->name, bch->nr, stat);\n\t\t\thdlc->ctrl.sr.xml = 0;\n\t\t\thdlc->ctrl.sr.cmd |= HDLC_CMD_RRS;\n\t\t\twrite_ctrl(bch, 1);\n\t\t\thdlc->ctrl.sr.cmd &= ~HDLC_CMD_RRS;\n\t\t\twrite_ctrl(bch, 1);\n\t\t\tif (bch->rx_skb)\n\t\t\t\tskb_trim(bch->rx_skb, 0);\n\t\t} else {\n\t\t\tlen = (stat & rmlMask) >> 8;\n\t\t\tif (!len)\n\t\t\t\tlen = fs;\n\t\t\thdlc_empty_fifo(bch, len);\n\t\t\tif (!bch->rx_skb)\n\t\t\t\tgoto handle_tx;\n\t\t\tif (test_bit(FLG_TRANSPARENT, &bch->Flags)) {\n\t\t\t\trecv_Bchannel(bch, 0, false);\n\t\t\t} else if (stat & HDLC_STAT_RME) {\n\t\t\t\tif ((stat & HDLC_STAT_CRCVFRRAB) ==\n\t\t\t\t    HDLC_STAT_CRCVFR) {\n\t\t\t\t\trecv_Bchannel(bch, 0, false);\n\t\t\t\t} else {\n\t\t\t\t\tpr_warn(\"%s: got invalid frame\\n\",\n\t\t\t\t\t\tfc->name);\n\t\t\t\t\tskb_trim(bch->rx_skb, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\nhandle_tx:\n\tif (stat & HDLC_INT_XDU) {\n\t\t \n\t\tpr_warn(\"%s: ch%d stat %x XDU %s\\n\", fc->name, bch->nr,\n\t\t\tstat, bch->tx_skb ? \"tx_skb\" : \"no tx_skb\");\n\t\tif (bch->tx_skb && bch->tx_skb->len) {\n\t\t\tif (!test_bit(FLG_TRANSPARENT, &bch->Flags))\n\t\t\t\tbch->tx_idx = 0;\n\t\t} else if (test_bit(FLG_FILLEMPTY, &bch->Flags)) {\n\t\t\ttest_and_set_bit(FLG_TX_EMPTY, &bch->Flags);\n\t\t}\n\t\thdlc->ctrl.sr.xml = 0;\n\t\thdlc->ctrl.sr.cmd |= HDLC_CMD_XRS;\n\t\twrite_ctrl(bch, 1);\n\t\thdlc->ctrl.sr.cmd &= ~HDLC_CMD_XRS;\n\t\tHDLC_irq_xpr(bch);\n\t\treturn;\n\t} else if (stat & HDLC_INT_XPR)\n\t\tHDLC_irq_xpr(bch);\n}\n\nstatic inline void\nHDLC_irq_main(struct fritzcard *fc)\n{\n\tu32 stat;\n\tstruct bchannel *bch;\n\n\tstat = read_status(fc, 1);\n\tif (stat & HDLC_INT_MASK) {\n\t\tbch = Sel_BCS(fc, 1);\n\t\tif (bch)\n\t\t\tHDLC_irq(bch, stat);\n\t\telse\n\t\t\tpr_debug(\"%s: spurious ch1 IRQ\\n\", fc->name);\n\t}\n\tstat = read_status(fc, 2);\n\tif (stat & HDLC_INT_MASK) {\n\t\tbch = Sel_BCS(fc, 2);\n\t\tif (bch)\n\t\t\tHDLC_irq(bch, stat);\n\t\telse\n\t\t\tpr_debug(\"%s: spurious ch2 IRQ\\n\", fc->name);\n\t}\n}\n\nstatic irqreturn_t\navm_fritz_interrupt(int intno, void *dev_id)\n{\n\tstruct fritzcard *fc = dev_id;\n\tu8 val;\n\tu8 sval;\n\n\tspin_lock(&fc->lock);\n\tsval = inb(fc->addr + 2);\n\tpr_debug(\"%s: irq stat0 %x\\n\", fc->name, sval);\n\tif ((sval & AVM_STATUS0_IRQ_MASK) == AVM_STATUS0_IRQ_MASK) {\n\t\t \n\t\tspin_unlock(&fc->lock);\n\t\treturn IRQ_NONE;\n\t}\n\tfc->irqcnt++;\n\n\tif (!(sval & AVM_STATUS0_IRQ_ISAC)) {\n\t\tval = ReadISAC_V1(fc, ISAC_ISTA);\n\t\tmISDNisac_irq(&fc->isac, val);\n\t}\n\tif (!(sval & AVM_STATUS0_IRQ_HDLC))\n\t\tHDLC_irq_main(fc);\n\tspin_unlock(&fc->lock);\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t\navm_fritzv2_interrupt(int intno, void *dev_id)\n{\n\tstruct fritzcard *fc = dev_id;\n\tu8 val;\n\tu8 sval;\n\n\tspin_lock(&fc->lock);\n\tsval = inb(fc->addr + 2);\n\tpr_debug(\"%s: irq stat0 %x\\n\", fc->name, sval);\n\tif (!(sval & AVM_STATUS0_IRQ_MASK)) {\n\t\t \n\t\tspin_unlock(&fc->lock);\n\t\treturn IRQ_NONE;\n\t}\n\tfc->irqcnt++;\n\n\tif (sval & AVM_STATUS0_IRQ_HDLC)\n\t\tHDLC_irq_main(fc);\n\tif (sval & AVM_STATUS0_IRQ_ISAC) {\n\t\tval = ReadISAC_V2(fc, ISACX_ISTA);\n\t\tmISDNisac_irq(&fc->isac, val);\n\t}\n\tif (sval & AVM_STATUS0_IRQ_TIMER) {\n\t\tpr_debug(\"%s: timer irq\\n\", fc->name);\n\t\toutb(fc->ctrlreg | AVM_STATUS0_RES_TIMER, fc->addr + 2);\n\t\tudelay(1);\n\t\toutb(fc->ctrlreg, fc->addr + 2);\n\t}\n\tspin_unlock(&fc->lock);\n\treturn IRQ_HANDLED;\n}\n\nstatic int\navm_l2l1B(struct mISDNchannel *ch, struct sk_buff *skb)\n{\n\tstruct bchannel *bch = container_of(ch, struct bchannel, ch);\n\tstruct fritzcard *fc = bch->hw;\n\tint ret = -EINVAL;\n\tstruct mISDNhead *hh = mISDN_HEAD_P(skb);\n\tunsigned long flags;\n\n\tswitch (hh->prim) {\n\tcase PH_DATA_REQ:\n\t\tspin_lock_irqsave(&fc->lock, flags);\n\t\tret = bchannel_senddata(bch, skb);\n\t\tif (ret > 0) {  \n\t\t\thdlc_fill_fifo(bch);\n\t\t\tret = 0;\n\t\t}\n\t\tspin_unlock_irqrestore(&fc->lock, flags);\n\t\treturn ret;\n\tcase PH_ACTIVATE_REQ:\n\t\tspin_lock_irqsave(&fc->lock, flags);\n\t\tif (!test_and_set_bit(FLG_ACTIVE, &bch->Flags))\n\t\t\tret = modehdlc(bch, ch->protocol);\n\t\telse\n\t\t\tret = 0;\n\t\tspin_unlock_irqrestore(&fc->lock, flags);\n\t\tif (!ret)\n\t\t\t_queue_data(ch, PH_ACTIVATE_IND, MISDN_ID_ANY, 0,\n\t\t\t\t    NULL, GFP_KERNEL);\n\t\tbreak;\n\tcase PH_DEACTIVATE_REQ:\n\t\tspin_lock_irqsave(&fc->lock, flags);\n\t\tmISDN_clear_bchannel(bch);\n\t\tmodehdlc(bch, ISDN_P_NONE);\n\t\tspin_unlock_irqrestore(&fc->lock, flags);\n\t\t_queue_data(ch, PH_DEACTIVATE_IND, MISDN_ID_ANY, 0,\n\t\t\t    NULL, GFP_KERNEL);\n\t\tret = 0;\n\t\tbreak;\n\t}\n\tif (!ret)\n\t\tdev_kfree_skb(skb);\n\treturn ret;\n}\n\nstatic void\ninithdlc(struct fritzcard *fc)\n{\n\tmodehdlc(&fc->bch[0], -1);\n\tmodehdlc(&fc->bch[1], -1);\n}\n\nstatic void\nclear_pending_hdlc_ints(struct fritzcard *fc)\n{\n\tu32 val;\n\n\tval = read_status(fc, 1);\n\tpr_debug(\"%s: HDLC 1 STA %x\\n\", fc->name, val);\n\tval = read_status(fc, 2);\n\tpr_debug(\"%s: HDLC 2 STA %x\\n\", fc->name, val);\n}\n\nstatic void\nreset_avm(struct fritzcard *fc)\n{\n\tswitch (fc->type) {\n\tcase AVM_FRITZ_PCI:\n\t\tfc->ctrlreg = AVM_STATUS0_RESET | AVM_STATUS0_DIS_TIMER;\n\t\tbreak;\n\tcase AVM_FRITZ_PCIV2:\n\t\tfc->ctrlreg = AVM_STATUS0_RESET;\n\t\tbreak;\n\t}\n\tif (debug & DEBUG_HW)\n\t\tpr_notice(\"%s: reset\\n\", fc->name);\n\tdisable_hwirq(fc);\n\tmdelay(5);\n\tswitch (fc->type) {\n\tcase AVM_FRITZ_PCI:\n\t\tfc->ctrlreg = AVM_STATUS0_DIS_TIMER | AVM_STATUS0_RES_TIMER;\n\t\tdisable_hwirq(fc);\n\t\toutb(AVM_STATUS1_ENA_IOM, fc->addr + 3);\n\t\tbreak;\n\tcase AVM_FRITZ_PCIV2:\n\t\tfc->ctrlreg = 0;\n\t\tdisable_hwirq(fc);\n\t\tbreak;\n\t}\n\tmdelay(1);\n\tif (debug & DEBUG_HW)\n\t\tpr_notice(\"%s: S0/S1 %x/%x\\n\", fc->name,\n\t\t\t  inb(fc->addr + 2), inb(fc->addr + 3));\n}\n\nstatic int\ninit_card(struct fritzcard *fc)\n{\n\tint\t\tret, cnt = 3;\n\tu_long\t\tflags;\n\n\treset_avm(fc);  \n\tif (fc->type == AVM_FRITZ_PCIV2)\n\t\tret = request_irq(fc->irq, avm_fritzv2_interrupt,\n\t\t\t\t  IRQF_SHARED, fc->name, fc);\n\telse\n\t\tret = request_irq(fc->irq, avm_fritz_interrupt,\n\t\t\t\t  IRQF_SHARED, fc->name, fc);\n\tif (ret) {\n\t\tpr_info(\"%s: couldn't get interrupt %d\\n\",\n\t\t\tfc->name, fc->irq);\n\t\treturn ret;\n\t}\n\twhile (cnt--) {\n\t\tspin_lock_irqsave(&fc->lock, flags);\n\t\tret = fc->isac.init(&fc->isac);\n\t\tif (ret) {\n\t\t\tspin_unlock_irqrestore(&fc->lock, flags);\n\t\t\tpr_info(\"%s: ISAC init failed with %d\\n\",\n\t\t\t\tfc->name, ret);\n\t\t\tbreak;\n\t\t}\n\t\tclear_pending_hdlc_ints(fc);\n\t\tinithdlc(fc);\n\t\tenable_hwirq(fc);\n\t\t \n\t\tif (fc->type == AVM_FRITZ_PCIV2) {\n\t\t\tWriteISAC_V2(fc, ISACX_MASK, 0);\n\t\t\tWriteISAC_V2(fc, ISACX_CMDRD, 0x41);\n\t\t} else {\n\t\t\tWriteISAC_V1(fc, ISAC_MASK, 0);\n\t\t\tWriteISAC_V1(fc, ISAC_CMDR, 0x41);\n\t\t}\n\t\tspin_unlock_irqrestore(&fc->lock, flags);\n\t\t \n\t\tmsleep_interruptible(10);\n\t\tif (debug & DEBUG_HW)\n\t\t\tpr_notice(\"%s: IRQ %d count %d\\n\", fc->name,\n\t\t\t\t  fc->irq, fc->irqcnt);\n\t\tif (!fc->irqcnt) {\n\t\t\tpr_info(\"%s: IRQ(%d) getting no IRQs during init %d\\n\",\n\t\t\t\tfc->name, fc->irq, 3 - cnt);\n\t\t\treset_avm(fc);\n\t\t} else\n\t\t\treturn 0;\n\t}\n\tfree_irq(fc->irq, fc);\n\treturn -EIO;\n}\n\nstatic int\nchannel_bctrl(struct bchannel *bch, struct mISDN_ctrl_req *cq)\n{\n\treturn mISDN_ctrl_bchannel(bch, cq);\n}\n\nstatic int\navm_bctrl(struct mISDNchannel *ch, u32 cmd, void *arg)\n{\n\tstruct bchannel *bch = container_of(ch, struct bchannel, ch);\n\tstruct fritzcard *fc = bch->hw;\n\tint ret = -EINVAL;\n\tu_long flags;\n\n\tpr_debug(\"%s: %s cmd:%x %p\\n\", fc->name, __func__, cmd, arg);\n\tswitch (cmd) {\n\tcase CLOSE_CHANNEL:\n\t\ttest_and_clear_bit(FLG_OPEN, &bch->Flags);\n\t\tcancel_work_sync(&bch->workq);\n\t\tspin_lock_irqsave(&fc->lock, flags);\n\t\tmISDN_clear_bchannel(bch);\n\t\tmodehdlc(bch, ISDN_P_NONE);\n\t\tspin_unlock_irqrestore(&fc->lock, flags);\n\t\tch->protocol = ISDN_P_NONE;\n\t\tch->peer = NULL;\n\t\tmodule_put(THIS_MODULE);\n\t\tret = 0;\n\t\tbreak;\n\tcase CONTROL_CHANNEL:\n\t\tret = channel_bctrl(bch, arg);\n\t\tbreak;\n\tdefault:\n\t\tpr_info(\"%s: %s unknown prim(%x)\\n\", fc->name, __func__, cmd);\n\t}\n\treturn ret;\n}\n\nstatic int\nchannel_ctrl(struct fritzcard  *fc, struct mISDN_ctrl_req *cq)\n{\n\tint\tret = 0;\n\n\tswitch (cq->op) {\n\tcase MISDN_CTRL_GETOP:\n\t\tcq->op = MISDN_CTRL_LOOP | MISDN_CTRL_L1_TIMER3;\n\t\tbreak;\n\tcase MISDN_CTRL_LOOP:\n\t\t \n\t\tif (cq->channel < 0 || cq->channel > 3) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tret = fc->isac.ctrl(&fc->isac, HW_TESTLOOP, cq->channel);\n\t\tbreak;\n\tcase MISDN_CTRL_L1_TIMER3:\n\t\tret = fc->isac.ctrl(&fc->isac, HW_TIMER3_VALUE, cq->p1);\n\t\tbreak;\n\tdefault:\n\t\tpr_info(\"%s: %s unknown Op %x\\n\", fc->name, __func__, cq->op);\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic int\nopen_bchannel(struct fritzcard *fc, struct channel_req *rq)\n{\n\tstruct bchannel\t\t*bch;\n\n\tif (rq->adr.channel == 0 || rq->adr.channel > 2)\n\t\treturn -EINVAL;\n\tif (rq->protocol == ISDN_P_NONE)\n\t\treturn -EINVAL;\n\tbch = &fc->bch[rq->adr.channel - 1];\n\tif (test_and_set_bit(FLG_OPEN, &bch->Flags))\n\t\treturn -EBUSY;  \n\tbch->ch.protocol = rq->protocol;\n\trq->ch = &bch->ch;\n\treturn 0;\n}\n\n \nstatic int\navm_dctrl(struct mISDNchannel *ch, u32 cmd, void *arg)\n{\n\tstruct mISDNdevice\t*dev = container_of(ch, struct mISDNdevice, D);\n\tstruct dchannel\t\t*dch = container_of(dev, struct dchannel, dev);\n\tstruct fritzcard\t*fc = dch->hw;\n\tstruct channel_req\t*rq;\n\tint\t\t\terr = 0;\n\n\tpr_debug(\"%s: %s cmd:%x %p\\n\", fc->name, __func__, cmd, arg);\n\tswitch (cmd) {\n\tcase OPEN_CHANNEL:\n\t\trq = arg;\n\t\tif (rq->protocol == ISDN_P_TE_S0)\n\t\t\terr = fc->isac.open(&fc->isac, rq);\n\t\telse\n\t\t\terr = open_bchannel(fc, rq);\n\t\tif (err)\n\t\t\tbreak;\n\t\tif (!try_module_get(THIS_MODULE))\n\t\t\tpr_info(\"%s: cannot get module\\n\", fc->name);\n\t\tbreak;\n\tcase CLOSE_CHANNEL:\n\t\tpr_debug(\"%s: dev(%d) close from %p\\n\", fc->name, dch->dev.id,\n\t\t\t __builtin_return_address(0));\n\t\tmodule_put(THIS_MODULE);\n\t\tbreak;\n\tcase CONTROL_CHANNEL:\n\t\terr = channel_ctrl(fc, arg);\n\t\tbreak;\n\tdefault:\n\t\tpr_debug(\"%s: %s unknown command %x\\n\",\n\t\t\t fc->name, __func__, cmd);\n\t\treturn -EINVAL;\n\t}\n\treturn err;\n}\n\nstatic int\nsetup_fritz(struct fritzcard *fc)\n{\n\tu32 val, ver;\n\n\tif (!request_region(fc->addr, 32, fc->name)) {\n\t\tpr_info(\"%s: AVM config port %x-%x already in use\\n\",\n\t\t\tfc->name, fc->addr, fc->addr + 31);\n\t\treturn -EIO;\n\t}\n\tswitch (fc->type) {\n\tcase AVM_FRITZ_PCI:\n\t\tval = inl(fc->addr);\n\t\toutl(AVM_HDLC_1, fc->addr + CHIP_INDEX);\n\t\tver = inl(fc->addr + CHIP_WINDOW + HDLC_STATUS) >> 24;\n\t\tif (debug & DEBUG_HW) {\n\t\t\tpr_notice(\"%s: PCI stat %#x\\n\", fc->name, val);\n\t\t\tpr_notice(\"%s: PCI Class %X Rev %d\\n\", fc->name,\n\t\t\t\t  val & 0xff, (val >> 8) & 0xff);\n\t\t\tpr_notice(\"%s: HDLC version %x\\n\", fc->name, ver & 0xf);\n\t\t}\n\t\tASSIGN_FUNC(V1, ISAC, fc->isac);\n\t\tfc->isac.type = IPAC_TYPE_ISAC;\n\t\tbreak;\n\tcase AVM_FRITZ_PCIV2:\n\t\tval = inl(fc->addr);\n\t\tver = inl(fc->addr + AVM_HDLC_STATUS_1) >> 24;\n\t\tif (debug & DEBUG_HW) {\n\t\t\tpr_notice(\"%s: PCI V2 stat %#x\\n\", fc->name, val);\n\t\t\tpr_notice(\"%s: PCI V2 Class %X Rev %d\\n\", fc->name,\n\t\t\t\t  val & 0xff, (val >> 8) & 0xff);\n\t\t\tpr_notice(\"%s: HDLC version %x\\n\", fc->name, ver & 0xf);\n\t\t}\n\t\tASSIGN_FUNC(V2, ISAC, fc->isac);\n\t\tfc->isac.type = IPAC_TYPE_ISACX;\n\t\tbreak;\n\tdefault:\n\t\trelease_region(fc->addr, 32);\n\t\tpr_info(\"%s: AVM unknown type %d\\n\", fc->name, fc->type);\n\t\treturn -ENODEV;\n\t}\n\tpr_notice(\"%s: %s config irq:%d base:0x%X\\n\", fc->name,\n\t\t  (fc->type == AVM_FRITZ_PCI) ? \"AVM Fritz!CARD PCI\" :\n\t\t  \"AVM Fritz!CARD PCIv2\", fc->irq, fc->addr);\n\treturn 0;\n}\n\nstatic void\nrelease_card(struct fritzcard *card)\n{\n\tu_long flags;\n\n\tdisable_hwirq(card);\n\tspin_lock_irqsave(&card->lock, flags);\n\tmodehdlc(&card->bch[0], ISDN_P_NONE);\n\tmodehdlc(&card->bch[1], ISDN_P_NONE);\n\tspin_unlock_irqrestore(&card->lock, flags);\n\tcard->isac.release(&card->isac);\n\tfree_irq(card->irq, card);\n\tmISDN_freebchannel(&card->bch[1]);\n\tmISDN_freebchannel(&card->bch[0]);\n\tmISDN_unregister_device(&card->isac.dch.dev);\n\trelease_region(card->addr, 32);\n\tpci_disable_device(card->pdev);\n\tpci_set_drvdata(card->pdev, NULL);\n\twrite_lock_irqsave(&card_lock, flags);\n\tlist_del(&card->list);\n\twrite_unlock_irqrestore(&card_lock, flags);\n\tkfree(card);\n\tAVM_cnt--;\n}\n\nstatic int\nsetup_instance(struct fritzcard *card)\n{\n\tint i, err;\n\tunsigned short minsize;\n\tu_long flags;\n\n\tsnprintf(card->name, MISDN_MAX_IDLEN - 1, \"AVM.%d\", AVM_cnt + 1);\n\twrite_lock_irqsave(&card_lock, flags);\n\tlist_add_tail(&card->list, &Cards);\n\twrite_unlock_irqrestore(&card_lock, flags);\n\n\t_set_debug(card);\n\tcard->isac.name = card->name;\n\tspin_lock_init(&card->lock);\n\tcard->isac.hwlock = &card->lock;\n\tmISDNisac_init(&card->isac, card);\n\n\tcard->isac.dch.dev.Bprotocols = (1 << (ISDN_P_B_RAW & ISDN_P_B_MASK)) |\n\t\t(1 << (ISDN_P_B_HDLC & ISDN_P_B_MASK));\n\tcard->isac.dch.dev.D.ctrl = avm_dctrl;\n\tfor (i = 0; i < 2; i++) {\n\t\tcard->bch[i].nr = i + 1;\n\t\tset_channelmap(i + 1, card->isac.dch.dev.channelmap);\n\t\tif (AVM_FRITZ_PCIV2 == card->type)\n\t\t\tminsize = HDLC_FIFO_SIZE_V2;\n\t\telse\n\t\t\tminsize = HDLC_FIFO_SIZE_V1;\n\t\tmISDN_initbchannel(&card->bch[i], MAX_DATA_MEM, minsize);\n\t\tcard->bch[i].hw = card;\n\t\tcard->bch[i].ch.send = avm_l2l1B;\n\t\tcard->bch[i].ch.ctrl = avm_bctrl;\n\t\tcard->bch[i].ch.nr = i + 1;\n\t\tlist_add(&card->bch[i].ch.list, &card->isac.dch.dev.bchannels);\n\t}\n\terr = setup_fritz(card);\n\tif (err)\n\t\tgoto error;\n\terr = mISDN_register_device(&card->isac.dch.dev, &card->pdev->dev,\n\t\t\t\t    card->name);\n\tif (err)\n\t\tgoto error_reg;\n\terr = init_card(card);\n\tif (!err)  {\n\t\tAVM_cnt++;\n\t\tpr_notice(\"AVM %d cards installed DEBUG\\n\", AVM_cnt);\n\t\treturn 0;\n\t}\n\tmISDN_unregister_device(&card->isac.dch.dev);\nerror_reg:\n\trelease_region(card->addr, 32);\nerror:\n\tcard->isac.release(&card->isac);\n\tmISDN_freebchannel(&card->bch[1]);\n\tmISDN_freebchannel(&card->bch[0]);\n\twrite_lock_irqsave(&card_lock, flags);\n\tlist_del(&card->list);\n\twrite_unlock_irqrestore(&card_lock, flags);\n\tkfree(card);\n\treturn err;\n}\n\nstatic int\nfritzpci_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tint err = -ENOMEM;\n\tstruct fritzcard *card;\n\n\tcard = kzalloc(sizeof(struct fritzcard), GFP_KERNEL);\n\tif (!card) {\n\t\tpr_info(\"No kmem for fritzcard\\n\");\n\t\treturn err;\n\t}\n\tif (pdev->device == PCI_DEVICE_ID_AVM_A1_V2)\n\t\tcard->type = AVM_FRITZ_PCIV2;\n\telse\n\t\tcard->type = AVM_FRITZ_PCI;\n\tcard->pdev = pdev;\n\terr = pci_enable_device(pdev);\n\tif (err) {\n\t\tkfree(card);\n\t\treturn err;\n\t}\n\n\tpr_notice(\"mISDN: found adapter %s at %s\\n\",\n\t\t  (char *) ent->driver_data, pci_name(pdev));\n\n\tcard->addr = pci_resource_start(pdev, 1);\n\tcard->irq = pdev->irq;\n\tpci_set_drvdata(pdev, card);\n\terr = setup_instance(card);\n\tif (err)\n\t\tpci_set_drvdata(pdev, NULL);\n\treturn err;\n}\n\nstatic void\nfritz_remove_pci(struct pci_dev *pdev)\n{\n\tstruct fritzcard *card = pci_get_drvdata(pdev);\n\n\tif (card)\n\t\trelease_card(card);\n\telse\n\t\tif (debug)\n\t\t\tpr_info(\"%s: drvdata already removed\\n\", __func__);\n}\n\nstatic const struct pci_device_id fcpci_ids[] = {\n\t{ PCI_VENDOR_ID_AVM, PCI_DEVICE_ID_AVM_A1, PCI_ANY_ID, PCI_ANY_ID,\n\t  0, 0, (unsigned long) \"Fritz!Card PCI\"},\n\t{ PCI_VENDOR_ID_AVM, PCI_DEVICE_ID_AVM_A1_V2, PCI_ANY_ID, PCI_ANY_ID,\n\t  0, 0, (unsigned long) \"Fritz!Card PCI v2\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(pci, fcpci_ids);\n\nstatic struct pci_driver fcpci_driver = {\n\t.name = \"fcpci\",\n\t.probe = fritzpci_probe,\n\t.remove = fritz_remove_pci,\n\t.id_table = fcpci_ids,\n};\n\nstatic int __init AVM_init(void)\n{\n\tint err;\n\n\tpr_notice(\"AVM Fritz PCI driver Rev. %s\\n\", AVMFRITZ_REV);\n\terr = pci_register_driver(&fcpci_driver);\n\treturn err;\n}\n\nstatic void __exit AVM_cleanup(void)\n{\n\tpci_unregister_driver(&fcpci_driver);\n}\n\nmodule_init(AVM_init);\nmodule_exit(AVM_cleanup);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}