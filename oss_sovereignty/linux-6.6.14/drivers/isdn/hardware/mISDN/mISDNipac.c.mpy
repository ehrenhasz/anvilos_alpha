{
  "module_name": "mISDNipac.c",
  "hash_id": "6cdcdd17b5f7e8b3001d658c2edc231ab0e970f897e1679c983aa4770aeff449",
  "original_prompt": "Ingested from linux-6.6.14/drivers/isdn/hardware/mISDN/mISDNipac.c",
  "human_readable_source": "\n \n\n#include <linux/irqreturn.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mISDNhw.h>\n#include \"ipac.h\"\n\n\n#define DBUSY_TIMER_VALUE\t80\n#define ARCOFI_USE\t\t1\n\n#define ISAC_REV\t\t\"2.0\"\n\nMODULE_AUTHOR(\"Karsten Keil\");\nMODULE_VERSION(ISAC_REV);\nMODULE_LICENSE(\"GPL v2\");\n\n#define ReadISAC(is, o)\t\t(is->read_reg(is->dch.hw, o + is->off))\n#define\tWriteISAC(is, o, v)\t(is->write_reg(is->dch.hw, o + is->off, v))\n#define ReadHSCX(h, o)\t\t(h->ip->read_reg(h->ip->hw, h->off + o))\n#define WriteHSCX(h, o, v)\t(h->ip->write_reg(h->ip->hw, h->off + o, v))\n#define ReadIPAC(ip, o)\t\t(ip->read_reg(ip->hw, o))\n#define WriteIPAC(ip, o, v)\t(ip->write_reg(ip->hw, o, v))\n\nstatic inline void\nph_command(struct isac_hw *isac, u8 command)\n{\n\tpr_debug(\"%s: ph_command %x\\n\", isac->name, command);\n\tif (isac->type & IPAC_TYPE_ISACX)\n\t\tWriteISAC(isac, ISACX_CIX0, (command << 4) | 0xE);\n\telse\n\t\tWriteISAC(isac, ISAC_CIX0, (command << 2) | 3);\n}\n\nstatic void\nisac_ph_state_change(struct isac_hw *isac)\n{\n\tswitch (isac->state) {\n\tcase (ISAC_IND_RS):\n\tcase (ISAC_IND_EI):\n\t\tph_command(isac, ISAC_CMD_DUI);\n\t}\n\tschedule_event(&isac->dch, FLG_PHCHANGE);\n}\n\nstatic void\nisac_ph_state_bh(struct dchannel *dch)\n{\n\tstruct isac_hw *isac = container_of(dch, struct isac_hw, dch);\n\n\tswitch (isac->state) {\n\tcase ISAC_IND_RS:\n\tcase ISAC_IND_EI:\n\t\tdch->state = 0;\n\t\tl1_event(dch->l1, HW_RESET_IND);\n\t\tbreak;\n\tcase ISAC_IND_DID:\n\t\tdch->state = 3;\n\t\tl1_event(dch->l1, HW_DEACT_CNF);\n\t\tbreak;\n\tcase ISAC_IND_DR:\n\tcase ISAC_IND_DR6:\n\t\tdch->state = 3;\n\t\tl1_event(dch->l1, HW_DEACT_IND);\n\t\tbreak;\n\tcase ISAC_IND_PU:\n\t\tdch->state = 4;\n\t\tl1_event(dch->l1, HW_POWERUP_IND);\n\t\tbreak;\n\tcase ISAC_IND_RSY:\n\t\tif (dch->state <= 5) {\n\t\t\tdch->state = 5;\n\t\t\tl1_event(dch->l1, ANYSIGNAL);\n\t\t} else {\n\t\t\tdch->state = 8;\n\t\t\tl1_event(dch->l1, LOSTFRAMING);\n\t\t}\n\t\tbreak;\n\tcase ISAC_IND_ARD:\n\t\tdch->state = 6;\n\t\tl1_event(dch->l1, INFO2);\n\t\tbreak;\n\tcase ISAC_IND_AI8:\n\t\tdch->state = 7;\n\t\tl1_event(dch->l1, INFO4_P8);\n\t\tbreak;\n\tcase ISAC_IND_AI10:\n\t\tdch->state = 7;\n\t\tl1_event(dch->l1, INFO4_P10);\n\t\tbreak;\n\t}\n\tpr_debug(\"%s: TE newstate %x\\n\", isac->name, dch->state);\n}\n\nstatic void\nisac_empty_fifo(struct isac_hw *isac, int count)\n{\n\tu8 *ptr;\n\n\tpr_debug(\"%s: %s  %d\\n\", isac->name, __func__, count);\n\n\tif (!isac->dch.rx_skb) {\n\t\tisac->dch.rx_skb = mI_alloc_skb(isac->dch.maxlen, GFP_ATOMIC);\n\t\tif (!isac->dch.rx_skb) {\n\t\t\tpr_info(\"%s: D receive out of memory\\n\", isac->name);\n\t\t\tWriteISAC(isac, ISAC_CMDR, 0x80);\n\t\t\treturn;\n\t\t}\n\t}\n\tif ((isac->dch.rx_skb->len + count) >= isac->dch.maxlen) {\n\t\tpr_debug(\"%s: %s overrun %d\\n\", isac->name, __func__,\n\t\t\t isac->dch.rx_skb->len + count);\n\t\tWriteISAC(isac, ISAC_CMDR, 0x80);\n\t\treturn;\n\t}\n\tptr = skb_put(isac->dch.rx_skb, count);\n\tisac->read_fifo(isac->dch.hw, isac->off, ptr, count);\n\tWriteISAC(isac, ISAC_CMDR, 0x80);\n\tif (isac->dch.debug & DEBUG_HW_DFIFO) {\n\t\tchar\tpfx[MISDN_MAX_IDLEN + 16];\n\n\t\tsnprintf(pfx, MISDN_MAX_IDLEN + 15, \"D-recv %s %d \",\n\t\t\t isac->name, count);\n\t\tprint_hex_dump_bytes(pfx, DUMP_PREFIX_OFFSET, ptr, count);\n\t}\n}\n\nstatic void\nisac_fill_fifo(struct isac_hw *isac)\n{\n\tint count, more;\n\tu8 *ptr;\n\n\tif (!isac->dch.tx_skb)\n\t\treturn;\n\tcount = isac->dch.tx_skb->len - isac->dch.tx_idx;\n\tif (count <= 0)\n\t\treturn;\n\n\tmore = 0;\n\tif (count > 32) {\n\t\tmore = !0;\n\t\tcount = 32;\n\t}\n\tpr_debug(\"%s: %s  %d\\n\", isac->name, __func__, count);\n\tptr = isac->dch.tx_skb->data + isac->dch.tx_idx;\n\tisac->dch.tx_idx += count;\n\tisac->write_fifo(isac->dch.hw, isac->off, ptr, count);\n\tWriteISAC(isac, ISAC_CMDR, more ? 0x8 : 0xa);\n\tif (test_and_set_bit(FLG_BUSY_TIMER, &isac->dch.Flags)) {\n\t\tpr_debug(\"%s: %s dbusytimer running\\n\", isac->name, __func__);\n\t\tdel_timer(&isac->dch.timer);\n\t}\n\tisac->dch.timer.expires = jiffies + ((DBUSY_TIMER_VALUE * HZ)/1000);\n\tadd_timer(&isac->dch.timer);\n\tif (isac->dch.debug & DEBUG_HW_DFIFO) {\n\t\tchar\tpfx[MISDN_MAX_IDLEN + 16];\n\n\t\tsnprintf(pfx, MISDN_MAX_IDLEN + 15, \"D-send %s %d \",\n\t\t\t isac->name, count);\n\t\tprint_hex_dump_bytes(pfx, DUMP_PREFIX_OFFSET, ptr, count);\n\t}\n}\n\nstatic void\nisac_rme_irq(struct isac_hw *isac)\n{\n\tu8 val, count;\n\n\tval = ReadISAC(isac, ISAC_RSTA);\n\tif ((val & 0x70) != 0x20) {\n\t\tif (val & 0x40) {\n\t\t\tpr_debug(\"%s: ISAC RDO\\n\", isac->name);\n#ifdef ERROR_STATISTIC\n\t\t\tisac->dch.err_rx++;\n#endif\n\t\t}\n\t\tif (!(val & 0x20)) {\n\t\t\tpr_debug(\"%s: ISAC CRC error\\n\", isac->name);\n#ifdef ERROR_STATISTIC\n\t\t\tisac->dch.err_crc++;\n#endif\n\t\t}\n\t\tWriteISAC(isac, ISAC_CMDR, 0x80);\n\t\tdev_kfree_skb(isac->dch.rx_skb);\n\t\tisac->dch.rx_skb = NULL;\n\t} else {\n\t\tcount = ReadISAC(isac, ISAC_RBCL) & 0x1f;\n\t\tif (count == 0)\n\t\t\tcount = 32;\n\t\tisac_empty_fifo(isac, count);\n\t\trecv_Dchannel(&isac->dch);\n\t}\n}\n\nstatic void\nisac_xpr_irq(struct isac_hw *isac)\n{\n\tif (test_and_clear_bit(FLG_BUSY_TIMER, &isac->dch.Flags))\n\t\tdel_timer(&isac->dch.timer);\n\tif (isac->dch.tx_skb && isac->dch.tx_idx < isac->dch.tx_skb->len) {\n\t\tisac_fill_fifo(isac);\n\t} else {\n\t\tdev_kfree_skb(isac->dch.tx_skb);\n\t\tif (get_next_dframe(&isac->dch))\n\t\t\tisac_fill_fifo(isac);\n\t}\n}\n\nstatic void\nisac_retransmit(struct isac_hw *isac)\n{\n\tif (test_and_clear_bit(FLG_BUSY_TIMER, &isac->dch.Flags))\n\t\tdel_timer(&isac->dch.timer);\n\tif (test_bit(FLG_TX_BUSY, &isac->dch.Flags)) {\n\t\t \n\t\tisac->dch.tx_idx = 0;\n\t\tisac_fill_fifo(isac);\n\t} else if (isac->dch.tx_skb) {  \n\t\tpr_info(\"%s: tx_skb exist but not busy\\n\", isac->name);\n\t\ttest_and_set_bit(FLG_TX_BUSY, &isac->dch.Flags);\n\t\tisac->dch.tx_idx = 0;\n\t\tisac_fill_fifo(isac);\n\t} else {\n\t\tpr_info(\"%s: ISAC XDU no TX_BUSY\\n\", isac->name);\n\t\tif (get_next_dframe(&isac->dch))\n\t\t\tisac_fill_fifo(isac);\n\t}\n}\n\nstatic void\nisac_mos_irq(struct isac_hw *isac)\n{\n\tu8 val;\n\tint ret;\n\n\tval = ReadISAC(isac, ISAC_MOSR);\n\tpr_debug(\"%s: ISAC MOSR %02x\\n\", isac->name, val);\n#if ARCOFI_USE\n\tif (val & 0x08) {\n\t\tif (!isac->mon_rx) {\n\t\t\tisac->mon_rx = kmalloc(MAX_MON_FRAME, GFP_ATOMIC);\n\t\t\tif (!isac->mon_rx) {\n\t\t\t\tpr_info(\"%s: ISAC MON RX out of memory!\\n\",\n\t\t\t\t\tisac->name);\n\t\t\t\tisac->mocr &= 0xf0;\n\t\t\t\tisac->mocr |= 0x0a;\n\t\t\t\tWriteISAC(isac, ISAC_MOCR, isac->mocr);\n\t\t\t\tgoto afterMONR0;\n\t\t\t} else\n\t\t\t\tisac->mon_rxp = 0;\n\t\t}\n\t\tif (isac->mon_rxp >= MAX_MON_FRAME) {\n\t\t\tisac->mocr &= 0xf0;\n\t\t\tisac->mocr |= 0x0a;\n\t\t\tWriteISAC(isac, ISAC_MOCR, isac->mocr);\n\t\t\tisac->mon_rxp = 0;\n\t\t\tpr_debug(\"%s: ISAC MON RX overflow!\\n\", isac->name);\n\t\t\tgoto afterMONR0;\n\t\t}\n\t\tisac->mon_rx[isac->mon_rxp++] = ReadISAC(isac, ISAC_MOR0);\n\t\tpr_debug(\"%s: ISAC MOR0 %02x\\n\", isac->name,\n\t\t\t isac->mon_rx[isac->mon_rxp - 1]);\n\t\tif (isac->mon_rxp == 1) {\n\t\t\tisac->mocr |= 0x04;\n\t\t\tWriteISAC(isac, ISAC_MOCR, isac->mocr);\n\t\t}\n\t}\nafterMONR0:\n\tif (val & 0x80) {\n\t\tif (!isac->mon_rx) {\n\t\t\tisac->mon_rx = kmalloc(MAX_MON_FRAME, GFP_ATOMIC);\n\t\t\tif (!isac->mon_rx) {\n\t\t\t\tpr_info(\"%s: ISAC MON RX out of memory!\\n\",\n\t\t\t\t\tisac->name);\n\t\t\t\tisac->mocr &= 0x0f;\n\t\t\t\tisac->mocr |= 0xa0;\n\t\t\t\tWriteISAC(isac, ISAC_MOCR, isac->mocr);\n\t\t\t\tgoto afterMONR1;\n\t\t\t} else\n\t\t\t\tisac->mon_rxp = 0;\n\t\t}\n\t\tif (isac->mon_rxp >= MAX_MON_FRAME) {\n\t\t\tisac->mocr &= 0x0f;\n\t\t\tisac->mocr |= 0xa0;\n\t\t\tWriteISAC(isac, ISAC_MOCR, isac->mocr);\n\t\t\tisac->mon_rxp = 0;\n\t\t\tpr_debug(\"%s: ISAC MON RX overflow!\\n\", isac->name);\n\t\t\tgoto afterMONR1;\n\t\t}\n\t\tisac->mon_rx[isac->mon_rxp++] = ReadISAC(isac, ISAC_MOR1);\n\t\tpr_debug(\"%s: ISAC MOR1 %02x\\n\", isac->name,\n\t\t\t isac->mon_rx[isac->mon_rxp - 1]);\n\t\tisac->mocr |= 0x40;\n\t\tWriteISAC(isac, ISAC_MOCR, isac->mocr);\n\t}\nafterMONR1:\n\tif (val & 0x04) {\n\t\tisac->mocr &= 0xf0;\n\t\tWriteISAC(isac, ISAC_MOCR, isac->mocr);\n\t\tisac->mocr |= 0x0a;\n\t\tWriteISAC(isac, ISAC_MOCR, isac->mocr);\n\t\tif (isac->monitor) {\n\t\t\tret = isac->monitor(isac->dch.hw, MONITOR_RX_0,\n\t\t\t\t\t    isac->mon_rx, isac->mon_rxp);\n\t\t\tif (ret)\n\t\t\t\tkfree(isac->mon_rx);\n\t\t} else {\n\t\t\tpr_info(\"%s: MONITOR 0 received %d but no user\\n\",\n\t\t\t\tisac->name, isac->mon_rxp);\n\t\t\tkfree(isac->mon_rx);\n\t\t}\n\t\tisac->mon_rx = NULL;\n\t\tisac->mon_rxp = 0;\n\t}\n\tif (val & 0x40) {\n\t\tisac->mocr &= 0x0f;\n\t\tWriteISAC(isac, ISAC_MOCR, isac->mocr);\n\t\tisac->mocr |= 0xa0;\n\t\tWriteISAC(isac, ISAC_MOCR, isac->mocr);\n\t\tif (isac->monitor) {\n\t\t\tret = isac->monitor(isac->dch.hw, MONITOR_RX_1,\n\t\t\t\t\t    isac->mon_rx, isac->mon_rxp);\n\t\t\tif (ret)\n\t\t\t\tkfree(isac->mon_rx);\n\t\t} else {\n\t\t\tpr_info(\"%s: MONITOR 1 received %d but no user\\n\",\n\t\t\t\tisac->name, isac->mon_rxp);\n\t\t\tkfree(isac->mon_rx);\n\t\t}\n\t\tisac->mon_rx = NULL;\n\t\tisac->mon_rxp = 0;\n\t}\n\tif (val & 0x02) {\n\t\tif ((!isac->mon_tx) || (isac->mon_txc &&\n\t\t\t\t\t(isac->mon_txp >= isac->mon_txc) && !(val & 0x08))) {\n\t\t\tisac->mocr &= 0xf0;\n\t\t\tWriteISAC(isac, ISAC_MOCR, isac->mocr);\n\t\t\tisac->mocr |= 0x0a;\n\t\t\tWriteISAC(isac, ISAC_MOCR, isac->mocr);\n\t\t\tif (isac->mon_txc && (isac->mon_txp >= isac->mon_txc)) {\n\t\t\t\tif (isac->monitor)\n\t\t\t\t\tisac->monitor(isac->dch.hw,\n\t\t\t\t\t\t      MONITOR_TX_0, NULL, 0);\n\t\t\t}\n\t\t\tkfree(isac->mon_tx);\n\t\t\tisac->mon_tx = NULL;\n\t\t\tisac->mon_txc = 0;\n\t\t\tisac->mon_txp = 0;\n\t\t\tgoto AfterMOX0;\n\t\t}\n\t\tif (isac->mon_txc && (isac->mon_txp >= isac->mon_txc)) {\n\t\t\tif (isac->monitor)\n\t\t\t\tisac->monitor(isac->dch.hw,\n\t\t\t\t\t      MONITOR_TX_0, NULL, 0);\n\t\t\tkfree(isac->mon_tx);\n\t\t\tisac->mon_tx = NULL;\n\t\t\tisac->mon_txc = 0;\n\t\t\tisac->mon_txp = 0;\n\t\t\tgoto AfterMOX0;\n\t\t}\n\t\tWriteISAC(isac, ISAC_MOX0, isac->mon_tx[isac->mon_txp++]);\n\t\tpr_debug(\"%s: ISAC %02x -> MOX0\\n\", isac->name,\n\t\t\t isac->mon_tx[isac->mon_txp - 1]);\n\t}\nAfterMOX0:\n\tif (val & 0x20) {\n\t\tif ((!isac->mon_tx) || (isac->mon_txc &&\n\t\t\t\t\t(isac->mon_txp >= isac->mon_txc) && !(val & 0x80))) {\n\t\t\tisac->mocr &= 0x0f;\n\t\t\tWriteISAC(isac, ISAC_MOCR, isac->mocr);\n\t\t\tisac->mocr |= 0xa0;\n\t\t\tWriteISAC(isac, ISAC_MOCR, isac->mocr);\n\t\t\tif (isac->mon_txc && (isac->mon_txp >= isac->mon_txc)) {\n\t\t\t\tif (isac->monitor)\n\t\t\t\t\tisac->monitor(isac->dch.hw,\n\t\t\t\t\t\t      MONITOR_TX_1, NULL, 0);\n\t\t\t}\n\t\t\tkfree(isac->mon_tx);\n\t\t\tisac->mon_tx = NULL;\n\t\t\tisac->mon_txc = 0;\n\t\t\tisac->mon_txp = 0;\n\t\t\tgoto AfterMOX1;\n\t\t}\n\t\tif (isac->mon_txc && (isac->mon_txp >= isac->mon_txc)) {\n\t\t\tif (isac->monitor)\n\t\t\t\tisac->monitor(isac->dch.hw,\n\t\t\t\t\t      MONITOR_TX_1, NULL, 0);\n\t\t\tkfree(isac->mon_tx);\n\t\t\tisac->mon_tx = NULL;\n\t\t\tisac->mon_txc = 0;\n\t\t\tisac->mon_txp = 0;\n\t\t\tgoto AfterMOX1;\n\t\t}\n\t\tWriteISAC(isac, ISAC_MOX1, isac->mon_tx[isac->mon_txp++]);\n\t\tpr_debug(\"%s: ISAC %02x -> MOX1\\n\", isac->name,\n\t\t\t isac->mon_tx[isac->mon_txp - 1]);\n\t}\nAfterMOX1:\n\tval = 0;  \n#endif\n}\n\nstatic void\nisac_cisq_irq(struct isac_hw *isac) {\n\tu8 val;\n\n\tval = ReadISAC(isac, ISAC_CIR0);\n\tpr_debug(\"%s: ISAC CIR0 %02X\\n\", isac->name, val);\n\tif (val & 2) {\n\t\tpr_debug(\"%s: ph_state change %x->%x\\n\", isac->name,\n\t\t\t isac->state, (val >> 2) & 0xf);\n\t\tisac->state = (val >> 2) & 0xf;\n\t\tisac_ph_state_change(isac);\n\t}\n\tif (val & 1) {\n\t\tval = ReadISAC(isac, ISAC_CIR1);\n\t\tpr_debug(\"%s: ISAC CIR1 %02X\\n\", isac->name, val);\n\t}\n}\n\nstatic void\nisacsx_cic_irq(struct isac_hw *isac)\n{\n\tu8 val;\n\n\tval = ReadISAC(isac, ISACX_CIR0);\n\tpr_debug(\"%s: ISACX CIR0 %02X\\n\", isac->name, val);\n\tif (val & ISACX_CIR0_CIC0) {\n\t\tpr_debug(\"%s: ph_state change %x->%x\\n\", isac->name,\n\t\t\t isac->state, val >> 4);\n\t\tisac->state = val >> 4;\n\t\tisac_ph_state_change(isac);\n\t}\n}\n\nstatic void\nisacsx_rme_irq(struct isac_hw *isac)\n{\n\tint count;\n\tu8 val;\n\n\tval = ReadISAC(isac, ISACX_RSTAD);\n\tif ((val & (ISACX_RSTAD_VFR |\n\t\t    ISACX_RSTAD_RDO |\n\t\t    ISACX_RSTAD_CRC |\n\t\t    ISACX_RSTAD_RAB))\n\t    != (ISACX_RSTAD_VFR | ISACX_RSTAD_CRC)) {\n\t\tpr_debug(\"%s: RSTAD %#x, dropped\\n\", isac->name, val);\n#ifdef ERROR_STATISTIC\n\t\tif (val & ISACX_RSTAD_CRC)\n\t\t\tisac->dch.err_rx++;\n\t\telse\n\t\t\tisac->dch.err_crc++;\n#endif\n\t\tWriteISAC(isac, ISACX_CMDRD, ISACX_CMDRD_RMC);\n\t\tdev_kfree_skb(isac->dch.rx_skb);\n\t\tisac->dch.rx_skb = NULL;\n\t} else {\n\t\tcount = ReadISAC(isac, ISACX_RBCLD) & 0x1f;\n\t\tif (count == 0)\n\t\t\tcount = 32;\n\t\tisac_empty_fifo(isac, count);\n\t\tif (isac->dch.rx_skb) {\n\t\t\tskb_trim(isac->dch.rx_skb, isac->dch.rx_skb->len - 1);\n\t\t\tpr_debug(\"%s: dchannel received %d\\n\", isac->name,\n\t\t\t\t isac->dch.rx_skb->len);\n\t\t\trecv_Dchannel(&isac->dch);\n\t\t}\n\t}\n}\n\nirqreturn_t\nmISDNisac_irq(struct isac_hw *isac, u8 val)\n{\n\tif (unlikely(!val))\n\t\treturn IRQ_NONE;\n\tpr_debug(\"%s: ISAC interrupt %02x\\n\", isac->name, val);\n\tif (isac->type & IPAC_TYPE_ISACX) {\n\t\tif (val & ISACX__CIC)\n\t\t\tisacsx_cic_irq(isac);\n\t\tif (val & ISACX__ICD) {\n\t\t\tval = ReadISAC(isac, ISACX_ISTAD);\n\t\t\tpr_debug(\"%s: ISTAD %02x\\n\", isac->name, val);\n\t\t\tif (val & ISACX_D_XDU) {\n\t\t\t\tpr_debug(\"%s: ISAC XDU\\n\", isac->name);\n#ifdef ERROR_STATISTIC\n\t\t\t\tisac->dch.err_tx++;\n#endif\n\t\t\t\tisac_retransmit(isac);\n\t\t\t}\n\t\t\tif (val & ISACX_D_XMR) {\n\t\t\t\tpr_debug(\"%s: ISAC XMR\\n\", isac->name);\n#ifdef ERROR_STATISTIC\n\t\t\t\tisac->dch.err_tx++;\n#endif\n\t\t\t\tisac_retransmit(isac);\n\t\t\t}\n\t\t\tif (val & ISACX_D_XPR)\n\t\t\t\tisac_xpr_irq(isac);\n\t\t\tif (val & ISACX_D_RFO) {\n\t\t\t\tpr_debug(\"%s: ISAC RFO\\n\", isac->name);\n\t\t\t\tWriteISAC(isac, ISACX_CMDRD, ISACX_CMDRD_RMC);\n\t\t\t}\n\t\t\tif (val & ISACX_D_RME)\n\t\t\t\tisacsx_rme_irq(isac);\n\t\t\tif (val & ISACX_D_RPF)\n\t\t\t\tisac_empty_fifo(isac, 0x20);\n\t\t}\n\t} else {\n\t\tif (val & 0x80)\t \n\t\t\tisac_rme_irq(isac);\n\t\tif (val & 0x40)\t \n\t\t\tisac_empty_fifo(isac, 32);\n\t\tif (val & 0x10)\t \n\t\t\tisac_xpr_irq(isac);\n\t\tif (val & 0x04)\t \n\t\t\tisac_cisq_irq(isac);\n\t\tif (val & 0x20)\t \n\t\t\tpr_debug(\"%s: ISAC RSC interrupt\\n\", isac->name);\n\t\tif (val & 0x02)\t \n\t\t\tpr_debug(\"%s: ISAC SIN interrupt\\n\", isac->name);\n\t\tif (val & 0x01) {\t \n\t\t\tval = ReadISAC(isac, ISAC_EXIR);\n\t\t\tpr_debug(\"%s: ISAC EXIR %02x\\n\", isac->name, val);\n\t\t\tif (val & 0x80)\t \n\t\t\t\tpr_debug(\"%s: ISAC XMR\\n\", isac->name);\n\t\t\tif (val & 0x40) {  \n\t\t\t\tpr_debug(\"%s: ISAC XDU\\n\", isac->name);\n#ifdef ERROR_STATISTIC\n\t\t\t\tisac->dch.err_tx++;\n#endif\n\t\t\t\tisac_retransmit(isac);\n\t\t\t}\n\t\t\tif (val & 0x04)\t \n\t\t\t\tisac_mos_irq(isac);\n\t\t}\n\t}\n\treturn IRQ_HANDLED;\n}\nEXPORT_SYMBOL(mISDNisac_irq);\n\nstatic int\nisac_l1hw(struct mISDNchannel *ch, struct sk_buff *skb)\n{\n\tstruct mISDNdevice\t*dev = container_of(ch, struct mISDNdevice, D);\n\tstruct dchannel\t\t*dch = container_of(dev, struct dchannel, dev);\n\tstruct isac_hw\t\t*isac = container_of(dch, struct isac_hw, dch);\n\tint\t\t\tret = -EINVAL;\n\tstruct mISDNhead\t*hh = mISDN_HEAD_P(skb);\n\tu32\t\t\tid;\n\tu_long\t\t\tflags;\n\n\tswitch (hh->prim) {\n\tcase PH_DATA_REQ:\n\t\tspin_lock_irqsave(isac->hwlock, flags);\n\t\tret = dchannel_senddata(dch, skb);\n\t\tif (ret > 0) {  \n\t\t\tid = hh->id;  \n\t\t\tisac_fill_fifo(isac);\n\t\t\tret = 0;\n\t\t\tspin_unlock_irqrestore(isac->hwlock, flags);\n\t\t\tqueue_ch_frame(ch, PH_DATA_CNF, id, NULL);\n\t\t} else\n\t\t\tspin_unlock_irqrestore(isac->hwlock, flags);\n\t\treturn ret;\n\tcase PH_ACTIVATE_REQ:\n\t\tret = l1_event(dch->l1, hh->prim);\n\t\tbreak;\n\tcase PH_DEACTIVATE_REQ:\n\t\ttest_and_clear_bit(FLG_L2_ACTIVATED, &dch->Flags);\n\t\tret = l1_event(dch->l1, hh->prim);\n\t\tbreak;\n\t}\n\n\tif (!ret)\n\t\tdev_kfree_skb(skb);\n\treturn ret;\n}\n\nstatic int\nisac_ctrl(struct isac_hw *isac, u32 cmd, unsigned long para)\n{\n\tu8 tl = 0;\n\tunsigned long flags;\n\tint ret = 0;\n\n\tswitch (cmd) {\n\tcase HW_TESTLOOP:\n\t\tspin_lock_irqsave(isac->hwlock, flags);\n\t\tif (!(isac->type & IPAC_TYPE_ISACX)) {\n\t\t\t \n\t\t\tif (para & 1)  \n\t\t\t\ttl |= 0x0c;\n\t\t\telse if (para & 2)  \n\t\t\t\ttl |= 0x3;\n\t\t\t \n\t\t\tWriteISAC(isac, ISAC_SPCR, tl);\n\t\t\tif (tl)\n\t\t\t\tWriteISAC(isac, ISAC_ADF1, 0x8);\n\t\t\telse\n\t\t\t\tWriteISAC(isac, ISAC_ADF1, 0x0);\n\t\t}\n\t\tspin_unlock_irqrestore(isac->hwlock, flags);\n\t\tbreak;\n\tcase HW_TIMER3_VALUE:\n\t\tret = l1_event(isac->dch.l1, HW_TIMER3_VALUE | (para & 0xff));\n\t\tbreak;\n\tdefault:\n\t\tpr_debug(\"%s: %s unknown command %x %lx\\n\", isac->name,\n\t\t\t __func__, cmd, para);\n\t\tret = -1;\n\t}\n\treturn ret;\n}\n\nstatic int\nisac_l1cmd(struct dchannel *dch, u32 cmd)\n{\n\tstruct isac_hw *isac = container_of(dch, struct isac_hw, dch);\n\tu_long flags;\n\n\tpr_debug(\"%s: cmd(%x) state(%02x)\\n\", isac->name, cmd, isac->state);\n\tswitch (cmd) {\n\tcase INFO3_P8:\n\t\tspin_lock_irqsave(isac->hwlock, flags);\n\t\tph_command(isac, ISAC_CMD_AR8);\n\t\tspin_unlock_irqrestore(isac->hwlock, flags);\n\t\tbreak;\n\tcase INFO3_P10:\n\t\tspin_lock_irqsave(isac->hwlock, flags);\n\t\tph_command(isac, ISAC_CMD_AR10);\n\t\tspin_unlock_irqrestore(isac->hwlock, flags);\n\t\tbreak;\n\tcase HW_RESET_REQ:\n\t\tspin_lock_irqsave(isac->hwlock, flags);\n\t\tif ((isac->state == ISAC_IND_EI) ||\n\t\t    (isac->state == ISAC_IND_DR) ||\n\t\t    (isac->state == ISAC_IND_DR6) ||\n\t\t    (isac->state == ISAC_IND_RS))\n\t\t\tph_command(isac, ISAC_CMD_TIM);\n\t\telse\n\t\t\tph_command(isac, ISAC_CMD_RS);\n\t\tspin_unlock_irqrestore(isac->hwlock, flags);\n\t\tbreak;\n\tcase HW_DEACT_REQ:\n\t\tskb_queue_purge(&dch->squeue);\n\t\tif (dch->tx_skb) {\n\t\t\tdev_kfree_skb(dch->tx_skb);\n\t\t\tdch->tx_skb = NULL;\n\t\t}\n\t\tdch->tx_idx = 0;\n\t\tif (dch->rx_skb) {\n\t\t\tdev_kfree_skb(dch->rx_skb);\n\t\t\tdch->rx_skb = NULL;\n\t\t}\n\t\ttest_and_clear_bit(FLG_TX_BUSY, &dch->Flags);\n\t\tif (test_and_clear_bit(FLG_BUSY_TIMER, &dch->Flags))\n\t\t\tdel_timer(&dch->timer);\n\t\tbreak;\n\tcase HW_POWERUP_REQ:\n\t\tspin_lock_irqsave(isac->hwlock, flags);\n\t\tph_command(isac, ISAC_CMD_TIM);\n\t\tspin_unlock_irqrestore(isac->hwlock, flags);\n\t\tbreak;\n\tcase PH_ACTIVATE_IND:\n\t\ttest_and_set_bit(FLG_ACTIVE, &dch->Flags);\n\t\t_queue_data(&dch->dev.D, cmd, MISDN_ID_ANY, 0, NULL,\n\t\t\t    GFP_ATOMIC);\n\t\tbreak;\n\tcase PH_DEACTIVATE_IND:\n\t\ttest_and_clear_bit(FLG_ACTIVE, &dch->Flags);\n\t\t_queue_data(&dch->dev.D, cmd, MISDN_ID_ANY, 0, NULL,\n\t\t\t    GFP_ATOMIC);\n\t\tbreak;\n\tdefault:\n\t\tpr_debug(\"%s: %s unknown command %x\\n\", isac->name,\n\t\t\t __func__, cmd);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic void\nisac_release(struct isac_hw *isac)\n{\n\tif (isac->type & IPAC_TYPE_ISACX)\n\t\tWriteISAC(isac, ISACX_MASK, 0xff);\n\telse if (isac->type != 0)\n\t\tWriteISAC(isac, ISAC_MASK, 0xff);\n\tif (isac->dch.timer.function != NULL) {\n\t\tdel_timer(&isac->dch.timer);\n\t\tisac->dch.timer.function = NULL;\n\t}\n\tkfree(isac->mon_rx);\n\tisac->mon_rx = NULL;\n\tkfree(isac->mon_tx);\n\tisac->mon_tx = NULL;\n\tif (isac->dch.l1)\n\t\tl1_event(isac->dch.l1, CLOSE_CHANNEL);\n\tmISDN_freedchannel(&isac->dch);\n}\n\nstatic void\ndbusy_timer_handler(struct timer_list *t)\n{\n\tstruct isac_hw *isac = from_timer(isac, t, dch.timer);\n\tint rbch, star;\n\tu_long flags;\n\n\tif (test_bit(FLG_BUSY_TIMER, &isac->dch.Flags)) {\n\t\tspin_lock_irqsave(isac->hwlock, flags);\n\t\trbch = ReadISAC(isac, ISAC_RBCH);\n\t\tstar = ReadISAC(isac, ISAC_STAR);\n\t\tpr_debug(\"%s: D-Channel Busy RBCH %02x STAR %02x\\n\",\n\t\t\t isac->name, rbch, star);\n\t\tif (rbch & ISAC_RBCH_XAC)  \n\t\t\ttest_and_set_bit(FLG_L1_BUSY, &isac->dch.Flags);\n\t\telse {\n\t\t\t \n\t\t\ttest_and_clear_bit(FLG_BUSY_TIMER, &isac->dch.Flags);\n\t\t\tif (isac->dch.tx_idx)\n\t\t\t\tisac->dch.tx_idx = 0;\n\t\t\telse\n\t\t\t\tpr_info(\"%s: ISAC D-Channel Busy no tx_idx\\n\",\n\t\t\t\t\tisac->name);\n\t\t\t \n\t\t\tWriteISAC(isac, ISAC_CMDR, 0x01);\n\t\t}\n\t\tspin_unlock_irqrestore(isac->hwlock, flags);\n\t}\n}\n\nstatic int\nopen_dchannel_caller(struct isac_hw *isac, struct channel_req *rq, void *caller)\n{\n\tpr_debug(\"%s: %s dev(%d) open from %p\\n\", isac->name, __func__,\n\t\t isac->dch.dev.id, caller);\n\tif (rq->protocol != ISDN_P_TE_S0)\n\t\treturn -EINVAL;\n\tif (rq->adr.channel == 1)\n\t\t \n\t\treturn -EINVAL;\n\trq->ch = &isac->dch.dev.D;\n\trq->ch->protocol = rq->protocol;\n\tif (isac->dch.state == 7)\n\t\t_queue_data(rq->ch, PH_ACTIVATE_IND, MISDN_ID_ANY,\n\t\t\t    0, NULL, GFP_KERNEL);\n\treturn 0;\n}\n\nstatic int\nopen_dchannel(struct isac_hw *isac, struct channel_req *rq)\n{\n\treturn open_dchannel_caller(isac, rq, __builtin_return_address(0));\n}\n\nstatic const char *ISACVer[] =\n{\"2086/2186 V1.1\", \"2085 B1\", \"2085 B2\",\n \"2085 V2.3\"};\n\nstatic int\nisac_init(struct isac_hw *isac)\n{\n\tu8 val;\n\tint err = 0;\n\n\tif (!isac->dch.l1) {\n\t\terr = create_l1(&isac->dch, isac_l1cmd);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tisac->mon_tx = NULL;\n\tisac->mon_rx = NULL;\n\ttimer_setup(&isac->dch.timer, dbusy_timer_handler, 0);\n\tisac->mocr = 0xaa;\n\tif (isac->type & IPAC_TYPE_ISACX) {\n\t\t \n\t\tWriteISAC(isac, ISACX_MASK, 0xff);\n\t\tval = ReadISAC(isac, ISACX_STARD);\n\t\tpr_debug(\"%s: ISACX STARD %x\\n\", isac->name, val);\n\t\tval = ReadISAC(isac, ISACX_ISTAD);\n\t\tpr_debug(\"%s: ISACX ISTAD %x\\n\", isac->name, val);\n\t\tval = ReadISAC(isac, ISACX_ISTA);\n\t\tpr_debug(\"%s: ISACX ISTA %x\\n\", isac->name, val);\n\t\t \n\t\tWriteISAC(isac, ISACX_TR_CONF0, 0x00);\n\t\t \n\t\tWriteISAC(isac, ISACX_TR_CONF2, 0x00);\n\t\t \n\t\tWriteISAC(isac, ISACX_MODED, 0xc9);\n\t\t \n\t\tval = ReadISAC(isac, ISACX_ID);\n\t\tif (isac->dch.debug & DEBUG_HW)\n\t\t\tpr_notice(\"%s: ISACX Design ID %x\\n\",\n\t\t\t\t  isac->name, val & 0x3f);\n\t\tval = ReadISAC(isac, ISACX_CIR0);\n\t\tpr_debug(\"%s: ISACX CIR0 %02X\\n\", isac->name, val);\n\t\tisac->state = val >> 4;\n\t\tisac_ph_state_change(isac);\n\t\tph_command(isac, ISAC_CMD_RS);\n\t\tWriteISAC(isac, ISACX_MASK, IPACX__ON);\n\t\tWriteISAC(isac, ISACX_MASKD, 0x00);\n\t} else {  \n\t\tWriteISAC(isac, ISAC_MASK, 0xff);\n\t\tval = ReadISAC(isac, ISAC_STAR);\n\t\tpr_debug(\"%s: ISAC STAR %x\\n\", isac->name, val);\n\t\tval = ReadISAC(isac, ISAC_MODE);\n\t\tpr_debug(\"%s: ISAC MODE %x\\n\", isac->name, val);\n\t\tval = ReadISAC(isac, ISAC_ADF2);\n\t\tpr_debug(\"%s: ISAC ADF2 %x\\n\", isac->name, val);\n\t\tval = ReadISAC(isac, ISAC_ISTA);\n\t\tpr_debug(\"%s: ISAC ISTA %x\\n\", isac->name, val);\n\t\tif (val & 0x01) {\n\t\t\tval = ReadISAC(isac, ISAC_EXIR);\n\t\t\tpr_debug(\"%s: ISAC EXIR %x\\n\", isac->name, val);\n\t\t}\n\t\tval = ReadISAC(isac, ISAC_RBCH);\n\t\tif (isac->dch.debug & DEBUG_HW)\n\t\t\tpr_notice(\"%s: ISAC version (%x): %s\\n\", isac->name,\n\t\t\t\t  val, ISACVer[(val >> 5) & 3]);\n\t\tisac->type |= ((val >> 5) & 3);\n\t\tif (!isac->adf2)\n\t\t\tisac->adf2 = 0x80;\n\t\tif (!(isac->adf2 & 0x80)) {  \n\t\t\tpr_info(\"%s: only support IOM2 mode but adf2=%02x\\n\",\n\t\t\t\tisac->name, isac->adf2);\n\t\t\tisac_release(isac);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tWriteISAC(isac, ISAC_ADF2, isac->adf2);\n\t\tWriteISAC(isac, ISAC_SQXR, 0x2f);\n\t\tWriteISAC(isac, ISAC_SPCR, 0x00);\n\t\tWriteISAC(isac, ISAC_STCR, 0x70);\n\t\tWriteISAC(isac, ISAC_MODE, 0xc9);\n\t\tWriteISAC(isac, ISAC_TIMR, 0x00);\n\t\tWriteISAC(isac, ISAC_ADF1, 0x00);\n\t\tval = ReadISAC(isac, ISAC_CIR0);\n\t\tpr_debug(\"%s: ISAC CIR0 %x\\n\", isac->name, val);\n\t\tisac->state = (val >> 2) & 0xf;\n\t\tisac_ph_state_change(isac);\n\t\tph_command(isac, ISAC_CMD_RS);\n\t\tWriteISAC(isac, ISAC_MASK, 0);\n\t}\n\treturn err;\n}\n\nint\nmISDNisac_init(struct isac_hw *isac, void *hw)\n{\n\tmISDN_initdchannel(&isac->dch, MAX_DFRAME_LEN_L1, isac_ph_state_bh);\n\tisac->dch.hw = hw;\n\tisac->dch.dev.D.send = isac_l1hw;\n\tisac->init = isac_init;\n\tisac->release = isac_release;\n\tisac->ctrl = isac_ctrl;\n\tisac->open = open_dchannel;\n\tisac->dch.dev.Dprotocols = (1 << ISDN_P_TE_S0);\n\tisac->dch.dev.nrbchan = 2;\n\treturn 0;\n}\nEXPORT_SYMBOL(mISDNisac_init);\n\nstatic void\nwaitforCEC(struct hscx_hw *hx)\n{\n\tu8 starb, to = 50;\n\n\twhile (to) {\n\t\tstarb = ReadHSCX(hx, IPAC_STARB);\n\t\tif (!(starb & 0x04))\n\t\t\tbreak;\n\t\tudelay(1);\n\t\tto--;\n\t}\n\tif (to < 50)\n\t\tpr_debug(\"%s: B%1d CEC %d us\\n\", hx->ip->name, hx->bch.nr,\n\t\t\t 50 - to);\n\tif (!to)\n\t\tpr_info(\"%s: B%1d CEC timeout\\n\", hx->ip->name, hx->bch.nr);\n}\n\n\nstatic void\nwaitforXFW(struct hscx_hw *hx)\n{\n\tu8 starb, to = 50;\n\n\twhile (to) {\n\t\tstarb = ReadHSCX(hx, IPAC_STARB);\n\t\tif ((starb & 0x44) == 0x40)\n\t\t\tbreak;\n\t\tudelay(1);\n\t\tto--;\n\t}\n\tif (to < 50)\n\t\tpr_debug(\"%s: B%1d XFW %d us\\n\", hx->ip->name, hx->bch.nr,\n\t\t\t 50 - to);\n\tif (!to)\n\t\tpr_info(\"%s: B%1d XFW timeout\\n\", hx->ip->name, hx->bch.nr);\n}\n\nstatic void\nhscx_cmdr(struct hscx_hw *hx, u8 cmd)\n{\n\tif (hx->ip->type & IPAC_TYPE_IPACX)\n\t\tWriteHSCX(hx, IPACX_CMDRB, cmd);\n\telse {\n\t\twaitforCEC(hx);\n\t\tWriteHSCX(hx, IPAC_CMDRB, cmd);\n\t}\n}\n\nstatic void\nhscx_empty_fifo(struct hscx_hw *hscx, u8 count)\n{\n\tu8 *p;\n\tint maxlen;\n\n\tpr_debug(\"%s: B%1d %d\\n\", hscx->ip->name, hscx->bch.nr, count);\n\tif (test_bit(FLG_RX_OFF, &hscx->bch.Flags)) {\n\t\thscx->bch.dropcnt += count;\n\t\thscx_cmdr(hscx, 0x80);  \n\t\treturn;\n\t}\n\tmaxlen = bchannel_get_rxbuf(&hscx->bch, count);\n\tif (maxlen < 0) {\n\t\thscx_cmdr(hscx, 0x80);  \n\t\tif (hscx->bch.rx_skb)\n\t\t\tskb_trim(hscx->bch.rx_skb, 0);\n\t\tpr_warn(\"%s.B%d: No bufferspace for %d bytes\\n\",\n\t\t\thscx->ip->name, hscx->bch.nr, count);\n\t\treturn;\n\t}\n\tp = skb_put(hscx->bch.rx_skb, count);\n\n\tif (hscx->ip->type & IPAC_TYPE_IPACX)\n\t\thscx->ip->read_fifo(hscx->ip->hw,\n\t\t\t\t    hscx->off + IPACX_RFIFOB, p, count);\n\telse\n\t\thscx->ip->read_fifo(hscx->ip->hw,\n\t\t\t\t    hscx->off, p, count);\n\n\thscx_cmdr(hscx, 0x80);  \n\n\tif (hscx->bch.debug & DEBUG_HW_BFIFO) {\n\t\tsnprintf(hscx->log, 64, \"B%1d-recv %s %d \",\n\t\t\t hscx->bch.nr, hscx->ip->name, count);\n\t\tprint_hex_dump_bytes(hscx->log, DUMP_PREFIX_OFFSET, p, count);\n\t}\n}\n\nstatic void\nhscx_fill_fifo(struct hscx_hw *hscx)\n{\n\tint count, more;\n\tu8 *p;\n\n\tif (!hscx->bch.tx_skb) {\n\t\tif (!test_bit(FLG_TX_EMPTY, &hscx->bch.Flags))\n\t\t\treturn;\n\t\tcount = hscx->fifo_size;\n\t\tmore = 1;\n\t\tp = hscx->log;\n\t\tmemset(p, hscx->bch.fill[0], count);\n\t} else {\n\t\tcount = hscx->bch.tx_skb->len - hscx->bch.tx_idx;\n\t\tif (count <= 0)\n\t\t\treturn;\n\t\tp = hscx->bch.tx_skb->data + hscx->bch.tx_idx;\n\n\t\tmore = test_bit(FLG_TRANSPARENT, &hscx->bch.Flags) ? 1 : 0;\n\t\tif (count > hscx->fifo_size) {\n\t\t\tcount = hscx->fifo_size;\n\t\t\tmore = 1;\n\t\t}\n\t\tpr_debug(\"%s: B%1d %d/%d/%d\\n\", hscx->ip->name, hscx->bch.nr,\n\t\t\t count, hscx->bch.tx_idx, hscx->bch.tx_skb->len);\n\t\thscx->bch.tx_idx += count;\n\t}\n\tif (hscx->ip->type & IPAC_TYPE_IPACX)\n\t\thscx->ip->write_fifo(hscx->ip->hw,\n\t\t\t\t     hscx->off + IPACX_XFIFOB, p, count);\n\telse {\n\t\twaitforXFW(hscx);\n\t\thscx->ip->write_fifo(hscx->ip->hw,\n\t\t\t\t     hscx->off, p, count);\n\t}\n\thscx_cmdr(hscx, more ? 0x08 : 0x0a);\n\n\tif (hscx->bch.tx_skb && (hscx->bch.debug & DEBUG_HW_BFIFO)) {\n\t\tsnprintf(hscx->log, 64, \"B%1d-send %s %d \",\n\t\t\t hscx->bch.nr, hscx->ip->name, count);\n\t\tprint_hex_dump_bytes(hscx->log, DUMP_PREFIX_OFFSET, p, count);\n\t}\n}\n\nstatic void\nhscx_xpr(struct hscx_hw *hx)\n{\n\tif (hx->bch.tx_skb && hx->bch.tx_idx < hx->bch.tx_skb->len) {\n\t\thscx_fill_fifo(hx);\n\t} else {\n\t\tdev_kfree_skb(hx->bch.tx_skb);\n\t\tif (get_next_bframe(&hx->bch)) {\n\t\t\thscx_fill_fifo(hx);\n\t\t\ttest_and_clear_bit(FLG_TX_EMPTY, &hx->bch.Flags);\n\t\t} else if (test_bit(FLG_TX_EMPTY, &hx->bch.Flags)) {\n\t\t\thscx_fill_fifo(hx);\n\t\t}\n\t}\n}\n\nstatic void\nipac_rme(struct hscx_hw *hx)\n{\n\tint count;\n\tu8 rstab;\n\n\tif (hx->ip->type & IPAC_TYPE_IPACX)\n\t\trstab = ReadHSCX(hx, IPACX_RSTAB);\n\telse\n\t\trstab = ReadHSCX(hx, IPAC_RSTAB);\n\tpr_debug(\"%s: B%1d RSTAB %02x\\n\", hx->ip->name, hx->bch.nr, rstab);\n\tif ((rstab & 0xf0) != 0xa0) {\n\t\t \n\t\tif (!(rstab & 0x80)) {\n\t\t\tif (hx->bch.debug & DEBUG_HW_BCHANNEL)\n\t\t\t\tpr_notice(\"%s: B%1d invalid frame\\n\",\n\t\t\t\t\t  hx->ip->name, hx->bch.nr);\n\t\t}\n\t\tif (rstab & 0x40) {\n\t\t\tif (hx->bch.debug & DEBUG_HW_BCHANNEL)\n\t\t\t\tpr_notice(\"%s: B%1d RDO proto=%x\\n\",\n\t\t\t\t\t  hx->ip->name, hx->bch.nr,\n\t\t\t\t\t  hx->bch.state);\n\t\t}\n\t\tif (!(rstab & 0x20)) {\n\t\t\tif (hx->bch.debug & DEBUG_HW_BCHANNEL)\n\t\t\t\tpr_notice(\"%s: B%1d CRC error\\n\",\n\t\t\t\t\t  hx->ip->name, hx->bch.nr);\n\t\t}\n\t\thscx_cmdr(hx, 0x80);  \n\t\treturn;\n\t}\n\tif (hx->ip->type & IPAC_TYPE_IPACX)\n\t\tcount = ReadHSCX(hx, IPACX_RBCLB);\n\telse\n\t\tcount = ReadHSCX(hx, IPAC_RBCLB);\n\tcount &= (hx->fifo_size - 1);\n\tif (count == 0)\n\t\tcount = hx->fifo_size;\n\thscx_empty_fifo(hx, count);\n\tif (!hx->bch.rx_skb)\n\t\treturn;\n\tif (hx->bch.rx_skb->len < 2) {\n\t\tpr_debug(\"%s: B%1d frame too short %d\\n\",\n\t\t\t hx->ip->name, hx->bch.nr, hx->bch.rx_skb->len);\n\t\tskb_trim(hx->bch.rx_skb, 0);\n\t} else {\n\t\tskb_trim(hx->bch.rx_skb, hx->bch.rx_skb->len - 1);\n\t\trecv_Bchannel(&hx->bch, 0, false);\n\t}\n}\n\nstatic void\nipac_irq(struct hscx_hw *hx, u8 ista)\n{\n\tu8 istab, m, exirb = 0;\n\n\tif (hx->ip->type & IPAC_TYPE_IPACX)\n\t\tistab = ReadHSCX(hx, IPACX_ISTAB);\n\telse if (hx->ip->type & IPAC_TYPE_IPAC) {\n\t\tistab = ReadHSCX(hx, IPAC_ISTAB);\n\t\tm = (hx->bch.nr & 1) ? IPAC__EXA : IPAC__EXB;\n\t\tif (m & ista) {\n\t\t\texirb = ReadHSCX(hx, IPAC_EXIRB);\n\t\t\tpr_debug(\"%s: B%1d EXIRB %02x\\n\", hx->ip->name,\n\t\t\t\t hx->bch.nr, exirb);\n\t\t}\n\t} else if (hx->bch.nr & 2) {  \n\t\tif (ista & (HSCX__EXA | HSCX__ICA))\n\t\t\tipac_irq(&hx->ip->hscx[0], ista);\n\t\tif (ista & HSCX__EXB) {\n\t\t\texirb = ReadHSCX(hx, IPAC_EXIRB);\n\t\t\tpr_debug(\"%s: B%1d EXIRB %02x\\n\", hx->ip->name,\n\t\t\t\t hx->bch.nr, exirb);\n\t\t}\n\t\tistab = ista & 0xF8;\n\t} else {  \n\t\tistab = ReadHSCX(hx, IPAC_ISTAB);\n\t\tif (ista & HSCX__EXA) {\n\t\t\texirb = ReadHSCX(hx, IPAC_EXIRB);\n\t\t\tpr_debug(\"%s: B%1d EXIRB %02x\\n\", hx->ip->name,\n\t\t\t\t hx->bch.nr, exirb);\n\t\t}\n\t\tistab = istab & 0xF8;\n\t}\n\tif (exirb & IPAC_B_XDU)\n\t\tistab |= IPACX_B_XDU;\n\tif (exirb & IPAC_B_RFO)\n\t\tistab |= IPACX_B_RFO;\n\tpr_debug(\"%s: B%1d ISTAB %02x\\n\", hx->ip->name, hx->bch.nr, istab);\n\n\tif (!test_bit(FLG_ACTIVE, &hx->bch.Flags))\n\t\treturn;\n\n\tif (istab & IPACX_B_RME)\n\t\tipac_rme(hx);\n\n\tif (istab & IPACX_B_RPF) {\n\t\thscx_empty_fifo(hx, hx->fifo_size);\n\t\tif (test_bit(FLG_TRANSPARENT, &hx->bch.Flags))\n\t\t\trecv_Bchannel(&hx->bch, 0, false);\n\t}\n\n\tif (istab & IPACX_B_RFO) {\n\t\tpr_debug(\"%s: B%1d RFO error\\n\", hx->ip->name, hx->bch.nr);\n\t\thscx_cmdr(hx, 0x40);\t \n\t}\n\n\tif (istab & IPACX_B_XPR)\n\t\thscx_xpr(hx);\n\n\tif (istab & IPACX_B_XDU) {\n\t\tif (test_bit(FLG_TRANSPARENT, &hx->bch.Flags)) {\n\t\t\tif (test_bit(FLG_FILLEMPTY, &hx->bch.Flags))\n\t\t\t\ttest_and_set_bit(FLG_TX_EMPTY, &hx->bch.Flags);\n\t\t\thscx_xpr(hx);\n\t\t\treturn;\n\t\t}\n\t\tpr_debug(\"%s: B%1d XDU error at len %d\\n\", hx->ip->name,\n\t\t\t hx->bch.nr, hx->bch.tx_idx);\n\t\thx->bch.tx_idx = 0;\n\t\thscx_cmdr(hx, 0x01);\t \n\t}\n}\n\nirqreturn_t\nmISDNipac_irq(struct ipac_hw *ipac, int maxloop)\n{\n\tint cnt = maxloop + 1;\n\tu8 ista, istad;\n\tstruct isac_hw  *isac = &ipac->isac;\n\n\tif (ipac->type & IPAC_TYPE_IPACX) {\n\t\tista = ReadIPAC(ipac, ISACX_ISTA);\n\t\twhile (ista && --cnt) {\n\t\t\tpr_debug(\"%s: ISTA %02x\\n\", ipac->name, ista);\n\t\t\tif (ista & IPACX__ICA)\n\t\t\t\tipac_irq(&ipac->hscx[0], ista);\n\t\t\tif (ista & IPACX__ICB)\n\t\t\t\tipac_irq(&ipac->hscx[1], ista);\n\t\t\tif (ista & (ISACX__ICD | ISACX__CIC))\n\t\t\t\tmISDNisac_irq(&ipac->isac, ista);\n\t\t\tista = ReadIPAC(ipac, ISACX_ISTA);\n\t\t}\n\t} else if (ipac->type & IPAC_TYPE_IPAC) {\n\t\tista = ReadIPAC(ipac, IPAC_ISTA);\n\t\twhile (ista && --cnt) {\n\t\t\tpr_debug(\"%s: ISTA %02x\\n\", ipac->name, ista);\n\t\t\tif (ista & (IPAC__ICD | IPAC__EXD)) {\n\t\t\t\tistad = ReadISAC(isac, ISAC_ISTA);\n\t\t\t\tpr_debug(\"%s: ISTAD %02x\\n\", ipac->name, istad);\n\t\t\t\tif (istad & IPAC_D_TIN2)\n\t\t\t\t\tpr_debug(\"%s TIN2 irq\\n\", ipac->name);\n\t\t\t\tif (ista & IPAC__EXD)\n\t\t\t\t\tistad |= 1;  \n\t\t\t\tmISDNisac_irq(isac, istad);\n\t\t\t}\n\t\t\tif (ista & (IPAC__ICA | IPAC__EXA))\n\t\t\t\tipac_irq(&ipac->hscx[0], ista);\n\t\t\tif (ista & (IPAC__ICB | IPAC__EXB))\n\t\t\t\tipac_irq(&ipac->hscx[1], ista);\n\t\t\tista = ReadIPAC(ipac, IPAC_ISTA);\n\t\t}\n\t} else if (ipac->type & IPAC_TYPE_HSCX) {\n\t\twhile (--cnt) {\n\t\t\tista = ReadIPAC(ipac, IPAC_ISTAB + ipac->hscx[1].off);\n\t\t\tpr_debug(\"%s: B2 ISTA %02x\\n\", ipac->name, ista);\n\t\t\tif (ista)\n\t\t\t\tipac_irq(&ipac->hscx[1], ista);\n\t\t\tistad = ReadISAC(isac, ISAC_ISTA);\n\t\t\tpr_debug(\"%s: ISTAD %02x\\n\", ipac->name, istad);\n\t\t\tif (istad)\n\t\t\t\tmISDNisac_irq(isac, istad);\n\t\t\tif (0 == (ista | istad))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tif (cnt > maxloop)  \n\t\treturn IRQ_NONE;\n\tif (cnt < maxloop)\n\t\tpr_debug(\"%s: %d irqloops cpu%d\\n\", ipac->name,\n\t\t\t maxloop - cnt, smp_processor_id());\n\tif (maxloop && !cnt)\n\t\tpr_notice(\"%s: %d IRQ LOOP cpu%d\\n\", ipac->name,\n\t\t\t  maxloop, smp_processor_id());\n\treturn IRQ_HANDLED;\n}\nEXPORT_SYMBOL(mISDNipac_irq);\n\nstatic int\nhscx_mode(struct hscx_hw *hscx, u32 bprotocol)\n{\n\tpr_debug(\"%s: HSCX %c protocol %x-->%x ch %d\\n\", hscx->ip->name,\n\t\t '@' + hscx->bch.nr, hscx->bch.state, bprotocol, hscx->bch.nr);\n\tif (hscx->ip->type & IPAC_TYPE_IPACX) {\n\t\tif (hscx->bch.nr & 1) {  \n\t\t\tWriteIPAC(hscx->ip, ISACX_BCHA_TSDP_BC1, 0x80);\n\t\t\tWriteIPAC(hscx->ip, ISACX_BCHA_CR, 0x88);\n\t\t} else {  \n\t\t\tWriteIPAC(hscx->ip, ISACX_BCHB_TSDP_BC1, 0x81);\n\t\t\tWriteIPAC(hscx->ip, ISACX_BCHB_CR, 0x88);\n\t\t}\n\t\tswitch (bprotocol) {\n\t\tcase ISDN_P_NONE:  \n\t\t\tWriteHSCX(hscx, IPACX_MODEB, 0xC0);\t \n\t\t\tWriteHSCX(hscx, IPACX_EXMB,  0x30);\t \n\t\t\tWriteHSCX(hscx, IPACX_MASKB, 0xFF);\t \n\t\t\thscx_cmdr(hscx, 0x41);\n\t\t\ttest_and_clear_bit(FLG_HDLC, &hscx->bch.Flags);\n\t\t\ttest_and_clear_bit(FLG_TRANSPARENT, &hscx->bch.Flags);\n\t\t\tbreak;\n\t\tcase ISDN_P_B_RAW:\n\t\t\tWriteHSCX(hscx, IPACX_MODEB, 0x88);\t \n\t\t\tWriteHSCX(hscx, IPACX_EXMB,  0x00);\t \n\t\t\thscx_cmdr(hscx, 0x41);\n\t\t\tWriteHSCX(hscx, IPACX_MASKB, IPACX_B_ON);\n\t\t\ttest_and_set_bit(FLG_TRANSPARENT, &hscx->bch.Flags);\n\t\t\tbreak;\n\t\tcase ISDN_P_B_HDLC:\n\t\t\tWriteHSCX(hscx, IPACX_MODEB, 0xC0);\t \n\t\t\tWriteHSCX(hscx, IPACX_EXMB,  0x00);\t \n\t\t\thscx_cmdr(hscx, 0x41);\n\t\t\tWriteHSCX(hscx, IPACX_MASKB, IPACX_B_ON);\n\t\t\ttest_and_set_bit(FLG_HDLC, &hscx->bch.Flags);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_info(\"%s: protocol not known %x\\n\", hscx->ip->name,\n\t\t\t\tbprotocol);\n\t\t\treturn -ENOPROTOOPT;\n\t\t}\n\t} else if (hscx->ip->type & IPAC_TYPE_IPAC) {  \n\t\tWriteHSCX(hscx, IPAC_CCR1, 0x82);\n\t\tWriteHSCX(hscx, IPAC_CCR2, 0x30);\n\t\tWriteHSCX(hscx, IPAC_XCCR, 0x07);\n\t\tWriteHSCX(hscx, IPAC_RCCR, 0x07);\n\t\tWriteHSCX(hscx, IPAC_TSAX, hscx->slot);\n\t\tWriteHSCX(hscx, IPAC_TSAR, hscx->slot);\n\t\tswitch (bprotocol) {\n\t\tcase ISDN_P_NONE:\n\t\t\tWriteHSCX(hscx, IPAC_TSAX, 0x1F);\n\t\t\tWriteHSCX(hscx, IPAC_TSAR, 0x1F);\n\t\t\tWriteHSCX(hscx, IPAC_MODEB, 0x84);\n\t\t\tWriteHSCX(hscx, IPAC_CCR1, 0x82);\n\t\t\tWriteHSCX(hscx, IPAC_MASKB, 0xFF);\t \n\t\t\ttest_and_clear_bit(FLG_HDLC, &hscx->bch.Flags);\n\t\t\ttest_and_clear_bit(FLG_TRANSPARENT, &hscx->bch.Flags);\n\t\t\tbreak;\n\t\tcase ISDN_P_B_RAW:\n\t\t\tWriteHSCX(hscx, IPAC_MODEB, 0xe4);\t \n\t\t\tWriteHSCX(hscx, IPAC_CCR1, 0x82);\n\t\t\thscx_cmdr(hscx, 0x41);\n\t\t\tWriteHSCX(hscx, IPAC_MASKB, 0);\n\t\t\ttest_and_set_bit(FLG_TRANSPARENT, &hscx->bch.Flags);\n\t\t\tbreak;\n\t\tcase ISDN_P_B_HDLC:\n\t\t\tWriteHSCX(hscx, IPAC_MODEB, 0x8c);\n\t\t\tWriteHSCX(hscx, IPAC_CCR1, 0x8a);\n\t\t\thscx_cmdr(hscx, 0x41);\n\t\t\tWriteHSCX(hscx, IPAC_MASKB, 0);\n\t\t\ttest_and_set_bit(FLG_HDLC, &hscx->bch.Flags);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_info(\"%s: protocol not known %x\\n\", hscx->ip->name,\n\t\t\t\tbprotocol);\n\t\t\treturn -ENOPROTOOPT;\n\t\t}\n\t} else if (hscx->ip->type & IPAC_TYPE_HSCX) {  \n\t\tWriteHSCX(hscx, IPAC_CCR1, 0x85);\n\t\tWriteHSCX(hscx, IPAC_CCR2, 0x30);\n\t\tWriteHSCX(hscx, IPAC_XCCR, 0x07);\n\t\tWriteHSCX(hscx, IPAC_RCCR, 0x07);\n\t\tWriteHSCX(hscx, IPAC_TSAX, hscx->slot);\n\t\tWriteHSCX(hscx, IPAC_TSAR, hscx->slot);\n\t\tswitch (bprotocol) {\n\t\tcase ISDN_P_NONE:\n\t\t\tWriteHSCX(hscx, IPAC_TSAX, 0x1F);\n\t\t\tWriteHSCX(hscx, IPAC_TSAR, 0x1F);\n\t\t\tWriteHSCX(hscx, IPAC_MODEB, 0x84);\n\t\t\tWriteHSCX(hscx, IPAC_CCR1, 0x85);\n\t\t\tWriteHSCX(hscx, IPAC_MASKB, 0xFF);\t \n\t\t\ttest_and_clear_bit(FLG_HDLC, &hscx->bch.Flags);\n\t\t\ttest_and_clear_bit(FLG_TRANSPARENT, &hscx->bch.Flags);\n\t\t\tbreak;\n\t\tcase ISDN_P_B_RAW:\n\t\t\tWriteHSCX(hscx, IPAC_MODEB, 0xe4);\t \n\t\t\tWriteHSCX(hscx, IPAC_CCR1, 0x85);\n\t\t\thscx_cmdr(hscx, 0x41);\n\t\t\tWriteHSCX(hscx, IPAC_MASKB, 0);\n\t\t\ttest_and_set_bit(FLG_TRANSPARENT, &hscx->bch.Flags);\n\t\t\tbreak;\n\t\tcase ISDN_P_B_HDLC:\n\t\t\tWriteHSCX(hscx, IPAC_MODEB, 0x8c);\n\t\t\tWriteHSCX(hscx, IPAC_CCR1, 0x8d);\n\t\t\thscx_cmdr(hscx, 0x41);\n\t\t\tWriteHSCX(hscx, IPAC_MASKB, 0);\n\t\t\ttest_and_set_bit(FLG_HDLC, &hscx->bch.Flags);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_info(\"%s: protocol not known %x\\n\", hscx->ip->name,\n\t\t\t\tbprotocol);\n\t\t\treturn -ENOPROTOOPT;\n\t\t}\n\t} else\n\t\treturn -EINVAL;\n\thscx->bch.state = bprotocol;\n\treturn 0;\n}\n\nstatic int\nhscx_l2l1(struct mISDNchannel *ch, struct sk_buff *skb)\n{\n\tstruct bchannel *bch = container_of(ch, struct bchannel, ch);\n\tstruct hscx_hw\t*hx = container_of(bch, struct hscx_hw, bch);\n\tint ret = -EINVAL;\n\tstruct mISDNhead *hh = mISDN_HEAD_P(skb);\n\tunsigned long flags;\n\n\tswitch (hh->prim) {\n\tcase PH_DATA_REQ:\n\t\tspin_lock_irqsave(hx->ip->hwlock, flags);\n\t\tret = bchannel_senddata(bch, skb);\n\t\tif (ret > 0) {  \n\t\t\tret = 0;\n\t\t\thscx_fill_fifo(hx);\n\t\t}\n\t\tspin_unlock_irqrestore(hx->ip->hwlock, flags);\n\t\treturn ret;\n\tcase PH_ACTIVATE_REQ:\n\t\tspin_lock_irqsave(hx->ip->hwlock, flags);\n\t\tif (!test_and_set_bit(FLG_ACTIVE, &bch->Flags))\n\t\t\tret = hscx_mode(hx, ch->protocol);\n\t\telse\n\t\t\tret = 0;\n\t\tspin_unlock_irqrestore(hx->ip->hwlock, flags);\n\t\tif (!ret)\n\t\t\t_queue_data(ch, PH_ACTIVATE_IND, MISDN_ID_ANY, 0,\n\t\t\t\t    NULL, GFP_KERNEL);\n\t\tbreak;\n\tcase PH_DEACTIVATE_REQ:\n\t\tspin_lock_irqsave(hx->ip->hwlock, flags);\n\t\tmISDN_clear_bchannel(bch);\n\t\thscx_mode(hx, ISDN_P_NONE);\n\t\tspin_unlock_irqrestore(hx->ip->hwlock, flags);\n\t\t_queue_data(ch, PH_DEACTIVATE_IND, MISDN_ID_ANY, 0,\n\t\t\t    NULL, GFP_KERNEL);\n\t\tret = 0;\n\t\tbreak;\n\tdefault:\n\t\tpr_info(\"%s: %s unknown prim(%x,%x)\\n\",\n\t\t\thx->ip->name, __func__, hh->prim, hh->id);\n\t\tret = -EINVAL;\n\t}\n\tif (!ret)\n\t\tdev_kfree_skb(skb);\n\treturn ret;\n}\n\nstatic int\nchannel_bctrl(struct bchannel *bch, struct mISDN_ctrl_req *cq)\n{\n\treturn mISDN_ctrl_bchannel(bch, cq);\n}\n\nstatic int\nhscx_bctrl(struct mISDNchannel *ch, u32 cmd, void *arg)\n{\n\tstruct bchannel *bch = container_of(ch, struct bchannel, ch);\n\tstruct hscx_hw\t*hx = container_of(bch, struct hscx_hw, bch);\n\tint ret = -EINVAL;\n\tu_long flags;\n\n\tpr_debug(\"%s: %s cmd:%x %p\\n\", hx->ip->name, __func__, cmd, arg);\n\tswitch (cmd) {\n\tcase CLOSE_CHANNEL:\n\t\ttest_and_clear_bit(FLG_OPEN, &bch->Flags);\n\t\tcancel_work_sync(&bch->workq);\n\t\tspin_lock_irqsave(hx->ip->hwlock, flags);\n\t\tmISDN_clear_bchannel(bch);\n\t\thscx_mode(hx, ISDN_P_NONE);\n\t\tspin_unlock_irqrestore(hx->ip->hwlock, flags);\n\t\tch->protocol = ISDN_P_NONE;\n\t\tch->peer = NULL;\n\t\tmodule_put(hx->ip->owner);\n\t\tret = 0;\n\t\tbreak;\n\tcase CONTROL_CHANNEL:\n\t\tret = channel_bctrl(bch, arg);\n\t\tbreak;\n\tdefault:\n\t\tpr_info(\"%s: %s unknown prim(%x)\\n\",\n\t\t\thx->ip->name, __func__, cmd);\n\t}\n\treturn ret;\n}\n\nstatic void\nfree_ipac(struct ipac_hw *ipac)\n{\n\tisac_release(&ipac->isac);\n}\n\nstatic const char *HSCXVer[] =\n{\"A1\", \"?1\", \"A2\", \"?3\", \"A3\", \"V2.1\", \"?6\", \"?7\",\n \"?8\", \"?9\", \"?10\", \"?11\", \"?12\", \"?13\", \"?14\", \"???\"};\n\n\n\nstatic void\nhscx_init(struct hscx_hw *hx)\n{\n\tu8 val;\n\n\tWriteHSCX(hx, IPAC_RAH2, 0xFF);\n\tWriteHSCX(hx, IPAC_XBCH, 0x00);\n\tWriteHSCX(hx, IPAC_RLCR, 0x00);\n\n\tif (hx->ip->type & IPAC_TYPE_HSCX) {\n\t\tWriteHSCX(hx, IPAC_CCR1, 0x85);\n\t\tval = ReadHSCX(hx, HSCX_VSTR);\n\t\tpr_debug(\"%s: HSCX VSTR %02x\\n\", hx->ip->name, val);\n\t\tif (hx->bch.debug & DEBUG_HW)\n\t\t\tpr_notice(\"%s: HSCX version %s\\n\", hx->ip->name,\n\t\t\t\t  HSCXVer[val & 0x0f]);\n\t} else\n\t\tWriteHSCX(hx, IPAC_CCR1, 0x82);\n\tWriteHSCX(hx, IPAC_CCR2, 0x30);\n\tWriteHSCX(hx, IPAC_XCCR, 0x07);\n\tWriteHSCX(hx, IPAC_RCCR, 0x07);\n}\n\nstatic int\nipac_init(struct ipac_hw *ipac)\n{\n\tu8 val;\n\n\tif (ipac->type & IPAC_TYPE_HSCX) {\n\t\thscx_init(&ipac->hscx[0]);\n\t\thscx_init(&ipac->hscx[1]);\n\t\tval = ReadIPAC(ipac, IPAC_ID);\n\t} else if (ipac->type & IPAC_TYPE_IPAC) {\n\t\thscx_init(&ipac->hscx[0]);\n\t\thscx_init(&ipac->hscx[1]);\n\t\tWriteIPAC(ipac, IPAC_MASK, IPAC__ON);\n\t\tval = ReadIPAC(ipac, IPAC_CONF);\n\t\t \n\t\tpr_debug(\"%s: IPAC CONF %02x/%02x\\n\", ipac->name,\n\t\t\t val, ipac->conf);\n\t\tWriteIPAC(ipac, IPAC_CONF, ipac->conf);\n\t\tval = ReadIPAC(ipac, IPAC_ID);\n\t\tif (ipac->hscx[0].bch.debug & DEBUG_HW)\n\t\t\tpr_notice(\"%s: IPAC Design ID %02x\\n\", ipac->name, val);\n\t}\n\t \n\treturn isac_init(&ipac->isac);\n}\n\nstatic int\nopen_bchannel(struct ipac_hw *ipac, struct channel_req *rq)\n{\n\tstruct bchannel\t\t*bch;\n\n\tif (rq->adr.channel == 0 || rq->adr.channel > 2)\n\t\treturn -EINVAL;\n\tif (rq->protocol == ISDN_P_NONE)\n\t\treturn -EINVAL;\n\tbch = &ipac->hscx[rq->adr.channel - 1].bch;\n\tif (test_and_set_bit(FLG_OPEN, &bch->Flags))\n\t\treturn -EBUSY;  \n\ttest_and_clear_bit(FLG_FILLEMPTY, &bch->Flags);\n\tbch->ch.protocol = rq->protocol;\n\trq->ch = &bch->ch;\n\treturn 0;\n}\n\nstatic int\nchannel_ctrl(struct ipac_hw *ipac, struct mISDN_ctrl_req *cq)\n{\n\tint\tret = 0;\n\n\tswitch (cq->op) {\n\tcase MISDN_CTRL_GETOP:\n\t\tcq->op = MISDN_CTRL_LOOP | MISDN_CTRL_L1_TIMER3;\n\t\tbreak;\n\tcase MISDN_CTRL_LOOP:\n\t\t \n\t\tif (cq->channel < 0 || cq->channel > 3) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tret = ipac->ctrl(ipac, HW_TESTLOOP, cq->channel);\n\t\tbreak;\n\tcase MISDN_CTRL_L1_TIMER3:\n\t\tret = ipac->isac.ctrl(&ipac->isac, HW_TIMER3_VALUE, cq->p1);\n\t\tbreak;\n\tdefault:\n\t\tpr_info(\"%s: unknown CTRL OP %x\\n\", ipac->name, cq->op);\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic int\nipac_dctrl(struct mISDNchannel *ch, u32 cmd, void *arg)\n{\n\tstruct mISDNdevice *dev = container_of(ch, struct mISDNdevice, D);\n\tstruct dchannel *dch = container_of(dev, struct dchannel, dev);\n\tstruct isac_hw *isac = container_of(dch, struct isac_hw, dch);\n\tstruct ipac_hw *ipac = container_of(isac, struct ipac_hw, isac);\n\tstruct channel_req *rq;\n\tint err = 0;\n\n\tpr_debug(\"%s: DCTRL: %x %p\\n\", ipac->name, cmd, arg);\n\tswitch (cmd) {\n\tcase OPEN_CHANNEL:\n\t\trq = arg;\n\t\tif (rq->protocol == ISDN_P_TE_S0)\n\t\t\terr = open_dchannel_caller(isac, rq, __builtin_return_address(0));\n\t\telse\n\t\t\terr = open_bchannel(ipac, rq);\n\t\tif (err)\n\t\t\tbreak;\n\t\tif (!try_module_get(ipac->owner))\n\t\t\tpr_info(\"%s: cannot get module\\n\", ipac->name);\n\t\tbreak;\n\tcase CLOSE_CHANNEL:\n\t\tpr_debug(\"%s: dev(%d) close from %p\\n\", ipac->name,\n\t\t\t dch->dev.id, __builtin_return_address(0));\n\t\tmodule_put(ipac->owner);\n\t\tbreak;\n\tcase CONTROL_CHANNEL:\n\t\terr = channel_ctrl(ipac, arg);\n\t\tbreak;\n\tdefault:\n\t\tpr_debug(\"%s: unknown DCTRL command %x\\n\", ipac->name, cmd);\n\t\treturn -EINVAL;\n\t}\n\treturn err;\n}\n\nu32\nmISDNipac_init(struct ipac_hw *ipac, void *hw)\n{\n\tu32 ret;\n\tu8 i;\n\n\tipac->hw = hw;\n\tif (ipac->isac.dch.debug & DEBUG_HW)\n\t\tpr_notice(\"%s: ipac type %x\\n\", ipac->name, ipac->type);\n\tif (ipac->type & IPAC_TYPE_HSCX) {\n\t\tipac->isac.type = IPAC_TYPE_ISAC;\n\t\tipac->hscx[0].off = 0;\n\t\tipac->hscx[1].off = 0x40;\n\t\tipac->hscx[0].fifo_size = 32;\n\t\tipac->hscx[1].fifo_size = 32;\n\t} else if (ipac->type & IPAC_TYPE_IPAC) {\n\t\tipac->isac.type = IPAC_TYPE_IPAC | IPAC_TYPE_ISAC;\n\t\tipac->hscx[0].off = 0;\n\t\tipac->hscx[1].off = 0x40;\n\t\tipac->hscx[0].fifo_size = 64;\n\t\tipac->hscx[1].fifo_size = 64;\n\t} else if (ipac->type & IPAC_TYPE_IPACX) {\n\t\tipac->isac.type = IPAC_TYPE_IPACX | IPAC_TYPE_ISACX;\n\t\tipac->hscx[0].off = IPACX_OFF_ICA;\n\t\tipac->hscx[1].off = IPACX_OFF_ICB;\n\t\tipac->hscx[0].fifo_size = 64;\n\t\tipac->hscx[1].fifo_size = 64;\n\t} else\n\t\treturn 0;\n\n\tmISDNisac_init(&ipac->isac, hw);\n\n\tipac->isac.dch.dev.D.ctrl = ipac_dctrl;\n\n\tfor (i = 0; i < 2; i++) {\n\t\tipac->hscx[i].bch.nr = i + 1;\n\t\tset_channelmap(i + 1, ipac->isac.dch.dev.channelmap);\n\t\tlist_add(&ipac->hscx[i].bch.ch.list,\n\t\t\t &ipac->isac.dch.dev.bchannels);\n\t\tmISDN_initbchannel(&ipac->hscx[i].bch, MAX_DATA_MEM,\n\t\t\t\t   ipac->hscx[i].fifo_size);\n\t\tipac->hscx[i].bch.ch.nr = i + 1;\n\t\tipac->hscx[i].bch.ch.send = &hscx_l2l1;\n\t\tipac->hscx[i].bch.ch.ctrl = hscx_bctrl;\n\t\tipac->hscx[i].bch.hw = hw;\n\t\tipac->hscx[i].ip = ipac;\n\t\t \n\t\tipac->hscx[i].slot = (i == 0) ? 0x2f : 0x03;\n\t}\n\n\tipac->init = ipac_init;\n\tipac->release = free_ipac;\n\n\tret =\t(1 << (ISDN_P_B_RAW & ISDN_P_B_MASK)) |\n\t\t(1 << (ISDN_P_B_HDLC & ISDN_P_B_MASK));\n\treturn ret;\n}\nEXPORT_SYMBOL(mISDNipac_init);\n\nstatic int __init\nisac_mod_init(void)\n{\n\tpr_notice(\"mISDNipac module version %s\\n\", ISAC_REV);\n\treturn 0;\n}\n\nstatic void __exit\nisac_mod_cleanup(void)\n{\n\tpr_notice(\"mISDNipac module unloaded\\n\");\n}\nmodule_init(isac_mod_init);\nmodule_exit(isac_mod_cleanup);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}