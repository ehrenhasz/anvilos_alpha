{
  "module_name": "w6692.c",
  "hash_id": "6bdc2d7517eff16bdb03658b542ebf0ac15aaa4ba78eb13fbc33c711f226a9a1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/isdn/hardware/mISDN/w6692.c",
  "human_readable_source": "\n \n\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/delay.h>\n#include <linux/mISDNhw.h>\n#include <linux/slab.h>\n#include \"w6692.h\"\n\n#define W6692_REV\t\"2.0\"\n\n#define DBUSY_TIMER_VALUE\t80\n\nenum {\n\tW6692_ASUS,\n\tW6692_WINBOND,\n\tW6692_USR\n};\n\n \nstruct w6692map {\n\tu_int\tsubtype;\n\tchar\t*name;\n};\n\nstatic const struct w6692map  w6692_map[] =\n{\n\t{W6692_ASUS, \"Dynalink/AsusCom IS64PH\"},\n\t{W6692_WINBOND, \"Winbond W6692\"},\n\t{W6692_USR, \"USR W6692\"}\n};\n\n#define PCI_DEVICE_ID_USR_6692\t0x3409\n\nstruct w6692_ch {\n\tstruct bchannel\t\tbch;\n\tu32\t\t\taddr;\n\tstruct timer_list\ttimer;\n\tu8\t\t\tb_mode;\n};\n\nstruct w6692_hw {\n\tstruct list_head\tlist;\n\tstruct pci_dev\t\t*pdev;\n\tchar\t\t\tname[MISDN_MAX_IDLEN];\n\tu32\t\t\tirq;\n\tu32\t\t\tirqcnt;\n\tu32\t\t\taddr;\n\tu32\t\t\tfmask;\t \n\tint\t\t\tsubtype;\n\tspinlock_t\t\tlock;\t \n\tu8\t\t\timask;\n\tu8\t\t\tpctl;\n\tu8\t\t\txaddr;\n\tu8\t\t\txdata;\n\tu8\t\t\tstate;\n\tstruct w6692_ch\t\tbc[2];\n\tstruct dchannel\t\tdch;\n\tchar\t\t\tlog[64];\n};\n\nstatic LIST_HEAD(Cards);\nstatic DEFINE_RWLOCK(card_lock);  \n\nstatic int w6692_cnt;\nstatic int debug;\nstatic u32 led;\nstatic u32 pots;\n\nstatic void\n_set_debug(struct w6692_hw *card)\n{\n\tcard->dch.debug = debug;\n\tcard->bc[0].bch.debug = debug;\n\tcard->bc[1].bch.debug = debug;\n}\n\nstatic int\nset_debug(const char *val, const struct kernel_param *kp)\n{\n\tint ret;\n\tstruct w6692_hw *card;\n\n\tret = param_set_uint(val, kp);\n\tif (!ret) {\n\t\tread_lock(&card_lock);\n\t\tlist_for_each_entry(card, &Cards, list)\n\t\t\t_set_debug(card);\n\t\tread_unlock(&card_lock);\n\t}\n\treturn ret;\n}\n\nMODULE_AUTHOR(\"Karsten Keil\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_VERSION(W6692_REV);\nmodule_param_call(debug, set_debug, param_get_uint, &debug, S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(debug, \"W6692 debug mask\");\nmodule_param(led, uint, S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(led, \"W6692 LED support bitmask (one bit per card)\");\nmodule_param(pots, uint, S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(pots, \"W6692 POTS support bitmask (one bit per card)\");\n\nstatic inline u8\nReadW6692(struct w6692_hw *card, u8 offset)\n{\n\treturn inb(card->addr + offset);\n}\n\nstatic inline void\nWriteW6692(struct w6692_hw *card, u8 offset, u8 value)\n{\n\toutb(value, card->addr + offset);\n}\n\nstatic inline u8\nReadW6692B(struct w6692_ch *bc, u8 offset)\n{\n\treturn inb(bc->addr + offset);\n}\n\nstatic inline void\nWriteW6692B(struct w6692_ch *bc, u8 offset, u8 value)\n{\n\toutb(value, bc->addr + offset);\n}\n\nstatic void\nenable_hwirq(struct w6692_hw *card)\n{\n\tWriteW6692(card, W_IMASK, card->imask);\n}\n\nstatic void\ndisable_hwirq(struct w6692_hw *card)\n{\n\tWriteW6692(card, W_IMASK, 0xff);\n}\n\nstatic const char *W6692Ver[] = {\"V00\", \"V01\", \"V10\", \"V11\"};\n\nstatic void\nW6692Version(struct w6692_hw *card)\n{\n\tint val;\n\n\tval = ReadW6692(card, W_D_RBCH);\n\tpr_notice(\"%s: Winbond W6692 version: %s\\n\", card->name,\n\t\t  W6692Ver[(val >> 6) & 3]);\n}\n\nstatic void\nw6692_led_handler(struct w6692_hw *card, int on)\n{\n\tif ((!(card->fmask & led)) || card->subtype == W6692_USR)\n\t\treturn;\n\tif (on) {\n\t\tcard->xdata &= 0xfb;\t \n\t\tWriteW6692(card, W_XDATA, card->xdata);\n\t} else {\n\t\tcard->xdata |= 0x04;\t \n\t\tWriteW6692(card, W_XDATA, card->xdata);\n\t}\n}\n\nstatic void\nph_command(struct w6692_hw *card, u8 cmd)\n{\n\tpr_debug(\"%s: ph_command %x\\n\", card->name, cmd);\n\tWriteW6692(card, W_CIX, cmd);\n}\n\nstatic void\nW6692_new_ph(struct w6692_hw *card)\n{\n\tif (card->state == W_L1CMD_RST)\n\t\tph_command(card, W_L1CMD_DRC);\n\tschedule_event(&card->dch, FLG_PHCHANGE);\n}\n\nstatic void\nW6692_ph_bh(struct dchannel *dch)\n{\n\tstruct w6692_hw *card = dch->hw;\n\n\tswitch (card->state) {\n\tcase W_L1CMD_RST:\n\t\tdch->state = 0;\n\t\tl1_event(dch->l1, HW_RESET_IND);\n\t\tbreak;\n\tcase W_L1IND_CD:\n\t\tdch->state = 3;\n\t\tl1_event(dch->l1, HW_DEACT_CNF);\n\t\tbreak;\n\tcase W_L1IND_DRD:\n\t\tdch->state = 3;\n\t\tl1_event(dch->l1, HW_DEACT_IND);\n\t\tbreak;\n\tcase W_L1IND_CE:\n\t\tdch->state = 4;\n\t\tl1_event(dch->l1, HW_POWERUP_IND);\n\t\tbreak;\n\tcase W_L1IND_LD:\n\t\tif (dch->state <= 5) {\n\t\t\tdch->state = 5;\n\t\t\tl1_event(dch->l1, ANYSIGNAL);\n\t\t} else {\n\t\t\tdch->state = 8;\n\t\t\tl1_event(dch->l1, LOSTFRAMING);\n\t\t}\n\t\tbreak;\n\tcase W_L1IND_ARD:\n\t\tdch->state = 6;\n\t\tl1_event(dch->l1, INFO2);\n\t\tbreak;\n\tcase W_L1IND_AI8:\n\t\tdch->state = 7;\n\t\tl1_event(dch->l1, INFO4_P8);\n\t\tbreak;\n\tcase W_L1IND_AI10:\n\t\tdch->state = 7;\n\t\tl1_event(dch->l1, INFO4_P10);\n\t\tbreak;\n\tdefault:\n\t\tpr_debug(\"%s: TE unknown state %02x dch state %02x\\n\",\n\t\t\t card->name, card->state, dch->state);\n\t\tbreak;\n\t}\n\tpr_debug(\"%s: TE newstate %02x\\n\", card->name, dch->state);\n}\n\nstatic void\nW6692_empty_Dfifo(struct w6692_hw *card, int count)\n{\n\tstruct dchannel *dch = &card->dch;\n\tu8 *ptr;\n\n\tpr_debug(\"%s: empty_Dfifo %d\\n\", card->name, count);\n\tif (!dch->rx_skb) {\n\t\tdch->rx_skb = mI_alloc_skb(card->dch.maxlen, GFP_ATOMIC);\n\t\tif (!dch->rx_skb) {\n\t\t\tpr_info(\"%s: D receive out of memory\\n\", card->name);\n\t\t\tWriteW6692(card, W_D_CMDR, W_D_CMDR_RACK);\n\t\t\treturn;\n\t\t}\n\t}\n\tif ((dch->rx_skb->len + count) >= dch->maxlen) {\n\t\tpr_debug(\"%s: empty_Dfifo overrun %d\\n\", card->name,\n\t\t\t dch->rx_skb->len + count);\n\t\tWriteW6692(card, W_D_CMDR, W_D_CMDR_RACK);\n\t\treturn;\n\t}\n\tptr = skb_put(dch->rx_skb, count);\n\tinsb(card->addr + W_D_RFIFO, ptr, count);\n\tWriteW6692(card, W_D_CMDR, W_D_CMDR_RACK);\n\tif (debug & DEBUG_HW_DFIFO) {\n\t\tsnprintf(card->log, 63, \"D-recv %s %d \",\n\t\t\t card->name, count);\n\t\tprint_hex_dump_bytes(card->log, DUMP_PREFIX_OFFSET, ptr, count);\n\t}\n}\n\nstatic void\nW6692_fill_Dfifo(struct w6692_hw *card)\n{\n\tstruct dchannel *dch = &card->dch;\n\tint count;\n\tu8 *ptr;\n\tu8 cmd = W_D_CMDR_XMS;\n\n\tpr_debug(\"%s: fill_Dfifo\\n\", card->name);\n\tif (!dch->tx_skb)\n\t\treturn;\n\tcount = dch->tx_skb->len - dch->tx_idx;\n\tif (count <= 0)\n\t\treturn;\n\tif (count > W_D_FIFO_THRESH)\n\t\tcount = W_D_FIFO_THRESH;\n\telse\n\t\tcmd |= W_D_CMDR_XME;\n\tptr = dch->tx_skb->data + dch->tx_idx;\n\tdch->tx_idx += count;\n\toutsb(card->addr + W_D_XFIFO, ptr, count);\n\tWriteW6692(card, W_D_CMDR, cmd);\n\tif (test_and_set_bit(FLG_BUSY_TIMER, &dch->Flags)) {\n\t\tpr_debug(\"%s: fill_Dfifo dbusytimer running\\n\", card->name);\n\t\tdel_timer(&dch->timer);\n\t}\n\tdch->timer.expires = jiffies + ((DBUSY_TIMER_VALUE * HZ) / 1000);\n\tadd_timer(&dch->timer);\n\tif (debug & DEBUG_HW_DFIFO) {\n\t\tsnprintf(card->log, 63, \"D-send %s %d \",\n\t\t\t card->name, count);\n\t\tprint_hex_dump_bytes(card->log, DUMP_PREFIX_OFFSET, ptr, count);\n\t}\n}\n\nstatic void\nd_retransmit(struct w6692_hw *card)\n{\n\tstruct dchannel *dch = &card->dch;\n\n\tif (test_and_clear_bit(FLG_BUSY_TIMER, &dch->Flags))\n\t\tdel_timer(&dch->timer);\n#ifdef FIXME\n\tif (test_and_clear_bit(FLG_L1_BUSY, &dch->Flags))\n\t\tdchannel_sched_event(dch, D_CLEARBUSY);\n#endif\n\tif (test_bit(FLG_TX_BUSY, &dch->Flags)) {\n\t\t \n\t\tdch->tx_idx = 0;\n\t\tW6692_fill_Dfifo(card);\n\t} else if (dch->tx_skb) {  \n\t\tpr_info(\"%s: %s without TX_BUSY\\n\", card->name, __func__);\n\t\ttest_and_set_bit(FLG_TX_BUSY, &dch->Flags);\n\t\tdch->tx_idx = 0;\n\t\tW6692_fill_Dfifo(card);\n\t} else {\n\t\tpr_info(\"%s: XDU no TX_BUSY\\n\", card->name);\n\t\tif (get_next_dframe(dch))\n\t\t\tW6692_fill_Dfifo(card);\n\t}\n}\n\nstatic void\nhandle_rxD(struct w6692_hw *card) {\n\tu8\tstat;\n\tint\tcount;\n\n\tstat = ReadW6692(card, W_D_RSTA);\n\tif (stat & (W_D_RSTA_RDOV | W_D_RSTA_CRCE | W_D_RSTA_RMB)) {\n\t\tif (stat & W_D_RSTA_RDOV) {\n\t\t\tpr_debug(\"%s: D-channel RDOV\\n\", card->name);\n#ifdef ERROR_STATISTIC\n\t\t\tcard->dch.err_rx++;\n#endif\n\t\t}\n\t\tif (stat & W_D_RSTA_CRCE) {\n\t\t\tpr_debug(\"%s: D-channel CRC error\\n\", card->name);\n#ifdef ERROR_STATISTIC\n\t\t\tcard->dch.err_crc++;\n#endif\n\t\t}\n\t\tif (stat & W_D_RSTA_RMB) {\n\t\t\tpr_debug(\"%s: D-channel ABORT\\n\", card->name);\n#ifdef ERROR_STATISTIC\n\t\t\tcard->dch.err_rx++;\n#endif\n\t\t}\n\t\tdev_kfree_skb(card->dch.rx_skb);\n\t\tcard->dch.rx_skb = NULL;\n\t\tWriteW6692(card, W_D_CMDR, W_D_CMDR_RACK | W_D_CMDR_RRST);\n\t} else {\n\t\tcount = ReadW6692(card, W_D_RBCL) & (W_D_FIFO_THRESH - 1);\n\t\tif (count == 0)\n\t\t\tcount = W_D_FIFO_THRESH;\n\t\tW6692_empty_Dfifo(card, count);\n\t\trecv_Dchannel(&card->dch);\n\t}\n}\n\nstatic void\nhandle_txD(struct w6692_hw *card) {\n\tif (test_and_clear_bit(FLG_BUSY_TIMER, &card->dch.Flags))\n\t\tdel_timer(&card->dch.timer);\n\tif (card->dch.tx_skb && card->dch.tx_idx < card->dch.tx_skb->len) {\n\t\tW6692_fill_Dfifo(card);\n\t} else {\n\t\tdev_kfree_skb(card->dch.tx_skb);\n\t\tif (get_next_dframe(&card->dch))\n\t\t\tW6692_fill_Dfifo(card);\n\t}\n}\n\nstatic void\nhandle_statusD(struct w6692_hw *card)\n{\n\tstruct dchannel *dch = &card->dch;\n\tu8 exval, v1, cir;\n\n\texval = ReadW6692(card, W_D_EXIR);\n\n\tpr_debug(\"%s: D_EXIR %02x\\n\", card->name, exval);\n\tif (exval & (W_D_EXI_XDUN | W_D_EXI_XCOL)) {\n\t\t \n\t\tpr_debug(\"%s: D-channel underrun/collision\\n\", card->name);\n#ifdef ERROR_STATISTIC\n\t\tdch->err_tx++;\n#endif\n\t\td_retransmit(card);\n\t}\n\tif (exval & W_D_EXI_RDOV) {\t \n\t\tpr_debug(\"%s: D-channel RDOV\\n\", card->name);\n\t\tWriteW6692(card, W_D_CMDR, W_D_CMDR_RRST);\n\t}\n\tif (exval & W_D_EXI_TIN2)\t \n\t\tpr_debug(\"%s: spurious TIN2 interrupt\\n\", card->name);\n\tif (exval & W_D_EXI_MOC) {\t \n\t\tv1 = ReadW6692(card, W_MOSR);\n\t\tpr_debug(\"%s: spurious MOC interrupt MOSR %02x\\n\",\n\t\t\t card->name, v1);\n\t}\n\tif (exval & W_D_EXI_ISC) {\t \n\t\tcir = ReadW6692(card, W_CIR);\n\t\tpr_debug(\"%s: ISC CIR %02X\\n\", card->name, cir);\n\t\tif (cir & W_CIR_ICC) {\n\t\t\tv1 = cir & W_CIR_COD_MASK;\n\t\t\tpr_debug(\"%s: ph_state_change %x -> %x\\n\", card->name,\n\t\t\t\t dch->state, v1);\n\t\t\tcard->state = v1;\n\t\t\tif (card->fmask & led) {\n\t\t\t\tswitch (v1) {\n\t\t\t\tcase W_L1IND_AI8:\n\t\t\t\tcase W_L1IND_AI10:\n\t\t\t\t\tw6692_led_handler(card, 1);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tw6692_led_handler(card, 0);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tW6692_new_ph(card);\n\t\t}\n\t\tif (cir & W_CIR_SCC) {\n\t\t\tv1 = ReadW6692(card, W_SQR);\n\t\t\tpr_debug(\"%s: SCC SQR %02X\\n\", card->name, v1);\n\t\t}\n\t}\n\tif (exval & W_D_EXI_WEXP)\n\t\tpr_debug(\"%s: spurious WEXP interrupt!\\n\", card->name);\n\tif (exval & W_D_EXI_TEXP)\n\t\tpr_debug(\"%s: spurious TEXP interrupt!\\n\", card->name);\n}\n\nstatic void\nW6692_empty_Bfifo(struct w6692_ch *wch, int count)\n{\n\tstruct w6692_hw *card = wch->bch.hw;\n\tu8 *ptr;\n\tint maxlen;\n\n\tpr_debug(\"%s: empty_Bfifo %d\\n\", card->name, count);\n\tif (unlikely(wch->bch.state == ISDN_P_NONE)) {\n\t\tpr_debug(\"%s: empty_Bfifo ISDN_P_NONE\\n\", card->name);\n\t\tWriteW6692B(wch, W_B_CMDR, W_B_CMDR_RACK | W_B_CMDR_RACT);\n\t\tif (wch->bch.rx_skb)\n\t\t\tskb_trim(wch->bch.rx_skb, 0);\n\t\treturn;\n\t}\n\tif (test_bit(FLG_RX_OFF, &wch->bch.Flags)) {\n\t\twch->bch.dropcnt += count;\n\t\tWriteW6692B(wch, W_B_CMDR, W_B_CMDR_RACK | W_B_CMDR_RACT);\n\t\treturn;\n\t}\n\tmaxlen = bchannel_get_rxbuf(&wch->bch, count);\n\tif (maxlen < 0) {\n\t\tWriteW6692B(wch, W_B_CMDR, W_B_CMDR_RACK | W_B_CMDR_RACT);\n\t\tif (wch->bch.rx_skb)\n\t\t\tskb_trim(wch->bch.rx_skb, 0);\n\t\tpr_warn(\"%s.B%d: No bufferspace for %d bytes\\n\",\n\t\t\tcard->name, wch->bch.nr, count);\n\t\treturn;\n\t}\n\tptr = skb_put(wch->bch.rx_skb, count);\n\tinsb(wch->addr + W_B_RFIFO, ptr, count);\n\tWriteW6692B(wch, W_B_CMDR, W_B_CMDR_RACK | W_B_CMDR_RACT);\n\tif (debug & DEBUG_HW_DFIFO) {\n\t\tsnprintf(card->log, 63, \"B%1d-recv %s %d \",\n\t\t\t wch->bch.nr, card->name, count);\n\t\tprint_hex_dump_bytes(card->log, DUMP_PREFIX_OFFSET, ptr, count);\n\t}\n}\n\nstatic void\nW6692_fill_Bfifo(struct w6692_ch *wch)\n{\n\tstruct w6692_hw *card = wch->bch.hw;\n\tint count, fillempty = 0;\n\tu8 *ptr, cmd = W_B_CMDR_RACT | W_B_CMDR_XMS;\n\n\tpr_debug(\"%s: fill Bfifo\\n\", card->name);\n\tif (!wch->bch.tx_skb) {\n\t\tif (!test_bit(FLG_TX_EMPTY, &wch->bch.Flags))\n\t\t\treturn;\n\t\tptr = wch->bch.fill;\n\t\tcount = W_B_FIFO_THRESH;\n\t\tfillempty = 1;\n\t} else {\n\t\tcount = wch->bch.tx_skb->len - wch->bch.tx_idx;\n\t\tif (count <= 0)\n\t\t\treturn;\n\t\tptr = wch->bch.tx_skb->data + wch->bch.tx_idx;\n\t}\n\tif (count > W_B_FIFO_THRESH)\n\t\tcount = W_B_FIFO_THRESH;\n\telse if (test_bit(FLG_HDLC, &wch->bch.Flags))\n\t\tcmd |= W_B_CMDR_XME;\n\n\tpr_debug(\"%s: fill Bfifo%d/%d\\n\", card->name,\n\t\t count, wch->bch.tx_idx);\n\twch->bch.tx_idx += count;\n\tif (fillempty) {\n\t\twhile (count > 0) {\n\t\t\toutsb(wch->addr + W_B_XFIFO, ptr, MISDN_BCH_FILL_SIZE);\n\t\t\tcount -= MISDN_BCH_FILL_SIZE;\n\t\t}\n\t} else {\n\t\toutsb(wch->addr + W_B_XFIFO, ptr, count);\n\t}\n\tWriteW6692B(wch, W_B_CMDR, cmd);\n\tif ((debug & DEBUG_HW_BFIFO) && !fillempty) {\n\t\tsnprintf(card->log, 63, \"B%1d-send %s %d \",\n\t\t\t wch->bch.nr, card->name, count);\n\t\tprint_hex_dump_bytes(card->log, DUMP_PREFIX_OFFSET, ptr, count);\n\t}\n}\n\n#if 0\nstatic int\nsetvolume(struct w6692_ch *wch, int mic, struct sk_buff *skb)\n{\n\tstruct w6692_hw *card = wch->bch.hw;\n\tu16 *vol = (u16 *)skb->data;\n\tu8 val;\n\n\tif ((!(card->fmask & pots)) ||\n\t    !test_bit(FLG_TRANSPARENT, &wch->bch.Flags))\n\t\treturn -ENODEV;\n\tif (skb->len < 2)\n\t\treturn -EINVAL;\n\tif (*vol > 7)\n\t\treturn -EINVAL;\n\tval = *vol & 7;\n\tval = 7 - val;\n\tif (mic) {\n\t\tval <<= 3;\n\t\tcard->xaddr &= 0xc7;\n\t} else {\n\t\tcard->xaddr &= 0xf8;\n\t}\n\tcard->xaddr |= val;\n\tWriteW6692(card, W_XADDR, card->xaddr);\n\treturn 0;\n}\n\nstatic int\nenable_pots(struct w6692_ch *wch)\n{\n\tstruct w6692_hw *card = wch->bch.hw;\n\n\tif ((!(card->fmask & pots)) ||\n\t    !test_bit(FLG_TRANSPARENT, &wch->bch.Flags))\n\t\treturn -ENODEV;\n\twch->b_mode |= W_B_MODE_EPCM | W_B_MODE_BSW0;\n\tWriteW6692B(wch, W_B_MODE, wch->b_mode);\n\tWriteW6692B(wch, W_B_CMDR, W_B_CMDR_RRST | W_B_CMDR_XRST);\n\tcard->pctl |= ((wch->bch.nr & 2) ? W_PCTL_PCX : 0);\n\tWriteW6692(card, W_PCTL, card->pctl);\n\treturn 0;\n}\n#endif\n\nstatic int\ndisable_pots(struct w6692_ch *wch)\n{\n\tstruct w6692_hw *card = wch->bch.hw;\n\n\tif (!(card->fmask & pots))\n\t\treturn -ENODEV;\n\twch->b_mode &= ~(W_B_MODE_EPCM | W_B_MODE_BSW0);\n\tWriteW6692B(wch, W_B_MODE, wch->b_mode);\n\tWriteW6692B(wch, W_B_CMDR, W_B_CMDR_RRST | W_B_CMDR_RACT |\n\t\t    W_B_CMDR_XRST);\n\treturn 0;\n}\n\nstatic int\nw6692_mode(struct w6692_ch *wch, u32 pr)\n{\n\tstruct w6692_hw\t*card;\n\n\tcard = wch->bch.hw;\n\tpr_debug(\"%s: B%d protocol %x-->%x\\n\", card->name,\n\t\t wch->bch.nr, wch->bch.state, pr);\n\tswitch (pr) {\n\tcase ISDN_P_NONE:\n\t\tif ((card->fmask & pots) && (wch->b_mode & W_B_MODE_EPCM))\n\t\t\tdisable_pots(wch);\n\t\twch->b_mode = 0;\n\t\tmISDN_clear_bchannel(&wch->bch);\n\t\tWriteW6692B(wch, W_B_MODE, wch->b_mode);\n\t\tWriteW6692B(wch, W_B_CMDR, W_B_CMDR_RRST | W_B_CMDR_XRST);\n\t\ttest_and_clear_bit(FLG_HDLC, &wch->bch.Flags);\n\t\ttest_and_clear_bit(FLG_TRANSPARENT, &wch->bch.Flags);\n\t\tbreak;\n\tcase ISDN_P_B_RAW:\n\t\twch->b_mode = W_B_MODE_MMS;\n\t\tWriteW6692B(wch, W_B_MODE, wch->b_mode);\n\t\tWriteW6692B(wch, W_B_EXIM, 0);\n\t\tWriteW6692B(wch, W_B_CMDR, W_B_CMDR_RRST | W_B_CMDR_RACT |\n\t\t\t    W_B_CMDR_XRST);\n\t\ttest_and_set_bit(FLG_TRANSPARENT, &wch->bch.Flags);\n\t\tbreak;\n\tcase ISDN_P_B_HDLC:\n\t\twch->b_mode = W_B_MODE_ITF;\n\t\tWriteW6692B(wch, W_B_MODE, wch->b_mode);\n\t\tWriteW6692B(wch, W_B_ADM1, 0xff);\n\t\tWriteW6692B(wch, W_B_ADM2, 0xff);\n\t\tWriteW6692B(wch, W_B_EXIM, 0);\n\t\tWriteW6692B(wch, W_B_CMDR, W_B_CMDR_RRST | W_B_CMDR_RACT |\n\t\t\t    W_B_CMDR_XRST);\n\t\ttest_and_set_bit(FLG_HDLC, &wch->bch.Flags);\n\t\tbreak;\n\tdefault:\n\t\tpr_info(\"%s: protocol %x not known\\n\", card->name, pr);\n\t\treturn -ENOPROTOOPT;\n\t}\n\twch->bch.state = pr;\n\treturn 0;\n}\n\nstatic void\nsend_next(struct w6692_ch *wch)\n{\n\tif (wch->bch.tx_skb && wch->bch.tx_idx < wch->bch.tx_skb->len) {\n\t\tW6692_fill_Bfifo(wch);\n\t} else {\n\t\tdev_kfree_skb(wch->bch.tx_skb);\n\t\tif (get_next_bframe(&wch->bch)) {\n\t\t\tW6692_fill_Bfifo(wch);\n\t\t\ttest_and_clear_bit(FLG_TX_EMPTY, &wch->bch.Flags);\n\t\t} else if (test_bit(FLG_TX_EMPTY, &wch->bch.Flags)) {\n\t\t\tW6692_fill_Bfifo(wch);\n\t\t}\n\t}\n}\n\nstatic void\nW6692B_interrupt(struct w6692_hw *card, int ch)\n{\n\tstruct w6692_ch\t*wch = &card->bc[ch];\n\tint\t\tcount;\n\tu8\t\tstat, star = 0;\n\n\tstat = ReadW6692B(wch, W_B_EXIR);\n\tpr_debug(\"%s: B%d EXIR %02x\\n\", card->name, wch->bch.nr, stat);\n\tif (stat & W_B_EXI_RME) {\n\t\tstar = ReadW6692B(wch, W_B_STAR);\n\t\tif (star & (W_B_STAR_RDOV | W_B_STAR_CRCE | W_B_STAR_RMB)) {\n\t\t\tif ((star & W_B_STAR_RDOV) &&\n\t\t\t    test_bit(FLG_ACTIVE, &wch->bch.Flags)) {\n\t\t\t\tpr_debug(\"%s: B%d RDOV proto=%x\\n\", card->name,\n\t\t\t\t\t wch->bch.nr, wch->bch.state);\n#ifdef ERROR_STATISTIC\n\t\t\t\twch->bch.err_rdo++;\n#endif\n\t\t\t}\n\t\t\tif (test_bit(FLG_HDLC, &wch->bch.Flags)) {\n\t\t\t\tif (star & W_B_STAR_CRCE) {\n\t\t\t\t\tpr_debug(\"%s: B%d CRC error\\n\",\n\t\t\t\t\t\t card->name, wch->bch.nr);\n#ifdef ERROR_STATISTIC\n\t\t\t\t\twch->bch.err_crc++;\n#endif\n\t\t\t\t}\n\t\t\t\tif (star & W_B_STAR_RMB) {\n\t\t\t\t\tpr_debug(\"%s: B%d message abort\\n\",\n\t\t\t\t\t\t card->name, wch->bch.nr);\n#ifdef ERROR_STATISTIC\n\t\t\t\t\twch->bch.err_inv++;\n#endif\n\t\t\t\t}\n\t\t\t}\n\t\t\tWriteW6692B(wch, W_B_CMDR, W_B_CMDR_RACK |\n\t\t\t\t    W_B_CMDR_RRST | W_B_CMDR_RACT);\n\t\t\tif (wch->bch.rx_skb)\n\t\t\t\tskb_trim(wch->bch.rx_skb, 0);\n\t\t} else {\n\t\t\tcount = ReadW6692B(wch, W_B_RBCL) &\n\t\t\t\t(W_B_FIFO_THRESH - 1);\n\t\t\tif (count == 0)\n\t\t\t\tcount = W_B_FIFO_THRESH;\n\t\t\tW6692_empty_Bfifo(wch, count);\n\t\t\trecv_Bchannel(&wch->bch, 0, false);\n\t\t}\n\t}\n\tif (stat & W_B_EXI_RMR) {\n\t\tif (!(stat & W_B_EXI_RME))\n\t\t\tstar = ReadW6692B(wch, W_B_STAR);\n\t\tif (star & W_B_STAR_RDOV) {\n\t\t\tpr_debug(\"%s: B%d RDOV proto=%x\\n\", card->name,\n\t\t\t\t wch->bch.nr, wch->bch.state);\n#ifdef ERROR_STATISTIC\n\t\t\twch->bch.err_rdo++;\n#endif\n\t\t\tWriteW6692B(wch, W_B_CMDR, W_B_CMDR_RACK |\n\t\t\t\t    W_B_CMDR_RRST | W_B_CMDR_RACT);\n\t\t} else {\n\t\t\tW6692_empty_Bfifo(wch, W_B_FIFO_THRESH);\n\t\t\tif (test_bit(FLG_TRANSPARENT, &wch->bch.Flags))\n\t\t\t\trecv_Bchannel(&wch->bch, 0, false);\n\t\t}\n\t}\n\tif (stat & W_B_EXI_RDOV) {\n\t\t \n\t\tif (!(star & W_B_STAR_RDOV)) {\n\t\t\tpr_debug(\"%s: B%d RDOV IRQ proto=%x\\n\", card->name,\n\t\t\t\t wch->bch.nr, wch->bch.state);\n#ifdef ERROR_STATISTIC\n\t\t\twch->bch.err_rdo++;\n#endif\n\t\t\tWriteW6692B(wch, W_B_CMDR, W_B_CMDR_RACK |\n\t\t\t\t    W_B_CMDR_RRST | W_B_CMDR_RACT);\n\t\t}\n\t}\n\tif (stat & W_B_EXI_XFR) {\n\t\tif (!(stat & (W_B_EXI_RME | W_B_EXI_RMR))) {\n\t\t\tstar = ReadW6692B(wch, W_B_STAR);\n\t\t\tpr_debug(\"%s: B%d star %02x\\n\", card->name,\n\t\t\t\t wch->bch.nr, star);\n\t\t}\n\t\tif (star & W_B_STAR_XDOW) {\n\t\t\tpr_warn(\"%s: B%d XDOW proto=%x\\n\", card->name,\n\t\t\t\twch->bch.nr, wch->bch.state);\n#ifdef ERROR_STATISTIC\n\t\t\twch->bch.err_xdu++;\n#endif\n\t\t\tWriteW6692B(wch, W_B_CMDR, W_B_CMDR_XRST |\n\t\t\t\t    W_B_CMDR_RACT);\n\t\t\t \n\t\t\tif (wch->bch.tx_skb) {\n\t\t\t\tif (!test_bit(FLG_TRANSPARENT, &wch->bch.Flags))\n\t\t\t\t\twch->bch.tx_idx = 0;\n\t\t\t}\n\t\t}\n\t\tsend_next(wch);\n\t\tif (star & W_B_STAR_XDOW)\n\t\t\treturn;  \n\t}\n\tif (stat & W_B_EXI_XDUN) {\n\t\tpr_warn(\"%s: B%d XDUN proto=%x\\n\", card->name,\n\t\t\twch->bch.nr, wch->bch.state);\n#ifdef ERROR_STATISTIC\n\t\twch->bch.err_xdu++;\n#endif\n\t\t \n\t\tif (wch->bch.tx_skb) {\n\t\t\tif (!test_bit(FLG_TRANSPARENT, &wch->bch.Flags))\n\t\t\t\twch->bch.tx_idx = 0;\n\t\t} else if (test_bit(FLG_FILLEMPTY, &wch->bch.Flags)) {\n\t\t\ttest_and_set_bit(FLG_TX_EMPTY, &wch->bch.Flags);\n\t\t}\n\t\tsend_next(wch);\n\t}\n}\n\nstatic irqreturn_t\nw6692_irq(int intno, void *dev_id)\n{\n\tstruct w6692_hw\t*card = dev_id;\n\tu8\t\tista;\n\n\tspin_lock(&card->lock);\n\tista = ReadW6692(card, W_ISTA);\n\tif ((ista | card->imask) == card->imask) {\n\t\t \n\t\tspin_unlock(&card->lock);\n\t\treturn IRQ_NONE;\n\t}\n\tcard->irqcnt++;\n\tpr_debug(\"%s: ista %02x\\n\", card->name, ista);\n\tista &= ~card->imask;\n\tif (ista & W_INT_B1_EXI)\n\t\tW6692B_interrupt(card, 0);\n\tif (ista & W_INT_B2_EXI)\n\t\tW6692B_interrupt(card, 1);\n\tif (ista & W_INT_D_RME)\n\t\thandle_rxD(card);\n\tif (ista & W_INT_D_RMR)\n\t\tW6692_empty_Dfifo(card, W_D_FIFO_THRESH);\n\tif (ista & W_INT_D_XFR)\n\t\thandle_txD(card);\n\tif (ista & W_INT_D_EXI)\n\t\thandle_statusD(card);\n\tif (ista & (W_INT_XINT0 | W_INT_XINT1))  \n\t\tpr_debug(\"%s: W6692 spurious XINT!\\n\", card->name);\n \n\tspin_unlock(&card->lock);\n\treturn IRQ_HANDLED;\n}\n\nstatic void\ndbusy_timer_handler(struct timer_list *t)\n{\n\tstruct dchannel *dch = from_timer(dch, t, timer);\n\tstruct w6692_hw\t*card = dch->hw;\n\tint\t\trbch, star;\n\tu_long\t\tflags;\n\n\tif (test_bit(FLG_BUSY_TIMER, &dch->Flags)) {\n\t\tspin_lock_irqsave(&card->lock, flags);\n\t\trbch = ReadW6692(card, W_D_RBCH);\n\t\tstar = ReadW6692(card, W_D_STAR);\n\t\tpr_debug(\"%s: D-Channel Busy RBCH %02x STAR %02x\\n\",\n\t\t\t card->name, rbch, star);\n\t\tif (star & W_D_STAR_XBZ)\t \n\t\t\ttest_and_set_bit(FLG_L1_BUSY, &dch->Flags);\n\t\telse {\n\t\t\t \n\t\t\ttest_and_clear_bit(FLG_BUSY_TIMER, &dch->Flags);\n\t\t\tif (dch->tx_idx)\n\t\t\t\tdch->tx_idx = 0;\n\t\t\telse\n\t\t\t\tpr_info(\"%s: W6692 D-Channel Busy no tx_idx\\n\",\n\t\t\t\t\tcard->name);\n\t\t\t \n\t\t\tWriteW6692(card, W_D_CMDR, W_D_CMDR_XRST);\n\t\t}\n\t\tspin_unlock_irqrestore(&card->lock, flags);\n\t}\n}\n\nstatic void initW6692(struct w6692_hw *card)\n{\n\tu8\tval;\n\n\ttimer_setup(&card->dch.timer, dbusy_timer_handler, 0);\n\tw6692_mode(&card->bc[0], ISDN_P_NONE);\n\tw6692_mode(&card->bc[1], ISDN_P_NONE);\n\tWriteW6692(card, W_D_CTL, 0x00);\n\tdisable_hwirq(card);\n\tWriteW6692(card, W_D_SAM, 0xff);\n\tWriteW6692(card, W_D_TAM, 0xff);\n\tWriteW6692(card, W_D_MODE, W_D_MODE_RACT);\n\tcard->state = W_L1CMD_RST;\n\tph_command(card, W_L1CMD_RST);\n\tph_command(card, W_L1CMD_ECK);\n\t \n\tcard->imask = 0x18;\n\tWriteW6692(card, W_D_EXIM, 0x00);\n\tWriteW6692B(&card->bc[0], W_B_EXIM, 0);\n\tWriteW6692B(&card->bc[1], W_B_EXIM, 0);\n\t \n\tWriteW6692(card, W_D_CMDR, W_D_CMDR_RRST | W_D_CMDR_XRST);\n\t \n\tWriteW6692B(&card->bc[0], W_B_CMDR, W_B_CMDR_RRST | W_B_CMDR_XRST);\n\tWriteW6692B(&card->bc[1], W_B_CMDR, W_B_CMDR_RRST | W_B_CMDR_XRST);\n\t \n\tif (card->subtype == W6692_USR) {\n\t\t \n\t\tcard->pctl = 0x80;\n\t\tcard->xdata = 0;\n\t\tWriteW6692(card, W_PCTL, card->pctl);\n\t\tWriteW6692(card, W_XDATA, card->xdata);\n\t} else {\n\t\tcard->pctl = W_PCTL_OE5 | W_PCTL_OE4 | W_PCTL_OE2 |\n\t\t\tW_PCTL_OE1 | W_PCTL_OE0;\n\t\tcard->xaddr = 0x00; \n\t\tif (card->fmask & pots)\n\t\t\tcard->xdata |= 0x06;\t \n\t\tif (card->fmask & led)\n\t\t\tcard->xdata |= 0x04;\t \n\t\tif ((card->fmask & pots) || (card->fmask & led)) {\n\t\t\tWriteW6692(card, W_PCTL, card->pctl);\n\t\t\tWriteW6692(card, W_XADDR, card->xaddr);\n\t\t\tWriteW6692(card, W_XDATA, card->xdata);\n\t\t\tval = ReadW6692(card, W_XADDR);\n\t\t\tif (debug & DEBUG_HW)\n\t\t\t\tpr_notice(\"%s: W_XADDR=%02x\\n\",\n\t\t\t\t\t  card->name, val);\n\t\t}\n\t}\n}\n\nstatic void\nreset_w6692(struct w6692_hw *card)\n{\n\tWriteW6692(card, W_D_CTL, W_D_CTL_SRST);\n\tmdelay(10);\n\tWriteW6692(card, W_D_CTL, 0);\n}\n\nstatic int\ninit_card(struct w6692_hw *card)\n{\n\tint\tcnt = 3;\n\tu_long\tflags;\n\n\tspin_lock_irqsave(&card->lock, flags);\n\tdisable_hwirq(card);\n\tspin_unlock_irqrestore(&card->lock, flags);\n\tif (request_irq(card->irq, w6692_irq, IRQF_SHARED, card->name, card)) {\n\t\tpr_info(\"%s: couldn't get interrupt %d\\n\", card->name,\n\t\t\tcard->irq);\n\t\treturn -EIO;\n\t}\n\twhile (cnt--) {\n\t\tspin_lock_irqsave(&card->lock, flags);\n\t\tinitW6692(card);\n\t\tenable_hwirq(card);\n\t\tspin_unlock_irqrestore(&card->lock, flags);\n\t\t \n\t\tmsleep_interruptible(10);\n\t\tif (debug & DEBUG_HW)\n\t\t\tpr_notice(\"%s: IRQ %d count %d\\n\", card->name,\n\t\t\t\t  card->irq, card->irqcnt);\n\t\tif (!card->irqcnt) {\n\t\t\tpr_info(\"%s: IRQ(%d) getting no IRQs during init %d\\n\",\n\t\t\t\tcard->name, card->irq, 3 - cnt);\n\t\t\treset_w6692(card);\n\t\t} else\n\t\t\treturn 0;\n\t}\n\tfree_irq(card->irq, card);\n\treturn -EIO;\n}\n\nstatic int\nw6692_l2l1B(struct mISDNchannel *ch, struct sk_buff *skb)\n{\n\tstruct bchannel *bch = container_of(ch, struct bchannel, ch);\n\tstruct w6692_ch\t*bc = container_of(bch, struct w6692_ch, bch);\n\tstruct w6692_hw *card = bch->hw;\n\tint ret = -EINVAL;\n\tstruct mISDNhead *hh = mISDN_HEAD_P(skb);\n\tunsigned long flags;\n\n\tswitch (hh->prim) {\n\tcase PH_DATA_REQ:\n\t\tspin_lock_irqsave(&card->lock, flags);\n\t\tret = bchannel_senddata(bch, skb);\n\t\tif (ret > 0) {  \n\t\t\tret = 0;\n\t\t\tW6692_fill_Bfifo(bc);\n\t\t}\n\t\tspin_unlock_irqrestore(&card->lock, flags);\n\t\treturn ret;\n\tcase PH_ACTIVATE_REQ:\n\t\tspin_lock_irqsave(&card->lock, flags);\n\t\tif (!test_and_set_bit(FLG_ACTIVE, &bch->Flags))\n\t\t\tret = w6692_mode(bc, ch->protocol);\n\t\telse\n\t\t\tret = 0;\n\t\tspin_unlock_irqrestore(&card->lock, flags);\n\t\tif (!ret)\n\t\t\t_queue_data(ch, PH_ACTIVATE_IND, MISDN_ID_ANY, 0,\n\t\t\t\t    NULL, GFP_KERNEL);\n\t\tbreak;\n\tcase PH_DEACTIVATE_REQ:\n\t\tspin_lock_irqsave(&card->lock, flags);\n\t\tmISDN_clear_bchannel(bch);\n\t\tw6692_mode(bc, ISDN_P_NONE);\n\t\tspin_unlock_irqrestore(&card->lock, flags);\n\t\t_queue_data(ch, PH_DEACTIVATE_IND, MISDN_ID_ANY, 0,\n\t\t\t    NULL, GFP_KERNEL);\n\t\tret = 0;\n\t\tbreak;\n\tdefault:\n\t\tpr_info(\"%s: %s unknown prim(%x,%x)\\n\",\n\t\t\tcard->name, __func__, hh->prim, hh->id);\n\t\tret = -EINVAL;\n\t}\n\tif (!ret)\n\t\tdev_kfree_skb(skb);\n\treturn ret;\n}\n\nstatic int\nchannel_bctrl(struct bchannel *bch, struct mISDN_ctrl_req *cq)\n{\n\treturn mISDN_ctrl_bchannel(bch, cq);\n}\n\nstatic int\nopen_bchannel(struct w6692_hw *card, struct channel_req *rq)\n{\n\tstruct bchannel *bch;\n\n\tif (rq->adr.channel == 0 || rq->adr.channel > 2)\n\t\treturn -EINVAL;\n\tif (rq->protocol == ISDN_P_NONE)\n\t\treturn -EINVAL;\n\tbch = &card->bc[rq->adr.channel - 1].bch;\n\tif (test_and_set_bit(FLG_OPEN, &bch->Flags))\n\t\treturn -EBUSY;  \n\tbch->ch.protocol = rq->protocol;\n\trq->ch = &bch->ch;\n\treturn 0;\n}\n\nstatic int\nchannel_ctrl(struct w6692_hw *card, struct mISDN_ctrl_req *cq)\n{\n\tint\tret = 0;\n\n\tswitch (cq->op) {\n\tcase MISDN_CTRL_GETOP:\n\t\tcq->op = MISDN_CTRL_L1_TIMER3;\n\t\tbreak;\n\tcase MISDN_CTRL_L1_TIMER3:\n\t\tret = l1_event(card->dch.l1, HW_TIMER3_VALUE | (cq->p1 & 0xff));\n\t\tbreak;\n\tdefault:\n\t\tpr_info(\"%s: unknown CTRL OP %x\\n\", card->name, cq->op);\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic int\nw6692_bctrl(struct mISDNchannel *ch, u32 cmd, void *arg)\n{\n\tstruct bchannel *bch = container_of(ch, struct bchannel, ch);\n\tstruct w6692_ch *bc = container_of(bch, struct w6692_ch, bch);\n\tstruct w6692_hw *card = bch->hw;\n\tint ret = -EINVAL;\n\tu_long flags;\n\n\tpr_debug(\"%s: %s cmd:%x %p\\n\", card->name, __func__, cmd, arg);\n\tswitch (cmd) {\n\tcase CLOSE_CHANNEL:\n\t\ttest_and_clear_bit(FLG_OPEN, &bch->Flags);\n\t\tcancel_work_sync(&bch->workq);\n\t\tspin_lock_irqsave(&card->lock, flags);\n\t\tmISDN_clear_bchannel(bch);\n\t\tw6692_mode(bc, ISDN_P_NONE);\n\t\tspin_unlock_irqrestore(&card->lock, flags);\n\t\tch->protocol = ISDN_P_NONE;\n\t\tch->peer = NULL;\n\t\tmodule_put(THIS_MODULE);\n\t\tret = 0;\n\t\tbreak;\n\tcase CONTROL_CHANNEL:\n\t\tret = channel_bctrl(bch, arg);\n\t\tbreak;\n\tdefault:\n\t\tpr_info(\"%s: %s unknown prim(%x)\\n\",\n\t\t\tcard->name, __func__, cmd);\n\t}\n\treturn ret;\n}\n\nstatic int\nw6692_l2l1D(struct mISDNchannel *ch, struct sk_buff *skb)\n{\n\tstruct mISDNdevice\t*dev = container_of(ch, struct mISDNdevice, D);\n\tstruct dchannel\t\t*dch = container_of(dev, struct dchannel, dev);\n\tstruct w6692_hw\t\t*card = container_of(dch, struct w6692_hw, dch);\n\tint\t\t\tret = -EINVAL;\n\tstruct mISDNhead\t*hh = mISDN_HEAD_P(skb);\n\tu32\t\t\tid;\n\tu_long\t\t\tflags;\n\n\tswitch (hh->prim) {\n\tcase PH_DATA_REQ:\n\t\tspin_lock_irqsave(&card->lock, flags);\n\t\tret = dchannel_senddata(dch, skb);\n\t\tif (ret > 0) {  \n\t\t\tid = hh->id;  \n\t\t\tW6692_fill_Dfifo(card);\n\t\t\tret = 0;\n\t\t\tspin_unlock_irqrestore(&card->lock, flags);\n\t\t\tqueue_ch_frame(ch, PH_DATA_CNF, id, NULL);\n\t\t} else\n\t\t\tspin_unlock_irqrestore(&card->lock, flags);\n\t\treturn ret;\n\tcase PH_ACTIVATE_REQ:\n\t\tret = l1_event(dch->l1, hh->prim);\n\t\tbreak;\n\tcase PH_DEACTIVATE_REQ:\n\t\ttest_and_clear_bit(FLG_L2_ACTIVATED, &dch->Flags);\n\t\tret = l1_event(dch->l1, hh->prim);\n\t\tbreak;\n\t}\n\n\tif (!ret)\n\t\tdev_kfree_skb(skb);\n\treturn ret;\n}\n\nstatic int\nw6692_l1callback(struct dchannel *dch, u32 cmd)\n{\n\tstruct w6692_hw *card = container_of(dch, struct w6692_hw, dch);\n\tu_long flags;\n\n\tpr_debug(\"%s: cmd(%x) state(%02x)\\n\", card->name, cmd, card->state);\n\tswitch (cmd) {\n\tcase INFO3_P8:\n\t\tspin_lock_irqsave(&card->lock, flags);\n\t\tph_command(card, W_L1CMD_AR8);\n\t\tspin_unlock_irqrestore(&card->lock, flags);\n\t\tbreak;\n\tcase INFO3_P10:\n\t\tspin_lock_irqsave(&card->lock, flags);\n\t\tph_command(card, W_L1CMD_AR10);\n\t\tspin_unlock_irqrestore(&card->lock, flags);\n\t\tbreak;\n\tcase HW_RESET_REQ:\n\t\tspin_lock_irqsave(&card->lock, flags);\n\t\tif (card->state != W_L1IND_DRD)\n\t\t\tph_command(card, W_L1CMD_RST);\n\t\tph_command(card, W_L1CMD_ECK);\n\t\tspin_unlock_irqrestore(&card->lock, flags);\n\t\tbreak;\n\tcase HW_DEACT_REQ:\n\t\tskb_queue_purge(&dch->squeue);\n\t\tif (dch->tx_skb) {\n\t\t\tdev_kfree_skb(dch->tx_skb);\n\t\t\tdch->tx_skb = NULL;\n\t\t}\n\t\tdch->tx_idx = 0;\n\t\tif (dch->rx_skb) {\n\t\t\tdev_kfree_skb(dch->rx_skb);\n\t\t\tdch->rx_skb = NULL;\n\t\t}\n\t\ttest_and_clear_bit(FLG_TX_BUSY, &dch->Flags);\n\t\tif (test_and_clear_bit(FLG_BUSY_TIMER, &dch->Flags))\n\t\t\tdel_timer(&dch->timer);\n\t\tbreak;\n\tcase HW_POWERUP_REQ:\n\t\tspin_lock_irqsave(&card->lock, flags);\n\t\tph_command(card, W_L1CMD_ECK);\n\t\tspin_unlock_irqrestore(&card->lock, flags);\n\t\tbreak;\n\tcase PH_ACTIVATE_IND:\n\t\ttest_and_set_bit(FLG_ACTIVE, &dch->Flags);\n\t\t_queue_data(&dch->dev.D, cmd, MISDN_ID_ANY, 0, NULL,\n\t\t\t    GFP_ATOMIC);\n\t\tbreak;\n\tcase PH_DEACTIVATE_IND:\n\t\ttest_and_clear_bit(FLG_ACTIVE, &dch->Flags);\n\t\t_queue_data(&dch->dev.D, cmd, MISDN_ID_ANY, 0, NULL,\n\t\t\t    GFP_ATOMIC);\n\t\tbreak;\n\tdefault:\n\t\tpr_debug(\"%s: %s unknown command %x\\n\", card->name,\n\t\t\t __func__, cmd);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int\nopen_dchannel(struct w6692_hw *card, struct channel_req *rq, void *caller)\n{\n\tpr_debug(\"%s: %s dev(%d) open from %p\\n\", card->name, __func__,\n\t\t card->dch.dev.id, caller);\n\tif (rq->protocol != ISDN_P_TE_S0)\n\t\treturn -EINVAL;\n\tif (rq->adr.channel == 1)\n\t\t \n\t\treturn -EINVAL;\n\trq->ch = &card->dch.dev.D;\n\trq->ch->protocol = rq->protocol;\n\tif (card->dch.state == 7)\n\t\t_queue_data(rq->ch, PH_ACTIVATE_IND, MISDN_ID_ANY,\n\t\t\t    0, NULL, GFP_KERNEL);\n\treturn 0;\n}\n\nstatic int\nw6692_dctrl(struct mISDNchannel *ch, u32 cmd, void *arg)\n{\n\tstruct mISDNdevice *dev = container_of(ch, struct mISDNdevice, D);\n\tstruct dchannel *dch = container_of(dev, struct dchannel, dev);\n\tstruct w6692_hw *card = container_of(dch, struct w6692_hw, dch);\n\tstruct channel_req *rq;\n\tint err = 0;\n\n\tpr_debug(\"%s: DCTRL: %x %p\\n\", card->name, cmd, arg);\n\tswitch (cmd) {\n\tcase OPEN_CHANNEL:\n\t\trq = arg;\n\t\tif (rq->protocol == ISDN_P_TE_S0)\n\t\t\terr = open_dchannel(card, rq, __builtin_return_address(0));\n\t\telse\n\t\t\terr = open_bchannel(card, rq);\n\t\tif (err)\n\t\t\tbreak;\n\t\tif (!try_module_get(THIS_MODULE))\n\t\t\tpr_info(\"%s: cannot get module\\n\", card->name);\n\t\tbreak;\n\tcase CLOSE_CHANNEL:\n\t\tpr_debug(\"%s: dev(%d) close from %p\\n\", card->name,\n\t\t\t dch->dev.id, __builtin_return_address(0));\n\t\tmodule_put(THIS_MODULE);\n\t\tbreak;\n\tcase CONTROL_CHANNEL:\n\t\terr = channel_ctrl(card, arg);\n\t\tbreak;\n\tdefault:\n\t\tpr_debug(\"%s: unknown DCTRL command %x\\n\", card->name, cmd);\n\t\treturn -EINVAL;\n\t}\n\treturn err;\n}\n\nstatic int\nsetup_w6692(struct w6692_hw *card)\n{\n\tu32\tval;\n\n\tif (!request_region(card->addr, 256, card->name)) {\n\t\tpr_info(\"%s: config port %x-%x already in use\\n\", card->name,\n\t\t\tcard->addr, card->addr + 255);\n\t\treturn -EIO;\n\t}\n\tW6692Version(card);\n\tcard->bc[0].addr = card->addr;\n\tcard->bc[1].addr = card->addr + 0x40;\n\tval = ReadW6692(card, W_ISTA);\n\tif (debug & DEBUG_HW)\n\t\tpr_notice(\"%s ISTA=%02x\\n\", card->name, val);\n\tval = ReadW6692(card, W_IMASK);\n\tif (debug & DEBUG_HW)\n\t\tpr_notice(\"%s IMASK=%02x\\n\", card->name, val);\n\tval = ReadW6692(card, W_D_EXIR);\n\tif (debug & DEBUG_HW)\n\t\tpr_notice(\"%s D_EXIR=%02x\\n\", card->name, val);\n\tval = ReadW6692(card, W_D_EXIM);\n\tif (debug & DEBUG_HW)\n\t\tpr_notice(\"%s D_EXIM=%02x\\n\", card->name, val);\n\tval = ReadW6692(card, W_D_RSTA);\n\tif (debug & DEBUG_HW)\n\t\tpr_notice(\"%s D_RSTA=%02x\\n\", card->name, val);\n\treturn 0;\n}\n\nstatic void\nrelease_card(struct w6692_hw *card)\n{\n\tu_long\tflags;\n\n\tspin_lock_irqsave(&card->lock, flags);\n\tdisable_hwirq(card);\n\tw6692_mode(&card->bc[0], ISDN_P_NONE);\n\tw6692_mode(&card->bc[1], ISDN_P_NONE);\n\tif ((card->fmask & led) || card->subtype == W6692_USR) {\n\t\tcard->xdata |= 0x04;\t \n\t\tWriteW6692(card, W_XDATA, card->xdata);\n\t}\n\tspin_unlock_irqrestore(&card->lock, flags);\n\tfree_irq(card->irq, card);\n\tl1_event(card->dch.l1, CLOSE_CHANNEL);\n\tmISDN_unregister_device(&card->dch.dev);\n\trelease_region(card->addr, 256);\n\tmISDN_freebchannel(&card->bc[1].bch);\n\tmISDN_freebchannel(&card->bc[0].bch);\n\tmISDN_freedchannel(&card->dch);\n\twrite_lock_irqsave(&card_lock, flags);\n\tlist_del(&card->list);\n\twrite_unlock_irqrestore(&card_lock, flags);\n\tpci_disable_device(card->pdev);\n\tpci_set_drvdata(card->pdev, NULL);\n\tkfree(card);\n}\n\nstatic int\nsetup_instance(struct w6692_hw *card)\n{\n\tint\t\ti, err;\n\tu_long\t\tflags;\n\n\tsnprintf(card->name, MISDN_MAX_IDLEN - 1, \"w6692.%d\", w6692_cnt + 1);\n\twrite_lock_irqsave(&card_lock, flags);\n\tlist_add_tail(&card->list, &Cards);\n\twrite_unlock_irqrestore(&card_lock, flags);\n\tcard->fmask = (1 << w6692_cnt);\n\t_set_debug(card);\n\tspin_lock_init(&card->lock);\n\tmISDN_initdchannel(&card->dch, MAX_DFRAME_LEN_L1, W6692_ph_bh);\n\tcard->dch.dev.Dprotocols = (1 << ISDN_P_TE_S0);\n\tcard->dch.dev.D.send = w6692_l2l1D;\n\tcard->dch.dev.D.ctrl = w6692_dctrl;\n\tcard->dch.dev.Bprotocols = (1 << (ISDN_P_B_RAW & ISDN_P_B_MASK)) |\n\t\t(1 << (ISDN_P_B_HDLC & ISDN_P_B_MASK));\n\tcard->dch.hw = card;\n\tcard->dch.dev.nrbchan = 2;\n\tfor (i = 0; i < 2; i++) {\n\t\tmISDN_initbchannel(&card->bc[i].bch, MAX_DATA_MEM,\n\t\t\t\t   W_B_FIFO_THRESH);\n\t\tcard->bc[i].bch.hw = card;\n\t\tcard->bc[i].bch.nr = i + 1;\n\t\tcard->bc[i].bch.ch.nr = i + 1;\n\t\tcard->bc[i].bch.ch.send = w6692_l2l1B;\n\t\tcard->bc[i].bch.ch.ctrl = w6692_bctrl;\n\t\tset_channelmap(i + 1, card->dch.dev.channelmap);\n\t\tlist_add(&card->bc[i].bch.ch.list, &card->dch.dev.bchannels);\n\t}\n\terr = setup_w6692(card);\n\tif (err)\n\t\tgoto error_setup;\n\terr = mISDN_register_device(&card->dch.dev, &card->pdev->dev,\n\t\t\t\t    card->name);\n\tif (err)\n\t\tgoto error_reg;\n\terr = init_card(card);\n\tif (err)\n\t\tgoto error_init;\n\terr = create_l1(&card->dch, w6692_l1callback);\n\tif (!err) {\n\t\tw6692_cnt++;\n\t\tpr_notice(\"W6692 %d cards installed\\n\", w6692_cnt);\n\t\treturn 0;\n\t}\n\n\tfree_irq(card->irq, card);\nerror_init:\n\tmISDN_unregister_device(&card->dch.dev);\nerror_reg:\n\trelease_region(card->addr, 256);\nerror_setup:\n\tmISDN_freebchannel(&card->bc[1].bch);\n\tmISDN_freebchannel(&card->bc[0].bch);\n\tmISDN_freedchannel(&card->dch);\n\twrite_lock_irqsave(&card_lock, flags);\n\tlist_del(&card->list);\n\twrite_unlock_irqrestore(&card_lock, flags);\n\tkfree(card);\n\treturn err;\n}\n\nstatic int\nw6692_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tint\t\terr = -ENOMEM;\n\tstruct w6692_hw\t*card;\n\tstruct w6692map\t*m = (struct w6692map *)ent->driver_data;\n\n\tcard = kzalloc(sizeof(struct w6692_hw), GFP_KERNEL);\n\tif (!card) {\n\t\tpr_info(\"No kmem for w6692 card\\n\");\n\t\treturn err;\n\t}\n\tcard->pdev = pdev;\n\tcard->subtype = m->subtype;\n\terr = pci_enable_device(pdev);\n\tif (err) {\n\t\tkfree(card);\n\t\treturn err;\n\t}\n\n\tprintk(KERN_INFO \"mISDN_w6692: found adapter %s at %s\\n\",\n\t       m->name, pci_name(pdev));\n\n\tcard->addr = pci_resource_start(pdev, 1);\n\tcard->irq = pdev->irq;\n\tpci_set_drvdata(pdev, card);\n\terr = setup_instance(card);\n\tif (err)\n\t\tpci_set_drvdata(pdev, NULL);\n\treturn err;\n}\n\nstatic void\nw6692_remove_pci(struct pci_dev *pdev)\n{\n\tstruct w6692_hw\t*card = pci_get_drvdata(pdev);\n\n\tif (card)\n\t\trelease_card(card);\n\telse\n\t\tif (debug)\n\t\t\tpr_notice(\"%s: drvdata already removed\\n\", __func__);\n}\n\nstatic const struct pci_device_id w6692_ids[] = {\n\t{ PCI_VENDOR_ID_DYNALINK, PCI_DEVICE_ID_DYNALINK_IS64PH,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, (ulong)&w6692_map[0]},\n\t{ PCI_VENDOR_ID_WINBOND2, PCI_DEVICE_ID_WINBOND2_6692,\n\t  PCI_VENDOR_ID_USR, PCI_DEVICE_ID_USR_6692, 0, 0,\n\t  (ulong)&w6692_map[2]},\n\t{ PCI_VENDOR_ID_WINBOND2, PCI_DEVICE_ID_WINBOND2_6692,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, (ulong)&w6692_map[1]},\n\t{ }\n};\nMODULE_DEVICE_TABLE(pci, w6692_ids);\n\nstatic struct pci_driver w6692_driver = {\n\t.name =  \"w6692\",\n\t.probe = w6692_probe,\n\t.remove = w6692_remove_pci,\n\t.id_table = w6692_ids,\n};\n\nstatic int __init w6692_init(void)\n{\n\tint err;\n\n\tpr_notice(\"Winbond W6692 PCI driver Rev. %s\\n\", W6692_REV);\n\n\terr = pci_register_driver(&w6692_driver);\n\treturn err;\n}\n\nstatic void __exit w6692_cleanup(void)\n{\n\tpci_unregister_driver(&w6692_driver);\n}\n\nmodule_init(w6692_init);\nmodule_exit(w6692_cleanup);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}