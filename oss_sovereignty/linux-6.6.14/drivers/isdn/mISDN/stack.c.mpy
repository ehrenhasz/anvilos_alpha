{
  "module_name": "stack.c",
  "hash_id": "02df57a478bfa3fe64b65b193e4a9cfe46f089003b28ff5eba4c4116fcf39f14",
  "original_prompt": "Ingested from linux-6.6.14/drivers/isdn/mISDN/stack.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/mISDNif.h>\n#include <linux/kthread.h>\n#include <linux/sched.h>\n#include <linux/sched/cputime.h>\n#include <linux/signal.h>\n\n#include \"core.h\"\n\nstatic u_int\t*debug;\n\nstatic inline void\n_queue_message(struct mISDNstack *st, struct sk_buff *skb)\n{\n\tstruct mISDNhead\t*hh = mISDN_HEAD_P(skb);\n\n\tif (*debug & DEBUG_QUEUE_FUNC)\n\t\tprintk(KERN_DEBUG \"%s prim(%x) id(%x) %p\\n\",\n\t\t       __func__, hh->prim, hh->id, skb);\n\tskb_queue_tail(&st->msgq, skb);\n\tif (likely(!test_bit(mISDN_STACK_STOPPED, &st->status))) {\n\t\ttest_and_set_bit(mISDN_STACK_WORK, &st->status);\n\t\twake_up_interruptible(&st->workq);\n\t}\n}\n\nstatic int\nmISDN_queue_message(struct mISDNchannel *ch, struct sk_buff *skb)\n{\n\t_queue_message(ch->st, skb);\n\treturn 0;\n}\n\nstatic struct mISDNchannel *\nget_channel4id(struct mISDNstack *st, u_int id)\n{\n\tstruct mISDNchannel\t*ch;\n\n\tmutex_lock(&st->lmutex);\n\tlist_for_each_entry(ch, &st->layer2, list) {\n\t\tif (id == ch->nr)\n\t\t\tgoto unlock;\n\t}\n\tch = NULL;\nunlock:\n\tmutex_unlock(&st->lmutex);\n\treturn ch;\n}\n\nstatic void\nsend_socklist(struct mISDN_sock_list *sl, struct sk_buff *skb)\n{\n\tstruct sock\t\t*sk;\n\tstruct sk_buff\t\t*cskb = NULL;\n\n\tread_lock(&sl->lock);\n\tsk_for_each(sk, &sl->head) {\n\t\tif (sk->sk_state != MISDN_BOUND)\n\t\t\tcontinue;\n\t\tif (!cskb)\n\t\t\tcskb = skb_copy(skb, GFP_ATOMIC);\n\t\tif (!cskb) {\n\t\t\tprintk(KERN_WARNING \"%s no skb\\n\", __func__);\n\t\t\tbreak;\n\t\t}\n\t\tif (!sock_queue_rcv_skb(sk, cskb))\n\t\t\tcskb = NULL;\n\t}\n\tread_unlock(&sl->lock);\n\tdev_kfree_skb(cskb);\n}\n\nstatic void\nsend_layer2(struct mISDNstack *st, struct sk_buff *skb)\n{\n\tstruct sk_buff\t\t*cskb;\n\tstruct mISDNhead\t*hh = mISDN_HEAD_P(skb);\n\tstruct mISDNchannel\t*ch;\n\tint\t\t\tret;\n\n\tif (!st)\n\t\treturn;\n\tmutex_lock(&st->lmutex);\n\tif ((hh->id & MISDN_ID_ADDR_MASK) == MISDN_ID_ANY) {  \n\t\tlist_for_each_entry(ch, &st->layer2, list) {\n\t\t\tif (list_is_last(&ch->list, &st->layer2)) {\n\t\t\t\tcskb = skb;\n\t\t\t\tskb = NULL;\n\t\t\t} else {\n\t\t\t\tcskb = skb_copy(skb, GFP_KERNEL);\n\t\t\t}\n\t\t\tif (cskb) {\n\t\t\t\tret = ch->send(ch, cskb);\n\t\t\t\tif (ret) {\n\t\t\t\t\tif (*debug & DEBUG_SEND_ERR)\n\t\t\t\t\t\tprintk(KERN_DEBUG\n\t\t\t\t\t\t       \"%s ch%d prim(%x) addr(%x)\"\n\t\t\t\t\t\t       \" err %d\\n\",\n\t\t\t\t\t\t       __func__, ch->nr,\n\t\t\t\t\t\t       hh->prim, ch->addr, ret);\n\t\t\t\t\tdev_kfree_skb(cskb);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tprintk(KERN_WARNING \"%s ch%d addr %x no mem\\n\",\n\t\t\t\t       __func__, ch->nr, ch->addr);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tlist_for_each_entry(ch, &st->layer2, list) {\n\t\t\tif ((hh->id & MISDN_ID_ADDR_MASK) == ch->addr) {\n\t\t\t\tret = ch->send(ch, skb);\n\t\t\t\tif (!ret)\n\t\t\t\t\tskb = NULL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tret = st->dev->teimgr->ctrl(st->dev->teimgr, CHECK_DATA, skb);\n\t\tif (!ret)\n\t\t\tskb = NULL;\n\t\telse if (*debug & DEBUG_SEND_ERR)\n\t\t\tprintk(KERN_DEBUG\n\t\t\t       \"%s mgr prim(%x) err %d\\n\",\n\t\t\t       __func__, hh->prim, ret);\n\t}\nout:\n\tmutex_unlock(&st->lmutex);\n\tdev_kfree_skb(skb);\n}\n\nstatic inline int\nsend_msg_to_layer(struct mISDNstack *st, struct sk_buff *skb)\n{\n\tstruct mISDNhead\t*hh = mISDN_HEAD_P(skb);\n\tstruct mISDNchannel\t*ch;\n\tint\tlm;\n\n\tlm = hh->prim & MISDN_LAYERMASK;\n\tif (*debug & DEBUG_QUEUE_FUNC)\n\t\tprintk(KERN_DEBUG \"%s prim(%x) id(%x) %p\\n\",\n\t\t       __func__, hh->prim, hh->id, skb);\n\tif (lm == 0x1) {\n\t\tif (!hlist_empty(&st->l1sock.head)) {\n\t\t\t__net_timestamp(skb);\n\t\t\tsend_socklist(&st->l1sock, skb);\n\t\t}\n\t\treturn st->layer1->send(st->layer1, skb);\n\t} else if (lm == 0x2) {\n\t\tif (!hlist_empty(&st->l1sock.head))\n\t\t\tsend_socklist(&st->l1sock, skb);\n\t\tsend_layer2(st, skb);\n\t\treturn 0;\n\t} else if (lm == 0x4) {\n\t\tch = get_channel4id(st, hh->id);\n\t\tif (ch)\n\t\t\treturn ch->send(ch, skb);\n\t\telse\n\t\t\tprintk(KERN_WARNING\n\t\t\t       \"%s: dev(%s) prim(%x) id(%x) no channel\\n\",\n\t\t\t       __func__, dev_name(&st->dev->dev), hh->prim,\n\t\t\t       hh->id);\n\t} else if (lm == 0x8) {\n\t\tWARN_ON(lm == 0x8);\n\t\tch = get_channel4id(st, hh->id);\n\t\tif (ch)\n\t\t\treturn ch->send(ch, skb);\n\t\telse\n\t\t\tprintk(KERN_WARNING\n\t\t\t       \"%s: dev(%s) prim(%x) id(%x) no channel\\n\",\n\t\t\t       __func__, dev_name(&st->dev->dev), hh->prim,\n\t\t\t       hh->id);\n\t} else {\n\t\t \n\t\tprintk(KERN_WARNING \"%s: dev(%s) prim %x not delivered\\n\",\n\t\t       __func__, dev_name(&st->dev->dev), hh->prim);\n\t}\n\treturn -ESRCH;\n}\n\nstatic void\ndo_clear_stack(struct mISDNstack *st)\n{\n}\n\nstatic int\nmISDNStackd(void *data)\n{\n\tstruct mISDNstack *st = data;\n#ifdef MISDN_MSG_STATS\n\tu64 utime, stime;\n#endif\n\tint err = 0;\n\n\tsigfillset(&current->blocked);\n\tif (*debug & DEBUG_MSG_THREAD)\n\t\tprintk(KERN_DEBUG \"mISDNStackd %s started\\n\",\n\t\t       dev_name(&st->dev->dev));\n\n\tif (st->notify != NULL) {\n\t\tcomplete(st->notify);\n\t\tst->notify = NULL;\n\t}\n\n\tfor (;;) {\n\t\tstruct sk_buff\t*skb;\n\n\t\tif (unlikely(test_bit(mISDN_STACK_STOPPED, &st->status))) {\n\t\t\ttest_and_clear_bit(mISDN_STACK_WORK, &st->status);\n\t\t\ttest_and_clear_bit(mISDN_STACK_RUNNING, &st->status);\n\t\t} else\n\t\t\ttest_and_set_bit(mISDN_STACK_RUNNING, &st->status);\n\t\twhile (test_bit(mISDN_STACK_WORK, &st->status)) {\n\t\t\tskb = skb_dequeue(&st->msgq);\n\t\t\tif (!skb) {\n\t\t\t\ttest_and_clear_bit(mISDN_STACK_WORK,\n\t\t\t\t\t\t   &st->status);\n\t\t\t\t \n\t\t\t\tskb = skb_dequeue(&st->msgq);\n\t\t\t\tif (!skb)\n\t\t\t\t\tcontinue;\n\t\t\t\ttest_and_set_bit(mISDN_STACK_WORK,\n\t\t\t\t\t\t &st->status);\n\t\t\t}\n#ifdef MISDN_MSG_STATS\n\t\t\tst->msg_cnt++;\n#endif\n\t\t\terr = send_msg_to_layer(st, skb);\n\t\t\tif (unlikely(err)) {\n\t\t\t\tif (*debug & DEBUG_SEND_ERR)\n\t\t\t\t\tprintk(KERN_DEBUG\n\t\t\t\t\t       \"%s: %s prim(%x) id(%x) \"\n\t\t\t\t\t       \"send call(%d)\\n\",\n\t\t\t\t\t       __func__, dev_name(&st->dev->dev),\n\t\t\t\t\t       mISDN_HEAD_PRIM(skb),\n\t\t\t\t\t       mISDN_HEAD_ID(skb), err);\n\t\t\t\tdev_kfree_skb(skb);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (unlikely(test_bit(mISDN_STACK_STOPPED,\n\t\t\t\t\t      &st->status))) {\n\t\t\t\ttest_and_clear_bit(mISDN_STACK_WORK,\n\t\t\t\t\t\t   &st->status);\n\t\t\t\ttest_and_clear_bit(mISDN_STACK_RUNNING,\n\t\t\t\t\t\t   &st->status);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (test_bit(mISDN_STACK_CLEARING, &st->status)) {\n\t\t\ttest_and_set_bit(mISDN_STACK_STOPPED, &st->status);\n\t\t\ttest_and_clear_bit(mISDN_STACK_RUNNING, &st->status);\n\t\t\tdo_clear_stack(st);\n\t\t\ttest_and_clear_bit(mISDN_STACK_CLEARING, &st->status);\n\t\t\ttest_and_set_bit(mISDN_STACK_RESTART, &st->status);\n\t\t}\n\t\tif (test_and_clear_bit(mISDN_STACK_RESTART, &st->status)) {\n\t\t\ttest_and_clear_bit(mISDN_STACK_STOPPED, &st->status);\n\t\t\ttest_and_set_bit(mISDN_STACK_RUNNING, &st->status);\n\t\t\tif (!skb_queue_empty(&st->msgq))\n\t\t\t\ttest_and_set_bit(mISDN_STACK_WORK,\n\t\t\t\t\t\t &st->status);\n\t\t}\n\t\tif (test_bit(mISDN_STACK_ABORT, &st->status))\n\t\t\tbreak;\n\t\tif (st->notify != NULL) {\n\t\t\tcomplete(st->notify);\n\t\t\tst->notify = NULL;\n\t\t}\n#ifdef MISDN_MSG_STATS\n\t\tst->sleep_cnt++;\n#endif\n\t\ttest_and_clear_bit(mISDN_STACK_ACTIVE, &st->status);\n\t\twait_event_interruptible(st->workq, (st->status &\n\t\t\t\t\t\t     mISDN_STACK_ACTION_MASK));\n\t\tif (*debug & DEBUG_MSG_THREAD)\n\t\t\tprintk(KERN_DEBUG \"%s: %s wake status %08lx\\n\",\n\t\t\t       __func__, dev_name(&st->dev->dev), st->status);\n\t\ttest_and_set_bit(mISDN_STACK_ACTIVE, &st->status);\n\n\t\ttest_and_clear_bit(mISDN_STACK_WAKEUP, &st->status);\n\n\t\tif (test_bit(mISDN_STACK_STOPPED, &st->status)) {\n\t\t\ttest_and_clear_bit(mISDN_STACK_RUNNING, &st->status);\n#ifdef MISDN_MSG_STATS\n\t\t\tst->stopped_cnt++;\n#endif\n\t\t}\n\t}\n#ifdef MISDN_MSG_STATS\n\tprintk(KERN_DEBUG \"mISDNStackd daemon for %s proceed %d \"\n\t       \"msg %d sleep %d stopped\\n\",\n\t       dev_name(&st->dev->dev), st->msg_cnt, st->sleep_cnt,\n\t       st->stopped_cnt);\n\ttask_cputime(st->thread, &utime, &stime);\n\tprintk(KERN_DEBUG\n\t       \"mISDNStackd daemon for %s utime(%llu) stime(%llu)\\n\",\n\t       dev_name(&st->dev->dev), utime, stime);\n\tprintk(KERN_DEBUG\n\t       \"mISDNStackd daemon for %s nvcsw(%ld) nivcsw(%ld)\\n\",\n\t       dev_name(&st->dev->dev), st->thread->nvcsw, st->thread->nivcsw);\n\tprintk(KERN_DEBUG \"mISDNStackd daemon for %s killed now\\n\",\n\t       dev_name(&st->dev->dev));\n#endif\n\ttest_and_set_bit(mISDN_STACK_KILLED, &st->status);\n\ttest_and_clear_bit(mISDN_STACK_RUNNING, &st->status);\n\ttest_and_clear_bit(mISDN_STACK_ACTIVE, &st->status);\n\ttest_and_clear_bit(mISDN_STACK_ABORT, &st->status);\n\tskb_queue_purge(&st->msgq);\n\tst->thread = NULL;\n\tif (st->notify != NULL) {\n\t\tcomplete(st->notify);\n\t\tst->notify = NULL;\n\t}\n\treturn 0;\n}\n\nstatic int\nl1_receive(struct mISDNchannel *ch, struct sk_buff *skb)\n{\n\tif (!ch->st)\n\t\treturn -ENODEV;\n\t__net_timestamp(skb);\n\t_queue_message(ch->st, skb);\n\treturn 0;\n}\n\nvoid\nset_channel_address(struct mISDNchannel *ch, u_int sapi, u_int tei)\n{\n\tch->addr = sapi | (tei << 8);\n}\n\nvoid\n__add_layer2(struct mISDNchannel *ch, struct mISDNstack *st)\n{\n\tlist_add_tail(&ch->list, &st->layer2);\n}\n\nvoid\nadd_layer2(struct mISDNchannel *ch, struct mISDNstack *st)\n{\n\tmutex_lock(&st->lmutex);\n\t__add_layer2(ch, st);\n\tmutex_unlock(&st->lmutex);\n}\n\nstatic int\nst_own_ctrl(struct mISDNchannel *ch, u_int cmd, void *arg)\n{\n\tif (!ch->st || !ch->st->layer1)\n\t\treturn -EINVAL;\n\treturn ch->st->layer1->ctrl(ch->st->layer1, cmd, arg);\n}\n\nint\ncreate_stack(struct mISDNdevice *dev)\n{\n\tstruct mISDNstack\t*newst;\n\tint\t\t\terr;\n\tDECLARE_COMPLETION_ONSTACK(done);\n\n\tnewst = kzalloc(sizeof(struct mISDNstack), GFP_KERNEL);\n\tif (!newst) {\n\t\tprintk(KERN_ERR \"kmalloc mISDN_stack failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tnewst->dev = dev;\n\tINIT_LIST_HEAD(&newst->layer2);\n\tINIT_HLIST_HEAD(&newst->l1sock.head);\n\trwlock_init(&newst->l1sock.lock);\n\tinit_waitqueue_head(&newst->workq);\n\tskb_queue_head_init(&newst->msgq);\n\tmutex_init(&newst->lmutex);\n\tdev->D.st = newst;\n\terr = create_teimanager(dev);\n\tif (err) {\n\t\tprintk(KERN_ERR \"kmalloc teimanager failed\\n\");\n\t\tkfree(newst);\n\t\treturn err;\n\t}\n\tdev->teimgr->peer = &newst->own;\n\tdev->teimgr->recv = mISDN_queue_message;\n\tdev->teimgr->st = newst;\n\tnewst->layer1 = &dev->D;\n\tdev->D.recv = l1_receive;\n\tdev->D.peer = &newst->own;\n\tnewst->own.st = newst;\n\tnewst->own.ctrl = st_own_ctrl;\n\tnewst->own.send = mISDN_queue_message;\n\tnewst->own.recv = mISDN_queue_message;\n\tif (*debug & DEBUG_CORE_FUNC)\n\t\tprintk(KERN_DEBUG \"%s: st(%s)\\n\", __func__,\n\t\t       dev_name(&newst->dev->dev));\n\tnewst->notify = &done;\n\tnewst->thread = kthread_run(mISDNStackd, (void *)newst, \"mISDN_%s\",\n\t\t\t\t    dev_name(&newst->dev->dev));\n\tif (IS_ERR(newst->thread)) {\n\t\terr = PTR_ERR(newst->thread);\n\t\tprintk(KERN_ERR\n\t\t       \"mISDN:cannot create kernel thread for %s (%d)\\n\",\n\t\t       dev_name(&newst->dev->dev), err);\n\t\tdelete_teimanager(dev->teimgr);\n\t\tkfree(newst);\n\t} else\n\t\twait_for_completion(&done);\n\treturn err;\n}\n\nint\nconnect_layer1(struct mISDNdevice *dev, struct mISDNchannel *ch,\n\t       u_int protocol, struct sockaddr_mISDN *adr)\n{\n\tstruct mISDN_sock\t*msk = container_of(ch, struct mISDN_sock, ch);\n\tstruct channel_req\trq;\n\tint\t\t\terr;\n\n\n\tif (*debug &  DEBUG_CORE_FUNC)\n\t\tprintk(KERN_DEBUG \"%s: %s proto(%x) adr(%d %d %d %d)\\n\",\n\t\t       __func__, dev_name(&dev->dev), protocol, adr->dev,\n\t\t       adr->channel, adr->sapi, adr->tei);\n\tswitch (protocol) {\n\tcase ISDN_P_NT_S0:\n\tcase ISDN_P_NT_E1:\n\tcase ISDN_P_TE_S0:\n\tcase ISDN_P_TE_E1:\n\t\tch->recv = mISDN_queue_message;\n\t\tch->peer = &dev->D.st->own;\n\t\tch->st = dev->D.st;\n\t\trq.protocol = protocol;\n\t\trq.adr.channel = adr->channel;\n\t\terr = dev->D.ctrl(&dev->D, OPEN_CHANNEL, &rq);\n\t\tprintk(KERN_DEBUG \"%s: ret %d (dev %d)\\n\", __func__, err,\n\t\t       dev->id);\n\t\tif (err)\n\t\t\treturn err;\n\t\twrite_lock_bh(&dev->D.st->l1sock.lock);\n\t\tsk_add_node(&msk->sk, &dev->D.st->l1sock.head);\n\t\twrite_unlock_bh(&dev->D.st->l1sock.lock);\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOPROTOOPT;\n\t}\n\treturn 0;\n}\n\nint\nconnect_Bstack(struct mISDNdevice *dev, struct mISDNchannel *ch,\n\t       u_int protocol, struct sockaddr_mISDN *adr)\n{\n\tstruct channel_req\trq, rq2;\n\tint\t\t\tpmask, err;\n\tstruct Bprotocol\t*bp;\n\n\tif (*debug &  DEBUG_CORE_FUNC)\n\t\tprintk(KERN_DEBUG \"%s: %s proto(%x) adr(%d %d %d %d)\\n\",\n\t\t       __func__, dev_name(&dev->dev), protocol,\n\t\t       adr->dev, adr->channel, adr->sapi,\n\t\t       adr->tei);\n\tch->st = dev->D.st;\n\tpmask = 1 << (protocol & ISDN_P_B_MASK);\n\tif (pmask & dev->Bprotocols) {\n\t\trq.protocol = protocol;\n\t\trq.adr = *adr;\n\t\terr = dev->D.ctrl(&dev->D, OPEN_CHANNEL, &rq);\n\t\tif (err)\n\t\t\treturn err;\n\t\tch->recv = rq.ch->send;\n\t\tch->peer = rq.ch;\n\t\trq.ch->recv = ch->send;\n\t\trq.ch->peer = ch;\n\t\trq.ch->st = dev->D.st;\n\t} else {\n\t\tbp = get_Bprotocol4mask(pmask);\n\t\tif (!bp)\n\t\t\treturn -ENOPROTOOPT;\n\t\trq2.protocol = protocol;\n\t\trq2.adr = *adr;\n\t\trq2.ch = ch;\n\t\terr = bp->create(&rq2);\n\t\tif (err)\n\t\t\treturn err;\n\t\tch->recv = rq2.ch->send;\n\t\tch->peer = rq2.ch;\n\t\trq2.ch->st = dev->D.st;\n\t\trq.protocol = rq2.protocol;\n\t\trq.adr = *adr;\n\t\terr = dev->D.ctrl(&dev->D, OPEN_CHANNEL, &rq);\n\t\tif (err) {\n\t\t\trq2.ch->ctrl(rq2.ch, CLOSE_CHANNEL, NULL);\n\t\t\treturn err;\n\t\t}\n\t\trq2.ch->recv = rq.ch->send;\n\t\trq2.ch->peer = rq.ch;\n\t\trq.ch->recv = rq2.ch->send;\n\t\trq.ch->peer = rq2.ch;\n\t\trq.ch->st = dev->D.st;\n\t}\n\tch->protocol = protocol;\n\tch->nr = rq.ch->nr;\n\treturn 0;\n}\n\nint\ncreate_l2entity(struct mISDNdevice *dev, struct mISDNchannel *ch,\n\t\tu_int protocol, struct sockaddr_mISDN *adr)\n{\n\tstruct channel_req\trq;\n\tint\t\t\terr;\n\n\tif (*debug &  DEBUG_CORE_FUNC)\n\t\tprintk(KERN_DEBUG \"%s: %s proto(%x) adr(%d %d %d %d)\\n\",\n\t\t       __func__, dev_name(&dev->dev), protocol,\n\t\t       adr->dev, adr->channel, adr->sapi,\n\t\t       adr->tei);\n\trq.protocol = ISDN_P_TE_S0;\n\tif (dev->Dprotocols & (1 << ISDN_P_TE_E1))\n\t\trq.protocol = ISDN_P_TE_E1;\n\tswitch (protocol) {\n\tcase ISDN_P_LAPD_NT:\n\t\trq.protocol = ISDN_P_NT_S0;\n\t\tif (dev->Dprotocols & (1 << ISDN_P_NT_E1))\n\t\t\trq.protocol = ISDN_P_NT_E1;\n\t\tfallthrough;\n\tcase ISDN_P_LAPD_TE:\n\t\tch->recv = mISDN_queue_message;\n\t\tch->peer = &dev->D.st->own;\n\t\tch->st = dev->D.st;\n\t\trq.adr.channel = 0;\n\t\terr = dev->D.ctrl(&dev->D, OPEN_CHANNEL, &rq);\n\t\tprintk(KERN_DEBUG \"%s: ret 1 %d\\n\", __func__, err);\n\t\tif (err)\n\t\t\tbreak;\n\t\trq.protocol = protocol;\n\t\trq.adr = *adr;\n\t\trq.ch = ch;\n\t\terr = dev->teimgr->ctrl(dev->teimgr, OPEN_CHANNEL, &rq);\n\t\tprintk(KERN_DEBUG \"%s: ret 2 %d\\n\", __func__, err);\n\t\tif (!err) {\n\t\t\tif ((protocol == ISDN_P_LAPD_NT) && !rq.ch)\n\t\t\t\tbreak;\n\t\t\tadd_layer2(rq.ch, dev->D.st);\n\t\t\trq.ch->recv = mISDN_queue_message;\n\t\t\trq.ch->peer = &dev->D.st->own;\n\t\t\trq.ch->ctrl(rq.ch, OPEN_CHANNEL, NULL);  \n\t\t}\n\t\tbreak;\n\tdefault:\n\t\terr = -EPROTONOSUPPORT;\n\t}\n\treturn err;\n}\n\nvoid\ndelete_channel(struct mISDNchannel *ch)\n{\n\tstruct mISDN_sock\t*msk = container_of(ch, struct mISDN_sock, ch);\n\tstruct mISDNchannel\t*pch;\n\n\tif (!ch->st) {\n\t\tprintk(KERN_WARNING \"%s: no stack\\n\", __func__);\n\t\treturn;\n\t}\n\tif (*debug & DEBUG_CORE_FUNC)\n\t\tprintk(KERN_DEBUG \"%s: st(%s) protocol(%x)\\n\", __func__,\n\t\t       dev_name(&ch->st->dev->dev), ch->protocol);\n\tif (ch->protocol >= ISDN_P_B_START) {\n\t\tif (ch->peer) {\n\t\t\tch->peer->ctrl(ch->peer, CLOSE_CHANNEL, NULL);\n\t\t\tch->peer = NULL;\n\t\t}\n\t\treturn;\n\t}\n\tswitch (ch->protocol) {\n\tcase ISDN_P_NT_S0:\n\tcase ISDN_P_TE_S0:\n\tcase ISDN_P_NT_E1:\n\tcase ISDN_P_TE_E1:\n\t\twrite_lock_bh(&ch->st->l1sock.lock);\n\t\tsk_del_node_init(&msk->sk);\n\t\twrite_unlock_bh(&ch->st->l1sock.lock);\n\t\tch->st->dev->D.ctrl(&ch->st->dev->D, CLOSE_CHANNEL, NULL);\n\t\tbreak;\n\tcase ISDN_P_LAPD_TE:\n\t\tpch = get_channel4id(ch->st, ch->nr);\n\t\tif (pch) {\n\t\t\tmutex_lock(&ch->st->lmutex);\n\t\t\tlist_del(&pch->list);\n\t\t\tmutex_unlock(&ch->st->lmutex);\n\t\t\tpch->ctrl(pch, CLOSE_CHANNEL, NULL);\n\t\t\tpch = ch->st->dev->teimgr;\n\t\t\tpch->ctrl(pch, CLOSE_CHANNEL, NULL);\n\t\t} else\n\t\t\tprintk(KERN_WARNING \"%s: no l2 channel\\n\",\n\t\t\t       __func__);\n\t\tbreak;\n\tcase ISDN_P_LAPD_NT:\n\t\tpch = ch->st->dev->teimgr;\n\t\tif (pch) {\n\t\t\tpch->ctrl(pch, CLOSE_CHANNEL, NULL);\n\t\t} else\n\t\t\tprintk(KERN_WARNING \"%s: no l2 channel\\n\",\n\t\t\t       __func__);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn;\n}\n\nvoid\ndelete_stack(struct mISDNdevice *dev)\n{\n\tstruct mISDNstack\t*st = dev->D.st;\n\tDECLARE_COMPLETION_ONSTACK(done);\n\n\tif (*debug & DEBUG_CORE_FUNC)\n\t\tprintk(KERN_DEBUG \"%s: st(%s)\\n\", __func__,\n\t\t       dev_name(&st->dev->dev));\n\tif (dev->teimgr)\n\t\tdelete_teimanager(dev->teimgr);\n\tif (st->thread) {\n\t\tif (st->notify) {\n\t\t\tprintk(KERN_WARNING \"%s: notifier in use\\n\",\n\t\t\t       __func__);\n\t\t\tcomplete(st->notify);\n\t\t}\n\t\tst->notify = &done;\n\t\ttest_and_set_bit(mISDN_STACK_ABORT, &st->status);\n\t\ttest_and_set_bit(mISDN_STACK_WAKEUP, &st->status);\n\t\twake_up_interruptible(&st->workq);\n\t\twait_for_completion(&done);\n\t}\n\tif (!list_empty(&st->layer2))\n\t\tprintk(KERN_WARNING \"%s: layer2 list not empty\\n\",\n\t\t       __func__);\n\tif (!hlist_empty(&st->l1sock.head))\n\t\tprintk(KERN_WARNING \"%s: layer1 list not empty\\n\",\n\t\t       __func__);\n\tkfree(st);\n}\n\nvoid\nmISDN_initstack(u_int *dp)\n{\n\tdebug = dp;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}