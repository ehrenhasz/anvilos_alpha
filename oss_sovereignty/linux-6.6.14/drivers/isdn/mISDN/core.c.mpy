{
  "module_name": "core.c",
  "hash_id": "6a8eea28785eeaf9f7ec423c36c6e74616bb31e67d8af3d5f72056209c64263f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/isdn/mISDN/core.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/stddef.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/mISDNif.h>\n#include \"core.h\"\n\nstatic u_int debug;\n\nMODULE_AUTHOR(\"Karsten Keil\");\nMODULE_LICENSE(\"GPL\");\nmodule_param(debug, uint, S_IRUGO | S_IWUSR);\n\nstatic u64\t\tdevice_ids;\n#define MAX_DEVICE_ID\t63\n\nstatic LIST_HEAD(Bprotocols);\nstatic DEFINE_RWLOCK(bp_lock);\n\nstatic void mISDN_dev_release(struct device *dev)\n{\n\t \n}\n\nstatic ssize_t id_show(struct device *dev,\n\t\t       struct device_attribute *attr, char *buf)\n{\n\tstruct mISDNdevice *mdev = dev_to_mISDN(dev);\n\n\tif (!mdev)\n\t\treturn -ENODEV;\n\treturn sprintf(buf, \"%d\\n\", mdev->id);\n}\nstatic DEVICE_ATTR_RO(id);\n\nstatic ssize_t nrbchan_show(struct device *dev,\n\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct mISDNdevice *mdev = dev_to_mISDN(dev);\n\n\tif (!mdev)\n\t\treturn -ENODEV;\n\treturn sprintf(buf, \"%d\\n\", mdev->nrbchan);\n}\nstatic DEVICE_ATTR_RO(nrbchan);\n\nstatic ssize_t d_protocols_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct mISDNdevice *mdev = dev_to_mISDN(dev);\n\n\tif (!mdev)\n\t\treturn -ENODEV;\n\treturn sprintf(buf, \"%d\\n\", mdev->Dprotocols);\n}\nstatic DEVICE_ATTR_RO(d_protocols);\n\nstatic ssize_t b_protocols_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct mISDNdevice *mdev = dev_to_mISDN(dev);\n\n\tif (!mdev)\n\t\treturn -ENODEV;\n\treturn sprintf(buf, \"%d\\n\", mdev->Bprotocols | get_all_Bprotocols());\n}\nstatic DEVICE_ATTR_RO(b_protocols);\n\nstatic ssize_t protocol_show(struct device *dev,\n\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct mISDNdevice *mdev = dev_to_mISDN(dev);\n\n\tif (!mdev)\n\t\treturn -ENODEV;\n\treturn sprintf(buf, \"%d\\n\", mdev->D.protocol);\n}\nstatic DEVICE_ATTR_RO(protocol);\n\nstatic ssize_t name_show(struct device *dev,\n\t\t\t struct device_attribute *attr, char *buf)\n{\n\tstrcpy(buf, dev_name(dev));\n\treturn strlen(buf);\n}\nstatic DEVICE_ATTR_RO(name);\n\n#if 0  \nstatic ssize_t name_set(struct device *dev, struct device_attribute *attr,\n\t\t\tconst char *buf, size_t count)\n{\n\tint err = 0;\n\tchar *out = kmalloc(count + 1, GFP_KERNEL);\n\n\tif (!out)\n\t\treturn -ENOMEM;\n\n\tmemcpy(out, buf, count);\n\tif (count && out[count - 1] == '\\n')\n\t\tout[--count] = 0;\n\tif (count)\n\t\terr = device_rename(dev, out);\n\tkfree(out);\n\n\treturn (err < 0) ? err : count;\n}\nstatic DEVICE_ATTR_RW(name);\n#endif\n\nstatic ssize_t channelmap_show(struct device *dev,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tstruct mISDNdevice *mdev = dev_to_mISDN(dev);\n\tchar *bp = buf;\n\tint i;\n\n\tfor (i = 0; i <= mdev->nrbchan; i++)\n\t\t*bp++ = test_channelmap(i, mdev->channelmap) ? '1' : '0';\n\n\treturn bp - buf;\n}\nstatic DEVICE_ATTR_RO(channelmap);\n\nstatic struct attribute *mISDN_attrs[] = {\n\t&dev_attr_id.attr,\n\t&dev_attr_d_protocols.attr,\n\t&dev_attr_b_protocols.attr,\n\t&dev_attr_protocol.attr,\n\t&dev_attr_channelmap.attr,\n\t&dev_attr_nrbchan.attr,\n\t&dev_attr_name.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(mISDN);\n\nstatic int mISDN_uevent(const struct device *dev, struct kobj_uevent_env *env)\n{\n\tconst struct mISDNdevice *mdev = dev_to_mISDN(dev);\n\n\tif (!mdev)\n\t\treturn 0;\n\n\tif (add_uevent_var(env, \"nchans=%d\", mdev->nrbchan))\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic struct class mISDN_class = {\n\t.name = \"mISDN\",\n\t.dev_uevent = mISDN_uevent,\n\t.dev_groups = mISDN_groups,\n\t.dev_release = mISDN_dev_release,\n};\n\nstatic int\n_get_mdevice(struct device *dev, const void *id)\n{\n\tstruct mISDNdevice *mdev = dev_to_mISDN(dev);\n\n\tif (!mdev)\n\t\treturn 0;\n\tif (mdev->id != *(const u_int *)id)\n\t\treturn 0;\n\treturn 1;\n}\n\nstruct mISDNdevice\n*get_mdevice(u_int id)\n{\n\treturn dev_to_mISDN(class_find_device(&mISDN_class, NULL, &id,\n\t\t\t\t\t      _get_mdevice));\n}\n\nstatic int\n_get_mdevice_count(struct device *dev, void *cnt)\n{\n\t*(int *)cnt += 1;\n\treturn 0;\n}\n\nint\nget_mdevice_count(void)\n{\n\tint cnt = 0;\n\n\tclass_for_each_device(&mISDN_class, NULL, &cnt, _get_mdevice_count);\n\treturn cnt;\n}\n\nstatic int\nget_free_devid(void)\n{\n\tu_int\ti;\n\n\tfor (i = 0; i <= MAX_DEVICE_ID; i++)\n\t\tif (!test_and_set_bit(i, (u_long *)&device_ids))\n\t\t\tbreak;\n\tif (i > MAX_DEVICE_ID)\n\t\treturn -EBUSY;\n\treturn i;\n}\n\nint\nmISDN_register_device(struct mISDNdevice *dev,\n\t\t      struct device *parent, char *name)\n{\n\tint\terr;\n\n\terr = get_free_devid();\n\tif (err < 0)\n\t\treturn err;\n\tdev->id = err;\n\n\tdevice_initialize(&dev->dev);\n\tif (name && name[0])\n\t\tdev_set_name(&dev->dev, \"%s\", name);\n\telse\n\t\tdev_set_name(&dev->dev, \"mISDN%d\", dev->id);\n\tif (debug & DEBUG_CORE)\n\t\tprintk(KERN_DEBUG \"mISDN_register %s %d\\n\",\n\t\t       dev_name(&dev->dev), dev->id);\n\tdev->dev.class = &mISDN_class;\n\n\terr = create_stack(dev);\n\tif (err)\n\t\tgoto error1;\n\n\tdev->dev.platform_data = dev;\n\tdev->dev.parent = parent;\n\tdev_set_drvdata(&dev->dev, dev);\n\n\terr = device_add(&dev->dev);\n\tif (err)\n\t\tgoto error3;\n\treturn 0;\n\nerror3:\n\tdelete_stack(dev);\nerror1:\n\tput_device(&dev->dev);\n\treturn err;\n\n}\nEXPORT_SYMBOL(mISDN_register_device);\n\nvoid\nmISDN_unregister_device(struct mISDNdevice *dev) {\n\tif (debug & DEBUG_CORE)\n\t\tprintk(KERN_DEBUG \"mISDN_unregister %s %d\\n\",\n\t\t       dev_name(&dev->dev), dev->id);\n\t \n\tdevice_del(&dev->dev);\n\tdev_set_drvdata(&dev->dev, NULL);\n\n\ttest_and_clear_bit(dev->id, (u_long *)&device_ids);\n\tdelete_stack(dev);\n\tput_device(&dev->dev);\n}\nEXPORT_SYMBOL(mISDN_unregister_device);\n\nu_int\nget_all_Bprotocols(void)\n{\n\tstruct Bprotocol\t*bp;\n\tu_int\tm = 0;\n\n\tread_lock(&bp_lock);\n\tlist_for_each_entry(bp, &Bprotocols, list)\n\t\tm |= bp->Bprotocols;\n\tread_unlock(&bp_lock);\n\treturn m;\n}\n\nstruct Bprotocol *\nget_Bprotocol4mask(u_int m)\n{\n\tstruct Bprotocol\t*bp;\n\n\tread_lock(&bp_lock);\n\tlist_for_each_entry(bp, &Bprotocols, list)\n\t\tif (bp->Bprotocols & m) {\n\t\t\tread_unlock(&bp_lock);\n\t\t\treturn bp;\n\t\t}\n\tread_unlock(&bp_lock);\n\treturn NULL;\n}\n\nstruct Bprotocol *\nget_Bprotocol4id(u_int id)\n{\n\tu_int\tm;\n\n\tif (id < ISDN_P_B_START || id > 63) {\n\t\tprintk(KERN_WARNING \"%s id not in range  %d\\n\",\n\t\t       __func__, id);\n\t\treturn NULL;\n\t}\n\tm = 1 << (id & ISDN_P_B_MASK);\n\treturn get_Bprotocol4mask(m);\n}\n\nint\nmISDN_register_Bprotocol(struct Bprotocol *bp)\n{\n\tu_long\t\t\tflags;\n\tstruct Bprotocol\t*old;\n\n\tif (debug & DEBUG_CORE)\n\t\tprintk(KERN_DEBUG \"%s: %s/%x\\n\", __func__,\n\t\t       bp->name, bp->Bprotocols);\n\told = get_Bprotocol4mask(bp->Bprotocols);\n\tif (old) {\n\t\tprintk(KERN_WARNING\n\t\t       \"register duplicate protocol old %s/%x new %s/%x\\n\",\n\t\t       old->name, old->Bprotocols, bp->name, bp->Bprotocols);\n\t\treturn -EBUSY;\n\t}\n\twrite_lock_irqsave(&bp_lock, flags);\n\tlist_add_tail(&bp->list, &Bprotocols);\n\twrite_unlock_irqrestore(&bp_lock, flags);\n\treturn 0;\n}\nEXPORT_SYMBOL(mISDN_register_Bprotocol);\n\nvoid\nmISDN_unregister_Bprotocol(struct Bprotocol *bp)\n{\n\tu_long\tflags;\n\n\tif (debug & DEBUG_CORE)\n\t\tprintk(KERN_DEBUG \"%s: %s/%x\\n\", __func__, bp->name,\n\t\t       bp->Bprotocols);\n\twrite_lock_irqsave(&bp_lock, flags);\n\tlist_del(&bp->list);\n\twrite_unlock_irqrestore(&bp_lock, flags);\n}\nEXPORT_SYMBOL(mISDN_unregister_Bprotocol);\n\nstatic const char *msg_no_channel = \"<no channel>\";\nstatic const char *msg_no_stack = \"<no stack>\";\nstatic const char *msg_no_stackdev = \"<no stack device>\";\n\nconst char *mISDNDevName4ch(struct mISDNchannel *ch)\n{\n\tif (!ch)\n\t\treturn msg_no_channel;\n\tif (!ch->st)\n\t\treturn msg_no_stack;\n\tif (!ch->st->dev)\n\t\treturn msg_no_stackdev;\n\treturn dev_name(&ch->st->dev->dev);\n};\nEXPORT_SYMBOL(mISDNDevName4ch);\n\nstatic int\nmISDNInit(void)\n{\n\tint\terr;\n\n\tprintk(KERN_INFO \"Modular ISDN core version %d.%d.%d\\n\",\n\t       MISDN_MAJOR_VERSION, MISDN_MINOR_VERSION, MISDN_RELEASE);\n\tmISDN_init_clock(&debug);\n\tmISDN_initstack(&debug);\n\terr = class_register(&mISDN_class);\n\tif (err)\n\t\tgoto error1;\n\terr = mISDN_inittimer(&debug);\n\tif (err)\n\t\tgoto error2;\n\terr = Isdnl1_Init(&debug);\n\tif (err)\n\t\tgoto error3;\n\terr = Isdnl2_Init(&debug);\n\tif (err)\n\t\tgoto error4;\n\terr = misdn_sock_init(&debug);\n\tif (err)\n\t\tgoto error5;\n\treturn 0;\n\nerror5:\n\tIsdnl2_cleanup();\nerror4:\n\tIsdnl1_cleanup();\nerror3:\n\tmISDN_timer_cleanup();\nerror2:\n\tclass_unregister(&mISDN_class);\nerror1:\n\treturn err;\n}\n\nstatic void mISDN_cleanup(void)\n{\n\tmisdn_sock_cleanup();\n\tIsdnl2_cleanup();\n\tIsdnl1_cleanup();\n\tmISDN_timer_cleanup();\n\tclass_unregister(&mISDN_class);\n\n\tprintk(KERN_DEBUG \"mISDNcore unloaded\\n\");\n}\n\nmodule_init(mISDNInit);\nmodule_exit(mISDN_cleanup);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}