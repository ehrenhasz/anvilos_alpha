{
  "module_name": "dsp_dtmf.c",
  "hash_id": "9a1548336ac76ae2b38a75056af91ca7366906c79446efc5dd93d445723032bd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/isdn/mISDN/dsp_dtmf.c",
  "human_readable_source": " \n\n#include <linux/mISDNif.h>\n#include <linux/mISDNdsp.h>\n#include \"core.h\"\n#include \"dsp.h\"\n\n#define NCOEFF            8      \n\n \nstatic u64 cos2pik[NCOEFF] =\n{\n\t \n\t55960, 53912, 51402, 48438, 38146, 32650, 26170, 18630\n};\n\n \nstatic char dtmf_matrix[4][4] =\n{\n\t{'1', '2', '3', 'A'},\n\t{'4', '5', '6', 'B'},\n\t{'7', '8', '9', 'C'},\n\t{'*', '0', '#', 'D'}\n};\n\n \nvoid dsp_dtmf_goertzel_init(struct dsp *dsp)\n{\n\tdsp->dtmf.size = 0;\n\tdsp->dtmf.lastwhat = '\\0';\n\tdsp->dtmf.lastdigit = '\\0';\n\tdsp->dtmf.count = 0;\n}\n\n \nvoid dsp_dtmf_hardware(struct dsp *dsp)\n{\n\tint hardware = 1;\n\n\tif (!dsp->dtmf.enable)\n\t\treturn;\n\n\tif (!dsp->features.hfc_dtmf)\n\t\thardware = 0;\n\n\t \n\tif (dsp->tx_volume) {\n\t\tif (dsp_debug & DEBUG_DSP_DTMF)\n\t\t\tprintk(KERN_DEBUG \"%s dsp %s cannot do hardware DTMF, \"\n\t\t\t       \"because tx_volume is changed\\n\",\n\t\t\t       __func__, dsp->name);\n\t\thardware = 0;\n\t}\n\tif (dsp->rx_volume) {\n\t\tif (dsp_debug & DEBUG_DSP_DTMF)\n\t\t\tprintk(KERN_DEBUG \"%s dsp %s cannot do hardware DTMF, \"\n\t\t\t       \"because rx_volume is changed\\n\",\n\t\t\t       __func__, dsp->name);\n\t\thardware = 0;\n\t}\n\t \n\tif (dsp->bf_enable) {\n\t\tif (dsp_debug & DEBUG_DSP_DTMF)\n\t\t\tprintk(KERN_DEBUG \"%s dsp %s cannot do hardware DTMF, \"\n\t\t\t       \"because encryption is enabled\\n\",\n\t\t\t       __func__, dsp->name);\n\t\thardware = 0;\n\t}\n\t \n\tif (dsp->pipeline.inuse) {\n\t\tif (dsp_debug & DEBUG_DSP_DTMF)\n\t\t\tprintk(KERN_DEBUG \"%s dsp %s cannot do hardware DTMF, \"\n\t\t\t       \"because pipeline exists.\\n\",\n\t\t\t       __func__, dsp->name);\n\t\thardware = 0;\n\t}\n\n\tdsp->dtmf.hardware = hardware;\n\tdsp->dtmf.software = !hardware;\n}\n\n\n \n\n \n\nu8\n*dsp_dtmf_goertzel_decode(struct dsp *dsp, u8 *data, int len, int fmt)\n{\n\tu8 what;\n\tint size;\n\tsigned short *buf;\n\ts32 sk, sk1, sk2;\n\tint k, n, i;\n\ts32 *hfccoeff;\n\ts32 result[NCOEFF], tresh, treshl;\n\tint lowgroup, highgroup;\n\ts64 cos2pik_;\n\n\tdsp->dtmf.digits[0] = '\\0';\n\n\t \nagain:\n\t \n\tsize = dsp->dtmf.size;\n\tbuf = dsp->dtmf.buffer;\n\tswitch (fmt) {\n\tcase 0:  \n\tcase 1:  \n\t\twhile (size < DSP_DTMF_NPOINTS && len) {\n\t\t\tbuf[size++] = dsp_audio_law_to_s32[*data++];\n\t\t\tlen--;\n\t\t}\n\t\tbreak;\n\n\tcase 2:  \n\tdefault:\n\t\tif (len < 64) {\n\t\t\tif (len > 0)\n\t\t\t\tprintk(KERN_ERR \"%s: coefficients have invalid \"\n\t\t\t\t       \"size. (is=%d < must=%d)\\n\",\n\t\t\t\t       __func__, len, 64);\n\t\t\treturn dsp->dtmf.digits;\n\t\t}\n\t\thfccoeff = (s32 *)data;\n\t\tfor (k = 0; k < NCOEFF; k++) {\n\t\t\tsk2 = (*hfccoeff++) >> 4;\n\t\t\tsk = (*hfccoeff++) >> 4;\n\t\t\tif (sk > 32767 || sk < -32767 || sk2 > 32767\n\t\t\t    || sk2 < -32767)\n\t\t\t\tprintk(KERN_WARNING\n\t\t\t\t       \"DTMF-Detection overflow\\n\");\n\t\t\t \n\t\t\tresult[k] =\n\t\t\t\t(sk * sk) -\n\t\t\t\t(((cos2pik[k] * sk) >> 15) * sk2) +\n\t\t\t\t(sk2 * sk2);\n\t\t}\n\t\tdata += 64;\n\t\tlen -= 64;\n\t\tgoto coefficients;\n\t\tbreak;\n\t}\n\tdsp->dtmf.size = size;\n\n\tif (size < DSP_DTMF_NPOINTS)\n\t\treturn dsp->dtmf.digits;\n\n\tdsp->dtmf.size = 0;\n\n\t \n\tfor (k = 0; k < NCOEFF; k++) {\n\t\tsk = 0;\n\t\tsk1 = 0;\n\t\tsk2 = 0;\n\t\tbuf = dsp->dtmf.buffer;\n\t\tcos2pik_ = cos2pik[k];\n\t\tfor (n = 0; n < DSP_DTMF_NPOINTS; n++) {\n\t\t\tsk = ((cos2pik_ * sk1) >> 15) - sk2 + (*buf++);\n\t\t\tsk2 = sk1;\n\t\t\tsk1 = sk;\n\t\t}\n\t\tsk >>= 8;\n\t\tsk2 >>= 8;\n\t\tif (sk > 32767 || sk < -32767 || sk2 > 32767 || sk2 < -32767)\n\t\t\tprintk(KERN_WARNING \"DTMF-Detection overflow\\n\");\n\t\t \n\t\tresult[k] =\n\t\t\t(sk * sk) -\n\t\t\t(((cos2pik[k] * sk) >> 15) * sk2) +\n\t\t\t(sk2 * sk2);\n\t}\n\n\t \ncoefficients:\n\ttresh = 0;\n\tfor (i = 0; i < NCOEFF; i++) {\n\t\tif (result[i] < 0)\n\t\t\tresult[i] = 0;\n\t\tif (result[i] > dsp->dtmf.treshold) {\n\t\t\tif (result[i] > tresh)\n\t\t\t\ttresh = result[i];\n\t\t}\n\t}\n\n\tif (tresh == 0) {\n\t\twhat = 0;\n\t\tgoto storedigit;\n\t}\n\n\tif (dsp_debug & DEBUG_DSP_DTMFCOEFF) {\n\t\ts32 tresh_100 = tresh/100;\n\n\t\tif (tresh_100 == 0) {\n\t\t\ttresh_100 = 1;\n\t\t\tprintk(KERN_DEBUG\n\t\t\t\t\"tresh(%d) too small set tresh/100 to 1\\n\",\n\t\t\t\ttresh);\n\t\t}\n\t\tprintk(KERN_DEBUG \"a %3d %3d %3d %3d %3d %3d %3d %3d\"\n\t\t       \" tr:%3d r %3d %3d %3d %3d %3d %3d %3d %3d\\n\",\n\t\t       result[0] / 10000, result[1] / 10000, result[2] / 10000,\n\t\t       result[3] / 10000, result[4] / 10000, result[5] / 10000,\n\t\t       result[6] / 10000, result[7] / 10000, tresh / 10000,\n\t\t       result[0] / (tresh_100), result[1] / (tresh_100),\n\t\t       result[2] / (tresh_100), result[3] / (tresh_100),\n\t\t       result[4] / (tresh_100), result[5] / (tresh_100),\n\t\t       result[6] / (tresh_100), result[7] / (tresh_100));\n\t}\n\n\t \n\tlowgroup = -1;\n\thighgroup = -1;\n\ttreshl = tresh >> 3;   \n\ttresh = tresh >> 2;   \n\tfor (i = 0; i < NCOEFF; i++) {\n\t\tif (result[i] < treshl)\n\t\t\tcontinue;   \n\t\tif (result[i] < tresh) {\n\t\t\tlowgroup = -1;\n\t\t\thighgroup = -1;\n\t\t\tbreak;   \n\t\t}\n\t\t \n\t\tif (i < NCOEFF / 2) {\n\t\t\t \n\t\t\tif (lowgroup >= 0) {\n\t\t\t\t \n\t\t\t\tlowgroup = -1;\n\t\t\t\tbreak;\n\t\t\t} else\n\t\t\t\tlowgroup = i;\n\t\t} else {\n\t\t\t \n\t\t\tif (highgroup >= 0) {\n\t\t\t\t \n\t\t\t\thighgroup = -1;\n\t\t\t\tbreak;\n\t\t\t} else\n\t\t\t\thighgroup = i - (NCOEFF / 2);\n\t\t}\n\t}\n\n\t \n\twhat = 0;\n\tif (lowgroup >= 0 && highgroup >= 0)\n\t\twhat = dtmf_matrix[lowgroup][highgroup];\n\nstoredigit:\n\tif (what && (dsp_debug & DEBUG_DSP_DTMF))\n\t\tprintk(KERN_DEBUG \"DTMF what: %c\\n\", what);\n\n\tif (dsp->dtmf.lastwhat != what)\n\t\tdsp->dtmf.count = 0;\n\n\t \n\tif (dsp->dtmf.count == 2) {\n\t\tif (dsp->dtmf.lastdigit != what) {\n\t\t\tdsp->dtmf.lastdigit = what;\n\t\t\tif (what) {\n\t\t\t\tif (dsp_debug & DEBUG_DSP_DTMF)\n\t\t\t\t\tprintk(KERN_DEBUG \"DTMF digit: %c\\n\",\n\t\t\t\t\t       what);\n\t\t\t\tif ((strlen(dsp->dtmf.digits) + 1)\n\t\t\t\t    < sizeof(dsp->dtmf.digits)) {\n\t\t\t\t\tdsp->dtmf.digits[strlen(\n\t\t\t\t\t\t\tdsp->dtmf.digits) + 1] = '\\0';\n\t\t\t\t\tdsp->dtmf.digits[strlen(\n\t\t\t\t\t\t\tdsp->dtmf.digits)] = what;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else\n\t\tdsp->dtmf.count++;\n\n\tdsp->dtmf.lastwhat = what;\n\n\tgoto again;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}