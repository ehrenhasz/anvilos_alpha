{
  "module_name": "timerdev.c",
  "hash_id": "09d6e986ab7f3d6435790ae6d3e7483e129ed7d8b17cd9af2d4ac91e476cdf07",
  "original_prompt": "Ingested from linux-6.6.14/drivers/isdn/mISDN/timerdev.c",
  "human_readable_source": "\n \n\n#include <linux/poll.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/timer.h>\n#include <linux/miscdevice.h>\n#include <linux/module.h>\n#include <linux/mISDNif.h>\n#include <linux/mutex.h>\n#include <linux/sched/signal.h>\n\n#include \"core.h\"\n\nstatic DEFINE_MUTEX(mISDN_mutex);\nstatic u_int\t*debug;\n\n\nstruct mISDNtimerdev {\n\tint\t\t\tnext_id;\n\tstruct list_head\tpending;\n\tstruct list_head\texpired;\n\twait_queue_head_t\twait;\n\tu_int\t\t\twork;\n\tspinlock_t\t\tlock;  \n};\n\nstruct mISDNtimer {\n\tstruct list_head\tlist;\n\tstruct  mISDNtimerdev\t*dev;\n\tstruct timer_list\ttl;\n\tint\t\t\tid;\n};\n\nstatic int\nmISDN_open(struct inode *ino, struct file *filep)\n{\n\tstruct mISDNtimerdev\t*dev;\n\n\tif (*debug & DEBUG_TIMER)\n\t\tprintk(KERN_DEBUG \"%s(%p,%p)\\n\", __func__, ino, filep);\n\tdev = kmalloc(sizeof(struct mISDNtimerdev) , GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\tdev->next_id = 1;\n\tINIT_LIST_HEAD(&dev->pending);\n\tINIT_LIST_HEAD(&dev->expired);\n\tspin_lock_init(&dev->lock);\n\tdev->work = 0;\n\tinit_waitqueue_head(&dev->wait);\n\tfilep->private_data = dev;\n\treturn nonseekable_open(ino, filep);\n}\n\nstatic int\nmISDN_close(struct inode *ino, struct file *filep)\n{\n\tstruct mISDNtimerdev\t*dev = filep->private_data;\n\tstruct list_head\t*list = &dev->pending;\n\tstruct mISDNtimer\t*timer, *next;\n\n\tif (*debug & DEBUG_TIMER)\n\t\tprintk(KERN_DEBUG \"%s(%p,%p)\\n\", __func__, ino, filep);\n\n\tspin_lock_irq(&dev->lock);\n\twhile (!list_empty(list)) {\n\t\ttimer = list_first_entry(list, struct mISDNtimer, list);\n\t\tspin_unlock_irq(&dev->lock);\n\t\ttimer_shutdown_sync(&timer->tl);\n\t\tspin_lock_irq(&dev->lock);\n\t\t \n\t\tlist_del(&timer->list);\n\t\tkfree(timer);\n\t}\n\tspin_unlock_irq(&dev->lock);\n\n\tlist_for_each_entry_safe(timer, next, &dev->expired, list) {\n\t\tkfree(timer);\n\t}\n\tkfree(dev);\n\treturn 0;\n}\n\nstatic ssize_t\nmISDN_read(struct file *filep, char __user *buf, size_t count, loff_t *off)\n{\n\tstruct mISDNtimerdev\t*dev = filep->private_data;\n\tstruct list_head *list = &dev->expired;\n\tstruct mISDNtimer\t*timer;\n\tint\tret = 0;\n\n\tif (*debug & DEBUG_TIMER)\n\t\tprintk(KERN_DEBUG \"%s(%p, %p, %d, %p)\\n\", __func__,\n\t\t       filep, buf, (int)count, off);\n\n\tif (count < sizeof(int))\n\t\treturn -ENOSPC;\n\n\tspin_lock_irq(&dev->lock);\n\twhile (list_empty(list) && (dev->work == 0)) {\n\t\tspin_unlock_irq(&dev->lock);\n\t\tif (filep->f_flags & O_NONBLOCK)\n\t\t\treturn -EAGAIN;\n\t\twait_event_interruptible(dev->wait, (dev->work ||\n\t\t\t\t\t\t     !list_empty(list)));\n\t\tif (signal_pending(current))\n\t\t\treturn -ERESTARTSYS;\n\t\tspin_lock_irq(&dev->lock);\n\t}\n\tif (dev->work)\n\t\tdev->work = 0;\n\tif (!list_empty(list)) {\n\t\ttimer = list_first_entry(list, struct mISDNtimer, list);\n\t\tlist_del(&timer->list);\n\t\tspin_unlock_irq(&dev->lock);\n\t\tif (put_user(timer->id, (int __user *)buf))\n\t\t\tret = -EFAULT;\n\t\telse\n\t\t\tret = sizeof(int);\n\t\tkfree(timer);\n\t} else {\n\t\tspin_unlock_irq(&dev->lock);\n\t}\n\treturn ret;\n}\n\nstatic __poll_t\nmISDN_poll(struct file *filep, poll_table *wait)\n{\n\tstruct mISDNtimerdev\t*dev = filep->private_data;\n\t__poll_t\t\tmask = EPOLLERR;\n\n\tif (*debug & DEBUG_TIMER)\n\t\tprintk(KERN_DEBUG \"%s(%p, %p)\\n\", __func__, filep, wait);\n\tif (dev) {\n\t\tpoll_wait(filep, &dev->wait, wait);\n\t\tmask = 0;\n\t\tif (dev->work || !list_empty(&dev->expired))\n\t\t\tmask |= (EPOLLIN | EPOLLRDNORM);\n\t\tif (*debug & DEBUG_TIMER)\n\t\t\tprintk(KERN_DEBUG \"%s work(%d) empty(%d)\\n\", __func__,\n\t\t\t       dev->work, list_empty(&dev->expired));\n\t}\n\treturn mask;\n}\n\nstatic void\ndev_expire_timer(struct timer_list *t)\n{\n\tstruct mISDNtimer *timer = from_timer(timer, t, tl);\n\tu_long\t\t\tflags;\n\n\tspin_lock_irqsave(&timer->dev->lock, flags);\n\tif (timer->id >= 0)\n\t\tlist_move_tail(&timer->list, &timer->dev->expired);\n\twake_up_interruptible(&timer->dev->wait);\n\tspin_unlock_irqrestore(&timer->dev->lock, flags);\n}\n\nstatic int\nmisdn_add_timer(struct mISDNtimerdev *dev, int timeout)\n{\n\tint\t\t\tid;\n\tstruct mISDNtimer\t*timer;\n\n\tif (!timeout) {\n\t\tdev->work = 1;\n\t\twake_up_interruptible(&dev->wait);\n\t\tid = 0;\n\t} else {\n\t\ttimer = kzalloc(sizeof(struct mISDNtimer), GFP_KERNEL);\n\t\tif (!timer)\n\t\t\treturn -ENOMEM;\n\t\ttimer->dev = dev;\n\t\ttimer_setup(&timer->tl, dev_expire_timer, 0);\n\t\tspin_lock_irq(&dev->lock);\n\t\tid = timer->id = dev->next_id++;\n\t\tif (dev->next_id < 0)\n\t\t\tdev->next_id = 1;\n\t\tlist_add_tail(&timer->list, &dev->pending);\n\t\ttimer->tl.expires = jiffies + ((HZ * (u_long)timeout) / 1000);\n\t\tadd_timer(&timer->tl);\n\t\tspin_unlock_irq(&dev->lock);\n\t}\n\treturn id;\n}\n\nstatic int\nmisdn_del_timer(struct mISDNtimerdev *dev, int id)\n{\n\tstruct mISDNtimer\t*timer;\n\n\tspin_lock_irq(&dev->lock);\n\tlist_for_each_entry(timer, &dev->pending, list) {\n\t\tif (timer->id == id) {\n\t\t\tlist_del_init(&timer->list);\n\t\t\ttimer->id = -1;\n\t\t\tspin_unlock_irq(&dev->lock);\n\t\t\ttimer_shutdown_sync(&timer->tl);\n\t\t\tkfree(timer);\n\t\t\treturn id;\n\t\t}\n\t}\n\tspin_unlock_irq(&dev->lock);\n\treturn 0;\n}\n\nstatic long\nmISDN_ioctl(struct file *filep, unsigned int cmd, unsigned long arg)\n{\n\tstruct mISDNtimerdev\t*dev = filep->private_data;\n\tint\t\t\tid, tout, ret = 0;\n\n\n\tif (*debug & DEBUG_TIMER)\n\t\tprintk(KERN_DEBUG \"%s(%p, %x, %lx)\\n\", __func__,\n\t\t       filep, cmd, arg);\n\tmutex_lock(&mISDN_mutex);\n\tswitch (cmd) {\n\tcase IMADDTIMER:\n\t\tif (get_user(tout, (int __user *)arg)) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tid = misdn_add_timer(dev, tout);\n\t\tif (*debug & DEBUG_TIMER)\n\t\t\tprintk(KERN_DEBUG \"%s add %d id %d\\n\", __func__,\n\t\t\t       tout, id);\n\t\tif (id < 0) {\n\t\t\tret = id;\n\t\t\tbreak;\n\t\t}\n\t\tif (put_user(id, (int __user *)arg))\n\t\t\tret = -EFAULT;\n\t\tbreak;\n\tcase IMDELTIMER:\n\t\tif (get_user(id, (int __user *)arg)) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tif (*debug & DEBUG_TIMER)\n\t\t\tprintk(KERN_DEBUG \"%s del id %d\\n\", __func__, id);\n\t\tid = misdn_del_timer(dev, id);\n\t\tif (put_user(id, (int __user *)arg))\n\t\t\tret = -EFAULT;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\tmutex_unlock(&mISDN_mutex);\n\treturn ret;\n}\n\nstatic const struct file_operations mISDN_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.read\t\t= mISDN_read,\n\t.poll\t\t= mISDN_poll,\n\t.unlocked_ioctl\t= mISDN_ioctl,\n\t.open\t\t= mISDN_open,\n\t.release\t= mISDN_close,\n\t.llseek\t\t= no_llseek,\n};\n\nstatic struct miscdevice mISDNtimer = {\n\t.minor\t= MISC_DYNAMIC_MINOR,\n\t.name\t= \"mISDNtimer\",\n\t.fops\t= &mISDN_fops,\n};\n\nint\nmISDN_inittimer(u_int *deb)\n{\n\tint\terr;\n\n\tdebug = deb;\n\terr = misc_register(&mISDNtimer);\n\tif (err)\n\t\tprintk(KERN_WARNING \"mISDN: Could not register timer device\\n\");\n\treturn err;\n}\n\nvoid mISDN_timer_cleanup(void)\n{\n\tmisc_deregister(&mISDNtimer);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}