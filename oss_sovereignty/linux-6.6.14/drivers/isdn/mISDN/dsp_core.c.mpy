{
  "module_name": "dsp_core.c",
  "hash_id": "c2dd196e62ef960800f457701acc490b721b835ac41c081b6d07fff865d8f9d0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/isdn/mISDN/dsp_core.c",
  "human_readable_source": " \n\n \n\n#include <linux/delay.h>\n#include <linux/gfp.h>\n#include <linux/mISDNif.h>\n#include <linux/mISDNdsp.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include \"core.h\"\n#include \"dsp.h\"\n\nstatic const char *mISDN_dsp_revision = \"2.0\";\n\nstatic int debug;\nstatic int options;\nstatic int poll;\nstatic int dtmfthreshold = 100;\n\nMODULE_AUTHOR(\"Andreas Eversberg\");\nmodule_param(debug, uint, S_IRUGO | S_IWUSR);\nmodule_param(options, uint, S_IRUGO | S_IWUSR);\nmodule_param(poll, uint, S_IRUGO | S_IWUSR);\nmodule_param(dtmfthreshold, uint, S_IRUGO | S_IWUSR);\nMODULE_LICENSE(\"GPL\");\n\n \n\nDEFINE_SPINLOCK(dsp_lock);  \nLIST_HEAD(dsp_ilist);\nLIST_HEAD(conf_ilist);\nint dsp_debug;\nint dsp_options;\nint dsp_poll, dsp_tics;\n\n \nstatic void\ndsp_rx_off_member(struct dsp *dsp)\n{\n\tstruct mISDN_ctrl_req\tcq;\n\tint rx_off = 1;\n\n\tmemset(&cq, 0, sizeof(cq));\n\n\tif (!dsp->features_rx_off)\n\t\treturn;\n\n\t \n\tif (!dsp->rx_disabled)\n\t\trx_off = 0;\n\t \n\telse if (dsp->dtmf.software)\n\t\trx_off = 0;\n\t \n\telse if (dsp->echo.software)\n\t\trx_off = 0;\n\t \n\telse if (dsp->conf && dsp->conf->software)\n\t\trx_off = 0;\n\t \n\n\tif (rx_off == dsp->rx_is_off)\n\t\treturn;\n\n\tif (!dsp->ch.peer) {\n\t\tif (dsp_debug & DEBUG_DSP_CORE)\n\t\t\tprintk(KERN_DEBUG \"%s: no peer, no rx_off\\n\",\n\t\t\t       __func__);\n\t\treturn;\n\t}\n\tcq.op = MISDN_CTRL_RX_OFF;\n\tcq.p1 = rx_off;\n\tif (dsp->ch.peer->ctrl(dsp->ch.peer, CONTROL_CHANNEL, &cq)) {\n\t\tprintk(KERN_DEBUG \"%s: 2nd CONTROL_CHANNEL failed\\n\",\n\t\t       __func__);\n\t\treturn;\n\t}\n\tdsp->rx_is_off = rx_off;\n\tif (dsp_debug & DEBUG_DSP_CORE)\n\t\tprintk(KERN_DEBUG \"%s: %s set rx_off = %d\\n\",\n\t\t       __func__, dsp->name, rx_off);\n}\nstatic void\ndsp_rx_off(struct dsp *dsp)\n{\n\tstruct dsp_conf_member\t*member;\n\n\tif (dsp_options & DSP_OPT_NOHARDWARE)\n\t\treturn;\n\n\t \n\tif (!dsp->conf) {\n\t\tdsp_rx_off_member(dsp);\n\t\treturn;\n\t}\n\t \n\tlist_for_each_entry(member, &dsp->conf->mlist, list) {\n\t\tdsp_rx_off_member(member->dsp);\n\t}\n}\n\n \nstatic void\ndsp_fill_empty(struct dsp *dsp)\n{\n\tstruct mISDN_ctrl_req\tcq;\n\n\tmemset(&cq, 0, sizeof(cq));\n\n\tif (!dsp->ch.peer) {\n\t\tif (dsp_debug & DEBUG_DSP_CORE)\n\t\t\tprintk(KERN_DEBUG \"%s: no peer, no fill_empty\\n\",\n\t\t\t       __func__);\n\t\treturn;\n\t}\n\tcq.op = MISDN_CTRL_FILL_EMPTY;\n\tcq.p1 = 1;\n\tcq.p2 = dsp_silence;\n\tif (dsp->ch.peer->ctrl(dsp->ch.peer, CONTROL_CHANNEL, &cq)) {\n\t\tprintk(KERN_DEBUG \"%s: CONTROL_CHANNEL failed\\n\",\n\t\t       __func__);\n\t\treturn;\n\t}\n\tif (dsp_debug & DEBUG_DSP_CORE)\n\t\tprintk(KERN_DEBUG \"%s: %s set fill_empty = 1\\n\",\n\t\t       __func__, dsp->name);\n}\n\nstatic int\ndsp_control_req(struct dsp *dsp, struct mISDNhead *hh, struct sk_buff *skb)\n{\n\tstruct sk_buff\t*nskb;\n\tint ret = 0;\n\tint cont;\n\tu8 *data;\n\tint len;\n\n\tif (skb->len < sizeof(int)) {\n\t\tprintk(KERN_ERR \"%s: PH_CONTROL message too short\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\tcont = *((int *)skb->data);\n\tlen = skb->len - sizeof(int);\n\tdata = skb->data + sizeof(int);\n\n\tswitch (cont) {\n\tcase DTMF_TONE_START:  \n\t\tif (dsp->hdlc) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tif (dsp_debug & DEBUG_DSP_CORE)\n\t\t\tprintk(KERN_DEBUG \"%s: start dtmf\\n\", __func__);\n\t\tif (len == sizeof(int)) {\n\t\t\tif (dsp_debug & DEBUG_DSP_CORE)\n\t\t\t\tprintk(KERN_NOTICE \"changing DTMF Threshold \"\n\t\t\t\t       \"to %d\\n\", *((int *)data));\n\t\t\tdsp->dtmf.treshold = (*(int *)data) * 10000;\n\t\t}\n\t\tdsp->dtmf.enable = 1;\n\t\t \n\t\tdsp_dtmf_goertzel_init(dsp);\n\n\t\t \n\t\tdsp_dtmf_hardware(dsp);\n\t\tdsp_rx_off(dsp);\n\t\tbreak;\n\tcase DTMF_TONE_STOP:  \n\t\tif (dsp_debug & DEBUG_DSP_CORE)\n\t\t\tprintk(KERN_DEBUG \"%s: stop dtmf\\n\", __func__);\n\t\tdsp->dtmf.enable = 0;\n\t\tdsp->dtmf.hardware = 0;\n\t\tdsp->dtmf.software = 0;\n\t\tbreak;\n\tcase DSP_CONF_JOIN:  \n\t\tif (len < sizeof(int)) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tif (*((u32 *)data) == 0)\n\t\t\tgoto conf_split;\n\t\tif (dsp_debug & DEBUG_DSP_CORE)\n\t\t\tprintk(KERN_DEBUG \"%s: join conference %d\\n\",\n\t\t\t       __func__, *((u32 *)data));\n\t\tret = dsp_cmx_conf(dsp, *((u32 *)data));\n\t\t \n\t\tdsp_rx_off(dsp);\n\t\tif (dsp_debug & DEBUG_DSP_CMX)\n\t\t\tdsp_cmx_debug(dsp);\n\t\tbreak;\n\tcase DSP_CONF_SPLIT:  \n\tconf_split:\n\t\tif (dsp_debug & DEBUG_DSP_CORE)\n\t\t\tprintk(KERN_DEBUG \"%s: release conference\\n\", __func__);\n\t\tret = dsp_cmx_conf(dsp, 0);\n\t\t \n\t\tif (dsp_debug & DEBUG_DSP_CMX)\n\t\t\tdsp_cmx_debug(dsp);\n\t\tdsp_rx_off(dsp);\n\t\tbreak;\n\tcase DSP_TONE_PATT_ON:  \n\t\tif (dsp->hdlc) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tif (len < sizeof(int)) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tif (dsp_debug & DEBUG_DSP_CORE)\n\t\t\tprintk(KERN_DEBUG \"%s: turn tone 0x%x on\\n\",\n\t\t\t       __func__, *((int *)skb->data));\n\t\tret = dsp_tone(dsp, *((int *)data));\n\t\tif (!ret) {\n\t\t\tdsp_cmx_hardware(dsp->conf, dsp);\n\t\t\tdsp_rx_off(dsp);\n\t\t}\n\t\tif (!dsp->tone.tone)\n\t\t\tgoto tone_off;\n\t\tbreak;\n\tcase DSP_TONE_PATT_OFF:  \n\t\tif (dsp->hdlc) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tif (dsp_debug & DEBUG_DSP_CORE)\n\t\t\tprintk(KERN_DEBUG \"%s: turn tone off\\n\", __func__);\n\t\tdsp_tone(dsp, 0);\n\t\tdsp_cmx_hardware(dsp->conf, dsp);\n\t\tdsp_rx_off(dsp);\n\t\t \n\ttone_off:\n\t\tdsp->rx_W = 0;\n\t\tdsp->rx_R = 0;\n\t\tbreak;\n\tcase DSP_VOL_CHANGE_TX:  \n\t\tif (dsp->hdlc) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tif (len < sizeof(int)) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tdsp->tx_volume = *((int *)data);\n\t\tif (dsp_debug & DEBUG_DSP_CORE)\n\t\t\tprintk(KERN_DEBUG \"%s: change tx vol to %d\\n\",\n\t\t\t       __func__, dsp->tx_volume);\n\t\tdsp_cmx_hardware(dsp->conf, dsp);\n\t\tdsp_dtmf_hardware(dsp);\n\t\tdsp_rx_off(dsp);\n\t\tbreak;\n\tcase DSP_VOL_CHANGE_RX:  \n\t\tif (dsp->hdlc) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tif (len < sizeof(int)) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tdsp->rx_volume = *((int *)data);\n\t\tif (dsp_debug & DEBUG_DSP_CORE)\n\t\t\tprintk(KERN_DEBUG \"%s: change rx vol to %d\\n\",\n\t\t\t       __func__, dsp->tx_volume);\n\t\tdsp_cmx_hardware(dsp->conf, dsp);\n\t\tdsp_dtmf_hardware(dsp);\n\t\tdsp_rx_off(dsp);\n\t\tbreak;\n\tcase DSP_ECHO_ON:  \n\t\tdsp->echo.software = 1;  \n\t\tif (dsp_debug & DEBUG_DSP_CORE)\n\t\t\tprintk(KERN_DEBUG \"%s: enable cmx-echo\\n\", __func__);\n\t\tdsp_cmx_hardware(dsp->conf, dsp);\n\t\tdsp_rx_off(dsp);\n\t\tif (dsp_debug & DEBUG_DSP_CMX)\n\t\t\tdsp_cmx_debug(dsp);\n\t\tbreak;\n\tcase DSP_ECHO_OFF:  \n\t\tdsp->echo.software = 0;\n\t\tdsp->echo.hardware = 0;\n\t\tif (dsp_debug & DEBUG_DSP_CORE)\n\t\t\tprintk(KERN_DEBUG \"%s: disable cmx-echo\\n\", __func__);\n\t\tdsp_cmx_hardware(dsp->conf, dsp);\n\t\tdsp_rx_off(dsp);\n\t\tif (dsp_debug & DEBUG_DSP_CMX)\n\t\t\tdsp_cmx_debug(dsp);\n\t\tbreak;\n\tcase DSP_RECEIVE_ON:  \n\t\tif (dsp_debug & DEBUG_DSP_CORE)\n\t\t\tprintk(KERN_DEBUG \"%s: enable receive to user \"\n\t\t\t       \"space\\n\", __func__);\n\t\tdsp->rx_disabled = 0;\n\t\tdsp_rx_off(dsp);\n\t\tbreak;\n\tcase DSP_RECEIVE_OFF:  \n\t\tif (dsp_debug & DEBUG_DSP_CORE)\n\t\t\tprintk(KERN_DEBUG \"%s: disable receive to \"\n\t\t\t       \"user space\\n\", __func__);\n\t\tdsp->rx_disabled = 1;\n\t\tdsp_rx_off(dsp);\n\t\tbreak;\n\tcase DSP_MIX_ON:  \n\t\tif (dsp->hdlc) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tif (dsp_debug & DEBUG_DSP_CORE)\n\t\t\tprintk(KERN_DEBUG \"%s: enable mixing of \"\n\t\t\t       \"tx-data with conf members\\n\", __func__);\n\t\tdsp->tx_mix = 1;\n\t\tdsp_cmx_hardware(dsp->conf, dsp);\n\t\tdsp_rx_off(dsp);\n\t\tif (dsp_debug & DEBUG_DSP_CMX)\n\t\t\tdsp_cmx_debug(dsp);\n\t\tbreak;\n\tcase DSP_MIX_OFF:  \n\t\tif (dsp->hdlc) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tif (dsp_debug & DEBUG_DSP_CORE)\n\t\t\tprintk(KERN_DEBUG \"%s: disable mixing of \"\n\t\t\t       \"tx-data with conf members\\n\", __func__);\n\t\tdsp->tx_mix = 0;\n\t\tdsp_cmx_hardware(dsp->conf, dsp);\n\t\tdsp_rx_off(dsp);\n\t\tif (dsp_debug & DEBUG_DSP_CMX)\n\t\t\tdsp_cmx_debug(dsp);\n\t\tbreak;\n\tcase DSP_TXDATA_ON:  \n\t\tdsp->tx_data = 1;\n\t\tif (dsp_debug & DEBUG_DSP_CORE)\n\t\t\tprintk(KERN_DEBUG \"%s: enable tx-data\\n\", __func__);\n\t\tdsp_cmx_hardware(dsp->conf, dsp);\n\t\tdsp_rx_off(dsp);\n\t\tif (dsp_debug & DEBUG_DSP_CMX)\n\t\t\tdsp_cmx_debug(dsp);\n\t\tbreak;\n\tcase DSP_TXDATA_OFF:  \n\t\tdsp->tx_data = 0;\n\t\tif (dsp_debug & DEBUG_DSP_CORE)\n\t\t\tprintk(KERN_DEBUG \"%s: disable tx-data\\n\", __func__);\n\t\tdsp_cmx_hardware(dsp->conf, dsp);\n\t\tdsp_rx_off(dsp);\n\t\tif (dsp_debug & DEBUG_DSP_CMX)\n\t\t\tdsp_cmx_debug(dsp);\n\t\tbreak;\n\tcase DSP_DELAY:  \n\t\tif (dsp->hdlc) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tif (len < sizeof(int)) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tdsp->cmx_delay = (*((int *)data)) << 3;\n\t\t \n\t\tif (dsp->cmx_delay >= (CMX_BUFF_HALF >> 1))\n\t\t\t \n\t\t\tdsp->cmx_delay = (CMX_BUFF_HALF >> 1) - 1;\n\t\tif (dsp_debug & DEBUG_DSP_CORE)\n\t\t\tprintk(KERN_DEBUG \"%s: use delay algorithm to \"\n\t\t\t       \"compensate jitter (%d samples)\\n\",\n\t\t\t       __func__, dsp->cmx_delay);\n\t\tbreak;\n\tcase DSP_JITTER:  \n\t\tif (dsp->hdlc) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tdsp->cmx_delay = 0;\n\t\tif (dsp_debug & DEBUG_DSP_CORE)\n\t\t\tprintk(KERN_DEBUG \"%s: use jitter algorithm to \"\n\t\t\t       \"compensate jitter\\n\", __func__);\n\t\tbreak;\n\tcase DSP_TX_DEJITTER:  \n\t\tif (dsp->hdlc) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tdsp->tx_dejitter = 1;\n\t\tif (dsp_debug & DEBUG_DSP_CORE)\n\t\t\tprintk(KERN_DEBUG \"%s: use dejitter on TX \"\n\t\t\t       \"buffer\\n\", __func__);\n\t\tbreak;\n\tcase DSP_TX_DEJ_OFF:  \n\t\tif (dsp->hdlc) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tdsp->tx_dejitter = 0;\n\t\tif (dsp_debug & DEBUG_DSP_CORE)\n\t\t\tprintk(KERN_DEBUG \"%s: use TX buffer without \"\n\t\t\t       \"dejittering\\n\", __func__);\n\t\tbreak;\n\tcase DSP_PIPELINE_CFG:\n\t\tif (dsp->hdlc) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tif (len > 0 && ((char *)data)[len - 1]) {\n\t\t\tprintk(KERN_DEBUG \"%s: pipeline config string \"\n\t\t\t       \"is not NULL terminated!\\n\", __func__);\n\t\t\tret = -EINVAL;\n\t\t} else {\n\t\t\tdsp->pipeline.inuse = 1;\n\t\t\tdsp_cmx_hardware(dsp->conf, dsp);\n\t\t\tret = dsp_pipeline_build(&dsp->pipeline,\n\t\t\t\t\t\t len > 0 ? data : NULL);\n\t\t\tdsp_cmx_hardware(dsp->conf, dsp);\n\t\t\tdsp_rx_off(dsp);\n\t\t}\n\t\tbreak;\n\tcase DSP_BF_ENABLE_KEY:  \n\t\tif (dsp->hdlc) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tif (len < 4 || len > 56) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tif (dsp_debug & DEBUG_DSP_CORE)\n\t\t\tprintk(KERN_DEBUG \"%s: turn blowfish on (key \"\n\t\t\t       \"not shown)\\n\", __func__);\n\t\tret = dsp_bf_init(dsp, (u8 *)data, len);\n\t\t \n\t\tif (!ret)\n\t\t\tcont = DSP_BF_ACCEPT;\n\t\telse\n\t\t\tcont = DSP_BF_REJECT;\n\t\t \n\t\tnskb = _alloc_mISDN_skb(PH_CONTROL_IND, MISDN_ID_ANY,\n\t\t\t\t\tsizeof(int), &cont, GFP_ATOMIC);\n\t\tif (nskb) {\n\t\t\tif (dsp->up) {\n\t\t\t\tif (dsp->up->send(dsp->up, nskb))\n\t\t\t\t\tdev_kfree_skb(nskb);\n\t\t\t} else\n\t\t\t\tdev_kfree_skb(nskb);\n\t\t}\n\t\tif (!ret) {\n\t\t\tdsp_cmx_hardware(dsp->conf, dsp);\n\t\t\tdsp_dtmf_hardware(dsp);\n\t\t\tdsp_rx_off(dsp);\n\t\t}\n\t\tbreak;\n\tcase DSP_BF_DISABLE:  \n\t\tif (dsp->hdlc) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tif (dsp_debug & DEBUG_DSP_CORE)\n\t\t\tprintk(KERN_DEBUG \"%s: turn blowfish off\\n\", __func__);\n\t\tdsp_bf_cleanup(dsp);\n\t\tdsp_cmx_hardware(dsp->conf, dsp);\n\t\tdsp_dtmf_hardware(dsp);\n\t\tdsp_rx_off(dsp);\n\t\tbreak;\n\tdefault:\n\t\tif (dsp_debug & DEBUG_DSP_CORE)\n\t\t\tprintk(KERN_DEBUG \"%s: ctrl req %x unhandled\\n\",\n\t\t\t       __func__, cont);\n\t\tret = -EINVAL;\n\t}\n\treturn ret;\n}\n\nstatic void\nget_features(struct mISDNchannel *ch)\n{\n\tstruct dsp\t\t*dsp = container_of(ch, struct dsp, ch);\n\tstruct mISDN_ctrl_req\tcq;\n\n\tif (!ch->peer) {\n\t\tif (dsp_debug & DEBUG_DSP_CORE)\n\t\t\tprintk(KERN_DEBUG \"%s: no peer, no features\\n\",\n\t\t\t       __func__);\n\t\treturn;\n\t}\n\tmemset(&cq, 0, sizeof(cq));\n\tcq.op = MISDN_CTRL_GETOP;\n\tif (ch->peer->ctrl(ch->peer, CONTROL_CHANNEL, &cq) < 0) {\n\t\tprintk(KERN_DEBUG \"%s: CONTROL_CHANNEL failed\\n\",\n\t\t       __func__);\n\t\treturn;\n\t}\n\tif (cq.op & MISDN_CTRL_RX_OFF)\n\t\tdsp->features_rx_off = 1;\n\tif (cq.op & MISDN_CTRL_FILL_EMPTY)\n\t\tdsp->features_fill_empty = 1;\n\tif (dsp_options & DSP_OPT_NOHARDWARE)\n\t\treturn;\n\tif ((cq.op & MISDN_CTRL_HW_FEATURES_OP)) {\n\t\tcq.op = MISDN_CTRL_HW_FEATURES;\n\t\t*((u_long *)&cq.p1) = (u_long)&dsp->features;\n\t\tif (ch->peer->ctrl(ch->peer, CONTROL_CHANNEL, &cq)) {\n\t\t\tprintk(KERN_DEBUG \"%s: 2nd CONTROL_CHANNEL failed\\n\",\n\t\t\t       __func__);\n\t\t}\n\t} else\n\t\tif (dsp_debug & DEBUG_DSP_CORE)\n\t\t\tprintk(KERN_DEBUG \"%s: features not supported for %s\\n\",\n\t\t\t       __func__, dsp->name);\n}\n\nstatic int\ndsp_function(struct mISDNchannel *ch,  struct sk_buff *skb)\n{\n\tstruct dsp\t\t*dsp = container_of(ch, struct dsp, ch);\n\tstruct mISDNhead\t*hh;\n\tint\t\t\tret = 0;\n\tu8\t\t\t*digits = NULL;\n\tu_long\t\t\tflags;\n\n\thh = mISDN_HEAD_P(skb);\n\tswitch (hh->prim) {\n\t\t \n\tcase (PH_DATA_CNF):\n\t\tdsp->data_pending = 0;\n\t\t \n\t\tif (dsp->hdlc) {\n\t\t\tspin_lock_irqsave(&dsp_lock, flags);\n\t\t\tif (dsp->b_active)\n\t\t\t\tschedule_work(&dsp->workq);\n\t\t\tspin_unlock_irqrestore(&dsp_lock, flags);\n\t\t}\n\t\tbreak;\n\tcase (PH_DATA_IND):\n\tcase (DL_DATA_IND):\n\t\tif (skb->len < 1) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tif (dsp->rx_is_off) {\n\t\t\tif (dsp_debug & DEBUG_DSP_CORE)\n\t\t\t\tprintk(KERN_DEBUG \"%s: rx-data during rx_off\"\n\t\t\t\t       \" for %s\\n\",\n\t\t\t\t       __func__, dsp->name);\n\t\t}\n\t\tif (dsp->hdlc) {\n\t\t\t \n\t\t\tspin_lock_irqsave(&dsp_lock, flags);\n\t\t\tdsp_cmx_hdlc(dsp, skb);\n\t\t\tspin_unlock_irqrestore(&dsp_lock, flags);\n\t\t\tif (dsp->rx_disabled) {\n\t\t\t\t \n\t\t\t\tbreak;\n\t\t\t}\n\t\t\thh->prim = DL_DATA_IND;\n\t\t\tif (dsp->up)\n\t\t\t\treturn dsp->up->send(dsp->up, skb);\n\t\t\tbreak;\n\t\t}\n\n\t\tspin_lock_irqsave(&dsp_lock, flags);\n\n\t\t \n\t\tif (dsp->bf_enable)\n\t\t\tdsp_bf_decrypt(dsp, skb->data, skb->len);\n\t\t \n\t\tif (dsp->pipeline.inuse)\n\t\t\tdsp_pipeline_process_rx(&dsp->pipeline, skb->data,\n\t\t\t\t\t\tskb->len, hh->id);\n\t\t \n\t\tif (dsp->rx_volume)\n\t\t\tdsp_change_volume(skb, dsp->rx_volume);\n\t\t \n\t\tif (dsp->dtmf.software) {\n\t\t\tdigits = dsp_dtmf_goertzel_decode(dsp, skb->data,\n\t\t\t\t\t\t\t  skb->len, (dsp_options & DSP_OPT_ULAW) ? 1 : 0);\n\t\t}\n\t\t \n\t\tif (dsp->conf && dsp->conf->software) {\n\t\t\t \n\t\t\tdsp_cmx_receive(dsp, skb);\n\t\t}\n\n\t\tspin_unlock_irqrestore(&dsp_lock, flags);\n\n\t\t \n\t\tif (digits) {\n\t\t\twhile (*digits) {\n\t\t\t\tint k;\n\t\t\t\tstruct sk_buff *nskb;\n\t\t\t\tif (dsp_debug & DEBUG_DSP_DTMF)\n\t\t\t\t\tprintk(KERN_DEBUG \"%s: digit\"\n\t\t\t\t\t       \"(%c) to layer %s\\n\",\n\t\t\t\t\t       __func__, *digits, dsp->name);\n\t\t\t\tk = *digits | DTMF_TONE_VAL;\n\t\t\t\tnskb = _alloc_mISDN_skb(PH_CONTROL_IND,\n\t\t\t\t\t\t\tMISDN_ID_ANY, sizeof(int), &k,\n\t\t\t\t\t\t\tGFP_ATOMIC);\n\t\t\t\tif (nskb) {\n\t\t\t\t\tif (dsp->up) {\n\t\t\t\t\t\tif (dsp->up->send(\n\t\t\t\t\t\t\t    dsp->up, nskb))\n\t\t\t\t\t\t\tdev_kfree_skb(nskb);\n\t\t\t\t\t} else\n\t\t\t\t\t\tdev_kfree_skb(nskb);\n\t\t\t\t}\n\t\t\t\tdigits++;\n\t\t\t}\n\t\t}\n\t\tif (dsp->rx_disabled) {\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\t\thh->prim = DL_DATA_IND;\n\t\tif (dsp->up)\n\t\t\treturn dsp->up->send(dsp->up, skb);\n\t\tbreak;\n\tcase (PH_CONTROL_IND):\n\t\tif (dsp_debug & DEBUG_DSP_DTMFCOEFF)\n\t\t\tprintk(KERN_DEBUG \"%s: PH_CONTROL INDICATION \"\n\t\t\t       \"received: %x (len %d) %s\\n\", __func__,\n\t\t\t       hh->id, skb->len, dsp->name);\n\t\tswitch (hh->id) {\n\t\tcase (DTMF_HFC_COEF):  \n\t\t\tif (!dsp->dtmf.hardware) {\n\t\t\t\tif (dsp_debug & DEBUG_DSP_DTMFCOEFF)\n\t\t\t\t\tprintk(KERN_DEBUG \"%s: ignoring DTMF \"\n\t\t\t\t\t       \"coefficients from HFC\\n\",\n\t\t\t\t\t       __func__);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdigits = dsp_dtmf_goertzel_decode(dsp, skb->data,\n\t\t\t\t\t\t\t  skb->len, 2);\n\t\t\twhile (*digits) {\n\t\t\t\tint k;\n\t\t\t\tstruct sk_buff *nskb;\n\t\t\t\tif (dsp_debug & DEBUG_DSP_DTMF)\n\t\t\t\t\tprintk(KERN_DEBUG \"%s: digit\"\n\t\t\t\t\t       \"(%c) to layer %s\\n\",\n\t\t\t\t\t       __func__, *digits, dsp->name);\n\t\t\t\tk = *digits | DTMF_TONE_VAL;\n\t\t\t\tnskb = _alloc_mISDN_skb(PH_CONTROL_IND,\n\t\t\t\t\t\t\tMISDN_ID_ANY, sizeof(int), &k,\n\t\t\t\t\t\t\tGFP_ATOMIC);\n\t\t\t\tif (nskb) {\n\t\t\t\t\tif (dsp->up) {\n\t\t\t\t\t\tif (dsp->up->send(\n\t\t\t\t\t\t\t    dsp->up, nskb))\n\t\t\t\t\t\t\tdev_kfree_skb(nskb);\n\t\t\t\t\t} else\n\t\t\t\t\t\tdev_kfree_skb(nskb);\n\t\t\t\t}\n\t\t\t\tdigits++;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase (HFC_VOL_CHANGE_TX):  \n\t\t\tif (skb->len != sizeof(int)) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tspin_lock_irqsave(&dsp_lock, flags);\n\t\t\tdsp->tx_volume = *((int *)skb->data);\n\t\t\tif (dsp_debug & DEBUG_DSP_CORE)\n\t\t\t\tprintk(KERN_DEBUG \"%s: change tx volume to \"\n\t\t\t\t       \"%d\\n\", __func__, dsp->tx_volume);\n\t\t\tdsp_cmx_hardware(dsp->conf, dsp);\n\t\t\tdsp_dtmf_hardware(dsp);\n\t\t\tdsp_rx_off(dsp);\n\t\t\tspin_unlock_irqrestore(&dsp_lock, flags);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (dsp_debug & DEBUG_DSP_CORE)\n\t\t\t\tprintk(KERN_DEBUG \"%s: ctrl ind %x unhandled \"\n\t\t\t\t       \"%s\\n\", __func__, hh->id, dsp->name);\n\t\t\tret = -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase (PH_ACTIVATE_IND):\n\tcase (PH_ACTIVATE_CNF):\n\t\tif (dsp_debug & DEBUG_DSP_CORE)\n\t\t\tprintk(KERN_DEBUG \"%s: b_channel is now active %s\\n\",\n\t\t\t       __func__, dsp->name);\n\t\t \n\t\tspin_lock_irqsave(&dsp_lock, flags);\n\t\tdsp->b_active = 1;\n\t\tdsp->data_pending = 0;\n\t\tdsp->rx_init = 1;\n\t\t \n\t\tdsp->rx_W = 0;\n\t\tdsp->rx_R = 0;\n\t\tmemset(dsp->rx_buff, 0, sizeof(dsp->rx_buff));\n\t\tdsp_cmx_hardware(dsp->conf, dsp);\n\t\tdsp_dtmf_hardware(dsp);\n\t\tdsp_rx_off(dsp);\n\t\tspin_unlock_irqrestore(&dsp_lock, flags);\n\t\tif (dsp_debug & DEBUG_DSP_CORE)\n\t\t\tprintk(KERN_DEBUG \"%s: done with activation, sending \"\n\t\t\t       \"confirm to user space. %s\\n\", __func__,\n\t\t\t       dsp->name);\n\t\t \n\t\thh->prim = DL_ESTABLISH_CNF;\n\t\tif (dsp->up)\n\t\t\treturn dsp->up->send(dsp->up, skb);\n\t\tbreak;\n\tcase (PH_DEACTIVATE_IND):\n\tcase (PH_DEACTIVATE_CNF):\n\t\tif (dsp_debug & DEBUG_DSP_CORE)\n\t\t\tprintk(KERN_DEBUG \"%s: b_channel is now inactive %s\\n\",\n\t\t\t       __func__, dsp->name);\n\t\t \n\t\tspin_lock_irqsave(&dsp_lock, flags);\n\t\tdsp->b_active = 0;\n\t\tdsp->data_pending = 0;\n\t\tdsp_cmx_hardware(dsp->conf, dsp);\n\t\tdsp_rx_off(dsp);\n\t\tspin_unlock_irqrestore(&dsp_lock, flags);\n\t\thh->prim = DL_RELEASE_CNF;\n\t\tif (dsp->up)\n\t\t\treturn dsp->up->send(dsp->up, skb);\n\t\tbreak;\n\t\t \n\tcase (DL_DATA_REQ):\n\tcase (PH_DATA_REQ):\n\t\tif (skb->len < 1) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tif (dsp->hdlc) {\n\t\t\t \n\t\t\tif (!dsp->b_active) {\n\t\t\t\tret = -EIO;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\thh->prim = PH_DATA_REQ;\n\t\t\tspin_lock_irqsave(&dsp_lock, flags);\n\t\t\tskb_queue_tail(&dsp->sendq, skb);\n\t\t\tschedule_work(&dsp->workq);\n\t\t\tspin_unlock_irqrestore(&dsp_lock, flags);\n\t\t\treturn 0;\n\t\t}\n\t\t \n\t\tif (!dsp->tone.tone) {\n\t\t\tspin_lock_irqsave(&dsp_lock, flags);\n\t\t\tdsp_cmx_transmit(dsp, skb);\n\t\t\tspin_unlock_irqrestore(&dsp_lock, flags);\n\t\t}\n\t\tbreak;\n\tcase (PH_CONTROL_REQ):\n\t\tspin_lock_irqsave(&dsp_lock, flags);\n\t\tret = dsp_control_req(dsp, hh, skb);\n\t\tspin_unlock_irqrestore(&dsp_lock, flags);\n\t\tbreak;\n\tcase (DL_ESTABLISH_REQ):\n\tcase (PH_ACTIVATE_REQ):\n\t\tif (dsp_debug & DEBUG_DSP_CORE)\n\t\t\tprintk(KERN_DEBUG \"%s: activating b_channel %s\\n\",\n\t\t\t       __func__, dsp->name);\n\t\tif (dsp->dtmf.hardware || dsp->dtmf.software)\n\t\t\tdsp_dtmf_goertzel_init(dsp);\n\t\tget_features(ch);\n\t\t \n\t\tif (dsp->features_fill_empty)\n\t\t\tdsp_fill_empty(dsp);\n\t\t \n\t\thh->prim = PH_ACTIVATE_REQ;\n\t\tif (ch->peer)\n\t\t\treturn ch->recv(ch->peer, skb);\n\t\tbreak;\n\tcase (DL_RELEASE_REQ):\n\tcase (PH_DEACTIVATE_REQ):\n\t\tif (dsp_debug & DEBUG_DSP_CORE)\n\t\t\tprintk(KERN_DEBUG \"%s: releasing b_channel %s\\n\",\n\t\t\t       __func__, dsp->name);\n\t\tspin_lock_irqsave(&dsp_lock, flags);\n\t\tdsp->tone.tone = 0;\n\t\tdsp->tone.hardware = 0;\n\t\tdsp->tone.software = 0;\n\t\tif (timer_pending(&dsp->tone.tl))\n\t\t\tdel_timer(&dsp->tone.tl);\n\t\tif (dsp->conf)\n\t\t\tdsp_cmx_conf(dsp, 0);  \n\t\tskb_queue_purge(&dsp->sendq);\n\t\tspin_unlock_irqrestore(&dsp_lock, flags);\n\t\thh->prim = PH_DEACTIVATE_REQ;\n\t\tif (ch->peer)\n\t\t\treturn ch->recv(ch->peer, skb);\n\t\tbreak;\n\tdefault:\n\t\tif (dsp_debug & DEBUG_DSP_CORE)\n\t\t\tprintk(KERN_DEBUG \"%s: msg %x unhandled %s\\n\",\n\t\t\t       __func__, hh->prim, dsp->name);\n\t\tret = -EINVAL;\n\t}\n\tif (!ret)\n\t\tdev_kfree_skb(skb);\n\treturn ret;\n}\n\nstatic int\ndsp_ctrl(struct mISDNchannel *ch, u_int cmd, void *arg)\n{\n\tstruct dsp\t\t*dsp = container_of(ch, struct dsp, ch);\n\tu_long\t\tflags;\n\n\tif (debug & DEBUG_DSP_CTRL)\n\t\tprintk(KERN_DEBUG \"%s:(%x)\\n\", __func__, cmd);\n\n\tswitch (cmd) {\n\tcase OPEN_CHANNEL:\n\t\tbreak;\n\tcase CLOSE_CHANNEL:\n\t\tif (dsp->ch.peer)\n\t\t\tdsp->ch.peer->ctrl(dsp->ch.peer, CLOSE_CHANNEL, NULL);\n\n\t\t \n\t\tspin_lock_irqsave(&dsp_lock, flags);\n\t\tdsp->b_active = 0;\n\t\tspin_unlock_irqrestore(&dsp_lock, flags);\n\t\t \n\t\tcancel_work_sync(&dsp->workq);\n\t\tspin_lock_irqsave(&dsp_lock, flags);\n\t\tif (timer_pending(&dsp->tone.tl))\n\t\t\tdel_timer(&dsp->tone.tl);\n\t\tskb_queue_purge(&dsp->sendq);\n\t\tif (dsp_debug & DEBUG_DSP_CTRL)\n\t\t\tprintk(KERN_DEBUG \"%s: releasing member %s\\n\",\n\t\t\t       __func__, dsp->name);\n\t\tdsp->b_active = 0;\n\t\tdsp_cmx_conf(dsp, 0);  \n\t\tdsp_pipeline_destroy(&dsp->pipeline);\n\n\t\tif (dsp_debug & DEBUG_DSP_CTRL)\n\t\t\tprintk(KERN_DEBUG \"%s: remove & destroy object %s\\n\",\n\t\t\t       __func__, dsp->name);\n\t\tlist_del(&dsp->list);\n\t\tspin_unlock_irqrestore(&dsp_lock, flags);\n\n\t\tif (dsp_debug & DEBUG_DSP_CTRL)\n\t\t\tprintk(KERN_DEBUG \"%s: dsp instance released\\n\",\n\t\t\t       __func__);\n\t\tvfree(dsp);\n\t\tmodule_put(THIS_MODULE);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic void\ndsp_send_bh(struct work_struct *work)\n{\n\tstruct dsp *dsp = container_of(work, struct dsp, workq);\n\tstruct sk_buff *skb;\n\tstruct mISDNhead\t*hh;\n\n\tif (dsp->hdlc && dsp->data_pending)\n\t\treturn;  \n\n\t \n\twhile ((skb = skb_dequeue(&dsp->sendq))) {\n\t\t \n\t\tif (dsp->data_pending) {\n\t\t\tif (dsp_debug & DEBUG_DSP_CORE)\n\t\t\t\tprintk(KERN_DEBUG \"%s: fifo full %s, this is \"\n\t\t\t\t       \"no bug!\\n\", __func__, dsp->name);\n\t\t\t \n\t\t\tdev_kfree_skb(skb);\n\t\t\tcontinue;\n\t\t}\n\t\thh = mISDN_HEAD_P(skb);\n\t\tif (hh->prim == DL_DATA_REQ) {\n\t\t\t \n\t\t\tif (dsp->up) {\n\t\t\t\tif (dsp->up->send(dsp->up, skb))\n\t\t\t\t\tdev_kfree_skb(skb);\n\t\t\t} else\n\t\t\t\tdev_kfree_skb(skb);\n\t\t} else {\n\t\t\t \n\t\t\tif (dsp->ch.peer) {\n\t\t\t\tdsp->data_pending = 1;\n\t\t\t\tif (dsp->ch.recv(dsp->ch.peer, skb)) {\n\t\t\t\t\tdev_kfree_skb(skb);\n\t\t\t\t\tdsp->data_pending = 0;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\tdev_kfree_skb(skb);\n\t\t}\n\t}\n}\n\nstatic int\ndspcreate(struct channel_req *crq)\n{\n\tstruct dsp\t\t*ndsp;\n\tu_long\t\tflags;\n\n\tif (crq->protocol != ISDN_P_B_L2DSP\n\t    && crq->protocol != ISDN_P_B_L2DSPHDLC)\n\t\treturn -EPROTONOSUPPORT;\n\tndsp = vzalloc(sizeof(struct dsp));\n\tif (!ndsp) {\n\t\tprintk(KERN_ERR \"%s: vmalloc struct dsp failed\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\tif (dsp_debug & DEBUG_DSP_CTRL)\n\t\tprintk(KERN_DEBUG \"%s: creating new dsp instance\\n\", __func__);\n\n\t \n\tINIT_WORK(&ndsp->workq, (void *)dsp_send_bh);\n\tskb_queue_head_init(&ndsp->sendq);\n\tndsp->ch.send = dsp_function;\n\tndsp->ch.ctrl = dsp_ctrl;\n\tndsp->up = crq->ch;\n\tcrq->ch = &ndsp->ch;\n\tif (crq->protocol == ISDN_P_B_L2DSP) {\n\t\tcrq->protocol = ISDN_P_B_RAW;\n\t\tndsp->hdlc = 0;\n\t} else {\n\t\tcrq->protocol = ISDN_P_B_HDLC;\n\t\tndsp->hdlc = 1;\n\t}\n\tif (!try_module_get(THIS_MODULE))\n\t\tprintk(KERN_WARNING \"%s:cannot get module\\n\",\n\t\t       __func__);\n\n\tsprintf(ndsp->name, \"DSP_C%x(0x%p)\",\n\t\tndsp->up->st->dev->id + 1, ndsp);\n\t \n\tndsp->features.hfc_id = -1;  \n\tndsp->features.pcm_id = -1;  \n\tndsp->pcm_slot_rx = -1;  \n\tndsp->pcm_slot_tx = -1;\n\tndsp->pcm_bank_rx = -1;\n\tndsp->pcm_bank_tx = -1;\n\tndsp->hfc_conf = -1;  \n\t \n\ttimer_setup(&ndsp->tone.tl, dsp_tone_timeout, 0);\n\n\tif (dtmfthreshold < 20 || dtmfthreshold > 500)\n\t\tdtmfthreshold = 200;\n\tndsp->dtmf.treshold = dtmfthreshold * 10000;\n\n\t \n\tspin_lock_irqsave(&dsp_lock, flags);\n\tdsp_pipeline_init(&ndsp->pipeline);\n\tlist_add_tail(&ndsp->list, &dsp_ilist);\n\tspin_unlock_irqrestore(&dsp_lock, flags);\n\n\treturn 0;\n}\n\n\nstatic struct Bprotocol DSP = {\n\t.Bprotocols = (1 << (ISDN_P_B_L2DSP & ISDN_P_B_MASK))\n\t| (1 << (ISDN_P_B_L2DSPHDLC & ISDN_P_B_MASK)),\n\t.name = \"dsp\",\n\t.create = dspcreate\n};\n\nstatic int __init dsp_init(void)\n{\n\tint err;\n\tint tics;\n\n\tprintk(KERN_INFO \"DSP module %s\\n\", mISDN_dsp_revision);\n\n\tdsp_options = options;\n\tdsp_debug = debug;\n\n\t \n\tdsp_poll = poll;\n\tif (dsp_poll) {\n\t\tif (dsp_poll > MAX_POLL) {\n\t\t\tprintk(KERN_ERR \"%s: Wrong poll value (%d), use %d \"\n\t\t\t       \"maximum.\\n\", __func__, poll, MAX_POLL);\n\t\t\terr = -EINVAL;\n\t\t\treturn err;\n\t\t}\n\t\tif (dsp_poll < 8) {\n\t\t\tprintk(KERN_ERR \"%s: Wrong poll value (%d), use 8 \"\n\t\t\t       \"minimum.\\n\", __func__, dsp_poll);\n\t\t\terr = -EINVAL;\n\t\t\treturn err;\n\t\t}\n\t\tdsp_tics = poll * HZ / 8000;\n\t\tif (dsp_tics * 8000 != poll * HZ) {\n\t\t\tprintk(KERN_INFO \"mISDN_dsp: Cannot clock every %d \"\n\t\t\t       \"samples (0,125 ms). It is not a multiple of \"\n\t\t\t       \"%d HZ.\\n\", poll, HZ);\n\t\t\terr = -EINVAL;\n\t\t\treturn err;\n\t\t}\n\t} else {\n\t\tpoll = 8;\n\t\twhile (poll <= MAX_POLL) {\n\t\t\ttics = (poll * HZ) / 8000;\n\t\t\tif (tics * 8000 == poll * HZ) {\n\t\t\t\tdsp_tics = tics;\n\t\t\t\tdsp_poll = poll;\n\t\t\t\tif (poll >= 64)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpoll++;\n\t\t}\n\t}\n\tif (dsp_poll == 0) {\n\t\tprintk(KERN_INFO \"mISDN_dsp: There is no multiple of kernel \"\n\t\t       \"clock that equals exactly the duration of 8-256 \"\n\t\t       \"samples. (Choose kernel clock speed like 100, 250, \"\n\t\t       \"300, 1000)\\n\");\n\t\terr = -EINVAL;\n\t\treturn err;\n\t}\n\tprintk(KERN_INFO \"mISDN_dsp: DSP clocks every %d samples. This equals \"\n\t       \"%d jiffies.\\n\", dsp_poll, dsp_tics);\n\n\t \n\tdsp_audio_generate_law_tables();\n\tdsp_silence = (dsp_options & DSP_OPT_ULAW) ? 0xff : 0x2a;\n\tdsp_audio_law_to_s32 = (dsp_options & DSP_OPT_ULAW) ?\n\t\tdsp_audio_ulaw_to_s32 : dsp_audio_alaw_to_s32;\n\tdsp_audio_generate_s2law_table();\n\tdsp_audio_generate_seven();\n\tdsp_audio_generate_mix_table();\n\tif (dsp_options & DSP_OPT_ULAW)\n\t\tdsp_audio_generate_ulaw_samples();\n\tdsp_audio_generate_volume_changes();\n\n\terr = dsp_pipeline_module_init();\n\tif (err) {\n\t\tprintk(KERN_ERR \"mISDN_dsp: Can't initialize pipeline, \"\n\t\t       \"error(%d)\\n\", err);\n\t\treturn err;\n\t}\n\n\terr = mISDN_register_Bprotocol(&DSP);\n\tif (err) {\n\t\tprintk(KERN_ERR \"Can't register %s error(%d)\\n\", DSP.name, err);\n\t\treturn err;\n\t}\n\n\t \n\ttimer_setup(&dsp_spl_tl, dsp_cmx_send, 0);\n\tdsp_spl_tl.expires = jiffies + dsp_tics;\n\tdsp_spl_jiffies = dsp_spl_tl.expires;\n\tadd_timer(&dsp_spl_tl);\n\n\treturn 0;\n}\n\n\nstatic void __exit dsp_cleanup(void)\n{\n\tmISDN_unregister_Bprotocol(&DSP);\n\n\tdel_timer_sync(&dsp_spl_tl);\n\n\tif (!list_empty(&dsp_ilist)) {\n\t\tprintk(KERN_ERR \"mISDN_dsp: Audio DSP object inst list not \"\n\t\t       \"empty.\\n\");\n\t}\n\tif (!list_empty(&conf_ilist)) {\n\t\tprintk(KERN_ERR \"mISDN_dsp: Conference list not empty. Not \"\n\t\t       \"all memory freed.\\n\");\n\t}\n\n\tdsp_pipeline_module_exit();\n}\n\nmodule_init(dsp_init);\nmodule_exit(dsp_cleanup);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}