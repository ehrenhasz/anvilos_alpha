{
  "module_name": "tei.c",
  "hash_id": "80d3651205e5d4d99df1aa2c09fd5b43d9a06ea693b3c52a6a4249f9155858e4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/isdn/mISDN/tei.c",
  "human_readable_source": "\n \n#include \"layer2.h\"\n#include <linux/random.h>\n#include <linux/slab.h>\n#include \"core.h\"\n\n#define ID_REQUEST\t1\n#define ID_ASSIGNED\t2\n#define ID_DENIED\t3\n#define ID_CHK_REQ\t4\n#define ID_CHK_RES\t5\n#define ID_REMOVE\t6\n#define ID_VERIFY\t7\n\n#define TEI_ENTITY_ID\t0xf\n\n#define MGR_PH_ACTIVE\t16\n#define MGR_PH_NOTREADY\t17\n\n#define DATIMER_VAL\t10000\n\nstatic\tu_int\t*debug;\n\nstatic struct Fsm deactfsm = {NULL, 0, 0, NULL, NULL};\nstatic struct Fsm teifsmu = {NULL, 0, 0, NULL, NULL};\nstatic struct Fsm teifsmn = {NULL, 0, 0, NULL, NULL};\n\nenum {\n\tST_L1_DEACT,\n\tST_L1_DEACT_PENDING,\n\tST_L1_ACTIV,\n};\n#define DEACT_STATE_COUNT (ST_L1_ACTIV + 1)\n\nstatic char *strDeactState[] =\n{\n\t\"ST_L1_DEACT\",\n\t\"ST_L1_DEACT_PENDING\",\n\t\"ST_L1_ACTIV\",\n};\n\nenum {\n\tEV_ACTIVATE,\n\tEV_ACTIVATE_IND,\n\tEV_DEACTIVATE,\n\tEV_DEACTIVATE_IND,\n\tEV_UI,\n\tEV_DATIMER,\n};\n\n#define DEACT_EVENT_COUNT (EV_DATIMER + 1)\n\nstatic char *strDeactEvent[] =\n{\n\t\"EV_ACTIVATE\",\n\t\"EV_ACTIVATE_IND\",\n\t\"EV_DEACTIVATE\",\n\t\"EV_DEACTIVATE_IND\",\n\t\"EV_UI\",\n\t\"EV_DATIMER\",\n};\n\nstatic void\nda_debug(struct FsmInst *fi, char *fmt, ...)\n{\n\tstruct manager\t*mgr = fi->userdata;\n\tstruct va_format vaf;\n\tva_list va;\n\n\tif (!(*debug & DEBUG_L2_TEIFSM))\n\t\treturn;\n\n\tva_start(va, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &va;\n\n\tprintk(KERN_DEBUG \"mgr(%d): %pV\\n\", mgr->ch.st->dev->id, &vaf);\n\n\tva_end(va);\n}\n\nstatic void\nda_activate(struct FsmInst *fi, int event, void *arg)\n{\n\tstruct manager\t*mgr = fi->userdata;\n\n\tif (fi->state == ST_L1_DEACT_PENDING)\n\t\tmISDN_FsmDelTimer(&mgr->datimer, 1);\n\tmISDN_FsmChangeState(fi, ST_L1_ACTIV);\n}\n\nstatic void\nda_deactivate_ind(struct FsmInst *fi, int event, void *arg)\n{\n\tmISDN_FsmChangeState(fi, ST_L1_DEACT);\n}\n\nstatic void\nda_deactivate(struct FsmInst *fi, int event, void *arg)\n{\n\tstruct manager\t*mgr = fi->userdata;\n\tstruct layer2\t*l2;\n\tu_long\t\tflags;\n\n\tread_lock_irqsave(&mgr->lock, flags);\n\tlist_for_each_entry(l2, &mgr->layer2, list) {\n\t\tif (l2->l2m.state > ST_L2_4) {\n\t\t\t \n\t\t\tread_unlock_irqrestore(&mgr->lock, flags);\n\t\t\treturn;\n\t\t}\n\t}\n\tread_unlock_irqrestore(&mgr->lock, flags);\n\t \n\tif (!test_bit(OPTION_L1_HOLD, &mgr->options)) {\n\t\tmISDN_FsmAddTimer(&mgr->datimer, DATIMER_VAL, EV_DATIMER,\n\t\t\t\t  NULL, 1);\n\t\tmISDN_FsmChangeState(fi, ST_L1_DEACT_PENDING);\n\t}\n}\n\nstatic void\nda_ui(struct FsmInst *fi, int event, void *arg)\n{\n\tstruct manager\t*mgr = fi->userdata;\n\n\t \n\tif (!test_bit(OPTION_L1_HOLD, &mgr->options)) {\n\t\tmISDN_FsmDelTimer(&mgr->datimer, 2);\n\t\tmISDN_FsmAddTimer(&mgr->datimer, DATIMER_VAL, EV_DATIMER,\n\t\t\t\t  NULL, 2);\n\t}\n}\n\nstatic void\nda_timer(struct FsmInst *fi, int event, void *arg)\n{\n\tstruct manager\t*mgr = fi->userdata;\n\tstruct layer2\t*l2;\n\tu_long\t\tflags;\n\n\t \n\tread_lock_irqsave(&mgr->lock, flags);\n\tlist_for_each_entry(l2, &mgr->layer2, list) {\n\t\tif (l2->l2m.state > ST_L2_4) {\n\t\t\t \n\t\t\tread_unlock_irqrestore(&mgr->lock, flags);\n\t\t\tmISDN_FsmChangeState(fi, ST_L1_ACTIV);\n\t\t\treturn;\n\t\t}\n\t}\n\tread_unlock_irqrestore(&mgr->lock, flags);\n\t \n\tmISDN_FsmChangeState(fi, ST_L1_DEACT);\n\t_queue_data(&mgr->ch, PH_DEACTIVATE_REQ, MISDN_ID_ANY, 0, NULL,\n\t\t    GFP_ATOMIC);\n}\n\nstatic struct FsmNode DeactFnList[] =\n{\n\t{ST_L1_DEACT, EV_ACTIVATE_IND, da_activate},\n\t{ST_L1_ACTIV, EV_DEACTIVATE_IND, da_deactivate_ind},\n\t{ST_L1_ACTIV, EV_DEACTIVATE, da_deactivate},\n\t{ST_L1_DEACT_PENDING, EV_ACTIVATE, da_activate},\n\t{ST_L1_DEACT_PENDING, EV_UI, da_ui},\n\t{ST_L1_DEACT_PENDING, EV_DATIMER, da_timer},\n};\n\nenum {\n\tST_TEI_NOP,\n\tST_TEI_IDREQ,\n\tST_TEI_IDVERIFY,\n};\n\n#define TEI_STATE_COUNT (ST_TEI_IDVERIFY + 1)\n\nstatic char *strTeiState[] =\n{\n\t\"ST_TEI_NOP\",\n\t\"ST_TEI_IDREQ\",\n\t\"ST_TEI_IDVERIFY\",\n};\n\nenum {\n\tEV_IDREQ,\n\tEV_ASSIGN,\n\tEV_ASSIGN_REQ,\n\tEV_DENIED,\n\tEV_CHKREQ,\n\tEV_CHKRESP,\n\tEV_REMOVE,\n\tEV_VERIFY,\n\tEV_TIMER,\n};\n\n#define TEI_EVENT_COUNT (EV_TIMER + 1)\n\nstatic char *strTeiEvent[] =\n{\n\t\"EV_IDREQ\",\n\t\"EV_ASSIGN\",\n\t\"EV_ASSIGN_REQ\",\n\t\"EV_DENIED\",\n\t\"EV_CHKREQ\",\n\t\"EV_CHKRESP\",\n\t\"EV_REMOVE\",\n\t\"EV_VERIFY\",\n\t\"EV_TIMER\",\n};\n\nstatic void\ntei_debug(struct FsmInst *fi, char *fmt, ...)\n{\n\tstruct teimgr\t*tm = fi->userdata;\n\tstruct va_format vaf;\n\tva_list va;\n\n\tif (!(*debug & DEBUG_L2_TEIFSM))\n\t\treturn;\n\n\tva_start(va, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &va;\n\n\tprintk(KERN_DEBUG \"sapi(%d) tei(%d): %pV\\n\",\n\t       tm->l2->sapi, tm->l2->tei, &vaf);\n\n\tva_end(va);\n}\n\n\n\nstatic int\nget_free_id(struct manager *mgr)\n{\n\tDECLARE_BITMAP(ids, 64) = { [0 ... BITS_TO_LONGS(64) - 1] = 0 };\n\tint\t\ti;\n\tstruct layer2\t*l2;\n\n\tlist_for_each_entry(l2, &mgr->layer2, list) {\n\t\tif (l2->ch.nr > 63) {\n\t\t\tprintk(KERN_WARNING\n\t\t\t       \"%s: more as 63 layer2 for one device\\n\",\n\t\t\t       __func__);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\t__set_bit(l2->ch.nr, ids);\n\t}\n\ti = find_next_zero_bit(ids, 64, 1);\n\tif (i < 64)\n\t\treturn i;\n\tprintk(KERN_WARNING \"%s: more as 63 layer2 for one device\\n\",\n\t       __func__);\n\treturn -EBUSY;\n}\n\nstatic int\nget_free_tei(struct manager *mgr)\n{\n\tDECLARE_BITMAP(ids, 64) = { [0 ... BITS_TO_LONGS(64) - 1] = 0 };\n\tint\t\ti;\n\tstruct layer2\t*l2;\n\n\tlist_for_each_entry(l2, &mgr->layer2, list) {\n\t\tif (l2->ch.nr == 0)\n\t\t\tcontinue;\n\t\tif ((l2->ch.addr & 0xff) != 0)\n\t\t\tcontinue;\n\t\ti = l2->ch.addr >> 8;\n\t\tif (i < 64)\n\t\t\tcontinue;\n\t\ti -= 64;\n\n\t\t__set_bit(i, ids);\n\t}\n\ti = find_first_zero_bit(ids, 64);\n\tif (i < 64)\n\t\treturn i + 64;\n\tprintk(KERN_WARNING \"%s: more as 63 dynamic tei for one device\\n\",\n\t       __func__);\n\treturn -1;\n}\n\nstatic void\nteiup_create(struct manager *mgr, u_int prim, int len, void *arg)\n{\n\tstruct sk_buff\t*skb;\n\tstruct mISDNhead *hh;\n\tint\t\terr;\n\n\tskb = mI_alloc_skb(len, GFP_ATOMIC);\n\tif (!skb)\n\t\treturn;\n\thh = mISDN_HEAD_P(skb);\n\thh->prim = prim;\n\thh->id = (mgr->ch.nr << 16) | mgr->ch.addr;\n\tif (len)\n\t\tskb_put_data(skb, arg, len);\n\terr = mgr->up->send(mgr->up, skb);\n\tif (err) {\n\t\tprintk(KERN_WARNING \"%s: err=%d\\n\", __func__, err);\n\t\tdev_kfree_skb(skb);\n\t}\n}\n\nstatic u_int\nnew_id(struct manager *mgr)\n{\n\tu_int\tid;\n\n\tid = mgr->nextid++;\n\tif (id == 0x7fff)\n\t\tmgr->nextid = 1;\n\tid <<= 16;\n\tid |= GROUP_TEI << 8;\n\tid |= TEI_SAPI;\n\treturn id;\n}\n\nstatic void\ndo_send(struct manager *mgr)\n{\n\tif (!test_bit(MGR_PH_ACTIVE, &mgr->options))\n\t\treturn;\n\n\tif (!test_and_set_bit(MGR_PH_NOTREADY, &mgr->options)) {\n\t\tstruct sk_buff\t*skb = skb_dequeue(&mgr->sendq);\n\n\t\tif (!skb) {\n\t\t\ttest_and_clear_bit(MGR_PH_NOTREADY, &mgr->options);\n\t\t\treturn;\n\t\t}\n\t\tmgr->lastid = mISDN_HEAD_ID(skb);\n\t\tmISDN_FsmEvent(&mgr->deact, EV_UI, NULL);\n\t\tif (mgr->ch.recv(mgr->ch.peer, skb)) {\n\t\t\tdev_kfree_skb(skb);\n\t\t\ttest_and_clear_bit(MGR_PH_NOTREADY, &mgr->options);\n\t\t\tmgr->lastid = MISDN_ID_NONE;\n\t\t}\n\t}\n}\n\nstatic void\ndo_ack(struct manager *mgr, u_int id)\n{\n\tif (test_bit(MGR_PH_NOTREADY, &mgr->options)) {\n\t\tif (id == mgr->lastid) {\n\t\t\tif (test_bit(MGR_PH_ACTIVE, &mgr->options)) {\n\t\t\t\tstruct sk_buff\t*skb;\n\n\t\t\t\tskb = skb_dequeue(&mgr->sendq);\n\t\t\t\tif (skb) {\n\t\t\t\t\tmgr->lastid = mISDN_HEAD_ID(skb);\n\t\t\t\t\tif (!mgr->ch.recv(mgr->ch.peer, skb))\n\t\t\t\t\t\treturn;\n\t\t\t\t\tdev_kfree_skb(skb);\n\t\t\t\t}\n\t\t\t}\n\t\t\tmgr->lastid = MISDN_ID_NONE;\n\t\t\ttest_and_clear_bit(MGR_PH_NOTREADY, &mgr->options);\n\t\t}\n\t}\n}\n\nstatic void\nmgr_send_down(struct manager *mgr, struct sk_buff *skb)\n{\n\tskb_queue_tail(&mgr->sendq, skb);\n\tif (!test_bit(MGR_PH_ACTIVE, &mgr->options)) {\n\t\t_queue_data(&mgr->ch, PH_ACTIVATE_REQ, MISDN_ID_ANY, 0,\n\t\t\t    NULL, GFP_KERNEL);\n\t} else {\n\t\tdo_send(mgr);\n\t}\n}\n\nstatic int\ndl_unit_data(struct manager *mgr, struct sk_buff *skb)\n{\n\tif (!test_bit(MGR_OPT_NETWORK, &mgr->options))  \n\t\treturn -EINVAL;\n\tif (!test_bit(MGR_PH_ACTIVE, &mgr->options))\n\t\t_queue_data(&mgr->ch, PH_ACTIVATE_REQ, MISDN_ID_ANY, 0,\n\t\t\t    NULL, GFP_KERNEL);\n\tskb_push(skb, 3);\n\tskb->data[0] = 0x02;  \n\tskb->data[1] = 0xff;  \n\tskb->data[2] = UI;    \n\tmISDN_HEAD_PRIM(skb) = PH_DATA_REQ;\n\tmISDN_HEAD_ID(skb) = new_id(mgr);\n\tskb_queue_tail(&mgr->sendq, skb);\n\tdo_send(mgr);\n\treturn 0;\n}\n\nstatic unsigned int\nrandom_ri(void)\n{\n\tu16 x;\n\n\tget_random_bytes(&x, sizeof(x));\n\treturn x;\n}\n\nstatic struct layer2 *\nfindtei(struct manager *mgr, int tei)\n{\n\tstruct layer2\t*l2;\n\tu_long\t\tflags;\n\n\tread_lock_irqsave(&mgr->lock, flags);\n\tlist_for_each_entry(l2, &mgr->layer2, list) {\n\t\tif ((l2->sapi == 0) && (l2->tei > 0) &&\n\t\t    (l2->tei != GROUP_TEI) && (l2->tei == tei))\n\t\t\tgoto done;\n\t}\n\tl2 = NULL;\ndone:\n\tread_unlock_irqrestore(&mgr->lock, flags);\n\treturn l2;\n}\n\nstatic void\nput_tei_msg(struct manager *mgr, u_char m_id, unsigned int ri, int tei)\n{\n\tstruct sk_buff *skb;\n\tu_char bp[8];\n\n\tbp[0] = (TEI_SAPI << 2);\n\tif (test_bit(MGR_OPT_NETWORK, &mgr->options))\n\t\tbp[0] |= 2;  \n\tbp[1] = (GROUP_TEI << 1) | 0x1;\n\tbp[2] = UI;\n\tbp[3] = TEI_ENTITY_ID;\n\tbp[4] = ri >> 8;\n\tbp[5] = ri & 0xff;\n\tbp[6] = m_id;\n\tbp[7] = ((tei << 1) & 0xff) | 1;\n\tskb = _alloc_mISDN_skb(PH_DATA_REQ, new_id(mgr), 8, bp, GFP_ATOMIC);\n\tif (!skb) {\n\t\tprintk(KERN_WARNING \"%s: no skb for tei msg\\n\", __func__);\n\t\treturn;\n\t}\n\tmgr_send_down(mgr, skb);\n}\n\nstatic void\ntei_id_request(struct FsmInst *fi, int event, void *arg)\n{\n\tstruct teimgr *tm = fi->userdata;\n\n\tif (tm->l2->tei != GROUP_TEI) {\n\t\ttm->tei_m.printdebug(&tm->tei_m,\n\t\t\t\t     \"assign request for already assigned tei %d\",\n\t\t\t\t     tm->l2->tei);\n\t\treturn;\n\t}\n\ttm->ri = random_ri();\n\tif (*debug & DEBUG_L2_TEI)\n\t\ttm->tei_m.printdebug(&tm->tei_m,\n\t\t\t\t     \"assign request ri %d\", tm->ri);\n\tput_tei_msg(tm->mgr, ID_REQUEST, tm->ri, GROUP_TEI);\n\tmISDN_FsmChangeState(fi, ST_TEI_IDREQ);\n\tmISDN_FsmAddTimer(&tm->timer, tm->tval, EV_TIMER, NULL, 1);\n\ttm->nval = 3;\n}\n\nstatic void\ntei_id_assign(struct FsmInst *fi, int event, void *arg)\n{\n\tstruct teimgr\t*tm = fi->userdata;\n\tstruct layer2\t*l2;\n\tu_char *dp = arg;\n\tint ri, tei;\n\n\tri = ((unsigned int) *dp++ << 8);\n\tri += *dp++;\n\tdp++;\n\ttei = *dp >> 1;\n\tif (*debug & DEBUG_L2_TEI)\n\t\ttm->tei_m.printdebug(fi, \"identity assign ri %d tei %d\",\n\t\t\t\t     ri, tei);\n\tl2 = findtei(tm->mgr, tei);\n\tif (l2) {\t \n\t\tif (ri != l2->tm->ri) {\n\t\t\ttm->tei_m.printdebug(fi,\n\t\t\t\t\t     \"possible duplicate assignment tei %d\", tei);\n\t\t\ttei_l2(l2, MDL_ERROR_RSP, 0);\n\t\t}\n\t} else if (ri == tm->ri) {\n\t\tmISDN_FsmDelTimer(&tm->timer, 1);\n\t\tmISDN_FsmChangeState(fi, ST_TEI_NOP);\n\t\ttei_l2(tm->l2, MDL_ASSIGN_REQ, tei);\n\t}\n}\n\nstatic void\ntei_id_test_dup(struct FsmInst *fi, int event, void *arg)\n{\n\tstruct teimgr\t*tm = fi->userdata;\n\tstruct layer2\t*l2;\n\tu_char *dp = arg;\n\tint tei, ri;\n\n\tri = ((unsigned int) *dp++ << 8);\n\tri += *dp++;\n\tdp++;\n\ttei = *dp >> 1;\n\tif (*debug & DEBUG_L2_TEI)\n\t\ttm->tei_m.printdebug(fi, \"foreign identity assign ri %d tei %d\",\n\t\t\t\t     ri, tei);\n\tl2 = findtei(tm->mgr, tei);\n\tif (l2) {\t \n\t\tif (ri != l2->tm->ri) {\t \n\t\t\ttm->tei_m.printdebug(fi,\n\t\t\t\t\t     \"possible duplicate assignment tei %d\", tei);\n\t\t\tmISDN_FsmEvent(&l2->tm->tei_m, EV_VERIFY, NULL);\n\t\t}\n\t}\n}\n\nstatic void\ntei_id_denied(struct FsmInst *fi, int event, void *arg)\n{\n\tstruct teimgr *tm = fi->userdata;\n\tu_char *dp = arg;\n\tint ri, tei;\n\n\tri = ((unsigned int) *dp++ << 8);\n\tri += *dp++;\n\tdp++;\n\ttei = *dp >> 1;\n\tif (*debug & DEBUG_L2_TEI)\n\t\ttm->tei_m.printdebug(fi, \"identity denied ri %d tei %d\",\n\t\t\t\t     ri, tei);\n}\n\nstatic void\ntei_id_chk_req(struct FsmInst *fi, int event, void *arg)\n{\n\tstruct teimgr *tm = fi->userdata;\n\tu_char *dp = arg;\n\tint tei;\n\n\ttei = *(dp + 3) >> 1;\n\tif (*debug & DEBUG_L2_TEI)\n\t\ttm->tei_m.printdebug(fi, \"identity check req tei %d\", tei);\n\tif ((tm->l2->tei != GROUP_TEI) && ((tei == GROUP_TEI) ||\n\t\t\t\t\t   (tei == tm->l2->tei))) {\n\t\tmISDN_FsmDelTimer(&tm->timer, 4);\n\t\tmISDN_FsmChangeState(&tm->tei_m, ST_TEI_NOP);\n\t\tput_tei_msg(tm->mgr, ID_CHK_RES, random_ri(), tm->l2->tei);\n\t}\n}\n\nstatic void\ntei_id_remove(struct FsmInst *fi, int event, void *arg)\n{\n\tstruct teimgr *tm = fi->userdata;\n\tu_char *dp = arg;\n\tint tei;\n\n\ttei = *(dp + 3) >> 1;\n\tif (*debug & DEBUG_L2_TEI)\n\t\ttm->tei_m.printdebug(fi, \"identity remove tei %d\", tei);\n\tif ((tm->l2->tei != GROUP_TEI) &&\n\t    ((tei == GROUP_TEI) || (tei == tm->l2->tei))) {\n\t\tmISDN_FsmDelTimer(&tm->timer, 5);\n\t\tmISDN_FsmChangeState(&tm->tei_m, ST_TEI_NOP);\n\t\ttei_l2(tm->l2, MDL_REMOVE_REQ, 0);\n\t}\n}\n\nstatic void\ntei_id_verify(struct FsmInst *fi, int event, void *arg)\n{\n\tstruct teimgr *tm = fi->userdata;\n\n\tif (*debug & DEBUG_L2_TEI)\n\t\ttm->tei_m.printdebug(fi, \"id verify request for tei %d\",\n\t\t\t\t     tm->l2->tei);\n\tput_tei_msg(tm->mgr, ID_VERIFY, 0, tm->l2->tei);\n\tmISDN_FsmChangeState(&tm->tei_m, ST_TEI_IDVERIFY);\n\tmISDN_FsmAddTimer(&tm->timer, tm->tval, EV_TIMER, NULL, 2);\n\ttm->nval = 2;\n}\n\nstatic void\ntei_id_req_tout(struct FsmInst *fi, int event, void *arg)\n{\n\tstruct teimgr *tm = fi->userdata;\n\n\tif (--tm->nval) {\n\t\ttm->ri = random_ri();\n\t\tif (*debug & DEBUG_L2_TEI)\n\t\t\ttm->tei_m.printdebug(fi, \"assign req(%d) ri %d\",\n\t\t\t\t\t     4 - tm->nval, tm->ri);\n\t\tput_tei_msg(tm->mgr, ID_REQUEST, tm->ri, GROUP_TEI);\n\t\tmISDN_FsmAddTimer(&tm->timer, tm->tval, EV_TIMER, NULL, 3);\n\t} else {\n\t\ttm->tei_m.printdebug(fi, \"assign req failed\");\n\t\ttei_l2(tm->l2, MDL_ERROR_RSP, 0);\n\t\tmISDN_FsmChangeState(fi, ST_TEI_NOP);\n\t}\n}\n\nstatic void\ntei_id_ver_tout(struct FsmInst *fi, int event, void *arg)\n{\n\tstruct teimgr *tm = fi->userdata;\n\n\tif (--tm->nval) {\n\t\tif (*debug & DEBUG_L2_TEI)\n\t\t\ttm->tei_m.printdebug(fi,\n\t\t\t\t\t     \"id verify req(%d) for tei %d\",\n\t\t\t\t\t     3 - tm->nval, tm->l2->tei);\n\t\tput_tei_msg(tm->mgr, ID_VERIFY, 0, tm->l2->tei);\n\t\tmISDN_FsmAddTimer(&tm->timer, tm->tval, EV_TIMER, NULL, 4);\n\t} else {\n\t\ttm->tei_m.printdebug(fi, \"verify req for tei %d failed\",\n\t\t\t\t     tm->l2->tei);\n\t\ttei_l2(tm->l2, MDL_REMOVE_REQ, 0);\n\t\tmISDN_FsmChangeState(fi, ST_TEI_NOP);\n\t}\n}\n\nstatic struct FsmNode TeiFnListUser[] =\n{\n\t{ST_TEI_NOP, EV_IDREQ, tei_id_request},\n\t{ST_TEI_NOP, EV_ASSIGN, tei_id_test_dup},\n\t{ST_TEI_NOP, EV_VERIFY, tei_id_verify},\n\t{ST_TEI_NOP, EV_REMOVE, tei_id_remove},\n\t{ST_TEI_NOP, EV_CHKREQ, tei_id_chk_req},\n\t{ST_TEI_IDREQ, EV_TIMER, tei_id_req_tout},\n\t{ST_TEI_IDREQ, EV_ASSIGN, tei_id_assign},\n\t{ST_TEI_IDREQ, EV_DENIED, tei_id_denied},\n\t{ST_TEI_IDVERIFY, EV_TIMER, tei_id_ver_tout},\n\t{ST_TEI_IDVERIFY, EV_REMOVE, tei_id_remove},\n\t{ST_TEI_IDVERIFY, EV_CHKREQ, tei_id_chk_req},\n};\n\nstatic void\ntei_l2remove(struct layer2 *l2)\n{\n\tput_tei_msg(l2->tm->mgr, ID_REMOVE, 0, l2->tei);\n\ttei_l2(l2, MDL_REMOVE_REQ, 0);\n\tlist_del(&l2->ch.list);\n\tl2->ch.ctrl(&l2->ch, CLOSE_CHANNEL, NULL);\n}\n\nstatic void\ntei_assign_req(struct FsmInst *fi, int event, void *arg)\n{\n\tstruct teimgr *tm = fi->userdata;\n\tu_char *dp = arg;\n\n\tif (tm->l2->tei == GROUP_TEI) {\n\t\ttm->tei_m.printdebug(&tm->tei_m,\n\t\t\t\t     \"net tei assign request without tei\");\n\t\treturn;\n\t}\n\ttm->ri = ((unsigned int) *dp++ << 8);\n\ttm->ri += *dp++;\n\tif (*debug & DEBUG_L2_TEI)\n\t\ttm->tei_m.printdebug(&tm->tei_m,\n\t\t\t\t     \"net assign request ri %d teim %d\", tm->ri, *dp);\n\tput_tei_msg(tm->mgr, ID_ASSIGNED, tm->ri, tm->l2->tei);\n\tmISDN_FsmChangeState(fi, ST_TEI_NOP);\n}\n\nstatic void\ntei_id_chk_req_net(struct FsmInst *fi, int event, void *arg)\n{\n\tstruct teimgr\t*tm = fi->userdata;\n\n\tif (*debug & DEBUG_L2_TEI)\n\t\ttm->tei_m.printdebug(fi, \"id check request for tei %d\",\n\t\t\t\t     tm->l2->tei);\n\ttm->rcnt = 0;\n\tput_tei_msg(tm->mgr, ID_CHK_REQ, 0, tm->l2->tei);\n\tmISDN_FsmChangeState(&tm->tei_m, ST_TEI_IDVERIFY);\n\tmISDN_FsmAddTimer(&tm->timer, tm->tval, EV_TIMER, NULL, 2);\n\ttm->nval = 2;\n}\n\nstatic void\ntei_id_chk_resp(struct FsmInst *fi, int event, void *arg)\n{\n\tstruct teimgr *tm = fi->userdata;\n\tu_char *dp = arg;\n\tint tei;\n\n\ttei = dp[3] >> 1;\n\tif (*debug & DEBUG_L2_TEI)\n\t\ttm->tei_m.printdebug(fi, \"identity check resp tei %d\", tei);\n\tif (tei == tm->l2->tei)\n\t\ttm->rcnt++;\n}\n\nstatic void\ntei_id_verify_net(struct FsmInst *fi, int event, void *arg)\n{\n\tstruct teimgr *tm = fi->userdata;\n\tu_char *dp = arg;\n\tint tei;\n\n\ttei = dp[3] >> 1;\n\tif (*debug & DEBUG_L2_TEI)\n\t\ttm->tei_m.printdebug(fi, \"identity verify req tei %d/%d\",\n\t\t\t\t     tei, tm->l2->tei);\n\tif (tei == tm->l2->tei)\n\t\ttei_id_chk_req_net(fi, event, arg);\n}\n\nstatic void\ntei_id_ver_tout_net(struct FsmInst *fi, int event, void *arg)\n{\n\tstruct teimgr *tm = fi->userdata;\n\n\tif (tm->rcnt == 1) {\n\t\tif (*debug & DEBUG_L2_TEI)\n\t\t\ttm->tei_m.printdebug(fi,\n\t\t\t\t\t     \"check req for tei %d successful\\n\", tm->l2->tei);\n\t\tmISDN_FsmChangeState(fi, ST_TEI_NOP);\n\t} else if (tm->rcnt > 1) {\n\t\t \n\t\ttei_l2remove(tm->l2);\n\t} else if (--tm->nval) {\n\t\tif (*debug & DEBUG_L2_TEI)\n\t\t\ttm->tei_m.printdebug(fi,\n\t\t\t\t\t     \"id check req(%d) for tei %d\",\n\t\t\t\t\t     3 - tm->nval, tm->l2->tei);\n\t\tput_tei_msg(tm->mgr, ID_CHK_REQ, 0, tm->l2->tei);\n\t\tmISDN_FsmAddTimer(&tm->timer, tm->tval, EV_TIMER, NULL, 4);\n\t} else {\n\t\ttm->tei_m.printdebug(fi, \"check req for tei %d failed\",\n\t\t\t\t     tm->l2->tei);\n\t\tmISDN_FsmChangeState(fi, ST_TEI_NOP);\n\t\ttei_l2remove(tm->l2);\n\t}\n}\n\nstatic struct FsmNode TeiFnListNet[] =\n{\n\t{ST_TEI_NOP, EV_ASSIGN_REQ, tei_assign_req},\n\t{ST_TEI_NOP, EV_VERIFY, tei_id_verify_net},\n\t{ST_TEI_NOP, EV_CHKREQ, tei_id_chk_req_net},\n\t{ST_TEI_IDVERIFY, EV_TIMER, tei_id_ver_tout_net},\n\t{ST_TEI_IDVERIFY, EV_CHKRESP, tei_id_chk_resp},\n};\n\nstatic void\ntei_ph_data_ind(struct teimgr *tm, u_int mt, u_char *dp, int len)\n{\n\tif (test_bit(FLG_FIXED_TEI, &tm->l2->flag))\n\t\treturn;\n\tif (*debug & DEBUG_L2_TEI)\n\t\ttm->tei_m.printdebug(&tm->tei_m, \"tei handler mt %x\", mt);\n\tif (mt == ID_ASSIGNED)\n\t\tmISDN_FsmEvent(&tm->tei_m, EV_ASSIGN, dp);\n\telse if (mt == ID_DENIED)\n\t\tmISDN_FsmEvent(&tm->tei_m, EV_DENIED, dp);\n\telse if (mt == ID_CHK_REQ)\n\t\tmISDN_FsmEvent(&tm->tei_m, EV_CHKREQ, dp);\n\telse if (mt == ID_REMOVE)\n\t\tmISDN_FsmEvent(&tm->tei_m, EV_REMOVE, dp);\n\telse if (mt == ID_VERIFY)\n\t\tmISDN_FsmEvent(&tm->tei_m, EV_VERIFY, dp);\n\telse if (mt == ID_CHK_RES)\n\t\tmISDN_FsmEvent(&tm->tei_m, EV_CHKRESP, dp);\n}\n\nstatic struct layer2 *\ncreate_new_tei(struct manager *mgr, int tei, int sapi)\n{\n\tunsigned long\t\topt = 0;\n\tunsigned long\t\tflags;\n\tint\t\t\tid;\n\tstruct layer2\t\t*l2;\n\tstruct channel_req\trq;\n\n\tif (!mgr->up)\n\t\treturn NULL;\n\tif ((tei >= 0) && (tei < 64))\n\t\ttest_and_set_bit(OPTION_L2_FIXEDTEI, &opt);\n\tif (mgr->ch.st->dev->Dprotocols & ((1 << ISDN_P_TE_E1) |\n\t    (1 << ISDN_P_NT_E1))) {\n\t\ttest_and_set_bit(OPTION_L2_PMX, &opt);\n\t\trq.protocol = ISDN_P_NT_E1;\n\t} else {\n\t\trq.protocol = ISDN_P_NT_S0;\n\t}\n\tl2 = create_l2(mgr->up, ISDN_P_LAPD_NT, opt, tei, sapi);\n\tif (!l2) {\n\t\tprintk(KERN_WARNING \"%s:no memory for layer2\\n\", __func__);\n\t\treturn NULL;\n\t}\n\tl2->tm = kzalloc(sizeof(struct teimgr), GFP_KERNEL);\n\tif (!l2->tm) {\n\t\tkfree(l2);\n\t\tprintk(KERN_WARNING \"%s:no memory for teimgr\\n\", __func__);\n\t\treturn NULL;\n\t}\n\tl2->tm->mgr = mgr;\n\tl2->tm->l2 = l2;\n\tl2->tm->tei_m.debug = *debug & DEBUG_L2_TEIFSM;\n\tl2->tm->tei_m.userdata = l2->tm;\n\tl2->tm->tei_m.printdebug = tei_debug;\n\tl2->tm->tei_m.fsm = &teifsmn;\n\tl2->tm->tei_m.state = ST_TEI_NOP;\n\tl2->tm->tval = 2000;  \n\tmISDN_FsmInitTimer(&l2->tm->tei_m, &l2->tm->timer);\n\twrite_lock_irqsave(&mgr->lock, flags);\n\tid = get_free_id(mgr);\n\tlist_add_tail(&l2->list, &mgr->layer2);\n\twrite_unlock_irqrestore(&mgr->lock, flags);\n\tif (id < 0) {\n\t\tl2->ch.ctrl(&l2->ch, CLOSE_CHANNEL, NULL);\n\t\tprintk(KERN_WARNING \"%s:no free id\\n\", __func__);\n\t\treturn NULL;\n\t} else {\n\t\tl2->ch.nr = id;\n\t\t__add_layer2(&l2->ch, mgr->ch.st);\n\t\tl2->ch.recv = mgr->ch.recv;\n\t\tl2->ch.peer = mgr->ch.peer;\n\t\tl2->ch.ctrl(&l2->ch, OPEN_CHANNEL, NULL);\n\t\t \n\t\trq.adr.dev = mgr->ch.st->dev->id;\n\t\tid = mgr->ch.st->own.ctrl(&mgr->ch.st->own, OPEN_CHANNEL, &rq);\n\t\tif (id < 0) {\n\t\t\tprintk(KERN_WARNING \"%s: cannot open L1\\n\", __func__);\n\t\t\tl2->ch.ctrl(&l2->ch, CLOSE_CHANNEL, NULL);\n\t\t\tl2 = NULL;\n\t\t}\n\t}\n\treturn l2;\n}\n\nstatic void\nnew_tei_req(struct manager *mgr, u_char *dp)\n{\n\tint\t\ttei, ri;\n\tstruct layer2\t*l2;\n\n\tri = dp[0] << 8;\n\tri += dp[1];\n\tif (!mgr->up)\n\t\tgoto denied;\n\tif (!(dp[3] & 1))  \n\t\tgoto denied;\n\tif (dp[3] != 0xff)\n\t\ttei = dp[3] >> 1;  \n\telse\n\t\ttei = get_free_tei(mgr);\n\tif (tei < 0) {\n\t\tprintk(KERN_WARNING \"%s:No free tei\\n\", __func__);\n\t\tgoto denied;\n\t}\n\tl2 = create_new_tei(mgr, tei, CTRL_SAPI);\n\tif (!l2)\n\t\tgoto denied;\n\telse\n\t\tmISDN_FsmEvent(&l2->tm->tei_m, EV_ASSIGN_REQ, dp);\n\treturn;\ndenied:\n\tput_tei_msg(mgr, ID_DENIED, ri, GROUP_TEI);\n}\n\nstatic int\nph_data_ind(struct manager *mgr, struct sk_buff *skb)\n{\n\tint\t\tret = -EINVAL;\n\tstruct layer2\t*l2, *nl2;\n\tu_char\t\tmt;\n\n\tif (skb->len < 8) {\n\t\tif (*debug  & DEBUG_L2_TEI)\n\t\t\tprintk(KERN_DEBUG \"%s: short mgr frame %d/8\\n\",\n\t\t\t       __func__, skb->len);\n\t\tgoto done;\n\t}\n\n\tif ((skb->data[0] >> 2) != TEI_SAPI)  \n\t\tgoto done;\n\tif (skb->data[0] & 1)  \n\t\tgoto done;\n\tif (!(skb->data[1] & 1))  \n\t\tgoto done;\n\tif ((skb->data[1] >> 1) != GROUP_TEI)  \n\t\tgoto done;\n\tif ((skb->data[2] & 0xef) != UI)  \n\t\tgoto done;\n\tif (skb->data[3] != TEI_ENTITY_ID)  \n\t\tgoto done;\n\tmt = skb->data[6];\n\tswitch (mt) {\n\tcase ID_REQUEST:\n\tcase ID_CHK_RES:\n\tcase ID_VERIFY:\n\t\tif (!test_bit(MGR_OPT_NETWORK, &mgr->options))\n\t\t\tgoto done;\n\t\tbreak;\n\tcase ID_ASSIGNED:\n\tcase ID_DENIED:\n\tcase ID_CHK_REQ:\n\tcase ID_REMOVE:\n\t\tif (test_bit(MGR_OPT_NETWORK, &mgr->options))\n\t\t\tgoto done;\n\t\tbreak;\n\tdefault:\n\t\tgoto done;\n\t}\n\tret = 0;\n\tif (mt == ID_REQUEST) {\n\t\tnew_tei_req(mgr, &skb->data[4]);\n\t\tgoto done;\n\t}\n\tlist_for_each_entry_safe(l2, nl2, &mgr->layer2, list) {\n\t\ttei_ph_data_ind(l2->tm, mt, &skb->data[4], skb->len - 4);\n\t}\ndone:\n\treturn ret;\n}\n\nint\nl2_tei(struct layer2 *l2, u_int cmd, u_long arg)\n{\n\tstruct teimgr\t*tm = l2->tm;\n\n\tif (test_bit(FLG_FIXED_TEI, &l2->flag))\n\t\treturn 0;\n\tif (*debug & DEBUG_L2_TEI)\n\t\tprintk(KERN_DEBUG \"%s: cmd(%x)\\n\", __func__, cmd);\n\tswitch (cmd) {\n\tcase MDL_ASSIGN_IND:\n\t\tmISDN_FsmEvent(&tm->tei_m, EV_IDREQ, NULL);\n\t\tbreak;\n\tcase MDL_ERROR_IND:\n\t\tif (test_bit(MGR_OPT_NETWORK, &tm->mgr->options))\n\t\t\tmISDN_FsmEvent(&tm->tei_m, EV_CHKREQ, &l2->tei);\n\t\tif (test_bit(MGR_OPT_USER, &tm->mgr->options))\n\t\t\tmISDN_FsmEvent(&tm->tei_m, EV_VERIFY, NULL);\n\t\tbreak;\n\tcase MDL_STATUS_UP_IND:\n\t\tif (test_bit(MGR_OPT_NETWORK, &tm->mgr->options))\n\t\t\tmISDN_FsmEvent(&tm->mgr->deact, EV_ACTIVATE, NULL);\n\t\tbreak;\n\tcase MDL_STATUS_DOWN_IND:\n\t\tif (test_bit(MGR_OPT_NETWORK, &tm->mgr->options))\n\t\t\tmISDN_FsmEvent(&tm->mgr->deact, EV_DEACTIVATE, NULL);\n\t\tbreak;\n\tcase MDL_STATUS_UI_IND:\n\t\tif (test_bit(MGR_OPT_NETWORK, &tm->mgr->options))\n\t\t\tmISDN_FsmEvent(&tm->mgr->deact, EV_UI, NULL);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nvoid\nTEIrelease(struct layer2 *l2)\n{\n\tstruct teimgr\t*tm = l2->tm;\n\tu_long\t\tflags;\n\n\tmISDN_FsmDelTimer(&tm->timer, 1);\n\twrite_lock_irqsave(&tm->mgr->lock, flags);\n\tlist_del(&l2->list);\n\twrite_unlock_irqrestore(&tm->mgr->lock, flags);\n\tl2->tm = NULL;\n\tkfree(tm);\n}\n\nstatic int\ncreate_teimgr(struct manager *mgr, struct channel_req *crq)\n{\n\tstruct layer2\t\t*l2;\n\tunsigned long\t\topt = 0;\n\tunsigned long\t\tflags;\n\tint\t\t\tid;\n\tstruct channel_req\tl1rq;\n\n\tif (*debug & DEBUG_L2_TEI)\n\t\tprintk(KERN_DEBUG \"%s: %s proto(%x) adr(%d %d %d %d)\\n\",\n\t\t       __func__, dev_name(&mgr->ch.st->dev->dev),\n\t\t       crq->protocol, crq->adr.dev, crq->adr.channel,\n\t\t       crq->adr.sapi, crq->adr.tei);\n\tif (crq->adr.tei > GROUP_TEI)\n\t\treturn -EINVAL;\n\tif (crq->adr.tei < 64)\n\t\ttest_and_set_bit(OPTION_L2_FIXEDTEI, &opt);\n\tif (crq->adr.tei == 0)\n\t\ttest_and_set_bit(OPTION_L2_PTP, &opt);\n\tif (test_bit(MGR_OPT_NETWORK, &mgr->options)) {\n\t\tif (crq->protocol == ISDN_P_LAPD_TE)\n\t\t\treturn -EPROTONOSUPPORT;\n\t\tif ((crq->adr.tei != 0) && (crq->adr.tei != 127))\n\t\t\treturn -EINVAL;\n\t\tif (mgr->up) {\n\t\t\tprintk(KERN_WARNING\n\t\t\t       \"%s: only one network manager is allowed\\n\",\n\t\t\t       __func__);\n\t\t\treturn -EBUSY;\n\t\t}\n\t} else if (test_bit(MGR_OPT_USER, &mgr->options)) {\n\t\tif (crq->protocol == ISDN_P_LAPD_NT)\n\t\t\treturn -EPROTONOSUPPORT;\n\t\tif ((crq->adr.tei >= 64) && (crq->adr.tei < GROUP_TEI))\n\t\t\treturn -EINVAL;  \n\t} else {\n\t\tif (crq->protocol == ISDN_P_LAPD_NT)\n\t\t\ttest_and_set_bit(MGR_OPT_NETWORK, &mgr->options);\n\t\tif (crq->protocol == ISDN_P_LAPD_TE)\n\t\t\ttest_and_set_bit(MGR_OPT_USER, &mgr->options);\n\t}\n\tl1rq.adr = crq->adr;\n\tif (mgr->ch.st->dev->Dprotocols\n\t    & ((1 << ISDN_P_TE_E1) | (1 << ISDN_P_NT_E1)))\n\t\ttest_and_set_bit(OPTION_L2_PMX, &opt);\n\tif ((crq->protocol == ISDN_P_LAPD_NT) && (crq->adr.tei == 127)) {\n\t\tmgr->up = crq->ch;\n\t\tid = DL_INFO_L2_CONNECT;\n\t\tteiup_create(mgr, DL_INFORMATION_IND, sizeof(id), &id);\n\t\tif (test_bit(MGR_PH_ACTIVE, &mgr->options))\n\t\t\tteiup_create(mgr, PH_ACTIVATE_IND, 0, NULL);\n\t\tcrq->ch = NULL;\n\t\tif (!list_empty(&mgr->layer2)) {\n\t\t\tread_lock_irqsave(&mgr->lock, flags);\n\t\t\tlist_for_each_entry(l2, &mgr->layer2, list) {\n\t\t\t\tl2->up = mgr->up;\n\t\t\t\tl2->ch.ctrl(&l2->ch, OPEN_CHANNEL, NULL);\n\t\t\t}\n\t\t\tread_unlock_irqrestore(&mgr->lock, flags);\n\t\t}\n\t\treturn 0;\n\t}\n\tl2 = create_l2(crq->ch, crq->protocol, opt,\n\t\t       crq->adr.tei, crq->adr.sapi);\n\tif (!l2)\n\t\treturn -ENOMEM;\n\tl2->tm = kzalloc(sizeof(struct teimgr), GFP_KERNEL);\n\tif (!l2->tm) {\n\t\tkfree(l2);\n\t\tprintk(KERN_ERR \"kmalloc teimgr failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tl2->tm->mgr = mgr;\n\tl2->tm->l2 = l2;\n\tl2->tm->tei_m.debug = *debug & DEBUG_L2_TEIFSM;\n\tl2->tm->tei_m.userdata = l2->tm;\n\tl2->tm->tei_m.printdebug = tei_debug;\n\tif (crq->protocol == ISDN_P_LAPD_TE) {\n\t\tl2->tm->tei_m.fsm = &teifsmu;\n\t\tl2->tm->tei_m.state = ST_TEI_NOP;\n\t\tl2->tm->tval = 1000;  \n\t\tif (test_bit(OPTION_L2_PMX, &opt))\n\t\t\tl1rq.protocol = ISDN_P_TE_E1;\n\t\telse\n\t\t\tl1rq.protocol = ISDN_P_TE_S0;\n\t} else {\n\t\tl2->tm->tei_m.fsm = &teifsmn;\n\t\tl2->tm->tei_m.state = ST_TEI_NOP;\n\t\tl2->tm->tval = 2000;  \n\t\tif (test_bit(OPTION_L2_PMX, &opt))\n\t\t\tl1rq.protocol = ISDN_P_NT_E1;\n\t\telse\n\t\t\tl1rq.protocol = ISDN_P_NT_S0;\n\t}\n\tmISDN_FsmInitTimer(&l2->tm->tei_m, &l2->tm->timer);\n\twrite_lock_irqsave(&mgr->lock, flags);\n\tid = get_free_id(mgr);\n\tlist_add_tail(&l2->list, &mgr->layer2);\n\twrite_unlock_irqrestore(&mgr->lock, flags);\n\tif (id >= 0) {\n\t\tl2->ch.nr = id;\n\t\tl2->up->nr = id;\n\t\tcrq->ch = &l2->ch;\n\t\t \n\t\tid = mgr->ch.st->own.ctrl(&mgr->ch.st->own, OPEN_CHANNEL,\n\t\t\t\t\t  &l1rq);\n\t}\n\tif (id < 0)\n\t\tl2->ch.ctrl(&l2->ch, CLOSE_CHANNEL, NULL);\n\treturn id;\n}\n\nstatic int\nmgr_send(struct mISDNchannel *ch, struct sk_buff *skb)\n{\n\tstruct manager\t*mgr;\n\tstruct mISDNhead\t*hh =  mISDN_HEAD_P(skb);\n\tint\t\t\tret = -EINVAL;\n\n\tmgr = container_of(ch, struct manager, ch);\n\tif (*debug & DEBUG_L2_RECV)\n\t\tprintk(KERN_DEBUG \"%s: prim(%x) id(%x)\\n\",\n\t\t       __func__, hh->prim, hh->id);\n\tswitch (hh->prim) {\n\tcase PH_DATA_IND:\n\t\tmISDN_FsmEvent(&mgr->deact, EV_UI, NULL);\n\t\tret = ph_data_ind(mgr, skb);\n\t\tbreak;\n\tcase PH_DATA_CNF:\n\t\tdo_ack(mgr, hh->id);\n\t\tret = 0;\n\t\tbreak;\n\tcase PH_ACTIVATE_IND:\n\t\ttest_and_set_bit(MGR_PH_ACTIVE, &mgr->options);\n\t\tif (mgr->up)\n\t\t\tteiup_create(mgr, PH_ACTIVATE_IND, 0, NULL);\n\t\tmISDN_FsmEvent(&mgr->deact, EV_ACTIVATE_IND, NULL);\n\t\tdo_send(mgr);\n\t\tret = 0;\n\t\tbreak;\n\tcase PH_DEACTIVATE_IND:\n\t\ttest_and_clear_bit(MGR_PH_ACTIVE, &mgr->options);\n\t\tif (mgr->up)\n\t\t\tteiup_create(mgr, PH_DEACTIVATE_IND, 0, NULL);\n\t\tmISDN_FsmEvent(&mgr->deact, EV_DEACTIVATE_IND, NULL);\n\t\tret = 0;\n\t\tbreak;\n\tcase DL_UNITDATA_REQ:\n\t\treturn dl_unit_data(mgr, skb);\n\t}\n\tif (!ret)\n\t\tdev_kfree_skb(skb);\n\treturn ret;\n}\n\nstatic int\nfree_teimanager(struct manager *mgr)\n{\n\tstruct layer2\t*l2, *nl2;\n\n\ttest_and_clear_bit(OPTION_L1_HOLD, &mgr->options);\n\tif (test_bit(MGR_OPT_NETWORK, &mgr->options)) {\n\t\t \n\t\tmgr->up = NULL;\n\t\tif (test_bit(OPTION_L2_CLEANUP, &mgr->options)) {\n\t\t\tlist_for_each_entry_safe(l2, nl2, &mgr->layer2, list) {\n\t\t\t\tput_tei_msg(mgr, ID_REMOVE, 0, l2->tei);\n\t\t\t\tmutex_lock(&mgr->ch.st->lmutex);\n\t\t\t\tlist_del(&l2->ch.list);\n\t\t\t\tmutex_unlock(&mgr->ch.st->lmutex);\n\t\t\t\tl2->ch.ctrl(&l2->ch, CLOSE_CHANNEL, NULL);\n\t\t\t}\n\t\t\ttest_and_clear_bit(MGR_OPT_NETWORK, &mgr->options);\n\t\t} else {\n\t\t\tlist_for_each_entry_safe(l2, nl2, &mgr->layer2, list) {\n\t\t\t\tl2->up = NULL;\n\t\t\t}\n\t\t}\n\t}\n\tif (test_bit(MGR_OPT_USER, &mgr->options)) {\n\t\tif (list_empty(&mgr->layer2))\n\t\t\ttest_and_clear_bit(MGR_OPT_USER, &mgr->options);\n\t}\n\tmgr->ch.st->dev->D.ctrl(&mgr->ch.st->dev->D, CLOSE_CHANNEL, NULL);\n\treturn 0;\n}\n\nstatic int\nctrl_teimanager(struct manager *mgr, void *arg)\n{\n\t \n\tunsigned int *val = (unsigned int *)arg;\n\n\tswitch (val[0]) {\n\tcase IMCLEAR_L2:\n\t\tif (val[1])\n\t\t\ttest_and_set_bit(OPTION_L2_CLEANUP, &mgr->options);\n\t\telse\n\t\t\ttest_and_clear_bit(OPTION_L2_CLEANUP, &mgr->options);\n\t\tbreak;\n\tcase IMHOLD_L1:\n\t\tif (val[1])\n\t\t\ttest_and_set_bit(OPTION_L1_HOLD, &mgr->options);\n\t\telse\n\t\t\ttest_and_clear_bit(OPTION_L1_HOLD, &mgr->options);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n \nstatic int\ncheck_data(struct manager *mgr, struct sk_buff *skb)\n{\n\tstruct mISDNhead\t*hh =  mISDN_HEAD_P(skb);\n\tint\t\t\tret, tei, sapi;\n\tstruct layer2\t\t*l2;\n\n\tif (*debug & DEBUG_L2_CTRL)\n\t\tprintk(KERN_DEBUG \"%s: prim(%x) id(%x)\\n\",\n\t\t       __func__, hh->prim, hh->id);\n\tif (test_bit(MGR_OPT_USER, &mgr->options))\n\t\treturn -ENOTCONN;\n\tif (hh->prim != PH_DATA_IND)\n\t\treturn -ENOTCONN;\n\tif (skb->len != 3)\n\t\treturn -ENOTCONN;\n\tif (skb->data[0] & 3)  \n\t\treturn -EINVAL;\n\tsapi = skb->data[0] >> 2;\n\tif (!(skb->data[1] & 1))  \n\t\treturn -EINVAL;\n\ttei = skb->data[1] >> 1;\n\tif (tei > 63)  \n\t\treturn -ENOTCONN;\n\tif ((skb->data[2] & ~0x10) != SABME)\n\t\treturn -ENOTCONN;\n\t \n\tif (*debug & DEBUG_L2_CTRL)\n\t\tprintk(KERN_DEBUG \"%s: SABME sapi(%d) tei(%d)\\n\",\n\t\t       __func__, sapi, tei);\n\tl2 = create_new_tei(mgr, tei, sapi);\n\tif (!l2) {\n\t\tif (*debug & DEBUG_L2_CTRL)\n\t\t\tprintk(KERN_DEBUG \"%s: failed to create new tei\\n\",\n\t\t\t       __func__);\n\t\treturn -ENOMEM;\n\t}\n\tret = l2->ch.send(&l2->ch, skb);\n\treturn ret;\n}\n\nvoid\ndelete_teimanager(struct mISDNchannel *ch)\n{\n\tstruct manager\t*mgr;\n\tstruct layer2\t*l2, *nl2;\n\n\tmgr = container_of(ch, struct manager, ch);\n\t \n\tlist_for_each_entry_safe(l2, nl2, &mgr->layer2, list) {\n\t\tmutex_lock(&mgr->ch.st->lmutex);\n\t\tlist_del(&l2->ch.list);\n\t\tmutex_unlock(&mgr->ch.st->lmutex);\n\t\tl2->ch.ctrl(&l2->ch, CLOSE_CHANNEL, NULL);\n\t}\n\tlist_del(&mgr->ch.list);\n\tlist_del(&mgr->bcast.list);\n\tskb_queue_purge(&mgr->sendq);\n\tkfree(mgr);\n}\n\nstatic int\nmgr_ctrl(struct mISDNchannel *ch, u_int cmd, void *arg)\n{\n\tstruct manager\t*mgr;\n\tint\t\tret = -EINVAL;\n\n\tmgr = container_of(ch, struct manager, ch);\n\tif (*debug & DEBUG_L2_CTRL)\n\t\tprintk(KERN_DEBUG \"%s(%x, %p)\\n\", __func__, cmd, arg);\n\tswitch (cmd) {\n\tcase OPEN_CHANNEL:\n\t\tret = create_teimgr(mgr, arg);\n\t\tbreak;\n\tcase CLOSE_CHANNEL:\n\t\tret = free_teimanager(mgr);\n\t\tbreak;\n\tcase CONTROL_CHANNEL:\n\t\tret = ctrl_teimanager(mgr, arg);\n\t\tbreak;\n\tcase CHECK_DATA:\n\t\tret = check_data(mgr, arg);\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic int\nmgr_bcast(struct mISDNchannel *ch, struct sk_buff *skb)\n{\n\tstruct manager\t\t*mgr = container_of(ch, struct manager, bcast);\n\tstruct mISDNhead\t*hhc, *hh = mISDN_HEAD_P(skb);\n\tstruct sk_buff\t\t*cskb = NULL;\n\tstruct layer2\t\t*l2;\n\tu_long\t\t\tflags;\n\tint\t\t\tret;\n\n\tread_lock_irqsave(&mgr->lock, flags);\n\tlist_for_each_entry(l2, &mgr->layer2, list) {\n\t\tif ((hh->id & MISDN_ID_SAPI_MASK) ==\n\t\t    (l2->ch.addr & MISDN_ID_SAPI_MASK)) {\n\t\t\tif (list_is_last(&l2->list, &mgr->layer2)) {\n\t\t\t\tcskb = skb;\n\t\t\t\tskb = NULL;\n\t\t\t} else {\n\t\t\t\tif (!cskb)\n\t\t\t\t\tcskb = skb_copy(skb, GFP_ATOMIC);\n\t\t\t}\n\t\t\tif (cskb) {\n\t\t\t\thhc = mISDN_HEAD_P(cskb);\n\t\t\t\t \n\t\t\t\thhc++;\n\t\t\t\t*hhc = *hh;\n\t\t\t\thhc--;\n\t\t\t\thhc->prim = DL_INTERN_MSG;\n\t\t\t\thhc->id = l2->ch.nr;\n\t\t\t\tret = ch->st->own.recv(&ch->st->own, cskb);\n\t\t\t\tif (ret) {\n\t\t\t\t\tif (*debug & DEBUG_SEND_ERR)\n\t\t\t\t\t\tprintk(KERN_DEBUG\n\t\t\t\t\t\t       \"%s ch%d prim(%x) addr(%x)\"\n\t\t\t\t\t\t       \" err %d\\n\",\n\t\t\t\t\t\t       __func__, l2->ch.nr,\n\t\t\t\t\t\t       hh->prim, l2->ch.addr, ret);\n\t\t\t\t} else\n\t\t\t\t\tcskb = NULL;\n\t\t\t} else {\n\t\t\t\tprintk(KERN_WARNING \"%s ch%d addr %x no mem\\n\",\n\t\t\t\t       __func__, ch->nr, ch->addr);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\nout:\n\tread_unlock_irqrestore(&mgr->lock, flags);\n\tdev_kfree_skb(cskb);\n\tdev_kfree_skb(skb);\n\treturn 0;\n}\n\nstatic int\nmgr_bcast_ctrl(struct mISDNchannel *ch, u_int cmd, void *arg)\n{\n\n\treturn -EINVAL;\n}\n\nint\ncreate_teimanager(struct mISDNdevice *dev)\n{\n\tstruct manager *mgr;\n\n\tmgr = kzalloc(sizeof(struct manager), GFP_KERNEL);\n\tif (!mgr)\n\t\treturn -ENOMEM;\n\tINIT_LIST_HEAD(&mgr->layer2);\n\trwlock_init(&mgr->lock);\n\tskb_queue_head_init(&mgr->sendq);\n\tmgr->nextid = 1;\n\tmgr->lastid = MISDN_ID_NONE;\n\tmgr->ch.send = mgr_send;\n\tmgr->ch.ctrl = mgr_ctrl;\n\tmgr->ch.st = dev->D.st;\n\tset_channel_address(&mgr->ch, TEI_SAPI, GROUP_TEI);\n\tadd_layer2(&mgr->ch, dev->D.st);\n\tmgr->bcast.send = mgr_bcast;\n\tmgr->bcast.ctrl = mgr_bcast_ctrl;\n\tmgr->bcast.st = dev->D.st;\n\tset_channel_address(&mgr->bcast, 0, GROUP_TEI);\n\tadd_layer2(&mgr->bcast, dev->D.st);\n\tmgr->deact.debug = *debug & DEBUG_MANAGER;\n\tmgr->deact.userdata = mgr;\n\tmgr->deact.printdebug = da_debug;\n\tmgr->deact.fsm = &deactfsm;\n\tmgr->deact.state = ST_L1_DEACT;\n\tmISDN_FsmInitTimer(&mgr->deact, &mgr->datimer);\n\tdev->teimgr = &mgr->ch;\n\treturn 0;\n}\n\nint TEIInit(u_int *deb)\n{\n\tint res;\n\tdebug = deb;\n\tteifsmu.state_count = TEI_STATE_COUNT;\n\tteifsmu.event_count = TEI_EVENT_COUNT;\n\tteifsmu.strEvent = strTeiEvent;\n\tteifsmu.strState = strTeiState;\n\tres = mISDN_FsmNew(&teifsmu, TeiFnListUser, ARRAY_SIZE(TeiFnListUser));\n\tif (res)\n\t\tgoto error;\n\tteifsmn.state_count = TEI_STATE_COUNT;\n\tteifsmn.event_count = TEI_EVENT_COUNT;\n\tteifsmn.strEvent = strTeiEvent;\n\tteifsmn.strState = strTeiState;\n\tres = mISDN_FsmNew(&teifsmn, TeiFnListNet, ARRAY_SIZE(TeiFnListNet));\n\tif (res)\n\t\tgoto error_smn;\n\tdeactfsm.state_count =  DEACT_STATE_COUNT;\n\tdeactfsm.event_count = DEACT_EVENT_COUNT;\n\tdeactfsm.strEvent = strDeactEvent;\n\tdeactfsm.strState = strDeactState;\n\tres = mISDN_FsmNew(&deactfsm, DeactFnList, ARRAY_SIZE(DeactFnList));\n\tif (res)\n\t\tgoto error_deact;\n\treturn 0;\n\nerror_deact:\n\tmISDN_FsmFree(&teifsmn);\nerror_smn:\n\tmISDN_FsmFree(&teifsmu);\nerror:\n\treturn res;\n}\n\nvoid TEIFree(void)\n{\n\tmISDN_FsmFree(&teifsmu);\n\tmISDN_FsmFree(&teifsmn);\n\tmISDN_FsmFree(&deactfsm);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}