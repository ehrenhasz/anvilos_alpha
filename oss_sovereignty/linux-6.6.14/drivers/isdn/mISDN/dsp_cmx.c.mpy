{
  "module_name": "dsp_cmx.c",
  "hash_id": "e8f3ee0f0e5f6edf8e87d9a5133bac245c75bf3a0c52d9dd58dc926b3e80fe41",
  "original_prompt": "Ingested from linux-6.6.14/drivers/isdn/mISDN/dsp_cmx.c",
  "human_readable_source": " \n\n \n\n \n\n \n\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/mISDNif.h>\n#include <linux/mISDNdsp.h>\n#include \"core.h\"\n#include \"dsp.h\"\n \n\n \n\n \n \n \n\n \nvoid\ndsp_cmx_debug(struct dsp *dsp)\n{\n\tstruct dsp_conf\t*conf;\n\tstruct dsp_conf_member\t*member;\n\tstruct dsp\t\t*odsp;\n\n\tprintk(KERN_DEBUG \"-----Current DSP\\n\");\n\tlist_for_each_entry(odsp, &dsp_ilist, list) {\n\t\tprintk(KERN_DEBUG \"* %s hardecho=%d softecho=%d txmix=%d\",\n\t\t       odsp->name, odsp->echo.hardware, odsp->echo.software,\n\t\t       odsp->tx_mix);\n\t\tif (odsp->conf)\n\t\t\tprintk(\" (Conf %d)\", odsp->conf->id);\n\t\tif (dsp == odsp)\n\t\t\tprintk(\" *this*\");\n\t\tprintk(\"\\n\");\n\t}\n\tprintk(KERN_DEBUG \"-----Current Conf:\\n\");\n\tlist_for_each_entry(conf, &conf_ilist, list) {\n\t\tprintk(KERN_DEBUG \"* Conf %d (%p)\\n\", conf->id, conf);\n\t\tlist_for_each_entry(member, &conf->mlist, list) {\n\t\t\tprintk(KERN_DEBUG\n\t\t\t       \"  - member = %s (slot_tx %d, bank_tx %d, \"\n\t\t\t       \"slot_rx %d, bank_rx %d hfc_conf %d \"\n\t\t\t       \"tx_data %d rx_is_off %d)%s\\n\",\n\t\t\t       member->dsp->name, member->dsp->pcm_slot_tx,\n\t\t\t       member->dsp->pcm_bank_tx, member->dsp->pcm_slot_rx,\n\t\t\t       member->dsp->pcm_bank_rx, member->dsp->hfc_conf,\n\t\t\t       member->dsp->tx_data, member->dsp->rx_is_off,\n\t\t\t       (member->dsp == dsp) ? \" *this*\" : \"\");\n\t\t}\n\t}\n\tprintk(KERN_DEBUG \"-----end\\n\");\n}\n\n \nstatic struct dsp_conf *\ndsp_cmx_search_conf(u32 id)\n{\n\tstruct dsp_conf *conf;\n\n\tif (!id) {\n\t\tprintk(KERN_WARNING \"%s: conference ID is 0.\\n\", __func__);\n\t\treturn NULL;\n\t}\n\n\t \n\tlist_for_each_entry(conf, &conf_ilist, list)\n\t\tif (conf->id == id)\n\t\t\treturn conf;\n\n\treturn NULL;\n}\n\n\n \nstatic int\ndsp_cmx_add_conf_member(struct dsp *dsp, struct dsp_conf *conf)\n{\n\tstruct dsp_conf_member *member;\n\n\tif (!conf || !dsp) {\n\t\tprintk(KERN_WARNING \"%s: conf or dsp is 0.\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\tif (dsp->member) {\n\t\tprintk(KERN_WARNING \"%s: dsp is already member in a conf.\\n\",\n\t\t       __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tif (dsp->conf) {\n\t\tprintk(KERN_WARNING \"%s: dsp is already in a conf.\\n\",\n\t\t       __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tmember = kzalloc(sizeof(struct dsp_conf_member), GFP_ATOMIC);\n\tif (!member) {\n\t\tprintk(KERN_ERR \"kzalloc struct dsp_conf_member failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tmember->dsp = dsp;\n\t \n\tmemset(dsp->rx_buff, dsp_silence, sizeof(dsp->rx_buff));\n\tdsp->rx_init = 1;  \n\tdsp->rx_W = 0;\n\tdsp->rx_R = 0;\n\n\tlist_add_tail(&member->list, &conf->mlist);\n\n\tdsp->conf = conf;\n\tdsp->member = member;\n\n\treturn 0;\n}\n\n\n \nint\ndsp_cmx_del_conf_member(struct dsp *dsp)\n{\n\tstruct dsp_conf_member *member;\n\n\tif (!dsp) {\n\t\tprintk(KERN_WARNING \"%s: dsp is 0.\\n\",\n\t\t       __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!dsp->conf) {\n\t\tprintk(KERN_WARNING \"%s: dsp is not in a conf.\\n\",\n\t\t       __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tif (list_empty(&dsp->conf->mlist)) {\n\t\tprintk(KERN_WARNING \"%s: dsp has linked an empty conf.\\n\",\n\t\t       __func__);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tlist_for_each_entry(member, &dsp->conf->mlist, list) {\n\t\tif (member->dsp == dsp) {\n\t\t\tlist_del(&member->list);\n\t\t\tdsp->conf = NULL;\n\t\t\tdsp->member = NULL;\n\t\t\tkfree(member);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tprintk(KERN_WARNING\n\t       \"%s: dsp is not present in its own conf_member list.\\n\",\n\t       __func__);\n\n\treturn -EINVAL;\n}\n\n\n \nstatic struct dsp_conf\n*dsp_cmx_new_conf(u32 id)\n{\n\tstruct dsp_conf *conf;\n\n\tif (!id) {\n\t\tprintk(KERN_WARNING \"%s: id is 0.\\n\",\n\t\t       __func__);\n\t\treturn NULL;\n\t}\n\n\tconf = kzalloc(sizeof(struct dsp_conf), GFP_ATOMIC);\n\tif (!conf) {\n\t\tprintk(KERN_ERR \"kzalloc struct dsp_conf failed\\n\");\n\t\treturn NULL;\n\t}\n\tINIT_LIST_HEAD(&conf->mlist);\n\tconf->id = id;\n\n\tlist_add_tail(&conf->list, &conf_ilist);\n\n\treturn conf;\n}\n\n\n \nint\ndsp_cmx_del_conf(struct dsp_conf *conf)\n{\n\tif (!conf) {\n\t\tprintk(KERN_WARNING \"%s: conf is null.\\n\",\n\t\t       __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!list_empty(&conf->mlist)) {\n\t\tprintk(KERN_WARNING \"%s: conf not empty.\\n\",\n\t\t       __func__);\n\t\treturn -EINVAL;\n\t}\n\tlist_del(&conf->list);\n\tkfree(conf);\n\n\treturn 0;\n}\n\n\n \nstatic void\ndsp_cmx_hw_message(struct dsp *dsp, u32 message, u32 param1, u32 param2,\n\t\t   u32 param3, u32 param4)\n{\n\tstruct mISDN_ctrl_req cq;\n\n\tmemset(&cq, 0, sizeof(cq));\n\tcq.op = message;\n\tcq.p1 = param1 | (param2 << 8);\n\tcq.p2 = param3 | (param4 << 8);\n\tif (dsp->ch.peer)\n\t\tdsp->ch.peer->ctrl(dsp->ch.peer, CONTROL_CHANNEL, &cq);\n}\n\n\n \nvoid\ndsp_cmx_hardware(struct dsp_conf *conf, struct dsp *dsp)\n{\n\tstruct dsp_conf_member\t*member, *nextm;\n\tstruct dsp\t\t*finddsp;\n\tint\t\tmemb = 0, i, ii, i1, i2;\n\tint\t\tfreeunits[8];\n\tu_char\t\tfreeslots[256];\n\tint\t\tsame_hfc = -1, same_pcm = -1, current_conf = -1,\n\t\tall_conf = 1, tx_data = 0;\n\n\t \n\tif (!conf) {\n\t\tif (!dsp)\n\t\t\treturn;\n\t\tif (dsp_debug & DEBUG_DSP_CMX)\n\t\t\tprintk(KERN_DEBUG \"%s checking dsp %s\\n\",\n\t\t\t       __func__, dsp->name);\n\tone_member:\n\t\t \n\t\tif (dsp->hfc_conf >= 0) {\n\t\t\tif (dsp_debug & DEBUG_DSP_CMX)\n\t\t\t\tprintk(KERN_DEBUG\n\t\t\t\t       \"%s removing %s from HFC conf %d \"\n\t\t\t\t       \"because dsp is split\\n\", __func__,\n\t\t\t\t       dsp->name, dsp->hfc_conf);\n\t\t\tdsp_cmx_hw_message(dsp, MISDN_CTRL_HFC_CONF_SPLIT,\n\t\t\t\t\t   0, 0, 0, 0);\n\t\t\tdsp->hfc_conf = -1;\n\t\t}\n\t\t \n\t\tif (dsp->features.pcm_banks < 1)\n\t\t\treturn;\n\t\tif (!dsp->echo.software && !dsp->echo.hardware) {\n\t\t\t \n\t\t\tif (dsp->pcm_slot_tx >= 0 || dsp->pcm_slot_rx >= 0) {\n\t\t\t\tif (dsp_debug & DEBUG_DSP_CMX)\n\t\t\t\t\tprintk(KERN_DEBUG \"%s removing %s from\"\n\t\t\t\t\t       \" PCM slot %d (TX) %d (RX) because\"\n\t\t\t\t\t       \" dsp is split (no echo)\\n\",\n\t\t\t\t\t       __func__, dsp->name,\n\t\t\t\t\t       dsp->pcm_slot_tx, dsp->pcm_slot_rx);\n\t\t\t\tdsp_cmx_hw_message(dsp, MISDN_CTRL_HFC_PCM_DISC,\n\t\t\t\t\t\t   0, 0, 0, 0);\n\t\t\t\tdsp->pcm_slot_tx = -1;\n\t\t\t\tdsp->pcm_bank_tx = -1;\n\t\t\t\tdsp->pcm_slot_rx = -1;\n\t\t\t\tdsp->pcm_bank_rx = -1;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\t \n\t\tdsp->echo.software = dsp->tx_data;\n\t\tdsp->echo.hardware = 0;\n\t\t \n\t\tif (dsp->pcm_slot_tx >= 0 && dsp->pcm_slot_rx < 0 &&\n\t\t    dsp->pcm_bank_tx == 2 && dsp->pcm_bank_rx == 2) {\n\t\t\tdsp->echo.hardware = 1;\n\t\t\treturn;\n\t\t}\n\t\t \n\t\tif (dsp->pcm_slot_tx >= 0) {\n\t\t\tdsp->pcm_slot_rx = dsp->pcm_slot_tx;\n\t\t\tdsp->pcm_bank_tx = 2;  \n\t\t\tdsp->pcm_bank_rx = 2;\n\t\t\tif (dsp_debug & DEBUG_DSP_CMX)\n\t\t\t\tprintk(KERN_DEBUG\n\t\t\t\t       \"%s refresh %s for echo using slot %d\\n\",\n\t\t\t\t       __func__, dsp->name,\n\t\t\t\t       dsp->pcm_slot_tx);\n\t\t\tdsp_cmx_hw_message(dsp, MISDN_CTRL_HFC_PCM_CONN,\n\t\t\t\t\t   dsp->pcm_slot_tx, 2, dsp->pcm_slot_rx, 2);\n\t\t\tdsp->echo.hardware = 1;\n\t\t\treturn;\n\t\t}\n\t\t \n\t\tdsp->pcm_slot_tx = -1;\n\t\tdsp->pcm_slot_rx = -1;\n\t\tmemset(freeslots, 1, sizeof(freeslots));\n\t\tlist_for_each_entry(finddsp, &dsp_ilist, list) {\n\t\t\tif (finddsp->features.pcm_id == dsp->features.pcm_id) {\n\t\t\t\tif (finddsp->pcm_slot_rx >= 0 &&\n\t\t\t\t    finddsp->pcm_slot_rx < sizeof(freeslots))\n\t\t\t\t\tfreeslots[finddsp->pcm_slot_rx] = 0;\n\t\t\t\tif (finddsp->pcm_slot_tx >= 0 &&\n\t\t\t\t    finddsp->pcm_slot_tx < sizeof(freeslots))\n\t\t\t\t\tfreeslots[finddsp->pcm_slot_tx] = 0;\n\t\t\t}\n\t\t}\n\t\ti = 0;\n\t\tii = dsp->features.pcm_slots;\n\t\twhile (i < ii) {\n\t\t\tif (freeslots[i])\n\t\t\t\tbreak;\n\t\t\ti++;\n\t\t}\n\t\tif (i == ii) {\n\t\t\tif (dsp_debug & DEBUG_DSP_CMX)\n\t\t\t\tprintk(KERN_DEBUG\n\t\t\t\t       \"%s no slot available for echo\\n\",\n\t\t\t\t       __func__);\n\t\t\t \n\t\t\tdsp->echo.software = 1;\n\t\t\treturn;\n\t\t}\n\t\t \n\t\tdsp->pcm_slot_tx = i;\n\t\tdsp->pcm_slot_rx = i;\n\t\tdsp->pcm_bank_tx = 2;  \n\t\tdsp->pcm_bank_rx = 2;\n\t\tif (dsp_debug & DEBUG_DSP_CMX)\n\t\t\tprintk(KERN_DEBUG\n\t\t\t       \"%s assign echo for %s using slot %d\\n\",\n\t\t\t       __func__, dsp->name, dsp->pcm_slot_tx);\n\t\tdsp_cmx_hw_message(dsp, MISDN_CTRL_HFC_PCM_CONN,\n\t\t\t\t   dsp->pcm_slot_tx, 2, dsp->pcm_slot_rx, 2);\n\t\tdsp->echo.hardware = 1;\n\t\treturn;\n\t}\n\n\t \n\tif (dsp_debug & DEBUG_DSP_CMX)\n\t\tprintk(KERN_DEBUG \"%s checking conference %d\\n\",\n\t\t       __func__, conf->id);\n\n\tif (list_empty(&conf->mlist)) {\n\t\tprintk(KERN_ERR \"%s: conference without members\\n\",\n\t\t       __func__);\n\t\treturn;\n\t}\n\tmember = list_entry(conf->mlist.next, struct dsp_conf_member, list);\n\tsame_hfc = member->dsp->features.hfc_id;\n\tsame_pcm = member->dsp->features.pcm_id;\n\t \n\tlist_for_each_entry(member, &conf->mlist, list) {\n\t\t \n\t\tif (member->dsp->tx_mix) {\n\t\t\tif (dsp_debug & DEBUG_DSP_CMX)\n\t\t\t\tprintk(KERN_DEBUG\n\t\t\t\t       \"%s dsp %s cannot form a conf, because \"\n\t\t\t\t       \"tx_mix is turned on\\n\", __func__,\n\t\t\t\t       member->dsp->name);\n\t\tconf_software:\n\t\t\tlist_for_each_entry(member, &conf->mlist, list) {\n\t\t\t\tdsp = member->dsp;\n\t\t\t\t \n\t\t\t\tif (dsp->hfc_conf >= 0) {\n\t\t\t\t\tif (dsp_debug & DEBUG_DSP_CMX)\n\t\t\t\t\t\tprintk(KERN_DEBUG\n\t\t\t\t\t\t       \"%s removing %s from HFC \"\n\t\t\t\t\t\t       \"conf %d because not \"\n\t\t\t\t\t\t       \"possible with hardware\\n\",\n\t\t\t\t\t\t       __func__,\n\t\t\t\t\t\t       dsp->name,\n\t\t\t\t\t\t       dsp->hfc_conf);\n\t\t\t\t\tdsp_cmx_hw_message(dsp,\n\t\t\t\t\t\t\t   MISDN_CTRL_HFC_CONF_SPLIT,\n\t\t\t\t\t\t\t   0, 0, 0, 0);\n\t\t\t\t\tdsp->hfc_conf = -1;\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\tif (dsp->pcm_slot_tx >= 0 ||\n\t\t\t\t    dsp->pcm_slot_rx >= 0) {\n\t\t\t\t\tif (dsp_debug & DEBUG_DSP_CMX)\n\t\t\t\t\t\tprintk(KERN_DEBUG \"%s removing \"\n\t\t\t\t\t\t       \"%s from PCM slot %d (TX)\"\n\t\t\t\t\t\t       \" slot %d (RX) because not\"\n\t\t\t\t\t\t       \" possible with hardware\\n\",\n\t\t\t\t\t\t       __func__,\n\t\t\t\t\t\t       dsp->name,\n\t\t\t\t\t\t       dsp->pcm_slot_tx,\n\t\t\t\t\t\t       dsp->pcm_slot_rx);\n\t\t\t\t\tdsp_cmx_hw_message(dsp,\n\t\t\t\t\t\t\t   MISDN_CTRL_HFC_PCM_DISC,\n\t\t\t\t\t\t\t   0, 0, 0, 0);\n\t\t\t\t\tdsp->pcm_slot_tx = -1;\n\t\t\t\t\tdsp->pcm_bank_tx = -1;\n\t\t\t\t\tdsp->pcm_slot_rx = -1;\n\t\t\t\t\tdsp->pcm_bank_rx = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tconf->hardware = 0;\n\t\t\tconf->software = 1;\n\t\t\treturn;\n\t\t}\n\t\t \n\t\tif (member->dsp->echo.hardware || member->dsp->echo.software) {\n\t\t\tif (dsp_debug & DEBUG_DSP_CMX)\n\t\t\t\tprintk(KERN_DEBUG\n\t\t\t\t       \"%s dsp %s cannot form a conf, because \"\n\t\t\t\t       \"echo is turned on\\n\", __func__,\n\t\t\t\t       member->dsp->name);\n\t\t\tgoto conf_software;\n\t\t}\n\t\t \n\t\tif (member->dsp->tx_mix) {\n\t\t\tif (dsp_debug & DEBUG_DSP_CMX)\n\t\t\t\tprintk(KERN_DEBUG\n\t\t\t\t       \"%s dsp %s cannot form a conf, because \"\n\t\t\t\t       \"tx_mix is turned on\\n\",\n\t\t\t\t       __func__, member->dsp->name);\n\t\t\tgoto conf_software;\n\t\t}\n\t\t \n\t\tif (member->dsp->tx_volume) {\n\t\t\tif (dsp_debug & DEBUG_DSP_CMX)\n\t\t\t\tprintk(KERN_DEBUG\n\t\t\t\t       \"%s dsp %s cannot form a conf, because \"\n\t\t\t\t       \"tx_volume is changed\\n\",\n\t\t\t\t       __func__, member->dsp->name);\n\t\t\tgoto conf_software;\n\t\t}\n\t\tif (member->dsp->rx_volume) {\n\t\t\tif (dsp_debug & DEBUG_DSP_CMX)\n\t\t\t\tprintk(KERN_DEBUG\n\t\t\t\t       \"%s dsp %s cannot form a conf, because \"\n\t\t\t\t       \"rx_volume is changed\\n\",\n\t\t\t\t       __func__, member->dsp->name);\n\t\t\tgoto conf_software;\n\t\t}\n\t\t \n\t\tif (member->dsp->tx_data) {\n\t\t\tif (dsp_debug & DEBUG_DSP_CMX)\n\t\t\t\tprintk(KERN_DEBUG\n\t\t\t\t       \"%s dsp %s tx_data is turned on\\n\",\n\t\t\t\t       __func__, member->dsp->name);\n\t\t\ttx_data = 1;\n\t\t}\n\t\t \n\t\tif (member->dsp->pipeline.inuse) {\n\t\t\tif (dsp_debug & DEBUG_DSP_CMX)\n\t\t\t\tprintk(KERN_DEBUG\n\t\t\t\t       \"%s dsp %s cannot form a conf, because \"\n\t\t\t\t       \"pipeline exists\\n\", __func__,\n\t\t\t\t       member->dsp->name);\n\t\t\tgoto conf_software;\n\t\t}\n\t\t \n\t\tif (member->dsp->bf_enable) {\n\t\t\tif (dsp_debug & DEBUG_DSP_CMX)\n\t\t\t\tprintk(KERN_DEBUG \"%s dsp %s cannot form a \"\n\t\t\t\t       \"conf, because encryption is enabled\\n\",\n\t\t\t\t       __func__, member->dsp->name);\n\t\t\tgoto conf_software;\n\t\t}\n\t\t \n\t\tif (member->dsp->features.pcm_id < 0) {\n\t\t\tif (dsp_debug & DEBUG_DSP_CMX)\n\t\t\t\tprintk(KERN_DEBUG\n\t\t\t\t       \"%s dsp %s cannot form a conf, because \"\n\t\t\t\t       \"dsp has no PCM bus\\n\",\n\t\t\t\t       __func__, member->dsp->name);\n\t\t\tgoto conf_software;\n\t\t}\n\t\t \n\t\tif (member->dsp->features.pcm_id != same_pcm) {\n\t\t\tif (dsp_debug & DEBUG_DSP_CMX)\n\t\t\t\tprintk(KERN_DEBUG\n\t\t\t\t       \"%s dsp %s cannot form a conf, because \"\n\t\t\t\t       \"dsp is on a different PCM bus than the \"\n\t\t\t\t       \"first dsp\\n\",\n\t\t\t\t       __func__, member->dsp->name);\n\t\t\tgoto conf_software;\n\t\t}\n\t\t \n\t\tif (same_hfc != member->dsp->features.hfc_id)\n\t\t\tsame_hfc = -1;\n\t\t \n\t\tif (current_conf < 0 && member->dsp->hfc_conf >= 0)\n\t\t\tcurrent_conf = member->dsp->hfc_conf;\n\t\t \n\t\tif (member->dsp->hfc_conf < 0)\n\t\t\tall_conf = 0;\n\n\t\tmemb++;\n\t}\n\n\t \n\tif (memb < 1)\n\t\treturn;\n\n\t \n\tif (memb == 1) {\n\t\tif (dsp_debug & DEBUG_DSP_CMX)\n\t\t\tprintk(KERN_DEBUG\n\t\t\t       \"%s conf %d cannot form a HW conference, \"\n\t\t\t       \"because dsp is alone\\n\", __func__, conf->id);\n\t\tconf->hardware = 0;\n\t\tconf->software = 0;\n\t\tmember = list_entry(conf->mlist.next, struct dsp_conf_member,\n\t\t\t\t    list);\n\t\tdsp = member->dsp;\n\t\tgoto one_member;\n\t}\n\n\t \n\n\t \n\tif (memb == 2) {\n\t\tmember = list_entry(conf->mlist.next, struct dsp_conf_member,\n\t\t\t\t    list);\n\t\tnextm = list_entry(member->list.next, struct dsp_conf_member,\n\t\t\t\t   list);\n\t\t \n\t\tif (member->dsp->hfc_conf >= 0) {\n\t\t\tif (dsp_debug & DEBUG_DSP_CMX)\n\t\t\t\tprintk(KERN_DEBUG\n\t\t\t\t       \"%s removing %s from HFC conf %d because \"\n\t\t\t\t       \"two parties require only a PCM slot\\n\",\n\t\t\t\t       __func__, member->dsp->name,\n\t\t\t\t       member->dsp->hfc_conf);\n\t\t\tdsp_cmx_hw_message(member->dsp,\n\t\t\t\t\t   MISDN_CTRL_HFC_CONF_SPLIT, 0, 0, 0, 0);\n\t\t\tmember->dsp->hfc_conf = -1;\n\t\t}\n\t\tif (nextm->dsp->hfc_conf >= 0) {\n\t\t\tif (dsp_debug & DEBUG_DSP_CMX)\n\t\t\t\tprintk(KERN_DEBUG\n\t\t\t\t       \"%s removing %s from HFC conf %d because \"\n\t\t\t\t       \"two parties require only a PCM slot\\n\",\n\t\t\t\t       __func__, nextm->dsp->name,\n\t\t\t\t       nextm->dsp->hfc_conf);\n\t\t\tdsp_cmx_hw_message(nextm->dsp,\n\t\t\t\t\t   MISDN_CTRL_HFC_CONF_SPLIT, 0, 0, 0, 0);\n\t\t\tnextm->dsp->hfc_conf = -1;\n\t\t}\n\t\t \n\t\tif (member->dsp->features.pcm_banks > 1 &&\n\t\t    nextm->dsp->features.pcm_banks > 1 &&\n\t\t    member->dsp->features.hfc_id !=\n\t\t    nextm->dsp->features.hfc_id) {\n\t\t\t \n\t\t\tif (member->dsp->pcm_slot_tx >= 0 &&\n\t\t\t    member->dsp->pcm_slot_rx >= 0 &&\n\t\t\t    nextm->dsp->pcm_slot_tx >= 0 &&\n\t\t\t    nextm->dsp->pcm_slot_rx >= 0 &&\n\t\t\t    nextm->dsp->pcm_slot_tx ==\n\t\t\t    member->dsp->pcm_slot_rx &&\n\t\t\t    nextm->dsp->pcm_slot_rx ==\n\t\t\t    member->dsp->pcm_slot_tx &&\n\t\t\t    nextm->dsp->pcm_slot_tx ==\n\t\t\t    member->dsp->pcm_slot_tx &&\n\t\t\t    member->dsp->pcm_bank_tx !=\n\t\t\t    member->dsp->pcm_bank_rx &&\n\t\t\t    nextm->dsp->pcm_bank_tx !=\n\t\t\t    nextm->dsp->pcm_bank_rx) {\n\t\t\t\t \n\t\t\t\tif (dsp_debug & DEBUG_DSP_CMX)\n\t\t\t\t\tprintk(KERN_DEBUG\n\t\t\t\t\t       \"%s dsp %s & %s stay joined on \"\n\t\t\t\t\t       \"PCM slot %d bank %d (TX) bank %d \"\n\t\t\t\t\t       \"(RX) (on different chips)\\n\",\n\t\t\t\t\t       __func__,\n\t\t\t\t\t       member->dsp->name,\n\t\t\t\t\t       nextm->dsp->name,\n\t\t\t\t\t       member->dsp->pcm_slot_tx,\n\t\t\t\t\t       member->dsp->pcm_bank_tx,\n\t\t\t\t\t       member->dsp->pcm_bank_rx);\n\t\t\t\tconf->hardware = 1;\n\t\t\t\tconf->software = tx_data;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t \n\t\t\tmemset(freeslots, 1, sizeof(freeslots));\n\t\t\tlist_for_each_entry(dsp, &dsp_ilist, list) {\n\t\t\t\tif (dsp != member->dsp &&\n\t\t\t\t    dsp != nextm->dsp &&\n\t\t\t\t    member->dsp->features.pcm_id ==\n\t\t\t\t    dsp->features.pcm_id) {\n\t\t\t\t\tif (dsp->pcm_slot_rx >= 0 &&\n\t\t\t\t\t    dsp->pcm_slot_rx <\n\t\t\t\t\t    sizeof(freeslots))\n\t\t\t\t\t\tfreeslots[dsp->pcm_slot_rx] = 0;\n\t\t\t\t\tif (dsp->pcm_slot_tx >= 0 &&\n\t\t\t\t\t    dsp->pcm_slot_tx <\n\t\t\t\t\t    sizeof(freeslots))\n\t\t\t\t\t\tfreeslots[dsp->pcm_slot_tx] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\ti = 0;\n\t\t\tii = member->dsp->features.pcm_slots;\n\t\t\twhile (i < ii) {\n\t\t\t\tif (freeslots[i])\n\t\t\t\t\tbreak;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tif (i == ii) {\n\t\t\t\tif (dsp_debug & DEBUG_DSP_CMX)\n\t\t\t\t\tprintk(KERN_DEBUG\n\t\t\t\t\t       \"%s no slot available for \"\n\t\t\t\t\t       \"%s & %s\\n\", __func__,\n\t\t\t\t\t       member->dsp->name,\n\t\t\t\t\t       nextm->dsp->name);\n\t\t\t\t \n\t\t\t\tgoto conf_software;\n\t\t\t}\n\t\t\t \n\t\t\tmember->dsp->pcm_slot_tx = i;\n\t\t\tmember->dsp->pcm_slot_rx = i;\n\t\t\tnextm->dsp->pcm_slot_tx = i;\n\t\t\tnextm->dsp->pcm_slot_rx = i;\n\t\t\tmember->dsp->pcm_bank_rx = 0;\n\t\t\tmember->dsp->pcm_bank_tx = 1;\n\t\t\tnextm->dsp->pcm_bank_rx = 1;\n\t\t\tnextm->dsp->pcm_bank_tx = 0;\n\t\t\tif (dsp_debug & DEBUG_DSP_CMX)\n\t\t\t\tprintk(KERN_DEBUG\n\t\t\t\t       \"%s adding %s & %s to new PCM slot %d \"\n\t\t\t\t       \"(TX and RX on different chips) because \"\n\t\t\t\t       \"both members have not same slots\\n\",\n\t\t\t\t       __func__,\n\t\t\t\t       member->dsp->name,\n\t\t\t\t       nextm->dsp->name,\n\t\t\t\t       member->dsp->pcm_slot_tx);\n\t\t\tdsp_cmx_hw_message(member->dsp, MISDN_CTRL_HFC_PCM_CONN,\n\t\t\t\t\t   member->dsp->pcm_slot_tx, member->dsp->pcm_bank_tx,\n\t\t\t\t\t   member->dsp->pcm_slot_rx, member->dsp->pcm_bank_rx);\n\t\t\tdsp_cmx_hw_message(nextm->dsp, MISDN_CTRL_HFC_PCM_CONN,\n\t\t\t\t\t   nextm->dsp->pcm_slot_tx, nextm->dsp->pcm_bank_tx,\n\t\t\t\t\t   nextm->dsp->pcm_slot_rx, nextm->dsp->pcm_bank_rx);\n\t\t\tconf->hardware = 1;\n\t\t\tconf->software = tx_data;\n\t\t\treturn;\n\t\t\t \n\t\t} else {\n\t\t\t \n\t\t\tif (member->dsp->pcm_slot_tx >= 0 &&\n\t\t\t    member->dsp->pcm_slot_rx >= 0 &&\n\t\t\t    nextm->dsp->pcm_slot_tx >= 0 &&\n\t\t\t    nextm->dsp->pcm_slot_rx >= 0 &&\n\t\t\t    nextm->dsp->pcm_slot_tx ==\n\t\t\t    member->dsp->pcm_slot_rx &&\n\t\t\t    nextm->dsp->pcm_slot_rx ==\n\t\t\t    member->dsp->pcm_slot_tx &&\n\t\t\t    member->dsp->pcm_slot_tx !=\n\t\t\t    member->dsp->pcm_slot_rx &&\n\t\t\t    member->dsp->pcm_bank_tx == 0 &&\n\t\t\t    member->dsp->pcm_bank_rx == 0 &&\n\t\t\t    nextm->dsp->pcm_bank_tx == 0 &&\n\t\t\t    nextm->dsp->pcm_bank_rx == 0) {\n\t\t\t\t \n\t\t\t\tif (dsp_debug & DEBUG_DSP_CMX)\n\t\t\t\t\tprintk(KERN_DEBUG\n\t\t\t\t\t       \"%s dsp %s & %s stay joined on PCM \"\n\t\t\t\t\t       \"slot %d (TX) %d (RX) on same chip \"\n\t\t\t\t\t       \"or one bank PCM)\\n\", __func__,\n\t\t\t\t\t       member->dsp->name,\n\t\t\t\t\t       nextm->dsp->name,\n\t\t\t\t\t       member->dsp->pcm_slot_tx,\n\t\t\t\t\t       member->dsp->pcm_slot_rx);\n\t\t\t\tconf->hardware = 1;\n\t\t\t\tconf->software = tx_data;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t \n\t\t\tmemset(freeslots, 1, sizeof(freeslots));\n\t\t\tlist_for_each_entry(dsp, &dsp_ilist, list) {\n\t\t\t\tif (dsp != member->dsp &&\n\t\t\t\t    dsp != nextm->dsp &&\n\t\t\t\t    member->dsp->features.pcm_id ==\n\t\t\t\t    dsp->features.pcm_id) {\n\t\t\t\t\tif (dsp->pcm_slot_rx >= 0 &&\n\t\t\t\t\t    dsp->pcm_slot_rx <\n\t\t\t\t\t    sizeof(freeslots))\n\t\t\t\t\t\tfreeslots[dsp->pcm_slot_rx] = 0;\n\t\t\t\t\tif (dsp->pcm_slot_tx >= 0 &&\n\t\t\t\t\t    dsp->pcm_slot_tx <\n\t\t\t\t\t    sizeof(freeslots))\n\t\t\t\t\t\tfreeslots[dsp->pcm_slot_tx] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\ti1 = 0;\n\t\t\tii = member->dsp->features.pcm_slots;\n\t\t\twhile (i1 < ii) {\n\t\t\t\tif (freeslots[i1])\n\t\t\t\t\tbreak;\n\t\t\t\ti1++;\n\t\t\t}\n\t\t\tif (i1 == ii) {\n\t\t\t\tif (dsp_debug & DEBUG_DSP_CMX)\n\t\t\t\t\tprintk(KERN_DEBUG\n\t\t\t\t\t       \"%s no slot available \"\n\t\t\t\t\t       \"for %s & %s\\n\", __func__,\n\t\t\t\t\t       member->dsp->name,\n\t\t\t\t\t       nextm->dsp->name);\n\t\t\t\t \n\t\t\t\tgoto conf_software;\n\t\t\t}\n\t\t\ti2 = i1 + 1;\n\t\t\twhile (i2 < ii) {\n\t\t\t\tif (freeslots[i2])\n\t\t\t\t\tbreak;\n\t\t\t\ti2++;\n\t\t\t}\n\t\t\tif (i2 == ii) {\n\t\t\t\tif (dsp_debug & DEBUG_DSP_CMX)\n\t\t\t\t\tprintk(KERN_DEBUG\n\t\t\t\t\t       \"%s no slot available \"\n\t\t\t\t\t       \"for %s & %s\\n\",\n\t\t\t\t\t       __func__,\n\t\t\t\t\t       member->dsp->name,\n\t\t\t\t\t       nextm->dsp->name);\n\t\t\t\t \n\t\t\t\tgoto conf_software;\n\t\t\t}\n\t\t\t \n\t\t\tmember->dsp->pcm_slot_tx = i1;\n\t\t\tmember->dsp->pcm_slot_rx = i2;\n\t\t\tnextm->dsp->pcm_slot_tx = i2;\n\t\t\tnextm->dsp->pcm_slot_rx = i1;\n\t\t\tmember->dsp->pcm_bank_rx = 0;\n\t\t\tmember->dsp->pcm_bank_tx = 0;\n\t\t\tnextm->dsp->pcm_bank_rx = 0;\n\t\t\tnextm->dsp->pcm_bank_tx = 0;\n\t\t\tif (dsp_debug & DEBUG_DSP_CMX)\n\t\t\t\tprintk(KERN_DEBUG\n\t\t\t\t       \"%s adding %s & %s to new PCM slot %d \"\n\t\t\t\t       \"(TX) %d (RX) on same chip or one bank \"\n\t\t\t\t       \"PCM, because both members have not \"\n\t\t\t\t       \"crossed slots\\n\", __func__,\n\t\t\t\t       member->dsp->name,\n\t\t\t\t       nextm->dsp->name,\n\t\t\t\t       member->dsp->pcm_slot_tx,\n\t\t\t\t       member->dsp->pcm_slot_rx);\n\t\t\tdsp_cmx_hw_message(member->dsp, MISDN_CTRL_HFC_PCM_CONN,\n\t\t\t\t\t   member->dsp->pcm_slot_tx, member->dsp->pcm_bank_tx,\n\t\t\t\t\t   member->dsp->pcm_slot_rx, member->dsp->pcm_bank_rx);\n\t\t\tdsp_cmx_hw_message(nextm->dsp, MISDN_CTRL_HFC_PCM_CONN,\n\t\t\t\t\t   nextm->dsp->pcm_slot_tx, nextm->dsp->pcm_bank_tx,\n\t\t\t\t\t   nextm->dsp->pcm_slot_rx, nextm->dsp->pcm_bank_rx);\n\t\t\tconf->hardware = 1;\n\t\t\tconf->software = tx_data;\n\t\t\treturn;\n\t\t}\n\t}\n\n\t \n\n\t \n\tif (same_hfc < 0) {\n\t\tif (dsp_debug & DEBUG_DSP_CMX)\n\t\t\tprintk(KERN_DEBUG\n\t\t\t       \"%s conference %d cannot be formed, because \"\n\t\t\t       \"members are on different chips or not \"\n\t\t\t       \"on HFC chip\\n\",\n\t\t\t       __func__, conf->id);\n\t\tgoto conf_software;\n\t}\n\n\t \n\n\t \n\tif (all_conf) {\n\t\tconf->hardware = 1;\n\t\tconf->software = tx_data;\n\t\treturn;\n\t}\n\n\t \n\tif (current_conf >= 0) {\n\tjoin_members:\n\t\tlist_for_each_entry(member, &conf->mlist, list) {\n\t\t\t \n\t\t\tif (!member->dsp->features.hfc_conf)\n\t\t\t\tgoto conf_software;\n\t\t\t \n\t\t\tif (member->dsp->hdlc)\n\t\t\t\tgoto conf_software;\n\t\t\t \n\t\t\tif (member->dsp->hfc_conf == current_conf)\n\t\t\t\tcontinue;\n\t\t\t \n\t\t\tmemset(freeslots, 1, sizeof(freeslots));\n\t\t\tlist_for_each_entry(dsp, &dsp_ilist, list) {\n\t\t\t\t \n\t\t\t\tif (\n\t\t\t\t\tdsp != member->dsp &&\n\t\t\t\t\t \n\t\t\t\t\tmember->dsp->features.pcm_id ==\n\t\t\t\t\tdsp->features.pcm_id) {\n\t\t\t\t\t \n\t\t\t\t\tif (dsp->pcm_slot_tx >= 0 &&\n\t\t\t\t\t    dsp->pcm_slot_tx <\n\t\t\t\t\t    sizeof(freeslots))\n\t\t\t\t\t\tfreeslots[dsp->pcm_slot_tx] = 0;\n\t\t\t\t\tif (dsp->pcm_slot_rx >= 0 &&\n\t\t\t\t\t    dsp->pcm_slot_rx <\n\t\t\t\t\t    sizeof(freeslots))\n\t\t\t\t\t\tfreeslots[dsp->pcm_slot_rx] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\ti = 0;\n\t\t\tii = member->dsp->features.pcm_slots;\n\t\t\twhile (i < ii) {\n\t\t\t\tif (freeslots[i])\n\t\t\t\t\tbreak;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tif (i == ii) {\n\t\t\t\t \n\t\t\t\tif (dsp_debug & DEBUG_DSP_CMX)\n\t\t\t\t\tprintk(KERN_DEBUG\n\t\t\t\t\t       \"%s conference %d cannot be formed,\"\n\t\t\t\t\t       \" because no slot free\\n\",\n\t\t\t\t\t       __func__, conf->id);\n\t\t\t\tgoto conf_software;\n\t\t\t}\n\t\t\tif (dsp_debug & DEBUG_DSP_CMX)\n\t\t\t\tprintk(KERN_DEBUG\n\t\t\t\t       \"%s changing dsp %s to HW conference \"\n\t\t\t\t       \"%d slot %d\\n\", __func__,\n\t\t\t\t       member->dsp->name, current_conf, i);\n\t\t\t \n\t\t\tmember->dsp->pcm_slot_tx = i;\n\t\t\tmember->dsp->pcm_slot_rx = i;\n\t\t\tmember->dsp->pcm_bank_tx = 2;  \n\t\t\tmember->dsp->pcm_bank_rx = 2;\n\t\t\tmember->dsp->hfc_conf = current_conf;\n\t\t\tdsp_cmx_hw_message(member->dsp, MISDN_CTRL_HFC_PCM_CONN,\n\t\t\t\t\t   i, 2, i, 2);\n\t\t\tdsp_cmx_hw_message(member->dsp,\n\t\t\t\t\t   MISDN_CTRL_HFC_CONF_JOIN, current_conf, 0, 0, 0);\n\t\t}\n\t\tconf->hardware = 1;\n\t\tconf->software = tx_data;\n\t\treturn;\n\t}\n\n\t \n\tmemset(freeunits, 1, sizeof(freeunits));\n\tlist_for_each_entry(dsp, &dsp_ilist, list) {\n\t\t \n\t\tif (dsp->features.hfc_id == same_hfc &&\n\t\t     \n\t\t    dsp->hfc_conf >= 0 &&\n\t\t     \n\t\t    dsp->hfc_conf < 8)\n\t\t\tfreeunits[dsp->hfc_conf] = 0;\n\t}\n\ti = 0;\n\tii = 8;\n\twhile (i < ii) {\n\t\tif (freeunits[i])\n\t\t\tbreak;\n\t\ti++;\n\t}\n\tif (i == ii) {\n\t\t \n\t\tif (dsp_debug & DEBUG_DSP_CMX)\n\t\t\tprintk(KERN_DEBUG\n\t\t\t       \"%s conference %d cannot be formed, because \"\n\t\t\t       \"no conference number free\\n\",\n\t\t\t       __func__, conf->id);\n\t\tgoto conf_software;\n\t}\n\t \n\tcurrent_conf = i;\n\tgoto join_members;\n}\n\n\n \nint\ndsp_cmx_conf(struct dsp *dsp, u32 conf_id)\n{\n\tint err;\n\tstruct dsp_conf *conf;\n\tstruct dsp_conf_member\t*member;\n\n\t \n\tif (dsp->conf_id == conf_id)\n\t\treturn 0;\n\n\t \n\tif (dsp->conf_id) {\n\t\tif (dsp_debug & DEBUG_DSP_CMX)\n\t\t\tprintk(KERN_DEBUG \"removing us from conference %d\\n\",\n\t\t\t       dsp->conf->id);\n\t\t \n\t\tconf = dsp->conf;\n\t\terr = dsp_cmx_del_conf_member(dsp);\n\t\tif (err)\n\t\t\treturn err;\n\t\tdsp->conf_id = 0;\n\n\t\t \n\t\tdsp_cmx_hardware(NULL, dsp);\n\n\t\t \n\t\tif (list_empty(&conf->mlist)) {\n\t\t\tif (dsp_debug & DEBUG_DSP_CMX)\n\t\t\t\tprintk(KERN_DEBUG\n\t\t\t\t       \"conference is empty, so we remove it.\\n\");\n\t\t\terr = dsp_cmx_del_conf(conf);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t} else {\n\t\t\t \n\t\t\tdsp_cmx_hardware(conf, NULL);\n\t\t}\n\t}\n\n\t \n\tif (!conf_id)\n\t\treturn 0;\n\n\t \n\tif (dsp_debug & DEBUG_DSP_CMX)\n\t\tprintk(KERN_DEBUG \"searching conference %d\\n\",\n\t\t       conf_id);\n\tconf = dsp_cmx_search_conf(conf_id);\n\tif (!conf) {\n\t\tif (dsp_debug & DEBUG_DSP_CMX)\n\t\t\tprintk(KERN_DEBUG\n\t\t\t       \"conference doesn't exist yet, creating.\\n\");\n\t\t \n\t\tconf = dsp_cmx_new_conf(conf_id);\n\t\tif (!conf)\n\t\t\treturn -EINVAL;\n\t} else if (!list_empty(&conf->mlist)) {\n\t\tmember = list_entry(conf->mlist.next, struct dsp_conf_member,\n\t\t\t\t    list);\n\t\tif (dsp->hdlc && !member->dsp->hdlc) {\n\t\t\tif (dsp_debug & DEBUG_DSP_CMX)\n\t\t\t\tprintk(KERN_DEBUG\n\t\t\t\t       \"cannot join transparent conference.\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (!dsp->hdlc && member->dsp->hdlc) {\n\t\t\tif (dsp_debug & DEBUG_DSP_CMX)\n\t\t\t\tprintk(KERN_DEBUG\n\t\t\t\t       \"cannot join hdlc conference.\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\t \n\terr = dsp_cmx_add_conf_member(dsp, conf);\n\tif (err)\n\t\treturn err;\n\tdsp->conf_id = conf_id;\n\n\t \n\tif (list_empty(&conf->mlist)) {\n\t\tif (dsp_debug & DEBUG_DSP_CMX)\n\t\t\tprintk(KERN_DEBUG\n\t\t\t       \"we are alone in this conference, so exit.\\n\");\n\t\t \n\t\tdsp_cmx_hardware(NULL, dsp);\n\t\treturn 0;\n\t}\n\n\t \n\tdsp_cmx_hardware(conf, NULL);\n\n\treturn 0;\n}\n\n#ifdef CMX_DELAY_DEBUG\nint delaycount;\nstatic void\nshowdelay(struct dsp *dsp, int samples, int delay)\n{\n\tchar bar[] = \"--------------------------------------------------|\";\n\tint sdelay;\n\n\tdelaycount += samples;\n\tif (delaycount < 8000)\n\t\treturn;\n\tdelaycount = 0;\n\n\tsdelay = delay * 50 / (dsp_poll << 2);\n\n\tprintk(KERN_DEBUG \"DELAY (%s) %3d >%s\\n\", dsp->name, delay,\n\t       sdelay > 50 ? \"...\" : bar + 50 - sdelay);\n}\n#endif\n\n \nvoid\ndsp_cmx_receive(struct dsp *dsp, struct sk_buff *skb)\n{\n\tu8 *d, *p;\n\tint len = skb->len;\n\tstruct mISDNhead *hh = mISDN_HEAD_P(skb);\n\tint w, i, ii;\n\n\t \n\tif (len < 1)\n\t\treturn;\n\n\t \n\tif (len >= CMX_BUFF_HALF) {\n\t\tprintk(KERN_ERR\n\t\t       \"%s line %d: packet from card is too large (%d bytes). \"\n\t\t       \"please make card send smaller packets OR increase \"\n\t\t       \"CMX_BUFF_SIZE\\n\", __FILE__, __LINE__, len);\n\t\treturn;\n\t}\n\n\t \n\tif (dsp->rx_init) {\n\t\tdsp->rx_init = 0;\n\t\tif (dsp->features.unordered) {\n\t\t\tdsp->rx_R = (hh->id & CMX_BUFF_MASK);\n\t\t\tif (dsp->cmx_delay)\n\t\t\t\tdsp->rx_W = (dsp->rx_R + dsp->cmx_delay)\n\t\t\t\t\t& CMX_BUFF_MASK;\n\t\t\telse\n\t\t\t\tdsp->rx_W = (dsp->rx_R + (dsp_poll >> 1))\n\t\t\t\t\t& CMX_BUFF_MASK;\n\t\t} else {\n\t\t\tdsp->rx_R = 0;\n\t\t\tif (dsp->cmx_delay)\n\t\t\t\tdsp->rx_W = dsp->cmx_delay;\n\t\t\telse\n\t\t\t\tdsp->rx_W = dsp_poll >> 1;\n\t\t}\n\t}\n\t \n\tif (dsp->features.unordered) {\n\t\tdsp->rx_W = (hh->id & CMX_BUFF_MASK);\n\t\t \n\t}\n\t \n\tif (((dsp->rx_W-dsp->rx_R) & CMX_BUFF_MASK) >= CMX_BUFF_HALF) {\n\t\tif (dsp_debug & DEBUG_DSP_CLOCK)\n\t\t\tprintk(KERN_DEBUG\n\t\t\t       \"cmx_receive(dsp=%lx): UNDERRUN (or overrun the \"\n\t\t\t       \"maximum delay), adjusting read pointer! \"\n\t\t\t       \"(inst %s)\\n\", (u_long)dsp, dsp->name);\n\t\t \n\t\tif (dsp->features.unordered) {\n\t\t\tdsp->rx_R = (hh->id & CMX_BUFF_MASK);\n\t\t\tif (dsp->cmx_delay)\n\t\t\t\tdsp->rx_W = (dsp->rx_R + dsp->cmx_delay)\n\t\t\t\t\t& CMX_BUFF_MASK;\n\t\t\telse\n\t\t\t\tdsp->rx_W = (dsp->rx_R + (dsp_poll >> 1))\n\t\t\t\t\t& CMX_BUFF_MASK;\n\t\t} else {\n\t\t\tdsp->rx_R = 0;\n\t\t\tif (dsp->cmx_delay)\n\t\t\t\tdsp->rx_W = dsp->cmx_delay;\n\t\t\telse\n\t\t\t\tdsp->rx_W = dsp_poll >> 1;\n\t\t}\n\t\tmemset(dsp->rx_buff, dsp_silence, sizeof(dsp->rx_buff));\n\t}\n\t \n\tif (dsp->cmx_delay)\n\t\tif (((dsp->rx_W - dsp->rx_R) & CMX_BUFF_MASK) >=\n\t\t    (dsp->cmx_delay << 1)) {\n\t\t\tif (dsp_debug & DEBUG_DSP_CLOCK)\n\t\t\t\tprintk(KERN_DEBUG\n\t\t\t\t       \"cmx_receive(dsp=%lx): OVERRUN (because \"\n\t\t\t\t       \"twice the delay is reached), adjusting \"\n\t\t\t\t       \"read pointer! (inst %s)\\n\",\n\t\t\t\t       (u_long)dsp, dsp->name);\n\t\t\t \n\t\t\tif (dsp->features.unordered) {\n\t\t\t\tdsp->rx_R = (hh->id & CMX_BUFF_MASK);\n\t\t\t\tdsp->rx_W = (dsp->rx_R + dsp->cmx_delay)\n\t\t\t\t\t& CMX_BUFF_MASK;\n\t\t\t} else {\n\t\t\t\tdsp->rx_R = 0;\n\t\t\t\tdsp->rx_W = dsp->cmx_delay;\n\t\t\t}\n\t\t\tmemset(dsp->rx_buff, dsp_silence, sizeof(dsp->rx_buff));\n\t\t}\n\n\t \n#ifdef CMX_DEBUG\n\tprintk(KERN_DEBUG\n\t       \"cmx_receive(dsp=%lx): rx_R(dsp)=%05x rx_W(dsp)=%05x len=%d %s\\n\",\n\t       (u_long)dsp, dsp->rx_R, dsp->rx_W, len, dsp->name);\n#endif\n\n\t \n\tp = skb->data;\n\td = dsp->rx_buff;\n\tw = dsp->rx_W;\n\ti = 0;\n\tii = len;\n\twhile (i < ii) {\n\t\td[w++ & CMX_BUFF_MASK] = *p++;\n\t\ti++;\n\t}\n\n\t \n\tdsp->rx_W = ((dsp->rx_W + len) & CMX_BUFF_MASK);\n#ifdef CMX_DELAY_DEBUG\n\tshowdelay(dsp, len, (dsp->rx_W-dsp->rx_R) & CMX_BUFF_MASK);\n#endif\n}\n\n\n \nstatic void\ndsp_cmx_send_member(struct dsp *dsp, int len, s32 *c, int members)\n{\n\tstruct dsp_conf *conf = dsp->conf;\n\tstruct dsp *member, *other;\n\tregister s32 sample;\n\tu8 *d, *p, *q, *o_q;\n\tstruct sk_buff *nskb, *txskb;\n\tint r, rr, t, tt, o_r, o_rr;\n\tint preload = 0;\n\tstruct mISDNhead *hh, *thh;\n\tint tx_data_only = 0;\n\n\t \n\tif (!dsp->b_active) {  \n\t\tdsp->last_tx = 0;\n\t\treturn;\n\t}\n\tif (((dsp->conf && dsp->conf->hardware) ||  \n\t     dsp->echo.hardware) &&  \n\t    dsp->tx_R == dsp->tx_W &&  \n\t    !(dsp->tone.tone && dsp->tone.software)) {  \n\t\tif (!dsp->tx_data) {  \n\t\t\tdsp->last_tx = 0;\n\t\t\treturn;\n\t\t}\n\t\tif (dsp->conf && dsp->conf->software && dsp->conf->hardware)\n\t\t\ttx_data_only = 1;\n\t\tif (dsp->echo.software && dsp->echo.hardware)\n\t\t\ttx_data_only = 1;\n\t}\n\n#ifdef CMX_DEBUG\n\tprintk(KERN_DEBUG\n\t       \"SEND members=%d dsp=%s, conf=%p, rx_R=%05x rx_W=%05x\\n\",\n\t       members, dsp->name, conf, dsp->rx_R, dsp->rx_W);\n#endif\n\n\t \n\tif (dsp->cmx_delay && !dsp->last_tx) {\n\t\tpreload = len;\n\t\tif (preload < 128)\n\t\t\tpreload = 128;\n\t}\n\n\t \n\tnskb = mI_alloc_skb(len + preload, GFP_ATOMIC);\n\tif (!nskb) {\n\t\tprintk(KERN_ERR\n\t\t       \"FATAL ERROR in mISDN_dsp.o: cannot alloc %d bytes\\n\",\n\t\t       len + preload);\n\t\treturn;\n\t}\n\thh = mISDN_HEAD_P(nskb);\n\thh->prim = PH_DATA_REQ;\n\thh->id = 0;\n\tdsp->last_tx = 1;\n\n\t \n\tmember = dsp;\n\tp = dsp->tx_buff;  \n\tq = dsp->rx_buff;  \n\td = skb_put(nskb, preload + len);  \n\tt = dsp->tx_R;  \n\ttt = dsp->tx_W;\n\tr = dsp->rx_R;  \n\trr = (r + len) & CMX_BUFF_MASK;\n\n\t \n\tif (preload) {\n\t\tmemset(d, dsp_silence, preload);\n\t\td += preload;\n\t}\n\n\t \n\tif (dsp->tone.tone && dsp->tone.software) {\n\t\t \n\t\tdsp_tone_copy(dsp, d, len);\n\t\tdsp->tx_R = 0;  \n\t\tdsp->tx_W = 0;\n\t\tgoto send_packet;\n\t}\n\t \n\tif (!dsp->tx_mix && t != tt) {\n\t\t \n#ifdef CMX_TX_DEBUG\n\t\tsprintf(debugbuf, \"TX sending (%04x-%04x)%p: \", t, tt, p);\n#endif\n\t\twhile (r != rr && t != tt) {\n#ifdef CMX_TX_DEBUG\n\t\t\tif (strlen(debugbuf) < 48)\n\t\t\t\tsprintf(debugbuf + strlen(debugbuf), \" %02x\",\n\t\t\t\t\tp[t]);\n#endif\n\t\t\t*d++ = p[t];  \n\t\t\tt = (t + 1) & CMX_BUFF_MASK;\n\t\t\tr = (r + 1) & CMX_BUFF_MASK;\n\t\t}\n\t\tif (r == rr) {\n\t\t\tdsp->tx_R = t;\n#ifdef CMX_TX_DEBUG\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", debugbuf);\n#endif\n\t\t\tgoto send_packet;\n\t\t}\n\t}\n#ifdef CMX_TX_DEBUG\n\tprintk(KERN_DEBUG \"%s\\n\", debugbuf);\n#endif\n\n\t \n\tif (!conf || members <= 1) {\n\t\t \n\t\tif (!dsp->echo.software) {\n\t\t\t \n\t\t\twhile (r != rr && t != tt) {\n\t\t\t\t*d++ = p[t];  \n\t\t\t\tt = (t + 1) & CMX_BUFF_MASK;\n\t\t\t\tr = (r + 1) & CMX_BUFF_MASK;\n\t\t\t}\n\t\t\tif (r != rr) {\n\t\t\t\tif (dsp_debug & DEBUG_DSP_CLOCK)\n\t\t\t\t\tprintk(KERN_DEBUG \"%s: RX empty\\n\",\n\t\t\t\t\t       __func__);\n\t\t\t\tmemset(d, dsp_silence, (rr - r) & CMX_BUFF_MASK);\n\t\t\t}\n\t\t\t \n\t\t} else {\n\t\t\t \n\t\t\twhile (r != rr && t != tt) {\n\t\t\t\t*d++ = dsp_audio_mix_law[(p[t] << 8) | q[r]];\n\t\t\t\tt = (t + 1) & CMX_BUFF_MASK;\n\t\t\t\tr = (r + 1) & CMX_BUFF_MASK;\n\t\t\t}\n\t\t\twhile (r != rr) {\n\t\t\t\t*d++ = q[r];  \n\t\t\t\tr = (r + 1) & CMX_BUFF_MASK;\n\t\t\t}\n\t\t}\n\t\tdsp->tx_R = t;\n\t\tgoto send_packet;\n\t}\n\t \n#ifdef CMX_CONF_DEBUG\n\tif (0) {\n#else\n\tif (members == 2) {\n#endif\n\t\t \n\t\tother = (list_entry(conf->mlist.next,\n\t\t\t\t    struct dsp_conf_member, list))->dsp;\n\t\tif (other == member)\n\t\t\tother = (list_entry(conf->mlist.prev,\n\t\t\t\t    struct dsp_conf_member, list))->dsp;\n\t\to_q = other->rx_buff;  \n\t\to_rr = (other->rx_R + len) & CMX_BUFF_MASK;\n\t\t \n\t\to_r = (o_rr - rr + r) & CMX_BUFF_MASK;\n\t\t \n\t\t \n\t\tif (!dsp->echo.software) {\n\t\t\t \n\t\t\twhile (o_r != o_rr && t != tt) {\n\t\t\t\t*d++ = dsp_audio_mix_law[(p[t] << 8) | o_q[o_r]];\n\t\t\t\tt = (t + 1) & CMX_BUFF_MASK;\n\t\t\t\to_r = (o_r + 1) & CMX_BUFF_MASK;\n\t\t\t}\n\t\t\twhile (o_r != o_rr) {\n\t\t\t\t*d++ = o_q[o_r];\n\t\t\t\to_r = (o_r + 1) & CMX_BUFF_MASK;\n\t\t\t}\n\t\t\t \n\t\t} else {\n\t\t\t \n\t\t\twhile (r != rr && t != tt) {\n\t\t\t\tsample = dsp_audio_law_to_s32[p[t]] +\n\t\t\t\t\tdsp_audio_law_to_s32[q[r]] +\n\t\t\t\t\tdsp_audio_law_to_s32[o_q[o_r]];\n\t\t\t\tif (sample < -32768)\n\t\t\t\t\tsample = -32768;\n\t\t\t\telse if (sample > 32767)\n\t\t\t\t\tsample = 32767;\n\t\t\t\t*d++ = dsp_audio_s16_to_law[sample & 0xffff];\n\t\t\t\t \n\t\t\t\tt = (t + 1) & CMX_BUFF_MASK;\n\t\t\t\tr = (r + 1) & CMX_BUFF_MASK;\n\t\t\t\to_r = (o_r + 1) & CMX_BUFF_MASK;\n\t\t\t}\n\t\t\twhile (r != rr) {\n\t\t\t\t*d++ = dsp_audio_mix_law[(q[r] << 8) | o_q[o_r]];\n\t\t\t\tr = (r + 1) & CMX_BUFF_MASK;\n\t\t\t\to_r = (o_r + 1) & CMX_BUFF_MASK;\n\t\t\t}\n\t\t}\n\t\tdsp->tx_R = t;\n\t\tgoto send_packet;\n\t}\n\t \n\t \n\tif (!dsp->echo.software) {\n\t\t \n\t\twhile (r != rr && t != tt) {\n\t\t\tsample = dsp_audio_law_to_s32[p[t]] + *c++ -\n\t\t\t\tdsp_audio_law_to_s32[q[r]];\n\t\t\tif (sample < -32768)\n\t\t\t\tsample = -32768;\n\t\t\telse if (sample > 32767)\n\t\t\t\tsample = 32767;\n\t\t\t*d++ = dsp_audio_s16_to_law[sample & 0xffff];\n\t\t\t \n\t\t\tr = (r + 1) & CMX_BUFF_MASK;\n\t\t\tt = (t + 1) & CMX_BUFF_MASK;\n\t\t}\n\t\twhile (r != rr) {\n\t\t\tsample = *c++ - dsp_audio_law_to_s32[q[r]];\n\t\t\tif (sample < -32768)\n\t\t\t\tsample = -32768;\n\t\t\telse if (sample > 32767)\n\t\t\t\tsample = 32767;\n\t\t\t*d++ = dsp_audio_s16_to_law[sample & 0xffff];\n\t\t\t \n\t\t\tr = (r + 1) & CMX_BUFF_MASK;\n\t\t}\n\t\t \n\t} else {\n\t\t \n\t\twhile (r != rr && t != tt) {\n\t\t\tsample = dsp_audio_law_to_s32[p[t]] + *c++;\n\t\t\tif (sample < -32768)\n\t\t\t\tsample = -32768;\n\t\t\telse if (sample > 32767)\n\t\t\t\tsample = 32767;\n\t\t\t*d++ = dsp_audio_s16_to_law[sample & 0xffff];\n\t\t\t \n\t\t\tt = (t + 1) & CMX_BUFF_MASK;\n\t\t\tr = (r + 1) & CMX_BUFF_MASK;\n\t\t}\n\t\twhile (r != rr) {\n\t\t\tsample = *c++;\n\t\t\tif (sample < -32768)\n\t\t\t\tsample = -32768;\n\t\t\telse if (sample > 32767)\n\t\t\t\tsample = 32767;\n\t\t\t*d++ = dsp_audio_s16_to_law[sample & 0xffff];\n\t\t\t \n\t\t\tr = (r + 1) & CMX_BUFF_MASK;\n\t\t}\n\t}\n\tdsp->tx_R = t;\n\tgoto send_packet;\n\nsend_packet:\n\t \n\tif (dsp->tx_data) {\n\t\tif (tx_data_only) {\n\t\t\thh->prim = DL_DATA_REQ;\n\t\t\thh->id = 0;\n\t\t\t \n\t\t\tskb_queue_tail(&dsp->sendq, nskb);\n\t\t\tschedule_work(&dsp->workq);\n\t\t\t \n\t\t\treturn;\n\t\t} else {\n\t\t\ttxskb = mI_alloc_skb(len, GFP_ATOMIC);\n\t\t\tif (!txskb) {\n\t\t\t\tprintk(KERN_ERR\n\t\t\t\t       \"FATAL ERROR in mISDN_dsp.o: \"\n\t\t\t\t       \"cannot alloc %d bytes\\n\", len);\n\t\t\t} else {\n\t\t\t\tthh = mISDN_HEAD_P(txskb);\n\t\t\t\tthh->prim = DL_DATA_REQ;\n\t\t\t\tthh->id = 0;\n\t\t\t\tskb_put_data(txskb, nskb->data + preload, len);\n\t\t\t\t \n\t\t\t\tskb_queue_tail(&dsp->sendq, txskb);\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\t \n\tif (dsp->tx_volume)\n\t\tdsp_change_volume(nskb, dsp->tx_volume);\n\t \n\tif (dsp->pipeline.inuse)\n\t\tdsp_pipeline_process_tx(&dsp->pipeline, nskb->data,\n\t\t\t\t\tnskb->len);\n\t \n\tif (dsp->bf_enable)\n\t\tdsp_bf_encrypt(dsp, nskb->data, nskb->len);\n\t \n\tskb_queue_tail(&dsp->sendq, nskb);\n\tschedule_work(&dsp->workq);\n}\n\nstatic u32\tjittercount;  \nstruct timer_list dsp_spl_tl;\nunsigned long\tdsp_spl_jiffies;  \nstatic u16\tdsp_count;  \nstatic int\tdsp_count_valid;  \n\nvoid\ndsp_cmx_send(struct timer_list *arg)\n{\n\tstruct dsp_conf *conf;\n\tstruct dsp_conf_member *member;\n\tstruct dsp *dsp;\n\tint mustmix, members;\n\tstatic s32 mixbuffer[MAX_POLL + 100];\n\ts32 *c;\n\tu8 *p, *q;\n\tint r, rr;\n\tint jittercheck = 0, delay, i;\n\tu_long flags;\n\tu16 length, count;\n\n\t \n\tspin_lock_irqsave(&dsp_lock, flags);\n\n\tif (!dsp_count_valid) {\n\t\tdsp_count = mISDN_clock_get();\n\t\tlength = dsp_poll;\n\t\tdsp_count_valid = 1;\n\t} else {\n\t\tcount = mISDN_clock_get();\n\t\tlength = count - dsp_count;\n\t\tdsp_count = count;\n\t}\n\tif (length > MAX_POLL + 100)\n\t\tlength = MAX_POLL + 100;\n\t \n\n\t \n\tjittercount += length;\n\tif (jittercount >= 8000) {\n\t\tjittercount -= 8000;\n\t\tjittercheck = 1;\n\t}\n\n\t \n\tlist_for_each_entry(dsp, &dsp_ilist, list) {\n\t\tif (dsp->hdlc)\n\t\t\tcontinue;\n\t\tconf = dsp->conf;\n\t\tmustmix = 0;\n\t\tmembers = 0;\n\t\tif (conf) {\n\t\t\tmembers = list_count_nodes(&conf->mlist);\n#ifdef CMX_CONF_DEBUG\n\t\t\tif (conf->software && members > 1)\n#else\n\t\t\tif (conf->software && members > 2)\n#endif\n\t\t\t\tmustmix = 1;\n\t\t}\n\n\t\t \n\t\tif (!mustmix) {\n\t\t\tdsp_cmx_send_member(dsp, length, mixbuffer, members);\n\n\t\t\t \n\t\t}\n\t}\n\n\t \n\tlist_for_each_entry(conf, &conf_ilist, list) {\n\t\t \n\t\tmembers = list_count_nodes(&conf->mlist);\n#ifdef CMX_CONF_DEBUG\n\t\tif (conf->software && members > 1) {\n#else\n\t\tif (conf->software && members > 2) {\n#endif\n\t\t\t \n\t\t\tmember = list_entry(conf->mlist.next,\n\t\t\t\t\t    struct dsp_conf_member, list);\n\t\t\tif (member->dsp->hdlc)\n\t\t\t\tcontinue;\n\t\t\t \n\t\t\tmemset(mixbuffer, 0, length * sizeof(s32));\n\t\t\tlist_for_each_entry(member, &conf->mlist, list) {\n\t\t\t\tdsp = member->dsp;\n\t\t\t\t \n\t\t\t\tc = mixbuffer;\n\t\t\t\tq = dsp->rx_buff;\n\t\t\t\tr = dsp->rx_R;\n\t\t\t\trr = (r + length) & CMX_BUFF_MASK;\n\t\t\t\t \n\t\t\t\twhile (r != rr) {\n\t\t\t\t\t*c++ += dsp_audio_law_to_s32[q[r]];\n\t\t\t\t\tr = (r + 1) & CMX_BUFF_MASK;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t \n\t\t\tlist_for_each_entry(member, &conf->mlist, list) {\n\t\t\t\t \n\t\t\t\tdsp_cmx_send_member(member->dsp, length,\n\t\t\t\t\t\t    mixbuffer, members);\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tlist_for_each_entry(dsp, &dsp_ilist, list) {\n\t\tif (dsp->hdlc)\n\t\t\tcontinue;\n\t\tp = dsp->rx_buff;\n\t\tq = dsp->tx_buff;\n\t\tr = dsp->rx_R;\n\t\t \n\t\tif (!dsp->rx_is_off) {\n\t\t\trr = (r + length) & CMX_BUFF_MASK;\n\t\t\t \n\t\t\twhile (r != rr) {\n\t\t\t\tp[r] = dsp_silence;\n\t\t\t\tr = (r + 1) & CMX_BUFF_MASK;\n\t\t\t}\n\t\t\t \n\t\t\tdsp->rx_R = r;  \n\t\t}\n\n\t\t \n\t\tdelay = (dsp->rx_W-dsp->rx_R) & CMX_BUFF_MASK;\n\t\tif (delay >= CMX_BUFF_HALF)\n\t\t\tdelay = 0;  \n\t\t \n\t\tif (delay < dsp->rx_delay[0])\n\t\t\tdsp->rx_delay[0] = delay;\n\t\t \n\t\tdelay = (dsp->tx_W-dsp->tx_R) & CMX_BUFF_MASK;\n\t\tif (delay >= CMX_BUFF_HALF)\n\t\t\tdelay = 0;  \n\t\t \n\t\tif (delay < dsp->tx_delay[0])\n\t\t\tdsp->tx_delay[0] = delay;\n\t\tif (jittercheck) {\n\t\t\t \n\t\t\tdelay = dsp->rx_delay[0];\n\t\t\ti = 1;\n\t\t\twhile (i < MAX_SECONDS_JITTER_CHECK) {\n\t\t\t\tif (delay > dsp->rx_delay[i])\n\t\t\t\t\tdelay = dsp->rx_delay[i];\n\t\t\t\ti++;\n\t\t\t}\n\t\t\t \n\t\t\tif (delay > dsp_poll && !dsp->cmx_delay) {\n\t\t\t\tif (dsp_debug & DEBUG_DSP_CLOCK)\n\t\t\t\t\tprintk(KERN_DEBUG\n\t\t\t\t\t       \"%s lowest rx_delay of %d bytes for\"\n\t\t\t\t\t       \" dsp %s are now removed.\\n\",\n\t\t\t\t\t       __func__, delay,\n\t\t\t\t\t       dsp->name);\n\t\t\t\tr = dsp->rx_R;\n\t\t\t\trr = (r + delay - (dsp_poll >> 1))\n\t\t\t\t\t& CMX_BUFF_MASK;\n\t\t\t\t \n\t\t\t\twhile (r != rr) {\n\t\t\t\t\tp[r] = dsp_silence;\n\t\t\t\t\tr = (r + 1) & CMX_BUFF_MASK;\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\tdsp->rx_R = r;\n\t\t\t\t \n\t\t\t}\n\t\t\t \n\t\t\tdelay = dsp->tx_delay[0];\n\t\t\ti = 1;\n\t\t\twhile (i < MAX_SECONDS_JITTER_CHECK) {\n\t\t\t\tif (delay > dsp->tx_delay[i])\n\t\t\t\t\tdelay = dsp->tx_delay[i];\n\t\t\t\ti++;\n\t\t\t}\n\t\t\t \n\t\t\tif (delay > dsp_poll && dsp->tx_dejitter) {\n\t\t\t\tif (dsp_debug & DEBUG_DSP_CLOCK)\n\t\t\t\t\tprintk(KERN_DEBUG\n\t\t\t\t\t       \"%s lowest tx_delay of %d bytes for\"\n\t\t\t\t\t       \" dsp %s are now removed.\\n\",\n\t\t\t\t\t       __func__, delay,\n\t\t\t\t\t       dsp->name);\n\t\t\t\tr = dsp->tx_R;\n\t\t\t\trr = (r + delay - (dsp_poll >> 1))\n\t\t\t\t\t& CMX_BUFF_MASK;\n\t\t\t\t \n\t\t\t\twhile (r != rr) {\n\t\t\t\t\tq[r] = dsp_silence;\n\t\t\t\t\tr = (r + 1) & CMX_BUFF_MASK;\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\tdsp->tx_R = r;\n\t\t\t\t \n\t\t\t}\n\t\t\t \n\t\t\ti = MAX_SECONDS_JITTER_CHECK - 1;\n\t\t\twhile (i) {\n\t\t\t\tdsp->rx_delay[i] = dsp->rx_delay[i - 1];\n\t\t\t\tdsp->tx_delay[i] = dsp->tx_delay[i - 1];\n\t\t\t\ti--;\n\t\t\t}\n\t\t\tdsp->tx_delay[0] = CMX_BUFF_HALF;  \n\t\t\tdsp->rx_delay[0] = CMX_BUFF_HALF;  \n\t\t}\n\t}\n\n\t \n\tif ((s32)(dsp_spl_jiffies + dsp_tics-jiffies) <= 0)\n\t\tdsp_spl_jiffies = jiffies + 1;\n\telse\n\t\tdsp_spl_jiffies += dsp_tics;\n\n\tdsp_spl_tl.expires = dsp_spl_jiffies;\n\tadd_timer(&dsp_spl_tl);\n\n\t \n\tspin_unlock_irqrestore(&dsp_lock, flags);\n}\n\n \nvoid\ndsp_cmx_transmit(struct dsp *dsp, struct sk_buff *skb)\n{\n\tu_int w, ww;\n\tu8 *d, *p;\n\tint space;  \n#ifdef CMX_TX_DEBUG\n\tchar debugbuf[256] = \"\";\n#endif\n\n\t \n\tw = dsp->tx_W;\n\tww = dsp->tx_R;\n\tp = dsp->tx_buff;\n\td = skb->data;\n\tspace = (ww - w - 1) & CMX_BUFF_MASK;\n\t \n\tif (space < skb->len) {\n\t\t \n\t\tww = (ww - 1) & CMX_BUFF_MASK;  \n\t\tif (dsp_debug & DEBUG_DSP_CLOCK)\n\t\t\tprintk(KERN_DEBUG \"%s: TX overflow space=%d skb->len=\"\n\t\t\t       \"%d, w=0x%04x, ww=0x%04x\\n\", __func__, space,\n\t\t\t       skb->len, w, ww);\n\t} else\n\t\t \n\t\tww = (w + skb->len) & CMX_BUFF_MASK;\n\tdsp->tx_W = ww;\n\t\t \n#ifdef CMX_DEBUG\n\tprintk(KERN_DEBUG\n\t       \"cmx_transmit(dsp=%lx) %d bytes to 0x%x-0x%x. %s\\n\",\n\t       (u_long)dsp, (ww - w) & CMX_BUFF_MASK, w, ww, dsp->name);\n#endif\n\n\t \n#ifdef CMX_TX_DEBUG\n\tsprintf(debugbuf, \"TX getting (%04x-%04x)%p: \", w, ww, p);\n#endif\n\twhile (w != ww) {\n#ifdef CMX_TX_DEBUG\n\t\tif (strlen(debugbuf) < 48)\n\t\t\tsprintf(debugbuf + strlen(debugbuf), \" %02x\", *d);\n#endif\n\t\tp[w] = *d++;\n\t\tw = (w + 1) & CMX_BUFF_MASK;\n\t}\n#ifdef CMX_TX_DEBUG\n\tprintk(KERN_DEBUG \"%s\\n\", debugbuf);\n#endif\n\n}\n\n \nvoid\ndsp_cmx_hdlc(struct dsp *dsp, struct sk_buff *skb)\n{\n\tstruct sk_buff *nskb = NULL;\n\tstruct dsp_conf_member *member;\n\tstruct mISDNhead *hh;\n\n\t \n\tif (!dsp->b_active)\n\t\treturn;\n\n\t \n\tif (skb->len < 1)\n\t\treturn;\n\n\t \n\tif (!dsp->conf) {\n\t\t \n\t\tif (dsp->echo.software) {\n\t\t\tnskb = skb_clone(skb, GFP_ATOMIC);\n\t\t\tif (nskb) {\n\t\t\t\thh = mISDN_HEAD_P(nskb);\n\t\t\t\thh->prim = PH_DATA_REQ;\n\t\t\t\thh->id = 0;\n\t\t\t\tskb_queue_tail(&dsp->sendq, nskb);\n\t\t\t\tschedule_work(&dsp->workq);\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\t \n\tif (dsp->conf->hardware)\n\t\treturn;\n\tlist_for_each_entry(member, &dsp->conf->mlist, list) {\n\t\tif (dsp->echo.software || member->dsp != dsp) {\n\t\t\tnskb = skb_clone(skb, GFP_ATOMIC);\n\t\t\tif (nskb) {\n\t\t\t\thh = mISDN_HEAD_P(nskb);\n\t\t\t\thh->prim = PH_DATA_REQ;\n\t\t\t\thh->id = 0;\n\t\t\t\tskb_queue_tail(&member->dsp->sendq, nskb);\n\t\t\t\tschedule_work(&member->dsp->workq);\n\t\t\t}\n\t\t}\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}