{
  "module_name": "dsp_pipeline.c",
  "hash_id": "b24583061e040739685df7d285f8c4a04242abbdb8bd2b2dbaeb8dccb76ce290",
  "original_prompt": "Ingested from linux-6.6.14/drivers/isdn/mISDN/dsp_pipeline.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/mISDNif.h>\n#include <linux/mISDNdsp.h>\n#include <linux/export.h>\n#include \"dsp.h\"\n#include \"dsp_hwec.h\"\n\nstruct dsp_pipeline_entry {\n\tstruct mISDN_dsp_element *elem;\n\tvoid                *p;\n\tstruct list_head     list;\n};\nstruct dsp_element_entry {\n\tstruct mISDN_dsp_element *elem;\n\tstruct device\t     dev;\n\tstruct list_head     list;\n};\n\nstatic LIST_HEAD(dsp_elements);\n\n \nstatic struct class *elements_class;\n\nstatic ssize_t\nattr_show_args(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct mISDN_dsp_element *elem = dev_get_drvdata(dev);\n\tint i;\n\tchar *p = buf;\n\n\t*buf = 0;\n\tfor (i = 0; i < elem->num_args; i++)\n\t\tp += sprintf(p, \"Name:        %s\\n%s%s%sDescription: %s\\n\\n\",\n\t\t\t     elem->args[i].name,\n\t\t\t     elem->args[i].def ? \"Default:     \" : \"\",\n\t\t\t     elem->args[i].def ? elem->args[i].def : \"\",\n\t\t\t     elem->args[i].def ? \"\\n\" : \"\",\n\t\t\t     elem->args[i].desc);\n\n\treturn p - buf;\n}\n\nstatic struct device_attribute element_attributes[] = {\n\t__ATTR(args, 0444, attr_show_args, NULL),\n};\n\nstatic void\nmISDN_dsp_dev_release(struct device *dev)\n{\n\tstruct dsp_element_entry *entry =\n\t\tcontainer_of(dev, struct dsp_element_entry, dev);\n\tlist_del(&entry->list);\n\tkfree(entry);\n}\n\nint mISDN_dsp_element_register(struct mISDN_dsp_element *elem)\n{\n\tstruct dsp_element_entry *entry;\n\tint ret, i;\n\n\tif (!elem)\n\t\treturn -EINVAL;\n\n\tentry = kzalloc(sizeof(struct dsp_element_entry), GFP_ATOMIC);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&entry->list);\n\tentry->elem = elem;\n\n\tentry->dev.class = elements_class;\n\tentry->dev.release = mISDN_dsp_dev_release;\n\tdev_set_drvdata(&entry->dev, elem);\n\tdev_set_name(&entry->dev, \"%s\", elem->name);\n\tret = device_register(&entry->dev);\n\tif (ret) {\n\t\tprintk(KERN_ERR \"%s: failed to register %s\\n\",\n\t\t       __func__, elem->name);\n\t\tgoto err1;\n\t}\n\tlist_add_tail(&entry->list, &dsp_elements);\n\n\tfor (i = 0; i < ARRAY_SIZE(element_attributes); ++i) {\n\t\tret = device_create_file(&entry->dev,\n\t\t\t\t\t &element_attributes[i]);\n\t\tif (ret) {\n\t\t\tprintk(KERN_ERR \"%s: failed to create device file\\n\",\n\t\t\t       __func__);\n\t\t\tgoto err2;\n\t\t}\n\t}\n\n\treturn 0;\n\nerr2:\n\tdevice_unregister(&entry->dev);\n\treturn ret;\nerr1:\n\tput_device(&entry->dev);\n\treturn ret;\n}\nEXPORT_SYMBOL(mISDN_dsp_element_register);\n\nvoid mISDN_dsp_element_unregister(struct mISDN_dsp_element *elem)\n{\n\tstruct dsp_element_entry *entry, *n;\n\n\tif (!elem)\n\t\treturn;\n\n\tlist_for_each_entry_safe(entry, n, &dsp_elements, list)\n\t\tif (entry->elem == elem) {\n\t\t\tdevice_unregister(&entry->dev);\n\t\t\treturn;\n\t\t}\n\tprintk(KERN_ERR \"%s: element %s not in list.\\n\", __func__, elem->name);\n}\nEXPORT_SYMBOL(mISDN_dsp_element_unregister);\n\nint dsp_pipeline_module_init(void)\n{\n\telements_class = class_create(\"dsp_pipeline\");\n\tif (IS_ERR(elements_class))\n\t\treturn PTR_ERR(elements_class);\n\n\tdsp_hwec_init();\n\n\treturn 0;\n}\n\nvoid dsp_pipeline_module_exit(void)\n{\n\tstruct dsp_element_entry *entry, *n;\n\n\tdsp_hwec_exit();\n\n\tclass_destroy(elements_class);\n\n\tlist_for_each_entry_safe(entry, n, &dsp_elements, list) {\n\t\tlist_del(&entry->list);\n\t\tprintk(KERN_WARNING \"%s: element was still registered: %s\\n\",\n\t\t       __func__, entry->elem->name);\n\t\tkfree(entry);\n\t}\n}\n\nint dsp_pipeline_init(struct dsp_pipeline *pipeline)\n{\n\tif (!pipeline)\n\t\treturn -EINVAL;\n\n\tINIT_LIST_HEAD(&pipeline->list);\n\n\treturn 0;\n}\n\nstatic inline void _dsp_pipeline_destroy(struct dsp_pipeline *pipeline)\n{\n\tstruct dsp_pipeline_entry *entry, *n;\n\n\tlist_for_each_entry_safe(entry, n, &pipeline->list, list) {\n\t\tlist_del(&entry->list);\n\t\tif (entry->elem == dsp_hwec)\n\t\t\tdsp_hwec_disable(container_of(pipeline, struct dsp,\n\t\t\t\t\t\t      pipeline));\n\t\telse\n\t\t\tentry->elem->free(entry->p);\n\t\tkfree(entry);\n\t}\n}\n\nvoid dsp_pipeline_destroy(struct dsp_pipeline *pipeline)\n{\n\n\tif (!pipeline)\n\t\treturn;\n\n\t_dsp_pipeline_destroy(pipeline);\n}\n\nint dsp_pipeline_build(struct dsp_pipeline *pipeline, const char *cfg)\n{\n\tint found = 0;\n\tchar *dup, *next, *tok, *name, *args;\n\tstruct dsp_element_entry *entry, *n;\n\tstruct dsp_pipeline_entry *pipeline_entry;\n\tstruct mISDN_dsp_element *elem;\n\n\tif (!pipeline)\n\t\treturn -EINVAL;\n\n\tif (!list_empty(&pipeline->list))\n\t\t_dsp_pipeline_destroy(pipeline);\n\n\tdup = next = kstrdup(cfg, GFP_ATOMIC);\n\tif (!dup)\n\t\treturn 0;\n\twhile ((tok = strsep(&next, \"|\"))) {\n\t\tif (!strlen(tok))\n\t\t\tcontinue;\n\t\tname = strsep(&tok, \"(\");\n\t\targs = strsep(&tok, \")\");\n\t\tif (args && !*args)\n\t\t\targs = NULL;\n\n\t\tlist_for_each_entry_safe(entry, n, &dsp_elements, list)\n\t\t\tif (!strcmp(entry->elem->name, name)) {\n\t\t\t\telem = entry->elem;\n\n\t\t\t\tpipeline_entry = kmalloc(sizeof(struct\n\t\t\t\t\t\t\t\tdsp_pipeline_entry), GFP_ATOMIC);\n\t\t\t\tif (!pipeline_entry) {\n\t\t\t\t\tprintk(KERN_ERR \"%s: failed to add \"\n\t\t\t\t\t       \"entry to pipeline: %s (out of \"\n\t\t\t\t\t       \"memory)\\n\", __func__, elem->name);\n\t\t\t\t\tgoto _out;\n\t\t\t\t}\n\t\t\t\tpipeline_entry->elem = elem;\n\n\t\t\t\tif (elem == dsp_hwec) {\n\t\t\t\t\t \n\t\t\t\t\tdsp_hwec_enable(container_of(pipeline,\n\t\t\t\t\t\t\t\t     struct dsp, pipeline), args);\n\t\t\t\t\tlist_add_tail(&pipeline_entry->list,\n\t\t\t\t\t\t      &pipeline->list);\n\t\t\t\t} else {\n\t\t\t\t\tpipeline_entry->p = elem->new(args);\n\t\t\t\t\tif (pipeline_entry->p) {\n\t\t\t\t\t\tlist_add_tail(&pipeline_entry->\n\t\t\t\t\t\t\t      list, &pipeline->list);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tprintk(KERN_ERR \"%s: failed \"\n\t\t\t\t\t\t       \"to add entry to pipeline: \"\n\t\t\t\t\t\t       \"%s (new() returned NULL)\\n\",\n\t\t\t\t\t\t       __func__, elem->name);\n\t\t\t\t\t\tkfree(pipeline_entry);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tif (found)\n\t\t\tfound = 0;\n\t\telse\n\t\t\tprintk(KERN_ERR \"%s: element not found, skipping: \"\n\t\t\t       \"%s\\n\", __func__, name);\n\t}\n\n_out:\n\tif (!list_empty(&pipeline->list))\n\t\tpipeline->inuse = 1;\n\telse\n\t\tpipeline->inuse = 0;\n\n\tkfree(dup);\n\treturn 0;\n}\n\nvoid dsp_pipeline_process_tx(struct dsp_pipeline *pipeline, u8 *data, int len)\n{\n\tstruct dsp_pipeline_entry *entry;\n\n\tif (!pipeline)\n\t\treturn;\n\n\tlist_for_each_entry(entry, &pipeline->list, list)\n\t\tif (entry->elem->process_tx)\n\t\t\tentry->elem->process_tx(entry->p, data, len);\n}\n\nvoid dsp_pipeline_process_rx(struct dsp_pipeline *pipeline, u8 *data, int len,\n\t\t\t     unsigned int txlen)\n{\n\tstruct dsp_pipeline_entry *entry;\n\n\tif (!pipeline)\n\t\treturn;\n\n\tlist_for_each_entry_reverse(entry, &pipeline->list, list)\n\t\tif (entry->elem->process_rx)\n\t\t\tentry->elem->process_rx(entry->p, data, len, txlen);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}