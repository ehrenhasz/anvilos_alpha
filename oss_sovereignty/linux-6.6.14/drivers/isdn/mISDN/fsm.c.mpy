{
  "module_name": "fsm.c",
  "hash_id": "1ea19d5a9fbcdcbf4b6212d3cccf1f60c784e351b349650604ea1410e55700f8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/isdn/mISDN/fsm.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include \"fsm.h\"\n\n#define FSM_TIMER_DEBUG 0\n\nint\nmISDN_FsmNew(struct Fsm *fsm,\n\t     struct FsmNode *fnlist, int fncount)\n{\n\tint i;\n\n\tfsm->jumpmatrix =\n\t\tkzalloc(array3_size(sizeof(FSMFNPTR), fsm->state_count,\n\t\t\t\t    fsm->event_count),\n\t\t\tGFP_KERNEL);\n\tif (fsm->jumpmatrix == NULL)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < fncount; i++)\n\t\tif ((fnlist[i].state >= fsm->state_count) ||\n\t\t    (fnlist[i].event >= fsm->event_count)) {\n\t\t\tprintk(KERN_ERR\n\t\t\t       \"mISDN_FsmNew Error: %d st(%ld/%ld) ev(%ld/%ld)\\n\",\n\t\t\t       i, (long)fnlist[i].state, (long)fsm->state_count,\n\t\t\t       (long)fnlist[i].event, (long)fsm->event_count);\n\t\t} else\n\t\t\tfsm->jumpmatrix[fsm->state_count * fnlist[i].event +\n\t\t\t\t\tfnlist[i].state] = (FSMFNPTR) fnlist[i].routine;\n\treturn 0;\n}\nEXPORT_SYMBOL(mISDN_FsmNew);\n\nvoid\nmISDN_FsmFree(struct Fsm *fsm)\n{\n\tkfree((void *) fsm->jumpmatrix);\n}\nEXPORT_SYMBOL(mISDN_FsmFree);\n\nint\nmISDN_FsmEvent(struct FsmInst *fi, int event, void *arg)\n{\n\tFSMFNPTR r;\n\n\tif ((fi->state >= fi->fsm->state_count) ||\n\t    (event >= fi->fsm->event_count)) {\n\t\tprintk(KERN_ERR\n\t\t       \"mISDN_FsmEvent Error st(%ld/%ld) ev(%d/%ld)\\n\",\n\t\t       (long)fi->state, (long)fi->fsm->state_count, event,\n\t\t       (long)fi->fsm->event_count);\n\t\treturn 1;\n\t}\n\tr = fi->fsm->jumpmatrix[fi->fsm->state_count * event + fi->state];\n\tif (r) {\n\t\tif (fi->debug)\n\t\t\tfi->printdebug(fi, \"State %s Event %s\",\n\t\t\t\t       fi->fsm->strState[fi->state],\n\t\t\t\t       fi->fsm->strEvent[event]);\n\t\tr(fi, event, arg);\n\t\treturn 0;\n\t} else {\n\t\tif (fi->debug)\n\t\t\tfi->printdebug(fi, \"State %s Event %s no action\",\n\t\t\t\t       fi->fsm->strState[fi->state],\n\t\t\t\t       fi->fsm->strEvent[event]);\n\t\treturn 1;\n\t}\n}\nEXPORT_SYMBOL(mISDN_FsmEvent);\n\nvoid\nmISDN_FsmChangeState(struct FsmInst *fi, int newstate)\n{\n\tfi->state = newstate;\n\tif (fi->debug)\n\t\tfi->printdebug(fi, \"ChangeState %s\",\n\t\t\t       fi->fsm->strState[newstate]);\n}\nEXPORT_SYMBOL(mISDN_FsmChangeState);\n\nstatic void\nFsmExpireTimer(struct timer_list *t)\n{\n\tstruct FsmTimer *ft = from_timer(ft, t, tl);\n#if FSM_TIMER_DEBUG\n\tif (ft->fi->debug)\n\t\tft->fi->printdebug(ft->fi, \"FsmExpireTimer %lx\", (long) ft);\n#endif\n\tmISDN_FsmEvent(ft->fi, ft->event, ft->arg);\n}\n\nvoid\nmISDN_FsmInitTimer(struct FsmInst *fi, struct FsmTimer *ft)\n{\n\tft->fi = fi;\n#if FSM_TIMER_DEBUG\n\tif (ft->fi->debug)\n\t\tft->fi->printdebug(ft->fi, \"mISDN_FsmInitTimer %lx\", (long) ft);\n#endif\n\ttimer_setup(&ft->tl, FsmExpireTimer, 0);\n}\nEXPORT_SYMBOL(mISDN_FsmInitTimer);\n\nvoid\nmISDN_FsmDelTimer(struct FsmTimer *ft, int where)\n{\n#if FSM_TIMER_DEBUG\n\tif (ft->fi->debug)\n\t\tft->fi->printdebug(ft->fi, \"mISDN_FsmDelTimer %lx %d\",\n\t\t\t\t   (long) ft, where);\n#endif\n\tdel_timer(&ft->tl);\n}\nEXPORT_SYMBOL(mISDN_FsmDelTimer);\n\nint\nmISDN_FsmAddTimer(struct FsmTimer *ft,\n\t\t  int millisec, int event, void *arg, int where)\n{\n\n#if FSM_TIMER_DEBUG\n\tif (ft->fi->debug)\n\t\tft->fi->printdebug(ft->fi, \"mISDN_FsmAddTimer %lx %d %d\",\n\t\t\t\t   (long) ft, millisec, where);\n#endif\n\n\tif (timer_pending(&ft->tl)) {\n\t\tif (ft->fi->debug) {\n\t\t\tprintk(KERN_WARNING\n\t\t\t       \"mISDN_FsmAddTimer: timer already active!\\n\");\n\t\t\tft->fi->printdebug(ft->fi,\n\t\t\t\t\t   \"mISDN_FsmAddTimer already active!\");\n\t\t}\n\t\treturn -1;\n\t}\n\tft->event = event;\n\tft->arg = arg;\n\tft->tl.expires = jiffies + (millisec * HZ) / 1000;\n\tadd_timer(&ft->tl);\n\treturn 0;\n}\nEXPORT_SYMBOL(mISDN_FsmAddTimer);\n\nvoid\nmISDN_FsmRestartTimer(struct FsmTimer *ft,\n\t\t      int millisec, int event, void *arg, int where)\n{\n\n#if FSM_TIMER_DEBUG\n\tif (ft->fi->debug)\n\t\tft->fi->printdebug(ft->fi, \"mISDN_FsmRestartTimer %lx %d %d\",\n\t\t\t\t   (long) ft, millisec, where);\n#endif\n\n\tif (timer_pending(&ft->tl))\n\t\tdel_timer(&ft->tl);\n\tft->event = event;\n\tft->arg = arg;\n\tft->tl.expires = jiffies + (millisec * HZ) / 1000;\n\tadd_timer(&ft->tl);\n}\nEXPORT_SYMBOL(mISDN_FsmRestartTimer);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}