{
  "module_name": "l1oip_core.c",
  "hash_id": "6be4560227ce9ad9a7d9094b17347f7787fd8486887c9a4a76407693a4d8d0fd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/isdn/mISDN/l1oip_core.c",
  "human_readable_source": "\n \n\n \n\n#define L1OIP_VERSION\t0\t \n\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/mISDNif.h>\n#include <linux/mISDNhw.h>\n#include <linux/mISDNdsp.h>\n#include <linux/init.h>\n#include <linux/in.h>\n#include <linux/inet.h>\n#include <linux/workqueue.h>\n#include <linux/kthread.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n\n#include <net/sock.h>\n#include \"core.h\"\n#include \"l1oip.h\"\n\nstatic const char *l1oip_revision = \"2.00\";\n\nstatic int l1oip_cnt;\nstatic DEFINE_SPINLOCK(l1oip_lock);\nstatic LIST_HEAD(l1oip_ilist);\n\n#define MAX_CARDS\t16\nstatic u_int type[MAX_CARDS];\nstatic u_int codec[MAX_CARDS];\nstatic u_int ip[MAX_CARDS * 4];\nstatic u_int port[MAX_CARDS];\nstatic u_int remoteport[MAX_CARDS];\nstatic u_int ondemand[MAX_CARDS];\nstatic u_int limit[MAX_CARDS];\nstatic u_int id[MAX_CARDS];\nstatic int debug;\nstatic int ulaw;\n\nMODULE_AUTHOR(\"Andreas Eversberg\");\nMODULE_LICENSE(\"GPL\");\nmodule_param_array(type, uint, NULL, S_IRUGO | S_IWUSR);\nmodule_param_array(codec, uint, NULL, S_IRUGO | S_IWUSR);\nmodule_param_array(ip, uint, NULL, S_IRUGO | S_IWUSR);\nmodule_param_array(port, uint, NULL, S_IRUGO | S_IWUSR);\nmodule_param_array(remoteport, uint, NULL, S_IRUGO | S_IWUSR);\nmodule_param_array(ondemand, uint, NULL, S_IRUGO | S_IWUSR);\nmodule_param_array(limit, uint, NULL, S_IRUGO | S_IWUSR);\nmodule_param_array(id, uint, NULL, S_IRUGO | S_IWUSR);\nmodule_param(ulaw, uint, S_IRUGO | S_IWUSR);\nmodule_param(debug, uint, S_IRUGO | S_IWUSR);\n\n \nstatic int\nl1oip_socket_send(struct l1oip *hc, u8 localcodec, u8 channel, u32 chanmask,\n\t\t  u16 timebase, u8 *buf, int len)\n{\n\tu8 *p;\n\tu8 frame[MAX_DFRAME_LEN_L1 + 32];\n\tstruct socket *socket = NULL;\n\n\tif (debug & DEBUG_L1OIP_MSG)\n\t\tprintk(KERN_DEBUG \"%s: sending data to socket (len = %d)\\n\",\n\t\t       __func__, len);\n\n\tp = frame;\n\n\t \n\tif (time_before(hc->keep_tl.expires, jiffies + 5 * HZ) && !hc->shutdown)\n\t\tmod_timer(&hc->keep_tl, jiffies + L1OIP_KEEPALIVE * HZ);\n\telse\n\t\thc->keep_tl.expires = jiffies + L1OIP_KEEPALIVE * HZ;\n\n\tif (debug & DEBUG_L1OIP_MSG)\n\t\tprintk(KERN_DEBUG \"%s: resetting timer\\n\", __func__);\n\n\t \n\tif (!hc->sin_remote.sin_addr.s_addr || !hc->sin_remote.sin_port) {\n\t\tif (debug & DEBUG_L1OIP_MSG)\n\t\t\tprintk(KERN_DEBUG \"%s: dropping frame, because remote \"\n\t\t\t       \"IP is not set.\\n\", __func__);\n\t\treturn len;\n\t}\n\n\t \n\t*p++ = (L1OIP_VERSION << 6)  \n\t\t| (hc->pri ? 0x20 : 0x00)  \n\t\t| (hc->id ? 0x10 : 0x00)  \n\t\t| localcodec;\n\tif (hc->id) {\n\t\t*p++ = hc->id >> 24;  \n\t\t*p++ = hc->id >> 16;\n\t\t*p++ = hc->id >> 8;\n\t\t*p++ = hc->id;\n\t}\n\t*p++ =  0x00 + channel;  \n\t*p++ = timebase >> 8;  \n\t*p++ = timebase;\n\n\tif (buf && len) {  \n\t\tif (localcodec == 1 && ulaw)\n\t\t\tl1oip_ulaw_to_alaw(buf, len, p);\n\t\telse if (localcodec == 2 && !ulaw)\n\t\t\tl1oip_alaw_to_ulaw(buf, len, p);\n\t\telse if (localcodec == 3)\n\t\t\tlen = l1oip_law_to_4bit(buf, len, p,\n\t\t\t\t\t\t&hc->chan[channel].codecstate);\n\t\telse\n\t\t\tmemcpy(p, buf, len);\n\t}\n\tlen += p - frame;\n\n\t \n\tspin_lock(&hc->socket_lock);\n\tif (!hc->socket) {\n\t\tspin_unlock(&hc->socket_lock);\n\t\treturn 0;\n\t}\n\t \n\tsocket = hc->socket;\n\thc->socket = NULL;\n\tspin_unlock(&hc->socket_lock);\n\t \n\tif (debug & DEBUG_L1OIP_MSG)\n\t\tprintk(KERN_DEBUG \"%s: sending packet to socket (len \"\n\t\t       \"= %d)\\n\", __func__, len);\n\thc->sendiov.iov_base = frame;\n\thc->sendiov.iov_len  = len;\n\tlen = kernel_sendmsg(socket, &hc->sendmsg, &hc->sendiov, 1, len);\n\t \n\thc->socket = socket;  \n\n\treturn len;\n}\n\n\n \nstatic void\nl1oip_socket_recv(struct l1oip *hc, u8 remotecodec, u8 channel, u16 timebase,\n\t\t  u8 *buf, int len)\n{\n\tstruct sk_buff *nskb;\n\tstruct bchannel *bch;\n\tstruct dchannel *dch;\n\tu8 *p;\n\tu32 rx_counter;\n\n\tif (len == 0) {\n\t\tif (debug & DEBUG_L1OIP_MSG)\n\t\t\tprintk(KERN_DEBUG \"%s: received empty keepalive data, \"\n\t\t\t       \"ignoring\\n\", __func__);\n\t\treturn;\n\t}\n\n\tif (debug & DEBUG_L1OIP_MSG)\n\t\tprintk(KERN_DEBUG \"%s: received data, sending to mISDN (%d)\\n\",\n\t\t       __func__, len);\n\n\tif (channel < 1 || channel > 127) {\n\t\tprintk(KERN_WARNING \"%s: packet error - channel %d out of \"\n\t\t       \"range\\n\", __func__, channel);\n\t\treturn;\n\t}\n\tdch = hc->chan[channel].dch;\n\tbch = hc->chan[channel].bch;\n\tif (!dch && !bch) {\n\t\tprintk(KERN_WARNING \"%s: packet error - channel %d not in \"\n\t\t       \"stack\\n\", __func__, channel);\n\t\treturn;\n\t}\n\n\t \n\tnskb = mI_alloc_skb((remotecodec == 3) ? (len << 1) : len, GFP_ATOMIC);\n\tif (!nskb) {\n\t\tprintk(KERN_ERR \"%s: No mem for skb.\\n\", __func__);\n\t\treturn;\n\t}\n\tp = skb_put(nskb, (remotecodec == 3) ? (len << 1) : len);\n\n\tif (remotecodec == 1 && ulaw)\n\t\tl1oip_alaw_to_ulaw(buf, len, p);\n\telse if (remotecodec == 2 && !ulaw)\n\t\tl1oip_ulaw_to_alaw(buf, len, p);\n\telse if (remotecodec == 3)\n\t\tlen = l1oip_4bit_to_law(buf, len, p);\n\telse\n\t\tmemcpy(p, buf, len);\n\n\t \n\tif (dch && len >= 2) {\n\t\tdch->rx_skb = nskb;\n\t\trecv_Dchannel(dch);\n\t}\n\tif (bch) {\n\t\t \n\t\trx_counter = hc->chan[channel].rx_counter;\n\t\tif (((s16)(timebase - rx_counter)) >= 0) {\n\t\t\t \n\t\t\tif (timebase >= (rx_counter & 0xffff))\n\t\t\t\trx_counter =\n\t\t\t\t\t(rx_counter & 0xffff0000) | timebase;\n\t\t\telse\n\t\t\t\trx_counter = ((rx_counter & 0xffff0000) + 0x10000)\n\t\t\t\t\t| timebase;\n\t\t} else {\n\t\t\t \n\t\t\tif (timebase < (rx_counter & 0xffff))\n\t\t\t\trx_counter =\n\t\t\t\t\t(rx_counter & 0xffff0000) | timebase;\n\t\t\telse\n\t\t\t\trx_counter = ((rx_counter & 0xffff0000) - 0x10000)\n\t\t\t\t\t| timebase;\n\t\t}\n\t\thc->chan[channel].rx_counter = rx_counter;\n\n#ifdef REORDER_DEBUG\n\t\tif (hc->chan[channel].disorder_flag) {\n\t\t\tswap(hc->chan[channel].disorder_skb, nskb);\n\t\t\tswap(hc->chan[channel].disorder_cnt, rx_counter);\n\t\t}\n\t\thc->chan[channel].disorder_flag ^= 1;\n\t\tif (nskb)\n#endif\n\t\t\tqueue_ch_frame(&bch->ch, PH_DATA_IND, rx_counter, nskb);\n\t}\n}\n\n\n \nstatic void\nl1oip_socket_parse(struct l1oip *hc, struct sockaddr_in *sin, u8 *buf, int len)\n{\n\tu32\t\t\tpacket_id;\n\tu8\t\t\tchannel;\n\tu8\t\t\tremotecodec;\n\tu16\t\t\ttimebase;\n\tint\t\t\tm, mlen;\n\tint\t\t\tlen_start = len;  \n\tstruct dchannel\t\t*dch = hc->chan[hc->d_idx].dch;\n\n\tif (debug & DEBUG_L1OIP_MSG)\n\t\tprintk(KERN_DEBUG \"%s: received frame, parsing... (%d)\\n\",\n\t\t       __func__, len);\n\n\t \n\tif (len < 1 + 1 + 2) {\n\t\tprintk(KERN_WARNING \"%s: packet error - length %d below \"\n\t\t       \"4 bytes\\n\", __func__, len);\n\t\treturn;\n\t}\n\n\t \n\tif (((*buf) >> 6) != L1OIP_VERSION) {\n\t\tprintk(KERN_WARNING \"%s: packet error - unknown version %d\\n\",\n\t\t       __func__, buf[0]>>6);\n\t\treturn;\n\t}\n\n\t \n\tif (((*buf) & 0x20) && !hc->pri) {\n\t\tprintk(KERN_WARNING \"%s: packet error - received E1 packet \"\n\t\t       \"on S0 interface\\n\", __func__);\n\t\treturn;\n\t}\n\tif (!((*buf) & 0x20) && hc->pri) {\n\t\tprintk(KERN_WARNING \"%s: packet error - received S0 packet \"\n\t\t       \"on E1 interface\\n\", __func__);\n\t\treturn;\n\t}\n\n\t \n\tpacket_id = (*buf >> 4) & 1;\n\n\t \n\tremotecodec = (*buf) & 0x0f;\n\tif (remotecodec > 3) {\n\t\tprintk(KERN_WARNING \"%s: packet error - remotecodec %d \"\n\t\t       \"unsupported\\n\", __func__, remotecodec);\n\t\treturn;\n\t}\n\tbuf++;\n\tlen--;\n\n\t \n\tif (packet_id) {\n\t\tif (!hc->id) {\n\t\t\tprintk(KERN_WARNING \"%s: packet error - packet has id \"\n\t\t\t       \"0x%x, but we have not\\n\", __func__, packet_id);\n\t\t\treturn;\n\t\t}\n\t\tif (len < 4) {\n\t\t\tprintk(KERN_WARNING \"%s: packet error - packet too \"\n\t\t\t       \"short for ID value\\n\", __func__);\n\t\t\treturn;\n\t\t}\n\t\tpacket_id = (*buf++) << 24;\n\t\tpacket_id += (*buf++) << 16;\n\t\tpacket_id += (*buf++) << 8;\n\t\tpacket_id += (*buf++);\n\t\tlen -= 4;\n\n\t\tif (packet_id != hc->id) {\n\t\t\tprintk(KERN_WARNING \"%s: packet error - ID mismatch, \"\n\t\t\t       \"got 0x%x, we 0x%x\\n\",\n\t\t\t       __func__, packet_id, hc->id);\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tif (hc->id) {\n\t\t\tprintk(KERN_WARNING \"%s: packet error - packet has no \"\n\t\t\t       \"ID, but we have\\n\", __func__);\n\t\t\treturn;\n\t\t}\n\t}\n\nmultiframe:\n\tif (len < 1) {\n\t\tprintk(KERN_WARNING \"%s: packet error - packet too short, \"\n\t\t       \"channel expected at position %d.\\n\",\n\t\t       __func__, len-len_start + 1);\n\t\treturn;\n\t}\n\n\t \n\tchannel = *buf & 0x7f;\n\tm = *buf >> 7;\n\tbuf++;\n\tlen--;\n\n\t \n\tif (m) {\n\t\tif (len < 1) {\n\t\t\tprintk(KERN_WARNING \"%s: packet error - packet too \"\n\t\t\t       \"short, length expected at position %d.\\n\",\n\t\t\t       __func__, len_start - len - 1);\n\t\t\treturn;\n\t\t}\n\n\t\tmlen = *buf++;\n\t\tlen--;\n\t\tif (mlen == 0)\n\t\t\tmlen = 256;\n\t\tif (len < mlen + 3) {\n\t\t\tprintk(KERN_WARNING \"%s: packet error - length %d at \"\n\t\t\t       \"position %d exceeds total length %d.\\n\",\n\t\t\t       __func__, mlen, len_start-len - 1, len_start);\n\t\t\treturn;\n\t\t}\n\t\tif (len == mlen + 3) {\n\t\t\tprintk(KERN_WARNING \"%s: packet error - length %d at \"\n\t\t\t       \"position %d will not allow additional \"\n\t\t\t       \"packet.\\n\",\n\t\t\t       __func__, mlen, len_start-len + 1);\n\t\t\treturn;\n\t\t}\n\t} else\n\t\tmlen = len - 2;  \n\n\tif (len < 2) {\n\t\tprintk(KERN_WARNING \"%s: packet error - packet too short, time \"\n\t\t       \"base expected at position %d.\\n\",\n\t\t       __func__, len-len_start + 1);\n\t\treturn;\n\t}\n\n\t \n\ttimebase = (*buf++) << 8;\n\ttimebase |= (*buf++);\n\tlen -= 2;\n\n\t \n\tif (!test_bit(FLG_ACTIVE, &dch->Flags)) {\n\t\tif (debug & (DEBUG_L1OIP_MSG | DEBUG_L1OIP_SOCKET))\n\t\t\tprintk(KERN_DEBUG \"%s: interface become active due to \"\n\t\t\t       \"received packet\\n\", __func__);\n\t\ttest_and_set_bit(FLG_ACTIVE, &dch->Flags);\n\t\t_queue_data(&dch->dev.D, PH_ACTIVATE_IND, MISDN_ID_ANY, 0,\n\t\t\t    NULL, GFP_ATOMIC);\n\t}\n\n\t \n\tl1oip_socket_recv(hc, remotecodec, channel, timebase, buf, mlen);\n\tbuf += mlen;\n\tlen -= mlen;\n\n\t \n\tif (m)\n\t\tgoto multiframe;\n\n\t \n\tif ((time_before(hc->timeout_tl.expires, jiffies + 5 * HZ) ||\n\t     !hc->timeout_on) &&\n\t    !hc->shutdown) {\n\t\thc->timeout_on = 1;\n\t\tmod_timer(&hc->timeout_tl, jiffies + L1OIP_TIMEOUT * HZ);\n\t} else  \n\t\thc->timeout_tl.expires = jiffies + L1OIP_TIMEOUT * HZ;\n\n\t \n\tif ((hc->sin_remote.sin_addr.s_addr != sin->sin_addr.s_addr)\n\t    || (hc->sin_remote.sin_port != sin->sin_port)) {\n\t\tif (debug & DEBUG_L1OIP_SOCKET)\n\t\t\tprintk(KERN_DEBUG \"%s: remote address changes from \"\n\t\t\t       \"0x%08x to 0x%08x (port %d to %d)\\n\", __func__,\n\t\t\t       ntohl(hc->sin_remote.sin_addr.s_addr),\n\t\t\t       ntohl(sin->sin_addr.s_addr),\n\t\t\t       ntohs(hc->sin_remote.sin_port),\n\t\t\t       ntohs(sin->sin_port));\n\t\thc->sin_remote.sin_addr.s_addr = sin->sin_addr.s_addr;\n\t\thc->sin_remote.sin_port = sin->sin_port;\n\t}\n}\n\n\n \nstatic int\nl1oip_socket_thread(void *data)\n{\n\tstruct l1oip *hc = (struct l1oip *)data;\n\tint ret = 0;\n\tstruct sockaddr_in sin_rx;\n\tstruct kvec iov;\n\tstruct msghdr msg = {.msg_name = &sin_rx,\n\t\t\t     .msg_namelen = sizeof(sin_rx)};\n\tunsigned char *recvbuf;\n\tsize_t recvbuf_size = 1500;\n\tint recvlen;\n\tstruct socket *socket = NULL;\n\tDECLARE_COMPLETION_ONSTACK(wait);\n\n\t \n\trecvbuf = kmalloc(recvbuf_size, GFP_KERNEL);\n\tif (!recvbuf) {\n\t\tprintk(KERN_ERR \"%s: Failed to alloc recvbuf.\\n\", __func__);\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\tiov.iov_base = recvbuf;\n\tiov.iov_len = recvbuf_size;\n\n\t \n\tallow_signal(SIGTERM);\n\n\t \n\tif (sock_create(PF_INET, SOCK_DGRAM, IPPROTO_UDP, &socket)) {\n\t\tprintk(KERN_ERR \"%s: Failed to create socket.\\n\", __func__);\n\t\tret = -EIO;\n\t\tgoto fail;\n\t}\n\n\t \n\thc->sin_local.sin_family = AF_INET;\n\thc->sin_local.sin_addr.s_addr = INADDR_ANY;\n\thc->sin_local.sin_port = htons((unsigned short)hc->localport);\n\n\t \n\thc->sin_remote.sin_family = AF_INET;\n\thc->sin_remote.sin_addr.s_addr = htonl(hc->remoteip);\n\thc->sin_remote.sin_port = htons((unsigned short)hc->remoteport);\n\n\t \n\tif (socket->ops->bind(socket, (struct sockaddr *)&hc->sin_local,\n\t\t\t      sizeof(hc->sin_local))) {\n\t\tprintk(KERN_ERR \"%s: Failed to bind socket to port %d.\\n\",\n\t\t       __func__, hc->localport);\n\t\tret = -EINVAL;\n\t\tgoto fail;\n\t}\n\n\t \n\tif (socket->sk == NULL) {\n\t\tprintk(KERN_ERR \"%s: socket->sk == NULL\\n\", __func__);\n\t\tret = -EIO;\n\t\tgoto fail;\n\t}\n\n\t \n\thc->sendmsg.msg_name = &hc->sin_remote;\n\thc->sendmsg.msg_namelen = sizeof(hc->sin_remote);\n\thc->sendmsg.msg_control = NULL;\n\thc->sendmsg.msg_controllen = 0;\n\n\t \n\tspin_lock(&hc->socket_lock);\n\thc->socket = socket;\n\tspin_unlock(&hc->socket_lock);\n\n\t \n\tif (debug & DEBUG_L1OIP_SOCKET)\n\t\tprintk(KERN_DEBUG \"%s: socket created and open\\n\",\n\t\t       __func__);\n\twhile (!signal_pending(current)) {\n\t\tiov_iter_kvec(&msg.msg_iter, ITER_DEST, &iov, 1, recvbuf_size);\n\t\trecvlen = sock_recvmsg(socket, &msg, 0);\n\t\tif (recvlen > 0) {\n\t\t\tl1oip_socket_parse(hc, &sin_rx, recvbuf, recvlen);\n\t\t} else {\n\t\t\tif (debug & DEBUG_L1OIP_SOCKET)\n\t\t\t\tprintk(KERN_WARNING\n\t\t\t\t       \"%s: broken pipe on socket\\n\", __func__);\n\t\t}\n\t}\n\n\t \n\tspin_lock(&hc->socket_lock);\n\t \n\twhile (!hc->socket) {\n\t\tspin_unlock(&hc->socket_lock);\n\t\tschedule_timeout(HZ / 10);\n\t\tspin_lock(&hc->socket_lock);\n\t}\n\thc->socket = NULL;\n\tspin_unlock(&hc->socket_lock);\n\n\tif (debug & DEBUG_L1OIP_SOCKET)\n\t\tprintk(KERN_DEBUG \"%s: socket thread terminating\\n\",\n\t\t       __func__);\n\nfail:\n\t \n\tkfree(recvbuf);\n\n\t \n\tif (socket)\n\t\tsock_release(socket);\n\n\t \n\tcomplete(&hc->socket_complete);\n\thc->socket_thread = NULL;  \n\n\tif (debug & DEBUG_L1OIP_SOCKET)\n\t\tprintk(KERN_DEBUG \"%s: socket thread terminated\\n\",\n\t\t       __func__);\n\treturn ret;\n}\n\nstatic void\nl1oip_socket_close(struct l1oip *hc)\n{\n\tstruct dchannel *dch = hc->chan[hc->d_idx].dch;\n\n\t \n\tif (hc->socket_thread) {\n\t\tif (debug & DEBUG_L1OIP_SOCKET)\n\t\t\tprintk(KERN_DEBUG \"%s: socket thread exists, \"\n\t\t\t       \"killing...\\n\", __func__);\n\t\tsend_sig(SIGTERM, hc->socket_thread, 0);\n\t\twait_for_completion(&hc->socket_complete);\n\t}\n\n\t \n\tif (test_bit(FLG_ACTIVE, &dch->Flags)) {\n\t\tif (debug & (DEBUG_L1OIP_MSG | DEBUG_L1OIP_SOCKET))\n\t\t\tprintk(KERN_DEBUG \"%s: interface become deactivated \"\n\t\t\t       \"due to timeout\\n\", __func__);\n\t\ttest_and_clear_bit(FLG_ACTIVE, &dch->Flags);\n\t\t_queue_data(&dch->dev.D, PH_DEACTIVATE_IND, MISDN_ID_ANY, 0,\n\t\t\t    NULL, GFP_ATOMIC);\n\t}\n}\n\nstatic int\nl1oip_socket_open(struct l1oip *hc)\n{\n\t \n\tl1oip_socket_close(hc);\n\n\tinit_completion(&hc->socket_complete);\n\n\t \n\thc->socket_thread = kthread_run(l1oip_socket_thread, hc, \"l1oip_%s\",\n\t\t\t\t\thc->name);\n\tif (IS_ERR(hc->socket_thread)) {\n\t\tint err = PTR_ERR(hc->socket_thread);\n\t\tprintk(KERN_ERR \"%s: Failed (%d) to create socket process.\\n\",\n\t\t       __func__, err);\n\t\thc->socket_thread = NULL;\n\t\tsock_release(hc->socket);\n\t\treturn err;\n\t}\n\tif (debug & DEBUG_L1OIP_SOCKET)\n\t\tprintk(KERN_DEBUG \"%s: socket thread created\\n\", __func__);\n\n\treturn 0;\n}\n\n\nstatic void\nl1oip_send_bh(struct work_struct *work)\n{\n\tstruct l1oip *hc = container_of(work, struct l1oip, workq);\n\n\tif (debug & (DEBUG_L1OIP_MSG | DEBUG_L1OIP_SOCKET))\n\t\tprintk(KERN_DEBUG \"%s: keepalive timer expired, sending empty \"\n\t\t       \"frame on dchannel\\n\", __func__);\n\n\t \n\tl1oip_socket_send(hc, 0, hc->d_idx, 0, 0, NULL, 0);\n}\n\n\n \nstatic void\nl1oip_keepalive(struct timer_list *t)\n{\n\tstruct l1oip *hc = from_timer(hc, t, keep_tl);\n\n\tschedule_work(&hc->workq);\n}\n\nstatic void\nl1oip_timeout(struct timer_list *t)\n{\n\tstruct l1oip\t\t\t*hc = from_timer(hc, t,\n\t\t\t\t\t\t\t\t  timeout_tl);\n\tstruct dchannel\t\t*dch = hc->chan[hc->d_idx].dch;\n\n\tif (debug & DEBUG_L1OIP_MSG)\n\t\tprintk(KERN_DEBUG \"%s: timeout timer expired, turn layer one \"\n\t\t       \"down.\\n\", __func__);\n\n\thc->timeout_on = 0;  \n\n\t \n\tif (test_bit(FLG_ACTIVE, &dch->Flags)) {\n\t\tif (debug & (DEBUG_L1OIP_MSG | DEBUG_L1OIP_SOCKET))\n\t\t\tprintk(KERN_DEBUG \"%s: interface become deactivated \"\n\t\t\t       \"due to timeout\\n\", __func__);\n\t\ttest_and_clear_bit(FLG_ACTIVE, &dch->Flags);\n\t\t_queue_data(&dch->dev.D, PH_DEACTIVATE_IND, MISDN_ID_ANY, 0,\n\t\t\t    NULL, GFP_ATOMIC);\n\t}\n\n\t \n\tif (hc->ondemand) {\n\t\tif (debug & DEBUG_L1OIP_MSG)\n\t\t\tprintk(KERN_DEBUG \"%s: on demand causes ip address to \"\n\t\t\t       \"be removed\\n\", __func__);\n\t\thc->sin_remote.sin_addr.s_addr = 0;\n\t}\n}\n\n\n \nstatic int\nhandle_dmsg(struct mISDNchannel *ch, struct sk_buff *skb)\n{\n\tstruct mISDNdevice\t*dev = container_of(ch, struct mISDNdevice, D);\n\tstruct dchannel\t\t*dch = container_of(dev, struct dchannel, dev);\n\tstruct l1oip\t\t\t*hc = dch->hw;\n\tstruct mISDNhead\t*hh = mISDN_HEAD_P(skb);\n\tint\t\t\tret = -EINVAL;\n\tint\t\t\tl, ll;\n\tunsigned char\t\t*p;\n\n\tswitch (hh->prim) {\n\tcase PH_DATA_REQ:\n\t\tif (skb->len < 1) {\n\t\t\tprintk(KERN_WARNING \"%s: skb too small\\n\",\n\t\t\t       __func__);\n\t\t\tbreak;\n\t\t}\n\t\tif (skb->len > MAX_DFRAME_LEN_L1 || skb->len > L1OIP_MAX_LEN) {\n\t\t\tprintk(KERN_WARNING \"%s: skb too large\\n\",\n\t\t\t       __func__);\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tp = skb->data;\n\t\tl = skb->len;\n\t\twhile (l) {\n\t\t\t \n\t\t\tll = (l < MAX_DFRAME_LEN_L1) ? l : MAX_DFRAME_LEN_L1;\n\t\t\tl1oip_socket_send(hc, 0, dch->slot, 0,\n\t\t\t\t\t  hc->chan[dch->slot].tx_counter++, p, ll);\n\t\t\tp += ll;\n\t\t\tl -= ll;\n\t\t}\n\t\tskb_trim(skb, 0);\n\t\tqueue_ch_frame(ch, PH_DATA_CNF, hh->id, skb);\n\t\treturn 0;\n\tcase PH_ACTIVATE_REQ:\n\t\tif (debug & (DEBUG_L1OIP_MSG | DEBUG_L1OIP_SOCKET))\n\t\t\tprintk(KERN_DEBUG \"%s: PH_ACTIVATE channel %d (1..%d)\\n\"\n\t\t\t       , __func__, dch->slot, hc->b_num + 1);\n\t\tskb_trim(skb, 0);\n\t\tif (test_bit(FLG_ACTIVE, &dch->Flags))\n\t\t\tqueue_ch_frame(ch, PH_ACTIVATE_IND, hh->id, skb);\n\t\telse\n\t\t\tqueue_ch_frame(ch, PH_DEACTIVATE_IND, hh->id, skb);\n\t\treturn 0;\n\tcase PH_DEACTIVATE_REQ:\n\t\tif (debug & (DEBUG_L1OIP_MSG | DEBUG_L1OIP_SOCKET))\n\t\t\tprintk(KERN_DEBUG \"%s: PH_DEACTIVATE channel %d \"\n\t\t\t       \"(1..%d)\\n\", __func__, dch->slot,\n\t\t\t       hc->b_num + 1);\n\t\tskb_trim(skb, 0);\n\t\tif (test_bit(FLG_ACTIVE, &dch->Flags))\n\t\t\tqueue_ch_frame(ch, PH_ACTIVATE_IND, hh->id, skb);\n\t\telse\n\t\t\tqueue_ch_frame(ch, PH_DEACTIVATE_IND, hh->id, skb);\n\t\treturn 0;\n\t}\n\tif (!ret)\n\t\tdev_kfree_skb(skb);\n\treturn ret;\n}\n\nstatic int\nchannel_dctrl(struct dchannel *dch, struct mISDN_ctrl_req *cq)\n{\n\tint\tret = 0;\n\tstruct l1oip\t*hc = dch->hw;\n\n\tswitch (cq->op) {\n\tcase MISDN_CTRL_GETOP:\n\t\tcq->op = MISDN_CTRL_SETPEER | MISDN_CTRL_UNSETPEER\n\t\t\t| MISDN_CTRL_GETPEER;\n\t\tbreak;\n\tcase MISDN_CTRL_SETPEER:\n\t\thc->remoteip = (u32)cq->p1;\n\t\thc->remoteport = cq->p2 & 0xffff;\n\t\thc->localport = cq->p2 >> 16;\n\t\tif (!hc->remoteport)\n\t\t\thc->remoteport = hc->localport;\n\t\tif (debug & DEBUG_L1OIP_SOCKET)\n\t\t\tprintk(KERN_DEBUG \"%s: got new ip address from user \"\n\t\t\t       \"space.\\n\", __func__);\n\t\tl1oip_socket_open(hc);\n\t\tbreak;\n\tcase MISDN_CTRL_UNSETPEER:\n\t\tif (debug & DEBUG_L1OIP_SOCKET)\n\t\t\tprintk(KERN_DEBUG \"%s: removing ip address.\\n\",\n\t\t\t       __func__);\n\t\thc->remoteip = 0;\n\t\tl1oip_socket_open(hc);\n\t\tbreak;\n\tcase MISDN_CTRL_GETPEER:\n\t\tif (debug & DEBUG_L1OIP_SOCKET)\n\t\t\tprintk(KERN_DEBUG \"%s: getting ip address.\\n\",\n\t\t\t       __func__);\n\t\tcq->p1 = hc->remoteip;\n\t\tcq->p2 = hc->remoteport | (hc->localport << 16);\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_WARNING \"%s: unknown Op %x\\n\",\n\t\t       __func__, cq->op);\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic int\nopen_dchannel(struct l1oip *hc, struct dchannel *dch, struct channel_req *rq)\n{\n\tif (debug & DEBUG_HW_OPEN)\n\t\tprintk(KERN_DEBUG \"%s: dev(%d) open from %p\\n\", __func__,\n\t\t       dch->dev.id, __builtin_return_address(0));\n\tif (rq->protocol == ISDN_P_NONE)\n\t\treturn -EINVAL;\n\tif ((dch->dev.D.protocol != ISDN_P_NONE) &&\n\t    (dch->dev.D.protocol != rq->protocol)) {\n\t\tif (debug & DEBUG_HW_OPEN)\n\t\t\tprintk(KERN_WARNING \"%s: change protocol %x to %x\\n\",\n\t\t\t       __func__, dch->dev.D.protocol, rq->protocol);\n\t}\n\tif (dch->dev.D.protocol != rq->protocol)\n\t\tdch->dev.D.protocol = rq->protocol;\n\n\tif (test_bit(FLG_ACTIVE, &dch->Flags)) {\n\t\t_queue_data(&dch->dev.D, PH_ACTIVATE_IND, MISDN_ID_ANY,\n\t\t\t    0, NULL, GFP_KERNEL);\n\t}\n\trq->ch = &dch->dev.D;\n\tif (!try_module_get(THIS_MODULE))\n\t\tprintk(KERN_WARNING \"%s:cannot get module\\n\", __func__);\n\treturn 0;\n}\n\nstatic int\nopen_bchannel(struct l1oip *hc, struct dchannel *dch, struct channel_req *rq)\n{\n\tstruct bchannel\t*bch;\n\tint\t\tch;\n\n\tif (!test_channelmap(rq->adr.channel, dch->dev.channelmap))\n\t\treturn -EINVAL;\n\tif (rq->protocol == ISDN_P_NONE)\n\t\treturn -EINVAL;\n\tch = rq->adr.channel;  \n\tbch = hc->chan[ch].bch;\n\tif (!bch) {\n\t\tprintk(KERN_ERR \"%s:internal error ch %d has no bch\\n\",\n\t\t       __func__, ch);\n\t\treturn -EINVAL;\n\t}\n\tif (test_and_set_bit(FLG_OPEN, &bch->Flags))\n\t\treturn -EBUSY;  \n\tbch->ch.protocol = rq->protocol;\n\trq->ch = &bch->ch;\n\tif (!try_module_get(THIS_MODULE))\n\t\tprintk(KERN_WARNING \"%s:cannot get module\\n\", __func__);\n\treturn 0;\n}\n\nstatic int\nl1oip_dctrl(struct mISDNchannel *ch, u_int cmd, void *arg)\n{\n\tstruct mISDNdevice\t*dev = container_of(ch, struct mISDNdevice, D);\n\tstruct dchannel\t\t*dch = container_of(dev, struct dchannel, dev);\n\tstruct l1oip\t\t\t*hc = dch->hw;\n\tstruct channel_req\t*rq;\n\tint\t\t\terr = 0;\n\n\tif (dch->debug & DEBUG_HW)\n\t\tprintk(KERN_DEBUG \"%s: cmd:%x %p\\n\",\n\t\t       __func__, cmd, arg);\n\tswitch (cmd) {\n\tcase OPEN_CHANNEL:\n\t\trq = arg;\n\t\tswitch (rq->protocol) {\n\t\tcase ISDN_P_TE_S0:\n\t\tcase ISDN_P_NT_S0:\n\t\t\tif (hc->pri) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\terr = open_dchannel(hc, dch, rq);\n\t\t\tbreak;\n\t\tcase ISDN_P_TE_E1:\n\t\tcase ISDN_P_NT_E1:\n\t\t\tif (!hc->pri) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\terr = open_dchannel(hc, dch, rq);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = open_bchannel(hc, dch, rq);\n\t\t}\n\t\tbreak;\n\tcase CLOSE_CHANNEL:\n\t\tif (debug & DEBUG_HW_OPEN)\n\t\t\tprintk(KERN_DEBUG \"%s: dev(%d) close from %p\\n\",\n\t\t\t       __func__, dch->dev.id,\n\t\t\t       __builtin_return_address(0));\n\t\tmodule_put(THIS_MODULE);\n\t\tbreak;\n\tcase CONTROL_CHANNEL:\n\t\terr = channel_dctrl(dch, arg);\n\t\tbreak;\n\tdefault:\n\t\tif (dch->debug & DEBUG_HW)\n\t\t\tprintk(KERN_DEBUG \"%s: unknown command %x\\n\",\n\t\t\t       __func__, cmd);\n\t\terr = -EINVAL;\n\t}\n\treturn err;\n}\n\nstatic int\nhandle_bmsg(struct mISDNchannel *ch, struct sk_buff *skb)\n{\n\tstruct bchannel\t\t*bch = container_of(ch, struct bchannel, ch);\n\tstruct l1oip\t\t\t*hc = bch->hw;\n\tint\t\t\tret = -EINVAL;\n\tstruct mISDNhead\t*hh = mISDN_HEAD_P(skb);\n\tint\t\t\tl, ll;\n\tunsigned char\t\t*p;\n\n\tswitch (hh->prim) {\n\tcase PH_DATA_REQ:\n\t\tif (skb->len <= 0) {\n\t\t\tprintk(KERN_WARNING \"%s: skb too small\\n\",\n\t\t\t       __func__);\n\t\t\tbreak;\n\t\t}\n\t\tif (skb->len > MAX_DFRAME_LEN_L1 || skb->len > L1OIP_MAX_LEN) {\n\t\t\tprintk(KERN_WARNING \"%s: skb too large\\n\",\n\t\t\t       __func__);\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tl = skb->len;\n\t\tif (!memchr_inv(skb->data, 0xff, l)) {\n\t\t\tif (debug & DEBUG_L1OIP_MSG)\n\t\t\t\tprintk(KERN_DEBUG \"%s: got AIS, not sending, \"\n\t\t\t\t       \"but counting\\n\", __func__);\n\t\t\thc->chan[bch->slot].tx_counter += l;\n\t\t\tskb_trim(skb, 0);\n\t\t\tqueue_ch_frame(ch, PH_DATA_CNF, hh->id, skb);\n\t\t\treturn 0;\n\t\t}\n\t\t \n\t\tl = skb->len;\n\t\tif (!memchr_inv(skb->data, 0x2a, l)) {\n\t\t\tif (debug & DEBUG_L1OIP_MSG)\n\t\t\t\tprintk(KERN_DEBUG \"%s: got silence, not sending\"\n\t\t\t\t       \", but counting\\n\", __func__);\n\t\t\thc->chan[bch->slot].tx_counter += l;\n\t\t\tskb_trim(skb, 0);\n\t\t\tqueue_ch_frame(ch, PH_DATA_CNF, hh->id, skb);\n\t\t\treturn 0;\n\t\t}\n\n\t\t \n\t\tp = skb->data;\n\t\tl = skb->len;\n\t\twhile (l) {\n\t\t\t \n\t\t\tll = (l < MAX_DFRAME_LEN_L1) ? l : MAX_DFRAME_LEN_L1;\n\t\t\tl1oip_socket_send(hc, hc->codec, bch->slot, 0,\n\t\t\t\t\t  hc->chan[bch->slot].tx_counter, p, ll);\n\t\t\thc->chan[bch->slot].tx_counter += ll;\n\t\t\tp += ll;\n\t\t\tl -= ll;\n\t\t}\n\t\tskb_trim(skb, 0);\n\t\tqueue_ch_frame(ch, PH_DATA_CNF, hh->id, skb);\n\t\treturn 0;\n\tcase PH_ACTIVATE_REQ:\n\t\tif (debug & (DEBUG_L1OIP_MSG | DEBUG_L1OIP_SOCKET))\n\t\t\tprintk(KERN_DEBUG \"%s: PH_ACTIVATE channel %d (1..%d)\\n\"\n\t\t\t       , __func__, bch->slot, hc->b_num + 1);\n\t\thc->chan[bch->slot].codecstate = 0;\n\t\ttest_and_set_bit(FLG_ACTIVE, &bch->Flags);\n\t\tskb_trim(skb, 0);\n\t\tqueue_ch_frame(ch, PH_ACTIVATE_IND, hh->id, skb);\n\t\treturn 0;\n\tcase PH_DEACTIVATE_REQ:\n\t\tif (debug & (DEBUG_L1OIP_MSG | DEBUG_L1OIP_SOCKET))\n\t\t\tprintk(KERN_DEBUG \"%s: PH_DEACTIVATE channel %d \"\n\t\t\t       \"(1..%d)\\n\", __func__, bch->slot,\n\t\t\t       hc->b_num + 1);\n\t\ttest_and_clear_bit(FLG_ACTIVE, &bch->Flags);\n\t\tskb_trim(skb, 0);\n\t\tqueue_ch_frame(ch, PH_DEACTIVATE_IND, hh->id, skb);\n\t\treturn 0;\n\t}\n\tif (!ret)\n\t\tdev_kfree_skb(skb);\n\treturn ret;\n}\n\nstatic int\nchannel_bctrl(struct bchannel *bch, struct mISDN_ctrl_req *cq)\n{\n\tint\t\t\tret = 0;\n\tstruct dsp_features\t*features =\n\t\t(struct dsp_features *)(*((u_long *)&cq->p1));\n\n\tswitch (cq->op) {\n\tcase MISDN_CTRL_GETOP:\n\t\tcq->op = MISDN_CTRL_HW_FEATURES_OP;\n\t\tbreak;\n\tcase MISDN_CTRL_HW_FEATURES:  \n\t\tif (debug & DEBUG_L1OIP_MSG)\n\t\t\tprintk(KERN_DEBUG \"%s: HW_FEATURE request\\n\",\n\t\t\t       __func__);\n\t\t \n\t\tfeatures->unclocked = 1;\n\t\tfeatures->unordered = 1;\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_WARNING \"%s: unknown Op %x\\n\",\n\t\t       __func__, cq->op);\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic int\nl1oip_bctrl(struct mISDNchannel *ch, u_int cmd, void *arg)\n{\n\tstruct bchannel\t*bch = container_of(ch, struct bchannel, ch);\n\tint\t\terr = -EINVAL;\n\n\tif (bch->debug & DEBUG_HW)\n\t\tprintk(KERN_DEBUG \"%s: cmd:%x %p\\n\",\n\t\t       __func__, cmd, arg);\n\tswitch (cmd) {\n\tcase CLOSE_CHANNEL:\n\t\ttest_and_clear_bit(FLG_OPEN, &bch->Flags);\n\t\ttest_and_clear_bit(FLG_ACTIVE, &bch->Flags);\n\t\tch->protocol = ISDN_P_NONE;\n\t\tch->peer = NULL;\n\t\tmodule_put(THIS_MODULE);\n\t\terr = 0;\n\t\tbreak;\n\tcase CONTROL_CHANNEL:\n\t\terr = channel_bctrl(bch, arg);\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_WARNING \"%s: unknown prim(%x)\\n\",\n\t\t       __func__, cmd);\n\t}\n\treturn err;\n}\n\n\n \nstatic void\nrelease_card(struct l1oip *hc)\n{\n\tint\tch;\n\n\thc->shutdown = true;\n\n\ttimer_shutdown_sync(&hc->keep_tl);\n\ttimer_shutdown_sync(&hc->timeout_tl);\n\n\tcancel_work_sync(&hc->workq);\n\n\tif (hc->socket_thread)\n\t\tl1oip_socket_close(hc);\n\n\tif (hc->registered && hc->chan[hc->d_idx].dch)\n\t\tmISDN_unregister_device(&hc->chan[hc->d_idx].dch->dev);\n\tfor (ch = 0; ch < 128; ch++) {\n\t\tif (hc->chan[ch].dch) {\n\t\t\tmISDN_freedchannel(hc->chan[ch].dch);\n\t\t\tkfree(hc->chan[ch].dch);\n\t\t}\n\t\tif (hc->chan[ch].bch) {\n\t\t\tmISDN_freebchannel(hc->chan[ch].bch);\n\t\t\tkfree(hc->chan[ch].bch);\n#ifdef REORDER_DEBUG\n\t\t\tdev_kfree_skb(hc->chan[ch].disorder_skb);\n#endif\n\t\t}\n\t}\n\n\tspin_lock(&l1oip_lock);\n\tlist_del(&hc->list);\n\tspin_unlock(&l1oip_lock);\n\n\tkfree(hc);\n}\n\nstatic void\nl1oip_cleanup(void)\n{\n\tstruct l1oip *hc, *next;\n\n\tlist_for_each_entry_safe(hc, next, &l1oip_ilist, list)\n\t\trelease_card(hc);\n\n\tl1oip_4bit_free();\n}\n\n\n \nstatic int\ninit_card(struct l1oip *hc, int pri, int bundle)\n{\n\tstruct dchannel\t*dch;\n\tstruct bchannel\t*bch;\n\tint\t\tret;\n\tint\t\ti, ch;\n\n\tspin_lock_init(&hc->socket_lock);\n\thc->idx = l1oip_cnt;\n\thc->pri = pri;\n\thc->d_idx = pri ? 16 : 3;\n\thc->b_num = pri ? 30 : 2;\n\thc->bundle = bundle;\n\tif (hc->pri)\n\t\tsprintf(hc->name, \"l1oip-e1.%d\", l1oip_cnt + 1);\n\telse\n\t\tsprintf(hc->name, \"l1oip-s0.%d\", l1oip_cnt + 1);\n\n\tswitch (codec[l1oip_cnt]) {\n\tcase 0:  \n\tcase 1:  \n\tcase 2:  \n\tcase 3:  \n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_ERR \"Codec(%d) not supported.\\n\",\n\t\t       codec[l1oip_cnt]);\n\t\treturn -EINVAL;\n\t}\n\thc->codec = codec[l1oip_cnt];\n\tif (debug & DEBUG_L1OIP_INIT)\n\t\tprintk(KERN_DEBUG \"%s: using codec %d\\n\",\n\t\t       __func__, hc->codec);\n\n\tif (id[l1oip_cnt] == 0) {\n\t\tprintk(KERN_WARNING \"Warning: No 'id' value given or \"\n\t\t       \"0, this is highly unsecure. Please use 32 \"\n\t\t       \"bit random number 0x...\\n\");\n\t}\n\thc->id = id[l1oip_cnt];\n\tif (debug & DEBUG_L1OIP_INIT)\n\t\tprintk(KERN_DEBUG \"%s: using id 0x%x\\n\", __func__, hc->id);\n\n\thc->ondemand = ondemand[l1oip_cnt];\n\tif (hc->ondemand && !hc->id) {\n\t\tprintk(KERN_ERR \"%s: ondemand option only allowed in \"\n\t\t       \"conjunction with non 0 ID\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tif (limit[l1oip_cnt])\n\t\thc->b_num = limit[l1oip_cnt];\n\tif (!pri && hc->b_num > 2) {\n\t\tprintk(KERN_ERR \"Maximum limit for BRI interface is 2 \"\n\t\t       \"channels.\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (pri && hc->b_num > 126) {\n\t\tprintk(KERN_ERR \"Maximum limit for PRI interface is 126 \"\n\t\t       \"channels.\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (pri && hc->b_num > 30) {\n\t\tprintk(KERN_WARNING \"Maximum limit for BRI interface is 30 \"\n\t\t       \"channels.\\n\");\n\t\tprintk(KERN_WARNING \"Your selection of %d channels must be \"\n\t\t       \"supported by application.\\n\", hc->limit);\n\t}\n\n\thc->remoteip = ip[l1oip_cnt << 2] << 24\n\t\t| ip[(l1oip_cnt << 2) + 1] << 16\n\t\t| ip[(l1oip_cnt << 2) + 2] << 8\n\t\t| ip[(l1oip_cnt << 2) + 3];\n\thc->localport = port[l1oip_cnt]?:(L1OIP_DEFAULTPORT + l1oip_cnt);\n\tif (remoteport[l1oip_cnt])\n\t\thc->remoteport = remoteport[l1oip_cnt];\n\telse\n\t\thc->remoteport = hc->localport;\n\tif (debug & DEBUG_L1OIP_INIT)\n\t\tprintk(KERN_DEBUG \"%s: using local port %d remote ip \"\n\t\t       \"%d.%d.%d.%d port %d ondemand %d\\n\", __func__,\n\t\t       hc->localport, hc->remoteip >> 24,\n\t\t       (hc->remoteip >> 16) & 0xff,\n\t\t       (hc->remoteip >> 8) & 0xff, hc->remoteip & 0xff,\n\t\t       hc->remoteport, hc->ondemand);\n\n\tdch = kzalloc(sizeof(struct dchannel), GFP_KERNEL);\n\tif (!dch)\n\t\treturn -ENOMEM;\n\tdch->debug = debug;\n\tmISDN_initdchannel(dch, MAX_DFRAME_LEN_L1, NULL);\n\tdch->hw = hc;\n\tif (pri)\n\t\tdch->dev.Dprotocols = (1 << ISDN_P_TE_E1) | (1 << ISDN_P_NT_E1);\n\telse\n\t\tdch->dev.Dprotocols = (1 << ISDN_P_TE_S0) | (1 << ISDN_P_NT_S0);\n\tdch->dev.Bprotocols = (1 << (ISDN_P_B_RAW & ISDN_P_B_MASK)) |\n\t\t(1 << (ISDN_P_B_HDLC & ISDN_P_B_MASK));\n\tdch->dev.D.send = handle_dmsg;\n\tdch->dev.D.ctrl = l1oip_dctrl;\n\tdch->dev.nrbchan = hc->b_num;\n\tdch->slot = hc->d_idx;\n\thc->chan[hc->d_idx].dch = dch;\n\ti = 1;\n\tfor (ch = 0; ch < dch->dev.nrbchan; ch++) {\n\t\tif (ch == 15)\n\t\t\ti++;\n\t\tbch = kzalloc(sizeof(struct bchannel), GFP_KERNEL);\n\t\tif (!bch) {\n\t\t\tprintk(KERN_ERR \"%s: no memory for bchannel\\n\",\n\t\t\t       __func__);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tbch->nr = i + ch;\n\t\tbch->slot = i + ch;\n\t\tbch->debug = debug;\n\t\tmISDN_initbchannel(bch, MAX_DATA_MEM, 0);\n\t\tbch->hw = hc;\n\t\tbch->ch.send = handle_bmsg;\n\t\tbch->ch.ctrl = l1oip_bctrl;\n\t\tbch->ch.nr = i + ch;\n\t\tlist_add(&bch->ch.list, &dch->dev.bchannels);\n\t\thc->chan[i + ch].bch = bch;\n\t\tset_channelmap(bch->nr, dch->dev.channelmap);\n\t}\n\t \n\tret = mISDN_register_device(&dch->dev, NULL, hc->name);\n\tif (ret)\n\t\treturn ret;\n\thc->registered = 1;\n\n\tif (debug & DEBUG_L1OIP_INIT)\n\t\tprintk(KERN_DEBUG \"%s: Setting up network card(%d)\\n\",\n\t\t       __func__, l1oip_cnt + 1);\n\tret = l1oip_socket_open(hc);\n\tif (ret)\n\t\treturn ret;\n\n\ttimer_setup(&hc->keep_tl, l1oip_keepalive, 0);\n\thc->keep_tl.expires = jiffies + 2 * HZ;  \n\tadd_timer(&hc->keep_tl);\n\n\ttimer_setup(&hc->timeout_tl, l1oip_timeout, 0);\n\thc->timeout_on = 0;  \n\n\treturn 0;\n}\n\nstatic int __init\nl1oip_init(void)\n{\n\tint\t\tpri, bundle;\n\tstruct l1oip\t\t*hc;\n\tint\t\tret;\n\n\tprintk(KERN_INFO \"mISDN: Layer-1-over-IP driver Rev. %s\\n\",\n\t       l1oip_revision);\n\n\tif (l1oip_4bit_alloc(ulaw))\n\t\treturn -ENOMEM;\n\n\tl1oip_cnt = 0;\n\twhile (l1oip_cnt < MAX_CARDS && type[l1oip_cnt]) {\n\t\tswitch (type[l1oip_cnt] & 0xff) {\n\t\tcase 1:\n\t\t\tpri = 0;\n\t\t\tbundle = 0;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tpri = 1;\n\t\t\tbundle = 0;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tpri = 0;\n\t\t\tbundle = 1;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tpri = 1;\n\t\t\tbundle = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintk(KERN_ERR \"Card type(%d) not supported.\\n\",\n\t\t\t       type[l1oip_cnt] & 0xff);\n\t\t\tl1oip_cleanup();\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (debug & DEBUG_L1OIP_INIT)\n\t\t\tprintk(KERN_DEBUG \"%s: interface %d is %s with %s.\\n\",\n\t\t\t       __func__, l1oip_cnt, pri ? \"PRI\" : \"BRI\",\n\t\t\t       bundle ? \"bundled IP packet for all B-channels\" :\n\t\t\t       \"separate IP packets for every B-channel\");\n\n\t\thc = kzalloc(sizeof(struct l1oip), GFP_ATOMIC);\n\t\tif (!hc) {\n\t\t\tprintk(KERN_ERR \"No kmem for L1-over-IP driver.\\n\");\n\t\t\tl1oip_cleanup();\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tINIT_WORK(&hc->workq, (void *)l1oip_send_bh);\n\n\t\tspin_lock(&l1oip_lock);\n\t\tlist_add_tail(&hc->list, &l1oip_ilist);\n\t\tspin_unlock(&l1oip_lock);\n\n\t\tret = init_card(hc, pri, bundle);\n\t\tif (ret) {\n\t\t\tl1oip_cleanup();\n\t\t\treturn ret;\n\t\t}\n\n\t\tl1oip_cnt++;\n\t}\n\tprintk(KERN_INFO \"%d virtual devices registered\\n\", l1oip_cnt);\n\treturn 0;\n}\n\nmodule_init(l1oip_init);\nmodule_exit(l1oip_cleanup);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}