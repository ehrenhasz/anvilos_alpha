{
  "module_name": "clock.c",
  "hash_id": "fe34359b02594dd110b9b00821902aea2e0bd142522bc837a7fddb40082006eb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/isdn/mISDN/clock.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/stddef.h>\n#include <linux/spinlock.h>\n#include <linux/ktime.h>\n#include <linux/mISDNif.h>\n#include <linux/export.h>\n#include \"core.h\"\n\nstatic u_int *debug;\nstatic LIST_HEAD(iclock_list);\nstatic DEFINE_RWLOCK(iclock_lock);\nstatic u16 iclock_count;\t\t \nstatic ktime_t iclock_timestamp;\t \nstatic int iclock_timestamp_valid;\t \nstatic struct mISDNclock *iclock_current;\n\nvoid\nmISDN_init_clock(u_int *dp)\n{\n\tdebug = dp;\n\ticlock_timestamp = ktime_get();\n}\n\nstatic void\nselect_iclock(void)\n{\n\tstruct mISDNclock *iclock, *bestclock = NULL, *lastclock = NULL;\n\tint pri = -128;\n\n\tlist_for_each_entry(iclock, &iclock_list, list) {\n\t\tif (iclock->pri > pri) {\n\t\t\tpri = iclock->pri;\n\t\t\tbestclock = iclock;\n\t\t}\n\t\tif (iclock_current == iclock)\n\t\t\tlastclock = iclock;\n\t}\n\tif (lastclock && bestclock != lastclock) {\n\t\t \n\t\tif (*debug & DEBUG_CLOCK)\n\t\t\tprintk(KERN_DEBUG \"Old clock source '%s' disable.\\n\",\n\t\t\t       lastclock->name);\n\t\tlastclock->ctl(lastclock->priv, 0);\n\t}\n\tif (bestclock && bestclock != iclock_current) {\n\t\t \n\t\tif (*debug & DEBUG_CLOCK)\n\t\t\tprintk(KERN_DEBUG \"New clock source '%s' enable.\\n\",\n\t\t\t       bestclock->name);\n\t\tbestclock->ctl(bestclock->priv, 1);\n\t}\n\tif (bestclock != iclock_current) {\n\t\t \n\t\ticlock_timestamp_valid = 0;\n\t}\n\ticlock_current = bestclock;\n}\n\nstruct mISDNclock\n*mISDN_register_clock(char *name, int pri, clockctl_func_t *ctl, void *priv)\n{\n\tu_long\t\t\tflags;\n\tstruct mISDNclock\t*iclock;\n\n\tif (*debug & (DEBUG_CORE | DEBUG_CLOCK))\n\t\tprintk(KERN_DEBUG \"%s: %s %d\\n\", __func__, name, pri);\n\ticlock = kzalloc(sizeof(struct mISDNclock), GFP_ATOMIC);\n\tif (!iclock) {\n\t\tprintk(KERN_ERR \"%s: No memory for clock entry.\\n\", __func__);\n\t\treturn NULL;\n\t}\n\tstrncpy(iclock->name, name, sizeof(iclock->name) - 1);\n\ticlock->pri = pri;\n\ticlock->priv = priv;\n\ticlock->ctl = ctl;\n\twrite_lock_irqsave(&iclock_lock, flags);\n\tlist_add_tail(&iclock->list, &iclock_list);\n\tselect_iclock();\n\twrite_unlock_irqrestore(&iclock_lock, flags);\n\treturn iclock;\n}\nEXPORT_SYMBOL(mISDN_register_clock);\n\nvoid\nmISDN_unregister_clock(struct mISDNclock *iclock)\n{\n\tu_long\tflags;\n\n\tif (*debug & (DEBUG_CORE | DEBUG_CLOCK))\n\t\tprintk(KERN_DEBUG \"%s: %s %d\\n\", __func__, iclock->name,\n\t\t       iclock->pri);\n\twrite_lock_irqsave(&iclock_lock, flags);\n\tif (iclock_current == iclock) {\n\t\tif (*debug & DEBUG_CLOCK)\n\t\t\tprintk(KERN_DEBUG\n\t\t\t       \"Current clock source '%s' unregisters.\\n\",\n\t\t\t       iclock->name);\n\t\ticlock->ctl(iclock->priv, 0);\n\t}\n\tlist_del(&iclock->list);\n\tselect_iclock();\n\twrite_unlock_irqrestore(&iclock_lock, flags);\n}\nEXPORT_SYMBOL(mISDN_unregister_clock);\n\nvoid\nmISDN_clock_update(struct mISDNclock *iclock, int samples, ktime_t *timestamp)\n{\n\tu_long\t\tflags;\n\tktime_t\t\ttimestamp_now;\n\tu16\t\tdelta;\n\n\twrite_lock_irqsave(&iclock_lock, flags);\n\tif (iclock_current != iclock) {\n\t\tprintk(KERN_ERR \"%s: '%s' sends us clock updates, but we do \"\n\t\t       \"listen to '%s'. This is a bug!\\n\", __func__,\n\t\t       iclock->name,\n\t\t       iclock_current ? iclock_current->name : \"nothing\");\n\t\ticlock->ctl(iclock->priv, 0);\n\t\twrite_unlock_irqrestore(&iclock_lock, flags);\n\t\treturn;\n\t}\n\tif (iclock_timestamp_valid) {\n\t\t \n\t\ticlock_count += samples;\n\t\tif (timestamp) {  \n\t\t\ticlock_timestamp = *timestamp;\n\t\t} else\t{\n\t\t\ticlock_timestamp = ktime_get();\n\t\t}\n\t} else {\n\t\t \n\t\tif (timestamp) {  \n\t\t\ttimestamp_now = *timestamp;\n\t\t} else {\n\t\t\ttimestamp_now = ktime_get();\n\t\t}\n\t\tdelta = ktime_divns(ktime_sub(timestamp_now, iclock_timestamp),\n\t\t\t\t(NSEC_PER_SEC / 8000));\n\t\t \n\t\ticlock_count += delta;\n\t\ticlock_timestamp = timestamp_now;\n\t\ticlock_timestamp_valid = 1;\n\t\tif (*debug & DEBUG_CLOCK)\n\t\t\tprintk(\"Received first clock from source '%s'.\\n\",\n\t\t\t       iclock_current ? iclock_current->name : \"nothing\");\n\t}\n\twrite_unlock_irqrestore(&iclock_lock, flags);\n}\nEXPORT_SYMBOL(mISDN_clock_update);\n\nunsigned short\nmISDN_clock_get(void)\n{\n\tu_long\t\tflags;\n\tktime_t\t\ttimestamp_now;\n\tu16\t\tdelta;\n\tu16\t\tcount;\n\n\tread_lock_irqsave(&iclock_lock, flags);\n\t \n\ttimestamp_now = ktime_get();\n\tdelta = ktime_divns(ktime_sub(timestamp_now, iclock_timestamp),\n\t\t\t(NSEC_PER_SEC / 8000));\n\t \n\tcount =\ticlock_count + delta;\n\tread_unlock_irqrestore(&iclock_lock, flags);\n\treturn count;\n}\nEXPORT_SYMBOL(mISDN_clock_get);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}