{
  "module_name": "socket.c",
  "hash_id": "4b085fe00d7b0ccb40c5019439c8581e7053aa25dc066956fd8176500def6fda",
  "original_prompt": "Ingested from linux-6.6.14/drivers/isdn/mISDN/socket.c",
  "human_readable_source": "\n \n\n#include <linux/mISDNif.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include \"core.h\"\n\nstatic u_int\t*debug;\n\nstatic struct proto mISDN_proto = {\n\t.name\t\t= \"misdn\",\n\t.owner\t\t= THIS_MODULE,\n\t.obj_size\t= sizeof(struct mISDN_sock)\n};\n\n#define _pms(sk)\t((struct mISDN_sock *)sk)\n\nstatic struct mISDN_sock_list\tdata_sockets = {\n\t.lock = __RW_LOCK_UNLOCKED(data_sockets.lock)\n};\n\nstatic struct mISDN_sock_list\tbase_sockets = {\n\t.lock = __RW_LOCK_UNLOCKED(base_sockets.lock)\n};\n\n#define L2_HEADER_LEN\t4\n\nstatic inline struct sk_buff *\n_l2_alloc_skb(unsigned int len, gfp_t gfp_mask)\n{\n\tstruct sk_buff  *skb;\n\n\tskb = alloc_skb(len + L2_HEADER_LEN, gfp_mask);\n\tif (likely(skb))\n\t\tskb_reserve(skb, L2_HEADER_LEN);\n\treturn skb;\n}\n\nstatic void\nmISDN_sock_link(struct mISDN_sock_list *l, struct sock *sk)\n{\n\twrite_lock_bh(&l->lock);\n\tsk_add_node(sk, &l->head);\n\twrite_unlock_bh(&l->lock);\n}\n\nstatic void mISDN_sock_unlink(struct mISDN_sock_list *l, struct sock *sk)\n{\n\twrite_lock_bh(&l->lock);\n\tsk_del_node_init(sk);\n\twrite_unlock_bh(&l->lock);\n}\n\nstatic int\nmISDN_send(struct mISDNchannel *ch, struct sk_buff *skb)\n{\n\tstruct mISDN_sock *msk;\n\tint\terr;\n\n\tmsk = container_of(ch, struct mISDN_sock, ch);\n\tif (*debug & DEBUG_SOCKET)\n\t\tprintk(KERN_DEBUG \"%s len %d %p\\n\", __func__, skb->len, skb);\n\tif (msk->sk.sk_state == MISDN_CLOSED)\n\t\treturn -EUNATCH;\n\t__net_timestamp(skb);\n\terr = sock_queue_rcv_skb(&msk->sk, skb);\n\tif (err)\n\t\tprintk(KERN_WARNING \"%s: error %d\\n\", __func__, err);\n\treturn err;\n}\n\nstatic int\nmISDN_ctrl(struct mISDNchannel *ch, u_int cmd, void *arg)\n{\n\tstruct mISDN_sock *msk;\n\n\tmsk = container_of(ch, struct mISDN_sock, ch);\n\tif (*debug & DEBUG_SOCKET)\n\t\tprintk(KERN_DEBUG \"%s(%p, %x, %p)\\n\", __func__, ch, cmd, arg);\n\tswitch (cmd) {\n\tcase CLOSE_CHANNEL:\n\t\tmsk->sk.sk_state = MISDN_CLOSED;\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic inline void\nmISDN_sock_cmsg(struct sock *sk, struct msghdr *msg, struct sk_buff *skb)\n{\n\tstruct __kernel_old_timeval\ttv;\n\n\tif (_pms(sk)->cmask & MISDN_TIME_STAMP) {\n\t\tskb_get_timestamp(skb, &tv);\n\t\tput_cmsg(msg, SOL_MISDN, MISDN_TIME_STAMP, sizeof(tv), &tv);\n\t}\n}\n\nstatic int\nmISDN_sock_recvmsg(struct socket *sock, struct msghdr *msg, size_t len,\n\t\t   int flags)\n{\n\tstruct sk_buff\t\t*skb;\n\tstruct sock\t\t*sk = sock->sk;\n\n\tint\t\tcopied, err;\n\n\tif (*debug & DEBUG_SOCKET)\n\t\tprintk(KERN_DEBUG \"%s: len %d, flags %x ch.nr %d, proto %x\\n\",\n\t\t       __func__, (int)len, flags, _pms(sk)->ch.nr,\n\t\t       sk->sk_protocol);\n\tif (flags & (MSG_OOB))\n\t\treturn -EOPNOTSUPP;\n\n\tif (sk->sk_state == MISDN_CLOSED)\n\t\treturn 0;\n\n\tskb = skb_recv_datagram(sk, flags, &err);\n\tif (!skb)\n\t\treturn err;\n\n\tif (msg->msg_name) {\n\t\tDECLARE_SOCKADDR(struct sockaddr_mISDN *, maddr, msg->msg_name);\n\n\t\tmaddr->family = AF_ISDN;\n\t\tmaddr->dev = _pms(sk)->dev->id;\n\t\tif ((sk->sk_protocol == ISDN_P_LAPD_TE) ||\n\t\t    (sk->sk_protocol == ISDN_P_LAPD_NT)) {\n\t\t\tmaddr->channel = (mISDN_HEAD_ID(skb) >> 16) & 0xff;\n\t\t\tmaddr->tei =  (mISDN_HEAD_ID(skb) >> 8) & 0xff;\n\t\t\tmaddr->sapi = mISDN_HEAD_ID(skb) & 0xff;\n\t\t} else {\n\t\t\tmaddr->channel = _pms(sk)->ch.nr;\n\t\t\tmaddr->sapi = _pms(sk)->ch.addr & 0xFF;\n\t\t\tmaddr->tei =  (_pms(sk)->ch.addr >> 8) & 0xFF;\n\t\t}\n\t\tmsg->msg_namelen = sizeof(*maddr);\n\t}\n\n\tcopied = skb->len + MISDN_HEADER_LEN;\n\tif (len < copied) {\n\t\tif (flags & MSG_PEEK)\n\t\t\trefcount_dec(&skb->users);\n\t\telse\n\t\t\tskb_queue_head(&sk->sk_receive_queue, skb);\n\t\treturn -ENOSPC;\n\t}\n\tmemcpy(skb_push(skb, MISDN_HEADER_LEN), mISDN_HEAD_P(skb),\n\t       MISDN_HEADER_LEN);\n\n\terr = skb_copy_datagram_msg(skb, 0, msg, copied);\n\n\tmISDN_sock_cmsg(sk, msg, skb);\n\n\tskb_free_datagram(sk, skb);\n\n\treturn err ? : copied;\n}\n\nstatic int\nmISDN_sock_sendmsg(struct socket *sock, struct msghdr *msg, size_t len)\n{\n\tstruct sock\t\t*sk = sock->sk;\n\tstruct sk_buff\t\t*skb;\n\tint\t\t\terr = -ENOMEM;\n\n\tif (*debug & DEBUG_SOCKET)\n\t\tprintk(KERN_DEBUG \"%s: len %d flags %x ch %d proto %x\\n\",\n\t\t       __func__, (int)len, msg->msg_flags, _pms(sk)->ch.nr,\n\t\t       sk->sk_protocol);\n\n\tif (msg->msg_flags & MSG_OOB)\n\t\treturn -EOPNOTSUPP;\n\n\tif (msg->msg_flags & ~(MSG_DONTWAIT | MSG_NOSIGNAL | MSG_ERRQUEUE))\n\t\treturn -EINVAL;\n\n\tif (len < MISDN_HEADER_LEN)\n\t\treturn -EINVAL;\n\n\tif (sk->sk_state != MISDN_BOUND)\n\t\treturn -EBADFD;\n\n\tlock_sock(sk);\n\n\tskb = _l2_alloc_skb(len, GFP_KERNEL);\n\tif (!skb)\n\t\tgoto done;\n\n\tif (memcpy_from_msg(skb_put(skb, len), msg, len)) {\n\t\terr = -EFAULT;\n\t\tgoto done;\n\t}\n\n\tmemcpy(mISDN_HEAD_P(skb), skb->data, MISDN_HEADER_LEN);\n\tskb_pull(skb, MISDN_HEADER_LEN);\n\n\tif (msg->msg_namelen >= sizeof(struct sockaddr_mISDN)) {\n\t\t \n\t\tDECLARE_SOCKADDR(struct sockaddr_mISDN *, maddr, msg->msg_name);\n\t\tmISDN_HEAD_ID(skb) = maddr->channel;\n\t} else {  \n\t\tif ((sk->sk_protocol == ISDN_P_LAPD_TE) ||\n\t\t    (sk->sk_protocol == ISDN_P_LAPD_NT))\n\t\t\tmISDN_HEAD_ID(skb) = _pms(sk)->ch.nr;\n\t}\n\n\tif (*debug & DEBUG_SOCKET)\n\t\tprintk(KERN_DEBUG \"%s: ID:%x\\n\",\n\t\t       __func__, mISDN_HEAD_ID(skb));\n\n\terr = -ENODEV;\n\tif (!_pms(sk)->ch.peer)\n\t\tgoto done;\n\terr = _pms(sk)->ch.recv(_pms(sk)->ch.peer, skb);\n\tif (err)\n\t\tgoto done;\n\telse {\n\t\tskb = NULL;\n\t\terr = len;\n\t}\n\ndone:\n\tkfree_skb(skb);\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int\ndata_sock_release(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\n\tif (*debug & DEBUG_SOCKET)\n\t\tprintk(KERN_DEBUG \"%s(%p) sk=%p\\n\", __func__, sock, sk);\n\tif (!sk)\n\t\treturn 0;\n\tswitch (sk->sk_protocol) {\n\tcase ISDN_P_TE_S0:\n\tcase ISDN_P_NT_S0:\n\tcase ISDN_P_TE_E1:\n\tcase ISDN_P_NT_E1:\n\t\tif (sk->sk_state == MISDN_BOUND)\n\t\t\tdelete_channel(&_pms(sk)->ch);\n\t\telse\n\t\t\tmISDN_sock_unlink(&data_sockets, sk);\n\t\tbreak;\n\tcase ISDN_P_LAPD_TE:\n\tcase ISDN_P_LAPD_NT:\n\tcase ISDN_P_B_RAW:\n\tcase ISDN_P_B_HDLC:\n\tcase ISDN_P_B_X75SLP:\n\tcase ISDN_P_B_L2DTMF:\n\tcase ISDN_P_B_L2DSP:\n\tcase ISDN_P_B_L2DSPHDLC:\n\t\tdelete_channel(&_pms(sk)->ch);\n\t\tmISDN_sock_unlink(&data_sockets, sk);\n\t\tbreak;\n\t}\n\n\tlock_sock(sk);\n\n\tsock_orphan(sk);\n\tskb_queue_purge(&sk->sk_receive_queue);\n\n\trelease_sock(sk);\n\tsock_put(sk);\n\n\treturn 0;\n}\n\nstatic int\ndata_sock_ioctl_bound(struct sock *sk, unsigned int cmd, void __user *p)\n{\n\tstruct mISDN_ctrl_req\tcq;\n\tint\t\t\terr = -EINVAL, val[2];\n\tstruct mISDNchannel\t*bchan, *next;\n\n\tlock_sock(sk);\n\tif (!_pms(sk)->dev) {\n\t\terr = -ENODEV;\n\t\tgoto done;\n\t}\n\tswitch (cmd) {\n\tcase IMCTRLREQ:\n\t\tif (copy_from_user(&cq, p, sizeof(cq))) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tif ((sk->sk_protocol & ~ISDN_P_B_MASK) == ISDN_P_B_START) {\n\t\t\tlist_for_each_entry_safe(bchan, next,\n\t\t\t\t\t\t &_pms(sk)->dev->bchannels, list) {\n\t\t\t\tif (bchan->nr == cq.channel) {\n\t\t\t\t\terr = bchan->ctrl(bchan,\n\t\t\t\t\t\t\t  CONTROL_CHANNEL, &cq);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else\n\t\t\terr = _pms(sk)->dev->D.ctrl(&_pms(sk)->dev->D,\n\t\t\t\t\t\t    CONTROL_CHANNEL, &cq);\n\t\tif (err)\n\t\t\tbreak;\n\t\tif (copy_to_user(p, &cq, sizeof(cq)))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\tcase IMCLEAR_L2:\n\t\tif (sk->sk_protocol != ISDN_P_LAPD_NT) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tval[0] = cmd;\n\t\tif (get_user(val[1], (int __user *)p)) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\terr = _pms(sk)->dev->teimgr->ctrl(_pms(sk)->dev->teimgr,\n\t\t\t\t\t\t  CONTROL_CHANNEL, val);\n\t\tbreak;\n\tcase IMHOLD_L1:\n\t\tif (sk->sk_protocol != ISDN_P_LAPD_NT\n\t\t    && sk->sk_protocol != ISDN_P_LAPD_TE) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tval[0] = cmd;\n\t\tif (get_user(val[1], (int __user *)p)) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\terr = _pms(sk)->dev->teimgr->ctrl(_pms(sk)->dev->teimgr,\n\t\t\t\t\t\t  CONTROL_CHANNEL, val);\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t\tbreak;\n\t}\ndone:\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int\ndata_sock_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)\n{\n\tint\t\t\terr = 0, id;\n\tstruct sock\t\t*sk = sock->sk;\n\tstruct mISDNdevice\t*dev;\n\tstruct mISDNversion\tver;\n\n\tswitch (cmd) {\n\tcase IMGETVERSION:\n\t\tver.major = MISDN_MAJOR_VERSION;\n\t\tver.minor = MISDN_MINOR_VERSION;\n\t\tver.release = MISDN_RELEASE;\n\t\tif (copy_to_user((void __user *)arg, &ver, sizeof(ver)))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\tcase IMGETCOUNT:\n\t\tid = get_mdevice_count();\n\t\tif (put_user(id, (int __user *)arg))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\tcase IMGETDEVINFO:\n\t\tif (get_user(id, (int __user *)arg)) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tdev = get_mdevice(id);\n\t\tif (dev) {\n\t\t\tstruct mISDN_devinfo di;\n\n\t\t\tmemset(&di, 0, sizeof(di));\n\t\t\tdi.id = dev->id;\n\t\t\tdi.Dprotocols = dev->Dprotocols;\n\t\t\tdi.Bprotocols = dev->Bprotocols | get_all_Bprotocols();\n\t\t\tdi.protocol = dev->D.protocol;\n\t\t\tmemcpy(di.channelmap, dev->channelmap,\n\t\t\t       sizeof(di.channelmap));\n\t\t\tdi.nrbchan = dev->nrbchan;\n\t\t\tstrscpy(di.name, dev_name(&dev->dev), sizeof(di.name));\n\t\t\tif (copy_to_user((void __user *)arg, &di, sizeof(di)))\n\t\t\t\terr = -EFAULT;\n\t\t} else\n\t\t\terr = -ENODEV;\n\t\tbreak;\n\tdefault:\n\t\tif (sk->sk_state == MISDN_BOUND)\n\t\t\terr = data_sock_ioctl_bound(sk, cmd,\n\t\t\t\t\t\t    (void __user *)arg);\n\t\telse\n\t\t\terr = -ENOTCONN;\n\t}\n\treturn err;\n}\n\nstatic int data_sock_setsockopt(struct socket *sock, int level, int optname,\n\t\t\t\tsockptr_t optval, unsigned int len)\n{\n\tstruct sock *sk = sock->sk;\n\tint err = 0, opt = 0;\n\n\tif (*debug & DEBUG_SOCKET)\n\t\tprintk(KERN_DEBUG \"%s(%p, %d, %x, optval, %d)\\n\", __func__, sock,\n\t\t       level, optname, len);\n\n\tlock_sock(sk);\n\n\tswitch (optname) {\n\tcase MISDN_TIME_STAMP:\n\t\tif (copy_from_sockptr(&opt, optval, sizeof(int))) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (opt)\n\t\t\t_pms(sk)->cmask |= MISDN_TIME_STAMP;\n\t\telse\n\t\t\t_pms(sk)->cmask &= ~MISDN_TIME_STAMP;\n\t\tbreak;\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int data_sock_getsockopt(struct socket *sock, int level, int optname,\n\t\t\t\tchar __user *optval, int __user *optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tint len, opt;\n\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\n\tif (len != sizeof(char))\n\t\treturn -EINVAL;\n\n\tswitch (optname) {\n\tcase MISDN_TIME_STAMP:\n\t\tif (_pms(sk)->cmask & MISDN_TIME_STAMP)\n\t\t\topt = 1;\n\t\telse\n\t\t\topt = 0;\n\n\t\tif (put_user(opt, optval))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOPROTOOPT;\n\t}\n\n\treturn 0;\n}\n\nstatic int\ndata_sock_bind(struct socket *sock, struct sockaddr *addr, int addr_len)\n{\n\tstruct sockaddr_mISDN *maddr = (struct sockaddr_mISDN *) addr;\n\tstruct sock *sk = sock->sk;\n\tstruct sock *csk;\n\tint err = 0;\n\n\tif (*debug & DEBUG_SOCKET)\n\t\tprintk(KERN_DEBUG \"%s(%p) sk=%p\\n\", __func__, sock, sk);\n\tif (addr_len != sizeof(struct sockaddr_mISDN))\n\t\treturn -EINVAL;\n\tif (!maddr || maddr->family != AF_ISDN)\n\t\treturn -EINVAL;\n\n\tlock_sock(sk);\n\n\tif (_pms(sk)->dev) {\n\t\terr = -EALREADY;\n\t\tgoto done;\n\t}\n\t_pms(sk)->dev = get_mdevice(maddr->dev);\n\tif (!_pms(sk)->dev) {\n\t\terr = -ENODEV;\n\t\tgoto done;\n\t}\n\n\tif (sk->sk_protocol < ISDN_P_B_START) {\n\t\tread_lock_bh(&data_sockets.lock);\n\t\tsk_for_each(csk, &data_sockets.head) {\n\t\t\tif (sk == csk)\n\t\t\t\tcontinue;\n\t\t\tif (_pms(csk)->dev != _pms(sk)->dev)\n\t\t\t\tcontinue;\n\t\t\tif (csk->sk_protocol >= ISDN_P_B_START)\n\t\t\t\tcontinue;\n\t\t\tif (IS_ISDN_P_TE(csk->sk_protocol)\n\t\t\t    == IS_ISDN_P_TE(sk->sk_protocol))\n\t\t\t\tcontinue;\n\t\t\tread_unlock_bh(&data_sockets.lock);\n\t\t\terr = -EBUSY;\n\t\t\tgoto done;\n\t\t}\n\t\tread_unlock_bh(&data_sockets.lock);\n\t}\n\n\t_pms(sk)->ch.send = mISDN_send;\n\t_pms(sk)->ch.ctrl = mISDN_ctrl;\n\n\tswitch (sk->sk_protocol) {\n\tcase ISDN_P_TE_S0:\n\tcase ISDN_P_NT_S0:\n\tcase ISDN_P_TE_E1:\n\tcase ISDN_P_NT_E1:\n\t\tmISDN_sock_unlink(&data_sockets, sk);\n\t\terr = connect_layer1(_pms(sk)->dev, &_pms(sk)->ch,\n\t\t\t\t     sk->sk_protocol, maddr);\n\t\tif (err)\n\t\t\tmISDN_sock_link(&data_sockets, sk);\n\t\tbreak;\n\tcase ISDN_P_LAPD_TE:\n\tcase ISDN_P_LAPD_NT:\n\t\terr = create_l2entity(_pms(sk)->dev, &_pms(sk)->ch,\n\t\t\t\t      sk->sk_protocol, maddr);\n\t\tbreak;\n\tcase ISDN_P_B_RAW:\n\tcase ISDN_P_B_HDLC:\n\tcase ISDN_P_B_X75SLP:\n\tcase ISDN_P_B_L2DTMF:\n\tcase ISDN_P_B_L2DSP:\n\tcase ISDN_P_B_L2DSPHDLC:\n\t\terr = connect_Bstack(_pms(sk)->dev, &_pms(sk)->ch,\n\t\t\t\t     sk->sk_protocol, maddr);\n\t\tbreak;\n\tdefault:\n\t\terr = -EPROTONOSUPPORT;\n\t}\n\tif (err)\n\t\tgoto done;\n\tsk->sk_state = MISDN_BOUND;\n\t_pms(sk)->ch.protocol = sk->sk_protocol;\n\ndone:\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int\ndata_sock_getname(struct socket *sock, struct sockaddr *addr,\n\t\t  int peer)\n{\n\tstruct sockaddr_mISDN\t*maddr = (struct sockaddr_mISDN *) addr;\n\tstruct sock\t\t*sk = sock->sk;\n\n\tif (!_pms(sk)->dev)\n\t\treturn -EBADFD;\n\n\tlock_sock(sk);\n\n\tmaddr->family = AF_ISDN;\n\tmaddr->dev = _pms(sk)->dev->id;\n\tmaddr->channel = _pms(sk)->ch.nr;\n\tmaddr->sapi = _pms(sk)->ch.addr & 0xff;\n\tmaddr->tei = (_pms(sk)->ch.addr >> 8) & 0xff;\n\trelease_sock(sk);\n\treturn sizeof(*maddr);\n}\n\nstatic const struct proto_ops data_sock_ops = {\n\t.family\t\t= PF_ISDN,\n\t.owner\t\t= THIS_MODULE,\n\t.release\t= data_sock_release,\n\t.ioctl\t\t= data_sock_ioctl,\n\t.bind\t\t= data_sock_bind,\n\t.getname\t= data_sock_getname,\n\t.sendmsg\t= mISDN_sock_sendmsg,\n\t.recvmsg\t= mISDN_sock_recvmsg,\n\t.poll\t\t= datagram_poll,\n\t.listen\t\t= sock_no_listen,\n\t.shutdown\t= sock_no_shutdown,\n\t.setsockopt\t= data_sock_setsockopt,\n\t.getsockopt\t= data_sock_getsockopt,\n\t.connect\t= sock_no_connect,\n\t.socketpair\t= sock_no_socketpair,\n\t.accept\t\t= sock_no_accept,\n\t.mmap\t\t= sock_no_mmap\n};\n\nstatic int\ndata_sock_create(struct net *net, struct socket *sock, int protocol, int kern)\n{\n\tstruct sock *sk;\n\n\tif (sock->type != SOCK_DGRAM)\n\t\treturn -ESOCKTNOSUPPORT;\n\n\tsk = sk_alloc(net, PF_ISDN, GFP_KERNEL, &mISDN_proto, kern);\n\tif (!sk)\n\t\treturn -ENOMEM;\n\n\tsock_init_data(sock, sk);\n\n\tsock->ops = &data_sock_ops;\n\tsock->state = SS_UNCONNECTED;\n\tsock_reset_flag(sk, SOCK_ZAPPED);\n\n\tsk->sk_protocol = protocol;\n\tsk->sk_state    = MISDN_OPEN;\n\tmISDN_sock_link(&data_sockets, sk);\n\n\treturn 0;\n}\n\nstatic int\nbase_sock_release(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\n\tprintk(KERN_DEBUG \"%s(%p) sk=%p\\n\", __func__, sock, sk);\n\tif (!sk)\n\t\treturn 0;\n\n\tmISDN_sock_unlink(&base_sockets, sk);\n\tsock_orphan(sk);\n\tsock_put(sk);\n\n\treturn 0;\n}\n\nstatic int\nbase_sock_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)\n{\n\tint\t\t\terr = 0, id;\n\tstruct mISDNdevice\t*dev;\n\tstruct mISDNversion\tver;\n\n\tswitch (cmd) {\n\tcase IMGETVERSION:\n\t\tver.major = MISDN_MAJOR_VERSION;\n\t\tver.minor = MISDN_MINOR_VERSION;\n\t\tver.release = MISDN_RELEASE;\n\t\tif (copy_to_user((void __user *)arg, &ver, sizeof(ver)))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\tcase IMGETCOUNT:\n\t\tid = get_mdevice_count();\n\t\tif (put_user(id, (int __user *)arg))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\tcase IMGETDEVINFO:\n\t\tif (get_user(id, (int __user *)arg)) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tdev = get_mdevice(id);\n\t\tif (dev) {\n\t\t\tstruct mISDN_devinfo di;\n\n\t\t\tmemset(&di, 0, sizeof(di));\n\t\t\tdi.id = dev->id;\n\t\t\tdi.Dprotocols = dev->Dprotocols;\n\t\t\tdi.Bprotocols = dev->Bprotocols | get_all_Bprotocols();\n\t\t\tdi.protocol = dev->D.protocol;\n\t\t\tmemcpy(di.channelmap, dev->channelmap,\n\t\t\t       sizeof(di.channelmap));\n\t\t\tdi.nrbchan = dev->nrbchan;\n\t\t\tstrscpy(di.name, dev_name(&dev->dev), sizeof(di.name));\n\t\t\tif (copy_to_user((void __user *)arg, &di, sizeof(di)))\n\t\t\t\terr = -EFAULT;\n\t\t} else\n\t\t\terr = -ENODEV;\n\t\tbreak;\n\tcase IMSETDEVNAME:\n\t{\n\t\tstruct mISDN_devrename dn;\n\t\tif (copy_from_user(&dn, (void __user *)arg,\n\t\t\t\t   sizeof(dn))) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tdn.name[sizeof(dn.name) - 1] = '\\0';\n\t\tdev = get_mdevice(dn.id);\n\t\tif (dev)\n\t\t\terr = device_rename(&dev->dev, dn.name);\n\t\telse\n\t\t\terr = -ENODEV;\n\t}\n\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t}\n\treturn err;\n}\n\nstatic int\nbase_sock_bind(struct socket *sock, struct sockaddr *addr, int addr_len)\n{\n\tstruct sockaddr_mISDN *maddr = (struct sockaddr_mISDN *) addr;\n\tstruct sock *sk = sock->sk;\n\tint err = 0;\n\n\tif (addr_len < sizeof(struct sockaddr_mISDN))\n\t\treturn -EINVAL;\n\n\tif (!maddr || maddr->family != AF_ISDN)\n\t\treturn -EINVAL;\n\n\tlock_sock(sk);\n\n\tif (_pms(sk)->dev) {\n\t\terr = -EALREADY;\n\t\tgoto done;\n\t}\n\n\t_pms(sk)->dev = get_mdevice(maddr->dev);\n\tif (!_pms(sk)->dev) {\n\t\terr = -ENODEV;\n\t\tgoto done;\n\t}\n\tsk->sk_state = MISDN_BOUND;\n\ndone:\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic const struct proto_ops base_sock_ops = {\n\t.family\t\t= PF_ISDN,\n\t.owner\t\t= THIS_MODULE,\n\t.release\t= base_sock_release,\n\t.ioctl\t\t= base_sock_ioctl,\n\t.bind\t\t= base_sock_bind,\n\t.getname\t= sock_no_getname,\n\t.sendmsg\t= sock_no_sendmsg,\n\t.recvmsg\t= sock_no_recvmsg,\n\t.listen\t\t= sock_no_listen,\n\t.shutdown\t= sock_no_shutdown,\n\t.connect\t= sock_no_connect,\n\t.socketpair\t= sock_no_socketpair,\n\t.accept\t\t= sock_no_accept,\n\t.mmap\t\t= sock_no_mmap\n};\n\n\nstatic int\nbase_sock_create(struct net *net, struct socket *sock, int protocol, int kern)\n{\n\tstruct sock *sk;\n\n\tif (sock->type != SOCK_RAW)\n\t\treturn -ESOCKTNOSUPPORT;\n\tif (!capable(CAP_NET_RAW))\n\t\treturn -EPERM;\n\n\tsk = sk_alloc(net, PF_ISDN, GFP_KERNEL, &mISDN_proto, kern);\n\tif (!sk)\n\t\treturn -ENOMEM;\n\n\tsock_init_data(sock, sk);\n\tsock->ops = &base_sock_ops;\n\tsock->state = SS_UNCONNECTED;\n\tsock_reset_flag(sk, SOCK_ZAPPED);\n\tsk->sk_protocol = protocol;\n\tsk->sk_state    = MISDN_OPEN;\n\tmISDN_sock_link(&base_sockets, sk);\n\n\treturn 0;\n}\n\nstatic int\nmISDN_sock_create(struct net *net, struct socket *sock, int proto, int kern)\n{\n\tint err = -EPROTONOSUPPORT;\n\n\tswitch (proto) {\n\tcase ISDN_P_BASE:\n\t\terr = base_sock_create(net, sock, proto, kern);\n\t\tbreak;\n\tcase ISDN_P_TE_S0:\n\tcase ISDN_P_NT_S0:\n\tcase ISDN_P_TE_E1:\n\tcase ISDN_P_NT_E1:\n\tcase ISDN_P_LAPD_TE:\n\tcase ISDN_P_LAPD_NT:\n\tcase ISDN_P_B_RAW:\n\tcase ISDN_P_B_HDLC:\n\tcase ISDN_P_B_X75SLP:\n\tcase ISDN_P_B_L2DTMF:\n\tcase ISDN_P_B_L2DSP:\n\tcase ISDN_P_B_L2DSPHDLC:\n\t\terr = data_sock_create(net, sock, proto, kern);\n\t\tbreak;\n\tdefault:\n\t\treturn err;\n\t}\n\n\treturn err;\n}\n\nstatic const struct net_proto_family mISDN_sock_family_ops = {\n\t.owner  = THIS_MODULE,\n\t.family = PF_ISDN,\n\t.create = mISDN_sock_create,\n};\n\nint\nmisdn_sock_init(u_int *deb)\n{\n\tint err;\n\n\tdebug = deb;\n\terr = sock_register(&mISDN_sock_family_ops);\n\tif (err)\n\t\tprintk(KERN_ERR \"%s: error(%d)\\n\", __func__, err);\n\treturn err;\n}\n\nvoid\nmisdn_sock_cleanup(void)\n{\n\tsock_unregister(PF_ISDN);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}