{
  "module_name": "hwchannel.c",
  "hash_id": "2a722d8d9015e3e9c276af76c6a21d68da07f1cc2f089a7e2cf90134540808c3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/isdn/mISDN/hwchannel.c",
  "human_readable_source": "\n \n\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/mISDNhw.h>\n\nstatic void\ndchannel_bh(struct work_struct *ws)\n{\n\tstruct dchannel\t*dch  = container_of(ws, struct dchannel, workq);\n\tstruct sk_buff\t*skb;\n\tint\t\terr;\n\n\tif (test_and_clear_bit(FLG_RECVQUEUE, &dch->Flags)) {\n\t\twhile ((skb = skb_dequeue(&dch->rqueue))) {\n\t\t\tif (likely(dch->dev.D.peer)) {\n\t\t\t\terr = dch->dev.D.recv(dch->dev.D.peer, skb);\n\t\t\t\tif (err)\n\t\t\t\t\tdev_kfree_skb(skb);\n\t\t\t} else\n\t\t\t\tdev_kfree_skb(skb);\n\t\t}\n\t}\n\tif (test_and_clear_bit(FLG_PHCHANGE, &dch->Flags)) {\n\t\tif (dch->phfunc)\n\t\t\tdch->phfunc(dch);\n\t}\n}\n\nstatic void\nbchannel_bh(struct work_struct *ws)\n{\n\tstruct bchannel\t*bch  = container_of(ws, struct bchannel, workq);\n\tstruct sk_buff\t*skb;\n\tint\t\terr;\n\n\tif (test_and_clear_bit(FLG_RECVQUEUE, &bch->Flags)) {\n\t\twhile ((skb = skb_dequeue(&bch->rqueue))) {\n\t\t\tbch->rcount--;\n\t\t\tif (likely(bch->ch.peer)) {\n\t\t\t\terr = bch->ch.recv(bch->ch.peer, skb);\n\t\t\t\tif (err)\n\t\t\t\t\tdev_kfree_skb(skb);\n\t\t\t} else\n\t\t\t\tdev_kfree_skb(skb);\n\t\t}\n\t}\n}\n\nint\nmISDN_initdchannel(struct dchannel *ch, int maxlen, void *phf)\n{\n\ttest_and_set_bit(FLG_HDLC, &ch->Flags);\n\tch->maxlen = maxlen;\n\tch->hw = NULL;\n\tch->rx_skb = NULL;\n\tch->tx_skb = NULL;\n\tch->tx_idx = 0;\n\tch->phfunc = phf;\n\tskb_queue_head_init(&ch->squeue);\n\tskb_queue_head_init(&ch->rqueue);\n\tINIT_LIST_HEAD(&ch->dev.bchannels);\n\tINIT_WORK(&ch->workq, dchannel_bh);\n\treturn 0;\n}\nEXPORT_SYMBOL(mISDN_initdchannel);\n\nint\nmISDN_initbchannel(struct bchannel *ch, unsigned short maxlen,\n\t\t   unsigned short minlen)\n{\n\tch->Flags = 0;\n\tch->minlen = minlen;\n\tch->next_minlen = minlen;\n\tch->init_minlen = minlen;\n\tch->maxlen = maxlen;\n\tch->next_maxlen = maxlen;\n\tch->init_maxlen = maxlen;\n\tch->hw = NULL;\n\tch->rx_skb = NULL;\n\tch->tx_skb = NULL;\n\tch->tx_idx = 0;\n\tskb_queue_head_init(&ch->rqueue);\n\tch->rcount = 0;\n\tch->next_skb = NULL;\n\tINIT_WORK(&ch->workq, bchannel_bh);\n\treturn 0;\n}\nEXPORT_SYMBOL(mISDN_initbchannel);\n\nint\nmISDN_freedchannel(struct dchannel *ch)\n{\n\tif (ch->tx_skb) {\n\t\tdev_kfree_skb(ch->tx_skb);\n\t\tch->tx_skb = NULL;\n\t}\n\tif (ch->rx_skb) {\n\t\tdev_kfree_skb(ch->rx_skb);\n\t\tch->rx_skb = NULL;\n\t}\n\tskb_queue_purge(&ch->squeue);\n\tskb_queue_purge(&ch->rqueue);\n\tflush_work(&ch->workq);\n\treturn 0;\n}\nEXPORT_SYMBOL(mISDN_freedchannel);\n\nvoid\nmISDN_clear_bchannel(struct bchannel *ch)\n{\n\tif (ch->tx_skb) {\n\t\tdev_kfree_skb(ch->tx_skb);\n\t\tch->tx_skb = NULL;\n\t}\n\tch->tx_idx = 0;\n\tif (ch->rx_skb) {\n\t\tdev_kfree_skb(ch->rx_skb);\n\t\tch->rx_skb = NULL;\n\t}\n\tif (ch->next_skb) {\n\t\tdev_kfree_skb(ch->next_skb);\n\t\tch->next_skb = NULL;\n\t}\n\ttest_and_clear_bit(FLG_TX_BUSY, &ch->Flags);\n\ttest_and_clear_bit(FLG_TX_NEXT, &ch->Flags);\n\ttest_and_clear_bit(FLG_ACTIVE, &ch->Flags);\n\ttest_and_clear_bit(FLG_FILLEMPTY, &ch->Flags);\n\ttest_and_clear_bit(FLG_TX_EMPTY, &ch->Flags);\n\ttest_and_clear_bit(FLG_RX_OFF, &ch->Flags);\n\tch->dropcnt = 0;\n\tch->minlen = ch->init_minlen;\n\tch->next_minlen = ch->init_minlen;\n\tch->maxlen = ch->init_maxlen;\n\tch->next_maxlen = ch->init_maxlen;\n\tskb_queue_purge(&ch->rqueue);\n\tch->rcount = 0;\n}\nEXPORT_SYMBOL(mISDN_clear_bchannel);\n\nvoid\nmISDN_freebchannel(struct bchannel *ch)\n{\n\tcancel_work_sync(&ch->workq);\n\tmISDN_clear_bchannel(ch);\n}\nEXPORT_SYMBOL(mISDN_freebchannel);\n\nint\nmISDN_ctrl_bchannel(struct bchannel *bch, struct mISDN_ctrl_req *cq)\n{\n\tint ret = 0;\n\n\tswitch (cq->op) {\n\tcase MISDN_CTRL_GETOP:\n\t\tcq->op = MISDN_CTRL_RX_BUFFER | MISDN_CTRL_FILL_EMPTY |\n\t\t\t MISDN_CTRL_RX_OFF;\n\t\tbreak;\n\tcase MISDN_CTRL_FILL_EMPTY:\n\t\tif (cq->p1) {\n\t\t\tmemset(bch->fill, cq->p2 & 0xff, MISDN_BCH_FILL_SIZE);\n\t\t\ttest_and_set_bit(FLG_FILLEMPTY, &bch->Flags);\n\t\t} else {\n\t\t\ttest_and_clear_bit(FLG_FILLEMPTY, &bch->Flags);\n\t\t}\n\t\tbreak;\n\tcase MISDN_CTRL_RX_OFF:\n\t\t \n\t\tcq->p2 = bch->dropcnt;\n\t\tif (cq->p1)\n\t\t\ttest_and_set_bit(FLG_RX_OFF, &bch->Flags);\n\t\telse\n\t\t\ttest_and_clear_bit(FLG_RX_OFF, &bch->Flags);\n\t\tbch->dropcnt = 0;\n\t\tbreak;\n\tcase MISDN_CTRL_RX_BUFFER:\n\t\tif (cq->p2 > MISDN_CTRL_RX_SIZE_IGNORE)\n\t\t\tbch->next_maxlen = cq->p2;\n\t\tif (cq->p1 > MISDN_CTRL_RX_SIZE_IGNORE)\n\t\t\tbch->next_minlen = cq->p1;\n\t\t \n\t\tcq->p1 = bch->minlen;\n\t\tcq->p2 = bch->maxlen;\n\t\tbreak;\n\tdefault:\n\t\tpr_info(\"mISDN unhandled control %x operation\\n\", cq->op);\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\treturn ret;\n}\nEXPORT_SYMBOL(mISDN_ctrl_bchannel);\n\nstatic inline u_int\nget_sapi_tei(u_char *p)\n{\n\tu_int\tsapi, tei;\n\n\tsapi = *p >> 2;\n\ttei = p[1] >> 1;\n\treturn sapi | (tei << 8);\n}\n\nvoid\nrecv_Dchannel(struct dchannel *dch)\n{\n\tstruct mISDNhead *hh;\n\n\tif (dch->rx_skb->len < 2) {  \n\t\tdev_kfree_skb(dch->rx_skb);\n\t\tdch->rx_skb = NULL;\n\t\treturn;\n\t}\n\thh = mISDN_HEAD_P(dch->rx_skb);\n\thh->prim = PH_DATA_IND;\n\thh->id = get_sapi_tei(dch->rx_skb->data);\n\tskb_queue_tail(&dch->rqueue, dch->rx_skb);\n\tdch->rx_skb = NULL;\n\tschedule_event(dch, FLG_RECVQUEUE);\n}\nEXPORT_SYMBOL(recv_Dchannel);\n\nvoid\nrecv_Echannel(struct dchannel *ech, struct dchannel *dch)\n{\n\tstruct mISDNhead *hh;\n\n\tif (ech->rx_skb->len < 2) {  \n\t\tdev_kfree_skb(ech->rx_skb);\n\t\tech->rx_skb = NULL;\n\t\treturn;\n\t}\n\thh = mISDN_HEAD_P(ech->rx_skb);\n\thh->prim = PH_DATA_E_IND;\n\thh->id = get_sapi_tei(ech->rx_skb->data);\n\tskb_queue_tail(&dch->rqueue, ech->rx_skb);\n\tech->rx_skb = NULL;\n\tschedule_event(dch, FLG_RECVQUEUE);\n}\nEXPORT_SYMBOL(recv_Echannel);\n\nvoid\nrecv_Bchannel(struct bchannel *bch, unsigned int id, bool force)\n{\n\tstruct mISDNhead *hh;\n\n\t \n\tif (unlikely(!bch->rx_skb))\n\t\treturn;\n\tif (unlikely(!bch->rx_skb->len)) {\n\t\t \n\t\tdev_kfree_skb(bch->rx_skb);\n\t\tbch->rx_skb = NULL;\n\t} else {\n\t\tif (test_bit(FLG_TRANSPARENT, &bch->Flags) &&\n\t\t    (bch->rx_skb->len < bch->minlen) && !force)\n\t\t\t\treturn;\n\t\thh = mISDN_HEAD_P(bch->rx_skb);\n\t\thh->prim = PH_DATA_IND;\n\t\thh->id = id;\n\t\tif (bch->rcount >= 64) {\n\t\t\tprintk(KERN_WARNING\n\t\t\t       \"B%d receive queue overflow - flushing!\\n\",\n\t\t\t       bch->nr);\n\t\t\tskb_queue_purge(&bch->rqueue);\n\t\t}\n\t\tbch->rcount++;\n\t\tskb_queue_tail(&bch->rqueue, bch->rx_skb);\n\t\tbch->rx_skb = NULL;\n\t\tschedule_event(bch, FLG_RECVQUEUE);\n\t}\n}\nEXPORT_SYMBOL(recv_Bchannel);\n\nvoid\nrecv_Dchannel_skb(struct dchannel *dch, struct sk_buff *skb)\n{\n\tskb_queue_tail(&dch->rqueue, skb);\n\tschedule_event(dch, FLG_RECVQUEUE);\n}\nEXPORT_SYMBOL(recv_Dchannel_skb);\n\nvoid\nrecv_Bchannel_skb(struct bchannel *bch, struct sk_buff *skb)\n{\n\tif (bch->rcount >= 64) {\n\t\tprintk(KERN_WARNING \"B-channel %p receive queue overflow, \"\n\t\t       \"flushing!\\n\", bch);\n\t\tskb_queue_purge(&bch->rqueue);\n\t\tbch->rcount = 0;\n\t}\n\tbch->rcount++;\n\tskb_queue_tail(&bch->rqueue, skb);\n\tschedule_event(bch, FLG_RECVQUEUE);\n}\nEXPORT_SYMBOL(recv_Bchannel_skb);\n\nstatic void\nconfirm_Dsend(struct dchannel *dch)\n{\n\tstruct sk_buff\t*skb;\n\n\tskb = _alloc_mISDN_skb(PH_DATA_CNF, mISDN_HEAD_ID(dch->tx_skb),\n\t\t\t       0, NULL, GFP_ATOMIC);\n\tif (!skb) {\n\t\tprintk(KERN_ERR \"%s: no skb id %x\\n\", __func__,\n\t\t       mISDN_HEAD_ID(dch->tx_skb));\n\t\treturn;\n\t}\n\tskb_queue_tail(&dch->rqueue, skb);\n\tschedule_event(dch, FLG_RECVQUEUE);\n}\n\nint\nget_next_dframe(struct dchannel *dch)\n{\n\tdch->tx_idx = 0;\n\tdch->tx_skb = skb_dequeue(&dch->squeue);\n\tif (dch->tx_skb) {\n\t\tconfirm_Dsend(dch);\n\t\treturn 1;\n\t}\n\tdch->tx_skb = NULL;\n\ttest_and_clear_bit(FLG_TX_BUSY, &dch->Flags);\n\treturn 0;\n}\nEXPORT_SYMBOL(get_next_dframe);\n\nstatic void\nconfirm_Bsend(struct bchannel *bch)\n{\n\tstruct sk_buff\t*skb;\n\n\tif (bch->rcount >= 64) {\n\t\tprintk(KERN_WARNING \"B-channel %p receive queue overflow, \"\n\t\t       \"flushing!\\n\", bch);\n\t\tskb_queue_purge(&bch->rqueue);\n\t\tbch->rcount = 0;\n\t}\n\tskb = _alloc_mISDN_skb(PH_DATA_CNF, mISDN_HEAD_ID(bch->tx_skb),\n\t\t\t       0, NULL, GFP_ATOMIC);\n\tif (!skb) {\n\t\tprintk(KERN_ERR \"%s: no skb id %x\\n\", __func__,\n\t\t       mISDN_HEAD_ID(bch->tx_skb));\n\t\treturn;\n\t}\n\tbch->rcount++;\n\tskb_queue_tail(&bch->rqueue, skb);\n\tschedule_event(bch, FLG_RECVQUEUE);\n}\n\nint\nget_next_bframe(struct bchannel *bch)\n{\n\tbch->tx_idx = 0;\n\tif (test_bit(FLG_TX_NEXT, &bch->Flags)) {\n\t\tbch->tx_skb = bch->next_skb;\n\t\tif (bch->tx_skb) {\n\t\t\tbch->next_skb = NULL;\n\t\t\ttest_and_clear_bit(FLG_TX_NEXT, &bch->Flags);\n\t\t\t \n\t\t\tconfirm_Bsend(bch);\n\t\t\treturn 1;\n\t\t} else {\n\t\t\ttest_and_clear_bit(FLG_TX_NEXT, &bch->Flags);\n\t\t\tprintk(KERN_WARNING \"B TX_NEXT without skb\\n\");\n\t\t}\n\t}\n\tbch->tx_skb = NULL;\n\ttest_and_clear_bit(FLG_TX_BUSY, &bch->Flags);\n\treturn 0;\n}\nEXPORT_SYMBOL(get_next_bframe);\n\nvoid\nqueue_ch_frame(struct mISDNchannel *ch, u_int pr, int id, struct sk_buff *skb)\n{\n\tstruct mISDNhead *hh;\n\n\tif (!skb) {\n\t\t_queue_data(ch, pr, id, 0, NULL, GFP_ATOMIC);\n\t} else {\n\t\tif (ch->peer) {\n\t\t\thh = mISDN_HEAD_P(skb);\n\t\t\thh->prim = pr;\n\t\t\thh->id = id;\n\t\t\tif (!ch->recv(ch->peer, skb))\n\t\t\t\treturn;\n\t\t}\n\t\tdev_kfree_skb(skb);\n\t}\n}\nEXPORT_SYMBOL(queue_ch_frame);\n\nint\ndchannel_senddata(struct dchannel *ch, struct sk_buff *skb)\n{\n\t \n\tif (skb->len <= 0) {\n\t\tprintk(KERN_WARNING \"%s: skb too small\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\tif (skb->len > ch->maxlen) {\n\t\tprintk(KERN_WARNING \"%s: skb too large(%d/%d)\\n\",\n\t\t       __func__, skb->len, ch->maxlen);\n\t\treturn -EINVAL;\n\t}\n\t \n\tif (test_and_set_bit(FLG_TX_BUSY, &ch->Flags)) {\n\t\tskb_queue_tail(&ch->squeue, skb);\n\t\treturn 0;\n\t} else {\n\t\t \n\t\tch->tx_skb = skb;\n\t\tch->tx_idx = 0;\n\t\treturn 1;\n\t}\n}\nEXPORT_SYMBOL(dchannel_senddata);\n\nint\nbchannel_senddata(struct bchannel *ch, struct sk_buff *skb)\n{\n\n\t \n\tif (skb->len <= 0) {\n\t\tprintk(KERN_WARNING \"%s: skb too small\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\tif (skb->len > ch->maxlen) {\n\t\tprintk(KERN_WARNING \"%s: skb too large(%d/%d)\\n\",\n\t\t       __func__, skb->len, ch->maxlen);\n\t\treturn -EINVAL;\n\t}\n\t \n\t \n\tif (ch->next_skb) {\n\t\tprintk(KERN_WARNING\n\t\t       \"%s: next_skb exist ERROR (skb->len=%d next_skb->len=%d)\\n\",\n\t\t       __func__, skb->len, ch->next_skb->len);\n\t\treturn -EBUSY;\n\t}\n\tif (test_and_set_bit(FLG_TX_BUSY, &ch->Flags)) {\n\t\ttest_and_set_bit(FLG_TX_NEXT, &ch->Flags);\n\t\tch->next_skb = skb;\n\t\treturn 0;\n\t} else {\n\t\t \n\t\tch->tx_skb = skb;\n\t\tch->tx_idx = 0;\n\t\tconfirm_Bsend(ch);\n\t\treturn 1;\n\t}\n}\nEXPORT_SYMBOL(bchannel_senddata);\n\n \nint\nbchannel_get_rxbuf(struct bchannel *bch, int reqlen)\n{\n\tint len;\n\n\tif (bch->rx_skb) {\n\t\tlen = skb_tailroom(bch->rx_skb);\n\t\tif (len < reqlen) {\n\t\t\tpr_warn(\"B%d no space for %d (only %d) bytes\\n\",\n\t\t\t\tbch->nr, reqlen, len);\n\t\t\tif (test_bit(FLG_TRANSPARENT, &bch->Flags)) {\n\t\t\t\t \n\t\t\t\trecv_Bchannel(bch, 0, true);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\treturn -EMSGSIZE;\n\t\t\t}\n\t\t} else {\n\t\t\treturn len;\n\t\t}\n\t}\n\t \n\tif (unlikely(bch->maxlen != bch->next_maxlen))\n\t\tbch->maxlen = bch->next_maxlen;\n\tif (unlikely(bch->minlen != bch->next_minlen))\n\t\tbch->minlen = bch->next_minlen;\n\tif (unlikely(reqlen > bch->maxlen))\n\t\treturn -EMSGSIZE;\n\tif (test_bit(FLG_TRANSPARENT, &bch->Flags)) {\n\t\tif (reqlen >= bch->minlen) {\n\t\t\tlen = reqlen;\n\t\t} else {\n\t\t\tlen = 2 * bch->minlen;\n\t\t\tif (len > bch->maxlen)\n\t\t\t\tlen = bch->maxlen;\n\t\t}\n\t} else {\n\t\t \n\t\tlen = bch->maxlen;\n\t}\n\tbch->rx_skb = mI_alloc_skb(len, GFP_ATOMIC);\n\tif (!bch->rx_skb) {\n\t\tpr_warn(\"B%d receive no memory for %d bytes\\n\", bch->nr, len);\n\t\tlen = -ENOMEM;\n\t}\n\treturn len;\n}\nEXPORT_SYMBOL(bchannel_get_rxbuf);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}