{
  "module_name": "layer2.c",
  "hash_id": "b29fc48a9389613826db572182db730d0b5e7c8fd5088aacccf67095feaa6372",
  "original_prompt": "Ingested from linux-6.6.14/drivers/isdn/mISDN/layer2.c",
  "human_readable_source": "\n \n\n#include <linux/mISDNif.h>\n#include <linux/slab.h>\n#include \"core.h\"\n#include \"fsm.h\"\n#include \"layer2.h\"\n\nstatic u_int *debug;\n\nstatic\nstruct Fsm l2fsm = {NULL, 0, 0, NULL, NULL};\n\nstatic char *strL2State[] =\n{\n\t\"ST_L2_1\",\n\t\"ST_L2_2\",\n\t\"ST_L2_3\",\n\t\"ST_L2_4\",\n\t\"ST_L2_5\",\n\t\"ST_L2_6\",\n\t\"ST_L2_7\",\n\t\"ST_L2_8\",\n};\n\nenum {\n\tEV_L2_UI,\n\tEV_L2_SABME,\n\tEV_L2_DISC,\n\tEV_L2_DM,\n\tEV_L2_UA,\n\tEV_L2_FRMR,\n\tEV_L2_SUPER,\n\tEV_L2_I,\n\tEV_L2_DL_DATA,\n\tEV_L2_ACK_PULL,\n\tEV_L2_DL_UNITDATA,\n\tEV_L2_DL_ESTABLISH_REQ,\n\tEV_L2_DL_RELEASE_REQ,\n\tEV_L2_MDL_ASSIGN,\n\tEV_L2_MDL_REMOVE,\n\tEV_L2_MDL_ERROR,\n\tEV_L1_DEACTIVATE,\n\tEV_L2_T200,\n\tEV_L2_T203,\n\tEV_L2_T200I,\n\tEV_L2_T203I,\n\tEV_L2_SET_OWN_BUSY,\n\tEV_L2_CLEAR_OWN_BUSY,\n\tEV_L2_FRAME_ERROR,\n};\n\n#define L2_EVENT_COUNT (EV_L2_FRAME_ERROR + 1)\n\nstatic char *strL2Event[] =\n{\n\t\"EV_L2_UI\",\n\t\"EV_L2_SABME\",\n\t\"EV_L2_DISC\",\n\t\"EV_L2_DM\",\n\t\"EV_L2_UA\",\n\t\"EV_L2_FRMR\",\n\t\"EV_L2_SUPER\",\n\t\"EV_L2_I\",\n\t\"EV_L2_DL_DATA\",\n\t\"EV_L2_ACK_PULL\",\n\t\"EV_L2_DL_UNITDATA\",\n\t\"EV_L2_DL_ESTABLISH_REQ\",\n\t\"EV_L2_DL_RELEASE_REQ\",\n\t\"EV_L2_MDL_ASSIGN\",\n\t\"EV_L2_MDL_REMOVE\",\n\t\"EV_L2_MDL_ERROR\",\n\t\"EV_L1_DEACTIVATE\",\n\t\"EV_L2_T200\",\n\t\"EV_L2_T203\",\n\t\"EV_L2_T200I\",\n\t\"EV_L2_T203I\",\n\t\"EV_L2_SET_OWN_BUSY\",\n\t\"EV_L2_CLEAR_OWN_BUSY\",\n\t\"EV_L2_FRAME_ERROR\",\n};\n\nstatic void\nl2m_debug(struct FsmInst *fi, char *fmt, ...)\n{\n\tstruct layer2 *l2 = fi->userdata;\n\tstruct va_format vaf;\n\tva_list va;\n\n\tif (!(*debug & DEBUG_L2_FSM))\n\t\treturn;\n\n\tva_start(va, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &va;\n\n\tprintk(KERN_DEBUG \"%s l2 (sapi %d tei %d): %pV\\n\",\n\t       mISDNDevName4ch(&l2->ch), l2->sapi, l2->tei, &vaf);\n\n\tva_end(va);\n}\n\ninline u_int\nl2headersize(struct layer2 *l2, int ui)\n{\n\treturn ((test_bit(FLG_MOD128, &l2->flag) && (!ui)) ? 2 : 1) +\n\t\t(test_bit(FLG_LAPD, &l2->flag) ? 2 : 1);\n}\n\ninline u_int\nl2addrsize(struct layer2 *l2)\n{\n\treturn test_bit(FLG_LAPD, &l2->flag) ? 2 : 1;\n}\n\nstatic u_int\nl2_newid(struct layer2 *l2)\n{\n\tu_int\tid;\n\n\tid = l2->next_id++;\n\tif (id == 0x7fff)\n\t\tl2->next_id = 1;\n\tid <<= 16;\n\tid |= l2->tei << 8;\n\tid |= l2->sapi;\n\treturn id;\n}\n\nstatic void\nl2up(struct layer2 *l2, u_int prim, struct sk_buff *skb)\n{\n\tint\terr;\n\n\tif (!l2->up)\n\t\treturn;\n\tmISDN_HEAD_PRIM(skb) = prim;\n\tmISDN_HEAD_ID(skb) = (l2->ch.nr << 16) | l2->ch.addr;\n\terr = l2->up->send(l2->up, skb);\n\tif (err) {\n\t\tprintk(KERN_WARNING \"%s: dev %s err=%d\\n\", __func__,\n\t\t       mISDNDevName4ch(&l2->ch), err);\n\t\tdev_kfree_skb(skb);\n\t}\n}\n\nstatic void\nl2up_create(struct layer2 *l2, u_int prim, int len, void *arg)\n{\n\tstruct sk_buff\t*skb;\n\tstruct mISDNhead *hh;\n\tint\t\terr;\n\n\tif (!l2->up)\n\t\treturn;\n\tskb = mI_alloc_skb(len, GFP_ATOMIC);\n\tif (!skb)\n\t\treturn;\n\thh = mISDN_HEAD_P(skb);\n\thh->prim = prim;\n\thh->id = (l2->ch.nr << 16) | l2->ch.addr;\n\tif (len)\n\t\tskb_put_data(skb, arg, len);\n\terr = l2->up->send(l2->up, skb);\n\tif (err) {\n\t\tprintk(KERN_WARNING \"%s: dev %s err=%d\\n\", __func__,\n\t\t       mISDNDevName4ch(&l2->ch), err);\n\t\tdev_kfree_skb(skb);\n\t}\n}\n\nstatic int\nl2down_skb(struct layer2 *l2, struct sk_buff *skb) {\n\tint ret;\n\n\tret = l2->ch.recv(l2->ch.peer, skb);\n\tif (ret && (*debug & DEBUG_L2_RECV))\n\t\tprintk(KERN_DEBUG \"l2down_skb: dev %s ret(%d)\\n\",\n\t\t       mISDNDevName4ch(&l2->ch), ret);\n\treturn ret;\n}\n\nstatic int\nl2down_raw(struct layer2 *l2, struct sk_buff *skb)\n{\n\tstruct mISDNhead *hh = mISDN_HEAD_P(skb);\n\n\tif (hh->prim == PH_DATA_REQ) {\n\t\tif (test_and_set_bit(FLG_L1_NOTREADY, &l2->flag)) {\n\t\t\tskb_queue_tail(&l2->down_queue, skb);\n\t\t\treturn 0;\n\t\t}\n\t\tl2->down_id = mISDN_HEAD_ID(skb);\n\t}\n\treturn l2down_skb(l2, skb);\n}\n\nstatic int\nl2down(struct layer2 *l2, u_int prim, u_int id, struct sk_buff *skb)\n{\n\tstruct mISDNhead *hh = mISDN_HEAD_P(skb);\n\n\thh->prim = prim;\n\thh->id = id;\n\treturn l2down_raw(l2, skb);\n}\n\nstatic int\nl2down_create(struct layer2 *l2, u_int prim, u_int id, int len, void *arg)\n{\n\tstruct sk_buff\t*skb;\n\tint\t\terr;\n\tstruct mISDNhead *hh;\n\n\tskb = mI_alloc_skb(len, GFP_ATOMIC);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\thh = mISDN_HEAD_P(skb);\n\thh->prim = prim;\n\thh->id = id;\n\tif (len)\n\t\tskb_put_data(skb, arg, len);\n\terr = l2down_raw(l2, skb);\n\tif (err)\n\t\tdev_kfree_skb(skb);\n\treturn err;\n}\n\nstatic int\nph_data_confirm(struct layer2 *l2, struct mISDNhead *hh, struct sk_buff *skb) {\n\tstruct sk_buff *nskb = skb;\n\tint ret = -EAGAIN;\n\n\tif (test_bit(FLG_L1_NOTREADY, &l2->flag)) {\n\t\tif (hh->id == l2->down_id) {\n\t\t\tnskb = skb_dequeue(&l2->down_queue);\n\t\t\tif (nskb) {\n\t\t\t\tl2->down_id = mISDN_HEAD_ID(nskb);\n\t\t\t\tif (l2down_skb(l2, nskb)) {\n\t\t\t\t\tdev_kfree_skb(nskb);\n\t\t\t\t\tl2->down_id = MISDN_ID_NONE;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\tl2->down_id = MISDN_ID_NONE;\n\t\t\tif (ret) {\n\t\t\t\tdev_kfree_skb(skb);\n\t\t\t\tret = 0;\n\t\t\t}\n\t\t\tif (l2->down_id == MISDN_ID_NONE) {\n\t\t\t\ttest_and_clear_bit(FLG_L1_NOTREADY, &l2->flag);\n\t\t\t\tmISDN_FsmEvent(&l2->l2m, EV_L2_ACK_PULL, NULL);\n\t\t\t}\n\t\t}\n\t}\n\tif (!test_and_set_bit(FLG_L1_NOTREADY, &l2->flag)) {\n\t\tnskb = skb_dequeue(&l2->down_queue);\n\t\tif (nskb) {\n\t\t\tl2->down_id = mISDN_HEAD_ID(nskb);\n\t\t\tif (l2down_skb(l2, nskb)) {\n\t\t\t\tdev_kfree_skb(nskb);\n\t\t\t\tl2->down_id = MISDN_ID_NONE;\n\t\t\t\ttest_and_clear_bit(FLG_L1_NOTREADY, &l2->flag);\n\t\t\t}\n\t\t} else\n\t\t\ttest_and_clear_bit(FLG_L1_NOTREADY, &l2->flag);\n\t}\n\treturn ret;\n}\n\nstatic void\nl2_timeout(struct FsmInst *fi, int event, void *arg)\n{\n\tstruct layer2 *l2 = fi->userdata;\n\tstruct sk_buff *skb;\n\tstruct mISDNhead *hh;\n\n\tskb = mI_alloc_skb(0, GFP_ATOMIC);\n\tif (!skb) {\n\t\tprintk(KERN_WARNING \"%s: L2(%d,%d) nr:%x timer %s no skb\\n\",\n\t\t       mISDNDevName4ch(&l2->ch), l2->sapi, l2->tei,\n\t\t       l2->ch.nr, event == EV_L2_T200 ? \"T200\" : \"T203\");\n\t\treturn;\n\t}\n\thh = mISDN_HEAD_P(skb);\n\thh->prim = event == EV_L2_T200 ? DL_TIMER200_IND : DL_TIMER203_IND;\n\thh->id = l2->ch.nr;\n\tif (*debug & DEBUG_TIMER)\n\t\tprintk(KERN_DEBUG \"%s: L2(%d,%d) nr:%x timer %s expired\\n\",\n\t\t       mISDNDevName4ch(&l2->ch), l2->sapi, l2->tei,\n\t\t       l2->ch.nr, event == EV_L2_T200 ? \"T200\" : \"T203\");\n\tif (l2->ch.st)\n\t\tl2->ch.st->own.recv(&l2->ch.st->own, skb);\n}\n\nstatic int\nl2mgr(struct layer2 *l2, u_int prim, void *arg) {\n\tlong c = (long)arg;\n\n\tprintk(KERN_WARNING \"l2mgr: dev %s addr:%x prim %x %c\\n\",\n\t       mISDNDevName4ch(&l2->ch), l2->id, prim, (char)c);\n\tif (test_bit(FLG_LAPD, &l2->flag) &&\n\t    !test_bit(FLG_FIXED_TEI, &l2->flag)) {\n\t\tswitch (c) {\n\t\tcase 'C':\n\t\tcase 'D':\n\t\tcase 'G':\n\t\tcase 'H':\n\t\t\tl2_tei(l2, prim, (u_long)arg);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void\nset_peer_busy(struct layer2 *l2) {\n\ttest_and_set_bit(FLG_PEER_BUSY, &l2->flag);\n\tif (skb_queue_len(&l2->i_queue) || skb_queue_len(&l2->ui_queue))\n\t\ttest_and_set_bit(FLG_L2BLOCK, &l2->flag);\n}\n\nstatic void\nclear_peer_busy(struct layer2 *l2) {\n\tif (test_and_clear_bit(FLG_PEER_BUSY, &l2->flag))\n\t\ttest_and_clear_bit(FLG_L2BLOCK, &l2->flag);\n}\n\nstatic void\nInitWin(struct layer2 *l2)\n{\n\tint i;\n\n\tfor (i = 0; i < MAX_WINDOW; i++)\n\t\tl2->windowar[i] = NULL;\n}\n\nstatic int\nfreewin(struct layer2 *l2)\n{\n\tint i, cnt = 0;\n\n\tfor (i = 0; i < MAX_WINDOW; i++) {\n\t\tif (l2->windowar[i]) {\n\t\t\tcnt++;\n\t\t\tdev_kfree_skb(l2->windowar[i]);\n\t\t\tl2->windowar[i] = NULL;\n\t\t}\n\t}\n\treturn cnt;\n}\n\nstatic void\nReleaseWin(struct layer2 *l2)\n{\n\tint cnt = freewin(l2);\n\n\tif (cnt)\n\t\tprintk(KERN_WARNING\n\t\t       \"isdnl2 freed %d skbuffs in release\\n\", cnt);\n}\n\ninline unsigned int\ncansend(struct layer2 *l2)\n{\n\tunsigned int p1;\n\n\tif (test_bit(FLG_MOD128, &l2->flag))\n\t\tp1 = (l2->vs - l2->va) % 128;\n\telse\n\t\tp1 = (l2->vs - l2->va) % 8;\n\treturn (p1 < l2->window) && !test_bit(FLG_PEER_BUSY, &l2->flag);\n}\n\ninline void\nclear_exception(struct layer2 *l2)\n{\n\ttest_and_clear_bit(FLG_ACK_PEND, &l2->flag);\n\ttest_and_clear_bit(FLG_REJEXC, &l2->flag);\n\ttest_and_clear_bit(FLG_OWN_BUSY, &l2->flag);\n\tclear_peer_busy(l2);\n}\n\nstatic int\nsethdraddr(struct layer2 *l2, u_char *header, int rsp)\n{\n\tu_char *ptr = header;\n\tint crbit = rsp;\n\n\tif (test_bit(FLG_LAPD, &l2->flag)) {\n\t\tif (test_bit(FLG_LAPD_NET, &l2->flag))\n\t\t\tcrbit = !crbit;\n\t\t*ptr++ = (l2->sapi << 2) | (crbit ? 2 : 0);\n\t\t*ptr++ = (l2->tei << 1) | 1;\n\t\treturn 2;\n\t} else {\n\t\tif (test_bit(FLG_ORIG, &l2->flag))\n\t\t\tcrbit = !crbit;\n\t\tif (crbit)\n\t\t\t*ptr++ = l2->addr.B;\n\t\telse\n\t\t\t*ptr++ = l2->addr.A;\n\t\treturn 1;\n\t}\n}\n\nstatic inline void\nenqueue_super(struct layer2 *l2, struct sk_buff *skb)\n{\n\tif (l2down(l2, PH_DATA_REQ, l2_newid(l2), skb))\n\t\tdev_kfree_skb(skb);\n}\n\nstatic inline void\nenqueue_ui(struct layer2 *l2, struct sk_buff *skb)\n{\n\tif (l2->tm)\n\t\tl2_tei(l2, MDL_STATUS_UI_IND, 0);\n\tif (l2down(l2, PH_DATA_REQ, l2_newid(l2), skb))\n\t\tdev_kfree_skb(skb);\n}\n\ninline int\nIsUI(u_char *data)\n{\n\treturn (data[0] & 0xef) == UI;\n}\n\ninline int\nIsUA(u_char *data)\n{\n\treturn (data[0] & 0xef) == UA;\n}\n\ninline int\nIsDM(u_char *data)\n{\n\treturn (data[0] & 0xef) == DM;\n}\n\ninline int\nIsDISC(u_char *data)\n{\n\treturn (data[0] & 0xef) == DISC;\n}\n\ninline int\nIsRR(u_char *data, struct layer2 *l2)\n{\n\tif (test_bit(FLG_MOD128, &l2->flag))\n\t\treturn data[0] == RR;\n\telse\n\t\treturn (data[0] & 0xf) == 1;\n}\n\ninline int\nIsSFrame(u_char *data, struct layer2 *l2)\n{\n\tregister u_char d = *data;\n\n\tif (!test_bit(FLG_MOD128, &l2->flag))\n\t\td &= 0xf;\n\treturn ((d & 0xf3) == 1) && ((d & 0x0c) != 0x0c);\n}\n\ninline int\nIsSABME(u_char *data, struct layer2 *l2)\n{\n\tu_char d = data[0] & ~0x10;\n\n\treturn test_bit(FLG_MOD128, &l2->flag) ? d == SABME : d == SABM;\n}\n\ninline int\nIsREJ(u_char *data, struct layer2 *l2)\n{\n\treturn test_bit(FLG_MOD128, &l2->flag) ?\n\t\tdata[0] == REJ : (data[0] & 0xf) == REJ;\n}\n\ninline int\nIsFRMR(u_char *data)\n{\n\treturn (data[0] & 0xef) == FRMR;\n}\n\ninline int\nIsRNR(u_char *data, struct layer2 *l2)\n{\n\treturn test_bit(FLG_MOD128, &l2->flag) ?\n\t\tdata[0] == RNR : (data[0] & 0xf) == RNR;\n}\n\nstatic int\niframe_error(struct layer2 *l2, struct sk_buff *skb)\n{\n\tu_int\ti;\n\tint\trsp = *skb->data & 0x2;\n\n\ti = l2addrsize(l2) + (test_bit(FLG_MOD128, &l2->flag) ? 2 : 1);\n\tif (test_bit(FLG_ORIG, &l2->flag))\n\t\trsp = !rsp;\n\tif (rsp)\n\t\treturn 'L';\n\tif (skb->len < i)\n\t\treturn 'N';\n\tif ((skb->len - i) > l2->maxlen)\n\t\treturn 'O';\n\treturn 0;\n}\n\nstatic int\nsuper_error(struct layer2 *l2, struct sk_buff *skb)\n{\n\tif (skb->len != l2addrsize(l2) +\n\t    (test_bit(FLG_MOD128, &l2->flag) ? 2 : 1))\n\t\treturn 'N';\n\treturn 0;\n}\n\nstatic int\nunnum_error(struct layer2 *l2, struct sk_buff *skb, int wantrsp)\n{\n\tint rsp = (*skb->data & 0x2) >> 1;\n\tif (test_bit(FLG_ORIG, &l2->flag))\n\t\trsp = !rsp;\n\tif (rsp != wantrsp)\n\t\treturn 'L';\n\tif (skb->len != l2addrsize(l2) + 1)\n\t\treturn 'N';\n\treturn 0;\n}\n\nstatic int\nUI_error(struct layer2 *l2, struct sk_buff *skb)\n{\n\tint rsp = *skb->data & 0x2;\n\tif (test_bit(FLG_ORIG, &l2->flag))\n\t\trsp = !rsp;\n\tif (rsp)\n\t\treturn 'L';\n\tif (skb->len > l2->maxlen + l2addrsize(l2) + 1)\n\t\treturn 'O';\n\treturn 0;\n}\n\nstatic int\nFRMR_error(struct layer2 *l2, struct sk_buff *skb)\n{\n\tu_int\theaders = l2addrsize(l2) + 1;\n\tu_char\t*datap = skb->data + headers;\n\tint\trsp = *skb->data & 0x2;\n\n\tif (test_bit(FLG_ORIG, &l2->flag))\n\t\trsp = !rsp;\n\tif (!rsp)\n\t\treturn 'L';\n\tif (test_bit(FLG_MOD128, &l2->flag)) {\n\t\tif (skb->len < headers + 5)\n\t\t\treturn 'N';\n\t\telse if (*debug & DEBUG_L2)\n\t\t\tl2m_debug(&l2->l2m,\n\t\t\t\t  \"FRMR information %2x %2x %2x %2x %2x\",\n\t\t\t\t  datap[0], datap[1], datap[2], datap[3], datap[4]);\n\t} else {\n\t\tif (skb->len < headers + 3)\n\t\t\treturn 'N';\n\t\telse if (*debug & DEBUG_L2)\n\t\t\tl2m_debug(&l2->l2m,\n\t\t\t\t  \"FRMR information %2x %2x %2x\",\n\t\t\t\t  datap[0], datap[1], datap[2]);\n\t}\n\treturn 0;\n}\n\nstatic unsigned int\nlegalnr(struct layer2 *l2, unsigned int nr)\n{\n\tif (test_bit(FLG_MOD128, &l2->flag))\n\t\treturn ((nr - l2->va) % 128) <= ((l2->vs - l2->va) % 128);\n\telse\n\t\treturn ((nr - l2->va) % 8) <= ((l2->vs - l2->va) % 8);\n}\n\nstatic void\nsetva(struct layer2 *l2, unsigned int nr)\n{\n\tstruct sk_buff\t*skb;\n\n\twhile (l2->va != nr) {\n\t\tl2->va++;\n\t\tif (test_bit(FLG_MOD128, &l2->flag))\n\t\t\tl2->va %= 128;\n\t\telse\n\t\t\tl2->va %= 8;\n\t\tif (l2->windowar[l2->sow]) {\n\t\t\tskb_trim(l2->windowar[l2->sow], 0);\n\t\t\tskb_queue_tail(&l2->tmp_queue, l2->windowar[l2->sow]);\n\t\t\tl2->windowar[l2->sow] = NULL;\n\t\t}\n\t\tl2->sow = (l2->sow + 1) % l2->window;\n\t}\n\tskb = skb_dequeue(&l2->tmp_queue);\n\twhile (skb) {\n\t\tdev_kfree_skb(skb);\n\t\tskb = skb_dequeue(&l2->tmp_queue);\n\t}\n}\n\nstatic void\nsend_uframe(struct layer2 *l2, struct sk_buff *skb, u_char cmd, u_char cr)\n{\n\tu_char tmp[MAX_L2HEADER_LEN];\n\tint i;\n\n\ti = sethdraddr(l2, tmp, cr);\n\ttmp[i++] = cmd;\n\tif (skb)\n\t\tskb_trim(skb, 0);\n\telse {\n\t\tskb = mI_alloc_skb(i, GFP_ATOMIC);\n\t\tif (!skb) {\n\t\t\tprintk(KERN_WARNING \"%s: can't alloc skbuff in %s\\n\",\n\t\t\t       mISDNDevName4ch(&l2->ch), __func__);\n\t\t\treturn;\n\t\t}\n\t}\n\tskb_put_data(skb, tmp, i);\n\tenqueue_super(l2, skb);\n}\n\n\ninline u_char\nget_PollFlag(struct layer2 *l2, struct sk_buff *skb)\n{\n\treturn skb->data[l2addrsize(l2)] & 0x10;\n}\n\ninline u_char\nget_PollFlagFree(struct layer2 *l2, struct sk_buff *skb)\n{\n\tu_char PF;\n\n\tPF = get_PollFlag(l2, skb);\n\tdev_kfree_skb(skb);\n\treturn PF;\n}\n\ninline void\nstart_t200(struct layer2 *l2, int i)\n{\n\tmISDN_FsmAddTimer(&l2->t200, l2->T200, EV_L2_T200, NULL, i);\n\ttest_and_set_bit(FLG_T200_RUN, &l2->flag);\n}\n\ninline void\nrestart_t200(struct layer2 *l2, int i)\n{\n\tmISDN_FsmRestartTimer(&l2->t200, l2->T200, EV_L2_T200, NULL, i);\n\ttest_and_set_bit(FLG_T200_RUN, &l2->flag);\n}\n\ninline void\nstop_t200(struct layer2 *l2, int i)\n{\n\tif (test_and_clear_bit(FLG_T200_RUN, &l2->flag))\n\t\tmISDN_FsmDelTimer(&l2->t200, i);\n}\n\ninline void\nst5_dl_release_l2l3(struct layer2 *l2)\n{\n\tint pr;\n\n\tif (test_and_clear_bit(FLG_PEND_REL, &l2->flag))\n\t\tpr = DL_RELEASE_CNF;\n\telse\n\t\tpr = DL_RELEASE_IND;\n\tl2up_create(l2, pr, 0, NULL);\n}\n\ninline void\nlapb_dl_release_l2l3(struct layer2 *l2, int f)\n{\n\tif (test_bit(FLG_LAPB, &l2->flag))\n\t\tl2down_create(l2, PH_DEACTIVATE_REQ, l2_newid(l2), 0, NULL);\n\tl2up_create(l2, f, 0, NULL);\n}\n\nstatic void\nestablishlink(struct FsmInst *fi)\n{\n\tstruct layer2 *l2 = fi->userdata;\n\tu_char cmd;\n\n\tclear_exception(l2);\n\tl2->rc = 0;\n\tcmd = (test_bit(FLG_MOD128, &l2->flag) ? SABME : SABM) | 0x10;\n\tsend_uframe(l2, NULL, cmd, CMD);\n\tmISDN_FsmDelTimer(&l2->t203, 1);\n\trestart_t200(l2, 1);\n\ttest_and_clear_bit(FLG_PEND_REL, &l2->flag);\n\tfreewin(l2);\n\tmISDN_FsmChangeState(fi, ST_L2_5);\n}\n\nstatic void\nl2_mdl_error_ua(struct FsmInst *fi, int event, void *arg)\n{\n\tstruct sk_buff *skb = arg;\n\tstruct layer2 *l2 = fi->userdata;\n\n\tif (get_PollFlagFree(l2, skb))\n\t\tl2mgr(l2, MDL_ERROR_IND, (void *) 'C');\n\telse\n\t\tl2mgr(l2, MDL_ERROR_IND, (void *) 'D');\n\n}\n\nstatic void\nl2_mdl_error_dm(struct FsmInst *fi, int event, void *arg)\n{\n\tstruct sk_buff *skb = arg;\n\tstruct layer2 *l2 = fi->userdata;\n\n\tif (get_PollFlagFree(l2, skb))\n\t\tl2mgr(l2, MDL_ERROR_IND, (void *) 'B');\n\telse {\n\t\tl2mgr(l2, MDL_ERROR_IND, (void *) 'E');\n\t\testablishlink(fi);\n\t\ttest_and_clear_bit(FLG_L3_INIT, &l2->flag);\n\t}\n}\n\nstatic void\nl2_st8_mdl_error_dm(struct FsmInst *fi, int event, void *arg)\n{\n\tstruct sk_buff *skb = arg;\n\tstruct layer2 *l2 = fi->userdata;\n\n\tif (get_PollFlagFree(l2, skb))\n\t\tl2mgr(l2, MDL_ERROR_IND, (void *) 'B');\n\telse\n\t\tl2mgr(l2, MDL_ERROR_IND, (void *) 'E');\n\testablishlink(fi);\n\ttest_and_clear_bit(FLG_L3_INIT, &l2->flag);\n}\n\nstatic void\nl2_go_st3(struct FsmInst *fi, int event, void *arg)\n{\n\tdev_kfree_skb((struct sk_buff *)arg);\n\tmISDN_FsmChangeState(fi, ST_L2_3);\n}\n\nstatic void\nl2_mdl_assign(struct FsmInst *fi, int event, void *arg)\n{\n\tstruct layer2\t*l2 = fi->userdata;\n\n\tmISDN_FsmChangeState(fi, ST_L2_3);\n\tdev_kfree_skb((struct sk_buff *)arg);\n\tl2_tei(l2, MDL_ASSIGN_IND, 0);\n}\n\nstatic void\nl2_queue_ui_assign(struct FsmInst *fi, int event, void *arg)\n{\n\tstruct layer2 *l2 = fi->userdata;\n\tstruct sk_buff *skb = arg;\n\n\tskb_queue_tail(&l2->ui_queue, skb);\n\tmISDN_FsmChangeState(fi, ST_L2_2);\n\tl2_tei(l2, MDL_ASSIGN_IND, 0);\n}\n\nstatic void\nl2_queue_ui(struct FsmInst *fi, int event, void *arg)\n{\n\tstruct layer2 *l2 = fi->userdata;\n\tstruct sk_buff *skb = arg;\n\n\tskb_queue_tail(&l2->ui_queue, skb);\n}\n\nstatic void\ntx_ui(struct layer2 *l2)\n{\n\tstruct sk_buff *skb;\n\tu_char header[MAX_L2HEADER_LEN];\n\tint i;\n\n\ti = sethdraddr(l2, header, CMD);\n\tif (test_bit(FLG_LAPD_NET, &l2->flag))\n\t\theader[1] = 0xff;  \n\theader[i++] = UI;\n\twhile ((skb = skb_dequeue(&l2->ui_queue))) {\n\t\tmemcpy(skb_push(skb, i), header, i);\n\t\tenqueue_ui(l2, skb);\n\t}\n}\n\nstatic void\nl2_send_ui(struct FsmInst *fi, int event, void *arg)\n{\n\tstruct layer2 *l2 = fi->userdata;\n\tstruct sk_buff *skb = arg;\n\n\tskb_queue_tail(&l2->ui_queue, skb);\n\ttx_ui(l2);\n}\n\nstatic void\nl2_got_ui(struct FsmInst *fi, int event, void *arg)\n{\n\tstruct layer2 *l2 = fi->userdata;\n\tstruct sk_buff *skb = arg;\n\n\tskb_pull(skb, l2headersize(l2, 1));\n \n\n\tif (l2->tm)\n\t\tl2_tei(l2, MDL_STATUS_UI_IND, 0);\n\tl2up(l2, DL_UNITDATA_IND, skb);\n}\n\nstatic void\nl2_establish(struct FsmInst *fi, int event, void *arg)\n{\n\tstruct sk_buff *skb = arg;\n\tstruct layer2 *l2 = fi->userdata;\n\n\testablishlink(fi);\n\ttest_and_set_bit(FLG_L3_INIT, &l2->flag);\n\tdev_kfree_skb(skb);\n}\n\nstatic void\nl2_discard_i_setl3(struct FsmInst *fi, int event, void *arg)\n{\n\tstruct sk_buff *skb = arg;\n\tstruct layer2 *l2 = fi->userdata;\n\n\tskb_queue_purge(&l2->i_queue);\n\ttest_and_set_bit(FLG_L3_INIT, &l2->flag);\n\ttest_and_clear_bit(FLG_PEND_REL, &l2->flag);\n\tdev_kfree_skb(skb);\n}\n\nstatic void\nl2_l3_reestablish(struct FsmInst *fi, int event, void *arg)\n{\n\tstruct sk_buff *skb = arg;\n\tstruct layer2 *l2 = fi->userdata;\n\n\tskb_queue_purge(&l2->i_queue);\n\testablishlink(fi);\n\ttest_and_set_bit(FLG_L3_INIT, &l2->flag);\n\tdev_kfree_skb(skb);\n}\n\nstatic void\nl2_release(struct FsmInst *fi, int event, void *arg)\n{\n\tstruct layer2 *l2 = fi->userdata;\n\tstruct sk_buff *skb = arg;\n\n\tskb_trim(skb, 0);\n\tl2up(l2, DL_RELEASE_CNF, skb);\n}\n\nstatic void\nl2_pend_rel(struct FsmInst *fi, int event, void *arg)\n{\n\tstruct sk_buff *skb = arg;\n\tstruct layer2 *l2 = fi->userdata;\n\n\ttest_and_set_bit(FLG_PEND_REL, &l2->flag);\n\tdev_kfree_skb(skb);\n}\n\nstatic void\nl2_disconnect(struct FsmInst *fi, int event, void *arg)\n{\n\tstruct layer2 *l2 = fi->userdata;\n\tstruct sk_buff *skb = arg;\n\n\tskb_queue_purge(&l2->i_queue);\n\tfreewin(l2);\n\tmISDN_FsmChangeState(fi, ST_L2_6);\n\tl2->rc = 0;\n\tsend_uframe(l2, NULL, DISC | 0x10, CMD);\n\tmISDN_FsmDelTimer(&l2->t203, 1);\n\trestart_t200(l2, 2);\n\tdev_kfree_skb(skb);\n}\n\nstatic void\nl2_start_multi(struct FsmInst *fi, int event, void *arg)\n{\n\tstruct layer2\t*l2 = fi->userdata;\n\tstruct sk_buff\t*skb = arg;\n\n\tl2->vs = 0;\n\tl2->va = 0;\n\tl2->vr = 0;\n\tl2->sow = 0;\n\tclear_exception(l2);\n\tsend_uframe(l2, NULL, UA | get_PollFlag(l2, skb), RSP);\n\tmISDN_FsmChangeState(fi, ST_L2_7);\n\tmISDN_FsmAddTimer(&l2->t203, l2->T203, EV_L2_T203, NULL, 3);\n\tskb_trim(skb, 0);\n\tl2up(l2, DL_ESTABLISH_IND, skb);\n\tif (l2->tm)\n\t\tl2_tei(l2, MDL_STATUS_UP_IND, 0);\n}\n\nstatic void\nl2_send_UA(struct FsmInst *fi, int event, void *arg)\n{\n\tstruct layer2 *l2 = fi->userdata;\n\tstruct sk_buff *skb = arg;\n\n\tsend_uframe(l2, skb, UA | get_PollFlag(l2, skb), RSP);\n}\n\nstatic void\nl2_send_DM(struct FsmInst *fi, int event, void *arg)\n{\n\tstruct layer2 *l2 = fi->userdata;\n\tstruct sk_buff *skb = arg;\n\n\tsend_uframe(l2, skb, DM | get_PollFlag(l2, skb), RSP);\n}\n\nstatic void\nl2_restart_multi(struct FsmInst *fi, int event, void *arg)\n{\n\tstruct layer2\t*l2 = fi->userdata;\n\tstruct sk_buff\t*skb = arg;\n\tint\t\test = 0;\n\n\tsend_uframe(l2, skb, UA | get_PollFlag(l2, skb), RSP);\n\n\tl2mgr(l2, MDL_ERROR_IND, (void *) 'F');\n\n\tif (l2->vs != l2->va) {\n\t\tskb_queue_purge(&l2->i_queue);\n\t\test = 1;\n\t}\n\n\tclear_exception(l2);\n\tl2->vs = 0;\n\tl2->va = 0;\n\tl2->vr = 0;\n\tl2->sow = 0;\n\tmISDN_FsmChangeState(fi, ST_L2_7);\n\tstop_t200(l2, 3);\n\tmISDN_FsmRestartTimer(&l2->t203, l2->T203, EV_L2_T203, NULL, 3);\n\n\tif (est)\n\t\tl2up_create(l2, DL_ESTABLISH_IND, 0, NULL);\n \n\tif (skb_queue_len(&l2->i_queue) && cansend(l2))\n\t\tmISDN_FsmEvent(fi, EV_L2_ACK_PULL, NULL);\n}\n\nstatic void\nl2_stop_multi(struct FsmInst *fi, int event, void *arg)\n{\n\tstruct layer2\t*l2 = fi->userdata;\n\tstruct sk_buff\t*skb = arg;\n\n\tmISDN_FsmChangeState(fi, ST_L2_4);\n\tmISDN_FsmDelTimer(&l2->t203, 3);\n\tstop_t200(l2, 4);\n\n\tsend_uframe(l2, skb, UA | get_PollFlag(l2, skb), RSP);\n\tskb_queue_purge(&l2->i_queue);\n\tfreewin(l2);\n\tlapb_dl_release_l2l3(l2, DL_RELEASE_IND);\n\tif (l2->tm)\n\t\tl2_tei(l2, MDL_STATUS_DOWN_IND, 0);\n}\n\nstatic void\nl2_connected(struct FsmInst *fi, int event, void *arg)\n{\n\tstruct layer2\t*l2 = fi->userdata;\n\tstruct sk_buff\t*skb = arg;\n\tint pr = -1;\n\n\tif (!get_PollFlag(l2, skb)) {\n\t\tl2_mdl_error_ua(fi, event, arg);\n\t\treturn;\n\t}\n\tdev_kfree_skb(skb);\n\tif (test_and_clear_bit(FLG_PEND_REL, &l2->flag))\n\t\tl2_disconnect(fi, event, NULL);\n\tif (test_and_clear_bit(FLG_L3_INIT, &l2->flag)) {\n\t\tpr = DL_ESTABLISH_CNF;\n\t} else if (l2->vs != l2->va) {\n\t\tskb_queue_purge(&l2->i_queue);\n\t\tpr = DL_ESTABLISH_IND;\n\t}\n\tstop_t200(l2, 5);\n\tl2->vr = 0;\n\tl2->vs = 0;\n\tl2->va = 0;\n\tl2->sow = 0;\n\tmISDN_FsmChangeState(fi, ST_L2_7);\n\tmISDN_FsmAddTimer(&l2->t203, l2->T203, EV_L2_T203, NULL, 4);\n\tif (pr != -1)\n\t\tl2up_create(l2, pr, 0, NULL);\n\n\tif (skb_queue_len(&l2->i_queue) && cansend(l2))\n\t\tmISDN_FsmEvent(fi, EV_L2_ACK_PULL, NULL);\n\n\tif (l2->tm)\n\t\tl2_tei(l2, MDL_STATUS_UP_IND, 0);\n}\n\nstatic void\nl2_released(struct FsmInst *fi, int event, void *arg)\n{\n\tstruct layer2 *l2 = fi->userdata;\n\tstruct sk_buff *skb = arg;\n\n\tif (!get_PollFlag(l2, skb)) {\n\t\tl2_mdl_error_ua(fi, event, arg);\n\t\treturn;\n\t}\n\tdev_kfree_skb(skb);\n\tstop_t200(l2, 6);\n\tlapb_dl_release_l2l3(l2, DL_RELEASE_CNF);\n\tmISDN_FsmChangeState(fi, ST_L2_4);\n\tif (l2->tm)\n\t\tl2_tei(l2, MDL_STATUS_DOWN_IND, 0);\n}\n\nstatic void\nl2_reestablish(struct FsmInst *fi, int event, void *arg)\n{\n\tstruct layer2 *l2 = fi->userdata;\n\tstruct sk_buff *skb = arg;\n\n\tif (!get_PollFlagFree(l2, skb)) {\n\t\testablishlink(fi);\n\t\ttest_and_set_bit(FLG_L3_INIT, &l2->flag);\n\t}\n}\n\nstatic void\nl2_st5_dm_release(struct FsmInst *fi, int event, void *arg)\n{\n\tstruct layer2 *l2 = fi->userdata;\n\tstruct sk_buff *skb = arg;\n\n\tif (get_PollFlagFree(l2, skb)) {\n\t\tstop_t200(l2, 7);\n\t\tif (!test_bit(FLG_L3_INIT, &l2->flag))\n\t\t\tskb_queue_purge(&l2->i_queue);\n\t\tif (test_bit(FLG_LAPB, &l2->flag))\n\t\t\tl2down_create(l2, PH_DEACTIVATE_REQ,\n\t\t\t\t      l2_newid(l2), 0, NULL);\n\t\tst5_dl_release_l2l3(l2);\n\t\tmISDN_FsmChangeState(fi, ST_L2_4);\n\t\tif (l2->tm)\n\t\t\tl2_tei(l2, MDL_STATUS_DOWN_IND, 0);\n\t}\n}\n\nstatic void\nl2_st6_dm_release(struct FsmInst *fi, int event, void *arg)\n{\n\tstruct layer2 *l2 = fi->userdata;\n\tstruct sk_buff *skb = arg;\n\n\tif (get_PollFlagFree(l2, skb)) {\n\t\tstop_t200(l2, 8);\n\t\tlapb_dl_release_l2l3(l2, DL_RELEASE_CNF);\n\t\tmISDN_FsmChangeState(fi, ST_L2_4);\n\t\tif (l2->tm)\n\t\t\tl2_tei(l2, MDL_STATUS_DOWN_IND, 0);\n\t}\n}\n\nstatic void\nenquiry_cr(struct layer2 *l2, u_char typ, u_char cr, u_char pf)\n{\n\tstruct sk_buff *skb;\n\tu_char tmp[MAX_L2HEADER_LEN];\n\tint i;\n\n\ti = sethdraddr(l2, tmp, cr);\n\tif (test_bit(FLG_MOD128, &l2->flag)) {\n\t\ttmp[i++] = typ;\n\t\ttmp[i++] = (l2->vr << 1) | (pf ? 1 : 0);\n\t} else\n\t\ttmp[i++] = (l2->vr << 5) | typ | (pf ? 0x10 : 0);\n\tskb = mI_alloc_skb(i, GFP_ATOMIC);\n\tif (!skb) {\n\t\tprintk(KERN_WARNING \"%s: isdnl2 can't alloc sbbuff in %s\\n\",\n\t\t       mISDNDevName4ch(&l2->ch), __func__);\n\t\treturn;\n\t}\n\tskb_put_data(skb, tmp, i);\n\tenqueue_super(l2, skb);\n}\n\ninline void\nenquiry_response(struct layer2 *l2)\n{\n\tif (test_bit(FLG_OWN_BUSY, &l2->flag))\n\t\tenquiry_cr(l2, RNR, RSP, 1);\n\telse\n\t\tenquiry_cr(l2, RR, RSP, 1);\n\ttest_and_clear_bit(FLG_ACK_PEND, &l2->flag);\n}\n\ninline void\ntransmit_enquiry(struct layer2 *l2)\n{\n\tif (test_bit(FLG_OWN_BUSY, &l2->flag))\n\t\tenquiry_cr(l2, RNR, CMD, 1);\n\telse\n\t\tenquiry_cr(l2, RR, CMD, 1);\n\ttest_and_clear_bit(FLG_ACK_PEND, &l2->flag);\n\tstart_t200(l2, 9);\n}\n\n\nstatic void\nnrerrorrecovery(struct FsmInst *fi)\n{\n\tstruct layer2 *l2 = fi->userdata;\n\n\tl2mgr(l2, MDL_ERROR_IND, (void *) 'J');\n\testablishlink(fi);\n\ttest_and_clear_bit(FLG_L3_INIT, &l2->flag);\n}\n\nstatic void\ninvoke_retransmission(struct layer2 *l2, unsigned int nr)\n{\n\tu_int\tp1;\n\n\tif (l2->vs != nr) {\n\t\twhile (l2->vs != nr) {\n\t\t\t(l2->vs)--;\n\t\t\tif (test_bit(FLG_MOD128, &l2->flag)) {\n\t\t\t\tl2->vs %= 128;\n\t\t\t\tp1 = (l2->vs - l2->va) % 128;\n\t\t\t} else {\n\t\t\t\tl2->vs %= 8;\n\t\t\t\tp1 = (l2->vs - l2->va) % 8;\n\t\t\t}\n\t\t\tp1 = (p1 + l2->sow) % l2->window;\n\t\t\tif (l2->windowar[p1])\n\t\t\t\tskb_queue_head(&l2->i_queue, l2->windowar[p1]);\n\t\t\telse\n\t\t\t\tprintk(KERN_WARNING\n\t\t\t\t       \"%s: windowar[%d] is NULL\\n\",\n\t\t\t\t       mISDNDevName4ch(&l2->ch), p1);\n\t\t\tl2->windowar[p1] = NULL;\n\t\t}\n\t\tmISDN_FsmEvent(&l2->l2m, EV_L2_ACK_PULL, NULL);\n\t}\n}\n\nstatic void\nl2_st7_got_super(struct FsmInst *fi, int event, void *arg)\n{\n\tstruct layer2 *l2 = fi->userdata;\n\tstruct sk_buff *skb = arg;\n\tint PollFlag, rsp, typ = RR;\n\tunsigned int nr;\n\n\trsp = *skb->data & 0x2;\n\tif (test_bit(FLG_ORIG, &l2->flag))\n\t\trsp = !rsp;\n\n\tskb_pull(skb, l2addrsize(l2));\n\tif (IsRNR(skb->data, l2)) {\n\t\tset_peer_busy(l2);\n\t\ttyp = RNR;\n\t} else\n\t\tclear_peer_busy(l2);\n\tif (IsREJ(skb->data, l2))\n\t\ttyp = REJ;\n\n\tif (test_bit(FLG_MOD128, &l2->flag)) {\n\t\tPollFlag = (skb->data[1] & 0x1) == 0x1;\n\t\tnr = skb->data[1] >> 1;\n\t} else {\n\t\tPollFlag = (skb->data[0] & 0x10);\n\t\tnr = (skb->data[0] >> 5) & 0x7;\n\t}\n\tdev_kfree_skb(skb);\n\n\tif (PollFlag) {\n\t\tif (rsp)\n\t\t\tl2mgr(l2, MDL_ERROR_IND, (void *) 'A');\n\t\telse\n\t\t\tenquiry_response(l2);\n\t}\n\tif (legalnr(l2, nr)) {\n\t\tif (typ == REJ) {\n\t\t\tsetva(l2, nr);\n\t\t\tinvoke_retransmission(l2, nr);\n\t\t\tstop_t200(l2, 10);\n\t\t\tif (mISDN_FsmAddTimer(&l2->t203, l2->T203,\n\t\t\t\t\t      EV_L2_T203, NULL, 6))\n\t\t\t\tl2m_debug(&l2->l2m, \"Restart T203 ST7 REJ\");\n\t\t} else if ((nr == l2->vs) && (typ == RR)) {\n\t\t\tsetva(l2, nr);\n\t\t\tstop_t200(l2, 11);\n\t\t\tmISDN_FsmRestartTimer(&l2->t203, l2->T203,\n\t\t\t\t\t      EV_L2_T203, NULL, 7);\n\t\t} else if ((l2->va != nr) || (typ == RNR)) {\n\t\t\tsetva(l2, nr);\n\t\t\tif (typ != RR)\n\t\t\t\tmISDN_FsmDelTimer(&l2->t203, 9);\n\t\t\trestart_t200(l2, 12);\n\t\t}\n\t\tif (skb_queue_len(&l2->i_queue) && (typ == RR))\n\t\t\tmISDN_FsmEvent(fi, EV_L2_ACK_PULL, NULL);\n\t} else\n\t\tnrerrorrecovery(fi);\n}\n\nstatic void\nl2_feed_i_if_reest(struct FsmInst *fi, int event, void *arg)\n{\n\tstruct layer2 *l2 = fi->userdata;\n\tstruct sk_buff *skb = arg;\n\n\tif (!test_bit(FLG_L3_INIT, &l2->flag))\n\t\tskb_queue_tail(&l2->i_queue, skb);\n\telse\n\t\tdev_kfree_skb(skb);\n}\n\nstatic void\nl2_feed_i_pull(struct FsmInst *fi, int event, void *arg)\n{\n\tstruct layer2 *l2 = fi->userdata;\n\tstruct sk_buff *skb = arg;\n\n\tskb_queue_tail(&l2->i_queue, skb);\n\tmISDN_FsmEvent(fi, EV_L2_ACK_PULL, NULL);\n}\n\nstatic void\nl2_feed_iqueue(struct FsmInst *fi, int event, void *arg)\n{\n\tstruct layer2 *l2 = fi->userdata;\n\tstruct sk_buff *skb = arg;\n\n\tskb_queue_tail(&l2->i_queue, skb);\n}\n\nstatic void\nl2_got_iframe(struct FsmInst *fi, int event, void *arg)\n{\n\tstruct layer2\t*l2 = fi->userdata;\n\tstruct sk_buff\t*skb = arg;\n\tint\t\tPollFlag, i;\n\tu_int\t\tns, nr;\n\n\ti = l2addrsize(l2);\n\tif (test_bit(FLG_MOD128, &l2->flag)) {\n\t\tPollFlag = ((skb->data[i + 1] & 0x1) == 0x1);\n\t\tns = skb->data[i] >> 1;\n\t\tnr = (skb->data[i + 1] >> 1) & 0x7f;\n\t} else {\n\t\tPollFlag = (skb->data[i] & 0x10);\n\t\tns = (skb->data[i] >> 1) & 0x7;\n\t\tnr = (skb->data[i] >> 5) & 0x7;\n\t}\n\tif (test_bit(FLG_OWN_BUSY, &l2->flag)) {\n\t\tdev_kfree_skb(skb);\n\t\tif (PollFlag)\n\t\t\tenquiry_response(l2);\n\t} else {\n\t\tif (l2->vr == ns) {\n\t\t\tl2->vr++;\n\t\t\tif (test_bit(FLG_MOD128, &l2->flag))\n\t\t\t\tl2->vr %= 128;\n\t\t\telse\n\t\t\t\tl2->vr %= 8;\n\t\t\ttest_and_clear_bit(FLG_REJEXC, &l2->flag);\n\t\t\tif (PollFlag)\n\t\t\t\tenquiry_response(l2);\n\t\t\telse\n\t\t\t\ttest_and_set_bit(FLG_ACK_PEND, &l2->flag);\n\t\t\tskb_pull(skb, l2headersize(l2, 0));\n\t\t\tl2up(l2, DL_DATA_IND, skb);\n\t\t} else {\n\t\t\t \n\t\t\tdev_kfree_skb(skb);\n\t\t\tif (test_and_set_bit(FLG_REJEXC, &l2->flag)) {\n\t\t\t\tif (PollFlag)\n\t\t\t\t\tenquiry_response(l2);\n\t\t\t} else {\n\t\t\t\tenquiry_cr(l2, REJ, RSP, PollFlag);\n\t\t\t\ttest_and_clear_bit(FLG_ACK_PEND, &l2->flag);\n\t\t\t}\n\t\t}\n\t}\n\tif (legalnr(l2, nr)) {\n\t\tif (!test_bit(FLG_PEER_BUSY, &l2->flag) &&\n\t\t    (fi->state == ST_L2_7)) {\n\t\t\tif (nr == l2->vs) {\n\t\t\t\tstop_t200(l2, 13);\n\t\t\t\tmISDN_FsmRestartTimer(&l2->t203, l2->T203,\n\t\t\t\t\t\t      EV_L2_T203, NULL, 7);\n\t\t\t} else if (nr != l2->va)\n\t\t\t\trestart_t200(l2, 14);\n\t\t}\n\t\tsetva(l2, nr);\n\t} else {\n\t\tnrerrorrecovery(fi);\n\t\treturn;\n\t}\n\tif (skb_queue_len(&l2->i_queue) && (fi->state == ST_L2_7))\n\t\tmISDN_FsmEvent(fi, EV_L2_ACK_PULL, NULL);\n\tif (test_and_clear_bit(FLG_ACK_PEND, &l2->flag))\n\t\tenquiry_cr(l2, RR, RSP, 0);\n}\n\nstatic void\nl2_got_tei(struct FsmInst *fi, int event, void *arg)\n{\n\tstruct layer2\t*l2 = fi->userdata;\n\tu_int\t\tinfo;\n\n\tl2->tei = (signed char)(long)arg;\n\tset_channel_address(&l2->ch, l2->sapi, l2->tei);\n\tinfo = DL_INFO_L2_CONNECT;\n\tl2up_create(l2, DL_INFORMATION_IND, sizeof(info), &info);\n\tif (fi->state == ST_L2_3) {\n\t\testablishlink(fi);\n\t\ttest_and_set_bit(FLG_L3_INIT, &l2->flag);\n\t} else\n\t\tmISDN_FsmChangeState(fi, ST_L2_4);\n\tif (skb_queue_len(&l2->ui_queue))\n\t\ttx_ui(l2);\n}\n\nstatic void\nl2_st5_tout_200(struct FsmInst *fi, int event, void *arg)\n{\n\tstruct layer2 *l2 = fi->userdata;\n\n\tif (test_bit(FLG_LAPD, &l2->flag) &&\n\t    test_bit(FLG_DCHAN_BUSY, &l2->flag)) {\n\t\tmISDN_FsmAddTimer(&l2->t200, l2->T200, EV_L2_T200, NULL, 9);\n\t} else if (l2->rc == l2->N200) {\n\t\tmISDN_FsmChangeState(fi, ST_L2_4);\n\t\ttest_and_clear_bit(FLG_T200_RUN, &l2->flag);\n\t\tskb_queue_purge(&l2->i_queue);\n\t\tl2mgr(l2, MDL_ERROR_IND, (void *) 'G');\n\t\tif (test_bit(FLG_LAPB, &l2->flag))\n\t\t\tl2down_create(l2, PH_DEACTIVATE_REQ,\n\t\t\t\t      l2_newid(l2), 0, NULL);\n\t\tst5_dl_release_l2l3(l2);\n\t\tif (l2->tm)\n\t\t\tl2_tei(l2, MDL_STATUS_DOWN_IND, 0);\n\t} else {\n\t\tl2->rc++;\n\t\tmISDN_FsmAddTimer(&l2->t200, l2->T200, EV_L2_T200, NULL, 9);\n\t\tsend_uframe(l2, NULL, (test_bit(FLG_MOD128, &l2->flag) ?\n\t\t\t\t       SABME : SABM) | 0x10, CMD);\n\t}\n}\n\nstatic void\nl2_st6_tout_200(struct FsmInst *fi, int event, void *arg)\n{\n\tstruct layer2 *l2 = fi->userdata;\n\n\tif (test_bit(FLG_LAPD, &l2->flag) &&\n\t    test_bit(FLG_DCHAN_BUSY, &l2->flag)) {\n\t\tmISDN_FsmAddTimer(&l2->t200, l2->T200, EV_L2_T200, NULL, 9);\n\t} else if (l2->rc == l2->N200) {\n\t\tmISDN_FsmChangeState(fi, ST_L2_4);\n\t\ttest_and_clear_bit(FLG_T200_RUN, &l2->flag);\n\t\tl2mgr(l2, MDL_ERROR_IND, (void *) 'H');\n\t\tlapb_dl_release_l2l3(l2, DL_RELEASE_CNF);\n\t\tif (l2->tm)\n\t\t\tl2_tei(l2, MDL_STATUS_DOWN_IND, 0);\n\t} else {\n\t\tl2->rc++;\n\t\tmISDN_FsmAddTimer(&l2->t200, l2->T200, EV_L2_T200,\n\t\t\t\t  NULL, 9);\n\t\tsend_uframe(l2, NULL, DISC | 0x10, CMD);\n\t}\n}\n\nstatic void\nl2_st7_tout_200(struct FsmInst *fi, int event, void *arg)\n{\n\tstruct layer2 *l2 = fi->userdata;\n\n\tif (test_bit(FLG_LAPD, &l2->flag) &&\n\t    test_bit(FLG_DCHAN_BUSY, &l2->flag)) {\n\t\tmISDN_FsmAddTimer(&l2->t200, l2->T200, EV_L2_T200, NULL, 9);\n\t\treturn;\n\t}\n\ttest_and_clear_bit(FLG_T200_RUN, &l2->flag);\n\tl2->rc = 0;\n\tmISDN_FsmChangeState(fi, ST_L2_8);\n\ttransmit_enquiry(l2);\n\tl2->rc++;\n}\n\nstatic void\nl2_st8_tout_200(struct FsmInst *fi, int event, void *arg)\n{\n\tstruct layer2 *l2 = fi->userdata;\n\n\tif (test_bit(FLG_LAPD, &l2->flag) &&\n\t    test_bit(FLG_DCHAN_BUSY, &l2->flag)) {\n\t\tmISDN_FsmAddTimer(&l2->t200, l2->T200, EV_L2_T200, NULL, 9);\n\t\treturn;\n\t}\n\ttest_and_clear_bit(FLG_T200_RUN, &l2->flag);\n\tif (l2->rc == l2->N200) {\n\t\tl2mgr(l2, MDL_ERROR_IND, (void *) 'I');\n\t\testablishlink(fi);\n\t\ttest_and_clear_bit(FLG_L3_INIT, &l2->flag);\n\t} else {\n\t\ttransmit_enquiry(l2);\n\t\tl2->rc++;\n\t}\n}\n\nstatic void\nl2_st7_tout_203(struct FsmInst *fi, int event, void *arg)\n{\n\tstruct layer2 *l2 = fi->userdata;\n\n\tif (test_bit(FLG_LAPD, &l2->flag) &&\n\t    test_bit(FLG_DCHAN_BUSY, &l2->flag)) {\n\t\tmISDN_FsmAddTimer(&l2->t203, l2->T203, EV_L2_T203, NULL, 9);\n\t\treturn;\n\t}\n\tmISDN_FsmChangeState(fi, ST_L2_8);\n\ttransmit_enquiry(l2);\n\tl2->rc = 0;\n}\n\nstatic void\nl2_pull_iqueue(struct FsmInst *fi, int event, void *arg)\n{\n\tstruct layer2\t*l2 = fi->userdata;\n\tstruct sk_buff\t*skb, *nskb;\n\tu_char\t\theader[MAX_L2HEADER_LEN];\n\tu_int\t\ti, p1;\n\n\tif (!cansend(l2))\n\t\treturn;\n\n\tskb = skb_dequeue(&l2->i_queue);\n\tif (!skb)\n\t\treturn;\n\ti = sethdraddr(l2, header, CMD);\n\tif (test_bit(FLG_MOD128, &l2->flag)) {\n\t\theader[i++] = l2->vs << 1;\n\t\theader[i++] = l2->vr << 1;\n\t} else\n\t\theader[i++] = (l2->vr << 5) | (l2->vs << 1);\n\tnskb = skb_realloc_headroom(skb, i);\n\tif (!nskb) {\n\t\tprintk(KERN_WARNING \"%s: no headroom(%d) copy for IFrame\\n\",\n\t\t       mISDNDevName4ch(&l2->ch), i);\n\t\tskb_queue_head(&l2->i_queue, skb);\n\t\treturn;\n\t}\n\tif (test_bit(FLG_MOD128, &l2->flag)) {\n\t\tp1 = (l2->vs - l2->va) % 128;\n\t\tl2->vs = (l2->vs + 1) % 128;\n\t} else {\n\t\tp1 = (l2->vs - l2->va) % 8;\n\t\tl2->vs = (l2->vs + 1) % 8;\n\t}\n\tp1 = (p1 + l2->sow) % l2->window;\n\tif (l2->windowar[p1]) {\n\t\tprintk(KERN_WARNING \"%s: l2 try overwrite ack queue entry %d\\n\",\n\t\t       mISDNDevName4ch(&l2->ch), p1);\n\t\tdev_kfree_skb(l2->windowar[p1]);\n\t}\n\tl2->windowar[p1] = skb;\n\tmemcpy(skb_push(nskb, i), header, i);\n\tl2down(l2, PH_DATA_REQ, l2_newid(l2), nskb);\n\ttest_and_clear_bit(FLG_ACK_PEND, &l2->flag);\n\tif (!test_and_set_bit(FLG_T200_RUN, &l2->flag)) {\n\t\tmISDN_FsmDelTimer(&l2->t203, 13);\n\t\tmISDN_FsmAddTimer(&l2->t200, l2->T200, EV_L2_T200, NULL, 11);\n\t}\n}\n\nstatic void\nl2_st8_got_super(struct FsmInst *fi, int event, void *arg)\n{\n\tstruct layer2 *l2 = fi->userdata;\n\tstruct sk_buff *skb = arg;\n\tint PollFlag, rsp, rnr = 0;\n\tunsigned int nr;\n\n\trsp = *skb->data & 0x2;\n\tif (test_bit(FLG_ORIG, &l2->flag))\n\t\trsp = !rsp;\n\n\tskb_pull(skb, l2addrsize(l2));\n\n\tif (IsRNR(skb->data, l2)) {\n\t\tset_peer_busy(l2);\n\t\trnr = 1;\n\t} else\n\t\tclear_peer_busy(l2);\n\n\tif (test_bit(FLG_MOD128, &l2->flag)) {\n\t\tPollFlag = (skb->data[1] & 0x1) == 0x1;\n\t\tnr = skb->data[1] >> 1;\n\t} else {\n\t\tPollFlag = (skb->data[0] & 0x10);\n\t\tnr = (skb->data[0] >> 5) & 0x7;\n\t}\n\tdev_kfree_skb(skb);\n\tif (rsp && PollFlag) {\n\t\tif (legalnr(l2, nr)) {\n\t\t\tif (rnr) {\n\t\t\t\trestart_t200(l2, 15);\n\t\t\t} else {\n\t\t\t\tstop_t200(l2, 16);\n\t\t\t\tmISDN_FsmAddTimer(&l2->t203, l2->T203,\n\t\t\t\t\t\t  EV_L2_T203, NULL, 5);\n\t\t\t\tsetva(l2, nr);\n\t\t\t}\n\t\t\tinvoke_retransmission(l2, nr);\n\t\t\tmISDN_FsmChangeState(fi, ST_L2_7);\n\t\t\tif (skb_queue_len(&l2->i_queue) && cansend(l2))\n\t\t\t\tmISDN_FsmEvent(fi, EV_L2_ACK_PULL, NULL);\n\t\t} else\n\t\t\tnrerrorrecovery(fi);\n\t} else {\n\t\tif (!rsp && PollFlag)\n\t\t\tenquiry_response(l2);\n\t\tif (legalnr(l2, nr))\n\t\t\tsetva(l2, nr);\n\t\telse\n\t\t\tnrerrorrecovery(fi);\n\t}\n}\n\nstatic void\nl2_got_FRMR(struct FsmInst *fi, int event, void *arg)\n{\n\tstruct layer2 *l2 = fi->userdata;\n\tstruct sk_buff *skb = arg;\n\n\tskb_pull(skb, l2addrsize(l2) + 1);\n\n\tif (!(skb->data[0] & 1) || ((skb->data[0] & 3) == 1) ||  \n\t    (IsUA(skb->data) && (fi->state == ST_L2_7))) {\n\t\tl2mgr(l2, MDL_ERROR_IND, (void *) 'K');\n\t\testablishlink(fi);\n\t\ttest_and_clear_bit(FLG_L3_INIT, &l2->flag);\n\t}\n\tdev_kfree_skb(skb);\n}\n\nstatic void\nl2_st24_tei_remove(struct FsmInst *fi, int event, void *arg)\n{\n\tstruct layer2 *l2 = fi->userdata;\n\n\tskb_queue_purge(&l2->ui_queue);\n\tl2->tei = GROUP_TEI;\n\tmISDN_FsmChangeState(fi, ST_L2_1);\n}\n\nstatic void\nl2_st3_tei_remove(struct FsmInst *fi, int event, void *arg)\n{\n\tstruct layer2 *l2 = fi->userdata;\n\n\tskb_queue_purge(&l2->ui_queue);\n\tl2->tei = GROUP_TEI;\n\tl2up_create(l2, DL_RELEASE_IND, 0, NULL);\n\tmISDN_FsmChangeState(fi, ST_L2_1);\n}\n\nstatic void\nl2_st5_tei_remove(struct FsmInst *fi, int event, void *arg)\n{\n\tstruct layer2 *l2 = fi->userdata;\n\n\tskb_queue_purge(&l2->i_queue);\n\tskb_queue_purge(&l2->ui_queue);\n\tfreewin(l2);\n\tl2->tei = GROUP_TEI;\n\tstop_t200(l2, 17);\n\tst5_dl_release_l2l3(l2);\n\tmISDN_FsmChangeState(fi, ST_L2_1);\n}\n\nstatic void\nl2_st6_tei_remove(struct FsmInst *fi, int event, void *arg)\n{\n\tstruct layer2 *l2 = fi->userdata;\n\n\tskb_queue_purge(&l2->ui_queue);\n\tl2->tei = GROUP_TEI;\n\tstop_t200(l2, 18);\n\tl2up_create(l2, DL_RELEASE_IND, 0, NULL);\n\tmISDN_FsmChangeState(fi, ST_L2_1);\n}\n\nstatic void\nl2_tei_remove(struct FsmInst *fi, int event, void *arg)\n{\n\tstruct layer2 *l2 = fi->userdata;\n\n\tskb_queue_purge(&l2->i_queue);\n\tskb_queue_purge(&l2->ui_queue);\n\tfreewin(l2);\n\tl2->tei = GROUP_TEI;\n\tstop_t200(l2, 17);\n\tmISDN_FsmDelTimer(&l2->t203, 19);\n\tl2up_create(l2, DL_RELEASE_IND, 0, NULL);\n \n\tmISDN_FsmChangeState(fi, ST_L2_1);\n}\n\nstatic void\nl2_st14_persistent_da(struct FsmInst *fi, int event, void *arg)\n{\n\tstruct layer2 *l2 = fi->userdata;\n\tstruct sk_buff *skb = arg;\n\n\tskb_queue_purge(&l2->i_queue);\n\tskb_queue_purge(&l2->ui_queue);\n\tif (test_and_clear_bit(FLG_ESTAB_PEND, &l2->flag))\n\t\tl2up(l2, DL_RELEASE_IND, skb);\n\telse\n\t\tdev_kfree_skb(skb);\n}\n\nstatic void\nl2_st5_persistent_da(struct FsmInst *fi, int event, void *arg)\n{\n\tstruct layer2 *l2 = fi->userdata;\n\tstruct sk_buff *skb = arg;\n\n\tskb_queue_purge(&l2->i_queue);\n\tskb_queue_purge(&l2->ui_queue);\n\tfreewin(l2);\n\tstop_t200(l2, 19);\n\tst5_dl_release_l2l3(l2);\n\tmISDN_FsmChangeState(fi, ST_L2_4);\n\tif (l2->tm)\n\t\tl2_tei(l2, MDL_STATUS_DOWN_IND, 0);\n\tdev_kfree_skb(skb);\n}\n\nstatic void\nl2_st6_persistent_da(struct FsmInst *fi, int event, void *arg)\n{\n\tstruct layer2 *l2 = fi->userdata;\n\tstruct sk_buff *skb = arg;\n\n\tskb_queue_purge(&l2->ui_queue);\n\tstop_t200(l2, 20);\n\tl2up(l2, DL_RELEASE_CNF, skb);\n\tmISDN_FsmChangeState(fi, ST_L2_4);\n\tif (l2->tm)\n\t\tl2_tei(l2, MDL_STATUS_DOWN_IND, 0);\n}\n\nstatic void\nl2_persistent_da(struct FsmInst *fi, int event, void *arg)\n{\n\tstruct layer2 *l2 = fi->userdata;\n\tstruct sk_buff *skb = arg;\n\n\tskb_queue_purge(&l2->i_queue);\n\tskb_queue_purge(&l2->ui_queue);\n\tfreewin(l2);\n\tstop_t200(l2, 19);\n\tmISDN_FsmDelTimer(&l2->t203, 19);\n\tl2up(l2, DL_RELEASE_IND, skb);\n\tmISDN_FsmChangeState(fi, ST_L2_4);\n\tif (l2->tm)\n\t\tl2_tei(l2, MDL_STATUS_DOWN_IND, 0);\n}\n\nstatic void\nl2_set_own_busy(struct FsmInst *fi, int event, void *arg)\n{\n\tstruct layer2 *l2 = fi->userdata;\n\tstruct sk_buff *skb = arg;\n\n\tif (!test_and_set_bit(FLG_OWN_BUSY, &l2->flag)) {\n\t\tenquiry_cr(l2, RNR, RSP, 0);\n\t\ttest_and_clear_bit(FLG_ACK_PEND, &l2->flag);\n\t}\n\tdev_kfree_skb(skb);\n}\n\nstatic void\nl2_clear_own_busy(struct FsmInst *fi, int event, void *arg)\n{\n\tstruct layer2 *l2 = fi->userdata;\n\tstruct sk_buff *skb = arg;\n\n\tif (!test_and_clear_bit(FLG_OWN_BUSY, &l2->flag)) {\n\t\tenquiry_cr(l2, RR, RSP, 0);\n\t\ttest_and_clear_bit(FLG_ACK_PEND, &l2->flag);\n\t}\n\tdev_kfree_skb(skb);\n}\n\nstatic void\nl2_frame_error(struct FsmInst *fi, int event, void *arg)\n{\n\tstruct layer2 *l2 = fi->userdata;\n\n\tl2mgr(l2, MDL_ERROR_IND, arg);\n}\n\nstatic void\nl2_frame_error_reest(struct FsmInst *fi, int event, void *arg)\n{\n\tstruct layer2 *l2 = fi->userdata;\n\n\tl2mgr(l2, MDL_ERROR_IND, arg);\n\testablishlink(fi);\n\ttest_and_clear_bit(FLG_L3_INIT, &l2->flag);\n}\n\nstatic struct FsmNode L2FnList[] =\n{\n\t{ST_L2_1, EV_L2_DL_ESTABLISH_REQ, l2_mdl_assign},\n\t{ST_L2_2, EV_L2_DL_ESTABLISH_REQ, l2_go_st3},\n\t{ST_L2_4, EV_L2_DL_ESTABLISH_REQ, l2_establish},\n\t{ST_L2_5, EV_L2_DL_ESTABLISH_REQ, l2_discard_i_setl3},\n\t{ST_L2_7, EV_L2_DL_ESTABLISH_REQ, l2_l3_reestablish},\n\t{ST_L2_8, EV_L2_DL_ESTABLISH_REQ, l2_l3_reestablish},\n\t{ST_L2_4, EV_L2_DL_RELEASE_REQ, l2_release},\n\t{ST_L2_5, EV_L2_DL_RELEASE_REQ, l2_pend_rel},\n\t{ST_L2_7, EV_L2_DL_RELEASE_REQ, l2_disconnect},\n\t{ST_L2_8, EV_L2_DL_RELEASE_REQ, l2_disconnect},\n\t{ST_L2_5, EV_L2_DL_DATA, l2_feed_i_if_reest},\n\t{ST_L2_7, EV_L2_DL_DATA, l2_feed_i_pull},\n\t{ST_L2_8, EV_L2_DL_DATA, l2_feed_iqueue},\n\t{ST_L2_1, EV_L2_DL_UNITDATA, l2_queue_ui_assign},\n\t{ST_L2_2, EV_L2_DL_UNITDATA, l2_queue_ui},\n\t{ST_L2_3, EV_L2_DL_UNITDATA, l2_queue_ui},\n\t{ST_L2_4, EV_L2_DL_UNITDATA, l2_send_ui},\n\t{ST_L2_5, EV_L2_DL_UNITDATA, l2_send_ui},\n\t{ST_L2_6, EV_L2_DL_UNITDATA, l2_send_ui},\n\t{ST_L2_7, EV_L2_DL_UNITDATA, l2_send_ui},\n\t{ST_L2_8, EV_L2_DL_UNITDATA, l2_send_ui},\n\t{ST_L2_1, EV_L2_MDL_ASSIGN, l2_got_tei},\n\t{ST_L2_2, EV_L2_MDL_ASSIGN, l2_got_tei},\n\t{ST_L2_3, EV_L2_MDL_ASSIGN, l2_got_tei},\n\t{ST_L2_2, EV_L2_MDL_ERROR, l2_st24_tei_remove},\n\t{ST_L2_3, EV_L2_MDL_ERROR, l2_st3_tei_remove},\n\t{ST_L2_4, EV_L2_MDL_REMOVE, l2_st24_tei_remove},\n\t{ST_L2_5, EV_L2_MDL_REMOVE, l2_st5_tei_remove},\n\t{ST_L2_6, EV_L2_MDL_REMOVE, l2_st6_tei_remove},\n\t{ST_L2_7, EV_L2_MDL_REMOVE, l2_tei_remove},\n\t{ST_L2_8, EV_L2_MDL_REMOVE, l2_tei_remove},\n\t{ST_L2_4, EV_L2_SABME, l2_start_multi},\n\t{ST_L2_5, EV_L2_SABME, l2_send_UA},\n\t{ST_L2_6, EV_L2_SABME, l2_send_DM},\n\t{ST_L2_7, EV_L2_SABME, l2_restart_multi},\n\t{ST_L2_8, EV_L2_SABME, l2_restart_multi},\n\t{ST_L2_4, EV_L2_DISC, l2_send_DM},\n\t{ST_L2_5, EV_L2_DISC, l2_send_DM},\n\t{ST_L2_6, EV_L2_DISC, l2_send_UA},\n\t{ST_L2_7, EV_L2_DISC, l2_stop_multi},\n\t{ST_L2_8, EV_L2_DISC, l2_stop_multi},\n\t{ST_L2_4, EV_L2_UA, l2_mdl_error_ua},\n\t{ST_L2_5, EV_L2_UA, l2_connected},\n\t{ST_L2_6, EV_L2_UA, l2_released},\n\t{ST_L2_7, EV_L2_UA, l2_mdl_error_ua},\n\t{ST_L2_8, EV_L2_UA, l2_mdl_error_ua},\n\t{ST_L2_4, EV_L2_DM, l2_reestablish},\n\t{ST_L2_5, EV_L2_DM, l2_st5_dm_release},\n\t{ST_L2_6, EV_L2_DM, l2_st6_dm_release},\n\t{ST_L2_7, EV_L2_DM, l2_mdl_error_dm},\n\t{ST_L2_8, EV_L2_DM, l2_st8_mdl_error_dm},\n\t{ST_L2_1, EV_L2_UI, l2_got_ui},\n\t{ST_L2_2, EV_L2_UI, l2_got_ui},\n\t{ST_L2_3, EV_L2_UI, l2_got_ui},\n\t{ST_L2_4, EV_L2_UI, l2_got_ui},\n\t{ST_L2_5, EV_L2_UI, l2_got_ui},\n\t{ST_L2_6, EV_L2_UI, l2_got_ui},\n\t{ST_L2_7, EV_L2_UI, l2_got_ui},\n\t{ST_L2_8, EV_L2_UI, l2_got_ui},\n\t{ST_L2_7, EV_L2_FRMR, l2_got_FRMR},\n\t{ST_L2_8, EV_L2_FRMR, l2_got_FRMR},\n\t{ST_L2_7, EV_L2_SUPER, l2_st7_got_super},\n\t{ST_L2_8, EV_L2_SUPER, l2_st8_got_super},\n\t{ST_L2_7, EV_L2_I, l2_got_iframe},\n\t{ST_L2_8, EV_L2_I, l2_got_iframe},\n\t{ST_L2_5, EV_L2_T200, l2_timeout},\n\t{ST_L2_6, EV_L2_T200, l2_timeout},\n\t{ST_L2_7, EV_L2_T200, l2_timeout},\n\t{ST_L2_8, EV_L2_T200, l2_timeout},\n\t{ST_L2_7, EV_L2_T203, l2_timeout},\n\t{ST_L2_5, EV_L2_T200I, l2_st5_tout_200},\n\t{ST_L2_6, EV_L2_T200I, l2_st6_tout_200},\n\t{ST_L2_7, EV_L2_T200I, l2_st7_tout_200},\n\t{ST_L2_8, EV_L2_T200I, l2_st8_tout_200},\n\t{ST_L2_7, EV_L2_T203I, l2_st7_tout_203},\n\t{ST_L2_7, EV_L2_ACK_PULL, l2_pull_iqueue},\n\t{ST_L2_7, EV_L2_SET_OWN_BUSY, l2_set_own_busy},\n\t{ST_L2_8, EV_L2_SET_OWN_BUSY, l2_set_own_busy},\n\t{ST_L2_7, EV_L2_CLEAR_OWN_BUSY, l2_clear_own_busy},\n\t{ST_L2_8, EV_L2_CLEAR_OWN_BUSY, l2_clear_own_busy},\n\t{ST_L2_4, EV_L2_FRAME_ERROR, l2_frame_error},\n\t{ST_L2_5, EV_L2_FRAME_ERROR, l2_frame_error},\n\t{ST_L2_6, EV_L2_FRAME_ERROR, l2_frame_error},\n\t{ST_L2_7, EV_L2_FRAME_ERROR, l2_frame_error_reest},\n\t{ST_L2_8, EV_L2_FRAME_ERROR, l2_frame_error_reest},\n\t{ST_L2_1, EV_L1_DEACTIVATE, l2_st14_persistent_da},\n\t{ST_L2_2, EV_L1_DEACTIVATE, l2_st24_tei_remove},\n\t{ST_L2_3, EV_L1_DEACTIVATE, l2_st3_tei_remove},\n\t{ST_L2_4, EV_L1_DEACTIVATE, l2_st14_persistent_da},\n\t{ST_L2_5, EV_L1_DEACTIVATE, l2_st5_persistent_da},\n\t{ST_L2_6, EV_L1_DEACTIVATE, l2_st6_persistent_da},\n\t{ST_L2_7, EV_L1_DEACTIVATE, l2_persistent_da},\n\t{ST_L2_8, EV_L1_DEACTIVATE, l2_persistent_da},\n};\n\nstatic int\nph_data_indication(struct layer2 *l2, struct mISDNhead *hh, struct sk_buff *skb)\n{\n\tu_char\t*datap = skb->data;\n\tint\tret = -EINVAL;\n\tint\tpsapi, ptei;\n\tu_int\tl;\n\tint\tc = 0;\n\n\tl = l2addrsize(l2);\n\tif (skb->len <= l) {\n\t\tmISDN_FsmEvent(&l2->l2m, EV_L2_FRAME_ERROR, (void *) 'N');\n\t\treturn ret;\n\t}\n\tif (test_bit(FLG_LAPD, &l2->flag)) {  \n\t\tpsapi = *datap++;\n\t\tptei = *datap++;\n\t\tif ((psapi & 1) || !(ptei & 1)) {\n\t\t\tprintk(KERN_WARNING\n\t\t\t       \"%s l2 D-channel frame wrong EA0/EA1\\n\",\n\t\t\t       mISDNDevName4ch(&l2->ch));\n\t\t\treturn ret;\n\t\t}\n\t\tpsapi >>= 2;\n\t\tptei >>= 1;\n\t\tif (psapi != l2->sapi) {\n\t\t\t \n\t\t\tif (*debug & DEBUG_L2)\n\t\t\t\tprintk(KERN_DEBUG \"%s: sapi %d/%d mismatch\\n\",\n\t\t\t\t       mISDNDevName4ch(&l2->ch), psapi,\n\t\t\t\t       l2->sapi);\n\t\t\tdev_kfree_skb(skb);\n\t\t\treturn 0;\n\t\t}\n\t\tif ((ptei != l2->tei) && (ptei != GROUP_TEI)) {\n\t\t\t \n\t\t\tif (*debug & DEBUG_L2)\n\t\t\t\tprintk(KERN_DEBUG \"%s: tei %d/%d mismatch\\n\",\n\t\t\t\t       mISDNDevName4ch(&l2->ch), ptei, l2->tei);\n\t\t\tdev_kfree_skb(skb);\n\t\t\treturn 0;\n\t\t}\n\t} else\n\t\tdatap += l;\n\tif (!(*datap & 1)) {\t \n\t\tc = iframe_error(l2, skb);\n\t\tif (!c)\n\t\t\tret = mISDN_FsmEvent(&l2->l2m, EV_L2_I, skb);\n\t} else if (IsSFrame(datap, l2)) {\t \n\t\tc = super_error(l2, skb);\n\t\tif (!c)\n\t\t\tret = mISDN_FsmEvent(&l2->l2m, EV_L2_SUPER, skb);\n\t} else if (IsUI(datap)) {\n\t\tc = UI_error(l2, skb);\n\t\tif (!c)\n\t\t\tret = mISDN_FsmEvent(&l2->l2m, EV_L2_UI, skb);\n\t} else if (IsSABME(datap, l2)) {\n\t\tc = unnum_error(l2, skb, CMD);\n\t\tif (!c)\n\t\t\tret = mISDN_FsmEvent(&l2->l2m, EV_L2_SABME, skb);\n\t} else if (IsUA(datap)) {\n\t\tc = unnum_error(l2, skb, RSP);\n\t\tif (!c)\n\t\t\tret = mISDN_FsmEvent(&l2->l2m, EV_L2_UA, skb);\n\t} else if (IsDISC(datap)) {\n\t\tc = unnum_error(l2, skb, CMD);\n\t\tif (!c)\n\t\t\tret = mISDN_FsmEvent(&l2->l2m, EV_L2_DISC, skb);\n\t} else if (IsDM(datap)) {\n\t\tc = unnum_error(l2, skb, RSP);\n\t\tif (!c)\n\t\t\tret = mISDN_FsmEvent(&l2->l2m, EV_L2_DM, skb);\n\t} else if (IsFRMR(datap)) {\n\t\tc = FRMR_error(l2, skb);\n\t\tif (!c)\n\t\t\tret = mISDN_FsmEvent(&l2->l2m, EV_L2_FRMR, skb);\n\t} else\n\t\tc = 'L';\n\tif (c) {\n\t\tprintk(KERN_WARNING \"%s:l2 D-channel frame error %c\\n\",\n\t\t       mISDNDevName4ch(&l2->ch), c);\n\t\tmISDN_FsmEvent(&l2->l2m, EV_L2_FRAME_ERROR, (void *)(long)c);\n\t}\n\treturn ret;\n}\n\nstatic int\nl2_send(struct mISDNchannel *ch, struct sk_buff *skb)\n{\n\tstruct layer2\t\t*l2 = container_of(ch, struct layer2, ch);\n\tstruct mISDNhead\t*hh =  mISDN_HEAD_P(skb);\n\tint\t\t\tret = -EINVAL;\n\n\tif (*debug & DEBUG_L2_RECV)\n\t\tprintk(KERN_DEBUG \"%s: %s prim(%x) id(%x) sapi(%d) tei(%d)\\n\",\n\t\t       __func__, mISDNDevName4ch(&l2->ch), hh->prim, hh->id,\n\t\t       l2->sapi, l2->tei);\n\tif (hh->prim == DL_INTERN_MSG) {\n\t\tstruct mISDNhead *chh = hh + 1;  \n\n\t\t*hh = *chh;\n\t\tif (*debug & DEBUG_L2_RECV)\n\t\t\tprintk(KERN_DEBUG \"%s: prim(%x) id(%x) internal msg\\n\",\n\t\t\t\tmISDNDevName4ch(&l2->ch), hh->prim, hh->id);\n\t}\n\tswitch (hh->prim) {\n\tcase PH_DATA_IND:\n\t\tret = ph_data_indication(l2, hh, skb);\n\t\tbreak;\n\tcase PH_DATA_CNF:\n\t\tret = ph_data_confirm(l2, hh, skb);\n\t\tbreak;\n\tcase PH_ACTIVATE_IND:\n\t\ttest_and_set_bit(FLG_L1_ACTIV, &l2->flag);\n\t\tl2up_create(l2, MPH_ACTIVATE_IND, 0, NULL);\n\t\tif (test_and_clear_bit(FLG_ESTAB_PEND, &l2->flag))\n\t\t\tret = mISDN_FsmEvent(&l2->l2m,\n\t\t\t\t\t     EV_L2_DL_ESTABLISH_REQ, skb);\n\t\tbreak;\n\tcase PH_DEACTIVATE_IND:\n\t\ttest_and_clear_bit(FLG_L1_ACTIV, &l2->flag);\n\t\tl2up_create(l2, MPH_DEACTIVATE_IND, 0, NULL);\n\t\tret = mISDN_FsmEvent(&l2->l2m, EV_L1_DEACTIVATE, skb);\n\t\tbreak;\n\tcase MPH_INFORMATION_IND:\n\t\tif (!l2->up)\n\t\t\tbreak;\n\t\tret = l2->up->send(l2->up, skb);\n\t\tbreak;\n\tcase DL_DATA_REQ:\n\t\tret = mISDN_FsmEvent(&l2->l2m, EV_L2_DL_DATA, skb);\n\t\tbreak;\n\tcase DL_UNITDATA_REQ:\n\t\tret = mISDN_FsmEvent(&l2->l2m, EV_L2_DL_UNITDATA, skb);\n\t\tbreak;\n\tcase DL_ESTABLISH_REQ:\n\t\tif (test_bit(FLG_LAPB, &l2->flag))\n\t\t\ttest_and_set_bit(FLG_ORIG, &l2->flag);\n\t\tif (test_bit(FLG_L1_ACTIV, &l2->flag)) {\n\t\t\tif (test_bit(FLG_LAPD, &l2->flag) ||\n\t\t\t    test_bit(FLG_ORIG, &l2->flag))\n\t\t\t\tret = mISDN_FsmEvent(&l2->l2m,\n\t\t\t\t\t\t     EV_L2_DL_ESTABLISH_REQ, skb);\n\t\t} else {\n\t\t\tif (test_bit(FLG_LAPD, &l2->flag) ||\n\t\t\t    test_bit(FLG_ORIG, &l2->flag)) {\n\t\t\t\ttest_and_set_bit(FLG_ESTAB_PEND,\n\t\t\t\t\t\t &l2->flag);\n\t\t\t}\n\t\t\tret = l2down(l2, PH_ACTIVATE_REQ, l2_newid(l2),\n\t\t\t\t     skb);\n\t\t}\n\t\tbreak;\n\tcase DL_RELEASE_REQ:\n\t\tif (test_bit(FLG_LAPB, &l2->flag))\n\t\t\tl2down_create(l2, PH_DEACTIVATE_REQ,\n\t\t\t\t      l2_newid(l2), 0, NULL);\n\t\tret = mISDN_FsmEvent(&l2->l2m, EV_L2_DL_RELEASE_REQ,\n\t\t\t\t     skb);\n\t\tbreak;\n\tcase DL_TIMER200_IND:\n\t\tmISDN_FsmEvent(&l2->l2m, EV_L2_T200I, NULL);\n\t\tbreak;\n\tcase DL_TIMER203_IND:\n\t\tmISDN_FsmEvent(&l2->l2m, EV_L2_T203I, NULL);\n\t\tbreak;\n\tdefault:\n\t\tif (*debug & DEBUG_L2)\n\t\t\tl2m_debug(&l2->l2m, \"l2 unknown pr %04x\",\n\t\t\t\t  hh->prim);\n\t}\n\tif (ret) {\n\t\tdev_kfree_skb(skb);\n\t\tret = 0;\n\t}\n\treturn ret;\n}\n\nint\ntei_l2(struct layer2 *l2, u_int cmd, u_long arg)\n{\n\tint\t\tret = -EINVAL;\n\n\tif (*debug & DEBUG_L2_TEI)\n\t\tprintk(KERN_DEBUG \"%s: cmd(%x) in %s\\n\",\n\t\t       mISDNDevName4ch(&l2->ch), cmd, __func__);\n\tswitch (cmd) {\n\tcase (MDL_ASSIGN_REQ):\n\t\tret = mISDN_FsmEvent(&l2->l2m, EV_L2_MDL_ASSIGN, (void *)arg);\n\t\tbreak;\n\tcase (MDL_REMOVE_REQ):\n\t\tret = mISDN_FsmEvent(&l2->l2m, EV_L2_MDL_REMOVE, NULL);\n\t\tbreak;\n\tcase (MDL_ERROR_IND):\n\t\tret = mISDN_FsmEvent(&l2->l2m, EV_L2_MDL_ERROR, NULL);\n\t\tbreak;\n\tcase (MDL_ERROR_RSP):\n\t\t \n\t\tprintk(KERN_NOTICE \"%s: MDL_ERROR|REQ (tei_l2)\\n\",\n\t\t       mISDNDevName4ch(&l2->ch));\n\t\tret = mISDN_FsmEvent(&l2->l2m, EV_L2_MDL_ERROR, NULL);\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic void\nrelease_l2(struct layer2 *l2)\n{\n\tmISDN_FsmDelTimer(&l2->t200, 21);\n\tmISDN_FsmDelTimer(&l2->t203, 16);\n\tskb_queue_purge(&l2->i_queue);\n\tskb_queue_purge(&l2->ui_queue);\n\tskb_queue_purge(&l2->down_queue);\n\tReleaseWin(l2);\n\tif (test_bit(FLG_LAPD, &l2->flag)) {\n\t\tTEIrelease(l2);\n\t\tif (l2->ch.st)\n\t\t\tl2->ch.st->dev->D.ctrl(&l2->ch.st->dev->D,\n\t\t\t\t\t       CLOSE_CHANNEL, NULL);\n\t}\n\tkfree(l2);\n}\n\nstatic int\nl2_ctrl(struct mISDNchannel *ch, u_int cmd, void *arg)\n{\n\tstruct layer2\t\t*l2 = container_of(ch, struct layer2, ch);\n\tu_int\t\t\tinfo;\n\n\tif (*debug & DEBUG_L2_CTRL)\n\t\tprintk(KERN_DEBUG \"%s: %s cmd(%x)\\n\",\n\t\t       mISDNDevName4ch(ch), __func__, cmd);\n\n\tswitch (cmd) {\n\tcase OPEN_CHANNEL:\n\t\tif (test_bit(FLG_LAPD, &l2->flag)) {\n\t\t\tset_channel_address(&l2->ch, l2->sapi, l2->tei);\n\t\t\tinfo = DL_INFO_L2_CONNECT;\n\t\t\tl2up_create(l2, DL_INFORMATION_IND,\n\t\t\t\t    sizeof(info), &info);\n\t\t}\n\t\tbreak;\n\tcase CLOSE_CHANNEL:\n\t\tif (l2->ch.peer)\n\t\t\tl2->ch.peer->ctrl(l2->ch.peer, CLOSE_CHANNEL, NULL);\n\t\trelease_l2(l2);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstruct layer2 *\ncreate_l2(struct mISDNchannel *ch, u_int protocol, u_long options, int tei,\n\t  int sapi)\n{\n\tstruct layer2\t\t*l2;\n\tstruct channel_req\trq;\n\n\tl2 = kzalloc(sizeof(struct layer2), GFP_KERNEL);\n\tif (!l2) {\n\t\tprintk(KERN_ERR \"kzalloc layer2 failed\\n\");\n\t\treturn NULL;\n\t}\n\tl2->next_id = 1;\n\tl2->down_id = MISDN_ID_NONE;\n\tl2->up = ch;\n\tl2->ch.st = ch->st;\n\tl2->ch.send = l2_send;\n\tl2->ch.ctrl = l2_ctrl;\n\tswitch (protocol) {\n\tcase ISDN_P_LAPD_NT:\n\t\ttest_and_set_bit(FLG_LAPD, &l2->flag);\n\t\ttest_and_set_bit(FLG_LAPD_NET, &l2->flag);\n\t\ttest_and_set_bit(FLG_MOD128, &l2->flag);\n\t\tl2->sapi = sapi;\n\t\tl2->maxlen = MAX_DFRAME_LEN;\n\t\tif (test_bit(OPTION_L2_PMX, &options))\n\t\t\tl2->window = 7;\n\t\telse\n\t\t\tl2->window = 1;\n\t\tif (test_bit(OPTION_L2_PTP, &options))\n\t\t\ttest_and_set_bit(FLG_PTP, &l2->flag);\n\t\tif (test_bit(OPTION_L2_FIXEDTEI, &options))\n\t\t\ttest_and_set_bit(FLG_FIXED_TEI, &l2->flag);\n\t\tl2->tei = tei;\n\t\tl2->T200 = 1000;\n\t\tl2->N200 = 3;\n\t\tl2->T203 = 10000;\n\t\tif (test_bit(OPTION_L2_PMX, &options))\n\t\t\trq.protocol = ISDN_P_NT_E1;\n\t\telse\n\t\t\trq.protocol = ISDN_P_NT_S0;\n\t\trq.adr.channel = 0;\n\t\tl2->ch.st->dev->D.ctrl(&l2->ch.st->dev->D, OPEN_CHANNEL, &rq);\n\t\tbreak;\n\tcase ISDN_P_LAPD_TE:\n\t\ttest_and_set_bit(FLG_LAPD, &l2->flag);\n\t\ttest_and_set_bit(FLG_MOD128, &l2->flag);\n\t\ttest_and_set_bit(FLG_ORIG, &l2->flag);\n\t\tl2->sapi = sapi;\n\t\tl2->maxlen = MAX_DFRAME_LEN;\n\t\tif (test_bit(OPTION_L2_PMX, &options))\n\t\t\tl2->window = 7;\n\t\telse\n\t\t\tl2->window = 1;\n\t\tif (test_bit(OPTION_L2_PTP, &options))\n\t\t\ttest_and_set_bit(FLG_PTP, &l2->flag);\n\t\tif (test_bit(OPTION_L2_FIXEDTEI, &options))\n\t\t\ttest_and_set_bit(FLG_FIXED_TEI, &l2->flag);\n\t\tl2->tei = tei;\n\t\tl2->T200 = 1000;\n\t\tl2->N200 = 3;\n\t\tl2->T203 = 10000;\n\t\tif (test_bit(OPTION_L2_PMX, &options))\n\t\t\trq.protocol = ISDN_P_TE_E1;\n\t\telse\n\t\t\trq.protocol = ISDN_P_TE_S0;\n\t\trq.adr.channel = 0;\n\t\tl2->ch.st->dev->D.ctrl(&l2->ch.st->dev->D, OPEN_CHANNEL, &rq);\n\t\tbreak;\n\tcase ISDN_P_B_X75SLP:\n\t\ttest_and_set_bit(FLG_LAPB, &l2->flag);\n\t\tl2->window = 7;\n\t\tl2->maxlen = MAX_DATA_SIZE;\n\t\tl2->T200 = 1000;\n\t\tl2->N200 = 4;\n\t\tl2->T203 = 5000;\n\t\tl2->addr.A = 3;\n\t\tl2->addr.B = 1;\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_ERR \"layer2 create failed prt %x\\n\",\n\t\t       protocol);\n\t\tkfree(l2);\n\t\treturn NULL;\n\t}\n\tskb_queue_head_init(&l2->i_queue);\n\tskb_queue_head_init(&l2->ui_queue);\n\tskb_queue_head_init(&l2->down_queue);\n\tskb_queue_head_init(&l2->tmp_queue);\n\tInitWin(l2);\n\tl2->l2m.fsm = &l2fsm;\n\tif (test_bit(FLG_LAPB, &l2->flag) ||\n\t    test_bit(FLG_FIXED_TEI, &l2->flag) ||\n\t    test_bit(FLG_LAPD_NET, &l2->flag))\n\t\tl2->l2m.state = ST_L2_4;\n\telse\n\t\tl2->l2m.state = ST_L2_1;\n\tl2->l2m.debug = *debug;\n\tl2->l2m.userdata = l2;\n\tl2->l2m.userint = 0;\n\tl2->l2m.printdebug = l2m_debug;\n\n\tmISDN_FsmInitTimer(&l2->l2m, &l2->t200);\n\tmISDN_FsmInitTimer(&l2->l2m, &l2->t203);\n\treturn l2;\n}\n\nstatic int\nx75create(struct channel_req *crq)\n{\n\tstruct layer2\t*l2;\n\n\tif (crq->protocol != ISDN_P_B_X75SLP)\n\t\treturn -EPROTONOSUPPORT;\n\tl2 = create_l2(crq->ch, crq->protocol, 0, 0, 0);\n\tif (!l2)\n\t\treturn -ENOMEM;\n\tcrq->ch = &l2->ch;\n\tcrq->protocol = ISDN_P_B_HDLC;\n\treturn 0;\n}\n\nstatic struct Bprotocol X75SLP = {\n\t.Bprotocols = (1 << (ISDN_P_B_X75SLP & ISDN_P_B_MASK)),\n\t.name = \"X75SLP\",\n\t.create = x75create\n};\n\nint\nIsdnl2_Init(u_int *deb)\n{\n\tint res;\n\tdebug = deb;\n\tmISDN_register_Bprotocol(&X75SLP);\n\tl2fsm.state_count = L2_STATE_COUNT;\n\tl2fsm.event_count = L2_EVENT_COUNT;\n\tl2fsm.strEvent = strL2Event;\n\tl2fsm.strState = strL2State;\n\tres = mISDN_FsmNew(&l2fsm, L2FnList, ARRAY_SIZE(L2FnList));\n\tif (res)\n\t\tgoto error;\n\tres = TEIInit(deb);\n\tif (res)\n\t\tgoto error_fsm;\n\treturn 0;\n\nerror_fsm:\n\tmISDN_FsmFree(&l2fsm);\nerror:\n\tmISDN_unregister_Bprotocol(&X75SLP);\n\treturn res;\n}\n\nvoid\nIsdnl2_cleanup(void)\n{\n\tmISDN_unregister_Bprotocol(&X75SLP);\n\tTEIFree();\n\tmISDN_FsmFree(&l2fsm);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}