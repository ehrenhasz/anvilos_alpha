{
  "module_name": "layer1.c",
  "hash_id": "94081e531a87b4fe2123498bcd2ccfb2d27eb8cf7c1501ed60a44d2b2dfa3255",
  "original_prompt": "Ingested from linux-6.6.14/drivers/isdn/mISDN/layer1.c",
  "human_readable_source": "\n \n\n\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mISDNhw.h>\n#include \"core.h\"\n#include \"layer1.h\"\n#include \"fsm.h\"\n\nstatic u_int *debug;\n\nstruct layer1 {\n\tu_long Flags;\n\tstruct FsmInst l1m;\n\tstruct FsmTimer timer3;\n\tstruct FsmTimer timerX;\n\tint delay;\n\tint t3_value;\n\tstruct dchannel *dch;\n\tdchannel_l1callback *dcb;\n};\n\n#define TIMER3_DEFAULT_VALUE\t7000\n\nstatic\nstruct Fsm l1fsm_s = {NULL, 0, 0, NULL, NULL};\n\nenum {\n\tST_L1_F2,\n\tST_L1_F3,\n\tST_L1_F4,\n\tST_L1_F5,\n\tST_L1_F6,\n\tST_L1_F7,\n\tST_L1_F8,\n};\n\n#define L1S_STATE_COUNT (ST_L1_F8 + 1)\n\nstatic char *strL1SState[] =\n{\n\t\"ST_L1_F2\",\n\t\"ST_L1_F3\",\n\t\"ST_L1_F4\",\n\t\"ST_L1_F5\",\n\t\"ST_L1_F6\",\n\t\"ST_L1_F7\",\n\t\"ST_L1_F8\",\n};\n\nenum {\n\tEV_PH_ACTIVATE,\n\tEV_PH_DEACTIVATE,\n\tEV_RESET_IND,\n\tEV_DEACT_CNF,\n\tEV_DEACT_IND,\n\tEV_POWER_UP,\n\tEV_ANYSIG_IND,\n\tEV_INFO2_IND,\n\tEV_INFO4_IND,\n\tEV_TIMER_DEACT,\n\tEV_TIMER_ACT,\n\tEV_TIMER3,\n};\n\n#define L1_EVENT_COUNT (EV_TIMER3 + 1)\n\nstatic char *strL1Event[] =\n{\n\t\"EV_PH_ACTIVATE\",\n\t\"EV_PH_DEACTIVATE\",\n\t\"EV_RESET_IND\",\n\t\"EV_DEACT_CNF\",\n\t\"EV_DEACT_IND\",\n\t\"EV_POWER_UP\",\n\t\"EV_ANYSIG_IND\",\n\t\"EV_INFO2_IND\",\n\t\"EV_INFO4_IND\",\n\t\"EV_TIMER_DEACT\",\n\t\"EV_TIMER_ACT\",\n\t\"EV_TIMER3\",\n};\n\nstatic void\nl1m_debug(struct FsmInst *fi, char *fmt, ...)\n{\n\tstruct layer1 *l1 = fi->userdata;\n\tstruct va_format vaf;\n\tva_list va;\n\n\tva_start(va, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &va;\n\n\tprintk(KERN_DEBUG \"%s: %pV\\n\", dev_name(&l1->dch->dev.dev), &vaf);\n\n\tva_end(va);\n}\n\nstatic void\nl1_reset(struct FsmInst *fi, int event, void *arg)\n{\n\tmISDN_FsmChangeState(fi, ST_L1_F3);\n}\n\nstatic void\nl1_deact_cnf(struct FsmInst *fi, int event, void *arg)\n{\n\tstruct layer1 *l1 = fi->userdata;\n\n\tmISDN_FsmChangeState(fi, ST_L1_F3);\n\tif (test_bit(FLG_L1_ACTIVATING, &l1->Flags))\n\t\tl1->dcb(l1->dch, HW_POWERUP_REQ);\n}\n\nstatic void\nl1_deact_req_s(struct FsmInst *fi, int event, void *arg)\n{\n\tstruct layer1 *l1 = fi->userdata;\n\n\tmISDN_FsmChangeState(fi, ST_L1_F3);\n\tmISDN_FsmRestartTimer(&l1->timerX, 550, EV_TIMER_DEACT, NULL, 2);\n\ttest_and_set_bit(FLG_L1_DEACTTIMER, &l1->Flags);\n}\n\nstatic void\nl1_power_up_s(struct FsmInst *fi, int event, void *arg)\n{\n\tstruct layer1 *l1 = fi->userdata;\n\n\tif (test_bit(FLG_L1_ACTIVATING, &l1->Flags)) {\n\t\tmISDN_FsmChangeState(fi, ST_L1_F4);\n\t\tl1->dcb(l1->dch, INFO3_P8);\n\t} else\n\t\tmISDN_FsmChangeState(fi, ST_L1_F3);\n}\n\nstatic void\nl1_go_F5(struct FsmInst *fi, int event, void *arg)\n{\n\tmISDN_FsmChangeState(fi, ST_L1_F5);\n}\n\nstatic void\nl1_go_F8(struct FsmInst *fi, int event, void *arg)\n{\n\tmISDN_FsmChangeState(fi, ST_L1_F8);\n}\n\nstatic void\nl1_info2_ind(struct FsmInst *fi, int event, void *arg)\n{\n\tstruct layer1 *l1 = fi->userdata;\n\n\tmISDN_FsmChangeState(fi, ST_L1_F6);\n\tl1->dcb(l1->dch, INFO3_P8);\n}\n\nstatic void\nl1_info4_ind(struct FsmInst *fi, int event, void *arg)\n{\n\tstruct layer1 *l1 = fi->userdata;\n\n\tmISDN_FsmChangeState(fi, ST_L1_F7);\n\tl1->dcb(l1->dch, INFO3_P8);\n\tif (test_and_clear_bit(FLG_L1_DEACTTIMER, &l1->Flags))\n\t\tmISDN_FsmDelTimer(&l1->timerX, 4);\n\tif (!test_bit(FLG_L1_ACTIVATED, &l1->Flags)) {\n\t\tif (test_and_clear_bit(FLG_L1_T3RUN, &l1->Flags))\n\t\t\tmISDN_FsmDelTimer(&l1->timer3, 3);\n\t\tmISDN_FsmRestartTimer(&l1->timerX, 110, EV_TIMER_ACT, NULL, 2);\n\t\ttest_and_set_bit(FLG_L1_ACTTIMER, &l1->Flags);\n\t}\n}\n\nstatic void\nl1_timer3(struct FsmInst *fi, int event, void *arg)\n{\n\tstruct layer1 *l1 = fi->userdata;\n\n\ttest_and_clear_bit(FLG_L1_T3RUN, &l1->Flags);\n\tif (test_and_clear_bit(FLG_L1_ACTIVATING, &l1->Flags)) {\n\t\tif (test_and_clear_bit(FLG_L1_DBLOCKED, &l1->Flags))\n\t\t\tl1->dcb(l1->dch, HW_D_NOBLOCKED);\n\t\tl1->dcb(l1->dch, PH_DEACTIVATE_IND);\n\t}\n\tif (l1->l1m.state != ST_L1_F6) {\n\t\tmISDN_FsmChangeState(fi, ST_L1_F3);\n\t\t \n\t}\n}\n\nstatic void\nl1_timer_act(struct FsmInst *fi, int event, void *arg)\n{\n\tstruct layer1 *l1 = fi->userdata;\n\n\ttest_and_clear_bit(FLG_L1_ACTTIMER, &l1->Flags);\n\ttest_and_set_bit(FLG_L1_ACTIVATED, &l1->Flags);\n\tl1->dcb(l1->dch, PH_ACTIVATE_IND);\n}\n\nstatic void\nl1_timer_deact(struct FsmInst *fi, int event, void *arg)\n{\n\tstruct layer1 *l1 = fi->userdata;\n\n\ttest_and_clear_bit(FLG_L1_DEACTTIMER, &l1->Flags);\n\ttest_and_clear_bit(FLG_L1_ACTIVATED, &l1->Flags);\n\tif (test_and_clear_bit(FLG_L1_DBLOCKED, &l1->Flags))\n\t\tl1->dcb(l1->dch, HW_D_NOBLOCKED);\n\tl1->dcb(l1->dch, PH_DEACTIVATE_IND);\n\tl1->dcb(l1->dch, HW_DEACT_REQ);\n}\n\nstatic void\nl1_activate_s(struct FsmInst *fi, int event, void *arg)\n{\n\tstruct layer1 *l1 = fi->userdata;\n\n\tmISDN_FsmRestartTimer(&l1->timer3, l1->t3_value, EV_TIMER3, NULL, 2);\n\ttest_and_set_bit(FLG_L1_T3RUN, &l1->Flags);\n\t \n\tl1->dcb(l1->dch, HW_RESET_REQ);\n}\n\nstatic void\nl1_activate_no(struct FsmInst *fi, int event, void *arg)\n{\n\tstruct layer1 *l1 = fi->userdata;\n\n\tif ((!test_bit(FLG_L1_DEACTTIMER, &l1->Flags)) &&\n\t    (!test_bit(FLG_L1_T3RUN, &l1->Flags))) {\n\t\ttest_and_clear_bit(FLG_L1_ACTIVATING, &l1->Flags);\n\t\tif (test_and_clear_bit(FLG_L1_DBLOCKED, &l1->Flags))\n\t\t\tl1->dcb(l1->dch, HW_D_NOBLOCKED);\n\t\tl1->dcb(l1->dch, PH_DEACTIVATE_IND);\n\t}\n}\n\nstatic struct FsmNode L1SFnList[] =\n{\n\t{ST_L1_F3, EV_PH_ACTIVATE, l1_activate_s},\n\t{ST_L1_F6, EV_PH_ACTIVATE, l1_activate_no},\n\t{ST_L1_F8, EV_PH_ACTIVATE, l1_activate_no},\n\t{ST_L1_F3, EV_RESET_IND, l1_reset},\n\t{ST_L1_F4, EV_RESET_IND, l1_reset},\n\t{ST_L1_F5, EV_RESET_IND, l1_reset},\n\t{ST_L1_F6, EV_RESET_IND, l1_reset},\n\t{ST_L1_F7, EV_RESET_IND, l1_reset},\n\t{ST_L1_F8, EV_RESET_IND, l1_reset},\n\t{ST_L1_F3, EV_DEACT_CNF, l1_deact_cnf},\n\t{ST_L1_F4, EV_DEACT_CNF, l1_deact_cnf},\n\t{ST_L1_F5, EV_DEACT_CNF, l1_deact_cnf},\n\t{ST_L1_F6, EV_DEACT_CNF, l1_deact_cnf},\n\t{ST_L1_F7, EV_DEACT_CNF, l1_deact_cnf},\n\t{ST_L1_F8, EV_DEACT_CNF, l1_deact_cnf},\n\t{ST_L1_F6, EV_DEACT_IND, l1_deact_req_s},\n\t{ST_L1_F7, EV_DEACT_IND, l1_deact_req_s},\n\t{ST_L1_F8, EV_DEACT_IND, l1_deact_req_s},\n\t{ST_L1_F3, EV_POWER_UP,  l1_power_up_s},\n\t{ST_L1_F4, EV_ANYSIG_IND, l1_go_F5},\n\t{ST_L1_F6, EV_ANYSIG_IND, l1_go_F8},\n\t{ST_L1_F7, EV_ANYSIG_IND, l1_go_F8},\n\t{ST_L1_F3, EV_INFO2_IND, l1_info2_ind},\n\t{ST_L1_F4, EV_INFO2_IND, l1_info2_ind},\n\t{ST_L1_F5, EV_INFO2_IND, l1_info2_ind},\n\t{ST_L1_F7, EV_INFO2_IND, l1_info2_ind},\n\t{ST_L1_F8, EV_INFO2_IND, l1_info2_ind},\n\t{ST_L1_F3, EV_INFO4_IND, l1_info4_ind},\n\t{ST_L1_F4, EV_INFO4_IND, l1_info4_ind},\n\t{ST_L1_F5, EV_INFO4_IND, l1_info4_ind},\n\t{ST_L1_F6, EV_INFO4_IND, l1_info4_ind},\n\t{ST_L1_F8, EV_INFO4_IND, l1_info4_ind},\n\t{ST_L1_F3, EV_TIMER3, l1_timer3},\n\t{ST_L1_F4, EV_TIMER3, l1_timer3},\n\t{ST_L1_F5, EV_TIMER3, l1_timer3},\n\t{ST_L1_F6, EV_TIMER3, l1_timer3},\n\t{ST_L1_F8, EV_TIMER3, l1_timer3},\n\t{ST_L1_F7, EV_TIMER_ACT, l1_timer_act},\n\t{ST_L1_F3, EV_TIMER_DEACT, l1_timer_deact},\n\t{ST_L1_F4, EV_TIMER_DEACT, l1_timer_deact},\n\t{ST_L1_F5, EV_TIMER_DEACT, l1_timer_deact},\n\t{ST_L1_F6, EV_TIMER_DEACT, l1_timer_deact},\n\t{ST_L1_F7, EV_TIMER_DEACT, l1_timer_deact},\n\t{ST_L1_F8, EV_TIMER_DEACT, l1_timer_deact},\n};\n\nstatic void\nrelease_l1(struct layer1 *l1) {\n\tmISDN_FsmDelTimer(&l1->timerX, 0);\n\tmISDN_FsmDelTimer(&l1->timer3, 0);\n\tif (l1->dch)\n\t\tl1->dch->l1 = NULL;\n\tmodule_put(THIS_MODULE);\n\tkfree(l1);\n}\n\nint\nl1_event(struct layer1 *l1, u_int event)\n{\n\tint\t\terr = 0;\n\n\tif (!l1)\n\t\treturn -EINVAL;\n\tswitch (event) {\n\tcase HW_RESET_IND:\n\t\tmISDN_FsmEvent(&l1->l1m, EV_RESET_IND, NULL);\n\t\tbreak;\n\tcase HW_DEACT_IND:\n\t\tmISDN_FsmEvent(&l1->l1m, EV_DEACT_IND, NULL);\n\t\tbreak;\n\tcase HW_POWERUP_IND:\n\t\tmISDN_FsmEvent(&l1->l1m, EV_POWER_UP, NULL);\n\t\tbreak;\n\tcase HW_DEACT_CNF:\n\t\tmISDN_FsmEvent(&l1->l1m, EV_DEACT_CNF, NULL);\n\t\tbreak;\n\tcase ANYSIGNAL:\n\t\tmISDN_FsmEvent(&l1->l1m, EV_ANYSIG_IND, NULL);\n\t\tbreak;\n\tcase LOSTFRAMING:\n\t\tmISDN_FsmEvent(&l1->l1m, EV_ANYSIG_IND, NULL);\n\t\tbreak;\n\tcase INFO2:\n\t\tmISDN_FsmEvent(&l1->l1m, EV_INFO2_IND, NULL);\n\t\tbreak;\n\tcase INFO4_P8:\n\t\tmISDN_FsmEvent(&l1->l1m, EV_INFO4_IND, NULL);\n\t\tbreak;\n\tcase INFO4_P10:\n\t\tmISDN_FsmEvent(&l1->l1m, EV_INFO4_IND, NULL);\n\t\tbreak;\n\tcase PH_ACTIVATE_REQ:\n\t\tif (test_bit(FLG_L1_ACTIVATED, &l1->Flags))\n\t\t\tl1->dcb(l1->dch, PH_ACTIVATE_IND);\n\t\telse {\n\t\t\ttest_and_set_bit(FLG_L1_ACTIVATING, &l1->Flags);\n\t\t\tmISDN_FsmEvent(&l1->l1m, EV_PH_ACTIVATE, NULL);\n\t\t}\n\t\tbreak;\n\tcase CLOSE_CHANNEL:\n\t\trelease_l1(l1);\n\t\tbreak;\n\tdefault:\n\t\tif ((event & ~HW_TIMER3_VMASK) == HW_TIMER3_VALUE) {\n\t\t\tint val = event & HW_TIMER3_VMASK;\n\n\t\t\tif (val < 5)\n\t\t\t\tval = 5;\n\t\t\tif (val > 30)\n\t\t\t\tval = 30;\n\t\t\tl1->t3_value = val;\n\t\t\tbreak;\n\t\t}\n\t\tif (*debug & DEBUG_L1)\n\t\t\tprintk(KERN_DEBUG \"%s %x unhandled\\n\",\n\t\t\t       __func__, event);\n\t\terr = -EINVAL;\n\t}\n\treturn err;\n}\nEXPORT_SYMBOL(l1_event);\n\nint\ncreate_l1(struct dchannel *dch, dchannel_l1callback *dcb) {\n\tstruct layer1\t*nl1;\n\n\tnl1 = kzalloc(sizeof(struct layer1), GFP_ATOMIC);\n\tif (!nl1) {\n\t\tprintk(KERN_ERR \"kmalloc struct layer1 failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tnl1->l1m.fsm = &l1fsm_s;\n\tnl1->l1m.state = ST_L1_F3;\n\tnl1->Flags = 0;\n\tnl1->t3_value = TIMER3_DEFAULT_VALUE;\n\tnl1->l1m.debug = *debug & DEBUG_L1_FSM;\n\tnl1->l1m.userdata = nl1;\n\tnl1->l1m.userint = 0;\n\tnl1->l1m.printdebug = l1m_debug;\n\tnl1->dch = dch;\n\tnl1->dcb = dcb;\n\tmISDN_FsmInitTimer(&nl1->l1m, &nl1->timer3);\n\tmISDN_FsmInitTimer(&nl1->l1m, &nl1->timerX);\n\t__module_get(THIS_MODULE);\n\tdch->l1 = nl1;\n\treturn 0;\n}\nEXPORT_SYMBOL(create_l1);\n\nint\nIsdnl1_Init(u_int *deb)\n{\n\tdebug = deb;\n\tl1fsm_s.state_count = L1S_STATE_COUNT;\n\tl1fsm_s.event_count = L1_EVENT_COUNT;\n\tl1fsm_s.strEvent = strL1Event;\n\tl1fsm_s.strState = strL1SState;\n\treturn mISDN_FsmNew(&l1fsm_s, L1SFnList, ARRAY_SIZE(L1SFnList));\n}\n\nvoid\nIsdnl1_cleanup(void)\n{\n\tmISDN_FsmFree(&l1fsm_s);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}