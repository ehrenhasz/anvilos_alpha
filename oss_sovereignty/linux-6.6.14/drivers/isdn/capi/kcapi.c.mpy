{
  "module_name": "kcapi.c",
  "hash_id": "3f8ead5fa0d840ef00a824d8aa629842bf26ed23532c402b8de7cf4bd6d548b0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/isdn/capi/kcapi.c",
  "human_readable_source": " \n\n#include \"kcapi.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/signal.h>\n#include <linux/seq_file.h>\n#include <linux/skbuff.h>\n#include <linux/workqueue.h>\n#include <linux/capi.h>\n#include <linux/kernelcapi.h>\n#include <linux/init.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/isdn/capicmd.h>\n#include <linux/isdn/capiutil.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n\nstatic int showcapimsgs;\nstatic struct workqueue_struct *kcapi_wq;\n\nmodule_param(showcapimsgs, uint, 0);\n\n \n\nstruct capictr_event {\n\tstruct work_struct work;\n\tunsigned int type;\n\tu32 controller;\n};\n\n \n\nstatic const struct capi_version driver_version = {2, 0, 1, 1 << 4};\nstatic char driver_serial[CAPI_SERIAL_LEN] = \"0004711\";\nstatic char capi_manufakturer[64] = \"AVM Berlin\";\n\n#define NCCI2CTRL(ncci)    (((ncci) >> 24) & 0x7f)\n\nstruct capi_ctr *capi_controller[CAPI_MAXCONTR];\nDEFINE_MUTEX(capi_controller_lock);\n\nstruct capi20_appl *capi_applications[CAPI_MAXAPPL];\n\nstatic int ncontrollers;\n\n \n\nstatic inline struct capi_ctr *\ncapi_ctr_get(struct capi_ctr *ctr)\n{\n\tif (!try_module_get(ctr->owner))\n\t\treturn NULL;\n\treturn ctr;\n}\n\nstatic inline void\ncapi_ctr_put(struct capi_ctr *ctr)\n{\n\tmodule_put(ctr->owner);\n}\n\n \n\nstatic inline struct capi_ctr *get_capi_ctr_by_nr(u16 contr)\n{\n\tif (contr < 1 || contr - 1 >= CAPI_MAXCONTR)\n\t\treturn NULL;\n\n\treturn capi_controller[contr - 1];\n}\n\nstatic inline struct capi20_appl *__get_capi_appl_by_nr(u16 applid)\n{\n\tlockdep_assert_held(&capi_controller_lock);\n\n\tif (applid < 1 || applid - 1 >= CAPI_MAXAPPL)\n\t\treturn NULL;\n\n\treturn capi_applications[applid - 1];\n}\n\nstatic inline struct capi20_appl *get_capi_appl_by_nr(u16 applid)\n{\n\tif (applid < 1 || applid - 1 >= CAPI_MAXAPPL)\n\t\treturn NULL;\n\n\treturn rcu_dereference(capi_applications[applid - 1]);\n}\n\n \n\nstatic inline int capi_cmd_valid(u8 cmd)\n{\n\tswitch (cmd) {\n\tcase CAPI_ALERT:\n\tcase CAPI_CONNECT:\n\tcase CAPI_CONNECT_ACTIVE:\n\tcase CAPI_CONNECT_B3_ACTIVE:\n\tcase CAPI_CONNECT_B3:\n\tcase CAPI_CONNECT_B3_T90_ACTIVE:\n\tcase CAPI_DATA_B3:\n\tcase CAPI_DISCONNECT_B3:\n\tcase CAPI_DISCONNECT:\n\tcase CAPI_FACILITY:\n\tcase CAPI_INFO:\n\tcase CAPI_LISTEN:\n\tcase CAPI_MANUFACTURER:\n\tcase CAPI_RESET_B3:\n\tcase CAPI_SELECT_B_PROTOCOL:\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic inline int capi_subcmd_valid(u8 subcmd)\n{\n\tswitch (subcmd) {\n\tcase CAPI_REQ:\n\tcase CAPI_CONF:\n\tcase CAPI_IND:\n\tcase CAPI_RESP:\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n \n\nstatic void\nregister_appl(struct capi_ctr *ctr, u16 applid, capi_register_params *rparam)\n{\n\tctr = capi_ctr_get(ctr);\n\n\tif (ctr)\n\t\tctr->register_appl(ctr, applid, rparam);\n\telse\n\t\tprintk(KERN_WARNING \"%s: cannot get controller resources\\n\",\n\t\t       __func__);\n}\n\n\nstatic void release_appl(struct capi_ctr *ctr, u16 applid)\n{\n\tDBG(\"applid %#x\", applid);\n\n\tctr->release_appl(ctr, applid);\n\tcapi_ctr_put(ctr);\n}\n\nstatic void notify_up(u32 contr)\n{\n\tstruct capi20_appl *ap;\n\tstruct capi_ctr *ctr;\n\tu16 applid;\n\n\tmutex_lock(&capi_controller_lock);\n\n\tif (showcapimsgs & 1)\n\t\tprintk(KERN_DEBUG \"kcapi: notify up contr %d\\n\", contr);\n\n\tctr = get_capi_ctr_by_nr(contr);\n\tif (ctr) {\n\t\tif (ctr->state == CAPI_CTR_RUNNING)\n\t\t\tgoto unlock_out;\n\n\t\tctr->state = CAPI_CTR_RUNNING;\n\n\t\tfor (applid = 1; applid <= CAPI_MAXAPPL; applid++) {\n\t\t\tap = __get_capi_appl_by_nr(applid);\n\t\t\tif (ap)\n\t\t\t\tregister_appl(ctr, applid, &ap->rparam);\n\t\t}\n\t} else\n\t\tprintk(KERN_WARNING \"%s: invalid contr %d\\n\", __func__, contr);\n\nunlock_out:\n\tmutex_unlock(&capi_controller_lock);\n}\n\nstatic void ctr_down(struct capi_ctr *ctr, int new_state)\n{\n\tstruct capi20_appl *ap;\n\tu16 applid;\n\n\tif (ctr->state == CAPI_CTR_DETECTED || ctr->state == CAPI_CTR_DETACHED)\n\t\treturn;\n\n\tctr->state = new_state;\n\n\tmemset(ctr->manu, 0, sizeof(ctr->manu));\n\tmemset(&ctr->version, 0, sizeof(ctr->version));\n\tmemset(&ctr->profile, 0, sizeof(ctr->profile));\n\tmemset(ctr->serial, 0, sizeof(ctr->serial));\n\n\tfor (applid = 1; applid <= CAPI_MAXAPPL; applid++) {\n\t\tap = __get_capi_appl_by_nr(applid);\n\t\tif (ap)\n\t\t\tcapi_ctr_put(ctr);\n\t}\n}\n\nstatic void notify_down(u32 contr)\n{\n\tstruct capi_ctr *ctr;\n\n\tmutex_lock(&capi_controller_lock);\n\n\tif (showcapimsgs & 1)\n\t\tprintk(KERN_DEBUG \"kcapi: notify down contr %d\\n\", contr);\n\n\tctr = get_capi_ctr_by_nr(contr);\n\tif (ctr)\n\t\tctr_down(ctr, CAPI_CTR_DETECTED);\n\telse\n\t\tprintk(KERN_WARNING \"%s: invalid contr %d\\n\", __func__, contr);\n\n\tmutex_unlock(&capi_controller_lock);\n}\n\nstatic void do_notify_work(struct work_struct *work)\n{\n\tstruct capictr_event *event =\n\t\tcontainer_of(work, struct capictr_event, work);\n\n\tswitch (event->type) {\n\tcase CAPICTR_UP:\n\t\tnotify_up(event->controller);\n\t\tbreak;\n\tcase CAPICTR_DOWN:\n\t\tnotify_down(event->controller);\n\t\tbreak;\n\t}\n\n\tkfree(event);\n}\n\nstatic int notify_push(unsigned int event_type, u32 controller)\n{\n\tstruct capictr_event *event = kmalloc(sizeof(*event), GFP_ATOMIC);\n\n\tif (!event)\n\t\treturn -ENOMEM;\n\n\tINIT_WORK(&event->work, do_notify_work);\n\tevent->type = event_type;\n\tevent->controller = controller;\n\n\tqueue_work(kcapi_wq, &event->work);\n\treturn 0;\n}\n\n \n\nstatic void recv_handler(struct work_struct *work)\n{\n\tstruct sk_buff *skb;\n\tstruct capi20_appl *ap =\n\t\tcontainer_of(work, struct capi20_appl, recv_work);\n\n\tif ((!ap) || (ap->release_in_progress))\n\t\treturn;\n\n\tmutex_lock(&ap->recv_mtx);\n\twhile ((skb = skb_dequeue(&ap->recv_queue))) {\n\t\tif (CAPIMSG_CMD(skb->data) == CAPI_DATA_B3_IND)\n\t\t\tap->nrecvdatapkt++;\n\t\telse\n\t\t\tap->nrecvctlpkt++;\n\n\t\tap->recv_message(ap, skb);\n\t}\n\tmutex_unlock(&ap->recv_mtx);\n}\n\n \n\nvoid capi_ctr_handle_message(struct capi_ctr *ctr, u16 appl,\n\t\t\t     struct sk_buff *skb)\n{\n\tstruct capi20_appl *ap;\n\tint showctl = 0;\n\tu8 cmd, subcmd;\n\t_cdebbuf *cdb;\n\n\tif (ctr->state != CAPI_CTR_RUNNING) {\n\t\tcdb = capi_message2str(skb->data);\n\t\tif (cdb) {\n\t\t\tprintk(KERN_INFO \"kcapi: controller [%03d] not active, got: %s\",\n\t\t\t       ctr->cnr, cdb->buf);\n\t\t\tcdebbuf_free(cdb);\n\t\t} else\n\t\t\tprintk(KERN_INFO \"kcapi: controller [%03d] not active, cannot trace\\n\",\n\t\t\t       ctr->cnr);\n\t\tgoto error;\n\t}\n\n\tcmd = CAPIMSG_COMMAND(skb->data);\n\tsubcmd = CAPIMSG_SUBCOMMAND(skb->data);\n\tif (cmd == CAPI_DATA_B3 && subcmd == CAPI_IND) {\n\t\tctr->nrecvdatapkt++;\n\t\tif (ctr->traceflag > 2)\n\t\t\tshowctl |= 2;\n\t} else {\n\t\tctr->nrecvctlpkt++;\n\t\tif (ctr->traceflag)\n\t\t\tshowctl |= 2;\n\t}\n\tshowctl |= (ctr->traceflag & 1);\n\tif (showctl & 2) {\n\t\tif (showctl & 1) {\n\t\t\tprintk(KERN_DEBUG \"kcapi: got [%03d] id#%d %s len=%u\\n\",\n\t\t\t       ctr->cnr, CAPIMSG_APPID(skb->data),\n\t\t\t       capi_cmd2str(cmd, subcmd),\n\t\t\t       CAPIMSG_LEN(skb->data));\n\t\t} else {\n\t\t\tcdb = capi_message2str(skb->data);\n\t\t\tif (cdb) {\n\t\t\t\tprintk(KERN_DEBUG \"kcapi: got [%03d] %s\\n\",\n\t\t\t\t       ctr->cnr, cdb->buf);\n\t\t\t\tcdebbuf_free(cdb);\n\t\t\t} else\n\t\t\t\tprintk(KERN_DEBUG \"kcapi: got [%03d] id#%d %s len=%u, cannot trace\\n\",\n\t\t\t\t       ctr->cnr, CAPIMSG_APPID(skb->data),\n\t\t\t\t       capi_cmd2str(cmd, subcmd),\n\t\t\t\t       CAPIMSG_LEN(skb->data));\n\t\t}\n\n\t}\n\n\trcu_read_lock();\n\tap = get_capi_appl_by_nr(CAPIMSG_APPID(skb->data));\n\tif (!ap) {\n\t\trcu_read_unlock();\n\t\tcdb = capi_message2str(skb->data);\n\t\tif (cdb) {\n\t\t\tprintk(KERN_ERR \"kcapi: handle_message: applid %d state released (%s)\\n\",\n\t\t\t       CAPIMSG_APPID(skb->data), cdb->buf);\n\t\t\tcdebbuf_free(cdb);\n\t\t} else\n\t\t\tprintk(KERN_ERR \"kcapi: handle_message: applid %d state released (%s) cannot trace\\n\",\n\t\t\t       CAPIMSG_APPID(skb->data),\n\t\t\t       capi_cmd2str(cmd, subcmd));\n\t\tgoto error;\n\t}\n\tskb_queue_tail(&ap->recv_queue, skb);\n\tqueue_work(kcapi_wq, &ap->recv_work);\n\trcu_read_unlock();\n\n\treturn;\n\nerror:\n\tkfree_skb(skb);\n}\n\nEXPORT_SYMBOL(capi_ctr_handle_message);\n\n \n\nvoid capi_ctr_ready(struct capi_ctr *ctr)\n{\n\tprintk(KERN_NOTICE \"kcapi: controller [%03d] \\\"%s\\\" ready.\\n\",\n\t       ctr->cnr, ctr->name);\n\n\tnotify_push(CAPICTR_UP, ctr->cnr);\n}\n\nEXPORT_SYMBOL(capi_ctr_ready);\n\n \n\nvoid capi_ctr_down(struct capi_ctr *ctr)\n{\n\tprintk(KERN_NOTICE \"kcapi: controller [%03d] down.\\n\", ctr->cnr);\n\n\tnotify_push(CAPICTR_DOWN, ctr->cnr);\n}\n\nEXPORT_SYMBOL(capi_ctr_down);\n\n \n\n \n\nint attach_capi_ctr(struct capi_ctr *ctr)\n{\n\tint i;\n\n\tmutex_lock(&capi_controller_lock);\n\n\tfor (i = 0; i < CAPI_MAXCONTR; i++) {\n\t\tif (!capi_controller[i])\n\t\t\tbreak;\n\t}\n\tif (i == CAPI_MAXCONTR) {\n\t\tmutex_unlock(&capi_controller_lock);\n\t\tprintk(KERN_ERR \"kcapi: out of controller slots\\n\");\n\t\treturn -EBUSY;\n\t}\n\tcapi_controller[i] = ctr;\n\n\tctr->nrecvctlpkt = 0;\n\tctr->nrecvdatapkt = 0;\n\tctr->nsentctlpkt = 0;\n\tctr->nsentdatapkt = 0;\n\tctr->cnr = i + 1;\n\tctr->state = CAPI_CTR_DETECTED;\n\tctr->blocked = 0;\n\tctr->traceflag = showcapimsgs;\n\n\tsprintf(ctr->procfn, \"capi/controllers/%d\", ctr->cnr);\n\tctr->procent = proc_create_single_data(ctr->procfn, 0, NULL,\n\t\t\tctr->proc_show, ctr);\n\n\tncontrollers++;\n\n\tmutex_unlock(&capi_controller_lock);\n\n\tprintk(KERN_NOTICE \"kcapi: controller [%03d]: %s attached\\n\",\n\t       ctr->cnr, ctr->name);\n\treturn 0;\n}\n\nEXPORT_SYMBOL(attach_capi_ctr);\n\n \n\nint detach_capi_ctr(struct capi_ctr *ctr)\n{\n\tint err = 0;\n\n\tmutex_lock(&capi_controller_lock);\n\n\tctr_down(ctr, CAPI_CTR_DETACHED);\n\n\tif (ctr->cnr < 1 || ctr->cnr - 1 >= CAPI_MAXCONTR) {\n\t\terr = -EINVAL;\n\t\tgoto unlock_out;\n\t}\n\n\tif (capi_controller[ctr->cnr - 1] != ctr) {\n\t\terr = -EINVAL;\n\t\tgoto unlock_out;\n\t}\n\tcapi_controller[ctr->cnr - 1] = NULL;\n\tncontrollers--;\n\n\tif (ctr->procent)\n\t\tremove_proc_entry(ctr->procfn, NULL);\n\n\tprintk(KERN_NOTICE \"kcapi: controller [%03d]: %s unregistered\\n\",\n\t       ctr->cnr, ctr->name);\n\nunlock_out:\n\tmutex_unlock(&capi_controller_lock);\n\n\treturn err;\n}\n\nEXPORT_SYMBOL(detach_capi_ctr);\n\n \n \n \n\n \n\nu16 capi20_isinstalled(void)\n{\n\tu16 ret = CAPI_REGNOTINSTALLED;\n\tint i;\n\n\tmutex_lock(&capi_controller_lock);\n\n\tfor (i = 0; i < CAPI_MAXCONTR; i++)\n\t\tif (capi_controller[i] &&\n\t\t    capi_controller[i]->state == CAPI_CTR_RUNNING) {\n\t\t\tret = CAPI_NOERROR;\n\t\t\tbreak;\n\t\t}\n\n\tmutex_unlock(&capi_controller_lock);\n\n\treturn ret;\n}\n\n \n\nu16 capi20_register(struct capi20_appl *ap)\n{\n\tint i;\n\tu16 applid;\n\n\tDBG(\"\");\n\n\tif (ap->rparam.datablklen < 128)\n\t\treturn CAPI_LOGBLKSIZETOSMALL;\n\n\tap->nrecvctlpkt = 0;\n\tap->nrecvdatapkt = 0;\n\tap->nsentctlpkt = 0;\n\tap->nsentdatapkt = 0;\n\tmutex_init(&ap->recv_mtx);\n\tskb_queue_head_init(&ap->recv_queue);\n\tINIT_WORK(&ap->recv_work, recv_handler);\n\tap->release_in_progress = 0;\n\n\tmutex_lock(&capi_controller_lock);\n\n\tfor (applid = 1; applid <= CAPI_MAXAPPL; applid++) {\n\t\tif (capi_applications[applid - 1] == NULL)\n\t\t\tbreak;\n\t}\n\tif (applid > CAPI_MAXAPPL) {\n\t\tmutex_unlock(&capi_controller_lock);\n\t\treturn CAPI_TOOMANYAPPLS;\n\t}\n\n\tap->applid = applid;\n\tcapi_applications[applid - 1] = ap;\n\n\tfor (i = 0; i < CAPI_MAXCONTR; i++) {\n\t\tif (!capi_controller[i] ||\n\t\t    capi_controller[i]->state != CAPI_CTR_RUNNING)\n\t\t\tcontinue;\n\t\tregister_appl(capi_controller[i], applid, &ap->rparam);\n\t}\n\n\tmutex_unlock(&capi_controller_lock);\n\n\tif (showcapimsgs & 1) {\n\t\tprintk(KERN_DEBUG \"kcapi: appl %d up\\n\", applid);\n\t}\n\n\treturn CAPI_NOERROR;\n}\n\n \n\nu16 capi20_release(struct capi20_appl *ap)\n{\n\tint i;\n\n\tDBG(\"applid %#x\", ap->applid);\n\n\tmutex_lock(&capi_controller_lock);\n\n\tap->release_in_progress = 1;\n\tcapi_applications[ap->applid - 1] = NULL;\n\n\tsynchronize_rcu();\n\n\tfor (i = 0; i < CAPI_MAXCONTR; i++) {\n\t\tif (!capi_controller[i] ||\n\t\t    capi_controller[i]->state != CAPI_CTR_RUNNING)\n\t\t\tcontinue;\n\t\trelease_appl(capi_controller[i], ap->applid);\n\t}\n\n\tmutex_unlock(&capi_controller_lock);\n\n\tflush_workqueue(kcapi_wq);\n\tskb_queue_purge(&ap->recv_queue);\n\n\tif (showcapimsgs & 1) {\n\t\tprintk(KERN_DEBUG \"kcapi: appl %d down\\n\", ap->applid);\n\t}\n\n\treturn CAPI_NOERROR;\n}\n\n \n\nu16 capi20_put_message(struct capi20_appl *ap, struct sk_buff *skb)\n{\n\tstruct capi_ctr *ctr;\n\tint showctl = 0;\n\tu8 cmd, subcmd;\n\n\tDBG(\"applid %#x\", ap->applid);\n\n\tif (ncontrollers == 0)\n\t\treturn CAPI_REGNOTINSTALLED;\n\tif ((ap->applid == 0) || ap->release_in_progress)\n\t\treturn CAPI_ILLAPPNR;\n\tif (skb->len < 12\n\t    || !capi_cmd_valid(CAPIMSG_COMMAND(skb->data))\n\t    || !capi_subcmd_valid(CAPIMSG_SUBCOMMAND(skb->data)))\n\t\treturn CAPI_ILLCMDORSUBCMDORMSGTOSMALL;\n\n\t \n\tctr = get_capi_ctr_by_nr(CAPIMSG_CONTROLLER(skb->data));\n\tif (!ctr || ctr->state != CAPI_CTR_RUNNING)\n\t\treturn CAPI_REGNOTINSTALLED;\n\tif (ctr->blocked)\n\t\treturn CAPI_SENDQUEUEFULL;\n\n\tcmd = CAPIMSG_COMMAND(skb->data);\n\tsubcmd = CAPIMSG_SUBCOMMAND(skb->data);\n\n\tif (cmd == CAPI_DATA_B3 && subcmd == CAPI_REQ) {\n\t\tctr->nsentdatapkt++;\n\t\tap->nsentdatapkt++;\n\t\tif (ctr->traceflag > 2)\n\t\t\tshowctl |= 2;\n\t} else {\n\t\tctr->nsentctlpkt++;\n\t\tap->nsentctlpkt++;\n\t\tif (ctr->traceflag)\n\t\t\tshowctl |= 2;\n\t}\n\tshowctl |= (ctr->traceflag & 1);\n\tif (showctl & 2) {\n\t\tif (showctl & 1) {\n\t\t\tprintk(KERN_DEBUG \"kcapi: put [%03d] id#%d %s len=%u\\n\",\n\t\t\t       CAPIMSG_CONTROLLER(skb->data),\n\t\t\t       CAPIMSG_APPID(skb->data),\n\t\t\t       capi_cmd2str(cmd, subcmd),\n\t\t\t       CAPIMSG_LEN(skb->data));\n\t\t} else {\n\t\t\t_cdebbuf *cdb = capi_message2str(skb->data);\n\t\t\tif (cdb) {\n\t\t\t\tprintk(KERN_DEBUG \"kcapi: put [%03d] %s\\n\",\n\t\t\t\t       CAPIMSG_CONTROLLER(skb->data),\n\t\t\t\t       cdb->buf);\n\t\t\t\tcdebbuf_free(cdb);\n\t\t\t} else\n\t\t\t\tprintk(KERN_DEBUG \"kcapi: put [%03d] id#%d %s len=%u cannot trace\\n\",\n\t\t\t\t       CAPIMSG_CONTROLLER(skb->data),\n\t\t\t\t       CAPIMSG_APPID(skb->data),\n\t\t\t\t       capi_cmd2str(cmd, subcmd),\n\t\t\t\t       CAPIMSG_LEN(skb->data));\n\t\t}\n\t}\n\treturn ctr->send_message(ctr, skb);\n}\n\n \n\nu16 capi20_get_manufacturer(u32 contr, u8 buf[CAPI_MANUFACTURER_LEN])\n{\n\tstruct capi_ctr *ctr;\n\tu16 ret;\n\n\tif (contr == 0) {\n\t\tstrncpy(buf, capi_manufakturer, CAPI_MANUFACTURER_LEN);\n\t\treturn CAPI_NOERROR;\n\t}\n\n\tmutex_lock(&capi_controller_lock);\n\n\tctr = get_capi_ctr_by_nr(contr);\n\tif (ctr && ctr->state == CAPI_CTR_RUNNING) {\n\t\tstrncpy(buf, ctr->manu, CAPI_MANUFACTURER_LEN);\n\t\tret = CAPI_NOERROR;\n\t} else\n\t\tret = CAPI_REGNOTINSTALLED;\n\n\tmutex_unlock(&capi_controller_lock);\n\treturn ret;\n}\n\n \n\nu16 capi20_get_version(u32 contr, struct capi_version *verp)\n{\n\tstruct capi_ctr *ctr;\n\tu16 ret;\n\n\tif (contr == 0) {\n\t\t*verp = driver_version;\n\t\treturn CAPI_NOERROR;\n\t}\n\n\tmutex_lock(&capi_controller_lock);\n\n\tctr = get_capi_ctr_by_nr(contr);\n\tif (ctr && ctr->state == CAPI_CTR_RUNNING) {\n\t\tmemcpy(verp, &ctr->version, sizeof(capi_version));\n\t\tret = CAPI_NOERROR;\n\t} else\n\t\tret = CAPI_REGNOTINSTALLED;\n\n\tmutex_unlock(&capi_controller_lock);\n\treturn ret;\n}\n\n \n\nu16 capi20_get_serial(u32 contr, u8 serial[CAPI_SERIAL_LEN])\n{\n\tstruct capi_ctr *ctr;\n\tu16 ret;\n\n\tif (contr == 0) {\n\t\tstrscpy(serial, driver_serial, CAPI_SERIAL_LEN);\n\t\treturn CAPI_NOERROR;\n\t}\n\n\tmutex_lock(&capi_controller_lock);\n\n\tctr = get_capi_ctr_by_nr(contr);\n\tif (ctr && ctr->state == CAPI_CTR_RUNNING) {\n\t\tstrscpy(serial, ctr->serial, CAPI_SERIAL_LEN);\n\t\tret = CAPI_NOERROR;\n\t} else\n\t\tret = CAPI_REGNOTINSTALLED;\n\n\tmutex_unlock(&capi_controller_lock);\n\treturn ret;\n}\n\n \n\nu16 capi20_get_profile(u32 contr, struct capi_profile *profp)\n{\n\tstruct capi_ctr *ctr;\n\tu16 ret;\n\n\tif (contr == 0) {\n\t\tprofp->ncontroller = ncontrollers;\n\t\treturn CAPI_NOERROR;\n\t}\n\n\tmutex_lock(&capi_controller_lock);\n\n\tctr = get_capi_ctr_by_nr(contr);\n\tif (ctr && ctr->state == CAPI_CTR_RUNNING) {\n\t\tmemcpy(profp, &ctr->profile, sizeof(struct capi_profile));\n\t\tret = CAPI_NOERROR;\n\t} else\n\t\tret = CAPI_REGNOTINSTALLED;\n\n\tmutex_unlock(&capi_controller_lock);\n\treturn ret;\n}\n\n \n\nint capi20_manufacturer(unsigned long cmd, void __user *data)\n{\n\tstruct capi_ctr *ctr;\n\tint retval;\n\n\tswitch (cmd) {\n\tcase KCAPI_CMD_TRACE:\n\t{\n\t\tkcapi_flagdef fdef;\n\n\t\tif (copy_from_user(&fdef, data, sizeof(kcapi_flagdef)))\n\t\t\treturn -EFAULT;\n\n\t\tmutex_lock(&capi_controller_lock);\n\n\t\tctr = get_capi_ctr_by_nr(fdef.contr);\n\t\tif (ctr) {\n\t\t\tctr->traceflag = fdef.flag;\n\t\t\tprintk(KERN_INFO \"kcapi: contr [%03d] set trace=%d\\n\",\n\t\t\t       ctr->cnr, ctr->traceflag);\n\t\t\tretval = 0;\n\t\t} else\n\t\t\tretval = -ESRCH;\n\n\t\tmutex_unlock(&capi_controller_lock);\n\n\t\treturn retval;\n\t}\n\n\tdefault:\n\t\tprintk(KERN_ERR \"kcapi: manufacturer command %lu unknown.\\n\",\n\t\t       cmd);\n\t\tbreak;\n\n\t}\n\treturn -EINVAL;\n}\n\n \n \n \n\n \n\nint __init kcapi_init(void)\n{\n\tint err;\n\n\tkcapi_wq = alloc_workqueue(\"kcapi\", 0, 0);\n\tif (!kcapi_wq)\n\t\treturn -ENOMEM;\n\n\terr = cdebug_init();\n\tif (err) {\n\t\tdestroy_workqueue(kcapi_wq);\n\t\treturn err;\n\t}\n\n\tkcapi_proc_init();\n\treturn 0;\n}\n\nvoid kcapi_exit(void)\n{\n\tkcapi_proc_exit();\n\n\tcdebug_exit();\n\tdestroy_workqueue(kcapi_wq);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}