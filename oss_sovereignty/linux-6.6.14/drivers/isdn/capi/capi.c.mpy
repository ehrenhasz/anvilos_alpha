{
  "module_name": "capi.c",
  "hash_id": "f88d5c7850de5415df2eef6b0d99e81b0ef5b83db179086696d0a5786af9f7de",
  "original_prompt": "Ingested from linux-6.6.14/drivers/isdn/capi/capi.c",
  "human_readable_source": " \n\n#include <linux/compiler.h>\n#include <linux/module.h>\n#include <linux/ethtool.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/major.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/signal.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/wait.h>\n#include <linux/tty.h>\n#include <linux/netdevice.h>\n#include <linux/ppp_defs.h>\n#include <linux/ppp-ioctl.h>\n#include <linux/skbuff.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/poll.h>\n#include <linux/capi.h>\n#include <linux/kernelcapi.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/isdn/capiutil.h>\n#include <linux/isdn/capicmd.h>\n\n#include \"kcapi.h\"\n\nMODULE_DESCRIPTION(\"CAPI4Linux: kernel CAPI layer and /dev/capi20 interface\");\nMODULE_AUTHOR(\"Carsten Paeth\");\nMODULE_LICENSE(\"GPL\");\n\n \n\nstatic DEFINE_MUTEX(capi_mutex);\nstatic struct class *capi_class;\nstatic int capi_major = 68;\t\t \n\nmodule_param_named(major, capi_major, uint, 0);\n\n#ifdef CONFIG_ISDN_CAPI_MIDDLEWARE\n#define CAPINC_NR_PORTS\t\t32\n#define CAPINC_MAX_PORTS\t256\n\nstatic int capi_ttyminors = CAPINC_NR_PORTS;\n\nmodule_param_named(ttyminors, capi_ttyminors, uint, 0);\n#endif  \n\n \n\n#define CAPINC_MAX_RECVQUEUE\t10\n#define CAPINC_MAX_SENDQUEUE\t10\n#define CAPI_MAX_BLKSIZE\t2048\n\n \n\nstruct capidev;\nstruct capincci;\nstruct capiminor;\n\nstruct ackqueue_entry {\n\tstruct list_head\tlist;\n\tu16\t\t\tdatahandle;\n};\n\nstruct capiminor {\n\tunsigned int      minor;\n\n\tstruct capi20_appl\t*ap;\n\tu32\t\t\tncci;\n\tatomic_t\t\tdatahandle;\n\tatomic_t\t\tmsgid;\n\n\tstruct tty_port port;\n\tint                ttyinstop;\n\tint                ttyoutstop;\n\n\tstruct sk_buff_head\tinqueue;\n\n\tstruct sk_buff_head\toutqueue;\n\tint\t\t\toutbytes;\n\tstruct sk_buff\t\t*outskb;\n\tspinlock_t\t\toutlock;\n\n\t \n\tstruct list_head ackqueue;\n\tint nack;\n\tspinlock_t ackqlock;\n};\n\nstruct capincci {\n\tstruct list_head list;\n\tu32\t\t ncci;\n\tstruct capidev\t*cdev;\n#ifdef CONFIG_ISDN_CAPI_MIDDLEWARE\n\tstruct capiminor *minorp;\n#endif  \n};\n\nstruct capidev {\n\tstruct list_head list;\n\tstruct capi20_appl ap;\n\tu16\t\terrcode;\n\tunsigned        userflags;\n\n\tstruct sk_buff_head recvqueue;\n\twait_queue_head_t recvwait;\n\n\tstruct list_head nccis;\n\n\tstruct mutex lock;\n};\n\n \n\nstatic DEFINE_MUTEX(capidev_list_lock);\nstatic LIST_HEAD(capidev_list);\n\n#ifdef CONFIG_ISDN_CAPI_MIDDLEWARE\n\nstatic DEFINE_SPINLOCK(capiminors_lock);\nstatic struct capiminor **capiminors;\n\nstatic struct tty_driver *capinc_tty_driver;\n\n \n\nstatic int capiminor_add_ack(struct capiminor *mp, u16 datahandle)\n{\n\tstruct ackqueue_entry *n;\n\n\tn = kmalloc(sizeof(*n), GFP_ATOMIC);\n\tif (unlikely(!n)) {\n\t\tprintk(KERN_ERR \"capi: alloc datahandle failed\\n\");\n\t\treturn -1;\n\t}\n\tn->datahandle = datahandle;\n\tINIT_LIST_HEAD(&n->list);\n\tspin_lock_bh(&mp->ackqlock);\n\tlist_add_tail(&n->list, &mp->ackqueue);\n\tmp->nack++;\n\tspin_unlock_bh(&mp->ackqlock);\n\treturn 0;\n}\n\nstatic int capiminor_del_ack(struct capiminor *mp, u16 datahandle)\n{\n\tstruct ackqueue_entry *p, *tmp;\n\n\tspin_lock_bh(&mp->ackqlock);\n\tlist_for_each_entry_safe(p, tmp, &mp->ackqueue, list) {\n\t\tif (p->datahandle == datahandle) {\n\t\t\tlist_del(&p->list);\n\t\t\tmp->nack--;\n\t\t\tspin_unlock_bh(&mp->ackqlock);\n\t\t\tkfree(p);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tspin_unlock_bh(&mp->ackqlock);\n\treturn -1;\n}\n\nstatic void capiminor_del_all_ack(struct capiminor *mp)\n{\n\tstruct ackqueue_entry *p, *tmp;\n\n\tlist_for_each_entry_safe(p, tmp, &mp->ackqueue, list) {\n\t\tlist_del(&p->list);\n\t\tkfree(p);\n\t\tmp->nack--;\n\t}\n}\n\n\n \n\nstatic void capiminor_destroy(struct tty_port *port)\n{\n\tstruct capiminor *mp = container_of(port, struct capiminor, port);\n\n\tkfree_skb(mp->outskb);\n\tskb_queue_purge(&mp->inqueue);\n\tskb_queue_purge(&mp->outqueue);\n\tcapiminor_del_all_ack(mp);\n\tkfree(mp);\n}\n\nstatic const struct tty_port_operations capiminor_port_ops = {\n\t.destruct = capiminor_destroy,\n};\n\nstatic struct capiminor *capiminor_alloc(struct capi20_appl *ap, u32 ncci)\n{\n\tstruct capiminor *mp;\n\tstruct device *dev;\n\tunsigned int minor;\n\n\tmp = kzalloc(sizeof(*mp), GFP_KERNEL);\n\tif (!mp) {\n\t\tprintk(KERN_ERR \"capi: can't alloc capiminor\\n\");\n\t\treturn NULL;\n\t}\n\n\tmp->ap = ap;\n\tmp->ncci = ncci;\n\tINIT_LIST_HEAD(&mp->ackqueue);\n\tspin_lock_init(&mp->ackqlock);\n\n\tskb_queue_head_init(&mp->inqueue);\n\tskb_queue_head_init(&mp->outqueue);\n\tspin_lock_init(&mp->outlock);\n\n\ttty_port_init(&mp->port);\n\tmp->port.ops = &capiminor_port_ops;\n\n\t \n\tspin_lock(&capiminors_lock);\n\tfor (minor = 0; minor < capi_ttyminors; minor++)\n\t\tif (!capiminors[minor]) {\n\t\t\tcapiminors[minor] = mp;\n\t\t\tbreak;\n\t\t}\n\tspin_unlock(&capiminors_lock);\n\n\tif (minor == capi_ttyminors) {\n\t\tprintk(KERN_NOTICE \"capi: out of minors\\n\");\n\t\tgoto err_out1;\n\t}\n\n\tmp->minor = minor;\n\n\tdev = tty_port_register_device(&mp->port, capinc_tty_driver, minor,\n\t\t\tNULL);\n\tif (IS_ERR(dev))\n\t\tgoto err_out2;\n\n\treturn mp;\n\nerr_out2:\n\tspin_lock(&capiminors_lock);\n\tcapiminors[minor] = NULL;\n\tspin_unlock(&capiminors_lock);\n\nerr_out1:\n\ttty_port_put(&mp->port);\n\treturn NULL;\n}\n\nstatic struct capiminor *capiminor_get(unsigned int minor)\n{\n\tstruct capiminor *mp;\n\n\tspin_lock(&capiminors_lock);\n\tmp = capiminors[minor];\n\tif (mp)\n\t\ttty_port_get(&mp->port);\n\tspin_unlock(&capiminors_lock);\n\n\treturn mp;\n}\n\nstatic inline void capiminor_put(struct capiminor *mp)\n{\n\ttty_port_put(&mp->port);\n}\n\nstatic void capiminor_free(struct capiminor *mp)\n{\n\ttty_unregister_device(capinc_tty_driver, mp->minor);\n\n\tspin_lock(&capiminors_lock);\n\tcapiminors[mp->minor] = NULL;\n\tspin_unlock(&capiminors_lock);\n\n\tcapiminor_put(mp);\n}\n\n \n\nstatic void capincci_alloc_minor(struct capidev *cdev, struct capincci *np)\n{\n\tif (cdev->userflags & CAPIFLAG_HIGHJACKING)\n\t\tnp->minorp = capiminor_alloc(&cdev->ap, np->ncci);\n}\n\nstatic void capincci_free_minor(struct capincci *np)\n{\n\tstruct capiminor *mp = np->minorp;\n\tstruct tty_struct *tty;\n\n\tif (mp) {\n\t\ttty = tty_port_tty_get(&mp->port);\n\t\tif (tty) {\n\t\t\ttty_vhangup(tty);\n\t\t\ttty_kref_put(tty);\n\t\t}\n\n\t\tcapiminor_free(mp);\n\t}\n}\n\nstatic inline unsigned int capincci_minor_opencount(struct capincci *np)\n{\n\tstruct capiminor *mp = np->minorp;\n\tunsigned int count = 0;\n\tstruct tty_struct *tty;\n\n\tif (mp) {\n\t\ttty = tty_port_tty_get(&mp->port);\n\t\tif (tty) {\n\t\t\tcount = tty->count;\n\t\t\ttty_kref_put(tty);\n\t\t}\n\t}\n\treturn count;\n}\n\n#else  \n\nstatic inline void\ncapincci_alloc_minor(struct capidev *cdev, struct capincci *np) { }\nstatic inline void capincci_free_minor(struct capincci *np) { }\n\n#endif  \n\nstatic struct capincci *capincci_alloc(struct capidev *cdev, u32 ncci)\n{\n\tstruct capincci *np;\n\n\tnp = kzalloc(sizeof(*np), GFP_KERNEL);\n\tif (!np)\n\t\treturn NULL;\n\tnp->ncci = ncci;\n\tnp->cdev = cdev;\n\n\tcapincci_alloc_minor(cdev, np);\n\n\tlist_add_tail(&np->list, &cdev->nccis);\n\n\treturn np;\n}\n\nstatic void capincci_free(struct capidev *cdev, u32 ncci)\n{\n\tstruct capincci *np, *tmp;\n\n\tlist_for_each_entry_safe(np, tmp, &cdev->nccis, list)\n\t\tif (ncci == 0xffffffff || np->ncci == ncci) {\n\t\t\tcapincci_free_minor(np);\n\t\t\tlist_del(&np->list);\n\t\t\tkfree(np);\n\t\t}\n}\n\n#ifdef CONFIG_ISDN_CAPI_MIDDLEWARE\nstatic struct capincci *capincci_find(struct capidev *cdev, u32 ncci)\n{\n\tstruct capincci *np;\n\n\tlist_for_each_entry(np, &cdev->nccis, list)\n\t\tif (np->ncci == ncci)\n\t\t\treturn np;\n\treturn NULL;\n}\n\n \n\nstatic struct sk_buff *\ngen_data_b3_resp_for(struct capiminor *mp, struct sk_buff *skb)\n{\n\tstruct sk_buff *nskb;\n\tnskb = alloc_skb(CAPI_DATA_B3_RESP_LEN, GFP_KERNEL);\n\tif (nskb) {\n\t\tu16 datahandle = CAPIMSG_U16(skb->data, CAPIMSG_BASELEN + 4 + 4 + 2);\n\t\tunsigned char *s = skb_put(nskb, CAPI_DATA_B3_RESP_LEN);\n\t\tcapimsg_setu16(s, 0, CAPI_DATA_B3_RESP_LEN);\n\t\tcapimsg_setu16(s, 2, mp->ap->applid);\n\t\tcapimsg_setu8 (s, 4, CAPI_DATA_B3);\n\t\tcapimsg_setu8 (s, 5, CAPI_RESP);\n\t\tcapimsg_setu16(s, 6, atomic_inc_return(&mp->msgid));\n\t\tcapimsg_setu32(s, 8, mp->ncci);\n\t\tcapimsg_setu16(s, 12, datahandle);\n\t}\n\treturn nskb;\n}\n\nstatic int handle_recv_skb(struct capiminor *mp, struct sk_buff *skb)\n{\n\tunsigned int datalen = skb->len - CAPIMSG_LEN(skb->data);\n\tstruct tty_struct *tty;\n\tstruct sk_buff *nskb;\n\tu16 errcode, datahandle;\n\tstruct tty_ldisc *ld;\n\tint ret = -1;\n\n\ttty = tty_port_tty_get(&mp->port);\n\tif (!tty) {\n\t\tpr_debug(\"capi: currently no receiver\\n\");\n\t\treturn -1;\n\t}\n\n\tld = tty_ldisc_ref(tty);\n\tif (!ld) {\n\t\t \n\t\tret = 0;\n\t\tkfree_skb(skb);\n\t\tgoto deref_tty;\n\t}\n\n\tif (ld->ops->receive_buf == NULL) {\n\t\tpr_debug(\"capi: ldisc has no receive_buf function\\n\");\n\t\t \n\t\tgoto free_skb;\n\t}\n\tif (mp->ttyinstop) {\n\t\tpr_debug(\"capi: recv tty throttled\\n\");\n\t\tgoto deref_ldisc;\n\t}\n\n\tif (tty->receive_room < datalen) {\n\t\tpr_debug(\"capi: no room in tty\\n\");\n\t\tgoto deref_ldisc;\n\t}\n\n\tnskb = gen_data_b3_resp_for(mp, skb);\n\tif (!nskb) {\n\t\tprintk(KERN_ERR \"capi: gen_data_b3_resp failed\\n\");\n\t\tgoto deref_ldisc;\n\t}\n\n\tdatahandle = CAPIMSG_U16(skb->data, CAPIMSG_BASELEN + 4);\n\n\terrcode = capi20_put_message(mp->ap, nskb);\n\n\tif (errcode == CAPI_NOERROR) {\n\t\tskb_pull(skb, CAPIMSG_LEN(skb->data));\n\t\tpr_debug(\"capi: DATA_B3_RESP %u len=%d => ldisc\\n\",\n\t\t\t datahandle, skb->len);\n\t\tld->ops->receive_buf(tty, skb->data, NULL, skb->len);\n\t} else {\n\t\tprintk(KERN_ERR \"capi: send DATA_B3_RESP failed=%x\\n\",\n\t\t       errcode);\n\t\tkfree_skb(nskb);\n\n\t\tif (errcode == CAPI_SENDQUEUEFULL)\n\t\t\tgoto deref_ldisc;\n\t}\n\nfree_skb:\n\tret = 0;\n\tkfree_skb(skb);\n\nderef_ldisc:\n\ttty_ldisc_deref(ld);\n\nderef_tty:\n\ttty_kref_put(tty);\n\treturn ret;\n}\n\nstatic void handle_minor_recv(struct capiminor *mp)\n{\n\tstruct sk_buff *skb;\n\n\twhile ((skb = skb_dequeue(&mp->inqueue)) != NULL)\n\t\tif (handle_recv_skb(mp, skb) < 0) {\n\t\t\tskb_queue_head(&mp->inqueue, skb);\n\t\t\treturn;\n\t\t}\n}\n\nstatic void handle_minor_send(struct capiminor *mp)\n{\n\tstruct tty_struct *tty;\n\tstruct sk_buff *skb;\n\tu16 len;\n\tu16 errcode;\n\tu16 datahandle;\n\n\ttty = tty_port_tty_get(&mp->port);\n\tif (!tty)\n\t\treturn;\n\n\tif (mp->ttyoutstop) {\n\t\tpr_debug(\"capi: send: tty stopped\\n\");\n\t\ttty_kref_put(tty);\n\t\treturn;\n\t}\n\n\twhile (1) {\n\t\tspin_lock_bh(&mp->outlock);\n\t\tskb = __skb_dequeue(&mp->outqueue);\n\t\tif (!skb) {\n\t\t\tspin_unlock_bh(&mp->outlock);\n\t\t\tbreak;\n\t\t}\n\t\tlen = (u16)skb->len;\n\t\tmp->outbytes -= len;\n\t\tspin_unlock_bh(&mp->outlock);\n\n\t\tdatahandle = atomic_inc_return(&mp->datahandle);\n\t\tskb_push(skb, CAPI_DATA_B3_REQ_LEN);\n\t\tmemset(skb->data, 0, CAPI_DATA_B3_REQ_LEN);\n\t\tcapimsg_setu16(skb->data, 0, CAPI_DATA_B3_REQ_LEN);\n\t\tcapimsg_setu16(skb->data, 2, mp->ap->applid);\n\t\tcapimsg_setu8 (skb->data, 4, CAPI_DATA_B3);\n\t\tcapimsg_setu8 (skb->data, 5, CAPI_REQ);\n\t\tcapimsg_setu16(skb->data, 6, atomic_inc_return(&mp->msgid));\n\t\tcapimsg_setu32(skb->data, 8, mp->ncci);\t \n\t\tcapimsg_setu32(skb->data, 12, (u32)(long)skb->data); \n\t\tcapimsg_setu16(skb->data, 16, len);\t \n\t\tcapimsg_setu16(skb->data, 18, datahandle);\n\t\tcapimsg_setu16(skb->data, 20, 0);\t \n\n\t\tif (capiminor_add_ack(mp, datahandle) < 0) {\n\t\t\tskb_pull(skb, CAPI_DATA_B3_REQ_LEN);\n\n\t\t\tspin_lock_bh(&mp->outlock);\n\t\t\t__skb_queue_head(&mp->outqueue, skb);\n\t\t\tmp->outbytes += len;\n\t\t\tspin_unlock_bh(&mp->outlock);\n\n\t\t\tbreak;\n\t\t}\n\t\terrcode = capi20_put_message(mp->ap, skb);\n\t\tif (errcode == CAPI_NOERROR) {\n\t\t\tpr_debug(\"capi: DATA_B3_REQ %u len=%u\\n\",\n\t\t\t\t datahandle, len);\n\t\t\tcontinue;\n\t\t}\n\t\tcapiminor_del_ack(mp, datahandle);\n\n\t\tif (errcode == CAPI_SENDQUEUEFULL) {\n\t\t\tskb_pull(skb, CAPI_DATA_B3_REQ_LEN);\n\n\t\t\tspin_lock_bh(&mp->outlock);\n\t\t\t__skb_queue_head(&mp->outqueue, skb);\n\t\t\tmp->outbytes += len;\n\t\t\tspin_unlock_bh(&mp->outlock);\n\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tprintk(KERN_ERR \"capi: put_message = %x\\n\", errcode);\n\t\tkfree_skb(skb);\n\t}\n\ttty_kref_put(tty);\n}\n\n#endif  \n \n\nstatic void capi_recv_message(struct capi20_appl *ap, struct sk_buff *skb)\n{\n\tstruct capidev *cdev = ap->private;\n#ifdef CONFIG_ISDN_CAPI_MIDDLEWARE\n\tstruct capiminor *mp;\n\tu16 datahandle;\n\tstruct capincci *np;\n#endif  \n\n\tmutex_lock(&cdev->lock);\n\n\tif (CAPIMSG_CMD(skb->data) == CAPI_CONNECT_B3_CONF) {\n\t\tu16 info = CAPIMSG_U16(skb->data, 12); \n\t\tif ((info & 0xff00) == 0)\n\t\t\tcapincci_alloc(cdev, CAPIMSG_NCCI(skb->data));\n\t}\n\tif (CAPIMSG_CMD(skb->data) == CAPI_CONNECT_B3_IND)\n\t\tcapincci_alloc(cdev, CAPIMSG_NCCI(skb->data));\n\n\tif (CAPIMSG_COMMAND(skb->data) != CAPI_DATA_B3) {\n\t\tskb_queue_tail(&cdev->recvqueue, skb);\n\t\twake_up_interruptible(&cdev->recvwait);\n\t\tgoto unlock_out;\n\t}\n\n#ifndef CONFIG_ISDN_CAPI_MIDDLEWARE\n\tskb_queue_tail(&cdev->recvqueue, skb);\n\twake_up_interruptible(&cdev->recvwait);\n\n#else  \n\n\tnp = capincci_find(cdev, CAPIMSG_CONTROL(skb->data));\n\tif (!np) {\n\t\tprintk(KERN_ERR \"BUG: capi_signal: ncci not found\\n\");\n\t\tskb_queue_tail(&cdev->recvqueue, skb);\n\t\twake_up_interruptible(&cdev->recvwait);\n\t\tgoto unlock_out;\n\t}\n\n\tmp = np->minorp;\n\tif (!mp) {\n\t\tskb_queue_tail(&cdev->recvqueue, skb);\n\t\twake_up_interruptible(&cdev->recvwait);\n\t\tgoto unlock_out;\n\t}\n\tif (CAPIMSG_SUBCOMMAND(skb->data) == CAPI_IND) {\n\t\tdatahandle = CAPIMSG_U16(skb->data, CAPIMSG_BASELEN + 4 + 4 + 2);\n\t\tpr_debug(\"capi_signal: DATA_B3_IND %u len=%d\\n\",\n\t\t\t datahandle, skb->len-CAPIMSG_LEN(skb->data));\n\t\tskb_queue_tail(&mp->inqueue, skb);\n\n\t\thandle_minor_recv(mp);\n\n\t} else if (CAPIMSG_SUBCOMMAND(skb->data) == CAPI_CONF) {\n\n\t\tdatahandle = CAPIMSG_U16(skb->data, CAPIMSG_BASELEN + 4);\n\t\tpr_debug(\"capi_signal: DATA_B3_CONF %u 0x%x\\n\",\n\t\t\t datahandle,\n\t\t\t CAPIMSG_U16(skb->data, CAPIMSG_BASELEN + 4 + 2));\n\t\tkfree_skb(skb);\n\t\tcapiminor_del_ack(mp, datahandle);\n\t\ttty_port_tty_wakeup(&mp->port);\n\t\thandle_minor_send(mp);\n\n\t} else {\n\t\t \n\t\tskb_queue_tail(&cdev->recvqueue, skb);\n\t\twake_up_interruptible(&cdev->recvwait);\n\t}\n#endif  \n\nunlock_out:\n\tmutex_unlock(&cdev->lock);\n}\n\n \n\nstatic ssize_t\ncapi_read(struct file *file, char __user *buf, size_t count, loff_t *ppos)\n{\n\tstruct capidev *cdev = file->private_data;\n\tstruct sk_buff *skb;\n\tsize_t copied;\n\tint err;\n\n\tif (!cdev->ap.applid)\n\t\treturn -ENODEV;\n\n\tskb = skb_dequeue(&cdev->recvqueue);\n\tif (!skb) {\n\t\tif (file->f_flags & O_NONBLOCK)\n\t\t\treturn -EAGAIN;\n\t\terr = wait_event_interruptible(cdev->recvwait,\n\t\t\t\t\t       (skb = skb_dequeue(&cdev->recvqueue)));\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tif (skb->len > count) {\n\t\tskb_queue_head(&cdev->recvqueue, skb);\n\t\treturn -EMSGSIZE;\n\t}\n\tif (copy_to_user(buf, skb->data, skb->len)) {\n\t\tskb_queue_head(&cdev->recvqueue, skb);\n\t\treturn -EFAULT;\n\t}\n\tcopied = skb->len;\n\n\tkfree_skb(skb);\n\n\treturn copied;\n}\n\nstatic ssize_t\ncapi_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos)\n{\n\tstruct capidev *cdev = file->private_data;\n\tstruct sk_buff *skb;\n\tu16 mlen;\n\n\tif (!cdev->ap.applid)\n\t\treturn -ENODEV;\n\n\tif (count < CAPIMSG_BASELEN)\n\t\treturn -EINVAL;\n\n\tskb = alloc_skb(count, GFP_USER);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tif (copy_from_user(skb_put(skb, count), buf, count)) {\n\t\tkfree_skb(skb);\n\t\treturn -EFAULT;\n\t}\n\tmlen = CAPIMSG_LEN(skb->data);\n\tif (CAPIMSG_CMD(skb->data) == CAPI_DATA_B3_REQ) {\n\t\tif (count < CAPI_DATA_B3_REQ_LEN ||\n\t\t    (size_t)(mlen + CAPIMSG_DATALEN(skb->data)) != count) {\n\t\t\tkfree_skb(skb);\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\tif (mlen != count) {\n\t\t\tkfree_skb(skb);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tCAPIMSG_SETAPPID(skb->data, cdev->ap.applid);\n\n\tif (CAPIMSG_CMD(skb->data) == CAPI_DISCONNECT_B3_RESP) {\n\t\tif (count < CAPI_DISCONNECT_B3_RESP_LEN) {\n\t\t\tkfree_skb(skb);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmutex_lock(&cdev->lock);\n\t\tcapincci_free(cdev, CAPIMSG_NCCI(skb->data));\n\t\tmutex_unlock(&cdev->lock);\n\t}\n\n\tcdev->errcode = capi20_put_message(&cdev->ap, skb);\n\n\tif (cdev->errcode) {\n\t\tkfree_skb(skb);\n\t\treturn -EIO;\n\t}\n\treturn count;\n}\n\nstatic __poll_t\ncapi_poll(struct file *file, poll_table *wait)\n{\n\tstruct capidev *cdev = file->private_data;\n\t__poll_t mask = 0;\n\n\tif (!cdev->ap.applid)\n\t\treturn EPOLLERR;\n\n\tpoll_wait(file, &(cdev->recvwait), wait);\n\tmask = EPOLLOUT | EPOLLWRNORM;\n\tif (!skb_queue_empty_lockless(&cdev->recvqueue))\n\t\tmask |= EPOLLIN | EPOLLRDNORM;\n\treturn mask;\n}\n\nstatic int\ncapi_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tstruct capidev *cdev = file->private_data;\n\tcapi_ioctl_struct data;\n\tint retval = -EINVAL;\n\tvoid __user *argp = (void __user *)arg;\n\n\tswitch (cmd) {\n\tcase CAPI_REGISTER:\n\t\tmutex_lock(&cdev->lock);\n\n\t\tif (cdev->ap.applid) {\n\t\t\tretval = -EEXIST;\n\t\t\tgoto register_out;\n\t\t}\n\t\tif (copy_from_user(&cdev->ap.rparam, argp,\n\t\t\t\t   sizeof(struct capi_register_params))) {\n\t\t\tretval = -EFAULT;\n\t\t\tgoto register_out;\n\t\t}\n\t\tcdev->ap.private = cdev;\n\t\tcdev->ap.recv_message = capi_recv_message;\n\t\tcdev->errcode = capi20_register(&cdev->ap);\n\t\tretval = (int)cdev->ap.applid;\n\t\tif (cdev->errcode) {\n\t\t\tcdev->ap.applid = 0;\n\t\t\tretval = -EIO;\n\t\t}\n\nregister_out:\n\t\tmutex_unlock(&cdev->lock);\n\t\treturn retval;\n\n\tcase CAPI_GET_VERSION:\n\t\tif (copy_from_user(&data.contr, argp,\n\t\t\t\t   sizeof(data.contr)))\n\t\t\treturn -EFAULT;\n\t\tcdev->errcode = capi20_get_version(data.contr, &data.version);\n\t\tif (cdev->errcode)\n\t\t\treturn -EIO;\n\t\tif (copy_to_user(argp, &data.version,\n\t\t\t\t sizeof(data.version)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\n\tcase CAPI_GET_SERIAL:\n\t\tif (copy_from_user(&data.contr, argp,\n\t\t\t\t   sizeof(data.contr)))\n\t\t\treturn -EFAULT;\n\t\tcdev->errcode = capi20_get_serial(data.contr, data.serial);\n\t\tif (cdev->errcode)\n\t\t\treturn -EIO;\n\t\tif (copy_to_user(argp, data.serial,\n\t\t\t\t sizeof(data.serial)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\n\tcase CAPI_GET_PROFILE:\n\t\tif (copy_from_user(&data.contr, argp,\n\t\t\t\t   sizeof(data.contr)))\n\t\t\treturn -EFAULT;\n\n\t\tif (data.contr == 0) {\n\t\t\tcdev->errcode = capi20_get_profile(data.contr, &data.profile);\n\t\t\tif (cdev->errcode)\n\t\t\t\treturn -EIO;\n\n\t\t\tretval = copy_to_user(argp,\n\t\t\t\t\t      &data.profile.ncontroller,\n\t\t\t\t\t      sizeof(data.profile.ncontroller));\n\n\t\t} else {\n\t\t\tcdev->errcode = capi20_get_profile(data.contr, &data.profile);\n\t\t\tif (cdev->errcode)\n\t\t\t\treturn -EIO;\n\n\t\t\tretval = copy_to_user(argp, &data.profile,\n\t\t\t\t\t      sizeof(data.profile));\n\t\t}\n\t\tif (retval)\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\n\tcase CAPI_GET_MANUFACTURER:\n\t\tif (copy_from_user(&data.contr, argp,\n\t\t\t\t   sizeof(data.contr)))\n\t\t\treturn -EFAULT;\n\t\tcdev->errcode = capi20_get_manufacturer(data.contr, data.manufacturer);\n\t\tif (cdev->errcode)\n\t\t\treturn -EIO;\n\n\t\tif (copy_to_user(argp, data.manufacturer,\n\t\t\t\t sizeof(data.manufacturer)))\n\t\t\treturn -EFAULT;\n\n\t\treturn 0;\n\n\tcase CAPI_GET_ERRCODE:\n\t\tdata.errcode = cdev->errcode;\n\t\tcdev->errcode = CAPI_NOERROR;\n\t\tif (arg) {\n\t\t\tif (copy_to_user(argp, &data.errcode,\n\t\t\t\t\t sizeof(data.errcode)))\n\t\t\t\treturn -EFAULT;\n\t\t}\n\t\treturn data.errcode;\n\n\tcase CAPI_INSTALLED:\n\t\tif (capi20_isinstalled() == CAPI_NOERROR)\n\t\t\treturn 0;\n\t\treturn -ENXIO;\n\n\tcase CAPI_MANUFACTURER_CMD: {\n\t\tstruct capi_manufacturer_cmd mcmd;\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\t\tif (copy_from_user(&mcmd, argp, sizeof(mcmd)))\n\t\t\treturn -EFAULT;\n\t\treturn capi20_manufacturer(mcmd.cmd, mcmd.data);\n\t}\n\tcase CAPI_SET_FLAGS:\n\tcase CAPI_CLR_FLAGS: {\n\t\tunsigned userflags;\n\n\t\tif (copy_from_user(&userflags, argp, sizeof(userflags)))\n\t\t\treturn -EFAULT;\n\n\t\tmutex_lock(&cdev->lock);\n\t\tif (cmd == CAPI_SET_FLAGS)\n\t\t\tcdev->userflags |= userflags;\n\t\telse\n\t\t\tcdev->userflags &= ~userflags;\n\t\tmutex_unlock(&cdev->lock);\n\t\treturn 0;\n\t}\n\tcase CAPI_GET_FLAGS:\n\t\tif (copy_to_user(argp, &cdev->userflags,\n\t\t\t\t sizeof(cdev->userflags)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\n#ifndef CONFIG_ISDN_CAPI_MIDDLEWARE\n\tcase CAPI_NCCI_OPENCOUNT:\n\t\treturn 0;\n\n#else  \n\tcase CAPI_NCCI_OPENCOUNT: {\n\t\tstruct capincci *nccip;\n\t\tunsigned ncci;\n\t\tint count = 0;\n\n\t\tif (copy_from_user(&ncci, argp, sizeof(ncci)))\n\t\t\treturn -EFAULT;\n\n\t\tmutex_lock(&cdev->lock);\n\t\tnccip = capincci_find(cdev, (u32)ncci);\n\t\tif (nccip)\n\t\t\tcount = capincci_minor_opencount(nccip);\n\t\tmutex_unlock(&cdev->lock);\n\t\treturn count;\n\t}\n\n\tcase CAPI_NCCI_GETUNIT: {\n\t\tstruct capincci *nccip;\n\t\tstruct capiminor *mp;\n\t\tunsigned ncci;\n\t\tint unit = -ESRCH;\n\n\t\tif (copy_from_user(&ncci, argp, sizeof(ncci)))\n\t\t\treturn -EFAULT;\n\n\t\tmutex_lock(&cdev->lock);\n\t\tnccip = capincci_find(cdev, (u32)ncci);\n\t\tif (nccip) {\n\t\t\tmp = nccip->minorp;\n\t\t\tif (mp)\n\t\t\t\tunit = mp->minor;\n\t\t}\n\t\tmutex_unlock(&cdev->lock);\n\t\treturn unit;\n\t}\n#endif  \n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic long\ncapi_unlocked_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tint ret;\n\n\tmutex_lock(&capi_mutex);\n\tret = capi_ioctl(file, cmd, arg);\n\tmutex_unlock(&capi_mutex);\n\n\treturn ret;\n}\n\n#ifdef CONFIG_COMPAT\nstatic long\ncapi_compat_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tint ret;\n\n\tif (cmd == CAPI_MANUFACTURER_CMD) {\n\t\tstruct {\n\t\t\tcompat_ulong_t cmd;\n\t\t\tcompat_uptr_t data;\n\t\t} mcmd32;\n\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\t\tif (copy_from_user(&mcmd32, compat_ptr(arg), sizeof(mcmd32)))\n\t\t\treturn -EFAULT;\n\n\t\tmutex_lock(&capi_mutex);\n\t\tret = capi20_manufacturer(mcmd32.cmd, compat_ptr(mcmd32.data));\n\t\tmutex_unlock(&capi_mutex);\n\n\t\treturn ret;\n\t}\n\n\treturn capi_unlocked_ioctl(file, cmd, (unsigned long)compat_ptr(arg));\n}\n#endif\n\nstatic int capi_open(struct inode *inode, struct file *file)\n{\n\tstruct capidev *cdev;\n\n\tcdev = kzalloc(sizeof(*cdev), GFP_KERNEL);\n\tif (!cdev)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&cdev->lock);\n\tskb_queue_head_init(&cdev->recvqueue);\n\tinit_waitqueue_head(&cdev->recvwait);\n\tINIT_LIST_HEAD(&cdev->nccis);\n\tfile->private_data = cdev;\n\n\tmutex_lock(&capidev_list_lock);\n\tlist_add_tail(&cdev->list, &capidev_list);\n\tmutex_unlock(&capidev_list_lock);\n\n\treturn stream_open(inode, file);\n}\n\nstatic int capi_release(struct inode *inode, struct file *file)\n{\n\tstruct capidev *cdev = file->private_data;\n\n\tmutex_lock(&capidev_list_lock);\n\tlist_del(&cdev->list);\n\tmutex_unlock(&capidev_list_lock);\n\n\tif (cdev->ap.applid)\n\t\tcapi20_release(&cdev->ap);\n\tskb_queue_purge(&cdev->recvqueue);\n\tcapincci_free(cdev, 0xffffffff);\n\n\tkfree(cdev);\n\treturn 0;\n}\n\nstatic const struct file_operations capi_fops =\n{\n\t.owner\t\t= THIS_MODULE,\n\t.llseek\t\t= no_llseek,\n\t.read\t\t= capi_read,\n\t.write\t\t= capi_write,\n\t.poll\t\t= capi_poll,\n\t.unlocked_ioctl\t= capi_unlocked_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl\t= capi_compat_ioctl,\n#endif\n\t.open\t\t= capi_open,\n\t.release\t= capi_release,\n};\n\n#ifdef CONFIG_ISDN_CAPI_MIDDLEWARE\n \n\nstatic int\ncapinc_tty_install(struct tty_driver *driver, struct tty_struct *tty)\n{\n\tstruct capiminor *mp = capiminor_get(tty->index);\n\tint ret = tty_standard_install(driver, tty);\n\n\tif (ret == 0)\n\t\ttty->driver_data = mp;\n\telse\n\t\tcapiminor_put(mp);\n\treturn ret;\n}\n\nstatic void capinc_tty_cleanup(struct tty_struct *tty)\n{\n\tstruct capiminor *mp = tty->driver_data;\n\ttty->driver_data = NULL;\n\tcapiminor_put(mp);\n}\n\nstatic int capinc_tty_open(struct tty_struct *tty, struct file *filp)\n{\n\tstruct capiminor *mp = tty->driver_data;\n\tint err;\n\n\terr = tty_port_open(&mp->port, tty, filp);\n\tif (err)\n\t\treturn err;\n\n\thandle_minor_recv(mp);\n\treturn 0;\n}\n\nstatic void capinc_tty_close(struct tty_struct *tty, struct file *filp)\n{\n\tstruct capiminor *mp = tty->driver_data;\n\n\ttty_port_close(&mp->port, tty, filp);\n}\n\nstatic ssize_t capinc_tty_write(struct tty_struct *tty, const u8 *buf,\n\t\t\t\tsize_t count)\n{\n\tstruct capiminor *mp = tty->driver_data;\n\tstruct sk_buff *skb;\n\n\tpr_debug(\"capinc_tty_write(count=%zu)\\n\", count);\n\n\tspin_lock_bh(&mp->outlock);\n\tskb = mp->outskb;\n\tif (skb) {\n\t\tmp->outskb = NULL;\n\t\t__skb_queue_tail(&mp->outqueue, skb);\n\t\tmp->outbytes += skb->len;\n\t}\n\n\tskb = alloc_skb(CAPI_DATA_B3_REQ_LEN + count, GFP_ATOMIC);\n\tif (!skb) {\n\t\tprintk(KERN_ERR \"capinc_tty_write: alloc_skb failed\\n\");\n\t\tspin_unlock_bh(&mp->outlock);\n\t\treturn -ENOMEM;\n\t}\n\n\tskb_reserve(skb, CAPI_DATA_B3_REQ_LEN);\n\tskb_put_data(skb, buf, count);\n\n\t__skb_queue_tail(&mp->outqueue, skb);\n\tmp->outbytes += skb->len;\n\tspin_unlock_bh(&mp->outlock);\n\n\thandle_minor_send(mp);\n\n\treturn count;\n}\n\nstatic int capinc_tty_put_char(struct tty_struct *tty, u8 ch)\n{\n\tstruct capiminor *mp = tty->driver_data;\n\tbool invoke_send = false;\n\tstruct sk_buff *skb;\n\tint ret = 1;\n\n\tpr_debug(\"capinc_put_char(%u)\\n\", ch);\n\n\tspin_lock_bh(&mp->outlock);\n\tskb = mp->outskb;\n\tif (skb) {\n\t\tif (skb_tailroom(skb) > 0) {\n\t\t\tskb_put_u8(skb, ch);\n\t\t\tgoto unlock_out;\n\t\t}\n\t\tmp->outskb = NULL;\n\t\t__skb_queue_tail(&mp->outqueue, skb);\n\t\tmp->outbytes += skb->len;\n\t\tinvoke_send = true;\n\t}\n\n\tskb = alloc_skb(CAPI_DATA_B3_REQ_LEN + CAPI_MAX_BLKSIZE, GFP_ATOMIC);\n\tif (skb) {\n\t\tskb_reserve(skb, CAPI_DATA_B3_REQ_LEN);\n\t\tskb_put_u8(skb, ch);\n\t\tmp->outskb = skb;\n\t} else {\n\t\tprintk(KERN_ERR \"capinc_put_char: char %u lost\\n\", ch);\n\t\tret = 0;\n\t}\n\nunlock_out:\n\tspin_unlock_bh(&mp->outlock);\n\n\tif (invoke_send)\n\t\thandle_minor_send(mp);\n\n\treturn ret;\n}\n\nstatic void capinc_tty_flush_chars(struct tty_struct *tty)\n{\n\tstruct capiminor *mp = tty->driver_data;\n\tstruct sk_buff *skb;\n\n\tspin_lock_bh(&mp->outlock);\n\tskb = mp->outskb;\n\tif (skb) {\n\t\tmp->outskb = NULL;\n\t\t__skb_queue_tail(&mp->outqueue, skb);\n\t\tmp->outbytes += skb->len;\n\t\tspin_unlock_bh(&mp->outlock);\n\n\t\thandle_minor_send(mp);\n\t} else\n\t\tspin_unlock_bh(&mp->outlock);\n\n\thandle_minor_recv(mp);\n}\n\nstatic unsigned int capinc_tty_write_room(struct tty_struct *tty)\n{\n\tstruct capiminor *mp = tty->driver_data;\n\tunsigned int room;\n\n\troom = CAPINC_MAX_SENDQUEUE-skb_queue_len(&mp->outqueue);\n\troom *= CAPI_MAX_BLKSIZE;\n\tpr_debug(\"capinc_tty_write_room = %u\\n\", room);\n\treturn room;\n}\n\nstatic unsigned int capinc_tty_chars_in_buffer(struct tty_struct *tty)\n{\n\tstruct capiminor *mp = tty->driver_data;\n\n\tpr_debug(\"capinc_tty_chars_in_buffer = %d nack=%d sq=%d rq=%d\\n\",\n\t\t mp->outbytes, mp->nack,\n\t\t skb_queue_len(&mp->outqueue),\n\t\t skb_queue_len(&mp->inqueue));\n\treturn mp->outbytes;\n}\n\nstatic void capinc_tty_throttle(struct tty_struct *tty)\n{\n\tstruct capiminor *mp = tty->driver_data;\n\tmp->ttyinstop = 1;\n}\n\nstatic void capinc_tty_unthrottle(struct tty_struct *tty)\n{\n\tstruct capiminor *mp = tty->driver_data;\n\n\tmp->ttyinstop = 0;\n\thandle_minor_recv(mp);\n}\n\nstatic void capinc_tty_stop(struct tty_struct *tty)\n{\n\tstruct capiminor *mp = tty->driver_data;\n\n\tmp->ttyoutstop = 1;\n}\n\nstatic void capinc_tty_start(struct tty_struct *tty)\n{\n\tstruct capiminor *mp = tty->driver_data;\n\n\tmp->ttyoutstop = 0;\n\thandle_minor_send(mp);\n}\n\nstatic void capinc_tty_hangup(struct tty_struct *tty)\n{\n\tstruct capiminor *mp = tty->driver_data;\n\n\ttty_port_hangup(&mp->port);\n}\n\nstatic void capinc_tty_send_xchar(struct tty_struct *tty, char ch)\n{\n\tpr_debug(\"capinc_tty_send_xchar(%d)\\n\", ch);\n}\n\nstatic const struct tty_operations capinc_ops = {\n\t.open = capinc_tty_open,\n\t.close = capinc_tty_close,\n\t.write = capinc_tty_write,\n\t.put_char = capinc_tty_put_char,\n\t.flush_chars = capinc_tty_flush_chars,\n\t.write_room = capinc_tty_write_room,\n\t.chars_in_buffer = capinc_tty_chars_in_buffer,\n\t.throttle = capinc_tty_throttle,\n\t.unthrottle = capinc_tty_unthrottle,\n\t.stop = capinc_tty_stop,\n\t.start = capinc_tty_start,\n\t.hangup = capinc_tty_hangup,\n\t.send_xchar = capinc_tty_send_xchar,\n\t.install = capinc_tty_install,\n\t.cleanup = capinc_tty_cleanup,\n};\n\nstatic int __init capinc_tty_init(void)\n{\n\tstruct tty_driver *drv;\n\tint err;\n\n\tif (capi_ttyminors > CAPINC_MAX_PORTS)\n\t\tcapi_ttyminors = CAPINC_MAX_PORTS;\n\tif (capi_ttyminors <= 0)\n\t\tcapi_ttyminors = CAPINC_NR_PORTS;\n\n\tcapiminors = kcalloc(capi_ttyminors, sizeof(struct capiminor *),\n\t\t\t     GFP_KERNEL);\n\tif (!capiminors)\n\t\treturn -ENOMEM;\n\n\tdrv = tty_alloc_driver(capi_ttyminors, TTY_DRIVER_REAL_RAW |\n\t\t\tTTY_DRIVER_RESET_TERMIOS | TTY_DRIVER_DYNAMIC_DEV);\n\tif (IS_ERR(drv)) {\n\t\tkfree(capiminors);\n\t\treturn PTR_ERR(drv);\n\t}\n\tdrv->driver_name = \"capi_nc\";\n\tdrv->name = \"capi!\";\n\tdrv->major = 0;\n\tdrv->minor_start = 0;\n\tdrv->type = TTY_DRIVER_TYPE_SERIAL;\n\tdrv->subtype = SERIAL_TYPE_NORMAL;\n\tdrv->init_termios = tty_std_termios;\n\tdrv->init_termios.c_iflag = ICRNL;\n\tdrv->init_termios.c_oflag = OPOST | ONLCR;\n\tdrv->init_termios.c_cflag = B9600 | CS8 | CREAD | HUPCL | CLOCAL;\n\tdrv->init_termios.c_lflag = 0;\n\ttty_set_operations(drv, &capinc_ops);\n\n\terr = tty_register_driver(drv);\n\tif (err) {\n\t\ttty_driver_kref_put(drv);\n\t\tkfree(capiminors);\n\t\tprintk(KERN_ERR \"Couldn't register capi_nc driver\\n\");\n\t\treturn err;\n\t}\n\tcapinc_tty_driver = drv;\n\treturn 0;\n}\n\nstatic void __exit capinc_tty_exit(void)\n{\n\ttty_unregister_driver(capinc_tty_driver);\n\ttty_driver_kref_put(capinc_tty_driver);\n\tkfree(capiminors);\n}\n\n#else  \n\nstatic inline int capinc_tty_init(void)\n{\n\treturn 0;\n}\n\nstatic inline void capinc_tty_exit(void) { }\n\n#endif  \n\n \n\n \nstatic int __maybe_unused capi20_proc_show(struct seq_file *m, void *v)\n{\n\tstruct capidev *cdev;\n\tstruct list_head *l;\n\n\tmutex_lock(&capidev_list_lock);\n\tlist_for_each(l, &capidev_list) {\n\t\tcdev = list_entry(l, struct capidev, list);\n\t\tseq_printf(m, \"0 %d %lu %lu %lu %lu\\n\",\n\t\t\t   cdev->ap.applid,\n\t\t\t   cdev->ap.nrecvctlpkt,\n\t\t\t   cdev->ap.nrecvdatapkt,\n\t\t\t   cdev->ap.nsentctlpkt,\n\t\t\t   cdev->ap.nsentdatapkt);\n\t}\n\tmutex_unlock(&capidev_list_lock);\n\treturn 0;\n}\n\n \nstatic int __maybe_unused capi20ncci_proc_show(struct seq_file *m, void *v)\n{\n\tstruct capidev *cdev;\n\tstruct capincci *np;\n\n\tmutex_lock(&capidev_list_lock);\n\tlist_for_each_entry(cdev, &capidev_list, list) {\n\t\tmutex_lock(&cdev->lock);\n\t\tlist_for_each_entry(np, &cdev->nccis, list)\n\t\t\tseq_printf(m, \"%d 0x%x\\n\", cdev->ap.applid, np->ncci);\n\t\tmutex_unlock(&cdev->lock);\n\t}\n\tmutex_unlock(&capidev_list_lock);\n\treturn 0;\n}\n\nstatic void __init proc_init(void)\n{\n\tproc_create_single(\"capi/capi20\", 0, NULL, capi20_proc_show);\n\tproc_create_single(\"capi/capi20ncci\", 0, NULL, capi20ncci_proc_show);\n}\n\nstatic void __exit proc_exit(void)\n{\n\tremove_proc_entry(\"capi/capi20\", NULL);\n\tremove_proc_entry(\"capi/capi20ncci\", NULL);\n}\n\n \n\n\nstatic int __init capi_init(void)\n{\n\tconst char *compileinfo;\n\tint major_ret;\n\tint ret;\n\n\tret = kcapi_init();\n\tif (ret)\n\t\treturn ret;\n\n\tmajor_ret = register_chrdev(capi_major, \"capi20\", &capi_fops);\n\tif (major_ret < 0) {\n\t\tprintk(KERN_ERR \"capi20: unable to get major %d\\n\", capi_major);\n\t\tkcapi_exit();\n\t\treturn major_ret;\n\t}\n\tcapi_class = class_create(\"capi\");\n\tif (IS_ERR(capi_class)) {\n\t\tunregister_chrdev(capi_major, \"capi20\");\n\t\tkcapi_exit();\n\t\treturn PTR_ERR(capi_class);\n\t}\n\n\tdevice_create(capi_class, NULL, MKDEV(capi_major, 0), NULL, \"capi20\");\n\n\tif (capinc_tty_init() < 0) {\n\t\tdevice_destroy(capi_class, MKDEV(capi_major, 0));\n\t\tclass_destroy(capi_class);\n\t\tunregister_chrdev(capi_major, \"capi20\");\n\t\tkcapi_exit();\n\t\treturn -ENOMEM;\n\t}\n\n\tproc_init();\n\n#ifdef CONFIG_ISDN_CAPI_MIDDLEWARE\n\tcompileinfo = \" (middleware)\";\n#else\n\tcompileinfo = \" (no middleware)\";\n#endif\n\tprintk(KERN_NOTICE \"CAPI 2.0 started up with major %d%s\\n\",\n\t       capi_major, compileinfo);\n\n\treturn 0;\n}\n\nstatic void __exit capi_exit(void)\n{\n\tproc_exit();\n\n\tdevice_destroy(capi_class, MKDEV(capi_major, 0));\n\tclass_destroy(capi_class);\n\tunregister_chrdev(capi_major, \"capi20\");\n\n\tcapinc_tty_exit();\n\n\tkcapi_exit();\n}\n\nmodule_init(capi_init);\nmodule_exit(capi_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}