{
  "module_name": "kcapi_proc.c",
  "hash_id": "9c3706385eeb198cf974df1e9a7e2281492e8f140018c4e3cdd670b2f1c2f4be",
  "original_prompt": "Ingested from linux-6.6.14/drivers/isdn/capi/kcapi_proc.c",
  "human_readable_source": " \n\n\n#include \"kcapi.h\"\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/export.h>\n\nstatic char *state2str(unsigned short state)\n{\n\tswitch (state) {\n\tcase CAPI_CTR_DETECTED:\treturn \"detected\";\n\tcase CAPI_CTR_LOADING:\treturn \"loading\";\n\tcase CAPI_CTR_RUNNING:\treturn \"running\";\n\tdefault:\t        return \"???\";\n\t}\n}\n\n\n\n\n\n\n\n\n\n\nstatic void *controller_start(struct seq_file *seq, loff_t *pos)\n\t__acquires(capi_controller_lock)\n{\n\tmutex_lock(&capi_controller_lock);\n\n\tif (*pos < CAPI_MAXCONTR)\n\t\treturn &capi_controller[*pos];\n\n\treturn NULL;\n}\n\nstatic void *controller_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\t++*pos;\n\tif (*pos < CAPI_MAXCONTR)\n\t\treturn &capi_controller[*pos];\n\n\treturn NULL;\n}\n\nstatic void controller_stop(struct seq_file *seq, void *v)\n\t__releases(capi_controller_lock)\n{\n\tmutex_unlock(&capi_controller_lock);\n}\n\nstatic int controller_show(struct seq_file *seq, void *v)\n{\n\tstruct capi_ctr *ctr = *(struct capi_ctr **) v;\n\n\tif (!ctr)\n\t\treturn 0;\n\n\tseq_printf(seq, \"%d %-10s %-8s %-16s %s\\n\",\n\t\t   ctr->cnr, ctr->driver_name,\n\t\t   state2str(ctr->state),\n\t\t   ctr->name,\n\t\t   ctr->procinfo ?  ctr->procinfo(ctr) : \"\");\n\n\treturn 0;\n}\n\nstatic int contrstats_show(struct seq_file *seq, void *v)\n{\n\tstruct capi_ctr *ctr = *(struct capi_ctr **) v;\n\n\tif (!ctr)\n\t\treturn 0;\n\n\tseq_printf(seq, \"%d %lu %lu %lu %lu\\n\",\n\t\t   ctr->cnr,\n\t\t   ctr->nrecvctlpkt,\n\t\t   ctr->nrecvdatapkt,\n\t\t   ctr->nsentctlpkt,\n\t\t   ctr->nsentdatapkt);\n\n\treturn 0;\n}\n\nstatic const struct seq_operations seq_controller_ops = {\n\t.start\t= controller_start,\n\t.next\t= controller_next,\n\t.stop\t= controller_stop,\n\t.show\t= controller_show,\n};\n\nstatic const struct seq_operations seq_contrstats_ops = {\n\t.start\t= controller_start,\n\t.next\t= controller_next,\n\t.stop\t= controller_stop,\n\t.show\t= contrstats_show,\n};\n\n\n\n\n\n\n\nstatic void *applications_start(struct seq_file *seq, loff_t *pos)\n\t__acquires(capi_controller_lock)\n{\n\tmutex_lock(&capi_controller_lock);\n\n\tif (*pos < CAPI_MAXAPPL)\n\t\treturn &capi_applications[*pos];\n\n\treturn NULL;\n}\n\nstatic void *\napplications_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\t++*pos;\n\tif (*pos < CAPI_MAXAPPL)\n\t\treturn &capi_applications[*pos];\n\n\treturn NULL;\n}\n\nstatic void applications_stop(struct seq_file *seq, void *v)\n\t__releases(capi_controller_lock)\n{\n\tmutex_unlock(&capi_controller_lock);\n}\n\nstatic int\napplications_show(struct seq_file *seq, void *v)\n{\n\tstruct capi20_appl *ap = *(struct capi20_appl **) v;\n\n\tif (!ap)\n\t\treturn 0;\n\n\tseq_printf(seq, \"%u %d %d %d\\n\",\n\t\t   ap->applid,\n\t\t   ap->rparam.level3cnt,\n\t\t   ap->rparam.datablkcnt,\n\t\t   ap->rparam.datablklen);\n\n\treturn 0;\n}\n\nstatic int\napplstats_show(struct seq_file *seq, void *v)\n{\n\tstruct capi20_appl *ap = *(struct capi20_appl **) v;\n\n\tif (!ap)\n\t\treturn 0;\n\n\tseq_printf(seq, \"%u %lu %lu %lu %lu\\n\",\n\t\t   ap->applid,\n\t\t   ap->nrecvctlpkt,\n\t\t   ap->nrecvdatapkt,\n\t\t   ap->nsentctlpkt,\n\t\t   ap->nsentdatapkt);\n\n\treturn 0;\n}\n\nstatic const struct seq_operations seq_applications_ops = {\n\t.start\t= applications_start,\n\t.next\t= applications_next,\n\t.stop\t= applications_stop,\n\t.show\t= applications_show,\n};\n\nstatic const struct seq_operations seq_applstats_ops = {\n\t.start\t= applications_start,\n\t.next\t= applications_next,\n\t.stop\t= applications_stop,\n\t.show\t= applstats_show,\n};\n\n\n\n \nstatic ssize_t empty_read(struct file *file, char __user *buf,\n\t\t\t  size_t size, loff_t *off)\n{\n\treturn 0;\n}\n\nstatic const struct proc_ops empty_proc_ops = {\n\t.proc_read\t= empty_read,\n\t.proc_lseek\t= default_llseek,\n};\n\n\n\nvoid __init\nkcapi_proc_init(void)\n{\n\tproc_mkdir(\"capi\",             NULL);\n\tproc_mkdir(\"capi/controllers\", NULL);\n\tproc_create_seq(\"capi/controller\",   0, NULL, &seq_controller_ops);\n\tproc_create_seq(\"capi/contrstats\",   0, NULL, &seq_contrstats_ops);\n\tproc_create_seq(\"capi/applications\", 0, NULL, &seq_applications_ops);\n\tproc_create_seq(\"capi/applstats\",    0, NULL, &seq_applstats_ops);\n\tproc_create(\"capi/driver\",           0, NULL, &empty_proc_ops);\n}\n\nvoid\nkcapi_proc_exit(void)\n{\n\tremove_proc_entry(\"capi/driver\",       NULL);\n\tremove_proc_entry(\"capi/controller\",   NULL);\n\tremove_proc_entry(\"capi/contrstats\",   NULL);\n\tremove_proc_entry(\"capi/applications\", NULL);\n\tremove_proc_entry(\"capi/applstats\",    NULL);\n\tremove_proc_entry(\"capi/controllers\",  NULL);\n\tremove_proc_entry(\"capi\",              NULL);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}