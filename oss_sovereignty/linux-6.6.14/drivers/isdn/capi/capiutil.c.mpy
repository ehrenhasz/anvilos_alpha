{
  "module_name": "capiutil.c",
  "hash_id": "195f192d0d118a757b7ba32cc03dfb8cb5e3749e9eba5e33cf1f178a8e3b6f60",
  "original_prompt": "Ingested from linux-6.6.14/drivers/isdn/capi/capiutil.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/stddef.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/isdn/capiutil.h>\n#include <linux/slab.h>\n\n#include \"kcapi.h\"\n\n \n\ntypedef struct {\n\tint typ;\n\tsize_t off;\n} _cdef;\n\n#define _CBYTE\t       1\n#define _CWORD\t       2\n#define _CDWORD        3\n#define _CSTRUCT       4\n#define _CMSTRUCT      5\n#define _CEND\t       6\n\nstatic _cdef cdef[] =\n{\n\t \n\t{_CEND},\n\t \n\t{_CEND},\n\t \n\t{_CEND},\n\t \n\t{_CDWORD, offsetof(_cmsg, adr.adrController)},\n\t \n\t{_CMSTRUCT, offsetof(_cmsg, AdditionalInfo)},\n\t \n\t{_CSTRUCT, offsetof(_cmsg, B1configuration)},\n\t \n\t{_CWORD, offsetof(_cmsg, B1protocol)},\n\t \n\t{_CSTRUCT, offsetof(_cmsg, B2configuration)},\n\t \n\t{_CWORD, offsetof(_cmsg, B2protocol)},\n\t \n\t{_CSTRUCT, offsetof(_cmsg, B3configuration)},\n\t \n\t{_CWORD, offsetof(_cmsg, B3protocol)},\n\t \n\t{_CSTRUCT, offsetof(_cmsg, BC)},\n\t \n\t{_CSTRUCT, offsetof(_cmsg, BChannelinformation)},\n\t \n\t{_CMSTRUCT, offsetof(_cmsg, BProtocol)},\n\t \n\t{_CSTRUCT, offsetof(_cmsg, CalledPartyNumber)},\n\t \n\t{_CSTRUCT, offsetof(_cmsg, CalledPartySubaddress)},\n\t \n\t{_CSTRUCT, offsetof(_cmsg, CallingPartyNumber)},\n\t \n\t{_CSTRUCT, offsetof(_cmsg, CallingPartySubaddress)},\n\t \n\t{_CDWORD, offsetof(_cmsg, CIPmask)},\n\t \n\t{_CDWORD, offsetof(_cmsg, CIPmask2)},\n\t \n\t{_CWORD, offsetof(_cmsg, CIPValue)},\n\t \n\t{_CDWORD, offsetof(_cmsg, Class)},\n\t \n\t{_CSTRUCT, offsetof(_cmsg, ConnectedNumber)},\n\t \n\t{_CSTRUCT, offsetof(_cmsg, ConnectedSubaddress)},\n\t \n\t{_CDWORD, offsetof(_cmsg, Data)},\n\t \n\t{_CWORD, offsetof(_cmsg, DataHandle)},\n\t \n\t{_CWORD, offsetof(_cmsg, DataLength)},\n\t \n\t{_CSTRUCT, offsetof(_cmsg, FacilityConfirmationParameter)},\n\t \n\t{_CSTRUCT, offsetof(_cmsg, Facilitydataarray)},\n\t \n\t{_CSTRUCT, offsetof(_cmsg, FacilityIndicationParameter)},\n\t \n\t{_CSTRUCT, offsetof(_cmsg, FacilityRequestParameter)},\n\t \n\t{_CWORD, offsetof(_cmsg, FacilitySelector)},\n\t \n\t{_CWORD, offsetof(_cmsg, Flags)},\n\t \n\t{_CDWORD, offsetof(_cmsg, Function)},\n\t \n\t{_CSTRUCT, offsetof(_cmsg, HLC)},\n\t \n\t{_CWORD, offsetof(_cmsg, Info)},\n\t \n\t{_CSTRUCT, offsetof(_cmsg, InfoElement)},\n\t \n\t{_CDWORD, offsetof(_cmsg, InfoMask)},\n\t \n\t{_CWORD, offsetof(_cmsg, InfoNumber)},\n\t \n\t{_CSTRUCT, offsetof(_cmsg, Keypadfacility)},\n\t \n\t{_CSTRUCT, offsetof(_cmsg, LLC)},\n\t \n\t{_CSTRUCT, offsetof(_cmsg, ManuData)},\n\t \n\t{_CDWORD, offsetof(_cmsg, ManuID)},\n\t \n\t{_CSTRUCT, offsetof(_cmsg, NCPI)},\n\t \n\t{_CWORD, offsetof(_cmsg, Reason)},\n\t \n\t{_CWORD, offsetof(_cmsg, Reason_B3)},\n\t \n\t{_CWORD, offsetof(_cmsg, Reject)},\n\t \n\t{_CSTRUCT, offsetof(_cmsg, Useruserdata)}\n};\n\nstatic unsigned char *cpars[] =\n{\n\t  [0x01] = \"\\x03\\x04\\x0c\\x27\\x2f\\x1c\\x01\\x01\",\n\t  [0x02] = \"\\x03\\x14\\x0e\\x10\\x0f\\x11\\x0d\\x06\\x08\\x0a\\x05\\x07\\x09\\x01\\x0b\\x28\\x22\\x04\\x0c\\x27\\x2f\\x1c\\x01\\x01\",\n\t  [0x04] = \"\\x03\\x04\\x0c\\x27\\x2f\\x1c\\x01\\x01\",\n\t  [0x05] = \"\\x03\\x25\\x12\\x13\\x10\\x11\\x01\",\n\t  [0x08] = \"\\x03\\x0e\\x04\\x0c\\x27\\x2f\\x1c\\x01\\x01\",\n\t  [0x09] = \"\\x03\\x1f\\x1e\\x01\",\n\t  [0x0a] = \"\\x03\\x0d\\x06\\x08\\x0a\\x05\\x07\\x09\\x01\\x01\",\n\t  [0x0b] = \"\\x03\\x2b\\x01\",\n\t  [0x0d] = \"\\x03\\x2b\\x01\",\n\t  [0x0f] = \"\\x03\\x18\\x1a\\x19\\x20\\x01\",\n\t  [0x10] = \"\\x03\\x2b\\x01\",\n\t  [0x13] = \"\\x03\\x23\\x01\",\n\t  [0x14] = \"\\x03\\x23\\x01\",\n\t  [0x16] = \"\\x03\\x23\\x01\",\n\t  [0x17] = \"\\x03\\x23\\x01\",\n\t  [0x18] = \"\\x03\\x2a\\x15\\x21\\x29\\x01\",\n\t  [0x1a] = \"\\x03\\x23\\x01\",\n\t  [0x1b] = \"\\x03\\x23\\x1f\\x1b\\x01\",\n\t  [0x1c] = \"\\x03\\x23\\x01\",\n\t  [0x1d] = \"\\x03\\x23\\x01\",\n\t  [0x1f] = \"\\x03\\x23\\x01\",\n\t  [0x21] = \"\\x03\\x19\\x23\\x01\",\n\t  [0x22] = \"\\x03\\x23\\x01\",\n\t  [0x26] = \"\\x03\\x14\\x0e\\x10\\x0f\\x11\\x0b\\x28\\x22\\x04\\x0c\\x27\\x2f\\x1c\\x01\\x01\",\n\t  [0x27] = \"\\x03\\x16\\x17\\x28\\x01\",\n\t  [0x28] = \"\\x03\\x2c\\x01\",\n\t  [0x2a] = \"\\x03\\x2a\\x15\\x21\\x29\\x01\",\n\t  [0x2c] = \"\\x03\\x26\\x24\\x01\",\n\t  [0x2d] = \"\\x03\\x1f\\x1d\\x01\",\n\t  [0x2f] = \"\\x03\\x2b\\x01\",\n\t  [0x30] = \"\\x03\\x2b\\x01\",\n\t  [0x31] = \"\\x03\\x2d\\x2b\\x01\",\n\t  [0x33] = \"\\x03\\x18\\x1a\\x19\\x20\\x01\",\n\t  [0x34] = \"\\x03\\x2b\\x01\",\n\t  [0x35] = \"\\x03\\x2b\\x01\",\n\t  [0x38] = \"\\x03\\x2e\\x0d\\x06\\x08\\x0a\\x05\\x07\\x09\\x01\\x16\\x17\\x28\\x04\\x0c\\x27\\x2f\\x1c\\x01\\x01\",\n\t  [0x39] = \"\\x03\\x01\",\n\t  [0x3a] = \"\\x03\\x01\",\n\t  [0x3c] = \"\\x03\\x2a\\x15\\x21\\x29\\x01\",\n\t  [0x3e] = \"\\x03\\x01\",\n\t  [0x3f] = \"\\x03\\x1f\\x01\",\n\t  [0x41] = \"\\x03\\x2e\\x2b\\x01\",\n\t  [0x42] = \"\\x03\\x01\",\n\t  [0x43] = \"\\x03\\x01\",\n\t  [0x45] = \"\\x03\\x19\\x01\",\n\t  [0x46] = \"\\x03\\x01\",\n\t  [0x47] = \"\\x03\\x01\",\n\t  [0x4e] = \"\\x03\\x2a\\x15\\x21\\x29\\x01\",\n};\n\n \n\n#define byteTLcpy(x, y)         *(u8 *)(x) = *(u8 *)(y);\n#define wordTLcpy(x, y)         *(u16 *)(x) = *(u16 *)(y);\n#define dwordTLcpy(x, y)        memcpy(x, y, 4);\n#define structTLcpy(x, y, l)    memcpy(x, y, l)\n#define structTLcpyovl(x, y, l) memmove(x, y, l)\n\n#define byteTRcpy(x, y)         *(u8 *)(y) = *(u8 *)(x);\n#define wordTRcpy(x, y)         *(u16 *)(y) = *(u16 *)(x);\n#define dwordTRcpy(x, y)        memcpy(y, x, 4);\n#define structTRcpy(x, y, l)    memcpy(y, x, l)\n#define structTRcpyovl(x, y, l) memmove(y, x, l)\n\n \nstatic unsigned command_2_index(u8 c, u8 sc)\n{\n\tif (c & 0x80)\n\t\tc = 0x9 + (c & 0x0f);\n\telse if (c == 0x41)\n\t\tc = 0x9 + 0x1;\n\tif (c > 0x18)\n\t\tc = 0x00;\n\treturn (sc & 3) * (0x9 + 0x9) + c;\n}\n\n \n\nstatic unsigned char *capi_cmd2par(u8 cmd, u8 subcmd)\n{\n\treturn cpars[command_2_index(cmd, subcmd)];\n}\n\n \n#define TYP (cdef[cmsg->par[cmsg->p]].typ)\n#define OFF (((u8 *)cmsg) + cdef[cmsg->par[cmsg->p]].off)\n\nstatic void jumpcstruct(_cmsg *cmsg)\n{\n\tunsigned layer;\n\tfor (cmsg->p++, layer = 1; layer;) {\n\t\t \n\t\tcmsg->p++;\n\t\tswitch (TYP) {\n\t\tcase _CMSTRUCT:\n\t\t\tlayer++;\n\t\t\tbreak;\n\t\tcase _CEND:\n\t\t\tlayer--;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n \n\nstatic char *mnames[] =\n{\n\t[0x01] = \"ALERT_REQ\",\n\t[0x02] = \"CONNECT_REQ\",\n\t[0x04] = \"DISCONNECT_REQ\",\n\t[0x05] = \"LISTEN_REQ\",\n\t[0x08] = \"INFO_REQ\",\n\t[0x09] = \"FACILITY_REQ\",\n\t[0x0a] = \"SELECT_B_PROTOCOL_REQ\",\n\t[0x0b] = \"CONNECT_B3_REQ\",\n\t[0x0d] = \"DISCONNECT_B3_REQ\",\n\t[0x0f] = \"DATA_B3_REQ\",\n\t[0x10] = \"RESET_B3_REQ\",\n\t[0x13] = \"ALERT_CONF\",\n\t[0x14] = \"CONNECT_CONF\",\n\t[0x16] = \"DISCONNECT_CONF\",\n\t[0x17] = \"LISTEN_CONF\",\n\t[0x18] = \"MANUFACTURER_REQ\",\n\t[0x1a] = \"INFO_CONF\",\n\t[0x1b] = \"FACILITY_CONF\",\n\t[0x1c] = \"SELECT_B_PROTOCOL_CONF\",\n\t[0x1d] = \"CONNECT_B3_CONF\",\n\t[0x1f] = \"DISCONNECT_B3_CONF\",\n\t[0x21] = \"DATA_B3_CONF\",\n\t[0x22] = \"RESET_B3_CONF\",\n\t[0x26] = \"CONNECT_IND\",\n\t[0x27] = \"CONNECT_ACTIVE_IND\",\n\t[0x28] = \"DISCONNECT_IND\",\n\t[0x2a] = \"MANUFACTURER_CONF\",\n\t[0x2c] = \"INFO_IND\",\n\t[0x2d] = \"FACILITY_IND\",\n\t[0x2f] = \"CONNECT_B3_IND\",\n\t[0x30] = \"CONNECT_B3_ACTIVE_IND\",\n\t[0x31] = \"DISCONNECT_B3_IND\",\n\t[0x33] = \"DATA_B3_IND\",\n\t[0x34] = \"RESET_B3_IND\",\n\t[0x35] = \"CONNECT_B3_T90_ACTIVE_IND\",\n\t[0x38] = \"CONNECT_RESP\",\n\t[0x39] = \"CONNECT_ACTIVE_RESP\",\n\t[0x3a] = \"DISCONNECT_RESP\",\n\t[0x3c] = \"MANUFACTURER_IND\",\n\t[0x3e] = \"INFO_RESP\",\n\t[0x3f] = \"FACILITY_RESP\",\n\t[0x41] = \"CONNECT_B3_RESP\",\n\t[0x42] = \"CONNECT_B3_ACTIVE_RESP\",\n\t[0x43] = \"DISCONNECT_B3_RESP\",\n\t[0x45] = \"DATA_B3_RESP\",\n\t[0x46] = \"RESET_B3_RESP\",\n\t[0x47] = \"CONNECT_B3_T90_ACTIVE_RESP\",\n\t[0x4e] = \"MANUFACTURER_RESP\"\n};\n\n \n\nchar *capi_cmd2str(u8 cmd, u8 subcmd)\n{\n\tchar *result;\n\n\tresult = mnames[command_2_index(cmd, subcmd)];\n\tif (result == NULL)\n\t\tresult = \"INVALID_COMMAND\";\n\treturn result;\n}\n\n\n \n\n#ifdef CONFIG_CAPI_TRACE\n\n \n\nstatic char *pnames[] =\n{\n\t  NULL,\n\t  NULL,\n\t  NULL,\n\t  \"Controller/PLCI/NCCI\",\n\t  \"AdditionalInfo\",\n\t  \"B1configuration\",\n\t  \"B1protocol\",\n\t  \"B2configuration\",\n\t  \"B2protocol\",\n\t  \"B3configuration\",\n\t  \"B3protocol\",\n\t  \"BC\",\n\t  \"BChannelinformation\",\n\t  \"BProtocol\",\n\t  \"CalledPartyNumber\",\n\t  \"CalledPartySubaddress\",\n\t  \"CallingPartyNumber\",\n\t  \"CallingPartySubaddress\",\n\t  \"CIPmask\",\n\t  \"CIPmask2\",\n\t  \"CIPValue\",\n\t  \"Class\",\n\t  \"ConnectedNumber\",\n\t  \"ConnectedSubaddress\",\n\t  \"Data32\",\n\t  \"DataHandle\",\n\t  \"DataLength\",\n\t  \"FacilityConfirmationParameter\",\n\t  \"Facilitydataarray\",\n\t  \"FacilityIndicationParameter\",\n\t  \"FacilityRequestParameter\",\n\t  \"FacilitySelector\",\n\t  \"Flags\",\n\t  \"Function\",\n\t  \"HLC\",\n\t  \"Info\",\n\t  \"InfoElement\",\n\t  \"InfoMask\",\n\t  \"InfoNumber\",\n\t  \"Keypadfacility\",\n\t  \"LLC\",\n\t  \"ManuData\",\n\t  \"ManuID\",\n\t  \"NCPI\",\n\t  \"Reason\",\n\t  \"Reason_B3\",\n\t  \"Reject\",\n\t  \"Useruserdata\"\n};\n\n#include <linux/stdarg.h>\n\n \nstatic _cdebbuf *bufprint(_cdebbuf *cdb, char *fmt, ...)\n{\n\tva_list f;\n\tsize_t n, r;\n\n\tif (!cdb)\n\t\treturn NULL;\n\tva_start(f, fmt);\n\tr = cdb->size - cdb->pos;\n\tn = vsnprintf(cdb->p, r, fmt, f);\n\tva_end(f);\n\tif (n >= r) {\n\t\t \n\t\tsize_t ns = 2 * cdb->size;\n\t\tu_char *nb;\n\n\t\twhile ((ns - cdb->pos) <= n)\n\t\t\tns *= 2;\n\t\tnb = kmalloc(ns, GFP_ATOMIC);\n\t\tif (!nb) {\n\t\t\tcdebbuf_free(cdb);\n\t\t\treturn NULL;\n\t\t}\n\t\tmemcpy(nb, cdb->buf, cdb->pos);\n\t\tkfree(cdb->buf);\n\t\tnb[cdb->pos] = 0;\n\t\tcdb->buf = nb;\n\t\tcdb->p = cdb->buf + cdb->pos;\n\t\tcdb->size = ns;\n\t\tva_start(f, fmt);\n\t\tr = cdb->size - cdb->pos;\n\t\tn = vsnprintf(cdb->p, r, fmt, f);\n\t\tva_end(f);\n\t}\n\tcdb->p += n;\n\tcdb->pos += n;\n\treturn cdb;\n}\n\nstatic _cdebbuf *printstructlen(_cdebbuf *cdb, u8 *m, unsigned len)\n{\n\tunsigned hex = 0;\n\n\tif (!cdb)\n\t\treturn NULL;\n\tfor (; len; len--, m++)\n\t\tif (isalnum(*m) || *m == ' ') {\n\t\t\tif (hex)\n\t\t\t\tcdb = bufprint(cdb, \">\");\n\t\t\tcdb = bufprint(cdb, \"%c\", *m);\n\t\t\thex = 0;\n\t\t} else {\n\t\t\tif (!hex)\n\t\t\t\tcdb = bufprint(cdb, \"<%02x\", *m);\n\t\t\telse\n\t\t\t\tcdb = bufprint(cdb, \" %02x\", *m);\n\t\t\thex = 1;\n\t\t}\n\tif (hex)\n\t\tcdb = bufprint(cdb, \">\");\n\treturn cdb;\n}\n\nstatic _cdebbuf *printstruct(_cdebbuf *cdb, u8 *m)\n{\n\tunsigned len;\n\n\tif (m[0] != 0xff) {\n\t\tlen = m[0];\n\t\tm += 1;\n\t} else {\n\t\tlen = ((u16 *) (m + 1))[0];\n\t\tm += 3;\n\t}\n\tcdb = printstructlen(cdb, m, len);\n\treturn cdb;\n}\n\n \n#define NAME (pnames[cmsg->par[cmsg->p]])\n\nstatic _cdebbuf *protocol_message_2_pars(_cdebbuf *cdb, _cmsg *cmsg, int level)\n{\n\tif (!cmsg->par)\n\t\treturn NULL;\t \n\n\tfor (; TYP != _CEND; cmsg->p++) {\n\t\tint slen = 29 + 3 - level;\n\t\tint i;\n\n\t\tif (!cdb)\n\t\t\treturn NULL;\n\t\tcdb = bufprint(cdb, \"  \");\n\t\tfor (i = 0; i < level - 1; i++)\n\t\t\tcdb = bufprint(cdb, \" \");\n\n\t\tswitch (TYP) {\n\t\tcase _CBYTE:\n\t\t\tcdb = bufprint(cdb, \"%-*s = 0x%x\\n\", slen, NAME, *(u8 *) (cmsg->m + cmsg->l));\n\t\t\tcmsg->l++;\n\t\t\tbreak;\n\t\tcase _CWORD:\n\t\t\tcdb = bufprint(cdb, \"%-*s = 0x%x\\n\", slen, NAME, *(u16 *) (cmsg->m + cmsg->l));\n\t\t\tcmsg->l += 2;\n\t\t\tbreak;\n\t\tcase _CDWORD:\n\t\t\tcdb = bufprint(cdb, \"%-*s = 0x%lx\\n\", slen, NAME, *(u32 *) (cmsg->m + cmsg->l));\n\t\t\tcmsg->l += 4;\n\t\t\tbreak;\n\t\tcase _CSTRUCT:\n\t\t\tcdb = bufprint(cdb, \"%-*s = \", slen, NAME);\n\t\t\tif (cmsg->m[cmsg->l] == '\\0')\n\t\t\t\tcdb = bufprint(cdb, \"default\");\n\t\t\telse\n\t\t\t\tcdb = printstruct(cdb, cmsg->m + cmsg->l);\n\t\t\tcdb = bufprint(cdb, \"\\n\");\n\t\t\tif (cmsg->m[cmsg->l] != 0xff)\n\t\t\t\tcmsg->l += 1 + cmsg->m[cmsg->l];\n\t\t\telse\n\t\t\t\tcmsg->l += 3 + *(u16 *) (cmsg->m + cmsg->l + 1);\n\n\t\t\tbreak;\n\n\t\tcase _CMSTRUCT:\n \n\t\t\tif (cmsg->m[cmsg->l] == '\\0') {\n\t\t\t\tcdb = bufprint(cdb, \"%-*s = default\\n\", slen, NAME);\n\t\t\t\tcmsg->l++;\n\t\t\t\tjumpcstruct(cmsg);\n\t\t\t} else {\n\t\t\t\tchar *name = NAME;\n\t\t\t\tunsigned _l = cmsg->l;\n\t\t\t\tcdb = bufprint(cdb, \"%-*s\\n\", slen, name);\n\t\t\t\tcmsg->l = (cmsg->m + _l)[0] == 255 ? cmsg->l + 3 : cmsg->l + 1;\n\t\t\t\tcmsg->p++;\n\t\t\t\tcdb = protocol_message_2_pars(cdb, cmsg, level + 1);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn cdb;\n}\n \n\nstatic _cdebbuf *g_debbuf;\nstatic u_long g_debbuf_lock;\nstatic _cmsg *g_cmsg;\n\nstatic _cdebbuf *cdebbuf_alloc(void)\n{\n\t_cdebbuf *cdb;\n\n\tif (likely(!test_and_set_bit(1, &g_debbuf_lock))) {\n\t\tcdb = g_debbuf;\n\t\tgoto init;\n\t} else\n\t\tcdb = kmalloc(sizeof(_cdebbuf), GFP_ATOMIC);\n\tif (!cdb)\n\t\treturn NULL;\n\tcdb->buf = kmalloc(CDEBUG_SIZE, GFP_ATOMIC);\n\tif (!cdb->buf) {\n\t\tkfree(cdb);\n\t\treturn NULL;\n\t}\n\tcdb->size = CDEBUG_SIZE;\ninit:\n\tcdb->buf[0] = 0;\n\tcdb->p = cdb->buf;\n\tcdb->pos = 0;\n\treturn cdb;\n}\n\n \n\nvoid cdebbuf_free(_cdebbuf *cdb)\n{\n\tif (likely(cdb == g_debbuf)) {\n\t\ttest_and_clear_bit(1, &g_debbuf_lock);\n\t\treturn;\n\t}\n\tif (likely(cdb))\n\t\tkfree(cdb->buf);\n\tkfree(cdb);\n}\n\n\n \n\n_cdebbuf *capi_message2str(u8 *msg)\n{\n\t_cdebbuf *cdb;\n\t_cmsg\t*cmsg;\n\n\tcdb = cdebbuf_alloc();\n\tif (unlikely(!cdb))\n\t\treturn NULL;\n\tif (likely(cdb == g_debbuf))\n\t\tcmsg = g_cmsg;\n\telse\n\t\tcmsg = kmalloc(sizeof(_cmsg), GFP_ATOMIC);\n\tif (unlikely(!cmsg)) {\n\t\tcdebbuf_free(cdb);\n\t\treturn NULL;\n\t}\n\tcmsg->m = msg;\n\tcmsg->l = 8;\n\tcmsg->p = 0;\n\tbyteTRcpy(cmsg->m + 4, &cmsg->Command);\n\tbyteTRcpy(cmsg->m + 5, &cmsg->Subcommand);\n\tcmsg->par = capi_cmd2par(cmsg->Command, cmsg->Subcommand);\n\n\tcdb = bufprint(cdb, \"%-26s ID=%03d #0x%04x LEN=%04d\\n\",\n\t\t       capi_cmd2str(cmsg->Command, cmsg->Subcommand),\n\t\t       ((unsigned short *) msg)[1],\n\t\t       ((unsigned short *) msg)[3],\n\t\t       ((unsigned short *) msg)[0]);\n\n\tcdb = protocol_message_2_pars(cdb, cmsg, 1);\n\tif (unlikely(cmsg != g_cmsg))\n\t\tkfree(cmsg);\n\treturn cdb;\n}\n\nint __init cdebug_init(void)\n{\n\tg_cmsg = kmalloc(sizeof(_cmsg), GFP_KERNEL);\n\tif (!g_cmsg)\n\t\treturn -ENOMEM;\n\tg_debbuf = kmalloc(sizeof(_cdebbuf), GFP_KERNEL);\n\tif (!g_debbuf) {\n\t\tkfree(g_cmsg);\n\t\treturn -ENOMEM;\n\t}\n\tg_debbuf->buf = kmalloc(CDEBUG_GSIZE, GFP_KERNEL);\n\tif (!g_debbuf->buf) {\n\t\tkfree(g_cmsg);\n\t\tkfree(g_debbuf);\n\t\treturn -ENOMEM;\n\t}\n\tg_debbuf->size = CDEBUG_GSIZE;\n\tg_debbuf->buf[0] = 0;\n\tg_debbuf->p = g_debbuf->buf;\n\tg_debbuf->pos = 0;\n\treturn 0;\n}\n\nvoid cdebug_exit(void)\n{\n\tif (g_debbuf)\n\t\tkfree(g_debbuf->buf);\n\tkfree(g_debbuf);\n\tkfree(g_cmsg);\n}\n\n#else  \n\nstatic _cdebbuf g_debbuf = {\"CONFIG_CAPI_TRACE not enabled\", NULL, 0, 0};\n\n_cdebbuf *capi_message2str(u8 *msg)\n{\n\treturn &g_debbuf;\n}\n\n_cdebbuf *capi_cmsg2str(_cmsg *cmsg)\n{\n\treturn &g_debbuf;\n}\n\nvoid cdebbuf_free(_cdebbuf *cdb)\n{\n}\n\nint __init cdebug_init(void)\n{\n\treturn 0;\n}\n\nvoid cdebug_exit(void)\n{\n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}