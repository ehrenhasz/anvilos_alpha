{
  "module_name": "rio-scan.c",
  "hash_id": "3f9834d0bb77c734852ebb6de1b6869cc9f5b23c693bfc4005e25819ea777d50",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rapidio/rio-scan.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/kernel.h>\n\n#include <linux/delay.h>\n#include <linux/dma-mapping.h>\n#include <linux/init.h>\n#include <linux/rio.h>\n#include <linux/rio_drv.h>\n#include <linux/rio_ids.h>\n#include <linux/rio_regs.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/timer.h>\n#include <linux/sched.h>\n#include <linux/jiffies.h>\n#include <linux/slab.h>\n\n#include \"rio.h\"\n\nstatic void rio_init_em(struct rio_dev *rdev);\n\nstruct rio_id_table {\n\tu16 start;\t \n\tu32 max;\t \n\tspinlock_t lock;\n\tunsigned long table[];\n};\n\nstatic int next_destid = 0;\nstatic int next_comptag = 1;\n\n \nstatic u16 rio_destid_alloc(struct rio_net *net)\n{\n\tint destid;\n\tstruct rio_id_table *idtab = (struct rio_id_table *)net->enum_data;\n\n\tspin_lock(&idtab->lock);\n\tdestid = find_first_zero_bit(idtab->table, idtab->max);\n\n\tif (destid < idtab->max) {\n\t\tset_bit(destid, idtab->table);\n\t\tdestid += idtab->start;\n\t} else\n\t\tdestid = RIO_INVALID_DESTID;\n\n\tspin_unlock(&idtab->lock);\n\treturn (u16)destid;\n}\n\n \nstatic int rio_destid_reserve(struct rio_net *net, u16 destid)\n{\n\tint oldbit;\n\tstruct rio_id_table *idtab = (struct rio_id_table *)net->enum_data;\n\n\tdestid -= idtab->start;\n\tspin_lock(&idtab->lock);\n\toldbit = test_and_set_bit(destid, idtab->table);\n\tspin_unlock(&idtab->lock);\n\treturn oldbit;\n}\n\n \nstatic void rio_destid_free(struct rio_net *net, u16 destid)\n{\n\tstruct rio_id_table *idtab = (struct rio_id_table *)net->enum_data;\n\n\tdestid -= idtab->start;\n\tspin_lock(&idtab->lock);\n\tclear_bit(destid, idtab->table);\n\tspin_unlock(&idtab->lock);\n}\n\n \nstatic u16 rio_destid_first(struct rio_net *net)\n{\n\tint destid;\n\tstruct rio_id_table *idtab = (struct rio_id_table *)net->enum_data;\n\n\tspin_lock(&idtab->lock);\n\tdestid = find_first_bit(idtab->table, idtab->max);\n\tif (destid >= idtab->max)\n\t\tdestid = RIO_INVALID_DESTID;\n\telse\n\t\tdestid += idtab->start;\n\tspin_unlock(&idtab->lock);\n\treturn (u16)destid;\n}\n\n \nstatic u16 rio_destid_next(struct rio_net *net, u16 from)\n{\n\tint destid;\n\tstruct rio_id_table *idtab = (struct rio_id_table *)net->enum_data;\n\n\tspin_lock(&idtab->lock);\n\tdestid = find_next_bit(idtab->table, idtab->max, from);\n\tif (destid >= idtab->max)\n\t\tdestid = RIO_INVALID_DESTID;\n\telse\n\t\tdestid += idtab->start;\n\tspin_unlock(&idtab->lock);\n\treturn (u16)destid;\n}\n\n \nstatic u16 rio_get_device_id(struct rio_mport *port, u16 destid, u8 hopcount)\n{\n\tu32 result;\n\n\trio_mport_read_config_32(port, destid, hopcount, RIO_DID_CSR, &result);\n\n\treturn RIO_GET_DID(port->sys_size, result);\n}\n\n \nstatic void rio_set_device_id(struct rio_mport *port, u16 destid, u8 hopcount, u16 did)\n{\n\trio_mport_write_config_32(port, destid, hopcount, RIO_DID_CSR,\n\t\t\t\t  RIO_SET_DID(port->sys_size, did));\n}\n\n \nstatic int rio_clear_locks(struct rio_net *net)\n{\n\tstruct rio_mport *port = net->hport;\n\tstruct rio_dev *rdev;\n\tu32 result;\n\tint ret = 0;\n\n\t \n\trio_local_write_config_32(port, RIO_HOST_DID_LOCK_CSR,\n\t\t\t\t  port->host_deviceid);\n\trio_local_read_config_32(port, RIO_HOST_DID_LOCK_CSR, &result);\n\tif ((result & 0xffff) != 0xffff) {\n\t\tprintk(KERN_INFO\n\t\t       \"RIO: badness when releasing host lock on master port, result %8.8x\\n\",\n\t\t       result);\n\t\tret = -EINVAL;\n\t}\n\tlist_for_each_entry(rdev, &net->devices, net_list) {\n\t\trio_write_config_32(rdev, RIO_HOST_DID_LOCK_CSR,\n\t\t\t\t    port->host_deviceid);\n\t\trio_read_config_32(rdev, RIO_HOST_DID_LOCK_CSR, &result);\n\t\tif ((result & 0xffff) != 0xffff) {\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"RIO: badness when releasing host lock on vid %4.4x did %4.4x\\n\",\n\t\t\t       rdev->vid, rdev->did);\n\t\t\tret = -EINVAL;\n\t\t}\n\n\t\t \n\t\trio_read_config_32(rdev,\n\t\t\t\t   rdev->phys_efptr + RIO_PORT_GEN_CTL_CSR,\n\t\t\t\t   &result);\n\t\tresult |= RIO_PORT_GEN_DISCOVERED | RIO_PORT_GEN_MASTER;\n\t\trio_write_config_32(rdev,\n\t\t\t\t    rdev->phys_efptr + RIO_PORT_GEN_CTL_CSR,\n\t\t\t\t    result);\n\t}\n\n\treturn ret;\n}\n\n \nstatic int rio_enum_host(struct rio_mport *port)\n{\n\tu32 result;\n\n\t \n\trio_local_write_config_32(port, RIO_HOST_DID_LOCK_CSR,\n\t\t\t\t  port->host_deviceid);\n\n\trio_local_read_config_32(port, RIO_HOST_DID_LOCK_CSR, &result);\n\tif ((result & 0xffff) != port->host_deviceid)\n\t\treturn -1;\n\n\t \n\trio_local_set_device_id(port, port->host_deviceid);\n\treturn 0;\n}\n\n \nstatic int rio_device_has_destid(struct rio_mport *port, int src_ops,\n\t\t\t\t int dst_ops)\n{\n\tu32 mask = RIO_OPS_READ | RIO_OPS_WRITE | RIO_OPS_ATOMIC_TST_SWP | RIO_OPS_ATOMIC_INC | RIO_OPS_ATOMIC_DEC | RIO_OPS_ATOMIC_SET | RIO_OPS_ATOMIC_CLR;\n\n\treturn !!((src_ops | dst_ops) & mask);\n}\n\n \nstatic void rio_release_dev(struct device *dev)\n{\n\tstruct rio_dev *rdev;\n\n\trdev = to_rio_dev(dev);\n\tkfree(rdev);\n}\n\n \nstatic int rio_is_switch(struct rio_dev *rdev)\n{\n\tif (rdev->pef & RIO_PEF_SWITCH)\n\t\treturn 1;\n\treturn 0;\n}\n\n \nstatic struct rio_dev *rio_setup_device(struct rio_net *net,\n\t\t\t\t\tstruct rio_mport *port, u16 destid,\n\t\t\t\t\tu8 hopcount, int do_enum)\n{\n\tint ret = 0;\n\tstruct rio_dev *rdev;\n\tstruct rio_switch *rswitch = NULL;\n\tint result, rdid;\n\tsize_t size;\n\tu32 swpinfo = 0;\n\n\tsize = sizeof(*rdev);\n\tif (rio_mport_read_config_32(port, destid, hopcount,\n\t\t\t\t     RIO_PEF_CAR, &result))\n\t\treturn NULL;\n\n\tif (result & (RIO_PEF_SWITCH | RIO_PEF_MULTIPORT)) {\n\t\trio_mport_read_config_32(port, destid, hopcount,\n\t\t\t\t\t RIO_SWP_INFO_CAR, &swpinfo);\n\t\tif (result & RIO_PEF_SWITCH)\n\t\t\tsize += struct_size(rswitch, nextdev, RIO_GET_TOTAL_PORTS(swpinfo));\n\t}\n\n\trdev = kzalloc(size, GFP_KERNEL);\n\tif (!rdev)\n\t\treturn NULL;\n\n\trdev->net = net;\n\trdev->pef = result;\n\trdev->swpinfo = swpinfo;\n\trio_mport_read_config_32(port, destid, hopcount, RIO_DEV_ID_CAR,\n\t\t\t\t &result);\n\trdev->did = result >> 16;\n\trdev->vid = result & 0xffff;\n\trio_mport_read_config_32(port, destid, hopcount, RIO_DEV_INFO_CAR,\n\t\t\t\t &rdev->device_rev);\n\trio_mport_read_config_32(port, destid, hopcount, RIO_ASM_ID_CAR,\n\t\t\t\t &result);\n\trdev->asm_did = result >> 16;\n\trdev->asm_vid = result & 0xffff;\n\trio_mport_read_config_32(port, destid, hopcount, RIO_ASM_INFO_CAR,\n\t\t\t\t &result);\n\trdev->asm_rev = result >> 16;\n\tif (rdev->pef & RIO_PEF_EXT_FEATURES) {\n\t\trdev->efptr = result & 0xffff;\n\t\trdev->phys_efptr = rio_mport_get_physefb(port, 0, destid,\n\t\t\t\t\t\thopcount, &rdev->phys_rmap);\n\t\tpr_debug(\"RIO: %s Register Map %d device\\n\",\n\t\t\t __func__, rdev->phys_rmap);\n\n\t\trdev->em_efptr = rio_mport_get_feature(port, 0, destid,\n\t\t\t\t\t\thopcount, RIO_EFB_ERR_MGMNT);\n\t\tif (!rdev->em_efptr)\n\t\t\trdev->em_efptr = rio_mport_get_feature(port, 0, destid,\n\t\t\t\t\t\thopcount, RIO_EFB_ERR_MGMNT_HS);\n\t}\n\n\trio_mport_read_config_32(port, destid, hopcount, RIO_SRC_OPS_CAR,\n\t\t\t\t &rdev->src_ops);\n\trio_mport_read_config_32(port, destid, hopcount, RIO_DST_OPS_CAR,\n\t\t\t\t &rdev->dst_ops);\n\n\tif (do_enum) {\n\t\t \n\t\tif (next_comptag >= 0x10000) {\n\t\t\tpr_err(\"RIO: Component Tag Counter Overflow\\n\");\n\t\t\tgoto cleanup;\n\t\t}\n\t\trio_mport_write_config_32(port, destid, hopcount,\n\t\t\t\t\t  RIO_COMPONENT_TAG_CSR, next_comptag);\n\t\trdev->comp_tag = next_comptag++;\n\t\trdev->do_enum = true;\n\t}  else {\n\t\trio_mport_read_config_32(port, destid, hopcount,\n\t\t\t\t\t RIO_COMPONENT_TAG_CSR,\n\t\t\t\t\t &rdev->comp_tag);\n\t}\n\n\tif (rio_device_has_destid(port, rdev->src_ops, rdev->dst_ops)) {\n\t\tif (do_enum) {\n\t\t\trio_set_device_id(port, destid, hopcount, next_destid);\n\t\t\trdev->destid = next_destid;\n\t\t\tnext_destid = rio_destid_alloc(net);\n\t\t} else\n\t\t\trdev->destid = rio_get_device_id(port, destid, hopcount);\n\n\t\trdev->hopcount = 0xff;\n\t} else {\n\t\t \n\t\trdev->destid = destid;\n\t\trdev->hopcount = hopcount;\n\t}\n\n\t \n\tif (rio_is_switch(rdev)) {\n\t\trswitch = rdev->rswitch;\n\t\trswitch->port_ok = 0;\n\t\tspin_lock_init(&rswitch->lock);\n\t\trswitch->route_table =\n\t\t\tkzalloc(RIO_MAX_ROUTE_ENTRIES(port->sys_size),\n\t\t\t\tGFP_KERNEL);\n\t\tif (!rswitch->route_table)\n\t\t\tgoto cleanup;\n\t\t \n\t\tfor (rdid = 0; rdid < RIO_MAX_ROUTE_ENTRIES(port->sys_size);\n\t\t\t\trdid++)\n\t\t\trswitch->route_table[rdid] = RIO_INVALID_ROUTE;\n\t\tdev_set_name(&rdev->dev, \"%02x:s:%04x\", rdev->net->id,\n\t\t\t     rdev->comp_tag & RIO_CTAG_UDEVID);\n\n\t\tif (do_enum)\n\t\t\trio_route_clr_table(rdev, RIO_GLOBAL_TABLE, 0);\n\t} else {\n\t\tif (do_enum)\n\t\t\t \n\t\t\trio_enable_rx_tx_port(port, 0, destid, hopcount, 0);\n\n\t\tdev_set_name(&rdev->dev, \"%02x:e:%04x\", rdev->net->id,\n\t\t\t     rdev->comp_tag & RIO_CTAG_UDEVID);\n\t}\n\n\trdev->dev.parent = &net->dev;\n\trio_attach_device(rdev);\n\trdev->dev.release = rio_release_dev;\n\trdev->dma_mask = DMA_BIT_MASK(32);\n\trdev->dev.dma_mask = &rdev->dma_mask;\n\trdev->dev.coherent_dma_mask = DMA_BIT_MASK(32);\n\n\tif (rdev->dst_ops & RIO_DST_OPS_DOORBELL)\n\t\trio_init_dbell_res(&rdev->riores[RIO_DOORBELL_RESOURCE],\n\t\t\t\t   0, 0xffff);\n\n\tret = rio_add_device(rdev);\n\tif (ret) {\n\t\tif (rswitch)\n\t\t\tkfree(rswitch->route_table);\n\t\tput_device(&rdev->dev);\n\t\treturn NULL;\n\t}\n\n\trio_dev_get(rdev);\n\n\treturn rdev;\n\ncleanup:\n\tif (rswitch)\n\t\tkfree(rswitch->route_table);\n\n\tkfree(rdev);\n\treturn NULL;\n}\n\n \nstatic int\nrio_sport_is_active(struct rio_dev *rdev, int sp)\n{\n\tu32 result = 0;\n\n\trio_read_config_32(rdev, RIO_DEV_PORT_N_ERR_STS_CSR(rdev, sp),\n\t\t\t   &result);\n\n\treturn result & RIO_PORT_N_ERR_STS_PORT_OK;\n}\n\n \nstatic u16 rio_get_host_deviceid_lock(struct rio_mport *port, u8 hopcount)\n{\n\tu32 result;\n\n\trio_mport_read_config_32(port, RIO_ANY_DESTID(port->sys_size), hopcount,\n\t\t\t\t RIO_HOST_DID_LOCK_CSR, &result);\n\n\treturn (u16) (result & 0xffff);\n}\n\n \nstatic int rio_enum_peer(struct rio_net *net, struct rio_mport *port,\n\t\t\t u8 hopcount, struct rio_dev *prev, int prev_port)\n{\n\tstruct rio_dev *rdev;\n\tu32 regval;\n\tint tmp;\n\n\tif (rio_mport_chk_dev_access(port,\n\t\t\tRIO_ANY_DESTID(port->sys_size), hopcount)) {\n\t\tpr_debug(\"RIO: device access check failed\\n\");\n\t\treturn -1;\n\t}\n\n\tif (rio_get_host_deviceid_lock(port, hopcount) == port->host_deviceid) {\n\t\tpr_debug(\"RIO: PE already discovered by this host\\n\");\n\t\t \n\t\trio_mport_read_config_32(port, RIO_ANY_DESTID(port->sys_size),\n\t\t\t\thopcount, RIO_COMPONENT_TAG_CSR, &regval);\n\n\t\tif (regval) {\n\t\t\trdev = rio_get_comptag((regval & 0xffff), NULL);\n\n\t\t\tif (rdev && prev && rio_is_switch(prev)) {\n\t\t\t\tpr_debug(\"RIO: redundant path to %s\\n\",\n\t\t\t\t\t rio_name(rdev));\n\t\t\t\tprev->rswitch->nextdev[prev_port] = rdev;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\t \n\trio_mport_write_config_32(port, RIO_ANY_DESTID(port->sys_size),\n\t\t\t\t  hopcount,\n\t\t\t\t  RIO_HOST_DID_LOCK_CSR, port->host_deviceid);\n\twhile ((tmp = rio_get_host_deviceid_lock(port, hopcount))\n\t       < port->host_deviceid) {\n\t\t \n\t\tmdelay(1);\n\t\t \n\t\trio_mport_write_config_32(port, RIO_ANY_DESTID(port->sys_size),\n\t\t\t\t\t  hopcount,\n\t\t\t\t\t  RIO_HOST_DID_LOCK_CSR,\n\t\t\t\t\t  port->host_deviceid);\n\t}\n\n\tif (rio_get_host_deviceid_lock(port, hopcount) > port->host_deviceid) {\n\t\tpr_debug(\n\t\t    \"RIO: PE locked by a higher priority host...retreating\\n\");\n\t\treturn -1;\n\t}\n\n\t \n\trdev = rio_setup_device(net, port, RIO_ANY_DESTID(port->sys_size),\n\t\t\t\t\thopcount, 1);\n\tif (rdev) {\n\t\trdev->prev = prev;\n\t\tif (prev && rio_is_switch(prev))\n\t\t\tprev->rswitch->nextdev[prev_port] = rdev;\n\t} else\n\t\treturn -1;\n\n\tif (rio_is_switch(rdev)) {\n\t\tint sw_destid;\n\t\tint cur_destid;\n\t\tint sw_inport;\n\t\tu16 destid;\n\t\tint port_num;\n\n\t\tsw_inport = RIO_GET_PORT_NUM(rdev->swpinfo);\n\t\trio_route_add_entry(rdev, RIO_GLOBAL_TABLE,\n\t\t\t\t    port->host_deviceid, sw_inport, 0);\n\t\trdev->rswitch->route_table[port->host_deviceid] = sw_inport;\n\n\t\tdestid = rio_destid_first(net);\n\t\twhile (destid != RIO_INVALID_DESTID && destid < next_destid) {\n\t\t\tif (destid != port->host_deviceid) {\n\t\t\t\trio_route_add_entry(rdev, RIO_GLOBAL_TABLE,\n\t\t\t\t\t\t    destid, sw_inport, 0);\n\t\t\t\trdev->rswitch->route_table[destid] = sw_inport;\n\t\t\t}\n\t\t\tdestid = rio_destid_next(net, destid + 1);\n\t\t}\n\t\tpr_debug(\n\t\t    \"RIO: found %s (vid %4.4x did %4.4x) with %d ports\\n\",\n\t\t    rio_name(rdev), rdev->vid, rdev->did,\n\t\t    RIO_GET_TOTAL_PORTS(rdev->swpinfo));\n\t\tsw_destid = next_destid;\n\t\tfor (port_num = 0;\n\t\t     port_num < RIO_GET_TOTAL_PORTS(rdev->swpinfo);\n\t\t     port_num++) {\n\t\t\tif (sw_inport == port_num) {\n\t\t\t\trio_enable_rx_tx_port(port, 0,\n\t\t\t\t\t      RIO_ANY_DESTID(port->sys_size),\n\t\t\t\t\t      hopcount, port_num);\n\t\t\t\trdev->rswitch->port_ok |= (1 << port_num);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tcur_destid = next_destid;\n\n\t\t\tif (rio_sport_is_active(rdev, port_num)) {\n\t\t\t\tpr_debug(\n\t\t\t\t    \"RIO: scanning device on port %d\\n\",\n\t\t\t\t    port_num);\n\t\t\t\trio_enable_rx_tx_port(port, 0,\n\t\t\t\t\t      RIO_ANY_DESTID(port->sys_size),\n\t\t\t\t\t      hopcount, port_num);\n\t\t\t\trdev->rswitch->port_ok |= (1 << port_num);\n\t\t\t\trio_route_add_entry(rdev, RIO_GLOBAL_TABLE,\n\t\t\t\t\t\tRIO_ANY_DESTID(port->sys_size),\n\t\t\t\t\t\tport_num, 0);\n\n\t\t\t\tif (rio_enum_peer(net, port, hopcount + 1,\n\t\t\t\t\t\t  rdev, port_num) < 0)\n\t\t\t\t\treturn -1;\n\n\t\t\t\t \n\t\t\t\tdestid = rio_destid_next(net, cur_destid + 1);\n\t\t\t\tif (destid != RIO_INVALID_DESTID) {\n\t\t\t\t\tfor (destid = cur_destid;\n\t\t\t\t\t     destid < next_destid;) {\n\t\t\t\t\t\tif (destid != port->host_deviceid) {\n\t\t\t\t\t\t\trio_route_add_entry(rdev,\n\t\t\t\t\t\t\t\t    RIO_GLOBAL_TABLE,\n\t\t\t\t\t\t\t\t    destid,\n\t\t\t\t\t\t\t\t    port_num,\n\t\t\t\t\t\t\t\t    0);\n\t\t\t\t\t\t\trdev->rswitch->\n\t\t\t\t\t\t\t\troute_table[destid] =\n\t\t\t\t\t\t\t\tport_num;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdestid = rio_destid_next(net,\n\t\t\t\t\t\t\t\tdestid + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tif (rdev->em_efptr)\n\t\t\t\t\trio_set_port_lockout(rdev, port_num, 1);\n\n\t\t\t\trdev->rswitch->port_ok &= ~(1 << port_num);\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif ((rdev->src_ops & RIO_SRC_OPS_PORT_WRITE) &&\n\t\t    (rdev->em_efptr)) {\n\t\t\trio_write_config_32(rdev,\n\t\t\t\t\trdev->em_efptr + RIO_EM_PW_TGT_DEVID,\n\t\t\t\t\t(port->host_deviceid << 16) |\n\t\t\t\t\t(port->sys_size << 15));\n\t\t}\n\n\t\trio_init_em(rdev);\n\n\t\t \n\t\tif (next_destid == sw_destid)\n\t\t\tnext_destid = rio_destid_alloc(net);\n\n\t\trdev->destid = sw_destid;\n\t} else\n\t\tpr_debug(\"RIO: found %s (vid %4.4x did %4.4x)\\n\",\n\t\t    rio_name(rdev), rdev->vid, rdev->did);\n\n\treturn 0;\n}\n\n \nstatic int rio_enum_complete(struct rio_mport *port)\n{\n\tu32 regval;\n\n\trio_local_read_config_32(port, port->phys_efptr + RIO_PORT_GEN_CTL_CSR,\n\t\t\t\t &regval);\n\treturn (regval & RIO_PORT_GEN_DISCOVERED) ? 1 : 0;\n}\n\n \nstatic int\nrio_disc_peer(struct rio_net *net, struct rio_mport *port, u16 destid,\n\t      u8 hopcount, struct rio_dev *prev, int prev_port)\n{\n\tu8 port_num, route_port;\n\tstruct rio_dev *rdev;\n\tu16 ndestid;\n\n\t \n\tif ((rdev = rio_setup_device(net, port, destid, hopcount, 0))) {\n\t\trdev->prev = prev;\n\t\tif (prev && rio_is_switch(prev))\n\t\t\tprev->rswitch->nextdev[prev_port] = rdev;\n\t} else\n\t\treturn -1;\n\n\tif (rio_is_switch(rdev)) {\n\t\t \n\t\trdev->destid = destid;\n\n\t\tpr_debug(\n\t\t    \"RIO: found %s (vid %4.4x did %4.4x) with %d ports\\n\",\n\t\t    rio_name(rdev), rdev->vid, rdev->did,\n\t\t    RIO_GET_TOTAL_PORTS(rdev->swpinfo));\n\t\tfor (port_num = 0;\n\t\t     port_num < RIO_GET_TOTAL_PORTS(rdev->swpinfo);\n\t\t     port_num++) {\n\t\t\tif (RIO_GET_PORT_NUM(rdev->swpinfo) == port_num)\n\t\t\t\tcontinue;\n\n\t\t\tif (rio_sport_is_active(rdev, port_num)) {\n\t\t\t\tpr_debug(\n\t\t\t\t    \"RIO: scanning device on port %d\\n\",\n\t\t\t\t    port_num);\n\n\t\t\t\trio_lock_device(port, destid, hopcount, 1000);\n\n\t\t\t\tfor (ndestid = 0;\n\t\t\t\t     ndestid < RIO_ANY_DESTID(port->sys_size);\n\t\t\t\t     ndestid++) {\n\t\t\t\t\trio_route_get_entry(rdev,\n\t\t\t\t\t\t\t    RIO_GLOBAL_TABLE,\n\t\t\t\t\t\t\t    ndestid,\n\t\t\t\t\t\t\t    &route_port, 0);\n\t\t\t\t\tif (route_port == port_num)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (ndestid == RIO_ANY_DESTID(port->sys_size))\n\t\t\t\t\tcontinue;\n\t\t\t\trio_unlock_device(port, destid, hopcount);\n\t\t\t\tif (rio_disc_peer(net, port, ndestid,\n\t\t\t\t\thopcount + 1, rdev, port_num) < 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t} else\n\t\tpr_debug(\"RIO: found %s (vid %4.4x did %4.4x)\\n\",\n\t\t    rio_name(rdev), rdev->vid, rdev->did);\n\n\treturn 0;\n}\n\n \nstatic int rio_mport_is_active(struct rio_mport *port)\n{\n\tu32 result = 0;\n\n\trio_local_read_config_32(port,\n\t\tport->phys_efptr +\n\t\t\tRIO_PORT_N_ERR_STS_CSR(port->index, port->phys_rmap),\n\t\t&result);\n\treturn result & RIO_PORT_N_ERR_STS_PORT_OK;\n}\n\nstatic void rio_scan_release_net(struct rio_net *net)\n{\n\tpr_debug(\"RIO-SCAN: %s: net_%d\\n\", __func__, net->id);\n\tkfree(net->enum_data);\n}\n\nstatic void rio_scan_release_dev(struct device *dev)\n{\n\tstruct rio_net *net;\n\n\tnet = to_rio_net(dev);\n\tpr_debug(\"RIO-SCAN: %s: net_%d\\n\", __func__, net->id);\n\tkfree(net);\n}\n\n \nstatic struct rio_net *rio_scan_alloc_net(struct rio_mport *mport,\n\t\t\t\t\t  int do_enum, u16 start)\n{\n\tstruct rio_net *net;\n\n\tnet = rio_alloc_net(mport);\n\n\tif (net && do_enum) {\n\t\tstruct rio_id_table *idtab;\n\t\tsize_t size;\n\n\t\tsize = sizeof(struct rio_id_table) +\n\t\t\t\tBITS_TO_LONGS(\n\t\t\t\t\tRIO_MAX_ROUTE_ENTRIES(mport->sys_size)\n\t\t\t\t\t) * sizeof(long);\n\n\t\tidtab = kzalloc(size, GFP_KERNEL);\n\n\t\tif (idtab == NULL) {\n\t\t\tpr_err(\"RIO: failed to allocate destID table\\n\");\n\t\t\trio_free_net(net);\n\t\t\tnet = NULL;\n\t\t} else {\n\t\t\tnet->enum_data = idtab;\n\t\t\tnet->release = rio_scan_release_net;\n\t\t\tidtab->start = start;\n\t\t\tidtab->max = RIO_MAX_ROUTE_ENTRIES(mport->sys_size);\n\t\t\tspin_lock_init(&idtab->lock);\n\t\t}\n\t}\n\n\tif (net) {\n\t\tnet->id = mport->id;\n\t\tnet->hport = mport;\n\t\tdev_set_name(&net->dev, \"rnet_%d\", net->id);\n\t\tnet->dev.parent = &mport->dev;\n\t\tnet->dev.release = rio_scan_release_dev;\n\t\trio_add_net(net);\n\t}\n\n\treturn net;\n}\n\n \nstatic void rio_update_route_tables(struct rio_net *net)\n{\n\tstruct rio_dev *rdev, *swrdev;\n\tstruct rio_switch *rswitch;\n\tu8 sport;\n\tu16 destid;\n\n\tlist_for_each_entry(rdev, &net->devices, net_list) {\n\n\t\tdestid = rdev->destid;\n\n\t\tlist_for_each_entry(rswitch, &net->switches, node) {\n\n\t\t\tif (rio_is_switch(rdev)\t&& (rdev->rswitch == rswitch))\n\t\t\t\tcontinue;\n\n\t\t\tif (RIO_INVALID_ROUTE == rswitch->route_table[destid]) {\n\t\t\t\tswrdev = sw_to_rio_dev(rswitch);\n\n\t\t\t\t \n\t\t\t\tif (swrdev->destid == destid)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tsport = RIO_GET_PORT_NUM(swrdev->swpinfo);\n\n\t\t\t\trio_route_add_entry(swrdev, RIO_GLOBAL_TABLE,\n\t\t\t\t\t\t    destid, sport, 0);\n\t\t\t\trswitch->route_table[destid] = sport;\n\t\t\t}\n\t\t}\n\t}\n}\n\n \nstatic void rio_init_em(struct rio_dev *rdev)\n{\n\tif (rio_is_switch(rdev) && (rdev->em_efptr) &&\n\t    rdev->rswitch->ops && rdev->rswitch->ops->em_init) {\n\t\trdev->rswitch->ops->em_init(rdev);\n\t}\n}\n\n \nstatic int rio_enum_mport(struct rio_mport *mport, u32 flags)\n{\n\tstruct rio_net *net = NULL;\n\tint rc = 0;\n\n\tprintk(KERN_INFO \"RIO: enumerate master port %d, %s\\n\", mport->id,\n\t       mport->name);\n\n\t \n\tif (mport->nnode.next || mport->nnode.prev)\n\t\treturn -EBUSY;\n\n\t \n\tif (rio_enum_host(mport) < 0) {\n\t\tprintk(KERN_INFO\n\t\t       \"RIO: master port %d device has been enumerated by a remote host\\n\",\n\t\t       mport->id);\n\t\trc = -EBUSY;\n\t\tgoto out;\n\t}\n\n\t \n\tif (rio_mport_is_active(mport)) {\n\t\tnet = rio_scan_alloc_net(mport, 1, 0);\n\t\tif (!net) {\n\t\t\tprintk(KERN_ERR \"RIO: failed to allocate new net\\n\");\n\t\t\trc = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\trio_destid_reserve(net, mport->host_deviceid);\n\n\t\t \n\t\trio_enable_rx_tx_port(mport, 1, 0, 0, 0);\n\n\t\t \n\t\trio_local_write_config_32(mport, RIO_COMPONENT_TAG_CSR,\n\t\t\t\t\t  next_comptag++);\n\n\t\tnext_destid = rio_destid_alloc(net);\n\n\t\tif (rio_enum_peer(net, mport, 0, NULL, 0) < 0) {\n\t\t\t \n\t\t\tprintk(KERN_INFO\n\t\t\t       \"RIO: master port %d device has lost enumeration to a remote host\\n\",\n\t\t\t       mport->id);\n\t\t\trio_clear_locks(net);\n\t\t\trc = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\t\t \n\t\trio_destid_free(net, next_destid);\n\t\trio_update_route_tables(net);\n\t\trio_clear_locks(net);\n\t\trio_pw_enable(mport, 1);\n\t} else {\n\t\tprintk(KERN_INFO \"RIO: master port %d link inactive\\n\",\n\t\t       mport->id);\n\t\trc = -EINVAL;\n\t}\n\n      out:\n\treturn rc;\n}\n\n \nstatic void rio_build_route_tables(struct rio_net *net)\n{\n\tstruct rio_switch *rswitch;\n\tstruct rio_dev *rdev;\n\tint i;\n\tu8 sport;\n\n\tlist_for_each_entry(rswitch, &net->switches, node) {\n\t\trdev = sw_to_rio_dev(rswitch);\n\n\t\trio_lock_device(net->hport, rdev->destid,\n\t\t\t\trdev->hopcount, 1000);\n\t\tfor (i = 0;\n\t\t     i < RIO_MAX_ROUTE_ENTRIES(net->hport->sys_size);\n\t\t     i++) {\n\t\t\tif (rio_route_get_entry(rdev, RIO_GLOBAL_TABLE,\n\t\t\t\t\t\ti, &sport, 0) < 0)\n\t\t\t\tcontinue;\n\t\t\trswitch->route_table[i] = sport;\n\t\t}\n\n\t\trio_unlock_device(net->hport, rdev->destid, rdev->hopcount);\n\t}\n}\n\n \nstatic int rio_disc_mport(struct rio_mport *mport, u32 flags)\n{\n\tstruct rio_net *net = NULL;\n\tunsigned long to_end;\n\n\tprintk(KERN_INFO \"RIO: discover master port %d, %s\\n\", mport->id,\n\t       mport->name);\n\n\t \n\tif (rio_mport_is_active(mport)) {\n\t\tif (rio_enum_complete(mport))\n\t\t\tgoto enum_done;\n\t\telse if (flags & RIO_SCAN_ENUM_NO_WAIT)\n\t\t\treturn -EAGAIN;\n\n\t\tpr_debug(\"RIO: wait for enumeration to complete...\\n\");\n\n\t\tto_end = jiffies + CONFIG_RAPIDIO_DISC_TIMEOUT * HZ;\n\t\twhile (time_before(jiffies, to_end)) {\n\t\t\tif (rio_enum_complete(mport))\n\t\t\t\tgoto enum_done;\n\t\t\tmsleep(10);\n\t\t}\n\n\t\tpr_debug(\"RIO: discovery timeout on mport %d %s\\n\",\n\t\t\t mport->id, mport->name);\n\t\tgoto bail;\nenum_done:\n\t\tpr_debug(\"RIO: ... enumeration done\\n\");\n\n\t\tnet = rio_scan_alloc_net(mport, 0, 0);\n\t\tif (!net) {\n\t\t\tprintk(KERN_ERR \"RIO: Failed to allocate new net\\n\");\n\t\t\tgoto bail;\n\t\t}\n\n\t\t \n\t\trio_local_read_config_32(mport, RIO_DID_CSR,\n\t\t\t\t\t &mport->host_deviceid);\n\t\tmport->host_deviceid = RIO_GET_DID(mport->sys_size,\n\t\t\t\t\t\t   mport->host_deviceid);\n\n\t\tif (rio_disc_peer(net, mport, RIO_ANY_DESTID(mport->sys_size),\n\t\t\t\t\t0, NULL, 0) < 0) {\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"RIO: master port %d device has failed discovery\\n\",\n\t\t\t       mport->id);\n\t\t\tgoto bail;\n\t\t}\n\n\t\trio_build_route_tables(net);\n\t}\n\n\treturn 0;\nbail:\n\treturn -EBUSY;\n}\n\nstatic struct rio_scan rio_scan_ops = {\n\t.owner = THIS_MODULE,\n\t.enumerate = rio_enum_mport,\n\t.discover = rio_disc_mport,\n};\n\nstatic bool scan;\nmodule_param(scan, bool, 0);\nMODULE_PARM_DESC(scan, \"Start RapidIO network enumeration/discovery \"\n\t\t\t\"(default = 0)\");\n\n \n\nstatic int __init rio_basic_attach(void)\n{\n\tif (rio_register_scan(RIO_MPORT_ANY, &rio_scan_ops))\n\t\treturn -EIO;\n\tif (scan)\n\t\trio_init_mports();\n\treturn 0;\n}\n\nlate_initcall(rio_basic_attach);\n\nMODULE_DESCRIPTION(\"Basic RapidIO enumeration/discovery\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}