{
  "module_name": "rio.c",
  "hash_id": "63dc30a37aad1e70e7c8ae010e1d6965784d8d3e5928ea03c5290e45b62fa4c9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rapidio/rio.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/kernel.h>\n\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/rio.h>\n#include <linux/rio_drv.h>\n#include <linux/rio_ids.h>\n#include <linux/rio_regs.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n\n#include \"rio.h\"\n\n \nstruct rio_pwrite {\n\tstruct list_head node;\n\n\tint (*pwcback)(struct rio_mport *mport, void *context,\n\t\t       union rio_pw_msg *msg, int step);\n\tvoid *context;\n};\n\nMODULE_DESCRIPTION(\"RapidIO Subsystem Core\");\nMODULE_AUTHOR(\"Matt Porter <mporter@kernel.crashing.org>\");\nMODULE_AUTHOR(\"Alexandre Bounine <alexandre.bounine@idt.com>\");\nMODULE_LICENSE(\"GPL\");\n\nstatic int hdid[RIO_MAX_MPORTS];\nstatic int ids_num;\nmodule_param_array(hdid, int, &ids_num, 0);\nMODULE_PARM_DESC(hdid,\n\t\"Destination ID assignment to local RapidIO controllers\");\n\nstatic LIST_HEAD(rio_devices);\nstatic LIST_HEAD(rio_nets);\nstatic DEFINE_SPINLOCK(rio_global_list_lock);\n\nstatic LIST_HEAD(rio_mports);\nstatic LIST_HEAD(rio_scans);\nstatic DEFINE_MUTEX(rio_mport_list_lock);\nstatic unsigned char next_portid;\nstatic DEFINE_SPINLOCK(rio_mmap_lock);\n\n \nu16 rio_local_get_device_id(struct rio_mport *port)\n{\n\tu32 result;\n\n\trio_local_read_config_32(port, RIO_DID_CSR, &result);\n\n\treturn (RIO_GET_DID(port->sys_size, result));\n}\nEXPORT_SYMBOL_GPL(rio_local_get_device_id);\n\n \nint rio_query_mport(struct rio_mport *port,\n\t\t    struct rio_mport_attr *mport_attr)\n{\n\tif (!port->ops->query_mport)\n\t\treturn -ENODATA;\n\treturn port->ops->query_mport(port, mport_attr);\n}\nEXPORT_SYMBOL(rio_query_mport);\n\n \nstruct rio_net *rio_alloc_net(struct rio_mport *mport)\n{\n\tstruct rio_net *net = kzalloc(sizeof(*net), GFP_KERNEL);\n\n\tif (net) {\n\t\tINIT_LIST_HEAD(&net->node);\n\t\tINIT_LIST_HEAD(&net->devices);\n\t\tINIT_LIST_HEAD(&net->switches);\n\t\tINIT_LIST_HEAD(&net->mports);\n\t\tmport->net = net;\n\t}\n\treturn net;\n}\nEXPORT_SYMBOL_GPL(rio_alloc_net);\n\nint rio_add_net(struct rio_net *net)\n{\n\tint err;\n\n\terr = device_register(&net->dev);\n\tif (err)\n\t\treturn err;\n\tspin_lock(&rio_global_list_lock);\n\tlist_add_tail(&net->node, &rio_nets);\n\tspin_unlock(&rio_global_list_lock);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(rio_add_net);\n\nvoid rio_free_net(struct rio_net *net)\n{\n\tspin_lock(&rio_global_list_lock);\n\tif (!list_empty(&net->node))\n\t\tlist_del(&net->node);\n\tspin_unlock(&rio_global_list_lock);\n\tif (net->release)\n\t\tnet->release(net);\n\tdevice_unregister(&net->dev);\n}\nEXPORT_SYMBOL_GPL(rio_free_net);\n\n \nvoid rio_local_set_device_id(struct rio_mport *port, u16 did)\n{\n\trio_local_write_config_32(port, RIO_DID_CSR,\n\t\t\t\t  RIO_SET_DID(port->sys_size, did));\n}\nEXPORT_SYMBOL_GPL(rio_local_set_device_id);\n\n \nint rio_add_device(struct rio_dev *rdev)\n{\n\tint err;\n\n\tatomic_set(&rdev->state, RIO_DEVICE_RUNNING);\n\terr = device_register(&rdev->dev);\n\tif (err)\n\t\treturn err;\n\n\tspin_lock(&rio_global_list_lock);\n\tlist_add_tail(&rdev->global_list, &rio_devices);\n\tif (rdev->net) {\n\t\tlist_add_tail(&rdev->net_list, &rdev->net->devices);\n\t\tif (rdev->pef & RIO_PEF_SWITCH)\n\t\t\tlist_add_tail(&rdev->rswitch->node,\n\t\t\t\t      &rdev->net->switches);\n\t}\n\tspin_unlock(&rio_global_list_lock);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(rio_add_device);\n\n \nvoid rio_del_device(struct rio_dev *rdev, enum rio_device_state state)\n{\n\tpr_debug(\"RIO: %s: removing %s\\n\", __func__, rio_name(rdev));\n\tatomic_set(&rdev->state, state);\n\tspin_lock(&rio_global_list_lock);\n\tlist_del(&rdev->global_list);\n\tif (rdev->net) {\n\t\tlist_del(&rdev->net_list);\n\t\tif (rdev->pef & RIO_PEF_SWITCH) {\n\t\t\tlist_del(&rdev->rswitch->node);\n\t\t\tkfree(rdev->rswitch->route_table);\n\t\t}\n\t}\n\tspin_unlock(&rio_global_list_lock);\n\tdevice_unregister(&rdev->dev);\n}\nEXPORT_SYMBOL_GPL(rio_del_device);\n\n \nint rio_request_inb_mbox(struct rio_mport *mport,\n\t\t\t void *dev_id,\n\t\t\t int mbox,\n\t\t\t int entries,\n\t\t\t void (*minb) (struct rio_mport * mport, void *dev_id, int mbox,\n\t\t\t\t       int slot))\n{\n\tint rc = -ENOSYS;\n\tstruct resource *res;\n\n\tif (!mport->ops->open_inb_mbox)\n\t\tgoto out;\n\n\tres = kzalloc(sizeof(*res), GFP_KERNEL);\n\tif (res) {\n\t\trio_init_mbox_res(res, mbox, mbox);\n\n\t\t \n\t\trc = request_resource(&mport->riores[RIO_INB_MBOX_RESOURCE],\n\t\t\t\t      res);\n\t\tif (rc < 0) {\n\t\t\tkfree(res);\n\t\t\tgoto out;\n\t\t}\n\n\t\tmport->inb_msg[mbox].res = res;\n\n\t\t \n\t\tmport->inb_msg[mbox].mcback = minb;\n\n\t\trc = mport->ops->open_inb_mbox(mport, dev_id, mbox, entries);\n\t\tif (rc) {\n\t\t\tmport->inb_msg[mbox].mcback = NULL;\n\t\t\tmport->inb_msg[mbox].res = NULL;\n\t\t\trelease_resource(res);\n\t\t\tkfree(res);\n\t\t}\n\t} else\n\t\trc = -ENOMEM;\n\n      out:\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(rio_request_inb_mbox);\n\n \nint rio_release_inb_mbox(struct rio_mport *mport, int mbox)\n{\n\tint rc;\n\n\tif (!mport->ops->close_inb_mbox || !mport->inb_msg[mbox].res)\n\t\treturn -EINVAL;\n\n\tmport->ops->close_inb_mbox(mport, mbox);\n\tmport->inb_msg[mbox].mcback = NULL;\n\n\trc = release_resource(mport->inb_msg[mbox].res);\n\tif (rc)\n\t\treturn rc;\n\n\tkfree(mport->inb_msg[mbox].res);\n\tmport->inb_msg[mbox].res = NULL;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(rio_release_inb_mbox);\n\n \nint rio_request_outb_mbox(struct rio_mport *mport,\n\t\t\t  void *dev_id,\n\t\t\t  int mbox,\n\t\t\t  int entries,\n\t\t\t  void (*moutb) (struct rio_mport * mport, void *dev_id, int mbox, int slot))\n{\n\tint rc = -ENOSYS;\n\tstruct resource *res;\n\n\tif (!mport->ops->open_outb_mbox)\n\t\tgoto out;\n\n\tres = kzalloc(sizeof(*res), GFP_KERNEL);\n\tif (res) {\n\t\trio_init_mbox_res(res, mbox, mbox);\n\n\t\t \n\t\trc = request_resource(&mport->riores[RIO_OUTB_MBOX_RESOURCE],\n\t\t\t\t      res);\n\t\tif (rc < 0) {\n\t\t\tkfree(res);\n\t\t\tgoto out;\n\t\t}\n\n\t\tmport->outb_msg[mbox].res = res;\n\n\t\t \n\t\tmport->outb_msg[mbox].mcback = moutb;\n\n\t\trc = mport->ops->open_outb_mbox(mport, dev_id, mbox, entries);\n\t\tif (rc) {\n\t\t\tmport->outb_msg[mbox].mcback = NULL;\n\t\t\tmport->outb_msg[mbox].res = NULL;\n\t\t\trelease_resource(res);\n\t\t\tkfree(res);\n\t\t}\n\t} else\n\t\trc = -ENOMEM;\n\n      out:\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(rio_request_outb_mbox);\n\n \nint rio_release_outb_mbox(struct rio_mport *mport, int mbox)\n{\n\tint rc;\n\n\tif (!mport->ops->close_outb_mbox || !mport->outb_msg[mbox].res)\n\t\treturn -EINVAL;\n\n\tmport->ops->close_outb_mbox(mport, mbox);\n\tmport->outb_msg[mbox].mcback = NULL;\n\n\trc = release_resource(mport->outb_msg[mbox].res);\n\tif (rc)\n\t\treturn rc;\n\n\tkfree(mport->outb_msg[mbox].res);\n\tmport->outb_msg[mbox].res = NULL;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(rio_release_outb_mbox);\n\n \nstatic int\nrio_setup_inb_dbell(struct rio_mport *mport, void *dev_id, struct resource *res,\n\t\t    void (*dinb) (struct rio_mport * mport, void *dev_id, u16 src, u16 dst,\n\t\t\t\t  u16 info))\n{\n\tstruct rio_dbell *dbell = kmalloc(sizeof(*dbell), GFP_KERNEL);\n\n\tif (!dbell)\n\t\treturn -ENOMEM;\n\n\tdbell->res = res;\n\tdbell->dinb = dinb;\n\tdbell->dev_id = dev_id;\n\n\tmutex_lock(&mport->lock);\n\tlist_add_tail(&dbell->node, &mport->dbells);\n\tmutex_unlock(&mport->lock);\n\treturn 0;\n}\n\n \nint rio_request_inb_dbell(struct rio_mport *mport,\n\t\t\t  void *dev_id,\n\t\t\t  u16 start,\n\t\t\t  u16 end,\n\t\t\t  void (*dinb) (struct rio_mport * mport, void *dev_id, u16 src,\n\t\t\t\t\tu16 dst, u16 info))\n{\n\tint rc;\n\tstruct resource *res = kzalloc(sizeof(*res), GFP_KERNEL);\n\n\tif (res) {\n\t\trio_init_dbell_res(res, start, end);\n\n\t\t \n\t\trc = request_resource(&mport->riores[RIO_DOORBELL_RESOURCE],\n\t\t\t\t      res);\n\t\tif (rc < 0) {\n\t\t\tkfree(res);\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\trc = rio_setup_inb_dbell(mport, dev_id, res, dinb);\n\t} else\n\t\trc = -ENOMEM;\n\n      out:\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(rio_request_inb_dbell);\n\n \nint rio_release_inb_dbell(struct rio_mport *mport, u16 start, u16 end)\n{\n\tint rc = 0, found = 0;\n\tstruct rio_dbell *dbell;\n\n\tmutex_lock(&mport->lock);\n\tlist_for_each_entry(dbell, &mport->dbells, node) {\n\t\tif ((dbell->res->start == start) && (dbell->res->end == end)) {\n\t\t\tlist_del(&dbell->node);\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&mport->lock);\n\n\t \n\tif (!found) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t \n\trc = release_resource(dbell->res);\n\n\t \n\tkfree(dbell);\n\n      out:\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(rio_release_inb_dbell);\n\n \nstruct resource *rio_request_outb_dbell(struct rio_dev *rdev, u16 start,\n\t\t\t\t\tu16 end)\n{\n\tstruct resource *res = kzalloc(sizeof(struct resource), GFP_KERNEL);\n\n\tif (res) {\n\t\trio_init_dbell_res(res, start, end);\n\n\t\t \n\t\tif (request_resource(&rdev->riores[RIO_DOORBELL_RESOURCE], res)\n\t\t    < 0) {\n\t\t\tkfree(res);\n\t\t\tres = NULL;\n\t\t}\n\t}\n\n\treturn res;\n}\nEXPORT_SYMBOL_GPL(rio_request_outb_dbell);\n\n \nint rio_release_outb_dbell(struct rio_dev *rdev, struct resource *res)\n{\n\tint rc = release_resource(res);\n\n\tkfree(res);\n\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(rio_release_outb_dbell);\n\n \nint rio_add_mport_pw_handler(struct rio_mport *mport, void *context,\n\t\t\t     int (*pwcback)(struct rio_mport *mport,\n\t\t\t     void *context, union rio_pw_msg *msg, int step))\n{\n\tstruct rio_pwrite *pwrite = kzalloc(sizeof(*pwrite), GFP_KERNEL);\n\n\tif (!pwrite)\n\t\treturn -ENOMEM;\n\n\tpwrite->pwcback = pwcback;\n\tpwrite->context = context;\n\tmutex_lock(&mport->lock);\n\tlist_add_tail(&pwrite->node, &mport->pwrites);\n\tmutex_unlock(&mport->lock);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(rio_add_mport_pw_handler);\n\n \nint rio_del_mport_pw_handler(struct rio_mport *mport, void *context,\n\t\t\t     int (*pwcback)(struct rio_mport *mport,\n\t\t\t     void *context, union rio_pw_msg *msg, int step))\n{\n\tint rc = -EINVAL;\n\tstruct rio_pwrite *pwrite;\n\n\tmutex_lock(&mport->lock);\n\tlist_for_each_entry(pwrite, &mport->pwrites, node) {\n\t\tif (pwrite->pwcback == pwcback && pwrite->context == context) {\n\t\t\tlist_del(&pwrite->node);\n\t\t\tkfree(pwrite);\n\t\t\trc = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&mport->lock);\n\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(rio_del_mport_pw_handler);\n\n \nint rio_request_inb_pwrite(struct rio_dev *rdev,\n\tint (*pwcback)(struct rio_dev *rdev, union rio_pw_msg *msg, int step))\n{\n\tint rc = 0;\n\n\tspin_lock(&rio_global_list_lock);\n\tif (rdev->pwcback)\n\t\trc = -ENOMEM;\n\telse\n\t\trdev->pwcback = pwcback;\n\n\tspin_unlock(&rio_global_list_lock);\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(rio_request_inb_pwrite);\n\n \nint rio_release_inb_pwrite(struct rio_dev *rdev)\n{\n\tint rc = -ENOMEM;\n\n\tspin_lock(&rio_global_list_lock);\n\tif (rdev->pwcback) {\n\t\trdev->pwcback = NULL;\n\t\trc = 0;\n\t}\n\n\tspin_unlock(&rio_global_list_lock);\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(rio_release_inb_pwrite);\n\n \nvoid rio_pw_enable(struct rio_mport *mport, int enable)\n{\n\tif (mport->ops->pwenable) {\n\t\tmutex_lock(&mport->lock);\n\n\t\tif ((enable && ++mport->pwe_refcnt == 1) ||\n\t\t    (!enable && mport->pwe_refcnt && --mport->pwe_refcnt == 0))\n\t\t\tmport->ops->pwenable(mport, enable);\n\t\tmutex_unlock(&mport->lock);\n\t}\n}\nEXPORT_SYMBOL_GPL(rio_pw_enable);\n\n \nint rio_map_inb_region(struct rio_mport *mport, dma_addr_t local,\n\t\t\tu64 rbase, u32 size, u32 rflags)\n{\n\tint rc;\n\tunsigned long flags;\n\n\tif (!mport->ops->map_inb)\n\t\treturn -1;\n\tspin_lock_irqsave(&rio_mmap_lock, flags);\n\trc = mport->ops->map_inb(mport, local, rbase, size, rflags);\n\tspin_unlock_irqrestore(&rio_mmap_lock, flags);\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(rio_map_inb_region);\n\n \nvoid rio_unmap_inb_region(struct rio_mport *mport, dma_addr_t lstart)\n{\n\tunsigned long flags;\n\tif (!mport->ops->unmap_inb)\n\t\treturn;\n\tspin_lock_irqsave(&rio_mmap_lock, flags);\n\tmport->ops->unmap_inb(mport, lstart);\n\tspin_unlock_irqrestore(&rio_mmap_lock, flags);\n}\nEXPORT_SYMBOL_GPL(rio_unmap_inb_region);\n\n \nint rio_map_outb_region(struct rio_mport *mport, u16 destid, u64 rbase,\n\t\t\tu32 size, u32 rflags, dma_addr_t *local)\n{\n\tint rc;\n\tunsigned long flags;\n\n\tif (!mport->ops->map_outb)\n\t\treturn -ENODEV;\n\n\tspin_lock_irqsave(&rio_mmap_lock, flags);\n\trc = mport->ops->map_outb(mport, destid, rbase, size,\n\t\trflags, local);\n\tspin_unlock_irqrestore(&rio_mmap_lock, flags);\n\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(rio_map_outb_region);\n\n \nvoid rio_unmap_outb_region(struct rio_mport *mport, u16 destid, u64 rstart)\n{\n\tunsigned long flags;\n\n\tif (!mport->ops->unmap_outb)\n\t\treturn;\n\n\tspin_lock_irqsave(&rio_mmap_lock, flags);\n\tmport->ops->unmap_outb(mport, destid, rstart);\n\tspin_unlock_irqrestore(&rio_mmap_lock, flags);\n}\nEXPORT_SYMBOL_GPL(rio_unmap_outb_region);\n\n \nu32\nrio_mport_get_physefb(struct rio_mport *port, int local,\n\t\t      u16 destid, u8 hopcount, u32 *rmap)\n{\n\tu32 ext_ftr_ptr;\n\tu32 ftr_header;\n\n\text_ftr_ptr = rio_mport_get_efb(port, local, destid, hopcount, 0);\n\n\twhile (ext_ftr_ptr)  {\n\t\tif (local)\n\t\t\trio_local_read_config_32(port, ext_ftr_ptr,\n\t\t\t\t\t\t &ftr_header);\n\t\telse\n\t\t\trio_mport_read_config_32(port, destid, hopcount,\n\t\t\t\t\t\t ext_ftr_ptr, &ftr_header);\n\n\t\tftr_header = RIO_GET_BLOCK_ID(ftr_header);\n\t\tswitch (ftr_header) {\n\n\t\tcase RIO_EFB_SER_EP_ID:\n\t\tcase RIO_EFB_SER_EP_REC_ID:\n\t\tcase RIO_EFB_SER_EP_FREE_ID:\n\t\tcase RIO_EFB_SER_EP_M1_ID:\n\t\tcase RIO_EFB_SER_EP_SW_M1_ID:\n\t\tcase RIO_EFB_SER_EPF_M1_ID:\n\t\tcase RIO_EFB_SER_EPF_SW_M1_ID:\n\t\t\t*rmap = 1;\n\t\t\treturn ext_ftr_ptr;\n\n\t\tcase RIO_EFB_SER_EP_M2_ID:\n\t\tcase RIO_EFB_SER_EP_SW_M2_ID:\n\t\tcase RIO_EFB_SER_EPF_M2_ID:\n\t\tcase RIO_EFB_SER_EPF_SW_M2_ID:\n\t\t\t*rmap = 2;\n\t\t\treturn ext_ftr_ptr;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\text_ftr_ptr = rio_mport_get_efb(port, local, destid,\n\t\t\t\t\t\thopcount, ext_ftr_ptr);\n\t}\n\n\treturn ext_ftr_ptr;\n}\nEXPORT_SYMBOL_GPL(rio_mport_get_physefb);\n\n \nstruct rio_dev *rio_get_comptag(u32 comp_tag, struct rio_dev *from)\n{\n\tstruct list_head *n;\n\tstruct rio_dev *rdev;\n\n\tspin_lock(&rio_global_list_lock);\n\tn = from ? from->global_list.next : rio_devices.next;\n\n\twhile (n && (n != &rio_devices)) {\n\t\trdev = rio_dev_g(n);\n\t\tif (rdev->comp_tag == comp_tag)\n\t\t\tgoto exit;\n\t\tn = n->next;\n\t}\n\trdev = NULL;\nexit:\n\tspin_unlock(&rio_global_list_lock);\n\treturn rdev;\n}\nEXPORT_SYMBOL_GPL(rio_get_comptag);\n\n \nint rio_set_port_lockout(struct rio_dev *rdev, u32 pnum, int lock)\n{\n\tu32 regval;\n\n\trio_read_config_32(rdev,\n\t\tRIO_DEV_PORT_N_CTL_CSR(rdev, pnum),\n\t\t&regval);\n\tif (lock)\n\t\tregval |= RIO_PORT_N_CTL_LOCKOUT;\n\telse\n\t\tregval &= ~RIO_PORT_N_CTL_LOCKOUT;\n\n\trio_write_config_32(rdev,\n\t\tRIO_DEV_PORT_N_CTL_CSR(rdev, pnum),\n\t\tregval);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(rio_set_port_lockout);\n\n \nint rio_enable_rx_tx_port(struct rio_mport *port,\n\t\t\t  int local, u16 destid,\n\t\t\t  u8 hopcount, u8 port_num)\n{\n#ifdef CONFIG_RAPIDIO_ENABLE_RX_TX_PORTS\n\tu32 regval;\n\tu32 ext_ftr_ptr;\n\tu32 rmap;\n\n\t \n\tpr_debug(\"rio_enable_rx_tx_port(local = %d, destid = %d, hopcount = \"\n\t\t \"%d, port_num = %d)\\n\", local, destid, hopcount, port_num);\n\n\text_ftr_ptr = rio_mport_get_physefb(port, local, destid,\n\t\t\t\t\t    hopcount, &rmap);\n\n\tif (local) {\n\t\trio_local_read_config_32(port,\n\t\t\t\text_ftr_ptr + RIO_PORT_N_CTL_CSR(0, rmap),\n\t\t\t\t&regval);\n\t} else {\n\t\tif (rio_mport_read_config_32(port, destid, hopcount,\n\t\t\text_ftr_ptr + RIO_PORT_N_CTL_CSR(port_num, rmap),\n\t\t\t\t&regval) < 0)\n\t\t\treturn -EIO;\n\t}\n\n\tregval = regval | RIO_PORT_N_CTL_EN_RX | RIO_PORT_N_CTL_EN_TX;\n\n\tif (local) {\n\t\trio_local_write_config_32(port,\n\t\t\text_ftr_ptr + RIO_PORT_N_CTL_CSR(0, rmap), regval);\n\t} else {\n\t\tif (rio_mport_write_config_32(port, destid, hopcount,\n\t\t\text_ftr_ptr + RIO_PORT_N_CTL_CSR(port_num, rmap),\n\t\t\t\tregval) < 0)\n\t\t\treturn -EIO;\n\t}\n#endif\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(rio_enable_rx_tx_port);\n\n\n \nstatic int\nrio_chk_dev_route(struct rio_dev *rdev, struct rio_dev **nrdev, int *npnum)\n{\n\tu32 result;\n\tint p_port, rc = -EIO;\n\tstruct rio_dev *prev = NULL;\n\n\t \n\twhile (rdev->prev && (rdev->prev->pef & RIO_PEF_SWITCH)) {\n\t\tif (!rio_read_config_32(rdev->prev, RIO_DEV_ID_CAR, &result)) {\n\t\t\tprev = rdev->prev;\n\t\t\tbreak;\n\t\t}\n\t\trdev = rdev->prev;\n\t}\n\n\tif (!prev)\n\t\tgoto err_out;\n\n\tp_port = prev->rswitch->route_table[rdev->destid];\n\n\tif (p_port != RIO_INVALID_ROUTE) {\n\t\tpr_debug(\"RIO: link failed on [%s]-P%d\\n\",\n\t\t\t rio_name(prev), p_port);\n\t\t*nrdev = prev;\n\t\t*npnum = p_port;\n\t\trc = 0;\n\t} else\n\t\tpr_debug(\"RIO: failed to trace route to %s\\n\", rio_name(rdev));\nerr_out:\n\treturn rc;\n}\n\n \nint\nrio_mport_chk_dev_access(struct rio_mport *mport, u16 destid, u8 hopcount)\n{\n\tint i = 0;\n\tu32 tmp;\n\n\twhile (rio_mport_read_config_32(mport, destid, hopcount,\n\t\t\t\t\tRIO_DEV_ID_CAR, &tmp)) {\n\t\ti++;\n\t\tif (i == RIO_MAX_CHK_RETRY)\n\t\t\treturn -EIO;\n\t\tmdelay(1);\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(rio_mport_chk_dev_access);\n\n \nstatic int rio_chk_dev_access(struct rio_dev *rdev)\n{\n\treturn rio_mport_chk_dev_access(rdev->net->hport,\n\t\t\t\t\trdev->destid, rdev->hopcount);\n}\n\n \nstatic int\nrio_get_input_status(struct rio_dev *rdev, int pnum, u32 *lnkresp)\n{\n\tu32 regval;\n\tint checkcount;\n\n\tif (lnkresp) {\n\t\t \n\t\trio_read_config_32(rdev,\n\t\t\tRIO_DEV_PORT_N_MNT_RSP_CSR(rdev, pnum),\n\t\t\t&regval);\n\t\tudelay(50);\n\t}\n\n\t \n\trio_write_config_32(rdev,\n\t\tRIO_DEV_PORT_N_MNT_REQ_CSR(rdev, pnum),\n\t\tRIO_MNT_REQ_CMD_IS);\n\n\t \n\tif (!lnkresp)\n\t\treturn 0;\n\n\tcheckcount = 3;\n\twhile (checkcount--) {\n\t\tudelay(50);\n\t\trio_read_config_32(rdev,\n\t\t\tRIO_DEV_PORT_N_MNT_RSP_CSR(rdev, pnum),\n\t\t\t&regval);\n\t\tif (regval & RIO_PORT_N_MNT_RSP_RVAL) {\n\t\t\t*lnkresp = regval;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -EIO;\n}\n\n \nstatic int rio_clr_err_stopped(struct rio_dev *rdev, u32 pnum, u32 err_status)\n{\n\tstruct rio_dev *nextdev = rdev->rswitch->nextdev[pnum];\n\tu32 regval;\n\tu32 far_ackid, far_linkstat, near_ackid;\n\n\tif (err_status == 0)\n\t\trio_read_config_32(rdev,\n\t\t\tRIO_DEV_PORT_N_ERR_STS_CSR(rdev, pnum),\n\t\t\t&err_status);\n\n\tif (err_status & RIO_PORT_N_ERR_STS_OUT_ES) {\n\t\tpr_debug(\"RIO_EM: servicing Output Error-Stopped state\\n\");\n\t\t \n\t\tif (rio_get_input_status(rdev, pnum, &regval)) {\n\t\t\tpr_debug(\"RIO_EM: Input-status response timeout\\n\");\n\t\t\tgoto rd_err;\n\t\t}\n\n\t\tpr_debug(\"RIO_EM: SP%d Input-status response=0x%08x\\n\",\n\t\t\t pnum, regval);\n\t\tfar_ackid = (regval & RIO_PORT_N_MNT_RSP_ASTAT) >> 5;\n\t\tfar_linkstat = regval & RIO_PORT_N_MNT_RSP_LSTAT;\n\t\trio_read_config_32(rdev,\n\t\t\tRIO_DEV_PORT_N_ACK_STS_CSR(rdev, pnum),\n\t\t\t&regval);\n\t\tpr_debug(\"RIO_EM: SP%d_ACK_STS_CSR=0x%08x\\n\", pnum, regval);\n\t\tnear_ackid = (regval & RIO_PORT_N_ACK_INBOUND) >> 24;\n\t\tpr_debug(\"RIO_EM: SP%d far_ackID=0x%02x far_linkstat=0x%02x\" \\\n\t\t\t \" near_ackID=0x%02x\\n\",\n\t\t\tpnum, far_ackid, far_linkstat, near_ackid);\n\n\t\t \n\t\tif ((far_ackid != ((regval & RIO_PORT_N_ACK_OUTSTAND) >> 8)) ||\n\t\t    (far_ackid != (regval & RIO_PORT_N_ACK_OUTBOUND))) {\n\t\t\t \n\t\t\trio_write_config_32(rdev,\n\t\t\t\tRIO_DEV_PORT_N_ACK_STS_CSR(rdev, pnum),\n\t\t\t\t(near_ackid << 24) |\n\t\t\t\t\t(far_ackid << 8) | far_ackid);\n\t\t\t \n\t\t\tfar_ackid++;\n\t\t\tif (!nextdev) {\n\t\t\t\tpr_debug(\"RIO_EM: nextdev pointer == NULL\\n\");\n\t\t\t\tgoto rd_err;\n\t\t\t}\n\n\t\t\trio_write_config_32(nextdev,\n\t\t\t\tRIO_DEV_PORT_N_ACK_STS_CSR(nextdev,\n\t\t\t\t\tRIO_GET_PORT_NUM(nextdev->swpinfo)),\n\t\t\t\t(far_ackid << 24) |\n\t\t\t\t(near_ackid << 8) | near_ackid);\n\t\t}\nrd_err:\n\t\trio_read_config_32(rdev, RIO_DEV_PORT_N_ERR_STS_CSR(rdev, pnum),\n\t\t\t\t   &err_status);\n\t\tpr_debug(\"RIO_EM: SP%d_ERR_STS_CSR=0x%08x\\n\", pnum, err_status);\n\t}\n\n\tif ((err_status & RIO_PORT_N_ERR_STS_INP_ES) && nextdev) {\n\t\tpr_debug(\"RIO_EM: servicing Input Error-Stopped state\\n\");\n\t\trio_get_input_status(nextdev,\n\t\t\t\t     RIO_GET_PORT_NUM(nextdev->swpinfo), NULL);\n\t\tudelay(50);\n\n\t\trio_read_config_32(rdev, RIO_DEV_PORT_N_ERR_STS_CSR(rdev, pnum),\n\t\t\t\t   &err_status);\n\t\tpr_debug(\"RIO_EM: SP%d_ERR_STS_CSR=0x%08x\\n\", pnum, err_status);\n\t}\n\n\treturn (err_status & (RIO_PORT_N_ERR_STS_OUT_ES |\n\t\t\t      RIO_PORT_N_ERR_STS_INP_ES)) ? 1 : 0;\n}\n\n \nint rio_inb_pwrite_handler(struct rio_mport *mport, union rio_pw_msg *pw_msg)\n{\n\tstruct rio_dev *rdev;\n\tu32 err_status, em_perrdet, em_ltlerrdet;\n\tint rc, portnum;\n\tstruct rio_pwrite *pwrite;\n\n#ifdef DEBUG_PW\n\t{\n\t\tu32 i;\n\n\t\tpr_debug(\"%s: PW to mport_%d:\\n\", __func__, mport->id);\n\t\tfor (i = 0; i < RIO_PW_MSG_SIZE / sizeof(u32); i = i + 4) {\n\t\t\tpr_debug(\"0x%02x: %08x %08x %08x %08x\\n\",\n\t\t\t\ti * 4, pw_msg->raw[i], pw_msg->raw[i + 1],\n\t\t\t\tpw_msg->raw[i + 2], pw_msg->raw[i + 3]);\n\t\t}\n\t}\n#endif\n\n\trdev = rio_get_comptag((pw_msg->em.comptag & RIO_CTAG_UDEVID), NULL);\n\tif (rdev) {\n\t\tpr_debug(\"RIO: Port-Write message from %s\\n\", rio_name(rdev));\n\t} else {\n\t\tpr_debug(\"RIO: %s No matching device for CTag 0x%08x\\n\",\n\t\t\t__func__, pw_msg->em.comptag);\n\t}\n\n\t \n\tif (rdev && rdev->pwcback) {\n\t\trc = rdev->pwcback(rdev, pw_msg, 0);\n\t\tif (rc == 0)\n\t\t\treturn 0;\n\t}\n\n\tmutex_lock(&mport->lock);\n\tlist_for_each_entry(pwrite, &mport->pwrites, node)\n\t\tpwrite->pwcback(mport, pwrite->context, pw_msg, 0);\n\tmutex_unlock(&mport->lock);\n\n\tif (!rdev)\n\t\treturn 0;\n\n\t \n\n\tportnum = pw_msg->em.is_port & 0xFF;\n\n\t \n\tif (rio_chk_dev_access(rdev)) {\n\t\tpr_debug(\"RIO: device access failed - get link partner\\n\");\n\t\t \n\t\tif (rio_chk_dev_route(rdev, &rdev, &portnum)) {\n\t\t\tpr_err(\"RIO: Route trace for %s failed\\n\",\n\t\t\t\trio_name(rdev));\n\t\t\treturn -EIO;\n\t\t}\n\t\tpw_msg = NULL;\n\t}\n\n\t \n\tif (!(rdev->pef & RIO_PEF_SWITCH))\n\t\treturn 0;\n\n\tif (rdev->phys_efptr == 0) {\n\t\tpr_err(\"RIO_PW: Bad switch initialization for %s\\n\",\n\t\t\trio_name(rdev));\n\t\treturn 0;\n\t}\n\n\t \n\tif (rdev->rswitch->ops && rdev->rswitch->ops->em_handle)\n\t\trdev->rswitch->ops->em_handle(rdev, portnum);\n\n\trio_read_config_32(rdev, RIO_DEV_PORT_N_ERR_STS_CSR(rdev, portnum),\n\t\t\t   &err_status);\n\tpr_debug(\"RIO_PW: SP%d_ERR_STS_CSR=0x%08x\\n\", portnum, err_status);\n\n\tif (err_status & RIO_PORT_N_ERR_STS_PORT_OK) {\n\n\t\tif (!(rdev->rswitch->port_ok & (1 << portnum))) {\n\t\t\trdev->rswitch->port_ok |= (1 << portnum);\n\t\t\trio_set_port_lockout(rdev, portnum, 0);\n\t\t\t \n\t\t\tpr_debug(\"RIO_PW: Device Insertion on [%s]-P%d\\n\",\n\t\t\t       rio_name(rdev), portnum);\n\t\t}\n\n\t\t \n\t\tif (err_status & (RIO_PORT_N_ERR_STS_OUT_ES |\n\t\t\t\t  RIO_PORT_N_ERR_STS_INP_ES)) {\n\t\t\tif (rio_clr_err_stopped(rdev, portnum, err_status))\n\t\t\t\trio_clr_err_stopped(rdev, portnum, 0);\n\t\t}\n\t}  else {  \n\n\t\tif (rdev->rswitch->port_ok & (1 << portnum)) {\n\t\t\trdev->rswitch->port_ok &= ~(1 << portnum);\n\t\t\trio_set_port_lockout(rdev, portnum, 1);\n\n\t\t\tif (rdev->phys_rmap == 1) {\n\t\t\trio_write_config_32(rdev,\n\t\t\t\tRIO_DEV_PORT_N_ACK_STS_CSR(rdev, portnum),\n\t\t\t\tRIO_PORT_N_ACK_CLEAR);\n\t\t\t} else {\n\t\t\t\trio_write_config_32(rdev,\n\t\t\t\t\tRIO_DEV_PORT_N_OB_ACK_CSR(rdev, portnum),\n\t\t\t\t\tRIO_PORT_N_OB_ACK_CLEAR);\n\t\t\t\trio_write_config_32(rdev,\n\t\t\t\t\tRIO_DEV_PORT_N_IB_ACK_CSR(rdev, portnum),\n\t\t\t\t\t0);\n\t\t\t}\n\n\t\t\t \n\t\t\tpr_debug(\"RIO_PW: Device Extraction on [%s]-P%d\\n\",\n\t\t\t       rio_name(rdev), portnum);\n\t\t}\n\t}\n\n\trio_read_config_32(rdev,\n\t\trdev->em_efptr + RIO_EM_PN_ERR_DETECT(portnum), &em_perrdet);\n\tif (em_perrdet) {\n\t\tpr_debug(\"RIO_PW: RIO_EM_P%d_ERR_DETECT=0x%08x\\n\",\n\t\t\t portnum, em_perrdet);\n\t\t \n\t\trio_write_config_32(rdev,\n\t\t\trdev->em_efptr + RIO_EM_PN_ERR_DETECT(portnum), 0);\n\t}\n\n\trio_read_config_32(rdev,\n\t\trdev->em_efptr + RIO_EM_LTL_ERR_DETECT, &em_ltlerrdet);\n\tif (em_ltlerrdet) {\n\t\tpr_debug(\"RIO_PW: RIO_EM_LTL_ERR_DETECT=0x%08x\\n\",\n\t\t\t em_ltlerrdet);\n\t\t \n\t\trio_write_config_32(rdev,\n\t\t\trdev->em_efptr + RIO_EM_LTL_ERR_DETECT, 0);\n\t}\n\n\t \n\trio_write_config_32(rdev, RIO_DEV_PORT_N_ERR_STS_CSR(rdev, portnum),\n\t\t\t    err_status);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(rio_inb_pwrite_handler);\n\n \nu32\nrio_mport_get_efb(struct rio_mport *port, int local, u16 destid,\n\t\t      u8 hopcount, u32 from)\n{\n\tu32 reg_val;\n\n\tif (from == 0) {\n\t\tif (local)\n\t\t\trio_local_read_config_32(port, RIO_ASM_INFO_CAR,\n\t\t\t\t\t\t &reg_val);\n\t\telse\n\t\t\trio_mport_read_config_32(port, destid, hopcount,\n\t\t\t\t\t\t RIO_ASM_INFO_CAR, &reg_val);\n\t\treturn reg_val & RIO_EXT_FTR_PTR_MASK;\n\t} else {\n\t\tif (local)\n\t\t\trio_local_read_config_32(port, from, &reg_val);\n\t\telse\n\t\t\trio_mport_read_config_32(port, destid, hopcount,\n\t\t\t\t\t\t from, &reg_val);\n\t\treturn RIO_GET_BLOCK_ID(reg_val);\n\t}\n}\nEXPORT_SYMBOL_GPL(rio_mport_get_efb);\n\n \nu32\nrio_mport_get_feature(struct rio_mport * port, int local, u16 destid,\n\t\t      u8 hopcount, int ftr)\n{\n\tu32 asm_info, ext_ftr_ptr, ftr_header;\n\n\tif (local)\n\t\trio_local_read_config_32(port, RIO_ASM_INFO_CAR, &asm_info);\n\telse\n\t\trio_mport_read_config_32(port, destid, hopcount,\n\t\t\t\t\t RIO_ASM_INFO_CAR, &asm_info);\n\n\text_ftr_ptr = asm_info & RIO_EXT_FTR_PTR_MASK;\n\n\twhile (ext_ftr_ptr) {\n\t\tif (local)\n\t\t\trio_local_read_config_32(port, ext_ftr_ptr,\n\t\t\t\t\t\t &ftr_header);\n\t\telse\n\t\t\trio_mport_read_config_32(port, destid, hopcount,\n\t\t\t\t\t\t ext_ftr_ptr, &ftr_header);\n\t\tif (RIO_GET_BLOCK_ID(ftr_header) == ftr)\n\t\t\treturn ext_ftr_ptr;\n\n\t\text_ftr_ptr = RIO_GET_BLOCK_PTR(ftr_header);\n\t\tif (!ext_ftr_ptr)\n\t\t\tbreak;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(rio_mport_get_feature);\n\n \nstatic int\nrio_std_route_add_entry(struct rio_mport *mport, u16 destid, u8 hopcount,\n\t\t\tu16 table, u16 route_destid, u8 route_port)\n{\n\tif (table == RIO_GLOBAL_TABLE) {\n\t\trio_mport_write_config_32(mport, destid, hopcount,\n\t\t\t\tRIO_STD_RTE_CONF_DESTID_SEL_CSR,\n\t\t\t\t(u32)route_destid);\n\t\trio_mport_write_config_32(mport, destid, hopcount,\n\t\t\t\tRIO_STD_RTE_CONF_PORT_SEL_CSR,\n\t\t\t\t(u32)route_port);\n\t}\n\n\tudelay(10);\n\treturn 0;\n}\n\n \nstatic int\nrio_std_route_get_entry(struct rio_mport *mport, u16 destid, u8 hopcount,\n\t\t\tu16 table, u16 route_destid, u8 *route_port)\n{\n\tu32 result;\n\n\tif (table == RIO_GLOBAL_TABLE) {\n\t\trio_mport_write_config_32(mport, destid, hopcount,\n\t\t\t\tRIO_STD_RTE_CONF_DESTID_SEL_CSR, route_destid);\n\t\trio_mport_read_config_32(mport, destid, hopcount,\n\t\t\t\tRIO_STD_RTE_CONF_PORT_SEL_CSR, &result);\n\n\t\t*route_port = (u8)result;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int\nrio_std_route_clr_table(struct rio_mport *mport, u16 destid, u8 hopcount,\n\t\t\tu16 table)\n{\n\tu32 max_destid = 0xff;\n\tu32 i, pef, id_inc = 1, ext_cfg = 0;\n\tu32 port_sel = RIO_INVALID_ROUTE;\n\n\tif (table == RIO_GLOBAL_TABLE) {\n\t\trio_mport_read_config_32(mport, destid, hopcount,\n\t\t\t\t\t RIO_PEF_CAR, &pef);\n\n\t\tif (mport->sys_size) {\n\t\t\trio_mport_read_config_32(mport, destid, hopcount,\n\t\t\t\t\t\t RIO_SWITCH_RT_LIMIT,\n\t\t\t\t\t\t &max_destid);\n\t\t\tmax_destid &= RIO_RT_MAX_DESTID;\n\t\t}\n\n\t\tif (pef & RIO_PEF_EXT_RT) {\n\t\t\text_cfg = 0x80000000;\n\t\t\tid_inc = 4;\n\t\t\tport_sel = (RIO_INVALID_ROUTE << 24) |\n\t\t\t\t   (RIO_INVALID_ROUTE << 16) |\n\t\t\t\t   (RIO_INVALID_ROUTE << 8) |\n\t\t\t\t   RIO_INVALID_ROUTE;\n\t\t}\n\n\t\tfor (i = 0; i <= max_destid;) {\n\t\t\trio_mport_write_config_32(mport, destid, hopcount,\n\t\t\t\t\tRIO_STD_RTE_CONF_DESTID_SEL_CSR,\n\t\t\t\t\text_cfg | i);\n\t\t\trio_mport_write_config_32(mport, destid, hopcount,\n\t\t\t\t\tRIO_STD_RTE_CONF_PORT_SEL_CSR,\n\t\t\t\t\tport_sel);\n\t\t\ti += id_inc;\n\t\t}\n\t}\n\n\tudelay(10);\n\treturn 0;\n}\n\n \nint rio_lock_device(struct rio_mport *port, u16 destid,\n\t\t    u8 hopcount, int wait_ms)\n{\n\tu32 result;\n\tint tcnt = 0;\n\n\t \n\trio_mport_write_config_32(port, destid, hopcount,\n\t\t\t\t  RIO_HOST_DID_LOCK_CSR, port->host_deviceid);\n\trio_mport_read_config_32(port, destid, hopcount,\n\t\t\t\t RIO_HOST_DID_LOCK_CSR, &result);\n\n\twhile (result != port->host_deviceid) {\n\t\tif (wait_ms != 0 && tcnt == wait_ms) {\n\t\t\tpr_debug(\"RIO: timeout when locking device %x:%x\\n\",\n\t\t\t\tdestid, hopcount);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tmdelay(1);\n\t\ttcnt++;\n\t\t \n\t\trio_mport_write_config_32(port, destid,\n\t\t\thopcount,\n\t\t\tRIO_HOST_DID_LOCK_CSR,\n\t\t\tport->host_deviceid);\n\t\trio_mport_read_config_32(port, destid,\n\t\t\thopcount,\n\t\t\tRIO_HOST_DID_LOCK_CSR, &result);\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(rio_lock_device);\n\n \nint rio_unlock_device(struct rio_mport *port, u16 destid, u8 hopcount)\n{\n\tu32 result;\n\n\t \n\trio_mport_write_config_32(port, destid,\n\t\t\t\t  hopcount,\n\t\t\t\t  RIO_HOST_DID_LOCK_CSR,\n\t\t\t\t  port->host_deviceid);\n\trio_mport_read_config_32(port, destid, hopcount,\n\t\tRIO_HOST_DID_LOCK_CSR, &result);\n\tif ((result & 0xffff) != 0xffff) {\n\t\tpr_debug(\"RIO: badness when releasing device lock %x:%x\\n\",\n\t\t\t destid, hopcount);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(rio_unlock_device);\n\n \nint rio_route_add_entry(struct rio_dev *rdev,\n\t\t\tu16 table, u16 route_destid, u8 route_port, int lock)\n{\n\tint rc = -EINVAL;\n\tstruct rio_switch_ops *ops = rdev->rswitch->ops;\n\n\tif (lock) {\n\t\trc = rio_lock_device(rdev->net->hport, rdev->destid,\n\t\t\t\t     rdev->hopcount, 1000);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\tspin_lock(&rdev->rswitch->lock);\n\n\tif (!ops || !ops->add_entry) {\n\t\trc = rio_std_route_add_entry(rdev->net->hport, rdev->destid,\n\t\t\t\t\t     rdev->hopcount, table,\n\t\t\t\t\t     route_destid, route_port);\n\t} else if (try_module_get(ops->owner)) {\n\t\trc = ops->add_entry(rdev->net->hport, rdev->destid,\n\t\t\t\t    rdev->hopcount, table, route_destid,\n\t\t\t\t    route_port);\n\t\tmodule_put(ops->owner);\n\t}\n\n\tspin_unlock(&rdev->rswitch->lock);\n\n\tif (lock)\n\t\trio_unlock_device(rdev->net->hport, rdev->destid,\n\t\t\t\t  rdev->hopcount);\n\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(rio_route_add_entry);\n\n \nint rio_route_get_entry(struct rio_dev *rdev, u16 table,\n\t\t\tu16 route_destid, u8 *route_port, int lock)\n{\n\tint rc = -EINVAL;\n\tstruct rio_switch_ops *ops = rdev->rswitch->ops;\n\n\tif (lock) {\n\t\trc = rio_lock_device(rdev->net->hport, rdev->destid,\n\t\t\t\t     rdev->hopcount, 1000);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\tspin_lock(&rdev->rswitch->lock);\n\n\tif (!ops || !ops->get_entry) {\n\t\trc = rio_std_route_get_entry(rdev->net->hport, rdev->destid,\n\t\t\t\t\t     rdev->hopcount, table,\n\t\t\t\t\t     route_destid, route_port);\n\t} else if (try_module_get(ops->owner)) {\n\t\trc = ops->get_entry(rdev->net->hport, rdev->destid,\n\t\t\t\t    rdev->hopcount, table, route_destid,\n\t\t\t\t    route_port);\n\t\tmodule_put(ops->owner);\n\t}\n\n\tspin_unlock(&rdev->rswitch->lock);\n\n\tif (lock)\n\t\trio_unlock_device(rdev->net->hport, rdev->destid,\n\t\t\t\t  rdev->hopcount);\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(rio_route_get_entry);\n\n \nint rio_route_clr_table(struct rio_dev *rdev, u16 table, int lock)\n{\n\tint rc = -EINVAL;\n\tstruct rio_switch_ops *ops = rdev->rswitch->ops;\n\n\tif (lock) {\n\t\trc = rio_lock_device(rdev->net->hport, rdev->destid,\n\t\t\t\t     rdev->hopcount, 1000);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\tspin_lock(&rdev->rswitch->lock);\n\n\tif (!ops || !ops->clr_table) {\n\t\trc = rio_std_route_clr_table(rdev->net->hport, rdev->destid,\n\t\t\t\t\t     rdev->hopcount, table);\n\t} else if (try_module_get(ops->owner)) {\n\t\trc = ops->clr_table(rdev->net->hport, rdev->destid,\n\t\t\t\t    rdev->hopcount, table);\n\n\t\tmodule_put(ops->owner);\n\t}\n\n\tspin_unlock(&rdev->rswitch->lock);\n\n\tif (lock)\n\t\trio_unlock_device(rdev->net->hport, rdev->destid,\n\t\t\t\t  rdev->hopcount);\n\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(rio_route_clr_table);\n\n#ifdef CONFIG_RAPIDIO_DMA_ENGINE\n\nstatic bool rio_chan_filter(struct dma_chan *chan, void *arg)\n{\n\tstruct rio_mport *mport = arg;\n\n\t \n\treturn mport == container_of(chan->device, struct rio_mport, dma);\n}\n\n \nstruct dma_chan *rio_request_mport_dma(struct rio_mport *mport)\n{\n\tdma_cap_mask_t mask;\n\n\tdma_cap_zero(mask);\n\tdma_cap_set(DMA_SLAVE, mask);\n\treturn dma_request_channel(mask, rio_chan_filter, mport);\n}\nEXPORT_SYMBOL_GPL(rio_request_mport_dma);\n\n \nstruct dma_chan *rio_request_dma(struct rio_dev *rdev)\n{\n\treturn rio_request_mport_dma(rdev->net->hport);\n}\nEXPORT_SYMBOL_GPL(rio_request_dma);\n\n \nvoid rio_release_dma(struct dma_chan *dchan)\n{\n\tdma_release_channel(dchan);\n}\nEXPORT_SYMBOL_GPL(rio_release_dma);\n\n \nstruct dma_async_tx_descriptor *rio_dma_prep_xfer(struct dma_chan *dchan,\n\tu16 destid, struct rio_dma_data *data,\n\tenum dma_transfer_direction direction, unsigned long flags)\n{\n\tstruct rio_dma_ext rio_ext;\n\n\tif (!dchan->device->device_prep_slave_sg) {\n\t\tpr_err(\"%s: prep_rio_sg == NULL\\n\", __func__);\n\t\treturn NULL;\n\t}\n\n\trio_ext.destid = destid;\n\trio_ext.rio_addr_u = data->rio_addr_u;\n\trio_ext.rio_addr = data->rio_addr;\n\trio_ext.wr_type = data->wr_type;\n\n\treturn dmaengine_prep_rio_sg(dchan, data->sg, data->sg_len,\n\t\t\t\t     direction, flags, &rio_ext);\n}\nEXPORT_SYMBOL_GPL(rio_dma_prep_xfer);\n\n \nstruct dma_async_tx_descriptor *rio_dma_prep_slave_sg(struct rio_dev *rdev,\n\tstruct dma_chan *dchan, struct rio_dma_data *data,\n\tenum dma_transfer_direction direction, unsigned long flags)\n{\n\treturn rio_dma_prep_xfer(dchan,\trdev->destid, data, direction, flags);\n}\nEXPORT_SYMBOL_GPL(rio_dma_prep_slave_sg);\n\n#endif  \n\n \nstruct rio_mport *rio_find_mport(int mport_id)\n{\n\tstruct rio_mport *port;\n\n\tmutex_lock(&rio_mport_list_lock);\n\tlist_for_each_entry(port, &rio_mports, node) {\n\t\tif (port->id == mport_id)\n\t\t\tgoto found;\n\t}\n\tport = NULL;\nfound:\n\tmutex_unlock(&rio_mport_list_lock);\n\n\treturn port;\n}\n\n \nint rio_register_scan(int mport_id, struct rio_scan *scan_ops)\n{\n\tstruct rio_mport *port;\n\tstruct rio_scan_node *scan;\n\tint rc = 0;\n\n\tpr_debug(\"RIO: %s for mport_id=%d\\n\", __func__, mport_id);\n\n\tif ((mport_id != RIO_MPORT_ANY && mport_id >= RIO_MAX_MPORTS) ||\n\t    !scan_ops)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&rio_mport_list_lock);\n\n\t \n\tlist_for_each_entry(scan, &rio_scans, node) {\n\t\tif (scan->mport_id == mport_id) {\n\t\t\trc = -EBUSY;\n\t\t\tgoto err_out;\n\t\t}\n\t}\n\n\t \n\tscan = kzalloc(sizeof(*scan), GFP_KERNEL);\n\tif (!scan) {\n\t\trc = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\n\tscan->mport_id = mport_id;\n\tscan->ops = scan_ops;\n\n\t \n\tlist_for_each_entry(port, &rio_mports, node) {\n\t\tif (port->id == mport_id) {\n\t\t\tport->nscan = scan_ops;\n\t\t\tbreak;\n\t\t} else if (mport_id == RIO_MPORT_ANY && !port->nscan)\n\t\t\tport->nscan = scan_ops;\n\t}\n\n\tlist_add_tail(&scan->node, &rio_scans);\n\nerr_out:\n\tmutex_unlock(&rio_mport_list_lock);\n\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(rio_register_scan);\n\n \nint rio_unregister_scan(int mport_id, struct rio_scan *scan_ops)\n{\n\tstruct rio_mport *port;\n\tstruct rio_scan_node *scan;\n\n\tpr_debug(\"RIO: %s for mport_id=%d\\n\", __func__, mport_id);\n\n\tif (mport_id != RIO_MPORT_ANY && mport_id >= RIO_MAX_MPORTS)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&rio_mport_list_lock);\n\n\tlist_for_each_entry(port, &rio_mports, node)\n\t\tif (port->id == mport_id ||\n\t\t    (mport_id == RIO_MPORT_ANY && port->nscan == scan_ops))\n\t\t\tport->nscan = NULL;\n\n\tlist_for_each_entry(scan, &rio_scans, node) {\n\t\tif (scan->mport_id == mport_id) {\n\t\t\tlist_del(&scan->node);\n\t\t\tkfree(scan);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tmutex_unlock(&rio_mport_list_lock);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(rio_unregister_scan);\n\n \nint rio_mport_scan(int mport_id)\n{\n\tstruct rio_mport *port = NULL;\n\tint rc;\n\n\tmutex_lock(&rio_mport_list_lock);\n\tlist_for_each_entry(port, &rio_mports, node) {\n\t\tif (port->id == mport_id)\n\t\t\tgoto found;\n\t}\n\tmutex_unlock(&rio_mport_list_lock);\n\treturn -ENODEV;\nfound:\n\tif (!port->nscan) {\n\t\tmutex_unlock(&rio_mport_list_lock);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!try_module_get(port->nscan->owner)) {\n\t\tmutex_unlock(&rio_mport_list_lock);\n\t\treturn -ENODEV;\n\t}\n\n\tmutex_unlock(&rio_mport_list_lock);\n\n\tif (port->host_deviceid >= 0)\n\t\trc = port->nscan->enumerate(port, 0);\n\telse\n\t\trc = port->nscan->discover(port, RIO_SCAN_ENUM_NO_WAIT);\n\n\tmodule_put(port->nscan->owner);\n\treturn rc;\n}\n\nstatic struct workqueue_struct *rio_wq;\n\nstruct rio_disc_work {\n\tstruct work_struct\twork;\n\tstruct rio_mport\t*mport;\n};\n\nstatic void disc_work_handler(struct work_struct *_work)\n{\n\tstruct rio_disc_work *work;\n\n\twork = container_of(_work, struct rio_disc_work, work);\n\tpr_debug(\"RIO: discovery work for mport %d %s\\n\",\n\t\t work->mport->id, work->mport->name);\n\tif (try_module_get(work->mport->nscan->owner)) {\n\t\twork->mport->nscan->discover(work->mport, 0);\n\t\tmodule_put(work->mport->nscan->owner);\n\t}\n}\n\nint rio_init_mports(void)\n{\n\tstruct rio_mport *port;\n\tstruct rio_disc_work *work;\n\tint n = 0;\n\n\tif (!next_portid)\n\t\treturn -ENODEV;\n\n\t \n\tmutex_lock(&rio_mport_list_lock);\n\tlist_for_each_entry(port, &rio_mports, node) {\n\t\tif (port->host_deviceid >= 0) {\n\t\t\tif (port->nscan && try_module_get(port->nscan->owner)) {\n\t\t\t\tport->nscan->enumerate(port, 0);\n\t\t\t\tmodule_put(port->nscan->owner);\n\t\t\t}\n\t\t} else\n\t\t\tn++;\n\t}\n\tmutex_unlock(&rio_mport_list_lock);\n\n\tif (!n)\n\t\tgoto no_disc;\n\n\t \n\trio_wq = alloc_workqueue(\"riodisc\", 0, 0);\n\tif (!rio_wq) {\n\t\tpr_err(\"RIO: unable allocate rio_wq\\n\");\n\t\tgoto no_disc;\n\t}\n\n\twork = kcalloc(n, sizeof *work, GFP_KERNEL);\n\tif (!work) {\n\t\tdestroy_workqueue(rio_wq);\n\t\tgoto no_disc;\n\t}\n\n\tn = 0;\n\tmutex_lock(&rio_mport_list_lock);\n\tlist_for_each_entry(port, &rio_mports, node) {\n\t\tif (port->host_deviceid < 0 && port->nscan) {\n\t\t\twork[n].mport = port;\n\t\t\tINIT_WORK(&work[n].work, disc_work_handler);\n\t\t\tqueue_work(rio_wq, &work[n].work);\n\t\t\tn++;\n\t\t}\n\t}\n\n\tflush_workqueue(rio_wq);\n\tmutex_unlock(&rio_mport_list_lock);\n\tpr_debug(\"RIO: destroy discovery workqueue\\n\");\n\tdestroy_workqueue(rio_wq);\n\tkfree(work);\n\nno_disc:\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(rio_init_mports);\n\nstatic int rio_get_hdid(int index)\n{\n\tif (ids_num == 0 || ids_num <= index || index >= RIO_MAX_MPORTS)\n\t\treturn -1;\n\n\treturn hdid[index];\n}\n\nint rio_mport_initialize(struct rio_mport *mport)\n{\n\tif (next_portid >= RIO_MAX_MPORTS) {\n\t\tpr_err(\"RIO: reached specified max number of mports\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tatomic_set(&mport->state, RIO_DEVICE_INITIALIZING);\n\tmport->id = next_portid++;\n\tmport->host_deviceid = rio_get_hdid(mport->id);\n\tmport->nscan = NULL;\n\tmutex_init(&mport->lock);\n\tmport->pwe_refcnt = 0;\n\tINIT_LIST_HEAD(&mport->pwrites);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(rio_mport_initialize);\n\nint rio_register_mport(struct rio_mport *port)\n{\n\tstruct rio_scan_node *scan = NULL;\n\tint res = 0;\n\n\tmutex_lock(&rio_mport_list_lock);\n\n\t \n\tlist_for_each_entry(scan, &rio_scans, node) {\n\t\tif (port->id == scan->mport_id ||\n\t\t    scan->mport_id == RIO_MPORT_ANY) {\n\t\t\tport->nscan = scan->ops;\n\t\t\tif (port->id == scan->mport_id)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tlist_add_tail(&port->node, &rio_mports);\n\tmutex_unlock(&rio_mport_list_lock);\n\n\tdev_set_name(&port->dev, \"rapidio%d\", port->id);\n\tport->dev.class = &rio_mport_class;\n\tatomic_set(&port->state, RIO_DEVICE_RUNNING);\n\n\tres = device_register(&port->dev);\n\tif (res) {\n\t\tdev_err(&port->dev, \"RIO: mport%d registration failed ERR=%d\\n\",\n\t\t\tport->id, res);\n\t\tmutex_lock(&rio_mport_list_lock);\n\t\tlist_del(&port->node);\n\t\tmutex_unlock(&rio_mport_list_lock);\n\t\tput_device(&port->dev);\n\t} else {\n\t\tdev_dbg(&port->dev, \"RIO: registered mport%d\\n\", port->id);\n\t}\n\n\treturn res;\n}\nEXPORT_SYMBOL_GPL(rio_register_mport);\n\nstatic int rio_mport_cleanup_callback(struct device *dev, void *data)\n{\n\tstruct rio_dev *rdev = to_rio_dev(dev);\n\n\tif (dev->bus == &rio_bus_type)\n\t\trio_del_device(rdev, RIO_DEVICE_SHUTDOWN);\n\treturn 0;\n}\n\nstatic int rio_net_remove_children(struct rio_net *net)\n{\n\t \n\tdevice_for_each_child(&net->dev, NULL, rio_mport_cleanup_callback);\n\treturn 0;\n}\n\nint rio_unregister_mport(struct rio_mport *port)\n{\n\tpr_debug(\"RIO: %s %s id=%d\\n\", __func__, port->name, port->id);\n\n\t \n\tif (atomic_cmpxchg(&port->state,\n\t\t\t   RIO_DEVICE_RUNNING,\n\t\t\t   RIO_DEVICE_SHUTDOWN) != RIO_DEVICE_RUNNING) {\n\t\tpr_err(\"RIO: %s unexpected state transition for mport %s\\n\",\n\t\t\t__func__, port->name);\n\t}\n\n\tif (port->net && port->net->hport == port) {\n\t\trio_net_remove_children(port->net);\n\t\trio_free_net(port->net);\n\t}\n\n\t \n\tmutex_lock(&rio_mport_list_lock);\n\tlist_del(&port->node);\n\tmutex_unlock(&rio_mport_list_lock);\n\tdevice_unregister(&port->dev);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(rio_unregister_mport);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}