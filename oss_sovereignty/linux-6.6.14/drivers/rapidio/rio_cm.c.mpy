{
  "module_name": "rio_cm.c",
  "hash_id": "3a13e058674e10929ec54dd93a454b10863427e13b4fdb435939956032d30937",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rapidio/rio_cm.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/dma-mapping.h>\n#include <linux/delay.h>\n#include <linux/sched.h>\n#include <linux/rio.h>\n#include <linux/rio_drv.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/interrupt.h>\n#include <linux/cdev.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/reboot.h>\n#include <linux/bitops.h>\n#include <linux/printk.h>\n#include <linux/rio_cm_cdev.h>\n\n#define DRV_NAME        \"rio_cm\"\n#define DRV_VERSION     \"1.0.0\"\n#define DRV_AUTHOR      \"Alexandre Bounine <alexandre.bounine@idt.com>\"\n#define DRV_DESC        \"RapidIO Channelized Messaging Driver\"\n#define DEV_NAME\t\"rio_cm\"\n\n \nenum {\n\tDBG_NONE\t= 0,\n\tDBG_INIT\t= BIT(0),  \n\tDBG_EXIT\t= BIT(1),  \n\tDBG_MPORT\t= BIT(2),  \n\tDBG_RDEV\t= BIT(3),  \n\tDBG_CHOP\t= BIT(4),  \n\tDBG_WAIT\t= BIT(5),  \n\tDBG_TX\t\t= BIT(6),  \n\tDBG_TX_EVENT\t= BIT(7),  \n\tDBG_RX_DATA\t= BIT(8),  \n\tDBG_RX_CMD\t= BIT(9),  \n\tDBG_ALL\t\t= ~0,\n};\n\n#ifdef DEBUG\n#define riocm_debug(level, fmt, arg...) \\\n\tdo { \\\n\t\tif (DBG_##level & dbg_level) \\\n\t\t\tpr_debug(DRV_NAME \": %s \" fmt \"\\n\", \\\n\t\t\t\t__func__, ##arg); \\\n\t} while (0)\n#else\n#define riocm_debug(level, fmt, arg...) \\\n\t\tno_printk(KERN_DEBUG pr_fmt(DRV_NAME fmt \"\\n\"), ##arg)\n#endif\n\n#define riocm_warn(fmt, arg...) \\\n\tpr_warn(DRV_NAME \": %s WARNING \" fmt \"\\n\", __func__, ##arg)\n\n#define riocm_error(fmt, arg...) \\\n\tpr_err(DRV_NAME \": %s ERROR \" fmt \"\\n\", __func__, ##arg)\n\n\nstatic int cmbox = 1;\nmodule_param(cmbox, int, S_IRUGO);\nMODULE_PARM_DESC(cmbox, \"RapidIO Mailbox number (default 1)\");\n\nstatic int chstart = 256;\nmodule_param(chstart, int, S_IRUGO);\nMODULE_PARM_DESC(chstart,\n\t\t \"Start channel number for dynamic allocation (default 256)\");\n\n#ifdef DEBUG\nstatic u32 dbg_level = DBG_NONE;\nmodule_param(dbg_level, uint, S_IWUSR | S_IRUGO);\nMODULE_PARM_DESC(dbg_level, \"Debugging output level (default 0 = none)\");\n#endif\n\nMODULE_AUTHOR(DRV_AUTHOR);\nMODULE_DESCRIPTION(DRV_DESC);\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(DRV_VERSION);\n\n#define RIOCM_TX_RING_SIZE\t128\n#define RIOCM_RX_RING_SIZE\t128\n#define RIOCM_CONNECT_TO\t3  \n\n#define RIOCM_MAX_CHNUM\t\t0xffff  \n#define RIOCM_CHNUM_AUTO\t0\n#define RIOCM_MAX_EP_COUNT\t0x10000  \n\nenum rio_cm_state {\n\tRIO_CM_IDLE,\n\tRIO_CM_CONNECT,\n\tRIO_CM_CONNECTED,\n\tRIO_CM_DISCONNECT,\n\tRIO_CM_CHAN_BOUND,\n\tRIO_CM_LISTEN,\n\tRIO_CM_DESTROYING,\n};\n\nenum rio_cm_pkt_type {\n\tRIO_CM_SYS\t= 0xaa,\n\tRIO_CM_CHAN\t= 0x55,\n};\n\nenum rio_cm_chop {\n\tCM_CONN_REQ,\n\tCM_CONN_ACK,\n\tCM_CONN_CLOSE,\n\tCM_DATA_MSG,\n};\n\nstruct rio_ch_base_bhdr {\n\tu32 src_id;\n\tu32 dst_id;\n#define RIO_HDR_LETTER_MASK 0xffff0000\n#define RIO_HDR_MBOX_MASK   0x0000ffff\n\tu8  src_mbox;\n\tu8  dst_mbox;\n\tu8  type;\n} __attribute__((__packed__));\n\nstruct rio_ch_chan_hdr {\n\tstruct rio_ch_base_bhdr bhdr;\n\tu8 ch_op;\n\tu16 dst_ch;\n\tu16 src_ch;\n\tu16 msg_len;\n\tu16 rsrvd;\n} __attribute__((__packed__));\n\nstruct tx_req {\n\tstruct list_head node;\n\tstruct rio_dev   *rdev;\n\tvoid\t\t *buffer;\n\tsize_t\t\t len;\n};\n\nstruct cm_dev {\n\tstruct list_head\tlist;\n\tstruct rio_mport\t*mport;\n\tvoid\t\t\t*rx_buf[RIOCM_RX_RING_SIZE];\n\tint\t\t\trx_slots;\n\tstruct mutex\t\trx_lock;\n\n\tvoid\t\t\t*tx_buf[RIOCM_TX_RING_SIZE];\n\tint\t\t\ttx_slot;\n\tint\t\t\ttx_cnt;\n\tint\t\t\ttx_ack_slot;\n\tstruct list_head\ttx_reqs;\n\tspinlock_t\t\ttx_lock;\n\n\tstruct list_head\tpeers;\n\tu32\t\t\tnpeers;\n\tstruct workqueue_struct *rx_wq;\n\tstruct work_struct\trx_work;\n};\n\nstruct chan_rx_ring {\n\tvoid\t*buf[RIOCM_RX_RING_SIZE];\n\tint\thead;\n\tint\ttail;\n\tint\tcount;\n\n\t \n\tvoid\t*inuse[RIOCM_RX_RING_SIZE];\n\tint\tinuse_cnt;\n};\n\nstruct rio_channel {\n\tu16\t\t\tid;\t \n\tstruct kref\t\tref;\t \n\tstruct file\t\t*filp;\n\tstruct cm_dev\t\t*cmdev;\t \n\tstruct rio_dev\t\t*rdev;\t \n\tenum rio_cm_state\tstate;\n\tint\t\t\terror;\n\tspinlock_t\t\tlock;\n\tvoid\t\t\t*context;\n\tu32\t\t\tloc_destid;\t \n\tu32\t\t\trem_destid;\t \n\tu16\t\t\trem_channel;\t \n\tstruct list_head\taccept_queue;\n\tstruct list_head\tch_node;\n\tstruct completion\tcomp;\n\tstruct completion\tcomp_close;\n\tstruct chan_rx_ring\trx_ring;\n};\n\nstruct cm_peer {\n\tstruct list_head node;\n\tstruct rio_dev *rdev;\n};\n\nstruct rio_cm_work {\n\tstruct work_struct work;\n\tstruct cm_dev *cm;\n\tvoid *data;\n};\n\nstruct conn_req {\n\tstruct list_head node;\n\tu32 destid;\t \n\tu16 chan;\t \n\tstruct cm_dev *cmdev;\n};\n\n \nstruct channel_dev {\n\tstruct cdev\tcdev;\n\tstruct device\t*dev;\n};\n\nstatic struct rio_channel *riocm_ch_alloc(u16 ch_num);\nstatic void riocm_ch_free(struct kref *ref);\nstatic int riocm_post_send(struct cm_dev *cm, struct rio_dev *rdev,\n\t\t\t   void *buffer, size_t len);\nstatic int riocm_ch_close(struct rio_channel *ch);\n\nstatic DEFINE_SPINLOCK(idr_lock);\nstatic DEFINE_IDR(ch_idr);\n\nstatic LIST_HEAD(cm_dev_list);\nstatic DECLARE_RWSEM(rdev_sem);\n\nstatic struct class *dev_class;\nstatic unsigned int dev_major;\nstatic unsigned int dev_minor_base;\nstatic dev_t dev_number;\nstatic struct channel_dev riocm_cdev;\n\n#define is_msg_capable(src_ops, dst_ops)\t\t\t\\\n\t\t\t((src_ops & RIO_SRC_OPS_DATA_MSG) &&\t\\\n\t\t\t (dst_ops & RIO_DST_OPS_DATA_MSG))\n#define dev_cm_capable(dev) \\\n\tis_msg_capable(dev->src_ops, dev->dst_ops)\n\nstatic int riocm_cmp(struct rio_channel *ch, enum rio_cm_state cmp)\n{\n\tint ret;\n\n\tspin_lock_bh(&ch->lock);\n\tret = (ch->state == cmp);\n\tspin_unlock_bh(&ch->lock);\n\treturn ret;\n}\n\nstatic int riocm_cmp_exch(struct rio_channel *ch,\n\t\t\t   enum rio_cm_state cmp, enum rio_cm_state exch)\n{\n\tint ret;\n\n\tspin_lock_bh(&ch->lock);\n\tret = (ch->state == cmp);\n\tif (ret)\n\t\tch->state = exch;\n\tspin_unlock_bh(&ch->lock);\n\treturn ret;\n}\n\nstatic enum rio_cm_state riocm_exch(struct rio_channel *ch,\n\t\t\t\t    enum rio_cm_state exch)\n{\n\tenum rio_cm_state old;\n\n\tspin_lock_bh(&ch->lock);\n\told = ch->state;\n\tch->state = exch;\n\tspin_unlock_bh(&ch->lock);\n\treturn old;\n}\n\nstatic struct rio_channel *riocm_get_channel(u16 nr)\n{\n\tstruct rio_channel *ch;\n\n\tspin_lock_bh(&idr_lock);\n\tch = idr_find(&ch_idr, nr);\n\tif (ch)\n\t\tkref_get(&ch->ref);\n\tspin_unlock_bh(&idr_lock);\n\treturn ch;\n}\n\nstatic void riocm_put_channel(struct rio_channel *ch)\n{\n\tkref_put(&ch->ref, riocm_ch_free);\n}\n\nstatic void *riocm_rx_get_msg(struct cm_dev *cm)\n{\n\tvoid *msg;\n\tint i;\n\n\tmsg = rio_get_inb_message(cm->mport, cmbox);\n\tif (msg) {\n\t\tfor (i = 0; i < RIOCM_RX_RING_SIZE; i++) {\n\t\t\tif (cm->rx_buf[i] == msg) {\n\t\t\t\tcm->rx_buf[i] = NULL;\n\t\t\t\tcm->rx_slots++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (i == RIOCM_RX_RING_SIZE)\n\t\t\triocm_warn(\"no record for buffer 0x%p\", msg);\n\t}\n\n\treturn msg;\n}\n\n \nstatic void riocm_rx_fill(struct cm_dev *cm, int nent)\n{\n\tint i;\n\n\tif (cm->rx_slots == 0)\n\t\treturn;\n\n\tfor (i = 0; i < RIOCM_RX_RING_SIZE && cm->rx_slots && nent; i++) {\n\t\tif (cm->rx_buf[i] == NULL) {\n\t\t\tcm->rx_buf[i] = kmalloc(RIO_MAX_MSG_SIZE, GFP_KERNEL);\n\t\t\tif (cm->rx_buf[i] == NULL)\n\t\t\t\tbreak;\n\t\t\trio_add_inb_buffer(cm->mport, cmbox, cm->rx_buf[i]);\n\t\t\tcm->rx_slots--;\n\t\t\tnent--;\n\t\t}\n\t}\n}\n\n \nstatic void riocm_rx_free(struct cm_dev *cm)\n{\n\tint i;\n\n\tfor (i = 0; i < RIOCM_RX_RING_SIZE; i++) {\n\t\tif (cm->rx_buf[i] != NULL) {\n\t\t\tkfree(cm->rx_buf[i]);\n\t\t\tcm->rx_buf[i] = NULL;\n\t\t}\n\t}\n}\n\n \nstatic int riocm_req_handler(struct cm_dev *cm, void *req_data)\n{\n\tstruct rio_channel *ch;\n\tstruct conn_req *req;\n\tstruct rio_ch_chan_hdr *hh = req_data;\n\tu16 chnum;\n\n\tchnum = ntohs(hh->dst_ch);\n\n\tch = riocm_get_channel(chnum);\n\n\tif (!ch)\n\t\treturn -ENODEV;\n\n\tif (ch->state != RIO_CM_LISTEN) {\n\t\triocm_debug(RX_CMD, \"channel %d is not in listen state\", chnum);\n\t\triocm_put_channel(ch);\n\t\treturn -EINVAL;\n\t}\n\n\treq = kzalloc(sizeof(*req), GFP_KERNEL);\n\tif (!req) {\n\t\triocm_put_channel(ch);\n\t\treturn -ENOMEM;\n\t}\n\n\treq->destid = ntohl(hh->bhdr.src_id);\n\treq->chan = ntohs(hh->src_ch);\n\treq->cmdev = cm;\n\n\tspin_lock_bh(&ch->lock);\n\tlist_add_tail(&req->node, &ch->accept_queue);\n\tspin_unlock_bh(&ch->lock);\n\tcomplete(&ch->comp);\n\triocm_put_channel(ch);\n\n\treturn 0;\n}\n\n \nstatic int riocm_resp_handler(void *resp_data)\n{\n\tstruct rio_channel *ch;\n\tstruct rio_ch_chan_hdr *hh = resp_data;\n\tu16 chnum;\n\n\tchnum = ntohs(hh->dst_ch);\n\tch = riocm_get_channel(chnum);\n\tif (!ch)\n\t\treturn -ENODEV;\n\n\tif (ch->state != RIO_CM_CONNECT) {\n\t\triocm_put_channel(ch);\n\t\treturn -EINVAL;\n\t}\n\n\triocm_exch(ch, RIO_CM_CONNECTED);\n\tch->rem_channel = ntohs(hh->src_ch);\n\tcomplete(&ch->comp);\n\triocm_put_channel(ch);\n\n\treturn 0;\n}\n\n \nstatic int riocm_close_handler(void *data)\n{\n\tstruct rio_channel *ch;\n\tstruct rio_ch_chan_hdr *hh = data;\n\tint ret;\n\n\triocm_debug(RX_CMD, \"for ch=%d\", ntohs(hh->dst_ch));\n\n\tspin_lock_bh(&idr_lock);\n\tch = idr_find(&ch_idr, ntohs(hh->dst_ch));\n\tif (!ch) {\n\t\tspin_unlock_bh(&idr_lock);\n\t\treturn -ENODEV;\n\t}\n\tidr_remove(&ch_idr, ch->id);\n\tspin_unlock_bh(&idr_lock);\n\n\triocm_exch(ch, RIO_CM_DISCONNECT);\n\n\tret = riocm_ch_close(ch);\n\tif (ret)\n\t\triocm_debug(RX_CMD, \"riocm_ch_close() returned %d\", ret);\n\n\treturn 0;\n}\n\n \nstatic void rio_cm_handler(struct cm_dev *cm, void *data)\n{\n\tstruct rio_ch_chan_hdr *hdr;\n\n\tif (!rio_mport_is_running(cm->mport))\n\t\tgoto out;\n\n\thdr = data;\n\n\triocm_debug(RX_CMD, \"OP=%x for ch=%d from %d\",\n\t\t    hdr->ch_op, ntohs(hdr->dst_ch), ntohs(hdr->src_ch));\n\n\tswitch (hdr->ch_op) {\n\tcase CM_CONN_REQ:\n\t\triocm_req_handler(cm, data);\n\t\tbreak;\n\tcase CM_CONN_ACK:\n\t\triocm_resp_handler(data);\n\t\tbreak;\n\tcase CM_CONN_CLOSE:\n\t\triocm_close_handler(data);\n\t\tbreak;\n\tdefault:\n\t\triocm_error(\"Invalid packet header\");\n\t\tbreak;\n\t}\nout:\n\tkfree(data);\n}\n\n \nstatic int rio_rx_data_handler(struct cm_dev *cm, void *buf)\n{\n\tstruct rio_ch_chan_hdr *hdr;\n\tstruct rio_channel *ch;\n\n\thdr = buf;\n\n\triocm_debug(RX_DATA, \"for ch=%d\", ntohs(hdr->dst_ch));\n\n\tch = riocm_get_channel(ntohs(hdr->dst_ch));\n\tif (!ch) {\n\t\t \n\t\tkfree(buf);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tspin_lock(&ch->lock);\n\n\tif (ch->state != RIO_CM_CONNECTED) {\n\t\t \n\t\triocm_debug(RX_DATA, \"ch=%d is in wrong state=%d\",\n\t\t\t    ch->id, ch->state);\n\t\tspin_unlock(&ch->lock);\n\t\tkfree(buf);\n\t\triocm_put_channel(ch);\n\t\treturn -EIO;\n\t}\n\n\tif (ch->rx_ring.count == RIOCM_RX_RING_SIZE) {\n\t\t \n\t\triocm_debug(RX_DATA, \"ch=%d is full\", ch->id);\n\t\tspin_unlock(&ch->lock);\n\t\tkfree(buf);\n\t\triocm_put_channel(ch);\n\t\treturn -ENOMEM;\n\t}\n\n\tch->rx_ring.buf[ch->rx_ring.head] = buf;\n\tch->rx_ring.head++;\n\tch->rx_ring.count++;\n\tch->rx_ring.head %= RIOCM_RX_RING_SIZE;\n\n\tcomplete(&ch->comp);\n\n\tspin_unlock(&ch->lock);\n\triocm_put_channel(ch);\n\n\treturn 0;\n}\n\n \nstatic void rio_ibmsg_handler(struct work_struct *work)\n{\n\tstruct cm_dev *cm = container_of(work, struct cm_dev, rx_work);\n\tvoid *data;\n\tstruct rio_ch_chan_hdr *hdr;\n\n\tif (!rio_mport_is_running(cm->mport))\n\t\treturn;\n\n\twhile (1) {\n\t\tmutex_lock(&cm->rx_lock);\n\t\tdata = riocm_rx_get_msg(cm);\n\t\tif (data)\n\t\t\triocm_rx_fill(cm, 1);\n\t\tmutex_unlock(&cm->rx_lock);\n\n\t\tif (data == NULL)\n\t\t\tbreak;\n\n\t\thdr = data;\n\n\t\tif (hdr->bhdr.type != RIO_CM_CHAN) {\n\t\t\t \n\t\t\triocm_error(\"Unsupported TYPE code (0x%x). Msg dropped\",\n\t\t\t\t    hdr->bhdr.type);\n\t\t\tkfree(data);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (hdr->ch_op == CM_DATA_MSG)\n\t\t\trio_rx_data_handler(cm, data);\n\t\telse\n\t\t\trio_cm_handler(cm, data);\n\t}\n}\n\nstatic void riocm_inb_msg_event(struct rio_mport *mport, void *dev_id,\n\t\t\t\tint mbox, int slot)\n{\n\tstruct cm_dev *cm = dev_id;\n\n\tif (rio_mport_is_running(cm->mport) && !work_pending(&cm->rx_work))\n\t\tqueue_work(cm->rx_wq, &cm->rx_work);\n}\n\n \nstatic void rio_txcq_handler(struct cm_dev *cm, int slot)\n{\n\tint ack_slot;\n\n\t \n\triocm_debug(TX_EVENT, \"for mport_%d slot %d tx_cnt %d\",\n\t\t    cm->mport->id, slot, cm->tx_cnt);\n\n\tspin_lock(&cm->tx_lock);\n\tack_slot = cm->tx_ack_slot;\n\n\tif (ack_slot == slot)\n\t\triocm_debug(TX_EVENT, \"slot == ack_slot\");\n\n\twhile (cm->tx_cnt && ((ack_slot != slot) ||\n\t       (cm->tx_cnt == RIOCM_TX_RING_SIZE))) {\n\n\t\tcm->tx_buf[ack_slot] = NULL;\n\t\t++ack_slot;\n\t\tack_slot &= (RIOCM_TX_RING_SIZE - 1);\n\t\tcm->tx_cnt--;\n\t}\n\n\tif (cm->tx_cnt < 0 || cm->tx_cnt > RIOCM_TX_RING_SIZE)\n\t\triocm_error(\"tx_cnt %d out of sync\", cm->tx_cnt);\n\n\tWARN_ON((cm->tx_cnt < 0) || (cm->tx_cnt > RIOCM_TX_RING_SIZE));\n\n\tcm->tx_ack_slot = ack_slot;\n\n\t \n\tif (!list_empty(&cm->tx_reqs) && (cm->tx_cnt < RIOCM_TX_RING_SIZE)) {\n\t\tstruct tx_req *req, *_req;\n\t\tint rc;\n\n\t\tlist_for_each_entry_safe(req, _req, &cm->tx_reqs, node) {\n\t\t\tlist_del(&req->node);\n\t\t\tcm->tx_buf[cm->tx_slot] = req->buffer;\n\t\t\trc = rio_add_outb_message(cm->mport, req->rdev, cmbox,\n\t\t\t\t\t\t  req->buffer, req->len);\n\t\t\tkfree(req->buffer);\n\t\t\tkfree(req);\n\n\t\t\t++cm->tx_cnt;\n\t\t\t++cm->tx_slot;\n\t\t\tcm->tx_slot &= (RIOCM_TX_RING_SIZE - 1);\n\t\t\tif (cm->tx_cnt == RIOCM_TX_RING_SIZE)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock(&cm->tx_lock);\n}\n\nstatic void riocm_outb_msg_event(struct rio_mport *mport, void *dev_id,\n\t\t\t\t int mbox, int slot)\n{\n\tstruct cm_dev *cm = dev_id;\n\n\tif (cm && rio_mport_is_running(cm->mport))\n\t\trio_txcq_handler(cm, slot);\n}\n\nstatic int riocm_queue_req(struct cm_dev *cm, struct rio_dev *rdev,\n\t\t\t   void *buffer, size_t len)\n{\n\tunsigned long flags;\n\tstruct tx_req *treq;\n\n\ttreq = kzalloc(sizeof(*treq), GFP_KERNEL);\n\tif (treq == NULL)\n\t\treturn -ENOMEM;\n\n\ttreq->rdev = rdev;\n\ttreq->buffer = buffer;\n\ttreq->len = len;\n\n\tspin_lock_irqsave(&cm->tx_lock, flags);\n\tlist_add_tail(&treq->node, &cm->tx_reqs);\n\tspin_unlock_irqrestore(&cm->tx_lock, flags);\n\treturn 0;\n}\n\n \nstatic int riocm_post_send(struct cm_dev *cm, struct rio_dev *rdev,\n\t\t\t   void *buffer, size_t len)\n{\n\tint rc;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&cm->tx_lock, flags);\n\n\tif (cm->mport == NULL) {\n\t\trc = -ENODEV;\n\t\tgoto err_out;\n\t}\n\n\tif (cm->tx_cnt == RIOCM_TX_RING_SIZE) {\n\t\triocm_debug(TX, \"Tx Queue is full\");\n\t\trc = -EBUSY;\n\t\tgoto err_out;\n\t}\n\n\tcm->tx_buf[cm->tx_slot] = buffer;\n\trc = rio_add_outb_message(cm->mport, rdev, cmbox, buffer, len);\n\n\triocm_debug(TX, \"Add buf@%p destid=%x tx_slot=%d tx_cnt=%d\",\n\t\t buffer, rdev->destid, cm->tx_slot, cm->tx_cnt);\n\n\t++cm->tx_cnt;\n\t++cm->tx_slot;\n\tcm->tx_slot &= (RIOCM_TX_RING_SIZE - 1);\n\nerr_out:\n\tspin_unlock_irqrestore(&cm->tx_lock, flags);\n\treturn rc;\n}\n\n \nstatic int riocm_ch_send(u16 ch_id, void *buf, int len)\n{\n\tstruct rio_channel *ch;\n\tstruct rio_ch_chan_hdr *hdr;\n\tint ret;\n\n\tif (buf == NULL || ch_id == 0 || len == 0 || len > RIO_MAX_MSG_SIZE)\n\t\treturn -EINVAL;\n\n\tch = riocm_get_channel(ch_id);\n\tif (!ch) {\n\t\triocm_error(\"%s(%d) ch_%d not found\", current->comm,\n\t\t\t    task_pid_nr(current), ch_id);\n\t\treturn -ENODEV;\n\t}\n\n\tif (!riocm_cmp(ch, RIO_CM_CONNECTED)) {\n\t\tret = -EAGAIN;\n\t\tgoto err_out;\n\t}\n\n\t \n\thdr = buf;\n\n\thdr->bhdr.src_id = htonl(ch->loc_destid);\n\thdr->bhdr.dst_id = htonl(ch->rem_destid);\n\thdr->bhdr.src_mbox = cmbox;\n\thdr->bhdr.dst_mbox = cmbox;\n\thdr->bhdr.type = RIO_CM_CHAN;\n\thdr->ch_op = CM_DATA_MSG;\n\thdr->dst_ch = htons(ch->rem_channel);\n\thdr->src_ch = htons(ch->id);\n\thdr->msg_len = htons((u16)len);\n\n\t \n\n\tret = riocm_post_send(ch->cmdev, ch->rdev, buf, len);\n\tif (ret)\n\t\triocm_debug(TX, \"ch %d send_err=%d\", ch->id, ret);\nerr_out:\n\triocm_put_channel(ch);\n\treturn ret;\n}\n\nstatic int riocm_ch_free_rxbuf(struct rio_channel *ch, void *buf)\n{\n\tint i, ret = -EINVAL;\n\n\tspin_lock_bh(&ch->lock);\n\n\tfor (i = 0; i < RIOCM_RX_RING_SIZE; i++) {\n\t\tif (ch->rx_ring.inuse[i] == buf) {\n\t\t\tch->rx_ring.inuse[i] = NULL;\n\t\t\tch->rx_ring.inuse_cnt--;\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock_bh(&ch->lock);\n\n\tif (!ret)\n\t\tkfree(buf);\n\n\treturn ret;\n}\n\n \nstatic int riocm_ch_receive(struct rio_channel *ch, void **buf, long timeout)\n{\n\tvoid *rxmsg = NULL;\n\tint i, ret = 0;\n\tlong wret;\n\n\tif (!riocm_cmp(ch, RIO_CM_CONNECTED)) {\n\t\tret = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\tif (ch->rx_ring.inuse_cnt == RIOCM_RX_RING_SIZE) {\n\t\t \n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\twret = wait_for_completion_interruptible_timeout(&ch->comp, timeout);\n\n\triocm_debug(WAIT, \"wait on %d returned %ld\", ch->id, wret);\n\n\tif (!wret)\n\t\tret = -ETIME;\n\telse if (wret == -ERESTARTSYS)\n\t\tret = -EINTR;\n\telse\n\t\tret = riocm_cmp(ch, RIO_CM_CONNECTED) ? 0 : -ECONNRESET;\n\n\tif (ret)\n\t\tgoto out;\n\n\tspin_lock_bh(&ch->lock);\n\n\trxmsg = ch->rx_ring.buf[ch->rx_ring.tail];\n\tch->rx_ring.buf[ch->rx_ring.tail] = NULL;\n\tch->rx_ring.count--;\n\tch->rx_ring.tail++;\n\tch->rx_ring.tail %= RIOCM_RX_RING_SIZE;\n\tret = -ENOMEM;\n\n\tfor (i = 0; i < RIOCM_RX_RING_SIZE; i++) {\n\t\tif (ch->rx_ring.inuse[i] == NULL) {\n\t\t\tch->rx_ring.inuse[i] = rxmsg;\n\t\t\tch->rx_ring.inuse_cnt++;\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ret) {\n\t\t \n\t\tkfree(rxmsg);\n\t\trxmsg = NULL;\n\t}\n\n\tspin_unlock_bh(&ch->lock);\nout:\n\t*buf = rxmsg;\n\treturn ret;\n}\n\n \nstatic int riocm_ch_connect(u16 loc_ch, struct cm_dev *cm,\n\t\t\t    struct cm_peer *peer, u16 rem_ch)\n{\n\tstruct rio_channel *ch = NULL;\n\tstruct rio_ch_chan_hdr *hdr;\n\tint ret;\n\tlong wret;\n\n\tch = riocm_get_channel(loc_ch);\n\tif (!ch)\n\t\treturn -ENODEV;\n\n\tif (!riocm_cmp_exch(ch, RIO_CM_IDLE, RIO_CM_CONNECT)) {\n\t\tret = -EINVAL;\n\t\tgoto conn_done;\n\t}\n\n\tch->cmdev = cm;\n\tch->rdev = peer->rdev;\n\tch->context = NULL;\n\tch->loc_destid = cm->mport->host_deviceid;\n\tch->rem_channel = rem_ch;\n\n\t \n\n\thdr = kzalloc(sizeof(*hdr), GFP_KERNEL);\n\tif (hdr == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto conn_done;\n\t}\n\n\thdr->bhdr.src_id = htonl(ch->loc_destid);\n\thdr->bhdr.dst_id = htonl(peer->rdev->destid);\n\thdr->bhdr.src_mbox = cmbox;\n\thdr->bhdr.dst_mbox = cmbox;\n\thdr->bhdr.type = RIO_CM_CHAN;\n\thdr->ch_op = CM_CONN_REQ;\n\thdr->dst_ch = htons(rem_ch);\n\thdr->src_ch = htons(loc_ch);\n\n\t \n\tret = riocm_post_send(cm, peer->rdev, hdr, sizeof(*hdr));\n\n\tif (ret != -EBUSY) {\n\t\tkfree(hdr);\n\t} else {\n\t\tret = riocm_queue_req(cm, peer->rdev, hdr, sizeof(*hdr));\n\t\tif (ret)\n\t\t\tkfree(hdr);\n\t}\n\n\tif (ret) {\n\t\triocm_cmp_exch(ch, RIO_CM_CONNECT, RIO_CM_IDLE);\n\t\tgoto conn_done;\n\t}\n\n\t \n\twret = wait_for_completion_interruptible_timeout(&ch->comp,\n\t\t\t\t\t\t\t RIOCM_CONNECT_TO * HZ);\n\triocm_debug(WAIT, \"wait on %d returns %ld\", ch->id, wret);\n\n\tif (!wret)\n\t\tret = -ETIME;\n\telse if (wret == -ERESTARTSYS)\n\t\tret = -EINTR;\n\telse\n\t\tret = riocm_cmp(ch, RIO_CM_CONNECTED) ? 0 : -1;\n\nconn_done:\n\triocm_put_channel(ch);\n\treturn ret;\n}\n\nstatic int riocm_send_ack(struct rio_channel *ch)\n{\n\tstruct rio_ch_chan_hdr *hdr;\n\tint ret;\n\n\thdr = kzalloc(sizeof(*hdr), GFP_KERNEL);\n\tif (hdr == NULL)\n\t\treturn -ENOMEM;\n\n\thdr->bhdr.src_id = htonl(ch->loc_destid);\n\thdr->bhdr.dst_id = htonl(ch->rem_destid);\n\thdr->dst_ch = htons(ch->rem_channel);\n\thdr->src_ch = htons(ch->id);\n\thdr->bhdr.src_mbox = cmbox;\n\thdr->bhdr.dst_mbox = cmbox;\n\thdr->bhdr.type = RIO_CM_CHAN;\n\thdr->ch_op = CM_CONN_ACK;\n\n\t \n\tret = riocm_post_send(ch->cmdev, ch->rdev, hdr, sizeof(*hdr));\n\n\tif (ret == -EBUSY && !riocm_queue_req(ch->cmdev,\n\t\t\t\t\t      ch->rdev, hdr, sizeof(*hdr)))\n\t\treturn 0;\n\tkfree(hdr);\n\n\tif (ret)\n\t\triocm_error(\"send ACK to ch_%d on %s failed (ret=%d)\",\n\t\t\t    ch->id, rio_name(ch->rdev), ret);\n\treturn ret;\n}\n\n \nstatic struct rio_channel *riocm_ch_accept(u16 ch_id, u16 *new_ch_id,\n\t\t\t\t\t   long timeout)\n{\n\tstruct rio_channel *ch;\n\tstruct rio_channel *new_ch;\n\tstruct conn_req *req;\n\tstruct cm_peer *peer;\n\tint found = 0;\n\tint err = 0;\n\tlong wret;\n\n\tch = riocm_get_channel(ch_id);\n\tif (!ch)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (!riocm_cmp(ch, RIO_CM_LISTEN)) {\n\t\terr = -EINVAL;\n\t\tgoto err_put;\n\t}\n\n\t \n\tif (!timeout) {\n\t\tif (!try_wait_for_completion(&ch->comp)) {\n\t\t\terr = -EAGAIN;\n\t\t\tgoto err_put;\n\t\t}\n\t} else {\n\t\triocm_debug(WAIT, \"on %d\", ch->id);\n\n\t\twret = wait_for_completion_interruptible_timeout(&ch->comp,\n\t\t\t\t\t\t\t\t timeout);\n\t\tif (!wret) {\n\t\t\terr = -ETIME;\n\t\t\tgoto err_put;\n\t\t} else if (wret == -ERESTARTSYS) {\n\t\t\terr = -EINTR;\n\t\t\tgoto err_put;\n\t\t}\n\t}\n\n\tspin_lock_bh(&ch->lock);\n\n\tif (ch->state != RIO_CM_LISTEN) {\n\t\terr = -ECANCELED;\n\t} else if (list_empty(&ch->accept_queue)) {\n\t\triocm_debug(WAIT, \"on %d accept_queue is empty on completion\",\n\t\t\t    ch->id);\n\t\terr = -EIO;\n\t}\n\n\tspin_unlock_bh(&ch->lock);\n\n\tif (err) {\n\t\triocm_debug(WAIT, \"on %d returns %d\", ch->id, err);\n\t\tgoto err_put;\n\t}\n\n\t \n\tnew_ch = riocm_ch_alloc(RIOCM_CHNUM_AUTO);\n\n\tif (IS_ERR(new_ch)) {\n\t\triocm_error(\"failed to get channel for new req (%ld)\",\n\t\t\tPTR_ERR(new_ch));\n\t\terr = -ENOMEM;\n\t\tgoto err_put;\n\t}\n\n\tspin_lock_bh(&ch->lock);\n\n\treq = list_first_entry(&ch->accept_queue, struct conn_req, node);\n\tlist_del(&req->node);\n\tnew_ch->cmdev = ch->cmdev;\n\tnew_ch->loc_destid = ch->loc_destid;\n\tnew_ch->rem_destid = req->destid;\n\tnew_ch->rem_channel = req->chan;\n\n\tspin_unlock_bh(&ch->lock);\n\triocm_put_channel(ch);\n\tch = NULL;\n\tkfree(req);\n\n\tdown_read(&rdev_sem);\n\t \n\tlist_for_each_entry(peer, &new_ch->cmdev->peers, node) {\n\t\tif (peer->rdev->destid == new_ch->rem_destid) {\n\t\t\triocm_debug(RX_CMD, \"found matching device(%s)\",\n\t\t\t\t    rio_name(peer->rdev));\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tup_read(&rdev_sem);\n\n\tif (!found) {\n\t\t \n\t\terr = -ENODEV;\n\t\tgoto err_put_new_ch;\n\t}\n\n\tnew_ch->rdev = peer->rdev;\n\tnew_ch->state = RIO_CM_CONNECTED;\n\tspin_lock_init(&new_ch->lock);\n\n\t \n\triocm_send_ack(new_ch);\n\n\t*new_ch_id = new_ch->id;\n\treturn new_ch;\n\nerr_put_new_ch:\n\tspin_lock_bh(&idr_lock);\n\tidr_remove(&ch_idr, new_ch->id);\n\tspin_unlock_bh(&idr_lock);\n\triocm_put_channel(new_ch);\n\nerr_put:\n\tif (ch)\n\t\triocm_put_channel(ch);\n\t*new_ch_id = 0;\n\treturn ERR_PTR(err);\n}\n\n \nstatic int riocm_ch_listen(u16 ch_id)\n{\n\tstruct rio_channel *ch = NULL;\n\tint ret = 0;\n\n\triocm_debug(CHOP, \"(ch_%d)\", ch_id);\n\n\tch = riocm_get_channel(ch_id);\n\tif (!ch)\n\t\treturn -EINVAL;\n\tif (!riocm_cmp_exch(ch, RIO_CM_CHAN_BOUND, RIO_CM_LISTEN))\n\t\tret = -EINVAL;\n\triocm_put_channel(ch);\n\treturn ret;\n}\n\n \nstatic int riocm_ch_bind(u16 ch_id, u8 mport_id, void *context)\n{\n\tstruct rio_channel *ch = NULL;\n\tstruct cm_dev *cm;\n\tint rc = -ENODEV;\n\n\triocm_debug(CHOP, \"ch_%d to mport_%d\", ch_id, mport_id);\n\n\t \n\tdown_read(&rdev_sem);\n\tlist_for_each_entry(cm, &cm_dev_list, list) {\n\t\tif ((cm->mport->id == mport_id) &&\n\t\t     rio_mport_is_running(cm->mport)) {\n\t\t\trc = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (rc)\n\t\tgoto exit;\n\n\tch = riocm_get_channel(ch_id);\n\tif (!ch) {\n\t\trc = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\tspin_lock_bh(&ch->lock);\n\tif (ch->state != RIO_CM_IDLE) {\n\t\tspin_unlock_bh(&ch->lock);\n\t\trc = -EINVAL;\n\t\tgoto err_put;\n\t}\n\n\tch->cmdev = cm;\n\tch->loc_destid = cm->mport->host_deviceid;\n\tch->context = context;\n\tch->state = RIO_CM_CHAN_BOUND;\n\tspin_unlock_bh(&ch->lock);\nerr_put:\n\triocm_put_channel(ch);\nexit:\n\tup_read(&rdev_sem);\n\treturn rc;\n}\n\n \nstatic struct rio_channel *riocm_ch_alloc(u16 ch_num)\n{\n\tint id;\n\tint start, end;\n\tstruct rio_channel *ch;\n\n\tch = kzalloc(sizeof(*ch), GFP_KERNEL);\n\tif (!ch)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (ch_num) {\n\t\t \n\t\tstart = ch_num;\n\t\tend = ch_num + 1;\n\t} else {\n\t\t \n\t\tstart = chstart;\n\t\tend = RIOCM_MAX_CHNUM + 1;\n\t}\n\n\tidr_preload(GFP_KERNEL);\n\tspin_lock_bh(&idr_lock);\n\tid = idr_alloc_cyclic(&ch_idr, ch, start, end, GFP_NOWAIT);\n\tspin_unlock_bh(&idr_lock);\n\tidr_preload_end();\n\n\tif (id < 0) {\n\t\tkfree(ch);\n\t\treturn ERR_PTR(id == -ENOSPC ? -EBUSY : id);\n\t}\n\n\tch->id = (u16)id;\n\tch->state = RIO_CM_IDLE;\n\tspin_lock_init(&ch->lock);\n\tINIT_LIST_HEAD(&ch->accept_queue);\n\tINIT_LIST_HEAD(&ch->ch_node);\n\tinit_completion(&ch->comp);\n\tinit_completion(&ch->comp_close);\n\tkref_init(&ch->ref);\n\tch->rx_ring.head = 0;\n\tch->rx_ring.tail = 0;\n\tch->rx_ring.count = 0;\n\tch->rx_ring.inuse_cnt = 0;\n\n\treturn ch;\n}\n\n \nstatic struct rio_channel *riocm_ch_create(u16 *ch_num)\n{\n\tstruct rio_channel *ch = NULL;\n\n\tch = riocm_ch_alloc(*ch_num);\n\n\tif (IS_ERR(ch))\n\t\triocm_debug(CHOP, \"Failed to allocate channel %d (err=%ld)\",\n\t\t\t    *ch_num, PTR_ERR(ch));\n\telse\n\t\t*ch_num = ch->id;\n\n\treturn ch;\n}\n\n \nstatic void riocm_ch_free(struct kref *ref)\n{\n\tstruct rio_channel *ch = container_of(ref, struct rio_channel, ref);\n\tint i;\n\n\triocm_debug(CHOP, \"(ch_%d)\", ch->id);\n\n\tif (ch->rx_ring.inuse_cnt) {\n\t\tfor (i = 0;\n\t\t     i < RIOCM_RX_RING_SIZE && ch->rx_ring.inuse_cnt; i++) {\n\t\t\tif (ch->rx_ring.inuse[i] != NULL) {\n\t\t\t\tkfree(ch->rx_ring.inuse[i]);\n\t\t\t\tch->rx_ring.inuse_cnt--;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ch->rx_ring.count)\n\t\tfor (i = 0; i < RIOCM_RX_RING_SIZE && ch->rx_ring.count; i++) {\n\t\t\tif (ch->rx_ring.buf[i] != NULL) {\n\t\t\t\tkfree(ch->rx_ring.buf[i]);\n\t\t\t\tch->rx_ring.count--;\n\t\t\t}\n\t\t}\n\n\tcomplete(&ch->comp_close);\n}\n\nstatic int riocm_send_close(struct rio_channel *ch)\n{\n\tstruct rio_ch_chan_hdr *hdr;\n\tint ret;\n\n\t \n\n\thdr = kzalloc(sizeof(*hdr), GFP_KERNEL);\n\tif (hdr == NULL)\n\t\treturn -ENOMEM;\n\n\thdr->bhdr.src_id = htonl(ch->loc_destid);\n\thdr->bhdr.dst_id = htonl(ch->rem_destid);\n\thdr->bhdr.src_mbox = cmbox;\n\thdr->bhdr.dst_mbox = cmbox;\n\thdr->bhdr.type = RIO_CM_CHAN;\n\thdr->ch_op = CM_CONN_CLOSE;\n\thdr->dst_ch = htons(ch->rem_channel);\n\thdr->src_ch = htons(ch->id);\n\n\t \n\tret = riocm_post_send(ch->cmdev, ch->rdev, hdr, sizeof(*hdr));\n\n\tif (ret == -EBUSY && !riocm_queue_req(ch->cmdev, ch->rdev,\n\t\t\t\t\t      hdr, sizeof(*hdr)))\n\t\treturn 0;\n\tkfree(hdr);\n\n\tif (ret)\n\t\triocm_error(\"ch(%d) send CLOSE failed (ret=%d)\", ch->id, ret);\n\n\treturn ret;\n}\n\n \nstatic int riocm_ch_close(struct rio_channel *ch)\n{\n\tunsigned long tmo = msecs_to_jiffies(3000);\n\tenum rio_cm_state state;\n\tlong wret;\n\tint ret = 0;\n\n\triocm_debug(CHOP, \"ch_%d by %s(%d)\",\n\t\t    ch->id, current->comm, task_pid_nr(current));\n\n\tstate = riocm_exch(ch, RIO_CM_DESTROYING);\n\tif (state == RIO_CM_CONNECTED)\n\t\triocm_send_close(ch);\n\n\tcomplete_all(&ch->comp);\n\n\triocm_put_channel(ch);\n\twret = wait_for_completion_interruptible_timeout(&ch->comp_close, tmo);\n\n\triocm_debug(WAIT, \"wait on %d returns %ld\", ch->id, wret);\n\n\tif (wret == 0) {\n\t\t \n\t\triocm_debug(CHOP, \"%s(%d) timed out waiting for ch %d\",\n\t\t       current->comm, task_pid_nr(current), ch->id);\n\t\tret = -ETIMEDOUT;\n\t} else if (wret == -ERESTARTSYS) {\n\t\t \n\t\triocm_debug(CHOP, \"%s(%d) wait for ch %d was interrupted\",\n\t\t\tcurrent->comm, task_pid_nr(current), ch->id);\n\t\tret = -EINTR;\n\t}\n\n\tif (!ret) {\n\t\triocm_debug(CHOP, \"ch_%d resources released\", ch->id);\n\t\tkfree(ch);\n\t} else {\n\t\triocm_debug(CHOP, \"failed to release ch_%d resources\", ch->id);\n\t}\n\n\treturn ret;\n}\n\n \nstatic int riocm_cdev_open(struct inode *inode, struct file *filp)\n{\n\triocm_debug(INIT, \"by %s(%d) filp=%p \",\n\t\t    current->comm, task_pid_nr(current), filp);\n\n\tif (list_empty(&cm_dev_list))\n\t\treturn -ENODEV;\n\n\treturn 0;\n}\n\n \nstatic int riocm_cdev_release(struct inode *inode, struct file *filp)\n{\n\tstruct rio_channel *ch, *_c;\n\tunsigned int i;\n\tLIST_HEAD(list);\n\n\triocm_debug(EXIT, \"by %s(%d) filp=%p\",\n\t\t    current->comm, task_pid_nr(current), filp);\n\n\t \n\tspin_lock_bh(&idr_lock);\n\tidr_for_each_entry(&ch_idr, ch, i) {\n\t\tif (ch && ch->filp == filp) {\n\t\t\triocm_debug(EXIT, \"ch_%d not released by %s(%d)\",\n\t\t\t\t    ch->id, current->comm,\n\t\t\t\t    task_pid_nr(current));\n\t\t\tidr_remove(&ch_idr, ch->id);\n\t\t\tlist_add(&ch->ch_node, &list);\n\t\t}\n\t}\n\tspin_unlock_bh(&idr_lock);\n\n\tif (!list_empty(&list)) {\n\t\tlist_for_each_entry_safe(ch, _c, &list, ch_node) {\n\t\t\tlist_del(&ch->ch_node);\n\t\t\triocm_ch_close(ch);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int cm_ep_get_list_size(void __user *arg)\n{\n\tu32 __user *p = arg;\n\tu32 mport_id;\n\tu32 count = 0;\n\tstruct cm_dev *cm;\n\n\tif (get_user(mport_id, p))\n\t\treturn -EFAULT;\n\tif (mport_id >= RIO_MAX_MPORTS)\n\t\treturn -EINVAL;\n\n\t \n\tdown_read(&rdev_sem);\n\tlist_for_each_entry(cm, &cm_dev_list, list) {\n\t\tif (cm->mport->id == mport_id) {\n\t\t\tcount = cm->npeers;\n\t\t\tup_read(&rdev_sem);\n\t\t\tif (copy_to_user(arg, &count, sizeof(u32)))\n\t\t\t\treturn -EFAULT;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tup_read(&rdev_sem);\n\n\treturn -ENODEV;\n}\n\n \nstatic int cm_ep_get_list(void __user *arg)\n{\n\tstruct cm_dev *cm;\n\tstruct cm_peer *peer;\n\tu32 info[2];\n\tvoid *buf;\n\tu32 nent;\n\tu32 *entry_ptr;\n\tu32 i = 0;\n\tint ret = 0;\n\n\tif (copy_from_user(&info, arg, sizeof(info)))\n\t\treturn -EFAULT;\n\n\tif (info[1] >= RIO_MAX_MPORTS || info[0] > RIOCM_MAX_EP_COUNT)\n\t\treturn -EINVAL;\n\n\t \n\tdown_read(&rdev_sem);\n\tlist_for_each_entry(cm, &cm_dev_list, list)\n\t\tif (cm->mport->id == (u8)info[1])\n\t\t\tgoto found;\n\n\tup_read(&rdev_sem);\n\treturn -ENODEV;\n\nfound:\n\tnent = min(info[0], cm->npeers);\n\tbuf = kcalloc(nent + 2, sizeof(u32), GFP_KERNEL);\n\tif (!buf) {\n\t\tup_read(&rdev_sem);\n\t\treturn -ENOMEM;\n\t}\n\n\tentry_ptr = (u32 *)((uintptr_t)buf + 2*sizeof(u32));\n\n\tlist_for_each_entry(peer, &cm->peers, node) {\n\t\t*entry_ptr = (u32)peer->rdev->destid;\n\t\tentry_ptr++;\n\t\tif (++i == nent)\n\t\t\tbreak;\n\t}\n\tup_read(&rdev_sem);\n\n\t((u32 *)buf)[0] = i;  \n\t((u32 *)buf)[1] = info[1];  \n\tif (copy_to_user(arg, buf, sizeof(u32) * (info[0] + 2)))\n\t\tret = -EFAULT;\n\n\tkfree(buf);\n\treturn ret;\n}\n\n \nstatic int cm_mport_get_list(void __user *arg)\n{\n\tint ret = 0;\n\tu32 entries;\n\tvoid *buf;\n\tstruct cm_dev *cm;\n\tu32 *entry_ptr;\n\tint count = 0;\n\n\tif (copy_from_user(&entries, arg, sizeof(entries)))\n\t\treturn -EFAULT;\n\tif (entries == 0 || entries > RIO_MAX_MPORTS)\n\t\treturn -EINVAL;\n\tbuf = kcalloc(entries + 1, sizeof(u32), GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\t \n\tentry_ptr = (u32 *)((uintptr_t)buf + sizeof(u32));\n\tdown_read(&rdev_sem);\n\tlist_for_each_entry(cm, &cm_dev_list, list) {\n\t\tif (count++ < entries) {\n\t\t\t*entry_ptr = (cm->mport->id << 16) |\n\t\t\t\t      cm->mport->host_deviceid;\n\t\t\tentry_ptr++;\n\t\t}\n\t}\n\tup_read(&rdev_sem);\n\n\t*((u32 *)buf) = count;  \n\tif (copy_to_user(arg, buf, sizeof(u32) * (count + 1)))\n\t\tret = -EFAULT;\n\n\tkfree(buf);\n\treturn ret;\n}\n\n \nstatic int cm_chan_create(struct file *filp, void __user *arg)\n{\n\tu16 __user *p = arg;\n\tu16 ch_num;\n\tstruct rio_channel *ch;\n\n\tif (get_user(ch_num, p))\n\t\treturn -EFAULT;\n\n\triocm_debug(CHOP, \"ch_%d requested by %s(%d)\",\n\t\t    ch_num, current->comm, task_pid_nr(current));\n\tch = riocm_ch_create(&ch_num);\n\tif (IS_ERR(ch))\n\t\treturn PTR_ERR(ch);\n\n\tch->filp = filp;\n\triocm_debug(CHOP, \"ch_%d created by %s(%d)\",\n\t\t    ch_num, current->comm, task_pid_nr(current));\n\treturn put_user(ch_num, p);\n}\n\n \nstatic int cm_chan_close(struct file *filp, void __user *arg)\n{\n\tu16 __user *p = arg;\n\tu16 ch_num;\n\tstruct rio_channel *ch;\n\n\tif (get_user(ch_num, p))\n\t\treturn -EFAULT;\n\n\triocm_debug(CHOP, \"ch_%d by %s(%d)\",\n\t\t    ch_num, current->comm, task_pid_nr(current));\n\n\tspin_lock_bh(&idr_lock);\n\tch = idr_find(&ch_idr, ch_num);\n\tif (!ch) {\n\t\tspin_unlock_bh(&idr_lock);\n\t\treturn 0;\n\t}\n\tif (ch->filp != filp) {\n\t\tspin_unlock_bh(&idr_lock);\n\t\treturn -EINVAL;\n\t}\n\tidr_remove(&ch_idr, ch->id);\n\tspin_unlock_bh(&idr_lock);\n\n\treturn riocm_ch_close(ch);\n}\n\n \nstatic int cm_chan_bind(void __user *arg)\n{\n\tstruct rio_cm_channel chan;\n\n\tif (copy_from_user(&chan, arg, sizeof(chan)))\n\t\treturn -EFAULT;\n\tif (chan.mport_id >= RIO_MAX_MPORTS)\n\t\treturn -EINVAL;\n\n\treturn riocm_ch_bind(chan.id, chan.mport_id, NULL);\n}\n\n \nstatic int cm_chan_listen(void __user *arg)\n{\n\tu16 __user *p = arg;\n\tu16 ch_num;\n\n\tif (get_user(ch_num, p))\n\t\treturn -EFAULT;\n\n\treturn riocm_ch_listen(ch_num);\n}\n\n \nstatic int cm_chan_accept(struct file *filp, void __user *arg)\n{\n\tstruct rio_cm_accept param;\n\tlong accept_to;\n\tstruct rio_channel *ch;\n\n\tif (copy_from_user(&param, arg, sizeof(param)))\n\t\treturn -EFAULT;\n\n\triocm_debug(CHOP, \"on ch_%d by %s(%d)\",\n\t\t    param.ch_num, current->comm, task_pid_nr(current));\n\n\taccept_to = param.wait_to ?\n\t\t\tmsecs_to_jiffies(param.wait_to) : 0;\n\n\tch = riocm_ch_accept(param.ch_num, &param.ch_num, accept_to);\n\tif (IS_ERR(ch))\n\t\treturn PTR_ERR(ch);\n\tch->filp = filp;\n\n\triocm_debug(CHOP, \"new ch_%d for %s(%d)\",\n\t\t    ch->id, current->comm, task_pid_nr(current));\n\n\tif (copy_to_user(arg, &param, sizeof(param)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\n \nstatic int cm_chan_connect(void __user *arg)\n{\n\tstruct rio_cm_channel chan;\n\tstruct cm_dev *cm;\n\tstruct cm_peer *peer;\n\tint ret = -ENODEV;\n\n\tif (copy_from_user(&chan, arg, sizeof(chan)))\n\t\treturn -EFAULT;\n\tif (chan.mport_id >= RIO_MAX_MPORTS)\n\t\treturn -EINVAL;\n\n\tdown_read(&rdev_sem);\n\n\t \n\tlist_for_each_entry(cm, &cm_dev_list, list) {\n\t\tif (cm->mport->id == chan.mport_id) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ret)\n\t\tgoto err_out;\n\n\tif (chan.remote_destid >= RIO_ANY_DESTID(cm->mport->sys_size)) {\n\t\tret = -EINVAL;\n\t\tgoto err_out;\n\t}\n\n\t \n\tret = -ENODEV;\n\n\tlist_for_each_entry(peer, &cm->peers, node) {\n\t\tif (peer->rdev->destid == chan.remote_destid) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ret)\n\t\tgoto err_out;\n\n\tup_read(&rdev_sem);\n\n\treturn riocm_ch_connect(chan.id, cm, peer, chan.remote_channel);\nerr_out:\n\tup_read(&rdev_sem);\n\treturn ret;\n}\n\n \nstatic int cm_chan_msg_send(void __user *arg)\n{\n\tstruct rio_cm_msg msg;\n\tvoid *buf;\n\tint ret;\n\n\tif (copy_from_user(&msg, arg, sizeof(msg)))\n\t\treturn -EFAULT;\n\tif (msg.size > RIO_MAX_MSG_SIZE)\n\t\treturn -EINVAL;\n\n\tbuf = memdup_user((void __user *)(uintptr_t)msg.msg, msg.size);\n\tif (IS_ERR(buf))\n\t\treturn PTR_ERR(buf);\n\n\tret = riocm_ch_send(msg.ch_num, buf, msg.size);\n\n\tkfree(buf);\n\treturn ret;\n}\n\n \nstatic int cm_chan_msg_rcv(void __user *arg)\n{\n\tstruct rio_cm_msg msg;\n\tstruct rio_channel *ch;\n\tvoid *buf;\n\tlong rxto;\n\tint ret = 0, msg_size;\n\n\tif (copy_from_user(&msg, arg, sizeof(msg)))\n\t\treturn -EFAULT;\n\n\tif (msg.ch_num == 0 || msg.size == 0)\n\t\treturn -EINVAL;\n\n\tch = riocm_get_channel(msg.ch_num);\n\tif (!ch)\n\t\treturn -ENODEV;\n\n\trxto = msg.rxto ? msecs_to_jiffies(msg.rxto) : MAX_SCHEDULE_TIMEOUT;\n\n\tret = riocm_ch_receive(ch, &buf, rxto);\n\tif (ret)\n\t\tgoto out;\n\n\tmsg_size = min(msg.size, (u16)(RIO_MAX_MSG_SIZE));\n\n\tif (copy_to_user((void __user *)(uintptr_t)msg.msg, buf, msg_size))\n\t\tret = -EFAULT;\n\n\triocm_ch_free_rxbuf(ch, buf);\nout:\n\triocm_put_channel(ch);\n\treturn ret;\n}\n\n \nstatic long\nriocm_cdev_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n\tswitch (cmd) {\n\tcase RIO_CM_EP_GET_LIST_SIZE:\n\t\treturn cm_ep_get_list_size((void __user *)arg);\n\tcase RIO_CM_EP_GET_LIST:\n\t\treturn cm_ep_get_list((void __user *)arg);\n\tcase RIO_CM_CHAN_CREATE:\n\t\treturn cm_chan_create(filp, (void __user *)arg);\n\tcase RIO_CM_CHAN_CLOSE:\n\t\treturn cm_chan_close(filp, (void __user *)arg);\n\tcase RIO_CM_CHAN_BIND:\n\t\treturn cm_chan_bind((void __user *)arg);\n\tcase RIO_CM_CHAN_LISTEN:\n\t\treturn cm_chan_listen((void __user *)arg);\n\tcase RIO_CM_CHAN_ACCEPT:\n\t\treturn cm_chan_accept(filp, (void __user *)arg);\n\tcase RIO_CM_CHAN_CONNECT:\n\t\treturn cm_chan_connect((void __user *)arg);\n\tcase RIO_CM_CHAN_SEND:\n\t\treturn cm_chan_msg_send((void __user *)arg);\n\tcase RIO_CM_CHAN_RECEIVE:\n\t\treturn cm_chan_msg_rcv((void __user *)arg);\n\tcase RIO_CM_MPORT_GET_LIST:\n\t\treturn cm_mport_get_list((void __user *)arg);\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic const struct file_operations riocm_cdev_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= riocm_cdev_open,\n\t.release\t= riocm_cdev_release,\n\t.unlocked_ioctl = riocm_cdev_ioctl,\n};\n\n \nstatic int riocm_add_dev(struct device *dev, struct subsys_interface *sif)\n{\n\tstruct cm_peer *peer;\n\tstruct rio_dev *rdev = to_rio_dev(dev);\n\tstruct cm_dev *cm;\n\n\t \n\tif (!dev_cm_capable(rdev))\n\t\treturn 0;\n\n\triocm_debug(RDEV, \"(%s)\", rio_name(rdev));\n\n\tpeer = kmalloc(sizeof(*peer), GFP_KERNEL);\n\tif (!peer)\n\t\treturn -ENOMEM;\n\n\t \n\tdown_write(&rdev_sem);\n\tlist_for_each_entry(cm, &cm_dev_list, list) {\n\t\tif (cm->mport == rdev->net->hport)\n\t\t\tgoto found;\n\t}\n\n\tup_write(&rdev_sem);\n\tkfree(peer);\n\treturn -ENODEV;\n\nfound:\n\tpeer->rdev = rdev;\n\tlist_add_tail(&peer->node, &cm->peers);\n\tcm->npeers++;\n\n\tup_write(&rdev_sem);\n\treturn 0;\n}\n\n \nstatic void riocm_remove_dev(struct device *dev, struct subsys_interface *sif)\n{\n\tstruct rio_dev *rdev = to_rio_dev(dev);\n\tstruct cm_dev *cm;\n\tstruct cm_peer *peer;\n\tstruct rio_channel *ch, *_c;\n\tunsigned int i;\n\tbool found = false;\n\tLIST_HEAD(list);\n\n\t \n\tif (!dev_cm_capable(rdev))\n\t\treturn;\n\n\triocm_debug(RDEV, \"(%s)\", rio_name(rdev));\n\n\t \n\tdown_write(&rdev_sem);\n\tlist_for_each_entry(cm, &cm_dev_list, list) {\n\t\tif (cm->mport == rdev->net->hport) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!found) {\n\t\tup_write(&rdev_sem);\n\t\treturn;\n\t}\n\n\t \n\tfound = false;\n\tlist_for_each_entry(peer, &cm->peers, node) {\n\t\tif (peer->rdev == rdev) {\n\t\t\triocm_debug(RDEV, \"removing peer %s\", rio_name(rdev));\n\t\t\tfound = true;\n\t\t\tlist_del(&peer->node);\n\t\t\tcm->npeers--;\n\t\t\tkfree(peer);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tup_write(&rdev_sem);\n\n\tif (!found)\n\t\treturn;\n\n\t \n\n\tspin_lock_bh(&idr_lock);\n\tidr_for_each_entry(&ch_idr, ch, i) {\n\t\tif (ch && ch->rdev == rdev) {\n\t\t\tif (atomic_read(&rdev->state) != RIO_DEVICE_SHUTDOWN)\n\t\t\t\triocm_exch(ch, RIO_CM_DISCONNECT);\n\t\t\tidr_remove(&ch_idr, ch->id);\n\t\t\tlist_add(&ch->ch_node, &list);\n\t\t}\n\t}\n\tspin_unlock_bh(&idr_lock);\n\n\tif (!list_empty(&list)) {\n\t\tlist_for_each_entry_safe(ch, _c, &list, ch_node) {\n\t\t\tlist_del(&ch->ch_node);\n\t\t\triocm_ch_close(ch);\n\t\t}\n\t}\n}\n\n \nstatic int riocm_cdev_add(dev_t devno)\n{\n\tint ret;\n\n\tcdev_init(&riocm_cdev.cdev, &riocm_cdev_fops);\n\triocm_cdev.cdev.owner = THIS_MODULE;\n\tret = cdev_add(&riocm_cdev.cdev, devno, 1);\n\tif (ret < 0) {\n\t\triocm_error(\"Cannot register a device with error %d\", ret);\n\t\treturn ret;\n\t}\n\n\triocm_cdev.dev = device_create(dev_class, NULL, devno, NULL, DEV_NAME);\n\tif (IS_ERR(riocm_cdev.dev)) {\n\t\tcdev_del(&riocm_cdev.cdev);\n\t\treturn PTR_ERR(riocm_cdev.dev);\n\t}\n\n\triocm_debug(MPORT, \"Added %s cdev(%d:%d)\",\n\t\t    DEV_NAME, MAJOR(devno), MINOR(devno));\n\n\treturn 0;\n}\n\n \nstatic int riocm_add_mport(struct device *dev)\n{\n\tint rc;\n\tint i;\n\tstruct cm_dev *cm;\n\tstruct rio_mport *mport = to_rio_mport(dev);\n\n\triocm_debug(MPORT, \"add mport %s\", mport->name);\n\n\tcm = kzalloc(sizeof(*cm), GFP_KERNEL);\n\tif (!cm)\n\t\treturn -ENOMEM;\n\n\tcm->mport = mport;\n\n\trc = rio_request_outb_mbox(mport, cm, cmbox,\n\t\t\t\t   RIOCM_TX_RING_SIZE, riocm_outb_msg_event);\n\tif (rc) {\n\t\triocm_error(\"failed to allocate OBMBOX_%d on %s\",\n\t\t\t    cmbox, mport->name);\n\t\tkfree(cm);\n\t\treturn -ENODEV;\n\t}\n\n\trc = rio_request_inb_mbox(mport, cm, cmbox,\n\t\t\t\t  RIOCM_RX_RING_SIZE, riocm_inb_msg_event);\n\tif (rc) {\n\t\triocm_error(\"failed to allocate IBMBOX_%d on %s\",\n\t\t\t    cmbox, mport->name);\n\t\trio_release_outb_mbox(mport, cmbox);\n\t\tkfree(cm);\n\t\treturn -ENODEV;\n\t}\n\n\tcm->rx_wq = create_workqueue(DRV_NAME \"/rxq\");\n\tif (!cm->rx_wq) {\n\t\trio_release_inb_mbox(mport, cmbox);\n\t\trio_release_outb_mbox(mport, cmbox);\n\t\tkfree(cm);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tfor (i = 0; i < RIOCM_RX_RING_SIZE; i++)\n\t\tcm->rx_buf[i] = NULL;\n\n\tcm->rx_slots = RIOCM_RX_RING_SIZE;\n\tmutex_init(&cm->rx_lock);\n\triocm_rx_fill(cm, RIOCM_RX_RING_SIZE);\n\tINIT_WORK(&cm->rx_work, rio_ibmsg_handler);\n\n\tcm->tx_slot = 0;\n\tcm->tx_cnt = 0;\n\tcm->tx_ack_slot = 0;\n\tspin_lock_init(&cm->tx_lock);\n\n\tINIT_LIST_HEAD(&cm->peers);\n\tcm->npeers = 0;\n\tINIT_LIST_HEAD(&cm->tx_reqs);\n\n\tdown_write(&rdev_sem);\n\tlist_add_tail(&cm->list, &cm_dev_list);\n\tup_write(&rdev_sem);\n\n\treturn 0;\n}\n\n \nstatic void riocm_remove_mport(struct device *dev)\n{\n\tstruct rio_mport *mport = to_rio_mport(dev);\n\tstruct cm_dev *cm;\n\tstruct cm_peer *peer, *temp;\n\tstruct rio_channel *ch, *_c;\n\tunsigned int i;\n\tbool found = false;\n\tLIST_HEAD(list);\n\n\triocm_debug(MPORT, \"%s\", mport->name);\n\n\t \n\tdown_write(&rdev_sem);\n\tlist_for_each_entry(cm, &cm_dev_list, list) {\n\t\tif (cm->mport == mport) {\n\t\t\tlist_del(&cm->list);\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tup_write(&rdev_sem);\n\tif (!found)\n\t\treturn;\n\n\tflush_workqueue(cm->rx_wq);\n\tdestroy_workqueue(cm->rx_wq);\n\n\t \n\tspin_lock_bh(&idr_lock);\n\tidr_for_each_entry(&ch_idr, ch, i) {\n\t\tif (ch->cmdev == cm) {\n\t\t\triocm_debug(RDEV, \"%s drop ch_%d\",\n\t\t\t\t    mport->name, ch->id);\n\t\t\tidr_remove(&ch_idr, ch->id);\n\t\t\tlist_add(&ch->ch_node, &list);\n\t\t}\n\t}\n\tspin_unlock_bh(&idr_lock);\n\n\tif (!list_empty(&list)) {\n\t\tlist_for_each_entry_safe(ch, _c, &list, ch_node) {\n\t\t\tlist_del(&ch->ch_node);\n\t\t\triocm_ch_close(ch);\n\t\t}\n\t}\n\n\trio_release_inb_mbox(mport, cmbox);\n\trio_release_outb_mbox(mport, cmbox);\n\n\t \n\tif (!list_empty(&cm->peers))\n\t\triocm_debug(RDEV, \"ATTN: peer list not empty\");\n\tlist_for_each_entry_safe(peer, temp, &cm->peers, node) {\n\t\triocm_debug(RDEV, \"removing peer %s\", rio_name(peer->rdev));\n\t\tlist_del(&peer->node);\n\t\tkfree(peer);\n\t}\n\n\triocm_rx_free(cm);\n\tkfree(cm);\n\triocm_debug(MPORT, \"%s done\", mport->name);\n}\n\nstatic int rio_cm_shutdown(struct notifier_block *nb, unsigned long code,\n\tvoid *unused)\n{\n\tstruct rio_channel *ch;\n\tunsigned int i;\n\tLIST_HEAD(list);\n\n\triocm_debug(EXIT, \".\");\n\n\t \n\tspin_lock_bh(&idr_lock);\n\tidr_for_each_entry(&ch_idr, ch, i) {\n\t\tif (ch->state == RIO_CM_CONNECTED) {\n\t\t\triocm_debug(EXIT, \"close ch %d\", ch->id);\n\t\t\tidr_remove(&ch_idr, ch->id);\n\t\t\tlist_add(&ch->ch_node, &list);\n\t\t}\n\t}\n\tspin_unlock_bh(&idr_lock);\n\n\tlist_for_each_entry(ch, &list, ch_node)\n\t\triocm_send_close(ch);\n\n\treturn NOTIFY_DONE;\n}\n\n \nstatic struct subsys_interface riocm_interface = {\n\t.name\t\t= \"rio_cm\",\n\t.subsys\t\t= &rio_bus_type,\n\t.add_dev\t= riocm_add_dev,\n\t.remove_dev\t= riocm_remove_dev,\n};\n\n \nstatic struct class_interface rio_mport_interface __refdata = {\n\t.class = &rio_mport_class,\n\t.add_dev = riocm_add_mport,\n\t.remove_dev = riocm_remove_mport,\n};\n\nstatic struct notifier_block rio_cm_notifier = {\n\t.notifier_call = rio_cm_shutdown,\n};\n\nstatic int __init riocm_init(void)\n{\n\tint ret;\n\n\t \n\tdev_class = class_create(DRV_NAME);\n\tif (IS_ERR(dev_class)) {\n\t\triocm_error(\"Cannot create \" DRV_NAME \" class\");\n\t\treturn PTR_ERR(dev_class);\n\t}\n\n\tret = alloc_chrdev_region(&dev_number, 0, 1, DRV_NAME);\n\tif (ret) {\n\t\tclass_destroy(dev_class);\n\t\treturn ret;\n\t}\n\n\tdev_major = MAJOR(dev_number);\n\tdev_minor_base = MINOR(dev_number);\n\triocm_debug(INIT, \"Registered class with %d major\", dev_major);\n\n\t \n\tret = class_interface_register(&rio_mport_interface);\n\tif (ret) {\n\t\triocm_error(\"class_interface_register error: %d\", ret);\n\t\tgoto err_reg;\n\t}\n\n\t \n\tret = subsys_interface_register(&riocm_interface);\n\tif (ret) {\n\t\triocm_error(\"subsys_interface_register error: %d\", ret);\n\t\tgoto err_cl;\n\t}\n\n\tret = register_reboot_notifier(&rio_cm_notifier);\n\tif (ret) {\n\t\triocm_error(\"failed to register reboot notifier (err=%d)\", ret);\n\t\tgoto err_sif;\n\t}\n\n\tret = riocm_cdev_add(dev_number);\n\tif (ret) {\n\t\tunregister_reboot_notifier(&rio_cm_notifier);\n\t\tret = -ENODEV;\n\t\tgoto err_sif;\n\t}\n\n\treturn 0;\nerr_sif:\n\tsubsys_interface_unregister(&riocm_interface);\nerr_cl:\n\tclass_interface_unregister(&rio_mport_interface);\nerr_reg:\n\tunregister_chrdev_region(dev_number, 1);\n\tclass_destroy(dev_class);\n\treturn ret;\n}\n\nstatic void __exit riocm_exit(void)\n{\n\triocm_debug(EXIT, \"enter\");\n\tunregister_reboot_notifier(&rio_cm_notifier);\n\tsubsys_interface_unregister(&riocm_interface);\n\tclass_interface_unregister(&rio_mport_interface);\n\tidr_destroy(&ch_idr);\n\n\tdevice_unregister(riocm_cdev.dev);\n\tcdev_del(&(riocm_cdev.cdev));\n\n\tclass_destroy(dev_class);\n\tunregister_chrdev_region(dev_number, 1);\n}\n\nlate_initcall(riocm_init);\nmodule_exit(riocm_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}