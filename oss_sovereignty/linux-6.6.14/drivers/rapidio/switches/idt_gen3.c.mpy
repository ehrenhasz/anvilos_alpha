{
  "module_name": "idt_gen3.c",
  "hash_id": "6c16e4303382251822715f42825a017525b50e6aa25a83c7ac15b3b82351ab8a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rapidio/switches/idt_gen3.c",
  "human_readable_source": "\n \n\n#include <linux/stat.h>\n#include <linux/module.h>\n#include <linux/rio.h>\n#include <linux/rio_drv.h>\n#include <linux/rio_ids.h>\n#include <linux/delay.h>\n\n#include <asm/page.h>\n#include \"../rio.h\"\n\n#define RIO_EM_PW_STAT\t\t0x40020\n#define RIO_PW_CTL\t\t0x40204\n#define RIO_PW_CTL_PW_TMR\t\t0xffffff00\n#define RIO_PW_ROUTE\t\t0x40208\n\n#define RIO_EM_DEV_INT_EN\t0x40030\n\n#define RIO_PLM_SPx_IMP_SPEC_CTL(x)\t(0x10100 + (x)*0x100)\n#define RIO_PLM_SPx_IMP_SPEC_CTL_SOFT_RST\t0x02000000\n\n#define RIO_PLM_SPx_PW_EN(x)\t(0x10118 + (x)*0x100)\n#define RIO_PLM_SPx_PW_EN_OK2U\t0x40000000\n#define RIO_PLM_SPx_PW_EN_LINIT 0x10000000\n\n#define RIO_BC_L2_Gn_ENTRYx_CSR(n, x)\t(0x31000 + (n)*0x400 + (x)*0x4)\n#define RIO_SPx_L2_Gn_ENTRYy_CSR(x, n, y) \\\n\t\t\t\t(0x51000 + (x)*0x2000 + (n)*0x400 + (y)*0x4)\n\nstatic int\nidtg3_route_add_entry(struct rio_mport *mport, u16 destid, u8 hopcount,\n\t\t       u16 table, u16 route_destid, u8 route_port)\n{\n\tu32 rval;\n\tu32 entry = route_port;\n\tint err = 0;\n\n\tpr_debug(\"RIO: %s t=0x%x did_%x to p_%x\\n\",\n\t\t __func__, table, route_destid, entry);\n\n\tif (route_destid > 0xFF)\n\t\treturn -EINVAL;\n\n\tif (route_port == RIO_INVALID_ROUTE)\n\t\tentry = RIO_RT_ENTRY_DROP_PKT;\n\n\tif (table == RIO_GLOBAL_TABLE) {\n\t\t \n\t\terr = rio_mport_write_config_32(mport, destid, hopcount,\n\t\t\t\tRIO_BC_L2_Gn_ENTRYx_CSR(0, route_destid),\n\t\t\t\tentry);\n\t\treturn err;\n\t}\n\n\t \n\terr = rio_mport_read_config_32(mport, destid, hopcount,\n\t\t\t\t       RIO_SWP_INFO_CAR, &rval);\n\tif (err)\n\t\treturn err;\n\n\tif (table >= RIO_GET_TOTAL_PORTS(rval))\n\t\treturn -EINVAL;\n\n\terr = rio_mport_write_config_32(mport, destid, hopcount,\n\t\t\tRIO_SPx_L2_Gn_ENTRYy_CSR(table, 0, route_destid),\n\t\t\tentry);\n\treturn err;\n}\n\nstatic int\nidtg3_route_get_entry(struct rio_mport *mport, u16 destid, u8 hopcount,\n\t\t       u16 table, u16 route_destid, u8 *route_port)\n{\n\tu32 rval;\n\tint err;\n\n\tif (route_destid > 0xFF)\n\t\treturn -EINVAL;\n\n\terr = rio_mport_read_config_32(mport, destid, hopcount,\n\t\t\t\t       RIO_SWP_INFO_CAR, &rval);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (table == RIO_GLOBAL_TABLE)\n\t\ttable = RIO_GET_PORT_NUM(rval);\n\telse if (table >= RIO_GET_TOTAL_PORTS(rval))\n\t\treturn -EINVAL;\n\n\terr = rio_mport_read_config_32(mport, destid, hopcount,\n\t\t\tRIO_SPx_L2_Gn_ENTRYy_CSR(table, 0, route_destid),\n\t\t\t&rval);\n\tif (err)\n\t\treturn err;\n\n\tif (rval == RIO_RT_ENTRY_DROP_PKT)\n\t\t*route_port = RIO_INVALID_ROUTE;\n\telse\n\t\t*route_port = (u8)rval;\n\n\treturn 0;\n}\n\nstatic int\nidtg3_route_clr_table(struct rio_mport *mport, u16 destid, u8 hopcount,\n\t\t       u16 table)\n{\n\tu32 i;\n\tu32 rval;\n\tint err;\n\n\tif (table == RIO_GLOBAL_TABLE) {\n\t\tfor (i = 0; i <= 0xff; i++) {\n\t\t\terr = rio_mport_write_config_32(mport, destid, hopcount,\n\t\t\t\t\t\tRIO_BC_L2_Gn_ENTRYx_CSR(0, i),\n\t\t\t\t\t\tRIO_RT_ENTRY_DROP_PKT);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn err;\n\t}\n\n\terr = rio_mport_read_config_32(mport, destid, hopcount,\n\t\t\t\t       RIO_SWP_INFO_CAR, &rval);\n\tif (err)\n\t\treturn err;\n\n\tif (table >= RIO_GET_TOTAL_PORTS(rval))\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i <= 0xff; i++) {\n\t\terr = rio_mport_write_config_32(mport, destid, hopcount,\n\t\t\t\t\tRIO_SPx_L2_Gn_ENTRYy_CSR(table, 0, i),\n\t\t\t\t\tRIO_RT_ENTRY_DROP_PKT);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\treturn err;\n}\n\n \nstatic int\nidtg3_em_init(struct rio_dev *rdev)\n{\n\tint i, tmp;\n\tu32 rval;\n\n\tpr_debug(\"RIO: %s [%d:%d]\\n\", __func__, rdev->destid, rdev->hopcount);\n\n\t \n\trio_write_config_32(rdev, RIO_EM_DEV_INT_EN, 0);\n\n\t \n\trio_write_config_32(rdev, rdev->em_efptr + RIO_EM_PW_TX_CTRL,\n\t\t\t    RIO_EM_PW_TX_CTRL_PW_DIS);\n\n\t \n\ttmp = RIO_GET_TOTAL_PORTS(rdev->swpinfo);\n\tfor (i = 0; i < tmp; i++) {\n\n\t\trio_read_config_32(rdev,\n\t\t\tRIO_DEV_PORT_N_ERR_STS_CSR(rdev, i),\n\t\t\t&rval);\n\t\tif (rval & RIO_PORT_N_ERR_STS_PORT_UA)\n\t\t\tcontinue;\n\n\t\t \n\t\trio_write_config_32(rdev,\n\t\t\trdev->em_efptr + RIO_EM_PN_ERR_DETECT(i), 0);\n\n\t\t \n\t\trio_write_config_32(rdev,\n\t\t\trdev->em_efptr + RIO_EM_PN_ERRRATE_EN(i),\n\t\t\tRIO_EM_PN_ERRRATE_EN_OK2U | RIO_EM_PN_ERRRATE_EN_U2OK);\n\t\t \n\t\trio_write_config_32(rdev, RIO_PLM_SPx_PW_EN(i),\n\t\t\tRIO_PLM_SPx_PW_EN_OK2U | RIO_PLM_SPx_PW_EN_LINIT);\n\n\t}\n\n\t \n\ttmp = RIO_GET_PORT_NUM(rdev->swpinfo);\n\trio_write_config_32(rdev, RIO_PW_ROUTE, 1 << tmp);\n\n\n\t \n\trio_write_config_32(rdev, rdev->em_efptr + RIO_EM_PW_TX_CTRL, 0);\n\n\t \n\trio_write_config_32(rdev,\n\t\trdev->phys_efptr + RIO_PORT_LINKTO_CTL_CSR, 0x8e << 8);\n\treturn 0;\n}\n\n\n \nstatic int\nidtg3_em_handler(struct rio_dev *rdev, u8 pnum)\n{\n\tu32 err_status;\n\tu32 rval;\n\n\trio_read_config_32(rdev,\n\t\t\tRIO_DEV_PORT_N_ERR_STS_CSR(rdev, pnum),\n\t\t\t&err_status);\n\n\t \n\tif (err_status & RIO_PORT_N_ERR_STS_PORT_UNINIT)\n\t\treturn 0;\n\n\t \n\tif (err_status & (RIO_PORT_N_ERR_STS_OUT_ES |\n\t\t\t\tRIO_PORT_N_ERR_STS_INP_ES)) {\n\t\trio_read_config_32(rdev, RIO_PLM_SPx_IMP_SPEC_CTL(pnum), &rval);\n\t\trio_write_config_32(rdev, RIO_PLM_SPx_IMP_SPEC_CTL(pnum),\n\t\t\t\t    rval | RIO_PLM_SPx_IMP_SPEC_CTL_SOFT_RST);\n\t\tudelay(10);\n\t\trio_write_config_32(rdev, RIO_PLM_SPx_IMP_SPEC_CTL(pnum), rval);\n\t\tmsleep(500);\n\t}\n\n\treturn 0;\n}\n\nstatic struct rio_switch_ops idtg3_switch_ops = {\n\t.owner = THIS_MODULE,\n\t.add_entry = idtg3_route_add_entry,\n\t.get_entry = idtg3_route_get_entry,\n\t.clr_table = idtg3_route_clr_table,\n\t.em_init   = idtg3_em_init,\n\t.em_handle = idtg3_em_handler,\n};\n\nstatic int idtg3_probe(struct rio_dev *rdev, const struct rio_device_id *id)\n{\n\tpr_debug(\"RIO: %s for %s\\n\", __func__, rio_name(rdev));\n\n\tspin_lock(&rdev->rswitch->lock);\n\n\tif (rdev->rswitch->ops) {\n\t\tspin_unlock(&rdev->rswitch->lock);\n\t\treturn -EINVAL;\n\t}\n\n\trdev->rswitch->ops = &idtg3_switch_ops;\n\n\tif (rdev->do_enum) {\n\t\t \n\t\trio_write_config_32(rdev, 0x5000 + RIO_BC_RT_CTL_CSR, 0);\n\t}\n\n\tspin_unlock(&rdev->rswitch->lock);\n\n\treturn 0;\n}\n\nstatic void idtg3_remove(struct rio_dev *rdev)\n{\n\tpr_debug(\"RIO: %s for %s\\n\", __func__, rio_name(rdev));\n\tspin_lock(&rdev->rswitch->lock);\n\tif (rdev->rswitch->ops == &idtg3_switch_ops)\n\t\trdev->rswitch->ops = NULL;\n\tspin_unlock(&rdev->rswitch->lock);\n}\n\n \nstatic void idtg3_shutdown(struct rio_dev *rdev)\n{\n\tint i;\n\tu32 rval;\n\tu16 destid;\n\n\t \n\tif (!rdev->do_enum)\n\t\treturn;\n\n\tpr_debug(\"RIO: %s(%s)\\n\", __func__, rio_name(rdev));\n\n\trio_read_config_32(rdev, RIO_PW_ROUTE, &rval);\n\ti = RIO_GET_PORT_NUM(rdev->swpinfo);\n\n\t \n\tif (!((1 << i) & rval))\n\t\treturn;\n\n\t \n\trio_read_config_32(rdev, rdev->em_efptr + RIO_EM_PW_TGT_DEVID, &rval);\n\n\tif (rval & RIO_EM_PW_TGT_DEVID_DEV16)\n\t\tdestid = rval >> 16;\n\telse\n\t\tdestid = ((rval & RIO_EM_PW_TGT_DEVID_D8) >> 16);\n\n\tif (rdev->net->hport->host_deviceid == destid) {\n\t\trio_write_config_32(rdev,\n\t\t\t\t    rdev->em_efptr + RIO_EM_PW_TX_CTRL, 0);\n\t\tpr_debug(\"RIO: %s(%s) PW transmission disabled\\n\",\n\t\t\t __func__, rio_name(rdev));\n\t}\n}\n\nstatic const struct rio_device_id idtg3_id_table[] = {\n\t{RIO_DEVICE(RIO_DID_IDTRXS1632, RIO_VID_IDT)},\n\t{RIO_DEVICE(RIO_DID_IDTRXS2448, RIO_VID_IDT)},\n\t{ 0, }\t \n};\n\nstatic struct rio_driver idtg3_driver = {\n\t.name = \"idt_gen3\",\n\t.id_table = idtg3_id_table,\n\t.probe = idtg3_probe,\n\t.remove = idtg3_remove,\n\t.shutdown = idtg3_shutdown,\n};\n\nstatic int __init idtg3_init(void)\n{\n\treturn rio_register_driver(&idtg3_driver);\n}\n\nstatic void __exit idtg3_exit(void)\n{\n\tpr_debug(\"RIO: %s\\n\", __func__);\n\trio_unregister_driver(&idtg3_driver);\n\tpr_debug(\"RIO: %s done\\n\", __func__);\n}\n\ndevice_initcall(idtg3_init);\nmodule_exit(idtg3_exit);\n\nMODULE_DESCRIPTION(\"IDT RXS Gen.3 Serial RapidIO switch family driver\");\nMODULE_AUTHOR(\"Integrated Device Technology, Inc.\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}