{
  "module_name": "idtcps.c",
  "hash_id": "8aaf11292492d8467c66af0ffda96c67379989f81d17fa6a8758a05001c3c8c0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rapidio/switches/idtcps.c",
  "human_readable_source": "\n \n\n#include <linux/rio.h>\n#include <linux/rio_drv.h>\n#include <linux/rio_ids.h>\n#include <linux/module.h>\n#include \"../rio.h\"\n\n#define CPS_DEFAULT_ROUTE\t0xde\n#define CPS_NO_ROUTE\t\t0xdf\n\n#define IDTCPS_RIO_DOMAIN 0xf20020\n\nstatic int\nidtcps_route_add_entry(struct rio_mport *mport, u16 destid, u8 hopcount,\n\t\t       u16 table, u16 route_destid, u8 route_port)\n{\n\tu32 result;\n\n\tif (route_port == RIO_INVALID_ROUTE)\n\t\troute_port = CPS_DEFAULT_ROUTE;\n\n\tif (table == RIO_GLOBAL_TABLE) {\n\t\trio_mport_write_config_32(mport, destid, hopcount,\n\t\t\t\tRIO_STD_RTE_CONF_DESTID_SEL_CSR, route_destid);\n\n\t\trio_mport_read_config_32(mport, destid, hopcount,\n\t\t\t\tRIO_STD_RTE_CONF_PORT_SEL_CSR, &result);\n\n\t\tresult = (0xffffff00 & result) | (u32)route_port;\n\t\trio_mport_write_config_32(mport, destid, hopcount,\n\t\t\t\tRIO_STD_RTE_CONF_PORT_SEL_CSR, result);\n\t}\n\n\treturn 0;\n}\n\nstatic int\nidtcps_route_get_entry(struct rio_mport *mport, u16 destid, u8 hopcount,\n\t\t       u16 table, u16 route_destid, u8 *route_port)\n{\n\tu32 result;\n\n\tif (table == RIO_GLOBAL_TABLE) {\n\t\trio_mport_write_config_32(mport, destid, hopcount,\n\t\t\t\tRIO_STD_RTE_CONF_DESTID_SEL_CSR, route_destid);\n\n\t\trio_mport_read_config_32(mport, destid, hopcount,\n\t\t\t\tRIO_STD_RTE_CONF_PORT_SEL_CSR, &result);\n\n\t\tif (CPS_DEFAULT_ROUTE == (u8)result ||\n\t\t    CPS_NO_ROUTE == (u8)result)\n\t\t\t*route_port = RIO_INVALID_ROUTE;\n\t\telse\n\t\t\t*route_port = (u8)result;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nidtcps_route_clr_table(struct rio_mport *mport, u16 destid, u8 hopcount,\n\t\t       u16 table)\n{\n\tu32 i;\n\n\tif (table == RIO_GLOBAL_TABLE) {\n\t\tfor (i = 0x80000000; i <= 0x800000ff;) {\n\t\t\trio_mport_write_config_32(mport, destid, hopcount,\n\t\t\t\tRIO_STD_RTE_CONF_DESTID_SEL_CSR, i);\n\t\t\trio_mport_write_config_32(mport, destid, hopcount,\n\t\t\t\tRIO_STD_RTE_CONF_PORT_SEL_CSR,\n\t\t\t\t(CPS_DEFAULT_ROUTE << 24) |\n\t\t\t\t(CPS_DEFAULT_ROUTE << 16) |\n\t\t\t\t(CPS_DEFAULT_ROUTE << 8) | CPS_DEFAULT_ROUTE);\n\t\t\ti += 4;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int\nidtcps_set_domain(struct rio_mport *mport, u16 destid, u8 hopcount,\n\t\t       u8 sw_domain)\n{\n\t \n\trio_mport_write_config_32(mport, destid, hopcount,\n\t\t\t\t  IDTCPS_RIO_DOMAIN, (u32)sw_domain);\n\treturn 0;\n}\n\nstatic int\nidtcps_get_domain(struct rio_mport *mport, u16 destid, u8 hopcount,\n\t\t       u8 *sw_domain)\n{\n\tu32 regval;\n\n\t \n\trio_mport_read_config_32(mport, destid, hopcount,\n\t\t\t\tIDTCPS_RIO_DOMAIN, &regval);\n\n\t*sw_domain = (u8)(regval & 0xff);\n\n\treturn 0;\n}\n\nstatic struct rio_switch_ops idtcps_switch_ops = {\n\t.owner = THIS_MODULE,\n\t.add_entry = idtcps_route_add_entry,\n\t.get_entry = idtcps_route_get_entry,\n\t.clr_table = idtcps_route_clr_table,\n\t.set_domain = idtcps_set_domain,\n\t.get_domain = idtcps_get_domain,\n\t.em_init = NULL,\n\t.em_handle = NULL,\n};\n\nstatic int idtcps_probe(struct rio_dev *rdev, const struct rio_device_id *id)\n{\n\tpr_debug(\"RIO: %s for %s\\n\", __func__, rio_name(rdev));\n\n\tspin_lock(&rdev->rswitch->lock);\n\n\tif (rdev->rswitch->ops) {\n\t\tspin_unlock(&rdev->rswitch->lock);\n\t\treturn -EINVAL;\n\t}\n\n\trdev->rswitch->ops = &idtcps_switch_ops;\n\n\tif (rdev->do_enum) {\n\t\t \n\t\trio_write_config_32(rdev,\n\t\t\trdev->phys_efptr + RIO_PORT_LINKTO_CTL_CSR, 0x8e << 8);\n\t\t \n\t\trio_write_config_32(rdev,\n\t\t\t\t    RIO_STD_RTE_DEFAULT_PORT, CPS_NO_ROUTE);\n\t}\n\n\tspin_unlock(&rdev->rswitch->lock);\n\treturn 0;\n}\n\nstatic void idtcps_remove(struct rio_dev *rdev)\n{\n\tpr_debug(\"RIO: %s for %s\\n\", __func__, rio_name(rdev));\n\tspin_lock(&rdev->rswitch->lock);\n\tif (rdev->rswitch->ops != &idtcps_switch_ops) {\n\t\tspin_unlock(&rdev->rswitch->lock);\n\t\treturn;\n\t}\n\trdev->rswitch->ops = NULL;\n\tspin_unlock(&rdev->rswitch->lock);\n}\n\nstatic const struct rio_device_id idtcps_id_table[] = {\n\t{RIO_DEVICE(RIO_DID_IDTCPS6Q, RIO_VID_IDT)},\n\t{RIO_DEVICE(RIO_DID_IDTCPS8, RIO_VID_IDT)},\n\t{RIO_DEVICE(RIO_DID_IDTCPS10Q, RIO_VID_IDT)},\n\t{RIO_DEVICE(RIO_DID_IDTCPS12, RIO_VID_IDT)},\n\t{RIO_DEVICE(RIO_DID_IDTCPS16, RIO_VID_IDT)},\n\t{RIO_DEVICE(RIO_DID_IDT70K200, RIO_VID_IDT)},\n\t{ 0, }\t \n};\n\nstatic struct rio_driver idtcps_driver = {\n\t.name = \"idtcps\",\n\t.id_table = idtcps_id_table,\n\t.probe = idtcps_probe,\n\t.remove = idtcps_remove,\n};\n\nstatic int __init idtcps_init(void)\n{\n\treturn rio_register_driver(&idtcps_driver);\n}\n\nstatic void __exit idtcps_exit(void)\n{\n\trio_unregister_driver(&idtcps_driver);\n}\n\ndevice_initcall(idtcps_init);\nmodule_exit(idtcps_exit);\n\nMODULE_DESCRIPTION(\"IDT CPS Gen.1 Serial RapidIO switch family driver\");\nMODULE_AUTHOR(\"Integrated Device Technology, Inc.\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}