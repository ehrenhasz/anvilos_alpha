{
  "module_name": "idt_gen2.c",
  "hash_id": "aa912f6dc31310649c4a731e9145bb2df216f6301145744130b1e2fd393b5a03",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rapidio/switches/idt_gen2.c",
  "human_readable_source": "\n \n\n#include <linux/stat.h>\n#include <linux/module.h>\n#include <linux/rio.h>\n#include <linux/rio_drv.h>\n#include <linux/rio_ids.h>\n#include <linux/delay.h>\n\n#include <asm/page.h>\n#include \"../rio.h\"\n\n#define LOCAL_RTE_CONF_DESTID_SEL\t0x010070\n#define LOCAL_RTE_CONF_DESTID_SEL_PSEL\t0x0000001f\n\n#define IDT_LT_ERR_REPORT_EN\t0x03100c\n\n#define IDT_PORT_ERR_REPORT_EN(n)\t(0x031044 + (n)*0x40)\n#define IDT_PORT_ERR_REPORT_EN_BC\t0x03ff04\n\n#define IDT_PORT_ISERR_REPORT_EN(n)\t(0x03104C + (n)*0x40)\n#define IDT_PORT_ISERR_REPORT_EN_BC\t0x03ff0c\n#define IDT_PORT_INIT_TX_ACQUIRED\t0x00000020\n\n#define IDT_LANE_ERR_REPORT_EN(n)\t(0x038010 + (n)*0x100)\n#define IDT_LANE_ERR_REPORT_EN_BC\t0x03ff10\n\n#define IDT_DEV_CTRL_1\t\t0xf2000c\n#define IDT_DEV_CTRL_1_GENPW\t\t0x02000000\n#define IDT_DEV_CTRL_1_PRSTBEH\t\t0x00000001\n\n#define IDT_CFGBLK_ERR_CAPTURE_EN\t0x020008\n#define IDT_CFGBLK_ERR_REPORT\t\t0xf20014\n#define IDT_CFGBLK_ERR_REPORT_GENPW\t\t0x00000002\n\n#define IDT_AUX_PORT_ERR_CAP_EN\t0x020000\n#define IDT_AUX_ERR_REPORT_EN\t0xf20018\n#define IDT_AUX_PORT_ERR_LOG_I2C\t0x00000002\n#define IDT_AUX_PORT_ERR_LOG_JTAG\t0x00000001\n\n#define\tIDT_ISLTL_ADDRESS_CAP\t0x021014\n\n#define IDT_RIO_DOMAIN\t\t0xf20020\n#define IDT_RIO_DOMAIN_MASK\t\t0x000000ff\n\n#define IDT_PW_INFO_CSR\t\t0xf20024\n\n#define IDT_SOFT_RESET\t\t0xf20040\n#define IDT_SOFT_RESET_REQ\t\t0x00030097\n\n#define IDT_I2C_MCTRL\t\t0xf20050\n#define IDT_I2C_MCTRL_GENPW\t\t0x04000000\n\n#define IDT_JTAG_CTRL\t\t0xf2005c\n#define IDT_JTAG_CTRL_GENPW\t\t0x00000002\n\n#define IDT_LANE_CTRL(n)\t(0xff8000 + (n)*0x100)\n#define IDT_LANE_CTRL_BC\t0xffff00\n#define IDT_LANE_CTRL_GENPW\t\t0x00200000\n#define IDT_LANE_DFE_1_BC\t0xffff18\n#define IDT_LANE_DFE_2_BC\t0xffff1c\n\n#define IDT_PORT_OPS(n)\t\t(0xf40004 + (n)*0x100)\n#define IDT_PORT_OPS_GENPW\t\t0x08000000\n#define IDT_PORT_OPS_PL_ELOG\t\t0x00000040\n#define IDT_PORT_OPS_LL_ELOG\t\t0x00000020\n#define IDT_PORT_OPS_LT_ELOG\t\t0x00000010\n#define IDT_PORT_OPS_BC\t\t0xf4ff04\n\n#define IDT_PORT_ISERR_DET(n)\t(0xf40008 + (n)*0x100)\n\n#define IDT_ERR_CAP\t\t0xfd0000\n#define IDT_ERR_CAP_LOG_OVERWR\t\t0x00000004\n\n#define IDT_ERR_RD\t\t0xfd0004\n\n#define IDT_DEFAULT_ROUTE\t0xde\n#define IDT_NO_ROUTE\t\t0xdf\n\nstatic int\nidtg2_route_add_entry(struct rio_mport *mport, u16 destid, u8 hopcount,\n\t\t       u16 table, u16 route_destid, u8 route_port)\n{\n\t \n\tif (table == RIO_GLOBAL_TABLE)\n\t\ttable = 0;\n\telse\n\t\ttable++;\n\n\tif (route_port == RIO_INVALID_ROUTE)\n\t\troute_port = IDT_DEFAULT_ROUTE;\n\n\trio_mport_write_config_32(mport, destid, hopcount,\n\t\t\t\t  LOCAL_RTE_CONF_DESTID_SEL, table);\n\n\t \n\trio_mport_write_config_32(mport, destid, hopcount,\n\t\t\t\t  RIO_STD_RTE_CONF_DESTID_SEL_CSR,\n\t\t\t\t  (u32)route_destid);\n\n\trio_mport_write_config_32(mport, destid, hopcount,\n\t\t\t\t  RIO_STD_RTE_CONF_PORT_SEL_CSR,\n\t\t\t\t  (u32)route_port);\n\tudelay(10);\n\n\treturn 0;\n}\n\nstatic int\nidtg2_route_get_entry(struct rio_mport *mport, u16 destid, u8 hopcount,\n\t\t       u16 table, u16 route_destid, u8 *route_port)\n{\n\tu32 result;\n\n\t \n\tif (table == RIO_GLOBAL_TABLE)\n\t\ttable = 0;\n\telse\n\t\ttable++;\n\n\trio_mport_write_config_32(mport, destid, hopcount,\n\t\t\t\t  LOCAL_RTE_CONF_DESTID_SEL, table);\n\n\trio_mport_write_config_32(mport, destid, hopcount,\n\t\t\t\t  RIO_STD_RTE_CONF_DESTID_SEL_CSR,\n\t\t\t\t  route_destid);\n\n\trio_mport_read_config_32(mport, destid, hopcount,\n\t\t\t\t RIO_STD_RTE_CONF_PORT_SEL_CSR, &result);\n\n\tif (IDT_DEFAULT_ROUTE == (u8)result || IDT_NO_ROUTE == (u8)result)\n\t\t*route_port = RIO_INVALID_ROUTE;\n\telse\n\t\t*route_port = (u8)result;\n\n\treturn 0;\n}\n\nstatic int\nidtg2_route_clr_table(struct rio_mport *mport, u16 destid, u8 hopcount,\n\t\t       u16 table)\n{\n\tu32 i;\n\n\t \n\tif (table == RIO_GLOBAL_TABLE)\n\t\ttable = 0;\n\telse\n\t\ttable++;\n\n\trio_mport_write_config_32(mport, destid, hopcount,\n\t\t\t\t  LOCAL_RTE_CONF_DESTID_SEL, table);\n\n\tfor (i = RIO_STD_RTE_CONF_EXTCFGEN;\n\t     i <= (RIO_STD_RTE_CONF_EXTCFGEN | 0xff);) {\n\t\trio_mport_write_config_32(mport, destid, hopcount,\n\t\t\tRIO_STD_RTE_CONF_DESTID_SEL_CSR, i);\n\t\trio_mport_write_config_32(mport, destid, hopcount,\n\t\t\tRIO_STD_RTE_CONF_PORT_SEL_CSR,\n\t\t\t(IDT_DEFAULT_ROUTE << 24) | (IDT_DEFAULT_ROUTE << 16) |\n\t\t\t(IDT_DEFAULT_ROUTE << 8) | IDT_DEFAULT_ROUTE);\n\t\ti += 4;\n\t}\n\n\treturn 0;\n}\n\n\nstatic int\nidtg2_set_domain(struct rio_mport *mport, u16 destid, u8 hopcount,\n\t\t       u8 sw_domain)\n{\n\t \n\trio_mport_write_config_32(mport, destid, hopcount,\n\t\t\t\t  IDT_RIO_DOMAIN, (u32)sw_domain);\n\treturn 0;\n}\n\nstatic int\nidtg2_get_domain(struct rio_mport *mport, u16 destid, u8 hopcount,\n\t\t       u8 *sw_domain)\n{\n\tu32 regval;\n\n\t \n\trio_mport_read_config_32(mport, destid, hopcount,\n\t\t\t\tIDT_RIO_DOMAIN, &regval);\n\n\t*sw_domain = (u8)(regval & 0xff);\n\n\treturn 0;\n}\n\nstatic int\nidtg2_em_init(struct rio_dev *rdev)\n{\n\tu32 regval;\n\tint i, tmp;\n\n\t \n\n\tpr_debug(\"RIO: %s [%d:%d]\\n\", __func__, rdev->destid, rdev->hopcount);\n\n\t \n\trio_write_config_32(rdev, IDT_PW_INFO_CSR, 0x0000e000);\n\n\t \n\n\t \n\trio_write_config_32(rdev, IDT_LT_ERR_REPORT_EN,\n\t\t\tREM_LTL_ERR_ILLTRAN | REM_LTL_ERR_UNSOLR |\n\t\t\tREM_LTL_ERR_UNSUPTR);\n\n\t \n\trio_read_config_32(rdev, IDT_DEV_CTRL_1, &regval);\n\trio_write_config_32(rdev, IDT_DEV_CTRL_1,\n\t\t\tregval | IDT_DEV_CTRL_1_GENPW | IDT_DEV_CTRL_1_PRSTBEH);\n\n\t \n\n\t \n\trio_write_config_32(rdev, IDT_PORT_ERR_REPORT_EN_BC, 0x807e8037);\n\n\t \n\trio_write_config_32(rdev, IDT_PORT_ISERR_REPORT_EN_BC,\n\t\t\t    IDT_PORT_INIT_TX_ACQUIRED);\n\n\t \n\ttmp = RIO_GET_TOTAL_PORTS(rdev->swpinfo);\n\tfor (i = 0; i < tmp; i++) {\n\t\trio_read_config_32(rdev, IDT_PORT_OPS(i), &regval);\n\t\trio_write_config_32(rdev,\n\t\t\t\tIDT_PORT_OPS(i), regval | IDT_PORT_OPS_GENPW |\n\t\t\t\tIDT_PORT_OPS_PL_ELOG |\n\t\t\t\tIDT_PORT_OPS_LL_ELOG |\n\t\t\t\tIDT_PORT_OPS_LT_ELOG);\n\t}\n\t \n\trio_write_config_32(rdev, IDT_ERR_CAP, IDT_ERR_CAP_LOG_OVERWR);\n\n\t \n\n\t \n\trio_write_config_32(rdev, IDT_LANE_ERR_REPORT_EN_BC, 0);\n\n\t \n\ttmp = (rdev->did == RIO_DID_IDTCPS1848) ? 48 : 16;\n\tfor (i = 0; i < tmp; i++) {\n\t\trio_read_config_32(rdev, IDT_LANE_CTRL(i), &regval);\n\t\trio_write_config_32(rdev, IDT_LANE_CTRL(i),\n\t\t\t\t    regval | IDT_LANE_CTRL_GENPW);\n\t}\n\n\t \n\n\t \n\trio_write_config_32(rdev, IDT_AUX_PORT_ERR_CAP_EN, 0);\n\n\t \n\trio_write_config_32(rdev, IDT_AUX_ERR_REPORT_EN, 0);\n\n\t \n\trio_write_config_32(rdev, IDT_JTAG_CTRL, 0);\n\n\t \n\trio_read_config_32(rdev, IDT_I2C_MCTRL, &regval);\n\trio_write_config_32(rdev, IDT_I2C_MCTRL, regval & ~IDT_I2C_MCTRL_GENPW);\n\n\t \n\n\t \n\trio_write_config_32(rdev, IDT_CFGBLK_ERR_CAPTURE_EN, 0);\n\n\t \n\trio_read_config_32(rdev, IDT_CFGBLK_ERR_REPORT, &regval);\n\trio_write_config_32(rdev, IDT_CFGBLK_ERR_REPORT,\n\t\t\t    regval & ~IDT_CFGBLK_ERR_REPORT_GENPW);\n\n\t \n\trio_write_config_32(rdev,\n\t\trdev->phys_efptr + RIO_PORT_LINKTO_CTL_CSR, 0x8e << 8);\n\n\treturn 0;\n}\n\nstatic int\nidtg2_em_handler(struct rio_dev *rdev, u8 portnum)\n{\n\tu32 regval, em_perrdet, em_ltlerrdet;\n\n\trio_read_config_32(rdev,\n\t\trdev->em_efptr + RIO_EM_LTL_ERR_DETECT, &em_ltlerrdet);\n\tif (em_ltlerrdet) {\n\t\t \n\t\tif (em_ltlerrdet & REM_LTL_ERR_IMPSPEC) {\n\t\t\t \n\t\t\trio_read_config_32(rdev,\n\t\t\t\t\tIDT_ISLTL_ADDRESS_CAP, &regval);\n\n\t\t\tpr_debug(\"RIO: %s Implementation Specific LTL errors\" \\\n\t\t\t\t \" 0x%x @(0x%x)\\n\",\n\t\t\t\t rio_name(rdev), em_ltlerrdet, regval);\n\n\t\t\t \n\t\t\trio_write_config_32(rdev, IDT_ISLTL_ADDRESS_CAP, 0);\n\n\t\t}\n\t}\n\n\trio_read_config_32(rdev,\n\t\trdev->em_efptr + RIO_EM_PN_ERR_DETECT(portnum), &em_perrdet);\n\tif (em_perrdet) {\n\t\t \n\t\tif (em_perrdet & REM_PED_IMPL_SPEC) {\n\t\t\t \n\n\t\t\t \n\t\t\trio_read_config_32(rdev,\n\t\t\t\t\tIDT_PORT_ISERR_DET(portnum), &regval);\n\n\t\t\tpr_debug(\"RIO: %s Implementation Specific Port\" \\\n\t\t\t\t \" errors 0x%x\\n\", rio_name(rdev), regval);\n\n\t\t\t \n\t\t\trio_write_config_32(rdev,\n\t\t\t\t\tIDT_PORT_ISERR_DET(portnum), 0);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic ssize_t\nidtg2_show_errlog(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct rio_dev *rdev = to_rio_dev(dev);\n\tssize_t len = 0;\n\tu32 regval;\n\n\twhile (!rio_read_config_32(rdev, IDT_ERR_RD, &regval)) {\n\t\tif (!regval)     \n\t\t\tbreak;\n\t\tlen += snprintf(buf + len, PAGE_SIZE - len,\n\t\t\t\t\t\"%08x\\n\", regval);\n\t\tif (len >= (PAGE_SIZE - 10))\n\t\t\tbreak;\n\t}\n\n\treturn len;\n}\n\nstatic DEVICE_ATTR(errlog, S_IRUGO, idtg2_show_errlog, NULL);\n\nstatic int idtg2_sysfs(struct rio_dev *rdev, bool create)\n{\n\tstruct device *dev = &rdev->dev;\n\tint err = 0;\n\n\tif (create) {\n\t\t \n\t\terr = device_create_file(dev, &dev_attr_errlog);\n\t\tif (err)\n\t\t\tdev_err(dev, \"Unable create sysfs errlog file\\n\");\n\t} else\n\t\tdevice_remove_file(dev, &dev_attr_errlog);\n\n\treturn err;\n}\n\nstatic struct rio_switch_ops idtg2_switch_ops = {\n\t.owner = THIS_MODULE,\n\t.add_entry = idtg2_route_add_entry,\n\t.get_entry = idtg2_route_get_entry,\n\t.clr_table = idtg2_route_clr_table,\n\t.set_domain = idtg2_set_domain,\n\t.get_domain = idtg2_get_domain,\n\t.em_init = idtg2_em_init,\n\t.em_handle = idtg2_em_handler,\n};\n\nstatic int idtg2_probe(struct rio_dev *rdev, const struct rio_device_id *id)\n{\n\tpr_debug(\"RIO: %s for %s\\n\", __func__, rio_name(rdev));\n\n\tspin_lock(&rdev->rswitch->lock);\n\n\tif (rdev->rswitch->ops) {\n\t\tspin_unlock(&rdev->rswitch->lock);\n\t\treturn -EINVAL;\n\t}\n\n\trdev->rswitch->ops = &idtg2_switch_ops;\n\n\tif (rdev->do_enum) {\n\t\t \n\t\trio_write_config_32(rdev,\n\t\t\t\t    RIO_STD_RTE_DEFAULT_PORT, IDT_NO_ROUTE);\n\t}\n\n\tspin_unlock(&rdev->rswitch->lock);\n\n\t \n\tidtg2_sysfs(rdev, true);\n\n\treturn 0;\n}\n\nstatic void idtg2_remove(struct rio_dev *rdev)\n{\n\tpr_debug(\"RIO: %s for %s\\n\", __func__, rio_name(rdev));\n\tspin_lock(&rdev->rswitch->lock);\n\tif (rdev->rswitch->ops != &idtg2_switch_ops) {\n\t\tspin_unlock(&rdev->rswitch->lock);\n\t\treturn;\n\t}\n\trdev->rswitch->ops = NULL;\n\tspin_unlock(&rdev->rswitch->lock);\n\t \n\tidtg2_sysfs(rdev, false);\n}\n\nstatic const struct rio_device_id idtg2_id_table[] = {\n\t{RIO_DEVICE(RIO_DID_IDTCPS1848, RIO_VID_IDT)},\n\t{RIO_DEVICE(RIO_DID_IDTCPS1616, RIO_VID_IDT)},\n\t{RIO_DEVICE(RIO_DID_IDTVPS1616, RIO_VID_IDT)},\n\t{RIO_DEVICE(RIO_DID_IDTSPS1616, RIO_VID_IDT)},\n\t{RIO_DEVICE(RIO_DID_IDTCPS1432, RIO_VID_IDT)},\n\t{ 0, }\t \n};\n\nstatic struct rio_driver idtg2_driver = {\n\t.name = \"idt_gen2\",\n\t.id_table = idtg2_id_table,\n\t.probe = idtg2_probe,\n\t.remove = idtg2_remove,\n};\n\nstatic int __init idtg2_init(void)\n{\n\treturn rio_register_driver(&idtg2_driver);\n}\n\nstatic void __exit idtg2_exit(void)\n{\n\tpr_debug(\"RIO: %s\\n\", __func__);\n\trio_unregister_driver(&idtg2_driver);\n\tpr_debug(\"RIO: %s done\\n\", __func__);\n}\n\ndevice_initcall(idtg2_init);\nmodule_exit(idtg2_exit);\n\nMODULE_DESCRIPTION(\"IDT CPS Gen.2 Serial RapidIO switch family driver\");\nMODULE_AUTHOR(\"Integrated Device Technology, Inc.\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}