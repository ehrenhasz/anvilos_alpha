{
  "module_name": "tsi721_dma.c",
  "hash_id": "7ab8ebdd0b00f9279178d9daf3584fc85ea0afd1fa5b0347555b08e14e31bbfe",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rapidio/devices/tsi721_dma.c",
  "human_readable_source": "\n \n\n#include <linux/io.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/rio.h>\n#include <linux/rio_drv.h>\n#include <linux/dma-mapping.h>\n#include <linux/interrupt.h>\n#include <linux/kfifo.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include \"../../dma/dmaengine.h\"\n\n#include \"tsi721.h\"\n\n#ifdef CONFIG_PCI_MSI\nstatic irqreturn_t tsi721_bdma_msix(int irq, void *ptr);\n#endif\nstatic int tsi721_submit_sg(struct tsi721_tx_desc *desc);\n\nstatic unsigned int dma_desc_per_channel = 128;\nmodule_param(dma_desc_per_channel, uint, S_IRUGO);\nMODULE_PARM_DESC(dma_desc_per_channel,\n\t\t \"Number of DMA descriptors per channel (default: 128)\");\n\nstatic unsigned int dma_txqueue_sz = 16;\nmodule_param(dma_txqueue_sz, uint, S_IRUGO);\nMODULE_PARM_DESC(dma_txqueue_sz,\n\t\t \"DMA Transactions Queue Size (default: 16)\");\n\nstatic u8 dma_sel = 0x7f;\nmodule_param(dma_sel, byte, S_IRUGO);\nMODULE_PARM_DESC(dma_sel,\n\t\t \"DMA Channel Selection Mask (default: 0x7f = all)\");\n\nstatic inline struct tsi721_bdma_chan *to_tsi721_chan(struct dma_chan *chan)\n{\n\treturn container_of(chan, struct tsi721_bdma_chan, dchan);\n}\n\nstatic inline struct tsi721_device *to_tsi721(struct dma_device *ddev)\n{\n\treturn container_of(ddev, struct rio_mport, dma)->priv;\n}\n\nstatic inline\nstruct tsi721_tx_desc *to_tsi721_desc(struct dma_async_tx_descriptor *txd)\n{\n\treturn container_of(txd, struct tsi721_tx_desc, txd);\n}\n\nstatic int tsi721_bdma_ch_init(struct tsi721_bdma_chan *bdma_chan, int bd_num)\n{\n\tstruct tsi721_dma_desc *bd_ptr;\n\tstruct device *dev = bdma_chan->dchan.device->dev;\n\tu64\t\t*sts_ptr;\n\tdma_addr_t\tbd_phys;\n\tdma_addr_t\tsts_phys;\n\tint\t\tsts_size;\n#ifdef CONFIG_PCI_MSI\n\tstruct tsi721_device *priv = to_tsi721(bdma_chan->dchan.device);\n#endif\n\n\ttsi_debug(DMA, &bdma_chan->dchan.dev->device, \"DMAC%d\", bdma_chan->id);\n\n\t \n\tbd_ptr = dma_alloc_coherent(dev,\n\t\t\t\t    (bd_num + 1) * sizeof(struct tsi721_dma_desc),\n\t\t\t\t    &bd_phys, GFP_ATOMIC);\n\tif (!bd_ptr)\n\t\treturn -ENOMEM;\n\n\tbdma_chan->bd_num = bd_num;\n\tbdma_chan->bd_phys = bd_phys;\n\tbdma_chan->bd_base = bd_ptr;\n\n\ttsi_debug(DMA, &bdma_chan->dchan.dev->device,\n\t\t  \"DMAC%d descriptors @ %p (phys = %pad)\",\n\t\t  bdma_chan->id, bd_ptr, &bd_phys);\n\n\t \n\tsts_size = ((bd_num + 1) >= TSI721_DMA_MINSTSSZ) ?\n\t\t\t\t\t(bd_num + 1) : TSI721_DMA_MINSTSSZ;\n\tsts_size = roundup_pow_of_two(sts_size);\n\tsts_ptr = dma_alloc_coherent(dev,\n\t\t\t\t     sts_size * sizeof(struct tsi721_dma_sts),\n\t\t\t\t     &sts_phys, GFP_ATOMIC);\n\tif (!sts_ptr) {\n\t\t \n\t\tdma_free_coherent(dev,\n\t\t\t\t  (bd_num + 1) * sizeof(struct tsi721_dma_desc),\n\t\t\t\t  bd_ptr, bd_phys);\n\t\tbdma_chan->bd_base = NULL;\n\t\treturn -ENOMEM;\n\t}\n\n\tbdma_chan->sts_phys = sts_phys;\n\tbdma_chan->sts_base = sts_ptr;\n\tbdma_chan->sts_size = sts_size;\n\n\ttsi_debug(DMA, &bdma_chan->dchan.dev->device,\n\t\t\"DMAC%d desc status FIFO @ %p (phys = %pad) size=0x%x\",\n\t\tbdma_chan->id, sts_ptr, &sts_phys, sts_size);\n\n\t \n\tbd_ptr[bd_num].type_id = cpu_to_le32(DTYPE3 << 29);\n\tbd_ptr[bd_num].next_lo = cpu_to_le32((u64)bd_phys &\n\t\t\t\t\t\t TSI721_DMAC_DPTRL_MASK);\n\tbd_ptr[bd_num].next_hi = cpu_to_le32((u64)bd_phys >> 32);\n\n\t \n\tiowrite32(((u64)bd_phys >> 32),\n\t\tbdma_chan->regs + TSI721_DMAC_DPTRH);\n\tiowrite32(((u64)bd_phys & TSI721_DMAC_DPTRL_MASK),\n\t\tbdma_chan->regs + TSI721_DMAC_DPTRL);\n\n\t \n\tiowrite32(((u64)sts_phys >> 32),\n\t\tbdma_chan->regs + TSI721_DMAC_DSBH);\n\tiowrite32(((u64)sts_phys & TSI721_DMAC_DSBL_MASK),\n\t\tbdma_chan->regs + TSI721_DMAC_DSBL);\n\tiowrite32(TSI721_DMAC_DSSZ_SIZE(sts_size),\n\t\tbdma_chan->regs + TSI721_DMAC_DSSZ);\n\n\t \n\tiowrite32(TSI721_DMAC_INT_ALL,\n\t\tbdma_chan->regs + TSI721_DMAC_INT);\n\n\tioread32(bdma_chan->regs + TSI721_DMAC_INT);\n\n#ifdef CONFIG_PCI_MSI\n\t \n\tif (priv->flags & TSI721_USING_MSIX) {\n\t\tint rc, idx;\n\n\t\tidx = TSI721_VECT_DMA0_DONE + bdma_chan->id;\n\n\t\trc = request_irq(priv->msix[idx].vector, tsi721_bdma_msix, 0,\n\t\t\t\t priv->msix[idx].irq_name, (void *)bdma_chan);\n\n\t\tif (rc) {\n\t\t\ttsi_debug(DMA, &bdma_chan->dchan.dev->device,\n\t\t\t\t  \"Unable to get MSI-X for DMAC%d-DONE\",\n\t\t\t\t  bdma_chan->id);\n\t\t\tgoto err_out;\n\t\t}\n\n\t\tidx = TSI721_VECT_DMA0_INT + bdma_chan->id;\n\n\t\trc = request_irq(priv->msix[idx].vector, tsi721_bdma_msix, 0,\n\t\t\t\tpriv->msix[idx].irq_name, (void *)bdma_chan);\n\n\t\tif (rc)\t{\n\t\t\ttsi_debug(DMA, &bdma_chan->dchan.dev->device,\n\t\t\t\t  \"Unable to get MSI-X for DMAC%d-INT\",\n\t\t\t\t  bdma_chan->id);\n\t\t\tfree_irq(\n\t\t\t\tpriv->msix[TSI721_VECT_DMA0_DONE +\n\t\t\t\t\t    bdma_chan->id].vector,\n\t\t\t\t(void *)bdma_chan);\n\t\t}\n\nerr_out:\n\t\tif (rc) {\n\t\t\t \n\t\t\tdma_free_coherent(dev,\n\t\t\t\t(bd_num + 1) * sizeof(struct tsi721_dma_desc),\n\t\t\t\tbd_ptr, bd_phys);\n\t\t\tbdma_chan->bd_base = NULL;\n\n\t\t\t \n\t\t\tdma_free_coherent(dev,\n\t\t\t\tsts_size * sizeof(struct tsi721_dma_sts),\n\t\t\t\tsts_ptr, sts_phys);\n\t\t\tbdma_chan->sts_base = NULL;\n\n\t\t\treturn -EIO;\n\t\t}\n\t}\n#endif  \n\n\t \n\tiowrite32(TSI721_DMAC_CTL_INIT,\tbdma_chan->regs + TSI721_DMAC_CTL);\n\tioread32(bdma_chan->regs + TSI721_DMAC_CTL);\n\tbdma_chan->wr_count = bdma_chan->wr_count_next = 0;\n\tbdma_chan->sts_rdptr = 0;\n\tudelay(10);\n\n\treturn 0;\n}\n\nstatic int tsi721_bdma_ch_free(struct tsi721_bdma_chan *bdma_chan)\n{\n\tu32 ch_stat;\n#ifdef CONFIG_PCI_MSI\n\tstruct tsi721_device *priv = to_tsi721(bdma_chan->dchan.device);\n#endif\n\n\tif (!bdma_chan->bd_base)\n\t\treturn 0;\n\n\t \n\tch_stat = ioread32(bdma_chan->regs + TSI721_DMAC_STS);\n\tif (ch_stat & TSI721_DMAC_STS_RUN)\n\t\treturn -EFAULT;\n\n\t \n\tiowrite32(TSI721_DMAC_CTL_INIT,\tbdma_chan->regs + TSI721_DMAC_CTL);\n\n#ifdef CONFIG_PCI_MSI\n\tif (priv->flags & TSI721_USING_MSIX) {\n\t\tfree_irq(priv->msix[TSI721_VECT_DMA0_DONE +\n\t\t\t\t    bdma_chan->id].vector, (void *)bdma_chan);\n\t\tfree_irq(priv->msix[TSI721_VECT_DMA0_INT +\n\t\t\t\t    bdma_chan->id].vector, (void *)bdma_chan);\n\t}\n#endif  \n\n\t \n\tdma_free_coherent(bdma_chan->dchan.device->dev,\n\t\t(bdma_chan->bd_num + 1) * sizeof(struct tsi721_dma_desc),\n\t\tbdma_chan->bd_base, bdma_chan->bd_phys);\n\tbdma_chan->bd_base = NULL;\n\n\t \n\tdma_free_coherent(bdma_chan->dchan.device->dev,\n\t\tbdma_chan->sts_size * sizeof(struct tsi721_dma_sts),\n\t\tbdma_chan->sts_base, bdma_chan->sts_phys);\n\tbdma_chan->sts_base = NULL;\n\treturn 0;\n}\n\nstatic void\ntsi721_bdma_interrupt_enable(struct tsi721_bdma_chan *bdma_chan, int enable)\n{\n\tif (enable) {\n\t\t \n\t\tiowrite32(TSI721_DMAC_INT_ALL,\n\t\t\tbdma_chan->regs + TSI721_DMAC_INT);\n\t\tioread32(bdma_chan->regs + TSI721_DMAC_INT);\n\t\t \n\t\tiowrite32(TSI721_DMAC_INT_ALL,\n\t\t\tbdma_chan->regs + TSI721_DMAC_INTE);\n\t} else {\n\t\t \n\t\tiowrite32(0, bdma_chan->regs + TSI721_DMAC_INTE);\n\t\t \n\t\tiowrite32(TSI721_DMAC_INT_ALL,\n\t\t\tbdma_chan->regs + TSI721_DMAC_INT);\n\t}\n\n}\n\nstatic bool tsi721_dma_is_idle(struct tsi721_bdma_chan *bdma_chan)\n{\n\tu32 sts;\n\n\tsts = ioread32(bdma_chan->regs + TSI721_DMAC_STS);\n\treturn ((sts & TSI721_DMAC_STS_RUN) == 0);\n}\n\nvoid tsi721_bdma_handler(struct tsi721_bdma_chan *bdma_chan)\n{\n\t \n\tiowrite32(0, bdma_chan->regs + TSI721_DMAC_INTE);\n\tif (bdma_chan->active)\n\t\ttasklet_hi_schedule(&bdma_chan->tasklet);\n}\n\n#ifdef CONFIG_PCI_MSI\n \nstatic irqreturn_t tsi721_bdma_msix(int irq, void *ptr)\n{\n\tstruct tsi721_bdma_chan *bdma_chan = ptr;\n\n\tif (bdma_chan->active)\n\t\ttasklet_hi_schedule(&bdma_chan->tasklet);\n\treturn IRQ_HANDLED;\n}\n#endif  \n\n \nstatic void tsi721_start_dma(struct tsi721_bdma_chan *bdma_chan)\n{\n\tif (!tsi721_dma_is_idle(bdma_chan)) {\n\t\ttsi_err(&bdma_chan->dchan.dev->device,\n\t\t\t\"DMAC%d Attempt to start non-idle channel\",\n\t\t\tbdma_chan->id);\n\t\treturn;\n\t}\n\n\tif (bdma_chan->wr_count == bdma_chan->wr_count_next) {\n\t\ttsi_err(&bdma_chan->dchan.dev->device,\n\t\t\t\"DMAC%d Attempt to start DMA with no BDs ready %d\",\n\t\t\tbdma_chan->id, task_pid_nr(current));\n\t\treturn;\n\t}\n\n\ttsi_debug(DMA, &bdma_chan->dchan.dev->device, \"DMAC%d (wrc=%d) %d\",\n\t\t  bdma_chan->id, bdma_chan->wr_count_next,\n\t\t  task_pid_nr(current));\n\n\tiowrite32(bdma_chan->wr_count_next,\n\t\tbdma_chan->regs + TSI721_DMAC_DWRCNT);\n\tioread32(bdma_chan->regs + TSI721_DMAC_DWRCNT);\n\n\tbdma_chan->wr_count = bdma_chan->wr_count_next;\n}\n\nstatic int\ntsi721_desc_fill_init(struct tsi721_tx_desc *desc,\n\t\t      struct tsi721_dma_desc *bd_ptr,\n\t\t      struct scatterlist *sg, u32 sys_size)\n{\n\tu64 rio_addr;\n\n\tif (!bd_ptr)\n\t\treturn -EINVAL;\n\n\t \n\tbd_ptr->type_id = cpu_to_le32((DTYPE1 << 29) |\n\t\t\t\t      (desc->rtype << 19) | desc->destid);\n\tbd_ptr->bcount = cpu_to_le32(((desc->rio_addr & 0x3) << 30) |\n\t\t\t\t     (sys_size << 26));\n\trio_addr = (desc->rio_addr >> 2) |\n\t\t\t\t((u64)(desc->rio_addr_u & 0x3) << 62);\n\tbd_ptr->raddr_lo = cpu_to_le32(rio_addr & 0xffffffff);\n\tbd_ptr->raddr_hi = cpu_to_le32(rio_addr >> 32);\n\tbd_ptr->t1.bufptr_lo = cpu_to_le32(\n\t\t\t\t\t(u64)sg_dma_address(sg) & 0xffffffff);\n\tbd_ptr->t1.bufptr_hi = cpu_to_le32((u64)sg_dma_address(sg) >> 32);\n\tbd_ptr->t1.s_dist = 0;\n\tbd_ptr->t1.s_size = 0;\n\n\treturn 0;\n}\n\nstatic int\ntsi721_desc_fill_end(struct tsi721_dma_desc *bd_ptr, u32 bcount, bool interrupt)\n{\n\tif (!bd_ptr)\n\t\treturn -EINVAL;\n\n\t \n\tif (interrupt)\n\t\tbd_ptr->type_id |= cpu_to_le32(TSI721_DMAD_IOF);\n\tbd_ptr->bcount |= cpu_to_le32(bcount & TSI721_DMAD_BCOUNT1);\n\n\treturn 0;\n}\n\nstatic void tsi721_dma_tx_err(struct tsi721_bdma_chan *bdma_chan,\n\t\t\t      struct tsi721_tx_desc *desc)\n{\n\tstruct dma_async_tx_descriptor *txd = &desc->txd;\n\tdma_async_tx_callback callback = txd->callback;\n\tvoid *param = txd->callback_param;\n\n\tlist_move(&desc->desc_node, &bdma_chan->free_list);\n\n\tif (callback)\n\t\tcallback(param);\n}\n\nstatic void tsi721_clr_stat(struct tsi721_bdma_chan *bdma_chan)\n{\n\tu32 srd_ptr;\n\tu64 *sts_ptr;\n\tint i, j;\n\n\t \n\tsrd_ptr = bdma_chan->sts_rdptr;\n\tsts_ptr = bdma_chan->sts_base;\n\tj = srd_ptr * 8;\n\twhile (sts_ptr[j]) {\n\t\tfor (i = 0; i < 8 && sts_ptr[j]; i++, j++)\n\t\t\tsts_ptr[j] = 0;\n\n\t\t++srd_ptr;\n\t\tsrd_ptr %= bdma_chan->sts_size;\n\t\tj = srd_ptr * 8;\n\t}\n\n\tiowrite32(srd_ptr, bdma_chan->regs + TSI721_DMAC_DSRP);\n\tbdma_chan->sts_rdptr = srd_ptr;\n}\n\n \nstatic int tsi721_submit_sg(struct tsi721_tx_desc *desc)\n{\n\tstruct dma_chan *dchan = desc->txd.chan;\n\tstruct tsi721_bdma_chan *bdma_chan = to_tsi721_chan(dchan);\n\tu32 sys_size;\n\tu64 rio_addr;\n\tdma_addr_t next_addr;\n\tu32 bcount;\n\tstruct scatterlist *sg;\n\tunsigned int i;\n\tint err = 0;\n\tstruct tsi721_dma_desc *bd_ptr = NULL;\n\tu32 idx, rd_idx;\n\tu32 add_count = 0;\n\tstruct device *ch_dev = &dchan->dev->device;\n\n\tif (!tsi721_dma_is_idle(bdma_chan)) {\n\t\ttsi_err(ch_dev, \"DMAC%d ERR: Attempt to use non-idle channel\",\n\t\t\tbdma_chan->id);\n\t\treturn -EIO;\n\t}\n\n\t \n\trio_addr = desc->rio_addr;\n\tnext_addr = -1;\n\tbcount = 0;\n\tsys_size = dma_to_mport(dchan->device)->sys_size;\n\n\trd_idx = ioread32(bdma_chan->regs + TSI721_DMAC_DRDCNT);\n\trd_idx %= (bdma_chan->bd_num + 1);\n\n\tidx = bdma_chan->wr_count_next % (bdma_chan->bd_num + 1);\n\tif (idx == bdma_chan->bd_num) {\n\t\t \n\t\tidx = 0;\n\t\tadd_count++;\n\t}\n\n\ttsi_debug(DMA, ch_dev, \"DMAC%d BD ring status: rdi=%d wri=%d\",\n\t\t  bdma_chan->id, rd_idx, idx);\n\n\tfor_each_sg(desc->sg, sg, desc->sg_len, i) {\n\n\t\ttsi_debug(DMAV, ch_dev, \"DMAC%d sg%d/%d addr: 0x%llx len: %d\",\n\t\t\tbdma_chan->id, i, desc->sg_len,\n\t\t\t(unsigned long long)sg_dma_address(sg), sg_dma_len(sg));\n\n\t\tif (sg_dma_len(sg) > TSI721_BDMA_MAX_BCOUNT) {\n\t\t\ttsi_err(ch_dev, \"DMAC%d SG entry %d is too large\",\n\t\t\t\tbdma_chan->id, i);\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (next_addr == sg_dma_address(sg) &&\n\t\t    bcount + sg_dma_len(sg) <= TSI721_BDMA_MAX_BCOUNT) {\n\t\t\t \n\t\t\tbcount += sg_dma_len(sg);\n\t\t\tgoto entry_done;\n\t\t} else if (next_addr != -1) {\n\t\t\t \n\t\t\ttsi721_desc_fill_end(bd_ptr, bcount, 0);\n\t\t\ttsi_debug(DMAV, ch_dev,\t\"DMAC%d prev desc final len: %d\",\n\t\t\t\t  bdma_chan->id, bcount);\n\t\t}\n\n\t\tdesc->rio_addr = rio_addr;\n\n\t\tif (i && idx == rd_idx) {\n\t\t\ttsi_debug(DMAV, ch_dev,\n\t\t\t\t  \"DMAC%d HW descriptor ring is full @ %d\",\n\t\t\t\t  bdma_chan->id, i);\n\t\t\tdesc->sg = sg;\n\t\t\tdesc->sg_len -= i;\n\t\t\tbreak;\n\t\t}\n\n\t\tbd_ptr = &((struct tsi721_dma_desc *)bdma_chan->bd_base)[idx];\n\t\terr = tsi721_desc_fill_init(desc, bd_ptr, sg, sys_size);\n\t\tif (err) {\n\t\t\ttsi_err(ch_dev, \"Failed to build desc: err=%d\", err);\n\t\t\tbreak;\n\t\t}\n\n\t\ttsi_debug(DMAV, ch_dev, \"DMAC%d bd_ptr = %p did=%d raddr=0x%llx\",\n\t\t\t  bdma_chan->id, bd_ptr, desc->destid, desc->rio_addr);\n\n\t\tnext_addr = sg_dma_address(sg);\n\t\tbcount = sg_dma_len(sg);\n\n\t\tadd_count++;\n\t\tif (++idx == bdma_chan->bd_num) {\n\t\t\t \n\t\t\tidx = 0;\n\t\t\tadd_count++;\n\t\t}\n\nentry_done:\n\t\tif (sg_is_last(sg)) {\n\t\t\ttsi721_desc_fill_end(bd_ptr, bcount, 0);\n\t\t\ttsi_debug(DMAV, ch_dev,\n\t\t\t\t  \"DMAC%d last desc final len: %d\",\n\t\t\t\t  bdma_chan->id, bcount);\n\t\t\tdesc->sg_len = 0;\n\t\t} else {\n\t\t\trio_addr += sg_dma_len(sg);\n\t\t\tnext_addr += sg_dma_len(sg);\n\t\t}\n\t}\n\n\tif (!err)\n\t\tbdma_chan->wr_count_next += add_count;\n\n\treturn err;\n}\n\nstatic void tsi721_advance_work(struct tsi721_bdma_chan *bdma_chan,\n\t\t\t\tstruct tsi721_tx_desc *desc)\n{\n\tint err;\n\n\ttsi_debug(DMA, &bdma_chan->dchan.dev->device, \"DMAC%d\", bdma_chan->id);\n\n\tif (!tsi721_dma_is_idle(bdma_chan))\n\t\treturn;\n\n\t \n\tif (!desc && !bdma_chan->active_tx && !list_empty(&bdma_chan->queue)) {\n\t\tdesc = list_first_entry(&bdma_chan->queue,\n\t\t\t\t\tstruct tsi721_tx_desc, desc_node);\n\t\tlist_del_init((&desc->desc_node));\n\t\tbdma_chan->active_tx = desc;\n\t}\n\n\tif (desc) {\n\t\terr = tsi721_submit_sg(desc);\n\t\tif (!err)\n\t\t\ttsi721_start_dma(bdma_chan);\n\t\telse {\n\t\t\ttsi721_dma_tx_err(bdma_chan, desc);\n\t\t\ttsi_debug(DMA, &bdma_chan->dchan.dev->device,\n\t\t\t\t\"DMAC%d ERR: tsi721_submit_sg failed with err=%d\",\n\t\t\t\tbdma_chan->id, err);\n\t\t}\n\t}\n\n\ttsi_debug(DMA, &bdma_chan->dchan.dev->device, \"DMAC%d Exit\",\n\t\t  bdma_chan->id);\n}\n\nstatic void tsi721_dma_tasklet(unsigned long data)\n{\n\tstruct tsi721_bdma_chan *bdma_chan = (struct tsi721_bdma_chan *)data;\n\tu32 dmac_int, dmac_sts;\n\n\tdmac_int = ioread32(bdma_chan->regs + TSI721_DMAC_INT);\n\ttsi_debug(DMA, &bdma_chan->dchan.dev->device, \"DMAC%d_INT = 0x%x\",\n\t\t  bdma_chan->id, dmac_int);\n\t \n\tiowrite32(dmac_int, bdma_chan->regs + TSI721_DMAC_INT);\n\n\tif (dmac_int & TSI721_DMAC_INT_ERR) {\n\t\tint i = 10000;\n\t\tstruct tsi721_tx_desc *desc;\n\n\t\tdesc = bdma_chan->active_tx;\n\t\tdmac_sts = ioread32(bdma_chan->regs + TSI721_DMAC_STS);\n\t\ttsi_err(&bdma_chan->dchan.dev->device,\n\t\t\t\"DMAC%d_STS = 0x%x did=%d raddr=0x%llx\",\n\t\t\tbdma_chan->id, dmac_sts, desc->destid, desc->rio_addr);\n\n\t\t \n\n\t\tif ((dmac_sts & TSI721_DMAC_STS_ABORT) == 0)\n\t\t\tgoto err_out;\n\n\t\ttsi721_clr_stat(bdma_chan);\n\n\t\tspin_lock(&bdma_chan->lock);\n\n\t\t \n\t\tiowrite32(TSI721_DMAC_CTL_INIT,\n\t\t\t  bdma_chan->regs + TSI721_DMAC_CTL);\n\t\tdo {\n\t\t\tudelay(1);\n\t\t\tdmac_sts = ioread32(bdma_chan->regs + TSI721_DMAC_STS);\n\t\t\ti--;\n\t\t} while ((dmac_sts & TSI721_DMAC_STS_ABORT) && i);\n\n\t\tif (dmac_sts & TSI721_DMAC_STS_ABORT) {\n\t\t\ttsi_err(&bdma_chan->dchan.dev->device,\n\t\t\t\t\"Failed to re-initiate DMAC%d\",\tbdma_chan->id);\n\t\t\tspin_unlock(&bdma_chan->lock);\n\t\t\tgoto err_out;\n\t\t}\n\n\t\t \n\t\tiowrite32(((u64)bdma_chan->bd_phys >> 32),\n\t\t\tbdma_chan->regs + TSI721_DMAC_DPTRH);\n\t\tiowrite32(((u64)bdma_chan->bd_phys & TSI721_DMAC_DPTRL_MASK),\n\t\t\tbdma_chan->regs + TSI721_DMAC_DPTRL);\n\n\t\t \n\t\tiowrite32(((u64)bdma_chan->sts_phys >> 32),\n\t\t\tbdma_chan->regs + TSI721_DMAC_DSBH);\n\t\tiowrite32(((u64)bdma_chan->sts_phys & TSI721_DMAC_DSBL_MASK),\n\t\t\tbdma_chan->regs + TSI721_DMAC_DSBL);\n\t\tiowrite32(TSI721_DMAC_DSSZ_SIZE(bdma_chan->sts_size),\n\t\t\tbdma_chan->regs + TSI721_DMAC_DSSZ);\n\n\t\t \n\t\tiowrite32(TSI721_DMAC_INT_ALL,\n\t\t\tbdma_chan->regs + TSI721_DMAC_INT);\n\n\t\tioread32(bdma_chan->regs + TSI721_DMAC_INT);\n\n\t\tbdma_chan->wr_count = bdma_chan->wr_count_next = 0;\n\t\tbdma_chan->sts_rdptr = 0;\n\t\tudelay(10);\n\n\t\tdesc = bdma_chan->active_tx;\n\t\tdesc->status = DMA_ERROR;\n\t\tdma_cookie_complete(&desc->txd);\n\t\tlist_add(&desc->desc_node, &bdma_chan->free_list);\n\t\tbdma_chan->active_tx = NULL;\n\t\tif (bdma_chan->active)\n\t\t\ttsi721_advance_work(bdma_chan, NULL);\n\t\tspin_unlock(&bdma_chan->lock);\n\t}\n\n\tif (dmac_int & TSI721_DMAC_INT_STFULL) {\n\t\ttsi_err(&bdma_chan->dchan.dev->device,\n\t\t\t\"DMAC%d descriptor status FIFO is full\",\n\t\t\tbdma_chan->id);\n\t}\n\n\tif (dmac_int & (TSI721_DMAC_INT_DONE | TSI721_DMAC_INT_IOFDONE)) {\n\t\tstruct tsi721_tx_desc *desc;\n\n\t\ttsi721_clr_stat(bdma_chan);\n\t\tspin_lock(&bdma_chan->lock);\n\t\tdesc = bdma_chan->active_tx;\n\n\t\tif (desc->sg_len == 0) {\n\t\t\tdma_async_tx_callback callback = NULL;\n\t\t\tvoid *param = NULL;\n\n\t\t\tdesc->status = DMA_COMPLETE;\n\t\t\tdma_cookie_complete(&desc->txd);\n\t\t\tif (desc->txd.flags & DMA_PREP_INTERRUPT) {\n\t\t\t\tcallback = desc->txd.callback;\n\t\t\t\tparam = desc->txd.callback_param;\n\t\t\t}\n\t\t\tlist_add(&desc->desc_node, &bdma_chan->free_list);\n\t\t\tbdma_chan->active_tx = NULL;\n\t\t\tif (bdma_chan->active)\n\t\t\t\ttsi721_advance_work(bdma_chan, NULL);\n\t\t\tspin_unlock(&bdma_chan->lock);\n\t\t\tif (callback)\n\t\t\t\tcallback(param);\n\t\t} else {\n\t\t\tif (bdma_chan->active)\n\t\t\t\ttsi721_advance_work(bdma_chan,\n\t\t\t\t\t\t    bdma_chan->active_tx);\n\t\t\tspin_unlock(&bdma_chan->lock);\n\t\t}\n\t}\nerr_out:\n\t \n\tiowrite32(TSI721_DMAC_INT_ALL, bdma_chan->regs + TSI721_DMAC_INTE);\n}\n\nstatic dma_cookie_t tsi721_tx_submit(struct dma_async_tx_descriptor *txd)\n{\n\tstruct tsi721_tx_desc *desc = to_tsi721_desc(txd);\n\tstruct tsi721_bdma_chan *bdma_chan = to_tsi721_chan(txd->chan);\n\tdma_cookie_t cookie;\n\n\t \n\tif (!list_empty(&desc->desc_node)) {\n\t\ttsi_err(&bdma_chan->dchan.dev->device,\n\t\t\t\"DMAC%d wrong state of descriptor %p\",\n\t\t\tbdma_chan->id, txd);\n\t\treturn -EIO;\n\t}\n\n\tspin_lock_bh(&bdma_chan->lock);\n\n\tif (!bdma_chan->active) {\n\t\tspin_unlock_bh(&bdma_chan->lock);\n\t\treturn -ENODEV;\n\t}\n\n\tcookie = dma_cookie_assign(txd);\n\tdesc->status = DMA_IN_PROGRESS;\n\tlist_add_tail(&desc->desc_node, &bdma_chan->queue);\n\ttsi721_advance_work(bdma_chan, NULL);\n\n\tspin_unlock_bh(&bdma_chan->lock);\n\treturn cookie;\n}\n\nstatic int tsi721_alloc_chan_resources(struct dma_chan *dchan)\n{\n\tstruct tsi721_bdma_chan *bdma_chan = to_tsi721_chan(dchan);\n\tstruct tsi721_tx_desc *desc;\n\tint i;\n\n\ttsi_debug(DMA, &dchan->dev->device, \"DMAC%d\", bdma_chan->id);\n\n\tif (bdma_chan->bd_base)\n\t\treturn dma_txqueue_sz;\n\n\t \n\tif (tsi721_bdma_ch_init(bdma_chan, dma_desc_per_channel)) {\n\t\ttsi_err(&dchan->dev->device, \"Unable to initialize DMAC%d\",\n\t\t\tbdma_chan->id);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tdesc = kcalloc(dma_txqueue_sz, sizeof(struct tsi721_tx_desc),\n\t\t\tGFP_ATOMIC);\n\tif (!desc) {\n\t\ttsi721_bdma_ch_free(bdma_chan);\n\t\treturn -ENOMEM;\n\t}\n\n\tbdma_chan->tx_desc = desc;\n\n\tfor (i = 0; i < dma_txqueue_sz; i++) {\n\t\tdma_async_tx_descriptor_init(&desc[i].txd, dchan);\n\t\tdesc[i].txd.tx_submit = tsi721_tx_submit;\n\t\tdesc[i].txd.flags = DMA_CTRL_ACK;\n\t\tlist_add(&desc[i].desc_node, &bdma_chan->free_list);\n\t}\n\n\tdma_cookie_init(dchan);\n\n\tbdma_chan->active = true;\n\ttsi721_bdma_interrupt_enable(bdma_chan, 1);\n\n\treturn dma_txqueue_sz;\n}\n\nstatic void tsi721_sync_dma_irq(struct tsi721_bdma_chan *bdma_chan)\n{\n\tstruct tsi721_device *priv = to_tsi721(bdma_chan->dchan.device);\n\n#ifdef CONFIG_PCI_MSI\n\tif (priv->flags & TSI721_USING_MSIX) {\n\t\tsynchronize_irq(priv->msix[TSI721_VECT_DMA0_DONE +\n\t\t\t\t\t   bdma_chan->id].vector);\n\t\tsynchronize_irq(priv->msix[TSI721_VECT_DMA0_INT +\n\t\t\t\t\t   bdma_chan->id].vector);\n\t} else\n#endif\n\tsynchronize_irq(priv->pdev->irq);\n}\n\nstatic void tsi721_free_chan_resources(struct dma_chan *dchan)\n{\n\tstruct tsi721_bdma_chan *bdma_chan = to_tsi721_chan(dchan);\n\n\ttsi_debug(DMA, &dchan->dev->device, \"DMAC%d\", bdma_chan->id);\n\n\tif (!bdma_chan->bd_base)\n\t\treturn;\n\n\ttsi721_bdma_interrupt_enable(bdma_chan, 0);\n\tbdma_chan->active = false;\n\ttsi721_sync_dma_irq(bdma_chan);\n\ttasklet_kill(&bdma_chan->tasklet);\n\tINIT_LIST_HEAD(&bdma_chan->free_list);\n\tkfree(bdma_chan->tx_desc);\n\ttsi721_bdma_ch_free(bdma_chan);\n}\n\nstatic\nenum dma_status tsi721_tx_status(struct dma_chan *dchan, dma_cookie_t cookie,\n\t\t\t\t struct dma_tx_state *txstate)\n{\n\tstruct tsi721_bdma_chan *bdma_chan = to_tsi721_chan(dchan);\n\tenum dma_status\tstatus;\n\n\tspin_lock_bh(&bdma_chan->lock);\n\tstatus = dma_cookie_status(dchan, cookie, txstate);\n\tspin_unlock_bh(&bdma_chan->lock);\n\treturn status;\n}\n\nstatic void tsi721_issue_pending(struct dma_chan *dchan)\n{\n\tstruct tsi721_bdma_chan *bdma_chan = to_tsi721_chan(dchan);\n\n\ttsi_debug(DMA, &dchan->dev->device, \"DMAC%d\", bdma_chan->id);\n\n\tspin_lock_bh(&bdma_chan->lock);\n\tif (tsi721_dma_is_idle(bdma_chan) && bdma_chan->active) {\n\t\ttsi721_advance_work(bdma_chan, NULL);\n\t}\n\tspin_unlock_bh(&bdma_chan->lock);\n}\n\nstatic\nstruct dma_async_tx_descriptor *tsi721_prep_rio_sg(struct dma_chan *dchan,\n\t\t\tstruct scatterlist *sgl, unsigned int sg_len,\n\t\t\tenum dma_transfer_direction dir, unsigned long flags,\n\t\t\tvoid *tinfo)\n{\n\tstruct tsi721_bdma_chan *bdma_chan = to_tsi721_chan(dchan);\n\tstruct tsi721_tx_desc *desc;\n\tstruct rio_dma_ext *rext = tinfo;\n\tenum dma_rtype rtype;\n\tstruct dma_async_tx_descriptor *txd = NULL;\n\n\tif (!sgl || !sg_len) {\n\t\ttsi_err(&dchan->dev->device, \"DMAC%d No SG list\",\n\t\t\tbdma_chan->id);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\ttsi_debug(DMA, &dchan->dev->device, \"DMAC%d %s\", bdma_chan->id,\n\t\t  (dir == DMA_DEV_TO_MEM)?\"READ\":\"WRITE\");\n\n\tif (dir == DMA_DEV_TO_MEM)\n\t\trtype = NREAD;\n\telse if (dir == DMA_MEM_TO_DEV) {\n\t\tswitch (rext->wr_type) {\n\t\tcase RDW_ALL_NWRITE:\n\t\t\trtype = ALL_NWRITE;\n\t\t\tbreak;\n\t\tcase RDW_ALL_NWRITE_R:\n\t\t\trtype = ALL_NWRITE_R;\n\t\t\tbreak;\n\t\tcase RDW_LAST_NWRITE_R:\n\t\tdefault:\n\t\t\trtype = LAST_NWRITE_R;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\ttsi_err(&dchan->dev->device,\n\t\t\t\"DMAC%d Unsupported DMA direction option\",\n\t\t\tbdma_chan->id);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tspin_lock_bh(&bdma_chan->lock);\n\n\tif (!list_empty(&bdma_chan->free_list)) {\n\t\tdesc = list_first_entry(&bdma_chan->free_list,\n\t\t\t\tstruct tsi721_tx_desc, desc_node);\n\t\tlist_del_init(&desc->desc_node);\n\t\tdesc->destid = rext->destid;\n\t\tdesc->rio_addr = rext->rio_addr;\n\t\tdesc->rio_addr_u = 0;\n\t\tdesc->rtype = rtype;\n\t\tdesc->sg_len\t= sg_len;\n\t\tdesc->sg\t= sgl;\n\t\ttxd\t\t= &desc->txd;\n\t\ttxd->flags\t= flags;\n\t}\n\n\tspin_unlock_bh(&bdma_chan->lock);\n\n\tif (!txd) {\n\t\ttsi_debug(DMA, &dchan->dev->device,\n\t\t\t  \"DMAC%d free TXD is not available\", bdma_chan->id);\n\t\treturn ERR_PTR(-EBUSY);\n\t}\n\n\treturn txd;\n}\n\nstatic int tsi721_terminate_all(struct dma_chan *dchan)\n{\n\tstruct tsi721_bdma_chan *bdma_chan = to_tsi721_chan(dchan);\n\tstruct tsi721_tx_desc *desc, *_d;\n\tLIST_HEAD(list);\n\n\ttsi_debug(DMA, &dchan->dev->device, \"DMAC%d\", bdma_chan->id);\n\n\tspin_lock_bh(&bdma_chan->lock);\n\n\tbdma_chan->active = false;\n\n\twhile (!tsi721_dma_is_idle(bdma_chan)) {\n\n\t\tudelay(5);\n#if (0)\n\t\t \n\t\tiowrite32(TSI721_DMAC_CTL_SUSP,\n\t\t\t  bdma_chan->regs + TSI721_DMAC_CTL);\n\n\t\t \n\t\tdo {\n\t\t\tdmac_int = ioread32(bdma_chan->regs + TSI721_DMAC_INT);\n\t\t} while ((dmac_int & TSI721_DMAC_INT_SUSP) == 0);\n#endif\n\t}\n\n\tif (bdma_chan->active_tx)\n\t\tlist_add(&bdma_chan->active_tx->desc_node, &list);\n\tlist_splice_init(&bdma_chan->queue, &list);\n\n\tlist_for_each_entry_safe(desc, _d, &list, desc_node)\n\t\ttsi721_dma_tx_err(bdma_chan, desc);\n\n\tspin_unlock_bh(&bdma_chan->lock);\n\n\treturn 0;\n}\n\nstatic void tsi721_dma_stop(struct tsi721_bdma_chan *bdma_chan)\n{\n\tif (!bdma_chan->active)\n\t\treturn;\n\tspin_lock_bh(&bdma_chan->lock);\n\tif (!tsi721_dma_is_idle(bdma_chan)) {\n\t\tint timeout = 100000;\n\n\t\t \n\t\tiowrite32(TSI721_DMAC_CTL_SUSP,\n\t\t\t  bdma_chan->regs + TSI721_DMAC_CTL);\n\n\t\t \n\t\twhile (!tsi721_dma_is_idle(bdma_chan) && --timeout)\n\t\t\tudelay(1);\n\t}\n\n\tspin_unlock_bh(&bdma_chan->lock);\n}\n\nvoid tsi721_dma_stop_all(struct tsi721_device *priv)\n{\n\tint i;\n\n\tfor (i = 0; i < TSI721_DMA_MAXCH; i++) {\n\t\tif ((i != TSI721_DMACH_MAINT) && (dma_sel & (1 << i)))\n\t\t\ttsi721_dma_stop(&priv->bdma[i]);\n\t}\n}\n\nint tsi721_register_dma(struct tsi721_device *priv)\n{\n\tint i;\n\tint nr_channels = 0;\n\tint err;\n\tstruct rio_mport *mport = &priv->mport;\n\n\tINIT_LIST_HEAD(&mport->dma.channels);\n\n\tfor (i = 0; i < TSI721_DMA_MAXCH; i++) {\n\t\tstruct tsi721_bdma_chan *bdma_chan = &priv->bdma[i];\n\n\t\tif ((i == TSI721_DMACH_MAINT) || (dma_sel & (1 << i)) == 0)\n\t\t\tcontinue;\n\n\t\tbdma_chan->regs = priv->regs + TSI721_DMAC_BASE(i);\n\n\t\tbdma_chan->dchan.device = &mport->dma;\n\t\tbdma_chan->dchan.cookie = 1;\n\t\tbdma_chan->dchan.chan_id = i;\n\t\tbdma_chan->id = i;\n\t\tbdma_chan->active = false;\n\n\t\tspin_lock_init(&bdma_chan->lock);\n\n\t\tbdma_chan->active_tx = NULL;\n\t\tINIT_LIST_HEAD(&bdma_chan->queue);\n\t\tINIT_LIST_HEAD(&bdma_chan->free_list);\n\n\t\ttasklet_init(&bdma_chan->tasklet, tsi721_dma_tasklet,\n\t\t\t     (unsigned long)bdma_chan);\n\t\tlist_add_tail(&bdma_chan->dchan.device_node,\n\t\t\t      &mport->dma.channels);\n\t\tnr_channels++;\n\t}\n\n\tmport->dma.chancnt = nr_channels;\n\tdma_cap_zero(mport->dma.cap_mask);\n\tdma_cap_set(DMA_PRIVATE, mport->dma.cap_mask);\n\tdma_cap_set(DMA_SLAVE, mport->dma.cap_mask);\n\n\tmport->dma.dev = &priv->pdev->dev;\n\tmport->dma.device_alloc_chan_resources = tsi721_alloc_chan_resources;\n\tmport->dma.device_free_chan_resources = tsi721_free_chan_resources;\n\tmport->dma.device_tx_status = tsi721_tx_status;\n\tmport->dma.device_issue_pending = tsi721_issue_pending;\n\tmport->dma.device_prep_slave_sg = tsi721_prep_rio_sg;\n\tmport->dma.device_terminate_all = tsi721_terminate_all;\n\n\terr = dma_async_device_register(&mport->dma);\n\tif (err)\n\t\ttsi_err(&priv->pdev->dev, \"Failed to register DMA device\");\n\n\treturn err;\n}\n\nvoid tsi721_unregister_dma(struct tsi721_device *priv)\n{\n\tstruct rio_mport *mport = &priv->mport;\n\tstruct dma_chan *chan, *_c;\n\tstruct tsi721_bdma_chan *bdma_chan;\n\n\ttsi721_dma_stop_all(priv);\n\tdma_async_device_unregister(&mport->dma);\n\n\tlist_for_each_entry_safe(chan, _c, &mport->dma.channels,\n\t\t\t\t\tdevice_node) {\n\t\tbdma_chan = to_tsi721_chan(chan);\n\t\tif (bdma_chan->active) {\n\t\t\ttsi721_bdma_interrupt_enable(bdma_chan, 0);\n\t\t\tbdma_chan->active = false;\n\t\t\ttsi721_sync_dma_irq(bdma_chan);\n\t\t\ttasklet_kill(&bdma_chan->tasklet);\n\t\t\tINIT_LIST_HEAD(&bdma_chan->free_list);\n\t\t\tkfree(bdma_chan->tx_desc);\n\t\t\ttsi721_bdma_ch_free(bdma_chan);\n\t\t}\n\n\t\tlist_del(&chan->device_node);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}