{
  "module_name": "tsi721.c",
  "hash_id": "a64c216cb3953d1bddc69606d1de88d0ce582a190ec513d8163997249ea1379a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rapidio/devices/tsi721.c",
  "human_readable_source": "\n \n\n#include <linux/io.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/rio.h>\n#include <linux/rio_drv.h>\n#include <linux/dma-mapping.h>\n#include <linux/interrupt.h>\n#include <linux/kfifo.h>\n#include <linux/delay.h>\n\n#include \"tsi721.h\"\n\n#ifdef DEBUG\nu32 tsi_dbg_level;\nmodule_param_named(dbg_level, tsi_dbg_level, uint, S_IWUSR | S_IRUGO);\nMODULE_PARM_DESC(dbg_level, \"Debugging output level (default 0 = none)\");\n#endif\n\nstatic int pcie_mrrs = -1;\nmodule_param(pcie_mrrs, int, S_IRUGO);\nMODULE_PARM_DESC(pcie_mrrs, \"PCIe MRRS override value (0...5)\");\n\nstatic u8 mbox_sel = 0x0f;\nmodule_param(mbox_sel, byte, S_IRUGO);\nMODULE_PARM_DESC(mbox_sel,\n\t\t \"RIO Messaging MBOX Selection Mask (default: 0x0f = all)\");\n\nstatic DEFINE_SPINLOCK(tsi721_maint_lock);\n\nstatic void tsi721_omsg_handler(struct tsi721_device *priv, int ch);\nstatic void tsi721_imsg_handler(struct tsi721_device *priv, int ch);\n\n \nstatic int tsi721_lcread(struct rio_mport *mport, int index, u32 offset,\n\t\t\t int len, u32 *data)\n{\n\tstruct tsi721_device *priv = mport->priv;\n\n\tif (len != sizeof(u32))\n\t\treturn -EINVAL;  \n\n\t*data = ioread32(priv->regs + offset);\n\n\treturn 0;\n}\n\n \nstatic int tsi721_lcwrite(struct rio_mport *mport, int index, u32 offset,\n\t\t\t  int len, u32 data)\n{\n\tstruct tsi721_device *priv = mport->priv;\n\n\tif (len != sizeof(u32))\n\t\treturn -EINVAL;  \n\n\tiowrite32(data, priv->regs + offset);\n\n\treturn 0;\n}\n\n \nstatic int tsi721_maint_dma(struct tsi721_device *priv, u32 sys_size,\n\t\t\tu16 destid, u8 hopcount, u32 offset, int len,\n\t\t\tu32 *data, int do_wr)\n{\n\tvoid __iomem *regs = priv->regs + TSI721_DMAC_BASE(priv->mdma.ch_id);\n\tstruct tsi721_dma_desc *bd_ptr;\n\tu32 rd_count, swr_ptr, ch_stat;\n\tunsigned long flags;\n\tint i, err = 0;\n\tu32 op = do_wr ? MAINT_WR : MAINT_RD;\n\n\tif (offset > (RIO_MAINT_SPACE_SZ - len) || (len != sizeof(u32)))\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&tsi721_maint_lock, flags);\n\n\tbd_ptr = priv->mdma.bd_base;\n\n\trd_count = ioread32(regs + TSI721_DMAC_DRDCNT);\n\n\t \n\tbd_ptr[0].type_id = cpu_to_le32((DTYPE2 << 29) | (op << 19) | destid);\n\tbd_ptr[0].bcount = cpu_to_le32((sys_size << 26) | 0x04);\n\tbd_ptr[0].raddr_lo = cpu_to_le32((hopcount << 24) | offset);\n\tbd_ptr[0].raddr_hi = 0;\n\tif (do_wr)\n\t\tbd_ptr[0].data[0] = cpu_to_be32p(data);\n\telse\n\t\tbd_ptr[0].data[0] = 0xffffffff;\n\n\tmb();\n\n\t \n\tiowrite32(rd_count + 2,\tregs + TSI721_DMAC_DWRCNT);\n\tioread32(regs + TSI721_DMAC_DWRCNT);\n\ti = 0;\n\n\t \n\twhile ((ch_stat = ioread32(regs + TSI721_DMAC_STS))\n\t\t\t\t\t\t\t& TSI721_DMAC_STS_RUN) {\n\t\tudelay(1);\n\t\tif (++i >= 5000000) {\n\t\t\ttsi_debug(MAINT, &priv->pdev->dev,\n\t\t\t\t\"DMA[%d] read timeout ch_status=%x\",\n\t\t\t\tpriv->mdma.ch_id, ch_stat);\n\t\t\tif (!do_wr)\n\t\t\t\t*data = 0xffffffff;\n\t\t\terr = -EIO;\n\t\t\tgoto err_out;\n\t\t}\n\t}\n\n\tif (ch_stat & TSI721_DMAC_STS_ABORT) {\n\t\t \n\t\ttsi_debug(MAINT, &priv->pdev->dev, \"DMA ABORT ch_stat=%x\",\n\t\t\t  ch_stat);\n\t\ttsi_debug(MAINT, &priv->pdev->dev,\n\t\t\t  \"OP=%d : destid=%x hc=%x off=%x\",\n\t\t\t  do_wr ? MAINT_WR : MAINT_RD,\n\t\t\t  destid, hopcount, offset);\n\t\tiowrite32(TSI721_DMAC_INT_ALL, regs + TSI721_DMAC_INT);\n\t\tiowrite32(TSI721_DMAC_CTL_INIT, regs + TSI721_DMAC_CTL);\n\t\tudelay(10);\n\t\tiowrite32(0, regs + TSI721_DMAC_DWRCNT);\n\t\tudelay(1);\n\t\tif (!do_wr)\n\t\t\t*data = 0xffffffff;\n\t\terr = -EIO;\n\t\tgoto err_out;\n\t}\n\n\tif (!do_wr)\n\t\t*data = be32_to_cpu(bd_ptr[0].data[0]);\n\n\t \n\tswr_ptr = ioread32(regs + TSI721_DMAC_DSWP);\n\tiowrite32(swr_ptr, regs + TSI721_DMAC_DSRP);\n\nerr_out:\n\tspin_unlock_irqrestore(&tsi721_maint_lock, flags);\n\n\treturn err;\n}\n\n \nstatic int tsi721_cread_dma(struct rio_mport *mport, int index, u16 destid,\n\t\t\tu8 hopcount, u32 offset, int len, u32 *data)\n{\n\tstruct tsi721_device *priv = mport->priv;\n\n\treturn tsi721_maint_dma(priv, mport->sys_size, destid, hopcount,\n\t\t\t\toffset, len, data, 0);\n}\n\n \nstatic int tsi721_cwrite_dma(struct rio_mport *mport, int index, u16 destid,\n\t\t\t u8 hopcount, u32 offset, int len, u32 data)\n{\n\tstruct tsi721_device *priv = mport->priv;\n\tu32 temp = data;\n\n\treturn tsi721_maint_dma(priv, mport->sys_size, destid, hopcount,\n\t\t\t\toffset, len, &temp, 1);\n}\n\n \nstatic int\ntsi721_pw_handler(struct tsi721_device *priv)\n{\n\tu32 pw_stat;\n\tu32 pw_buf[TSI721_RIO_PW_MSG_SIZE/sizeof(u32)];\n\n\n\tpw_stat = ioread32(priv->regs + TSI721_RIO_PW_RX_STAT);\n\n\tif (pw_stat & TSI721_RIO_PW_RX_STAT_PW_VAL) {\n\t\tpw_buf[0] = ioread32(priv->regs + TSI721_RIO_PW_RX_CAPT(0));\n\t\tpw_buf[1] = ioread32(priv->regs + TSI721_RIO_PW_RX_CAPT(1));\n\t\tpw_buf[2] = ioread32(priv->regs + TSI721_RIO_PW_RX_CAPT(2));\n\t\tpw_buf[3] = ioread32(priv->regs + TSI721_RIO_PW_RX_CAPT(3));\n\n\t\t \n\t\tspin_lock(&priv->pw_fifo_lock);\n\t\tif (kfifo_avail(&priv->pw_fifo) >= TSI721_RIO_PW_MSG_SIZE)\n\t\t\tkfifo_in(&priv->pw_fifo, pw_buf,\n\t\t\t\t\t\tTSI721_RIO_PW_MSG_SIZE);\n\t\telse\n\t\t\tpriv->pw_discard_count++;\n\t\tspin_unlock(&priv->pw_fifo_lock);\n\t}\n\n\t \n\tiowrite32(TSI721_RIO_PW_RX_STAT_PW_DISC | TSI721_RIO_PW_RX_STAT_PW_VAL,\n\t\t  priv->regs + TSI721_RIO_PW_RX_STAT);\n\n\tschedule_work(&priv->pw_work);\n\n\treturn 0;\n}\n\nstatic void tsi721_pw_dpc(struct work_struct *work)\n{\n\tstruct tsi721_device *priv = container_of(work, struct tsi721_device,\n\t\t\t\t\t\t    pw_work);\n\tunion rio_pw_msg pwmsg;\n\n\t \n\twhile (kfifo_out_spinlocked(&priv->pw_fifo, (unsigned char *)&pwmsg,\n\t\t\t TSI721_RIO_PW_MSG_SIZE, &priv->pw_fifo_lock)) {\n\t\t \n\t\trio_inb_pwrite_handler(&priv->mport, &pwmsg);\n\t}\n}\n\n \nstatic int tsi721_pw_enable(struct rio_mport *mport, int enable)\n{\n\tstruct tsi721_device *priv = mport->priv;\n\tu32 rval;\n\n\trval = ioread32(priv->regs + TSI721_RIO_EM_INT_ENABLE);\n\n\tif (enable)\n\t\trval |= TSI721_RIO_EM_INT_ENABLE_PW_RX;\n\telse\n\t\trval &= ~TSI721_RIO_EM_INT_ENABLE_PW_RX;\n\n\t \n\tiowrite32(TSI721_RIO_PW_RX_STAT_PW_DISC | TSI721_RIO_PW_RX_STAT_PW_VAL,\n\t\t  priv->regs + TSI721_RIO_PW_RX_STAT);\n\t \n\tiowrite32(rval, priv->regs + TSI721_RIO_EM_INT_ENABLE);\n\n\treturn 0;\n}\n\n \nstatic int tsi721_dsend(struct rio_mport *mport, int index,\n\t\t\tu16 destid, u16 data)\n{\n\tstruct tsi721_device *priv = mport->priv;\n\tu32 offset;\n\n\toffset = (((mport->sys_size) ? RIO_TT_CODE_16 : RIO_TT_CODE_8) << 18) |\n\t\t (destid << 2);\n\n\ttsi_debug(DBELL, &priv->pdev->dev,\n\t\t  \"Send Doorbell 0x%04x to destID 0x%x\", data, destid);\n\tiowrite16be(data, priv->odb_base + offset);\n\n\treturn 0;\n}\n\n \nstatic int\ntsi721_dbell_handler(struct tsi721_device *priv)\n{\n\tu32 regval;\n\n\t \n\tregval = ioread32(priv->regs + TSI721_SR_CHINTE(IDB_QUEUE));\n\tregval &= ~TSI721_SR_CHINT_IDBQRCV;\n\tiowrite32(regval,\n\t\tpriv->regs + TSI721_SR_CHINTE(IDB_QUEUE));\n\n\tschedule_work(&priv->idb_work);\n\n\treturn 0;\n}\n\nstatic void tsi721_db_dpc(struct work_struct *work)\n{\n\tstruct tsi721_device *priv = container_of(work, struct tsi721_device,\n\t\t\t\t\t\t    idb_work);\n\tstruct rio_mport *mport;\n\tstruct rio_dbell *dbell;\n\tint found = 0;\n\tu32 wr_ptr, rd_ptr;\n\tu64 *idb_entry;\n\tu32 regval;\n\tunion {\n\t\tu64 msg;\n\t\tu8  bytes[8];\n\t} idb;\n\n\t \n\tmport = &priv->mport;\n\n\twr_ptr = ioread32(priv->regs + TSI721_IDQ_WP(IDB_QUEUE)) % IDB_QSIZE;\n\trd_ptr = ioread32(priv->regs + TSI721_IDQ_RP(IDB_QUEUE)) % IDB_QSIZE;\n\n\twhile (wr_ptr != rd_ptr) {\n\t\tidb_entry = (u64 *)(priv->idb_base +\n\t\t\t\t\t(TSI721_IDB_ENTRY_SIZE * rd_ptr));\n\t\trd_ptr++;\n\t\trd_ptr %= IDB_QSIZE;\n\t\tidb.msg = *idb_entry;\n\t\t*idb_entry = 0;\n\n\t\t \n\t\tlist_for_each_entry(dbell, &mport->dbells, node) {\n\t\t\tif ((dbell->res->start <= DBELL_INF(idb.bytes)) &&\n\t\t\t    (dbell->res->end >= DBELL_INF(idb.bytes))) {\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (found) {\n\t\t\tdbell->dinb(mport, dbell->dev_id, DBELL_SID(idb.bytes),\n\t\t\t\t    DBELL_TID(idb.bytes), DBELL_INF(idb.bytes));\n\t\t} else {\n\t\t\ttsi_debug(DBELL, &priv->pdev->dev,\n\t\t\t\t  \"spurious IDB sid %2.2x tid %2.2x info %4.4x\",\n\t\t\t\t  DBELL_SID(idb.bytes), DBELL_TID(idb.bytes),\n\t\t\t\t  DBELL_INF(idb.bytes));\n\t\t}\n\n\t\twr_ptr = ioread32(priv->regs +\n\t\t\t\t  TSI721_IDQ_WP(IDB_QUEUE)) % IDB_QSIZE;\n\t}\n\n\tiowrite32(rd_ptr & (IDB_QSIZE - 1),\n\t\tpriv->regs + TSI721_IDQ_RP(IDB_QUEUE));\n\n\t \n\tregval = ioread32(priv->regs + TSI721_SR_CHINTE(IDB_QUEUE));\n\tregval |= TSI721_SR_CHINT_IDBQRCV;\n\tiowrite32(regval,\n\t\tpriv->regs + TSI721_SR_CHINTE(IDB_QUEUE));\n\n\twr_ptr = ioread32(priv->regs + TSI721_IDQ_WP(IDB_QUEUE)) % IDB_QSIZE;\n\tif (wr_ptr != rd_ptr)\n\t\tschedule_work(&priv->idb_work);\n}\n\n \nstatic irqreturn_t tsi721_irqhandler(int irq, void *ptr)\n{\n\tstruct tsi721_device *priv = (struct tsi721_device *)ptr;\n\tu32 dev_int;\n\tu32 dev_ch_int;\n\tu32 intval;\n\tu32 ch_inte;\n\n\t \n\tif (priv->flags & TSI721_USING_MSI)\n\t\tiowrite32(0, priv->regs + TSI721_DEV_INTE);\n\n\tdev_int = ioread32(priv->regs + TSI721_DEV_INT);\n\tif (!dev_int)\n\t\treturn IRQ_NONE;\n\n\tdev_ch_int = ioread32(priv->regs + TSI721_DEV_CHAN_INT);\n\n\tif (dev_int & TSI721_DEV_INT_SR2PC_CH) {\n\t\t \n\t\tif (dev_ch_int & TSI721_INT_SR2PC_CHAN(IDB_QUEUE)) {\n\t\t\t \n\t\t\tintval = ioread32(priv->regs +\n\t\t\t\t\t\tTSI721_SR_CHINT(IDB_QUEUE));\n\t\t\tif (intval & TSI721_SR_CHINT_IDBQRCV)\n\t\t\t\ttsi721_dbell_handler(priv);\n\t\t\telse\n\t\t\t\ttsi_info(&priv->pdev->dev,\n\t\t\t\t\t\"Unsupported SR_CH_INT %x\", intval);\n\n\t\t\t \n\t\t\tiowrite32(intval,\n\t\t\t\tpriv->regs + TSI721_SR_CHINT(IDB_QUEUE));\n\t\t\tioread32(priv->regs + TSI721_SR_CHINT(IDB_QUEUE));\n\t\t}\n\t}\n\n\tif (dev_int & TSI721_DEV_INT_SMSG_CH) {\n\t\tint ch;\n\n\t\t \n\n\t\tif (dev_ch_int & TSI721_INT_IMSG_CHAN_M) {  \n\t\t\t \n\t\t\tch_inte = ioread32(priv->regs + TSI721_DEV_CHAN_INTE);\n\t\t\tch_inte &= ~(dev_ch_int & TSI721_INT_IMSG_CHAN_M);\n\t\t\tiowrite32(ch_inte, priv->regs + TSI721_DEV_CHAN_INTE);\n\n\t\t\t \n\t\t\tfor (ch = 4; ch < RIO_MAX_MBOX + 4; ch++) {\n\t\t\t\tif (!(dev_ch_int & TSI721_INT_IMSG_CHAN(ch)))\n\t\t\t\t\tcontinue;\n\t\t\t\ttsi721_imsg_handler(priv, ch);\n\t\t\t}\n\t\t}\n\n\t\tif (dev_ch_int & TSI721_INT_OMSG_CHAN_M) {  \n\t\t\t \n\t\t\tch_inte = ioread32(priv->regs + TSI721_DEV_CHAN_INTE);\n\t\t\tch_inte &= ~(dev_ch_int & TSI721_INT_OMSG_CHAN_M);\n\t\t\tiowrite32(ch_inte, priv->regs + TSI721_DEV_CHAN_INTE);\n\n\t\t\t \n\n\t\t\tfor (ch = 0; ch < RIO_MAX_MBOX; ch++) {\n\t\t\t\tif (!(dev_ch_int & TSI721_INT_OMSG_CHAN(ch)))\n\t\t\t\t\tcontinue;\n\t\t\t\ttsi721_omsg_handler(priv, ch);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (dev_int & TSI721_DEV_INT_SRIO) {\n\t\t \n\t\tintval = ioread32(priv->regs + TSI721_RIO_EM_INT_STAT);\n\t\tif (intval & TSI721_RIO_EM_INT_STAT_PW_RX)\n\t\t\ttsi721_pw_handler(priv);\n\t}\n\n#ifdef CONFIG_RAPIDIO_DMA_ENGINE\n\tif (dev_int & TSI721_DEV_INT_BDMA_CH) {\n\t\tint ch;\n\n\t\tif (dev_ch_int & TSI721_INT_BDMA_CHAN_M) {\n\t\t\ttsi_debug(DMA, &priv->pdev->dev,\n\t\t\t\t  \"IRQ from DMA channel 0x%08x\", dev_ch_int);\n\n\t\t\tfor (ch = 0; ch < TSI721_DMA_MAXCH; ch++) {\n\t\t\t\tif (!(dev_ch_int & TSI721_INT_BDMA_CHAN(ch)))\n\t\t\t\t\tcontinue;\n\t\t\t\ttsi721_bdma_handler(&priv->bdma[ch]);\n\t\t\t}\n\t\t}\n\t}\n#endif\n\n\t \n\tif (priv->flags & TSI721_USING_MSI) {\n\t\tdev_int = TSI721_DEV_INT_SR2PC_CH | TSI721_DEV_INT_SRIO |\n\t\t\tTSI721_DEV_INT_SMSG_CH | TSI721_DEV_INT_BDMA_CH;\n\t\tiowrite32(dev_int, priv->regs + TSI721_DEV_INTE);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void tsi721_interrupts_init(struct tsi721_device *priv)\n{\n\tu32 intr;\n\n\t \n\tiowrite32(TSI721_SR_CHINT_ALL,\n\t\tpriv->regs + TSI721_SR_CHINT(IDB_QUEUE));\n\tiowrite32(TSI721_SR_CHINT_IDBQRCV,\n\t\tpriv->regs + TSI721_SR_CHINTE(IDB_QUEUE));\n\n\t \n\tiowrite32(TSI721_RIO_EM_DEV_INT_EN_INT,\n\t\tpriv->regs + TSI721_RIO_EM_DEV_INT_EN);\n\n\t \n#ifdef CONFIG_RAPIDIO_DMA_ENGINE\n\tintr = TSI721_INT_SR2PC_CHAN(IDB_QUEUE) |\n\t\t(TSI721_INT_BDMA_CHAN_M &\n\t\t ~TSI721_INT_BDMA_CHAN(TSI721_DMACH_MAINT));\n#else\n\tintr = TSI721_INT_SR2PC_CHAN(IDB_QUEUE);\n#endif\n\tiowrite32(intr,\tpriv->regs + TSI721_DEV_CHAN_INTE);\n\n\tif (priv->flags & TSI721_USING_MSIX)\n\t\tintr = TSI721_DEV_INT_SRIO;\n\telse\n\t\tintr = TSI721_DEV_INT_SR2PC_CH | TSI721_DEV_INT_SRIO |\n\t\t\tTSI721_DEV_INT_SMSG_CH | TSI721_DEV_INT_BDMA_CH;\n\n\tiowrite32(intr, priv->regs + TSI721_DEV_INTE);\n\tioread32(priv->regs + TSI721_DEV_INTE);\n}\n\n#ifdef CONFIG_PCI_MSI\n \nstatic irqreturn_t tsi721_omsg_msix(int irq, void *ptr)\n{\n\tstruct tsi721_device *priv = (struct tsi721_device *)ptr;\n\tint mbox;\n\n\tmbox = (irq - priv->msix[TSI721_VECT_OMB0_DONE].vector) % RIO_MAX_MBOX;\n\ttsi721_omsg_handler(priv, mbox);\n\treturn IRQ_HANDLED;\n}\n\n \nstatic irqreturn_t tsi721_imsg_msix(int irq, void *ptr)\n{\n\tstruct tsi721_device *priv = (struct tsi721_device *)ptr;\n\tint mbox;\n\n\tmbox = (irq - priv->msix[TSI721_VECT_IMB0_RCV].vector) % RIO_MAX_MBOX;\n\ttsi721_imsg_handler(priv, mbox + 4);\n\treturn IRQ_HANDLED;\n}\n\n \nstatic irqreturn_t tsi721_srio_msix(int irq, void *ptr)\n{\n\tstruct tsi721_device *priv = (struct tsi721_device *)ptr;\n\tu32 srio_int;\n\n\t \n\tsrio_int = ioread32(priv->regs + TSI721_RIO_EM_INT_STAT);\n\tif (srio_int & TSI721_RIO_EM_INT_STAT_PW_RX)\n\t\ttsi721_pw_handler(priv);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic irqreturn_t tsi721_sr2pc_ch_msix(int irq, void *ptr)\n{\n\tstruct tsi721_device *priv = (struct tsi721_device *)ptr;\n\tu32 sr_ch_int;\n\n\t \n\tsr_ch_int = ioread32(priv->regs + TSI721_SR_CHINT(IDB_QUEUE));\n\tif (sr_ch_int & TSI721_SR_CHINT_IDBQRCV)\n\t\ttsi721_dbell_handler(priv);\n\n\t \n\tiowrite32(sr_ch_int, priv->regs + TSI721_SR_CHINT(IDB_QUEUE));\n\t \n\tsr_ch_int = ioread32(priv->regs + TSI721_SR_CHINT(IDB_QUEUE));\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic int tsi721_request_msix(struct tsi721_device *priv)\n{\n\tint err = 0;\n\n\terr = request_irq(priv->msix[TSI721_VECT_IDB].vector,\n\t\t\ttsi721_sr2pc_ch_msix, 0,\n\t\t\tpriv->msix[TSI721_VECT_IDB].irq_name, (void *)priv);\n\tif (err)\n\t\treturn err;\n\n\terr = request_irq(priv->msix[TSI721_VECT_PWRX].vector,\n\t\t\ttsi721_srio_msix, 0,\n\t\t\tpriv->msix[TSI721_VECT_PWRX].irq_name, (void *)priv);\n\tif (err) {\n\t\tfree_irq(priv->msix[TSI721_VECT_IDB].vector, (void *)priv);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int tsi721_enable_msix(struct tsi721_device *priv)\n{\n\tstruct msix_entry entries[TSI721_VECT_MAX];\n\tint err;\n\tint i;\n\n\tentries[TSI721_VECT_IDB].entry = TSI721_MSIX_SR2PC_IDBQ_RCV(IDB_QUEUE);\n\tentries[TSI721_VECT_PWRX].entry = TSI721_MSIX_SRIO_MAC_INT;\n\n\t \n\tfor (i = 0; i < RIO_MAX_MBOX; i++) {\n\t\tentries[TSI721_VECT_IMB0_RCV + i].entry =\n\t\t\t\t\tTSI721_MSIX_IMSG_DQ_RCV(i + 4);\n\t\tentries[TSI721_VECT_IMB0_INT + i].entry =\n\t\t\t\t\tTSI721_MSIX_IMSG_INT(i + 4);\n\t\tentries[TSI721_VECT_OMB0_DONE + i].entry =\n\t\t\t\t\tTSI721_MSIX_OMSG_DONE(i);\n\t\tentries[TSI721_VECT_OMB0_INT + i].entry =\n\t\t\t\t\tTSI721_MSIX_OMSG_INT(i);\n\t}\n\n#ifdef CONFIG_RAPIDIO_DMA_ENGINE\n\t \n\tfor (i = 0; i < TSI721_DMA_CHNUM; i++) {\n\t\tentries[TSI721_VECT_DMA0_DONE + i].entry =\n\t\t\t\t\tTSI721_MSIX_DMACH_DONE(i);\n\t\tentries[TSI721_VECT_DMA0_INT + i].entry =\n\t\t\t\t\tTSI721_MSIX_DMACH_INT(i);\n\t}\n#endif  \n\n\terr = pci_enable_msix_exact(priv->pdev, entries, ARRAY_SIZE(entries));\n\tif (err) {\n\t\ttsi_err(&priv->pdev->dev,\n\t\t\t\"Failed to enable MSI-X (err=%d)\", err);\n\t\treturn err;\n\t}\n\n\t \n\tpriv->msix[TSI721_VECT_IDB].vector = entries[TSI721_VECT_IDB].vector;\n\tsnprintf(priv->msix[TSI721_VECT_IDB].irq_name, IRQ_DEVICE_NAME_MAX,\n\t\t DRV_NAME \"-idb@pci:%s\", pci_name(priv->pdev));\n\tpriv->msix[TSI721_VECT_PWRX].vector = entries[TSI721_VECT_PWRX].vector;\n\tsnprintf(priv->msix[TSI721_VECT_PWRX].irq_name, IRQ_DEVICE_NAME_MAX,\n\t\t DRV_NAME \"-pwrx@pci:%s\", pci_name(priv->pdev));\n\n\tfor (i = 0; i < RIO_MAX_MBOX; i++) {\n\t\tpriv->msix[TSI721_VECT_IMB0_RCV + i].vector =\n\t\t\t\tentries[TSI721_VECT_IMB0_RCV + i].vector;\n\t\tsnprintf(priv->msix[TSI721_VECT_IMB0_RCV + i].irq_name,\n\t\t\t IRQ_DEVICE_NAME_MAX, DRV_NAME \"-imbr%d@pci:%s\",\n\t\t\t i, pci_name(priv->pdev));\n\n\t\tpriv->msix[TSI721_VECT_IMB0_INT + i].vector =\n\t\t\t\tentries[TSI721_VECT_IMB0_INT + i].vector;\n\t\tsnprintf(priv->msix[TSI721_VECT_IMB0_INT + i].irq_name,\n\t\t\t IRQ_DEVICE_NAME_MAX, DRV_NAME \"-imbi%d@pci:%s\",\n\t\t\t i, pci_name(priv->pdev));\n\n\t\tpriv->msix[TSI721_VECT_OMB0_DONE + i].vector =\n\t\t\t\tentries[TSI721_VECT_OMB0_DONE + i].vector;\n\t\tsnprintf(priv->msix[TSI721_VECT_OMB0_DONE + i].irq_name,\n\t\t\t IRQ_DEVICE_NAME_MAX, DRV_NAME \"-ombd%d@pci:%s\",\n\t\t\t i, pci_name(priv->pdev));\n\n\t\tpriv->msix[TSI721_VECT_OMB0_INT + i].vector =\n\t\t\t\tentries[TSI721_VECT_OMB0_INT + i].vector;\n\t\tsnprintf(priv->msix[TSI721_VECT_OMB0_INT + i].irq_name,\n\t\t\t IRQ_DEVICE_NAME_MAX, DRV_NAME \"-ombi%d@pci:%s\",\n\t\t\t i, pci_name(priv->pdev));\n\t}\n\n#ifdef CONFIG_RAPIDIO_DMA_ENGINE\n\tfor (i = 0; i < TSI721_DMA_CHNUM; i++) {\n\t\tpriv->msix[TSI721_VECT_DMA0_DONE + i].vector =\n\t\t\t\tentries[TSI721_VECT_DMA0_DONE + i].vector;\n\t\tsnprintf(priv->msix[TSI721_VECT_DMA0_DONE + i].irq_name,\n\t\t\t IRQ_DEVICE_NAME_MAX, DRV_NAME \"-dmad%d@pci:%s\",\n\t\t\t i, pci_name(priv->pdev));\n\n\t\tpriv->msix[TSI721_VECT_DMA0_INT + i].vector =\n\t\t\t\tentries[TSI721_VECT_DMA0_INT + i].vector;\n\t\tsnprintf(priv->msix[TSI721_VECT_DMA0_INT + i].irq_name,\n\t\t\t IRQ_DEVICE_NAME_MAX, DRV_NAME \"-dmai%d@pci:%s\",\n\t\t\t i, pci_name(priv->pdev));\n\t}\n#endif  \n\n\treturn 0;\n}\n#endif  \n\nstatic int tsi721_request_irq(struct tsi721_device *priv)\n{\n\tint err;\n\n#ifdef CONFIG_PCI_MSI\n\tif (priv->flags & TSI721_USING_MSIX)\n\t\terr = tsi721_request_msix(priv);\n\telse\n#endif\n\t\terr = request_irq(priv->pdev->irq, tsi721_irqhandler,\n\t\t\t  (priv->flags & TSI721_USING_MSI) ? 0 : IRQF_SHARED,\n\t\t\t  DRV_NAME, (void *)priv);\n\n\tif (err)\n\t\ttsi_err(&priv->pdev->dev,\n\t\t\t\"Unable to allocate interrupt, err=%d\", err);\n\n\treturn err;\n}\n\nstatic void tsi721_free_irq(struct tsi721_device *priv)\n{\n#ifdef CONFIG_PCI_MSI\n\tif (priv->flags & TSI721_USING_MSIX) {\n\t\tfree_irq(priv->msix[TSI721_VECT_IDB].vector, (void *)priv);\n\t\tfree_irq(priv->msix[TSI721_VECT_PWRX].vector, (void *)priv);\n\t} else\n#endif\n\tfree_irq(priv->pdev->irq, (void *)priv);\n}\n\nstatic int\ntsi721_obw_alloc(struct tsi721_device *priv, struct tsi721_obw_bar *pbar,\n\t\t u32 size, int *win_id)\n{\n\tu64 win_base;\n\tu64 bar_base;\n\tu64 bar_end;\n\tu32 align;\n\tstruct tsi721_ob_win *win;\n\tstruct tsi721_ob_win *new_win = NULL;\n\tint new_win_idx = -1;\n\tint i = 0;\n\n\tbar_base = pbar->base;\n\tbar_end =  bar_base + pbar->size;\n\twin_base = bar_base;\n\talign = size/TSI721_PC2SR_ZONES;\n\n\twhile (i < TSI721_IBWIN_NUM) {\n\t\tfor (i = 0; i < TSI721_IBWIN_NUM; i++) {\n\t\t\tif (!priv->ob_win[i].active) {\n\t\t\t\tif (new_win == NULL) {\n\t\t\t\t\tnew_win = &priv->ob_win[i];\n\t\t\t\t\tnew_win_idx = i;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t \n\t\t\twin = &priv->ob_win[i];\n\n\t\t\tif (win->base >= bar_base && win->base < bar_end) {\n\t\t\t\tif (win_base < (win->base + win->size) &&\n\t\t\t\t\t\t(win_base + size) > win->base) {\n\t\t\t\t\t \n\t\t\t\t\twin_base = win->base + win->size;\n\t\t\t\t\twin_base = ALIGN(win_base, align);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (win_base + size > bar_end)\n\t\treturn -ENOMEM;\n\n\tif (!new_win) {\n\t\ttsi_err(&priv->pdev->dev, \"OBW count tracking failed\");\n\t\treturn -EIO;\n\t}\n\n\tnew_win->active = true;\n\tnew_win->base = win_base;\n\tnew_win->size = size;\n\tnew_win->pbar = pbar;\n\tpriv->obwin_cnt--;\n\tpbar->free -= size;\n\t*win_id = new_win_idx;\n\treturn 0;\n}\n\nstatic int tsi721_map_outb_win(struct rio_mport *mport, u16 destid, u64 rstart,\n\t\t\tu32 size, u32 flags, dma_addr_t *laddr)\n{\n\tstruct tsi721_device *priv = mport->priv;\n\tint i;\n\tstruct tsi721_obw_bar *pbar;\n\tstruct tsi721_ob_win *ob_win;\n\tint obw = -1;\n\tu32 rval;\n\tu64 rio_addr;\n\tu32 zsize;\n\tint ret = -ENOMEM;\n\n\ttsi_debug(OBW, &priv->pdev->dev,\n\t\t  \"did=%d ra=0x%llx sz=0x%x\", destid, rstart, size);\n\n\tif (!is_power_of_2(size) || (size < 0x8000) || (rstart & (size - 1)))\n\t\treturn -EINVAL;\n\n\tif (priv->obwin_cnt == 0)\n\t\treturn -EBUSY;\n\n\tfor (i = 0; i < 2; i++) {\n\t\tif (priv->p2r_bar[i].free >= size) {\n\t\t\tpbar = &priv->p2r_bar[i];\n\t\t\tret = tsi721_obw_alloc(priv, pbar, size, &obw);\n\t\t\tif (!ret)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ret)\n\t\treturn ret;\n\n\tWARN_ON(obw == -1);\n\tob_win = &priv->ob_win[obw];\n\tob_win->destid = destid;\n\tob_win->rstart = rstart;\n\ttsi_debug(OBW, &priv->pdev->dev,\n\t\t  \"allocated OBW%d @%llx\", obw, ob_win->base);\n\n\t \n\n\tzsize = size/TSI721_PC2SR_ZONES;\n\trio_addr = rstart;\n\n\t \n\tfor (i = 0; i < TSI721_PC2SR_ZONES; i++) {\n\n\t\twhile (ioread32(priv->regs + TSI721_ZONE_SEL) &\n\t\t\tTSI721_ZONE_SEL_GO) {\n\t\t\tudelay(1);\n\t\t}\n\n\t\trval = (u32)(rio_addr & TSI721_LUT_DATA0_ADD) |\n\t\t\tTSI721_LUT_DATA0_NREAD | TSI721_LUT_DATA0_NWR;\n\t\tiowrite32(rval, priv->regs + TSI721_LUT_DATA0);\n\t\trval = (u32)(rio_addr >> 32);\n\t\tiowrite32(rval, priv->regs + TSI721_LUT_DATA1);\n\t\trval = destid;\n\t\tiowrite32(rval, priv->regs + TSI721_LUT_DATA2);\n\n\t\trval = TSI721_ZONE_SEL_GO | (obw << 3) | i;\n\t\tiowrite32(rval, priv->regs + TSI721_ZONE_SEL);\n\n\t\trio_addr += zsize;\n\t}\n\n\tiowrite32(TSI721_OBWIN_SIZE(size) << 8,\n\t\t  priv->regs + TSI721_OBWINSZ(obw));\n\tiowrite32((u32)(ob_win->base >> 32), priv->regs + TSI721_OBWINUB(obw));\n\tiowrite32((u32)(ob_win->base & TSI721_OBWINLB_BA) | TSI721_OBWINLB_WEN,\n\t\t  priv->regs + TSI721_OBWINLB(obw));\n\n\t*laddr = ob_win->base;\n\treturn 0;\n}\n\nstatic void tsi721_unmap_outb_win(struct rio_mport *mport,\n\t\t\t\t  u16 destid, u64 rstart)\n{\n\tstruct tsi721_device *priv = mport->priv;\n\tstruct tsi721_ob_win *ob_win;\n\tint i;\n\n\ttsi_debug(OBW, &priv->pdev->dev, \"did=%d ra=0x%llx\", destid, rstart);\n\n\tfor (i = 0; i < TSI721_OBWIN_NUM; i++) {\n\t\tob_win = &priv->ob_win[i];\n\n\t\tif (ob_win->active &&\n\t\t    ob_win->destid == destid && ob_win->rstart == rstart) {\n\t\t\ttsi_debug(OBW, &priv->pdev->dev,\n\t\t\t\t  \"free OBW%d @%llx\", i, ob_win->base);\n\t\t\tob_win->active = false;\n\t\t\tiowrite32(0, priv->regs + TSI721_OBWINLB(i));\n\t\t\tob_win->pbar->free += ob_win->size;\n\t\t\tpriv->obwin_cnt++;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n \nstatic void tsi721_init_pc2sr_mapping(struct tsi721_device *priv)\n{\n\tint i, z;\n\tu32 rval;\n\n\t \n\tfor (i = 0; i < TSI721_OBWIN_NUM; i++)\n\t\tiowrite32(0, priv->regs + TSI721_OBWINLB(i));\n\n\t \n\tiowrite32(0, priv->regs + TSI721_LUT_DATA0);\n\tiowrite32(0, priv->regs + TSI721_LUT_DATA1);\n\tiowrite32(0, priv->regs + TSI721_LUT_DATA2);\n\n\tfor (i = 0; i < TSI721_OBWIN_NUM; i++) {\n\t\tfor (z = 0; z < TSI721_PC2SR_ZONES; z++) {\n\t\t\twhile (ioread32(priv->regs + TSI721_ZONE_SEL) &\n\t\t\t\tTSI721_ZONE_SEL_GO) {\n\t\t\t\tudelay(1);\n\t\t\t}\n\t\t\trval = TSI721_ZONE_SEL_GO | (i << 3) | z;\n\t\t\tiowrite32(rval, priv->regs + TSI721_ZONE_SEL);\n\t\t}\n\t}\n\n\tif (priv->p2r_bar[0].size == 0 && priv->p2r_bar[1].size == 0) {\n\t\tpriv->obwin_cnt = 0;\n\t\treturn;\n\t}\n\n\tpriv->p2r_bar[0].free = priv->p2r_bar[0].size;\n\tpriv->p2r_bar[1].free = priv->p2r_bar[1].size;\n\n\tfor (i = 0; i < TSI721_OBWIN_NUM; i++)\n\t\tpriv->ob_win[i].active = false;\n\n\tpriv->obwin_cnt = TSI721_OBWIN_NUM;\n}\n\n \nstatic int tsi721_rio_map_inb_mem(struct rio_mport *mport, dma_addr_t lstart,\n\t\tu64 rstart, u64 size, u32 flags)\n{\n\tstruct tsi721_device *priv = mport->priv;\n\tint i, avail = -1;\n\tu32 regval;\n\tstruct tsi721_ib_win *ib_win;\n\tbool direct = (lstart == rstart);\n\tu64 ibw_size;\n\tdma_addr_t loc_start;\n\tu64 ibw_start;\n\tstruct tsi721_ib_win_mapping *map = NULL;\n\tint ret = -EBUSY;\n\n\t \n\tif (size > 0x400000000UL)\n\t\treturn -EINVAL;\n\n\tif (direct) {\n\t\t \n\n\t\tibw_size = roundup_pow_of_two(size);\n\t\tibw_start = lstart & ~(ibw_size - 1);\n\n\t\ttsi_debug(IBW, &priv->pdev->dev,\n\t\t\t\"Direct (RIO_0x%llx -> PCIe_%pad), size=0x%llx, ibw_start = 0x%llx\",\n\t\t\trstart, &lstart, size, ibw_start);\n\n\t\twhile ((lstart + size) > (ibw_start + ibw_size)) {\n\t\t\tibw_size *= 2;\n\t\t\tibw_start = lstart & ~(ibw_size - 1);\n\t\t\t \n\t\t\tif (ibw_size > 0x400000000UL)\n\t\t\t\treturn -EBUSY;\n\t\t}\n\n\t\tloc_start = ibw_start;\n\n\t\tmap = kzalloc(sizeof(struct tsi721_ib_win_mapping), GFP_ATOMIC);\n\t\tif (map == NULL)\n\t\t\treturn -ENOMEM;\n\n\t} else {\n\t\ttsi_debug(IBW, &priv->pdev->dev,\n\t\t\t\"Translated (RIO_0x%llx -> PCIe_%pad), size=0x%llx\",\n\t\t\trstart, &lstart, size);\n\n\t\tif (!is_power_of_2(size) || size < 0x1000 ||\n\t\t    ((u64)lstart & (size - 1)) || (rstart & (size - 1)))\n\t\t\treturn -EINVAL;\n\t\tif (priv->ibwin_cnt == 0)\n\t\t\treturn -EBUSY;\n\t\tibw_start = rstart;\n\t\tibw_size = size;\n\t\tloc_start = lstart;\n\t}\n\n\t \n\tfor (i = 0; i < TSI721_IBWIN_NUM; i++) {\n\t\tib_win = &priv->ib_win[i];\n\n\t\tif (!ib_win->active) {\n\t\t\tif (avail == -1) {\n\t\t\t\tavail = i;\n\t\t\t\tret = 0;\n\t\t\t}\n\t\t} else if (ibw_start < (ib_win->rstart + ib_win->size) &&\n\t\t\t   (ibw_start + ibw_size) > ib_win->rstart) {\n\t\t\t \n\t\t\tif (!direct || ib_win->xlat) {\n\t\t\t\tret = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (rstart >= ib_win->rstart &&\n\t\t\t    (rstart + size) <= (ib_win->rstart +\n\t\t\t\t\t\t\tib_win->size)) {\n\t\t\t\t \n\t\t\t\tmap->lstart = lstart;\n\t\t\t\tlist_add_tail(&map->node, &ib_win->mappings);\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ret)\n\t\tgoto out;\n\ti = avail;\n\n\t \n\tregval = ioread32(priv->regs + TSI721_IBWIN_LB(i));\n\tif (WARN_ON(regval & TSI721_IBWIN_LB_WEN)) {\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\tib_win = &priv->ib_win[i];\n\tib_win->active = true;\n\tib_win->rstart = ibw_start;\n\tib_win->lstart = loc_start;\n\tib_win->size = ibw_size;\n\tib_win->xlat = (lstart != rstart);\n\tINIT_LIST_HEAD(&ib_win->mappings);\n\n\t \n\tif (direct) {\n\t\tmap->lstart = lstart;\n\t\tlist_add_tail(&map->node, &ib_win->mappings);\n\t}\n\n\tiowrite32(TSI721_IBWIN_SIZE(ibw_size) << 8,\n\t\t\tpriv->regs + TSI721_IBWIN_SZ(i));\n\n\tiowrite32(((u64)loc_start >> 32), priv->regs + TSI721_IBWIN_TUA(i));\n\tiowrite32(((u64)loc_start & TSI721_IBWIN_TLA_ADD),\n\t\t  priv->regs + TSI721_IBWIN_TLA(i));\n\n\tiowrite32(ibw_start >> 32, priv->regs + TSI721_IBWIN_UB(i));\n\tiowrite32((ibw_start & TSI721_IBWIN_LB_BA) | TSI721_IBWIN_LB_WEN,\n\t\tpriv->regs + TSI721_IBWIN_LB(i));\n\n\tpriv->ibwin_cnt--;\n\n\ttsi_debug(IBW, &priv->pdev->dev,\n\t\t\"Configured IBWIN%d (RIO_0x%llx -> PCIe_%pad), size=0x%llx\",\n\t\ti, ibw_start, &loc_start, ibw_size);\n\n\treturn 0;\nout:\n\tkfree(map);\n\treturn ret;\n}\n\n \nstatic void tsi721_rio_unmap_inb_mem(struct rio_mport *mport,\n\t\t\t\tdma_addr_t lstart)\n{\n\tstruct tsi721_device *priv = mport->priv;\n\tstruct tsi721_ib_win *ib_win;\n\tint i;\n\n\ttsi_debug(IBW, &priv->pdev->dev,\n\t\t\"Unmap IBW mapped to PCIe_%pad\", &lstart);\n\n\t \n\tfor (i = 0; i < TSI721_IBWIN_NUM; i++) {\n\t\tib_win = &priv->ib_win[i];\n\n\t\t \n\t\tif (!ib_win->active ||\n\t\t    (ib_win->xlat && lstart != ib_win->lstart))\n\t\t\tcontinue;\n\n\t\tif (lstart >= ib_win->lstart &&\n\t\t    lstart < (ib_win->lstart + ib_win->size)) {\n\n\t\t\tif (!ib_win->xlat) {\n\t\t\t\tstruct tsi721_ib_win_mapping *map;\n\t\t\t\tint found = 0;\n\n\t\t\t\tlist_for_each_entry(map,\n\t\t\t\t\t\t    &ib_win->mappings, node) {\n\t\t\t\t\tif (map->lstart == lstart) {\n\t\t\t\t\t\tlist_del(&map->node);\n\t\t\t\t\t\tkfree(map);\n\t\t\t\t\t\tfound = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!found)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (!list_empty(&ib_win->mappings))\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\ttsi_debug(IBW, &priv->pdev->dev, \"Disable IBWIN_%d\", i);\n\t\t\tiowrite32(0, priv->regs + TSI721_IBWIN_LB(i));\n\t\t\tib_win->active = false;\n\t\t\tpriv->ibwin_cnt++;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i == TSI721_IBWIN_NUM)\n\t\ttsi_debug(IBW, &priv->pdev->dev,\n\t\t\t\"IB window mapped to %pad not found\", &lstart);\n}\n\n \nstatic void tsi721_init_sr2pc_mapping(struct tsi721_device *priv)\n{\n\tint i;\n\n\t \n\tfor (i = 0; i < TSI721_IBWIN_NUM; i++)\n\t\tiowrite32(0, priv->regs + TSI721_IBWIN_LB(i));\n\tpriv->ibwin_cnt = TSI721_IBWIN_NUM;\n}\n\n \nstatic void tsi721_close_sr2pc_mapping(struct tsi721_device *priv)\n{\n\tstruct tsi721_ib_win *ib_win;\n\tint i;\n\n\t \n\tfor (i = 0; i < TSI721_IBWIN_NUM; i++) {\n\t\tib_win = &priv->ib_win[i];\n\t\tif (ib_win->active) {\n\t\t\tiowrite32(0, priv->regs + TSI721_IBWIN_LB(i));\n\t\t\tib_win->active = false;\n\t\t}\n\t}\n}\n\n \nstatic int tsi721_port_write_init(struct tsi721_device *priv)\n{\n\tpriv->pw_discard_count = 0;\n\tINIT_WORK(&priv->pw_work, tsi721_pw_dpc);\n\tspin_lock_init(&priv->pw_fifo_lock);\n\tif (kfifo_alloc(&priv->pw_fifo,\n\t\t\tTSI721_RIO_PW_MSG_SIZE * 32, GFP_KERNEL)) {\n\t\ttsi_err(&priv->pdev->dev, \"PW FIFO allocation failed\");\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tiowrite32(TSI721_RIO_PW_CTL_PWC_REL, priv->regs + TSI721_RIO_PW_CTL);\n\treturn 0;\n}\n\nstatic void tsi721_port_write_free(struct tsi721_device *priv)\n{\n\tkfifo_free(&priv->pw_fifo);\n}\n\nstatic int tsi721_doorbell_init(struct tsi721_device *priv)\n{\n\t \n\n\t \n\tpriv->db_discard_count = 0;\n\tINIT_WORK(&priv->idb_work, tsi721_db_dpc);\n\n\t \n\tpriv->idb_base = dma_alloc_coherent(&priv->pdev->dev,\n\t\t\t\t\t    IDB_QSIZE * TSI721_IDB_ENTRY_SIZE,\n\t\t\t\t\t    &priv->idb_dma, GFP_KERNEL);\n\tif (!priv->idb_base)\n\t\treturn -ENOMEM;\n\n\ttsi_debug(DBELL, &priv->pdev->dev,\n\t\t  \"Allocated IDB buffer @ %p (phys = %pad)\",\n\t\t  priv->idb_base, &priv->idb_dma);\n\n\tiowrite32(TSI721_IDQ_SIZE_VAL(IDB_QSIZE),\n\t\tpriv->regs + TSI721_IDQ_SIZE(IDB_QUEUE));\n\tiowrite32(((u64)priv->idb_dma >> 32),\n\t\tpriv->regs + TSI721_IDQ_BASEU(IDB_QUEUE));\n\tiowrite32(((u64)priv->idb_dma & TSI721_IDQ_BASEL_ADDR),\n\t\tpriv->regs + TSI721_IDQ_BASEL(IDB_QUEUE));\n\t \n\tiowrite32(0, priv->regs + TSI721_IDQ_MASK(IDB_QUEUE));\n\n\tiowrite32(TSI721_IDQ_INIT, priv->regs + TSI721_IDQ_CTL(IDB_QUEUE));\n\n\tiowrite32(0, priv->regs + TSI721_IDQ_RP(IDB_QUEUE));\n\n\treturn 0;\n}\n\nstatic void tsi721_doorbell_free(struct tsi721_device *priv)\n{\n\tif (priv->idb_base == NULL)\n\t\treturn;\n\n\t \n\tdma_free_coherent(&priv->pdev->dev, IDB_QSIZE * TSI721_IDB_ENTRY_SIZE,\n\t\t\t  priv->idb_base, priv->idb_dma);\n\tpriv->idb_base = NULL;\n}\n\n \nstatic int tsi721_bdma_maint_init(struct tsi721_device *priv)\n{\n\tstruct tsi721_dma_desc *bd_ptr;\n\tu64\t\t*sts_ptr;\n\tdma_addr_t\tbd_phys, sts_phys;\n\tint\t\tsts_size;\n\tint\t\tbd_num = 2;\n\tvoid __iomem\t*regs;\n\n\ttsi_debug(MAINT, &priv->pdev->dev,\n\t\t  \"Init BDMA_%d Maintenance requests\", TSI721_DMACH_MAINT);\n\n\t \n\n\tpriv->mdma.ch_id = TSI721_DMACH_MAINT;\n\tregs = priv->regs + TSI721_DMAC_BASE(TSI721_DMACH_MAINT);\n\n\t \n\tbd_ptr = dma_alloc_coherent(&priv->pdev->dev,\n\t\t\t\t    bd_num * sizeof(struct tsi721_dma_desc),\n\t\t\t\t    &bd_phys, GFP_KERNEL);\n\tif (!bd_ptr)\n\t\treturn -ENOMEM;\n\n\tpriv->mdma.bd_num = bd_num;\n\tpriv->mdma.bd_phys = bd_phys;\n\tpriv->mdma.bd_base = bd_ptr;\n\n\ttsi_debug(MAINT, &priv->pdev->dev, \"DMA descriptors @ %p (phys = %pad)\",\n\t\t  bd_ptr, &bd_phys);\n\n\t \n\tsts_size = (bd_num >= TSI721_DMA_MINSTSSZ) ?\n\t\t\t\t\tbd_num : TSI721_DMA_MINSTSSZ;\n\tsts_size = roundup_pow_of_two(sts_size);\n\tsts_ptr = dma_alloc_coherent(&priv->pdev->dev,\n\t\t\t\t     sts_size * sizeof(struct tsi721_dma_sts),\n\t\t\t\t     &sts_phys, GFP_KERNEL);\n\tif (!sts_ptr) {\n\t\t \n\t\tdma_free_coherent(&priv->pdev->dev,\n\t\t\t\t  bd_num * sizeof(struct tsi721_dma_desc),\n\t\t\t\t  bd_ptr, bd_phys);\n\t\tpriv->mdma.bd_base = NULL;\n\t\treturn -ENOMEM;\n\t}\n\n\tpriv->mdma.sts_phys = sts_phys;\n\tpriv->mdma.sts_base = sts_ptr;\n\tpriv->mdma.sts_size = sts_size;\n\n\ttsi_debug(MAINT, &priv->pdev->dev,\n\t\t\"desc status FIFO @ %p (phys = %pad) size=0x%x\",\n\t\tsts_ptr, &sts_phys, sts_size);\n\n\t \n\tbd_ptr[bd_num - 1].type_id = cpu_to_le32(DTYPE3 << 29);\n\tbd_ptr[bd_num - 1].next_lo = cpu_to_le32((u64)bd_phys &\n\t\t\t\t\t\t TSI721_DMAC_DPTRL_MASK);\n\tbd_ptr[bd_num - 1].next_hi = cpu_to_le32((u64)bd_phys >> 32);\n\n\t \n\tiowrite32(((u64)bd_phys >> 32),\tregs + TSI721_DMAC_DPTRH);\n\tiowrite32(((u64)bd_phys & TSI721_DMAC_DPTRL_MASK),\n\t\tregs + TSI721_DMAC_DPTRL);\n\n\t \n\tiowrite32(((u64)sts_phys >> 32), regs + TSI721_DMAC_DSBH);\n\tiowrite32(((u64)sts_phys & TSI721_DMAC_DSBL_MASK),\n\t\tregs + TSI721_DMAC_DSBL);\n\tiowrite32(TSI721_DMAC_DSSZ_SIZE(sts_size),\n\t\tregs + TSI721_DMAC_DSSZ);\n\n\t \n\tiowrite32(TSI721_DMAC_INT_ALL, regs + TSI721_DMAC_INT);\n\n\tioread32(regs + TSI721_DMAC_INT);\n\n\t \n\tiowrite32(TSI721_DMAC_CTL_INIT,\tregs + TSI721_DMAC_CTL);\n\tioread32(regs + TSI721_DMAC_CTL);\n\tudelay(10);\n\n\treturn 0;\n}\n\nstatic int tsi721_bdma_maint_free(struct tsi721_device *priv)\n{\n\tu32 ch_stat;\n\tstruct tsi721_bdma_maint *mdma = &priv->mdma;\n\tvoid __iomem *regs = priv->regs + TSI721_DMAC_BASE(mdma->ch_id);\n\n\tif (mdma->bd_base == NULL)\n\t\treturn 0;\n\n\t \n\tch_stat = ioread32(regs + TSI721_DMAC_STS);\n\tif (ch_stat & TSI721_DMAC_STS_RUN)\n\t\treturn -EFAULT;\n\n\t \n\tiowrite32(TSI721_DMAC_CTL_INIT,\tregs + TSI721_DMAC_CTL);\n\n\t \n\tdma_free_coherent(&priv->pdev->dev,\n\t\tmdma->bd_num * sizeof(struct tsi721_dma_desc),\n\t\tmdma->bd_base, mdma->bd_phys);\n\tmdma->bd_base = NULL;\n\n\t \n\tdma_free_coherent(&priv->pdev->dev,\n\t\tmdma->sts_size * sizeof(struct tsi721_dma_sts),\n\t\tmdma->sts_base, mdma->sts_phys);\n\tmdma->sts_base = NULL;\n\treturn 0;\n}\n\n \nstatic void\ntsi721_imsg_interrupt_enable(struct tsi721_device *priv, int ch,\n\t\t\t\t  u32 inte_mask)\n{\n\tu32 rval;\n\n\tif (!inte_mask)\n\t\treturn;\n\n\t \n\tiowrite32(inte_mask, priv->regs + TSI721_IBDMAC_INT(ch));\n\n\t \n\trval = ioread32(priv->regs + TSI721_IBDMAC_INTE(ch));\n\tiowrite32(rval | inte_mask, priv->regs + TSI721_IBDMAC_INTE(ch));\n\n\tif (priv->flags & TSI721_USING_MSIX)\n\t\treturn;  \n\n\t \n\n\t \n\trval = ioread32(priv->regs + TSI721_DEV_CHAN_INTE);\n\tiowrite32(rval | TSI721_INT_IMSG_CHAN(ch),\n\t\t  priv->regs + TSI721_DEV_CHAN_INTE);\n}\n\n \nstatic void\ntsi721_imsg_interrupt_disable(struct tsi721_device *priv, int ch,\n\t\t\t\t   u32 inte_mask)\n{\n\tu32 rval;\n\n\tif (!inte_mask)\n\t\treturn;\n\n\t \n\tiowrite32(inte_mask, priv->regs + TSI721_IBDMAC_INT(ch));\n\n\t \n\trval = ioread32(priv->regs + TSI721_IBDMAC_INTE(ch));\n\trval &= ~inte_mask;\n\tiowrite32(rval, priv->regs + TSI721_IBDMAC_INTE(ch));\n\n\tif (priv->flags & TSI721_USING_MSIX)\n\t\treturn;  \n\n\t \n\n\t \n\trval = ioread32(priv->regs + TSI721_DEV_CHAN_INTE);\n\trval &= ~TSI721_INT_IMSG_CHAN(ch);\n\tiowrite32(rval, priv->regs + TSI721_DEV_CHAN_INTE);\n}\n\n \nstatic void\ntsi721_omsg_interrupt_enable(struct tsi721_device *priv, int ch,\n\t\t\t\t  u32 inte_mask)\n{\n\tu32 rval;\n\n\tif (!inte_mask)\n\t\treturn;\n\n\t \n\tiowrite32(inte_mask, priv->regs + TSI721_OBDMAC_INT(ch));\n\n\t \n\trval = ioread32(priv->regs + TSI721_OBDMAC_INTE(ch));\n\tiowrite32(rval | inte_mask, priv->regs + TSI721_OBDMAC_INTE(ch));\n\n\tif (priv->flags & TSI721_USING_MSIX)\n\t\treturn;  \n\n\t \n\n\t \n\trval = ioread32(priv->regs + TSI721_DEV_CHAN_INTE);\n\tiowrite32(rval | TSI721_INT_OMSG_CHAN(ch),\n\t\t  priv->regs + TSI721_DEV_CHAN_INTE);\n}\n\n \nstatic void\ntsi721_omsg_interrupt_disable(struct tsi721_device *priv, int ch,\n\t\t\t\t   u32 inte_mask)\n{\n\tu32 rval;\n\n\tif (!inte_mask)\n\t\treturn;\n\n\t \n\tiowrite32(inte_mask, priv->regs + TSI721_OBDMAC_INT(ch));\n\n\t \n\trval = ioread32(priv->regs + TSI721_OBDMAC_INTE(ch));\n\trval &= ~inte_mask;\n\tiowrite32(rval, priv->regs + TSI721_OBDMAC_INTE(ch));\n\n\tif (priv->flags & TSI721_USING_MSIX)\n\t\treturn;  \n\n\t \n\n\t \n\trval = ioread32(priv->regs + TSI721_DEV_CHAN_INTE);\n\trval &= ~TSI721_INT_OMSG_CHAN(ch);\n\tiowrite32(rval, priv->regs + TSI721_DEV_CHAN_INTE);\n}\n\n \nstatic int\ntsi721_add_outb_message(struct rio_mport *mport, struct rio_dev *rdev, int mbox,\n\t\t\tvoid *buffer, size_t len)\n{\n\tstruct tsi721_device *priv = mport->priv;\n\tstruct tsi721_omsg_desc *desc;\n\tu32 tx_slot;\n\tunsigned long flags;\n\n\tif (!priv->omsg_init[mbox] ||\n\t    len > TSI721_MSG_MAX_SIZE || len < 8)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&priv->omsg_ring[mbox].lock, flags);\n\n\ttx_slot = priv->omsg_ring[mbox].tx_slot;\n\n\t \n\tmemcpy(priv->omsg_ring[mbox].omq_base[tx_slot], buffer, len);\n\n\tif (len & 0x7)\n\t\tlen += 8;\n\n\t \n\tdesc = priv->omsg_ring[mbox].omd_base;\n\tdesc[tx_slot].type_id = cpu_to_le32((DTYPE4 << 29) | rdev->destid);\n#ifdef TSI721_OMSG_DESC_INT\n\t \n\tif (tx_slot % 4 == 0)\n\t\tdesc[tx_slot].type_id |= cpu_to_le32(TSI721_OMD_IOF);\n#endif\n\tdesc[tx_slot].msg_info =\n\t\tcpu_to_le32((mport->sys_size << 26) | (mbox << 22) |\n\t\t\t    (0xe << 12) | (len & 0xff8));\n\tdesc[tx_slot].bufptr_lo =\n\t\tcpu_to_le32((u64)priv->omsg_ring[mbox].omq_phys[tx_slot] &\n\t\t\t    0xffffffff);\n\tdesc[tx_slot].bufptr_hi =\n\t\tcpu_to_le32((u64)priv->omsg_ring[mbox].omq_phys[tx_slot] >> 32);\n\n\tpriv->omsg_ring[mbox].wr_count++;\n\n\t \n\tif (++priv->omsg_ring[mbox].tx_slot == priv->omsg_ring[mbox].size) {\n\t\tpriv->omsg_ring[mbox].tx_slot = 0;\n\t\t \n\t\tpriv->omsg_ring[mbox].wr_count++;\n\t}\n\n\tmb();\n\n\t \n\tiowrite32(priv->omsg_ring[mbox].wr_count,\n\t\tpriv->regs + TSI721_OBDMAC_DWRCNT(mbox));\n\tioread32(priv->regs + TSI721_OBDMAC_DWRCNT(mbox));\n\n\tspin_unlock_irqrestore(&priv->omsg_ring[mbox].lock, flags);\n\n\treturn 0;\n}\n\n \nstatic void tsi721_omsg_handler(struct tsi721_device *priv, int ch)\n{\n\tu32 omsg_int;\n\tstruct rio_mport *mport = &priv->mport;\n\tvoid *dev_id = NULL;\n\tu32 tx_slot = 0xffffffff;\n\tint do_callback = 0;\n\n\tspin_lock(&priv->omsg_ring[ch].lock);\n\n\tomsg_int = ioread32(priv->regs + TSI721_OBDMAC_INT(ch));\n\n\tif (omsg_int & TSI721_OBDMAC_INT_ST_FULL)\n\t\ttsi_info(&priv->pdev->dev,\n\t\t\t\"OB MBOX%d: Status FIFO is full\", ch);\n\n\tif (omsg_int & (TSI721_OBDMAC_INT_DONE | TSI721_OBDMAC_INT_IOF_DONE)) {\n\t\tu32 srd_ptr;\n\t\tu64 *sts_ptr, last_ptr = 0, prev_ptr = 0;\n\t\tint i, j;\n\n\t\t \n\n\t\t \n\t\tsrd_ptr = priv->omsg_ring[ch].sts_rdptr;\n\t\tsts_ptr = priv->omsg_ring[ch].sts_base;\n\t\tj = srd_ptr * 8;\n\t\twhile (sts_ptr[j]) {\n\t\t\tfor (i = 0; i < 8 && sts_ptr[j]; i++, j++) {\n\t\t\t\tprev_ptr = last_ptr;\n\t\t\t\tlast_ptr = le64_to_cpu(sts_ptr[j]);\n\t\t\t\tsts_ptr[j] = 0;\n\t\t\t}\n\n\t\t\t++srd_ptr;\n\t\t\tsrd_ptr %= priv->omsg_ring[ch].sts_size;\n\t\t\tj = srd_ptr * 8;\n\t\t}\n\n\t\tif (last_ptr == 0)\n\t\t\tgoto no_sts_update;\n\n\t\tpriv->omsg_ring[ch].sts_rdptr = srd_ptr;\n\t\tiowrite32(srd_ptr, priv->regs + TSI721_OBDMAC_DSRP(ch));\n\n\t\tif (!mport->outb_msg[ch].mcback)\n\t\t\tgoto no_sts_update;\n\n\t\t \n\n\t\ttx_slot = (last_ptr - (u64)priv->omsg_ring[ch].omd_phys)/\n\t\t\t\t\t\tsizeof(struct tsi721_omsg_desc);\n\n\t\t \n\t\tif (tx_slot == priv->omsg_ring[ch].size) {\n\t\t\tif (prev_ptr)\n\t\t\t\ttx_slot = (prev_ptr -\n\t\t\t\t\t(u64)priv->omsg_ring[ch].omd_phys)/\n\t\t\t\t\t\tsizeof(struct tsi721_omsg_desc);\n\t\t\telse\n\t\t\t\tgoto no_sts_update;\n\t\t}\n\n\t\tif (tx_slot >= priv->omsg_ring[ch].size)\n\t\t\ttsi_debug(OMSG, &priv->pdev->dev,\n\t\t\t\t  \"OB_MSG tx_slot=%x > size=%x\",\n\t\t\t\t  tx_slot, priv->omsg_ring[ch].size);\n\t\tWARN_ON(tx_slot >= priv->omsg_ring[ch].size);\n\n\t\t \n\t\t++tx_slot;\n\t\tif (tx_slot == priv->omsg_ring[ch].size)\n\t\t\ttx_slot = 0;\n\n\t\tdev_id = priv->omsg_ring[ch].dev_id;\n\t\tdo_callback = 1;\n\t}\n\nno_sts_update:\n\n\tif (omsg_int & TSI721_OBDMAC_INT_ERROR) {\n\t\t \n\n\t\ttsi_debug(OMSG, &priv->pdev->dev, \"OB MSG ABORT ch_stat=%x\",\n\t\t\t  ioread32(priv->regs + TSI721_OBDMAC_STS(ch)));\n\n\t\tiowrite32(TSI721_OBDMAC_INT_ERROR,\n\t\t\t\tpriv->regs + TSI721_OBDMAC_INT(ch));\n\t\tiowrite32(TSI721_OBDMAC_CTL_RETRY_THR | TSI721_OBDMAC_CTL_INIT,\n\t\t\t\tpriv->regs + TSI721_OBDMAC_CTL(ch));\n\t\tioread32(priv->regs + TSI721_OBDMAC_CTL(ch));\n\n\t\t \n\t\tdev_id = priv->omsg_ring[ch].dev_id;\n\t\ttx_slot = priv->omsg_ring[ch].tx_slot;\n\t\tdo_callback = 1;\n\n\t\t \n\t\tiowrite32(priv->omsg_ring[ch].tx_slot,\n\t\t\tpriv->regs + TSI721_OBDMAC_DRDCNT(ch));\n\t\tioread32(priv->regs + TSI721_OBDMAC_DRDCNT(ch));\n\t\tpriv->omsg_ring[ch].wr_count = priv->omsg_ring[ch].tx_slot;\n\t\tpriv->omsg_ring[ch].sts_rdptr = 0;\n\t}\n\n\t \n\tiowrite32(omsg_int, priv->regs + TSI721_OBDMAC_INT(ch));\n\n\tif (!(priv->flags & TSI721_USING_MSIX)) {\n\t\tu32 ch_inte;\n\n\t\t \n\t\tch_inte = ioread32(priv->regs + TSI721_DEV_CHAN_INTE);\n\t\tch_inte |= TSI721_INT_OMSG_CHAN(ch);\n\t\tiowrite32(ch_inte, priv->regs + TSI721_DEV_CHAN_INTE);\n\t}\n\n\tspin_unlock(&priv->omsg_ring[ch].lock);\n\n\tif (mport->outb_msg[ch].mcback && do_callback)\n\t\tmport->outb_msg[ch].mcback(mport, dev_id, ch, tx_slot);\n}\n\n \nstatic int tsi721_open_outb_mbox(struct rio_mport *mport, void *dev_id,\n\t\t\t\t int mbox, int entries)\n{\n\tstruct tsi721_device *priv = mport->priv;\n\tstruct tsi721_omsg_desc *bd_ptr;\n\tint i, rc = 0;\n\n\tif ((entries < TSI721_OMSGD_MIN_RING_SIZE) ||\n\t    (entries > (TSI721_OMSGD_RING_SIZE)) ||\n\t    (!is_power_of_2(entries)) || mbox >= RIO_MAX_MBOX) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif ((mbox_sel & (1 << mbox)) == 0) {\n\t\trc = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tpriv->omsg_ring[mbox].dev_id = dev_id;\n\tpriv->omsg_ring[mbox].size = entries;\n\tpriv->omsg_ring[mbox].sts_rdptr = 0;\n\tspin_lock_init(&priv->omsg_ring[mbox].lock);\n\n\t \n\tfor (i = 0; i < entries; i++) {\n\t\tpriv->omsg_ring[mbox].omq_base[i] =\n\t\t\tdma_alloc_coherent(\n\t\t\t\t&priv->pdev->dev, TSI721_MSG_BUFFER_SIZE,\n\t\t\t\t&priv->omsg_ring[mbox].omq_phys[i],\n\t\t\t\tGFP_KERNEL);\n\t\tif (priv->omsg_ring[mbox].omq_base[i] == NULL) {\n\t\t\ttsi_debug(OMSG, &priv->pdev->dev,\n\t\t\t\t  \"ENOMEM for OB_MSG_%d data buffer\", mbox);\n\t\t\trc = -ENOMEM;\n\t\t\tgoto out_buf;\n\t\t}\n\t}\n\n\t \n\tpriv->omsg_ring[mbox].omd_base = dma_alloc_coherent(\n\t\t\t\t&priv->pdev->dev,\n\t\t\t\t(entries + 1) * sizeof(struct tsi721_omsg_desc),\n\t\t\t\t&priv->omsg_ring[mbox].omd_phys, GFP_KERNEL);\n\tif (priv->omsg_ring[mbox].omd_base == NULL) {\n\t\ttsi_debug(OMSG, &priv->pdev->dev,\n\t\t\t\"ENOMEM for OB_MSG_%d descriptor memory\", mbox);\n\t\trc = -ENOMEM;\n\t\tgoto out_buf;\n\t}\n\n\tpriv->omsg_ring[mbox].tx_slot = 0;\n\n\t \n\tpriv->omsg_ring[mbox].sts_size = roundup_pow_of_two(entries + 1);\n\tpriv->omsg_ring[mbox].sts_base = dma_alloc_coherent(&priv->pdev->dev,\n\t\t\t\t\t\t\t    priv->omsg_ring[mbox].sts_size * sizeof(struct tsi721_dma_sts),\n\t\t\t\t\t\t\t    &priv->omsg_ring[mbox].sts_phys,\n\t\t\t\t\t\t\t    GFP_KERNEL);\n\tif (priv->omsg_ring[mbox].sts_base == NULL) {\n\t\ttsi_debug(OMSG, &priv->pdev->dev,\n\t\t\t\"ENOMEM for OB_MSG_%d status FIFO\", mbox);\n\t\trc = -ENOMEM;\n\t\tgoto out_desc;\n\t}\n\n\t \n\n\t \n\tiowrite32(((u64)priv->omsg_ring[mbox].omd_phys >> 32),\n\t\t\tpriv->regs + TSI721_OBDMAC_DPTRH(mbox));\n\tiowrite32(((u64)priv->omsg_ring[mbox].omd_phys &\n\t\t\t\t\tTSI721_OBDMAC_DPTRL_MASK),\n\t\t\tpriv->regs + TSI721_OBDMAC_DPTRL(mbox));\n\n\t \n\tiowrite32(((u64)priv->omsg_ring[mbox].sts_phys >> 32),\n\t\t\tpriv->regs + TSI721_OBDMAC_DSBH(mbox));\n\tiowrite32(((u64)priv->omsg_ring[mbox].sts_phys &\n\t\t\t\t\tTSI721_OBDMAC_DSBL_MASK),\n\t\t\tpriv->regs + TSI721_OBDMAC_DSBL(mbox));\n\tiowrite32(TSI721_DMAC_DSSZ_SIZE(priv->omsg_ring[mbox].sts_size),\n\t\tpriv->regs + (u32)TSI721_OBDMAC_DSSZ(mbox));\n\n\t \n\n#ifdef CONFIG_PCI_MSI\n\tif (priv->flags & TSI721_USING_MSIX) {\n\t\tint idx = TSI721_VECT_OMB0_DONE + mbox;\n\n\t\t \n\t\trc = request_irq(priv->msix[idx].vector, tsi721_omsg_msix, 0,\n\t\t\t\t priv->msix[idx].irq_name, (void *)priv);\n\n\t\tif (rc) {\n\t\t\ttsi_debug(OMSG, &priv->pdev->dev,\n\t\t\t\t\"Unable to get MSI-X IRQ for OBOX%d-DONE\",\n\t\t\t\tmbox);\n\t\t\tgoto out_stat;\n\t\t}\n\n\t\tidx = TSI721_VECT_OMB0_INT + mbox;\n\t\trc = request_irq(priv->msix[idx].vector, tsi721_omsg_msix, 0,\n\t\t\t\t priv->msix[idx].irq_name, (void *)priv);\n\n\t\tif (rc)\t{\n\t\t\ttsi_debug(OMSG, &priv->pdev->dev,\n\t\t\t\t\"Unable to get MSI-X IRQ for MBOX%d-INT\", mbox);\n\t\t\tidx = TSI721_VECT_OMB0_DONE + mbox;\n\t\t\tfree_irq(priv->msix[idx].vector, (void *)priv);\n\t\t\tgoto out_stat;\n\t\t}\n\t}\n#endif  \n\n\ttsi721_omsg_interrupt_enable(priv, mbox, TSI721_OBDMAC_INT_ALL);\n\n\t \n\tbd_ptr = priv->omsg_ring[mbox].omd_base;\n\tbd_ptr[entries].type_id = cpu_to_le32(DTYPE5 << 29);\n\tbd_ptr[entries].msg_info = 0;\n\tbd_ptr[entries].next_lo =\n\t\tcpu_to_le32((u64)priv->omsg_ring[mbox].omd_phys &\n\t\tTSI721_OBDMAC_DPTRL_MASK);\n\tbd_ptr[entries].next_hi =\n\t\tcpu_to_le32((u64)priv->omsg_ring[mbox].omd_phys >> 32);\n\tpriv->omsg_ring[mbox].wr_count = 0;\n\tmb();\n\n\t \n\tiowrite32(TSI721_OBDMAC_CTL_RETRY_THR | TSI721_OBDMAC_CTL_INIT,\n\t\t  priv->regs + TSI721_OBDMAC_CTL(mbox));\n\tioread32(priv->regs + TSI721_OBDMAC_DWRCNT(mbox));\n\tudelay(10);\n\n\tpriv->omsg_init[mbox] = 1;\n\n\treturn 0;\n\n#ifdef CONFIG_PCI_MSI\nout_stat:\n\tdma_free_coherent(&priv->pdev->dev,\n\t\tpriv->omsg_ring[mbox].sts_size * sizeof(struct tsi721_dma_sts),\n\t\tpriv->omsg_ring[mbox].sts_base,\n\t\tpriv->omsg_ring[mbox].sts_phys);\n\n\tpriv->omsg_ring[mbox].sts_base = NULL;\n#endif  \n\nout_desc:\n\tdma_free_coherent(&priv->pdev->dev,\n\t\t(entries + 1) * sizeof(struct tsi721_omsg_desc),\n\t\tpriv->omsg_ring[mbox].omd_base,\n\t\tpriv->omsg_ring[mbox].omd_phys);\n\n\tpriv->omsg_ring[mbox].omd_base = NULL;\n\nout_buf:\n\tfor (i = 0; i < priv->omsg_ring[mbox].size; i++) {\n\t\tif (priv->omsg_ring[mbox].omq_base[i]) {\n\t\t\tdma_free_coherent(&priv->pdev->dev,\n\t\t\t\tTSI721_MSG_BUFFER_SIZE,\n\t\t\t\tpriv->omsg_ring[mbox].omq_base[i],\n\t\t\t\tpriv->omsg_ring[mbox].omq_phys[i]);\n\n\t\t\tpriv->omsg_ring[mbox].omq_base[i] = NULL;\n\t\t}\n\t}\n\nout:\n\treturn rc;\n}\n\n \nstatic void tsi721_close_outb_mbox(struct rio_mport *mport, int mbox)\n{\n\tstruct tsi721_device *priv = mport->priv;\n\tu32 i;\n\n\tif (!priv->omsg_init[mbox])\n\t\treturn;\n\tpriv->omsg_init[mbox] = 0;\n\n\t \n\n\ttsi721_omsg_interrupt_disable(priv, mbox, TSI721_OBDMAC_INT_ALL);\n\n#ifdef CONFIG_PCI_MSI\n\tif (priv->flags & TSI721_USING_MSIX) {\n\t\tfree_irq(priv->msix[TSI721_VECT_OMB0_DONE + mbox].vector,\n\t\t\t (void *)priv);\n\t\tfree_irq(priv->msix[TSI721_VECT_OMB0_INT + mbox].vector,\n\t\t\t (void *)priv);\n\t}\n#endif  \n\n\t \n\tdma_free_coherent(&priv->pdev->dev,\n\t\tpriv->omsg_ring[mbox].sts_size * sizeof(struct tsi721_dma_sts),\n\t\tpriv->omsg_ring[mbox].sts_base,\n\t\tpriv->omsg_ring[mbox].sts_phys);\n\n\tpriv->omsg_ring[mbox].sts_base = NULL;\n\n\t \n\tdma_free_coherent(&priv->pdev->dev,\n\t\t(priv->omsg_ring[mbox].size + 1) *\n\t\t\tsizeof(struct tsi721_omsg_desc),\n\t\tpriv->omsg_ring[mbox].omd_base,\n\t\tpriv->omsg_ring[mbox].omd_phys);\n\n\tpriv->omsg_ring[mbox].omd_base = NULL;\n\n\t \n\tfor (i = 0; i < priv->omsg_ring[mbox].size; i++) {\n\t\tif (priv->omsg_ring[mbox].omq_base[i]) {\n\t\t\tdma_free_coherent(&priv->pdev->dev,\n\t\t\t\tTSI721_MSG_BUFFER_SIZE,\n\t\t\t\tpriv->omsg_ring[mbox].omq_base[i],\n\t\t\t\tpriv->omsg_ring[mbox].omq_phys[i]);\n\n\t\t\tpriv->omsg_ring[mbox].omq_base[i] = NULL;\n\t\t}\n\t}\n}\n\n \nstatic void tsi721_imsg_handler(struct tsi721_device *priv, int ch)\n{\n\tu32 mbox = ch - 4;\n\tu32 imsg_int;\n\tstruct rio_mport *mport = &priv->mport;\n\n\tspin_lock(&priv->imsg_ring[mbox].lock);\n\n\timsg_int = ioread32(priv->regs + TSI721_IBDMAC_INT(ch));\n\n\tif (imsg_int & TSI721_IBDMAC_INT_SRTO)\n\t\ttsi_info(&priv->pdev->dev, \"IB MBOX%d SRIO timeout\", mbox);\n\n\tif (imsg_int & TSI721_IBDMAC_INT_PC_ERROR)\n\t\ttsi_info(&priv->pdev->dev, \"IB MBOX%d PCIe error\", mbox);\n\n\tif (imsg_int & TSI721_IBDMAC_INT_FQ_LOW)\n\t\ttsi_info(&priv->pdev->dev, \"IB MBOX%d IB free queue low\", mbox);\n\n\t \n\tiowrite32(imsg_int, priv->regs + TSI721_IBDMAC_INT(ch));\n\n\t \n\tif (imsg_int & TSI721_IBDMAC_INT_DQ_RCV &&\n\t\tmport->inb_msg[mbox].mcback)\n\t\tmport->inb_msg[mbox].mcback(mport,\n\t\t\t\tpriv->imsg_ring[mbox].dev_id, mbox, -1);\n\n\tif (!(priv->flags & TSI721_USING_MSIX)) {\n\t\tu32 ch_inte;\n\n\t\t \n\t\tch_inte = ioread32(priv->regs + TSI721_DEV_CHAN_INTE);\n\t\tch_inte |= TSI721_INT_IMSG_CHAN(ch);\n\t\tiowrite32(ch_inte, priv->regs + TSI721_DEV_CHAN_INTE);\n\t}\n\n\tspin_unlock(&priv->imsg_ring[mbox].lock);\n}\n\n \nstatic int tsi721_open_inb_mbox(struct rio_mport *mport, void *dev_id,\n\t\t\t\tint mbox, int entries)\n{\n\tstruct tsi721_device *priv = mport->priv;\n\tint ch = mbox + 4;\n\tint i;\n\tu64 *free_ptr;\n\tint rc = 0;\n\n\tif ((entries < TSI721_IMSGD_MIN_RING_SIZE) ||\n\t    (entries > TSI721_IMSGD_RING_SIZE) ||\n\t    (!is_power_of_2(entries)) || mbox >= RIO_MAX_MBOX) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif ((mbox_sel & (1 << mbox)) == 0) {\n\t\trc = -ENODEV;\n\t\tgoto out;\n\t}\n\n\t \n\tpriv->imsg_ring[mbox].dev_id = dev_id;\n\tpriv->imsg_ring[mbox].size = entries;\n\tpriv->imsg_ring[mbox].rx_slot = 0;\n\tpriv->imsg_ring[mbox].desc_rdptr = 0;\n\tpriv->imsg_ring[mbox].fq_wrptr = 0;\n\tfor (i = 0; i < priv->imsg_ring[mbox].size; i++)\n\t\tpriv->imsg_ring[mbox].imq_base[i] = NULL;\n\tspin_lock_init(&priv->imsg_ring[mbox].lock);\n\n\t \n\tpriv->imsg_ring[mbox].buf_base =\n\t\tdma_alloc_coherent(&priv->pdev->dev,\n\t\t\t\t   entries * TSI721_MSG_BUFFER_SIZE,\n\t\t\t\t   &priv->imsg_ring[mbox].buf_phys,\n\t\t\t\t   GFP_KERNEL);\n\n\tif (priv->imsg_ring[mbox].buf_base == NULL) {\n\t\ttsi_err(&priv->pdev->dev,\n\t\t\t\"Failed to allocate buffers for IB MBOX%d\", mbox);\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t \n\tpriv->imsg_ring[mbox].imfq_base =\n\t\tdma_alloc_coherent(&priv->pdev->dev,\n\t\t\t\t   entries * 8,\n\t\t\t\t   &priv->imsg_ring[mbox].imfq_phys,\n\t\t\t\t   GFP_KERNEL);\n\n\tif (priv->imsg_ring[mbox].imfq_base == NULL) {\n\t\ttsi_err(&priv->pdev->dev,\n\t\t\t\"Failed to allocate free queue for IB MBOX%d\", mbox);\n\t\trc = -ENOMEM;\n\t\tgoto out_buf;\n\t}\n\n\t \n\tpriv->imsg_ring[mbox].imd_base =\n\t\tdma_alloc_coherent(&priv->pdev->dev,\n\t\t\t\t   entries * sizeof(struct tsi721_imsg_desc),\n\t\t\t\t   &priv->imsg_ring[mbox].imd_phys, GFP_KERNEL);\n\n\tif (priv->imsg_ring[mbox].imd_base == NULL) {\n\t\ttsi_err(&priv->pdev->dev,\n\t\t\t\"Failed to allocate descriptor memory for IB MBOX%d\",\n\t\t\tmbox);\n\t\trc = -ENOMEM;\n\t\tgoto out_dma;\n\t}\n\n\t \n\tfree_ptr = priv->imsg_ring[mbox].imfq_base;\n\tfor (i = 0; i < entries; i++)\n\t\tfree_ptr[i] = cpu_to_le64(\n\t\t\t\t(u64)(priv->imsg_ring[mbox].buf_phys) +\n\t\t\t\ti * 0x1000);\n\n\tmb();\n\n\t \n\tif (!(priv->flags & TSI721_IMSGID_SET)) {\n\t\tiowrite32((u32)priv->mport.host_deviceid,\n\t\t\tpriv->regs + TSI721_IB_DEVID);\n\t\tpriv->flags |= TSI721_IMSGID_SET;\n\t}\n\n\t \n\n\t \n\tiowrite32(((u64)priv->imsg_ring[mbox].imfq_phys >> 32),\n\t\tpriv->regs + TSI721_IBDMAC_FQBH(ch));\n\tiowrite32(((u64)priv->imsg_ring[mbox].imfq_phys &\n\t\t\tTSI721_IBDMAC_FQBL_MASK),\n\t\tpriv->regs+TSI721_IBDMAC_FQBL(ch));\n\tiowrite32(TSI721_DMAC_DSSZ_SIZE(entries),\n\t\tpriv->regs + TSI721_IBDMAC_FQSZ(ch));\n\n\t \n\tiowrite32(((u64)priv->imsg_ring[mbox].imd_phys >> 32),\n\t\tpriv->regs + TSI721_IBDMAC_DQBH(ch));\n\tiowrite32(((u32)priv->imsg_ring[mbox].imd_phys &\n\t\t   (u32)TSI721_IBDMAC_DQBL_MASK),\n\t\tpriv->regs+TSI721_IBDMAC_DQBL(ch));\n\tiowrite32(TSI721_DMAC_DSSZ_SIZE(entries),\n\t\tpriv->regs + TSI721_IBDMAC_DQSZ(ch));\n\n\t \n\n#ifdef CONFIG_PCI_MSI\n\tif (priv->flags & TSI721_USING_MSIX) {\n\t\tint idx = TSI721_VECT_IMB0_RCV + mbox;\n\n\t\t \n\t\trc = request_irq(priv->msix[idx].vector, tsi721_imsg_msix, 0,\n\t\t\t\t priv->msix[idx].irq_name, (void *)priv);\n\n\t\tif (rc) {\n\t\t\ttsi_debug(IMSG, &priv->pdev->dev,\n\t\t\t\t\"Unable to get MSI-X IRQ for IBOX%d-DONE\",\n\t\t\t\tmbox);\n\t\t\tgoto out_desc;\n\t\t}\n\n\t\tidx = TSI721_VECT_IMB0_INT + mbox;\n\t\trc = request_irq(priv->msix[idx].vector, tsi721_imsg_msix, 0,\n\t\t\t\t priv->msix[idx].irq_name, (void *)priv);\n\n\t\tif (rc)\t{\n\t\t\ttsi_debug(IMSG, &priv->pdev->dev,\n\t\t\t\t\"Unable to get MSI-X IRQ for IBOX%d-INT\", mbox);\n\t\t\tfree_irq(\n\t\t\t\tpriv->msix[TSI721_VECT_IMB0_RCV + mbox].vector,\n\t\t\t\t(void *)priv);\n\t\t\tgoto out_desc;\n\t\t}\n\t}\n#endif  \n\n\ttsi721_imsg_interrupt_enable(priv, ch, TSI721_IBDMAC_INT_ALL);\n\n\t \n\tiowrite32(TSI721_IBDMAC_CTL_INIT, priv->regs + TSI721_IBDMAC_CTL(ch));\n\tioread32(priv->regs + TSI721_IBDMAC_CTL(ch));\n\tudelay(10);\n\tpriv->imsg_ring[mbox].fq_wrptr = entries - 1;\n\tiowrite32(entries - 1, priv->regs + TSI721_IBDMAC_FQWP(ch));\n\n\tpriv->imsg_init[mbox] = 1;\n\treturn 0;\n\n#ifdef CONFIG_PCI_MSI\nout_desc:\n\tdma_free_coherent(&priv->pdev->dev,\n\t\tpriv->imsg_ring[mbox].size * sizeof(struct tsi721_imsg_desc),\n\t\tpriv->imsg_ring[mbox].imd_base,\n\t\tpriv->imsg_ring[mbox].imd_phys);\n\n\tpriv->imsg_ring[mbox].imd_base = NULL;\n#endif  \n\nout_dma:\n\tdma_free_coherent(&priv->pdev->dev,\n\t\tpriv->imsg_ring[mbox].size * 8,\n\t\tpriv->imsg_ring[mbox].imfq_base,\n\t\tpriv->imsg_ring[mbox].imfq_phys);\n\n\tpriv->imsg_ring[mbox].imfq_base = NULL;\n\nout_buf:\n\tdma_free_coherent(&priv->pdev->dev,\n\t\tpriv->imsg_ring[mbox].size * TSI721_MSG_BUFFER_SIZE,\n\t\tpriv->imsg_ring[mbox].buf_base,\n\t\tpriv->imsg_ring[mbox].buf_phys);\n\n\tpriv->imsg_ring[mbox].buf_base = NULL;\n\nout:\n\treturn rc;\n}\n\n \nstatic void tsi721_close_inb_mbox(struct rio_mport *mport, int mbox)\n{\n\tstruct tsi721_device *priv = mport->priv;\n\tu32 rx_slot;\n\tint ch = mbox + 4;\n\n\tif (!priv->imsg_init[mbox])  \n\t\treturn;\n\tpriv->imsg_init[mbox] = 0;\n\n\t \n\n\t \n\ttsi721_imsg_interrupt_disable(priv, ch, TSI721_OBDMAC_INT_MASK);\n\n#ifdef CONFIG_PCI_MSI\n\tif (priv->flags & TSI721_USING_MSIX) {\n\t\tfree_irq(priv->msix[TSI721_VECT_IMB0_RCV + mbox].vector,\n\t\t\t\t(void *)priv);\n\t\tfree_irq(priv->msix[TSI721_VECT_IMB0_INT + mbox].vector,\n\t\t\t\t(void *)priv);\n\t}\n#endif  \n\n\t \n\tfor (rx_slot = 0; rx_slot < priv->imsg_ring[mbox].size; rx_slot++)\n\t\tpriv->imsg_ring[mbox].imq_base[rx_slot] = NULL;\n\n\t \n\tdma_free_coherent(&priv->pdev->dev,\n\t\tpriv->imsg_ring[mbox].size * TSI721_MSG_BUFFER_SIZE,\n\t\tpriv->imsg_ring[mbox].buf_base,\n\t\tpriv->imsg_ring[mbox].buf_phys);\n\n\tpriv->imsg_ring[mbox].buf_base = NULL;\n\n\t \n\tdma_free_coherent(&priv->pdev->dev,\n\t\tpriv->imsg_ring[mbox].size * 8,\n\t\tpriv->imsg_ring[mbox].imfq_base,\n\t\tpriv->imsg_ring[mbox].imfq_phys);\n\n\tpriv->imsg_ring[mbox].imfq_base = NULL;\n\n\t \n\tdma_free_coherent(&priv->pdev->dev,\n\t\tpriv->imsg_ring[mbox].size * sizeof(struct tsi721_imsg_desc),\n\t\tpriv->imsg_ring[mbox].imd_base,\n\t\tpriv->imsg_ring[mbox].imd_phys);\n\n\tpriv->imsg_ring[mbox].imd_base = NULL;\n}\n\n \nstatic int tsi721_add_inb_buffer(struct rio_mport *mport, int mbox, void *buf)\n{\n\tstruct tsi721_device *priv = mport->priv;\n\tu32 rx_slot;\n\tint rc = 0;\n\n\trx_slot = priv->imsg_ring[mbox].rx_slot;\n\tif (priv->imsg_ring[mbox].imq_base[rx_slot]) {\n\t\ttsi_err(&priv->pdev->dev,\n\t\t\t\"Error adding inbound buffer %d, buffer exists\",\n\t\t\trx_slot);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tpriv->imsg_ring[mbox].imq_base[rx_slot] = buf;\n\n\tif (++priv->imsg_ring[mbox].rx_slot == priv->imsg_ring[mbox].size)\n\t\tpriv->imsg_ring[mbox].rx_slot = 0;\n\nout:\n\treturn rc;\n}\n\n \nstatic void *tsi721_get_inb_message(struct rio_mport *mport, int mbox)\n{\n\tstruct tsi721_device *priv = mport->priv;\n\tstruct tsi721_imsg_desc *desc;\n\tu32 rx_slot;\n\tvoid *rx_virt = NULL;\n\tu64 rx_phys;\n\tvoid *buf = NULL;\n\tu64 *free_ptr;\n\tint ch = mbox + 4;\n\tint msg_size;\n\n\tif (!priv->imsg_init[mbox])\n\t\treturn NULL;\n\n\tdesc = priv->imsg_ring[mbox].imd_base;\n\tdesc += priv->imsg_ring[mbox].desc_rdptr;\n\n\tif (!(le32_to_cpu(desc->msg_info) & TSI721_IMD_HO))\n\t\tgoto out;\n\n\trx_slot = priv->imsg_ring[mbox].rx_slot;\n\twhile (priv->imsg_ring[mbox].imq_base[rx_slot] == NULL) {\n\t\tif (++rx_slot == priv->imsg_ring[mbox].size)\n\t\t\trx_slot = 0;\n\t}\n\n\trx_phys = ((u64)le32_to_cpu(desc->bufptr_hi) << 32) |\n\t\t\tle32_to_cpu(desc->bufptr_lo);\n\n\trx_virt = priv->imsg_ring[mbox].buf_base +\n\t\t  (rx_phys - (u64)priv->imsg_ring[mbox].buf_phys);\n\n\tbuf = priv->imsg_ring[mbox].imq_base[rx_slot];\n\tmsg_size = le32_to_cpu(desc->msg_info) & TSI721_IMD_BCOUNT;\n\tif (msg_size == 0)\n\t\tmsg_size = RIO_MAX_MSG_SIZE;\n\n\tmemcpy(buf, rx_virt, msg_size);\n\tpriv->imsg_ring[mbox].imq_base[rx_slot] = NULL;\n\n\tdesc->msg_info &= cpu_to_le32(~TSI721_IMD_HO);\n\tif (++priv->imsg_ring[mbox].desc_rdptr == priv->imsg_ring[mbox].size)\n\t\tpriv->imsg_ring[mbox].desc_rdptr = 0;\n\n\tiowrite32(priv->imsg_ring[mbox].desc_rdptr,\n\t\tpriv->regs + TSI721_IBDMAC_DQRP(ch));\n\n\t \n\tfree_ptr = priv->imsg_ring[mbox].imfq_base;\n\tfree_ptr[priv->imsg_ring[mbox].fq_wrptr] = cpu_to_le64(rx_phys);\n\n\tif (++priv->imsg_ring[mbox].fq_wrptr == priv->imsg_ring[mbox].size)\n\t\tpriv->imsg_ring[mbox].fq_wrptr = 0;\n\n\tiowrite32(priv->imsg_ring[mbox].fq_wrptr,\n\t\tpriv->regs + TSI721_IBDMAC_FQWP(ch));\nout:\n\treturn buf;\n}\n\n \nstatic int tsi721_messages_init(struct tsi721_device *priv)\n{\n\tint\tch;\n\n\tiowrite32(0, priv->regs + TSI721_SMSG_ECC_LOG);\n\tiowrite32(0, priv->regs + TSI721_RETRY_GEN_CNT);\n\tiowrite32(0, priv->regs + TSI721_RETRY_RX_CNT);\n\n\t \n\tiowrite32(TSI721_RQRPTO_VAL, priv->regs + TSI721_RQRPTO);\n\n\t \n\tfor (ch = 0; ch < TSI721_IMSG_CHNUM; ch++) {\n\t\t \n\t\tiowrite32(TSI721_IBDMAC_INT_MASK,\n\t\t\tpriv->regs + TSI721_IBDMAC_INT(ch));\n\t\t \n\t\tiowrite32(0, priv->regs + TSI721_IBDMAC_STS(ch));\n\n\t\tiowrite32(TSI721_SMSG_ECC_COR_LOG_MASK,\n\t\t\t\tpriv->regs + TSI721_SMSG_ECC_COR_LOG(ch));\n\t\tiowrite32(TSI721_SMSG_ECC_NCOR_MASK,\n\t\t\t\tpriv->regs + TSI721_SMSG_ECC_NCOR(ch));\n\t}\n\n\treturn 0;\n}\n\n \nstatic int tsi721_query_mport(struct rio_mport *mport,\n\t\t\t      struct rio_mport_attr *attr)\n{\n\tstruct tsi721_device *priv = mport->priv;\n\tu32 rval;\n\n\trval = ioread32(priv->regs + 0x100 + RIO_PORT_N_ERR_STS_CSR(0, 0));\n\tif (rval & RIO_PORT_N_ERR_STS_PORT_OK) {\n\t\trval = ioread32(priv->regs + 0x100 + RIO_PORT_N_CTL2_CSR(0, 0));\n\t\tattr->link_speed = (rval & RIO_PORT_N_CTL2_SEL_BAUD) >> 28;\n\t\trval = ioread32(priv->regs + 0x100 + RIO_PORT_N_CTL_CSR(0, 0));\n\t\tattr->link_width = (rval & RIO_PORT_N_CTL_IPW) >> 27;\n\t} else\n\t\tattr->link_speed = RIO_LINK_DOWN;\n\n#ifdef CONFIG_RAPIDIO_DMA_ENGINE\n\tattr->flags = RIO_MPORT_DMA | RIO_MPORT_DMA_SG;\n\tattr->dma_max_sge = 0;\n\tattr->dma_max_size = TSI721_BDMA_MAX_BCOUNT;\n\tattr->dma_align = 0;\n#else\n\tattr->flags = 0;\n#endif\n\treturn 0;\n}\n\n \nstatic void tsi721_disable_ints(struct tsi721_device *priv)\n{\n\tint ch;\n\n\t \n\tiowrite32(0, priv->regs + TSI721_DEV_INTE);\n\n\t \n\tiowrite32(0, priv->regs + TSI721_DEV_CHAN_INTE);\n\n\t \n\tfor (ch = 0; ch < TSI721_IMSG_CHNUM; ch++)\n\t\tiowrite32(0, priv->regs + TSI721_IBDMAC_INTE(ch));\n\n\t \n\tfor (ch = 0; ch < TSI721_OMSG_CHNUM; ch++)\n\t\tiowrite32(0, priv->regs + TSI721_OBDMAC_INTE(ch));\n\n\t \n\tiowrite32(0, priv->regs + TSI721_SMSG_INTE);\n\n\t \n\tfor (ch = 0; ch < TSI721_DMA_MAXCH; ch++)\n\t\tiowrite32(0,\n\t\t\tpriv->regs + TSI721_DMAC_BASE(ch) + TSI721_DMAC_INTE);\n\n\t \n\tiowrite32(0, priv->regs + TSI721_BDMA_INTE);\n\n\t \n\tfor (ch = 0; ch < TSI721_SRIO_MAXCH; ch++)\n\t\tiowrite32(0, priv->regs + TSI721_SR_CHINTE(ch));\n\n\t \n\tiowrite32(0, priv->regs + TSI721_SR2PC_GEN_INTE);\n\n\t \n\tiowrite32(0, priv->regs + TSI721_PC2SR_INTE);\n\n\t \n\tiowrite32(0, priv->regs + TSI721_I2C_INT_ENABLE);\n\n\t \n\tiowrite32(0, priv->regs + TSI721_RIO_EM_INT_ENABLE);\n\tiowrite32(0, priv->regs + TSI721_RIO_EM_DEV_INT_EN);\n}\n\nstatic struct rio_ops tsi721_rio_ops = {\n\t.lcread\t\t\t= tsi721_lcread,\n\t.lcwrite\t\t= tsi721_lcwrite,\n\t.cread\t\t\t= tsi721_cread_dma,\n\t.cwrite\t\t\t= tsi721_cwrite_dma,\n\t.dsend\t\t\t= tsi721_dsend,\n\t.open_inb_mbox\t\t= tsi721_open_inb_mbox,\n\t.close_inb_mbox\t\t= tsi721_close_inb_mbox,\n\t.open_outb_mbox\t\t= tsi721_open_outb_mbox,\n\t.close_outb_mbox\t= tsi721_close_outb_mbox,\n\t.add_outb_message\t= tsi721_add_outb_message,\n\t.add_inb_buffer\t\t= tsi721_add_inb_buffer,\n\t.get_inb_message\t= tsi721_get_inb_message,\n\t.map_inb\t\t= tsi721_rio_map_inb_mem,\n\t.unmap_inb\t\t= tsi721_rio_unmap_inb_mem,\n\t.pwenable\t\t= tsi721_pw_enable,\n\t.query_mport\t\t= tsi721_query_mport,\n\t.map_outb\t\t= tsi721_map_outb_win,\n\t.unmap_outb\t\t= tsi721_unmap_outb_win,\n};\n\nstatic void tsi721_mport_release(struct device *dev)\n{\n\tstruct rio_mport *mport = to_rio_mport(dev);\n\n\ttsi_debug(EXIT, dev, \"%s id=%d\", mport->name, mport->id);\n}\n\n \nstatic int tsi721_setup_mport(struct tsi721_device *priv)\n{\n\tstruct pci_dev *pdev = priv->pdev;\n\tint err = 0;\n\tstruct rio_mport *mport = &priv->mport;\n\n\terr = rio_mport_initialize(mport);\n\tif (err)\n\t\treturn err;\n\n\tmport->ops = &tsi721_rio_ops;\n\tmport->index = 0;\n\tmport->sys_size = 0;  \n\tmport->priv = (void *)priv;\n\tmport->phys_efptr = 0x100;\n\tmport->phys_rmap = 1;\n\tmport->dev.parent = &pdev->dev;\n\tmport->dev.release = tsi721_mport_release;\n\n\tINIT_LIST_HEAD(&mport->dbells);\n\n\trio_init_dbell_res(&mport->riores[RIO_DOORBELL_RESOURCE], 0, 0xffff);\n\trio_init_mbox_res(&mport->riores[RIO_INB_MBOX_RESOURCE], 0, 3);\n\trio_init_mbox_res(&mport->riores[RIO_OUTB_MBOX_RESOURCE], 0, 3);\n\tsnprintf(mport->name, RIO_MAX_MPORT_NAME, \"%s(%s)\",\n\t\t dev_driver_string(&pdev->dev), dev_name(&pdev->dev));\n\n\t \n\n#ifdef CONFIG_PCI_MSI\n\tif (!tsi721_enable_msix(priv))\n\t\tpriv->flags |= TSI721_USING_MSIX;\n\telse if (!pci_enable_msi(pdev))\n\t\tpriv->flags |= TSI721_USING_MSI;\n\telse\n\t\ttsi_debug(MPORT, &pdev->dev,\n\t\t\t \"MSI/MSI-X is not available. Using legacy INTx.\");\n#endif  \n\n\terr = tsi721_request_irq(priv);\n\n\tif (err) {\n\t\ttsi_err(&pdev->dev, \"Unable to get PCI IRQ %02X (err=0x%x)\",\n\t\t\tpdev->irq, err);\n\t\treturn err;\n\t}\n\n#ifdef CONFIG_RAPIDIO_DMA_ENGINE\n\terr = tsi721_register_dma(priv);\n\tif (err)\n\t\tgoto err_exit;\n#endif\n\t \n\tiowrite32(ioread32(priv->regs + TSI721_DEVCTL) |\n\t\t  TSI721_DEVCTL_SRBOOT_CMPL,\n\t\t  priv->regs + TSI721_DEVCTL);\n\n\tif (mport->host_deviceid >= 0)\n\t\tiowrite32(RIO_PORT_GEN_HOST | RIO_PORT_GEN_MASTER |\n\t\t\t  RIO_PORT_GEN_DISCOVERED,\n\t\t\t  priv->regs + (0x100 + RIO_PORT_GEN_CTL_CSR));\n\telse\n\t\tiowrite32(0, priv->regs + (0x100 + RIO_PORT_GEN_CTL_CSR));\n\n\terr = rio_register_mport(mport);\n\tif (err) {\n\t\ttsi721_unregister_dma(priv);\n\t\tgoto err_exit;\n\t}\n\n\treturn 0;\n\nerr_exit:\n\ttsi721_free_irq(priv);\n\treturn err;\n}\n\nstatic int tsi721_probe(struct pci_dev *pdev,\n\t\t\t\t  const struct pci_device_id *id)\n{\n\tstruct tsi721_device *priv;\n\tint err;\n\n\tpriv = kzalloc(sizeof(struct tsi721_device), GFP_KERNEL);\n\tif (!priv) {\n\t\terr = -ENOMEM;\n\t\tgoto err_exit;\n\t}\n\n\terr = pci_enable_device(pdev);\n\tif (err) {\n\t\ttsi_err(&pdev->dev, \"Failed to enable PCI device\");\n\t\tgoto err_clean;\n\t}\n\n\tpriv->pdev = pdev;\n\n#ifdef DEBUG\n\t{\n\t\tint i;\n\n\t\tfor (i = 0; i < PCI_STD_NUM_BARS; i++) {\n\t\t\ttsi_debug(INIT, &pdev->dev, \"res%d %pR\",\n\t\t\t\t  i, &pdev->resource[i]);\n\t\t}\n\t}\n#endif\n\t \n\n\t \n\tif (!(pci_resource_flags(pdev, BAR_0) & IORESOURCE_MEM) ||\n\t    pci_resource_flags(pdev, BAR_0) & IORESOURCE_MEM_64 ||\n\t    pci_resource_len(pdev, BAR_0) < TSI721_REG_SPACE_SIZE) {\n\t\ttsi_err(&pdev->dev, \"Missing or misconfigured CSR BAR0\");\n\t\terr = -ENODEV;\n\t\tgoto err_disable_pdev;\n\t}\n\n\t \n\tif (!(pci_resource_flags(pdev, BAR_1) & IORESOURCE_MEM) ||\n\t    pci_resource_flags(pdev, BAR_1) & IORESOURCE_MEM_64 ||\n\t    pci_resource_len(pdev, BAR_1) < TSI721_DB_WIN_SIZE) {\n\t\ttsi_err(&pdev->dev, \"Missing or misconfigured Doorbell BAR1\");\n\t\terr = -ENODEV;\n\t\tgoto err_disable_pdev;\n\t}\n\n\t \n\n\tpriv->p2r_bar[0].size = priv->p2r_bar[1].size = 0;\n\n\tif (pci_resource_flags(pdev, BAR_2) & IORESOURCE_MEM_64) {\n\t\tif (pci_resource_flags(pdev, BAR_2) & IORESOURCE_PREFETCH)\n\t\t\ttsi_debug(INIT, &pdev->dev,\n\t\t\t\t \"Prefetchable OBW BAR2 will not be used\");\n\t\telse {\n\t\t\tpriv->p2r_bar[0].base = pci_resource_start(pdev, BAR_2);\n\t\t\tpriv->p2r_bar[0].size = pci_resource_len(pdev, BAR_2);\n\t\t}\n\t}\n\n\tif (pci_resource_flags(pdev, BAR_4) & IORESOURCE_MEM_64) {\n\t\tif (pci_resource_flags(pdev, BAR_4) & IORESOURCE_PREFETCH)\n\t\t\ttsi_debug(INIT, &pdev->dev,\n\t\t\t\t \"Prefetchable OBW BAR4 will not be used\");\n\t\telse {\n\t\t\tpriv->p2r_bar[1].base = pci_resource_start(pdev, BAR_4);\n\t\t\tpriv->p2r_bar[1].size = pci_resource_len(pdev, BAR_4);\n\t\t}\n\t}\n\n\terr = pci_request_regions(pdev, DRV_NAME);\n\tif (err) {\n\t\ttsi_err(&pdev->dev, \"Unable to obtain PCI resources\");\n\t\tgoto err_disable_pdev;\n\t}\n\n\tpci_set_master(pdev);\n\n\tpriv->regs = pci_ioremap_bar(pdev, BAR_0);\n\tif (!priv->regs) {\n\t\ttsi_err(&pdev->dev, \"Unable to map device registers space\");\n\t\terr = -ENOMEM;\n\t\tgoto err_free_res;\n\t}\n\n\tpriv->odb_base = pci_ioremap_bar(pdev, BAR_1);\n\tif (!priv->odb_base) {\n\t\ttsi_err(&pdev->dev, \"Unable to map outbound doorbells space\");\n\t\terr = -ENOMEM;\n\t\tgoto err_unmap_bars;\n\t}\n\n\t \n\tif (dma_set_mask(&pdev->dev, DMA_BIT_MASK(64))) {\n\t\terr = dma_set_mask(&pdev->dev, DMA_BIT_MASK(32));\n\t\tif (err) {\n\t\t\ttsi_err(&pdev->dev, \"Unable to set DMA mask\");\n\t\t\tgoto err_unmap_bars;\n\t\t}\n\n\t\tif (dma_set_coherent_mask(&pdev->dev, DMA_BIT_MASK(32)))\n\t\t\ttsi_info(&pdev->dev, \"Unable to set consistent DMA mask\");\n\t} else {\n\t\terr = dma_set_coherent_mask(&pdev->dev, DMA_BIT_MASK(64));\n\t\tif (err)\n\t\t\ttsi_info(&pdev->dev, \"Unable to set consistent DMA mask\");\n\t}\n\n\tBUG_ON(!pci_is_pcie(pdev));\n\n\t \n\tpcie_capability_clear_and_set_word(pdev, PCI_EXP_DEVCTL,\n\t\tPCI_EXP_DEVCTL_RELAX_EN | PCI_EXP_DEVCTL_NOSNOOP_EN, 0);\n\n\t \n\tif (pcie_mrrs >= 0) {\n\t\tif (pcie_mrrs <= 5)\n\t\t\tpcie_capability_clear_and_set_word(pdev, PCI_EXP_DEVCTL,\n\t\t\t\t\tPCI_EXP_DEVCTL_READRQ, pcie_mrrs << 12);\n\t\telse\n\t\t\ttsi_info(&pdev->dev,\n\t\t\t\t \"Invalid MRRS override value %d\", pcie_mrrs);\n\t}\n\n\t \n\tpcie_capability_clear_and_set_word(pdev, PCI_EXP_DEVCTL2,\n\t\t\t\t\t   PCI_EXP_DEVCTL2_COMP_TIMEOUT, 0x2);\n\n\t \n\tpci_write_config_dword(pdev, TSI721_PCIECFG_EPCTL, 0x01);\n\tpci_write_config_dword(pdev, TSI721_PCIECFG_MSIXTBL,\n\t\t\t\t\t\tTSI721_MSIXTBL_OFFSET);\n\tpci_write_config_dword(pdev, TSI721_PCIECFG_MSIXPBA,\n\t\t\t\t\t\tTSI721_MSIXPBA_OFFSET);\n\tpci_write_config_dword(pdev, TSI721_PCIECFG_EPCTL, 0);\n\t \n\n\ttsi721_disable_ints(priv);\n\n\ttsi721_init_pc2sr_mapping(priv);\n\ttsi721_init_sr2pc_mapping(priv);\n\n\tif (tsi721_bdma_maint_init(priv)) {\n\t\ttsi_err(&pdev->dev, \"BDMA initialization failed\");\n\t\terr = -ENOMEM;\n\t\tgoto err_unmap_bars;\n\t}\n\n\terr = tsi721_doorbell_init(priv);\n\tif (err)\n\t\tgoto err_free_bdma;\n\n\ttsi721_port_write_init(priv);\n\n\terr = tsi721_messages_init(priv);\n\tif (err)\n\t\tgoto err_free_consistent;\n\n\terr = tsi721_setup_mport(priv);\n\tif (err)\n\t\tgoto err_free_consistent;\n\n\tpci_set_drvdata(pdev, priv);\n\ttsi721_interrupts_init(priv);\n\n\treturn 0;\n\nerr_free_consistent:\n\ttsi721_port_write_free(priv);\n\ttsi721_doorbell_free(priv);\nerr_free_bdma:\n\ttsi721_bdma_maint_free(priv);\nerr_unmap_bars:\n\tif (priv->regs)\n\t\tiounmap(priv->regs);\n\tif (priv->odb_base)\n\t\tiounmap(priv->odb_base);\nerr_free_res:\n\tpci_release_regions(pdev);\nerr_disable_pdev:\n\tpci_disable_device(pdev);\nerr_clean:\n\tkfree(priv);\nerr_exit:\n\treturn err;\n}\n\nstatic void tsi721_remove(struct pci_dev *pdev)\n{\n\tstruct tsi721_device *priv = pci_get_drvdata(pdev);\n\n\ttsi_debug(EXIT, &pdev->dev, \"enter\");\n\n\ttsi721_disable_ints(priv);\n\ttsi721_free_irq(priv);\n\tflush_work(&priv->idb_work);\n\tflush_work(&priv->pw_work);\n\trio_unregister_mport(&priv->mport);\n\n\ttsi721_unregister_dma(priv);\n\ttsi721_bdma_maint_free(priv);\n\ttsi721_doorbell_free(priv);\n\ttsi721_port_write_free(priv);\n\ttsi721_close_sr2pc_mapping(priv);\n\n\tif (priv->regs)\n\t\tiounmap(priv->regs);\n\tif (priv->odb_base)\n\t\tiounmap(priv->odb_base);\n#ifdef CONFIG_PCI_MSI\n\tif (priv->flags & TSI721_USING_MSIX)\n\t\tpci_disable_msix(priv->pdev);\n\telse if (priv->flags & TSI721_USING_MSI)\n\t\tpci_disable_msi(priv->pdev);\n#endif\n\tpci_release_regions(pdev);\n\tpci_disable_device(pdev);\n\tpci_set_drvdata(pdev, NULL);\n\tkfree(priv);\n\ttsi_debug(EXIT, &pdev->dev, \"exit\");\n}\n\nstatic void tsi721_shutdown(struct pci_dev *pdev)\n{\n\tstruct tsi721_device *priv = pci_get_drvdata(pdev);\n\n\ttsi_debug(EXIT, &pdev->dev, \"enter\");\n\n\ttsi721_disable_ints(priv);\n\ttsi721_dma_stop_all(priv);\n\tpci_disable_device(pdev);\n}\n\nstatic const struct pci_device_id tsi721_pci_tbl[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_IDT, PCI_DEVICE_ID_TSI721) },\n\t{ 0, }\t \n};\n\nMODULE_DEVICE_TABLE(pci, tsi721_pci_tbl);\n\nstatic struct pci_driver tsi721_driver = {\n\t.name\t\t= \"tsi721\",\n\t.id_table\t= tsi721_pci_tbl,\n\t.probe\t\t= tsi721_probe,\n\t.remove\t\t= tsi721_remove,\n\t.shutdown\t= tsi721_shutdown,\n};\n\nmodule_pci_driver(tsi721_driver);\n\nMODULE_DESCRIPTION(\"IDT Tsi721 PCIExpress-to-SRIO bridge driver\");\nMODULE_AUTHOR(\"Integrated Device Technology, Inc.\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}