{
  "module_name": "nd_virtio.c",
  "hash_id": "39fa5c2ba39371fd86da6b89f71402daac9077a251412293d0e278f7f4e97b7b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/nvdimm/nd_virtio.c",
  "human_readable_source": "\n \n#include \"virtio_pmem.h\"\n#include \"nd.h\"\n\n  \nvoid virtio_pmem_host_ack(struct virtqueue *vq)\n{\n\tstruct virtio_pmem *vpmem = vq->vdev->priv;\n\tstruct virtio_pmem_request *req_data, *req_buf;\n\tunsigned long flags;\n\tunsigned int len;\n\n\tspin_lock_irqsave(&vpmem->pmem_lock, flags);\n\twhile ((req_data = virtqueue_get_buf(vq, &len)) != NULL) {\n\t\treq_data->done = true;\n\t\twake_up(&req_data->host_acked);\n\n\t\tif (!list_empty(&vpmem->req_list)) {\n\t\t\treq_buf = list_first_entry(&vpmem->req_list,\n\t\t\t\t\tstruct virtio_pmem_request, list);\n\t\t\treq_buf->wq_buf_avail = true;\n\t\t\twake_up(&req_buf->wq_buf);\n\t\t\tlist_del(&req_buf->list);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&vpmem->pmem_lock, flags);\n}\nEXPORT_SYMBOL_GPL(virtio_pmem_host_ack);\n\n  \nstatic int virtio_pmem_flush(struct nd_region *nd_region)\n{\n\tstruct virtio_device *vdev = nd_region->provider_data;\n\tstruct virtio_pmem *vpmem  = vdev->priv;\n\tstruct virtio_pmem_request *req_data;\n\tstruct scatterlist *sgs[2], sg, ret;\n\tunsigned long flags;\n\tint err, err1;\n\n\tmight_sleep();\n\treq_data = kmalloc(sizeof(*req_data), GFP_KERNEL);\n\tif (!req_data)\n\t\treturn -ENOMEM;\n\n\treq_data->done = false;\n\tinit_waitqueue_head(&req_data->host_acked);\n\tinit_waitqueue_head(&req_data->wq_buf);\n\tINIT_LIST_HEAD(&req_data->list);\n\treq_data->req.type = cpu_to_le32(VIRTIO_PMEM_REQ_TYPE_FLUSH);\n\tsg_init_one(&sg, &req_data->req, sizeof(req_data->req));\n\tsgs[0] = &sg;\n\tsg_init_one(&ret, &req_data->resp.ret, sizeof(req_data->resp));\n\tsgs[1] = &ret;\n\n\tspin_lock_irqsave(&vpmem->pmem_lock, flags);\n\t  \n\twhile ((err = virtqueue_add_sgs(vpmem->req_vq, sgs, 1, 1, req_data,\n\t\t\t\t\tGFP_ATOMIC)) == -ENOSPC) {\n\n\t\tdev_info(&vdev->dev, \"failed to send command to virtio pmem device, no free slots in the virtqueue\\n\");\n\t\treq_data->wq_buf_avail = false;\n\t\tlist_add_tail(&req_data->list, &vpmem->req_list);\n\t\tspin_unlock_irqrestore(&vpmem->pmem_lock, flags);\n\n\t\t \n\t\twait_event(req_data->wq_buf, req_data->wq_buf_avail);\n\t\tspin_lock_irqsave(&vpmem->pmem_lock, flags);\n\t}\n\terr1 = virtqueue_kick(vpmem->req_vq);\n\tspin_unlock_irqrestore(&vpmem->pmem_lock, flags);\n\t \n\tif (err || !err1) {\n\t\tdev_info(&vdev->dev, \"failed to send command to virtio pmem device\\n\");\n\t\terr = -EIO;\n\t} else {\n\t\t \n\t\twait_event(req_data->host_acked, req_data->done);\n\t\terr = le32_to_cpu(req_data->resp.ret);\n\t}\n\n\tkfree(req_data);\n\treturn err;\n};\n\n \nint async_pmem_flush(struct nd_region *nd_region, struct bio *bio)\n{\n\t \n\tif (bio && bio->bi_iter.bi_sector != -1) {\n\t\tstruct bio *child = bio_alloc(bio->bi_bdev, 0,\n\t\t\t\t\t      REQ_OP_WRITE | REQ_PREFLUSH,\n\t\t\t\t\t      GFP_ATOMIC);\n\n\t\tif (!child)\n\t\t\treturn -ENOMEM;\n\t\tbio_clone_blkg_association(child, bio);\n\t\tchild->bi_iter.bi_sector = -1;\n\t\tbio_chain(child, bio);\n\t\tsubmit_bio(child);\n\t\treturn 0;\n\t}\n\tif (virtio_pmem_flush(nd_region))\n\t\treturn -EIO;\n\n\treturn 0;\n};\nEXPORT_SYMBOL_GPL(async_pmem_flush);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}