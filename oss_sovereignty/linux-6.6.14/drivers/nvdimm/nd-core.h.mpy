{
  "module_name": "nd-core.h",
  "hash_id": "91ee446bdd686bb2df3fa2e542b136789250e6bee7fc4b1274aa0626d0cdb3e4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/nvdimm/nd-core.h",
  "human_readable_source": " \n \n#ifndef __ND_CORE_H__\n#define __ND_CORE_H__\n#include <linux/libnvdimm.h>\n#include <linux/device.h>\n#include <linux/sizes.h>\n#include <linux/mutex.h>\n#include <linux/nd.h>\n#include \"nd.h\"\n\nextern struct list_head nvdimm_bus_list;\nextern struct mutex nvdimm_bus_list_mutex;\nextern int nvdimm_major;\nextern struct workqueue_struct *nvdimm_wq;\n\nstruct nvdimm_bus {\n\tstruct nvdimm_bus_descriptor *nd_desc;\n\twait_queue_head_t wait;\n\tstruct list_head list;\n\tstruct device dev;\n\tint id, probe_active;\n\tatomic_t ioctl_active;\n\tstruct list_head mapping_list;\n\tstruct mutex reconfig_mutex;\n\tstruct badrange badrange;\n};\n\nstruct nvdimm {\n\tunsigned long flags;\n\tvoid *provider_data;\n\tunsigned long cmd_mask;\n\tstruct device dev;\n\tatomic_t busy;\n\tint id, num_flush;\n\tstruct resource *flush_wpq;\n\tconst char *dimm_id;\n\tstruct {\n\t\tconst struct nvdimm_security_ops *ops;\n\t\tunsigned long flags;\n\t\tunsigned long ext_flags;\n\t\tunsigned int overwrite_tmo;\n\t\tstruct kernfs_node *overwrite_state;\n\t} sec;\n\tstruct delayed_work dwork;\n\tconst struct nvdimm_fw_ops *fw_ops;\n};\n\nstatic inline unsigned long nvdimm_security_flags(\n\t\tstruct nvdimm *nvdimm, enum nvdimm_passphrase_type ptype)\n{\n\tu64 flags;\n\tconst u64 state_flags = 1UL << NVDIMM_SECURITY_DISABLED\n\t\t| 1UL << NVDIMM_SECURITY_LOCKED\n\t\t| 1UL << NVDIMM_SECURITY_UNLOCKED\n\t\t| 1UL << NVDIMM_SECURITY_OVERWRITE;\n\n\tif (!nvdimm->sec.ops)\n\t\treturn 0;\n\n\tflags = nvdimm->sec.ops->get_flags(nvdimm, ptype);\n\t \n\tdev_WARN_ONCE(&nvdimm->dev, hweight64(flags & state_flags) > 1,\n\t\t\t\"reported invalid security state: %#llx\\n\",\n\t\t\t(unsigned long long) flags);\n\treturn flags;\n}\nint nvdimm_security_freeze(struct nvdimm *nvdimm);\n#if IS_ENABLED(CONFIG_NVDIMM_KEYS)\nssize_t nvdimm_security_store(struct device *dev, const char *buf, size_t len);\nvoid nvdimm_security_overwrite_query(struct work_struct *work);\n#else\nstatic inline ssize_t nvdimm_security_store(struct device *dev,\n\t\tconst char *buf, size_t len)\n{\n\treturn -EOPNOTSUPP;\n}\nstatic inline void nvdimm_security_overwrite_query(struct work_struct *work)\n{\n}\n#endif\n\nbool is_nvdimm(const struct device *dev);\nbool is_nd_pmem(const struct device *dev);\nbool is_nd_volatile(const struct device *dev);\nstatic inline bool is_nd_region(const struct device *dev)\n{\n\treturn is_nd_pmem(dev) || is_nd_volatile(dev);\n}\nstatic inline bool is_memory(const struct device *dev)\n{\n\treturn is_nd_pmem(dev) || is_nd_volatile(dev);\n}\nstruct nvdimm_bus *walk_to_nvdimm_bus(struct device *nd_dev);\nint __init nvdimm_bus_init(void);\nvoid nvdimm_bus_exit(void);\nvoid nvdimm_devs_exit(void);\nstruct nd_region;\nvoid nd_region_advance_seeds(struct nd_region *nd_region, struct device *dev);\nvoid nd_region_create_ns_seed(struct nd_region *nd_region);\nvoid nd_region_create_btt_seed(struct nd_region *nd_region);\nvoid nd_region_create_pfn_seed(struct nd_region *nd_region);\nvoid nd_region_create_dax_seed(struct nd_region *nd_region);\nint nvdimm_bus_create_ndctl(struct nvdimm_bus *nvdimm_bus);\nvoid nvdimm_bus_destroy_ndctl(struct nvdimm_bus *nvdimm_bus);\nvoid nd_synchronize(void);\nvoid nd_device_register(struct device *dev);\nvoid nd_device_register_sync(struct device *dev);\nstruct nd_label_id;\nchar *nd_label_gen_id(struct nd_label_id *label_id, const uuid_t *uuid,\n\t\t      u32 flags);\nbool nd_is_uuid_unique(struct device *dev, uuid_t *uuid);\nstruct nd_region;\nstruct nvdimm_drvdata;\nstruct nd_mapping;\nvoid nd_mapping_free_labels(struct nd_mapping *nd_mapping);\n\nint __reserve_free_pmem(struct device *dev, void *data);\nvoid release_free_pmem(struct nvdimm_bus *nvdimm_bus,\n\t\t       struct nd_mapping *nd_mapping);\n\nresource_size_t nd_pmem_max_contiguous_dpa(struct nd_region *nd_region,\n\t\t\t\t\t   struct nd_mapping *nd_mapping);\nresource_size_t nd_region_allocatable_dpa(struct nd_region *nd_region);\nresource_size_t nd_pmem_available_dpa(struct nd_region *nd_region,\n\t\t\t\t      struct nd_mapping *nd_mapping);\nresource_size_t nd_region_available_dpa(struct nd_region *nd_region);\nint nd_region_conflict(struct nd_region *nd_region, resource_size_t start,\n\t\tresource_size_t size);\nresource_size_t nvdimm_allocated_dpa(struct nvdimm_drvdata *ndd,\n\t\tstruct nd_label_id *label_id);\nint nvdimm_num_label_slots(struct nvdimm_drvdata *ndd);\nvoid get_ndd(struct nvdimm_drvdata *ndd);\nresource_size_t __nvdimm_namespace_capacity(struct nd_namespace_common *ndns);\nvoid nd_detach_ndns(struct device *dev, struct nd_namespace_common **_ndns);\nvoid __nd_detach_ndns(struct device *dev, struct nd_namespace_common **_ndns);\nbool nd_attach_ndns(struct device *dev, struct nd_namespace_common *attach,\n\t\tstruct nd_namespace_common **_ndns);\nbool __nd_attach_ndns(struct device *dev, struct nd_namespace_common *attach,\n\t\tstruct nd_namespace_common **_ndns);\nssize_t nd_namespace_store(struct device *dev,\n\t\tstruct nd_namespace_common **_ndns, const char *buf,\n\t\tsize_t len);\nstruct nd_pfn *to_nd_pfn_safe(struct device *dev);\nbool is_nvdimm_bus(struct device *dev);\n\n#if IS_ENABLED(CONFIG_ND_CLAIM)\nint devm_nsio_enable(struct device *dev, struct nd_namespace_io *nsio,\n\t\tresource_size_t size);\nvoid devm_nsio_disable(struct device *dev, struct nd_namespace_io *nsio);\n#else\nstatic inline int devm_nsio_enable(struct device *dev,\n\t\tstruct nd_namespace_io *nsio, resource_size_t size)\n{\n\treturn -ENXIO;\n}\n\nstatic inline void devm_nsio_disable(struct device *dev,\n\t\tstruct nd_namespace_io *nsio)\n{\n}\n#endif\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}