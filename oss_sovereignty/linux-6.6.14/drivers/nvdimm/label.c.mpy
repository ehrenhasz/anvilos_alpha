{
  "module_name": "label.c",
  "hash_id": "4b5875e94c4f5310a419c68a7973c319d8e6ce67e4f8b8e2b5b1e19425b60a9b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/nvdimm/label.c",
  "human_readable_source": "\n \n#include <linux/device.h>\n#include <linux/ndctl.h>\n#include <linux/uuid.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/nd.h>\n#include \"nd-core.h\"\n#include \"label.h\"\n#include \"nd.h\"\n\nstatic guid_t nvdimm_btt_guid;\nstatic guid_t nvdimm_btt2_guid;\nstatic guid_t nvdimm_pfn_guid;\nstatic guid_t nvdimm_dax_guid;\n\nstatic uuid_t nvdimm_btt_uuid;\nstatic uuid_t nvdimm_btt2_uuid;\nstatic uuid_t nvdimm_pfn_uuid;\nstatic uuid_t nvdimm_dax_uuid;\n\nstatic uuid_t cxl_region_uuid;\nstatic uuid_t cxl_namespace_uuid;\n\nstatic const char NSINDEX_SIGNATURE[] = \"NAMESPACE_INDEX\\0\";\n\nstatic u32 best_seq(u32 a, u32 b)\n{\n\ta &= NSINDEX_SEQ_MASK;\n\tb &= NSINDEX_SEQ_MASK;\n\n\tif (a == 0 || a == b)\n\t\treturn b;\n\telse if (b == 0)\n\t\treturn a;\n\telse if (nd_inc_seq(a) == b)\n\t\treturn b;\n\telse\n\t\treturn a;\n}\n\nunsigned sizeof_namespace_label(struct nvdimm_drvdata *ndd)\n{\n\treturn ndd->nslabel_size;\n}\n\nstatic size_t __sizeof_namespace_index(u32 nslot)\n{\n\treturn ALIGN(sizeof(struct nd_namespace_index) + DIV_ROUND_UP(nslot, 8),\n\t\t\tNSINDEX_ALIGN);\n}\n\nstatic int __nvdimm_num_label_slots(struct nvdimm_drvdata *ndd,\n\t\tsize_t index_size)\n{\n\treturn (ndd->nsarea.config_size - index_size * 2) /\n\t\t\tsizeof_namespace_label(ndd);\n}\n\nint nvdimm_num_label_slots(struct nvdimm_drvdata *ndd)\n{\n\tu32 tmp_nslot, n;\n\n\ttmp_nslot = ndd->nsarea.config_size / sizeof_namespace_label(ndd);\n\tn = __sizeof_namespace_index(tmp_nslot) / NSINDEX_ALIGN;\n\n\treturn __nvdimm_num_label_slots(ndd, NSINDEX_ALIGN * n);\n}\n\nsize_t sizeof_namespace_index(struct nvdimm_drvdata *ndd)\n{\n\tu32 nslot, space, size;\n\n\t \n\tnslot = nvdimm_num_label_slots(ndd);\n\tspace = ndd->nsarea.config_size - nslot * sizeof_namespace_label(ndd);\n\tsize = __sizeof_namespace_index(nslot) * 2;\n\tif (size <= space && nslot >= 2)\n\t\treturn size / 2;\n\n\tdev_err(ndd->dev, \"label area (%d) too small to host (%d byte) labels\\n\",\n\t\t\tndd->nsarea.config_size, sizeof_namespace_label(ndd));\n\treturn 0;\n}\n\nstatic int __nd_label_validate(struct nvdimm_drvdata *ndd)\n{\n\t \n\tstruct nd_namespace_index *nsindex[] = {\n\t\tto_namespace_index(ndd, 0),\n\t\tto_namespace_index(ndd, 1),\n\t};\n\tconst int num_index = ARRAY_SIZE(nsindex);\n\tstruct device *dev = ndd->dev;\n\tbool valid[2] = { 0 };\n\tint i, num_valid = 0;\n\tu32 seq;\n\n\tfor (i = 0; i < num_index; i++) {\n\t\tu32 nslot;\n\t\tu8 sig[NSINDEX_SIG_LEN];\n\t\tu64 sum_save, sum, size;\n\t\tunsigned int version, labelsize;\n\n\t\tmemcpy(sig, nsindex[i]->sig, NSINDEX_SIG_LEN);\n\t\tif (memcmp(sig, NSINDEX_SIGNATURE, NSINDEX_SIG_LEN) != 0) {\n\t\t\tdev_dbg(dev, \"nsindex%d signature invalid\\n\", i);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tversion = __le16_to_cpu(nsindex[i]->major) * 100\n\t\t\t+ __le16_to_cpu(nsindex[i]->minor);\n\t\tif (version >= 102)\n\t\t\tlabelsize = 1 << (7 + nsindex[i]->labelsize);\n\t\telse\n\t\t\tlabelsize = 128;\n\n\t\tif (labelsize != sizeof_namespace_label(ndd)) {\n\t\t\tdev_dbg(dev, \"nsindex%d labelsize %d invalid\\n\",\n\t\t\t\t\ti, nsindex[i]->labelsize);\n\t\t\tcontinue;\n\t\t}\n\n\t\tsum_save = __le64_to_cpu(nsindex[i]->checksum);\n\t\tnsindex[i]->checksum = __cpu_to_le64(0);\n\t\tsum = nd_fletcher64(nsindex[i], sizeof_namespace_index(ndd), 1);\n\t\tnsindex[i]->checksum = __cpu_to_le64(sum_save);\n\t\tif (sum != sum_save) {\n\t\t\tdev_dbg(dev, \"nsindex%d checksum invalid\\n\", i);\n\t\t\tcontinue;\n\t\t}\n\n\t\tseq = __le32_to_cpu(nsindex[i]->seq);\n\t\tif ((seq & NSINDEX_SEQ_MASK) == 0) {\n\t\t\tdev_dbg(dev, \"nsindex%d sequence: %#x invalid\\n\", i, seq);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (__le64_to_cpu(nsindex[i]->myoff)\n\t\t\t\t!= i * sizeof_namespace_index(ndd)) {\n\t\t\tdev_dbg(dev, \"nsindex%d myoff: %#llx invalid\\n\",\n\t\t\t\t\ti, (unsigned long long)\n\t\t\t\t\t__le64_to_cpu(nsindex[i]->myoff));\n\t\t\tcontinue;\n\t\t}\n\t\tif (__le64_to_cpu(nsindex[i]->otheroff)\n\t\t\t\t!= (!i) * sizeof_namespace_index(ndd)) {\n\t\t\tdev_dbg(dev, \"nsindex%d otheroff: %#llx invalid\\n\",\n\t\t\t\t\ti, (unsigned long long)\n\t\t\t\t\t__le64_to_cpu(nsindex[i]->otheroff));\n\t\t\tcontinue;\n\t\t}\n\t\tif (__le64_to_cpu(nsindex[i]->labeloff)\n\t\t\t\t!= 2 * sizeof_namespace_index(ndd)) {\n\t\t\tdev_dbg(dev, \"nsindex%d labeloff: %#llx invalid\\n\",\n\t\t\t\t\ti, (unsigned long long)\n\t\t\t\t\t__le64_to_cpu(nsindex[i]->labeloff));\n\t\t\tcontinue;\n\t\t}\n\n\t\tsize = __le64_to_cpu(nsindex[i]->mysize);\n\t\tif (size > sizeof_namespace_index(ndd)\n\t\t\t\t|| size < sizeof(struct nd_namespace_index)) {\n\t\t\tdev_dbg(dev, \"nsindex%d mysize: %#llx invalid\\n\", i, size);\n\t\t\tcontinue;\n\t\t}\n\n\t\tnslot = __le32_to_cpu(nsindex[i]->nslot);\n\t\tif (nslot * sizeof_namespace_label(ndd)\n\t\t\t\t+ 2 * sizeof_namespace_index(ndd)\n\t\t\t\t> ndd->nsarea.config_size) {\n\t\t\tdev_dbg(dev, \"nsindex%d nslot: %u invalid, config_size: %#x\\n\",\n\t\t\t\t\ti, nslot, ndd->nsarea.config_size);\n\t\t\tcontinue;\n\t\t}\n\t\tvalid[i] = true;\n\t\tnum_valid++;\n\t}\n\n\tswitch (num_valid) {\n\tcase 0:\n\t\tbreak;\n\tcase 1:\n\t\tfor (i = 0; i < num_index; i++)\n\t\t\tif (valid[i])\n\t\t\t\treturn i;\n\t\t \n\t\tWARN_ON(1);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tseq = best_seq(__le32_to_cpu(nsindex[0]->seq),\n\t\t\t\t__le32_to_cpu(nsindex[1]->seq));\n\t\tif (seq == (__le32_to_cpu(nsindex[1]->seq) & NSINDEX_SEQ_MASK))\n\t\t\treturn 1;\n\t\telse\n\t\t\treturn 0;\n\t\tbreak;\n\t}\n\n\treturn -1;\n}\n\nstatic int nd_label_validate(struct nvdimm_drvdata *ndd)\n{\n\t \n\tint label_size[] = { 128, 256 };\n\tint i, rc;\n\n\tfor (i = 0; i < ARRAY_SIZE(label_size); i++) {\n\t\tndd->nslabel_size = label_size[i];\n\t\trc = __nd_label_validate(ndd);\n\t\tif (rc >= 0)\n\t\t\treturn rc;\n\t}\n\n\treturn -1;\n}\n\nstatic void nd_label_copy(struct nvdimm_drvdata *ndd,\n\t\t\t  struct nd_namespace_index *dst,\n\t\t\t  struct nd_namespace_index *src)\n{\n\t \n\tif (!dst || !src)\n\t\treturn;\n\n\tmemcpy(dst, src, sizeof_namespace_index(ndd));\n}\n\nstatic struct nd_namespace_label *nd_label_base(struct nvdimm_drvdata *ndd)\n{\n\tvoid *base = to_namespace_index(ndd, 0);\n\n\treturn base + 2 * sizeof_namespace_index(ndd);\n}\n\nstatic int to_slot(struct nvdimm_drvdata *ndd,\n\t\tstruct nd_namespace_label *nd_label)\n{\n\tunsigned long label, base;\n\n\tlabel = (unsigned long) nd_label;\n\tbase = (unsigned long) nd_label_base(ndd);\n\n\treturn (label - base) / sizeof_namespace_label(ndd);\n}\n\nstatic struct nd_namespace_label *to_label(struct nvdimm_drvdata *ndd, int slot)\n{\n\tunsigned long label, base;\n\n\tbase = (unsigned long) nd_label_base(ndd);\n\tlabel = base + sizeof_namespace_label(ndd) * slot;\n\n\treturn (struct nd_namespace_label *) label;\n}\n\n#define for_each_clear_bit_le(bit, addr, size) \\\n\tfor ((bit) = find_next_zero_bit_le((addr), (size), 0);  \\\n\t     (bit) < (size);                                    \\\n\t     (bit) = find_next_zero_bit_le((addr), (size), (bit) + 1))\n\n \nstatic bool preamble_index(struct nvdimm_drvdata *ndd, int idx,\n\t\tstruct nd_namespace_index **nsindex_out,\n\t\tunsigned long **free, u32 *nslot)\n{\n\tstruct nd_namespace_index *nsindex;\n\n\tnsindex = to_namespace_index(ndd, idx);\n\tif (nsindex == NULL)\n\t\treturn false;\n\n\t*free = (unsigned long *) nsindex->free;\n\t*nslot = __le32_to_cpu(nsindex->nslot);\n\t*nsindex_out = nsindex;\n\n\treturn true;\n}\n\nchar *nd_label_gen_id(struct nd_label_id *label_id, const uuid_t *uuid,\n\t\t      u32 flags)\n{\n\tif (!label_id || !uuid)\n\t\treturn NULL;\n\tsnprintf(label_id->id, ND_LABEL_ID_SIZE, \"pmem-%pUb\", uuid);\n\treturn label_id->id;\n}\n\nstatic bool preamble_current(struct nvdimm_drvdata *ndd,\n\t\tstruct nd_namespace_index **nsindex,\n\t\tunsigned long **free, u32 *nslot)\n{\n\treturn preamble_index(ndd, ndd->ns_current, nsindex,\n\t\t\tfree, nslot);\n}\n\nstatic bool preamble_next(struct nvdimm_drvdata *ndd,\n\t\tstruct nd_namespace_index **nsindex,\n\t\tunsigned long **free, u32 *nslot)\n{\n\treturn preamble_index(ndd, ndd->ns_next, nsindex,\n\t\t\tfree, nslot);\n}\n\nstatic bool nsl_validate_checksum(struct nvdimm_drvdata *ndd,\n\t\t\t\t  struct nd_namespace_label *nd_label)\n{\n\tu64 sum, sum_save;\n\n\tif (!ndd->cxl && !efi_namespace_label_has(ndd, checksum))\n\t\treturn true;\n\n\tsum_save = nsl_get_checksum(ndd, nd_label);\n\tnsl_set_checksum(ndd, nd_label, 0);\n\tsum = nd_fletcher64(nd_label, sizeof_namespace_label(ndd), 1);\n\tnsl_set_checksum(ndd, nd_label, sum_save);\n\treturn sum == sum_save;\n}\n\nstatic void nsl_calculate_checksum(struct nvdimm_drvdata *ndd,\n\t\t\t\t   struct nd_namespace_label *nd_label)\n{\n\tu64 sum;\n\n\tif (!ndd->cxl && !efi_namespace_label_has(ndd, checksum))\n\t\treturn;\n\tnsl_set_checksum(ndd, nd_label, 0);\n\tsum = nd_fletcher64(nd_label, sizeof_namespace_label(ndd), 1);\n\tnsl_set_checksum(ndd, nd_label, sum);\n}\n\nstatic bool slot_valid(struct nvdimm_drvdata *ndd,\n\t\tstruct nd_namespace_label *nd_label, u32 slot)\n{\n\tbool valid;\n\n\t \n\tif (slot != nsl_get_slot(ndd, nd_label))\n\t\treturn false;\n\tvalid = nsl_validate_checksum(ndd, nd_label);\n\tif (!valid)\n\t\tdev_dbg(ndd->dev, \"fail checksum. slot: %d\\n\", slot);\n\treturn valid;\n}\n\nint nd_label_reserve_dpa(struct nvdimm_drvdata *ndd)\n{\n\tstruct nd_namespace_index *nsindex;\n\tunsigned long *free;\n\tu32 nslot, slot;\n\n\tif (!preamble_current(ndd, &nsindex, &free, &nslot))\n\t\treturn 0;  \n\n\tfor_each_clear_bit_le(slot, free, nslot) {\n\t\tstruct nd_namespace_label *nd_label;\n\t\tstruct nd_region *nd_region = NULL;\n\t\tstruct nd_label_id label_id;\n\t\tstruct resource *res;\n\t\tuuid_t label_uuid;\n\t\tu32 flags;\n\n\t\tnd_label = to_label(ndd, slot);\n\n\t\tif (!slot_valid(ndd, nd_label, slot))\n\t\t\tcontinue;\n\n\t\tnsl_get_uuid(ndd, nd_label, &label_uuid);\n\t\tflags = nsl_get_flags(ndd, nd_label);\n\t\tnd_label_gen_id(&label_id, &label_uuid, flags);\n\t\tres = nvdimm_allocate_dpa(ndd, &label_id,\n\t\t\t\t\t  nsl_get_dpa(ndd, nd_label),\n\t\t\t\t\t  nsl_get_rawsize(ndd, nd_label));\n\t\tnd_dbg_dpa(nd_region, ndd, res, \"reserve\\n\");\n\t\tif (!res)\n\t\t\treturn -EBUSY;\n\t}\n\n\treturn 0;\n}\n\nint nd_label_data_init(struct nvdimm_drvdata *ndd)\n{\n\tsize_t config_size, read_size, max_xfer, offset;\n\tstruct nd_namespace_index *nsindex;\n\tunsigned int i;\n\tint rc = 0;\n\tu32 nslot;\n\n\tif (ndd->data)\n\t\treturn 0;\n\n\tif (ndd->nsarea.status || ndd->nsarea.max_xfer == 0) {\n\t\tdev_dbg(ndd->dev, \"failed to init config data area: (%u:%u)\\n\",\n\t\t\tndd->nsarea.max_xfer, ndd->nsarea.config_size);\n\t\treturn -ENXIO;\n\t}\n\n\t \n\tndd->nslabel_size = 128;\n\tread_size = sizeof_namespace_index(ndd) * 2;\n\tif (!read_size)\n\t\treturn -ENXIO;\n\n\t \n\tconfig_size = ndd->nsarea.config_size;\n\tndd->data = kvzalloc(config_size, GFP_KERNEL);\n\tif (!ndd->data)\n\t\treturn -ENOMEM;\n\n\t \n\tmax_xfer = min_t(size_t, ndd->nsarea.max_xfer, config_size);\n\tif (read_size < max_xfer) {\n\t\t \n\t\tmax_xfer -= ((max_xfer - 1) - (config_size - 1) % max_xfer) /\n\t\t\t    DIV_ROUND_UP(config_size, max_xfer);\n\t\t \n\t\tif (max_xfer < read_size)\n\t\t\tmax_xfer = read_size;\n\t}\n\n\t \n\tread_size = min(DIV_ROUND_UP(read_size, max_xfer) * max_xfer,\n\t\t\tconfig_size);\n\n\t \n\trc = nvdimm_get_config_data(ndd, ndd->data, 0, read_size);\n\tif (rc)\n\t\tgoto out_err;\n\n\t \n\tndd->ns_current = nd_label_validate(ndd);\n\tif (ndd->ns_current < 0)\n\t\treturn 0;\n\n\t \n\tndd->ns_next = nd_label_next_nsindex(ndd->ns_current);\n\n\t \n\tnsindex = to_current_namespace_index(ndd);\n\tnd_label_copy(ndd, to_next_namespace_index(ndd), nsindex);\n\n\t \n\toffset = __le64_to_cpu(nsindex->labeloff);\n\tnslot = __le32_to_cpu(nsindex->nslot);\n\n\t \n\tfor (i = 0; i < nslot; i++, offset += ndd->nslabel_size) {\n\t\tsize_t label_read_size;\n\n\t\t \n\t\tif (test_bit_le(i, nsindex->free)) {\n\t\t\tmemset(ndd->data + offset, 0, ndd->nslabel_size);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (offset + ndd->nslabel_size <= read_size)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (read_size < offset)\n\t\t\tread_size = offset;\n\n\t\t \n\t\tlabel_read_size = offset + ndd->nslabel_size - read_size;\n\t\tlabel_read_size = DIV_ROUND_UP(label_read_size, max_xfer) *\n\t\t\t\t  max_xfer;\n\n\t\t \n\t\tif (read_size + label_read_size > config_size)\n\t\t\tlabel_read_size = config_size - read_size;\n\n\t\t \n\t\trc = nvdimm_get_config_data(ndd, ndd->data + read_size,\n\t\t\t\t\t    read_size, label_read_size);\n\t\tif (rc)\n\t\t\tgoto out_err;\n\n\t\t \n\t\tread_size += label_read_size;\n\t}\n\n\tdev_dbg(ndd->dev, \"len: %zu rc: %d\\n\", offset, rc);\nout_err:\n\treturn rc;\n}\n\nint nd_label_active_count(struct nvdimm_drvdata *ndd)\n{\n\tstruct nd_namespace_index *nsindex;\n\tunsigned long *free;\n\tu32 nslot, slot;\n\tint count = 0;\n\n\tif (!preamble_current(ndd, &nsindex, &free, &nslot))\n\t\treturn 0;\n\n\tfor_each_clear_bit_le(slot, free, nslot) {\n\t\tstruct nd_namespace_label *nd_label;\n\n\t\tnd_label = to_label(ndd, slot);\n\n\t\tif (!slot_valid(ndd, nd_label, slot)) {\n\t\t\tu32 label_slot = nsl_get_slot(ndd, nd_label);\n\t\t\tu64 size = nsl_get_rawsize(ndd, nd_label);\n\t\t\tu64 dpa = nsl_get_dpa(ndd, nd_label);\n\n\t\t\tdev_dbg(ndd->dev,\n\t\t\t\t\"slot%d invalid slot: %d dpa: %llx size: %llx\\n\",\n\t\t\t\t\tslot, label_slot, dpa, size);\n\t\t\tcontinue;\n\t\t}\n\t\tcount++;\n\t}\n\treturn count;\n}\n\nstruct nd_namespace_label *nd_label_active(struct nvdimm_drvdata *ndd, int n)\n{\n\tstruct nd_namespace_index *nsindex;\n\tunsigned long *free;\n\tu32 nslot, slot;\n\n\tif (!preamble_current(ndd, &nsindex, &free, &nslot))\n\t\treturn NULL;\n\n\tfor_each_clear_bit_le(slot, free, nslot) {\n\t\tstruct nd_namespace_label *nd_label;\n\n\t\tnd_label = to_label(ndd, slot);\n\t\tif (!slot_valid(ndd, nd_label, slot))\n\t\t\tcontinue;\n\n\t\tif (n-- == 0)\n\t\t\treturn to_label(ndd, slot);\n\t}\n\n\treturn NULL;\n}\n\nu32 nd_label_alloc_slot(struct nvdimm_drvdata *ndd)\n{\n\tstruct nd_namespace_index *nsindex;\n\tunsigned long *free;\n\tu32 nslot, slot;\n\n\tif (!preamble_next(ndd, &nsindex, &free, &nslot))\n\t\treturn UINT_MAX;\n\n\tWARN_ON(!is_nvdimm_bus_locked(ndd->dev));\n\n\tslot = find_next_bit_le(free, nslot, 0);\n\tif (slot == nslot)\n\t\treturn UINT_MAX;\n\n\tclear_bit_le(slot, free);\n\n\treturn slot;\n}\n\nbool nd_label_free_slot(struct nvdimm_drvdata *ndd, u32 slot)\n{\n\tstruct nd_namespace_index *nsindex;\n\tunsigned long *free;\n\tu32 nslot;\n\n\tif (!preamble_next(ndd, &nsindex, &free, &nslot))\n\t\treturn false;\n\n\tWARN_ON(!is_nvdimm_bus_locked(ndd->dev));\n\n\tif (slot < nslot)\n\t\treturn !test_and_set_bit_le(slot, free);\n\treturn false;\n}\n\nu32 nd_label_nfree(struct nvdimm_drvdata *ndd)\n{\n\tstruct nd_namespace_index *nsindex;\n\tunsigned long *free;\n\tu32 nslot;\n\n\tWARN_ON(!is_nvdimm_bus_locked(ndd->dev));\n\n\tif (!preamble_next(ndd, &nsindex, &free, &nslot))\n\t\treturn nvdimm_num_label_slots(ndd);\n\n\treturn bitmap_weight(free, nslot);\n}\n\nstatic int nd_label_write_index(struct nvdimm_drvdata *ndd, int index, u32 seq,\n\t\tunsigned long flags)\n{\n\tstruct nd_namespace_index *nsindex;\n\tunsigned long offset;\n\tu64 checksum;\n\tu32 nslot;\n\tint rc;\n\n\tnsindex = to_namespace_index(ndd, index);\n\tif (flags & ND_NSINDEX_INIT)\n\t\tnslot = nvdimm_num_label_slots(ndd);\n\telse\n\t\tnslot = __le32_to_cpu(nsindex->nslot);\n\n\tmemcpy(nsindex->sig, NSINDEX_SIGNATURE, NSINDEX_SIG_LEN);\n\tmemset(&nsindex->flags, 0, 3);\n\tnsindex->labelsize = sizeof_namespace_label(ndd) >> 8;\n\tnsindex->seq = __cpu_to_le32(seq);\n\toffset = (unsigned long) nsindex\n\t\t- (unsigned long) to_namespace_index(ndd, 0);\n\tnsindex->myoff = __cpu_to_le64(offset);\n\tnsindex->mysize = __cpu_to_le64(sizeof_namespace_index(ndd));\n\toffset = (unsigned long) to_namespace_index(ndd,\n\t\t\tnd_label_next_nsindex(index))\n\t\t- (unsigned long) to_namespace_index(ndd, 0);\n\tnsindex->otheroff = __cpu_to_le64(offset);\n\toffset = (unsigned long) nd_label_base(ndd)\n\t\t- (unsigned long) to_namespace_index(ndd, 0);\n\tnsindex->labeloff = __cpu_to_le64(offset);\n\tnsindex->nslot = __cpu_to_le32(nslot);\n\tnsindex->major = __cpu_to_le16(1);\n\tif (sizeof_namespace_label(ndd) < 256)\n\t\tnsindex->minor = __cpu_to_le16(1);\n\telse\n\t\tnsindex->minor = __cpu_to_le16(2);\n\tnsindex->checksum = __cpu_to_le64(0);\n\tif (flags & ND_NSINDEX_INIT) {\n\t\tunsigned long *free = (unsigned long *) nsindex->free;\n\t\tu32 nfree = ALIGN(nslot, BITS_PER_LONG);\n\t\tint last_bits, i;\n\n\t\tmemset(nsindex->free, 0xff, nfree / 8);\n\t\tfor (i = 0, last_bits = nfree - nslot; i < last_bits; i++)\n\t\t\tclear_bit_le(nslot + i, free);\n\t}\n\tchecksum = nd_fletcher64(nsindex, sizeof_namespace_index(ndd), 1);\n\tnsindex->checksum = __cpu_to_le64(checksum);\n\trc = nvdimm_set_config_data(ndd, __le64_to_cpu(nsindex->myoff),\n\t\t\tnsindex, sizeof_namespace_index(ndd));\n\tif (rc < 0)\n\t\treturn rc;\n\n\tif (flags & ND_NSINDEX_INIT)\n\t\treturn 0;\n\n\t \n\tWARN_ON(index != ndd->ns_next);\n\tnd_label_copy(ndd, to_current_namespace_index(ndd), nsindex);\n\tndd->ns_current = nd_label_next_nsindex(ndd->ns_current);\n\tndd->ns_next = nd_label_next_nsindex(ndd->ns_next);\n\tWARN_ON(ndd->ns_current == ndd->ns_next);\n\n\treturn 0;\n}\n\nstatic unsigned long nd_label_offset(struct nvdimm_drvdata *ndd,\n\t\tstruct nd_namespace_label *nd_label)\n{\n\treturn (unsigned long) nd_label\n\t\t- (unsigned long) to_namespace_index(ndd, 0);\n}\n\nstatic enum nvdimm_claim_class guid_to_nvdimm_cclass(guid_t *guid)\n{\n\tif (guid_equal(guid, &nvdimm_btt_guid))\n\t\treturn NVDIMM_CCLASS_BTT;\n\telse if (guid_equal(guid, &nvdimm_btt2_guid))\n\t\treturn NVDIMM_CCLASS_BTT2;\n\telse if (guid_equal(guid, &nvdimm_pfn_guid))\n\t\treturn NVDIMM_CCLASS_PFN;\n\telse if (guid_equal(guid, &nvdimm_dax_guid))\n\t\treturn NVDIMM_CCLASS_DAX;\n\telse if (guid_equal(guid, &guid_null))\n\t\treturn NVDIMM_CCLASS_NONE;\n\n\treturn NVDIMM_CCLASS_UNKNOWN;\n}\n\n \nstatic enum nvdimm_claim_class uuid_to_nvdimm_cclass(uuid_t *uuid)\n{\n\tif (uuid_equal(uuid, &nvdimm_btt_uuid))\n\t\treturn NVDIMM_CCLASS_BTT;\n\telse if (uuid_equal(uuid, &nvdimm_btt2_uuid))\n\t\treturn NVDIMM_CCLASS_BTT2;\n\telse if (uuid_equal(uuid, &nvdimm_pfn_uuid))\n\t\treturn NVDIMM_CCLASS_PFN;\n\telse if (uuid_equal(uuid, &nvdimm_dax_uuid))\n\t\treturn NVDIMM_CCLASS_DAX;\n\telse if (uuid_equal(uuid, &uuid_null))\n\t\treturn NVDIMM_CCLASS_NONE;\n\n\treturn NVDIMM_CCLASS_UNKNOWN;\n}\n\nstatic const guid_t *to_abstraction_guid(enum nvdimm_claim_class claim_class,\n\tguid_t *target)\n{\n\tif (claim_class == NVDIMM_CCLASS_BTT)\n\t\treturn &nvdimm_btt_guid;\n\telse if (claim_class == NVDIMM_CCLASS_BTT2)\n\t\treturn &nvdimm_btt2_guid;\n\telse if (claim_class == NVDIMM_CCLASS_PFN)\n\t\treturn &nvdimm_pfn_guid;\n\telse if (claim_class == NVDIMM_CCLASS_DAX)\n\t\treturn &nvdimm_dax_guid;\n\telse if (claim_class == NVDIMM_CCLASS_UNKNOWN) {\n\t\t \n\t\treturn target;\n\t} else\n\t\treturn &guid_null;\n}\n\n \nstatic const uuid_t *to_abstraction_uuid(enum nvdimm_claim_class claim_class,\n\t\t\t\t\t uuid_t *target)\n{\n\tif (claim_class == NVDIMM_CCLASS_BTT)\n\t\treturn &nvdimm_btt_uuid;\n\telse if (claim_class == NVDIMM_CCLASS_BTT2)\n\t\treturn &nvdimm_btt2_uuid;\n\telse if (claim_class == NVDIMM_CCLASS_PFN)\n\t\treturn &nvdimm_pfn_uuid;\n\telse if (claim_class == NVDIMM_CCLASS_DAX)\n\t\treturn &nvdimm_dax_uuid;\n\telse if (claim_class == NVDIMM_CCLASS_UNKNOWN) {\n\t\t \n\t\treturn target;\n\t} else\n\t\treturn &uuid_null;\n}\n\nstatic void reap_victim(struct nd_mapping *nd_mapping,\n\t\tstruct nd_label_ent *victim)\n{\n\tstruct nvdimm_drvdata *ndd = to_ndd(nd_mapping);\n\tu32 slot = to_slot(ndd, victim->label);\n\n\tdev_dbg(ndd->dev, \"free: %d\\n\", slot);\n\tnd_label_free_slot(ndd, slot);\n\tvictim->label = NULL;\n}\n\nstatic void nsl_set_type_guid(struct nvdimm_drvdata *ndd,\n\t\t\t      struct nd_namespace_label *nd_label, guid_t *guid)\n{\n\tif (efi_namespace_label_has(ndd, type_guid))\n\t\tguid_copy(&nd_label->efi.type_guid, guid);\n}\n\nbool nsl_validate_type_guid(struct nvdimm_drvdata *ndd,\n\t\t\t    struct nd_namespace_label *nd_label, guid_t *guid)\n{\n\tif (ndd->cxl || !efi_namespace_label_has(ndd, type_guid))\n\t\treturn true;\n\tif (!guid_equal(&nd_label->efi.type_guid, guid)) {\n\t\tdev_dbg(ndd->dev, \"expect type_guid %pUb got %pUb\\n\", guid,\n\t\t\t&nd_label->efi.type_guid);\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic void nsl_set_claim_class(struct nvdimm_drvdata *ndd,\n\t\t\t\tstruct nd_namespace_label *nd_label,\n\t\t\t\tenum nvdimm_claim_class claim_class)\n{\n\tif (ndd->cxl) {\n\t\tuuid_t uuid;\n\n\t\timport_uuid(&uuid, nd_label->cxl.abstraction_uuid);\n\t\texport_uuid(nd_label->cxl.abstraction_uuid,\n\t\t\t    to_abstraction_uuid(claim_class, &uuid));\n\t\treturn;\n\t}\n\n\tif (!efi_namespace_label_has(ndd, abstraction_guid))\n\t\treturn;\n\tguid_copy(&nd_label->efi.abstraction_guid,\n\t\t  to_abstraction_guid(claim_class,\n\t\t\t\t      &nd_label->efi.abstraction_guid));\n}\n\nenum nvdimm_claim_class nsl_get_claim_class(struct nvdimm_drvdata *ndd,\n\t\t\t\t\t    struct nd_namespace_label *nd_label)\n{\n\tif (ndd->cxl) {\n\t\tuuid_t uuid;\n\n\t\timport_uuid(&uuid, nd_label->cxl.abstraction_uuid);\n\t\treturn uuid_to_nvdimm_cclass(&uuid);\n\t}\n\tif (!efi_namespace_label_has(ndd, abstraction_guid))\n\t\treturn NVDIMM_CCLASS_NONE;\n\treturn guid_to_nvdimm_cclass(&nd_label->efi.abstraction_guid);\n}\n\nstatic int __pmem_label_update(struct nd_region *nd_region,\n\t\tstruct nd_mapping *nd_mapping, struct nd_namespace_pmem *nspm,\n\t\tint pos, unsigned long flags)\n{\n\tstruct nd_namespace_common *ndns = &nspm->nsio.common;\n\tstruct nd_interleave_set *nd_set = nd_region->nd_set;\n\tstruct nvdimm_drvdata *ndd = to_ndd(nd_mapping);\n\tstruct nd_namespace_label *nd_label;\n\tstruct nd_namespace_index *nsindex;\n\tstruct nd_label_ent *label_ent;\n\tstruct nd_label_id label_id;\n\tstruct resource *res;\n\tunsigned long *free;\n\tu32 nslot, slot;\n\tsize_t offset;\n\tu64 cookie;\n\tint rc;\n\n\tif (!preamble_next(ndd, &nsindex, &free, &nslot))\n\t\treturn -ENXIO;\n\n\tcookie = nd_region_interleave_set_cookie(nd_region, nsindex);\n\tnd_label_gen_id(&label_id, nspm->uuid, 0);\n\tfor_each_dpa_resource(ndd, res)\n\t\tif (strcmp(res->name, label_id.id) == 0)\n\t\t\tbreak;\n\n\tif (!res) {\n\t\tWARN_ON_ONCE(1);\n\t\treturn -ENXIO;\n\t}\n\n\t \n\tslot = nd_label_alloc_slot(ndd);\n\tif (slot == UINT_MAX)\n\t\treturn -ENXIO;\n\tdev_dbg(ndd->dev, \"allocated: %d\\n\", slot);\n\n\tnd_label = to_label(ndd, slot);\n\tmemset(nd_label, 0, sizeof_namespace_label(ndd));\n\tnsl_set_uuid(ndd, nd_label, nspm->uuid);\n\tnsl_set_name(ndd, nd_label, nspm->alt_name);\n\tnsl_set_flags(ndd, nd_label, flags);\n\tnsl_set_nlabel(ndd, nd_label, nd_region->ndr_mappings);\n\tnsl_set_nrange(ndd, nd_label, 1);\n\tnsl_set_position(ndd, nd_label, pos);\n\tnsl_set_isetcookie(ndd, nd_label, cookie);\n\tnsl_set_rawsize(ndd, nd_label, resource_size(res));\n\tnsl_set_lbasize(ndd, nd_label, nspm->lbasize);\n\tnsl_set_dpa(ndd, nd_label, res->start);\n\tnsl_set_slot(ndd, nd_label, slot);\n\tnsl_set_type_guid(ndd, nd_label, &nd_set->type_guid);\n\tnsl_set_claim_class(ndd, nd_label, ndns->claim_class);\n\tnsl_calculate_checksum(ndd, nd_label);\n\tnd_dbg_dpa(nd_region, ndd, res, \"\\n\");\n\n\t \n\toffset = nd_label_offset(ndd, nd_label);\n\trc = nvdimm_set_config_data(ndd, offset, nd_label,\n\t\t\tsizeof_namespace_label(ndd));\n\tif (rc < 0)\n\t\treturn rc;\n\n\t \n\tmutex_lock(&nd_mapping->lock);\n\tlist_for_each_entry(label_ent, &nd_mapping->labels, list) {\n\t\tif (!label_ent->label)\n\t\t\tcontinue;\n\t\tif (test_and_clear_bit(ND_LABEL_REAP, &label_ent->flags) ||\n\t\t    nsl_uuid_equal(ndd, label_ent->label, nspm->uuid))\n\t\t\treap_victim(nd_mapping, label_ent);\n\t}\n\n\t \n\trc = nd_label_write_index(ndd, ndd->ns_next,\n\t\t\tnd_inc_seq(__le32_to_cpu(nsindex->seq)), 0);\n\tif (rc == 0) {\n\t\tlist_for_each_entry(label_ent, &nd_mapping->labels, list)\n\t\t\tif (!label_ent->label) {\n\t\t\t\tlabel_ent->label = nd_label;\n\t\t\t\tnd_label = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tdev_WARN_ONCE(&nspm->nsio.common.dev, nd_label,\n\t\t\t\t\"failed to track label: %d\\n\",\n\t\t\t\tto_slot(ndd, nd_label));\n\t\tif (nd_label)\n\t\t\trc = -ENXIO;\n\t}\n\tmutex_unlock(&nd_mapping->lock);\n\n\treturn rc;\n}\n\nstatic int init_labels(struct nd_mapping *nd_mapping, int num_labels)\n{\n\tint i, old_num_labels = 0;\n\tstruct nd_label_ent *label_ent;\n\tstruct nd_namespace_index *nsindex;\n\tstruct nvdimm_drvdata *ndd = to_ndd(nd_mapping);\n\n\tmutex_lock(&nd_mapping->lock);\n\tlist_for_each_entry(label_ent, &nd_mapping->labels, list)\n\t\told_num_labels++;\n\tmutex_unlock(&nd_mapping->lock);\n\n\t \n\tfor (i = old_num_labels; i < num_labels; i++) {\n\t\tlabel_ent = kzalloc(sizeof(*label_ent), GFP_KERNEL);\n\t\tif (!label_ent)\n\t\t\treturn -ENOMEM;\n\t\tmutex_lock(&nd_mapping->lock);\n\t\tlist_add_tail(&label_ent->list, &nd_mapping->labels);\n\t\tmutex_unlock(&nd_mapping->lock);\n\t}\n\n\tif (ndd->ns_current == -1 || ndd->ns_next == -1)\n\t\t ;\n\telse\n\t\treturn max(num_labels, old_num_labels);\n\n\tnsindex = to_namespace_index(ndd, 0);\n\tmemset(nsindex, 0, ndd->nsarea.config_size);\n\tfor (i = 0; i < 2; i++) {\n\t\tint rc = nd_label_write_index(ndd, i, 3 - i, ND_NSINDEX_INIT);\n\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\tndd->ns_next = 1;\n\tndd->ns_current = 0;\n\n\treturn max(num_labels, old_num_labels);\n}\n\nstatic int del_labels(struct nd_mapping *nd_mapping, uuid_t *uuid)\n{\n\tstruct nvdimm_drvdata *ndd = to_ndd(nd_mapping);\n\tstruct nd_label_ent *label_ent, *e;\n\tstruct nd_namespace_index *nsindex;\n\tunsigned long *free;\n\tLIST_HEAD(list);\n\tu32 nslot, slot;\n\tint active = 0;\n\n\tif (!uuid)\n\t\treturn 0;\n\n\t \n\tif (!preamble_next(ndd, &nsindex, &free, &nslot))\n\t\treturn 0;\n\n\tmutex_lock(&nd_mapping->lock);\n\tlist_for_each_entry_safe(label_ent, e, &nd_mapping->labels, list) {\n\t\tstruct nd_namespace_label *nd_label = label_ent->label;\n\n\t\tif (!nd_label)\n\t\t\tcontinue;\n\t\tactive++;\n\t\tif (!nsl_uuid_equal(ndd, nd_label, uuid))\n\t\t\tcontinue;\n\t\tactive--;\n\t\tslot = to_slot(ndd, nd_label);\n\t\tnd_label_free_slot(ndd, slot);\n\t\tdev_dbg(ndd->dev, \"free: %d\\n\", slot);\n\t\tlist_move_tail(&label_ent->list, &list);\n\t\tlabel_ent->label = NULL;\n\t}\n\tlist_splice_tail_init(&list, &nd_mapping->labels);\n\n\tif (active == 0) {\n\t\tnd_mapping_free_labels(nd_mapping);\n\t\tdev_dbg(ndd->dev, \"no more active labels\\n\");\n\t}\n\tmutex_unlock(&nd_mapping->lock);\n\n\treturn nd_label_write_index(ndd, ndd->ns_next,\n\t\t\tnd_inc_seq(__le32_to_cpu(nsindex->seq)), 0);\n}\n\nint nd_pmem_namespace_label_update(struct nd_region *nd_region,\n\t\tstruct nd_namespace_pmem *nspm, resource_size_t size)\n{\n\tint i, rc;\n\n\tfor (i = 0; i < nd_region->ndr_mappings; i++) {\n\t\tstruct nd_mapping *nd_mapping = &nd_region->mapping[i];\n\t\tstruct nvdimm_drvdata *ndd = to_ndd(nd_mapping);\n\t\tstruct resource *res;\n\t\tint count = 0;\n\n\t\tif (size == 0) {\n\t\t\trc = del_labels(nd_mapping, nspm->uuid);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor_each_dpa_resource(ndd, res)\n\t\t\tif (strncmp(res->name, \"pmem\", 4) == 0)\n\t\t\t\tcount++;\n\t\tWARN_ON_ONCE(!count);\n\n\t\trc = init_labels(nd_mapping, count);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\trc = __pmem_label_update(nd_region, nd_mapping, nspm, i,\n\t\t\t\tNSLABEL_FLAG_UPDATING);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\tif (size == 0)\n\t\treturn 0;\n\n\t \n\tfor (i = 0; i < nd_region->ndr_mappings; i++) {\n\t\tstruct nd_mapping *nd_mapping = &nd_region->mapping[i];\n\n\t\trc = __pmem_label_update(nd_region, nd_mapping, nspm, i, 0);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\treturn 0;\n}\n\nint __init nd_label_init(void)\n{\n\tWARN_ON(guid_parse(NVDIMM_BTT_GUID, &nvdimm_btt_guid));\n\tWARN_ON(guid_parse(NVDIMM_BTT2_GUID, &nvdimm_btt2_guid));\n\tWARN_ON(guid_parse(NVDIMM_PFN_GUID, &nvdimm_pfn_guid));\n\tWARN_ON(guid_parse(NVDIMM_DAX_GUID, &nvdimm_dax_guid));\n\n\tWARN_ON(uuid_parse(NVDIMM_BTT_GUID, &nvdimm_btt_uuid));\n\tWARN_ON(uuid_parse(NVDIMM_BTT2_GUID, &nvdimm_btt2_uuid));\n\tWARN_ON(uuid_parse(NVDIMM_PFN_GUID, &nvdimm_pfn_uuid));\n\tWARN_ON(uuid_parse(NVDIMM_DAX_GUID, &nvdimm_dax_uuid));\n\n\tWARN_ON(uuid_parse(CXL_REGION_UUID, &cxl_region_uuid));\n\tWARN_ON(uuid_parse(CXL_NAMESPACE_UUID, &cxl_namespace_uuid));\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}