{
  "module_name": "dax_devs.c",
  "hash_id": "65bc78a864b24d2f1c1c1c1a1a45e616a07bfbafb1aeced4997321c10a3167b8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/nvdimm/dax_devs.c",
  "human_readable_source": "\n \n#include <linux/device.h>\n#include <linux/sizes.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include \"nd-core.h\"\n#include \"pfn.h\"\n#include \"nd.h\"\n\nstatic void nd_dax_release(struct device *dev)\n{\n\tstruct nd_region *nd_region = to_nd_region(dev->parent);\n\tstruct nd_dax *nd_dax = to_nd_dax(dev);\n\tstruct nd_pfn *nd_pfn = &nd_dax->nd_pfn;\n\n\tdev_dbg(dev, \"trace\\n\");\n\tnd_detach_ndns(dev, &nd_pfn->ndns);\n\tida_simple_remove(&nd_region->dax_ida, nd_pfn->id);\n\tkfree(nd_pfn->uuid);\n\tkfree(nd_dax);\n}\n\nstruct nd_dax *to_nd_dax(struct device *dev)\n{\n\tstruct nd_dax *nd_dax = container_of(dev, struct nd_dax, nd_pfn.dev);\n\n\tWARN_ON(!is_nd_dax(dev));\n\treturn nd_dax;\n}\nEXPORT_SYMBOL(to_nd_dax);\n\nstatic const struct device_type nd_dax_device_type = {\n\t.name = \"nd_dax\",\n\t.release = nd_dax_release,\n\t.groups = nd_pfn_attribute_groups,\n};\n\nbool is_nd_dax(const struct device *dev)\n{\n\treturn dev ? dev->type == &nd_dax_device_type : false;\n}\nEXPORT_SYMBOL(is_nd_dax);\n\nstatic struct nd_dax *nd_dax_alloc(struct nd_region *nd_region)\n{\n\tstruct nd_pfn *nd_pfn;\n\tstruct nd_dax *nd_dax;\n\tstruct device *dev;\n\n\tnd_dax = kzalloc(sizeof(*nd_dax), GFP_KERNEL);\n\tif (!nd_dax)\n\t\treturn NULL;\n\n\tnd_pfn = &nd_dax->nd_pfn;\n\tnd_pfn->id = ida_simple_get(&nd_region->dax_ida, 0, 0, GFP_KERNEL);\n\tif (nd_pfn->id < 0) {\n\t\tkfree(nd_dax);\n\t\treturn NULL;\n\t}\n\n\tdev = &nd_pfn->dev;\n\tdev_set_name(dev, \"dax%d.%d\", nd_region->id, nd_pfn->id);\n\tdev->type = &nd_dax_device_type;\n\tdev->parent = &nd_region->dev;\n\n\treturn nd_dax;\n}\n\nstruct device *nd_dax_create(struct nd_region *nd_region)\n{\n\tstruct device *dev = NULL;\n\tstruct nd_dax *nd_dax;\n\n\tif (!is_memory(&nd_region->dev))\n\t\treturn NULL;\n\n\tnd_dax = nd_dax_alloc(nd_region);\n\tif (nd_dax)\n\t\tdev = nd_pfn_devinit(&nd_dax->nd_pfn, NULL);\n\tnd_device_register(dev);\n\treturn dev;\n}\n\nint nd_dax_probe(struct device *dev, struct nd_namespace_common *ndns)\n{\n\tint rc;\n\tstruct nd_dax *nd_dax;\n\tstruct device *dax_dev;\n\tstruct nd_pfn *nd_pfn;\n\tstruct nd_pfn_sb *pfn_sb;\n\tstruct nd_region *nd_region = to_nd_region(ndns->dev.parent);\n\n\tif (ndns->force_raw)\n\t\treturn -ENODEV;\n\n\tswitch (ndns->claim_class) {\n\tcase NVDIMM_CCLASS_NONE:\n\tcase NVDIMM_CCLASS_DAX:\n\t\tbreak;\n\tdefault:\n\t\treturn -ENODEV;\n\t}\n\n\tnvdimm_bus_lock(&ndns->dev);\n\tnd_dax = nd_dax_alloc(nd_region);\n\tnd_pfn = &nd_dax->nd_pfn;\n\tdax_dev = nd_pfn_devinit(nd_pfn, ndns);\n\tnvdimm_bus_unlock(&ndns->dev);\n\tif (!dax_dev)\n\t\treturn -ENOMEM;\n\tpfn_sb = devm_kmalloc(dev, sizeof(*pfn_sb), GFP_KERNEL);\n\tnd_pfn->pfn_sb = pfn_sb;\n\trc = nd_pfn_validate(nd_pfn, DAX_SIG);\n\tdev_dbg(dev, \"dax: %s\\n\", rc == 0 ? dev_name(dax_dev) : \"<none>\");\n\tif (rc < 0) {\n\t\tnd_detach_ndns(dax_dev, &nd_pfn->ndns);\n\t\tput_device(dax_dev);\n\t} else\n\t\tnd_device_register(dax_dev);\n\n\treturn rc;\n}\nEXPORT_SYMBOL(nd_dax_probe);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}