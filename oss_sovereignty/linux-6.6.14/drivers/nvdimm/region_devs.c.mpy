{
  "module_name": "region_devs.c",
  "hash_id": "3668c62b2e7133b5d66214c7acada85c3e3e9e806c913e445adae6d1333f1158",
  "original_prompt": "Ingested from linux-6.6.14/drivers/nvdimm/region_devs.c",
  "human_readable_source": "\n \n#include <linux/scatterlist.h>\n#include <linux/memregion.h>\n#include <linux/highmem.h>\n#include <linux/kstrtox.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/hash.h>\n#include <linux/sort.h>\n#include <linux/io.h>\n#include <linux/nd.h>\n#include \"nd-core.h\"\n#include \"nd.h\"\n\n \n#include <linux/io-64-nonatomic-hi-lo.h>\n\nstatic DEFINE_PER_CPU(int, flush_idx);\n\nstatic int nvdimm_map_flush(struct device *dev, struct nvdimm *nvdimm, int dimm,\n\t\tstruct nd_region_data *ndrd)\n{\n\tint i, j;\n\n\tdev_dbg(dev, \"%s: map %d flush address%s\\n\", nvdimm_name(nvdimm),\n\t\t\tnvdimm->num_flush, nvdimm->num_flush == 1 ? \"\" : \"es\");\n\tfor (i = 0; i < (1 << ndrd->hints_shift); i++) {\n\t\tstruct resource *res = &nvdimm->flush_wpq[i];\n\t\tunsigned long pfn = PHYS_PFN(res->start);\n\t\tvoid __iomem *flush_page;\n\n\t\t \n\t\tfor (j = 0; j < i; j++) {\n\t\t\tstruct resource *res_j = &nvdimm->flush_wpq[j];\n\t\t\tunsigned long pfn_j = PHYS_PFN(res_j->start);\n\n\t\t\tif (pfn == pfn_j)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (j < i)\n\t\t\tflush_page = (void __iomem *) ((unsigned long)\n\t\t\t\t\tndrd_get_flush_wpq(ndrd, dimm, j)\n\t\t\t\t\t& PAGE_MASK);\n\t\telse\n\t\t\tflush_page = devm_nvdimm_ioremap(dev,\n\t\t\t\t\tPFN_PHYS(pfn), PAGE_SIZE);\n\t\tif (!flush_page)\n\t\t\treturn -ENXIO;\n\t\tndrd_set_flush_wpq(ndrd, dimm, i, flush_page\n\t\t\t\t+ (res->start & ~PAGE_MASK));\n\t}\n\n\treturn 0;\n}\n\nstatic int nd_region_invalidate_memregion(struct nd_region *nd_region)\n{\n\tint i, incoherent = 0;\n\n\tfor (i = 0; i < nd_region->ndr_mappings; i++) {\n\t\tstruct nd_mapping *nd_mapping = &nd_region->mapping[i];\n\t\tstruct nvdimm *nvdimm = nd_mapping->nvdimm;\n\n\t\tif (test_bit(NDD_INCOHERENT, &nvdimm->flags)) {\n\t\t\tincoherent++;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!incoherent)\n\t\treturn 0;\n\n\tif (!cpu_cache_has_invalidate_memregion()) {\n\t\tif (IS_ENABLED(CONFIG_NVDIMM_SECURITY_TEST)) {\n\t\t\tdev_warn(\n\t\t\t\t&nd_region->dev,\n\t\t\t\t\"Bypassing cpu_cache_invalidate_memergion() for testing!\\n\");\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tdev_err(&nd_region->dev,\n\t\t\t\t\"Failed to synchronize CPU cache state\\n\");\n\t\t\treturn -ENXIO;\n\t\t}\n\t}\n\n\tcpu_cache_invalidate_memregion(IORES_DESC_PERSISTENT_MEMORY);\nout:\n\tfor (i = 0; i < nd_region->ndr_mappings; i++) {\n\t\tstruct nd_mapping *nd_mapping = &nd_region->mapping[i];\n\t\tstruct nvdimm *nvdimm = nd_mapping->nvdimm;\n\n\t\tclear_bit(NDD_INCOHERENT, &nvdimm->flags);\n\t}\n\n\treturn 0;\n}\n\nint nd_region_activate(struct nd_region *nd_region)\n{\n\tint i, j, rc, num_flush = 0;\n\tstruct nd_region_data *ndrd;\n\tstruct device *dev = &nd_region->dev;\n\tsize_t flush_data_size = sizeof(void *);\n\n\tnvdimm_bus_lock(&nd_region->dev);\n\tfor (i = 0; i < nd_region->ndr_mappings; i++) {\n\t\tstruct nd_mapping *nd_mapping = &nd_region->mapping[i];\n\t\tstruct nvdimm *nvdimm = nd_mapping->nvdimm;\n\n\t\tif (test_bit(NDD_SECURITY_OVERWRITE, &nvdimm->flags)) {\n\t\t\tnvdimm_bus_unlock(&nd_region->dev);\n\t\t\treturn -EBUSY;\n\t\t}\n\n\t\t \n\t\tflush_data_size += sizeof(void *);\n\t\tnum_flush = min_not_zero(num_flush, nvdimm->num_flush);\n\t\tif (!nvdimm->num_flush)\n\t\t\tcontinue;\n\t\tflush_data_size += nvdimm->num_flush * sizeof(void *);\n\t}\n\tnvdimm_bus_unlock(&nd_region->dev);\n\n\trc = nd_region_invalidate_memregion(nd_region);\n\tif (rc)\n\t\treturn rc;\n\n\tndrd = devm_kzalloc(dev, sizeof(*ndrd) + flush_data_size, GFP_KERNEL);\n\tif (!ndrd)\n\t\treturn -ENOMEM;\n\tdev_set_drvdata(dev, ndrd);\n\n\tif (!num_flush)\n\t\treturn 0;\n\n\tndrd->hints_shift = ilog2(num_flush);\n\tfor (i = 0; i < nd_region->ndr_mappings; i++) {\n\t\tstruct nd_mapping *nd_mapping = &nd_region->mapping[i];\n\t\tstruct nvdimm *nvdimm = nd_mapping->nvdimm;\n\t\tint rc = nvdimm_map_flush(&nd_region->dev, nvdimm, i, ndrd);\n\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\t \n\tfor (i = 0; i < nd_region->ndr_mappings - 1; i++) {\n\t\t \n\t\tif (!ndrd_get_flush_wpq(ndrd, i, 0))\n\t\t\tcontinue;\n\n\t\tfor (j = i + 1; j < nd_region->ndr_mappings; j++)\n\t\t\tif (ndrd_get_flush_wpq(ndrd, i, 0) ==\n\t\t\t    ndrd_get_flush_wpq(ndrd, j, 0))\n\t\t\t\tndrd_set_flush_wpq(ndrd, j, 0, NULL);\n\t}\n\n\treturn 0;\n}\n\nstatic void nd_region_release(struct device *dev)\n{\n\tstruct nd_region *nd_region = to_nd_region(dev);\n\tu16 i;\n\n\tfor (i = 0; i < nd_region->ndr_mappings; i++) {\n\t\tstruct nd_mapping *nd_mapping = &nd_region->mapping[i];\n\t\tstruct nvdimm *nvdimm = nd_mapping->nvdimm;\n\n\t\tput_device(&nvdimm->dev);\n\t}\n\tfree_percpu(nd_region->lane);\n\tif (!test_bit(ND_REGION_CXL, &nd_region->flags))\n\t\tmemregion_free(nd_region->id);\n\tkfree(nd_region);\n}\n\nstruct nd_region *to_nd_region(struct device *dev)\n{\n\tstruct nd_region *nd_region = container_of(dev, struct nd_region, dev);\n\n\tWARN_ON(dev->type->release != nd_region_release);\n\treturn nd_region;\n}\nEXPORT_SYMBOL_GPL(to_nd_region);\n\nstruct device *nd_region_dev(struct nd_region *nd_region)\n{\n\tif (!nd_region)\n\t\treturn NULL;\n\treturn &nd_region->dev;\n}\nEXPORT_SYMBOL_GPL(nd_region_dev);\n\nvoid *nd_region_provider_data(struct nd_region *nd_region)\n{\n\treturn nd_region->provider_data;\n}\nEXPORT_SYMBOL_GPL(nd_region_provider_data);\n\n \nint nd_region_to_nstype(struct nd_region *nd_region)\n{\n\tif (is_memory(&nd_region->dev)) {\n\t\tu16 i, label;\n\n\t\tfor (i = 0, label = 0; i < nd_region->ndr_mappings; i++) {\n\t\t\tstruct nd_mapping *nd_mapping = &nd_region->mapping[i];\n\t\t\tstruct nvdimm *nvdimm = nd_mapping->nvdimm;\n\n\t\t\tif (test_bit(NDD_LABELING, &nvdimm->flags))\n\t\t\t\tlabel++;\n\t\t}\n\t\tif (label)\n\t\t\treturn ND_DEVICE_NAMESPACE_PMEM;\n\t\telse\n\t\t\treturn ND_DEVICE_NAMESPACE_IO;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(nd_region_to_nstype);\n\nstatic unsigned long long region_size(struct nd_region *nd_region)\n{\n\tif (is_memory(&nd_region->dev)) {\n\t\treturn nd_region->ndr_size;\n\t} else if (nd_region->ndr_mappings == 1) {\n\t\tstruct nd_mapping *nd_mapping = &nd_region->mapping[0];\n\n\t\treturn nd_mapping->size;\n\t}\n\n\treturn 0;\n}\n\nstatic ssize_t size_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct nd_region *nd_region = to_nd_region(dev);\n\n\treturn sprintf(buf, \"%llu\\n\", region_size(nd_region));\n}\nstatic DEVICE_ATTR_RO(size);\n\nstatic ssize_t deep_flush_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct nd_region *nd_region = to_nd_region(dev);\n\n\t \n\treturn sprintf(buf, \"%d\\n\", nvdimm_has_flush(nd_region));\n}\n\nstatic ssize_t deep_flush_store(struct device *dev, struct device_attribute *attr,\n\t\tconst char *buf, size_t len)\n{\n\tbool flush;\n\tint rc = kstrtobool(buf, &flush);\n\tstruct nd_region *nd_region = to_nd_region(dev);\n\n\tif (rc)\n\t\treturn rc;\n\tif (!flush)\n\t\treturn -EINVAL;\n\trc = nvdimm_flush(nd_region, NULL);\n\tif (rc)\n\t\treturn rc;\n\n\treturn len;\n}\nstatic DEVICE_ATTR_RW(deep_flush);\n\nstatic ssize_t mappings_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct nd_region *nd_region = to_nd_region(dev);\n\n\treturn sprintf(buf, \"%d\\n\", nd_region->ndr_mappings);\n}\nstatic DEVICE_ATTR_RO(mappings);\n\nstatic ssize_t nstype_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct nd_region *nd_region = to_nd_region(dev);\n\n\treturn sprintf(buf, \"%d\\n\", nd_region_to_nstype(nd_region));\n}\nstatic DEVICE_ATTR_RO(nstype);\n\nstatic ssize_t set_cookie_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct nd_region *nd_region = to_nd_region(dev);\n\tstruct nd_interleave_set *nd_set = nd_region->nd_set;\n\tssize_t rc = 0;\n\n\tif (is_memory(dev) && nd_set)\n\t\t ;\n\telse\n\t\treturn -ENXIO;\n\n\t \n\tdevice_lock(dev);\n\tnvdimm_bus_lock(dev);\n\twait_nvdimm_bus_probe_idle(dev);\n\tif (nd_region->ndr_mappings) {\n\t\tstruct nd_mapping *nd_mapping = &nd_region->mapping[0];\n\t\tstruct nvdimm_drvdata *ndd = to_ndd(nd_mapping);\n\n\t\tif (ndd) {\n\t\t\tstruct nd_namespace_index *nsindex;\n\n\t\t\tnsindex = to_namespace_index(ndd, ndd->ns_current);\n\t\t\trc = sprintf(buf, \"%#llx\\n\",\n\t\t\t\t\tnd_region_interleave_set_cookie(nd_region,\n\t\t\t\t\t\tnsindex));\n\t\t}\n\t}\n\tnvdimm_bus_unlock(dev);\n\tdevice_unlock(dev);\n\n\tif (rc)\n\t\treturn rc;\n\treturn sprintf(buf, \"%#llx\\n\", nd_set->cookie1);\n}\nstatic DEVICE_ATTR_RO(set_cookie);\n\nresource_size_t nd_region_available_dpa(struct nd_region *nd_region)\n{\n\tresource_size_t available;\n\tint i;\n\n\tWARN_ON(!is_nvdimm_bus_locked(&nd_region->dev));\n\n\tavailable = 0;\n\tfor (i = 0; i < nd_region->ndr_mappings; i++) {\n\t\tstruct nd_mapping *nd_mapping = &nd_region->mapping[i];\n\t\tstruct nvdimm_drvdata *ndd = to_ndd(nd_mapping);\n\n\t\t \n\t\tif (!ndd)\n\t\t\treturn 0;\n\n\t\tavailable += nd_pmem_available_dpa(nd_region, nd_mapping);\n\t}\n\n\treturn available;\n}\n\nresource_size_t nd_region_allocatable_dpa(struct nd_region *nd_region)\n{\n\tresource_size_t avail = 0;\n\tint i;\n\n\tWARN_ON(!is_nvdimm_bus_locked(&nd_region->dev));\n\tfor (i = 0; i < nd_region->ndr_mappings; i++) {\n\t\tstruct nd_mapping *nd_mapping = &nd_region->mapping[i];\n\n\t\tavail = min_not_zero(avail, nd_pmem_max_contiguous_dpa(\n\t\t\t\t\t\t    nd_region, nd_mapping));\n\t}\n\treturn avail * nd_region->ndr_mappings;\n}\n\nstatic ssize_t available_size_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct nd_region *nd_region = to_nd_region(dev);\n\tunsigned long long available = 0;\n\n\t \n\tdevice_lock(dev);\n\tnvdimm_bus_lock(dev);\n\twait_nvdimm_bus_probe_idle(dev);\n\tavailable = nd_region_available_dpa(nd_region);\n\tnvdimm_bus_unlock(dev);\n\tdevice_unlock(dev);\n\n\treturn sprintf(buf, \"%llu\\n\", available);\n}\nstatic DEVICE_ATTR_RO(available_size);\n\nstatic ssize_t max_available_extent_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct nd_region *nd_region = to_nd_region(dev);\n\tunsigned long long available = 0;\n\n\tdevice_lock(dev);\n\tnvdimm_bus_lock(dev);\n\twait_nvdimm_bus_probe_idle(dev);\n\tavailable = nd_region_allocatable_dpa(nd_region);\n\tnvdimm_bus_unlock(dev);\n\tdevice_unlock(dev);\n\n\treturn sprintf(buf, \"%llu\\n\", available);\n}\nstatic DEVICE_ATTR_RO(max_available_extent);\n\nstatic ssize_t init_namespaces_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct nd_region_data *ndrd = dev_get_drvdata(dev);\n\tssize_t rc;\n\n\tnvdimm_bus_lock(dev);\n\tif (ndrd)\n\t\trc = sprintf(buf, \"%d/%d\\n\", ndrd->ns_active, ndrd->ns_count);\n\telse\n\t\trc = -ENXIO;\n\tnvdimm_bus_unlock(dev);\n\n\treturn rc;\n}\nstatic DEVICE_ATTR_RO(init_namespaces);\n\nstatic ssize_t namespace_seed_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct nd_region *nd_region = to_nd_region(dev);\n\tssize_t rc;\n\n\tnvdimm_bus_lock(dev);\n\tif (nd_region->ns_seed)\n\t\trc = sprintf(buf, \"%s\\n\", dev_name(nd_region->ns_seed));\n\telse\n\t\trc = sprintf(buf, \"\\n\");\n\tnvdimm_bus_unlock(dev);\n\treturn rc;\n}\nstatic DEVICE_ATTR_RO(namespace_seed);\n\nstatic ssize_t btt_seed_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct nd_region *nd_region = to_nd_region(dev);\n\tssize_t rc;\n\n\tnvdimm_bus_lock(dev);\n\tif (nd_region->btt_seed)\n\t\trc = sprintf(buf, \"%s\\n\", dev_name(nd_region->btt_seed));\n\telse\n\t\trc = sprintf(buf, \"\\n\");\n\tnvdimm_bus_unlock(dev);\n\n\treturn rc;\n}\nstatic DEVICE_ATTR_RO(btt_seed);\n\nstatic ssize_t pfn_seed_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct nd_region *nd_region = to_nd_region(dev);\n\tssize_t rc;\n\n\tnvdimm_bus_lock(dev);\n\tif (nd_region->pfn_seed)\n\t\trc = sprintf(buf, \"%s\\n\", dev_name(nd_region->pfn_seed));\n\telse\n\t\trc = sprintf(buf, \"\\n\");\n\tnvdimm_bus_unlock(dev);\n\n\treturn rc;\n}\nstatic DEVICE_ATTR_RO(pfn_seed);\n\nstatic ssize_t dax_seed_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct nd_region *nd_region = to_nd_region(dev);\n\tssize_t rc;\n\n\tnvdimm_bus_lock(dev);\n\tif (nd_region->dax_seed)\n\t\trc = sprintf(buf, \"%s\\n\", dev_name(nd_region->dax_seed));\n\telse\n\t\trc = sprintf(buf, \"\\n\");\n\tnvdimm_bus_unlock(dev);\n\n\treturn rc;\n}\nstatic DEVICE_ATTR_RO(dax_seed);\n\nstatic ssize_t read_only_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct nd_region *nd_region = to_nd_region(dev);\n\n\treturn sprintf(buf, \"%d\\n\", nd_region->ro);\n}\n\nstatic int revalidate_read_only(struct device *dev, void *data)\n{\n\tnd_device_notify(dev, NVDIMM_REVALIDATE_REGION);\n\treturn 0;\n}\n\nstatic ssize_t read_only_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t len)\n{\n\tbool ro;\n\tint rc = kstrtobool(buf, &ro);\n\tstruct nd_region *nd_region = to_nd_region(dev);\n\n\tif (rc)\n\t\treturn rc;\n\n\tnd_region->ro = ro;\n\tdevice_for_each_child(dev, NULL, revalidate_read_only);\n\treturn len;\n}\nstatic DEVICE_ATTR_RW(read_only);\n\nstatic ssize_t align_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct nd_region *nd_region = to_nd_region(dev);\n\n\treturn sprintf(buf, \"%#lx\\n\", nd_region->align);\n}\n\nstatic ssize_t align_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t len)\n{\n\tstruct nd_region *nd_region = to_nd_region(dev);\n\tunsigned long val, dpa;\n\tu32 mappings, remainder;\n\tint rc;\n\n\trc = kstrtoul(buf, 0, &val);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tmappings = max_t(u32, 1, nd_region->ndr_mappings);\n\tdpa = div_u64_rem(val, mappings, &remainder);\n\tif (!is_power_of_2(dpa) || dpa < PAGE_SIZE\n\t\t\t|| val > region_size(nd_region) || remainder)\n\t\treturn -EINVAL;\n\n\t \n\tnvdimm_bus_lock(dev);\n\tnd_region->align = val;\n\tnvdimm_bus_unlock(dev);\n\n\treturn len;\n}\nstatic DEVICE_ATTR_RW(align);\n\nstatic ssize_t region_badblocks_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct nd_region *nd_region = to_nd_region(dev);\n\tssize_t rc;\n\n\tdevice_lock(dev);\n\tif (dev->driver)\n\t\trc = badblocks_show(&nd_region->bb, buf, 0);\n\telse\n\t\trc = -ENXIO;\n\tdevice_unlock(dev);\n\n\treturn rc;\n}\nstatic DEVICE_ATTR(badblocks, 0444, region_badblocks_show, NULL);\n\nstatic ssize_t resource_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct nd_region *nd_region = to_nd_region(dev);\n\n\treturn sprintf(buf, \"%#llx\\n\", nd_region->ndr_start);\n}\nstatic DEVICE_ATTR_ADMIN_RO(resource);\n\nstatic ssize_t persistence_domain_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct nd_region *nd_region = to_nd_region(dev);\n\n\tif (test_bit(ND_REGION_PERSIST_CACHE, &nd_region->flags))\n\t\treturn sprintf(buf, \"cpu_cache\\n\");\n\telse if (test_bit(ND_REGION_PERSIST_MEMCTRL, &nd_region->flags))\n\t\treturn sprintf(buf, \"memory_controller\\n\");\n\telse\n\t\treturn sprintf(buf, \"\\n\");\n}\nstatic DEVICE_ATTR_RO(persistence_domain);\n\nstatic struct attribute *nd_region_attributes[] = {\n\t&dev_attr_size.attr,\n\t&dev_attr_align.attr,\n\t&dev_attr_nstype.attr,\n\t&dev_attr_mappings.attr,\n\t&dev_attr_btt_seed.attr,\n\t&dev_attr_pfn_seed.attr,\n\t&dev_attr_dax_seed.attr,\n\t&dev_attr_deep_flush.attr,\n\t&dev_attr_read_only.attr,\n\t&dev_attr_set_cookie.attr,\n\t&dev_attr_available_size.attr,\n\t&dev_attr_max_available_extent.attr,\n\t&dev_attr_namespace_seed.attr,\n\t&dev_attr_init_namespaces.attr,\n\t&dev_attr_badblocks.attr,\n\t&dev_attr_resource.attr,\n\t&dev_attr_persistence_domain.attr,\n\tNULL,\n};\n\nstatic umode_t region_visible(struct kobject *kobj, struct attribute *a, int n)\n{\n\tstruct device *dev = container_of(kobj, typeof(*dev), kobj);\n\tstruct nd_region *nd_region = to_nd_region(dev);\n\tstruct nd_interleave_set *nd_set = nd_region->nd_set;\n\tint type = nd_region_to_nstype(nd_region);\n\n\tif (!is_memory(dev) && a == &dev_attr_pfn_seed.attr)\n\t\treturn 0;\n\n\tif (!is_memory(dev) && a == &dev_attr_dax_seed.attr)\n\t\treturn 0;\n\n\tif (!is_memory(dev) && a == &dev_attr_badblocks.attr)\n\t\treturn 0;\n\n\tif (a == &dev_attr_resource.attr && !is_memory(dev))\n\t\treturn 0;\n\n\tif (a == &dev_attr_deep_flush.attr) {\n\t\tint has_flush = nvdimm_has_flush(nd_region);\n\n\t\tif (has_flush == 1)\n\t\t\treturn a->mode;\n\t\telse if (has_flush == 0)\n\t\t\treturn 0444;\n\t\telse\n\t\t\treturn 0;\n\t}\n\n\tif (a == &dev_attr_persistence_domain.attr) {\n\t\tif ((nd_region->flags & (BIT(ND_REGION_PERSIST_CACHE)\n\t\t\t\t\t| BIT(ND_REGION_PERSIST_MEMCTRL))) == 0)\n\t\t\treturn 0;\n\t\treturn a->mode;\n\t}\n\n\tif (a == &dev_attr_align.attr)\n\t\treturn a->mode;\n\n\tif (a != &dev_attr_set_cookie.attr\n\t\t\t&& a != &dev_attr_available_size.attr)\n\t\treturn a->mode;\n\n\tif (type == ND_DEVICE_NAMESPACE_PMEM &&\n\t    a == &dev_attr_available_size.attr)\n\t\treturn a->mode;\n\telse if (is_memory(dev) && nd_set)\n\t\treturn a->mode;\n\n\treturn 0;\n}\n\nstatic ssize_t mappingN(struct device *dev, char *buf, int n)\n{\n\tstruct nd_region *nd_region = to_nd_region(dev);\n\tstruct nd_mapping *nd_mapping;\n\tstruct nvdimm *nvdimm;\n\n\tif (n >= nd_region->ndr_mappings)\n\t\treturn -ENXIO;\n\tnd_mapping = &nd_region->mapping[n];\n\tnvdimm = nd_mapping->nvdimm;\n\n\treturn sprintf(buf, \"%s,%llu,%llu,%d\\n\", dev_name(&nvdimm->dev),\n\t\t\tnd_mapping->start, nd_mapping->size,\n\t\t\tnd_mapping->position);\n}\n\n#define REGION_MAPPING(idx) \\\nstatic ssize_t mapping##idx##_show(struct device *dev,\t\t\\\n\t\tstruct device_attribute *attr, char *buf)\t\\\n{\t\t\t\t\t\t\t\t\\\n\treturn mappingN(dev, buf, idx);\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\\\nstatic DEVICE_ATTR_RO(mapping##idx)\n\n \nREGION_MAPPING(0);\nREGION_MAPPING(1);\nREGION_MAPPING(2);\nREGION_MAPPING(3);\nREGION_MAPPING(4);\nREGION_MAPPING(5);\nREGION_MAPPING(6);\nREGION_MAPPING(7);\nREGION_MAPPING(8);\nREGION_MAPPING(9);\nREGION_MAPPING(10);\nREGION_MAPPING(11);\nREGION_MAPPING(12);\nREGION_MAPPING(13);\nREGION_MAPPING(14);\nREGION_MAPPING(15);\nREGION_MAPPING(16);\nREGION_MAPPING(17);\nREGION_MAPPING(18);\nREGION_MAPPING(19);\nREGION_MAPPING(20);\nREGION_MAPPING(21);\nREGION_MAPPING(22);\nREGION_MAPPING(23);\nREGION_MAPPING(24);\nREGION_MAPPING(25);\nREGION_MAPPING(26);\nREGION_MAPPING(27);\nREGION_MAPPING(28);\nREGION_MAPPING(29);\nREGION_MAPPING(30);\nREGION_MAPPING(31);\n\nstatic umode_t mapping_visible(struct kobject *kobj, struct attribute *a, int n)\n{\n\tstruct device *dev = container_of(kobj, struct device, kobj);\n\tstruct nd_region *nd_region = to_nd_region(dev);\n\n\tif (n < nd_region->ndr_mappings)\n\t\treturn a->mode;\n\treturn 0;\n}\n\nstatic struct attribute *mapping_attributes[] = {\n\t&dev_attr_mapping0.attr,\n\t&dev_attr_mapping1.attr,\n\t&dev_attr_mapping2.attr,\n\t&dev_attr_mapping3.attr,\n\t&dev_attr_mapping4.attr,\n\t&dev_attr_mapping5.attr,\n\t&dev_attr_mapping6.attr,\n\t&dev_attr_mapping7.attr,\n\t&dev_attr_mapping8.attr,\n\t&dev_attr_mapping9.attr,\n\t&dev_attr_mapping10.attr,\n\t&dev_attr_mapping11.attr,\n\t&dev_attr_mapping12.attr,\n\t&dev_attr_mapping13.attr,\n\t&dev_attr_mapping14.attr,\n\t&dev_attr_mapping15.attr,\n\t&dev_attr_mapping16.attr,\n\t&dev_attr_mapping17.attr,\n\t&dev_attr_mapping18.attr,\n\t&dev_attr_mapping19.attr,\n\t&dev_attr_mapping20.attr,\n\t&dev_attr_mapping21.attr,\n\t&dev_attr_mapping22.attr,\n\t&dev_attr_mapping23.attr,\n\t&dev_attr_mapping24.attr,\n\t&dev_attr_mapping25.attr,\n\t&dev_attr_mapping26.attr,\n\t&dev_attr_mapping27.attr,\n\t&dev_attr_mapping28.attr,\n\t&dev_attr_mapping29.attr,\n\t&dev_attr_mapping30.attr,\n\t&dev_attr_mapping31.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group nd_mapping_attribute_group = {\n\t.is_visible = mapping_visible,\n\t.attrs = mapping_attributes,\n};\n\nstatic const struct attribute_group nd_region_attribute_group = {\n\t.attrs = nd_region_attributes,\n\t.is_visible = region_visible,\n};\n\nstatic const struct attribute_group *nd_region_attribute_groups[] = {\n\t&nd_device_attribute_group,\n\t&nd_region_attribute_group,\n\t&nd_numa_attribute_group,\n\t&nd_mapping_attribute_group,\n\tNULL,\n};\n\nstatic const struct device_type nd_pmem_device_type = {\n\t.name = \"nd_pmem\",\n\t.release = nd_region_release,\n\t.groups = nd_region_attribute_groups,\n};\n\nstatic const struct device_type nd_volatile_device_type = {\n\t.name = \"nd_volatile\",\n\t.release = nd_region_release,\n\t.groups = nd_region_attribute_groups,\n};\n\nbool is_nd_pmem(const struct device *dev)\n{\n\treturn dev ? dev->type == &nd_pmem_device_type : false;\n}\n\nbool is_nd_volatile(const struct device *dev)\n{\n\treturn dev ? dev->type == &nd_volatile_device_type : false;\n}\n\nu64 nd_region_interleave_set_cookie(struct nd_region *nd_region,\n\t\tstruct nd_namespace_index *nsindex)\n{\n\tstruct nd_interleave_set *nd_set = nd_region->nd_set;\n\n\tif (!nd_set)\n\t\treturn 0;\n\n\tif (nsindex && __le16_to_cpu(nsindex->major) == 1\n\t\t\t&& __le16_to_cpu(nsindex->minor) == 1)\n\t\treturn nd_set->cookie1;\n\treturn nd_set->cookie2;\n}\n\nu64 nd_region_interleave_set_altcookie(struct nd_region *nd_region)\n{\n\tstruct nd_interleave_set *nd_set = nd_region->nd_set;\n\n\tif (nd_set)\n\t\treturn nd_set->altcookie;\n\treturn 0;\n}\n\nvoid nd_mapping_free_labels(struct nd_mapping *nd_mapping)\n{\n\tstruct nd_label_ent *label_ent, *e;\n\n\tlockdep_assert_held(&nd_mapping->lock);\n\tlist_for_each_entry_safe(label_ent, e, &nd_mapping->labels, list) {\n\t\tlist_del(&label_ent->list);\n\t\tkfree(label_ent);\n\t}\n}\n\n \nvoid nd_region_advance_seeds(struct nd_region *nd_region, struct device *dev)\n{\n\tnvdimm_bus_lock(dev);\n\tif (nd_region->ns_seed == dev) {\n\t\tnd_region_create_ns_seed(nd_region);\n\t} else if (is_nd_btt(dev)) {\n\t\tstruct nd_btt *nd_btt = to_nd_btt(dev);\n\n\t\tif (nd_region->btt_seed == dev)\n\t\t\tnd_region_create_btt_seed(nd_region);\n\t\tif (nd_region->ns_seed == &nd_btt->ndns->dev)\n\t\t\tnd_region_create_ns_seed(nd_region);\n\t} else if (is_nd_pfn(dev)) {\n\t\tstruct nd_pfn *nd_pfn = to_nd_pfn(dev);\n\n\t\tif (nd_region->pfn_seed == dev)\n\t\t\tnd_region_create_pfn_seed(nd_region);\n\t\tif (nd_region->ns_seed == &nd_pfn->ndns->dev)\n\t\t\tnd_region_create_ns_seed(nd_region);\n\t} else if (is_nd_dax(dev)) {\n\t\tstruct nd_dax *nd_dax = to_nd_dax(dev);\n\n\t\tif (nd_region->dax_seed == dev)\n\t\t\tnd_region_create_dax_seed(nd_region);\n\t\tif (nd_region->ns_seed == &nd_dax->nd_pfn.ndns->dev)\n\t\t\tnd_region_create_ns_seed(nd_region);\n\t}\n\tnvdimm_bus_unlock(dev);\n}\n\n \nunsigned int nd_region_acquire_lane(struct nd_region *nd_region)\n{\n\tunsigned int cpu, lane;\n\n\tmigrate_disable();\n\tcpu = smp_processor_id();\n\tif (nd_region->num_lanes < nr_cpu_ids) {\n\t\tstruct nd_percpu_lane *ndl_lock, *ndl_count;\n\n\t\tlane = cpu % nd_region->num_lanes;\n\t\tndl_count = per_cpu_ptr(nd_region->lane, cpu);\n\t\tndl_lock = per_cpu_ptr(nd_region->lane, lane);\n\t\tif (ndl_count->count++ == 0)\n\t\t\tspin_lock(&ndl_lock->lock);\n\t} else\n\t\tlane = cpu;\n\n\treturn lane;\n}\nEXPORT_SYMBOL(nd_region_acquire_lane);\n\nvoid nd_region_release_lane(struct nd_region *nd_region, unsigned int lane)\n{\n\tif (nd_region->num_lanes < nr_cpu_ids) {\n\t\tunsigned int cpu = smp_processor_id();\n\t\tstruct nd_percpu_lane *ndl_lock, *ndl_count;\n\n\t\tndl_count = per_cpu_ptr(nd_region->lane, cpu);\n\t\tndl_lock = per_cpu_ptr(nd_region->lane, lane);\n\t\tif (--ndl_count->count == 0)\n\t\t\tspin_unlock(&ndl_lock->lock);\n\t}\n\tmigrate_enable();\n}\nEXPORT_SYMBOL(nd_region_release_lane);\n\n \n#define MEMREMAP_COMPAT_ALIGN_MAX SZ_16M\n\nstatic unsigned long default_align(struct nd_region *nd_region)\n{\n\tunsigned long align;\n\tu32 remainder;\n\tint mappings;\n\n\talign = MEMREMAP_COMPAT_ALIGN_MAX;\n\tif (nd_region->ndr_size < MEMREMAP_COMPAT_ALIGN_MAX)\n\t\talign = PAGE_SIZE;\n\n\tmappings = max_t(u16, 1, nd_region->ndr_mappings);\n\tdiv_u64_rem(align, mappings, &remainder);\n\tif (remainder)\n\t\talign *= mappings;\n\n\treturn align;\n}\n\nstatic struct lock_class_key nvdimm_region_key;\n\nstatic struct nd_region *nd_region_create(struct nvdimm_bus *nvdimm_bus,\n\t\tstruct nd_region_desc *ndr_desc,\n\t\tconst struct device_type *dev_type, const char *caller)\n{\n\tstruct nd_region *nd_region;\n\tstruct device *dev;\n\tunsigned int i;\n\tint ro = 0;\n\n\tfor (i = 0; i < ndr_desc->num_mappings; i++) {\n\t\tstruct nd_mapping_desc *mapping = &ndr_desc->mapping[i];\n\t\tstruct nvdimm *nvdimm = mapping->nvdimm;\n\n\t\tif ((mapping->start | mapping->size) % PAGE_SIZE) {\n\t\t\tdev_err(&nvdimm_bus->dev,\n\t\t\t\t\"%s: %s mapping%d is not %ld aligned\\n\",\n\t\t\t\tcaller, dev_name(&nvdimm->dev), i, PAGE_SIZE);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (test_bit(NDD_UNARMED, &nvdimm->flags))\n\t\t\tro = 1;\n\n\t}\n\n\tnd_region =\n\t\tkzalloc(struct_size(nd_region, mapping, ndr_desc->num_mappings),\n\t\t\tGFP_KERNEL);\n\n\tif (!nd_region)\n\t\treturn NULL;\n\t \n\tif (test_bit(ND_REGION_CXL, &ndr_desc->flags)) {\n\t\tnd_region->id = ndr_desc->memregion;\n\t} else {\n\t\tnd_region->id = memregion_alloc(GFP_KERNEL);\n\t\tif (nd_region->id < 0)\n\t\t\tgoto err_id;\n\t}\n\n\tnd_region->lane = alloc_percpu(struct nd_percpu_lane);\n\tif (!nd_region->lane)\n\t\tgoto err_percpu;\n\n        for (i = 0; i < nr_cpu_ids; i++) {\n\t\tstruct nd_percpu_lane *ndl;\n\n\t\tndl = per_cpu_ptr(nd_region->lane, i);\n\t\tspin_lock_init(&ndl->lock);\n\t\tndl->count = 0;\n\t}\n\n\tfor (i = 0; i < ndr_desc->num_mappings; i++) {\n\t\tstruct nd_mapping_desc *mapping = &ndr_desc->mapping[i];\n\t\tstruct nvdimm *nvdimm = mapping->nvdimm;\n\n\t\tnd_region->mapping[i].nvdimm = nvdimm;\n\t\tnd_region->mapping[i].start = mapping->start;\n\t\tnd_region->mapping[i].size = mapping->size;\n\t\tnd_region->mapping[i].position = mapping->position;\n\t\tINIT_LIST_HEAD(&nd_region->mapping[i].labels);\n\t\tmutex_init(&nd_region->mapping[i].lock);\n\n\t\tget_device(&nvdimm->dev);\n\t}\n\tnd_region->ndr_mappings = ndr_desc->num_mappings;\n\tnd_region->provider_data = ndr_desc->provider_data;\n\tnd_region->nd_set = ndr_desc->nd_set;\n\tnd_region->num_lanes = ndr_desc->num_lanes;\n\tnd_region->flags = ndr_desc->flags;\n\tnd_region->ro = ro;\n\tnd_region->numa_node = ndr_desc->numa_node;\n\tnd_region->target_node = ndr_desc->target_node;\n\tida_init(&nd_region->ns_ida);\n\tida_init(&nd_region->btt_ida);\n\tida_init(&nd_region->pfn_ida);\n\tida_init(&nd_region->dax_ida);\n\tdev = &nd_region->dev;\n\tdev_set_name(dev, \"region%d\", nd_region->id);\n\tdev->parent = &nvdimm_bus->dev;\n\tdev->type = dev_type;\n\tdev->groups = ndr_desc->attr_groups;\n\tdev->of_node = ndr_desc->of_node;\n\tnd_region->ndr_size = resource_size(ndr_desc->res);\n\tnd_region->ndr_start = ndr_desc->res->start;\n\tnd_region->align = default_align(nd_region);\n\tif (ndr_desc->flush)\n\t\tnd_region->flush = ndr_desc->flush;\n\telse\n\t\tnd_region->flush = NULL;\n\n\tdevice_initialize(dev);\n\tlockdep_set_class(&dev->mutex, &nvdimm_region_key);\n\tnd_device_register(dev);\n\n\treturn nd_region;\n\nerr_percpu:\n\tif (!test_bit(ND_REGION_CXL, &ndr_desc->flags))\n\t\tmemregion_free(nd_region->id);\nerr_id:\n\tkfree(nd_region);\n\treturn NULL;\n}\n\nstruct nd_region *nvdimm_pmem_region_create(struct nvdimm_bus *nvdimm_bus,\n\t\tstruct nd_region_desc *ndr_desc)\n{\n\tndr_desc->num_lanes = ND_MAX_LANES;\n\treturn nd_region_create(nvdimm_bus, ndr_desc, &nd_pmem_device_type,\n\t\t\t__func__);\n}\nEXPORT_SYMBOL_GPL(nvdimm_pmem_region_create);\n\nstruct nd_region *nvdimm_volatile_region_create(struct nvdimm_bus *nvdimm_bus,\n\t\tstruct nd_region_desc *ndr_desc)\n{\n\tndr_desc->num_lanes = ND_MAX_LANES;\n\treturn nd_region_create(nvdimm_bus, ndr_desc, &nd_volatile_device_type,\n\t\t\t__func__);\n}\nEXPORT_SYMBOL_GPL(nvdimm_volatile_region_create);\n\nvoid nvdimm_region_delete(struct nd_region *nd_region)\n{\n\tif (nd_region)\n\t\tnd_device_unregister(&nd_region->dev, ND_SYNC);\n}\nEXPORT_SYMBOL_GPL(nvdimm_region_delete);\n\nint nvdimm_flush(struct nd_region *nd_region, struct bio *bio)\n{\n\tint rc = 0;\n\n\tif (!nd_region->flush)\n\t\trc = generic_nvdimm_flush(nd_region);\n\telse {\n\t\tif (nd_region->flush(nd_region, bio))\n\t\t\trc = -EIO;\n\t}\n\n\treturn rc;\n}\n \nint generic_nvdimm_flush(struct nd_region *nd_region)\n{\n\tstruct nd_region_data *ndrd = dev_get_drvdata(&nd_region->dev);\n\tint i, idx;\n\n\t \n\tidx = this_cpu_read(flush_idx);\n\tidx = this_cpu_add_return(flush_idx, hash_32(current->pid + idx, 8));\n\n\t \n\tpmem_wmb();\n\tfor (i = 0; i < nd_region->ndr_mappings; i++)\n\t\tif (ndrd_get_flush_wpq(ndrd, i, 0))\n\t\t\twriteq(1, ndrd_get_flush_wpq(ndrd, i, idx));\n\twmb();\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(nvdimm_flush);\n\n \nint nvdimm_has_flush(struct nd_region *nd_region)\n{\n\tint i;\n\n\t \n\tif (nd_region->ndr_mappings == 0\n\t\t\t|| !IS_ENABLED(CONFIG_ARCH_HAS_PMEM_API))\n\t\treturn -ENXIO;\n\n\t \n\tif (test_bit(ND_REGION_ASYNC, &nd_region->flags) && nd_region->flush)\n\t\treturn 1;\n\n\t \n\tfor (i = 0; i < nd_region->ndr_mappings; i++) {\n\t\tstruct nd_mapping *nd_mapping = &nd_region->mapping[i];\n\t\tstruct nvdimm *nvdimm = nd_mapping->nvdimm;\n\n\t\t \n\t\tif (nvdimm->num_flush)\n\t\t\treturn 1;\n\t}\n\n\t \n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(nvdimm_has_flush);\n\nint nvdimm_has_cache(struct nd_region *nd_region)\n{\n\treturn is_nd_pmem(&nd_region->dev) &&\n\t\t!test_bit(ND_REGION_PERSIST_CACHE, &nd_region->flags);\n}\nEXPORT_SYMBOL_GPL(nvdimm_has_cache);\n\nbool is_nvdimm_sync(struct nd_region *nd_region)\n{\n\tif (is_nd_volatile(&nd_region->dev))\n\t\treturn true;\n\n\treturn is_nd_pmem(&nd_region->dev) &&\n\t\t!test_bit(ND_REGION_ASYNC, &nd_region->flags);\n}\nEXPORT_SYMBOL_GPL(is_nvdimm_sync);\n\nstruct conflict_context {\n\tstruct nd_region *nd_region;\n\tresource_size_t start, size;\n};\n\nstatic int region_conflict(struct device *dev, void *data)\n{\n\tstruct nd_region *nd_region;\n\tstruct conflict_context *ctx = data;\n\tresource_size_t res_end, region_end, region_start;\n\n\tif (!is_memory(dev))\n\t\treturn 0;\n\n\tnd_region = to_nd_region(dev);\n\tif (nd_region == ctx->nd_region)\n\t\treturn 0;\n\n\tres_end = ctx->start + ctx->size;\n\tregion_start = nd_region->ndr_start;\n\tregion_end = region_start + nd_region->ndr_size;\n\tif (ctx->start >= region_start && ctx->start < region_end)\n\t\treturn -EBUSY;\n\tif (res_end > region_start && res_end <= region_end)\n\t\treturn -EBUSY;\n\treturn 0;\n}\n\nint nd_region_conflict(struct nd_region *nd_region, resource_size_t start,\n\t\tresource_size_t size)\n{\n\tstruct nvdimm_bus *nvdimm_bus = walk_to_nvdimm_bus(&nd_region->dev);\n\tstruct conflict_context ctx = {\n\t\t.nd_region = nd_region,\n\t\t.start = start,\n\t\t.size = size,\n\t};\n\n\treturn device_for_each_child(&nvdimm_bus->dev, &ctx, region_conflict);\n}\n\nMODULE_IMPORT_NS(DEVMEM);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}