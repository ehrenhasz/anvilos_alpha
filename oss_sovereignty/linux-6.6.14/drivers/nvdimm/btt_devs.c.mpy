{
  "module_name": "btt_devs.c",
  "hash_id": "82604435d4331223d77761adbc333ac86ee3d784d4efe9c762ea63c5551abd52",
  "original_prompt": "Ingested from linux-6.6.14/drivers/nvdimm/btt_devs.c",
  "human_readable_source": "\n \n#include <linux/blkdev.h>\n#include <linux/device.h>\n#include <linux/sizes.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include \"nd-core.h\"\n#include \"btt.h\"\n#include \"nd.h\"\n\nstatic void nd_btt_release(struct device *dev)\n{\n\tstruct nd_region *nd_region = to_nd_region(dev->parent);\n\tstruct nd_btt *nd_btt = to_nd_btt(dev);\n\n\tdev_dbg(dev, \"trace\\n\");\n\tnd_detach_ndns(&nd_btt->dev, &nd_btt->ndns);\n\tida_simple_remove(&nd_region->btt_ida, nd_btt->id);\n\tkfree(nd_btt->uuid);\n\tkfree(nd_btt);\n}\n\nstruct nd_btt *to_nd_btt(struct device *dev)\n{\n\tstruct nd_btt *nd_btt = container_of(dev, struct nd_btt, dev);\n\n\tWARN_ON(!is_nd_btt(dev));\n\treturn nd_btt;\n}\nEXPORT_SYMBOL(to_nd_btt);\n\nstatic const unsigned long btt_lbasize_supported[] = { 512, 520, 528,\n\t4096, 4104, 4160, 4224, 0 };\n\nstatic ssize_t sector_size_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct nd_btt *nd_btt = to_nd_btt(dev);\n\n\treturn nd_size_select_show(nd_btt->lbasize, btt_lbasize_supported, buf);\n}\n\nstatic ssize_t sector_size_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t len)\n{\n\tstruct nd_btt *nd_btt = to_nd_btt(dev);\n\tssize_t rc;\n\n\tdevice_lock(dev);\n\tnvdimm_bus_lock(dev);\n\trc = nd_size_select_store(dev, buf, &nd_btt->lbasize,\n\t\t\tbtt_lbasize_supported);\n\tdev_dbg(dev, \"result: %zd wrote: %s%s\", rc, buf,\n\t\t\tbuf[len - 1] == '\\n' ? \"\" : \"\\n\");\n\tnvdimm_bus_unlock(dev);\n\tdevice_unlock(dev);\n\n\treturn rc ? rc : len;\n}\nstatic DEVICE_ATTR_RW(sector_size);\n\nstatic ssize_t uuid_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct nd_btt *nd_btt = to_nd_btt(dev);\n\n\tif (nd_btt->uuid)\n\t\treturn sprintf(buf, \"%pUb\\n\", nd_btt->uuid);\n\treturn sprintf(buf, \"\\n\");\n}\n\nstatic ssize_t uuid_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t len)\n{\n\tstruct nd_btt *nd_btt = to_nd_btt(dev);\n\tssize_t rc;\n\n\tdevice_lock(dev);\n\trc = nd_uuid_store(dev, &nd_btt->uuid, buf, len);\n\tdev_dbg(dev, \"result: %zd wrote: %s%s\", rc, buf,\n\t\t\tbuf[len - 1] == '\\n' ? \"\" : \"\\n\");\n\tdevice_unlock(dev);\n\n\treturn rc ? rc : len;\n}\nstatic DEVICE_ATTR_RW(uuid);\n\nstatic ssize_t namespace_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct nd_btt *nd_btt = to_nd_btt(dev);\n\tssize_t rc;\n\n\tnvdimm_bus_lock(dev);\n\trc = sprintf(buf, \"%s\\n\", nd_btt->ndns\n\t\t\t? dev_name(&nd_btt->ndns->dev) : \"\");\n\tnvdimm_bus_unlock(dev);\n\treturn rc;\n}\n\nstatic ssize_t namespace_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t len)\n{\n\tstruct nd_btt *nd_btt = to_nd_btt(dev);\n\tssize_t rc;\n\n\tdevice_lock(dev);\n\tnvdimm_bus_lock(dev);\n\trc = nd_namespace_store(dev, &nd_btt->ndns, buf, len);\n\tdev_dbg(dev, \"result: %zd wrote: %s%s\", rc, buf,\n\t\t\tbuf[len - 1] == '\\n' ? \"\" : \"\\n\");\n\tnvdimm_bus_unlock(dev);\n\tdevice_unlock(dev);\n\n\treturn rc;\n}\nstatic DEVICE_ATTR_RW(namespace);\n\nstatic ssize_t size_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct nd_btt *nd_btt = to_nd_btt(dev);\n\tssize_t rc;\n\n\tdevice_lock(dev);\n\tif (dev->driver)\n\t\trc = sprintf(buf, \"%llu\\n\", nd_btt->size);\n\telse {\n\t\t \n\t\trc = -ENXIO;\n\t}\n\tdevice_unlock(dev);\n\n\treturn rc;\n}\nstatic DEVICE_ATTR_RO(size);\n\nstatic ssize_t log_zero_flags_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"Y\\n\");\n}\nstatic DEVICE_ATTR_RO(log_zero_flags);\n\nstatic struct attribute *nd_btt_attributes[] = {\n\t&dev_attr_sector_size.attr,\n\t&dev_attr_namespace.attr,\n\t&dev_attr_uuid.attr,\n\t&dev_attr_size.attr,\n\t&dev_attr_log_zero_flags.attr,\n\tNULL,\n};\n\nstatic struct attribute_group nd_btt_attribute_group = {\n\t.attrs = nd_btt_attributes,\n};\n\nstatic const struct attribute_group *nd_btt_attribute_groups[] = {\n\t&nd_btt_attribute_group,\n\t&nd_device_attribute_group,\n\t&nd_numa_attribute_group,\n\tNULL,\n};\n\nstatic const struct device_type nd_btt_device_type = {\n\t.name = \"nd_btt\",\n\t.release = nd_btt_release,\n\t.groups = nd_btt_attribute_groups,\n};\n\nbool is_nd_btt(struct device *dev)\n{\n\treturn dev->type == &nd_btt_device_type;\n}\nEXPORT_SYMBOL(is_nd_btt);\n\nstatic struct lock_class_key nvdimm_btt_key;\n\nstatic struct device *__nd_btt_create(struct nd_region *nd_region,\n\t\t\t\t      unsigned long lbasize, uuid_t *uuid,\n\t\t\t\t      struct nd_namespace_common *ndns)\n{\n\tstruct nd_btt *nd_btt;\n\tstruct device *dev;\n\n\tnd_btt = kzalloc(sizeof(*nd_btt), GFP_KERNEL);\n\tif (!nd_btt)\n\t\treturn NULL;\n\n\tnd_btt->id = ida_simple_get(&nd_region->btt_ida, 0, 0, GFP_KERNEL);\n\tif (nd_btt->id < 0)\n\t\tgoto out_nd_btt;\n\n\tnd_btt->lbasize = lbasize;\n\tif (uuid) {\n\t\tuuid = kmemdup(uuid, 16, GFP_KERNEL);\n\t\tif (!uuid)\n\t\t\tgoto out_put_id;\n\t}\n\tnd_btt->uuid = uuid;\n\tdev = &nd_btt->dev;\n\tdev_set_name(dev, \"btt%d.%d\", nd_region->id, nd_btt->id);\n\tdev->parent = &nd_region->dev;\n\tdev->type = &nd_btt_device_type;\n\tdevice_initialize(&nd_btt->dev);\n\tlockdep_set_class(&nd_btt->dev.mutex, &nvdimm_btt_key);\n\tif (ndns && !__nd_attach_ndns(&nd_btt->dev, ndns, &nd_btt->ndns)) {\n\t\tdev_dbg(&ndns->dev, \"failed, already claimed by %s\\n\",\n\t\t\t\tdev_name(ndns->claim));\n\t\tput_device(dev);\n\t\treturn NULL;\n\t}\n\treturn dev;\n\nout_put_id:\n\tida_simple_remove(&nd_region->btt_ida, nd_btt->id);\n\nout_nd_btt:\n\tkfree(nd_btt);\n\treturn NULL;\n}\n\nstruct device *nd_btt_create(struct nd_region *nd_region)\n{\n\tstruct device *dev = __nd_btt_create(nd_region, 0, NULL, NULL);\n\n\tnd_device_register(dev);\n\treturn dev;\n}\n\n \nbool nd_btt_arena_is_valid(struct nd_btt *nd_btt, struct btt_sb *super)\n{\n\tconst uuid_t *ns_uuid = nd_dev_to_uuid(&nd_btt->ndns->dev);\n\tuuid_t parent_uuid;\n\tu64 checksum;\n\n\tif (memcmp(super->signature, BTT_SIG, BTT_SIG_LEN) != 0)\n\t\treturn false;\n\n\timport_uuid(&parent_uuid, super->parent_uuid);\n\tif (!uuid_is_null(&parent_uuid))\n\t\tif (!uuid_equal(&parent_uuid, ns_uuid))\n\t\t\treturn false;\n\n\tchecksum = le64_to_cpu(super->checksum);\n\tsuper->checksum = 0;\n\tif (checksum != nd_sb_checksum((struct nd_gen_sb *) super))\n\t\treturn false;\n\tsuper->checksum = cpu_to_le64(checksum);\n\n\t \n\tif ((le32_to_cpu(super->flags) & IB_FLAG_ERROR_MASK) != 0)\n\t\tdev_info(&nd_btt->dev, \"Found arena with an error flag\\n\");\n\n\treturn true;\n}\nEXPORT_SYMBOL(nd_btt_arena_is_valid);\n\nint nd_btt_version(struct nd_btt *nd_btt, struct nd_namespace_common *ndns,\n\t\tstruct btt_sb *btt_sb)\n{\n\tif (ndns->claim_class == NVDIMM_CCLASS_BTT2) {\n\t\t \n\t\tnd_btt->initial_offset = 0;\n\t\tnd_btt->version_major = 2;\n\t\tnd_btt->version_minor = 0;\n\t\tif (nvdimm_read_bytes(ndns, 0, btt_sb, sizeof(*btt_sb), 0))\n\t\t\treturn -ENXIO;\n\t\tif (!nd_btt_arena_is_valid(nd_btt, btt_sb))\n\t\t\treturn -ENODEV;\n\t\tif ((le16_to_cpu(btt_sb->version_major) != 2) ||\n\t\t\t\t(le16_to_cpu(btt_sb->version_minor) != 0))\n\t\t\treturn -ENODEV;\n\t} else {\n\t\t \n\t\tnd_btt->initial_offset = SZ_4K;\n\t\tnd_btt->version_major = 1;\n\t\tnd_btt->version_minor = 1;\n\t\tif (nvdimm_read_bytes(ndns, SZ_4K, btt_sb, sizeof(*btt_sb), 0))\n\t\t\treturn -ENXIO;\n\t\tif (!nd_btt_arena_is_valid(nd_btt, btt_sb))\n\t\t\treturn -ENODEV;\n\t\tif ((le16_to_cpu(btt_sb->version_major) != 1) ||\n\t\t\t\t(le16_to_cpu(btt_sb->version_minor) != 1))\n\t\t\treturn -ENODEV;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL(nd_btt_version);\n\nstatic int __nd_btt_probe(struct nd_btt *nd_btt,\n\t\tstruct nd_namespace_common *ndns, struct btt_sb *btt_sb)\n{\n\tint rc;\n\n\tif (!btt_sb || !ndns || !nd_btt)\n\t\treturn -ENODEV;\n\n\tif (nvdimm_namespace_capacity(ndns) < SZ_16M)\n\t\treturn -ENXIO;\n\n\trc = nd_btt_version(nd_btt, ndns, btt_sb);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tnd_btt->lbasize = le32_to_cpu(btt_sb->external_lbasize);\n\tnd_btt->uuid = kmemdup(&btt_sb->uuid, sizeof(uuid_t), GFP_KERNEL);\n\tif (!nd_btt->uuid)\n\t\treturn -ENOMEM;\n\n\tnd_device_register(&nd_btt->dev);\n\n\treturn 0;\n}\n\nint nd_btt_probe(struct device *dev, struct nd_namespace_common *ndns)\n{\n\tint rc;\n\tstruct device *btt_dev;\n\tstruct btt_sb *btt_sb;\n\tstruct nd_region *nd_region = to_nd_region(ndns->dev.parent);\n\n\tif (ndns->force_raw)\n\t\treturn -ENODEV;\n\n\tswitch (ndns->claim_class) {\n\tcase NVDIMM_CCLASS_NONE:\n\tcase NVDIMM_CCLASS_BTT:\n\tcase NVDIMM_CCLASS_BTT2:\n\t\tbreak;\n\tdefault:\n\t\treturn -ENODEV;\n\t}\n\n\tnvdimm_bus_lock(&ndns->dev);\n\tbtt_dev = __nd_btt_create(nd_region, 0, NULL, ndns);\n\tnvdimm_bus_unlock(&ndns->dev);\n\tif (!btt_dev)\n\t\treturn -ENOMEM;\n\tbtt_sb = devm_kzalloc(dev, sizeof(*btt_sb), GFP_KERNEL);\n\trc = __nd_btt_probe(to_nd_btt(btt_dev), ndns, btt_sb);\n\tdev_dbg(dev, \"btt: %s\\n\", rc == 0 ? dev_name(btt_dev) : \"<none>\");\n\tif (rc < 0) {\n\t\tstruct nd_btt *nd_btt = to_nd_btt(btt_dev);\n\n\t\tnd_detach_ndns(btt_dev, &nd_btt->ndns);\n\t\tput_device(btt_dev);\n\t}\n\n\treturn rc;\n}\nEXPORT_SYMBOL(nd_btt_probe);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}