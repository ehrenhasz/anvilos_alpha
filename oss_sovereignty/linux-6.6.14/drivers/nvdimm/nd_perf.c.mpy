{
  "module_name": "nd_perf.c",
  "hash_id": "819eea66d7cb54dd9ae666a85eb1977cb441bd3767a4beac70596c415b0135ac",
  "original_prompt": "Ingested from linux-6.6.14/drivers/nvdimm/nd_perf.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"nvdimm_pmu: \" fmt\n\n#include <linux/nd.h>\n#include <linux/platform_device.h>\n\n#define EVENT(_name, _code)     enum{_name = _code}\n\n \n\n \nEVENT(CTL_RES_CNT,\t\t0x1);\n \nEVENT(CTL_RES_TM,\t\t0x2);\n \nEVENT(POWERON_SECS,\t\t0x3);\n \nEVENT(MEM_LIFE,\t\t0x4);\n \nEVENT(CRI_RES_UTIL,\t\t0x5);\n \nEVENT(HOST_L_CNT,\t\t0x6);\n \nEVENT(HOST_S_CNT,\t\t0x7);\n \nEVENT(HOST_S_DUR,\t\t0x8);\n \nEVENT(HOST_L_DUR,\t\t0x9);\n \nEVENT(MED_R_CNT,\t\t0xa);\n \nEVENT(MED_W_CNT,\t\t0xb);\n \nEVENT(MED_R_DUR,\t\t0xc);\n \nEVENT(MED_W_DUR,\t\t0xd);\n \nEVENT(CACHE_RH_CNT,\t\t0xe);\n \nEVENT(CACHE_WH_CNT,\t\t0xf);\n \nEVENT(FAST_W_CNT,\t\t0x10);\n\nNVDIMM_EVENT_ATTR(ctl_res_cnt,\t\tCTL_RES_CNT);\nNVDIMM_EVENT_ATTR(ctl_res_tm,\t\tCTL_RES_TM);\nNVDIMM_EVENT_ATTR(poweron_secs,\t\tPOWERON_SECS);\nNVDIMM_EVENT_ATTR(mem_life,\t\tMEM_LIFE);\nNVDIMM_EVENT_ATTR(cri_res_util,\t\tCRI_RES_UTIL);\nNVDIMM_EVENT_ATTR(host_l_cnt,\t\tHOST_L_CNT);\nNVDIMM_EVENT_ATTR(host_s_cnt,\t\tHOST_S_CNT);\nNVDIMM_EVENT_ATTR(host_s_dur,\t\tHOST_S_DUR);\nNVDIMM_EVENT_ATTR(host_l_dur,\t\tHOST_L_DUR);\nNVDIMM_EVENT_ATTR(med_r_cnt,\t\tMED_R_CNT);\nNVDIMM_EVENT_ATTR(med_w_cnt,\t\tMED_W_CNT);\nNVDIMM_EVENT_ATTR(med_r_dur,\t\tMED_R_DUR);\nNVDIMM_EVENT_ATTR(med_w_dur,\t\tMED_W_DUR);\nNVDIMM_EVENT_ATTR(cache_rh_cnt,\t\tCACHE_RH_CNT);\nNVDIMM_EVENT_ATTR(cache_wh_cnt,\t\tCACHE_WH_CNT);\nNVDIMM_EVENT_ATTR(fast_w_cnt,\t\tFAST_W_CNT);\n\nstatic struct attribute *nvdimm_events_attr[] = {\n\tNVDIMM_EVENT_PTR(CTL_RES_CNT),\n\tNVDIMM_EVENT_PTR(CTL_RES_TM),\n\tNVDIMM_EVENT_PTR(POWERON_SECS),\n\tNVDIMM_EVENT_PTR(MEM_LIFE),\n\tNVDIMM_EVENT_PTR(CRI_RES_UTIL),\n\tNVDIMM_EVENT_PTR(HOST_L_CNT),\n\tNVDIMM_EVENT_PTR(HOST_S_CNT),\n\tNVDIMM_EVENT_PTR(HOST_S_DUR),\n\tNVDIMM_EVENT_PTR(HOST_L_DUR),\n\tNVDIMM_EVENT_PTR(MED_R_CNT),\n\tNVDIMM_EVENT_PTR(MED_W_CNT),\n\tNVDIMM_EVENT_PTR(MED_R_DUR),\n\tNVDIMM_EVENT_PTR(MED_W_DUR),\n\tNVDIMM_EVENT_PTR(CACHE_RH_CNT),\n\tNVDIMM_EVENT_PTR(CACHE_WH_CNT),\n\tNVDIMM_EVENT_PTR(FAST_W_CNT),\n\tNULL\n};\n\nstatic struct attribute_group nvdimm_pmu_events_group = {\n\t.name = \"events\",\n\t.attrs = nvdimm_events_attr,\n};\n\nPMU_FORMAT_ATTR(event, \"config:0-4\");\n\nstatic struct attribute *nvdimm_pmu_format_attr[] = {\n\t&format_attr_event.attr,\n\tNULL,\n};\n\nstatic struct attribute_group nvdimm_pmu_format_group = {\n\t.name = \"format\",\n\t.attrs = nvdimm_pmu_format_attr,\n};\n\nssize_t nvdimm_events_sysfs_show(struct device *dev,\n\t\t\t\t struct device_attribute *attr, char *page)\n{\n\tstruct perf_pmu_events_attr *pmu_attr;\n\n\tpmu_attr = container_of(attr, struct perf_pmu_events_attr, attr);\n\n\treturn sprintf(page, \"event=0x%02llx\\n\", pmu_attr->id);\n}\n\nstatic ssize_t nvdimm_pmu_cpumask_show(struct device *dev,\n\t\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tstruct pmu *pmu = dev_get_drvdata(dev);\n\tstruct nvdimm_pmu *nd_pmu;\n\n\tnd_pmu = container_of(pmu, struct nvdimm_pmu, pmu);\n\n\treturn cpumap_print_to_pagebuf(true, buf, cpumask_of(nd_pmu->cpu));\n}\n\nstatic int nvdimm_pmu_cpu_offline(unsigned int cpu, struct hlist_node *node)\n{\n\tstruct nvdimm_pmu *nd_pmu;\n\tu32 target;\n\tint nodeid;\n\tconst struct cpumask *cpumask;\n\n\tnd_pmu = hlist_entry_safe(node, struct nvdimm_pmu, node);\n\n\t \n\tcpumask_test_and_clear_cpu(cpu, &nd_pmu->arch_cpumask);\n\n\t \n\tif (cpu != nd_pmu->cpu)\n\t\treturn 0;\n\n\t \n\ttarget = cpumask_any(&nd_pmu->arch_cpumask);\n\n\t \n\tif (target >= nr_cpu_ids) {\n\t\tnodeid = cpu_to_node(cpu);\n\t\tcpumask = cpumask_of_node(nodeid);\n\t\ttarget = cpumask_any_but(cpumask, cpu);\n\t}\n\tnd_pmu->cpu = target;\n\n\t \n\tif (target >= 0 && target < nr_cpu_ids)\n\t\tperf_pmu_migrate_context(&nd_pmu->pmu, cpu, target);\n\n\treturn 0;\n}\n\nstatic int nvdimm_pmu_cpu_online(unsigned int cpu, struct hlist_node *node)\n{\n\tstruct nvdimm_pmu *nd_pmu;\n\n\tnd_pmu = hlist_entry_safe(node, struct nvdimm_pmu, node);\n\n\tif (nd_pmu->cpu >= nr_cpu_ids)\n\t\tnd_pmu->cpu = cpu;\n\n\treturn 0;\n}\n\nstatic int create_cpumask_attr_group(struct nvdimm_pmu *nd_pmu)\n{\n\tstruct perf_pmu_events_attr *pmu_events_attr;\n\tstruct attribute **attrs_group;\n\tstruct attribute_group *nvdimm_pmu_cpumask_group;\n\n\tpmu_events_attr = kzalloc(sizeof(*pmu_events_attr), GFP_KERNEL);\n\tif (!pmu_events_attr)\n\t\treturn -ENOMEM;\n\n\tattrs_group = kzalloc(2 * sizeof(struct attribute *), GFP_KERNEL);\n\tif (!attrs_group) {\n\t\tkfree(pmu_events_attr);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tnvdimm_pmu_cpumask_group = kzalloc(sizeof(*nvdimm_pmu_cpumask_group), GFP_KERNEL);\n\tif (!nvdimm_pmu_cpumask_group) {\n\t\tkfree(pmu_events_attr);\n\t\tkfree(attrs_group);\n\t\treturn -ENOMEM;\n\t}\n\n\tsysfs_attr_init(&pmu_events_attr->attr.attr);\n\tpmu_events_attr->attr.attr.name = \"cpumask\";\n\tpmu_events_attr->attr.attr.mode = 0444;\n\tpmu_events_attr->attr.show = nvdimm_pmu_cpumask_show;\n\tattrs_group[0] = &pmu_events_attr->attr.attr;\n\tattrs_group[1] = NULL;\n\n\tnvdimm_pmu_cpumask_group->attrs = attrs_group;\n\tnd_pmu->pmu.attr_groups[NVDIMM_PMU_CPUMASK_ATTR] = nvdimm_pmu_cpumask_group;\n\treturn 0;\n}\n\nstatic int nvdimm_pmu_cpu_hotplug_init(struct nvdimm_pmu *nd_pmu)\n{\n\tint nodeid, rc;\n\tconst struct cpumask *cpumask;\n\n\t \n\tif (!cpumask_empty(&nd_pmu->arch_cpumask)) {\n\t\tnd_pmu->cpu = cpumask_any(&nd_pmu->arch_cpumask);\n\t} else {\n\t\t \n\t\tnodeid = dev_to_node(nd_pmu->dev);\n\t\tcpumask = cpumask_of_node(nodeid);\n\t\tnd_pmu->cpu = cpumask_any(cpumask);\n\t}\n\n\trc = cpuhp_setup_state_multi(CPUHP_AP_ONLINE_DYN, \"perf/nvdimm:online\",\n\t\t\t\t     nvdimm_pmu_cpu_online, nvdimm_pmu_cpu_offline);\n\n\tif (rc < 0)\n\t\treturn rc;\n\n\tnd_pmu->cpuhp_state = rc;\n\n\t \n\trc = cpuhp_state_add_instance_nocalls(nd_pmu->cpuhp_state, &nd_pmu->node);\n\tif (rc) {\n\t\tcpuhp_remove_multi_state(nd_pmu->cpuhp_state);\n\t\treturn rc;\n\t}\n\n\t \n\trc = create_cpumask_attr_group(nd_pmu);\n\tif (rc) {\n\t\tcpuhp_state_remove_instance_nocalls(nd_pmu->cpuhp_state, &nd_pmu->node);\n\t\tcpuhp_remove_multi_state(nd_pmu->cpuhp_state);\n\t\treturn rc;\n\t}\n\n\treturn 0;\n}\n\nstatic void nvdimm_pmu_free_hotplug_memory(struct nvdimm_pmu *nd_pmu)\n{\n\tcpuhp_state_remove_instance_nocalls(nd_pmu->cpuhp_state, &nd_pmu->node);\n\tcpuhp_remove_multi_state(nd_pmu->cpuhp_state);\n\n\tif (nd_pmu->pmu.attr_groups[NVDIMM_PMU_CPUMASK_ATTR])\n\t\tkfree(nd_pmu->pmu.attr_groups[NVDIMM_PMU_CPUMASK_ATTR]->attrs);\n\tkfree(nd_pmu->pmu.attr_groups[NVDIMM_PMU_CPUMASK_ATTR]);\n}\n\nint register_nvdimm_pmu(struct nvdimm_pmu *nd_pmu, struct platform_device *pdev)\n{\n\tint rc;\n\n\tif (!nd_pmu || !pdev)\n\t\treturn -EINVAL;\n\n\t \n\tif (WARN_ON_ONCE(!(nd_pmu->pmu.event_init && nd_pmu->pmu.add &&\n\t\t\t   nd_pmu->pmu.del && nd_pmu->pmu.read && nd_pmu->pmu.name)))\n\t\treturn -EINVAL;\n\n\tnd_pmu->pmu.attr_groups = kzalloc((NVDIMM_PMU_NULL_ATTR + 1) *\n\t\t\t\t\t  sizeof(struct attribute_group *), GFP_KERNEL);\n\tif (!nd_pmu->pmu.attr_groups)\n\t\treturn -ENOMEM;\n\n\t \n\tnd_pmu->dev = &pdev->dev;\n\n\t \n\tnd_pmu->pmu.attr_groups[NVDIMM_PMU_FORMAT_ATTR] = &nvdimm_pmu_format_group;\n\tnd_pmu->pmu.attr_groups[NVDIMM_PMU_EVENT_ATTR] = &nvdimm_pmu_events_group;\n\tnd_pmu->pmu.attr_groups[NVDIMM_PMU_NULL_ATTR] = NULL;\n\n\t \n\trc = nvdimm_pmu_cpu_hotplug_init(nd_pmu);\n\tif (rc) {\n\t\tpr_info(\"cpu hotplug feature failed for device: %s\\n\", nd_pmu->pmu.name);\n\t\tkfree(nd_pmu->pmu.attr_groups);\n\t\treturn rc;\n\t}\n\n\trc = perf_pmu_register(&nd_pmu->pmu, nd_pmu->pmu.name, -1);\n\tif (rc) {\n\t\tnvdimm_pmu_free_hotplug_memory(nd_pmu);\n\t\tkfree(nd_pmu->pmu.attr_groups);\n\t\treturn rc;\n\t}\n\n\tpr_info(\"%s NVDIMM performance monitor support registered\\n\",\n\t\tnd_pmu->pmu.name);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(register_nvdimm_pmu);\n\nvoid unregister_nvdimm_pmu(struct nvdimm_pmu *nd_pmu)\n{\n\tperf_pmu_unregister(&nd_pmu->pmu);\n\tnvdimm_pmu_free_hotplug_memory(nd_pmu);\n\tkfree(nd_pmu->pmu.attr_groups);\n\tkfree(nd_pmu);\n}\nEXPORT_SYMBOL_GPL(unregister_nvdimm_pmu);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}