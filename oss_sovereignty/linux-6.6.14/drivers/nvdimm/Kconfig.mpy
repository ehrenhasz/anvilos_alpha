{
  "module_name": "Kconfig",
  "hash_id": "413f46f08c22fc0b46d90a0a86c9fe5cfee42a588485483a60ed6303e3c3e604",
  "original_prompt": "Ingested from linux-6.6.14/drivers/nvdimm/Kconfig",
  "human_readable_source": "# SPDX-License-Identifier: GPL-2.0-only\nmenuconfig LIBNVDIMM\n\ttristate \"NVDIMM (Non-Volatile Memory Device) Support\"\n\tdepends on PHYS_ADDR_T_64BIT\n\tdepends on HAS_IOMEM\n\tdepends on BLK_DEV\n\tselect MEMREGION\n\thelp\n\t  Generic support for non-volatile memory devices including\n\t  ACPI-6-NFIT defined resources.  On platforms that define an\n\t  NFIT, or otherwise can discover NVDIMM resources, a libnvdimm\n\t  bus is registered to advertise PMEM (persistent memory)\n\t  namespaces (/dev/pmemX). A PMEM namespace refers to a\n\t  memory resource that may span multiple DIMMs and support DAX\n\t  (see CONFIG_DAX).\n\nif LIBNVDIMM\n\nconfig BLK_DEV_PMEM\n\ttristate \"PMEM: Persistent memory block device support\"\n\tdefault LIBNVDIMM\n\tselect DAX\n\tselect ND_BTT if BTT\n\tselect ND_PFN if NVDIMM_PFN\n\thelp\n\t  Memory ranges for PMEM are described by either an NFIT\n\t  (NVDIMM Firmware Interface Table, see CONFIG_NFIT_ACPI), a\n\t  non-standard OEM-specific E820 memory type (type-12, see\n\t  CONFIG_X86_PMEM_LEGACY), or it is manually specified by the\n\t  'memmap=nn[KMG]!ss[KMG]' kernel command line (see\n\t  Documentation/admin-guide/kernel-parameters.rst).  This driver converts\n\t  these persistent memory ranges into block devices that are\n\t  capable of DAX (direct-access) file system mappings.  See\n\t  Documentation/driver-api/nvdimm/nvdimm.rst for more details.\n\n\t  Say Y if you want to use an NVDIMM\n\nconfig ND_CLAIM\n\tbool\n\nconfig ND_BTT\n\ttristate\n\nconfig BTT\n\tbool \"BTT: Block Translation Table (atomic sector updates)\"\n\tdefault y if LIBNVDIMM\n\tselect ND_CLAIM\n\thelp\n\t  The Block Translation Table (BTT) provides atomic sector\n\t  update semantics for persistent memory devices, so that\n\t  applications that rely on sector writes not being torn (a\n\t  guarantee that typical disks provide) can continue to do so.\n\t  The BTT manifests itself as an alternate personality for an\n\t  NVDIMM namespace, i.e. a namespace can be in raw mode pmemX,\n\t  or 'sectored' mode.\n\n\t  Select Y if unsure\n\nconfig ND_PFN\n\ttristate\n\nconfig NVDIMM_PFN\n\tbool \"PFN: Map persistent (device) memory\"\n\tdefault LIBNVDIMM\n\tdepends on ZONE_DEVICE\n\tselect ND_CLAIM\n\thelp\n\t  Map persistent memory, i.e. advertise it to the memory\n\t  management sub-system.  By default persistent memory does\n\t  not support direct I/O, RDMA, or any other usage that\n\t  requires a 'struct page' to mediate an I/O request.  This\n\t  driver allocates and initializes the infrastructure needed\n\t  to support those use cases.\n\n\t  Select Y if unsure\n\nconfig NVDIMM_DAX\n\tbool \"NVDIMM DAX: Raw access to persistent memory\"\n\tdefault LIBNVDIMM\n\tdepends on NVDIMM_PFN\n\thelp\n\t  Support raw device dax access to a persistent memory\n\t  namespace.  For environments that want to hard partition\n\t  persistent memory, this capability provides a mechanism to\n\t  sub-divide a namespace into character devices that can only be\n\t  accessed via DAX (mmap(2)).\n\n\t  Select Y if unsure\n\nconfig OF_PMEM\n\ttristate \"Device-tree support for persistent memory regions\"\n\tdepends on OF\n\tdefault LIBNVDIMM\n\thelp\n\t  Allows regions of persistent memory to be described in the\n\t  device-tree.\n\n\t  Select Y if unsure.\n\nconfig NVDIMM_KEYS\n\tdef_bool y\n\tdepends on ENCRYPTED_KEYS\n\tdepends on (LIBNVDIMM=ENCRYPTED_KEYS) || LIBNVDIMM=m\n\nconfig NVDIMM_KMSAN\n\tbool\n\tdepends on KMSAN\n\thelp\n\t  KMSAN, and other memory debug facilities, increase the size of\n\t  'struct page' to contain extra metadata. This collides with\n\t  the NVDIMM capability to store a potentially\n\t  larger-than-\"System RAM\" size 'struct page' array in a\n\t  reservation of persistent memory rather than limited /\n\t  precious DRAM. However, that reservation needs to persist for\n\t  the life of the given NVDIMM namespace. If you are using KMSAN\n\t  to debug an issue unrelated to NVDIMMs or DAX then say N to this\n\t  option. Otherwise, say Y but understand that any namespaces\n\t  (with the page array stored pmem) created with this build of\n\t  the kernel will permanently reserve and strand excess\n\t  capacity compared to the CONFIG_KMSAN=n case.\n\n\t  Select N if unsure.\n\nconfig NVDIMM_TEST_BUILD\n\ttristate \"Build the unit test core\"\n\tdepends on m\n\tdepends on COMPILE_TEST && X86_64\n\tdefault m if COMPILE_TEST\n\thelp\n\t  Build the core of the unit test infrastructure. The result of\n\t  this build is non-functional for unit test execution, but it\n\t  otherwise helps catch build errors induced by changes to the\n\t  core devm_memremap_pages() implementation and other\n\t  infrastructure.\n\nconfig NVDIMM_SECURITY_TEST\n\tbool \"Enable NVDIMM security unit tests\"\n\tdepends on NVDIMM_KEYS\n\thelp\n\t  The NVDIMM and CXL subsystems support unit testing of their device\n\t  security state machines. The NVDIMM_SECURITY_TEST option disables CPU\n\t  cache maintenance operations around events like secure erase and\n\t  overwrite.  Also, when enabled, the NVDIMM subsystem core helps the unit\n\t  test implement a mock state machine.\n\n\t  Select N if unsure.\n\nendif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}