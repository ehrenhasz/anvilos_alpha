{
  "module_name": "core.c",
  "hash_id": "3ba272f0d35dbdde8fecf232b798a326fc563c50690e92a19fafcf08c8c9c675",
  "original_prompt": "Ingested from linux-6.6.14/drivers/nvdimm/core.c",
  "human_readable_source": "\n \n#include <linux/libnvdimm.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/blk-integrity.h>\n#include <linux/device.h>\n#include <linux/ctype.h>\n#include <linux/ndctl.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include \"nd-core.h\"\n#include \"nd.h\"\n\nLIST_HEAD(nvdimm_bus_list);\nDEFINE_MUTEX(nvdimm_bus_list_mutex);\n\nvoid nvdimm_bus_lock(struct device *dev)\n{\n\tstruct nvdimm_bus *nvdimm_bus = walk_to_nvdimm_bus(dev);\n\n\tif (!nvdimm_bus)\n\t\treturn;\n\tmutex_lock(&nvdimm_bus->reconfig_mutex);\n}\nEXPORT_SYMBOL(nvdimm_bus_lock);\n\nvoid nvdimm_bus_unlock(struct device *dev)\n{\n\tstruct nvdimm_bus *nvdimm_bus = walk_to_nvdimm_bus(dev);\n\n\tif (!nvdimm_bus)\n\t\treturn;\n\tmutex_unlock(&nvdimm_bus->reconfig_mutex);\n}\nEXPORT_SYMBOL(nvdimm_bus_unlock);\n\nbool is_nvdimm_bus_locked(struct device *dev)\n{\n\tstruct nvdimm_bus *nvdimm_bus = walk_to_nvdimm_bus(dev);\n\n\tif (!nvdimm_bus)\n\t\treturn false;\n\treturn mutex_is_locked(&nvdimm_bus->reconfig_mutex);\n}\nEXPORT_SYMBOL(is_nvdimm_bus_locked);\n\nstruct nvdimm_map {\n\tstruct nvdimm_bus *nvdimm_bus;\n\tstruct list_head list;\n\tresource_size_t offset;\n\tunsigned long flags;\n\tsize_t size;\n\tunion {\n\t\tvoid *mem;\n\t\tvoid __iomem *iomem;\n\t};\n\tstruct kref kref;\n};\n\nstatic struct nvdimm_map *find_nvdimm_map(struct device *dev,\n\t\tresource_size_t offset)\n{\n\tstruct nvdimm_bus *nvdimm_bus = walk_to_nvdimm_bus(dev);\n\tstruct nvdimm_map *nvdimm_map;\n\n\tlist_for_each_entry(nvdimm_map, &nvdimm_bus->mapping_list, list)\n\t\tif (nvdimm_map->offset == offset)\n\t\t\treturn nvdimm_map;\n\treturn NULL;\n}\n\nstatic struct nvdimm_map *alloc_nvdimm_map(struct device *dev,\n\t\tresource_size_t offset, size_t size, unsigned long flags)\n{\n\tstruct nvdimm_bus *nvdimm_bus = walk_to_nvdimm_bus(dev);\n\tstruct nvdimm_map *nvdimm_map;\n\n\tnvdimm_map = kzalloc(sizeof(*nvdimm_map), GFP_KERNEL);\n\tif (!nvdimm_map)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&nvdimm_map->list);\n\tnvdimm_map->nvdimm_bus = nvdimm_bus;\n\tnvdimm_map->offset = offset;\n\tnvdimm_map->flags = flags;\n\tnvdimm_map->size = size;\n\tkref_init(&nvdimm_map->kref);\n\n\tif (!request_mem_region(offset, size, dev_name(&nvdimm_bus->dev))) {\n\t\tdev_err(&nvdimm_bus->dev, \"failed to request %pa + %zd for %s\\n\",\n\t\t\t\t&offset, size, dev_name(dev));\n\t\tgoto err_request_region;\n\t}\n\n\tif (flags)\n\t\tnvdimm_map->mem = memremap(offset, size, flags);\n\telse\n\t\tnvdimm_map->iomem = ioremap(offset, size);\n\n\tif (!nvdimm_map->mem)\n\t\tgoto err_map;\n\n\tdev_WARN_ONCE(dev, !is_nvdimm_bus_locked(dev), \"%s: bus unlocked!\",\n\t\t\t__func__);\n\tlist_add(&nvdimm_map->list, &nvdimm_bus->mapping_list);\n\n\treturn nvdimm_map;\n\n err_map:\n\trelease_mem_region(offset, size);\n err_request_region:\n\tkfree(nvdimm_map);\n\treturn NULL;\n}\n\nstatic void nvdimm_map_release(struct kref *kref)\n{\n\tstruct nvdimm_bus *nvdimm_bus;\n\tstruct nvdimm_map *nvdimm_map;\n\n\tnvdimm_map = container_of(kref, struct nvdimm_map, kref);\n\tnvdimm_bus = nvdimm_map->nvdimm_bus;\n\n\tdev_dbg(&nvdimm_bus->dev, \"%pa\\n\", &nvdimm_map->offset);\n\tlist_del(&nvdimm_map->list);\n\tif (nvdimm_map->flags)\n\t\tmemunmap(nvdimm_map->mem);\n\telse\n\t\tiounmap(nvdimm_map->iomem);\n\trelease_mem_region(nvdimm_map->offset, nvdimm_map->size);\n\tkfree(nvdimm_map);\n}\n\nstatic void nvdimm_map_put(void *data)\n{\n\tstruct nvdimm_map *nvdimm_map = data;\n\tstruct nvdimm_bus *nvdimm_bus = nvdimm_map->nvdimm_bus;\n\n\tnvdimm_bus_lock(&nvdimm_bus->dev);\n\tkref_put(&nvdimm_map->kref, nvdimm_map_release);\n\tnvdimm_bus_unlock(&nvdimm_bus->dev);\n}\n\n \nvoid *devm_nvdimm_memremap(struct device *dev, resource_size_t offset,\n\t\tsize_t size, unsigned long flags)\n{\n\tstruct nvdimm_map *nvdimm_map;\n\n\tnvdimm_bus_lock(dev);\n\tnvdimm_map = find_nvdimm_map(dev, offset);\n\tif (!nvdimm_map)\n\t\tnvdimm_map = alloc_nvdimm_map(dev, offset, size, flags);\n\telse\n\t\tkref_get(&nvdimm_map->kref);\n\tnvdimm_bus_unlock(dev);\n\n\tif (!nvdimm_map)\n\t\treturn NULL;\n\n\tif (devm_add_action_or_reset(dev, nvdimm_map_put, nvdimm_map))\n\t\treturn NULL;\n\n\treturn nvdimm_map->mem;\n}\nEXPORT_SYMBOL_GPL(devm_nvdimm_memremap);\n\nu64 nd_fletcher64(void *addr, size_t len, bool le)\n{\n\tu32 *buf = addr;\n\tu32 lo32 = 0;\n\tu64 hi32 = 0;\n\tint i;\n\n\tfor (i = 0; i < len / sizeof(u32); i++) {\n\t\tlo32 += le ? le32_to_cpu((__le32) buf[i]) : buf[i];\n\t\thi32 += lo32;\n\t}\n\n\treturn hi32 << 32 | lo32;\n}\nEXPORT_SYMBOL_GPL(nd_fletcher64);\n\nstruct nvdimm_bus_descriptor *to_nd_desc(struct nvdimm_bus *nvdimm_bus)\n{\n\t \n\treturn nvdimm_bus->nd_desc;\n}\nEXPORT_SYMBOL_GPL(to_nd_desc);\n\nstruct device *to_nvdimm_bus_dev(struct nvdimm_bus *nvdimm_bus)\n{\n\t \n\treturn &nvdimm_bus->dev;\n}\nEXPORT_SYMBOL_GPL(to_nvdimm_bus_dev);\n\n \nint nd_uuid_store(struct device *dev, uuid_t **uuid_out, const char *buf,\n\t\tsize_t len)\n{\n\tuuid_t uuid;\n\tint rc;\n\n\tif (dev->driver)\n\t\treturn -EBUSY;\n\n\trc = uuid_parse(buf, &uuid);\n\tif (rc)\n\t\treturn rc;\n\n\tkfree(*uuid_out);\n\t*uuid_out = kmemdup(&uuid, sizeof(uuid), GFP_KERNEL);\n\tif (!(*uuid_out))\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nssize_t nd_size_select_show(unsigned long current_size,\n\t\tconst unsigned long *supported, char *buf)\n{\n\tssize_t len = 0;\n\tint i;\n\n\tfor (i = 0; supported[i]; i++)\n\t\tif (current_size == supported[i])\n\t\t\tlen += sprintf(buf + len, \"[%ld] \", supported[i]);\n\t\telse\n\t\t\tlen += sprintf(buf + len, \"%ld \", supported[i]);\n\tlen += sprintf(buf + len, \"\\n\");\n\treturn len;\n}\n\nssize_t nd_size_select_store(struct device *dev, const char *buf,\n\t\tunsigned long *current_size, const unsigned long *supported)\n{\n\tunsigned long lbasize;\n\tint rc, i;\n\n\tif (dev->driver)\n\t\treturn -EBUSY;\n\n\trc = kstrtoul(buf, 0, &lbasize);\n\tif (rc)\n\t\treturn rc;\n\n\tfor (i = 0; supported[i]; i++)\n\t\tif (lbasize == supported[i])\n\t\t\tbreak;\n\n\tif (supported[i]) {\n\t\t*current_size = lbasize;\n\t\treturn 0;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic ssize_t commands_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tint cmd, len = 0;\n\tstruct nvdimm_bus *nvdimm_bus = to_nvdimm_bus(dev);\n\tstruct nvdimm_bus_descriptor *nd_desc = nvdimm_bus->nd_desc;\n\n\tfor_each_set_bit(cmd, &nd_desc->cmd_mask, BITS_PER_LONG)\n\t\tlen += sprintf(buf + len, \"%s \", nvdimm_bus_cmd_name(cmd));\n\tlen += sprintf(buf + len, \"\\n\");\n\treturn len;\n}\nstatic DEVICE_ATTR_RO(commands);\n\nstatic const char *nvdimm_bus_provider(struct nvdimm_bus *nvdimm_bus)\n{\n\tstruct nvdimm_bus_descriptor *nd_desc = nvdimm_bus->nd_desc;\n\tstruct device *parent = nvdimm_bus->dev.parent;\n\n\tif (nd_desc->provider_name)\n\t\treturn nd_desc->provider_name;\n\telse if (parent)\n\t\treturn dev_name(parent);\n\telse\n\t\treturn \"unknown\";\n}\n\nstatic ssize_t provider_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct nvdimm_bus *nvdimm_bus = to_nvdimm_bus(dev);\n\n\treturn sprintf(buf, \"%s\\n\", nvdimm_bus_provider(nvdimm_bus));\n}\nstatic DEVICE_ATTR_RO(provider);\n\nstatic int flush_namespaces(struct device *dev, void *data)\n{\n\tdevice_lock(dev);\n\tdevice_unlock(dev);\n\treturn 0;\n}\n\nstatic int flush_regions_dimms(struct device *dev, void *data)\n{\n\tdevice_lock(dev);\n\tdevice_unlock(dev);\n\tdevice_for_each_child(dev, NULL, flush_namespaces);\n\treturn 0;\n}\n\nstatic ssize_t wait_probe_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct nvdimm_bus *nvdimm_bus = to_nvdimm_bus(dev);\n\tstruct nvdimm_bus_descriptor *nd_desc = nvdimm_bus->nd_desc;\n\tint rc;\n\n\tif (nd_desc->flush_probe) {\n\t\trc = nd_desc->flush_probe(nd_desc);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\tnd_synchronize();\n\tdevice_for_each_child(dev, NULL, flush_regions_dimms);\n\treturn sprintf(buf, \"1\\n\");\n}\nstatic DEVICE_ATTR_RO(wait_probe);\n\nstatic struct attribute *nvdimm_bus_attributes[] = {\n\t&dev_attr_commands.attr,\n\t&dev_attr_wait_probe.attr,\n\t&dev_attr_provider.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group nvdimm_bus_attribute_group = {\n\t.attrs = nvdimm_bus_attributes,\n};\n\nstatic ssize_t capability_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct nvdimm_bus *nvdimm_bus = to_nvdimm_bus(dev);\n\tstruct nvdimm_bus_descriptor *nd_desc = nvdimm_bus->nd_desc;\n\tenum nvdimm_fwa_capability cap;\n\n\tif (!nd_desc->fw_ops)\n\t\treturn -EOPNOTSUPP;\n\n\tcap = nd_desc->fw_ops->capability(nd_desc);\n\n\tswitch (cap) {\n\tcase NVDIMM_FWA_CAP_QUIESCE:\n\t\treturn sprintf(buf, \"quiesce\\n\");\n\tcase NVDIMM_FWA_CAP_LIVE:\n\t\treturn sprintf(buf, \"live\\n\");\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic DEVICE_ATTR_RO(capability);\n\nstatic ssize_t activate_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct nvdimm_bus *nvdimm_bus = to_nvdimm_bus(dev);\n\tstruct nvdimm_bus_descriptor *nd_desc = nvdimm_bus->nd_desc;\n\tenum nvdimm_fwa_capability cap;\n\tenum nvdimm_fwa_state state;\n\n\tif (!nd_desc->fw_ops)\n\t\treturn -EOPNOTSUPP;\n\n\tcap = nd_desc->fw_ops->capability(nd_desc);\n\tstate = nd_desc->fw_ops->activate_state(nd_desc);\n\n\tif (cap < NVDIMM_FWA_CAP_QUIESCE)\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (state) {\n\tcase NVDIMM_FWA_IDLE:\n\t\treturn sprintf(buf, \"idle\\n\");\n\tcase NVDIMM_FWA_BUSY:\n\t\treturn sprintf(buf, \"busy\\n\");\n\tcase NVDIMM_FWA_ARMED:\n\t\treturn sprintf(buf, \"armed\\n\");\n\tcase NVDIMM_FWA_ARM_OVERFLOW:\n\t\treturn sprintf(buf, \"overflow\\n\");\n\tdefault:\n\t\treturn -ENXIO;\n\t}\n}\n\nstatic int exec_firmware_activate(void *data)\n{\n\tstruct nvdimm_bus_descriptor *nd_desc = data;\n\n\treturn nd_desc->fw_ops->activate(nd_desc);\n}\n\nstatic ssize_t activate_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t len)\n{\n\tstruct nvdimm_bus *nvdimm_bus = to_nvdimm_bus(dev);\n\tstruct nvdimm_bus_descriptor *nd_desc = nvdimm_bus->nd_desc;\n\tenum nvdimm_fwa_state state;\n\tbool quiesce;\n\tssize_t rc;\n\n\tif (!nd_desc->fw_ops)\n\t\treturn -EOPNOTSUPP;\n\n\tif (sysfs_streq(buf, \"live\"))\n\t\tquiesce = false;\n\telse if (sysfs_streq(buf, \"quiesce\"))\n\t\tquiesce = true;\n\telse\n\t\treturn -EINVAL;\n\n\tstate = nd_desc->fw_ops->activate_state(nd_desc);\n\n\tswitch (state) {\n\tcase NVDIMM_FWA_BUSY:\n\t\trc = -EBUSY;\n\t\tbreak;\n\tcase NVDIMM_FWA_ARMED:\n\tcase NVDIMM_FWA_ARM_OVERFLOW:\n\t\tif (quiesce)\n\t\t\trc = hibernate_quiet_exec(exec_firmware_activate, nd_desc);\n\t\telse\n\t\t\trc = nd_desc->fw_ops->activate(nd_desc);\n\t\tbreak;\n\tcase NVDIMM_FWA_IDLE:\n\tdefault:\n\t\trc = -ENXIO;\n\t}\n\n\tif (rc == 0)\n\t\trc = len;\n\treturn rc;\n}\n\nstatic DEVICE_ATTR_ADMIN_RW(activate);\n\nstatic umode_t nvdimm_bus_firmware_visible(struct kobject *kobj, struct attribute *a, int n)\n{\n\tstruct device *dev = container_of(kobj, typeof(*dev), kobj);\n\tstruct nvdimm_bus *nvdimm_bus = to_nvdimm_bus(dev);\n\tstruct nvdimm_bus_descriptor *nd_desc = nvdimm_bus->nd_desc;\n\tenum nvdimm_fwa_capability cap;\n\n\t \n\tif (!nd_desc->fw_ops)\n\t\treturn 0;\n\n\tcap = nd_desc->fw_ops->capability(nd_desc);\n\tif (cap < NVDIMM_FWA_CAP_QUIESCE)\n\t\treturn 0;\n\n\treturn a->mode;\n}\nstatic struct attribute *nvdimm_bus_firmware_attributes[] = {\n\t&dev_attr_activate.attr,\n\t&dev_attr_capability.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group nvdimm_bus_firmware_attribute_group = {\n\t.name = \"firmware\",\n\t.attrs = nvdimm_bus_firmware_attributes,\n\t.is_visible = nvdimm_bus_firmware_visible,\n};\n\nconst struct attribute_group *nvdimm_bus_attribute_groups[] = {\n\t&nvdimm_bus_attribute_group,\n\t&nvdimm_bus_firmware_attribute_group,\n\tNULL,\n};\n\nint nvdimm_bus_add_badrange(struct nvdimm_bus *nvdimm_bus, u64 addr, u64 length)\n{\n\treturn badrange_add(&nvdimm_bus->badrange, addr, length);\n}\nEXPORT_SYMBOL_GPL(nvdimm_bus_add_badrange);\n\n#ifdef CONFIG_BLK_DEV_INTEGRITY\nint nd_integrity_init(struct gendisk *disk, unsigned long meta_size)\n{\n\tstruct blk_integrity bi;\n\n\tif (meta_size == 0)\n\t\treturn 0;\n\n\tmemset(&bi, 0, sizeof(bi));\n\n\tbi.tuple_size = meta_size;\n\tbi.tag_size = meta_size;\n\n\tblk_integrity_register(disk, &bi);\n\tblk_queue_max_integrity_segments(disk->queue, 1);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(nd_integrity_init);\n\n#else  \nint nd_integrity_init(struct gendisk *disk, unsigned long meta_size)\n{\n\treturn 0;\n}\nEXPORT_SYMBOL(nd_integrity_init);\n\n#endif\n\nstatic __init int libnvdimm_init(void)\n{\n\tint rc;\n\n\trc = nvdimm_bus_init();\n\tif (rc)\n\t\treturn rc;\n\trc = nvdimm_init();\n\tif (rc)\n\t\tgoto err_dimm;\n\trc = nd_region_init();\n\tif (rc)\n\t\tgoto err_region;\n\n\tnd_label_init();\n\n\treturn 0;\n err_region:\n\tnvdimm_exit();\n err_dimm:\n\tnvdimm_bus_exit();\n\treturn rc;\n}\n\nstatic __exit void libnvdimm_exit(void)\n{\n\tWARN_ON(!list_empty(&nvdimm_bus_list));\n\tnd_region_exit();\n\tnvdimm_exit();\n\tnvdimm_bus_exit();\n\tnvdimm_devs_exit();\n}\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Intel Corporation\");\nsubsys_initcall(libnvdimm_init);\nmodule_exit(libnvdimm_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}