{
  "module_name": "claim.c",
  "hash_id": "337cf89c3d4d88115478d1515b8396e17ac02fe3a9e7c8457c393fbd44d4ed4d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/nvdimm/claim.c",
  "human_readable_source": "\n \n#include <linux/device.h>\n#include <linux/sizes.h>\n#include <linux/badblocks.h>\n#include \"nd-core.h\"\n#include \"pmem.h\"\n#include \"pfn.h\"\n#include \"btt.h\"\n#include \"nd.h\"\n\nvoid __nd_detach_ndns(struct device *dev, struct nd_namespace_common **_ndns)\n{\n\tstruct nd_namespace_common *ndns = *_ndns;\n\tstruct nvdimm_bus *nvdimm_bus;\n\n\tif (!ndns)\n\t\treturn;\n\n\tnvdimm_bus = walk_to_nvdimm_bus(&ndns->dev);\n\tlockdep_assert_held(&nvdimm_bus->reconfig_mutex);\n\tdev_WARN_ONCE(dev, ndns->claim != dev, \"%s: invalid claim\\n\", __func__);\n\tndns->claim = NULL;\n\t*_ndns = NULL;\n\tput_device(&ndns->dev);\n}\n\nvoid nd_detach_ndns(struct device *dev,\n\t\tstruct nd_namespace_common **_ndns)\n{\n\tstruct nd_namespace_common *ndns = *_ndns;\n\n\tif (!ndns)\n\t\treturn;\n\tget_device(&ndns->dev);\n\tnvdimm_bus_lock(&ndns->dev);\n\t__nd_detach_ndns(dev, _ndns);\n\tnvdimm_bus_unlock(&ndns->dev);\n\tput_device(&ndns->dev);\n}\n\nbool __nd_attach_ndns(struct device *dev, struct nd_namespace_common *attach,\n\t\tstruct nd_namespace_common **_ndns)\n{\n\tstruct nvdimm_bus *nvdimm_bus = walk_to_nvdimm_bus(&attach->dev);\n\n\tif (attach->claim)\n\t\treturn false;\n\tlockdep_assert_held(&nvdimm_bus->reconfig_mutex);\n\tdev_WARN_ONCE(dev, *_ndns, \"%s: invalid claim\\n\", __func__);\n\tattach->claim = dev;\n\t*_ndns = attach;\n\tget_device(&attach->dev);\n\treturn true;\n}\n\nbool nd_attach_ndns(struct device *dev, struct nd_namespace_common *attach,\n\t\tstruct nd_namespace_common **_ndns)\n{\n\tbool claimed;\n\n\tnvdimm_bus_lock(&attach->dev);\n\tclaimed = __nd_attach_ndns(dev, attach, _ndns);\n\tnvdimm_bus_unlock(&attach->dev);\n\treturn claimed;\n}\n\nstatic int namespace_match(struct device *dev, void *data)\n{\n\tchar *name = data;\n\n\treturn strcmp(name, dev_name(dev)) == 0;\n}\n\nstatic bool is_idle(struct device *dev, struct nd_namespace_common *ndns)\n{\n\tstruct nd_region *nd_region = to_nd_region(dev->parent);\n\tstruct device *seed = NULL;\n\n\tif (is_nd_btt(dev))\n\t\tseed = nd_region->btt_seed;\n\telse if (is_nd_pfn(dev))\n\t\tseed = nd_region->pfn_seed;\n\telse if (is_nd_dax(dev))\n\t\tseed = nd_region->dax_seed;\n\n\tif (seed == dev || ndns || dev->driver)\n\t\treturn false;\n\treturn true;\n}\n\nstruct nd_pfn *to_nd_pfn_safe(struct device *dev)\n{\n\t \n\tif (is_nd_pfn(dev))\n\t\treturn to_nd_pfn(dev);\n\n\tif (is_nd_dax(dev)) {\n\t\tstruct nd_dax *nd_dax = to_nd_dax(dev);\n\n\t\treturn &nd_dax->nd_pfn;\n\t}\n\n\tWARN_ON(1);\n\treturn NULL;\n}\n\nstatic void nd_detach_and_reset(struct device *dev,\n\t\tstruct nd_namespace_common **_ndns)\n{\n\t \n\t__nd_detach_ndns(dev, _ndns);\n\tif (is_idle(dev, *_ndns)) {\n\t\tnd_device_unregister(dev, ND_ASYNC);\n\t} else if (is_nd_btt(dev)) {\n\t\tstruct nd_btt *nd_btt = to_nd_btt(dev);\n\n\t\tnd_btt->lbasize = 0;\n\t\tkfree(nd_btt->uuid);\n\t\tnd_btt->uuid = NULL;\n\t} else if (is_nd_pfn(dev) || is_nd_dax(dev)) {\n\t\tstruct nd_pfn *nd_pfn = to_nd_pfn_safe(dev);\n\n\t\tkfree(nd_pfn->uuid);\n\t\tnd_pfn->uuid = NULL;\n\t\tnd_pfn->mode = PFN_MODE_NONE;\n\t}\n}\n\nssize_t nd_namespace_store(struct device *dev,\n\t\tstruct nd_namespace_common **_ndns, const char *buf,\n\t\tsize_t len)\n{\n\tstruct nd_namespace_common *ndns;\n\tstruct device *found;\n\tchar *name;\n\n\tif (dev->driver) {\n\t\tdev_dbg(dev, \"namespace already active\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tname = kstrndup(buf, len, GFP_KERNEL);\n\tif (!name)\n\t\treturn -ENOMEM;\n\tstrim(name);\n\n\tif (strncmp(name, \"namespace\", 9) == 0 || strcmp(name, \"\") == 0)\n\t\t ;\n\telse {\n\t\tlen = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tndns = *_ndns;\n\tif (strcmp(name, \"\") == 0) {\n\t\tnd_detach_and_reset(dev, _ndns);\n\t\tgoto out;\n\t} else if (ndns) {\n\t\tdev_dbg(dev, \"namespace already set to: %s\\n\",\n\t\t\t\tdev_name(&ndns->dev));\n\t\tlen = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tfound = device_find_child(dev->parent, name, namespace_match);\n\tif (!found) {\n\t\tdev_dbg(dev, \"'%s' not found under %s\\n\", name,\n\t\t\t\tdev_name(dev->parent));\n\t\tlen = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tndns = to_ndns(found);\n\n\tswitch (ndns->claim_class) {\n\tcase NVDIMM_CCLASS_NONE:\n\t\tbreak;\n\tcase NVDIMM_CCLASS_BTT:\n\tcase NVDIMM_CCLASS_BTT2:\n\t\tif (!is_nd_btt(dev)) {\n\t\t\tlen = -EBUSY;\n\t\t\tgoto out_attach;\n\t\t}\n\t\tbreak;\n\tcase NVDIMM_CCLASS_PFN:\n\t\tif (!is_nd_pfn(dev)) {\n\t\t\tlen = -EBUSY;\n\t\t\tgoto out_attach;\n\t\t}\n\t\tbreak;\n\tcase NVDIMM_CCLASS_DAX:\n\t\tif (!is_nd_dax(dev)) {\n\t\t\tlen = -EBUSY;\n\t\t\tgoto out_attach;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tlen = -EBUSY;\n\t\tgoto out_attach;\n\t\tbreak;\n\t}\n\n\tif (__nvdimm_namespace_capacity(ndns) < SZ_16M) {\n\t\tdev_dbg(dev, \"%s too small to host\\n\", name);\n\t\tlen = -ENXIO;\n\t\tgoto out_attach;\n\t}\n\n\tWARN_ON_ONCE(!is_nvdimm_bus_locked(dev));\n\tif (!__nd_attach_ndns(dev, ndns, _ndns)) {\n\t\tdev_dbg(dev, \"%s already claimed\\n\",\n\t\t\t\tdev_name(&ndns->dev));\n\t\tlen = -EBUSY;\n\t}\n\n out_attach:\n\tput_device(&ndns->dev);  \n out:\n\tkfree(name);\n\treturn len;\n}\n\n \nu64 nd_sb_checksum(struct nd_gen_sb *nd_gen_sb)\n{\n\tu64 sum;\n\t__le64 sum_save;\n\n\tBUILD_BUG_ON(sizeof(struct btt_sb) != SZ_4K);\n\tBUILD_BUG_ON(sizeof(struct nd_pfn_sb) != SZ_4K);\n\tBUILD_BUG_ON(sizeof(struct nd_gen_sb) != SZ_4K);\n\n\tsum_save = nd_gen_sb->checksum;\n\tnd_gen_sb->checksum = 0;\n\tsum = nd_fletcher64(nd_gen_sb, sizeof(*nd_gen_sb), 1);\n\tnd_gen_sb->checksum = sum_save;\n\treturn sum;\n}\nEXPORT_SYMBOL(nd_sb_checksum);\n\nstatic int nsio_rw_bytes(struct nd_namespace_common *ndns,\n\t\tresource_size_t offset, void *buf, size_t size, int rw,\n\t\tunsigned long flags)\n{\n\tstruct nd_namespace_io *nsio = to_nd_namespace_io(&ndns->dev);\n\tunsigned int sz_align = ALIGN(size + (offset & (512 - 1)), 512);\n\tsector_t sector = offset >> 9;\n\tint rc = 0, ret = 0;\n\n\tif (unlikely(!size))\n\t\treturn 0;\n\n\tif (unlikely(offset + size > nsio->size)) {\n\t\tdev_WARN_ONCE(&ndns->dev, 1, \"request out of range\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\tif (rw == READ) {\n\t\tif (unlikely(is_bad_pmem(&nsio->bb, sector, sz_align)))\n\t\t\treturn -EIO;\n\t\tif (copy_mc_to_kernel(buf, nsio->addr + offset, size) != 0)\n\t\t\treturn -EIO;\n\t\treturn 0;\n\t}\n\n\tif (unlikely(is_bad_pmem(&nsio->bb, sector, sz_align))) {\n\t\tif (IS_ALIGNED(offset, 512) && IS_ALIGNED(size, 512)\n\t\t\t\t&& !(flags & NVDIMM_IO_ATOMIC)) {\n\t\t\tlong cleared;\n\n\t\t\tmight_sleep();\n\t\t\tcleared = nvdimm_clear_poison(&ndns->dev,\n\t\t\t\t\tnsio->res.start + offset, size);\n\t\t\tif (cleared < size)\n\t\t\t\trc = -EIO;\n\t\t\tif (cleared > 0 && cleared / 512) {\n\t\t\t\tcleared /= 512;\n\t\t\t\tbadblocks_clear(&nsio->bb, sector, cleared);\n\t\t\t}\n\t\t\tarch_invalidate_pmem(nsio->addr + offset, size);\n\t\t} else\n\t\t\trc = -EIO;\n\t}\n\n\tmemcpy_flushcache(nsio->addr + offset, buf, size);\n\tret = nvdimm_flush(to_nd_region(ndns->dev.parent), NULL);\n\tif (ret)\n\t\trc = ret;\n\n\treturn rc;\n}\n\nint devm_nsio_enable(struct device *dev, struct nd_namespace_io *nsio,\n\t\tresource_size_t size)\n{\n\tstruct nd_namespace_common *ndns = &nsio->common;\n\tstruct range range = {\n\t\t.start = nsio->res.start,\n\t\t.end = nsio->res.end,\n\t};\n\n\tnsio->size = size;\n\tif (!devm_request_mem_region(dev, range.start, size,\n\t\t\t\tdev_name(&ndns->dev))) {\n\t\tdev_warn(dev, \"could not reserve region %pR\\n\", &nsio->res);\n\t\treturn -EBUSY;\n\t}\n\n\tndns->rw_bytes = nsio_rw_bytes;\n\tif (devm_init_badblocks(dev, &nsio->bb))\n\t\treturn -ENOMEM;\n\tnvdimm_badblocks_populate(to_nd_region(ndns->dev.parent), &nsio->bb,\n\t\t\t&range);\n\n\tnsio->addr = devm_memremap(dev, range.start, size, ARCH_MEMREMAP_PMEM);\n\n\treturn PTR_ERR_OR_ZERO(nsio->addr);\n}\n\nvoid devm_nsio_disable(struct device *dev, struct nd_namespace_io *nsio)\n{\n\tstruct resource *res = &nsio->res;\n\n\tdevm_memunmap(dev, nsio->addr);\n\tdevm_exit_badblocks(dev, &nsio->bb);\n\tdevm_release_mem_region(dev, res->start, nsio->size);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}