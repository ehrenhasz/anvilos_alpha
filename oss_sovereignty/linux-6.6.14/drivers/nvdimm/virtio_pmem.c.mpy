{
  "module_name": "virtio_pmem.c",
  "hash_id": "03c815ffdc493ae7661acc4c1e9096ea72c34b48fd09e12e0932a34e3314e982",
  "original_prompt": "Ingested from linux-6.6.14/drivers/nvdimm/virtio_pmem.c",
  "human_readable_source": "\n \n#include \"virtio_pmem.h\"\n#include \"nd.h\"\n\nstatic struct virtio_device_id id_table[] = {\n\t{ VIRTIO_ID_PMEM, VIRTIO_DEV_ANY_ID },\n\t{ 0 },\n};\n\n  \nstatic int init_vq(struct virtio_pmem *vpmem)\n{\n\t \n\tvpmem->req_vq = virtio_find_single_vq(vpmem->vdev,\n\t\t\t\t\tvirtio_pmem_host_ack, \"flush_queue\");\n\tif (IS_ERR(vpmem->req_vq))\n\t\treturn PTR_ERR(vpmem->req_vq);\n\n\tspin_lock_init(&vpmem->pmem_lock);\n\tINIT_LIST_HEAD(&vpmem->req_list);\n\n\treturn 0;\n};\n\nstatic int virtio_pmem_probe(struct virtio_device *vdev)\n{\n\tstruct nd_region_desc ndr_desc = {};\n\tstruct nd_region *nd_region;\n\tstruct virtio_pmem *vpmem;\n\tstruct resource res;\n\tint err = 0;\n\n\tif (!vdev->config->get) {\n\t\tdev_err(&vdev->dev, \"%s failure: config access disabled\\n\",\n\t\t\t__func__);\n\t\treturn -EINVAL;\n\t}\n\n\tvpmem = devm_kzalloc(&vdev->dev, sizeof(*vpmem), GFP_KERNEL);\n\tif (!vpmem) {\n\t\terr = -ENOMEM;\n\t\tgoto out_err;\n\t}\n\n\tvpmem->vdev = vdev;\n\tvdev->priv = vpmem;\n\terr = init_vq(vpmem);\n\tif (err) {\n\t\tdev_err(&vdev->dev, \"failed to initialize virtio pmem vq's\\n\");\n\t\tgoto out_err;\n\t}\n\n\tvirtio_cread_le(vpmem->vdev, struct virtio_pmem_config,\n\t\t\tstart, &vpmem->start);\n\tvirtio_cread_le(vpmem->vdev, struct virtio_pmem_config,\n\t\t\tsize, &vpmem->size);\n\n\tres.start = vpmem->start;\n\tres.end   = vpmem->start + vpmem->size - 1;\n\tvpmem->nd_desc.provider_name = \"virtio-pmem\";\n\tvpmem->nd_desc.module = THIS_MODULE;\n\n\tvpmem->nvdimm_bus = nvdimm_bus_register(&vdev->dev,\n\t\t\t\t\t\t&vpmem->nd_desc);\n\tif (!vpmem->nvdimm_bus) {\n\t\tdev_err(&vdev->dev, \"failed to register device with nvdimm_bus\\n\");\n\t\terr = -ENXIO;\n\t\tgoto out_vq;\n\t}\n\n\tdev_set_drvdata(&vdev->dev, vpmem->nvdimm_bus);\n\n\tndr_desc.res = &res;\n\n\tndr_desc.numa_node = memory_add_physaddr_to_nid(res.start);\n\tndr_desc.target_node = phys_to_target_node(res.start);\n\tif (ndr_desc.target_node == NUMA_NO_NODE) {\n\t\tndr_desc.target_node = ndr_desc.numa_node;\n\t\tdev_dbg(&vdev->dev, \"changing target node from %d to %d\",\n\t\t\tNUMA_NO_NODE, ndr_desc.target_node);\n\t}\n\n\tndr_desc.flush = async_pmem_flush;\n\tndr_desc.provider_data = vdev;\n\tset_bit(ND_REGION_PAGEMAP, &ndr_desc.flags);\n\tset_bit(ND_REGION_ASYNC, &ndr_desc.flags);\n\t \n\tvirtio_device_ready(vdev);\n\tnd_region = nvdimm_pmem_region_create(vpmem->nvdimm_bus, &ndr_desc);\n\tif (!nd_region) {\n\t\tdev_err(&vdev->dev, \"failed to create nvdimm region\\n\");\n\t\terr = -ENXIO;\n\t\tgoto out_nd;\n\t}\n\treturn 0;\nout_nd:\n\tvirtio_reset_device(vdev);\n\tnvdimm_bus_unregister(vpmem->nvdimm_bus);\nout_vq:\n\tvdev->config->del_vqs(vdev);\nout_err:\n\treturn err;\n}\n\nstatic void virtio_pmem_remove(struct virtio_device *vdev)\n{\n\tstruct nvdimm_bus *nvdimm_bus = dev_get_drvdata(&vdev->dev);\n\n\tnvdimm_bus_unregister(nvdimm_bus);\n\tvdev->config->del_vqs(vdev);\n\tvirtio_reset_device(vdev);\n}\n\nstatic struct virtio_driver virtio_pmem_driver = {\n\t.driver.name\t\t= KBUILD_MODNAME,\n\t.driver.owner\t\t= THIS_MODULE,\n\t.id_table\t\t= id_table,\n\t.probe\t\t\t= virtio_pmem_probe,\n\t.remove\t\t\t= virtio_pmem_remove,\n};\n\nmodule_virtio_driver(virtio_pmem_driver);\nMODULE_DEVICE_TABLE(virtio, id_table);\nMODULE_DESCRIPTION(\"Virtio pmem driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}