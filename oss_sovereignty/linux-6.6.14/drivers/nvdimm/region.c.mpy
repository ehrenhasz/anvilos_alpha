{
  "module_name": "region.c",
  "hash_id": "17f275e7dc2cb70afb13d83e60cfa7f355a34c73ee00956d9f432d949185c687",
  "original_prompt": "Ingested from linux-6.6.14/drivers/nvdimm/region.c",
  "human_readable_source": "\n \n#include <linux/memregion.h>\n#include <linux/cpumask.h>\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/nd.h>\n#include \"nd-core.h\"\n#include \"nd.h\"\n\nstatic int nd_region_probe(struct device *dev)\n{\n\tint err, rc;\n\tstatic unsigned long once;\n\tstruct nd_region_data *ndrd;\n\tstruct nd_region *nd_region = to_nd_region(dev);\n\tstruct range range = {\n\t\t.start = nd_region->ndr_start,\n\t\t.end = nd_region->ndr_start + nd_region->ndr_size - 1,\n\t};\n\n\tif (nd_region->num_lanes > num_online_cpus()\n\t\t\t&& nd_region->num_lanes < num_possible_cpus()\n\t\t\t&& !test_and_set_bit(0, &once)) {\n\t\tdev_dbg(dev, \"online cpus (%d) < concurrent i/o lanes (%d) < possible cpus (%d)\\n\",\n\t\t\t\tnum_online_cpus(), nd_region->num_lanes,\n\t\t\t\tnum_possible_cpus());\n\t\tdev_dbg(dev, \"setting nr_cpus=%d may yield better libnvdimm device performance\\n\",\n\t\t\t\tnd_region->num_lanes);\n\t}\n\n\trc = nd_region_activate(nd_region);\n\tif (rc)\n\t\treturn rc;\n\n\tif (devm_init_badblocks(dev, &nd_region->bb))\n\t\treturn -ENODEV;\n\tnd_region->bb_state =\n\t\tsysfs_get_dirent(nd_region->dev.kobj.sd, \"badblocks\");\n\tif (!nd_region->bb_state)\n\t\tdev_warn(dev, \"'badblocks' notification disabled\\n\");\n\tnvdimm_badblocks_populate(nd_region, &nd_region->bb, &range);\n\n\trc = nd_region_register_namespaces(nd_region, &err);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tndrd = dev_get_drvdata(dev);\n\tndrd->ns_active = rc;\n\tndrd->ns_count = rc + err;\n\n\tif (rc && err && rc == err)\n\t\treturn -ENODEV;\n\n\tnd_region->btt_seed = nd_btt_create(nd_region);\n\tnd_region->pfn_seed = nd_pfn_create(nd_region);\n\tnd_region->dax_seed = nd_dax_create(nd_region);\n\tif (err == 0)\n\t\treturn 0;\n\n\t \n\tdev_err(dev, \"failed to register %d namespace%s, continuing...\\n\",\n\t\t\terr, err == 1 ? \"\" : \"s\");\n\treturn 0;\n}\n\nstatic int child_unregister(struct device *dev, void *data)\n{\n\tnd_device_unregister(dev, ND_SYNC);\n\treturn 0;\n}\n\nstatic void nd_region_remove(struct device *dev)\n{\n\tstruct nd_region *nd_region = to_nd_region(dev);\n\n\tdevice_for_each_child(dev, NULL, child_unregister);\n\n\t \n\tnvdimm_bus_lock(dev);\n\tnd_region->ns_seed = NULL;\n\tnd_region->btt_seed = NULL;\n\tnd_region->pfn_seed = NULL;\n\tnd_region->dax_seed = NULL;\n\tdev_set_drvdata(dev, NULL);\n\tnvdimm_bus_unlock(dev);\n\n\t \n\tsysfs_put(nd_region->bb_state);\n\tnd_region->bb_state = NULL;\n\n\t \n\tif (cpu_cache_has_invalidate_memregion())\n\t\tcpu_cache_invalidate_memregion(IORES_DESC_PERSISTENT_MEMORY);\n}\n\nstatic int child_notify(struct device *dev, void *data)\n{\n\tnd_device_notify(dev, *(enum nvdimm_event *) data);\n\treturn 0;\n}\n\nstatic void nd_region_notify(struct device *dev, enum nvdimm_event event)\n{\n\tif (event == NVDIMM_REVALIDATE_POISON) {\n\t\tstruct nd_region *nd_region = to_nd_region(dev);\n\n\t\tif (is_memory(&nd_region->dev)) {\n\t\t\tstruct range range = {\n\t\t\t\t.start = nd_region->ndr_start,\n\t\t\t\t.end = nd_region->ndr_start +\n\t\t\t\t\tnd_region->ndr_size - 1,\n\t\t\t};\n\n\t\t\tnvdimm_badblocks_populate(nd_region,\n\t\t\t\t\t&nd_region->bb, &range);\n\t\t\tif (nd_region->bb_state)\n\t\t\t\tsysfs_notify_dirent(nd_region->bb_state);\n\t\t}\n\t}\n\tdevice_for_each_child(dev, &event, child_notify);\n}\n\nstatic struct nd_device_driver nd_region_driver = {\n\t.probe = nd_region_probe,\n\t.remove = nd_region_remove,\n\t.notify = nd_region_notify,\n\t.drv = {\n\t\t.name = \"nd_region\",\n\t},\n\t.type = ND_DRIVER_REGION_BLK | ND_DRIVER_REGION_PMEM,\n};\n\nint __init nd_region_init(void)\n{\n\treturn nd_driver_register(&nd_region_driver);\n}\n\nvoid nd_region_exit(void)\n{\n\tdriver_unregister(&nd_region_driver.drv);\n}\n\nMODULE_ALIAS_ND_DEVICE(ND_DEVICE_REGION_PMEM);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}