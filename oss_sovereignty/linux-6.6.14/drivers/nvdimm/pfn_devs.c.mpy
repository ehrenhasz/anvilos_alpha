{
  "module_name": "pfn_devs.c",
  "hash_id": "424d4349e8af8063adce57aa54cdbc9ea1d0c5d1ea96d271553f9c1a744a9017",
  "original_prompt": "Ingested from linux-6.6.14/drivers/nvdimm/pfn_devs.c",
  "human_readable_source": "\n \n#include <linux/memremap.h>\n#include <linux/blkdev.h>\n#include <linux/device.h>\n#include <linux/sizes.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include \"nd-core.h\"\n#include \"pfn.h\"\n#include \"nd.h\"\n\nstatic const bool page_struct_override = IS_ENABLED(CONFIG_NVDIMM_KMSAN);\n\nstatic void nd_pfn_release(struct device *dev)\n{\n\tstruct nd_region *nd_region = to_nd_region(dev->parent);\n\tstruct nd_pfn *nd_pfn = to_nd_pfn(dev);\n\n\tdev_dbg(dev, \"trace\\n\");\n\tnd_detach_ndns(&nd_pfn->dev, &nd_pfn->ndns);\n\tida_simple_remove(&nd_region->pfn_ida, nd_pfn->id);\n\tkfree(nd_pfn->uuid);\n\tkfree(nd_pfn);\n}\n\nstruct nd_pfn *to_nd_pfn(struct device *dev)\n{\n\tstruct nd_pfn *nd_pfn = container_of(dev, struct nd_pfn, dev);\n\n\tWARN_ON(!is_nd_pfn(dev));\n\treturn nd_pfn;\n}\nEXPORT_SYMBOL(to_nd_pfn);\n\nstatic ssize_t mode_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct nd_pfn *nd_pfn = to_nd_pfn_safe(dev);\n\n\tswitch (nd_pfn->mode) {\n\tcase PFN_MODE_RAM:\n\t\treturn sprintf(buf, \"ram\\n\");\n\tcase PFN_MODE_PMEM:\n\t\treturn sprintf(buf, \"pmem\\n\");\n\tdefault:\n\t\treturn sprintf(buf, \"none\\n\");\n\t}\n}\n\nstatic ssize_t mode_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t len)\n{\n\tstruct nd_pfn *nd_pfn = to_nd_pfn_safe(dev);\n\tssize_t rc = 0;\n\n\tdevice_lock(dev);\n\tnvdimm_bus_lock(dev);\n\tif (dev->driver)\n\t\trc = -EBUSY;\n\telse {\n\t\tsize_t n = len - 1;\n\n\t\tif (strncmp(buf, \"pmem\\n\", n) == 0\n\t\t\t\t|| strncmp(buf, \"pmem\", n) == 0) {\n\t\t\tnd_pfn->mode = PFN_MODE_PMEM;\n\t\t} else if (strncmp(buf, \"ram\\n\", n) == 0\n\t\t\t\t|| strncmp(buf, \"ram\", n) == 0)\n\t\t\tnd_pfn->mode = PFN_MODE_RAM;\n\t\telse if (strncmp(buf, \"none\\n\", n) == 0\n\t\t\t\t|| strncmp(buf, \"none\", n) == 0)\n\t\t\tnd_pfn->mode = PFN_MODE_NONE;\n\t\telse\n\t\t\trc = -EINVAL;\n\t}\n\tdev_dbg(dev, \"result: %zd wrote: %s%s\", rc, buf,\n\t\t\tbuf[len - 1] == '\\n' ? \"\" : \"\\n\");\n\tnvdimm_bus_unlock(dev);\n\tdevice_unlock(dev);\n\n\treturn rc ? rc : len;\n}\nstatic DEVICE_ATTR_RW(mode);\n\nstatic ssize_t align_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct nd_pfn *nd_pfn = to_nd_pfn_safe(dev);\n\n\treturn sprintf(buf, \"%ld\\n\", nd_pfn->align);\n}\n\nstatic unsigned long *nd_pfn_supported_alignments(unsigned long *alignments)\n{\n\n\talignments[0] = PAGE_SIZE;\n\n\tif (has_transparent_hugepage()) {\n\t\talignments[1] = HPAGE_PMD_SIZE;\n\t\tif (has_transparent_pud_hugepage())\n\t\t\talignments[2] = HPAGE_PUD_SIZE;\n\t}\n\n\treturn alignments;\n}\n\n \nstatic unsigned long nd_pfn_default_alignment(void)\n{\n\n\tif (has_transparent_hugepage())\n\t\treturn HPAGE_PMD_SIZE;\n\treturn PAGE_SIZE;\n}\n\nstatic ssize_t align_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t len)\n{\n\tstruct nd_pfn *nd_pfn = to_nd_pfn_safe(dev);\n\tunsigned long aligns[MAX_NVDIMM_ALIGN] = { [0] = 0, };\n\tssize_t rc;\n\n\tdevice_lock(dev);\n\tnvdimm_bus_lock(dev);\n\trc = nd_size_select_store(dev, buf, &nd_pfn->align,\n\t\t\tnd_pfn_supported_alignments(aligns));\n\tdev_dbg(dev, \"result: %zd wrote: %s%s\", rc, buf,\n\t\t\tbuf[len - 1] == '\\n' ? \"\" : \"\\n\");\n\tnvdimm_bus_unlock(dev);\n\tdevice_unlock(dev);\n\n\treturn rc ? rc : len;\n}\nstatic DEVICE_ATTR_RW(align);\n\nstatic ssize_t uuid_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct nd_pfn *nd_pfn = to_nd_pfn_safe(dev);\n\n\tif (nd_pfn->uuid)\n\t\treturn sprintf(buf, \"%pUb\\n\", nd_pfn->uuid);\n\treturn sprintf(buf, \"\\n\");\n}\n\nstatic ssize_t uuid_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t len)\n{\n\tstruct nd_pfn *nd_pfn = to_nd_pfn_safe(dev);\n\tssize_t rc;\n\n\tdevice_lock(dev);\n\trc = nd_uuid_store(dev, &nd_pfn->uuid, buf, len);\n\tdev_dbg(dev, \"result: %zd wrote: %s%s\", rc, buf,\n\t\t\tbuf[len - 1] == '\\n' ? \"\" : \"\\n\");\n\tdevice_unlock(dev);\n\n\treturn rc ? rc : len;\n}\nstatic DEVICE_ATTR_RW(uuid);\n\nstatic ssize_t namespace_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct nd_pfn *nd_pfn = to_nd_pfn_safe(dev);\n\tssize_t rc;\n\n\tnvdimm_bus_lock(dev);\n\trc = sprintf(buf, \"%s\\n\", nd_pfn->ndns\n\t\t\t? dev_name(&nd_pfn->ndns->dev) : \"\");\n\tnvdimm_bus_unlock(dev);\n\treturn rc;\n}\n\nstatic ssize_t namespace_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t len)\n{\n\tstruct nd_pfn *nd_pfn = to_nd_pfn_safe(dev);\n\tssize_t rc;\n\n\tdevice_lock(dev);\n\tnvdimm_bus_lock(dev);\n\trc = nd_namespace_store(dev, &nd_pfn->ndns, buf, len);\n\tdev_dbg(dev, \"result: %zd wrote: %s%s\", rc, buf,\n\t\t\tbuf[len - 1] == '\\n' ? \"\" : \"\\n\");\n\tnvdimm_bus_unlock(dev);\n\tdevice_unlock(dev);\n\n\treturn rc;\n}\nstatic DEVICE_ATTR_RW(namespace);\n\nstatic ssize_t resource_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct nd_pfn *nd_pfn = to_nd_pfn_safe(dev);\n\tssize_t rc;\n\n\tdevice_lock(dev);\n\tif (dev->driver) {\n\t\tstruct nd_pfn_sb *pfn_sb = nd_pfn->pfn_sb;\n\t\tu64 offset = __le64_to_cpu(pfn_sb->dataoff);\n\t\tstruct nd_namespace_common *ndns = nd_pfn->ndns;\n\t\tu32 start_pad = __le32_to_cpu(pfn_sb->start_pad);\n\t\tstruct nd_namespace_io *nsio = to_nd_namespace_io(&ndns->dev);\n\n\t\trc = sprintf(buf, \"%#llx\\n\", (unsigned long long) nsio->res.start\n\t\t\t\t+ start_pad + offset);\n\t} else {\n\t\t \n\t\trc = -ENXIO;\n\t}\n\tdevice_unlock(dev);\n\n\treturn rc;\n}\nstatic DEVICE_ATTR_ADMIN_RO(resource);\n\nstatic ssize_t size_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct nd_pfn *nd_pfn = to_nd_pfn_safe(dev);\n\tssize_t rc;\n\n\tdevice_lock(dev);\n\tif (dev->driver) {\n\t\tstruct nd_pfn_sb *pfn_sb = nd_pfn->pfn_sb;\n\t\tu64 offset = __le64_to_cpu(pfn_sb->dataoff);\n\t\tstruct nd_namespace_common *ndns = nd_pfn->ndns;\n\t\tu32 start_pad = __le32_to_cpu(pfn_sb->start_pad);\n\t\tu32 end_trunc = __le32_to_cpu(pfn_sb->end_trunc);\n\t\tstruct nd_namespace_io *nsio = to_nd_namespace_io(&ndns->dev);\n\n\t\trc = sprintf(buf, \"%llu\\n\", (unsigned long long)\n\t\t\t\tresource_size(&nsio->res) - start_pad\n\t\t\t\t- end_trunc - offset);\n\t} else {\n\t\t \n\t\trc = -ENXIO;\n\t}\n\tdevice_unlock(dev);\n\n\treturn rc;\n}\nstatic DEVICE_ATTR_RO(size);\n\nstatic ssize_t supported_alignments_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tunsigned long aligns[MAX_NVDIMM_ALIGN] = { [0] = 0, };\n\n\treturn nd_size_select_show(0,\n\t\t\tnd_pfn_supported_alignments(aligns), buf);\n}\nstatic DEVICE_ATTR_RO(supported_alignments);\n\nstatic struct attribute *nd_pfn_attributes[] = {\n\t&dev_attr_mode.attr,\n\t&dev_attr_namespace.attr,\n\t&dev_attr_uuid.attr,\n\t&dev_attr_align.attr,\n\t&dev_attr_resource.attr,\n\t&dev_attr_size.attr,\n\t&dev_attr_supported_alignments.attr,\n\tNULL,\n};\n\nstatic struct attribute_group nd_pfn_attribute_group = {\n\t.attrs = nd_pfn_attributes,\n};\n\nconst struct attribute_group *nd_pfn_attribute_groups[] = {\n\t&nd_pfn_attribute_group,\n\t&nd_device_attribute_group,\n\t&nd_numa_attribute_group,\n\tNULL,\n};\n\nstatic const struct device_type nd_pfn_device_type = {\n\t.name = \"nd_pfn\",\n\t.release = nd_pfn_release,\n\t.groups = nd_pfn_attribute_groups,\n};\n\nbool is_nd_pfn(struct device *dev)\n{\n\treturn dev ? dev->type == &nd_pfn_device_type : false;\n}\nEXPORT_SYMBOL(is_nd_pfn);\n\nstatic struct lock_class_key nvdimm_pfn_key;\n\nstruct device *nd_pfn_devinit(struct nd_pfn *nd_pfn,\n\t\tstruct nd_namespace_common *ndns)\n{\n\tstruct device *dev;\n\n\tif (!nd_pfn)\n\t\treturn NULL;\n\n\tnd_pfn->mode = PFN_MODE_NONE;\n\tnd_pfn->align = nd_pfn_default_alignment();\n\tdev = &nd_pfn->dev;\n\tdevice_initialize(&nd_pfn->dev);\n\tlockdep_set_class(&nd_pfn->dev.mutex, &nvdimm_pfn_key);\n\tif (ndns && !__nd_attach_ndns(&nd_pfn->dev, ndns, &nd_pfn->ndns)) {\n\t\tdev_dbg(&ndns->dev, \"failed, already claimed by %s\\n\",\n\t\t\t\tdev_name(ndns->claim));\n\t\tput_device(dev);\n\t\treturn NULL;\n\t}\n\treturn dev;\n}\n\nstatic struct nd_pfn *nd_pfn_alloc(struct nd_region *nd_region)\n{\n\tstruct nd_pfn *nd_pfn;\n\tstruct device *dev;\n\n\tnd_pfn = kzalloc(sizeof(*nd_pfn), GFP_KERNEL);\n\tif (!nd_pfn)\n\t\treturn NULL;\n\n\tnd_pfn->id = ida_simple_get(&nd_region->pfn_ida, 0, 0, GFP_KERNEL);\n\tif (nd_pfn->id < 0) {\n\t\tkfree(nd_pfn);\n\t\treturn NULL;\n\t}\n\n\tdev = &nd_pfn->dev;\n\tdev_set_name(dev, \"pfn%d.%d\", nd_region->id, nd_pfn->id);\n\tdev->type = &nd_pfn_device_type;\n\tdev->parent = &nd_region->dev;\n\n\treturn nd_pfn;\n}\n\nstruct device *nd_pfn_create(struct nd_region *nd_region)\n{\n\tstruct nd_pfn *nd_pfn;\n\tstruct device *dev;\n\n\tif (!is_memory(&nd_region->dev))\n\t\treturn NULL;\n\n\tnd_pfn = nd_pfn_alloc(nd_region);\n\tdev = nd_pfn_devinit(nd_pfn, NULL);\n\n\tnd_device_register(dev);\n\treturn dev;\n}\n\n \nstatic int nd_pfn_clear_memmap_errors(struct nd_pfn *nd_pfn)\n{\n\tstruct nd_region *nd_region = to_nd_region(nd_pfn->dev.parent);\n\tstruct nd_namespace_common *ndns = nd_pfn->ndns;\n\tvoid *zero_page = page_address(ZERO_PAGE(0));\n\tstruct nd_pfn_sb *pfn_sb = nd_pfn->pfn_sb;\n\tint num_bad, meta_num, rc, bb_present;\n\tsector_t first_bad, meta_start;\n\tstruct nd_namespace_io *nsio;\n\n\tif (nd_pfn->mode != PFN_MODE_PMEM)\n\t\treturn 0;\n\n\tnsio = to_nd_namespace_io(&ndns->dev);\n\tmeta_start = (SZ_4K + sizeof(*pfn_sb)) >> 9;\n\tmeta_num = (le64_to_cpu(pfn_sb->dataoff) >> 9) - meta_start;\n\n\t \n\tdevm_namespace_disable(&nd_pfn->dev, ndns);\n\trc = devm_namespace_enable(&nd_pfn->dev, ndns, le64_to_cpu(pfn_sb->dataoff));\n\tif (rc)\n\t\treturn rc;\n\n\tdo {\n\t\tunsigned long zero_len;\n\t\tu64 nsoff;\n\n\t\tbb_present = badblocks_check(&nd_region->bb, meta_start,\n\t\t\t\tmeta_num, &first_bad, &num_bad);\n\t\tif (bb_present) {\n\t\t\tdev_dbg(&nd_pfn->dev, \"meta: %x badblocks at %llx\\n\",\n\t\t\t\t\tnum_bad, first_bad);\n\t\t\tnsoff = ALIGN_DOWN((nd_region->ndr_start\n\t\t\t\t\t+ (first_bad << 9)) - nsio->res.start,\n\t\t\t\t\tPAGE_SIZE);\n\t\t\tzero_len = ALIGN(num_bad << 9, PAGE_SIZE);\n\t\t\twhile (zero_len) {\n\t\t\t\tunsigned long chunk = min(zero_len, PAGE_SIZE);\n\n\t\t\t\trc = nvdimm_write_bytes(ndns, nsoff, zero_page,\n\t\t\t\t\t\t\tchunk, 0);\n\t\t\t\tif (rc)\n\t\t\t\t\tbreak;\n\n\t\t\t\tzero_len -= chunk;\n\t\t\t\tnsoff += chunk;\n\t\t\t}\n\t\t\tif (rc) {\n\t\t\t\tdev_err(&nd_pfn->dev,\n\t\t\t\t\t\"error clearing %x badblocks at %llx\\n\",\n\t\t\t\t\tnum_bad, first_bad);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\t} while (bb_present);\n\n\treturn 0;\n}\n\nstatic bool nd_supported_alignment(unsigned long align)\n{\n\tint i;\n\tunsigned long supported[MAX_NVDIMM_ALIGN] = { [0] = 0, };\n\n\tif (align == 0)\n\t\treturn false;\n\n\tnd_pfn_supported_alignments(supported);\n\tfor (i = 0; supported[i]; i++)\n\t\tif (align == supported[i])\n\t\t\treturn true;\n\treturn false;\n}\n\n \nint nd_pfn_validate(struct nd_pfn *nd_pfn, const char *sig)\n{\n\tu64 checksum, offset;\n\tstruct resource *res;\n\tenum nd_pfn_mode mode;\n\tresource_size_t res_size;\n\tstruct nd_namespace_io *nsio;\n\tunsigned long align, start_pad, end_trunc;\n\tstruct nd_pfn_sb *pfn_sb = nd_pfn->pfn_sb;\n\tstruct nd_namespace_common *ndns = nd_pfn->ndns;\n\tconst uuid_t *parent_uuid = nd_dev_to_uuid(&ndns->dev);\n\n\tif (!pfn_sb || !ndns)\n\t\treturn -ENODEV;\n\n\tif (!is_memory(nd_pfn->dev.parent))\n\t\treturn -ENODEV;\n\n\tif (nvdimm_read_bytes(ndns, SZ_4K, pfn_sb, sizeof(*pfn_sb), 0))\n\t\treturn -ENXIO;\n\n\tif (memcmp(pfn_sb->signature, sig, PFN_SIG_LEN) != 0)\n\t\treturn -ENODEV;\n\n\tchecksum = le64_to_cpu(pfn_sb->checksum);\n\tpfn_sb->checksum = 0;\n\tif (checksum != nd_sb_checksum((struct nd_gen_sb *) pfn_sb))\n\t\treturn -ENODEV;\n\tpfn_sb->checksum = cpu_to_le64(checksum);\n\n\tif (memcmp(pfn_sb->parent_uuid, parent_uuid, 16) != 0)\n\t\treturn -ENODEV;\n\n\tif (__le16_to_cpu(pfn_sb->version_minor) < 1) {\n\t\tpfn_sb->start_pad = 0;\n\t\tpfn_sb->end_trunc = 0;\n\t}\n\n\tif (__le16_to_cpu(pfn_sb->version_minor) < 2)\n\t\tpfn_sb->align = 0;\n\n\tif (__le16_to_cpu(pfn_sb->version_minor) < 4) {\n\t\tpfn_sb->page_struct_size = cpu_to_le16(64);\n\t\tpfn_sb->page_size = cpu_to_le32(PAGE_SIZE);\n\t}\n\n\tswitch (le32_to_cpu(pfn_sb->mode)) {\n\tcase PFN_MODE_RAM:\n\tcase PFN_MODE_PMEM:\n\t\tbreak;\n\tdefault:\n\t\treturn -ENXIO;\n\t}\n\n\talign = le32_to_cpu(pfn_sb->align);\n\toffset = le64_to_cpu(pfn_sb->dataoff);\n\tstart_pad = le32_to_cpu(pfn_sb->start_pad);\n\tend_trunc = le32_to_cpu(pfn_sb->end_trunc);\n\tif (align == 0)\n\t\talign = 1UL << ilog2(offset);\n\tmode = le32_to_cpu(pfn_sb->mode);\n\n\tif ((le32_to_cpu(pfn_sb->page_size) > PAGE_SIZE) &&\n\t\t\t(mode == PFN_MODE_PMEM)) {\n\t\tdev_err(&nd_pfn->dev,\n\t\t\t\t\"init failed, page size mismatch %d\\n\",\n\t\t\t\tle32_to_cpu(pfn_sb->page_size));\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif ((le16_to_cpu(pfn_sb->page_struct_size) < sizeof(struct page)) &&\n\t\t\t(mode == PFN_MODE_PMEM)) {\n\t\tdev_err(&nd_pfn->dev,\n\t\t\t\t\"init failed, struct page size mismatch %d\\n\",\n\t\t\t\tle16_to_cpu(pfn_sb->page_struct_size));\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t \n\tif (!nd_supported_alignment(align) &&\n\t\t\t!memcmp(pfn_sb->signature, DAX_SIG, PFN_SIG_LEN)) {\n\t\tdev_err(&nd_pfn->dev, \"init failed, alignment mismatch: \"\n\t\t\t\t\"%ld:%ld\\n\", nd_pfn->align, align);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (!nd_pfn->uuid) {\n\t\t \n\t\tnd_pfn->uuid = kmemdup(pfn_sb->uuid, 16, GFP_KERNEL);\n\t\tif (!nd_pfn->uuid)\n\t\t\treturn -ENOMEM;\n\t\tnd_pfn->align = align;\n\t\tnd_pfn->mode = mode;\n\t} else {\n\t\t \n\t\tif (memcmp(nd_pfn->uuid, pfn_sb->uuid, 16) != 0)\n\t\t\treturn -ENODEV;\n\n\t\t \n\t\tif (nd_pfn->align != align || nd_pfn->mode != mode) {\n\t\t\tdev_err(&nd_pfn->dev,\n\t\t\t\t\t\"init failed, settings mismatch\\n\");\n\t\t\tdev_dbg(&nd_pfn->dev, \"align: %lx:%lx mode: %d:%d\\n\",\n\t\t\t\t\tnd_pfn->align, align, nd_pfn->mode,\n\t\t\t\t\tmode);\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t}\n\n\tif (align > nvdimm_namespace_capacity(ndns)) {\n\t\tdev_err(&nd_pfn->dev, \"alignment: %lx exceeds capacity %llx\\n\",\n\t\t\t\talign, nvdimm_namespace_capacity(ndns));\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t \n\tnsio = to_nd_namespace_io(&ndns->dev);\n\tres = &nsio->res;\n\tres_size = resource_size(res);\n\tif (offset >= res_size) {\n\t\tdev_err(&nd_pfn->dev, \"pfn array size exceeds capacity of %s\\n\",\n\t\t\t\tdev_name(&ndns->dev));\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif ((align && !IS_ALIGNED(res->start + offset + start_pad, align))\n\t\t\t|| !IS_ALIGNED(offset, PAGE_SIZE)) {\n\t\tdev_err(&nd_pfn->dev,\n\t\t\t\t\"bad offset: %#llx dax disabled align: %#lx\\n\",\n\t\t\t\toffset, align);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (!IS_ALIGNED(res->start + start_pad, memremap_compat_align())) {\n\t\tdev_err(&nd_pfn->dev, \"resource start misaligned\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (!IS_ALIGNED(res->end + 1 - end_trunc, memremap_compat_align())) {\n\t\tdev_err(&nd_pfn->dev, \"resource end misaligned\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (offset >= (res_size - start_pad - end_trunc)) {\n\t\tdev_err(&nd_pfn->dev, \"bad offset with small namespace\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL(nd_pfn_validate);\n\nint nd_pfn_probe(struct device *dev, struct nd_namespace_common *ndns)\n{\n\tint rc;\n\tstruct nd_pfn *nd_pfn;\n\tstruct device *pfn_dev;\n\tstruct nd_pfn_sb *pfn_sb;\n\tstruct nd_region *nd_region = to_nd_region(ndns->dev.parent);\n\n\tif (ndns->force_raw)\n\t\treturn -ENODEV;\n\n\tswitch (ndns->claim_class) {\n\tcase NVDIMM_CCLASS_NONE:\n\tcase NVDIMM_CCLASS_PFN:\n\t\tbreak;\n\tdefault:\n\t\treturn -ENODEV;\n\t}\n\n\tnvdimm_bus_lock(&ndns->dev);\n\tnd_pfn = nd_pfn_alloc(nd_region);\n\tpfn_dev = nd_pfn_devinit(nd_pfn, ndns);\n\tnvdimm_bus_unlock(&ndns->dev);\n\tif (!pfn_dev)\n\t\treturn -ENOMEM;\n\tpfn_sb = devm_kmalloc(dev, sizeof(*pfn_sb), GFP_KERNEL);\n\tnd_pfn = to_nd_pfn(pfn_dev);\n\tnd_pfn->pfn_sb = pfn_sb;\n\trc = nd_pfn_validate(nd_pfn, PFN_SIG);\n\tdev_dbg(dev, \"pfn: %s\\n\", rc == 0 ? dev_name(pfn_dev) : \"<none>\");\n\tif (rc < 0) {\n\t\tnd_detach_ndns(pfn_dev, &nd_pfn->ndns);\n\t\tput_device(pfn_dev);\n\t} else\n\t\tnd_device_register(pfn_dev);\n\n\treturn rc;\n}\nEXPORT_SYMBOL(nd_pfn_probe);\n\n \nstatic unsigned long init_altmap_base(resource_size_t base)\n{\n\tunsigned long base_pfn = PHYS_PFN(base);\n\n\treturn SUBSECTION_ALIGN_DOWN(base_pfn);\n}\n\nstatic unsigned long init_altmap_reserve(resource_size_t base)\n{\n\tunsigned long reserve = nd_info_block_reserve() >> PAGE_SHIFT;\n\tunsigned long base_pfn = PHYS_PFN(base);\n\n\treserve += base_pfn - SUBSECTION_ALIGN_DOWN(base_pfn);\n\treturn reserve;\n}\n\nstatic int __nvdimm_setup_pfn(struct nd_pfn *nd_pfn, struct dev_pagemap *pgmap)\n{\n\tstruct range *range = &pgmap->range;\n\tstruct vmem_altmap *altmap = &pgmap->altmap;\n\tstruct nd_pfn_sb *pfn_sb = nd_pfn->pfn_sb;\n\tu64 offset = le64_to_cpu(pfn_sb->dataoff);\n\tu32 start_pad = __le32_to_cpu(pfn_sb->start_pad);\n\tu32 end_trunc = __le32_to_cpu(pfn_sb->end_trunc);\n\tu32 reserve = nd_info_block_reserve();\n\tstruct nd_namespace_common *ndns = nd_pfn->ndns;\n\tstruct nd_namespace_io *nsio = to_nd_namespace_io(&ndns->dev);\n\tresource_size_t base = nsio->res.start + start_pad;\n\tresource_size_t end = nsio->res.end - end_trunc;\n\tstruct vmem_altmap __altmap = {\n\t\t.base_pfn = init_altmap_base(base),\n\t\t.reserve = init_altmap_reserve(base),\n\t\t.end_pfn = PHYS_PFN(end),\n\t};\n\n\t*range = (struct range) {\n\t\t.start = nsio->res.start + start_pad,\n\t\t.end = nsio->res.end - end_trunc,\n\t};\n\tpgmap->nr_range = 1;\n\tif (nd_pfn->mode == PFN_MODE_RAM) {\n\t\tif (offset < reserve)\n\t\t\treturn -EINVAL;\n\t\tnd_pfn->npfns = le64_to_cpu(pfn_sb->npfns);\n\t} else if (nd_pfn->mode == PFN_MODE_PMEM) {\n\t\tnd_pfn->npfns = PHYS_PFN((range_len(range) - offset));\n\t\tif (le64_to_cpu(nd_pfn->pfn_sb->npfns) > nd_pfn->npfns)\n\t\t\tdev_info(&nd_pfn->dev,\n\t\t\t\t\t\"number of pfns truncated from %lld to %ld\\n\",\n\t\t\t\t\tle64_to_cpu(nd_pfn->pfn_sb->npfns),\n\t\t\t\t\tnd_pfn->npfns);\n\t\tmemcpy(altmap, &__altmap, sizeof(*altmap));\n\t\taltmap->free = PHYS_PFN(offset - reserve);\n\t\taltmap->alloc = 0;\n\t\tpgmap->flags |= PGMAP_ALTMAP_VALID;\n\t} else\n\t\treturn -ENXIO;\n\n\treturn 0;\n}\n\nstatic int nd_pfn_init(struct nd_pfn *nd_pfn)\n{\n\tstruct nd_namespace_common *ndns = nd_pfn->ndns;\n\tstruct nd_namespace_io *nsio = to_nd_namespace_io(&ndns->dev);\n\tresource_size_t start, size;\n\tstruct nd_region *nd_region;\n\tunsigned long npfns, align;\n\tu32 end_trunc;\n\tstruct nd_pfn_sb *pfn_sb;\n\tphys_addr_t offset;\n\tconst char *sig;\n\tu64 checksum;\n\tint rc;\n\n\tpfn_sb = devm_kmalloc(&nd_pfn->dev, sizeof(*pfn_sb), GFP_KERNEL);\n\tif (!pfn_sb)\n\t\treturn -ENOMEM;\n\n\tnd_pfn->pfn_sb = pfn_sb;\n\tif (is_nd_dax(&nd_pfn->dev))\n\t\tsig = DAX_SIG;\n\telse\n\t\tsig = PFN_SIG;\n\n\trc = nd_pfn_validate(nd_pfn, sig);\n\tif (rc == 0)\n\t\treturn nd_pfn_clear_memmap_errors(nd_pfn);\n\tif (rc != -ENODEV)\n\t\treturn rc;\n\n\t ;\n\tmemset(pfn_sb, 0, sizeof(*pfn_sb));\n\n\tnd_region = to_nd_region(nd_pfn->dev.parent);\n\tif (nd_region->ro) {\n\t\tdev_info(&nd_pfn->dev,\n\t\t\t\t\"%s is read-only, unable to init metadata\\n\",\n\t\t\t\tdev_name(&nd_region->dev));\n\t\treturn -ENXIO;\n\t}\n\n\tstart = nsio->res.start;\n\tsize = resource_size(&nsio->res);\n\tnpfns = PHYS_PFN(size - SZ_8K);\n\talign = max(nd_pfn->align, memremap_compat_align());\n\n\t \n\tif (!IS_ALIGNED(start, memremap_compat_align())) {\n\t\tdev_err(&nd_pfn->dev, \"%s: start %pa misaligned to %#lx\\n\",\n\t\t\t\tdev_name(&ndns->dev), &start,\n\t\t\t\tmemremap_compat_align());\n\t\treturn -EINVAL;\n\t}\n\tend_trunc = start + size - ALIGN_DOWN(start + size, align);\n\tif (nd_pfn->mode == PFN_MODE_PMEM) {\n\t\tunsigned long page_map_size = MAX_STRUCT_PAGE_SIZE * npfns;\n\n\t\t \n\t\tif (sizeof(struct page) > MAX_STRUCT_PAGE_SIZE) {\n\t\t\tif (page_struct_override)\n\t\t\t\tpage_map_size = sizeof(struct page) * npfns;\n\t\t\telse {\n\t\t\t\tdev_err(&nd_pfn->dev,\n\t\t\t\t\t\"Memory debug options prevent using pmem for the page map\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t\toffset = ALIGN(start + SZ_8K + page_map_size, align) - start;\n\t} else if (nd_pfn->mode == PFN_MODE_RAM)\n\t\toffset = ALIGN(start + SZ_8K, align) - start;\n\telse\n\t\treturn -ENXIO;\n\n\tif (offset >= (size - end_trunc)) {\n\t\t \n\t\tdev_err(&nd_pfn->dev, \"%s unable to satisfy requested alignment\\n\",\n\t\t\t\tdev_name(&ndns->dev));\n\t\treturn -ENXIO;\n\t}\n\n\tnpfns = PHYS_PFN(size - offset - end_trunc);\n\tpfn_sb->mode = cpu_to_le32(nd_pfn->mode);\n\tpfn_sb->dataoff = cpu_to_le64(offset);\n\tpfn_sb->npfns = cpu_to_le64(npfns);\n\tmemcpy(pfn_sb->signature, sig, PFN_SIG_LEN);\n\tmemcpy(pfn_sb->uuid, nd_pfn->uuid, 16);\n\tmemcpy(pfn_sb->parent_uuid, nd_dev_to_uuid(&ndns->dev), 16);\n\tpfn_sb->version_major = cpu_to_le16(1);\n\tpfn_sb->version_minor = cpu_to_le16(4);\n\tpfn_sb->end_trunc = cpu_to_le32(end_trunc);\n\tpfn_sb->align = cpu_to_le32(nd_pfn->align);\n\tif (sizeof(struct page) > MAX_STRUCT_PAGE_SIZE && page_struct_override)\n\t\tpfn_sb->page_struct_size = cpu_to_le16(sizeof(struct page));\n\telse\n\t\tpfn_sb->page_struct_size = cpu_to_le16(MAX_STRUCT_PAGE_SIZE);\n\tpfn_sb->page_size = cpu_to_le32(PAGE_SIZE);\n\tchecksum = nd_sb_checksum((struct nd_gen_sb *) pfn_sb);\n\tpfn_sb->checksum = cpu_to_le64(checksum);\n\n\trc = nd_pfn_clear_memmap_errors(nd_pfn);\n\tif (rc)\n\t\treturn rc;\n\n\treturn nvdimm_write_bytes(ndns, SZ_4K, pfn_sb, sizeof(*pfn_sb), 0);\n}\n\n \nint nvdimm_setup_pfn(struct nd_pfn *nd_pfn, struct dev_pagemap *pgmap)\n{\n\tint rc;\n\n\tif (!nd_pfn->uuid || !nd_pfn->ndns)\n\t\treturn -ENODEV;\n\n\trc = nd_pfn_init(nd_pfn);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\treturn __nvdimm_setup_pfn(nd_pfn, pgmap);\n}\nEXPORT_SYMBOL_GPL(nvdimm_setup_pfn);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}