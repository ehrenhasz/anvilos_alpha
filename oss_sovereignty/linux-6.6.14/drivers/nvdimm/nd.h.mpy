{
  "module_name": "nd.h",
  "hash_id": "9caf4ec0fdc2545ee8e6c6667a6f8f7be90fe3bb8a94663470461ef2128fa72e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/nvdimm/nd.h",
  "human_readable_source": " \n \n#ifndef __ND_H__\n#define __ND_H__\n#include <linux/libnvdimm.h>\n#include <linux/badblocks.h>\n#include <linux/blkdev.h>\n#include <linux/device.h>\n#include <linux/mutex.h>\n#include <linux/ndctl.h>\n#include <linux/types.h>\n#include <linux/nd.h>\n#include \"label.h\"\n\nenum {\n\t \n\tND_MAX_LANES = 256,\n\tINT_LBASIZE_ALIGNMENT = 64,\n\tNVDIMM_IO_ATOMIC = 1,\n};\n\nstruct nvdimm_drvdata {\n\tstruct device *dev;\n\tint nslabel_size;\n\tstruct nd_cmd_get_config_size nsarea;\n\tvoid *data;\n\tbool cxl;\n\tint ns_current, ns_next;\n\tstruct resource dpa;\n\tstruct kref kref;\n};\n\nstatic inline const u8 *nsl_ref_name(struct nvdimm_drvdata *ndd,\n\t\t\t\t     struct nd_namespace_label *nd_label)\n{\n\tif (ndd->cxl)\n\t\treturn nd_label->cxl.name;\n\treturn nd_label->efi.name;\n}\n\nstatic inline u8 *nsl_get_name(struct nvdimm_drvdata *ndd,\n\t\t\t       struct nd_namespace_label *nd_label, u8 *name)\n{\n\tif (ndd->cxl)\n\t\treturn memcpy(name, nd_label->cxl.name, NSLABEL_NAME_LEN);\n\treturn memcpy(name, nd_label->efi.name, NSLABEL_NAME_LEN);\n}\n\nstatic inline u8 *nsl_set_name(struct nvdimm_drvdata *ndd,\n\t\t\t       struct nd_namespace_label *nd_label, u8 *name)\n{\n\tif (!name)\n\t\treturn NULL;\n\tif (ndd->cxl)\n\t\treturn memcpy(nd_label->cxl.name, name, NSLABEL_NAME_LEN);\n\treturn memcpy(nd_label->efi.name, name, NSLABEL_NAME_LEN);\n}\n\nstatic inline u32 nsl_get_slot(struct nvdimm_drvdata *ndd,\n\t\t\t       struct nd_namespace_label *nd_label)\n{\n\tif (ndd->cxl)\n\t\treturn __le32_to_cpu(nd_label->cxl.slot);\n\treturn __le32_to_cpu(nd_label->efi.slot);\n}\n\nstatic inline void nsl_set_slot(struct nvdimm_drvdata *ndd,\n\t\t\t\tstruct nd_namespace_label *nd_label, u32 slot)\n{\n\tif (ndd->cxl)\n\t\tnd_label->cxl.slot = __cpu_to_le32(slot);\n\telse\n\t\tnd_label->efi.slot = __cpu_to_le32(slot);\n}\n\nstatic inline u64 nsl_get_checksum(struct nvdimm_drvdata *ndd,\n\t\t\t\t   struct nd_namespace_label *nd_label)\n{\n\tif (ndd->cxl)\n\t\treturn __le64_to_cpu(nd_label->cxl.checksum);\n\treturn __le64_to_cpu(nd_label->efi.checksum);\n}\n\nstatic inline void nsl_set_checksum(struct nvdimm_drvdata *ndd,\n\t\t\t\t    struct nd_namespace_label *nd_label,\n\t\t\t\t    u64 checksum)\n{\n\tif (ndd->cxl)\n\t\tnd_label->cxl.checksum = __cpu_to_le64(checksum);\n\telse\n\t\tnd_label->efi.checksum = __cpu_to_le64(checksum);\n}\n\nstatic inline u32 nsl_get_flags(struct nvdimm_drvdata *ndd,\n\t\t\t\tstruct nd_namespace_label *nd_label)\n{\n\tif (ndd->cxl)\n\t\treturn __le32_to_cpu(nd_label->cxl.flags);\n\treturn __le32_to_cpu(nd_label->efi.flags);\n}\n\nstatic inline void nsl_set_flags(struct nvdimm_drvdata *ndd,\n\t\t\t\t struct nd_namespace_label *nd_label, u32 flags)\n{\n\tif (ndd->cxl)\n\t\tnd_label->cxl.flags = __cpu_to_le32(flags);\n\telse\n\t\tnd_label->efi.flags = __cpu_to_le32(flags);\n}\n\nstatic inline u64 nsl_get_dpa(struct nvdimm_drvdata *ndd,\n\t\t\t      struct nd_namespace_label *nd_label)\n{\n\tif (ndd->cxl)\n\t\treturn __le64_to_cpu(nd_label->cxl.dpa);\n\treturn __le64_to_cpu(nd_label->efi.dpa);\n}\n\nstatic inline void nsl_set_dpa(struct nvdimm_drvdata *ndd,\n\t\t\t       struct nd_namespace_label *nd_label, u64 dpa)\n{\n\tif (ndd->cxl)\n\t\tnd_label->cxl.dpa = __cpu_to_le64(dpa);\n\telse\n\t\tnd_label->efi.dpa = __cpu_to_le64(dpa);\n}\n\nstatic inline u64 nsl_get_rawsize(struct nvdimm_drvdata *ndd,\n\t\t\t\t  struct nd_namespace_label *nd_label)\n{\n\tif (ndd->cxl)\n\t\treturn __le64_to_cpu(nd_label->cxl.rawsize);\n\treturn __le64_to_cpu(nd_label->efi.rawsize);\n}\n\nstatic inline void nsl_set_rawsize(struct nvdimm_drvdata *ndd,\n\t\t\t\t   struct nd_namespace_label *nd_label,\n\t\t\t\t   u64 rawsize)\n{\n\tif (ndd->cxl)\n\t\tnd_label->cxl.rawsize = __cpu_to_le64(rawsize);\n\telse\n\t\tnd_label->efi.rawsize = __cpu_to_le64(rawsize);\n}\n\nstatic inline u64 nsl_get_isetcookie(struct nvdimm_drvdata *ndd,\n\t\t\t\t     struct nd_namespace_label *nd_label)\n{\n\t \n\tif (dev_WARN_ONCE(ndd->dev, ndd->cxl,\n\t\t\t  \"CXL labels do not use the isetcookie concept\\n\"))\n\t\treturn 0;\n\treturn __le64_to_cpu(nd_label->efi.isetcookie);\n}\n\nstatic inline void nsl_set_isetcookie(struct nvdimm_drvdata *ndd,\n\t\t\t\t      struct nd_namespace_label *nd_label,\n\t\t\t\t      u64 isetcookie)\n{\n\tif (!ndd->cxl)\n\t\tnd_label->efi.isetcookie = __cpu_to_le64(isetcookie);\n}\n\nstatic inline bool nsl_validate_isetcookie(struct nvdimm_drvdata *ndd,\n\t\t\t\t\t   struct nd_namespace_label *nd_label,\n\t\t\t\t\t   u64 cookie)\n{\n\t \n\tif (ndd->cxl)\n\t\treturn true;\n\treturn cookie == __le64_to_cpu(nd_label->efi.isetcookie);\n}\n\nstatic inline u16 nsl_get_position(struct nvdimm_drvdata *ndd,\n\t\t\t\t   struct nd_namespace_label *nd_label)\n{\n\tif (ndd->cxl)\n\t\treturn __le16_to_cpu(nd_label->cxl.position);\n\treturn __le16_to_cpu(nd_label->efi.position);\n}\n\nstatic inline void nsl_set_position(struct nvdimm_drvdata *ndd,\n\t\t\t\t    struct nd_namespace_label *nd_label,\n\t\t\t\t    u16 position)\n{\n\tif (ndd->cxl)\n\t\tnd_label->cxl.position = __cpu_to_le16(position);\n\telse\n\t\tnd_label->efi.position = __cpu_to_le16(position);\n}\n\nstatic inline u16 nsl_get_nlabel(struct nvdimm_drvdata *ndd,\n\t\t\t\t struct nd_namespace_label *nd_label)\n{\n\tif (ndd->cxl)\n\t\treturn 0;\n\treturn __le16_to_cpu(nd_label->efi.nlabel);\n}\n\nstatic inline void nsl_set_nlabel(struct nvdimm_drvdata *ndd,\n\t\t\t\t  struct nd_namespace_label *nd_label,\n\t\t\t\t  u16 nlabel)\n{\n\tif (!ndd->cxl)\n\t\tnd_label->efi.nlabel = __cpu_to_le16(nlabel);\n}\n\nstatic inline u16 nsl_get_nrange(struct nvdimm_drvdata *ndd,\n\t\t\t\t struct nd_namespace_label *nd_label)\n{\n\tif (ndd->cxl)\n\t\treturn __le16_to_cpu(nd_label->cxl.nrange);\n\treturn 1;\n}\n\nstatic inline void nsl_set_nrange(struct nvdimm_drvdata *ndd,\n\t\t\t\t  struct nd_namespace_label *nd_label,\n\t\t\t\t  u16 nrange)\n{\n\tif (ndd->cxl)\n\t\tnd_label->cxl.nrange = __cpu_to_le16(nrange);\n}\n\nstatic inline u64 nsl_get_lbasize(struct nvdimm_drvdata *ndd,\n\t\t\t\t  struct nd_namespace_label *nd_label)\n{\n\t \n\tif (ndd->cxl)\n\t\treturn __le16_to_cpu(nd_label->cxl.lbasize);\n\treturn __le64_to_cpu(nd_label->efi.lbasize);\n}\n\nstatic inline void nsl_set_lbasize(struct nvdimm_drvdata *ndd,\n\t\t\t\t   struct nd_namespace_label *nd_label,\n\t\t\t\t   u64 lbasize)\n{\n\tif (ndd->cxl)\n\t\tnd_label->cxl.lbasize = __cpu_to_le16(lbasize);\n\telse\n\t\tnd_label->efi.lbasize = __cpu_to_le64(lbasize);\n}\n\nstatic inline const uuid_t *nsl_get_uuid(struct nvdimm_drvdata *ndd,\n\t\t\t\t\t struct nd_namespace_label *nd_label,\n\t\t\t\t\t uuid_t *uuid)\n{\n\tif (ndd->cxl)\n\t\timport_uuid(uuid, nd_label->cxl.uuid);\n\telse\n\t\timport_uuid(uuid, nd_label->efi.uuid);\n\treturn uuid;\n}\n\nstatic inline const uuid_t *nsl_set_uuid(struct nvdimm_drvdata *ndd,\n\t\t\t\t\t struct nd_namespace_label *nd_label,\n\t\t\t\t\t const uuid_t *uuid)\n{\n\tif (ndd->cxl)\n\t\texport_uuid(nd_label->cxl.uuid, uuid);\n\telse\n\t\texport_uuid(nd_label->efi.uuid, uuid);\n\treturn uuid;\n}\n\nstatic inline bool nsl_uuid_equal(struct nvdimm_drvdata *ndd,\n\t\t\t\t  struct nd_namespace_label *nd_label,\n\t\t\t\t  const uuid_t *uuid)\n{\n\tuuid_t tmp;\n\n\tif (ndd->cxl)\n\t\timport_uuid(&tmp, nd_label->cxl.uuid);\n\telse\n\t\timport_uuid(&tmp, nd_label->efi.uuid);\n\treturn uuid_equal(&tmp, uuid);\n}\n\nstatic inline const u8 *nsl_uuid_raw(struct nvdimm_drvdata *ndd,\n\t\t\t\t     struct nd_namespace_label *nd_label)\n{\n\tif (ndd->cxl)\n\t\treturn nd_label->cxl.uuid;\n\treturn nd_label->efi.uuid;\n}\n\nbool nsl_validate_type_guid(struct nvdimm_drvdata *ndd,\n\t\t\t    struct nd_namespace_label *nd_label, guid_t *guid);\nenum nvdimm_claim_class nsl_get_claim_class(struct nvdimm_drvdata *ndd,\n\t\t\t\t\t    struct nd_namespace_label *nd_label);\n\nstruct nd_region_data {\n\tint ns_count;\n\tint ns_active;\n\tunsigned int hints_shift;\n\tvoid __iomem *flush_wpq[];\n};\n\nstatic inline void __iomem *ndrd_get_flush_wpq(struct nd_region_data *ndrd,\n\t\tint dimm, int hint)\n{\n\tunsigned int num = 1 << ndrd->hints_shift;\n\tunsigned int mask = num - 1;\n\n\treturn ndrd->flush_wpq[dimm * num + (hint & mask)];\n}\n\nstatic inline void ndrd_set_flush_wpq(struct nd_region_data *ndrd, int dimm,\n\t\tint hint, void __iomem *flush)\n{\n\tunsigned int num = 1 << ndrd->hints_shift;\n\tunsigned int mask = num - 1;\n\n\tndrd->flush_wpq[dimm * num + (hint & mask)] = flush;\n}\n\nstatic inline struct nd_namespace_index *to_namespace_index(\n\t\tstruct nvdimm_drvdata *ndd, int i)\n{\n\tif (i < 0)\n\t\treturn NULL;\n\n\treturn ndd->data + sizeof_namespace_index(ndd) * i;\n}\n\nstatic inline struct nd_namespace_index *to_current_namespace_index(\n\t\tstruct nvdimm_drvdata *ndd)\n{\n\treturn to_namespace_index(ndd, ndd->ns_current);\n}\n\nstatic inline struct nd_namespace_index *to_next_namespace_index(\n\t\tstruct nvdimm_drvdata *ndd)\n{\n\treturn to_namespace_index(ndd, ndd->ns_next);\n}\n\nunsigned sizeof_namespace_label(struct nvdimm_drvdata *ndd);\n\n#define efi_namespace_label_has(ndd, field) \\\n\t(!ndd->cxl && offsetof(struct nvdimm_efi_label, field) \\\n\t\t< sizeof_namespace_label(ndd))\n\n#define nd_dbg_dpa(r, d, res, fmt, arg...) \\\n\tdev_dbg((r) ? &(r)->dev : (d)->dev, \"%s: %.13s: %#llx @ %#llx \" fmt, \\\n\t\t(r) ? dev_name((d)->dev) : \"\", res ? res->name : \"null\", \\\n\t\t(unsigned long long) (res ? resource_size(res) : 0), \\\n\t\t(unsigned long long) (res ? res->start : 0), ##arg)\n\n#define for_each_dpa_resource(ndd, res) \\\n\tfor (res = (ndd)->dpa.child; res; res = res->sibling)\n\n#define for_each_dpa_resource_safe(ndd, res, next) \\\n\tfor (res = (ndd)->dpa.child, next = res ? res->sibling : NULL; \\\n\t\t\tres; res = next, next = next ? next->sibling : NULL)\n\nstruct nd_percpu_lane {\n\tint count;\n\tspinlock_t lock;\n};\n\nenum nd_label_flags {\n\tND_LABEL_REAP,\n};\nstruct nd_label_ent {\n\tstruct list_head list;\n\tunsigned long flags;\n\tstruct nd_namespace_label *label;\n};\n\nenum nd_mapping_lock_class {\n\tND_MAPPING_CLASS0,\n\tND_MAPPING_UUID_SCAN,\n};\n\nstruct nd_mapping {\n\tstruct nvdimm *nvdimm;\n\tu64 start;\n\tu64 size;\n\tint position;\n\tstruct list_head labels;\n\tstruct mutex lock;\n\t \n\tstruct nvdimm_drvdata *ndd;\n};\n\nstruct nd_region {\n\tstruct device dev;\n\tstruct ida ns_ida;\n\tstruct ida btt_ida;\n\tstruct ida pfn_ida;\n\tstruct ida dax_ida;\n\tunsigned long flags;\n\tstruct device *ns_seed;\n\tstruct device *btt_seed;\n\tstruct device *pfn_seed;\n\tstruct device *dax_seed;\n\tunsigned long align;\n\tu16 ndr_mappings;\n\tu64 ndr_size;\n\tu64 ndr_start;\n\tint id, num_lanes, ro, numa_node, target_node;\n\tvoid *provider_data;\n\tstruct kernfs_node *bb_state;\n\tstruct badblocks bb;\n\tstruct nd_interleave_set *nd_set;\n\tstruct nd_percpu_lane __percpu *lane;\n\tint (*flush)(struct nd_region *nd_region, struct bio *bio);\n\tstruct nd_mapping mapping[];\n};\n\nstatic inline bool nsl_validate_nlabel(struct nd_region *nd_region,\n\t\t\t\t       struct nvdimm_drvdata *ndd,\n\t\t\t\t       struct nd_namespace_label *nd_label)\n{\n\tif (ndd->cxl)\n\t\treturn true;\n\treturn nsl_get_nlabel(ndd, nd_label) == nd_region->ndr_mappings;\n}\n\n \nstatic inline unsigned nd_inc_seq(unsigned seq)\n{\n\tstatic const unsigned next[] = { 0, 2, 3, 1 };\n\n\treturn next[seq & 3];\n}\n\nstruct btt;\nstruct nd_btt {\n\tstruct device dev;\n\tstruct nd_namespace_common *ndns;\n\tstruct btt *btt;\n\tunsigned long lbasize;\n\tu64 size;\n\tuuid_t *uuid;\n\tint id;\n\tint initial_offset;\n\tu16 version_major;\n\tu16 version_minor;\n};\n\nenum nd_pfn_mode {\n\tPFN_MODE_NONE,\n\tPFN_MODE_RAM,\n\tPFN_MODE_PMEM,\n};\n\nstruct nd_pfn {\n\tint id;\n\tuuid_t *uuid;\n\tstruct device dev;\n\tunsigned long align;\n\tunsigned long npfns;\n\tenum nd_pfn_mode mode;\n\tstruct nd_pfn_sb *pfn_sb;\n\tstruct nd_namespace_common *ndns;\n};\n\nstruct nd_dax {\n\tstruct nd_pfn nd_pfn;\n};\n\nstatic inline u32 nd_info_block_reserve(void)\n{\n\treturn ALIGN(SZ_8K, PAGE_SIZE);\n}\n\nenum nd_async_mode {\n\tND_SYNC,\n\tND_ASYNC,\n};\n\nint nd_integrity_init(struct gendisk *disk, unsigned long meta_size);\nvoid wait_nvdimm_bus_probe_idle(struct device *dev);\nvoid nd_device_register(struct device *dev);\nvoid nd_device_unregister(struct device *dev, enum nd_async_mode mode);\nvoid nd_device_notify(struct device *dev, enum nvdimm_event event);\nint nd_uuid_store(struct device *dev, uuid_t **uuid_out, const char *buf,\n\t\tsize_t len);\nssize_t nd_size_select_show(unsigned long current_size,\n\t\tconst unsigned long *supported, char *buf);\nssize_t nd_size_select_store(struct device *dev, const char *buf,\n\t\tunsigned long *current_size, const unsigned long *supported);\nint __init nvdimm_init(void);\nint __init nd_region_init(void);\nint __init nd_label_init(void);\nvoid nvdimm_exit(void);\nvoid nd_region_exit(void);\nstruct nvdimm;\nextern const struct attribute_group nd_device_attribute_group;\nextern const struct attribute_group nd_numa_attribute_group;\nextern const struct attribute_group *nvdimm_bus_attribute_groups[];\nstruct nvdimm_drvdata *to_ndd(struct nd_mapping *nd_mapping);\nint nvdimm_check_config_data(struct device *dev);\nint nvdimm_init_nsarea(struct nvdimm_drvdata *ndd);\nint nvdimm_init_config_data(struct nvdimm_drvdata *ndd);\nint nvdimm_get_config_data(struct nvdimm_drvdata *ndd, void *buf,\n\t\t\t   size_t offset, size_t len);\nint nvdimm_set_config_data(struct nvdimm_drvdata *ndd, size_t offset,\n\t\tvoid *buf, size_t len);\nlong nvdimm_clear_poison(struct device *dev, phys_addr_t phys,\n\t\tunsigned int len);\nvoid nvdimm_set_labeling(struct device *dev);\nvoid nvdimm_set_locked(struct device *dev);\nvoid nvdimm_clear_locked(struct device *dev);\nint nvdimm_security_setup_events(struct device *dev);\n#if IS_ENABLED(CONFIG_NVDIMM_KEYS)\nint nvdimm_security_unlock(struct device *dev);\n#else\nstatic inline int nvdimm_security_unlock(struct device *dev)\n{\n\treturn 0;\n}\n#endif\nstruct nd_btt *to_nd_btt(struct device *dev);\n\nstruct nd_gen_sb {\n\tchar reserved[SZ_4K - 8];\n\t__le64 checksum;\n};\n\nu64 nd_sb_checksum(struct nd_gen_sb *sb);\n#if IS_ENABLED(CONFIG_BTT)\nint nd_btt_probe(struct device *dev, struct nd_namespace_common *ndns);\nbool is_nd_btt(struct device *dev);\nstruct device *nd_btt_create(struct nd_region *nd_region);\n#else\nstatic inline int nd_btt_probe(struct device *dev,\n\t\tstruct nd_namespace_common *ndns)\n{\n\treturn -ENODEV;\n}\n\nstatic inline bool is_nd_btt(struct device *dev)\n{\n\treturn false;\n}\n\nstatic inline struct device *nd_btt_create(struct nd_region *nd_region)\n{\n\treturn NULL;\n}\n#endif\n\nstruct nd_pfn *to_nd_pfn(struct device *dev);\n#if IS_ENABLED(CONFIG_NVDIMM_PFN)\n\n#define MAX_NVDIMM_ALIGN\t4\n\nint nd_pfn_probe(struct device *dev, struct nd_namespace_common *ndns);\nbool is_nd_pfn(struct device *dev);\nstruct device *nd_pfn_create(struct nd_region *nd_region);\nstruct device *nd_pfn_devinit(struct nd_pfn *nd_pfn,\n\t\tstruct nd_namespace_common *ndns);\nint nd_pfn_validate(struct nd_pfn *nd_pfn, const char *sig);\nextern const struct attribute_group *nd_pfn_attribute_groups[];\n#else\nstatic inline int nd_pfn_probe(struct device *dev,\n\t\tstruct nd_namespace_common *ndns)\n{\n\treturn -ENODEV;\n}\n\nstatic inline bool is_nd_pfn(struct device *dev)\n{\n\treturn false;\n}\n\nstatic inline struct device *nd_pfn_create(struct nd_region *nd_region)\n{\n\treturn NULL;\n}\n\nstatic inline int nd_pfn_validate(struct nd_pfn *nd_pfn, const char *sig)\n{\n\treturn -ENODEV;\n}\n#endif\n\nstruct nd_dax *to_nd_dax(struct device *dev);\n#if IS_ENABLED(CONFIG_NVDIMM_DAX)\nint nd_dax_probe(struct device *dev, struct nd_namespace_common *ndns);\nbool is_nd_dax(const struct device *dev);\nstruct device *nd_dax_create(struct nd_region *nd_region);\n#else\nstatic inline int nd_dax_probe(struct device *dev,\n\t\tstruct nd_namespace_common *ndns)\n{\n\treturn -ENODEV;\n}\n\nstatic inline bool is_nd_dax(const struct device *dev)\n{\n\treturn false;\n}\n\nstatic inline struct device *nd_dax_create(struct nd_region *nd_region)\n{\n\treturn NULL;\n}\n#endif\n\nint nd_region_to_nstype(struct nd_region *nd_region);\nint nd_region_register_namespaces(struct nd_region *nd_region, int *err);\nu64 nd_region_interleave_set_cookie(struct nd_region *nd_region,\n\t\tstruct nd_namespace_index *nsindex);\nu64 nd_region_interleave_set_altcookie(struct nd_region *nd_region);\nvoid nvdimm_bus_lock(struct device *dev);\nvoid nvdimm_bus_unlock(struct device *dev);\nbool is_nvdimm_bus_locked(struct device *dev);\nvoid nvdimm_check_and_set_ro(struct gendisk *disk);\nvoid nvdimm_drvdata_release(struct kref *kref);\nvoid put_ndd(struct nvdimm_drvdata *ndd);\nint nd_label_reserve_dpa(struct nvdimm_drvdata *ndd);\nvoid nvdimm_free_dpa(struct nvdimm_drvdata *ndd, struct resource *res);\nstruct resource *nvdimm_allocate_dpa(struct nvdimm_drvdata *ndd,\n\t\tstruct nd_label_id *label_id, resource_size_t start,\n\t\tresource_size_t n);\nresource_size_t nvdimm_namespace_capacity(struct nd_namespace_common *ndns);\nbool nvdimm_namespace_locked(struct nd_namespace_common *ndns);\nstruct nd_namespace_common *nvdimm_namespace_common_probe(struct device *dev);\nint nvdimm_namespace_attach_btt(struct nd_namespace_common *ndns);\nint nvdimm_namespace_detach_btt(struct nd_btt *nd_btt);\nconst char *nvdimm_namespace_disk_name(struct nd_namespace_common *ndns,\n\t\tchar *name);\nunsigned int pmem_sector_size(struct nd_namespace_common *ndns);\nstruct range;\nvoid nvdimm_badblocks_populate(struct nd_region *nd_region,\n\t\tstruct badblocks *bb, const struct range *range);\nint devm_namespace_enable(struct device *dev, struct nd_namespace_common *ndns,\n\t\tresource_size_t size);\nvoid devm_namespace_disable(struct device *dev,\n\t\tstruct nd_namespace_common *ndns);\n#if IS_ENABLED(CONFIG_ND_CLAIM)\n \n#define MAX_STRUCT_PAGE_SIZE 64\nint nvdimm_setup_pfn(struct nd_pfn *nd_pfn, struct dev_pagemap *pgmap);\n#else\nstatic inline int nvdimm_setup_pfn(struct nd_pfn *nd_pfn,\n\t\t\t\t   struct dev_pagemap *pgmap)\n{\n\treturn -ENXIO;\n}\n#endif\nint nd_region_activate(struct nd_region *nd_region);\nstatic inline bool is_bad_pmem(struct badblocks *bb, sector_t sector,\n\t\tunsigned int len)\n{\n\tif (bb->count) {\n\t\tsector_t first_bad;\n\t\tint num_bad;\n\n\t\treturn !!badblocks_check(bb, sector, len / 512, &first_bad,\n\t\t\t\t&num_bad);\n\t}\n\n\treturn false;\n}\nconst uuid_t *nd_dev_to_uuid(struct device *dev);\nbool pmem_should_map_pages(struct device *dev);\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}