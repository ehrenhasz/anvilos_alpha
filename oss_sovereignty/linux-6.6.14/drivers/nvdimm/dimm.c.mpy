{
  "module_name": "dimm.c",
  "hash_id": "1abd8aaeedc12b0febbadf4f172ebe47d8745a63a9a58b2338f845665877cb27",
  "original_prompt": "Ingested from linux-6.6.14/drivers/nvdimm/dimm.c",
  "human_readable_source": "\n \n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/sizes.h>\n#include <linux/ndctl.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/nd.h>\n#include \"label.h\"\n#include \"nd.h\"\n\nstatic int nvdimm_probe(struct device *dev)\n{\n\tstruct nvdimm_drvdata *ndd;\n\tint rc;\n\n\trc = nvdimm_security_setup_events(dev);\n\tif (rc < 0) {\n\t\tdev_err(dev, \"security event setup failed: %d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\trc = nvdimm_check_config_data(dev);\n\tif (rc) {\n\t\t \n\t\tif (rc == -ENOTTY)\n\t\t\trc = 0;\n\t\treturn rc;\n\t}\n\n\t \n\tnvdimm_clear_locked(dev);\n\n\tndd = kzalloc(sizeof(*ndd), GFP_KERNEL);\n\tif (!ndd)\n\t\treturn -ENOMEM;\n\n\tdev_set_drvdata(dev, ndd);\n\tndd->dpa.name = dev_name(dev);\n\tndd->ns_current = -1;\n\tndd->ns_next = -1;\n\tndd->dpa.start = 0;\n\tndd->dpa.end = -1;\n\tndd->dev = dev;\n\tget_device(dev);\n\tkref_init(&ndd->kref);\n\n\t \n\trc = nvdimm_security_unlock(dev);\n\tif (rc < 0)\n\t\tdev_dbg(dev, \"failed to unlock dimm: %d\\n\", rc);\n\n\n\t \n\trc = nvdimm_init_nsarea(ndd);\n\tif (rc == -EACCES) {\n\t\t \n\t\tnvdimm_set_locked(dev);\n\t\trc = 0;\n\t}\n\tif (rc)\n\t\tgoto err;\n\n\t \n\trc = nd_label_data_init(ndd);\n\tif (rc == -EACCES)\n\t\tnvdimm_set_locked(dev);\n\tif (rc)\n\t\tgoto err;\n\n\tdev_dbg(dev, \"config data size: %d\\n\", ndd->nsarea.config_size);\n\n\tnvdimm_bus_lock(dev);\n\tif (ndd->ns_current >= 0) {\n\t\trc = nd_label_reserve_dpa(ndd);\n\t\tif (rc == 0)\n\t\t\tnvdimm_set_labeling(dev);\n\t}\n\tnvdimm_bus_unlock(dev);\n\n\tif (rc)\n\t\tgoto err;\n\n\treturn 0;\n\n err:\n\tput_ndd(ndd);\n\treturn rc;\n}\n\nstatic void nvdimm_remove(struct device *dev)\n{\n\tstruct nvdimm_drvdata *ndd = dev_get_drvdata(dev);\n\n\tnvdimm_bus_lock(dev);\n\tdev_set_drvdata(dev, NULL);\n\tnvdimm_bus_unlock(dev);\n\tput_ndd(ndd);\n}\n\nstatic struct nd_device_driver nvdimm_driver = {\n\t.probe = nvdimm_probe,\n\t.remove = nvdimm_remove,\n\t.drv = {\n\t\t.name = \"nvdimm\",\n\t},\n\t.type = ND_DRIVER_DIMM,\n};\n\nint __init nvdimm_init(void)\n{\n\treturn nd_driver_register(&nvdimm_driver);\n}\n\nvoid nvdimm_exit(void)\n{\n\tdriver_unregister(&nvdimm_driver.drv);\n}\n\nMODULE_ALIAS_ND_DEVICE(ND_DEVICE_DIMM);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}