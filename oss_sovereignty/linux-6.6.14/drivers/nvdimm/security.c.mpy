{
  "module_name": "security.c",
  "hash_id": "3c4b5cb455776b178fb99ecc3096ed7f9c168c59a08bc9be86d53ce8f9c27571",
  "original_prompt": "Ingested from linux-6.6.14/drivers/nvdimm/security.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/ndctl.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/key.h>\n#include <linux/key-type.h>\n#include <keys/user-type.h>\n#include <keys/encrypted-type.h>\n#include \"nd-core.h\"\n#include \"nd.h\"\n\n#define NVDIMM_BASE_KEY\t\t0\n#define NVDIMM_NEW_KEY\t\t1\n\nstatic bool key_revalidate = true;\nmodule_param(key_revalidate, bool, 0444);\nMODULE_PARM_DESC(key_revalidate, \"Require key validation at init.\");\n\nstatic const char zero_key[NVDIMM_PASSPHRASE_LEN];\n\nstatic void *key_data(struct key *key)\n{\n\tstruct encrypted_key_payload *epayload = dereference_key_locked(key);\n\n\tlockdep_assert_held_read(&key->sem);\n\n\treturn epayload->decrypted_data;\n}\n\nstatic void nvdimm_put_key(struct key *key)\n{\n\tif (!key)\n\t\treturn;\n\n\tup_read(&key->sem);\n\tkey_put(key);\n}\n\n \nstatic struct key *nvdimm_request_key(struct nvdimm *nvdimm)\n{\n\tstruct key *key = NULL;\n\tstatic const char NVDIMM_PREFIX[] = \"nvdimm:\";\n\tchar desc[NVDIMM_KEY_DESC_LEN + sizeof(NVDIMM_PREFIX)];\n\tstruct device *dev = &nvdimm->dev;\n\n\tsprintf(desc, \"%s%s\", NVDIMM_PREFIX, nvdimm->dimm_id);\n\tkey = request_key(&key_type_encrypted, desc, \"\");\n\tif (IS_ERR(key)) {\n\t\tif (PTR_ERR(key) == -ENOKEY)\n\t\t\tdev_dbg(dev, \"request_key() found no key\\n\");\n\t\telse\n\t\t\tdev_dbg(dev, \"request_key() upcall failed\\n\");\n\t\tkey = NULL;\n\t} else {\n\t\tstruct encrypted_key_payload *epayload;\n\n\t\tdown_read(&key->sem);\n\t\tepayload = dereference_key_locked(key);\n\t\tif (epayload->decrypted_datalen != NVDIMM_PASSPHRASE_LEN) {\n\t\t\tup_read(&key->sem);\n\t\t\tkey_put(key);\n\t\t\tkey = NULL;\n\t\t}\n\t}\n\n\treturn key;\n}\n\nstatic const void *nvdimm_get_key_payload(struct nvdimm *nvdimm,\n\t\tstruct key **key)\n{\n\t*key = nvdimm_request_key(nvdimm);\n\tif (!*key)\n\t\treturn zero_key;\n\n\treturn key_data(*key);\n}\n\nstatic struct key *nvdimm_lookup_user_key(struct nvdimm *nvdimm,\n\t\tkey_serial_t id, int subclass)\n{\n\tkey_ref_t keyref;\n\tstruct key *key;\n\tstruct encrypted_key_payload *epayload;\n\tstruct device *dev = &nvdimm->dev;\n\n\tkeyref = lookup_user_key(id, 0, KEY_NEED_SEARCH);\n\tif (IS_ERR(keyref))\n\t\treturn NULL;\n\n\tkey = key_ref_to_ptr(keyref);\n\tif (key->type != &key_type_encrypted) {\n\t\tkey_put(key);\n\t\treturn NULL;\n\t}\n\n\tdev_dbg(dev, \"%s: key found: %#x\\n\", __func__, key_serial(key));\n\n\tdown_read_nested(&key->sem, subclass);\n\tepayload = dereference_key_locked(key);\n\tif (epayload->decrypted_datalen != NVDIMM_PASSPHRASE_LEN) {\n\t\tup_read(&key->sem);\n\t\tkey_put(key);\n\t\tkey = NULL;\n\t}\n\treturn key;\n}\n\nstatic const void *nvdimm_get_user_key_payload(struct nvdimm *nvdimm,\n\t\tkey_serial_t id, int subclass, struct key **key)\n{\n\t*key = NULL;\n\tif (id == 0) {\n\t\tif (subclass == NVDIMM_BASE_KEY)\n\t\t\treturn zero_key;\n\t\telse\n\t\t\treturn NULL;\n\t}\n\n\t*key = nvdimm_lookup_user_key(nvdimm, id, subclass);\n\tif (!*key)\n\t\treturn NULL;\n\n\treturn key_data(*key);\n}\n\n\nstatic int nvdimm_key_revalidate(struct nvdimm *nvdimm)\n{\n\tstruct key *key;\n\tint rc;\n\tconst void *data;\n\n\tif (!nvdimm->sec.ops->change_key)\n\t\treturn -EOPNOTSUPP;\n\n\tdata = nvdimm_get_key_payload(nvdimm, &key);\n\n\t \n\trc = nvdimm->sec.ops->change_key(nvdimm, data, data, NVDIMM_USER);\n\tif (rc < 0) {\n\t\tnvdimm_put_key(key);\n\t\treturn rc;\n\t}\n\n\tnvdimm_put_key(key);\n\tnvdimm->sec.flags = nvdimm_security_flags(nvdimm, NVDIMM_USER);\n\treturn 0;\n}\n\nstatic int __nvdimm_security_unlock(struct nvdimm *nvdimm)\n{\n\tstruct device *dev = &nvdimm->dev;\n\tstruct nvdimm_bus *nvdimm_bus = walk_to_nvdimm_bus(dev);\n\tstruct key *key;\n\tconst void *data;\n\tint rc;\n\n\t \n\tlockdep_assert_held(&nvdimm_bus->reconfig_mutex);\n\n\tif (!nvdimm->sec.ops || !nvdimm->sec.ops->unlock\n\t\t\t|| !nvdimm->sec.flags)\n\t\treturn -EIO;\n\n\t \n\tif (IS_ENABLED(CONFIG_NVDIMM_SECURITY_TEST))\n\t\tnvdimm->sec.flags = nvdimm_security_flags(nvdimm, NVDIMM_USER);\n\n\t \n\tif (test_bit(NVDIMM_SECURITY_DISABLED, &nvdimm->sec.flags))\n\t\treturn 0;\n\n\tif (test_bit(NDD_SECURITY_OVERWRITE, &nvdimm->flags)) {\n\t\tdev_dbg(dev, \"Security operation in progress.\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\t \n\tif (test_bit(NVDIMM_SECURITY_UNLOCKED, &nvdimm->sec.flags)) {\n\t\tif (!key_revalidate)\n\t\t\treturn 0;\n\n\t\treturn nvdimm_key_revalidate(nvdimm);\n\t} else\n\t\tdata = nvdimm_get_key_payload(nvdimm, &key);\n\n\trc = nvdimm->sec.ops->unlock(nvdimm, data);\n\tdev_dbg(dev, \"key: %d unlock: %s\\n\", key_serial(key),\n\t\t\trc == 0 ? \"success\" : \"fail\");\n\tif (rc == 0)\n\t\tset_bit(NDD_INCOHERENT, &nvdimm->flags);\n\n\tnvdimm_put_key(key);\n\tnvdimm->sec.flags = nvdimm_security_flags(nvdimm, NVDIMM_USER);\n\treturn rc;\n}\n\nint nvdimm_security_unlock(struct device *dev)\n{\n\tstruct nvdimm *nvdimm = to_nvdimm(dev);\n\tint rc;\n\n\tnvdimm_bus_lock(dev);\n\trc = __nvdimm_security_unlock(nvdimm);\n\tnvdimm_bus_unlock(dev);\n\treturn rc;\n}\n\nstatic int check_security_state(struct nvdimm *nvdimm)\n{\n\tstruct device *dev = &nvdimm->dev;\n\n\tif (test_bit(NVDIMM_SECURITY_FROZEN, &nvdimm->sec.flags)) {\n\t\tdev_dbg(dev, \"Incorrect security state: %#lx\\n\",\n\t\t\t\tnvdimm->sec.flags);\n\t\treturn -EIO;\n\t}\n\n\tif (test_bit(NDD_SECURITY_OVERWRITE, &nvdimm->flags)) {\n\t\tdev_dbg(dev, \"Security operation in progress.\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\treturn 0;\n}\n\nstatic int security_disable(struct nvdimm *nvdimm, unsigned int keyid,\n\t\t\t    enum nvdimm_passphrase_type pass_type)\n{\n\tstruct device *dev = &nvdimm->dev;\n\tstruct nvdimm_bus *nvdimm_bus = walk_to_nvdimm_bus(dev);\n\tstruct key *key;\n\tint rc;\n\tconst void *data;\n\n\t \n\tlockdep_assert_held(&nvdimm_bus->reconfig_mutex);\n\n\tif (!nvdimm->sec.ops || !nvdimm->sec.flags)\n\t\treturn -EOPNOTSUPP;\n\n\tif (pass_type == NVDIMM_USER && !nvdimm->sec.ops->disable)\n\t\treturn -EOPNOTSUPP;\n\n\tif (pass_type == NVDIMM_MASTER && !nvdimm->sec.ops->disable_master)\n\t\treturn -EOPNOTSUPP;\n\n\trc = check_security_state(nvdimm);\n\tif (rc)\n\t\treturn rc;\n\n\tdata = nvdimm_get_user_key_payload(nvdimm, keyid,\n\t\t\tNVDIMM_BASE_KEY, &key);\n\tif (!data)\n\t\treturn -ENOKEY;\n\n\tif (pass_type == NVDIMM_MASTER) {\n\t\trc = nvdimm->sec.ops->disable_master(nvdimm, data);\n\t\tdev_dbg(dev, \"key: %d disable_master: %s\\n\", key_serial(key),\n\t\t\trc == 0 ? \"success\" : \"fail\");\n\t} else {\n\t\trc = nvdimm->sec.ops->disable(nvdimm, data);\n\t\tdev_dbg(dev, \"key: %d disable: %s\\n\", key_serial(key),\n\t\t\trc == 0 ? \"success\" : \"fail\");\n\t}\n\n\tnvdimm_put_key(key);\n\tif (pass_type == NVDIMM_MASTER)\n\t\tnvdimm->sec.ext_flags = nvdimm_security_flags(nvdimm, NVDIMM_MASTER);\n\telse\n\t\tnvdimm->sec.flags = nvdimm_security_flags(nvdimm, NVDIMM_USER);\n\treturn rc;\n}\n\nstatic int security_update(struct nvdimm *nvdimm, unsigned int keyid,\n\t\tunsigned int new_keyid,\n\t\tenum nvdimm_passphrase_type pass_type)\n{\n\tstruct device *dev = &nvdimm->dev;\n\tstruct nvdimm_bus *nvdimm_bus = walk_to_nvdimm_bus(dev);\n\tstruct key *key, *newkey;\n\tint rc;\n\tconst void *data, *newdata;\n\n\t \n\tlockdep_assert_held(&nvdimm_bus->reconfig_mutex);\n\n\tif (!nvdimm->sec.ops || !nvdimm->sec.ops->change_key\n\t\t\t|| !nvdimm->sec.flags)\n\t\treturn -EOPNOTSUPP;\n\n\trc = check_security_state(nvdimm);\n\tif (rc)\n\t\treturn rc;\n\n\tdata = nvdimm_get_user_key_payload(nvdimm, keyid,\n\t\t\tNVDIMM_BASE_KEY, &key);\n\tif (!data)\n\t\treturn -ENOKEY;\n\n\tnewdata = nvdimm_get_user_key_payload(nvdimm, new_keyid,\n\t\t\tNVDIMM_NEW_KEY, &newkey);\n\tif (!newdata) {\n\t\tnvdimm_put_key(key);\n\t\treturn -ENOKEY;\n\t}\n\n\trc = nvdimm->sec.ops->change_key(nvdimm, data, newdata, pass_type);\n\tdev_dbg(dev, \"key: %d %d update%s: %s\\n\",\n\t\t\tkey_serial(key), key_serial(newkey),\n\t\t\tpass_type == NVDIMM_MASTER ? \"(master)\" : \"(user)\",\n\t\t\trc == 0 ? \"success\" : \"fail\");\n\n\tnvdimm_put_key(newkey);\n\tnvdimm_put_key(key);\n\tif (pass_type == NVDIMM_MASTER)\n\t\tnvdimm->sec.ext_flags = nvdimm_security_flags(nvdimm,\n\t\t\t\tNVDIMM_MASTER);\n\telse\n\t\tnvdimm->sec.flags = nvdimm_security_flags(nvdimm,\n\t\t\t\tNVDIMM_USER);\n\treturn rc;\n}\n\nstatic int security_erase(struct nvdimm *nvdimm, unsigned int keyid,\n\t\tenum nvdimm_passphrase_type pass_type)\n{\n\tstruct device *dev = &nvdimm->dev;\n\tstruct nvdimm_bus *nvdimm_bus = walk_to_nvdimm_bus(dev);\n\tstruct key *key = NULL;\n\tint rc;\n\tconst void *data;\n\n\t \n\tlockdep_assert_held(&nvdimm_bus->reconfig_mutex);\n\n\tif (!nvdimm->sec.ops || !nvdimm->sec.ops->erase\n\t\t\t|| !nvdimm->sec.flags)\n\t\treturn -EOPNOTSUPP;\n\n\trc = check_security_state(nvdimm);\n\tif (rc)\n\t\treturn rc;\n\n\tif (!test_bit(NVDIMM_SECURITY_UNLOCKED, &nvdimm->sec.ext_flags)\n\t\t\t&& pass_type == NVDIMM_MASTER) {\n\t\tdev_dbg(dev,\n\t\t\t\"Attempt to secure erase in wrong master state.\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tdata = nvdimm_get_user_key_payload(nvdimm, keyid,\n\t\t\tNVDIMM_BASE_KEY, &key);\n\tif (!data)\n\t\treturn -ENOKEY;\n\n\trc = nvdimm->sec.ops->erase(nvdimm, data, pass_type);\n\tif (rc == 0)\n\t\tset_bit(NDD_INCOHERENT, &nvdimm->flags);\n\tdev_dbg(dev, \"key: %d erase%s: %s\\n\", key_serial(key),\n\t\t\tpass_type == NVDIMM_MASTER ? \"(master)\" : \"(user)\",\n\t\t\trc == 0 ? \"success\" : \"fail\");\n\n\tnvdimm_put_key(key);\n\tnvdimm->sec.flags = nvdimm_security_flags(nvdimm, NVDIMM_USER);\n\treturn rc;\n}\n\nstatic int security_overwrite(struct nvdimm *nvdimm, unsigned int keyid)\n{\n\tstruct device *dev = &nvdimm->dev;\n\tstruct nvdimm_bus *nvdimm_bus = walk_to_nvdimm_bus(dev);\n\tstruct key *key = NULL;\n\tint rc;\n\tconst void *data;\n\n\t \n\tlockdep_assert_held(&nvdimm_bus->reconfig_mutex);\n\n\tif (!nvdimm->sec.ops || !nvdimm->sec.ops->overwrite\n\t\t\t|| !nvdimm->sec.flags)\n\t\treturn -EOPNOTSUPP;\n\n\trc = check_security_state(nvdimm);\n\tif (rc)\n\t\treturn rc;\n\n\tdata = nvdimm_get_user_key_payload(nvdimm, keyid,\n\t\t\tNVDIMM_BASE_KEY, &key);\n\tif (!data)\n\t\treturn -ENOKEY;\n\n\trc = nvdimm->sec.ops->overwrite(nvdimm, data);\n\tif (rc == 0)\n\t\tset_bit(NDD_INCOHERENT, &nvdimm->flags);\n\tdev_dbg(dev, \"key: %d overwrite submission: %s\\n\", key_serial(key),\n\t\t\trc == 0 ? \"success\" : \"fail\");\n\n\tnvdimm_put_key(key);\n\tif (rc == 0) {\n\t\tset_bit(NDD_SECURITY_OVERWRITE, &nvdimm->flags);\n\t\tset_bit(NDD_WORK_PENDING, &nvdimm->flags);\n\t\tset_bit(NVDIMM_SECURITY_OVERWRITE, &nvdimm->sec.flags);\n\t\t \n\t\tget_device(dev);\n\t\tqueue_delayed_work(system_wq, &nvdimm->dwork, 0);\n\t}\n\n\treturn rc;\n}\n\nstatic void __nvdimm_security_overwrite_query(struct nvdimm *nvdimm)\n{\n\tstruct nvdimm_bus *nvdimm_bus = walk_to_nvdimm_bus(&nvdimm->dev);\n\tint rc;\n\tunsigned int tmo;\n\n\t \n\tlockdep_assert_held(&nvdimm_bus->reconfig_mutex);\n\n\t \n\tif (!test_bit(NDD_WORK_PENDING, &nvdimm->flags))\n\t\treturn;\n\n\ttmo = nvdimm->sec.overwrite_tmo;\n\n\tif (!nvdimm->sec.ops || !nvdimm->sec.ops->query_overwrite\n\t\t\t|| !nvdimm->sec.flags)\n\t\treturn;\n\n\trc = nvdimm->sec.ops->query_overwrite(nvdimm);\n\tif (rc == -EBUSY) {\n\n\t\t \n\t\ttmo += 10;\n\t\tqueue_delayed_work(system_wq, &nvdimm->dwork, tmo * HZ);\n\t\tnvdimm->sec.overwrite_tmo = min(15U * 60U, tmo);\n\t\treturn;\n\t}\n\n\tif (rc < 0)\n\t\tdev_dbg(&nvdimm->dev, \"overwrite failed\\n\");\n\telse\n\t\tdev_dbg(&nvdimm->dev, \"overwrite completed\\n\");\n\n\t \n\tnvdimm->sec.overwrite_tmo = 0;\n\tclear_bit(NDD_SECURITY_OVERWRITE, &nvdimm->flags);\n\tclear_bit(NDD_WORK_PENDING, &nvdimm->flags);\n\tnvdimm->sec.flags = nvdimm_security_flags(nvdimm, NVDIMM_USER);\n\tnvdimm->sec.ext_flags = nvdimm_security_flags(nvdimm, NVDIMM_MASTER);\n\tif (nvdimm->sec.overwrite_state)\n\t\tsysfs_notify_dirent(nvdimm->sec.overwrite_state);\n\tput_device(&nvdimm->dev);\n}\n\nvoid nvdimm_security_overwrite_query(struct work_struct *work)\n{\n\tstruct nvdimm *nvdimm =\n\t\tcontainer_of(work, typeof(*nvdimm), dwork.work);\n\n\tnvdimm_bus_lock(&nvdimm->dev);\n\t__nvdimm_security_overwrite_query(nvdimm);\n\tnvdimm_bus_unlock(&nvdimm->dev);\n}\n\n#define OPS\t\t\t\t\t\t\t\\\n\tC( OP_FREEZE,\t\t\"freeze\",\t\t1),\t\\\n\tC( OP_DISABLE,\t\t\"disable\",\t\t2),\t\\\n\tC( OP_DISABLE_MASTER,\t\"disable_master\",\t2),\t\\\n\tC( OP_UPDATE,\t\t\"update\",\t\t3),\t\\\n\tC( OP_ERASE,\t\t\"erase\",\t\t2),\t\\\n\tC( OP_OVERWRITE,\t\"overwrite\",\t\t2),\t\\\n\tC( OP_MASTER_UPDATE,\t\"master_update\",\t3),\t\\\n\tC( OP_MASTER_ERASE,\t\"master_erase\",\t\t2)\n#undef C\n#define C(a, b, c) a\nenum nvdimmsec_op_ids { OPS };\n#undef C\n#define C(a, b, c) { b, c }\nstatic struct {\n\tconst char *name;\n\tint args;\n} ops[] = { OPS };\n#undef C\n\n#define SEC_CMD_SIZE 32\n#define KEY_ID_SIZE 10\n\nssize_t nvdimm_security_store(struct device *dev, const char *buf, size_t len)\n{\n\tstruct nvdimm *nvdimm = to_nvdimm(dev);\n\tssize_t rc;\n\tchar cmd[SEC_CMD_SIZE+1], keystr[KEY_ID_SIZE+1],\n\t\tnkeystr[KEY_ID_SIZE+1];\n\tunsigned int key, newkey;\n\tint i;\n\n\trc = sscanf(buf, \"%\"__stringify(SEC_CMD_SIZE)\"s\"\n\t\t\t\" %\"__stringify(KEY_ID_SIZE)\"s\"\n\t\t\t\" %\"__stringify(KEY_ID_SIZE)\"s\",\n\t\t\tcmd, keystr, nkeystr);\n\tif (rc < 1)\n\t\treturn -EINVAL;\n\tfor (i = 0; i < ARRAY_SIZE(ops); i++)\n\t\tif (sysfs_streq(cmd, ops[i].name))\n\t\t\tbreak;\n\tif (i >= ARRAY_SIZE(ops))\n\t\treturn -EINVAL;\n\tif (ops[i].args > 1)\n\t\trc = kstrtouint(keystr, 0, &key);\n\tif (rc >= 0 && ops[i].args > 2)\n\t\trc = kstrtouint(nkeystr, 0, &newkey);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tif (i == OP_FREEZE) {\n\t\tdev_dbg(dev, \"freeze\\n\");\n\t\trc = nvdimm_security_freeze(nvdimm);\n\t} else if (i == OP_DISABLE) {\n\t\tdev_dbg(dev, \"disable %u\\n\", key);\n\t\trc = security_disable(nvdimm, key, NVDIMM_USER);\n\t} else if (i == OP_DISABLE_MASTER) {\n\t\tdev_dbg(dev, \"disable_master %u\\n\", key);\n\t\trc = security_disable(nvdimm, key, NVDIMM_MASTER);\n\t} else if (i == OP_UPDATE || i == OP_MASTER_UPDATE) {\n\t\tdev_dbg(dev, \"%s %u %u\\n\", ops[i].name, key, newkey);\n\t\trc = security_update(nvdimm, key, newkey, i == OP_UPDATE\n\t\t\t\t? NVDIMM_USER : NVDIMM_MASTER);\n\t} else if (i == OP_ERASE || i == OP_MASTER_ERASE) {\n\t\tdev_dbg(dev, \"%s %u\\n\", ops[i].name, key);\n\t\tif (atomic_read(&nvdimm->busy)) {\n\t\t\tdev_dbg(dev, \"Unable to secure erase while DIMM active.\\n\");\n\t\t\treturn -EBUSY;\n\t\t}\n\t\trc = security_erase(nvdimm, key, i == OP_ERASE\n\t\t\t\t? NVDIMM_USER : NVDIMM_MASTER);\n\t} else if (i == OP_OVERWRITE) {\n\t\tdev_dbg(dev, \"overwrite %u\\n\", key);\n\t\tif (atomic_read(&nvdimm->busy)) {\n\t\t\tdev_dbg(dev, \"Unable to overwrite while DIMM active.\\n\");\n\t\t\treturn -EBUSY;\n\t\t}\n\t\trc = security_overwrite(nvdimm, key);\n\t} else\n\t\treturn -EINVAL;\n\n\tif (rc == 0)\n\t\trc = len;\n\treturn rc;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}