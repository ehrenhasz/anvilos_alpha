{
  "module_name": "of_pmem.c",
  "hash_id": "b185d275d83eb9a4a3c4bd0c1755fbbf366d0b94ee2d692a859336383f8ffcdc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/nvdimm/of_pmem.c",
  "human_readable_source": "\n\n#define pr_fmt(fmt) \"of_pmem: \" fmt\n\n#include <linux/of.h>\n#include <linux/libnvdimm.h>\n#include <linux/module.h>\n#include <linux/ioport.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n\nstruct of_pmem_private {\n\tstruct nvdimm_bus_descriptor bus_desc;\n\tstruct nvdimm_bus *bus;\n};\n\nstatic int of_pmem_region_probe(struct platform_device *pdev)\n{\n\tstruct of_pmem_private *priv;\n\tstruct device_node *np;\n\tstruct nvdimm_bus *bus;\n\tbool is_volatile;\n\tint i;\n\n\tnp = dev_of_node(&pdev->dev);\n\tif (!np)\n\t\treturn -ENXIO;\n\n\tpriv = kzalloc(sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->bus_desc.provider_name = devm_kstrdup(&pdev->dev, pdev->name,\n\t\t\t\t\t\t\tGFP_KERNEL);\n\tif (!priv->bus_desc.provider_name) {\n\t\tkfree(priv);\n\t\treturn -ENOMEM;\n\t}\n\n\tpriv->bus_desc.module = THIS_MODULE;\n\tpriv->bus_desc.of_node = np;\n\n\tpriv->bus = bus = nvdimm_bus_register(&pdev->dev, &priv->bus_desc);\n\tif (!bus) {\n\t\tkfree(priv);\n\t\treturn -ENODEV;\n\t}\n\tplatform_set_drvdata(pdev, priv);\n\n\tis_volatile = !!of_find_property(np, \"volatile\", NULL);\n\tdev_dbg(&pdev->dev, \"Registering %s regions from %pOF\\n\",\n\t\t\tis_volatile ? \"volatile\" : \"non-volatile\",  np);\n\n\tfor (i = 0; i < pdev->num_resources; i++) {\n\t\tstruct nd_region_desc ndr_desc;\n\t\tstruct nd_region *region;\n\n\t\t \n\t\tmemset(&ndr_desc, 0, sizeof(ndr_desc));\n\t\tndr_desc.numa_node = dev_to_node(&pdev->dev);\n\t\tndr_desc.target_node = ndr_desc.numa_node;\n\t\tndr_desc.res = &pdev->resource[i];\n\t\tndr_desc.of_node = np;\n\t\tset_bit(ND_REGION_PAGEMAP, &ndr_desc.flags);\n\n\t\tif (is_volatile)\n\t\t\tregion = nvdimm_volatile_region_create(bus, &ndr_desc);\n\t\telse {\n\t\t\tset_bit(ND_REGION_PERSIST_MEMCTRL, &ndr_desc.flags);\n\t\t\tregion = nvdimm_pmem_region_create(bus, &ndr_desc);\n\t\t}\n\n\t\tif (!region)\n\t\t\tdev_warn(&pdev->dev, \"Unable to register region %pR from %pOF\\n\",\n\t\t\t\t\tndr_desc.res, np);\n\t\telse\n\t\t\tdev_dbg(&pdev->dev, \"Registered region %pR from %pOF\\n\",\n\t\t\t\t\tndr_desc.res, np);\n\t}\n\n\treturn 0;\n}\n\nstatic int of_pmem_region_remove(struct platform_device *pdev)\n{\n\tstruct of_pmem_private *priv = platform_get_drvdata(pdev);\n\n\tnvdimm_bus_unregister(priv->bus);\n\tkfree(priv);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id of_pmem_region_match[] = {\n\t{ .compatible = \"pmem-region\" },\n\t{ .compatible = \"pmem-region-v2\" },\n\t{ },\n};\n\nstatic struct platform_driver of_pmem_region_driver = {\n\t.probe = of_pmem_region_probe,\n\t.remove = of_pmem_region_remove,\n\t.driver = {\n\t\t.name = \"of_pmem\",\n\t\t.of_match_table = of_pmem_region_match,\n\t},\n};\n\nmodule_platform_driver(of_pmem_region_driver);\nMODULE_DEVICE_TABLE(of, of_pmem_region_match);\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"IBM Corporation\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}