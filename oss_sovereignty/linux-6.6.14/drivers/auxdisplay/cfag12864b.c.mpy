{
  "module_name": "cfag12864b.c",
  "hash_id": "59b10aac8590b6f1904cf68ffbf09e9ef94f5ba134a80c09ed47633333f2e630",
  "original_prompt": "Ingested from linux-6.6.14/drivers/auxdisplay/cfag12864b.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/cdev.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/jiffies.h>\n#include <linux/mutex.h>\n#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/workqueue.h>\n#include <linux/ks0108.h>\n#include <linux/cfag12864b.h>\n\n\n#define CFAG12864B_NAME \"cfag12864b\"\n\n \n\nstatic unsigned int cfag12864b_rate = CONFIG_CFAG12864B_RATE;\nmodule_param(cfag12864b_rate, uint, 0444);\nMODULE_PARM_DESC(cfag12864b_rate,\n\t\"Refresh rate (hertz)\");\n\nunsigned int cfag12864b_getrate(void)\n{\n\treturn cfag12864b_rate;\n}\n\n \n\n#define bit(n) (((unsigned char)1)<<(n))\n\n#define CFAG12864B_BIT_E\t(0)\n#define CFAG12864B_BIT_CS1\t(2)\n#define CFAG12864B_BIT_CS2\t(1)\n#define CFAG12864B_BIT_DI\t(3)\n\nstatic unsigned char cfag12864b_state;\n\nstatic void cfag12864b_set(void)\n{\n\tks0108_writecontrol(cfag12864b_state);\n}\n\nstatic void cfag12864b_setbit(unsigned char state, unsigned char n)\n{\n\tif (state)\n\t\tcfag12864b_state |= bit(n);\n\telse\n\t\tcfag12864b_state &= ~bit(n);\n}\n\nstatic void cfag12864b_e(unsigned char state)\n{\n\tcfag12864b_setbit(state, CFAG12864B_BIT_E);\n\tcfag12864b_set();\n}\n\nstatic void cfag12864b_cs1(unsigned char state)\n{\n\tcfag12864b_setbit(state, CFAG12864B_BIT_CS1);\n}\n\nstatic void cfag12864b_cs2(unsigned char state)\n{\n\tcfag12864b_setbit(state, CFAG12864B_BIT_CS2);\n}\n\nstatic void cfag12864b_di(unsigned char state)\n{\n\tcfag12864b_setbit(state, CFAG12864B_BIT_DI);\n}\n\nstatic void cfag12864b_setcontrollers(unsigned char first,\n\tunsigned char second)\n{\n\tif (first)\n\t\tcfag12864b_cs1(0);\n\telse\n\t\tcfag12864b_cs1(1);\n\n\tif (second)\n\t\tcfag12864b_cs2(0);\n\telse\n\t\tcfag12864b_cs2(1);\n}\n\nstatic void cfag12864b_controller(unsigned char which)\n{\n\tif (which == 0)\n\t\tcfag12864b_setcontrollers(1, 0);\n\telse if (which == 1)\n\t\tcfag12864b_setcontrollers(0, 1);\n}\n\nstatic void cfag12864b_displaystate(unsigned char state)\n{\n\tcfag12864b_di(0);\n\tcfag12864b_e(1);\n\tks0108_displaystate(state);\n\tcfag12864b_e(0);\n}\n\nstatic void cfag12864b_address(unsigned char address)\n{\n\tcfag12864b_di(0);\n\tcfag12864b_e(1);\n\tks0108_address(address);\n\tcfag12864b_e(0);\n}\n\nstatic void cfag12864b_page(unsigned char page)\n{\n\tcfag12864b_di(0);\n\tcfag12864b_e(1);\n\tks0108_page(page);\n\tcfag12864b_e(0);\n}\n\nstatic void cfag12864b_startline(unsigned char startline)\n{\n\tcfag12864b_di(0);\n\tcfag12864b_e(1);\n\tks0108_startline(startline);\n\tcfag12864b_e(0);\n}\n\nstatic void cfag12864b_writebyte(unsigned char byte)\n{\n\tcfag12864b_di(1);\n\tcfag12864b_e(1);\n\tks0108_writedata(byte);\n\tcfag12864b_e(0);\n}\n\nstatic void cfag12864b_nop(void)\n{\n\tcfag12864b_startline(0);\n}\n\n \n\nstatic void cfag12864b_on(void)\n{\n\tcfag12864b_setcontrollers(1, 1);\n\tcfag12864b_displaystate(1);\n}\n\nstatic void cfag12864b_off(void)\n{\n\tcfag12864b_setcontrollers(1, 1);\n\tcfag12864b_displaystate(0);\n}\n\nstatic void cfag12864b_clear(void)\n{\n\tunsigned char i, j;\n\n\tcfag12864b_setcontrollers(1, 1);\n\tfor (i = 0; i < CFAG12864B_PAGES; i++) {\n\t\tcfag12864b_page(i);\n\t\tcfag12864b_address(0);\n\t\tfor (j = 0; j < CFAG12864B_ADDRESSES; j++)\n\t\t\tcfag12864b_writebyte(0);\n\t}\n}\n\n \n\nunsigned char *cfag12864b_buffer;\nstatic unsigned char *cfag12864b_cache;\nstatic DEFINE_MUTEX(cfag12864b_mutex);\nstatic unsigned char cfag12864b_updating;\nstatic void cfag12864b_update(struct work_struct *delayed_work);\nstatic struct workqueue_struct *cfag12864b_workqueue;\nstatic DECLARE_DELAYED_WORK(cfag12864b_work, cfag12864b_update);\n\nstatic void cfag12864b_queue(void)\n{\n\tqueue_delayed_work(cfag12864b_workqueue, &cfag12864b_work,\n\t\tHZ / cfag12864b_rate);\n}\n\nunsigned char cfag12864b_enable(void)\n{\n\tunsigned char ret;\n\n\tmutex_lock(&cfag12864b_mutex);\n\n\tif (!cfag12864b_updating) {\n\t\tcfag12864b_updating = 1;\n\t\tcfag12864b_queue();\n\t\tret = 0;\n\t} else\n\t\tret = 1;\n\n\tmutex_unlock(&cfag12864b_mutex);\n\n\treturn ret;\n}\n\nvoid cfag12864b_disable(void)\n{\n\tmutex_lock(&cfag12864b_mutex);\n\n\tif (cfag12864b_updating) {\n\t\tcfag12864b_updating = 0;\n\t\tcancel_delayed_work(&cfag12864b_work);\n\t\tflush_workqueue(cfag12864b_workqueue);\n\t}\n\n\tmutex_unlock(&cfag12864b_mutex);\n}\n\nunsigned char cfag12864b_isenabled(void)\n{\n\treturn cfag12864b_updating;\n}\n\nstatic void cfag12864b_update(struct work_struct *work)\n{\n\tunsigned char c;\n\tunsigned short i, j, k, b;\n\n\tif (memcmp(cfag12864b_cache, cfag12864b_buffer, CFAG12864B_SIZE)) {\n\t\tfor (i = 0; i < CFAG12864B_CONTROLLERS; i++) {\n\t\t\tcfag12864b_controller(i);\n\t\t\tcfag12864b_nop();\n\t\t\tfor (j = 0; j < CFAG12864B_PAGES; j++) {\n\t\t\t\tcfag12864b_page(j);\n\t\t\t\tcfag12864b_nop();\n\t\t\t\tcfag12864b_address(0);\n\t\t\t\tcfag12864b_nop();\n\t\t\t\tfor (k = 0; k < CFAG12864B_ADDRESSES; k++) {\n\t\t\t\t\tfor (c = 0, b = 0; b < 8; b++)\n\t\t\t\t\t\tif (cfag12864b_buffer\n\t\t\t\t\t\t\t[i * CFAG12864B_ADDRESSES / 8\n\t\t\t\t\t\t\t+ k / 8 + (j * 8 + b) *\n\t\t\t\t\t\t\tCFAG12864B_WIDTH / 8]\n\t\t\t\t\t\t\t& bit(k % 8))\n\t\t\t\t\t\t\tc |= bit(b);\n\t\t\t\t\tcfag12864b_writebyte(c);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tmemcpy(cfag12864b_cache, cfag12864b_buffer, CFAG12864B_SIZE);\n\t}\n\n\tif (cfag12864b_updating)\n\t\tcfag12864b_queue();\n}\n\n \n\nEXPORT_SYMBOL_GPL(cfag12864b_buffer);\nEXPORT_SYMBOL_GPL(cfag12864b_getrate);\nEXPORT_SYMBOL_GPL(cfag12864b_enable);\nEXPORT_SYMBOL_GPL(cfag12864b_disable);\nEXPORT_SYMBOL_GPL(cfag12864b_isenabled);\n\n \n\nstatic unsigned char cfag12864b_inited;\nunsigned char cfag12864b_isinited(void)\n{\n\treturn cfag12864b_inited;\n}\nEXPORT_SYMBOL_GPL(cfag12864b_isinited);\n\n \n\nstatic int __init cfag12864b_init(void)\n{\n\tint ret = -EINVAL;\n\n\t \n\tif (!ks0108_isinited()) {\n\t\tprintk(KERN_ERR CFAG12864B_NAME \": ERROR: \"\n\t\t\t\"ks0108 is not initialized\\n\");\n\t\tgoto none;\n\t}\n\tBUILD_BUG_ON(PAGE_SIZE < CFAG12864B_SIZE);\n\n\tcfag12864b_buffer = (unsigned char *) get_zeroed_page(GFP_KERNEL);\n\tif (cfag12864b_buffer == NULL) {\n\t\tprintk(KERN_ERR CFAG12864B_NAME \": ERROR: \"\n\t\t\t\"can't get a free page\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto none;\n\t}\n\n\tcfag12864b_cache = kmalloc(CFAG12864B_SIZE,\n\t\t\t\t   GFP_KERNEL);\n\tif (cfag12864b_cache == NULL) {\n\t\tprintk(KERN_ERR CFAG12864B_NAME \": ERROR: \"\n\t\t\t\"can't alloc cache buffer (%i bytes)\\n\",\n\t\t\tCFAG12864B_SIZE);\n\t\tret = -ENOMEM;\n\t\tgoto bufferalloced;\n\t}\n\n\tcfag12864b_workqueue = create_singlethread_workqueue(CFAG12864B_NAME);\n\tif (cfag12864b_workqueue == NULL)\n\t\tgoto cachealloced;\n\n\tcfag12864b_clear();\n\tcfag12864b_on();\n\n\tcfag12864b_inited = 1;\n\treturn 0;\n\ncachealloced:\n\tkfree(cfag12864b_cache);\n\nbufferalloced:\n\tfree_page((unsigned long) cfag12864b_buffer);\n\nnone:\n\treturn ret;\n}\n\nstatic void __exit cfag12864b_exit(void)\n{\n\tcfag12864b_disable();\n\tcfag12864b_off();\n\tdestroy_workqueue(cfag12864b_workqueue);\n\tkfree(cfag12864b_cache);\n\tfree_page((unsigned long) cfag12864b_buffer);\n}\n\nmodule_init(cfag12864b_init);\nmodule_exit(cfag12864b_exit);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Miguel Ojeda <ojeda@kernel.org>\");\nMODULE_DESCRIPTION(\"cfag12864b LCD driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}