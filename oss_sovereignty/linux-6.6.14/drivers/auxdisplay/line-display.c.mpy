{
  "module_name": "line-display.c",
  "hash_id": "100cf82d0caf609f7d0fe8333b44e1364e5f405d9d6aaabae846d56c2d07d22e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/auxdisplay/line-display.c",
  "human_readable_source": "\n \n\n#include <generated/utsrelease.h>\n\n#include <linux/device.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/sysfs.h>\n#include <linux/timer.h>\n\n#include \"line-display.h\"\n\n#define DEFAULT_SCROLL_RATE\t(HZ / 2)\n\n \nstatic void linedisp_scroll(struct timer_list *t)\n{\n\tstruct linedisp *linedisp = from_timer(linedisp, t, timer);\n\tunsigned int i, ch = linedisp->scroll_pos;\n\tunsigned int num_chars = linedisp->num_chars;\n\n\t \n\tfor (i = 0; i < num_chars;) {\n\t\t \n\t\tfor (; i < num_chars && ch < linedisp->message_len; i++, ch++)\n\t\t\tlinedisp->buf[i] = linedisp->message[ch];\n\n\t\t \n\t\tch = 0;\n\t}\n\n\t \n\tlinedisp->update(linedisp);\n\n\t \n\tlinedisp->scroll_pos++;\n\tlinedisp->scroll_pos %= linedisp->message_len;\n\n\t \n\tif (linedisp->message_len > num_chars && linedisp->scroll_rate)\n\t\tmod_timer(&linedisp->timer, jiffies + linedisp->scroll_rate);\n}\n\n \nstatic int linedisp_display(struct linedisp *linedisp, const char *msg,\n\t\t\t    ssize_t count)\n{\n\tchar *new_msg;\n\n\t \n\tdel_timer_sync(&linedisp->timer);\n\n\tif (count == -1)\n\t\tcount = strlen(msg);\n\n\t \n\tif (msg[count - 1] == '\\n')\n\t\tcount--;\n\n\tif (!count) {\n\t\t \n\t\tkfree(linedisp->message);\n\t\tlinedisp->message = NULL;\n\t\tlinedisp->message_len = 0;\n\t\tmemset(linedisp->buf, ' ', linedisp->num_chars);\n\t\tlinedisp->update(linedisp);\n\t\treturn 0;\n\t}\n\n\tnew_msg = kmemdup_nul(msg, count, GFP_KERNEL);\n\tif (!new_msg)\n\t\treturn -ENOMEM;\n\n\tkfree(linedisp->message);\n\n\tlinedisp->message = new_msg;\n\tlinedisp->message_len = count;\n\tlinedisp->scroll_pos = 0;\n\n\t \n\tlinedisp_scroll(&linedisp->timer);\n\n\treturn 0;\n}\n\n \nstatic ssize_t message_show(struct device *dev, struct device_attribute *attr,\n\t\t\t    char *buf)\n{\n\tstruct linedisp *linedisp = container_of(dev, struct linedisp, dev);\n\n\treturn sysfs_emit(buf, \"%s\\n\", linedisp->message);\n}\n\n \nstatic ssize_t message_store(struct device *dev, struct device_attribute *attr,\n\t\t\t     const char *buf, size_t count)\n{\n\tstruct linedisp *linedisp = container_of(dev, struct linedisp, dev);\n\tint err;\n\n\terr = linedisp_display(linedisp, buf, count);\n\treturn err ?: count;\n}\n\nstatic DEVICE_ATTR_RW(message);\n\nstatic ssize_t scroll_step_ms_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct linedisp *linedisp = container_of(dev, struct linedisp, dev);\n\n\treturn sysfs_emit(buf, \"%u\\n\", jiffies_to_msecs(linedisp->scroll_rate));\n}\n\nstatic ssize_t scroll_step_ms_store(struct device *dev,\n\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t    const char *buf, size_t count)\n{\n\tstruct linedisp *linedisp = container_of(dev, struct linedisp, dev);\n\tunsigned int ms;\n\n\tif (kstrtouint(buf, 10, &ms) != 0)\n\t\treturn -EINVAL;\n\n\tlinedisp->scroll_rate = msecs_to_jiffies(ms);\n\tif (linedisp->message && linedisp->message_len > linedisp->num_chars) {\n\t\tdel_timer_sync(&linedisp->timer);\n\t\tif (linedisp->scroll_rate)\n\t\t\tlinedisp_scroll(&linedisp->timer);\n\t}\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR_RW(scroll_step_ms);\n\nstatic struct attribute *linedisp_attrs[] = {\n\t&dev_attr_message.attr,\n\t&dev_attr_scroll_step_ms.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(linedisp);\n\nstatic const struct device_type linedisp_type = {\n\t.groups\t= linedisp_groups,\n};\n\n \nint linedisp_register(struct linedisp *linedisp, struct device *parent,\n\t\t      unsigned int num_chars, char *buf,\n\t\t      void (*update)(struct linedisp *linedisp))\n{\n\tstatic atomic_t linedisp_id = ATOMIC_INIT(-1);\n\tint err;\n\n\tmemset(linedisp, 0, sizeof(*linedisp));\n\tlinedisp->dev.parent = parent;\n\tlinedisp->dev.type = &linedisp_type;\n\tlinedisp->update = update;\n\tlinedisp->buf = buf;\n\tlinedisp->num_chars = num_chars;\n\tlinedisp->scroll_rate = DEFAULT_SCROLL_RATE;\n\n\tdevice_initialize(&linedisp->dev);\n\tdev_set_name(&linedisp->dev, \"linedisp.%lu\",\n\t\t     (unsigned long)atomic_inc_return(&linedisp_id));\n\n\t \n\ttimer_setup(&linedisp->timer, linedisp_scroll, 0);\n\n\terr = device_add(&linedisp->dev);\n\tif (err)\n\t\tgoto out_del_timer;\n\n\t \n\terr = linedisp_display(linedisp, \"Linux \" UTS_RELEASE \"       \", -1);\n\tif (err)\n\t\tgoto out_del_dev;\n\n\treturn 0;\n\nout_del_dev:\n\tdevice_del(&linedisp->dev);\nout_del_timer:\n\tdel_timer_sync(&linedisp->timer);\n\tput_device(&linedisp->dev);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(linedisp_register);\n\n \nvoid linedisp_unregister(struct linedisp *linedisp)\n{\n\tdevice_del(&linedisp->dev);\n\tdel_timer_sync(&linedisp->timer);\n\tkfree(linedisp->message);\n\tput_device(&linedisp->dev);\n}\nEXPORT_SYMBOL_GPL(linedisp_unregister);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}