{
  "module_name": "img-ascii-lcd.c",
  "hash_id": "f33482db85465d773cf79f8519efed6c886ae3970b0d86856195dea500dc535a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/auxdisplay/img-ascii-lcd.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/io.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of_address.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n\n#include \"line-display.h\"\n\nstruct img_ascii_lcd_ctx;\n\n \nstruct img_ascii_lcd_config {\n\tunsigned int num_chars;\n\tbool external_regmap;\n\tvoid (*update)(struct linedisp *linedisp);\n};\n\n \nstruct img_ascii_lcd_ctx {\n\tunion {\n\t\tvoid __iomem *base;\n\t\tstruct regmap *regmap;\n\t};\n\tu32 offset;\n\tconst struct img_ascii_lcd_config *cfg;\n\tstruct linedisp linedisp;\n\tchar curr[] __aligned(8);\n};\n\n \n\nstatic void boston_update(struct linedisp *linedisp)\n{\n\tstruct img_ascii_lcd_ctx *ctx =\n\t\tcontainer_of(linedisp, struct img_ascii_lcd_ctx, linedisp);\n\tulong val;\n\n#if BITS_PER_LONG == 64\n\tval = *((u64 *)&ctx->curr[0]);\n\t__raw_writeq(val, ctx->base);\n#elif BITS_PER_LONG == 32\n\tval = *((u32 *)&ctx->curr[0]);\n\t__raw_writel(val, ctx->base);\n\tval = *((u32 *)&ctx->curr[4]);\n\t__raw_writel(val, ctx->base + 4);\n#else\n# error Not 32 or 64 bit\n#endif\n}\n\nstatic struct img_ascii_lcd_config boston_config = {\n\t.num_chars = 8,\n\t.update = boston_update,\n};\n\n \n\nstatic void malta_update(struct linedisp *linedisp)\n{\n\tstruct img_ascii_lcd_ctx *ctx =\n\t\tcontainer_of(linedisp, struct img_ascii_lcd_ctx, linedisp);\n\tunsigned int i;\n\tint err = 0;\n\n\tfor (i = 0; i < linedisp->num_chars; i++) {\n\t\terr = regmap_write(ctx->regmap,\n\t\t\t\t   ctx->offset + (i * 8), ctx->curr[i]);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\tif (unlikely(err))\n\t\tpr_err_ratelimited(\"Failed to update LCD display: %d\\n\", err);\n}\n\nstatic struct img_ascii_lcd_config malta_config = {\n\t.num_chars = 8,\n\t.external_regmap = true,\n\t.update = malta_update,\n};\n\n \n\nenum {\n\tSEAD3_REG_LCD_CTRL\t\t= 0x00,\n#define SEAD3_REG_LCD_CTRL_SETDRAM\tBIT(7)\n\tSEAD3_REG_LCD_DATA\t\t= 0x08,\n\tSEAD3_REG_CPLD_STATUS\t\t= 0x10,\n#define SEAD3_REG_CPLD_STATUS_BUSY\tBIT(0)\n\tSEAD3_REG_CPLD_DATA\t\t= 0x18,\n#define SEAD3_REG_CPLD_DATA_BUSY\tBIT(7)\n};\n\nstatic int sead3_wait_sm_idle(struct img_ascii_lcd_ctx *ctx)\n{\n\tunsigned int status;\n\tint err;\n\n\tdo {\n\t\terr = regmap_read(ctx->regmap,\n\t\t\t\t  ctx->offset + SEAD3_REG_CPLD_STATUS,\n\t\t\t\t  &status);\n\t\tif (err)\n\t\t\treturn err;\n\t} while (status & SEAD3_REG_CPLD_STATUS_BUSY);\n\n\treturn 0;\n\n}\n\nstatic int sead3_wait_lcd_idle(struct img_ascii_lcd_ctx *ctx)\n{\n\tunsigned int cpld_data;\n\tint err;\n\n\terr = sead3_wait_sm_idle(ctx);\n\tif (err)\n\t\treturn err;\n\n\tdo {\n\t\terr = regmap_read(ctx->regmap,\n\t\t\t\t  ctx->offset + SEAD3_REG_LCD_CTRL,\n\t\t\t\t  &cpld_data);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = sead3_wait_sm_idle(ctx);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = regmap_read(ctx->regmap,\n\t\t\t\t  ctx->offset + SEAD3_REG_CPLD_DATA,\n\t\t\t\t  &cpld_data);\n\t\tif (err)\n\t\t\treturn err;\n\t} while (cpld_data & SEAD3_REG_CPLD_DATA_BUSY);\n\n\treturn 0;\n}\n\nstatic void sead3_update(struct linedisp *linedisp)\n{\n\tstruct img_ascii_lcd_ctx *ctx =\n\t\tcontainer_of(linedisp, struct img_ascii_lcd_ctx, linedisp);\n\tunsigned int i;\n\tint err = 0;\n\n\tfor (i = 0; i < linedisp->num_chars; i++) {\n\t\terr = sead3_wait_lcd_idle(ctx);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\terr = regmap_write(ctx->regmap,\n\t\t\t\t   ctx->offset + SEAD3_REG_LCD_CTRL,\n\t\t\t\t   SEAD3_REG_LCD_CTRL_SETDRAM | i);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\terr = sead3_wait_lcd_idle(ctx);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\terr = regmap_write(ctx->regmap,\n\t\t\t\t   ctx->offset + SEAD3_REG_LCD_DATA,\n\t\t\t\t   ctx->curr[i]);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\tif (unlikely(err))\n\t\tpr_err_ratelimited(\"Failed to update LCD display: %d\\n\", err);\n}\n\nstatic struct img_ascii_lcd_config sead3_config = {\n\t.num_chars = 16,\n\t.external_regmap = true,\n\t.update = sead3_update,\n};\n\nstatic const struct of_device_id img_ascii_lcd_matches[] = {\n\t{ .compatible = \"img,boston-lcd\", .data = &boston_config },\n\t{ .compatible = \"mti,malta-lcd\", .data = &malta_config },\n\t{ .compatible = \"mti,sead3-lcd\", .data = &sead3_config },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, img_ascii_lcd_matches);\n\n \nstatic int img_ascii_lcd_probe(struct platform_device *pdev)\n{\n\tconst struct of_device_id *match;\n\tconst struct img_ascii_lcd_config *cfg;\n\tstruct device *dev = &pdev->dev;\n\tstruct img_ascii_lcd_ctx *ctx;\n\tint err;\n\n\tmatch = of_match_device(img_ascii_lcd_matches, dev);\n\tif (!match)\n\t\treturn -ENODEV;\n\n\tcfg = match->data;\n\tctx = devm_kzalloc(dev, sizeof(*ctx) + cfg->num_chars, GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tif (cfg->external_regmap) {\n\t\tctx->regmap = syscon_node_to_regmap(dev->parent->of_node);\n\t\tif (IS_ERR(ctx->regmap))\n\t\t\treturn PTR_ERR(ctx->regmap);\n\n\t\tif (of_property_read_u32(dev->of_node, \"offset\", &ctx->offset))\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tctx->base = devm_platform_ioremap_resource(pdev, 0);\n\t\tif (IS_ERR(ctx->base))\n\t\t\treturn PTR_ERR(ctx->base);\n\t}\n\n\terr = linedisp_register(&ctx->linedisp, dev, cfg->num_chars, ctx->curr,\n\t\t\t\tcfg->update);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = compat_only_sysfs_link_entry_to_kobj(&dev->kobj,\n\t\t\t\t\t\t   &ctx->linedisp.dev.kobj,\n\t\t\t\t\t\t   \"message\", NULL);\n\tif (err)\n\t\tgoto err_unregister;\n\n\tplatform_set_drvdata(pdev, ctx);\n\treturn 0;\n\nerr_unregister:\n\tlinedisp_unregister(&ctx->linedisp);\n\treturn err;\n}\n\n \nstatic int img_ascii_lcd_remove(struct platform_device *pdev)\n{\n\tstruct img_ascii_lcd_ctx *ctx = platform_get_drvdata(pdev);\n\n\tsysfs_remove_link(&pdev->dev.kobj, \"message\");\n\tlinedisp_unregister(&ctx->linedisp);\n\treturn 0;\n}\n\nstatic struct platform_driver img_ascii_lcd_driver = {\n\t.driver = {\n\t\t.name\t\t= \"img-ascii-lcd\",\n\t\t.of_match_table\t= img_ascii_lcd_matches,\n\t},\n\t.probe\t= img_ascii_lcd_probe,\n\t.remove\t= img_ascii_lcd_remove,\n};\nmodule_platform_driver(img_ascii_lcd_driver);\n\nMODULE_DESCRIPTION(\"Imagination Technologies ASCII LCD Display\");\nMODULE_AUTHOR(\"Paul Burton <paul.burton@mips.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}