{
  "module_name": "ht16k33.c",
  "hash_id": "38a889008500ef336f22f03bf4cd86555e6510d4654b2f9d0bb5e833303fada5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/auxdisplay/ht16k33.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/i2c.h>\n#include <linux/property.h>\n#include <linux/fb.h>\n#include <linux/backlight.h>\n#include <linux/input.h>\n#include <linux/input/matrix_keypad.h>\n#include <linux/leds.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n\n#include <linux/map_to_7segment.h>\n#include <linux/map_to_14segment.h>\n\n#include <asm/unaligned.h>\n\n#include \"line-display.h\"\n\n \n#define REG_SYSTEM_SETUP\t\t0x20\n#define REG_SYSTEM_SETUP_OSC_ON\t\tBIT(0)\n\n#define REG_DISPLAY_SETUP\t\t0x80\n#define REG_DISPLAY_SETUP_ON\t\tBIT(0)\n#define REG_DISPLAY_SETUP_BLINK_OFF\t(0 << 1)\n#define REG_DISPLAY_SETUP_BLINK_2HZ\t(1 << 1)\n#define REG_DISPLAY_SETUP_BLINK_1HZ\t(2 << 1)\n#define REG_DISPLAY_SETUP_BLINK_0HZ5\t(3 << 1)\n\n#define REG_ROWINT_SET\t\t\t0xA0\n#define REG_ROWINT_SET_INT_EN\t\tBIT(0)\n#define REG_ROWINT_SET_INT_ACT_HIGH\tBIT(1)\n\n#define REG_BRIGHTNESS\t\t\t0xE0\n\n \n#define DRIVER_NAME\t\t\t\"ht16k33\"\n\n#define MIN_BRIGHTNESS\t\t\t0x1\n#define MAX_BRIGHTNESS\t\t\t0x10\n\n#define HT16K33_MATRIX_LED_MAX_COLS\t8\n#define HT16K33_MATRIX_LED_MAX_ROWS\t16\n#define HT16K33_MATRIX_KEYPAD_MAX_COLS\t3\n#define HT16K33_MATRIX_KEYPAD_MAX_ROWS\t12\n\n#define BYTES_PER_ROW\t\t(HT16K33_MATRIX_LED_MAX_ROWS / 8)\n#define HT16K33_FB_SIZE\t\t(HT16K33_MATRIX_LED_MAX_COLS * BYTES_PER_ROW)\n\nenum display_type {\n\tDISP_MATRIX = 0,\n\tDISP_QUAD_7SEG,\n\tDISP_QUAD_14SEG,\n};\n\nstruct ht16k33_keypad {\n\tstruct i2c_client *client;\n\tstruct input_dev *dev;\n\tuint32_t cols;\n\tuint32_t rows;\n\tuint32_t row_shift;\n\tuint32_t debounce_ms;\n\tuint16_t last_key_state[HT16K33_MATRIX_KEYPAD_MAX_COLS];\n\n\twait_queue_head_t wait;\n\tbool stopped;\n};\n\nstruct ht16k33_fbdev {\n\tstruct fb_info *info;\n\tuint32_t refresh_rate;\n\tuint8_t *buffer;\n\tuint8_t *cache;\n};\n\nstruct ht16k33_seg {\n\tstruct linedisp linedisp;\n\tunion {\n\t\tstruct seg7_conversion_map seg7;\n\t\tstruct seg14_conversion_map seg14;\n\t} map;\n\tunsigned int map_size;\n\tchar curr[4];\n};\n\nstruct ht16k33_priv {\n\tstruct i2c_client *client;\n\tstruct delayed_work work;\n\tstruct led_classdev led;\n\tstruct ht16k33_keypad keypad;\n\tunion {\n\t\tstruct ht16k33_fbdev fbdev;\n\t\tstruct ht16k33_seg seg;\n\t};\n\tenum display_type type;\n\tuint8_t blink;\n};\n\nstatic const struct fb_fix_screeninfo ht16k33_fb_fix = {\n\t.id\t\t= DRIVER_NAME,\n\t.type\t\t= FB_TYPE_PACKED_PIXELS,\n\t.visual\t\t= FB_VISUAL_MONO10,\n\t.xpanstep\t= 0,\n\t.ypanstep\t= 0,\n\t.ywrapstep\t= 0,\n\t.line_length\t= HT16K33_MATRIX_LED_MAX_ROWS,\n\t.accel\t\t= FB_ACCEL_NONE,\n};\n\nstatic const struct fb_var_screeninfo ht16k33_fb_var = {\n\t.xres = HT16K33_MATRIX_LED_MAX_ROWS,\n\t.yres = HT16K33_MATRIX_LED_MAX_COLS,\n\t.xres_virtual = HT16K33_MATRIX_LED_MAX_ROWS,\n\t.yres_virtual = HT16K33_MATRIX_LED_MAX_COLS,\n\t.bits_per_pixel = 1,\n\t.red = { 0, 1, 0 },\n\t.green = { 0, 1, 0 },\n\t.blue = { 0, 1, 0 },\n\t.left_margin = 0,\n\t.right_margin = 0,\n\t.upper_margin = 0,\n\t.lower_margin = 0,\n\t.vmode = FB_VMODE_NONINTERLACED,\n};\n\nstatic const SEG7_DEFAULT_MAP(initial_map_seg7);\nstatic const SEG14_DEFAULT_MAP(initial_map_seg14);\n\nstatic ssize_t map_seg_show(struct device *dev, struct device_attribute *attr,\n\t\t\t    char *buf)\n{\n\tstruct ht16k33_priv *priv = dev_get_drvdata(dev);\n\n\tmemcpy(buf, &priv->seg.map, priv->seg.map_size);\n\treturn priv->seg.map_size;\n}\n\nstatic ssize_t map_seg_store(struct device *dev, struct device_attribute *attr,\n\t\t\t     const char *buf, size_t cnt)\n{\n\tstruct ht16k33_priv *priv = dev_get_drvdata(dev);\n\n\tif (cnt != priv->seg.map_size)\n\t\treturn -EINVAL;\n\n\tmemcpy(&priv->seg.map, buf, cnt);\n\treturn cnt;\n}\n\nstatic DEVICE_ATTR(map_seg7, 0644, map_seg_show, map_seg_store);\nstatic DEVICE_ATTR(map_seg14, 0644, map_seg_show, map_seg_store);\n\nstatic int ht16k33_display_on(struct ht16k33_priv *priv)\n{\n\tuint8_t data = REG_DISPLAY_SETUP | REG_DISPLAY_SETUP_ON | priv->blink;\n\n\treturn i2c_smbus_write_byte(priv->client, data);\n}\n\nstatic int ht16k33_display_off(struct ht16k33_priv *priv)\n{\n\treturn i2c_smbus_write_byte(priv->client, REG_DISPLAY_SETUP);\n}\n\nstatic int ht16k33_brightness_set(struct ht16k33_priv *priv,\n\t\t\t\t  unsigned int brightness)\n{\n\tint err;\n\n\tif (brightness == 0) {\n\t\tpriv->blink = REG_DISPLAY_SETUP_BLINK_OFF;\n\t\treturn ht16k33_display_off(priv);\n\t}\n\n\terr = ht16k33_display_on(priv);\n\tif (err)\n\t\treturn err;\n\n\treturn i2c_smbus_write_byte(priv->client,\n\t\t\t\t    REG_BRIGHTNESS | (brightness - 1));\n}\n\nstatic int ht16k33_brightness_set_blocking(struct led_classdev *led_cdev,\n\t\t\t\t\t   enum led_brightness brightness)\n{\n\tstruct ht16k33_priv *priv = container_of(led_cdev, struct ht16k33_priv,\n\t\t\t\t\t\t led);\n\n\treturn ht16k33_brightness_set(priv, brightness);\n}\n\nstatic int ht16k33_blink_set(struct led_classdev *led_cdev,\n\t\t\t     unsigned long *delay_on, unsigned long *delay_off)\n{\n\tstruct ht16k33_priv *priv = container_of(led_cdev, struct ht16k33_priv,\n\t\t\t\t\t\t led);\n\tunsigned int delay;\n\tuint8_t blink;\n\tint err;\n\n\tif (!*delay_on && !*delay_off) {\n\t\tblink = REG_DISPLAY_SETUP_BLINK_1HZ;\n\t\tdelay = 1000;\n\t} else if (*delay_on <= 750) {\n\t\tblink = REG_DISPLAY_SETUP_BLINK_2HZ;\n\t\tdelay = 500;\n\t} else if (*delay_on <= 1500) {\n\t\tblink = REG_DISPLAY_SETUP_BLINK_1HZ;\n\t\tdelay = 1000;\n\t} else {\n\t\tblink = REG_DISPLAY_SETUP_BLINK_0HZ5;\n\t\tdelay = 2000;\n\t}\n\n\terr = i2c_smbus_write_byte(priv->client,\n\t\t\t\t   REG_DISPLAY_SETUP | REG_DISPLAY_SETUP_ON |\n\t\t\t\t   blink);\n\tif (err)\n\t\treturn err;\n\n\tpriv->blink = blink;\n\t*delay_on = *delay_off = delay;\n\treturn 0;\n}\n\nstatic void ht16k33_fb_queue(struct ht16k33_priv *priv)\n{\n\tstruct ht16k33_fbdev *fbdev = &priv->fbdev;\n\n\tschedule_delayed_work(&priv->work, HZ / fbdev->refresh_rate);\n}\n\n \nstatic void ht16k33_fb_update(struct work_struct *work)\n{\n\tstruct ht16k33_priv *priv = container_of(work, struct ht16k33_priv,\n\t\t\t\t\t\t work.work);\n\tstruct ht16k33_fbdev *fbdev = &priv->fbdev;\n\n\tuint8_t *p1, *p2;\n\tint len, pos = 0, first = -1;\n\n\tp1 = fbdev->cache;\n\tp2 = fbdev->buffer;\n\n\t \n\twhile (pos < HT16K33_FB_SIZE && first < 0) {\n\t\tif (*(p1++) - *(p2++))\n\t\t\tfirst = pos;\n\t\tpos++;\n\t}\n\n\t \n\tif (first < 0)\n\t\tgoto requeue;\n\n\tlen = HT16K33_FB_SIZE - first;\n\tp1 = fbdev->cache + HT16K33_FB_SIZE - 1;\n\tp2 = fbdev->buffer + HT16K33_FB_SIZE - 1;\n\n\t \n\twhile (len > 1) {\n\t\tif (*(p1--) - *(p2--))\n\t\t\tbreak;\n\t\tlen--;\n\t}\n\n\tp1 = fbdev->cache + first;\n\tp2 = fbdev->buffer + first;\n\tif (!i2c_smbus_write_i2c_block_data(priv->client, first, len, p2))\n\t\tmemcpy(p1, p2, len);\nrequeue:\n\tht16k33_fb_queue(priv);\n}\n\nstatic int ht16k33_initialize(struct ht16k33_priv *priv)\n{\n\tuint8_t data[HT16K33_FB_SIZE];\n\tuint8_t byte;\n\tint err;\n\n\t \n\tmemset(data, 0, sizeof(data));\n\terr = i2c_smbus_write_block_data(priv->client, 0, sizeof(data), data);\n\tif (err)\n\t\treturn err;\n\n\t \n\tbyte = REG_SYSTEM_SETUP_OSC_ON | REG_SYSTEM_SETUP;\n\terr = i2c_smbus_write_byte(priv->client, byte);\n\tif (err)\n\t\treturn err;\n\n\t \n\tbyte = REG_ROWINT_SET | REG_ROWINT_SET_INT_ACT_HIGH;\n\tif (priv->client->irq > 0)\n\t\tbyte |= REG_ROWINT_SET_INT_EN;\n\treturn i2c_smbus_write_byte(priv->client, byte);\n}\n\nstatic int ht16k33_bl_update_status(struct backlight_device *bl)\n{\n\tint brightness = bl->props.brightness;\n\tstruct ht16k33_priv *priv = bl_get_data(bl);\n\n\tif (bl->props.power != FB_BLANK_UNBLANK ||\n\t    bl->props.fb_blank != FB_BLANK_UNBLANK ||\n\t    bl->props.state & BL_CORE_FBBLANK)\n\t\tbrightness = 0;\n\n\treturn ht16k33_brightness_set(priv, brightness);\n}\n\nstatic int ht16k33_bl_check_fb(struct backlight_device *bl, struct fb_info *fi)\n{\n\tstruct ht16k33_priv *priv = bl_get_data(bl);\n\n\treturn (fi == NULL) || (fi->par == priv);\n}\n\nstatic const struct backlight_ops ht16k33_bl_ops = {\n\t.update_status\t= ht16k33_bl_update_status,\n\t.check_fb\t= ht16k33_bl_check_fb,\n};\n\n \nstatic int ht16k33_blank(int blank, struct fb_info *info)\n{\n\treturn 0;\n}\n\nstatic int ht16k33_mmap(struct fb_info *info, struct vm_area_struct *vma)\n{\n\tstruct ht16k33_priv *priv = info->par;\n\tstruct page *pages = virt_to_page(priv->fbdev.buffer);\n\n\treturn vm_map_pages_zero(vma, &pages, 1);\n}\n\nstatic const struct fb_ops ht16k33_fb_ops = {\n\t.owner = THIS_MODULE,\n\t.fb_read = fb_sys_read,\n\t.fb_write = fb_sys_write,\n\t.fb_blank = ht16k33_blank,\n\t.fb_fillrect = sys_fillrect,\n\t.fb_copyarea = sys_copyarea,\n\t.fb_imageblit = sys_imageblit,\n\t.fb_mmap = ht16k33_mmap,\n};\n\n \nstatic bool ht16k33_keypad_scan(struct ht16k33_keypad *keypad)\n{\n\tconst unsigned short *keycodes = keypad->dev->keycode;\n\tu16 new_state[HT16K33_MATRIX_KEYPAD_MAX_COLS];\n\t__le16 data[HT16K33_MATRIX_KEYPAD_MAX_COLS];\n\tunsigned long bits_changed;\n\tint row, col, code;\n\tint rc;\n\tbool pressed = false;\n\n\trc = i2c_smbus_read_i2c_block_data(keypad->client, 0x40,\n\t\t\t\t\t   sizeof(data), (u8 *)data);\n\tif (rc != sizeof(data)) {\n\t\tdev_err(&keypad->client->dev,\n\t\t\t\"Failed to read key data, rc=%d\\n\", rc);\n\t\treturn false;\n\t}\n\n\tfor (col = 0; col < keypad->cols; col++) {\n\t\tnew_state[col] = le16_to_cpu(data[col]);\n\t\tif (new_state[col])\n\t\t\tpressed = true;\n\t\tbits_changed = keypad->last_key_state[col] ^ new_state[col];\n\n\t\tfor_each_set_bit(row, &bits_changed, BITS_PER_LONG) {\n\t\t\tcode = MATRIX_SCAN_CODE(row, col, keypad->row_shift);\n\t\t\tinput_event(keypad->dev, EV_MSC, MSC_SCAN, code);\n\t\t\tinput_report_key(keypad->dev, keycodes[code],\n\t\t\t\t\t new_state[col] & BIT(row));\n\t\t}\n\t}\n\tinput_sync(keypad->dev);\n\tmemcpy(keypad->last_key_state, new_state, sizeof(u16) * keypad->cols);\n\n\treturn pressed;\n}\n\nstatic irqreturn_t ht16k33_keypad_irq_thread(int irq, void *dev)\n{\n\tstruct ht16k33_keypad *keypad = dev;\n\n\tdo {\n\t\twait_event_timeout(keypad->wait, keypad->stopped,\n\t\t\t\t    msecs_to_jiffies(keypad->debounce_ms));\n\t\tif (keypad->stopped)\n\t\t\tbreak;\n\t} while (ht16k33_keypad_scan(keypad));\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int ht16k33_keypad_start(struct input_dev *dev)\n{\n\tstruct ht16k33_keypad *keypad = input_get_drvdata(dev);\n\n\tkeypad->stopped = false;\n\tmb();\n\tenable_irq(keypad->client->irq);\n\n\treturn 0;\n}\n\nstatic void ht16k33_keypad_stop(struct input_dev *dev)\n{\n\tstruct ht16k33_keypad *keypad = input_get_drvdata(dev);\n\n\tkeypad->stopped = true;\n\tmb();\n\twake_up(&keypad->wait);\n\tdisable_irq(keypad->client->irq);\n}\n\nstatic void ht16k33_linedisp_update(struct linedisp *linedisp)\n{\n\tstruct ht16k33_priv *priv = container_of(linedisp, struct ht16k33_priv,\n\t\t\t\t\t\t seg.linedisp);\n\n\tschedule_delayed_work(&priv->work, 0);\n}\n\nstatic void ht16k33_seg7_update(struct work_struct *work)\n{\n\tstruct ht16k33_priv *priv = container_of(work, struct ht16k33_priv,\n\t\t\t\t\t\t work.work);\n\tstruct ht16k33_seg *seg = &priv->seg;\n\tchar *s = seg->curr;\n\tuint8_t buf[9];\n\n\tbuf[0] = map_to_seg7(&seg->map.seg7, *s++);\n\tbuf[1] = 0;\n\tbuf[2] = map_to_seg7(&seg->map.seg7, *s++);\n\tbuf[3] = 0;\n\tbuf[4] = 0;\n\tbuf[5] = 0;\n\tbuf[6] = map_to_seg7(&seg->map.seg7, *s++);\n\tbuf[7] = 0;\n\tbuf[8] = map_to_seg7(&seg->map.seg7, *s++);\n\n\ti2c_smbus_write_i2c_block_data(priv->client, 0, ARRAY_SIZE(buf), buf);\n}\n\nstatic void ht16k33_seg14_update(struct work_struct *work)\n{\n\tstruct ht16k33_priv *priv = container_of(work, struct ht16k33_priv,\n\t\t\t\t\t\t work.work);\n\tstruct ht16k33_seg *seg = &priv->seg;\n\tchar *s = seg->curr;\n\tuint8_t buf[8];\n\n\tput_unaligned_le16(map_to_seg14(&seg->map.seg14, *s++), buf);\n\tput_unaligned_le16(map_to_seg14(&seg->map.seg14, *s++), buf + 2);\n\tput_unaligned_le16(map_to_seg14(&seg->map.seg14, *s++), buf + 4);\n\tput_unaligned_le16(map_to_seg14(&seg->map.seg14, *s++), buf + 6);\n\n\ti2c_smbus_write_i2c_block_data(priv->client, 0, ARRAY_SIZE(buf), buf);\n}\n\nstatic int ht16k33_led_probe(struct device *dev, struct led_classdev *led,\n\t\t\t     unsigned int brightness)\n{\n\tstruct led_init_data init_data = {};\n\tint err;\n\n\t \n\tinit_data.fwnode = device_get_named_child_node(dev, \"led\");\n\tif (!init_data.fwnode)\n\t\treturn 0;\n\n\tinit_data.devicename = \"auxdisplay\";\n\tinit_data.devname_mandatory = true;\n\n\tled->brightness_set_blocking = ht16k33_brightness_set_blocking;\n\tled->blink_set = ht16k33_blink_set;\n\tled->flags = LED_CORE_SUSPENDRESUME;\n\tled->brightness = brightness;\n\tled->max_brightness = MAX_BRIGHTNESS;\n\n\terr = devm_led_classdev_register_ext(dev, led, &init_data);\n\tif (err)\n\t\tdev_err(dev, \"Failed to register LED\\n\");\n\n\treturn err;\n}\n\nstatic int ht16k33_keypad_probe(struct i2c_client *client,\n\t\t\t\tstruct ht16k33_keypad *keypad)\n{\n\tstruct device *dev = &client->dev;\n\tu32 rows = HT16K33_MATRIX_KEYPAD_MAX_ROWS;\n\tu32 cols = HT16K33_MATRIX_KEYPAD_MAX_COLS;\n\tint err;\n\n\tkeypad->client = client;\n\tinit_waitqueue_head(&keypad->wait);\n\n\tkeypad->dev = devm_input_allocate_device(dev);\n\tif (!keypad->dev)\n\t\treturn -ENOMEM;\n\n\tinput_set_drvdata(keypad->dev, keypad);\n\n\tkeypad->dev->name = DRIVER_NAME\"-keypad\";\n\tkeypad->dev->id.bustype = BUS_I2C;\n\tkeypad->dev->open = ht16k33_keypad_start;\n\tkeypad->dev->close = ht16k33_keypad_stop;\n\n\tif (!device_property_read_bool(dev, \"linux,no-autorepeat\"))\n\t\t__set_bit(EV_REP, keypad->dev->evbit);\n\n\terr = device_property_read_u32(dev, \"debounce-delay-ms\",\n\t\t\t\t       &keypad->debounce_ms);\n\tif (err) {\n\t\tdev_err(dev, \"key debounce delay not specified\\n\");\n\t\treturn err;\n\t}\n\n\terr = matrix_keypad_parse_properties(dev, &rows, &cols);\n\tif (err)\n\t\treturn err;\n\tif (rows > HT16K33_MATRIX_KEYPAD_MAX_ROWS ||\n\t    cols > HT16K33_MATRIX_KEYPAD_MAX_COLS) {\n\t\tdev_err(dev, \"%u rows or %u cols out of range in DT\\n\", rows,\n\t\t\tcols);\n\t\treturn -ERANGE;\n\t}\n\n\tkeypad->rows = rows;\n\tkeypad->cols = cols;\n\tkeypad->row_shift = get_count_order(cols);\n\n\terr = matrix_keypad_build_keymap(NULL, NULL, rows, cols, NULL,\n\t\t\t\t\t keypad->dev);\n\tif (err) {\n\t\tdev_err(dev, \"failed to build keymap\\n\");\n\t\treturn err;\n\t}\n\n\terr = devm_request_threaded_irq(dev, client->irq, NULL,\n\t\t\t\t\tht16k33_keypad_irq_thread,\n\t\t\t\t\tIRQF_TRIGGER_HIGH | IRQF_ONESHOT,\n\t\t\t\t\tDRIVER_NAME, keypad);\n\tif (err) {\n\t\tdev_err(dev, \"irq request failed %d, error %d\\n\", client->irq,\n\t\t\terr);\n\t\treturn err;\n\t}\n\n\tht16k33_keypad_stop(keypad->dev);\n\n\treturn input_register_device(keypad->dev);\n}\n\nstatic int ht16k33_fbdev_probe(struct device *dev, struct ht16k33_priv *priv,\n\t\t\t       uint32_t brightness)\n{\n\tstruct ht16k33_fbdev *fbdev = &priv->fbdev;\n\tstruct backlight_device *bl = NULL;\n\tint err;\n\n\tif (priv->led.dev) {\n\t\terr = ht16k33_brightness_set(priv, brightness);\n\t\tif (err)\n\t\t\treturn err;\n\t} else {\n\t\t \n\t\tstruct backlight_properties bl_props;\n\n\t\tmemset(&bl_props, 0, sizeof(struct backlight_properties));\n\t\tbl_props.type = BACKLIGHT_RAW;\n\t\tbl_props.max_brightness = MAX_BRIGHTNESS;\n\n\t\tbl = devm_backlight_device_register(dev, DRIVER_NAME\"-bl\", dev,\n\t\t\t\t\t\t    priv, &ht16k33_bl_ops,\n\t\t\t\t\t\t    &bl_props);\n\t\tif (IS_ERR(bl)) {\n\t\t\tdev_err(dev, \"failed to register backlight\\n\");\n\t\t\treturn PTR_ERR(bl);\n\t\t}\n\n\t\tbl->props.brightness = brightness;\n\t\tht16k33_bl_update_status(bl);\n\t}\n\n\t \n\tBUILD_BUG_ON(PAGE_SIZE < HT16K33_FB_SIZE);\n\tfbdev->buffer = (unsigned char *) get_zeroed_page(GFP_KERNEL);\n\tif (!fbdev->buffer)\n\t\treturn -ENOMEM;\n\n\tfbdev->cache = devm_kmalloc(dev, HT16K33_FB_SIZE, GFP_KERNEL);\n\tif (!fbdev->cache) {\n\t\terr = -ENOMEM;\n\t\tgoto err_fbdev_buffer;\n\t}\n\n\tfbdev->info = framebuffer_alloc(0, dev);\n\tif (!fbdev->info) {\n\t\terr = -ENOMEM;\n\t\tgoto err_fbdev_buffer;\n\t}\n\n\terr = device_property_read_u32(dev, \"refresh-rate-hz\",\n\t\t\t\t       &fbdev->refresh_rate);\n\tif (err) {\n\t\tdev_err(dev, \"refresh rate not specified\\n\");\n\t\tgoto err_fbdev_info;\n\t}\n\tfb_bl_default_curve(fbdev->info, 0, MIN_BRIGHTNESS, MAX_BRIGHTNESS);\n\n\tINIT_DELAYED_WORK(&priv->work, ht16k33_fb_update);\n\tfbdev->info->fbops = &ht16k33_fb_ops;\n\tfbdev->info->screen_buffer = fbdev->buffer;\n\tfbdev->info->screen_size = HT16K33_FB_SIZE;\n\tfbdev->info->fix = ht16k33_fb_fix;\n\tfbdev->info->var = ht16k33_fb_var;\n\tfbdev->info->bl_dev = bl;\n\tfbdev->info->pseudo_palette = NULL;\n\tfbdev->info->par = priv;\n\n\terr = register_framebuffer(fbdev->info);\n\tif (err)\n\t\tgoto err_fbdev_info;\n\n\tht16k33_fb_queue(priv);\n\treturn 0;\n\nerr_fbdev_info:\n\tframebuffer_release(fbdev->info);\nerr_fbdev_buffer:\n\tfree_page((unsigned long) fbdev->buffer);\n\n\treturn err;\n}\n\nstatic int ht16k33_seg_probe(struct device *dev, struct ht16k33_priv *priv,\n\t\t\t     uint32_t brightness)\n{\n\tstruct ht16k33_seg *seg = &priv->seg;\n\tint err;\n\n\terr = ht16k33_brightness_set(priv, brightness);\n\tif (err)\n\t\treturn err;\n\n\tswitch (priv->type) {\n\tcase DISP_MATRIX:\n\t\t \n\t\terr = -EINVAL;\n\t\tbreak;\n\n\tcase DISP_QUAD_7SEG:\n\t\tINIT_DELAYED_WORK(&priv->work, ht16k33_seg7_update);\n\t\tseg->map.seg7 = initial_map_seg7;\n\t\tseg->map_size = sizeof(seg->map.seg7);\n\t\terr = device_create_file(dev, &dev_attr_map_seg7);\n\t\tbreak;\n\n\tcase DISP_QUAD_14SEG:\n\t\tINIT_DELAYED_WORK(&priv->work, ht16k33_seg14_update);\n\t\tseg->map.seg14 = initial_map_seg14;\n\t\tseg->map_size = sizeof(seg->map.seg14);\n\t\terr = device_create_file(dev, &dev_attr_map_seg14);\n\t\tbreak;\n\t}\n\tif (err)\n\t\treturn err;\n\n\terr = linedisp_register(&seg->linedisp, dev, 4, seg->curr,\n\t\t\t\tht16k33_linedisp_update);\n\tif (err)\n\t\tgoto err_remove_map_file;\n\n\treturn 0;\n\nerr_remove_map_file:\n\tdevice_remove_file(dev, &dev_attr_map_seg7);\n\tdevice_remove_file(dev, &dev_attr_map_seg14);\n\treturn err;\n}\n\nstatic int ht16k33_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tconst struct of_device_id *id;\n\tstruct ht16k33_priv *priv;\n\tuint32_t dft_brightness;\n\tint err;\n\n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {\n\t\tdev_err(dev, \"i2c_check_functionality error\\n\");\n\t\treturn -EIO;\n\t}\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->client = client;\n\tid = i2c_of_match_device(dev->driver->of_match_table, client);\n\tif (id)\n\t\tpriv->type = (uintptr_t)id->data;\n\ti2c_set_clientdata(client, priv);\n\n\terr = ht16k33_initialize(priv);\n\tif (err)\n\t\treturn err;\n\n\terr = device_property_read_u32(dev, \"default-brightness-level\",\n\t\t\t\t       &dft_brightness);\n\tif (err) {\n\t\tdft_brightness = MAX_BRIGHTNESS;\n\t} else if (dft_brightness > MAX_BRIGHTNESS) {\n\t\tdev_warn(dev,\n\t\t\t \"invalid default brightness level: %u, using %u\\n\",\n\t\t\t dft_brightness, MAX_BRIGHTNESS);\n\t\tdft_brightness = MAX_BRIGHTNESS;\n\t}\n\n\t \n\terr = ht16k33_led_probe(dev, &priv->led, dft_brightness);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (client->irq > 0) {\n\t\terr = ht16k33_keypad_probe(client, &priv->keypad);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tswitch (priv->type) {\n\tcase DISP_MATRIX:\n\t\t \n\t\terr = ht16k33_fbdev_probe(dev, priv, dft_brightness);\n\t\tbreak;\n\n\tcase DISP_QUAD_7SEG:\n\tcase DISP_QUAD_14SEG:\n\t\t \n\t\terr = ht16k33_seg_probe(dev, priv, dft_brightness);\n\t\tbreak;\n\t}\n\treturn err;\n}\n\nstatic void ht16k33_remove(struct i2c_client *client)\n{\n\tstruct ht16k33_priv *priv = i2c_get_clientdata(client);\n\tstruct ht16k33_fbdev *fbdev = &priv->fbdev;\n\n\tcancel_delayed_work_sync(&priv->work);\n\n\tswitch (priv->type) {\n\tcase DISP_MATRIX:\n\t\tunregister_framebuffer(fbdev->info);\n\t\tframebuffer_release(fbdev->info);\n\t\tfree_page((unsigned long)fbdev->buffer);\n\t\tbreak;\n\n\tcase DISP_QUAD_7SEG:\n\tcase DISP_QUAD_14SEG:\n\t\tlinedisp_unregister(&priv->seg.linedisp);\n\t\tdevice_remove_file(&client->dev, &dev_attr_map_seg7);\n\t\tdevice_remove_file(&client->dev, &dev_attr_map_seg14);\n\t\tbreak;\n\t}\n}\n\nstatic const struct i2c_device_id ht16k33_i2c_match[] = {\n\t{ \"ht16k33\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, ht16k33_i2c_match);\n\nstatic const struct of_device_id ht16k33_of_match[] = {\n\t{\n\t\t \n\t\t.compatible = \"adafruit,3108\", .data = (void *)DISP_QUAD_7SEG,\n\t}, {\n\t\t \n\t\t.compatible = \"adafruit,3130\", .data = (void *)DISP_QUAD_14SEG,\n\t}, {\n\t\t \n\t\t.compatible = \"holtek,ht16k33\", .data = (void *)DISP_MATRIX,\n\t},\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, ht16k33_of_match);\n\nstatic struct i2c_driver ht16k33_driver = {\n\t.probe\t\t= ht16k33_probe,\n\t.remove\t\t= ht16k33_remove,\n\t.driver\t\t= {\n\t\t.name\t\t= DRIVER_NAME,\n\t\t.of_match_table\t= ht16k33_of_match,\n\t},\n\t.id_table = ht16k33_i2c_match,\n};\nmodule_i2c_driver(ht16k33_driver);\n\nMODULE_DESCRIPTION(\"Holtek HT16K33 driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Robin van der Gracht <robin@protonic.nl>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}