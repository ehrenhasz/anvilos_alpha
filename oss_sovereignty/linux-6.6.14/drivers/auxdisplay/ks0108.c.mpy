{
  "module_name": "ks0108.c",
  "hash_id": "fc6feafbbb3b38340566c8dd6e2440be9c9e060b8233ffdae3ded787cd4084e2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/auxdisplay/ks0108.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/delay.h>\n#include <linux/parport.h>\n#include <linux/ks0108.h>\n\n#define KS0108_NAME \"ks0108\"\n\n \n\nstatic unsigned int ks0108_port = CONFIG_KS0108_PORT;\nmodule_param(ks0108_port, uint, 0444);\nMODULE_PARM_DESC(ks0108_port, \"Parallel port where the LCD is connected\");\n\nstatic unsigned int ks0108_delay = CONFIG_KS0108_DELAY;\nmodule_param(ks0108_delay, uint, 0444);\nMODULE_PARM_DESC(ks0108_delay, \"Delay between each control writing (microseconds)\");\n\n \n\nstatic struct parport *ks0108_parport;\nstatic struct pardevice *ks0108_pardevice;\n\n \n\n#define bit(n) (((unsigned char)1)<<(n))\n\nvoid ks0108_writedata(unsigned char byte)\n{\n\tparport_write_data(ks0108_parport, byte);\n}\n\nvoid ks0108_writecontrol(unsigned char byte)\n{\n\tudelay(ks0108_delay);\n\tparport_write_control(ks0108_parport, byte ^ (bit(0) | bit(1) | bit(3)));\n}\n\nvoid ks0108_displaystate(unsigned char state)\n{\n\tks0108_writedata((state ? bit(0) : 0) | bit(1) | bit(2) | bit(3) | bit(4) | bit(5));\n}\n\nvoid ks0108_startline(unsigned char startline)\n{\n\tks0108_writedata(min_t(unsigned char, startline, 63) | bit(6) |\n\t\t\t bit(7));\n}\n\nvoid ks0108_address(unsigned char address)\n{\n\tks0108_writedata(min_t(unsigned char, address, 63) | bit(6));\n}\n\nvoid ks0108_page(unsigned char page)\n{\n\tks0108_writedata(min_t(unsigned char, page, 7) | bit(3) | bit(4) |\n\t\t\t bit(5) | bit(7));\n}\n\nEXPORT_SYMBOL_GPL(ks0108_writedata);\nEXPORT_SYMBOL_GPL(ks0108_writecontrol);\nEXPORT_SYMBOL_GPL(ks0108_displaystate);\nEXPORT_SYMBOL_GPL(ks0108_startline);\nEXPORT_SYMBOL_GPL(ks0108_address);\nEXPORT_SYMBOL_GPL(ks0108_page);\n\n \n\nstatic unsigned char ks0108_inited;\nunsigned char ks0108_isinited(void)\n{\n\treturn ks0108_inited;\n}\nEXPORT_SYMBOL_GPL(ks0108_isinited);\n\nstatic void ks0108_parport_attach(struct parport *port)\n{\n\tstruct pardev_cb ks0108_cb;\n\n\tif (port->base != ks0108_port)\n\t\treturn;\n\n\tmemset(&ks0108_cb, 0, sizeof(ks0108_cb));\n\tks0108_cb.flags = PARPORT_DEV_EXCL;\n\tks0108_pardevice = parport_register_dev_model(port, KS0108_NAME,\n\t\t\t\t\t\t      &ks0108_cb, 0);\n\tif (!ks0108_pardevice) {\n\t\tpr_err(\"ERROR: parport didn't register new device\\n\");\n\t\treturn;\n\t}\n\tif (parport_claim(ks0108_pardevice)) {\n\t\tpr_err(\"could not claim access to parport %i. Aborting.\\n\",\n\t\t       ks0108_port);\n\t\tgoto err_unreg_device;\n\t}\n\n\tks0108_parport = port;\n\tks0108_inited = 1;\n\treturn;\n\nerr_unreg_device:\n\tparport_unregister_device(ks0108_pardevice);\n\tks0108_pardevice = NULL;\n}\n\nstatic void ks0108_parport_detach(struct parport *port)\n{\n\tif (port->base != ks0108_port)\n\t\treturn;\n\n\tif (!ks0108_pardevice) {\n\t\tpr_err(\"%s: already unregistered.\\n\", KS0108_NAME);\n\t\treturn;\n\t}\n\n\tparport_release(ks0108_pardevice);\n\tparport_unregister_device(ks0108_pardevice);\n\tks0108_pardevice = NULL;\n\tks0108_parport = NULL;\n}\n\n \n\nstatic struct parport_driver ks0108_parport_driver = {\n\t.name = \"ks0108\",\n\t.match_port = ks0108_parport_attach,\n\t.detach = ks0108_parport_detach,\n\t.devmodel = true,\n};\nmodule_parport_driver(ks0108_parport_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Miguel Ojeda <ojeda@kernel.org>\");\nMODULE_DESCRIPTION(\"ks0108 LCD Controller driver\");\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}