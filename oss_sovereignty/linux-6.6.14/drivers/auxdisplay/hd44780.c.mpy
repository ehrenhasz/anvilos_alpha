{
  "module_name": "hd44780.c",
  "hash_id": "d9d112d13c5734b57d4582a6b17f45dbb9c4e44fa0f4436d84d0225056a32816",
  "original_prompt": "Ingested from linux-6.6.14/drivers/auxdisplay/hd44780.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/platform_device.h>\n#include <linux/property.h>\n#include <linux/slab.h>\n\n#include \"charlcd.h\"\n#include \"hd44780_common.h\"\n\nenum hd44780_pin {\n\t \n\tPIN_DATA0,\t \n\tPIN_DATA1,\t \n\tPIN_DATA2,\t \n\tPIN_DATA3,\t \n\tPIN_DATA4,\n\tPIN_DATA5,\n\tPIN_DATA6,\n\tPIN_DATA7,\n\tPIN_CTRL_RS,\n\tPIN_CTRL_RW,\t \n\tPIN_CTRL_E,\n\tPIN_CTRL_BL,    \n\tPIN_NUM\n};\n\nstruct hd44780 {\n\tstruct gpio_desc *pins[PIN_NUM];\n};\n\nstatic void hd44780_backlight(struct charlcd *lcd, enum charlcd_onoff on)\n{\n\tstruct hd44780_common *hdc = lcd->drvdata;\n\tstruct hd44780 *hd = hdc->hd44780;\n\n\tif (hd->pins[PIN_CTRL_BL])\n\t\tgpiod_set_value_cansleep(hd->pins[PIN_CTRL_BL], on);\n}\n\nstatic void hd44780_strobe_gpio(struct hd44780 *hd)\n{\n\t \n\tudelay(20);\n\n\tgpiod_set_value_cansleep(hd->pins[PIN_CTRL_E], 1);\n\n\t \n\tudelay(40);\n\n\tgpiod_set_value_cansleep(hd->pins[PIN_CTRL_E], 0);\n}\n\n \nstatic void hd44780_write_gpio8(struct hd44780 *hd, u8 val, unsigned int rs)\n{\n\tDECLARE_BITMAP(values, 10);  \n\tunsigned int n;\n\n\tvalues[0] = val;\n\t__assign_bit(8, values, rs);\n\tn = hd->pins[PIN_CTRL_RW] ? 10 : 9;\n\n\t \n\tgpiod_set_array_value_cansleep(n, &hd->pins[PIN_DATA0], NULL, values);\n\n\thd44780_strobe_gpio(hd);\n}\n\n \nstatic void hd44780_write_gpio4(struct hd44780 *hd, u8 val, unsigned int rs)\n{\n\tDECLARE_BITMAP(values, 6);  \n\tunsigned int n;\n\n\t \n\tvalues[0] = val >> 4;\n\t__assign_bit(4, values, rs);\n\tn = hd->pins[PIN_CTRL_RW] ? 6 : 5;\n\n\t \n\tgpiod_set_array_value_cansleep(n, &hd->pins[PIN_DATA4], NULL, values);\n\n\thd44780_strobe_gpio(hd);\n\n\t \n\tvalues[0] &= ~0x0fUL;\n\tvalues[0] |= val & 0x0f;\n\n\t \n\tgpiod_set_array_value_cansleep(n, &hd->pins[PIN_DATA4], NULL, values);\n\n\thd44780_strobe_gpio(hd);\n}\n\n \nstatic void hd44780_write_cmd_gpio8(struct hd44780_common *hdc, int cmd)\n{\n\tstruct hd44780 *hd = hdc->hd44780;\n\n\thd44780_write_gpio8(hd, cmd, 0);\n\n\t \n\tudelay(120);\n}\n\n \nstatic void hd44780_write_data_gpio8(struct hd44780_common *hdc, int data)\n{\n\tstruct hd44780 *hd = hdc->hd44780;\n\n\thd44780_write_gpio8(hd, data, 1);\n\n\t \n\tudelay(45);\n}\n\nstatic const struct charlcd_ops hd44780_ops_gpio8 = {\n\t.backlight\t= hd44780_backlight,\n\t.print\t\t= hd44780_common_print,\n\t.gotoxy\t\t= hd44780_common_gotoxy,\n\t.home\t\t= hd44780_common_home,\n\t.clear_display\t= hd44780_common_clear_display,\n\t.init_display\t= hd44780_common_init_display,\n\t.shift_cursor\t= hd44780_common_shift_cursor,\n\t.shift_display\t= hd44780_common_shift_display,\n\t.display\t= hd44780_common_display,\n\t.cursor\t\t= hd44780_common_cursor,\n\t.blink\t\t= hd44780_common_blink,\n\t.fontsize\t= hd44780_common_fontsize,\n\t.lines\t\t= hd44780_common_lines,\n\t.redefine_char\t= hd44780_common_redefine_char,\n};\n\n \nstatic void hd44780_write_cmd_gpio4(struct hd44780_common *hdc, int cmd)\n{\n\tstruct hd44780 *hd = hdc->hd44780;\n\n\thd44780_write_gpio4(hd, cmd, 0);\n\n\t \n\tudelay(120);\n}\n\n \nstatic void hd44780_write_cmd_raw_gpio4(struct hd44780_common *hdc, int cmd)\n{\n\tDECLARE_BITMAP(values, 6);  \n\tstruct hd44780 *hd = hdc->hd44780;\n\tunsigned int n;\n\n\t \n\tvalues[0] = cmd & 0x0f;\n\tn = hd->pins[PIN_CTRL_RW] ? 6 : 5;\n\n\t \n\tgpiod_set_array_value_cansleep(n, &hd->pins[PIN_DATA4], NULL, values);\n\n\thd44780_strobe_gpio(hd);\n}\n\n \nstatic void hd44780_write_data_gpio4(struct hd44780_common *hdc, int data)\n{\n\tstruct hd44780 *hd = hdc->hd44780;\n\n\thd44780_write_gpio4(hd, data, 1);\n\n\t \n\tudelay(45);\n}\n\nstatic const struct charlcd_ops hd44780_ops_gpio4 = {\n\t.backlight\t= hd44780_backlight,\n\t.print\t\t= hd44780_common_print,\n\t.gotoxy\t\t= hd44780_common_gotoxy,\n\t.home\t\t= hd44780_common_home,\n\t.clear_display\t= hd44780_common_clear_display,\n\t.init_display\t= hd44780_common_init_display,\n\t.shift_cursor\t= hd44780_common_shift_cursor,\n\t.shift_display\t= hd44780_common_shift_display,\n\t.display\t= hd44780_common_display,\n\t.cursor\t\t= hd44780_common_cursor,\n\t.blink\t\t= hd44780_common_blink,\n\t.fontsize\t= hd44780_common_fontsize,\n\t.lines\t\t= hd44780_common_lines,\n\t.redefine_char\t= hd44780_common_redefine_char,\n};\n\nstatic int hd44780_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tunsigned int i, base;\n\tstruct charlcd *lcd;\n\tstruct hd44780_common *hdc;\n\tstruct hd44780 *hd;\n\tint ifwidth, ret = -ENOMEM;\n\n\t \n\tifwidth = gpiod_count(dev, \"data\");\n\tif (ifwidth < 0)\n\t\treturn ifwidth;\n\n\tswitch (ifwidth) {\n\tcase 4:\n\t\tbase = PIN_DATA4;\n\t\tbreak;\n\tcase 8:\n\t\tbase = PIN_DATA0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\thdc = hd44780_common_alloc();\n\tif (!hdc)\n\t\treturn -ENOMEM;\n\n\tlcd = charlcd_alloc();\n\tif (!lcd)\n\t\tgoto fail1;\n\n\thd = kzalloc(sizeof(struct hd44780), GFP_KERNEL);\n\tif (!hd)\n\t\tgoto fail2;\n\n\thdc->hd44780 = hd;\n\tlcd->drvdata = hdc;\n\tfor (i = 0; i < ifwidth; i++) {\n\t\thd->pins[base + i] = devm_gpiod_get_index(dev, \"data\", i,\n\t\t\t\t\t\t\t  GPIOD_OUT_LOW);\n\t\tif (IS_ERR(hd->pins[base + i])) {\n\t\t\tret = PTR_ERR(hd->pins[base + i]);\n\t\t\tgoto fail3;\n\t\t}\n\t}\n\n\thd->pins[PIN_CTRL_E] = devm_gpiod_get(dev, \"enable\", GPIOD_OUT_LOW);\n\tif (IS_ERR(hd->pins[PIN_CTRL_E])) {\n\t\tret = PTR_ERR(hd->pins[PIN_CTRL_E]);\n\t\tgoto fail3;\n\t}\n\n\thd->pins[PIN_CTRL_RS] = devm_gpiod_get(dev, \"rs\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(hd->pins[PIN_CTRL_RS])) {\n\t\tret = PTR_ERR(hd->pins[PIN_CTRL_RS]);\n\t\tgoto fail3;\n\t}\n\n\t \n\thd->pins[PIN_CTRL_RW] = devm_gpiod_get_optional(dev, \"rw\",\n\t\t\t\t\t\t\tGPIOD_OUT_LOW);\n\tif (IS_ERR(hd->pins[PIN_CTRL_RW])) {\n\t\tret = PTR_ERR(hd->pins[PIN_CTRL_RW]);\n\t\tgoto fail3;\n\t}\n\n\thd->pins[PIN_CTRL_BL] = devm_gpiod_get_optional(dev, \"backlight\",\n\t\t\t\t\t\t\tGPIOD_OUT_LOW);\n\tif (IS_ERR(hd->pins[PIN_CTRL_BL])) {\n\t\tret = PTR_ERR(hd->pins[PIN_CTRL_BL]);\n\t\tgoto fail3;\n\t}\n\n\t \n\tret = device_property_read_u32(dev, \"display-height-chars\",\n\t\t\t\t       &lcd->height);\n\tif (ret)\n\t\tgoto fail3;\n\tret = device_property_read_u32(dev, \"display-width-chars\", &lcd->width);\n\tif (ret)\n\t\tgoto fail3;\n\n\t \n\tif (lcd->height > 2)\n\t\thdc->bwidth = lcd->width;\n\n\t \n\tdevice_property_read_u32(dev, \"internal-buffer-width\", &hdc->bwidth);\n\n\thdc->ifwidth = ifwidth;\n\tif (ifwidth == 8) {\n\t\tlcd->ops = &hd44780_ops_gpio8;\n\t\thdc->write_data = hd44780_write_data_gpio8;\n\t\thdc->write_cmd = hd44780_write_cmd_gpio8;\n\t} else {\n\t\tlcd->ops = &hd44780_ops_gpio4;\n\t\thdc->write_data = hd44780_write_data_gpio4;\n\t\thdc->write_cmd = hd44780_write_cmd_gpio4;\n\t\thdc->write_cmd_raw4 = hd44780_write_cmd_raw_gpio4;\n\t}\n\n\tret = charlcd_register(lcd);\n\tif (ret)\n\t\tgoto fail3;\n\n\tplatform_set_drvdata(pdev, lcd);\n\treturn 0;\n\nfail3:\n\tkfree(hd);\nfail2:\n\tkfree(lcd);\nfail1:\n\tkfree(hdc);\n\treturn ret;\n}\n\nstatic int hd44780_remove(struct platform_device *pdev)\n{\n\tstruct charlcd *lcd = platform_get_drvdata(pdev);\n\tstruct hd44780_common *hdc = lcd->drvdata;\n\n\tcharlcd_unregister(lcd);\n\tkfree(hdc->hd44780);\n\tkfree(lcd->drvdata);\n\n\tkfree(lcd);\n\treturn 0;\n}\n\nstatic const struct of_device_id hd44780_of_match[] = {\n\t{ .compatible = \"hit,hd44780\" },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, hd44780_of_match);\n\nstatic struct platform_driver hd44780_driver = {\n\t.probe = hd44780_probe,\n\t.remove = hd44780_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"hd44780\",\n\t\t.of_match_table = hd44780_of_match,\n\t},\n};\n\nmodule_platform_driver(hd44780_driver);\nMODULE_DESCRIPTION(\"HD44780 Character LCD driver\");\nMODULE_AUTHOR(\"Geert Uytterhoeven <geert@linux-m68k.org>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}