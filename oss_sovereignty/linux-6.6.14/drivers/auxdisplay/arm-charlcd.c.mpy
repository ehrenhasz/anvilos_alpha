{
  "module_name": "arm-charlcd.c",
  "hash_id": "5da6b11eb4df84d10c3420b6e25021a34331cecdfea1bd8ca32d2c885f9e9c1c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/auxdisplay/arm-charlcd.c",
  "human_readable_source": "\n \n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/platform_device.h>\n#include <linux/of.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <generated/utsrelease.h>\n\n#define DRIVERNAME \"arm-charlcd\"\n#define CHARLCD_TIMEOUT (msecs_to_jiffies(1000))\n\n \n#define CHAR_COM\t0x00U\n#define CHAR_DAT\t0x04U\n#define CHAR_RD\t\t0x08U\n#define CHAR_RAW\t0x0CU\n#define CHAR_MASK\t0x10U\n#define CHAR_STAT\t0x14U\n\n#define CHAR_RAW_CLEAR\t0x00000000U\n#define CHAR_RAW_VALID\t0x00000100U\n\n \n#define HD_CLEAR\t\t\t0x01U\n#define HD_HOME\t\t\t\t0x02U\n#define HD_ENTRYMODE\t\t\t0x04U\n#define HD_ENTRYMODE_INCREMENT\t\t0x02U\n#define HD_ENTRYMODE_SHIFT\t\t0x01U\n#define HD_DISPCTRL\t\t\t0x08U\n#define HD_DISPCTRL_ON\t\t\t0x04U\n#define HD_DISPCTRL_CURSOR_ON\t\t0x02U\n#define HD_DISPCTRL_CURSOR_BLINK\t0x01U\n#define HD_CRSR_SHIFT\t\t\t0x10U\n#define HD_CRSR_SHIFT_DISPLAY\t\t0x08U\n#define HD_CRSR_SHIFT_DISPLAY_RIGHT\t0x04U\n#define HD_FUNCSET\t\t\t0x20U\n#define HD_FUNCSET_8BIT\t\t\t0x10U\n#define HD_FUNCSET_2_LINES\t\t0x08U\n#define HD_FUNCSET_FONT_5X10\t\t0x04U\n#define HD_SET_CGRAM\t\t\t0x40U\n#define HD_SET_DDRAM\t\t\t0x80U\n#define HD_BUSY_FLAG\t\t\t0x80U\n\n \nstruct charlcd {\n\tstruct device *dev;\n\tu32 phybase;\n\tu32 physize;\n\tvoid __iomem *virtbase;\n\tint irq;\n\tstruct completion complete;\n\tstruct delayed_work init_work;\n};\n\nstatic irqreturn_t charlcd_interrupt(int irq, void *data)\n{\n\tstruct charlcd *lcd = data;\n\tu8 status;\n\n\tstatus = readl(lcd->virtbase + CHAR_STAT) & 0x01;\n\t \n\twritel(CHAR_RAW_CLEAR, lcd->virtbase + CHAR_RAW);\n\tif (status)\n\t\tcomplete(&lcd->complete);\n\telse\n\t\tdev_info(lcd->dev, \"Spurious IRQ (%02x)\\n\", status);\n\treturn IRQ_HANDLED;\n}\n\n\nstatic void charlcd_wait_complete_irq(struct charlcd *lcd)\n{\n\tint ret;\n\n\tret = wait_for_completion_interruptible_timeout(&lcd->complete,\n\t\t\t\t\t\t\tCHARLCD_TIMEOUT);\n\t \n\twritel(0x00, lcd->virtbase + CHAR_MASK);\n\n\tif (ret < 0) {\n\t\tdev_err(lcd->dev,\n\t\t\t\"wait_for_completion_interruptible_timeout() \"\n\t\t\t\"returned %d waiting for ready\\n\", ret);\n\t\treturn;\n\t}\n\n\tif (ret == 0) {\n\t\tdev_err(lcd->dev, \"charlcd controller timed out \"\n\t\t\t\"waiting for ready\\n\");\n\t\treturn;\n\t}\n}\n\nstatic u8 charlcd_4bit_read_char(struct charlcd *lcd)\n{\n\tu8 data;\n\tu32 val;\n\tint i;\n\n\t \n\tif (lcd->irq >= 0)\n\t\tcharlcd_wait_complete_irq(lcd);\n\telse {\n\t\ti = 0;\n\t\tval = 0;\n\t\twhile (!(val & CHAR_RAW_VALID) && i < 10) {\n\t\t\tudelay(100);\n\t\t\tval = readl(lcd->virtbase + CHAR_RAW);\n\t\t\ti++;\n\t\t}\n\n\t\twritel(CHAR_RAW_CLEAR, lcd->virtbase + CHAR_RAW);\n\t}\n\tmsleep(1);\n\n\t \n\tdata = readl(lcd->virtbase + CHAR_RD) & 0xf0;\n\n\t \n\ti = 0;\n\tval = 0;\n\twhile (!(val & CHAR_RAW_VALID) && i < 10) {\n\t\tudelay(100);\n\t\tval = readl(lcd->virtbase + CHAR_RAW);\n\t\ti++;\n\t}\n\twritel(CHAR_RAW_CLEAR, lcd->virtbase + CHAR_RAW);\n\tmsleep(1);\n\n\t \n\tdata |= (readl(lcd->virtbase + CHAR_RD) >> 4) & 0x0f;\n\n\treturn data;\n}\n\nstatic bool charlcd_4bit_read_bf(struct charlcd *lcd)\n{\n\tif (lcd->irq >= 0) {\n\t\t \n\t\twritel(CHAR_RAW_CLEAR, lcd->virtbase + CHAR_RAW);\n\t\tinit_completion(&lcd->complete);\n\t\twritel(0x01, lcd->virtbase + CHAR_MASK);\n\t}\n\treadl(lcd->virtbase + CHAR_COM);\n\treturn charlcd_4bit_read_char(lcd) & HD_BUSY_FLAG ? true : false;\n}\n\nstatic void charlcd_4bit_wait_busy(struct charlcd *lcd)\n{\n\tint retries = 50;\n\n\tudelay(100);\n\twhile (charlcd_4bit_read_bf(lcd) && retries)\n\t\tretries--;\n\tif (!retries)\n\t\tdev_err(lcd->dev, \"timeout waiting for busyflag\\n\");\n}\n\nstatic void charlcd_4bit_command(struct charlcd *lcd, u8 cmd)\n{\n\tu32 cmdlo = (cmd << 4) & 0xf0;\n\tu32 cmdhi = (cmd & 0xf0);\n\n\twritel(cmdhi, lcd->virtbase + CHAR_COM);\n\tudelay(10);\n\twritel(cmdlo, lcd->virtbase + CHAR_COM);\n\tcharlcd_4bit_wait_busy(lcd);\n}\n\nstatic void charlcd_4bit_char(struct charlcd *lcd, u8 ch)\n{\n\tu32 chlo = (ch << 4) & 0xf0;\n\tu32 chhi = (ch & 0xf0);\n\n\twritel(chhi, lcd->virtbase + CHAR_DAT);\n\tudelay(10);\n\twritel(chlo, lcd->virtbase + CHAR_DAT);\n\tcharlcd_4bit_wait_busy(lcd);\n}\n\nstatic void charlcd_4bit_print(struct charlcd *lcd, int line, const char *str)\n{\n\tu8 offset;\n\tint i;\n\n\t \n\tif (line == 0)\n\t\toffset = 0;\n\telse if (line == 1)\n\t\toffset = 0x28;\n\telse\n\t\treturn;\n\n\t \n\tcharlcd_4bit_command(lcd, HD_SET_DDRAM | offset);\n\n\t \n\tfor (i = 0; i < strlen(str) && i < 0x28; i++)\n\t\tcharlcd_4bit_char(lcd, str[i]);\n}\n\nstatic void charlcd_4bit_init(struct charlcd *lcd)\n{\n\t \n\twritel(HD_FUNCSET | HD_FUNCSET_8BIT, lcd->virtbase + CHAR_COM);\n\tmsleep(5);\n\twritel(HD_FUNCSET | HD_FUNCSET_8BIT, lcd->virtbase + CHAR_COM);\n\tudelay(100);\n\twritel(HD_FUNCSET | HD_FUNCSET_8BIT, lcd->virtbase + CHAR_COM);\n\tudelay(100);\n\t \n\twritel(HD_FUNCSET, lcd->virtbase + CHAR_COM);\n\tudelay(100);\n\t \n\tcharlcd_4bit_command(lcd, HD_FUNCSET | HD_FUNCSET_2_LINES);\n\tcharlcd_4bit_command(lcd, HD_DISPCTRL | HD_DISPCTRL_ON);\n\tcharlcd_4bit_command(lcd, HD_ENTRYMODE | HD_ENTRYMODE_INCREMENT);\n\tcharlcd_4bit_command(lcd, HD_CLEAR);\n\tcharlcd_4bit_command(lcd, HD_HOME);\n\t \n\tcharlcd_4bit_print(lcd, 0, \"ARM Linux\");\n\tcharlcd_4bit_print(lcd, 1, UTS_RELEASE);\n}\n\nstatic void charlcd_init_work(struct work_struct *work)\n{\n\tstruct charlcd *lcd =\n\t\tcontainer_of(work, struct charlcd, init_work.work);\n\n\tcharlcd_4bit_init(lcd);\n}\n\nstatic int __init charlcd_probe(struct platform_device *pdev)\n{\n\tint ret;\n\tstruct charlcd *lcd;\n\tstruct resource *res;\n\n\tlcd = kzalloc(sizeof(struct charlcd), GFP_KERNEL);\n\tif (!lcd)\n\t\treturn -ENOMEM;\n\n\tlcd->dev = &pdev->dev;\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res) {\n\t\tret = -ENOENT;\n\t\tgoto out_no_resource;\n\t}\n\tlcd->phybase = res->start;\n\tlcd->physize = resource_size(res);\n\n\tif (request_mem_region(lcd->phybase, lcd->physize,\n\t\t\t       DRIVERNAME) == NULL) {\n\t\tret = -EBUSY;\n\t\tgoto out_no_memregion;\n\t}\n\n\tlcd->virtbase = ioremap(lcd->phybase, lcd->physize);\n\tif (!lcd->virtbase) {\n\t\tret = -ENOMEM;\n\t\tgoto out_no_memregion;\n\t}\n\n\tlcd->irq = platform_get_irq(pdev, 0);\n\t \n\tif (lcd->irq >= 0) {\n\t\tif (request_irq(lcd->irq, charlcd_interrupt, 0,\n\t\t\t\tDRIVERNAME, lcd)) {\n\t\t\tret = -EIO;\n\t\t\tgoto out_no_irq;\n\t\t}\n\t}\n\n\tplatform_set_drvdata(pdev, lcd);\n\n\t \n\tINIT_DELAYED_WORK(&lcd->init_work, charlcd_init_work);\n\tschedule_delayed_work(&lcd->init_work, 0);\n\n\tdev_info(&pdev->dev, \"initialized ARM character LCD at %08x\\n\",\n\t\tlcd->phybase);\n\n\treturn 0;\n\nout_no_irq:\n\tiounmap(lcd->virtbase);\nout_no_memregion:\n\trelease_mem_region(lcd->phybase, SZ_4K);\nout_no_resource:\n\tkfree(lcd);\n\treturn ret;\n}\n\nstatic int charlcd_suspend(struct device *dev)\n{\n\tstruct charlcd *lcd = dev_get_drvdata(dev);\n\n\t \n\tcharlcd_4bit_command(lcd, HD_DISPCTRL);\n\treturn 0;\n}\n\nstatic int charlcd_resume(struct device *dev)\n{\n\tstruct charlcd *lcd = dev_get_drvdata(dev);\n\n\t \n\tcharlcd_4bit_command(lcd, HD_DISPCTRL | HD_DISPCTRL_ON);\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops charlcd_pm_ops = {\n\t.suspend = charlcd_suspend,\n\t.resume = charlcd_resume,\n};\n\nstatic const struct of_device_id charlcd_match[] = {\n\t{ .compatible = \"arm,versatile-lcd\", },\n\t{}\n};\n\nstatic struct platform_driver charlcd_driver = {\n\t.driver = {\n\t\t.name = DRIVERNAME,\n\t\t.pm = &charlcd_pm_ops,\n\t\t.suppress_bind_attrs = true,\n\t\t.of_match_table = of_match_ptr(charlcd_match),\n\t},\n};\nbuiltin_platform_driver_probe(charlcd_driver, charlcd_probe);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}