{
  "module_name": "charlcd.c",
  "hash_id": "c88db6d4312b005faeded1b4e3c3e2763e2a94b79ac7b4a3b2dd616c0868874d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/auxdisplay/charlcd.c",
  "human_readable_source": "\n \n\n#include <linux/atomic.h>\n#include <linux/ctype.h>\n#include <linux/fs.h>\n#include <linux/miscdevice.h>\n#include <linux/module.h>\n#include <linux/notifier.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/workqueue.h>\n\n#include <generated/utsrelease.h>\n\n#include \"charlcd.h\"\n\n \n#define LCD_BL_TEMPO_PERIOD\t4\n\n#define LCD_ESCAPE_LEN\t\t24\t \n#define LCD_ESCAPE_CHAR\t\t27\t \n\nstruct charlcd_priv {\n\tstruct charlcd lcd;\n\n\tstruct delayed_work bl_work;\n\tstruct mutex bl_tempo_lock;\t \n\tbool bl_tempo;\n\n\tbool must_clear;\n\n\t \n\tunsigned long flags;\n\n\t \n\tstruct {\n\t\tchar buf[LCD_ESCAPE_LEN + 1];\n\t\tint len;\n\t} esc_seq;\n\n\tunsigned long long drvdata[];\n};\n\n#define charlcd_to_priv(p)\tcontainer_of(p, struct charlcd_priv, lcd)\n\n \nstatic atomic_t charlcd_available = ATOMIC_INIT(1);\n\n \nvoid charlcd_backlight(struct charlcd *lcd, enum charlcd_onoff on)\n{\n\tstruct charlcd_priv *priv = charlcd_to_priv(lcd);\n\n\tif (!lcd->ops->backlight)\n\t\treturn;\n\n\tmutex_lock(&priv->bl_tempo_lock);\n\tif (!priv->bl_tempo)\n\t\tlcd->ops->backlight(lcd, on);\n\tmutex_unlock(&priv->bl_tempo_lock);\n}\nEXPORT_SYMBOL_GPL(charlcd_backlight);\n\nstatic void charlcd_bl_off(struct work_struct *work)\n{\n\tstruct delayed_work *dwork = to_delayed_work(work);\n\tstruct charlcd_priv *priv =\n\t\tcontainer_of(dwork, struct charlcd_priv, bl_work);\n\n\tmutex_lock(&priv->bl_tempo_lock);\n\tif (priv->bl_tempo) {\n\t\tpriv->bl_tempo = false;\n\t\tif (!(priv->flags & LCD_FLAG_L))\n\t\t\tpriv->lcd.ops->backlight(&priv->lcd, CHARLCD_OFF);\n\t}\n\tmutex_unlock(&priv->bl_tempo_lock);\n}\n\n \nvoid charlcd_poke(struct charlcd *lcd)\n{\n\tstruct charlcd_priv *priv = charlcd_to_priv(lcd);\n\n\tif (!lcd->ops->backlight)\n\t\treturn;\n\n\tcancel_delayed_work_sync(&priv->bl_work);\n\n\tmutex_lock(&priv->bl_tempo_lock);\n\tif (!priv->bl_tempo && !(priv->flags & LCD_FLAG_L))\n\t\tlcd->ops->backlight(lcd, CHARLCD_ON);\n\tpriv->bl_tempo = true;\n\tschedule_delayed_work(&priv->bl_work, LCD_BL_TEMPO_PERIOD * HZ);\n\tmutex_unlock(&priv->bl_tempo_lock);\n}\nEXPORT_SYMBOL_GPL(charlcd_poke);\n\nstatic void charlcd_home(struct charlcd *lcd)\n{\n\tlcd->addr.x = 0;\n\tlcd->addr.y = 0;\n\tlcd->ops->home(lcd);\n}\n\nstatic void charlcd_print(struct charlcd *lcd, char c)\n{\n\tif (lcd->addr.x >= lcd->width)\n\t\treturn;\n\n\tif (lcd->char_conv)\n\t\tc = lcd->char_conv[(unsigned char)c];\n\n\tif (!lcd->ops->print(lcd, c))\n\t\tlcd->addr.x++;\n\n\t \n\tif (lcd->addr.x == lcd->width)\n\t\tlcd->ops->gotoxy(lcd, lcd->addr.x - 1, lcd->addr.y);\n}\n\nstatic void charlcd_clear_display(struct charlcd *lcd)\n{\n\tlcd->ops->clear_display(lcd);\n\tlcd->addr.x = 0;\n\tlcd->addr.y = 0;\n}\n\n \nstatic bool parse_xy(const char *s, unsigned long *x, unsigned long *y)\n{\n\tunsigned long new_x = *x;\n\tunsigned long new_y = *y;\n\tchar *p;\n\n\tfor (;;) {\n\t\tif (!*s)\n\t\t\treturn false;\n\n\t\tif (*s == ';')\n\t\t\tbreak;\n\n\t\tif (*s == 'x') {\n\t\t\tnew_x = simple_strtoul(s + 1, &p, 10);\n\t\t\tif (p == s + 1)\n\t\t\t\treturn false;\n\t\t\ts = p;\n\t\t} else if (*s == 'y') {\n\t\t\tnew_y = simple_strtoul(s + 1, &p, 10);\n\t\t\tif (p == s + 1)\n\t\t\t\treturn false;\n\t\t\ts = p;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t*x = new_x;\n\t*y = new_y;\n\treturn true;\n}\n\n \n\nstatic inline int handle_lcd_special_code(struct charlcd *lcd)\n{\n\tstruct charlcd_priv *priv = charlcd_to_priv(lcd);\n\n\t \n\n\tint processed = 0;\n\n\tchar *esc = priv->esc_seq.buf + 2;\n\tint oldflags = priv->flags;\n\n\t \n\tswitch (*esc) {\n\tcase 'D':\t \n\t\tpriv->flags |= LCD_FLAG_D;\n\t\tif (priv->flags != oldflags)\n\t\t\tlcd->ops->display(lcd, CHARLCD_ON);\n\n\t\tprocessed = 1;\n\t\tbreak;\n\tcase 'd':\t \n\t\tpriv->flags &= ~LCD_FLAG_D;\n\t\tif (priv->flags != oldflags)\n\t\t\tlcd->ops->display(lcd, CHARLCD_OFF);\n\n\t\tprocessed = 1;\n\t\tbreak;\n\tcase 'C':\t \n\t\tpriv->flags |= LCD_FLAG_C;\n\t\tif (priv->flags != oldflags)\n\t\t\tlcd->ops->cursor(lcd, CHARLCD_ON);\n\n\t\tprocessed = 1;\n\t\tbreak;\n\tcase 'c':\t \n\t\tpriv->flags &= ~LCD_FLAG_C;\n\t\tif (priv->flags != oldflags)\n\t\t\tlcd->ops->cursor(lcd, CHARLCD_OFF);\n\n\t\tprocessed = 1;\n\t\tbreak;\n\tcase 'B':\t \n\t\tpriv->flags |= LCD_FLAG_B;\n\t\tif (priv->flags != oldflags)\n\t\t\tlcd->ops->blink(lcd, CHARLCD_ON);\n\n\t\tprocessed = 1;\n\t\tbreak;\n\tcase 'b':\t \n\t\tpriv->flags &= ~LCD_FLAG_B;\n\t\tif (priv->flags != oldflags)\n\t\t\tlcd->ops->blink(lcd, CHARLCD_OFF);\n\n\t\tprocessed = 1;\n\t\tbreak;\n\tcase '+':\t \n\t\tpriv->flags |= LCD_FLAG_L;\n\t\tif (priv->flags != oldflags)\n\t\t\tcharlcd_backlight(lcd, CHARLCD_ON);\n\n\t\tprocessed = 1;\n\t\tbreak;\n\tcase '-':\t \n\t\tpriv->flags &= ~LCD_FLAG_L;\n\t\tif (priv->flags != oldflags)\n\t\t\tcharlcd_backlight(lcd, CHARLCD_OFF);\n\n\t\tprocessed = 1;\n\t\tbreak;\n\tcase '*':\t \n\t\tcharlcd_poke(lcd);\n\t\tprocessed = 1;\n\t\tbreak;\n\tcase 'f':\t \n\t\tpriv->flags &= ~LCD_FLAG_F;\n\t\tif (priv->flags != oldflags)\n\t\t\tlcd->ops->fontsize(lcd, CHARLCD_FONTSIZE_SMALL);\n\n\t\tprocessed = 1;\n\t\tbreak;\n\tcase 'F':\t \n\t\tpriv->flags |= LCD_FLAG_F;\n\t\tif (priv->flags != oldflags)\n\t\t\tlcd->ops->fontsize(lcd, CHARLCD_FONTSIZE_LARGE);\n\n\t\tprocessed = 1;\n\t\tbreak;\n\tcase 'n':\t \n\t\tpriv->flags &= ~LCD_FLAG_N;\n\t\tif (priv->flags != oldflags)\n\t\t\tlcd->ops->lines(lcd, CHARLCD_LINES_1);\n\n\t\tprocessed = 1;\n\t\tbreak;\n\tcase 'N':\t \n\t\tpriv->flags |= LCD_FLAG_N;\n\t\tif (priv->flags != oldflags)\n\t\t\tlcd->ops->lines(lcd, CHARLCD_LINES_2);\n\n\t\tprocessed = 1;\n\t\tbreak;\n\tcase 'l':\t \n\t\tif (lcd->addr.x > 0) {\n\t\t\tif (!lcd->ops->shift_cursor(lcd, CHARLCD_SHIFT_LEFT))\n\t\t\t\tlcd->addr.x--;\n\t\t}\n\n\t\tprocessed = 1;\n\t\tbreak;\n\tcase 'r':\t \n\t\tif (lcd->addr.x < lcd->width) {\n\t\t\tif (!lcd->ops->shift_cursor(lcd, CHARLCD_SHIFT_RIGHT))\n\t\t\t\tlcd->addr.x++;\n\t\t}\n\n\t\tprocessed = 1;\n\t\tbreak;\n\tcase 'L':\t \n\t\tlcd->ops->shift_display(lcd, CHARLCD_SHIFT_LEFT);\n\t\tprocessed = 1;\n\t\tbreak;\n\tcase 'R':\t \n\t\tlcd->ops->shift_display(lcd, CHARLCD_SHIFT_RIGHT);\n\t\tprocessed = 1;\n\t\tbreak;\n\tcase 'k': {\t \n\t\tint x, xs, ys;\n\n\t\txs = lcd->addr.x;\n\t\tys = lcd->addr.y;\n\t\tfor (x = lcd->addr.x; x < lcd->width; x++)\n\t\t\tlcd->ops->print(lcd, ' ');\n\n\t\t \n\t\tlcd->addr.x = xs;\n\t\tlcd->addr.y = ys;\n\t\tlcd->ops->gotoxy(lcd, lcd->addr.x, lcd->addr.y);\n\t\tprocessed = 1;\n\t\tbreak;\n\t}\n\tcase 'I':\t \n\t\tlcd->ops->init_display(lcd);\n\t\tpriv->flags = ((lcd->height > 1) ? LCD_FLAG_N : 0) | LCD_FLAG_D |\n\t\t\tLCD_FLAG_C | LCD_FLAG_B;\n\t\tprocessed = 1;\n\t\tbreak;\n\tcase 'G':\n\t\tif (lcd->ops->redefine_char)\n\t\t\tprocessed = lcd->ops->redefine_char(lcd, esc);\n\t\telse\n\t\t\tprocessed = 1;\n\t\tbreak;\n\n\tcase 'x':\t \n\tcase 'y':\t \n\t\tif (priv->esc_seq.buf[priv->esc_seq.len - 1] != ';')\n\t\t\tbreak;\n\n\t\t \n\t\tif (parse_xy(esc, &lcd->addr.x, &lcd->addr.y))\n\t\t\tlcd->ops->gotoxy(lcd, lcd->addr.x, lcd->addr.y);\n\n\t\t \n\t\tprocessed = 1;\n\t\tbreak;\n\t}\n\n\treturn processed;\n}\n\nstatic void charlcd_write_char(struct charlcd *lcd, char c)\n{\n\tstruct charlcd_priv *priv = charlcd_to_priv(lcd);\n\n\t \n\tif ((c != '\\n') && priv->esc_seq.len >= 0) {\n\t\t \n\t\tpriv->esc_seq.buf[priv->esc_seq.len++] = c;\n\t\tpriv->esc_seq.buf[priv->esc_seq.len] = '\\0';\n\t} else {\n\t\t \n\t\tpriv->esc_seq.len = -1;\n\n\t\tswitch (c) {\n\t\tcase LCD_ESCAPE_CHAR:\n\t\t\t \n\t\t\tpriv->esc_seq.len = 0;\n\t\t\tpriv->esc_seq.buf[priv->esc_seq.len] = '\\0';\n\t\t\tbreak;\n\t\tcase '\\b':\n\t\t\t \n\t\t\tif (lcd->addr.x > 0) {\n\t\t\t\t \n\t\t\t\tif (!lcd->ops->shift_cursor(lcd,\n\t\t\t\t\t\t\tCHARLCD_SHIFT_LEFT))\n\t\t\t\t\tlcd->addr.x--;\n\t\t\t}\n\t\t\t \n\t\t\tcharlcd_print(lcd, ' ');\n\t\t\t \n\t\t\tif (!lcd->ops->shift_cursor(lcd, CHARLCD_SHIFT_LEFT))\n\t\t\t\tlcd->addr.x--;\n\n\t\t\tbreak;\n\t\tcase '\\f':\n\t\t\t \n\t\t\tcharlcd_clear_display(lcd);\n\t\t\tbreak;\n\t\tcase '\\n':\n\t\t\t \n\t\t\tfor (; lcd->addr.x < lcd->width; lcd->addr.x++)\n\t\t\t\tlcd->ops->print(lcd, ' ');\n\n\t\t\tlcd->addr.x = 0;\n\t\t\tlcd->addr.y = (lcd->addr.y + 1) % lcd->height;\n\t\t\tlcd->ops->gotoxy(lcd, lcd->addr.x, lcd->addr.y);\n\t\t\tbreak;\n\t\tcase '\\r':\n\t\t\t \n\t\t\tlcd->addr.x = 0;\n\t\t\tlcd->ops->gotoxy(lcd, lcd->addr.x, lcd->addr.y);\n\t\t\tbreak;\n\t\tcase '\\t':\n\t\t\t \n\t\t\tcharlcd_print(lcd, ' ');\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\tcharlcd_print(lcd, c);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (priv->esc_seq.len >= 2) {\n\t\tint processed = 0;\n\n\t\tif (!strcmp(priv->esc_seq.buf, \"[2J\")) {\n\t\t\t \n\t\t\tcharlcd_clear_display(lcd);\n\t\t\tprocessed = 1;\n\t\t} else if (!strcmp(priv->esc_seq.buf, \"[H\")) {\n\t\t\t \n\t\t\tcharlcd_home(lcd);\n\t\t\tprocessed = 1;\n\t\t}\n\t\t \n\t\telse if ((priv->esc_seq.len >= 3) &&\n\t\t\t (priv->esc_seq.buf[0] == '[') &&\n\t\t\t (priv->esc_seq.buf[1] == 'L')) {\n\t\t\tprocessed = handle_lcd_special_code(lcd);\n\t\t}\n\n\t\t \n\t\t \n\t\tif (processed || (priv->esc_seq.len >= LCD_ESCAPE_LEN))\n\t\t\tpriv->esc_seq.len = -1;\n\t}  \n}\n\nstatic struct charlcd *the_charlcd;\n\nstatic ssize_t charlcd_write(struct file *file, const char __user *buf,\n\t\t\t     size_t count, loff_t *ppos)\n{\n\tconst char __user *tmp = buf;\n\tchar c;\n\n\tfor (; count-- > 0; (*ppos)++, tmp++) {\n\t\tif (((count + 1) & 0x1f) == 0) {\n\t\t\t \n\t\t\tcond_resched();\n\t\t}\n\n\t\tif (get_user(c, tmp))\n\t\t\treturn -EFAULT;\n\n\t\tcharlcd_write_char(the_charlcd, c);\n\t}\n\n\treturn tmp - buf;\n}\n\nstatic int charlcd_open(struct inode *inode, struct file *file)\n{\n\tstruct charlcd_priv *priv = charlcd_to_priv(the_charlcd);\n\tint ret;\n\n\tret = -EBUSY;\n\tif (!atomic_dec_and_test(&charlcd_available))\n\t\tgoto fail;\t \n\n\tret = -EPERM;\n\tif (file->f_mode & FMODE_READ)\t \n\t\tgoto fail;\n\n\tif (priv->must_clear) {\n\t\tpriv->lcd.ops->clear_display(&priv->lcd);\n\t\tpriv->must_clear = false;\n\t\tpriv->lcd.addr.x = 0;\n\t\tpriv->lcd.addr.y = 0;\n\t}\n\treturn nonseekable_open(inode, file);\n\n fail:\n\tatomic_inc(&charlcd_available);\n\treturn ret;\n}\n\nstatic int charlcd_release(struct inode *inode, struct file *file)\n{\n\tatomic_inc(&charlcd_available);\n\treturn 0;\n}\n\nstatic const struct file_operations charlcd_fops = {\n\t.write   = charlcd_write,\n\t.open    = charlcd_open,\n\t.release = charlcd_release,\n\t.llseek  = no_llseek,\n};\n\nstatic struct miscdevice charlcd_dev = {\n\t.minor\t= LCD_MINOR,\n\t.name\t= \"lcd\",\n\t.fops\t= &charlcd_fops,\n};\n\nstatic void charlcd_puts(struct charlcd *lcd, const char *s)\n{\n\tconst char *tmp = s;\n\tint count = strlen(s);\n\n\tfor (; count-- > 0; tmp++) {\n\t\tif (((count + 1) & 0x1f) == 0)\n\t\t\tcond_resched();\n\n\t\tcharlcd_write_char(lcd, *tmp);\n\t}\n}\n\n#ifdef CONFIG_PANEL_BOOT_MESSAGE\n#define LCD_INIT_TEXT CONFIG_PANEL_BOOT_MESSAGE\n#else\n#define LCD_INIT_TEXT \"Linux-\" UTS_RELEASE \"\\n\"\n#endif\n\n#ifdef CONFIG_CHARLCD_BL_ON\n#define LCD_INIT_BL \"\\x1b[L+\"\n#elif defined(CONFIG_CHARLCD_BL_FLASH)\n#define LCD_INIT_BL \"\\x1b[L*\"\n#else\n#define LCD_INIT_BL \"\\x1b[L-\"\n#endif\n\n \nstatic int charlcd_init(struct charlcd *lcd)\n{\n\tstruct charlcd_priv *priv = charlcd_to_priv(lcd);\n\tint ret;\n\n\tpriv->flags = ((lcd->height > 1) ? LCD_FLAG_N : 0) | LCD_FLAG_D |\n\t\t      LCD_FLAG_C | LCD_FLAG_B;\n\tif (lcd->ops->backlight) {\n\t\tmutex_init(&priv->bl_tempo_lock);\n\t\tINIT_DELAYED_WORK(&priv->bl_work, charlcd_bl_off);\n\t}\n\n\t \n\tif (WARN_ON(!lcd->ops->init_display))\n\t\treturn -EINVAL;\n\n\tret = lcd->ops->init_display(lcd);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tcharlcd_puts(lcd, \"\\x1b[Lc\\x1b[Lb\" LCD_INIT_BL LCD_INIT_TEXT);\n\n\t \n\tpriv->must_clear = true;\n\tcharlcd_home(lcd);\n\treturn 0;\n}\n\nstruct charlcd *charlcd_alloc(void)\n{\n\tstruct charlcd_priv *priv;\n\tstruct charlcd *lcd;\n\n\tpriv = kzalloc(sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn NULL;\n\n\tpriv->esc_seq.len = -1;\n\n\tlcd = &priv->lcd;\n\n\treturn lcd;\n}\nEXPORT_SYMBOL_GPL(charlcd_alloc);\n\nvoid charlcd_free(struct charlcd *lcd)\n{\n\tkfree(charlcd_to_priv(lcd));\n}\nEXPORT_SYMBOL_GPL(charlcd_free);\n\nstatic int panel_notify_sys(struct notifier_block *this, unsigned long code,\n\t\t\t    void *unused)\n{\n\tstruct charlcd *lcd = the_charlcd;\n\n\tswitch (code) {\n\tcase SYS_DOWN:\n\t\tcharlcd_puts(lcd,\n\t\t\t     \"\\x0cReloading\\nSystem...\\x1b[Lc\\x1b[Lb\\x1b[L+\");\n\t\tbreak;\n\tcase SYS_HALT:\n\t\tcharlcd_puts(lcd, \"\\x0cSystem Halted.\\x1b[Lc\\x1b[Lb\\x1b[L+\");\n\t\tbreak;\n\tcase SYS_POWER_OFF:\n\t\tcharlcd_puts(lcd, \"\\x0cPower off.\\x1b[Lc\\x1b[Lb\\x1b[L+\");\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block panel_notifier = {\n\t.notifier_call = panel_notify_sys,\n};\n\nint charlcd_register(struct charlcd *lcd)\n{\n\tint ret;\n\n\tret = charlcd_init(lcd);\n\tif (ret)\n\t\treturn ret;\n\n\tret = misc_register(&charlcd_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tthe_charlcd = lcd;\n\tregister_reboot_notifier(&panel_notifier);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(charlcd_register);\n\nint charlcd_unregister(struct charlcd *lcd)\n{\n\tstruct charlcd_priv *priv = charlcd_to_priv(lcd);\n\n\tunregister_reboot_notifier(&panel_notifier);\n\tcharlcd_puts(lcd, \"\\x0cLCD driver unloaded.\\x1b[Lc\\x1b[Lb\\x1b[L-\");\n\tmisc_deregister(&charlcd_dev);\n\tthe_charlcd = NULL;\n\tif (lcd->ops->backlight) {\n\t\tcancel_delayed_work_sync(&priv->bl_work);\n\t\tpriv->lcd.ops->backlight(&priv->lcd, CHARLCD_OFF);\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(charlcd_unregister);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}