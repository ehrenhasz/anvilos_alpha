{
  "module_name": "panel.c",
  "hash_id": "39ae65fd6218b0b3e7ce8e9a9e0403336c36075dd7bd7482e7a26c73f5b25b40",
  "original_prompt": "Ingested from linux-6.6.14/drivers/auxdisplay/panel.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n\n#include <linux/types.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/miscdevice.h>\n#include <linux/slab.h>\n#include <linux/ioport.h>\n#include <linux/fcntl.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/parport.h>\n#include <linux/list.h>\n\n#include <linux/io.h>\n#include <linux/uaccess.h>\n\n#include \"charlcd.h\"\n#include \"hd44780_common.h\"\n\n#define LCD_MAXBYTES\t\t256\t \n\n#define KEYPAD_BUFFER\t\t64\n\n \n#define INPUT_POLL_TIME\t\t(HZ / 50)\n \n#define KEYPAD_REP_START\t(10)\n \n#define KEYPAD_REP_DELAY\t(2)\n\n \n#define PNL_PINPUT(a)\t\t((((unsigned char)(a)) ^ 0x7F) >> 3)\n\n#define PNL_PBUSY\t\t0x80\t \n#define PNL_PACK\t\t0x40\t \n#define PNL_POUTPA\t\t0x20\t \n#define PNL_PSELECD\t\t0x10\t \n#define PNL_PERRORP\t\t0x08\t \n\n#define PNL_PBIDIR\t\t0x20\t \n \n#define PNL_PINTEN\t\t0x10\n#define PNL_PSELECP\t\t0x08\t \n#define PNL_PINITP\t\t0x04\t \n#define PNL_PAUTOLF\t\t0x02\t \n#define PNL_PSTROBE\t\t0x01\t \n\n#define PNL_PD0\t\t\t0x01\n#define PNL_PD1\t\t\t0x02\n#define PNL_PD2\t\t\t0x04\n#define PNL_PD3\t\t\t0x08\n#define PNL_PD4\t\t\t0x10\n#define PNL_PD5\t\t\t0x20\n#define PNL_PD6\t\t\t0x40\n#define PNL_PD7\t\t\t0x80\n\n#define PIN_NONE\t\t0\n#define PIN_STROBE\t\t1\n#define PIN_D0\t\t\t2\n#define PIN_D1\t\t\t3\n#define PIN_D2\t\t\t4\n#define PIN_D3\t\t\t5\n#define PIN_D4\t\t\t6\n#define PIN_D5\t\t\t7\n#define PIN_D6\t\t\t8\n#define PIN_D7\t\t\t9\n#define PIN_AUTOLF\t\t14\n#define PIN_INITP\t\t16\n#define PIN_SELECP\t\t17\n#define PIN_NOT_SET\t\t127\n\n#define NOT_SET\t\t\t-1\n\n \n#define r_ctr(x)        (parport_read_control((x)->port))\n#define r_dtr(x)        (parport_read_data((x)->port))\n#define r_str(x)        (parport_read_status((x)->port))\n#define w_ctr(x, y)     (parport_write_control((x)->port, (y)))\n#define w_dtr(x, y)     (parport_write_data((x)->port, (y)))\n\n \n \nstatic __u8 scan_mask_o;\n \nstatic __u8 scan_mask_i;\n\nenum input_type {\n\tINPUT_TYPE_STD,\n\tINPUT_TYPE_KBD,\n};\n\nenum input_state {\n\tINPUT_ST_LOW,\n\tINPUT_ST_RISING,\n\tINPUT_ST_HIGH,\n\tINPUT_ST_FALLING,\n};\n\nstruct logical_input {\n\tstruct list_head list;\n\t__u64 mask;\n\t__u64 value;\n\tenum input_type type;\n\tenum input_state state;\n\t__u8 rise_time, fall_time;\n\t__u8 rise_timer, fall_timer, high_timer;\n\n\tunion {\n\t\tstruct {\t \n\t\t\tvoid (*press_fct)(int);\n\t\t\tvoid (*release_fct)(int);\n\t\t\tint press_data;\n\t\t\tint release_data;\n\t\t} std;\n\t\tstruct {\t \n\t\t\tchar press_str[sizeof(void *) + sizeof(int)] __nonstring;\n\t\t\tchar repeat_str[sizeof(void *) + sizeof(int)] __nonstring;\n\t\t\tchar release_str[sizeof(void *) + sizeof(int)] __nonstring;\n\t\t} kbd;\n\t} u;\n};\n\nstatic LIST_HEAD(logical_inputs);\t \n\n \n\n \nstatic __u64 phys_read;\n \nstatic __u64 phys_read_prev;\n \nstatic __u64 phys_curr;\n \nstatic __u64 phys_prev;\n \nstatic char inputs_stable;\n\n \nstatic struct {\n\tbool enabled;\n} keypad;\n\nstatic char keypad_buffer[KEYPAD_BUFFER];\nstatic int keypad_buflen;\nstatic int keypad_start;\nstatic char keypressed;\nstatic wait_queue_head_t keypad_read_wait;\n\n \nstatic struct {\n\tbool enabled;\n\tbool initialized;\n\n\tint charset;\n\tint proto;\n\n\t \n\tstruct {\n\t\tint e;\n\t\tint rs;\n\t\tint rw;\n\t\tint cl;\n\t\tint da;\n\t\tint bl;\n\t} pins;\n\n\tstruct charlcd *charlcd;\n} lcd;\n\n \nstatic int selected_lcd_type = NOT_SET;\n\n \n#define BIT_CLR\t\t0\n#define BIT_SET\t\t1\n#define BIT_MSK\t\t2\n#define BIT_STATES\t3\n \n#define LCD_BIT_E\t0\n#define LCD_BIT_RS\t1\n#define LCD_BIT_RW\t2\n#define LCD_BIT_BL\t3\n#define LCD_BIT_CL\t4\n#define LCD_BIT_DA\t5\n#define LCD_BITS\t6\n\n \n#define LCD_PORT_C\t0\n#define LCD_PORT_D\t1\n#define LCD_PORTS\t2\n\nstatic unsigned char lcd_bits[LCD_PORTS][LCD_BITS][BIT_STATES];\n\n \n#define LCD_PROTO_PARALLEL      0\n#define LCD_PROTO_SERIAL        1\n#define LCD_PROTO_TI_DA8XX_LCD\t2\n\n \n#define LCD_CHARSET_NORMAL      0\n#define LCD_CHARSET_KS0074      1\n\n \n#define LCD_TYPE_NONE\t\t0\n#define LCD_TYPE_CUSTOM\t\t1\n#define LCD_TYPE_OLD\t\t2\n#define LCD_TYPE_KS0074\t\t3\n#define LCD_TYPE_HANTRONIX\t4\n#define LCD_TYPE_NEXCOM\t\t5\n\n \n#define KEYPAD_TYPE_NONE\t0\n#define KEYPAD_TYPE_OLD\t\t1\n#define KEYPAD_TYPE_NEW\t\t2\n#define KEYPAD_TYPE_NEXCOM\t3\n\n \n#define PANEL_PROFILE_CUSTOM\t0\n#define PANEL_PROFILE_OLD\t1\n#define PANEL_PROFILE_NEW\t2\n#define PANEL_PROFILE_HANTRONIX\t3\n#define PANEL_PROFILE_NEXCOM\t4\n#define PANEL_PROFILE_LARGE\t5\n\n \n#define DEFAULT_PARPORT         0\n#define DEFAULT_PROFILE         PANEL_PROFILE_LARGE\n#define DEFAULT_KEYPAD_TYPE     KEYPAD_TYPE_OLD\n#define DEFAULT_LCD_TYPE        LCD_TYPE_OLD\n#define DEFAULT_LCD_HEIGHT      2\n#define DEFAULT_LCD_WIDTH       40\n#define DEFAULT_LCD_CHARSET     LCD_CHARSET_NORMAL\n#define DEFAULT_LCD_PROTO       LCD_PROTO_PARALLEL\n\n#define DEFAULT_LCD_PIN_E       PIN_AUTOLF\n#define DEFAULT_LCD_PIN_RS      PIN_SELECP\n#define DEFAULT_LCD_PIN_RW      PIN_INITP\n#define DEFAULT_LCD_PIN_SCL     PIN_STROBE\n#define DEFAULT_LCD_PIN_SDA     PIN_D0\n#define DEFAULT_LCD_PIN_BL      PIN_NOT_SET\n\n#ifdef CONFIG_PANEL_PARPORT\n#undef DEFAULT_PARPORT\n#define DEFAULT_PARPORT CONFIG_PANEL_PARPORT\n#endif\n\n#ifdef CONFIG_PANEL_PROFILE\n#undef DEFAULT_PROFILE\n#define DEFAULT_PROFILE CONFIG_PANEL_PROFILE\n#endif\n\n#if DEFAULT_PROFILE == 0\t \n#ifdef CONFIG_PANEL_KEYPAD\n#undef DEFAULT_KEYPAD_TYPE\n#define DEFAULT_KEYPAD_TYPE CONFIG_PANEL_KEYPAD\n#endif\n\n#ifdef CONFIG_PANEL_LCD\n#undef DEFAULT_LCD_TYPE\n#define DEFAULT_LCD_TYPE CONFIG_PANEL_LCD\n#endif\n\n#ifdef CONFIG_PANEL_LCD_HEIGHT\n#undef DEFAULT_LCD_HEIGHT\n#define DEFAULT_LCD_HEIGHT CONFIG_PANEL_LCD_HEIGHT\n#endif\n\n#ifdef CONFIG_PANEL_LCD_WIDTH\n#undef DEFAULT_LCD_WIDTH\n#define DEFAULT_LCD_WIDTH CONFIG_PANEL_LCD_WIDTH\n#endif\n\n#ifdef CONFIG_PANEL_LCD_BWIDTH\n#undef DEFAULT_LCD_BWIDTH\n#define DEFAULT_LCD_BWIDTH CONFIG_PANEL_LCD_BWIDTH\n#endif\n\n#ifdef CONFIG_PANEL_LCD_HWIDTH\n#undef DEFAULT_LCD_HWIDTH\n#define DEFAULT_LCD_HWIDTH CONFIG_PANEL_LCD_HWIDTH\n#endif\n\n#ifdef CONFIG_PANEL_LCD_CHARSET\n#undef DEFAULT_LCD_CHARSET\n#define DEFAULT_LCD_CHARSET CONFIG_PANEL_LCD_CHARSET\n#endif\n\n#ifdef CONFIG_PANEL_LCD_PROTO\n#undef DEFAULT_LCD_PROTO\n#define DEFAULT_LCD_PROTO CONFIG_PANEL_LCD_PROTO\n#endif\n\n#ifdef CONFIG_PANEL_LCD_PIN_E\n#undef DEFAULT_LCD_PIN_E\n#define DEFAULT_LCD_PIN_E CONFIG_PANEL_LCD_PIN_E\n#endif\n\n#ifdef CONFIG_PANEL_LCD_PIN_RS\n#undef DEFAULT_LCD_PIN_RS\n#define DEFAULT_LCD_PIN_RS CONFIG_PANEL_LCD_PIN_RS\n#endif\n\n#ifdef CONFIG_PANEL_LCD_PIN_RW\n#undef DEFAULT_LCD_PIN_RW\n#define DEFAULT_LCD_PIN_RW CONFIG_PANEL_LCD_PIN_RW\n#endif\n\n#ifdef CONFIG_PANEL_LCD_PIN_SCL\n#undef DEFAULT_LCD_PIN_SCL\n#define DEFAULT_LCD_PIN_SCL CONFIG_PANEL_LCD_PIN_SCL\n#endif\n\n#ifdef CONFIG_PANEL_LCD_PIN_SDA\n#undef DEFAULT_LCD_PIN_SDA\n#define DEFAULT_LCD_PIN_SDA CONFIG_PANEL_LCD_PIN_SDA\n#endif\n\n#ifdef CONFIG_PANEL_LCD_PIN_BL\n#undef DEFAULT_LCD_PIN_BL\n#define DEFAULT_LCD_PIN_BL CONFIG_PANEL_LCD_PIN_BL\n#endif\n\n#endif  \n\n \n\n \nstatic atomic_t keypad_available = ATOMIC_INIT(1);\n\nstatic struct pardevice *pprt;\n\nstatic int keypad_initialized;\n\nstatic DEFINE_SPINLOCK(pprt_lock);\nstatic struct timer_list scan_timer;\n\nMODULE_DESCRIPTION(\"Generic parallel port LCD/Keypad driver\");\n\nstatic int parport = DEFAULT_PARPORT;\nmodule_param(parport, int, 0000);\nMODULE_PARM_DESC(parport, \"Parallel port index (0=lpt1, 1=lpt2, ...)\");\n\nstatic int profile = DEFAULT_PROFILE;\nmodule_param(profile, int, 0000);\nMODULE_PARM_DESC(profile,\n\t\t \"1=16x2 old kp; 2=serial 16x2, new kp; 3=16x2 hantronix; \"\n\t\t \"4=16x2 nexcom; default=40x2, old kp\");\n\nstatic int keypad_type = NOT_SET;\nmodule_param(keypad_type, int, 0000);\nMODULE_PARM_DESC(keypad_type,\n\t\t \"Keypad type: 0=none, 1=old 6 keys, 2=new 6+1 keys, 3=nexcom 4 keys\");\n\nstatic int lcd_type = NOT_SET;\nmodule_param(lcd_type, int, 0000);\nMODULE_PARM_DESC(lcd_type,\n\t\t \"LCD type: 0=none, 1=compiled-in, 2=old, 3=serial ks0074, 4=hantronix, 5=nexcom\");\n\nstatic int lcd_height = NOT_SET;\nmodule_param(lcd_height, int, 0000);\nMODULE_PARM_DESC(lcd_height, \"Number of lines on the LCD\");\n\nstatic int lcd_width = NOT_SET;\nmodule_param(lcd_width, int, 0000);\nMODULE_PARM_DESC(lcd_width, \"Number of columns on the LCD\");\n\nstatic int lcd_bwidth = NOT_SET;\t \nmodule_param(lcd_bwidth, int, 0000);\nMODULE_PARM_DESC(lcd_bwidth, \"Internal LCD line width (40)\");\n\nstatic int lcd_hwidth = NOT_SET;\t \nmodule_param(lcd_hwidth, int, 0000);\nMODULE_PARM_DESC(lcd_hwidth, \"LCD line hardware address (64)\");\n\nstatic int lcd_charset = NOT_SET;\nmodule_param(lcd_charset, int, 0000);\nMODULE_PARM_DESC(lcd_charset, \"LCD character set: 0=standard, 1=KS0074\");\n\nstatic int lcd_proto = NOT_SET;\nmodule_param(lcd_proto, int, 0000);\nMODULE_PARM_DESC(lcd_proto,\n\t\t \"LCD communication: 0=parallel (//), 1=serial, 2=TI LCD Interface\");\n\n \n\nstatic int lcd_e_pin  = PIN_NOT_SET;\nmodule_param(lcd_e_pin, int, 0000);\nMODULE_PARM_DESC(lcd_e_pin,\n\t\t \"# of the // port pin connected to LCD 'E' signal, with polarity (-17..17)\");\n\nstatic int lcd_rs_pin = PIN_NOT_SET;\nmodule_param(lcd_rs_pin, int, 0000);\nMODULE_PARM_DESC(lcd_rs_pin,\n\t\t \"# of the // port pin connected to LCD 'RS' signal, with polarity (-17..17)\");\n\nstatic int lcd_rw_pin = PIN_NOT_SET;\nmodule_param(lcd_rw_pin, int, 0000);\nMODULE_PARM_DESC(lcd_rw_pin,\n\t\t \"# of the // port pin connected to LCD 'RW' signal, with polarity (-17..17)\");\n\nstatic int lcd_cl_pin = PIN_NOT_SET;\nmodule_param(lcd_cl_pin, int, 0000);\nMODULE_PARM_DESC(lcd_cl_pin,\n\t\t \"# of the // port pin connected to serial LCD 'SCL' signal, with polarity (-17..17)\");\n\nstatic int lcd_da_pin = PIN_NOT_SET;\nmodule_param(lcd_da_pin, int, 0000);\nMODULE_PARM_DESC(lcd_da_pin,\n\t\t \"# of the // port pin connected to serial LCD 'SDA' signal, with polarity (-17..17)\");\n\nstatic int lcd_bl_pin = PIN_NOT_SET;\nmodule_param(lcd_bl_pin, int, 0000);\nMODULE_PARM_DESC(lcd_bl_pin,\n\t\t \"# of the // port pin connected to LCD backlight, with polarity (-17..17)\");\n\n \n\nstatic int lcd_enabled = NOT_SET;\nmodule_param(lcd_enabled, int, 0000);\nMODULE_PARM_DESC(lcd_enabled, \"Deprecated option, use lcd_type instead\");\n\nstatic int keypad_enabled = NOT_SET;\nmodule_param(keypad_enabled, int, 0000);\nMODULE_PARM_DESC(keypad_enabled, \"Deprecated option, use keypad_type instead\");\n\n \nstatic const unsigned char lcd_char_conv_ks0074[256] = {\n\t \n\t  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n\t  0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n\t  0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n\t  0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,\n\t  0x20, 0x21, 0x22, 0x23, 0xa2, 0x25, 0x26, 0x27,\n\t  0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,\n\t  0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,\n\t  0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,\n\t  0xa0, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,\n\t  0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,\n\t  0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,\n\t  0x58, 0x59, 0x5a, 0xfa, 0xfb, 0xfc, 0x1d, 0xc4,\n\t  0x96, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,\n\t  0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,\n\t  0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,\n\t  0x78, 0x79, 0x7a, 0xfd, 0xfe, 0xff, 0xce, 0x20,\n\t  0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,\n\t  0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f,\n\t  0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97,\n\t  0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f,\n\t  0x20, 0x40, 0xb1, 0xa1, 0x24, 0xa3, 0xfe, 0x5f,\n\t  0x22, 0xc8, 0x61, 0x14, 0x97, 0x2d, 0xad, 0x96,\n\t  0x80, 0x8c, 0x82, 0x83, 0x27, 0x8f, 0x86, 0xdd,\n\t  0x2c, 0x81, 0x6f, 0x15, 0x8b, 0x8a, 0x84, 0x60,\n\t  0xe2, 0xe2, 0xe2, 0x5b, 0x5b, 0xae, 0xbc, 0xa9,\n\t  0xc5, 0xbf, 0xc6, 0xf1, 0xe3, 0xe3, 0xe3, 0xe3,\n\t  0x44, 0x5d, 0xa8, 0xe4, 0xec, 0xec, 0x5c, 0x78,\n\t  0xab, 0xa6, 0xe5, 0x5e, 0x5e, 0xe6, 0xaa, 0xbe,\n\t  0x7f, 0xe7, 0xaf, 0x7b, 0x7b, 0xaf, 0xbd, 0xc8,\n\t  0xa4, 0xa5, 0xc7, 0xf6, 0xa7, 0xe8, 0x69, 0x69,\n\t  0xed, 0x7d, 0xa8, 0xe4, 0xec, 0x5c, 0x5c, 0x25,\n\t  0xac, 0xa6, 0xea, 0xef, 0x7e, 0xeb, 0xb2, 0x79,\n};\n\nstatic const char old_keypad_profile[][4][9] = {\n\t{\"S0\", \"Left\\n\", \"Left\\n\", \"\"},\n\t{\"S1\", \"Down\\n\", \"Down\\n\", \"\"},\n\t{\"S2\", \"Up\\n\", \"Up\\n\", \"\"},\n\t{\"S3\", \"Right\\n\", \"Right\\n\", \"\"},\n\t{\"S4\", \"Esc\\n\", \"Esc\\n\", \"\"},\n\t{\"S5\", \"Ret\\n\", \"Ret\\n\", \"\"},\n\t{\"\", \"\", \"\", \"\"}\n};\n\n \nstatic const char new_keypad_profile[][4][9] = {\n\t{\"S0\", \"Left\\n\", \"Left\\n\", \"\"},\n\t{\"S1\", \"Down\\n\", \"Down\\n\", \"\"},\n\t{\"S2\", \"Up\\n\", \"Up\\n\", \"\"},\n\t{\"S3\", \"Right\\n\", \"Right\\n\", \"\"},\n\t{\"S4s5\", \"\", \"Esc\\n\", \"Esc\\n\"},\n\t{\"s4S5\", \"\", \"Ret\\n\", \"Ret\\n\"},\n\t{\"S4S5\", \"Help\\n\", \"\", \"\"},\n\t \n\t{\"\", \"\", \"\", \"\"}\n};\n\n \nstatic const char nexcom_keypad_profile[][4][9] = {\n\t{\"a-p-e-\", \"Down\\n\", \"Down\\n\", \"\"},\n\t{\"a-p-E-\", \"Ret\\n\", \"Ret\\n\", \"\"},\n\t{\"a-P-E-\", \"Esc\\n\", \"Esc\\n\", \"\"},\n\t{\"a-P-e-\", \"Up\\n\", \"Up\\n\", \"\"},\n\t \n\t{\"\", \"\", \"\", \"\"}\n};\n\nstatic const char (*keypad_profile)[4][9] = old_keypad_profile;\n\nstatic DECLARE_BITMAP(bits, LCD_BITS);\n\nstatic void lcd_get_bits(unsigned int port, int *val)\n{\n\tunsigned int bit, state;\n\n\tfor (bit = 0; bit < LCD_BITS; bit++) {\n\t\tstate = test_bit(bit, bits) ? BIT_SET : BIT_CLR;\n\t\t*val &= lcd_bits[port][bit][BIT_MSK];\n\t\t*val |= lcd_bits[port][bit][state];\n\t}\n}\n\n \nstatic int set_data_bits(void)\n{\n\tint val;\n\n\tval = r_dtr(pprt);\n\tlcd_get_bits(LCD_PORT_D, &val);\n\tw_dtr(pprt, val);\n\treturn val;\n}\n\n \nstatic int set_ctrl_bits(void)\n{\n\tint val;\n\n\tval = r_ctr(pprt);\n\tlcd_get_bits(LCD_PORT_C, &val);\n\tw_ctr(pprt, val);\n\treturn val;\n}\n\n \nstatic void panel_set_bits(void)\n{\n\tset_data_bits();\n\tset_ctrl_bits();\n}\n\n \nstatic void pin_to_bits(int pin, unsigned char *d_val, unsigned char *c_val)\n{\n\tint d_bit, c_bit, inv;\n\n\td_val[0] = 0;\n\tc_val[0] = 0;\n\td_val[1] = 0;\n\tc_val[1] = 0;\n\td_val[2] = 0xFF;\n\tc_val[2] = 0xFF;\n\n\tif (pin == 0)\n\t\treturn;\n\n\tinv = (pin < 0);\n\tif (inv)\n\t\tpin = -pin;\n\n\td_bit = 0;\n\tc_bit = 0;\n\n\tswitch (pin) {\n\tcase PIN_STROBE:\t \n\t\tc_bit = PNL_PSTROBE;\n\t\tinv = !inv;\n\t\tbreak;\n\tcase PIN_D0...PIN_D7:\t \n\t\td_bit = 1 << (pin - 2);\n\t\tbreak;\n\tcase PIN_AUTOLF:\t \n\t\tc_bit = PNL_PAUTOLF;\n\t\tinv = !inv;\n\t\tbreak;\n\tcase PIN_INITP:\t\t \n\t\tc_bit = PNL_PINITP;\n\t\tbreak;\n\tcase PIN_SELECP:\t \n\t\tc_bit = PNL_PSELECP;\n\t\tinv = !inv;\n\t\tbreak;\n\tdefault:\t\t \n\t\tbreak;\n\t}\n\n\tif (c_bit) {\n\t\tc_val[2] &= ~c_bit;\n\t\tc_val[!inv] = c_bit;\n\t} else if (d_bit) {\n\t\td_val[2] &= ~d_bit;\n\t\td_val[!inv] = d_bit;\n\t}\n}\n\n \nstatic void lcd_send_serial(int byte)\n{\n\tint bit;\n\n\t \n\tfor (bit = 0; bit < 8; bit++) {\n\t\tclear_bit(LCD_BIT_CL, bits);\t \n\t\tpanel_set_bits();\n\t\tif (byte & 1) {\n\t\t\tset_bit(LCD_BIT_DA, bits);\n\t\t} else {\n\t\t\tclear_bit(LCD_BIT_DA, bits);\n\t\t}\n\n\t\tpanel_set_bits();\n\t\tudelay(2);   \n\t\tset_bit(LCD_BIT_CL, bits);\t \n\t\tpanel_set_bits();\n\t\tudelay(1);   \n\t\tbyte >>= 1;\n\t}\n}\n\n \nstatic void lcd_backlight(struct charlcd *charlcd, enum charlcd_onoff on)\n{\n\tif (lcd.pins.bl == PIN_NONE)\n\t\treturn;\n\n\t \n\tspin_lock_irq(&pprt_lock);\n\tif (on)\n\t\tset_bit(LCD_BIT_BL, bits);\n\telse\n\t\tclear_bit(LCD_BIT_BL, bits);\n\tpanel_set_bits();\n\tspin_unlock_irq(&pprt_lock);\n}\n\n \nstatic void lcd_write_cmd_s(struct hd44780_common *hdc, int cmd)\n{\n\tspin_lock_irq(&pprt_lock);\n\tlcd_send_serial(0x1F);\t \n\tlcd_send_serial(cmd & 0x0F);\n\tlcd_send_serial((cmd >> 4) & 0x0F);\n\tudelay(40);\t\t \n\tspin_unlock_irq(&pprt_lock);\n}\n\n \nstatic void lcd_write_data_s(struct hd44780_common *hdc, int data)\n{\n\tspin_lock_irq(&pprt_lock);\n\tlcd_send_serial(0x5F);\t \n\tlcd_send_serial(data & 0x0F);\n\tlcd_send_serial((data >> 4) & 0x0F);\n\tudelay(40);\t\t \n\tspin_unlock_irq(&pprt_lock);\n}\n\n \nstatic void lcd_write_cmd_p8(struct hd44780_common *hdc, int cmd)\n{\n\tspin_lock_irq(&pprt_lock);\n\t \n\tw_dtr(pprt, cmd);\n\tudelay(20);\t \n\n\tset_bit(LCD_BIT_E, bits);\n\tclear_bit(LCD_BIT_RS, bits);\n\tclear_bit(LCD_BIT_RW, bits);\n\tset_ctrl_bits();\n\n\tudelay(40);\t \n\n\tclear_bit(LCD_BIT_E, bits);\n\tset_ctrl_bits();\n\n\tudelay(120);\t \n\tspin_unlock_irq(&pprt_lock);\n}\n\n \nstatic void lcd_write_data_p8(struct hd44780_common *hdc, int data)\n{\n\tspin_lock_irq(&pprt_lock);\n\t \n\tw_dtr(pprt, data);\n\tudelay(20);\t \n\n\tset_bit(LCD_BIT_E, bits);\n\tset_bit(LCD_BIT_RS, bits);\n\tclear_bit(LCD_BIT_RW, bits);\n\tset_ctrl_bits();\n\n\tudelay(40);\t \n\n\tclear_bit(LCD_BIT_E, bits);\n\tset_ctrl_bits();\n\n\tudelay(45);\t \n\tspin_unlock_irq(&pprt_lock);\n}\n\n \nstatic void lcd_write_cmd_tilcd(struct hd44780_common *hdc, int cmd)\n{\n\tspin_lock_irq(&pprt_lock);\n\t \n\tw_ctr(pprt, cmd);\n\tudelay(60);\n\tspin_unlock_irq(&pprt_lock);\n}\n\n \nstatic void lcd_write_data_tilcd(struct hd44780_common *hdc, int data)\n{\n\tspin_lock_irq(&pprt_lock);\n\t \n\tw_dtr(pprt, data);\n\tudelay(60);\n\tspin_unlock_irq(&pprt_lock);\n}\n\nstatic const struct charlcd_ops charlcd_ops = {\n\t.backlight\t= lcd_backlight,\n\t.print\t\t= hd44780_common_print,\n\t.gotoxy\t\t= hd44780_common_gotoxy,\n\t.home\t\t= hd44780_common_home,\n\t.clear_display\t= hd44780_common_clear_display,\n\t.init_display\t= hd44780_common_init_display,\n\t.shift_cursor\t= hd44780_common_shift_cursor,\n\t.shift_display\t= hd44780_common_shift_display,\n\t.display\t= hd44780_common_display,\n\t.cursor\t\t= hd44780_common_cursor,\n\t.blink\t\t= hd44780_common_blink,\n\t.fontsize\t= hd44780_common_fontsize,\n\t.lines\t\t= hd44780_common_lines,\n\t.redefine_char\t= hd44780_common_redefine_char,\n};\n\n \nstatic void lcd_init(void)\n{\n\tstruct charlcd *charlcd;\n\tstruct hd44780_common *hdc;\n\n\thdc = hd44780_common_alloc();\n\tif (!hdc)\n\t\treturn;\n\n\tcharlcd = charlcd_alloc();\n\tif (!charlcd) {\n\t\tkfree(hdc);\n\t\treturn;\n\t}\n\n\thdc->hd44780 = &lcd;\n\tcharlcd->drvdata = hdc;\n\n\t \n\tcharlcd->height = lcd_height;\n\tcharlcd->width = lcd_width;\n\thdc->bwidth = lcd_bwidth;\n\thdc->hwidth = lcd_hwidth;\n\n\tswitch (selected_lcd_type) {\n\tcase LCD_TYPE_OLD:\n\t\t \n\t\tlcd.proto = LCD_PROTO_PARALLEL;\n\t\tlcd.charset = LCD_CHARSET_NORMAL;\n\t\tlcd.pins.e = PIN_STROBE;\n\t\tlcd.pins.rs = PIN_AUTOLF;\n\n\t\tcharlcd->width = 40;\n\t\thdc->bwidth = 40;\n\t\thdc->hwidth = 64;\n\t\tcharlcd->height = 2;\n\t\tbreak;\n\tcase LCD_TYPE_KS0074:\n\t\t \n\t\tlcd.proto = LCD_PROTO_SERIAL;\n\t\tlcd.charset = LCD_CHARSET_KS0074;\n\t\tlcd.pins.bl = PIN_AUTOLF;\n\t\tlcd.pins.cl = PIN_STROBE;\n\t\tlcd.pins.da = PIN_D0;\n\n\t\tcharlcd->width = 16;\n\t\thdc->bwidth = 40;\n\t\thdc->hwidth = 16;\n\t\tcharlcd->height = 2;\n\t\tbreak;\n\tcase LCD_TYPE_NEXCOM:\n\t\t \n\t\tlcd.proto = LCD_PROTO_PARALLEL;\n\t\tlcd.charset = LCD_CHARSET_NORMAL;\n\t\tlcd.pins.e = PIN_AUTOLF;\n\t\tlcd.pins.rs = PIN_SELECP;\n\t\tlcd.pins.rw = PIN_INITP;\n\n\t\tcharlcd->width = 16;\n\t\thdc->bwidth = 40;\n\t\thdc->hwidth = 64;\n\t\tcharlcd->height = 2;\n\t\tbreak;\n\tcase LCD_TYPE_CUSTOM:\n\t\t \n\t\tlcd.proto = DEFAULT_LCD_PROTO;\n\t\tlcd.charset = DEFAULT_LCD_CHARSET;\n\t\t \n\t\tbreak;\n\tcase LCD_TYPE_HANTRONIX:\n\t\t \n\tdefault:\n\t\tlcd.proto = LCD_PROTO_PARALLEL;\n\t\tlcd.charset = LCD_CHARSET_NORMAL;\n\t\tlcd.pins.e = PIN_STROBE;\n\t\tlcd.pins.rs = PIN_SELECP;\n\n\t\tcharlcd->width = 16;\n\t\thdc->bwidth = 40;\n\t\thdc->hwidth = 64;\n\t\tcharlcd->height = 2;\n\t\tbreak;\n\t}\n\n\t \n\tif (lcd_height != NOT_SET)\n\t\tcharlcd->height = lcd_height;\n\tif (lcd_width != NOT_SET)\n\t\tcharlcd->width = lcd_width;\n\tif (lcd_bwidth != NOT_SET)\n\t\thdc->bwidth = lcd_bwidth;\n\tif (lcd_hwidth != NOT_SET)\n\t\thdc->hwidth = lcd_hwidth;\n\tif (lcd_charset != NOT_SET)\n\t\tlcd.charset = lcd_charset;\n\tif (lcd_proto != NOT_SET)\n\t\tlcd.proto = lcd_proto;\n\tif (lcd_e_pin != PIN_NOT_SET)\n\t\tlcd.pins.e = lcd_e_pin;\n\tif (lcd_rs_pin != PIN_NOT_SET)\n\t\tlcd.pins.rs = lcd_rs_pin;\n\tif (lcd_rw_pin != PIN_NOT_SET)\n\t\tlcd.pins.rw = lcd_rw_pin;\n\tif (lcd_cl_pin != PIN_NOT_SET)\n\t\tlcd.pins.cl = lcd_cl_pin;\n\tif (lcd_da_pin != PIN_NOT_SET)\n\t\tlcd.pins.da = lcd_da_pin;\n\tif (lcd_bl_pin != PIN_NOT_SET)\n\t\tlcd.pins.bl = lcd_bl_pin;\n\n\t \n\tif (charlcd->width <= 0)\n\t\tcharlcd->width = DEFAULT_LCD_WIDTH;\n\tif (hdc->bwidth <= 0)\n\t\thdc->bwidth = DEFAULT_LCD_BWIDTH;\n\tif (hdc->hwidth <= 0)\n\t\thdc->hwidth = DEFAULT_LCD_HWIDTH;\n\tif (charlcd->height <= 0)\n\t\tcharlcd->height = DEFAULT_LCD_HEIGHT;\n\n\tif (lcd.proto == LCD_PROTO_SERIAL) {\t \n\t\tcharlcd->ops = &charlcd_ops;\n\t\thdc->write_data = lcd_write_data_s;\n\t\thdc->write_cmd = lcd_write_cmd_s;\n\n\t\tif (lcd.pins.cl == PIN_NOT_SET)\n\t\t\tlcd.pins.cl = DEFAULT_LCD_PIN_SCL;\n\t\tif (lcd.pins.da == PIN_NOT_SET)\n\t\t\tlcd.pins.da = DEFAULT_LCD_PIN_SDA;\n\n\t} else if (lcd.proto == LCD_PROTO_PARALLEL) {\t \n\t\tcharlcd->ops = &charlcd_ops;\n\t\thdc->write_data = lcd_write_data_p8;\n\t\thdc->write_cmd = lcd_write_cmd_p8;\n\n\t\tif (lcd.pins.e == PIN_NOT_SET)\n\t\t\tlcd.pins.e = DEFAULT_LCD_PIN_E;\n\t\tif (lcd.pins.rs == PIN_NOT_SET)\n\t\t\tlcd.pins.rs = DEFAULT_LCD_PIN_RS;\n\t\tif (lcd.pins.rw == PIN_NOT_SET)\n\t\t\tlcd.pins.rw = DEFAULT_LCD_PIN_RW;\n\t} else {\n\t\tcharlcd->ops = &charlcd_ops;\n\t\thdc->write_data = lcd_write_data_tilcd;\n\t\thdc->write_cmd = lcd_write_cmd_tilcd;\n\t}\n\n\tif (lcd.pins.bl == PIN_NOT_SET)\n\t\tlcd.pins.bl = DEFAULT_LCD_PIN_BL;\n\n\tif (lcd.pins.e == PIN_NOT_SET)\n\t\tlcd.pins.e = PIN_NONE;\n\tif (lcd.pins.rs == PIN_NOT_SET)\n\t\tlcd.pins.rs = PIN_NONE;\n\tif (lcd.pins.rw == PIN_NOT_SET)\n\t\tlcd.pins.rw = PIN_NONE;\n\tif (lcd.pins.bl == PIN_NOT_SET)\n\t\tlcd.pins.bl = PIN_NONE;\n\tif (lcd.pins.cl == PIN_NOT_SET)\n\t\tlcd.pins.cl = PIN_NONE;\n\tif (lcd.pins.da == PIN_NOT_SET)\n\t\tlcd.pins.da = PIN_NONE;\n\n\tif (lcd.charset == NOT_SET)\n\t\tlcd.charset = DEFAULT_LCD_CHARSET;\n\n\tif (lcd.charset == LCD_CHARSET_KS0074)\n\t\tcharlcd->char_conv = lcd_char_conv_ks0074;\n\telse\n\t\tcharlcd->char_conv = NULL;\n\n\tpin_to_bits(lcd.pins.e, lcd_bits[LCD_PORT_D][LCD_BIT_E],\n\t\t    lcd_bits[LCD_PORT_C][LCD_BIT_E]);\n\tpin_to_bits(lcd.pins.rs, lcd_bits[LCD_PORT_D][LCD_BIT_RS],\n\t\t    lcd_bits[LCD_PORT_C][LCD_BIT_RS]);\n\tpin_to_bits(lcd.pins.rw, lcd_bits[LCD_PORT_D][LCD_BIT_RW],\n\t\t    lcd_bits[LCD_PORT_C][LCD_BIT_RW]);\n\tpin_to_bits(lcd.pins.bl, lcd_bits[LCD_PORT_D][LCD_BIT_BL],\n\t\t    lcd_bits[LCD_PORT_C][LCD_BIT_BL]);\n\tpin_to_bits(lcd.pins.cl, lcd_bits[LCD_PORT_D][LCD_BIT_CL],\n\t\t    lcd_bits[LCD_PORT_C][LCD_BIT_CL]);\n\tpin_to_bits(lcd.pins.da, lcd_bits[LCD_PORT_D][LCD_BIT_DA],\n\t\t    lcd_bits[LCD_PORT_C][LCD_BIT_DA]);\n\n\tlcd.charlcd = charlcd;\n\tlcd.initialized = true;\n}\n\n \n\nstatic ssize_t keypad_read(struct file *file,\n\t\t\t   char __user *buf, size_t count, loff_t *ppos)\n{\n\tunsigned i = *ppos;\n\tchar __user *tmp = buf;\n\n\tif (keypad_buflen == 0) {\n\t\tif (file->f_flags & O_NONBLOCK)\n\t\t\treturn -EAGAIN;\n\n\t\tif (wait_event_interruptible(keypad_read_wait,\n\t\t\t\t\t     keypad_buflen != 0))\n\t\t\treturn -EINTR;\n\t}\n\n\tfor (; count-- > 0 && (keypad_buflen > 0);\n\t     ++i, ++tmp, --keypad_buflen) {\n\t\tput_user(keypad_buffer[keypad_start], tmp);\n\t\tkeypad_start = (keypad_start + 1) % KEYPAD_BUFFER;\n\t}\n\t*ppos = i;\n\n\treturn tmp - buf;\n}\n\nstatic int keypad_open(struct inode *inode, struct file *file)\n{\n\tint ret;\n\n\tret = -EBUSY;\n\tif (!atomic_dec_and_test(&keypad_available))\n\t\tgoto fail;\t \n\n\tret = -EPERM;\n\tif (file->f_mode & FMODE_WRITE)\t \n\t\tgoto fail;\n\n\tkeypad_buflen = 0;\t \n\treturn 0;\n fail:\n\tatomic_inc(&keypad_available);\n\treturn ret;\n}\n\nstatic int keypad_release(struct inode *inode, struct file *file)\n{\n\tatomic_inc(&keypad_available);\n\treturn 0;\n}\n\nstatic const struct file_operations keypad_fops = {\n\t.read    = keypad_read,\t\t \n\t.open    = keypad_open,\t\t \n\t.release = keypad_release,\t \n\t.llseek  = default_llseek,\n};\n\nstatic struct miscdevice keypad_dev = {\n\t.minor\t= KEYPAD_MINOR,\n\t.name\t= \"keypad\",\n\t.fops\t= &keypad_fops,\n};\n\nstatic void keypad_send_key(const char *string, int max_len)\n{\n\t \n\tif (!atomic_read(&keypad_available)) {\n\t\twhile (max_len-- && keypad_buflen < KEYPAD_BUFFER && *string) {\n\t\t\tkeypad_buffer[(keypad_start + keypad_buflen++) %\n\t\t\t\t      KEYPAD_BUFFER] = *string++;\n\t\t}\n\t\twake_up_interruptible(&keypad_read_wait);\n\t}\n}\n\n \nstatic void phys_scan_contacts(void)\n{\n\tint bit, bitval;\n\tchar oldval;\n\tchar bitmask;\n\tchar gndmask;\n\n\tphys_prev = phys_curr;\n\tphys_read_prev = phys_read;\n\tphys_read = 0;\t\t \n\n\t \n\toldval = r_dtr(pprt) | scan_mask_o;\n\t \n\tw_dtr(pprt, oldval & ~scan_mask_o);\n\n\t \n\tbitmask = PNL_PINPUT(r_str(pprt)) & scan_mask_i;\n\t \n\tw_dtr(pprt, oldval);\n\n\t \n\n\t \n\tgndmask = PNL_PINPUT(r_str(pprt)) & scan_mask_i;\n\n\t \n\tphys_read |= (__u64)gndmask << 40;\n\n\tif (bitmask != gndmask) {\n\t\t \n\t\tfor (bit = 0; bit < 8; bit++) {\n\t\t\tbitval = BIT(bit);\n\n\t\t\tif (!(scan_mask_o & bitval))\t \n\t\t\t\tcontinue;\n\n\t\t\tw_dtr(pprt, oldval & ~bitval);\t \n\t\t\tbitmask = PNL_PINPUT(r_str(pprt)) & ~gndmask;\n\t\t\tphys_read |= (__u64)bitmask << (5 * bit);\n\t\t}\n\t\tw_dtr(pprt, oldval);\t \n\t}\n\t \n\tphys_curr = (phys_prev & (phys_read ^ phys_read_prev)) |\n\t\t    (phys_read & ~(phys_read ^ phys_read_prev));\n}\n\nstatic inline int input_state_high(struct logical_input *input)\n{\n#if 0\n\t \n\n\t \n\tif (((phys_prev & input->mask) == input->value) &&\n\t    ((phys_curr & input->mask) >  input->value)) {\n\t\tinput->state = INPUT_ST_LOW;  \n\t\treturn 1;\n\t}\n#endif\n\n\tif ((phys_curr & input->mask) == input->value) {\n\t\tif ((input->type == INPUT_TYPE_STD) &&\n\t\t    (input->high_timer == 0)) {\n\t\t\tinput->high_timer++;\n\t\t\tif (input->u.std.press_fct)\n\t\t\t\tinput->u.std.press_fct(input->u.std.press_data);\n\t\t} else if (input->type == INPUT_TYPE_KBD) {\n\t\t\t \n\t\t\tkeypressed = 1;\n\n\t\t\tif (input->high_timer == 0) {\n\t\t\t\tchar *press_str = input->u.kbd.press_str;\n\n\t\t\t\tif (press_str[0]) {\n\t\t\t\t\tint s = sizeof(input->u.kbd.press_str);\n\n\t\t\t\t\tkeypad_send_key(press_str, s);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (input->u.kbd.repeat_str[0]) {\n\t\t\t\tchar *repeat_str = input->u.kbd.repeat_str;\n\n\t\t\t\tif (input->high_timer >= KEYPAD_REP_START) {\n\t\t\t\t\tint s = sizeof(input->u.kbd.repeat_str);\n\n\t\t\t\t\tinput->high_timer -= KEYPAD_REP_DELAY;\n\t\t\t\t\tkeypad_send_key(repeat_str, s);\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\tinputs_stable = 0;\n\t\t\t}\n\n\t\t\tif (input->high_timer < 255)\n\t\t\t\tinput->high_timer++;\n\t\t}\n\t\treturn 1;\n\t}\n\n\t \n\tinput->state = INPUT_ST_FALLING;\n\tinput->fall_timer = 0;\n\n\treturn 0;\n}\n\nstatic inline void input_state_falling(struct logical_input *input)\n{\n#if 0\n\t \n\tif (((phys_prev & input->mask) == input->value) &&\n\t    ((phys_curr & input->mask) >  input->value)) {\n\t\tinput->state = INPUT_ST_LOW;\t \n\t\treturn;\n\t}\n#endif\n\n\tif ((phys_curr & input->mask) == input->value) {\n\t\tif (input->type == INPUT_TYPE_KBD) {\n\t\t\t \n\t\t\tkeypressed = 1;\n\n\t\t\tif (input->u.kbd.repeat_str[0]) {\n\t\t\t\tchar *repeat_str = input->u.kbd.repeat_str;\n\n\t\t\t\tif (input->high_timer >= KEYPAD_REP_START) {\n\t\t\t\t\tint s = sizeof(input->u.kbd.repeat_str);\n\n\t\t\t\t\tinput->high_timer -= KEYPAD_REP_DELAY;\n\t\t\t\t\tkeypad_send_key(repeat_str, s);\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\tinputs_stable = 0;\n\t\t\t}\n\n\t\t\tif (input->high_timer < 255)\n\t\t\t\tinput->high_timer++;\n\t\t}\n\t\tinput->state = INPUT_ST_HIGH;\n\t} else if (input->fall_timer >= input->fall_time) {\n\t\t \n\t\tif (input->type == INPUT_TYPE_STD) {\n\t\t\tvoid (*release_fct)(int) = input->u.std.release_fct;\n\n\t\t\tif (release_fct)\n\t\t\t\trelease_fct(input->u.std.release_data);\n\t\t} else if (input->type == INPUT_TYPE_KBD) {\n\t\t\tchar *release_str = input->u.kbd.release_str;\n\n\t\t\tif (release_str[0]) {\n\t\t\t\tint s = sizeof(input->u.kbd.release_str);\n\n\t\t\t\tkeypad_send_key(release_str, s);\n\t\t\t}\n\t\t}\n\n\t\tinput->state = INPUT_ST_LOW;\n\t} else {\n\t\tinput->fall_timer++;\n\t\tinputs_stable = 0;\n\t}\n}\n\nstatic void panel_process_inputs(void)\n{\n\tstruct logical_input *input;\n\n\tkeypressed = 0;\n\tinputs_stable = 1;\n\tlist_for_each_entry(input, &logical_inputs, list) {\n\t\tswitch (input->state) {\n\t\tcase INPUT_ST_LOW:\n\t\t\tif ((phys_curr & input->mask) != input->value)\n\t\t\t\tbreak;\n\t\t\t \n\t\t\tif ((phys_prev & input->mask) == input->value)\n\t\t\t\tbreak;\n\t\t\tinput->rise_timer = 0;\n\t\t\tinput->state = INPUT_ST_RISING;\n\t\t\tfallthrough;\n\t\tcase INPUT_ST_RISING:\n\t\t\tif ((phys_curr & input->mask) != input->value) {\n\t\t\t\tinput->state = INPUT_ST_LOW;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (input->rise_timer < input->rise_time) {\n\t\t\t\tinputs_stable = 0;\n\t\t\t\tinput->rise_timer++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tinput->high_timer = 0;\n\t\t\tinput->state = INPUT_ST_HIGH;\n\t\t\tfallthrough;\n\t\tcase INPUT_ST_HIGH:\n\t\t\tif (input_state_high(input))\n\t\t\t\tbreak;\n\t\t\tfallthrough;\n\t\tcase INPUT_ST_FALLING:\n\t\t\tinput_state_falling(input);\n\t\t}\n\t}\n}\n\nstatic void panel_scan_timer(struct timer_list *unused)\n{\n\tif (keypad.enabled && keypad_initialized) {\n\t\tif (spin_trylock_irq(&pprt_lock)) {\n\t\t\tphys_scan_contacts();\n\n\t\t\t \n\t\t\tspin_unlock_irq(&pprt_lock);\n\t\t}\n\n\t\tif (!inputs_stable || phys_curr != phys_prev)\n\t\t\tpanel_process_inputs();\n\t}\n\n\tif (keypressed && lcd.enabled && lcd.initialized)\n\t\tcharlcd_poke(lcd.charlcd);\n\n\tmod_timer(&scan_timer, jiffies + INPUT_POLL_TIME);\n}\n\nstatic void init_scan_timer(void)\n{\n\tif (scan_timer.function)\n\t\treturn;\t\t \n\n\ttimer_setup(&scan_timer, panel_scan_timer, 0);\n\tscan_timer.expires = jiffies + INPUT_POLL_TIME;\n\tadd_timer(&scan_timer);\n}\n\n \nstatic u8 input_name2mask(const char *name, __u64 *mask, __u64 *value,\n\t\t\t  u8 *imask, u8 *omask)\n{\n\tconst char sigtab[] = \"EeSsPpAaBb\";\n\tu8 im, om;\n\t__u64 m, v;\n\n\tom = 0;\n\tim = 0;\n\tm = 0ULL;\n\tv = 0ULL;\n\twhile (*name) {\n\t\tint in, out, bit, neg;\n\t\tconst char *idx;\n\n\t\tidx = strchr(sigtab, *name);\n\t\tif (!idx)\n\t\t\treturn 0;\t \n\n\t\tin = idx - sigtab;\n\t\tneg = (in & 1);\t \n\t\tin >>= 1;\n\t\tim |= BIT(in);\n\n\t\tname++;\n\t\tif (*name >= '0' && *name <= '7') {\n\t\t\tout = *name - '0';\n\t\t\tom |= BIT(out);\n\t\t} else if (*name == '-') {\n\t\t\tout = 8;\n\t\t} else {\n\t\t\treturn 0;\t \n\t\t}\n\n\t\tbit = (out * 5) + in;\n\n\t\tm |= 1ULL << bit;\n\t\tif (!neg)\n\t\t\tv |= 1ULL << bit;\n\t\tname++;\n\t}\n\t*mask = m;\n\t*value = v;\n\tif (imask)\n\t\t*imask |= im;\n\tif (omask)\n\t\t*omask |= om;\n\treturn 1;\n}\n\n \nstatic struct logical_input *panel_bind_key(const char *name, const char *press,\n\t\t\t\t\t    const char *repeat,\n\t\t\t\t\t    const char *release)\n{\n\tstruct logical_input *key;\n\n\tkey = kzalloc(sizeof(*key), GFP_KERNEL);\n\tif (!key)\n\t\treturn NULL;\n\n\tif (!input_name2mask(name, &key->mask, &key->value, &scan_mask_i,\n\t\t\t     &scan_mask_o)) {\n\t\tkfree(key);\n\t\treturn NULL;\n\t}\n\n\tkey->type = INPUT_TYPE_KBD;\n\tkey->state = INPUT_ST_LOW;\n\tkey->rise_time = 1;\n\tkey->fall_time = 1;\n\n\tstrncpy(key->u.kbd.press_str, press, sizeof(key->u.kbd.press_str));\n\tstrncpy(key->u.kbd.repeat_str, repeat, sizeof(key->u.kbd.repeat_str));\n\tstrncpy(key->u.kbd.release_str, release,\n\t\tsizeof(key->u.kbd.release_str));\n\tlist_add(&key->list, &logical_inputs);\n\treturn key;\n}\n\n#if 0\n \nstatic struct logical_input *panel_bind_callback(char *name,\n\t\t\t\t\t\t void (*press_fct)(int),\n\t\t\t\t\t\t int press_data,\n\t\t\t\t\t\t void (*release_fct)(int),\n\t\t\t\t\t\t int release_data)\n{\n\tstruct logical_input *callback;\n\n\tcallback = kmalloc(sizeof(*callback), GFP_KERNEL);\n\tif (!callback)\n\t\treturn NULL;\n\n\tmemset(callback, 0, sizeof(struct logical_input));\n\tif (!input_name2mask(name, &callback->mask, &callback->value,\n\t\t\t     &scan_mask_i, &scan_mask_o))\n\t\treturn NULL;\n\n\tcallback->type = INPUT_TYPE_STD;\n\tcallback->state = INPUT_ST_LOW;\n\tcallback->rise_time = 1;\n\tcallback->fall_time = 1;\n\tcallback->u.std.press_fct = press_fct;\n\tcallback->u.std.press_data = press_data;\n\tcallback->u.std.release_fct = release_fct;\n\tcallback->u.std.release_data = release_data;\n\tlist_add(&callback->list, &logical_inputs);\n\treturn callback;\n}\n#endif\n\nstatic void keypad_init(void)\n{\n\tint keynum;\n\n\tinit_waitqueue_head(&keypad_read_wait);\n\tkeypad_buflen = 0;\t \n\n\t \n\n\tfor (keynum = 0; keypad_profile[keynum][0][0]; keynum++) {\n\t\tpanel_bind_key(keypad_profile[keynum][0],\n\t\t\t       keypad_profile[keynum][1],\n\t\t\t       keypad_profile[keynum][2],\n\t\t\t       keypad_profile[keynum][3]);\n\t}\n\n\tinit_scan_timer();\n\tkeypad_initialized = 1;\n}\n\n \n \n \n\nstatic void panel_attach(struct parport *port)\n{\n\tstruct pardev_cb panel_cb;\n\n\tif (port->number != parport)\n\t\treturn;\n\n\tif (pprt) {\n\t\tpr_err(\"%s: port->number=%d parport=%d, already registered!\\n\",\n\t\t       __func__, port->number, parport);\n\t\treturn;\n\t}\n\n\tmemset(&panel_cb, 0, sizeof(panel_cb));\n\tpanel_cb.private = &pprt;\n\t \n\n\tpprt = parport_register_dev_model(port, \"panel\", &panel_cb, 0);\n\tif (!pprt) {\n\t\tpr_err(\"%s: port->number=%d parport=%d, parport_register_device() failed\\n\",\n\t\t       __func__, port->number, parport);\n\t\treturn;\n\t}\n\n\tif (parport_claim(pprt)) {\n\t\tpr_err(\"could not claim access to parport%d. Aborting.\\n\",\n\t\t       parport);\n\t\tgoto err_unreg_device;\n\t}\n\n\t \n\tif (lcd.enabled) {\n\t\tlcd_init();\n\t\tif (!lcd.charlcd || charlcd_register(lcd.charlcd))\n\t\t\tgoto err_unreg_device;\n\t}\n\n\tif (keypad.enabled) {\n\t\tkeypad_init();\n\t\tif (misc_register(&keypad_dev))\n\t\t\tgoto err_lcd_unreg;\n\t}\n\treturn;\n\nerr_lcd_unreg:\n\tif (scan_timer.function)\n\t\tdel_timer_sync(&scan_timer);\n\tif (lcd.enabled)\n\t\tcharlcd_unregister(lcd.charlcd);\nerr_unreg_device:\n\tkfree(lcd.charlcd);\n\tlcd.charlcd = NULL;\n\tparport_unregister_device(pprt);\n\tpprt = NULL;\n}\n\nstatic void panel_detach(struct parport *port)\n{\n\tif (port->number != parport)\n\t\treturn;\n\n\tif (!pprt) {\n\t\tpr_err(\"%s: port->number=%d parport=%d, nothing to unregister.\\n\",\n\t\t       __func__, port->number, parport);\n\t\treturn;\n\t}\n\tif (scan_timer.function)\n\t\tdel_timer_sync(&scan_timer);\n\n\tif (keypad.enabled) {\n\t\tmisc_deregister(&keypad_dev);\n\t\tkeypad_initialized = 0;\n\t}\n\n\tif (lcd.enabled) {\n\t\tcharlcd_unregister(lcd.charlcd);\n\t\tlcd.initialized = false;\n\t\tkfree(lcd.charlcd->drvdata);\n\t\tkfree(lcd.charlcd);\n\t\tlcd.charlcd = NULL;\n\t}\n\n\t \n\tparport_release(pprt);\n\tparport_unregister_device(pprt);\n\tpprt = NULL;\n}\n\nstatic struct parport_driver panel_driver = {\n\t.name = \"panel\",\n\t.match_port = panel_attach,\n\t.detach = panel_detach,\n\t.devmodel = true,\n};\n\n \nstatic int __init panel_init_module(void)\n{\n\tint selected_keypad_type = NOT_SET, err;\n\n\t \n\tswitch (profile) {\n\tcase PANEL_PROFILE_CUSTOM:\n\t\t \n\t\tselected_keypad_type = DEFAULT_KEYPAD_TYPE;\n\t\tselected_lcd_type = DEFAULT_LCD_TYPE;\n\t\tbreak;\n\tcase PANEL_PROFILE_OLD:\n\t\t \n\t\tselected_keypad_type = KEYPAD_TYPE_OLD;\n\t\tselected_lcd_type = LCD_TYPE_OLD;\n\n\t\t \n\t\tif (lcd_width == NOT_SET)\n\t\t\tlcd_width = 16;\n\t\tif (lcd_hwidth == NOT_SET)\n\t\t\tlcd_hwidth = 16;\n\t\tbreak;\n\tcase PANEL_PROFILE_NEW:\n\t\t \n\t\tselected_keypad_type = KEYPAD_TYPE_NEW;\n\t\tselected_lcd_type = LCD_TYPE_KS0074;\n\t\tbreak;\n\tcase PANEL_PROFILE_HANTRONIX:\n\t\t \n\t\tselected_keypad_type = KEYPAD_TYPE_NONE;\n\t\tselected_lcd_type = LCD_TYPE_HANTRONIX;\n\t\tbreak;\n\tcase PANEL_PROFILE_NEXCOM:\n\t\t \n\t\tselected_keypad_type = KEYPAD_TYPE_NEXCOM;\n\t\tselected_lcd_type = LCD_TYPE_NEXCOM;\n\t\tbreak;\n\tcase PANEL_PROFILE_LARGE:\n\t\t \n\t\tselected_keypad_type = KEYPAD_TYPE_OLD;\n\t\tselected_lcd_type = LCD_TYPE_OLD;\n\t\tbreak;\n\t}\n\n\t \n\tif (keypad_enabled != NOT_SET)\n\t\tselected_keypad_type = keypad_enabled;\n\tif (keypad_type != NOT_SET)\n\t\tselected_keypad_type = keypad_type;\n\n\tkeypad.enabled = (selected_keypad_type > 0);\n\n\tif (lcd_enabled != NOT_SET)\n\t\tselected_lcd_type = lcd_enabled;\n\tif (lcd_type != NOT_SET)\n\t\tselected_lcd_type = lcd_type;\n\n\tlcd.enabled = (selected_lcd_type > 0);\n\n\tif (lcd.enabled) {\n\t\t \n\t\tlcd.charset = lcd_charset;\n\t\tlcd.proto = lcd_proto;\n\t\tlcd.pins.e = lcd_e_pin;\n\t\tlcd.pins.rs = lcd_rs_pin;\n\t\tlcd.pins.rw = lcd_rw_pin;\n\t\tlcd.pins.cl = lcd_cl_pin;\n\t\tlcd.pins.da = lcd_da_pin;\n\t\tlcd.pins.bl = lcd_bl_pin;\n\t}\n\n\tswitch (selected_keypad_type) {\n\tcase KEYPAD_TYPE_OLD:\n\t\tkeypad_profile = old_keypad_profile;\n\t\tbreak;\n\tcase KEYPAD_TYPE_NEW:\n\t\tkeypad_profile = new_keypad_profile;\n\t\tbreak;\n\tcase KEYPAD_TYPE_NEXCOM:\n\t\tkeypad_profile = nexcom_keypad_profile;\n\t\tbreak;\n\tdefault:\n\t\tkeypad_profile = NULL;\n\t\tbreak;\n\t}\n\n\tif (!lcd.enabled && !keypad.enabled) {\n\t\t \n\t\tpr_err(\"panel driver disabled.\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\terr = parport_register_driver(&panel_driver);\n\tif (err) {\n\t\tpr_err(\"could not register with parport. Aborting.\\n\");\n\t\treturn err;\n\t}\n\n\tif (pprt)\n\t\tpr_info(\"panel driver registered on parport%d (io=0x%lx).\\n\",\n\t\t\tparport, pprt->port->base);\n\telse\n\t\tpr_info(\"panel driver not yet registered\\n\");\n\treturn 0;\n}\n\nstatic void __exit panel_cleanup_module(void)\n{\n\tparport_unregister_driver(&panel_driver);\n}\n\nmodule_init(panel_init_module);\nmodule_exit(panel_cleanup_module);\nMODULE_AUTHOR(\"Willy Tarreau\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}