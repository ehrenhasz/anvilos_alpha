{
  "module_name": "lcd2s.c",
  "hash_id": "c415f13e95afd640cf084bb565d9993f574d70c76f163daf0ecb14662d6e18b6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/auxdisplay/lcd2s.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/property.h>\n#include <linux/slab.h>\n#include <linux/i2c.h>\n#include <linux/delay.h>\n\n#include \"charlcd.h\"\n\n#define LCD2S_CMD_CUR_MOVES_FWD\t\t0x09\n#define LCD2S_CMD_CUR_BLINK_OFF\t\t0x10\n#define LCD2S_CMD_CUR_UL_OFF\t\t0x11\n#define LCD2S_CMD_DISPLAY_OFF\t\t0x12\n#define LCD2S_CMD_CUR_BLINK_ON\t\t0x18\n#define LCD2S_CMD_CUR_UL_ON\t\t0x19\n#define LCD2S_CMD_DISPLAY_ON\t\t0x1a\n#define LCD2S_CMD_BACKLIGHT_OFF\t\t0x20\n#define LCD2S_CMD_BACKLIGHT_ON\t\t0x28\n#define LCD2S_CMD_WRITE\t\t\t0x80\n#define LCD2S_CMD_MOV_CUR_RIGHT\t\t0x83\n#define LCD2S_CMD_MOV_CUR_LEFT\t\t0x84\n#define LCD2S_CMD_SHIFT_RIGHT\t\t0x85\n#define LCD2S_CMD_SHIFT_LEFT\t\t0x86\n#define LCD2S_CMD_SHIFT_UP\t\t0x87\n#define LCD2S_CMD_SHIFT_DOWN\t\t0x88\n#define LCD2S_CMD_CUR_ADDR\t\t0x89\n#define LCD2S_CMD_CUR_POS\t\t0x8a\n#define LCD2S_CMD_CUR_RESET\t\t0x8b\n#define LCD2S_CMD_CLEAR\t\t\t0x8c\n#define LCD2S_CMD_DEF_CUSTOM_CHAR\t0x92\n#define LCD2S_CMD_READ_STATUS\t\t0xd0\n\n#define LCD2S_CHARACTER_SIZE\t\t8\n\n#define LCD2S_STATUS_BUF_MASK\t\t0x7f\n\nstruct lcd2s_data {\n\tstruct i2c_client *i2c;\n\tstruct charlcd *charlcd;\n};\n\nstatic s32 lcd2s_wait_buf_free(const struct i2c_client *client, int count)\n{\n\ts32 status;\n\n\tstatus = i2c_smbus_read_byte_data(client, LCD2S_CMD_READ_STATUS);\n\tif (status < 0)\n\t\treturn status;\n\n\twhile ((status & LCD2S_STATUS_BUF_MASK) < count) {\n\t\tmdelay(1);\n\t\tstatus = i2c_smbus_read_byte_data(client,\n\t\t\t\t\t\t  LCD2S_CMD_READ_STATUS);\n\t\tif (status < 0)\n\t\t\treturn status;\n\t}\n\treturn 0;\n}\n\nstatic int lcd2s_i2c_master_send(const struct i2c_client *client,\n\t\t\t\t const char *buf, int count)\n{\n\ts32 status;\n\n\tstatus = lcd2s_wait_buf_free(client, count);\n\tif (status < 0)\n\t\treturn status;\n\n\treturn i2c_master_send(client, buf, count);\n}\n\nstatic int lcd2s_i2c_smbus_write_byte(const struct i2c_client *client, u8 value)\n{\n\ts32 status;\n\n\tstatus = lcd2s_wait_buf_free(client, 1);\n\tif (status < 0)\n\t\treturn status;\n\n\treturn i2c_smbus_write_byte(client, value);\n}\n\nstatic int lcd2s_print(struct charlcd *lcd, int c)\n{\n\tstruct lcd2s_data *lcd2s = lcd->drvdata;\n\tu8 buf[2] = { LCD2S_CMD_WRITE, c };\n\n\tlcd2s_i2c_master_send(lcd2s->i2c, buf, sizeof(buf));\n\treturn 0;\n}\n\nstatic int lcd2s_gotoxy(struct charlcd *lcd, unsigned int x, unsigned int y)\n{\n\tstruct lcd2s_data *lcd2s = lcd->drvdata;\n\tu8 buf[3] = { LCD2S_CMD_CUR_POS, y + 1, x + 1 };\n\n\tlcd2s_i2c_master_send(lcd2s->i2c, buf, sizeof(buf));\n\n\treturn 0;\n}\n\nstatic int lcd2s_home(struct charlcd *lcd)\n{\n\tstruct lcd2s_data *lcd2s = lcd->drvdata;\n\n\tlcd2s_i2c_smbus_write_byte(lcd2s->i2c, LCD2S_CMD_CUR_RESET);\n\treturn 0;\n}\n\nstatic int lcd2s_init_display(struct charlcd *lcd)\n{\n\tstruct lcd2s_data *lcd2s = lcd->drvdata;\n\n\t \n\tlcd2s_i2c_smbus_write_byte(lcd2s->i2c, LCD2S_CMD_DISPLAY_ON);\n\tlcd2s_i2c_smbus_write_byte(lcd2s->i2c, LCD2S_CMD_BACKLIGHT_OFF);\n\tlcd2s_i2c_smbus_write_byte(lcd2s->i2c, LCD2S_CMD_CUR_MOVES_FWD);\n\tlcd2s_i2c_smbus_write_byte(lcd2s->i2c, LCD2S_CMD_CUR_BLINK_OFF);\n\tlcd2s_i2c_smbus_write_byte(lcd2s->i2c, LCD2S_CMD_CUR_UL_OFF);\n\tlcd2s_i2c_smbus_write_byte(lcd2s->i2c, LCD2S_CMD_CLEAR);\n\n\treturn 0;\n}\n\nstatic int lcd2s_shift_cursor(struct charlcd *lcd, enum charlcd_shift_dir dir)\n{\n\tstruct lcd2s_data *lcd2s = lcd->drvdata;\n\n\tif (dir == CHARLCD_SHIFT_LEFT)\n\t\tlcd2s_i2c_smbus_write_byte(lcd2s->i2c, LCD2S_CMD_MOV_CUR_LEFT);\n\telse\n\t\tlcd2s_i2c_smbus_write_byte(lcd2s->i2c, LCD2S_CMD_MOV_CUR_RIGHT);\n\n\treturn 0;\n}\n\nstatic int lcd2s_shift_display(struct charlcd *lcd, enum charlcd_shift_dir dir)\n{\n\tstruct lcd2s_data *lcd2s = lcd->drvdata;\n\n\tif (dir == CHARLCD_SHIFT_LEFT)\n\t\tlcd2s_i2c_smbus_write_byte(lcd2s->i2c, LCD2S_CMD_SHIFT_LEFT);\n\telse\n\t\tlcd2s_i2c_smbus_write_byte(lcd2s->i2c, LCD2S_CMD_SHIFT_RIGHT);\n\n\treturn 0;\n}\n\nstatic void lcd2s_backlight(struct charlcd *lcd, enum charlcd_onoff on)\n{\n\tstruct lcd2s_data *lcd2s = lcd->drvdata;\n\n\tif (on)\n\t\tlcd2s_i2c_smbus_write_byte(lcd2s->i2c, LCD2S_CMD_BACKLIGHT_ON);\n\telse\n\t\tlcd2s_i2c_smbus_write_byte(lcd2s->i2c, LCD2S_CMD_BACKLIGHT_OFF);\n}\n\nstatic int lcd2s_display(struct charlcd *lcd, enum charlcd_onoff on)\n{\n\tstruct lcd2s_data *lcd2s = lcd->drvdata;\n\n\tif (on)\n\t\tlcd2s_i2c_smbus_write_byte(lcd2s->i2c, LCD2S_CMD_DISPLAY_ON);\n\telse\n\t\tlcd2s_i2c_smbus_write_byte(lcd2s->i2c, LCD2S_CMD_DISPLAY_OFF);\n\n\treturn 0;\n}\n\nstatic int lcd2s_cursor(struct charlcd *lcd, enum charlcd_onoff on)\n{\n\tstruct lcd2s_data *lcd2s = lcd->drvdata;\n\n\tif (on)\n\t\tlcd2s_i2c_smbus_write_byte(lcd2s->i2c, LCD2S_CMD_CUR_UL_ON);\n\telse\n\t\tlcd2s_i2c_smbus_write_byte(lcd2s->i2c, LCD2S_CMD_CUR_UL_OFF);\n\n\treturn 0;\n}\n\nstatic int lcd2s_blink(struct charlcd *lcd, enum charlcd_onoff on)\n{\n\tstruct lcd2s_data *lcd2s = lcd->drvdata;\n\n\tif (on)\n\t\tlcd2s_i2c_smbus_write_byte(lcd2s->i2c, LCD2S_CMD_CUR_BLINK_ON);\n\telse\n\t\tlcd2s_i2c_smbus_write_byte(lcd2s->i2c, LCD2S_CMD_CUR_BLINK_OFF);\n\n\treturn 0;\n}\n\nstatic int lcd2s_fontsize(struct charlcd *lcd, enum charlcd_fontsize size)\n{\n\treturn 0;\n}\n\nstatic int lcd2s_lines(struct charlcd *lcd, enum charlcd_lines lines)\n{\n\treturn 0;\n}\n\n \nstatic int lcd2s_redefine_char(struct charlcd *lcd, char *esc)\n{\n\tstruct lcd2s_data *lcd2s = lcd->drvdata;\n\tu8 buf[LCD2S_CHARACTER_SIZE + 2] = { LCD2S_CMD_DEF_CUSTOM_CHAR };\n\tu8 value;\n\tint shift, i;\n\n\tif (!strchr(esc, ';'))\n\t\treturn 0;\n\n\tesc++;\n\n\tbuf[1] = *(esc++) - '0';\n\tif (buf[1] > 7)\n\t\treturn 1;\n\n\ti = 2;\n\tshift = 0;\n\tvalue = 0;\n\twhile (*esc && i < LCD2S_CHARACTER_SIZE + 2) {\n\t\tint half;\n\n\t\tshift ^= 4;\n\t\thalf = hex_to_bin(*esc++);\n\t\tif (half < 0)\n\t\t\tcontinue;\n\n\t\tvalue |= half << shift;\n\t\tif (shift == 0) {\n\t\t\tbuf[i++] = value;\n\t\t\tvalue = 0;\n\t\t}\n\t}\n\n\tlcd2s_i2c_master_send(lcd2s->i2c, buf, sizeof(buf));\n\treturn 1;\n}\n\nstatic int lcd2s_clear_display(struct charlcd *lcd)\n{\n\tstruct lcd2s_data *lcd2s = lcd->drvdata;\n\n\t \n\tlcd2s_i2c_smbus_write_byte(lcd2s->i2c, LCD2S_CMD_CLEAR);\n\treturn 0;\n}\n\nstatic const struct charlcd_ops lcd2s_ops = {\n\t.print\t\t= lcd2s_print,\n\t.backlight\t= lcd2s_backlight,\n\t.gotoxy\t\t= lcd2s_gotoxy,\n\t.home\t\t= lcd2s_home,\n\t.clear_display\t= lcd2s_clear_display,\n\t.init_display\t= lcd2s_init_display,\n\t.shift_cursor\t= lcd2s_shift_cursor,\n\t.shift_display\t= lcd2s_shift_display,\n\t.display\t= lcd2s_display,\n\t.cursor\t\t= lcd2s_cursor,\n\t.blink\t\t= lcd2s_blink,\n\t.fontsize\t= lcd2s_fontsize,\n\t.lines\t\t= lcd2s_lines,\n\t.redefine_char\t= lcd2s_redefine_char,\n};\n\nstatic int lcd2s_i2c_probe(struct i2c_client *i2c)\n{\n\tstruct charlcd *lcd;\n\tstruct lcd2s_data *lcd2s;\n\tint err;\n\n\tif (!i2c_check_functionality(i2c->adapter,\n\t\t\tI2C_FUNC_SMBUS_WRITE_BYTE_DATA |\n\t\t\tI2C_FUNC_SMBUS_WRITE_BLOCK_DATA))\n\t\treturn -EIO;\n\n\tlcd2s = devm_kzalloc(&i2c->dev, sizeof(*lcd2s), GFP_KERNEL);\n\tif (!lcd2s)\n\t\treturn -ENOMEM;\n\n\t \n\terr = lcd2s_i2c_smbus_write_byte(i2c, LCD2S_CMD_DISPLAY_OFF);\n\tif (err < 0)\n\t\treturn err;\n\n\tlcd = charlcd_alloc();\n\tif (!lcd)\n\t\treturn -ENOMEM;\n\n\tlcd->drvdata = lcd2s;\n\tlcd2s->i2c = i2c;\n\tlcd2s->charlcd = lcd;\n\n\t \n\terr = device_property_read_u32(&i2c->dev, \"display-height-chars\",\n\t\t\t&lcd->height);\n\tif (err)\n\t\tgoto fail1;\n\n\terr = device_property_read_u32(&i2c->dev, \"display-width-chars\",\n\t\t\t&lcd->width);\n\tif (err)\n\t\tgoto fail1;\n\n\tlcd->ops = &lcd2s_ops;\n\n\terr = charlcd_register(lcd2s->charlcd);\n\tif (err)\n\t\tgoto fail1;\n\n\ti2c_set_clientdata(i2c, lcd2s);\n\treturn 0;\n\nfail1:\n\tcharlcd_free(lcd2s->charlcd);\n\treturn err;\n}\n\nstatic void lcd2s_i2c_remove(struct i2c_client *i2c)\n{\n\tstruct lcd2s_data *lcd2s = i2c_get_clientdata(i2c);\n\n\tcharlcd_unregister(lcd2s->charlcd);\n\tcharlcd_free(lcd2s->charlcd);\n}\n\nstatic const struct i2c_device_id lcd2s_i2c_id[] = {\n\t{ \"lcd2s\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, lcd2s_i2c_id);\n\nstatic const struct of_device_id lcd2s_of_table[] = {\n\t{ .compatible = \"modtronix,lcd2s\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, lcd2s_of_table);\n\nstatic struct i2c_driver lcd2s_i2c_driver = {\n\t.driver = {\n\t\t.name = \"lcd2s\",\n\t\t.of_match_table = lcd2s_of_table,\n\t},\n\t.probe = lcd2s_i2c_probe,\n\t.remove = lcd2s_i2c_remove,\n\t.id_table = lcd2s_i2c_id,\n};\nmodule_i2c_driver(lcd2s_i2c_driver);\n\nMODULE_DESCRIPTION(\"LCD2S character display driver\");\nMODULE_AUTHOR(\"Lars Poeschel\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}