{
  "module_name": "api.c",
  "hash_id": "e9956fc3ddcdd2b79e7cd033036ab71ec8885f1bb6173427b59acdc397a232b8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/msi/api.c",
  "human_readable_source": "\n \n\n#include <linux/export.h>\n#include <linux/irq.h>\n\n#include \"msi.h\"\n\n \nint pci_enable_msi(struct pci_dev *dev)\n{\n\tint rc = __pci_enable_msi_range(dev, 1, 1, NULL);\n\tif (rc < 0)\n\t\treturn rc;\n\treturn 0;\n}\nEXPORT_SYMBOL(pci_enable_msi);\n\n \nvoid pci_disable_msi(struct pci_dev *dev)\n{\n\tif (!pci_msi_enabled() || !dev || !dev->msi_enabled)\n\t\treturn;\n\n\tmsi_lock_descs(&dev->dev);\n\tpci_msi_shutdown(dev);\n\tpci_free_msi_irqs(dev);\n\tmsi_unlock_descs(&dev->dev);\n}\nEXPORT_SYMBOL(pci_disable_msi);\n\n \nint pci_msix_vec_count(struct pci_dev *dev)\n{\n\tu16 control;\n\n\tif (!dev->msix_cap)\n\t\treturn -EINVAL;\n\n\tpci_read_config_word(dev, dev->msix_cap + PCI_MSIX_FLAGS, &control);\n\treturn msix_table_size(control);\n}\nEXPORT_SYMBOL(pci_msix_vec_count);\n\n \nint pci_enable_msix_range(struct pci_dev *dev, struct msix_entry *entries,\n\t\t\t  int minvec, int maxvec)\n{\n\treturn __pci_enable_msix_range(dev, entries, minvec, maxvec, NULL, 0);\n}\nEXPORT_SYMBOL(pci_enable_msix_range);\n\n \nbool pci_msix_can_alloc_dyn(struct pci_dev *dev)\n{\n\tif (!dev->msix_cap)\n\t\treturn false;\n\n\treturn pci_msi_domain_supports(dev, MSI_FLAG_PCI_MSIX_ALLOC_DYN, DENY_LEGACY);\n}\nEXPORT_SYMBOL_GPL(pci_msix_can_alloc_dyn);\n\n \nstruct msi_map pci_msix_alloc_irq_at(struct pci_dev *dev, unsigned int index,\n\t\t\t\t     const struct irq_affinity_desc *affdesc)\n{\n\tstruct msi_map map = { .index = -ENOTSUPP };\n\n\tif (!dev->msix_enabled)\n\t\treturn map;\n\n\tif (!pci_msix_can_alloc_dyn(dev))\n\t\treturn map;\n\n\treturn msi_domain_alloc_irq_at(&dev->dev, MSI_DEFAULT_DOMAIN, index, affdesc, NULL);\n}\nEXPORT_SYMBOL_GPL(pci_msix_alloc_irq_at);\n\n \nvoid pci_msix_free_irq(struct pci_dev *dev, struct msi_map map)\n{\n\tif (WARN_ON_ONCE(map.index < 0 || map.virq <= 0))\n\t\treturn;\n\tif (WARN_ON_ONCE(!pci_msix_can_alloc_dyn(dev)))\n\t\treturn;\n\tmsi_domain_free_irqs_range(&dev->dev, MSI_DEFAULT_DOMAIN, map.index, map.index);\n}\nEXPORT_SYMBOL_GPL(pci_msix_free_irq);\n\n \nvoid pci_disable_msix(struct pci_dev *dev)\n{\n\tif (!pci_msi_enabled() || !dev || !dev->msix_enabled)\n\t\treturn;\n\n\tmsi_lock_descs(&dev->dev);\n\tpci_msix_shutdown(dev);\n\tpci_free_msi_irqs(dev);\n\tmsi_unlock_descs(&dev->dev);\n}\nEXPORT_SYMBOL(pci_disable_msix);\n\n \nint pci_alloc_irq_vectors(struct pci_dev *dev, unsigned int min_vecs,\n\t\t\t  unsigned int max_vecs, unsigned int flags)\n{\n\treturn pci_alloc_irq_vectors_affinity(dev, min_vecs, max_vecs,\n\t\t\t\t\t      flags, NULL);\n}\nEXPORT_SYMBOL(pci_alloc_irq_vectors);\n\n \nint pci_alloc_irq_vectors_affinity(struct pci_dev *dev, unsigned int min_vecs,\n\t\t\t\t   unsigned int max_vecs, unsigned int flags,\n\t\t\t\t   struct irq_affinity *affd)\n{\n\tstruct irq_affinity msi_default_affd = {0};\n\tint nvecs = -ENOSPC;\n\n\tif (flags & PCI_IRQ_AFFINITY) {\n\t\tif (!affd)\n\t\t\taffd = &msi_default_affd;\n\t} else {\n\t\tif (WARN_ON(affd))\n\t\t\taffd = NULL;\n\t}\n\n\tif (flags & PCI_IRQ_MSIX) {\n\t\tnvecs = __pci_enable_msix_range(dev, NULL, min_vecs, max_vecs,\n\t\t\t\t\t\taffd, flags);\n\t\tif (nvecs > 0)\n\t\t\treturn nvecs;\n\t}\n\n\tif (flags & PCI_IRQ_MSI) {\n\t\tnvecs = __pci_enable_msi_range(dev, min_vecs, max_vecs, affd);\n\t\tif (nvecs > 0)\n\t\t\treturn nvecs;\n\t}\n\n\t \n\tif (flags & PCI_IRQ_LEGACY) {\n\t\tif (min_vecs == 1 && dev->irq) {\n\t\t\t \n\t\t\tif (affd)\n\t\t\t\tirq_create_affinity_masks(1, affd);\n\t\t\tpci_intx(dev, 1);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn nvecs;\n}\nEXPORT_SYMBOL(pci_alloc_irq_vectors_affinity);\n\n \nint pci_irq_vector(struct pci_dev *dev, unsigned int nr)\n{\n\tunsigned int irq;\n\n\tif (!dev->msi_enabled && !dev->msix_enabled)\n\t\treturn !nr ? dev->irq : -EINVAL;\n\n\tirq = msi_get_virq(&dev->dev, nr);\n\treturn irq ? irq : -EINVAL;\n}\nEXPORT_SYMBOL(pci_irq_vector);\n\n \nconst struct cpumask *pci_irq_get_affinity(struct pci_dev *dev, int nr)\n{\n\tint idx, irq = pci_irq_vector(dev, nr);\n\tstruct msi_desc *desc;\n\n\tif (WARN_ON_ONCE(irq <= 0))\n\t\treturn NULL;\n\n\tdesc = irq_get_msi_desc(irq);\n\t \n\tif (!desc)\n\t\treturn cpu_possible_mask;\n\n\t \n\tif (!desc->affinity)\n\t\treturn NULL;\n\n\t \n\tidx = dev->msi_enabled ? nr : 0;\n\treturn &desc->affinity[idx].mask;\n}\nEXPORT_SYMBOL(pci_irq_get_affinity);\n\n \nstruct msi_map pci_ims_alloc_irq(struct pci_dev *dev, union msi_instance_cookie *icookie,\n\t\t\t\t const struct irq_affinity_desc *affdesc)\n{\n\treturn msi_domain_alloc_irq_at(&dev->dev, MSI_SECONDARY_DOMAIN, MSI_ANY_INDEX,\n\t\t\t\t       affdesc, icookie);\n}\nEXPORT_SYMBOL_GPL(pci_ims_alloc_irq);\n\n \nvoid pci_ims_free_irq(struct pci_dev *dev, struct msi_map map)\n{\n\tif (WARN_ON_ONCE(map.index < 0 || map.virq <= 0))\n\t\treturn;\n\tmsi_domain_free_irqs_range(&dev->dev, MSI_SECONDARY_DOMAIN, map.index, map.index);\n}\nEXPORT_SYMBOL_GPL(pci_ims_free_irq);\n\n \nvoid pci_free_irq_vectors(struct pci_dev *dev)\n{\n\tpci_disable_msix(dev);\n\tpci_disable_msi(dev);\n}\nEXPORT_SYMBOL(pci_free_irq_vectors);\n\n \nvoid pci_restore_msi_state(struct pci_dev *dev)\n{\n\t__pci_restore_msi_state(dev);\n\t__pci_restore_msix_state(dev);\n}\nEXPORT_SYMBOL_GPL(pci_restore_msi_state);\n\n \nint pci_msi_enabled(void)\n{\n\treturn pci_msi_enable;\n}\nEXPORT_SYMBOL(pci_msi_enabled);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}