{
  "module_name": "msi.h",
  "hash_id": "ef672bdb109665d6f17a94d8688fa48b069d35a1c185075a2a25774147ec72fd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/msi/msi.h",
  "human_readable_source": " \n\n#include <linux/pci.h>\n#include <linux/msi.h>\n\n#define msix_table_size(flags)\t((flags & PCI_MSIX_FLAGS_QSIZE) + 1)\n\nint pci_msi_setup_msi_irqs(struct pci_dev *dev, int nvec, int type);\nvoid pci_msi_teardown_msi_irqs(struct pci_dev *dev);\n\n \nvoid pci_msi_update_mask(struct msi_desc *desc, u32 clear, u32 set);\n\nstatic inline void pci_msi_mask(struct msi_desc *desc, u32 mask)\n{\n\tpci_msi_update_mask(desc, 0, mask);\n}\n\nstatic inline void pci_msi_unmask(struct msi_desc *desc, u32 mask)\n{\n\tpci_msi_update_mask(desc, mask, 0);\n}\n\nstatic inline void __iomem *pci_msix_desc_addr(struct msi_desc *desc)\n{\n\treturn desc->pci.mask_base + desc->msi_index * PCI_MSIX_ENTRY_SIZE;\n}\n\n \nstatic inline void pci_msix_write_vector_ctrl(struct msi_desc *desc, u32 ctrl)\n{\n\tvoid __iomem *desc_addr = pci_msix_desc_addr(desc);\n\n\tif (desc->pci.msi_attrib.can_mask)\n\t\twritel(ctrl, desc_addr + PCI_MSIX_ENTRY_VECTOR_CTRL);\n}\n\nstatic inline void pci_msix_mask(struct msi_desc *desc)\n{\n\tdesc->pci.msix_ctrl |= PCI_MSIX_ENTRY_CTRL_MASKBIT;\n\tpci_msix_write_vector_ctrl(desc, desc->pci.msix_ctrl);\n\t \n\treadl(desc->pci.mask_base);\n}\n\nstatic inline void pci_msix_unmask(struct msi_desc *desc)\n{\n\tdesc->pci.msix_ctrl &= ~PCI_MSIX_ENTRY_CTRL_MASKBIT;\n\tpci_msix_write_vector_ctrl(desc, desc->pci.msix_ctrl);\n}\n\nstatic inline void __pci_msi_mask_desc(struct msi_desc *desc, u32 mask)\n{\n\tif (desc->pci.msi_attrib.is_msix)\n\t\tpci_msix_mask(desc);\n\telse\n\t\tpci_msi_mask(desc, mask);\n}\n\nstatic inline void __pci_msi_unmask_desc(struct msi_desc *desc, u32 mask)\n{\n\tif (desc->pci.msi_attrib.is_msix)\n\t\tpci_msix_unmask(desc);\n\telse\n\t\tpci_msi_unmask(desc, mask);\n}\n\n \nstatic inline __attribute_const__ u32 msi_multi_mask(struct msi_desc *desc)\n{\n\t \n\tif (desc->pci.msi_attrib.multi_cap >= 5)\n\t\treturn 0xffffffff;\n\treturn (1 << (1 << desc->pci.msi_attrib.multi_cap)) - 1;\n}\n\nvoid msix_prepare_msi_desc(struct pci_dev *dev, struct msi_desc *desc);\n\n \nextern int pci_msi_enable;\n\n \nvoid pci_msi_shutdown(struct pci_dev *dev);\nvoid pci_msix_shutdown(struct pci_dev *dev);\nvoid pci_free_msi_irqs(struct pci_dev *dev);\nint __pci_enable_msi_range(struct pci_dev *dev, int minvec, int maxvec, struct irq_affinity *affd);\nint __pci_enable_msix_range(struct pci_dev *dev, struct msix_entry *entries, int minvec,\n\t\t\t    int maxvec,  struct irq_affinity *affd, int flags);\nvoid __pci_restore_msi_state(struct pci_dev *dev);\nvoid __pci_restore_msix_state(struct pci_dev *dev);\n\n \n\nenum support_mode {\n\tALLOW_LEGACY,\n\tDENY_LEGACY,\n};\n\nbool pci_msi_domain_supports(struct pci_dev *dev, unsigned int feature_mask, enum support_mode mode);\nbool pci_setup_msi_device_domain(struct pci_dev *pdev);\nbool pci_setup_msix_device_domain(struct pci_dev *pdev, unsigned int hwsize);\n\n \n\n#ifdef CONFIG_PCI_MSI_ARCH_FALLBACKS\nint pci_msi_legacy_setup_msi_irqs(struct pci_dev *dev, int nvec, int type);\nvoid pci_msi_legacy_teardown_msi_irqs(struct pci_dev *dev);\n#else\nstatic inline int pci_msi_legacy_setup_msi_irqs(struct pci_dev *dev, int nvec, int type)\n{\n\tWARN_ON_ONCE(1);\n\treturn -ENODEV;\n}\n\nstatic inline void pci_msi_legacy_teardown_msi_irqs(struct pci_dev *dev)\n{\n\tWARN_ON_ONCE(1);\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}