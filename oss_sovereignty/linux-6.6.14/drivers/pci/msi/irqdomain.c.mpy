{
  "module_name": "irqdomain.c",
  "hash_id": "af2166cff13bc786c148e786ef52d4f451ba88f2a916228f7b600891a66bd297",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/msi/irqdomain.c",
  "human_readable_source": "\n \n#include <linux/acpi_iort.h>\n#include <linux/irqdomain.h>\n#include <linux/of_irq.h>\n\n#include \"msi.h\"\n\nint pci_msi_setup_msi_irqs(struct pci_dev *dev, int nvec, int type)\n{\n\tstruct irq_domain *domain;\n\n\tdomain = dev_get_msi_domain(&dev->dev);\n\tif (domain && irq_domain_is_hierarchy(domain))\n\t\treturn msi_domain_alloc_irqs_all_locked(&dev->dev, MSI_DEFAULT_DOMAIN, nvec);\n\n\treturn pci_msi_legacy_setup_msi_irqs(dev, nvec, type);\n}\n\nvoid pci_msi_teardown_msi_irqs(struct pci_dev *dev)\n{\n\tstruct irq_domain *domain;\n\n\tdomain = dev_get_msi_domain(&dev->dev);\n\tif (domain && irq_domain_is_hierarchy(domain)) {\n\t\tmsi_domain_free_irqs_all_locked(&dev->dev, MSI_DEFAULT_DOMAIN);\n\t} else {\n\t\tpci_msi_legacy_teardown_msi_irqs(dev);\n\t\tmsi_free_msi_descs(&dev->dev);\n\t}\n}\n\n \nstatic void pci_msi_domain_write_msg(struct irq_data *irq_data, struct msi_msg *msg)\n{\n\tstruct msi_desc *desc = irq_data_get_msi_desc(irq_data);\n\n\t \n\tif (desc->irq == irq_data->irq)\n\t\t__pci_write_msi_msg(desc, msg);\n}\n\n \nstatic irq_hw_number_t pci_msi_domain_calc_hwirq(struct msi_desc *desc)\n{\n\tstruct pci_dev *dev = msi_desc_to_pci_dev(desc);\n\n\treturn (irq_hw_number_t)desc->msi_index |\n\t\tpci_dev_id(dev) << 11 |\n\t\t(pci_domain_nr(dev->bus) & 0xFFFFFFFF) << 27;\n}\n\nstatic void pci_msi_domain_set_desc(msi_alloc_info_t *arg,\n\t\t\t\t    struct msi_desc *desc)\n{\n\targ->desc = desc;\n\targ->hwirq = pci_msi_domain_calc_hwirq(desc);\n}\n\nstatic struct msi_domain_ops pci_msi_domain_ops_default = {\n\t.set_desc\t= pci_msi_domain_set_desc,\n};\n\nstatic void pci_msi_domain_update_dom_ops(struct msi_domain_info *info)\n{\n\tstruct msi_domain_ops *ops = info->ops;\n\n\tif (ops == NULL) {\n\t\tinfo->ops = &pci_msi_domain_ops_default;\n\t} else {\n\t\tif (ops->set_desc == NULL)\n\t\t\tops->set_desc = pci_msi_domain_set_desc;\n\t}\n}\n\nstatic void pci_msi_domain_update_chip_ops(struct msi_domain_info *info)\n{\n\tstruct irq_chip *chip = info->chip;\n\n\tBUG_ON(!chip);\n\tif (!chip->irq_write_msi_msg)\n\t\tchip->irq_write_msi_msg = pci_msi_domain_write_msg;\n\tif (!chip->irq_mask)\n\t\tchip->irq_mask = pci_msi_mask_irq;\n\tif (!chip->irq_unmask)\n\t\tchip->irq_unmask = pci_msi_unmask_irq;\n}\n\n \nstruct irq_domain *pci_msi_create_irq_domain(struct fwnode_handle *fwnode,\n\t\t\t\t\t     struct msi_domain_info *info,\n\t\t\t\t\t     struct irq_domain *parent)\n{\n\tif (WARN_ON(info->flags & MSI_FLAG_LEVEL_CAPABLE))\n\t\tinfo->flags &= ~MSI_FLAG_LEVEL_CAPABLE;\n\n\tif (info->flags & MSI_FLAG_USE_DEF_DOM_OPS)\n\t\tpci_msi_domain_update_dom_ops(info);\n\tif (info->flags & MSI_FLAG_USE_DEF_CHIP_OPS)\n\t\tpci_msi_domain_update_chip_ops(info);\n\n\t \n\tinfo->flags |= MSI_FLAG_FREE_MSI_DESCS;\n\n\tinfo->flags |= MSI_FLAG_ACTIVATE_EARLY | MSI_FLAG_DEV_SYSFS;\n\tif (IS_ENABLED(CONFIG_GENERIC_IRQ_RESERVATION_MODE))\n\t\tinfo->flags |= MSI_FLAG_MUST_REACTIVATE;\n\n\t \n\tinfo->chip->flags |= IRQCHIP_ONESHOT_SAFE;\n\t \n\tinfo->bus_token = DOMAIN_BUS_PCI_MSI;\n\n\treturn msi_create_irq_domain(fwnode, info, parent);\n}\nEXPORT_SYMBOL_GPL(pci_msi_create_irq_domain);\n\n \nstatic void pci_device_domain_set_desc(msi_alloc_info_t *arg, struct msi_desc *desc)\n{\n\targ->desc = desc;\n\targ->hwirq = desc->msi_index;\n}\n\nstatic void pci_irq_mask_msi(struct irq_data *data)\n{\n\tstruct msi_desc *desc = irq_data_get_msi_desc(data);\n\n\tpci_msi_mask(desc, BIT(data->irq - desc->irq));\n}\n\nstatic void pci_irq_unmask_msi(struct irq_data *data)\n{\n\tstruct msi_desc *desc = irq_data_get_msi_desc(data);\n\n\tpci_msi_unmask(desc, BIT(data->irq - desc->irq));\n}\n\n#ifdef CONFIG_GENERIC_IRQ_RESERVATION_MODE\n# define MSI_REACTIVATE\t\tMSI_FLAG_MUST_REACTIVATE\n#else\n# define MSI_REACTIVATE\t\t0\n#endif\n\n#define MSI_COMMON_FLAGS\t(MSI_FLAG_FREE_MSI_DESCS |\t\\\n\t\t\t\t MSI_FLAG_ACTIVATE_EARLY |\t\\\n\t\t\t\t MSI_FLAG_DEV_SYSFS |\t\t\\\n\t\t\t\t MSI_REACTIVATE)\n\nstatic const struct msi_domain_template pci_msi_template = {\n\t.chip = {\n\t\t.name\t\t\t= \"PCI-MSI\",\n\t\t.irq_mask\t\t= pci_irq_mask_msi,\n\t\t.irq_unmask\t\t= pci_irq_unmask_msi,\n\t\t.irq_write_msi_msg\t= pci_msi_domain_write_msg,\n\t\t.flags\t\t\t= IRQCHIP_ONESHOT_SAFE,\n\t},\n\n\t.ops = {\n\t\t.set_desc\t\t= pci_device_domain_set_desc,\n\t},\n\n\t.info = {\n\t\t.flags\t\t\t= MSI_COMMON_FLAGS | MSI_FLAG_MULTI_PCI_MSI,\n\t\t.bus_token\t\t= DOMAIN_BUS_PCI_DEVICE_MSI,\n\t},\n};\n\nstatic void pci_irq_mask_msix(struct irq_data *data)\n{\n\tpci_msix_mask(irq_data_get_msi_desc(data));\n}\n\nstatic void pci_irq_unmask_msix(struct irq_data *data)\n{\n\tpci_msix_unmask(irq_data_get_msi_desc(data));\n}\n\nstatic void pci_msix_prepare_desc(struct irq_domain *domain, msi_alloc_info_t *arg,\n\t\t\t\t  struct msi_desc *desc)\n{\n\t \n\tif (!desc->pci.mask_base)\n\t\tmsix_prepare_msi_desc(to_pci_dev(desc->dev), desc);\n}\n\nstatic const struct msi_domain_template pci_msix_template = {\n\t.chip = {\n\t\t.name\t\t\t= \"PCI-MSIX\",\n\t\t.irq_mask\t\t= pci_irq_mask_msix,\n\t\t.irq_unmask\t\t= pci_irq_unmask_msix,\n\t\t.irq_write_msi_msg\t= pci_msi_domain_write_msg,\n\t\t.flags\t\t\t= IRQCHIP_ONESHOT_SAFE,\n\t},\n\n\t.ops = {\n\t\t.prepare_desc\t\t= pci_msix_prepare_desc,\n\t\t.set_desc\t\t= pci_device_domain_set_desc,\n\t},\n\n\t.info = {\n\t\t.flags\t\t\t= MSI_COMMON_FLAGS | MSI_FLAG_PCI_MSIX |\n\t\t\t\t\t  MSI_FLAG_PCI_MSIX_ALLOC_DYN,\n\t\t.bus_token\t\t= DOMAIN_BUS_PCI_DEVICE_MSIX,\n\t},\n};\n\nstatic bool pci_match_device_domain(struct pci_dev *pdev, enum irq_domain_bus_token bus_token)\n{\n\treturn msi_match_device_irq_domain(&pdev->dev, MSI_DEFAULT_DOMAIN, bus_token);\n}\n\nstatic bool pci_create_device_domain(struct pci_dev *pdev, const struct msi_domain_template *tmpl,\n\t\t\t\t     unsigned int hwsize)\n{\n\tstruct irq_domain *domain = dev_get_msi_domain(&pdev->dev);\n\n\tif (!domain || !irq_domain_is_msi_parent(domain))\n\t\treturn true;\n\n\treturn msi_create_device_irq_domain(&pdev->dev, MSI_DEFAULT_DOMAIN, tmpl,\n\t\t\t\t\t    hwsize, NULL, NULL);\n}\n\n \nbool pci_setup_msi_device_domain(struct pci_dev *pdev)\n{\n\tif (WARN_ON_ONCE(pdev->msix_enabled))\n\t\treturn false;\n\n\tif (pci_match_device_domain(pdev, DOMAIN_BUS_PCI_DEVICE_MSI))\n\t\treturn true;\n\tif (pci_match_device_domain(pdev, DOMAIN_BUS_PCI_DEVICE_MSIX))\n\t\tmsi_remove_device_irq_domain(&pdev->dev, MSI_DEFAULT_DOMAIN);\n\n\treturn pci_create_device_domain(pdev, &pci_msi_template, 1);\n}\n\n \nbool pci_setup_msix_device_domain(struct pci_dev *pdev, unsigned int hwsize)\n{\n\tif (WARN_ON_ONCE(pdev->msi_enabled))\n\t\treturn false;\n\n\tif (pci_match_device_domain(pdev, DOMAIN_BUS_PCI_DEVICE_MSIX))\n\t\treturn true;\n\tif (pci_match_device_domain(pdev, DOMAIN_BUS_PCI_DEVICE_MSI))\n\t\tmsi_remove_device_irq_domain(&pdev->dev, MSI_DEFAULT_DOMAIN);\n\n\treturn pci_create_device_domain(pdev, &pci_msix_template, hwsize);\n}\n\n \nbool pci_msi_domain_supports(struct pci_dev *pdev, unsigned int feature_mask,\n\t\t\t     enum support_mode mode)\n{\n\tstruct msi_domain_info *info;\n\tstruct irq_domain *domain;\n\tunsigned int supported;\n\n\tdomain = dev_get_msi_domain(&pdev->dev);\n\n\tif (!domain || !irq_domain_is_hierarchy(domain))\n\t\treturn mode == ALLOW_LEGACY;\n\n\tif (!irq_domain_is_msi_parent(domain)) {\n\t\t \n\t\tinfo = domain->host_data;\n\t\tsupported = info->flags;\n\t} else {\n\t\t \n\t\tsupported = domain->msi_parent_ops->supported_flags;\n\t}\n\n\treturn (supported & feature_mask) == feature_mask;\n}\n\n \nbool pci_create_ims_domain(struct pci_dev *pdev, const struct msi_domain_template *template,\n\t\t\t   unsigned int hwsize, void *data)\n{\n\tstruct irq_domain *domain = dev_get_msi_domain(&pdev->dev);\n\n\tif (!domain || !irq_domain_is_msi_parent(domain))\n\t\treturn false;\n\n\tif (template->info.bus_token != DOMAIN_BUS_PCI_DEVICE_IMS ||\n\t    !(template->info.flags & MSI_FLAG_ALLOC_SIMPLE_MSI_DESCS) ||\n\t    !(template->info.flags & MSI_FLAG_FREE_MSI_DESCS) ||\n\t    !template->chip.irq_mask || !template->chip.irq_unmask ||\n\t    !template->chip.irq_write_msi_msg || template->chip.irq_set_affinity)\n\t\treturn false;\n\n\treturn msi_create_device_irq_domain(&pdev->dev, MSI_SECONDARY_DOMAIN, template,\n\t\t\t\t\t    hwsize, data, NULL);\n}\nEXPORT_SYMBOL_GPL(pci_create_ims_domain);\n\n \nstatic int get_msi_id_cb(struct pci_dev *pdev, u16 alias, void *data)\n{\n\tu32 *pa = data;\n\tu8 bus = PCI_BUS_NUM(*pa);\n\n\tif (pdev->bus->number != bus || PCI_BUS_NUM(alias) != bus)\n\t\t*pa = alias;\n\n\treturn 0;\n}\n\n \nu32 pci_msi_domain_get_msi_rid(struct irq_domain *domain, struct pci_dev *pdev)\n{\n\tstruct device_node *of_node;\n\tu32 rid = pci_dev_id(pdev);\n\n\tpci_for_each_dma_alias(pdev, get_msi_id_cb, &rid);\n\n\tof_node = irq_domain_get_of_node(domain);\n\trid = of_node ? of_msi_map_id(&pdev->dev, of_node, rid) :\n\t\t\tiort_msi_map_id(&pdev->dev, rid);\n\n\treturn rid;\n}\n\n \nstruct irq_domain *pci_msi_get_device_domain(struct pci_dev *pdev)\n{\n\tstruct irq_domain *dom;\n\tu32 rid = pci_dev_id(pdev);\n\n\tpci_for_each_dma_alias(pdev, get_msi_id_cb, &rid);\n\tdom = of_msi_map_get_device_domain(&pdev->dev, rid, DOMAIN_BUS_PCI_MSI);\n\tif (!dom)\n\t\tdom = iort_get_device_domain(&pdev->dev, rid,\n\t\t\t\t\t     DOMAIN_BUS_PCI_MSI);\n\treturn dom;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}