{
  "module_name": "vpd.c",
  "hash_id": "58c03d3bc0c7a8107f7bad3c56e401a2e3e83034e6673d5aa067ad4d73d86b13",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/vpd.c",
  "human_readable_source": "\n \n\n#include <linux/pci.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/sched/signal.h>\n#include <asm/unaligned.h>\n#include \"pci.h\"\n\n#define PCI_VPD_LRDT_TAG_SIZE\t\t3\n#define PCI_VPD_SRDT_LEN_MASK\t\t0x07\n#define PCI_VPD_SRDT_TAG_SIZE\t\t1\n#define PCI_VPD_STIN_END\t\t0x0f\n#define PCI_VPD_INFO_FLD_HDR_SIZE\t3\n\nstatic u16 pci_vpd_lrdt_size(const u8 *lrdt)\n{\n\treturn get_unaligned_le16(lrdt + 1);\n}\n\nstatic u8 pci_vpd_srdt_tag(const u8 *srdt)\n{\n\treturn *srdt >> 3;\n}\n\nstatic u8 pci_vpd_srdt_size(const u8 *srdt)\n{\n\treturn *srdt & PCI_VPD_SRDT_LEN_MASK;\n}\n\nstatic u8 pci_vpd_info_field_size(const u8 *info_field)\n{\n\treturn info_field[2];\n}\n\n \n\nstatic struct pci_dev *pci_get_func0_dev(struct pci_dev *dev)\n{\n\treturn pci_get_slot(dev->bus, PCI_DEVFN(PCI_SLOT(dev->devfn), 0));\n}\n\n#define PCI_VPD_MAX_SIZE\t(PCI_VPD_ADDR_MASK + 1)\n#define PCI_VPD_SZ_INVALID\tUINT_MAX\n\n \nstatic size_t pci_vpd_size(struct pci_dev *dev)\n{\n\tsize_t off = 0, size;\n\tunsigned char tag, header[1+2];\t \n\n\twhile (pci_read_vpd_any(dev, off, 1, header) == 1) {\n\t\tsize = 0;\n\n\t\tif (off == 0 && (header[0] == 0x00 || header[0] == 0xff))\n\t\t\tgoto error;\n\n\t\tif (header[0] & PCI_VPD_LRDT) {\n\t\t\t \n\t\t\tif (pci_read_vpd_any(dev, off + 1, 2, &header[1]) != 2) {\n\t\t\t\tpci_warn(dev, \"failed VPD read at offset %zu\\n\",\n\t\t\t\t\t off + 1);\n\t\t\t\treturn off ?: PCI_VPD_SZ_INVALID;\n\t\t\t}\n\t\t\tsize = pci_vpd_lrdt_size(header);\n\t\t\tif (off + size > PCI_VPD_MAX_SIZE)\n\t\t\t\tgoto error;\n\n\t\t\toff += PCI_VPD_LRDT_TAG_SIZE + size;\n\t\t} else {\n\t\t\t \n\t\t\ttag = pci_vpd_srdt_tag(header);\n\t\t\tsize = pci_vpd_srdt_size(header);\n\t\t\tif (off + size > PCI_VPD_MAX_SIZE)\n\t\t\t\tgoto error;\n\n\t\t\toff += PCI_VPD_SRDT_TAG_SIZE + size;\n\t\t\tif (tag == PCI_VPD_STIN_END)\t \n\t\t\t\treturn off;\n\t\t}\n\t}\n\treturn off;\n\nerror:\n\tpci_info(dev, \"invalid VPD tag %#04x (size %zu) at offset %zu%s\\n\",\n\t\t header[0], size, off, off == 0 ?\n\t\t \"; assume missing optional EEPROM\" : \"\");\n\treturn off ?: PCI_VPD_SZ_INVALID;\n}\n\nstatic bool pci_vpd_available(struct pci_dev *dev, bool check_size)\n{\n\tstruct pci_vpd *vpd = &dev->vpd;\n\n\tif (!vpd->cap)\n\t\treturn false;\n\n\tif (vpd->len == 0 && check_size) {\n\t\tvpd->len = pci_vpd_size(dev);\n\t\tif (vpd->len == PCI_VPD_SZ_INVALID) {\n\t\t\tvpd->cap = 0;\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\n \nstatic int pci_vpd_wait(struct pci_dev *dev, bool set)\n{\n\tstruct pci_vpd *vpd = &dev->vpd;\n\tunsigned long timeout = jiffies + msecs_to_jiffies(125);\n\tunsigned long max_sleep = 16;\n\tu16 status;\n\tint ret;\n\n\tdo {\n\t\tret = pci_user_read_config_word(dev, vpd->cap + PCI_VPD_ADDR,\n\t\t\t\t\t\t&status);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (!!(status & PCI_VPD_ADDR_F) == set)\n\t\t\treturn 0;\n\n\t\tif (time_after(jiffies, timeout))\n\t\t\tbreak;\n\n\t\tusleep_range(10, max_sleep);\n\t\tif (max_sleep < 1024)\n\t\t\tmax_sleep *= 2;\n\t} while (true);\n\n\tpci_warn(dev, \"VPD access failed.  This is likely a firmware bug on this device.  Contact the card vendor for a firmware update\\n\");\n\treturn -ETIMEDOUT;\n}\n\nstatic ssize_t pci_vpd_read(struct pci_dev *dev, loff_t pos, size_t count,\n\t\t\t    void *arg, bool check_size)\n{\n\tstruct pci_vpd *vpd = &dev->vpd;\n\tunsigned int max_len;\n\tint ret = 0;\n\tloff_t end = pos + count;\n\tu8 *buf = arg;\n\n\tif (!pci_vpd_available(dev, check_size))\n\t\treturn -ENODEV;\n\n\tif (pos < 0)\n\t\treturn -EINVAL;\n\n\tmax_len = check_size ? vpd->len : PCI_VPD_MAX_SIZE;\n\n\tif (pos >= max_len)\n\t\treturn 0;\n\n\tif (end > max_len) {\n\t\tend = max_len;\n\t\tcount = end - pos;\n\t}\n\n\tif (mutex_lock_killable(&vpd->lock))\n\t\treturn -EINTR;\n\n\twhile (pos < end) {\n\t\tu32 val;\n\t\tunsigned int i, skip;\n\n\t\tif (fatal_signal_pending(current)) {\n\t\t\tret = -EINTR;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = pci_user_write_config_word(dev, vpd->cap + PCI_VPD_ADDR,\n\t\t\t\t\t\t pos & ~3);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tret = pci_vpd_wait(dev, true);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\n\t\tret = pci_user_read_config_dword(dev, vpd->cap + PCI_VPD_DATA, &val);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\n\t\tskip = pos & 3;\n\t\tfor (i = 0;  i < sizeof(u32); i++) {\n\t\t\tif (i >= skip) {\n\t\t\t\t*buf++ = val;\n\t\t\t\tif (++pos == end)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tval >>= 8;\n\t\t}\n\t}\n\n\tmutex_unlock(&vpd->lock);\n\treturn ret ? ret : count;\n}\n\nstatic ssize_t pci_vpd_write(struct pci_dev *dev, loff_t pos, size_t count,\n\t\t\t     const void *arg, bool check_size)\n{\n\tstruct pci_vpd *vpd = &dev->vpd;\n\tunsigned int max_len;\n\tconst u8 *buf = arg;\n\tloff_t end = pos + count;\n\tint ret = 0;\n\n\tif (!pci_vpd_available(dev, check_size))\n\t\treturn -ENODEV;\n\n\tif (pos < 0 || (pos & 3) || (count & 3))\n\t\treturn -EINVAL;\n\n\tmax_len = check_size ? vpd->len : PCI_VPD_MAX_SIZE;\n\n\tif (end > max_len)\n\t\treturn -EINVAL;\n\n\tif (mutex_lock_killable(&vpd->lock))\n\t\treturn -EINTR;\n\n\twhile (pos < end) {\n\t\tret = pci_user_write_config_dword(dev, vpd->cap + PCI_VPD_DATA,\n\t\t\t\t\t\t  get_unaligned_le32(buf));\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tret = pci_user_write_config_word(dev, vpd->cap + PCI_VPD_ADDR,\n\t\t\t\t\t\t pos | PCI_VPD_ADDR_F);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\n\t\tret = pci_vpd_wait(dev, false);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\n\t\tbuf += sizeof(u32);\n\t\tpos += sizeof(u32);\n\t}\n\n\tmutex_unlock(&vpd->lock);\n\treturn ret ? ret : count;\n}\n\nvoid pci_vpd_init(struct pci_dev *dev)\n{\n\tif (dev->vpd.len == PCI_VPD_SZ_INVALID)\n\t\treturn;\n\n\tdev->vpd.cap = pci_find_capability(dev, PCI_CAP_ID_VPD);\n\tmutex_init(&dev->vpd.lock);\n}\n\nstatic ssize_t vpd_read(struct file *filp, struct kobject *kobj,\n\t\t\tstruct bin_attribute *bin_attr, char *buf, loff_t off,\n\t\t\tsize_t count)\n{\n\tstruct pci_dev *dev = to_pci_dev(kobj_to_dev(kobj));\n\tstruct pci_dev *vpd_dev = dev;\n\tssize_t ret;\n\n\tif (dev->dev_flags & PCI_DEV_FLAGS_VPD_REF_F0) {\n\t\tvpd_dev = pci_get_func0_dev(dev);\n\t\tif (!vpd_dev)\n\t\t\treturn -ENODEV;\n\t}\n\n\tpci_config_pm_runtime_get(vpd_dev);\n\tret = pci_read_vpd(vpd_dev, off, count, buf);\n\tpci_config_pm_runtime_put(vpd_dev);\n\n\tif (dev->dev_flags & PCI_DEV_FLAGS_VPD_REF_F0)\n\t\tpci_dev_put(vpd_dev);\n\n\treturn ret;\n}\n\nstatic ssize_t vpd_write(struct file *filp, struct kobject *kobj,\n\t\t\t struct bin_attribute *bin_attr, char *buf, loff_t off,\n\t\t\t size_t count)\n{\n\tstruct pci_dev *dev = to_pci_dev(kobj_to_dev(kobj));\n\tstruct pci_dev *vpd_dev = dev;\n\tssize_t ret;\n\n\tif (dev->dev_flags & PCI_DEV_FLAGS_VPD_REF_F0) {\n\t\tvpd_dev = pci_get_func0_dev(dev);\n\t\tif (!vpd_dev)\n\t\t\treturn -ENODEV;\n\t}\n\n\tpci_config_pm_runtime_get(vpd_dev);\n\tret = pci_write_vpd(vpd_dev, off, count, buf);\n\tpci_config_pm_runtime_put(vpd_dev);\n\n\tif (dev->dev_flags & PCI_DEV_FLAGS_VPD_REF_F0)\n\t\tpci_dev_put(vpd_dev);\n\n\treturn ret;\n}\nstatic BIN_ATTR(vpd, 0600, vpd_read, vpd_write, 0);\n\nstatic struct bin_attribute *vpd_attrs[] = {\n\t&bin_attr_vpd,\n\tNULL,\n};\n\nstatic umode_t vpd_attr_is_visible(struct kobject *kobj,\n\t\t\t\t   struct bin_attribute *a, int n)\n{\n\tstruct pci_dev *pdev = to_pci_dev(kobj_to_dev(kobj));\n\n\tif (!pdev->vpd.cap)\n\t\treturn 0;\n\n\treturn a->attr.mode;\n}\n\nconst struct attribute_group pci_dev_vpd_attr_group = {\n\t.bin_attrs = vpd_attrs,\n\t.is_bin_visible = vpd_attr_is_visible,\n};\n\nvoid *pci_vpd_alloc(struct pci_dev *dev, unsigned int *size)\n{\n\tunsigned int len;\n\tvoid *buf;\n\tint cnt;\n\n\tif (!pci_vpd_available(dev, true))\n\t\treturn ERR_PTR(-ENODEV);\n\n\tlen = dev->vpd.len;\n\tbuf = kmalloc(len, GFP_KERNEL);\n\tif (!buf)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcnt = pci_read_vpd(dev, 0, len, buf);\n\tif (cnt != len) {\n\t\tkfree(buf);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\n\tif (size)\n\t\t*size = len;\n\n\treturn buf;\n}\nEXPORT_SYMBOL_GPL(pci_vpd_alloc);\n\nstatic int pci_vpd_find_tag(const u8 *buf, unsigned int len, u8 rdt, unsigned int *size)\n{\n\tint i = 0;\n\n\t \n\twhile (i + PCI_VPD_LRDT_TAG_SIZE <= len && buf[i] & PCI_VPD_LRDT) {\n\t\tunsigned int lrdt_len = pci_vpd_lrdt_size(buf + i);\n\t\tu8 tag = buf[i];\n\n\t\ti += PCI_VPD_LRDT_TAG_SIZE;\n\t\tif (tag == rdt) {\n\t\t\tif (i + lrdt_len > len)\n\t\t\t\tlrdt_len = len - i;\n\t\t\tif (size)\n\t\t\t\t*size = lrdt_len;\n\t\t\treturn i;\n\t\t}\n\n\t\ti += lrdt_len;\n\t}\n\n\treturn -ENOENT;\n}\n\nint pci_vpd_find_id_string(const u8 *buf, unsigned int len, unsigned int *size)\n{\n\treturn pci_vpd_find_tag(buf, len, PCI_VPD_LRDT_ID_STRING, size);\n}\nEXPORT_SYMBOL_GPL(pci_vpd_find_id_string);\n\nstatic int pci_vpd_find_info_keyword(const u8 *buf, unsigned int off,\n\t\t\t      unsigned int len, const char *kw)\n{\n\tint i;\n\n\tfor (i = off; i + PCI_VPD_INFO_FLD_HDR_SIZE <= off + len;) {\n\t\tif (buf[i + 0] == kw[0] &&\n\t\t    buf[i + 1] == kw[1])\n\t\t\treturn i;\n\n\t\ti += PCI_VPD_INFO_FLD_HDR_SIZE +\n\t\t     pci_vpd_info_field_size(&buf[i]);\n\t}\n\n\treturn -ENOENT;\n}\n\nstatic ssize_t __pci_read_vpd(struct pci_dev *dev, loff_t pos, size_t count, void *buf,\n\t\t\t      bool check_size)\n{\n\tssize_t ret;\n\n\tif (dev->dev_flags & PCI_DEV_FLAGS_VPD_REF_F0) {\n\t\tdev = pci_get_func0_dev(dev);\n\t\tif (!dev)\n\t\t\treturn -ENODEV;\n\n\t\tret = pci_vpd_read(dev, pos, count, buf, check_size);\n\t\tpci_dev_put(dev);\n\t\treturn ret;\n\t}\n\n\treturn pci_vpd_read(dev, pos, count, buf, check_size);\n}\n\n \nssize_t pci_read_vpd(struct pci_dev *dev, loff_t pos, size_t count, void *buf)\n{\n\treturn __pci_read_vpd(dev, pos, count, buf, true);\n}\nEXPORT_SYMBOL(pci_read_vpd);\n\n \nssize_t pci_read_vpd_any(struct pci_dev *dev, loff_t pos, size_t count, void *buf)\n{\n\treturn __pci_read_vpd(dev, pos, count, buf, false);\n}\nEXPORT_SYMBOL(pci_read_vpd_any);\n\nstatic ssize_t __pci_write_vpd(struct pci_dev *dev, loff_t pos, size_t count,\n\t\t\t       const void *buf, bool check_size)\n{\n\tssize_t ret;\n\n\tif (dev->dev_flags & PCI_DEV_FLAGS_VPD_REF_F0) {\n\t\tdev = pci_get_func0_dev(dev);\n\t\tif (!dev)\n\t\t\treturn -ENODEV;\n\n\t\tret = pci_vpd_write(dev, pos, count, buf, check_size);\n\t\tpci_dev_put(dev);\n\t\treturn ret;\n\t}\n\n\treturn pci_vpd_write(dev, pos, count, buf, check_size);\n}\n\n \nssize_t pci_write_vpd(struct pci_dev *dev, loff_t pos, size_t count, const void *buf)\n{\n\treturn __pci_write_vpd(dev, pos, count, buf, true);\n}\nEXPORT_SYMBOL(pci_write_vpd);\n\n \nssize_t pci_write_vpd_any(struct pci_dev *dev, loff_t pos, size_t count, const void *buf)\n{\n\treturn __pci_write_vpd(dev, pos, count, buf, false);\n}\nEXPORT_SYMBOL(pci_write_vpd_any);\n\nint pci_vpd_find_ro_info_keyword(const void *buf, unsigned int len,\n\t\t\t\t const char *kw, unsigned int *size)\n{\n\tint ro_start, infokw_start;\n\tunsigned int ro_len, infokw_size;\n\n\tro_start = pci_vpd_find_tag(buf, len, PCI_VPD_LRDT_RO_DATA, &ro_len);\n\tif (ro_start < 0)\n\t\treturn ro_start;\n\n\tinfokw_start = pci_vpd_find_info_keyword(buf, ro_start, ro_len, kw);\n\tif (infokw_start < 0)\n\t\treturn infokw_start;\n\n\tinfokw_size = pci_vpd_info_field_size(buf + infokw_start);\n\tinfokw_start += PCI_VPD_INFO_FLD_HDR_SIZE;\n\n\tif (infokw_start + infokw_size > len)\n\t\treturn -EINVAL;\n\n\tif (size)\n\t\t*size = infokw_size;\n\n\treturn infokw_start;\n}\nEXPORT_SYMBOL_GPL(pci_vpd_find_ro_info_keyword);\n\nint pci_vpd_check_csum(const void *buf, unsigned int len)\n{\n\tconst u8 *vpd = buf;\n\tunsigned int size;\n\tu8 csum = 0;\n\tint rv_start;\n\n\trv_start = pci_vpd_find_ro_info_keyword(buf, len, PCI_VPD_RO_KEYWORD_CHKSUM, &size);\n\tif (rv_start == -ENOENT)  \n\t\treturn 1;\n\telse if (rv_start < 0)\n\t\treturn rv_start;\n\n\tif (!size)\n\t\treturn -EINVAL;\n\n\twhile (rv_start >= 0)\n\t\tcsum += vpd[rv_start--];\n\n\treturn csum ? -EILSEQ : 0;\n}\nEXPORT_SYMBOL_GPL(pci_vpd_check_csum);\n\n#ifdef CONFIG_PCI_QUIRKS\n \nstatic void quirk_f0_vpd_link(struct pci_dev *dev)\n{\n\tstruct pci_dev *f0;\n\n\tif (!PCI_FUNC(dev->devfn))\n\t\treturn;\n\n\tf0 = pci_get_func0_dev(dev);\n\tif (!f0)\n\t\treturn;\n\n\tif (f0->vpd.cap && dev->class == f0->class &&\n\t    dev->vendor == f0->vendor && dev->device == f0->device)\n\t\tdev->dev_flags |= PCI_DEV_FLAGS_VPD_REF_F0;\n\n\tpci_dev_put(f0);\n}\nDECLARE_PCI_FIXUP_CLASS_EARLY(PCI_VENDOR_ID_INTEL, PCI_ANY_ID,\n\t\t\t      PCI_CLASS_NETWORK_ETHERNET, 8, quirk_f0_vpd_link);\n\n \nstatic void quirk_blacklist_vpd(struct pci_dev *dev)\n{\n\tdev->vpd.len = PCI_VPD_SZ_INVALID;\n\tpci_warn(dev, FW_BUG \"disabling VPD access (can't determine size of non-standard VPD format)\\n\");\n}\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_LSI_LOGIC, 0x0060, quirk_blacklist_vpd);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_LSI_LOGIC, 0x007c, quirk_blacklist_vpd);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_LSI_LOGIC, 0x0413, quirk_blacklist_vpd);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_LSI_LOGIC, 0x0078, quirk_blacklist_vpd);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_LSI_LOGIC, 0x0079, quirk_blacklist_vpd);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_LSI_LOGIC, 0x0073, quirk_blacklist_vpd);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_LSI_LOGIC, 0x0071, quirk_blacklist_vpd);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_LSI_LOGIC, 0x005b, quirk_blacklist_vpd);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_LSI_LOGIC, 0x002f, quirk_blacklist_vpd);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_LSI_LOGIC, 0x005d, quirk_blacklist_vpd);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_LSI_LOGIC, 0x005f, quirk_blacklist_vpd);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_ATTANSIC, PCI_ANY_ID, quirk_blacklist_vpd);\n \nDECLARE_PCI_FIXUP_CLASS_HEADER(PCI_VENDOR_ID_AMAZON_ANNAPURNA_LABS, 0x0031,\n\t\t\t       PCI_CLASS_BRIDGE_PCI, 8, quirk_blacklist_vpd);\n\nstatic void quirk_chelsio_extend_vpd(struct pci_dev *dev)\n{\n\tint chip = (dev->device & 0xf000) >> 12;\n\tint func = (dev->device & 0x0f00) >>  8;\n\tint prod = (dev->device & 0x00ff) >>  0;\n\n\t \n\tif (chip == 0x0 && prod >= 0x20)\n\t\tdev->vpd.len = 8192;\n\telse if (chip >= 0x4 && func < 0x8)\n\t\tdev->vpd.len = 2048;\n}\n\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_CHELSIO, PCI_ANY_ID,\n\t\t\t quirk_chelsio_extend_vpd);\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}