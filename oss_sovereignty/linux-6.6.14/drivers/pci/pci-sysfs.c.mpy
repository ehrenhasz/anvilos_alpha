{
  "module_name": "pci-sysfs.c",
  "hash_id": "74f9cbf9cb00a3b1c5c6696a9e40cba70fd6a85c4ed27043f467f7f39dba0d44",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/pci-sysfs.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/pci.h>\n#include <linux/stat.h>\n#include <linux/export.h>\n#include <linux/topology.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/vgaarb.h>\n#include <linux/pm_runtime.h>\n#include <linux/msi.h>\n#include <linux/of.h>\n#include <linux/aperture.h>\n#include \"pci.h\"\n\nstatic int sysfs_initialized;\t \n\n \n#define pci_config_attr(field, format_string)\t\t\t\t\\\nstatic ssize_t\t\t\t\t\t\t\t\t\\\nfield##_show(struct device *dev, struct device_attribute *attr, char *buf)\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct pci_dev *pdev;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tpdev = to_pci_dev(dev);\t\t\t\t\t\t\\\n\treturn sysfs_emit(buf, format_string, pdev->field);\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic DEVICE_ATTR_RO(field)\n\npci_config_attr(vendor, \"0x%04x\\n\");\npci_config_attr(device, \"0x%04x\\n\");\npci_config_attr(subsystem_vendor, \"0x%04x\\n\");\npci_config_attr(subsystem_device, \"0x%04x\\n\");\npci_config_attr(revision, \"0x%02x\\n\");\npci_config_attr(class, \"0x%06x\\n\");\n\nstatic ssize_t irq_show(struct device *dev,\n\t\t\tstruct device_attribute *attr,\n\t\t\tchar *buf)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\n#ifdef CONFIG_PCI_MSI\n\t \n\tif (pdev->msi_enabled)\n\t\treturn sysfs_emit(buf, \"%u\\n\", pci_irq_vector(pdev, 0));\n#endif\n\n\treturn sysfs_emit(buf, \"%u\\n\", pdev->irq);\n}\nstatic DEVICE_ATTR_RO(irq);\n\nstatic ssize_t broken_parity_status_show(struct device *dev,\n\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t char *buf)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\treturn sysfs_emit(buf, \"%u\\n\", pdev->broken_parity_status);\n}\n\nstatic ssize_t broken_parity_status_store(struct device *dev,\n\t\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t\t  const char *buf, size_t count)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tunsigned long val;\n\n\tif (kstrtoul(buf, 0, &val) < 0)\n\t\treturn -EINVAL;\n\n\tpdev->broken_parity_status = !!val;\n\n\treturn count;\n}\nstatic DEVICE_ATTR_RW(broken_parity_status);\n\nstatic ssize_t pci_dev_show_local_cpu(struct device *dev, bool list,\n\t\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tconst struct cpumask *mask;\n\n#ifdef CONFIG_NUMA\n\tif (dev_to_node(dev) == NUMA_NO_NODE)\n\t\tmask = cpu_online_mask;\n\telse\n\t\tmask = cpumask_of_node(dev_to_node(dev));\n#else\n\tmask = cpumask_of_pcibus(to_pci_dev(dev)->bus);\n#endif\n\treturn cpumap_print_to_pagebuf(list, buf, mask);\n}\n\nstatic ssize_t local_cpus_show(struct device *dev,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\treturn pci_dev_show_local_cpu(dev, false, attr, buf);\n}\nstatic DEVICE_ATTR_RO(local_cpus);\n\nstatic ssize_t local_cpulist_show(struct device *dev,\n\t\t\t\t  struct device_attribute *attr, char *buf)\n{\n\treturn pci_dev_show_local_cpu(dev, true, attr, buf);\n}\nstatic DEVICE_ATTR_RO(local_cpulist);\n\n \nstatic ssize_t cpuaffinity_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tconst struct cpumask *cpumask = cpumask_of_pcibus(to_pci_bus(dev));\n\n\treturn cpumap_print_to_pagebuf(false, buf, cpumask);\n}\nstatic DEVICE_ATTR_RO(cpuaffinity);\n\nstatic ssize_t cpulistaffinity_show(struct device *dev,\n\t\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tconst struct cpumask *cpumask = cpumask_of_pcibus(to_pci_bus(dev));\n\n\treturn cpumap_print_to_pagebuf(true, buf, cpumask);\n}\nstatic DEVICE_ATTR_RO(cpulistaffinity);\n\nstatic ssize_t power_state_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\n\treturn sysfs_emit(buf, \"%s\\n\", pci_power_name(pdev->current_state));\n}\nstatic DEVICE_ATTR_RO(power_state);\n\n \nstatic ssize_t resource_show(struct device *dev, struct device_attribute *attr,\n\t\t\t     char *buf)\n{\n\tstruct pci_dev *pci_dev = to_pci_dev(dev);\n\tint i;\n\tint max;\n\tresource_size_t start, end;\n\tsize_t len = 0;\n\n\tif (pci_dev->subordinate)\n\t\tmax = DEVICE_COUNT_RESOURCE;\n\telse\n\t\tmax = PCI_BRIDGE_RESOURCES;\n\n\tfor (i = 0; i < max; i++) {\n\t\tstruct resource *res =  &pci_dev->resource[i];\n\t\tpci_resource_to_user(pci_dev, i, res, &start, &end);\n\t\tlen += sysfs_emit_at(buf, len, \"0x%016llx 0x%016llx 0x%016llx\\n\",\n\t\t\t\t     (unsigned long long)start,\n\t\t\t\t     (unsigned long long)end,\n\t\t\t\t     (unsigned long long)res->flags);\n\t}\n\treturn len;\n}\nstatic DEVICE_ATTR_RO(resource);\n\nstatic ssize_t max_link_speed_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\n\treturn sysfs_emit(buf, \"%s\\n\",\n\t\t\t  pci_speed_string(pcie_get_speed_cap(pdev)));\n}\nstatic DEVICE_ATTR_RO(max_link_speed);\n\nstatic ssize_t max_link_width_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\n\treturn sysfs_emit(buf, \"%u\\n\", pcie_get_width_cap(pdev));\n}\nstatic DEVICE_ATTR_RO(max_link_width);\n\nstatic ssize_t current_link_speed_show(struct device *dev,\n\t\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tstruct pci_dev *pci_dev = to_pci_dev(dev);\n\tu16 linkstat;\n\tint err;\n\tenum pci_bus_speed speed;\n\n\terr = pcie_capability_read_word(pci_dev, PCI_EXP_LNKSTA, &linkstat);\n\tif (err)\n\t\treturn -EINVAL;\n\n\tspeed = pcie_link_speed[linkstat & PCI_EXP_LNKSTA_CLS];\n\n\treturn sysfs_emit(buf, \"%s\\n\", pci_speed_string(speed));\n}\nstatic DEVICE_ATTR_RO(current_link_speed);\n\nstatic ssize_t current_link_width_show(struct device *dev,\n\t\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tstruct pci_dev *pci_dev = to_pci_dev(dev);\n\tu16 linkstat;\n\tint err;\n\n\terr = pcie_capability_read_word(pci_dev, PCI_EXP_LNKSTA, &linkstat);\n\tif (err)\n\t\treturn -EINVAL;\n\n\treturn sysfs_emit(buf, \"%u\\n\", FIELD_GET(PCI_EXP_LNKSTA_NLW, linkstat));\n}\nstatic DEVICE_ATTR_RO(current_link_width);\n\nstatic ssize_t secondary_bus_number_show(struct device *dev,\n\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t char *buf)\n{\n\tstruct pci_dev *pci_dev = to_pci_dev(dev);\n\tu8 sec_bus;\n\tint err;\n\n\terr = pci_read_config_byte(pci_dev, PCI_SECONDARY_BUS, &sec_bus);\n\tif (err)\n\t\treturn -EINVAL;\n\n\treturn sysfs_emit(buf, \"%u\\n\", sec_bus);\n}\nstatic DEVICE_ATTR_RO(secondary_bus_number);\n\nstatic ssize_t subordinate_bus_number_show(struct device *dev,\n\t\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t\t   char *buf)\n{\n\tstruct pci_dev *pci_dev = to_pci_dev(dev);\n\tu8 sub_bus;\n\tint err;\n\n\terr = pci_read_config_byte(pci_dev, PCI_SUBORDINATE_BUS, &sub_bus);\n\tif (err)\n\t\treturn -EINVAL;\n\n\treturn sysfs_emit(buf, \"%u\\n\", sub_bus);\n}\nstatic DEVICE_ATTR_RO(subordinate_bus_number);\n\nstatic ssize_t ari_enabled_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\tstruct pci_dev *pci_dev = to_pci_dev(dev);\n\n\treturn sysfs_emit(buf, \"%u\\n\", pci_ari_enabled(pci_dev->bus));\n}\nstatic DEVICE_ATTR_RO(ari_enabled);\n\nstatic ssize_t modalias_show(struct device *dev, struct device_attribute *attr,\n\t\t\t     char *buf)\n{\n\tstruct pci_dev *pci_dev = to_pci_dev(dev);\n\n\treturn sysfs_emit(buf, \"pci:v%08Xd%08Xsv%08Xsd%08Xbc%02Xsc%02Xi%02X\\n\",\n\t\t\t  pci_dev->vendor, pci_dev->device,\n\t\t\t  pci_dev->subsystem_vendor, pci_dev->subsystem_device,\n\t\t\t  (u8)(pci_dev->class >> 16), (u8)(pci_dev->class >> 8),\n\t\t\t  (u8)(pci_dev->class));\n}\nstatic DEVICE_ATTR_RO(modalias);\n\nstatic ssize_t enable_store(struct device *dev, struct device_attribute *attr,\n\t\t\t     const char *buf, size_t count)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tunsigned long val;\n\tssize_t result = 0;\n\n\t \n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (kstrtoul(buf, 0, &val) < 0)\n\t\treturn -EINVAL;\n\n\tdevice_lock(dev);\n\tif (dev->driver)\n\t\tresult = -EBUSY;\n\telse if (val)\n\t\tresult = pci_enable_device(pdev);\n\telse if (pci_is_enabled(pdev))\n\t\tpci_disable_device(pdev);\n\telse\n\t\tresult = -EIO;\n\tdevice_unlock(dev);\n\n\treturn result < 0 ? result : count;\n}\n\nstatic ssize_t enable_show(struct device *dev, struct device_attribute *attr,\n\t\t\t    char *buf)\n{\n\tstruct pci_dev *pdev;\n\n\tpdev = to_pci_dev(dev);\n\treturn sysfs_emit(buf, \"%u\\n\", atomic_read(&pdev->enable_cnt));\n}\nstatic DEVICE_ATTR_RW(enable);\n\n#ifdef CONFIG_NUMA\nstatic ssize_t numa_node_store(struct device *dev,\n\t\t\t       struct device_attribute *attr, const char *buf,\n\t\t\t       size_t count)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tint node;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (kstrtoint(buf, 0, &node) < 0)\n\t\treturn -EINVAL;\n\n\tif ((node < 0 && node != NUMA_NO_NODE) || node >= MAX_NUMNODES)\n\t\treturn -EINVAL;\n\n\tif (node != NUMA_NO_NODE && !node_online(node))\n\t\treturn -EINVAL;\n\n\tadd_taint(TAINT_FIRMWARE_WORKAROUND, LOCKDEP_STILL_OK);\n\tpci_alert(pdev, FW_BUG \"Overriding NUMA node to %d.  Contact your vendor for updates.\",\n\t\t  node);\n\n\tdev->numa_node = node;\n\treturn count;\n}\n\nstatic ssize_t numa_node_show(struct device *dev, struct device_attribute *attr,\n\t\t\t      char *buf)\n{\n\treturn sysfs_emit(buf, \"%d\\n\", dev->numa_node);\n}\nstatic DEVICE_ATTR_RW(numa_node);\n#endif\n\nstatic ssize_t dma_mask_bits_show(struct device *dev,\n\t\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\n\treturn sysfs_emit(buf, \"%d\\n\", fls64(pdev->dma_mask));\n}\nstatic DEVICE_ATTR_RO(dma_mask_bits);\n\nstatic ssize_t consistent_dma_mask_bits_show(struct device *dev,\n\t\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t\t     char *buf)\n{\n\treturn sysfs_emit(buf, \"%d\\n\", fls64(dev->coherent_dma_mask));\n}\nstatic DEVICE_ATTR_RO(consistent_dma_mask_bits);\n\nstatic ssize_t msi_bus_show(struct device *dev, struct device_attribute *attr,\n\t\t\t    char *buf)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tstruct pci_bus *subordinate = pdev->subordinate;\n\n\treturn sysfs_emit(buf, \"%u\\n\", subordinate ?\n\t\t\t  !(subordinate->bus_flags & PCI_BUS_FLAGS_NO_MSI)\n\t\t\t    : !pdev->no_msi);\n}\n\nstatic ssize_t msi_bus_store(struct device *dev, struct device_attribute *attr,\n\t\t\t     const char *buf, size_t count)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tstruct pci_bus *subordinate = pdev->subordinate;\n\tunsigned long val;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (kstrtoul(buf, 0, &val) < 0)\n\t\treturn -EINVAL;\n\n\t \n\tif (!subordinate) {\n\t\tpdev->no_msi = !val;\n\t\tpci_info(pdev, \"MSI/MSI-X %s for future drivers\\n\",\n\t\t\t val ? \"allowed\" : \"disallowed\");\n\t\treturn count;\n\t}\n\n\tif (val)\n\t\tsubordinate->bus_flags &= ~PCI_BUS_FLAGS_NO_MSI;\n\telse\n\t\tsubordinate->bus_flags |= PCI_BUS_FLAGS_NO_MSI;\n\n\tdev_info(&subordinate->dev, \"MSI/MSI-X %s for future drivers of devices on this bus\\n\",\n\t\t val ? \"allowed\" : \"disallowed\");\n\treturn count;\n}\nstatic DEVICE_ATTR_RW(msi_bus);\n\nstatic ssize_t rescan_store(const struct bus_type *bus, const char *buf, size_t count)\n{\n\tunsigned long val;\n\tstruct pci_bus *b = NULL;\n\n\tif (kstrtoul(buf, 0, &val) < 0)\n\t\treturn -EINVAL;\n\n\tif (val) {\n\t\tpci_lock_rescan_remove();\n\t\twhile ((b = pci_find_next_bus(b)) != NULL)\n\t\t\tpci_rescan_bus(b);\n\t\tpci_unlock_rescan_remove();\n\t}\n\treturn count;\n}\nstatic BUS_ATTR_WO(rescan);\n\nstatic struct attribute *pci_bus_attrs[] = {\n\t&bus_attr_rescan.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group pci_bus_group = {\n\t.attrs = pci_bus_attrs,\n};\n\nconst struct attribute_group *pci_bus_groups[] = {\n\t&pci_bus_group,\n\tNULL,\n};\n\nstatic ssize_t dev_rescan_store(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, const char *buf,\n\t\t\t\tsize_t count)\n{\n\tunsigned long val;\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\n\tif (kstrtoul(buf, 0, &val) < 0)\n\t\treturn -EINVAL;\n\n\tif (val) {\n\t\tpci_lock_rescan_remove();\n\t\tpci_rescan_bus(pdev->bus);\n\t\tpci_unlock_rescan_remove();\n\t}\n\treturn count;\n}\nstatic struct device_attribute dev_attr_dev_rescan = __ATTR(rescan, 0200, NULL,\n\t\t\t\t\t\t\t    dev_rescan_store);\n\nstatic ssize_t remove_store(struct device *dev, struct device_attribute *attr,\n\t\t\t    const char *buf, size_t count)\n{\n\tunsigned long val;\n\n\tif (kstrtoul(buf, 0, &val) < 0)\n\t\treturn -EINVAL;\n\n\tif (val && device_remove_file_self(dev, attr))\n\t\tpci_stop_and_remove_bus_device_locked(to_pci_dev(dev));\n\treturn count;\n}\nstatic DEVICE_ATTR_IGNORE_LOCKDEP(remove, 0220, NULL,\n\t\t\t\t  remove_store);\n\nstatic ssize_t bus_rescan_store(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tconst char *buf, size_t count)\n{\n\tunsigned long val;\n\tstruct pci_bus *bus = to_pci_bus(dev);\n\n\tif (kstrtoul(buf, 0, &val) < 0)\n\t\treturn -EINVAL;\n\n\tif (val) {\n\t\tpci_lock_rescan_remove();\n\t\tif (!pci_is_root_bus(bus) && list_empty(&bus->devices))\n\t\t\tpci_rescan_bus_bridge_resize(bus->self);\n\t\telse\n\t\t\tpci_rescan_bus(bus);\n\t\tpci_unlock_rescan_remove();\n\t}\n\treturn count;\n}\nstatic struct device_attribute dev_attr_bus_rescan = __ATTR(rescan, 0200, NULL,\n\t\t\t\t\t\t\t    bus_rescan_store);\n\n#if defined(CONFIG_PM) && defined(CONFIG_ACPI)\nstatic ssize_t d3cold_allowed_store(struct device *dev,\n\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t    const char *buf, size_t count)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tunsigned long val;\n\n\tif (kstrtoul(buf, 0, &val) < 0)\n\t\treturn -EINVAL;\n\n\tpdev->d3cold_allowed = !!val;\n\tpci_bridge_d3_update(pdev);\n\n\tpm_runtime_resume(dev);\n\n\treturn count;\n}\n\nstatic ssize_t d3cold_allowed_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\treturn sysfs_emit(buf, \"%u\\n\", pdev->d3cold_allowed);\n}\nstatic DEVICE_ATTR_RW(d3cold_allowed);\n#endif\n\n#ifdef CONFIG_OF\nstatic ssize_t devspec_show(struct device *dev,\n\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tstruct device_node *np = pci_device_to_OF_node(pdev);\n\n\tif (np == NULL)\n\t\treturn 0;\n\treturn sysfs_emit(buf, \"%pOF\\n\", np);\n}\nstatic DEVICE_ATTR_RO(devspec);\n#endif\n\nstatic ssize_t driver_override_store(struct device *dev,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     const char *buf, size_t count)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tint ret;\n\n\tret = driver_set_override(dev, &pdev->driver_override, buf, count);\n\tif (ret)\n\t\treturn ret;\n\n\treturn count;\n}\n\nstatic ssize_t driver_override_show(struct device *dev,\n\t\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tssize_t len;\n\n\tdevice_lock(dev);\n\tlen = sysfs_emit(buf, \"%s\\n\", pdev->driver_override);\n\tdevice_unlock(dev);\n\treturn len;\n}\nstatic DEVICE_ATTR_RW(driver_override);\n\nstatic struct attribute *pci_dev_attrs[] = {\n\t&dev_attr_power_state.attr,\n\t&dev_attr_resource.attr,\n\t&dev_attr_vendor.attr,\n\t&dev_attr_device.attr,\n\t&dev_attr_subsystem_vendor.attr,\n\t&dev_attr_subsystem_device.attr,\n\t&dev_attr_revision.attr,\n\t&dev_attr_class.attr,\n\t&dev_attr_irq.attr,\n\t&dev_attr_local_cpus.attr,\n\t&dev_attr_local_cpulist.attr,\n\t&dev_attr_modalias.attr,\n#ifdef CONFIG_NUMA\n\t&dev_attr_numa_node.attr,\n#endif\n\t&dev_attr_dma_mask_bits.attr,\n\t&dev_attr_consistent_dma_mask_bits.attr,\n\t&dev_attr_enable.attr,\n\t&dev_attr_broken_parity_status.attr,\n\t&dev_attr_msi_bus.attr,\n#if defined(CONFIG_PM) && defined(CONFIG_ACPI)\n\t&dev_attr_d3cold_allowed.attr,\n#endif\n#ifdef CONFIG_OF\n\t&dev_attr_devspec.attr,\n#endif\n\t&dev_attr_driver_override.attr,\n\t&dev_attr_ari_enabled.attr,\n\tNULL,\n};\n\nstatic struct attribute *pci_bridge_attrs[] = {\n\t&dev_attr_subordinate_bus_number.attr,\n\t&dev_attr_secondary_bus_number.attr,\n\tNULL,\n};\n\nstatic struct attribute *pcie_dev_attrs[] = {\n\t&dev_attr_current_link_speed.attr,\n\t&dev_attr_current_link_width.attr,\n\t&dev_attr_max_link_width.attr,\n\t&dev_attr_max_link_speed.attr,\n\tNULL,\n};\n\nstatic struct attribute *pcibus_attrs[] = {\n\t&dev_attr_bus_rescan.attr,\n\t&dev_attr_cpuaffinity.attr,\n\t&dev_attr_cpulistaffinity.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group pcibus_group = {\n\t.attrs = pcibus_attrs,\n};\n\nconst struct attribute_group *pcibus_groups[] = {\n\t&pcibus_group,\n\tNULL,\n};\n\nstatic ssize_t boot_vga_show(struct device *dev, struct device_attribute *attr,\n\t\t\t     char *buf)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tstruct pci_dev *vga_dev = vga_default_device();\n\n\tif (vga_dev)\n\t\treturn sysfs_emit(buf, \"%u\\n\", (pdev == vga_dev));\n\n\treturn sysfs_emit(buf, \"%u\\n\",\n\t\t\t  !!(pdev->resource[PCI_ROM_RESOURCE].flags &\n\t\t\t     IORESOURCE_ROM_SHADOW));\n}\nstatic DEVICE_ATTR_RO(boot_vga);\n\nstatic ssize_t pci_read_config(struct file *filp, struct kobject *kobj,\n\t\t\t       struct bin_attribute *bin_attr, char *buf,\n\t\t\t       loff_t off, size_t count)\n{\n\tstruct pci_dev *dev = to_pci_dev(kobj_to_dev(kobj));\n\tunsigned int size = 64;\n\tloff_t init_off = off;\n\tu8 *data = (u8 *) buf;\n\n\t \n\tif (file_ns_capable(filp, &init_user_ns, CAP_SYS_ADMIN))\n\t\tsize = dev->cfg_size;\n\telse if (dev->hdr_type == PCI_HEADER_TYPE_CARDBUS)\n\t\tsize = 128;\n\n\tif (off > size)\n\t\treturn 0;\n\tif (off + count > size) {\n\t\tsize -= off;\n\t\tcount = size;\n\t} else {\n\t\tsize = count;\n\t}\n\n\tpci_config_pm_runtime_get(dev);\n\n\tif ((off & 1) && size) {\n\t\tu8 val;\n\t\tpci_user_read_config_byte(dev, off, &val);\n\t\tdata[off - init_off] = val;\n\t\toff++;\n\t\tsize--;\n\t}\n\n\tif ((off & 3) && size > 2) {\n\t\tu16 val;\n\t\tpci_user_read_config_word(dev, off, &val);\n\t\tdata[off - init_off] = val & 0xff;\n\t\tdata[off - init_off + 1] = (val >> 8) & 0xff;\n\t\toff += 2;\n\t\tsize -= 2;\n\t}\n\n\twhile (size > 3) {\n\t\tu32 val;\n\t\tpci_user_read_config_dword(dev, off, &val);\n\t\tdata[off - init_off] = val & 0xff;\n\t\tdata[off - init_off + 1] = (val >> 8) & 0xff;\n\t\tdata[off - init_off + 2] = (val >> 16) & 0xff;\n\t\tdata[off - init_off + 3] = (val >> 24) & 0xff;\n\t\toff += 4;\n\t\tsize -= 4;\n\t\tcond_resched();\n\t}\n\n\tif (size >= 2) {\n\t\tu16 val;\n\t\tpci_user_read_config_word(dev, off, &val);\n\t\tdata[off - init_off] = val & 0xff;\n\t\tdata[off - init_off + 1] = (val >> 8) & 0xff;\n\t\toff += 2;\n\t\tsize -= 2;\n\t}\n\n\tif (size > 0) {\n\t\tu8 val;\n\t\tpci_user_read_config_byte(dev, off, &val);\n\t\tdata[off - init_off] = val;\n\t}\n\n\tpci_config_pm_runtime_put(dev);\n\n\treturn count;\n}\n\nstatic ssize_t pci_write_config(struct file *filp, struct kobject *kobj,\n\t\t\t\tstruct bin_attribute *bin_attr, char *buf,\n\t\t\t\tloff_t off, size_t count)\n{\n\tstruct pci_dev *dev = to_pci_dev(kobj_to_dev(kobj));\n\tunsigned int size = count;\n\tloff_t init_off = off;\n\tu8 *data = (u8 *) buf;\n\tint ret;\n\n\tret = security_locked_down(LOCKDOWN_PCI_ACCESS);\n\tif (ret)\n\t\treturn ret;\n\n\tif (resource_is_exclusive(&dev->driver_exclusive_resource, off,\n\t\t\t\t  count)) {\n\t\tpci_warn_once(dev, \"%s: Unexpected write to kernel-exclusive config offset %llx\",\n\t\t\t      current->comm, off);\n\t\tadd_taint(TAINT_USER, LOCKDEP_STILL_OK);\n\t}\n\n\tif (off > dev->cfg_size)\n\t\treturn 0;\n\tif (off + count > dev->cfg_size) {\n\t\tsize = dev->cfg_size - off;\n\t\tcount = size;\n\t}\n\n\tpci_config_pm_runtime_get(dev);\n\n\tif ((off & 1) && size) {\n\t\tpci_user_write_config_byte(dev, off, data[off - init_off]);\n\t\toff++;\n\t\tsize--;\n\t}\n\n\tif ((off & 3) && size > 2) {\n\t\tu16 val = data[off - init_off];\n\t\tval |= (u16) data[off - init_off + 1] << 8;\n\t\tpci_user_write_config_word(dev, off, val);\n\t\toff += 2;\n\t\tsize -= 2;\n\t}\n\n\twhile (size > 3) {\n\t\tu32 val = data[off - init_off];\n\t\tval |= (u32) data[off - init_off + 1] << 8;\n\t\tval |= (u32) data[off - init_off + 2] << 16;\n\t\tval |= (u32) data[off - init_off + 3] << 24;\n\t\tpci_user_write_config_dword(dev, off, val);\n\t\toff += 4;\n\t\tsize -= 4;\n\t}\n\n\tif (size >= 2) {\n\t\tu16 val = data[off - init_off];\n\t\tval |= (u16) data[off - init_off + 1] << 8;\n\t\tpci_user_write_config_word(dev, off, val);\n\t\toff += 2;\n\t\tsize -= 2;\n\t}\n\n\tif (size)\n\t\tpci_user_write_config_byte(dev, off, data[off - init_off]);\n\n\tpci_config_pm_runtime_put(dev);\n\n\treturn count;\n}\nstatic BIN_ATTR(config, 0644, pci_read_config, pci_write_config, 0);\n\nstatic struct bin_attribute *pci_dev_config_attrs[] = {\n\t&bin_attr_config,\n\tNULL,\n};\n\nstatic umode_t pci_dev_config_attr_is_visible(struct kobject *kobj,\n\t\t\t\t\t      struct bin_attribute *a, int n)\n{\n\tstruct pci_dev *pdev = to_pci_dev(kobj_to_dev(kobj));\n\n\ta->size = PCI_CFG_SPACE_SIZE;\n\tif (pdev->cfg_size > PCI_CFG_SPACE_SIZE)\n\t\ta->size = PCI_CFG_SPACE_EXP_SIZE;\n\n\treturn a->attr.mode;\n}\n\nstatic const struct attribute_group pci_dev_config_attr_group = {\n\t.bin_attrs = pci_dev_config_attrs,\n\t.is_bin_visible = pci_dev_config_attr_is_visible,\n};\n\n#ifdef HAVE_PCI_LEGACY\n \nstatic ssize_t pci_read_legacy_io(struct file *filp, struct kobject *kobj,\n\t\t\t\t  struct bin_attribute *bin_attr, char *buf,\n\t\t\t\t  loff_t off, size_t count)\n{\n\tstruct pci_bus *bus = to_pci_bus(kobj_to_dev(kobj));\n\n\t \n\tif (count != 1 && count != 2 && count != 4)\n\t\treturn -EINVAL;\n\n\treturn pci_legacy_read(bus, off, (u32 *)buf, count);\n}\n\n \nstatic ssize_t pci_write_legacy_io(struct file *filp, struct kobject *kobj,\n\t\t\t\t   struct bin_attribute *bin_attr, char *buf,\n\t\t\t\t   loff_t off, size_t count)\n{\n\tstruct pci_bus *bus = to_pci_bus(kobj_to_dev(kobj));\n\n\t \n\tif (count != 1 && count != 2 && count != 4)\n\t\treturn -EINVAL;\n\n\treturn pci_legacy_write(bus, off, *(u32 *)buf, count);\n}\n\n \nstatic int pci_mmap_legacy_mem(struct file *filp, struct kobject *kobj,\n\t\t\t       struct bin_attribute *attr,\n\t\t\t       struct vm_area_struct *vma)\n{\n\tstruct pci_bus *bus = to_pci_bus(kobj_to_dev(kobj));\n\n\treturn pci_mmap_legacy_page_range(bus, vma, pci_mmap_mem);\n}\n\n \nstatic int pci_mmap_legacy_io(struct file *filp, struct kobject *kobj,\n\t\t\t      struct bin_attribute *attr,\n\t\t\t      struct vm_area_struct *vma)\n{\n\tstruct pci_bus *bus = to_pci_bus(kobj_to_dev(kobj));\n\n\treturn pci_mmap_legacy_page_range(bus, vma, pci_mmap_io);\n}\n\n \nvoid __weak pci_adjust_legacy_attr(struct pci_bus *b,\n\t\t\t\t   enum pci_mmap_state mmap_type)\n{\n}\n\n \nvoid pci_create_legacy_files(struct pci_bus *b)\n{\n\tint error;\n\n\tif (!sysfs_initialized)\n\t\treturn;\n\n\tb->legacy_io = kcalloc(2, sizeof(struct bin_attribute),\n\t\t\t       GFP_ATOMIC);\n\tif (!b->legacy_io)\n\t\tgoto kzalloc_err;\n\n\tsysfs_bin_attr_init(b->legacy_io);\n\tb->legacy_io->attr.name = \"legacy_io\";\n\tb->legacy_io->size = 0xffff;\n\tb->legacy_io->attr.mode = 0600;\n\tb->legacy_io->read = pci_read_legacy_io;\n\tb->legacy_io->write = pci_write_legacy_io;\n\tb->legacy_io->mmap = pci_mmap_legacy_io;\n\tb->legacy_io->f_mapping = iomem_get_mapping;\n\tpci_adjust_legacy_attr(b, pci_mmap_io);\n\terror = device_create_bin_file(&b->dev, b->legacy_io);\n\tif (error)\n\t\tgoto legacy_io_err;\n\n\t \n\tb->legacy_mem = b->legacy_io + 1;\n\tsysfs_bin_attr_init(b->legacy_mem);\n\tb->legacy_mem->attr.name = \"legacy_mem\";\n\tb->legacy_mem->size = 1024*1024;\n\tb->legacy_mem->attr.mode = 0600;\n\tb->legacy_mem->mmap = pci_mmap_legacy_mem;\n\tb->legacy_mem->f_mapping = iomem_get_mapping;\n\tpci_adjust_legacy_attr(b, pci_mmap_mem);\n\terror = device_create_bin_file(&b->dev, b->legacy_mem);\n\tif (error)\n\t\tgoto legacy_mem_err;\n\n\treturn;\n\nlegacy_mem_err:\n\tdevice_remove_bin_file(&b->dev, b->legacy_io);\nlegacy_io_err:\n\tkfree(b->legacy_io);\n\tb->legacy_io = NULL;\nkzalloc_err:\n\tdev_warn(&b->dev, \"could not create legacy I/O port and ISA memory resources in sysfs\\n\");\n}\n\nvoid pci_remove_legacy_files(struct pci_bus *b)\n{\n\tif (b->legacy_io) {\n\t\tdevice_remove_bin_file(&b->dev, b->legacy_io);\n\t\tdevice_remove_bin_file(&b->dev, b->legacy_mem);\n\t\tkfree(b->legacy_io);  \n\t}\n}\n#endif  \n\n#if defined(HAVE_PCI_MMAP) || defined(ARCH_GENERIC_PCI_MMAP_RESOURCE)\n\nint pci_mmap_fits(struct pci_dev *pdev, int resno, struct vm_area_struct *vma,\n\t\t  enum pci_mmap_api mmap_api)\n{\n\tunsigned long nr, start, size;\n\tresource_size_t pci_start = 0, pci_end;\n\n\tif (pci_resource_len(pdev, resno) == 0)\n\t\treturn 0;\n\tnr = vma_pages(vma);\n\tstart = vma->vm_pgoff;\n\tsize = ((pci_resource_len(pdev, resno) - 1) >> PAGE_SHIFT) + 1;\n\tif (mmap_api == PCI_MMAP_PROCFS) {\n\t\tpci_resource_to_user(pdev, resno, &pdev->resource[resno],\n\t\t\t\t     &pci_start, &pci_end);\n\t\tpci_start >>= PAGE_SHIFT;\n\t}\n\tif (start >= pci_start && start < pci_start + size &&\n\t\t\tstart + nr <= pci_start + size)\n\t\treturn 1;\n\treturn 0;\n}\n\n \nstatic int pci_mmap_resource(struct kobject *kobj, struct bin_attribute *attr,\n\t\t\t     struct vm_area_struct *vma, int write_combine)\n{\n\tstruct pci_dev *pdev = to_pci_dev(kobj_to_dev(kobj));\n\tint bar = (unsigned long)attr->private;\n\tenum pci_mmap_state mmap_type;\n\tstruct resource *res = &pdev->resource[bar];\n\tint ret;\n\n\tret = security_locked_down(LOCKDOWN_PCI_ACCESS);\n\tif (ret)\n\t\treturn ret;\n\n\tif (res->flags & IORESOURCE_MEM && iomem_is_exclusive(res->start))\n\t\treturn -EINVAL;\n\n\tif (!pci_mmap_fits(pdev, bar, vma, PCI_MMAP_SYSFS))\n\t\treturn -EINVAL;\n\n\tmmap_type = res->flags & IORESOURCE_MEM ? pci_mmap_mem : pci_mmap_io;\n\n\treturn pci_mmap_resource_range(pdev, bar, vma, mmap_type, write_combine);\n}\n\nstatic int pci_mmap_resource_uc(struct file *filp, struct kobject *kobj,\n\t\t\t\tstruct bin_attribute *attr,\n\t\t\t\tstruct vm_area_struct *vma)\n{\n\treturn pci_mmap_resource(kobj, attr, vma, 0);\n}\n\nstatic int pci_mmap_resource_wc(struct file *filp, struct kobject *kobj,\n\t\t\t\tstruct bin_attribute *attr,\n\t\t\t\tstruct vm_area_struct *vma)\n{\n\treturn pci_mmap_resource(kobj, attr, vma, 1);\n}\n\nstatic ssize_t pci_resource_io(struct file *filp, struct kobject *kobj,\n\t\t\t       struct bin_attribute *attr, char *buf,\n\t\t\t       loff_t off, size_t count, bool write)\n{\n#ifdef CONFIG_HAS_IOPORT\n\tstruct pci_dev *pdev = to_pci_dev(kobj_to_dev(kobj));\n\tint bar = (unsigned long)attr->private;\n\tunsigned long port = off;\n\n\tport += pci_resource_start(pdev, bar);\n\n\tif (port > pci_resource_end(pdev, bar))\n\t\treturn 0;\n\n\tif (port + count - 1 > pci_resource_end(pdev, bar))\n\t\treturn -EINVAL;\n\n\tswitch (count) {\n\tcase 1:\n\t\tif (write)\n\t\t\toutb(*(u8 *)buf, port);\n\t\telse\n\t\t\t*(u8 *)buf = inb(port);\n\t\treturn 1;\n\tcase 2:\n\t\tif (write)\n\t\t\toutw(*(u16 *)buf, port);\n\t\telse\n\t\t\t*(u16 *)buf = inw(port);\n\t\treturn 2;\n\tcase 4:\n\t\tif (write)\n\t\t\toutl(*(u32 *)buf, port);\n\t\telse\n\t\t\t*(u32 *)buf = inl(port);\n\t\treturn 4;\n\t}\n\treturn -EINVAL;\n#else\n\treturn -ENXIO;\n#endif\n}\n\nstatic ssize_t pci_read_resource_io(struct file *filp, struct kobject *kobj,\n\t\t\t\t    struct bin_attribute *attr, char *buf,\n\t\t\t\t    loff_t off, size_t count)\n{\n\treturn pci_resource_io(filp, kobj, attr, buf, off, count, false);\n}\n\nstatic ssize_t pci_write_resource_io(struct file *filp, struct kobject *kobj,\n\t\t\t\t     struct bin_attribute *attr, char *buf,\n\t\t\t\t     loff_t off, size_t count)\n{\n\tint ret;\n\n\tret = security_locked_down(LOCKDOWN_PCI_ACCESS);\n\tif (ret)\n\t\treturn ret;\n\n\treturn pci_resource_io(filp, kobj, attr, buf, off, count, true);\n}\n\n \nstatic void pci_remove_resource_files(struct pci_dev *pdev)\n{\n\tint i;\n\n\tfor (i = 0; i < PCI_STD_NUM_BARS; i++) {\n\t\tstruct bin_attribute *res_attr;\n\n\t\tres_attr = pdev->res_attr[i];\n\t\tif (res_attr) {\n\t\t\tsysfs_remove_bin_file(&pdev->dev.kobj, res_attr);\n\t\t\tkfree(res_attr);\n\t\t}\n\n\t\tres_attr = pdev->res_attr_wc[i];\n\t\tif (res_attr) {\n\t\t\tsysfs_remove_bin_file(&pdev->dev.kobj, res_attr);\n\t\t\tkfree(res_attr);\n\t\t}\n\t}\n}\n\nstatic int pci_create_attr(struct pci_dev *pdev, int num, int write_combine)\n{\n\t \n\tint name_len = write_combine ? 13 : 10;\n\tstruct bin_attribute *res_attr;\n\tchar *res_attr_name;\n\tint retval;\n\n\tres_attr = kzalloc(sizeof(*res_attr) + name_len, GFP_ATOMIC);\n\tif (!res_attr)\n\t\treturn -ENOMEM;\n\n\tres_attr_name = (char *)(res_attr + 1);\n\n\tsysfs_bin_attr_init(res_attr);\n\tif (write_combine) {\n\t\tsprintf(res_attr_name, \"resource%d_wc\", num);\n\t\tres_attr->mmap = pci_mmap_resource_wc;\n\t} else {\n\t\tsprintf(res_attr_name, \"resource%d\", num);\n\t\tif (pci_resource_flags(pdev, num) & IORESOURCE_IO) {\n\t\t\tres_attr->read = pci_read_resource_io;\n\t\t\tres_attr->write = pci_write_resource_io;\n\t\t\tif (arch_can_pci_mmap_io())\n\t\t\t\tres_attr->mmap = pci_mmap_resource_uc;\n\t\t} else {\n\t\t\tres_attr->mmap = pci_mmap_resource_uc;\n\t\t}\n\t}\n\tif (res_attr->mmap)\n\t\tres_attr->f_mapping = iomem_get_mapping;\n\tres_attr->attr.name = res_attr_name;\n\tres_attr->attr.mode = 0600;\n\tres_attr->size = pci_resource_len(pdev, num);\n\tres_attr->private = (void *)(unsigned long)num;\n\tretval = sysfs_create_bin_file(&pdev->dev.kobj, res_attr);\n\tif (retval) {\n\t\tkfree(res_attr);\n\t\treturn retval;\n\t}\n\n\tif (write_combine)\n\t\tpdev->res_attr_wc[num] = res_attr;\n\telse\n\t\tpdev->res_attr[num] = res_attr;\n\n\treturn 0;\n}\n\n \nstatic int pci_create_resource_files(struct pci_dev *pdev)\n{\n\tint i;\n\tint retval;\n\n\t \n\tfor (i = 0; i < PCI_STD_NUM_BARS; i++) {\n\n\t\t \n\t\tif (!pci_resource_len(pdev, i))\n\t\t\tcontinue;\n\n\t\tretval = pci_create_attr(pdev, i, 0);\n\t\t \n\t\tif (!retval && arch_can_pci_mmap_wc() &&\n\t\t    pdev->resource[i].flags & IORESOURCE_PREFETCH)\n\t\t\tretval = pci_create_attr(pdev, i, 1);\n\t\tif (retval) {\n\t\t\tpci_remove_resource_files(pdev);\n\t\t\treturn retval;\n\t\t}\n\t}\n\treturn 0;\n}\n#else  \nint __weak pci_create_resource_files(struct pci_dev *dev) { return 0; }\nvoid __weak pci_remove_resource_files(struct pci_dev *dev) { return; }\n#endif\n\n \nstatic ssize_t pci_write_rom(struct file *filp, struct kobject *kobj,\n\t\t\t     struct bin_attribute *bin_attr, char *buf,\n\t\t\t     loff_t off, size_t count)\n{\n\tstruct pci_dev *pdev = to_pci_dev(kobj_to_dev(kobj));\n\n\tif ((off ==  0) && (*buf == '0') && (count == 2))\n\t\tpdev->rom_attr_enabled = 0;\n\telse\n\t\tpdev->rom_attr_enabled = 1;\n\n\treturn count;\n}\n\n \nstatic ssize_t pci_read_rom(struct file *filp, struct kobject *kobj,\n\t\t\t    struct bin_attribute *bin_attr, char *buf,\n\t\t\t    loff_t off, size_t count)\n{\n\tstruct pci_dev *pdev = to_pci_dev(kobj_to_dev(kobj));\n\tvoid __iomem *rom;\n\tsize_t size;\n\n\tif (!pdev->rom_attr_enabled)\n\t\treturn -EINVAL;\n\n\trom = pci_map_rom(pdev, &size);\t \n\tif (!rom || !size)\n\t\treturn -EIO;\n\n\tif (off >= size)\n\t\tcount = 0;\n\telse {\n\t\tif (off + count > size)\n\t\t\tcount = size - off;\n\n\t\tmemcpy_fromio(buf, rom + off, count);\n\t}\n\tpci_unmap_rom(pdev, rom);\n\n\treturn count;\n}\nstatic BIN_ATTR(rom, 0600, pci_read_rom, pci_write_rom, 0);\n\nstatic struct bin_attribute *pci_dev_rom_attrs[] = {\n\t&bin_attr_rom,\n\tNULL,\n};\n\nstatic umode_t pci_dev_rom_attr_is_visible(struct kobject *kobj,\n\t\t\t\t\t   struct bin_attribute *a, int n)\n{\n\tstruct pci_dev *pdev = to_pci_dev(kobj_to_dev(kobj));\n\tsize_t rom_size;\n\n\t \n\trom_size = pci_resource_len(pdev, PCI_ROM_RESOURCE);\n\tif (!rom_size)\n\t\treturn 0;\n\n\ta->size = rom_size;\n\n\treturn a->attr.mode;\n}\n\nstatic const struct attribute_group pci_dev_rom_attr_group = {\n\t.bin_attrs = pci_dev_rom_attrs,\n\t.is_bin_visible = pci_dev_rom_attr_is_visible,\n};\n\nstatic ssize_t reset_store(struct device *dev, struct device_attribute *attr,\n\t\t\t   const char *buf, size_t count)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tunsigned long val;\n\tssize_t result;\n\n\tif (kstrtoul(buf, 0, &val) < 0)\n\t\treturn -EINVAL;\n\n\tif (val != 1)\n\t\treturn -EINVAL;\n\n\tpm_runtime_get_sync(dev);\n\tresult = pci_reset_function(pdev);\n\tpm_runtime_put(dev);\n\tif (result < 0)\n\t\treturn result;\n\n\treturn count;\n}\nstatic DEVICE_ATTR_WO(reset);\n\nstatic struct attribute *pci_dev_reset_attrs[] = {\n\t&dev_attr_reset.attr,\n\tNULL,\n};\n\nstatic umode_t pci_dev_reset_attr_is_visible(struct kobject *kobj,\n\t\t\t\t\t     struct attribute *a, int n)\n{\n\tstruct pci_dev *pdev = to_pci_dev(kobj_to_dev(kobj));\n\n\tif (!pci_reset_supported(pdev))\n\t\treturn 0;\n\n\treturn a->mode;\n}\n\nstatic const struct attribute_group pci_dev_reset_attr_group = {\n\t.attrs = pci_dev_reset_attrs,\n\t.is_visible = pci_dev_reset_attr_is_visible,\n};\n\n#define pci_dev_resource_resize_attr(n)\t\t\t\t\t\\\nstatic ssize_t resource##n##_resize_show(struct device *dev,\t\t\\\n\t\t\t\t\t struct device_attribute *attr,\t\\\n\t\t\t\t\t char * buf)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct pci_dev *pdev = to_pci_dev(dev);\t\t\t\t\\\n\tssize_t ret;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tpci_config_pm_runtime_get(pdev);\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tret = sysfs_emit(buf, \"%016llx\\n\",\t\t\t\t\\\n\t\t\t (u64)pci_rebar_get_possible_sizes(pdev, n));\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tpci_config_pm_runtime_put(pdev);\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\treturn ret;\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nstatic ssize_t resource##n##_resize_store(struct device *dev,\t\t\\\n\t\t\t\t\t  struct device_attribute *attr,\\\n\t\t\t\t\t  const char *buf, size_t count)\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct pci_dev *pdev = to_pci_dev(dev);\t\t\t\t\\\n\tunsigned long size, flags;\t\t\t\t\t\\\n\tint ret, i;\t\t\t\t\t\t\t\\\n\tu16 cmd;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (kstrtoul(buf, 0, &size) < 0)\t\t\t\t\\\n\t\treturn -EINVAL;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tdevice_lock(dev);\t\t\t\t\t\t\\\n\tif (dev->driver) {\t\t\t\t\t\t\\\n\t\tret = -EBUSY;\t\t\t\t\t\t\\\n\t\tgoto unlock;\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tpci_config_pm_runtime_get(pdev);\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif ((pdev->class >> 8) == PCI_CLASS_DISPLAY_VGA) {\t\t\\\n\t\tret = aperture_remove_conflicting_pci_devices(pdev,\t\\\n\t\t\t\t\t\t\"resourceN_resize\");\t\\\n\t\tif (ret)\t\t\t\t\t\t\\\n\t\t\tgoto pm_put;\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tpci_read_config_word(pdev, PCI_COMMAND, &cmd);\t\t\t\\\n\tpci_write_config_word(pdev, PCI_COMMAND,\t\t\t\\\n\t\t\t      cmd & ~PCI_COMMAND_MEMORY);\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tflags = pci_resource_flags(pdev, n);\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tpci_remove_resource_files(pdev);\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tfor (i = 0; i < PCI_STD_NUM_BARS; i++) {\t\t\t\\\n\t\tif (pci_resource_len(pdev, i) &&\t\t\t\\\n\t\t    pci_resource_flags(pdev, i) == flags)\t\t\\\n\t\t\tpci_release_resource(pdev, i);\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tret = pci_resize_resource(pdev, n, size);\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tpci_assign_unassigned_bus_resources(pdev->bus);\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (pci_create_resource_files(pdev))\t\t\t\t\\\n\t\tpci_warn(pdev, \"Failed to recreate resource files after BAR resizing\\n\");\\\n\t\t\t\t\t\t\t\t\t\\\n\tpci_write_config_word(pdev, PCI_COMMAND, cmd);\t\t\t\\\npm_put:\t\t\t\t\t\t\t\t\t\\\n\tpci_config_pm_runtime_put(pdev);\t\t\t\t\\\nunlock:\t\t\t\t\t\t\t\t\t\\\n\tdevice_unlock(dev);\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\treturn ret ? ret : count;\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic DEVICE_ATTR_RW(resource##n##_resize)\n\npci_dev_resource_resize_attr(0);\npci_dev_resource_resize_attr(1);\npci_dev_resource_resize_attr(2);\npci_dev_resource_resize_attr(3);\npci_dev_resource_resize_attr(4);\npci_dev_resource_resize_attr(5);\n\nstatic struct attribute *resource_resize_attrs[] = {\n\t&dev_attr_resource0_resize.attr,\n\t&dev_attr_resource1_resize.attr,\n\t&dev_attr_resource2_resize.attr,\n\t&dev_attr_resource3_resize.attr,\n\t&dev_attr_resource4_resize.attr,\n\t&dev_attr_resource5_resize.attr,\n\tNULL,\n};\n\nstatic umode_t resource_resize_is_visible(struct kobject *kobj,\n\t\t\t\t\t  struct attribute *a, int n)\n{\n\tstruct pci_dev *pdev = to_pci_dev(kobj_to_dev(kobj));\n\n\treturn pci_rebar_get_current_size(pdev, n) < 0 ? 0 : a->mode;\n}\n\nstatic const struct attribute_group pci_dev_resource_resize_group = {\n\t.attrs = resource_resize_attrs,\n\t.is_visible = resource_resize_is_visible,\n};\n\nint __must_check pci_create_sysfs_dev_files(struct pci_dev *pdev)\n{\n\tif (!sysfs_initialized)\n\t\treturn -EACCES;\n\n\treturn pci_create_resource_files(pdev);\n}\n\n \nvoid pci_remove_sysfs_dev_files(struct pci_dev *pdev)\n{\n\tif (!sysfs_initialized)\n\t\treturn;\n\n\tpci_remove_resource_files(pdev);\n}\n\nstatic int __init pci_sysfs_init(void)\n{\n\tstruct pci_dev *pdev = NULL;\n\tstruct pci_bus *pbus = NULL;\n\tint retval;\n\n\tsysfs_initialized = 1;\n\tfor_each_pci_dev(pdev) {\n\t\tretval = pci_create_sysfs_dev_files(pdev);\n\t\tif (retval) {\n\t\t\tpci_dev_put(pdev);\n\t\t\treturn retval;\n\t\t}\n\t}\n\n\twhile ((pbus = pci_find_next_bus(pbus)))\n\t\tpci_create_legacy_files(pbus);\n\n\treturn 0;\n}\nlate_initcall(pci_sysfs_init);\n\nstatic struct attribute *pci_dev_dev_attrs[] = {\n\t&dev_attr_boot_vga.attr,\n\tNULL,\n};\n\nstatic umode_t pci_dev_attrs_are_visible(struct kobject *kobj,\n\t\t\t\t\t struct attribute *a, int n)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\n\tif (a == &dev_attr_boot_vga.attr)\n\t\tif ((pdev->class >> 8) != PCI_CLASS_DISPLAY_VGA)\n\t\t\treturn 0;\n\n\treturn a->mode;\n}\n\nstatic struct attribute *pci_dev_hp_attrs[] = {\n\t&dev_attr_remove.attr,\n\t&dev_attr_dev_rescan.attr,\n\tNULL,\n};\n\nstatic umode_t pci_dev_hp_attrs_are_visible(struct kobject *kobj,\n\t\t\t\t\t    struct attribute *a, int n)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\n\tif (pdev->is_virtfn)\n\t\treturn 0;\n\n\treturn a->mode;\n}\n\nstatic umode_t pci_bridge_attrs_are_visible(struct kobject *kobj,\n\t\t\t\t\t    struct attribute *a, int n)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\n\tif (pci_is_bridge(pdev))\n\t\treturn a->mode;\n\n\treturn 0;\n}\n\nstatic umode_t pcie_dev_attrs_are_visible(struct kobject *kobj,\n\t\t\t\t\t  struct attribute *a, int n)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\n\tif (pci_is_pcie(pdev))\n\t\treturn a->mode;\n\n\treturn 0;\n}\n\nstatic const struct attribute_group pci_dev_group = {\n\t.attrs = pci_dev_attrs,\n};\n\nconst struct attribute_group *pci_dev_groups[] = {\n\t&pci_dev_group,\n\t&pci_dev_config_attr_group,\n\t&pci_dev_rom_attr_group,\n\t&pci_dev_reset_attr_group,\n\t&pci_dev_reset_method_attr_group,\n\t&pci_dev_vpd_attr_group,\n#ifdef CONFIG_DMI\n\t&pci_dev_smbios_attr_group,\n#endif\n#ifdef CONFIG_ACPI\n\t&pci_dev_acpi_attr_group,\n#endif\n\t&pci_dev_resource_resize_group,\n\tNULL,\n};\n\nstatic const struct attribute_group pci_dev_hp_attr_group = {\n\t.attrs = pci_dev_hp_attrs,\n\t.is_visible = pci_dev_hp_attrs_are_visible,\n};\n\nstatic const struct attribute_group pci_dev_attr_group = {\n\t.attrs = pci_dev_dev_attrs,\n\t.is_visible = pci_dev_attrs_are_visible,\n};\n\nstatic const struct attribute_group pci_bridge_attr_group = {\n\t.attrs = pci_bridge_attrs,\n\t.is_visible = pci_bridge_attrs_are_visible,\n};\n\nstatic const struct attribute_group pcie_dev_attr_group = {\n\t.attrs = pcie_dev_attrs,\n\t.is_visible = pcie_dev_attrs_are_visible,\n};\n\nstatic const struct attribute_group *pci_dev_attr_groups[] = {\n\t&pci_dev_attr_group,\n\t&pci_dev_hp_attr_group,\n#ifdef CONFIG_PCI_IOV\n\t&sriov_pf_dev_attr_group,\n\t&sriov_vf_dev_attr_group,\n#endif\n\t&pci_bridge_attr_group,\n\t&pcie_dev_attr_group,\n#ifdef CONFIG_PCIEAER\n\t&aer_stats_attr_group,\n#endif\n#ifdef CONFIG_PCIEASPM\n\t&aspm_ctrl_attr_group,\n#endif\n\tNULL,\n};\n\nconst struct device_type pci_dev_type = {\n\t.groups = pci_dev_attr_groups,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}