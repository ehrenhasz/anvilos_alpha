{
  "module_name": "pcie-iproc.c",
  "hash_id": "ecb00b36d979f53ba7f85d419e1711746bb8fa0c28c5d54a27278dc6a89a78e9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/controller/pcie-iproc.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/pci.h>\n#include <linux/pci-ecam.h>\n#include <linux/msi.h>\n#include <linux/clk.h>\n#include <linux/module.h>\n#include <linux/mbus.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/irqchip/arm-gic-v3.h>\n#include <linux/platform_device.h>\n#include <linux/of_address.h>\n#include <linux/of_pci.h>\n#include <linux/of_platform.h>\n#include <linux/phy/phy.h>\n\n#include \"pcie-iproc.h\"\n\n#define EP_PERST_SOURCE_SELECT_SHIFT\t2\n#define EP_PERST_SOURCE_SELECT\t\tBIT(EP_PERST_SOURCE_SELECT_SHIFT)\n#define EP_MODE_SURVIVE_PERST_SHIFT\t1\n#define EP_MODE_SURVIVE_PERST\t\tBIT(EP_MODE_SURVIVE_PERST_SHIFT)\n#define RC_PCIE_RST_OUTPUT_SHIFT\t0\n#define RC_PCIE_RST_OUTPUT\t\tBIT(RC_PCIE_RST_OUTPUT_SHIFT)\n#define PAXC_RESET_MASK\t\t\t0x7f\n\n#define GIC_V3_CFG_SHIFT\t\t0\n#define GIC_V3_CFG\t\t\tBIT(GIC_V3_CFG_SHIFT)\n\n#define MSI_ENABLE_CFG_SHIFT\t\t0\n#define MSI_ENABLE_CFG\t\t\tBIT(MSI_ENABLE_CFG_SHIFT)\n\n#define CFG_IND_ADDR_MASK\t\t0x00001ffc\n\n#define CFG_ADDR_REG_NUM_MASK\t\t0x00000ffc\n#define CFG_ADDR_CFG_TYPE_1\t\t1\n\n#define SYS_RC_INTX_MASK\t\t0xf\n\n#define PCIE_PHYLINKUP_SHIFT\t\t3\n#define PCIE_PHYLINKUP\t\t\tBIT(PCIE_PHYLINKUP_SHIFT)\n#define PCIE_DL_ACTIVE_SHIFT\t\t2\n#define PCIE_DL_ACTIVE\t\t\tBIT(PCIE_DL_ACTIVE_SHIFT)\n\n#define APB_ERR_EN_SHIFT\t\t0\n#define APB_ERR_EN\t\t\tBIT(APB_ERR_EN_SHIFT)\n\n#define CFG_RD_SUCCESS\t\t\t0\n#define CFG_RD_UR\t\t\t1\n#define CFG_RD_CRS\t\t\t2\n#define CFG_RD_CA\t\t\t3\n#define CFG_RETRY_STATUS\t\t0xffff0001\n#define CFG_RETRY_STATUS_TIMEOUT_US\t500000  \n\n \n#define MAP_REG(base_reg, index)\t((base_reg) + (index) * 2)\n\n \n#define MAX_NUM_OB_WINDOW_SIZES\t\t4\n\n#define OARR_VALID_SHIFT\t\t0\n#define OARR_VALID\t\t\tBIT(OARR_VALID_SHIFT)\n#define OARR_SIZE_CFG_SHIFT\t\t1\n\n \n#define MAX_NUM_IB_REGION_SIZES\t\t9\n\n#define IMAP_VALID_SHIFT\t\t0\n#define IMAP_VALID\t\t\tBIT(IMAP_VALID_SHIFT)\n\n#define IPROC_PCI_PM_CAP\t\t0x48\n#define IPROC_PCI_PM_CAP_MASK\t\t0xffff\n#define IPROC_PCI_EXP_CAP\t\t0xac\n\n#define IPROC_PCIE_REG_INVALID\t\t0xffff\n\n \nstruct iproc_pcie_ob_map {\n\tresource_size_t window_sizes[MAX_NUM_OB_WINDOW_SIZES];\n\tunsigned int nr_sizes;\n};\n\nstatic const struct iproc_pcie_ob_map paxb_ob_map[] = {\n\t{\n\t\t \n\t\t.window_sizes = { 128, 256 },\n\t\t.nr_sizes = 2,\n\t},\n\t{\n\t\t \n\t\t.window_sizes = { 128, 256 },\n\t\t.nr_sizes = 2,\n\t},\n};\n\nstatic const struct iproc_pcie_ob_map paxb_v2_ob_map[] = {\n\t{\n\t\t \n\t\t.window_sizes = { 128, 256 },\n\t\t.nr_sizes = 2,\n\t},\n\t{\n\t\t \n\t\t.window_sizes = { 128, 256 },\n\t\t.nr_sizes = 2,\n\t},\n\t{\n\t\t \n\t\t.window_sizes = { 128, 256, 512, 1024 },\n\t\t.nr_sizes = 4,\n\t},\n\t{\n\t\t \n\t\t.window_sizes = { 128, 256, 512, 1024 },\n\t\t.nr_sizes = 4,\n\t},\n};\n\n \nenum iproc_pcie_ib_map_type {\n\tIPROC_PCIE_IB_MAP_MEM = 0,\n\tIPROC_PCIE_IB_MAP_IO,\n\tIPROC_PCIE_IB_MAP_INVALID\n};\n\n \nstruct iproc_pcie_ib_map {\n\tenum iproc_pcie_ib_map_type type;\n\tunsigned int size_unit;\n\tresource_size_t region_sizes[MAX_NUM_IB_REGION_SIZES];\n\tunsigned int nr_sizes;\n\tunsigned int nr_windows;\n\tu16 imap_addr_offset;\n\tu16 imap_window_offset;\n};\n\nstatic const struct iproc_pcie_ib_map paxb_v2_ib_map[] = {\n\t{\n\t\t \n\t\t.type = IPROC_PCIE_IB_MAP_IO,\n\t\t.size_unit = SZ_1K,\n\t\t.region_sizes = { 32 },\n\t\t.nr_sizes = 1,\n\t\t.nr_windows = 8,\n\t\t.imap_addr_offset = 0x40,\n\t\t.imap_window_offset = 0x4,\n\t},\n\t{\n\t\t \n\t\t.type = IPROC_PCIE_IB_MAP_MEM,\n\t\t.size_unit = SZ_1M,\n\t\t.region_sizes = { 8 },\n\t\t.nr_sizes = 1,\n\t\t.nr_windows = 8,\n\t\t.imap_addr_offset = 0x4,\n\t\t.imap_window_offset = 0x8,\n\n\t},\n\t{\n\t\t \n\t\t.type = IPROC_PCIE_IB_MAP_MEM,\n\t\t.size_unit = SZ_1M,\n\t\t.region_sizes = { 64, 128, 256, 512, 1024, 2048, 4096, 8192,\n\t\t\t\t  16384 },\n\t\t.nr_sizes = 9,\n\t\t.nr_windows = 1,\n\t\t.imap_addr_offset = 0x4,\n\t\t.imap_window_offset = 0x8,\n\t},\n\t{\n\t\t \n\t\t.type = IPROC_PCIE_IB_MAP_MEM,\n\t\t.size_unit = SZ_1G,\n\t\t.region_sizes = { 1, 2, 4, 8, 16, 32 },\n\t\t.nr_sizes = 6,\n\t\t.nr_windows = 8,\n\t\t.imap_addr_offset = 0x4,\n\t\t.imap_window_offset = 0x8,\n\t},\n\t{\n\t\t \n\t\t.type = IPROC_PCIE_IB_MAP_MEM,\n\t\t.size_unit = SZ_1G,\n\t\t.region_sizes = { 32, 64, 128, 256, 512 },\n\t\t.nr_sizes = 5,\n\t\t.nr_windows = 8,\n\t\t.imap_addr_offset = 0x4,\n\t\t.imap_window_offset = 0x8,\n\t},\n};\n\n \nenum iproc_pcie_reg {\n\t \n\tIPROC_PCIE_CLK_CTRL = 0,\n\n\t \n\tIPROC_PCIE_MSI_GIC_MODE,\n\n\t \n\tIPROC_PCIE_MSI_BASE_ADDR,\n\tIPROC_PCIE_MSI_WINDOW_SIZE,\n\n\t \n\tIPROC_PCIE_MSI_ADDR_LO,\n\tIPROC_PCIE_MSI_ADDR_HI,\n\n\t \n\tIPROC_PCIE_MSI_EN_CFG,\n\n\t \n\tIPROC_PCIE_CFG_IND_ADDR,\n\tIPROC_PCIE_CFG_IND_DATA,\n\n\t \n\tIPROC_PCIE_CFG_ADDR,\n\tIPROC_PCIE_CFG_DATA,\n\n\t \n\tIPROC_PCIE_INTX_EN,\n\n\t \n\tIPROC_PCIE_OARR0,\n\tIPROC_PCIE_OMAP0,\n\tIPROC_PCIE_OARR1,\n\tIPROC_PCIE_OMAP1,\n\tIPROC_PCIE_OARR2,\n\tIPROC_PCIE_OMAP2,\n\tIPROC_PCIE_OARR3,\n\tIPROC_PCIE_OMAP3,\n\n\t \n\tIPROC_PCIE_IARR0,\n\tIPROC_PCIE_IMAP0,\n\tIPROC_PCIE_IARR1,\n\tIPROC_PCIE_IMAP1,\n\tIPROC_PCIE_IARR2,\n\tIPROC_PCIE_IMAP2,\n\tIPROC_PCIE_IARR3,\n\tIPROC_PCIE_IMAP3,\n\tIPROC_PCIE_IARR4,\n\tIPROC_PCIE_IMAP4,\n\n\t \n\tIPROC_PCIE_CFG_RD_STATUS,\n\n\t \n\tIPROC_PCIE_LINK_STATUS,\n\n\t \n\tIPROC_PCIE_APB_ERR_EN,\n\n\t \n\tIPROC_PCIE_MAX_NUM_REG,\n};\n\n \nstatic const u16 iproc_pcie_reg_paxb_bcma[IPROC_PCIE_MAX_NUM_REG] = {\n\t[IPROC_PCIE_CLK_CTRL]\t\t= 0x000,\n\t[IPROC_PCIE_CFG_IND_ADDR]\t= 0x120,\n\t[IPROC_PCIE_CFG_IND_DATA]\t= 0x124,\n\t[IPROC_PCIE_CFG_ADDR]\t\t= 0x1f8,\n\t[IPROC_PCIE_CFG_DATA]\t\t= 0x1fc,\n\t[IPROC_PCIE_INTX_EN]\t\t= 0x330,\n\t[IPROC_PCIE_LINK_STATUS]\t= 0xf0c,\n};\n\n \nstatic const u16 iproc_pcie_reg_paxb[IPROC_PCIE_MAX_NUM_REG] = {\n\t[IPROC_PCIE_CLK_CTRL]\t\t= 0x000,\n\t[IPROC_PCIE_CFG_IND_ADDR]\t= 0x120,\n\t[IPROC_PCIE_CFG_IND_DATA]\t= 0x124,\n\t[IPROC_PCIE_CFG_ADDR]\t\t= 0x1f8,\n\t[IPROC_PCIE_CFG_DATA]\t\t= 0x1fc,\n\t[IPROC_PCIE_INTX_EN]\t\t= 0x330,\n\t[IPROC_PCIE_OARR0]\t\t= 0xd20,\n\t[IPROC_PCIE_OMAP0]\t\t= 0xd40,\n\t[IPROC_PCIE_OARR1]\t\t= 0xd28,\n\t[IPROC_PCIE_OMAP1]\t\t= 0xd48,\n\t[IPROC_PCIE_LINK_STATUS]\t= 0xf0c,\n\t[IPROC_PCIE_APB_ERR_EN]\t\t= 0xf40,\n};\n\n \nstatic const u16 iproc_pcie_reg_paxb_v2[IPROC_PCIE_MAX_NUM_REG] = {\n\t[IPROC_PCIE_CLK_CTRL]\t\t= 0x000,\n\t[IPROC_PCIE_CFG_IND_ADDR]\t= 0x120,\n\t[IPROC_PCIE_CFG_IND_DATA]\t= 0x124,\n\t[IPROC_PCIE_CFG_ADDR]\t\t= 0x1f8,\n\t[IPROC_PCIE_CFG_DATA]\t\t= 0x1fc,\n\t[IPROC_PCIE_INTX_EN]\t\t= 0x330,\n\t[IPROC_PCIE_OARR0]\t\t= 0xd20,\n\t[IPROC_PCIE_OMAP0]\t\t= 0xd40,\n\t[IPROC_PCIE_OARR1]\t\t= 0xd28,\n\t[IPROC_PCIE_OMAP1]\t\t= 0xd48,\n\t[IPROC_PCIE_OARR2]\t\t= 0xd60,\n\t[IPROC_PCIE_OMAP2]\t\t= 0xd68,\n\t[IPROC_PCIE_OARR3]\t\t= 0xdf0,\n\t[IPROC_PCIE_OMAP3]\t\t= 0xdf8,\n\t[IPROC_PCIE_IARR0]\t\t= 0xd00,\n\t[IPROC_PCIE_IMAP0]\t\t= 0xc00,\n\t[IPROC_PCIE_IARR1]\t\t= 0xd08,\n\t[IPROC_PCIE_IMAP1]\t\t= 0xd70,\n\t[IPROC_PCIE_IARR2]\t\t= 0xd10,\n\t[IPROC_PCIE_IMAP2]\t\t= 0xcc0,\n\t[IPROC_PCIE_IARR3]\t\t= 0xe00,\n\t[IPROC_PCIE_IMAP3]\t\t= 0xe08,\n\t[IPROC_PCIE_IARR4]\t\t= 0xe68,\n\t[IPROC_PCIE_IMAP4]\t\t= 0xe70,\n\t[IPROC_PCIE_CFG_RD_STATUS]\t= 0xee0,\n\t[IPROC_PCIE_LINK_STATUS]\t= 0xf0c,\n\t[IPROC_PCIE_APB_ERR_EN]\t\t= 0xf40,\n};\n\n \nstatic const u16 iproc_pcie_reg_paxc[IPROC_PCIE_MAX_NUM_REG] = {\n\t[IPROC_PCIE_CLK_CTRL]\t\t= 0x000,\n\t[IPROC_PCIE_CFG_IND_ADDR]\t= 0x1f0,\n\t[IPROC_PCIE_CFG_IND_DATA]\t= 0x1f4,\n\t[IPROC_PCIE_CFG_ADDR]\t\t= 0x1f8,\n\t[IPROC_PCIE_CFG_DATA]\t\t= 0x1fc,\n};\n\n \nstatic const u16 iproc_pcie_reg_paxc_v2[IPROC_PCIE_MAX_NUM_REG] = {\n\t[IPROC_PCIE_MSI_GIC_MODE]\t= 0x050,\n\t[IPROC_PCIE_MSI_BASE_ADDR]\t= 0x074,\n\t[IPROC_PCIE_MSI_WINDOW_SIZE]\t= 0x078,\n\t[IPROC_PCIE_MSI_ADDR_LO]\t= 0x07c,\n\t[IPROC_PCIE_MSI_ADDR_HI]\t= 0x080,\n\t[IPROC_PCIE_MSI_EN_CFG]\t\t= 0x09c,\n\t[IPROC_PCIE_CFG_IND_ADDR]\t= 0x1f0,\n\t[IPROC_PCIE_CFG_IND_DATA]\t= 0x1f4,\n\t[IPROC_PCIE_CFG_ADDR]\t\t= 0x1f8,\n\t[IPROC_PCIE_CFG_DATA]\t\t= 0x1fc,\n};\n\n \nstatic const u16 iproc_pcie_corrupt_cap_did[] = {\n\t0x16cd,\n\t0x16f0,\n\t0xd802,\n\t0xd804\n};\n\nstatic inline struct iproc_pcie *iproc_data(struct pci_bus *bus)\n{\n\tstruct iproc_pcie *pcie = bus->sysdata;\n\treturn pcie;\n}\n\nstatic inline bool iproc_pcie_reg_is_invalid(u16 reg_offset)\n{\n\treturn !!(reg_offset == IPROC_PCIE_REG_INVALID);\n}\n\nstatic inline u16 iproc_pcie_reg_offset(struct iproc_pcie *pcie,\n\t\t\t\t\tenum iproc_pcie_reg reg)\n{\n\treturn pcie->reg_offsets[reg];\n}\n\nstatic inline u32 iproc_pcie_read_reg(struct iproc_pcie *pcie,\n\t\t\t\t      enum iproc_pcie_reg reg)\n{\n\tu16 offset = iproc_pcie_reg_offset(pcie, reg);\n\n\tif (iproc_pcie_reg_is_invalid(offset))\n\t\treturn 0;\n\n\treturn readl(pcie->base + offset);\n}\n\nstatic inline void iproc_pcie_write_reg(struct iproc_pcie *pcie,\n\t\t\t\t\tenum iproc_pcie_reg reg, u32 val)\n{\n\tu16 offset = iproc_pcie_reg_offset(pcie, reg);\n\n\tif (iproc_pcie_reg_is_invalid(offset))\n\t\treturn;\n\n\twritel(val, pcie->base + offset);\n}\n\n \nstatic inline void iproc_pcie_apb_err_disable(struct pci_bus *bus,\n\t\t\t\t\t      bool disable)\n{\n\tstruct iproc_pcie *pcie = iproc_data(bus);\n\tu32 val;\n\n\tif (bus->number && pcie->has_apb_err_disable) {\n\t\tval = iproc_pcie_read_reg(pcie, IPROC_PCIE_APB_ERR_EN);\n\t\tif (disable)\n\t\t\tval &= ~APB_ERR_EN;\n\t\telse\n\t\t\tval |= APB_ERR_EN;\n\t\tiproc_pcie_write_reg(pcie, IPROC_PCIE_APB_ERR_EN, val);\n\t}\n}\n\nstatic void __iomem *iproc_pcie_map_ep_cfg_reg(struct iproc_pcie *pcie,\n\t\t\t\t\t       unsigned int busno,\n\t\t\t\t\t       unsigned int devfn,\n\t\t\t\t\t       int where)\n{\n\tu16 offset;\n\tu32 val;\n\n\t \n\tval = ALIGN_DOWN(PCIE_ECAM_OFFSET(busno, devfn, where), 4) |\n\t\tCFG_ADDR_CFG_TYPE_1;\n\n\tiproc_pcie_write_reg(pcie, IPROC_PCIE_CFG_ADDR, val);\n\toffset = iproc_pcie_reg_offset(pcie, IPROC_PCIE_CFG_DATA);\n\n\tif (iproc_pcie_reg_is_invalid(offset))\n\t\treturn NULL;\n\n\treturn (pcie->base + offset);\n}\n\nstatic unsigned int iproc_pcie_cfg_retry(struct iproc_pcie *pcie,\n\t\t\t\t\t void __iomem *cfg_data_p)\n{\n\tint timeout = CFG_RETRY_STATUS_TIMEOUT_US;\n\tunsigned int data;\n\tu32 status;\n\n\t \n\tdata = readl(cfg_data_p);\n\twhile (data == CFG_RETRY_STATUS && timeout--) {\n\t\t \n\t\tstatus = iproc_pcie_read_reg(pcie, IPROC_PCIE_CFG_RD_STATUS);\n\t\tif (status != CFG_RD_CRS)\n\t\t\treturn data;\n\n\t\tudelay(1);\n\t\tdata = readl(cfg_data_p);\n\t}\n\n\tif (data == CFG_RETRY_STATUS)\n\t\tdata = 0xffffffff;\n\n\treturn data;\n}\n\nstatic void iproc_pcie_fix_cap(struct iproc_pcie *pcie, int where, u32 *val)\n{\n\tu32 i, dev_id;\n\n\tswitch (where & ~0x3) {\n\tcase PCI_VENDOR_ID:\n\t\tdev_id = *val >> 16;\n\n\t\t \n\t\tfor (i = 0; i < ARRAY_SIZE(iproc_pcie_corrupt_cap_did); i++)\n\t\t\tif (dev_id == iproc_pcie_corrupt_cap_did[i])\n\t\t\t\tpcie->fix_paxc_cap = true;\n\t\tbreak;\n\n\tcase IPROC_PCI_PM_CAP:\n\t\tif (pcie->fix_paxc_cap) {\n\t\t\t \n\t\t\t*val &= ~IPROC_PCI_PM_CAP_MASK;\n\t\t\t*val |= IPROC_PCI_EXP_CAP << 8 | PCI_CAP_ID_PM;\n\t\t}\n\t\tbreak;\n\n\tcase IPROC_PCI_EXP_CAP:\n\t\tif (pcie->fix_paxc_cap) {\n\t\t\t \n\t\t\t*val = (PCI_EXP_TYPE_ROOT_PORT << 4 | 2) << 16 |\n\t\t\t\tPCI_CAP_ID_EXP;\n\t\t}\n\t\tbreak;\n\n\tcase IPROC_PCI_EXP_CAP + PCI_EXP_RTCTL:\n\t\t \n\t\t*val &= ~(PCI_EXP_RTCAP_CRSVIS << 16);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic int iproc_pcie_config_read(struct pci_bus *bus, unsigned int devfn,\n\t\t\t\t  int where, int size, u32 *val)\n{\n\tstruct iproc_pcie *pcie = iproc_data(bus);\n\tunsigned int busno = bus->number;\n\tvoid __iomem *cfg_data_p;\n\tunsigned int data;\n\tint ret;\n\n\t \n\tif (busno == 0) {\n\t\tret = pci_generic_config_read32(bus, devfn, where, size, val);\n\t\tif (ret == PCIBIOS_SUCCESSFUL)\n\t\t\tiproc_pcie_fix_cap(pcie, where, val);\n\n\t\treturn ret;\n\t}\n\n\tcfg_data_p = iproc_pcie_map_ep_cfg_reg(pcie, busno, devfn, where);\n\n\tif (!cfg_data_p)\n\t\treturn PCIBIOS_DEVICE_NOT_FOUND;\n\n\tdata = iproc_pcie_cfg_retry(pcie, cfg_data_p);\n\n\t*val = data;\n\tif (size <= 2)\n\t\t*val = (data >> (8 * (where & 3))) & ((1 << (size * 8)) - 1);\n\n\t \n#define DEVICE_ID_MASK     0xffff0000\n#define DEVICE_ID_SHIFT    16\n\tif (pcie->rej_unconfig_pf &&\n\t    (where & CFG_ADDR_REG_NUM_MASK) == PCI_VENDOR_ID)\n\t\tif ((*val & DEVICE_ID_MASK) ==\n\t\t    (PCI_DEVICE_ID_NX2_57810 << DEVICE_ID_SHIFT))\n\t\t\treturn PCIBIOS_FUNC_NOT_SUPPORTED;\n\n\treturn PCIBIOS_SUCCESSFUL;\n}\n\n \nstatic void __iomem *iproc_pcie_map_cfg_bus(struct iproc_pcie *pcie,\n\t\t\t\t\t    int busno, unsigned int devfn,\n\t\t\t\t\t    int where)\n{\n\tu16 offset;\n\n\t \n\tif (busno == 0) {\n\t\tif (PCIE_ECAM_DEVFN(devfn) > 0)\n\t\t\treturn NULL;\n\n\t\tiproc_pcie_write_reg(pcie, IPROC_PCIE_CFG_IND_ADDR,\n\t\t\t\t     where & CFG_IND_ADDR_MASK);\n\t\toffset = iproc_pcie_reg_offset(pcie, IPROC_PCIE_CFG_IND_DATA);\n\t\tif (iproc_pcie_reg_is_invalid(offset))\n\t\t\treturn NULL;\n\t\telse\n\t\t\treturn (pcie->base + offset);\n\t}\n\n\treturn iproc_pcie_map_ep_cfg_reg(pcie, busno, devfn, where);\n}\n\nstatic void __iomem *iproc_pcie_bus_map_cfg_bus(struct pci_bus *bus,\n\t\t\t\t\t\tunsigned int devfn,\n\t\t\t\t\t\tint where)\n{\n\treturn iproc_pcie_map_cfg_bus(iproc_data(bus), bus->number, devfn,\n\t\t\t\t      where);\n}\n\nstatic int iproc_pci_raw_config_read32(struct iproc_pcie *pcie,\n\t\t\t\t       unsigned int devfn, int where,\n\t\t\t\t       int size, u32 *val)\n{\n\tvoid __iomem *addr;\n\n\taddr = iproc_pcie_map_cfg_bus(pcie, 0, devfn, where & ~0x3);\n\tif (!addr)\n\t\treturn PCIBIOS_DEVICE_NOT_FOUND;\n\n\t*val = readl(addr);\n\n\tif (size <= 2)\n\t\t*val = (*val >> (8 * (where & 3))) & ((1 << (size * 8)) - 1);\n\n\treturn PCIBIOS_SUCCESSFUL;\n}\n\nstatic int iproc_pci_raw_config_write32(struct iproc_pcie *pcie,\n\t\t\t\t\tunsigned int devfn, int where,\n\t\t\t\t\tint size, u32 val)\n{\n\tvoid __iomem *addr;\n\tu32 mask, tmp;\n\n\taddr = iproc_pcie_map_cfg_bus(pcie, 0, devfn, where & ~0x3);\n\tif (!addr)\n\t\treturn PCIBIOS_DEVICE_NOT_FOUND;\n\n\tif (size == 4) {\n\t\twritel(val, addr);\n\t\treturn PCIBIOS_SUCCESSFUL;\n\t}\n\n\tmask = ~(((1 << (size * 8)) - 1) << ((where & 0x3) * 8));\n\ttmp = readl(addr) & mask;\n\ttmp |= val << ((where & 0x3) * 8);\n\twritel(tmp, addr);\n\n\treturn PCIBIOS_SUCCESSFUL;\n}\n\nstatic int iproc_pcie_config_read32(struct pci_bus *bus, unsigned int devfn,\n\t\t\t\t    int where, int size, u32 *val)\n{\n\tint ret;\n\tstruct iproc_pcie *pcie = iproc_data(bus);\n\n\tiproc_pcie_apb_err_disable(bus, true);\n\tif (pcie->iproc_cfg_read)\n\t\tret = iproc_pcie_config_read(bus, devfn, where, size, val);\n\telse\n\t\tret = pci_generic_config_read32(bus, devfn, where, size, val);\n\tiproc_pcie_apb_err_disable(bus, false);\n\n\treturn ret;\n}\n\nstatic int iproc_pcie_config_write32(struct pci_bus *bus, unsigned int devfn,\n\t\t\t\t     int where, int size, u32 val)\n{\n\tint ret;\n\n\tiproc_pcie_apb_err_disable(bus, true);\n\tret = pci_generic_config_write32(bus, devfn, where, size, val);\n\tiproc_pcie_apb_err_disable(bus, false);\n\n\treturn ret;\n}\n\nstatic struct pci_ops iproc_pcie_ops = {\n\t.map_bus = iproc_pcie_bus_map_cfg_bus,\n\t.read = iproc_pcie_config_read32,\n\t.write = iproc_pcie_config_write32,\n};\n\nstatic void iproc_pcie_perst_ctrl(struct iproc_pcie *pcie, bool assert)\n{\n\tu32 val;\n\n\t \n\tif (pcie->ep_is_internal)\n\t\treturn;\n\n\tif (assert) {\n\t\tval = iproc_pcie_read_reg(pcie, IPROC_PCIE_CLK_CTRL);\n\t\tval &= ~EP_PERST_SOURCE_SELECT & ~EP_MODE_SURVIVE_PERST &\n\t\t\t~RC_PCIE_RST_OUTPUT;\n\t\tiproc_pcie_write_reg(pcie, IPROC_PCIE_CLK_CTRL, val);\n\t\tudelay(250);\n\t} else {\n\t\tval = iproc_pcie_read_reg(pcie, IPROC_PCIE_CLK_CTRL);\n\t\tval |= RC_PCIE_RST_OUTPUT;\n\t\tiproc_pcie_write_reg(pcie, IPROC_PCIE_CLK_CTRL, val);\n\t\tmsleep(100);\n\t}\n}\n\nint iproc_pcie_shutdown(struct iproc_pcie *pcie)\n{\n\tiproc_pcie_perst_ctrl(pcie, true);\n\tmsleep(500);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(iproc_pcie_shutdown);\n\nstatic int iproc_pcie_check_link(struct iproc_pcie *pcie)\n{\n\tstruct device *dev = pcie->dev;\n\tu32 hdr_type, link_ctrl, link_status, class, val;\n\tbool link_is_active = false;\n\n\t \n\tif (pcie->ep_is_internal)\n\t\treturn 0;\n\n\tval = iproc_pcie_read_reg(pcie, IPROC_PCIE_LINK_STATUS);\n\tif (!(val & PCIE_PHYLINKUP) || !(val & PCIE_DL_ACTIVE)) {\n\t\tdev_err(dev, \"PHY or data link is INACTIVE!\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tiproc_pci_raw_config_read32(pcie, 0, PCI_HEADER_TYPE, 1, &hdr_type);\n\tif ((hdr_type & 0x7f) != PCI_HEADER_TYPE_BRIDGE) {\n\t\tdev_err(dev, \"in EP mode, hdr=%#02x\\n\", hdr_type);\n\t\treturn -EFAULT;\n\t}\n\n\t \n#define PCI_BRIDGE_CTRL_REG_OFFSET\t0x43c\n#define PCI_BRIDGE_CTRL_REG_CLASS_MASK\t0xffffff\n\tiproc_pci_raw_config_read32(pcie, 0, PCI_BRIDGE_CTRL_REG_OFFSET,\n\t\t\t\t    4, &class);\n\tclass &= ~PCI_BRIDGE_CTRL_REG_CLASS_MASK;\n\tclass |= PCI_CLASS_BRIDGE_PCI_NORMAL;\n\tiproc_pci_raw_config_write32(pcie, 0, PCI_BRIDGE_CTRL_REG_OFFSET,\n\t\t\t\t     4, class);\n\n\t \n\tiproc_pci_raw_config_read32(pcie, 0, IPROC_PCI_EXP_CAP + PCI_EXP_LNKSTA,\n\t\t\t\t    2, &link_status);\n\tif (link_status & PCI_EXP_LNKSTA_NLW)\n\t\tlink_is_active = true;\n\n\tif (!link_is_active) {\n\t\t \n#define PCI_TARGET_LINK_SPEED_MASK\t0xf\n#define PCI_TARGET_LINK_SPEED_GEN2\t0x2\n#define PCI_TARGET_LINK_SPEED_GEN1\t0x1\n\t\tiproc_pci_raw_config_read32(pcie, 0,\n\t\t\t\t\t    IPROC_PCI_EXP_CAP + PCI_EXP_LNKCTL2,\n\t\t\t\t\t    4, &link_ctrl);\n\t\tif ((link_ctrl & PCI_TARGET_LINK_SPEED_MASK) ==\n\t\t    PCI_TARGET_LINK_SPEED_GEN2) {\n\t\t\tlink_ctrl &= ~PCI_TARGET_LINK_SPEED_MASK;\n\t\t\tlink_ctrl |= PCI_TARGET_LINK_SPEED_GEN1;\n\t\t\tiproc_pci_raw_config_write32(pcie, 0,\n\t\t\t\t\tIPROC_PCI_EXP_CAP + PCI_EXP_LNKCTL2,\n\t\t\t\t\t4, link_ctrl);\n\t\t\tmsleep(100);\n\n\t\t\tiproc_pci_raw_config_read32(pcie, 0,\n\t\t\t\t\tIPROC_PCI_EXP_CAP + PCI_EXP_LNKSTA,\n\t\t\t\t\t2, &link_status);\n\t\t\tif (link_status & PCI_EXP_LNKSTA_NLW)\n\t\t\t\tlink_is_active = true;\n\t\t}\n\t}\n\n\tdev_info(dev, \"link: %s\\n\", link_is_active ? \"UP\" : \"DOWN\");\n\n\treturn link_is_active ? 0 : -ENODEV;\n}\n\nstatic void iproc_pcie_enable(struct iproc_pcie *pcie)\n{\n\tiproc_pcie_write_reg(pcie, IPROC_PCIE_INTX_EN, SYS_RC_INTX_MASK);\n}\n\nstatic inline bool iproc_pcie_ob_is_valid(struct iproc_pcie *pcie,\n\t\t\t\t\t  int window_idx)\n{\n\tu32 val;\n\n\tval = iproc_pcie_read_reg(pcie, MAP_REG(IPROC_PCIE_OARR0, window_idx));\n\n\treturn !!(val & OARR_VALID);\n}\n\nstatic inline int iproc_pcie_ob_write(struct iproc_pcie *pcie, int window_idx,\n\t\t\t\t      int size_idx, u64 axi_addr, u64 pci_addr)\n{\n\tstruct device *dev = pcie->dev;\n\tu16 oarr_offset, omap_offset;\n\n\t \n\toarr_offset = iproc_pcie_reg_offset(pcie, MAP_REG(IPROC_PCIE_OARR0,\n\t\t\t\t\t\t\t  window_idx));\n\tomap_offset = iproc_pcie_reg_offset(pcie, MAP_REG(IPROC_PCIE_OMAP0,\n\t\t\t\t\t\t\t  window_idx));\n\tif (iproc_pcie_reg_is_invalid(oarr_offset) ||\n\t    iproc_pcie_reg_is_invalid(omap_offset))\n\t\treturn -EINVAL;\n\n\t \n\twritel(lower_32_bits(axi_addr) | (size_idx << OARR_SIZE_CFG_SHIFT) |\n\t       OARR_VALID, pcie->base + oarr_offset);\n\twritel(upper_32_bits(axi_addr), pcie->base + oarr_offset + 4);\n\n\t \n\twritel(lower_32_bits(pci_addr), pcie->base + omap_offset);\n\twritel(upper_32_bits(pci_addr), pcie->base + omap_offset + 4);\n\n\tdev_dbg(dev, \"ob window [%d]: offset 0x%x axi %pap pci %pap\\n\",\n\t\twindow_idx, oarr_offset, &axi_addr, &pci_addr);\n\tdev_dbg(dev, \"oarr lo 0x%x oarr hi 0x%x\\n\",\n\t\treadl(pcie->base + oarr_offset),\n\t\treadl(pcie->base + oarr_offset + 4));\n\tdev_dbg(dev, \"omap lo 0x%x omap hi 0x%x\\n\",\n\t\treadl(pcie->base + omap_offset),\n\t\treadl(pcie->base + omap_offset + 4));\n\n\treturn 0;\n}\n\n \nstatic int iproc_pcie_setup_ob(struct iproc_pcie *pcie, u64 axi_addr,\n\t\t\t       u64 pci_addr, resource_size_t size)\n{\n\tstruct iproc_pcie_ob *ob = &pcie->ob;\n\tstruct device *dev = pcie->dev;\n\tint ret = -EINVAL, window_idx, size_idx;\n\n\tif (axi_addr < ob->axi_offset) {\n\t\tdev_err(dev, \"axi address %pap less than offset %pap\\n\",\n\t\t\t&axi_addr, &ob->axi_offset);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\taxi_addr -= ob->axi_offset;\n\n\t \n\tfor (window_idx = ob->nr_windows - 1; window_idx >= 0; window_idx--) {\n\t\tconst struct iproc_pcie_ob_map *ob_map =\n\t\t\t&pcie->ob_map[window_idx];\n\n\t\t \n\t\tif (iproc_pcie_ob_is_valid(pcie, window_idx))\n\t\t\tcontinue;\n\n\t\t \n\t\tfor (size_idx = ob_map->nr_sizes - 1; size_idx >= 0;\n\t\t     size_idx--) {\n\t\t\tresource_size_t window_size =\n\t\t\t\tob_map->window_sizes[size_idx] * SZ_1M;\n\n\t\t\t \n\t\t\tif (size < window_size) {\n\t\t\t\tif (size_idx > 0 || window_idx > 0)\n\t\t\t\t\tcontinue;\n\n\t\t\t\t \n\t\t\t\taxi_addr = ALIGN_DOWN(axi_addr, window_size);\n\t\t\t\tpci_addr = ALIGN_DOWN(pci_addr, window_size);\n\t\t\t\tsize = window_size;\n\t\t\t}\n\n\t\t\tif (!IS_ALIGNED(axi_addr, window_size) ||\n\t\t\t    !IS_ALIGNED(pci_addr, window_size)) {\n\t\t\t\tdev_err(dev,\n\t\t\t\t\t\"axi %pap or pci %pap not aligned\\n\",\n\t\t\t\t\t&axi_addr, &pci_addr);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\t \n\t\t\tret = iproc_pcie_ob_write(pcie, window_idx, size_idx,\n\t\t\t\t\t\t  axi_addr, pci_addr);\n\t\t\tif (ret)\n\t\t\t\tgoto err_ob;\n\n\t\t\tsize -= window_size;\n\t\t\tif (size == 0)\n\t\t\t\treturn 0;\n\n\t\t\t \n\t\t\taxi_addr += window_size;\n\t\t\tpci_addr += window_size;\n\t\t\tbreak;\n\t\t}\n\t}\n\nerr_ob:\n\tdev_err(dev, \"unable to configure outbound mapping\\n\");\n\tdev_err(dev,\n\t\t\"axi %pap, axi offset %pap, pci %pap, res size %pap\\n\",\n\t\t&axi_addr, &ob->axi_offset, &pci_addr, &size);\n\n\treturn ret;\n}\n\nstatic int iproc_pcie_map_ranges(struct iproc_pcie *pcie,\n\t\t\t\t struct list_head *resources)\n{\n\tstruct device *dev = pcie->dev;\n\tstruct resource_entry *window;\n\tint ret;\n\n\tresource_list_for_each_entry(window, resources) {\n\t\tstruct resource *res = window->res;\n\t\tu64 res_type = resource_type(res);\n\n\t\tswitch (res_type) {\n\t\tcase IORESOURCE_IO:\n\t\tcase IORESOURCE_BUS:\n\t\t\tbreak;\n\t\tcase IORESOURCE_MEM:\n\t\t\tret = iproc_pcie_setup_ob(pcie, res->start,\n\t\t\t\t\t\t  res->start - window->offset,\n\t\t\t\t\t\t  resource_size(res));\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(dev, \"invalid resource %pR\\n\", res);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic inline bool iproc_pcie_ib_is_in_use(struct iproc_pcie *pcie,\n\t\t\t\t\t   int region_idx)\n{\n\tconst struct iproc_pcie_ib_map *ib_map = &pcie->ib_map[region_idx];\n\tu32 val;\n\n\tval = iproc_pcie_read_reg(pcie, MAP_REG(IPROC_PCIE_IARR0, region_idx));\n\n\treturn !!(val & (BIT(ib_map->nr_sizes) - 1));\n}\n\nstatic inline bool iproc_pcie_ib_check_type(const struct iproc_pcie_ib_map *ib_map,\n\t\t\t\t\t    enum iproc_pcie_ib_map_type type)\n{\n\treturn !!(ib_map->type == type);\n}\n\nstatic int iproc_pcie_ib_write(struct iproc_pcie *pcie, int region_idx,\n\t\t\t       int size_idx, int nr_windows, u64 axi_addr,\n\t\t\t       u64 pci_addr, resource_size_t size)\n{\n\tstruct device *dev = pcie->dev;\n\tconst struct iproc_pcie_ib_map *ib_map = &pcie->ib_map[region_idx];\n\tu16 iarr_offset, imap_offset;\n\tu32 val;\n\tint window_idx;\n\n\tiarr_offset = iproc_pcie_reg_offset(pcie,\n\t\t\t\tMAP_REG(IPROC_PCIE_IARR0, region_idx));\n\timap_offset = iproc_pcie_reg_offset(pcie,\n\t\t\t\tMAP_REG(IPROC_PCIE_IMAP0, region_idx));\n\tif (iproc_pcie_reg_is_invalid(iarr_offset) ||\n\t    iproc_pcie_reg_is_invalid(imap_offset))\n\t\treturn -EINVAL;\n\n\tdev_dbg(dev, \"ib region [%d]: offset 0x%x axi %pap pci %pap\\n\",\n\t\tregion_idx, iarr_offset, &axi_addr, &pci_addr);\n\n\t \n\twritel(lower_32_bits(pci_addr) | BIT(size_idx),\n\t       pcie->base + iarr_offset);\n\twritel(upper_32_bits(pci_addr), pcie->base + iarr_offset + 4);\n\n\tdev_dbg(dev, \"iarr lo 0x%x iarr hi 0x%x\\n\",\n\t\treadl(pcie->base + iarr_offset),\n\t\treadl(pcie->base + iarr_offset + 4));\n\n\t \n\tsize >>= ilog2(nr_windows);\n\tfor (window_idx = 0; window_idx < nr_windows; window_idx++) {\n\t\tval = readl(pcie->base + imap_offset);\n\t\tval |= lower_32_bits(axi_addr) | IMAP_VALID;\n\t\twritel(val, pcie->base + imap_offset);\n\t\twritel(upper_32_bits(axi_addr),\n\t\t       pcie->base + imap_offset + ib_map->imap_addr_offset);\n\n\t\tdev_dbg(dev, \"imap window [%d] lo 0x%x hi 0x%x\\n\",\n\t\t\twindow_idx, readl(pcie->base + imap_offset),\n\t\t\treadl(pcie->base + imap_offset +\n\t\t\t      ib_map->imap_addr_offset));\n\n\t\timap_offset += ib_map->imap_window_offset;\n\t\taxi_addr += size;\n\t}\n\n\treturn 0;\n}\n\nstatic int iproc_pcie_setup_ib(struct iproc_pcie *pcie,\n\t\t\t       struct resource_entry *entry,\n\t\t\t       enum iproc_pcie_ib_map_type type)\n{\n\tstruct device *dev = pcie->dev;\n\tstruct iproc_pcie_ib *ib = &pcie->ib;\n\tint ret;\n\tunsigned int region_idx, size_idx;\n\tu64 axi_addr = entry->res->start;\n\tu64 pci_addr = entry->res->start - entry->offset;\n\tresource_size_t size = resource_size(entry->res);\n\n\t \n\tfor (region_idx = 0; region_idx < ib->nr_regions; region_idx++) {\n\t\tconst struct iproc_pcie_ib_map *ib_map =\n\t\t\t&pcie->ib_map[region_idx];\n\n\t\t \n\t\tif (iproc_pcie_ib_is_in_use(pcie, region_idx) ||\n\t\t    !iproc_pcie_ib_check_type(ib_map, type))\n\t\t\tcontinue;\n\n\t\t \n\t\tfor (size_idx = 0; size_idx < ib_map->nr_sizes; size_idx++) {\n\t\t\tresource_size_t region_size =\n\t\t\tib_map->region_sizes[size_idx] * ib_map->size_unit;\n\n\t\t\tif (size != region_size)\n\t\t\t\tcontinue;\n\n\t\t\tif (!IS_ALIGNED(axi_addr, region_size) ||\n\t\t\t    !IS_ALIGNED(pci_addr, region_size)) {\n\t\t\t\tdev_err(dev,\n\t\t\t\t\t\"axi %pap or pci %pap not aligned\\n\",\n\t\t\t\t\t&axi_addr, &pci_addr);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\t \n\t\t\tret = iproc_pcie_ib_write(pcie, region_idx, size_idx,\n\t\t\t\t\t\t  ib_map->nr_windows, axi_addr,\n\t\t\t\t\t\t  pci_addr, size);\n\t\t\tif (ret)\n\t\t\t\tgoto err_ib;\n\t\t\telse\n\t\t\t\treturn 0;\n\n\t\t}\n\t}\n\tret = -EINVAL;\n\nerr_ib:\n\tdev_err(dev, \"unable to configure inbound mapping\\n\");\n\tdev_err(dev, \"axi %pap, pci %pap, res size %pap\\n\",\n\t\t&axi_addr, &pci_addr, &size);\n\n\treturn ret;\n}\n\nstatic int iproc_pcie_map_dma_ranges(struct iproc_pcie *pcie)\n{\n\tstruct pci_host_bridge *host = pci_host_bridge_from_priv(pcie);\n\tstruct resource_entry *entry;\n\tint ret = 0;\n\n\tresource_list_for_each_entry(entry, &host->dma_ranges) {\n\t\t \n\t\tret = iproc_pcie_setup_ib(pcie, entry, IPROC_PCIE_IB_MAP_MEM);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic void iproc_pcie_invalidate_mapping(struct iproc_pcie *pcie)\n{\n\tstruct iproc_pcie_ib *ib = &pcie->ib;\n\tstruct iproc_pcie_ob *ob = &pcie->ob;\n\tint idx;\n\n\tif (pcie->ep_is_internal)\n\t\treturn;\n\n\tif (pcie->need_ob_cfg) {\n\t\t \n\t\tfor (idx = ob->nr_windows - 1; idx >= 0; idx--) {\n\t\t\tiproc_pcie_write_reg(pcie,\n\t\t\t\t\t     MAP_REG(IPROC_PCIE_OARR0, idx), 0);\n\t\t}\n\t}\n\n\tif (pcie->need_ib_cfg) {\n\t\t \n\t\tfor (idx = 0; idx < ib->nr_regions; idx++) {\n\t\t\tiproc_pcie_write_reg(pcie,\n\t\t\t\t\t     MAP_REG(IPROC_PCIE_IARR0, idx), 0);\n\t\t}\n\t}\n}\n\nstatic int iproce_pcie_get_msi(struct iproc_pcie *pcie,\n\t\t\t       struct device_node *msi_node,\n\t\t\t       u64 *msi_addr)\n{\n\tstruct device *dev = pcie->dev;\n\tint ret;\n\tstruct resource res;\n\n\t \n\tif (!of_device_is_compatible(msi_node, \"arm,gic-v3-its\")) {\n\t\tdev_err(dev, \"unable to find compatible MSI controller\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tret = of_address_to_resource(msi_node, 0, &res);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"unable to obtain MSI controller resources\\n\");\n\t\treturn ret;\n\t}\n\n\t*msi_addr = res.start + GITS_TRANSLATER;\n\treturn 0;\n}\n\nstatic int iproc_pcie_paxb_v2_msi_steer(struct iproc_pcie *pcie, u64 msi_addr)\n{\n\tint ret;\n\tstruct resource_entry entry;\n\n\tmemset(&entry, 0, sizeof(entry));\n\tentry.res = &entry.__res;\n\n\tmsi_addr &= ~(SZ_32K - 1);\n\tentry.res->start = msi_addr;\n\tentry.res->end = msi_addr + SZ_32K - 1;\n\n\tret = iproc_pcie_setup_ib(pcie, &entry, IPROC_PCIE_IB_MAP_IO);\n\treturn ret;\n}\n\nstatic void iproc_pcie_paxc_v2_msi_steer(struct iproc_pcie *pcie, u64 msi_addr,\n\t\t\t\t\t bool enable)\n{\n\tu32 val;\n\n\tif (!enable) {\n\t\t \n\t\tval = iproc_pcie_read_reg(pcie, IPROC_PCIE_MSI_EN_CFG);\n\t\tval &= ~MSI_ENABLE_CFG;\n\t\tiproc_pcie_write_reg(pcie, IPROC_PCIE_MSI_EN_CFG, val);\n\t\treturn;\n\t}\n\n\t \n\tiproc_pcie_write_reg(pcie, IPROC_PCIE_MSI_BASE_ADDR,\n\t\t\t     (u32)(msi_addr >> 13));\n\n\t \n\tiproc_pcie_write_reg(pcie, IPROC_PCIE_MSI_WINDOW_SIZE, 0);\n\n\t \n\tval = iproc_pcie_read_reg(pcie, IPROC_PCIE_MSI_GIC_MODE);\n\tval |= GIC_V3_CFG;\n\tiproc_pcie_write_reg(pcie, IPROC_PCIE_MSI_GIC_MODE, val);\n\n\t \n\tmsi_addr >>= 2;\n\tiproc_pcie_write_reg(pcie, IPROC_PCIE_MSI_ADDR_HI,\n\t\t\t     upper_32_bits(msi_addr));\n\tiproc_pcie_write_reg(pcie, IPROC_PCIE_MSI_ADDR_LO,\n\t\t\t     lower_32_bits(msi_addr));\n\n\t \n\tval = iproc_pcie_read_reg(pcie, IPROC_PCIE_MSI_EN_CFG);\n\tval |= MSI_ENABLE_CFG;\n\tiproc_pcie_write_reg(pcie, IPROC_PCIE_MSI_EN_CFG, val);\n}\n\nstatic int iproc_pcie_msi_steer(struct iproc_pcie *pcie,\n\t\t\t\tstruct device_node *msi_node)\n{\n\tstruct device *dev = pcie->dev;\n\tint ret;\n\tu64 msi_addr;\n\n\tret = iproce_pcie_get_msi(pcie, msi_node, &msi_addr);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"msi steering failed\\n\");\n\t\treturn ret;\n\t}\n\n\tswitch (pcie->type) {\n\tcase IPROC_PCIE_PAXB_V2:\n\t\tret = iproc_pcie_paxb_v2_msi_steer(pcie, msi_addr);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase IPROC_PCIE_PAXC_V2:\n\t\tiproc_pcie_paxc_v2_msi_steer(pcie, msi_addr, true);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int iproc_pcie_msi_enable(struct iproc_pcie *pcie)\n{\n\tstruct device_node *msi_node;\n\tint ret;\n\n\t \n\n\tmsi_node = of_parse_phandle(pcie->dev->of_node, \"msi-parent\", 0);\n\tif (!msi_node) {\n\t\tconst __be32 *msi_map = NULL;\n\t\tint len;\n\t\tu32 phandle;\n\n\t\tmsi_map = of_get_property(pcie->dev->of_node, \"msi-map\", &len);\n\t\tif (!msi_map)\n\t\t\treturn -ENODEV;\n\n\t\tphandle = be32_to_cpup(msi_map + 1);\n\t\tmsi_node = of_find_node_by_phandle(phandle);\n\t\tif (!msi_node)\n\t\t\treturn -ENODEV;\n\t}\n\n\t \n\tif (pcie->need_msi_steer) {\n\t\tret = iproc_pcie_msi_steer(pcie, msi_node);\n\t\tif (ret)\n\t\t\tgoto out_put_node;\n\t}\n\n\t \n\tret = iproc_msi_init(pcie, msi_node);\n\nout_put_node:\n\tof_node_put(msi_node);\n\treturn ret;\n}\n\nstatic void iproc_pcie_msi_disable(struct iproc_pcie *pcie)\n{\n\tiproc_msi_exit(pcie);\n}\n\nstatic int iproc_pcie_rev_init(struct iproc_pcie *pcie)\n{\n\tstruct device *dev = pcie->dev;\n\tunsigned int reg_idx;\n\tconst u16 *regs;\n\n\tswitch (pcie->type) {\n\tcase IPROC_PCIE_PAXB_BCMA:\n\t\tregs = iproc_pcie_reg_paxb_bcma;\n\t\tbreak;\n\tcase IPROC_PCIE_PAXB:\n\t\tregs = iproc_pcie_reg_paxb;\n\t\tpcie->has_apb_err_disable = true;\n\t\tif (pcie->need_ob_cfg) {\n\t\t\tpcie->ob_map = paxb_ob_map;\n\t\t\tpcie->ob.nr_windows = ARRAY_SIZE(paxb_ob_map);\n\t\t}\n\t\tbreak;\n\tcase IPROC_PCIE_PAXB_V2:\n\t\tregs = iproc_pcie_reg_paxb_v2;\n\t\tpcie->iproc_cfg_read = true;\n\t\tpcie->has_apb_err_disable = true;\n\t\tif (pcie->need_ob_cfg) {\n\t\t\tpcie->ob_map = paxb_v2_ob_map;\n\t\t\tpcie->ob.nr_windows = ARRAY_SIZE(paxb_v2_ob_map);\n\t\t}\n\t\tpcie->ib.nr_regions = ARRAY_SIZE(paxb_v2_ib_map);\n\t\tpcie->ib_map = paxb_v2_ib_map;\n\t\tpcie->need_msi_steer = true;\n\t\tdev_warn(dev, \"reads of config registers that contain %#x return incorrect data\\n\",\n\t\t\t CFG_RETRY_STATUS);\n\t\tbreak;\n\tcase IPROC_PCIE_PAXC:\n\t\tregs = iproc_pcie_reg_paxc;\n\t\tpcie->ep_is_internal = true;\n\t\tpcie->iproc_cfg_read = true;\n\t\tpcie->rej_unconfig_pf = true;\n\t\tbreak;\n\tcase IPROC_PCIE_PAXC_V2:\n\t\tregs = iproc_pcie_reg_paxc_v2;\n\t\tpcie->ep_is_internal = true;\n\t\tpcie->iproc_cfg_read = true;\n\t\tpcie->rej_unconfig_pf = true;\n\t\tpcie->need_msi_steer = true;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"incompatible iProc PCIe interface\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpcie->reg_offsets = devm_kcalloc(dev, IPROC_PCIE_MAX_NUM_REG,\n\t\t\t\t\t sizeof(*pcie->reg_offsets),\n\t\t\t\t\t GFP_KERNEL);\n\tif (!pcie->reg_offsets)\n\t\treturn -ENOMEM;\n\n\t \n\tpcie->reg_offsets[0] = (pcie->type == IPROC_PCIE_PAXC_V2) ?\n\t\tIPROC_PCIE_REG_INVALID : regs[0];\n\tfor (reg_idx = 1; reg_idx < IPROC_PCIE_MAX_NUM_REG; reg_idx++)\n\t\tpcie->reg_offsets[reg_idx] = regs[reg_idx] ?\n\t\t\tregs[reg_idx] : IPROC_PCIE_REG_INVALID;\n\n\treturn 0;\n}\n\nint iproc_pcie_setup(struct iproc_pcie *pcie, struct list_head *res)\n{\n\tstruct device *dev;\n\tint ret;\n\tstruct pci_dev *pdev;\n\tstruct pci_host_bridge *host = pci_host_bridge_from_priv(pcie);\n\n\tdev = pcie->dev;\n\n\tret = iproc_pcie_rev_init(pcie);\n\tif (ret) {\n\t\tdev_err(dev, \"unable to initialize controller parameters\\n\");\n\t\treturn ret;\n\t}\n\n\tret = phy_init(pcie->phy);\n\tif (ret) {\n\t\tdev_err(dev, \"unable to initialize PCIe PHY\\n\");\n\t\treturn ret;\n\t}\n\n\tret = phy_power_on(pcie->phy);\n\tif (ret) {\n\t\tdev_err(dev, \"unable to power on PCIe PHY\\n\");\n\t\tgoto err_exit_phy;\n\t}\n\n\tiproc_pcie_perst_ctrl(pcie, true);\n\tiproc_pcie_perst_ctrl(pcie, false);\n\n\tiproc_pcie_invalidate_mapping(pcie);\n\n\tif (pcie->need_ob_cfg) {\n\t\tret = iproc_pcie_map_ranges(pcie, res);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"map failed\\n\");\n\t\t\tgoto err_power_off_phy;\n\t\t}\n\t}\n\n\tif (pcie->need_ib_cfg) {\n\t\tret = iproc_pcie_map_dma_ranges(pcie);\n\t\tif (ret && ret != -ENOENT)\n\t\t\tgoto err_power_off_phy;\n\t}\n\n\tret = iproc_pcie_check_link(pcie);\n\tif (ret) {\n\t\tdev_err(dev, \"no PCIe EP device detected\\n\");\n\t\tgoto err_power_off_phy;\n\t}\n\n\tiproc_pcie_enable(pcie);\n\n\tif (IS_ENABLED(CONFIG_PCI_MSI))\n\t\tif (iproc_pcie_msi_enable(pcie))\n\t\t\tdev_info(dev, \"not using iProc MSI\\n\");\n\n\thost->ops = &iproc_pcie_ops;\n\thost->sysdata = pcie;\n\thost->map_irq = pcie->map_irq;\n\n\tret = pci_host_probe(host);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to scan host: %d\\n\", ret);\n\t\tgoto err_power_off_phy;\n\t}\n\n\tfor_each_pci_bridge(pdev, host->bus) {\n\t\tif (pci_pcie_type(pdev) == PCI_EXP_TYPE_ROOT_PORT)\n\t\t\tpcie_print_link_status(pdev);\n\t}\n\n\treturn 0;\n\nerr_power_off_phy:\n\tphy_power_off(pcie->phy);\nerr_exit_phy:\n\tphy_exit(pcie->phy);\n\treturn ret;\n}\nEXPORT_SYMBOL(iproc_pcie_setup);\n\nvoid iproc_pcie_remove(struct iproc_pcie *pcie)\n{\n\tstruct pci_host_bridge *host = pci_host_bridge_from_priv(pcie);\n\n\tpci_stop_root_bus(host->bus);\n\tpci_remove_root_bus(host->bus);\n\n\tiproc_pcie_msi_disable(pcie);\n\n\tphy_power_off(pcie->phy);\n\tphy_exit(pcie->phy);\n}\nEXPORT_SYMBOL(iproc_pcie_remove);\n\n \nstatic void quirk_paxc_disable_msi_parsing(struct pci_dev *pdev)\n{\n\tstruct iproc_pcie *pcie = iproc_data(pdev->bus);\n\n\tif (pdev->hdr_type == PCI_HEADER_TYPE_BRIDGE)\n\t\tiproc_pcie_paxc_v2_msi_steer(pcie, 0, false);\n}\nDECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_BROADCOM, 0x16f0,\n\t\t\tquirk_paxc_disable_msi_parsing);\nDECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_BROADCOM, 0xd802,\n\t\t\tquirk_paxc_disable_msi_parsing);\nDECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_BROADCOM, 0xd804,\n\t\t\tquirk_paxc_disable_msi_parsing);\n\nstatic void quirk_paxc_bridge(struct pci_dev *pdev)\n{\n\t \n\tif (pdev->hdr_type == PCI_HEADER_TYPE_BRIDGE)\n\t\tpdev->class = PCI_CLASS_BRIDGE_PCI_NORMAL;\n\n\t \n\tpdev->pcie_mpss = 2;\n}\nDECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_BROADCOM, 0x16cd, quirk_paxc_bridge);\nDECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_BROADCOM, 0x16f0, quirk_paxc_bridge);\nDECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_BROADCOM, 0xd750, quirk_paxc_bridge);\nDECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_BROADCOM, 0xd802, quirk_paxc_bridge);\nDECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_BROADCOM, 0xd804, quirk_paxc_bridge);\n\nMODULE_AUTHOR(\"Ray Jui <rjui@broadcom.com>\");\nMODULE_DESCRIPTION(\"Broadcom iPROC PCIe common driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}