{
  "module_name": "pci-ftpci100.c",
  "hash_id": "986a11b8727e85a37ad6727f6f5db43ac4768996caed17cf65ed800e18aac190",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/controller/pci-ftpci100.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/of.h>\n#include <linux/of_irq.h>\n#include <linux/of_pci.h>\n#include <linux/pci.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/irqchip/chained_irq.h>\n#include <linux/bitops.h>\n#include <linux/irq.h>\n#include <linux/clk.h>\n\n#include \"../pci.h\"\n\n \n#define FTPCI_IOSIZE\t0x00\n#define FTPCI_PROT\t0x04  \n#define FTPCI_CTRL\t0x08  \n#define FTPCI_SOFTRST\t0x10  \n#define FTPCI_CONFIG\t0x28  \n#define FTPCI_DATA\t0x2C\n\n#define FARADAY_PCI_STATUS_CMD\t\t0x04  \n#define FARADAY_PCI_PMC\t\t\t0x40  \n#define FARADAY_PCI_PMCSR\t\t0x44  \n#define FARADAY_PCI_CTRL1\t\t0x48  \n#define FARADAY_PCI_CTRL2\t\t0x4C  \n#define FARADAY_PCI_MEM1_BASE_SIZE\t0x50  \n#define FARADAY_PCI_MEM2_BASE_SIZE\t0x54  \n#define FARADAY_PCI_MEM3_BASE_SIZE\t0x58  \n\n#define PCI_STATUS_66MHZ_CAPABLE\tBIT(21)\n\n \n#define PCI_CTRL2_INTSTS_SHIFT\t\t28\n#define PCI_CTRL2_INTMASK_CMDERR\tBIT(27)\n#define PCI_CTRL2_INTMASK_PARERR\tBIT(26)\n \n#define PCI_CTRL2_INTMASK_SHIFT\t\t22\n#define PCI_CTRL2_INTMASK_MABRT_RX\tBIT(21)\n#define PCI_CTRL2_INTMASK_TABRT_RX\tBIT(20)\n#define PCI_CTRL2_INTMASK_TABRT_TX\tBIT(19)\n#define PCI_CTRL2_INTMASK_RETRY4\tBIT(18)\n#define PCI_CTRL2_INTMASK_SERR_RX\tBIT(17)\n#define PCI_CTRL2_INTMASK_PERR_RX\tBIT(16)\n \n#define PCI_CTRL2_MSTPRI_REQ6\t\tBIT(14)\n#define PCI_CTRL2_MSTPRI_REQ5\t\tBIT(13)\n#define PCI_CTRL2_MSTPRI_REQ4\t\tBIT(12)\n#define PCI_CTRL2_MSTPRI_REQ3\t\tBIT(11)\n#define PCI_CTRL2_MSTPRI_REQ2\t\tBIT(10)\n#define PCI_CTRL2_MSTPRI_REQ1\t\tBIT(9)\n#define PCI_CTRL2_MSTPRI_REQ0\t\tBIT(8)\n \n \n\n \n#define FARADAY_PCI_MEMBASE_MASK\t0xfff00000\n#define FARADAY_PCI_MEMSIZE_1MB\t\t0x0\n#define FARADAY_PCI_MEMSIZE_2MB\t\t0x1\n#define FARADAY_PCI_MEMSIZE_4MB\t\t0x2\n#define FARADAY_PCI_MEMSIZE_8MB\t\t0x3\n#define FARADAY_PCI_MEMSIZE_16MB\t0x4\n#define FARADAY_PCI_MEMSIZE_32MB\t0x5\n#define FARADAY_PCI_MEMSIZE_64MB\t0x6\n#define FARADAY_PCI_MEMSIZE_128MB\t0x7\n#define FARADAY_PCI_MEMSIZE_256MB\t0x8\n#define FARADAY_PCI_MEMSIZE_512MB\t0x9\n#define FARADAY_PCI_MEMSIZE_1GB\t\t0xa\n#define FARADAY_PCI_MEMSIZE_2GB\t\t0xb\n#define FARADAY_PCI_MEMSIZE_SHIFT\t16\n\n \n#define FARADAY_PCI_DMA_MEM1_BASE\t0x00000000\n#define FARADAY_PCI_DMA_MEM2_BASE\t0x00000000\n#define FARADAY_PCI_DMA_MEM3_BASE\t0x00000000\n\n \nstruct faraday_pci_variant {\n\tbool cascaded_irq;\n};\n\nstruct faraday_pci {\n\tstruct device *dev;\n\tvoid __iomem *base;\n\tstruct irq_domain *irqdomain;\n\tstruct pci_bus *bus;\n\tstruct clk *bus_clk;\n};\n\nstatic int faraday_res_to_memcfg(resource_size_t mem_base,\n\t\t\t\t resource_size_t mem_size, u32 *val)\n{\n\tu32 outval;\n\n\tswitch (mem_size) {\n\tcase SZ_1M:\n\t\toutval = FARADAY_PCI_MEMSIZE_1MB;\n\t\tbreak;\n\tcase SZ_2M:\n\t\toutval = FARADAY_PCI_MEMSIZE_2MB;\n\t\tbreak;\n\tcase SZ_4M:\n\t\toutval = FARADAY_PCI_MEMSIZE_4MB;\n\t\tbreak;\n\tcase SZ_8M:\n\t\toutval = FARADAY_PCI_MEMSIZE_8MB;\n\t\tbreak;\n\tcase SZ_16M:\n\t\toutval = FARADAY_PCI_MEMSIZE_16MB;\n\t\tbreak;\n\tcase SZ_32M:\n\t\toutval = FARADAY_PCI_MEMSIZE_32MB;\n\t\tbreak;\n\tcase SZ_64M:\n\t\toutval = FARADAY_PCI_MEMSIZE_64MB;\n\t\tbreak;\n\tcase SZ_128M:\n\t\toutval = FARADAY_PCI_MEMSIZE_128MB;\n\t\tbreak;\n\tcase SZ_256M:\n\t\toutval = FARADAY_PCI_MEMSIZE_256MB;\n\t\tbreak;\n\tcase SZ_512M:\n\t\toutval = FARADAY_PCI_MEMSIZE_512MB;\n\t\tbreak;\n\tcase SZ_1G:\n\t\toutval = FARADAY_PCI_MEMSIZE_1GB;\n\t\tbreak;\n\tcase SZ_2G:\n\t\toutval = FARADAY_PCI_MEMSIZE_2GB;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\toutval <<= FARADAY_PCI_MEMSIZE_SHIFT;\n\n\t \n\tif (mem_base & ~(FARADAY_PCI_MEMBASE_MASK))\n\t\tpr_warn(\"truncated PCI memory base\\n\");\n\t \n\toutval |= (mem_base & FARADAY_PCI_MEMBASE_MASK);\n\tpr_debug(\"Translated pci base @%pap, size %pap to config %08x\\n\",\n\t\t &mem_base, &mem_size, outval);\n\n\t*val = outval;\n\treturn 0;\n}\n\nstatic int faraday_raw_pci_read_config(struct faraday_pci *p, int bus_number,\n\t\t\t\t       unsigned int fn, int config, int size,\n\t\t\t\t       u32 *value)\n{\n\twritel(PCI_CONF1_ADDRESS(bus_number, PCI_SLOT(fn),\n\t\t\t\t PCI_FUNC(fn), config),\n\t\t\tp->base + FTPCI_CONFIG);\n\n\t*value = readl(p->base + FTPCI_DATA);\n\n\tif (size == 1)\n\t\t*value = (*value >> (8 * (config & 3))) & 0xFF;\n\telse if (size == 2)\n\t\t*value = (*value >> (8 * (config & 3))) & 0xFFFF;\n\n\treturn PCIBIOS_SUCCESSFUL;\n}\n\nstatic int faraday_pci_read_config(struct pci_bus *bus, unsigned int fn,\n\t\t\t\t   int config, int size, u32 *value)\n{\n\tstruct faraday_pci *p = bus->sysdata;\n\n\tdev_dbg(&bus->dev,\n\t\t\"[read]  slt: %.2d, fnc: %d, cnf: 0x%.2X, val (%d bytes): 0x%.8X\\n\",\n\t\tPCI_SLOT(fn), PCI_FUNC(fn), config, size, *value);\n\n\treturn faraday_raw_pci_read_config(p, bus->number, fn, config, size, value);\n}\n\nstatic int faraday_raw_pci_write_config(struct faraday_pci *p, int bus_number,\n\t\t\t\t\t unsigned int fn, int config, int size,\n\t\t\t\t\t u32 value)\n{\n\tint ret = PCIBIOS_SUCCESSFUL;\n\n\twritel(PCI_CONF1_ADDRESS(bus_number, PCI_SLOT(fn),\n\t\t\t\t PCI_FUNC(fn), config),\n\t\t\tp->base + FTPCI_CONFIG);\n\n\tswitch (size) {\n\tcase 4:\n\t\twritel(value, p->base + FTPCI_DATA);\n\t\tbreak;\n\tcase 2:\n\t\twritew(value, p->base + FTPCI_DATA + (config & 3));\n\t\tbreak;\n\tcase 1:\n\t\twriteb(value, p->base + FTPCI_DATA + (config & 3));\n\t\tbreak;\n\tdefault:\n\t\tret = PCIBIOS_BAD_REGISTER_NUMBER;\n\t}\n\n\treturn ret;\n}\n\nstatic int faraday_pci_write_config(struct pci_bus *bus, unsigned int fn,\n\t\t\t\t    int config, int size, u32 value)\n{\n\tstruct faraday_pci *p = bus->sysdata;\n\n\tdev_dbg(&bus->dev,\n\t\t\"[write] slt: %.2d, fnc: %d, cnf: 0x%.2X, val (%d bytes): 0x%.8X\\n\",\n\t\tPCI_SLOT(fn), PCI_FUNC(fn), config, size, value);\n\n\treturn faraday_raw_pci_write_config(p, bus->number, fn, config, size,\n\t\t\t\t\t    value);\n}\n\nstatic struct pci_ops faraday_pci_ops = {\n\t.read\t= faraday_pci_read_config,\n\t.write\t= faraday_pci_write_config,\n};\n\nstatic void faraday_pci_ack_irq(struct irq_data *d)\n{\n\tstruct faraday_pci *p = irq_data_get_irq_chip_data(d);\n\tunsigned int reg;\n\n\tfaraday_raw_pci_read_config(p, 0, 0, FARADAY_PCI_CTRL2, 4, &reg);\n\treg &= ~(0xF << PCI_CTRL2_INTSTS_SHIFT);\n\treg |= BIT(irqd_to_hwirq(d) + PCI_CTRL2_INTSTS_SHIFT);\n\tfaraday_raw_pci_write_config(p, 0, 0, FARADAY_PCI_CTRL2, 4, reg);\n}\n\nstatic void faraday_pci_mask_irq(struct irq_data *d)\n{\n\tstruct faraday_pci *p = irq_data_get_irq_chip_data(d);\n\tunsigned int reg;\n\n\tfaraday_raw_pci_read_config(p, 0, 0, FARADAY_PCI_CTRL2, 4, &reg);\n\treg &= ~((0xF << PCI_CTRL2_INTSTS_SHIFT)\n\t\t | BIT(irqd_to_hwirq(d) + PCI_CTRL2_INTMASK_SHIFT));\n\tfaraday_raw_pci_write_config(p, 0, 0, FARADAY_PCI_CTRL2, 4, reg);\n}\n\nstatic void faraday_pci_unmask_irq(struct irq_data *d)\n{\n\tstruct faraday_pci *p = irq_data_get_irq_chip_data(d);\n\tunsigned int reg;\n\n\tfaraday_raw_pci_read_config(p, 0, 0, FARADAY_PCI_CTRL2, 4, &reg);\n\treg &= ~(0xF << PCI_CTRL2_INTSTS_SHIFT);\n\treg |= BIT(irqd_to_hwirq(d) + PCI_CTRL2_INTMASK_SHIFT);\n\tfaraday_raw_pci_write_config(p, 0, 0, FARADAY_PCI_CTRL2, 4, reg);\n}\n\nstatic void faraday_pci_irq_handler(struct irq_desc *desc)\n{\n\tstruct faraday_pci *p = irq_desc_get_handler_data(desc);\n\tstruct irq_chip *irqchip = irq_desc_get_chip(desc);\n\tunsigned int irq_stat, reg, i;\n\n\tfaraday_raw_pci_read_config(p, 0, 0, FARADAY_PCI_CTRL2, 4, &reg);\n\tirq_stat = reg >> PCI_CTRL2_INTSTS_SHIFT;\n\n\tchained_irq_enter(irqchip, desc);\n\n\tfor (i = 0; i < 4; i++) {\n\t\tif ((irq_stat & BIT(i)) == 0)\n\t\t\tcontinue;\n\t\tgeneric_handle_domain_irq(p->irqdomain, i);\n\t}\n\n\tchained_irq_exit(irqchip, desc);\n}\n\nstatic struct irq_chip faraday_pci_irq_chip = {\n\t.name = \"PCI\",\n\t.irq_ack = faraday_pci_ack_irq,\n\t.irq_mask = faraday_pci_mask_irq,\n\t.irq_unmask = faraday_pci_unmask_irq,\n};\n\nstatic int faraday_pci_irq_map(struct irq_domain *domain, unsigned int irq,\n\t\t\t       irq_hw_number_t hwirq)\n{\n\tirq_set_chip_and_handler(irq, &faraday_pci_irq_chip, handle_level_irq);\n\tirq_set_chip_data(irq, domain->host_data);\n\n\treturn 0;\n}\n\nstatic const struct irq_domain_ops faraday_pci_irqdomain_ops = {\n\t.map = faraday_pci_irq_map,\n};\n\nstatic int faraday_pci_setup_cascaded_irq(struct faraday_pci *p)\n{\n\tstruct device_node *intc = of_get_next_child(p->dev->of_node, NULL);\n\tint irq;\n\tint i;\n\n\tif (!intc) {\n\t\tdev_err(p->dev, \"missing child interrupt-controller node\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tirq = of_irq_get(intc, 0);\n\tif (irq <= 0) {\n\t\tdev_err(p->dev, \"failed to get parent IRQ\\n\");\n\t\tof_node_put(intc);\n\t\treturn irq ?: -EINVAL;\n\t}\n\n\tp->irqdomain = irq_domain_add_linear(intc, PCI_NUM_INTX,\n\t\t\t\t\t     &faraday_pci_irqdomain_ops, p);\n\tof_node_put(intc);\n\tif (!p->irqdomain) {\n\t\tdev_err(p->dev, \"failed to create Gemini PCI IRQ domain\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tirq_set_chained_handler_and_data(irq, faraday_pci_irq_handler, p);\n\n\tfor (i = 0; i < 4; i++)\n\t\tirq_create_mapping(p->irqdomain, i);\n\n\treturn 0;\n}\n\nstatic int faraday_pci_parse_map_dma_ranges(struct faraday_pci *p)\n{\n\tstruct device *dev = p->dev;\n\tstruct pci_host_bridge *bridge = pci_host_bridge_from_priv(p);\n\tstruct resource_entry *entry;\n\tu32 confreg[3] = {\n\t\tFARADAY_PCI_MEM1_BASE_SIZE,\n\t\tFARADAY_PCI_MEM2_BASE_SIZE,\n\t\tFARADAY_PCI_MEM3_BASE_SIZE,\n\t};\n\tint i = 0;\n\tu32 val;\n\n\tresource_list_for_each_entry(entry, &bridge->dma_ranges) {\n\t\tu64 pci_addr = entry->res->start - entry->offset;\n\t\tu64 end = entry->res->end - entry->offset;\n\t\tint ret;\n\n\t\tret = faraday_res_to_memcfg(pci_addr,\n\t\t\t\t\t    resource_size(entry->res), &val);\n\t\tif (ret) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"DMA range %d: illegal MEM resource size\\n\", i);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tdev_info(dev, \"DMA MEM%d BASE: 0x%016llx -> 0x%016llx config %08x\\n\",\n\t\t\t i + 1, pci_addr, end, val);\n\t\tif (i <= 2) {\n\t\t\tfaraday_raw_pci_write_config(p, 0, 0, confreg[i],\n\t\t\t\t\t\t     4, val);\n\t\t} else {\n\t\t\tdev_err(dev, \"ignore extraneous dma-range %d\\n\", i);\n\t\t\tbreak;\n\t\t}\n\n\t\ti++;\n\t}\n\n\treturn 0;\n}\n\nstatic int faraday_pci_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tconst struct faraday_pci_variant *variant =\n\t\tof_device_get_match_data(dev);\n\tstruct resource_entry *win;\n\tstruct faraday_pci *p;\n\tstruct resource *io;\n\tstruct pci_host_bridge *host;\n\tstruct clk *clk;\n\tunsigned char max_bus_speed = PCI_SPEED_33MHz;\n\tunsigned char cur_bus_speed = PCI_SPEED_33MHz;\n\tint ret;\n\tu32 val;\n\n\thost = devm_pci_alloc_host_bridge(dev, sizeof(*p));\n\tif (!host)\n\t\treturn -ENOMEM;\n\n\thost->ops = &faraday_pci_ops;\n\tp = pci_host_bridge_priv(host);\n\thost->sysdata = p;\n\tp->dev = dev;\n\n\t \n\tclk = devm_clk_get_enabled(dev, \"PCLK\");\n\tif (IS_ERR(clk))\n\t\treturn PTR_ERR(clk);\n\tp->bus_clk = devm_clk_get_enabled(dev, \"PCICLK\");\n\tif (IS_ERR(p->bus_clk))\n\t\treturn PTR_ERR(p->bus_clk);\n\n\tp->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(p->base))\n\t\treturn PTR_ERR(p->base);\n\n\twin = resource_list_first_type(&host->windows, IORESOURCE_IO);\n\tif (win) {\n\t\tio = win->res;\n\t\tif (!faraday_res_to_memcfg(io->start - win->offset,\n\t\t\t\t\t   resource_size(io), &val)) {\n\t\t\t \n\t\t\twritel(val, p->base + FTPCI_IOSIZE);\n\t\t} else {\n\t\t\tdev_err(dev, \"illegal IO mem size\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t \n\tval = readl(p->base + FTPCI_CTRL);\n\tval |= PCI_COMMAND_IO;\n\tval |= PCI_COMMAND_MEMORY;\n\tval |= PCI_COMMAND_MASTER;\n\twritel(val, p->base + FTPCI_CTRL);\n\t \n\tfaraday_raw_pci_write_config(p, 0, 0, FARADAY_PCI_CTRL2 + 2, 2, 0xF000);\n\tif (variant->cascaded_irq) {\n\t\tret = faraday_pci_setup_cascaded_irq(p);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"failed to setup cascaded IRQ\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tif (!IS_ERR(p->bus_clk)) {\n\t\tunsigned long rate;\n\t\tu32 val;\n\n\t\tfaraday_raw_pci_read_config(p, 0, 0,\n\t\t\t\t\t    FARADAY_PCI_STATUS_CMD, 4, &val);\n\t\trate = clk_get_rate(p->bus_clk);\n\n\t\tif ((rate == 33000000) && (val & PCI_STATUS_66MHZ_CAPABLE)) {\n\t\t\tdev_info(dev, \"33MHz bus is 66MHz capable\\n\");\n\t\t\tmax_bus_speed = PCI_SPEED_66MHz;\n\t\t\tret = clk_set_rate(p->bus_clk, 66000000);\n\t\t\tif (ret)\n\t\t\t\tdev_err(dev, \"failed to set bus clock\\n\");\n\t\t} else {\n\t\t\tdev_info(dev, \"33MHz only bus\\n\");\n\t\t\tmax_bus_speed = PCI_SPEED_33MHz;\n\t\t}\n\n\t\t \n\t\trate = clk_get_rate(p->bus_clk);\n\t\tif (rate == 33000000)\n\t\t\tcur_bus_speed = PCI_SPEED_33MHz;\n\t\tif (rate == 66000000)\n\t\t\tcur_bus_speed = PCI_SPEED_66MHz;\n\t}\n\n\tret = faraday_pci_parse_map_dma_ranges(p);\n\tif (ret)\n\t\treturn ret;\n\n\tret = pci_scan_root_bus_bridge(host);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to scan host: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tp->bus = host->bus;\n\tp->bus->max_bus_speed = max_bus_speed;\n\tp->bus->cur_bus_speed = cur_bus_speed;\n\n\tpci_bus_assign_resources(p->bus);\n\tpci_bus_add_devices(p->bus);\n\n\treturn 0;\n}\n\n \nstatic const struct faraday_pci_variant faraday_regular = {\n\t.cascaded_irq = true,\n};\n\nstatic const struct faraday_pci_variant faraday_dual = {\n\t.cascaded_irq = false,\n};\n\nstatic const struct of_device_id faraday_pci_of_match[] = {\n\t{\n\t\t.compatible = \"faraday,ftpci100\",\n\t\t.data = &faraday_regular,\n\t},\n\t{\n\t\t.compatible = \"faraday,ftpci100-dual\",\n\t\t.data = &faraday_dual,\n\t},\n\t{},\n};\n\nstatic struct platform_driver faraday_pci_driver = {\n\t.driver = {\n\t\t.name = \"ftpci100\",\n\t\t.of_match_table = faraday_pci_of_match,\n\t\t.suppress_bind_attrs = true,\n\t},\n\t.probe  = faraday_pci_probe,\n};\nbuiltin_platform_driver(faraday_pci_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}