{
  "module_name": "pci-mvebu.c",
  "hash_id": "e909faabb2be9ce6abc4f92e64cebe3f080ceed9fea016f17b271249b96ee6e7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/controller/pci-mvebu.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/init.h>\n#include <linux/irqchip/chained_irq.h>\n#include <linux/irqdomain.h>\n#include <linux/mbus.h>\n#include <linux/slab.h>\n#include <linux/platform_device.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/of_pci.h>\n#include <linux/of_platform.h>\n\n#include \"../pci.h\"\n#include \"../pci-bridge-emul.h\"\n\n \n#define PCIE_DEV_ID_OFF\t\t0x0000\n#define PCIE_CMD_OFF\t\t0x0004\n#define PCIE_DEV_REV_OFF\t0x0008\n#define PCIE_BAR_LO_OFF(n)\t(0x0010 + ((n) << 3))\n#define PCIE_BAR_HI_OFF(n)\t(0x0014 + ((n) << 3))\n#define PCIE_SSDEV_ID_OFF\t0x002c\n#define PCIE_CAP_PCIEXP\t\t0x0060\n#define PCIE_CAP_PCIERR_OFF\t0x0100\n#define PCIE_BAR_CTRL_OFF(n)\t(0x1804 + (((n) - 1) * 4))\n#define PCIE_WIN04_CTRL_OFF(n)\t(0x1820 + ((n) << 4))\n#define PCIE_WIN04_BASE_OFF(n)\t(0x1824 + ((n) << 4))\n#define PCIE_WIN04_REMAP_OFF(n)\t(0x182c + ((n) << 4))\n#define PCIE_WIN5_CTRL_OFF\t0x1880\n#define PCIE_WIN5_BASE_OFF\t0x1884\n#define PCIE_WIN5_REMAP_OFF\t0x188c\n#define PCIE_CONF_ADDR_OFF\t0x18f8\n#define  PCIE_CONF_ADDR_EN\t\t0x80000000\n#define  PCIE_CONF_REG(r)\t\t((((r) & 0xf00) << 16) | ((r) & 0xfc))\n#define  PCIE_CONF_BUS(b)\t\t(((b) & 0xff) << 16)\n#define  PCIE_CONF_DEV(d)\t\t(((d) & 0x1f) << 11)\n#define  PCIE_CONF_FUNC(f)\t\t(((f) & 0x7) << 8)\n#define  PCIE_CONF_ADDR(bus, devfn, where) \\\n\t(PCIE_CONF_BUS(bus) | PCIE_CONF_DEV(PCI_SLOT(devfn))    | \\\n\t PCIE_CONF_FUNC(PCI_FUNC(devfn)) | PCIE_CONF_REG(where) | \\\n\t PCIE_CONF_ADDR_EN)\n#define PCIE_CONF_DATA_OFF\t0x18fc\n#define PCIE_INT_CAUSE_OFF\t0x1900\n#define PCIE_INT_UNMASK_OFF\t0x1910\n#define  PCIE_INT_INTX(i)\t\tBIT(24+i)\n#define  PCIE_INT_PM_PME\t\tBIT(28)\n#define  PCIE_INT_ALL_MASK\t\tGENMASK(31, 0)\n#define PCIE_CTRL_OFF\t\t0x1a00\n#define  PCIE_CTRL_X1_MODE\t\t0x0001\n#define  PCIE_CTRL_RC_MODE\t\tBIT(1)\n#define  PCIE_CTRL_MASTER_HOT_RESET\tBIT(24)\n#define PCIE_STAT_OFF\t\t0x1a04\n#define  PCIE_STAT_BUS                  0xff00\n#define  PCIE_STAT_DEV                  0x1f0000\n#define  PCIE_STAT_LINK_DOWN\t\tBIT(0)\n#define PCIE_SSPL_OFF\t\t0x1a0c\n#define  PCIE_SSPL_VALUE_SHIFT\t\t0\n#define  PCIE_SSPL_VALUE_MASK\t\tGENMASK(7, 0)\n#define  PCIE_SSPL_SCALE_SHIFT\t\t8\n#define  PCIE_SSPL_SCALE_MASK\t\tGENMASK(9, 8)\n#define  PCIE_SSPL_ENABLE\t\tBIT(16)\n#define PCIE_RC_RTSTA\t\t0x1a14\n#define PCIE_DEBUG_CTRL         0x1a60\n#define  PCIE_DEBUG_SOFT_RESET\t\tBIT(20)\n\nstruct mvebu_pcie_port;\n\n \nstruct mvebu_pcie {\n\tstruct platform_device *pdev;\n\tstruct mvebu_pcie_port *ports;\n\tstruct resource io;\n\tstruct resource realio;\n\tstruct resource mem;\n\tint nports;\n};\n\nstruct mvebu_pcie_window {\n\tphys_addr_t base;\n\tphys_addr_t remap;\n\tsize_t size;\n};\n\n \nstruct mvebu_pcie_port {\n\tchar *name;\n\tvoid __iomem *base;\n\tu32 port;\n\tu32 lane;\n\tbool is_x4;\n\tint devfn;\n\tunsigned int mem_target;\n\tunsigned int mem_attr;\n\tunsigned int io_target;\n\tunsigned int io_attr;\n\tstruct clk *clk;\n\tstruct gpio_desc *reset_gpio;\n\tchar *reset_name;\n\tstruct pci_bridge_emul bridge;\n\tstruct device_node *dn;\n\tstruct mvebu_pcie *pcie;\n\tstruct mvebu_pcie_window memwin;\n\tstruct mvebu_pcie_window iowin;\n\tu32 saved_pcie_stat;\n\tstruct resource regs;\n\tu8 slot_power_limit_value;\n\tu8 slot_power_limit_scale;\n\tstruct irq_domain *intx_irq_domain;\n\traw_spinlock_t irq_lock;\n\tint intx_irq;\n};\n\nstatic inline void mvebu_writel(struct mvebu_pcie_port *port, u32 val, u32 reg)\n{\n\twritel(val, port->base + reg);\n}\n\nstatic inline u32 mvebu_readl(struct mvebu_pcie_port *port, u32 reg)\n{\n\treturn readl(port->base + reg);\n}\n\nstatic inline bool mvebu_has_ioport(struct mvebu_pcie_port *port)\n{\n\treturn port->io_target != -1 && port->io_attr != -1;\n}\n\nstatic bool mvebu_pcie_link_up(struct mvebu_pcie_port *port)\n{\n\treturn !(mvebu_readl(port, PCIE_STAT_OFF) & PCIE_STAT_LINK_DOWN);\n}\n\nstatic u8 mvebu_pcie_get_local_bus_nr(struct mvebu_pcie_port *port)\n{\n\treturn (mvebu_readl(port, PCIE_STAT_OFF) & PCIE_STAT_BUS) >> 8;\n}\n\nstatic void mvebu_pcie_set_local_bus_nr(struct mvebu_pcie_port *port, int nr)\n{\n\tu32 stat;\n\n\tstat = mvebu_readl(port, PCIE_STAT_OFF);\n\tstat &= ~PCIE_STAT_BUS;\n\tstat |= nr << 8;\n\tmvebu_writel(port, stat, PCIE_STAT_OFF);\n}\n\nstatic void mvebu_pcie_set_local_dev_nr(struct mvebu_pcie_port *port, int nr)\n{\n\tu32 stat;\n\n\tstat = mvebu_readl(port, PCIE_STAT_OFF);\n\tstat &= ~PCIE_STAT_DEV;\n\tstat |= nr << 16;\n\tmvebu_writel(port, stat, PCIE_STAT_OFF);\n}\n\nstatic void mvebu_pcie_disable_wins(struct mvebu_pcie_port *port)\n{\n\tint i;\n\n\tmvebu_writel(port, 0, PCIE_BAR_LO_OFF(0));\n\tmvebu_writel(port, 0, PCIE_BAR_HI_OFF(0));\n\n\tfor (i = 1; i < 3; i++) {\n\t\tmvebu_writel(port, 0, PCIE_BAR_CTRL_OFF(i));\n\t\tmvebu_writel(port, 0, PCIE_BAR_LO_OFF(i));\n\t\tmvebu_writel(port, 0, PCIE_BAR_HI_OFF(i));\n\t}\n\n\tfor (i = 0; i < 5; i++) {\n\t\tmvebu_writel(port, 0, PCIE_WIN04_CTRL_OFF(i));\n\t\tmvebu_writel(port, 0, PCIE_WIN04_BASE_OFF(i));\n\t\tmvebu_writel(port, 0, PCIE_WIN04_REMAP_OFF(i));\n\t}\n\n\tmvebu_writel(port, 0, PCIE_WIN5_CTRL_OFF);\n\tmvebu_writel(port, 0, PCIE_WIN5_BASE_OFF);\n\tmvebu_writel(port, 0, PCIE_WIN5_REMAP_OFF);\n}\n\n \nstatic void mvebu_pcie_setup_wins(struct mvebu_pcie_port *port)\n{\n\tconst struct mbus_dram_target_info *dram;\n\tu32 size;\n\tint i;\n\n\tdram = mv_mbus_dram_info();\n\n\t \n\tmvebu_pcie_disable_wins(port);\n\n\t \n\tsize = 0;\n\tfor (i = 0; i < dram->num_cs; i++) {\n\t\tconst struct mbus_dram_window *cs = dram->cs + i;\n\n\t\tmvebu_writel(port, cs->base & 0xffff0000,\n\t\t\t     PCIE_WIN04_BASE_OFF(i));\n\t\tmvebu_writel(port, 0, PCIE_WIN04_REMAP_OFF(i));\n\t\tmvebu_writel(port,\n\t\t\t     ((cs->size - 1) & 0xffff0000) |\n\t\t\t     (cs->mbus_attr << 8) |\n\t\t\t     (dram->mbus_dram_target_id << 4) | 1,\n\t\t\t     PCIE_WIN04_CTRL_OFF(i));\n\n\t\tsize += cs->size;\n\t}\n\n\t \n\tif ((size & (size - 1)) != 0)\n\t\tsize = 1 << fls(size);\n\n\t \n\tmvebu_writel(port, dram->cs[0].base, PCIE_BAR_LO_OFF(1));\n\tmvebu_writel(port, 0, PCIE_BAR_HI_OFF(1));\n\tmvebu_writel(port, ((size - 1) & 0xffff0000) | 1,\n\t\t     PCIE_BAR_CTRL_OFF(1));\n\n\t \n\tmvebu_writel(port, round_down(port->regs.start, SZ_1M), PCIE_BAR_LO_OFF(0));\n\tmvebu_writel(port, 0, PCIE_BAR_HI_OFF(0));\n}\n\nstatic void mvebu_pcie_setup_hw(struct mvebu_pcie_port *port)\n{\n\tu32 ctrl, lnkcap, cmd, dev_rev, unmask, sspl;\n\n\t \n\tctrl = mvebu_readl(port, PCIE_CTRL_OFF);\n\tctrl |= PCIE_CTRL_RC_MODE;\n\tmvebu_writel(port, ctrl, PCIE_CTRL_OFF);\n\n\t \n\tlnkcap = mvebu_readl(port, PCIE_CAP_PCIEXP + PCI_EXP_LNKCAP);\n\tlnkcap &= ~PCI_EXP_LNKCAP_MLW;\n\tlnkcap |= FIELD_PREP(PCI_EXP_LNKCAP_MLW, port->is_x4 ? 4 : 1);\n\tmvebu_writel(port, lnkcap, PCIE_CAP_PCIEXP + PCI_EXP_LNKCAP);\n\n\t \n\tcmd = mvebu_readl(port, PCIE_CMD_OFF);\n\tcmd &= ~(PCI_COMMAND_IO | PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER);\n\tmvebu_writel(port, cmd, PCIE_CMD_OFF);\n\n\t \n\tdev_rev = mvebu_readl(port, PCIE_DEV_REV_OFF);\n\tdev_rev &= ~0xffffff00;\n\tdev_rev |= PCI_CLASS_BRIDGE_PCI_NORMAL << 8;\n\tmvebu_writel(port, dev_rev, PCIE_DEV_REV_OFF);\n\n\t \n\tmvebu_pcie_setup_wins(port);\n\n\t \n\tsspl = mvebu_readl(port, PCIE_SSPL_OFF);\n\tsspl &= ~(PCIE_SSPL_VALUE_MASK | PCIE_SSPL_SCALE_MASK | PCIE_SSPL_ENABLE);\n\tif (port->slot_power_limit_value) {\n\t\tsspl |= port->slot_power_limit_value << PCIE_SSPL_VALUE_SHIFT;\n\t\tsspl |= port->slot_power_limit_scale << PCIE_SSPL_SCALE_SHIFT;\n\t\tsspl |= PCIE_SSPL_ENABLE;\n\t}\n\tmvebu_writel(port, sspl, PCIE_SSPL_OFF);\n\n\t \n\tmvebu_writel(port, ~PCIE_INT_ALL_MASK, PCIE_INT_UNMASK_OFF);\n\n\t \n\tmvebu_writel(port, ~PCIE_INT_ALL_MASK, PCIE_INT_CAUSE_OFF);\n\n\t \n\tif (port->intx_irq > 0)\n\t\treturn;\n\n\t \n\tunmask = mvebu_readl(port, PCIE_INT_UNMASK_OFF);\n\tunmask |= PCIE_INT_INTX(0) | PCIE_INT_INTX(1) |\n\t\t  PCIE_INT_INTX(2) | PCIE_INT_INTX(3);\n\tmvebu_writel(port, unmask, PCIE_INT_UNMASK_OFF);\n}\n\nstatic struct mvebu_pcie_port *mvebu_pcie_find_port(struct mvebu_pcie *pcie,\n\t\t\t\t\t\t    struct pci_bus *bus,\n\t\t\t\t\t\t    int devfn);\n\nstatic int mvebu_pcie_child_rd_conf(struct pci_bus *bus, u32 devfn, int where,\n\t\t\t\t    int size, u32 *val)\n{\n\tstruct mvebu_pcie *pcie = bus->sysdata;\n\tstruct mvebu_pcie_port *port;\n\tvoid __iomem *conf_data;\n\n\tport = mvebu_pcie_find_port(pcie, bus, devfn);\n\tif (!port)\n\t\treturn PCIBIOS_DEVICE_NOT_FOUND;\n\n\tif (!mvebu_pcie_link_up(port))\n\t\treturn PCIBIOS_DEVICE_NOT_FOUND;\n\n\tconf_data = port->base + PCIE_CONF_DATA_OFF;\n\n\tmvebu_writel(port, PCIE_CONF_ADDR(bus->number, devfn, where),\n\t\t     PCIE_CONF_ADDR_OFF);\n\n\tswitch (size) {\n\tcase 1:\n\t\t*val = readb_relaxed(conf_data + (where & 3));\n\t\tbreak;\n\tcase 2:\n\t\t*val = readw_relaxed(conf_data + (where & 2));\n\t\tbreak;\n\tcase 4:\n\t\t*val = readl_relaxed(conf_data);\n\t\tbreak;\n\tdefault:\n\t\treturn PCIBIOS_BAD_REGISTER_NUMBER;\n\t}\n\n\treturn PCIBIOS_SUCCESSFUL;\n}\n\nstatic int mvebu_pcie_child_wr_conf(struct pci_bus *bus, u32 devfn,\n\t\t\t\t    int where, int size, u32 val)\n{\n\tstruct mvebu_pcie *pcie = bus->sysdata;\n\tstruct mvebu_pcie_port *port;\n\tvoid __iomem *conf_data;\n\n\tport = mvebu_pcie_find_port(pcie, bus, devfn);\n\tif (!port)\n\t\treturn PCIBIOS_DEVICE_NOT_FOUND;\n\n\tif (!mvebu_pcie_link_up(port))\n\t\treturn PCIBIOS_DEVICE_NOT_FOUND;\n\n\tconf_data = port->base + PCIE_CONF_DATA_OFF;\n\n\tmvebu_writel(port, PCIE_CONF_ADDR(bus->number, devfn, where),\n\t\t     PCIE_CONF_ADDR_OFF);\n\n\tswitch (size) {\n\tcase 1:\n\t\twriteb(val, conf_data + (where & 3));\n\t\tbreak;\n\tcase 2:\n\t\twritew(val, conf_data + (where & 2));\n\t\tbreak;\n\tcase 4:\n\t\twritel(val, conf_data);\n\t\tbreak;\n\tdefault:\n\t\treturn PCIBIOS_BAD_REGISTER_NUMBER;\n\t}\n\n\treturn PCIBIOS_SUCCESSFUL;\n}\n\nstatic struct pci_ops mvebu_pcie_child_ops = {\n\t.read = mvebu_pcie_child_rd_conf,\n\t.write = mvebu_pcie_child_wr_conf,\n};\n\n \nstatic void mvebu_pcie_del_windows(struct mvebu_pcie_port *port,\n\t\t\t\t   phys_addr_t base, size_t size)\n{\n\twhile (size) {\n\t\tsize_t sz = 1 << (fls(size) - 1);\n\n\t\tmvebu_mbus_del_window(base, sz);\n\t\tbase += sz;\n\t\tsize -= sz;\n\t}\n}\n\n \nstatic int mvebu_pcie_add_windows(struct mvebu_pcie_port *port,\n\t\t\t\t   unsigned int target, unsigned int attribute,\n\t\t\t\t   phys_addr_t base, size_t size,\n\t\t\t\t   phys_addr_t remap)\n{\n\tsize_t size_mapped = 0;\n\n\twhile (size) {\n\t\tsize_t sz = 1 << (fls(size) - 1);\n\t\tint ret;\n\n\t\tret = mvebu_mbus_add_window_remap_by_id(target, attribute, base,\n\t\t\t\t\t\t\tsz, remap);\n\t\tif (ret) {\n\t\t\tphys_addr_t end = base + sz - 1;\n\n\t\t\tdev_err(&port->pcie->pdev->dev,\n\t\t\t\t\"Could not create MBus window at [mem %pa-%pa]: %d\\n\",\n\t\t\t\t&base, &end, ret);\n\t\t\tmvebu_pcie_del_windows(port, base - size_mapped,\n\t\t\t\t\t       size_mapped);\n\t\t\treturn ret;\n\t\t}\n\n\t\tsize -= sz;\n\t\tsize_mapped += sz;\n\t\tbase += sz;\n\t\tif (remap != MVEBU_MBUS_NO_REMAP)\n\t\t\tremap += sz;\n\t}\n\n\treturn 0;\n}\n\nstatic int mvebu_pcie_set_window(struct mvebu_pcie_port *port,\n\t\t\t\t  unsigned int target, unsigned int attribute,\n\t\t\t\t  const struct mvebu_pcie_window *desired,\n\t\t\t\t  struct mvebu_pcie_window *cur)\n{\n\tint ret;\n\n\tif (desired->base == cur->base && desired->remap == cur->remap &&\n\t    desired->size == cur->size)\n\t\treturn 0;\n\n\tif (cur->size != 0) {\n\t\tmvebu_pcie_del_windows(port, cur->base, cur->size);\n\t\tcur->size = 0;\n\t\tcur->base = 0;\n\n\t\t \n\t}\n\n\tif (desired->size == 0)\n\t\treturn 0;\n\n\tret = mvebu_pcie_add_windows(port, target, attribute, desired->base,\n\t\t\t\t     desired->size, desired->remap);\n\tif (ret) {\n\t\tcur->size = 0;\n\t\tcur->base = 0;\n\t\treturn ret;\n\t}\n\n\t*cur = *desired;\n\treturn 0;\n}\n\nstatic int mvebu_pcie_handle_iobase_change(struct mvebu_pcie_port *port)\n{\n\tstruct mvebu_pcie_window desired = {};\n\tstruct pci_bridge_emul_conf *conf = &port->bridge.conf;\n\n\t \n\tif (conf->iolimit < conf->iobase ||\n\t    le16_to_cpu(conf->iolimitupper) < le16_to_cpu(conf->iobaseupper))\n\t\treturn mvebu_pcie_set_window(port, port->io_target, port->io_attr,\n\t\t\t\t\t     &desired, &port->iowin);\n\n\t \n\tdesired.remap = ((conf->iobase & 0xF0) << 8) |\n\t\t\t(le16_to_cpu(conf->iobaseupper) << 16);\n\tdesired.base = port->pcie->io.start + desired.remap;\n\tdesired.size = ((0xFFF | ((conf->iolimit & 0xF0) << 8) |\n\t\t\t (le16_to_cpu(conf->iolimitupper) << 16)) -\n\t\t\tdesired.remap) +\n\t\t       1;\n\n\treturn mvebu_pcie_set_window(port, port->io_target, port->io_attr, &desired,\n\t\t\t\t     &port->iowin);\n}\n\nstatic int mvebu_pcie_handle_membase_change(struct mvebu_pcie_port *port)\n{\n\tstruct mvebu_pcie_window desired = {.remap = MVEBU_MBUS_NO_REMAP};\n\tstruct pci_bridge_emul_conf *conf = &port->bridge.conf;\n\n\t \n\tif (le16_to_cpu(conf->memlimit) < le16_to_cpu(conf->membase))\n\t\treturn mvebu_pcie_set_window(port, port->mem_target, port->mem_attr,\n\t\t\t\t\t     &desired, &port->memwin);\n\n\t \n\tdesired.base = ((le16_to_cpu(conf->membase) & 0xFFF0) << 16);\n\tdesired.size = (((le16_to_cpu(conf->memlimit) & 0xFFF0) << 16) | 0xFFFFF) -\n\t\t       desired.base + 1;\n\n\treturn mvebu_pcie_set_window(port, port->mem_target, port->mem_attr, &desired,\n\t\t\t\t     &port->memwin);\n}\n\nstatic pci_bridge_emul_read_status_t\nmvebu_pci_bridge_emul_base_conf_read(struct pci_bridge_emul *bridge,\n\t\t\t\t     int reg, u32 *value)\n{\n\tstruct mvebu_pcie_port *port = bridge->data;\n\n\tswitch (reg) {\n\tcase PCI_COMMAND:\n\t\t*value = mvebu_readl(port, PCIE_CMD_OFF);\n\t\tbreak;\n\n\tcase PCI_PRIMARY_BUS: {\n\t\t \n\t\t__le32 *cfgspace = (__le32 *)&bridge->conf;\n\t\tu32 val = le32_to_cpu(cfgspace[PCI_PRIMARY_BUS / 4]);\n\t\tval &= ~0xff00;\n\t\tval |= mvebu_pcie_get_local_bus_nr(port) << 8;\n\t\t*value = val;\n\t\tbreak;\n\t}\n\n\tcase PCI_INTERRUPT_LINE: {\n\t\t \n\t\t__le32 *cfgspace = (__le32 *)&bridge->conf;\n\t\tu32 val = le32_to_cpu(cfgspace[PCI_INTERRUPT_LINE / 4]);\n\t\tif (mvebu_readl(port, PCIE_CTRL_OFF) & PCIE_CTRL_MASTER_HOT_RESET)\n\t\t\tval |= PCI_BRIDGE_CTL_BUS_RESET << 16;\n\t\telse\n\t\t\tval &= ~(PCI_BRIDGE_CTL_BUS_RESET << 16);\n\t\t*value = val;\n\t\tbreak;\n\t}\n\n\tdefault:\n\t\treturn PCI_BRIDGE_EMUL_NOT_HANDLED;\n\t}\n\n\treturn PCI_BRIDGE_EMUL_HANDLED;\n}\n\nstatic pci_bridge_emul_read_status_t\nmvebu_pci_bridge_emul_pcie_conf_read(struct pci_bridge_emul *bridge,\n\t\t\t\t     int reg, u32 *value)\n{\n\tstruct mvebu_pcie_port *port = bridge->data;\n\n\tswitch (reg) {\n\tcase PCI_EXP_DEVCAP:\n\t\t*value = mvebu_readl(port, PCIE_CAP_PCIEXP + PCI_EXP_DEVCAP);\n\t\tbreak;\n\n\tcase PCI_EXP_DEVCTL:\n\t\t*value = mvebu_readl(port, PCIE_CAP_PCIEXP + PCI_EXP_DEVCTL);\n\t\tbreak;\n\n\tcase PCI_EXP_LNKCAP:\n\t\t \n\t\t*value = (mvebu_readl(port, PCIE_CAP_PCIEXP + PCI_EXP_LNKCAP) &\n\t\t\t  ~PCI_EXP_LNKCAP_CLKPM) | PCI_EXP_LNKCAP_DLLLARC;\n\t\tbreak;\n\n\tcase PCI_EXP_LNKCTL:\n\t\t \n\t\t*value = mvebu_readl(port, PCIE_CAP_PCIEXP + PCI_EXP_LNKCTL) |\n\t\t\t (mvebu_pcie_link_up(port) ?\n\t\t\t  (PCI_EXP_LNKSTA_DLLLA << 16) : 0);\n\t\tbreak;\n\n\tcase PCI_EXP_SLTCTL: {\n\t\tu16 slotctl = le16_to_cpu(bridge->pcie_conf.slotctl);\n\t\tu16 slotsta = le16_to_cpu(bridge->pcie_conf.slotsta);\n\t\tu32 val = 0;\n\t\t \n\t\tif (!port->slot_power_limit_value)\n\t\t\tval |= slotctl & PCI_EXP_SLTCTL_ASPL_DISABLE;\n\t\telse if (!(mvebu_readl(port, PCIE_SSPL_OFF) & PCIE_SSPL_ENABLE))\n\t\t\tval |= PCI_EXP_SLTCTL_ASPL_DISABLE;\n\t\t \n\t\tval |= slotsta << 16;\n\t\t*value = val;\n\t\tbreak;\n\t}\n\n\tcase PCI_EXP_RTSTA:\n\t\t*value = mvebu_readl(port, PCIE_RC_RTSTA);\n\t\tbreak;\n\n\tcase PCI_EXP_DEVCAP2:\n\t\t*value = mvebu_readl(port, PCIE_CAP_PCIEXP + PCI_EXP_DEVCAP2);\n\t\tbreak;\n\n\tcase PCI_EXP_DEVCTL2:\n\t\t*value = mvebu_readl(port, PCIE_CAP_PCIEXP + PCI_EXP_DEVCTL2);\n\t\tbreak;\n\n\tcase PCI_EXP_LNKCTL2:\n\t\t*value = mvebu_readl(port, PCIE_CAP_PCIEXP + PCI_EXP_LNKCTL2);\n\t\tbreak;\n\n\tdefault:\n\t\treturn PCI_BRIDGE_EMUL_NOT_HANDLED;\n\t}\n\n\treturn PCI_BRIDGE_EMUL_HANDLED;\n}\n\nstatic pci_bridge_emul_read_status_t\nmvebu_pci_bridge_emul_ext_conf_read(struct pci_bridge_emul *bridge,\n\t\t\t\t    int reg, u32 *value)\n{\n\tstruct mvebu_pcie_port *port = bridge->data;\n\n\tswitch (reg) {\n\tcase 0:\n\tcase PCI_ERR_UNCOR_STATUS:\n\tcase PCI_ERR_UNCOR_MASK:\n\tcase PCI_ERR_UNCOR_SEVER:\n\tcase PCI_ERR_COR_STATUS:\n\tcase PCI_ERR_COR_MASK:\n\tcase PCI_ERR_CAP:\n\tcase PCI_ERR_HEADER_LOG+0:\n\tcase PCI_ERR_HEADER_LOG+4:\n\tcase PCI_ERR_HEADER_LOG+8:\n\tcase PCI_ERR_HEADER_LOG+12:\n\tcase PCI_ERR_ROOT_COMMAND:\n\tcase PCI_ERR_ROOT_STATUS:\n\tcase PCI_ERR_ROOT_ERR_SRC:\n\t\t*value = mvebu_readl(port, PCIE_CAP_PCIERR_OFF + reg);\n\t\tbreak;\n\n\tdefault:\n\t\treturn PCI_BRIDGE_EMUL_NOT_HANDLED;\n\t}\n\n\treturn PCI_BRIDGE_EMUL_HANDLED;\n}\n\nstatic void\nmvebu_pci_bridge_emul_base_conf_write(struct pci_bridge_emul *bridge,\n\t\t\t\t      int reg, u32 old, u32 new, u32 mask)\n{\n\tstruct mvebu_pcie_port *port = bridge->data;\n\tstruct pci_bridge_emul_conf *conf = &bridge->conf;\n\n\tswitch (reg) {\n\tcase PCI_COMMAND:\n\t\tmvebu_writel(port, new, PCIE_CMD_OFF);\n\t\tbreak;\n\n\tcase PCI_IO_BASE:\n\t\tif ((mask & 0xffff) && mvebu_has_ioport(port) &&\n\t\t    mvebu_pcie_handle_iobase_change(port)) {\n\t\t\t \n\t\t\tconf->iobase &= ~0xf0;\n\t\t\tconf->iolimit &= ~0xf0;\n\t\t\tconf->iobase |= 0xf0;\n\t\t\tconf->iobaseupper = cpu_to_le16(0x0000);\n\t\t\tconf->iolimitupper = cpu_to_le16(0x0000);\n\t\t}\n\t\tbreak;\n\n\tcase PCI_MEMORY_BASE:\n\t\tif (mvebu_pcie_handle_membase_change(port)) {\n\t\t\t \n\t\t\tconf->membase = cpu_to_le16(le16_to_cpu(conf->membase) & ~0xfff0);\n\t\t\tconf->memlimit = cpu_to_le16(le16_to_cpu(conf->memlimit) & ~0xfff0);\n\t\t\tconf->membase = cpu_to_le16(le16_to_cpu(conf->membase) | 0xfff0);\n\t\t}\n\t\tbreak;\n\n\tcase PCI_IO_BASE_UPPER16:\n\t\tif (mvebu_has_ioport(port) &&\n\t\t    mvebu_pcie_handle_iobase_change(port)) {\n\t\t\t \n\t\t\tconf->iobase &= ~0xf0;\n\t\t\tconf->iolimit &= ~0xf0;\n\t\t\tconf->iobase |= 0xf0;\n\t\t\tconf->iobaseupper = cpu_to_le16(0x0000);\n\t\t\tconf->iolimitupper = cpu_to_le16(0x0000);\n\t\t}\n\t\tbreak;\n\n\tcase PCI_PRIMARY_BUS:\n\t\tif (mask & 0xff00)\n\t\t\tmvebu_pcie_set_local_bus_nr(port, conf->secondary_bus);\n\t\tbreak;\n\n\tcase PCI_INTERRUPT_LINE:\n\t\tif (mask & (PCI_BRIDGE_CTL_BUS_RESET << 16)) {\n\t\t\tu32 ctrl = mvebu_readl(port, PCIE_CTRL_OFF);\n\t\t\tif (new & (PCI_BRIDGE_CTL_BUS_RESET << 16))\n\t\t\t\tctrl |= PCIE_CTRL_MASTER_HOT_RESET;\n\t\t\telse\n\t\t\t\tctrl &= ~PCIE_CTRL_MASTER_HOT_RESET;\n\t\t\tmvebu_writel(port, ctrl, PCIE_CTRL_OFF);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void\nmvebu_pci_bridge_emul_pcie_conf_write(struct pci_bridge_emul *bridge,\n\t\t\t\t      int reg, u32 old, u32 new, u32 mask)\n{\n\tstruct mvebu_pcie_port *port = bridge->data;\n\n\tswitch (reg) {\n\tcase PCI_EXP_DEVCTL:\n\t\tmvebu_writel(port, new, PCIE_CAP_PCIEXP + PCI_EXP_DEVCTL);\n\t\tbreak;\n\n\tcase PCI_EXP_LNKCTL:\n\t\t \n\t\tnew &= ~PCI_EXP_LNKCTL_CLKREQ_EN;\n\n\t\tmvebu_writel(port, new, PCIE_CAP_PCIEXP + PCI_EXP_LNKCTL);\n\t\tbreak;\n\n\tcase PCI_EXP_SLTCTL:\n\t\t \n\t\tif ((mask & PCI_EXP_SLTCTL_ASPL_DISABLE) &&\n\t\t    port->slot_power_limit_value) {\n\t\t\tu32 sspl = mvebu_readl(port, PCIE_SSPL_OFF);\n\t\t\tif (new & PCI_EXP_SLTCTL_ASPL_DISABLE)\n\t\t\t\tsspl &= ~PCIE_SSPL_ENABLE;\n\t\t\telse\n\t\t\t\tsspl |= PCIE_SSPL_ENABLE;\n\t\t\tmvebu_writel(port, sspl, PCIE_SSPL_OFF);\n\t\t}\n\t\tbreak;\n\n\tcase PCI_EXP_RTSTA:\n\t\t \n\t\tif (new & PCI_EXP_RTSTA_PME)\n\t\t\tmvebu_writel(port, ~PCIE_INT_PM_PME, PCIE_INT_CAUSE_OFF);\n\t\tbreak;\n\n\tcase PCI_EXP_DEVCTL2:\n\t\tmvebu_writel(port, new, PCIE_CAP_PCIEXP + PCI_EXP_DEVCTL2);\n\t\tbreak;\n\n\tcase PCI_EXP_LNKCTL2:\n\t\tmvebu_writel(port, new, PCIE_CAP_PCIEXP + PCI_EXP_LNKCTL2);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void\nmvebu_pci_bridge_emul_ext_conf_write(struct pci_bridge_emul *bridge,\n\t\t\t\t     int reg, u32 old, u32 new, u32 mask)\n{\n\tstruct mvebu_pcie_port *port = bridge->data;\n\n\tswitch (reg) {\n\t \n\tcase PCI_ERR_UNCOR_STATUS:\n\tcase PCI_ERR_COR_STATUS:\n\tcase PCI_ERR_ROOT_STATUS:\n\t\tnew &= mask;\n\t\tfallthrough;\n\n\tcase PCI_ERR_UNCOR_MASK:\n\tcase PCI_ERR_UNCOR_SEVER:\n\tcase PCI_ERR_COR_MASK:\n\tcase PCI_ERR_CAP:\n\tcase PCI_ERR_HEADER_LOG+0:\n\tcase PCI_ERR_HEADER_LOG+4:\n\tcase PCI_ERR_HEADER_LOG+8:\n\tcase PCI_ERR_HEADER_LOG+12:\n\tcase PCI_ERR_ROOT_COMMAND:\n\tcase PCI_ERR_ROOT_ERR_SRC:\n\t\tmvebu_writel(port, new, PCIE_CAP_PCIERR_OFF + reg);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic const struct pci_bridge_emul_ops mvebu_pci_bridge_emul_ops = {\n\t.read_base = mvebu_pci_bridge_emul_base_conf_read,\n\t.write_base = mvebu_pci_bridge_emul_base_conf_write,\n\t.read_pcie = mvebu_pci_bridge_emul_pcie_conf_read,\n\t.write_pcie = mvebu_pci_bridge_emul_pcie_conf_write,\n\t.read_ext = mvebu_pci_bridge_emul_ext_conf_read,\n\t.write_ext = mvebu_pci_bridge_emul_ext_conf_write,\n};\n\n \nstatic int mvebu_pci_bridge_emul_init(struct mvebu_pcie_port *port)\n{\n\tunsigned int bridge_flags = PCI_BRIDGE_EMUL_NO_PREFMEM_FORWARD;\n\tstruct pci_bridge_emul *bridge = &port->bridge;\n\tu32 dev_id = mvebu_readl(port, PCIE_DEV_ID_OFF);\n\tu32 dev_rev = mvebu_readl(port, PCIE_DEV_REV_OFF);\n\tu32 ssdev_id = mvebu_readl(port, PCIE_SSDEV_ID_OFF);\n\tu32 pcie_cap = mvebu_readl(port, PCIE_CAP_PCIEXP);\n\tu8 pcie_cap_ver = ((pcie_cap >> 16) & PCI_EXP_FLAGS_VERS);\n\n\tbridge->conf.vendor = cpu_to_le16(dev_id & 0xffff);\n\tbridge->conf.device = cpu_to_le16(dev_id >> 16);\n\tbridge->conf.class_revision = cpu_to_le32(dev_rev & 0xff);\n\n\tif (mvebu_has_ioport(port)) {\n\t\t \n\t\tbridge->conf.iobase = PCI_IO_RANGE_TYPE_32;\n\t\tbridge->conf.iolimit = PCI_IO_RANGE_TYPE_32;\n\t} else {\n\t\tbridge_flags |= PCI_BRIDGE_EMUL_NO_IO_FORWARD;\n\t}\n\n\t \n\tbridge->pcie_conf.cap = cpu_to_le16(pcie_cap_ver | PCI_EXP_FLAGS_SLOT);\n\n\t \n\tbridge->pcie_conf.slotcap = cpu_to_le32(\n\t\tFIELD_PREP(PCI_EXP_SLTCAP_SPLV, port->slot_power_limit_value) |\n\t\tFIELD_PREP(PCI_EXP_SLTCAP_SPLS, port->slot_power_limit_scale) |\n\t\tFIELD_PREP(PCI_EXP_SLTCAP_PSN, port->port+1));\n\tbridge->pcie_conf.slotsta = cpu_to_le16(PCI_EXP_SLTSTA_PDS);\n\n\tbridge->subsystem_vendor_id = ssdev_id & 0xffff;\n\tbridge->subsystem_id = ssdev_id >> 16;\n\tbridge->has_pcie = true;\n\tbridge->pcie_start = PCIE_CAP_PCIEXP;\n\tbridge->data = port;\n\tbridge->ops = &mvebu_pci_bridge_emul_ops;\n\n\treturn pci_bridge_emul_init(bridge, bridge_flags);\n}\n\nstatic inline struct mvebu_pcie *sys_to_pcie(struct pci_sys_data *sys)\n{\n\treturn sys->private_data;\n}\n\nstatic struct mvebu_pcie_port *mvebu_pcie_find_port(struct mvebu_pcie *pcie,\n\t\t\t\t\t\t    struct pci_bus *bus,\n\t\t\t\t\t\t    int devfn)\n{\n\tint i;\n\n\tfor (i = 0; i < pcie->nports; i++) {\n\t\tstruct mvebu_pcie_port *port = &pcie->ports[i];\n\n\t\tif (!port->base)\n\t\t\tcontinue;\n\n\t\tif (bus->number == 0 && port->devfn == devfn)\n\t\t\treturn port;\n\t\tif (bus->number != 0 &&\n\t\t    bus->number >= port->bridge.conf.secondary_bus &&\n\t\t    bus->number <= port->bridge.conf.subordinate_bus)\n\t\t\treturn port;\n\t}\n\n\treturn NULL;\n}\n\n \nstatic int mvebu_pcie_wr_conf(struct pci_bus *bus, u32 devfn,\n\t\t\t      int where, int size, u32 val)\n{\n\tstruct mvebu_pcie *pcie = bus->sysdata;\n\tstruct mvebu_pcie_port *port;\n\n\tport = mvebu_pcie_find_port(pcie, bus, devfn);\n\tif (!port)\n\t\treturn PCIBIOS_DEVICE_NOT_FOUND;\n\n\treturn pci_bridge_emul_conf_write(&port->bridge, where, size, val);\n}\n\n \nstatic int mvebu_pcie_rd_conf(struct pci_bus *bus, u32 devfn, int where,\n\t\t\t      int size, u32 *val)\n{\n\tstruct mvebu_pcie *pcie = bus->sysdata;\n\tstruct mvebu_pcie_port *port;\n\n\tport = mvebu_pcie_find_port(pcie, bus, devfn);\n\tif (!port)\n\t\treturn PCIBIOS_DEVICE_NOT_FOUND;\n\n\treturn pci_bridge_emul_conf_read(&port->bridge, where, size, val);\n}\n\nstatic struct pci_ops mvebu_pcie_ops = {\n\t.read = mvebu_pcie_rd_conf,\n\t.write = mvebu_pcie_wr_conf,\n};\n\nstatic void mvebu_pcie_intx_irq_mask(struct irq_data *d)\n{\n\tstruct mvebu_pcie_port *port = d->domain->host_data;\n\tirq_hw_number_t hwirq = irqd_to_hwirq(d);\n\tunsigned long flags;\n\tu32 unmask;\n\n\traw_spin_lock_irqsave(&port->irq_lock, flags);\n\tunmask = mvebu_readl(port, PCIE_INT_UNMASK_OFF);\n\tunmask &= ~PCIE_INT_INTX(hwirq);\n\tmvebu_writel(port, unmask, PCIE_INT_UNMASK_OFF);\n\traw_spin_unlock_irqrestore(&port->irq_lock, flags);\n}\n\nstatic void mvebu_pcie_intx_irq_unmask(struct irq_data *d)\n{\n\tstruct mvebu_pcie_port *port = d->domain->host_data;\n\tirq_hw_number_t hwirq = irqd_to_hwirq(d);\n\tunsigned long flags;\n\tu32 unmask;\n\n\traw_spin_lock_irqsave(&port->irq_lock, flags);\n\tunmask = mvebu_readl(port, PCIE_INT_UNMASK_OFF);\n\tunmask |= PCIE_INT_INTX(hwirq);\n\tmvebu_writel(port, unmask, PCIE_INT_UNMASK_OFF);\n\traw_spin_unlock_irqrestore(&port->irq_lock, flags);\n}\n\nstatic struct irq_chip intx_irq_chip = {\n\t.name = \"mvebu-INTx\",\n\t.irq_mask = mvebu_pcie_intx_irq_mask,\n\t.irq_unmask = mvebu_pcie_intx_irq_unmask,\n};\n\nstatic int mvebu_pcie_intx_irq_map(struct irq_domain *h,\n\t\t\t\t   unsigned int virq, irq_hw_number_t hwirq)\n{\n\tstruct mvebu_pcie_port *port = h->host_data;\n\n\tirq_set_status_flags(virq, IRQ_LEVEL);\n\tirq_set_chip_and_handler(virq, &intx_irq_chip, handle_level_irq);\n\tirq_set_chip_data(virq, port);\n\n\treturn 0;\n}\n\nstatic const struct irq_domain_ops mvebu_pcie_intx_irq_domain_ops = {\n\t.map = mvebu_pcie_intx_irq_map,\n\t.xlate = irq_domain_xlate_onecell,\n};\n\nstatic int mvebu_pcie_init_irq_domain(struct mvebu_pcie_port *port)\n{\n\tstruct device *dev = &port->pcie->pdev->dev;\n\tstruct device_node *pcie_intc_node;\n\n\traw_spin_lock_init(&port->irq_lock);\n\n\tpcie_intc_node = of_get_next_child(port->dn, NULL);\n\tif (!pcie_intc_node) {\n\t\tdev_err(dev, \"No PCIe Intc node found for %s\\n\", port->name);\n\t\treturn -ENODEV;\n\t}\n\n\tport->intx_irq_domain = irq_domain_add_linear(pcie_intc_node, PCI_NUM_INTX,\n\t\t\t\t\t\t      &mvebu_pcie_intx_irq_domain_ops,\n\t\t\t\t\t\t      port);\n\tof_node_put(pcie_intc_node);\n\tif (!port->intx_irq_domain) {\n\t\tdev_err(dev, \"Failed to get INTx IRQ domain for %s\\n\", port->name);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic void mvebu_pcie_irq_handler(struct irq_desc *desc)\n{\n\tstruct mvebu_pcie_port *port = irq_desc_get_handler_data(desc);\n\tstruct irq_chip *chip = irq_desc_get_chip(desc);\n\tstruct device *dev = &port->pcie->pdev->dev;\n\tu32 cause, unmask, status;\n\tint i;\n\n\tchained_irq_enter(chip, desc);\n\n\tcause = mvebu_readl(port, PCIE_INT_CAUSE_OFF);\n\tunmask = mvebu_readl(port, PCIE_INT_UNMASK_OFF);\n\tstatus = cause & unmask;\n\n\t \n\tfor (i = 0; i < PCI_NUM_INTX; i++) {\n\t\tif (!(status & PCIE_INT_INTX(i)))\n\t\t\tcontinue;\n\n\t\tif (generic_handle_domain_irq(port->intx_irq_domain, i) == -EINVAL)\n\t\t\tdev_err_ratelimited(dev, \"unexpected INT%c IRQ\\n\", (char)i+'A');\n\t}\n\n\tchained_irq_exit(chip, desc);\n}\n\nstatic int mvebu_pcie_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)\n{\n\t \n\tif (dev->bus->number == 0)\n\t\treturn 0;  \n\n\treturn of_irq_parse_and_map_pci(dev, slot, pin);\n}\n\nstatic resource_size_t mvebu_pcie_align_resource(struct pci_dev *dev,\n\t\t\t\t\t\t const struct resource *res,\n\t\t\t\t\t\t resource_size_t start,\n\t\t\t\t\t\t resource_size_t size,\n\t\t\t\t\t\t resource_size_t align)\n{\n\tif (dev->bus->number != 0)\n\t\treturn start;\n\n\t \n\tif (res->flags & IORESOURCE_IO)\n\t\treturn round_up(start, max_t(resource_size_t, SZ_64K,\n\t\t\t\t\t     rounddown_pow_of_two(size)));\n\telse if (res->flags & IORESOURCE_MEM)\n\t\treturn round_up(start, max_t(resource_size_t, SZ_1M,\n\t\t\t\t\t     rounddown_pow_of_two(size)));\n\telse\n\t\treturn start;\n}\n\nstatic void __iomem *mvebu_pcie_map_registers(struct platform_device *pdev,\n\t\t\t\t\t      struct device_node *np,\n\t\t\t\t\t      struct mvebu_pcie_port *port)\n{\n\tint ret = 0;\n\n\tret = of_address_to_resource(np, 0, &port->regs);\n\tif (ret)\n\t\treturn (void __iomem *)ERR_PTR(ret);\n\n\treturn devm_ioremap_resource(&pdev->dev, &port->regs);\n}\n\n#define DT_FLAGS_TO_TYPE(flags)       (((flags) >> 24) & 0x03)\n#define    DT_TYPE_IO                 0x1\n#define    DT_TYPE_MEM32              0x2\n#define DT_CPUADDR_TO_TARGET(cpuaddr) (((cpuaddr) >> 56) & 0xFF)\n#define DT_CPUADDR_TO_ATTR(cpuaddr)   (((cpuaddr) >> 48) & 0xFF)\n\nstatic int mvebu_get_tgt_attr(struct device_node *np, int devfn,\n\t\t\t      unsigned long type,\n\t\t\t      unsigned int *tgt,\n\t\t\t      unsigned int *attr)\n{\n\tconst int na = 3, ns = 2;\n\tconst __be32 *range;\n\tint rlen, nranges, rangesz, pna, i;\n\n\t*tgt = -1;\n\t*attr = -1;\n\n\trange = of_get_property(np, \"ranges\", &rlen);\n\tif (!range)\n\t\treturn -EINVAL;\n\n\tpna = of_n_addr_cells(np);\n\trangesz = pna + na + ns;\n\tnranges = rlen / sizeof(__be32) / rangesz;\n\n\tfor (i = 0; i < nranges; i++, range += rangesz) {\n\t\tu32 flags = of_read_number(range, 1);\n\t\tu32 slot = of_read_number(range + 1, 1);\n\t\tu64 cpuaddr = of_read_number(range + na, pna);\n\t\tunsigned long rtype;\n\n\t\tif (DT_FLAGS_TO_TYPE(flags) == DT_TYPE_IO)\n\t\t\trtype = IORESOURCE_IO;\n\t\telse if (DT_FLAGS_TO_TYPE(flags) == DT_TYPE_MEM32)\n\t\t\trtype = IORESOURCE_MEM;\n\t\telse\n\t\t\tcontinue;\n\n\t\tif (slot == PCI_SLOT(devfn) && type == rtype) {\n\t\t\t*tgt = DT_CPUADDR_TO_TARGET(cpuaddr);\n\t\t\t*attr = DT_CPUADDR_TO_ATTR(cpuaddr);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -ENOENT;\n}\n\nstatic int mvebu_pcie_suspend(struct device *dev)\n{\n\tstruct mvebu_pcie *pcie;\n\tint i;\n\n\tpcie = dev_get_drvdata(dev);\n\tfor (i = 0; i < pcie->nports; i++) {\n\t\tstruct mvebu_pcie_port *port = pcie->ports + i;\n\t\tif (!port->base)\n\t\t\tcontinue;\n\t\tport->saved_pcie_stat = mvebu_readl(port, PCIE_STAT_OFF);\n\t}\n\n\treturn 0;\n}\n\nstatic int mvebu_pcie_resume(struct device *dev)\n{\n\tstruct mvebu_pcie *pcie;\n\tint i;\n\n\tpcie = dev_get_drvdata(dev);\n\tfor (i = 0; i < pcie->nports; i++) {\n\t\tstruct mvebu_pcie_port *port = pcie->ports + i;\n\t\tif (!port->base)\n\t\t\tcontinue;\n\t\tmvebu_writel(port, port->saved_pcie_stat, PCIE_STAT_OFF);\n\t\tmvebu_pcie_setup_hw(port);\n\t}\n\n\treturn 0;\n}\n\nstatic void mvebu_pcie_port_clk_put(void *data)\n{\n\tstruct mvebu_pcie_port *port = data;\n\n\tclk_put(port->clk);\n}\n\nstatic int mvebu_pcie_parse_port(struct mvebu_pcie *pcie,\n\tstruct mvebu_pcie_port *port, struct device_node *child)\n{\n\tstruct device *dev = &pcie->pdev->dev;\n\tu32 slot_power_limit;\n\tint ret;\n\tu32 num_lanes;\n\n\tport->pcie = pcie;\n\n\tif (of_property_read_u32(child, \"marvell,pcie-port\", &port->port)) {\n\t\tdev_warn(dev, \"ignoring %pOF, missing pcie-port property\\n\",\n\t\t\t child);\n\t\tgoto skip;\n\t}\n\n\tif (of_property_read_u32(child, \"marvell,pcie-lane\", &port->lane))\n\t\tport->lane = 0;\n\n\tif (!of_property_read_u32(child, \"num-lanes\", &num_lanes) && num_lanes == 4)\n\t\tport->is_x4 = true;\n\n\tport->name = devm_kasprintf(dev, GFP_KERNEL, \"pcie%d.%d\", port->port,\n\t\t\t\t    port->lane);\n\tif (!port->name) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tport->devfn = of_pci_get_devfn(child);\n\tif (port->devfn < 0)\n\t\tgoto skip;\n\tif (PCI_FUNC(port->devfn) != 0) {\n\t\tdev_err(dev, \"%s: invalid function number, must be zero\\n\",\n\t\t\tport->name);\n\t\tgoto skip;\n\t}\n\n\tret = mvebu_get_tgt_attr(dev->of_node, port->devfn, IORESOURCE_MEM,\n\t\t\t\t &port->mem_target, &port->mem_attr);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"%s: cannot get tgt/attr for mem window\\n\",\n\t\t\tport->name);\n\t\tgoto skip;\n\t}\n\n\tif (resource_size(&pcie->io) != 0) {\n\t\tmvebu_get_tgt_attr(dev->of_node, port->devfn, IORESOURCE_IO,\n\t\t\t\t   &port->io_target, &port->io_attr);\n\t} else {\n\t\tport->io_target = -1;\n\t\tport->io_attr = -1;\n\t}\n\n\t \n\tport->intx_irq = of_irq_get_byname(child, \"intx\");\n\tif (port->intx_irq == -EPROBE_DEFER) {\n\t\tret = port->intx_irq;\n\t\tgoto err;\n\t}\n\tif (port->intx_irq <= 0) {\n\t\tdev_warn(dev, \"%s: legacy INTx interrupts cannot be masked individually, \"\n\t\t\t      \"%pOF does not contain intx interrupt\\n\",\n\t\t\t port->name, child);\n\t}\n\n\tport->reset_name = devm_kasprintf(dev, GFP_KERNEL, \"%s-reset\",\n\t\t\t\t\t  port->name);\n\tif (!port->reset_name) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tport->reset_gpio = devm_fwnode_gpiod_get(dev, of_fwnode_handle(child),\n\t\t\t\t\t\t \"reset\", GPIOD_OUT_HIGH,\n\t\t\t\t\t\t port->name);\n\tret = PTR_ERR_OR_ZERO(port->reset_gpio);\n\tif (ret) {\n\t\tif (ret != -ENOENT)\n\t\t\tgoto err;\n\t\t \n\t\tport->reset_gpio = NULL;\n\t\tdevm_kfree(dev, port->reset_name);\n\t\tport->reset_name = NULL;\n\t}\n\n\tslot_power_limit = of_pci_get_slot_power_limit(child,\n\t\t\t\t&port->slot_power_limit_value,\n\t\t\t\t&port->slot_power_limit_scale);\n\tif (slot_power_limit)\n\t\tdev_info(dev, \"%s: Slot power limit %u.%uW\\n\",\n\t\t\t port->name,\n\t\t\t slot_power_limit / 1000,\n\t\t\t (slot_power_limit / 100) % 10);\n\n\tport->clk = of_clk_get_by_name(child, NULL);\n\tif (IS_ERR(port->clk)) {\n\t\tdev_err(dev, \"%s: cannot get clock\\n\", port->name);\n\t\tgoto skip;\n\t}\n\n\tret = devm_add_action(dev, mvebu_pcie_port_clk_put, port);\n\tif (ret < 0) {\n\t\tclk_put(port->clk);\n\t\tgoto err;\n\t}\n\n\treturn 1;\n\nskip:\n\tret = 0;\n\n\t \n\tdevm_kfree(dev, port->reset_name);\n\tport->reset_name = NULL;\n\tdevm_kfree(dev, port->name);\n\tport->name = NULL;\n\nerr:\n\treturn ret;\n}\n\n \nstatic int mvebu_pcie_powerup(struct mvebu_pcie_port *port)\n{\n\tint ret;\n\n\tret = clk_prepare_enable(port->clk);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (port->reset_gpio) {\n\t\tu32 reset_udelay = PCI_PM_D3COLD_WAIT * 1000;\n\n\t\tof_property_read_u32(port->dn, \"reset-delay-us\",\n\t\t\t\t     &reset_udelay);\n\n\t\tudelay(100);\n\n\t\tgpiod_set_value_cansleep(port->reset_gpio, 0);\n\t\tmsleep(reset_udelay / 1000);\n\t}\n\n\treturn 0;\n}\n\n \nstatic void mvebu_pcie_powerdown(struct mvebu_pcie_port *port)\n{\n\tgpiod_set_value_cansleep(port->reset_gpio, 1);\n\n\tclk_disable_unprepare(port->clk);\n}\n\n \nstatic int mvebu_pcie_parse_request_resources(struct mvebu_pcie *pcie)\n{\n\tstruct device *dev = &pcie->pdev->dev;\n\tstruct pci_host_bridge *bridge = pci_host_bridge_from_priv(pcie);\n\tint ret;\n\n\t \n\tmvebu_mbus_get_pcie_mem_aperture(&pcie->mem);\n\tif (resource_size(&pcie->mem) == 0) {\n\t\tdev_err(dev, \"invalid memory aperture size\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpcie->mem.name = \"PCI MEM\";\n\tpci_add_resource(&bridge->windows, &pcie->mem);\n\tret = devm_request_resource(dev, &iomem_resource, &pcie->mem);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tmvebu_mbus_get_pcie_io_aperture(&pcie->io);\n\n\tif (resource_size(&pcie->io) != 0) {\n\t\tpcie->realio.flags = pcie->io.flags;\n\t\tpcie->realio.start = PCIBIOS_MIN_IO;\n\t\tpcie->realio.end = min_t(resource_size_t,\n\t\t\t\t\t IO_SPACE_LIMIT - SZ_64K,\n\t\t\t\t\t resource_size(&pcie->io) - 1);\n\t\tpcie->realio.name = \"PCI I/O\";\n\n\t\tret = devm_pci_remap_iospace(dev, &pcie->realio, pcie->io.start);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tpci_add_resource(&bridge->windows, &pcie->realio);\n\t\tret = devm_request_resource(dev, &ioport_resource, &pcie->realio);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int mvebu_pcie_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct mvebu_pcie *pcie;\n\tstruct pci_host_bridge *bridge;\n\tstruct device_node *np = dev->of_node;\n\tstruct device_node *child;\n\tint num, i, ret;\n\n\tbridge = devm_pci_alloc_host_bridge(dev, sizeof(struct mvebu_pcie));\n\tif (!bridge)\n\t\treturn -ENOMEM;\n\n\tpcie = pci_host_bridge_priv(bridge);\n\tpcie->pdev = pdev;\n\tplatform_set_drvdata(pdev, pcie);\n\n\tret = mvebu_pcie_parse_request_resources(pcie);\n\tif (ret)\n\t\treturn ret;\n\n\tnum = of_get_available_child_count(np);\n\n\tpcie->ports = devm_kcalloc(dev, num, sizeof(*pcie->ports), GFP_KERNEL);\n\tif (!pcie->ports)\n\t\treturn -ENOMEM;\n\n\ti = 0;\n\tfor_each_available_child_of_node(np, child) {\n\t\tstruct mvebu_pcie_port *port = &pcie->ports[i];\n\n\t\tret = mvebu_pcie_parse_port(pcie, port, child);\n\t\tif (ret < 0) {\n\t\t\tof_node_put(child);\n\t\t\treturn ret;\n\t\t} else if (ret == 0) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tport->dn = child;\n\t\ti++;\n\t}\n\tpcie->nports = i;\n\n\tfor (i = 0; i < pcie->nports; i++) {\n\t\tstruct mvebu_pcie_port *port = &pcie->ports[i];\n\t\tint irq = port->intx_irq;\n\n\t\tchild = port->dn;\n\t\tif (!child)\n\t\t\tcontinue;\n\n\t\tret = mvebu_pcie_powerup(port);\n\t\tif (ret < 0)\n\t\t\tcontinue;\n\n\t\tport->base = mvebu_pcie_map_registers(pdev, child, port);\n\t\tif (IS_ERR(port->base)) {\n\t\t\tdev_err(dev, \"%s: cannot map registers\\n\", port->name);\n\t\t\tport->base = NULL;\n\t\t\tmvebu_pcie_powerdown(port);\n\t\t\tcontinue;\n\t\t}\n\n\t\tret = mvebu_pci_bridge_emul_init(port);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"%s: cannot init emulated bridge\\n\",\n\t\t\t\tport->name);\n\t\t\tdevm_iounmap(dev, port->base);\n\t\t\tport->base = NULL;\n\t\t\tmvebu_pcie_powerdown(port);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (irq > 0) {\n\t\t\tret = mvebu_pcie_init_irq_domain(port);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(dev, \"%s: cannot init irq domain\\n\",\n\t\t\t\t\tport->name);\n\t\t\t\tpci_bridge_emul_cleanup(&port->bridge);\n\t\t\t\tdevm_iounmap(dev, port->base);\n\t\t\t\tport->base = NULL;\n\t\t\t\tmvebu_pcie_powerdown(port);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tirq_set_chained_handler_and_data(irq,\n\t\t\t\t\t\t\t mvebu_pcie_irq_handler,\n\t\t\t\t\t\t\t port);\n\t\t}\n\n\t\t \n\t\tmvebu_pcie_setup_hw(port);\n\t\tmvebu_pcie_set_local_dev_nr(port, 1);\n\t\tmvebu_pcie_set_local_bus_nr(port, 0);\n\t}\n\n\tbridge->sysdata = pcie;\n\tbridge->ops = &mvebu_pcie_ops;\n\tbridge->child_ops = &mvebu_pcie_child_ops;\n\tbridge->align_resource = mvebu_pcie_align_resource;\n\tbridge->map_irq = mvebu_pcie_map_irq;\n\n\treturn pci_host_probe(bridge);\n}\n\nstatic void mvebu_pcie_remove(struct platform_device *pdev)\n{\n\tstruct mvebu_pcie *pcie = platform_get_drvdata(pdev);\n\tstruct pci_host_bridge *bridge = pci_host_bridge_from_priv(pcie);\n\tu32 cmd, sspl;\n\tint i;\n\n\t \n\tpci_lock_rescan_remove();\n\tpci_stop_root_bus(bridge->bus);\n\tpci_remove_root_bus(bridge->bus);\n\tpci_unlock_rescan_remove();\n\n\tfor (i = 0; i < pcie->nports; i++) {\n\t\tstruct mvebu_pcie_port *port = &pcie->ports[i];\n\t\tint irq = port->intx_irq;\n\n\t\tif (!port->base)\n\t\t\tcontinue;\n\n\t\t \n\t\tcmd = mvebu_readl(port, PCIE_CMD_OFF);\n\t\tcmd &= ~(PCI_COMMAND_IO | PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER);\n\t\tmvebu_writel(port, cmd, PCIE_CMD_OFF);\n\n\t\t \n\t\tmvebu_writel(port, ~PCIE_INT_ALL_MASK, PCIE_INT_UNMASK_OFF);\n\n\t\t \n\t\tmvebu_writel(port, ~PCIE_INT_ALL_MASK, PCIE_INT_CAUSE_OFF);\n\n\t\tif (irq > 0)\n\t\t\tirq_set_chained_handler_and_data(irq, NULL, NULL);\n\n\t\t \n\t\tif (port->intx_irq_domain)\n\t\t\tirq_domain_remove(port->intx_irq_domain);\n\n\t\t \n\t\tpci_bridge_emul_cleanup(&port->bridge);\n\n\t\t \n\t\tsspl = mvebu_readl(port, PCIE_SSPL_OFF);\n\t\tsspl &= ~(PCIE_SSPL_VALUE_MASK | PCIE_SSPL_SCALE_MASK | PCIE_SSPL_ENABLE);\n\t\tmvebu_writel(port, sspl, PCIE_SSPL_OFF);\n\n\t\t \n\t\tmvebu_pcie_disable_wins(port);\n\n\t\t \n\t\tif (port->iowin.size)\n\t\t\tmvebu_pcie_del_windows(port, port->iowin.base, port->iowin.size);\n\t\tif (port->memwin.size)\n\t\t\tmvebu_pcie_del_windows(port, port->memwin.base, port->memwin.size);\n\n\t\t \n\t\tmvebu_pcie_powerdown(port);\n\t}\n}\n\nstatic const struct of_device_id mvebu_pcie_of_match_table[] = {\n\t{ .compatible = \"marvell,armada-xp-pcie\", },\n\t{ .compatible = \"marvell,armada-370-pcie\", },\n\t{ .compatible = \"marvell,dove-pcie\", },\n\t{ .compatible = \"marvell,kirkwood-pcie\", },\n\t{},\n};\n\nstatic const struct dev_pm_ops mvebu_pcie_pm_ops = {\n\tNOIRQ_SYSTEM_SLEEP_PM_OPS(mvebu_pcie_suspend, mvebu_pcie_resume)\n};\n\nstatic struct platform_driver mvebu_pcie_driver = {\n\t.driver = {\n\t\t.name = \"mvebu-pcie\",\n\t\t.of_match_table = mvebu_pcie_of_match_table,\n\t\t.pm = &mvebu_pcie_pm_ops,\n\t},\n\t.probe = mvebu_pcie_probe,\n\t.remove_new = mvebu_pcie_remove,\n};\nmodule_platform_driver(mvebu_pcie_driver);\n\nMODULE_AUTHOR(\"Thomas Petazzoni <thomas.petazzoni@bootlin.com>\");\nMODULE_AUTHOR(\"Pali Roh\u00e1r <pali@kernel.org>\");\nMODULE_DESCRIPTION(\"Marvell EBU PCIe controller\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}