{
  "module_name": "pci-thunder-pem.c",
  "hash_id": "21bbe2f72cd37ac8724b809a050ce6d63a77b62b77ee068dbe9fa5b0ef1c7002",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/controller/pci-thunder-pem.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/pci.h>\n#include <linux/of_address.h>\n#include <linux/of_pci.h>\n#include <linux/pci-acpi.h>\n#include <linux/pci-ecam.h>\n#include <linux/platform_device.h>\n#include <linux/io-64-nonatomic-lo-hi.h>\n#include \"../pci.h\"\n\n#if defined(CONFIG_PCI_HOST_THUNDER_PEM) || (defined(CONFIG_ACPI) && defined(CONFIG_PCI_QUIRKS))\n\n#define PEM_CFG_WR 0x28\n#define PEM_CFG_RD 0x30\n\n \n#define THUNDER_PCIE_ECAM_BUS_SHIFT\t24\n\nstruct thunder_pem_pci {\n\tu32\t\tea_entry[3];\n\tvoid __iomem\t*pem_reg_base;\n};\n\nstatic int thunder_pem_bridge_read(struct pci_bus *bus, unsigned int devfn,\n\t\t\t\t   int where, int size, u32 *val)\n{\n\tu64 read_val, tmp_val;\n\tstruct pci_config_window *cfg = bus->sysdata;\n\tstruct thunder_pem_pci *pem_pci = (struct thunder_pem_pci *)cfg->priv;\n\n\tif (devfn != 0 || where >= 2048)\n\t\treturn PCIBIOS_DEVICE_NOT_FOUND;\n\n\t \n\tread_val = where & ~3ull;\n\twriteq(read_val, pem_pci->pem_reg_base + PEM_CFG_RD);\n\tread_val = readq(pem_pci->pem_reg_base + PEM_CFG_RD);\n\tread_val >>= 32;\n\n\t \n\tswitch (where & ~3) {\n\tcase 0x40:\n\t\tread_val &= 0xffff00ff;\n\t\tread_val |= 0x00007000;  \n\t\tbreak;\n\tcase 0x70:  \n\t\t \n\t\tif (!(read_val & (0x1f << 25)))\n\t\t\tread_val |= (2u << 25);\n\t\tbreak;\n\tcase 0xb0:  \n\t\t \n\t\tread_val &= 0xc00000ff;\n\t\t \n\t\twriteq(0x70, pem_pci->pem_reg_base + PEM_CFG_RD);\n\t\ttmp_val = readq(pem_pci->pem_reg_base + PEM_CFG_RD);\n\t\ttmp_val >>= 32;\n\t\tif (!(tmp_val & (0x1f << 25)))\n\t\t\tread_val |= 0x0003bc00;\n\t\telse\n\t\t\tread_val |= 0x0001bc00;\n\t\tbreak;\n\tcase 0xb4:\n\t\t \n\t\tread_val = 0x00000000;\n\t\tbreak;\n\tcase 0xb8:\n\t\t \n\t\tread_val = 0x000f0000;\n\t\tbreak;\n\tcase 0xbc:\n\t\t \n\t\tread_val = 0x00010014;\n\t\tbreak;\n\tcase 0xc0:\n\t\t \n\t\tread_val = 0x00000000;\n\t\tbreak;\n\tcase 0xc4:\n\t\t \n\t\tread_val = 0x80ff0003;\n\t\tbreak;\n\tcase 0xc8:\n\t\tread_val = pem_pci->ea_entry[0];\n\t\tbreak;\n\tcase 0xcc:\n\t\tread_val = pem_pci->ea_entry[1];\n\t\tbreak;\n\tcase 0xd0:\n\t\tread_val = pem_pci->ea_entry[2];\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tread_val >>= (8 * (where & 3));\n\tswitch (size) {\n\tcase 1:\n\t\tread_val &= 0xff;\n\t\tbreak;\n\tcase 2:\n\t\tread_val &= 0xffff;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\t*val = read_val;\n\treturn PCIBIOS_SUCCESSFUL;\n}\n\nstatic int thunder_pem_config_read(struct pci_bus *bus, unsigned int devfn,\n\t\t\t\t   int where, int size, u32 *val)\n{\n\tstruct pci_config_window *cfg = bus->sysdata;\n\n\tif (bus->number < cfg->busr.start ||\n\t    bus->number > cfg->busr.end)\n\t\treturn PCIBIOS_DEVICE_NOT_FOUND;\n\n\t \n\tif (bus->number == cfg->busr.start)\n\t\treturn thunder_pem_bridge_read(bus, devfn, where, size, val);\n\n\treturn pci_generic_config_read(bus, devfn, where, size, val);\n}\n\n \nstatic u32 thunder_pem_bridge_w1c_bits(u64 where_aligned)\n{\n\tu32 w1c_bits = 0;\n\n\tswitch (where_aligned) {\n\tcase 0x04:  \n\tcase 0x1c:  \n\t\tw1c_bits = 0xff000000;\n\t\tbreak;\n\tcase 0x44:  \n\t\tw1c_bits = 0xfffffe00;\n\t\tbreak;\n\tcase 0x78:  \n\tcase 0x80:  \n\tcase 0x88:  \n\tcase 0x90:  \n\tcase 0xa0:  \n\t\tw1c_bits = 0xffff0000;\n\t\tbreak;\n\tcase 0x104:  \n\tcase 0x110:  \n\tcase 0x130:  \n\tcase 0x160:  \n\t\tw1c_bits = 0xffffffff;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn w1c_bits;\n}\n\n \nstatic u32 thunder_pem_bridge_w1_bits(u64 where_aligned)\n{\n\tu32 w1_bits;\n\n\tswitch (where_aligned) {\n\tcase 0x1c:  \n\t\t \n\t\tw1_bits = 0x0101;\n\t\tbreak;\n\tcase 0x24:  \n\t\t \n\t\tw1_bits = 0x00010001;\n\t\tbreak;\n\tdefault:\n\t\tw1_bits = 0;\n\t\tbreak;\n\t}\n\treturn w1_bits;\n}\n\nstatic int thunder_pem_bridge_write(struct pci_bus *bus, unsigned int devfn,\n\t\t\t\t    int where, int size, u32 val)\n{\n\tstruct pci_config_window *cfg = bus->sysdata;\n\tstruct thunder_pem_pci *pem_pci = (struct thunder_pem_pci *)cfg->priv;\n\tu64 write_val, read_val;\n\tu64 where_aligned = where & ~3ull;\n\tu32 mask = 0;\n\n\n\tif (devfn != 0 || where >= 2048)\n\t\treturn PCIBIOS_DEVICE_NOT_FOUND;\n\n\t \n\tswitch (size) {\n\tcase 1:\n\t\twriteq(where_aligned, pem_pci->pem_reg_base + PEM_CFG_RD);\n\t\tread_val = readq(pem_pci->pem_reg_base + PEM_CFG_RD);\n\t\tread_val >>= 32;\n\t\tmask = ~(0xff << (8 * (where & 3)));\n\t\tread_val &= mask;\n\t\tval = (val & 0xff) << (8 * (where & 3));\n\t\tval |= (u32)read_val;\n\t\tbreak;\n\tcase 2:\n\t\twriteq(where_aligned, pem_pci->pem_reg_base + PEM_CFG_RD);\n\t\tread_val = readq(pem_pci->pem_reg_base + PEM_CFG_RD);\n\t\tread_val >>= 32;\n\t\tmask = ~(0xffff << (8 * (where & 3)));\n\t\tread_val &= mask;\n\t\tval = (val & 0xffff) << (8 * (where & 3));\n\t\tval |= (u32)read_val;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tif (mask) {\n\t\tu32 w1c_bits = thunder_pem_bridge_w1c_bits(where);\n\n\t\tif (w1c_bits) {\n\t\t\tmask &= w1c_bits;\n\t\t\tval &= ~mask;\n\t\t}\n\t}\n\n\t \n\tval |= thunder_pem_bridge_w1_bits(where_aligned);\n\n\t \n\twrite_val = (((u64)val) << 32) | where_aligned;\n\twriteq(write_val, pem_pci->pem_reg_base + PEM_CFG_WR);\n\treturn PCIBIOS_SUCCESSFUL;\n}\n\nstatic int thunder_pem_config_write(struct pci_bus *bus, unsigned int devfn,\n\t\t\t\t    int where, int size, u32 val)\n{\n\tstruct pci_config_window *cfg = bus->sysdata;\n\n\tif (bus->number < cfg->busr.start ||\n\t    bus->number > cfg->busr.end)\n\t\treturn PCIBIOS_DEVICE_NOT_FOUND;\n\t \n\tif (bus->number == cfg->busr.start)\n\t\treturn thunder_pem_bridge_write(bus, devfn, where, size, val);\n\n\n\treturn pci_generic_config_write(bus, devfn, where, size, val);\n}\n\nstatic int thunder_pem_init(struct device *dev, struct pci_config_window *cfg,\n\t\t\t    struct resource *res_pem)\n{\n\tstruct thunder_pem_pci *pem_pci;\n\tresource_size_t bar4_start;\n\n\tpem_pci = devm_kzalloc(dev, sizeof(*pem_pci), GFP_KERNEL);\n\tif (!pem_pci)\n\t\treturn -ENOMEM;\n\n\tpem_pci->pem_reg_base = devm_ioremap(dev, res_pem->start, 0x10000);\n\tif (!pem_pci->pem_reg_base)\n\t\treturn -ENOMEM;\n\n\t \n\tbar4_start = res_pem->start + 0xf00000;\n\tpem_pci->ea_entry[0] = lower_32_bits(bar4_start) | 2;\n\tpem_pci->ea_entry[1] = lower_32_bits(res_pem->end - bar4_start) & ~3u;\n\tpem_pci->ea_entry[2] = upper_32_bits(bar4_start);\n\n\tcfg->priv = pem_pci;\n\treturn 0;\n}\n\n#if defined(CONFIG_ACPI) && defined(CONFIG_PCI_QUIRKS)\n\n#define PEM_RES_BASE\t\t0x87e0c0000000ULL\n#define PEM_NODE_MASK\t\tGENMASK_ULL(45, 44)\n#define PEM_INDX_MASK\t\tGENMASK_ULL(26, 24)\n#define PEM_MIN_DOM_IN_NODE\t4\n#define PEM_MAX_DOM_IN_NODE\t10\n\nstatic void thunder_pem_reserve_range(struct device *dev, int seg,\n\t\t\t\t      struct resource *r)\n{\n\tresource_size_t start = r->start, end = r->end;\n\tstruct resource *res;\n\tconst char *regionid;\n\n\tregionid = kasprintf(GFP_KERNEL, \"PEM RC:%d\", seg);\n\tif (!regionid)\n\t\treturn;\n\n\tres = request_mem_region(start, end - start + 1, regionid);\n\tif (res)\n\t\tres->flags &= ~IORESOURCE_BUSY;\n\telse\n\t\tkfree(regionid);\n\n\tdev_info(dev, \"%pR %s reserved\\n\", r,\n\t\t res ? \"has been\" : \"could not be\");\n}\n\nstatic void thunder_pem_legacy_fw(struct acpi_pci_root *root,\n\t\t\t\t struct resource *res_pem)\n{\n\tint node = acpi_get_node(root->device->handle);\n\tint index;\n\n\tif (node == NUMA_NO_NODE)\n\t\tnode = 0;\n\n\tindex = root->segment - PEM_MIN_DOM_IN_NODE;\n\tindex -= node * PEM_MAX_DOM_IN_NODE;\n\tres_pem->start = PEM_RES_BASE | FIELD_PREP(PEM_NODE_MASK, node) |\n\t\t\t\t\tFIELD_PREP(PEM_INDX_MASK, index);\n\tres_pem->flags = IORESOURCE_MEM;\n}\n\nstatic int thunder_pem_acpi_init(struct pci_config_window *cfg)\n{\n\tstruct device *dev = cfg->parent;\n\tstruct acpi_device *adev = to_acpi_device(dev);\n\tstruct acpi_pci_root *root = acpi_driver_data(adev);\n\tstruct resource *res_pem;\n\tint ret;\n\n\tres_pem = devm_kzalloc(&adev->dev, sizeof(*res_pem), GFP_KERNEL);\n\tif (!res_pem)\n\t\treturn -ENOMEM;\n\n\tret = acpi_get_rc_resources(dev, \"CAVA02B\", root->segment, res_pem);\n\n\t \n\tif (ret) {\n\t\tthunder_pem_legacy_fw(root, res_pem);\n\t\t \n\t\tres_pem->end = res_pem->start + SZ_64K - 1;\n\t\tthunder_pem_reserve_range(dev, root->segment, res_pem);\n\t\tres_pem->end = res_pem->start + SZ_16M - 1;\n\n\t\t \n\t\tthunder_pem_reserve_range(dev, root->segment, &cfg->res);\n\t}\n\n\treturn thunder_pem_init(dev, cfg, res_pem);\n}\n\nconst struct pci_ecam_ops thunder_pem_ecam_ops = {\n\t.bus_shift\t= THUNDER_PCIE_ECAM_BUS_SHIFT,\n\t.init\t\t= thunder_pem_acpi_init,\n\t.pci_ops\t= {\n\t\t.map_bus\t= pci_ecam_map_bus,\n\t\t.read\t\t= thunder_pem_config_read,\n\t\t.write\t\t= thunder_pem_config_write,\n\t}\n};\n\n#endif\n\n#ifdef CONFIG_PCI_HOST_THUNDER_PEM\n\nstatic int thunder_pem_platform_init(struct pci_config_window *cfg)\n{\n\tstruct device *dev = cfg->parent;\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct resource *res_pem;\n\n\tif (!dev->of_node)\n\t\treturn -EINVAL;\n\n\t \n\tres_pem = platform_get_resource(pdev, IORESOURCE_MEM, 1);\n\tif (!res_pem) {\n\t\tdev_err(dev, \"missing \\\"reg[1]\\\"property\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn thunder_pem_init(dev, cfg, res_pem);\n}\n\nstatic const struct pci_ecam_ops pci_thunder_pem_ops = {\n\t.bus_shift\t= THUNDER_PCIE_ECAM_BUS_SHIFT,\n\t.init\t\t= thunder_pem_platform_init,\n\t.pci_ops\t= {\n\t\t.map_bus\t= pci_ecam_map_bus,\n\t\t.read\t\t= thunder_pem_config_read,\n\t\t.write\t\t= thunder_pem_config_write,\n\t}\n};\n\nstatic const struct of_device_id thunder_pem_of_match[] = {\n\t{\n\t\t.compatible = \"cavium,pci-host-thunder-pem\",\n\t\t.data = &pci_thunder_pem_ops,\n\t},\n\t{ },\n};\n\nstatic struct platform_driver thunder_pem_driver = {\n\t.driver = {\n\t\t.name = KBUILD_MODNAME,\n\t\t.of_match_table = thunder_pem_of_match,\n\t\t.suppress_bind_attrs = true,\n\t},\n\t.probe = pci_host_common_probe,\n};\nbuiltin_platform_driver(thunder_pem_driver);\n\n#endif\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}