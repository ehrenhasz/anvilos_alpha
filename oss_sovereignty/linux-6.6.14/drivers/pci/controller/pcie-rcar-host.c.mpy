{
  "module_name": "pcie-rcar-host.c",
  "hash_id": "91c9aac27c1dfdca0f5c4117f76c14c07361f48cea5745f4e4a643cdca6e9441",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/controller/pcie-rcar-host.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/iopoll.h>\n#include <linux/msi.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/of_platform.h>\n#include <linux/pci.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n\n#include \"pcie-rcar.h\"\n\nstruct rcar_msi {\n\tDECLARE_BITMAP(used, INT_PCI_MSI_NR);\n\tstruct irq_domain *domain;\n\tstruct mutex map_lock;\n\tspinlock_t mask_lock;\n\tint irq1;\n\tint irq2;\n};\n\n \nstruct rcar_pcie_host {\n\tstruct rcar_pcie\tpcie;\n\tstruct phy\t\t*phy;\n\tstruct clk\t\t*bus_clk;\n\tstruct\t\t\trcar_msi msi;\n\tint\t\t\t(*phy_init_fn)(struct rcar_pcie_host *host);\n};\n\nstatic DEFINE_SPINLOCK(pmsr_lock);\n\nstatic int rcar_pcie_wakeup(struct device *pcie_dev, void __iomem *pcie_base)\n{\n\tunsigned long flags;\n\tu32 pmsr, val;\n\tint ret = 0;\n\n\tspin_lock_irqsave(&pmsr_lock, flags);\n\n\tif (!pcie_base || pm_runtime_suspended(pcie_dev)) {\n\t\tret = -EINVAL;\n\t\tgoto unlock_exit;\n\t}\n\n\tpmsr = readl(pcie_base + PMSR);\n\n\t \n\tif ((pmsr & PMEL1RX) && ((pmsr & PMSTATE) != PMSTATE_L1)) {\n\t\twritel(L1IATN, pcie_base + PMCTLR);\n\t\tret = readl_poll_timeout_atomic(pcie_base + PMSR, val,\n\t\t\t\t\t\tval & L1FAEG, 10, 1000);\n\t\tWARN(ret, \"Timeout waiting for L1 link state, ret=%d\\n\", ret);\n\t\twritel(L1FAEG | PMEL1RX, pcie_base + PMSR);\n\t}\n\nunlock_exit:\n\tspin_unlock_irqrestore(&pmsr_lock, flags);\n\treturn ret;\n}\n\nstatic struct rcar_pcie_host *msi_to_host(struct rcar_msi *msi)\n{\n\treturn container_of(msi, struct rcar_pcie_host, msi);\n}\n\nstatic u32 rcar_read_conf(struct rcar_pcie *pcie, int where)\n{\n\tunsigned int shift = BITS_PER_BYTE * (where & 3);\n\tu32 val = rcar_pci_read_reg(pcie, where & ~3);\n\n\treturn val >> shift;\n}\n\n#ifdef CONFIG_ARM\n#define __rcar_pci_rw_reg_workaround(instr)\t\t\t\t\\\n\t\t\"\t.arch armv7-a\\n\"\t\t\t\t\\\n\t\t\"1:\t\" instr \" %1, [%2]\\n\"\t\t\t\t\\\n\t\t\"2:\tisb\\n\"\t\t\t\t\t\t\\\n\t\t\"3:\t.pushsection .text.fixup,\\\"ax\\\"\\n\"\t\t\\\n\t\t\"\t.align\t2\\n\"\t\t\t\t\t\\\n\t\t\"4:\tmov\t%0, #\" __stringify(PCIBIOS_SET_FAILED) \"\\n\" \\\n\t\t\"\tb\t3b\\n\"\t\t\t\t\t\\\n\t\t\"\t.popsection\\n\"\t\t\t\t\t\\\n\t\t\"\t.pushsection __ex_table,\\\"a\\\"\\n\"\t\t\\\n\t\t\"\t.align\t3\\n\"\t\t\t\t\t\\\n\t\t\"\t.long\t1b, 4b\\n\"\t\t\t\t\\\n\t\t\"\t.long\t2b, 4b\\n\"\t\t\t\t\\\n\t\t\"\t.popsection\\n\"\n#endif\n\nstatic int rcar_pci_write_reg_workaround(struct rcar_pcie *pcie, u32 val,\n\t\t\t\t\t unsigned int reg)\n{\n\tint error = PCIBIOS_SUCCESSFUL;\n#ifdef CONFIG_ARM\n\tasm volatile(\n\t\t__rcar_pci_rw_reg_workaround(\"str\")\n\t: \"+r\"(error):\"r\"(val), \"r\"(pcie->base + reg) : \"memory\");\n#else\n\trcar_pci_write_reg(pcie, val, reg);\n#endif\n\treturn error;\n}\n\nstatic int rcar_pci_read_reg_workaround(struct rcar_pcie *pcie, u32 *val,\n\t\t\t\t\tunsigned int reg)\n{\n\tint error = PCIBIOS_SUCCESSFUL;\n#ifdef CONFIG_ARM\n\tasm volatile(\n\t\t__rcar_pci_rw_reg_workaround(\"ldr\")\n\t: \"+r\"(error), \"=r\"(*val) : \"r\"(pcie->base + reg) : \"memory\");\n\n\tif (error != PCIBIOS_SUCCESSFUL)\n\t\tPCI_SET_ERROR_RESPONSE(val);\n#else\n\t*val = rcar_pci_read_reg(pcie, reg);\n#endif\n\treturn error;\n}\n\n \nstatic int rcar_pcie_config_access(struct rcar_pcie_host *host,\n\t\tunsigned char access_type, struct pci_bus *bus,\n\t\tunsigned int devfn, int where, u32 *data)\n{\n\tstruct rcar_pcie *pcie = &host->pcie;\n\tunsigned int dev, func, reg, index;\n\tint ret;\n\n\t \n\tret = rcar_pcie_wakeup(pcie->dev, pcie->base);\n\tif (ret) {\n\t\tPCI_SET_ERROR_RESPONSE(data);\n\t\treturn PCIBIOS_SET_FAILED;\n\t}\n\n\tdev = PCI_SLOT(devfn);\n\tfunc = PCI_FUNC(devfn);\n\treg = where & ~3;\n\tindex = reg / 4;\n\n\t \n\tif (pci_is_root_bus(bus)) {\n\t\tif (dev != 0)\n\t\t\treturn PCIBIOS_DEVICE_NOT_FOUND;\n\n\t\tif (access_type == RCAR_PCI_ACCESS_READ)\n\t\t\t*data = rcar_pci_read_reg(pcie, PCICONF(index));\n\t\telse\n\t\t\trcar_pci_write_reg(pcie, *data, PCICONF(index));\n\n\t\treturn PCIBIOS_SUCCESSFUL;\n\t}\n\n\t \n\trcar_pci_write_reg(pcie, rcar_pci_read_reg(pcie, PCIEERRFR), PCIEERRFR);\n\n\t \n\trcar_pci_write_reg(pcie, PCIE_CONF_BUS(bus->number) |\n\t\tPCIE_CONF_DEV(dev) | PCIE_CONF_FUNC(func) | reg, PCIECAR);\n\n\t \n\tif (pci_is_root_bus(bus->parent))\n\t\trcar_pci_write_reg(pcie, PCIECCTLR_CCIE | TYPE0, PCIECCTLR);\n\telse\n\t\trcar_pci_write_reg(pcie, PCIECCTLR_CCIE | TYPE1, PCIECCTLR);\n\n\t \n\tif (rcar_pci_read_reg(pcie, PCIEERRFR) & UNSUPPORTED_REQUEST)\n\t\treturn PCIBIOS_DEVICE_NOT_FOUND;\n\n\t \n\tif (rcar_read_conf(pcie, RCONF(PCI_STATUS)) &\n\t\t(PCI_STATUS_REC_MASTER_ABORT | PCI_STATUS_REC_TARGET_ABORT))\n\t\treturn PCIBIOS_DEVICE_NOT_FOUND;\n\n\tif (access_type == RCAR_PCI_ACCESS_READ)\n\t\tret = rcar_pci_read_reg_workaround(pcie, data, PCIECDR);\n\telse\n\t\tret = rcar_pci_write_reg_workaround(pcie, *data, PCIECDR);\n\n\t \n\trcar_pci_write_reg(pcie, 0, PCIECCTLR);\n\n\treturn ret;\n}\n\nstatic int rcar_pcie_read_conf(struct pci_bus *bus, unsigned int devfn,\n\t\t\t       int where, int size, u32 *val)\n{\n\tstruct rcar_pcie_host *host = bus->sysdata;\n\tint ret;\n\n\tret = rcar_pcie_config_access(host, RCAR_PCI_ACCESS_READ,\n\t\t\t\t      bus, devfn, where, val);\n\tif (ret != PCIBIOS_SUCCESSFUL)\n\t\treturn ret;\n\n\tif (size == 1)\n\t\t*val = (*val >> (BITS_PER_BYTE * (where & 3))) & 0xff;\n\telse if (size == 2)\n\t\t*val = (*val >> (BITS_PER_BYTE * (where & 2))) & 0xffff;\n\n\tdev_dbg(&bus->dev, \"pcie-config-read: bus=%3d devfn=0x%04x where=0x%04x size=%d val=0x%08x\\n\",\n\t\tbus->number, devfn, where, size, *val);\n\n\treturn ret;\n}\n\n \nstatic int rcar_pcie_write_conf(struct pci_bus *bus, unsigned int devfn,\n\t\t\t\tint where, int size, u32 val)\n{\n\tstruct rcar_pcie_host *host = bus->sysdata;\n\tunsigned int shift;\n\tu32 data;\n\tint ret;\n\n\tret = rcar_pcie_config_access(host, RCAR_PCI_ACCESS_READ,\n\t\t\t\t      bus, devfn, where, &data);\n\tif (ret != PCIBIOS_SUCCESSFUL)\n\t\treturn ret;\n\n\tdev_dbg(&bus->dev, \"pcie-config-write: bus=%3d devfn=0x%04x where=0x%04x size=%d val=0x%08x\\n\",\n\t\tbus->number, devfn, where, size, val);\n\n\tif (size == 1) {\n\t\tshift = BITS_PER_BYTE * (where & 3);\n\t\tdata &= ~(0xff << shift);\n\t\tdata |= ((val & 0xff) << shift);\n\t} else if (size == 2) {\n\t\tshift = BITS_PER_BYTE * (where & 2);\n\t\tdata &= ~(0xffff << shift);\n\t\tdata |= ((val & 0xffff) << shift);\n\t} else\n\t\tdata = val;\n\n\tret = rcar_pcie_config_access(host, RCAR_PCI_ACCESS_WRITE,\n\t\t\t\t      bus, devfn, where, &data);\n\n\treturn ret;\n}\n\nstatic struct pci_ops rcar_pcie_ops = {\n\t.read\t= rcar_pcie_read_conf,\n\t.write\t= rcar_pcie_write_conf,\n};\n\nstatic void rcar_pcie_force_speedup(struct rcar_pcie *pcie)\n{\n\tstruct device *dev = pcie->dev;\n\tunsigned int timeout = 1000;\n\tu32 macsr;\n\n\tif ((rcar_pci_read_reg(pcie, MACS2R) & LINK_SPEED) != LINK_SPEED_5_0GTS)\n\t\treturn;\n\n\tif (rcar_pci_read_reg(pcie, MACCTLR) & SPEED_CHANGE) {\n\t\tdev_err(dev, \"Speed change already in progress\\n\");\n\t\treturn;\n\t}\n\n\tmacsr = rcar_pci_read_reg(pcie, MACSR);\n\tif ((macsr & LINK_SPEED) == LINK_SPEED_5_0GTS)\n\t\tgoto done;\n\n\t \n\trcar_rmw32(pcie, EXPCAP(12), PCI_EXP_LNKSTA_CLS,\n\t\t   PCI_EXP_LNKSTA_CLS_5_0GB);\n\n\t \n\trcar_rmw32(pcie, MACCGSPSETR, SPCNGRSN, 0);\n\n\t \n\tif (macsr & (SPCHGFIN | SPCHGSUC | SPCHGFAIL))\n\t\trcar_pci_write_reg(pcie, macsr, MACSR);\n\n\t \n\trcar_rmw32(pcie, MACCTLR, SPEED_CHANGE, SPEED_CHANGE);\n\n\twhile (timeout--) {\n\t\tmacsr = rcar_pci_read_reg(pcie, MACSR);\n\t\tif (macsr & SPCHGFIN) {\n\t\t\t \n\t\t\trcar_pci_write_reg(pcie, macsr, MACSR);\n\n\t\t\tif (macsr & SPCHGFAIL)\n\t\t\t\tdev_err(dev, \"Speed change failed\\n\");\n\n\t\t\tgoto done;\n\t\t}\n\n\t\tmsleep(1);\n\t}\n\n\tdev_err(dev, \"Speed change timed out\\n\");\n\ndone:\n\tdev_info(dev, \"Current link speed is %s GT/s\\n\",\n\t\t (macsr & LINK_SPEED) == LINK_SPEED_5_0GTS ? \"5\" : \"2.5\");\n}\n\nstatic void rcar_pcie_hw_enable(struct rcar_pcie_host *host)\n{\n\tstruct rcar_pcie *pcie = &host->pcie;\n\tstruct pci_host_bridge *bridge = pci_host_bridge_from_priv(host);\n\tstruct resource_entry *win;\n\tLIST_HEAD(res);\n\tint i = 0;\n\n\t \n\trcar_pcie_force_speedup(pcie);\n\n\t \n\tresource_list_for_each_entry(win, &bridge->windows) {\n\t\tstruct resource *res = win->res;\n\n\t\tif (!res->flags)\n\t\t\tcontinue;\n\n\t\tswitch (resource_type(res)) {\n\t\tcase IORESOURCE_IO:\n\t\tcase IORESOURCE_MEM:\n\t\t\trcar_pcie_set_outbound(pcie, i, win);\n\t\t\ti++;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic int rcar_pcie_enable(struct rcar_pcie_host *host)\n{\n\tstruct pci_host_bridge *bridge = pci_host_bridge_from_priv(host);\n\n\trcar_pcie_hw_enable(host);\n\n\tpci_add_flags(PCI_REASSIGN_ALL_BUS);\n\n\tbridge->sysdata = host;\n\tbridge->ops = &rcar_pcie_ops;\n\n\treturn pci_host_probe(bridge);\n}\n\nstatic int phy_wait_for_ack(struct rcar_pcie *pcie)\n{\n\tstruct device *dev = pcie->dev;\n\tunsigned int timeout = 100;\n\n\twhile (timeout--) {\n\t\tif (rcar_pci_read_reg(pcie, H1_PCIEPHYADRR) & PHY_ACK)\n\t\t\treturn 0;\n\n\t\tudelay(100);\n\t}\n\n\tdev_err(dev, \"Access to PCIe phy timed out\\n\");\n\n\treturn -ETIMEDOUT;\n}\n\nstatic void phy_write_reg(struct rcar_pcie *pcie,\n\t\t\t  unsigned int rate, u32 addr,\n\t\t\t  unsigned int lane, u32 data)\n{\n\tu32 phyaddr;\n\n\tphyaddr = WRITE_CMD |\n\t\t((rate & 1) << RATE_POS) |\n\t\t((lane & 0xf) << LANE_POS) |\n\t\t((addr & 0xff) << ADR_POS);\n\n\t \n\trcar_pci_write_reg(pcie, data, H1_PCIEPHYDOUTR);\n\trcar_pci_write_reg(pcie, phyaddr, H1_PCIEPHYADRR);\n\n\t \n\tphy_wait_for_ack(pcie);\n\n\t \n\trcar_pci_write_reg(pcie, 0, H1_PCIEPHYDOUTR);\n\trcar_pci_write_reg(pcie, 0, H1_PCIEPHYADRR);\n\n\t \n\tphy_wait_for_ack(pcie);\n}\n\nstatic int rcar_pcie_hw_init(struct rcar_pcie *pcie)\n{\n\tint err;\n\n\t \n\trcar_pci_write_reg(pcie, 0, PCIETCTLR);\n\n\t \n\trcar_pci_write_reg(pcie, 1, PCIEMSR);\n\n\terr = rcar_pcie_wait_for_phyrdy(pcie);\n\tif (err)\n\t\treturn err;\n\n\t \n\trcar_pci_write_reg(pcie, PCI_CLASS_BRIDGE_PCI_NORMAL << 8, IDSETR1);\n\n\t \n\trcar_rmw32(pcie, RCONF(PCI_SECONDARY_BUS), 0xff, 1);\n\trcar_rmw32(pcie, RCONF(PCI_SUBORDINATE_BUS), 0xff, 1);\n\n\t \n\trcar_rmw32(pcie, REXPCAP(0), 0xff, PCI_CAP_ID_EXP);\n\trcar_rmw32(pcie, REXPCAP(PCI_EXP_FLAGS),\n\t\tPCI_EXP_FLAGS_TYPE, PCI_EXP_TYPE_ROOT_PORT << 4);\n\trcar_rmw32(pcie, RCONF(PCI_HEADER_TYPE), 0x7f,\n\t\tPCI_HEADER_TYPE_BRIDGE);\n\n\t \n\trcar_rmw32(pcie, REXPCAP(PCI_EXP_LNKCAP), PCI_EXP_LNKCAP_DLLLARC,\n\t\tPCI_EXP_LNKCAP_DLLLARC);\n\n\t \n\trcar_rmw32(pcie, REXPCAP(PCI_EXP_SLTCAP), PCI_EXP_SLTCAP_PSN, 0);\n\n\t \n\trcar_rmw32(pcie, TLCTLR + 1, 0x3f, 50);\n\n\t \n\trcar_rmw32(pcie, RVCCAP(0), 0xfff00000, 0);\n\n\t \n\tif (IS_ENABLED(CONFIG_PCI_MSI))\n\t\trcar_pci_write_reg(pcie, 0x801f0000, PCIEMSITXR);\n\n\trcar_pci_write_reg(pcie, MACCTLR_INIT_VAL, MACCTLR);\n\n\t \n\trcar_pci_write_reg(pcie, CFINIT, PCIETCTLR);\n\n\t \n\terr = rcar_pcie_wait_for_dl(pcie);\n\tif (err)\n\t\treturn err;\n\n\t \n\trcar_rmw32(pcie, PCIEINTXR, 0, 0xF << 8);\n\n\twmb();\n\n\treturn 0;\n}\n\nstatic int rcar_pcie_phy_init_h1(struct rcar_pcie_host *host)\n{\n\tstruct rcar_pcie *pcie = &host->pcie;\n\n\t \n\tphy_write_reg(pcie, 0, 0x42, 0x1, 0x0EC34191);\n\tphy_write_reg(pcie, 1, 0x42, 0x1, 0x0EC34180);\n\tphy_write_reg(pcie, 0, 0x43, 0x1, 0x00210188);\n\tphy_write_reg(pcie, 1, 0x43, 0x1, 0x00210188);\n\tphy_write_reg(pcie, 0, 0x44, 0x1, 0x015C0014);\n\tphy_write_reg(pcie, 1, 0x44, 0x1, 0x015C0014);\n\tphy_write_reg(pcie, 1, 0x4C, 0x1, 0x786174A0);\n\tphy_write_reg(pcie, 1, 0x4D, 0x1, 0x048000BB);\n\tphy_write_reg(pcie, 0, 0x51, 0x1, 0x079EC062);\n\tphy_write_reg(pcie, 0, 0x52, 0x1, 0x20000000);\n\tphy_write_reg(pcie, 1, 0x52, 0x1, 0x20000000);\n\tphy_write_reg(pcie, 1, 0x56, 0x1, 0x00003806);\n\n\tphy_write_reg(pcie, 0, 0x60, 0x1, 0x004B03A5);\n\tphy_write_reg(pcie, 0, 0x64, 0x1, 0x3F0F1F0F);\n\tphy_write_reg(pcie, 0, 0x66, 0x1, 0x00008000);\n\n\treturn 0;\n}\n\nstatic int rcar_pcie_phy_init_gen2(struct rcar_pcie_host *host)\n{\n\tstruct rcar_pcie *pcie = &host->pcie;\n\n\t \n\trcar_pci_write_reg(pcie, 0x000f0030, GEN2_PCIEPHYADDR);\n\trcar_pci_write_reg(pcie, 0x00381203, GEN2_PCIEPHYDATA);\n\trcar_pci_write_reg(pcie, 0x00000001, GEN2_PCIEPHYCTRL);\n\trcar_pci_write_reg(pcie, 0x00000006, GEN2_PCIEPHYCTRL);\n\n\trcar_pci_write_reg(pcie, 0x000f0054, GEN2_PCIEPHYADDR);\n\t \n\trcar_pci_write_reg(pcie, 0x13802007, GEN2_PCIEPHYDATA);\n\trcar_pci_write_reg(pcie, 0x00000001, GEN2_PCIEPHYCTRL);\n\trcar_pci_write_reg(pcie, 0x00000006, GEN2_PCIEPHYCTRL);\n\n\treturn 0;\n}\n\nstatic int rcar_pcie_phy_init_gen3(struct rcar_pcie_host *host)\n{\n\tint err;\n\n\terr = phy_init(host->phy);\n\tif (err)\n\t\treturn err;\n\n\terr = phy_power_on(host->phy);\n\tif (err)\n\t\tphy_exit(host->phy);\n\n\treturn err;\n}\n\nstatic irqreturn_t rcar_pcie_msi_irq(int irq, void *data)\n{\n\tstruct rcar_pcie_host *host = data;\n\tstruct rcar_pcie *pcie = &host->pcie;\n\tstruct rcar_msi *msi = &host->msi;\n\tstruct device *dev = pcie->dev;\n\tunsigned long reg;\n\n\treg = rcar_pci_read_reg(pcie, PCIEMSIFR);\n\n\t \n\tif (!reg)\n\t\treturn IRQ_NONE;\n\n\twhile (reg) {\n\t\tunsigned int index = find_first_bit(&reg, 32);\n\t\tint ret;\n\n\t\tret = generic_handle_domain_irq(msi->domain->parent, index);\n\t\tif (ret) {\n\t\t\t \n\t\t\tdev_dbg(dev, \"unexpected MSI\\n\");\n\t\t\trcar_pci_write_reg(pcie, BIT(index), PCIEMSIFR);\n\t\t}\n\n\t\t \n\t\treg = rcar_pci_read_reg(pcie, PCIEMSIFR);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void rcar_msi_top_irq_ack(struct irq_data *d)\n{\n\tirq_chip_ack_parent(d);\n}\n\nstatic void rcar_msi_top_irq_mask(struct irq_data *d)\n{\n\tpci_msi_mask_irq(d);\n\tirq_chip_mask_parent(d);\n}\n\nstatic void rcar_msi_top_irq_unmask(struct irq_data *d)\n{\n\tpci_msi_unmask_irq(d);\n\tirq_chip_unmask_parent(d);\n}\n\nstatic struct irq_chip rcar_msi_top_chip = {\n\t.name\t\t= \"PCIe MSI\",\n\t.irq_ack\t= rcar_msi_top_irq_ack,\n\t.irq_mask\t= rcar_msi_top_irq_mask,\n\t.irq_unmask\t= rcar_msi_top_irq_unmask,\n};\n\nstatic void rcar_msi_irq_ack(struct irq_data *d)\n{\n\tstruct rcar_msi *msi = irq_data_get_irq_chip_data(d);\n\tstruct rcar_pcie *pcie = &msi_to_host(msi)->pcie;\n\n\t \n\trcar_pci_write_reg(pcie, BIT(d->hwirq), PCIEMSIFR);\n}\n\nstatic void rcar_msi_irq_mask(struct irq_data *d)\n{\n\tstruct rcar_msi *msi = irq_data_get_irq_chip_data(d);\n\tstruct rcar_pcie *pcie = &msi_to_host(msi)->pcie;\n\tunsigned long flags;\n\tu32 value;\n\n\tspin_lock_irqsave(&msi->mask_lock, flags);\n\tvalue = rcar_pci_read_reg(pcie, PCIEMSIIER);\n\tvalue &= ~BIT(d->hwirq);\n\trcar_pci_write_reg(pcie, value, PCIEMSIIER);\n\tspin_unlock_irqrestore(&msi->mask_lock, flags);\n}\n\nstatic void rcar_msi_irq_unmask(struct irq_data *d)\n{\n\tstruct rcar_msi *msi = irq_data_get_irq_chip_data(d);\n\tstruct rcar_pcie *pcie = &msi_to_host(msi)->pcie;\n\tunsigned long flags;\n\tu32 value;\n\n\tspin_lock_irqsave(&msi->mask_lock, flags);\n\tvalue = rcar_pci_read_reg(pcie, PCIEMSIIER);\n\tvalue |= BIT(d->hwirq);\n\trcar_pci_write_reg(pcie, value, PCIEMSIIER);\n\tspin_unlock_irqrestore(&msi->mask_lock, flags);\n}\n\nstatic int rcar_msi_set_affinity(struct irq_data *d, const struct cpumask *mask, bool force)\n{\n\treturn -EINVAL;\n}\n\nstatic void rcar_compose_msi_msg(struct irq_data *data, struct msi_msg *msg)\n{\n\tstruct rcar_msi *msi = irq_data_get_irq_chip_data(data);\n\tstruct rcar_pcie *pcie = &msi_to_host(msi)->pcie;\n\n\tmsg->address_lo = rcar_pci_read_reg(pcie, PCIEMSIALR) & ~MSIFE;\n\tmsg->address_hi = rcar_pci_read_reg(pcie, PCIEMSIAUR);\n\tmsg->data = data->hwirq;\n}\n\nstatic struct irq_chip rcar_msi_bottom_chip = {\n\t.name\t\t\t= \"R-Car MSI\",\n\t.irq_ack\t\t= rcar_msi_irq_ack,\n\t.irq_mask\t\t= rcar_msi_irq_mask,\n\t.irq_unmask\t\t= rcar_msi_irq_unmask,\n\t.irq_set_affinity \t= rcar_msi_set_affinity,\n\t.irq_compose_msi_msg\t= rcar_compose_msi_msg,\n};\n\nstatic int rcar_msi_domain_alloc(struct irq_domain *domain, unsigned int virq,\n\t\t\t\t  unsigned int nr_irqs, void *args)\n{\n\tstruct rcar_msi *msi = domain->host_data;\n\tunsigned int i;\n\tint hwirq;\n\n\tmutex_lock(&msi->map_lock);\n\n\thwirq = bitmap_find_free_region(msi->used, INT_PCI_MSI_NR, order_base_2(nr_irqs));\n\n\tmutex_unlock(&msi->map_lock);\n\n\tif (hwirq < 0)\n\t\treturn -ENOSPC;\n\n\tfor (i = 0; i < nr_irqs; i++)\n\t\tirq_domain_set_info(domain, virq + i, hwirq + i,\n\t\t\t\t    &rcar_msi_bottom_chip, domain->host_data,\n\t\t\t\t    handle_edge_irq, NULL, NULL);\n\n\treturn 0;\n}\n\nstatic void rcar_msi_domain_free(struct irq_domain *domain, unsigned int virq,\n\t\t\t\t  unsigned int nr_irqs)\n{\n\tstruct irq_data *d = irq_domain_get_irq_data(domain, virq);\n\tstruct rcar_msi *msi = domain->host_data;\n\n\tmutex_lock(&msi->map_lock);\n\n\tbitmap_release_region(msi->used, d->hwirq, order_base_2(nr_irqs));\n\n\tmutex_unlock(&msi->map_lock);\n}\n\nstatic const struct irq_domain_ops rcar_msi_domain_ops = {\n\t.alloc\t= rcar_msi_domain_alloc,\n\t.free\t= rcar_msi_domain_free,\n};\n\nstatic struct msi_domain_info rcar_msi_info = {\n\t.flags\t= (MSI_FLAG_USE_DEF_DOM_OPS | MSI_FLAG_USE_DEF_CHIP_OPS |\n\t\t   MSI_FLAG_MULTI_PCI_MSI),\n\t.chip\t= &rcar_msi_top_chip,\n};\n\nstatic int rcar_allocate_domains(struct rcar_msi *msi)\n{\n\tstruct rcar_pcie *pcie = &msi_to_host(msi)->pcie;\n\tstruct fwnode_handle *fwnode = dev_fwnode(pcie->dev);\n\tstruct irq_domain *parent;\n\n\tparent = irq_domain_create_linear(fwnode, INT_PCI_MSI_NR,\n\t\t\t\t\t  &rcar_msi_domain_ops, msi);\n\tif (!parent) {\n\t\tdev_err(pcie->dev, \"failed to create IRQ domain\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tirq_domain_update_bus_token(parent, DOMAIN_BUS_NEXUS);\n\n\tmsi->domain = pci_msi_create_irq_domain(fwnode, &rcar_msi_info, parent);\n\tif (!msi->domain) {\n\t\tdev_err(pcie->dev, \"failed to create MSI domain\\n\");\n\t\tirq_domain_remove(parent);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic void rcar_free_domains(struct rcar_msi *msi)\n{\n\tstruct irq_domain *parent = msi->domain->parent;\n\n\tirq_domain_remove(msi->domain);\n\tirq_domain_remove(parent);\n}\n\nstatic int rcar_pcie_enable_msi(struct rcar_pcie_host *host)\n{\n\tstruct rcar_pcie *pcie = &host->pcie;\n\tstruct device *dev = pcie->dev;\n\tstruct rcar_msi *msi = &host->msi;\n\tstruct resource res;\n\tint err;\n\n\tmutex_init(&msi->map_lock);\n\tspin_lock_init(&msi->mask_lock);\n\n\terr = of_address_to_resource(dev->of_node, 0, &res);\n\tif (err)\n\t\treturn err;\n\n\terr = rcar_allocate_domains(msi);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = devm_request_irq(dev, msi->irq1, rcar_pcie_msi_irq,\n\t\t\t       IRQF_SHARED | IRQF_NO_THREAD,\n\t\t\t       rcar_msi_bottom_chip.name, host);\n\tif (err < 0) {\n\t\tdev_err(dev, \"failed to request IRQ: %d\\n\", err);\n\t\tgoto err;\n\t}\n\n\terr = devm_request_irq(dev, msi->irq2, rcar_pcie_msi_irq,\n\t\t\t       IRQF_SHARED | IRQF_NO_THREAD,\n\t\t\t       rcar_msi_bottom_chip.name, host);\n\tif (err < 0) {\n\t\tdev_err(dev, \"failed to request IRQ: %d\\n\", err);\n\t\tgoto err;\n\t}\n\n\t \n\trcar_pci_write_reg(pcie, 0, PCIEMSIIER);\n\n\t \n\trcar_pci_write_reg(pcie, lower_32_bits(res.start) | MSIFE, PCIEMSIALR);\n\trcar_pci_write_reg(pcie, upper_32_bits(res.start), PCIEMSIAUR);\n\n\treturn 0;\n\nerr:\n\trcar_free_domains(msi);\n\treturn err;\n}\n\nstatic void rcar_pcie_teardown_msi(struct rcar_pcie_host *host)\n{\n\tstruct rcar_pcie *pcie = &host->pcie;\n\n\t \n\trcar_pci_write_reg(pcie, 0, PCIEMSIIER);\n\n\t \n\trcar_pci_write_reg(pcie, 0, PCIEMSIALR);\n\n\trcar_free_domains(&host->msi);\n}\n\nstatic int rcar_pcie_get_resources(struct rcar_pcie_host *host)\n{\n\tstruct rcar_pcie *pcie = &host->pcie;\n\tstruct device *dev = pcie->dev;\n\tstruct resource res;\n\tint err, i;\n\n\thost->phy = devm_phy_optional_get(dev, \"pcie\");\n\tif (IS_ERR(host->phy))\n\t\treturn PTR_ERR(host->phy);\n\n\terr = of_address_to_resource(dev->of_node, 0, &res);\n\tif (err)\n\t\treturn err;\n\n\tpcie->base = devm_ioremap_resource(dev, &res);\n\tif (IS_ERR(pcie->base))\n\t\treturn PTR_ERR(pcie->base);\n\n\thost->bus_clk = devm_clk_get(dev, \"pcie_bus\");\n\tif (IS_ERR(host->bus_clk)) {\n\t\tdev_err(dev, \"cannot get pcie bus clock\\n\");\n\t\treturn PTR_ERR(host->bus_clk);\n\t}\n\n\ti = irq_of_parse_and_map(dev->of_node, 0);\n\tif (!i) {\n\t\tdev_err(dev, \"cannot get platform resources for msi interrupt\\n\");\n\t\terr = -ENOENT;\n\t\tgoto err_irq1;\n\t}\n\thost->msi.irq1 = i;\n\n\ti = irq_of_parse_and_map(dev->of_node, 1);\n\tif (!i) {\n\t\tdev_err(dev, \"cannot get platform resources for msi interrupt\\n\");\n\t\terr = -ENOENT;\n\t\tgoto err_irq2;\n\t}\n\thost->msi.irq2 = i;\n\n\treturn 0;\n\nerr_irq2:\n\tirq_dispose_mapping(host->msi.irq1);\nerr_irq1:\n\treturn err;\n}\n\nstatic int rcar_pcie_inbound_ranges(struct rcar_pcie *pcie,\n\t\t\t\t    struct resource_entry *entry,\n\t\t\t\t    int *index)\n{\n\tu64 restype = entry->res->flags;\n\tu64 cpu_addr = entry->res->start;\n\tu64 cpu_end = entry->res->end;\n\tu64 pci_addr = entry->res->start - entry->offset;\n\tu32 flags = LAM_64BIT | LAR_ENABLE;\n\tu64 mask;\n\tu64 size = resource_size(entry->res);\n\tint idx = *index;\n\n\tif (restype & IORESOURCE_PREFETCH)\n\t\tflags |= LAM_PREFETCH;\n\n\twhile (cpu_addr < cpu_end) {\n\t\tif (idx >= MAX_NR_INBOUND_MAPS - 1) {\n\t\t\tdev_err(pcie->dev, \"Failed to map inbound regions!\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t \n\t\tif (cpu_addr > 0) {\n\t\t\tunsigned long nr_zeros = __ffs64(cpu_addr);\n\t\t\tu64 alignment = 1ULL << nr_zeros;\n\n\t\t\tsize = min(size, alignment);\n\t\t}\n\t\t \n\t\tsize = min(size, 1ULL << 32);\n\n\t\tmask = roundup_pow_of_two(size) - 1;\n\t\tmask &= ~0xf;\n\n\t\trcar_pcie_set_inbound(pcie, cpu_addr, pci_addr,\n\t\t\t\t      lower_32_bits(mask) | flags, idx, true);\n\n\t\tpci_addr += size;\n\t\tcpu_addr += size;\n\t\tidx += 2;\n\t}\n\t*index = idx;\n\n\treturn 0;\n}\n\nstatic int rcar_pcie_parse_map_dma_ranges(struct rcar_pcie_host *host)\n{\n\tstruct pci_host_bridge *bridge = pci_host_bridge_from_priv(host);\n\tstruct resource_entry *entry;\n\tint index = 0, err = 0;\n\n\tresource_list_for_each_entry(entry, &bridge->dma_ranges) {\n\t\terr = rcar_pcie_inbound_ranges(&host->pcie, entry, &index);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nstatic const struct of_device_id rcar_pcie_of_match[] = {\n\t{ .compatible = \"renesas,pcie-r8a7779\",\n\t  .data = rcar_pcie_phy_init_h1 },\n\t{ .compatible = \"renesas,pcie-r8a7790\",\n\t  .data = rcar_pcie_phy_init_gen2 },\n\t{ .compatible = \"renesas,pcie-r8a7791\",\n\t  .data = rcar_pcie_phy_init_gen2 },\n\t{ .compatible = \"renesas,pcie-rcar-gen2\",\n\t  .data = rcar_pcie_phy_init_gen2 },\n\t{ .compatible = \"renesas,pcie-r8a7795\",\n\t  .data = rcar_pcie_phy_init_gen3 },\n\t{ .compatible = \"renesas,pcie-rcar-gen3\",\n\t  .data = rcar_pcie_phy_init_gen3 },\n\t{},\n};\n\nstatic int rcar_pcie_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct rcar_pcie_host *host;\n\tstruct rcar_pcie *pcie;\n\tu32 data;\n\tint err;\n\tstruct pci_host_bridge *bridge;\n\n\tbridge = devm_pci_alloc_host_bridge(dev, sizeof(*host));\n\tif (!bridge)\n\t\treturn -ENOMEM;\n\n\thost = pci_host_bridge_priv(bridge);\n\tpcie = &host->pcie;\n\tpcie->dev = dev;\n\tplatform_set_drvdata(pdev, host);\n\n\tpm_runtime_enable(pcie->dev);\n\terr = pm_runtime_get_sync(pcie->dev);\n\tif (err < 0) {\n\t\tdev_err(pcie->dev, \"pm_runtime_get_sync failed\\n\");\n\t\tgoto err_pm_put;\n\t}\n\n\terr = rcar_pcie_get_resources(host);\n\tif (err < 0) {\n\t\tdev_err(dev, \"failed to request resources: %d\\n\", err);\n\t\tgoto err_pm_put;\n\t}\n\n\terr = clk_prepare_enable(host->bus_clk);\n\tif (err) {\n\t\tdev_err(dev, \"failed to enable bus clock: %d\\n\", err);\n\t\tgoto err_unmap_msi_irqs;\n\t}\n\n\terr = rcar_pcie_parse_map_dma_ranges(host);\n\tif (err)\n\t\tgoto err_clk_disable;\n\n\thost->phy_init_fn = of_device_get_match_data(dev);\n\terr = host->phy_init_fn(host);\n\tif (err) {\n\t\tdev_err(dev, \"failed to init PCIe PHY\\n\");\n\t\tgoto err_clk_disable;\n\t}\n\n\t \n\tif (rcar_pcie_hw_init(pcie)) {\n\t\tdev_info(dev, \"PCIe link down\\n\");\n\t\terr = -ENODEV;\n\t\tgoto err_phy_shutdown;\n\t}\n\n\tdata = rcar_pci_read_reg(pcie, MACSR);\n\tdev_info(dev, \"PCIe x%d: link up\\n\", (data >> 20) & 0x3f);\n\n\tif (IS_ENABLED(CONFIG_PCI_MSI)) {\n\t\terr = rcar_pcie_enable_msi(host);\n\t\tif (err < 0) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"failed to enable MSI support: %d\\n\",\n\t\t\t\terr);\n\t\t\tgoto err_phy_shutdown;\n\t\t}\n\t}\n\n\terr = rcar_pcie_enable(host);\n\tif (err)\n\t\tgoto err_msi_teardown;\n\n\treturn 0;\n\nerr_msi_teardown:\n\tif (IS_ENABLED(CONFIG_PCI_MSI))\n\t\trcar_pcie_teardown_msi(host);\n\nerr_phy_shutdown:\n\tif (host->phy) {\n\t\tphy_power_off(host->phy);\n\t\tphy_exit(host->phy);\n\t}\n\nerr_clk_disable:\n\tclk_disable_unprepare(host->bus_clk);\n\nerr_unmap_msi_irqs:\n\tirq_dispose_mapping(host->msi.irq2);\n\tirq_dispose_mapping(host->msi.irq1);\n\nerr_pm_put:\n\tpm_runtime_put(dev);\n\tpm_runtime_disable(dev);\n\n\treturn err;\n}\n\nstatic int rcar_pcie_resume(struct device *dev)\n{\n\tstruct rcar_pcie_host *host = dev_get_drvdata(dev);\n\tstruct rcar_pcie *pcie = &host->pcie;\n\tunsigned int data;\n\tint err;\n\n\terr = rcar_pcie_parse_map_dma_ranges(host);\n\tif (err)\n\t\treturn 0;\n\n\t \n\terr = host->phy_init_fn(host);\n\tif (err) {\n\t\tdev_info(dev, \"PCIe link down\\n\");\n\t\treturn 0;\n\t}\n\n\tdata = rcar_pci_read_reg(pcie, MACSR);\n\tdev_info(dev, \"PCIe x%d: link up\\n\", (data >> 20) & 0x3f);\n\n\t \n\tif (IS_ENABLED(CONFIG_PCI_MSI)) {\n\t\tstruct resource res;\n\t\tu32 val;\n\n\t\tof_address_to_resource(dev->of_node, 0, &res);\n\t\trcar_pci_write_reg(pcie, upper_32_bits(res.start), PCIEMSIAUR);\n\t\trcar_pci_write_reg(pcie, lower_32_bits(res.start) | MSIFE, PCIEMSIALR);\n\n\t\tbitmap_to_arr32(&val, host->msi.used, INT_PCI_MSI_NR);\n\t\trcar_pci_write_reg(pcie, val, PCIEMSIIER);\n\t}\n\n\trcar_pcie_hw_enable(host);\n\n\treturn 0;\n}\n\nstatic int rcar_pcie_resume_noirq(struct device *dev)\n{\n\tstruct rcar_pcie_host *host = dev_get_drvdata(dev);\n\tstruct rcar_pcie *pcie = &host->pcie;\n\n\tif (rcar_pci_read_reg(pcie, PMSR) &&\n\t    !(rcar_pci_read_reg(pcie, PCIETCTLR) & DL_DOWN))\n\t\treturn 0;\n\n\t \n\trcar_pci_write_reg(pcie, MACCTLR_INIT_VAL, MACCTLR);\n\trcar_pci_write_reg(pcie, CFINIT, PCIETCTLR);\n\treturn rcar_pcie_wait_for_dl(pcie);\n}\n\nstatic const struct dev_pm_ops rcar_pcie_pm_ops = {\n\tSYSTEM_SLEEP_PM_OPS(NULL, rcar_pcie_resume)\n\t.resume_noirq = rcar_pcie_resume_noirq,\n};\n\nstatic struct platform_driver rcar_pcie_driver = {\n\t.driver = {\n\t\t.name = \"rcar-pcie\",\n\t\t.of_match_table = rcar_pcie_of_match,\n\t\t.pm = &rcar_pcie_pm_ops,\n\t\t.suppress_bind_attrs = true,\n\t},\n\t.probe = rcar_pcie_probe,\n};\n\n#ifdef CONFIG_ARM\nstatic int rcar_pcie_aarch32_abort_handler(unsigned long addr,\n\t\tunsigned int fsr, struct pt_regs *regs)\n{\n\treturn !fixup_exception(regs);\n}\n\nstatic const struct of_device_id rcar_pcie_abort_handler_of_match[] __initconst = {\n\t{ .compatible = \"renesas,pcie-r8a7779\" },\n\t{ .compatible = \"renesas,pcie-r8a7790\" },\n\t{ .compatible = \"renesas,pcie-r8a7791\" },\n\t{ .compatible = \"renesas,pcie-rcar-gen2\" },\n\t{},\n};\n\nstatic int __init rcar_pcie_init(void)\n{\n\tif (of_find_matching_node(NULL, rcar_pcie_abort_handler_of_match)) {\n#ifdef CONFIG_ARM_LPAE\n\t\thook_fault_code(17, rcar_pcie_aarch32_abort_handler, SIGBUS, 0,\n\t\t\t\t\"asynchronous external abort\");\n#else\n\t\thook_fault_code(22, rcar_pcie_aarch32_abort_handler, SIGBUS, 0,\n\t\t\t\t\"imprecise external abort\");\n#endif\n\t}\n\n\treturn platform_driver_register(&rcar_pcie_driver);\n}\ndevice_initcall(rcar_pcie_init);\n#else\nbuiltin_platform_driver(rcar_pcie_driver);\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}