{
  "module_name": "pcie-rockchip-host.c",
  "hash_id": "3249d7e9a912996a9c08c86032c3f61d0e3ebdae914f8576936822a2f8186c1a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/controller/pcie-rockchip-host.c",
  "human_readable_source": "\n \n\n#include <linux/bitrev.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/iopoll.h>\n#include <linux/irq.h>\n#include <linux/irqchip/chained_irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_pci.h>\n#include <linux/pci.h>\n#include <linux/pci_ids.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n#include <linux/reset.h>\n#include <linux/regmap.h>\n\n#include \"../pci.h\"\n#include \"pcie-rockchip.h\"\n\nstatic void rockchip_pcie_enable_bw_int(struct rockchip_pcie *rockchip)\n{\n\tu32 status;\n\n\tstatus = rockchip_pcie_read(rockchip, PCIE_RC_CONFIG_LCS);\n\tstatus |= (PCI_EXP_LNKCTL_LBMIE | PCI_EXP_LNKCTL_LABIE);\n\trockchip_pcie_write(rockchip, status, PCIE_RC_CONFIG_LCS);\n}\n\nstatic void rockchip_pcie_clr_bw_int(struct rockchip_pcie *rockchip)\n{\n\tu32 status;\n\n\tstatus = rockchip_pcie_read(rockchip, PCIE_RC_CONFIG_LCS);\n\tstatus |= (PCI_EXP_LNKSTA_LBMS | PCI_EXP_LNKSTA_LABS) << 16;\n\trockchip_pcie_write(rockchip, status, PCIE_RC_CONFIG_LCS);\n}\n\nstatic void rockchip_pcie_update_txcredit_mui(struct rockchip_pcie *rockchip)\n{\n\tu32 val;\n\n\t \n\tval = rockchip_pcie_read(rockchip, PCIE_CORE_TXCREDIT_CFG1);\n\tval &= ~PCIE_CORE_TXCREDIT_CFG1_MUI_MASK;\n\tval |= PCIE_CORE_TXCREDIT_CFG1_MUI_ENCODE(24000);\t \n\trockchip_pcie_write(rockchip, val, PCIE_CORE_TXCREDIT_CFG1);\n}\n\nstatic int rockchip_pcie_valid_device(struct rockchip_pcie *rockchip,\n\t\t\t\t      struct pci_bus *bus, int dev)\n{\n\t \n\tif (pci_is_root_bus(bus) || pci_is_root_bus(bus->parent))\n\t\treturn dev == 0;\n\n\treturn 1;\n}\n\nstatic u8 rockchip_pcie_lane_map(struct rockchip_pcie *rockchip)\n{\n\tu32 val;\n\tu8 map;\n\n\tif (rockchip->legacy_phy)\n\t\treturn GENMASK(MAX_LANE_NUM - 1, 0);\n\n\tval = rockchip_pcie_read(rockchip, PCIE_CORE_LANE_MAP);\n\tmap = val & PCIE_CORE_LANE_MAP_MASK;\n\n\t \n\tif (val & PCIE_CORE_LANE_MAP_REVERSE)\n\t\tmap = bitrev8(map) >> 4;\n\n\treturn map;\n}\n\nstatic int rockchip_pcie_rd_own_conf(struct rockchip_pcie *rockchip,\n\t\t\t\t     int where, int size, u32 *val)\n{\n\tvoid __iomem *addr;\n\n\taddr = rockchip->apb_base + PCIE_RC_CONFIG_NORMAL_BASE + where;\n\n\tif (!IS_ALIGNED((uintptr_t)addr, size)) {\n\t\t*val = 0;\n\t\treturn PCIBIOS_BAD_REGISTER_NUMBER;\n\t}\n\n\tif (size == 4) {\n\t\t*val = readl(addr);\n\t} else if (size == 2) {\n\t\t*val = readw(addr);\n\t} else if (size == 1) {\n\t\t*val = readb(addr);\n\t} else {\n\t\t*val = 0;\n\t\treturn PCIBIOS_BAD_REGISTER_NUMBER;\n\t}\n\treturn PCIBIOS_SUCCESSFUL;\n}\n\nstatic int rockchip_pcie_wr_own_conf(struct rockchip_pcie *rockchip,\n\t\t\t\t     int where, int size, u32 val)\n{\n\tu32 mask, tmp, offset;\n\tvoid __iomem *addr;\n\n\toffset = where & ~0x3;\n\taddr = rockchip->apb_base + PCIE_RC_CONFIG_NORMAL_BASE + offset;\n\n\tif (size == 4) {\n\t\twritel(val, addr);\n\t\treturn PCIBIOS_SUCCESSFUL;\n\t}\n\n\tmask = ~(((1 << (size * 8)) - 1) << ((where & 0x3) * 8));\n\n\t \n\ttmp = readl(addr) & mask;\n\ttmp |= val << ((where & 0x3) * 8);\n\twritel(tmp, addr);\n\n\treturn PCIBIOS_SUCCESSFUL;\n}\n\nstatic int rockchip_pcie_rd_other_conf(struct rockchip_pcie *rockchip,\n\t\t\t\t       struct pci_bus *bus, u32 devfn,\n\t\t\t\t       int where, int size, u32 *val)\n{\n\tvoid __iomem *addr;\n\n\taddr = rockchip->reg_base + PCIE_ECAM_OFFSET(bus->number, devfn, where);\n\n\tif (!IS_ALIGNED((uintptr_t)addr, size)) {\n\t\t*val = 0;\n\t\treturn PCIBIOS_BAD_REGISTER_NUMBER;\n\t}\n\n\tif (pci_is_root_bus(bus->parent))\n\t\trockchip_pcie_cfg_configuration_accesses(rockchip,\n\t\t\t\t\t\tAXI_WRAPPER_TYPE0_CFG);\n\telse\n\t\trockchip_pcie_cfg_configuration_accesses(rockchip,\n\t\t\t\t\t\tAXI_WRAPPER_TYPE1_CFG);\n\n\tif (size == 4) {\n\t\t*val = readl(addr);\n\t} else if (size == 2) {\n\t\t*val = readw(addr);\n\t} else if (size == 1) {\n\t\t*val = readb(addr);\n\t} else {\n\t\t*val = 0;\n\t\treturn PCIBIOS_BAD_REGISTER_NUMBER;\n\t}\n\treturn PCIBIOS_SUCCESSFUL;\n}\n\nstatic int rockchip_pcie_wr_other_conf(struct rockchip_pcie *rockchip,\n\t\t\t\t       struct pci_bus *bus, u32 devfn,\n\t\t\t\t       int where, int size, u32 val)\n{\n\tvoid __iomem *addr;\n\n\taddr = rockchip->reg_base + PCIE_ECAM_OFFSET(bus->number, devfn, where);\n\n\tif (!IS_ALIGNED((uintptr_t)addr, size))\n\t\treturn PCIBIOS_BAD_REGISTER_NUMBER;\n\n\tif (pci_is_root_bus(bus->parent))\n\t\trockchip_pcie_cfg_configuration_accesses(rockchip,\n\t\t\t\t\t\tAXI_WRAPPER_TYPE0_CFG);\n\telse\n\t\trockchip_pcie_cfg_configuration_accesses(rockchip,\n\t\t\t\t\t\tAXI_WRAPPER_TYPE1_CFG);\n\n\tif (size == 4)\n\t\twritel(val, addr);\n\telse if (size == 2)\n\t\twritew(val, addr);\n\telse if (size == 1)\n\t\twriteb(val, addr);\n\telse\n\t\treturn PCIBIOS_BAD_REGISTER_NUMBER;\n\n\treturn PCIBIOS_SUCCESSFUL;\n}\n\nstatic int rockchip_pcie_rd_conf(struct pci_bus *bus, u32 devfn, int where,\n\t\t\t\t int size, u32 *val)\n{\n\tstruct rockchip_pcie *rockchip = bus->sysdata;\n\n\tif (!rockchip_pcie_valid_device(rockchip, bus, PCI_SLOT(devfn)))\n\t\treturn PCIBIOS_DEVICE_NOT_FOUND;\n\n\tif (pci_is_root_bus(bus))\n\t\treturn rockchip_pcie_rd_own_conf(rockchip, where, size, val);\n\n\treturn rockchip_pcie_rd_other_conf(rockchip, bus, devfn, where, size,\n\t\t\t\t\t   val);\n}\n\nstatic int rockchip_pcie_wr_conf(struct pci_bus *bus, u32 devfn,\n\t\t\t\t int where, int size, u32 val)\n{\n\tstruct rockchip_pcie *rockchip = bus->sysdata;\n\n\tif (!rockchip_pcie_valid_device(rockchip, bus, PCI_SLOT(devfn)))\n\t\treturn PCIBIOS_DEVICE_NOT_FOUND;\n\n\tif (pci_is_root_bus(bus))\n\t\treturn rockchip_pcie_wr_own_conf(rockchip, where, size, val);\n\n\treturn rockchip_pcie_wr_other_conf(rockchip, bus, devfn, where, size,\n\t\t\t\t\t   val);\n}\n\nstatic struct pci_ops rockchip_pcie_ops = {\n\t.read = rockchip_pcie_rd_conf,\n\t.write = rockchip_pcie_wr_conf,\n};\n\nstatic void rockchip_pcie_set_power_limit(struct rockchip_pcie *rockchip)\n{\n\tint curr;\n\tu32 status, scale, power;\n\n\tif (IS_ERR(rockchip->vpcie3v3))\n\t\treturn;\n\n\t \n\tcurr = regulator_get_current_limit(rockchip->vpcie3v3);\n\tif (curr <= 0)\n\t\treturn;\n\n\tscale = 3;  \n\tcurr = curr / 1000;  \n\tpower = (curr * 3300) / 1000;  \n\twhile (power > PCIE_RC_CONFIG_DCR_CSPL_LIMIT) {\n\t\tif (!scale) {\n\t\t\tdev_warn(rockchip->dev, \"invalid power supply\\n\");\n\t\t\treturn;\n\t\t}\n\t\tscale--;\n\t\tpower = power / 10;\n\t}\n\n\tstatus = rockchip_pcie_read(rockchip, PCIE_RC_CONFIG_DCR);\n\tstatus |= (power << PCIE_RC_CONFIG_DCR_CSPL_SHIFT) |\n\t\t  (scale << PCIE_RC_CONFIG_DCR_CPLS_SHIFT);\n\trockchip_pcie_write(rockchip, status, PCIE_RC_CONFIG_DCR);\n}\n\n \nstatic int rockchip_pcie_host_init_port(struct rockchip_pcie *rockchip)\n{\n\tstruct device *dev = rockchip->dev;\n\tint err, i = MAX_LANE_NUM;\n\tu32 status;\n\n\tgpiod_set_value_cansleep(rockchip->ep_gpio, 0);\n\n\terr = rockchip_pcie_init_port(rockchip);\n\tif (err)\n\t\treturn err;\n\n\t \n\tstatus = rockchip_pcie_read(rockchip, PCIE_CORE_CTRL_PLC1);\n\tstatus = (status & ~PCIE_CORE_CTRL_PLC1_FTS_MASK) |\n\t\t (PCIE_CORE_CTRL_PLC1_FTS_CNT << PCIE_CORE_CTRL_PLC1_FTS_SHIFT);\n\trockchip_pcie_write(rockchip, status, PCIE_CORE_CTRL_PLC1);\n\n\trockchip_pcie_set_power_limit(rockchip);\n\n\t \n\tstatus = rockchip_pcie_read(rockchip, PCIE_RC_CONFIG_LCS);\n\tstatus |= PCI_EXP_LNKSTA_SLC << 16;\n\trockchip_pcie_write(rockchip, status, PCIE_RC_CONFIG_LCS);\n\n\t \n\tstatus = rockchip_pcie_read(rockchip, PCIE_RC_CONFIG_LCS);\n\tstatus |= PCI_EXP_LNKCTL_RCB;\n\trockchip_pcie_write(rockchip, status, PCIE_RC_CONFIG_LCS);\n\n\t \n\trockchip_pcie_write(rockchip, PCIE_CLIENT_LINK_TRAIN_ENABLE,\n\t\t\t    PCIE_CLIENT_CONFIG);\n\n\tgpiod_set_value_cansleep(rockchip->ep_gpio, 1);\n\n\t \n\terr = readl_poll_timeout(rockchip->apb_base + PCIE_CLIENT_BASIC_STATUS1,\n\t\t\t\t status, PCIE_LINK_UP(status), 20,\n\t\t\t\t 500 * USEC_PER_MSEC);\n\tif (err) {\n\t\tdev_err(dev, \"PCIe link training gen1 timeout!\\n\");\n\t\tgoto err_power_off_phy;\n\t}\n\n\tif (rockchip->link_gen == 2) {\n\t\t \n\t\tstatus = rockchip_pcie_read(rockchip, PCIE_RC_CONFIG_LCS);\n\t\tstatus |= PCI_EXP_LNKCTL_RL;\n\t\trockchip_pcie_write(rockchip, status, PCIE_RC_CONFIG_LCS);\n\n\t\terr = readl_poll_timeout(rockchip->apb_base + PCIE_CORE_CTRL,\n\t\t\t\t\t status, PCIE_LINK_IS_GEN2(status), 20,\n\t\t\t\t\t 500 * USEC_PER_MSEC);\n\t\tif (err)\n\t\t\tdev_dbg(dev, \"PCIe link training gen2 timeout, fall back to gen1!\\n\");\n\t}\n\n\t \n\tstatus = rockchip_pcie_read(rockchip, PCIE_CORE_CTRL);\n\tstatus = 0x1 << ((status & PCIE_CORE_PL_CONF_LANE_MASK) >>\n\t\t\t  PCIE_CORE_PL_CONF_LANE_SHIFT);\n\tdev_dbg(dev, \"current link width is x%d\\n\", status);\n\n\t \n\trockchip->lanes_map = rockchip_pcie_lane_map(rockchip);\n\tfor (i = 0; i < MAX_LANE_NUM; i++) {\n\t\tif (!(rockchip->lanes_map & BIT(i))) {\n\t\t\tdev_dbg(dev, \"idling lane %d\\n\", i);\n\t\t\tphy_power_off(rockchip->phys[i]);\n\t\t}\n\t}\n\n\trockchip_pcie_write(rockchip, ROCKCHIP_VENDOR_ID,\n\t\t\t    PCIE_CORE_CONFIG_VENDOR);\n\trockchip_pcie_write(rockchip,\n\t\t\t    PCI_CLASS_BRIDGE_PCI_NORMAL << 8,\n\t\t\t    PCIE_RC_CONFIG_RID_CCR);\n\n\t \n\tstatus = rockchip_pcie_read(rockchip, PCIE_RC_CONFIG_THP_CAP);\n\tstatus &= ~PCIE_RC_CONFIG_THP_CAP_NEXT_MASK;\n\trockchip_pcie_write(rockchip, status, PCIE_RC_CONFIG_THP_CAP);\n\n\t \n\tif (of_property_read_bool(dev->of_node, \"aspm-no-l0s\")) {\n\t\tstatus = rockchip_pcie_read(rockchip, PCIE_RC_CONFIG_LINK_CAP);\n\t\tstatus &= ~PCIE_RC_CONFIG_LINK_CAP_L0S;\n\t\trockchip_pcie_write(rockchip, status, PCIE_RC_CONFIG_LINK_CAP);\n\t}\n\n\tstatus = rockchip_pcie_read(rockchip, PCIE_RC_CONFIG_DCSR);\n\tstatus &= ~PCIE_RC_CONFIG_DCSR_MPS_MASK;\n\tstatus |= PCIE_RC_CONFIG_DCSR_MPS_256;\n\trockchip_pcie_write(rockchip, status, PCIE_RC_CONFIG_DCSR);\n\n\treturn 0;\nerr_power_off_phy:\n\twhile (i--)\n\t\tphy_power_off(rockchip->phys[i]);\n\ti = MAX_LANE_NUM;\n\twhile (i--)\n\t\tphy_exit(rockchip->phys[i]);\n\treturn err;\n}\n\nstatic irqreturn_t rockchip_pcie_subsys_irq_handler(int irq, void *arg)\n{\n\tstruct rockchip_pcie *rockchip = arg;\n\tstruct device *dev = rockchip->dev;\n\tu32 reg;\n\tu32 sub_reg;\n\n\treg = rockchip_pcie_read(rockchip, PCIE_CLIENT_INT_STATUS);\n\tif (reg & PCIE_CLIENT_INT_LOCAL) {\n\t\tdev_dbg(dev, \"local interrupt received\\n\");\n\t\tsub_reg = rockchip_pcie_read(rockchip, PCIE_CORE_INT_STATUS);\n\t\tif (sub_reg & PCIE_CORE_INT_PRFPE)\n\t\t\tdev_dbg(dev, \"parity error detected while reading from the PNP receive FIFO RAM\\n\");\n\n\t\tif (sub_reg & PCIE_CORE_INT_CRFPE)\n\t\t\tdev_dbg(dev, \"parity error detected while reading from the Completion Receive FIFO RAM\\n\");\n\n\t\tif (sub_reg & PCIE_CORE_INT_RRPE)\n\t\t\tdev_dbg(dev, \"parity error detected while reading from replay buffer RAM\\n\");\n\n\t\tif (sub_reg & PCIE_CORE_INT_PRFO)\n\t\t\tdev_dbg(dev, \"overflow occurred in the PNP receive FIFO\\n\");\n\n\t\tif (sub_reg & PCIE_CORE_INT_CRFO)\n\t\t\tdev_dbg(dev, \"overflow occurred in the completion receive FIFO\\n\");\n\n\t\tif (sub_reg & PCIE_CORE_INT_RT)\n\t\t\tdev_dbg(dev, \"replay timer timed out\\n\");\n\n\t\tif (sub_reg & PCIE_CORE_INT_RTR)\n\t\t\tdev_dbg(dev, \"replay timer rolled over after 4 transmissions of the same TLP\\n\");\n\n\t\tif (sub_reg & PCIE_CORE_INT_PE)\n\t\t\tdev_dbg(dev, \"phy error detected on receive side\\n\");\n\n\t\tif (sub_reg & PCIE_CORE_INT_MTR)\n\t\t\tdev_dbg(dev, \"malformed TLP received from the link\\n\");\n\n\t\tif (sub_reg & PCIE_CORE_INT_UCR)\n\t\t\tdev_dbg(dev, \"malformed TLP received from the link\\n\");\n\n\t\tif (sub_reg & PCIE_CORE_INT_FCE)\n\t\t\tdev_dbg(dev, \"an error was observed in the flow control advertisements from the other side\\n\");\n\n\t\tif (sub_reg & PCIE_CORE_INT_CT)\n\t\t\tdev_dbg(dev, \"a request timed out waiting for completion\\n\");\n\n\t\tif (sub_reg & PCIE_CORE_INT_UTC)\n\t\t\tdev_dbg(dev, \"unmapped TC error\\n\");\n\n\t\tif (sub_reg & PCIE_CORE_INT_MMVC)\n\t\t\tdev_dbg(dev, \"MSI mask register changes\\n\");\n\n\t\trockchip_pcie_write(rockchip, sub_reg, PCIE_CORE_INT_STATUS);\n\t} else if (reg & PCIE_CLIENT_INT_PHY) {\n\t\tdev_dbg(dev, \"phy link changes\\n\");\n\t\trockchip_pcie_update_txcredit_mui(rockchip);\n\t\trockchip_pcie_clr_bw_int(rockchip);\n\t}\n\n\trockchip_pcie_write(rockchip, reg & PCIE_CLIENT_INT_LOCAL,\n\t\t\t    PCIE_CLIENT_INT_STATUS);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t rockchip_pcie_client_irq_handler(int irq, void *arg)\n{\n\tstruct rockchip_pcie *rockchip = arg;\n\tstruct device *dev = rockchip->dev;\n\tu32 reg;\n\n\treg = rockchip_pcie_read(rockchip, PCIE_CLIENT_INT_STATUS);\n\tif (reg & PCIE_CLIENT_INT_LEGACY_DONE)\n\t\tdev_dbg(dev, \"legacy done interrupt received\\n\");\n\n\tif (reg & PCIE_CLIENT_INT_MSG)\n\t\tdev_dbg(dev, \"message done interrupt received\\n\");\n\n\tif (reg & PCIE_CLIENT_INT_HOT_RST)\n\t\tdev_dbg(dev, \"hot reset interrupt received\\n\");\n\n\tif (reg & PCIE_CLIENT_INT_DPA)\n\t\tdev_dbg(dev, \"dpa interrupt received\\n\");\n\n\tif (reg & PCIE_CLIENT_INT_FATAL_ERR)\n\t\tdev_dbg(dev, \"fatal error interrupt received\\n\");\n\n\tif (reg & PCIE_CLIENT_INT_NFATAL_ERR)\n\t\tdev_dbg(dev, \"no fatal error interrupt received\\n\");\n\n\tif (reg & PCIE_CLIENT_INT_CORR_ERR)\n\t\tdev_dbg(dev, \"correctable error interrupt received\\n\");\n\n\tif (reg & PCIE_CLIENT_INT_PHY)\n\t\tdev_dbg(dev, \"phy interrupt received\\n\");\n\n\trockchip_pcie_write(rockchip, reg & (PCIE_CLIENT_INT_LEGACY_DONE |\n\t\t\t      PCIE_CLIENT_INT_MSG | PCIE_CLIENT_INT_HOT_RST |\n\t\t\t      PCIE_CLIENT_INT_DPA | PCIE_CLIENT_INT_FATAL_ERR |\n\t\t\t      PCIE_CLIENT_INT_NFATAL_ERR |\n\t\t\t      PCIE_CLIENT_INT_CORR_ERR |\n\t\t\t      PCIE_CLIENT_INT_PHY),\n\t\t   PCIE_CLIENT_INT_STATUS);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void rockchip_pcie_legacy_int_handler(struct irq_desc *desc)\n{\n\tstruct irq_chip *chip = irq_desc_get_chip(desc);\n\tstruct rockchip_pcie *rockchip = irq_desc_get_handler_data(desc);\n\tstruct device *dev = rockchip->dev;\n\tu32 reg;\n\tu32 hwirq;\n\tint ret;\n\n\tchained_irq_enter(chip, desc);\n\n\treg = rockchip_pcie_read(rockchip, PCIE_CLIENT_INT_STATUS);\n\treg = (reg & PCIE_CLIENT_INTR_MASK) >> PCIE_CLIENT_INTR_SHIFT;\n\n\twhile (reg) {\n\t\thwirq = ffs(reg) - 1;\n\t\treg &= ~BIT(hwirq);\n\n\t\tret = generic_handle_domain_irq(rockchip->irq_domain, hwirq);\n\t\tif (ret)\n\t\t\tdev_err(dev, \"unexpected IRQ, INT%d\\n\", hwirq);\n\t}\n\n\tchained_irq_exit(chip, desc);\n}\n\nstatic int rockchip_pcie_setup_irq(struct rockchip_pcie *rockchip)\n{\n\tint irq, err;\n\tstruct device *dev = rockchip->dev;\n\tstruct platform_device *pdev = to_platform_device(dev);\n\n\tirq = platform_get_irq_byname(pdev, \"sys\");\n\tif (irq < 0)\n\t\treturn irq;\n\n\terr = devm_request_irq(dev, irq, rockchip_pcie_subsys_irq_handler,\n\t\t\t       IRQF_SHARED, \"pcie-sys\", rockchip);\n\tif (err) {\n\t\tdev_err(dev, \"failed to request PCIe subsystem IRQ\\n\");\n\t\treturn err;\n\t}\n\n\tirq = platform_get_irq_byname(pdev, \"legacy\");\n\tif (irq < 0)\n\t\treturn irq;\n\n\tirq_set_chained_handler_and_data(irq,\n\t\t\t\t\t rockchip_pcie_legacy_int_handler,\n\t\t\t\t\t rockchip);\n\n\tirq = platform_get_irq_byname(pdev, \"client\");\n\tif (irq < 0)\n\t\treturn irq;\n\n\terr = devm_request_irq(dev, irq, rockchip_pcie_client_irq_handler,\n\t\t\t       IRQF_SHARED, \"pcie-client\", rockchip);\n\tif (err) {\n\t\tdev_err(dev, \"failed to request PCIe client IRQ\\n\");\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int rockchip_pcie_parse_host_dt(struct rockchip_pcie *rockchip)\n{\n\tstruct device *dev = rockchip->dev;\n\tint err;\n\n\terr = rockchip_pcie_parse_dt(rockchip);\n\tif (err)\n\t\treturn err;\n\n\trockchip->vpcie12v = devm_regulator_get_optional(dev, \"vpcie12v\");\n\tif (IS_ERR(rockchip->vpcie12v)) {\n\t\tif (PTR_ERR(rockchip->vpcie12v) != -ENODEV)\n\t\t\treturn PTR_ERR(rockchip->vpcie12v);\n\t\tdev_info(dev, \"no vpcie12v regulator found\\n\");\n\t}\n\n\trockchip->vpcie3v3 = devm_regulator_get_optional(dev, \"vpcie3v3\");\n\tif (IS_ERR(rockchip->vpcie3v3)) {\n\t\tif (PTR_ERR(rockchip->vpcie3v3) != -ENODEV)\n\t\t\treturn PTR_ERR(rockchip->vpcie3v3);\n\t\tdev_info(dev, \"no vpcie3v3 regulator found\\n\");\n\t}\n\n\trockchip->vpcie1v8 = devm_regulator_get(dev, \"vpcie1v8\");\n\tif (IS_ERR(rockchip->vpcie1v8))\n\t\treturn PTR_ERR(rockchip->vpcie1v8);\n\n\trockchip->vpcie0v9 = devm_regulator_get(dev, \"vpcie0v9\");\n\tif (IS_ERR(rockchip->vpcie0v9))\n\t\treturn PTR_ERR(rockchip->vpcie0v9);\n\n\treturn 0;\n}\n\nstatic int rockchip_pcie_set_vpcie(struct rockchip_pcie *rockchip)\n{\n\tstruct device *dev = rockchip->dev;\n\tint err;\n\n\tif (!IS_ERR(rockchip->vpcie12v)) {\n\t\terr = regulator_enable(rockchip->vpcie12v);\n\t\tif (err) {\n\t\t\tdev_err(dev, \"fail to enable vpcie12v regulator\\n\");\n\t\t\tgoto err_out;\n\t\t}\n\t}\n\n\tif (!IS_ERR(rockchip->vpcie3v3)) {\n\t\terr = regulator_enable(rockchip->vpcie3v3);\n\t\tif (err) {\n\t\t\tdev_err(dev, \"fail to enable vpcie3v3 regulator\\n\");\n\t\t\tgoto err_disable_12v;\n\t\t}\n\t}\n\n\terr = regulator_enable(rockchip->vpcie1v8);\n\tif (err) {\n\t\tdev_err(dev, \"fail to enable vpcie1v8 regulator\\n\");\n\t\tgoto err_disable_3v3;\n\t}\n\n\terr = regulator_enable(rockchip->vpcie0v9);\n\tif (err) {\n\t\tdev_err(dev, \"fail to enable vpcie0v9 regulator\\n\");\n\t\tgoto err_disable_1v8;\n\t}\n\n\treturn 0;\n\nerr_disable_1v8:\n\tregulator_disable(rockchip->vpcie1v8);\nerr_disable_3v3:\n\tif (!IS_ERR(rockchip->vpcie3v3))\n\t\tregulator_disable(rockchip->vpcie3v3);\nerr_disable_12v:\n\tif (!IS_ERR(rockchip->vpcie12v))\n\t\tregulator_disable(rockchip->vpcie12v);\nerr_out:\n\treturn err;\n}\n\nstatic void rockchip_pcie_enable_interrupts(struct rockchip_pcie *rockchip)\n{\n\trockchip_pcie_write(rockchip, (PCIE_CLIENT_INT_CLI << 16) &\n\t\t\t    (~PCIE_CLIENT_INT_CLI), PCIE_CLIENT_INT_MASK);\n\trockchip_pcie_write(rockchip, (u32)(~PCIE_CORE_INT),\n\t\t\t    PCIE_CORE_INT_MASK);\n\n\trockchip_pcie_enable_bw_int(rockchip);\n}\n\nstatic int rockchip_pcie_intx_map(struct irq_domain *domain, unsigned int irq,\n\t\t\t\t  irq_hw_number_t hwirq)\n{\n\tirq_set_chip_and_handler(irq, &dummy_irq_chip, handle_simple_irq);\n\tirq_set_chip_data(irq, domain->host_data);\n\n\treturn 0;\n}\n\nstatic const struct irq_domain_ops intx_domain_ops = {\n\t.map = rockchip_pcie_intx_map,\n};\n\nstatic int rockchip_pcie_init_irq_domain(struct rockchip_pcie *rockchip)\n{\n\tstruct device *dev = rockchip->dev;\n\tstruct device_node *intc = of_get_next_child(dev->of_node, NULL);\n\n\tif (!intc) {\n\t\tdev_err(dev, \"missing child interrupt-controller node\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\trockchip->irq_domain = irq_domain_add_linear(intc, PCI_NUM_INTX,\n\t\t\t\t\t\t    &intx_domain_ops, rockchip);\n\tof_node_put(intc);\n\tif (!rockchip->irq_domain) {\n\t\tdev_err(dev, \"failed to get a INTx IRQ domain\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int rockchip_pcie_prog_ob_atu(struct rockchip_pcie *rockchip,\n\t\t\t\t     int region_no, int type, u8 num_pass_bits,\n\t\t\t\t     u32 lower_addr, u32 upper_addr)\n{\n\tu32 ob_addr_0;\n\tu32 ob_addr_1;\n\tu32 ob_desc_0;\n\tu32 aw_offset;\n\n\tif (region_no >= MAX_AXI_WRAPPER_REGION_NUM)\n\t\treturn -EINVAL;\n\tif (num_pass_bits + 1 < 8)\n\t\treturn -EINVAL;\n\tif (num_pass_bits > 63)\n\t\treturn -EINVAL;\n\tif (region_no == 0) {\n\t\tif (AXI_REGION_0_SIZE < (2ULL << num_pass_bits))\n\t\t\treturn -EINVAL;\n\t}\n\tif (region_no != 0) {\n\t\tif (AXI_REGION_SIZE < (2ULL << num_pass_bits))\n\t\t\treturn -EINVAL;\n\t}\n\n\taw_offset = (region_no << OB_REG_SIZE_SHIFT);\n\n\tob_addr_0 = num_pass_bits & PCIE_CORE_OB_REGION_ADDR0_NUM_BITS;\n\tob_addr_0 |= lower_addr & PCIE_CORE_OB_REGION_ADDR0_LO_ADDR;\n\tob_addr_1 = upper_addr;\n\tob_desc_0 = (1 << 23 | type);\n\n\trockchip_pcie_write(rockchip, ob_addr_0,\n\t\t\t    PCIE_CORE_OB_REGION_ADDR0 + aw_offset);\n\trockchip_pcie_write(rockchip, ob_addr_1,\n\t\t\t    PCIE_CORE_OB_REGION_ADDR1 + aw_offset);\n\trockchip_pcie_write(rockchip, ob_desc_0,\n\t\t\t    PCIE_CORE_OB_REGION_DESC0 + aw_offset);\n\trockchip_pcie_write(rockchip, 0,\n\t\t\t    PCIE_CORE_OB_REGION_DESC1 + aw_offset);\n\n\treturn 0;\n}\n\nstatic int rockchip_pcie_prog_ib_atu(struct rockchip_pcie *rockchip,\n\t\t\t\t     int region_no, u8 num_pass_bits,\n\t\t\t\t     u32 lower_addr, u32 upper_addr)\n{\n\tu32 ib_addr_0;\n\tu32 ib_addr_1;\n\tu32 aw_offset;\n\n\tif (region_no > MAX_AXI_IB_ROOTPORT_REGION_NUM)\n\t\treturn -EINVAL;\n\tif (num_pass_bits + 1 < MIN_AXI_ADDR_BITS_PASSED)\n\t\treturn -EINVAL;\n\tif (num_pass_bits > 63)\n\t\treturn -EINVAL;\n\n\taw_offset = (region_no << IB_ROOT_PORT_REG_SIZE_SHIFT);\n\n\tib_addr_0 = num_pass_bits & PCIE_CORE_IB_REGION_ADDR0_NUM_BITS;\n\tib_addr_0 |= (lower_addr << 8) & PCIE_CORE_IB_REGION_ADDR0_LO_ADDR;\n\tib_addr_1 = upper_addr;\n\n\trockchip_pcie_write(rockchip, ib_addr_0, PCIE_RP_IB_ADDR0 + aw_offset);\n\trockchip_pcie_write(rockchip, ib_addr_1, PCIE_RP_IB_ADDR1 + aw_offset);\n\n\treturn 0;\n}\n\nstatic int rockchip_pcie_cfg_atu(struct rockchip_pcie *rockchip)\n{\n\tstruct device *dev = rockchip->dev;\n\tstruct pci_host_bridge *bridge = pci_host_bridge_from_priv(rockchip);\n\tstruct resource_entry *entry;\n\tu64 pci_addr, size;\n\tint offset;\n\tint err;\n\tint reg_no;\n\n\trockchip_pcie_cfg_configuration_accesses(rockchip,\n\t\t\t\t\t\t AXI_WRAPPER_TYPE0_CFG);\n\tentry = resource_list_first_type(&bridge->windows, IORESOURCE_MEM);\n\tif (!entry)\n\t\treturn -ENODEV;\n\n\tsize = resource_size(entry->res);\n\tpci_addr = entry->res->start - entry->offset;\n\trockchip->msg_bus_addr = pci_addr;\n\n\tfor (reg_no = 0; reg_no < (size >> 20); reg_no++) {\n\t\terr = rockchip_pcie_prog_ob_atu(rockchip, reg_no + 1,\n\t\t\t\t\t\tAXI_WRAPPER_MEM_WRITE,\n\t\t\t\t\t\t20 - 1,\n\t\t\t\t\t\tpci_addr + (reg_no << 20),\n\t\t\t\t\t\t0);\n\t\tif (err) {\n\t\t\tdev_err(dev, \"program RC mem outbound ATU failed\\n\");\n\t\t\treturn err;\n\t\t}\n\t}\n\n\terr = rockchip_pcie_prog_ib_atu(rockchip, 2, 32 - 1, 0x0, 0);\n\tif (err) {\n\t\tdev_err(dev, \"program RC mem inbound ATU failed\\n\");\n\t\treturn err;\n\t}\n\n\tentry = resource_list_first_type(&bridge->windows, IORESOURCE_IO);\n\tif (!entry)\n\t\treturn -ENODEV;\n\n\t \n\toffset = size >> 20;\n\n\tsize = resource_size(entry->res);\n\tpci_addr = entry->res->start - entry->offset;\n\n\tfor (reg_no = 0; reg_no < (size >> 20); reg_no++) {\n\t\terr = rockchip_pcie_prog_ob_atu(rockchip,\n\t\t\t\t\t\treg_no + 1 + offset,\n\t\t\t\t\t\tAXI_WRAPPER_IO_WRITE,\n\t\t\t\t\t\t20 - 1,\n\t\t\t\t\t\tpci_addr + (reg_no << 20),\n\t\t\t\t\t\t0);\n\t\tif (err) {\n\t\t\tdev_err(dev, \"program RC io outbound ATU failed\\n\");\n\t\t\treturn err;\n\t\t}\n\t}\n\n\t \n\trockchip_pcie_prog_ob_atu(rockchip, reg_no + 1 + offset,\n\t\t\t\t  AXI_WRAPPER_NOR_MSG,\n\t\t\t\t  20 - 1, 0, 0);\n\n\trockchip->msg_bus_addr += ((reg_no + offset) << 20);\n\treturn err;\n}\n\nstatic int rockchip_pcie_wait_l2(struct rockchip_pcie *rockchip)\n{\n\tu32 value;\n\tint err;\n\n\t \n\twritel(0x0, rockchip->msg_region + PCIE_RC_SEND_PME_OFF);\n\n\t \n\terr = readl_poll_timeout(rockchip->apb_base + PCIE_CLIENT_DEBUG_OUT_0,\n\t\t\t\t value, PCIE_LINK_IS_L2(value), 20,\n\t\t\t\t jiffies_to_usecs(5 * HZ));\n\tif (err) {\n\t\tdev_err(rockchip->dev, \"PCIe link enter L2 timeout!\\n\");\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int rockchip_pcie_suspend_noirq(struct device *dev)\n{\n\tstruct rockchip_pcie *rockchip = dev_get_drvdata(dev);\n\tint ret;\n\n\t \n\trockchip_pcie_write(rockchip, (PCIE_CLIENT_INT_CLI << 16) |\n\t\t\t    PCIE_CLIENT_INT_CLI, PCIE_CLIENT_INT_MASK);\n\trockchip_pcie_write(rockchip, (u32)PCIE_CORE_INT, PCIE_CORE_INT_MASK);\n\n\tret = rockchip_pcie_wait_l2(rockchip);\n\tif (ret) {\n\t\trockchip_pcie_enable_interrupts(rockchip);\n\t\treturn ret;\n\t}\n\n\trockchip_pcie_deinit_phys(rockchip);\n\n\trockchip_pcie_disable_clocks(rockchip);\n\n\tregulator_disable(rockchip->vpcie0v9);\n\n\treturn ret;\n}\n\nstatic int rockchip_pcie_resume_noirq(struct device *dev)\n{\n\tstruct rockchip_pcie *rockchip = dev_get_drvdata(dev);\n\tint err;\n\n\terr = regulator_enable(rockchip->vpcie0v9);\n\tif (err) {\n\t\tdev_err(dev, \"fail to enable vpcie0v9 regulator\\n\");\n\t\treturn err;\n\t}\n\n\terr = rockchip_pcie_enable_clocks(rockchip);\n\tif (err)\n\t\tgoto err_disable_0v9;\n\n\terr = rockchip_pcie_host_init_port(rockchip);\n\tif (err)\n\t\tgoto err_pcie_resume;\n\n\terr = rockchip_pcie_cfg_atu(rockchip);\n\tif (err)\n\t\tgoto err_err_deinit_port;\n\n\t \n\trockchip_pcie_update_txcredit_mui(rockchip);\n\trockchip_pcie_enable_interrupts(rockchip);\n\n\treturn 0;\n\nerr_err_deinit_port:\n\trockchip_pcie_deinit_phys(rockchip);\nerr_pcie_resume:\n\trockchip_pcie_disable_clocks(rockchip);\nerr_disable_0v9:\n\tregulator_disable(rockchip->vpcie0v9);\n\treturn err;\n}\n\nstatic int rockchip_pcie_probe(struct platform_device *pdev)\n{\n\tstruct rockchip_pcie *rockchip;\n\tstruct device *dev = &pdev->dev;\n\tstruct pci_host_bridge *bridge;\n\tint err;\n\n\tif (!dev->of_node)\n\t\treturn -ENODEV;\n\n\tbridge = devm_pci_alloc_host_bridge(dev, sizeof(*rockchip));\n\tif (!bridge)\n\t\treturn -ENOMEM;\n\n\trockchip = pci_host_bridge_priv(bridge);\n\n\tplatform_set_drvdata(pdev, rockchip);\n\trockchip->dev = dev;\n\trockchip->is_rc = true;\n\n\terr = rockchip_pcie_parse_host_dt(rockchip);\n\tif (err)\n\t\treturn err;\n\n\terr = rockchip_pcie_enable_clocks(rockchip);\n\tif (err)\n\t\treturn err;\n\n\terr = rockchip_pcie_set_vpcie(rockchip);\n\tif (err) {\n\t\tdev_err(dev, \"failed to set vpcie regulator\\n\");\n\t\tgoto err_set_vpcie;\n\t}\n\n\terr = rockchip_pcie_host_init_port(rockchip);\n\tif (err)\n\t\tgoto err_vpcie;\n\n\terr = rockchip_pcie_init_irq_domain(rockchip);\n\tif (err < 0)\n\t\tgoto err_deinit_port;\n\n\terr = rockchip_pcie_cfg_atu(rockchip);\n\tif (err)\n\t\tgoto err_remove_irq_domain;\n\n\trockchip->msg_region = devm_ioremap(dev, rockchip->msg_bus_addr, SZ_1M);\n\tif (!rockchip->msg_region) {\n\t\terr = -ENOMEM;\n\t\tgoto err_remove_irq_domain;\n\t}\n\n\tbridge->sysdata = rockchip;\n\tbridge->ops = &rockchip_pcie_ops;\n\n\terr = rockchip_pcie_setup_irq(rockchip);\n\tif (err)\n\t\tgoto err_remove_irq_domain;\n\n\trockchip_pcie_enable_interrupts(rockchip);\n\n\terr = pci_host_probe(bridge);\n\tif (err < 0)\n\t\tgoto err_remove_irq_domain;\n\n\treturn 0;\n\nerr_remove_irq_domain:\n\tirq_domain_remove(rockchip->irq_domain);\nerr_deinit_port:\n\trockchip_pcie_deinit_phys(rockchip);\nerr_vpcie:\n\tif (!IS_ERR(rockchip->vpcie12v))\n\t\tregulator_disable(rockchip->vpcie12v);\n\tif (!IS_ERR(rockchip->vpcie3v3))\n\t\tregulator_disable(rockchip->vpcie3v3);\n\tregulator_disable(rockchip->vpcie1v8);\n\tregulator_disable(rockchip->vpcie0v9);\nerr_set_vpcie:\n\trockchip_pcie_disable_clocks(rockchip);\n\treturn err;\n}\n\nstatic void rockchip_pcie_remove(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct rockchip_pcie *rockchip = dev_get_drvdata(dev);\n\tstruct pci_host_bridge *bridge = pci_host_bridge_from_priv(rockchip);\n\n\tpci_stop_root_bus(bridge->bus);\n\tpci_remove_root_bus(bridge->bus);\n\tirq_domain_remove(rockchip->irq_domain);\n\n\trockchip_pcie_deinit_phys(rockchip);\n\n\trockchip_pcie_disable_clocks(rockchip);\n\n\tif (!IS_ERR(rockchip->vpcie12v))\n\t\tregulator_disable(rockchip->vpcie12v);\n\tif (!IS_ERR(rockchip->vpcie3v3))\n\t\tregulator_disable(rockchip->vpcie3v3);\n\tregulator_disable(rockchip->vpcie1v8);\n\tregulator_disable(rockchip->vpcie0v9);\n}\n\nstatic const struct dev_pm_ops rockchip_pcie_pm_ops = {\n\tNOIRQ_SYSTEM_SLEEP_PM_OPS(rockchip_pcie_suspend_noirq,\n\t\t\t\t  rockchip_pcie_resume_noirq)\n};\n\nstatic const struct of_device_id rockchip_pcie_of_match[] = {\n\t{ .compatible = \"rockchip,rk3399-pcie\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, rockchip_pcie_of_match);\n\nstatic struct platform_driver rockchip_pcie_driver = {\n\t.driver = {\n\t\t.name = \"rockchip-pcie\",\n\t\t.of_match_table = rockchip_pcie_of_match,\n\t\t.pm = &rockchip_pcie_pm_ops,\n\t},\n\t.probe = rockchip_pcie_probe,\n\t.remove_new = rockchip_pcie_remove,\n};\nmodule_platform_driver(rockchip_pcie_driver);\n\nMODULE_AUTHOR(\"Rockchip Inc\");\nMODULE_DESCRIPTION(\"Rockchip AXI PCIe driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}