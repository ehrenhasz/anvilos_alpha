{
  "module_name": "pcie-cadence-ep.c",
  "hash_id": "29d1652b4748646381c0e2f7ea97e4ed4d50f49056048ead78cc16b25bb7d739",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/controller/cadence/pcie-cadence-ep.c",
  "human_readable_source": "\n\n\n\n\n#include <linux/delay.h>\n#include <linux/kernel.h>\n#include <linux/of.h>\n#include <linux/pci-epc.h>\n#include <linux/platform_device.h>\n#include <linux/sizes.h>\n\n#include \"pcie-cadence.h\"\n\n#define CDNS_PCIE_EP_MIN_APERTURE\t\t128\t \n#define CDNS_PCIE_EP_IRQ_PCI_ADDR_NONE\t\t0x1\n#define CDNS_PCIE_EP_IRQ_PCI_ADDR_LEGACY\t0x3\n\nstatic u8 cdns_pcie_get_fn_from_vfn(struct cdns_pcie *pcie, u8 fn, u8 vfn)\n{\n\tu32 cap = CDNS_PCIE_EP_FUNC_SRIOV_CAP_OFFSET;\n\tu32 first_vf_offset, stride;\n\n\tif (vfn == 0)\n\t\treturn fn;\n\n\tfirst_vf_offset = cdns_pcie_ep_fn_readw(pcie, fn, cap + PCI_SRIOV_VF_OFFSET);\n\tstride = cdns_pcie_ep_fn_readw(pcie, fn, cap +  PCI_SRIOV_VF_STRIDE);\n\tfn = fn + first_vf_offset + ((vfn - 1) * stride);\n\n\treturn fn;\n}\n\nstatic int cdns_pcie_ep_write_header(struct pci_epc *epc, u8 fn, u8 vfn,\n\t\t\t\t     struct pci_epf_header *hdr)\n{\n\tstruct cdns_pcie_ep *ep = epc_get_drvdata(epc);\n\tu32 cap = CDNS_PCIE_EP_FUNC_SRIOV_CAP_OFFSET;\n\tstruct cdns_pcie *pcie = &ep->pcie;\n\tu32 reg;\n\n\tif (vfn > 1) {\n\t\tdev_err(&epc->dev, \"Only Virtual Function #1 has deviceID\\n\");\n\t\treturn -EINVAL;\n\t} else if (vfn == 1) {\n\t\treg = cap + PCI_SRIOV_VF_DID;\n\t\tcdns_pcie_ep_fn_writew(pcie, fn, reg, hdr->deviceid);\n\t\treturn 0;\n\t}\n\n\tcdns_pcie_ep_fn_writew(pcie, fn, PCI_DEVICE_ID, hdr->deviceid);\n\tcdns_pcie_ep_fn_writeb(pcie, fn, PCI_REVISION_ID, hdr->revid);\n\tcdns_pcie_ep_fn_writeb(pcie, fn, PCI_CLASS_PROG, hdr->progif_code);\n\tcdns_pcie_ep_fn_writew(pcie, fn, PCI_CLASS_DEVICE,\n\t\t\t       hdr->subclass_code | hdr->baseclass_code << 8);\n\tcdns_pcie_ep_fn_writeb(pcie, fn, PCI_CACHE_LINE_SIZE,\n\t\t\t       hdr->cache_line_size);\n\tcdns_pcie_ep_fn_writew(pcie, fn, PCI_SUBSYSTEM_ID, hdr->subsys_id);\n\tcdns_pcie_ep_fn_writeb(pcie, fn, PCI_INTERRUPT_PIN, hdr->interrupt_pin);\n\n\t \n\tif (fn == 0) {\n\t\t \n\t\tu32 id = CDNS_PCIE_LM_ID_VENDOR(hdr->vendorid) |\n\t\t\t CDNS_PCIE_LM_ID_SUBSYS(hdr->subsys_vendor_id);\n\n\t\tcdns_pcie_writel(pcie, CDNS_PCIE_LM_ID, id);\n\t}\n\n\treturn 0;\n}\n\nstatic int cdns_pcie_ep_set_bar(struct pci_epc *epc, u8 fn, u8 vfn,\n\t\t\t\tstruct pci_epf_bar *epf_bar)\n{\n\tstruct cdns_pcie_ep *ep = epc_get_drvdata(epc);\n\tstruct cdns_pcie_epf *epf = &ep->epf[fn];\n\tstruct cdns_pcie *pcie = &ep->pcie;\n\tdma_addr_t bar_phys = epf_bar->phys_addr;\n\tenum pci_barno bar = epf_bar->barno;\n\tint flags = epf_bar->flags;\n\tu32 addr0, addr1, reg, cfg, b, aperture, ctrl;\n\tu64 sz;\n\n\t \n\tsz = max_t(size_t, epf_bar->size, CDNS_PCIE_EP_MIN_APERTURE);\n\t \n\tsz = 1ULL << fls64(sz - 1);\n\taperture = ilog2(sz) - 7;  \n\n\tif ((flags & PCI_BASE_ADDRESS_SPACE) == PCI_BASE_ADDRESS_SPACE_IO) {\n\t\tctrl = CDNS_PCIE_LM_BAR_CFG_CTRL_IO_32BITS;\n\t} else {\n\t\tbool is_prefetch = !!(flags & PCI_BASE_ADDRESS_MEM_PREFETCH);\n\t\tbool is_64bits = sz > SZ_2G;\n\n\t\tif (is_64bits && (bar & 1))\n\t\t\treturn -EINVAL;\n\n\t\tif (is_64bits && !(flags & PCI_BASE_ADDRESS_MEM_TYPE_64))\n\t\t\tepf_bar->flags |= PCI_BASE_ADDRESS_MEM_TYPE_64;\n\n\t\tif (is_64bits && is_prefetch)\n\t\t\tctrl = CDNS_PCIE_LM_BAR_CFG_CTRL_PREFETCH_MEM_64BITS;\n\t\telse if (is_prefetch)\n\t\t\tctrl = CDNS_PCIE_LM_BAR_CFG_CTRL_PREFETCH_MEM_32BITS;\n\t\telse if (is_64bits)\n\t\t\tctrl = CDNS_PCIE_LM_BAR_CFG_CTRL_MEM_64BITS;\n\t\telse\n\t\t\tctrl = CDNS_PCIE_LM_BAR_CFG_CTRL_MEM_32BITS;\n\t}\n\n\taddr0 = lower_32_bits(bar_phys);\n\taddr1 = upper_32_bits(bar_phys);\n\n\tif (vfn == 1)\n\t\treg = CDNS_PCIE_LM_EP_VFUNC_BAR_CFG(bar, fn);\n\telse\n\t\treg = CDNS_PCIE_LM_EP_FUNC_BAR_CFG(bar, fn);\n\tb = (bar < BAR_4) ? bar : bar - BAR_4;\n\n\tif (vfn == 0 || vfn == 1) {\n\t\tcfg = cdns_pcie_readl(pcie, reg);\n\t\tcfg &= ~(CDNS_PCIE_LM_EP_FUNC_BAR_CFG_BAR_APERTURE_MASK(b) |\n\t\t\t CDNS_PCIE_LM_EP_FUNC_BAR_CFG_BAR_CTRL_MASK(b));\n\t\tcfg |= (CDNS_PCIE_LM_EP_FUNC_BAR_CFG_BAR_APERTURE(b, aperture) |\n\t\t\tCDNS_PCIE_LM_EP_FUNC_BAR_CFG_BAR_CTRL(b, ctrl));\n\t\tcdns_pcie_writel(pcie, reg, cfg);\n\t}\n\n\tfn = cdns_pcie_get_fn_from_vfn(pcie, fn, vfn);\n\tcdns_pcie_writel(pcie, CDNS_PCIE_AT_IB_EP_FUNC_BAR_ADDR0(fn, bar),\n\t\t\t addr0);\n\tcdns_pcie_writel(pcie, CDNS_PCIE_AT_IB_EP_FUNC_BAR_ADDR1(fn, bar),\n\t\t\t addr1);\n\n\tif (vfn > 0)\n\t\tepf = &epf->epf[vfn - 1];\n\tepf->epf_bar[bar] = epf_bar;\n\n\treturn 0;\n}\n\nstatic void cdns_pcie_ep_clear_bar(struct pci_epc *epc, u8 fn, u8 vfn,\n\t\t\t\t   struct pci_epf_bar *epf_bar)\n{\n\tstruct cdns_pcie_ep *ep = epc_get_drvdata(epc);\n\tstruct cdns_pcie_epf *epf = &ep->epf[fn];\n\tstruct cdns_pcie *pcie = &ep->pcie;\n\tenum pci_barno bar = epf_bar->barno;\n\tu32 reg, cfg, b, ctrl;\n\n\tif (vfn == 1)\n\t\treg = CDNS_PCIE_LM_EP_VFUNC_BAR_CFG(bar, fn);\n\telse\n\t\treg = CDNS_PCIE_LM_EP_FUNC_BAR_CFG(bar, fn);\n\tb = (bar < BAR_4) ? bar : bar - BAR_4;\n\n\tif (vfn == 0 || vfn == 1) {\n\t\tctrl = CDNS_PCIE_LM_BAR_CFG_CTRL_DISABLED;\n\t\tcfg = cdns_pcie_readl(pcie, reg);\n\t\tcfg &= ~(CDNS_PCIE_LM_EP_FUNC_BAR_CFG_BAR_APERTURE_MASK(b) |\n\t\t\t CDNS_PCIE_LM_EP_FUNC_BAR_CFG_BAR_CTRL_MASK(b));\n\t\tcfg |= CDNS_PCIE_LM_EP_FUNC_BAR_CFG_BAR_CTRL(b, ctrl);\n\t\tcdns_pcie_writel(pcie, reg, cfg);\n\t}\n\n\tfn = cdns_pcie_get_fn_from_vfn(pcie, fn, vfn);\n\tcdns_pcie_writel(pcie, CDNS_PCIE_AT_IB_EP_FUNC_BAR_ADDR0(fn, bar), 0);\n\tcdns_pcie_writel(pcie, CDNS_PCIE_AT_IB_EP_FUNC_BAR_ADDR1(fn, bar), 0);\n\n\tif (vfn > 0)\n\t\tepf = &epf->epf[vfn - 1];\n\tepf->epf_bar[bar] = NULL;\n}\n\nstatic int cdns_pcie_ep_map_addr(struct pci_epc *epc, u8 fn, u8 vfn,\n\t\t\t\t phys_addr_t addr, u64 pci_addr, size_t size)\n{\n\tstruct cdns_pcie_ep *ep = epc_get_drvdata(epc);\n\tstruct cdns_pcie *pcie = &ep->pcie;\n\tu32 r;\n\n\tr = find_first_zero_bit(&ep->ob_region_map, BITS_PER_LONG);\n\tif (r >= ep->max_regions - 1) {\n\t\tdev_err(&epc->dev, \"no free outbound region\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tfn = cdns_pcie_get_fn_from_vfn(pcie, fn, vfn);\n\tcdns_pcie_set_outbound_region(pcie, 0, fn, r, false, addr, pci_addr, size);\n\n\tset_bit(r, &ep->ob_region_map);\n\tep->ob_addr[r] = addr;\n\n\treturn 0;\n}\n\nstatic void cdns_pcie_ep_unmap_addr(struct pci_epc *epc, u8 fn, u8 vfn,\n\t\t\t\t    phys_addr_t addr)\n{\n\tstruct cdns_pcie_ep *ep = epc_get_drvdata(epc);\n\tstruct cdns_pcie *pcie = &ep->pcie;\n\tu32 r;\n\n\tfor (r = 0; r < ep->max_regions - 1; r++)\n\t\tif (ep->ob_addr[r] == addr)\n\t\t\tbreak;\n\n\tif (r == ep->max_regions - 1)\n\t\treturn;\n\n\tcdns_pcie_reset_outbound_region(pcie, r);\n\n\tep->ob_addr[r] = 0;\n\tclear_bit(r, &ep->ob_region_map);\n}\n\nstatic int cdns_pcie_ep_set_msi(struct pci_epc *epc, u8 fn, u8 vfn, u8 mmc)\n{\n\tstruct cdns_pcie_ep *ep = epc_get_drvdata(epc);\n\tstruct cdns_pcie *pcie = &ep->pcie;\n\tu32 cap = CDNS_PCIE_EP_FUNC_MSI_CAP_OFFSET;\n\tu16 flags;\n\n\tfn = cdns_pcie_get_fn_from_vfn(pcie, fn, vfn);\n\n\t \n\tflags = cdns_pcie_ep_fn_readw(pcie, fn, cap + PCI_MSI_FLAGS);\n\tflags = (flags & ~PCI_MSI_FLAGS_QMASK) | (mmc << 1);\n\tflags |= PCI_MSI_FLAGS_64BIT;\n\tflags &= ~PCI_MSI_FLAGS_MASKBIT;\n\tcdns_pcie_ep_fn_writew(pcie, fn, cap + PCI_MSI_FLAGS, flags);\n\n\treturn 0;\n}\n\nstatic int cdns_pcie_ep_get_msi(struct pci_epc *epc, u8 fn, u8 vfn)\n{\n\tstruct cdns_pcie_ep *ep = epc_get_drvdata(epc);\n\tstruct cdns_pcie *pcie = &ep->pcie;\n\tu32 cap = CDNS_PCIE_EP_FUNC_MSI_CAP_OFFSET;\n\tu16 flags, mme;\n\n\tfn = cdns_pcie_get_fn_from_vfn(pcie, fn, vfn);\n\n\t \n\tflags = cdns_pcie_ep_fn_readw(pcie, fn, cap + PCI_MSI_FLAGS);\n\tif (!(flags & PCI_MSI_FLAGS_ENABLE))\n\t\treturn -EINVAL;\n\n\t \n\tmme = (flags & PCI_MSI_FLAGS_QSIZE) >> 4;\n\n\treturn mme;\n}\n\nstatic int cdns_pcie_ep_get_msix(struct pci_epc *epc, u8 func_no, u8 vfunc_no)\n{\n\tstruct cdns_pcie_ep *ep = epc_get_drvdata(epc);\n\tstruct cdns_pcie *pcie = &ep->pcie;\n\tu32 cap = CDNS_PCIE_EP_FUNC_MSIX_CAP_OFFSET;\n\tu32 val, reg;\n\n\tfunc_no = cdns_pcie_get_fn_from_vfn(pcie, func_no, vfunc_no);\n\n\treg = cap + PCI_MSIX_FLAGS;\n\tval = cdns_pcie_ep_fn_readw(pcie, func_no, reg);\n\tif (!(val & PCI_MSIX_FLAGS_ENABLE))\n\t\treturn -EINVAL;\n\n\tval &= PCI_MSIX_FLAGS_QSIZE;\n\n\treturn val;\n}\n\nstatic int cdns_pcie_ep_set_msix(struct pci_epc *epc, u8 fn, u8 vfn,\n\t\t\t\t u16 interrupts, enum pci_barno bir,\n\t\t\t\t u32 offset)\n{\n\tstruct cdns_pcie_ep *ep = epc_get_drvdata(epc);\n\tstruct cdns_pcie *pcie = &ep->pcie;\n\tu32 cap = CDNS_PCIE_EP_FUNC_MSIX_CAP_OFFSET;\n\tu32 val, reg;\n\n\tfn = cdns_pcie_get_fn_from_vfn(pcie, fn, vfn);\n\n\treg = cap + PCI_MSIX_FLAGS;\n\tval = cdns_pcie_ep_fn_readw(pcie, fn, reg);\n\tval &= ~PCI_MSIX_FLAGS_QSIZE;\n\tval |= interrupts;\n\tcdns_pcie_ep_fn_writew(pcie, fn, reg, val);\n\n\t \n\treg = cap + PCI_MSIX_TABLE;\n\tval = offset | bir;\n\tcdns_pcie_ep_fn_writel(pcie, fn, reg, val);\n\n\t \n\treg = cap + PCI_MSIX_PBA;\n\tval = (offset + (interrupts * PCI_MSIX_ENTRY_SIZE)) | bir;\n\tcdns_pcie_ep_fn_writel(pcie, fn, reg, val);\n\n\treturn 0;\n}\n\nstatic void cdns_pcie_ep_assert_intx(struct cdns_pcie_ep *ep, u8 fn, u8 intx,\n\t\t\t\t     bool is_asserted)\n{\n\tstruct cdns_pcie *pcie = &ep->pcie;\n\tunsigned long flags;\n\tu32 offset;\n\tu16 status;\n\tu8 msg_code;\n\n\tintx &= 3;\n\n\t \n\tif (unlikely(ep->irq_pci_addr != CDNS_PCIE_EP_IRQ_PCI_ADDR_LEGACY ||\n\t\t     ep->irq_pci_fn != fn)) {\n\t\t \n\t\tcdns_pcie_set_outbound_region_for_normal_msg(pcie, 0, fn, 0,\n\t\t\t\t\t\t\t     ep->irq_phys_addr);\n\t\tep->irq_pci_addr = CDNS_PCIE_EP_IRQ_PCI_ADDR_LEGACY;\n\t\tep->irq_pci_fn = fn;\n\t}\n\n\tif (is_asserted) {\n\t\tep->irq_pending |= BIT(intx);\n\t\tmsg_code = MSG_CODE_ASSERT_INTA + intx;\n\t} else {\n\t\tep->irq_pending &= ~BIT(intx);\n\t\tmsg_code = MSG_CODE_DEASSERT_INTA + intx;\n\t}\n\n\tspin_lock_irqsave(&ep->lock, flags);\n\tstatus = cdns_pcie_ep_fn_readw(pcie, fn, PCI_STATUS);\n\tif (((status & PCI_STATUS_INTERRUPT) != 0) ^ (ep->irq_pending != 0)) {\n\t\tstatus ^= PCI_STATUS_INTERRUPT;\n\t\tcdns_pcie_ep_fn_writew(pcie, fn, PCI_STATUS, status);\n\t}\n\tspin_unlock_irqrestore(&ep->lock, flags);\n\n\toffset = CDNS_PCIE_NORMAL_MSG_ROUTING(MSG_ROUTING_LOCAL) |\n\t\t CDNS_PCIE_NORMAL_MSG_CODE(msg_code) |\n\t\t CDNS_PCIE_MSG_NO_DATA;\n\twritel(0, ep->irq_cpu_addr + offset);\n}\n\nstatic int cdns_pcie_ep_send_legacy_irq(struct cdns_pcie_ep *ep, u8 fn, u8 vfn,\n\t\t\t\t\tu8 intx)\n{\n\tu16 cmd;\n\n\tcmd = cdns_pcie_ep_fn_readw(&ep->pcie, fn, PCI_COMMAND);\n\tif (cmd & PCI_COMMAND_INTX_DISABLE)\n\t\treturn -EINVAL;\n\n\tcdns_pcie_ep_assert_intx(ep, fn, intx, true);\n\t \n\tmdelay(1);\n\tcdns_pcie_ep_assert_intx(ep, fn, intx, false);\n\treturn 0;\n}\n\nstatic int cdns_pcie_ep_send_msi_irq(struct cdns_pcie_ep *ep, u8 fn, u8 vfn,\n\t\t\t\t     u8 interrupt_num)\n{\n\tstruct cdns_pcie *pcie = &ep->pcie;\n\tu32 cap = CDNS_PCIE_EP_FUNC_MSI_CAP_OFFSET;\n\tu16 flags, mme, data, data_mask;\n\tu8 msi_count;\n\tu64 pci_addr, pci_addr_mask = 0xff;\n\n\tfn = cdns_pcie_get_fn_from_vfn(pcie, fn, vfn);\n\n\t \n\tflags = cdns_pcie_ep_fn_readw(pcie, fn, cap + PCI_MSI_FLAGS);\n\tif (!(flags & PCI_MSI_FLAGS_ENABLE))\n\t\treturn -EINVAL;\n\n\t \n\tmme = (flags & PCI_MSI_FLAGS_QSIZE) >> 4;\n\tmsi_count = 1 << mme;\n\tif (!interrupt_num || interrupt_num > msi_count)\n\t\treturn -EINVAL;\n\n\t \n\tdata_mask = msi_count - 1;\n\tdata = cdns_pcie_ep_fn_readw(pcie, fn, cap + PCI_MSI_DATA_64);\n\tdata = (data & ~data_mask) | ((interrupt_num - 1) & data_mask);\n\n\t \n\tpci_addr = cdns_pcie_ep_fn_readl(pcie, fn, cap + PCI_MSI_ADDRESS_HI);\n\tpci_addr <<= 32;\n\tpci_addr |= cdns_pcie_ep_fn_readl(pcie, fn, cap + PCI_MSI_ADDRESS_LO);\n\tpci_addr &= GENMASK_ULL(63, 2);\n\n\t \n\tif (unlikely(ep->irq_pci_addr != (pci_addr & ~pci_addr_mask) ||\n\t\t     ep->irq_pci_fn != fn)) {\n\t\t \n\t\tcdns_pcie_set_outbound_region(pcie, 0, fn, 0,\n\t\t\t\t\t      false,\n\t\t\t\t\t      ep->irq_phys_addr,\n\t\t\t\t\t      pci_addr & ~pci_addr_mask,\n\t\t\t\t\t      pci_addr_mask + 1);\n\t\tep->irq_pci_addr = (pci_addr & ~pci_addr_mask);\n\t\tep->irq_pci_fn = fn;\n\t}\n\twritel(data, ep->irq_cpu_addr + (pci_addr & pci_addr_mask));\n\n\treturn 0;\n}\n\nstatic int cdns_pcie_ep_map_msi_irq(struct pci_epc *epc, u8 fn, u8 vfn,\n\t\t\t\t    phys_addr_t addr, u8 interrupt_num,\n\t\t\t\t    u32 entry_size, u32 *msi_data,\n\t\t\t\t    u32 *msi_addr_offset)\n{\n\tstruct cdns_pcie_ep *ep = epc_get_drvdata(epc);\n\tu32 cap = CDNS_PCIE_EP_FUNC_MSI_CAP_OFFSET;\n\tstruct cdns_pcie *pcie = &ep->pcie;\n\tu64 pci_addr, pci_addr_mask = 0xff;\n\tu16 flags, mme, data, data_mask;\n\tu8 msi_count;\n\tint ret;\n\tint i;\n\n\tfn = cdns_pcie_get_fn_from_vfn(pcie, fn, vfn);\n\n\t \n\tflags = cdns_pcie_ep_fn_readw(pcie, fn, cap + PCI_MSI_FLAGS);\n\tif (!(flags & PCI_MSI_FLAGS_ENABLE))\n\t\treturn -EINVAL;\n\n\t \n\tmme = (flags & PCI_MSI_FLAGS_QSIZE) >> 4;\n\tmsi_count = 1 << mme;\n\tif (!interrupt_num || interrupt_num > msi_count)\n\t\treturn -EINVAL;\n\n\t \n\tdata_mask = msi_count - 1;\n\tdata = cdns_pcie_ep_fn_readw(pcie, fn, cap + PCI_MSI_DATA_64);\n\tdata = data & ~data_mask;\n\n\t \n\tpci_addr = cdns_pcie_ep_fn_readl(pcie, fn, cap + PCI_MSI_ADDRESS_HI);\n\tpci_addr <<= 32;\n\tpci_addr |= cdns_pcie_ep_fn_readl(pcie, fn, cap + PCI_MSI_ADDRESS_LO);\n\tpci_addr &= GENMASK_ULL(63, 2);\n\n\tfor (i = 0; i < interrupt_num; i++) {\n\t\tret = cdns_pcie_ep_map_addr(epc, fn, vfn, addr,\n\t\t\t\t\t    pci_addr & ~pci_addr_mask,\n\t\t\t\t\t    entry_size);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\taddr = addr + entry_size;\n\t}\n\n\t*msi_data = data;\n\t*msi_addr_offset = pci_addr & pci_addr_mask;\n\n\treturn 0;\n}\n\nstatic int cdns_pcie_ep_send_msix_irq(struct cdns_pcie_ep *ep, u8 fn, u8 vfn,\n\t\t\t\t      u16 interrupt_num)\n{\n\tu32 cap = CDNS_PCIE_EP_FUNC_MSIX_CAP_OFFSET;\n\tu32 tbl_offset, msg_data, reg;\n\tstruct cdns_pcie *pcie = &ep->pcie;\n\tstruct pci_epf_msix_tbl *msix_tbl;\n\tstruct cdns_pcie_epf *epf;\n\tu64 pci_addr_mask = 0xff;\n\tu64 msg_addr;\n\tu16 flags;\n\tu8 bir;\n\n\tepf = &ep->epf[fn];\n\tif (vfn > 0)\n\t\tepf = &epf->epf[vfn - 1];\n\n\tfn = cdns_pcie_get_fn_from_vfn(pcie, fn, vfn);\n\n\t \n\tflags = cdns_pcie_ep_fn_readw(pcie, fn, cap + PCI_MSIX_FLAGS);\n\tif (!(flags & PCI_MSIX_FLAGS_ENABLE))\n\t\treturn -EINVAL;\n\n\treg = cap + PCI_MSIX_TABLE;\n\ttbl_offset = cdns_pcie_ep_fn_readl(pcie, fn, reg);\n\tbir = tbl_offset & PCI_MSIX_TABLE_BIR;\n\ttbl_offset &= PCI_MSIX_TABLE_OFFSET;\n\n\tmsix_tbl = epf->epf_bar[bir]->addr + tbl_offset;\n\tmsg_addr = msix_tbl[(interrupt_num - 1)].msg_addr;\n\tmsg_data = msix_tbl[(interrupt_num - 1)].msg_data;\n\n\t \n\tif (ep->irq_pci_addr != (msg_addr & ~pci_addr_mask) ||\n\t    ep->irq_pci_fn != fn) {\n\t\t \n\t\tcdns_pcie_set_outbound_region(pcie, 0, fn, 0,\n\t\t\t\t\t      false,\n\t\t\t\t\t      ep->irq_phys_addr,\n\t\t\t\t\t      msg_addr & ~pci_addr_mask,\n\t\t\t\t\t      pci_addr_mask + 1);\n\t\tep->irq_pci_addr = (msg_addr & ~pci_addr_mask);\n\t\tep->irq_pci_fn = fn;\n\t}\n\twritel(msg_data, ep->irq_cpu_addr + (msg_addr & pci_addr_mask));\n\n\treturn 0;\n}\n\nstatic int cdns_pcie_ep_raise_irq(struct pci_epc *epc, u8 fn, u8 vfn,\n\t\t\t\t  enum pci_epc_irq_type type,\n\t\t\t\t  u16 interrupt_num)\n{\n\tstruct cdns_pcie_ep *ep = epc_get_drvdata(epc);\n\tstruct cdns_pcie *pcie = &ep->pcie;\n\tstruct device *dev = pcie->dev;\n\n\tswitch (type) {\n\tcase PCI_EPC_IRQ_LEGACY:\n\t\tif (vfn > 0) {\n\t\t\tdev_err(dev, \"Cannot raise legacy interrupts for VF\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\treturn cdns_pcie_ep_send_legacy_irq(ep, fn, vfn, 0);\n\n\tcase PCI_EPC_IRQ_MSI:\n\t\treturn cdns_pcie_ep_send_msi_irq(ep, fn, vfn, interrupt_num);\n\n\tcase PCI_EPC_IRQ_MSIX:\n\t\treturn cdns_pcie_ep_send_msix_irq(ep, fn, vfn, interrupt_num);\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int cdns_pcie_ep_start(struct pci_epc *epc)\n{\n\tstruct cdns_pcie_ep *ep = epc_get_drvdata(epc);\n\tstruct cdns_pcie *pcie = &ep->pcie;\n\tstruct device *dev = pcie->dev;\n\tint max_epfs = sizeof(epc->function_num_map) * 8;\n\tint ret, value, epf;\n\n\t \n\tcdns_pcie_writel(pcie, CDNS_PCIE_LM_EP_FUNC_CFG, epc->function_num_map);\n\n\tif (ep->quirk_disable_flr) {\n\t\tfor (epf = 0; epf < max_epfs; epf++) {\n\t\t\tif (!(epc->function_num_map & BIT(epf)))\n\t\t\t\tcontinue;\n\n\t\t\tvalue = cdns_pcie_ep_fn_readl(pcie, epf,\n\t\t\t\t\tCDNS_PCIE_EP_FUNC_DEV_CAP_OFFSET +\n\t\t\t\t\tPCI_EXP_DEVCAP);\n\t\t\tvalue &= ~PCI_EXP_DEVCAP_FLR;\n\t\t\tcdns_pcie_ep_fn_writel(pcie, epf,\n\t\t\t\t\tCDNS_PCIE_EP_FUNC_DEV_CAP_OFFSET +\n\t\t\t\t\tPCI_EXP_DEVCAP, value);\n\t\t}\n\t}\n\n\tret = cdns_pcie_start_link(pcie);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to start link\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct pci_epc_features cdns_pcie_epc_vf_features = {\n\t.linkup_notifier = false,\n\t.msi_capable = true,\n\t.msix_capable = true,\n\t.align = 65536,\n};\n\nstatic const struct pci_epc_features cdns_pcie_epc_features = {\n\t.linkup_notifier = false,\n\t.msi_capable = true,\n\t.msix_capable = true,\n\t.align = 256,\n};\n\nstatic const struct pci_epc_features*\ncdns_pcie_ep_get_features(struct pci_epc *epc, u8 func_no, u8 vfunc_no)\n{\n\tif (!vfunc_no)\n\t\treturn &cdns_pcie_epc_features;\n\n\treturn &cdns_pcie_epc_vf_features;\n}\n\nstatic const struct pci_epc_ops cdns_pcie_epc_ops = {\n\t.write_header\t= cdns_pcie_ep_write_header,\n\t.set_bar\t= cdns_pcie_ep_set_bar,\n\t.clear_bar\t= cdns_pcie_ep_clear_bar,\n\t.map_addr\t= cdns_pcie_ep_map_addr,\n\t.unmap_addr\t= cdns_pcie_ep_unmap_addr,\n\t.set_msi\t= cdns_pcie_ep_set_msi,\n\t.get_msi\t= cdns_pcie_ep_get_msi,\n\t.set_msix\t= cdns_pcie_ep_set_msix,\n\t.get_msix\t= cdns_pcie_ep_get_msix,\n\t.raise_irq\t= cdns_pcie_ep_raise_irq,\n\t.map_msi_irq\t= cdns_pcie_ep_map_msi_irq,\n\t.start\t\t= cdns_pcie_ep_start,\n\t.get_features\t= cdns_pcie_ep_get_features,\n};\n\n\nint cdns_pcie_ep_setup(struct cdns_pcie_ep *ep)\n{\n\tstruct device *dev = ep->pcie.dev;\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct device_node *np = dev->of_node;\n\tstruct cdns_pcie *pcie = &ep->pcie;\n\tstruct cdns_pcie_epf *epf;\n\tstruct resource *res;\n\tstruct pci_epc *epc;\n\tint ret;\n\tint i;\n\n\tpcie->is_rc = false;\n\n\tpcie->reg_base = devm_platform_ioremap_resource_byname(pdev, \"reg\");\n\tif (IS_ERR(pcie->reg_base)) {\n\t\tdev_err(dev, \"missing \\\"reg\\\"\\n\");\n\t\treturn PTR_ERR(pcie->reg_base);\n\t}\n\n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"mem\");\n\tif (!res) {\n\t\tdev_err(dev, \"missing \\\"mem\\\"\\n\");\n\t\treturn -EINVAL;\n\t}\n\tpcie->mem_res = res;\n\n\tep->max_regions = CDNS_PCIE_MAX_OB;\n\tof_property_read_u32(np, \"cdns,max-outbound-regions\", &ep->max_regions);\n\n\tep->ob_addr = devm_kcalloc(dev,\n\t\t\t\t   ep->max_regions, sizeof(*ep->ob_addr),\n\t\t\t\t   GFP_KERNEL);\n\tif (!ep->ob_addr)\n\t\treturn -ENOMEM;\n\n\t \n\tcdns_pcie_writel(pcie, CDNS_PCIE_LM_EP_FUNC_CFG, BIT(0));\n\n\tepc = devm_pci_epc_create(dev, &cdns_pcie_epc_ops);\n\tif (IS_ERR(epc)) {\n\t\tdev_err(dev, \"failed to create epc device\\n\");\n\t\treturn PTR_ERR(epc);\n\t}\n\n\tepc_set_drvdata(epc, ep);\n\n\tif (of_property_read_u8(np, \"max-functions\", &epc->max_functions) < 0)\n\t\tepc->max_functions = 1;\n\n\tep->epf = devm_kcalloc(dev, epc->max_functions, sizeof(*ep->epf),\n\t\t\t       GFP_KERNEL);\n\tif (!ep->epf)\n\t\treturn -ENOMEM;\n\n\tepc->max_vfs = devm_kcalloc(dev, epc->max_functions,\n\t\t\t\t    sizeof(*epc->max_vfs), GFP_KERNEL);\n\tif (!epc->max_vfs)\n\t\treturn -ENOMEM;\n\n\tret = of_property_read_u8_array(np, \"max-virtual-functions\",\n\t\t\t\t\tepc->max_vfs, epc->max_functions);\n\tif (ret == 0) {\n\t\tfor (i = 0; i < epc->max_functions; i++) {\n\t\t\tepf = &ep->epf[i];\n\t\t\tif (epc->max_vfs[i] == 0)\n\t\t\t\tcontinue;\n\t\t\tepf->epf = devm_kcalloc(dev, epc->max_vfs[i],\n\t\t\t\t\t\tsizeof(*ep->epf), GFP_KERNEL);\n\t\t\tif (!epf->epf)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tret = pci_epc_mem_init(epc, pcie->mem_res->start,\n\t\t\t       resource_size(pcie->mem_res), PAGE_SIZE);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to initialize the memory space\\n\");\n\t\treturn ret;\n\t}\n\n\tep->irq_cpu_addr = pci_epc_mem_alloc_addr(epc, &ep->irq_phys_addr,\n\t\t\t\t\t\t  SZ_128K);\n\tif (!ep->irq_cpu_addr) {\n\t\tdev_err(dev, \"failed to reserve memory space for MSI\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto free_epc_mem;\n\t}\n\tep->irq_pci_addr = CDNS_PCIE_EP_IRQ_PCI_ADDR_NONE;\n\t \n\tset_bit(0, &ep->ob_region_map);\n\n\tif (ep->quirk_detect_quiet_flag)\n\t\tcdns_pcie_detect_quiet_min_delay_set(&ep->pcie);\n\n\tspin_lock_init(&ep->lock);\n\n\treturn 0;\n\n free_epc_mem:\n\tpci_epc_mem_exit(epc);\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}