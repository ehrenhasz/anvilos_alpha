{
  "module_name": "pcie-cadence.c",
  "hash_id": "f0b71fbc9e5168cf277528970b921a4314a245058dd1981624fc6cb278b07aa3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/controller/cadence/pcie-cadence.c",
  "human_readable_source": "\n\n\n\n\n#include <linux/kernel.h>\n#include <linux/of.h>\n\n#include \"pcie-cadence.h\"\n\nvoid cdns_pcie_detect_quiet_min_delay_set(struct cdns_pcie *pcie)\n{\n\tu32 delay = 0x3;\n\tu32 ltssm_control_cap;\n\n\t \n\tltssm_control_cap = cdns_pcie_readl(pcie, CDNS_PCIE_LTSSM_CONTROL_CAP);\n\tltssm_control_cap = ((ltssm_control_cap &\n\t\t\t    ~CDNS_PCIE_DETECT_QUIET_MIN_DELAY_MASK) |\n\t\t\t    CDNS_PCIE_DETECT_QUIET_MIN_DELAY(delay));\n\n\tcdns_pcie_writel(pcie, CDNS_PCIE_LTSSM_CONTROL_CAP, ltssm_control_cap);\n}\n\nvoid cdns_pcie_set_outbound_region(struct cdns_pcie *pcie, u8 busnr, u8 fn,\n\t\t\t\t   u32 r, bool is_io,\n\t\t\t\t   u64 cpu_addr, u64 pci_addr, size_t size)\n{\n\t \n\tu64 sz = 1ULL << fls64(size - 1);\n\tint nbits = ilog2(sz);\n\tu32 addr0, addr1, desc0, desc1;\n\n\tif (nbits < 8)\n\t\tnbits = 8;\n\n\t \n\taddr0 = CDNS_PCIE_AT_OB_REGION_PCI_ADDR0_NBITS(nbits) |\n\t\t(lower_32_bits(pci_addr) & GENMASK(31, 8));\n\taddr1 = upper_32_bits(pci_addr);\n\n\tcdns_pcie_writel(pcie, CDNS_PCIE_AT_OB_REGION_PCI_ADDR0(r), addr0);\n\tcdns_pcie_writel(pcie, CDNS_PCIE_AT_OB_REGION_PCI_ADDR1(r), addr1);\n\n\t \n\tif (is_io)\n\t\tdesc0 = CDNS_PCIE_AT_OB_REGION_DESC0_TYPE_IO;\n\telse\n\t\tdesc0 = CDNS_PCIE_AT_OB_REGION_DESC0_TYPE_MEM;\n\tdesc1 = 0;\n\n\t \n\tif (pcie->is_rc) {\n\t\t \n\t\tdesc0 |= CDNS_PCIE_AT_OB_REGION_DESC0_HARDCODED_RID |\n\t\t\t CDNS_PCIE_AT_OB_REGION_DESC0_DEVFN(0);\n\t\tdesc1 |= CDNS_PCIE_AT_OB_REGION_DESC1_BUS(busnr);\n\t} else {\n\t\t \n\t\tdesc0 |= CDNS_PCIE_AT_OB_REGION_DESC0_DEVFN(fn);\n\t}\n\n\tcdns_pcie_writel(pcie, CDNS_PCIE_AT_OB_REGION_DESC0(r), desc0);\n\tcdns_pcie_writel(pcie, CDNS_PCIE_AT_OB_REGION_DESC1(r), desc1);\n\n\t \n\tif (pcie->ops->cpu_addr_fixup)\n\t\tcpu_addr = pcie->ops->cpu_addr_fixup(pcie, cpu_addr);\n\n\taddr0 = CDNS_PCIE_AT_OB_REGION_CPU_ADDR0_NBITS(nbits) |\n\t\t(lower_32_bits(cpu_addr) & GENMASK(31, 8));\n\taddr1 = upper_32_bits(cpu_addr);\n\n\tcdns_pcie_writel(pcie, CDNS_PCIE_AT_OB_REGION_CPU_ADDR0(r), addr0);\n\tcdns_pcie_writel(pcie, CDNS_PCIE_AT_OB_REGION_CPU_ADDR1(r), addr1);\n}\n\nvoid cdns_pcie_set_outbound_region_for_normal_msg(struct cdns_pcie *pcie,\n\t\t\t\t\t\t  u8 busnr, u8 fn,\n\t\t\t\t\t\t  u32 r, u64 cpu_addr)\n{\n\tu32 addr0, addr1, desc0, desc1;\n\n\tdesc0 = CDNS_PCIE_AT_OB_REGION_DESC0_TYPE_NORMAL_MSG;\n\tdesc1 = 0;\n\n\t \n\tif (pcie->is_rc) {\n\t\tdesc0 |= CDNS_PCIE_AT_OB_REGION_DESC0_HARDCODED_RID |\n\t\t\t CDNS_PCIE_AT_OB_REGION_DESC0_DEVFN(0);\n\t\tdesc1 |= CDNS_PCIE_AT_OB_REGION_DESC1_BUS(busnr);\n\t} else {\n\t\tdesc0 |= CDNS_PCIE_AT_OB_REGION_DESC0_DEVFN(fn);\n\t}\n\n\t \n\tif (pcie->ops->cpu_addr_fixup)\n\t\tcpu_addr = pcie->ops->cpu_addr_fixup(pcie, cpu_addr);\n\n\taddr0 = CDNS_PCIE_AT_OB_REGION_CPU_ADDR0_NBITS(17) |\n\t\t(lower_32_bits(cpu_addr) & GENMASK(31, 8));\n\taddr1 = upper_32_bits(cpu_addr);\n\n\tcdns_pcie_writel(pcie, CDNS_PCIE_AT_OB_REGION_PCI_ADDR0(r), 0);\n\tcdns_pcie_writel(pcie, CDNS_PCIE_AT_OB_REGION_PCI_ADDR1(r), 0);\n\tcdns_pcie_writel(pcie, CDNS_PCIE_AT_OB_REGION_DESC0(r), desc0);\n\tcdns_pcie_writel(pcie, CDNS_PCIE_AT_OB_REGION_DESC1(r), desc1);\n\tcdns_pcie_writel(pcie, CDNS_PCIE_AT_OB_REGION_CPU_ADDR0(r), addr0);\n\tcdns_pcie_writel(pcie, CDNS_PCIE_AT_OB_REGION_CPU_ADDR1(r), addr1);\n}\n\nvoid cdns_pcie_reset_outbound_region(struct cdns_pcie *pcie, u32 r)\n{\n\tcdns_pcie_writel(pcie, CDNS_PCIE_AT_OB_REGION_PCI_ADDR0(r), 0);\n\tcdns_pcie_writel(pcie, CDNS_PCIE_AT_OB_REGION_PCI_ADDR1(r), 0);\n\n\tcdns_pcie_writel(pcie, CDNS_PCIE_AT_OB_REGION_DESC0(r), 0);\n\tcdns_pcie_writel(pcie, CDNS_PCIE_AT_OB_REGION_DESC1(r), 0);\n\n\tcdns_pcie_writel(pcie, CDNS_PCIE_AT_OB_REGION_CPU_ADDR0(r), 0);\n\tcdns_pcie_writel(pcie, CDNS_PCIE_AT_OB_REGION_CPU_ADDR1(r), 0);\n}\n\nvoid cdns_pcie_disable_phy(struct cdns_pcie *pcie)\n{\n\tint i = pcie->phy_count;\n\n\twhile (i--) {\n\t\tphy_power_off(pcie->phy[i]);\n\t\tphy_exit(pcie->phy[i]);\n\t}\n}\n\nint cdns_pcie_enable_phy(struct cdns_pcie *pcie)\n{\n\tint ret;\n\tint i;\n\n\tfor (i = 0; i < pcie->phy_count; i++) {\n\t\tret = phy_init(pcie->phy[i]);\n\t\tif (ret < 0)\n\t\t\tgoto err_phy;\n\n\t\tret = phy_power_on(pcie->phy[i]);\n\t\tif (ret < 0) {\n\t\t\tphy_exit(pcie->phy[i]);\n\t\t\tgoto err_phy;\n\t\t}\n\t}\n\n\treturn 0;\n\nerr_phy:\n\twhile (--i >= 0) {\n\t\tphy_power_off(pcie->phy[i]);\n\t\tphy_exit(pcie->phy[i]);\n\t}\n\n\treturn ret;\n}\n\nint cdns_pcie_init_phy(struct device *dev, struct cdns_pcie *pcie)\n{\n\tstruct device_node *np = dev->of_node;\n\tint phy_count;\n\tstruct phy **phy;\n\tstruct device_link **link;\n\tint i;\n\tint ret;\n\tconst char *name;\n\n\tphy_count = of_property_count_strings(np, \"phy-names\");\n\tif (phy_count < 1) {\n\t\tdev_err(dev, \"no phy-names.  PHY will not be initialized\\n\");\n\t\tpcie->phy_count = 0;\n\t\treturn 0;\n\t}\n\n\tphy = devm_kcalloc(dev, phy_count, sizeof(*phy), GFP_KERNEL);\n\tif (!phy)\n\t\treturn -ENOMEM;\n\n\tlink = devm_kcalloc(dev, phy_count, sizeof(*link), GFP_KERNEL);\n\tif (!link)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < phy_count; i++) {\n\t\tof_property_read_string_index(np, \"phy-names\", i, &name);\n\t\tphy[i] = devm_phy_get(dev, name);\n\t\tif (IS_ERR(phy[i])) {\n\t\t\tret = PTR_ERR(phy[i]);\n\t\t\tgoto err_phy;\n\t\t}\n\t\tlink[i] = device_link_add(dev, &phy[i]->dev, DL_FLAG_STATELESS);\n\t\tif (!link[i]) {\n\t\t\tdevm_phy_put(dev, phy[i]);\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_phy;\n\t\t}\n\t}\n\n\tpcie->phy_count = phy_count;\n\tpcie->phy = phy;\n\tpcie->link = link;\n\n\tret =  cdns_pcie_enable_phy(pcie);\n\tif (ret)\n\t\tgoto err_phy;\n\n\treturn 0;\n\nerr_phy:\n\twhile (--i >= 0) {\n\t\tdevice_link_del(link[i]);\n\t\tdevm_phy_put(dev, phy[i]);\n\t}\n\n\treturn ret;\n}\n\nstatic int cdns_pcie_suspend_noirq(struct device *dev)\n{\n\tstruct cdns_pcie *pcie = dev_get_drvdata(dev);\n\n\tcdns_pcie_disable_phy(pcie);\n\n\treturn 0;\n}\n\nstatic int cdns_pcie_resume_noirq(struct device *dev)\n{\n\tstruct cdns_pcie *pcie = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = cdns_pcie_enable_phy(pcie);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to enable phy\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nconst struct dev_pm_ops cdns_pcie_pm_ops = {\n\tNOIRQ_SYSTEM_SLEEP_PM_OPS(cdns_pcie_suspend_noirq,\n\t\t\t\t  cdns_pcie_resume_noirq)\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}