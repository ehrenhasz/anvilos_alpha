{
  "module_name": "pcie-cadence-host.c",
  "hash_id": "30cf3a4ce4e94c53dd935c64323b16ac2d1e873d737d9dd645dee88e3f2f6a54",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/controller/cadence/pcie-cadence-host.c",
  "human_readable_source": "\n\n\n\n\n#include <linux/delay.h>\n#include <linux/kernel.h>\n#include <linux/list_sort.h>\n#include <linux/of_address.h>\n#include <linux/of_pci.h>\n#include <linux/platform_device.h>\n\n#include \"pcie-cadence.h\"\n\n#define LINK_RETRAIN_TIMEOUT HZ\n\nstatic u64 bar_max_size[] = {\n\t[RP_BAR0] = _ULL(128 * SZ_2G),\n\t[RP_BAR1] = SZ_2G,\n\t[RP_NO_BAR] = _BITULL(63),\n};\n\nstatic u8 bar_aperture_mask[] = {\n\t[RP_BAR0] = 0x1F,\n\t[RP_BAR1] = 0xF,\n};\n\nvoid __iomem *cdns_pci_map_bus(struct pci_bus *bus, unsigned int devfn,\n\t\t\t       int where)\n{\n\tstruct pci_host_bridge *bridge = pci_find_host_bridge(bus);\n\tstruct cdns_pcie_rc *rc = pci_host_bridge_priv(bridge);\n\tstruct cdns_pcie *pcie = &rc->pcie;\n\tunsigned int busn = bus->number;\n\tu32 addr0, desc0;\n\n\tif (pci_is_root_bus(bus)) {\n\t\t \n\t\tif (devfn)\n\t\t\treturn NULL;\n\n\t\treturn pcie->reg_base + (where & 0xfff);\n\t}\n\t \n\tif (!(cdns_pcie_readl(pcie, CDNS_PCIE_LM_BASE) & 0x1))\n\t\treturn NULL;\n\t \n\tcdns_pcie_writel(pcie, CDNS_PCIE_AT_LINKDOWN, 0x0);\n\n\t \n\taddr0 = CDNS_PCIE_AT_OB_REGION_PCI_ADDR0_NBITS(12) |\n\t\tCDNS_PCIE_AT_OB_REGION_PCI_ADDR0_DEVFN(devfn) |\n\t\tCDNS_PCIE_AT_OB_REGION_PCI_ADDR0_BUS(busn);\n\tcdns_pcie_writel(pcie, CDNS_PCIE_AT_OB_REGION_PCI_ADDR0(0), addr0);\n\n\t \n\tdesc0 = CDNS_PCIE_AT_OB_REGION_DESC0_HARDCODED_RID |\n\t\tCDNS_PCIE_AT_OB_REGION_DESC0_DEVFN(0);\n\t \n\tif (busn == bridge->busnr + 1)\n\t\tdesc0 |= CDNS_PCIE_AT_OB_REGION_DESC0_TYPE_CONF_TYPE0;\n\telse\n\t\tdesc0 |= CDNS_PCIE_AT_OB_REGION_DESC0_TYPE_CONF_TYPE1;\n\tcdns_pcie_writel(pcie, CDNS_PCIE_AT_OB_REGION_DESC0(0), desc0);\n\n\treturn rc->cfg_base + (where & 0xfff);\n}\n\nstatic struct pci_ops cdns_pcie_host_ops = {\n\t.map_bus\t= cdns_pci_map_bus,\n\t.read\t\t= pci_generic_config_read,\n\t.write\t\t= pci_generic_config_write,\n};\n\nstatic int cdns_pcie_host_training_complete(struct cdns_pcie *pcie)\n{\n\tu32 pcie_cap_off = CDNS_PCIE_RP_CAP_OFFSET;\n\tunsigned long end_jiffies;\n\tu16 lnk_stat;\n\n\t \n\tend_jiffies = jiffies + LINK_RETRAIN_TIMEOUT;\n\tdo {\n\t\tlnk_stat = cdns_pcie_rp_readw(pcie, pcie_cap_off + PCI_EXP_LNKSTA);\n\t\tif (!(lnk_stat & PCI_EXP_LNKSTA_LT))\n\t\t\tbreak;\n\t\tusleep_range(0, 1000);\n\t} while (time_before(jiffies, end_jiffies));\n\n\tif (!(lnk_stat & PCI_EXP_LNKSTA_LT))\n\t\treturn 0;\n\n\treturn -ETIMEDOUT;\n}\n\nstatic int cdns_pcie_host_wait_for_link(struct cdns_pcie *pcie)\n{\n\tstruct device *dev = pcie->dev;\n\tint retries;\n\n\t \n\tfor (retries = 0; retries < LINK_WAIT_MAX_RETRIES; retries++) {\n\t\tif (cdns_pcie_link_up(pcie)) {\n\t\t\tdev_info(dev, \"Link up\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tusleep_range(LINK_WAIT_USLEEP_MIN, LINK_WAIT_USLEEP_MAX);\n\t}\n\n\treturn -ETIMEDOUT;\n}\n\nstatic int cdns_pcie_retrain(struct cdns_pcie *pcie)\n{\n\tu32 lnk_cap_sls, pcie_cap_off = CDNS_PCIE_RP_CAP_OFFSET;\n\tu16 lnk_stat, lnk_ctl;\n\tint ret = 0;\n\n\t \n\n\tlnk_cap_sls = cdns_pcie_readl(pcie, (CDNS_PCIE_RP_BASE + pcie_cap_off +\n\t\t\t\t\t     PCI_EXP_LNKCAP));\n\tif ((lnk_cap_sls & PCI_EXP_LNKCAP_SLS) <= PCI_EXP_LNKCAP_SLS_2_5GB)\n\t\treturn ret;\n\n\tlnk_stat = cdns_pcie_rp_readw(pcie, pcie_cap_off + PCI_EXP_LNKSTA);\n\tif ((lnk_stat & PCI_EXP_LNKSTA_CLS) == PCI_EXP_LNKSTA_CLS_2_5GB) {\n\t\tlnk_ctl = cdns_pcie_rp_readw(pcie,\n\t\t\t\t\t     pcie_cap_off + PCI_EXP_LNKCTL);\n\t\tlnk_ctl |= PCI_EXP_LNKCTL_RL;\n\t\tcdns_pcie_rp_writew(pcie, pcie_cap_off + PCI_EXP_LNKCTL,\n\t\t\t\t    lnk_ctl);\n\n\t\tret = cdns_pcie_host_training_complete(pcie);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = cdns_pcie_host_wait_for_link(pcie);\n\t}\n\treturn ret;\n}\n\nstatic void cdns_pcie_host_enable_ptm_response(struct cdns_pcie *pcie)\n{\n\tu32 val;\n\n\tval = cdns_pcie_readl(pcie, CDNS_PCIE_LM_PTM_CTRL);\n\tcdns_pcie_writel(pcie, CDNS_PCIE_LM_PTM_CTRL, val | CDNS_PCIE_LM_TPM_CTRL_PTMRSEN);\n}\n\nstatic int cdns_pcie_host_start_link(struct cdns_pcie_rc *rc)\n{\n\tstruct cdns_pcie *pcie = &rc->pcie;\n\tint ret;\n\n\tret = cdns_pcie_host_wait_for_link(pcie);\n\n\t \n\tif (!ret && rc->quirk_retrain_flag)\n\t\tret = cdns_pcie_retrain(pcie);\n\n\treturn ret;\n}\n\nstatic int cdns_pcie_host_init_root_port(struct cdns_pcie_rc *rc)\n{\n\tstruct cdns_pcie *pcie = &rc->pcie;\n\tu32 value, ctrl;\n\tu32 id;\n\n\t \n\tctrl = CDNS_PCIE_LM_BAR_CFG_CTRL_DISABLED;\n\tvalue = CDNS_PCIE_LM_RC_BAR_CFG_BAR0_CTRL(ctrl) |\n\t\tCDNS_PCIE_LM_RC_BAR_CFG_BAR1_CTRL(ctrl) |\n\t\tCDNS_PCIE_LM_RC_BAR_CFG_PREFETCH_MEM_ENABLE |\n\t\tCDNS_PCIE_LM_RC_BAR_CFG_PREFETCH_MEM_64BITS |\n\t\tCDNS_PCIE_LM_RC_BAR_CFG_IO_ENABLE |\n\t\tCDNS_PCIE_LM_RC_BAR_CFG_IO_32BITS;\n\tcdns_pcie_writel(pcie, CDNS_PCIE_LM_RC_BAR_CFG, value);\n\n\t \n\tif (rc->vendor_id != 0xffff) {\n\t\tid = CDNS_PCIE_LM_ID_VENDOR(rc->vendor_id) |\n\t\t\tCDNS_PCIE_LM_ID_SUBSYS(rc->vendor_id);\n\t\tcdns_pcie_writel(pcie, CDNS_PCIE_LM_ID, id);\n\t}\n\n\tif (rc->device_id != 0xffff)\n\t\tcdns_pcie_rp_writew(pcie, PCI_DEVICE_ID, rc->device_id);\n\n\tcdns_pcie_rp_writeb(pcie, PCI_CLASS_REVISION, 0);\n\tcdns_pcie_rp_writeb(pcie, PCI_CLASS_PROG, 0);\n\tcdns_pcie_rp_writew(pcie, PCI_CLASS_DEVICE, PCI_CLASS_BRIDGE_PCI);\n\n\treturn 0;\n}\n\nstatic int cdns_pcie_host_bar_ib_config(struct cdns_pcie_rc *rc,\n\t\t\t\t\tenum cdns_pcie_rp_bar bar,\n\t\t\t\t\tu64 cpu_addr, u64 size,\n\t\t\t\t\tunsigned long flags)\n{\n\tstruct cdns_pcie *pcie = &rc->pcie;\n\tu32 addr0, addr1, aperture, value;\n\n\tif (!rc->avail_ib_bar[bar])\n\t\treturn -EBUSY;\n\n\trc->avail_ib_bar[bar] = false;\n\n\taperture = ilog2(size);\n\taddr0 = CDNS_PCIE_AT_IB_RP_BAR_ADDR0_NBITS(aperture) |\n\t\t(lower_32_bits(cpu_addr) & GENMASK(31, 8));\n\taddr1 = upper_32_bits(cpu_addr);\n\tcdns_pcie_writel(pcie, CDNS_PCIE_AT_IB_RP_BAR_ADDR0(bar), addr0);\n\tcdns_pcie_writel(pcie, CDNS_PCIE_AT_IB_RP_BAR_ADDR1(bar), addr1);\n\n\tif (bar == RP_NO_BAR)\n\t\treturn 0;\n\n\tvalue = cdns_pcie_readl(pcie, CDNS_PCIE_LM_RC_BAR_CFG);\n\tvalue &= ~(LM_RC_BAR_CFG_CTRL_MEM_64BITS(bar) |\n\t\t   LM_RC_BAR_CFG_CTRL_PREF_MEM_64BITS(bar) |\n\t\t   LM_RC_BAR_CFG_CTRL_MEM_32BITS(bar) |\n\t\t   LM_RC_BAR_CFG_CTRL_PREF_MEM_32BITS(bar) |\n\t\t   LM_RC_BAR_CFG_APERTURE(bar, bar_aperture_mask[bar] + 2));\n\tif (size + cpu_addr >= SZ_4G) {\n\t\tif (!(flags & IORESOURCE_PREFETCH))\n\t\t\tvalue |= LM_RC_BAR_CFG_CTRL_MEM_64BITS(bar);\n\t\tvalue |= LM_RC_BAR_CFG_CTRL_PREF_MEM_64BITS(bar);\n\t} else {\n\t\tif (!(flags & IORESOURCE_PREFETCH))\n\t\t\tvalue |= LM_RC_BAR_CFG_CTRL_MEM_32BITS(bar);\n\t\tvalue |= LM_RC_BAR_CFG_CTRL_PREF_MEM_32BITS(bar);\n\t}\n\n\tvalue |= LM_RC_BAR_CFG_APERTURE(bar, aperture);\n\tcdns_pcie_writel(pcie, CDNS_PCIE_LM_RC_BAR_CFG, value);\n\n\treturn 0;\n}\n\nstatic enum cdns_pcie_rp_bar\ncdns_pcie_host_find_min_bar(struct cdns_pcie_rc *rc, u64 size)\n{\n\tenum cdns_pcie_rp_bar bar, sel_bar;\n\n\tsel_bar = RP_BAR_UNDEFINED;\n\tfor (bar = RP_BAR0; bar <= RP_NO_BAR; bar++) {\n\t\tif (!rc->avail_ib_bar[bar])\n\t\t\tcontinue;\n\n\t\tif (size <= bar_max_size[bar]) {\n\t\t\tif (sel_bar == RP_BAR_UNDEFINED) {\n\t\t\t\tsel_bar = bar;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (bar_max_size[bar] < bar_max_size[sel_bar])\n\t\t\t\tsel_bar = bar;\n\t\t}\n\t}\n\n\treturn sel_bar;\n}\n\nstatic enum cdns_pcie_rp_bar\ncdns_pcie_host_find_max_bar(struct cdns_pcie_rc *rc, u64 size)\n{\n\tenum cdns_pcie_rp_bar bar, sel_bar;\n\n\tsel_bar = RP_BAR_UNDEFINED;\n\tfor (bar = RP_BAR0; bar <= RP_NO_BAR; bar++) {\n\t\tif (!rc->avail_ib_bar[bar])\n\t\t\tcontinue;\n\n\t\tif (size >= bar_max_size[bar]) {\n\t\t\tif (sel_bar == RP_BAR_UNDEFINED) {\n\t\t\t\tsel_bar = bar;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (bar_max_size[bar] > bar_max_size[sel_bar])\n\t\t\t\tsel_bar = bar;\n\t\t}\n\t}\n\n\treturn sel_bar;\n}\n\nstatic int cdns_pcie_host_bar_config(struct cdns_pcie_rc *rc,\n\t\t\t\t     struct resource_entry *entry)\n{\n\tu64 cpu_addr, pci_addr, size, winsize;\n\tstruct cdns_pcie *pcie = &rc->pcie;\n\tstruct device *dev = pcie->dev;\n\tenum cdns_pcie_rp_bar bar;\n\tunsigned long flags;\n\tint ret;\n\n\tcpu_addr = entry->res->start;\n\tpci_addr = entry->res->start - entry->offset;\n\tflags = entry->res->flags;\n\tsize = resource_size(entry->res);\n\n\tif (entry->offset) {\n\t\tdev_err(dev, \"PCI addr: %llx must be equal to CPU addr: %llx\\n\",\n\t\t\tpci_addr, cpu_addr);\n\t\treturn -EINVAL;\n\t}\n\n\twhile (size > 0) {\n\t\t \n\t\tbar = cdns_pcie_host_find_min_bar(rc, size);\n\t\tif (bar != RP_BAR_UNDEFINED) {\n\t\t\tret = cdns_pcie_host_bar_ib_config(rc, bar, cpu_addr,\n\t\t\t\t\t\t\t   size, flags);\n\t\t\tif (ret)\n\t\t\t\tdev_err(dev, \"IB BAR: %d config failed\\n\", bar);\n\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tbar = cdns_pcie_host_find_max_bar(rc, size);\n\t\tif (bar == RP_BAR_UNDEFINED) {\n\t\t\tdev_err(dev, \"No free BAR to map cpu_addr %llx\\n\",\n\t\t\t\tcpu_addr);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\twinsize = bar_max_size[bar];\n\t\tret = cdns_pcie_host_bar_ib_config(rc, bar, cpu_addr, winsize,\n\t\t\t\t\t\t   flags);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"IB BAR: %d config failed\\n\", bar);\n\t\t\treturn ret;\n\t\t}\n\n\t\tsize -= winsize;\n\t\tcpu_addr += winsize;\n\t}\n\n\treturn 0;\n}\n\nstatic int cdns_pcie_host_dma_ranges_cmp(void *priv, const struct list_head *a,\n\t\t\t\t\t const struct list_head *b)\n{\n\tstruct resource_entry *entry1, *entry2;\n\n        entry1 = container_of(a, struct resource_entry, node);\n        entry2 = container_of(b, struct resource_entry, node);\n\n        return resource_size(entry2->res) - resource_size(entry1->res);\n}\n\nstatic int cdns_pcie_host_map_dma_ranges(struct cdns_pcie_rc *rc)\n{\n\tstruct cdns_pcie *pcie = &rc->pcie;\n\tstruct device *dev = pcie->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct pci_host_bridge *bridge;\n\tstruct resource_entry *entry;\n\tu32 no_bar_nbits = 32;\n\tint err;\n\n\tbridge = pci_host_bridge_from_priv(rc);\n\tif (!bridge)\n\t\treturn -ENOMEM;\n\n\tif (list_empty(&bridge->dma_ranges)) {\n\t\tof_property_read_u32(np, \"cdns,no-bar-match-nbits\",\n\t\t\t\t     &no_bar_nbits);\n\t\terr = cdns_pcie_host_bar_ib_config(rc, RP_NO_BAR, 0x0,\n\t\t\t\t\t\t   (u64)1 << no_bar_nbits, 0);\n\t\tif (err)\n\t\t\tdev_err(dev, \"IB BAR: %d config failed\\n\", RP_NO_BAR);\n\t\treturn err;\n\t}\n\n\tlist_sort(NULL, &bridge->dma_ranges, cdns_pcie_host_dma_ranges_cmp);\n\n\tresource_list_for_each_entry(entry, &bridge->dma_ranges) {\n\t\terr = cdns_pcie_host_bar_config(rc, entry);\n\t\tif (err) {\n\t\t\tdev_err(dev, \"Fail to configure IB using dma-ranges\\n\");\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int cdns_pcie_host_init_address_translation(struct cdns_pcie_rc *rc)\n{\n\tstruct cdns_pcie *pcie = &rc->pcie;\n\tstruct pci_host_bridge *bridge = pci_host_bridge_from_priv(rc);\n\tstruct resource *cfg_res = rc->cfg_res;\n\tstruct resource_entry *entry;\n\tu64 cpu_addr = cfg_res->start;\n\tu32 addr0, addr1, desc1;\n\tint r, busnr = 0;\n\n\tentry = resource_list_first_type(&bridge->windows, IORESOURCE_BUS);\n\tif (entry)\n\t\tbusnr = entry->res->start;\n\n\t \n\taddr1 = 0;  \n\tdesc1 = CDNS_PCIE_AT_OB_REGION_DESC1_BUS(busnr);\n\tcdns_pcie_writel(pcie, CDNS_PCIE_AT_OB_REGION_PCI_ADDR1(0), addr1);\n\tcdns_pcie_writel(pcie, CDNS_PCIE_AT_OB_REGION_DESC1(0), desc1);\n\n\tif (pcie->ops->cpu_addr_fixup)\n\t\tcpu_addr = pcie->ops->cpu_addr_fixup(pcie, cpu_addr);\n\n\taddr0 = CDNS_PCIE_AT_OB_REGION_CPU_ADDR0_NBITS(12) |\n\t\t(lower_32_bits(cpu_addr) & GENMASK(31, 8));\n\taddr1 = upper_32_bits(cpu_addr);\n\tcdns_pcie_writel(pcie, CDNS_PCIE_AT_OB_REGION_CPU_ADDR0(0), addr0);\n\tcdns_pcie_writel(pcie, CDNS_PCIE_AT_OB_REGION_CPU_ADDR1(0), addr1);\n\n\tr = 1;\n\tresource_list_for_each_entry(entry, &bridge->windows) {\n\t\tstruct resource *res = entry->res;\n\t\tu64 pci_addr = res->start - entry->offset;\n\n\t\tif (resource_type(res) == IORESOURCE_IO)\n\t\t\tcdns_pcie_set_outbound_region(pcie, busnr, 0, r,\n\t\t\t\t\t\t      true,\n\t\t\t\t\t\t      pci_pio_to_address(res->start),\n\t\t\t\t\t\t      pci_addr,\n\t\t\t\t\t\t      resource_size(res));\n\t\telse\n\t\t\tcdns_pcie_set_outbound_region(pcie, busnr, 0, r,\n\t\t\t\t\t\t      false,\n\t\t\t\t\t\t      res->start,\n\t\t\t\t\t\t      pci_addr,\n\t\t\t\t\t\t      resource_size(res));\n\n\t\tr++;\n\t}\n\n\treturn cdns_pcie_host_map_dma_ranges(rc);\n}\n\nstatic int cdns_pcie_host_init(struct device *dev,\n\t\t\t       struct cdns_pcie_rc *rc)\n{\n\tint err;\n\n\terr = cdns_pcie_host_init_root_port(rc);\n\tif (err)\n\t\treturn err;\n\n\treturn cdns_pcie_host_init_address_translation(rc);\n}\n\nint cdns_pcie_host_setup(struct cdns_pcie_rc *rc)\n{\n\tstruct device *dev = rc->pcie.dev;\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct device_node *np = dev->of_node;\n\tstruct pci_host_bridge *bridge;\n\tenum cdns_pcie_rp_bar bar;\n\tstruct cdns_pcie *pcie;\n\tstruct resource *res;\n\tint ret;\n\n\tbridge = pci_host_bridge_from_priv(rc);\n\tif (!bridge)\n\t\treturn -ENOMEM;\n\n\tpcie = &rc->pcie;\n\tpcie->is_rc = true;\n\n\trc->vendor_id = 0xffff;\n\tof_property_read_u32(np, \"vendor-id\", &rc->vendor_id);\n\n\trc->device_id = 0xffff;\n\tof_property_read_u32(np, \"device-id\", &rc->device_id);\n\n\tpcie->reg_base = devm_platform_ioremap_resource_byname(pdev, \"reg\");\n\tif (IS_ERR(pcie->reg_base)) {\n\t\tdev_err(dev, \"missing \\\"reg\\\"\\n\");\n\t\treturn PTR_ERR(pcie->reg_base);\n\t}\n\n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"cfg\");\n\trc->cfg_base = devm_pci_remap_cfg_resource(dev, res);\n\tif (IS_ERR(rc->cfg_base))\n\t\treturn PTR_ERR(rc->cfg_base);\n\trc->cfg_res = res;\n\n\tif (rc->quirk_detect_quiet_flag)\n\t\tcdns_pcie_detect_quiet_min_delay_set(&rc->pcie);\n\n\tcdns_pcie_host_enable_ptm_response(pcie);\n\n\tret = cdns_pcie_start_link(pcie);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to start link\\n\");\n\t\treturn ret;\n\t}\n\n\tret = cdns_pcie_host_start_link(rc);\n\tif (ret)\n\t\tdev_dbg(dev, \"PCIe link never came up\\n\");\n\n\tfor (bar = RP_BAR0; bar <= RP_NO_BAR; bar++)\n\t\trc->avail_ib_bar[bar] = true;\n\n\tret = cdns_pcie_host_init(dev, rc);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!bridge->ops)\n\t\tbridge->ops = &cdns_pcie_host_ops;\n\n\tret = pci_host_probe(bridge);\n\tif (ret < 0)\n\t\tgoto err_init;\n\n\treturn 0;\n\n err_init:\n\tpm_runtime_put_sync(dev);\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}