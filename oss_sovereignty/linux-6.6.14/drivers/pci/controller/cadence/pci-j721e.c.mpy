{
  "module_name": "pci-j721e.c",
  "hash_id": "181ab8ec9ade3b32c53740ac2fc669cbca92d52ab47284fd80b051e311ceb036",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/controller/cadence/pci-j721e.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/io.h>\n#include <linux/irqchip/chained_irq.h>\n#include <linux/irqdomain.h>\n#include <linux/mfd/syscon.h>\n#include <linux/of.h>\n#include <linux/pci.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n\n#include \"../../pci.h\"\n#include \"pcie-cadence.h\"\n\n#define ENABLE_REG_SYS_2\t0x108\n#define STATUS_REG_SYS_2\t0x508\n#define STATUS_CLR_REG_SYS_2\t0x708\n#define LINK_DOWN\t\tBIT(1)\n#define J7200_LINK_DOWN\t\tBIT(10)\n\n#define J721E_PCIE_USER_CMD_STATUS\t0x4\n#define LINK_TRAINING_ENABLE\t\tBIT(0)\n\n#define J721E_PCIE_USER_LINKSTATUS\t0x14\n#define LINK_STATUS\t\t\tGENMASK(1, 0)\n\nenum link_status {\n\tNO_RECEIVERS_DETECTED,\n\tLINK_TRAINING_IN_PROGRESS,\n\tLINK_UP_DL_IN_PROGRESS,\n\tLINK_UP_DL_COMPLETED,\n};\n\n#define J721E_MODE_RC\t\t\tBIT(7)\n#define LANE_COUNT_MASK\t\t\tBIT(8)\n#define LANE_COUNT(n)\t\t\t((n) << 8)\n\n#define GENERATION_SEL_MASK\t\tGENMASK(1, 0)\n\n#define MAX_LANES\t\t\t2\n\nstruct j721e_pcie {\n\tstruct cdns_pcie\t*cdns_pcie;\n\tstruct clk\t\t*refclk;\n\tu32\t\t\tmode;\n\tu32\t\t\tnum_lanes;\n\tvoid __iomem\t\t*user_cfg_base;\n\tvoid __iomem\t\t*intd_cfg_base;\n\tu32\t\t\tlinkdown_irq_regfield;\n};\n\nenum j721e_pcie_mode {\n\tPCI_MODE_RC,\n\tPCI_MODE_EP,\n};\n\nstruct j721e_pcie_data {\n\tenum j721e_pcie_mode\tmode;\n\tunsigned int\t\tquirk_retrain_flag:1;\n\tunsigned int\t\tquirk_detect_quiet_flag:1;\n\tunsigned int\t\tquirk_disable_flr:1;\n\tu32\t\t\tlinkdown_irq_regfield;\n\tunsigned int\t\tbyte_access_allowed:1;\n};\n\nstatic inline u32 j721e_pcie_user_readl(struct j721e_pcie *pcie, u32 offset)\n{\n\treturn readl(pcie->user_cfg_base + offset);\n}\n\nstatic inline void j721e_pcie_user_writel(struct j721e_pcie *pcie, u32 offset,\n\t\t\t\t\t  u32 value)\n{\n\twritel(value, pcie->user_cfg_base + offset);\n}\n\nstatic inline u32 j721e_pcie_intd_readl(struct j721e_pcie *pcie, u32 offset)\n{\n\treturn readl(pcie->intd_cfg_base + offset);\n}\n\nstatic inline void j721e_pcie_intd_writel(struct j721e_pcie *pcie, u32 offset,\n\t\t\t\t\t  u32 value)\n{\n\twritel(value, pcie->intd_cfg_base + offset);\n}\n\nstatic irqreturn_t j721e_pcie_link_irq_handler(int irq, void *priv)\n{\n\tstruct j721e_pcie *pcie = priv;\n\tstruct device *dev = pcie->cdns_pcie->dev;\n\tu32 reg;\n\n\treg = j721e_pcie_intd_readl(pcie, STATUS_REG_SYS_2);\n\tif (!(reg & pcie->linkdown_irq_regfield))\n\t\treturn IRQ_NONE;\n\n\tdev_err(dev, \"LINK DOWN!\\n\");\n\n\tj721e_pcie_intd_writel(pcie, STATUS_CLR_REG_SYS_2, pcie->linkdown_irq_regfield);\n\treturn IRQ_HANDLED;\n}\n\nstatic void j721e_pcie_config_link_irq(struct j721e_pcie *pcie)\n{\n\tu32 reg;\n\n\treg = j721e_pcie_intd_readl(pcie, ENABLE_REG_SYS_2);\n\treg |= pcie->linkdown_irq_regfield;\n\tj721e_pcie_intd_writel(pcie, ENABLE_REG_SYS_2, reg);\n}\n\nstatic int j721e_pcie_start_link(struct cdns_pcie *cdns_pcie)\n{\n\tstruct j721e_pcie *pcie = dev_get_drvdata(cdns_pcie->dev);\n\tu32 reg;\n\n\treg = j721e_pcie_user_readl(pcie, J721E_PCIE_USER_CMD_STATUS);\n\treg |= LINK_TRAINING_ENABLE;\n\tj721e_pcie_user_writel(pcie, J721E_PCIE_USER_CMD_STATUS, reg);\n\n\treturn 0;\n}\n\nstatic void j721e_pcie_stop_link(struct cdns_pcie *cdns_pcie)\n{\n\tstruct j721e_pcie *pcie = dev_get_drvdata(cdns_pcie->dev);\n\tu32 reg;\n\n\treg = j721e_pcie_user_readl(pcie, J721E_PCIE_USER_CMD_STATUS);\n\treg &= ~LINK_TRAINING_ENABLE;\n\tj721e_pcie_user_writel(pcie, J721E_PCIE_USER_CMD_STATUS, reg);\n}\n\nstatic bool j721e_pcie_link_up(struct cdns_pcie *cdns_pcie)\n{\n\tstruct j721e_pcie *pcie = dev_get_drvdata(cdns_pcie->dev);\n\tu32 reg;\n\n\treg = j721e_pcie_user_readl(pcie, J721E_PCIE_USER_LINKSTATUS);\n\treg &= LINK_STATUS;\n\tif (reg == LINK_UP_DL_COMPLETED)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic const struct cdns_pcie_ops j721e_pcie_ops = {\n\t.start_link = j721e_pcie_start_link,\n\t.stop_link = j721e_pcie_stop_link,\n\t.link_up = j721e_pcie_link_up,\n};\n\nstatic int j721e_pcie_set_mode(struct j721e_pcie *pcie, struct regmap *syscon,\n\t\t\t       unsigned int offset)\n{\n\tstruct device *dev = pcie->cdns_pcie->dev;\n\tu32 mask = J721E_MODE_RC;\n\tu32 mode = pcie->mode;\n\tu32 val = 0;\n\tint ret = 0;\n\n\tif (mode == PCI_MODE_RC)\n\t\tval = J721E_MODE_RC;\n\n\tret = regmap_update_bits(syscon, offset, mask, val);\n\tif (ret)\n\t\tdev_err(dev, \"failed to set pcie mode\\n\");\n\n\treturn ret;\n}\n\nstatic int j721e_pcie_set_link_speed(struct j721e_pcie *pcie,\n\t\t\t\t     struct regmap *syscon, unsigned int offset)\n{\n\tstruct device *dev = pcie->cdns_pcie->dev;\n\tstruct device_node *np = dev->of_node;\n\tint link_speed;\n\tu32 val = 0;\n\tint ret;\n\n\tlink_speed = of_pci_get_max_link_speed(np);\n\tif (link_speed < 2)\n\t\tlink_speed = 2;\n\n\tval = link_speed - 1;\n\tret = regmap_update_bits(syscon, offset, GENERATION_SEL_MASK, val);\n\tif (ret)\n\t\tdev_err(dev, \"failed to set link speed\\n\");\n\n\treturn ret;\n}\n\nstatic int j721e_pcie_set_lane_count(struct j721e_pcie *pcie,\n\t\t\t\t     struct regmap *syscon, unsigned int offset)\n{\n\tstruct device *dev = pcie->cdns_pcie->dev;\n\tu32 lanes = pcie->num_lanes;\n\tu32 val = 0;\n\tint ret;\n\n\tval = LANE_COUNT(lanes - 1);\n\tret = regmap_update_bits(syscon, offset, LANE_COUNT_MASK, val);\n\tif (ret)\n\t\tdev_err(dev, \"failed to set link count\\n\");\n\n\treturn ret;\n}\n\nstatic int j721e_pcie_ctrl_init(struct j721e_pcie *pcie)\n{\n\tstruct device *dev = pcie->cdns_pcie->dev;\n\tstruct device_node *node = dev->of_node;\n\tstruct of_phandle_args args;\n\tunsigned int offset = 0;\n\tstruct regmap *syscon;\n\tint ret;\n\n\tsyscon = syscon_regmap_lookup_by_phandle(node, \"ti,syscon-pcie-ctrl\");\n\tif (IS_ERR(syscon)) {\n\t\tdev_err(dev, \"Unable to get ti,syscon-pcie-ctrl regmap\\n\");\n\t\treturn PTR_ERR(syscon);\n\t}\n\n\t \n\tret = of_parse_phandle_with_fixed_args(node, \"ti,syscon-pcie-ctrl\", 1,\n\t\t\t\t\t       0, &args);\n\tif (!ret)\n\t\toffset = args.args[0];\n\n\tret = j721e_pcie_set_mode(pcie, syscon, offset);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to set pci mode\\n\");\n\t\treturn ret;\n\t}\n\n\tret = j721e_pcie_set_link_speed(pcie, syscon, offset);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to set link speed\\n\");\n\t\treturn ret;\n\t}\n\n\tret = j721e_pcie_set_lane_count(pcie, syscon, offset);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to set num-lanes\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int cdns_ti_pcie_config_read(struct pci_bus *bus, unsigned int devfn,\n\t\t\t\t    int where, int size, u32 *value)\n{\n\tif (pci_is_root_bus(bus))\n\t\treturn pci_generic_config_read32(bus, devfn, where, size,\n\t\t\t\t\t\t value);\n\n\treturn pci_generic_config_read(bus, devfn, where, size, value);\n}\n\nstatic int cdns_ti_pcie_config_write(struct pci_bus *bus, unsigned int devfn,\n\t\t\t\t     int where, int size, u32 value)\n{\n\tif (pci_is_root_bus(bus))\n\t\treturn pci_generic_config_write32(bus, devfn, where, size,\n\t\t\t\t\t\t  value);\n\n\treturn pci_generic_config_write(bus, devfn, where, size, value);\n}\n\nstatic struct pci_ops cdns_ti_pcie_host_ops = {\n\t.map_bus\t= cdns_pci_map_bus,\n\t.read\t\t= cdns_ti_pcie_config_read,\n\t.write\t\t= cdns_ti_pcie_config_write,\n};\n\nstatic const struct j721e_pcie_data j721e_pcie_rc_data = {\n\t.mode = PCI_MODE_RC,\n\t.quirk_retrain_flag = true,\n\t.byte_access_allowed = false,\n\t.linkdown_irq_regfield = LINK_DOWN,\n};\n\nstatic const struct j721e_pcie_data j721e_pcie_ep_data = {\n\t.mode = PCI_MODE_EP,\n\t.linkdown_irq_regfield = LINK_DOWN,\n};\n\nstatic const struct j721e_pcie_data j7200_pcie_rc_data = {\n\t.mode = PCI_MODE_RC,\n\t.quirk_detect_quiet_flag = true,\n\t.linkdown_irq_regfield = J7200_LINK_DOWN,\n\t.byte_access_allowed = true,\n};\n\nstatic const struct j721e_pcie_data j7200_pcie_ep_data = {\n\t.mode = PCI_MODE_EP,\n\t.quirk_detect_quiet_flag = true,\n\t.quirk_disable_flr = true,\n};\n\nstatic const struct j721e_pcie_data am64_pcie_rc_data = {\n\t.mode = PCI_MODE_RC,\n\t.linkdown_irq_regfield = J7200_LINK_DOWN,\n\t.byte_access_allowed = true,\n};\n\nstatic const struct j721e_pcie_data am64_pcie_ep_data = {\n\t.mode = PCI_MODE_EP,\n\t.linkdown_irq_regfield = J7200_LINK_DOWN,\n};\n\nstatic const struct of_device_id of_j721e_pcie_match[] = {\n\t{\n\t\t.compatible = \"ti,j721e-pcie-host\",\n\t\t.data = &j721e_pcie_rc_data,\n\t},\n\t{\n\t\t.compatible = \"ti,j721e-pcie-ep\",\n\t\t.data = &j721e_pcie_ep_data,\n\t},\n\t{\n\t\t.compatible = \"ti,j7200-pcie-host\",\n\t\t.data = &j7200_pcie_rc_data,\n\t},\n\t{\n\t\t.compatible = \"ti,j7200-pcie-ep\",\n\t\t.data = &j7200_pcie_ep_data,\n\t},\n\t{\n\t\t.compatible = \"ti,am64-pcie-host\",\n\t\t.data = &am64_pcie_rc_data,\n\t},\n\t{\n\t\t.compatible = \"ti,am64-pcie-ep\",\n\t\t.data = &am64_pcie_ep_data,\n\t},\n\t{},\n};\n\nstatic int j721e_pcie_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *node = dev->of_node;\n\tstruct pci_host_bridge *bridge;\n\tconst struct j721e_pcie_data *data;\n\tstruct cdns_pcie *cdns_pcie;\n\tstruct j721e_pcie *pcie;\n\tstruct cdns_pcie_rc *rc = NULL;\n\tstruct cdns_pcie_ep *ep = NULL;\n\tstruct gpio_desc *gpiod;\n\tvoid __iomem *base;\n\tstruct clk *clk;\n\tu32 num_lanes;\n\tu32 mode;\n\tint ret;\n\tint irq;\n\n\tdata = of_device_get_match_data(dev);\n\tif (!data)\n\t\treturn -EINVAL;\n\n\tmode = (u32)data->mode;\n\n\tpcie = devm_kzalloc(dev, sizeof(*pcie), GFP_KERNEL);\n\tif (!pcie)\n\t\treturn -ENOMEM;\n\n\tswitch (mode) {\n\tcase PCI_MODE_RC:\n\t\tif (!IS_ENABLED(CONFIG_PCIE_CADENCE_HOST))\n\t\t\treturn -ENODEV;\n\n\t\tbridge = devm_pci_alloc_host_bridge(dev, sizeof(*rc));\n\t\tif (!bridge)\n\t\t\treturn -ENOMEM;\n\n\t\tif (!data->byte_access_allowed)\n\t\t\tbridge->ops = &cdns_ti_pcie_host_ops;\n\t\trc = pci_host_bridge_priv(bridge);\n\t\trc->quirk_retrain_flag = data->quirk_retrain_flag;\n\t\trc->quirk_detect_quiet_flag = data->quirk_detect_quiet_flag;\n\n\t\tcdns_pcie = &rc->pcie;\n\t\tcdns_pcie->dev = dev;\n\t\tcdns_pcie->ops = &j721e_pcie_ops;\n\t\tpcie->cdns_pcie = cdns_pcie;\n\t\tbreak;\n\tcase PCI_MODE_EP:\n\t\tif (!IS_ENABLED(CONFIG_PCIE_CADENCE_EP))\n\t\t\treturn -ENODEV;\n\n\t\tep = devm_kzalloc(dev, sizeof(*ep), GFP_KERNEL);\n\t\tif (!ep)\n\t\t\treturn -ENOMEM;\n\n\t\tep->quirk_detect_quiet_flag = data->quirk_detect_quiet_flag;\n\t\tep->quirk_disable_flr = data->quirk_disable_flr;\n\n\t\tcdns_pcie = &ep->pcie;\n\t\tcdns_pcie->dev = dev;\n\t\tcdns_pcie->ops = &j721e_pcie_ops;\n\t\tpcie->cdns_pcie = cdns_pcie;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"INVALID device type %d\\n\", mode);\n\t\treturn 0;\n\t}\n\n\tpcie->mode = mode;\n\tpcie->linkdown_irq_regfield = data->linkdown_irq_regfield;\n\n\tbase = devm_platform_ioremap_resource_byname(pdev, \"intd_cfg\");\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\tpcie->intd_cfg_base = base;\n\n\tbase = devm_platform_ioremap_resource_byname(pdev, \"user_cfg\");\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\tpcie->user_cfg_base = base;\n\n\tret = of_property_read_u32(node, \"num-lanes\", &num_lanes);\n\tif (ret || num_lanes > MAX_LANES)\n\t\tnum_lanes = 1;\n\tpcie->num_lanes = num_lanes;\n\n\tif (dma_set_mask_and_coherent(dev, DMA_BIT_MASK(48)))\n\t\treturn -EINVAL;\n\n\tirq = platform_get_irq_byname(pdev, \"link_state\");\n\tif (irq < 0)\n\t\treturn irq;\n\n\tdev_set_drvdata(dev, pcie);\n\tpm_runtime_enable(dev);\n\tret = pm_runtime_get_sync(dev);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"pm_runtime_get_sync failed\\n\");\n\t\tgoto err_get_sync;\n\t}\n\n\tret = j721e_pcie_ctrl_init(pcie);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"pm_runtime_get_sync failed\\n\");\n\t\tgoto err_get_sync;\n\t}\n\n\tret = devm_request_irq(dev, irq, j721e_pcie_link_irq_handler, 0,\n\t\t\t       \"j721e-pcie-link-down-irq\", pcie);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to request link state IRQ %d\\n\", irq);\n\t\tgoto err_get_sync;\n\t}\n\n\tj721e_pcie_config_link_irq(pcie);\n\n\tswitch (mode) {\n\tcase PCI_MODE_RC:\n\t\tgpiod = devm_gpiod_get_optional(dev, \"reset\", GPIOD_OUT_LOW);\n\t\tif (IS_ERR(gpiod)) {\n\t\t\tret = PTR_ERR(gpiod);\n\t\t\tif (ret != -EPROBE_DEFER)\n\t\t\t\tdev_err(dev, \"Failed to get reset GPIO\\n\");\n\t\t\tgoto err_get_sync;\n\t\t}\n\n\t\tret = cdns_pcie_init_phy(dev, cdns_pcie);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Failed to init phy\\n\");\n\t\t\tgoto err_get_sync;\n\t\t}\n\n\t\tclk = devm_clk_get_optional(dev, \"pcie_refclk\");\n\t\tif (IS_ERR(clk)) {\n\t\t\tret = PTR_ERR(clk);\n\t\t\tdev_err(dev, \"failed to get pcie_refclk\\n\");\n\t\t\tgoto err_pcie_setup;\n\t\t}\n\n\t\tret = clk_prepare_enable(clk);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"failed to enable pcie_refclk\\n\");\n\t\t\tgoto err_pcie_setup;\n\t\t}\n\t\tpcie->refclk = clk;\n\n\t\t \n\t\tif (gpiod) {\n\t\t\tusleep_range(100, 200);\n\t\t\tgpiod_set_value_cansleep(gpiod, 1);\n\t\t}\n\n\t\tret = cdns_pcie_host_setup(rc);\n\t\tif (ret < 0) {\n\t\t\tclk_disable_unprepare(pcie->refclk);\n\t\t\tgoto err_pcie_setup;\n\t\t}\n\n\t\tbreak;\n\tcase PCI_MODE_EP:\n\t\tret = cdns_pcie_init_phy(dev, cdns_pcie);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Failed to init phy\\n\");\n\t\t\tgoto err_get_sync;\n\t\t}\n\n\t\tret = cdns_pcie_ep_setup(ep);\n\t\tif (ret < 0)\n\t\t\tgoto err_pcie_setup;\n\n\t\tbreak;\n\t}\n\n\treturn 0;\n\nerr_pcie_setup:\n\tcdns_pcie_disable_phy(cdns_pcie);\n\nerr_get_sync:\n\tpm_runtime_put(dev);\n\tpm_runtime_disable(dev);\n\n\treturn ret;\n}\n\nstatic void j721e_pcie_remove(struct platform_device *pdev)\n{\n\tstruct j721e_pcie *pcie = platform_get_drvdata(pdev);\n\tstruct cdns_pcie *cdns_pcie = pcie->cdns_pcie;\n\tstruct device *dev = &pdev->dev;\n\n\tclk_disable_unprepare(pcie->refclk);\n\tcdns_pcie_disable_phy(cdns_pcie);\n\tpm_runtime_put(dev);\n\tpm_runtime_disable(dev);\n}\n\nstatic struct platform_driver j721e_pcie_driver = {\n\t.probe  = j721e_pcie_probe,\n\t.remove_new = j721e_pcie_remove,\n\t.driver = {\n\t\t.name\t= \"j721e-pcie\",\n\t\t.of_match_table = of_j721e_pcie_match,\n\t\t.suppress_bind_attrs = true,\n\t},\n};\nbuiltin_platform_driver(j721e_pcie_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}