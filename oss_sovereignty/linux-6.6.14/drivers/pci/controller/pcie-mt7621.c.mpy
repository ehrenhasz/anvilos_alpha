{
  "module_name": "pcie-mt7621.c",
  "hash_id": "dccd07ecac9bded786f7fb9fb42475be88ca5e6d6776da2aac3baf48fe5ccfab",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/controller/pcie-mt7621.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_pci.h>\n#include <linux/of_platform.h>\n#include <linux/pci.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n#include <linux/reset.h>\n#include <linux/sys_soc.h>\n\n#include \"../pci.h\"\n\n \n#define PCIE_FTS_NUM\t\t\t0x70c\n#define PCIE_FTS_NUM_MASK\t\tGENMASK(15, 8)\n#define PCIE_FTS_NUM_L0(x)\t\t(((x) & 0xff) << 8)\n\n \n#define RALINK_PCI_PCICFG_ADDR\t\t0x0000\n#define RALINK_PCI_PCIMSK_ADDR\t\t0x000c\n#define RALINK_PCI_CONFIG_ADDR\t\t0x0020\n#define RALINK_PCI_CONFIG_DATA\t\t0x0024\n#define RALINK_PCI_MEMBASE\t\t0x0028\n#define RALINK_PCI_IOBASE\t\t0x002c\n\n \n#define RALINK_PCI_ID\t\t\t0x0030\n#define RALINK_PCI_CLASS\t\t0x0034\n#define RALINK_PCI_SUBID\t\t0x0038\n#define RALINK_PCI_STATUS\t\t0x0050\n\n \n#define PCIE_REVISION_ID\t\tBIT(0)\n#define PCIE_CLASS_CODE\t\t\t(0x60400 << 8)\n#define PCIE_BAR_MAP_MAX\t\tGENMASK(30, 16)\n#define PCIE_BAR_ENABLE\t\t\tBIT(0)\n#define PCIE_PORT_INT_EN(x)\t\tBIT(20 + (x))\n#define PCIE_PORT_LINKUP\t\tBIT(0)\n#define PCIE_PORT_CNT\t\t\t3\n\n#define INIT_PORTS_DELAY_MS\t\t100\n#define PERST_DELAY_MS\t\t\t100\n\n \nstruct mt7621_pcie_port {\n\tvoid __iomem *base;\n\tstruct list_head list;\n\tstruct mt7621_pcie *pcie;\n\tstruct clk *clk;\n\tstruct phy *phy;\n\tstruct reset_control *pcie_rst;\n\tstruct gpio_desc *gpio_rst;\n\tu32 slot;\n\tbool enabled;\n};\n\n \nstruct mt7621_pcie {\n\tstruct device *dev;\n\tvoid __iomem *base;\n\tstruct list_head ports;\n\tbool resets_inverted;\n};\n\nstatic inline u32 pcie_read(struct mt7621_pcie *pcie, u32 reg)\n{\n\treturn readl_relaxed(pcie->base + reg);\n}\n\nstatic inline void pcie_write(struct mt7621_pcie *pcie, u32 val, u32 reg)\n{\n\twritel_relaxed(val, pcie->base + reg);\n}\n\nstatic inline u32 pcie_port_read(struct mt7621_pcie_port *port, u32 reg)\n{\n\treturn readl_relaxed(port->base + reg);\n}\n\nstatic inline void pcie_port_write(struct mt7621_pcie_port *port,\n\t\t\t\t   u32 val, u32 reg)\n{\n\twritel_relaxed(val, port->base + reg);\n}\n\nstatic void __iomem *mt7621_pcie_map_bus(struct pci_bus *bus,\n\t\t\t\t\t unsigned int devfn, int where)\n{\n\tstruct mt7621_pcie *pcie = bus->sysdata;\n\tu32 address = PCI_CONF1_EXT_ADDRESS(bus->number, PCI_SLOT(devfn),\n\t\t\t\t\t    PCI_FUNC(devfn), where);\n\n\twritel_relaxed(address, pcie->base + RALINK_PCI_CONFIG_ADDR);\n\n\treturn pcie->base + RALINK_PCI_CONFIG_DATA + (where & 3);\n}\n\nstatic struct pci_ops mt7621_pcie_ops = {\n\t.map_bus\t= mt7621_pcie_map_bus,\n\t.read\t\t= pci_generic_config_read,\n\t.write\t\t= pci_generic_config_write,\n};\n\nstatic u32 read_config(struct mt7621_pcie *pcie, unsigned int dev, u32 reg)\n{\n\tu32 address = PCI_CONF1_EXT_ADDRESS(0, dev, 0, reg);\n\n\tpcie_write(pcie, address, RALINK_PCI_CONFIG_ADDR);\n\treturn pcie_read(pcie, RALINK_PCI_CONFIG_DATA);\n}\n\nstatic void write_config(struct mt7621_pcie *pcie, unsigned int dev,\n\t\t\t u32 reg, u32 val)\n{\n\tu32 address = PCI_CONF1_EXT_ADDRESS(0, dev, 0, reg);\n\n\tpcie_write(pcie, address, RALINK_PCI_CONFIG_ADDR);\n\tpcie_write(pcie, val, RALINK_PCI_CONFIG_DATA);\n}\n\nstatic inline void mt7621_rst_gpio_pcie_assert(struct mt7621_pcie_port *port)\n{\n\tif (port->gpio_rst)\n\t\tgpiod_set_value(port->gpio_rst, 1);\n}\n\nstatic inline void mt7621_rst_gpio_pcie_deassert(struct mt7621_pcie_port *port)\n{\n\tif (port->gpio_rst)\n\t\tgpiod_set_value(port->gpio_rst, 0);\n}\n\nstatic inline bool mt7621_pcie_port_is_linkup(struct mt7621_pcie_port *port)\n{\n\treturn (pcie_port_read(port, RALINK_PCI_STATUS) & PCIE_PORT_LINKUP) != 0;\n}\n\nstatic inline void mt7621_control_assert(struct mt7621_pcie_port *port)\n{\n\tstruct mt7621_pcie *pcie = port->pcie;\n\n\tif (pcie->resets_inverted)\n\t\treset_control_assert(port->pcie_rst);\n\telse\n\t\treset_control_deassert(port->pcie_rst);\n}\n\nstatic inline void mt7621_control_deassert(struct mt7621_pcie_port *port)\n{\n\tstruct mt7621_pcie *pcie = port->pcie;\n\n\tif (pcie->resets_inverted)\n\t\treset_control_deassert(port->pcie_rst);\n\telse\n\t\treset_control_assert(port->pcie_rst);\n}\n\nstatic int mt7621_pcie_parse_port(struct mt7621_pcie *pcie,\n\t\t\t\t  struct device_node *node,\n\t\t\t\t  int slot)\n{\n\tstruct mt7621_pcie_port *port;\n\tstruct device *dev = pcie->dev;\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tchar name[10];\n\tint err;\n\n\tport = devm_kzalloc(dev, sizeof(*port), GFP_KERNEL);\n\tif (!port)\n\t\treturn -ENOMEM;\n\n\tport->base = devm_platform_ioremap_resource(pdev, slot + 1);\n\tif (IS_ERR(port->base))\n\t\treturn PTR_ERR(port->base);\n\n\tport->clk = devm_get_clk_from_child(dev, node, NULL);\n\tif (IS_ERR(port->clk)) {\n\t\tdev_err(dev, \"failed to get pcie%d clock\\n\", slot);\n\t\treturn PTR_ERR(port->clk);\n\t}\n\n\tport->pcie_rst = of_reset_control_get_exclusive(node, NULL);\n\tif (PTR_ERR(port->pcie_rst) == -EPROBE_DEFER) {\n\t\tdev_err(dev, \"failed to get pcie%d reset control\\n\", slot);\n\t\treturn PTR_ERR(port->pcie_rst);\n\t}\n\n\tsnprintf(name, sizeof(name), \"pcie-phy%d\", slot);\n\tport->phy = devm_of_phy_get(dev, node, name);\n\tif (IS_ERR(port->phy)) {\n\t\tdev_err(dev, \"failed to get pcie-phy%d\\n\", slot);\n\t\terr = PTR_ERR(port->phy);\n\t\tgoto remove_reset;\n\t}\n\n\tport->gpio_rst = devm_gpiod_get_index_optional(dev, \"reset\", slot,\n\t\t\t\t\t\t       GPIOD_OUT_LOW);\n\tif (IS_ERR(port->gpio_rst)) {\n\t\tdev_err(dev, \"failed to get GPIO for PCIe%d\\n\", slot);\n\t\terr = PTR_ERR(port->gpio_rst);\n\t\tgoto remove_reset;\n\t}\n\n\tport->slot = slot;\n\tport->pcie = pcie;\n\n\tINIT_LIST_HEAD(&port->list);\n\tlist_add_tail(&port->list, &pcie->ports);\n\n\treturn 0;\n\nremove_reset:\n\treset_control_put(port->pcie_rst);\n\treturn err;\n}\n\nstatic int mt7621_pcie_parse_dt(struct mt7621_pcie *pcie)\n{\n\tstruct device *dev = pcie->dev;\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct device_node *node = dev->of_node, *child;\n\tint err;\n\n\tpcie->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(pcie->base))\n\t\treturn PTR_ERR(pcie->base);\n\n\tfor_each_available_child_of_node(node, child) {\n\t\tint slot;\n\n\t\terr = of_pci_get_devfn(child);\n\t\tif (err < 0) {\n\t\t\tof_node_put(child);\n\t\t\tdev_err(dev, \"failed to parse devfn: %d\\n\", err);\n\t\t\treturn err;\n\t\t}\n\n\t\tslot = PCI_SLOT(err);\n\n\t\terr = mt7621_pcie_parse_port(pcie, child, slot);\n\t\tif (err) {\n\t\t\tof_node_put(child);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int mt7621_pcie_init_port(struct mt7621_pcie_port *port)\n{\n\tstruct mt7621_pcie *pcie = port->pcie;\n\tstruct device *dev = pcie->dev;\n\tu32 slot = port->slot;\n\tint err;\n\n\terr = phy_init(port->phy);\n\tif (err) {\n\t\tdev_err(dev, \"failed to initialize port%d phy\\n\", slot);\n\t\treturn err;\n\t}\n\n\terr = phy_power_on(port->phy);\n\tif (err) {\n\t\tdev_err(dev, \"failed to power on port%d phy\\n\", slot);\n\t\tphy_exit(port->phy);\n\t\treturn err;\n\t}\n\n\tport->enabled = true;\n\n\treturn 0;\n}\n\nstatic void mt7621_pcie_reset_assert(struct mt7621_pcie *pcie)\n{\n\tstruct mt7621_pcie_port *port;\n\n\tlist_for_each_entry(port, &pcie->ports, list) {\n\t\t \n\t\tmt7621_control_assert(port);\n\n\t\t \n\t\tmt7621_rst_gpio_pcie_assert(port);\n\t}\n\n\tmsleep(PERST_DELAY_MS);\n}\n\nstatic void mt7621_pcie_reset_rc_deassert(struct mt7621_pcie *pcie)\n{\n\tstruct mt7621_pcie_port *port;\n\n\tlist_for_each_entry(port, &pcie->ports, list)\n\t\tmt7621_control_deassert(port);\n}\n\nstatic void mt7621_pcie_reset_ep_deassert(struct mt7621_pcie *pcie)\n{\n\tstruct mt7621_pcie_port *port;\n\n\tlist_for_each_entry(port, &pcie->ports, list)\n\t\tmt7621_rst_gpio_pcie_deassert(port);\n\n\tmsleep(PERST_DELAY_MS);\n}\n\nstatic int mt7621_pcie_init_ports(struct mt7621_pcie *pcie)\n{\n\tstruct device *dev = pcie->dev;\n\tstruct mt7621_pcie_port *port, *tmp;\n\tu8 num_disabled = 0;\n\tint err;\n\n\tmt7621_pcie_reset_assert(pcie);\n\tmt7621_pcie_reset_rc_deassert(pcie);\n\n\tlist_for_each_entry_safe(port, tmp, &pcie->ports, list) {\n\t\tu32 slot = port->slot;\n\n\t\tif (slot == 1) {\n\t\t\tport->enabled = true;\n\t\t\tcontinue;\n\t\t}\n\n\t\terr = mt7621_pcie_init_port(port);\n\t\tif (err) {\n\t\t\tdev_err(dev, \"initializing port %d failed\\n\", slot);\n\t\t\tlist_del(&port->list);\n\t\t}\n\t}\n\n\tmsleep(INIT_PORTS_DELAY_MS);\n\tmt7621_pcie_reset_ep_deassert(pcie);\n\n\ttmp = NULL;\n\tlist_for_each_entry(port, &pcie->ports, list) {\n\t\tu32 slot = port->slot;\n\n\t\tif (!mt7621_pcie_port_is_linkup(port)) {\n\t\t\tdev_info(dev, \"pcie%d no card, disable it (RST & CLK)\\n\",\n\t\t\t\t slot);\n\t\t\tmt7621_control_assert(port);\n\t\t\tport->enabled = false;\n\t\t\tnum_disabled++;\n\n\t\t\tif (slot == 0) {\n\t\t\t\ttmp = port;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (slot == 1 && tmp && !tmp->enabled)\n\t\t\t\tphy_power_off(tmp->phy);\n\t\t}\n\t}\n\n\treturn (num_disabled != PCIE_PORT_CNT) ? 0 : -ENODEV;\n}\n\nstatic void mt7621_pcie_enable_port(struct mt7621_pcie_port *port)\n{\n\tstruct mt7621_pcie *pcie = port->pcie;\n\tu32 slot = port->slot;\n\tu32 val;\n\n\t \n\tval = pcie_read(pcie, RALINK_PCI_PCIMSK_ADDR);\n\tval |= PCIE_PORT_INT_EN(slot);\n\tpcie_write(pcie, val, RALINK_PCI_PCIMSK_ADDR);\n\n\t \n\tpcie_port_write(port, PCIE_BAR_MAP_MAX | PCIE_BAR_ENABLE,\n\t\t\tPCI_BASE_ADDRESS_0);\n\n\t \n\tpcie_port_write(port, PCIE_CLASS_CODE | PCIE_REVISION_ID,\n\t\t\tRALINK_PCI_CLASS);\n\n\t \n\tval = read_config(pcie, slot, PCIE_FTS_NUM);\n\tval &= ~PCIE_FTS_NUM_MASK;\n\tval |= PCIE_FTS_NUM_L0(0x50);\n\twrite_config(pcie, slot, PCIE_FTS_NUM, val);\n}\n\nstatic int mt7621_pcie_enable_ports(struct pci_host_bridge *host)\n{\n\tstruct mt7621_pcie *pcie = pci_host_bridge_priv(host);\n\tstruct device *dev = pcie->dev;\n\tstruct mt7621_pcie_port *port;\n\tstruct resource_entry *entry;\n\tint err;\n\n\tentry = resource_list_first_type(&host->windows, IORESOURCE_IO);\n\tif (!entry) {\n\t\tdev_err(dev, \"cannot get io resource\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tpcie_write(pcie, 0xffffffff, RALINK_PCI_MEMBASE);\n\tpcie_write(pcie, entry->res->start - entry->offset, RALINK_PCI_IOBASE);\n\n\tlist_for_each_entry(port, &pcie->ports, list) {\n\t\tif (port->enabled) {\n\t\t\terr = clk_prepare_enable(port->clk);\n\t\t\tif (err) {\n\t\t\t\tdev_err(dev, \"enabling clk pcie%d\\n\",\n\t\t\t\t\tport->slot);\n\t\t\t\treturn err;\n\t\t\t}\n\n\t\t\tmt7621_pcie_enable_port(port);\n\t\t\tdev_info(dev, \"PCIE%d enabled\\n\", port->slot);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int mt7621_pcie_register_host(struct pci_host_bridge *host)\n{\n\tstruct mt7621_pcie *pcie = pci_host_bridge_priv(host);\n\n\thost->ops = &mt7621_pcie_ops;\n\thost->sysdata = pcie;\n\treturn pci_host_probe(host);\n}\n\nstatic const struct soc_device_attribute mt7621_pcie_quirks_match[] = {\n\t{ .soc_id = \"mt7621\", .revision = \"E2\" },\n\t{   }\n};\n\nstatic int mt7621_pcie_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tconst struct soc_device_attribute *attr;\n\tstruct mt7621_pcie_port *port;\n\tstruct mt7621_pcie *pcie;\n\tstruct pci_host_bridge *bridge;\n\tint err;\n\n\tif (!dev->of_node)\n\t\treturn -ENODEV;\n\n\tbridge = devm_pci_alloc_host_bridge(dev, sizeof(*pcie));\n\tif (!bridge)\n\t\treturn -ENOMEM;\n\n\tpcie = pci_host_bridge_priv(bridge);\n\tpcie->dev = dev;\n\tplatform_set_drvdata(pdev, pcie);\n\tINIT_LIST_HEAD(&pcie->ports);\n\n\tattr = soc_device_match(mt7621_pcie_quirks_match);\n\tif (attr)\n\t\tpcie->resets_inverted = true;\n\n\terr = mt7621_pcie_parse_dt(pcie);\n\tif (err) {\n\t\tdev_err(dev, \"parsing DT failed\\n\");\n\t\treturn err;\n\t}\n\n\terr = mt7621_pcie_init_ports(pcie);\n\tif (err) {\n\t\tdev_err(dev, \"nothing connected in virtual bridges\\n\");\n\t\treturn 0;\n\t}\n\n\terr = mt7621_pcie_enable_ports(bridge);\n\tif (err) {\n\t\tdev_err(dev, \"error enabling pcie ports\\n\");\n\t\tgoto remove_resets;\n\t}\n\n\treturn mt7621_pcie_register_host(bridge);\n\nremove_resets:\n\tlist_for_each_entry(port, &pcie->ports, list)\n\t\treset_control_put(port->pcie_rst);\n\n\treturn err;\n}\n\nstatic void mt7621_pcie_remove(struct platform_device *pdev)\n{\n\tstruct mt7621_pcie *pcie = platform_get_drvdata(pdev);\n\tstruct mt7621_pcie_port *port;\n\n\tlist_for_each_entry(port, &pcie->ports, list)\n\t\treset_control_put(port->pcie_rst);\n}\n\nstatic const struct of_device_id mt7621_pcie_ids[] = {\n\t{ .compatible = \"mediatek,mt7621-pci\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, mt7621_pcie_ids);\n\nstatic struct platform_driver mt7621_pcie_driver = {\n\t.probe = mt7621_pcie_probe,\n\t.remove_new = mt7621_pcie_remove,\n\t.driver = {\n\t\t.name = \"mt7621-pci\",\n\t\t.of_match_table = mt7621_pcie_ids,\n\t},\n};\nbuiltin_platform_driver(mt7621_pcie_driver);\n\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}