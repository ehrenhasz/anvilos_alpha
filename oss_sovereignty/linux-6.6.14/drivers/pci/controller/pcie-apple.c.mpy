{
  "module_name": "pcie-apple.c",
  "hash_id": "3f3559f7268d1a8ced1dcd868ca8ee8b34ccaa7fe3610b10620158fba5ad0efb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/controller/pcie-apple.c",
  "human_readable_source": "\n \n\n#include <linux/gpio/consumer.h>\n#include <linux/kernel.h>\n#include <linux/iopoll.h>\n#include <linux/irqchip/chained_irq.h>\n#include <linux/irqdomain.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/notifier.h>\n#include <linux/of_irq.h>\n#include <linux/pci-ecam.h>\n\n#define CORE_RC_PHYIF_CTL\t\t0x00024\n#define   CORE_RC_PHYIF_CTL_RUN\t\tBIT(0)\n#define CORE_RC_PHYIF_STAT\t\t0x00028\n#define   CORE_RC_PHYIF_STAT_REFCLK\tBIT(4)\n#define CORE_RC_CTL\t\t\t0x00050\n#define   CORE_RC_CTL_RUN\t\tBIT(0)\n#define CORE_RC_STAT\t\t\t0x00058\n#define   CORE_RC_STAT_READY\t\tBIT(0)\n#define CORE_FABRIC_STAT\t\t0x04000\n#define   CORE_FABRIC_STAT_MASK\t\t0x001F001F\n#define CORE_LANE_CFG(port)\t\t(0x84000 + 0x4000 * (port))\n#define   CORE_LANE_CFG_REFCLK0REQ\tBIT(0)\n#define   CORE_LANE_CFG_REFCLK1REQ\tBIT(1)\n#define   CORE_LANE_CFG_REFCLK0ACK\tBIT(2)\n#define   CORE_LANE_CFG_REFCLK1ACK\tBIT(3)\n#define   CORE_LANE_CFG_REFCLKEN\t(BIT(9) | BIT(10))\n#define CORE_LANE_CTL(port)\t\t(0x84004 + 0x4000 * (port))\n#define   CORE_LANE_CTL_CFGACC\t\tBIT(15)\n\n#define PORT_LTSSMCTL\t\t\t0x00080\n#define   PORT_LTSSMCTL_START\t\tBIT(0)\n#define PORT_INTSTAT\t\t\t0x00100\n#define   PORT_INT_TUNNEL_ERR\t\t31\n#define   PORT_INT_CPL_TIMEOUT\t\t23\n#define   PORT_INT_RID2SID_MAPERR\t22\n#define   PORT_INT_CPL_ABORT\t\t21\n#define   PORT_INT_MSI_BAD_DATA\t\t19\n#define   PORT_INT_MSI_ERR\t\t18\n#define   PORT_INT_REQADDR_GT32\t\t17\n#define   PORT_INT_AF_TIMEOUT\t\t15\n#define   PORT_INT_LINK_DOWN\t\t14\n#define   PORT_INT_LINK_UP\t\t12\n#define   PORT_INT_LINK_BWMGMT\t\t11\n#define   PORT_INT_AER_MASK\t\t(15 << 4)\n#define   PORT_INT_PORT_ERR\t\t4\n#define   PORT_INT_INTx(i)\t\ti\n#define   PORT_INT_INTx_MASK\t\t15\n#define PORT_INTMSK\t\t\t0x00104\n#define PORT_INTMSKSET\t\t\t0x00108\n#define PORT_INTMSKCLR\t\t\t0x0010c\n#define PORT_MSICFG\t\t\t0x00124\n#define   PORT_MSICFG_EN\t\tBIT(0)\n#define   PORT_MSICFG_L2MSINUM_SHIFT\t4\n#define PORT_MSIBASE\t\t\t0x00128\n#define   PORT_MSIBASE_1_SHIFT\t\t16\n#define PORT_MSIADDR\t\t\t0x00168\n#define PORT_LINKSTS\t\t\t0x00208\n#define   PORT_LINKSTS_UP\t\tBIT(0)\n#define   PORT_LINKSTS_BUSY\t\tBIT(2)\n#define PORT_LINKCMDSTS\t\t\t0x00210\n#define PORT_OUTS_NPREQS\t\t0x00284\n#define   PORT_OUTS_NPREQS_REQ\t\tBIT(24)\n#define   PORT_OUTS_NPREQS_CPL\t\tBIT(16)\n#define PORT_RXWR_FIFO\t\t\t0x00288\n#define   PORT_RXWR_FIFO_HDR\t\tGENMASK(15, 10)\n#define   PORT_RXWR_FIFO_DATA\t\tGENMASK(9, 0)\n#define PORT_RXRD_FIFO\t\t\t0x0028C\n#define   PORT_RXRD_FIFO_REQ\t\tGENMASK(6, 0)\n#define PORT_OUTS_CPLS\t\t\t0x00290\n#define   PORT_OUTS_CPLS_SHRD\t\tGENMASK(14, 8)\n#define   PORT_OUTS_CPLS_WAIT\t\tGENMASK(6, 0)\n#define PORT_APPCLK\t\t\t0x00800\n#define   PORT_APPCLK_EN\t\tBIT(0)\n#define   PORT_APPCLK_CGDIS\t\tBIT(8)\n#define PORT_STATUS\t\t\t0x00804\n#define   PORT_STATUS_READY\t\tBIT(0)\n#define PORT_REFCLK\t\t\t0x00810\n#define   PORT_REFCLK_EN\t\tBIT(0)\n#define   PORT_REFCLK_CGDIS\t\tBIT(8)\n#define PORT_PERST\t\t\t0x00814\n#define   PORT_PERST_OFF\t\tBIT(0)\n#define PORT_RID2SID(i16)\t\t(0x00828 + 4 * (i16))\n#define   PORT_RID2SID_VALID\t\tBIT(31)\n#define   PORT_RID2SID_SID_SHIFT\t16\n#define   PORT_RID2SID_BUS_SHIFT\t8\n#define   PORT_RID2SID_DEV_SHIFT\t3\n#define   PORT_RID2SID_FUNC_SHIFT\t0\n#define PORT_OUTS_PREQS_HDR\t\t0x00980\n#define   PORT_OUTS_PREQS_HDR_MASK\tGENMASK(9, 0)\n#define PORT_OUTS_PREQS_DATA\t\t0x00984\n#define   PORT_OUTS_PREQS_DATA_MASK\tGENMASK(15, 0)\n#define PORT_TUNCTRL\t\t\t0x00988\n#define   PORT_TUNCTRL_PERST_ON\t\tBIT(0)\n#define   PORT_TUNCTRL_PERST_ACK_REQ\tBIT(1)\n#define PORT_TUNSTAT\t\t\t0x0098c\n#define   PORT_TUNSTAT_PERST_ON\t\tBIT(0)\n#define   PORT_TUNSTAT_PERST_ACK_PEND\tBIT(1)\n#define PORT_PREFMEM_ENABLE\t\t0x00994\n\n#define MAX_RID2SID\t\t\t64\n\n \n#define DOORBELL_ADDR\t\tCONFIG_PCIE_APPLE_MSI_DOORBELL_ADDR\n\nstruct apple_pcie {\n\tstruct mutex\t\tlock;\n\tstruct device\t\t*dev;\n\tvoid __iomem            *base;\n\tstruct irq_domain\t*domain;\n\tunsigned long\t\t*bitmap;\n\tstruct list_head\tports;\n\tstruct completion\tevent;\n\tstruct irq_fwspec\tfwspec;\n\tu32\t\t\tnvecs;\n};\n\nstruct apple_pcie_port {\n\tstruct apple_pcie\t*pcie;\n\tstruct device_node\t*np;\n\tvoid __iomem\t\t*base;\n\tstruct irq_domain\t*domain;\n\tstruct list_head\tentry;\n\tDECLARE_BITMAP(sid_map, MAX_RID2SID);\n\tint\t\t\tsid_map_sz;\n\tint\t\t\tidx;\n};\n\nstatic void rmw_set(u32 set, void __iomem *addr)\n{\n\twritel_relaxed(readl_relaxed(addr) | set, addr);\n}\n\nstatic void rmw_clear(u32 clr, void __iomem *addr)\n{\n\twritel_relaxed(readl_relaxed(addr) & ~clr, addr);\n}\n\nstatic void apple_msi_top_irq_mask(struct irq_data *d)\n{\n\tpci_msi_mask_irq(d);\n\tirq_chip_mask_parent(d);\n}\n\nstatic void apple_msi_top_irq_unmask(struct irq_data *d)\n{\n\tpci_msi_unmask_irq(d);\n\tirq_chip_unmask_parent(d);\n}\n\nstatic struct irq_chip apple_msi_top_chip = {\n\t.name\t\t\t= \"PCIe MSI\",\n\t.irq_mask\t\t= apple_msi_top_irq_mask,\n\t.irq_unmask\t\t= apple_msi_top_irq_unmask,\n\t.irq_eoi\t\t= irq_chip_eoi_parent,\n\t.irq_set_affinity\t= irq_chip_set_affinity_parent,\n\t.irq_set_type\t\t= irq_chip_set_type_parent,\n};\n\nstatic void apple_msi_compose_msg(struct irq_data *data, struct msi_msg *msg)\n{\n\tmsg->address_hi = upper_32_bits(DOORBELL_ADDR);\n\tmsg->address_lo = lower_32_bits(DOORBELL_ADDR);\n\tmsg->data = data->hwirq;\n}\n\nstatic struct irq_chip apple_msi_bottom_chip = {\n\t.name\t\t\t= \"MSI\",\n\t.irq_mask\t\t= irq_chip_mask_parent,\n\t.irq_unmask\t\t= irq_chip_unmask_parent,\n\t.irq_eoi\t\t= irq_chip_eoi_parent,\n\t.irq_set_affinity\t= irq_chip_set_affinity_parent,\n\t.irq_set_type\t\t= irq_chip_set_type_parent,\n\t.irq_compose_msi_msg\t= apple_msi_compose_msg,\n};\n\nstatic int apple_msi_domain_alloc(struct irq_domain *domain, unsigned int virq,\n\t\t\t\t  unsigned int nr_irqs, void *args)\n{\n\tstruct apple_pcie *pcie = domain->host_data;\n\tstruct irq_fwspec fwspec = pcie->fwspec;\n\tunsigned int i;\n\tint ret, hwirq;\n\n\tmutex_lock(&pcie->lock);\n\n\thwirq = bitmap_find_free_region(pcie->bitmap, pcie->nvecs,\n\t\t\t\t\torder_base_2(nr_irqs));\n\n\tmutex_unlock(&pcie->lock);\n\n\tif (hwirq < 0)\n\t\treturn -ENOSPC;\n\n\tfwspec.param[fwspec.param_count - 2] += hwirq;\n\n\tret = irq_domain_alloc_irqs_parent(domain, virq, nr_irqs, &fwspec);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < nr_irqs; i++) {\n\t\tirq_domain_set_hwirq_and_chip(domain, virq + i, hwirq + i,\n\t\t\t\t\t      &apple_msi_bottom_chip,\n\t\t\t\t\t      domain->host_data);\n\t}\n\n\treturn 0;\n}\n\nstatic void apple_msi_domain_free(struct irq_domain *domain, unsigned int virq,\n\t\t\t\t  unsigned int nr_irqs)\n{\n\tstruct irq_data *d = irq_domain_get_irq_data(domain, virq);\n\tstruct apple_pcie *pcie = domain->host_data;\n\n\tmutex_lock(&pcie->lock);\n\n\tbitmap_release_region(pcie->bitmap, d->hwirq, order_base_2(nr_irqs));\n\n\tmutex_unlock(&pcie->lock);\n}\n\nstatic const struct irq_domain_ops apple_msi_domain_ops = {\n\t.alloc\t= apple_msi_domain_alloc,\n\t.free\t= apple_msi_domain_free,\n};\n\nstatic struct msi_domain_info apple_msi_info = {\n\t.flags\t= (MSI_FLAG_USE_DEF_DOM_OPS | MSI_FLAG_USE_DEF_CHIP_OPS |\n\t\t   MSI_FLAG_MULTI_PCI_MSI | MSI_FLAG_PCI_MSIX),\n\t.chip\t= &apple_msi_top_chip,\n};\n\nstatic void apple_port_irq_mask(struct irq_data *data)\n{\n\tstruct apple_pcie_port *port = irq_data_get_irq_chip_data(data);\n\n\twritel_relaxed(BIT(data->hwirq), port->base + PORT_INTMSKSET);\n}\n\nstatic void apple_port_irq_unmask(struct irq_data *data)\n{\n\tstruct apple_pcie_port *port = irq_data_get_irq_chip_data(data);\n\n\twritel_relaxed(BIT(data->hwirq), port->base + PORT_INTMSKCLR);\n}\n\nstatic bool hwirq_is_intx(unsigned int hwirq)\n{\n\treturn BIT(hwirq) & PORT_INT_INTx_MASK;\n}\n\nstatic void apple_port_irq_ack(struct irq_data *data)\n{\n\tstruct apple_pcie_port *port = irq_data_get_irq_chip_data(data);\n\n\tif (!hwirq_is_intx(data->hwirq))\n\t\twritel_relaxed(BIT(data->hwirq), port->base + PORT_INTSTAT);\n}\n\nstatic int apple_port_irq_set_type(struct irq_data *data, unsigned int type)\n{\n\t \n\tif (hwirq_is_intx(data->hwirq) ^ !!(type & IRQ_TYPE_LEVEL_MASK))\n\t\treturn -EINVAL;\n\n\tirqd_set_trigger_type(data, type);\n\treturn 0;\n}\n\nstatic struct irq_chip apple_port_irqchip = {\n\t.name\t\t= \"PCIe\",\n\t.irq_ack\t= apple_port_irq_ack,\n\t.irq_mask\t= apple_port_irq_mask,\n\t.irq_unmask\t= apple_port_irq_unmask,\n\t.irq_set_type\t= apple_port_irq_set_type,\n};\n\nstatic int apple_port_irq_domain_alloc(struct irq_domain *domain,\n\t\t\t\t       unsigned int virq, unsigned int nr_irqs,\n\t\t\t\t       void *args)\n{\n\tstruct apple_pcie_port *port = domain->host_data;\n\tstruct irq_fwspec *fwspec = args;\n\tint i;\n\n\tfor (i = 0; i < nr_irqs; i++) {\n\t\tirq_flow_handler_t flow = handle_edge_irq;\n\t\tunsigned int type = IRQ_TYPE_EDGE_RISING;\n\n\t\tif (hwirq_is_intx(fwspec->param[0] + i)) {\n\t\t\tflow = handle_level_irq;\n\t\t\ttype = IRQ_TYPE_LEVEL_HIGH;\n\t\t}\n\n\t\tirq_domain_set_info(domain, virq + i, fwspec->param[0] + i,\n\t\t\t\t    &apple_port_irqchip, port, flow,\n\t\t\t\t    NULL, NULL);\n\n\t\tirq_set_irq_type(virq + i, type);\n\t}\n\n\treturn 0;\n}\n\nstatic void apple_port_irq_domain_free(struct irq_domain *domain,\n\t\t\t\t       unsigned int virq, unsigned int nr_irqs)\n{\n\tint i;\n\n\tfor (i = 0; i < nr_irqs; i++) {\n\t\tstruct irq_data *d = irq_domain_get_irq_data(domain, virq + i);\n\n\t\tirq_set_handler(virq + i, NULL);\n\t\tirq_domain_reset_irq_data(d);\n\t}\n}\n\nstatic const struct irq_domain_ops apple_port_irq_domain_ops = {\n\t.translate\t= irq_domain_translate_onecell,\n\t.alloc\t\t= apple_port_irq_domain_alloc,\n\t.free\t\t= apple_port_irq_domain_free,\n};\n\nstatic void apple_port_irq_handler(struct irq_desc *desc)\n{\n\tstruct apple_pcie_port *port = irq_desc_get_handler_data(desc);\n\tstruct irq_chip *chip = irq_desc_get_chip(desc);\n\tunsigned long stat;\n\tint i;\n\n\tchained_irq_enter(chip, desc);\n\n\tstat = readl_relaxed(port->base + PORT_INTSTAT);\n\n\tfor_each_set_bit(i, &stat, 32)\n\t\tgeneric_handle_domain_irq(port->domain, i);\n\n\tchained_irq_exit(chip, desc);\n}\n\nstatic int apple_pcie_port_setup_irq(struct apple_pcie_port *port)\n{\n\tstruct fwnode_handle *fwnode = &port->np->fwnode;\n\tunsigned int irq;\n\n\t \n\tirq = irq_of_parse_and_map(to_of_node(dev_fwnode(port->pcie->dev)),\n\t\t\t\t   port->idx);\n\tif (!irq)\n\t\treturn -ENXIO;\n\n\tport->domain = irq_domain_create_linear(fwnode, 32,\n\t\t\t\t\t\t&apple_port_irq_domain_ops,\n\t\t\t\t\t\tport);\n\tif (!port->domain)\n\t\treturn -ENOMEM;\n\n\t \n\twritel_relaxed(~0, port->base + PORT_INTMSKSET);\n\twritel_relaxed(~0, port->base + PORT_INTSTAT);\n\n\tirq_set_chained_handler_and_data(irq, apple_port_irq_handler, port);\n\n\t \n\tBUILD_BUG_ON(upper_32_bits(DOORBELL_ADDR));\n\twritel_relaxed(lower_32_bits(DOORBELL_ADDR), port->base + PORT_MSIADDR);\n\n\t \n\twritel_relaxed(0, port->base + PORT_MSIBASE);\n\twritel_relaxed((ilog2(port->pcie->nvecs) << PORT_MSICFG_L2MSINUM_SHIFT) |\n\t\t       PORT_MSICFG_EN, port->base + PORT_MSICFG);\n\n\treturn 0;\n}\n\nstatic irqreturn_t apple_pcie_port_irq(int irq, void *data)\n{\n\tstruct apple_pcie_port *port = data;\n\tunsigned int hwirq = irq_domain_get_irq_data(port->domain, irq)->hwirq;\n\n\tswitch (hwirq) {\n\tcase PORT_INT_LINK_UP:\n\t\tdev_info_ratelimited(port->pcie->dev, \"Link up on %pOF\\n\",\n\t\t\t\t     port->np);\n\t\tcomplete_all(&port->pcie->event);\n\t\tbreak;\n\tcase PORT_INT_LINK_DOWN:\n\t\tdev_info_ratelimited(port->pcie->dev, \"Link down on %pOF\\n\",\n\t\t\t\t     port->np);\n\t\tbreak;\n\tdefault:\n\t\treturn IRQ_NONE;\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int apple_pcie_port_register_irqs(struct apple_pcie_port *port)\n{\n\tstatic struct {\n\t\tunsigned int\thwirq;\n\t\tconst char\t*name;\n\t} port_irqs[] = {\n\t\t{ PORT_INT_LINK_UP,\t\"Link up\",\t},\n\t\t{ PORT_INT_LINK_DOWN,\t\"Link down\",\t},\n\t};\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(port_irqs); i++) {\n\t\tstruct irq_fwspec fwspec = {\n\t\t\t.fwnode\t\t= &port->np->fwnode,\n\t\t\t.param_count\t= 1,\n\t\t\t.param\t\t= {\n\t\t\t\t[0]\t= port_irqs[i].hwirq,\n\t\t\t},\n\t\t};\n\t\tunsigned int irq;\n\t\tint ret;\n\n\t\tirq = irq_domain_alloc_irqs(port->domain, 1, NUMA_NO_NODE,\n\t\t\t\t\t    &fwspec);\n\t\tif (WARN_ON(!irq))\n\t\t\tcontinue;\n\n\t\tret = request_irq(irq, apple_pcie_port_irq, 0,\n\t\t\t\t  port_irqs[i].name, port);\n\t\tWARN_ON(ret);\n\t}\n\n\treturn 0;\n}\n\nstatic int apple_pcie_setup_refclk(struct apple_pcie *pcie,\n\t\t\t\t   struct apple_pcie_port *port)\n{\n\tu32 stat;\n\tint res;\n\n\tres = readl_relaxed_poll_timeout(pcie->base + CORE_RC_PHYIF_STAT, stat,\n\t\t\t\t\t stat & CORE_RC_PHYIF_STAT_REFCLK,\n\t\t\t\t\t 100, 50000);\n\tif (res < 0)\n\t\treturn res;\n\n\trmw_set(CORE_LANE_CTL_CFGACC, pcie->base + CORE_LANE_CTL(port->idx));\n\trmw_set(CORE_LANE_CFG_REFCLK0REQ, pcie->base + CORE_LANE_CFG(port->idx));\n\n\tres = readl_relaxed_poll_timeout(pcie->base + CORE_LANE_CFG(port->idx),\n\t\t\t\t\t stat, stat & CORE_LANE_CFG_REFCLK0ACK,\n\t\t\t\t\t 100, 50000);\n\tif (res < 0)\n\t\treturn res;\n\n\trmw_set(CORE_LANE_CFG_REFCLK1REQ, pcie->base + CORE_LANE_CFG(port->idx));\n\tres = readl_relaxed_poll_timeout(pcie->base + CORE_LANE_CFG(port->idx),\n\t\t\t\t\t stat, stat & CORE_LANE_CFG_REFCLK1ACK,\n\t\t\t\t\t 100, 50000);\n\n\tif (res < 0)\n\t\treturn res;\n\n\trmw_clear(CORE_LANE_CTL_CFGACC, pcie->base + CORE_LANE_CTL(port->idx));\n\n\trmw_set(CORE_LANE_CFG_REFCLKEN, pcie->base + CORE_LANE_CFG(port->idx));\n\trmw_set(PORT_REFCLK_EN, port->base + PORT_REFCLK);\n\n\treturn 0;\n}\n\nstatic u32 apple_pcie_rid2sid_write(struct apple_pcie_port *port,\n\t\t\t\t    int idx, u32 val)\n{\n\twritel_relaxed(val, port->base + PORT_RID2SID(idx));\n\t \n\treturn readl_relaxed(port->base + PORT_RID2SID(idx));\n}\n\nstatic int apple_pcie_setup_port(struct apple_pcie *pcie,\n\t\t\t\t struct device_node *np)\n{\n\tstruct platform_device *platform = to_platform_device(pcie->dev);\n\tstruct apple_pcie_port *port;\n\tstruct gpio_desc *reset;\n\tu32 stat, idx;\n\tint ret, i;\n\n\treset = devm_fwnode_gpiod_get(pcie->dev, of_fwnode_handle(np), \"reset\",\n\t\t\t\t      GPIOD_OUT_LOW, \"PERST#\");\n\tif (IS_ERR(reset))\n\t\treturn PTR_ERR(reset);\n\n\tport = devm_kzalloc(pcie->dev, sizeof(*port), GFP_KERNEL);\n\tif (!port)\n\t\treturn -ENOMEM;\n\n\tret = of_property_read_u32_index(np, \"reg\", 0, &idx);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tport->idx = idx >> 11;\n\tport->pcie = pcie;\n\tport->np = np;\n\n\tport->base = devm_platform_ioremap_resource(platform, port->idx + 2);\n\tif (IS_ERR(port->base))\n\t\treturn PTR_ERR(port->base);\n\n\trmw_set(PORT_APPCLK_EN, port->base + PORT_APPCLK);\n\n\t \n\tgpiod_set_value(reset, 1);\n\n\tret = apple_pcie_setup_refclk(pcie, port);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tusleep_range(100, 200);\n\n\t \n\trmw_set(PORT_PERST_OFF, port->base + PORT_PERST);\n\tgpiod_set_value(reset, 0);\n\n\t \n\tmsleep(100);\n\n\tret = readl_relaxed_poll_timeout(port->base + PORT_STATUS, stat,\n\t\t\t\t\t stat & PORT_STATUS_READY, 100, 250000);\n\tif (ret < 0) {\n\t\tdev_err(pcie->dev, \"port %pOF ready wait timeout\\n\", np);\n\t\treturn ret;\n\t}\n\n\trmw_clear(PORT_REFCLK_CGDIS, port->base + PORT_REFCLK);\n\trmw_clear(PORT_APPCLK_CGDIS, port->base + PORT_APPCLK);\n\n\tret = apple_pcie_port_setup_irq(port);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tfor (i = 0; i < MAX_RID2SID; i++) {\n\t\tif (apple_pcie_rid2sid_write(port, i, 0xbad1d) != 0xbad1d)\n\t\t\tbreak;\n\t\tapple_pcie_rid2sid_write(port, i, 0);\n\t}\n\n\tdev_dbg(pcie->dev, \"%pOF: %d RID/SID mapping entries\\n\", np, i);\n\n\tport->sid_map_sz = i;\n\n\tlist_add_tail(&port->entry, &pcie->ports);\n\tinit_completion(&pcie->event);\n\n\tret = apple_pcie_port_register_irqs(port);\n\tWARN_ON(ret);\n\n\twritel_relaxed(PORT_LTSSMCTL_START, port->base + PORT_LTSSMCTL);\n\n\tif (!wait_for_completion_timeout(&pcie->event, HZ / 10))\n\t\tdev_warn(pcie->dev, \"%pOF link didn't come up\\n\", np);\n\n\treturn 0;\n}\n\nstatic int apple_msi_init(struct apple_pcie *pcie)\n{\n\tstruct fwnode_handle *fwnode = dev_fwnode(pcie->dev);\n\tstruct of_phandle_args args = {};\n\tstruct irq_domain *parent;\n\tint ret;\n\n\tret = of_parse_phandle_with_args(to_of_node(fwnode), \"msi-ranges\",\n\t\t\t\t\t \"#interrupt-cells\", 0, &args);\n\tif (ret)\n\t\treturn ret;\n\n\tret = of_property_read_u32_index(to_of_node(fwnode), \"msi-ranges\",\n\t\t\t\t\t args.args_count + 1, &pcie->nvecs);\n\tif (ret)\n\t\treturn ret;\n\n\tof_phandle_args_to_fwspec(args.np, args.args, args.args_count,\n\t\t\t\t  &pcie->fwspec);\n\n\tpcie->bitmap = devm_bitmap_zalloc(pcie->dev, pcie->nvecs, GFP_KERNEL);\n\tif (!pcie->bitmap)\n\t\treturn -ENOMEM;\n\n\tparent = irq_find_matching_fwspec(&pcie->fwspec, DOMAIN_BUS_WIRED);\n\tif (!parent) {\n\t\tdev_err(pcie->dev, \"failed to find parent domain\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tparent = irq_domain_create_hierarchy(parent, 0, pcie->nvecs, fwnode,\n\t\t\t\t\t     &apple_msi_domain_ops, pcie);\n\tif (!parent) {\n\t\tdev_err(pcie->dev, \"failed to create IRQ domain\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tirq_domain_update_bus_token(parent, DOMAIN_BUS_NEXUS);\n\n\tpcie->domain = pci_msi_create_irq_domain(fwnode, &apple_msi_info,\n\t\t\t\t\t\t parent);\n\tif (!pcie->domain) {\n\t\tdev_err(pcie->dev, \"failed to create MSI domain\\n\");\n\t\tirq_domain_remove(parent);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic struct apple_pcie_port *apple_pcie_get_port(struct pci_dev *pdev)\n{\n\tstruct pci_config_window *cfg = pdev->sysdata;\n\tstruct apple_pcie *pcie = cfg->priv;\n\tstruct pci_dev *port_pdev;\n\tstruct apple_pcie_port *port;\n\n\t \n\tport_pdev = pcie_find_root_port(pdev);\n\n\t \n\tif (WARN_ON(!port_pdev) || pdev == port_pdev)\n\t\treturn NULL;\n\n\tlist_for_each_entry(port, &pcie->ports, entry) {\n\t\tif (port->idx == PCI_SLOT(port_pdev->devfn))\n\t\t\treturn port;\n\t}\n\n\treturn NULL;\n}\n\nstatic int apple_pcie_add_device(struct apple_pcie_port *port,\n\t\t\t\t struct pci_dev *pdev)\n{\n\tu32 sid, rid = pci_dev_id(pdev);\n\tint idx, err;\n\n\tdev_dbg(&pdev->dev, \"added to bus %s, index %d\\n\",\n\t\tpci_name(pdev->bus->self), port->idx);\n\n\terr = of_map_id(port->pcie->dev->of_node, rid, \"iommu-map\",\n\t\t\t\"iommu-map-mask\", NULL, &sid);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&port->pcie->lock);\n\n\tidx = bitmap_find_free_region(port->sid_map, port->sid_map_sz, 0);\n\tif (idx >= 0) {\n\t\tapple_pcie_rid2sid_write(port, idx,\n\t\t\t\t\t PORT_RID2SID_VALID |\n\t\t\t\t\t (sid << PORT_RID2SID_SID_SHIFT) | rid);\n\n\t\tdev_dbg(&pdev->dev, \"mapping RID%x to SID%x (index %d)\\n\",\n\t\t\trid, sid, idx);\n\t}\n\n\tmutex_unlock(&port->pcie->lock);\n\n\treturn idx >= 0 ? 0 : -ENOSPC;\n}\n\nstatic void apple_pcie_release_device(struct apple_pcie_port *port,\n\t\t\t\t      struct pci_dev *pdev)\n{\n\tu32 rid = pci_dev_id(pdev);\n\tint idx;\n\n\tmutex_lock(&port->pcie->lock);\n\n\tfor_each_set_bit(idx, port->sid_map, port->sid_map_sz) {\n\t\tu32 val;\n\n\t\tval = readl_relaxed(port->base + PORT_RID2SID(idx));\n\t\tif ((val & 0xffff) == rid) {\n\t\t\tapple_pcie_rid2sid_write(port, idx, 0);\n\t\t\tbitmap_release_region(port->sid_map, idx, 0);\n\t\t\tdev_dbg(&pdev->dev, \"Released %x (%d)\\n\", val, idx);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tmutex_unlock(&port->pcie->lock);\n}\n\nstatic int apple_pcie_bus_notifier(struct notifier_block *nb,\n\t\t\t\t   unsigned long action,\n\t\t\t\t   void *data)\n{\n\tstruct device *dev = data;\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tstruct apple_pcie_port *port;\n\tint err;\n\n\t \n\tport = apple_pcie_get_port(pdev);\n\tif (!port)\n\t\treturn NOTIFY_DONE;\n\n\tswitch (action) {\n\tcase BUS_NOTIFY_ADD_DEVICE:\n\t\terr = apple_pcie_add_device(port, pdev);\n\t\tif (err)\n\t\t\treturn notifier_from_errno(err);\n\t\tbreak;\n\tcase BUS_NOTIFY_DEL_DEVICE:\n\t\tapple_pcie_release_device(port, pdev);\n\t\tbreak;\n\tdefault:\n\t\treturn NOTIFY_DONE;\n\t}\n\n\treturn NOTIFY_OK;\n}\n\nstatic struct notifier_block apple_pcie_nb = {\n\t.notifier_call = apple_pcie_bus_notifier,\n};\n\nstatic int apple_pcie_init(struct pci_config_window *cfg)\n{\n\tstruct device *dev = cfg->parent;\n\tstruct platform_device *platform = to_platform_device(dev);\n\tstruct device_node *of_port;\n\tstruct apple_pcie *pcie;\n\tint ret;\n\n\tpcie = devm_kzalloc(dev, sizeof(*pcie), GFP_KERNEL);\n\tif (!pcie)\n\t\treturn -ENOMEM;\n\n\tpcie->dev = dev;\n\n\tmutex_init(&pcie->lock);\n\n\tpcie->base = devm_platform_ioremap_resource(platform, 1);\n\tif (IS_ERR(pcie->base))\n\t\treturn PTR_ERR(pcie->base);\n\n\tcfg->priv = pcie;\n\tINIT_LIST_HEAD(&pcie->ports);\n\n\tret = apple_msi_init(pcie);\n\tif (ret)\n\t\treturn ret;\n\n\tfor_each_child_of_node(dev->of_node, of_port) {\n\t\tret = apple_pcie_setup_port(pcie, of_port);\n\t\tif (ret) {\n\t\t\tdev_err(pcie->dev, \"Port %pOF setup fail: %d\\n\", of_port, ret);\n\t\t\tof_node_put(of_port);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int apple_pcie_probe(struct platform_device *pdev)\n{\n\tint ret;\n\n\tret = bus_register_notifier(&pci_bus_type, &apple_pcie_nb);\n\tif (ret)\n\t\treturn ret;\n\n\tret = pci_host_common_probe(pdev);\n\tif (ret)\n\t\tbus_unregister_notifier(&pci_bus_type, &apple_pcie_nb);\n\n\treturn ret;\n}\n\nstatic const struct pci_ecam_ops apple_pcie_cfg_ecam_ops = {\n\t.init\t\t= apple_pcie_init,\n\t.pci_ops\t= {\n\t\t.map_bus\t= pci_ecam_map_bus,\n\t\t.read\t\t= pci_generic_config_read,\n\t\t.write\t\t= pci_generic_config_write,\n\t}\n};\n\nstatic const struct of_device_id apple_pcie_of_match[] = {\n\t{ .compatible = \"apple,pcie\", .data = &apple_pcie_cfg_ecam_ops },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, apple_pcie_of_match);\n\nstatic struct platform_driver apple_pcie_driver = {\n\t.probe\t= apple_pcie_probe,\n\t.driver\t= {\n\t\t.name\t\t\t= \"pcie-apple\",\n\t\t.of_match_table\t\t= apple_pcie_of_match,\n\t\t.suppress_bind_attrs\t= true,\n\t},\n};\nmodule_platform_driver(apple_pcie_driver);\n\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}