{
  "module_name": "pcie-mediatek.c",
  "hash_id": "8720fb963607c890492767116aaaa2beb1cc988809ca594187d9e381b51509d5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/controller/pcie-mediatek.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/iopoll.h>\n#include <linux/irq.h>\n#include <linux/irqchip/chained_irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel.h>\n#include <linux/mfd/syscon.h>\n#include <linux/msi.h>\n#include <linux/module.h>\n#include <linux/of_address.h>\n#include <linux/of_pci.h>\n#include <linux/of_platform.h>\n#include <linux/pci.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n#include <linux/reset.h>\n\n#include \"../pci.h\"\n\n \n#define PCIE_SYS_CFG\t\t0x00\n#define PCIE_INT_ENABLE\t\t0x0c\n#define PCIE_CFG_ADDR\t\t0x20\n#define PCIE_CFG_DATA\t\t0x24\n\n \n#define PCIE_BAR0_SETUP\t\t0x10\n#define PCIE_CLASS\t\t0x34\n#define PCIE_LINK_STATUS\t0x50\n\n#define PCIE_PORT_INT_EN(x)\tBIT(20 + (x))\n#define PCIE_PORT_PERST(x)\tBIT(1 + (x))\n#define PCIE_PORT_LINKUP\tBIT(0)\n#define PCIE_BAR_MAP_MAX\tGENMASK(31, 16)\n\n#define PCIE_BAR_ENABLE\t\tBIT(0)\n#define PCIE_REVISION_ID\tBIT(0)\n#define PCIE_CLASS_CODE\t\t(0x60400 << 8)\n#define PCIE_CONF_REG(regn)\t(((regn) & GENMASK(7, 2)) | \\\n\t\t\t\t((((regn) >> 8) & GENMASK(3, 0)) << 24))\n#define PCIE_CONF_FUN(fun)\t(((fun) << 8) & GENMASK(10, 8))\n#define PCIE_CONF_DEV(dev)\t(((dev) << 11) & GENMASK(15, 11))\n#define PCIE_CONF_BUS(bus)\t(((bus) << 16) & GENMASK(23, 16))\n#define PCIE_CONF_ADDR(regn, fun, dev, bus) \\\n\t(PCIE_CONF_REG(regn) | PCIE_CONF_FUN(fun) | \\\n\t PCIE_CONF_DEV(dev) | PCIE_CONF_BUS(bus))\n\n \n#define PCIE_FTS_NUM\t\t0x70c\n#define PCIE_FTS_NUM_MASK\tGENMASK(15, 8)\n#define PCIE_FTS_NUM_L0(x)\t((x) & 0xff << 8)\n\n#define PCIE_FC_CREDIT\t\t0x73c\n#define PCIE_FC_CREDIT_MASK\t(GENMASK(31, 31) | GENMASK(28, 16))\n#define PCIE_FC_CREDIT_VAL(x)\t((x) << 16)\n\n \n#define PCIE_SYS_CFG_V2\t\t0x0\n#define PCIE_CSR_LTSSM_EN(x)\tBIT(0 + (x) * 8)\n#define PCIE_CSR_ASPM_L1_EN(x)\tBIT(1 + (x) * 8)\n\n \n#define PCIE_MSI_VECTOR\t\t0x0c0\n\n#define PCIE_CONF_VEND_ID\t0x100\n#define PCIE_CONF_DEVICE_ID\t0x102\n#define PCIE_CONF_CLASS_ID\t0x106\n\n#define PCIE_INT_MASK\t\t0x420\n#define INTX_MASK\t\tGENMASK(19, 16)\n#define INTX_SHIFT\t\t16\n#define PCIE_INT_STATUS\t\t0x424\n#define MSI_STATUS\t\tBIT(23)\n#define PCIE_IMSI_STATUS\t0x42c\n#define PCIE_IMSI_ADDR\t\t0x430\n#define MSI_MASK\t\tBIT(23)\n#define MTK_MSI_IRQS_NUM\t32\n\n#define PCIE_AHB_TRANS_BASE0_L\t0x438\n#define PCIE_AHB_TRANS_BASE0_H\t0x43c\n#define AHB2PCIE_SIZE(x)\t((x) & GENMASK(4, 0))\n#define PCIE_AXI_WINDOW0\t0x448\n#define WIN_ENABLE\t\tBIT(7)\n \n#define PCIE2AHB_SIZE\t0x21\n\n \n#define PCIE_CFG_HEADER0\t0x460\n#define PCIE_CFG_HEADER1\t0x464\n#define PCIE_CFG_HEADER2\t0x468\n#define PCIE_CFG_WDATA\t\t0x470\n#define PCIE_APP_TLP_REQ\t0x488\n#define PCIE_CFG_RDATA\t\t0x48c\n#define APP_CFG_REQ\t\tBIT(0)\n#define APP_CPL_STATUS\t\tGENMASK(7, 5)\n\n#define CFG_WRRD_TYPE_0\t\t4\n#define CFG_WR_FMT\t\t2\n#define CFG_RD_FMT\t\t0\n\n#define CFG_DW0_LENGTH(length)\t((length) & GENMASK(9, 0))\n#define CFG_DW0_TYPE(type)\t(((type) << 24) & GENMASK(28, 24))\n#define CFG_DW0_FMT(fmt)\t(((fmt) << 29) & GENMASK(31, 29))\n#define CFG_DW2_REGN(regn)\t((regn) & GENMASK(11, 2))\n#define CFG_DW2_FUN(fun)\t(((fun) << 16) & GENMASK(18, 16))\n#define CFG_DW2_DEV(dev)\t(((dev) << 19) & GENMASK(23, 19))\n#define CFG_DW2_BUS(bus)\t(((bus) << 24) & GENMASK(31, 24))\n#define CFG_HEADER_DW0(type, fmt) \\\n\t(CFG_DW0_LENGTH(1) | CFG_DW0_TYPE(type) | CFG_DW0_FMT(fmt))\n#define CFG_HEADER_DW1(where, size) \\\n\t(GENMASK(((size) - 1), 0) << ((where) & 0x3))\n#define CFG_HEADER_DW2(regn, fun, dev, bus) \\\n\t(CFG_DW2_REGN(regn) | CFG_DW2_FUN(fun) | \\\n\tCFG_DW2_DEV(dev) | CFG_DW2_BUS(bus))\n\n#define PCIE_RST_CTRL\t\t0x510\n#define PCIE_PHY_RSTB\t\tBIT(0)\n#define PCIE_PIPE_SRSTB\t\tBIT(1)\n#define PCIE_MAC_SRSTB\t\tBIT(2)\n#define PCIE_CRSTB\t\tBIT(3)\n#define PCIE_PERSTB\t\tBIT(8)\n#define PCIE_LINKDOWN_RST_EN\tGENMASK(15, 13)\n#define PCIE_LINK_STATUS_V2\t0x804\n#define PCIE_PORT_LINKUP_V2\tBIT(10)\n\nstruct mtk_pcie_port;\n\n \nstruct mtk_pcie_soc {\n\tbool need_fix_class_id;\n\tbool need_fix_device_id;\n\tbool no_msi;\n\tunsigned int device_id;\n\tstruct pci_ops *ops;\n\tint (*startup)(struct mtk_pcie_port *port);\n\tint (*setup_irq)(struct mtk_pcie_port *port, struct device_node *node);\n};\n\n \nstruct mtk_pcie_port {\n\tvoid __iomem *base;\n\tstruct list_head list;\n\tstruct mtk_pcie *pcie;\n\tstruct reset_control *reset;\n\tstruct clk *sys_ck;\n\tstruct clk *ahb_ck;\n\tstruct clk *axi_ck;\n\tstruct clk *aux_ck;\n\tstruct clk *obff_ck;\n\tstruct clk *pipe_ck;\n\tstruct phy *phy;\n\tu32 slot;\n\tint irq;\n\tstruct irq_domain *irq_domain;\n\tstruct irq_domain *inner_domain;\n\tstruct irq_domain *msi_domain;\n\tstruct mutex lock;\n\tDECLARE_BITMAP(msi_irq_in_use, MTK_MSI_IRQS_NUM);\n};\n\n \nstruct mtk_pcie {\n\tstruct device *dev;\n\tvoid __iomem *base;\n\tstruct regmap *cfg;\n\tstruct clk *free_ck;\n\n\tstruct list_head ports;\n\tconst struct mtk_pcie_soc *soc;\n};\n\nstatic void mtk_pcie_subsys_powerdown(struct mtk_pcie *pcie)\n{\n\tstruct device *dev = pcie->dev;\n\n\tclk_disable_unprepare(pcie->free_ck);\n\n\tpm_runtime_put_sync(dev);\n\tpm_runtime_disable(dev);\n}\n\nstatic void mtk_pcie_port_free(struct mtk_pcie_port *port)\n{\n\tstruct mtk_pcie *pcie = port->pcie;\n\tstruct device *dev = pcie->dev;\n\n\tdevm_iounmap(dev, port->base);\n\tlist_del(&port->list);\n\tdevm_kfree(dev, port);\n}\n\nstatic void mtk_pcie_put_resources(struct mtk_pcie *pcie)\n{\n\tstruct mtk_pcie_port *port, *tmp;\n\n\tlist_for_each_entry_safe(port, tmp, &pcie->ports, list) {\n\t\tphy_power_off(port->phy);\n\t\tphy_exit(port->phy);\n\t\tclk_disable_unprepare(port->pipe_ck);\n\t\tclk_disable_unprepare(port->obff_ck);\n\t\tclk_disable_unprepare(port->axi_ck);\n\t\tclk_disable_unprepare(port->aux_ck);\n\t\tclk_disable_unprepare(port->ahb_ck);\n\t\tclk_disable_unprepare(port->sys_ck);\n\t\tmtk_pcie_port_free(port);\n\t}\n\n\tmtk_pcie_subsys_powerdown(pcie);\n}\n\nstatic int mtk_pcie_check_cfg_cpld(struct mtk_pcie_port *port)\n{\n\tu32 val;\n\tint err;\n\n\terr = readl_poll_timeout_atomic(port->base + PCIE_APP_TLP_REQ, val,\n\t\t\t\t\t!(val & APP_CFG_REQ), 10,\n\t\t\t\t\t100 * USEC_PER_MSEC);\n\tif (err)\n\t\treturn PCIBIOS_SET_FAILED;\n\n\tif (readl(port->base + PCIE_APP_TLP_REQ) & APP_CPL_STATUS)\n\t\treturn PCIBIOS_SET_FAILED;\n\n\treturn PCIBIOS_SUCCESSFUL;\n}\n\nstatic int mtk_pcie_hw_rd_cfg(struct mtk_pcie_port *port, u32 bus, u32 devfn,\n\t\t\t      int where, int size, u32 *val)\n{\n\tu32 tmp;\n\n\t \n\twritel(CFG_HEADER_DW0(CFG_WRRD_TYPE_0, CFG_RD_FMT),\n\t       port->base + PCIE_CFG_HEADER0);\n\twritel(CFG_HEADER_DW1(where, size), port->base + PCIE_CFG_HEADER1);\n\twritel(CFG_HEADER_DW2(where, PCI_FUNC(devfn), PCI_SLOT(devfn), bus),\n\t       port->base + PCIE_CFG_HEADER2);\n\n\t \n\ttmp = readl(port->base + PCIE_APP_TLP_REQ);\n\ttmp |= APP_CFG_REQ;\n\twritel(tmp, port->base + PCIE_APP_TLP_REQ);\n\n\t \n\tif (mtk_pcie_check_cfg_cpld(port))\n\t\treturn PCIBIOS_SET_FAILED;\n\n\t \n\t*val = readl(port->base + PCIE_CFG_RDATA);\n\n\tif (size == 1)\n\t\t*val = (*val >> (8 * (where & 3))) & 0xff;\n\telse if (size == 2)\n\t\t*val = (*val >> (8 * (where & 3))) & 0xffff;\n\n\treturn PCIBIOS_SUCCESSFUL;\n}\n\nstatic int mtk_pcie_hw_wr_cfg(struct mtk_pcie_port *port, u32 bus, u32 devfn,\n\t\t\t      int where, int size, u32 val)\n{\n\t \n\twritel(CFG_HEADER_DW0(CFG_WRRD_TYPE_0, CFG_WR_FMT),\n\t       port->base + PCIE_CFG_HEADER0);\n\twritel(CFG_HEADER_DW1(where, size), port->base + PCIE_CFG_HEADER1);\n\twritel(CFG_HEADER_DW2(where, PCI_FUNC(devfn), PCI_SLOT(devfn), bus),\n\t       port->base + PCIE_CFG_HEADER2);\n\n\t \n\tval = val << 8 * (where & 3);\n\twritel(val, port->base + PCIE_CFG_WDATA);\n\n\t \n\tval = readl(port->base + PCIE_APP_TLP_REQ);\n\tval |= APP_CFG_REQ;\n\twritel(val, port->base + PCIE_APP_TLP_REQ);\n\n\t \n\treturn mtk_pcie_check_cfg_cpld(port);\n}\n\nstatic struct mtk_pcie_port *mtk_pcie_find_port(struct pci_bus *bus,\n\t\t\t\t\t\tunsigned int devfn)\n{\n\tstruct mtk_pcie *pcie = bus->sysdata;\n\tstruct mtk_pcie_port *port;\n\tstruct pci_dev *dev = NULL;\n\n\t \n\twhile (bus && bus->number) {\n\t\tdev = bus->self;\n\t\tbus = dev->bus;\n\t\tdevfn = dev->devfn;\n\t}\n\n\tlist_for_each_entry(port, &pcie->ports, list)\n\t\tif (port->slot == PCI_SLOT(devfn))\n\t\t\treturn port;\n\n\treturn NULL;\n}\n\nstatic int mtk_pcie_config_read(struct pci_bus *bus, unsigned int devfn,\n\t\t\t\tint where, int size, u32 *val)\n{\n\tstruct mtk_pcie_port *port;\n\tu32 bn = bus->number;\n\n\tport = mtk_pcie_find_port(bus, devfn);\n\tif (!port)\n\t\treturn PCIBIOS_DEVICE_NOT_FOUND;\n\n\treturn mtk_pcie_hw_rd_cfg(port, bn, devfn, where, size, val);\n}\n\nstatic int mtk_pcie_config_write(struct pci_bus *bus, unsigned int devfn,\n\t\t\t\t int where, int size, u32 val)\n{\n\tstruct mtk_pcie_port *port;\n\tu32 bn = bus->number;\n\n\tport = mtk_pcie_find_port(bus, devfn);\n\tif (!port)\n\t\treturn PCIBIOS_DEVICE_NOT_FOUND;\n\n\treturn mtk_pcie_hw_wr_cfg(port, bn, devfn, where, size, val);\n}\n\nstatic struct pci_ops mtk_pcie_ops_v2 = {\n\t.read  = mtk_pcie_config_read,\n\t.write = mtk_pcie_config_write,\n};\n\nstatic void mtk_compose_msi_msg(struct irq_data *data, struct msi_msg *msg)\n{\n\tstruct mtk_pcie_port *port = irq_data_get_irq_chip_data(data);\n\tphys_addr_t addr;\n\n\t \n\taddr = virt_to_phys(port->base + PCIE_MSI_VECTOR);\n\tmsg->address_hi = 0;\n\tmsg->address_lo = lower_32_bits(addr);\n\n\tmsg->data = data->hwirq;\n\n\tdev_dbg(port->pcie->dev, \"msi#%d address_hi %#x address_lo %#x\\n\",\n\t\t(int)data->hwirq, msg->address_hi, msg->address_lo);\n}\n\nstatic int mtk_msi_set_affinity(struct irq_data *irq_data,\n\t\t\t\tconst struct cpumask *mask, bool force)\n{\n\t return -EINVAL;\n}\n\nstatic void mtk_msi_ack_irq(struct irq_data *data)\n{\n\tstruct mtk_pcie_port *port = irq_data_get_irq_chip_data(data);\n\tu32 hwirq = data->hwirq;\n\n\twritel(1 << hwirq, port->base + PCIE_IMSI_STATUS);\n}\n\nstatic struct irq_chip mtk_msi_bottom_irq_chip = {\n\t.name\t\t\t= \"MTK MSI\",\n\t.irq_compose_msi_msg\t= mtk_compose_msi_msg,\n\t.irq_set_affinity\t= mtk_msi_set_affinity,\n\t.irq_ack\t\t= mtk_msi_ack_irq,\n};\n\nstatic int mtk_pcie_irq_domain_alloc(struct irq_domain *domain, unsigned int virq,\n\t\t\t\t     unsigned int nr_irqs, void *args)\n{\n\tstruct mtk_pcie_port *port = domain->host_data;\n\tunsigned long bit;\n\n\tWARN_ON(nr_irqs != 1);\n\tmutex_lock(&port->lock);\n\n\tbit = find_first_zero_bit(port->msi_irq_in_use, MTK_MSI_IRQS_NUM);\n\tif (bit >= MTK_MSI_IRQS_NUM) {\n\t\tmutex_unlock(&port->lock);\n\t\treturn -ENOSPC;\n\t}\n\n\t__set_bit(bit, port->msi_irq_in_use);\n\n\tmutex_unlock(&port->lock);\n\n\tirq_domain_set_info(domain, virq, bit, &mtk_msi_bottom_irq_chip,\n\t\t\t    domain->host_data, handle_edge_irq,\n\t\t\t    NULL, NULL);\n\n\treturn 0;\n}\n\nstatic void mtk_pcie_irq_domain_free(struct irq_domain *domain,\n\t\t\t\t     unsigned int virq, unsigned int nr_irqs)\n{\n\tstruct irq_data *d = irq_domain_get_irq_data(domain, virq);\n\tstruct mtk_pcie_port *port = irq_data_get_irq_chip_data(d);\n\n\tmutex_lock(&port->lock);\n\n\tif (!test_bit(d->hwirq, port->msi_irq_in_use))\n\t\tdev_err(port->pcie->dev, \"trying to free unused MSI#%lu\\n\",\n\t\t\td->hwirq);\n\telse\n\t\t__clear_bit(d->hwirq, port->msi_irq_in_use);\n\n\tmutex_unlock(&port->lock);\n\n\tirq_domain_free_irqs_parent(domain, virq, nr_irqs);\n}\n\nstatic const struct irq_domain_ops msi_domain_ops = {\n\t.alloc\t= mtk_pcie_irq_domain_alloc,\n\t.free\t= mtk_pcie_irq_domain_free,\n};\n\nstatic struct irq_chip mtk_msi_irq_chip = {\n\t.name\t\t= \"MTK PCIe MSI\",\n\t.irq_ack\t= irq_chip_ack_parent,\n\t.irq_mask\t= pci_msi_mask_irq,\n\t.irq_unmask\t= pci_msi_unmask_irq,\n};\n\nstatic struct msi_domain_info mtk_msi_domain_info = {\n\t.flags\t= (MSI_FLAG_USE_DEF_DOM_OPS | MSI_FLAG_USE_DEF_CHIP_OPS |\n\t\t   MSI_FLAG_PCI_MSIX),\n\t.chip\t= &mtk_msi_irq_chip,\n};\n\nstatic int mtk_pcie_allocate_msi_domains(struct mtk_pcie_port *port)\n{\n\tstruct fwnode_handle *fwnode = of_node_to_fwnode(port->pcie->dev->of_node);\n\n\tmutex_init(&port->lock);\n\n\tport->inner_domain = irq_domain_create_linear(fwnode, MTK_MSI_IRQS_NUM,\n\t\t\t\t\t\t      &msi_domain_ops, port);\n\tif (!port->inner_domain) {\n\t\tdev_err(port->pcie->dev, \"failed to create IRQ domain\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tport->msi_domain = pci_msi_create_irq_domain(fwnode, &mtk_msi_domain_info,\n\t\t\t\t\t\t     port->inner_domain);\n\tif (!port->msi_domain) {\n\t\tdev_err(port->pcie->dev, \"failed to create MSI domain\\n\");\n\t\tirq_domain_remove(port->inner_domain);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic void mtk_pcie_enable_msi(struct mtk_pcie_port *port)\n{\n\tu32 val;\n\tphys_addr_t msg_addr;\n\n\tmsg_addr = virt_to_phys(port->base + PCIE_MSI_VECTOR);\n\tval = lower_32_bits(msg_addr);\n\twritel(val, port->base + PCIE_IMSI_ADDR);\n\n\tval = readl(port->base + PCIE_INT_MASK);\n\tval &= ~MSI_MASK;\n\twritel(val, port->base + PCIE_INT_MASK);\n}\n\nstatic void mtk_pcie_irq_teardown(struct mtk_pcie *pcie)\n{\n\tstruct mtk_pcie_port *port, *tmp;\n\n\tlist_for_each_entry_safe(port, tmp, &pcie->ports, list) {\n\t\tirq_set_chained_handler_and_data(port->irq, NULL, NULL);\n\n\t\tif (port->irq_domain)\n\t\t\tirq_domain_remove(port->irq_domain);\n\n\t\tif (IS_ENABLED(CONFIG_PCI_MSI)) {\n\t\t\tif (port->msi_domain)\n\t\t\t\tirq_domain_remove(port->msi_domain);\n\t\t\tif (port->inner_domain)\n\t\t\t\tirq_domain_remove(port->inner_domain);\n\t\t}\n\n\t\tirq_dispose_mapping(port->irq);\n\t}\n}\n\nstatic int mtk_pcie_intx_map(struct irq_domain *domain, unsigned int irq,\n\t\t\t     irq_hw_number_t hwirq)\n{\n\tirq_set_chip_and_handler(irq, &dummy_irq_chip, handle_simple_irq);\n\tirq_set_chip_data(irq, domain->host_data);\n\n\treturn 0;\n}\n\nstatic const struct irq_domain_ops intx_domain_ops = {\n\t.map = mtk_pcie_intx_map,\n};\n\nstatic int mtk_pcie_init_irq_domain(struct mtk_pcie_port *port,\n\t\t\t\t    struct device_node *node)\n{\n\tstruct device *dev = port->pcie->dev;\n\tstruct device_node *pcie_intc_node;\n\tint ret;\n\n\t \n\tpcie_intc_node = of_get_next_child(node, NULL);\n\tif (!pcie_intc_node) {\n\t\tdev_err(dev, \"no PCIe Intc node found\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tport->irq_domain = irq_domain_add_linear(pcie_intc_node, PCI_NUM_INTX,\n\t\t\t\t\t\t &intx_domain_ops, port);\n\tof_node_put(pcie_intc_node);\n\tif (!port->irq_domain) {\n\t\tdev_err(dev, \"failed to get INTx IRQ domain\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (IS_ENABLED(CONFIG_PCI_MSI)) {\n\t\tret = mtk_pcie_allocate_msi_domains(port);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void mtk_pcie_intr_handler(struct irq_desc *desc)\n{\n\tstruct mtk_pcie_port *port = irq_desc_get_handler_data(desc);\n\tstruct irq_chip *irqchip = irq_desc_get_chip(desc);\n\tunsigned long status;\n\tu32 bit = INTX_SHIFT;\n\n\tchained_irq_enter(irqchip, desc);\n\n\tstatus = readl(port->base + PCIE_INT_STATUS);\n\tif (status & INTX_MASK) {\n\t\tfor_each_set_bit_from(bit, &status, PCI_NUM_INTX + INTX_SHIFT) {\n\t\t\t \n\t\t\twritel(1 << bit, port->base + PCIE_INT_STATUS);\n\t\t\tgeneric_handle_domain_irq(port->irq_domain,\n\t\t\t\t\t\t  bit - INTX_SHIFT);\n\t\t}\n\t}\n\n\tif (IS_ENABLED(CONFIG_PCI_MSI)) {\n\t\tif (status & MSI_STATUS){\n\t\t\tunsigned long imsi_status;\n\n\t\t\t \n\t\t\twritel(MSI_STATUS, port->base + PCIE_INT_STATUS);\n\t\t\twhile ((imsi_status = readl(port->base + PCIE_IMSI_STATUS))) {\n\t\t\t\tfor_each_set_bit(bit, &imsi_status, MTK_MSI_IRQS_NUM)\n\t\t\t\t\tgeneric_handle_domain_irq(port->inner_domain, bit);\n\t\t\t}\n\t\t}\n\t}\n\n\tchained_irq_exit(irqchip, desc);\n}\n\nstatic int mtk_pcie_setup_irq(struct mtk_pcie_port *port,\n\t\t\t      struct device_node *node)\n{\n\tstruct mtk_pcie *pcie = port->pcie;\n\tstruct device *dev = pcie->dev;\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tint err;\n\n\terr = mtk_pcie_init_irq_domain(port, node);\n\tif (err) {\n\t\tdev_err(dev, \"failed to init PCIe IRQ domain\\n\");\n\t\treturn err;\n\t}\n\n\tif (of_property_present(dev->of_node, \"interrupt-names\"))\n\t\tport->irq = platform_get_irq_byname(pdev, \"pcie_irq\");\n\telse\n\t\tport->irq = platform_get_irq(pdev, port->slot);\n\n\tif (port->irq < 0)\n\t\treturn port->irq;\n\n\tirq_set_chained_handler_and_data(port->irq,\n\t\t\t\t\t mtk_pcie_intr_handler, port);\n\n\treturn 0;\n}\n\nstatic int mtk_pcie_startup_port_v2(struct mtk_pcie_port *port)\n{\n\tstruct mtk_pcie *pcie = port->pcie;\n\tstruct pci_host_bridge *host = pci_host_bridge_from_priv(pcie);\n\tstruct resource *mem = NULL;\n\tstruct resource_entry *entry;\n\tconst struct mtk_pcie_soc *soc = port->pcie->soc;\n\tu32 val;\n\tint err;\n\n\tentry = resource_list_first_type(&host->windows, IORESOURCE_MEM);\n\tif (entry)\n\t\tmem = entry->res;\n\tif (!mem)\n\t\treturn -EINVAL;\n\n\t \n\tif (pcie->base) {\n\t\tval = readl(pcie->base + PCIE_SYS_CFG_V2);\n\t\tval |= PCIE_CSR_LTSSM_EN(port->slot) |\n\t\t       PCIE_CSR_ASPM_L1_EN(port->slot);\n\t\twritel(val, pcie->base + PCIE_SYS_CFG_V2);\n\t} else if (pcie->cfg) {\n\t\tval = PCIE_CSR_LTSSM_EN(port->slot) |\n\t\t      PCIE_CSR_ASPM_L1_EN(port->slot);\n\t\tregmap_update_bits(pcie->cfg, PCIE_SYS_CFG_V2, val, val);\n\t}\n\n\t \n\twritel(0, port->base + PCIE_RST_CTRL);\n\n\t \n\twritel(PCIE_LINKDOWN_RST_EN, port->base + PCIE_RST_CTRL);\n\n\t \n\tmsleep(100);\n\n\t \n\tval = readl(port->base + PCIE_RST_CTRL);\n\tval |= PCIE_PHY_RSTB | PCIE_PERSTB | PCIE_PIPE_SRSTB |\n\t       PCIE_MAC_SRSTB | PCIE_CRSTB;\n\twritel(val, port->base + PCIE_RST_CTRL);\n\n\t \n\tif (soc->need_fix_class_id) {\n\t\tval = PCI_VENDOR_ID_MEDIATEK;\n\t\twritew(val, port->base + PCIE_CONF_VEND_ID);\n\n\t\tval = PCI_CLASS_BRIDGE_PCI;\n\t\twritew(val, port->base + PCIE_CONF_CLASS_ID);\n\t}\n\n\tif (soc->need_fix_device_id)\n\t\twritew(soc->device_id, port->base + PCIE_CONF_DEVICE_ID);\n\n\t \n\terr = readl_poll_timeout(port->base + PCIE_LINK_STATUS_V2, val,\n\t\t\t\t !!(val & PCIE_PORT_LINKUP_V2), 20,\n\t\t\t\t 100 * USEC_PER_MSEC);\n\tif (err)\n\t\treturn -ETIMEDOUT;\n\n\t \n\tval = readl(port->base + PCIE_INT_MASK);\n\tval &= ~INTX_MASK;\n\twritel(val, port->base + PCIE_INT_MASK);\n\n\tif (IS_ENABLED(CONFIG_PCI_MSI))\n\t\tmtk_pcie_enable_msi(port);\n\n\t \n\tval = lower_32_bits(mem->start) |\n\t      AHB2PCIE_SIZE(fls(resource_size(mem)));\n\twritel(val, port->base + PCIE_AHB_TRANS_BASE0_L);\n\n\tval = upper_32_bits(mem->start);\n\twritel(val, port->base + PCIE_AHB_TRANS_BASE0_H);\n\n\t \n\tval = PCIE2AHB_SIZE | WIN_ENABLE;\n\twritel(val, port->base + PCIE_AXI_WINDOW0);\n\n\treturn 0;\n}\n\nstatic void __iomem *mtk_pcie_map_bus(struct pci_bus *bus,\n\t\t\t\t      unsigned int devfn, int where)\n{\n\tstruct mtk_pcie *pcie = bus->sysdata;\n\n\twritel(PCIE_CONF_ADDR(where, PCI_FUNC(devfn), PCI_SLOT(devfn),\n\t\t\t      bus->number), pcie->base + PCIE_CFG_ADDR);\n\n\treturn pcie->base + PCIE_CFG_DATA + (where & 3);\n}\n\nstatic struct pci_ops mtk_pcie_ops = {\n\t.map_bus = mtk_pcie_map_bus,\n\t.read  = pci_generic_config_read,\n\t.write = pci_generic_config_write,\n};\n\nstatic int mtk_pcie_startup_port(struct mtk_pcie_port *port)\n{\n\tstruct mtk_pcie *pcie = port->pcie;\n\tu32 func = PCI_FUNC(port->slot);\n\tu32 slot = PCI_SLOT(port->slot << 3);\n\tu32 val;\n\tint err;\n\n\t \n\tval = readl(pcie->base + PCIE_SYS_CFG);\n\tval |= PCIE_PORT_PERST(port->slot);\n\twritel(val, pcie->base + PCIE_SYS_CFG);\n\n\t \n\tval = readl(pcie->base + PCIE_SYS_CFG);\n\tval &= ~PCIE_PORT_PERST(port->slot);\n\twritel(val, pcie->base + PCIE_SYS_CFG);\n\n\t \n\terr = readl_poll_timeout(port->base + PCIE_LINK_STATUS, val,\n\t\t\t\t !!(val & PCIE_PORT_LINKUP), 20,\n\t\t\t\t 100 * USEC_PER_MSEC);\n\tif (err)\n\t\treturn -ETIMEDOUT;\n\n\t \n\tval = readl(pcie->base + PCIE_INT_ENABLE);\n\tval |= PCIE_PORT_INT_EN(port->slot);\n\twritel(val, pcie->base + PCIE_INT_ENABLE);\n\n\t \n\twritel(PCIE_BAR_MAP_MAX | PCIE_BAR_ENABLE,\n\t       port->base + PCIE_BAR0_SETUP);\n\n\t \n\twritel(PCIE_CLASS_CODE | PCIE_REVISION_ID, port->base + PCIE_CLASS);\n\n\t \n\twritel(PCIE_CONF_ADDR(PCIE_FC_CREDIT, func, slot, 0),\n\t       pcie->base + PCIE_CFG_ADDR);\n\tval = readl(pcie->base + PCIE_CFG_DATA);\n\tval &= ~PCIE_FC_CREDIT_MASK;\n\tval |= PCIE_FC_CREDIT_VAL(0x806c);\n\twritel(PCIE_CONF_ADDR(PCIE_FC_CREDIT, func, slot, 0),\n\t       pcie->base + PCIE_CFG_ADDR);\n\twritel(val, pcie->base + PCIE_CFG_DATA);\n\n\t \n\twritel(PCIE_CONF_ADDR(PCIE_FTS_NUM, func, slot, 0),\n\t       pcie->base + PCIE_CFG_ADDR);\n\tval = readl(pcie->base + PCIE_CFG_DATA);\n\tval &= ~PCIE_FTS_NUM_MASK;\n\tval |= PCIE_FTS_NUM_L0(0x50);\n\twritel(PCIE_CONF_ADDR(PCIE_FTS_NUM, func, slot, 0),\n\t       pcie->base + PCIE_CFG_ADDR);\n\twritel(val, pcie->base + PCIE_CFG_DATA);\n\n\treturn 0;\n}\n\nstatic void mtk_pcie_enable_port(struct mtk_pcie_port *port)\n{\n\tstruct mtk_pcie *pcie = port->pcie;\n\tstruct device *dev = pcie->dev;\n\tint err;\n\n\terr = clk_prepare_enable(port->sys_ck);\n\tif (err) {\n\t\tdev_err(dev, \"failed to enable sys_ck%d clock\\n\", port->slot);\n\t\tgoto err_sys_clk;\n\t}\n\n\terr = clk_prepare_enable(port->ahb_ck);\n\tif (err) {\n\t\tdev_err(dev, \"failed to enable ahb_ck%d\\n\", port->slot);\n\t\tgoto err_ahb_clk;\n\t}\n\n\terr = clk_prepare_enable(port->aux_ck);\n\tif (err) {\n\t\tdev_err(dev, \"failed to enable aux_ck%d\\n\", port->slot);\n\t\tgoto err_aux_clk;\n\t}\n\n\terr = clk_prepare_enable(port->axi_ck);\n\tif (err) {\n\t\tdev_err(dev, \"failed to enable axi_ck%d\\n\", port->slot);\n\t\tgoto err_axi_clk;\n\t}\n\n\terr = clk_prepare_enable(port->obff_ck);\n\tif (err) {\n\t\tdev_err(dev, \"failed to enable obff_ck%d\\n\", port->slot);\n\t\tgoto err_obff_clk;\n\t}\n\n\terr = clk_prepare_enable(port->pipe_ck);\n\tif (err) {\n\t\tdev_err(dev, \"failed to enable pipe_ck%d\\n\", port->slot);\n\t\tgoto err_pipe_clk;\n\t}\n\n\treset_control_assert(port->reset);\n\treset_control_deassert(port->reset);\n\n\terr = phy_init(port->phy);\n\tif (err) {\n\t\tdev_err(dev, \"failed to initialize port%d phy\\n\", port->slot);\n\t\tgoto err_phy_init;\n\t}\n\n\terr = phy_power_on(port->phy);\n\tif (err) {\n\t\tdev_err(dev, \"failed to power on port%d phy\\n\", port->slot);\n\t\tgoto err_phy_on;\n\t}\n\n\tif (!pcie->soc->startup(port))\n\t\treturn;\n\n\tdev_info(dev, \"Port%d link down\\n\", port->slot);\n\n\tphy_power_off(port->phy);\nerr_phy_on:\n\tphy_exit(port->phy);\nerr_phy_init:\n\tclk_disable_unprepare(port->pipe_ck);\nerr_pipe_clk:\n\tclk_disable_unprepare(port->obff_ck);\nerr_obff_clk:\n\tclk_disable_unprepare(port->axi_ck);\nerr_axi_clk:\n\tclk_disable_unprepare(port->aux_ck);\nerr_aux_clk:\n\tclk_disable_unprepare(port->ahb_ck);\nerr_ahb_clk:\n\tclk_disable_unprepare(port->sys_ck);\nerr_sys_clk:\n\tmtk_pcie_port_free(port);\n}\n\nstatic int mtk_pcie_parse_port(struct mtk_pcie *pcie,\n\t\t\t       struct device_node *node,\n\t\t\t       int slot)\n{\n\tstruct mtk_pcie_port *port;\n\tstruct device *dev = pcie->dev;\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tchar name[10];\n\tint err;\n\n\tport = devm_kzalloc(dev, sizeof(*port), GFP_KERNEL);\n\tif (!port)\n\t\treturn -ENOMEM;\n\n\tsnprintf(name, sizeof(name), \"port%d\", slot);\n\tport->base = devm_platform_ioremap_resource_byname(pdev, name);\n\tif (IS_ERR(port->base)) {\n\t\tdev_err(dev, \"failed to map port%d base\\n\", slot);\n\t\treturn PTR_ERR(port->base);\n\t}\n\n\tsnprintf(name, sizeof(name), \"sys_ck%d\", slot);\n\tport->sys_ck = devm_clk_get(dev, name);\n\tif (IS_ERR(port->sys_ck)) {\n\t\tdev_err(dev, \"failed to get sys_ck%d clock\\n\", slot);\n\t\treturn PTR_ERR(port->sys_ck);\n\t}\n\n\t \n\tsnprintf(name, sizeof(name), \"ahb_ck%d\", slot);\n\tport->ahb_ck = devm_clk_get_optional(dev, name);\n\tif (IS_ERR(port->ahb_ck))\n\t\treturn PTR_ERR(port->ahb_ck);\n\n\tsnprintf(name, sizeof(name), \"axi_ck%d\", slot);\n\tport->axi_ck = devm_clk_get_optional(dev, name);\n\tif (IS_ERR(port->axi_ck))\n\t\treturn PTR_ERR(port->axi_ck);\n\n\tsnprintf(name, sizeof(name), \"aux_ck%d\", slot);\n\tport->aux_ck = devm_clk_get_optional(dev, name);\n\tif (IS_ERR(port->aux_ck))\n\t\treturn PTR_ERR(port->aux_ck);\n\n\tsnprintf(name, sizeof(name), \"obff_ck%d\", slot);\n\tport->obff_ck = devm_clk_get_optional(dev, name);\n\tif (IS_ERR(port->obff_ck))\n\t\treturn PTR_ERR(port->obff_ck);\n\n\tsnprintf(name, sizeof(name), \"pipe_ck%d\", slot);\n\tport->pipe_ck = devm_clk_get_optional(dev, name);\n\tif (IS_ERR(port->pipe_ck))\n\t\treturn PTR_ERR(port->pipe_ck);\n\n\tsnprintf(name, sizeof(name), \"pcie-rst%d\", slot);\n\tport->reset = devm_reset_control_get_optional_exclusive(dev, name);\n\tif (PTR_ERR(port->reset) == -EPROBE_DEFER)\n\t\treturn PTR_ERR(port->reset);\n\n\t \n\tsnprintf(name, sizeof(name), \"pcie-phy%d\", slot);\n\tport->phy = devm_phy_optional_get(dev, name);\n\tif (IS_ERR(port->phy))\n\t\treturn PTR_ERR(port->phy);\n\n\tport->slot = slot;\n\tport->pcie = pcie;\n\n\tif (pcie->soc->setup_irq) {\n\t\terr = pcie->soc->setup_irq(port, node);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tINIT_LIST_HEAD(&port->list);\n\tlist_add_tail(&port->list, &pcie->ports);\n\n\treturn 0;\n}\n\nstatic int mtk_pcie_subsys_powerup(struct mtk_pcie *pcie)\n{\n\tstruct device *dev = pcie->dev;\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct resource *regs;\n\tstruct device_node *cfg_node;\n\tint err;\n\n\t \n\tregs = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"subsys\");\n\tif (regs) {\n\t\tpcie->base = devm_ioremap_resource(dev, regs);\n\t\tif (IS_ERR(pcie->base))\n\t\t\treturn PTR_ERR(pcie->base);\n\t}\n\n\tcfg_node = of_find_compatible_node(NULL, NULL,\n\t\t\t\t\t   \"mediatek,generic-pciecfg\");\n\tif (cfg_node) {\n\t\tpcie->cfg = syscon_node_to_regmap(cfg_node);\n\t\tof_node_put(cfg_node);\n\t\tif (IS_ERR(pcie->cfg))\n\t\t\treturn PTR_ERR(pcie->cfg);\n\t}\n\n\tpcie->free_ck = devm_clk_get(dev, \"free_ck\");\n\tif (IS_ERR(pcie->free_ck)) {\n\t\tif (PTR_ERR(pcie->free_ck) == -EPROBE_DEFER)\n\t\t\treturn -EPROBE_DEFER;\n\n\t\tpcie->free_ck = NULL;\n\t}\n\n\tpm_runtime_enable(dev);\n\tpm_runtime_get_sync(dev);\n\n\t \n\terr = clk_prepare_enable(pcie->free_ck);\n\tif (err) {\n\t\tdev_err(dev, \"failed to enable free_ck\\n\");\n\t\tgoto err_free_ck;\n\t}\n\n\treturn 0;\n\nerr_free_ck:\n\tpm_runtime_put_sync(dev);\n\tpm_runtime_disable(dev);\n\n\treturn err;\n}\n\nstatic int mtk_pcie_setup(struct mtk_pcie *pcie)\n{\n\tstruct device *dev = pcie->dev;\n\tstruct device_node *node = dev->of_node, *child;\n\tstruct mtk_pcie_port *port, *tmp;\n\tint err, slot;\n\n\tslot = of_get_pci_domain_nr(dev->of_node);\n\tif (slot < 0) {\n\t\tfor_each_available_child_of_node(node, child) {\n\t\t\terr = of_pci_get_devfn(child);\n\t\t\tif (err < 0) {\n\t\t\t\tdev_err(dev, \"failed to get devfn: %d\\n\", err);\n\t\t\t\tgoto error_put_node;\n\t\t\t}\n\n\t\t\tslot = PCI_SLOT(err);\n\n\t\t\terr = mtk_pcie_parse_port(pcie, child, slot);\n\t\t\tif (err)\n\t\t\t\tgoto error_put_node;\n\t\t}\n\t} else {\n\t\terr = mtk_pcie_parse_port(pcie, node, slot);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\terr = mtk_pcie_subsys_powerup(pcie);\n\tif (err)\n\t\treturn err;\n\n\t \n\tlist_for_each_entry_safe(port, tmp, &pcie->ports, list)\n\t\tmtk_pcie_enable_port(port);\n\n\t \n\tif (list_empty(&pcie->ports))\n\t\tmtk_pcie_subsys_powerdown(pcie);\n\n\treturn 0;\nerror_put_node:\n\tof_node_put(child);\n\treturn err;\n}\n\nstatic int mtk_pcie_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct mtk_pcie *pcie;\n\tstruct pci_host_bridge *host;\n\tint err;\n\n\thost = devm_pci_alloc_host_bridge(dev, sizeof(*pcie));\n\tif (!host)\n\t\treturn -ENOMEM;\n\n\tpcie = pci_host_bridge_priv(host);\n\n\tpcie->dev = dev;\n\tpcie->soc = of_device_get_match_data(dev);\n\tplatform_set_drvdata(pdev, pcie);\n\tINIT_LIST_HEAD(&pcie->ports);\n\n\terr = mtk_pcie_setup(pcie);\n\tif (err)\n\t\treturn err;\n\n\thost->ops = pcie->soc->ops;\n\thost->sysdata = pcie;\n\thost->msi_domain = pcie->soc->no_msi;\n\n\terr = pci_host_probe(host);\n\tif (err)\n\t\tgoto put_resources;\n\n\treturn 0;\n\nput_resources:\n\tif (!list_empty(&pcie->ports))\n\t\tmtk_pcie_put_resources(pcie);\n\n\treturn err;\n}\n\n\nstatic void mtk_pcie_free_resources(struct mtk_pcie *pcie)\n{\n\tstruct pci_host_bridge *host = pci_host_bridge_from_priv(pcie);\n\tstruct list_head *windows = &host->windows;\n\n\tpci_free_resource_list(windows);\n}\n\nstatic void mtk_pcie_remove(struct platform_device *pdev)\n{\n\tstruct mtk_pcie *pcie = platform_get_drvdata(pdev);\n\tstruct pci_host_bridge *host = pci_host_bridge_from_priv(pcie);\n\n\tpci_stop_root_bus(host->bus);\n\tpci_remove_root_bus(host->bus);\n\tmtk_pcie_free_resources(pcie);\n\n\tmtk_pcie_irq_teardown(pcie);\n\n\tmtk_pcie_put_resources(pcie);\n}\n\nstatic int mtk_pcie_suspend_noirq(struct device *dev)\n{\n\tstruct mtk_pcie *pcie = dev_get_drvdata(dev);\n\tstruct mtk_pcie_port *port;\n\n\tif (list_empty(&pcie->ports))\n\t\treturn 0;\n\n\tlist_for_each_entry(port, &pcie->ports, list) {\n\t\tclk_disable_unprepare(port->pipe_ck);\n\t\tclk_disable_unprepare(port->obff_ck);\n\t\tclk_disable_unprepare(port->axi_ck);\n\t\tclk_disable_unprepare(port->aux_ck);\n\t\tclk_disable_unprepare(port->ahb_ck);\n\t\tclk_disable_unprepare(port->sys_ck);\n\t\tphy_power_off(port->phy);\n\t\tphy_exit(port->phy);\n\t}\n\n\tclk_disable_unprepare(pcie->free_ck);\n\n\treturn 0;\n}\n\nstatic int mtk_pcie_resume_noirq(struct device *dev)\n{\n\tstruct mtk_pcie *pcie = dev_get_drvdata(dev);\n\tstruct mtk_pcie_port *port, *tmp;\n\n\tif (list_empty(&pcie->ports))\n\t\treturn 0;\n\n\tclk_prepare_enable(pcie->free_ck);\n\n\tlist_for_each_entry_safe(port, tmp, &pcie->ports, list)\n\t\tmtk_pcie_enable_port(port);\n\n\t \n\tif (list_empty(&pcie->ports))\n\t\tclk_disable_unprepare(pcie->free_ck);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops mtk_pcie_pm_ops = {\n\tNOIRQ_SYSTEM_SLEEP_PM_OPS(mtk_pcie_suspend_noirq,\n\t\t\t\t  mtk_pcie_resume_noirq)\n};\n\nstatic const struct mtk_pcie_soc mtk_pcie_soc_v1 = {\n\t.no_msi = true,\n\t.ops = &mtk_pcie_ops,\n\t.startup = mtk_pcie_startup_port,\n};\n\nstatic const struct mtk_pcie_soc mtk_pcie_soc_mt2712 = {\n\t.ops = &mtk_pcie_ops_v2,\n\t.startup = mtk_pcie_startup_port_v2,\n\t.setup_irq = mtk_pcie_setup_irq,\n};\n\nstatic const struct mtk_pcie_soc mtk_pcie_soc_mt7622 = {\n\t.need_fix_class_id = true,\n\t.ops = &mtk_pcie_ops_v2,\n\t.startup = mtk_pcie_startup_port_v2,\n\t.setup_irq = mtk_pcie_setup_irq,\n};\n\nstatic const struct mtk_pcie_soc mtk_pcie_soc_mt7629 = {\n\t.need_fix_class_id = true,\n\t.need_fix_device_id = true,\n\t.device_id = PCI_DEVICE_ID_MEDIATEK_7629,\n\t.ops = &mtk_pcie_ops_v2,\n\t.startup = mtk_pcie_startup_port_v2,\n\t.setup_irq = mtk_pcie_setup_irq,\n};\n\nstatic const struct of_device_id mtk_pcie_ids[] = {\n\t{ .compatible = \"mediatek,mt2701-pcie\", .data = &mtk_pcie_soc_v1 },\n\t{ .compatible = \"mediatek,mt7623-pcie\", .data = &mtk_pcie_soc_v1 },\n\t{ .compatible = \"mediatek,mt2712-pcie\", .data = &mtk_pcie_soc_mt2712 },\n\t{ .compatible = \"mediatek,mt7622-pcie\", .data = &mtk_pcie_soc_mt7622 },\n\t{ .compatible = \"mediatek,mt7629-pcie\", .data = &mtk_pcie_soc_mt7629 },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, mtk_pcie_ids);\n\nstatic struct platform_driver mtk_pcie_driver = {\n\t.probe = mtk_pcie_probe,\n\t.remove_new = mtk_pcie_remove,\n\t.driver = {\n\t\t.name = \"mtk-pcie\",\n\t\t.of_match_table = mtk_pcie_ids,\n\t\t.suppress_bind_attrs = true,\n\t\t.pm = &mtk_pcie_pm_ops,\n\t},\n};\nmodule_platform_driver(mtk_pcie_driver);\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}