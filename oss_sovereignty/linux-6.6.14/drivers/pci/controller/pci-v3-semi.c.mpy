{
  "module_name": "pci-v3-semi.c",
  "hash_id": "967cc914aa2298fe4e667ff4450a11f202c1174c4196fe63756e244b2f1207b2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/controller/pci-v3-semi.c",
  "human_readable_source": "\n \n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/of.h>\n#include <linux/of_pci.h>\n#include <linux/pci.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/irq.h>\n#include <linux/mfd/syscon.h>\n#include <linux/regmap.h>\n#include <linux/clk.h>\n\n#include \"../pci.h\"\n\n#define V3_PCI_VENDOR\t\t\t0x00000000\n#define V3_PCI_DEVICE\t\t\t0x00000002\n#define V3_PCI_CMD\t\t\t0x00000004\n#define V3_PCI_STAT\t\t\t0x00000006\n#define V3_PCI_CC_REV\t\t\t0x00000008\n#define V3_PCI_HDR_CFG\t\t\t0x0000000C\n#define V3_PCI_IO_BASE\t\t\t0x00000010\n#define V3_PCI_BASE0\t\t\t0x00000014\n#define V3_PCI_BASE1\t\t\t0x00000018\n#define V3_PCI_SUB_VENDOR\t\t0x0000002C\n#define V3_PCI_SUB_ID\t\t\t0x0000002E\n#define V3_PCI_ROM\t\t\t0x00000030\n#define V3_PCI_BPARAM\t\t\t0x0000003C\n#define V3_PCI_MAP0\t\t\t0x00000040\n#define V3_PCI_MAP1\t\t\t0x00000044\n#define V3_PCI_INT_STAT\t\t\t0x00000048\n#define V3_PCI_INT_CFG\t\t\t0x0000004C\n#define V3_LB_BASE0\t\t\t0x00000054\n#define V3_LB_BASE1\t\t\t0x00000058\n#define V3_LB_MAP0\t\t\t0x0000005E\n#define V3_LB_MAP1\t\t\t0x00000062\n#define V3_LB_BASE2\t\t\t0x00000064\n#define V3_LB_MAP2\t\t\t0x00000066\n#define V3_LB_SIZE\t\t\t0x00000068\n#define V3_LB_IO_BASE\t\t\t0x0000006E\n#define V3_FIFO_CFG\t\t\t0x00000070\n#define V3_FIFO_PRIORITY\t\t0x00000072\n#define V3_FIFO_STAT\t\t\t0x00000074\n#define V3_LB_ISTAT\t\t\t0x00000076\n#define V3_LB_IMASK\t\t\t0x00000077\n#define V3_SYSTEM\t\t\t0x00000078\n#define V3_LB_CFG\t\t\t0x0000007A\n#define V3_PCI_CFG\t\t\t0x0000007C\n#define V3_DMA_PCI_ADR0\t\t\t0x00000080\n#define V3_DMA_PCI_ADR1\t\t\t0x00000090\n#define V3_DMA_LOCAL_ADR0\t\t0x00000084\n#define V3_DMA_LOCAL_ADR1\t\t0x00000094\n#define V3_DMA_LENGTH0\t\t\t0x00000088\n#define V3_DMA_LENGTH1\t\t\t0x00000098\n#define V3_DMA_CSR0\t\t\t0x0000008B\n#define V3_DMA_CSR1\t\t\t0x0000009B\n#define V3_DMA_CTLB_ADR0\t\t0x0000008C\n#define V3_DMA_CTLB_ADR1\t\t0x0000009C\n#define V3_DMA_DELAY\t\t\t0x000000E0\n#define V3_MAIL_DATA\t\t\t0x000000C0\n#define V3_PCI_MAIL_IEWR\t\t0x000000D0\n#define V3_PCI_MAIL_IERD\t\t0x000000D2\n#define V3_LB_MAIL_IEWR\t\t\t0x000000D4\n#define V3_LB_MAIL_IERD\t\t\t0x000000D6\n#define V3_MAIL_WR_STAT\t\t\t0x000000D8\n#define V3_MAIL_RD_STAT\t\t\t0x000000DA\n#define V3_QBA_MAP\t\t\t0x000000DC\n\n \n#define V3_PCI_STAT_PAR_ERR\t\tBIT(15)\n#define V3_PCI_STAT_SYS_ERR\t\tBIT(14)\n#define V3_PCI_STAT_M_ABORT_ERR\t\tBIT(13)\n#define V3_PCI_STAT_T_ABORT_ERR\t\tBIT(12)\n\n \n#define V3_LB_ISTAT_MAILBOX\t\tBIT(7)\n#define V3_LB_ISTAT_PCI_RD\t\tBIT(6)\n#define V3_LB_ISTAT_PCI_WR\t\tBIT(5)\n#define V3_LB_ISTAT_PCI_INT\t\tBIT(4)\n#define V3_LB_ISTAT_PCI_PERR\t\tBIT(3)\n#define V3_LB_ISTAT_I2O_QWR\t\tBIT(2)\n#define V3_LB_ISTAT_DMA1\t\tBIT(1)\n#define V3_LB_ISTAT_DMA0\t\tBIT(0)\n\n \n#define V3_COMMAND_M_FBB_EN\t\tBIT(9)\n#define V3_COMMAND_M_SERR_EN\t\tBIT(8)\n#define V3_COMMAND_M_PAR_EN\t\tBIT(6)\n#define V3_COMMAND_M_MASTER_EN\t\tBIT(2)\n#define V3_COMMAND_M_MEM_EN\t\tBIT(1)\n#define V3_COMMAND_M_IO_EN\t\tBIT(0)\n\n \n#define V3_SYSTEM_M_RST_OUT\t\tBIT(15)\n#define V3_SYSTEM_M_LOCK\t\tBIT(14)\n#define V3_SYSTEM_UNLOCK\t\t0xa05f\n\n \n#define V3_PCI_CFG_M_I2O_EN\t\tBIT(15)\n#define V3_PCI_CFG_M_IO_REG_DIS\t\tBIT(14)\n#define V3_PCI_CFG_M_IO_DIS\t\tBIT(13)\n#define V3_PCI_CFG_M_EN3V\t\tBIT(12)\n#define V3_PCI_CFG_M_RETRY_EN\t\tBIT(10)\n#define V3_PCI_CFG_M_AD_LOW1\t\tBIT(9)\n#define V3_PCI_CFG_M_AD_LOW0\t\tBIT(8)\n \n#define V3_PCI_CFG_M_RTYPE_SHIFT\t5\n#define V3_PCI_CFG_M_WTYPE_SHIFT\t1\n#define V3_PCI_CFG_TYPE_DEFAULT\t\t0x3\n\n \n#define V3_PCI_BASE_M_ADR_BASE\t\t0xFFF00000U\n#define V3_PCI_BASE_M_ADR_BASEL\t\t0x000FFF00U\n#define V3_PCI_BASE_M_PREFETCH\t\tBIT(3)\n#define V3_PCI_BASE_M_TYPE\t\t(3 << 1)\n#define V3_PCI_BASE_M_IO\t\tBIT(0)\n\n \n#define V3_PCI_MAP_M_MAP_ADR\t\t0xFFF00000U\n#define V3_PCI_MAP_M_RD_POST_INH\tBIT(15)\n#define V3_PCI_MAP_M_ROM_SIZE\t\t(3 << 10)\n#define V3_PCI_MAP_M_SWAP\t\t(3 << 8)\n#define V3_PCI_MAP_M_ADR_SIZE\t\t0x000000F0U\n#define V3_PCI_MAP_M_REG_EN\t\tBIT(1)\n#define V3_PCI_MAP_M_ENABLE\t\tBIT(0)\n\n \n#define V3_LB_BASE_ADR_BASE\t\t0xfff00000U\n#define V3_LB_BASE_SWAP\t\t\t(3 << 8)\n#define V3_LB_BASE_ADR_SIZE\t\t(15 << 4)\n#define V3_LB_BASE_PREFETCH\t\tBIT(3)\n#define V3_LB_BASE_ENABLE\t\tBIT(0)\n\n#define V3_LB_BASE_ADR_SIZE_1MB\t\t(0 << 4)\n#define V3_LB_BASE_ADR_SIZE_2MB\t\t(1 << 4)\n#define V3_LB_BASE_ADR_SIZE_4MB\t\t(2 << 4)\n#define V3_LB_BASE_ADR_SIZE_8MB\t\t(3 << 4)\n#define V3_LB_BASE_ADR_SIZE_16MB\t(4 << 4)\n#define V3_LB_BASE_ADR_SIZE_32MB\t(5 << 4)\n#define V3_LB_BASE_ADR_SIZE_64MB\t(6 << 4)\n#define V3_LB_BASE_ADR_SIZE_128MB\t(7 << 4)\n#define V3_LB_BASE_ADR_SIZE_256MB\t(8 << 4)\n#define V3_LB_BASE_ADR_SIZE_512MB\t(9 << 4)\n#define V3_LB_BASE_ADR_SIZE_1GB\t\t(10 << 4)\n#define V3_LB_BASE_ADR_SIZE_2GB\t\t(11 << 4)\n\n#define v3_addr_to_lb_base(a)\t((a) & V3_LB_BASE_ADR_BASE)\n\n \n#define V3_LB_MAP_MAP_ADR\t\t0xfff0U\n#define V3_LB_MAP_TYPE\t\t\t(7 << 1)\n#define V3_LB_MAP_AD_LOW_EN\t\tBIT(0)\n\n#define V3_LB_MAP_TYPE_IACK\t\t(0 << 1)\n#define V3_LB_MAP_TYPE_IO\t\t(1 << 1)\n#define V3_LB_MAP_TYPE_MEM\t\t(3 << 1)\n#define V3_LB_MAP_TYPE_CONFIG\t\t(5 << 1)\n#define V3_LB_MAP_TYPE_MEM_MULTIPLE\t(6 << 1)\n\n#define v3_addr_to_lb_map(a)\t(((a) >> 16) & V3_LB_MAP_MAP_ADR)\n\n \n#define V3_LB_BASE2_ADR_BASE\t\t0xff00U\n#define V3_LB_BASE2_SWAP_AUTO\t\t(3 << 6)\n#define V3_LB_BASE2_ENABLE\t\tBIT(0)\n\n#define v3_addr_to_lb_base2(a)\t(((a) >> 16) & V3_LB_BASE2_ADR_BASE)\n\n \n#define V3_LB_MAP2_MAP_ADR\t\t0xff00U\n\n#define v3_addr_to_lb_map2(a)\t(((a) >> 16) & V3_LB_MAP2_MAP_ADR)\n\n \n#define V3_FIFO_PRIO_LOCAL\t\tBIT(12)\n#define V3_FIFO_PRIO_LB_RD1_FLUSH_EOB\tBIT(10)\n#define V3_FIFO_PRIO_LB_RD1_FLUSH_AP1\tBIT(11)\n#define V3_FIFO_PRIO_LB_RD1_FLUSH_ANY\t(BIT(10)|BIT(11))\n#define V3_FIFO_PRIO_LB_RD0_FLUSH_EOB\tBIT(8)\n#define V3_FIFO_PRIO_LB_RD0_FLUSH_AP1\tBIT(9)\n#define V3_FIFO_PRIO_LB_RD0_FLUSH_ANY\t(BIT(8)|BIT(9))\n#define V3_FIFO_PRIO_PCI\t\tBIT(4)\n#define V3_FIFO_PRIO_PCI_RD1_FLUSH_EOB\tBIT(2)\n#define V3_FIFO_PRIO_PCI_RD1_FLUSH_AP1\tBIT(3)\n#define V3_FIFO_PRIO_PCI_RD1_FLUSH_ANY\t(BIT(2)|BIT(3))\n#define V3_FIFO_PRIO_PCI_RD0_FLUSH_EOB\tBIT(0)\n#define V3_FIFO_PRIO_PCI_RD0_FLUSH_AP1\tBIT(1)\n#define V3_FIFO_PRIO_PCI_RD0_FLUSH_ANY\t(BIT(0)|BIT(1))\n\n \n#define V3_LB_CFG_LB_TO_64_CYCLES\t0x0000\n#define V3_LB_CFG_LB_TO_256_CYCLES\tBIT(13)\n#define V3_LB_CFG_LB_TO_512_CYCLES\tBIT(14)\n#define V3_LB_CFG_LB_TO_1024_CYCLES\t(BIT(13)|BIT(14))\n#define V3_LB_CFG_LB_RST\t\tBIT(12)\n#define V3_LB_CFG_LB_PPC_RDY\t\tBIT(11)\n#define V3_LB_CFG_LB_LB_INT\t\tBIT(10)\n#define V3_LB_CFG_LB_ERR_EN\t\tBIT(9)\n#define V3_LB_CFG_LB_RDY_EN\t\tBIT(8)\n#define V3_LB_CFG_LB_BE_IMODE\t\tBIT(7)\n#define V3_LB_CFG_LB_BE_OMODE\t\tBIT(6)\n#define V3_LB_CFG_LB_ENDIAN\t\tBIT(5)\n#define V3_LB_CFG_LB_PARK_EN\t\tBIT(4)\n#define V3_LB_CFG_LB_FBB_DIS\t\tBIT(2)\n\n \n#define INTEGRATOR_SC_PCI_OFFSET\t0x18\n#define INTEGRATOR_SC_PCI_ENABLE\tBIT(0)\n#define INTEGRATOR_SC_PCI_INTCLR\tBIT(1)\n#define INTEGRATOR_SC_LBFADDR_OFFSET\t0x20\n#define INTEGRATOR_SC_LBFCODE_OFFSET\t0x24\n\nstruct v3_pci {\n\tstruct device *dev;\n\tvoid __iomem *base;\n\tvoid __iomem *config_base;\n\tu32 config_mem;\n\tu32 non_pre_mem;\n\tu32 pre_mem;\n\tphys_addr_t non_pre_bus_addr;\n\tphys_addr_t pre_bus_addr;\n\tstruct regmap *map;\n};\n\n \nstatic void __iomem *v3_map_bus(struct pci_bus *bus,\n\t\t\t\tunsigned int devfn, int offset)\n{\n\tstruct v3_pci *v3 = bus->sysdata;\n\tunsigned int address, mapaddress, busnr;\n\n\tbusnr = bus->number;\n\tif (busnr == 0) {\n\t\tint slot = PCI_SLOT(devfn);\n\n\t\t \n\t\taddress = PCI_FUNC(devfn) << 8;\n\t\tmapaddress = V3_LB_MAP_TYPE_CONFIG;\n\n\t\tif (slot > 12)\n\t\t\t \n\t\t\tmapaddress |= BIT(slot - 5);\n\t\telse\n\t\t\t \n\t\t\taddress |= BIT(slot + 11);\n\t} else {\n\t\t \n\t\tmapaddress = V3_LB_MAP_TYPE_CONFIG | V3_LB_MAP_AD_LOW_EN;\n\t\taddress = (busnr << 16) | (devfn << 8);\n\t}\n\n\t \n\twritel(v3_addr_to_lb_base(v3->non_pre_mem) |\n\t       V3_LB_BASE_ADR_SIZE_512MB | V3_LB_BASE_ENABLE,\n\t       v3->base + V3_LB_BASE0);\n\n\t \n\twritel(v3_addr_to_lb_base(v3->config_mem) |\n\t       V3_LB_BASE_ADR_SIZE_16MB | V3_LB_BASE_ENABLE,\n\t       v3->base + V3_LB_BASE1);\n\twritew(mapaddress, v3->base + V3_LB_MAP1);\n\n\treturn v3->config_base + address + offset;\n}\n\nstatic void v3_unmap_bus(struct v3_pci *v3)\n{\n\t \n\twritel(v3_addr_to_lb_base(v3->pre_mem) |\n\t       V3_LB_BASE_ADR_SIZE_256MB | V3_LB_BASE_PREFETCH |\n\t       V3_LB_BASE_ENABLE,\n\t       v3->base + V3_LB_BASE1);\n\twritew(v3_addr_to_lb_map(v3->pre_bus_addr) |\n\t       V3_LB_MAP_TYPE_MEM,  \n\t       v3->base + V3_LB_MAP1);\n\n\t \n\twritel(v3_addr_to_lb_base(v3->non_pre_mem) |\n\t       V3_LB_BASE_ADR_SIZE_256MB | V3_LB_BASE_ENABLE,\n\t       v3->base + V3_LB_BASE0);\n}\n\nstatic int v3_pci_read_config(struct pci_bus *bus, unsigned int fn,\n\t\t\t      int config, int size, u32 *value)\n{\n\tstruct v3_pci *v3 = bus->sysdata;\n\tint ret;\n\n\tdev_dbg(&bus->dev,\n\t\t\"[read]  slt: %.2d, fnc: %d, cnf: 0x%.2X, val (%d bytes): 0x%.8X\\n\",\n\t\tPCI_SLOT(fn), PCI_FUNC(fn), config, size, *value);\n\tret = pci_generic_config_read(bus, fn, config, size, value);\n\tv3_unmap_bus(v3);\n\treturn ret;\n}\n\nstatic int v3_pci_write_config(struct pci_bus *bus, unsigned int fn,\n\t\t\t\t    int config, int size, u32 value)\n{\n\tstruct v3_pci *v3 = bus->sysdata;\n\tint ret;\n\n\tdev_dbg(&bus->dev,\n\t\t\"[write] slt: %.2d, fnc: %d, cnf: 0x%.2X, val (%d bytes): 0x%.8X\\n\",\n\t\tPCI_SLOT(fn), PCI_FUNC(fn), config, size, value);\n\tret = pci_generic_config_write(bus, fn, config, size, value);\n\tv3_unmap_bus(v3);\n\treturn ret;\n}\n\nstatic struct pci_ops v3_pci_ops = {\n\t.map_bus = v3_map_bus,\n\t.read = v3_pci_read_config,\n\t.write = v3_pci_write_config,\n};\n\nstatic irqreturn_t v3_irq(int irq, void *data)\n{\n\tstruct v3_pci *v3 = data;\n\tstruct device *dev = v3->dev;\n\tu32 status;\n\n\tstatus = readw(v3->base + V3_PCI_STAT);\n\tif (status & V3_PCI_STAT_PAR_ERR)\n\t\tdev_err(dev, \"parity error interrupt\\n\");\n\tif (status & V3_PCI_STAT_SYS_ERR)\n\t\tdev_err(dev, \"system error interrupt\\n\");\n\tif (status & V3_PCI_STAT_M_ABORT_ERR)\n\t\tdev_err(dev, \"master abort error interrupt\\n\");\n\tif (status & V3_PCI_STAT_T_ABORT_ERR)\n\t\tdev_err(dev, \"target abort error interrupt\\n\");\n\twritew(status, v3->base + V3_PCI_STAT);\n\n\tstatus = readb(v3->base + V3_LB_ISTAT);\n\tif (status & V3_LB_ISTAT_MAILBOX)\n\t\tdev_info(dev, \"PCI mailbox interrupt\\n\");\n\tif (status & V3_LB_ISTAT_PCI_RD)\n\t\tdev_err(dev, \"PCI target LB->PCI READ abort interrupt\\n\");\n\tif (status & V3_LB_ISTAT_PCI_WR)\n\t\tdev_err(dev, \"PCI target LB->PCI WRITE abort interrupt\\n\");\n\tif (status &  V3_LB_ISTAT_PCI_INT)\n\t\tdev_info(dev, \"PCI pin interrupt\\n\");\n\tif (status & V3_LB_ISTAT_PCI_PERR)\n\t\tdev_err(dev, \"PCI parity error interrupt\\n\");\n\tif (status & V3_LB_ISTAT_I2O_QWR)\n\t\tdev_info(dev, \"I2O inbound post queue interrupt\\n\");\n\tif (status & V3_LB_ISTAT_DMA1)\n\t\tdev_info(dev, \"DMA channel 1 interrupt\\n\");\n\tif (status & V3_LB_ISTAT_DMA0)\n\t\tdev_info(dev, \"DMA channel 0 interrupt\\n\");\n\t \n\twriteb(0, v3->base + V3_LB_ISTAT);\n\tif (v3->map)\n\t\tregmap_write(v3->map, INTEGRATOR_SC_PCI_OFFSET,\n\t\t\t     INTEGRATOR_SC_PCI_ENABLE |\n\t\t\t     INTEGRATOR_SC_PCI_INTCLR);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int v3_integrator_init(struct v3_pci *v3)\n{\n\tunsigned int val;\n\n\tv3->map =\n\t\tsyscon_regmap_lookup_by_compatible(\"arm,integrator-ap-syscon\");\n\tif (IS_ERR(v3->map)) {\n\t\tdev_err(v3->dev, \"no syscon\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tregmap_read(v3->map, INTEGRATOR_SC_PCI_OFFSET, &val);\n\t \n\tregmap_write(v3->map, INTEGRATOR_SC_PCI_OFFSET,\n\t\t     INTEGRATOR_SC_PCI_ENABLE |\n\t\t     INTEGRATOR_SC_PCI_INTCLR);\n\n\tif (!(val & INTEGRATOR_SC_PCI_ENABLE)) {\n\t\t \n\t\tmsleep(230);\n\n\t\t \n\t\twritel(0x6200, v3->base + V3_LB_IO_BASE);\n\n\t\t \n\t\tdo {\n\t\t\twriteb(0xaa, v3->base + V3_MAIL_DATA);\n\t\t\twriteb(0x55, v3->base + V3_MAIL_DATA + 4);\n\t\t} while (readb(v3->base + V3_MAIL_DATA) != 0xaa &&\n\t\t\t readb(v3->base + V3_MAIL_DATA) != 0x55);\n\t}\n\n\tdev_info(v3->dev, \"initialized PCI V3 Integrator/AP integration\\n\");\n\n\treturn 0;\n}\n\nstatic int v3_pci_setup_resource(struct v3_pci *v3,\n\t\t\t\t struct pci_host_bridge *host,\n\t\t\t\t struct resource_entry *win)\n{\n\tstruct device *dev = v3->dev;\n\tstruct resource *mem;\n\tstruct resource *io;\n\n\tswitch (resource_type(win->res)) {\n\tcase IORESOURCE_IO:\n\t\tio = win->res;\n\n\t\t \n\t\twritel(v3_addr_to_lb_base2(pci_pio_to_address(io->start)) |\n\t\t       V3_LB_BASE2_ENABLE,\n\t\t       v3->base + V3_LB_BASE2);\n\t\twritew(v3_addr_to_lb_map2(io->start - win->offset),\n\t\t       v3->base + V3_LB_MAP2);\n\t\tbreak;\n\tcase IORESOURCE_MEM:\n\t\tmem = win->res;\n\t\tif (mem->flags & IORESOURCE_PREFETCH) {\n\t\t\tmem->name = \"V3 PCI PRE-MEM\";\n\t\t\tv3->pre_mem = mem->start;\n\t\t\tv3->pre_bus_addr = mem->start - win->offset;\n\t\t\tdev_dbg(dev, \"PREFETCHABLE MEM window %pR, bus addr %pap\\n\",\n\t\t\t\tmem, &v3->pre_bus_addr);\n\t\t\tif (resource_size(mem) != SZ_256M) {\n\t\t\t\tdev_err(dev, \"prefetchable memory range is not 256MB\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (v3->non_pre_mem &&\n\t\t\t    (mem->start != v3->non_pre_mem + SZ_256M)) {\n\t\t\t\tdev_err(dev,\n\t\t\t\t\t\"prefetchable memory is not adjacent to non-prefetchable memory\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\t \n\t\t\twritel(v3_addr_to_lb_base(v3->pre_mem) |\n\t\t\t       V3_LB_BASE_ADR_SIZE_256MB |\n\t\t\t       V3_LB_BASE_PREFETCH |\n\t\t\t       V3_LB_BASE_ENABLE,\n\t\t\t       v3->base + V3_LB_BASE1);\n\t\t\twritew(v3_addr_to_lb_map(v3->pre_bus_addr) |\n\t\t\t       V3_LB_MAP_TYPE_MEM,  \n\t\t\t       v3->base + V3_LB_MAP1);\n\t\t} else {\n\t\t\tmem->name = \"V3 PCI NON-PRE-MEM\";\n\t\t\tv3->non_pre_mem = mem->start;\n\t\t\tv3->non_pre_bus_addr = mem->start - win->offset;\n\t\t\tdev_dbg(dev, \"NON-PREFETCHABLE MEM window %pR, bus addr %pap\\n\",\n\t\t\t\tmem, &v3->non_pre_bus_addr);\n\t\t\tif (resource_size(mem) != SZ_256M) {\n\t\t\t\tdev_err(dev,\n\t\t\t\t\t\"non-prefetchable memory range is not 256MB\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\t \n\t\t\twritel(v3_addr_to_lb_base(v3->non_pre_mem) |\n\t\t\t       V3_LB_BASE_ADR_SIZE_256MB |\n\t\t\t       V3_LB_BASE_ENABLE,\n\t\t\t       v3->base + V3_LB_BASE0);\n\t\t\twritew(v3_addr_to_lb_map(v3->non_pre_bus_addr) |\n\t\t\t       V3_LB_MAP_TYPE_MEM,\n\t\t\t       v3->base + V3_LB_MAP0);\n\t\t}\n\t\tbreak;\n\tcase IORESOURCE_BUS:\n\t\tbreak;\n\tdefault:\n\t\tdev_info(dev, \"Unknown resource type %lu\\n\",\n\t\t\t resource_type(win->res));\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int v3_get_dma_range_config(struct v3_pci *v3,\n\t\t\t\t   struct resource_entry *entry,\n\t\t\t\t   u32 *pci_base, u32 *pci_map)\n{\n\tstruct device *dev = v3->dev;\n\tu64 cpu_addr = entry->res->start;\n\tu64 cpu_end = entry->res->end;\n\tu64 pci_end = cpu_end - entry->offset;\n\tu64 pci_addr = entry->res->start - entry->offset;\n\tu32 val;\n\n\tif (pci_addr & ~V3_PCI_BASE_M_ADR_BASE) {\n\t\tdev_err(dev, \"illegal range, only PCI bits 31..20 allowed\\n\");\n\t\treturn -EINVAL;\n\t}\n\tval = ((u32)pci_addr) & V3_PCI_BASE_M_ADR_BASE;\n\t*pci_base = val;\n\n\tif (cpu_addr & ~V3_PCI_MAP_M_MAP_ADR) {\n\t\tdev_err(dev, \"illegal range, only CPU bits 31..20 allowed\\n\");\n\t\treturn -EINVAL;\n\t}\n\tval = ((u32)cpu_addr) & V3_PCI_MAP_M_MAP_ADR;\n\n\tswitch (resource_size(entry->res)) {\n\tcase SZ_1M:\n\t\tval |= V3_LB_BASE_ADR_SIZE_1MB;\n\t\tbreak;\n\tcase SZ_2M:\n\t\tval |= V3_LB_BASE_ADR_SIZE_2MB;\n\t\tbreak;\n\tcase SZ_4M:\n\t\tval |= V3_LB_BASE_ADR_SIZE_4MB;\n\t\tbreak;\n\tcase SZ_8M:\n\t\tval |= V3_LB_BASE_ADR_SIZE_8MB;\n\t\tbreak;\n\tcase SZ_16M:\n\t\tval |= V3_LB_BASE_ADR_SIZE_16MB;\n\t\tbreak;\n\tcase SZ_32M:\n\t\tval |= V3_LB_BASE_ADR_SIZE_32MB;\n\t\tbreak;\n\tcase SZ_64M:\n\t\tval |= V3_LB_BASE_ADR_SIZE_64MB;\n\t\tbreak;\n\tcase SZ_128M:\n\t\tval |= V3_LB_BASE_ADR_SIZE_128MB;\n\t\tbreak;\n\tcase SZ_256M:\n\t\tval |= V3_LB_BASE_ADR_SIZE_256MB;\n\t\tbreak;\n\tcase SZ_512M:\n\t\tval |= V3_LB_BASE_ADR_SIZE_512MB;\n\t\tbreak;\n\tcase SZ_1G:\n\t\tval |= V3_LB_BASE_ADR_SIZE_1GB;\n\t\tbreak;\n\tcase SZ_2G:\n\t\tval |= V3_LB_BASE_ADR_SIZE_2GB;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(v3->dev, \"illegal dma memory chunk size\\n\");\n\t\treturn -EINVAL;\n\t}\n\tval |= V3_PCI_MAP_M_REG_EN | V3_PCI_MAP_M_ENABLE;\n\t*pci_map = val;\n\n\tdev_dbg(dev,\n\t\t\"DMA MEM CPU: 0x%016llx -> 0x%016llx => \"\n\t\t\"PCI: 0x%016llx -> 0x%016llx base %08x map %08x\\n\",\n\t\tcpu_addr, cpu_end,\n\t\tpci_addr, pci_end,\n\t\t*pci_base, *pci_map);\n\n\treturn 0;\n}\n\nstatic int v3_pci_parse_map_dma_ranges(struct v3_pci *v3,\n\t\t\t\t       struct device_node *np)\n{\n\tstruct pci_host_bridge *bridge = pci_host_bridge_from_priv(v3);\n\tstruct device *dev = v3->dev;\n\tstruct resource_entry *entry;\n\tint i = 0;\n\n\tresource_list_for_each_entry(entry, &bridge->dma_ranges) {\n\t\tint ret;\n\t\tu32 pci_base, pci_map;\n\n\t\tret = v3_get_dma_range_config(v3, entry, &pci_base, &pci_map);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (i == 0) {\n\t\t\twritel(pci_base, v3->base + V3_PCI_BASE0);\n\t\t\twritel(pci_map, v3->base + V3_PCI_MAP0);\n\t\t} else if (i == 1) {\n\t\t\twritel(pci_base, v3->base + V3_PCI_BASE1);\n\t\t\twritel(pci_map, v3->base + V3_PCI_MAP1);\n\t\t} else {\n\t\t\tdev_err(dev, \"too many ranges, only two supported\\n\");\n\t\t\tdev_err(dev, \"range %d ignored\\n\", i);\n\t\t}\n\t\ti++;\n\t}\n\treturn 0;\n}\n\nstatic int v3_pci_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct resource *regs;\n\tstruct resource_entry *win;\n\tstruct v3_pci *v3;\n\tstruct pci_host_bridge *host;\n\tstruct clk *clk;\n\tu16 val;\n\tint irq;\n\tint ret;\n\n\thost = devm_pci_alloc_host_bridge(dev, sizeof(*v3));\n\tif (!host)\n\t\treturn -ENOMEM;\n\n\thost->ops = &v3_pci_ops;\n\tv3 = pci_host_bridge_priv(host);\n\thost->sysdata = v3;\n\tv3->dev = dev;\n\n\t \n\tclk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(clk)) {\n\t\tdev_err(dev, \"clock not found\\n\");\n\t\treturn PTR_ERR(clk);\n\t}\n\tret = clk_prepare_enable(clk);\n\tif (ret) {\n\t\tdev_err(dev, \"unable to enable clock\\n\");\n\t\treturn ret;\n\t}\n\n\tv3->base = devm_platform_get_and_ioremap_resource(pdev, 0, &regs);\n\tif (IS_ERR(v3->base))\n\t\treturn PTR_ERR(v3->base);\n\t \n\tif (readl(v3->base + V3_LB_IO_BASE) != (regs->start >> 16))\n\t\tdev_err(dev, \"V3_LB_IO_BASE = %08x but device is @%pR\\n\",\n\t\t\treadl(v3->base + V3_LB_IO_BASE), regs);\n\n\t \n\tregs = platform_get_resource(pdev, IORESOURCE_MEM, 1);\n\tif (resource_size(regs) != SZ_16M) {\n\t\tdev_err(dev, \"config mem is not 16MB!\\n\");\n\t\treturn -EINVAL;\n\t}\n\tv3->config_mem = regs->start;\n\tv3->config_base = devm_ioremap_resource(dev, regs);\n\tif (IS_ERR(v3->config_base))\n\t\treturn PTR_ERR(v3->config_base);\n\n\t \n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tret = devm_request_irq(dev, irq, v3_irq, 0,\n\t\t\t\"PCIv3 error\", v3);\n\tif (ret < 0) {\n\t\tdev_err(dev,\n\t\t\t\"unable to request PCIv3 error IRQ %d (%d)\\n\",\n\t\t\tirq, ret);\n\t\treturn ret;\n\t}\n\n\t \n\tif (readw(v3->base + V3_SYSTEM) & V3_SYSTEM_M_LOCK)\n\t\twritew(V3_SYSTEM_UNLOCK, v3->base + V3_SYSTEM);\n\n\t \n\tval = readw(v3->base + V3_PCI_CMD);\n\tval &= ~(PCI_COMMAND_IO | PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER);\n\twritew(val, v3->base + V3_PCI_CMD);\n\n\t \n\tval = readw(v3->base + V3_SYSTEM);\n\tval &= ~V3_SYSTEM_M_RST_OUT;\n\twritew(val, v3->base + V3_SYSTEM);\n\n\t \n\tval = readw(v3->base + V3_PCI_CFG);\n\tval |= V3_PCI_CFG_M_RETRY_EN;\n\twritew(val, v3->base + V3_PCI_CFG);\n\n\t \n\tval = readw(v3->base + V3_LB_CFG);\n\tval |= V3_LB_CFG_LB_BE_IMODE;  \n\tval |= V3_LB_CFG_LB_BE_OMODE;  \n\tval &= ~V3_LB_CFG_LB_ENDIAN;  \n\tval &= ~V3_LB_CFG_LB_PPC_RDY;  \n\twritew(val, v3->base + V3_LB_CFG);\n\n\t \n\tval = readw(v3->base + V3_PCI_CMD);\n\tval |= PCI_COMMAND_MASTER;\n\twritew(val, v3->base + V3_PCI_CMD);\n\n\t \n\tresource_list_for_each_entry(win, &host->windows) {\n\t\tret = v3_pci_setup_resource(v3, host, win);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"error setting up resources\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\tret = v3_pci_parse_map_dma_ranges(v3, np);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\twritel(0x00000000, v3->base + V3_PCI_IO_BASE);\n\tval = V3_PCI_CFG_M_IO_REG_DIS | V3_PCI_CFG_M_IO_DIS |\n\t\tV3_PCI_CFG_M_EN3V | V3_PCI_CFG_M_AD_LOW0;\n\t \n\tval |=  V3_PCI_CFG_TYPE_DEFAULT << V3_PCI_CFG_M_RTYPE_SHIFT;\n\tval |=  V3_PCI_CFG_TYPE_DEFAULT << V3_PCI_CFG_M_WTYPE_SHIFT;\n\twritew(val, v3->base + V3_PCI_CFG);\n\n\t \n\twritew(V3_FIFO_PRIO_LB_RD1_FLUSH_AP1 |\n\t       V3_FIFO_PRIO_LB_RD0_FLUSH_AP1 |\n\t       V3_FIFO_PRIO_PCI_RD1_FLUSH_AP1 |\n\t       V3_FIFO_PRIO_PCI_RD0_FLUSH_AP1,\n\t       v3->base + V3_FIFO_PRIORITY);\n\n\n\t \n\twriteb(0, v3->base + V3_LB_ISTAT);\n\tval = readw(v3->base + V3_LB_CFG);\n\tval |= V3_LB_CFG_LB_LB_INT;\n\twritew(val, v3->base + V3_LB_CFG);\n\twriteb(V3_LB_ISTAT_PCI_WR | V3_LB_ISTAT_PCI_PERR,\n\t       v3->base + V3_LB_IMASK);\n\n\t \n\tif (of_device_is_compatible(np, \"arm,integrator-ap-pci\")) {\n\t\tret = v3_integrator_init(v3);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tval = readw(v3->base + V3_PCI_CMD);\n\tval |= PCI_COMMAND_MEMORY | PCI_COMMAND_INVALIDATE;\n\twritew(val, v3->base + V3_PCI_CMD);\n\n\t \n\twriteb(0, v3->base + V3_LB_ISTAT);\n\t \n\twriteb(V3_LB_ISTAT_PCI_RD | V3_LB_ISTAT_PCI_WR | V3_LB_ISTAT_PCI_PERR,\n\t       v3->base + V3_LB_IMASK);\n\n\t \n\tval = readw(v3->base + V3_SYSTEM);\n\tval |= V3_SYSTEM_M_RST_OUT;\n\twritew(val, v3->base + V3_SYSTEM);\n\n\t \n\tval = readw(v3->base + V3_SYSTEM);\n\tval |= V3_SYSTEM_M_LOCK;\n\twritew(val, v3->base + V3_SYSTEM);\n\n\treturn pci_host_probe(host);\n}\n\nstatic const struct of_device_id v3_pci_of_match[] = {\n\t{\n\t\t.compatible = \"v3,v360epc-pci\",\n\t},\n\t{},\n};\n\nstatic struct platform_driver v3_pci_driver = {\n\t.driver = {\n\t\t.name = \"pci-v3-semi\",\n\t\t.of_match_table = v3_pci_of_match,\n\t\t.suppress_bind_attrs = true,\n\t},\n\t.probe  = v3_pci_probe,\n};\nbuiltin_platform_driver(v3_pci_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}