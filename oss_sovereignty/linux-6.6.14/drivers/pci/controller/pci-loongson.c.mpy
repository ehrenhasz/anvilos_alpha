{
  "module_name": "pci-loongson.c",
  "hash_id": "2c9806845184826a02a9f270706eefc4a4c8a585386a26869661a91e95eb6c52",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/controller/pci-loongson.c",
  "human_readable_source": "\n \n\n#include <linux/of.h>\n#include <linux/of_pci.h>\n#include <linux/pci.h>\n#include <linux/pci_ids.h>\n#include <linux/pci-acpi.h>\n#include <linux/pci-ecam.h>\n\n#include \"../pci.h\"\n\n \n#define DEV_LS2K_PCIE_PORT0\t0x1a05\n#define DEV_LS7A_PCIE_PORT0\t0x7a09\n#define DEV_LS7A_PCIE_PORT1\t0x7a19\n#define DEV_LS7A_PCIE_PORT2\t0x7a29\n#define DEV_LS7A_PCIE_PORT3\t0x7a39\n#define DEV_LS7A_PCIE_PORT4\t0x7a49\n#define DEV_LS7A_PCIE_PORT5\t0x7a59\n#define DEV_LS7A_PCIE_PORT6\t0x7a69\n\n#define DEV_LS2K_APB\t0x7a02\n#define DEV_LS7A_GMAC\t0x7a03\n#define DEV_LS7A_DC1\t0x7a06\n#define DEV_LS7A_LPC\t0x7a0c\n#define DEV_LS7A_AHCI\t0x7a08\n#define DEV_LS7A_CONF\t0x7a10\n#define DEV_LS7A_GNET\t0x7a13\n#define DEV_LS7A_EHCI\t0x7a14\n#define DEV_LS7A_DC2\t0x7a36\n#define DEV_LS7A_HDMI\t0x7a37\n\n#define FLAG_CFG0\tBIT(0)\n#define FLAG_CFG1\tBIT(1)\n#define FLAG_DEV_FIX\tBIT(2)\n#define FLAG_DEV_HIDDEN\tBIT(3)\n\nstruct loongson_pci_data {\n\tu32 flags;\n\tstruct pci_ops *ops;\n};\n\nstruct loongson_pci {\n\tvoid __iomem *cfg0_base;\n\tvoid __iomem *cfg1_base;\n\tstruct platform_device *pdev;\n\tconst struct loongson_pci_data *data;\n};\n\n \nstatic void bridge_class_quirk(struct pci_dev *dev)\n{\n\tdev->class = PCI_CLASS_BRIDGE_PCI_NORMAL;\n}\nDECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_LOONGSON,\n\t\t\tDEV_LS7A_PCIE_PORT0, bridge_class_quirk);\nDECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_LOONGSON,\n\t\t\tDEV_LS7A_PCIE_PORT1, bridge_class_quirk);\nDECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_LOONGSON,\n\t\t\tDEV_LS7A_PCIE_PORT2, bridge_class_quirk);\n\nstatic void system_bus_quirk(struct pci_dev *pdev)\n{\n\t \n\tpdev->mmio_always_on = 1;\n\tpdev->non_compliant_bars = 1;\n}\nDECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_LOONGSON,\n\t\t\tDEV_LS2K_APB, system_bus_quirk);\nDECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_LOONGSON,\n\t\t\tDEV_LS7A_CONF, system_bus_quirk);\nDECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_LOONGSON,\n\t\t\tDEV_LS7A_LPC, system_bus_quirk);\n\n \n#ifdef CONFIG_MIPS\nstatic void loongson_set_min_mrrs_quirk(struct pci_dev *pdev)\n{\n\tstruct pci_bus *bus = pdev->bus;\n\tstruct pci_dev *bridge;\n\tstatic const struct pci_device_id bridge_devids[] = {\n\t\t{ PCI_VDEVICE(LOONGSON, DEV_LS2K_PCIE_PORT0) },\n\t\t{ PCI_VDEVICE(LOONGSON, DEV_LS7A_PCIE_PORT0) },\n\t\t{ PCI_VDEVICE(LOONGSON, DEV_LS7A_PCIE_PORT1) },\n\t\t{ PCI_VDEVICE(LOONGSON, DEV_LS7A_PCIE_PORT2) },\n\t\t{ PCI_VDEVICE(LOONGSON, DEV_LS7A_PCIE_PORT3) },\n\t\t{ PCI_VDEVICE(LOONGSON, DEV_LS7A_PCIE_PORT4) },\n\t\t{ PCI_VDEVICE(LOONGSON, DEV_LS7A_PCIE_PORT5) },\n\t\t{ PCI_VDEVICE(LOONGSON, DEV_LS7A_PCIE_PORT6) },\n\t\t{ 0, },\n\t};\n\n\t \n\twhile (!pci_is_root_bus(bus)) {\n\t\tbridge = bus->self;\n\t\tbus = bus->parent;\n\n\t\tif (pci_match_id(bridge_devids, bridge)) {\n\t\t\tif (pcie_get_readrq(pdev) > 256) {\n\t\t\t\tpci_info(pdev, \"limiting MRRS to 256\\n\");\n\t\t\t\tpcie_set_readrq(pdev, 256);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n}\nDECLARE_PCI_FIXUP_ENABLE(PCI_ANY_ID, PCI_ANY_ID, loongson_set_min_mrrs_quirk);\n#endif\n\nstatic void loongson_mrrs_quirk(struct pci_dev *pdev)\n{\n\tstruct pci_host_bridge *bridge = pci_find_host_bridge(pdev->bus);\n\n\tbridge->no_inc_mrrs = 1;\n}\nDECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_LOONGSON,\n\t\t\tDEV_LS2K_PCIE_PORT0, loongson_mrrs_quirk);\nDECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_LOONGSON,\n\t\t\tDEV_LS7A_PCIE_PORT0, loongson_mrrs_quirk);\nDECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_LOONGSON,\n\t\t\tDEV_LS7A_PCIE_PORT1, loongson_mrrs_quirk);\nDECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_LOONGSON,\n\t\t\tDEV_LS7A_PCIE_PORT2, loongson_mrrs_quirk);\nDECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_LOONGSON,\n\t\t\tDEV_LS7A_PCIE_PORT3, loongson_mrrs_quirk);\nDECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_LOONGSON,\n\t\t\tDEV_LS7A_PCIE_PORT4, loongson_mrrs_quirk);\nDECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_LOONGSON,\n\t\t\tDEV_LS7A_PCIE_PORT5, loongson_mrrs_quirk);\nDECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_LOONGSON,\n\t\t\tDEV_LS7A_PCIE_PORT6, loongson_mrrs_quirk);\n\nstatic void loongson_pci_pin_quirk(struct pci_dev *pdev)\n{\n\tpdev->pin = 1 + (PCI_FUNC(pdev->devfn) & 3);\n}\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_LOONGSON,\n\t\t\tDEV_LS7A_DC1, loongson_pci_pin_quirk);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_LOONGSON,\n\t\t\tDEV_LS7A_DC2, loongson_pci_pin_quirk);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_LOONGSON,\n\t\t\tDEV_LS7A_GMAC, loongson_pci_pin_quirk);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_LOONGSON,\n\t\t\tDEV_LS7A_AHCI, loongson_pci_pin_quirk);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_LOONGSON,\n\t\t\tDEV_LS7A_EHCI, loongson_pci_pin_quirk);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_LOONGSON,\n\t\t\tDEV_LS7A_GNET, loongson_pci_pin_quirk);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_LOONGSON,\n\t\t\tDEV_LS7A_HDMI, loongson_pci_pin_quirk);\n\nstatic struct loongson_pci *pci_bus_to_loongson_pci(struct pci_bus *bus)\n{\n\tstruct pci_config_window *cfg;\n\n\tif (acpi_disabled)\n\t\treturn (struct loongson_pci *)(bus->sysdata);\n\n\tcfg = bus->sysdata;\n\treturn (struct loongson_pci *)(cfg->priv);\n}\n\nstatic void __iomem *cfg0_map(struct loongson_pci *priv, struct pci_bus *bus,\n\t\t\t      unsigned int devfn, int where)\n{\n\tunsigned long addroff = 0x0;\n\tunsigned char busnum = bus->number;\n\n\tif (!pci_is_root_bus(bus)) {\n\t\taddroff |= BIT(24);  \n\t\taddroff |= (busnum << 16);\n\t}\n\taddroff |= (devfn << 8) | where;\n\treturn priv->cfg0_base + addroff;\n}\n\nstatic void __iomem *cfg1_map(struct loongson_pci *priv, struct pci_bus *bus,\n\t\t\t      unsigned int devfn, int where)\n{\n\tunsigned long addroff = 0x0;\n\tunsigned char busnum = bus->number;\n\n\tif (!pci_is_root_bus(bus)) {\n\t\taddroff |= BIT(28);  \n\t\taddroff |= (busnum << 16);\n\t}\n\taddroff |= (devfn << 8) | (where & 0xff) | ((where & 0xf00) << 16);\n\treturn priv->cfg1_base + addroff;\n}\n\nstatic bool pdev_may_exist(struct pci_bus *bus, unsigned int device,\n\t\t\t   unsigned int function)\n{\n\treturn !(pci_is_root_bus(bus) &&\n\t\t(device >= 9 && device <= 20) && (function > 0));\n}\n\nstatic void __iomem *pci_loongson_map_bus(struct pci_bus *bus,\n\t\t\t\t\t  unsigned int devfn, int where)\n{\n\tunsigned int device = PCI_SLOT(devfn);\n\tunsigned int function = PCI_FUNC(devfn);\n\tstruct loongson_pci *priv = pci_bus_to_loongson_pci(bus);\n\n\t \n\tif ((priv->data->flags & FLAG_DEV_FIX) && bus->self) {\n\t\tif (!pci_is_root_bus(bus) && (device > 0))\n\t\t\treturn NULL;\n\t}\n\n\t \n\tif (priv->data->flags & FLAG_DEV_HIDDEN) {\n\t\tif (!pdev_may_exist(bus, device, function))\n\t\t\treturn NULL;\n\t}\n\n\t \n\tif (where < PCI_CFG_SPACE_SIZE && priv->cfg0_base)\n\t\treturn cfg0_map(priv, bus, devfn, where);\n\n\t \n\tif (where < PCI_CFG_SPACE_EXP_SIZE && priv->cfg1_base)\n\t\treturn cfg1_map(priv, bus, devfn, where);\n\n\treturn NULL;\n}\n\n#ifdef CONFIG_OF\n\nstatic int loongson_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)\n{\n\tint irq;\n\tu8 val;\n\n\tirq = of_irq_parse_and_map_pci(dev, slot, pin);\n\tif (irq > 0)\n\t\treturn irq;\n\n\t \n\tpci_read_config_byte(dev, PCI_INTERRUPT_LINE, &val);\n\t \n\tif (val > 15)\n\t\treturn 0;\n\n\treturn val;\n}\n\n \nstatic struct pci_ops loongson_pci_ops = {\n\t.map_bus = pci_loongson_map_bus,\n\t.read\t= pci_generic_config_read,\n\t.write\t= pci_generic_config_write,\n};\n\n \nstatic struct pci_ops loongson_pci_ops32 = {\n\t.map_bus = pci_loongson_map_bus,\n\t.read\t= pci_generic_config_read32,\n\t.write\t= pci_generic_config_write32,\n};\n\nstatic const struct loongson_pci_data ls2k_pci_data = {\n\t.flags = FLAG_CFG1 | FLAG_DEV_FIX | FLAG_DEV_HIDDEN,\n\t.ops = &loongson_pci_ops,\n};\n\nstatic const struct loongson_pci_data ls7a_pci_data = {\n\t.flags = FLAG_CFG1 | FLAG_DEV_FIX | FLAG_DEV_HIDDEN,\n\t.ops = &loongson_pci_ops,\n};\n\nstatic const struct loongson_pci_data rs780e_pci_data = {\n\t.flags = FLAG_CFG0,\n\t.ops = &loongson_pci_ops32,\n};\n\nstatic const struct of_device_id loongson_pci_of_match[] = {\n\t{ .compatible = \"loongson,ls2k-pci\",\n\t\t.data = &ls2k_pci_data, },\n\t{ .compatible = \"loongson,ls7a-pci\",\n\t\t.data = &ls7a_pci_data, },\n\t{ .compatible = \"loongson,rs780e-pci\",\n\t\t.data = &rs780e_pci_data, },\n\t{}\n};\n\nstatic int loongson_pci_probe(struct platform_device *pdev)\n{\n\tstruct loongson_pci *priv;\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *node = dev->of_node;\n\tstruct pci_host_bridge *bridge;\n\tstruct resource *regs;\n\n\tif (!node)\n\t\treturn -ENODEV;\n\n\tbridge = devm_pci_alloc_host_bridge(dev, sizeof(*priv));\n\tif (!bridge)\n\t\treturn -ENODEV;\n\n\tpriv = pci_host_bridge_priv(bridge);\n\tpriv->pdev = pdev;\n\tpriv->data = of_device_get_match_data(dev);\n\n\tif (priv->data->flags & FLAG_CFG0) {\n\t\tregs = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\t\tif (!regs)\n\t\t\tdev_err(dev, \"missing mem resources for cfg0\\n\");\n\t\telse {\n\t\t\tpriv->cfg0_base = devm_pci_remap_cfg_resource(dev, regs);\n\t\t\tif (IS_ERR(priv->cfg0_base))\n\t\t\t\treturn PTR_ERR(priv->cfg0_base);\n\t\t}\n\t}\n\n\tif (priv->data->flags & FLAG_CFG1) {\n\t\tregs = platform_get_resource(pdev, IORESOURCE_MEM, 1);\n\t\tif (!regs)\n\t\t\tdev_info(dev, \"missing mem resource for cfg1\\n\");\n\t\telse {\n\t\t\tpriv->cfg1_base = devm_pci_remap_cfg_resource(dev, regs);\n\t\t\tif (IS_ERR(priv->cfg1_base))\n\t\t\t\tpriv->cfg1_base = NULL;\n\t\t}\n\t}\n\n\tbridge->sysdata = priv;\n\tbridge->ops = priv->data->ops;\n\tbridge->map_irq = loongson_map_irq;\n\n\treturn pci_host_probe(bridge);\n}\n\nstatic struct platform_driver loongson_pci_driver = {\n\t.driver = {\n\t\t.name = \"loongson-pci\",\n\t\t.of_match_table = loongson_pci_of_match,\n\t},\n\t.probe = loongson_pci_probe,\n};\nbuiltin_platform_driver(loongson_pci_driver);\n\n#endif\n\n#ifdef CONFIG_ACPI\n\nstatic int loongson_pci_ecam_init(struct pci_config_window *cfg)\n{\n\tstruct device *dev = cfg->parent;\n\tstruct loongson_pci *priv;\n\tstruct loongson_pci_data *data;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tdata = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tcfg->priv = priv;\n\tdata->flags = FLAG_CFG1 | FLAG_DEV_HIDDEN;\n\tpriv->data = data;\n\tpriv->cfg1_base = cfg->win - (cfg->busr.start << 16);\n\n\treturn 0;\n}\n\nconst struct pci_ecam_ops loongson_pci_ecam_ops = {\n\t.bus_shift = 16,\n\t.init\t   = loongson_pci_ecam_init,\n\t.pci_ops   = {\n\t\t.map_bus = pci_loongson_map_bus,\n\t\t.read\t = pci_generic_config_read,\n\t\t.write\t = pci_generic_config_write,\n\t}\n};\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}