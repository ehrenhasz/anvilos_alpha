{
  "module_name": "pcie-hisi-error.c",
  "hash_id": "7ebe27139b1772328ec99e505cb33a4a73d52ecece6242c4fb01db818615b9b4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/controller/pcie-hisi-error.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <acpi/ghes.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/pci.h>\n#include <linux/platform_device.h>\n#include <linux/kfifo.h>\n#include <linux/spinlock.h>\n\n \n#define HISI_PCIE_ERR_MISC_REGS\t33\n\n#define HISI_PCIE_LOCAL_VALID_VERSION\t\tBIT(0)\n#define HISI_PCIE_LOCAL_VALID_SOC_ID\t\tBIT(1)\n#define HISI_PCIE_LOCAL_VALID_SOCKET_ID\t\tBIT(2)\n#define HISI_PCIE_LOCAL_VALID_NIMBUS_ID\t\tBIT(3)\n#define HISI_PCIE_LOCAL_VALID_SUB_MODULE_ID\tBIT(4)\n#define HISI_PCIE_LOCAL_VALID_CORE_ID\t\tBIT(5)\n#define HISI_PCIE_LOCAL_VALID_PORT_ID\t\tBIT(6)\n#define HISI_PCIE_LOCAL_VALID_ERR_TYPE\t\tBIT(7)\n#define HISI_PCIE_LOCAL_VALID_ERR_SEVERITY\tBIT(8)\n#define HISI_PCIE_LOCAL_VALID_ERR_MISC\t\t9\n\nstatic guid_t hisi_pcie_sec_guid =\n\tGUID_INIT(0xB2889FC9, 0xE7D7, 0x4F9D,\n\t\t  0xA8, 0x67, 0xAF, 0x42, 0xE9, 0x8B, 0xE7, 0x72);\n\n \n#define HISI_PCIE_PORT_ID(core, v)       (((v) >> 1) + ((core) << 3))\n#define HISI_PCIE_CORE_ID(v)             ((v) >> 3)\n#define HISI_PCIE_CORE_PORT_ID(v)        (((v) & 7) << 1)\n\nstruct hisi_pcie_error_data {\n\tu64\tval_bits;\n\tu8\tversion;\n\tu8\tsoc_id;\n\tu8\tsocket_id;\n\tu8\tnimbus_id;\n\tu8\tsub_module_id;\n\tu8\tcore_id;\n\tu8\tport_id;\n\tu8\terr_severity;\n\tu16\terr_type;\n\tu8\treserv[2];\n\tu32\terr_misc[HISI_PCIE_ERR_MISC_REGS];\n};\n\nstruct hisi_pcie_error_private {\n\tstruct notifier_block\tnb;\n\tstruct device *dev;\n};\n\nenum hisi_pcie_submodule_id {\n\tHISI_PCIE_SUB_MODULE_ID_AP,\n\tHISI_PCIE_SUB_MODULE_ID_TL,\n\tHISI_PCIE_SUB_MODULE_ID_MAC,\n\tHISI_PCIE_SUB_MODULE_ID_DL,\n\tHISI_PCIE_SUB_MODULE_ID_SDI,\n};\n\nstatic const char * const hisi_pcie_sub_module[] = {\n\t[HISI_PCIE_SUB_MODULE_ID_AP]\t= \"AP Layer\",\n\t[HISI_PCIE_SUB_MODULE_ID_TL]\t= \"TL Layer\",\n\t[HISI_PCIE_SUB_MODULE_ID_MAC]\t= \"MAC Layer\",\n\t[HISI_PCIE_SUB_MODULE_ID_DL]\t= \"DL Layer\",\n\t[HISI_PCIE_SUB_MODULE_ID_SDI]\t= \"SDI Layer\",\n};\n\nenum hisi_pcie_err_severity {\n\tHISI_PCIE_ERR_SEV_RECOVERABLE,\n\tHISI_PCIE_ERR_SEV_FATAL,\n\tHISI_PCIE_ERR_SEV_CORRECTED,\n\tHISI_PCIE_ERR_SEV_NONE,\n};\n\nstatic const char * const hisi_pcie_error_sev[] = {\n\t[HISI_PCIE_ERR_SEV_RECOVERABLE]\t= \"recoverable\",\n\t[HISI_PCIE_ERR_SEV_FATAL]\t= \"fatal\",\n\t[HISI_PCIE_ERR_SEV_CORRECTED]\t= \"corrected\",\n\t[HISI_PCIE_ERR_SEV_NONE]\t= \"none\",\n};\n\nstatic const char *hisi_pcie_get_string(const char * const *array,\n\t\t\t\t\tsize_t n, u32 id)\n{\n\tu32 index;\n\n\tfor (index = 0; index < n; index++) {\n\t\tif (index == id && array[index])\n\t\t\treturn array[index];\n\t}\n\n\treturn \"unknown\";\n}\n\nstatic int hisi_pcie_port_reset(struct platform_device *pdev,\n\t\t\t\tu32 chip_id, u32 port_id)\n{\n\tstruct device *dev = &pdev->dev;\n\tacpi_handle handle = ACPI_HANDLE(dev);\n\tunion acpi_object arg[3];\n\tstruct acpi_object_list arg_list;\n\tacpi_status s;\n\tunsigned long long data = 0;\n\n\targ[0].type = ACPI_TYPE_INTEGER;\n\targ[0].integer.value = chip_id;\n\targ[1].type = ACPI_TYPE_INTEGER;\n\targ[1].integer.value = HISI_PCIE_CORE_ID(port_id);\n\targ[2].type = ACPI_TYPE_INTEGER;\n\targ[2].integer.value = HISI_PCIE_CORE_PORT_ID(port_id);\n\n\targ_list.count = 3;\n\targ_list.pointer = arg;\n\n\ts = acpi_evaluate_integer(handle, \"RST\", &arg_list, &data);\n\tif (ACPI_FAILURE(s)) {\n\t\tdev_err(dev, \"No RST method\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (data) {\n\t\tdev_err(dev, \"Failed to Reset\\n\");\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int hisi_pcie_port_do_recovery(struct platform_device *dev,\n\t\t\t\t      u32 chip_id, u32 port_id)\n{\n\tacpi_status s;\n\tstruct device *device = &dev->dev;\n\tacpi_handle root_handle = ACPI_HANDLE(device);\n\tstruct acpi_pci_root *pci_root;\n\tstruct pci_bus *root_bus;\n\tstruct pci_dev *pdev;\n\tu32 domain, busnr, devfn;\n\n\ts = acpi_get_parent(root_handle, &root_handle);\n\tif (ACPI_FAILURE(s))\n\t\treturn -ENODEV;\n\tpci_root = acpi_pci_find_root(root_handle);\n\tif (!pci_root)\n\t\treturn -ENODEV;\n\troot_bus = pci_root->bus;\n\tdomain = pci_root->segment;\n\n\tbusnr = root_bus->number;\n\tdevfn = PCI_DEVFN(port_id, 0);\n\tpdev = pci_get_domain_bus_and_slot(domain, busnr, devfn);\n\tif (!pdev) {\n\t\tdev_info(device, \"Fail to get root port %04x:%02x:%02x.%d device\\n\",\n\t\t\t domain, busnr, PCI_SLOT(devfn), PCI_FUNC(devfn));\n\t\treturn -ENODEV;\n\t}\n\n\tpci_stop_and_remove_bus_device_locked(pdev);\n\tpci_dev_put(pdev);\n\n\tif (hisi_pcie_port_reset(dev, chip_id, port_id))\n\t\treturn -EIO;\n\n\t \n\tssleep(1UL);\n\n\t \n\tpci_lock_rescan_remove();\n\tpci_rescan_bus(root_bus);\n\tpci_unlock_rescan_remove();\n\n\treturn 0;\n}\n\nstatic void hisi_pcie_handle_error(struct platform_device *pdev,\n\t\t\t\t   const struct hisi_pcie_error_data *edata)\n{\n\tstruct device *dev = &pdev->dev;\n\tint idx, rc;\n\tconst unsigned long valid_bits[] = {BITMAP_FROM_U64(edata->val_bits)};\n\n\tif (edata->val_bits == 0) {\n\t\tdev_warn(dev, \"%s: no valid error information\\n\", __func__);\n\t\treturn;\n\t}\n\n\tdev_info(dev, \"\\nHISI : HIP : PCIe controller error\\n\");\n\tif (edata->val_bits & HISI_PCIE_LOCAL_VALID_SOC_ID)\n\t\tdev_info(dev, \"Table version = %d\\n\", edata->version);\n\tif (edata->val_bits & HISI_PCIE_LOCAL_VALID_SOCKET_ID)\n\t\tdev_info(dev, \"Socket ID = %d\\n\", edata->socket_id);\n\tif (edata->val_bits & HISI_PCIE_LOCAL_VALID_NIMBUS_ID)\n\t\tdev_info(dev, \"Nimbus ID = %d\\n\", edata->nimbus_id);\n\tif (edata->val_bits & HISI_PCIE_LOCAL_VALID_SUB_MODULE_ID)\n\t\tdev_info(dev, \"Sub Module = %s\\n\",\n\t\t\t hisi_pcie_get_string(hisi_pcie_sub_module,\n\t\t\t\t\t      ARRAY_SIZE(hisi_pcie_sub_module),\n\t\t\t\t\t      edata->sub_module_id));\n\tif (edata->val_bits & HISI_PCIE_LOCAL_VALID_CORE_ID)\n\t\tdev_info(dev, \"Core ID = core%d\\n\", edata->core_id);\n\tif (edata->val_bits & HISI_PCIE_LOCAL_VALID_PORT_ID)\n\t\tdev_info(dev, \"Port ID = port%d\\n\", edata->port_id);\n\tif (edata->val_bits & HISI_PCIE_LOCAL_VALID_ERR_SEVERITY)\n\t\tdev_info(dev, \"Error severity = %s\\n\",\n\t\t\t hisi_pcie_get_string(hisi_pcie_error_sev,\n\t\t\t\t\t      ARRAY_SIZE(hisi_pcie_error_sev),\n\t\t\t\t\t      edata->err_severity));\n\tif (edata->val_bits & HISI_PCIE_LOCAL_VALID_ERR_TYPE)\n\t\tdev_info(dev, \"Error type = 0x%x\\n\", edata->err_type);\n\n\tdev_info(dev, \"Reg Dump:\\n\");\n\tidx = HISI_PCIE_LOCAL_VALID_ERR_MISC;\n\tfor_each_set_bit_from(idx, valid_bits,\n\t\t\t      HISI_PCIE_LOCAL_VALID_ERR_MISC + HISI_PCIE_ERR_MISC_REGS)\n\t\tdev_info(dev, \"ERR_MISC_%d = 0x%x\\n\", idx - HISI_PCIE_LOCAL_VALID_ERR_MISC,\n\t\t\t edata->err_misc[idx - HISI_PCIE_LOCAL_VALID_ERR_MISC]);\n\n\tif (edata->err_severity != HISI_PCIE_ERR_SEV_RECOVERABLE)\n\t\treturn;\n\n\t \n\trc = hisi_pcie_port_do_recovery(pdev, edata->socket_id,\n\t\t\tHISI_PCIE_PORT_ID(edata->core_id, edata->port_id));\n\tif (rc)\n\t\tdev_info(dev, \"fail to do hisi pcie port reset\\n\");\n}\n\nstatic int hisi_pcie_notify_error(struct notifier_block *nb,\n\t\t\t\t  unsigned long event, void *data)\n{\n\tstruct acpi_hest_generic_data *gdata = data;\n\tconst struct hisi_pcie_error_data *error_data = acpi_hest_get_payload(gdata);\n\tstruct hisi_pcie_error_private *priv;\n\tstruct device *dev;\n\tstruct platform_device *pdev;\n\tguid_t err_sec_guid;\n\tu8 socket;\n\n\timport_guid(&err_sec_guid, gdata->section_type);\n\tif (!guid_equal(&err_sec_guid, &hisi_pcie_sec_guid))\n\t\treturn NOTIFY_DONE;\n\n\tpriv = container_of(nb, struct hisi_pcie_error_private, nb);\n\tdev = priv->dev;\n\n\tif (device_property_read_u8(dev, \"socket\", &socket))\n\t\treturn NOTIFY_DONE;\n\n\tif (error_data->socket_id != socket)\n\t\treturn NOTIFY_DONE;\n\n\tpdev = container_of(dev, struct platform_device, dev);\n\thisi_pcie_handle_error(pdev, error_data);\n\n\treturn NOTIFY_OK;\n}\n\nstatic int hisi_pcie_error_handler_probe(struct platform_device *pdev)\n{\n\tstruct hisi_pcie_error_private *priv;\n\tint ret;\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->nb.notifier_call = hisi_pcie_notify_error;\n\tpriv->dev = &pdev->dev;\n\tret = ghes_register_vendor_record_notifier(&priv->nb);\n\tif (ret) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Failed to register hisi pcie controller error handler with apei\\n\");\n\t\treturn ret;\n\t}\n\n\tplatform_set_drvdata(pdev, priv);\n\n\treturn 0;\n}\n\nstatic void hisi_pcie_error_handler_remove(struct platform_device *pdev)\n{\n\tstruct hisi_pcie_error_private *priv = platform_get_drvdata(pdev);\n\n\tghes_unregister_vendor_record_notifier(&priv->nb);\n}\n\nstatic const struct acpi_device_id hisi_pcie_acpi_match[] = {\n\t{ \"HISI0361\", 0 },\n\t{ }\n};\n\nstatic struct platform_driver hisi_pcie_error_handler_driver = {\n\t.driver = {\n\t\t.name\t= \"hisi-pcie-error-handler\",\n\t\t.acpi_match_table = hisi_pcie_acpi_match,\n\t},\n\t.probe\t\t= hisi_pcie_error_handler_probe,\n\t.remove_new\t= hisi_pcie_error_handler_remove,\n};\nmodule_platform_driver(hisi_pcie_error_handler_driver);\n\nMODULE_DESCRIPTION(\"HiSilicon HIP PCIe controller error handling driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}