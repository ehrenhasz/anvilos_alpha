{
  "module_name": "pcie-xilinx.c",
  "hash_id": "a9976f1b68962f1f16c86de620ff7b63228a3dcf1fec8d37c5a09d2b7bca10bc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/controller/pcie-xilinx.c",
  "human_readable_source": "\n \n\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/msi.h>\n#include <linux/of_address.h>\n#include <linux/of_pci.h>\n#include <linux/of_platform.h>\n#include <linux/of_irq.h>\n#include <linux/pci.h>\n#include <linux/pci-ecam.h>\n#include <linux/platform_device.h>\n\n#include \"../pci.h\"\n\n \n#define XILINX_PCIE_REG_BIR\t\t0x00000130\n#define XILINX_PCIE_REG_IDR\t\t0x00000138\n#define XILINX_PCIE_REG_IMR\t\t0x0000013c\n#define XILINX_PCIE_REG_PSCR\t\t0x00000144\n#define XILINX_PCIE_REG_RPSC\t\t0x00000148\n#define XILINX_PCIE_REG_MSIBASE1\t0x0000014c\n#define XILINX_PCIE_REG_MSIBASE2\t0x00000150\n#define XILINX_PCIE_REG_RPEFR\t\t0x00000154\n#define XILINX_PCIE_REG_RPIFR1\t\t0x00000158\n#define XILINX_PCIE_REG_RPIFR2\t\t0x0000015c\n\n \n#define XILINX_PCIE_INTR_LINK_DOWN\tBIT(0)\n#define XILINX_PCIE_INTR_ECRC_ERR\tBIT(1)\n#define XILINX_PCIE_INTR_STR_ERR\tBIT(2)\n#define XILINX_PCIE_INTR_HOT_RESET\tBIT(3)\n#define XILINX_PCIE_INTR_CFG_TIMEOUT\tBIT(8)\n#define XILINX_PCIE_INTR_CORRECTABLE\tBIT(9)\n#define XILINX_PCIE_INTR_NONFATAL\tBIT(10)\n#define XILINX_PCIE_INTR_FATAL\t\tBIT(11)\n#define XILINX_PCIE_INTR_INTX\t\tBIT(16)\n#define XILINX_PCIE_INTR_MSI\t\tBIT(17)\n#define XILINX_PCIE_INTR_SLV_UNSUPP\tBIT(20)\n#define XILINX_PCIE_INTR_SLV_UNEXP\tBIT(21)\n#define XILINX_PCIE_INTR_SLV_COMPL\tBIT(22)\n#define XILINX_PCIE_INTR_SLV_ERRP\tBIT(23)\n#define XILINX_PCIE_INTR_SLV_CMPABT\tBIT(24)\n#define XILINX_PCIE_INTR_SLV_ILLBUR\tBIT(25)\n#define XILINX_PCIE_INTR_MST_DECERR\tBIT(26)\n#define XILINX_PCIE_INTR_MST_SLVERR\tBIT(27)\n#define XILINX_PCIE_INTR_MST_ERRP\tBIT(28)\n#define XILINX_PCIE_IMR_ALL_MASK\t0x1FF30FED\n#define XILINX_PCIE_IMR_ENABLE_MASK\t0x1FF30F0D\n#define XILINX_PCIE_IDR_ALL_MASK\t0xFFFFFFFF\n\n \n#define XILINX_PCIE_RPEFR_ERR_VALID\tBIT(18)\n#define XILINX_PCIE_RPEFR_REQ_ID\tGENMASK(15, 0)\n#define XILINX_PCIE_RPEFR_ALL_MASK\t0xFFFFFFFF\n\n \n#define XILINX_PCIE_RPIFR1_INTR_VALID\tBIT(31)\n#define XILINX_PCIE_RPIFR1_MSI_INTR\tBIT(30)\n#define XILINX_PCIE_RPIFR1_INTR_MASK\tGENMASK(28, 27)\n#define XILINX_PCIE_RPIFR1_ALL_MASK\t0xFFFFFFFF\n#define XILINX_PCIE_RPIFR1_INTR_SHIFT\t27\n\n \n#define XILINX_PCIE_BIR_ECAM_SZ_MASK\tGENMASK(18, 16)\n#define XILINX_PCIE_BIR_ECAM_SZ_SHIFT\t16\n\n \n#define XILINX_PCIE_RPIFR2_MSG_DATA\tGENMASK(15, 0)\n\n \n#define XILINX_PCIE_REG_RPSC_BEN\tBIT(0)\n\n \n#define XILINX_PCIE_REG_PSCR_LNKUP\tBIT(11)\n\n \n#define XILINX_NUM_MSI_IRQS\t\t128\n\n \nstruct xilinx_pcie {\n\tstruct device *dev;\n\tvoid __iomem *reg_base;\n\tunsigned long msi_map[BITS_TO_LONGS(XILINX_NUM_MSI_IRQS)];\n\tstruct mutex map_lock;\n\tstruct irq_domain *msi_domain;\n\tstruct irq_domain *leg_domain;\n\tstruct list_head resources;\n};\n\nstatic inline u32 pcie_read(struct xilinx_pcie *pcie, u32 reg)\n{\n\treturn readl(pcie->reg_base + reg);\n}\n\nstatic inline void pcie_write(struct xilinx_pcie *pcie, u32 val, u32 reg)\n{\n\twritel(val, pcie->reg_base + reg);\n}\n\nstatic inline bool xilinx_pcie_link_up(struct xilinx_pcie *pcie)\n{\n\treturn (pcie_read(pcie, XILINX_PCIE_REG_PSCR) &\n\t\tXILINX_PCIE_REG_PSCR_LNKUP) ? 1 : 0;\n}\n\n \nstatic void xilinx_pcie_clear_err_interrupts(struct xilinx_pcie *pcie)\n{\n\tstruct device *dev = pcie->dev;\n\tunsigned long val = pcie_read(pcie, XILINX_PCIE_REG_RPEFR);\n\n\tif (val & XILINX_PCIE_RPEFR_ERR_VALID) {\n\t\tdev_dbg(dev, \"Requester ID %lu\\n\",\n\t\t\tval & XILINX_PCIE_RPEFR_REQ_ID);\n\t\tpcie_write(pcie, XILINX_PCIE_RPEFR_ALL_MASK,\n\t\t\t   XILINX_PCIE_REG_RPEFR);\n\t}\n}\n\n \nstatic bool xilinx_pcie_valid_device(struct pci_bus *bus, unsigned int devfn)\n{\n\tstruct xilinx_pcie *pcie = bus->sysdata;\n\n\t \n\tif (!pci_is_root_bus(bus)) {\n\t\tif (!xilinx_pcie_link_up(pcie))\n\t\t\treturn false;\n\t} else if (devfn > 0) {\n\t\t \n\t\treturn false;\n\t}\n\treturn true;\n}\n\n \nstatic void __iomem *xilinx_pcie_map_bus(struct pci_bus *bus,\n\t\t\t\t\t unsigned int devfn, int where)\n{\n\tstruct xilinx_pcie *pcie = bus->sysdata;\n\n\tif (!xilinx_pcie_valid_device(bus, devfn))\n\t\treturn NULL;\n\n\treturn pcie->reg_base + PCIE_ECAM_OFFSET(bus->number, devfn, where);\n}\n\n \nstatic struct pci_ops xilinx_pcie_ops = {\n\t.map_bus = xilinx_pcie_map_bus,\n\t.read\t= pci_generic_config_read,\n\t.write\t= pci_generic_config_write,\n};\n\n \n\nstatic void xilinx_msi_top_irq_ack(struct irq_data *d)\n{\n\t \n}\n\nstatic struct irq_chip xilinx_msi_top_chip = {\n\t.name\t\t= \"PCIe MSI\",\n\t.irq_ack\t= xilinx_msi_top_irq_ack,\n};\n\nstatic int xilinx_msi_set_affinity(struct irq_data *d, const struct cpumask *mask, bool force)\n{\n\treturn -EINVAL;\n}\n\nstatic void xilinx_compose_msi_msg(struct irq_data *data, struct msi_msg *msg)\n{\n\tstruct xilinx_pcie *pcie = irq_data_get_irq_chip_data(data);\n\tphys_addr_t pa = ALIGN_DOWN(virt_to_phys(pcie), SZ_4K);\n\n\tmsg->address_lo = lower_32_bits(pa);\n\tmsg->address_hi = upper_32_bits(pa);\n\tmsg->data = data->hwirq;\n}\n\nstatic struct irq_chip xilinx_msi_bottom_chip = {\n\t.name\t\t\t= \"Xilinx MSI\",\n\t.irq_set_affinity \t= xilinx_msi_set_affinity,\n\t.irq_compose_msi_msg\t= xilinx_compose_msi_msg,\n};\n\nstatic int xilinx_msi_domain_alloc(struct irq_domain *domain, unsigned int virq,\n\t\t\t\t  unsigned int nr_irqs, void *args)\n{\n\tstruct xilinx_pcie *pcie = domain->host_data;\n\tint hwirq, i;\n\n\tmutex_lock(&pcie->map_lock);\n\n\thwirq = bitmap_find_free_region(pcie->msi_map, XILINX_NUM_MSI_IRQS, order_base_2(nr_irqs));\n\n\tmutex_unlock(&pcie->map_lock);\n\n\tif (hwirq < 0)\n\t\treturn -ENOSPC;\n\n\tfor (i = 0; i < nr_irqs; i++)\n\t\tirq_domain_set_info(domain, virq + i, hwirq + i,\n\t\t\t\t    &xilinx_msi_bottom_chip, domain->host_data,\n\t\t\t\t    handle_edge_irq, NULL, NULL);\n\n\treturn 0;\n}\n\nstatic void xilinx_msi_domain_free(struct irq_domain *domain, unsigned int virq,\n\t\t\t\t  unsigned int nr_irqs)\n{\n\tstruct irq_data *d = irq_domain_get_irq_data(domain, virq);\n\tstruct xilinx_pcie *pcie = domain->host_data;\n\n\tmutex_lock(&pcie->map_lock);\n\n\tbitmap_release_region(pcie->msi_map, d->hwirq, order_base_2(nr_irqs));\n\n\tmutex_unlock(&pcie->map_lock);\n}\n\nstatic const struct irq_domain_ops xilinx_msi_domain_ops = {\n\t.alloc\t= xilinx_msi_domain_alloc,\n\t.free\t= xilinx_msi_domain_free,\n};\n\nstatic struct msi_domain_info xilinx_msi_info = {\n\t.flags\t= (MSI_FLAG_USE_DEF_DOM_OPS | MSI_FLAG_USE_DEF_CHIP_OPS),\n\t.chip\t= &xilinx_msi_top_chip,\n};\n\nstatic int xilinx_allocate_msi_domains(struct xilinx_pcie *pcie)\n{\n\tstruct fwnode_handle *fwnode = dev_fwnode(pcie->dev);\n\tstruct irq_domain *parent;\n\n\tparent = irq_domain_create_linear(fwnode, XILINX_NUM_MSI_IRQS,\n\t\t\t\t\t  &xilinx_msi_domain_ops, pcie);\n\tif (!parent) {\n\t\tdev_err(pcie->dev, \"failed to create IRQ domain\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tirq_domain_update_bus_token(parent, DOMAIN_BUS_NEXUS);\n\n\tpcie->msi_domain = pci_msi_create_irq_domain(fwnode, &xilinx_msi_info, parent);\n\tif (!pcie->msi_domain) {\n\t\tdev_err(pcie->dev, \"failed to create MSI domain\\n\");\n\t\tirq_domain_remove(parent);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic void xilinx_free_msi_domains(struct xilinx_pcie *pcie)\n{\n\tstruct irq_domain *parent = pcie->msi_domain->parent;\n\n\tirq_domain_remove(pcie->msi_domain);\n\tirq_domain_remove(parent);\n}\n\n \n\n \nstatic int xilinx_pcie_intx_map(struct irq_domain *domain, unsigned int irq,\n\t\t\t\tirq_hw_number_t hwirq)\n{\n\tirq_set_chip_and_handler(irq, &dummy_irq_chip, handle_simple_irq);\n\tirq_set_chip_data(irq, domain->host_data);\n\n\treturn 0;\n}\n\n \nstatic const struct irq_domain_ops intx_domain_ops = {\n\t.map = xilinx_pcie_intx_map,\n\t.xlate = pci_irqd_intx_xlate,\n};\n\n \n\n \nstatic irqreturn_t xilinx_pcie_intr_handler(int irq, void *data)\n{\n\tstruct xilinx_pcie *pcie = (struct xilinx_pcie *)data;\n\tstruct device *dev = pcie->dev;\n\tu32 val, mask, status;\n\n\t \n\tval = pcie_read(pcie, XILINX_PCIE_REG_IDR);\n\tmask = pcie_read(pcie, XILINX_PCIE_REG_IMR);\n\n\tstatus = val & mask;\n\tif (!status)\n\t\treturn IRQ_NONE;\n\n\tif (status & XILINX_PCIE_INTR_LINK_DOWN)\n\t\tdev_warn(dev, \"Link Down\\n\");\n\n\tif (status & XILINX_PCIE_INTR_ECRC_ERR)\n\t\tdev_warn(dev, \"ECRC failed\\n\");\n\n\tif (status & XILINX_PCIE_INTR_STR_ERR)\n\t\tdev_warn(dev, \"Streaming error\\n\");\n\n\tif (status & XILINX_PCIE_INTR_HOT_RESET)\n\t\tdev_info(dev, \"Hot reset\\n\");\n\n\tif (status & XILINX_PCIE_INTR_CFG_TIMEOUT)\n\t\tdev_warn(dev, \"ECAM access timeout\\n\");\n\n\tif (status & XILINX_PCIE_INTR_CORRECTABLE) {\n\t\tdev_warn(dev, \"Correctable error message\\n\");\n\t\txilinx_pcie_clear_err_interrupts(pcie);\n\t}\n\n\tif (status & XILINX_PCIE_INTR_NONFATAL) {\n\t\tdev_warn(dev, \"Non fatal error message\\n\");\n\t\txilinx_pcie_clear_err_interrupts(pcie);\n\t}\n\n\tif (status & XILINX_PCIE_INTR_FATAL) {\n\t\tdev_warn(dev, \"Fatal error message\\n\");\n\t\txilinx_pcie_clear_err_interrupts(pcie);\n\t}\n\n\tif (status & (XILINX_PCIE_INTR_INTX | XILINX_PCIE_INTR_MSI)) {\n\t\tstruct irq_domain *domain;\n\n\t\tval = pcie_read(pcie, XILINX_PCIE_REG_RPIFR1);\n\n\t\t \n\t\tif (!(val & XILINX_PCIE_RPIFR1_INTR_VALID)) {\n\t\t\tdev_warn(dev, \"RP Intr FIFO1 read error\\n\");\n\t\t\tgoto error;\n\t\t}\n\n\t\t \n\t\tif (val & XILINX_PCIE_RPIFR1_MSI_INTR) {\n\t\t\tval = pcie_read(pcie, XILINX_PCIE_REG_RPIFR2) &\n\t\t\t\tXILINX_PCIE_RPIFR2_MSG_DATA;\n\t\t\tdomain = pcie->msi_domain->parent;\n\t\t} else {\n\t\t\tval = (val & XILINX_PCIE_RPIFR1_INTR_MASK) >>\n\t\t\t\tXILINX_PCIE_RPIFR1_INTR_SHIFT;\n\t\t\tdomain = pcie->leg_domain;\n\t\t}\n\n\t\t \n\t\tpcie_write(pcie, XILINX_PCIE_RPIFR1_ALL_MASK,\n\t\t\t   XILINX_PCIE_REG_RPIFR1);\n\n\t\tgeneric_handle_domain_irq(domain, val);\n\t}\n\n\tif (status & XILINX_PCIE_INTR_SLV_UNSUPP)\n\t\tdev_warn(dev, \"Slave unsupported request\\n\");\n\n\tif (status & XILINX_PCIE_INTR_SLV_UNEXP)\n\t\tdev_warn(dev, \"Slave unexpected completion\\n\");\n\n\tif (status & XILINX_PCIE_INTR_SLV_COMPL)\n\t\tdev_warn(dev, \"Slave completion timeout\\n\");\n\n\tif (status & XILINX_PCIE_INTR_SLV_ERRP)\n\t\tdev_warn(dev, \"Slave Error Poison\\n\");\n\n\tif (status & XILINX_PCIE_INTR_SLV_CMPABT)\n\t\tdev_warn(dev, \"Slave Completer Abort\\n\");\n\n\tif (status & XILINX_PCIE_INTR_SLV_ILLBUR)\n\t\tdev_warn(dev, \"Slave Illegal Burst\\n\");\n\n\tif (status & XILINX_PCIE_INTR_MST_DECERR)\n\t\tdev_warn(dev, \"Master decode error\\n\");\n\n\tif (status & XILINX_PCIE_INTR_MST_SLVERR)\n\t\tdev_warn(dev, \"Master slave error\\n\");\n\n\tif (status & XILINX_PCIE_INTR_MST_ERRP)\n\t\tdev_warn(dev, \"Master error poison\\n\");\n\nerror:\n\t \n\tpcie_write(pcie, status, XILINX_PCIE_REG_IDR);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic int xilinx_pcie_init_irq_domain(struct xilinx_pcie *pcie)\n{\n\tstruct device *dev = pcie->dev;\n\tstruct device_node *pcie_intc_node;\n\tint ret;\n\n\t \n\tpcie_intc_node = of_get_next_child(dev->of_node, NULL);\n\tif (!pcie_intc_node) {\n\t\tdev_err(dev, \"No PCIe Intc node found\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tpcie->leg_domain = irq_domain_add_linear(pcie_intc_node, PCI_NUM_INTX,\n\t\t\t\t\t\t &intx_domain_ops,\n\t\t\t\t\t\t pcie);\n\tof_node_put(pcie_intc_node);\n\tif (!pcie->leg_domain) {\n\t\tdev_err(dev, \"Failed to get a INTx IRQ domain\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tif (IS_ENABLED(CONFIG_PCI_MSI)) {\n\t\tphys_addr_t pa = ALIGN_DOWN(virt_to_phys(pcie), SZ_4K);\n\n\t\tret = xilinx_allocate_msi_domains(pcie);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tpcie_write(pcie, upper_32_bits(pa), XILINX_PCIE_REG_MSIBASE1);\n\t\tpcie_write(pcie, lower_32_bits(pa), XILINX_PCIE_REG_MSIBASE2);\n\t}\n\n\treturn 0;\n}\n\n \nstatic void xilinx_pcie_init_port(struct xilinx_pcie *pcie)\n{\n\tstruct device *dev = pcie->dev;\n\n\tif (xilinx_pcie_link_up(pcie))\n\t\tdev_info(dev, \"PCIe Link is UP\\n\");\n\telse\n\t\tdev_info(dev, \"PCIe Link is DOWN\\n\");\n\n\t \n\tpcie_write(pcie, ~XILINX_PCIE_IDR_ALL_MASK,\n\t\t   XILINX_PCIE_REG_IMR);\n\n\t \n\tpcie_write(pcie, pcie_read(pcie, XILINX_PCIE_REG_IDR) &\n\t\t\t XILINX_PCIE_IMR_ALL_MASK,\n\t\t   XILINX_PCIE_REG_IDR);\n\n\t \n\tpcie_write(pcie, XILINX_PCIE_IMR_ENABLE_MASK, XILINX_PCIE_REG_IMR);\n\n\t \n\tpcie_write(pcie, pcie_read(pcie, XILINX_PCIE_REG_RPSC) |\n\t\t\t XILINX_PCIE_REG_RPSC_BEN,\n\t\t   XILINX_PCIE_REG_RPSC);\n}\n\n \nstatic int xilinx_pcie_parse_dt(struct xilinx_pcie *pcie)\n{\n\tstruct device *dev = pcie->dev;\n\tstruct device_node *node = dev->of_node;\n\tstruct resource regs;\n\tunsigned int irq;\n\tint err;\n\n\terr = of_address_to_resource(node, 0, &regs);\n\tif (err) {\n\t\tdev_err(dev, \"missing \\\"reg\\\" property\\n\");\n\t\treturn err;\n\t}\n\n\tpcie->reg_base = devm_pci_remap_cfg_resource(dev, &regs);\n\tif (IS_ERR(pcie->reg_base))\n\t\treturn PTR_ERR(pcie->reg_base);\n\n\tirq = irq_of_parse_and_map(node, 0);\n\terr = devm_request_irq(dev, irq, xilinx_pcie_intr_handler,\n\t\t\t       IRQF_SHARED | IRQF_NO_THREAD,\n\t\t\t       \"xilinx-pcie\", pcie);\n\tif (err) {\n\t\tdev_err(dev, \"unable to request irq %d\\n\", irq);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int xilinx_pcie_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct xilinx_pcie *pcie;\n\tstruct pci_host_bridge *bridge;\n\tint err;\n\n\tif (!dev->of_node)\n\t\treturn -ENODEV;\n\n\tbridge = devm_pci_alloc_host_bridge(dev, sizeof(*pcie));\n\tif (!bridge)\n\t\treturn -ENODEV;\n\n\tpcie = pci_host_bridge_priv(bridge);\n\tmutex_init(&pcie->map_lock);\n\tpcie->dev = dev;\n\n\terr = xilinx_pcie_parse_dt(pcie);\n\tif (err) {\n\t\tdev_err(dev, \"Parsing DT failed\\n\");\n\t\treturn err;\n\t}\n\n\txilinx_pcie_init_port(pcie);\n\n\terr = xilinx_pcie_init_irq_domain(pcie);\n\tif (err) {\n\t\tdev_err(dev, \"Failed creating IRQ Domain\\n\");\n\t\treturn err;\n\t}\n\n\tbridge->sysdata = pcie;\n\tbridge->ops = &xilinx_pcie_ops;\n\n\terr = pci_host_probe(bridge);\n\tif (err)\n\t\txilinx_free_msi_domains(pcie);\n\n\treturn err;\n}\n\nstatic const struct of_device_id xilinx_pcie_of_match[] = {\n\t{ .compatible = \"xlnx,axi-pcie-host-1.00.a\", },\n\t{}\n};\n\nstatic struct platform_driver xilinx_pcie_driver = {\n\t.driver = {\n\t\t.name = \"xilinx-pcie\",\n\t\t.of_match_table = xilinx_pcie_of_match,\n\t\t.suppress_bind_attrs = true,\n\t},\n\t.probe = xilinx_pcie_probe,\n};\nbuiltin_platform_driver(xilinx_pcie_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}