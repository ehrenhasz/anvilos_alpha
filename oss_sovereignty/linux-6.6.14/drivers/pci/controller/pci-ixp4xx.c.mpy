{
  "module_name": "pci-ixp4xx.c",
  "hash_id": "c4d4538d538581d931f0f228e3549aa468890fa37af7ee61233d863aadb9736e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/controller/pci-ixp4xx.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/of.h>\n#include <linux/of_pci.h>\n#include <linux/pci.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/bits.h>\n#include \"../pci.h\"\n\n \n#define IXP4XX_PCI_NP_AD\t\t0x00\n#define IXP4XX_PCI_NP_CBE\t\t0x04\n#define IXP4XX_PCI_NP_WDATA\t\t0x08\n#define IXP4XX_PCI_NP_RDATA\t\t0x0c\n#define IXP4XX_PCI_CRP_AD_CBE\t\t0x10\n#define IXP4XX_PCI_CRP_WDATA\t\t0x14\n#define IXP4XX_PCI_CRP_RDATA\t\t0x18\n#define IXP4XX_PCI_CSR\t\t\t0x1c\n#define IXP4XX_PCI_ISR\t\t\t0x20\n#define IXP4XX_PCI_INTEN\t\t0x24\n#define IXP4XX_PCI_DMACTRL\t\t0x28\n#define IXP4XX_PCI_AHBMEMBASE\t\t0x2c\n#define IXP4XX_PCI_AHBIOBASE\t\t0x30\n#define IXP4XX_PCI_PCIMEMBASE\t\t0x34\n#define IXP4XX_PCI_AHBDOORBELL\t\t0x38\n#define IXP4XX_PCI_PCIDOORBELL\t\t0x3c\n#define IXP4XX_PCI_ATPDMA0_AHBADDR\t0x40\n#define IXP4XX_PCI_ATPDMA0_PCIADDR\t0x44\n#define IXP4XX_PCI_ATPDMA0_LENADDR\t0x48\n#define IXP4XX_PCI_ATPDMA1_AHBADDR\t0x4c\n#define IXP4XX_PCI_ATPDMA1_PCIADDR\t0x50\n#define IXP4XX_PCI_ATPDMA1_LENADDR\t0x54\n\n \n#define IXP4XX_PCI_CSR_HOST\t\tBIT(0)\n#define IXP4XX_PCI_CSR_ARBEN\t\tBIT(1)\n#define IXP4XX_PCI_CSR_ADS\t\tBIT(2)\n#define IXP4XX_PCI_CSR_PDS\t\tBIT(3)\n#define IXP4XX_PCI_CSR_ABE\t\tBIT(4)\n#define IXP4XX_PCI_CSR_DBT\t\tBIT(5)\n#define IXP4XX_PCI_CSR_ASE\t\tBIT(8)\n#define IXP4XX_PCI_CSR_IC\t\tBIT(15)\n#define IXP4XX_PCI_CSR_PRST\t\tBIT(16)\n\n \n#define IXP4XX_PCI_ISR_PSE\t\tBIT(0)\n#define IXP4XX_PCI_ISR_PFE\t\tBIT(1)\n#define IXP4XX_PCI_ISR_PPE\t\tBIT(2)\n#define IXP4XX_PCI_ISR_AHBE\t\tBIT(3)\n#define IXP4XX_PCI_ISR_APDC\t\tBIT(4)\n#define IXP4XX_PCI_ISR_PADC\t\tBIT(5)\n#define IXP4XX_PCI_ISR_ADB\t\tBIT(6)\n#define IXP4XX_PCI_ISR_PDB\t\tBIT(7)\n\n \n#define IXP4XX_PCI_INTEN_PSE\t\tBIT(0)\n#define IXP4XX_PCI_INTEN_PFE\t\tBIT(1)\n#define IXP4XX_PCI_INTEN_PPE\t\tBIT(2)\n#define IXP4XX_PCI_INTEN_AHBE\t\tBIT(3)\n#define IXP4XX_PCI_INTEN_APDC\t\tBIT(4)\n#define IXP4XX_PCI_INTEN_PADC\t\tBIT(5)\n#define IXP4XX_PCI_INTEN_ADB\t\tBIT(6)\n#define IXP4XX_PCI_INTEN_PDB\t\tBIT(7)\n\n \n#define IXP4XX_PCI_NP_CBE_BESL\t\t4\n\n \n#define NP_CMD_IOREAD\t\t\t0x2\n#define NP_CMD_IOWRITE\t\t\t0x3\n#define NP_CMD_CONFIGREAD\t\t0xa\n#define NP_CMD_CONFIGWRITE\t\t0xb\n#define NP_CMD_MEMREAD\t\t\t0x6\n#define\tNP_CMD_MEMWRITE\t\t\t0x7\n\n \n#define CRP_AD_CBE_BESL         20\n#define CRP_AD_CBE_WRITE\t0x00010000\n\n \n#define IXP4XX_PCI_RTOTTO\t\t0x40\n\nstruct ixp4xx_pci {\n\tstruct device *dev;\n\tvoid __iomem *base;\n\tbool errata_hammer;\n\tbool host_mode;\n};\n\n \nstatic inline u32 ixp4xx_readl(struct ixp4xx_pci *p, u32 reg)\n{\n\treturn __raw_readl(p->base + reg);\n}\n\nstatic inline void ixp4xx_writel(struct ixp4xx_pci *p, u32 reg, u32 val)\n{\n\t__raw_writel(val, p->base + reg);\n}\n\nstatic int ixp4xx_pci_check_master_abort(struct ixp4xx_pci *p)\n{\n\tu32 isr = ixp4xx_readl(p, IXP4XX_PCI_ISR);\n\n\tif (isr & IXP4XX_PCI_ISR_PFE) {\n\t\t \n\t\tixp4xx_writel(p, IXP4XX_PCI_ISR, IXP4XX_PCI_ISR_PFE);\n\t\tdev_dbg(p->dev, \"master abort detected\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int ixp4xx_pci_read_indirect(struct ixp4xx_pci *p, u32 addr, u32 cmd, u32 *data)\n{\n\tixp4xx_writel(p, IXP4XX_PCI_NP_AD, addr);\n\n\tif (p->errata_hammer) {\n\t\tint i;\n\n\t\t \n\t\tfor (i = 0; i < 8; i++) {\n\t\t\tixp4xx_writel(p, IXP4XX_PCI_NP_CBE, cmd);\n\t\t\t*data = ixp4xx_readl(p, IXP4XX_PCI_NP_RDATA);\n\t\t\t*data = ixp4xx_readl(p, IXP4XX_PCI_NP_RDATA);\n\t\t}\n\t} else {\n\t\tixp4xx_writel(p, IXP4XX_PCI_NP_CBE, cmd);\n\t\t*data = ixp4xx_readl(p, IXP4XX_PCI_NP_RDATA);\n\t}\n\n\treturn ixp4xx_pci_check_master_abort(p);\n}\n\nstatic int ixp4xx_pci_write_indirect(struct ixp4xx_pci *p, u32 addr, u32 cmd, u32 data)\n{\n\tixp4xx_writel(p, IXP4XX_PCI_NP_AD, addr);\n\n\t \n\tixp4xx_writel(p, IXP4XX_PCI_NP_CBE, cmd);\n\n\t \n\tixp4xx_writel(p, IXP4XX_PCI_NP_WDATA, data);\n\n\treturn ixp4xx_pci_check_master_abort(p);\n}\n\nstatic u32 ixp4xx_config_addr(u8 bus_num, u16 devfn, int where)\n{\n\t \n\tif (bus_num == 0) {\n\t\t \n\t\treturn (PCI_CONF1_ADDRESS(0, 0, PCI_FUNC(devfn), where) &\n\t\t\t~PCI_CONF1_ENABLE) | BIT(32-PCI_SLOT(devfn));\n\t} else {\n\t\t \n\t\treturn (PCI_CONF1_ADDRESS(bus_num, PCI_SLOT(devfn),\n\t\t\t\t\t  PCI_FUNC(devfn), where) &\n\t\t\t~PCI_CONF1_ENABLE) | 1;\n\t}\n}\n\n \nstatic u32 ixp4xx_crp_byte_lane_enable_bits(u32 n, int size)\n{\n\tif (size == 1)\n\t\treturn (0xf & ~BIT(n)) << CRP_AD_CBE_BESL;\n\tif (size == 2)\n\t\treturn (0xf & ~(BIT(n) | BIT(n+1))) << CRP_AD_CBE_BESL;\n\tif (size == 4)\n\t\treturn 0;\n\treturn 0xffffffff;\n}\n\nstatic int ixp4xx_crp_read_config(struct ixp4xx_pci *p, int where, int size,\n\t\t\t\t  u32 *value)\n{\n\tu32 n, cmd, val;\n\n\tn = where % 4;\n\tcmd = where & ~3;\n\n\tdev_dbg(p->dev, \"%s from %d size %d cmd %08x\\n\",\n\t\t__func__, where, size, cmd);\n\n\tixp4xx_writel(p, IXP4XX_PCI_CRP_AD_CBE, cmd);\n\tval = ixp4xx_readl(p, IXP4XX_PCI_CRP_RDATA);\n\n\tval >>= (8*n);\n\tswitch (size) {\n\tcase 1:\n\t\tval &= U8_MAX;\n\t\tdev_dbg(p->dev, \"%s read byte %02x\\n\", __func__, val);\n\t\tbreak;\n\tcase 2:\n\t\tval &= U16_MAX;\n\t\tdev_dbg(p->dev, \"%s read word %04x\\n\", __func__, val);\n\t\tbreak;\n\tcase 4:\n\t\tval &= U32_MAX;\n\t\tdev_dbg(p->dev, \"%s read long %08x\\n\", __func__, val);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tdev_err(p->dev, \"%s illegal size\\n\", __func__);\n\t\treturn PCIBIOS_DEVICE_NOT_FOUND;\n\t}\n\t*value = val;\n\n\treturn PCIBIOS_SUCCESSFUL;\n}\n\nstatic int ixp4xx_crp_write_config(struct ixp4xx_pci *p, int where, int size,\n\t\t\t\t   u32 value)\n{\n\tu32 n, cmd, val;\n\n\tn = where % 4;\n\tcmd = ixp4xx_crp_byte_lane_enable_bits(n, size);\n\tif (cmd == 0xffffffff)\n\t\treturn PCIBIOS_BAD_REGISTER_NUMBER;\n\tcmd |= where & ~3;\n\tcmd |= CRP_AD_CBE_WRITE;\n\n\tval = value << (8*n);\n\n\tdev_dbg(p->dev, \"%s to %d size %d cmd %08x val %08x\\n\",\n\t\t__func__, where, size, cmd, val);\n\n\tixp4xx_writel(p, IXP4XX_PCI_CRP_AD_CBE, cmd);\n\tixp4xx_writel(p, IXP4XX_PCI_CRP_WDATA, val);\n\n\treturn PCIBIOS_SUCCESSFUL;\n}\n\n \nstatic u32 ixp4xx_byte_lane_enable_bits(u32 n, int size)\n{\n\tif (size == 1)\n\t\treturn (0xf & ~BIT(n)) << 4;\n\tif (size == 2)\n\t\treturn (0xf & ~(BIT(n) | BIT(n+1))) << 4;\n\tif (size == 4)\n\t\treturn 0;\n\treturn 0xffffffff;\n}\n\nstatic int ixp4xx_pci_read_config(struct pci_bus *bus, unsigned int devfn,\n\t\t\t\t  int where, int size, u32 *value)\n{\n\tstruct ixp4xx_pci *p = bus->sysdata;\n\tu32 n, addr, val, cmd;\n\tu8 bus_num = bus->number;\n\tint ret;\n\n\t*value = 0xffffffff;\n\tn = where % 4;\n\tcmd = ixp4xx_byte_lane_enable_bits(n, size);\n\tif (cmd == 0xffffffff)\n\t\treturn PCIBIOS_BAD_REGISTER_NUMBER;\n\n\taddr = ixp4xx_config_addr(bus_num, devfn, where);\n\tcmd |= NP_CMD_CONFIGREAD;\n\tdev_dbg(p->dev, \"read_config from %d size %d dev %d:%d:%d address: %08x cmd: %08x\\n\",\n\t\twhere, size, bus_num, PCI_SLOT(devfn), PCI_FUNC(devfn), addr, cmd);\n\n\tret = ixp4xx_pci_read_indirect(p, addr, cmd, &val);\n\tif (ret)\n\t\treturn PCIBIOS_DEVICE_NOT_FOUND;\n\n\tval >>= (8*n);\n\tswitch (size) {\n\tcase 1:\n\t\tval &= U8_MAX;\n\t\tdev_dbg(p->dev, \"%s read byte %02x\\n\", __func__, val);\n\t\tbreak;\n\tcase 2:\n\t\tval &= U16_MAX;\n\t\tdev_dbg(p->dev, \"%s read word %04x\\n\", __func__, val);\n\t\tbreak;\n\tcase 4:\n\t\tval &= U32_MAX;\n\t\tdev_dbg(p->dev, \"%s read long %08x\\n\", __func__, val);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tdev_err(p->dev, \"%s illegal size\\n\", __func__);\n\t\treturn PCIBIOS_DEVICE_NOT_FOUND;\n\t}\n\t*value = val;\n\n\treturn PCIBIOS_SUCCESSFUL;\n}\n\nstatic int ixp4xx_pci_write_config(struct pci_bus *bus,  unsigned int devfn,\n\t\t\t\t   int where, int size, u32 value)\n{\n\tstruct ixp4xx_pci *p = bus->sysdata;\n\tu32 n, addr, val, cmd;\n\tu8 bus_num = bus->number;\n\tint ret;\n\n\tn = where % 4;\n\tcmd = ixp4xx_byte_lane_enable_bits(n, size);\n\tif (cmd == 0xffffffff)\n\t\treturn PCIBIOS_BAD_REGISTER_NUMBER;\n\n\taddr = ixp4xx_config_addr(bus_num, devfn, where);\n\tcmd |= NP_CMD_CONFIGWRITE;\n\tval = value << (8*n);\n\n\tdev_dbg(p->dev, \"write_config_byte %#x to %d size %d dev %d:%d:%d addr: %08x cmd %08x\\n\",\n\t\tvalue, where, size, bus_num, PCI_SLOT(devfn), PCI_FUNC(devfn), addr, cmd);\n\n\tret = ixp4xx_pci_write_indirect(p, addr, cmd, val);\n\tif (ret)\n\t\treturn PCIBIOS_DEVICE_NOT_FOUND;\n\n\treturn PCIBIOS_SUCCESSFUL;\n}\n\nstatic struct pci_ops ixp4xx_pci_ops = {\n\t.read = ixp4xx_pci_read_config,\n\t.write = ixp4xx_pci_write_config,\n};\n\nstatic u32 ixp4xx_pci_addr_to_64mconf(phys_addr_t addr)\n{\n\tu8 base;\n\n\tbase = ((addr & 0xff000000) >> 24);\n\treturn (base << 24) | ((base + 1) << 16)\n\t\t| ((base + 2) << 8) | (base + 3);\n}\n\nstatic int ixp4xx_pci_parse_map_ranges(struct ixp4xx_pci *p)\n{\n\tstruct device *dev = p->dev;\n\tstruct pci_host_bridge *bridge = pci_host_bridge_from_priv(p);\n\tstruct resource_entry *win;\n\tstruct resource *res;\n\tphys_addr_t addr;\n\n\twin = resource_list_first_type(&bridge->windows, IORESOURCE_MEM);\n\tif (win) {\n\t\tu32 pcimembase;\n\n\t\tres = win->res;\n\t\taddr = res->start - win->offset;\n\n\t\tif (res->flags & IORESOURCE_PREFETCH)\n\t\t\tres->name = \"IXP4xx PCI PRE-MEM\";\n\t\telse\n\t\t\tres->name = \"IXP4xx PCI NON-PRE-MEM\";\n\n\t\tdev_dbg(dev, \"%s window %pR, bus addr %pa\\n\",\n\t\t\tres->name, res, &addr);\n\t\tif (resource_size(res) != SZ_64M) {\n\t\t\tdev_err(dev, \"memory range is not 64MB\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tpcimembase = ixp4xx_pci_addr_to_64mconf(addr);\n\t\t \n\t\tixp4xx_writel(p, IXP4XX_PCI_PCIMEMBASE, pcimembase);\n\t} else {\n\t\tdev_err(dev, \"no AHB memory mapping defined\\n\");\n\t}\n\n\twin = resource_list_first_type(&bridge->windows, IORESOURCE_IO);\n\tif (win) {\n\t\tres = win->res;\n\n\t\taddr = pci_pio_to_address(res->start);\n\t\tif (addr & 0xff) {\n\t\t\tdev_err(dev, \"IO mem at uneven address: %pa\\n\", &addr);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tres->name = \"IXP4xx PCI IO MEM\";\n\t\t \n\t\tixp4xx_writel(p, IXP4XX_PCI_AHBIOBASE, (addr >> 8));\n\t} else {\n\t\tdev_info(dev, \"no IO space AHB memory mapping defined\\n\");\n\t}\n\n\treturn 0;\n}\n\nstatic int ixp4xx_pci_parse_map_dma_ranges(struct ixp4xx_pci *p)\n{\n\tstruct device *dev = p->dev;\n\tstruct pci_host_bridge *bridge = pci_host_bridge_from_priv(p);\n\tstruct resource_entry *win;\n\tstruct resource *res;\n\tphys_addr_t addr;\n\tu32 ahbmembase;\n\n\twin = resource_list_first_type(&bridge->dma_ranges, IORESOURCE_MEM);\n\tif (win) {\n\t\tres = win->res;\n\t\taddr = res->start - win->offset;\n\n\t\tif (resource_size(res) != SZ_64M) {\n\t\t\tdev_err(dev, \"DMA memory range is not 64MB\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tdev_dbg(dev, \"DMA MEM BASE: %pa\\n\", &addr);\n\t\t \n\t\tahbmembase = ixp4xx_pci_addr_to_64mconf(addr);\n\t\t \n\t\tixp4xx_writel(p, IXP4XX_PCI_AHBMEMBASE, ahbmembase);\n\t} else {\n\t\tdev_err(dev, \"no DMA memory range defined\\n\");\n\t}\n\n\treturn 0;\n}\n\n \nstatic struct ixp4xx_pci *ixp4xx_pci_abort_singleton;\n\nstatic int ixp4xx_pci_abort_handler(unsigned long addr, unsigned int fsr,\n\t\t\t\t    struct pt_regs *regs)\n{\n\tstruct ixp4xx_pci *p = ixp4xx_pci_abort_singleton;\n\tu32 isr, status;\n\tint ret;\n\n\tisr = ixp4xx_readl(p, IXP4XX_PCI_ISR);\n\tret = ixp4xx_crp_read_config(p, PCI_STATUS, 2, &status);\n\tif (ret) {\n\t\tdev_err(p->dev, \"unable to read abort status\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev_err(p->dev,\n\t\t\"PCI: abort_handler addr = %#lx, isr = %#x, status = %#x\\n\",\n\t\taddr, isr, status);\n\n\t \n\tixp4xx_writel(p, IXP4XX_PCI_ISR, IXP4XX_PCI_ISR_PFE);\n\tstatus |= PCI_STATUS_REC_MASTER_ABORT;\n\tret = ixp4xx_crp_write_config(p, PCI_STATUS, 2, status);\n\tif (ret)\n\t\tdev_err(p->dev, \"unable to clear abort status bit\\n\");\n\n\t \n\tif (fsr & (1 << 10)) {\n\t\tdev_err(p->dev, \"imprecise abort\\n\");\n\t\tregs->ARM_pc += 4;\n\t}\n\n\treturn 0;\n}\n\nstatic int __init ixp4xx_pci_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct ixp4xx_pci *p;\n\tstruct pci_host_bridge *host;\n\tint ret;\n\tu32 val;\n\tphys_addr_t addr;\n\tu32 basereg[4] = {\n\t\tPCI_BASE_ADDRESS_0,\n\t\tPCI_BASE_ADDRESS_1,\n\t\tPCI_BASE_ADDRESS_2,\n\t\tPCI_BASE_ADDRESS_3,\n\t};\n\tint i;\n\n\thost = devm_pci_alloc_host_bridge(dev, sizeof(*p));\n\tif (!host)\n\t\treturn -ENOMEM;\n\n\thost->ops = &ixp4xx_pci_ops;\n\tp = pci_host_bridge_priv(host);\n\thost->sysdata = p;\n\tp->dev = dev;\n\tdev_set_drvdata(dev, p);\n\n\t \n\tif (of_device_is_compatible(np, \"intel,ixp42x-pci\")) {\n\t\tp->errata_hammer = true;\n\t\tdev_info(dev, \"activate hammering errata\\n\");\n\t}\n\n\tp->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(p->base))\n\t\treturn PTR_ERR(p->base);\n\n\tval = ixp4xx_readl(p, IXP4XX_PCI_CSR);\n\tp->host_mode = !!(val & IXP4XX_PCI_CSR_HOST);\n\tdev_info(dev, \"controller is in %s mode\\n\",\n\t\t p->host_mode ? \"host\" : \"option\");\n\n\t \n\tixp4xx_pci_abort_singleton = p;\n\thook_fault_code(16+6, ixp4xx_pci_abort_handler, SIGBUS, 0,\n\t\t\t\"imprecise external abort\");\n\n\tret = ixp4xx_pci_parse_map_ranges(p);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ixp4xx_pci_parse_map_dma_ranges(p);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (p->host_mode) {\n\t\taddr = __pa(PAGE_OFFSET);\n\t\t \n\t\taddr |= PCI_BASE_ADDRESS_SPACE_MEMORY;\n\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\t \n\t\t\tret = ixp4xx_crp_write_config(p, basereg[i], 4, addr);\n\t\t\tif (ret)\n\t\t\t\tdev_err(dev, \"failed to set up PCI_BASE_ADDRESS_%d\\n\", i);\n\t\t\telse\n\t\t\t\tdev_info(dev, \"set PCI_BASE_ADDR_%d to %pa\\n\", i, &addr);\n\t\t\taddr += SZ_16M;\n\t\t}\n\n\t\t \n\t\tret = ixp4xx_crp_write_config(p, PCI_BASE_ADDRESS_4, 4, addr);\n\t\tif (ret)\n\t\t\tdev_err(dev, \"failed to set up PCI_BASE_ADDRESS_4\\n\");\n\t\telse\n\t\t\tdev_info(dev, \"set PCI_BASE_ADDR_4 to %pa\\n\", &addr);\n\n\t\t \n\t\taddr = 0xfffffc00;\n\t\taddr |= PCI_BASE_ADDRESS_SPACE_IO;\n\t\tret = ixp4xx_crp_write_config(p, PCI_BASE_ADDRESS_5, 4, addr);\n\t\tif (ret)\n\t\t\tdev_err(dev, \"failed to set up PCI_BASE_ADDRESS_5\\n\");\n\t\telse\n\t\t\tdev_info(dev, \"set PCI_BASE_ADDR_5 to %pa\\n\", &addr);\n\n\t\t \n\t\tret = ixp4xx_crp_write_config(p, IXP4XX_PCI_RTOTTO, 4,\n\t\t\t\t\t      0x000080ff);\n\t\tif (ret)\n\t\t\tdev_err(dev, \"failed to set up TRDY limit\\n\");\n\t\telse\n\t\t\tdev_info(dev, \"set TRDY limit to 0x80ff\\n\");\n\t}\n\n\t \n\tval = IXP4XX_PCI_ISR_PSE | IXP4XX_PCI_ISR_PFE | IXP4XX_PCI_ISR_PPE | IXP4XX_PCI_ISR_AHBE;\n\tixp4xx_writel(p, IXP4XX_PCI_ISR, val);\n\n\t \n\tval = IXP4XX_PCI_CSR_IC | IXP4XX_PCI_CSR_ABE;\n\tif (IS_ENABLED(CONFIG_CPU_BIG_ENDIAN))\n\t\tval |= (IXP4XX_PCI_CSR_PDS | IXP4XX_PCI_CSR_ADS);\n\tixp4xx_writel(p, IXP4XX_PCI_CSR, val);\n\n\tret = ixp4xx_crp_write_config(p, PCI_COMMAND, 2, PCI_COMMAND_MASTER | PCI_COMMAND_MEMORY);\n\tif (ret)\n\t\tdev_err(dev, \"unable to initialize master and command memory\\n\");\n\telse\n\t\tdev_info(dev, \"initialized as master\\n\");\n\n\tpci_host_probe(host);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id ixp4xx_pci_of_match[] = {\n\t{\n\t\t.compatible = \"intel,ixp42x-pci\",\n\t},\n\t{\n\t\t.compatible = \"intel,ixp43x-pci\",\n\t},\n\t{},\n};\n\n \nstatic struct platform_driver ixp4xx_pci_driver = {\n\t.driver = {\n\t\t.name = \"ixp4xx-pci\",\n\t\t.suppress_bind_attrs = true,\n\t\t.of_match_table = ixp4xx_pci_of_match,\n\t},\n};\nbuiltin_platform_driver_probe(ixp4xx_pci_driver, ixp4xx_pci_probe);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}