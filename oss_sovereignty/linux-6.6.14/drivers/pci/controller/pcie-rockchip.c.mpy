{
  "module_name": "pcie-rockchip.c",
  "hash_id": "dc9e87c507bc42f28422a6a03d8bc600992d46ef4f2942287944ebdd8e149013",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/controller/pcie-rockchip.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/iopoll.h>\n#include <linux/of.h>\n#include <linux/of_pci.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n#include <linux/reset.h>\n\n#include \"../pci.h\"\n#include \"pcie-rockchip.h\"\n\nint rockchip_pcie_parse_dt(struct rockchip_pcie *rockchip)\n{\n\tstruct device *dev = rockchip->dev;\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct device_node *node = dev->of_node;\n\tstruct resource *regs;\n\tint err;\n\n\tif (rockchip->is_rc) {\n\t\tregs = platform_get_resource_byname(pdev,\n\t\t\t\t\t\t    IORESOURCE_MEM,\n\t\t\t\t\t\t    \"axi-base\");\n\t\trockchip->reg_base = devm_pci_remap_cfg_resource(dev, regs);\n\t\tif (IS_ERR(rockchip->reg_base))\n\t\t\treturn PTR_ERR(rockchip->reg_base);\n\t} else {\n\t\trockchip->mem_res =\n\t\t\tplatform_get_resource_byname(pdev, IORESOURCE_MEM,\n\t\t\t\t\t\t     \"mem-base\");\n\t\tif (!rockchip->mem_res)\n\t\t\treturn -EINVAL;\n\t}\n\n\trockchip->apb_base =\n\t\tdevm_platform_ioremap_resource_byname(pdev, \"apb-base\");\n\tif (IS_ERR(rockchip->apb_base))\n\t\treturn PTR_ERR(rockchip->apb_base);\n\n\terr = rockchip_pcie_get_phys(rockchip);\n\tif (err)\n\t\treturn err;\n\n\trockchip->lanes = 1;\n\terr = of_property_read_u32(node, \"num-lanes\", &rockchip->lanes);\n\tif (!err && (rockchip->lanes == 0 ||\n\t\t     rockchip->lanes == 3 ||\n\t\t     rockchip->lanes > 4)) {\n\t\tdev_warn(dev, \"invalid num-lanes, default to use one lane\\n\");\n\t\trockchip->lanes = 1;\n\t}\n\n\trockchip->link_gen = of_pci_get_max_link_speed(node);\n\tif (rockchip->link_gen < 0 || rockchip->link_gen > 2)\n\t\trockchip->link_gen = 2;\n\n\trockchip->core_rst = devm_reset_control_get_exclusive(dev, \"core\");\n\tif (IS_ERR(rockchip->core_rst)) {\n\t\tif (PTR_ERR(rockchip->core_rst) != -EPROBE_DEFER)\n\t\t\tdev_err(dev, \"missing core reset property in node\\n\");\n\t\treturn PTR_ERR(rockchip->core_rst);\n\t}\n\n\trockchip->mgmt_rst = devm_reset_control_get_exclusive(dev, \"mgmt\");\n\tif (IS_ERR(rockchip->mgmt_rst)) {\n\t\tif (PTR_ERR(rockchip->mgmt_rst) != -EPROBE_DEFER)\n\t\t\tdev_err(dev, \"missing mgmt reset property in node\\n\");\n\t\treturn PTR_ERR(rockchip->mgmt_rst);\n\t}\n\n\trockchip->mgmt_sticky_rst = devm_reset_control_get_exclusive(dev,\n\t\t\t\t\t\t\t\t\"mgmt-sticky\");\n\tif (IS_ERR(rockchip->mgmt_sticky_rst)) {\n\t\tif (PTR_ERR(rockchip->mgmt_sticky_rst) != -EPROBE_DEFER)\n\t\t\tdev_err(dev, \"missing mgmt-sticky reset property in node\\n\");\n\t\treturn PTR_ERR(rockchip->mgmt_sticky_rst);\n\t}\n\n\trockchip->pipe_rst = devm_reset_control_get_exclusive(dev, \"pipe\");\n\tif (IS_ERR(rockchip->pipe_rst)) {\n\t\tif (PTR_ERR(rockchip->pipe_rst) != -EPROBE_DEFER)\n\t\t\tdev_err(dev, \"missing pipe reset property in node\\n\");\n\t\treturn PTR_ERR(rockchip->pipe_rst);\n\t}\n\n\trockchip->pm_rst = devm_reset_control_get_exclusive(dev, \"pm\");\n\tif (IS_ERR(rockchip->pm_rst)) {\n\t\tif (PTR_ERR(rockchip->pm_rst) != -EPROBE_DEFER)\n\t\t\tdev_err(dev, \"missing pm reset property in node\\n\");\n\t\treturn PTR_ERR(rockchip->pm_rst);\n\t}\n\n\trockchip->pclk_rst = devm_reset_control_get_exclusive(dev, \"pclk\");\n\tif (IS_ERR(rockchip->pclk_rst)) {\n\t\tif (PTR_ERR(rockchip->pclk_rst) != -EPROBE_DEFER)\n\t\t\tdev_err(dev, \"missing pclk reset property in node\\n\");\n\t\treturn PTR_ERR(rockchip->pclk_rst);\n\t}\n\n\trockchip->aclk_rst = devm_reset_control_get_exclusive(dev, \"aclk\");\n\tif (IS_ERR(rockchip->aclk_rst)) {\n\t\tif (PTR_ERR(rockchip->aclk_rst) != -EPROBE_DEFER)\n\t\t\tdev_err(dev, \"missing aclk reset property in node\\n\");\n\t\treturn PTR_ERR(rockchip->aclk_rst);\n\t}\n\n\tif (rockchip->is_rc) {\n\t\trockchip->ep_gpio = devm_gpiod_get_optional(dev, \"ep\",\n\t\t\t\t\t\t\t    GPIOD_OUT_HIGH);\n\t\tif (IS_ERR(rockchip->ep_gpio))\n\t\t\treturn dev_err_probe(dev, PTR_ERR(rockchip->ep_gpio),\n\t\t\t\t\t     \"failed to get ep GPIO\\n\");\n\t}\n\n\trockchip->aclk_pcie = devm_clk_get(dev, \"aclk\");\n\tif (IS_ERR(rockchip->aclk_pcie)) {\n\t\tdev_err(dev, \"aclk clock not found\\n\");\n\t\treturn PTR_ERR(rockchip->aclk_pcie);\n\t}\n\n\trockchip->aclk_perf_pcie = devm_clk_get(dev, \"aclk-perf\");\n\tif (IS_ERR(rockchip->aclk_perf_pcie)) {\n\t\tdev_err(dev, \"aclk_perf clock not found\\n\");\n\t\treturn PTR_ERR(rockchip->aclk_perf_pcie);\n\t}\n\n\trockchip->hclk_pcie = devm_clk_get(dev, \"hclk\");\n\tif (IS_ERR(rockchip->hclk_pcie)) {\n\t\tdev_err(dev, \"hclk clock not found\\n\");\n\t\treturn PTR_ERR(rockchip->hclk_pcie);\n\t}\n\n\trockchip->clk_pcie_pm = devm_clk_get(dev, \"pm\");\n\tif (IS_ERR(rockchip->clk_pcie_pm)) {\n\t\tdev_err(dev, \"pm clock not found\\n\");\n\t\treturn PTR_ERR(rockchip->clk_pcie_pm);\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(rockchip_pcie_parse_dt);\n\n#define rockchip_pcie_read_addr(addr) rockchip_pcie_read(rockchip, addr)\n \n#define RK_PHY_PLL_LOCK_TIMEOUT_US 100000\n \n#define RK_PHY_PLL_LOCK_SLEEP_US 1000\n\nint rockchip_pcie_init_port(struct rockchip_pcie *rockchip)\n{\n\tstruct device *dev = rockchip->dev;\n\tint err, i;\n\tu32 regs;\n\n\terr = reset_control_assert(rockchip->aclk_rst);\n\tif (err) {\n\t\tdev_err(dev, \"assert aclk_rst err %d\\n\", err);\n\t\treturn err;\n\t}\n\n\terr = reset_control_assert(rockchip->pclk_rst);\n\tif (err) {\n\t\tdev_err(dev, \"assert pclk_rst err %d\\n\", err);\n\t\treturn err;\n\t}\n\n\terr = reset_control_assert(rockchip->pm_rst);\n\tif (err) {\n\t\tdev_err(dev, \"assert pm_rst err %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tfor (i = 0; i < MAX_LANE_NUM; i++) {\n\t\terr = phy_init(rockchip->phys[i]);\n\t\tif (err) {\n\t\t\tdev_err(dev, \"init phy%d err %d\\n\", i, err);\n\t\t\tgoto err_exit_phy;\n\t\t}\n\t}\n\n\terr = reset_control_assert(rockchip->core_rst);\n\tif (err) {\n\t\tdev_err(dev, \"assert core_rst err %d\\n\", err);\n\t\tgoto err_exit_phy;\n\t}\n\n\terr = reset_control_assert(rockchip->mgmt_rst);\n\tif (err) {\n\t\tdev_err(dev, \"assert mgmt_rst err %d\\n\", err);\n\t\tgoto err_exit_phy;\n\t}\n\n\terr = reset_control_assert(rockchip->mgmt_sticky_rst);\n\tif (err) {\n\t\tdev_err(dev, \"assert mgmt_sticky_rst err %d\\n\", err);\n\t\tgoto err_exit_phy;\n\t}\n\n\terr = reset_control_assert(rockchip->pipe_rst);\n\tif (err) {\n\t\tdev_err(dev, \"assert pipe_rst err %d\\n\", err);\n\t\tgoto err_exit_phy;\n\t}\n\n\tudelay(10);\n\n\terr = reset_control_deassert(rockchip->pm_rst);\n\tif (err) {\n\t\tdev_err(dev, \"deassert pm_rst err %d\\n\", err);\n\t\tgoto err_exit_phy;\n\t}\n\n\terr = reset_control_deassert(rockchip->aclk_rst);\n\tif (err) {\n\t\tdev_err(dev, \"deassert aclk_rst err %d\\n\", err);\n\t\tgoto err_exit_phy;\n\t}\n\n\terr = reset_control_deassert(rockchip->pclk_rst);\n\tif (err) {\n\t\tdev_err(dev, \"deassert pclk_rst err %d\\n\", err);\n\t\tgoto err_exit_phy;\n\t}\n\n\tif (rockchip->link_gen == 2)\n\t\trockchip_pcie_write(rockchip, PCIE_CLIENT_GEN_SEL_2,\n\t\t\t\t    PCIE_CLIENT_CONFIG);\n\telse\n\t\trockchip_pcie_write(rockchip, PCIE_CLIENT_GEN_SEL_1,\n\t\t\t\t    PCIE_CLIENT_CONFIG);\n\n\tregs = PCIE_CLIENT_LINK_TRAIN_ENABLE | PCIE_CLIENT_ARI_ENABLE |\n\t       PCIE_CLIENT_CONF_LANE_NUM(rockchip->lanes);\n\n\tif (rockchip->is_rc)\n\t\tregs |= PCIE_CLIENT_CONF_ENABLE | PCIE_CLIENT_MODE_RC;\n\telse\n\t\tregs |= PCIE_CLIENT_CONF_DISABLE | PCIE_CLIENT_MODE_EP;\n\n\trockchip_pcie_write(rockchip, regs, PCIE_CLIENT_CONFIG);\n\n\tfor (i = 0; i < MAX_LANE_NUM; i++) {\n\t\terr = phy_power_on(rockchip->phys[i]);\n\t\tif (err) {\n\t\t\tdev_err(dev, \"power on phy%d err %d\\n\", i, err);\n\t\t\tgoto err_power_off_phy;\n\t\t}\n\t}\n\n\terr = readx_poll_timeout(rockchip_pcie_read_addr,\n\t\t\t\t PCIE_CLIENT_SIDE_BAND_STATUS,\n\t\t\t\t regs, !(regs & PCIE_CLIENT_PHY_ST),\n\t\t\t\t RK_PHY_PLL_LOCK_SLEEP_US,\n\t\t\t\t RK_PHY_PLL_LOCK_TIMEOUT_US);\n\tif (err) {\n\t\tdev_err(dev, \"PHY PLLs could not lock, %d\\n\", err);\n\t\tgoto err_power_off_phy;\n\t}\n\n\t \n\terr = reset_control_deassert(rockchip->mgmt_sticky_rst);\n\tif (err) {\n\t\tdev_err(dev, \"deassert mgmt_sticky_rst err %d\\n\", err);\n\t\tgoto err_power_off_phy;\n\t}\n\n\terr = reset_control_deassert(rockchip->core_rst);\n\tif (err) {\n\t\tdev_err(dev, \"deassert core_rst err %d\\n\", err);\n\t\tgoto err_power_off_phy;\n\t}\n\n\terr = reset_control_deassert(rockchip->mgmt_rst);\n\tif (err) {\n\t\tdev_err(dev, \"deassert mgmt_rst err %d\\n\", err);\n\t\tgoto err_power_off_phy;\n\t}\n\n\terr = reset_control_deassert(rockchip->pipe_rst);\n\tif (err) {\n\t\tdev_err(dev, \"deassert pipe_rst err %d\\n\", err);\n\t\tgoto err_power_off_phy;\n\t}\n\n\treturn 0;\nerr_power_off_phy:\n\twhile (i--)\n\t\tphy_power_off(rockchip->phys[i]);\n\ti = MAX_LANE_NUM;\nerr_exit_phy:\n\twhile (i--)\n\t\tphy_exit(rockchip->phys[i]);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(rockchip_pcie_init_port);\n\nint rockchip_pcie_get_phys(struct rockchip_pcie *rockchip)\n{\n\tstruct device *dev = rockchip->dev;\n\tstruct phy *phy;\n\tchar *name;\n\tu32 i;\n\n\tphy = devm_phy_get(dev, \"pcie-phy\");\n\tif (!IS_ERR(phy)) {\n\t\trockchip->legacy_phy = true;\n\t\trockchip->phys[0] = phy;\n\t\tdev_warn(dev, \"legacy phy model is deprecated!\\n\");\n\t\treturn 0;\n\t}\n\n\tif (PTR_ERR(phy) == -EPROBE_DEFER)\n\t\treturn PTR_ERR(phy);\n\n\tdev_dbg(dev, \"missing legacy phy; search for per-lane PHY\\n\");\n\n\tfor (i = 0; i < MAX_LANE_NUM; i++) {\n\t\tname = kasprintf(GFP_KERNEL, \"pcie-phy-%u\", i);\n\t\tif (!name)\n\t\t\treturn -ENOMEM;\n\n\t\tphy = devm_of_phy_get(dev, dev->of_node, name);\n\t\tkfree(name);\n\n\t\tif (IS_ERR(phy)) {\n\t\t\tif (PTR_ERR(phy) != -EPROBE_DEFER)\n\t\t\t\tdev_err(dev, \"missing phy for lane %d: %ld\\n\",\n\t\t\t\t\ti, PTR_ERR(phy));\n\t\t\treturn PTR_ERR(phy);\n\t\t}\n\n\t\trockchip->phys[i] = phy;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(rockchip_pcie_get_phys);\n\nvoid rockchip_pcie_deinit_phys(struct rockchip_pcie *rockchip)\n{\n\tint i;\n\n\tfor (i = 0; i < MAX_LANE_NUM; i++) {\n\t\t \n\t\tif (rockchip->lanes_map & BIT(i))\n\t\t\tphy_power_off(rockchip->phys[i]);\n\t\tphy_exit(rockchip->phys[i]);\n\t}\n}\nEXPORT_SYMBOL_GPL(rockchip_pcie_deinit_phys);\n\nint rockchip_pcie_enable_clocks(struct rockchip_pcie *rockchip)\n{\n\tstruct device *dev = rockchip->dev;\n\tint err;\n\n\terr = clk_prepare_enable(rockchip->aclk_pcie);\n\tif (err) {\n\t\tdev_err(dev, \"unable to enable aclk_pcie clock\\n\");\n\t\treturn err;\n\t}\n\n\terr = clk_prepare_enable(rockchip->aclk_perf_pcie);\n\tif (err) {\n\t\tdev_err(dev, \"unable to enable aclk_perf_pcie clock\\n\");\n\t\tgoto err_aclk_perf_pcie;\n\t}\n\n\terr = clk_prepare_enable(rockchip->hclk_pcie);\n\tif (err) {\n\t\tdev_err(dev, \"unable to enable hclk_pcie clock\\n\");\n\t\tgoto err_hclk_pcie;\n\t}\n\n\terr = clk_prepare_enable(rockchip->clk_pcie_pm);\n\tif (err) {\n\t\tdev_err(dev, \"unable to enable clk_pcie_pm clock\\n\");\n\t\tgoto err_clk_pcie_pm;\n\t}\n\n\treturn 0;\n\nerr_clk_pcie_pm:\n\tclk_disable_unprepare(rockchip->hclk_pcie);\nerr_hclk_pcie:\n\tclk_disable_unprepare(rockchip->aclk_perf_pcie);\nerr_aclk_perf_pcie:\n\tclk_disable_unprepare(rockchip->aclk_pcie);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(rockchip_pcie_enable_clocks);\n\nvoid rockchip_pcie_disable_clocks(void *data)\n{\n\tstruct rockchip_pcie *rockchip = data;\n\n\tclk_disable_unprepare(rockchip->clk_pcie_pm);\n\tclk_disable_unprepare(rockchip->hclk_pcie);\n\tclk_disable_unprepare(rockchip->aclk_perf_pcie);\n\tclk_disable_unprepare(rockchip->aclk_pcie);\n}\nEXPORT_SYMBOL_GPL(rockchip_pcie_disable_clocks);\n\nvoid rockchip_pcie_cfg_configuration_accesses(\n\t\tstruct rockchip_pcie *rockchip, u32 type)\n{\n\tu32 ob_desc_0;\n\n\t \n\trockchip_pcie_write(rockchip, 0x0, PCIE_RC_BAR_CONF);\n\n\trockchip_pcie_write(rockchip,\n\t\t\t    (RC_REGION_0_ADDR_TRANS_L + RC_REGION_0_PASS_BITS),\n\t\t\t    PCIE_CORE_OB_REGION_ADDR0);\n\trockchip_pcie_write(rockchip, RC_REGION_0_ADDR_TRANS_H,\n\t\t\t    PCIE_CORE_OB_REGION_ADDR1);\n\tob_desc_0 = rockchip_pcie_read(rockchip, PCIE_CORE_OB_REGION_DESC0);\n\tob_desc_0 &= ~(RC_REGION_0_TYPE_MASK);\n\tob_desc_0 |= (type | (0x1 << 23));\n\trockchip_pcie_write(rockchip, ob_desc_0, PCIE_CORE_OB_REGION_DESC0);\n\trockchip_pcie_write(rockchip, 0x0, PCIE_CORE_OB_REGION_DESC1);\n}\nEXPORT_SYMBOL_GPL(rockchip_pcie_cfg_configuration_accesses);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}