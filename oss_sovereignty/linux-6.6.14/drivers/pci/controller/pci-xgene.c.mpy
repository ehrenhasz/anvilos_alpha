{
  "module_name": "pci-xgene.c",
  "hash_id": "ded21ed37e2147813851d5151f8463eb44095d3f7ded20f95fddf43303363209",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/controller/pci-xgene.c",
  "human_readable_source": "\n \n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/jiffies.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_pci.h>\n#include <linux/pci.h>\n#include <linux/pci-acpi.h>\n#include <linux/pci-ecam.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n\n#include \"../pci.h\"\n\n#define PCIECORE_CTLANDSTATUS\t\t0x50\n#define PIM1_1L\t\t\t\t0x80\n#define IBAR2\t\t\t\t0x98\n#define IR2MSK\t\t\t\t0x9c\n#define PIM2_1L\t\t\t\t0xa0\n#define IBAR3L\t\t\t\t0xb4\n#define IR3MSKL\t\t\t\t0xbc\n#define PIM3_1L\t\t\t\t0xc4\n#define OMR1BARL\t\t\t0x100\n#define OMR2BARL\t\t\t0x118\n#define OMR3BARL\t\t\t0x130\n#define CFGBARL\t\t\t\t0x154\n#define CFGBARH\t\t\t\t0x158\n#define CFGCTL\t\t\t\t0x15c\n#define RTDID\t\t\t\t0x160\n#define BRIDGE_CFG_0\t\t\t0x2000\n#define BRIDGE_CFG_4\t\t\t0x2010\n#define BRIDGE_STATUS_0\t\t\t0x2600\n\n#define LINK_UP_MASK\t\t\t0x00000100\n#define AXI_EP_CFG_ACCESS\t\t0x10000\n#define EN_COHERENCY\t\t\t0xF0000000\n#define EN_REG\t\t\t\t0x00000001\n#define OB_LO_IO\t\t\t0x00000002\n#define XGENE_PCIE_DEVICEID\t\t0xE004\n#define PIPE_PHY_RATE_RD(src)\t\t((0xc000 & (u32)(src)) >> 0xe)\n\n#define XGENE_V1_PCI_EXP_CAP\t\t0x40\n\n \n#define XGENE_PCIE_IP_VER_UNKN\t\t0\n#define XGENE_PCIE_IP_VER_1\t\t1\n#define XGENE_PCIE_IP_VER_2\t\t2\n\n#if defined(CONFIG_PCI_XGENE) || (defined(CONFIG_ACPI) && defined(CONFIG_PCI_QUIRKS))\nstruct xgene_pcie {\n\tstruct device_node\t*node;\n\tstruct device\t\t*dev;\n\tstruct clk\t\t*clk;\n\tvoid __iomem\t\t*csr_base;\n\tvoid __iomem\t\t*cfg_base;\n\tunsigned long\t\tcfg_addr;\n\tbool\t\t\tlink_up;\n\tu32\t\t\tversion;\n};\n\nstatic u32 xgene_pcie_readl(struct xgene_pcie *port, u32 reg)\n{\n\treturn readl(port->csr_base + reg);\n}\n\nstatic void xgene_pcie_writel(struct xgene_pcie *port, u32 reg, u32 val)\n{\n\twritel(val, port->csr_base + reg);\n}\n\nstatic inline u32 pcie_bar_low_val(u32 addr, u32 flags)\n{\n\treturn (addr & PCI_BASE_ADDRESS_MEM_MASK) | flags;\n}\n\nstatic inline struct xgene_pcie *pcie_bus_to_port(struct pci_bus *bus)\n{\n\tstruct pci_config_window *cfg;\n\n\tif (acpi_disabled)\n\t\treturn (struct xgene_pcie *)(bus->sysdata);\n\n\tcfg = bus->sysdata;\n\treturn (struct xgene_pcie *)(cfg->priv);\n}\n\n \nstatic void __iomem *xgene_pcie_get_cfg_base(struct pci_bus *bus)\n{\n\tstruct xgene_pcie *port = pcie_bus_to_port(bus);\n\n\tif (bus->number >= (bus->primary + 1))\n\t\treturn port->cfg_base + AXI_EP_CFG_ACCESS;\n\n\treturn port->cfg_base;\n}\n\n \nstatic void xgene_pcie_set_rtdid_reg(struct pci_bus *bus, uint devfn)\n{\n\tstruct xgene_pcie *port = pcie_bus_to_port(bus);\n\tunsigned int b, d, f;\n\tu32 rtdid_val = 0;\n\n\tb = bus->number;\n\td = PCI_SLOT(devfn);\n\tf = PCI_FUNC(devfn);\n\n\tif (!pci_is_root_bus(bus))\n\t\trtdid_val = (b << 8) | (d << 3) | f;\n\n\txgene_pcie_writel(port, RTDID, rtdid_val);\n\t \n\txgene_pcie_readl(port, RTDID);\n}\n\n \nstatic bool xgene_pcie_hide_rc_bars(struct pci_bus *bus, int offset)\n{\n\tif (pci_is_root_bus(bus) && ((offset == PCI_BASE_ADDRESS_0) ||\n\t\t\t\t     (offset == PCI_BASE_ADDRESS_1)))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic void __iomem *xgene_pcie_map_bus(struct pci_bus *bus, unsigned int devfn,\n\t\t\t\t\tint offset)\n{\n\tif ((pci_is_root_bus(bus) && devfn != 0) ||\n\t    xgene_pcie_hide_rc_bars(bus, offset))\n\t\treturn NULL;\n\n\txgene_pcie_set_rtdid_reg(bus, devfn);\n\treturn xgene_pcie_get_cfg_base(bus) + offset;\n}\n\nstatic int xgene_pcie_config_read32(struct pci_bus *bus, unsigned int devfn,\n\t\t\t\t    int where, int size, u32 *val)\n{\n\tstruct xgene_pcie *port = pcie_bus_to_port(bus);\n\n\tif (pci_generic_config_read32(bus, devfn, where & ~0x3, 4, val) !=\n\t    PCIBIOS_SUCCESSFUL)\n\t\treturn PCIBIOS_DEVICE_NOT_FOUND;\n\n\t \n\tif (pci_is_root_bus(bus) && (port->version == XGENE_PCIE_IP_VER_1) &&\n\t    ((where & ~0x3) == XGENE_V1_PCI_EXP_CAP + PCI_EXP_RTCTL))\n\t\t*val &= ~(PCI_EXP_RTCAP_CRSVIS << 16);\n\n\tif (size <= 2)\n\t\t*val = (*val >> (8 * (where & 3))) & ((1 << (size * 8)) - 1);\n\n\treturn PCIBIOS_SUCCESSFUL;\n}\n#endif\n\n#if defined(CONFIG_ACPI) && defined(CONFIG_PCI_QUIRKS)\nstatic int xgene_get_csr_resource(struct acpi_device *adev,\n\t\t\t\t  struct resource *res)\n{\n\tstruct device *dev = &adev->dev;\n\tstruct resource_entry *entry;\n\tstruct list_head list;\n\tunsigned long flags;\n\tint ret;\n\n\tINIT_LIST_HEAD(&list);\n\tflags = IORESOURCE_MEM;\n\tret = acpi_dev_get_resources(adev, &list,\n\t\t\t\t     acpi_dev_filter_resource_type_cb,\n\t\t\t\t     (void *) flags);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to parse _CRS method, error code %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tif (ret == 0) {\n\t\tdev_err(dev, \"no IO and memory resources present in _CRS\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tentry = list_first_entry(&list, struct resource_entry, node);\n\t*res = *entry->res;\n\tacpi_dev_free_resource_list(&list);\n\treturn 0;\n}\n\nstatic int xgene_pcie_ecam_init(struct pci_config_window *cfg, u32 ipversion)\n{\n\tstruct device *dev = cfg->parent;\n\tstruct acpi_device *adev = to_acpi_device(dev);\n\tstruct xgene_pcie *port;\n\tstruct resource csr;\n\tint ret;\n\n\tport = devm_kzalloc(dev, sizeof(*port), GFP_KERNEL);\n\tif (!port)\n\t\treturn -ENOMEM;\n\n\tret = xgene_get_csr_resource(adev, &csr);\n\tif (ret) {\n\t\tdev_err(dev, \"can't get CSR resource\\n\");\n\t\treturn ret;\n\t}\n\tport->csr_base = devm_pci_remap_cfg_resource(dev, &csr);\n\tif (IS_ERR(port->csr_base))\n\t\treturn PTR_ERR(port->csr_base);\n\n\tport->cfg_base = cfg->win;\n\tport->version = ipversion;\n\n\tcfg->priv = port;\n\treturn 0;\n}\n\nstatic int xgene_v1_pcie_ecam_init(struct pci_config_window *cfg)\n{\n\treturn xgene_pcie_ecam_init(cfg, XGENE_PCIE_IP_VER_1);\n}\n\nconst struct pci_ecam_ops xgene_v1_pcie_ecam_ops = {\n\t.init\t\t= xgene_v1_pcie_ecam_init,\n\t.pci_ops\t= {\n\t\t.map_bus\t= xgene_pcie_map_bus,\n\t\t.read\t\t= xgene_pcie_config_read32,\n\t\t.write\t\t= pci_generic_config_write,\n\t}\n};\n\nstatic int xgene_v2_pcie_ecam_init(struct pci_config_window *cfg)\n{\n\treturn xgene_pcie_ecam_init(cfg, XGENE_PCIE_IP_VER_2);\n}\n\nconst struct pci_ecam_ops xgene_v2_pcie_ecam_ops = {\n\t.init\t\t= xgene_v2_pcie_ecam_init,\n\t.pci_ops\t= {\n\t\t.map_bus\t= xgene_pcie_map_bus,\n\t\t.read\t\t= xgene_pcie_config_read32,\n\t\t.write\t\t= pci_generic_config_write,\n\t}\n};\n#endif\n\n#if defined(CONFIG_PCI_XGENE)\nstatic u64 xgene_pcie_set_ib_mask(struct xgene_pcie *port, u32 addr,\n\t\t\t\t  u32 flags, u64 size)\n{\n\tu64 mask = (~(size - 1) & PCI_BASE_ADDRESS_MEM_MASK) | flags;\n\tu32 val32 = 0;\n\tu32 val;\n\n\tval32 = xgene_pcie_readl(port, addr);\n\tval = (val32 & 0x0000ffff) | (lower_32_bits(mask) << 16);\n\txgene_pcie_writel(port, addr, val);\n\n\tval32 = xgene_pcie_readl(port, addr + 0x04);\n\tval = (val32 & 0xffff0000) | (lower_32_bits(mask) >> 16);\n\txgene_pcie_writel(port, addr + 0x04, val);\n\n\tval32 = xgene_pcie_readl(port, addr + 0x04);\n\tval = (val32 & 0x0000ffff) | (upper_32_bits(mask) << 16);\n\txgene_pcie_writel(port, addr + 0x04, val);\n\n\tval32 = xgene_pcie_readl(port, addr + 0x08);\n\tval = (val32 & 0xffff0000) | (upper_32_bits(mask) >> 16);\n\txgene_pcie_writel(port, addr + 0x08, val);\n\n\treturn mask;\n}\n\nstatic void xgene_pcie_linkup(struct xgene_pcie *port,\n\t\t\t      u32 *lanes, u32 *speed)\n{\n\tu32 val32;\n\n\tport->link_up = false;\n\tval32 = xgene_pcie_readl(port, PCIECORE_CTLANDSTATUS);\n\tif (val32 & LINK_UP_MASK) {\n\t\tport->link_up = true;\n\t\t*speed = PIPE_PHY_RATE_RD(val32);\n\t\tval32 = xgene_pcie_readl(port, BRIDGE_STATUS_0);\n\t\t*lanes = val32 >> 26;\n\t}\n}\n\nstatic int xgene_pcie_init_port(struct xgene_pcie *port)\n{\n\tstruct device *dev = port->dev;\n\tint rc;\n\n\tport->clk = clk_get(dev, NULL);\n\tif (IS_ERR(port->clk)) {\n\t\tdev_err(dev, \"clock not available\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\trc = clk_prepare_enable(port->clk);\n\tif (rc) {\n\t\tdev_err(dev, \"clock enable failed\\n\");\n\t\treturn rc;\n\t}\n\n\treturn 0;\n}\n\nstatic int xgene_pcie_map_reg(struct xgene_pcie *port,\n\t\t\t      struct platform_device *pdev)\n{\n\tstruct device *dev = port->dev;\n\tstruct resource *res;\n\n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"csr\");\n\tport->csr_base = devm_pci_remap_cfg_resource(dev, res);\n\tif (IS_ERR(port->csr_base))\n\t\treturn PTR_ERR(port->csr_base);\n\n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"cfg\");\n\tport->cfg_base = devm_ioremap_resource(dev, res);\n\tif (IS_ERR(port->cfg_base))\n\t\treturn PTR_ERR(port->cfg_base);\n\tport->cfg_addr = res->start;\n\n\treturn 0;\n}\n\nstatic void xgene_pcie_setup_ob_reg(struct xgene_pcie *port,\n\t\t\t\t    struct resource *res, u32 offset,\n\t\t\t\t    u64 cpu_addr, u64 pci_addr)\n{\n\tstruct device *dev = port->dev;\n\tresource_size_t size = resource_size(res);\n\tu64 restype = resource_type(res);\n\tu64 mask = 0;\n\tu32 min_size;\n\tu32 flag = EN_REG;\n\n\tif (restype == IORESOURCE_MEM) {\n\t\tmin_size = SZ_128M;\n\t} else {\n\t\tmin_size = 128;\n\t\tflag |= OB_LO_IO;\n\t}\n\n\tif (size >= min_size)\n\t\tmask = ~(size - 1) | flag;\n\telse\n\t\tdev_warn(dev, \"res size 0x%llx less than minimum 0x%x\\n\",\n\t\t\t (u64)size, min_size);\n\n\txgene_pcie_writel(port, offset, lower_32_bits(cpu_addr));\n\txgene_pcie_writel(port, offset + 0x04, upper_32_bits(cpu_addr));\n\txgene_pcie_writel(port, offset + 0x08, lower_32_bits(mask));\n\txgene_pcie_writel(port, offset + 0x0c, upper_32_bits(mask));\n\txgene_pcie_writel(port, offset + 0x10, lower_32_bits(pci_addr));\n\txgene_pcie_writel(port, offset + 0x14, upper_32_bits(pci_addr));\n}\n\nstatic void xgene_pcie_setup_cfg_reg(struct xgene_pcie *port)\n{\n\tu64 addr = port->cfg_addr;\n\n\txgene_pcie_writel(port, CFGBARL, lower_32_bits(addr));\n\txgene_pcie_writel(port, CFGBARH, upper_32_bits(addr));\n\txgene_pcie_writel(port, CFGCTL, EN_REG);\n}\n\nstatic int xgene_pcie_map_ranges(struct xgene_pcie *port)\n{\n\tstruct pci_host_bridge *bridge = pci_host_bridge_from_priv(port);\n\tstruct resource_entry *window;\n\tstruct device *dev = port->dev;\n\n\tresource_list_for_each_entry(window, &bridge->windows) {\n\t\tstruct resource *res = window->res;\n\t\tu64 restype = resource_type(res);\n\n\t\tdev_dbg(dev, \"%pR\\n\", res);\n\n\t\tswitch (restype) {\n\t\tcase IORESOURCE_IO:\n\t\t\txgene_pcie_setup_ob_reg(port, res, OMR3BARL,\n\t\t\t\t\t\tpci_pio_to_address(res->start),\n\t\t\t\t\t\tres->start - window->offset);\n\t\t\tbreak;\n\t\tcase IORESOURCE_MEM:\n\t\t\tif (res->flags & IORESOURCE_PREFETCH)\n\t\t\t\txgene_pcie_setup_ob_reg(port, res, OMR2BARL,\n\t\t\t\t\t\t\tres->start,\n\t\t\t\t\t\t\tres->start -\n\t\t\t\t\t\t\twindow->offset);\n\t\t\telse\n\t\t\t\txgene_pcie_setup_ob_reg(port, res, OMR1BARL,\n\t\t\t\t\t\t\tres->start,\n\t\t\t\t\t\t\tres->start -\n\t\t\t\t\t\t\twindow->offset);\n\t\t\tbreak;\n\t\tcase IORESOURCE_BUS:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(dev, \"invalid resource %pR\\n\", res);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\txgene_pcie_setup_cfg_reg(port);\n\treturn 0;\n}\n\nstatic void xgene_pcie_setup_pims(struct xgene_pcie *port, u32 pim_reg,\n\t\t\t\t  u64 pim, u64 size)\n{\n\txgene_pcie_writel(port, pim_reg, lower_32_bits(pim));\n\txgene_pcie_writel(port, pim_reg + 0x04,\n\t\t\t  upper_32_bits(pim) | EN_COHERENCY);\n\txgene_pcie_writel(port, pim_reg + 0x10, lower_32_bits(size));\n\txgene_pcie_writel(port, pim_reg + 0x14, upper_32_bits(size));\n}\n\n \nstatic int xgene_pcie_select_ib_reg(u8 *ib_reg_mask, u64 size)\n{\n\tif ((size > 4) && (size < SZ_16M) && !(*ib_reg_mask & (1 << 1))) {\n\t\t*ib_reg_mask |= (1 << 1);\n\t\treturn 1;\n\t}\n\n\tif ((size > SZ_1K) && (size < SZ_1T) && !(*ib_reg_mask & (1 << 0))) {\n\t\t*ib_reg_mask |= (1 << 0);\n\t\treturn 0;\n\t}\n\n\tif ((size > SZ_1M) && (size < SZ_1T) && !(*ib_reg_mask & (1 << 2))) {\n\t\t*ib_reg_mask |= (1 << 2);\n\t\treturn 2;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic void xgene_pcie_setup_ib_reg(struct xgene_pcie *port,\n\t\t\t\t    struct of_pci_range *range, u8 *ib_reg_mask)\n{\n\tvoid __iomem *cfg_base = port->cfg_base;\n\tstruct device *dev = port->dev;\n\tvoid __iomem *bar_addr;\n\tu32 pim_reg;\n\tu64 cpu_addr = range->cpu_addr;\n\tu64 pci_addr = range->pci_addr;\n\tu64 size = range->size;\n\tu64 mask = ~(size - 1) | EN_REG;\n\tu32 flags = PCI_BASE_ADDRESS_MEM_TYPE_64;\n\tu32 bar_low;\n\tint region;\n\n\tregion = xgene_pcie_select_ib_reg(ib_reg_mask, range->size);\n\tif (region < 0) {\n\t\tdev_warn(dev, \"invalid pcie dma-range config\\n\");\n\t\treturn;\n\t}\n\n\tif (range->flags & IORESOURCE_PREFETCH)\n\t\tflags |= PCI_BASE_ADDRESS_MEM_PREFETCH;\n\n\tbar_low = pcie_bar_low_val((u32)cpu_addr, flags);\n\tswitch (region) {\n\tcase 0:\n\t\txgene_pcie_set_ib_mask(port, BRIDGE_CFG_4, flags, size);\n\t\tbar_addr = cfg_base + PCI_BASE_ADDRESS_0;\n\t\twritel(bar_low, bar_addr);\n\t\twritel(upper_32_bits(cpu_addr), bar_addr + 0x4);\n\t\tpim_reg = PIM1_1L;\n\t\tbreak;\n\tcase 1:\n\t\txgene_pcie_writel(port, IBAR2, bar_low);\n\t\txgene_pcie_writel(port, IR2MSK, lower_32_bits(mask));\n\t\tpim_reg = PIM2_1L;\n\t\tbreak;\n\tcase 2:\n\t\txgene_pcie_writel(port, IBAR3L, bar_low);\n\t\txgene_pcie_writel(port, IBAR3L + 0x4, upper_32_bits(cpu_addr));\n\t\txgene_pcie_writel(port, IR3MSKL, lower_32_bits(mask));\n\t\txgene_pcie_writel(port, IR3MSKL + 0x4, upper_32_bits(mask));\n\t\tpim_reg = PIM3_1L;\n\t\tbreak;\n\t}\n\n\txgene_pcie_setup_pims(port, pim_reg, pci_addr, ~(size - 1));\n}\n\nstatic int xgene_pcie_parse_map_dma_ranges(struct xgene_pcie *port)\n{\n\tstruct device_node *np = port->node;\n\tstruct of_pci_range range;\n\tstruct of_pci_range_parser parser;\n\tstruct device *dev = port->dev;\n\tu8 ib_reg_mask = 0;\n\n\tif (of_pci_dma_range_parser_init(&parser, np)) {\n\t\tdev_err(dev, \"missing dma-ranges property\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tfor_each_of_pci_range(&parser, &range) {\n\t\tu64 end = range.cpu_addr + range.size - 1;\n\n\t\tdev_dbg(dev, \"0x%08x 0x%016llx..0x%016llx -> 0x%016llx\\n\",\n\t\t\trange.flags, range.cpu_addr, end, range.pci_addr);\n\t\txgene_pcie_setup_ib_reg(port, &range, &ib_reg_mask);\n\t}\n\treturn 0;\n}\n\n \nstatic void xgene_pcie_clear_config(struct xgene_pcie *port)\n{\n\tint i;\n\n\tfor (i = PIM1_1L; i <= CFGCTL; i += 4)\n\t\txgene_pcie_writel(port, i, 0);\n}\n\nstatic int xgene_pcie_setup(struct xgene_pcie *port)\n{\n\tstruct device *dev = port->dev;\n\tu32 val, lanes = 0, speed = 0;\n\tint ret;\n\n\txgene_pcie_clear_config(port);\n\n\t \n\tval = (XGENE_PCIE_DEVICEID << 16) | PCI_VENDOR_ID_AMCC;\n\txgene_pcie_writel(port, BRIDGE_CFG_0, val);\n\n\tret = xgene_pcie_map_ranges(port);\n\tif (ret)\n\t\treturn ret;\n\n\tret = xgene_pcie_parse_map_dma_ranges(port);\n\tif (ret)\n\t\treturn ret;\n\n\txgene_pcie_linkup(port, &lanes, &speed);\n\tif (!port->link_up)\n\t\tdev_info(dev, \"(rc) link down\\n\");\n\telse\n\t\tdev_info(dev, \"(rc) x%d gen-%d link up\\n\", lanes, speed + 1);\n\treturn 0;\n}\n\nstatic struct pci_ops xgene_pcie_ops = {\n\t.map_bus = xgene_pcie_map_bus,\n\t.read = xgene_pcie_config_read32,\n\t.write = pci_generic_config_write32,\n};\n\nstatic int xgene_pcie_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *dn = dev->of_node;\n\tstruct xgene_pcie *port;\n\tstruct pci_host_bridge *bridge;\n\tint ret;\n\n\tbridge = devm_pci_alloc_host_bridge(dev, sizeof(*port));\n\tif (!bridge)\n\t\treturn -ENOMEM;\n\n\tport = pci_host_bridge_priv(bridge);\n\n\tport->node = of_node_get(dn);\n\tport->dev = dev;\n\n\tport->version = XGENE_PCIE_IP_VER_UNKN;\n\tif (of_device_is_compatible(port->node, \"apm,xgene-pcie\"))\n\t\tport->version = XGENE_PCIE_IP_VER_1;\n\n\tret = xgene_pcie_map_reg(port, pdev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = xgene_pcie_init_port(port);\n\tif (ret)\n\t\treturn ret;\n\n\tret = xgene_pcie_setup(port);\n\tif (ret)\n\t\treturn ret;\n\n\tbridge->sysdata = port;\n\tbridge->ops = &xgene_pcie_ops;\n\n\treturn pci_host_probe(bridge);\n}\n\nstatic const struct of_device_id xgene_pcie_match_table[] = {\n\t{.compatible = \"apm,xgene-pcie\",},\n\t{},\n};\n\nstatic struct platform_driver xgene_pcie_driver = {\n\t.driver = {\n\t\t.name = \"xgene-pcie\",\n\t\t.of_match_table = xgene_pcie_match_table,\n\t\t.suppress_bind_attrs = true,\n\t},\n\t.probe = xgene_pcie_probe,\n};\nbuiltin_platform_driver(xgene_pcie_driver);\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}