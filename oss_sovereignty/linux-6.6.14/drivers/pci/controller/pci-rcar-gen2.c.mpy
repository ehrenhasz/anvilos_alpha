{
  "module_name": "pci-rcar-gen2.c",
  "hash_id": "36706c3326e1c5107021dd8d6605df630af043c9a9a9771b4bbe9628866c1e30",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/controller/pci-rcar-gen2.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/of_address.h>\n#include <linux/of_pci.h>\n#include <linux/pci.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/sizes.h>\n#include <linux/slab.h>\n\n#include \"../pci.h\"\n\n \n#define RCAR_AHBPCI_PCICOM_OFFSET\t0x800\n\n#define RCAR_PCIAHB_WIN1_CTR_REG\t(RCAR_AHBPCI_PCICOM_OFFSET + 0x00)\n#define RCAR_PCIAHB_WIN2_CTR_REG\t(RCAR_AHBPCI_PCICOM_OFFSET + 0x04)\n#define RCAR_PCIAHB_PREFETCH0\t\t0x0\n#define RCAR_PCIAHB_PREFETCH4\t\t0x1\n#define RCAR_PCIAHB_PREFETCH8\t\t0x2\n#define RCAR_PCIAHB_PREFETCH16\t\t0x3\n\n#define RCAR_AHBPCI_WIN1_CTR_REG\t(RCAR_AHBPCI_PCICOM_OFFSET + 0x10)\n#define RCAR_AHBPCI_WIN2_CTR_REG\t(RCAR_AHBPCI_PCICOM_OFFSET + 0x14)\n#define RCAR_AHBPCI_WIN_CTR_MEM\t\t(3 << 1)\n#define RCAR_AHBPCI_WIN_CTR_CFG\t\t(5 << 1)\n#define RCAR_AHBPCI_WIN1_HOST\t\t(1 << 30)\n#define RCAR_AHBPCI_WIN1_DEVICE\t\t(1 << 31)\n\n#define RCAR_PCI_INT_ENABLE_REG\t\t(RCAR_AHBPCI_PCICOM_OFFSET + 0x20)\n#define RCAR_PCI_INT_STATUS_REG\t\t(RCAR_AHBPCI_PCICOM_OFFSET + 0x24)\n#define RCAR_PCI_INT_SIGTABORT\t\t(1 << 0)\n#define RCAR_PCI_INT_SIGRETABORT\t(1 << 1)\n#define RCAR_PCI_INT_REMABORT\t\t(1 << 2)\n#define RCAR_PCI_INT_PERR\t\t(1 << 3)\n#define RCAR_PCI_INT_SIGSERR\t\t(1 << 4)\n#define RCAR_PCI_INT_RESERR\t\t(1 << 5)\n#define RCAR_PCI_INT_WIN1ERR\t\t(1 << 12)\n#define RCAR_PCI_INT_WIN2ERR\t\t(1 << 13)\n#define RCAR_PCI_INT_A\t\t\t(1 << 16)\n#define RCAR_PCI_INT_B\t\t\t(1 << 17)\n#define RCAR_PCI_INT_PME\t\t(1 << 19)\n#define RCAR_PCI_INT_ALLERRORS (RCAR_PCI_INT_SIGTABORT\t\t| \\\n\t\t\t\tRCAR_PCI_INT_SIGRETABORT\t| \\\n\t\t\t\tRCAR_PCI_INT_REMABORT\t\t| \\\n\t\t\t\tRCAR_PCI_INT_PERR\t\t| \\\n\t\t\t\tRCAR_PCI_INT_SIGSERR\t\t| \\\n\t\t\t\tRCAR_PCI_INT_RESERR\t\t| \\\n\t\t\t\tRCAR_PCI_INT_WIN1ERR\t\t| \\\n\t\t\t\tRCAR_PCI_INT_WIN2ERR)\n\n#define RCAR_AHB_BUS_CTR_REG\t\t(RCAR_AHBPCI_PCICOM_OFFSET + 0x30)\n#define RCAR_AHB_BUS_MMODE_HTRANS\t(1 << 0)\n#define RCAR_AHB_BUS_MMODE_BYTE_BURST\t(1 << 1)\n#define RCAR_AHB_BUS_MMODE_WR_INCR\t(1 << 2)\n#define RCAR_AHB_BUS_MMODE_HBUS_REQ\t(1 << 7)\n#define RCAR_AHB_BUS_SMODE_READYCTR\t(1 << 17)\n#define RCAR_AHB_BUS_MODE\t\t(RCAR_AHB_BUS_MMODE_HTRANS |\t\\\n\t\t\t\t\tRCAR_AHB_BUS_MMODE_BYTE_BURST |\t\\\n\t\t\t\t\tRCAR_AHB_BUS_MMODE_WR_INCR |\t\\\n\t\t\t\t\tRCAR_AHB_BUS_MMODE_HBUS_REQ |\t\\\n\t\t\t\t\tRCAR_AHB_BUS_SMODE_READYCTR)\n\n#define RCAR_USBCTR_REG\t\t\t(RCAR_AHBPCI_PCICOM_OFFSET + 0x34)\n#define RCAR_USBCTR_USBH_RST\t\t(1 << 0)\n#define RCAR_USBCTR_PCICLK_MASK\t\t(1 << 1)\n#define RCAR_USBCTR_PLL_RST\t\t(1 << 2)\n#define RCAR_USBCTR_DIRPD\t\t(1 << 8)\n#define RCAR_USBCTR_PCIAHB_WIN2_EN\t(1 << 9)\n#define RCAR_USBCTR_PCIAHB_WIN1_256M\t(0 << 10)\n#define RCAR_USBCTR_PCIAHB_WIN1_512M\t(1 << 10)\n#define RCAR_USBCTR_PCIAHB_WIN1_1G\t(2 << 10)\n#define RCAR_USBCTR_PCIAHB_WIN1_2G\t(3 << 10)\n#define RCAR_USBCTR_PCIAHB_WIN1_MASK\t(3 << 10)\n\n#define RCAR_PCI_ARBITER_CTR_REG\t(RCAR_AHBPCI_PCICOM_OFFSET + 0x40)\n#define RCAR_PCI_ARBITER_PCIREQ0\t(1 << 0)\n#define RCAR_PCI_ARBITER_PCIREQ1\t(1 << 1)\n#define RCAR_PCI_ARBITER_PCIBP_MODE\t(1 << 12)\n\n#define RCAR_PCI_UNIT_REV_REG\t\t(RCAR_AHBPCI_PCICOM_OFFSET + 0x48)\n\nstruct rcar_pci {\n\tstruct device *dev;\n\tvoid __iomem *reg;\n\tstruct resource mem_res;\n\tstruct resource *cfg_res;\n\tint irq;\n};\n\n \nstatic void __iomem *rcar_pci_cfg_base(struct pci_bus *bus, unsigned int devfn,\n\t\t\t\t       int where)\n{\n\tstruct rcar_pci *priv = bus->sysdata;\n\tint slot, val;\n\n\tif (!pci_is_root_bus(bus) || PCI_FUNC(devfn))\n\t\treturn NULL;\n\n\t \n\tslot = PCI_SLOT(devfn);\n\tif (slot > 2)\n\t\treturn NULL;\n\n\t \n\tif (slot == 0x0 && where >= 0x40)\n\t\treturn NULL;\n\n\tval = slot ? RCAR_AHBPCI_WIN1_DEVICE | RCAR_AHBPCI_WIN_CTR_CFG :\n\t\t     RCAR_AHBPCI_WIN1_HOST | RCAR_AHBPCI_WIN_CTR_CFG;\n\n\tiowrite32(val, priv->reg + RCAR_AHBPCI_WIN1_CTR_REG);\n\treturn priv->reg + (slot >> 1) * 0x100 + where;\n}\n\n#ifdef CONFIG_PCI_DEBUG\n \n\nstatic irqreturn_t rcar_pci_err_irq(int irq, void *pw)\n{\n\tstruct rcar_pci *priv = pw;\n\tstruct device *dev = priv->dev;\n\tu32 status = ioread32(priv->reg + RCAR_PCI_INT_STATUS_REG);\n\n\tif (status & RCAR_PCI_INT_ALLERRORS) {\n\t\tdev_err(dev, \"error irq: status %08x\\n\", status);\n\n\t\t \n\t\tiowrite32(status & RCAR_PCI_INT_ALLERRORS,\n\t\t\t  priv->reg + RCAR_PCI_INT_STATUS_REG);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\treturn IRQ_NONE;\n}\n\nstatic void rcar_pci_setup_errirq(struct rcar_pci *priv)\n{\n\tstruct device *dev = priv->dev;\n\tint ret;\n\tu32 val;\n\n\tret = devm_request_irq(dev, priv->irq, rcar_pci_err_irq,\n\t\t\t       IRQF_SHARED, \"error irq\", priv);\n\tif (ret) {\n\t\tdev_err(dev, \"cannot claim IRQ for error handling\\n\");\n\t\treturn;\n\t}\n\n\tval = ioread32(priv->reg + RCAR_PCI_INT_ENABLE_REG);\n\tval |= RCAR_PCI_INT_ALLERRORS;\n\tiowrite32(val, priv->reg + RCAR_PCI_INT_ENABLE_REG);\n}\n#else\nstatic inline void rcar_pci_setup_errirq(struct rcar_pci *priv) { }\n#endif\n\n \nstatic void rcar_pci_setup(struct rcar_pci *priv)\n{\n\tstruct pci_host_bridge *bridge = pci_host_bridge_from_priv(priv);\n\tstruct device *dev = priv->dev;\n\tvoid __iomem *reg = priv->reg;\n\tstruct resource_entry *entry;\n\tunsigned long window_size;\n\tunsigned long window_addr;\n\tunsigned long window_pci;\n\tu32 val;\n\n\tentry = resource_list_first_type(&bridge->dma_ranges, IORESOURCE_MEM);\n\tif (!entry) {\n\t\twindow_addr = 0x40000000;\n\t\twindow_pci = 0x40000000;\n\t\twindow_size = SZ_1G;\n\t} else {\n\t\twindow_addr = entry->res->start;\n\t\twindow_pci = entry->res->start - entry->offset;\n\t\twindow_size = resource_size(entry->res);\n\t}\n\n\tpm_runtime_enable(dev);\n\tpm_runtime_get_sync(dev);\n\n\tval = ioread32(reg + RCAR_PCI_UNIT_REV_REG);\n\tdev_info(dev, \"PCI: revision %x\\n\", val);\n\n\t \n\tval = ioread32(reg + RCAR_USBCTR_REG) & ~RCAR_USBCTR_DIRPD;\n\tval |= RCAR_USBCTR_USBH_RST | RCAR_USBCTR_PLL_RST;\n\tiowrite32(val, reg + RCAR_USBCTR_REG);\n\tudelay(4);\n\n\t \n\tval &= ~(RCAR_USBCTR_PCIAHB_WIN1_MASK | RCAR_USBCTR_PCICLK_MASK |\n\t\t RCAR_USBCTR_USBH_RST | RCAR_USBCTR_PLL_RST);\n\n\t \n\tswitch (window_size) {\n\tcase SZ_2G:\n\t\tval |= RCAR_USBCTR_PCIAHB_WIN1_2G;\n\t\tbreak;\n\tcase SZ_1G:\n\t\tval |= RCAR_USBCTR_PCIAHB_WIN1_1G;\n\t\tbreak;\n\tcase SZ_512M:\n\t\tval |= RCAR_USBCTR_PCIAHB_WIN1_512M;\n\t\tbreak;\n\tdefault:\n\t\tpr_warn(\"unknown window size %ld - defaulting to 256M\\n\",\n\t\t\twindow_size);\n\t\twindow_size = SZ_256M;\n\t\tfallthrough;\n\tcase SZ_256M:\n\t\tval |= RCAR_USBCTR_PCIAHB_WIN1_256M;\n\t\tbreak;\n\t}\n\tiowrite32(val, reg + RCAR_USBCTR_REG);\n\n\t \n\tiowrite32(RCAR_AHB_BUS_MODE, reg + RCAR_AHB_BUS_CTR_REG);\n\n\t \n\tval = ioread32(reg + RCAR_PCI_ARBITER_CTR_REG);\n\tval |= RCAR_PCI_ARBITER_PCIREQ0 | RCAR_PCI_ARBITER_PCIREQ1 |\n\t       RCAR_PCI_ARBITER_PCIBP_MODE;\n\tiowrite32(val, reg + RCAR_PCI_ARBITER_CTR_REG);\n\n\t \n\tiowrite32(window_addr | RCAR_PCIAHB_PREFETCH16,\n\t\t  reg + RCAR_PCIAHB_WIN1_CTR_REG);\n\n\t \n\tval = priv->mem_res.start | RCAR_AHBPCI_WIN_CTR_MEM;\n\tiowrite32(val, reg + RCAR_AHBPCI_WIN2_CTR_REG);\n\n\t \n\tiowrite32(RCAR_AHBPCI_WIN1_HOST | RCAR_AHBPCI_WIN_CTR_CFG,\n\t\t  reg + RCAR_AHBPCI_WIN1_CTR_REG);\n\t \n\tiowrite32(window_pci | PCI_BASE_ADDRESS_MEM_PREFETCH,\n\t\t  reg + PCI_BASE_ADDRESS_1);\n\t \n\tval = priv->cfg_res->start + RCAR_AHBPCI_PCICOM_OFFSET;\n\tiowrite32(val, reg + PCI_BASE_ADDRESS_0);\n\n\tval = ioread32(reg + PCI_COMMAND);\n\tval |= PCI_COMMAND_SERR | PCI_COMMAND_PARITY |\n\t       PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER;\n\tiowrite32(val, reg + PCI_COMMAND);\n\n\t \n\tiowrite32(RCAR_PCI_INT_A | RCAR_PCI_INT_B | RCAR_PCI_INT_PME,\n\t\t  reg + RCAR_PCI_INT_ENABLE_REG);\n\n\trcar_pci_setup_errirq(priv);\n}\n\nstatic struct pci_ops rcar_pci_ops = {\n\t.map_bus = rcar_pci_cfg_base,\n\t.read\t= pci_generic_config_read,\n\t.write\t= pci_generic_config_write,\n};\n\nstatic int rcar_pci_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct resource *cfg_res, *mem_res;\n\tstruct rcar_pci *priv;\n\tstruct pci_host_bridge *bridge;\n\tvoid __iomem *reg;\n\n\tbridge = devm_pci_alloc_host_bridge(dev, sizeof(*priv));\n\tif (!bridge)\n\t\treturn -ENOMEM;\n\n\tpriv = pci_host_bridge_priv(bridge);\n\tbridge->sysdata = priv;\n\n\treg = devm_platform_get_and_ioremap_resource(pdev, 0, &cfg_res);\n\tif (IS_ERR(reg))\n\t\treturn PTR_ERR(reg);\n\n\tmem_res = platform_get_resource(pdev, IORESOURCE_MEM, 1);\n\tif (!mem_res || !mem_res->start)\n\t\treturn -ENODEV;\n\n\tif (mem_res->start & 0xFFFF)\n\t\treturn -EINVAL;\n\n\tpriv->mem_res = *mem_res;\n\tpriv->cfg_res = cfg_res;\n\n\tpriv->irq = platform_get_irq(pdev, 0);\n\tpriv->reg = reg;\n\tpriv->dev = dev;\n\n\tif (priv->irq < 0) {\n\t\tdev_err(dev, \"no valid irq found\\n\");\n\t\treturn priv->irq;\n\t}\n\n\tbridge->ops = &rcar_pci_ops;\n\n\tpci_add_flags(PCI_REASSIGN_ALL_BUS);\n\n\trcar_pci_setup(priv);\n\n\treturn pci_host_probe(bridge);\n}\n\nstatic const struct of_device_id rcar_pci_of_match[] = {\n\t{ .compatible = \"renesas,pci-r8a7790\", },\n\t{ .compatible = \"renesas,pci-r8a7791\", },\n\t{ .compatible = \"renesas,pci-r8a7794\", },\n\t{ .compatible = \"renesas,pci-rcar-gen2\", },\n\t{ .compatible = \"renesas,pci-rzn1\", },\n\t{ },\n};\n\nstatic struct platform_driver rcar_pci_driver = {\n\t.driver = {\n\t\t.name = \"pci-rcar-gen2\",\n\t\t.suppress_bind_attrs = true,\n\t\t.of_match_table = rcar_pci_of_match,\n\t},\n\t.probe = rcar_pci_probe,\n};\nbuiltin_platform_driver(rcar_pci_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}