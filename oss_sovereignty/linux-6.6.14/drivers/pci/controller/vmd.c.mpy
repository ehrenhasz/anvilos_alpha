{
  "module_name": "vmd.c",
  "hash_id": "838a78fd84ce55239e128f8240c8d23c2215fced2f1bce6c15b4f19949006ea1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/controller/vmd.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/pci.h>\n#include <linux/pci-acpi.h>\n#include <linux/pci-ecam.h>\n#include <linux/srcu.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n\n#include <asm/irqdomain.h>\n\n#define VMD_CFGBAR\t0\n#define VMD_MEMBAR1\t2\n#define VMD_MEMBAR2\t4\n\n#define PCI_REG_VMCAP\t\t0x40\n#define BUS_RESTRICT_CAP(vmcap)\t(vmcap & 0x1)\n#define PCI_REG_VMCONFIG\t0x44\n#define BUS_RESTRICT_CFG(vmcfg)\t((vmcfg >> 8) & 0x3)\n#define VMCONFIG_MSI_REMAP\t0x2\n#define PCI_REG_VMLOCK\t\t0x70\n#define MB2_SHADOW_EN(vmlock)\t(vmlock & 0x2)\n\n#define MB2_SHADOW_OFFSET\t0x2000\n#define MB2_SHADOW_SIZE\t\t16\n\nenum vmd_features {\n\t \n\tVMD_FEAT_HAS_MEMBAR_SHADOW\t\t= (1 << 0),\n\n\t \n\tVMD_FEAT_HAS_BUS_RESTRICTIONS\t\t= (1 << 1),\n\n\t \n\tVMD_FEAT_HAS_MEMBAR_SHADOW_VSCAP\t= (1 << 2),\n\n\t \n\tVMD_FEAT_OFFSET_FIRST_VECTOR\t\t= (1 << 3),\n\n\t \n\tVMD_FEAT_CAN_BYPASS_MSI_REMAP\t\t= (1 << 4),\n\n\t \n\tVMD_FEAT_BIOS_PM_QUIRK\t\t= (1 << 5),\n};\n\n#define VMD_BIOS_PM_QUIRK_LTR\t0x1003\t \n\n#define VMD_FEATS_CLIENT\t(VMD_FEAT_HAS_MEMBAR_SHADOW_VSCAP |\t\\\n\t\t\t\t VMD_FEAT_HAS_BUS_RESTRICTIONS |\t\\\n\t\t\t\t VMD_FEAT_OFFSET_FIRST_VECTOR |\t\t\\\n\t\t\t\t VMD_FEAT_BIOS_PM_QUIRK)\n\nstatic DEFINE_IDA(vmd_instance_ida);\n\n \nstatic DEFINE_RAW_SPINLOCK(list_lock);\n\n \nstruct vmd_irq {\n\tstruct list_head\tnode;\n\tstruct vmd_irq_list\t*irq;\n\tbool\t\t\tenabled;\n\tunsigned int\t\tvirq;\n};\n\n \nstruct vmd_irq_list {\n\tstruct list_head\tirq_list;\n\tstruct srcu_struct\tsrcu;\n\tunsigned int\t\tcount;\n\tunsigned int\t\tvirq;\n};\n\nstruct vmd_dev {\n\tstruct pci_dev\t\t*dev;\n\n\tspinlock_t\t\tcfg_lock;\n\tvoid __iomem\t\t*cfgbar;\n\n\tint msix_count;\n\tstruct vmd_irq_list\t*irqs;\n\n\tstruct pci_sysdata\tsysdata;\n\tstruct resource\t\tresources[3];\n\tstruct irq_domain\t*irq_domain;\n\tstruct pci_bus\t\t*bus;\n\tu8\t\t\tbusn_start;\n\tu8\t\t\tfirst_vec;\n\tchar\t\t\t*name;\n\tint\t\t\tinstance;\n};\n\nstatic inline struct vmd_dev *vmd_from_bus(struct pci_bus *bus)\n{\n\treturn container_of(bus->sysdata, struct vmd_dev, sysdata);\n}\n\nstatic inline unsigned int index_from_irqs(struct vmd_dev *vmd,\n\t\t\t\t\t   struct vmd_irq_list *irqs)\n{\n\treturn irqs - vmd->irqs;\n}\n\n \nstatic void vmd_compose_msi_msg(struct irq_data *data, struct msi_msg *msg)\n{\n\tstruct vmd_irq *vmdirq = data->chip_data;\n\tstruct vmd_irq_list *irq = vmdirq->irq;\n\tstruct vmd_dev *vmd = irq_data_get_irq_handler_data(data);\n\n\tmemset(msg, 0, sizeof(*msg));\n\tmsg->address_hi = X86_MSI_BASE_ADDRESS_HIGH;\n\tmsg->arch_addr_lo.base_address = X86_MSI_BASE_ADDRESS_LOW;\n\tmsg->arch_addr_lo.destid_0_7 = index_from_irqs(vmd, irq);\n}\n\n \nstatic void vmd_irq_enable(struct irq_data *data)\n{\n\tstruct vmd_irq *vmdirq = data->chip_data;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&list_lock, flags);\n\tWARN_ON(vmdirq->enabled);\n\tlist_add_tail_rcu(&vmdirq->node, &vmdirq->irq->irq_list);\n\tvmdirq->enabled = true;\n\traw_spin_unlock_irqrestore(&list_lock, flags);\n\n\tdata->chip->irq_unmask(data);\n}\n\nstatic void vmd_irq_disable(struct irq_data *data)\n{\n\tstruct vmd_irq *vmdirq = data->chip_data;\n\tunsigned long flags;\n\n\tdata->chip->irq_mask(data);\n\n\traw_spin_lock_irqsave(&list_lock, flags);\n\tif (vmdirq->enabled) {\n\t\tlist_del_rcu(&vmdirq->node);\n\t\tvmdirq->enabled = false;\n\t}\n\traw_spin_unlock_irqrestore(&list_lock, flags);\n}\n\n \nstatic int vmd_irq_set_affinity(struct irq_data *data,\n\t\t\t\tconst struct cpumask *dest, bool force)\n{\n\treturn -EINVAL;\n}\n\nstatic struct irq_chip vmd_msi_controller = {\n\t.name\t\t\t= \"VMD-MSI\",\n\t.irq_enable\t\t= vmd_irq_enable,\n\t.irq_disable\t\t= vmd_irq_disable,\n\t.irq_compose_msi_msg\t= vmd_compose_msi_msg,\n\t.irq_set_affinity\t= vmd_irq_set_affinity,\n};\n\nstatic irq_hw_number_t vmd_get_hwirq(struct msi_domain_info *info,\n\t\t\t\t     msi_alloc_info_t *arg)\n{\n\treturn 0;\n}\n\n \nstatic struct vmd_irq_list *vmd_next_irq(struct vmd_dev *vmd, struct msi_desc *desc)\n{\n\tunsigned long flags;\n\tint i, best;\n\n\tif (vmd->msix_count == 1 + vmd->first_vec)\n\t\treturn &vmd->irqs[vmd->first_vec];\n\n\t \n\tswitch (msi_desc_to_pci_dev(desc)->class) {\n\tcase PCI_CLASS_STORAGE_EXPRESS:\n\t\tbreak;\n\tdefault:\n\t\treturn &vmd->irqs[vmd->first_vec];\n\t}\n\n\traw_spin_lock_irqsave(&list_lock, flags);\n\tbest = vmd->first_vec + 1;\n\tfor (i = best; i < vmd->msix_count; i++)\n\t\tif (vmd->irqs[i].count < vmd->irqs[best].count)\n\t\t\tbest = i;\n\tvmd->irqs[best].count++;\n\traw_spin_unlock_irqrestore(&list_lock, flags);\n\n\treturn &vmd->irqs[best];\n}\n\nstatic int vmd_msi_init(struct irq_domain *domain, struct msi_domain_info *info,\n\t\t\tunsigned int virq, irq_hw_number_t hwirq,\n\t\t\tmsi_alloc_info_t *arg)\n{\n\tstruct msi_desc *desc = arg->desc;\n\tstruct vmd_dev *vmd = vmd_from_bus(msi_desc_to_pci_dev(desc)->bus);\n\tstruct vmd_irq *vmdirq = kzalloc(sizeof(*vmdirq), GFP_KERNEL);\n\n\tif (!vmdirq)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&vmdirq->node);\n\tvmdirq->irq = vmd_next_irq(vmd, desc);\n\tvmdirq->virq = virq;\n\n\tirq_domain_set_info(domain, virq, vmdirq->irq->virq, info->chip, vmdirq,\n\t\t\t    handle_untracked_irq, vmd, NULL);\n\treturn 0;\n}\n\nstatic void vmd_msi_free(struct irq_domain *domain,\n\t\t\tstruct msi_domain_info *info, unsigned int virq)\n{\n\tstruct vmd_irq *vmdirq = irq_get_chip_data(virq);\n\tunsigned long flags;\n\n\tsynchronize_srcu(&vmdirq->irq->srcu);\n\n\t \n\traw_spin_lock_irqsave(&list_lock, flags);\n\tvmdirq->irq->count--;\n\traw_spin_unlock_irqrestore(&list_lock, flags);\n\n\tkfree(vmdirq);\n}\n\nstatic int vmd_msi_prepare(struct irq_domain *domain, struct device *dev,\n\t\t\t   int nvec, msi_alloc_info_t *arg)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tstruct vmd_dev *vmd = vmd_from_bus(pdev->bus);\n\n\tif (nvec > vmd->msix_count)\n\t\treturn vmd->msix_count;\n\n\tmemset(arg, 0, sizeof(*arg));\n\treturn 0;\n}\n\nstatic void vmd_set_desc(msi_alloc_info_t *arg, struct msi_desc *desc)\n{\n\targ->desc = desc;\n}\n\nstatic struct msi_domain_ops vmd_msi_domain_ops = {\n\t.get_hwirq\t= vmd_get_hwirq,\n\t.msi_init\t= vmd_msi_init,\n\t.msi_free\t= vmd_msi_free,\n\t.msi_prepare\t= vmd_msi_prepare,\n\t.set_desc\t= vmd_set_desc,\n};\n\nstatic struct msi_domain_info vmd_msi_domain_info = {\n\t.flags\t\t= MSI_FLAG_USE_DEF_DOM_OPS | MSI_FLAG_USE_DEF_CHIP_OPS |\n\t\t\t  MSI_FLAG_PCI_MSIX,\n\t.ops\t\t= &vmd_msi_domain_ops,\n\t.chip\t\t= &vmd_msi_controller,\n};\n\nstatic void vmd_set_msi_remapping(struct vmd_dev *vmd, bool enable)\n{\n\tu16 reg;\n\n\tpci_read_config_word(vmd->dev, PCI_REG_VMCONFIG, &reg);\n\treg = enable ? (reg & ~VMCONFIG_MSI_REMAP) :\n\t\t       (reg | VMCONFIG_MSI_REMAP);\n\tpci_write_config_word(vmd->dev, PCI_REG_VMCONFIG, reg);\n}\n\nstatic int vmd_create_irq_domain(struct vmd_dev *vmd)\n{\n\tstruct fwnode_handle *fn;\n\n\tfn = irq_domain_alloc_named_id_fwnode(\"VMD-MSI\", vmd->sysdata.domain);\n\tif (!fn)\n\t\treturn -ENODEV;\n\n\tvmd->irq_domain = pci_msi_create_irq_domain(fn, &vmd_msi_domain_info, NULL);\n\tif (!vmd->irq_domain) {\n\t\tirq_domain_free_fwnode(fn);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic void vmd_remove_irq_domain(struct vmd_dev *vmd)\n{\n\t \n\tif (!vmd->msix_count)\n\t\tvmd_set_msi_remapping(vmd, true);\n\n\tif (vmd->irq_domain) {\n\t\tstruct fwnode_handle *fn = vmd->irq_domain->fwnode;\n\n\t\tirq_domain_remove(vmd->irq_domain);\n\t\tirq_domain_free_fwnode(fn);\n\t}\n}\n\nstatic void __iomem *vmd_cfg_addr(struct vmd_dev *vmd, struct pci_bus *bus,\n\t\t\t\t  unsigned int devfn, int reg, int len)\n{\n\tunsigned int busnr_ecam = bus->number - vmd->busn_start;\n\tu32 offset = PCIE_ECAM_OFFSET(busnr_ecam, devfn, reg);\n\n\tif (offset + len >= resource_size(&vmd->dev->resource[VMD_CFGBAR]))\n\t\treturn NULL;\n\n\treturn vmd->cfgbar + offset;\n}\n\n \nstatic int vmd_pci_read(struct pci_bus *bus, unsigned int devfn, int reg,\n\t\t\tint len, u32 *value)\n{\n\tstruct vmd_dev *vmd = vmd_from_bus(bus);\n\tvoid __iomem *addr = vmd_cfg_addr(vmd, bus, devfn, reg, len);\n\tunsigned long flags;\n\tint ret = 0;\n\n\tif (!addr)\n\t\treturn -EFAULT;\n\n\tspin_lock_irqsave(&vmd->cfg_lock, flags);\n\tswitch (len) {\n\tcase 1:\n\t\t*value = readb(addr);\n\t\tbreak;\n\tcase 2:\n\t\t*value = readw(addr);\n\t\tbreak;\n\tcase 4:\n\t\t*value = readl(addr);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\tspin_unlock_irqrestore(&vmd->cfg_lock, flags);\n\treturn ret;\n}\n\n \nstatic int vmd_pci_write(struct pci_bus *bus, unsigned int devfn, int reg,\n\t\t\t int len, u32 value)\n{\n\tstruct vmd_dev *vmd = vmd_from_bus(bus);\n\tvoid __iomem *addr = vmd_cfg_addr(vmd, bus, devfn, reg, len);\n\tunsigned long flags;\n\tint ret = 0;\n\n\tif (!addr)\n\t\treturn -EFAULT;\n\n\tspin_lock_irqsave(&vmd->cfg_lock, flags);\n\tswitch (len) {\n\tcase 1:\n\t\twriteb(value, addr);\n\t\treadb(addr);\n\t\tbreak;\n\tcase 2:\n\t\twritew(value, addr);\n\t\treadw(addr);\n\t\tbreak;\n\tcase 4:\n\t\twritel(value, addr);\n\t\treadl(addr);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\tspin_unlock_irqrestore(&vmd->cfg_lock, flags);\n\treturn ret;\n}\n\nstatic struct pci_ops vmd_ops = {\n\t.read\t\t= vmd_pci_read,\n\t.write\t\t= vmd_pci_write,\n};\n\n#ifdef CONFIG_ACPI\nstatic struct acpi_device *vmd_acpi_find_companion(struct pci_dev *pci_dev)\n{\n\tstruct pci_host_bridge *bridge;\n\tu32 busnr, addr;\n\n\tif (pci_dev->bus->ops != &vmd_ops)\n\t\treturn NULL;\n\n\tbridge = pci_find_host_bridge(pci_dev->bus);\n\tbusnr = pci_dev->bus->number - bridge->bus->number;\n\t \n\tif (busnr > 31)\n\t\treturn NULL;\n\n\taddr = (busnr << 24) | ((u32)pci_dev->devfn << 16) | 0x8000FFFFU;\n\n\tdev_dbg(&pci_dev->dev, \"Looking for ACPI companion (address 0x%x)\\n\",\n\t\taddr);\n\n\treturn acpi_find_child_device(ACPI_COMPANION(bridge->dev.parent), addr,\n\t\t\t\t      false);\n}\n\nstatic bool hook_installed;\n\nstatic void vmd_acpi_begin(void)\n{\n\tif (pci_acpi_set_companion_lookup_hook(vmd_acpi_find_companion))\n\t\treturn;\n\n\thook_installed = true;\n}\n\nstatic void vmd_acpi_end(void)\n{\n\tif (!hook_installed)\n\t\treturn;\n\n\tpci_acpi_clear_companion_lookup_hook();\n\thook_installed = false;\n}\n#else\nstatic inline void vmd_acpi_begin(void) { }\nstatic inline void vmd_acpi_end(void) { }\n#endif  \n\nstatic void vmd_domain_reset(struct vmd_dev *vmd)\n{\n\tu16 bus, max_buses = resource_size(&vmd->resources[0]);\n\tu8 dev, functions, fn, hdr_type;\n\tchar __iomem *base;\n\n\tfor (bus = 0; bus < max_buses; bus++) {\n\t\tfor (dev = 0; dev < 32; dev++) {\n\t\t\tbase = vmd->cfgbar + PCIE_ECAM_OFFSET(bus,\n\t\t\t\t\t\tPCI_DEVFN(dev, 0), 0);\n\n\t\t\thdr_type = readb(base + PCI_HEADER_TYPE);\n\n\t\t\tfunctions = (hdr_type & 0x80) ? 8 : 1;\n\t\t\tfor (fn = 0; fn < functions; fn++) {\n\t\t\t\tbase = vmd->cfgbar + PCIE_ECAM_OFFSET(bus,\n\t\t\t\t\t\tPCI_DEVFN(dev, fn), 0);\n\n\t\t\t\thdr_type = readb(base + PCI_HEADER_TYPE) &\n\t\t\t\t\t\tPCI_HEADER_TYPE_MASK;\n\n\t\t\t\tif (hdr_type != PCI_HEADER_TYPE_BRIDGE ||\n\t\t\t\t    (readw(base + PCI_CLASS_DEVICE) !=\n\t\t\t\t     PCI_CLASS_BRIDGE_PCI))\n\t\t\t\t\tcontinue;\n\n\t\t\t\t \n\t\t\t\twritel(0x0000ffff, base + PCI_IO_BASE_UPPER16);\n\t\t\t\t \n\t\t\t\twritew(0x00f0, base + PCI_IO_BASE);\n\t\t\t\t \n\t\t\t\twritel(0, base + PCI_IO_BASE_UPPER16);\n\n\t\t\t\t \n\t\t\t\twritel(0x0000fff0, base + PCI_MEMORY_BASE);\n\n\t\t\t\t \n\t\t\t\twritel(0, base + PCI_PREF_LIMIT_UPPER32);\n\t\t\t\twritel(0x0000fff0, base + PCI_PREF_MEMORY_BASE);\n\t\t\t\twritel(0xffffffff, base + PCI_PREF_BASE_UPPER32);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void vmd_attach_resources(struct vmd_dev *vmd)\n{\n\tvmd->dev->resource[VMD_MEMBAR1].child = &vmd->resources[1];\n\tvmd->dev->resource[VMD_MEMBAR2].child = &vmd->resources[2];\n}\n\nstatic void vmd_detach_resources(struct vmd_dev *vmd)\n{\n\tvmd->dev->resource[VMD_MEMBAR1].child = NULL;\n\tvmd->dev->resource[VMD_MEMBAR2].child = NULL;\n}\n\n \nstatic int vmd_find_free_domain(void)\n{\n\tint domain = 0xffff;\n\tstruct pci_bus *bus = NULL;\n\n\twhile ((bus = pci_find_next_bus(bus)) != NULL)\n\t\tdomain = max_t(int, domain, pci_domain_nr(bus));\n\treturn domain + 1;\n}\n\nstatic int vmd_get_phys_offsets(struct vmd_dev *vmd, bool native_hint,\n\t\t\t\tresource_size_t *offset1,\n\t\t\t\tresource_size_t *offset2)\n{\n\tstruct pci_dev *dev = vmd->dev;\n\tu64 phys1, phys2;\n\n\tif (native_hint) {\n\t\tu32 vmlock;\n\t\tint ret;\n\n\t\tret = pci_read_config_dword(dev, PCI_REG_VMLOCK, &vmlock);\n\t\tif (ret || PCI_POSSIBLE_ERROR(vmlock))\n\t\t\treturn -ENODEV;\n\n\t\tif (MB2_SHADOW_EN(vmlock)) {\n\t\t\tvoid __iomem *membar2;\n\n\t\t\tmembar2 = pci_iomap(dev, VMD_MEMBAR2, 0);\n\t\t\tif (!membar2)\n\t\t\t\treturn -ENOMEM;\n\t\t\tphys1 = readq(membar2 + MB2_SHADOW_OFFSET);\n\t\t\tphys2 = readq(membar2 + MB2_SHADOW_OFFSET + 8);\n\t\t\tpci_iounmap(dev, membar2);\n\t\t} else\n\t\t\treturn 0;\n\t} else {\n\t\t \n\t\tint pos = pci_find_capability(dev, PCI_CAP_ID_VNDR);\n\t\tu32 reg, regu;\n\n\t\tpci_read_config_dword(dev, pos + 4, &reg);\n\n\t\t \n\t\tif (pos && reg == 0x53484457) {\n\t\t\tpci_read_config_dword(dev, pos + 8, &reg);\n\t\t\tpci_read_config_dword(dev, pos + 12, &regu);\n\t\t\tphys1 = (u64) regu << 32 | reg;\n\n\t\t\tpci_read_config_dword(dev, pos + 16, &reg);\n\t\t\tpci_read_config_dword(dev, pos + 20, &regu);\n\t\t\tphys2 = (u64) regu << 32 | reg;\n\t\t} else\n\t\t\treturn 0;\n\t}\n\n\t*offset1 = dev->resource[VMD_MEMBAR1].start -\n\t\t\t(phys1 & PCI_BASE_ADDRESS_MEM_MASK);\n\t*offset2 = dev->resource[VMD_MEMBAR2].start -\n\t\t\t(phys2 & PCI_BASE_ADDRESS_MEM_MASK);\n\n\treturn 0;\n}\n\nstatic int vmd_get_bus_number_start(struct vmd_dev *vmd)\n{\n\tstruct pci_dev *dev = vmd->dev;\n\tu16 reg;\n\n\tpci_read_config_word(dev, PCI_REG_VMCAP, &reg);\n\tif (BUS_RESTRICT_CAP(reg)) {\n\t\tpci_read_config_word(dev, PCI_REG_VMCONFIG, &reg);\n\n\t\tswitch (BUS_RESTRICT_CFG(reg)) {\n\t\tcase 0:\n\t\t\tvmd->busn_start = 0;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tvmd->busn_start = 128;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tvmd->busn_start = 224;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpci_err(dev, \"Unknown Bus Offset Setting (%d)\\n\",\n\t\t\t\tBUS_RESTRICT_CFG(reg));\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic irqreturn_t vmd_irq(int irq, void *data)\n{\n\tstruct vmd_irq_list *irqs = data;\n\tstruct vmd_irq *vmdirq;\n\tint idx;\n\n\tidx = srcu_read_lock(&irqs->srcu);\n\tlist_for_each_entry_rcu(vmdirq, &irqs->irq_list, node)\n\t\tgeneric_handle_irq(vmdirq->virq);\n\tsrcu_read_unlock(&irqs->srcu, idx);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int vmd_alloc_irqs(struct vmd_dev *vmd)\n{\n\tstruct pci_dev *dev = vmd->dev;\n\tint i, err;\n\n\tvmd->msix_count = pci_msix_vec_count(dev);\n\tif (vmd->msix_count < 0)\n\t\treturn -ENODEV;\n\n\tvmd->msix_count = pci_alloc_irq_vectors(dev, vmd->first_vec + 1,\n\t\t\t\t\t\tvmd->msix_count, PCI_IRQ_MSIX);\n\tif (vmd->msix_count < 0)\n\t\treturn vmd->msix_count;\n\n\tvmd->irqs = devm_kcalloc(&dev->dev, vmd->msix_count, sizeof(*vmd->irqs),\n\t\t\t\t GFP_KERNEL);\n\tif (!vmd->irqs)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < vmd->msix_count; i++) {\n\t\terr = init_srcu_struct(&vmd->irqs[i].srcu);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tINIT_LIST_HEAD(&vmd->irqs[i].irq_list);\n\t\tvmd->irqs[i].virq = pci_irq_vector(dev, i);\n\t\terr = devm_request_irq(&dev->dev, vmd->irqs[i].virq,\n\t\t\t\t       vmd_irq, IRQF_NO_THREAD,\n\t\t\t\t       vmd->name, &vmd->irqs[i]);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void vmd_copy_host_bridge_flags(struct pci_host_bridge *root_bridge,\n\t\t\t\t       struct pci_host_bridge *vmd_bridge)\n{\n\tvmd_bridge->native_pcie_hotplug = root_bridge->native_pcie_hotplug;\n\tvmd_bridge->native_shpc_hotplug = root_bridge->native_shpc_hotplug;\n\tvmd_bridge->native_aer = root_bridge->native_aer;\n\tvmd_bridge->native_pme = root_bridge->native_pme;\n\tvmd_bridge->native_ltr = root_bridge->native_ltr;\n\tvmd_bridge->native_dpc = root_bridge->native_dpc;\n}\n\n \nstatic int vmd_pm_enable_quirk(struct pci_dev *pdev, void *userdata)\n{\n\tunsigned long features = *(unsigned long *)userdata;\n\tu16 ltr = VMD_BIOS_PM_QUIRK_LTR;\n\tu32 ltr_reg;\n\tint pos;\n\n\tif (!(features & VMD_FEAT_BIOS_PM_QUIRK))\n\t\treturn 0;\n\n\tpci_enable_link_state_locked(pdev, PCIE_LINK_STATE_ALL);\n\n\tpos = pci_find_ext_capability(pdev, PCI_EXT_CAP_ID_LTR);\n\tif (!pos)\n\t\treturn 0;\n\n\t \n\tpci_read_config_dword(pdev, pos + PCI_LTR_MAX_SNOOP_LAT, &ltr_reg);\n\tif (!!(ltr_reg & (PCI_LTR_VALUE_MASK | PCI_LTR_SCALE_MASK)))\n\t\treturn 0;\n\n\t \n\tltr_reg = (ltr << 16) | ltr;\n\tpci_write_config_dword(pdev, pos + PCI_LTR_MAX_SNOOP_LAT, ltr_reg);\n\tpci_info(pdev, \"VMD: Default LTR value set by driver\\n\");\n\n\treturn 0;\n}\n\nstatic int vmd_enable_domain(struct vmd_dev *vmd, unsigned long features)\n{\n\tstruct pci_sysdata *sd = &vmd->sysdata;\n\tstruct resource *res;\n\tu32 upper_bits;\n\tunsigned long flags;\n\tLIST_HEAD(resources);\n\tresource_size_t offset[2] = {0};\n\tresource_size_t membar2_offset = 0x2000;\n\tstruct pci_bus *child;\n\tstruct pci_dev *dev;\n\tint ret;\n\n\t \n\tif (features & VMD_FEAT_HAS_MEMBAR_SHADOW) {\n\t\tmembar2_offset = MB2_SHADOW_OFFSET + MB2_SHADOW_SIZE;\n\t\tret = vmd_get_phys_offsets(vmd, true, &offset[0], &offset[1]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else if (features & VMD_FEAT_HAS_MEMBAR_SHADOW_VSCAP) {\n\t\tret = vmd_get_phys_offsets(vmd, false, &offset[0], &offset[1]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tif (features & VMD_FEAT_HAS_BUS_RESTRICTIONS) {\n\t\tret = vmd_get_bus_number_start(vmd);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tres = &vmd->dev->resource[VMD_CFGBAR];\n\tvmd->resources[0] = (struct resource) {\n\t\t.name  = \"VMD CFGBAR\",\n\t\t.start = vmd->busn_start,\n\t\t.end   = vmd->busn_start + (resource_size(res) >> 20) - 1,\n\t\t.flags = IORESOURCE_BUS | IORESOURCE_PCI_FIXED,\n\t};\n\n\t \n\tres = &vmd->dev->resource[VMD_MEMBAR1];\n\tupper_bits = upper_32_bits(res->end);\n\tflags = res->flags & ~IORESOURCE_SIZEALIGN;\n\tif (!upper_bits)\n\t\tflags &= ~IORESOURCE_MEM_64;\n\tvmd->resources[1] = (struct resource) {\n\t\t.name  = \"VMD MEMBAR1\",\n\t\t.start = res->start,\n\t\t.end   = res->end,\n\t\t.flags = flags,\n\t\t.parent = res,\n\t};\n\n\tres = &vmd->dev->resource[VMD_MEMBAR2];\n\tupper_bits = upper_32_bits(res->end);\n\tflags = res->flags & ~IORESOURCE_SIZEALIGN;\n\tif (!upper_bits)\n\t\tflags &= ~IORESOURCE_MEM_64;\n\tvmd->resources[2] = (struct resource) {\n\t\t.name  = \"VMD MEMBAR2\",\n\t\t.start = res->start + membar2_offset,\n\t\t.end   = res->end,\n\t\t.flags = flags,\n\t\t.parent = res,\n\t};\n\n\tsd->vmd_dev = vmd->dev;\n\tsd->domain = vmd_find_free_domain();\n\tif (sd->domain < 0)\n\t\treturn sd->domain;\n\n\tsd->node = pcibus_to_node(vmd->dev->bus);\n\n\t \n\tif (!(features & VMD_FEAT_CAN_BYPASS_MSI_REMAP) ||\n\t    offset[0] || offset[1]) {\n\t\tret = vmd_alloc_irqs(vmd);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tvmd_set_msi_remapping(vmd, true);\n\n\t\tret = vmd_create_irq_domain(vmd);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tirq_domain_update_bus_token(vmd->irq_domain, DOMAIN_BUS_VMD_MSI);\n\t} else {\n\t\tvmd_set_msi_remapping(vmd, false);\n\t}\n\n\tpci_add_resource(&resources, &vmd->resources[0]);\n\tpci_add_resource_offset(&resources, &vmd->resources[1], offset[0]);\n\tpci_add_resource_offset(&resources, &vmd->resources[2], offset[1]);\n\n\tvmd->bus = pci_create_root_bus(&vmd->dev->dev, vmd->busn_start,\n\t\t\t\t       &vmd_ops, sd, &resources);\n\tif (!vmd->bus) {\n\t\tpci_free_resource_list(&resources);\n\t\tvmd_remove_irq_domain(vmd);\n\t\treturn -ENODEV;\n\t}\n\n\tvmd_copy_host_bridge_flags(pci_find_host_bridge(vmd->dev->bus),\n\t\t\t\t   to_pci_host_bridge(vmd->bus->bridge));\n\n\tvmd_attach_resources(vmd);\n\tif (vmd->irq_domain)\n\t\tdev_set_msi_domain(&vmd->bus->dev, vmd->irq_domain);\n\telse\n\t\tdev_set_msi_domain(&vmd->bus->dev,\n\t\t\t\t   dev_get_msi_domain(&vmd->dev->dev));\n\n\tvmd_acpi_begin();\n\n\tpci_scan_child_bus(vmd->bus);\n\tvmd_domain_reset(vmd);\n\n\t \n\tlist_for_each_entry(child, &vmd->bus->children, node) {\n\t\tif (!list_empty(&child->devices)) {\n\t\t\tdev = list_first_entry(&child->devices,\n\t\t\t\t\t       struct pci_dev, bus_list);\n\t\t\tret = pci_reset_bus(dev);\n\t\t\tif (ret)\n\t\t\t\tpci_warn(dev, \"can't reset device: %d\\n\", ret);\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tpci_assign_unassigned_bus_resources(vmd->bus);\n\n\tpci_walk_bus(vmd->bus, vmd_pm_enable_quirk, &features);\n\n\t \n\tlist_for_each_entry(child, &vmd->bus->children, node)\n\t\tpcie_bus_configure_settings(child);\n\n\tpci_bus_add_devices(vmd->bus);\n\n\tvmd_acpi_end();\n\n\tWARN(sysfs_create_link(&vmd->dev->dev.kobj, &vmd->bus->dev.kobj,\n\t\t\t       \"domain\"), \"Can't create symlink to domain\\n\");\n\treturn 0;\n}\n\nstatic int vmd_probe(struct pci_dev *dev, const struct pci_device_id *id)\n{\n\tunsigned long features = (unsigned long) id->driver_data;\n\tstruct vmd_dev *vmd;\n\tint err;\n\n\tif (resource_size(&dev->resource[VMD_CFGBAR]) < (1 << 20))\n\t\treturn -ENOMEM;\n\n\tvmd = devm_kzalloc(&dev->dev, sizeof(*vmd), GFP_KERNEL);\n\tif (!vmd)\n\t\treturn -ENOMEM;\n\n\tvmd->dev = dev;\n\tvmd->instance = ida_simple_get(&vmd_instance_ida, 0, 0, GFP_KERNEL);\n\tif (vmd->instance < 0)\n\t\treturn vmd->instance;\n\n\tvmd->name = devm_kasprintf(&dev->dev, GFP_KERNEL, \"vmd%d\",\n\t\t\t\t   vmd->instance);\n\tif (!vmd->name) {\n\t\terr = -ENOMEM;\n\t\tgoto out_release_instance;\n\t}\n\n\terr = pcim_enable_device(dev);\n\tif (err < 0)\n\t\tgoto out_release_instance;\n\n\tvmd->cfgbar = pcim_iomap(dev, VMD_CFGBAR, 0);\n\tif (!vmd->cfgbar) {\n\t\terr = -ENOMEM;\n\t\tgoto out_release_instance;\n\t}\n\n\tpci_set_master(dev);\n\tif (dma_set_mask_and_coherent(&dev->dev, DMA_BIT_MASK(64)) &&\n\t    dma_set_mask_and_coherent(&dev->dev, DMA_BIT_MASK(32))) {\n\t\terr = -ENODEV;\n\t\tgoto out_release_instance;\n\t}\n\n\tif (features & VMD_FEAT_OFFSET_FIRST_VECTOR)\n\t\tvmd->first_vec = 1;\n\n\tspin_lock_init(&vmd->cfg_lock);\n\tpci_set_drvdata(dev, vmd);\n\terr = vmd_enable_domain(vmd, features);\n\tif (err)\n\t\tgoto out_release_instance;\n\n\tdev_info(&vmd->dev->dev, \"Bound to PCI domain %04x\\n\",\n\t\t vmd->sysdata.domain);\n\treturn 0;\n\n out_release_instance:\n\tida_simple_remove(&vmd_instance_ida, vmd->instance);\n\treturn err;\n}\n\nstatic void vmd_cleanup_srcu(struct vmd_dev *vmd)\n{\n\tint i;\n\n\tfor (i = 0; i < vmd->msix_count; i++)\n\t\tcleanup_srcu_struct(&vmd->irqs[i].srcu);\n}\n\nstatic void vmd_remove(struct pci_dev *dev)\n{\n\tstruct vmd_dev *vmd = pci_get_drvdata(dev);\n\n\tsysfs_remove_link(&vmd->dev->dev.kobj, \"domain\");\n\tpci_stop_root_bus(vmd->bus);\n\tpci_remove_root_bus(vmd->bus);\n\tvmd_cleanup_srcu(vmd);\n\tvmd_detach_resources(vmd);\n\tvmd_remove_irq_domain(vmd);\n\tida_simple_remove(&vmd_instance_ida, vmd->instance);\n}\n\nstatic void vmd_shutdown(struct pci_dev *dev)\n{\n        struct vmd_dev *vmd = pci_get_drvdata(dev);\n\n        vmd_remove_irq_domain(vmd);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int vmd_suspend(struct device *dev)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tstruct vmd_dev *vmd = pci_get_drvdata(pdev);\n\tint i;\n\n\tfor (i = 0; i < vmd->msix_count; i++)\n\t\tdevm_free_irq(dev, vmd->irqs[i].virq, &vmd->irqs[i]);\n\n\treturn 0;\n}\n\nstatic int vmd_resume(struct device *dev)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tstruct vmd_dev *vmd = pci_get_drvdata(pdev);\n\tint err, i;\n\n       if (vmd->irq_domain)\n               vmd_set_msi_remapping(vmd, true);\n       else\n               vmd_set_msi_remapping(vmd, false);\n\n\tfor (i = 0; i < vmd->msix_count; i++) {\n\t\terr = devm_request_irq(dev, vmd->irqs[i].virq,\n\t\t\t\t       vmd_irq, IRQF_NO_THREAD,\n\t\t\t\t       vmd->name, &vmd->irqs[i]);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n#endif\nstatic SIMPLE_DEV_PM_OPS(vmd_dev_pm_ops, vmd_suspend, vmd_resume);\n\nstatic const struct pci_device_id vmd_ids[] = {\n\t{PCI_VDEVICE(INTEL, PCI_DEVICE_ID_INTEL_VMD_201D),\n\t\t.driver_data = VMD_FEAT_HAS_MEMBAR_SHADOW_VSCAP,},\n\t{PCI_VDEVICE(INTEL, PCI_DEVICE_ID_INTEL_VMD_28C0),\n\t\t.driver_data = VMD_FEAT_HAS_MEMBAR_SHADOW |\n\t\t\t\tVMD_FEAT_HAS_BUS_RESTRICTIONS |\n\t\t\t\tVMD_FEAT_CAN_BYPASS_MSI_REMAP,},\n\t{PCI_VDEVICE(INTEL, 0x467f),\n\t\t.driver_data = VMD_FEATS_CLIENT,},\n\t{PCI_VDEVICE(INTEL, 0x4c3d),\n\t\t.driver_data = VMD_FEATS_CLIENT,},\n\t{PCI_VDEVICE(INTEL, 0xa77f),\n\t\t.driver_data = VMD_FEATS_CLIENT,},\n\t{PCI_VDEVICE(INTEL, 0x7d0b),\n\t\t.driver_data = VMD_FEATS_CLIENT,},\n\t{PCI_VDEVICE(INTEL, 0xad0b),\n\t\t.driver_data = VMD_FEATS_CLIENT,},\n\t{PCI_VDEVICE(INTEL, PCI_DEVICE_ID_INTEL_VMD_9A0B),\n\t\t.driver_data = VMD_FEATS_CLIENT,},\n\t{0,}\n};\nMODULE_DEVICE_TABLE(pci, vmd_ids);\n\nstatic struct pci_driver vmd_drv = {\n\t.name\t\t= \"vmd\",\n\t.id_table\t= vmd_ids,\n\t.probe\t\t= vmd_probe,\n\t.remove\t\t= vmd_remove,\n\t.shutdown\t= vmd_shutdown,\n\t.driver\t\t= {\n\t\t.pm\t= &vmd_dev_pm_ops,\n\t},\n};\nmodule_pci_driver(vmd_drv);\n\nMODULE_AUTHOR(\"Intel Corporation\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_VERSION(\"0.6\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}