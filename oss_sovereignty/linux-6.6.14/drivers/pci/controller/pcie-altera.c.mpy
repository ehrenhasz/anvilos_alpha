{
  "module_name": "pcie-altera.c",
  "hash_id": "c49f1e3db64d72c5b09615da1a1594533c284c753c9a17300c7410f4a589fe17",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/controller/pcie-altera.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/irqchip/chained_irq.h>\n#include <linux/irqdomain.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_pci.h>\n#include <linux/pci.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n\n#include \"../pci.h\"\n\n#define RP_TX_REG0\t\t\t0x2000\n#define RP_TX_REG1\t\t\t0x2004\n#define RP_TX_CNTRL\t\t\t0x2008\n#define RP_TX_EOP\t\t\t0x2\n#define RP_TX_SOP\t\t\t0x1\n#define RP_RXCPL_STATUS\t\t\t0x2010\n#define RP_RXCPL_EOP\t\t\t0x2\n#define RP_RXCPL_SOP\t\t\t0x1\n#define RP_RXCPL_REG0\t\t\t0x2014\n#define RP_RXCPL_REG1\t\t\t0x2018\n#define P2A_INT_STATUS\t\t\t0x3060\n#define P2A_INT_STS_ALL\t\t\t0xf\n#define P2A_INT_ENABLE\t\t\t0x3070\n#define P2A_INT_ENA_ALL\t\t\t0xf\n#define RP_LTSSM\t\t\t0x3c64\n#define RP_LTSSM_MASK\t\t\t0x1f\n#define LTSSM_L0\t\t\t0xf\n\n#define S10_RP_TX_CNTRL\t\t\t0x2004\n#define S10_RP_RXCPL_REG\t\t0x2008\n#define S10_RP_RXCPL_STATUS\t\t0x200C\n#define S10_RP_CFG_ADDR(pcie, reg)\t\\\n\t(((pcie)->hip_base) + (reg) + (1 << 20))\n#define S10_RP_SECONDARY(pcie)\t\t\\\n\treadb(S10_RP_CFG_ADDR(pcie, PCI_SECONDARY_BUS))\n\n \n#define TLP_FMTTYPE_CFGRD0\t\t0x04\t \n#define TLP_FMTTYPE_CFGWR0\t\t0x44\t \n#define TLP_FMTTYPE_CFGRD1\t\t0x05\t \n#define TLP_FMTTYPE_CFGWR1\t\t0x45\t \n#define TLP_PAYLOAD_SIZE\t\t0x01\n#define TLP_READ_TAG\t\t\t0x1d\n#define TLP_WRITE_TAG\t\t\t0x10\n#define RP_DEVFN\t\t\t0\n#define TLP_REQ_ID(bus, devfn)\t\t(((bus) << 8) | (devfn))\n#define TLP_CFG_DW0(pcie, cfg)\t\t\\\n\t\t(((cfg) << 24) |\t\\\n\t\t  TLP_PAYLOAD_SIZE)\n#define TLP_CFG_DW1(pcie, tag, be)\t\\\n\t(((TLP_REQ_ID(pcie->root_bus_nr,  RP_DEVFN)) << 16) | (tag << 8) | (be))\n#define TLP_CFG_DW2(bus, devfn, offset)\t\\\n\t\t\t\t(((bus) << 24) | ((devfn) << 16) | (offset))\n#define TLP_COMP_STATUS(s)\t\t(((s) >> 13) & 7)\n#define TLP_BYTE_COUNT(s)\t\t(((s) >> 0) & 0xfff)\n#define TLP_HDR_SIZE\t\t\t3\n#define TLP_LOOP\t\t\t500\n\n#define LINK_UP_TIMEOUT\t\t\tHZ\n#define LINK_RETRAIN_TIMEOUT\t\tHZ\n\n#define DWORD_MASK\t\t\t3\n\n#define S10_TLP_FMTTYPE_CFGRD0\t\t0x05\n#define S10_TLP_FMTTYPE_CFGRD1\t\t0x04\n#define S10_TLP_FMTTYPE_CFGWR0\t\t0x45\n#define S10_TLP_FMTTYPE_CFGWR1\t\t0x44\n\nenum altera_pcie_version {\n\tALTERA_PCIE_V1 = 0,\n\tALTERA_PCIE_V2,\n};\n\nstruct altera_pcie {\n\tstruct platform_device\t*pdev;\n\tvoid __iomem\t\t*cra_base;\n\tvoid __iomem\t\t*hip_base;\n\tint\t\t\tirq;\n\tu8\t\t\troot_bus_nr;\n\tstruct irq_domain\t*irq_domain;\n\tstruct resource\t\tbus_range;\n\tconst struct altera_pcie_data\t*pcie_data;\n};\n\nstruct altera_pcie_ops {\n\tint (*tlp_read_pkt)(struct altera_pcie *pcie, u32 *value);\n\tvoid (*tlp_write_pkt)(struct altera_pcie *pcie, u32 *headers,\n\t\t\t      u32 data, bool align);\n\tbool (*get_link_status)(struct altera_pcie *pcie);\n\tint (*rp_read_cfg)(struct altera_pcie *pcie, int where,\n\t\t\t   int size, u32 *value);\n\tint (*rp_write_cfg)(struct altera_pcie *pcie, u8 busno,\n\t\t\t    int where, int size, u32 value);\n};\n\nstruct altera_pcie_data {\n\tconst struct altera_pcie_ops *ops;\n\tenum altera_pcie_version version;\n\tu32 cap_offset;\t\t \n\tu32 cfgrd0;\n\tu32 cfgrd1;\n\tu32 cfgwr0;\n\tu32 cfgwr1;\n};\n\nstruct tlp_rp_regpair_t {\n\tu32 ctrl;\n\tu32 reg0;\n\tu32 reg1;\n};\n\nstatic inline void cra_writel(struct altera_pcie *pcie, const u32 value,\n\t\t\t      const u32 reg)\n{\n\twritel_relaxed(value, pcie->cra_base + reg);\n}\n\nstatic inline u32 cra_readl(struct altera_pcie *pcie, const u32 reg)\n{\n\treturn readl_relaxed(pcie->cra_base + reg);\n}\n\nstatic bool altera_pcie_link_up(struct altera_pcie *pcie)\n{\n\treturn !!((cra_readl(pcie, RP_LTSSM) & RP_LTSSM_MASK) == LTSSM_L0);\n}\n\nstatic bool s10_altera_pcie_link_up(struct altera_pcie *pcie)\n{\n\tvoid __iomem *addr = S10_RP_CFG_ADDR(pcie,\n\t\t\t\t   pcie->pcie_data->cap_offset +\n\t\t\t\t   PCI_EXP_LNKSTA);\n\n\treturn !!(readw(addr) & PCI_EXP_LNKSTA_DLLLA);\n}\n\n \nstatic bool altera_pcie_hide_rc_bar(struct pci_bus *bus, unsigned int  devfn,\n\t\t\t\t    int offset)\n{\n\tif (pci_is_root_bus(bus) && (devfn == 0) &&\n\t    (offset == PCI_BASE_ADDRESS_0))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic void tlp_write_tx(struct altera_pcie *pcie,\n\t\t\t struct tlp_rp_regpair_t *tlp_rp_regdata)\n{\n\tcra_writel(pcie, tlp_rp_regdata->reg0, RP_TX_REG0);\n\tcra_writel(pcie, tlp_rp_regdata->reg1, RP_TX_REG1);\n\tcra_writel(pcie, tlp_rp_regdata->ctrl, RP_TX_CNTRL);\n}\n\nstatic void s10_tlp_write_tx(struct altera_pcie *pcie, u32 reg0, u32 ctrl)\n{\n\tcra_writel(pcie, reg0, RP_TX_REG0);\n\tcra_writel(pcie, ctrl, S10_RP_TX_CNTRL);\n}\n\nstatic bool altera_pcie_valid_device(struct altera_pcie *pcie,\n\t\t\t\t     struct pci_bus *bus, int dev)\n{\n\t \n\tif (bus->number != pcie->root_bus_nr) {\n\t\tif (!pcie->pcie_data->ops->get_link_status(pcie))\n\t\t\treturn false;\n\t}\n\n\t \n\tif (bus->number == pcie->root_bus_nr && dev > 0)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic int tlp_read_packet(struct altera_pcie *pcie, u32 *value)\n{\n\tint i;\n\tbool sop = false;\n\tu32 ctrl;\n\tu32 reg0, reg1;\n\tu32 comp_status = 1;\n\n\t \n\tfor (i = 0; i < TLP_LOOP; i++) {\n\t\tctrl = cra_readl(pcie, RP_RXCPL_STATUS);\n\t\tif ((ctrl & RP_RXCPL_SOP) || (ctrl & RP_RXCPL_EOP) || sop) {\n\t\t\treg0 = cra_readl(pcie, RP_RXCPL_REG0);\n\t\t\treg1 = cra_readl(pcie, RP_RXCPL_REG1);\n\n\t\t\tif (ctrl & RP_RXCPL_SOP) {\n\t\t\t\tsop = true;\n\t\t\t\tcomp_status = TLP_COMP_STATUS(reg1);\n\t\t\t}\n\n\t\t\tif (ctrl & RP_RXCPL_EOP) {\n\t\t\t\tif (comp_status)\n\t\t\t\t\treturn PCIBIOS_DEVICE_NOT_FOUND;\n\n\t\t\t\tif (value)\n\t\t\t\t\t*value = reg0;\n\n\t\t\t\treturn PCIBIOS_SUCCESSFUL;\n\t\t\t}\n\t\t}\n\t\tudelay(5);\n\t}\n\n\treturn PCIBIOS_DEVICE_NOT_FOUND;\n}\n\nstatic int s10_tlp_read_packet(struct altera_pcie *pcie, u32 *value)\n{\n\tu32 ctrl;\n\tu32 comp_status;\n\tu32 dw[4];\n\tu32 count;\n\tstruct device *dev = &pcie->pdev->dev;\n\n\tfor (count = 0; count < TLP_LOOP; count++) {\n\t\tctrl = cra_readl(pcie, S10_RP_RXCPL_STATUS);\n\t\tif (ctrl & RP_RXCPL_SOP) {\n\t\t\t \n\t\t\tdw[0] = cra_readl(pcie, S10_RP_RXCPL_REG);\n\t\t\tbreak;\n\t\t}\n\n\t\tudelay(5);\n\t}\n\n\t \n\tif (count == TLP_LOOP)\n\t\treturn PCIBIOS_DEVICE_NOT_FOUND;\n\n\tcount = 1;\n\n\t \n\twhile (count < ARRAY_SIZE(dw)) {\n\t\tctrl = cra_readl(pcie, S10_RP_RXCPL_STATUS);\n\t\tdw[count++] = cra_readl(pcie, S10_RP_RXCPL_REG);\n\t\tif (ctrl & RP_RXCPL_EOP) {\n\t\t\tcomp_status = TLP_COMP_STATUS(dw[1]);\n\t\t\tif (comp_status)\n\t\t\t\treturn PCIBIOS_DEVICE_NOT_FOUND;\n\n\t\t\tif (value && TLP_BYTE_COUNT(dw[1]) == sizeof(u32) &&\n\t\t\t    count == 4)\n\t\t\t\t*value = dw[3];\n\n\t\t\treturn PCIBIOS_SUCCESSFUL;\n\t\t}\n\t}\n\n\tdev_warn(dev, \"Malformed TLP packet\\n\");\n\n\treturn PCIBIOS_DEVICE_NOT_FOUND;\n}\n\nstatic void tlp_write_packet(struct altera_pcie *pcie, u32 *headers,\n\t\t\t     u32 data, bool align)\n{\n\tstruct tlp_rp_regpair_t tlp_rp_regdata;\n\n\ttlp_rp_regdata.reg0 = headers[0];\n\ttlp_rp_regdata.reg1 = headers[1];\n\ttlp_rp_regdata.ctrl = RP_TX_SOP;\n\ttlp_write_tx(pcie, &tlp_rp_regdata);\n\n\tif (align) {\n\t\ttlp_rp_regdata.reg0 = headers[2];\n\t\ttlp_rp_regdata.reg1 = 0;\n\t\ttlp_rp_regdata.ctrl = 0;\n\t\ttlp_write_tx(pcie, &tlp_rp_regdata);\n\n\t\ttlp_rp_regdata.reg0 = data;\n\t\ttlp_rp_regdata.reg1 = 0;\n\t} else {\n\t\ttlp_rp_regdata.reg0 = headers[2];\n\t\ttlp_rp_regdata.reg1 = data;\n\t}\n\n\ttlp_rp_regdata.ctrl = RP_TX_EOP;\n\ttlp_write_tx(pcie, &tlp_rp_regdata);\n}\n\nstatic void s10_tlp_write_packet(struct altera_pcie *pcie, u32 *headers,\n\t\t\t\t u32 data, bool dummy)\n{\n\ts10_tlp_write_tx(pcie, headers[0], RP_TX_SOP);\n\ts10_tlp_write_tx(pcie, headers[1], 0);\n\ts10_tlp_write_tx(pcie, headers[2], 0);\n\ts10_tlp_write_tx(pcie, data, RP_TX_EOP);\n}\n\nstatic void get_tlp_header(struct altera_pcie *pcie, u8 bus, u32 devfn,\n\t\t\t   int where, u8 byte_en, bool read, u32 *headers)\n{\n\tu8 cfg;\n\tu8 cfg0 = read ? pcie->pcie_data->cfgrd0 : pcie->pcie_data->cfgwr0;\n\tu8 cfg1 = read ? pcie->pcie_data->cfgrd1 : pcie->pcie_data->cfgwr1;\n\tu8 tag = read ? TLP_READ_TAG : TLP_WRITE_TAG;\n\n\tif (pcie->pcie_data->version == ALTERA_PCIE_V1)\n\t\tcfg = (bus == pcie->root_bus_nr) ? cfg0 : cfg1;\n\telse\n\t\tcfg = (bus > S10_RP_SECONDARY(pcie)) ? cfg0 : cfg1;\n\n\theaders[0] = TLP_CFG_DW0(pcie, cfg);\n\theaders[1] = TLP_CFG_DW1(pcie, tag, byte_en);\n\theaders[2] = TLP_CFG_DW2(bus, devfn, where);\n}\n\nstatic int tlp_cfg_dword_read(struct altera_pcie *pcie, u8 bus, u32 devfn,\n\t\t\t      int where, u8 byte_en, u32 *value)\n{\n\tu32 headers[TLP_HDR_SIZE];\n\n\tget_tlp_header(pcie, bus, devfn, where, byte_en, true,\n\t\t       headers);\n\n\tpcie->pcie_data->ops->tlp_write_pkt(pcie, headers, 0, false);\n\n\treturn pcie->pcie_data->ops->tlp_read_pkt(pcie, value);\n}\n\nstatic int tlp_cfg_dword_write(struct altera_pcie *pcie, u8 bus, u32 devfn,\n\t\t\t       int where, u8 byte_en, u32 value)\n{\n\tu32 headers[TLP_HDR_SIZE];\n\tint ret;\n\n\tget_tlp_header(pcie, bus, devfn, where, byte_en, false,\n\t\t       headers);\n\n\t \n\tif ((where & 0x7) == 0)\n\t\tpcie->pcie_data->ops->tlp_write_pkt(pcie, headers,\n\t\t\t\t\t\t    value, true);\n\telse\n\t\tpcie->pcie_data->ops->tlp_write_pkt(pcie, headers,\n\t\t\t\t\t\t    value, false);\n\n\tret = pcie->pcie_data->ops->tlp_read_pkt(pcie, NULL);\n\tif (ret != PCIBIOS_SUCCESSFUL)\n\t\treturn ret;\n\n\t \n\tif ((bus == pcie->root_bus_nr) && (where == PCI_PRIMARY_BUS))\n\t\tpcie->root_bus_nr = (u8)(value);\n\n\treturn PCIBIOS_SUCCESSFUL;\n}\n\nstatic int s10_rp_read_cfg(struct altera_pcie *pcie, int where,\n\t\t\t   int size, u32 *value)\n{\n\tvoid __iomem *addr = S10_RP_CFG_ADDR(pcie, where);\n\n\tswitch (size) {\n\tcase 1:\n\t\t*value = readb(addr);\n\t\tbreak;\n\tcase 2:\n\t\t*value = readw(addr);\n\t\tbreak;\n\tdefault:\n\t\t*value = readl(addr);\n\t\tbreak;\n\t}\n\n\treturn PCIBIOS_SUCCESSFUL;\n}\n\nstatic int s10_rp_write_cfg(struct altera_pcie *pcie, u8 busno,\n\t\t\t    int where, int size, u32 value)\n{\n\tvoid __iomem *addr = S10_RP_CFG_ADDR(pcie, where);\n\n\tswitch (size) {\n\tcase 1:\n\t\twriteb(value, addr);\n\t\tbreak;\n\tcase 2:\n\t\twritew(value, addr);\n\t\tbreak;\n\tdefault:\n\t\twritel(value, addr);\n\t\tbreak;\n\t}\n\n\t \n\tif (busno == pcie->root_bus_nr && where == PCI_PRIMARY_BUS)\n\t\tpcie->root_bus_nr = value & 0xff;\n\n\treturn PCIBIOS_SUCCESSFUL;\n}\n\nstatic int _altera_pcie_cfg_read(struct altera_pcie *pcie, u8 busno,\n\t\t\t\t unsigned int devfn, int where, int size,\n\t\t\t\t u32 *value)\n{\n\tint ret;\n\tu32 data;\n\tu8 byte_en;\n\n\tif (busno == pcie->root_bus_nr && pcie->pcie_data->ops->rp_read_cfg)\n\t\treturn pcie->pcie_data->ops->rp_read_cfg(pcie, where,\n\t\t\t\t\t\t\t size, value);\n\n\tswitch (size) {\n\tcase 1:\n\t\tbyte_en = 1 << (where & 3);\n\t\tbreak;\n\tcase 2:\n\t\tbyte_en = 3 << (where & 3);\n\t\tbreak;\n\tdefault:\n\t\tbyte_en = 0xf;\n\t\tbreak;\n\t}\n\n\tret = tlp_cfg_dword_read(pcie, busno, devfn,\n\t\t\t\t (where & ~DWORD_MASK), byte_en, &data);\n\tif (ret != PCIBIOS_SUCCESSFUL)\n\t\treturn ret;\n\n\tswitch (size) {\n\tcase 1:\n\t\t*value = (data >> (8 * (where & 0x3))) & 0xff;\n\t\tbreak;\n\tcase 2:\n\t\t*value = (data >> (8 * (where & 0x2))) & 0xffff;\n\t\tbreak;\n\tdefault:\n\t\t*value = data;\n\t\tbreak;\n\t}\n\n\treturn PCIBIOS_SUCCESSFUL;\n}\n\nstatic int _altera_pcie_cfg_write(struct altera_pcie *pcie, u8 busno,\n\t\t\t\t  unsigned int devfn, int where, int size,\n\t\t\t\t  u32 value)\n{\n\tu32 data32;\n\tu32 shift = 8 * (where & 3);\n\tu8 byte_en;\n\n\tif (busno == pcie->root_bus_nr && pcie->pcie_data->ops->rp_write_cfg)\n\t\treturn pcie->pcie_data->ops->rp_write_cfg(pcie, busno,\n\t\t\t\t\t\t     where, size, value);\n\n\tswitch (size) {\n\tcase 1:\n\t\tdata32 = (value & 0xff) << shift;\n\t\tbyte_en = 1 << (where & 3);\n\t\tbreak;\n\tcase 2:\n\t\tdata32 = (value & 0xffff) << shift;\n\t\tbyte_en = 3 << (where & 3);\n\t\tbreak;\n\tdefault:\n\t\tdata32 = value;\n\t\tbyte_en = 0xf;\n\t\tbreak;\n\t}\n\n\treturn tlp_cfg_dword_write(pcie, busno, devfn, (where & ~DWORD_MASK),\n\t\t\t\t   byte_en, data32);\n}\n\nstatic int altera_pcie_cfg_read(struct pci_bus *bus, unsigned int devfn,\n\t\t\t\tint where, int size, u32 *value)\n{\n\tstruct altera_pcie *pcie = bus->sysdata;\n\n\tif (altera_pcie_hide_rc_bar(bus, devfn, where))\n\t\treturn PCIBIOS_BAD_REGISTER_NUMBER;\n\n\tif (!altera_pcie_valid_device(pcie, bus, PCI_SLOT(devfn)))\n\t\treturn PCIBIOS_DEVICE_NOT_FOUND;\n\n\treturn _altera_pcie_cfg_read(pcie, bus->number, devfn, where, size,\n\t\t\t\t     value);\n}\n\nstatic int altera_pcie_cfg_write(struct pci_bus *bus, unsigned int devfn,\n\t\t\t\t int where, int size, u32 value)\n{\n\tstruct altera_pcie *pcie = bus->sysdata;\n\n\tif (altera_pcie_hide_rc_bar(bus, devfn, where))\n\t\treturn PCIBIOS_BAD_REGISTER_NUMBER;\n\n\tif (!altera_pcie_valid_device(pcie, bus, PCI_SLOT(devfn)))\n\t\treturn PCIBIOS_DEVICE_NOT_FOUND;\n\n\treturn _altera_pcie_cfg_write(pcie, bus->number, devfn, where, size,\n\t\t\t\t     value);\n}\n\nstatic struct pci_ops altera_pcie_ops = {\n\t.read = altera_pcie_cfg_read,\n\t.write = altera_pcie_cfg_write,\n};\n\nstatic int altera_read_cap_word(struct altera_pcie *pcie, u8 busno,\n\t\t\t\tunsigned int devfn, int offset, u16 *value)\n{\n\tu32 data;\n\tint ret;\n\n\tret = _altera_pcie_cfg_read(pcie, busno, devfn,\n\t\t\t\t    pcie->pcie_data->cap_offset + offset,\n\t\t\t\t    sizeof(*value),\n\t\t\t\t    &data);\n\t*value = data;\n\treturn ret;\n}\n\nstatic int altera_write_cap_word(struct altera_pcie *pcie, u8 busno,\n\t\t\t\t unsigned int devfn, int offset, u16 value)\n{\n\treturn _altera_pcie_cfg_write(pcie, busno, devfn,\n\t\t\t\t      pcie->pcie_data->cap_offset + offset,\n\t\t\t\t      sizeof(value),\n\t\t\t\t      value);\n}\n\nstatic void altera_wait_link_retrain(struct altera_pcie *pcie)\n{\n\tstruct device *dev = &pcie->pdev->dev;\n\tu16 reg16;\n\tunsigned long start_jiffies;\n\n\t \n\tstart_jiffies = jiffies;\n\tfor (;;) {\n\t\taltera_read_cap_word(pcie, pcie->root_bus_nr, RP_DEVFN,\n\t\t\t\t     PCI_EXP_LNKSTA, &reg16);\n\t\tif (!(reg16 & PCI_EXP_LNKSTA_LT))\n\t\t\tbreak;\n\n\t\tif (time_after(jiffies, start_jiffies + LINK_RETRAIN_TIMEOUT)) {\n\t\t\tdev_err(dev, \"link retrain timeout\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tudelay(100);\n\t}\n\n\t \n\tstart_jiffies = jiffies;\n\tfor (;;) {\n\t\tif (pcie->pcie_data->ops->get_link_status(pcie))\n\t\t\tbreak;\n\n\t\tif (time_after(jiffies, start_jiffies + LINK_UP_TIMEOUT)) {\n\t\t\tdev_err(dev, \"link up timeout\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tudelay(100);\n\t}\n}\n\nstatic void altera_pcie_retrain(struct altera_pcie *pcie)\n{\n\tu16 linkcap, linkstat, linkctl;\n\n\tif (!pcie->pcie_data->ops->get_link_status(pcie))\n\t\treturn;\n\n\t \n\taltera_read_cap_word(pcie, pcie->root_bus_nr, RP_DEVFN, PCI_EXP_LNKCAP,\n\t\t\t     &linkcap);\n\tif ((linkcap & PCI_EXP_LNKCAP_SLS) <= PCI_EXP_LNKCAP_SLS_2_5GB)\n\t\treturn;\n\n\taltera_read_cap_word(pcie, pcie->root_bus_nr, RP_DEVFN, PCI_EXP_LNKSTA,\n\t\t\t     &linkstat);\n\tif ((linkstat & PCI_EXP_LNKSTA_CLS) == PCI_EXP_LNKSTA_CLS_2_5GB) {\n\t\taltera_read_cap_word(pcie, pcie->root_bus_nr, RP_DEVFN,\n\t\t\t\t     PCI_EXP_LNKCTL, &linkctl);\n\t\tlinkctl |= PCI_EXP_LNKCTL_RL;\n\t\taltera_write_cap_word(pcie, pcie->root_bus_nr, RP_DEVFN,\n\t\t\t\t      PCI_EXP_LNKCTL, linkctl);\n\n\t\taltera_wait_link_retrain(pcie);\n\t}\n}\n\nstatic int altera_pcie_intx_map(struct irq_domain *domain, unsigned int irq,\n\t\t\t\tirq_hw_number_t hwirq)\n{\n\tirq_set_chip_and_handler(irq, &dummy_irq_chip, handle_simple_irq);\n\tirq_set_chip_data(irq, domain->host_data);\n\treturn 0;\n}\n\nstatic const struct irq_domain_ops intx_domain_ops = {\n\t.map = altera_pcie_intx_map,\n\t.xlate = pci_irqd_intx_xlate,\n};\n\nstatic void altera_pcie_isr(struct irq_desc *desc)\n{\n\tstruct irq_chip *chip = irq_desc_get_chip(desc);\n\tstruct altera_pcie *pcie;\n\tstruct device *dev;\n\tunsigned long status;\n\tu32 bit;\n\tint ret;\n\n\tchained_irq_enter(chip, desc);\n\tpcie = irq_desc_get_handler_data(desc);\n\tdev = &pcie->pdev->dev;\n\n\twhile ((status = cra_readl(pcie, P2A_INT_STATUS)\n\t\t& P2A_INT_STS_ALL) != 0) {\n\t\tfor_each_set_bit(bit, &status, PCI_NUM_INTX) {\n\t\t\t \n\t\t\tcra_writel(pcie, 1 << bit, P2A_INT_STATUS);\n\n\t\t\tret = generic_handle_domain_irq(pcie->irq_domain, bit);\n\t\t\tif (ret)\n\t\t\t\tdev_err_ratelimited(dev, \"unexpected IRQ, INT%d\\n\", bit);\n\t\t}\n\t}\n\n\tchained_irq_exit(chip, desc);\n}\n\nstatic int altera_pcie_init_irq_domain(struct altera_pcie *pcie)\n{\n\tstruct device *dev = &pcie->pdev->dev;\n\tstruct device_node *node = dev->of_node;\n\n\t \n\tpcie->irq_domain = irq_domain_add_linear(node, PCI_NUM_INTX,\n\t\t\t\t\t&intx_domain_ops, pcie);\n\tif (!pcie->irq_domain) {\n\t\tdev_err(dev, \"Failed to get a INTx IRQ domain\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic void altera_pcie_irq_teardown(struct altera_pcie *pcie)\n{\n\tirq_set_chained_handler_and_data(pcie->irq, NULL, NULL);\n\tirq_domain_remove(pcie->irq_domain);\n\tirq_dispose_mapping(pcie->irq);\n}\n\nstatic int altera_pcie_parse_dt(struct altera_pcie *pcie)\n{\n\tstruct platform_device *pdev = pcie->pdev;\n\n\tpcie->cra_base = devm_platform_ioremap_resource_byname(pdev, \"Cra\");\n\tif (IS_ERR(pcie->cra_base))\n\t\treturn PTR_ERR(pcie->cra_base);\n\n\tif (pcie->pcie_data->version == ALTERA_PCIE_V2) {\n\t\tpcie->hip_base =\n\t\t\tdevm_platform_ioremap_resource_byname(pdev, \"Hip\");\n\t\tif (IS_ERR(pcie->hip_base))\n\t\t\treturn PTR_ERR(pcie->hip_base);\n\t}\n\n\t \n\tpcie->irq = platform_get_irq(pdev, 0);\n\tif (pcie->irq < 0)\n\t\treturn pcie->irq;\n\n\tirq_set_chained_handler_and_data(pcie->irq, altera_pcie_isr, pcie);\n\treturn 0;\n}\n\nstatic void altera_pcie_host_init(struct altera_pcie *pcie)\n{\n\taltera_pcie_retrain(pcie);\n}\n\nstatic const struct altera_pcie_ops altera_pcie_ops_1_0 = {\n\t.tlp_read_pkt = tlp_read_packet,\n\t.tlp_write_pkt = tlp_write_packet,\n\t.get_link_status = altera_pcie_link_up,\n};\n\nstatic const struct altera_pcie_ops altera_pcie_ops_2_0 = {\n\t.tlp_read_pkt = s10_tlp_read_packet,\n\t.tlp_write_pkt = s10_tlp_write_packet,\n\t.get_link_status = s10_altera_pcie_link_up,\n\t.rp_read_cfg = s10_rp_read_cfg,\n\t.rp_write_cfg = s10_rp_write_cfg,\n};\n\nstatic const struct altera_pcie_data altera_pcie_1_0_data = {\n\t.ops = &altera_pcie_ops_1_0,\n\t.cap_offset = 0x80,\n\t.version = ALTERA_PCIE_V1,\n\t.cfgrd0 = TLP_FMTTYPE_CFGRD0,\n\t.cfgrd1 = TLP_FMTTYPE_CFGRD1,\n\t.cfgwr0 = TLP_FMTTYPE_CFGWR0,\n\t.cfgwr1 = TLP_FMTTYPE_CFGWR1,\n};\n\nstatic const struct altera_pcie_data altera_pcie_2_0_data = {\n\t.ops = &altera_pcie_ops_2_0,\n\t.version = ALTERA_PCIE_V2,\n\t.cap_offset = 0x70,\n\t.cfgrd0 = S10_TLP_FMTTYPE_CFGRD0,\n\t.cfgrd1 = S10_TLP_FMTTYPE_CFGRD1,\n\t.cfgwr0 = S10_TLP_FMTTYPE_CFGWR0,\n\t.cfgwr1 = S10_TLP_FMTTYPE_CFGWR1,\n};\n\nstatic const struct of_device_id altera_pcie_of_match[] = {\n\t{.compatible = \"altr,pcie-root-port-1.0\",\n\t .data = &altera_pcie_1_0_data },\n\t{.compatible = \"altr,pcie-root-port-2.0\",\n\t .data = &altera_pcie_2_0_data },\n\t{},\n};\n\nstatic int altera_pcie_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct altera_pcie *pcie;\n\tstruct pci_host_bridge *bridge;\n\tint ret;\n\tconst struct altera_pcie_data *data;\n\n\tbridge = devm_pci_alloc_host_bridge(dev, sizeof(*pcie));\n\tif (!bridge)\n\t\treturn -ENOMEM;\n\n\tpcie = pci_host_bridge_priv(bridge);\n\tpcie->pdev = pdev;\n\tplatform_set_drvdata(pdev, pcie);\n\n\tdata = of_device_get_match_data(&pdev->dev);\n\tif (!data)\n\t\treturn -ENODEV;\n\n\tpcie->pcie_data = data;\n\n\tret = altera_pcie_parse_dt(pcie);\n\tif (ret) {\n\t\tdev_err(dev, \"Parsing DT failed\\n\");\n\t\treturn ret;\n\t}\n\n\tret = altera_pcie_init_irq_domain(pcie);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed creating IRQ Domain\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tcra_writel(pcie, P2A_INT_STS_ALL, P2A_INT_STATUS);\n\t \n\tcra_writel(pcie, P2A_INT_ENA_ALL, P2A_INT_ENABLE);\n\taltera_pcie_host_init(pcie);\n\n\tbridge->sysdata = pcie;\n\tbridge->busnr = pcie->root_bus_nr;\n\tbridge->ops = &altera_pcie_ops;\n\n\treturn pci_host_probe(bridge);\n}\n\nstatic void altera_pcie_remove(struct platform_device *pdev)\n{\n\tstruct altera_pcie *pcie = platform_get_drvdata(pdev);\n\tstruct pci_host_bridge *bridge = pci_host_bridge_from_priv(pcie);\n\n\tpci_stop_root_bus(bridge->bus);\n\tpci_remove_root_bus(bridge->bus);\n\taltera_pcie_irq_teardown(pcie);\n}\n\nstatic struct platform_driver altera_pcie_driver = {\n\t.probe\t\t= altera_pcie_probe,\n\t.remove_new\t= altera_pcie_remove,\n\t.driver = {\n\t\t.name\t= \"altera-pcie\",\n\t\t.of_match_table = altera_pcie_of_match,\n\t},\n};\n\nMODULE_DEVICE_TABLE(of, altera_pcie_of_match);\nmodule_platform_driver(altera_pcie_driver);\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}