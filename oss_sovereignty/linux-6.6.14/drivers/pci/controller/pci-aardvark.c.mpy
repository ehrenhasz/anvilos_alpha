{
  "module_name": "pci-aardvark.c",
  "hash_id": "6883aeeb5cc13b68a15d8c08eecd368d39fc4bda62658cd312430881a734b2eb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/controller/pci-aardvark.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/pci-ecam.h>\n#include <linux/init.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n#include <linux/msi.h>\n#include <linux/of_address.h>\n#include <linux/of_gpio.h>\n#include <linux/of_pci.h>\n\n#include \"../pci.h\"\n#include \"../pci-bridge-emul.h\"\n\n \n#define PCIE_CORE_DEV_ID_REG\t\t\t\t\t0x0\n#define PCIE_CORE_CMD_STATUS_REG\t\t\t\t0x4\n#define PCIE_CORE_DEV_REV_REG\t\t\t\t\t0x8\n#define PCIE_CORE_SSDEV_ID_REG\t\t\t\t\t0x2c\n#define PCIE_CORE_PCIEXP_CAP\t\t\t\t\t0xc0\n#define PCIE_CORE_PCIERR_CAP\t\t\t\t\t0x100\n#define PCIE_CORE_ERR_CAPCTL_REG\t\t\t\t0x118\n#define     PCIE_CORE_ERR_CAPCTL_ECRC_CHK_TX\t\t\tBIT(5)\n#define     PCIE_CORE_ERR_CAPCTL_ECRC_CHK_TX_EN\t\t\tBIT(6)\n#define     PCIE_CORE_ERR_CAPCTL_ECRC_CHCK\t\t\tBIT(7)\n#define     PCIE_CORE_ERR_CAPCTL_ECRC_CHCK_RCV\t\t\tBIT(8)\n \n#define PIO_BASE_ADDR\t\t\t\t0x4000\n#define PIO_CTRL\t\t\t\t(PIO_BASE_ADDR + 0x0)\n#define   PIO_CTRL_TYPE_MASK\t\t\tGENMASK(3, 0)\n#define   PIO_CTRL_ADDR_WIN_DISABLE\t\tBIT(24)\n#define PIO_STAT\t\t\t\t(PIO_BASE_ADDR + 0x4)\n#define   PIO_COMPLETION_STATUS_SHIFT\t\t7\n#define   PIO_COMPLETION_STATUS_MASK\t\tGENMASK(9, 7)\n#define   PIO_COMPLETION_STATUS_OK\t\t0\n#define   PIO_COMPLETION_STATUS_UR\t\t1\n#define   PIO_COMPLETION_STATUS_CRS\t\t2\n#define   PIO_COMPLETION_STATUS_CA\t\t4\n#define   PIO_NON_POSTED_REQ\t\t\tBIT(10)\n#define   PIO_ERR_STATUS\t\t\tBIT(11)\n#define PIO_ADDR_LS\t\t\t\t(PIO_BASE_ADDR + 0x8)\n#define PIO_ADDR_MS\t\t\t\t(PIO_BASE_ADDR + 0xc)\n#define PIO_WR_DATA\t\t\t\t(PIO_BASE_ADDR + 0x10)\n#define PIO_WR_DATA_STRB\t\t\t(PIO_BASE_ADDR + 0x14)\n#define PIO_RD_DATA\t\t\t\t(PIO_BASE_ADDR + 0x18)\n#define PIO_START\t\t\t\t(PIO_BASE_ADDR + 0x1c)\n#define PIO_ISR\t\t\t\t\t(PIO_BASE_ADDR + 0x20)\n#define PIO_ISRM\t\t\t\t(PIO_BASE_ADDR + 0x24)\n\n \n#define CONTROL_BASE_ADDR\t\t\t0x4800\n#define PCIE_CORE_CTRL0_REG\t\t\t(CONTROL_BASE_ADDR + 0x0)\n#define     PCIE_GEN_SEL_MSK\t\t\t0x3\n#define     PCIE_GEN_SEL_SHIFT\t\t\t0x0\n#define     SPEED_GEN_1\t\t\t\t0\n#define     SPEED_GEN_2\t\t\t\t1\n#define     SPEED_GEN_3\t\t\t\t2\n#define     IS_RC_MSK\t\t\t\t1\n#define     IS_RC_SHIFT\t\t\t\t2\n#define     LANE_CNT_MSK\t\t\t0x18\n#define     LANE_CNT_SHIFT\t\t\t0x3\n#define     LANE_COUNT_1\t\t\t(0 << LANE_CNT_SHIFT)\n#define     LANE_COUNT_2\t\t\t(1 << LANE_CNT_SHIFT)\n#define     LANE_COUNT_4\t\t\t(2 << LANE_CNT_SHIFT)\n#define     LANE_COUNT_8\t\t\t(3 << LANE_CNT_SHIFT)\n#define     LINK_TRAINING_EN\t\t\tBIT(6)\n#define     LEGACY_INTA\t\t\t\tBIT(28)\n#define     LEGACY_INTB\t\t\t\tBIT(29)\n#define     LEGACY_INTC\t\t\t\tBIT(30)\n#define     LEGACY_INTD\t\t\t\tBIT(31)\n#define PCIE_CORE_CTRL1_REG\t\t\t(CONTROL_BASE_ADDR + 0x4)\n#define     HOT_RESET_GEN\t\t\tBIT(0)\n#define PCIE_CORE_CTRL2_REG\t\t\t(CONTROL_BASE_ADDR + 0x8)\n#define     PCIE_CORE_CTRL2_RESERVED\t\t0x7\n#define     PCIE_CORE_CTRL2_TD_ENABLE\t\tBIT(4)\n#define     PCIE_CORE_CTRL2_STRICT_ORDER_ENABLE\tBIT(5)\n#define     PCIE_CORE_CTRL2_OB_WIN_ENABLE\tBIT(6)\n#define     PCIE_CORE_CTRL2_MSI_ENABLE\t\tBIT(10)\n#define PCIE_CORE_REF_CLK_REG\t\t\t(CONTROL_BASE_ADDR + 0x14)\n#define     PCIE_CORE_REF_CLK_TX_ENABLE\t\tBIT(1)\n#define     PCIE_CORE_REF_CLK_RX_ENABLE\t\tBIT(2)\n#define PCIE_MSG_LOG_REG\t\t\t(CONTROL_BASE_ADDR + 0x30)\n#define PCIE_ISR0_REG\t\t\t\t(CONTROL_BASE_ADDR + 0x40)\n#define PCIE_MSG_PM_PME_MASK\t\t\tBIT(7)\n#define PCIE_ISR0_MASK_REG\t\t\t(CONTROL_BASE_ADDR + 0x44)\n#define     PCIE_ISR0_MSI_INT_PENDING\t\tBIT(24)\n#define     PCIE_ISR0_CORR_ERR\t\t\tBIT(11)\n#define     PCIE_ISR0_NFAT_ERR\t\t\tBIT(12)\n#define     PCIE_ISR0_FAT_ERR\t\t\tBIT(13)\n#define     PCIE_ISR0_ERR_MASK\t\t\tGENMASK(13, 11)\n#define     PCIE_ISR0_INTX_ASSERT(val)\t\tBIT(16 + (val))\n#define     PCIE_ISR0_INTX_DEASSERT(val)\tBIT(20 + (val))\n#define     PCIE_ISR0_ALL_MASK\t\t\tGENMASK(31, 0)\n#define PCIE_ISR1_REG\t\t\t\t(CONTROL_BASE_ADDR + 0x48)\n#define PCIE_ISR1_MASK_REG\t\t\t(CONTROL_BASE_ADDR + 0x4C)\n#define     PCIE_ISR1_POWER_STATE_CHANGE\tBIT(4)\n#define     PCIE_ISR1_FLUSH\t\t\tBIT(5)\n#define     PCIE_ISR1_INTX_ASSERT(val)\t\tBIT(8 + (val))\n#define     PCIE_ISR1_ALL_MASK\t\t\tGENMASK(31, 0)\n#define PCIE_MSI_ADDR_LOW_REG\t\t\t(CONTROL_BASE_ADDR + 0x50)\n#define PCIE_MSI_ADDR_HIGH_REG\t\t\t(CONTROL_BASE_ADDR + 0x54)\n#define PCIE_MSI_STATUS_REG\t\t\t(CONTROL_BASE_ADDR + 0x58)\n#define PCIE_MSI_MASK_REG\t\t\t(CONTROL_BASE_ADDR + 0x5C)\n#define     PCIE_MSI_ALL_MASK\t\t\tGENMASK(31, 0)\n#define PCIE_MSI_PAYLOAD_REG\t\t\t(CONTROL_BASE_ADDR + 0x9C)\n#define     PCIE_MSI_DATA_MASK\t\t\tGENMASK(15, 0)\n\n \n#define OB_WIN_BASE_ADDR\t\t\t0x4c00\n#define OB_WIN_BLOCK_SIZE\t\t\t0x20\n#define OB_WIN_COUNT\t\t\t\t8\n#define OB_WIN_REG_ADDR(win, offset)\t\t(OB_WIN_BASE_ADDR + \\\n\t\t\t\t\t\t OB_WIN_BLOCK_SIZE * (win) + \\\n\t\t\t\t\t\t (offset))\n#define OB_WIN_MATCH_LS(win)\t\t\tOB_WIN_REG_ADDR(win, 0x00)\n#define     OB_WIN_ENABLE\t\t\tBIT(0)\n#define OB_WIN_MATCH_MS(win)\t\t\tOB_WIN_REG_ADDR(win, 0x04)\n#define OB_WIN_REMAP_LS(win)\t\t\tOB_WIN_REG_ADDR(win, 0x08)\n#define OB_WIN_REMAP_MS(win)\t\t\tOB_WIN_REG_ADDR(win, 0x0c)\n#define OB_WIN_MASK_LS(win)\t\t\tOB_WIN_REG_ADDR(win, 0x10)\n#define OB_WIN_MASK_MS(win)\t\t\tOB_WIN_REG_ADDR(win, 0x14)\n#define OB_WIN_ACTIONS(win)\t\t\tOB_WIN_REG_ADDR(win, 0x18)\n#define OB_WIN_DEFAULT_ACTIONS\t\t\t(OB_WIN_ACTIONS(OB_WIN_COUNT-1) + 0x4)\n#define     OB_WIN_FUNC_NUM_MASK\t\tGENMASK(31, 24)\n#define     OB_WIN_FUNC_NUM_SHIFT\t\t24\n#define     OB_WIN_FUNC_NUM_ENABLE\t\tBIT(23)\n#define     OB_WIN_BUS_NUM_BITS_MASK\t\tGENMASK(22, 20)\n#define     OB_WIN_BUS_NUM_BITS_SHIFT\t\t20\n#define     OB_WIN_MSG_CODE_ENABLE\t\tBIT(22)\n#define     OB_WIN_MSG_CODE_MASK\t\tGENMASK(21, 14)\n#define     OB_WIN_MSG_CODE_SHIFT\t\t14\n#define     OB_WIN_MSG_PAYLOAD_LEN\t\tBIT(12)\n#define     OB_WIN_ATTR_ENABLE\t\t\tBIT(11)\n#define     OB_WIN_ATTR_TC_MASK\t\t\tGENMASK(10, 8)\n#define     OB_WIN_ATTR_TC_SHIFT\t\t8\n#define     OB_WIN_ATTR_RELAXED\t\t\tBIT(7)\n#define     OB_WIN_ATTR_NOSNOOP\t\t\tBIT(6)\n#define     OB_WIN_ATTR_POISON\t\t\tBIT(5)\n#define     OB_WIN_ATTR_IDO\t\t\tBIT(4)\n#define     OB_WIN_TYPE_MASK\t\t\tGENMASK(3, 0)\n#define     OB_WIN_TYPE_SHIFT\t\t\t0\n#define     OB_WIN_TYPE_MEM\t\t\t0x0\n#define     OB_WIN_TYPE_IO\t\t\t0x4\n#define     OB_WIN_TYPE_CONFIG_TYPE0\t\t0x8\n#define     OB_WIN_TYPE_CONFIG_TYPE1\t\t0x9\n#define     OB_WIN_TYPE_MSG\t\t\t0xc\n\n \n#define LMI_BASE_ADDR\t\t\t\t0x6000\n#define CFG_REG\t\t\t\t\t(LMI_BASE_ADDR + 0x0)\n#define     LTSSM_SHIFT\t\t\t\t24\n#define     LTSSM_MASK\t\t\t\t0x3f\n#define     RC_BAR_CONFIG\t\t\t0x300\n\n \nenum {\n\tLTSSM_DETECT_QUIET\t\t\t= 0x0,\n\tLTSSM_DETECT_ACTIVE\t\t\t= 0x1,\n\tLTSSM_POLLING_ACTIVE\t\t\t= 0x2,\n\tLTSSM_POLLING_COMPLIANCE\t\t= 0x3,\n\tLTSSM_POLLING_CONFIGURATION\t\t= 0x4,\n\tLTSSM_CONFIG_LINKWIDTH_START\t\t= 0x5,\n\tLTSSM_CONFIG_LINKWIDTH_ACCEPT\t\t= 0x6,\n\tLTSSM_CONFIG_LANENUM_ACCEPT\t\t= 0x7,\n\tLTSSM_CONFIG_LANENUM_WAIT\t\t= 0x8,\n\tLTSSM_CONFIG_COMPLETE\t\t\t= 0x9,\n\tLTSSM_CONFIG_IDLE\t\t\t= 0xa,\n\tLTSSM_RECOVERY_RCVR_LOCK\t\t= 0xb,\n\tLTSSM_RECOVERY_SPEED\t\t\t= 0xc,\n\tLTSSM_RECOVERY_RCVR_CFG\t\t\t= 0xd,\n\tLTSSM_RECOVERY_IDLE\t\t\t= 0xe,\n\tLTSSM_L0\t\t\t\t= 0x10,\n\tLTSSM_RX_L0S_ENTRY\t\t\t= 0x11,\n\tLTSSM_RX_L0S_IDLE\t\t\t= 0x12,\n\tLTSSM_RX_L0S_FTS\t\t\t= 0x13,\n\tLTSSM_TX_L0S_ENTRY\t\t\t= 0x14,\n\tLTSSM_TX_L0S_IDLE\t\t\t= 0x15,\n\tLTSSM_TX_L0S_FTS\t\t\t= 0x16,\n\tLTSSM_L1_ENTRY\t\t\t\t= 0x17,\n\tLTSSM_L1_IDLE\t\t\t\t= 0x18,\n\tLTSSM_L2_IDLE\t\t\t\t= 0x19,\n\tLTSSM_L2_TRANSMIT_WAKE\t\t\t= 0x1a,\n\tLTSSM_DISABLED\t\t\t\t= 0x20,\n\tLTSSM_LOOPBACK_ENTRY_MASTER\t\t= 0x21,\n\tLTSSM_LOOPBACK_ACTIVE_MASTER\t\t= 0x22,\n\tLTSSM_LOOPBACK_EXIT_MASTER\t\t= 0x23,\n\tLTSSM_LOOPBACK_ENTRY_SLAVE\t\t= 0x24,\n\tLTSSM_LOOPBACK_ACTIVE_SLAVE\t\t= 0x25,\n\tLTSSM_LOOPBACK_EXIT_SLAVE\t\t= 0x26,\n\tLTSSM_HOT_RESET\t\t\t\t= 0x27,\n\tLTSSM_RECOVERY_EQUALIZATION_PHASE0\t= 0x28,\n\tLTSSM_RECOVERY_EQUALIZATION_PHASE1\t= 0x29,\n\tLTSSM_RECOVERY_EQUALIZATION_PHASE2\t= 0x2a,\n\tLTSSM_RECOVERY_EQUALIZATION_PHASE3\t= 0x2b,\n};\n\n#define VENDOR_ID_REG\t\t\t\t(LMI_BASE_ADDR + 0x44)\n\n \n#define CTRL_CORE_BASE_ADDR\t\t\t0x18000\n#define CTRL_CONFIG_REG\t\t\t\t(CTRL_CORE_BASE_ADDR + 0x0)\n#define     CTRL_MODE_SHIFT\t\t\t0x0\n#define     CTRL_MODE_MASK\t\t\t0x1\n#define     PCIE_CORE_MODE_DIRECT\t\t0x0\n#define     PCIE_CORE_MODE_COMMAND\t\t0x1\n\n \n#define CENTRAL_INT_BASE_ADDR\t\t\t0x1b000\n#define HOST_CTRL_INT_STATUS_REG\t\t(CENTRAL_INT_BASE_ADDR + 0x0)\n#define HOST_CTRL_INT_MASK_REG\t\t\t(CENTRAL_INT_BASE_ADDR + 0x4)\n#define     PCIE_IRQ_CMDQ_INT\t\t\tBIT(0)\n#define     PCIE_IRQ_MSI_STATUS_INT\t\tBIT(1)\n#define     PCIE_IRQ_CMD_SENT_DONE\t\tBIT(3)\n#define     PCIE_IRQ_DMA_INT\t\t\tBIT(4)\n#define     PCIE_IRQ_IB_DXFERDONE\t\tBIT(5)\n#define     PCIE_IRQ_OB_DXFERDONE\t\tBIT(6)\n#define     PCIE_IRQ_OB_RXFERDONE\t\tBIT(7)\n#define     PCIE_IRQ_COMPQ_INT\t\t\tBIT(12)\n#define     PCIE_IRQ_DIR_RD_DDR_DET\t\tBIT(13)\n#define     PCIE_IRQ_DIR_WR_DDR_DET\t\tBIT(14)\n#define     PCIE_IRQ_CORE_INT\t\t\tBIT(16)\n#define     PCIE_IRQ_CORE_INT_PIO\t\tBIT(17)\n#define     PCIE_IRQ_DPMU_INT\t\t\tBIT(18)\n#define     PCIE_IRQ_PCIE_MIS_INT\t\tBIT(19)\n#define     PCIE_IRQ_MSI_INT1_DET\t\tBIT(20)\n#define     PCIE_IRQ_MSI_INT2_DET\t\tBIT(21)\n#define     PCIE_IRQ_RC_DBELL_DET\t\tBIT(22)\n#define     PCIE_IRQ_EP_STATUS\t\t\tBIT(23)\n#define     PCIE_IRQ_ALL_MASK\t\t\tGENMASK(31, 0)\n#define     PCIE_IRQ_ENABLE_INTS_MASK\t\tPCIE_IRQ_CORE_INT\n\n \n#define PCIE_CONFIG_RD_TYPE0\t\t\t0x8\n#define PCIE_CONFIG_RD_TYPE1\t\t\t0x9\n#define PCIE_CONFIG_WR_TYPE0\t\t\t0xa\n#define PCIE_CONFIG_WR_TYPE1\t\t\t0xb\n\n#define PIO_RETRY_CNT\t\t\t750000  \n#define PIO_RETRY_DELAY\t\t\t2  \n\n#define LINK_WAIT_MAX_RETRIES\t\t10\n#define LINK_WAIT_USLEEP_MIN\t\t90000\n#define LINK_WAIT_USLEEP_MAX\t\t100000\n#define RETRAIN_WAIT_MAX_RETRIES\t10\n#define RETRAIN_WAIT_USLEEP_US\t\t2000\n\n#define MSI_IRQ_NUM\t\t\t32\n\n#define CFG_RD_CRS_VAL\t\t\t0xffff0001\n\nstruct advk_pcie {\n\tstruct platform_device *pdev;\n\tvoid __iomem *base;\n\tstruct {\n\t\tphys_addr_t match;\n\t\tphys_addr_t remap;\n\t\tphys_addr_t mask;\n\t\tu32 actions;\n\t} wins[OB_WIN_COUNT];\n\tu8 wins_count;\n\tstruct irq_domain *rp_irq_domain;\n\tstruct irq_domain *irq_domain;\n\tstruct irq_chip irq_chip;\n\traw_spinlock_t irq_lock;\n\tstruct irq_domain *msi_domain;\n\tstruct irq_domain *msi_inner_domain;\n\traw_spinlock_t msi_irq_lock;\n\tDECLARE_BITMAP(msi_used, MSI_IRQ_NUM);\n\tstruct mutex msi_used_lock;\n\tint link_gen;\n\tstruct pci_bridge_emul bridge;\n\tstruct gpio_desc *reset_gpio;\n\tstruct phy *phy;\n};\n\nstatic inline void advk_writel(struct advk_pcie *pcie, u32 val, u64 reg)\n{\n\twritel(val, pcie->base + reg);\n}\n\nstatic inline u32 advk_readl(struct advk_pcie *pcie, u64 reg)\n{\n\treturn readl(pcie->base + reg);\n}\n\nstatic u8 advk_pcie_ltssm_state(struct advk_pcie *pcie)\n{\n\tu32 val;\n\tu8 ltssm_state;\n\n\tval = advk_readl(pcie, CFG_REG);\n\tltssm_state = (val >> LTSSM_SHIFT) & LTSSM_MASK;\n\treturn ltssm_state;\n}\n\nstatic inline bool advk_pcie_link_up(struct advk_pcie *pcie)\n{\n\t \n\tu8 ltssm_state = advk_pcie_ltssm_state(pcie);\n\treturn ltssm_state >= LTSSM_L0 && ltssm_state < LTSSM_DISABLED;\n}\n\nstatic inline bool advk_pcie_link_active(struct advk_pcie *pcie)\n{\n\t \n\tu8 ltssm_state = advk_pcie_ltssm_state(pcie);\n\treturn ltssm_state >= LTSSM_CONFIG_IDLE && ltssm_state < LTSSM_DISABLED;\n}\n\nstatic inline bool advk_pcie_link_training(struct advk_pcie *pcie)\n{\n\t \n\tu8 ltssm_state = advk_pcie_ltssm_state(pcie);\n\treturn ((ltssm_state >= LTSSM_CONFIG_LINKWIDTH_START &&\n\t\t ltssm_state < LTSSM_L0) ||\n\t\t(ltssm_state >= LTSSM_RECOVERY_EQUALIZATION_PHASE0 &&\n\t\t ltssm_state <= LTSSM_RECOVERY_EQUALIZATION_PHASE3));\n}\n\nstatic int advk_pcie_wait_for_link(struct advk_pcie *pcie)\n{\n\tint retries;\n\n\t \n\tfor (retries = 0; retries < LINK_WAIT_MAX_RETRIES; retries++) {\n\t\tif (advk_pcie_link_up(pcie))\n\t\t\treturn 0;\n\n\t\tusleep_range(LINK_WAIT_USLEEP_MIN, LINK_WAIT_USLEEP_MAX);\n\t}\n\n\treturn -ETIMEDOUT;\n}\n\nstatic void advk_pcie_wait_for_retrain(struct advk_pcie *pcie)\n{\n\tsize_t retries;\n\n\tfor (retries = 0; retries < RETRAIN_WAIT_MAX_RETRIES; ++retries) {\n\t\tif (advk_pcie_link_training(pcie))\n\t\t\tbreak;\n\t\tudelay(RETRAIN_WAIT_USLEEP_US);\n\t}\n}\n\nstatic void advk_pcie_issue_perst(struct advk_pcie *pcie)\n{\n\tif (!pcie->reset_gpio)\n\t\treturn;\n\n\t \n\tdev_info(&pcie->pdev->dev, \"issuing PERST via reset GPIO for 10ms\\n\");\n\tgpiod_set_value_cansleep(pcie->reset_gpio, 1);\n\tusleep_range(10000, 11000);\n\tgpiod_set_value_cansleep(pcie->reset_gpio, 0);\n}\n\nstatic void advk_pcie_train_link(struct advk_pcie *pcie)\n{\n\tstruct device *dev = &pcie->pdev->dev;\n\tu32 reg;\n\tint ret;\n\n\t \n\treg = advk_readl(pcie, PCIE_CORE_CTRL0_REG);\n\treg &= ~PCIE_GEN_SEL_MSK;\n\tif (pcie->link_gen == 3)\n\t\treg |= SPEED_GEN_3;\n\telse if (pcie->link_gen == 2)\n\t\treg |= SPEED_GEN_2;\n\telse\n\t\treg |= SPEED_GEN_1;\n\tadvk_writel(pcie, reg, PCIE_CORE_CTRL0_REG);\n\n\t \n\treg = advk_readl(pcie, PCIE_CORE_PCIEXP_CAP + PCI_EXP_LNKCTL2);\n\treg &= ~PCI_EXP_LNKCTL2_TLS;\n\tif (pcie->link_gen == 3)\n\t\treg |= PCI_EXP_LNKCTL2_TLS_8_0GT;\n\telse if (pcie->link_gen == 2)\n\t\treg |= PCI_EXP_LNKCTL2_TLS_5_0GT;\n\telse\n\t\treg |= PCI_EXP_LNKCTL2_TLS_2_5GT;\n\tadvk_writel(pcie, reg, PCIE_CORE_PCIEXP_CAP + PCI_EXP_LNKCTL2);\n\n\t \n\treg = advk_readl(pcie, PCIE_CORE_CTRL0_REG);\n\treg |= LINK_TRAINING_EN;\n\tadvk_writel(pcie, reg, PCIE_CORE_CTRL0_REG);\n\n\t \n\tadvk_pcie_issue_perst(pcie);\n\n\t \n\tret = advk_pcie_wait_for_link(pcie);\n\tif (ret < 0)\n\t\tdev_err(dev, \"link never came up\\n\");\n\telse\n\t\tdev_info(dev, \"link up\\n\");\n}\n\n \nstatic void advk_pcie_set_ob_win(struct advk_pcie *pcie, u8 win_num,\n\t\t\t\t phys_addr_t match, phys_addr_t remap,\n\t\t\t\t phys_addr_t mask, u32 actions)\n{\n\tadvk_writel(pcie, OB_WIN_ENABLE |\n\t\t\t  lower_32_bits(match), OB_WIN_MATCH_LS(win_num));\n\tadvk_writel(pcie, upper_32_bits(match), OB_WIN_MATCH_MS(win_num));\n\tadvk_writel(pcie, lower_32_bits(remap), OB_WIN_REMAP_LS(win_num));\n\tadvk_writel(pcie, upper_32_bits(remap), OB_WIN_REMAP_MS(win_num));\n\tadvk_writel(pcie, lower_32_bits(mask), OB_WIN_MASK_LS(win_num));\n\tadvk_writel(pcie, upper_32_bits(mask), OB_WIN_MASK_MS(win_num));\n\tadvk_writel(pcie, actions, OB_WIN_ACTIONS(win_num));\n}\n\nstatic void advk_pcie_disable_ob_win(struct advk_pcie *pcie, u8 win_num)\n{\n\tadvk_writel(pcie, 0, OB_WIN_MATCH_LS(win_num));\n\tadvk_writel(pcie, 0, OB_WIN_MATCH_MS(win_num));\n\tadvk_writel(pcie, 0, OB_WIN_REMAP_LS(win_num));\n\tadvk_writel(pcie, 0, OB_WIN_REMAP_MS(win_num));\n\tadvk_writel(pcie, 0, OB_WIN_MASK_LS(win_num));\n\tadvk_writel(pcie, 0, OB_WIN_MASK_MS(win_num));\n\tadvk_writel(pcie, 0, OB_WIN_ACTIONS(win_num));\n}\n\nstatic void advk_pcie_setup_hw(struct advk_pcie *pcie)\n{\n\tphys_addr_t msi_addr;\n\tu32 reg;\n\tint i;\n\n\t \n\treg = advk_readl(pcie, PCIE_CORE_REF_CLK_REG);\n\treg |= PCIE_CORE_REF_CLK_TX_ENABLE;\n\treg &= ~PCIE_CORE_REF_CLK_RX_ENABLE;\n\tadvk_writel(pcie, reg, PCIE_CORE_REF_CLK_REG);\n\n\t \n\treg = advk_readl(pcie, CTRL_CONFIG_REG);\n\treg &= ~(CTRL_MODE_MASK << CTRL_MODE_SHIFT);\n\treg |= ((PCIE_CORE_MODE_DIRECT & CTRL_MODE_MASK) << CTRL_MODE_SHIFT);\n\tadvk_writel(pcie, reg, CTRL_CONFIG_REG);\n\n\t \n\treg = advk_readl(pcie, PCIE_CORE_CTRL0_REG);\n\treg |= (IS_RC_MSK << IS_RC_SHIFT);\n\tadvk_writel(pcie, reg, PCIE_CORE_CTRL0_REG);\n\n\t \n\treg = (PCI_VENDOR_ID_MARVELL << 16) | PCI_VENDOR_ID_MARVELL;\n\tadvk_writel(pcie, reg, VENDOR_ID_REG);\n\n\t \n\treg = advk_readl(pcie, PCIE_CORE_DEV_REV_REG);\n\treg &= ~0xffffff00;\n\treg |= PCI_CLASS_BRIDGE_PCI_NORMAL << 8;\n\tadvk_writel(pcie, reg, PCIE_CORE_DEV_REV_REG);\n\n\t \n\treg = advk_readl(pcie, PCIE_CORE_CMD_STATUS_REG);\n\treg &= ~(PCI_COMMAND_IO | PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER);\n\tadvk_writel(pcie, reg, PCIE_CORE_CMD_STATUS_REG);\n\n\t \n\treg = PCIE_CORE_ERR_CAPCTL_ECRC_CHK_TX |\n\t\tPCIE_CORE_ERR_CAPCTL_ECRC_CHK_TX_EN |\n\t\tPCIE_CORE_ERR_CAPCTL_ECRC_CHCK |\n\t\tPCIE_CORE_ERR_CAPCTL_ECRC_CHCK_RCV;\n\tadvk_writel(pcie, reg, PCIE_CORE_ERR_CAPCTL_REG);\n\n\t \n\treg = advk_readl(pcie, PCIE_CORE_PCIEXP_CAP + PCI_EXP_DEVCTL);\n\treg &= ~PCI_EXP_DEVCTL_RELAX_EN;\n\treg &= ~PCI_EXP_DEVCTL_NOSNOOP_EN;\n\treg &= ~PCI_EXP_DEVCTL_PAYLOAD;\n\treg &= ~PCI_EXP_DEVCTL_READRQ;\n\treg |= PCI_EXP_DEVCTL_PAYLOAD_512B;\n\treg |= PCI_EXP_DEVCTL_READRQ_512B;\n\tadvk_writel(pcie, reg, PCIE_CORE_PCIEXP_CAP + PCI_EXP_DEVCTL);\n\n\t \n\treg = PCIE_CORE_CTRL2_RESERVED |\n\t\tPCIE_CORE_CTRL2_TD_ENABLE;\n\tadvk_writel(pcie, reg, PCIE_CORE_CTRL2_REG);\n\n\t \n\treg = advk_readl(pcie, PCIE_CORE_CTRL0_REG);\n\treg &= ~LANE_CNT_MSK;\n\treg |= LANE_COUNT_1;\n\tadvk_writel(pcie, reg, PCIE_CORE_CTRL0_REG);\n\n\t \n\tmsi_addr = virt_to_phys(pcie);\n\tadvk_writel(pcie, lower_32_bits(msi_addr), PCIE_MSI_ADDR_LOW_REG);\n\tadvk_writel(pcie, upper_32_bits(msi_addr), PCIE_MSI_ADDR_HIGH_REG);\n\n\t \n\treg = advk_readl(pcie, PCIE_CORE_CTRL2_REG);\n\treg |= PCIE_CORE_CTRL2_MSI_ENABLE;\n\tadvk_writel(pcie, reg, PCIE_CORE_CTRL2_REG);\n\n\t \n\tadvk_writel(pcie, PCIE_MSI_ALL_MASK, PCIE_MSI_STATUS_REG);\n\tadvk_writel(pcie, PCIE_ISR0_ALL_MASK, PCIE_ISR0_REG);\n\tadvk_writel(pcie, PCIE_ISR1_ALL_MASK, PCIE_ISR1_REG);\n\tadvk_writel(pcie, PCIE_IRQ_ALL_MASK, HOST_CTRL_INT_STATUS_REG);\n\n\t \n\tadvk_writel(pcie, PCIE_ISR0_ALL_MASK, PCIE_ISR0_MASK_REG);\n\tadvk_writel(pcie, PCIE_ISR1_ALL_MASK, PCIE_ISR1_MASK_REG);\n\tadvk_writel(pcie, PCIE_MSI_ALL_MASK, PCIE_MSI_MASK_REG);\n\n\t \n\treg = advk_readl(pcie, PCIE_ISR0_MASK_REG);\n\treg &= ~PCIE_ISR0_MSI_INT_PENDING;\n\tadvk_writel(pcie, reg, PCIE_ISR0_MASK_REG);\n\n\t \n\treg = advk_readl(pcie, PCIE_ISR0_MASK_REG);\n\treg &= ~PCIE_MSG_PM_PME_MASK;\n\tadvk_writel(pcie, reg, PCIE_ISR0_MASK_REG);\n\n\t \n\treg = PCIE_IRQ_ALL_MASK & (~PCIE_IRQ_ENABLE_INTS_MASK);\n\tadvk_writel(pcie, reg, HOST_CTRL_INT_MASK_REG);\n\n\t \n\treg = advk_readl(pcie, PCIE_CORE_CTRL2_REG);\n\treg |= PCIE_CORE_CTRL2_OB_WIN_ENABLE;\n\tadvk_writel(pcie, reg, PCIE_CORE_CTRL2_REG);\n\n\t \n\tadvk_writel(pcie, OB_WIN_TYPE_MEM, OB_WIN_DEFAULT_ACTIONS);\n\n\t \n\treg = advk_readl(pcie, PIO_CTRL);\n\treg |= PIO_CTRL_ADDR_WIN_DISABLE;\n\tadvk_writel(pcie, reg, PIO_CTRL);\n\n\t \n\tfor (i = 0; i < pcie->wins_count; i++)\n\t\tadvk_pcie_set_ob_win(pcie, i,\n\t\t\t\t     pcie->wins[i].match, pcie->wins[i].remap,\n\t\t\t\t     pcie->wins[i].mask, pcie->wins[i].actions);\n\n\t \n\tfor (i = pcie->wins_count; i < OB_WIN_COUNT; i++)\n\t\tadvk_pcie_disable_ob_win(pcie, i);\n\n\tadvk_pcie_train_link(pcie);\n}\n\nstatic int advk_pcie_check_pio_status(struct advk_pcie *pcie, bool allow_crs, u32 *val)\n{\n\tstruct device *dev = &pcie->pdev->dev;\n\tu32 reg;\n\tunsigned int status;\n\tchar *strcomp_status, *str_posted;\n\tint ret;\n\n\treg = advk_readl(pcie, PIO_STAT);\n\tstatus = (reg & PIO_COMPLETION_STATUS_MASK) >>\n\t\tPIO_COMPLETION_STATUS_SHIFT;\n\n\t \n\tswitch (status) {\n\tcase PIO_COMPLETION_STATUS_OK:\n\t\tif (reg & PIO_ERR_STATUS) {\n\t\t\tstrcomp_status = \"COMP_ERR\";\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tif (val)\n\t\t\t*val = advk_readl(pcie, PIO_RD_DATA);\n\t\t \n\t\tstrcomp_status = NULL;\n\t\tret = 0;\n\t\tbreak;\n\tcase PIO_COMPLETION_STATUS_UR:\n\t\tstrcomp_status = \"UR\";\n\t\tret = -EOPNOTSUPP;\n\t\tbreak;\n\tcase PIO_COMPLETION_STATUS_CRS:\n\t\tif (allow_crs && val) {\n\t\t\t \n\t\t\t*val = CFG_RD_CRS_VAL;\n\t\t\tstrcomp_status = NULL;\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tstrcomp_status = \"CRS\";\n\t\tret = -EAGAIN;\n\t\tbreak;\n\tcase PIO_COMPLETION_STATUS_CA:\n\t\tstrcomp_status = \"CA\";\n\t\tret = -ECANCELED;\n\t\tbreak;\n\tdefault:\n\t\tstrcomp_status = \"Unknown\";\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\tif (!strcomp_status)\n\t\treturn ret;\n\n\tif (reg & PIO_NON_POSTED_REQ)\n\t\tstr_posted = \"Non-posted\";\n\telse\n\t\tstr_posted = \"Posted\";\n\n\tdev_dbg(dev, \"%s PIO Response Status: %s, %#x @ %#x\\n\",\n\t\tstr_posted, strcomp_status, reg, advk_readl(pcie, PIO_ADDR_LS));\n\n\treturn ret;\n}\n\nstatic int advk_pcie_wait_pio(struct advk_pcie *pcie)\n{\n\tstruct device *dev = &pcie->pdev->dev;\n\tint i;\n\n\tfor (i = 1; i <= PIO_RETRY_CNT; i++) {\n\t\tu32 start, isr;\n\n\t\tstart = advk_readl(pcie, PIO_START);\n\t\tisr = advk_readl(pcie, PIO_ISR);\n\t\tif (!start && isr)\n\t\t\treturn i;\n\t\tudelay(PIO_RETRY_DELAY);\n\t}\n\n\tdev_err(dev, \"PIO read/write transfer time out\\n\");\n\treturn -ETIMEDOUT;\n}\n\nstatic pci_bridge_emul_read_status_t\nadvk_pci_bridge_emul_base_conf_read(struct pci_bridge_emul *bridge,\n\t\t\t\t    int reg, u32 *value)\n{\n\tstruct advk_pcie *pcie = bridge->data;\n\n\tswitch (reg) {\n\tcase PCI_COMMAND:\n\t\t*value = advk_readl(pcie, PCIE_CORE_CMD_STATUS_REG);\n\t\treturn PCI_BRIDGE_EMUL_HANDLED;\n\n\tcase PCI_INTERRUPT_LINE: {\n\t\t \n\t\t__le32 *cfgspace = (__le32 *)&bridge->conf;\n\t\tu32 val = le32_to_cpu(cfgspace[PCI_INTERRUPT_LINE / 4]);\n\t\tif (advk_readl(pcie, PCIE_ISR0_MASK_REG) & PCIE_ISR0_ERR_MASK)\n\t\t\tval &= ~(PCI_BRIDGE_CTL_SERR << 16);\n\t\telse\n\t\t\tval |= PCI_BRIDGE_CTL_SERR << 16;\n\t\tif (advk_readl(pcie, PCIE_CORE_CTRL1_REG) & HOT_RESET_GEN)\n\t\t\tval |= PCI_BRIDGE_CTL_BUS_RESET << 16;\n\t\telse\n\t\t\tval &= ~(PCI_BRIDGE_CTL_BUS_RESET << 16);\n\t\t*value = val;\n\t\treturn PCI_BRIDGE_EMUL_HANDLED;\n\t}\n\n\tdefault:\n\t\treturn PCI_BRIDGE_EMUL_NOT_HANDLED;\n\t}\n}\n\nstatic void\nadvk_pci_bridge_emul_base_conf_write(struct pci_bridge_emul *bridge,\n\t\t\t\t     int reg, u32 old, u32 new, u32 mask)\n{\n\tstruct advk_pcie *pcie = bridge->data;\n\n\tswitch (reg) {\n\tcase PCI_COMMAND:\n\t\tadvk_writel(pcie, new, PCIE_CORE_CMD_STATUS_REG);\n\t\tbreak;\n\n\tcase PCI_INTERRUPT_LINE:\n\t\t \n\t\tif (mask & (PCI_BRIDGE_CTL_SERR << 16)) {\n\t\t\tu32 val = advk_readl(pcie, PCIE_ISR0_MASK_REG);\n\t\t\tif (new & (PCI_BRIDGE_CTL_SERR << 16))\n\t\t\t\tval &= ~PCIE_ISR0_ERR_MASK;\n\t\t\telse\n\t\t\t\tval |= PCIE_ISR0_ERR_MASK;\n\t\t\tadvk_writel(pcie, val, PCIE_ISR0_MASK_REG);\n\t\t}\n\t\tif (mask & (PCI_BRIDGE_CTL_BUS_RESET << 16)) {\n\t\t\tu32 val = advk_readl(pcie, PCIE_CORE_CTRL1_REG);\n\t\t\tif (new & (PCI_BRIDGE_CTL_BUS_RESET << 16))\n\t\t\t\tval |= HOT_RESET_GEN;\n\t\t\telse\n\t\t\t\tval &= ~HOT_RESET_GEN;\n\t\t\tadvk_writel(pcie, val, PCIE_CORE_CTRL1_REG);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic pci_bridge_emul_read_status_t\nadvk_pci_bridge_emul_pcie_conf_read(struct pci_bridge_emul *bridge,\n\t\t\t\t    int reg, u32 *value)\n{\n\tstruct advk_pcie *pcie = bridge->data;\n\n\n\tswitch (reg) {\n\t \n\n\tcase PCI_EXP_LNKCAP: {\n\t\tu32 val = advk_readl(pcie, PCIE_CORE_PCIEXP_CAP + reg);\n\t\t \n\t\tval |= PCI_EXP_LNKCAP_DLLLARC;\n\t\t*value = val;\n\t\treturn PCI_BRIDGE_EMUL_HANDLED;\n\t}\n\n\tcase PCI_EXP_LNKCTL: {\n\t\t \n\t\tu32 val = advk_readl(pcie, PCIE_CORE_PCIEXP_CAP + reg) &\n\t\t\t~(PCI_EXP_LNKSTA_LT << 16);\n\t\tif (advk_pcie_link_training(pcie))\n\t\t\tval |= (PCI_EXP_LNKSTA_LT << 16);\n\t\tif (advk_pcie_link_active(pcie))\n\t\t\tval |= (PCI_EXP_LNKSTA_DLLLA << 16);\n\t\t*value = val;\n\t\treturn PCI_BRIDGE_EMUL_HANDLED;\n\t}\n\n\tcase PCI_EXP_DEVCAP:\n\tcase PCI_EXP_DEVCTL:\n\tcase PCI_EXP_DEVCAP2:\n\tcase PCI_EXP_DEVCTL2:\n\tcase PCI_EXP_LNKCAP2:\n\tcase PCI_EXP_LNKCTL2:\n\t\t*value = advk_readl(pcie, PCIE_CORE_PCIEXP_CAP + reg);\n\t\treturn PCI_BRIDGE_EMUL_HANDLED;\n\n\tdefault:\n\t\treturn PCI_BRIDGE_EMUL_NOT_HANDLED;\n\t}\n\n}\n\nstatic void\nadvk_pci_bridge_emul_pcie_conf_write(struct pci_bridge_emul *bridge,\n\t\t\t\t     int reg, u32 old, u32 new, u32 mask)\n{\n\tstruct advk_pcie *pcie = bridge->data;\n\n\tswitch (reg) {\n\tcase PCI_EXP_LNKCTL:\n\t\tadvk_writel(pcie, new, PCIE_CORE_PCIEXP_CAP + reg);\n\t\tif (new & PCI_EXP_LNKCTL_RL)\n\t\t\tadvk_pcie_wait_for_retrain(pcie);\n\t\tbreak;\n\n\tcase PCI_EXP_RTCTL: {\n\t\tu16 rootctl = le16_to_cpu(bridge->pcie_conf.rootctl);\n\t\t \n\t\trootctl &= PCI_EXP_RTCTL_PMEIE | PCI_EXP_RTCTL_CRSSVE;\n\t\tbridge->pcie_conf.rootctl = cpu_to_le16(rootctl);\n\t\tbreak;\n\t}\n\n\t \n\n\tcase PCI_EXP_DEVCTL:\n\tcase PCI_EXP_DEVCTL2:\n\tcase PCI_EXP_LNKCTL2:\n\t\tadvk_writel(pcie, new, PCIE_CORE_PCIEXP_CAP + reg);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic pci_bridge_emul_read_status_t\nadvk_pci_bridge_emul_ext_conf_read(struct pci_bridge_emul *bridge,\n\t\t\t\t   int reg, u32 *value)\n{\n\tstruct advk_pcie *pcie = bridge->data;\n\n\tswitch (reg) {\n\tcase 0:\n\t\t*value = advk_readl(pcie, PCIE_CORE_PCIERR_CAP + reg);\n\n\t\t \n\t\t*value &= 0x000fffff;\n\t\treturn PCI_BRIDGE_EMUL_HANDLED;\n\n\tcase PCI_ERR_UNCOR_STATUS:\n\tcase PCI_ERR_UNCOR_MASK:\n\tcase PCI_ERR_UNCOR_SEVER:\n\tcase PCI_ERR_COR_STATUS:\n\tcase PCI_ERR_COR_MASK:\n\tcase PCI_ERR_CAP:\n\tcase PCI_ERR_HEADER_LOG + 0:\n\tcase PCI_ERR_HEADER_LOG + 4:\n\tcase PCI_ERR_HEADER_LOG + 8:\n\tcase PCI_ERR_HEADER_LOG + 12:\n\tcase PCI_ERR_ROOT_COMMAND:\n\tcase PCI_ERR_ROOT_STATUS:\n\tcase PCI_ERR_ROOT_ERR_SRC:\n\t\t*value = advk_readl(pcie, PCIE_CORE_PCIERR_CAP + reg);\n\t\treturn PCI_BRIDGE_EMUL_HANDLED;\n\n\tdefault:\n\t\treturn PCI_BRIDGE_EMUL_NOT_HANDLED;\n\t}\n}\n\nstatic void\nadvk_pci_bridge_emul_ext_conf_write(struct pci_bridge_emul *bridge,\n\t\t\t\t    int reg, u32 old, u32 new, u32 mask)\n{\n\tstruct advk_pcie *pcie = bridge->data;\n\n\tswitch (reg) {\n\t \n\tcase PCI_ERR_UNCOR_STATUS:\n\tcase PCI_ERR_COR_STATUS:\n\tcase PCI_ERR_ROOT_STATUS:\n\t\tnew &= mask;\n\t\tfallthrough;\n\n\tcase PCI_ERR_UNCOR_MASK:\n\tcase PCI_ERR_UNCOR_SEVER:\n\tcase PCI_ERR_COR_MASK:\n\tcase PCI_ERR_CAP:\n\tcase PCI_ERR_HEADER_LOG + 0:\n\tcase PCI_ERR_HEADER_LOG + 4:\n\tcase PCI_ERR_HEADER_LOG + 8:\n\tcase PCI_ERR_HEADER_LOG + 12:\n\tcase PCI_ERR_ROOT_COMMAND:\n\tcase PCI_ERR_ROOT_ERR_SRC:\n\t\tadvk_writel(pcie, new, PCIE_CORE_PCIERR_CAP + reg);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic const struct pci_bridge_emul_ops advk_pci_bridge_emul_ops = {\n\t.read_base = advk_pci_bridge_emul_base_conf_read,\n\t.write_base = advk_pci_bridge_emul_base_conf_write,\n\t.read_pcie = advk_pci_bridge_emul_pcie_conf_read,\n\t.write_pcie = advk_pci_bridge_emul_pcie_conf_write,\n\t.read_ext = advk_pci_bridge_emul_ext_conf_read,\n\t.write_ext = advk_pci_bridge_emul_ext_conf_write,\n};\n\n \nstatic int advk_sw_pci_bridge_init(struct advk_pcie *pcie)\n{\n\tstruct pci_bridge_emul *bridge = &pcie->bridge;\n\n\tbridge->conf.vendor =\n\t\tcpu_to_le16(advk_readl(pcie, PCIE_CORE_DEV_ID_REG) & 0xffff);\n\tbridge->conf.device =\n\t\tcpu_to_le16(advk_readl(pcie, PCIE_CORE_DEV_ID_REG) >> 16);\n\tbridge->conf.class_revision =\n\t\tcpu_to_le32(advk_readl(pcie, PCIE_CORE_DEV_REV_REG) & 0xff);\n\n\t \n\tbridge->conf.iobase = PCI_IO_RANGE_TYPE_32;\n\tbridge->conf.iolimit = PCI_IO_RANGE_TYPE_32;\n\n\t \n\tbridge->conf.pref_mem_base = cpu_to_le16(PCI_PREF_RANGE_TYPE_64);\n\tbridge->conf.pref_mem_limit = cpu_to_le16(PCI_PREF_RANGE_TYPE_64);\n\n\t \n\tbridge->conf.intpin = PCI_INTERRUPT_INTA;\n\n\t \n\tbridge->pcie_conf.cap = cpu_to_le16(2 | PCI_EXP_FLAGS_SLOT);\n\n\t \n\tbridge->pcie_conf.slotcap = cpu_to_le32(FIELD_PREP(PCI_EXP_SLTCAP_PSN,\n\t\t\t\t\t\t\t   1));\n\tbridge->pcie_conf.slotsta = cpu_to_le16(PCI_EXP_SLTSTA_PDS);\n\n\t \n\tbridge->pcie_conf.rootcap = cpu_to_le16(PCI_EXP_RTCAP_CRSVIS);\n\n\tbridge->subsystem_vendor_id = advk_readl(pcie, PCIE_CORE_SSDEV_ID_REG) & 0xffff;\n\tbridge->subsystem_id = advk_readl(pcie, PCIE_CORE_SSDEV_ID_REG) >> 16;\n\tbridge->has_pcie = true;\n\tbridge->pcie_start = PCIE_CORE_PCIEXP_CAP;\n\tbridge->data = pcie;\n\tbridge->ops = &advk_pci_bridge_emul_ops;\n\n\treturn pci_bridge_emul_init(bridge, 0);\n}\n\nstatic bool advk_pcie_valid_device(struct advk_pcie *pcie, struct pci_bus *bus,\n\t\t\t\t  int devfn)\n{\n\tif (pci_is_root_bus(bus) && PCI_SLOT(devfn) != 0)\n\t\treturn false;\n\n\t \n\tif (!pci_is_root_bus(bus) && !advk_pcie_link_up(pcie))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool advk_pcie_pio_is_running(struct advk_pcie *pcie)\n{\n\tstruct device *dev = &pcie->pdev->dev;\n\n\t \n\tif (advk_readl(pcie, PIO_START)) {\n\t\tdev_err(dev, \"Previous PIO read/write transfer is still running\\n\");\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic int advk_pcie_rd_conf(struct pci_bus *bus, u32 devfn,\n\t\t\t     int where, int size, u32 *val)\n{\n\tstruct advk_pcie *pcie = bus->sysdata;\n\tint retry_count;\n\tbool allow_crs;\n\tu32 reg;\n\tint ret;\n\n\tif (!advk_pcie_valid_device(pcie, bus, devfn))\n\t\treturn PCIBIOS_DEVICE_NOT_FOUND;\n\n\tif (pci_is_root_bus(bus))\n\t\treturn pci_bridge_emul_conf_read(&pcie->bridge, where,\n\t\t\t\t\t\t size, val);\n\n\t \n\tallow_crs = (where == PCI_VENDOR_ID) && (size == 4) &&\n\t\t    (le16_to_cpu(pcie->bridge.pcie_conf.rootctl) &\n\t\t     PCI_EXP_RTCTL_CRSSVE);\n\n\tif (advk_pcie_pio_is_running(pcie))\n\t\tgoto try_crs;\n\n\t \n\treg = advk_readl(pcie, PIO_CTRL);\n\treg &= ~PIO_CTRL_TYPE_MASK;\n\tif (pci_is_root_bus(bus->parent))\n\t\treg |= PCIE_CONFIG_RD_TYPE0;\n\telse\n\t\treg |= PCIE_CONFIG_RD_TYPE1;\n\tadvk_writel(pcie, reg, PIO_CTRL);\n\n\t \n\treg = ALIGN_DOWN(PCIE_ECAM_OFFSET(bus->number, devfn, where), 4);\n\tadvk_writel(pcie, reg, PIO_ADDR_LS);\n\tadvk_writel(pcie, 0, PIO_ADDR_MS);\n\n\t \n\tadvk_writel(pcie, 0xf, PIO_WR_DATA_STRB);\n\n\tretry_count = 0;\n\tdo {\n\t\t \n\t\tadvk_writel(pcie, 1, PIO_ISR);\n\t\tadvk_writel(pcie, 1, PIO_START);\n\n\t\tret = advk_pcie_wait_pio(pcie);\n\t\tif (ret < 0)\n\t\t\tgoto try_crs;\n\n\t\tretry_count += ret;\n\n\t\t \n\t\tret = advk_pcie_check_pio_status(pcie, allow_crs, val);\n\t} while (ret == -EAGAIN && retry_count < PIO_RETRY_CNT);\n\n\tif (ret < 0)\n\t\tgoto fail;\n\n\tif (size == 1)\n\t\t*val = (*val >> (8 * (where & 3))) & 0xff;\n\telse if (size == 2)\n\t\t*val = (*val >> (8 * (where & 3))) & 0xffff;\n\n\treturn PCIBIOS_SUCCESSFUL;\n\ntry_crs:\n\t \n\tif (allow_crs) {\n\t\t*val = CFG_RD_CRS_VAL;\n\t\treturn PCIBIOS_SUCCESSFUL;\n\t}\n\nfail:\n\t*val = 0xffffffff;\n\treturn PCIBIOS_SET_FAILED;\n}\n\nstatic int advk_pcie_wr_conf(struct pci_bus *bus, u32 devfn,\n\t\t\t\tint where, int size, u32 val)\n{\n\tstruct advk_pcie *pcie = bus->sysdata;\n\tu32 reg;\n\tu32 data_strobe = 0x0;\n\tint retry_count;\n\tint offset;\n\tint ret;\n\n\tif (!advk_pcie_valid_device(pcie, bus, devfn))\n\t\treturn PCIBIOS_DEVICE_NOT_FOUND;\n\n\tif (pci_is_root_bus(bus))\n\t\treturn pci_bridge_emul_conf_write(&pcie->bridge, where,\n\t\t\t\t\t\t  size, val);\n\n\tif (where % size)\n\t\treturn PCIBIOS_SET_FAILED;\n\n\tif (advk_pcie_pio_is_running(pcie))\n\t\treturn PCIBIOS_SET_FAILED;\n\n\t \n\treg = advk_readl(pcie, PIO_CTRL);\n\treg &= ~PIO_CTRL_TYPE_MASK;\n\tif (pci_is_root_bus(bus->parent))\n\t\treg |= PCIE_CONFIG_WR_TYPE0;\n\telse\n\t\treg |= PCIE_CONFIG_WR_TYPE1;\n\tadvk_writel(pcie, reg, PIO_CTRL);\n\n\t \n\treg = ALIGN_DOWN(PCIE_ECAM_OFFSET(bus->number, devfn, where), 4);\n\tadvk_writel(pcie, reg, PIO_ADDR_LS);\n\tadvk_writel(pcie, 0, PIO_ADDR_MS);\n\n\t \n\toffset      = where & 0x3;\n\treg         = val << (8 * offset);\n\tdata_strobe = GENMASK(size - 1, 0) << offset;\n\n\t \n\tadvk_writel(pcie, reg, PIO_WR_DATA);\n\n\t \n\tadvk_writel(pcie, data_strobe, PIO_WR_DATA_STRB);\n\n\tretry_count = 0;\n\tdo {\n\t\t \n\t\tadvk_writel(pcie, 1, PIO_ISR);\n\t\tadvk_writel(pcie, 1, PIO_START);\n\n\t\tret = advk_pcie_wait_pio(pcie);\n\t\tif (ret < 0)\n\t\t\treturn PCIBIOS_SET_FAILED;\n\n\t\tretry_count += ret;\n\n\t\tret = advk_pcie_check_pio_status(pcie, false, NULL);\n\t} while (ret == -EAGAIN && retry_count < PIO_RETRY_CNT);\n\n\treturn ret < 0 ? PCIBIOS_SET_FAILED : PCIBIOS_SUCCESSFUL;\n}\n\nstatic struct pci_ops advk_pcie_ops = {\n\t.read = advk_pcie_rd_conf,\n\t.write = advk_pcie_wr_conf,\n};\n\nstatic void advk_msi_irq_compose_msi_msg(struct irq_data *data,\n\t\t\t\t\t struct msi_msg *msg)\n{\n\tstruct advk_pcie *pcie = irq_data_get_irq_chip_data(data);\n\tphys_addr_t msi_addr = virt_to_phys(pcie);\n\n\tmsg->address_lo = lower_32_bits(msi_addr);\n\tmsg->address_hi = upper_32_bits(msi_addr);\n\tmsg->data = data->hwirq;\n}\n\nstatic int advk_msi_set_affinity(struct irq_data *irq_data,\n\t\t\t\t const struct cpumask *mask, bool force)\n{\n\treturn -EINVAL;\n}\n\nstatic void advk_msi_irq_mask(struct irq_data *d)\n{\n\tstruct advk_pcie *pcie = d->domain->host_data;\n\tirq_hw_number_t hwirq = irqd_to_hwirq(d);\n\tunsigned long flags;\n\tu32 mask;\n\n\traw_spin_lock_irqsave(&pcie->msi_irq_lock, flags);\n\tmask = advk_readl(pcie, PCIE_MSI_MASK_REG);\n\tmask |= BIT(hwirq);\n\tadvk_writel(pcie, mask, PCIE_MSI_MASK_REG);\n\traw_spin_unlock_irqrestore(&pcie->msi_irq_lock, flags);\n}\n\nstatic void advk_msi_irq_unmask(struct irq_data *d)\n{\n\tstruct advk_pcie *pcie = d->domain->host_data;\n\tirq_hw_number_t hwirq = irqd_to_hwirq(d);\n\tunsigned long flags;\n\tu32 mask;\n\n\traw_spin_lock_irqsave(&pcie->msi_irq_lock, flags);\n\tmask = advk_readl(pcie, PCIE_MSI_MASK_REG);\n\tmask &= ~BIT(hwirq);\n\tadvk_writel(pcie, mask, PCIE_MSI_MASK_REG);\n\traw_spin_unlock_irqrestore(&pcie->msi_irq_lock, flags);\n}\n\nstatic void advk_msi_top_irq_mask(struct irq_data *d)\n{\n\tpci_msi_mask_irq(d);\n\tirq_chip_mask_parent(d);\n}\n\nstatic void advk_msi_top_irq_unmask(struct irq_data *d)\n{\n\tpci_msi_unmask_irq(d);\n\tirq_chip_unmask_parent(d);\n}\n\nstatic struct irq_chip advk_msi_bottom_irq_chip = {\n\t.name\t\t\t= \"MSI\",\n\t.irq_compose_msi_msg\t= advk_msi_irq_compose_msi_msg,\n\t.irq_set_affinity\t= advk_msi_set_affinity,\n\t.irq_mask\t\t= advk_msi_irq_mask,\n\t.irq_unmask\t\t= advk_msi_irq_unmask,\n};\n\nstatic int advk_msi_irq_domain_alloc(struct irq_domain *domain,\n\t\t\t\t     unsigned int virq,\n\t\t\t\t     unsigned int nr_irqs, void *args)\n{\n\tstruct advk_pcie *pcie = domain->host_data;\n\tint hwirq, i;\n\n\tmutex_lock(&pcie->msi_used_lock);\n\thwirq = bitmap_find_free_region(pcie->msi_used, MSI_IRQ_NUM,\n\t\t\t\t\torder_base_2(nr_irqs));\n\tmutex_unlock(&pcie->msi_used_lock);\n\tif (hwirq < 0)\n\t\treturn -ENOSPC;\n\n\tfor (i = 0; i < nr_irqs; i++)\n\t\tirq_domain_set_info(domain, virq + i, hwirq + i,\n\t\t\t\t    &advk_msi_bottom_irq_chip,\n\t\t\t\t    domain->host_data, handle_simple_irq,\n\t\t\t\t    NULL, NULL);\n\n\treturn 0;\n}\n\nstatic void advk_msi_irq_domain_free(struct irq_domain *domain,\n\t\t\t\t     unsigned int virq, unsigned int nr_irqs)\n{\n\tstruct irq_data *d = irq_domain_get_irq_data(domain, virq);\n\tstruct advk_pcie *pcie = domain->host_data;\n\n\tmutex_lock(&pcie->msi_used_lock);\n\tbitmap_release_region(pcie->msi_used, d->hwirq, order_base_2(nr_irqs));\n\tmutex_unlock(&pcie->msi_used_lock);\n}\n\nstatic const struct irq_domain_ops advk_msi_domain_ops = {\n\t.alloc = advk_msi_irq_domain_alloc,\n\t.free = advk_msi_irq_domain_free,\n};\n\nstatic void advk_pcie_irq_mask(struct irq_data *d)\n{\n\tstruct advk_pcie *pcie = d->domain->host_data;\n\tirq_hw_number_t hwirq = irqd_to_hwirq(d);\n\tunsigned long flags;\n\tu32 mask;\n\n\traw_spin_lock_irqsave(&pcie->irq_lock, flags);\n\tmask = advk_readl(pcie, PCIE_ISR1_MASK_REG);\n\tmask |= PCIE_ISR1_INTX_ASSERT(hwirq);\n\tadvk_writel(pcie, mask, PCIE_ISR1_MASK_REG);\n\traw_spin_unlock_irqrestore(&pcie->irq_lock, flags);\n}\n\nstatic void advk_pcie_irq_unmask(struct irq_data *d)\n{\n\tstruct advk_pcie *pcie = d->domain->host_data;\n\tirq_hw_number_t hwirq = irqd_to_hwirq(d);\n\tunsigned long flags;\n\tu32 mask;\n\n\traw_spin_lock_irqsave(&pcie->irq_lock, flags);\n\tmask = advk_readl(pcie, PCIE_ISR1_MASK_REG);\n\tmask &= ~PCIE_ISR1_INTX_ASSERT(hwirq);\n\tadvk_writel(pcie, mask, PCIE_ISR1_MASK_REG);\n\traw_spin_unlock_irqrestore(&pcie->irq_lock, flags);\n}\n\nstatic int advk_pcie_irq_map(struct irq_domain *h,\n\t\t\t     unsigned int virq, irq_hw_number_t hwirq)\n{\n\tstruct advk_pcie *pcie = h->host_data;\n\n\tirq_set_status_flags(virq, IRQ_LEVEL);\n\tirq_set_chip_and_handler(virq, &pcie->irq_chip,\n\t\t\t\t handle_level_irq);\n\tirq_set_chip_data(virq, pcie);\n\n\treturn 0;\n}\n\nstatic const struct irq_domain_ops advk_pcie_irq_domain_ops = {\n\t.map = advk_pcie_irq_map,\n\t.xlate = irq_domain_xlate_onecell,\n};\n\nstatic struct irq_chip advk_msi_irq_chip = {\n\t.name\t\t= \"advk-MSI\",\n\t.irq_mask\t= advk_msi_top_irq_mask,\n\t.irq_unmask\t= advk_msi_top_irq_unmask,\n};\n\nstatic struct msi_domain_info advk_msi_domain_info = {\n\t.flags\t= MSI_FLAG_USE_DEF_DOM_OPS | MSI_FLAG_USE_DEF_CHIP_OPS |\n\t\t  MSI_FLAG_MULTI_PCI_MSI | MSI_FLAG_PCI_MSIX,\n\t.chip\t= &advk_msi_irq_chip,\n};\n\nstatic int advk_pcie_init_msi_irq_domain(struct advk_pcie *pcie)\n{\n\tstruct device *dev = &pcie->pdev->dev;\n\n\traw_spin_lock_init(&pcie->msi_irq_lock);\n\tmutex_init(&pcie->msi_used_lock);\n\n\tpcie->msi_inner_domain =\n\t\tirq_domain_add_linear(NULL, MSI_IRQ_NUM,\n\t\t\t\t      &advk_msi_domain_ops, pcie);\n\tif (!pcie->msi_inner_domain)\n\t\treturn -ENOMEM;\n\n\tpcie->msi_domain =\n\t\tpci_msi_create_irq_domain(dev_fwnode(dev),\n\t\t\t\t\t  &advk_msi_domain_info,\n\t\t\t\t\t  pcie->msi_inner_domain);\n\tif (!pcie->msi_domain) {\n\t\tirq_domain_remove(pcie->msi_inner_domain);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic void advk_pcie_remove_msi_irq_domain(struct advk_pcie *pcie)\n{\n\tirq_domain_remove(pcie->msi_domain);\n\tirq_domain_remove(pcie->msi_inner_domain);\n}\n\nstatic int advk_pcie_init_irq_domain(struct advk_pcie *pcie)\n{\n\tstruct device *dev = &pcie->pdev->dev;\n\tstruct device_node *node = dev->of_node;\n\tstruct device_node *pcie_intc_node;\n\tstruct irq_chip *irq_chip;\n\tint ret = 0;\n\n\traw_spin_lock_init(&pcie->irq_lock);\n\n\tpcie_intc_node =  of_get_next_child(node, NULL);\n\tif (!pcie_intc_node) {\n\t\tdev_err(dev, \"No PCIe Intc node found\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tirq_chip = &pcie->irq_chip;\n\n\tirq_chip->name = devm_kasprintf(dev, GFP_KERNEL, \"%s-irq\",\n\t\t\t\t\tdev_name(dev));\n\tif (!irq_chip->name) {\n\t\tret = -ENOMEM;\n\t\tgoto out_put_node;\n\t}\n\n\tirq_chip->irq_mask = advk_pcie_irq_mask;\n\tirq_chip->irq_unmask = advk_pcie_irq_unmask;\n\n\tpcie->irq_domain =\n\t\tirq_domain_add_linear(pcie_intc_node, PCI_NUM_INTX,\n\t\t\t\t      &advk_pcie_irq_domain_ops, pcie);\n\tif (!pcie->irq_domain) {\n\t\tdev_err(dev, \"Failed to get a INTx IRQ domain\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out_put_node;\n\t}\n\nout_put_node:\n\tof_node_put(pcie_intc_node);\n\treturn ret;\n}\n\nstatic void advk_pcie_remove_irq_domain(struct advk_pcie *pcie)\n{\n\tirq_domain_remove(pcie->irq_domain);\n}\n\nstatic struct irq_chip advk_rp_irq_chip = {\n\t.name = \"advk-RP\",\n};\n\nstatic int advk_pcie_rp_irq_map(struct irq_domain *h,\n\t\t\t\tunsigned int virq, irq_hw_number_t hwirq)\n{\n\tstruct advk_pcie *pcie = h->host_data;\n\n\tirq_set_chip_and_handler(virq, &advk_rp_irq_chip, handle_simple_irq);\n\tirq_set_chip_data(virq, pcie);\n\n\treturn 0;\n}\n\nstatic const struct irq_domain_ops advk_pcie_rp_irq_domain_ops = {\n\t.map = advk_pcie_rp_irq_map,\n\t.xlate = irq_domain_xlate_onecell,\n};\n\nstatic int advk_pcie_init_rp_irq_domain(struct advk_pcie *pcie)\n{\n\tpcie->rp_irq_domain = irq_domain_add_linear(NULL, 1,\n\t\t\t\t\t\t    &advk_pcie_rp_irq_domain_ops,\n\t\t\t\t\t\t    pcie);\n\tif (!pcie->rp_irq_domain) {\n\t\tdev_err(&pcie->pdev->dev, \"Failed to add Root Port IRQ domain\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic void advk_pcie_remove_rp_irq_domain(struct advk_pcie *pcie)\n{\n\tirq_domain_remove(pcie->rp_irq_domain);\n}\n\nstatic void advk_pcie_handle_pme(struct advk_pcie *pcie)\n{\n\tu32 requester = advk_readl(pcie, PCIE_MSG_LOG_REG) >> 16;\n\n\tadvk_writel(pcie, PCIE_MSG_PM_PME_MASK, PCIE_ISR0_REG);\n\n\t \n\tif (!(le32_to_cpu(pcie->bridge.pcie_conf.rootsta) & PCI_EXP_RTSTA_PME)) {\n\t\tpcie->bridge.pcie_conf.rootsta = cpu_to_le32(requester | PCI_EXP_RTSTA_PME);\n\n\t\t \n\t\tif (!(le16_to_cpu(pcie->bridge.pcie_conf.rootctl) & PCI_EXP_RTCTL_PMEIE))\n\t\t\treturn;\n\n\t\tif (generic_handle_domain_irq(pcie->rp_irq_domain, 0) == -EINVAL)\n\t\t\tdev_err_ratelimited(&pcie->pdev->dev, \"unhandled PME IRQ\\n\");\n\t}\n}\n\nstatic void advk_pcie_handle_msi(struct advk_pcie *pcie)\n{\n\tu32 msi_val, msi_mask, msi_status, msi_idx;\n\n\tmsi_mask = advk_readl(pcie, PCIE_MSI_MASK_REG);\n\tmsi_val = advk_readl(pcie, PCIE_MSI_STATUS_REG);\n\tmsi_status = msi_val & ((~msi_mask) & PCIE_MSI_ALL_MASK);\n\n\tfor (msi_idx = 0; msi_idx < MSI_IRQ_NUM; msi_idx++) {\n\t\tif (!(BIT(msi_idx) & msi_status))\n\t\t\tcontinue;\n\n\t\tadvk_writel(pcie, BIT(msi_idx), PCIE_MSI_STATUS_REG);\n\t\tif (generic_handle_domain_irq(pcie->msi_inner_domain, msi_idx) == -EINVAL)\n\t\t\tdev_err_ratelimited(&pcie->pdev->dev, \"unexpected MSI 0x%02x\\n\", msi_idx);\n\t}\n\n\tadvk_writel(pcie, PCIE_ISR0_MSI_INT_PENDING,\n\t\t    PCIE_ISR0_REG);\n}\n\nstatic void advk_pcie_handle_int(struct advk_pcie *pcie)\n{\n\tu32 isr0_val, isr0_mask, isr0_status;\n\tu32 isr1_val, isr1_mask, isr1_status;\n\tint i;\n\n\tisr0_val = advk_readl(pcie, PCIE_ISR0_REG);\n\tisr0_mask = advk_readl(pcie, PCIE_ISR0_MASK_REG);\n\tisr0_status = isr0_val & ((~isr0_mask) & PCIE_ISR0_ALL_MASK);\n\n\tisr1_val = advk_readl(pcie, PCIE_ISR1_REG);\n\tisr1_mask = advk_readl(pcie, PCIE_ISR1_MASK_REG);\n\tisr1_status = isr1_val & ((~isr1_mask) & PCIE_ISR1_ALL_MASK);\n\n\t \n\tif (isr0_status & PCIE_MSG_PM_PME_MASK)\n\t\tadvk_pcie_handle_pme(pcie);\n\n\t \n\tif (isr0_status & PCIE_ISR0_ERR_MASK) {\n\t\tadvk_writel(pcie, PCIE_ISR0_ERR_MASK, PCIE_ISR0_REG);\n\n\t\t \n\t\tif (generic_handle_domain_irq(pcie->rp_irq_domain, 0) == -EINVAL)\n\t\t\tdev_err_ratelimited(&pcie->pdev->dev, \"unhandled ERR IRQ\\n\");\n\t}\n\n\t \n\tif (isr0_status & PCIE_ISR0_MSI_INT_PENDING)\n\t\tadvk_pcie_handle_msi(pcie);\n\n\t \n\tfor (i = 0; i < PCI_NUM_INTX; i++) {\n\t\tif (!(isr1_status & PCIE_ISR1_INTX_ASSERT(i)))\n\t\t\tcontinue;\n\n\t\tadvk_writel(pcie, PCIE_ISR1_INTX_ASSERT(i),\n\t\t\t    PCIE_ISR1_REG);\n\n\t\tif (generic_handle_domain_irq(pcie->irq_domain, i) == -EINVAL)\n\t\t\tdev_err_ratelimited(&pcie->pdev->dev, \"unexpected INT%c IRQ\\n\",\n\t\t\t\t\t    (char)i + 'A');\n\t}\n}\n\nstatic irqreturn_t advk_pcie_irq_handler(int irq, void *arg)\n{\n\tstruct advk_pcie *pcie = arg;\n\tu32 status;\n\n\tstatus = advk_readl(pcie, HOST_CTRL_INT_STATUS_REG);\n\tif (!(status & PCIE_IRQ_CORE_INT))\n\t\treturn IRQ_NONE;\n\n\tadvk_pcie_handle_int(pcie);\n\n\t \n\tadvk_writel(pcie, PCIE_IRQ_CORE_INT, HOST_CTRL_INT_STATUS_REG);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int advk_pcie_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)\n{\n\tstruct advk_pcie *pcie = dev->bus->sysdata;\n\n\t \n\tif (pci_is_root_bus(dev->bus))\n\t\treturn irq_create_mapping(pcie->rp_irq_domain, pin - 1);\n\telse\n\t\treturn of_irq_parse_and_map_pci(dev, slot, pin);\n}\n\nstatic void advk_pcie_disable_phy(struct advk_pcie *pcie)\n{\n\tphy_power_off(pcie->phy);\n\tphy_exit(pcie->phy);\n}\n\nstatic int advk_pcie_enable_phy(struct advk_pcie *pcie)\n{\n\tint ret;\n\n\tif (!pcie->phy)\n\t\treturn 0;\n\n\tret = phy_init(pcie->phy);\n\tif (ret)\n\t\treturn ret;\n\n\tret = phy_set_mode(pcie->phy, PHY_MODE_PCIE);\n\tif (ret) {\n\t\tphy_exit(pcie->phy);\n\t\treturn ret;\n\t}\n\n\tret = phy_power_on(pcie->phy);\n\tif (ret) {\n\t\tphy_exit(pcie->phy);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int advk_pcie_setup_phy(struct advk_pcie *pcie)\n{\n\tstruct device *dev = &pcie->pdev->dev;\n\tstruct device_node *node = dev->of_node;\n\tint ret = 0;\n\n\tpcie->phy = devm_of_phy_get(dev, node, NULL);\n\tif (IS_ERR(pcie->phy) && (PTR_ERR(pcie->phy) == -EPROBE_DEFER))\n\t\treturn PTR_ERR(pcie->phy);\n\n\t \n\tif (IS_ERR(pcie->phy)) {\n\t\tdev_warn(dev, \"PHY unavailable (%ld)\\n\", PTR_ERR(pcie->phy));\n\t\tpcie->phy = NULL;\n\t\treturn 0;\n\t}\n\n\tret = advk_pcie_enable_phy(pcie);\n\tif (ret)\n\t\tdev_err(dev, \"Failed to initialize PHY (%d)\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int advk_pcie_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct advk_pcie *pcie;\n\tstruct pci_host_bridge *bridge;\n\tstruct resource_entry *entry;\n\tint ret, irq;\n\n\tbridge = devm_pci_alloc_host_bridge(dev, sizeof(struct advk_pcie));\n\tif (!bridge)\n\t\treturn -ENOMEM;\n\n\tpcie = pci_host_bridge_priv(bridge);\n\tpcie->pdev = pdev;\n\tplatform_set_drvdata(pdev, pcie);\n\n\tresource_list_for_each_entry(entry, &bridge->windows) {\n\t\tresource_size_t start = entry->res->start;\n\t\tresource_size_t size = resource_size(entry->res);\n\t\tunsigned long type = resource_type(entry->res);\n\t\tu64 win_size;\n\n\t\t \n\t\tif (type != IORESOURCE_MEM && type != IORESOURCE_IO)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (type == IORESOURCE_MEM && entry->offset == 0)\n\t\t\tcontinue;\n\n\t\t \n\t\twhile (pcie->wins_count < OB_WIN_COUNT && size > 0) {\n\t\t\t \n\t\t\twin_size = (1ULL << (fls64(size)-1)) |\n\t\t\t\t   (start ? (1ULL << __ffs64(start)) : 0);\n\t\t\twin_size = 1ULL << __ffs64(win_size);\n\t\t\tif (win_size < 0x10000)\n\t\t\t\tbreak;\n\n\t\t\tdev_dbg(dev,\n\t\t\t\t\"Configuring PCIe window %d: [0x%llx-0x%llx] as %lu\\n\",\n\t\t\t\tpcie->wins_count, (unsigned long long)start,\n\t\t\t\t(unsigned long long)start + win_size, type);\n\n\t\t\tif (type == IORESOURCE_IO) {\n\t\t\t\tpcie->wins[pcie->wins_count].actions = OB_WIN_TYPE_IO;\n\t\t\t\tpcie->wins[pcie->wins_count].match = pci_pio_to_address(start);\n\t\t\t} else {\n\t\t\t\tpcie->wins[pcie->wins_count].actions = OB_WIN_TYPE_MEM;\n\t\t\t\tpcie->wins[pcie->wins_count].match = start;\n\t\t\t}\n\t\t\tpcie->wins[pcie->wins_count].remap = start - entry->offset;\n\t\t\tpcie->wins[pcie->wins_count].mask = ~(win_size - 1);\n\n\t\t\tif (pcie->wins[pcie->wins_count].remap & (win_size - 1))\n\t\t\t\tbreak;\n\n\t\t\tstart += win_size;\n\t\t\tsize -= win_size;\n\t\t\tpcie->wins_count++;\n\t\t}\n\n\t\tif (size > 0) {\n\t\t\tdev_err(&pcie->pdev->dev,\n\t\t\t\t\"Invalid PCIe region [0x%llx-0x%llx]\\n\",\n\t\t\t\t(unsigned long long)entry->res->start,\n\t\t\t\t(unsigned long long)entry->res->end + 1);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tpcie->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(pcie->base))\n\t\treturn PTR_ERR(pcie->base);\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tret = devm_request_irq(dev, irq, advk_pcie_irq_handler,\n\t\t\t       IRQF_SHARED | IRQF_NO_THREAD, \"advk-pcie\",\n\t\t\t       pcie);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to register interrupt\\n\");\n\t\treturn ret;\n\t}\n\n\tpcie->reset_gpio = devm_gpiod_get_optional(dev, \"reset\", GPIOD_OUT_LOW);\n\tret = PTR_ERR_OR_ZERO(pcie->reset_gpio);\n\tif (ret) {\n\t\tif (ret != -EPROBE_DEFER)\n\t\t\tdev_err(dev, \"Failed to get reset-gpio: %i\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = gpiod_set_consumer_name(pcie->reset_gpio, \"pcie1-reset\");\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to set reset gpio name: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = of_pci_get_max_link_speed(dev->of_node);\n\tif (ret <= 0 || ret > 3)\n\t\tpcie->link_gen = 3;\n\telse\n\t\tpcie->link_gen = ret;\n\n\tret = advk_pcie_setup_phy(pcie);\n\tif (ret)\n\t\treturn ret;\n\n\tadvk_pcie_setup_hw(pcie);\n\n\tret = advk_sw_pci_bridge_init(pcie);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to register emulated root PCI bridge\\n\");\n\t\treturn ret;\n\t}\n\n\tret = advk_pcie_init_irq_domain(pcie);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to initialize irq\\n\");\n\t\treturn ret;\n\t}\n\n\tret = advk_pcie_init_msi_irq_domain(pcie);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to initialize irq\\n\");\n\t\tadvk_pcie_remove_irq_domain(pcie);\n\t\treturn ret;\n\t}\n\n\tret = advk_pcie_init_rp_irq_domain(pcie);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to initialize irq\\n\");\n\t\tadvk_pcie_remove_msi_irq_domain(pcie);\n\t\tadvk_pcie_remove_irq_domain(pcie);\n\t\treturn ret;\n\t}\n\n\tbridge->sysdata = pcie;\n\tbridge->ops = &advk_pcie_ops;\n\tbridge->map_irq = advk_pcie_map_irq;\n\n\tret = pci_host_probe(bridge);\n\tif (ret < 0) {\n\t\tadvk_pcie_remove_rp_irq_domain(pcie);\n\t\tadvk_pcie_remove_msi_irq_domain(pcie);\n\t\tadvk_pcie_remove_irq_domain(pcie);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void advk_pcie_remove(struct platform_device *pdev)\n{\n\tstruct advk_pcie *pcie = platform_get_drvdata(pdev);\n\tstruct pci_host_bridge *bridge = pci_host_bridge_from_priv(pcie);\n\tu32 val;\n\tint i;\n\n\t \n\tpci_lock_rescan_remove();\n\tpci_stop_root_bus(bridge->bus);\n\tpci_remove_root_bus(bridge->bus);\n\tpci_unlock_rescan_remove();\n\n\t \n\tval = advk_readl(pcie, PCIE_CORE_CMD_STATUS_REG);\n\tval &= ~(PCI_COMMAND_IO | PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER);\n\tadvk_writel(pcie, val, PCIE_CORE_CMD_STATUS_REG);\n\n\t \n\tval = advk_readl(pcie, PCIE_CORE_CTRL2_REG);\n\tval &= ~PCIE_CORE_CTRL2_MSI_ENABLE;\n\tadvk_writel(pcie, val, PCIE_CORE_CTRL2_REG);\n\n\t \n\tadvk_writel(pcie, 0, PCIE_MSI_ADDR_LOW_REG);\n\tadvk_writel(pcie, 0, PCIE_MSI_ADDR_HIGH_REG);\n\n\t \n\tadvk_writel(pcie, PCIE_MSI_ALL_MASK, PCIE_MSI_MASK_REG);\n\tadvk_writel(pcie, PCIE_ISR0_ALL_MASK, PCIE_ISR0_MASK_REG);\n\tadvk_writel(pcie, PCIE_ISR1_ALL_MASK, PCIE_ISR1_MASK_REG);\n\tadvk_writel(pcie, PCIE_IRQ_ALL_MASK, HOST_CTRL_INT_MASK_REG);\n\n\t \n\tadvk_writel(pcie, PCIE_MSI_ALL_MASK, PCIE_MSI_STATUS_REG);\n\tadvk_writel(pcie, PCIE_ISR0_ALL_MASK, PCIE_ISR0_REG);\n\tadvk_writel(pcie, PCIE_ISR1_ALL_MASK, PCIE_ISR1_REG);\n\tadvk_writel(pcie, PCIE_IRQ_ALL_MASK, HOST_CTRL_INT_STATUS_REG);\n\n\t \n\tadvk_pcie_remove_rp_irq_domain(pcie);\n\tadvk_pcie_remove_msi_irq_domain(pcie);\n\tadvk_pcie_remove_irq_domain(pcie);\n\n\t \n\tpci_bridge_emul_cleanup(&pcie->bridge);\n\n\t \n\tif (pcie->reset_gpio)\n\t\tgpiod_set_value_cansleep(pcie->reset_gpio, 1);\n\n\t \n\tval = advk_readl(pcie, PCIE_CORE_CTRL0_REG);\n\tval &= ~LINK_TRAINING_EN;\n\tadvk_writel(pcie, val, PCIE_CORE_CTRL0_REG);\n\n\t \n\tfor (i = 0; i < OB_WIN_COUNT; i++)\n\t\tadvk_pcie_disable_ob_win(pcie, i);\n\n\t \n\tadvk_pcie_disable_phy(pcie);\n}\n\nstatic const struct of_device_id advk_pcie_of_match_table[] = {\n\t{ .compatible = \"marvell,armada-3700-pcie\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, advk_pcie_of_match_table);\n\nstatic struct platform_driver advk_pcie_driver = {\n\t.driver = {\n\t\t.name = \"advk-pcie\",\n\t\t.of_match_table = advk_pcie_of_match_table,\n\t},\n\t.probe = advk_pcie_probe,\n\t.remove_new = advk_pcie_remove,\n};\nmodule_platform_driver(advk_pcie_driver);\n\nMODULE_DESCRIPTION(\"Aardvark PCIe controller\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}