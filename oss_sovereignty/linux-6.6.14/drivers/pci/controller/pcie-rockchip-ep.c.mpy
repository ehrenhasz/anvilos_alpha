{
  "module_name": "pcie-rockchip-ep.c",
  "hash_id": "7324b9fa36515c3dd77e53a995a29560c43f2d1b067bb18408815fd893338fe6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/controller/pcie-rockchip-ep.c",
  "human_readable_source": "\n \n\n#include <linux/configfs.h>\n#include <linux/delay.h>\n#include <linux/kernel.h>\n#include <linux/of.h>\n#include <linux/pci-epc.h>\n#include <linux/platform_device.h>\n#include <linux/pci-epf.h>\n#include <linux/sizes.h>\n\n#include \"pcie-rockchip.h\"\n\n \nstruct rockchip_pcie_ep {\n\tstruct rockchip_pcie\trockchip;\n\tstruct pci_epc\t\t*epc;\n\tu32\t\t\tmax_regions;\n\tunsigned long\t\tob_region_map;\n\tphys_addr_t\t\t*ob_addr;\n\tphys_addr_t\t\tirq_phys_addr;\n\tvoid __iomem\t\t*irq_cpu_addr;\n\tu64\t\t\tirq_pci_addr;\n\tu8\t\t\tirq_pci_fn;\n\tu8\t\t\tirq_pending;\n};\n\nstatic void rockchip_pcie_clear_ep_ob_atu(struct rockchip_pcie *rockchip,\n\t\t\t\t\t  u32 region)\n{\n\trockchip_pcie_write(rockchip, 0,\n\t\t\t    ROCKCHIP_PCIE_AT_OB_REGION_PCI_ADDR0(region));\n\trockchip_pcie_write(rockchip, 0,\n\t\t\t    ROCKCHIP_PCIE_AT_OB_REGION_PCI_ADDR1(region));\n\trockchip_pcie_write(rockchip, 0,\n\t\t\t    ROCKCHIP_PCIE_AT_OB_REGION_DESC0(region));\n\trockchip_pcie_write(rockchip, 0,\n\t\t\t    ROCKCHIP_PCIE_AT_OB_REGION_DESC1(region));\n}\n\nstatic void rockchip_pcie_prog_ep_ob_atu(struct rockchip_pcie *rockchip, u8 fn,\n\t\t\t\t\t u32 r, u64 cpu_addr, u64 pci_addr,\n\t\t\t\t\t size_t size)\n{\n\tint num_pass_bits = fls64(size - 1);\n\tu32 addr0, addr1, desc0;\n\n\tif (num_pass_bits < 8)\n\t\tnum_pass_bits = 8;\n\n\taddr0 = ((num_pass_bits - 1) & PCIE_CORE_OB_REGION_ADDR0_NUM_BITS) |\n\t\t(lower_32_bits(pci_addr) & PCIE_CORE_OB_REGION_ADDR0_LO_ADDR);\n\taddr1 = upper_32_bits(pci_addr);\n\tdesc0 = ROCKCHIP_PCIE_AT_OB_REGION_DESC0_DEVFN(fn) | AXI_WRAPPER_MEM_WRITE;\n\n\t \n\trockchip_pcie_write(rockchip, addr0,\n\t\t\t    ROCKCHIP_PCIE_AT_OB_REGION_PCI_ADDR0(r));\n\trockchip_pcie_write(rockchip, addr1,\n\t\t\t    ROCKCHIP_PCIE_AT_OB_REGION_PCI_ADDR1(r));\n\trockchip_pcie_write(rockchip, desc0,\n\t\t\t    ROCKCHIP_PCIE_AT_OB_REGION_DESC0(r));\n\trockchip_pcie_write(rockchip, 0,\n\t\t\t    ROCKCHIP_PCIE_AT_OB_REGION_DESC1(r));\n}\n\nstatic int rockchip_pcie_ep_write_header(struct pci_epc *epc, u8 fn, u8 vfn,\n\t\t\t\t\t struct pci_epf_header *hdr)\n{\n\tu32 reg;\n\tstruct rockchip_pcie_ep *ep = epc_get_drvdata(epc);\n\tstruct rockchip_pcie *rockchip = &ep->rockchip;\n\n\t \n\tif (fn == 0) {\n\t\tu32 vid_regs = (hdr->vendorid & GENMASK(15, 0)) |\n\t\t\t       (hdr->subsys_vendor_id & GENMASK(31, 16)) << 16;\n\n\t\trockchip_pcie_write(rockchip, vid_regs,\n\t\t\t\t    PCIE_CORE_CONFIG_VENDOR);\n\t}\n\n\treg = rockchip_pcie_read(rockchip, PCIE_EP_CONFIG_DID_VID);\n\treg = (reg & 0xFFFF) | (hdr->deviceid << 16);\n\trockchip_pcie_write(rockchip, reg, PCIE_EP_CONFIG_DID_VID);\n\n\trockchip_pcie_write(rockchip,\n\t\t\t    hdr->revid |\n\t\t\t    hdr->progif_code << 8 |\n\t\t\t    hdr->subclass_code << 16 |\n\t\t\t    hdr->baseclass_code << 24,\n\t\t\t    ROCKCHIP_PCIE_EP_FUNC_BASE(fn) + PCI_REVISION_ID);\n\trockchip_pcie_write(rockchip, hdr->cache_line_size,\n\t\t\t    ROCKCHIP_PCIE_EP_FUNC_BASE(fn) +\n\t\t\t    PCI_CACHE_LINE_SIZE);\n\trockchip_pcie_write(rockchip, hdr->subsys_id << 16,\n\t\t\t    ROCKCHIP_PCIE_EP_FUNC_BASE(fn) +\n\t\t\t    PCI_SUBSYSTEM_VENDOR_ID);\n\trockchip_pcie_write(rockchip, hdr->interrupt_pin << 8,\n\t\t\t    ROCKCHIP_PCIE_EP_FUNC_BASE(fn) +\n\t\t\t    PCI_INTERRUPT_LINE);\n\n\treturn 0;\n}\n\nstatic int rockchip_pcie_ep_set_bar(struct pci_epc *epc, u8 fn, u8 vfn,\n\t\t\t\t    struct pci_epf_bar *epf_bar)\n{\n\tstruct rockchip_pcie_ep *ep = epc_get_drvdata(epc);\n\tstruct rockchip_pcie *rockchip = &ep->rockchip;\n\tdma_addr_t bar_phys = epf_bar->phys_addr;\n\tenum pci_barno bar = epf_bar->barno;\n\tint flags = epf_bar->flags;\n\tu32 addr0, addr1, reg, cfg, b, aperture, ctrl;\n\tu64 sz;\n\n\t \n\tsz = max_t(size_t, epf_bar->size, MIN_EP_APERTURE);\n\n\t \n\tsz = 1ULL << fls64(sz - 1);\n\taperture = ilog2(sz) - 7;  \n\n\tif ((flags & PCI_BASE_ADDRESS_SPACE) == PCI_BASE_ADDRESS_SPACE_IO) {\n\t\tctrl = ROCKCHIP_PCIE_CORE_BAR_CFG_CTRL_IO_32BITS;\n\t} else {\n\t\tbool is_prefetch = !!(flags & PCI_BASE_ADDRESS_MEM_PREFETCH);\n\t\tbool is_64bits = sz > SZ_2G;\n\n\t\tif (is_64bits && (bar & 1))\n\t\t\treturn -EINVAL;\n\n\t\tif (is_64bits && is_prefetch)\n\t\t\tctrl =\n\t\t\t    ROCKCHIP_PCIE_CORE_BAR_CFG_CTRL_PREFETCH_MEM_64BITS;\n\t\telse if (is_prefetch)\n\t\t\tctrl =\n\t\t\t    ROCKCHIP_PCIE_CORE_BAR_CFG_CTRL_PREFETCH_MEM_32BITS;\n\t\telse if (is_64bits)\n\t\t\tctrl = ROCKCHIP_PCIE_CORE_BAR_CFG_CTRL_MEM_64BITS;\n\t\telse\n\t\t\tctrl = ROCKCHIP_PCIE_CORE_BAR_CFG_CTRL_MEM_32BITS;\n\t}\n\n\tif (bar < BAR_4) {\n\t\treg = ROCKCHIP_PCIE_CORE_EP_FUNC_BAR_CFG0(fn);\n\t\tb = bar;\n\t} else {\n\t\treg = ROCKCHIP_PCIE_CORE_EP_FUNC_BAR_CFG1(fn);\n\t\tb = bar - BAR_4;\n\t}\n\n\taddr0 = lower_32_bits(bar_phys);\n\taddr1 = upper_32_bits(bar_phys);\n\n\tcfg = rockchip_pcie_read(rockchip, reg);\n\tcfg &= ~(ROCKCHIP_PCIE_CORE_EP_FUNC_BAR_CFG_BAR_APERTURE_MASK(b) |\n\t\t ROCKCHIP_PCIE_CORE_EP_FUNC_BAR_CFG_BAR_CTRL_MASK(b));\n\tcfg |= (ROCKCHIP_PCIE_CORE_EP_FUNC_BAR_CFG_BAR_APERTURE(b, aperture) |\n\t\tROCKCHIP_PCIE_CORE_EP_FUNC_BAR_CFG_BAR_CTRL(b, ctrl));\n\n\trockchip_pcie_write(rockchip, cfg, reg);\n\trockchip_pcie_write(rockchip, addr0,\n\t\t\t    ROCKCHIP_PCIE_AT_IB_EP_FUNC_BAR_ADDR0(fn, bar));\n\trockchip_pcie_write(rockchip, addr1,\n\t\t\t    ROCKCHIP_PCIE_AT_IB_EP_FUNC_BAR_ADDR1(fn, bar));\n\n\treturn 0;\n}\n\nstatic void rockchip_pcie_ep_clear_bar(struct pci_epc *epc, u8 fn, u8 vfn,\n\t\t\t\t       struct pci_epf_bar *epf_bar)\n{\n\tstruct rockchip_pcie_ep *ep = epc_get_drvdata(epc);\n\tstruct rockchip_pcie *rockchip = &ep->rockchip;\n\tu32 reg, cfg, b, ctrl;\n\tenum pci_barno bar = epf_bar->barno;\n\n\tif (bar < BAR_4) {\n\t\treg = ROCKCHIP_PCIE_CORE_EP_FUNC_BAR_CFG0(fn);\n\t\tb = bar;\n\t} else {\n\t\treg = ROCKCHIP_PCIE_CORE_EP_FUNC_BAR_CFG1(fn);\n\t\tb = bar - BAR_4;\n\t}\n\n\tctrl = ROCKCHIP_PCIE_CORE_BAR_CFG_CTRL_DISABLED;\n\tcfg = rockchip_pcie_read(rockchip, reg);\n\tcfg &= ~(ROCKCHIP_PCIE_CORE_EP_FUNC_BAR_CFG_BAR_APERTURE_MASK(b) |\n\t\t ROCKCHIP_PCIE_CORE_EP_FUNC_BAR_CFG_BAR_CTRL_MASK(b));\n\tcfg |= ROCKCHIP_PCIE_CORE_EP_FUNC_BAR_CFG_BAR_CTRL(b, ctrl);\n\n\trockchip_pcie_write(rockchip, cfg, reg);\n\trockchip_pcie_write(rockchip, 0x0,\n\t\t\t    ROCKCHIP_PCIE_AT_IB_EP_FUNC_BAR_ADDR0(fn, bar));\n\trockchip_pcie_write(rockchip, 0x0,\n\t\t\t    ROCKCHIP_PCIE_AT_IB_EP_FUNC_BAR_ADDR1(fn, bar));\n}\n\nstatic inline u32 rockchip_ob_region(phys_addr_t addr)\n{\n\treturn (addr >> ilog2(SZ_1M)) & 0x1f;\n}\n\nstatic int rockchip_pcie_ep_map_addr(struct pci_epc *epc, u8 fn, u8 vfn,\n\t\t\t\t     phys_addr_t addr, u64 pci_addr,\n\t\t\t\t     size_t size)\n{\n\tstruct rockchip_pcie_ep *ep = epc_get_drvdata(epc);\n\tstruct rockchip_pcie *pcie = &ep->rockchip;\n\tu32 r = rockchip_ob_region(addr);\n\n\trockchip_pcie_prog_ep_ob_atu(pcie, fn, r, addr, pci_addr, size);\n\n\tset_bit(r, &ep->ob_region_map);\n\tep->ob_addr[r] = addr;\n\n\treturn 0;\n}\n\nstatic void rockchip_pcie_ep_unmap_addr(struct pci_epc *epc, u8 fn, u8 vfn,\n\t\t\t\t\tphys_addr_t addr)\n{\n\tstruct rockchip_pcie_ep *ep = epc_get_drvdata(epc);\n\tstruct rockchip_pcie *rockchip = &ep->rockchip;\n\tu32 r;\n\n\tfor (r = 0; r < ep->max_regions; r++)\n\t\tif (ep->ob_addr[r] == addr)\n\t\t\tbreak;\n\n\tif (r == ep->max_regions)\n\t\treturn;\n\n\trockchip_pcie_clear_ep_ob_atu(rockchip, r);\n\n\tep->ob_addr[r] = 0;\n\tclear_bit(r, &ep->ob_region_map);\n}\n\nstatic int rockchip_pcie_ep_set_msi(struct pci_epc *epc, u8 fn, u8 vfn,\n\t\t\t\t    u8 multi_msg_cap)\n{\n\tstruct rockchip_pcie_ep *ep = epc_get_drvdata(epc);\n\tstruct rockchip_pcie *rockchip = &ep->rockchip;\n\tu32 flags;\n\n\tflags = rockchip_pcie_read(rockchip,\n\t\t\t\t   ROCKCHIP_PCIE_EP_FUNC_BASE(fn) +\n\t\t\t\t   ROCKCHIP_PCIE_EP_MSI_CTRL_REG);\n\tflags &= ~ROCKCHIP_PCIE_EP_MSI_CTRL_MMC_MASK;\n\tflags |=\n\t   (multi_msg_cap << ROCKCHIP_PCIE_EP_MSI_CTRL_MMC_OFFSET) |\n\t   (PCI_MSI_FLAGS_64BIT << ROCKCHIP_PCIE_EP_MSI_FLAGS_OFFSET);\n\tflags &= ~ROCKCHIP_PCIE_EP_MSI_CTRL_MASK_MSI_CAP;\n\trockchip_pcie_write(rockchip, flags,\n\t\t\t    ROCKCHIP_PCIE_EP_FUNC_BASE(fn) +\n\t\t\t    ROCKCHIP_PCIE_EP_MSI_CTRL_REG);\n\treturn 0;\n}\n\nstatic int rockchip_pcie_ep_get_msi(struct pci_epc *epc, u8 fn, u8 vfn)\n{\n\tstruct rockchip_pcie_ep *ep = epc_get_drvdata(epc);\n\tstruct rockchip_pcie *rockchip = &ep->rockchip;\n\tu32 flags;\n\n\tflags = rockchip_pcie_read(rockchip,\n\t\t\t\t   ROCKCHIP_PCIE_EP_FUNC_BASE(fn) +\n\t\t\t\t   ROCKCHIP_PCIE_EP_MSI_CTRL_REG);\n\tif (!(flags & ROCKCHIP_PCIE_EP_MSI_CTRL_ME))\n\t\treturn -EINVAL;\n\n\treturn ((flags & ROCKCHIP_PCIE_EP_MSI_CTRL_MME_MASK) >>\n\t\t\tROCKCHIP_PCIE_EP_MSI_CTRL_MME_OFFSET);\n}\n\nstatic void rockchip_pcie_ep_assert_intx(struct rockchip_pcie_ep *ep, u8 fn,\n\t\t\t\t\t u8 intx, bool do_assert)\n{\n\tstruct rockchip_pcie *rockchip = &ep->rockchip;\n\n\tintx &= 3;\n\n\tif (do_assert) {\n\t\tep->irq_pending |= BIT(intx);\n\t\trockchip_pcie_write(rockchip,\n\t\t\t\t    PCIE_CLIENT_INT_IN_ASSERT |\n\t\t\t\t    PCIE_CLIENT_INT_PEND_ST_PEND,\n\t\t\t\t    PCIE_CLIENT_LEGACY_INT_CTRL);\n\t} else {\n\t\tep->irq_pending &= ~BIT(intx);\n\t\trockchip_pcie_write(rockchip,\n\t\t\t\t    PCIE_CLIENT_INT_IN_DEASSERT |\n\t\t\t\t    PCIE_CLIENT_INT_PEND_ST_NORMAL,\n\t\t\t\t    PCIE_CLIENT_LEGACY_INT_CTRL);\n\t}\n}\n\nstatic int rockchip_pcie_ep_send_legacy_irq(struct rockchip_pcie_ep *ep, u8 fn,\n\t\t\t\t\t    u8 intx)\n{\n\tu16 cmd;\n\n\tcmd = rockchip_pcie_read(&ep->rockchip,\n\t\t\t\t ROCKCHIP_PCIE_EP_FUNC_BASE(fn) +\n\t\t\t\t ROCKCHIP_PCIE_EP_CMD_STATUS);\n\n\tif (cmd & PCI_COMMAND_INTX_DISABLE)\n\t\treturn -EINVAL;\n\n\t \n\trockchip_pcie_ep_assert_intx(ep, fn, intx, true);\n\tmdelay(1);\n\trockchip_pcie_ep_assert_intx(ep, fn, intx, false);\n\treturn 0;\n}\n\nstatic int rockchip_pcie_ep_send_msi_irq(struct rockchip_pcie_ep *ep, u8 fn,\n\t\t\t\t\t u8 interrupt_num)\n{\n\tstruct rockchip_pcie *rockchip = &ep->rockchip;\n\tu32 flags, mme, data, data_mask;\n\tu8 msi_count;\n\tu64 pci_addr;\n\tu32 r;\n\n\t \n\tflags = rockchip_pcie_read(&ep->rockchip,\n\t\t\t\t   ROCKCHIP_PCIE_EP_FUNC_BASE(fn) +\n\t\t\t\t   ROCKCHIP_PCIE_EP_MSI_CTRL_REG);\n\tif (!(flags & ROCKCHIP_PCIE_EP_MSI_CTRL_ME))\n\t\treturn -EINVAL;\n\n\t \n\tmme = ((flags & ROCKCHIP_PCIE_EP_MSI_CTRL_MME_MASK) >>\n\t\t\tROCKCHIP_PCIE_EP_MSI_CTRL_MME_OFFSET);\n\tmsi_count = 1 << mme;\n\tif (!interrupt_num || interrupt_num > msi_count)\n\t\treturn -EINVAL;\n\n\t \n\tdata_mask = msi_count - 1;\n\tdata = rockchip_pcie_read(rockchip,\n\t\t\t\t  ROCKCHIP_PCIE_EP_FUNC_BASE(fn) +\n\t\t\t\t  ROCKCHIP_PCIE_EP_MSI_CTRL_REG +\n\t\t\t\t  PCI_MSI_DATA_64);\n\tdata = (data & ~data_mask) | ((interrupt_num - 1) & data_mask);\n\n\t \n\tpci_addr = rockchip_pcie_read(rockchip,\n\t\t\t\t      ROCKCHIP_PCIE_EP_FUNC_BASE(fn) +\n\t\t\t\t      ROCKCHIP_PCIE_EP_MSI_CTRL_REG +\n\t\t\t\t      PCI_MSI_ADDRESS_HI);\n\tpci_addr <<= 32;\n\tpci_addr |= rockchip_pcie_read(rockchip,\n\t\t\t\t       ROCKCHIP_PCIE_EP_FUNC_BASE(fn) +\n\t\t\t\t       ROCKCHIP_PCIE_EP_MSI_CTRL_REG +\n\t\t\t\t       PCI_MSI_ADDRESS_LO);\n\n\t \n\tif (unlikely(ep->irq_pci_addr != (pci_addr & PCIE_ADDR_MASK) ||\n\t\t     ep->irq_pci_fn != fn)) {\n\t\tr = rockchip_ob_region(ep->irq_phys_addr);\n\t\trockchip_pcie_prog_ep_ob_atu(rockchip, fn, r,\n\t\t\t\t\t     ep->irq_phys_addr,\n\t\t\t\t\t     pci_addr & PCIE_ADDR_MASK,\n\t\t\t\t\t     ~PCIE_ADDR_MASK + 1);\n\t\tep->irq_pci_addr = (pci_addr & PCIE_ADDR_MASK);\n\t\tep->irq_pci_fn = fn;\n\t}\n\n\twritew(data, ep->irq_cpu_addr + (pci_addr & ~PCIE_ADDR_MASK));\n\treturn 0;\n}\n\nstatic int rockchip_pcie_ep_raise_irq(struct pci_epc *epc, u8 fn, u8 vfn,\n\t\t\t\t      enum pci_epc_irq_type type,\n\t\t\t\t      u16 interrupt_num)\n{\n\tstruct rockchip_pcie_ep *ep = epc_get_drvdata(epc);\n\n\tswitch (type) {\n\tcase PCI_EPC_IRQ_LEGACY:\n\t\treturn rockchip_pcie_ep_send_legacy_irq(ep, fn, 0);\n\tcase PCI_EPC_IRQ_MSI:\n\t\treturn rockchip_pcie_ep_send_msi_irq(ep, fn, interrupt_num);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int rockchip_pcie_ep_start(struct pci_epc *epc)\n{\n\tstruct rockchip_pcie_ep *ep = epc_get_drvdata(epc);\n\tstruct rockchip_pcie *rockchip = &ep->rockchip;\n\tstruct pci_epf *epf;\n\tu32 cfg;\n\n\tcfg = BIT(0);\n\tlist_for_each_entry(epf, &epc->pci_epf, list)\n\t\tcfg |= BIT(epf->func_no);\n\n\trockchip_pcie_write(rockchip, cfg, PCIE_CORE_PHY_FUNC_CFG);\n\n\treturn 0;\n}\n\nstatic const struct pci_epc_features rockchip_pcie_epc_features = {\n\t.linkup_notifier = false,\n\t.msi_capable = true,\n\t.msix_capable = false,\n\t.align = 256,\n};\n\nstatic const struct pci_epc_features*\nrockchip_pcie_ep_get_features(struct pci_epc *epc, u8 func_no, u8 vfunc_no)\n{\n\treturn &rockchip_pcie_epc_features;\n}\n\nstatic const struct pci_epc_ops rockchip_pcie_epc_ops = {\n\t.write_header\t= rockchip_pcie_ep_write_header,\n\t.set_bar\t= rockchip_pcie_ep_set_bar,\n\t.clear_bar\t= rockchip_pcie_ep_clear_bar,\n\t.map_addr\t= rockchip_pcie_ep_map_addr,\n\t.unmap_addr\t= rockchip_pcie_ep_unmap_addr,\n\t.set_msi\t= rockchip_pcie_ep_set_msi,\n\t.get_msi\t= rockchip_pcie_ep_get_msi,\n\t.raise_irq\t= rockchip_pcie_ep_raise_irq,\n\t.start\t\t= rockchip_pcie_ep_start,\n\t.get_features\t= rockchip_pcie_ep_get_features,\n};\n\nstatic int rockchip_pcie_parse_ep_dt(struct rockchip_pcie *rockchip,\n\t\t\t\t     struct rockchip_pcie_ep *ep)\n{\n\tstruct device *dev = rockchip->dev;\n\tint err;\n\n\terr = rockchip_pcie_parse_dt(rockchip);\n\tif (err)\n\t\treturn err;\n\n\terr = rockchip_pcie_get_phys(rockchip);\n\tif (err)\n\t\treturn err;\n\n\terr = of_property_read_u32(dev->of_node,\n\t\t\t\t   \"rockchip,max-outbound-regions\",\n\t\t\t\t   &ep->max_regions);\n\tif (err < 0 || ep->max_regions > MAX_REGION_LIMIT)\n\t\tep->max_regions = MAX_REGION_LIMIT;\n\n\tep->ob_region_map = 0;\n\n\terr = of_property_read_u8(dev->of_node, \"max-functions\",\n\t\t\t\t  &ep->epc->max_functions);\n\tif (err < 0)\n\t\tep->epc->max_functions = 1;\n\n\treturn 0;\n}\n\nstatic const struct of_device_id rockchip_pcie_ep_of_match[] = {\n\t{ .compatible = \"rockchip,rk3399-pcie-ep\"},\n\t{},\n};\n\nstatic int rockchip_pcie_ep_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct rockchip_pcie_ep *ep;\n\tstruct rockchip_pcie *rockchip;\n\tstruct pci_epc *epc;\n\tsize_t max_regions;\n\tstruct pci_epc_mem_window *windows = NULL;\n\tint err, i;\n\tu32 cfg_msi, cfg_msix_cp;\n\n\tep = devm_kzalloc(dev, sizeof(*ep), GFP_KERNEL);\n\tif (!ep)\n\t\treturn -ENOMEM;\n\n\trockchip = &ep->rockchip;\n\trockchip->is_rc = false;\n\trockchip->dev = dev;\n\n\tepc = devm_pci_epc_create(dev, &rockchip_pcie_epc_ops);\n\tif (IS_ERR(epc)) {\n\t\tdev_err(dev, \"failed to create epc device\\n\");\n\t\treturn PTR_ERR(epc);\n\t}\n\n\tep->epc = epc;\n\tepc_set_drvdata(epc, ep);\n\n\terr = rockchip_pcie_parse_ep_dt(rockchip, ep);\n\tif (err)\n\t\treturn err;\n\n\terr = rockchip_pcie_enable_clocks(rockchip);\n\tif (err)\n\t\treturn err;\n\n\terr = rockchip_pcie_init_port(rockchip);\n\tif (err)\n\t\tgoto err_disable_clocks;\n\n\t \n\trockchip_pcie_write(rockchip, PCIE_CLIENT_LINK_TRAIN_ENABLE,\n\t\t\t    PCIE_CLIENT_CONFIG);\n\n\tmax_regions = ep->max_regions;\n\tep->ob_addr = devm_kcalloc(dev, max_regions, sizeof(*ep->ob_addr),\n\t\t\t\t   GFP_KERNEL);\n\n\tif (!ep->ob_addr) {\n\t\terr = -ENOMEM;\n\t\tgoto err_uninit_port;\n\t}\n\n\t \n\trockchip_pcie_write(rockchip, BIT(0), PCIE_CORE_PHY_FUNC_CFG);\n\n\twindows = devm_kcalloc(dev, ep->max_regions,\n\t\t\t       sizeof(struct pci_epc_mem_window), GFP_KERNEL);\n\tif (!windows) {\n\t\terr = -ENOMEM;\n\t\tgoto err_uninit_port;\n\t}\n\tfor (i = 0; i < ep->max_regions; i++) {\n\t\twindows[i].phys_base = rockchip->mem_res->start + (SZ_1M * i);\n\t\twindows[i].size = SZ_1M;\n\t\twindows[i].page_size = SZ_1M;\n\t}\n\terr = pci_epc_multi_mem_init(epc, windows, ep->max_regions);\n\tdevm_kfree(dev, windows);\n\n\tif (err < 0) {\n\t\tdev_err(dev, \"failed to initialize the memory space\\n\");\n\t\tgoto err_uninit_port;\n\t}\n\n\tep->irq_cpu_addr = pci_epc_mem_alloc_addr(epc, &ep->irq_phys_addr,\n\t\t\t\t\t\t  SZ_1M);\n\tif (!ep->irq_cpu_addr) {\n\t\tdev_err(dev, \"failed to reserve memory space for MSI\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto err_epc_mem_exit;\n\t}\n\n\tep->irq_pci_addr = ROCKCHIP_PCIE_EP_DUMMY_IRQ_ADDR;\n\n\t \n\tcfg_msi = rockchip_pcie_read(rockchip, PCIE_EP_CONFIG_BASE +\n\t\t\t\t     ROCKCHIP_PCIE_EP_MSI_CTRL_REG);\n\n\tcfg_msi &= ~ROCKCHIP_PCIE_EP_MSI_CP1_MASK;\n\n\tcfg_msix_cp = rockchip_pcie_read(rockchip, PCIE_EP_CONFIG_BASE +\n\t\t\t\t\t ROCKCHIP_PCIE_EP_MSIX_CAP_REG) &\n\t\t\t\t\t ROCKCHIP_PCIE_EP_MSIX_CAP_CP_MASK;\n\n\tcfg_msi |= cfg_msix_cp;\n\n\trockchip_pcie_write(rockchip, cfg_msi,\n\t\t\t    PCIE_EP_CONFIG_BASE + ROCKCHIP_PCIE_EP_MSI_CTRL_REG);\n\n\trockchip_pcie_write(rockchip, PCIE_CLIENT_CONF_ENABLE,\n\t\t\t    PCIE_CLIENT_CONFIG);\n\n\treturn 0;\nerr_epc_mem_exit:\n\tpci_epc_mem_exit(epc);\nerr_uninit_port:\n\trockchip_pcie_deinit_phys(rockchip);\nerr_disable_clocks:\n\trockchip_pcie_disable_clocks(rockchip);\n\treturn err;\n}\n\nstatic struct platform_driver rockchip_pcie_ep_driver = {\n\t.driver = {\n\t\t.name = \"rockchip-pcie-ep\",\n\t\t.of_match_table = rockchip_pcie_ep_of_match,\n\t},\n\t.probe = rockchip_pcie_ep_probe,\n};\n\nbuiltin_platform_driver(rockchip_pcie_ep_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}