{
  "module_name": "pcie-iproc-platform.c",
  "hash_id": "028621b712207c4d55006ad4e2bb4d44bf051f34efcf62ca62cebec9ddc60e5c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/controller/pcie-iproc-platform.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/pci.h>\n#include <linux/clk.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/platform_device.h>\n#include <linux/of_address.h>\n#include <linux/of_pci.h>\n#include <linux/of_platform.h>\n#include <linux/phy/phy.h>\n\n#include \"../pci.h\"\n#include \"pcie-iproc.h\"\n\nstatic const struct of_device_id iproc_pcie_of_match_table[] = {\n\t{\n\t\t.compatible = \"brcm,iproc-pcie\",\n\t\t.data = (int *)IPROC_PCIE_PAXB,\n\t}, {\n\t\t.compatible = \"brcm,iproc-pcie-paxb-v2\",\n\t\t.data = (int *)IPROC_PCIE_PAXB_V2,\n\t}, {\n\t\t.compatible = \"brcm,iproc-pcie-paxc\",\n\t\t.data = (int *)IPROC_PCIE_PAXC,\n\t}, {\n\t\t.compatible = \"brcm,iproc-pcie-paxc-v2\",\n\t\t.data = (int *)IPROC_PCIE_PAXC_V2,\n\t},\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, iproc_pcie_of_match_table);\n\nstatic int iproc_pltfm_pcie_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct iproc_pcie *pcie;\n\tstruct device_node *np = dev->of_node;\n\tstruct resource reg;\n\tstruct pci_host_bridge *bridge;\n\tint ret;\n\n\tbridge = devm_pci_alloc_host_bridge(dev, sizeof(*pcie));\n\tif (!bridge)\n\t\treturn -ENOMEM;\n\n\tpcie = pci_host_bridge_priv(bridge);\n\n\tpcie->dev = dev;\n\tpcie->type = (enum iproc_pcie_type) of_device_get_match_data(dev);\n\n\tret = of_address_to_resource(np, 0, &reg);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"unable to obtain controller resources\\n\");\n\t\treturn ret;\n\t}\n\n\tpcie->base = devm_pci_remap_cfgspace(dev, reg.start,\n\t\t\t\t\t     resource_size(&reg));\n\tif (!pcie->base) {\n\t\tdev_err(dev, \"unable to map controller registers\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tpcie->base_addr = reg.start;\n\n\tif (of_property_read_bool(np, \"brcm,pcie-ob\")) {\n\t\tu32 val;\n\n\t\tret = of_property_read_u32(np, \"brcm,pcie-ob-axi-offset\",\n\t\t\t\t\t   &val);\n\t\tif (ret) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"missing brcm,pcie-ob-axi-offset property\\n\");\n\t\t\treturn ret;\n\t\t}\n\t\tpcie->ob.axi_offset = val;\n\t\tpcie->need_ob_cfg = true;\n\t}\n\n\t \n\tpcie->need_ib_cfg = of_property_read_bool(np, \"dma-ranges\");\n\n\t \n\tpcie->phy = devm_phy_optional_get(dev, \"pcie-phy\");\n\tif (IS_ERR(pcie->phy))\n\t\treturn PTR_ERR(pcie->phy);\n\n\t \n\tswitch (pcie->type) {\n\tcase IPROC_PCIE_PAXC:\n\tcase IPROC_PCIE_PAXC_V2:\n\t\tpcie->map_irq = NULL;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tret = iproc_pcie_setup(pcie, &bridge->windows);\n\tif (ret) {\n\t\tdev_err(dev, \"PCIe controller setup failed\\n\");\n\t\treturn ret;\n\t}\n\n\tplatform_set_drvdata(pdev, pcie);\n\treturn 0;\n}\n\nstatic void iproc_pltfm_pcie_remove(struct platform_device *pdev)\n{\n\tstruct iproc_pcie *pcie = platform_get_drvdata(pdev);\n\n\tiproc_pcie_remove(pcie);\n}\n\nstatic void iproc_pltfm_pcie_shutdown(struct platform_device *pdev)\n{\n\tstruct iproc_pcie *pcie = platform_get_drvdata(pdev);\n\n\tiproc_pcie_shutdown(pcie);\n}\n\nstatic struct platform_driver iproc_pltfm_pcie_driver = {\n\t.driver = {\n\t\t.name = \"iproc-pcie\",\n\t\t.of_match_table = of_match_ptr(iproc_pcie_of_match_table),\n\t},\n\t.probe = iproc_pltfm_pcie_probe,\n\t.remove_new = iproc_pltfm_pcie_remove,\n\t.shutdown = iproc_pltfm_pcie_shutdown,\n};\nmodule_platform_driver(iproc_pltfm_pcie_driver);\n\nMODULE_AUTHOR(\"Ray Jui <rjui@broadcom.com>\");\nMODULE_DESCRIPTION(\"Broadcom iPROC PCIe platform driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}