{
  "module_name": "pci-thunder-ecam.c",
  "hash_id": "32cfa06010381ba54c523b361efda465e339d79dae0ea42e87f99fe84aff9ace",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/controller/pci-thunder-ecam.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/of_pci.h>\n#include <linux/of.h>\n#include <linux/pci-ecam.h>\n#include <linux/platform_device.h>\n\n#if defined(CONFIG_PCI_HOST_THUNDER_ECAM) || (defined(CONFIG_ACPI) && defined(CONFIG_PCI_QUIRKS))\n\nstatic void set_val(u32 v, int where, int size, u32 *val)\n{\n\tint shift = (where & 3) * 8;\n\n\tpr_debug(\"set_val %04x: %08x\\n\", (unsigned int)(where & ~3), v);\n\tv >>= shift;\n\tif (size == 1)\n\t\tv &= 0xff;\n\telse if (size == 2)\n\t\tv &= 0xffff;\n\t*val = v;\n}\n\nstatic int handle_ea_bar(u32 e0, int bar, struct pci_bus *bus,\n\t\t\t unsigned int devfn, int where, int size, u32 *val)\n{\n\tvoid __iomem *addr;\n\tu32 v;\n\n\t \n\tint where_a = where & 0xc;\n\n\tif (where_a == 0) {\n\t\tset_val(e0, where, size, val);\n\t\treturn PCIBIOS_SUCCESSFUL;\n\t}\n\tif (where_a == 0x4) {\n\t\taddr = bus->ops->map_bus(bus, devfn, bar);  \n\t\tif (!addr)\n\t\t\treturn PCIBIOS_DEVICE_NOT_FOUND;\n\n\t\tv = readl(addr);\n\t\tv &= ~0xf;\n\t\tv |= 2;  \n\t\tset_val(v, where, size, val);\n\t\treturn PCIBIOS_SUCCESSFUL;\n\t}\n\tif (where_a == 0x8) {\n\t\tu32 barl_orig;\n\t\tu32 barl_rb;\n\n\t\taddr = bus->ops->map_bus(bus, devfn, bar);  \n\t\tif (!addr)\n\t\t\treturn PCIBIOS_DEVICE_NOT_FOUND;\n\n\t\tbarl_orig = readl(addr + 0);\n\t\twritel(0xffffffff, addr + 0);\n\t\tbarl_rb = readl(addr + 0);\n\t\twritel(barl_orig, addr + 0);\n\t\t \n\t\tv = ~barl_rb & ~3;\n\t\tv |= 0xc;  \n\t\tset_val(v, where, size, val);\n\t\treturn PCIBIOS_SUCCESSFUL;\n\t}\n\tif (where_a == 0xc) {\n\t\taddr = bus->ops->map_bus(bus, devfn, bar + 4);  \n\t\tif (!addr)\n\t\t\treturn PCIBIOS_DEVICE_NOT_FOUND;\n\n\t\tv = readl(addr);  \n\t\tset_val(v, where, size, val);\n\t\treturn PCIBIOS_SUCCESSFUL;\n\t}\n\treturn PCIBIOS_DEVICE_NOT_FOUND;\n}\n\nstatic int thunder_ecam_p2_config_read(struct pci_bus *bus, unsigned int devfn,\n\t\t\t\t       int where, int size, u32 *val)\n{\n\tstruct pci_config_window *cfg = bus->sysdata;\n\tint where_a = where & ~3;\n\tvoid __iomem *addr;\n\tu32 node_bits;\n\tu32 v;\n\n\t \n\tswitch (where_a) {\n\tcase 0xa8:\n\tcase 0xbc:\n\tcase 0xd0:\n\tcase 0xe4:\n\t\tbreak;\n\tdefault:\n\t\treturn pci_generic_config_read(bus, devfn, where, size, val);\n\t}\n\n\taddr = bus->ops->map_bus(bus, devfn, where_a);\n\tif (!addr)\n\t\treturn PCIBIOS_DEVICE_NOT_FOUND;\n\n\tv = readl(addr);\n\n\t \n\tnode_bits = upper_32_bits(cfg->res.start) & (1 << 12);\n\n\tv |= node_bits;\n\tset_val(v, where, size, val);\n\n\treturn PCIBIOS_SUCCESSFUL;\n}\n\nstatic int thunder_ecam_config_read(struct pci_bus *bus, unsigned int devfn,\n\t\t\t\t    int where, int size, u32 *val)\n{\n\tu32 v;\n\tu32 vendor_device;\n\tu32 class_rev;\n\tvoid __iomem *addr;\n\tint cfg_type;\n\tint where_a = where & ~3;\n\n\taddr = bus->ops->map_bus(bus, devfn, 0xc);\n\tif (!addr)\n\t\treturn PCIBIOS_DEVICE_NOT_FOUND;\n\n\tv = readl(addr);\n\n\t \n\tcfg_type = (v >> 16) & 0x7f;\n\n\taddr = bus->ops->map_bus(bus, devfn, 8);\n\tif (!addr)\n\t\treturn PCIBIOS_DEVICE_NOT_FOUND;\n\n\tclass_rev = readl(addr);\n\tif (class_rev == 0xffffffff)\n\t\tgoto no_emulation;\n\n\tif ((class_rev & 0xff) >= 8) {\n\t\t \n\t\tif (cfg_type)\n\t\t\tgoto no_emulation;\n\t\treturn thunder_ecam_p2_config_read(bus, devfn, where,\n\t\t\t\t\t\t   size, val);\n\t}\n\n\t \n\tif (cfg_type == 0 &&\n\t    ((where >= 0x10 && where < 0x2c) ||\n\t     (where >= 0x1a4 && where < 0x1bc))) {\n\t\t \n\t\t*val = 0;\n\t\treturn PCIBIOS_SUCCESSFUL;\n\t}\n\n\taddr = bus->ops->map_bus(bus, devfn, 0);\n\tif (!addr)\n\t\treturn PCIBIOS_DEVICE_NOT_FOUND;\n\n\tvendor_device = readl(addr);\n\tif (vendor_device == 0xffffffff)\n\t\tgoto no_emulation;\n\n\tpr_debug(\"%04x:%04x - Fix pass#: %08x, where: %03x, devfn: %03x\\n\",\n\t\t vendor_device & 0xffff, vendor_device >> 16, class_rev,\n\t\t (unsigned int)where, devfn);\n\n\t \n\tif (cfg_type == 0) {\n\t\tbool has_msix;\n\t\tbool is_nic = (vendor_device == 0xa01e177d);\n\t\tbool is_tns = (vendor_device == 0xa01f177d);\n\n\t\taddr = bus->ops->map_bus(bus, devfn, 0x70);\n\t\tif (!addr)\n\t\t\treturn PCIBIOS_DEVICE_NOT_FOUND;\n\n\t\t \n\t\tv = readl(addr);\n\t\thas_msix = (v & 0xff00) != 0;\n\n\t\tif (!has_msix && where_a == 0x70) {\n\t\t\tv |= 0xbc00;  \n\t\t\tset_val(v, where, size, val);\n\t\t\treturn PCIBIOS_SUCCESSFUL;\n\t\t}\n\t\tif (where_a == 0xb0) {\n\t\t\taddr = bus->ops->map_bus(bus, devfn, where_a);\n\t\t\tif (!addr)\n\t\t\t\treturn PCIBIOS_DEVICE_NOT_FOUND;\n\n\t\t\tv = readl(addr);\n\t\t\tif (v & 0xff00)\n\t\t\t\tpr_err(\"Bad MSIX cap header: %08x\\n\", v);\n\t\t\tv |= 0xbc00;  \n\t\t\tset_val(v, where, size, val);\n\t\t\treturn PCIBIOS_SUCCESSFUL;\n\t\t}\n\t\tif (where_a == 0xbc) {\n\t\t\tif (is_nic)\n\t\t\t\tv = 0x40014;  \n\t\t\telse if (is_tns)\n\t\t\t\tv = 0x30014;  \n\t\t\telse if (has_msix)\n\t\t\t\tv = 0x20014;  \n\t\t\telse\n\t\t\t\tv = 0x10014;  \n\t\t\tset_val(v, where, size, val);\n\t\t\treturn PCIBIOS_SUCCESSFUL;\n\t\t}\n\t\tif (where_a >= 0xc0 && where_a < 0xd0)\n\t\t\t \n\t\t\treturn handle_ea_bar(0x80ff0003,\n\t\t\t\t\t     0x10, bus, devfn, where,\n\t\t\t\t\t     size, val);\n\t\tif (where_a >= 0xd0 && where_a < 0xe0 && has_msix)\n\t\t\t  \n\t\t\treturn handle_ea_bar(0x80ff0043,\n\t\t\t\t\t     0x20, bus, devfn, where,\n\t\t\t\t\t     size, val);\n\t\tif (where_a >= 0xe0 && where_a < 0xf0 && is_tns)\n\t\t\t \n\t\t\treturn handle_ea_bar(0x80ff0023,\n\t\t\t\t\t     0x18, bus, devfn, where,\n\t\t\t\t\t     size, val);\n\t\tif (where_a >= 0xe0 && where_a < 0xf0 && is_nic)\n\t\t\t \n\t\t\treturn handle_ea_bar(0x80ff0493,\n\t\t\t\t\t     0x1a4, bus, devfn, where,\n\t\t\t\t\t     size, val);\n\t\tif (where_a >= 0xf0 && where_a < 0x100 && is_nic)\n\t\t\t \n\t\t\treturn handle_ea_bar(0x80ff04d3,\n\t\t\t\t\t     0x1b4, bus, devfn, where,\n\t\t\t\t\t     size, val);\n\t} else if (cfg_type == 1) {\n\t\tbool is_rsl_bridge = devfn == 0x08;\n\t\tbool is_rad_bridge = devfn == 0xa0;\n\t\tbool is_zip_bridge = devfn == 0xa8;\n\t\tbool is_dfa_bridge = devfn == 0xb0;\n\t\tbool is_nic_bridge = devfn == 0x10;\n\n\t\tif (where_a == 0x70) {\n\t\t\taddr = bus->ops->map_bus(bus, devfn, where_a);\n\t\t\tif (!addr)\n\t\t\t\treturn PCIBIOS_DEVICE_NOT_FOUND;\n\n\t\t\tv = readl(addr);\n\t\t\tif (v & 0xff00)\n\t\t\t\tpr_err(\"Bad PCIe cap header: %08x\\n\", v);\n\t\t\tv |= 0xbc00;  \n\t\t\tset_val(v, where, size, val);\n\t\t\treturn PCIBIOS_SUCCESSFUL;\n\t\t}\n\t\tif (where_a == 0xbc) {\n\t\t\tif (is_nic_bridge)\n\t\t\t\tv = 0x10014;  \n\t\t\telse\n\t\t\t\tv = 0x00014;  \n\t\t\tset_val(v, where, size, val);\n\t\t\treturn PCIBIOS_SUCCESSFUL;\n\t\t}\n\t\tif (where_a == 0xc0) {\n\t\t\tif (is_rsl_bridge || is_nic_bridge)\n\t\t\t\tv = 0x0101;  \n\t\t\telse if (is_rad_bridge)\n\t\t\t\tv = 0x0202;  \n\t\t\telse if (is_zip_bridge)\n\t\t\t\tv = 0x0303;  \n\t\t\telse if (is_dfa_bridge)\n\t\t\t\tv = 0x0404;  \n\t\t\tset_val(v, where, size, val);\n\t\t\treturn PCIBIOS_SUCCESSFUL;\n\t\t}\n\t\tif (where_a == 0xc4 && is_nic_bridge) {\n\t\t\t \n\t\t\tv = 0x80ff0564;\n\t\t\tset_val(v, where, size, val);\n\t\t\treturn PCIBIOS_SUCCESSFUL;\n\t\t}\n\t\tif (where_a == 0xc8 && is_nic_bridge) {\n\t\t\tv = 0x00000002;  \n\t\t\tset_val(v, where, size, val);\n\t\t\treturn PCIBIOS_SUCCESSFUL;\n\t\t}\n\t\tif (where_a == 0xcc && is_nic_bridge) {\n\t\t\tv = 0xfffffffe;  \n\t\t\tset_val(v, where, size, val);\n\t\t\treturn PCIBIOS_SUCCESSFUL;\n\t\t}\n\t\tif (where_a == 0xd0 && is_nic_bridge) {\n\t\t\tv = 0x00008430;  \n\t\t\tset_val(v, where, size, val);\n\t\t\treturn PCIBIOS_SUCCESSFUL;\n\t\t}\n\t\tif (where_a == 0xd4 && is_nic_bridge) {\n\t\t\tv = 0x0000000f;  \n\t\t\tset_val(v, where, size, val);\n\t\t\treturn PCIBIOS_SUCCESSFUL;\n\t\t}\n\t}\nno_emulation:\n\treturn pci_generic_config_read(bus, devfn, where, size, val);\n}\n\nstatic int thunder_ecam_config_write(struct pci_bus *bus, unsigned int devfn,\n\t\t\t\t     int where, int size, u32 val)\n{\n\t \n\tif ((where >= 0x10 && where < 0x2c) ||\n\t    (where >= 0x1a4 && where < 0x1bc))\n\t\t \n\t\treturn PCIBIOS_SUCCESSFUL;\n\n\treturn pci_generic_config_write(bus, devfn, where, size, val);\n}\n\nconst struct pci_ecam_ops pci_thunder_ecam_ops = {\n\t.pci_ops\t= {\n\t\t.map_bus        = pci_ecam_map_bus,\n\t\t.read           = thunder_ecam_config_read,\n\t\t.write          = thunder_ecam_config_write,\n\t}\n};\n\n#ifdef CONFIG_PCI_HOST_THUNDER_ECAM\n\nstatic const struct of_device_id thunder_ecam_of_match[] = {\n\t{\n\t\t.compatible = \"cavium,pci-host-thunder-ecam\",\n\t\t.data = &pci_thunder_ecam_ops,\n\t},\n\t{ },\n};\n\nstatic struct platform_driver thunder_ecam_driver = {\n\t.driver = {\n\t\t.name = KBUILD_MODNAME,\n\t\t.of_match_table = thunder_ecam_of_match,\n\t\t.suppress_bind_attrs = true,\n\t},\n\t.probe = pci_host_common_probe,\n};\nbuiltin_platform_driver(thunder_ecam_driver);\n\n#endif\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}