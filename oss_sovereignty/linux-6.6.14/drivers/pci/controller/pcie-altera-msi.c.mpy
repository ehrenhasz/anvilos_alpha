{
  "module_name": "pcie-altera-msi.c",
  "hash_id": "eb696a180c56d47ea4d59441e82795cec670b065b22faf856651e86bb0ba14de",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/controller/pcie-altera-msi.c",
  "human_readable_source": "\n \n\n#include <linux/interrupt.h>\n#include <linux/irqchip/chained_irq.h>\n#include <linux/irqdomain.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/of_address.h>\n#include <linux/of_pci.h>\n#include <linux/pci.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n\n#define MSI_STATUS\t\t0x0\n#define MSI_ERROR\t\t0x4\n#define MSI_INTMASK\t\t0x8\n\n#define MAX_MSI_VECTORS\t\t32\n\nstruct altera_msi {\n\tDECLARE_BITMAP(used, MAX_MSI_VECTORS);\n\tstruct mutex\t\tlock;\t \n\tstruct platform_device\t*pdev;\n\tstruct irq_domain\t*msi_domain;\n\tstruct irq_domain\t*inner_domain;\n\tvoid __iomem\t\t*csr_base;\n\tvoid __iomem\t\t*vector_base;\n\tphys_addr_t\t\tvector_phy;\n\tu32\t\t\tnum_of_vectors;\n\tint\t\t\tirq;\n};\n\nstatic inline void msi_writel(struct altera_msi *msi, const u32 value,\n\t\t\t      const u32 reg)\n{\n\twritel_relaxed(value, msi->csr_base + reg);\n}\n\nstatic inline u32 msi_readl(struct altera_msi *msi, const u32 reg)\n{\n\treturn readl_relaxed(msi->csr_base + reg);\n}\n\nstatic void altera_msi_isr(struct irq_desc *desc)\n{\n\tstruct irq_chip *chip = irq_desc_get_chip(desc);\n\tstruct altera_msi *msi;\n\tunsigned long status;\n\tu32 bit;\n\tint ret;\n\n\tchained_irq_enter(chip, desc);\n\tmsi = irq_desc_get_handler_data(desc);\n\n\twhile ((status = msi_readl(msi, MSI_STATUS)) != 0) {\n\t\tfor_each_set_bit(bit, &status, msi->num_of_vectors) {\n\t\t\t \n\t\t\treadl_relaxed(msi->vector_base + (bit * sizeof(u32)));\n\n\t\t\tret = generic_handle_domain_irq(msi->inner_domain, bit);\n\t\t\tif (ret)\n\t\t\t\tdev_err_ratelimited(&msi->pdev->dev, \"unexpected MSI\\n\");\n\t\t}\n\t}\n\n\tchained_irq_exit(chip, desc);\n}\n\nstatic struct irq_chip altera_msi_irq_chip = {\n\t.name = \"Altera PCIe MSI\",\n\t.irq_mask = pci_msi_mask_irq,\n\t.irq_unmask = pci_msi_unmask_irq,\n};\n\nstatic struct msi_domain_info altera_msi_domain_info = {\n\t.flags\t= (MSI_FLAG_USE_DEF_DOM_OPS | MSI_FLAG_USE_DEF_CHIP_OPS |\n\t\t     MSI_FLAG_PCI_MSIX),\n\t.chip\t= &altera_msi_irq_chip,\n};\n\nstatic void altera_compose_msi_msg(struct irq_data *data, struct msi_msg *msg)\n{\n\tstruct altera_msi *msi = irq_data_get_irq_chip_data(data);\n\tphys_addr_t addr = msi->vector_phy + (data->hwirq * sizeof(u32));\n\n\tmsg->address_lo = lower_32_bits(addr);\n\tmsg->address_hi = upper_32_bits(addr);\n\tmsg->data = data->hwirq;\n\n\tdev_dbg(&msi->pdev->dev, \"msi#%d address_hi %#x address_lo %#x\\n\",\n\t\t(int)data->hwirq, msg->address_hi, msg->address_lo);\n}\n\nstatic int altera_msi_set_affinity(struct irq_data *irq_data,\n\t\t\t\t   const struct cpumask *mask, bool force)\n{\n\t return -EINVAL;\n}\n\nstatic struct irq_chip altera_msi_bottom_irq_chip = {\n\t.name\t\t\t= \"Altera MSI\",\n\t.irq_compose_msi_msg\t= altera_compose_msi_msg,\n\t.irq_set_affinity\t= altera_msi_set_affinity,\n};\n\nstatic int altera_irq_domain_alloc(struct irq_domain *domain, unsigned int virq,\n\t\t\t\t   unsigned int nr_irqs, void *args)\n{\n\tstruct altera_msi *msi = domain->host_data;\n\tunsigned long bit;\n\tu32 mask;\n\n\tWARN_ON(nr_irqs != 1);\n\tmutex_lock(&msi->lock);\n\n\tbit = find_first_zero_bit(msi->used, msi->num_of_vectors);\n\tif (bit >= msi->num_of_vectors) {\n\t\tmutex_unlock(&msi->lock);\n\t\treturn -ENOSPC;\n\t}\n\n\tset_bit(bit, msi->used);\n\n\tmutex_unlock(&msi->lock);\n\n\tirq_domain_set_info(domain, virq, bit, &altera_msi_bottom_irq_chip,\n\t\t\t    domain->host_data, handle_simple_irq,\n\t\t\t    NULL, NULL);\n\n\tmask = msi_readl(msi, MSI_INTMASK);\n\tmask |= 1 << bit;\n\tmsi_writel(msi, mask, MSI_INTMASK);\n\n\treturn 0;\n}\n\nstatic void altera_irq_domain_free(struct irq_domain *domain,\n\t\t\t\t   unsigned int virq, unsigned int nr_irqs)\n{\n\tstruct irq_data *d = irq_domain_get_irq_data(domain, virq);\n\tstruct altera_msi *msi = irq_data_get_irq_chip_data(d);\n\tu32 mask;\n\n\tmutex_lock(&msi->lock);\n\n\tif (!test_bit(d->hwirq, msi->used)) {\n\t\tdev_err(&msi->pdev->dev, \"trying to free unused MSI#%lu\\n\",\n\t\t\td->hwirq);\n\t} else {\n\t\t__clear_bit(d->hwirq, msi->used);\n\t\tmask = msi_readl(msi, MSI_INTMASK);\n\t\tmask &= ~(1 << d->hwirq);\n\t\tmsi_writel(msi, mask, MSI_INTMASK);\n\t}\n\n\tmutex_unlock(&msi->lock);\n}\n\nstatic const struct irq_domain_ops msi_domain_ops = {\n\t.alloc\t= altera_irq_domain_alloc,\n\t.free\t= altera_irq_domain_free,\n};\n\nstatic int altera_allocate_domains(struct altera_msi *msi)\n{\n\tstruct fwnode_handle *fwnode = of_node_to_fwnode(msi->pdev->dev.of_node);\n\n\tmsi->inner_domain = irq_domain_add_linear(NULL, msi->num_of_vectors,\n\t\t\t\t\t     &msi_domain_ops, msi);\n\tif (!msi->inner_domain) {\n\t\tdev_err(&msi->pdev->dev, \"failed to create IRQ domain\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tmsi->msi_domain = pci_msi_create_irq_domain(fwnode,\n\t\t\t\t&altera_msi_domain_info, msi->inner_domain);\n\tif (!msi->msi_domain) {\n\t\tdev_err(&msi->pdev->dev, \"failed to create MSI domain\\n\");\n\t\tirq_domain_remove(msi->inner_domain);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic void altera_free_domains(struct altera_msi *msi)\n{\n\tirq_domain_remove(msi->msi_domain);\n\tirq_domain_remove(msi->inner_domain);\n}\n\nstatic void altera_msi_remove(struct platform_device *pdev)\n{\n\tstruct altera_msi *msi = platform_get_drvdata(pdev);\n\n\tmsi_writel(msi, 0, MSI_INTMASK);\n\tirq_set_chained_handler_and_data(msi->irq, NULL, NULL);\n\n\taltera_free_domains(msi);\n\n\tplatform_set_drvdata(pdev, NULL);\n}\n\nstatic int altera_msi_probe(struct platform_device *pdev)\n{\n\tstruct altera_msi *msi;\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct resource *res;\n\tint ret;\n\n\tmsi = devm_kzalloc(&pdev->dev, sizeof(struct altera_msi),\n\t\t\t   GFP_KERNEL);\n\tif (!msi)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&msi->lock);\n\tmsi->pdev = pdev;\n\n\tmsi->csr_base = devm_platform_ioremap_resource_byname(pdev, \"csr\");\n\tif (IS_ERR(msi->csr_base)) {\n\t\tdev_err(&pdev->dev, \"failed to map csr memory\\n\");\n\t\treturn PTR_ERR(msi->csr_base);\n\t}\n\n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM,\n\t\t\t\t\t   \"vector_slave\");\n\tmsi->vector_base = devm_ioremap_resource(&pdev->dev, res);\n\tif (IS_ERR(msi->vector_base))\n\t\treturn PTR_ERR(msi->vector_base);\n\n\tmsi->vector_phy = res->start;\n\n\tif (of_property_read_u32(np, \"num-vectors\", &msi->num_of_vectors)) {\n\t\tdev_err(&pdev->dev, \"failed to parse the number of vectors\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = altera_allocate_domains(msi);\n\tif (ret)\n\t\treturn ret;\n\n\tmsi->irq = platform_get_irq(pdev, 0);\n\tif (msi->irq < 0) {\n\t\tret = msi->irq;\n\t\tgoto err;\n\t}\n\n\tirq_set_chained_handler_and_data(msi->irq, altera_msi_isr, msi);\n\tplatform_set_drvdata(pdev, msi);\n\n\treturn 0;\n\nerr:\n\taltera_msi_remove(pdev);\n\treturn ret;\n}\n\nstatic const struct of_device_id altera_msi_of_match[] = {\n\t{ .compatible = \"altr,msi-1.0\", NULL },\n\t{ },\n};\n\nstatic struct platform_driver altera_msi_driver = {\n\t.driver = {\n\t\t.name = \"altera-msi\",\n\t\t.of_match_table = altera_msi_of_match,\n\t},\n\t.probe = altera_msi_probe,\n\t.remove_new = altera_msi_remove,\n};\n\nstatic int __init altera_msi_init(void)\n{\n\treturn platform_driver_register(&altera_msi_driver);\n}\n\nstatic void __exit altera_msi_exit(void)\n{\n\tplatform_driver_unregister(&altera_msi_driver);\n}\n\nsubsys_initcall(altera_msi_init);\nMODULE_DEVICE_TABLE(of, altera_msi_of_match);\nmodule_exit(altera_msi_exit);\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}