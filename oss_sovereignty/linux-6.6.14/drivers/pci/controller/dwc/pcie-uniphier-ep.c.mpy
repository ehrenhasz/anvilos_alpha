{
  "module_name": "pcie-uniphier-ep.c",
  "hash_id": "5725e477fa40d17f790f40a1da4cc0071f1ed04a60a5bf5a80fc4746657c9ad0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/controller/dwc/pcie-uniphier-ep.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/iopoll.h>\n#include <linux/of.h>\n#include <linux/pci.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n#include <linux/reset.h>\n\n#include \"pcie-designware.h\"\n\n \n#define PCL_RSTCTRL0\t\t\t0x0010\n#define PCL_RSTCTRL_AXI_REG\t\tBIT(3)\n#define PCL_RSTCTRL_AXI_SLAVE\t\tBIT(2)\n#define PCL_RSTCTRL_AXI_MASTER\t\tBIT(1)\n#define PCL_RSTCTRL_PIPE3\t\tBIT(0)\n\n#define PCL_RSTCTRL1\t\t\t0x0020\n#define PCL_RSTCTRL_PERST\t\tBIT(0)\n\n#define PCL_RSTCTRL2\t\t\t0x0024\n#define PCL_RSTCTRL_PHY_RESET\t\tBIT(0)\n\n#define PCL_PINCTRL0\t\t\t0x002c\n#define PCL_PERST_PLDN_REGEN\t\tBIT(12)\n#define PCL_PERST_NOE_REGEN\t\tBIT(11)\n#define PCL_PERST_OUT_REGEN\t\tBIT(8)\n#define PCL_PERST_PLDN_REGVAL\t\tBIT(4)\n#define PCL_PERST_NOE_REGVAL\t\tBIT(3)\n#define PCL_PERST_OUT_REGVAL\t\tBIT(0)\n\n#define PCL_PIPEMON\t\t\t0x0044\n#define PCL_PCLK_ALIVE\t\t\tBIT(15)\n\n#define PCL_MODE\t\t\t0x8000\n#define PCL_MODE_REGEN\t\t\tBIT(8)\n#define PCL_MODE_REGVAL\t\t\tBIT(0)\n\n#define PCL_APP_CLK_CTRL\t\t0x8004\n#define PCL_APP_CLK_REQ\t\t\tBIT(0)\n\n#define PCL_APP_READY_CTRL\t\t0x8008\n#define PCL_APP_LTSSM_ENABLE\t\tBIT(0)\n\n#define PCL_APP_MSI0\t\t\t0x8040\n#define PCL_APP_VEN_MSI_TC_MASK\t\tGENMASK(10, 8)\n#define PCL_APP_VEN_MSI_VECTOR_MASK\tGENMASK(4, 0)\n\n#define PCL_APP_MSI1\t\t\t0x8044\n#define PCL_APP_MSI_REQ\t\t\tBIT(0)\n\n#define PCL_APP_INTX\t\t\t0x8074\n#define PCL_APP_INTX_SYS_INT\t\tBIT(0)\n\n#define PCL_APP_PM0\t\t\t0x8078\n#define PCL_SYS_AUX_PWR_DET\t\tBIT(8)\n\n \n#define PCL_INTX_WIDTH_USEC\t\t30\n\nstruct uniphier_pcie_ep_priv {\n\tvoid __iomem *base;\n\tstruct dw_pcie pci;\n\tstruct clk *clk, *clk_gio;\n\tstruct reset_control *rst, *rst_gio;\n\tstruct phy *phy;\n\tconst struct uniphier_pcie_ep_soc_data *data;\n};\n\nstruct uniphier_pcie_ep_soc_data {\n\tbool has_gio;\n\tvoid (*init)(struct uniphier_pcie_ep_priv *priv);\n\tint (*wait)(struct uniphier_pcie_ep_priv *priv);\n\tconst struct pci_epc_features features;\n};\n\n#define to_uniphier_pcie(x)\tdev_get_drvdata((x)->dev)\n\nstatic void uniphier_pcie_ltssm_enable(struct uniphier_pcie_ep_priv *priv,\n\t\t\t\t       bool enable)\n{\n\tu32 val;\n\n\tval = readl(priv->base + PCL_APP_READY_CTRL);\n\tif (enable)\n\t\tval |= PCL_APP_LTSSM_ENABLE;\n\telse\n\t\tval &= ~PCL_APP_LTSSM_ENABLE;\n\twritel(val, priv->base + PCL_APP_READY_CTRL);\n}\n\nstatic void uniphier_pcie_phy_reset(struct uniphier_pcie_ep_priv *priv,\n\t\t\t\t    bool assert)\n{\n\tu32 val;\n\n\tval = readl(priv->base + PCL_RSTCTRL2);\n\tif (assert)\n\t\tval |= PCL_RSTCTRL_PHY_RESET;\n\telse\n\t\tval &= ~PCL_RSTCTRL_PHY_RESET;\n\twritel(val, priv->base + PCL_RSTCTRL2);\n}\n\nstatic void uniphier_pcie_pro5_init_ep(struct uniphier_pcie_ep_priv *priv)\n{\n\tu32 val;\n\n\t \n\tval = readl(priv->base + PCL_MODE);\n\tval |= PCL_MODE_REGEN | PCL_MODE_REGVAL;\n\twritel(val, priv->base + PCL_MODE);\n\n\t \n\tval = readl(priv->base + PCL_APP_CLK_CTRL);\n\tval &= ~PCL_APP_CLK_REQ;\n\twritel(val, priv->base + PCL_APP_CLK_CTRL);\n\n\t \n\tval = readl(priv->base + PCL_RSTCTRL0);\n\tval |= PCL_RSTCTRL_AXI_REG | PCL_RSTCTRL_AXI_SLAVE\n\t\t| PCL_RSTCTRL_AXI_MASTER | PCL_RSTCTRL_PIPE3;\n\twritel(val, priv->base + PCL_RSTCTRL0);\n\n\tuniphier_pcie_ltssm_enable(priv, false);\n\n\tmsleep(100);\n}\n\nstatic void uniphier_pcie_nx1_init_ep(struct uniphier_pcie_ep_priv *priv)\n{\n\tu32 val;\n\n\t \n\tval = readl(priv->base + PCL_MODE);\n\tval |= PCL_MODE_REGEN | PCL_MODE_REGVAL;\n\twritel(val, priv->base + PCL_MODE);\n\n\t \n\tval = readl(priv->base + PCL_APP_PM0);\n\tval |= PCL_SYS_AUX_PWR_DET;\n\twritel(val, priv->base + PCL_APP_PM0);\n\n\t \n\tval = readl(priv->base + PCL_PINCTRL0);\n\tval &= ~(PCL_PERST_NOE_REGVAL | PCL_PERST_OUT_REGVAL\n\t\t | PCL_PERST_PLDN_REGVAL);\n\tval |= PCL_PERST_NOE_REGEN | PCL_PERST_OUT_REGEN\n\t\t| PCL_PERST_PLDN_REGEN;\n\twritel(val, priv->base + PCL_PINCTRL0);\n\n\tuniphier_pcie_ltssm_enable(priv, false);\n\n\tusleep_range(100000, 200000);\n\n\t \n\tval = readl(priv->base + PCL_PINCTRL0);\n\tval |= PCL_PERST_OUT_REGVAL | PCL_PERST_OUT_REGEN;\n\twritel(val, priv->base + PCL_PINCTRL0);\n}\n\nstatic int uniphier_pcie_nx1_wait_ep(struct uniphier_pcie_ep_priv *priv)\n{\n\tu32 status;\n\tint ret;\n\n\t \n\tret = readl_poll_timeout(priv->base + PCL_PIPEMON, status,\n\t\t\t\t status & PCL_PCLK_ALIVE, 100000, 1000000);\n\tif (ret) {\n\t\tdev_err(priv->pci.dev,\n\t\t\t\"Failed to initialize controller in EP mode\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int uniphier_pcie_start_link(struct dw_pcie *pci)\n{\n\tstruct uniphier_pcie_ep_priv *priv = to_uniphier_pcie(pci);\n\n\tuniphier_pcie_ltssm_enable(priv, true);\n\n\treturn 0;\n}\n\nstatic void uniphier_pcie_stop_link(struct dw_pcie *pci)\n{\n\tstruct uniphier_pcie_ep_priv *priv = to_uniphier_pcie(pci);\n\n\tuniphier_pcie_ltssm_enable(priv, false);\n}\n\nstatic void uniphier_pcie_ep_init(struct dw_pcie_ep *ep)\n{\n\tstruct dw_pcie *pci = to_dw_pcie_from_ep(ep);\n\tenum pci_barno bar;\n\n\tfor (bar = BAR_0; bar <= BAR_5; bar++)\n\t\tdw_pcie_ep_reset_bar(pci, bar);\n}\n\nstatic int uniphier_pcie_ep_raise_legacy_irq(struct dw_pcie_ep *ep)\n{\n\tstruct dw_pcie *pci = to_dw_pcie_from_ep(ep);\n\tstruct uniphier_pcie_ep_priv *priv = to_uniphier_pcie(pci);\n\tu32 val;\n\n\t \n\t \n\tval = readl(priv->base + PCL_APP_INTX);\n\tval |= PCL_APP_INTX_SYS_INT;\n\twritel(val, priv->base + PCL_APP_INTX);\n\n\tudelay(PCL_INTX_WIDTH_USEC);\n\n\t \n\tval &= ~PCL_APP_INTX_SYS_INT;\n\twritel(val, priv->base + PCL_APP_INTX);\n\n\treturn 0;\n}\n\nstatic int uniphier_pcie_ep_raise_msi_irq(struct dw_pcie_ep *ep,\n\t\t\t\t\t  u8 func_no, u16 interrupt_num)\n{\n\tstruct dw_pcie *pci = to_dw_pcie_from_ep(ep);\n\tstruct uniphier_pcie_ep_priv *priv = to_uniphier_pcie(pci);\n\tu32 val;\n\n\tval = FIELD_PREP(PCL_APP_VEN_MSI_TC_MASK, func_no)\n\t\t| FIELD_PREP(PCL_APP_VEN_MSI_VECTOR_MASK, interrupt_num - 1);\n\twritel(val, priv->base + PCL_APP_MSI0);\n\n\tval = readl(priv->base + PCL_APP_MSI1);\n\tval |= PCL_APP_MSI_REQ;\n\twritel(val, priv->base + PCL_APP_MSI1);\n\n\treturn 0;\n}\n\nstatic int uniphier_pcie_ep_raise_irq(struct dw_pcie_ep *ep, u8 func_no,\n\t\t\t\t      enum pci_epc_irq_type type,\n\t\t\t\t      u16 interrupt_num)\n{\n\tstruct dw_pcie *pci = to_dw_pcie_from_ep(ep);\n\n\tswitch (type) {\n\tcase PCI_EPC_IRQ_LEGACY:\n\t\treturn uniphier_pcie_ep_raise_legacy_irq(ep);\n\tcase PCI_EPC_IRQ_MSI:\n\t\treturn uniphier_pcie_ep_raise_msi_irq(ep, func_no,\n\t\t\t\t\t\t      interrupt_num);\n\tdefault:\n\t\tdev_err(pci->dev, \"UNKNOWN IRQ type (%d)\\n\", type);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct pci_epc_features*\nuniphier_pcie_get_features(struct dw_pcie_ep *ep)\n{\n\tstruct dw_pcie *pci = to_dw_pcie_from_ep(ep);\n\tstruct uniphier_pcie_ep_priv *priv = to_uniphier_pcie(pci);\n\n\treturn &priv->data->features;\n}\n\nstatic const struct dw_pcie_ep_ops uniphier_pcie_ep_ops = {\n\t.ep_init = uniphier_pcie_ep_init,\n\t.raise_irq = uniphier_pcie_ep_raise_irq,\n\t.get_features = uniphier_pcie_get_features,\n};\n\nstatic int uniphier_pcie_ep_enable(struct uniphier_pcie_ep_priv *priv)\n{\n\tint ret;\n\n\tret = clk_prepare_enable(priv->clk);\n\tif (ret)\n\t\treturn ret;\n\n\tret = clk_prepare_enable(priv->clk_gio);\n\tif (ret)\n\t\tgoto out_clk_disable;\n\n\tret = reset_control_deassert(priv->rst);\n\tif (ret)\n\t\tgoto out_clk_gio_disable;\n\n\tret = reset_control_deassert(priv->rst_gio);\n\tif (ret)\n\t\tgoto out_rst_assert;\n\n\tif (priv->data->init)\n\t\tpriv->data->init(priv);\n\n\tuniphier_pcie_phy_reset(priv, true);\n\n\tret = phy_init(priv->phy);\n\tif (ret)\n\t\tgoto out_rst_gio_assert;\n\n\tuniphier_pcie_phy_reset(priv, false);\n\n\tif (priv->data->wait) {\n\t\tret = priv->data->wait(priv);\n\t\tif (ret)\n\t\t\tgoto out_phy_exit;\n\t}\n\n\treturn 0;\n\nout_phy_exit:\n\tphy_exit(priv->phy);\nout_rst_gio_assert:\n\treset_control_assert(priv->rst_gio);\nout_rst_assert:\n\treset_control_assert(priv->rst);\nout_clk_gio_disable:\n\tclk_disable_unprepare(priv->clk_gio);\nout_clk_disable:\n\tclk_disable_unprepare(priv->clk);\n\n\treturn ret;\n}\n\nstatic const struct dw_pcie_ops dw_pcie_ops = {\n\t.start_link = uniphier_pcie_start_link,\n\t.stop_link = uniphier_pcie_stop_link,\n};\n\nstatic int uniphier_pcie_ep_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct uniphier_pcie_ep_priv *priv;\n\tint ret;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->data = of_device_get_match_data(dev);\n\tif (WARN_ON(!priv->data))\n\t\treturn -EINVAL;\n\n\tpriv->pci.dev = dev;\n\tpriv->pci.ops = &dw_pcie_ops;\n\n\tpriv->base = devm_platform_ioremap_resource_byname(pdev, \"link\");\n\tif (IS_ERR(priv->base))\n\t\treturn PTR_ERR(priv->base);\n\n\tif (priv->data->has_gio) {\n\t\tpriv->clk_gio = devm_clk_get(dev, \"gio\");\n\t\tif (IS_ERR(priv->clk_gio))\n\t\t\treturn PTR_ERR(priv->clk_gio);\n\n\t\tpriv->rst_gio = devm_reset_control_get_shared(dev, \"gio\");\n\t\tif (IS_ERR(priv->rst_gio))\n\t\t\treturn PTR_ERR(priv->rst_gio);\n\t}\n\n\tpriv->clk = devm_clk_get(dev, \"link\");\n\tif (IS_ERR(priv->clk))\n\t\treturn PTR_ERR(priv->clk);\n\n\tpriv->rst = devm_reset_control_get_shared(dev, \"link\");\n\tif (IS_ERR(priv->rst))\n\t\treturn PTR_ERR(priv->rst);\n\n\tpriv->phy = devm_phy_optional_get(dev, \"pcie-phy\");\n\tif (IS_ERR(priv->phy)) {\n\t\tret = PTR_ERR(priv->phy);\n\t\tdev_err(dev, \"Failed to get phy (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tplatform_set_drvdata(pdev, priv);\n\n\tret = uniphier_pcie_ep_enable(priv);\n\tif (ret)\n\t\treturn ret;\n\n\tpriv->pci.ep.ops = &uniphier_pcie_ep_ops;\n\treturn dw_pcie_ep_init(&priv->pci.ep);\n}\n\nstatic const struct uniphier_pcie_ep_soc_data uniphier_pro5_data = {\n\t.has_gio = true,\n\t.init = uniphier_pcie_pro5_init_ep,\n\t.wait = NULL,\n\t.features = {\n\t\t.linkup_notifier = false,\n\t\t.msi_capable = true,\n\t\t.msix_capable = false,\n\t\t.align = 1 << 16,\n\t\t.bar_fixed_64bit = BIT(BAR_0) | BIT(BAR_2) | BIT(BAR_4),\n\t\t.reserved_bar =  BIT(BAR_4),\n\t},\n};\n\nstatic const struct uniphier_pcie_ep_soc_data uniphier_nx1_data = {\n\t.has_gio = false,\n\t.init = uniphier_pcie_nx1_init_ep,\n\t.wait = uniphier_pcie_nx1_wait_ep,\n\t.features = {\n\t\t.linkup_notifier = false,\n\t\t.msi_capable = true,\n\t\t.msix_capable = false,\n\t\t.align = 1 << 12,\n\t\t.bar_fixed_64bit = BIT(BAR_0) | BIT(BAR_2) | BIT(BAR_4),\n\t},\n};\n\nstatic const struct of_device_id uniphier_pcie_ep_match[] = {\n\t{\n\t\t.compatible = \"socionext,uniphier-pro5-pcie-ep\",\n\t\t.data = &uniphier_pro5_data,\n\t},\n\t{\n\t\t.compatible = \"socionext,uniphier-nx1-pcie-ep\",\n\t\t.data = &uniphier_nx1_data,\n\t},\n\t{   },\n};\n\nstatic struct platform_driver uniphier_pcie_ep_driver = {\n\t.probe  = uniphier_pcie_ep_probe,\n\t.driver = {\n\t\t.name = \"uniphier-pcie-ep\",\n\t\t.of_match_table = uniphier_pcie_ep_match,\n\t\t.suppress_bind_attrs = true,\n\t},\n};\nbuiltin_platform_driver(uniphier_pcie_ep_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}