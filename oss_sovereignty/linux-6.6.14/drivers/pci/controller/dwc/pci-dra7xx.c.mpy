{
  "module_name": "pci-dra7xx.c",
  "hash_id": "7e9c089993f1611f86f6c5acaf55d92fd2ab22d16df0320a1ca4073fdd499633",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/controller/dwc/pci-dra7xx.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_gpio.h>\n#include <linux/of_pci.h>\n#include <linux/pci.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/resource.h>\n#include <linux/types.h>\n#include <linux/mfd/syscon.h>\n#include <linux/regmap.h>\n#include <linux/gpio/consumer.h>\n\n#include \"../../pci.h\"\n#include \"pcie-designware.h\"\n\n \n\n#define\tPCIECTRL_DRA7XX_CONF_IRQSTATUS_MAIN\t\t0x0024\n#define\tPCIECTRL_DRA7XX_CONF_IRQENABLE_SET_MAIN\t\t0x0028\n#define\tERR_SYS\t\t\t\t\t\tBIT(0)\n#define\tERR_FATAL\t\t\t\t\tBIT(1)\n#define\tERR_NONFATAL\t\t\t\t\tBIT(2)\n#define\tERR_COR\t\t\t\t\t\tBIT(3)\n#define\tERR_AXI\t\t\t\t\t\tBIT(4)\n#define\tERR_ECRC\t\t\t\t\tBIT(5)\n#define\tPME_TURN_OFF\t\t\t\t\tBIT(8)\n#define\tPME_TO_ACK\t\t\t\t\tBIT(9)\n#define\tPM_PME\t\t\t\t\t\tBIT(10)\n#define\tLINK_REQ_RST\t\t\t\t\tBIT(11)\n#define\tLINK_UP_EVT\t\t\t\t\tBIT(12)\n#define\tCFG_BME_EVT\t\t\t\t\tBIT(13)\n#define\tCFG_MSE_EVT\t\t\t\t\tBIT(14)\n#define\tINTERRUPTS (ERR_SYS | ERR_FATAL | ERR_NONFATAL | ERR_COR | ERR_AXI | \\\n\t\t\tERR_ECRC | PME_TURN_OFF | PME_TO_ACK | PM_PME | \\\n\t\t\tLINK_REQ_RST | LINK_UP_EVT | CFG_BME_EVT | CFG_MSE_EVT)\n\n#define\tPCIECTRL_DRA7XX_CONF_IRQSTATUS_MSI\t\t0x0034\n#define\tPCIECTRL_DRA7XX_CONF_IRQENABLE_SET_MSI\t\t0x0038\n#define\tINTA\t\t\t\t\t\tBIT(0)\n#define\tINTB\t\t\t\t\t\tBIT(1)\n#define\tINTC\t\t\t\t\t\tBIT(2)\n#define\tINTD\t\t\t\t\t\tBIT(3)\n#define\tMSI\t\t\t\t\t\tBIT(4)\n#define\tLEG_EP_INTERRUPTS (INTA | INTB | INTC | INTD)\n\n#define\tPCIECTRL_TI_CONF_DEVICE_TYPE\t\t\t0x0100\n#define\tDEVICE_TYPE_EP\t\t\t\t\t0x0\n#define\tDEVICE_TYPE_LEG_EP\t\t\t\t0x1\n#define\tDEVICE_TYPE_RC\t\t\t\t\t0x4\n\n#define\tPCIECTRL_DRA7XX_CONF_DEVICE_CMD\t\t\t0x0104\n#define\tLTSSM_EN\t\t\t\t\t0x1\n\n#define\tPCIECTRL_DRA7XX_CONF_PHY_CS\t\t\t0x010C\n#define\tLINK_UP\t\t\t\t\t\tBIT(16)\n#define\tDRA7XX_CPU_TO_BUS_ADDR\t\t\t\t0x0FFFFFFF\n\n#define\tPCIECTRL_TI_CONF_INTX_ASSERT\t\t\t0x0124\n#define\tPCIECTRL_TI_CONF_INTX_DEASSERT\t\t\t0x0128\n\n#define\tPCIECTRL_TI_CONF_MSI_XMT\t\t\t0x012c\n#define MSI_REQ_GRANT\t\t\t\t\tBIT(0)\n#define MSI_VECTOR_SHIFT\t\t\t\t7\n\n#define PCIE_1LANE_2LANE_SELECTION\t\t\tBIT(13)\n#define PCIE_B1C0_MODE_SEL\t\t\t\tBIT(2)\n#define PCIE_B0_B1_TSYNCEN\t\t\t\tBIT(0)\n\nstruct dra7xx_pcie {\n\tstruct dw_pcie\t\t*pci;\n\tvoid __iomem\t\t*base;\t\t \n\tint\t\t\tphy_count;\t \n\tstruct phy\t\t**phy;\n\tstruct irq_domain\t*irq_domain;\n\tstruct clk              *clk;\n\tenum dw_pcie_device_mode mode;\n};\n\nstruct dra7xx_pcie_of_data {\n\tenum dw_pcie_device_mode mode;\n\tu32 b1co_mode_sel_mask;\n};\n\n#define to_dra7xx_pcie(x)\tdev_get_drvdata((x)->dev)\n\nstatic inline u32 dra7xx_pcie_readl(struct dra7xx_pcie *pcie, u32 offset)\n{\n\treturn readl(pcie->base + offset);\n}\n\nstatic inline void dra7xx_pcie_writel(struct dra7xx_pcie *pcie, u32 offset,\n\t\t\t\t      u32 value)\n{\n\twritel(value, pcie->base + offset);\n}\n\nstatic u64 dra7xx_pcie_cpu_addr_fixup(struct dw_pcie *pci, u64 pci_addr)\n{\n\treturn pci_addr & DRA7XX_CPU_TO_BUS_ADDR;\n}\n\nstatic int dra7xx_pcie_link_up(struct dw_pcie *pci)\n{\n\tstruct dra7xx_pcie *dra7xx = to_dra7xx_pcie(pci);\n\tu32 reg = dra7xx_pcie_readl(dra7xx, PCIECTRL_DRA7XX_CONF_PHY_CS);\n\n\treturn !!(reg & LINK_UP);\n}\n\nstatic void dra7xx_pcie_stop_link(struct dw_pcie *pci)\n{\n\tstruct dra7xx_pcie *dra7xx = to_dra7xx_pcie(pci);\n\tu32 reg;\n\n\treg = dra7xx_pcie_readl(dra7xx, PCIECTRL_DRA7XX_CONF_DEVICE_CMD);\n\treg &= ~LTSSM_EN;\n\tdra7xx_pcie_writel(dra7xx, PCIECTRL_DRA7XX_CONF_DEVICE_CMD, reg);\n}\n\nstatic int dra7xx_pcie_establish_link(struct dw_pcie *pci)\n{\n\tstruct dra7xx_pcie *dra7xx = to_dra7xx_pcie(pci);\n\tstruct device *dev = pci->dev;\n\tu32 reg;\n\n\tif (dw_pcie_link_up(pci)) {\n\t\tdev_err(dev, \"link is already up\\n\");\n\t\treturn 0;\n\t}\n\n\treg = dra7xx_pcie_readl(dra7xx, PCIECTRL_DRA7XX_CONF_DEVICE_CMD);\n\treg |= LTSSM_EN;\n\tdra7xx_pcie_writel(dra7xx, PCIECTRL_DRA7XX_CONF_DEVICE_CMD, reg);\n\n\treturn 0;\n}\n\nstatic void dra7xx_pcie_enable_msi_interrupts(struct dra7xx_pcie *dra7xx)\n{\n\tdra7xx_pcie_writel(dra7xx, PCIECTRL_DRA7XX_CONF_IRQSTATUS_MSI,\n\t\t\t   LEG_EP_INTERRUPTS | MSI);\n\n\tdra7xx_pcie_writel(dra7xx,\n\t\t\t   PCIECTRL_DRA7XX_CONF_IRQENABLE_SET_MSI,\n\t\t\t   MSI | LEG_EP_INTERRUPTS);\n}\n\nstatic void dra7xx_pcie_enable_wrapper_interrupts(struct dra7xx_pcie *dra7xx)\n{\n\tdra7xx_pcie_writel(dra7xx, PCIECTRL_DRA7XX_CONF_IRQSTATUS_MAIN,\n\t\t\t   INTERRUPTS);\n\tdra7xx_pcie_writel(dra7xx, PCIECTRL_DRA7XX_CONF_IRQENABLE_SET_MAIN,\n\t\t\t   INTERRUPTS);\n}\n\nstatic void dra7xx_pcie_enable_interrupts(struct dra7xx_pcie *dra7xx)\n{\n\tdra7xx_pcie_enable_wrapper_interrupts(dra7xx);\n\tdra7xx_pcie_enable_msi_interrupts(dra7xx);\n}\n\nstatic int dra7xx_pcie_host_init(struct dw_pcie_rp *pp)\n{\n\tstruct dw_pcie *pci = to_dw_pcie_from_pp(pp);\n\tstruct dra7xx_pcie *dra7xx = to_dra7xx_pcie(pci);\n\n\tdra7xx_pcie_enable_interrupts(dra7xx);\n\n\treturn 0;\n}\n\nstatic int dra7xx_pcie_intx_map(struct irq_domain *domain, unsigned int irq,\n\t\t\t\tirq_hw_number_t hwirq)\n{\n\tirq_set_chip_and_handler(irq, &dummy_irq_chip, handle_simple_irq);\n\tirq_set_chip_data(irq, domain->host_data);\n\n\treturn 0;\n}\n\nstatic const struct irq_domain_ops intx_domain_ops = {\n\t.map = dra7xx_pcie_intx_map,\n\t.xlate = pci_irqd_intx_xlate,\n};\n\nstatic int dra7xx_pcie_handle_msi(struct dw_pcie_rp *pp, int index)\n{\n\tstruct dw_pcie *pci = to_dw_pcie_from_pp(pp);\n\tunsigned long val;\n\tint pos;\n\n\tval = dw_pcie_readl_dbi(pci, PCIE_MSI_INTR0_STATUS +\n\t\t\t\t   (index * MSI_REG_CTRL_BLOCK_SIZE));\n\tif (!val)\n\t\treturn 0;\n\n\tpos = find_first_bit(&val, MAX_MSI_IRQS_PER_CTRL);\n\twhile (pos != MAX_MSI_IRQS_PER_CTRL) {\n\t\tgeneric_handle_domain_irq(pp->irq_domain,\n\t\t\t\t\t  (index * MAX_MSI_IRQS_PER_CTRL) + pos);\n\t\tpos++;\n\t\tpos = find_next_bit(&val, MAX_MSI_IRQS_PER_CTRL, pos);\n\t}\n\n\treturn 1;\n}\n\nstatic void dra7xx_pcie_handle_msi_irq(struct dw_pcie_rp *pp)\n{\n\tstruct dw_pcie *pci = to_dw_pcie_from_pp(pp);\n\tint ret, i, count, num_ctrls;\n\n\tnum_ctrls = pp->num_vectors / MAX_MSI_IRQS_PER_CTRL;\n\n\t \n\tcount = 0;\n\tdo {\n\t\tret = 0;\n\n\t\tfor (i = 0; i < num_ctrls; i++)\n\t\t\tret |= dra7xx_pcie_handle_msi(pp, i);\n\t\tcount++;\n\t} while (ret && count <= 1000);\n\n\tif (count > 1000)\n\t\tdev_warn_ratelimited(pci->dev,\n\t\t\t\t     \"Too many MSI IRQs to handle\\n\");\n}\n\nstatic void dra7xx_pcie_msi_irq_handler(struct irq_desc *desc)\n{\n\tstruct irq_chip *chip = irq_desc_get_chip(desc);\n\tstruct dra7xx_pcie *dra7xx;\n\tstruct dw_pcie_rp *pp;\n\tstruct dw_pcie *pci;\n\tunsigned long reg;\n\tu32 bit;\n\n\tchained_irq_enter(chip, desc);\n\n\tpp = irq_desc_get_handler_data(desc);\n\tpci = to_dw_pcie_from_pp(pp);\n\tdra7xx = to_dra7xx_pcie(pci);\n\n\treg = dra7xx_pcie_readl(dra7xx, PCIECTRL_DRA7XX_CONF_IRQSTATUS_MSI);\n\tdra7xx_pcie_writel(dra7xx, PCIECTRL_DRA7XX_CONF_IRQSTATUS_MSI, reg);\n\n\tswitch (reg) {\n\tcase MSI:\n\t\tdra7xx_pcie_handle_msi_irq(pp);\n\t\tbreak;\n\tcase INTA:\n\tcase INTB:\n\tcase INTC:\n\tcase INTD:\n\t\tfor_each_set_bit(bit, &reg, PCI_NUM_INTX)\n\t\t\tgeneric_handle_domain_irq(dra7xx->irq_domain, bit);\n\t\tbreak;\n\t}\n\n\tchained_irq_exit(chip, desc);\n}\n\nstatic irqreturn_t dra7xx_pcie_irq_handler(int irq, void *arg)\n{\n\tstruct dra7xx_pcie *dra7xx = arg;\n\tstruct dw_pcie *pci = dra7xx->pci;\n\tstruct device *dev = pci->dev;\n\tstruct dw_pcie_ep *ep = &pci->ep;\n\tu32 reg;\n\n\treg = dra7xx_pcie_readl(dra7xx, PCIECTRL_DRA7XX_CONF_IRQSTATUS_MAIN);\n\n\tif (reg & ERR_SYS)\n\t\tdev_dbg(dev, \"System Error\\n\");\n\n\tif (reg & ERR_FATAL)\n\t\tdev_dbg(dev, \"Fatal Error\\n\");\n\n\tif (reg & ERR_NONFATAL)\n\t\tdev_dbg(dev, \"Non Fatal Error\\n\");\n\n\tif (reg & ERR_COR)\n\t\tdev_dbg(dev, \"Correctable Error\\n\");\n\n\tif (reg & ERR_AXI)\n\t\tdev_dbg(dev, \"AXI tag lookup fatal Error\\n\");\n\n\tif (reg & ERR_ECRC)\n\t\tdev_dbg(dev, \"ECRC Error\\n\");\n\n\tif (reg & PME_TURN_OFF)\n\t\tdev_dbg(dev,\n\t\t\t\"Power Management Event Turn-Off message received\\n\");\n\n\tif (reg & PME_TO_ACK)\n\t\tdev_dbg(dev,\n\t\t\t\"Power Management Turn-Off Ack message received\\n\");\n\n\tif (reg & PM_PME)\n\t\tdev_dbg(dev, \"PM Power Management Event message received\\n\");\n\n\tif (reg & LINK_REQ_RST)\n\t\tdev_dbg(dev, \"Link Request Reset\\n\");\n\n\tif (reg & LINK_UP_EVT) {\n\t\tif (dra7xx->mode == DW_PCIE_EP_TYPE)\n\t\t\tdw_pcie_ep_linkup(ep);\n\t\tdev_dbg(dev, \"Link-up state change\\n\");\n\t}\n\n\tif (reg & CFG_BME_EVT)\n\t\tdev_dbg(dev, \"CFG 'Bus Master Enable' change\\n\");\n\n\tif (reg & CFG_MSE_EVT)\n\t\tdev_dbg(dev, \"CFG 'Memory Space Enable' change\\n\");\n\n\tdra7xx_pcie_writel(dra7xx, PCIECTRL_DRA7XX_CONF_IRQSTATUS_MAIN, reg);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int dra7xx_pcie_init_irq_domain(struct dw_pcie_rp *pp)\n{\n\tstruct dw_pcie *pci = to_dw_pcie_from_pp(pp);\n\tstruct device *dev = pci->dev;\n\tstruct dra7xx_pcie *dra7xx = to_dra7xx_pcie(pci);\n\tstruct device_node *node = dev->of_node;\n\tstruct device_node *pcie_intc_node =  of_get_next_child(node, NULL);\n\n\tif (!pcie_intc_node) {\n\t\tdev_err(dev, \"No PCIe Intc node found\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tirq_set_chained_handler_and_data(pp->irq, dra7xx_pcie_msi_irq_handler,\n\t\t\t\t\t pp);\n\tdra7xx->irq_domain = irq_domain_add_linear(pcie_intc_node, PCI_NUM_INTX,\n\t\t\t\t\t\t   &intx_domain_ops, pp);\n\tof_node_put(pcie_intc_node);\n\tif (!dra7xx->irq_domain) {\n\t\tdev_err(dev, \"Failed to get a INTx IRQ domain\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct dw_pcie_host_ops dra7xx_pcie_host_ops = {\n\t.host_init = dra7xx_pcie_host_init,\n};\n\nstatic void dra7xx_pcie_ep_init(struct dw_pcie_ep *ep)\n{\n\tstruct dw_pcie *pci = to_dw_pcie_from_ep(ep);\n\tstruct dra7xx_pcie *dra7xx = to_dra7xx_pcie(pci);\n\tenum pci_barno bar;\n\n\tfor (bar = 0; bar < PCI_STD_NUM_BARS; bar++)\n\t\tdw_pcie_ep_reset_bar(pci, bar);\n\n\tdra7xx_pcie_enable_wrapper_interrupts(dra7xx);\n}\n\nstatic void dra7xx_pcie_raise_legacy_irq(struct dra7xx_pcie *dra7xx)\n{\n\tdra7xx_pcie_writel(dra7xx, PCIECTRL_TI_CONF_INTX_ASSERT, 0x1);\n\tmdelay(1);\n\tdra7xx_pcie_writel(dra7xx, PCIECTRL_TI_CONF_INTX_DEASSERT, 0x1);\n}\n\nstatic void dra7xx_pcie_raise_msi_irq(struct dra7xx_pcie *dra7xx,\n\t\t\t\t      u8 interrupt_num)\n{\n\tu32 reg;\n\n\treg = (interrupt_num - 1) << MSI_VECTOR_SHIFT;\n\treg |= MSI_REQ_GRANT;\n\tdra7xx_pcie_writel(dra7xx, PCIECTRL_TI_CONF_MSI_XMT, reg);\n}\n\nstatic int dra7xx_pcie_raise_irq(struct dw_pcie_ep *ep, u8 func_no,\n\t\t\t\t enum pci_epc_irq_type type, u16 interrupt_num)\n{\n\tstruct dw_pcie *pci = to_dw_pcie_from_ep(ep);\n\tstruct dra7xx_pcie *dra7xx = to_dra7xx_pcie(pci);\n\n\tswitch (type) {\n\tcase PCI_EPC_IRQ_LEGACY:\n\t\tdra7xx_pcie_raise_legacy_irq(dra7xx);\n\t\tbreak;\n\tcase PCI_EPC_IRQ_MSI:\n\t\tdra7xx_pcie_raise_msi_irq(dra7xx, interrupt_num);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(pci->dev, \"UNKNOWN IRQ type\\n\");\n\t}\n\n\treturn 0;\n}\n\nstatic const struct pci_epc_features dra7xx_pcie_epc_features = {\n\t.linkup_notifier = true,\n\t.msi_capable = true,\n\t.msix_capable = false,\n};\n\nstatic const struct pci_epc_features*\ndra7xx_pcie_get_features(struct dw_pcie_ep *ep)\n{\n\treturn &dra7xx_pcie_epc_features;\n}\n\nstatic const struct dw_pcie_ep_ops pcie_ep_ops = {\n\t.ep_init = dra7xx_pcie_ep_init,\n\t.raise_irq = dra7xx_pcie_raise_irq,\n\t.get_features = dra7xx_pcie_get_features,\n};\n\nstatic int dra7xx_add_pcie_ep(struct dra7xx_pcie *dra7xx,\n\t\t\t      struct platform_device *pdev)\n{\n\tint ret;\n\tstruct dw_pcie_ep *ep;\n\tstruct device *dev = &pdev->dev;\n\tstruct dw_pcie *pci = dra7xx->pci;\n\n\tep = &pci->ep;\n\tep->ops = &pcie_ep_ops;\n\n\tpci->dbi_base = devm_platform_ioremap_resource_byname(pdev, \"ep_dbics\");\n\tif (IS_ERR(pci->dbi_base))\n\t\treturn PTR_ERR(pci->dbi_base);\n\n\tpci->dbi_base2 =\n\t\tdevm_platform_ioremap_resource_byname(pdev, \"ep_dbics2\");\n\tif (IS_ERR(pci->dbi_base2))\n\t\treturn PTR_ERR(pci->dbi_base2);\n\n\tret = dw_pcie_ep_init(ep);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to initialize endpoint\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int dra7xx_add_pcie_port(struct dra7xx_pcie *dra7xx,\n\t\t\t\tstruct platform_device *pdev)\n{\n\tint ret;\n\tstruct dw_pcie *pci = dra7xx->pci;\n\tstruct dw_pcie_rp *pp = &pci->pp;\n\tstruct device *dev = pci->dev;\n\n\tpp->irq = platform_get_irq(pdev, 1);\n\tif (pp->irq < 0)\n\t\treturn pp->irq;\n\n\t \n\tpp->msi_irq[0] = -ENODEV;\n\n\tret = dra7xx_pcie_init_irq_domain(pp);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tpci->dbi_base = devm_platform_ioremap_resource_byname(pdev, \"rc_dbics\");\n\tif (IS_ERR(pci->dbi_base))\n\t\treturn PTR_ERR(pci->dbi_base);\n\n\tpp->ops = &dra7xx_pcie_host_ops;\n\n\tret = dw_pcie_host_init(pp);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to initialize host\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct dw_pcie_ops dw_pcie_ops = {\n\t.cpu_addr_fixup = dra7xx_pcie_cpu_addr_fixup,\n\t.start_link = dra7xx_pcie_establish_link,\n\t.stop_link = dra7xx_pcie_stop_link,\n\t.link_up = dra7xx_pcie_link_up,\n};\n\nstatic void dra7xx_pcie_disable_phy(struct dra7xx_pcie *dra7xx)\n{\n\tint phy_count = dra7xx->phy_count;\n\n\twhile (phy_count--) {\n\t\tphy_power_off(dra7xx->phy[phy_count]);\n\t\tphy_exit(dra7xx->phy[phy_count]);\n\t}\n}\n\nstatic int dra7xx_pcie_enable_phy(struct dra7xx_pcie *dra7xx)\n{\n\tint phy_count = dra7xx->phy_count;\n\tint ret;\n\tint i;\n\n\tfor (i = 0; i < phy_count; i++) {\n\t\tret = phy_set_mode(dra7xx->phy[i], PHY_MODE_PCIE);\n\t\tif (ret < 0)\n\t\t\tgoto err_phy;\n\n\t\tret = phy_init(dra7xx->phy[i]);\n\t\tif (ret < 0)\n\t\t\tgoto err_phy;\n\n\t\tret = phy_power_on(dra7xx->phy[i]);\n\t\tif (ret < 0) {\n\t\t\tphy_exit(dra7xx->phy[i]);\n\t\t\tgoto err_phy;\n\t\t}\n\t}\n\n\treturn 0;\n\nerr_phy:\n\twhile (--i >= 0) {\n\t\tphy_power_off(dra7xx->phy[i]);\n\t\tphy_exit(dra7xx->phy[i]);\n\t}\n\n\treturn ret;\n}\n\nstatic const struct dra7xx_pcie_of_data dra7xx_pcie_rc_of_data = {\n\t.mode = DW_PCIE_RC_TYPE,\n};\n\nstatic const struct dra7xx_pcie_of_data dra7xx_pcie_ep_of_data = {\n\t.mode = DW_PCIE_EP_TYPE,\n};\n\nstatic const struct dra7xx_pcie_of_data dra746_pcie_rc_of_data = {\n\t.b1co_mode_sel_mask = BIT(2),\n\t.mode = DW_PCIE_RC_TYPE,\n};\n\nstatic const struct dra7xx_pcie_of_data dra726_pcie_rc_of_data = {\n\t.b1co_mode_sel_mask = GENMASK(3, 2),\n\t.mode = DW_PCIE_RC_TYPE,\n};\n\nstatic const struct dra7xx_pcie_of_data dra746_pcie_ep_of_data = {\n\t.b1co_mode_sel_mask = BIT(2),\n\t.mode = DW_PCIE_EP_TYPE,\n};\n\nstatic const struct dra7xx_pcie_of_data dra726_pcie_ep_of_data = {\n\t.b1co_mode_sel_mask = GENMASK(3, 2),\n\t.mode = DW_PCIE_EP_TYPE,\n};\n\nstatic const struct of_device_id of_dra7xx_pcie_match[] = {\n\t{\n\t\t.compatible = \"ti,dra7-pcie\",\n\t\t.data = &dra7xx_pcie_rc_of_data,\n\t},\n\t{\n\t\t.compatible = \"ti,dra7-pcie-ep\",\n\t\t.data = &dra7xx_pcie_ep_of_data,\n\t},\n\t{\n\t\t.compatible = \"ti,dra746-pcie-rc\",\n\t\t.data = &dra746_pcie_rc_of_data,\n\t},\n\t{\n\t\t.compatible = \"ti,dra726-pcie-rc\",\n\t\t.data = &dra726_pcie_rc_of_data,\n\t},\n\t{\n\t\t.compatible = \"ti,dra746-pcie-ep\",\n\t\t.data = &dra746_pcie_ep_of_data,\n\t},\n\t{\n\t\t.compatible = \"ti,dra726-pcie-ep\",\n\t\t.data = &dra726_pcie_ep_of_data,\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, of_dra7xx_pcie_match);\n\n \nstatic int dra7xx_pcie_unaligned_memaccess(struct device *dev)\n{\n\tint ret;\n\tstruct device_node *np = dev->of_node;\n\tstruct of_phandle_args args;\n\tstruct regmap *regmap;\n\n\tregmap = syscon_regmap_lookup_by_phandle(np,\n\t\t\t\t\t\t \"ti,syscon-unaligned-access\");\n\tif (IS_ERR(regmap)) {\n\t\tdev_dbg(dev, \"can't get ti,syscon-unaligned-access\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = of_parse_phandle_with_fixed_args(np, \"ti,syscon-unaligned-access\",\n\t\t\t\t\t       2, 0, &args);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to parse ti,syscon-unaligned-access\\n\");\n\t\treturn ret;\n\t}\n\n\tret = regmap_update_bits(regmap, args.args[0], args.args[1],\n\t\t\t\t args.args[1]);\n\tif (ret)\n\t\tdev_err(dev, \"failed to enable unaligned access\\n\");\n\n\tof_node_put(args.np);\n\n\treturn ret;\n}\n\nstatic int dra7xx_pcie_configure_two_lane(struct device *dev,\n\t\t\t\t\t  u32 b1co_mode_sel_mask)\n{\n\tstruct device_node *np = dev->of_node;\n\tstruct regmap *pcie_syscon;\n\tunsigned int pcie_reg;\n\tu32 mask;\n\tu32 val;\n\n\tpcie_syscon = syscon_regmap_lookup_by_phandle(np, \"ti,syscon-lane-sel\");\n\tif (IS_ERR(pcie_syscon)) {\n\t\tdev_err(dev, \"unable to get ti,syscon-lane-sel\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (of_property_read_u32_index(np, \"ti,syscon-lane-sel\", 1,\n\t\t\t\t       &pcie_reg)) {\n\t\tdev_err(dev, \"couldn't get lane selection reg offset\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmask = b1co_mode_sel_mask | PCIE_B0_B1_TSYNCEN;\n\tval = PCIE_B1C0_MODE_SEL | PCIE_B0_B1_TSYNCEN;\n\tregmap_update_bits(pcie_syscon, pcie_reg, mask, val);\n\n\treturn 0;\n}\n\nstatic int dra7xx_pcie_probe(struct platform_device *pdev)\n{\n\tu32 reg;\n\tint ret;\n\tint irq;\n\tint i;\n\tint phy_count;\n\tstruct phy **phy;\n\tstruct device_link **link;\n\tvoid __iomem *base;\n\tstruct dw_pcie *pci;\n\tstruct dra7xx_pcie *dra7xx;\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tchar name[10];\n\tstruct gpio_desc *reset;\n\tconst struct dra7xx_pcie_of_data *data;\n\tenum dw_pcie_device_mode mode;\n\tu32 b1co_mode_sel_mask;\n\n\tdata = of_device_get_match_data(dev);\n\tif (!data)\n\t\treturn -EINVAL;\n\n\tmode = (enum dw_pcie_device_mode)data->mode;\n\tb1co_mode_sel_mask = data->b1co_mode_sel_mask;\n\n\tdra7xx = devm_kzalloc(dev, sizeof(*dra7xx), GFP_KERNEL);\n\tif (!dra7xx)\n\t\treturn -ENOMEM;\n\n\tpci = devm_kzalloc(dev, sizeof(*pci), GFP_KERNEL);\n\tif (!pci)\n\t\treturn -ENOMEM;\n\n\tpci->dev = dev;\n\tpci->ops = &dw_pcie_ops;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tbase = devm_platform_ioremap_resource_byname(pdev, \"ti_conf\");\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\tphy_count = of_property_count_strings(np, \"phy-names\");\n\tif (phy_count < 0) {\n\t\tdev_err(dev, \"unable to find the strings\\n\");\n\t\treturn phy_count;\n\t}\n\n\tphy = devm_kcalloc(dev, phy_count, sizeof(*phy), GFP_KERNEL);\n\tif (!phy)\n\t\treturn -ENOMEM;\n\n\tlink = devm_kcalloc(dev, phy_count, sizeof(*link), GFP_KERNEL);\n\tif (!link)\n\t\treturn -ENOMEM;\n\n\tdra7xx->clk = devm_clk_get_optional(dev, NULL);\n\tif (IS_ERR(dra7xx->clk))\n\t\treturn dev_err_probe(dev, PTR_ERR(dra7xx->clk),\n\t\t\t\t     \"clock request failed\");\n\n\tret = clk_prepare_enable(dra7xx->clk);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < phy_count; i++) {\n\t\tsnprintf(name, sizeof(name), \"pcie-phy%d\", i);\n\t\tphy[i] = devm_phy_get(dev, name);\n\t\tif (IS_ERR(phy[i]))\n\t\t\treturn PTR_ERR(phy[i]);\n\n\t\tlink[i] = device_link_add(dev, &phy[i]->dev, DL_FLAG_STATELESS);\n\t\tif (!link[i]) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_link;\n\t\t}\n\t}\n\n\tdra7xx->base = base;\n\tdra7xx->phy = phy;\n\tdra7xx->pci = pci;\n\tdra7xx->phy_count = phy_count;\n\n\tif (phy_count == 2) {\n\t\tret = dra7xx_pcie_configure_two_lane(dev, b1co_mode_sel_mask);\n\t\tif (ret < 0)\n\t\t\tdra7xx->phy_count = 1;  \n\t}\n\n\tret = dra7xx_pcie_enable_phy(dra7xx);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to enable phy\\n\");\n\t\treturn ret;\n\t}\n\n\tplatform_set_drvdata(pdev, dra7xx);\n\n\tpm_runtime_enable(dev);\n\tret = pm_runtime_get_sync(dev);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"pm_runtime_get_sync failed\\n\");\n\t\tgoto err_get_sync;\n\t}\n\n\treset = devm_gpiod_get_optional(dev, NULL, GPIOD_OUT_HIGH);\n\tif (IS_ERR(reset)) {\n\t\tret = PTR_ERR(reset);\n\t\tdev_err(&pdev->dev, \"gpio request failed, ret %d\\n\", ret);\n\t\tgoto err_gpio;\n\t}\n\n\treg = dra7xx_pcie_readl(dra7xx, PCIECTRL_DRA7XX_CONF_DEVICE_CMD);\n\treg &= ~LTSSM_EN;\n\tdra7xx_pcie_writel(dra7xx, PCIECTRL_DRA7XX_CONF_DEVICE_CMD, reg);\n\n\tswitch (mode) {\n\tcase DW_PCIE_RC_TYPE:\n\t\tif (!IS_ENABLED(CONFIG_PCI_DRA7XX_HOST)) {\n\t\t\tret = -ENODEV;\n\t\t\tgoto err_gpio;\n\t\t}\n\n\t\tdra7xx_pcie_writel(dra7xx, PCIECTRL_TI_CONF_DEVICE_TYPE,\n\t\t\t\t   DEVICE_TYPE_RC);\n\n\t\tret = dra7xx_pcie_unaligned_memaccess(dev);\n\t\tif (ret)\n\t\t\tdev_err(dev, \"WA for Errata i870 not applied\\n\");\n\n\t\tret = dra7xx_add_pcie_port(dra7xx, pdev);\n\t\tif (ret < 0)\n\t\t\tgoto err_gpio;\n\t\tbreak;\n\tcase DW_PCIE_EP_TYPE:\n\t\tif (!IS_ENABLED(CONFIG_PCI_DRA7XX_EP)) {\n\t\t\tret = -ENODEV;\n\t\t\tgoto err_gpio;\n\t\t}\n\n\t\tdra7xx_pcie_writel(dra7xx, PCIECTRL_TI_CONF_DEVICE_TYPE,\n\t\t\t\t   DEVICE_TYPE_EP);\n\n\t\tret = dra7xx_pcie_unaligned_memaccess(dev);\n\t\tif (ret)\n\t\t\tgoto err_gpio;\n\n\t\tret = dra7xx_add_pcie_ep(dra7xx, pdev);\n\t\tif (ret < 0)\n\t\t\tgoto err_gpio;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"INVALID device type %d\\n\", mode);\n\t}\n\tdra7xx->mode = mode;\n\n\tret = devm_request_threaded_irq(dev, irq, NULL, dra7xx_pcie_irq_handler,\n\t\t\t       IRQF_SHARED, \"dra7xx-pcie-main\", dra7xx);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to request irq\\n\");\n\t\tgoto err_gpio;\n\t}\n\n\treturn 0;\n\nerr_gpio:\nerr_get_sync:\n\tpm_runtime_put(dev);\n\tpm_runtime_disable(dev);\n\tdra7xx_pcie_disable_phy(dra7xx);\n\nerr_link:\n\twhile (--i >= 0)\n\t\tdevice_link_del(link[i]);\n\n\treturn ret;\n}\n\nstatic int dra7xx_pcie_suspend(struct device *dev)\n{\n\tstruct dra7xx_pcie *dra7xx = dev_get_drvdata(dev);\n\tstruct dw_pcie *pci = dra7xx->pci;\n\tu32 val;\n\n\tif (dra7xx->mode != DW_PCIE_RC_TYPE)\n\t\treturn 0;\n\n\t \n\tval = dw_pcie_readl_dbi(pci, PCI_COMMAND);\n\tval &= ~PCI_COMMAND_MEMORY;\n\tdw_pcie_writel_dbi(pci, PCI_COMMAND, val);\n\n\treturn 0;\n}\n\nstatic int dra7xx_pcie_resume(struct device *dev)\n{\n\tstruct dra7xx_pcie *dra7xx = dev_get_drvdata(dev);\n\tstruct dw_pcie *pci = dra7xx->pci;\n\tu32 val;\n\n\tif (dra7xx->mode != DW_PCIE_RC_TYPE)\n\t\treturn 0;\n\n\t \n\tval = dw_pcie_readl_dbi(pci, PCI_COMMAND);\n\tval |= PCI_COMMAND_MEMORY;\n\tdw_pcie_writel_dbi(pci, PCI_COMMAND, val);\n\n\treturn 0;\n}\n\nstatic int dra7xx_pcie_suspend_noirq(struct device *dev)\n{\n\tstruct dra7xx_pcie *dra7xx = dev_get_drvdata(dev);\n\n\tdra7xx_pcie_disable_phy(dra7xx);\n\n\treturn 0;\n}\n\nstatic int dra7xx_pcie_resume_noirq(struct device *dev)\n{\n\tstruct dra7xx_pcie *dra7xx = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = dra7xx_pcie_enable_phy(dra7xx);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to enable phy\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void dra7xx_pcie_shutdown(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct dra7xx_pcie *dra7xx = dev_get_drvdata(dev);\n\tint ret;\n\n\tdra7xx_pcie_stop_link(dra7xx->pci);\n\n\tret = pm_runtime_put_sync(dev);\n\tif (ret < 0)\n\t\tdev_dbg(dev, \"pm_runtime_put_sync failed\\n\");\n\n\tpm_runtime_disable(dev);\n\tdra7xx_pcie_disable_phy(dra7xx);\n\n\tclk_disable_unprepare(dra7xx->clk);\n}\n\nstatic const struct dev_pm_ops dra7xx_pcie_pm_ops = {\n\tSYSTEM_SLEEP_PM_OPS(dra7xx_pcie_suspend, dra7xx_pcie_resume)\n\tNOIRQ_SYSTEM_SLEEP_PM_OPS(dra7xx_pcie_suspend_noirq,\n\t\t\t\t  dra7xx_pcie_resume_noirq)\n};\n\nstatic struct platform_driver dra7xx_pcie_driver = {\n\t.probe = dra7xx_pcie_probe,\n\t.driver = {\n\t\t.name\t= \"dra7-pcie\",\n\t\t.of_match_table = of_dra7xx_pcie_match,\n\t\t.suppress_bind_attrs = true,\n\t\t.pm\t= &dra7xx_pcie_pm_ops,\n\t},\n\t.shutdown = dra7xx_pcie_shutdown,\n};\nmodule_platform_driver(dra7xx_pcie_driver);\n\nMODULE_AUTHOR(\"Kishon Vijay Abraham I <kishon@ti.com>\");\nMODULE_DESCRIPTION(\"PCIe controller driver for TI DRA7xx SoCs\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}