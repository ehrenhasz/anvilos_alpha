{
  "module_name": "pci-meson.c",
  "hash_id": "849f1c62f3a958461f40c9f53bf57763e3196dcbbe02576f24abf9a971c550a2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/controller/dwc/pci-meson.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/of_gpio.h>\n#include <linux/pci.h>\n#include <linux/platform_device.h>\n#include <linux/reset.h>\n#include <linux/resource.h>\n#include <linux/types.h>\n#include <linux/phy/phy.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n\n#include \"pcie-designware.h\"\n\n#define to_meson_pcie(x) dev_get_drvdata((x)->dev)\n\n#define PCIE_CAP_MAX_PAYLOAD_SIZE(x)\t((x) << 5)\n#define PCIE_CAP_MAX_READ_REQ_SIZE(x)\t((x) << 12)\n\n \n#define PCIE_CFG0\t\t\t0x0\n#define APP_LTSSM_ENABLE\t\tBIT(7)\n\n#define PCIE_CFG_STATUS12\t\t0x30\n#define IS_SMLH_LINK_UP(x)\t\t((x) & (1 << 6))\n#define IS_RDLH_LINK_UP(x)\t\t((x) & (1 << 16))\n#define IS_LTSSM_UP(x)\t\t\t((((x) >> 10) & 0x1f) == 0x11)\n\n#define PCIE_CFG_STATUS17\t\t0x44\n#define PM_CURRENT_STATE(x)\t\t(((x) >> 7) & 0x1)\n\n#define WAIT_LINKUP_TIMEOUT\t\t4000\n#define PORT_CLK_RATE\t\t\t100000000UL\n#define MAX_PAYLOAD_SIZE\t\t256\n#define MAX_READ_REQ_SIZE\t\t256\n#define PCIE_RESET_DELAY\t\t500\n#define PCIE_SHARED_RESET\t\t1\n#define PCIE_NORMAL_RESET\t\t0\n\nenum pcie_data_rate {\n\tPCIE_GEN1,\n\tPCIE_GEN2,\n\tPCIE_GEN3,\n\tPCIE_GEN4\n};\n\nstruct meson_pcie_clk_res {\n\tstruct clk *clk;\n\tstruct clk *port_clk;\n\tstruct clk *general_clk;\n};\n\nstruct meson_pcie_rc_reset {\n\tstruct reset_control *port;\n\tstruct reset_control *apb;\n};\n\nstruct meson_pcie {\n\tstruct dw_pcie pci;\n\tvoid __iomem *cfg_base;\n\tstruct meson_pcie_clk_res clk_res;\n\tstruct meson_pcie_rc_reset mrst;\n\tstruct gpio_desc *reset_gpio;\n\tstruct phy *phy;\n};\n\nstatic struct reset_control *meson_pcie_get_reset(struct meson_pcie *mp,\n\t\t\t\t\t\t  const char *id,\n\t\t\t\t\t\t  u32 reset_type)\n{\n\tstruct device *dev = mp->pci.dev;\n\tstruct reset_control *reset;\n\n\tif (reset_type == PCIE_SHARED_RESET)\n\t\treset = devm_reset_control_get_shared(dev, id);\n\telse\n\t\treset = devm_reset_control_get(dev, id);\n\n\treturn reset;\n}\n\nstatic int meson_pcie_get_resets(struct meson_pcie *mp)\n{\n\tstruct meson_pcie_rc_reset *mrst = &mp->mrst;\n\n\tmrst->port = meson_pcie_get_reset(mp, \"port\", PCIE_NORMAL_RESET);\n\tif (IS_ERR(mrst->port))\n\t\treturn PTR_ERR(mrst->port);\n\treset_control_deassert(mrst->port);\n\n\tmrst->apb = meson_pcie_get_reset(mp, \"apb\", PCIE_SHARED_RESET);\n\tif (IS_ERR(mrst->apb))\n\t\treturn PTR_ERR(mrst->apb);\n\treset_control_deassert(mrst->apb);\n\n\treturn 0;\n}\n\nstatic int meson_pcie_get_mems(struct platform_device *pdev,\n\t\t\t       struct meson_pcie *mp)\n{\n\tstruct dw_pcie *pci = &mp->pci;\n\n\tpci->dbi_base = devm_platform_ioremap_resource_byname(pdev, \"elbi\");\n\tif (IS_ERR(pci->dbi_base))\n\t\treturn PTR_ERR(pci->dbi_base);\n\n\tmp->cfg_base = devm_platform_ioremap_resource_byname(pdev, \"cfg\");\n\tif (IS_ERR(mp->cfg_base))\n\t\treturn PTR_ERR(mp->cfg_base);\n\n\treturn 0;\n}\n\nstatic int meson_pcie_power_on(struct meson_pcie *mp)\n{\n\tint ret = 0;\n\n\tret = phy_init(mp->phy);\n\tif (ret)\n\t\treturn ret;\n\n\tret = phy_power_on(mp->phy);\n\tif (ret) {\n\t\tphy_exit(mp->phy);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void meson_pcie_power_off(struct meson_pcie *mp)\n{\n\tphy_power_off(mp->phy);\n\tphy_exit(mp->phy);\n}\n\nstatic int meson_pcie_reset(struct meson_pcie *mp)\n{\n\tstruct meson_pcie_rc_reset *mrst = &mp->mrst;\n\tint ret = 0;\n\n\tret = phy_reset(mp->phy);\n\tif (ret)\n\t\treturn ret;\n\n\treset_control_assert(mrst->port);\n\treset_control_assert(mrst->apb);\n\tudelay(PCIE_RESET_DELAY);\n\treset_control_deassert(mrst->port);\n\treset_control_deassert(mrst->apb);\n\tudelay(PCIE_RESET_DELAY);\n\n\treturn 0;\n}\n\nstatic inline void meson_pcie_disable_clock(void *data)\n{\n\tstruct clk *clk = data;\n\n\tclk_disable_unprepare(clk);\n}\n\nstatic inline struct clk *meson_pcie_probe_clock(struct device *dev,\n\t\t\t\t\t\t const char *id, u64 rate)\n{\n\tstruct clk *clk;\n\tint ret;\n\n\tclk = devm_clk_get(dev, id);\n\tif (IS_ERR(clk))\n\t\treturn clk;\n\n\tif (rate) {\n\t\tret = clk_set_rate(clk, rate);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"set clk rate failed, ret = %d\\n\", ret);\n\t\t\treturn ERR_PTR(ret);\n\t\t}\n\t}\n\n\tret = clk_prepare_enable(clk);\n\tif (ret) {\n\t\tdev_err(dev, \"couldn't enable clk\\n\");\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tdevm_add_action_or_reset(dev, meson_pcie_disable_clock, clk);\n\n\treturn clk;\n}\n\nstatic int meson_pcie_probe_clocks(struct meson_pcie *mp)\n{\n\tstruct device *dev = mp->pci.dev;\n\tstruct meson_pcie_clk_res *res = &mp->clk_res;\n\n\tres->port_clk = meson_pcie_probe_clock(dev, \"port\", PORT_CLK_RATE);\n\tif (IS_ERR(res->port_clk))\n\t\treturn PTR_ERR(res->port_clk);\n\n\tres->general_clk = meson_pcie_probe_clock(dev, \"general\", 0);\n\tif (IS_ERR(res->general_clk))\n\t\treturn PTR_ERR(res->general_clk);\n\n\tres->clk = meson_pcie_probe_clock(dev, \"pclk\", 0);\n\tif (IS_ERR(res->clk))\n\t\treturn PTR_ERR(res->clk);\n\n\treturn 0;\n}\n\nstatic inline u32 meson_cfg_readl(struct meson_pcie *mp, u32 reg)\n{\n\treturn readl(mp->cfg_base + reg);\n}\n\nstatic inline void meson_cfg_writel(struct meson_pcie *mp, u32 val, u32 reg)\n{\n\twritel(val, mp->cfg_base + reg);\n}\n\nstatic void meson_pcie_assert_reset(struct meson_pcie *mp)\n{\n\tgpiod_set_value_cansleep(mp->reset_gpio, 1);\n\tudelay(500);\n\tgpiod_set_value_cansleep(mp->reset_gpio, 0);\n}\n\nstatic void meson_pcie_ltssm_enable(struct meson_pcie *mp)\n{\n\tu32 val;\n\n\tval = meson_cfg_readl(mp, PCIE_CFG0);\n\tval |= APP_LTSSM_ENABLE;\n\tmeson_cfg_writel(mp, val, PCIE_CFG0);\n}\n\nstatic int meson_size_to_payload(struct meson_pcie *mp, int size)\n{\n\tstruct device *dev = mp->pci.dev;\n\n\t \n\tif (!is_power_of_2(size) || size < 128 || size > 4096) {\n\t\tdev_warn(dev, \"payload size %d, set to default 256\\n\", size);\n\t\treturn 1;\n\t}\n\n\treturn fls(size) - 8;\n}\n\nstatic void meson_set_max_payload(struct meson_pcie *mp, int size)\n{\n\tstruct dw_pcie *pci = &mp->pci;\n\tu32 val;\n\tu16 offset = dw_pcie_find_capability(pci, PCI_CAP_ID_EXP);\n\tint max_payload_size = meson_size_to_payload(mp, size);\n\n\tval = dw_pcie_readl_dbi(pci, offset + PCI_EXP_DEVCTL);\n\tval &= ~PCI_EXP_DEVCTL_PAYLOAD;\n\tdw_pcie_writel_dbi(pci, offset + PCI_EXP_DEVCTL, val);\n\n\tval = dw_pcie_readl_dbi(pci, offset + PCI_EXP_DEVCTL);\n\tval |= PCIE_CAP_MAX_PAYLOAD_SIZE(max_payload_size);\n\tdw_pcie_writel_dbi(pci, offset + PCI_EXP_DEVCTL, val);\n}\n\nstatic void meson_set_max_rd_req_size(struct meson_pcie *mp, int size)\n{\n\tstruct dw_pcie *pci = &mp->pci;\n\tu32 val;\n\tu16 offset = dw_pcie_find_capability(pci, PCI_CAP_ID_EXP);\n\tint max_rd_req_size = meson_size_to_payload(mp, size);\n\n\tval = dw_pcie_readl_dbi(pci, offset + PCI_EXP_DEVCTL);\n\tval &= ~PCI_EXP_DEVCTL_READRQ;\n\tdw_pcie_writel_dbi(pci, offset + PCI_EXP_DEVCTL, val);\n\n\tval = dw_pcie_readl_dbi(pci, offset + PCI_EXP_DEVCTL);\n\tval |= PCIE_CAP_MAX_READ_REQ_SIZE(max_rd_req_size);\n\tdw_pcie_writel_dbi(pci, offset + PCI_EXP_DEVCTL, val);\n}\n\nstatic int meson_pcie_start_link(struct dw_pcie *pci)\n{\n\tstruct meson_pcie *mp = to_meson_pcie(pci);\n\n\tmeson_pcie_ltssm_enable(mp);\n\tmeson_pcie_assert_reset(mp);\n\n\treturn 0;\n}\n\nstatic int meson_pcie_rd_own_conf(struct pci_bus *bus, u32 devfn,\n\t\t\t\t  int where, int size, u32 *val)\n{\n\tint ret;\n\n\tret = pci_generic_config_read(bus, devfn, where, size, val);\n\tif (ret != PCIBIOS_SUCCESSFUL)\n\t\treturn ret;\n\n\t \n\tif ((where & ~3) == PCI_CLASS_REVISION) {\n\t\tif (size <= 2)\n\t\t\t*val = (*val & ((1 << (size * 8)) - 1)) << (8 * (where & 3));\n\t\t*val &= ~0xffffff00;\n\t\t*val |= PCI_CLASS_BRIDGE_PCI_NORMAL << 8;\n\t\tif (size <= 2)\n\t\t\t*val = (*val >> (8 * (where & 3))) & ((1 << (size * 8)) - 1);\n\t}\n\n\treturn PCIBIOS_SUCCESSFUL;\n}\n\nstatic struct pci_ops meson_pci_ops = {\n\t.map_bus = dw_pcie_own_conf_map_bus,\n\t.read = meson_pcie_rd_own_conf,\n\t.write = pci_generic_config_write,\n};\n\nstatic int meson_pcie_link_up(struct dw_pcie *pci)\n{\n\tstruct meson_pcie *mp = to_meson_pcie(pci);\n\tstruct device *dev = pci->dev;\n\tu32 speed_okay = 0;\n\tu32 cnt = 0;\n\tu32 state12, state17, smlh_up, ltssm_up, rdlh_up;\n\n\tdo {\n\t\tstate12 = meson_cfg_readl(mp, PCIE_CFG_STATUS12);\n\t\tstate17 = meson_cfg_readl(mp, PCIE_CFG_STATUS17);\n\t\tsmlh_up = IS_SMLH_LINK_UP(state12);\n\t\trdlh_up = IS_RDLH_LINK_UP(state12);\n\t\tltssm_up = IS_LTSSM_UP(state12);\n\n\t\tif (PM_CURRENT_STATE(state17) < PCIE_GEN3)\n\t\t\tspeed_okay = 1;\n\n\t\tif (smlh_up)\n\t\t\tdev_dbg(dev, \"smlh_link_up is on\\n\");\n\t\tif (rdlh_up)\n\t\t\tdev_dbg(dev, \"rdlh_link_up is on\\n\");\n\t\tif (ltssm_up)\n\t\t\tdev_dbg(dev, \"ltssm_up is on\\n\");\n\t\tif (speed_okay)\n\t\t\tdev_dbg(dev, \"speed_okay\\n\");\n\n\t\tif (smlh_up && rdlh_up && ltssm_up && speed_okay)\n\t\t\treturn 1;\n\n\t\tcnt++;\n\n\t\tudelay(10);\n\t} while (cnt < WAIT_LINKUP_TIMEOUT);\n\n\tdev_err(dev, \"error: wait linkup timeout\\n\");\n\treturn 0;\n}\n\nstatic int meson_pcie_host_init(struct dw_pcie_rp *pp)\n{\n\tstruct dw_pcie *pci = to_dw_pcie_from_pp(pp);\n\tstruct meson_pcie *mp = to_meson_pcie(pci);\n\n\tpp->bridge->ops = &meson_pci_ops;\n\n\tmeson_set_max_payload(mp, MAX_PAYLOAD_SIZE);\n\tmeson_set_max_rd_req_size(mp, MAX_READ_REQ_SIZE);\n\n\treturn 0;\n}\n\nstatic const struct dw_pcie_host_ops meson_pcie_host_ops = {\n\t.host_init = meson_pcie_host_init,\n};\n\nstatic const struct dw_pcie_ops dw_pcie_ops = {\n\t.link_up = meson_pcie_link_up,\n\t.start_link = meson_pcie_start_link,\n};\n\nstatic int meson_pcie_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct dw_pcie *pci;\n\tstruct meson_pcie *mp;\n\tint ret;\n\n\tmp = devm_kzalloc(dev, sizeof(*mp), GFP_KERNEL);\n\tif (!mp)\n\t\treturn -ENOMEM;\n\n\tpci = &mp->pci;\n\tpci->dev = dev;\n\tpci->ops = &dw_pcie_ops;\n\tpci->pp.ops = &meson_pcie_host_ops;\n\tpci->num_lanes = 1;\n\n\tmp->phy = devm_phy_get(dev, \"pcie\");\n\tif (IS_ERR(mp->phy)) {\n\t\tdev_err(dev, \"get phy failed, %ld\\n\", PTR_ERR(mp->phy));\n\t\treturn PTR_ERR(mp->phy);\n\t}\n\n\tmp->reset_gpio = devm_gpiod_get(dev, \"reset\", GPIOD_OUT_LOW);\n\tif (IS_ERR(mp->reset_gpio)) {\n\t\tdev_err(dev, \"get reset gpio failed\\n\");\n\t\treturn PTR_ERR(mp->reset_gpio);\n\t}\n\n\tret = meson_pcie_get_resets(mp);\n\tif (ret) {\n\t\tdev_err(dev, \"get reset resource failed, %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = meson_pcie_get_mems(pdev, mp);\n\tif (ret) {\n\t\tdev_err(dev, \"get memory resource failed, %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = meson_pcie_power_on(mp);\n\tif (ret) {\n\t\tdev_err(dev, \"phy power on failed, %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = meson_pcie_reset(mp);\n\tif (ret) {\n\t\tdev_err(dev, \"reset failed, %d\\n\", ret);\n\t\tgoto err_phy;\n\t}\n\n\tret = meson_pcie_probe_clocks(mp);\n\tif (ret) {\n\t\tdev_err(dev, \"init clock resources failed, %d\\n\", ret);\n\t\tgoto err_phy;\n\t}\n\n\tplatform_set_drvdata(pdev, mp);\n\n\tret = dw_pcie_host_init(&pci->pp);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Add PCIe port failed, %d\\n\", ret);\n\t\tgoto err_phy;\n\t}\n\n\treturn 0;\n\nerr_phy:\n\tmeson_pcie_power_off(mp);\n\treturn ret;\n}\n\nstatic const struct of_device_id meson_pcie_of_match[] = {\n\t{\n\t\t.compatible = \"amlogic,axg-pcie\",\n\t},\n\t{\n\t\t.compatible = \"amlogic,g12a-pcie\",\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, meson_pcie_of_match);\n\nstatic struct platform_driver meson_pcie_driver = {\n\t.probe = meson_pcie_probe,\n\t.driver = {\n\t\t.name = \"meson-pcie\",\n\t\t.of_match_table = meson_pcie_of_match,\n\t},\n};\n\nmodule_platform_driver(meson_pcie_driver);\n\nMODULE_AUTHOR(\"Yue Wang <yue.wang@amlogic.com>\");\nMODULE_DESCRIPTION(\"Amlogic PCIe Controller driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}