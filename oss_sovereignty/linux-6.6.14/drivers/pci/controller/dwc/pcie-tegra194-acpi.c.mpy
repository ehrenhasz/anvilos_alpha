{
  "module_name": "pcie-tegra194-acpi.c",
  "hash_id": "1ddcffb7627640ed8d53008ac5e33b60659e9367c245d5b611b7d8d0e1bd361f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/controller/dwc/pcie-tegra194-acpi.c",
  "human_readable_source": "\n \n\n#include <linux/pci.h>\n#include <linux/pci-acpi.h>\n#include <linux/pci-ecam.h>\n\n#include \"pcie-designware.h\"\n\nstruct tegra194_pcie_ecam  {\n\tvoid __iomem *config_base;\n\tvoid __iomem *iatu_base;\n\tvoid __iomem *dbi_base;\n};\n\nstatic int tegra194_acpi_init(struct pci_config_window *cfg)\n{\n\tstruct device *dev = cfg->parent;\n\tstruct tegra194_pcie_ecam *pcie_ecam;\n\n\tpcie_ecam = devm_kzalloc(dev, sizeof(*pcie_ecam), GFP_KERNEL);\n\tif (!pcie_ecam)\n\t\treturn -ENOMEM;\n\n\tpcie_ecam->config_base = cfg->win;\n\tpcie_ecam->iatu_base = cfg->win + SZ_256K;\n\tpcie_ecam->dbi_base = cfg->win + SZ_512K;\n\tcfg->priv = pcie_ecam;\n\n\treturn 0;\n}\n\nstatic void atu_reg_write(struct tegra194_pcie_ecam *pcie_ecam, int index,\n\t\t\t  u32 val, u32 reg)\n{\n\tu32 offset = PCIE_ATU_UNROLL_BASE(PCIE_ATU_REGION_DIR_OB, index) +\n\t\t     PCIE_ATU_VIEWPORT_BASE;\n\n\twritel(val, pcie_ecam->iatu_base + offset + reg);\n}\n\nstatic void program_outbound_atu(struct tegra194_pcie_ecam *pcie_ecam,\n\t\t\t\t int index, int type, u64 cpu_addr,\n\t\t\t\t u64 pci_addr, u64 size)\n{\n\tatu_reg_write(pcie_ecam, index, lower_32_bits(cpu_addr),\n\t\t      PCIE_ATU_LOWER_BASE);\n\tatu_reg_write(pcie_ecam, index, upper_32_bits(cpu_addr),\n\t\t      PCIE_ATU_UPPER_BASE);\n\tatu_reg_write(pcie_ecam, index, lower_32_bits(pci_addr),\n\t\t      PCIE_ATU_LOWER_TARGET);\n\tatu_reg_write(pcie_ecam, index, lower_32_bits(cpu_addr + size - 1),\n\t\t      PCIE_ATU_LIMIT);\n\tatu_reg_write(pcie_ecam, index, upper_32_bits(pci_addr),\n\t\t      PCIE_ATU_UPPER_TARGET);\n\tatu_reg_write(pcie_ecam, index, type, PCIE_ATU_REGION_CTRL1);\n\tatu_reg_write(pcie_ecam, index, PCIE_ATU_ENABLE, PCIE_ATU_REGION_CTRL2);\n}\n\nstatic void __iomem *tegra194_map_bus(struct pci_bus *bus,\n\t\t\t\t      unsigned int devfn, int where)\n{\n\tstruct pci_config_window *cfg = bus->sysdata;\n\tstruct tegra194_pcie_ecam *pcie_ecam = cfg->priv;\n\tu32 busdev;\n\tint type;\n\n\tif (bus->number < cfg->busr.start || bus->number > cfg->busr.end)\n\t\treturn NULL;\n\n\tif (bus->number == cfg->busr.start) {\n\t\tif (PCI_SLOT(devfn) == 0)\n\t\t\treturn pcie_ecam->dbi_base + where;\n\t\telse\n\t\t\treturn NULL;\n\t}\n\n\tbusdev = PCIE_ATU_BUS(bus->number) | PCIE_ATU_DEV(PCI_SLOT(devfn)) |\n\t\t PCIE_ATU_FUNC(PCI_FUNC(devfn));\n\n\tif (bus->parent->number == cfg->busr.start) {\n\t\tif (PCI_SLOT(devfn) == 0)\n\t\t\ttype = PCIE_ATU_TYPE_CFG0;\n\t\telse\n\t\t\treturn NULL;\n\t} else {\n\t\ttype = PCIE_ATU_TYPE_CFG1;\n\t}\n\n\tprogram_outbound_atu(pcie_ecam, 0, type, cfg->res.start, busdev,\n\t\t\t     SZ_256K);\n\n\treturn pcie_ecam->config_base + where;\n}\n\nconst struct pci_ecam_ops tegra194_pcie_ops = {\n\t.init\t\t= tegra194_acpi_init,\n\t.pci_ops\t= {\n\t\t.map_bus\t= tegra194_map_bus,\n\t\t.read\t\t= pci_generic_config_read,\n\t\t.write\t\t= pci_generic_config_write,\n\t}\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}