{
  "module_name": "pcie-uniphier.c",
  "hash_id": "07f38726b74612beaa98dc3d467246573ff19563905c1c767779f95f470b64fd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/controller/dwc/pcie-uniphier.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/iopoll.h>\n#include <linux/irqchip/chained_irq.h>\n#include <linux/irqdomain.h>\n#include <linux/of_irq.h>\n#include <linux/pci.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n#include <linux/reset.h>\n\n#include \"pcie-designware.h\"\n\n#define PCL_PINCTRL0\t\t\t0x002c\n#define PCL_PERST_PLDN_REGEN\t\tBIT(12)\n#define PCL_PERST_NOE_REGEN\t\tBIT(11)\n#define PCL_PERST_OUT_REGEN\t\tBIT(8)\n#define PCL_PERST_PLDN_REGVAL\t\tBIT(4)\n#define PCL_PERST_NOE_REGVAL\t\tBIT(3)\n#define PCL_PERST_OUT_REGVAL\t\tBIT(0)\n\n#define PCL_PIPEMON\t\t\t0x0044\n#define PCL_PCLK_ALIVE\t\t\tBIT(15)\n\n#define PCL_MODE\t\t\t0x8000\n#define PCL_MODE_REGEN\t\t\tBIT(8)\n#define PCL_MODE_REGVAL\t\t\tBIT(0)\n\n#define PCL_APP_READY_CTRL\t\t0x8008\n#define PCL_APP_LTSSM_ENABLE\t\tBIT(0)\n\n#define PCL_APP_PM0\t\t\t0x8078\n#define PCL_SYS_AUX_PWR_DET\t\tBIT(8)\n\n#define PCL_RCV_INT\t\t\t0x8108\n#define PCL_RCV_INT_ALL_ENABLE\t\tGENMASK(20, 17)\n#define PCL_CFG_BW_MGT_STATUS\t\tBIT(4)\n#define PCL_CFG_LINK_AUTO_BW_STATUS\tBIT(3)\n#define PCL_CFG_AER_RC_ERR_MSI_STATUS\tBIT(2)\n#define PCL_CFG_PME_MSI_STATUS\t\tBIT(1)\n\n#define PCL_RCV_INTX\t\t\t0x810c\n#define PCL_RCV_INTX_ALL_ENABLE\t\tGENMASK(19, 16)\n#define PCL_RCV_INTX_ALL_MASK\t\tGENMASK(11, 8)\n#define PCL_RCV_INTX_MASK_SHIFT\t\t8\n#define PCL_RCV_INTX_ALL_STATUS\t\tGENMASK(3, 0)\n#define PCL_RCV_INTX_STATUS_SHIFT\t0\n\n#define PCL_STATUS_LINK\t\t\t0x8140\n#define PCL_RDLH_LINK_UP\t\tBIT(1)\n#define PCL_XMLH_LINK_UP\t\tBIT(0)\n\nstruct uniphier_pcie {\n\tstruct dw_pcie pci;\n\tvoid __iomem *base;\n\tstruct clk *clk;\n\tstruct reset_control *rst;\n\tstruct phy *phy;\n\tstruct irq_domain *legacy_irq_domain;\n};\n\n#define to_uniphier_pcie(x)\tdev_get_drvdata((x)->dev)\n\nstatic void uniphier_pcie_ltssm_enable(struct uniphier_pcie *pcie,\n\t\t\t\t       bool enable)\n{\n\tu32 val;\n\n\tval = readl(pcie->base + PCL_APP_READY_CTRL);\n\tif (enable)\n\t\tval |= PCL_APP_LTSSM_ENABLE;\n\telse\n\t\tval &= ~PCL_APP_LTSSM_ENABLE;\n\twritel(val, pcie->base + PCL_APP_READY_CTRL);\n}\n\nstatic void uniphier_pcie_init_rc(struct uniphier_pcie *pcie)\n{\n\tu32 val;\n\n\t \n\tval = readl(pcie->base + PCL_MODE);\n\tval |= PCL_MODE_REGEN;\n\tval &= ~PCL_MODE_REGVAL;\n\twritel(val, pcie->base + PCL_MODE);\n\n\t \n\tval = readl(pcie->base + PCL_APP_PM0);\n\tval |= PCL_SYS_AUX_PWR_DET;\n\twritel(val, pcie->base + PCL_APP_PM0);\n\n\t \n\tval = readl(pcie->base + PCL_PINCTRL0);\n\tval &= ~(PCL_PERST_NOE_REGVAL | PCL_PERST_OUT_REGVAL\n\t\t | PCL_PERST_PLDN_REGVAL);\n\tval |= PCL_PERST_NOE_REGEN | PCL_PERST_OUT_REGEN\n\t\t| PCL_PERST_PLDN_REGEN;\n\twritel(val, pcie->base + PCL_PINCTRL0);\n\n\tuniphier_pcie_ltssm_enable(pcie, false);\n\n\tusleep_range(100000, 200000);\n\n\t \n\tval = readl(pcie->base + PCL_PINCTRL0);\n\tval |= PCL_PERST_OUT_REGVAL | PCL_PERST_OUT_REGEN;\n\twritel(val, pcie->base + PCL_PINCTRL0);\n}\n\nstatic int uniphier_pcie_wait_rc(struct uniphier_pcie *pcie)\n{\n\tu32 status;\n\tint ret;\n\n\t \n\tret = readl_poll_timeout(pcie->base + PCL_PIPEMON, status,\n\t\t\t\t status & PCL_PCLK_ALIVE, 100000, 1000000);\n\tif (ret) {\n\t\tdev_err(pcie->pci.dev,\n\t\t\t\"Failed to initialize controller in RC mode\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int uniphier_pcie_link_up(struct dw_pcie *pci)\n{\n\tstruct uniphier_pcie *pcie = to_uniphier_pcie(pci);\n\tu32 val, mask;\n\n\tval = readl(pcie->base + PCL_STATUS_LINK);\n\tmask = PCL_RDLH_LINK_UP | PCL_XMLH_LINK_UP;\n\n\treturn (val & mask) == mask;\n}\n\nstatic int uniphier_pcie_start_link(struct dw_pcie *pci)\n{\n\tstruct uniphier_pcie *pcie = to_uniphier_pcie(pci);\n\n\tuniphier_pcie_ltssm_enable(pcie, true);\n\n\treturn 0;\n}\n\nstatic void uniphier_pcie_stop_link(struct dw_pcie *pci)\n{\n\tstruct uniphier_pcie *pcie = to_uniphier_pcie(pci);\n\n\tuniphier_pcie_ltssm_enable(pcie, false);\n}\n\nstatic void uniphier_pcie_irq_enable(struct uniphier_pcie *pcie)\n{\n\twritel(PCL_RCV_INT_ALL_ENABLE, pcie->base + PCL_RCV_INT);\n\twritel(PCL_RCV_INTX_ALL_ENABLE, pcie->base + PCL_RCV_INTX);\n}\n\n\nstatic void uniphier_pcie_irq_mask(struct irq_data *d)\n{\n\tstruct dw_pcie_rp *pp = irq_data_get_irq_chip_data(d);\n\tstruct dw_pcie *pci = to_dw_pcie_from_pp(pp);\n\tstruct uniphier_pcie *pcie = to_uniphier_pcie(pci);\n\tunsigned long flags;\n\tu32 val;\n\n\traw_spin_lock_irqsave(&pp->lock, flags);\n\n\tval = readl(pcie->base + PCL_RCV_INTX);\n\tval |= BIT(irqd_to_hwirq(d) + PCL_RCV_INTX_MASK_SHIFT);\n\twritel(val, pcie->base + PCL_RCV_INTX);\n\n\traw_spin_unlock_irqrestore(&pp->lock, flags);\n}\n\nstatic void uniphier_pcie_irq_unmask(struct irq_data *d)\n{\n\tstruct dw_pcie_rp *pp = irq_data_get_irq_chip_data(d);\n\tstruct dw_pcie *pci = to_dw_pcie_from_pp(pp);\n\tstruct uniphier_pcie *pcie = to_uniphier_pcie(pci);\n\tunsigned long flags;\n\tu32 val;\n\n\traw_spin_lock_irqsave(&pp->lock, flags);\n\n\tval = readl(pcie->base + PCL_RCV_INTX);\n\tval &= ~BIT(irqd_to_hwirq(d) + PCL_RCV_INTX_MASK_SHIFT);\n\twritel(val, pcie->base + PCL_RCV_INTX);\n\n\traw_spin_unlock_irqrestore(&pp->lock, flags);\n}\n\nstatic struct irq_chip uniphier_pcie_irq_chip = {\n\t.name = \"PCI\",\n\t.irq_mask = uniphier_pcie_irq_mask,\n\t.irq_unmask = uniphier_pcie_irq_unmask,\n};\n\nstatic int uniphier_pcie_intx_map(struct irq_domain *domain, unsigned int irq,\n\t\t\t\t  irq_hw_number_t hwirq)\n{\n\tirq_set_chip_and_handler(irq, &uniphier_pcie_irq_chip,\n\t\t\t\t handle_level_irq);\n\tirq_set_chip_data(irq, domain->host_data);\n\n\treturn 0;\n}\n\nstatic const struct irq_domain_ops uniphier_intx_domain_ops = {\n\t.map = uniphier_pcie_intx_map,\n};\n\nstatic void uniphier_pcie_irq_handler(struct irq_desc *desc)\n{\n\tstruct dw_pcie_rp *pp = irq_desc_get_handler_data(desc);\n\tstruct dw_pcie *pci = to_dw_pcie_from_pp(pp);\n\tstruct uniphier_pcie *pcie = to_uniphier_pcie(pci);\n\tstruct irq_chip *chip = irq_desc_get_chip(desc);\n\tunsigned long reg;\n\tu32 val, bit;\n\n\t \n\tval = readl(pcie->base + PCL_RCV_INT);\n\n\tif (val & PCL_CFG_BW_MGT_STATUS)\n\t\tdev_dbg(pci->dev, \"Link Bandwidth Management Event\\n\");\n\tif (val & PCL_CFG_LINK_AUTO_BW_STATUS)\n\t\tdev_dbg(pci->dev, \"Link Autonomous Bandwidth Event\\n\");\n\tif (val & PCL_CFG_AER_RC_ERR_MSI_STATUS)\n\t\tdev_dbg(pci->dev, \"Root Error\\n\");\n\tif (val & PCL_CFG_PME_MSI_STATUS)\n\t\tdev_dbg(pci->dev, \"PME Interrupt\\n\");\n\n\twritel(val, pcie->base + PCL_RCV_INT);\n\n\t \n\tchained_irq_enter(chip, desc);\n\n\tval = readl(pcie->base + PCL_RCV_INTX);\n\treg = FIELD_GET(PCL_RCV_INTX_ALL_STATUS, val);\n\n\tfor_each_set_bit(bit, &reg, PCI_NUM_INTX)\n\t\tgeneric_handle_domain_irq(pcie->legacy_irq_domain, bit);\n\n\tchained_irq_exit(chip, desc);\n}\n\nstatic int uniphier_pcie_config_legacy_irq(struct dw_pcie_rp *pp)\n{\n\tstruct dw_pcie *pci = to_dw_pcie_from_pp(pp);\n\tstruct uniphier_pcie *pcie = to_uniphier_pcie(pci);\n\tstruct device_node *np = pci->dev->of_node;\n\tstruct device_node *np_intc;\n\tint ret = 0;\n\n\tnp_intc = of_get_child_by_name(np, \"legacy-interrupt-controller\");\n\tif (!np_intc) {\n\t\tdev_err(pci->dev, \"Failed to get legacy-interrupt-controller node\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpp->irq = irq_of_parse_and_map(np_intc, 0);\n\tif (!pp->irq) {\n\t\tdev_err(pci->dev, \"Failed to get an IRQ entry in legacy-interrupt-controller\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out_put_node;\n\t}\n\n\tpcie->legacy_irq_domain = irq_domain_add_linear(np_intc, PCI_NUM_INTX,\n\t\t\t\t\t\t&uniphier_intx_domain_ops, pp);\n\tif (!pcie->legacy_irq_domain) {\n\t\tdev_err(pci->dev, \"Failed to get INTx domain\\n\");\n\t\tret = -ENODEV;\n\t\tgoto out_put_node;\n\t}\n\n\tirq_set_chained_handler_and_data(pp->irq, uniphier_pcie_irq_handler,\n\t\t\t\t\t pp);\n\nout_put_node:\n\tof_node_put(np_intc);\n\treturn ret;\n}\n\nstatic int uniphier_pcie_host_init(struct dw_pcie_rp *pp)\n{\n\tstruct dw_pcie *pci = to_dw_pcie_from_pp(pp);\n\tstruct uniphier_pcie *pcie = to_uniphier_pcie(pci);\n\tint ret;\n\n\tret = uniphier_pcie_config_legacy_irq(pp);\n\tif (ret)\n\t\treturn ret;\n\n\tuniphier_pcie_irq_enable(pcie);\n\n\treturn 0;\n}\n\nstatic const struct dw_pcie_host_ops uniphier_pcie_host_ops = {\n\t.host_init = uniphier_pcie_host_init,\n};\n\nstatic int uniphier_pcie_host_enable(struct uniphier_pcie *pcie)\n{\n\tint ret;\n\n\tret = clk_prepare_enable(pcie->clk);\n\tif (ret)\n\t\treturn ret;\n\n\tret = reset_control_deassert(pcie->rst);\n\tif (ret)\n\t\tgoto out_clk_disable;\n\n\tuniphier_pcie_init_rc(pcie);\n\n\tret = phy_init(pcie->phy);\n\tif (ret)\n\t\tgoto out_rst_assert;\n\n\tret = uniphier_pcie_wait_rc(pcie);\n\tif (ret)\n\t\tgoto out_phy_exit;\n\n\treturn 0;\n\nout_phy_exit:\n\tphy_exit(pcie->phy);\nout_rst_assert:\n\treset_control_assert(pcie->rst);\nout_clk_disable:\n\tclk_disable_unprepare(pcie->clk);\n\n\treturn ret;\n}\n\nstatic const struct dw_pcie_ops dw_pcie_ops = {\n\t.start_link = uniphier_pcie_start_link,\n\t.stop_link = uniphier_pcie_stop_link,\n\t.link_up = uniphier_pcie_link_up,\n};\n\nstatic int uniphier_pcie_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct uniphier_pcie *pcie;\n\tint ret;\n\n\tpcie = devm_kzalloc(dev, sizeof(*pcie), GFP_KERNEL);\n\tif (!pcie)\n\t\treturn -ENOMEM;\n\n\tpcie->pci.dev = dev;\n\tpcie->pci.ops = &dw_pcie_ops;\n\n\tpcie->base = devm_platform_ioremap_resource_byname(pdev, \"link\");\n\tif (IS_ERR(pcie->base))\n\t\treturn PTR_ERR(pcie->base);\n\n\tpcie->clk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(pcie->clk))\n\t\treturn PTR_ERR(pcie->clk);\n\n\tpcie->rst = devm_reset_control_get_shared(dev, NULL);\n\tif (IS_ERR(pcie->rst))\n\t\treturn PTR_ERR(pcie->rst);\n\n\tpcie->phy = devm_phy_optional_get(dev, \"pcie-phy\");\n\tif (IS_ERR(pcie->phy))\n\t\treturn PTR_ERR(pcie->phy);\n\n\tplatform_set_drvdata(pdev, pcie);\n\n\tret = uniphier_pcie_host_enable(pcie);\n\tif (ret)\n\t\treturn ret;\n\n\tpcie->pci.pp.ops = &uniphier_pcie_host_ops;\n\n\treturn dw_pcie_host_init(&pcie->pci.pp);\n}\n\nstatic const struct of_device_id uniphier_pcie_match[] = {\n\t{ .compatible = \"socionext,uniphier-pcie\", },\n\t{   },\n};\n\nstatic struct platform_driver uniphier_pcie_driver = {\n\t.probe  = uniphier_pcie_probe,\n\t.driver = {\n\t\t.name = \"uniphier-pcie\",\n\t\t.of_match_table = uniphier_pcie_match,\n\t},\n};\nbuiltin_platform_driver(uniphier_pcie_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}