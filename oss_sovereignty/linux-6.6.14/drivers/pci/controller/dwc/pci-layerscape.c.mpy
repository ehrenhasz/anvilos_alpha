{
  "module_name": "pci-layerscape.c",
  "hash_id": "41234642ebfe0e3fd83563fdf009594bd2ea6f837c3595e8e651dc8f0f94ab7c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/controller/dwc/pci-layerscape.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/iopoll.h>\n#include <linux/of_pci.h>\n#include <linux/of_platform.h>\n#include <linux/of_address.h>\n#include <linux/pci.h>\n#include <linux/platform_device.h>\n#include <linux/resource.h>\n#include <linux/mfd/syscon.h>\n#include <linux/regmap.h>\n\n#include \"../../pci.h\"\n#include \"pcie-designware.h\"\n\n \n#define PCIE_STRFMR1\t\t0x71c  \n#define PCIE_ABSERR\t\t0x8d0  \n#define PCIE_ABSERR_SETTING\t0x9401  \n\n \n#define LS_PCIE_PF_MCR\t\t0x2c\n#define PF_MCR_PTOMR\t\tBIT(0)\n#define PF_MCR_EXL2S\t\tBIT(1)\n\n#define PCIE_IATU_NUM\t\t6\n\nstruct ls_pcie_drvdata {\n\tconst u32 pf_off;\n\tbool pm_support;\n};\n\nstruct ls_pcie {\n\tstruct dw_pcie *pci;\n\tconst struct ls_pcie_drvdata *drvdata;\n\tvoid __iomem *pf_base;\n\tbool big_endian;\n};\n\n#define ls_pcie_pf_readl_addr(addr)\tls_pcie_pf_readl(pcie, addr)\n#define to_ls_pcie(x)\tdev_get_drvdata((x)->dev)\n\nstatic bool ls_pcie_is_bridge(struct ls_pcie *pcie)\n{\n\tstruct dw_pcie *pci = pcie->pci;\n\tu32 header_type;\n\n\theader_type = ioread8(pci->dbi_base + PCI_HEADER_TYPE);\n\theader_type &= 0x7f;\n\n\treturn header_type == PCI_HEADER_TYPE_BRIDGE;\n}\n\n \nstatic void ls_pcie_clear_multifunction(struct ls_pcie *pcie)\n{\n\tstruct dw_pcie *pci = pcie->pci;\n\n\tiowrite8(PCI_HEADER_TYPE_BRIDGE, pci->dbi_base + PCI_HEADER_TYPE);\n}\n\n \nstatic void ls_pcie_drop_msg_tlp(struct ls_pcie *pcie)\n{\n\tu32 val;\n\tstruct dw_pcie *pci = pcie->pci;\n\n\tval = ioread32(pci->dbi_base + PCIE_STRFMR1);\n\tval &= 0xDFFFFFFF;\n\tiowrite32(val, pci->dbi_base + PCIE_STRFMR1);\n}\n\n \nstatic void ls_pcie_fix_error_response(struct ls_pcie *pcie)\n{\n\tstruct dw_pcie *pci = pcie->pci;\n\n\tiowrite32(PCIE_ABSERR_SETTING, pci->dbi_base + PCIE_ABSERR);\n}\n\nstatic u32 ls_pcie_pf_readl(struct ls_pcie *pcie, u32 off)\n{\n\tif (pcie->big_endian)\n\t\treturn ioread32be(pcie->pf_base + off);\n\n\treturn ioread32(pcie->pf_base + off);\n}\n\nstatic void ls_pcie_pf_writel(struct ls_pcie *pcie, u32 off, u32 val)\n{\n\tif (pcie->big_endian)\n\t\tiowrite32be(val, pcie->pf_base + off);\n\telse\n\t\tiowrite32(val, pcie->pf_base + off);\n}\n\nstatic void ls_pcie_send_turnoff_msg(struct dw_pcie_rp *pp)\n{\n\tstruct dw_pcie *pci = to_dw_pcie_from_pp(pp);\n\tstruct ls_pcie *pcie = to_ls_pcie(pci);\n\tu32 val;\n\tint ret;\n\n\tval = ls_pcie_pf_readl(pcie, LS_PCIE_PF_MCR);\n\tval |= PF_MCR_PTOMR;\n\tls_pcie_pf_writel(pcie, LS_PCIE_PF_MCR, val);\n\n\tret = readx_poll_timeout(ls_pcie_pf_readl_addr, LS_PCIE_PF_MCR,\n\t\t\t\t val, !(val & PF_MCR_PTOMR),\n\t\t\t\t PCIE_PME_TO_L2_TIMEOUT_US/10,\n\t\t\t\t PCIE_PME_TO_L2_TIMEOUT_US);\n\tif (ret)\n\t\tdev_err(pcie->pci->dev, \"PME_Turn_off timeout\\n\");\n}\n\nstatic void ls_pcie_exit_from_l2(struct dw_pcie_rp *pp)\n{\n\tstruct dw_pcie *pci = to_dw_pcie_from_pp(pp);\n\tstruct ls_pcie *pcie = to_ls_pcie(pci);\n\tu32 val;\n\tint ret;\n\n\t \n\tval = ls_pcie_pf_readl(pcie, LS_PCIE_PF_MCR);\n\tval |= PF_MCR_EXL2S;\n\tls_pcie_pf_writel(pcie, LS_PCIE_PF_MCR, val);\n\n\t \n\tret = readx_poll_timeout(ls_pcie_pf_readl_addr, LS_PCIE_PF_MCR,\n\t\t\t\t val, !(val & PF_MCR_EXL2S),\n\t\t\t\t 1000,\n\t\t\t\t 10000);\n\tif (ret)\n\t\tdev_err(pcie->pci->dev, \"L2 exit timeout\\n\");\n}\n\nstatic int ls_pcie_host_init(struct dw_pcie_rp *pp)\n{\n\tstruct dw_pcie *pci = to_dw_pcie_from_pp(pp);\n\tstruct ls_pcie *pcie = to_ls_pcie(pci);\n\n\tls_pcie_fix_error_response(pcie);\n\n\tdw_pcie_dbi_ro_wr_en(pci);\n\tls_pcie_clear_multifunction(pcie);\n\tdw_pcie_dbi_ro_wr_dis(pci);\n\n\tls_pcie_drop_msg_tlp(pcie);\n\n\treturn 0;\n}\n\nstatic const struct dw_pcie_host_ops ls_pcie_host_ops = {\n\t.host_init = ls_pcie_host_init,\n\t.pme_turn_off = ls_pcie_send_turnoff_msg,\n};\n\nstatic const struct ls_pcie_drvdata ls1021a_drvdata = {\n\t.pm_support = false,\n};\n\nstatic const struct ls_pcie_drvdata layerscape_drvdata = {\n\t.pf_off = 0xc0000,\n\t.pm_support = true,\n};\n\nstatic const struct of_device_id ls_pcie_of_match[] = {\n\t{ .compatible = \"fsl,ls1012a-pcie\", .data = &layerscape_drvdata },\n\t{ .compatible = \"fsl,ls1021a-pcie\", .data = &ls1021a_drvdata },\n\t{ .compatible = \"fsl,ls1028a-pcie\", .data = &layerscape_drvdata },\n\t{ .compatible = \"fsl,ls1043a-pcie\", .data = &ls1021a_drvdata },\n\t{ .compatible = \"fsl,ls1046a-pcie\", .data = &layerscape_drvdata },\n\t{ .compatible = \"fsl,ls2080a-pcie\", .data = &layerscape_drvdata },\n\t{ .compatible = \"fsl,ls2085a-pcie\", .data = &layerscape_drvdata },\n\t{ .compatible = \"fsl,ls2088a-pcie\", .data = &layerscape_drvdata },\n\t{ .compatible = \"fsl,ls1088a-pcie\", .data = &layerscape_drvdata },\n\t{ },\n};\n\nstatic int ls_pcie_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct dw_pcie *pci;\n\tstruct ls_pcie *pcie;\n\tstruct resource *dbi_base;\n\n\tpcie = devm_kzalloc(dev, sizeof(*pcie), GFP_KERNEL);\n\tif (!pcie)\n\t\treturn -ENOMEM;\n\n\tpci = devm_kzalloc(dev, sizeof(*pci), GFP_KERNEL);\n\tif (!pci)\n\t\treturn -ENOMEM;\n\n\tpcie->drvdata = of_device_get_match_data(dev);\n\n\tpci->dev = dev;\n\tpci->pp.ops = &ls_pcie_host_ops;\n\n\tpcie->pci = pci;\n\n\tdbi_base = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"regs\");\n\tpci->dbi_base = devm_pci_remap_cfg_resource(dev, dbi_base);\n\tif (IS_ERR(pci->dbi_base))\n\t\treturn PTR_ERR(pci->dbi_base);\n\n\tpcie->big_endian = of_property_read_bool(dev->of_node, \"big-endian\");\n\n\tpcie->pf_base = pci->dbi_base + pcie->drvdata->pf_off;\n\n\tif (!ls_pcie_is_bridge(pcie))\n\t\treturn -ENODEV;\n\n\tplatform_set_drvdata(pdev, pcie);\n\n\treturn dw_pcie_host_init(&pci->pp);\n}\n\nstatic int ls_pcie_suspend_noirq(struct device *dev)\n{\n\tstruct ls_pcie *pcie = dev_get_drvdata(dev);\n\n\tif (!pcie->drvdata->pm_support)\n\t\treturn 0;\n\n\treturn dw_pcie_suspend_noirq(pcie->pci);\n}\n\nstatic int ls_pcie_resume_noirq(struct device *dev)\n{\n\tstruct ls_pcie *pcie = dev_get_drvdata(dev);\n\n\tif (!pcie->drvdata->pm_support)\n\t\treturn 0;\n\n\tls_pcie_exit_from_l2(&pcie->pci->pp);\n\n\treturn dw_pcie_resume_noirq(pcie->pci);\n}\n\nstatic const struct dev_pm_ops ls_pcie_pm_ops = {\n\tNOIRQ_SYSTEM_SLEEP_PM_OPS(ls_pcie_suspend_noirq, ls_pcie_resume_noirq)\n};\n\nstatic struct platform_driver ls_pcie_driver = {\n\t.probe = ls_pcie_probe,\n\t.driver = {\n\t\t.name = \"layerscape-pcie\",\n\t\t.of_match_table = ls_pcie_of_match,\n\t\t.suppress_bind_attrs = true,\n\t\t.pm = &ls_pcie_pm_ops,\n\t},\n};\nbuiltin_platform_driver(ls_pcie_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}