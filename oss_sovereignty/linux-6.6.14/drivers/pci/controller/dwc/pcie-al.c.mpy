{
  "module_name": "pcie-al.c",
  "hash_id": "f1c62fbe9ee294db9a5a0e9f27cc8b51e7925f7253835b51d2c6883865526d97",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/controller/dwc/pcie-al.c",
  "human_readable_source": "\n \n\n#include <linux/pci.h>\n#include <linux/pci-ecam.h>\n#include <linux/pci-acpi.h>\n#include \"../../pci.h\"\n\n#if defined(CONFIG_ACPI) && defined(CONFIG_PCI_QUIRKS)\n\nstruct al_pcie_acpi  {\n\tvoid __iomem *dbi_base;\n};\n\nstatic void __iomem *al_pcie_map_bus(struct pci_bus *bus, unsigned int devfn,\n\t\t\t\t     int where)\n{\n\tstruct pci_config_window *cfg = bus->sysdata;\n\tstruct al_pcie_acpi *pcie = cfg->priv;\n\tvoid __iomem *dbi_base = pcie->dbi_base;\n\n\tif (bus->number == cfg->busr.start) {\n\t\t \n\t\tif (PCI_SLOT(devfn) > 0)\n\t\t\treturn NULL;\n\t\telse\n\t\t\treturn dbi_base + where;\n\t}\n\n\treturn pci_ecam_map_bus(bus, devfn, where);\n}\n\nstatic int al_pcie_init(struct pci_config_window *cfg)\n{\n\tstruct device *dev = cfg->parent;\n\tstruct acpi_device *adev = to_acpi_device(dev);\n\tstruct acpi_pci_root *root = acpi_driver_data(adev);\n\tstruct al_pcie_acpi *al_pcie;\n\tstruct resource *res;\n\tint ret;\n\n\tal_pcie = devm_kzalloc(dev, sizeof(*al_pcie), GFP_KERNEL);\n\tif (!al_pcie)\n\t\treturn -ENOMEM;\n\n\tres = devm_kzalloc(dev, sizeof(*res), GFP_KERNEL);\n\tif (!res)\n\t\treturn -ENOMEM;\n\n\tret = acpi_get_rc_resources(dev, \"AMZN0001\", root->segment, res);\n\tif (ret) {\n\t\tdev_err(dev, \"can't get rc dbi base address for SEG %d\\n\",\n\t\t\troot->segment);\n\t\treturn ret;\n\t}\n\n\tdev_dbg(dev, \"Root port dbi res: %pR\\n\", res);\n\n\tal_pcie->dbi_base = devm_pci_remap_cfg_resource(dev, res);\n\tif (IS_ERR(al_pcie->dbi_base))\n\t\treturn PTR_ERR(al_pcie->dbi_base);\n\n\tcfg->priv = al_pcie;\n\n\treturn 0;\n}\n\nconst struct pci_ecam_ops al_pcie_ops = {\n\t.init         =  al_pcie_init,\n\t.pci_ops      = {\n\t\t.map_bus    = al_pcie_map_bus,\n\t\t.read       = pci_generic_config_read,\n\t\t.write      = pci_generic_config_write,\n\t}\n};\n\n#endif  \n\n#ifdef CONFIG_PCIE_AL\n\n#include <linux/of_pci.h>\n#include \"pcie-designware.h\"\n\n#define AL_PCIE_REV_ID_2\t2\n#define AL_PCIE_REV_ID_3\t3\n#define AL_PCIE_REV_ID_4\t4\n\n#define AXI_BASE_OFFSET\t\t0x0\n\n#define DEVICE_ID_OFFSET\t0x16c\n\n#define DEVICE_REV_ID\t\t\t0x0\n#define DEVICE_REV_ID_DEV_ID_MASK\tGENMASK(31, 16)\n\n#define DEVICE_REV_ID_DEV_ID_X4\t\t0\n#define DEVICE_REV_ID_DEV_ID_X8\t\t2\n#define DEVICE_REV_ID_DEV_ID_X16\t4\n\n#define OB_CTRL_REV1_2_OFFSET\t0x0040\n#define OB_CTRL_REV3_5_OFFSET\t0x0030\n\n#define CFG_TARGET_BUS\t\t\t0x0\n#define CFG_TARGET_BUS_MASK_MASK\tGENMASK(7, 0)\n#define CFG_TARGET_BUS_BUSNUM_MASK\tGENMASK(15, 8)\n\n#define CFG_CONTROL\t\t\t0x4\n#define CFG_CONTROL_SUBBUS_MASK\t\tGENMASK(15, 8)\n#define CFG_CONTROL_SEC_BUS_MASK\tGENMASK(23, 16)\n\nstruct al_pcie_reg_offsets {\n\tunsigned int ob_ctrl;\n};\n\nstruct al_pcie_target_bus_cfg {\n\tu8 reg_val;\n\tu8 reg_mask;\n\tu8 ecam_mask;\n};\n\nstruct al_pcie {\n\tstruct dw_pcie *pci;\n\tvoid __iomem *controller_base;  \n\tstruct device *dev;\n\tresource_size_t ecam_size;\n\tunsigned int controller_rev_id;\n\tstruct al_pcie_reg_offsets reg_offsets;\n\tstruct al_pcie_target_bus_cfg target_bus_cfg;\n};\n\n#define to_al_pcie(x)\t\tdev_get_drvdata((x)->dev)\n\nstatic inline u32 al_pcie_controller_readl(struct al_pcie *pcie, u32 offset)\n{\n\treturn readl_relaxed(pcie->controller_base + offset);\n}\n\nstatic inline void al_pcie_controller_writel(struct al_pcie *pcie, u32 offset,\n\t\t\t\t\t     u32 val)\n{\n\twritel_relaxed(val, pcie->controller_base + offset);\n}\n\nstatic int al_pcie_rev_id_get(struct al_pcie *pcie, unsigned int *rev_id)\n{\n\tu32 dev_rev_id_val;\n\tu32 dev_id_val;\n\n\tdev_rev_id_val = al_pcie_controller_readl(pcie, AXI_BASE_OFFSET +\n\t\t\t\t\t\t  DEVICE_ID_OFFSET +\n\t\t\t\t\t\t  DEVICE_REV_ID);\n\tdev_id_val = FIELD_GET(DEVICE_REV_ID_DEV_ID_MASK, dev_rev_id_val);\n\n\tswitch (dev_id_val) {\n\tcase DEVICE_REV_ID_DEV_ID_X4:\n\t\t*rev_id = AL_PCIE_REV_ID_2;\n\t\tbreak;\n\tcase DEVICE_REV_ID_DEV_ID_X8:\n\t\t*rev_id = AL_PCIE_REV_ID_3;\n\t\tbreak;\n\tcase DEVICE_REV_ID_DEV_ID_X16:\n\t\t*rev_id = AL_PCIE_REV_ID_4;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(pcie->dev, \"Unsupported dev_id_val (0x%x)\\n\",\n\t\t\tdev_id_val);\n\t\treturn -EINVAL;\n\t}\n\n\tdev_dbg(pcie->dev, \"dev_id_val: 0x%x\\n\", dev_id_val);\n\n\treturn 0;\n}\n\nstatic int al_pcie_reg_offsets_set(struct al_pcie *pcie)\n{\n\tswitch (pcie->controller_rev_id) {\n\tcase AL_PCIE_REV_ID_2:\n\t\tpcie->reg_offsets.ob_ctrl = OB_CTRL_REV1_2_OFFSET;\n\t\tbreak;\n\tcase AL_PCIE_REV_ID_3:\n\tcase AL_PCIE_REV_ID_4:\n\t\tpcie->reg_offsets.ob_ctrl = OB_CTRL_REV3_5_OFFSET;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(pcie->dev, \"Unsupported controller rev_id: 0x%x\\n\",\n\t\t\tpcie->controller_rev_id);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic inline void al_pcie_target_bus_set(struct al_pcie *pcie,\n\t\t\t\t\t  u8 target_bus,\n\t\t\t\t\t  u8 mask_target_bus)\n{\n\tu32 reg;\n\n\treg = FIELD_PREP(CFG_TARGET_BUS_MASK_MASK, mask_target_bus) |\n\t      FIELD_PREP(CFG_TARGET_BUS_BUSNUM_MASK, target_bus);\n\n\tal_pcie_controller_writel(pcie, AXI_BASE_OFFSET +\n\t\t\t\t  pcie->reg_offsets.ob_ctrl + CFG_TARGET_BUS,\n\t\t\t\t  reg);\n}\n\nstatic void __iomem *al_pcie_conf_addr_map_bus(struct pci_bus *bus,\n\t\t\t\t\t       unsigned int devfn, int where)\n{\n\tstruct dw_pcie_rp *pp = bus->sysdata;\n\tstruct al_pcie *pcie = to_al_pcie(to_dw_pcie_from_pp(pp));\n\tunsigned int busnr = bus->number;\n\tstruct al_pcie_target_bus_cfg *target_bus_cfg = &pcie->target_bus_cfg;\n\tunsigned int busnr_ecam = busnr & target_bus_cfg->ecam_mask;\n\tunsigned int busnr_reg = busnr & target_bus_cfg->reg_mask;\n\n\tif (busnr_reg != target_bus_cfg->reg_val) {\n\t\tdev_dbg(pcie->pci->dev, \"Changing target bus busnum val from 0x%x to 0x%x\\n\",\n\t\t\ttarget_bus_cfg->reg_val, busnr_reg);\n\t\ttarget_bus_cfg->reg_val = busnr_reg;\n\t\tal_pcie_target_bus_set(pcie,\n\t\t\t\t       target_bus_cfg->reg_val,\n\t\t\t\t       target_bus_cfg->reg_mask);\n\t}\n\n\treturn pp->va_cfg0_base + PCIE_ECAM_OFFSET(busnr_ecam, devfn, where);\n}\n\nstatic struct pci_ops al_child_pci_ops = {\n\t.map_bus = al_pcie_conf_addr_map_bus,\n\t.read = pci_generic_config_read,\n\t.write = pci_generic_config_write,\n};\n\nstatic void al_pcie_config_prepare(struct al_pcie *pcie)\n{\n\tstruct al_pcie_target_bus_cfg *target_bus_cfg;\n\tstruct dw_pcie_rp *pp = &pcie->pci->pp;\n\tunsigned int ecam_bus_mask;\n\tu32 cfg_control_offset;\n\tu8 subordinate_bus;\n\tu8 secondary_bus;\n\tu32 cfg_control;\n\tu32 reg;\n\tstruct resource *bus = resource_list_first_type(&pp->bridge->windows, IORESOURCE_BUS)->res;\n\n\ttarget_bus_cfg = &pcie->target_bus_cfg;\n\n\tecam_bus_mask = (pcie->ecam_size >> PCIE_ECAM_BUS_SHIFT) - 1;\n\tif (ecam_bus_mask > 255) {\n\t\tdev_warn(pcie->dev, \"ECAM window size is larger than 256MB. Cutting off at 256\\n\");\n\t\tecam_bus_mask = 255;\n\t}\n\n\t \n\ttarget_bus_cfg->ecam_mask = ecam_bus_mask;\n\t \n\ttarget_bus_cfg->reg_mask = ~target_bus_cfg->ecam_mask;\n\ttarget_bus_cfg->reg_val = bus->start & target_bus_cfg->reg_mask;\n\n\tal_pcie_target_bus_set(pcie, target_bus_cfg->reg_val,\n\t\t\t       target_bus_cfg->reg_mask);\n\n\tsecondary_bus = bus->start + 1;\n\tsubordinate_bus = bus->end;\n\n\t \n\tcfg_control_offset = AXI_BASE_OFFSET + pcie->reg_offsets.ob_ctrl +\n\t\t\t     CFG_CONTROL;\n\n\tcfg_control = al_pcie_controller_readl(pcie, cfg_control_offset);\n\n\treg = cfg_control &\n\t      ~(CFG_CONTROL_SEC_BUS_MASK | CFG_CONTROL_SUBBUS_MASK);\n\n\treg |= FIELD_PREP(CFG_CONTROL_SUBBUS_MASK, subordinate_bus) |\n\t       FIELD_PREP(CFG_CONTROL_SEC_BUS_MASK, secondary_bus);\n\n\tal_pcie_controller_writel(pcie, cfg_control_offset, reg);\n}\n\nstatic int al_pcie_host_init(struct dw_pcie_rp *pp)\n{\n\tstruct dw_pcie *pci = to_dw_pcie_from_pp(pp);\n\tstruct al_pcie *pcie = to_al_pcie(pci);\n\tint rc;\n\n\tpp->bridge->child_ops = &al_child_pci_ops;\n\n\trc = al_pcie_rev_id_get(pcie, &pcie->controller_rev_id);\n\tif (rc)\n\t\treturn rc;\n\n\trc = al_pcie_reg_offsets_set(pcie);\n\tif (rc)\n\t\treturn rc;\n\n\tal_pcie_config_prepare(pcie);\n\n\treturn 0;\n}\n\nstatic const struct dw_pcie_host_ops al_pcie_host_ops = {\n\t.host_init = al_pcie_host_init,\n};\n\nstatic int al_pcie_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct resource *controller_res;\n\tstruct resource *ecam_res;\n\tstruct al_pcie *al_pcie;\n\tstruct dw_pcie *pci;\n\n\tal_pcie = devm_kzalloc(dev, sizeof(*al_pcie), GFP_KERNEL);\n\tif (!al_pcie)\n\t\treturn -ENOMEM;\n\n\tpci = devm_kzalloc(dev, sizeof(*pci), GFP_KERNEL);\n\tif (!pci)\n\t\treturn -ENOMEM;\n\n\tpci->dev = dev;\n\tpci->pp.ops = &al_pcie_host_ops;\n\n\tal_pcie->pci = pci;\n\tal_pcie->dev = dev;\n\n\tecam_res = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"config\");\n\tif (!ecam_res) {\n\t\tdev_err(dev, \"couldn't find 'config' reg in DT\\n\");\n\t\treturn -ENOENT;\n\t}\n\tal_pcie->ecam_size = resource_size(ecam_res);\n\n\tcontroller_res = platform_get_resource_byname(pdev, IORESOURCE_MEM,\n\t\t\t\t\t\t      \"controller\");\n\tal_pcie->controller_base = devm_ioremap_resource(dev, controller_res);\n\tif (IS_ERR(al_pcie->controller_base)) {\n\t\tdev_err(dev, \"couldn't remap controller base %pR\\n\",\n\t\t\tcontroller_res);\n\t\treturn PTR_ERR(al_pcie->controller_base);\n\t}\n\n\tdev_dbg(dev, \"From DT: controller_base: %pR\\n\", controller_res);\n\n\tplatform_set_drvdata(pdev, al_pcie);\n\n\treturn dw_pcie_host_init(&pci->pp);\n}\n\nstatic const struct of_device_id al_pcie_of_match[] = {\n\t{ .compatible = \"amazon,al-alpine-v2-pcie\",\n\t},\n\t{ .compatible = \"amazon,al-alpine-v3-pcie\",\n\t},\n\t{},\n};\n\nstatic struct platform_driver al_pcie_driver = {\n\t.driver = {\n\t\t.name\t= \"al-pcie\",\n\t\t.of_match_table = al_pcie_of_match,\n\t\t.suppress_bind_attrs = true,\n\t},\n\t.probe = al_pcie_probe,\n};\nbuiltin_platform_driver(al_pcie_driver);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}