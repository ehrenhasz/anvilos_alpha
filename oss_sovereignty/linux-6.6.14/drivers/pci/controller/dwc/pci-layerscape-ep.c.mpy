{
  "module_name": "pci-layerscape-ep.c",
  "hash_id": "f1855b4da6d12e1083c703ded861e0fd7098edc75afd20623f003e19018a4438",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/controller/dwc/pci-layerscape-ep.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/of_pci.h>\n#include <linux/of_platform.h>\n#include <linux/of_address.h>\n#include <linux/pci.h>\n#include <linux/platform_device.h>\n#include <linux/resource.h>\n\n#include \"pcie-designware.h\"\n\n#define PEX_PF0_CONFIG\t\t\t0xC0014\n#define PEX_PF0_CFG_READY\t\tBIT(0)\n\n \n#define PEX_PF0_PME_MES_DR\t\t0xC0020\n#define PEX_PF0_PME_MES_DR_LUD\t\tBIT(7)\n#define PEX_PF0_PME_MES_DR_LDD\t\tBIT(9)\n#define PEX_PF0_PME_MES_DR_HRD\t\tBIT(10)\n\n#define PEX_PF0_PME_MES_IER\t\t0xC0028\n#define PEX_PF0_PME_MES_IER_LUDIE\tBIT(7)\n#define PEX_PF0_PME_MES_IER_LDDIE\tBIT(9)\n#define PEX_PF0_PME_MES_IER_HRDIE\tBIT(10)\n\n#define to_ls_pcie_ep(x)\tdev_get_drvdata((x)->dev)\n\nstruct ls_pcie_ep_drvdata {\n\tu32\t\t\t\tfunc_offset;\n\tconst struct dw_pcie_ep_ops\t*ops;\n\tconst struct dw_pcie_ops\t*dw_pcie_ops;\n};\n\nstruct ls_pcie_ep {\n\tstruct dw_pcie\t\t\t*pci;\n\tstruct pci_epc_features\t\t*ls_epc;\n\tconst struct ls_pcie_ep_drvdata *drvdata;\n\tint\t\t\t\tirq;\n\tu32\t\t\t\tlnkcap;\n\tbool\t\t\t\tbig_endian;\n};\n\nstatic u32 ls_lut_readl(struct ls_pcie_ep *pcie, u32 offset)\n{\n\tstruct dw_pcie *pci = pcie->pci;\n\n\tif (pcie->big_endian)\n\t\treturn ioread32be(pci->dbi_base + offset);\n\telse\n\t\treturn ioread32(pci->dbi_base + offset);\n}\n\nstatic void ls_lut_writel(struct ls_pcie_ep *pcie, u32 offset, u32 value)\n{\n\tstruct dw_pcie *pci = pcie->pci;\n\n\tif (pcie->big_endian)\n\t\tiowrite32be(value, pci->dbi_base + offset);\n\telse\n\t\tiowrite32(value, pci->dbi_base + offset);\n}\n\nstatic irqreturn_t ls_pcie_ep_event_handler(int irq, void *dev_id)\n{\n\tstruct ls_pcie_ep *pcie = dev_id;\n\tstruct dw_pcie *pci = pcie->pci;\n\tu32 val, cfg;\n\tu8 offset;\n\n\tval = ls_lut_readl(pcie, PEX_PF0_PME_MES_DR);\n\tls_lut_writel(pcie, PEX_PF0_PME_MES_DR, val);\n\n\tif (!val)\n\t\treturn IRQ_NONE;\n\n\tif (val & PEX_PF0_PME_MES_DR_LUD) {\n\n\t\toffset = dw_pcie_find_capability(pci, PCI_CAP_ID_EXP);\n\n\t\t \n\t\tdw_pcie_dbi_ro_wr_en(pci);\n\t\tdw_pcie_writel_dbi(pci, offset + PCI_EXP_LNKCAP, pcie->lnkcap);\n\t\tdw_pcie_dbi_ro_wr_dis(pci);\n\n\t\tcfg = ls_lut_readl(pcie, PEX_PF0_CONFIG);\n\t\tcfg |= PEX_PF0_CFG_READY;\n\t\tls_lut_writel(pcie, PEX_PF0_CONFIG, cfg);\n\t\tdw_pcie_ep_linkup(&pci->ep);\n\n\t\tdev_dbg(pci->dev, \"Link up\\n\");\n\t} else if (val & PEX_PF0_PME_MES_DR_LDD) {\n\t\tdev_dbg(pci->dev, \"Link down\\n\");\n\t\tpci_epc_linkdown(pci->ep.epc);\n\t} else if (val & PEX_PF0_PME_MES_DR_HRD) {\n\t\tdev_dbg(pci->dev, \"Hot reset\\n\");\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int ls_pcie_ep_interrupt_init(struct ls_pcie_ep *pcie,\n\t\t\t\t     struct platform_device *pdev)\n{\n\tu32 val;\n\tint ret;\n\n\tpcie->irq = platform_get_irq_byname(pdev, \"pme\");\n\tif (pcie->irq < 0)\n\t\treturn pcie->irq;\n\n\tret = devm_request_irq(&pdev->dev, pcie->irq, ls_pcie_ep_event_handler,\n\t\t\t       IRQF_SHARED, pdev->name, pcie);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Can't register PCIe IRQ\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tval = ls_lut_readl(pcie, PEX_PF0_PME_MES_IER);\n\tval |=  PEX_PF0_PME_MES_IER_LDDIE | PEX_PF0_PME_MES_IER_HRDIE |\n\t\tPEX_PF0_PME_MES_IER_LUDIE;\n\tls_lut_writel(pcie, PEX_PF0_PME_MES_IER, val);\n\n\treturn 0;\n}\n\nstatic const struct pci_epc_features*\nls_pcie_ep_get_features(struct dw_pcie_ep *ep)\n{\n\tstruct dw_pcie *pci = to_dw_pcie_from_ep(ep);\n\tstruct ls_pcie_ep *pcie = to_ls_pcie_ep(pci);\n\n\treturn pcie->ls_epc;\n}\n\nstatic void ls_pcie_ep_init(struct dw_pcie_ep *ep)\n{\n\tstruct dw_pcie *pci = to_dw_pcie_from_ep(ep);\n\tstruct ls_pcie_ep *pcie = to_ls_pcie_ep(pci);\n\tstruct dw_pcie_ep_func *ep_func;\n\tenum pci_barno bar;\n\n\tep_func = dw_pcie_ep_get_func_from_ep(ep, 0);\n\tif (!ep_func)\n\t\treturn;\n\n\tfor (bar = 0; bar < PCI_STD_NUM_BARS; bar++)\n\t\tdw_pcie_ep_reset_bar(pci, bar);\n\n\tpcie->ls_epc->msi_capable = ep_func->msi_cap ? true : false;\n\tpcie->ls_epc->msix_capable = ep_func->msix_cap ? true : false;\n}\n\nstatic int ls_pcie_ep_raise_irq(struct dw_pcie_ep *ep, u8 func_no,\n\t\t\t\tenum pci_epc_irq_type type, u16 interrupt_num)\n{\n\tstruct dw_pcie *pci = to_dw_pcie_from_ep(ep);\n\n\tswitch (type) {\n\tcase PCI_EPC_IRQ_LEGACY:\n\t\treturn dw_pcie_ep_raise_legacy_irq(ep, func_no);\n\tcase PCI_EPC_IRQ_MSI:\n\t\treturn dw_pcie_ep_raise_msi_irq(ep, func_no, interrupt_num);\n\tcase PCI_EPC_IRQ_MSIX:\n\t\treturn dw_pcie_ep_raise_msix_irq_doorbell(ep, func_no,\n\t\t\t\t\t\t\t  interrupt_num);\n\tdefault:\n\t\tdev_err(pci->dev, \"UNKNOWN IRQ type\\n\");\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic unsigned int ls_pcie_ep_func_conf_select(struct dw_pcie_ep *ep,\n\t\t\t\t\t\tu8 func_no)\n{\n\tstruct dw_pcie *pci = to_dw_pcie_from_ep(ep);\n\tstruct ls_pcie_ep *pcie = to_ls_pcie_ep(pci);\n\n\tWARN_ON(func_no && !pcie->drvdata->func_offset);\n\treturn pcie->drvdata->func_offset * func_no;\n}\n\nstatic const struct dw_pcie_ep_ops ls_pcie_ep_ops = {\n\t.ep_init = ls_pcie_ep_init,\n\t.raise_irq = ls_pcie_ep_raise_irq,\n\t.get_features = ls_pcie_ep_get_features,\n\t.func_conf_select = ls_pcie_ep_func_conf_select,\n};\n\nstatic const struct ls_pcie_ep_drvdata ls1_ep_drvdata = {\n\t.ops = &ls_pcie_ep_ops,\n};\n\nstatic const struct ls_pcie_ep_drvdata ls2_ep_drvdata = {\n\t.func_offset = 0x20000,\n\t.ops = &ls_pcie_ep_ops,\n};\n\nstatic const struct ls_pcie_ep_drvdata lx2_ep_drvdata = {\n\t.func_offset = 0x8000,\n\t.ops = &ls_pcie_ep_ops,\n};\n\nstatic const struct of_device_id ls_pcie_ep_of_match[] = {\n\t{ .compatible = \"fsl,ls1028a-pcie-ep\", .data = &ls1_ep_drvdata },\n\t{ .compatible = \"fsl,ls1046a-pcie-ep\", .data = &ls1_ep_drvdata },\n\t{ .compatible = \"fsl,ls1088a-pcie-ep\", .data = &ls2_ep_drvdata },\n\t{ .compatible = \"fsl,ls2088a-pcie-ep\", .data = &ls2_ep_drvdata },\n\t{ .compatible = \"fsl,lx2160ar2-pcie-ep\", .data = &lx2_ep_drvdata },\n\t{ },\n};\n\nstatic int __init ls_pcie_ep_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct dw_pcie *pci;\n\tstruct ls_pcie_ep *pcie;\n\tstruct pci_epc_features *ls_epc;\n\tstruct resource *dbi_base;\n\tu8 offset;\n\tint ret;\n\n\tpcie = devm_kzalloc(dev, sizeof(*pcie), GFP_KERNEL);\n\tif (!pcie)\n\t\treturn -ENOMEM;\n\n\tpci = devm_kzalloc(dev, sizeof(*pci), GFP_KERNEL);\n\tif (!pci)\n\t\treturn -ENOMEM;\n\n\tls_epc = devm_kzalloc(dev, sizeof(*ls_epc), GFP_KERNEL);\n\tif (!ls_epc)\n\t\treturn -ENOMEM;\n\n\tpcie->drvdata = of_device_get_match_data(dev);\n\n\tpci->dev = dev;\n\tpci->ops = pcie->drvdata->dw_pcie_ops;\n\n\tls_epc->bar_fixed_64bit = (1 << BAR_2) | (1 << BAR_4);\n\tls_epc->linkup_notifier = true;\n\n\tpcie->pci = pci;\n\tpcie->ls_epc = ls_epc;\n\n\tdbi_base = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"regs\");\n\tpci->dbi_base = devm_pci_remap_cfg_resource(dev, dbi_base);\n\tif (IS_ERR(pci->dbi_base))\n\t\treturn PTR_ERR(pci->dbi_base);\n\n\tpci->ep.ops = &ls_pcie_ep_ops;\n\n\tpcie->big_endian = of_property_read_bool(dev->of_node, \"big-endian\");\n\n\tplatform_set_drvdata(pdev, pcie);\n\n\toffset = dw_pcie_find_capability(pci, PCI_CAP_ID_EXP);\n\tpcie->lnkcap = dw_pcie_readl_dbi(pci, offset + PCI_EXP_LNKCAP);\n\n\tret = dw_pcie_ep_init(&pci->ep);\n\tif (ret)\n\t\treturn ret;\n\n\treturn ls_pcie_ep_interrupt_init(pcie, pdev);\n}\n\nstatic struct platform_driver ls_pcie_ep_driver = {\n\t.driver = {\n\t\t.name = \"layerscape-pcie-ep\",\n\t\t.of_match_table = ls_pcie_ep_of_match,\n\t\t.suppress_bind_attrs = true,\n\t},\n};\nbuiltin_platform_driver_probe(ls_pcie_ep_driver, ls_pcie_ep_probe);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}