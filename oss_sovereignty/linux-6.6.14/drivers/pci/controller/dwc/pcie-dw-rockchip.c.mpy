{
  "module_name": "pcie-dw-rockchip.c",
  "hash_id": "8483ec67bb54e5059aadb3016819c9aa0eea3f56afb7cde7fa1e766cdd6a3bb5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/controller/dwc/pcie-dw-rockchip.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/gpio/consumer.h>\n#include <linux/irqchip/chained_irq.h>\n#include <linux/irqdomain.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_irq.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/reset.h>\n\n#include \"pcie-designware.h\"\n\n \n#define HIWORD_UPDATE(mask, val) (((mask) << 16) | (val))\n#define HIWORD_UPDATE_BIT(val)\tHIWORD_UPDATE(val, val)\n#define HIWORD_DISABLE_BIT(val)\tHIWORD_UPDATE(val, ~val)\n\n#define to_rockchip_pcie(x) dev_get_drvdata((x)->dev)\n\n#define PCIE_CLIENT_RC_MODE\t\tHIWORD_UPDATE_BIT(0x40)\n#define PCIE_CLIENT_ENABLE_LTSSM\tHIWORD_UPDATE_BIT(0xc)\n#define PCIE_SMLH_LINKUP\t\tBIT(16)\n#define PCIE_RDLH_LINKUP\t\tBIT(17)\n#define PCIE_LINKUP\t\t\t(PCIE_SMLH_LINKUP | PCIE_RDLH_LINKUP)\n#define PCIE_L0S_ENTRY\t\t\t0x11\n#define PCIE_CLIENT_GENERAL_CONTROL\t0x0\n#define PCIE_CLIENT_INTR_STATUS_LEGACY\t0x8\n#define PCIE_CLIENT_INTR_MASK_LEGACY\t0x1c\n#define PCIE_CLIENT_GENERAL_DEBUG\t0x104\n#define PCIE_CLIENT_HOT_RESET_CTRL\t0x180\n#define PCIE_CLIENT_LTSSM_STATUS\t0x300\n#define PCIE_LTSSM_ENABLE_ENHANCE\tBIT(4)\n#define PCIE_LTSSM_STATUS_MASK\t\tGENMASK(5, 0)\n\nstruct rockchip_pcie {\n\tstruct dw_pcie\t\t\tpci;\n\tvoid __iomem\t\t\t*apb_base;\n\tstruct phy\t\t\t*phy;\n\tstruct clk_bulk_data\t\t*clks;\n\tunsigned int\t\t\tclk_cnt;\n\tstruct reset_control\t\t*rst;\n\tstruct gpio_desc\t\t*rst_gpio;\n\tstruct regulator                *vpcie3v3;\n\tstruct irq_domain\t\t*irq_domain;\n};\n\nstatic int rockchip_pcie_readl_apb(struct rockchip_pcie *rockchip,\n\t\t\t\t\t     u32 reg)\n{\n\treturn readl_relaxed(rockchip->apb_base + reg);\n}\n\nstatic void rockchip_pcie_writel_apb(struct rockchip_pcie *rockchip,\n\t\t\t\t\t\tu32 val, u32 reg)\n{\n\twritel_relaxed(val, rockchip->apb_base + reg);\n}\n\nstatic void rockchip_pcie_legacy_int_handler(struct irq_desc *desc)\n{\n\tstruct irq_chip *chip = irq_desc_get_chip(desc);\n\tstruct rockchip_pcie *rockchip = irq_desc_get_handler_data(desc);\n\tunsigned long reg, hwirq;\n\n\tchained_irq_enter(chip, desc);\n\n\treg = rockchip_pcie_readl_apb(rockchip, PCIE_CLIENT_INTR_STATUS_LEGACY);\n\n\tfor_each_set_bit(hwirq, &reg, 4)\n\t\tgeneric_handle_domain_irq(rockchip->irq_domain, hwirq);\n\n\tchained_irq_exit(chip, desc);\n}\n\nstatic void rockchip_intx_mask(struct irq_data *data)\n{\n\trockchip_pcie_writel_apb(irq_data_get_irq_chip_data(data),\n\t\t\t\t HIWORD_UPDATE_BIT(BIT(data->hwirq)),\n\t\t\t\t PCIE_CLIENT_INTR_MASK_LEGACY);\n};\n\nstatic void rockchip_intx_unmask(struct irq_data *data)\n{\n\trockchip_pcie_writel_apb(irq_data_get_irq_chip_data(data),\n\t\t\t\t HIWORD_DISABLE_BIT(BIT(data->hwirq)),\n\t\t\t\t PCIE_CLIENT_INTR_MASK_LEGACY);\n};\n\nstatic struct irq_chip rockchip_intx_irq_chip = {\n\t.name\t\t\t= \"INTx\",\n\t.irq_mask\t\t= rockchip_intx_mask,\n\t.irq_unmask\t\t= rockchip_intx_unmask,\n\t.flags\t\t\t= IRQCHIP_SKIP_SET_WAKE | IRQCHIP_MASK_ON_SUSPEND,\n};\n\nstatic int rockchip_pcie_intx_map(struct irq_domain *domain, unsigned int irq,\n\t\t\t\t  irq_hw_number_t hwirq)\n{\n\tirq_set_chip_and_handler(irq, &rockchip_intx_irq_chip, handle_level_irq);\n\tirq_set_chip_data(irq, domain->host_data);\n\n\treturn 0;\n}\n\nstatic const struct irq_domain_ops intx_domain_ops = {\n\t.map = rockchip_pcie_intx_map,\n};\n\nstatic int rockchip_pcie_init_irq_domain(struct rockchip_pcie *rockchip)\n{\n\tstruct device *dev = rockchip->pci.dev;\n\tstruct device_node *intc;\n\n\tintc = of_get_child_by_name(dev->of_node, \"legacy-interrupt-controller\");\n\tif (!intc) {\n\t\tdev_err(dev, \"missing child interrupt-controller node\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\trockchip->irq_domain = irq_domain_add_linear(intc, PCI_NUM_INTX,\n\t\t\t\t\t\t    &intx_domain_ops, rockchip);\n\tof_node_put(intc);\n\tif (!rockchip->irq_domain) {\n\t\tdev_err(dev, \"failed to get a INTx IRQ domain\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void rockchip_pcie_enable_ltssm(struct rockchip_pcie *rockchip)\n{\n\trockchip_pcie_writel_apb(rockchip, PCIE_CLIENT_ENABLE_LTSSM,\n\t\t\t\t PCIE_CLIENT_GENERAL_CONTROL);\n}\n\nstatic int rockchip_pcie_link_up(struct dw_pcie *pci)\n{\n\tstruct rockchip_pcie *rockchip = to_rockchip_pcie(pci);\n\tu32 val = rockchip_pcie_readl_apb(rockchip, PCIE_CLIENT_LTSSM_STATUS);\n\n\tif ((val & PCIE_LINKUP) == PCIE_LINKUP &&\n\t    (val & PCIE_LTSSM_STATUS_MASK) == PCIE_L0S_ENTRY)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic int rockchip_pcie_start_link(struct dw_pcie *pci)\n{\n\tstruct rockchip_pcie *rockchip = to_rockchip_pcie(pci);\n\n\t \n\tgpiod_set_value_cansleep(rockchip->rst_gpio, 0);\n\n\trockchip_pcie_enable_ltssm(rockchip);\n\n\t \n\tmsleep(100);\n\tgpiod_set_value_cansleep(rockchip->rst_gpio, 1);\n\n\treturn 0;\n}\n\nstatic int rockchip_pcie_host_init(struct dw_pcie_rp *pp)\n{\n\tstruct dw_pcie *pci = to_dw_pcie_from_pp(pp);\n\tstruct rockchip_pcie *rockchip = to_rockchip_pcie(pci);\n\tstruct device *dev = rockchip->pci.dev;\n\tu32 val = HIWORD_UPDATE_BIT(PCIE_LTSSM_ENABLE_ENHANCE);\n\tint irq, ret;\n\n\tirq = of_irq_get_byname(dev->of_node, \"legacy\");\n\tif (irq < 0)\n\t\treturn irq;\n\n\tret = rockchip_pcie_init_irq_domain(rockchip);\n\tif (ret < 0)\n\t\tdev_err(dev, \"failed to init irq domain\\n\");\n\n\tirq_set_chained_handler_and_data(irq, rockchip_pcie_legacy_int_handler,\n\t\t\t\t\t rockchip);\n\n\t \n\trockchip_pcie_writel_apb(rockchip, val, PCIE_CLIENT_HOT_RESET_CTRL);\n\n\trockchip_pcie_writel_apb(rockchip, PCIE_CLIENT_RC_MODE,\n\t\t\t\t PCIE_CLIENT_GENERAL_CONTROL);\n\n\treturn 0;\n}\n\nstatic const struct dw_pcie_host_ops rockchip_pcie_host_ops = {\n\t.host_init = rockchip_pcie_host_init,\n};\n\nstatic int rockchip_pcie_clk_init(struct rockchip_pcie *rockchip)\n{\n\tstruct device *dev = rockchip->pci.dev;\n\tint ret;\n\n\tret = devm_clk_bulk_get_all(dev, &rockchip->clks);\n\tif (ret < 0)\n\t\treturn ret;\n\n\trockchip->clk_cnt = ret;\n\n\treturn clk_bulk_prepare_enable(rockchip->clk_cnt, rockchip->clks);\n}\n\nstatic int rockchip_pcie_resource_get(struct platform_device *pdev,\n\t\t\t\t      struct rockchip_pcie *rockchip)\n{\n\trockchip->apb_base = devm_platform_ioremap_resource_byname(pdev, \"apb\");\n\tif (IS_ERR(rockchip->apb_base))\n\t\treturn PTR_ERR(rockchip->apb_base);\n\n\trockchip->rst_gpio = devm_gpiod_get_optional(&pdev->dev, \"reset\",\n\t\t\t\t\t\t     GPIOD_OUT_HIGH);\n\tif (IS_ERR(rockchip->rst_gpio))\n\t\treturn PTR_ERR(rockchip->rst_gpio);\n\n\trockchip->rst = devm_reset_control_array_get_exclusive(&pdev->dev);\n\tif (IS_ERR(rockchip->rst))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(rockchip->rst),\n\t\t\t\t     \"failed to get reset lines\\n\");\n\n\treturn 0;\n}\n\nstatic int rockchip_pcie_phy_init(struct rockchip_pcie *rockchip)\n{\n\tstruct device *dev = rockchip->pci.dev;\n\tint ret;\n\n\trockchip->phy = devm_phy_get(dev, \"pcie-phy\");\n\tif (IS_ERR(rockchip->phy))\n\t\treturn dev_err_probe(dev, PTR_ERR(rockchip->phy),\n\t\t\t\t     \"missing PHY\\n\");\n\n\tret = phy_init(rockchip->phy);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = phy_power_on(rockchip->phy);\n\tif (ret)\n\t\tphy_exit(rockchip->phy);\n\n\treturn ret;\n}\n\nstatic void rockchip_pcie_phy_deinit(struct rockchip_pcie *rockchip)\n{\n\tphy_exit(rockchip->phy);\n\tphy_power_off(rockchip->phy);\n}\n\nstatic const struct dw_pcie_ops dw_pcie_ops = {\n\t.link_up = rockchip_pcie_link_up,\n\t.start_link = rockchip_pcie_start_link,\n};\n\nstatic int rockchip_pcie_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct rockchip_pcie *rockchip;\n\tstruct dw_pcie_rp *pp;\n\tint ret;\n\n\trockchip = devm_kzalloc(dev, sizeof(*rockchip), GFP_KERNEL);\n\tif (!rockchip)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, rockchip);\n\n\trockchip->pci.dev = dev;\n\trockchip->pci.ops = &dw_pcie_ops;\n\n\tpp = &rockchip->pci.pp;\n\tpp->ops = &rockchip_pcie_host_ops;\n\n\tret = rockchip_pcie_resource_get(pdev, rockchip);\n\tif (ret)\n\t\treturn ret;\n\n\tret = reset_control_assert(rockchip->rst);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\trockchip->vpcie3v3 = devm_regulator_get_optional(dev, \"vpcie3v3\");\n\tif (IS_ERR(rockchip->vpcie3v3)) {\n\t\tif (PTR_ERR(rockchip->vpcie3v3) != -ENODEV)\n\t\t\treturn dev_err_probe(dev, PTR_ERR(rockchip->vpcie3v3),\n\t\t\t\t\t\"failed to get vpcie3v3 regulator\\n\");\n\t\trockchip->vpcie3v3 = NULL;\n\t} else {\n\t\tret = regulator_enable(rockchip->vpcie3v3);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"failed to enable vpcie3v3 regulator\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = rockchip_pcie_phy_init(rockchip);\n\tif (ret)\n\t\tgoto disable_regulator;\n\n\tret = reset_control_deassert(rockchip->rst);\n\tif (ret)\n\t\tgoto deinit_phy;\n\n\tret = rockchip_pcie_clk_init(rockchip);\n\tif (ret)\n\t\tgoto deinit_phy;\n\n\tret = dw_pcie_host_init(pp);\n\tif (!ret)\n\t\treturn 0;\n\n\tclk_bulk_disable_unprepare(rockchip->clk_cnt, rockchip->clks);\ndeinit_phy:\n\trockchip_pcie_phy_deinit(rockchip);\ndisable_regulator:\n\tif (rockchip->vpcie3v3)\n\t\tregulator_disable(rockchip->vpcie3v3);\n\n\treturn ret;\n}\n\nstatic const struct of_device_id rockchip_pcie_of_match[] = {\n\t{ .compatible = \"rockchip,rk3568-pcie\", },\n\t{},\n};\n\nstatic struct platform_driver rockchip_pcie_driver = {\n\t.driver = {\n\t\t.name\t= \"rockchip-dw-pcie\",\n\t\t.of_match_table = rockchip_pcie_of_match,\n\t\t.suppress_bind_attrs = true,\n\t},\n\t.probe = rockchip_pcie_probe,\n};\nbuiltin_platform_driver(rockchip_pcie_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}