{
  "module_name": "pcie-keembay.c",
  "hash_id": "ab35d32c1b883cbf1660b8d549e7a744405cced7e1498614ed34b5f74e3bf7ad",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/controller/dwc/pcie-keembay.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/bits.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/gpio/consumer.h>\n#include <linux/init.h>\n#include <linux/iopoll.h>\n#include <linux/irqchip/chained_irq.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/pci.h>\n#include <linux/platform_device.h>\n#include <linux/property.h>\n\n#include \"pcie-designware.h\"\n\n \n#define PCIE_REGS_PCIE_CFG\t\t0x0004\n#define  PCIE_DEVICE_TYPE\t\tBIT(8)\n#define  PCIE_RSTN\t\t\tBIT(0)\n#define PCIE_REGS_PCIE_APP_CNTRL\t0x0008\n#define  APP_LTSSM_ENABLE\t\tBIT(0)\n#define PCIE_REGS_INTERRUPT_ENABLE\t0x0028\n#define  MSI_CTRL_INT_EN\t\tBIT(8)\n#define  EDMA_INT_EN\t\t\tGENMASK(7, 0)\n#define PCIE_REGS_INTERRUPT_STATUS\t0x002c\n#define  MSI_CTRL_INT\t\t\tBIT(8)\n#define PCIE_REGS_PCIE_SII_PM_STATE\t0x00b0\n#define  SMLH_LINK_UP\t\t\tBIT(19)\n#define  RDLH_LINK_UP\t\t\tBIT(8)\n#define  PCIE_REGS_PCIE_SII_LINK_UP\t(SMLH_LINK_UP | RDLH_LINK_UP)\n#define PCIE_REGS_PCIE_PHY_CNTL\t\t0x0164\n#define  PHY0_SRAM_BYPASS\t\tBIT(8)\n#define PCIE_REGS_PCIE_PHY_STAT\t\t0x0168\n#define  PHY0_MPLLA_STATE\t\tBIT(1)\n#define PCIE_REGS_LJPLL_STA\t\t0x016c\n#define  LJPLL_LOCK\t\t\tBIT(0)\n#define PCIE_REGS_LJPLL_CNTRL_0\t\t0x0170\n#define  LJPLL_EN\t\t\tBIT(29)\n#define  LJPLL_FOUT_EN\t\t\tGENMASK(24, 21)\n#define PCIE_REGS_LJPLL_CNTRL_2\t\t0x0178\n#define  LJPLL_REF_DIV\t\t\tGENMASK(17, 12)\n#define  LJPLL_FB_DIV\t\t\tGENMASK(11, 0)\n#define PCIE_REGS_LJPLL_CNTRL_3\t\t0x017c\n#define  LJPLL_POST_DIV3A\t\tGENMASK(24, 22)\n#define  LJPLL_POST_DIV2A\t\tGENMASK(18, 16)\n\n#define PERST_DELAY_US\t\t1000\n#define AUX_CLK_RATE_HZ\t\t24000000\n\nstruct keembay_pcie {\n\tstruct dw_pcie\t\tpci;\n\tvoid __iomem\t\t*apb_base;\n\tenum dw_pcie_device_mode mode;\n\n\tstruct clk\t\t*clk_master;\n\tstruct clk\t\t*clk_aux;\n\tstruct gpio_desc\t*reset;\n};\n\nstruct keembay_pcie_of_data {\n\tenum dw_pcie_device_mode mode;\n};\n\nstatic void keembay_ep_reset_assert(struct keembay_pcie *pcie)\n{\n\tgpiod_set_value_cansleep(pcie->reset, 1);\n\tusleep_range(PERST_DELAY_US, PERST_DELAY_US + 500);\n}\n\nstatic void keembay_ep_reset_deassert(struct keembay_pcie *pcie)\n{\n\t \n\tmsleep(100);\n\n\tgpiod_set_value_cansleep(pcie->reset, 0);\n\tusleep_range(PERST_DELAY_US, PERST_DELAY_US + 500);\n}\n\nstatic void keembay_pcie_ltssm_set(struct keembay_pcie *pcie, bool enable)\n{\n\tu32 val;\n\n\tval = readl(pcie->apb_base + PCIE_REGS_PCIE_APP_CNTRL);\n\tif (enable)\n\t\tval |= APP_LTSSM_ENABLE;\n\telse\n\t\tval &= ~APP_LTSSM_ENABLE;\n\twritel(val, pcie->apb_base + PCIE_REGS_PCIE_APP_CNTRL);\n}\n\nstatic int keembay_pcie_link_up(struct dw_pcie *pci)\n{\n\tstruct keembay_pcie *pcie = dev_get_drvdata(pci->dev);\n\tu32 val;\n\n\tval = readl(pcie->apb_base + PCIE_REGS_PCIE_SII_PM_STATE);\n\n\treturn (val & PCIE_REGS_PCIE_SII_LINK_UP) == PCIE_REGS_PCIE_SII_LINK_UP;\n}\n\nstatic int keembay_pcie_start_link(struct dw_pcie *pci)\n{\n\tstruct keembay_pcie *pcie = dev_get_drvdata(pci->dev);\n\tu32 val;\n\tint ret;\n\n\tif (pcie->mode == DW_PCIE_EP_TYPE)\n\t\treturn 0;\n\n\tkeembay_pcie_ltssm_set(pcie, false);\n\n\tret = readl_poll_timeout(pcie->apb_base + PCIE_REGS_PCIE_PHY_STAT,\n\t\t\t\t val, val & PHY0_MPLLA_STATE, 20,\n\t\t\t\t 500 * USEC_PER_MSEC);\n\tif (ret) {\n\t\tdev_err(pci->dev, \"MPLLA is not locked\\n\");\n\t\treturn ret;\n\t}\n\n\tkeembay_pcie_ltssm_set(pcie, true);\n\n\treturn 0;\n}\n\nstatic void keembay_pcie_stop_link(struct dw_pcie *pci)\n{\n\tstruct keembay_pcie *pcie = dev_get_drvdata(pci->dev);\n\n\tkeembay_pcie_ltssm_set(pcie, false);\n}\n\nstatic const struct dw_pcie_ops keembay_pcie_ops = {\n\t.link_up\t= keembay_pcie_link_up,\n\t.start_link\t= keembay_pcie_start_link,\n\t.stop_link\t= keembay_pcie_stop_link,\n};\n\nstatic inline void keembay_pcie_disable_clock(void *data)\n{\n\tstruct clk *clk = data;\n\n\tclk_disable_unprepare(clk);\n}\n\nstatic inline struct clk *keembay_pcie_probe_clock(struct device *dev,\n\t\t\t\t\t\t   const char *id, u64 rate)\n{\n\tstruct clk *clk;\n\tint ret;\n\n\tclk = devm_clk_get(dev, id);\n\tif (IS_ERR(clk))\n\t\treturn clk;\n\n\tif (rate) {\n\t\tret = clk_set_rate(clk, rate);\n\t\tif (ret)\n\t\t\treturn ERR_PTR(ret);\n\t}\n\n\tret = clk_prepare_enable(clk);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tret = devm_add_action_or_reset(dev, keembay_pcie_disable_clock, clk);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\treturn clk;\n}\n\nstatic int keembay_pcie_probe_clocks(struct keembay_pcie *pcie)\n{\n\tstruct dw_pcie *pci = &pcie->pci;\n\tstruct device *dev = pci->dev;\n\n\tpcie->clk_master = keembay_pcie_probe_clock(dev, \"master\", 0);\n\tif (IS_ERR(pcie->clk_master))\n\t\treturn dev_err_probe(dev, PTR_ERR(pcie->clk_master),\n\t\t\t\t     \"Failed to enable master clock\");\n\n\tpcie->clk_aux = keembay_pcie_probe_clock(dev, \"aux\", AUX_CLK_RATE_HZ);\n\tif (IS_ERR(pcie->clk_aux))\n\t\treturn dev_err_probe(dev, PTR_ERR(pcie->clk_aux),\n\t\t\t\t     \"Failed to enable auxiliary clock\");\n\n\treturn 0;\n}\n\n \nstatic int keembay_pcie_pll_init(struct keembay_pcie *pcie)\n{\n\tstruct dw_pcie *pci = &pcie->pci;\n\tu32 val;\n\tint ret;\n\n\tval = FIELD_PREP(LJPLL_REF_DIV, 0) | FIELD_PREP(LJPLL_FB_DIV, 0x32);\n\twritel(val, pcie->apb_base + PCIE_REGS_LJPLL_CNTRL_2);\n\n\tval = FIELD_PREP(LJPLL_POST_DIV3A, 0x2) |\n\t\tFIELD_PREP(LJPLL_POST_DIV2A, 0x2);\n\twritel(val, pcie->apb_base + PCIE_REGS_LJPLL_CNTRL_3);\n\n\tval = FIELD_PREP(LJPLL_EN, 0x1) | FIELD_PREP(LJPLL_FOUT_EN, 0xc);\n\twritel(val, pcie->apb_base + PCIE_REGS_LJPLL_CNTRL_0);\n\n\tret = readl_poll_timeout(pcie->apb_base + PCIE_REGS_LJPLL_STA,\n\t\t\t\t val, val & LJPLL_LOCK, 20,\n\t\t\t\t 500 * USEC_PER_MSEC);\n\tif (ret)\n\t\tdev_err(pci->dev, \"Low jitter PLL is not locked\\n\");\n\n\treturn ret;\n}\n\nstatic void keembay_pcie_msi_irq_handler(struct irq_desc *desc)\n{\n\tstruct keembay_pcie *pcie = irq_desc_get_handler_data(desc);\n\tstruct irq_chip *chip = irq_desc_get_chip(desc);\n\tu32 val, mask, status;\n\tstruct dw_pcie_rp *pp;\n\n\t \n\n\tchained_irq_enter(chip, desc);\n\n\tpp = &pcie->pci.pp;\n\tval = readl(pcie->apb_base + PCIE_REGS_INTERRUPT_STATUS);\n\tmask = readl(pcie->apb_base + PCIE_REGS_INTERRUPT_ENABLE);\n\n\tstatus = val & mask;\n\n\tif (status & MSI_CTRL_INT) {\n\t\tdw_handle_msi_irq(pp);\n\t\twritel(status, pcie->apb_base + PCIE_REGS_INTERRUPT_STATUS);\n\t}\n\n\tchained_irq_exit(chip, desc);\n}\n\nstatic int keembay_pcie_setup_msi_irq(struct keembay_pcie *pcie)\n{\n\tstruct dw_pcie *pci = &pcie->pci;\n\tstruct device *dev = pci->dev;\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tint irq;\n\n\tirq = platform_get_irq_byname(pdev, \"pcie\");\n\tif (irq < 0)\n\t\treturn irq;\n\n\tirq_set_chained_handler_and_data(irq, keembay_pcie_msi_irq_handler,\n\t\t\t\t\t pcie);\n\n\treturn 0;\n}\n\nstatic void keembay_pcie_ep_init(struct dw_pcie_ep *ep)\n{\n\tstruct dw_pcie *pci = to_dw_pcie_from_ep(ep);\n\tstruct keembay_pcie *pcie = dev_get_drvdata(pci->dev);\n\n\twritel(EDMA_INT_EN, pcie->apb_base + PCIE_REGS_INTERRUPT_ENABLE);\n}\n\nstatic int keembay_pcie_ep_raise_irq(struct dw_pcie_ep *ep, u8 func_no,\n\t\t\t\t     enum pci_epc_irq_type type,\n\t\t\t\t     u16 interrupt_num)\n{\n\tstruct dw_pcie *pci = to_dw_pcie_from_ep(ep);\n\n\tswitch (type) {\n\tcase PCI_EPC_IRQ_LEGACY:\n\t\t \n\t\tdev_err(pci->dev, \"Legacy IRQ is not supported\\n\");\n\t\treturn -EINVAL;\n\tcase PCI_EPC_IRQ_MSI:\n\t\treturn dw_pcie_ep_raise_msi_irq(ep, func_no, interrupt_num);\n\tcase PCI_EPC_IRQ_MSIX:\n\t\treturn dw_pcie_ep_raise_msix_irq(ep, func_no, interrupt_num);\n\tdefault:\n\t\tdev_err(pci->dev, \"Unknown IRQ type %d\\n\", type);\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const struct pci_epc_features keembay_pcie_epc_features = {\n\t.linkup_notifier\t= false,\n\t.msi_capable\t\t= true,\n\t.msix_capable\t\t= true,\n\t.reserved_bar\t\t= BIT(BAR_1) | BIT(BAR_3) | BIT(BAR_5),\n\t.bar_fixed_64bit\t= BIT(BAR_0) | BIT(BAR_2) | BIT(BAR_4),\n\t.align\t\t\t= SZ_16K,\n};\n\nstatic const struct pci_epc_features *\nkeembay_pcie_get_features(struct dw_pcie_ep *ep)\n{\n\treturn &keembay_pcie_epc_features;\n}\n\nstatic const struct dw_pcie_ep_ops keembay_pcie_ep_ops = {\n\t.ep_init\t= keembay_pcie_ep_init,\n\t.raise_irq\t= keembay_pcie_ep_raise_irq,\n\t.get_features\t= keembay_pcie_get_features,\n};\n\nstatic const struct dw_pcie_host_ops keembay_pcie_host_ops = {\n};\n\nstatic int keembay_pcie_add_pcie_port(struct keembay_pcie *pcie,\n\t\t\t\t      struct platform_device *pdev)\n{\n\tstruct dw_pcie *pci = &pcie->pci;\n\tstruct dw_pcie_rp *pp = &pci->pp;\n\tstruct device *dev = &pdev->dev;\n\tu32 val;\n\tint ret;\n\n\tpp->ops = &keembay_pcie_host_ops;\n\tpp->msi_irq[0] = -ENODEV;\n\n\tret = keembay_pcie_setup_msi_irq(pcie);\n\tif (ret)\n\t\treturn ret;\n\n\tpcie->reset = devm_gpiod_get(dev, \"reset\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(pcie->reset))\n\t\treturn PTR_ERR(pcie->reset);\n\n\tret = keembay_pcie_probe_clocks(pcie);\n\tif (ret)\n\t\treturn ret;\n\n\tval = readl(pcie->apb_base + PCIE_REGS_PCIE_PHY_CNTL);\n\tval |= PHY0_SRAM_BYPASS;\n\twritel(val, pcie->apb_base + PCIE_REGS_PCIE_PHY_CNTL);\n\n\twritel(PCIE_DEVICE_TYPE, pcie->apb_base + PCIE_REGS_PCIE_CFG);\n\n\tret = keembay_pcie_pll_init(pcie);\n\tif (ret)\n\t\treturn ret;\n\n\tval = readl(pcie->apb_base + PCIE_REGS_PCIE_CFG);\n\twritel(val | PCIE_RSTN, pcie->apb_base + PCIE_REGS_PCIE_CFG);\n\tkeembay_ep_reset_deassert(pcie);\n\n\tret = dw_pcie_host_init(pp);\n\tif (ret) {\n\t\tkeembay_ep_reset_assert(pcie);\n\t\tdev_err(dev, \"Failed to initialize host: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tval = readl(pcie->apb_base + PCIE_REGS_INTERRUPT_ENABLE);\n\tif (IS_ENABLED(CONFIG_PCI_MSI))\n\t\tval |= MSI_CTRL_INT_EN;\n\twritel(val, pcie->apb_base + PCIE_REGS_INTERRUPT_ENABLE);\n\n\treturn 0;\n}\n\nstatic int keembay_pcie_probe(struct platform_device *pdev)\n{\n\tconst struct keembay_pcie_of_data *data;\n\tstruct device *dev = &pdev->dev;\n\tstruct keembay_pcie *pcie;\n\tstruct dw_pcie *pci;\n\tenum dw_pcie_device_mode mode;\n\n\tdata = device_get_match_data(dev);\n\tif (!data)\n\t\treturn -ENODEV;\n\n\tmode = (enum dw_pcie_device_mode)data->mode;\n\n\tpcie = devm_kzalloc(dev, sizeof(*pcie), GFP_KERNEL);\n\tif (!pcie)\n\t\treturn -ENOMEM;\n\n\tpci = &pcie->pci;\n\tpci->dev = dev;\n\tpci->ops = &keembay_pcie_ops;\n\n\tpcie->mode = mode;\n\n\tpcie->apb_base = devm_platform_ioremap_resource_byname(pdev, \"apb\");\n\tif (IS_ERR(pcie->apb_base))\n\t\treturn PTR_ERR(pcie->apb_base);\n\n\tplatform_set_drvdata(pdev, pcie);\n\n\tswitch (pcie->mode) {\n\tcase DW_PCIE_RC_TYPE:\n\t\tif (!IS_ENABLED(CONFIG_PCIE_KEEMBAY_HOST))\n\t\t\treturn -ENODEV;\n\n\t\treturn keembay_pcie_add_pcie_port(pcie, pdev);\n\tcase DW_PCIE_EP_TYPE:\n\t\tif (!IS_ENABLED(CONFIG_PCIE_KEEMBAY_EP))\n\t\t\treturn -ENODEV;\n\n\t\tpci->ep.ops = &keembay_pcie_ep_ops;\n\t\treturn dw_pcie_ep_init(&pci->ep);\n\tdefault:\n\t\tdev_err(dev, \"Invalid device type %d\\n\", pcie->mode);\n\t\treturn -ENODEV;\n\t}\n}\n\nstatic const struct keembay_pcie_of_data keembay_pcie_rc_of_data = {\n\t.mode = DW_PCIE_RC_TYPE,\n};\n\nstatic const struct keembay_pcie_of_data keembay_pcie_ep_of_data = {\n\t.mode = DW_PCIE_EP_TYPE,\n};\n\nstatic const struct of_device_id keembay_pcie_of_match[] = {\n\t{\n\t\t.compatible = \"intel,keembay-pcie\",\n\t\t.data = &keembay_pcie_rc_of_data,\n\t},\n\t{\n\t\t.compatible = \"intel,keembay-pcie-ep\",\n\t\t.data = &keembay_pcie_ep_of_data,\n\t},\n\t{}\n};\n\nstatic struct platform_driver keembay_pcie_driver = {\n\t.driver = {\n\t\t.name = \"keembay-pcie\",\n\t\t.of_match_table = keembay_pcie_of_match,\n\t\t.suppress_bind_attrs = true,\n\t},\n\t.probe  = keembay_pcie_probe,\n};\nbuiltin_platform_driver(keembay_pcie_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}