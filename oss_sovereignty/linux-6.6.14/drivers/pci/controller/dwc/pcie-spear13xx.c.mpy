{
  "module_name": "pcie-spear13xx.c",
  "hash_id": "af2c9da846ddcf7a963477b4601809e73a4c3518d2a009eb3e5cd1100712617d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/controller/dwc/pcie-spear13xx.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/of.h>\n#include <linux/pci.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n#include <linux/resource.h>\n\n#include \"pcie-designware.h\"\n\nstruct spear13xx_pcie {\n\tstruct dw_pcie\t\t*pci;\n\tvoid __iomem\t\t*app_base;\n\tstruct phy\t\t*phy;\n\tstruct clk\t\t*clk;\n};\n\nstruct pcie_app_reg {\n\tu32\tapp_ctrl_0;\t\t \n\tu32\tapp_ctrl_1;\t\t \n\tu32\tapp_status_0;\t\t \n\tu32\tapp_status_1;\t\t \n\tu32\tmsg_status;\t\t \n\tu32\tmsg_payload;\t\t \n\tu32\tint_sts;\t\t \n\tu32\tint_clr;\t\t \n\tu32\tint_mask;\t\t \n\tu32\tmst_bmisc;\t\t \n\tu32\tphy_ctrl;\t\t \n\tu32\tphy_status;\t\t \n\tu32\tcxpl_debug_info_0;\t \n\tu32\tcxpl_debug_info_1;\t \n\tu32\tven_msg_ctrl_0;\t\t \n\tu32\tven_msg_ctrl_1;\t\t \n\tu32\tven_msg_data_0;\t\t \n\tu32\tven_msg_data_1;\t\t \n\tu32\tven_msi_0;\t\t \n\tu32\tven_msi_1;\t\t \n\tu32\tmst_rmisc;\t\t \n};\n\n \n#define APP_LTSSM_ENABLE_ID\t\t\t3\n#define DEVICE_TYPE_RC\t\t\t\t(4 << 25)\n#define MISCTRL_EN_ID\t\t\t\t30\n#define REG_TRANSLATION_ENABLE\t\t\t31\n\n \n#define XMLH_LINK_UP\t\t\t\t(1 << 6)\n\n \n#define MSI_CTRL_INT\t\t\t\t(1 << 26)\n\n#define to_spear13xx_pcie(x)\tdev_get_drvdata((x)->dev)\n\nstatic int spear13xx_pcie_start_link(struct dw_pcie *pci)\n{\n\tstruct spear13xx_pcie *spear13xx_pcie = to_spear13xx_pcie(pci);\n\tstruct pcie_app_reg __iomem *app_reg = spear13xx_pcie->app_base;\n\n\t \n\twritel(DEVICE_TYPE_RC | (1 << MISCTRL_EN_ID)\n\t\t\t| (1 << APP_LTSSM_ENABLE_ID)\n\t\t\t| ((u32)1 << REG_TRANSLATION_ENABLE),\n\t\t\t&app_reg->app_ctrl_0);\n\n\treturn 0;\n}\n\nstatic irqreturn_t spear13xx_pcie_irq_handler(int irq, void *arg)\n{\n\tstruct spear13xx_pcie *spear13xx_pcie = arg;\n\tstruct pcie_app_reg __iomem *app_reg = spear13xx_pcie->app_base;\n\tstruct dw_pcie *pci = spear13xx_pcie->pci;\n\tstruct dw_pcie_rp *pp = &pci->pp;\n\tunsigned int status;\n\n\tstatus = readl(&app_reg->int_sts);\n\n\tif (status & MSI_CTRL_INT) {\n\t\tBUG_ON(!IS_ENABLED(CONFIG_PCI_MSI));\n\t\tdw_handle_msi_irq(pp);\n\t}\n\n\twritel(status, &app_reg->int_clr);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void spear13xx_pcie_enable_interrupts(struct spear13xx_pcie *spear13xx_pcie)\n{\n\tstruct pcie_app_reg __iomem *app_reg = spear13xx_pcie->app_base;\n\n\t \n\tif (IS_ENABLED(CONFIG_PCI_MSI))\n\t\twritel(readl(&app_reg->int_mask) |\n\t\t\t\tMSI_CTRL_INT, &app_reg->int_mask);\n}\n\nstatic int spear13xx_pcie_link_up(struct dw_pcie *pci)\n{\n\tstruct spear13xx_pcie *spear13xx_pcie = to_spear13xx_pcie(pci);\n\tstruct pcie_app_reg __iomem *app_reg = spear13xx_pcie->app_base;\n\n\tif (readl(&app_reg->app_status_1) & XMLH_LINK_UP)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic int spear13xx_pcie_host_init(struct dw_pcie_rp *pp)\n{\n\tstruct dw_pcie *pci = to_dw_pcie_from_pp(pp);\n\tstruct spear13xx_pcie *spear13xx_pcie = to_spear13xx_pcie(pci);\n\tu32 exp_cap_off = dw_pcie_find_capability(pci, PCI_CAP_ID_EXP);\n\tu32 val;\n\n\tspear13xx_pcie->app_base = pci->dbi_base + 0x2000;\n\n\t \n\tval = dw_pcie_readw_dbi(pci, exp_cap_off + PCI_EXP_DEVCTL);\n\tval &= ~PCI_EXP_DEVCTL_READRQ;\n\tdw_pcie_writew_dbi(pci, exp_cap_off + PCI_EXP_DEVCTL, val);\n\n\tdw_pcie_writew_dbi(pci, PCI_VENDOR_ID, 0x104A);\n\tdw_pcie_writew_dbi(pci, PCI_DEVICE_ID, 0xCD80);\n\n\tspear13xx_pcie_enable_interrupts(spear13xx_pcie);\n\n\treturn 0;\n}\n\nstatic const struct dw_pcie_host_ops spear13xx_pcie_host_ops = {\n\t.host_init = spear13xx_pcie_host_init,\n};\n\nstatic int spear13xx_add_pcie_port(struct spear13xx_pcie *spear13xx_pcie,\n\t\t\t\t   struct platform_device *pdev)\n{\n\tstruct dw_pcie *pci = spear13xx_pcie->pci;\n\tstruct dw_pcie_rp *pp = &pci->pp;\n\tstruct device *dev = &pdev->dev;\n\tint ret;\n\n\tpp->irq = platform_get_irq(pdev, 0);\n\tif (pp->irq < 0)\n\t\treturn pp->irq;\n\n\tret = devm_request_irq(dev, pp->irq, spear13xx_pcie_irq_handler,\n\t\t\t       IRQF_SHARED | IRQF_NO_THREAD,\n\t\t\t       \"spear1340-pcie\", spear13xx_pcie);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to request irq %d\\n\", pp->irq);\n\t\treturn ret;\n\t}\n\n\tpp->ops = &spear13xx_pcie_host_ops;\n\tpp->msi_irq[0] = -ENODEV;\n\n\tret = dw_pcie_host_init(pp);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to initialize host\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct dw_pcie_ops dw_pcie_ops = {\n\t.link_up = spear13xx_pcie_link_up,\n\t.start_link = spear13xx_pcie_start_link,\n};\n\nstatic int spear13xx_pcie_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct dw_pcie *pci;\n\tstruct spear13xx_pcie *spear13xx_pcie;\n\tstruct device_node *np = dev->of_node;\n\tint ret;\n\n\tspear13xx_pcie = devm_kzalloc(dev, sizeof(*spear13xx_pcie), GFP_KERNEL);\n\tif (!spear13xx_pcie)\n\t\treturn -ENOMEM;\n\n\tpci = devm_kzalloc(dev, sizeof(*pci), GFP_KERNEL);\n\tif (!pci)\n\t\treturn -ENOMEM;\n\n\tpci->dev = dev;\n\tpci->ops = &dw_pcie_ops;\n\n\tspear13xx_pcie->pci = pci;\n\n\tspear13xx_pcie->phy = devm_phy_get(dev, \"pcie-phy\");\n\tif (IS_ERR(spear13xx_pcie->phy)) {\n\t\tret = PTR_ERR(spear13xx_pcie->phy);\n\t\tif (ret == -EPROBE_DEFER)\n\t\t\tdev_info(dev, \"probe deferred\\n\");\n\t\telse\n\t\t\tdev_err(dev, \"couldn't get pcie-phy\\n\");\n\t\treturn ret;\n\t}\n\n\tphy_init(spear13xx_pcie->phy);\n\n\tspear13xx_pcie->clk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(spear13xx_pcie->clk)) {\n\t\tdev_err(dev, \"couldn't get clk for pcie\\n\");\n\t\treturn PTR_ERR(spear13xx_pcie->clk);\n\t}\n\tret = clk_prepare_enable(spear13xx_pcie->clk);\n\tif (ret) {\n\t\tdev_err(dev, \"couldn't enable clk for pcie\\n\");\n\t\treturn ret;\n\t}\n\n\tif (of_property_read_bool(np, \"st,pcie-is-gen1\"))\n\t\tpci->link_gen = 1;\n\n\tplatform_set_drvdata(pdev, spear13xx_pcie);\n\n\tret = spear13xx_add_pcie_port(spear13xx_pcie, pdev);\n\tif (ret < 0)\n\t\tgoto fail_clk;\n\n\treturn 0;\n\nfail_clk:\n\tclk_disable_unprepare(spear13xx_pcie->clk);\n\n\treturn ret;\n}\n\nstatic const struct of_device_id spear13xx_pcie_of_match[] = {\n\t{ .compatible = \"st,spear1340-pcie\", },\n\t{},\n};\n\nstatic struct platform_driver spear13xx_pcie_driver = {\n\t.probe\t\t= spear13xx_pcie_probe,\n\t.driver = {\n\t\t.name\t= \"spear-pcie\",\n\t\t.of_match_table = spear13xx_pcie_of_match,\n\t\t.suppress_bind_attrs = true,\n\t},\n};\n\nbuiltin_platform_driver(spear13xx_pcie_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}