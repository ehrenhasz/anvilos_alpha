{
  "module_name": "pcie-tegra194.c",
  "hash_id": "3d5f4e4b5c23b7b80fad8baeb880179f5167b40b90a01dddfff60f6990ef6f39",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/controller/dwc/pcie-tegra194.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/gpio.h>\n#include <linux/gpio/consumer.h>\n#include <linux/interconnect.h>\n#include <linux/interrupt.h>\n#include <linux/iopoll.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_gpio.h>\n#include <linux/of_pci.h>\n#include <linux/pci.h>\n#include <linux/phy/phy.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/random.h>\n#include <linux/reset.h>\n#include <linux/resource.h>\n#include <linux/types.h>\n#include \"pcie-designware.h\"\n#include <soc/tegra/bpmp.h>\n#include <soc/tegra/bpmp-abi.h>\n#include \"../../pci.h\"\n\n#define TEGRA194_DWC_IP_VER\t\t\t0x490A\n#define TEGRA234_DWC_IP_VER\t\t\t0x562A\n\n#define APPL_PINMUX\t\t\t\t0x0\n#define APPL_PINMUX_PEX_RST\t\t\tBIT(0)\n#define APPL_PINMUX_CLKREQ_OVERRIDE_EN\t\tBIT(2)\n#define APPL_PINMUX_CLKREQ_OVERRIDE\t\tBIT(3)\n#define APPL_PINMUX_CLK_OUTPUT_IN_OVERRIDE_EN\tBIT(4)\n#define APPL_PINMUX_CLK_OUTPUT_IN_OVERRIDE\tBIT(5)\n\n#define APPL_CTRL\t\t\t\t0x4\n#define APPL_CTRL_SYS_PRE_DET_STATE\t\tBIT(6)\n#define APPL_CTRL_LTSSM_EN\t\t\tBIT(7)\n#define APPL_CTRL_HW_HOT_RST_EN\t\t\tBIT(20)\n#define APPL_CTRL_HW_HOT_RST_MODE_MASK\t\tGENMASK(1, 0)\n#define APPL_CTRL_HW_HOT_RST_MODE_SHIFT\t\t22\n#define APPL_CTRL_HW_HOT_RST_MODE_IMDT_RST\t0x1\n#define APPL_CTRL_HW_HOT_RST_MODE_IMDT_RST_LTSSM_EN\t0x2\n\n#define APPL_INTR_EN_L0_0\t\t\t0x8\n#define APPL_INTR_EN_L0_0_LINK_STATE_INT_EN\tBIT(0)\n#define APPL_INTR_EN_L0_0_MSI_RCV_INT_EN\tBIT(4)\n#define APPL_INTR_EN_L0_0_INT_INT_EN\t\tBIT(8)\n#define APPL_INTR_EN_L0_0_PCI_CMD_EN_INT_EN\tBIT(15)\n#define APPL_INTR_EN_L0_0_CDM_REG_CHK_INT_EN\tBIT(19)\n#define APPL_INTR_EN_L0_0_SYS_INTR_EN\t\tBIT(30)\n#define APPL_INTR_EN_L0_0_SYS_MSI_INTR_EN\tBIT(31)\n\n#define APPL_INTR_STATUS_L0\t\t\t0xC\n#define APPL_INTR_STATUS_L0_LINK_STATE_INT\tBIT(0)\n#define APPL_INTR_STATUS_L0_INT_INT\t\tBIT(8)\n#define APPL_INTR_STATUS_L0_PCI_CMD_EN_INT\tBIT(15)\n#define APPL_INTR_STATUS_L0_PEX_RST_INT\t\tBIT(16)\n#define APPL_INTR_STATUS_L0_CDM_REG_CHK_INT\tBIT(18)\n\n#define APPL_INTR_EN_L1_0_0\t\t\t\t0x1C\n#define APPL_INTR_EN_L1_0_0_LINK_REQ_RST_NOT_INT_EN\tBIT(1)\n#define APPL_INTR_EN_L1_0_0_RDLH_LINK_UP_INT_EN\t\tBIT(3)\n#define APPL_INTR_EN_L1_0_0_HOT_RESET_DONE_INT_EN\tBIT(30)\n\n#define APPL_INTR_STATUS_L1_0_0\t\t\t\t0x20\n#define APPL_INTR_STATUS_L1_0_0_LINK_REQ_RST_NOT_CHGED\tBIT(1)\n#define APPL_INTR_STATUS_L1_0_0_RDLH_LINK_UP_CHGED\tBIT(3)\n#define APPL_INTR_STATUS_L1_0_0_HOT_RESET_DONE\t\tBIT(30)\n\n#define APPL_INTR_STATUS_L1_1\t\t\t0x2C\n#define APPL_INTR_STATUS_L1_2\t\t\t0x30\n#define APPL_INTR_STATUS_L1_3\t\t\t0x34\n#define APPL_INTR_STATUS_L1_6\t\t\t0x3C\n#define APPL_INTR_STATUS_L1_7\t\t\t0x40\n#define APPL_INTR_STATUS_L1_15_CFG_BME_CHGED\tBIT(1)\n\n#define APPL_INTR_EN_L1_8_0\t\t\t0x44\n#define APPL_INTR_EN_L1_8_BW_MGT_INT_EN\t\tBIT(2)\n#define APPL_INTR_EN_L1_8_AUTO_BW_INT_EN\tBIT(3)\n#define APPL_INTR_EN_L1_8_INTX_EN\t\tBIT(11)\n#define APPL_INTR_EN_L1_8_AER_INT_EN\t\tBIT(15)\n\n#define APPL_INTR_STATUS_L1_8_0\t\t\t0x4C\n#define APPL_INTR_STATUS_L1_8_0_EDMA_INT_MASK\tGENMASK(11, 6)\n#define APPL_INTR_STATUS_L1_8_0_BW_MGT_INT_STS\tBIT(2)\n#define APPL_INTR_STATUS_L1_8_0_AUTO_BW_INT_STS\tBIT(3)\n\n#define APPL_INTR_STATUS_L1_9\t\t\t0x54\n#define APPL_INTR_STATUS_L1_10\t\t\t0x58\n#define APPL_INTR_STATUS_L1_11\t\t\t0x64\n#define APPL_INTR_STATUS_L1_13\t\t\t0x74\n#define APPL_INTR_STATUS_L1_14\t\t\t0x78\n#define APPL_INTR_STATUS_L1_15\t\t\t0x7C\n#define APPL_INTR_STATUS_L1_17\t\t\t0x88\n\n#define APPL_INTR_EN_L1_18\t\t\t\t0x90\n#define APPL_INTR_EN_L1_18_CDM_REG_CHK_CMPLT\t\tBIT(2)\n#define APPL_INTR_EN_L1_18_CDM_REG_CHK_CMP_ERR\t\tBIT(1)\n#define APPL_INTR_EN_L1_18_CDM_REG_CHK_LOGIC_ERR\tBIT(0)\n\n#define APPL_INTR_STATUS_L1_18\t\t\t\t0x94\n#define APPL_INTR_STATUS_L1_18_CDM_REG_CHK_CMPLT\tBIT(2)\n#define APPL_INTR_STATUS_L1_18_CDM_REG_CHK_CMP_ERR\tBIT(1)\n#define APPL_INTR_STATUS_L1_18_CDM_REG_CHK_LOGIC_ERR\tBIT(0)\n\n#define APPL_MSI_CTRL_1\t\t\t\t0xAC\n\n#define APPL_MSI_CTRL_2\t\t\t\t0xB0\n\n#define APPL_LEGACY_INTX\t\t\t0xB8\n\n#define APPL_LTR_MSG_1\t\t\t\t0xC4\n#define LTR_MSG_REQ\t\t\t\tBIT(15)\n#define LTR_MST_NO_SNOOP_SHIFT\t\t\t16\n\n#define APPL_LTR_MSG_2\t\t\t\t0xC8\n#define APPL_LTR_MSG_2_LTR_MSG_REQ_STATE\tBIT(3)\n\n#define APPL_LINK_STATUS\t\t\t0xCC\n#define APPL_LINK_STATUS_RDLH_LINK_UP\t\tBIT(0)\n\n#define APPL_DEBUG\t\t\t\t0xD0\n#define APPL_DEBUG_PM_LINKST_IN_L2_LAT\t\tBIT(21)\n#define APPL_DEBUG_PM_LINKST_IN_L0\t\t0x11\n#define APPL_DEBUG_LTSSM_STATE_MASK\t\tGENMASK(8, 3)\n#define APPL_DEBUG_LTSSM_STATE_SHIFT\t\t3\n#define LTSSM_STATE_PRE_DETECT\t\t\t5\n\n#define APPL_RADM_STATUS\t\t\t0xE4\n#define APPL_PM_XMT_TURNOFF_STATE\t\tBIT(0)\n\n#define APPL_DM_TYPE\t\t\t\t0x100\n#define APPL_DM_TYPE_MASK\t\t\tGENMASK(3, 0)\n#define APPL_DM_TYPE_RP\t\t\t\t0x4\n#define APPL_DM_TYPE_EP\t\t\t\t0x0\n\n#define APPL_CFG_BASE_ADDR\t\t\t0x104\n#define APPL_CFG_BASE_ADDR_MASK\t\t\tGENMASK(31, 12)\n\n#define APPL_CFG_IATU_DMA_BASE_ADDR\t\t0x108\n#define APPL_CFG_IATU_DMA_BASE_ADDR_MASK\tGENMASK(31, 18)\n\n#define APPL_CFG_MISC\t\t\t\t0x110\n#define APPL_CFG_MISC_SLV_EP_MODE\t\tBIT(14)\n#define APPL_CFG_MISC_ARCACHE_MASK\t\tGENMASK(13, 10)\n#define APPL_CFG_MISC_ARCACHE_SHIFT\t\t10\n#define APPL_CFG_MISC_ARCACHE_VAL\t\t3\n\n#define APPL_CFG_SLCG_OVERRIDE\t\t\t0x114\n#define APPL_CFG_SLCG_OVERRIDE_SLCG_EN_MASTER\tBIT(0)\n\n#define APPL_CAR_RESET_OVRD\t\t\t\t0x12C\n#define APPL_CAR_RESET_OVRD_CYA_OVERRIDE_CORE_RST_N\tBIT(0)\n\n#define IO_BASE_IO_DECODE\t\t\t\tBIT(0)\n#define IO_BASE_IO_DECODE_BIT8\t\t\t\tBIT(8)\n\n#define CFG_PREF_MEM_LIMIT_BASE_MEM_DECODE\t\tBIT(0)\n#define CFG_PREF_MEM_LIMIT_BASE_MEM_LIMIT_DECODE\tBIT(16)\n\n#define CFG_TIMER_CTRL_MAX_FUNC_NUM_OFF\t0x718\n#define CFG_TIMER_CTRL_ACK_NAK_SHIFT\t(19)\n\n#define N_FTS_VAL\t\t\t\t\t52\n#define FTS_VAL\t\t\t\t\t\t52\n\n#define GEN3_EQ_CONTROL_OFF\t\t\t0x8a8\n#define GEN3_EQ_CONTROL_OFF_PSET_REQ_VEC_SHIFT\t8\n#define GEN3_EQ_CONTROL_OFF_PSET_REQ_VEC_MASK\tGENMASK(23, 8)\n#define GEN3_EQ_CONTROL_OFF_FB_MODE_MASK\tGENMASK(3, 0)\n\n#define PORT_LOGIC_AMBA_ERROR_RESPONSE_DEFAULT\t0x8D0\n#define AMBA_ERROR_RESPONSE_CRS_SHIFT\t\t3\n#define AMBA_ERROR_RESPONSE_CRS_MASK\t\tGENMASK(1, 0)\n#define AMBA_ERROR_RESPONSE_CRS_OKAY\t\t0\n#define AMBA_ERROR_RESPONSE_CRS_OKAY_FFFFFFFF\t1\n#define AMBA_ERROR_RESPONSE_CRS_OKAY_FFFF0001\t2\n\n#define MSIX_ADDR_MATCH_LOW_OFF\t\t\t0x940\n#define MSIX_ADDR_MATCH_LOW_OFF_EN\t\tBIT(0)\n#define MSIX_ADDR_MATCH_LOW_OFF_MASK\t\tGENMASK(31, 2)\n\n#define MSIX_ADDR_MATCH_HIGH_OFF\t\t0x944\n#define MSIX_ADDR_MATCH_HIGH_OFF_MASK\t\tGENMASK(31, 0)\n\n#define PORT_LOGIC_MSIX_DOORBELL\t\t\t0x948\n\n#define CAP_SPCIE_CAP_OFF\t\t\t0x154\n#define CAP_SPCIE_CAP_OFF_DSP_TX_PRESET0_MASK\tGENMASK(3, 0)\n#define CAP_SPCIE_CAP_OFF_USP_TX_PRESET0_MASK\tGENMASK(11, 8)\n#define CAP_SPCIE_CAP_OFF_USP_TX_PRESET0_SHIFT\t8\n\n#define PME_ACK_TIMEOUT 10000\n\n#define LTSSM_TIMEOUT 50000\t \n\n#define GEN3_GEN4_EQ_PRESET_INIT\t5\n\n#define GEN1_CORE_CLK_FREQ\t62500000\n#define GEN2_CORE_CLK_FREQ\t125000000\n#define GEN3_CORE_CLK_FREQ\t250000000\n#define GEN4_CORE_CLK_FREQ\t500000000\n\n#define LTR_MSG_TIMEOUT\t\t(100 * 1000)\n\n#define PERST_DEBOUNCE_TIME\t(5 * 1000)\n\n#define EP_STATE_DISABLED\t0\n#define EP_STATE_ENABLED\t1\n\nstatic const unsigned int pcie_gen_freq[] = {\n\tGEN1_CORE_CLK_FREQ,\t \n\tGEN1_CORE_CLK_FREQ,\n\tGEN2_CORE_CLK_FREQ,\n\tGEN3_CORE_CLK_FREQ,\n\tGEN4_CORE_CLK_FREQ\n};\n\nstruct tegra_pcie_dw_of_data {\n\tu32 version;\n\tenum dw_pcie_device_mode mode;\n\tbool has_msix_doorbell_access_fix;\n\tbool has_sbr_reset_fix;\n\tbool has_l1ss_exit_fix;\n\tbool has_ltr_req_fix;\n\tu32 cdm_chk_int_en_bit;\n\tu32 gen4_preset_vec;\n\tu8 n_fts[2];\n};\n\nstruct tegra_pcie_dw {\n\tstruct device *dev;\n\tstruct resource *appl_res;\n\tstruct resource *dbi_res;\n\tstruct resource *atu_dma_res;\n\tvoid __iomem *appl_base;\n\tstruct clk *core_clk;\n\tstruct reset_control *core_apb_rst;\n\tstruct reset_control *core_rst;\n\tstruct dw_pcie pci;\n\tstruct tegra_bpmp *bpmp;\n\n\tstruct tegra_pcie_dw_of_data *of_data;\n\n\tbool supports_clkreq;\n\tbool enable_cdm_check;\n\tbool enable_srns;\n\tbool link_state;\n\tbool update_fc_fixup;\n\tbool enable_ext_refclk;\n\tu8 init_link_width;\n\tu32 msi_ctrl_int;\n\tu32 num_lanes;\n\tu32 cid;\n\tu32 cfg_link_cap_l1sub;\n\tu32 ras_des_cap;\n\tu32 pcie_cap_base;\n\tu32 aspm_cmrt;\n\tu32 aspm_pwr_on_t;\n\tu32 aspm_l0s_enter_lat;\n\n\tstruct regulator *pex_ctl_supply;\n\tstruct regulator *slot_ctl_3v3;\n\tstruct regulator *slot_ctl_12v;\n\n\tunsigned int phy_count;\n\tstruct phy **phys;\n\n\tstruct dentry *debugfs;\n\n\t \n\tstruct gpio_desc *pex_rst_gpiod;\n\tstruct gpio_desc *pex_refclk_sel_gpiod;\n\tunsigned int pex_rst_irq;\n\tint ep_state;\n\tlong link_status;\n\tstruct icc_path *icc_path;\n};\n\nstatic inline struct tegra_pcie_dw *to_tegra_pcie(struct dw_pcie *pci)\n{\n\treturn container_of(pci, struct tegra_pcie_dw, pci);\n}\n\nstatic inline void appl_writel(struct tegra_pcie_dw *pcie, const u32 value,\n\t\t\t       const u32 reg)\n{\n\twritel_relaxed(value, pcie->appl_base + reg);\n}\n\nstatic inline u32 appl_readl(struct tegra_pcie_dw *pcie, const u32 reg)\n{\n\treturn readl_relaxed(pcie->appl_base + reg);\n}\n\nstruct tegra_pcie_soc {\n\tenum dw_pcie_device_mode mode;\n};\n\nstatic void tegra_pcie_icc_set(struct tegra_pcie_dw *pcie)\n{\n\tstruct dw_pcie *pci = &pcie->pci;\n\tu32 val, speed, width;\n\n\tval = dw_pcie_readw_dbi(pci, pcie->pcie_cap_base + PCI_EXP_LNKSTA);\n\n\tspeed = FIELD_GET(PCI_EXP_LNKSTA_CLS, val);\n\twidth = FIELD_GET(PCI_EXP_LNKSTA_NLW, val);\n\n\tval = width * (PCIE_SPEED2MBS_ENC(pcie_link_speed[speed]) / BITS_PER_BYTE);\n\n\tif (icc_set_bw(pcie->icc_path, MBps_to_icc(val), 0))\n\t\tdev_err(pcie->dev, \"can't set bw[%u]\\n\", val);\n\n\tif (speed >= ARRAY_SIZE(pcie_gen_freq))\n\t\tspeed = 0;\n\n\tclk_set_rate(pcie->core_clk, pcie_gen_freq[speed]);\n}\n\nstatic void apply_bad_link_workaround(struct dw_pcie_rp *pp)\n{\n\tstruct dw_pcie *pci = to_dw_pcie_from_pp(pp);\n\tstruct tegra_pcie_dw *pcie = to_tegra_pcie(pci);\n\tu32 current_link_width;\n\tu16 val;\n\n\t \n\tval = dw_pcie_readw_dbi(pci, pcie->pcie_cap_base + PCI_EXP_LNKSTA);\n\tif (val & PCI_EXP_LNKSTA_LBMS) {\n\t\tcurrent_link_width = FIELD_GET(PCI_EXP_LNKSTA_NLW, val);\n\t\tif (pcie->init_link_width > current_link_width) {\n\t\t\tdev_warn(pci->dev, \"PCIe link is bad, width reduced\\n\");\n\t\t\tval = dw_pcie_readw_dbi(pci, pcie->pcie_cap_base +\n\t\t\t\t\t\tPCI_EXP_LNKCTL2);\n\t\t\tval &= ~PCI_EXP_LNKCTL2_TLS;\n\t\t\tval |= PCI_EXP_LNKCTL2_TLS_2_5GT;\n\t\t\tdw_pcie_writew_dbi(pci, pcie->pcie_cap_base +\n\t\t\t\t\t   PCI_EXP_LNKCTL2, val);\n\n\t\t\tval = dw_pcie_readw_dbi(pci, pcie->pcie_cap_base +\n\t\t\t\t\t\tPCI_EXP_LNKCTL);\n\t\t\tval |= PCI_EXP_LNKCTL_RL;\n\t\t\tdw_pcie_writew_dbi(pci, pcie->pcie_cap_base +\n\t\t\t\t\t   PCI_EXP_LNKCTL, val);\n\t\t}\n\t}\n}\n\nstatic irqreturn_t tegra_pcie_rp_irq_handler(int irq, void *arg)\n{\n\tstruct tegra_pcie_dw *pcie = arg;\n\tstruct dw_pcie *pci = &pcie->pci;\n\tstruct dw_pcie_rp *pp = &pci->pp;\n\tu32 val, status_l0, status_l1;\n\tu16 val_w;\n\n\tstatus_l0 = appl_readl(pcie, APPL_INTR_STATUS_L0);\n\tif (status_l0 & APPL_INTR_STATUS_L0_LINK_STATE_INT) {\n\t\tstatus_l1 = appl_readl(pcie, APPL_INTR_STATUS_L1_0_0);\n\t\tappl_writel(pcie, status_l1, APPL_INTR_STATUS_L1_0_0);\n\t\tif (!pcie->of_data->has_sbr_reset_fix &&\n\t\t    status_l1 & APPL_INTR_STATUS_L1_0_0_LINK_REQ_RST_NOT_CHGED) {\n\t\t\t \n\t\t\tval = appl_readl(pcie, APPL_CAR_RESET_OVRD);\n\t\t\tval &= ~APPL_CAR_RESET_OVRD_CYA_OVERRIDE_CORE_RST_N;\n\t\t\tappl_writel(pcie, val, APPL_CAR_RESET_OVRD);\n\t\t\tudelay(1);\n\t\t\tval = appl_readl(pcie, APPL_CAR_RESET_OVRD);\n\t\t\tval |= APPL_CAR_RESET_OVRD_CYA_OVERRIDE_CORE_RST_N;\n\t\t\tappl_writel(pcie, val, APPL_CAR_RESET_OVRD);\n\n\t\t\tval = dw_pcie_readl_dbi(pci, PCIE_LINK_WIDTH_SPEED_CONTROL);\n\t\t\tval |= PORT_LOGIC_SPEED_CHANGE;\n\t\t\tdw_pcie_writel_dbi(pci, PCIE_LINK_WIDTH_SPEED_CONTROL, val);\n\t\t}\n\t}\n\n\tif (status_l0 & APPL_INTR_STATUS_L0_INT_INT) {\n\t\tstatus_l1 = appl_readl(pcie, APPL_INTR_STATUS_L1_8_0);\n\t\tif (status_l1 & APPL_INTR_STATUS_L1_8_0_AUTO_BW_INT_STS) {\n\t\t\tappl_writel(pcie,\n\t\t\t\t    APPL_INTR_STATUS_L1_8_0_AUTO_BW_INT_STS,\n\t\t\t\t    APPL_INTR_STATUS_L1_8_0);\n\t\t\tapply_bad_link_workaround(pp);\n\t\t}\n\t\tif (status_l1 & APPL_INTR_STATUS_L1_8_0_BW_MGT_INT_STS) {\n\t\t\tval_w = dw_pcie_readw_dbi(pci, pcie->pcie_cap_base +\n\t\t\t\t\t\t  PCI_EXP_LNKSTA);\n\t\t\tval_w |= PCI_EXP_LNKSTA_LBMS;\n\t\t\tdw_pcie_writew_dbi(pci, pcie->pcie_cap_base +\n\t\t\t\t\t   PCI_EXP_LNKSTA, val_w);\n\n\t\t\tappl_writel(pcie,\n\t\t\t\t    APPL_INTR_STATUS_L1_8_0_BW_MGT_INT_STS,\n\t\t\t\t    APPL_INTR_STATUS_L1_8_0);\n\n\t\t\tval_w = dw_pcie_readw_dbi(pci, pcie->pcie_cap_base +\n\t\t\t\t\t\t  PCI_EXP_LNKSTA);\n\t\t\tdev_dbg(pci->dev, \"Link Speed : Gen-%u\\n\", val_w &\n\t\t\t\tPCI_EXP_LNKSTA_CLS);\n\t\t}\n\t}\n\n\tif (status_l0 & APPL_INTR_STATUS_L0_CDM_REG_CHK_INT) {\n\t\tstatus_l1 = appl_readl(pcie, APPL_INTR_STATUS_L1_18);\n\t\tval = dw_pcie_readl_dbi(pci, PCIE_PL_CHK_REG_CONTROL_STATUS);\n\t\tif (status_l1 & APPL_INTR_STATUS_L1_18_CDM_REG_CHK_CMPLT) {\n\t\t\tdev_info(pci->dev, \"CDM check complete\\n\");\n\t\t\tval |= PCIE_PL_CHK_REG_CHK_REG_COMPLETE;\n\t\t}\n\t\tif (status_l1 & APPL_INTR_STATUS_L1_18_CDM_REG_CHK_CMP_ERR) {\n\t\t\tdev_err(pci->dev, \"CDM comparison mismatch\\n\");\n\t\t\tval |= PCIE_PL_CHK_REG_CHK_REG_COMPARISON_ERROR;\n\t\t}\n\t\tif (status_l1 & APPL_INTR_STATUS_L1_18_CDM_REG_CHK_LOGIC_ERR) {\n\t\t\tdev_err(pci->dev, \"CDM Logic error\\n\");\n\t\t\tval |= PCIE_PL_CHK_REG_CHK_REG_LOGIC_ERROR;\n\t\t}\n\t\tdw_pcie_writel_dbi(pci, PCIE_PL_CHK_REG_CONTROL_STATUS, val);\n\t\tval = dw_pcie_readl_dbi(pci, PCIE_PL_CHK_REG_ERR_ADDR);\n\t\tdev_err(pci->dev, \"CDM Error Address Offset = 0x%08X\\n\", val);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void pex_ep_event_hot_rst_done(struct tegra_pcie_dw *pcie)\n{\n\tu32 val;\n\n\tappl_writel(pcie, 0xFFFFFFFF, APPL_INTR_STATUS_L0);\n\tappl_writel(pcie, 0xFFFFFFFF, APPL_INTR_STATUS_L1_0_0);\n\tappl_writel(pcie, 0xFFFFFFFF, APPL_INTR_STATUS_L1_1);\n\tappl_writel(pcie, 0xFFFFFFFF, APPL_INTR_STATUS_L1_2);\n\tappl_writel(pcie, 0xFFFFFFFF, APPL_INTR_STATUS_L1_3);\n\tappl_writel(pcie, 0xFFFFFFFF, APPL_INTR_STATUS_L1_6);\n\tappl_writel(pcie, 0xFFFFFFFF, APPL_INTR_STATUS_L1_7);\n\tappl_writel(pcie, 0xFFFFFFFF, APPL_INTR_STATUS_L1_8_0);\n\tappl_writel(pcie, 0xFFFFFFFF, APPL_INTR_STATUS_L1_9);\n\tappl_writel(pcie, 0xFFFFFFFF, APPL_INTR_STATUS_L1_10);\n\tappl_writel(pcie, 0xFFFFFFFF, APPL_INTR_STATUS_L1_11);\n\tappl_writel(pcie, 0xFFFFFFFF, APPL_INTR_STATUS_L1_13);\n\tappl_writel(pcie, 0xFFFFFFFF, APPL_INTR_STATUS_L1_14);\n\tappl_writel(pcie, 0xFFFFFFFF, APPL_INTR_STATUS_L1_15);\n\tappl_writel(pcie, 0xFFFFFFFF, APPL_INTR_STATUS_L1_17);\n\tappl_writel(pcie, 0xFFFFFFFF, APPL_MSI_CTRL_2);\n\n\tval = appl_readl(pcie, APPL_CTRL);\n\tval |= APPL_CTRL_LTSSM_EN;\n\tappl_writel(pcie, val, APPL_CTRL);\n}\n\nstatic irqreturn_t tegra_pcie_ep_irq_thread(int irq, void *arg)\n{\n\tstruct tegra_pcie_dw *pcie = arg;\n\tstruct dw_pcie_ep *ep = &pcie->pci.ep;\n\tstruct dw_pcie *pci = &pcie->pci;\n\tu32 val;\n\n\tif (test_and_clear_bit(0, &pcie->link_status))\n\t\tdw_pcie_ep_linkup(ep);\n\n\ttegra_pcie_icc_set(pcie);\n\n\tif (pcie->of_data->has_ltr_req_fix)\n\t\treturn IRQ_HANDLED;\n\n\t \n\tval = dw_pcie_readl_dbi(pci, pcie->cfg_link_cap_l1sub);\n\tif (!(val & (PCI_L1SS_CAP_ASPM_L1_1 | PCI_L1SS_CAP_ASPM_L1_2)))\n\t\treturn IRQ_HANDLED;\n\n\t \n\tval = dw_pcie_readl_dbi(pci, PCI_COMMAND);\n\tif (val & PCI_COMMAND_MASTER) {\n\t\tktime_t timeout;\n\n\t\t \n\t\tval = 110 | (2 << PCI_LTR_SCALE_SHIFT) | LTR_MSG_REQ;\n\t\tval |= (val << LTR_MST_NO_SNOOP_SHIFT);\n\t\tappl_writel(pcie, val, APPL_LTR_MSG_1);\n\n\t\t \n\t\tval = appl_readl(pcie, APPL_LTR_MSG_2);\n\t\tval |= APPL_LTR_MSG_2_LTR_MSG_REQ_STATE;\n\t\tappl_writel(pcie, val, APPL_LTR_MSG_2);\n\n\t\ttimeout = ktime_add_us(ktime_get(), LTR_MSG_TIMEOUT);\n\t\tfor (;;) {\n\t\t\tval = appl_readl(pcie, APPL_LTR_MSG_2);\n\t\t\tif (!(val & APPL_LTR_MSG_2_LTR_MSG_REQ_STATE))\n\t\t\t\tbreak;\n\t\t\tif (ktime_after(ktime_get(), timeout))\n\t\t\t\tbreak;\n\t\t\tusleep_range(1000, 1100);\n\t\t}\n\t\tif (val & APPL_LTR_MSG_2_LTR_MSG_REQ_STATE)\n\t\t\tdev_err(pcie->dev, \"Failed to send LTR message\\n\");\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t tegra_pcie_ep_hard_irq(int irq, void *arg)\n{\n\tstruct tegra_pcie_dw *pcie = arg;\n\tint spurious = 1;\n\tu32 status_l0, status_l1, link_status;\n\n\tstatus_l0 = appl_readl(pcie, APPL_INTR_STATUS_L0);\n\tif (status_l0 & APPL_INTR_STATUS_L0_LINK_STATE_INT) {\n\t\tstatus_l1 = appl_readl(pcie, APPL_INTR_STATUS_L1_0_0);\n\t\tappl_writel(pcie, status_l1, APPL_INTR_STATUS_L1_0_0);\n\n\t\tif (status_l1 & APPL_INTR_STATUS_L1_0_0_HOT_RESET_DONE)\n\t\t\tpex_ep_event_hot_rst_done(pcie);\n\n\t\tif (status_l1 & APPL_INTR_STATUS_L1_0_0_RDLH_LINK_UP_CHGED) {\n\t\t\tlink_status = appl_readl(pcie, APPL_LINK_STATUS);\n\t\t\tif (link_status & APPL_LINK_STATUS_RDLH_LINK_UP) {\n\t\t\t\tdev_dbg(pcie->dev, \"Link is up with Host\\n\");\n\t\t\t\tset_bit(0, &pcie->link_status);\n\t\t\t\treturn IRQ_WAKE_THREAD;\n\t\t\t}\n\t\t}\n\n\t\tspurious = 0;\n\t}\n\n\tif (status_l0 & APPL_INTR_STATUS_L0_PCI_CMD_EN_INT) {\n\t\tstatus_l1 = appl_readl(pcie, APPL_INTR_STATUS_L1_15);\n\t\tappl_writel(pcie, status_l1, APPL_INTR_STATUS_L1_15);\n\n\t\tif (status_l1 & APPL_INTR_STATUS_L1_15_CFG_BME_CHGED)\n\t\t\treturn IRQ_WAKE_THREAD;\n\n\t\tspurious = 0;\n\t}\n\n\tif (spurious) {\n\t\tdev_warn(pcie->dev, \"Random interrupt (STATUS = 0x%08X)\\n\",\n\t\t\t status_l0);\n\t\tappl_writel(pcie, status_l0, APPL_INTR_STATUS_L0);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int tegra_pcie_dw_rd_own_conf(struct pci_bus *bus, u32 devfn, int where,\n\t\t\t\t     int size, u32 *val)\n{\n\tstruct dw_pcie_rp *pp = bus->sysdata;\n\tstruct dw_pcie *pci = to_dw_pcie_from_pp(pp);\n\tstruct tegra_pcie_dw *pcie = to_tegra_pcie(pci);\n\n\t \n\tif (!pcie->of_data->has_msix_doorbell_access_fix &&\n\t    !PCI_SLOT(devfn) && where == PORT_LOGIC_MSIX_DOORBELL) {\n\t\t*val = 0x00000000;\n\t\treturn PCIBIOS_SUCCESSFUL;\n\t}\n\n\treturn pci_generic_config_read(bus, devfn, where, size, val);\n}\n\nstatic int tegra_pcie_dw_wr_own_conf(struct pci_bus *bus, u32 devfn, int where,\n\t\t\t\t     int size, u32 val)\n{\n\tstruct dw_pcie_rp *pp = bus->sysdata;\n\tstruct dw_pcie *pci = to_dw_pcie_from_pp(pp);\n\tstruct tegra_pcie_dw *pcie = to_tegra_pcie(pci);\n\n\t \n\tif (!pcie->of_data->has_msix_doorbell_access_fix &&\n\t    !PCI_SLOT(devfn) && where == PORT_LOGIC_MSIX_DOORBELL)\n\t\treturn PCIBIOS_SUCCESSFUL;\n\n\treturn pci_generic_config_write(bus, devfn, where, size, val);\n}\n\nstatic struct pci_ops tegra_pci_ops = {\n\t.map_bus = dw_pcie_own_conf_map_bus,\n\t.read = tegra_pcie_dw_rd_own_conf,\n\t.write = tegra_pcie_dw_wr_own_conf,\n};\n\n#if defined(CONFIG_PCIEASPM)\nstatic void disable_aspm_l11(struct tegra_pcie_dw *pcie)\n{\n\tu32 val;\n\n\tval = dw_pcie_readl_dbi(&pcie->pci, pcie->cfg_link_cap_l1sub);\n\tval &= ~PCI_L1SS_CAP_ASPM_L1_1;\n\tdw_pcie_writel_dbi(&pcie->pci, pcie->cfg_link_cap_l1sub, val);\n}\n\nstatic void disable_aspm_l12(struct tegra_pcie_dw *pcie)\n{\n\tu32 val;\n\n\tval = dw_pcie_readl_dbi(&pcie->pci, pcie->cfg_link_cap_l1sub);\n\tval &= ~PCI_L1SS_CAP_ASPM_L1_2;\n\tdw_pcie_writel_dbi(&pcie->pci, pcie->cfg_link_cap_l1sub, val);\n}\n\nstatic inline u32 event_counter_prog(struct tegra_pcie_dw *pcie, u32 event)\n{\n\tu32 val;\n\n\tval = dw_pcie_readl_dbi(&pcie->pci, pcie->ras_des_cap +\n\t\t\t\tPCIE_RAS_DES_EVENT_COUNTER_CONTROL);\n\tval &= ~(EVENT_COUNTER_EVENT_SEL_MASK << EVENT_COUNTER_EVENT_SEL_SHIFT);\n\tval |= EVENT_COUNTER_GROUP_5 << EVENT_COUNTER_GROUP_SEL_SHIFT;\n\tval |= event << EVENT_COUNTER_EVENT_SEL_SHIFT;\n\tval |= EVENT_COUNTER_ENABLE_ALL << EVENT_COUNTER_ENABLE_SHIFT;\n\tdw_pcie_writel_dbi(&pcie->pci, pcie->ras_des_cap +\n\t\t\t   PCIE_RAS_DES_EVENT_COUNTER_CONTROL, val);\n\tval = dw_pcie_readl_dbi(&pcie->pci, pcie->ras_des_cap +\n\t\t\t\tPCIE_RAS_DES_EVENT_COUNTER_DATA);\n\n\treturn val;\n}\n\nstatic int aspm_state_cnt(struct seq_file *s, void *data)\n{\n\tstruct tegra_pcie_dw *pcie = (struct tegra_pcie_dw *)\n\t\t\t\t     dev_get_drvdata(s->private);\n\tu32 val;\n\n\tseq_printf(s, \"Tx L0s entry count : %u\\n\",\n\t\t   event_counter_prog(pcie, EVENT_COUNTER_EVENT_Tx_L0S));\n\n\tseq_printf(s, \"Rx L0s entry count : %u\\n\",\n\t\t   event_counter_prog(pcie, EVENT_COUNTER_EVENT_Rx_L0S));\n\n\tseq_printf(s, \"Link L1 entry count : %u\\n\",\n\t\t   event_counter_prog(pcie, EVENT_COUNTER_EVENT_L1));\n\n\tseq_printf(s, \"Link L1.1 entry count : %u\\n\",\n\t\t   event_counter_prog(pcie, EVENT_COUNTER_EVENT_L1_1));\n\n\tseq_printf(s, \"Link L1.2 entry count : %u\\n\",\n\t\t   event_counter_prog(pcie, EVENT_COUNTER_EVENT_L1_2));\n\n\t \n\tdw_pcie_writel_dbi(&pcie->pci, pcie->ras_des_cap +\n\t\t\t   PCIE_RAS_DES_EVENT_COUNTER_CONTROL,\n\t\t\t   EVENT_COUNTER_ALL_CLEAR);\n\n\t \n\tval = EVENT_COUNTER_ENABLE_ALL << EVENT_COUNTER_ENABLE_SHIFT;\n\tval |= EVENT_COUNTER_GROUP_5 << EVENT_COUNTER_GROUP_SEL_SHIFT;\n\tdw_pcie_writel_dbi(&pcie->pci, pcie->ras_des_cap +\n\t\t\t   PCIE_RAS_DES_EVENT_COUNTER_CONTROL, val);\n\n\treturn 0;\n}\n\nstatic void init_host_aspm(struct tegra_pcie_dw *pcie)\n{\n\tstruct dw_pcie *pci = &pcie->pci;\n\tu32 val;\n\n\tval = dw_pcie_find_ext_capability(pci, PCI_EXT_CAP_ID_L1SS);\n\tpcie->cfg_link_cap_l1sub = val + PCI_L1SS_CAP;\n\n\tpcie->ras_des_cap = dw_pcie_find_ext_capability(&pcie->pci,\n\t\t\t\t\t\t\tPCI_EXT_CAP_ID_VNDR);\n\n\t \n\tval = EVENT_COUNTER_ENABLE_ALL << EVENT_COUNTER_ENABLE_SHIFT;\n\tval |= EVENT_COUNTER_GROUP_5 << EVENT_COUNTER_GROUP_SEL_SHIFT;\n\tdw_pcie_writel_dbi(pci, pcie->ras_des_cap +\n\t\t\t   PCIE_RAS_DES_EVENT_COUNTER_CONTROL, val);\n\n\t \n\tval = dw_pcie_readl_dbi(pci, pcie->cfg_link_cap_l1sub);\n\tval &= ~(PCI_L1SS_CAP_CM_RESTORE_TIME | PCI_L1SS_CAP_P_PWR_ON_VALUE);\n\tval |= (pcie->aspm_cmrt << 8);\n\tval |= (pcie->aspm_pwr_on_t << 19);\n\tdw_pcie_writel_dbi(pci, pcie->cfg_link_cap_l1sub, val);\n\n\t \n\tval = dw_pcie_readl_dbi(pci, PCIE_PORT_AFR);\n\tval &= ~PORT_AFR_L0S_ENTRANCE_LAT_MASK;\n\tval |= (pcie->aspm_l0s_enter_lat << PORT_AFR_L0S_ENTRANCE_LAT_SHIFT);\n\tval |= PORT_AFR_ENTER_ASPM;\n\tdw_pcie_writel_dbi(pci, PCIE_PORT_AFR, val);\n}\n\nstatic void init_debugfs(struct tegra_pcie_dw *pcie)\n{\n\tdebugfs_create_devm_seqfile(pcie->dev, \"aspm_state_cnt\", pcie->debugfs,\n\t\t\t\t    aspm_state_cnt);\n}\n#else\nstatic inline void disable_aspm_l12(struct tegra_pcie_dw *pcie) { return; }\nstatic inline void disable_aspm_l11(struct tegra_pcie_dw *pcie) { return; }\nstatic inline void init_host_aspm(struct tegra_pcie_dw *pcie) { return; }\nstatic inline void init_debugfs(struct tegra_pcie_dw *pcie) { return; }\n#endif\n\nstatic void tegra_pcie_enable_system_interrupts(struct dw_pcie_rp *pp)\n{\n\tstruct dw_pcie *pci = to_dw_pcie_from_pp(pp);\n\tstruct tegra_pcie_dw *pcie = to_tegra_pcie(pci);\n\tu32 val;\n\tu16 val_w;\n\n\tval = appl_readl(pcie, APPL_INTR_EN_L0_0);\n\tval |= APPL_INTR_EN_L0_0_LINK_STATE_INT_EN;\n\tappl_writel(pcie, val, APPL_INTR_EN_L0_0);\n\n\tif (!pcie->of_data->has_sbr_reset_fix) {\n\t\tval = appl_readl(pcie, APPL_INTR_EN_L1_0_0);\n\t\tval |= APPL_INTR_EN_L1_0_0_LINK_REQ_RST_NOT_INT_EN;\n\t\tappl_writel(pcie, val, APPL_INTR_EN_L1_0_0);\n\t}\n\n\tif (pcie->enable_cdm_check) {\n\t\tval = appl_readl(pcie, APPL_INTR_EN_L0_0);\n\t\tval |= pcie->of_data->cdm_chk_int_en_bit;\n\t\tappl_writel(pcie, val, APPL_INTR_EN_L0_0);\n\n\t\tval = appl_readl(pcie, APPL_INTR_EN_L1_18);\n\t\tval |= APPL_INTR_EN_L1_18_CDM_REG_CHK_CMP_ERR;\n\t\tval |= APPL_INTR_EN_L1_18_CDM_REG_CHK_LOGIC_ERR;\n\t\tappl_writel(pcie, val, APPL_INTR_EN_L1_18);\n\t}\n\n\tval_w = dw_pcie_readw_dbi(&pcie->pci, pcie->pcie_cap_base +\n\t\t\t\t  PCI_EXP_LNKSTA);\n\tpcie->init_link_width = FIELD_GET(PCI_EXP_LNKSTA_NLW, val_w);\n\n\tval_w = dw_pcie_readw_dbi(&pcie->pci, pcie->pcie_cap_base +\n\t\t\t\t  PCI_EXP_LNKCTL);\n\tval_w |= PCI_EXP_LNKCTL_LBMIE;\n\tdw_pcie_writew_dbi(&pcie->pci, pcie->pcie_cap_base + PCI_EXP_LNKCTL,\n\t\t\t   val_w);\n}\n\nstatic void tegra_pcie_enable_legacy_interrupts(struct dw_pcie_rp *pp)\n{\n\tstruct dw_pcie *pci = to_dw_pcie_from_pp(pp);\n\tstruct tegra_pcie_dw *pcie = to_tegra_pcie(pci);\n\tu32 val;\n\n\t \n\tval = appl_readl(pcie, APPL_INTR_EN_L0_0);\n\tval |= APPL_INTR_EN_L0_0_SYS_INTR_EN;\n\tval |= APPL_INTR_EN_L0_0_INT_INT_EN;\n\tappl_writel(pcie, val, APPL_INTR_EN_L0_0);\n\n\tval = appl_readl(pcie, APPL_INTR_EN_L1_8_0);\n\tval |= APPL_INTR_EN_L1_8_INTX_EN;\n\tval |= APPL_INTR_EN_L1_8_AUTO_BW_INT_EN;\n\tval |= APPL_INTR_EN_L1_8_BW_MGT_INT_EN;\n\tif (IS_ENABLED(CONFIG_PCIEAER))\n\t\tval |= APPL_INTR_EN_L1_8_AER_INT_EN;\n\tappl_writel(pcie, val, APPL_INTR_EN_L1_8_0);\n}\n\nstatic void tegra_pcie_enable_msi_interrupts(struct dw_pcie_rp *pp)\n{\n\tstruct dw_pcie *pci = to_dw_pcie_from_pp(pp);\n\tstruct tegra_pcie_dw *pcie = to_tegra_pcie(pci);\n\tu32 val;\n\n\t \n\tval = appl_readl(pcie, APPL_INTR_EN_L0_0);\n\tval |= APPL_INTR_EN_L0_0_SYS_MSI_INTR_EN;\n\tval |= APPL_INTR_EN_L0_0_MSI_RCV_INT_EN;\n\tappl_writel(pcie, val, APPL_INTR_EN_L0_0);\n}\n\nstatic void tegra_pcie_enable_interrupts(struct dw_pcie_rp *pp)\n{\n\tstruct dw_pcie *pci = to_dw_pcie_from_pp(pp);\n\tstruct tegra_pcie_dw *pcie = to_tegra_pcie(pci);\n\n\t \n\tappl_writel(pcie, 0xFFFFFFFF, APPL_INTR_STATUS_L0);\n\tappl_writel(pcie, 0xFFFFFFFF, APPL_INTR_STATUS_L1_0_0);\n\tappl_writel(pcie, 0xFFFFFFFF, APPL_INTR_STATUS_L1_1);\n\tappl_writel(pcie, 0xFFFFFFFF, APPL_INTR_STATUS_L1_2);\n\tappl_writel(pcie, 0xFFFFFFFF, APPL_INTR_STATUS_L1_3);\n\tappl_writel(pcie, 0xFFFFFFFF, APPL_INTR_STATUS_L1_6);\n\tappl_writel(pcie, 0xFFFFFFFF, APPL_INTR_STATUS_L1_7);\n\tappl_writel(pcie, 0xFFFFFFFF, APPL_INTR_STATUS_L1_8_0);\n\tappl_writel(pcie, 0xFFFFFFFF, APPL_INTR_STATUS_L1_9);\n\tappl_writel(pcie, 0xFFFFFFFF, APPL_INTR_STATUS_L1_10);\n\tappl_writel(pcie, 0xFFFFFFFF, APPL_INTR_STATUS_L1_11);\n\tappl_writel(pcie, 0xFFFFFFFF, APPL_INTR_STATUS_L1_13);\n\tappl_writel(pcie, 0xFFFFFFFF, APPL_INTR_STATUS_L1_14);\n\tappl_writel(pcie, 0xFFFFFFFF, APPL_INTR_STATUS_L1_15);\n\tappl_writel(pcie, 0xFFFFFFFF, APPL_INTR_STATUS_L1_17);\n\n\ttegra_pcie_enable_system_interrupts(pp);\n\ttegra_pcie_enable_legacy_interrupts(pp);\n\tif (IS_ENABLED(CONFIG_PCI_MSI))\n\t\ttegra_pcie_enable_msi_interrupts(pp);\n}\n\nstatic void config_gen3_gen4_eq_presets(struct tegra_pcie_dw *pcie)\n{\n\tstruct dw_pcie *pci = &pcie->pci;\n\tu32 val, offset, i;\n\n\t \n\tfor (i = 0; i < pcie->num_lanes; i++) {\n\t\tval = dw_pcie_readw_dbi(pci, CAP_SPCIE_CAP_OFF + (i * 2));\n\t\tval &= ~CAP_SPCIE_CAP_OFF_DSP_TX_PRESET0_MASK;\n\t\tval |= GEN3_GEN4_EQ_PRESET_INIT;\n\t\tval &= ~CAP_SPCIE_CAP_OFF_USP_TX_PRESET0_MASK;\n\t\tval |= (GEN3_GEN4_EQ_PRESET_INIT <<\n\t\t\t   CAP_SPCIE_CAP_OFF_USP_TX_PRESET0_SHIFT);\n\t\tdw_pcie_writew_dbi(pci, CAP_SPCIE_CAP_OFF + (i * 2), val);\n\n\t\toffset = dw_pcie_find_ext_capability(pci,\n\t\t\t\t\t\t     PCI_EXT_CAP_ID_PL_16GT) +\n\t\t\t\tPCI_PL_16GT_LE_CTRL;\n\t\tval = dw_pcie_readb_dbi(pci, offset + i);\n\t\tval &= ~PCI_PL_16GT_LE_CTRL_DSP_TX_PRESET_MASK;\n\t\tval |= GEN3_GEN4_EQ_PRESET_INIT;\n\t\tval &= ~PCI_PL_16GT_LE_CTRL_USP_TX_PRESET_MASK;\n\t\tval |= (GEN3_GEN4_EQ_PRESET_INIT <<\n\t\t\tPCI_PL_16GT_LE_CTRL_USP_TX_PRESET_SHIFT);\n\t\tdw_pcie_writeb_dbi(pci, offset + i, val);\n\t}\n\n\tval = dw_pcie_readl_dbi(pci, GEN3_RELATED_OFF);\n\tval &= ~GEN3_RELATED_OFF_RATE_SHADOW_SEL_MASK;\n\tdw_pcie_writel_dbi(pci, GEN3_RELATED_OFF, val);\n\n\tval = dw_pcie_readl_dbi(pci, GEN3_EQ_CONTROL_OFF);\n\tval &= ~GEN3_EQ_CONTROL_OFF_PSET_REQ_VEC_MASK;\n\tval |= (0x3ff << GEN3_EQ_CONTROL_OFF_PSET_REQ_VEC_SHIFT);\n\tval &= ~GEN3_EQ_CONTROL_OFF_FB_MODE_MASK;\n\tdw_pcie_writel_dbi(pci, GEN3_EQ_CONTROL_OFF, val);\n\n\tval = dw_pcie_readl_dbi(pci, GEN3_RELATED_OFF);\n\tval &= ~GEN3_RELATED_OFF_RATE_SHADOW_SEL_MASK;\n\tval |= (0x1 << GEN3_RELATED_OFF_RATE_SHADOW_SEL_SHIFT);\n\tdw_pcie_writel_dbi(pci, GEN3_RELATED_OFF, val);\n\n\tval = dw_pcie_readl_dbi(pci, GEN3_EQ_CONTROL_OFF);\n\tval &= ~GEN3_EQ_CONTROL_OFF_PSET_REQ_VEC_MASK;\n\tval |= (pcie->of_data->gen4_preset_vec <<\n\t\tGEN3_EQ_CONTROL_OFF_PSET_REQ_VEC_SHIFT);\n\tval &= ~GEN3_EQ_CONTROL_OFF_FB_MODE_MASK;\n\tdw_pcie_writel_dbi(pci, GEN3_EQ_CONTROL_OFF, val);\n\n\tval = dw_pcie_readl_dbi(pci, GEN3_RELATED_OFF);\n\tval &= ~GEN3_RELATED_OFF_RATE_SHADOW_SEL_MASK;\n\tdw_pcie_writel_dbi(pci, GEN3_RELATED_OFF, val);\n}\n\nstatic int tegra_pcie_dw_host_init(struct dw_pcie_rp *pp)\n{\n\tstruct dw_pcie *pci = to_dw_pcie_from_pp(pp);\n\tstruct tegra_pcie_dw *pcie = to_tegra_pcie(pci);\n\tu32 val;\n\tu16 val_16;\n\n\tpp->bridge->ops = &tegra_pci_ops;\n\n\tif (!pcie->pcie_cap_base)\n\t\tpcie->pcie_cap_base = dw_pcie_find_capability(&pcie->pci,\n\t\t\t\t\t\t\t      PCI_CAP_ID_EXP);\n\n\tval = dw_pcie_readl_dbi(pci, PCI_IO_BASE);\n\tval &= ~(IO_BASE_IO_DECODE | IO_BASE_IO_DECODE_BIT8);\n\tdw_pcie_writel_dbi(pci, PCI_IO_BASE, val);\n\n\tval = dw_pcie_readl_dbi(pci, PCI_PREF_MEMORY_BASE);\n\tval |= CFG_PREF_MEM_LIMIT_BASE_MEM_DECODE;\n\tval |= CFG_PREF_MEM_LIMIT_BASE_MEM_LIMIT_DECODE;\n\tdw_pcie_writel_dbi(pci, PCI_PREF_MEMORY_BASE, val);\n\n\tdw_pcie_writel_dbi(pci, PCI_BASE_ADDRESS_0, 0);\n\n\t \n\tval = dw_pcie_readl_dbi(pci, PORT_LOGIC_AMBA_ERROR_RESPONSE_DEFAULT);\n\tval &= ~(AMBA_ERROR_RESPONSE_CRS_MASK << AMBA_ERROR_RESPONSE_CRS_SHIFT);\n\tval |= (AMBA_ERROR_RESPONSE_CRS_OKAY_FFFF0001 <<\n\t\tAMBA_ERROR_RESPONSE_CRS_SHIFT);\n\tdw_pcie_writel_dbi(pci, PORT_LOGIC_AMBA_ERROR_RESPONSE_DEFAULT, val);\n\n\t \n\tval = dw_pcie_readl_dbi(pci, pcie->pcie_cap_base + PCI_EXP_LNKCAP);\n\tval &= ~PCI_EXP_LNKCAP_MLW;\n\tval |= FIELD_PREP(PCI_EXP_LNKCAP_MLW, pcie->num_lanes);\n\tdw_pcie_writel_dbi(pci, pcie->pcie_cap_base + PCI_EXP_LNKCAP, val);\n\n\t \n\tif (pcie->enable_srns) {\n\t\tval_16 = dw_pcie_readw_dbi(pci, pcie->pcie_cap_base +\n\t\t\t\t\t   PCI_EXP_LNKSTA);\n\t\tval_16 &= ~PCI_EXP_LNKSTA_SLC;\n\t\tdw_pcie_writew_dbi(pci, pcie->pcie_cap_base + PCI_EXP_LNKSTA,\n\t\t\t\t   val_16);\n\t}\n\n\tconfig_gen3_gen4_eq_presets(pcie);\n\n\tinit_host_aspm(pcie);\n\n\t \n\tif (!pcie->supports_clkreq) {\n\t\tdisable_aspm_l11(pcie);\n\t\tdisable_aspm_l12(pcie);\n\t}\n\n\tif (!pcie->of_data->has_l1ss_exit_fix) {\n\t\tval = dw_pcie_readl_dbi(pci, GEN3_RELATED_OFF);\n\t\tval &= ~GEN3_RELATED_OFF_GEN3_ZRXDC_NONCOMPL;\n\t\tdw_pcie_writel_dbi(pci, GEN3_RELATED_OFF, val);\n\t}\n\n\tif (pcie->update_fc_fixup) {\n\t\tval = dw_pcie_readl_dbi(pci, CFG_TIMER_CTRL_MAX_FUNC_NUM_OFF);\n\t\tval |= 0x1 << CFG_TIMER_CTRL_ACK_NAK_SHIFT;\n\t\tdw_pcie_writel_dbi(pci, CFG_TIMER_CTRL_MAX_FUNC_NUM_OFF, val);\n\t}\n\n\tclk_set_rate(pcie->core_clk, GEN4_CORE_CLK_FREQ);\n\n\treturn 0;\n}\n\nstatic int tegra_pcie_dw_start_link(struct dw_pcie *pci)\n{\n\tstruct tegra_pcie_dw *pcie = to_tegra_pcie(pci);\n\tstruct dw_pcie_rp *pp = &pci->pp;\n\tu32 val, offset, tmp;\n\tbool retry = true;\n\n\tif (pcie->of_data->mode == DW_PCIE_EP_TYPE) {\n\t\tenable_irq(pcie->pex_rst_irq);\n\t\treturn 0;\n\t}\n\nretry_link:\n\t \n\tval = appl_readl(pcie, APPL_PINMUX);\n\tval &= ~APPL_PINMUX_PEX_RST;\n\tappl_writel(pcie, val, APPL_PINMUX);\n\n\tusleep_range(100, 200);\n\n\t \n\tval = appl_readl(pcie, APPL_CTRL);\n\tval |= APPL_CTRL_LTSSM_EN;\n\tappl_writel(pcie, val, APPL_CTRL);\n\n\t \n\tval = appl_readl(pcie, APPL_PINMUX);\n\tval |= APPL_PINMUX_PEX_RST;\n\tappl_writel(pcie, val, APPL_PINMUX);\n\n\tmsleep(100);\n\n\tif (dw_pcie_wait_for_link(pci)) {\n\t\tif (!retry)\n\t\t\treturn 0;\n\t\t \n\t\tval = appl_readl(pcie, APPL_DEBUG);\n\t\tval &= APPL_DEBUG_LTSSM_STATE_MASK;\n\t\tval >>= APPL_DEBUG_LTSSM_STATE_SHIFT;\n\t\ttmp = appl_readl(pcie, APPL_LINK_STATUS);\n\t\ttmp &= APPL_LINK_STATUS_RDLH_LINK_UP;\n\t\tif (!(val == 0x11 && !tmp)) {\n\t\t\t \n\t\t\treturn 0;\n\t\t}\n\n\t\tdev_info(pci->dev, \"Link is down in DLL\");\n\t\tdev_info(pci->dev, \"Trying again with DLFE disabled\\n\");\n\t\t \n\t\tval = appl_readl(pcie, APPL_CTRL);\n\t\tval &= ~APPL_CTRL_LTSSM_EN;\n\t\tappl_writel(pcie, val, APPL_CTRL);\n\n\t\treset_control_assert(pcie->core_rst);\n\t\treset_control_deassert(pcie->core_rst);\n\n\t\toffset = dw_pcie_find_ext_capability(pci, PCI_EXT_CAP_ID_DLF);\n\t\tval = dw_pcie_readl_dbi(pci, offset + PCI_DLF_CAP);\n\t\tval &= ~PCI_DLF_EXCHANGE_ENABLE;\n\t\tdw_pcie_writel_dbi(pci, offset + PCI_DLF_CAP, val);\n\n\t\ttegra_pcie_dw_host_init(pp);\n\t\tdw_pcie_setup_rc(pp);\n\n\t\tretry = false;\n\t\tgoto retry_link;\n\t}\n\n\ttegra_pcie_icc_set(pcie);\n\n\ttegra_pcie_enable_interrupts(pp);\n\n\treturn 0;\n}\n\nstatic int tegra_pcie_dw_link_up(struct dw_pcie *pci)\n{\n\tstruct tegra_pcie_dw *pcie = to_tegra_pcie(pci);\n\tu32 val = dw_pcie_readw_dbi(pci, pcie->pcie_cap_base + PCI_EXP_LNKSTA);\n\n\treturn !!(val & PCI_EXP_LNKSTA_DLLLA);\n}\n\nstatic void tegra_pcie_dw_stop_link(struct dw_pcie *pci)\n{\n\tstruct tegra_pcie_dw *pcie = to_tegra_pcie(pci);\n\n\tdisable_irq(pcie->pex_rst_irq);\n}\n\nstatic const struct dw_pcie_ops tegra_dw_pcie_ops = {\n\t.link_up = tegra_pcie_dw_link_up,\n\t.start_link = tegra_pcie_dw_start_link,\n\t.stop_link = tegra_pcie_dw_stop_link,\n};\n\nstatic const struct dw_pcie_host_ops tegra_pcie_dw_host_ops = {\n\t.host_init = tegra_pcie_dw_host_init,\n};\n\nstatic void tegra_pcie_disable_phy(struct tegra_pcie_dw *pcie)\n{\n\tunsigned int phy_count = pcie->phy_count;\n\n\twhile (phy_count--) {\n\t\tphy_power_off(pcie->phys[phy_count]);\n\t\tphy_exit(pcie->phys[phy_count]);\n\t}\n}\n\nstatic int tegra_pcie_enable_phy(struct tegra_pcie_dw *pcie)\n{\n\tunsigned int i;\n\tint ret;\n\n\tfor (i = 0; i < pcie->phy_count; i++) {\n\t\tret = phy_init(pcie->phys[i]);\n\t\tif (ret < 0)\n\t\t\tgoto phy_power_off;\n\n\t\tret = phy_power_on(pcie->phys[i]);\n\t\tif (ret < 0)\n\t\t\tgoto phy_exit;\n\t}\n\n\treturn 0;\n\nphy_power_off:\n\twhile (i--) {\n\t\tphy_power_off(pcie->phys[i]);\nphy_exit:\n\t\tphy_exit(pcie->phys[i]);\n\t}\n\n\treturn ret;\n}\n\nstatic int tegra_pcie_dw_parse_dt(struct tegra_pcie_dw *pcie)\n{\n\tstruct platform_device *pdev = to_platform_device(pcie->dev);\n\tstruct device_node *np = pcie->dev->of_node;\n\tint ret;\n\n\tpcie->dbi_res = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"dbi\");\n\tif (!pcie->dbi_res) {\n\t\tdev_err(pcie->dev, \"Failed to find \\\"dbi\\\" region\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tret = of_property_read_u32(np, \"nvidia,aspm-cmrt-us\", &pcie->aspm_cmrt);\n\tif (ret < 0) {\n\t\tdev_info(pcie->dev, \"Failed to read ASPM T_cmrt: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = of_property_read_u32(np, \"nvidia,aspm-pwr-on-t-us\",\n\t\t\t\t   &pcie->aspm_pwr_on_t);\n\tif (ret < 0)\n\t\tdev_info(pcie->dev, \"Failed to read ASPM Power On time: %d\\n\",\n\t\t\t ret);\n\n\tret = of_property_read_u32(np, \"nvidia,aspm-l0s-entrance-latency-us\",\n\t\t\t\t   &pcie->aspm_l0s_enter_lat);\n\tif (ret < 0)\n\t\tdev_info(pcie->dev,\n\t\t\t \"Failed to read ASPM L0s Entrance latency: %d\\n\", ret);\n\n\tret = of_property_read_u32(np, \"num-lanes\", &pcie->num_lanes);\n\tif (ret < 0) {\n\t\tdev_err(pcie->dev, \"Failed to read num-lanes: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = of_property_read_u32_index(np, \"nvidia,bpmp\", 1, &pcie->cid);\n\tif (ret) {\n\t\tdev_err(pcie->dev, \"Failed to read Controller-ID: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = of_property_count_strings(np, \"phy-names\");\n\tif (ret < 0) {\n\t\tdev_err(pcie->dev, \"Failed to find PHY entries: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\tpcie->phy_count = ret;\n\n\tif (of_property_read_bool(np, \"nvidia,update-fc-fixup\"))\n\t\tpcie->update_fc_fixup = true;\n\n\t \n\tif (pcie->of_data->version == TEGRA194_DWC_IP_VER) {\n\t\tif (pcie->of_data->mode == DW_PCIE_EP_TYPE)\n\t\t\tpcie->enable_ext_refclk = true;\n\t} else {\n\t\tpcie->enable_ext_refclk =\n\t\t\tof_property_read_bool(pcie->dev->of_node,\n\t\t\t\t\t      \"nvidia,enable-ext-refclk\");\n\t}\n\n\tpcie->supports_clkreq =\n\t\tof_property_read_bool(pcie->dev->of_node, \"supports-clkreq\");\n\n\tpcie->enable_cdm_check =\n\t\tof_property_read_bool(np, \"snps,enable-cdm-check\");\n\n\tif (pcie->of_data->version == TEGRA234_DWC_IP_VER)\n\t\tpcie->enable_srns =\n\t\t\tof_property_read_bool(np, \"nvidia,enable-srns\");\n\n\tif (pcie->of_data->mode == DW_PCIE_RC_TYPE)\n\t\treturn 0;\n\n\t \n\tpcie->pex_rst_gpiod = devm_gpiod_get(pcie->dev, \"reset\", GPIOD_IN);\n\tif (IS_ERR(pcie->pex_rst_gpiod)) {\n\t\tint err = PTR_ERR(pcie->pex_rst_gpiod);\n\t\tconst char *level = KERN_ERR;\n\n\t\tif (err == -EPROBE_DEFER)\n\t\t\tlevel = KERN_DEBUG;\n\n\t\tdev_printk(level, pcie->dev,\n\t\t\t   dev_fmt(\"Failed to get PERST GPIO: %d\\n\"),\n\t\t\t   err);\n\t\treturn err;\n\t}\n\n\tpcie->pex_refclk_sel_gpiod = devm_gpiod_get(pcie->dev,\n\t\t\t\t\t\t    \"nvidia,refclk-select\",\n\t\t\t\t\t\t    GPIOD_OUT_HIGH);\n\tif (IS_ERR(pcie->pex_refclk_sel_gpiod)) {\n\t\tint err = PTR_ERR(pcie->pex_refclk_sel_gpiod);\n\t\tconst char *level = KERN_ERR;\n\n\t\tif (err == -EPROBE_DEFER)\n\t\t\tlevel = KERN_DEBUG;\n\n\t\tdev_printk(level, pcie->dev,\n\t\t\t   dev_fmt(\"Failed to get REFCLK select GPIOs: %d\\n\"),\n\t\t\t   err);\n\t\tpcie->pex_refclk_sel_gpiod = NULL;\n\t}\n\n\treturn 0;\n}\n\nstatic int tegra_pcie_bpmp_set_ctrl_state(struct tegra_pcie_dw *pcie,\n\t\t\t\t\t  bool enable)\n{\n\tstruct mrq_uphy_response resp;\n\tstruct tegra_bpmp_message msg;\n\tstruct mrq_uphy_request req;\n\n\t \n\tif (pcie->of_data->version == TEGRA194_DWC_IP_VER && pcie->cid == 5)\n\t\treturn 0;\n\n\tmemset(&req, 0, sizeof(req));\n\tmemset(&resp, 0, sizeof(resp));\n\n\treq.cmd = CMD_UPHY_PCIE_CONTROLLER_STATE;\n\treq.controller_state.pcie_controller = pcie->cid;\n\treq.controller_state.enable = enable;\n\n\tmemset(&msg, 0, sizeof(msg));\n\tmsg.mrq = MRQ_UPHY;\n\tmsg.tx.data = &req;\n\tmsg.tx.size = sizeof(req);\n\tmsg.rx.data = &resp;\n\tmsg.rx.size = sizeof(resp);\n\n\treturn tegra_bpmp_transfer(pcie->bpmp, &msg);\n}\n\nstatic int tegra_pcie_bpmp_set_pll_state(struct tegra_pcie_dw *pcie,\n\t\t\t\t\t bool enable)\n{\n\tstruct mrq_uphy_response resp;\n\tstruct tegra_bpmp_message msg;\n\tstruct mrq_uphy_request req;\n\n\tmemset(&req, 0, sizeof(req));\n\tmemset(&resp, 0, sizeof(resp));\n\n\tif (enable) {\n\t\treq.cmd = CMD_UPHY_PCIE_EP_CONTROLLER_PLL_INIT;\n\t\treq.ep_ctrlr_pll_init.ep_controller = pcie->cid;\n\t} else {\n\t\treq.cmd = CMD_UPHY_PCIE_EP_CONTROLLER_PLL_OFF;\n\t\treq.ep_ctrlr_pll_off.ep_controller = pcie->cid;\n\t}\n\n\tmemset(&msg, 0, sizeof(msg));\n\tmsg.mrq = MRQ_UPHY;\n\tmsg.tx.data = &req;\n\tmsg.tx.size = sizeof(req);\n\tmsg.rx.data = &resp;\n\tmsg.rx.size = sizeof(resp);\n\n\treturn tegra_bpmp_transfer(pcie->bpmp, &msg);\n}\n\nstatic void tegra_pcie_downstream_dev_to_D0(struct tegra_pcie_dw *pcie)\n{\n\tstruct dw_pcie_rp *pp = &pcie->pci.pp;\n\tstruct pci_bus *child, *root_bus = NULL;\n\tstruct pci_dev *pdev;\n\n\t \n\n\tlist_for_each_entry(child, &pp->bridge->bus->children, node) {\n\t\t \n\t\tif (child->parent == pp->bridge->bus) {\n\t\t\troot_bus = child;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!root_bus) {\n\t\tdev_err(pcie->dev, \"Failed to find downstream devices\\n\");\n\t\treturn;\n\t}\n\n\tlist_for_each_entry(pdev, &root_bus->devices, bus_list) {\n\t\tif (PCI_SLOT(pdev->devfn) == 0) {\n\t\t\tif (pci_set_power_state(pdev, PCI_D0))\n\t\t\t\tdev_err(pcie->dev,\n\t\t\t\t\t\"Failed to transition %s to D0 state\\n\",\n\t\t\t\t\tdev_name(&pdev->dev));\n\t\t}\n\t}\n}\n\nstatic int tegra_pcie_get_slot_regulators(struct tegra_pcie_dw *pcie)\n{\n\tpcie->slot_ctl_3v3 = devm_regulator_get_optional(pcie->dev, \"vpcie3v3\");\n\tif (IS_ERR(pcie->slot_ctl_3v3)) {\n\t\tif (PTR_ERR(pcie->slot_ctl_3v3) != -ENODEV)\n\t\t\treturn PTR_ERR(pcie->slot_ctl_3v3);\n\n\t\tpcie->slot_ctl_3v3 = NULL;\n\t}\n\n\tpcie->slot_ctl_12v = devm_regulator_get_optional(pcie->dev, \"vpcie12v\");\n\tif (IS_ERR(pcie->slot_ctl_12v)) {\n\t\tif (PTR_ERR(pcie->slot_ctl_12v) != -ENODEV)\n\t\t\treturn PTR_ERR(pcie->slot_ctl_12v);\n\n\t\tpcie->slot_ctl_12v = NULL;\n\t}\n\n\treturn 0;\n}\n\nstatic int tegra_pcie_enable_slot_regulators(struct tegra_pcie_dw *pcie)\n{\n\tint ret;\n\n\tif (pcie->slot_ctl_3v3) {\n\t\tret = regulator_enable(pcie->slot_ctl_3v3);\n\t\tif (ret < 0) {\n\t\t\tdev_err(pcie->dev,\n\t\t\t\t\"Failed to enable 3.3V slot supply: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (pcie->slot_ctl_12v) {\n\t\tret = regulator_enable(pcie->slot_ctl_12v);\n\t\tif (ret < 0) {\n\t\t\tdev_err(pcie->dev,\n\t\t\t\t\"Failed to enable 12V slot supply: %d\\n\", ret);\n\t\t\tgoto fail_12v_enable;\n\t\t}\n\t}\n\n\t \n\tif (pcie->slot_ctl_3v3 || pcie->slot_ctl_12v)\n\t\tmsleep(100);\n\n\treturn 0;\n\nfail_12v_enable:\n\tif (pcie->slot_ctl_3v3)\n\t\tregulator_disable(pcie->slot_ctl_3v3);\n\treturn ret;\n}\n\nstatic void tegra_pcie_disable_slot_regulators(struct tegra_pcie_dw *pcie)\n{\n\tif (pcie->slot_ctl_12v)\n\t\tregulator_disable(pcie->slot_ctl_12v);\n\tif (pcie->slot_ctl_3v3)\n\t\tregulator_disable(pcie->slot_ctl_3v3);\n}\n\nstatic int tegra_pcie_config_controller(struct tegra_pcie_dw *pcie,\n\t\t\t\t\tbool en_hw_hot_rst)\n{\n\tint ret;\n\tu32 val;\n\n\tret = tegra_pcie_bpmp_set_ctrl_state(pcie, true);\n\tif (ret) {\n\t\tdev_err(pcie->dev,\n\t\t\t\"Failed to enable controller %u: %d\\n\", pcie->cid, ret);\n\t\treturn ret;\n\t}\n\n\tif (pcie->enable_ext_refclk) {\n\t\tret = tegra_pcie_bpmp_set_pll_state(pcie, true);\n\t\tif (ret) {\n\t\t\tdev_err(pcie->dev, \"Failed to init UPHY: %d\\n\", ret);\n\t\t\tgoto fail_pll_init;\n\t\t}\n\t}\n\n\tret = tegra_pcie_enable_slot_regulators(pcie);\n\tif (ret < 0)\n\t\tgoto fail_slot_reg_en;\n\n\tret = regulator_enable(pcie->pex_ctl_supply);\n\tif (ret < 0) {\n\t\tdev_err(pcie->dev, \"Failed to enable regulator: %d\\n\", ret);\n\t\tgoto fail_reg_en;\n\t}\n\n\tret = clk_prepare_enable(pcie->core_clk);\n\tif (ret) {\n\t\tdev_err(pcie->dev, \"Failed to enable core clock: %d\\n\", ret);\n\t\tgoto fail_core_clk;\n\t}\n\n\tret = reset_control_deassert(pcie->core_apb_rst);\n\tif (ret) {\n\t\tdev_err(pcie->dev, \"Failed to deassert core APB reset: %d\\n\",\n\t\t\tret);\n\t\tgoto fail_core_apb_rst;\n\t}\n\n\tif (en_hw_hot_rst || pcie->of_data->has_sbr_reset_fix) {\n\t\t \n\t\tval = appl_readl(pcie, APPL_CTRL);\n\t\tval &= ~(APPL_CTRL_HW_HOT_RST_MODE_MASK <<\n\t\t\t APPL_CTRL_HW_HOT_RST_MODE_SHIFT);\n\t\tval |= (APPL_CTRL_HW_HOT_RST_MODE_IMDT_RST_LTSSM_EN <<\n\t\t\tAPPL_CTRL_HW_HOT_RST_MODE_SHIFT);\n\t\tval |= APPL_CTRL_HW_HOT_RST_EN;\n\t\tappl_writel(pcie, val, APPL_CTRL);\n\t}\n\n\tret = tegra_pcie_enable_phy(pcie);\n\tif (ret) {\n\t\tdev_err(pcie->dev, \"Failed to enable PHY: %d\\n\", ret);\n\t\tgoto fail_phy;\n\t}\n\n\t \n\tappl_writel(pcie, pcie->dbi_res->start & APPL_CFG_BASE_ADDR_MASK,\n\t\t    APPL_CFG_BASE_ADDR);\n\n\t \n\tappl_writel(pcie, APPL_DM_TYPE_RP, APPL_DM_TYPE);\n\n\tappl_writel(pcie, 0x0, APPL_CFG_SLCG_OVERRIDE);\n\n\tval = appl_readl(pcie, APPL_CTRL);\n\tappl_writel(pcie, val | APPL_CTRL_SYS_PRE_DET_STATE, APPL_CTRL);\n\n\tval = appl_readl(pcie, APPL_CFG_MISC);\n\tval |= (APPL_CFG_MISC_ARCACHE_VAL << APPL_CFG_MISC_ARCACHE_SHIFT);\n\tappl_writel(pcie, val, APPL_CFG_MISC);\n\n\tif (pcie->enable_srns || pcie->enable_ext_refclk) {\n\t\t \n\t\tval = appl_readl(pcie, APPL_PINMUX);\n\t\tval |= APPL_PINMUX_CLK_OUTPUT_IN_OVERRIDE_EN;\n\t\tval &= ~APPL_PINMUX_CLK_OUTPUT_IN_OVERRIDE;\n\t\tappl_writel(pcie, val, APPL_PINMUX);\n\t}\n\n\tif (!pcie->supports_clkreq) {\n\t\tval = appl_readl(pcie, APPL_PINMUX);\n\t\tval |= APPL_PINMUX_CLKREQ_OVERRIDE_EN;\n\t\tval &= ~APPL_PINMUX_CLKREQ_OVERRIDE;\n\t\tappl_writel(pcie, val, APPL_PINMUX);\n\t}\n\n\t \n\tappl_writel(pcie,\n\t\t    pcie->atu_dma_res->start & APPL_CFG_IATU_DMA_BASE_ADDR_MASK,\n\t\t    APPL_CFG_IATU_DMA_BASE_ADDR);\n\n\treset_control_deassert(pcie->core_rst);\n\n\treturn ret;\n\nfail_phy:\n\treset_control_assert(pcie->core_apb_rst);\nfail_core_apb_rst:\n\tclk_disable_unprepare(pcie->core_clk);\nfail_core_clk:\n\tregulator_disable(pcie->pex_ctl_supply);\nfail_reg_en:\n\ttegra_pcie_disable_slot_regulators(pcie);\nfail_slot_reg_en:\n\tif (pcie->enable_ext_refclk)\n\t\ttegra_pcie_bpmp_set_pll_state(pcie, false);\nfail_pll_init:\n\ttegra_pcie_bpmp_set_ctrl_state(pcie, false);\n\n\treturn ret;\n}\n\nstatic void tegra_pcie_unconfig_controller(struct tegra_pcie_dw *pcie)\n{\n\tint ret;\n\n\tret = reset_control_assert(pcie->core_rst);\n\tif (ret)\n\t\tdev_err(pcie->dev, \"Failed to assert \\\"core\\\" reset: %d\\n\", ret);\n\n\ttegra_pcie_disable_phy(pcie);\n\n\tret = reset_control_assert(pcie->core_apb_rst);\n\tif (ret)\n\t\tdev_err(pcie->dev, \"Failed to assert APB reset: %d\\n\", ret);\n\n\tclk_disable_unprepare(pcie->core_clk);\n\n\tret = regulator_disable(pcie->pex_ctl_supply);\n\tif (ret)\n\t\tdev_err(pcie->dev, \"Failed to disable regulator: %d\\n\", ret);\n\n\ttegra_pcie_disable_slot_regulators(pcie);\n\n\tif (pcie->enable_ext_refclk) {\n\t\tret = tegra_pcie_bpmp_set_pll_state(pcie, false);\n\t\tif (ret)\n\t\t\tdev_err(pcie->dev, \"Failed to deinit UPHY: %d\\n\", ret);\n\t}\n\n\tret = tegra_pcie_bpmp_set_ctrl_state(pcie, false);\n\tif (ret)\n\t\tdev_err(pcie->dev, \"Failed to disable controller %d: %d\\n\",\n\t\t\tpcie->cid, ret);\n}\n\nstatic int tegra_pcie_init_controller(struct tegra_pcie_dw *pcie)\n{\n\tstruct dw_pcie *pci = &pcie->pci;\n\tstruct dw_pcie_rp *pp = &pci->pp;\n\tint ret;\n\n\tret = tegra_pcie_config_controller(pcie, false);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tpp->ops = &tegra_pcie_dw_host_ops;\n\n\tret = dw_pcie_host_init(pp);\n\tif (ret < 0) {\n\t\tdev_err(pcie->dev, \"Failed to add PCIe port: %d\\n\", ret);\n\t\tgoto fail_host_init;\n\t}\n\n\treturn 0;\n\nfail_host_init:\n\ttegra_pcie_unconfig_controller(pcie);\n\treturn ret;\n}\n\nstatic int tegra_pcie_try_link_l2(struct tegra_pcie_dw *pcie)\n{\n\tu32 val;\n\n\tif (!tegra_pcie_dw_link_up(&pcie->pci))\n\t\treturn 0;\n\n\tval = appl_readl(pcie, APPL_RADM_STATUS);\n\tval |= APPL_PM_XMT_TURNOFF_STATE;\n\tappl_writel(pcie, val, APPL_RADM_STATUS);\n\n\treturn readl_poll_timeout_atomic(pcie->appl_base + APPL_DEBUG, val,\n\t\t\t\t val & APPL_DEBUG_PM_LINKST_IN_L2_LAT,\n\t\t\t\t 1, PME_ACK_TIMEOUT);\n}\n\nstatic void tegra_pcie_dw_pme_turnoff(struct tegra_pcie_dw *pcie)\n{\n\tu32 data;\n\tint err;\n\n\tif (!tegra_pcie_dw_link_up(&pcie->pci)) {\n\t\tdev_dbg(pcie->dev, \"PCIe link is not up...!\\n\");\n\t\treturn;\n\t}\n\n\t \n\tappl_writel(pcie, 0x0, APPL_INTR_EN_L0_0);\n\n\tif (tegra_pcie_try_link_l2(pcie)) {\n\t\tdev_info(pcie->dev, \"Link didn't transition to L2 state\\n\");\n\t\t \n\t\tdata = appl_readl(pcie, APPL_PINMUX);\n\t\tdata &= ~APPL_PINMUX_PEX_RST;\n\t\tappl_writel(pcie, data, APPL_PINMUX);\n\n\t\t \n\t\tdata = readl(pcie->appl_base + APPL_CTRL);\n\t\tdata &= ~APPL_CTRL_LTSSM_EN;\n\t\twritel(data, pcie->appl_base + APPL_CTRL);\n\n\t\terr = readl_poll_timeout_atomic(pcie->appl_base + APPL_DEBUG,\n\t\t\t\t\t\tdata,\n\t\t\t\t\t\t((data &\n\t\t\t\t\t\tAPPL_DEBUG_LTSSM_STATE_MASK) >>\n\t\t\t\t\t\tAPPL_DEBUG_LTSSM_STATE_SHIFT) ==\n\t\t\t\t\t\tLTSSM_STATE_PRE_DETECT,\n\t\t\t\t\t\t1, LTSSM_TIMEOUT);\n\t\tif (err)\n\t\t\tdev_info(pcie->dev, \"Link didn't go to detect state\\n\");\n\t}\n\t \n\tdata = appl_readl(pcie, APPL_PINMUX);\n\tdata |= (APPL_PINMUX_CLKREQ_OVERRIDE_EN | APPL_PINMUX_CLKREQ_OVERRIDE);\n\t \n\tdata |= APPL_PINMUX_CLK_OUTPUT_IN_OVERRIDE_EN;\n\tdata &= ~APPL_PINMUX_CLK_OUTPUT_IN_OVERRIDE;\n\tappl_writel(pcie, data, APPL_PINMUX);\n}\n\nstatic void tegra_pcie_deinit_controller(struct tegra_pcie_dw *pcie)\n{\n\ttegra_pcie_downstream_dev_to_D0(pcie);\n\tdw_pcie_host_deinit(&pcie->pci.pp);\n\ttegra_pcie_dw_pme_turnoff(pcie);\n\ttegra_pcie_unconfig_controller(pcie);\n}\n\nstatic int tegra_pcie_config_rp(struct tegra_pcie_dw *pcie)\n{\n\tstruct device *dev = pcie->dev;\n\tchar *name;\n\tint ret;\n\n\tpm_runtime_enable(dev);\n\n\tret = pm_runtime_get_sync(dev);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to get runtime sync for PCIe dev: %d\\n\",\n\t\t\tret);\n\t\tgoto fail_pm_get_sync;\n\t}\n\n\tret = pinctrl_pm_select_default_state(dev);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to configure sideband pins: %d\\n\", ret);\n\t\tgoto fail_pm_get_sync;\n\t}\n\n\tret = tegra_pcie_init_controller(pcie);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to initialize controller: %d\\n\", ret);\n\t\tgoto fail_pm_get_sync;\n\t}\n\n\tpcie->link_state = tegra_pcie_dw_link_up(&pcie->pci);\n\tif (!pcie->link_state) {\n\t\tret = -ENOMEDIUM;\n\t\tgoto fail_host_init;\n\t}\n\n\tname = devm_kasprintf(dev, GFP_KERNEL, \"%pOFP\", dev->of_node);\n\tif (!name) {\n\t\tret = -ENOMEM;\n\t\tgoto fail_host_init;\n\t}\n\n\tpcie->debugfs = debugfs_create_dir(name, NULL);\n\tinit_debugfs(pcie);\n\n\treturn ret;\n\nfail_host_init:\n\ttegra_pcie_deinit_controller(pcie);\nfail_pm_get_sync:\n\tpm_runtime_put_sync(dev);\n\tpm_runtime_disable(dev);\n\treturn ret;\n}\n\nstatic void pex_ep_event_pex_rst_assert(struct tegra_pcie_dw *pcie)\n{\n\tu32 val;\n\tint ret;\n\n\tif (pcie->ep_state == EP_STATE_DISABLED)\n\t\treturn;\n\n\t \n\tval = appl_readl(pcie, APPL_CTRL);\n\tval &= ~APPL_CTRL_LTSSM_EN;\n\tappl_writel(pcie, val, APPL_CTRL);\n\n\tret = readl_poll_timeout(pcie->appl_base + APPL_DEBUG, val,\n\t\t\t\t ((val & APPL_DEBUG_LTSSM_STATE_MASK) >>\n\t\t\t\t APPL_DEBUG_LTSSM_STATE_SHIFT) ==\n\t\t\t\t LTSSM_STATE_PRE_DETECT,\n\t\t\t\t 1, LTSSM_TIMEOUT);\n\tif (ret)\n\t\tdev_err(pcie->dev, \"Failed to go Detect state: %d\\n\", ret);\n\n\treset_control_assert(pcie->core_rst);\n\n\ttegra_pcie_disable_phy(pcie);\n\n\treset_control_assert(pcie->core_apb_rst);\n\n\tclk_disable_unprepare(pcie->core_clk);\n\n\tpm_runtime_put_sync(pcie->dev);\n\n\tif (pcie->enable_ext_refclk) {\n\t\tret = tegra_pcie_bpmp_set_pll_state(pcie, false);\n\t\tif (ret)\n\t\t\tdev_err(pcie->dev, \"Failed to turn off UPHY: %d\\n\",\n\t\t\t\tret);\n\t}\n\n\tret = tegra_pcie_bpmp_set_pll_state(pcie, false);\n\tif (ret)\n\t\tdev_err(pcie->dev, \"Failed to turn off UPHY: %d\\n\", ret);\n\n\tpcie->ep_state = EP_STATE_DISABLED;\n\tdev_dbg(pcie->dev, \"Uninitialization of endpoint is completed\\n\");\n}\n\nstatic void pex_ep_event_pex_rst_deassert(struct tegra_pcie_dw *pcie)\n{\n\tstruct dw_pcie *pci = &pcie->pci;\n\tstruct dw_pcie_ep *ep = &pci->ep;\n\tstruct device *dev = pcie->dev;\n\tu32 val;\n\tint ret;\n\tu16 val_16;\n\n\tif (pcie->ep_state == EP_STATE_ENABLED)\n\t\treturn;\n\n\tret = pm_runtime_resume_and_get(dev);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to get runtime sync for PCIe dev: %d\\n\",\n\t\t\tret);\n\t\treturn;\n\t}\n\n\tret = tegra_pcie_bpmp_set_ctrl_state(pcie, true);\n\tif (ret) {\n\t\tdev_err(pcie->dev, \"Failed to enable controller %u: %d\\n\",\n\t\t\tpcie->cid, ret);\n\t\tgoto fail_set_ctrl_state;\n\t}\n\n\tif (pcie->enable_ext_refclk) {\n\t\tret = tegra_pcie_bpmp_set_pll_state(pcie, true);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Failed to init UPHY for PCIe EP: %d\\n\",\n\t\t\t\tret);\n\t\t\tgoto fail_pll_init;\n\t\t}\n\t}\n\n\tret = clk_prepare_enable(pcie->core_clk);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to enable core clock: %d\\n\", ret);\n\t\tgoto fail_core_clk_enable;\n\t}\n\n\tret = reset_control_deassert(pcie->core_apb_rst);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to deassert core APB reset: %d\\n\", ret);\n\t\tgoto fail_core_apb_rst;\n\t}\n\n\tret = tegra_pcie_enable_phy(pcie);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to enable PHY: %d\\n\", ret);\n\t\tgoto fail_phy;\n\t}\n\n\t \n\tappl_writel(pcie, 0xFFFFFFFF, APPL_INTR_STATUS_L0);\n\tappl_writel(pcie, 0xFFFFFFFF, APPL_INTR_STATUS_L1_0_0);\n\tappl_writel(pcie, 0xFFFFFFFF, APPL_INTR_STATUS_L1_1);\n\tappl_writel(pcie, 0xFFFFFFFF, APPL_INTR_STATUS_L1_2);\n\tappl_writel(pcie, 0xFFFFFFFF, APPL_INTR_STATUS_L1_3);\n\tappl_writel(pcie, 0xFFFFFFFF, APPL_INTR_STATUS_L1_6);\n\tappl_writel(pcie, 0xFFFFFFFF, APPL_INTR_STATUS_L1_7);\n\tappl_writel(pcie, 0xFFFFFFFF, APPL_INTR_STATUS_L1_8_0);\n\tappl_writel(pcie, 0xFFFFFFFF, APPL_INTR_STATUS_L1_9);\n\tappl_writel(pcie, 0xFFFFFFFF, APPL_INTR_STATUS_L1_10);\n\tappl_writel(pcie, 0xFFFFFFFF, APPL_INTR_STATUS_L1_11);\n\tappl_writel(pcie, 0xFFFFFFFF, APPL_INTR_STATUS_L1_13);\n\tappl_writel(pcie, 0xFFFFFFFF, APPL_INTR_STATUS_L1_14);\n\tappl_writel(pcie, 0xFFFFFFFF, APPL_INTR_STATUS_L1_15);\n\tappl_writel(pcie, 0xFFFFFFFF, APPL_INTR_STATUS_L1_17);\n\n\t \n\tval = appl_readl(pcie, APPL_DM_TYPE);\n\tval &= ~APPL_DM_TYPE_MASK;\n\tval |= APPL_DM_TYPE_EP;\n\tappl_writel(pcie, val, APPL_DM_TYPE);\n\n\tappl_writel(pcie, 0x0, APPL_CFG_SLCG_OVERRIDE);\n\n\tval = appl_readl(pcie, APPL_CTRL);\n\tval |= APPL_CTRL_SYS_PRE_DET_STATE;\n\tval |= APPL_CTRL_HW_HOT_RST_EN;\n\tappl_writel(pcie, val, APPL_CTRL);\n\n\tval = appl_readl(pcie, APPL_CFG_MISC);\n\tval |= APPL_CFG_MISC_SLV_EP_MODE;\n\tval |= (APPL_CFG_MISC_ARCACHE_VAL << APPL_CFG_MISC_ARCACHE_SHIFT);\n\tappl_writel(pcie, val, APPL_CFG_MISC);\n\n\tval = appl_readl(pcie, APPL_PINMUX);\n\tval |= APPL_PINMUX_CLK_OUTPUT_IN_OVERRIDE_EN;\n\tval |= APPL_PINMUX_CLK_OUTPUT_IN_OVERRIDE;\n\tappl_writel(pcie, val, APPL_PINMUX);\n\n\tappl_writel(pcie, pcie->dbi_res->start & APPL_CFG_BASE_ADDR_MASK,\n\t\t    APPL_CFG_BASE_ADDR);\n\n\tappl_writel(pcie, pcie->atu_dma_res->start &\n\t\t    APPL_CFG_IATU_DMA_BASE_ADDR_MASK,\n\t\t    APPL_CFG_IATU_DMA_BASE_ADDR);\n\n\tval = appl_readl(pcie, APPL_INTR_EN_L0_0);\n\tval |= APPL_INTR_EN_L0_0_SYS_INTR_EN;\n\tval |= APPL_INTR_EN_L0_0_LINK_STATE_INT_EN;\n\tval |= APPL_INTR_EN_L0_0_PCI_CMD_EN_INT_EN;\n\tappl_writel(pcie, val, APPL_INTR_EN_L0_0);\n\n\tval = appl_readl(pcie, APPL_INTR_EN_L1_0_0);\n\tval |= APPL_INTR_EN_L1_0_0_HOT_RESET_DONE_INT_EN;\n\tval |= APPL_INTR_EN_L1_0_0_RDLH_LINK_UP_INT_EN;\n\tappl_writel(pcie, val, APPL_INTR_EN_L1_0_0);\n\n\treset_control_deassert(pcie->core_rst);\n\n\tif (pcie->update_fc_fixup) {\n\t\tval = dw_pcie_readl_dbi(pci, CFG_TIMER_CTRL_MAX_FUNC_NUM_OFF);\n\t\tval |= 0x1 << CFG_TIMER_CTRL_ACK_NAK_SHIFT;\n\t\tdw_pcie_writel_dbi(pci, CFG_TIMER_CTRL_MAX_FUNC_NUM_OFF, val);\n\t}\n\n\tconfig_gen3_gen4_eq_presets(pcie);\n\n\tinit_host_aspm(pcie);\n\n\t \n\tif (!pcie->supports_clkreq) {\n\t\tdisable_aspm_l11(pcie);\n\t\tdisable_aspm_l12(pcie);\n\t}\n\n\tif (!pcie->of_data->has_l1ss_exit_fix) {\n\t\tval = dw_pcie_readl_dbi(pci, GEN3_RELATED_OFF);\n\t\tval &= ~GEN3_RELATED_OFF_GEN3_ZRXDC_NONCOMPL;\n\t\tdw_pcie_writel_dbi(pci, GEN3_RELATED_OFF, val);\n\t}\n\n\tpcie->pcie_cap_base = dw_pcie_find_capability(&pcie->pci,\n\t\t\t\t\t\t      PCI_CAP_ID_EXP);\n\n\t \n\tif (pcie->enable_srns) {\n\t\tval_16 = dw_pcie_readw_dbi(pci, pcie->pcie_cap_base +\n\t\t\t\t\t   PCI_EXP_LNKSTA);\n\t\tval_16 &= ~PCI_EXP_LNKSTA_SLC;\n\t\tdw_pcie_writew_dbi(pci, pcie->pcie_cap_base + PCI_EXP_LNKSTA,\n\t\t\t\t   val_16);\n\t}\n\n\tclk_set_rate(pcie->core_clk, GEN4_CORE_CLK_FREQ);\n\n\tval = (ep->msi_mem_phys & MSIX_ADDR_MATCH_LOW_OFF_MASK);\n\tval |= MSIX_ADDR_MATCH_LOW_OFF_EN;\n\tdw_pcie_writel_dbi(pci, MSIX_ADDR_MATCH_LOW_OFF, val);\n\tval = (upper_32_bits(ep->msi_mem_phys) & MSIX_ADDR_MATCH_HIGH_OFF_MASK);\n\tdw_pcie_writel_dbi(pci, MSIX_ADDR_MATCH_HIGH_OFF, val);\n\n\tret = dw_pcie_ep_init_complete(ep);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to complete initialization: %d\\n\", ret);\n\t\tgoto fail_init_complete;\n\t}\n\n\tdw_pcie_ep_init_notify(ep);\n\n\t \n\tif (pcie->of_data->has_ltr_req_fix) {\n\t\tval = appl_readl(pcie, APPL_LTR_MSG_2);\n\t\tval |= APPL_LTR_MSG_2_LTR_MSG_REQ_STATE;\n\t\tappl_writel(pcie, val, APPL_LTR_MSG_2);\n\t}\n\n\t \n\tval = appl_readl(pcie, APPL_CTRL);\n\tval |= APPL_CTRL_LTSSM_EN;\n\tappl_writel(pcie, val, APPL_CTRL);\n\n\tpcie->ep_state = EP_STATE_ENABLED;\n\tdev_dbg(dev, \"Initialization of endpoint is completed\\n\");\n\n\treturn;\n\nfail_init_complete:\n\treset_control_assert(pcie->core_rst);\n\ttegra_pcie_disable_phy(pcie);\nfail_phy:\n\treset_control_assert(pcie->core_apb_rst);\nfail_core_apb_rst:\n\tclk_disable_unprepare(pcie->core_clk);\nfail_core_clk_enable:\n\ttegra_pcie_bpmp_set_pll_state(pcie, false);\nfail_pll_init:\n\ttegra_pcie_bpmp_set_ctrl_state(pcie, false);\nfail_set_ctrl_state:\n\tpm_runtime_put_sync(dev);\n}\n\nstatic irqreturn_t tegra_pcie_ep_pex_rst_irq(int irq, void *arg)\n{\n\tstruct tegra_pcie_dw *pcie = arg;\n\n\tif (gpiod_get_value(pcie->pex_rst_gpiod))\n\t\tpex_ep_event_pex_rst_assert(pcie);\n\telse\n\t\tpex_ep_event_pex_rst_deassert(pcie);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int tegra_pcie_ep_raise_legacy_irq(struct tegra_pcie_dw *pcie, u16 irq)\n{\n\t \n\tif (irq > 1)\n\t\treturn -EINVAL;\n\n\tappl_writel(pcie, 1, APPL_LEGACY_INTX);\n\tusleep_range(1000, 2000);\n\tappl_writel(pcie, 0, APPL_LEGACY_INTX);\n\treturn 0;\n}\n\nstatic int tegra_pcie_ep_raise_msi_irq(struct tegra_pcie_dw *pcie, u16 irq)\n{\n\tif (unlikely(irq > 31))\n\t\treturn -EINVAL;\n\n\tappl_writel(pcie, BIT(irq), APPL_MSI_CTRL_1);\n\n\treturn 0;\n}\n\nstatic int tegra_pcie_ep_raise_msix_irq(struct tegra_pcie_dw *pcie, u16 irq)\n{\n\tstruct dw_pcie_ep *ep = &pcie->pci.ep;\n\n\twritel(irq, ep->msi_mem);\n\n\treturn 0;\n}\n\nstatic int tegra_pcie_ep_raise_irq(struct dw_pcie_ep *ep, u8 func_no,\n\t\t\t\t   enum pci_epc_irq_type type,\n\t\t\t\t   u16 interrupt_num)\n{\n\tstruct dw_pcie *pci = to_dw_pcie_from_ep(ep);\n\tstruct tegra_pcie_dw *pcie = to_tegra_pcie(pci);\n\n\tswitch (type) {\n\tcase PCI_EPC_IRQ_LEGACY:\n\t\treturn tegra_pcie_ep_raise_legacy_irq(pcie, interrupt_num);\n\n\tcase PCI_EPC_IRQ_MSI:\n\t\treturn tegra_pcie_ep_raise_msi_irq(pcie, interrupt_num);\n\n\tcase PCI_EPC_IRQ_MSIX:\n\t\treturn tegra_pcie_ep_raise_msix_irq(pcie, interrupt_num);\n\n\tdefault:\n\t\tdev_err(pci->dev, \"Unknown IRQ type\\n\");\n\t\treturn -EPERM;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct pci_epc_features tegra_pcie_epc_features = {\n\t.linkup_notifier = true,\n\t.core_init_notifier = true,\n\t.msi_capable = false,\n\t.msix_capable = false,\n\t.reserved_bar = 1 << BAR_2 | 1 << BAR_3 | 1 << BAR_4 | 1 << BAR_5,\n\t.bar_fixed_64bit = 1 << BAR_0,\n\t.bar_fixed_size[0] = SZ_1M,\n};\n\nstatic const struct pci_epc_features*\ntegra_pcie_ep_get_features(struct dw_pcie_ep *ep)\n{\n\treturn &tegra_pcie_epc_features;\n}\n\nstatic const struct dw_pcie_ep_ops pcie_ep_ops = {\n\t.raise_irq = tegra_pcie_ep_raise_irq,\n\t.get_features = tegra_pcie_ep_get_features,\n};\n\nstatic int tegra_pcie_config_ep(struct tegra_pcie_dw *pcie,\n\t\t\t\tstruct platform_device *pdev)\n{\n\tstruct dw_pcie *pci = &pcie->pci;\n\tstruct device *dev = pcie->dev;\n\tstruct dw_pcie_ep *ep;\n\tchar *name;\n\tint ret;\n\n\tep = &pci->ep;\n\tep->ops = &pcie_ep_ops;\n\n\tep->page_size = SZ_64K;\n\n\tret = gpiod_set_debounce(pcie->pex_rst_gpiod, PERST_DEBOUNCE_TIME);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to set PERST GPIO debounce time: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tret = gpiod_to_irq(pcie->pex_rst_gpiod);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to get IRQ for PERST GPIO: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tpcie->pex_rst_irq = (unsigned int)ret;\n\n\tname = devm_kasprintf(dev, GFP_KERNEL, \"tegra_pcie_%u_pex_rst_irq\",\n\t\t\t      pcie->cid);\n\tif (!name) {\n\t\tdev_err(dev, \"Failed to create PERST IRQ string\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tirq_set_status_flags(pcie->pex_rst_irq, IRQ_NOAUTOEN);\n\n\tpcie->ep_state = EP_STATE_DISABLED;\n\n\tret = devm_request_threaded_irq(dev, pcie->pex_rst_irq, NULL,\n\t\t\t\t\ttegra_pcie_ep_pex_rst_irq,\n\t\t\t\t\tIRQF_TRIGGER_RISING |\n\t\t\t\t\tIRQF_TRIGGER_FALLING | IRQF_ONESHOT,\n\t\t\t\t\tname, (void *)pcie);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to request IRQ for PERST: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tpm_runtime_enable(dev);\n\n\tret = dw_pcie_ep_init(ep);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to initialize DWC Endpoint subsystem: %d\\n\",\n\t\t\tret);\n\t\tpm_runtime_disable(dev);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int tegra_pcie_dw_probe(struct platform_device *pdev)\n{\n\tconst struct tegra_pcie_dw_of_data *data;\n\tstruct device *dev = &pdev->dev;\n\tstruct resource *atu_dma_res;\n\tstruct tegra_pcie_dw *pcie;\n\tstruct dw_pcie_rp *pp;\n\tstruct dw_pcie *pci;\n\tstruct phy **phys;\n\tchar *name;\n\tint ret;\n\tu32 i;\n\n\tdata = of_device_get_match_data(dev);\n\n\tpcie = devm_kzalloc(dev, sizeof(*pcie), GFP_KERNEL);\n\tif (!pcie)\n\t\treturn -ENOMEM;\n\n\tpci = &pcie->pci;\n\tpci->dev = &pdev->dev;\n\tpci->ops = &tegra_dw_pcie_ops;\n\tpcie->dev = &pdev->dev;\n\tpcie->of_data = (struct tegra_pcie_dw_of_data *)data;\n\tpci->n_fts[0] = pcie->of_data->n_fts[0];\n\tpci->n_fts[1] = pcie->of_data->n_fts[1];\n\tpp = &pci->pp;\n\tpp->num_vectors = MAX_MSI_IRQS;\n\n\tret = tegra_pcie_dw_parse_dt(pcie);\n\tif (ret < 0) {\n\t\tconst char *level = KERN_ERR;\n\n\t\tif (ret == -EPROBE_DEFER)\n\t\t\tlevel = KERN_DEBUG;\n\n\t\tdev_printk(level, dev,\n\t\t\t   dev_fmt(\"Failed to parse device tree: %d\\n\"),\n\t\t\t   ret);\n\t\treturn ret;\n\t}\n\n\tret = tegra_pcie_get_slot_regulators(pcie);\n\tif (ret < 0) {\n\t\tconst char *level = KERN_ERR;\n\n\t\tif (ret == -EPROBE_DEFER)\n\t\t\tlevel = KERN_DEBUG;\n\n\t\tdev_printk(level, dev,\n\t\t\t   dev_fmt(\"Failed to get slot regulators: %d\\n\"),\n\t\t\t   ret);\n\t\treturn ret;\n\t}\n\n\tif (pcie->pex_refclk_sel_gpiod)\n\t\tgpiod_set_value(pcie->pex_refclk_sel_gpiod, 1);\n\n\tpcie->pex_ctl_supply = devm_regulator_get(dev, \"vddio-pex-ctl\");\n\tif (IS_ERR(pcie->pex_ctl_supply)) {\n\t\tret = PTR_ERR(pcie->pex_ctl_supply);\n\t\tif (ret != -EPROBE_DEFER)\n\t\t\tdev_err(dev, \"Failed to get regulator: %ld\\n\",\n\t\t\t\tPTR_ERR(pcie->pex_ctl_supply));\n\t\treturn ret;\n\t}\n\n\tpcie->core_clk = devm_clk_get(dev, \"core\");\n\tif (IS_ERR(pcie->core_clk)) {\n\t\tdev_err(dev, \"Failed to get core clock: %ld\\n\",\n\t\t\tPTR_ERR(pcie->core_clk));\n\t\treturn PTR_ERR(pcie->core_clk);\n\t}\n\n\tpcie->appl_res = platform_get_resource_byname(pdev, IORESOURCE_MEM,\n\t\t\t\t\t\t      \"appl\");\n\tif (!pcie->appl_res) {\n\t\tdev_err(dev, \"Failed to find \\\"appl\\\" region\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tpcie->appl_base = devm_ioremap_resource(dev, pcie->appl_res);\n\tif (IS_ERR(pcie->appl_base))\n\t\treturn PTR_ERR(pcie->appl_base);\n\n\tpcie->core_apb_rst = devm_reset_control_get(dev, \"apb\");\n\tif (IS_ERR(pcie->core_apb_rst)) {\n\t\tdev_err(dev, \"Failed to get APB reset: %ld\\n\",\n\t\t\tPTR_ERR(pcie->core_apb_rst));\n\t\treturn PTR_ERR(pcie->core_apb_rst);\n\t}\n\n\tphys = devm_kcalloc(dev, pcie->phy_count, sizeof(*phys), GFP_KERNEL);\n\tif (!phys)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < pcie->phy_count; i++) {\n\t\tname = kasprintf(GFP_KERNEL, \"p2u-%u\", i);\n\t\tif (!name) {\n\t\t\tdev_err(dev, \"Failed to create P2U string\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tphys[i] = devm_phy_get(dev, name);\n\t\tkfree(name);\n\t\tif (IS_ERR(phys[i])) {\n\t\t\tret = PTR_ERR(phys[i]);\n\t\t\tif (ret != -EPROBE_DEFER)\n\t\t\t\tdev_err(dev, \"Failed to get PHY: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tpcie->phys = phys;\n\n\tatu_dma_res = platform_get_resource_byname(pdev, IORESOURCE_MEM,\n\t\t\t\t\t\t   \"atu_dma\");\n\tif (!atu_dma_res) {\n\t\tdev_err(dev, \"Failed to find \\\"atu_dma\\\" region\\n\");\n\t\treturn -ENODEV;\n\t}\n\tpcie->atu_dma_res = atu_dma_res;\n\n\tpci->atu_size = resource_size(atu_dma_res);\n\tpci->atu_base = devm_ioremap_resource(dev, atu_dma_res);\n\tif (IS_ERR(pci->atu_base))\n\t\treturn PTR_ERR(pci->atu_base);\n\n\tpcie->core_rst = devm_reset_control_get(dev, \"core\");\n\tif (IS_ERR(pcie->core_rst)) {\n\t\tdev_err(dev, \"Failed to get core reset: %ld\\n\",\n\t\t\tPTR_ERR(pcie->core_rst));\n\t\treturn PTR_ERR(pcie->core_rst);\n\t}\n\n\tpp->irq = platform_get_irq_byname(pdev, \"intr\");\n\tif (pp->irq < 0)\n\t\treturn pp->irq;\n\n\tpcie->bpmp = tegra_bpmp_get(dev);\n\tif (IS_ERR(pcie->bpmp))\n\t\treturn PTR_ERR(pcie->bpmp);\n\n\tplatform_set_drvdata(pdev, pcie);\n\n\tpcie->icc_path = devm_of_icc_get(&pdev->dev, \"write\");\n\tret = PTR_ERR_OR_ZERO(pcie->icc_path);\n\tif (ret) {\n\t\ttegra_bpmp_put(pcie->bpmp);\n\t\tdev_err_probe(&pdev->dev, ret, \"failed to get write interconnect\\n\");\n\t\treturn ret;\n\t}\n\n\tswitch (pcie->of_data->mode) {\n\tcase DW_PCIE_RC_TYPE:\n\t\tret = devm_request_irq(dev, pp->irq, tegra_pcie_rp_irq_handler,\n\t\t\t\t       IRQF_SHARED, \"tegra-pcie-intr\", pcie);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Failed to request IRQ %d: %d\\n\", pp->irq,\n\t\t\t\tret);\n\t\t\tgoto fail;\n\t\t}\n\n\t\tret = tegra_pcie_config_rp(pcie);\n\t\tif (ret && ret != -ENOMEDIUM)\n\t\t\tgoto fail;\n\t\telse\n\t\t\treturn 0;\n\t\tbreak;\n\n\tcase DW_PCIE_EP_TYPE:\n\t\tret = devm_request_threaded_irq(dev, pp->irq,\n\t\t\t\t\t\ttegra_pcie_ep_hard_irq,\n\t\t\t\t\t\ttegra_pcie_ep_irq_thread,\n\t\t\t\t\t\tIRQF_SHARED | IRQF_ONESHOT,\n\t\t\t\t\t\t\"tegra-pcie-ep-intr\", pcie);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Failed to request IRQ %d: %d\\n\", pp->irq,\n\t\t\t\tret);\n\t\t\tgoto fail;\n\t\t}\n\n\t\tret = tegra_pcie_config_ep(pcie, pdev);\n\t\tif (ret < 0)\n\t\t\tgoto fail;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(dev, \"Invalid PCIe device type %d\\n\",\n\t\t\tpcie->of_data->mode);\n\t}\n\nfail:\n\ttegra_bpmp_put(pcie->bpmp);\n\treturn ret;\n}\n\nstatic void tegra_pcie_dw_remove(struct platform_device *pdev)\n{\n\tstruct tegra_pcie_dw *pcie = platform_get_drvdata(pdev);\n\n\tif (pcie->of_data->mode == DW_PCIE_RC_TYPE) {\n\t\tif (!pcie->link_state)\n\t\t\treturn;\n\n\t\tdebugfs_remove_recursive(pcie->debugfs);\n\t\ttegra_pcie_deinit_controller(pcie);\n\t\tpm_runtime_put_sync(pcie->dev);\n\t} else {\n\t\tdisable_irq(pcie->pex_rst_irq);\n\t\tpex_ep_event_pex_rst_assert(pcie);\n\t}\n\n\tpm_runtime_disable(pcie->dev);\n\ttegra_bpmp_put(pcie->bpmp);\n\tif (pcie->pex_refclk_sel_gpiod)\n\t\tgpiod_set_value(pcie->pex_refclk_sel_gpiod, 0);\n}\n\nstatic int tegra_pcie_dw_suspend_late(struct device *dev)\n{\n\tstruct tegra_pcie_dw *pcie = dev_get_drvdata(dev);\n\tu32 val;\n\n\tif (pcie->of_data->mode == DW_PCIE_EP_TYPE) {\n\t\tdev_err(dev, \"Failed to Suspend as Tegra PCIe is in EP mode\\n\");\n\t\treturn -EPERM;\n\t}\n\n\tif (!pcie->link_state)\n\t\treturn 0;\n\n\t \n\tif (!pcie->of_data->has_sbr_reset_fix) {\n\t\tval = appl_readl(pcie, APPL_CTRL);\n\t\tval &= ~(APPL_CTRL_HW_HOT_RST_MODE_MASK <<\n\t\t\t APPL_CTRL_HW_HOT_RST_MODE_SHIFT);\n\t\tval |= APPL_CTRL_HW_HOT_RST_EN;\n\t\tappl_writel(pcie, val, APPL_CTRL);\n\t}\n\n\treturn 0;\n}\n\nstatic int tegra_pcie_dw_suspend_noirq(struct device *dev)\n{\n\tstruct tegra_pcie_dw *pcie = dev_get_drvdata(dev);\n\n\tif (!pcie->link_state)\n\t\treturn 0;\n\n\ttegra_pcie_downstream_dev_to_D0(pcie);\n\ttegra_pcie_dw_pme_turnoff(pcie);\n\ttegra_pcie_unconfig_controller(pcie);\n\n\treturn 0;\n}\n\nstatic int tegra_pcie_dw_resume_noirq(struct device *dev)\n{\n\tstruct tegra_pcie_dw *pcie = dev_get_drvdata(dev);\n\tint ret;\n\n\tif (!pcie->link_state)\n\t\treturn 0;\n\n\tret = tegra_pcie_config_controller(pcie, true);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = tegra_pcie_dw_host_init(&pcie->pci.pp);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to init host: %d\\n\", ret);\n\t\tgoto fail_host_init;\n\t}\n\n\tdw_pcie_setup_rc(&pcie->pci.pp);\n\n\tret = tegra_pcie_dw_start_link(&pcie->pci);\n\tif (ret < 0)\n\t\tgoto fail_host_init;\n\n\treturn 0;\n\nfail_host_init:\n\ttegra_pcie_unconfig_controller(pcie);\n\treturn ret;\n}\n\nstatic int tegra_pcie_dw_resume_early(struct device *dev)\n{\n\tstruct tegra_pcie_dw *pcie = dev_get_drvdata(dev);\n\tu32 val;\n\n\tif (pcie->of_data->mode == DW_PCIE_EP_TYPE) {\n\t\tdev_err(dev, \"Suspend is not supported in EP mode\");\n\t\treturn -ENOTSUPP;\n\t}\n\n\tif (!pcie->link_state)\n\t\treturn 0;\n\n\t \n\tif (!pcie->of_data->has_sbr_reset_fix) {\n\t\tval = appl_readl(pcie, APPL_CTRL);\n\t\tval &= ~(APPL_CTRL_HW_HOT_RST_MODE_MASK <<\n\t\t\t APPL_CTRL_HW_HOT_RST_MODE_SHIFT);\n\t\tval |= APPL_CTRL_HW_HOT_RST_MODE_IMDT_RST <<\n\t\t       APPL_CTRL_HW_HOT_RST_MODE_SHIFT;\n\t\tval &= ~APPL_CTRL_HW_HOT_RST_EN;\n\t\tappl_writel(pcie, val, APPL_CTRL);\n\t}\n\n\treturn 0;\n}\n\nstatic void tegra_pcie_dw_shutdown(struct platform_device *pdev)\n{\n\tstruct tegra_pcie_dw *pcie = platform_get_drvdata(pdev);\n\n\tif (pcie->of_data->mode == DW_PCIE_RC_TYPE) {\n\t\tif (!pcie->link_state)\n\t\t\treturn;\n\n\t\tdebugfs_remove_recursive(pcie->debugfs);\n\t\ttegra_pcie_downstream_dev_to_D0(pcie);\n\n\t\tdisable_irq(pcie->pci.pp.irq);\n\t\tif (IS_ENABLED(CONFIG_PCI_MSI))\n\t\t\tdisable_irq(pcie->pci.pp.msi_irq[0]);\n\n\t\ttegra_pcie_dw_pme_turnoff(pcie);\n\t\ttegra_pcie_unconfig_controller(pcie);\n\t\tpm_runtime_put_sync(pcie->dev);\n\t} else {\n\t\tdisable_irq(pcie->pex_rst_irq);\n\t\tpex_ep_event_pex_rst_assert(pcie);\n\t}\n}\n\nstatic const struct tegra_pcie_dw_of_data tegra194_pcie_dw_rc_of_data = {\n\t.version = TEGRA194_DWC_IP_VER,\n\t.mode = DW_PCIE_RC_TYPE,\n\t.cdm_chk_int_en_bit = BIT(19),\n\t \n\t.gen4_preset_vec = 0x360,\n\t.n_fts = { 52, 52 },\n};\n\nstatic const struct tegra_pcie_dw_of_data tegra194_pcie_dw_ep_of_data = {\n\t.version = TEGRA194_DWC_IP_VER,\n\t.mode = DW_PCIE_EP_TYPE,\n\t.cdm_chk_int_en_bit = BIT(19),\n\t \n\t.gen4_preset_vec = 0x360,\n\t.n_fts = { 52, 52 },\n};\n\nstatic const struct tegra_pcie_dw_of_data tegra234_pcie_dw_rc_of_data = {\n\t.version = TEGRA234_DWC_IP_VER,\n\t.mode = DW_PCIE_RC_TYPE,\n\t.has_msix_doorbell_access_fix = true,\n\t.has_sbr_reset_fix = true,\n\t.has_l1ss_exit_fix = true,\n\t.cdm_chk_int_en_bit = BIT(18),\n\t \n\t.gen4_preset_vec = 0x340,\n\t.n_fts = { 52, 80 },\n};\n\nstatic const struct tegra_pcie_dw_of_data tegra234_pcie_dw_ep_of_data = {\n\t.version = TEGRA234_DWC_IP_VER,\n\t.mode = DW_PCIE_EP_TYPE,\n\t.has_l1ss_exit_fix = true,\n\t.has_ltr_req_fix = true,\n\t.cdm_chk_int_en_bit = BIT(18),\n\t \n\t.gen4_preset_vec = 0x340,\n\t.n_fts = { 52, 80 },\n};\n\nstatic const struct of_device_id tegra_pcie_dw_of_match[] = {\n\t{\n\t\t.compatible = \"nvidia,tegra194-pcie\",\n\t\t.data = &tegra194_pcie_dw_rc_of_data,\n\t},\n\t{\n\t\t.compatible = \"nvidia,tegra194-pcie-ep\",\n\t\t.data = &tegra194_pcie_dw_ep_of_data,\n\t},\n\t{\n\t\t.compatible = \"nvidia,tegra234-pcie\",\n\t\t.data = &tegra234_pcie_dw_rc_of_data,\n\t},\n\t{\n\t\t.compatible = \"nvidia,tegra234-pcie-ep\",\n\t\t.data = &tegra234_pcie_dw_ep_of_data,\n\t},\n\t{}\n};\n\nstatic const struct dev_pm_ops tegra_pcie_dw_pm_ops = {\n\t.suspend_late = tegra_pcie_dw_suspend_late,\n\t.suspend_noirq = tegra_pcie_dw_suspend_noirq,\n\t.resume_noirq = tegra_pcie_dw_resume_noirq,\n\t.resume_early = tegra_pcie_dw_resume_early,\n};\n\nstatic struct platform_driver tegra_pcie_dw_driver = {\n\t.probe = tegra_pcie_dw_probe,\n\t.remove_new = tegra_pcie_dw_remove,\n\t.shutdown = tegra_pcie_dw_shutdown,\n\t.driver = {\n\t\t.name\t= \"tegra194-pcie\",\n\t\t.pm = &tegra_pcie_dw_pm_ops,\n\t\t.of_match_table = tegra_pcie_dw_of_match,\n\t},\n};\nmodule_platform_driver(tegra_pcie_dw_driver);\n\nMODULE_DEVICE_TABLE(of, tegra_pcie_dw_of_match);\n\nMODULE_AUTHOR(\"Vidya Sagar <vidyas@nvidia.com>\");\nMODULE_DESCRIPTION(\"NVIDIA PCIe host controller driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}