{
  "module_name": "pcie-hisi.c",
  "hash_id": "2e6a6f58b2226b3f89ec81736a2f3514fcb7f518f16dac49e874b6b8bea9e36a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/controller/dwc/pcie-hisi.c",
  "human_readable_source": "\n \n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/platform_device.h>\n#include <linux/pci.h>\n#include <linux/pci-acpi.h>\n#include <linux/pci-ecam.h>\n#include \"../../pci.h\"\n\n#if defined(CONFIG_PCI_HISI) || (defined(CONFIG_ACPI) && defined(CONFIG_PCI_QUIRKS))\n\nstruct hisi_pcie {\n\tvoid __iomem\t*reg_base;\n};\n\nstatic int hisi_pcie_rd_conf(struct pci_bus *bus, u32 devfn, int where,\n\t\t\t     int size, u32 *val)\n{\n\tstruct pci_config_window *cfg = bus->sysdata;\n\tint dev = PCI_SLOT(devfn);\n\n\tif (bus->number == cfg->busr.start) {\n\t\t \n\t\tif (dev > 0)\n\t\t\treturn PCIBIOS_DEVICE_NOT_FOUND;\n\t\telse\n\t\t\treturn pci_generic_config_read32(bus, devfn, where,\n\t\t\t\t\t\t\t size, val);\n\t}\n\n\treturn pci_generic_config_read(bus, devfn, where, size, val);\n}\n\nstatic int hisi_pcie_wr_conf(struct pci_bus *bus, u32 devfn,\n\t\t\t     int where, int size, u32 val)\n{\n\tstruct pci_config_window *cfg = bus->sysdata;\n\tint dev = PCI_SLOT(devfn);\n\n\tif (bus->number == cfg->busr.start) {\n\t\t \n\t\tif (dev > 0)\n\t\t\treturn PCIBIOS_DEVICE_NOT_FOUND;\n\t\telse\n\t\t\treturn pci_generic_config_write32(bus, devfn, where,\n\t\t\t\t\t\t\t  size, val);\n\t}\n\n\treturn pci_generic_config_write(bus, devfn, where, size, val);\n}\n\nstatic void __iomem *hisi_pcie_map_bus(struct pci_bus *bus, unsigned int devfn,\n\t\t\t\t       int where)\n{\n\tstruct pci_config_window *cfg = bus->sysdata;\n\tstruct hisi_pcie *pcie = cfg->priv;\n\n\tif (bus->number == cfg->busr.start)\n\t\treturn pcie->reg_base + where;\n\telse\n\t\treturn pci_ecam_map_bus(bus, devfn, where);\n}\n\n#if defined(CONFIG_ACPI) && defined(CONFIG_PCI_QUIRKS)\n\nstatic int hisi_pcie_init(struct pci_config_window *cfg)\n{\n\tstruct device *dev = cfg->parent;\n\tstruct hisi_pcie *pcie;\n\tstruct acpi_device *adev = to_acpi_device(dev);\n\tstruct acpi_pci_root *root = acpi_driver_data(adev);\n\tstruct resource *res;\n\tint ret;\n\n\tpcie = devm_kzalloc(dev, sizeof(*pcie), GFP_KERNEL);\n\tif (!pcie)\n\t\treturn -ENOMEM;\n\n\t \n\tres = devm_kzalloc(dev, sizeof(*res), GFP_KERNEL);\n\tif (!res)\n\t\treturn -ENOMEM;\n\n\tret = acpi_get_rc_resources(dev, \"HISI0081\", root->segment, res);\n\tif (ret) {\n\t\tdev_err(dev, \"can't get rc base address\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tpcie->reg_base = devm_pci_remap_cfgspace(dev, res->start, resource_size(res));\n\tif (!pcie->reg_base)\n\t\treturn -ENOMEM;\n\n\tcfg->priv = pcie;\n\treturn 0;\n}\n\nconst struct pci_ecam_ops hisi_pcie_ops = {\n\t.init         =  hisi_pcie_init,\n\t.pci_ops      = {\n\t\t.map_bus    = hisi_pcie_map_bus,\n\t\t.read       = hisi_pcie_rd_conf,\n\t\t.write      = hisi_pcie_wr_conf,\n\t}\n};\n\n#endif\n\n#ifdef CONFIG_PCI_HISI\n\nstatic int hisi_pcie_platform_init(struct pci_config_window *cfg)\n{\n\tstruct device *dev = cfg->parent;\n\tstruct hisi_pcie *pcie;\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct resource *res;\n\n\tpcie = devm_kzalloc(dev, sizeof(*pcie), GFP_KERNEL);\n\tif (!pcie)\n\t\treturn -ENOMEM;\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 1);\n\tif (!res) {\n\t\tdev_err(dev, \"missing \\\"reg[1]\\\"property\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpcie->reg_base = devm_pci_remap_cfgspace(dev, res->start, resource_size(res));\n\tif (!pcie->reg_base)\n\t\treturn -ENOMEM;\n\n\tcfg->priv = pcie;\n\treturn 0;\n}\n\nstatic const struct pci_ecam_ops hisi_pcie_platform_ops = {\n\t.init         =  hisi_pcie_platform_init,\n\t.pci_ops      = {\n\t\t.map_bus    = hisi_pcie_map_bus,\n\t\t.read       = hisi_pcie_rd_conf,\n\t\t.write      = hisi_pcie_wr_conf,\n\t}\n};\n\nstatic const struct of_device_id hisi_pcie_almost_ecam_of_match[] = {\n\t{\n\t\t.compatible =  \"hisilicon,hip06-pcie-ecam\",\n\t\t.data\t    =  &hisi_pcie_platform_ops,\n\t},\n\t{\n\t\t.compatible =  \"hisilicon,hip07-pcie-ecam\",\n\t\t.data       =  &hisi_pcie_platform_ops,\n\t},\n\t{},\n};\n\nstatic struct platform_driver hisi_pcie_almost_ecam_driver = {\n\t.probe  = pci_host_common_probe,\n\t.driver = {\n\t\t   .name = \"hisi-pcie-almost-ecam\",\n\t\t   .of_match_table = hisi_pcie_almost_ecam_of_match,\n\t\t   .suppress_bind_attrs = true,\n\t},\n};\nbuiltin_platform_driver(hisi_pcie_almost_ecam_driver);\n\n#endif\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}