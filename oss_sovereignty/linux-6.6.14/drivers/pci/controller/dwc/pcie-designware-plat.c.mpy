{
  "module_name": "pcie-designware-plat.c",
  "hash_id": "20e390d2fd4481411c3be0ce7f232441f6e372fbce20bbafba340f6ac3b4b079",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/controller/dwc/pcie-designware-plat.c",
  "human_readable_source": "\n \n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/gpio.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/of.h>\n#include <linux/pci.h>\n#include <linux/platform_device.h>\n#include <linux/resource.h>\n#include <linux/types.h>\n\n#include \"pcie-designware.h\"\n\nstruct dw_plat_pcie {\n\tstruct dw_pcie\t\t\t*pci;\n\tenum dw_pcie_device_mode\tmode;\n};\n\nstruct dw_plat_pcie_of_data {\n\tenum dw_pcie_device_mode\tmode;\n};\n\nstatic const struct dw_pcie_host_ops dw_plat_pcie_host_ops = {\n};\n\nstatic void dw_plat_pcie_ep_init(struct dw_pcie_ep *ep)\n{\n\tstruct dw_pcie *pci = to_dw_pcie_from_ep(ep);\n\tenum pci_barno bar;\n\n\tfor (bar = 0; bar < PCI_STD_NUM_BARS; bar++)\n\t\tdw_pcie_ep_reset_bar(pci, bar);\n}\n\nstatic int dw_plat_pcie_ep_raise_irq(struct dw_pcie_ep *ep, u8 func_no,\n\t\t\t\t     enum pci_epc_irq_type type,\n\t\t\t\t     u16 interrupt_num)\n{\n\tstruct dw_pcie *pci = to_dw_pcie_from_ep(ep);\n\n\tswitch (type) {\n\tcase PCI_EPC_IRQ_LEGACY:\n\t\treturn dw_pcie_ep_raise_legacy_irq(ep, func_no);\n\tcase PCI_EPC_IRQ_MSI:\n\t\treturn dw_pcie_ep_raise_msi_irq(ep, func_no, interrupt_num);\n\tcase PCI_EPC_IRQ_MSIX:\n\t\treturn dw_pcie_ep_raise_msix_irq(ep, func_no, interrupt_num);\n\tdefault:\n\t\tdev_err(pci->dev, \"UNKNOWN IRQ type\\n\");\n\t}\n\n\treturn 0;\n}\n\nstatic const struct pci_epc_features dw_plat_pcie_epc_features = {\n\t.linkup_notifier = false,\n\t.msi_capable = true,\n\t.msix_capable = true,\n};\n\nstatic const struct pci_epc_features*\ndw_plat_pcie_get_features(struct dw_pcie_ep *ep)\n{\n\treturn &dw_plat_pcie_epc_features;\n}\n\nstatic const struct dw_pcie_ep_ops pcie_ep_ops = {\n\t.ep_init = dw_plat_pcie_ep_init,\n\t.raise_irq = dw_plat_pcie_ep_raise_irq,\n\t.get_features = dw_plat_pcie_get_features,\n};\n\nstatic int dw_plat_add_pcie_port(struct dw_plat_pcie *dw_plat_pcie,\n\t\t\t\t struct platform_device *pdev)\n{\n\tstruct dw_pcie *pci = dw_plat_pcie->pci;\n\tstruct dw_pcie_rp *pp = &pci->pp;\n\tstruct device *dev = &pdev->dev;\n\tint ret;\n\n\tpp->irq = platform_get_irq(pdev, 1);\n\tif (pp->irq < 0)\n\t\treturn pp->irq;\n\n\tpp->num_vectors = MAX_MSI_IRQS;\n\tpp->ops = &dw_plat_pcie_host_ops;\n\n\tret = dw_pcie_host_init(pp);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to initialize host\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int dw_plat_pcie_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct dw_plat_pcie *dw_plat_pcie;\n\tstruct dw_pcie *pci;\n\tint ret;\n\tconst struct dw_plat_pcie_of_data *data;\n\tenum dw_pcie_device_mode mode;\n\n\tdata = of_device_get_match_data(dev);\n\tif (!data)\n\t\treturn -EINVAL;\n\n\tmode = (enum dw_pcie_device_mode)data->mode;\n\n\tdw_plat_pcie = devm_kzalloc(dev, sizeof(*dw_plat_pcie), GFP_KERNEL);\n\tif (!dw_plat_pcie)\n\t\treturn -ENOMEM;\n\n\tpci = devm_kzalloc(dev, sizeof(*pci), GFP_KERNEL);\n\tif (!pci)\n\t\treturn -ENOMEM;\n\n\tpci->dev = dev;\n\n\tdw_plat_pcie->pci = pci;\n\tdw_plat_pcie->mode = mode;\n\n\tplatform_set_drvdata(pdev, dw_plat_pcie);\n\n\tswitch (dw_plat_pcie->mode) {\n\tcase DW_PCIE_RC_TYPE:\n\t\tif (!IS_ENABLED(CONFIG_PCIE_DW_PLAT_HOST))\n\t\t\treturn -ENODEV;\n\n\t\tret = dw_plat_add_pcie_port(dw_plat_pcie, pdev);\n\t\tbreak;\n\tcase DW_PCIE_EP_TYPE:\n\t\tif (!IS_ENABLED(CONFIG_PCIE_DW_PLAT_EP))\n\t\t\treturn -ENODEV;\n\n\t\tpci->ep.ops = &pcie_ep_ops;\n\t\tret = dw_pcie_ep_init(&pci->ep);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"INVALID device type %d\\n\", dw_plat_pcie->mode);\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic const struct dw_plat_pcie_of_data dw_plat_pcie_rc_of_data = {\n\t.mode = DW_PCIE_RC_TYPE,\n};\n\nstatic const struct dw_plat_pcie_of_data dw_plat_pcie_ep_of_data = {\n\t.mode = DW_PCIE_EP_TYPE,\n};\n\nstatic const struct of_device_id dw_plat_pcie_of_match[] = {\n\t{\n\t\t.compatible = \"snps,dw-pcie\",\n\t\t.data = &dw_plat_pcie_rc_of_data,\n\t},\n\t{\n\t\t.compatible = \"snps,dw-pcie-ep\",\n\t\t.data = &dw_plat_pcie_ep_of_data,\n\t},\n\t{},\n};\n\nstatic struct platform_driver dw_plat_pcie_driver = {\n\t.driver = {\n\t\t.name\t= \"dw-pcie\",\n\t\t.of_match_table = dw_plat_pcie_of_match,\n\t\t.suppress_bind_attrs = true,\n\t},\n\t.probe = dw_plat_pcie_probe,\n};\nbuiltin_platform_driver(dw_plat_pcie_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}