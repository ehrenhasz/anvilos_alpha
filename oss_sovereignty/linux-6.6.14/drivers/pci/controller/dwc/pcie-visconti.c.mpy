{
  "module_name": "pcie-visconti.c",
  "hash_id": "a5544dd057a16c5c7b28bbab7c4c3e7711ec0bf91d13fbb68ea26dc94ea307d4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/controller/dwc/pcie-visconti.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/gpio.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/iopoll.h>\n#include <linux/kernel.h>\n#include <linux/of_platform.h>\n#include <linux/pci.h>\n#include <linux/platform_device.h>\n#include <linux/resource.h>\n#include <linux/types.h>\n\n#include \"pcie-designware.h\"\n#include \"../../pci.h\"\n\nstruct visconti_pcie {\n\tstruct dw_pcie pci;\n\tvoid __iomem *ulreg_base;\n\tvoid __iomem *smu_base;\n\tvoid __iomem *mpu_base;\n\tstruct clk *refclk;\n\tstruct clk *coreclk;\n\tstruct clk *auxclk;\n};\n\n#define PCIE_UL_REG_S_PCIE_MODE\t\t0x00F4\n#define  PCIE_UL_REG_S_PCIE_MODE_EP\t0x00\n#define  PCIE_UL_REG_S_PCIE_MODE_RC\t0x04\n\n#define PCIE_UL_REG_S_PERSTN_CTRL\t0x00F8\n#define  PCIE_UL_IOM_PCIE_PERSTN_I_EN\tBIT(3)\n#define  PCIE_UL_DIRECT_PERSTN_EN\tBIT(2)\n#define  PCIE_UL_PERSTN_OUT\t\tBIT(1)\n#define  PCIE_UL_DIRECT_PERSTN\t\tBIT(0)\n#define  PCIE_UL_REG_S_PERSTN_CTRL_INIT\t(PCIE_UL_IOM_PCIE_PERSTN_I_EN | \\\n\t\t\t\t\t PCIE_UL_DIRECT_PERSTN_EN | \\\n\t\t\t\t\t PCIE_UL_DIRECT_PERSTN)\n\n#define PCIE_UL_REG_S_PHY_INIT_02\t0x0104\n#define  PCIE_UL_PHY0_SRAM_EXT_LD_DONE\tBIT(0)\n\n#define PCIE_UL_REG_S_PHY_INIT_03\t0x0108\n#define  PCIE_UL_PHY0_SRAM_INIT_DONE\tBIT(0)\n\n#define PCIE_UL_REG_S_INT_EVENT_MASK1\t0x0138\n#define  PCIE_UL_CFG_PME_INT\t\tBIT(0)\n#define  PCIE_UL_CFG_LINK_EQ_REQ_INT\tBIT(1)\n#define  PCIE_UL_EDMA_INT0\t\tBIT(2)\n#define  PCIE_UL_EDMA_INT1\t\tBIT(3)\n#define  PCIE_UL_EDMA_INT2\t\tBIT(4)\n#define  PCIE_UL_EDMA_INT3\t\tBIT(5)\n#define  PCIE_UL_S_INT_EVENT_MASK1_ALL  (PCIE_UL_CFG_PME_INT | \\\n\t\t\t\t\t PCIE_UL_CFG_LINK_EQ_REQ_INT | \\\n\t\t\t\t\t PCIE_UL_EDMA_INT0 | \\\n\t\t\t\t\t PCIE_UL_EDMA_INT1 | \\\n\t\t\t\t\t PCIE_UL_EDMA_INT2 | \\\n\t\t\t\t\t PCIE_UL_EDMA_INT3)\n\n#define PCIE_UL_REG_S_SB_MON\t\t0x0198\n#define PCIE_UL_REG_S_SIG_MON\t\t0x019C\n#define  PCIE_UL_CORE_RST_N_MON\t\tBIT(0)\n\n#define PCIE_UL_REG_V_SII_DBG_00\t0x0844\n#define PCIE_UL_REG_V_SII_GEN_CTRL_01\t0x0860\n#define  PCIE_UL_APP_LTSSM_ENABLE\tBIT(0)\n\n#define PCIE_UL_REG_V_PHY_ST_00\t\t0x0864\n#define  PCIE_UL_SMLH_LINK_UP\t\tBIT(0)\n\n#define PCIE_UL_REG_V_PHY_ST_02\t\t0x0868\n#define  PCIE_UL_S_DETECT_ACT\t\t0x01\n#define  PCIE_UL_S_L0\t\t\t0x11\n\n#define PISMU_CKON_PCIE\t\t\t0x0038\n#define  PISMU_CKON_PCIE_AUX_CLK\tBIT(1)\n#define  PISMU_CKON_PCIE_MSTR_ACLK\tBIT(0)\n\n#define PISMU_RSOFF_PCIE\t\t0x0538\n#define  PISMU_RSOFF_PCIE_ULREG_RST_N\tBIT(1)\n#define  PISMU_RSOFF_PCIE_PWR_UP_RST_N\tBIT(0)\n\n#define PCIE_MPU_REG_MP_EN\t\t0x0\n#define  MPU_MP_EN_DISABLE\t\tBIT(0)\n\n \nstatic void visconti_ulreg_writel(struct visconti_pcie *pcie, u32 val, u32 reg)\n{\n\twritel_relaxed(val, pcie->ulreg_base + reg);\n}\n\nstatic u32 visconti_ulreg_readl(struct visconti_pcie *pcie, u32 reg)\n{\n\treturn readl_relaxed(pcie->ulreg_base + reg);\n}\n\n \nstatic void visconti_smu_writel(struct visconti_pcie *pcie, u32 val, u32 reg)\n{\n\twritel_relaxed(val, pcie->smu_base + reg);\n}\n\n \nstatic void visconti_mpu_writel(struct visconti_pcie *pcie, u32 val, u32 reg)\n{\n\twritel_relaxed(val, pcie->mpu_base + reg);\n}\n\nstatic u32 visconti_mpu_readl(struct visconti_pcie *pcie, u32 reg)\n{\n\treturn readl_relaxed(pcie->mpu_base + reg);\n}\n\nstatic int visconti_pcie_link_up(struct dw_pcie *pci)\n{\n\tstruct visconti_pcie *pcie = dev_get_drvdata(pci->dev);\n\tvoid __iomem *addr = pcie->ulreg_base;\n\tu32 val = readl_relaxed(addr + PCIE_UL_REG_V_PHY_ST_02);\n\n\treturn !!(val & PCIE_UL_S_L0);\n}\n\nstatic int visconti_pcie_start_link(struct dw_pcie *pci)\n{\n\tstruct visconti_pcie *pcie = dev_get_drvdata(pci->dev);\n\tvoid __iomem *addr = pcie->ulreg_base;\n\tu32 val;\n\tint ret;\n\n\tvisconti_ulreg_writel(pcie, PCIE_UL_APP_LTSSM_ENABLE,\n\t\t\t      PCIE_UL_REG_V_SII_GEN_CTRL_01);\n\n\tret = readl_relaxed_poll_timeout(addr + PCIE_UL_REG_V_PHY_ST_02,\n\t\t\t\t\t val, (val & PCIE_UL_S_L0),\n\t\t\t\t\t 90000, 100000);\n\tif (ret)\n\t\treturn ret;\n\n\tvisconti_ulreg_writel(pcie, PCIE_UL_S_INT_EVENT_MASK1_ALL,\n\t\t\t      PCIE_UL_REG_S_INT_EVENT_MASK1);\n\n\tif (dw_pcie_link_up(pci)) {\n\t\tval = visconti_mpu_readl(pcie, PCIE_MPU_REG_MP_EN);\n\t\tvisconti_mpu_writel(pcie, val & ~MPU_MP_EN_DISABLE,\n\t\t\t\t    PCIE_MPU_REG_MP_EN);\n\t}\n\n\treturn 0;\n}\n\nstatic void visconti_pcie_stop_link(struct dw_pcie *pci)\n{\n\tstruct visconti_pcie *pcie = dev_get_drvdata(pci->dev);\n\tu32 val;\n\n\tval = visconti_ulreg_readl(pcie, PCIE_UL_REG_V_SII_GEN_CTRL_01);\n\tval &= ~PCIE_UL_APP_LTSSM_ENABLE;\n\tvisconti_ulreg_writel(pcie, val, PCIE_UL_REG_V_SII_GEN_CTRL_01);\n\n\tval = visconti_mpu_readl(pcie, PCIE_MPU_REG_MP_EN);\n\tvisconti_mpu_writel(pcie, val | MPU_MP_EN_DISABLE, PCIE_MPU_REG_MP_EN);\n}\n\n \nstatic u64 visconti_pcie_cpu_addr_fixup(struct dw_pcie *pci, u64 cpu_addr)\n{\n\tstruct dw_pcie_rp *pp = &pci->pp;\n\n\treturn cpu_addr & ~pp->io_base;\n}\n\nstatic const struct dw_pcie_ops dw_pcie_ops = {\n\t.cpu_addr_fixup = visconti_pcie_cpu_addr_fixup,\n\t.link_up = visconti_pcie_link_up,\n\t.start_link = visconti_pcie_start_link,\n\t.stop_link = visconti_pcie_stop_link,\n};\n\nstatic int visconti_pcie_host_init(struct dw_pcie_rp *pp)\n{\n\tstruct dw_pcie *pci = to_dw_pcie_from_pp(pp);\n\tstruct visconti_pcie *pcie = dev_get_drvdata(pci->dev);\n\tvoid __iomem *addr;\n\tint err;\n\tu32 val;\n\n\tvisconti_smu_writel(pcie,\n\t\t\t    PISMU_CKON_PCIE_AUX_CLK | PISMU_CKON_PCIE_MSTR_ACLK,\n\t\t\t    PISMU_CKON_PCIE);\n\tndelay(250);\n\n\tvisconti_smu_writel(pcie, PISMU_RSOFF_PCIE_ULREG_RST_N,\n\t\t\t    PISMU_RSOFF_PCIE);\n\tvisconti_ulreg_writel(pcie, PCIE_UL_REG_S_PCIE_MODE_RC,\n\t\t\t      PCIE_UL_REG_S_PCIE_MODE);\n\n\tval = PCIE_UL_REG_S_PERSTN_CTRL_INIT;\n\tvisconti_ulreg_writel(pcie, val, PCIE_UL_REG_S_PERSTN_CTRL);\n\tudelay(100);\n\n\tval |= PCIE_UL_PERSTN_OUT;\n\tvisconti_ulreg_writel(pcie, val, PCIE_UL_REG_S_PERSTN_CTRL);\n\tudelay(100);\n\n\tvisconti_smu_writel(pcie, PISMU_RSOFF_PCIE_PWR_UP_RST_N,\n\t\t\t    PISMU_RSOFF_PCIE);\n\n\taddr = pcie->ulreg_base + PCIE_UL_REG_S_PHY_INIT_03;\n\terr = readl_relaxed_poll_timeout(addr, val,\n\t\t\t\t\t (val & PCIE_UL_PHY0_SRAM_INIT_DONE),\n\t\t\t\t\t 100, 1000);\n\tif (err)\n\t\treturn err;\n\n\tvisconti_ulreg_writel(pcie, PCIE_UL_PHY0_SRAM_EXT_LD_DONE,\n\t\t\t      PCIE_UL_REG_S_PHY_INIT_02);\n\n\taddr = pcie->ulreg_base + PCIE_UL_REG_S_SIG_MON;\n\treturn readl_relaxed_poll_timeout(addr, val,\n\t\t\t\t\t  (val & PCIE_UL_CORE_RST_N_MON), 100,\n\t\t\t\t\t  1000);\n}\n\nstatic const struct dw_pcie_host_ops visconti_pcie_host_ops = {\n\t.host_init = visconti_pcie_host_init,\n};\n\nstatic int visconti_get_resources(struct platform_device *pdev,\n\t\t\t\t  struct visconti_pcie *pcie)\n{\n\tstruct device *dev = &pdev->dev;\n\n\tpcie->ulreg_base = devm_platform_ioremap_resource_byname(pdev, \"ulreg\");\n\tif (IS_ERR(pcie->ulreg_base))\n\t\treturn PTR_ERR(pcie->ulreg_base);\n\n\tpcie->smu_base = devm_platform_ioremap_resource_byname(pdev, \"smu\");\n\tif (IS_ERR(pcie->smu_base))\n\t\treturn PTR_ERR(pcie->smu_base);\n\n\tpcie->mpu_base = devm_platform_ioremap_resource_byname(pdev, \"mpu\");\n\tif (IS_ERR(pcie->mpu_base))\n\t\treturn PTR_ERR(pcie->mpu_base);\n\n\tpcie->refclk = devm_clk_get(dev, \"ref\");\n\tif (IS_ERR(pcie->refclk))\n\t\treturn dev_err_probe(dev, PTR_ERR(pcie->refclk),\n\t\t\t\t     \"Failed to get ref clock\\n\");\n\n\tpcie->coreclk = devm_clk_get(dev, \"core\");\n\tif (IS_ERR(pcie->coreclk))\n\t\treturn dev_err_probe(dev, PTR_ERR(pcie->coreclk),\n\t\t\t\t     \"Failed to get core clock\\n\");\n\n\tpcie->auxclk = devm_clk_get(dev, \"aux\");\n\tif (IS_ERR(pcie->auxclk))\n\t\treturn dev_err_probe(dev, PTR_ERR(pcie->auxclk),\n\t\t\t\t     \"Failed to get aux clock\\n\");\n\n\treturn 0;\n}\n\nstatic int visconti_add_pcie_port(struct visconti_pcie *pcie,\n\t\t\t\t  struct platform_device *pdev)\n{\n\tstruct dw_pcie *pci = &pcie->pci;\n\tstruct dw_pcie_rp *pp = &pci->pp;\n\n\tpp->irq = platform_get_irq_byname(pdev, \"intr\");\n\tif (pp->irq < 0)\n\t\treturn pp->irq;\n\n\tpp->ops = &visconti_pcie_host_ops;\n\n\treturn dw_pcie_host_init(pp);\n}\n\nstatic int visconti_pcie_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct visconti_pcie *pcie;\n\tstruct dw_pcie *pci;\n\tint ret;\n\n\tpcie = devm_kzalloc(dev, sizeof(*pcie), GFP_KERNEL);\n\tif (!pcie)\n\t\treturn -ENOMEM;\n\n\tpci = &pcie->pci;\n\tpci->dev = dev;\n\tpci->ops = &dw_pcie_ops;\n\n\tret = visconti_get_resources(pdev, pcie);\n\tif (ret)\n\t\treturn ret;\n\n\tplatform_set_drvdata(pdev, pcie);\n\n\treturn visconti_add_pcie_port(pcie, pdev);\n}\n\nstatic const struct of_device_id visconti_pcie_match[] = {\n\t{ .compatible = \"toshiba,visconti-pcie\" },\n\t{},\n};\n\nstatic struct platform_driver visconti_pcie_driver = {\n\t.probe = visconti_pcie_probe,\n\t.driver = {\n\t\t.name = \"visconti-pcie\",\n\t\t.of_match_table = visconti_pcie_match,\n\t\t.suppress_bind_attrs = true,\n\t},\n};\nbuiltin_platform_driver(visconti_pcie_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}