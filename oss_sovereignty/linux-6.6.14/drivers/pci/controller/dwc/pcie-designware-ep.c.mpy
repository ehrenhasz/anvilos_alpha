{
  "module_name": "pcie-designware-ep.c",
  "hash_id": "4d83c72ec98e98f8a245e9de3f4aa60332b573ec1c90fabb172d4d86b5d459fe",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/controller/dwc/pcie-designware-ep.c",
  "human_readable_source": "\n \n\n#include <linux/of.h>\n#include <linux/platform_device.h>\n\n#include \"pcie-designware.h\"\n#include <linux/pci-epc.h>\n#include <linux/pci-epf.h>\n\nvoid dw_pcie_ep_linkup(struct dw_pcie_ep *ep)\n{\n\tstruct pci_epc *epc = ep->epc;\n\n\tpci_epc_linkup(epc);\n}\nEXPORT_SYMBOL_GPL(dw_pcie_ep_linkup);\n\nvoid dw_pcie_ep_init_notify(struct dw_pcie_ep *ep)\n{\n\tstruct pci_epc *epc = ep->epc;\n\n\tpci_epc_init_notify(epc);\n}\nEXPORT_SYMBOL_GPL(dw_pcie_ep_init_notify);\n\nstruct dw_pcie_ep_func *\ndw_pcie_ep_get_func_from_ep(struct dw_pcie_ep *ep, u8 func_no)\n{\n\tstruct dw_pcie_ep_func *ep_func;\n\n\tlist_for_each_entry(ep_func, &ep->func_list, list) {\n\t\tif (ep_func->func_no == func_no)\n\t\t\treturn ep_func;\n\t}\n\n\treturn NULL;\n}\n\nstatic unsigned int dw_pcie_ep_func_select(struct dw_pcie_ep *ep, u8 func_no)\n{\n\tunsigned int func_offset = 0;\n\n\tif (ep->ops->func_conf_select)\n\t\tfunc_offset = ep->ops->func_conf_select(ep, func_no);\n\n\treturn func_offset;\n}\n\nstatic void __dw_pcie_ep_reset_bar(struct dw_pcie *pci, u8 func_no,\n\t\t\t\t   enum pci_barno bar, int flags)\n{\n\tu32 reg;\n\tunsigned int func_offset = 0;\n\tstruct dw_pcie_ep *ep = &pci->ep;\n\n\tfunc_offset = dw_pcie_ep_func_select(ep, func_no);\n\n\treg = func_offset + PCI_BASE_ADDRESS_0 + (4 * bar);\n\tdw_pcie_dbi_ro_wr_en(pci);\n\tdw_pcie_writel_dbi2(pci, reg, 0x0);\n\tdw_pcie_writel_dbi(pci, reg, 0x0);\n\tif (flags & PCI_BASE_ADDRESS_MEM_TYPE_64) {\n\t\tdw_pcie_writel_dbi2(pci, reg + 4, 0x0);\n\t\tdw_pcie_writel_dbi(pci, reg + 4, 0x0);\n\t}\n\tdw_pcie_dbi_ro_wr_dis(pci);\n}\n\nvoid dw_pcie_ep_reset_bar(struct dw_pcie *pci, enum pci_barno bar)\n{\n\tu8 func_no, funcs;\n\n\tfuncs = pci->ep.epc->max_functions;\n\n\tfor (func_no = 0; func_no < funcs; func_no++)\n\t\t__dw_pcie_ep_reset_bar(pci, func_no, bar, 0);\n}\nEXPORT_SYMBOL_GPL(dw_pcie_ep_reset_bar);\n\nstatic u8 __dw_pcie_ep_find_next_cap(struct dw_pcie_ep *ep, u8 func_no,\n\t\tu8 cap_ptr, u8 cap)\n{\n\tstruct dw_pcie *pci = to_dw_pcie_from_ep(ep);\n\tunsigned int func_offset = 0;\n\tu8 cap_id, next_cap_ptr;\n\tu16 reg;\n\n\tif (!cap_ptr)\n\t\treturn 0;\n\n\tfunc_offset = dw_pcie_ep_func_select(ep, func_no);\n\n\treg = dw_pcie_readw_dbi(pci, func_offset + cap_ptr);\n\tcap_id = (reg & 0x00ff);\n\n\tif (cap_id > PCI_CAP_ID_MAX)\n\t\treturn 0;\n\n\tif (cap_id == cap)\n\t\treturn cap_ptr;\n\n\tnext_cap_ptr = (reg & 0xff00) >> 8;\n\treturn __dw_pcie_ep_find_next_cap(ep, func_no, next_cap_ptr, cap);\n}\n\nstatic u8 dw_pcie_ep_find_capability(struct dw_pcie_ep *ep, u8 func_no, u8 cap)\n{\n\tstruct dw_pcie *pci = to_dw_pcie_from_ep(ep);\n\tunsigned int func_offset = 0;\n\tu8 next_cap_ptr;\n\tu16 reg;\n\n\tfunc_offset = dw_pcie_ep_func_select(ep, func_no);\n\n\treg = dw_pcie_readw_dbi(pci, func_offset + PCI_CAPABILITY_LIST);\n\tnext_cap_ptr = (reg & 0x00ff);\n\n\treturn __dw_pcie_ep_find_next_cap(ep, func_no, next_cap_ptr, cap);\n}\n\nstatic int dw_pcie_ep_write_header(struct pci_epc *epc, u8 func_no, u8 vfunc_no,\n\t\t\t\t   struct pci_epf_header *hdr)\n{\n\tstruct dw_pcie_ep *ep = epc_get_drvdata(epc);\n\tstruct dw_pcie *pci = to_dw_pcie_from_ep(ep);\n\tunsigned int func_offset = 0;\n\n\tfunc_offset = dw_pcie_ep_func_select(ep, func_no);\n\n\tdw_pcie_dbi_ro_wr_en(pci);\n\tdw_pcie_writew_dbi(pci, func_offset + PCI_VENDOR_ID, hdr->vendorid);\n\tdw_pcie_writew_dbi(pci, func_offset + PCI_DEVICE_ID, hdr->deviceid);\n\tdw_pcie_writeb_dbi(pci, func_offset + PCI_REVISION_ID, hdr->revid);\n\tdw_pcie_writeb_dbi(pci, func_offset + PCI_CLASS_PROG, hdr->progif_code);\n\tdw_pcie_writew_dbi(pci, func_offset + PCI_CLASS_DEVICE,\n\t\t\t   hdr->subclass_code | hdr->baseclass_code << 8);\n\tdw_pcie_writeb_dbi(pci, func_offset + PCI_CACHE_LINE_SIZE,\n\t\t\t   hdr->cache_line_size);\n\tdw_pcie_writew_dbi(pci, func_offset + PCI_SUBSYSTEM_VENDOR_ID,\n\t\t\t   hdr->subsys_vendor_id);\n\tdw_pcie_writew_dbi(pci, func_offset + PCI_SUBSYSTEM_ID, hdr->subsys_id);\n\tdw_pcie_writeb_dbi(pci, func_offset + PCI_INTERRUPT_PIN,\n\t\t\t   hdr->interrupt_pin);\n\tdw_pcie_dbi_ro_wr_dis(pci);\n\n\treturn 0;\n}\n\nstatic int dw_pcie_ep_inbound_atu(struct dw_pcie_ep *ep, u8 func_no, int type,\n\t\t\t\t  dma_addr_t cpu_addr, enum pci_barno bar)\n{\n\tint ret;\n\tu32 free_win;\n\tstruct dw_pcie *pci = to_dw_pcie_from_ep(ep);\n\n\tif (!ep->bar_to_atu[bar])\n\t\tfree_win = find_first_zero_bit(ep->ib_window_map, pci->num_ib_windows);\n\telse\n\t\tfree_win = ep->bar_to_atu[bar];\n\n\tif (free_win >= pci->num_ib_windows) {\n\t\tdev_err(pci->dev, \"No free inbound window\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = dw_pcie_prog_ep_inbound_atu(pci, func_no, free_win, type,\n\t\t\t\t\t  cpu_addr, bar);\n\tif (ret < 0) {\n\t\tdev_err(pci->dev, \"Failed to program IB window\\n\");\n\t\treturn ret;\n\t}\n\n\tep->bar_to_atu[bar] = free_win;\n\tset_bit(free_win, ep->ib_window_map);\n\n\treturn 0;\n}\n\nstatic int dw_pcie_ep_outbound_atu(struct dw_pcie_ep *ep, u8 func_no,\n\t\t\t\t   phys_addr_t phys_addr,\n\t\t\t\t   u64 pci_addr, size_t size)\n{\n\tstruct dw_pcie *pci = to_dw_pcie_from_ep(ep);\n\tu32 free_win;\n\tint ret;\n\n\tfree_win = find_first_zero_bit(ep->ob_window_map, pci->num_ob_windows);\n\tif (free_win >= pci->num_ob_windows) {\n\t\tdev_err(pci->dev, \"No free outbound window\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = dw_pcie_prog_ep_outbound_atu(pci, func_no, free_win, PCIE_ATU_TYPE_MEM,\n\t\t\t\t\t   phys_addr, pci_addr, size);\n\tif (ret)\n\t\treturn ret;\n\n\tset_bit(free_win, ep->ob_window_map);\n\tep->outbound_addr[free_win] = phys_addr;\n\n\treturn 0;\n}\n\nstatic void dw_pcie_ep_clear_bar(struct pci_epc *epc, u8 func_no, u8 vfunc_no,\n\t\t\t\t struct pci_epf_bar *epf_bar)\n{\n\tstruct dw_pcie_ep *ep = epc_get_drvdata(epc);\n\tstruct dw_pcie *pci = to_dw_pcie_from_ep(ep);\n\tenum pci_barno bar = epf_bar->barno;\n\tu32 atu_index = ep->bar_to_atu[bar];\n\n\t__dw_pcie_ep_reset_bar(pci, func_no, bar, epf_bar->flags);\n\n\tdw_pcie_disable_atu(pci, PCIE_ATU_REGION_DIR_IB, atu_index);\n\tclear_bit(atu_index, ep->ib_window_map);\n\tep->epf_bar[bar] = NULL;\n\tep->bar_to_atu[bar] = 0;\n}\n\nstatic int dw_pcie_ep_set_bar(struct pci_epc *epc, u8 func_no, u8 vfunc_no,\n\t\t\t      struct pci_epf_bar *epf_bar)\n{\n\tstruct dw_pcie_ep *ep = epc_get_drvdata(epc);\n\tstruct dw_pcie *pci = to_dw_pcie_from_ep(ep);\n\tenum pci_barno bar = epf_bar->barno;\n\tsize_t size = epf_bar->size;\n\tint flags = epf_bar->flags;\n\tunsigned int func_offset = 0;\n\tint ret, type;\n\tu32 reg;\n\n\tfunc_offset = dw_pcie_ep_func_select(ep, func_no);\n\n\treg = PCI_BASE_ADDRESS_0 + (4 * bar) + func_offset;\n\n\tif (!(flags & PCI_BASE_ADDRESS_SPACE))\n\t\ttype = PCIE_ATU_TYPE_MEM;\n\telse\n\t\ttype = PCIE_ATU_TYPE_IO;\n\n\tret = dw_pcie_ep_inbound_atu(ep, func_no, type, epf_bar->phys_addr, bar);\n\tif (ret)\n\t\treturn ret;\n\n\tif (ep->epf_bar[bar])\n\t\treturn 0;\n\n\tdw_pcie_dbi_ro_wr_en(pci);\n\n\tdw_pcie_writel_dbi2(pci, reg, lower_32_bits(size - 1));\n\tdw_pcie_writel_dbi(pci, reg, flags);\n\n\tif (flags & PCI_BASE_ADDRESS_MEM_TYPE_64) {\n\t\tdw_pcie_writel_dbi2(pci, reg + 4, upper_32_bits(size - 1));\n\t\tdw_pcie_writel_dbi(pci, reg + 4, 0);\n\t}\n\n\tep->epf_bar[bar] = epf_bar;\n\tdw_pcie_dbi_ro_wr_dis(pci);\n\n\treturn 0;\n}\n\nstatic int dw_pcie_find_index(struct dw_pcie_ep *ep, phys_addr_t addr,\n\t\t\t      u32 *atu_index)\n{\n\tu32 index;\n\tstruct dw_pcie *pci = to_dw_pcie_from_ep(ep);\n\n\tfor (index = 0; index < pci->num_ob_windows; index++) {\n\t\tif (ep->outbound_addr[index] != addr)\n\t\t\tcontinue;\n\t\t*atu_index = index;\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic void dw_pcie_ep_unmap_addr(struct pci_epc *epc, u8 func_no, u8 vfunc_no,\n\t\t\t\t  phys_addr_t addr)\n{\n\tint ret;\n\tu32 atu_index;\n\tstruct dw_pcie_ep *ep = epc_get_drvdata(epc);\n\tstruct dw_pcie *pci = to_dw_pcie_from_ep(ep);\n\n\tret = dw_pcie_find_index(ep, addr, &atu_index);\n\tif (ret < 0)\n\t\treturn;\n\n\tdw_pcie_disable_atu(pci, PCIE_ATU_REGION_DIR_OB, atu_index);\n\tclear_bit(atu_index, ep->ob_window_map);\n}\n\nstatic int dw_pcie_ep_map_addr(struct pci_epc *epc, u8 func_no, u8 vfunc_no,\n\t\t\t       phys_addr_t addr, u64 pci_addr, size_t size)\n{\n\tint ret;\n\tstruct dw_pcie_ep *ep = epc_get_drvdata(epc);\n\tstruct dw_pcie *pci = to_dw_pcie_from_ep(ep);\n\n\tret = dw_pcie_ep_outbound_atu(ep, func_no, addr, pci_addr, size);\n\tif (ret) {\n\t\tdev_err(pci->dev, \"Failed to enable address\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int dw_pcie_ep_get_msi(struct pci_epc *epc, u8 func_no, u8 vfunc_no)\n{\n\tstruct dw_pcie_ep *ep = epc_get_drvdata(epc);\n\tstruct dw_pcie *pci = to_dw_pcie_from_ep(ep);\n\tu32 val, reg;\n\tunsigned int func_offset = 0;\n\tstruct dw_pcie_ep_func *ep_func;\n\n\tep_func = dw_pcie_ep_get_func_from_ep(ep, func_no);\n\tif (!ep_func || !ep_func->msi_cap)\n\t\treturn -EINVAL;\n\n\tfunc_offset = dw_pcie_ep_func_select(ep, func_no);\n\n\treg = ep_func->msi_cap + func_offset + PCI_MSI_FLAGS;\n\tval = dw_pcie_readw_dbi(pci, reg);\n\tif (!(val & PCI_MSI_FLAGS_ENABLE))\n\t\treturn -EINVAL;\n\n\tval = (val & PCI_MSI_FLAGS_QSIZE) >> 4;\n\n\treturn val;\n}\n\nstatic int dw_pcie_ep_set_msi(struct pci_epc *epc, u8 func_no, u8 vfunc_no,\n\t\t\t      u8 interrupts)\n{\n\tstruct dw_pcie_ep *ep = epc_get_drvdata(epc);\n\tstruct dw_pcie *pci = to_dw_pcie_from_ep(ep);\n\tu32 val, reg;\n\tunsigned int func_offset = 0;\n\tstruct dw_pcie_ep_func *ep_func;\n\n\tep_func = dw_pcie_ep_get_func_from_ep(ep, func_no);\n\tif (!ep_func || !ep_func->msi_cap)\n\t\treturn -EINVAL;\n\n\tfunc_offset = dw_pcie_ep_func_select(ep, func_no);\n\n\treg = ep_func->msi_cap + func_offset + PCI_MSI_FLAGS;\n\tval = dw_pcie_readw_dbi(pci, reg);\n\tval &= ~PCI_MSI_FLAGS_QMASK;\n\tval |= (interrupts << 1) & PCI_MSI_FLAGS_QMASK;\n\tdw_pcie_dbi_ro_wr_en(pci);\n\tdw_pcie_writew_dbi(pci, reg, val);\n\tdw_pcie_dbi_ro_wr_dis(pci);\n\n\treturn 0;\n}\n\nstatic int dw_pcie_ep_get_msix(struct pci_epc *epc, u8 func_no, u8 vfunc_no)\n{\n\tstruct dw_pcie_ep *ep = epc_get_drvdata(epc);\n\tstruct dw_pcie *pci = to_dw_pcie_from_ep(ep);\n\tu32 val, reg;\n\tunsigned int func_offset = 0;\n\tstruct dw_pcie_ep_func *ep_func;\n\n\tep_func = dw_pcie_ep_get_func_from_ep(ep, func_no);\n\tif (!ep_func || !ep_func->msix_cap)\n\t\treturn -EINVAL;\n\n\tfunc_offset = dw_pcie_ep_func_select(ep, func_no);\n\n\treg = ep_func->msix_cap + func_offset + PCI_MSIX_FLAGS;\n\tval = dw_pcie_readw_dbi(pci, reg);\n\tif (!(val & PCI_MSIX_FLAGS_ENABLE))\n\t\treturn -EINVAL;\n\n\tval &= PCI_MSIX_FLAGS_QSIZE;\n\n\treturn val;\n}\n\nstatic int dw_pcie_ep_set_msix(struct pci_epc *epc, u8 func_no, u8 vfunc_no,\n\t\t\t       u16 interrupts, enum pci_barno bir, u32 offset)\n{\n\tstruct dw_pcie_ep *ep = epc_get_drvdata(epc);\n\tstruct dw_pcie *pci = to_dw_pcie_from_ep(ep);\n\tu32 val, reg;\n\tunsigned int func_offset = 0;\n\tstruct dw_pcie_ep_func *ep_func;\n\n\tep_func = dw_pcie_ep_get_func_from_ep(ep, func_no);\n\tif (!ep_func || !ep_func->msix_cap)\n\t\treturn -EINVAL;\n\n\tdw_pcie_dbi_ro_wr_en(pci);\n\n\tfunc_offset = dw_pcie_ep_func_select(ep, func_no);\n\n\treg = ep_func->msix_cap + func_offset + PCI_MSIX_FLAGS;\n\tval = dw_pcie_readw_dbi(pci, reg);\n\tval &= ~PCI_MSIX_FLAGS_QSIZE;\n\tval |= interrupts;\n\tdw_pcie_writew_dbi(pci, reg, val);\n\n\treg = ep_func->msix_cap + func_offset + PCI_MSIX_TABLE;\n\tval = offset | bir;\n\tdw_pcie_writel_dbi(pci, reg, val);\n\n\treg = ep_func->msix_cap + func_offset + PCI_MSIX_PBA;\n\tval = (offset + (interrupts * PCI_MSIX_ENTRY_SIZE)) | bir;\n\tdw_pcie_writel_dbi(pci, reg, val);\n\n\tdw_pcie_dbi_ro_wr_dis(pci);\n\n\treturn 0;\n}\n\nstatic int dw_pcie_ep_raise_irq(struct pci_epc *epc, u8 func_no, u8 vfunc_no,\n\t\t\t\tenum pci_epc_irq_type type, u16 interrupt_num)\n{\n\tstruct dw_pcie_ep *ep = epc_get_drvdata(epc);\n\n\tif (!ep->ops->raise_irq)\n\t\treturn -EINVAL;\n\n\treturn ep->ops->raise_irq(ep, func_no, type, interrupt_num);\n}\n\nstatic void dw_pcie_ep_stop(struct pci_epc *epc)\n{\n\tstruct dw_pcie_ep *ep = epc_get_drvdata(epc);\n\tstruct dw_pcie *pci = to_dw_pcie_from_ep(ep);\n\n\tdw_pcie_stop_link(pci);\n}\n\nstatic int dw_pcie_ep_start(struct pci_epc *epc)\n{\n\tstruct dw_pcie_ep *ep = epc_get_drvdata(epc);\n\tstruct dw_pcie *pci = to_dw_pcie_from_ep(ep);\n\n\treturn dw_pcie_start_link(pci);\n}\n\nstatic const struct pci_epc_features*\ndw_pcie_ep_get_features(struct pci_epc *epc, u8 func_no, u8 vfunc_no)\n{\n\tstruct dw_pcie_ep *ep = epc_get_drvdata(epc);\n\n\tif (!ep->ops->get_features)\n\t\treturn NULL;\n\n\treturn ep->ops->get_features(ep);\n}\n\nstatic const struct pci_epc_ops epc_ops = {\n\t.write_header\t\t= dw_pcie_ep_write_header,\n\t.set_bar\t\t= dw_pcie_ep_set_bar,\n\t.clear_bar\t\t= dw_pcie_ep_clear_bar,\n\t.map_addr\t\t= dw_pcie_ep_map_addr,\n\t.unmap_addr\t\t= dw_pcie_ep_unmap_addr,\n\t.set_msi\t\t= dw_pcie_ep_set_msi,\n\t.get_msi\t\t= dw_pcie_ep_get_msi,\n\t.set_msix\t\t= dw_pcie_ep_set_msix,\n\t.get_msix\t\t= dw_pcie_ep_get_msix,\n\t.raise_irq\t\t= dw_pcie_ep_raise_irq,\n\t.start\t\t\t= dw_pcie_ep_start,\n\t.stop\t\t\t= dw_pcie_ep_stop,\n\t.get_features\t\t= dw_pcie_ep_get_features,\n};\n\nint dw_pcie_ep_raise_legacy_irq(struct dw_pcie_ep *ep, u8 func_no)\n{\n\tstruct dw_pcie *pci = to_dw_pcie_from_ep(ep);\n\tstruct device *dev = pci->dev;\n\n\tdev_err(dev, \"EP cannot trigger legacy IRQs\\n\");\n\n\treturn -EINVAL;\n}\nEXPORT_SYMBOL_GPL(dw_pcie_ep_raise_legacy_irq);\n\nint dw_pcie_ep_raise_msi_irq(struct dw_pcie_ep *ep, u8 func_no,\n\t\t\t     u8 interrupt_num)\n{\n\tstruct dw_pcie *pci = to_dw_pcie_from_ep(ep);\n\tstruct dw_pcie_ep_func *ep_func;\n\tstruct pci_epc *epc = ep->epc;\n\tunsigned int aligned_offset;\n\tunsigned int func_offset = 0;\n\tu16 msg_ctrl, msg_data;\n\tu32 msg_addr_lower, msg_addr_upper, reg;\n\tu64 msg_addr;\n\tbool has_upper;\n\tint ret;\n\n\tep_func = dw_pcie_ep_get_func_from_ep(ep, func_no);\n\tif (!ep_func || !ep_func->msi_cap)\n\t\treturn -EINVAL;\n\n\tfunc_offset = dw_pcie_ep_func_select(ep, func_no);\n\n\t \n\treg = ep_func->msi_cap + func_offset + PCI_MSI_FLAGS;\n\tmsg_ctrl = dw_pcie_readw_dbi(pci, reg);\n\thas_upper = !!(msg_ctrl & PCI_MSI_FLAGS_64BIT);\n\treg = ep_func->msi_cap + func_offset + PCI_MSI_ADDRESS_LO;\n\tmsg_addr_lower = dw_pcie_readl_dbi(pci, reg);\n\tif (has_upper) {\n\t\treg = ep_func->msi_cap + func_offset + PCI_MSI_ADDRESS_HI;\n\t\tmsg_addr_upper = dw_pcie_readl_dbi(pci, reg);\n\t\treg = ep_func->msi_cap + func_offset + PCI_MSI_DATA_64;\n\t\tmsg_data = dw_pcie_readw_dbi(pci, reg);\n\t} else {\n\t\tmsg_addr_upper = 0;\n\t\treg = ep_func->msi_cap + func_offset + PCI_MSI_DATA_32;\n\t\tmsg_data = dw_pcie_readw_dbi(pci, reg);\n\t}\n\taligned_offset = msg_addr_lower & (epc->mem->window.page_size - 1);\n\tmsg_addr = ((u64)msg_addr_upper) << 32 |\n\t\t\t(msg_addr_lower & ~aligned_offset);\n\tret = dw_pcie_ep_map_addr(epc, func_no, 0, ep->msi_mem_phys, msg_addr,\n\t\t\t\t  epc->mem->window.page_size);\n\tif (ret)\n\t\treturn ret;\n\n\twritel(msg_data | (interrupt_num - 1), ep->msi_mem + aligned_offset);\n\n\tdw_pcie_ep_unmap_addr(epc, func_no, 0, ep->msi_mem_phys);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(dw_pcie_ep_raise_msi_irq);\n\nint dw_pcie_ep_raise_msix_irq_doorbell(struct dw_pcie_ep *ep, u8 func_no,\n\t\t\t\t       u16 interrupt_num)\n{\n\tstruct dw_pcie *pci = to_dw_pcie_from_ep(ep);\n\tstruct dw_pcie_ep_func *ep_func;\n\tu32 msg_data;\n\n\tep_func = dw_pcie_ep_get_func_from_ep(ep, func_no);\n\tif (!ep_func || !ep_func->msix_cap)\n\t\treturn -EINVAL;\n\n\tmsg_data = (func_no << PCIE_MSIX_DOORBELL_PF_SHIFT) |\n\t\t   (interrupt_num - 1);\n\n\tdw_pcie_writel_dbi(pci, PCIE_MSIX_DOORBELL, msg_data);\n\n\treturn 0;\n}\n\nint dw_pcie_ep_raise_msix_irq(struct dw_pcie_ep *ep, u8 func_no,\n\t\t\t      u16 interrupt_num)\n{\n\tstruct dw_pcie *pci = to_dw_pcie_from_ep(ep);\n\tstruct dw_pcie_ep_func *ep_func;\n\tstruct pci_epf_msix_tbl *msix_tbl;\n\tstruct pci_epc *epc = ep->epc;\n\tunsigned int func_offset = 0;\n\tu32 reg, msg_data, vec_ctrl;\n\tunsigned int aligned_offset;\n\tu32 tbl_offset;\n\tu64 msg_addr;\n\tint ret;\n\tu8 bir;\n\n\tep_func = dw_pcie_ep_get_func_from_ep(ep, func_no);\n\tif (!ep_func || !ep_func->msix_cap)\n\t\treturn -EINVAL;\n\n\tfunc_offset = dw_pcie_ep_func_select(ep, func_no);\n\n\treg = ep_func->msix_cap + func_offset + PCI_MSIX_TABLE;\n\ttbl_offset = dw_pcie_readl_dbi(pci, reg);\n\tbir = (tbl_offset & PCI_MSIX_TABLE_BIR);\n\ttbl_offset &= PCI_MSIX_TABLE_OFFSET;\n\n\tmsix_tbl = ep->epf_bar[bir]->addr + tbl_offset;\n\tmsg_addr = msix_tbl[(interrupt_num - 1)].msg_addr;\n\tmsg_data = msix_tbl[(interrupt_num - 1)].msg_data;\n\tvec_ctrl = msix_tbl[(interrupt_num - 1)].vector_ctrl;\n\n\tif (vec_ctrl & PCI_MSIX_ENTRY_CTRL_MASKBIT) {\n\t\tdev_dbg(pci->dev, \"MSI-X entry ctrl set\\n\");\n\t\treturn -EPERM;\n\t}\n\n\taligned_offset = msg_addr & (epc->mem->window.page_size - 1);\n\tmsg_addr &= ~aligned_offset;\n\tret = dw_pcie_ep_map_addr(epc, func_no, 0, ep->msi_mem_phys, msg_addr,\n\t\t\t\t  epc->mem->window.page_size);\n\tif (ret)\n\t\treturn ret;\n\n\twritel(msg_data, ep->msi_mem + aligned_offset);\n\n\tdw_pcie_ep_unmap_addr(epc, func_no, 0, ep->msi_mem_phys);\n\n\treturn 0;\n}\n\nvoid dw_pcie_ep_exit(struct dw_pcie_ep *ep)\n{\n\tstruct dw_pcie *pci = to_dw_pcie_from_ep(ep);\n\tstruct pci_epc *epc = ep->epc;\n\n\tdw_pcie_edma_remove(pci);\n\n\tpci_epc_mem_free_addr(epc, ep->msi_mem_phys, ep->msi_mem,\n\t\t\t      epc->mem->window.page_size);\n\n\tpci_epc_mem_exit(epc);\n}\n\nstatic unsigned int dw_pcie_ep_find_ext_capability(struct dw_pcie *pci, int cap)\n{\n\tu32 header;\n\tint pos = PCI_CFG_SPACE_SIZE;\n\n\twhile (pos) {\n\t\theader = dw_pcie_readl_dbi(pci, pos);\n\t\tif (PCI_EXT_CAP_ID(header) == cap)\n\t\t\treturn pos;\n\n\t\tpos = PCI_EXT_CAP_NEXT(header);\n\t\tif (!pos)\n\t\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nint dw_pcie_ep_init_complete(struct dw_pcie_ep *ep)\n{\n\tstruct dw_pcie *pci = to_dw_pcie_from_ep(ep);\n\tunsigned int offset, ptm_cap_base;\n\tunsigned int nbars;\n\tu8 hdr_type;\n\tu32 reg;\n\tint i;\n\n\thdr_type = dw_pcie_readb_dbi(pci, PCI_HEADER_TYPE) &\n\t\t   PCI_HEADER_TYPE_MASK;\n\tif (hdr_type != PCI_HEADER_TYPE_NORMAL) {\n\t\tdev_err(pci->dev,\n\t\t\t\"PCIe controller is not set to EP mode (hdr_type:0x%x)!\\n\",\n\t\t\thdr_type);\n\t\treturn -EIO;\n\t}\n\n\toffset = dw_pcie_ep_find_ext_capability(pci, PCI_EXT_CAP_ID_REBAR);\n\tptm_cap_base = dw_pcie_ep_find_ext_capability(pci, PCI_EXT_CAP_ID_PTM);\n\n\tdw_pcie_dbi_ro_wr_en(pci);\n\n\tif (offset) {\n\t\treg = dw_pcie_readl_dbi(pci, offset + PCI_REBAR_CTRL);\n\t\tnbars = (reg & PCI_REBAR_CTRL_NBAR_MASK) >>\n\t\t\tPCI_REBAR_CTRL_NBAR_SHIFT;\n\n\t\tfor (i = 0; i < nbars; i++, offset += PCI_REBAR_CTRL)\n\t\t\tdw_pcie_writel_dbi(pci, offset + PCI_REBAR_CAP, 0x0);\n\t}\n\n\t \n\tif (ptm_cap_base) {\n\t\tdw_pcie_dbi_ro_wr_en(pci);\n\t\treg = dw_pcie_readl_dbi(pci, ptm_cap_base + PCI_PTM_CAP);\n\t\treg &= ~PCI_PTM_CAP_ROOT;\n\t\tdw_pcie_writel_dbi(pci, ptm_cap_base + PCI_PTM_CAP, reg);\n\n\t\treg = dw_pcie_readl_dbi(pci, ptm_cap_base + PCI_PTM_CAP);\n\t\treg &= ~(PCI_PTM_CAP_RES | PCI_PTM_GRANULARITY_MASK);\n\t\tdw_pcie_writel_dbi(pci, ptm_cap_base + PCI_PTM_CAP, reg);\n\t\tdw_pcie_dbi_ro_wr_dis(pci);\n\t}\n\n\tdw_pcie_setup(pci);\n\tdw_pcie_dbi_ro_wr_dis(pci);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(dw_pcie_ep_init_complete);\n\nint dw_pcie_ep_init(struct dw_pcie_ep *ep)\n{\n\tint ret;\n\tvoid *addr;\n\tu8 func_no;\n\tstruct resource *res;\n\tstruct pci_epc *epc;\n\tstruct dw_pcie *pci = to_dw_pcie_from_ep(ep);\n\tstruct device *dev = pci->dev;\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct device_node *np = dev->of_node;\n\tconst struct pci_epc_features *epc_features;\n\tstruct dw_pcie_ep_func *ep_func;\n\n\tINIT_LIST_HEAD(&ep->func_list);\n\n\tret = dw_pcie_get_resources(pci);\n\tif (ret)\n\t\treturn ret;\n\n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"addr_space\");\n\tif (!res)\n\t\treturn -EINVAL;\n\n\tep->phys_base = res->start;\n\tep->addr_size = resource_size(res);\n\n\tdw_pcie_version_detect(pci);\n\n\tdw_pcie_iatu_detect(pci);\n\n\tep->ib_window_map = devm_bitmap_zalloc(dev, pci->num_ib_windows,\n\t\t\t\t\t       GFP_KERNEL);\n\tif (!ep->ib_window_map)\n\t\treturn -ENOMEM;\n\n\tep->ob_window_map = devm_bitmap_zalloc(dev, pci->num_ob_windows,\n\t\t\t\t\t       GFP_KERNEL);\n\tif (!ep->ob_window_map)\n\t\treturn -ENOMEM;\n\n\taddr = devm_kcalloc(dev, pci->num_ob_windows, sizeof(phys_addr_t),\n\t\t\t    GFP_KERNEL);\n\tif (!addr)\n\t\treturn -ENOMEM;\n\tep->outbound_addr = addr;\n\n\tepc = devm_pci_epc_create(dev, &epc_ops);\n\tif (IS_ERR(epc)) {\n\t\tdev_err(dev, \"Failed to create epc device\\n\");\n\t\treturn PTR_ERR(epc);\n\t}\n\n\tep->epc = epc;\n\tepc_set_drvdata(epc, ep);\n\n\tret = of_property_read_u8(np, \"max-functions\", &epc->max_functions);\n\tif (ret < 0)\n\t\tepc->max_functions = 1;\n\n\tfor (func_no = 0; func_no < epc->max_functions; func_no++) {\n\t\tep_func = devm_kzalloc(dev, sizeof(*ep_func), GFP_KERNEL);\n\t\tif (!ep_func)\n\t\t\treturn -ENOMEM;\n\n\t\tep_func->func_no = func_no;\n\t\tep_func->msi_cap = dw_pcie_ep_find_capability(ep, func_no,\n\t\t\t\t\t\t\t      PCI_CAP_ID_MSI);\n\t\tep_func->msix_cap = dw_pcie_ep_find_capability(ep, func_no,\n\t\t\t\t\t\t\t       PCI_CAP_ID_MSIX);\n\n\t\tlist_add_tail(&ep_func->list, &ep->func_list);\n\t}\n\n\tif (ep->ops->ep_init)\n\t\tep->ops->ep_init(ep);\n\n\tret = pci_epc_mem_init(epc, ep->phys_base, ep->addr_size,\n\t\t\t       ep->page_size);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to initialize address space\\n\");\n\t\treturn ret;\n\t}\n\n\tep->msi_mem = pci_epc_mem_alloc_addr(epc, &ep->msi_mem_phys,\n\t\t\t\t\t     epc->mem->window.page_size);\n\tif (!ep->msi_mem) {\n\t\tret = -ENOMEM;\n\t\tdev_err(dev, \"Failed to reserve memory for MSI/MSI-X\\n\");\n\t\tgoto err_exit_epc_mem;\n\t}\n\n\tret = dw_pcie_edma_detect(pci);\n\tif (ret)\n\t\tgoto err_free_epc_mem;\n\n\tif (ep->ops->get_features) {\n\t\tepc_features = ep->ops->get_features(ep);\n\t\tif (epc_features->core_init_notifier)\n\t\t\treturn 0;\n\t}\n\n\tret = dw_pcie_ep_init_complete(ep);\n\tif (ret)\n\t\tgoto err_remove_edma;\n\n\treturn 0;\n\nerr_remove_edma:\n\tdw_pcie_edma_remove(pci);\n\nerr_free_epc_mem:\n\tpci_epc_mem_free_addr(epc, ep->msi_mem_phys, ep->msi_mem,\n\t\t\t      epc->mem->window.page_size);\n\nerr_exit_epc_mem:\n\tpci_epc_mem_exit(epc);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(dw_pcie_ep_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}