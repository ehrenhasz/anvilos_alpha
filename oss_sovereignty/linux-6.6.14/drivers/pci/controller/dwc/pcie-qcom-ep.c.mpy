{
  "module_name": "pcie-qcom-ep.c",
  "hash_id": "6e5350b8572f7ce59bc4d635bd90318220afcd0fbf5eef87c9c9f33a06853c2a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/controller/dwc/pcie-qcom-ep.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/interconnect.h>\n#include <linux/mfd/syscon.h>\n#include <linux/phy/pcie.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n#include <linux/pm_domain.h>\n#include <linux/regmap.h>\n#include <linux/reset.h>\n#include <linux/module.h>\n\n#include \"pcie-designware.h\"\n\n \n#define PARF_SYS_CTRL\t\t\t\t0x00\n#define PARF_DB_CTRL\t\t\t\t0x10\n#define PARF_PM_CTRL\t\t\t\t0x20\n#define PARF_MHI_CLOCK_RESET_CTRL\t\t0x174\n#define PARF_MHI_BASE_ADDR_LOWER\t\t0x178\n#define PARF_MHI_BASE_ADDR_UPPER\t\t0x17c\n#define PARF_DEBUG_INT_EN\t\t\t0x190\n#define PARF_AXI_MSTR_RD_HALT_NO_WRITES\t\t0x1a4\n#define PARF_AXI_MSTR_WR_ADDR_HALT\t\t0x1a8\n#define PARF_Q2A_FLUSH\t\t\t\t0x1ac\n#define PARF_LTSSM\t\t\t\t0x1b0\n#define PARF_CFG_BITS\t\t\t\t0x210\n#define PARF_INT_ALL_STATUS\t\t\t0x224\n#define PARF_INT_ALL_CLEAR\t\t\t0x228\n#define PARF_INT_ALL_MASK\t\t\t0x22c\n#define PARF_SLV_ADDR_MSB_CTRL\t\t\t0x2c0\n#define PARF_DBI_BASE_ADDR\t\t\t0x350\n#define PARF_DBI_BASE_ADDR_HI\t\t\t0x354\n#define PARF_SLV_ADDR_SPACE_SIZE\t\t0x358\n#define PARF_SLV_ADDR_SPACE_SIZE_HI\t\t0x35c\n#define PARF_ATU_BASE_ADDR\t\t\t0x634\n#define PARF_ATU_BASE_ADDR_HI\t\t\t0x638\n#define PARF_SRIS_MODE\t\t\t\t0x644\n#define PARF_DEBUG_CNT_PM_LINKST_IN_L2\t\t0xc04\n#define PARF_DEBUG_CNT_PM_LINKST_IN_L1\t\t0xc0c\n#define PARF_DEBUG_CNT_PM_LINKST_IN_L0S\t\t0xc10\n#define PARF_DEBUG_CNT_AUX_CLK_IN_L1SUB_L1\t0xc84\n#define PARF_DEBUG_CNT_AUX_CLK_IN_L1SUB_L2\t0xc88\n#define PARF_DEVICE_TYPE\t\t\t0x1000\n#define PARF_BDF_TO_SID_CFG\t\t\t0x2c00\n\n \n#define PARF_INT_ALL_LINK_DOWN\t\t\tBIT(1)\n#define PARF_INT_ALL_BME\t\t\tBIT(2)\n#define PARF_INT_ALL_PM_TURNOFF\t\t\tBIT(3)\n#define PARF_INT_ALL_DEBUG\t\t\tBIT(4)\n#define PARF_INT_ALL_LTR\t\t\tBIT(5)\n#define PARF_INT_ALL_MHI_Q6\t\t\tBIT(6)\n#define PARF_INT_ALL_MHI_A7\t\t\tBIT(7)\n#define PARF_INT_ALL_DSTATE_CHANGE\t\tBIT(8)\n#define PARF_INT_ALL_L1SUB_TIMEOUT\t\tBIT(9)\n#define PARF_INT_ALL_MMIO_WRITE\t\t\tBIT(10)\n#define PARF_INT_ALL_CFG_WRITE\t\t\tBIT(11)\n#define PARF_INT_ALL_BRIDGE_FLUSH_N\t\tBIT(12)\n#define PARF_INT_ALL_LINK_UP\t\t\tBIT(13)\n#define PARF_INT_ALL_AER_LEGACY\t\t\tBIT(14)\n#define PARF_INT_ALL_PLS_ERR\t\t\tBIT(15)\n#define PARF_INT_ALL_PME_LEGACY\t\t\tBIT(16)\n#define PARF_INT_ALL_PLS_PME\t\t\tBIT(17)\n#define PARF_INT_ALL_EDMA\t\t\tBIT(22)\n\n \n#define PARF_BDF_TO_SID_BYPASS\t\t\tBIT(0)\n\n \n#define PARF_DEBUG_INT_PM_DSTATE_CHANGE\t\tBIT(1)\n#define PARF_DEBUG_INT_CFG_BUS_MASTER_EN\tBIT(2)\n#define PARF_DEBUG_INT_RADM_PM_TURNOFF\t\tBIT(3)\n\n \n#define PARF_DEVICE_TYPE_EP\t\t\t0x0\n\n \n#define PARF_PM_CTRL_REQ_EXIT_L1\t\tBIT(1)\n#define PARF_PM_CTRL_READY_ENTR_L23\t\tBIT(2)\n#define PARF_PM_CTRL_REQ_NOT_ENTR_L1\t\tBIT(5)\n\n \n#define PARF_MSTR_AXI_CLK_EN\t\t\tBIT(1)\n\n \n#define PARF_AXI_MSTR_RD_HALT_NO_WRITE_EN\tBIT(0)\n\n \n#define PARF_AXI_MSTR_WR_ADDR_HALT_EN\t\tBIT(31)\n\n \n#define PARF_Q2A_FLUSH_EN\t\t\tBIT(16)\n\n \n#define PARF_SYS_CTRL_AUX_PWR_DET\t\tBIT(4)\n#define PARF_SYS_CTRL_CORE_CLK_CGC_DIS\t\tBIT(6)\n#define PARF_SYS_CTRL_MSTR_ACLK_CGC_DIS\t\tBIT(10)\n#define PARF_SYS_CTRL_SLV_DBI_WAKE_DISABLE\tBIT(11)\n\n \n#define PARF_DB_CTRL_INSR_DBNCR_BLOCK\t\tBIT(0)\n#define PARF_DB_CTRL_RMVL_DBNCR_BLOCK\t\tBIT(1)\n#define PARF_DB_CTRL_DBI_WKP_BLOCK\t\tBIT(4)\n#define PARF_DB_CTRL_SLV_WKP_BLOCK\t\tBIT(5)\n#define PARF_DB_CTRL_MST_WKP_BLOCK\t\tBIT(6)\n\n \n#define PARF_CFG_BITS_REQ_EXIT_L1SS_MSI_LTR_EN\tBIT(1)\n\n \n#define ELBI_SYS_STTS\t\t\t\t0x08\n#define ELBI_CS2_ENABLE\t\t\t\t0xa4\n\n \n#define DBI_CON_STATUS\t\t\t\t0x44\n\n \n#define DBI_CON_STATUS_POWER_STATE_MASK\t\tGENMASK(1, 0)\n\n#define XMLH_LINK_UP\t\t\t\t0x400\n#define CORE_RESET_TIME_US_MIN\t\t\t1000\n#define CORE_RESET_TIME_US_MAX\t\t\t1005\n#define WAKE_DELAY_US\t\t\t\t2000  \n\n#define PCIE_GEN1_BW_MBPS\t\t\t250\n#define PCIE_GEN2_BW_MBPS\t\t\t500\n#define PCIE_GEN3_BW_MBPS\t\t\t985\n#define PCIE_GEN4_BW_MBPS\t\t\t1969\n\n#define to_pcie_ep(x)\t\t\t\tdev_get_drvdata((x)->dev)\n\nenum qcom_pcie_ep_link_status {\n\tQCOM_PCIE_EP_LINK_DISABLED,\n\tQCOM_PCIE_EP_LINK_ENABLED,\n\tQCOM_PCIE_EP_LINK_UP,\n\tQCOM_PCIE_EP_LINK_DOWN,\n};\n\n \nstruct qcom_pcie_ep {\n\tstruct dw_pcie pci;\n\n\tvoid __iomem *parf;\n\tvoid __iomem *elbi;\n\tvoid __iomem *mmio;\n\tstruct regmap *perst_map;\n\tstruct resource *mmio_res;\n\n\tstruct reset_control *core_reset;\n\tstruct gpio_desc *reset;\n\tstruct gpio_desc *wake;\n\tstruct phy *phy;\n\tstruct dentry *debugfs;\n\n\tstruct icc_path *icc_mem;\n\n\tstruct clk_bulk_data *clks;\n\tint num_clks;\n\n\tu32 perst_en;\n\tu32 perst_sep_en;\n\n\tenum qcom_pcie_ep_link_status link_status;\n\tint global_irq;\n\tint perst_irq;\n};\n\nstatic int qcom_pcie_ep_core_reset(struct qcom_pcie_ep *pcie_ep)\n{\n\tstruct dw_pcie *pci = &pcie_ep->pci;\n\tstruct device *dev = pci->dev;\n\tint ret;\n\n\tret = reset_control_assert(pcie_ep->core_reset);\n\tif (ret) {\n\t\tdev_err(dev, \"Cannot assert core reset\\n\");\n\t\treturn ret;\n\t}\n\n\tusleep_range(CORE_RESET_TIME_US_MIN, CORE_RESET_TIME_US_MAX);\n\n\tret = reset_control_deassert(pcie_ep->core_reset);\n\tif (ret) {\n\t\tdev_err(dev, \"Cannot de-assert core reset\\n\");\n\t\treturn ret;\n\t}\n\n\tusleep_range(CORE_RESET_TIME_US_MIN, CORE_RESET_TIME_US_MAX);\n\n\treturn 0;\n}\n\n \nstatic void qcom_pcie_ep_configure_tcsr(struct qcom_pcie_ep *pcie_ep)\n{\n\tif (pcie_ep->perst_map) {\n\t\tregmap_write(pcie_ep->perst_map, pcie_ep->perst_en, 0);\n\t\tregmap_write(pcie_ep->perst_map, pcie_ep->perst_sep_en, 0);\n\t}\n}\n\nstatic int qcom_pcie_dw_link_up(struct dw_pcie *pci)\n{\n\tstruct qcom_pcie_ep *pcie_ep = to_pcie_ep(pci);\n\tu32 reg;\n\n\treg = readl_relaxed(pcie_ep->elbi + ELBI_SYS_STTS);\n\n\treturn reg & XMLH_LINK_UP;\n}\n\nstatic int qcom_pcie_dw_start_link(struct dw_pcie *pci)\n{\n\tstruct qcom_pcie_ep *pcie_ep = to_pcie_ep(pci);\n\n\tenable_irq(pcie_ep->perst_irq);\n\n\treturn 0;\n}\n\nstatic void qcom_pcie_dw_stop_link(struct dw_pcie *pci)\n{\n\tstruct qcom_pcie_ep *pcie_ep = to_pcie_ep(pci);\n\n\tdisable_irq(pcie_ep->perst_irq);\n}\n\nstatic void qcom_pcie_dw_write_dbi2(struct dw_pcie *pci, void __iomem *base,\n\t\t\t\t    u32 reg, size_t size, u32 val)\n{\n\tstruct qcom_pcie_ep *pcie_ep = to_pcie_ep(pci);\n\tint ret;\n\n\twritel(1, pcie_ep->elbi + ELBI_CS2_ENABLE);\n\n\tret = dw_pcie_write(pci->dbi_base2 + reg, size, val);\n\tif (ret)\n\t\tdev_err(pci->dev, \"Failed to write DBI2 register (0x%x): %d\\n\", reg, ret);\n\n\twritel(0, pcie_ep->elbi + ELBI_CS2_ENABLE);\n}\n\nstatic void qcom_pcie_ep_icc_update(struct qcom_pcie_ep *pcie_ep)\n{\n\tstruct dw_pcie *pci = &pcie_ep->pci;\n\tu32 offset, status, bw;\n\tint speed, width;\n\tint ret;\n\n\tif (!pcie_ep->icc_mem)\n\t\treturn;\n\n\toffset = dw_pcie_find_capability(pci, PCI_CAP_ID_EXP);\n\tstatus = readw(pci->dbi_base + offset + PCI_EXP_LNKSTA);\n\n\tspeed = FIELD_GET(PCI_EXP_LNKSTA_CLS, status);\n\twidth = FIELD_GET(PCI_EXP_LNKSTA_NLW, status);\n\n\tswitch (speed) {\n\tcase 1:\n\t\tbw = MBps_to_icc(PCIE_GEN1_BW_MBPS);\n\t\tbreak;\n\tcase 2:\n\t\tbw = MBps_to_icc(PCIE_GEN2_BW_MBPS);\n\t\tbreak;\n\tcase 3:\n\t\tbw = MBps_to_icc(PCIE_GEN3_BW_MBPS);\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(pci->dev, \"using default GEN4 bandwidth\\n\");\n\t\tfallthrough;\n\tcase 4:\n\t\tbw = MBps_to_icc(PCIE_GEN4_BW_MBPS);\n\t\tbreak;\n\t}\n\n\tret = icc_set_bw(pcie_ep->icc_mem, 0, width * bw);\n\tif (ret)\n\t\tdev_err(pci->dev, \"failed to set interconnect bandwidth: %d\\n\",\n\t\t\tret);\n}\n\nstatic int qcom_pcie_enable_resources(struct qcom_pcie_ep *pcie_ep)\n{\n\tstruct dw_pcie *pci = &pcie_ep->pci;\n\tint ret;\n\n\tret = clk_bulk_prepare_enable(pcie_ep->num_clks, pcie_ep->clks);\n\tif (ret)\n\t\treturn ret;\n\n\tret = qcom_pcie_ep_core_reset(pcie_ep);\n\tif (ret)\n\t\tgoto err_disable_clk;\n\n\tret = phy_init(pcie_ep->phy);\n\tif (ret)\n\t\tgoto err_disable_clk;\n\n\tret = phy_set_mode_ext(pcie_ep->phy, PHY_MODE_PCIE, PHY_MODE_PCIE_EP);\n\tif (ret)\n\t\tgoto err_phy_exit;\n\n\tret = phy_power_on(pcie_ep->phy);\n\tif (ret)\n\t\tgoto err_phy_exit;\n\n\t \n\tret = icc_set_bw(pcie_ep->icc_mem, 0, MBps_to_icc(PCIE_GEN1_BW_MBPS));\n\tif (ret) {\n\t\tdev_err(pci->dev, \"failed to set interconnect bandwidth: %d\\n\",\n\t\t\tret);\n\t\tgoto err_phy_off;\n\t}\n\n\treturn 0;\n\nerr_phy_off:\n\tphy_power_off(pcie_ep->phy);\nerr_phy_exit:\n\tphy_exit(pcie_ep->phy);\nerr_disable_clk:\n\tclk_bulk_disable_unprepare(pcie_ep->num_clks, pcie_ep->clks);\n\n\treturn ret;\n}\n\nstatic void qcom_pcie_disable_resources(struct qcom_pcie_ep *pcie_ep)\n{\n\ticc_set_bw(pcie_ep->icc_mem, 0, 0);\n\tphy_power_off(pcie_ep->phy);\n\tphy_exit(pcie_ep->phy);\n\tclk_bulk_disable_unprepare(pcie_ep->num_clks, pcie_ep->clks);\n}\n\nstatic int qcom_pcie_perst_deassert(struct dw_pcie *pci)\n{\n\tstruct qcom_pcie_ep *pcie_ep = to_pcie_ep(pci);\n\tstruct device *dev = pci->dev;\n\tu32 val, offset;\n\tint ret;\n\n\tret = qcom_pcie_enable_resources(pcie_ep);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to enable resources: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tgpiod_set_value_cansleep(pcie_ep->wake, 1);\n\tusleep_range(WAKE_DELAY_US, WAKE_DELAY_US + 500);\n\tgpiod_set_value_cansleep(pcie_ep->wake, 0);\n\n\tqcom_pcie_ep_configure_tcsr(pcie_ep);\n\n\t \n\tval = readl_relaxed(pcie_ep->parf + PARF_BDF_TO_SID_CFG);\n\tval |= PARF_BDF_TO_SID_BYPASS;\n\twritel_relaxed(val, pcie_ep->parf + PARF_BDF_TO_SID_CFG);\n\n\t \n\tval = readl_relaxed(pcie_ep->parf + PARF_DEBUG_INT_EN);\n\tval |= PARF_DEBUG_INT_RADM_PM_TURNOFF |\n\t       PARF_DEBUG_INT_CFG_BUS_MASTER_EN |\n\t       PARF_DEBUG_INT_PM_DSTATE_CHANGE;\n\twritel_relaxed(val, pcie_ep->parf + PARF_DEBUG_INT_EN);\n\n\t \n\twritel_relaxed(PARF_DEVICE_TYPE_EP, pcie_ep->parf + PARF_DEVICE_TYPE);\n\n\t \n\tval = readl_relaxed(pcie_ep->parf + PARF_PM_CTRL);\n\tval &= ~PARF_PM_CTRL_REQ_NOT_ENTR_L1;\n\twritel_relaxed(val, pcie_ep->parf + PARF_PM_CTRL);\n\n\t \n\tval = readl_relaxed(pcie_ep->parf + PARF_AXI_MSTR_RD_HALT_NO_WRITES);\n\tval &= ~PARF_AXI_MSTR_RD_HALT_NO_WRITE_EN;\n\twritel_relaxed(val, pcie_ep->parf + PARF_AXI_MSTR_RD_HALT_NO_WRITES);\n\n\t \n\tval = readl_relaxed(pcie_ep->parf + PARF_AXI_MSTR_WR_ADDR_HALT);\n\tval |= PARF_AXI_MSTR_WR_ADDR_HALT_EN;\n\twritel_relaxed(val, pcie_ep->parf + PARF_AXI_MSTR_WR_ADDR_HALT);\n\n\t \n\tval = readl_relaxed(pcie_ep->parf + PARF_Q2A_FLUSH);\n\tval &= ~PARF_Q2A_FLUSH_EN;\n\twritel_relaxed(val, pcie_ep->parf + PARF_Q2A_FLUSH);\n\n\t \n\tval = readl_relaxed(pcie_ep->parf + PARF_SYS_CTRL);\n\tval &= ~PARF_SYS_CTRL_MSTR_ACLK_CGC_DIS;\n\tval |= PARF_SYS_CTRL_SLV_DBI_WAKE_DISABLE |\n\t       PARF_SYS_CTRL_CORE_CLK_CGC_DIS |\n\t       PARF_SYS_CTRL_AUX_PWR_DET;\n\twritel_relaxed(val, pcie_ep->parf + PARF_SYS_CTRL);\n\n\t \n\tval = readl_relaxed(pcie_ep->parf + PARF_DB_CTRL);\n\tval |= PARF_DB_CTRL_INSR_DBNCR_BLOCK | PARF_DB_CTRL_RMVL_DBNCR_BLOCK |\n\t       PARF_DB_CTRL_DBI_WKP_BLOCK | PARF_DB_CTRL_SLV_WKP_BLOCK |\n\t       PARF_DB_CTRL_MST_WKP_BLOCK;\n\twritel_relaxed(val, pcie_ep->parf + PARF_DB_CTRL);\n\n\t \n\tval = readl_relaxed(pcie_ep->parf + PARF_CFG_BITS);\n\tval |= PARF_CFG_BITS_REQ_EXIT_L1SS_MSI_LTR_EN;\n\twritel_relaxed(val, pcie_ep->parf + PARF_CFG_BITS);\n\n\tdw_pcie_dbi_ro_wr_en(pci);\n\n\t \n\toffset = dw_pcie_find_capability(pci, PCI_CAP_ID_EXP);\n\tval = dw_pcie_readl_dbi(pci, offset + PCI_EXP_LNKCAP);\n\tval &= ~PCI_EXP_LNKCAP_L0SEL;\n\tval |= FIELD_PREP(PCI_EXP_LNKCAP_L0SEL, 0x6);\n\tdw_pcie_writel_dbi(pci, offset + PCI_EXP_LNKCAP, val);\n\n\t \n\toffset = dw_pcie_find_capability(pci, PCI_CAP_ID_EXP);\n\tval = dw_pcie_readl_dbi(pci, offset + PCI_EXP_LNKCAP);\n\tval &= ~PCI_EXP_LNKCAP_L1EL;\n\tval |= FIELD_PREP(PCI_EXP_LNKCAP_L1EL, 0x6);\n\tdw_pcie_writel_dbi(pci, offset + PCI_EXP_LNKCAP, val);\n\n\tdw_pcie_dbi_ro_wr_dis(pci);\n\n\twritel_relaxed(0, pcie_ep->parf + PARF_INT_ALL_MASK);\n\tval = PARF_INT_ALL_LINK_DOWN | PARF_INT_ALL_BME |\n\t      PARF_INT_ALL_PM_TURNOFF | PARF_INT_ALL_DSTATE_CHANGE |\n\t      PARF_INT_ALL_LINK_UP | PARF_INT_ALL_EDMA;\n\twritel_relaxed(val, pcie_ep->parf + PARF_INT_ALL_MASK);\n\n\tret = dw_pcie_ep_init_complete(&pcie_ep->pci.ep);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to complete initialization: %d\\n\", ret);\n\t\tgoto err_disable_resources;\n\t}\n\n\t \n\twritel_relaxed(pcie_ep->mmio_res->start,\n\t\t       pcie_ep->parf + PARF_MHI_BASE_ADDR_LOWER);\n\twritel_relaxed(0, pcie_ep->parf + PARF_MHI_BASE_ADDR_UPPER);\n\n\t \n\tval = readl_relaxed(pcie_ep->parf + PARF_MHI_CLOCK_RESET_CTRL);\n\tval &= ~PARF_MSTR_AXI_CLK_EN;\n\twritel_relaxed(val, pcie_ep->parf + PARF_MHI_CLOCK_RESET_CTRL);\n\n\tdw_pcie_ep_init_notify(&pcie_ep->pci.ep);\n\n\t \n\tval = readl_relaxed(pcie_ep->parf + PARF_LTSSM);\n\tval |= BIT(8);\n\twritel_relaxed(val, pcie_ep->parf + PARF_LTSSM);\n\n\treturn 0;\n\nerr_disable_resources:\n\tqcom_pcie_disable_resources(pcie_ep);\n\n\treturn ret;\n}\n\nstatic void qcom_pcie_perst_assert(struct dw_pcie *pci)\n{\n\tstruct qcom_pcie_ep *pcie_ep = to_pcie_ep(pci);\n\tstruct device *dev = pci->dev;\n\n\tif (pcie_ep->link_status == QCOM_PCIE_EP_LINK_DISABLED) {\n\t\tdev_dbg(dev, \"Link is already disabled\\n\");\n\t\treturn;\n\t}\n\n\tqcom_pcie_disable_resources(pcie_ep);\n\tpcie_ep->link_status = QCOM_PCIE_EP_LINK_DISABLED;\n}\n\n \nstatic const struct dw_pcie_ops pci_ops = {\n\t.link_up = qcom_pcie_dw_link_up,\n\t.start_link = qcom_pcie_dw_start_link,\n\t.stop_link = qcom_pcie_dw_stop_link,\n\t.write_dbi2 = qcom_pcie_dw_write_dbi2,\n};\n\nstatic int qcom_pcie_ep_get_io_resources(struct platform_device *pdev,\n\t\t\t\t\t struct qcom_pcie_ep *pcie_ep)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct dw_pcie *pci = &pcie_ep->pci;\n\tstruct device_node *syscon;\n\tstruct resource *res;\n\tint ret;\n\n\tpcie_ep->parf = devm_platform_ioremap_resource_byname(pdev, \"parf\");\n\tif (IS_ERR(pcie_ep->parf))\n\t\treturn PTR_ERR(pcie_ep->parf);\n\n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"dbi\");\n\tpci->dbi_base = devm_pci_remap_cfg_resource(dev, res);\n\tif (IS_ERR(pci->dbi_base))\n\t\treturn PTR_ERR(pci->dbi_base);\n\tpci->dbi_base2 = pci->dbi_base;\n\n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"elbi\");\n\tpcie_ep->elbi = devm_pci_remap_cfg_resource(dev, res);\n\tif (IS_ERR(pcie_ep->elbi))\n\t\treturn PTR_ERR(pcie_ep->elbi);\n\n\tpcie_ep->mmio_res = platform_get_resource_byname(pdev, IORESOURCE_MEM,\n\t\t\t\t\t\t\t \"mmio\");\n\tif (!pcie_ep->mmio_res) {\n\t\tdev_err(dev, \"Failed to get mmio resource\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpcie_ep->mmio = devm_pci_remap_cfg_resource(dev, pcie_ep->mmio_res);\n\tif (IS_ERR(pcie_ep->mmio))\n\t\treturn PTR_ERR(pcie_ep->mmio);\n\n\tsyscon = of_parse_phandle(dev->of_node, \"qcom,perst-regs\", 0);\n\tif (!syscon) {\n\t\tdev_dbg(dev, \"PERST separation not available\\n\");\n\t\treturn 0;\n\t}\n\n\tpcie_ep->perst_map = syscon_node_to_regmap(syscon);\n\tof_node_put(syscon);\n\tif (IS_ERR(pcie_ep->perst_map))\n\t\treturn PTR_ERR(pcie_ep->perst_map);\n\n\tret = of_property_read_u32_index(dev->of_node, \"qcom,perst-regs\",\n\t\t\t\t\t 1, &pcie_ep->perst_en);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"No Perst Enable offset in syscon\\n\");\n\t\treturn ret;\n\t}\n\n\tret = of_property_read_u32_index(dev->of_node, \"qcom,perst-regs\",\n\t\t\t\t\t 2, &pcie_ep->perst_sep_en);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"No Perst Separation Enable offset in syscon\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int qcom_pcie_ep_get_resources(struct platform_device *pdev,\n\t\t\t\t      struct qcom_pcie_ep *pcie_ep)\n{\n\tstruct device *dev = &pdev->dev;\n\tint ret;\n\n\tret = qcom_pcie_ep_get_io_resources(pdev, pcie_ep);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to get io resources %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tpcie_ep->num_clks = devm_clk_bulk_get_all(dev, &pcie_ep->clks);\n\tif (pcie_ep->num_clks < 0) {\n\t\tdev_err(dev, \"Failed to get clocks\\n\");\n\t\treturn pcie_ep->num_clks;\n\t}\n\n\tpcie_ep->core_reset = devm_reset_control_get_exclusive(dev, \"core\");\n\tif (IS_ERR(pcie_ep->core_reset))\n\t\treturn PTR_ERR(pcie_ep->core_reset);\n\n\tpcie_ep->reset = devm_gpiod_get(dev, \"reset\", GPIOD_IN);\n\tif (IS_ERR(pcie_ep->reset))\n\t\treturn PTR_ERR(pcie_ep->reset);\n\n\tpcie_ep->wake = devm_gpiod_get_optional(dev, \"wake\", GPIOD_OUT_LOW);\n\tif (IS_ERR(pcie_ep->wake))\n\t\treturn PTR_ERR(pcie_ep->wake);\n\n\tpcie_ep->phy = devm_phy_optional_get(dev, \"pciephy\");\n\tif (IS_ERR(pcie_ep->phy))\n\t\tret = PTR_ERR(pcie_ep->phy);\n\n\tpcie_ep->icc_mem = devm_of_icc_get(dev, \"pcie-mem\");\n\tif (IS_ERR(pcie_ep->icc_mem))\n\t\tret = PTR_ERR(pcie_ep->icc_mem);\n\n\treturn ret;\n}\n\n \nstatic irqreturn_t qcom_pcie_ep_global_irq_thread(int irq, void *data)\n{\n\tstruct qcom_pcie_ep *pcie_ep = data;\n\tstruct dw_pcie *pci = &pcie_ep->pci;\n\tstruct device *dev = pci->dev;\n\tu32 status = readl_relaxed(pcie_ep->parf + PARF_INT_ALL_STATUS);\n\tu32 mask = readl_relaxed(pcie_ep->parf + PARF_INT_ALL_MASK);\n\tu32 dstate, val;\n\n\twritel_relaxed(status, pcie_ep->parf + PARF_INT_ALL_CLEAR);\n\tstatus &= mask;\n\n\tif (FIELD_GET(PARF_INT_ALL_LINK_DOWN, status)) {\n\t\tdev_dbg(dev, \"Received Linkdown event\\n\");\n\t\tpcie_ep->link_status = QCOM_PCIE_EP_LINK_DOWN;\n\t\tpci_epc_linkdown(pci->ep.epc);\n\t} else if (FIELD_GET(PARF_INT_ALL_BME, status)) {\n\t\tdev_dbg(dev, \"Received BME event. Link is enabled!\\n\");\n\t\tpcie_ep->link_status = QCOM_PCIE_EP_LINK_ENABLED;\n\t\tqcom_pcie_ep_icc_update(pcie_ep);\n\t\tpci_epc_bme_notify(pci->ep.epc);\n\t} else if (FIELD_GET(PARF_INT_ALL_PM_TURNOFF, status)) {\n\t\tdev_dbg(dev, \"Received PM Turn-off event! Entering L23\\n\");\n\t\tval = readl_relaxed(pcie_ep->parf + PARF_PM_CTRL);\n\t\tval |= PARF_PM_CTRL_READY_ENTR_L23;\n\t\twritel_relaxed(val, pcie_ep->parf + PARF_PM_CTRL);\n\t} else if (FIELD_GET(PARF_INT_ALL_DSTATE_CHANGE, status)) {\n\t\tdstate = dw_pcie_readl_dbi(pci, DBI_CON_STATUS) &\n\t\t\t\t\t   DBI_CON_STATUS_POWER_STATE_MASK;\n\t\tdev_dbg(dev, \"Received D%d state event\\n\", dstate);\n\t\tif (dstate == 3) {\n\t\t\tval = readl_relaxed(pcie_ep->parf + PARF_PM_CTRL);\n\t\t\tval |= PARF_PM_CTRL_REQ_EXIT_L1;\n\t\t\twritel_relaxed(val, pcie_ep->parf + PARF_PM_CTRL);\n\t\t}\n\t} else if (FIELD_GET(PARF_INT_ALL_LINK_UP, status)) {\n\t\tdev_dbg(dev, \"Received Linkup event. Enumeration complete!\\n\");\n\t\tdw_pcie_ep_linkup(&pci->ep);\n\t\tpcie_ep->link_status = QCOM_PCIE_EP_LINK_UP;\n\t} else {\n\t\tdev_err(dev, \"Received unknown event: %d\\n\", status);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t qcom_pcie_ep_perst_irq_thread(int irq, void *data)\n{\n\tstruct qcom_pcie_ep *pcie_ep = data;\n\tstruct dw_pcie *pci = &pcie_ep->pci;\n\tstruct device *dev = pci->dev;\n\tu32 perst;\n\n\tperst = gpiod_get_value(pcie_ep->reset);\n\tif (perst) {\n\t\tdev_dbg(dev, \"PERST asserted by host. Shutting down the PCIe link!\\n\");\n\t\tqcom_pcie_perst_assert(pci);\n\t} else {\n\t\tdev_dbg(dev, \"PERST de-asserted by host. Starting link training!\\n\");\n\t\tqcom_pcie_perst_deassert(pci);\n\t}\n\n\tirq_set_irq_type(gpiod_to_irq(pcie_ep->reset),\n\t\t\t (perst ? IRQF_TRIGGER_HIGH : IRQF_TRIGGER_LOW));\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int qcom_pcie_ep_enable_irq_resources(struct platform_device *pdev,\n\t\t\t\t\t     struct qcom_pcie_ep *pcie_ep)\n{\n\tint ret;\n\n\tpcie_ep->global_irq = platform_get_irq_byname(pdev, \"global\");\n\tif (pcie_ep->global_irq < 0)\n\t\treturn pcie_ep->global_irq;\n\n\tret = devm_request_threaded_irq(&pdev->dev, pcie_ep->global_irq, NULL,\n\t\t\t\t\tqcom_pcie_ep_global_irq_thread,\n\t\t\t\t\tIRQF_ONESHOT,\n\t\t\t\t\t\"global_irq\", pcie_ep);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed to request Global IRQ\\n\");\n\t\treturn ret;\n\t}\n\n\tpcie_ep->perst_irq = gpiod_to_irq(pcie_ep->reset);\n\tirq_set_status_flags(pcie_ep->perst_irq, IRQ_NOAUTOEN);\n\tret = devm_request_threaded_irq(&pdev->dev, pcie_ep->perst_irq, NULL,\n\t\t\t\t\tqcom_pcie_ep_perst_irq_thread,\n\t\t\t\t\tIRQF_TRIGGER_HIGH | IRQF_ONESHOT,\n\t\t\t\t\t\"perst_irq\", pcie_ep);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed to request PERST IRQ\\n\");\n\t\tdisable_irq(pcie_ep->global_irq);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int qcom_pcie_ep_raise_irq(struct dw_pcie_ep *ep, u8 func_no,\n\t\t\t\t  enum pci_epc_irq_type type, u16 interrupt_num)\n{\n\tstruct dw_pcie *pci = to_dw_pcie_from_ep(ep);\n\n\tswitch (type) {\n\tcase PCI_EPC_IRQ_LEGACY:\n\t\treturn dw_pcie_ep_raise_legacy_irq(ep, func_no);\n\tcase PCI_EPC_IRQ_MSI:\n\t\treturn dw_pcie_ep_raise_msi_irq(ep, func_no, interrupt_num);\n\tdefault:\n\t\tdev_err(pci->dev, \"Unknown IRQ type\\n\");\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int qcom_pcie_ep_link_transition_count(struct seq_file *s, void *data)\n{\n\tstruct qcom_pcie_ep *pcie_ep = (struct qcom_pcie_ep *)\n\t\t\t\t     dev_get_drvdata(s->private);\n\n\tseq_printf(s, \"L0s transition count: %u\\n\",\n\t\t   readl_relaxed(pcie_ep->mmio + PARF_DEBUG_CNT_PM_LINKST_IN_L0S));\n\n\tseq_printf(s, \"L1 transition count: %u\\n\",\n\t\t   readl_relaxed(pcie_ep->mmio + PARF_DEBUG_CNT_PM_LINKST_IN_L1));\n\n\tseq_printf(s, \"L1.1 transition count: %u\\n\",\n\t\t   readl_relaxed(pcie_ep->mmio + PARF_DEBUG_CNT_AUX_CLK_IN_L1SUB_L1));\n\n\tseq_printf(s, \"L1.2 transition count: %u\\n\",\n\t\t   readl_relaxed(pcie_ep->mmio + PARF_DEBUG_CNT_AUX_CLK_IN_L1SUB_L2));\n\n\tseq_printf(s, \"L2 transition count: %u\\n\",\n\t\t   readl_relaxed(pcie_ep->mmio + PARF_DEBUG_CNT_PM_LINKST_IN_L2));\n\n\treturn 0;\n}\n\nstatic void qcom_pcie_ep_init_debugfs(struct qcom_pcie_ep *pcie_ep)\n{\n\tstruct dw_pcie *pci = &pcie_ep->pci;\n\n\tdebugfs_create_devm_seqfile(pci->dev, \"link_transition_count\", pcie_ep->debugfs,\n\t\t\t\t    qcom_pcie_ep_link_transition_count);\n}\n\nstatic const struct pci_epc_features qcom_pcie_epc_features = {\n\t.linkup_notifier = true,\n\t.core_init_notifier = true,\n\t.msi_capable = true,\n\t.msix_capable = false,\n\t.align = SZ_4K,\n};\n\nstatic const struct pci_epc_features *\nqcom_pcie_epc_get_features(struct dw_pcie_ep *pci_ep)\n{\n\treturn &qcom_pcie_epc_features;\n}\n\nstatic void qcom_pcie_ep_init(struct dw_pcie_ep *ep)\n{\n\tstruct dw_pcie *pci = to_dw_pcie_from_ep(ep);\n\tenum pci_barno bar;\n\n\tfor (bar = BAR_0; bar <= BAR_5; bar++)\n\t\tdw_pcie_ep_reset_bar(pci, bar);\n}\n\nstatic const struct dw_pcie_ep_ops pci_ep_ops = {\n\t.ep_init = qcom_pcie_ep_init,\n\t.raise_irq = qcom_pcie_ep_raise_irq,\n\t.get_features = qcom_pcie_epc_get_features,\n};\n\nstatic int qcom_pcie_ep_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct qcom_pcie_ep *pcie_ep;\n\tchar *name;\n\tint ret;\n\n\tpcie_ep = devm_kzalloc(dev, sizeof(*pcie_ep), GFP_KERNEL);\n\tif (!pcie_ep)\n\t\treturn -ENOMEM;\n\n\tpcie_ep->pci.dev = dev;\n\tpcie_ep->pci.ops = &pci_ops;\n\tpcie_ep->pci.ep.ops = &pci_ep_ops;\n\tpcie_ep->pci.edma.nr_irqs = 1;\n\tplatform_set_drvdata(pdev, pcie_ep);\n\n\tret = qcom_pcie_ep_get_resources(pdev, pcie_ep);\n\tif (ret)\n\t\treturn ret;\n\n\tret = qcom_pcie_enable_resources(pcie_ep);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to enable resources: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = dw_pcie_ep_init(&pcie_ep->pci.ep);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to initialize endpoint: %d\\n\", ret);\n\t\tgoto err_disable_resources;\n\t}\n\n\tret = qcom_pcie_ep_enable_irq_resources(pdev, pcie_ep);\n\tif (ret)\n\t\tgoto err_disable_resources;\n\n\tname = devm_kasprintf(dev, GFP_KERNEL, \"%pOFP\", dev->of_node);\n\tif (!name) {\n\t\tret = -ENOMEM;\n\t\tgoto err_disable_irqs;\n\t}\n\n\tpcie_ep->debugfs = debugfs_create_dir(name, NULL);\n\tqcom_pcie_ep_init_debugfs(pcie_ep);\n\n\treturn 0;\n\nerr_disable_irqs:\n\tdisable_irq(pcie_ep->global_irq);\n\tdisable_irq(pcie_ep->perst_irq);\n\nerr_disable_resources:\n\tqcom_pcie_disable_resources(pcie_ep);\n\n\treturn ret;\n}\n\nstatic void qcom_pcie_ep_remove(struct platform_device *pdev)\n{\n\tstruct qcom_pcie_ep *pcie_ep = platform_get_drvdata(pdev);\n\n\tdisable_irq(pcie_ep->global_irq);\n\tdisable_irq(pcie_ep->perst_irq);\n\n\tdebugfs_remove_recursive(pcie_ep->debugfs);\n\n\tif (pcie_ep->link_status == QCOM_PCIE_EP_LINK_DISABLED)\n\t\treturn;\n\n\tqcom_pcie_disable_resources(pcie_ep);\n}\n\nstatic const struct of_device_id qcom_pcie_ep_match[] = {\n\t{ .compatible = \"qcom,sdx55-pcie-ep\", },\n\t{ .compatible = \"qcom,sm8450-pcie-ep\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, qcom_pcie_ep_match);\n\nstatic struct platform_driver qcom_pcie_ep_driver = {\n\t.probe\t= qcom_pcie_ep_probe,\n\t.remove_new = qcom_pcie_ep_remove,\n\t.driver\t= {\n\t\t.name = \"qcom-pcie-ep\",\n\t\t.of_match_table\t= qcom_pcie_ep_match,\n\t},\n};\nbuiltin_platform_driver(qcom_pcie_ep_driver);\n\nMODULE_AUTHOR(\"Siddartha Mohanadoss <smohanad@codeaurora.org>\");\nMODULE_AUTHOR(\"Manivannan Sadhasivam <manivannan.sadhasivam@linaro.org>\");\nMODULE_DESCRIPTION(\"Qualcomm PCIe Endpoint controller driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}