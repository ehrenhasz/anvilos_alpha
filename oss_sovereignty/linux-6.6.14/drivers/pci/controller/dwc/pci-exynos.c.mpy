{
  "module_name": "pci-exynos.c",
  "hash_id": "706f3e070bf95688ca23dd7e7d20ff3381c4fb587f2cc0221ae2ed4ef9a13f10",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/controller/dwc/pci-exynos.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/pci.h>\n#include <linux/platform_device.h>\n#include <linux/phy/phy.h>\n#include <linux/regulator/consumer.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n\n#include \"pcie-designware.h\"\n\n#define to_exynos_pcie(x)\tdev_get_drvdata((x)->dev)\n\n \n#define PCIE_IRQ_PULSE\t\t\t0x000\n#define IRQ_INTA_ASSERT\t\t\tBIT(0)\n#define IRQ_INTB_ASSERT\t\t\tBIT(2)\n#define IRQ_INTC_ASSERT\t\t\tBIT(4)\n#define IRQ_INTD_ASSERT\t\t\tBIT(6)\n#define PCIE_IRQ_LEVEL\t\t\t0x004\n#define PCIE_IRQ_SPECIAL\t\t0x008\n#define PCIE_IRQ_EN_PULSE\t\t0x00c\n#define PCIE_IRQ_EN_LEVEL\t\t0x010\n#define PCIE_IRQ_EN_SPECIAL\t\t0x014\n#define PCIE_SW_WAKE\t\t\t0x018\n#define PCIE_BUS_EN\t\t\tBIT(1)\n#define PCIE_CORE_RESET\t\t\t0x01c\n#define PCIE_CORE_RESET_ENABLE\t\tBIT(0)\n#define PCIE_STICKY_RESET\t\t0x020\n#define PCIE_NONSTICKY_RESET\t\t0x024\n#define PCIE_APP_INIT_RESET\t\t0x028\n#define PCIE_APP_LTSSM_ENABLE\t\t0x02c\n#define PCIE_ELBI_RDLH_LINKUP\t\t0x074\n#define PCIE_ELBI_XMLH_LINKUP\t\tBIT(4)\n#define PCIE_ELBI_LTSSM_ENABLE\t\t0x1\n#define PCIE_ELBI_SLV_AWMISC\t\t0x11c\n#define PCIE_ELBI_SLV_ARMISC\t\t0x120\n#define PCIE_ELBI_SLV_DBI_ENABLE\tBIT(21)\n\nstruct exynos_pcie {\n\tstruct dw_pcie\t\t\tpci;\n\tvoid __iomem\t\t\t*elbi_base;\n\tstruct clk\t\t\t*clk;\n\tstruct clk\t\t\t*bus_clk;\n\tstruct phy\t\t\t*phy;\n\tstruct regulator_bulk_data\tsupplies[2];\n};\n\nstatic int exynos_pcie_init_clk_resources(struct exynos_pcie *ep)\n{\n\tstruct device *dev = ep->pci.dev;\n\tint ret;\n\n\tret = clk_prepare_enable(ep->clk);\n\tif (ret) {\n\t\tdev_err(dev, \"cannot enable pcie rc clock\");\n\t\treturn ret;\n\t}\n\n\tret = clk_prepare_enable(ep->bus_clk);\n\tif (ret) {\n\t\tdev_err(dev, \"cannot enable pcie bus clock\");\n\t\tgoto err_bus_clk;\n\t}\n\n\treturn 0;\n\nerr_bus_clk:\n\tclk_disable_unprepare(ep->clk);\n\n\treturn ret;\n}\n\nstatic void exynos_pcie_deinit_clk_resources(struct exynos_pcie *ep)\n{\n\tclk_disable_unprepare(ep->bus_clk);\n\tclk_disable_unprepare(ep->clk);\n}\n\nstatic void exynos_pcie_writel(void __iomem *base, u32 val, u32 reg)\n{\n\twritel(val, base + reg);\n}\n\nstatic u32 exynos_pcie_readl(void __iomem *base, u32 reg)\n{\n\treturn readl(base + reg);\n}\n\nstatic void exynos_pcie_sideband_dbi_w_mode(struct exynos_pcie *ep, bool on)\n{\n\tu32 val;\n\n\tval = exynos_pcie_readl(ep->elbi_base, PCIE_ELBI_SLV_AWMISC);\n\tif (on)\n\t\tval |= PCIE_ELBI_SLV_DBI_ENABLE;\n\telse\n\t\tval &= ~PCIE_ELBI_SLV_DBI_ENABLE;\n\texynos_pcie_writel(ep->elbi_base, val, PCIE_ELBI_SLV_AWMISC);\n}\n\nstatic void exynos_pcie_sideband_dbi_r_mode(struct exynos_pcie *ep, bool on)\n{\n\tu32 val;\n\n\tval = exynos_pcie_readl(ep->elbi_base, PCIE_ELBI_SLV_ARMISC);\n\tif (on)\n\t\tval |= PCIE_ELBI_SLV_DBI_ENABLE;\n\telse\n\t\tval &= ~PCIE_ELBI_SLV_DBI_ENABLE;\n\texynos_pcie_writel(ep->elbi_base, val, PCIE_ELBI_SLV_ARMISC);\n}\n\nstatic void exynos_pcie_assert_core_reset(struct exynos_pcie *ep)\n{\n\tu32 val;\n\n\tval = exynos_pcie_readl(ep->elbi_base, PCIE_CORE_RESET);\n\tval &= ~PCIE_CORE_RESET_ENABLE;\n\texynos_pcie_writel(ep->elbi_base, val, PCIE_CORE_RESET);\n\texynos_pcie_writel(ep->elbi_base, 0, PCIE_STICKY_RESET);\n\texynos_pcie_writel(ep->elbi_base, 0, PCIE_NONSTICKY_RESET);\n}\n\nstatic void exynos_pcie_deassert_core_reset(struct exynos_pcie *ep)\n{\n\tu32 val;\n\n\tval = exynos_pcie_readl(ep->elbi_base, PCIE_CORE_RESET);\n\tval |= PCIE_CORE_RESET_ENABLE;\n\n\texynos_pcie_writel(ep->elbi_base, val, PCIE_CORE_RESET);\n\texynos_pcie_writel(ep->elbi_base, 1, PCIE_STICKY_RESET);\n\texynos_pcie_writel(ep->elbi_base, 1, PCIE_NONSTICKY_RESET);\n\texynos_pcie_writel(ep->elbi_base, 1, PCIE_APP_INIT_RESET);\n\texynos_pcie_writel(ep->elbi_base, 0, PCIE_APP_INIT_RESET);\n}\n\nstatic int exynos_pcie_start_link(struct dw_pcie *pci)\n{\n\tstruct exynos_pcie *ep = to_exynos_pcie(pci);\n\tu32 val;\n\n\tval = exynos_pcie_readl(ep->elbi_base, PCIE_SW_WAKE);\n\tval &= ~PCIE_BUS_EN;\n\texynos_pcie_writel(ep->elbi_base, val, PCIE_SW_WAKE);\n\n\t \n\texynos_pcie_writel(ep->elbi_base, PCIE_ELBI_LTSSM_ENABLE,\n\t\t\t  PCIE_APP_LTSSM_ENABLE);\n\treturn 0;\n}\n\nstatic void exynos_pcie_clear_irq_pulse(struct exynos_pcie *ep)\n{\n\tu32 val = exynos_pcie_readl(ep->elbi_base, PCIE_IRQ_PULSE);\n\n\texynos_pcie_writel(ep->elbi_base, val, PCIE_IRQ_PULSE);\n}\n\nstatic irqreturn_t exynos_pcie_irq_handler(int irq, void *arg)\n{\n\tstruct exynos_pcie *ep = arg;\n\n\texynos_pcie_clear_irq_pulse(ep);\n\treturn IRQ_HANDLED;\n}\n\nstatic void exynos_pcie_enable_irq_pulse(struct exynos_pcie *ep)\n{\n\tu32 val = IRQ_INTA_ASSERT | IRQ_INTB_ASSERT |\n\t\t  IRQ_INTC_ASSERT | IRQ_INTD_ASSERT;\n\n\texynos_pcie_writel(ep->elbi_base, val, PCIE_IRQ_EN_PULSE);\n\texynos_pcie_writel(ep->elbi_base, 0, PCIE_IRQ_EN_LEVEL);\n\texynos_pcie_writel(ep->elbi_base, 0, PCIE_IRQ_EN_SPECIAL);\n}\n\nstatic u32 exynos_pcie_read_dbi(struct dw_pcie *pci, void __iomem *base,\n\t\t\t\tu32 reg, size_t size)\n{\n\tstruct exynos_pcie *ep = to_exynos_pcie(pci);\n\tu32 val;\n\n\texynos_pcie_sideband_dbi_r_mode(ep, true);\n\tdw_pcie_read(base + reg, size, &val);\n\texynos_pcie_sideband_dbi_r_mode(ep, false);\n\treturn val;\n}\n\nstatic void exynos_pcie_write_dbi(struct dw_pcie *pci, void __iomem *base,\n\t\t\t\t  u32 reg, size_t size, u32 val)\n{\n\tstruct exynos_pcie *ep = to_exynos_pcie(pci);\n\n\texynos_pcie_sideband_dbi_w_mode(ep, true);\n\tdw_pcie_write(base + reg, size, val);\n\texynos_pcie_sideband_dbi_w_mode(ep, false);\n}\n\nstatic int exynos_pcie_rd_own_conf(struct pci_bus *bus, unsigned int devfn,\n\t\t\t\t   int where, int size, u32 *val)\n{\n\tstruct dw_pcie *pci = to_dw_pcie_from_pp(bus->sysdata);\n\n\tif (PCI_SLOT(devfn))\n\t\treturn PCIBIOS_DEVICE_NOT_FOUND;\n\n\t*val = dw_pcie_read_dbi(pci, where, size);\n\treturn PCIBIOS_SUCCESSFUL;\n}\n\nstatic int exynos_pcie_wr_own_conf(struct pci_bus *bus, unsigned int devfn,\n\t\t\t\t   int where, int size, u32 val)\n{\n\tstruct dw_pcie *pci = to_dw_pcie_from_pp(bus->sysdata);\n\n\tif (PCI_SLOT(devfn))\n\t\treturn PCIBIOS_DEVICE_NOT_FOUND;\n\n\tdw_pcie_write_dbi(pci, where, size, val);\n\treturn PCIBIOS_SUCCESSFUL;\n}\n\nstatic struct pci_ops exynos_pci_ops = {\n\t.read = exynos_pcie_rd_own_conf,\n\t.write = exynos_pcie_wr_own_conf,\n};\n\nstatic int exynos_pcie_link_up(struct dw_pcie *pci)\n{\n\tstruct exynos_pcie *ep = to_exynos_pcie(pci);\n\tu32 val = exynos_pcie_readl(ep->elbi_base, PCIE_ELBI_RDLH_LINKUP);\n\n\treturn (val & PCIE_ELBI_XMLH_LINKUP);\n}\n\nstatic int exynos_pcie_host_init(struct dw_pcie_rp *pp)\n{\n\tstruct dw_pcie *pci = to_dw_pcie_from_pp(pp);\n\tstruct exynos_pcie *ep = to_exynos_pcie(pci);\n\n\tpp->bridge->ops = &exynos_pci_ops;\n\n\texynos_pcie_assert_core_reset(ep);\n\n\tphy_init(ep->phy);\n\tphy_power_on(ep->phy);\n\n\texynos_pcie_deassert_core_reset(ep);\n\texynos_pcie_enable_irq_pulse(ep);\n\n\treturn 0;\n}\n\nstatic const struct dw_pcie_host_ops exynos_pcie_host_ops = {\n\t.host_init = exynos_pcie_host_init,\n};\n\nstatic int exynos_add_pcie_port(struct exynos_pcie *ep,\n\t\t\t\t       struct platform_device *pdev)\n{\n\tstruct dw_pcie *pci = &ep->pci;\n\tstruct dw_pcie_rp *pp = &pci->pp;\n\tstruct device *dev = &pdev->dev;\n\tint ret;\n\n\tpp->irq = platform_get_irq(pdev, 0);\n\tif (pp->irq < 0)\n\t\treturn pp->irq;\n\n\tret = devm_request_irq(dev, pp->irq, exynos_pcie_irq_handler,\n\t\t\t       IRQF_SHARED, \"exynos-pcie\", ep);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to request irq\\n\");\n\t\treturn ret;\n\t}\n\n\tpp->ops = &exynos_pcie_host_ops;\n\tpp->msi_irq[0] = -ENODEV;\n\n\tret = dw_pcie_host_init(pp);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to initialize host\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct dw_pcie_ops dw_pcie_ops = {\n\t.read_dbi = exynos_pcie_read_dbi,\n\t.write_dbi = exynos_pcie_write_dbi,\n\t.link_up = exynos_pcie_link_up,\n\t.start_link = exynos_pcie_start_link,\n};\n\nstatic int exynos_pcie_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct exynos_pcie *ep;\n\tstruct device_node *np = dev->of_node;\n\tint ret;\n\n\tep = devm_kzalloc(dev, sizeof(*ep), GFP_KERNEL);\n\tif (!ep)\n\t\treturn -ENOMEM;\n\n\tep->pci.dev = dev;\n\tep->pci.ops = &dw_pcie_ops;\n\n\tep->phy = devm_of_phy_get(dev, np, NULL);\n\tif (IS_ERR(ep->phy))\n\t\treturn PTR_ERR(ep->phy);\n\n\t \n\tep->elbi_base = devm_platform_ioremap_resource_byname(pdev, \"elbi\");\n\tif (IS_ERR(ep->elbi_base))\n\t\treturn PTR_ERR(ep->elbi_base);\n\n\tep->clk = devm_clk_get(dev, \"pcie\");\n\tif (IS_ERR(ep->clk)) {\n\t\tdev_err(dev, \"Failed to get pcie rc clock\\n\");\n\t\treturn PTR_ERR(ep->clk);\n\t}\n\n\tep->bus_clk = devm_clk_get(dev, \"pcie_bus\");\n\tif (IS_ERR(ep->bus_clk)) {\n\t\tdev_err(dev, \"Failed to get pcie bus clock\\n\");\n\t\treturn PTR_ERR(ep->bus_clk);\n\t}\n\n\tep->supplies[0].supply = \"vdd18\";\n\tep->supplies[1].supply = \"vdd10\";\n\tret = devm_regulator_bulk_get(dev, ARRAY_SIZE(ep->supplies),\n\t\t\t\t      ep->supplies);\n\tif (ret)\n\t\treturn ret;\n\n\tret = exynos_pcie_init_clk_resources(ep);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regulator_bulk_enable(ARRAY_SIZE(ep->supplies), ep->supplies);\n\tif (ret)\n\t\treturn ret;\n\n\tplatform_set_drvdata(pdev, ep);\n\n\tret = exynos_add_pcie_port(ep, pdev);\n\tif (ret < 0)\n\t\tgoto fail_probe;\n\n\treturn 0;\n\nfail_probe:\n\tphy_exit(ep->phy);\n\texynos_pcie_deinit_clk_resources(ep);\n\tregulator_bulk_disable(ARRAY_SIZE(ep->supplies), ep->supplies);\n\n\treturn ret;\n}\n\nstatic int exynos_pcie_remove(struct platform_device *pdev)\n{\n\tstruct exynos_pcie *ep = platform_get_drvdata(pdev);\n\n\tdw_pcie_host_deinit(&ep->pci.pp);\n\texynos_pcie_assert_core_reset(ep);\n\tphy_power_off(ep->phy);\n\tphy_exit(ep->phy);\n\texynos_pcie_deinit_clk_resources(ep);\n\tregulator_bulk_disable(ARRAY_SIZE(ep->supplies), ep->supplies);\n\n\treturn 0;\n}\n\nstatic int exynos_pcie_suspend_noirq(struct device *dev)\n{\n\tstruct exynos_pcie *ep = dev_get_drvdata(dev);\n\n\texynos_pcie_assert_core_reset(ep);\n\tphy_power_off(ep->phy);\n\tphy_exit(ep->phy);\n\tregulator_bulk_disable(ARRAY_SIZE(ep->supplies), ep->supplies);\n\n\treturn 0;\n}\n\nstatic int exynos_pcie_resume_noirq(struct device *dev)\n{\n\tstruct exynos_pcie *ep = dev_get_drvdata(dev);\n\tstruct dw_pcie *pci = &ep->pci;\n\tstruct dw_pcie_rp *pp = &pci->pp;\n\tint ret;\n\n\tret = regulator_bulk_enable(ARRAY_SIZE(ep->supplies), ep->supplies);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\texynos_pcie_host_init(pp);\n\tdw_pcie_setup_rc(pp);\n\texynos_pcie_start_link(pci);\n\treturn dw_pcie_wait_for_link(pci);\n}\n\nstatic const struct dev_pm_ops exynos_pcie_pm_ops = {\n\tNOIRQ_SYSTEM_SLEEP_PM_OPS(exynos_pcie_suspend_noirq,\n\t\t\t\t  exynos_pcie_resume_noirq)\n};\n\nstatic const struct of_device_id exynos_pcie_of_match[] = {\n\t{ .compatible = \"samsung,exynos5433-pcie\", },\n\t{ },\n};\n\nstatic struct platform_driver exynos_pcie_driver = {\n\t.probe\t\t= exynos_pcie_probe,\n\t.remove\t\t= exynos_pcie_remove,\n\t.driver = {\n\t\t.name\t= \"exynos-pcie\",\n\t\t.of_match_table = exynos_pcie_of_match,\n\t\t.pm\t\t= &exynos_pcie_pm_ops,\n\t},\n};\nmodule_platform_driver(exynos_pcie_driver);\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DEVICE_TABLE(of, exynos_pcie_of_match);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}