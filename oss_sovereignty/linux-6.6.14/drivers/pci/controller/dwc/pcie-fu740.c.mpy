{
  "module_name": "pcie-fu740.c",
  "hash_id": "f1b10e5d5ac2ef24f879aecef402a059e7ff2647c2d788249a44868f1d5d728c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/controller/dwc/pcie-fu740.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/gpio.h>\n#include <linux/gpio/consumer.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/platform_device.h>\n#include <linux/resource.h>\n#include <linux/types.h>\n#include <linux/interrupt.h>\n#include <linux/iopoll.h>\n#include <linux/reset.h>\n\n#include \"pcie-designware.h\"\n\n#define to_fu740_pcie(x)\tdev_get_drvdata((x)->dev)\n\nstruct fu740_pcie {\n\tstruct dw_pcie pci;\n\tvoid __iomem *mgmt_base;\n\tstruct gpio_desc *reset;\n\tstruct gpio_desc *pwren;\n\tstruct clk *pcie_aux;\n\tstruct reset_control *rst;\n};\n\n#define SIFIVE_DEVICESRESETREG\t\t0x28\n\n#define PCIEX8MGMT_PERST_N\t\t0x0\n#define PCIEX8MGMT_APP_LTSSM_ENABLE\t0x10\n#define PCIEX8MGMT_APP_HOLD_PHY_RST\t0x18\n#define PCIEX8MGMT_DEVICE_TYPE\t\t0x708\n#define PCIEX8MGMT_PHY0_CR_PARA_ADDR\t0x860\n#define PCIEX8MGMT_PHY0_CR_PARA_RD_EN\t0x870\n#define PCIEX8MGMT_PHY0_CR_PARA_RD_DATA\t0x878\n#define PCIEX8MGMT_PHY0_CR_PARA_SEL\t0x880\n#define PCIEX8MGMT_PHY0_CR_PARA_WR_DATA\t0x888\n#define PCIEX8MGMT_PHY0_CR_PARA_WR_EN\t0x890\n#define PCIEX8MGMT_PHY0_CR_PARA_ACK\t0x898\n#define PCIEX8MGMT_PHY1_CR_PARA_ADDR\t0x8a0\n#define PCIEX8MGMT_PHY1_CR_PARA_RD_EN\t0x8b0\n#define PCIEX8MGMT_PHY1_CR_PARA_RD_DATA\t0x8b8\n#define PCIEX8MGMT_PHY1_CR_PARA_SEL\t0x8c0\n#define PCIEX8MGMT_PHY1_CR_PARA_WR_DATA\t0x8c8\n#define PCIEX8MGMT_PHY1_CR_PARA_WR_EN\t0x8d0\n#define PCIEX8MGMT_PHY1_CR_PARA_ACK\t0x8d8\n\n#define PCIEX8MGMT_PHY_CDR_TRACK_EN\tBIT(0)\n#define PCIEX8MGMT_PHY_LOS_THRSHLD\tBIT(5)\n#define PCIEX8MGMT_PHY_TERM_EN\t\tBIT(9)\n#define PCIEX8MGMT_PHY_TERM_ACDC\tBIT(10)\n#define PCIEX8MGMT_PHY_EN\t\tBIT(11)\n#define PCIEX8MGMT_PHY_INIT_VAL\t\t(PCIEX8MGMT_PHY_CDR_TRACK_EN|\\\n\t\t\t\t\t PCIEX8MGMT_PHY_LOS_THRSHLD|\\\n\t\t\t\t\t PCIEX8MGMT_PHY_TERM_EN|\\\n\t\t\t\t\t PCIEX8MGMT_PHY_TERM_ACDC|\\\n\t\t\t\t\t PCIEX8MGMT_PHY_EN)\n\n#define PCIEX8MGMT_PHY_LANEN_DIG_ASIC_RX_OVRD_IN_3\t0x1008\n#define PCIEX8MGMT_PHY_LANE_OFF\t\t0x100\n#define PCIEX8MGMT_PHY_LANE0_BASE\t(PCIEX8MGMT_PHY_LANEN_DIG_ASIC_RX_OVRD_IN_3 + 0x100 * 0)\n#define PCIEX8MGMT_PHY_LANE1_BASE\t(PCIEX8MGMT_PHY_LANEN_DIG_ASIC_RX_OVRD_IN_3 + 0x100 * 1)\n#define PCIEX8MGMT_PHY_LANE2_BASE\t(PCIEX8MGMT_PHY_LANEN_DIG_ASIC_RX_OVRD_IN_3 + 0x100 * 2)\n#define PCIEX8MGMT_PHY_LANE3_BASE\t(PCIEX8MGMT_PHY_LANEN_DIG_ASIC_RX_OVRD_IN_3 + 0x100 * 3)\n\nstatic void fu740_pcie_assert_reset(struct fu740_pcie *afp)\n{\n\t \n\tgpiod_set_value_cansleep(afp->reset, 0);\n\t \n\twritel_relaxed(0x0, afp->mgmt_base + PCIEX8MGMT_PERST_N);\n}\n\nstatic void fu740_pcie_deassert_reset(struct fu740_pcie *afp)\n{\n\t \n\twritel_relaxed(0x1, afp->mgmt_base + PCIEX8MGMT_PERST_N);\n\t \n\tgpiod_set_value_cansleep(afp->reset, 1);\n}\n\nstatic void fu740_pcie_power_on(struct fu740_pcie *afp)\n{\n\tgpiod_set_value_cansleep(afp->pwren, 1);\n\t \n\tmsleep(100);\n}\n\nstatic void fu740_pcie_drive_reset(struct fu740_pcie *afp)\n{\n\tfu740_pcie_assert_reset(afp);\n\tfu740_pcie_power_on(afp);\n\tfu740_pcie_deassert_reset(afp);\n}\n\nstatic void fu740_phyregwrite(const uint8_t phy, const uint16_t addr,\n\t\t\t      const uint16_t wrdata, struct fu740_pcie *afp)\n{\n\tstruct device *dev = afp->pci.dev;\n\tvoid __iomem *phy_cr_para_addr;\n\tvoid __iomem *phy_cr_para_wr_data;\n\tvoid __iomem *phy_cr_para_wr_en;\n\tvoid __iomem *phy_cr_para_ack;\n\tint ret, val;\n\n\t \n\tif (phy) {\n\t\tphy_cr_para_addr = afp->mgmt_base + PCIEX8MGMT_PHY1_CR_PARA_ADDR;\n\t\tphy_cr_para_wr_data = afp->mgmt_base + PCIEX8MGMT_PHY1_CR_PARA_WR_DATA;\n\t\tphy_cr_para_wr_en = afp->mgmt_base + PCIEX8MGMT_PHY1_CR_PARA_WR_EN;\n\t\tphy_cr_para_ack = afp->mgmt_base + PCIEX8MGMT_PHY1_CR_PARA_ACK;\n\t} else {\n\t\tphy_cr_para_addr = afp->mgmt_base + PCIEX8MGMT_PHY0_CR_PARA_ADDR;\n\t\tphy_cr_para_wr_data = afp->mgmt_base + PCIEX8MGMT_PHY0_CR_PARA_WR_DATA;\n\t\tphy_cr_para_wr_en = afp->mgmt_base + PCIEX8MGMT_PHY0_CR_PARA_WR_EN;\n\t\tphy_cr_para_ack = afp->mgmt_base + PCIEX8MGMT_PHY0_CR_PARA_ACK;\n\t}\n\n\twritel_relaxed(addr, phy_cr_para_addr);\n\twritel_relaxed(wrdata, phy_cr_para_wr_data);\n\twritel_relaxed(1, phy_cr_para_wr_en);\n\n\t \n\tret = readl_poll_timeout(phy_cr_para_ack, val, val, 10, 5000);\n\tif (ret)\n\t\tdev_warn(dev, \"Wait for wait_idle state failed!\\n\");\n\n\t \n\twritel_relaxed(0, phy_cr_para_wr_en);\n\n\t \n\tret = readl_poll_timeout(phy_cr_para_ack, val, !val, 10, 5000);\n\tif (ret)\n\t\tdev_warn(dev, \"Wait for !wait_idle state failed!\\n\");\n}\n\nstatic void fu740_pcie_init_phy(struct fu740_pcie *afp)\n{\n\t \n\twritel_relaxed(0x1, afp->mgmt_base + PCIEX8MGMT_PHY0_CR_PARA_SEL);\n\twritel_relaxed(0x1, afp->mgmt_base + PCIEX8MGMT_PHY1_CR_PARA_SEL);\n\n\t \n\tndelay(10);\n\n\t \n\tfu740_phyregwrite(0, PCIEX8MGMT_PHY_LANE0_BASE, PCIEX8MGMT_PHY_INIT_VAL, afp);\n\tfu740_phyregwrite(0, PCIEX8MGMT_PHY_LANE1_BASE, PCIEX8MGMT_PHY_INIT_VAL, afp);\n\tfu740_phyregwrite(0, PCIEX8MGMT_PHY_LANE2_BASE, PCIEX8MGMT_PHY_INIT_VAL, afp);\n\tfu740_phyregwrite(0, PCIEX8MGMT_PHY_LANE3_BASE, PCIEX8MGMT_PHY_INIT_VAL, afp);\n\tfu740_phyregwrite(1, PCIEX8MGMT_PHY_LANE0_BASE, PCIEX8MGMT_PHY_INIT_VAL, afp);\n\tfu740_phyregwrite(1, PCIEX8MGMT_PHY_LANE1_BASE, PCIEX8MGMT_PHY_INIT_VAL, afp);\n\tfu740_phyregwrite(1, PCIEX8MGMT_PHY_LANE2_BASE, PCIEX8MGMT_PHY_INIT_VAL, afp);\n\tfu740_phyregwrite(1, PCIEX8MGMT_PHY_LANE3_BASE, PCIEX8MGMT_PHY_INIT_VAL, afp);\n}\n\nstatic int fu740_pcie_start_link(struct dw_pcie *pci)\n{\n\tstruct device *dev = pci->dev;\n\tstruct fu740_pcie *afp = dev_get_drvdata(dev);\n\tu8 cap_exp = dw_pcie_find_capability(pci, PCI_CAP_ID_EXP);\n\tint ret;\n\tu32 orig, tmp;\n\n\t \n\tdev_dbg(dev, \"cap_exp at %x\\n\", cap_exp);\n\tdw_pcie_dbi_ro_wr_en(pci);\n\n\ttmp = dw_pcie_readl_dbi(pci, cap_exp + PCI_EXP_LNKCAP);\n\torig = tmp & PCI_EXP_LNKCAP_SLS;\n\ttmp &= ~PCI_EXP_LNKCAP_SLS;\n\ttmp |= PCI_EXP_LNKCAP_SLS_2_5GB;\n\tdw_pcie_writel_dbi(pci, cap_exp + PCI_EXP_LNKCAP, tmp);\n\n\t \n\twritel_relaxed(0x1, afp->mgmt_base + PCIEX8MGMT_APP_LTSSM_ENABLE);\n\n\tret = dw_pcie_wait_for_link(pci);\n\tif (ret) {\n\t\tdev_err(dev, \"error: link did not start\\n\");\n\t\tgoto err;\n\t}\n\n\ttmp = dw_pcie_readl_dbi(pci, cap_exp + PCI_EXP_LNKCAP);\n\tif ((tmp & PCI_EXP_LNKCAP_SLS) != orig) {\n\t\tdev_dbg(dev, \"changing speed back to original\\n\");\n\n\t\ttmp &= ~PCI_EXP_LNKCAP_SLS;\n\t\ttmp |= orig;\n\t\tdw_pcie_writel_dbi(pci, cap_exp + PCI_EXP_LNKCAP, tmp);\n\n\t\ttmp = dw_pcie_readl_dbi(pci, PCIE_LINK_WIDTH_SPEED_CONTROL);\n\t\ttmp |= PORT_LOGIC_SPEED_CHANGE;\n\t\tdw_pcie_writel_dbi(pci, PCIE_LINK_WIDTH_SPEED_CONTROL, tmp);\n\n\t\tret = dw_pcie_wait_for_link(pci);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"error: link did not start at new speed\\n\");\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tret = 0;\nerr:\n\tWARN_ON(ret);\t \n\tdw_pcie_dbi_ro_wr_dis(pci);\n\treturn ret;\n}\n\nstatic int fu740_pcie_host_init(struct dw_pcie_rp *pp)\n{\n\tstruct dw_pcie *pci = to_dw_pcie_from_pp(pp);\n\tstruct fu740_pcie *afp = to_fu740_pcie(pci);\n\tstruct device *dev = pci->dev;\n\tint ret;\n\n\t \n\tfu740_pcie_drive_reset(afp);\n\n\t \n\tret = clk_prepare_enable(afp->pcie_aux);\n\tif (ret) {\n\t\tdev_err(dev, \"unable to enable pcie_aux clock\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\twritel_relaxed(0x1, afp->mgmt_base + PCIEX8MGMT_APP_HOLD_PHY_RST);\n\n\t \n\tret = reset_control_deassert(afp->rst);\n\tif (ret) {\n\t\tdev_err(dev, \"unable to deassert pcie_power_up_rst_n\\n\");\n\t\treturn ret;\n\t}\n\n\tfu740_pcie_init_phy(afp);\n\n\t \n\tclk_disable_unprepare(afp->pcie_aux);\n\t \n\twritel_relaxed(0x0, afp->mgmt_base + PCIEX8MGMT_APP_HOLD_PHY_RST);\n\t \n\tclk_prepare_enable(afp->pcie_aux);\n\t \n\twritel_relaxed(0x4, afp->mgmt_base + PCIEX8MGMT_DEVICE_TYPE);\n\n\treturn 0;\n}\n\nstatic const struct dw_pcie_host_ops fu740_pcie_host_ops = {\n\t.host_init = fu740_pcie_host_init,\n};\n\nstatic const struct dw_pcie_ops dw_pcie_ops = {\n\t.start_link = fu740_pcie_start_link,\n};\n\nstatic int fu740_pcie_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct dw_pcie *pci;\n\tstruct fu740_pcie *afp;\n\n\tafp = devm_kzalloc(dev, sizeof(*afp), GFP_KERNEL);\n\tif (!afp)\n\t\treturn -ENOMEM;\n\tpci = &afp->pci;\n\tpci->dev = dev;\n\tpci->ops = &dw_pcie_ops;\n\tpci->pp.ops = &fu740_pcie_host_ops;\n\tpci->pp.num_vectors = MAX_MSI_IRQS;\n\n\t \n\tafp->mgmt_base = devm_platform_ioremap_resource_byname(pdev, \"mgmt\");\n\tif (IS_ERR(afp->mgmt_base))\n\t\treturn PTR_ERR(afp->mgmt_base);\n\n\t \n\tafp->reset = devm_gpiod_get_optional(dev, \"reset\", GPIOD_OUT_LOW);\n\tif (IS_ERR(afp->reset))\n\t\treturn dev_err_probe(dev, PTR_ERR(afp->reset), \"unable to get reset-gpios\\n\");\n\n\tafp->pwren = devm_gpiod_get_optional(dev, \"pwren\", GPIOD_OUT_LOW);\n\tif (IS_ERR(afp->pwren))\n\t\treturn dev_err_probe(dev, PTR_ERR(afp->pwren), \"unable to get pwren-gpios\\n\");\n\n\t \n\tafp->pcie_aux = devm_clk_get(dev, \"pcie_aux\");\n\tif (IS_ERR(afp->pcie_aux))\n\t\treturn dev_err_probe(dev, PTR_ERR(afp->pcie_aux),\n\t\t\t\t\t     \"pcie_aux clock source missing or invalid\\n\");\n\n\t \n\tafp->rst = devm_reset_control_get_exclusive(dev, NULL);\n\tif (IS_ERR(afp->rst))\n\t\treturn dev_err_probe(dev, PTR_ERR(afp->rst), \"unable to get reset\\n\");\n\n\tplatform_set_drvdata(pdev, afp);\n\n\treturn dw_pcie_host_init(&pci->pp);\n}\n\nstatic void fu740_pcie_shutdown(struct platform_device *pdev)\n{\n\tstruct fu740_pcie *afp = platform_get_drvdata(pdev);\n\n\t \n\tfu740_pcie_assert_reset(afp);\n}\n\nstatic const struct of_device_id fu740_pcie_of_match[] = {\n\t{ .compatible = \"sifive,fu740-pcie\", },\n\t{},\n};\n\nstatic struct platform_driver fu740_pcie_driver = {\n\t.driver = {\n\t\t   .name = \"fu740-pcie\",\n\t\t   .of_match_table = fu740_pcie_of_match,\n\t\t   .suppress_bind_attrs = true,\n\t},\n\t.probe = fu740_pcie_probe,\n\t.shutdown = fu740_pcie_shutdown,\n};\n\nbuiltin_platform_driver(fu740_pcie_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}