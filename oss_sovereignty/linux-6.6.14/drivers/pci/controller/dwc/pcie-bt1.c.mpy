{
  "module_name": "pcie-bt1.c",
  "hash_id": "3448aad641dedb9623cf6329fbef120b2b20552af71409bab642f8c7ed937b32",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/controller/dwc/pcie-bt1.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/bits.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/kernel.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/reset.h>\n#include <linux/types.h>\n\n#include \"pcie-designware.h\"\n\n \n#define BT1_CCU_PCIE_CLKC\t\t\t0x140\n#define BT1_CCU_PCIE_REQ_PCS_CLK\t\tBIT(16)\n#define BT1_CCU_PCIE_REQ_MAC_CLK\t\tBIT(17)\n#define BT1_CCU_PCIE_REQ_PIPE_CLK\t\tBIT(18)\n\n#define BT1_CCU_PCIE_RSTC\t\t\t0x144\n#define BT1_CCU_PCIE_REQ_LINK_RST\t\tBIT(13)\n#define BT1_CCU_PCIE_REQ_SMLH_RST\t\tBIT(14)\n#define BT1_CCU_PCIE_REQ_PHY_RST\t\tBIT(16)\n#define BT1_CCU_PCIE_REQ_CORE_RST\t\tBIT(24)\n#define BT1_CCU_PCIE_REQ_STICKY_RST\t\tBIT(26)\n#define BT1_CCU_PCIE_REQ_NSTICKY_RST\t\tBIT(27)\n\n#define BT1_CCU_PCIE_PMSC\t\t\t0x148\n#define BT1_CCU_PCIE_LTSSM_STATE_MASK\t\tGENMASK(5, 0)\n#define BT1_CCU_PCIE_LTSSM_DET_QUIET\t\t0x00\n#define BT1_CCU_PCIE_LTSSM_DET_ACT\t\t0x01\n#define BT1_CCU_PCIE_LTSSM_POLL_ACT\t\t0x02\n#define BT1_CCU_PCIE_LTSSM_POLL_COMP\t\t0x03\n#define BT1_CCU_PCIE_LTSSM_POLL_CONF\t\t0x04\n#define BT1_CCU_PCIE_LTSSM_PRE_DET_QUIET\t0x05\n#define BT1_CCU_PCIE_LTSSM_DET_WAIT\t\t0x06\n#define BT1_CCU_PCIE_LTSSM_CFG_LNKWD_START\t0x07\n#define BT1_CCU_PCIE_LTSSM_CFG_LNKWD_ACEPT\t0x08\n#define BT1_CCU_PCIE_LTSSM_CFG_LNNUM_WAIT\t0x09\n#define BT1_CCU_PCIE_LTSSM_CFG_LNNUM_ACEPT\t0x0a\n#define BT1_CCU_PCIE_LTSSM_CFG_COMPLETE\t\t0x0b\n#define BT1_CCU_PCIE_LTSSM_CFG_IDLE\t\t0x0c\n#define BT1_CCU_PCIE_LTSSM_RCVR_LOCK\t\t0x0d\n#define BT1_CCU_PCIE_LTSSM_RCVR_SPEED\t\t0x0e\n#define BT1_CCU_PCIE_LTSSM_RCVR_RCVRCFG\t\t0x0f\n#define BT1_CCU_PCIE_LTSSM_RCVR_IDLE\t\t0x10\n#define BT1_CCU_PCIE_LTSSM_L0\t\t\t0x11\n#define BT1_CCU_PCIE_LTSSM_L0S\t\t\t0x12\n#define BT1_CCU_PCIE_LTSSM_L123_SEND_IDLE\t0x13\n#define BT1_CCU_PCIE_LTSSM_L1_IDLE\t\t0x14\n#define BT1_CCU_PCIE_LTSSM_L2_IDLE\t\t0x15\n#define BT1_CCU_PCIE_LTSSM_L2_WAKE\t\t0x16\n#define BT1_CCU_PCIE_LTSSM_DIS_ENTRY\t\t0x17\n#define BT1_CCU_PCIE_LTSSM_DIS_IDLE\t\t0x18\n#define BT1_CCU_PCIE_LTSSM_DISABLE\t\t0x19\n#define BT1_CCU_PCIE_LTSSM_LPBK_ENTRY\t\t0x1a\n#define BT1_CCU_PCIE_LTSSM_LPBK_ACTIVE\t\t0x1b\n#define BT1_CCU_PCIE_LTSSM_LPBK_EXIT\t\t0x1c\n#define BT1_CCU_PCIE_LTSSM_LPBK_EXIT_TOUT\t0x1d\n#define BT1_CCU_PCIE_LTSSM_HOT_RST_ENTRY\t0x1e\n#define BT1_CCU_PCIE_LTSSM_HOT_RST\t\t0x1f\n#define BT1_CCU_PCIE_LTSSM_RCVR_EQ0\t\t0x20\n#define BT1_CCU_PCIE_LTSSM_RCVR_EQ1\t\t0x21\n#define BT1_CCU_PCIE_LTSSM_RCVR_EQ2\t\t0x22\n#define BT1_CCU_PCIE_LTSSM_RCVR_EQ3\t\t0x23\n#define BT1_CCU_PCIE_SMLH_LINKUP\t\tBIT(6)\n#define BT1_CCU_PCIE_RDLH_LINKUP\t\tBIT(7)\n#define BT1_CCU_PCIE_PM_LINKSTATE_L0S\t\tBIT(8)\n#define BT1_CCU_PCIE_PM_LINKSTATE_L1\t\tBIT(9)\n#define BT1_CCU_PCIE_PM_LINKSTATE_L2\t\tBIT(10)\n#define BT1_CCU_PCIE_L1_PENDING\t\t\tBIT(12)\n#define BT1_CCU_PCIE_REQ_EXIT_L1\t\tBIT(14)\n#define BT1_CCU_PCIE_LTSSM_RCVR_EQ\t\tBIT(15)\n#define BT1_CCU_PCIE_PM_DSTAT_MASK\t\tGENMASK(18, 16)\n#define BT1_CCU_PCIE_PM_PME_EN\t\t\tBIT(20)\n#define BT1_CCU_PCIE_PM_PME_STATUS\t\tBIT(21)\n#define BT1_CCU_PCIE_AUX_PM_EN\t\t\tBIT(22)\n#define BT1_CCU_PCIE_AUX_PWR_DET\t\tBIT(23)\n#define BT1_CCU_PCIE_WAKE_DET\t\t\tBIT(24)\n#define BT1_CCU_PCIE_TURNOFF_REQ\t\tBIT(30)\n#define BT1_CCU_PCIE_TURNOFF_ACK\t\tBIT(31)\n\n#define BT1_CCU_PCIE_GENC\t\t\t0x14c\n#define BT1_CCU_PCIE_LTSSM_EN\t\t\tBIT(1)\n#define BT1_CCU_PCIE_DBI2_MODE\t\t\tBIT(2)\n#define BT1_CCU_PCIE_MGMT_EN\t\t\tBIT(3)\n#define BT1_CCU_PCIE_RXLANE_FLIP_EN\t\tBIT(16)\n#define BT1_CCU_PCIE_TXLANE_FLIP_EN\t\tBIT(17)\n#define BT1_CCU_PCIE_SLV_XFER_PEND\t\tBIT(24)\n#define BT1_CCU_PCIE_RCV_XFER_PEND\t\tBIT(25)\n#define BT1_CCU_PCIE_DBI_XFER_PEND\t\tBIT(26)\n#define BT1_CCU_PCIE_DMA_XFER_PEND\t\tBIT(27)\n\n#define BT1_CCU_PCIE_LTSSM_LINKUP(_pmsc) \\\n({ \\\n\tint __state = FIELD_GET(BT1_CCU_PCIE_LTSSM_STATE_MASK, _pmsc); \\\n\t__state >= BT1_CCU_PCIE_LTSSM_L0 && __state <= BT1_CCU_PCIE_LTSSM_L2_WAKE; \\\n})\n\n \n#define BT1_PCIE_AXI2MGM_LANENUM\t\t0xd04\n#define BT1_PCIE_AXI2MGM_LANESEL_MASK\t\tGENMASK(3, 0)\n\n#define BT1_PCIE_AXI2MGM_ADDRCTL\t\t0xd08\n#define BT1_PCIE_AXI2MGM_PHYREG_ADDR_MASK\tGENMASK(20, 0)\n#define BT1_PCIE_AXI2MGM_READ_FLAG\t\tBIT(29)\n#define BT1_PCIE_AXI2MGM_DONE\t\t\tBIT(30)\n#define BT1_PCIE_AXI2MGM_BUSY\t\t\tBIT(31)\n\n#define BT1_PCIE_AXI2MGM_WRITEDATA\t\t0xd0c\n#define BT1_PCIE_AXI2MGM_WDATA\t\t\tGENMASK(15, 0)\n\n#define BT1_PCIE_AXI2MGM_READDATA\t\t0xd10\n#define BT1_PCIE_AXI2MGM_RDATA\t\t\tGENMASK(15, 0)\n\n \n#define BT1_PCIE_NUM_APP_CLKS\t\t\tARRAY_SIZE(bt1_pcie_app_clks)\n#define BT1_PCIE_NUM_CORE_CLKS\t\t\tARRAY_SIZE(bt1_pcie_core_clks)\n#define BT1_PCIE_NUM_APP_RSTS\t\t\tARRAY_SIZE(bt1_pcie_app_rsts)\n#define BT1_PCIE_NUM_CORE_RSTS\t\t\tARRAY_SIZE(bt1_pcie_core_rsts)\n\n \n#define BT1_PCIE_RST_DELAY_MS\t\t\t100\n#define BT1_PCIE_RUN_DELAY_US\t\t\t100\n#define BT1_PCIE_REQ_DELAY_US\t\t\t1\n#define BT1_PCIE_REQ_TIMEOUT_US\t\t\t1000\n#define BT1_PCIE_LNK_DELAY_US\t\t\t1000\n#define BT1_PCIE_LNK_TIMEOUT_US\t\t\t1000000\n\nstatic const enum dw_pcie_app_clk bt1_pcie_app_clks[] = {\n\tDW_PCIE_DBI_CLK, DW_PCIE_MSTR_CLK, DW_PCIE_SLV_CLK,\n};\n\nstatic const enum dw_pcie_core_clk bt1_pcie_core_clks[] = {\n\tDW_PCIE_REF_CLK,\n};\n\nstatic const enum dw_pcie_app_rst bt1_pcie_app_rsts[] = {\n\tDW_PCIE_MSTR_RST, DW_PCIE_SLV_RST,\n};\n\nstatic const enum dw_pcie_core_rst bt1_pcie_core_rsts[] = {\n\tDW_PCIE_NON_STICKY_RST, DW_PCIE_STICKY_RST, DW_PCIE_CORE_RST,\n\tDW_PCIE_PIPE_RST, DW_PCIE_PHY_RST, DW_PCIE_HOT_RST, DW_PCIE_PWR_RST,\n};\n\nstruct bt1_pcie {\n\tstruct dw_pcie dw;\n\tstruct platform_device *pdev;\n\tstruct regmap *sys_regs;\n};\n#define to_bt1_pcie(_dw) container_of(_dw, struct bt1_pcie, dw)\n\n \nstatic int bt1_pcie_read_mmio(void __iomem *addr, int size, u32 *val)\n{\n\tunsigned int ofs = (uintptr_t)addr & 0x3;\n\n\tif (!IS_ALIGNED((uintptr_t)addr, size))\n\t\treturn -EINVAL;\n\n\t*val = readl(addr - ofs) >> ofs * BITS_PER_BYTE;\n\tif (size == 4) {\n\t\treturn 0;\n\t} else if (size == 2) {\n\t\t*val &= 0xffff;\n\t\treturn 0;\n\t} else if (size == 1) {\n\t\t*val &= 0xff;\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int bt1_pcie_write_mmio(void __iomem *addr, int size, u32 val)\n{\n\tunsigned int ofs = (uintptr_t)addr & 0x3;\n\tu32 tmp, mask;\n\n\tif (!IS_ALIGNED((uintptr_t)addr, size))\n\t\treturn -EINVAL;\n\n\tif (size == 4) {\n\t\twritel(val, addr);\n\t\treturn 0;\n\t} else if (size == 2 || size == 1) {\n\t\tmask = GENMASK(size * BITS_PER_BYTE - 1, 0);\n\t\ttmp = readl(addr - ofs) & ~(mask << ofs * BITS_PER_BYTE);\n\t\ttmp |= (val & mask) << ofs * BITS_PER_BYTE;\n\t\twritel(tmp, addr - ofs);\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic u32 bt1_pcie_read_dbi(struct dw_pcie *pci, void __iomem *base, u32 reg,\n\t\t\t     size_t size)\n{\n\tint ret;\n\tu32 val;\n\n\tret = bt1_pcie_read_mmio(base + reg, size, &val);\n\tif (ret) {\n\t\tdev_err(pci->dev, \"Read DBI address failed\\n\");\n\t\treturn ~0U;\n\t}\n\n\treturn val;\n}\n\nstatic void bt1_pcie_write_dbi(struct dw_pcie *pci, void __iomem *base, u32 reg,\n\t\t\t       size_t size, u32 val)\n{\n\tint ret;\n\n\tret = bt1_pcie_write_mmio(base + reg, size, val);\n\tif (ret)\n\t\tdev_err(pci->dev, \"Write DBI address failed\\n\");\n}\n\nstatic void bt1_pcie_write_dbi2(struct dw_pcie *pci, void __iomem *base, u32 reg,\n\t\t\t\tsize_t size, u32 val)\n{\n\tstruct bt1_pcie *btpci = to_bt1_pcie(pci);\n\tint ret;\n\n\tregmap_update_bits(btpci->sys_regs, BT1_CCU_PCIE_GENC,\n\t\t\t   BT1_CCU_PCIE_DBI2_MODE, BT1_CCU_PCIE_DBI2_MODE);\n\n\tret = bt1_pcie_write_mmio(base + reg, size, val);\n\tif (ret)\n\t\tdev_err(pci->dev, \"Write DBI2 address failed\\n\");\n\n\tregmap_update_bits(btpci->sys_regs, BT1_CCU_PCIE_GENC,\n\t\t\t   BT1_CCU_PCIE_DBI2_MODE, 0);\n}\n\nstatic int bt1_pcie_start_link(struct dw_pcie *pci)\n{\n\tstruct bt1_pcie *btpci = to_bt1_pcie(pci);\n\tu32 val;\n\tint ret;\n\n\t \n\tregmap_update_bits(btpci->sys_regs, BT1_CCU_PCIE_GENC,\n\t\t\t   BT1_CCU_PCIE_LTSSM_EN, BT1_CCU_PCIE_LTSSM_EN);\n\n\tret = regmap_read_poll_timeout(btpci->sys_regs, BT1_CCU_PCIE_PMSC, val,\n\t\t\t\t       (val & BT1_CCU_PCIE_SMLH_LINKUP),\n\t\t\t\t       BT1_PCIE_LNK_DELAY_US, BT1_PCIE_LNK_TIMEOUT_US);\n\tif (ret) {\n\t\tdev_err(pci->dev, \"LTSSM failed to set PHY link up\\n\");\n\t\treturn ret;\n\t}\n\n\tret = regmap_read_poll_timeout(btpci->sys_regs, BT1_CCU_PCIE_PMSC, val,\n\t\t\t\t       (val & BT1_CCU_PCIE_RDLH_LINKUP),\n\t\t\t\t       BT1_PCIE_LNK_DELAY_US, BT1_PCIE_LNK_TIMEOUT_US);\n\tif (ret) {\n\t\tdev_err(pci->dev, \"LTSSM failed to set data link up\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tval = dw_pcie_readl_dbi(pci, PCIE_LINK_WIDTH_SPEED_CONTROL);\n\tval |= PORT_LOGIC_SPEED_CHANGE;\n\tdw_pcie_writel_dbi(pci, PCIE_LINK_WIDTH_SPEED_CONTROL, val);\n\n\tret = regmap_read_poll_timeout(btpci->sys_regs, BT1_CCU_PCIE_PMSC, val,\n\t\t\t\t       BT1_CCU_PCIE_LTSSM_LINKUP(val),\n\t\t\t\t       BT1_PCIE_LNK_DELAY_US, BT1_PCIE_LNK_TIMEOUT_US);\n\tif (ret)\n\t\tdev_err(pci->dev, \"LTSSM failed to get into L0 state\\n\");\n\n\treturn ret;\n}\n\nstatic void bt1_pcie_stop_link(struct dw_pcie *pci)\n{\n\tstruct bt1_pcie *btpci = to_bt1_pcie(pci);\n\n\tregmap_update_bits(btpci->sys_regs, BT1_CCU_PCIE_GENC,\n\t\t\t   BT1_CCU_PCIE_LTSSM_EN, 0);\n}\n\nstatic const struct dw_pcie_ops bt1_pcie_ops = {\n\t.read_dbi = bt1_pcie_read_dbi,\n\t.write_dbi = bt1_pcie_write_dbi,\n\t.write_dbi2 = bt1_pcie_write_dbi2,\n\t.start_link = bt1_pcie_start_link,\n\t.stop_link = bt1_pcie_stop_link,\n};\n\nstatic struct pci_ops bt1_pci_ops = {\n\t.map_bus = dw_pcie_own_conf_map_bus,\n\t.read = pci_generic_config_read32,\n\t.write = pci_generic_config_write32,\n};\n\nstatic int bt1_pcie_get_resources(struct bt1_pcie *btpci)\n{\n\tstruct device *dev = btpci->dw.dev;\n\tint i;\n\n\t \n\tbtpci->dw.pp.bridge->ops = &bt1_pci_ops;\n\n\t \n\tbtpci->sys_regs =\n\t\tsyscon_regmap_lookup_by_phandle(dev->of_node, \"baikal,bt1-syscon\");\n\tif (IS_ERR(btpci->sys_regs))\n\t\treturn dev_err_probe(dev, PTR_ERR(btpci->sys_regs),\n\t\t\t\t     \"Failed to get syscon\\n\");\n\n\t \n\tfor (i = 0; i < BT1_PCIE_NUM_APP_CLKS; i++) {\n\t\tif (!btpci->dw.app_clks[bt1_pcie_app_clks[i]].clk) {\n\t\t\tdev_err(dev, \"App clocks set is incomplete\\n\");\n\t\t\treturn -ENOENT;\n\t\t}\n\t}\n\n\tfor (i = 0; i < BT1_PCIE_NUM_CORE_CLKS; i++) {\n\t\tif (!btpci->dw.core_clks[bt1_pcie_core_clks[i]].clk) {\n\t\t\tdev_err(dev, \"Core clocks set is incomplete\\n\");\n\t\t\treturn -ENOENT;\n\t\t}\n\t}\n\n\tfor (i = 0; i < BT1_PCIE_NUM_APP_RSTS; i++) {\n\t\tif (!btpci->dw.app_rsts[bt1_pcie_app_rsts[i]].rstc) {\n\t\t\tdev_err(dev, \"App resets set is incomplete\\n\");\n\t\t\treturn -ENOENT;\n\t\t}\n\t}\n\n\tfor (i = 0; i < BT1_PCIE_NUM_CORE_RSTS; i++) {\n\t\tif (!btpci->dw.core_rsts[bt1_pcie_core_rsts[i]].rstc) {\n\t\t\tdev_err(dev, \"Core resets set is incomplete\\n\");\n\t\t\treturn -ENOENT;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void bt1_pcie_full_stop_bus(struct bt1_pcie *btpci, bool init)\n{\n\tstruct device *dev = btpci->dw.dev;\n\tstruct dw_pcie *pci = &btpci->dw;\n\tint ret;\n\n\t \n\tregmap_update_bits(btpci->sys_regs, BT1_CCU_PCIE_GENC,\n\t\t\t   BT1_CCU_PCIE_LTSSM_EN, 0);\n\n\t \n\tret = reset_control_bulk_assert(DW_PCIE_NUM_CORE_RSTS, pci->core_rsts);\n\tif (ret)\n\t\tdev_err(dev, \"Failed to assert core resets\\n\");\n\n\t \n\tif (!init) {\n\t\tclk_bulk_disable_unprepare(DW_PCIE_NUM_CORE_CLKS, pci->core_clks);\n\n\t\tclk_bulk_disable_unprepare(DW_PCIE_NUM_APP_CLKS, pci->app_clks);\n\t}\n\n\t \n\tgpiod_set_value_cansleep(pci->pe_rst, 1);\n\n\t \n\tmsleep(BT1_PCIE_RST_DELAY_MS);\n}\n\n \nstatic int bt1_pcie_cold_start_bus(struct bt1_pcie *btpci)\n{\n\tstruct device *dev = btpci->dw.dev;\n\tstruct dw_pcie *pci = &btpci->dw;\n\tu32 val;\n\tint ret;\n\n\t \n\tret = reset_control_deassert(pci->core_rsts[DW_PCIE_PWR_RST].rstc);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to deassert PHY reset\\n\");\n\t\treturn ret;\n\t}\n\n\tret = reset_control_deassert(pci->core_rsts[DW_PCIE_HOT_RST].rstc);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to deassert hot reset\\n\");\n\t\tgoto err_assert_pwr_rst;\n\t}\n\n\t \n\tret = regmap_read_poll_timeout(btpci->sys_regs, BT1_CCU_PCIE_RSTC, val,\n\t\t\t\t       !(val & BT1_CCU_PCIE_REQ_PHY_RST),\n\t\t\t\t       BT1_PCIE_REQ_DELAY_US, BT1_PCIE_REQ_TIMEOUT_US);\n\tif (ret) {\n\t\tdev_err(dev, \"Timed out waiting for PM to stop PHY resetting\\n\");\n\t\tgoto err_assert_hot_rst;\n\t}\n\n\tret = reset_control_deassert(pci->core_rsts[DW_PCIE_PHY_RST].rstc);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to deassert PHY reset\\n\");\n\t\tgoto err_assert_hot_rst;\n\t}\n\n\t \n\tret = clk_bulk_prepare_enable(DW_PCIE_NUM_APP_CLKS, pci->app_clks);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to enable app clocks\\n\");\n\t\tgoto err_assert_phy_rst;\n\t}\n\n\tret = clk_bulk_prepare_enable(DW_PCIE_NUM_CORE_CLKS, pci->core_clks);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to enable ref clocks\\n\");\n\t\tgoto err_disable_app_clk;\n\t}\n\n\t \n\tret = regmap_read_poll_timeout(btpci->sys_regs, BT1_CCU_PCIE_RSTC, val,\n\t\t\t\t       !(val & BT1_CCU_PCIE_REQ_CORE_RST),\n\t\t\t\t       BT1_PCIE_REQ_DELAY_US, BT1_PCIE_REQ_TIMEOUT_US);\n\tif (ret) {\n\t\tdev_err(dev, \"Timed out waiting for PM to stop core resetting\\n\");\n\t\tgoto err_disable_core_clk;\n\t}\n\n\t \n\tret = reset_control_deassert(pci->core_rsts[DW_PCIE_PIPE_RST].rstc);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to deassert PIPE reset\\n\");\n\t\tgoto err_disable_core_clk;\n\t}\n\n\tret = reset_control_deassert(pci->core_rsts[DW_PCIE_CORE_RST].rstc);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to deassert core reset\\n\");\n\t\tgoto err_assert_pipe_rst;\n\t}\n\n\t \n\tret = reset_control_bulk_reset(DW_PCIE_NUM_APP_RSTS, pci->app_rsts);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to reset app domain\\n\");\n\t\tgoto err_assert_core_rst;\n\t}\n\n\t \n\tret = reset_control_deassert(pci->core_rsts[DW_PCIE_STICKY_RST].rstc);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to deassert sticky reset\\n\");\n\t\tgoto err_assert_core_rst;\n\t}\n\n\tret = reset_control_deassert(pci->core_rsts[DW_PCIE_NON_STICKY_RST].rstc);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to deassert non-sticky reset\\n\");\n\t\tgoto err_assert_sticky_rst;\n\t}\n\n\t \n\tgpiod_set_value_cansleep(pci->pe_rst, 0);\n\n\t \n\tusleep_range(BT1_PCIE_RUN_DELAY_US, BT1_PCIE_RUN_DELAY_US + 100);\n\n\treturn 0;\n\nerr_assert_sticky_rst:\n\treset_control_assert(pci->core_rsts[DW_PCIE_STICKY_RST].rstc);\n\nerr_assert_core_rst:\n\treset_control_assert(pci->core_rsts[DW_PCIE_CORE_RST].rstc);\n\nerr_assert_pipe_rst:\n\treset_control_assert(pci->core_rsts[DW_PCIE_PIPE_RST].rstc);\n\nerr_disable_core_clk:\n\tclk_bulk_disable_unprepare(DW_PCIE_NUM_CORE_CLKS, pci->core_clks);\n\nerr_disable_app_clk:\n\tclk_bulk_disable_unprepare(DW_PCIE_NUM_APP_CLKS, pci->app_clks);\n\nerr_assert_phy_rst:\n\treset_control_assert(pci->core_rsts[DW_PCIE_PHY_RST].rstc);\n\nerr_assert_hot_rst:\n\treset_control_assert(pci->core_rsts[DW_PCIE_HOT_RST].rstc);\n\nerr_assert_pwr_rst:\n\treset_control_assert(pci->core_rsts[DW_PCIE_PWR_RST].rstc);\n\n\treturn ret;\n}\n\nstatic int bt1_pcie_host_init(struct dw_pcie_rp *pp)\n{\n\tstruct dw_pcie *pci = to_dw_pcie_from_pp(pp);\n\tstruct bt1_pcie *btpci = to_bt1_pcie(pci);\n\tint ret;\n\n\tret = bt1_pcie_get_resources(btpci);\n\tif (ret)\n\t\treturn ret;\n\n\tbt1_pcie_full_stop_bus(btpci, true);\n\n\treturn bt1_pcie_cold_start_bus(btpci);\n}\n\nstatic void bt1_pcie_host_deinit(struct dw_pcie_rp *pp)\n{\n\tstruct dw_pcie *pci = to_dw_pcie_from_pp(pp);\n\tstruct bt1_pcie *btpci = to_bt1_pcie(pci);\n\n\tbt1_pcie_full_stop_bus(btpci, false);\n}\n\nstatic const struct dw_pcie_host_ops bt1_pcie_host_ops = {\n\t.host_init = bt1_pcie_host_init,\n\t.host_deinit = bt1_pcie_host_deinit,\n};\n\nstatic struct bt1_pcie *bt1_pcie_create_data(struct platform_device *pdev)\n{\n\tstruct bt1_pcie *btpci;\n\n\tbtpci = devm_kzalloc(&pdev->dev, sizeof(*btpci), GFP_KERNEL);\n\tif (!btpci)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tbtpci->pdev = pdev;\n\n\tplatform_set_drvdata(pdev, btpci);\n\n\treturn btpci;\n}\n\nstatic int bt1_pcie_add_port(struct bt1_pcie *btpci)\n{\n\tstruct device *dev = &btpci->pdev->dev;\n\tint ret;\n\n\tret = dma_set_mask_and_coherent(dev, DMA_BIT_MASK(64));\n\tif (ret)\n\t\treturn ret;\n\n\tbtpci->dw.version = DW_PCIE_VER_460A;\n\tbtpci->dw.dev = dev;\n\tbtpci->dw.ops = &bt1_pcie_ops;\n\n\tbtpci->dw.pp.num_vectors = MAX_MSI_IRQS;\n\tbtpci->dw.pp.ops = &bt1_pcie_host_ops;\n\n\tdw_pcie_cap_set(&btpci->dw, REQ_RES);\n\n\tret = dw_pcie_host_init(&btpci->dw.pp);\n\n\treturn dev_err_probe(dev, ret, \"Failed to initialize DWC PCIe host\\n\");\n}\n\nstatic void bt1_pcie_del_port(struct bt1_pcie *btpci)\n{\n\tdw_pcie_host_deinit(&btpci->dw.pp);\n}\n\nstatic int bt1_pcie_probe(struct platform_device *pdev)\n{\n\tstruct bt1_pcie *btpci;\n\n\tbtpci = bt1_pcie_create_data(pdev);\n\tif (IS_ERR(btpci))\n\t\treturn PTR_ERR(btpci);\n\n\treturn bt1_pcie_add_port(btpci);\n}\n\nstatic void bt1_pcie_remove(struct platform_device *pdev)\n{\n\tstruct bt1_pcie *btpci = platform_get_drvdata(pdev);\n\n\tbt1_pcie_del_port(btpci);\n}\n\nstatic const struct of_device_id bt1_pcie_of_match[] = {\n\t{ .compatible = \"baikal,bt1-pcie\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, bt1_pcie_of_match);\n\nstatic struct platform_driver bt1_pcie_driver = {\n\t.probe = bt1_pcie_probe,\n\t.remove_new = bt1_pcie_remove,\n\t.driver = {\n\t\t.name\t= \"bt1-pcie\",\n\t\t.of_match_table = bt1_pcie_of_match,\n\t},\n};\nmodule_platform_driver(bt1_pcie_driver);\n\nMODULE_AUTHOR(\"Serge Semin <Sergey.Semin@baikalelectronics.ru>\");\nMODULE_DESCRIPTION(\"Baikal-T1 PCIe driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}