{
  "module_name": "pcie-intel-gw.c",
  "hash_id": "4c11d08435f35f34296445040cb5130967f41644fa4583e165a21bdacb554a69",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/controller/dwc/pcie-intel-gw.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/gpio/consumer.h>\n#include <linux/iopoll.h>\n#include <linux/mod_devicetable.h>\n#include <linux/pci_regs.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n#include <linux/property.h>\n#include <linux/reset.h>\n\n#include \"../../pci.h\"\n#include \"pcie-designware.h\"\n\n#define PORT_AFR_N_FTS_GEN12_DFT\t(SZ_128 - 1)\n#define PORT_AFR_N_FTS_GEN3\t\t180\n#define PORT_AFR_N_FTS_GEN4\t\t196\n\n \n#define PCIE_APP_CCR\t\t\t0x10\n#define PCIE_APP_CCR_LTSSM_ENABLE\tBIT(0)\n\n#define PCIE_APP_MSG_CR\t\t\t0x30\n#define PCIE_APP_MSG_XMT_PM_TURNOFF\tBIT(0)\n\n#define PCIE_APP_PMC\t\t\t0x44\n#define PCIE_APP_PMC_IN_L2\t\tBIT(20)\n\n#define PCIE_APP_IRNEN\t\t\t0xF4\n#define PCIE_APP_IRNCR\t\t\t0xF8\n#define PCIE_APP_IRN_AER_REPORT\t\tBIT(0)\n#define PCIE_APP_IRN_PME\t\tBIT(2)\n#define PCIE_APP_IRN_RX_VDM_MSG\t\tBIT(4)\n#define PCIE_APP_IRN_PM_TO_ACK\t\tBIT(9)\n#define PCIE_APP_IRN_LINK_AUTO_BW_STAT\tBIT(11)\n#define PCIE_APP_IRN_BW_MGT\t\tBIT(12)\n#define PCIE_APP_IRN_INTA\t\tBIT(13)\n#define PCIE_APP_IRN_INTB\t\tBIT(14)\n#define PCIE_APP_IRN_INTC\t\tBIT(15)\n#define PCIE_APP_IRN_INTD\t\tBIT(16)\n#define PCIE_APP_IRN_MSG_LTR\t\tBIT(18)\n#define PCIE_APP_IRN_SYS_ERR_RC\t\tBIT(29)\n#define PCIE_APP_INTX_OFST\t\t12\n\n#define PCIE_APP_IRN_INT \\\n\t(PCIE_APP_IRN_AER_REPORT | PCIE_APP_IRN_PME | \\\n\tPCIE_APP_IRN_RX_VDM_MSG | PCIE_APP_IRN_SYS_ERR_RC | \\\n\tPCIE_APP_IRN_PM_TO_ACK | PCIE_APP_IRN_MSG_LTR | \\\n\tPCIE_APP_IRN_BW_MGT | PCIE_APP_IRN_LINK_AUTO_BW_STAT | \\\n\tPCIE_APP_IRN_INTA | PCIE_APP_IRN_INTB | \\\n\tPCIE_APP_IRN_INTC | PCIE_APP_IRN_INTD)\n\n#define BUS_IATU_OFFSET\t\t\tSZ_256M\n#define RESET_INTERVAL_MS\t\t100\n\nstruct intel_pcie {\n\tstruct dw_pcie\t\tpci;\n\tvoid __iomem\t\t*app_base;\n\tstruct gpio_desc\t*reset_gpio;\n\tu32\t\t\trst_intrvl;\n\tstruct clk\t\t*core_clk;\n\tstruct reset_control\t*core_rst;\n\tstruct phy\t\t*phy;\n};\n\nstatic void pcie_update_bits(void __iomem *base, u32 ofs, u32 mask, u32 val)\n{\n\tu32 old;\n\n\told = readl(base + ofs);\n\tval = (old & ~mask) | (val & mask);\n\n\tif (val != old)\n\t\twritel(val, base + ofs);\n}\n\nstatic inline void pcie_app_wr(struct intel_pcie *pcie, u32 ofs, u32 val)\n{\n\twritel(val, pcie->app_base + ofs);\n}\n\nstatic void pcie_app_wr_mask(struct intel_pcie *pcie, u32 ofs,\n\t\t\t     u32 mask, u32 val)\n{\n\tpcie_update_bits(pcie->app_base, ofs, mask, val);\n}\n\nstatic inline u32 pcie_rc_cfg_rd(struct intel_pcie *pcie, u32 ofs)\n{\n\treturn dw_pcie_readl_dbi(&pcie->pci, ofs);\n}\n\nstatic inline void pcie_rc_cfg_wr(struct intel_pcie *pcie, u32 ofs, u32 val)\n{\n\tdw_pcie_writel_dbi(&pcie->pci, ofs, val);\n}\n\nstatic void pcie_rc_cfg_wr_mask(struct intel_pcie *pcie, u32 ofs,\n\t\t\t\tu32 mask, u32 val)\n{\n\tpcie_update_bits(pcie->pci.dbi_base, ofs, mask, val);\n}\n\nstatic void intel_pcie_ltssm_enable(struct intel_pcie *pcie)\n{\n\tpcie_app_wr_mask(pcie, PCIE_APP_CCR, PCIE_APP_CCR_LTSSM_ENABLE,\n\t\t\t PCIE_APP_CCR_LTSSM_ENABLE);\n}\n\nstatic void intel_pcie_ltssm_disable(struct intel_pcie *pcie)\n{\n\tpcie_app_wr_mask(pcie, PCIE_APP_CCR, PCIE_APP_CCR_LTSSM_ENABLE, 0);\n}\n\nstatic void intel_pcie_link_setup(struct intel_pcie *pcie)\n{\n\tu32 val;\n\tu8 offset = dw_pcie_find_capability(&pcie->pci, PCI_CAP_ID_EXP);\n\n\tval = pcie_rc_cfg_rd(pcie, offset + PCI_EXP_LNKCTL);\n\n\tval &= ~(PCI_EXP_LNKCTL_LD | PCI_EXP_LNKCTL_ASPMC);\n\tpcie_rc_cfg_wr(pcie, offset + PCI_EXP_LNKCTL, val);\n}\n\nstatic void intel_pcie_init_n_fts(struct dw_pcie *pci)\n{\n\tswitch (pci->link_gen) {\n\tcase 3:\n\t\tpci->n_fts[1] = PORT_AFR_N_FTS_GEN3;\n\t\tbreak;\n\tcase 4:\n\t\tpci->n_fts[1] = PORT_AFR_N_FTS_GEN4;\n\t\tbreak;\n\tdefault:\n\t\tpci->n_fts[1] = PORT_AFR_N_FTS_GEN12_DFT;\n\t\tbreak;\n\t}\n\tpci->n_fts[0] = PORT_AFR_N_FTS_GEN12_DFT;\n}\n\nstatic int intel_pcie_ep_rst_init(struct intel_pcie *pcie)\n{\n\tstruct device *dev = pcie->pci.dev;\n\tint ret;\n\n\tpcie->reset_gpio = devm_gpiod_get(dev, \"reset\", GPIOD_OUT_LOW);\n\tif (IS_ERR(pcie->reset_gpio)) {\n\t\tret = PTR_ERR(pcie->reset_gpio);\n\t\tif (ret != -EPROBE_DEFER)\n\t\t\tdev_err(dev, \"Failed to request PCIe GPIO: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tusleep_range(100, 200);\n\n\treturn 0;\n}\n\nstatic void intel_pcie_core_rst_assert(struct intel_pcie *pcie)\n{\n\treset_control_assert(pcie->core_rst);\n}\n\nstatic void intel_pcie_core_rst_deassert(struct intel_pcie *pcie)\n{\n\t \n\tudelay(1);\n\treset_control_deassert(pcie->core_rst);\n\n\t \n\tusleep_range(1000, 2000);\n}\n\nstatic void intel_pcie_device_rst_assert(struct intel_pcie *pcie)\n{\n\tgpiod_set_value_cansleep(pcie->reset_gpio, 1);\n}\n\nstatic void intel_pcie_device_rst_deassert(struct intel_pcie *pcie)\n{\n\tmsleep(pcie->rst_intrvl);\n\tgpiod_set_value_cansleep(pcie->reset_gpio, 0);\n}\n\nstatic void intel_pcie_core_irq_disable(struct intel_pcie *pcie)\n{\n\tpcie_app_wr(pcie, PCIE_APP_IRNEN, 0);\n\tpcie_app_wr(pcie, PCIE_APP_IRNCR, PCIE_APP_IRN_INT);\n}\n\nstatic int intel_pcie_get_resources(struct platform_device *pdev)\n{\n\tstruct intel_pcie *pcie = platform_get_drvdata(pdev);\n\tstruct dw_pcie *pci = &pcie->pci;\n\tstruct device *dev = pci->dev;\n\tint ret;\n\n\tpcie->core_clk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(pcie->core_clk)) {\n\t\tret = PTR_ERR(pcie->core_clk);\n\t\tif (ret != -EPROBE_DEFER)\n\t\t\tdev_err(dev, \"Failed to get clks: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tpcie->core_rst = devm_reset_control_get(dev, NULL);\n\tif (IS_ERR(pcie->core_rst)) {\n\t\tret = PTR_ERR(pcie->core_rst);\n\t\tif (ret != -EPROBE_DEFER)\n\t\t\tdev_err(dev, \"Failed to get resets: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = device_property_read_u32(dev, \"reset-assert-ms\",\n\t\t\t\t       &pcie->rst_intrvl);\n\tif (ret)\n\t\tpcie->rst_intrvl = RESET_INTERVAL_MS;\n\n\tpcie->app_base = devm_platform_ioremap_resource_byname(pdev, \"app\");\n\tif (IS_ERR(pcie->app_base))\n\t\treturn PTR_ERR(pcie->app_base);\n\n\tpcie->phy = devm_phy_get(dev, \"pcie\");\n\tif (IS_ERR(pcie->phy)) {\n\t\tret = PTR_ERR(pcie->phy);\n\t\tif (ret != -EPROBE_DEFER)\n\t\t\tdev_err(dev, \"Couldn't get pcie-phy: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int intel_pcie_wait_l2(struct intel_pcie *pcie)\n{\n\tu32 value;\n\tint ret;\n\tstruct dw_pcie *pci = &pcie->pci;\n\n\tif (pci->link_gen < 3)\n\t\treturn 0;\n\n\t \n\tpcie_app_wr_mask(pcie, PCIE_APP_MSG_CR, PCIE_APP_MSG_XMT_PM_TURNOFF,\n\t\t\t PCIE_APP_MSG_XMT_PM_TURNOFF);\n\n\t \n\tret = readl_poll_timeout(pcie->app_base + PCIE_APP_PMC, value,\n\t\t\t\t value & PCIE_APP_PMC_IN_L2, 20,\n\t\t\t\t jiffies_to_usecs(5 * HZ));\n\tif (ret)\n\t\tdev_err(pcie->pci.dev, \"PCIe link enter L2 timeout!\\n\");\n\n\treturn ret;\n}\n\nstatic void intel_pcie_turn_off(struct intel_pcie *pcie)\n{\n\tif (dw_pcie_link_up(&pcie->pci))\n\t\tintel_pcie_wait_l2(pcie);\n\n\t \n\tintel_pcie_device_rst_assert(pcie);\n\tpcie_rc_cfg_wr_mask(pcie, PCI_COMMAND, PCI_COMMAND_MEMORY, 0);\n}\n\nstatic int intel_pcie_host_setup(struct intel_pcie *pcie)\n{\n\tint ret;\n\tstruct dw_pcie *pci = &pcie->pci;\n\n\tintel_pcie_core_rst_assert(pcie);\n\tintel_pcie_device_rst_assert(pcie);\n\n\tret = phy_init(pcie->phy);\n\tif (ret)\n\t\treturn ret;\n\n\tintel_pcie_core_rst_deassert(pcie);\n\n\tret = clk_prepare_enable(pcie->core_clk);\n\tif (ret) {\n\t\tdev_err(pcie->pci.dev, \"Core clock enable failed: %d\\n\", ret);\n\t\tgoto clk_err;\n\t}\n\n\tpci->atu_base = pci->dbi_base + 0xC0000;\n\n\tintel_pcie_ltssm_disable(pcie);\n\tintel_pcie_link_setup(pcie);\n\tintel_pcie_init_n_fts(pci);\n\n\tret = dw_pcie_setup_rc(&pci->pp);\n\tif (ret)\n\t\tgoto app_init_err;\n\n\tdw_pcie_upconfig_setup(pci);\n\n\tintel_pcie_device_rst_deassert(pcie);\n\tintel_pcie_ltssm_enable(pcie);\n\n\tret = dw_pcie_wait_for_link(pci);\n\tif (ret)\n\t\tgoto app_init_err;\n\n\t \n\tpcie_app_wr_mask(pcie, PCIE_APP_IRNEN, PCIE_APP_IRN_INT,\n\t\t\t PCIE_APP_IRN_INT);\n\n\treturn 0;\n\napp_init_err:\n\tclk_disable_unprepare(pcie->core_clk);\nclk_err:\n\tintel_pcie_core_rst_assert(pcie);\n\tphy_exit(pcie->phy);\n\n\treturn ret;\n}\n\nstatic void __intel_pcie_remove(struct intel_pcie *pcie)\n{\n\tintel_pcie_core_irq_disable(pcie);\n\tintel_pcie_turn_off(pcie);\n\tclk_disable_unprepare(pcie->core_clk);\n\tintel_pcie_core_rst_assert(pcie);\n\tphy_exit(pcie->phy);\n}\n\nstatic void intel_pcie_remove(struct platform_device *pdev)\n{\n\tstruct intel_pcie *pcie = platform_get_drvdata(pdev);\n\tstruct dw_pcie_rp *pp = &pcie->pci.pp;\n\n\tdw_pcie_host_deinit(pp);\n\t__intel_pcie_remove(pcie);\n}\n\nstatic int intel_pcie_suspend_noirq(struct device *dev)\n{\n\tstruct intel_pcie *pcie = dev_get_drvdata(dev);\n\tint ret;\n\n\tintel_pcie_core_irq_disable(pcie);\n\tret = intel_pcie_wait_l2(pcie);\n\tif (ret)\n\t\treturn ret;\n\n\tphy_exit(pcie->phy);\n\tclk_disable_unprepare(pcie->core_clk);\n\treturn ret;\n}\n\nstatic int intel_pcie_resume_noirq(struct device *dev)\n{\n\tstruct intel_pcie *pcie = dev_get_drvdata(dev);\n\n\treturn intel_pcie_host_setup(pcie);\n}\n\nstatic int intel_pcie_rc_init(struct dw_pcie_rp *pp)\n{\n\tstruct dw_pcie *pci = to_dw_pcie_from_pp(pp);\n\tstruct intel_pcie *pcie = dev_get_drvdata(pci->dev);\n\n\treturn intel_pcie_host_setup(pcie);\n}\n\nstatic u64 intel_pcie_cpu_addr(struct dw_pcie *pcie, u64 cpu_addr)\n{\n\treturn cpu_addr + BUS_IATU_OFFSET;\n}\n\nstatic const struct dw_pcie_ops intel_pcie_ops = {\n\t.cpu_addr_fixup = intel_pcie_cpu_addr,\n};\n\nstatic const struct dw_pcie_host_ops intel_pcie_dw_ops = {\n\t.host_init =\t\tintel_pcie_rc_init,\n};\n\nstatic int intel_pcie_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct intel_pcie *pcie;\n\tstruct dw_pcie_rp *pp;\n\tstruct dw_pcie *pci;\n\tint ret;\n\n\tpcie = devm_kzalloc(dev, sizeof(*pcie), GFP_KERNEL);\n\tif (!pcie)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, pcie);\n\tpci = &pcie->pci;\n\tpci->dev = dev;\n\tpp = &pci->pp;\n\n\tret = intel_pcie_get_resources(pdev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = intel_pcie_ep_rst_init(pcie);\n\tif (ret)\n\t\treturn ret;\n\n\tpci->ops = &intel_pcie_ops;\n\tpp->ops = &intel_pcie_dw_ops;\n\n\tret = dw_pcie_host_init(pp);\n\tif (ret) {\n\t\tdev_err(dev, \"Cannot initialize host\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops intel_pcie_pm_ops = {\n\tNOIRQ_SYSTEM_SLEEP_PM_OPS(intel_pcie_suspend_noirq,\n\t\t\t\t  intel_pcie_resume_noirq)\n};\n\nstatic const struct of_device_id of_intel_pcie_match[] = {\n\t{ .compatible = \"intel,lgm-pcie\" },\n\t{}\n};\n\nstatic struct platform_driver intel_pcie_driver = {\n\t.probe = intel_pcie_probe,\n\t.remove_new = intel_pcie_remove,\n\t.driver = {\n\t\t.name = \"intel-gw-pcie\",\n\t\t.of_match_table = of_intel_pcie_match,\n\t\t.pm = &intel_pcie_pm_ops,\n\t},\n};\nbuiltin_platform_driver(intel_pcie_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}