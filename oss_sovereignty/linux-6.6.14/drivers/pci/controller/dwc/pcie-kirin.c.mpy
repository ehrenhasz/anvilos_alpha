{
  "module_name": "pcie-kirin.c",
  "hash_id": "3c1e5ceae8d3f3ab41770bae19aef3c3b9449dbbc74f2f357fb5c9285ea69758",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/controller/dwc/pcie-kirin.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/compiler.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/gpio.h>\n#include <linux/gpio/consumer.h>\n#include <linux/interrupt.h>\n#include <linux/mfd/syscon.h>\n#include <linux/of.h>\n#include <linux/of_gpio.h>\n#include <linux/of_pci.h>\n#include <linux/phy/phy.h>\n#include <linux/pci.h>\n#include <linux/pci_regs.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/resource.h>\n#include <linux/types.h>\n#include \"pcie-designware.h\"\n\n#define to_kirin_pcie(x) dev_get_drvdata((x)->dev)\n\n \n#define SOC_PCIECTRL_CTRL0_ADDR\t\t0x000\n#define SOC_PCIECTRL_CTRL1_ADDR\t\t0x004\n#define PCIE_ELBI_SLV_DBI_ENABLE\t(0x1 << 21)\n\n \n#define PCIE_APP_LTSSM_ENABLE\t0x01c\n#define PCIE_APB_PHY_STATUS0\t0x400\n#define PCIE_LINKUP_ENABLE\t(0x8020)\n#define PCIE_LTSSM_ENABLE_BIT\t(0x1 << 11)\n\n \n#define SCTRL_PCIE_CMOS_OFFSET\t0x60\n#define SCTRL_PCIE_CMOS_BIT\t0x10\n#define SCTRL_PCIE_ISO_OFFSET\t0x44\n#define SCTRL_PCIE_ISO_BIT\t0x30\n#define SCTRL_PCIE_HPCLK_OFFSET\t0x190\n#define SCTRL_PCIE_HPCLK_BIT\t0x184000\n#define SCTRL_PCIE_OE_OFFSET\t0x14a\n#define PCIE_DEBOUNCE_PARAM\t0xF0F400\n#define PCIE_OE_BYPASS\t\t(0x3 << 28)\n\n \n#define MAX_PCI_SLOTS\t\t3\n\nenum pcie_kirin_phy_type {\n\tPCIE_KIRIN_INTERNAL_PHY,\n\tPCIE_KIRIN_EXTERNAL_PHY\n};\n\nstruct kirin_pcie {\n\tenum pcie_kirin_phy_type\ttype;\n\n\tstruct dw_pcie\t*pci;\n\tstruct regmap   *apb;\n\tstruct phy\t*phy;\n\tvoid\t\t*phy_priv;\t \n\n\t \n\tint\t\tgpio_id_dwc_perst;\n\n\t \n\tint\t\tnum_slots;\n\tint\t\tgpio_id_reset[MAX_PCI_SLOTS];\n\tconst char\t*reset_names[MAX_PCI_SLOTS];\n\n\t \n\tint\t\tn_gpio_clkreq;\n\tint\t\tgpio_id_clkreq[MAX_PCI_SLOTS];\n\tconst char\t*clkreq_names[MAX_PCI_SLOTS];\n};\n\n \n\n#define REF_CLK_FREQ\t\t\t100000000\n\n \n#define PCIE_APB_PHY_CTRL0\t0x0\n#define PCIE_APB_PHY_CTRL1\t0x4\n#define PCIE_APB_PHY_STATUS0   0x400\n#define PIPE_CLK_STABLE\t\tBIT(19)\n#define PHY_REF_PAD_BIT\t\tBIT(8)\n#define PHY_PWR_DOWN_BIT\tBIT(22)\n#define PHY_RST_ACK_BIT\t\tBIT(16)\n\n \n#define CRGCTRL_PCIE_ASSERT_OFFSET\t0x88\n#define CRGCTRL_PCIE_ASSERT_BIT\t\t0x8c000000\n\n \n#define REF_2_PERST_MIN\t\t21000\n#define REF_2_PERST_MAX\t\t25000\n#define PERST_2_ACCESS_MIN\t10000\n#define PERST_2_ACCESS_MAX\t12000\n#define PIPE_CLK_WAIT_MIN\t550\n#define PIPE_CLK_WAIT_MAX\t600\n#define TIME_CMOS_MIN\t\t100\n#define TIME_CMOS_MAX\t\t105\n#define TIME_PHY_PD_MIN\t\t10\n#define TIME_PHY_PD_MAX\t\t11\n\nstruct hi3660_pcie_phy {\n\tstruct device\t*dev;\n\tvoid __iomem\t*base;\n\tstruct regmap\t*crgctrl;\n\tstruct regmap\t*sysctrl;\n\tstruct clk\t*apb_sys_clk;\n\tstruct clk\t*apb_phy_clk;\n\tstruct clk\t*phy_ref_clk;\n\tstruct clk\t*aclk;\n\tstruct clk\t*aux_clk;\n};\n\n \nstatic inline void kirin_apb_phy_writel(struct hi3660_pcie_phy *hi3660_pcie_phy,\n\t\t\t\t\tu32 val, u32 reg)\n{\n\twritel(val, hi3660_pcie_phy->base + reg);\n}\n\nstatic inline u32 kirin_apb_phy_readl(struct hi3660_pcie_phy *hi3660_pcie_phy,\n\t\t\t\t      u32 reg)\n{\n\treturn readl(hi3660_pcie_phy->base + reg);\n}\n\nstatic int hi3660_pcie_phy_get_clk(struct hi3660_pcie_phy *phy)\n{\n\tstruct device *dev = phy->dev;\n\n\tphy->phy_ref_clk = devm_clk_get(dev, \"pcie_phy_ref\");\n\tif (IS_ERR(phy->phy_ref_clk))\n\t\treturn PTR_ERR(phy->phy_ref_clk);\n\n\tphy->aux_clk = devm_clk_get(dev, \"pcie_aux\");\n\tif (IS_ERR(phy->aux_clk))\n\t\treturn PTR_ERR(phy->aux_clk);\n\n\tphy->apb_phy_clk = devm_clk_get(dev, \"pcie_apb_phy\");\n\tif (IS_ERR(phy->apb_phy_clk))\n\t\treturn PTR_ERR(phy->apb_phy_clk);\n\n\tphy->apb_sys_clk = devm_clk_get(dev, \"pcie_apb_sys\");\n\tif (IS_ERR(phy->apb_sys_clk))\n\t\treturn PTR_ERR(phy->apb_sys_clk);\n\n\tphy->aclk = devm_clk_get(dev, \"pcie_aclk\");\n\tif (IS_ERR(phy->aclk))\n\t\treturn PTR_ERR(phy->aclk);\n\n\treturn 0;\n}\n\nstatic int hi3660_pcie_phy_get_resource(struct hi3660_pcie_phy *phy)\n{\n\tstruct device *dev = phy->dev;\n\tstruct platform_device *pdev;\n\n\t \n\tpdev = container_of(dev, struct platform_device, dev);\n\n\tphy->base = devm_platform_ioremap_resource_byname(pdev, \"phy\");\n\tif (IS_ERR(phy->base))\n\t\treturn PTR_ERR(phy->base);\n\n\tphy->crgctrl = syscon_regmap_lookup_by_compatible(\"hisilicon,hi3660-crgctrl\");\n\tif (IS_ERR(phy->crgctrl))\n\t\treturn PTR_ERR(phy->crgctrl);\n\n\tphy->sysctrl = syscon_regmap_lookup_by_compatible(\"hisilicon,hi3660-sctrl\");\n\tif (IS_ERR(phy->sysctrl))\n\t\treturn PTR_ERR(phy->sysctrl);\n\n\treturn 0;\n}\n\nstatic int hi3660_pcie_phy_start(struct hi3660_pcie_phy *phy)\n{\n\tstruct device *dev = phy->dev;\n\tu32 reg_val;\n\n\treg_val = kirin_apb_phy_readl(phy, PCIE_APB_PHY_CTRL1);\n\treg_val &= ~PHY_REF_PAD_BIT;\n\tkirin_apb_phy_writel(phy, reg_val, PCIE_APB_PHY_CTRL1);\n\n\treg_val = kirin_apb_phy_readl(phy, PCIE_APB_PHY_CTRL0);\n\treg_val &= ~PHY_PWR_DOWN_BIT;\n\tkirin_apb_phy_writel(phy, reg_val, PCIE_APB_PHY_CTRL0);\n\tusleep_range(TIME_PHY_PD_MIN, TIME_PHY_PD_MAX);\n\n\treg_val = kirin_apb_phy_readl(phy, PCIE_APB_PHY_CTRL1);\n\treg_val &= ~PHY_RST_ACK_BIT;\n\tkirin_apb_phy_writel(phy, reg_val, PCIE_APB_PHY_CTRL1);\n\n\tusleep_range(PIPE_CLK_WAIT_MIN, PIPE_CLK_WAIT_MAX);\n\treg_val = kirin_apb_phy_readl(phy, PCIE_APB_PHY_STATUS0);\n\tif (reg_val & PIPE_CLK_STABLE) {\n\t\tdev_err(dev, \"PIPE clk is not stable\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void hi3660_pcie_phy_oe_enable(struct hi3660_pcie_phy *phy)\n{\n\tu32 val;\n\n\tregmap_read(phy->sysctrl, SCTRL_PCIE_OE_OFFSET, &val);\n\tval |= PCIE_DEBOUNCE_PARAM;\n\tval &= ~PCIE_OE_BYPASS;\n\tregmap_write(phy->sysctrl, SCTRL_PCIE_OE_OFFSET, val);\n}\n\nstatic int hi3660_pcie_phy_clk_ctrl(struct hi3660_pcie_phy *phy, bool enable)\n{\n\tint ret = 0;\n\n\tif (!enable)\n\t\tgoto close_clk;\n\n\tret = clk_set_rate(phy->phy_ref_clk, REF_CLK_FREQ);\n\tif (ret)\n\t\treturn ret;\n\n\tret = clk_prepare_enable(phy->phy_ref_clk);\n\tif (ret)\n\t\treturn ret;\n\n\tret = clk_prepare_enable(phy->apb_sys_clk);\n\tif (ret)\n\t\tgoto apb_sys_fail;\n\n\tret = clk_prepare_enable(phy->apb_phy_clk);\n\tif (ret)\n\t\tgoto apb_phy_fail;\n\n\tret = clk_prepare_enable(phy->aclk);\n\tif (ret)\n\t\tgoto aclk_fail;\n\n\tret = clk_prepare_enable(phy->aux_clk);\n\tif (ret)\n\t\tgoto aux_clk_fail;\n\n\treturn 0;\n\nclose_clk:\n\tclk_disable_unprepare(phy->aux_clk);\naux_clk_fail:\n\tclk_disable_unprepare(phy->aclk);\naclk_fail:\n\tclk_disable_unprepare(phy->apb_phy_clk);\napb_phy_fail:\n\tclk_disable_unprepare(phy->apb_sys_clk);\napb_sys_fail:\n\tclk_disable_unprepare(phy->phy_ref_clk);\n\n\treturn ret;\n}\n\nstatic int hi3660_pcie_phy_power_on(struct kirin_pcie *pcie)\n{\n\tstruct hi3660_pcie_phy *phy = pcie->phy_priv;\n\tint ret;\n\n\t \n\tregmap_write(phy->sysctrl,\n\t\t     SCTRL_PCIE_CMOS_OFFSET, SCTRL_PCIE_CMOS_BIT);\n\tusleep_range(TIME_CMOS_MIN, TIME_CMOS_MAX);\n\n\thi3660_pcie_phy_oe_enable(phy);\n\n\tret = hi3660_pcie_phy_clk_ctrl(phy, true);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tregmap_write(phy->sysctrl,\n\t\t     SCTRL_PCIE_ISO_OFFSET, SCTRL_PCIE_ISO_BIT);\n\tregmap_write(phy->crgctrl,\n\t\t     CRGCTRL_PCIE_ASSERT_OFFSET, CRGCTRL_PCIE_ASSERT_BIT);\n\tregmap_write(phy->sysctrl,\n\t\t     SCTRL_PCIE_HPCLK_OFFSET, SCTRL_PCIE_HPCLK_BIT);\n\n\tret = hi3660_pcie_phy_start(phy);\n\tif (ret)\n\t\tgoto disable_clks;\n\n\treturn 0;\n\ndisable_clks:\n\thi3660_pcie_phy_clk_ctrl(phy, false);\n\treturn ret;\n}\n\nstatic int hi3660_pcie_phy_init(struct platform_device *pdev,\n\t\t\t\tstruct kirin_pcie *pcie)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct hi3660_pcie_phy *phy;\n\tint ret;\n\n\tphy = devm_kzalloc(dev, sizeof(*phy), GFP_KERNEL);\n\tif (!phy)\n\t\treturn -ENOMEM;\n\n\tpcie->phy_priv = phy;\n\tphy->dev = dev;\n\n\tret = hi3660_pcie_phy_get_clk(phy);\n\tif (ret)\n\t\treturn ret;\n\n\treturn hi3660_pcie_phy_get_resource(phy);\n}\n\nstatic int hi3660_pcie_phy_power_off(struct kirin_pcie *pcie)\n{\n\tstruct hi3660_pcie_phy *phy = pcie->phy_priv;\n\n\t \n\tregmap_write(phy->sysctrl, SCTRL_PCIE_CMOS_OFFSET, 0x00);\n\n\thi3660_pcie_phy_clk_ctrl(phy, false);\n\n\treturn 0;\n}\n\n \n\nstatic const struct regmap_config pcie_kirin_regmap_conf = {\n\t.name = \"kirin_pcie_apb\",\n\t.reg_bits = 32,\n\t.val_bits = 32,\n\t.reg_stride = 4,\n};\n\nstatic int kirin_pcie_get_gpio_enable(struct kirin_pcie *pcie,\n\t\t\t\t      struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tchar name[32];\n\tint ret, i;\n\n\t \n\tret = gpiod_count(dev, \"hisilicon,clken\");\n\tif (ret < 0)\n\t\treturn 0;\n\n\tif (ret > MAX_PCI_SLOTS) {\n\t\tdev_err(dev, \"Too many GPIO clock requests!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpcie->n_gpio_clkreq = ret;\n\n\tfor (i = 0; i < pcie->n_gpio_clkreq; i++) {\n\t\tpcie->gpio_id_clkreq[i] = of_get_named_gpio(dev->of_node,\n\t\t\t\t\t\t    \"hisilicon,clken-gpios\", i);\n\t\tif (pcie->gpio_id_clkreq[i] < 0)\n\t\t\treturn pcie->gpio_id_clkreq[i];\n\n\t\tsprintf(name, \"pcie_clkreq_%d\", i);\n\t\tpcie->clkreq_names[i] = devm_kstrdup_const(dev, name,\n\t\t\t\t\t\t\t    GFP_KERNEL);\n\t\tif (!pcie->clkreq_names[i])\n\t\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic int kirin_pcie_parse_port(struct kirin_pcie *pcie,\n\t\t\t\t struct platform_device *pdev,\n\t\t\t\t struct device_node *node)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *parent, *child;\n\tint ret, slot, i;\n\tchar name[32];\n\n\tfor_each_available_child_of_node(node, parent) {\n\t\tfor_each_available_child_of_node(parent, child) {\n\t\t\ti = pcie->num_slots;\n\n\t\t\tpcie->gpio_id_reset[i] = of_get_named_gpio(child,\n\t\t\t\t\t\t\t\"reset-gpios\", 0);\n\t\t\tif (pcie->gpio_id_reset[i] < 0)\n\t\t\t\tcontinue;\n\n\t\t\tpcie->num_slots++;\n\t\t\tif (pcie->num_slots > MAX_PCI_SLOTS) {\n\t\t\t\tdev_err(dev, \"Too many PCI slots!\\n\");\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto put_node;\n\t\t\t}\n\n\t\t\tret = of_pci_get_devfn(child);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(dev, \"failed to parse devfn: %d\\n\", ret);\n\t\t\t\tgoto put_node;\n\t\t\t}\n\n\t\t\tslot = PCI_SLOT(ret);\n\n\t\t\tsprintf(name, \"pcie_perst_%d\", slot);\n\t\t\tpcie->reset_names[i] = devm_kstrdup_const(dev, name,\n\t\t\t\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!pcie->reset_names[i]) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto put_node;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n\nput_node:\n\tof_node_put(child);\n\tof_node_put(parent);\n\treturn ret;\n}\n\nstatic long kirin_pcie_get_resource(struct kirin_pcie *kirin_pcie,\n\t\t\t\t    struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *child, *node = dev->of_node;\n\tvoid __iomem *apb_base;\n\tint ret;\n\n\tapb_base = devm_platform_ioremap_resource_byname(pdev, \"apb\");\n\tif (IS_ERR(apb_base))\n\t\treturn PTR_ERR(apb_base);\n\n\tkirin_pcie->apb = devm_regmap_init_mmio(dev, apb_base,\n\t\t\t\t\t\t&pcie_kirin_regmap_conf);\n\tif (IS_ERR(kirin_pcie->apb))\n\t\treturn PTR_ERR(kirin_pcie->apb);\n\n\t \n\tkirin_pcie->gpio_id_dwc_perst = of_get_named_gpio(dev->of_node,\n\t\t\t\t\t\t\t  \"reset-gpios\", 0);\n\tif (kirin_pcie->gpio_id_dwc_perst == -EPROBE_DEFER) {\n\t\treturn -EPROBE_DEFER;\n\t} else if (!gpio_is_valid(kirin_pcie->gpio_id_dwc_perst)) {\n\t\tdev_err(dev, \"unable to get a valid gpio pin\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tret = kirin_pcie_get_gpio_enable(kirin_pcie, pdev);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tfor_each_available_child_of_node(node, child) {\n\t\tret = kirin_pcie_parse_port(kirin_pcie, pdev, child);\n\t\tif (ret)\n\t\t\tgoto put_node;\n\t}\n\n\treturn 0;\n\nput_node:\n\tof_node_put(child);\n\treturn ret;\n}\n\nstatic void kirin_pcie_sideband_dbi_w_mode(struct kirin_pcie *kirin_pcie,\n\t\t\t\t\t   bool on)\n{\n\tu32 val;\n\n\tregmap_read(kirin_pcie->apb, SOC_PCIECTRL_CTRL0_ADDR, &val);\n\tif (on)\n\t\tval = val | PCIE_ELBI_SLV_DBI_ENABLE;\n\telse\n\t\tval = val & ~PCIE_ELBI_SLV_DBI_ENABLE;\n\n\tregmap_write(kirin_pcie->apb, SOC_PCIECTRL_CTRL0_ADDR, val);\n}\n\nstatic void kirin_pcie_sideband_dbi_r_mode(struct kirin_pcie *kirin_pcie,\n\t\t\t\t\t   bool on)\n{\n\tu32 val;\n\n\tregmap_read(kirin_pcie->apb, SOC_PCIECTRL_CTRL1_ADDR, &val);\n\tif (on)\n\t\tval = val | PCIE_ELBI_SLV_DBI_ENABLE;\n\telse\n\t\tval = val & ~PCIE_ELBI_SLV_DBI_ENABLE;\n\n\tregmap_write(kirin_pcie->apb, SOC_PCIECTRL_CTRL1_ADDR, val);\n}\n\nstatic int kirin_pcie_rd_own_conf(struct pci_bus *bus, unsigned int devfn,\n\t\t\t\t  int where, int size, u32 *val)\n{\n\tstruct dw_pcie *pci = to_dw_pcie_from_pp(bus->sysdata);\n\n\tif (PCI_SLOT(devfn))\n\t\treturn PCIBIOS_DEVICE_NOT_FOUND;\n\n\t*val = dw_pcie_read_dbi(pci, where, size);\n\treturn PCIBIOS_SUCCESSFUL;\n}\n\nstatic int kirin_pcie_wr_own_conf(struct pci_bus *bus, unsigned int devfn,\n\t\t\t\t  int where, int size, u32 val)\n{\n\tstruct dw_pcie *pci = to_dw_pcie_from_pp(bus->sysdata);\n\n\tif (PCI_SLOT(devfn))\n\t\treturn PCIBIOS_DEVICE_NOT_FOUND;\n\n\tdw_pcie_write_dbi(pci, where, size, val);\n\treturn PCIBIOS_SUCCESSFUL;\n}\n\nstatic int kirin_pcie_add_bus(struct pci_bus *bus)\n{\n\tstruct dw_pcie *pci = to_dw_pcie_from_pp(bus->sysdata);\n\tstruct kirin_pcie *kirin_pcie = to_kirin_pcie(pci);\n\tint i, ret;\n\n\tif (!kirin_pcie->num_slots)\n\t\treturn 0;\n\n\t \n\tfor (i = 0; i < kirin_pcie->num_slots; i++) {\n\t\tret = gpio_direction_output(kirin_pcie->gpio_id_reset[i], 1);\n\t\tif (ret) {\n\t\t\tdev_err(pci->dev, \"PERST# %s error: %d\\n\",\n\t\t\t\tkirin_pcie->reset_names[i], ret);\n\t\t}\n\t}\n\tusleep_range(PERST_2_ACCESS_MIN, PERST_2_ACCESS_MAX);\n\n\treturn 0;\n}\n\nstatic struct pci_ops kirin_pci_ops = {\n\t.read = kirin_pcie_rd_own_conf,\n\t.write = kirin_pcie_wr_own_conf,\n\t.add_bus = kirin_pcie_add_bus,\n};\n\nstatic u32 kirin_pcie_read_dbi(struct dw_pcie *pci, void __iomem *base,\n\t\t\t       u32 reg, size_t size)\n{\n\tstruct kirin_pcie *kirin_pcie = to_kirin_pcie(pci);\n\tu32 ret;\n\n\tkirin_pcie_sideband_dbi_r_mode(kirin_pcie, true);\n\tdw_pcie_read(base + reg, size, &ret);\n\tkirin_pcie_sideband_dbi_r_mode(kirin_pcie, false);\n\n\treturn ret;\n}\n\nstatic void kirin_pcie_write_dbi(struct dw_pcie *pci, void __iomem *base,\n\t\t\t\t u32 reg, size_t size, u32 val)\n{\n\tstruct kirin_pcie *kirin_pcie = to_kirin_pcie(pci);\n\n\tkirin_pcie_sideband_dbi_w_mode(kirin_pcie, true);\n\tdw_pcie_write(base + reg, size, val);\n\tkirin_pcie_sideband_dbi_w_mode(kirin_pcie, false);\n}\n\nstatic int kirin_pcie_link_up(struct dw_pcie *pci)\n{\n\tstruct kirin_pcie *kirin_pcie = to_kirin_pcie(pci);\n\tu32 val;\n\n\tregmap_read(kirin_pcie->apb, PCIE_APB_PHY_STATUS0, &val);\n\tif ((val & PCIE_LINKUP_ENABLE) == PCIE_LINKUP_ENABLE)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic int kirin_pcie_start_link(struct dw_pcie *pci)\n{\n\tstruct kirin_pcie *kirin_pcie = to_kirin_pcie(pci);\n\n\t \n\tregmap_write(kirin_pcie->apb, PCIE_APP_LTSSM_ENABLE,\n\t\t     PCIE_LTSSM_ENABLE_BIT);\n\n\treturn 0;\n}\n\nstatic int kirin_pcie_host_init(struct dw_pcie_rp *pp)\n{\n\tpp->bridge->ops = &kirin_pci_ops;\n\n\treturn 0;\n}\n\nstatic int kirin_pcie_gpio_request(struct kirin_pcie *kirin_pcie,\n\t\t\t\t   struct device *dev)\n{\n\tint ret, i;\n\n\tfor (i = 0; i < kirin_pcie->num_slots; i++) {\n\t\tif (!gpio_is_valid(kirin_pcie->gpio_id_reset[i])) {\n\t\t\tdev_err(dev, \"unable to get a valid %s gpio\\n\",\n\t\t\t\tkirin_pcie->reset_names[i]);\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\tret = devm_gpio_request(dev, kirin_pcie->gpio_id_reset[i],\n\t\t\t\t\tkirin_pcie->reset_names[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < kirin_pcie->n_gpio_clkreq; i++) {\n\t\tif (!gpio_is_valid(kirin_pcie->gpio_id_clkreq[i])) {\n\t\t\tdev_err(dev, \"unable to get a valid %s gpio\\n\",\n\t\t\t\tkirin_pcie->clkreq_names[i]);\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\tret = devm_gpio_request(dev, kirin_pcie->gpio_id_clkreq[i],\n\t\t\t\t\tkirin_pcie->clkreq_names[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = gpio_direction_output(kirin_pcie->gpio_id_clkreq[i], 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct dw_pcie_ops kirin_dw_pcie_ops = {\n\t.read_dbi = kirin_pcie_read_dbi,\n\t.write_dbi = kirin_pcie_write_dbi,\n\t.link_up = kirin_pcie_link_up,\n\t.start_link = kirin_pcie_start_link,\n};\n\nstatic const struct dw_pcie_host_ops kirin_pcie_host_ops = {\n\t.host_init = kirin_pcie_host_init,\n};\n\nstatic int kirin_pcie_power_off(struct kirin_pcie *kirin_pcie)\n{\n\tint i;\n\n\tif (kirin_pcie->type == PCIE_KIRIN_INTERNAL_PHY)\n\t\treturn hi3660_pcie_phy_power_off(kirin_pcie);\n\n\tfor (i = 0; i < kirin_pcie->n_gpio_clkreq; i++)\n\t\tgpio_direction_output(kirin_pcie->gpio_id_clkreq[i], 1);\n\n\tphy_power_off(kirin_pcie->phy);\n\tphy_exit(kirin_pcie->phy);\n\n\treturn 0;\n}\n\nstatic int kirin_pcie_power_on(struct platform_device *pdev,\n\t\t\t       struct kirin_pcie *kirin_pcie)\n{\n\tstruct device *dev = &pdev->dev;\n\tint ret;\n\n\tif (kirin_pcie->type == PCIE_KIRIN_INTERNAL_PHY) {\n\t\tret = hi3660_pcie_phy_init(pdev, kirin_pcie);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = hi3660_pcie_phy_power_on(kirin_pcie);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\tkirin_pcie->phy = devm_of_phy_get(dev, dev->of_node, NULL);\n\t\tif (IS_ERR(kirin_pcie->phy))\n\t\t\treturn PTR_ERR(kirin_pcie->phy);\n\n\t\tret = kirin_pcie_gpio_request(kirin_pcie, dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = phy_init(kirin_pcie->phy);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tret = phy_power_on(kirin_pcie->phy);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\t \n\tusleep_range(REF_2_PERST_MIN, REF_2_PERST_MAX);\n\n\tif (!gpio_request(kirin_pcie->gpio_id_dwc_perst, \"pcie_perst_bridge\")) {\n\t\tret = gpio_direction_output(kirin_pcie->gpio_id_dwc_perst, 1);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\tusleep_range(PERST_2_ACCESS_MIN, PERST_2_ACCESS_MAX);\n\n\treturn 0;\nerr:\n\tkirin_pcie_power_off(kirin_pcie);\n\n\treturn ret;\n}\n\nstatic int kirin_pcie_remove(struct platform_device *pdev)\n{\n\tstruct kirin_pcie *kirin_pcie = platform_get_drvdata(pdev);\n\n\tdw_pcie_host_deinit(&kirin_pcie->pci->pp);\n\n\tkirin_pcie_power_off(kirin_pcie);\n\n\treturn 0;\n}\n\nstruct kirin_pcie_data {\n\tenum pcie_kirin_phy_type\tphy_type;\n};\n\nstatic const struct kirin_pcie_data kirin_960_data = {\n\t.phy_type = PCIE_KIRIN_INTERNAL_PHY,\n};\n\nstatic const struct kirin_pcie_data kirin_970_data = {\n\t.phy_type = PCIE_KIRIN_EXTERNAL_PHY,\n};\n\nstatic const struct of_device_id kirin_pcie_match[] = {\n\t{ .compatible = \"hisilicon,kirin960-pcie\", .data = &kirin_960_data },\n\t{ .compatible = \"hisilicon,kirin970-pcie\", .data = &kirin_970_data },\n\t{},\n};\n\nstatic int kirin_pcie_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tconst struct kirin_pcie_data *data;\n\tstruct kirin_pcie *kirin_pcie;\n\tstruct dw_pcie *pci;\n\tint ret;\n\n\tif (!dev->of_node) {\n\t\tdev_err(dev, \"NULL node\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdata = of_device_get_match_data(dev);\n\tif (!data) {\n\t\tdev_err(dev, \"OF data missing\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tkirin_pcie = devm_kzalloc(dev, sizeof(struct kirin_pcie), GFP_KERNEL);\n\tif (!kirin_pcie)\n\t\treturn -ENOMEM;\n\n\tpci = devm_kzalloc(dev, sizeof(*pci), GFP_KERNEL);\n\tif (!pci)\n\t\treturn -ENOMEM;\n\n\tpci->dev = dev;\n\tpci->ops = &kirin_dw_pcie_ops;\n\tpci->pp.ops = &kirin_pcie_host_ops;\n\tkirin_pcie->pci = pci;\n\tkirin_pcie->type = data->phy_type;\n\n\tret = kirin_pcie_get_resource(kirin_pcie, pdev);\n\tif (ret)\n\t\treturn ret;\n\n\tplatform_set_drvdata(pdev, kirin_pcie);\n\n\tret = kirin_pcie_power_on(pdev, kirin_pcie);\n\tif (ret)\n\t\treturn ret;\n\n\treturn dw_pcie_host_init(&pci->pp);\n}\n\nstatic struct platform_driver kirin_pcie_driver = {\n\t.probe\t\t\t= kirin_pcie_probe,\n\t.remove\t        \t= kirin_pcie_remove,\n\t.driver\t\t\t= {\n\t\t.name\t\t\t= \"kirin-pcie\",\n\t\t.of_match_table\t\t= kirin_pcie_match,\n\t\t.suppress_bind_attrs\t= true,\n\t},\n};\nmodule_platform_driver(kirin_pcie_driver);\n\nMODULE_DEVICE_TABLE(of, kirin_pcie_match);\nMODULE_DESCRIPTION(\"PCIe host controller driver for Kirin Phone SoCs\");\nMODULE_AUTHOR(\"Xiaowei Song <songxiaowei@huawei.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}