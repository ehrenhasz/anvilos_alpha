{
  "module_name": "pcie-artpec6.c",
  "hash_id": "e18a2f2a181dc3029fca44c676bfc9d390206f1ff002931ac0ae32ae0ed4e27e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/controller/dwc/pcie-artpec6.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/of.h>\n#include <linux/pci.h>\n#include <linux/platform_device.h>\n#include <linux/resource.h>\n#include <linux/signal.h>\n#include <linux/types.h>\n#include <linux/interrupt.h>\n#include <linux/mfd/syscon.h>\n#include <linux/regmap.h>\n\n#include \"pcie-designware.h\"\n\n#define to_artpec6_pcie(x)\tdev_get_drvdata((x)->dev)\n\nenum artpec_pcie_variants {\n\tARTPEC6,\n\tARTPEC7,\n};\n\nstruct artpec6_pcie {\n\tstruct dw_pcie\t\t*pci;\n\tstruct regmap\t\t*regmap;\t \n\tvoid __iomem\t\t*phy_base;\t \n\tenum artpec_pcie_variants variant;\n\tenum dw_pcie_device_mode mode;\n};\n\nstruct artpec_pcie_of_data {\n\tenum artpec_pcie_variants variant;\n\tenum dw_pcie_device_mode mode;\n};\n\nstatic const struct of_device_id artpec6_pcie_of_match[];\n\n \n#define PCIECFG\t\t\t\t0x18\n#define  PCIECFG_DBG_OEN\t\tBIT(24)\n#define  PCIECFG_CORE_RESET_REQ\t\tBIT(21)\n#define  PCIECFG_LTSSM_ENABLE\t\tBIT(20)\n#define  PCIECFG_DEVICE_TYPE_MASK\tGENMASK(19, 16)\n#define  PCIECFG_CLKREQ_B\t\tBIT(11)\n#define  PCIECFG_REFCLK_ENABLE\t\tBIT(10)\n#define  PCIECFG_PLL_ENABLE\t\tBIT(9)\n#define  PCIECFG_PCLK_ENABLE\t\tBIT(8)\n#define  PCIECFG_RISRCREN\t\tBIT(4)\n#define  PCIECFG_MODE_TX_DRV_EN\t\tBIT(3)\n#define  PCIECFG_CISRREN\t\tBIT(2)\n#define  PCIECFG_MACRO_ENABLE\t\tBIT(0)\n \n#define  PCIECFG_REFCLKSEL\t\tBIT(23)\n#define  PCIECFG_NOC_RESET\t\tBIT(3)\n\n#define PCIESTAT\t\t\t0x1c\n \n#define  PCIESTAT_EXTREFCLK\t\tBIT(3)\n\n#define NOCCFG\t\t\t\t0x40\n#define  NOCCFG_ENABLE_CLK_PCIE\t\tBIT(4)\n#define  NOCCFG_POWER_PCIE_IDLEACK\tBIT(3)\n#define  NOCCFG_POWER_PCIE_IDLE\t\tBIT(2)\n#define  NOCCFG_POWER_PCIE_IDLEREQ\tBIT(1)\n\n#define PHY_STATUS\t\t\t0x118\n#define  PHY_COSPLLLOCK\t\t\tBIT(0)\n\n#define PHY_TX_ASIC_OUT\t\t\t0x4040\n#define  PHY_TX_ASIC_OUT_TX_ACK\t\tBIT(0)\n\n#define PHY_RX_ASIC_OUT\t\t\t0x405c\n#define  PHY_RX_ASIC_OUT_ACK\t\tBIT(0)\n\nstatic u32 artpec6_pcie_readl(struct artpec6_pcie *artpec6_pcie, u32 offset)\n{\n\tu32 val;\n\n\tregmap_read(artpec6_pcie->regmap, offset, &val);\n\treturn val;\n}\n\nstatic void artpec6_pcie_writel(struct artpec6_pcie *artpec6_pcie, u32 offset, u32 val)\n{\n\tregmap_write(artpec6_pcie->regmap, offset, val);\n}\n\nstatic u64 artpec6_pcie_cpu_addr_fixup(struct dw_pcie *pci, u64 pci_addr)\n{\n\tstruct artpec6_pcie *artpec6_pcie = to_artpec6_pcie(pci);\n\tstruct dw_pcie_rp *pp = &pci->pp;\n\tstruct dw_pcie_ep *ep = &pci->ep;\n\n\tswitch (artpec6_pcie->mode) {\n\tcase DW_PCIE_RC_TYPE:\n\t\treturn pci_addr - pp->cfg0_base;\n\tcase DW_PCIE_EP_TYPE:\n\t\treturn pci_addr - ep->phys_base;\n\tdefault:\n\t\tdev_err(pci->dev, \"UNKNOWN device type\\n\");\n\t}\n\treturn pci_addr;\n}\n\nstatic int artpec6_pcie_establish_link(struct dw_pcie *pci)\n{\n\tstruct artpec6_pcie *artpec6_pcie = to_artpec6_pcie(pci);\n\tu32 val;\n\n\tval = artpec6_pcie_readl(artpec6_pcie, PCIECFG);\n\tval |= PCIECFG_LTSSM_ENABLE;\n\tartpec6_pcie_writel(artpec6_pcie, PCIECFG, val);\n\n\treturn 0;\n}\n\nstatic void artpec6_pcie_stop_link(struct dw_pcie *pci)\n{\n\tstruct artpec6_pcie *artpec6_pcie = to_artpec6_pcie(pci);\n\tu32 val;\n\n\tval = artpec6_pcie_readl(artpec6_pcie, PCIECFG);\n\tval &= ~PCIECFG_LTSSM_ENABLE;\n\tartpec6_pcie_writel(artpec6_pcie, PCIECFG, val);\n}\n\nstatic const struct dw_pcie_ops dw_pcie_ops = {\n\t.cpu_addr_fixup = artpec6_pcie_cpu_addr_fixup,\n\t.start_link = artpec6_pcie_establish_link,\n\t.stop_link = artpec6_pcie_stop_link,\n};\n\nstatic void artpec6_pcie_wait_for_phy_a6(struct artpec6_pcie *artpec6_pcie)\n{\n\tstruct dw_pcie *pci = artpec6_pcie->pci;\n\tstruct device *dev = pci->dev;\n\tu32 val;\n\tunsigned int retries;\n\n\tretries = 50;\n\tdo {\n\t\tusleep_range(1000, 2000);\n\t\tval = artpec6_pcie_readl(artpec6_pcie, NOCCFG);\n\t\tretries--;\n\t} while (retries &&\n\t\t(val & (NOCCFG_POWER_PCIE_IDLEACK | NOCCFG_POWER_PCIE_IDLE)));\n\tif (!retries)\n\t\tdev_err(dev, \"PCIe clock manager did not leave idle state\\n\");\n\n\tretries = 50;\n\tdo {\n\t\tusleep_range(1000, 2000);\n\t\tval = readl(artpec6_pcie->phy_base + PHY_STATUS);\n\t\tretries--;\n\t} while (retries && !(val & PHY_COSPLLLOCK));\n\tif (!retries)\n\t\tdev_err(dev, \"PHY PLL did not lock\\n\");\n}\n\nstatic void artpec6_pcie_wait_for_phy_a7(struct artpec6_pcie *artpec6_pcie)\n{\n\tstruct dw_pcie *pci = artpec6_pcie->pci;\n\tstruct device *dev = pci->dev;\n\tu32 val;\n\tu16 phy_status_tx, phy_status_rx;\n\tunsigned int retries;\n\n\tretries = 50;\n\tdo {\n\t\tusleep_range(1000, 2000);\n\t\tval = artpec6_pcie_readl(artpec6_pcie, NOCCFG);\n\t\tretries--;\n\t} while (retries &&\n\t\t(val & (NOCCFG_POWER_PCIE_IDLEACK | NOCCFG_POWER_PCIE_IDLE)));\n\tif (!retries)\n\t\tdev_err(dev, \"PCIe clock manager did not leave idle state\\n\");\n\n\tretries = 50;\n\tdo {\n\t\tusleep_range(1000, 2000);\n\t\tphy_status_tx = readw(artpec6_pcie->phy_base + PHY_TX_ASIC_OUT);\n\t\tphy_status_rx = readw(artpec6_pcie->phy_base + PHY_RX_ASIC_OUT);\n\t\tretries--;\n\t} while (retries && ((phy_status_tx & PHY_TX_ASIC_OUT_TX_ACK) ||\n\t\t\t\t(phy_status_rx & PHY_RX_ASIC_OUT_ACK)));\n\tif (!retries)\n\t\tdev_err(dev, \"PHY did not enter Pn state\\n\");\n}\n\nstatic void artpec6_pcie_wait_for_phy(struct artpec6_pcie *artpec6_pcie)\n{\n\tswitch (artpec6_pcie->variant) {\n\tcase ARTPEC6:\n\t\tartpec6_pcie_wait_for_phy_a6(artpec6_pcie);\n\t\tbreak;\n\tcase ARTPEC7:\n\t\tartpec6_pcie_wait_for_phy_a7(artpec6_pcie);\n\t\tbreak;\n\t}\n}\n\nstatic void artpec6_pcie_init_phy_a6(struct artpec6_pcie *artpec6_pcie)\n{\n\tu32 val;\n\n\tval = artpec6_pcie_readl(artpec6_pcie, PCIECFG);\n\tval |=  PCIECFG_RISRCREN |\t \n\t\tPCIECFG_MODE_TX_DRV_EN |\n\t\tPCIECFG_CISRREN |\t \n\t\tPCIECFG_MACRO_ENABLE;\n\tval |= PCIECFG_REFCLK_ENABLE;\n\tval &= ~PCIECFG_DBG_OEN;\n\tval &= ~PCIECFG_CLKREQ_B;\n\tartpec6_pcie_writel(artpec6_pcie, PCIECFG, val);\n\tusleep_range(5000, 6000);\n\n\tval = artpec6_pcie_readl(artpec6_pcie, NOCCFG);\n\tval |= NOCCFG_ENABLE_CLK_PCIE;\n\tartpec6_pcie_writel(artpec6_pcie, NOCCFG, val);\n\tusleep_range(20, 30);\n\n\tval = artpec6_pcie_readl(artpec6_pcie, PCIECFG);\n\tval |= PCIECFG_PCLK_ENABLE | PCIECFG_PLL_ENABLE;\n\tartpec6_pcie_writel(artpec6_pcie, PCIECFG, val);\n\tusleep_range(6000, 7000);\n\n\tval = artpec6_pcie_readl(artpec6_pcie, NOCCFG);\n\tval &= ~NOCCFG_POWER_PCIE_IDLEREQ;\n\tartpec6_pcie_writel(artpec6_pcie, NOCCFG, val);\n}\n\nstatic void artpec6_pcie_init_phy_a7(struct artpec6_pcie *artpec6_pcie)\n{\n\tstruct dw_pcie *pci = artpec6_pcie->pci;\n\tu32 val;\n\tbool extrefclk;\n\n\t \n\tval = artpec6_pcie_readl(artpec6_pcie, PCIESTAT);\n\textrefclk = !!(val & PCIESTAT_EXTREFCLK);\n\tdev_dbg(pci->dev, \"Using reference clock: %s\\n\",\n\t\textrefclk ? \"external\" : \"internal\");\n\n\tval = artpec6_pcie_readl(artpec6_pcie, PCIECFG);\n\tval |=  PCIECFG_RISRCREN |\t \n\t\tPCIECFG_PCLK_ENABLE;\n\tif (extrefclk)\n\t\tval |= PCIECFG_REFCLKSEL;\n\telse\n\t\tval &= ~PCIECFG_REFCLKSEL;\n\tartpec6_pcie_writel(artpec6_pcie, PCIECFG, val);\n\tusleep_range(10, 20);\n\n\tval = artpec6_pcie_readl(artpec6_pcie, NOCCFG);\n\tval |= NOCCFG_ENABLE_CLK_PCIE;\n\tartpec6_pcie_writel(artpec6_pcie, NOCCFG, val);\n\tusleep_range(20, 30);\n\n\tval = artpec6_pcie_readl(artpec6_pcie, NOCCFG);\n\tval &= ~NOCCFG_POWER_PCIE_IDLEREQ;\n\tartpec6_pcie_writel(artpec6_pcie, NOCCFG, val);\n}\n\nstatic void artpec6_pcie_init_phy(struct artpec6_pcie *artpec6_pcie)\n{\n\tswitch (artpec6_pcie->variant) {\n\tcase ARTPEC6:\n\t\tartpec6_pcie_init_phy_a6(artpec6_pcie);\n\t\tbreak;\n\tcase ARTPEC7:\n\t\tartpec6_pcie_init_phy_a7(artpec6_pcie);\n\t\tbreak;\n\t}\n}\n\nstatic void artpec6_pcie_assert_core_reset(struct artpec6_pcie *artpec6_pcie)\n{\n\tu32 val;\n\n\tval = artpec6_pcie_readl(artpec6_pcie, PCIECFG);\n\tswitch (artpec6_pcie->variant) {\n\tcase ARTPEC6:\n\t\tval |= PCIECFG_CORE_RESET_REQ;\n\t\tbreak;\n\tcase ARTPEC7:\n\t\tval &= ~PCIECFG_NOC_RESET;\n\t\tbreak;\n\t}\n\tartpec6_pcie_writel(artpec6_pcie, PCIECFG, val);\n}\n\nstatic void artpec6_pcie_deassert_core_reset(struct artpec6_pcie *artpec6_pcie)\n{\n\tu32 val;\n\n\tval = artpec6_pcie_readl(artpec6_pcie, PCIECFG);\n\tswitch (artpec6_pcie->variant) {\n\tcase ARTPEC6:\n\t\tval &= ~PCIECFG_CORE_RESET_REQ;\n\t\tbreak;\n\tcase ARTPEC7:\n\t\tval |= PCIECFG_NOC_RESET;\n\t\tbreak;\n\t}\n\tartpec6_pcie_writel(artpec6_pcie, PCIECFG, val);\n\tusleep_range(100, 200);\n}\n\nstatic int artpec6_pcie_host_init(struct dw_pcie_rp *pp)\n{\n\tstruct dw_pcie *pci = to_dw_pcie_from_pp(pp);\n\tstruct artpec6_pcie *artpec6_pcie = to_artpec6_pcie(pci);\n\n\tif (artpec6_pcie->variant == ARTPEC7) {\n\t\tpci->n_fts[0] = 180;\n\t\tpci->n_fts[1] = 180;\n\t}\n\tartpec6_pcie_assert_core_reset(artpec6_pcie);\n\tartpec6_pcie_init_phy(artpec6_pcie);\n\tartpec6_pcie_deassert_core_reset(artpec6_pcie);\n\tartpec6_pcie_wait_for_phy(artpec6_pcie);\n\n\treturn 0;\n}\n\nstatic const struct dw_pcie_host_ops artpec6_pcie_host_ops = {\n\t.host_init = artpec6_pcie_host_init,\n};\n\nstatic void artpec6_pcie_ep_init(struct dw_pcie_ep *ep)\n{\n\tstruct dw_pcie *pci = to_dw_pcie_from_ep(ep);\n\tstruct artpec6_pcie *artpec6_pcie = to_artpec6_pcie(pci);\n\tenum pci_barno bar;\n\n\tartpec6_pcie_assert_core_reset(artpec6_pcie);\n\tartpec6_pcie_init_phy(artpec6_pcie);\n\tartpec6_pcie_deassert_core_reset(artpec6_pcie);\n\tartpec6_pcie_wait_for_phy(artpec6_pcie);\n\n\tfor (bar = 0; bar < PCI_STD_NUM_BARS; bar++)\n\t\tdw_pcie_ep_reset_bar(pci, bar);\n}\n\nstatic int artpec6_pcie_raise_irq(struct dw_pcie_ep *ep, u8 func_no,\n\t\t\t\t  enum pci_epc_irq_type type, u16 interrupt_num)\n{\n\tstruct dw_pcie *pci = to_dw_pcie_from_ep(ep);\n\n\tswitch (type) {\n\tcase PCI_EPC_IRQ_LEGACY:\n\t\tdev_err(pci->dev, \"EP cannot trigger legacy IRQs\\n\");\n\t\treturn -EINVAL;\n\tcase PCI_EPC_IRQ_MSI:\n\t\treturn dw_pcie_ep_raise_msi_irq(ep, func_no, interrupt_num);\n\tdefault:\n\t\tdev_err(pci->dev, \"UNKNOWN IRQ type\\n\");\n\t}\n\n\treturn 0;\n}\n\nstatic const struct dw_pcie_ep_ops pcie_ep_ops = {\n\t.ep_init = artpec6_pcie_ep_init,\n\t.raise_irq = artpec6_pcie_raise_irq,\n};\n\nstatic int artpec6_pcie_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct dw_pcie *pci;\n\tstruct artpec6_pcie *artpec6_pcie;\n\tint ret;\n\tconst struct artpec_pcie_of_data *data;\n\tenum artpec_pcie_variants variant;\n\tenum dw_pcie_device_mode mode;\n\tu32 val;\n\n\tdata = of_device_get_match_data(dev);\n\tif (!data)\n\t\treturn -EINVAL;\n\n\tvariant = (enum artpec_pcie_variants)data->variant;\n\tmode = (enum dw_pcie_device_mode)data->mode;\n\n\tartpec6_pcie = devm_kzalloc(dev, sizeof(*artpec6_pcie), GFP_KERNEL);\n\tif (!artpec6_pcie)\n\t\treturn -ENOMEM;\n\n\tpci = devm_kzalloc(dev, sizeof(*pci), GFP_KERNEL);\n\tif (!pci)\n\t\treturn -ENOMEM;\n\n\tpci->dev = dev;\n\tpci->ops = &dw_pcie_ops;\n\n\tartpec6_pcie->pci = pci;\n\tartpec6_pcie->variant = variant;\n\tartpec6_pcie->mode = mode;\n\n\tartpec6_pcie->phy_base =\n\t\tdevm_platform_ioremap_resource_byname(pdev, \"phy\");\n\tif (IS_ERR(artpec6_pcie->phy_base))\n\t\treturn PTR_ERR(artpec6_pcie->phy_base);\n\n\tartpec6_pcie->regmap =\n\t\tsyscon_regmap_lookup_by_phandle(dev->of_node,\n\t\t\t\t\t\t\"axis,syscon-pcie\");\n\tif (IS_ERR(artpec6_pcie->regmap))\n\t\treturn PTR_ERR(artpec6_pcie->regmap);\n\n\tplatform_set_drvdata(pdev, artpec6_pcie);\n\n\tswitch (artpec6_pcie->mode) {\n\tcase DW_PCIE_RC_TYPE:\n\t\tif (!IS_ENABLED(CONFIG_PCIE_ARTPEC6_HOST))\n\t\t\treturn -ENODEV;\n\n\t\tpci->pp.ops = &artpec6_pcie_host_ops;\n\n\t\tret = dw_pcie_host_init(&pci->pp);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase DW_PCIE_EP_TYPE:\n\t\tif (!IS_ENABLED(CONFIG_PCIE_ARTPEC6_EP))\n\t\t\treturn -ENODEV;\n\n\t\tval = artpec6_pcie_readl(artpec6_pcie, PCIECFG);\n\t\tval &= ~PCIECFG_DEVICE_TYPE_MASK;\n\t\tartpec6_pcie_writel(artpec6_pcie, PCIECFG, val);\n\n\t\tpci->ep.ops = &pcie_ep_ops;\n\n\t\treturn dw_pcie_ep_init(&pci->ep);\n\tdefault:\n\t\tdev_err(dev, \"INVALID device type %d\\n\", artpec6_pcie->mode);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct artpec_pcie_of_data artpec6_pcie_rc_of_data = {\n\t.variant = ARTPEC6,\n\t.mode = DW_PCIE_RC_TYPE,\n};\n\nstatic const struct artpec_pcie_of_data artpec6_pcie_ep_of_data = {\n\t.variant = ARTPEC6,\n\t.mode = DW_PCIE_EP_TYPE,\n};\n\nstatic const struct artpec_pcie_of_data artpec7_pcie_rc_of_data = {\n\t.variant = ARTPEC7,\n\t.mode = DW_PCIE_RC_TYPE,\n};\n\nstatic const struct artpec_pcie_of_data artpec7_pcie_ep_of_data = {\n\t.variant = ARTPEC7,\n\t.mode = DW_PCIE_EP_TYPE,\n};\n\nstatic const struct of_device_id artpec6_pcie_of_match[] = {\n\t{\n\t\t.compatible = \"axis,artpec6-pcie\",\n\t\t.data = &artpec6_pcie_rc_of_data,\n\t},\n\t{\n\t\t.compatible = \"axis,artpec6-pcie-ep\",\n\t\t.data = &artpec6_pcie_ep_of_data,\n\t},\n\t{\n\t\t.compatible = \"axis,artpec7-pcie\",\n\t\t.data = &artpec7_pcie_rc_of_data,\n\t},\n\t{\n\t\t.compatible = \"axis,artpec7-pcie-ep\",\n\t\t.data = &artpec7_pcie_ep_of_data,\n\t},\n\t{},\n};\n\nstatic struct platform_driver artpec6_pcie_driver = {\n\t.probe = artpec6_pcie_probe,\n\t.driver = {\n\t\t.name\t= \"artpec6-pcie\",\n\t\t.of_match_table = artpec6_pcie_of_match,\n\t\t.suppress_bind_attrs = true,\n\t},\n};\nbuiltin_platform_driver(artpec6_pcie_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}