{
  "module_name": "pcie-armada8k.c",
  "hash_id": "a2847b3de81332ebc5eba62361983bc215ec69beff17e6795ff76a5ba64eeb97",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/controller/dwc/pcie-armada8k.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/of.h>\n#include <linux/pci.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n#include <linux/resource.h>\n#include <linux/of_pci.h>\n\n#include \"pcie-designware.h\"\n\n#define ARMADA8K_PCIE_MAX_LANES PCIE_LNK_X4\n\nstruct armada8k_pcie {\n\tstruct dw_pcie *pci;\n\tstruct clk *clk;\n\tstruct clk *clk_reg;\n\tstruct phy *phy[ARMADA8K_PCIE_MAX_LANES];\n\tunsigned int phy_count;\n};\n\n#define PCIE_VENDOR_REGS_OFFSET\t\t0x8000\n\n#define PCIE_GLOBAL_CONTROL_REG\t\t(PCIE_VENDOR_REGS_OFFSET + 0x0)\n#define PCIE_APP_LTSSM_EN\t\tBIT(2)\n#define PCIE_DEVICE_TYPE_SHIFT\t\t4\n#define PCIE_DEVICE_TYPE_MASK\t\t0xF\n#define PCIE_DEVICE_TYPE_RC\t\t0x4  \n\n#define PCIE_GLOBAL_STATUS_REG\t\t(PCIE_VENDOR_REGS_OFFSET + 0x8)\n#define PCIE_GLB_STS_RDLH_LINK_UP\tBIT(1)\n#define PCIE_GLB_STS_PHY_LINK_UP\tBIT(9)\n\n#define PCIE_GLOBAL_INT_CAUSE1_REG\t(PCIE_VENDOR_REGS_OFFSET + 0x1C)\n#define PCIE_GLOBAL_INT_MASK1_REG\t(PCIE_VENDOR_REGS_OFFSET + 0x20)\n#define PCIE_INT_A_ASSERT_MASK\t\tBIT(9)\n#define PCIE_INT_B_ASSERT_MASK\t\tBIT(10)\n#define PCIE_INT_C_ASSERT_MASK\t\tBIT(11)\n#define PCIE_INT_D_ASSERT_MASK\t\tBIT(12)\n\n#define PCIE_ARCACHE_TRC_REG\t\t(PCIE_VENDOR_REGS_OFFSET + 0x50)\n#define PCIE_AWCACHE_TRC_REG\t\t(PCIE_VENDOR_REGS_OFFSET + 0x54)\n#define PCIE_ARUSER_REG\t\t\t(PCIE_VENDOR_REGS_OFFSET + 0x5C)\n#define PCIE_AWUSER_REG\t\t\t(PCIE_VENDOR_REGS_OFFSET + 0x60)\n \n#define ARCACHE_DEFAULT_VALUE\t\t0x3511\n#define AWCACHE_DEFAULT_VALUE\t\t0x5311\n\n#define DOMAIN_OUTER_SHAREABLE\t\t0x2\n#define AX_USER_DOMAIN_MASK\t\t0x3\n#define AX_USER_DOMAIN_SHIFT\t\t4\n\n#define to_armada8k_pcie(x)\tdev_get_drvdata((x)->dev)\n\nstatic void armada8k_pcie_disable_phys(struct armada8k_pcie *pcie)\n{\n\tint i;\n\n\tfor (i = 0; i < ARMADA8K_PCIE_MAX_LANES; i++) {\n\t\tphy_power_off(pcie->phy[i]);\n\t\tphy_exit(pcie->phy[i]);\n\t}\n}\n\nstatic int armada8k_pcie_enable_phys(struct armada8k_pcie *pcie)\n{\n\tint ret;\n\tint i;\n\n\tfor (i = 0; i < ARMADA8K_PCIE_MAX_LANES; i++) {\n\t\tret = phy_init(pcie->phy[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = phy_set_mode_ext(pcie->phy[i], PHY_MODE_PCIE,\n\t\t\t\t       pcie->phy_count);\n\t\tif (ret) {\n\t\t\tphy_exit(pcie->phy[i]);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = phy_power_on(pcie->phy[i]);\n\t\tif (ret) {\n\t\t\tphy_exit(pcie->phy[i]);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int armada8k_pcie_setup_phys(struct armada8k_pcie *pcie)\n{\n\tstruct dw_pcie *pci = pcie->pci;\n\tstruct device *dev = pci->dev;\n\tstruct device_node *node = dev->of_node;\n\tint ret = 0;\n\tint i;\n\n\tfor (i = 0; i < ARMADA8K_PCIE_MAX_LANES; i++) {\n\t\tpcie->phy[i] = devm_of_phy_get_by_index(dev, node, i);\n\t\tif (IS_ERR(pcie->phy[i])) {\n\t\t\tif (PTR_ERR(pcie->phy[i]) != -ENODEV)\n\t\t\t\treturn PTR_ERR(pcie->phy[i]);\n\n\t\t\tpcie->phy[i] = NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\tpcie->phy_count++;\n\t}\n\n\t \n\tif (!pcie->phy_count)\n\t\tdev_warn(dev, \"No available PHY\\n\");\n\n\tret = armada8k_pcie_enable_phys(pcie);\n\tif (ret)\n\t\tdev_err(dev, \"Failed to initialize PHY(s) (%d)\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int armada8k_pcie_link_up(struct dw_pcie *pci)\n{\n\tu32 reg;\n\tu32 mask = PCIE_GLB_STS_RDLH_LINK_UP | PCIE_GLB_STS_PHY_LINK_UP;\n\n\treg = dw_pcie_readl_dbi(pci, PCIE_GLOBAL_STATUS_REG);\n\n\tif ((reg & mask) == mask)\n\t\treturn 1;\n\n\tdev_dbg(pci->dev, \"No link detected (Global-Status: 0x%08x).\\n\", reg);\n\treturn 0;\n}\n\nstatic int armada8k_pcie_start_link(struct dw_pcie *pci)\n{\n\tu32 reg;\n\n\t \n\treg = dw_pcie_readl_dbi(pci, PCIE_GLOBAL_CONTROL_REG);\n\treg |= PCIE_APP_LTSSM_EN;\n\tdw_pcie_writel_dbi(pci, PCIE_GLOBAL_CONTROL_REG, reg);\n\n\treturn 0;\n}\n\nstatic int armada8k_pcie_host_init(struct dw_pcie_rp *pp)\n{\n\tu32 reg;\n\tstruct dw_pcie *pci = to_dw_pcie_from_pp(pp);\n\n\tif (!dw_pcie_link_up(pci)) {\n\t\t \n\t\treg = dw_pcie_readl_dbi(pci, PCIE_GLOBAL_CONTROL_REG);\n\t\treg &= ~(PCIE_APP_LTSSM_EN);\n\t\tdw_pcie_writel_dbi(pci, PCIE_GLOBAL_CONTROL_REG, reg);\n\t}\n\n\t \n\treg = dw_pcie_readl_dbi(pci, PCIE_GLOBAL_CONTROL_REG);\n\treg &= ~(PCIE_DEVICE_TYPE_MASK << PCIE_DEVICE_TYPE_SHIFT);\n\treg |= PCIE_DEVICE_TYPE_RC << PCIE_DEVICE_TYPE_SHIFT;\n\tdw_pcie_writel_dbi(pci, PCIE_GLOBAL_CONTROL_REG, reg);\n\n\t \n\tdw_pcie_writel_dbi(pci, PCIE_ARCACHE_TRC_REG, ARCACHE_DEFAULT_VALUE);\n\tdw_pcie_writel_dbi(pci, PCIE_AWCACHE_TRC_REG, AWCACHE_DEFAULT_VALUE);\n\n\t \n\treg = dw_pcie_readl_dbi(pci, PCIE_ARUSER_REG);\n\treg &= ~(AX_USER_DOMAIN_MASK << AX_USER_DOMAIN_SHIFT);\n\treg |= DOMAIN_OUTER_SHAREABLE << AX_USER_DOMAIN_SHIFT;\n\tdw_pcie_writel_dbi(pci, PCIE_ARUSER_REG, reg);\n\n\treg = dw_pcie_readl_dbi(pci, PCIE_AWUSER_REG);\n\treg &= ~(AX_USER_DOMAIN_MASK << AX_USER_DOMAIN_SHIFT);\n\treg |= DOMAIN_OUTER_SHAREABLE << AX_USER_DOMAIN_SHIFT;\n\tdw_pcie_writel_dbi(pci, PCIE_AWUSER_REG, reg);\n\n\t \n\treg = dw_pcie_readl_dbi(pci, PCIE_GLOBAL_INT_MASK1_REG);\n\treg |= PCIE_INT_A_ASSERT_MASK | PCIE_INT_B_ASSERT_MASK |\n\t       PCIE_INT_C_ASSERT_MASK | PCIE_INT_D_ASSERT_MASK;\n\tdw_pcie_writel_dbi(pci, PCIE_GLOBAL_INT_MASK1_REG, reg);\n\n\treturn 0;\n}\n\nstatic irqreturn_t armada8k_pcie_irq_handler(int irq, void *arg)\n{\n\tstruct armada8k_pcie *pcie = arg;\n\tstruct dw_pcie *pci = pcie->pci;\n\tu32 val;\n\n\t \n\tval = dw_pcie_readl_dbi(pci, PCIE_GLOBAL_INT_CAUSE1_REG);\n\tdw_pcie_writel_dbi(pci, PCIE_GLOBAL_INT_CAUSE1_REG, val);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic const struct dw_pcie_host_ops armada8k_pcie_host_ops = {\n\t.host_init = armada8k_pcie_host_init,\n};\n\nstatic int armada8k_add_pcie_port(struct armada8k_pcie *pcie,\n\t\t\t\t  struct platform_device *pdev)\n{\n\tstruct dw_pcie *pci = pcie->pci;\n\tstruct dw_pcie_rp *pp = &pci->pp;\n\tstruct device *dev = &pdev->dev;\n\tint ret;\n\n\tpp->ops = &armada8k_pcie_host_ops;\n\n\tpp->irq = platform_get_irq(pdev, 0);\n\tif (pp->irq < 0)\n\t\treturn pp->irq;\n\n\tret = devm_request_irq(dev, pp->irq, armada8k_pcie_irq_handler,\n\t\t\t       IRQF_SHARED, \"armada8k-pcie\", pcie);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to request irq %d\\n\", pp->irq);\n\t\treturn ret;\n\t}\n\n\tret = dw_pcie_host_init(pp);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to initialize host: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct dw_pcie_ops dw_pcie_ops = {\n\t.link_up = armada8k_pcie_link_up,\n\t.start_link = armada8k_pcie_start_link,\n};\n\nstatic int armada8k_pcie_probe(struct platform_device *pdev)\n{\n\tstruct dw_pcie *pci;\n\tstruct armada8k_pcie *pcie;\n\tstruct device *dev = &pdev->dev;\n\tstruct resource *base;\n\tint ret;\n\n\tpcie = devm_kzalloc(dev, sizeof(*pcie), GFP_KERNEL);\n\tif (!pcie)\n\t\treturn -ENOMEM;\n\n\tpci = devm_kzalloc(dev, sizeof(*pci), GFP_KERNEL);\n\tif (!pci)\n\t\treturn -ENOMEM;\n\n\tpci->dev = dev;\n\tpci->ops = &dw_pcie_ops;\n\n\tpcie->pci = pci;\n\n\tpcie->clk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(pcie->clk))\n\t\treturn PTR_ERR(pcie->clk);\n\n\tret = clk_prepare_enable(pcie->clk);\n\tif (ret)\n\t\treturn ret;\n\n\tpcie->clk_reg = devm_clk_get(dev, \"reg\");\n\tif (pcie->clk_reg == ERR_PTR(-EPROBE_DEFER)) {\n\t\tret = -EPROBE_DEFER;\n\t\tgoto fail;\n\t}\n\tif (!IS_ERR(pcie->clk_reg)) {\n\t\tret = clk_prepare_enable(pcie->clk_reg);\n\t\tif (ret)\n\t\t\tgoto fail_clkreg;\n\t}\n\n\t \n\tbase = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"ctrl\");\n\tpci->dbi_base = devm_pci_remap_cfg_resource(dev, base);\n\tif (IS_ERR(pci->dbi_base)) {\n\t\tret = PTR_ERR(pci->dbi_base);\n\t\tgoto fail_clkreg;\n\t}\n\n\tret = armada8k_pcie_setup_phys(pcie);\n\tif (ret)\n\t\tgoto fail_clkreg;\n\n\tplatform_set_drvdata(pdev, pcie);\n\n\tret = armada8k_add_pcie_port(pcie, pdev);\n\tif (ret)\n\t\tgoto disable_phy;\n\n\treturn 0;\n\ndisable_phy:\n\tarmada8k_pcie_disable_phys(pcie);\nfail_clkreg:\n\tclk_disable_unprepare(pcie->clk_reg);\nfail:\n\tclk_disable_unprepare(pcie->clk);\n\n\treturn ret;\n}\n\nstatic const struct of_device_id armada8k_pcie_of_match[] = {\n\t{ .compatible = \"marvell,armada8k-pcie\", },\n\t{},\n};\n\nstatic struct platform_driver armada8k_pcie_driver = {\n\t.probe\t\t= armada8k_pcie_probe,\n\t.driver = {\n\t\t.name\t= \"armada8k-pcie\",\n\t\t.of_match_table = armada8k_pcie_of_match,\n\t\t.suppress_bind_attrs = true,\n\t},\n};\nbuiltin_platform_driver(armada8k_pcie_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}