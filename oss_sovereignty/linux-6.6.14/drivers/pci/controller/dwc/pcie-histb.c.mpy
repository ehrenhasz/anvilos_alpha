{
  "module_name": "pcie-histb.c",
  "hash_id": "6894ba29d9c7c962f9f3bd4ffce8cdc80ff1e702f14c5627a999152bb86772cf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/controller/dwc/pcie-histb.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/pci.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n#include <linux/resource.h>\n#include <linux/reset.h>\n\n#include \"pcie-designware.h\"\n\n#define to_histb_pcie(x)\tdev_get_drvdata((x)->dev)\n\n#define PCIE_SYS_CTRL0\t\t\t0x0000\n#define PCIE_SYS_CTRL1\t\t\t0x0004\n#define PCIE_SYS_CTRL7\t\t\t0x001C\n#define PCIE_SYS_CTRL13\t\t\t0x0034\n#define PCIE_SYS_CTRL15\t\t\t0x003C\n#define PCIE_SYS_CTRL16\t\t\t0x0040\n#define PCIE_SYS_CTRL17\t\t\t0x0044\n\n#define PCIE_SYS_STAT0\t\t\t0x0100\n#define PCIE_SYS_STAT4\t\t\t0x0110\n\n#define PCIE_RDLH_LINK_UP\t\tBIT(5)\n#define PCIE_XMLH_LINK_UP\t\tBIT(15)\n#define PCIE_ELBI_SLV_DBI_ENABLE\tBIT(21)\n#define PCIE_APP_LTSSM_ENABLE\t\tBIT(11)\n\n#define PCIE_DEVICE_TYPE_MASK\t\tGENMASK(31, 28)\n#define PCIE_WM_EP\t\t\t0\n#define PCIE_WM_LEGACY\t\t\tBIT(1)\n#define PCIE_WM_RC\t\t\tBIT(30)\n\n#define PCIE_LTSSM_STATE_MASK\t\tGENMASK(5, 0)\n#define PCIE_LTSSM_STATE_ACTIVE\t\t0x11\n\nstruct histb_pcie {\n\tstruct dw_pcie *pci;\n\tstruct clk *aux_clk;\n\tstruct clk *pipe_clk;\n\tstruct clk *sys_clk;\n\tstruct clk *bus_clk;\n\tstruct phy *phy;\n\tstruct reset_control *soft_reset;\n\tstruct reset_control *sys_reset;\n\tstruct reset_control *bus_reset;\n\tvoid __iomem *ctrl;\n\tstruct gpio_desc *reset_gpio;\n\tstruct regulator *vpcie;\n};\n\nstatic u32 histb_pcie_readl(struct histb_pcie *histb_pcie, u32 reg)\n{\n\treturn readl(histb_pcie->ctrl + reg);\n}\n\nstatic void histb_pcie_writel(struct histb_pcie *histb_pcie, u32 reg, u32 val)\n{\n\twritel(val, histb_pcie->ctrl + reg);\n}\n\nstatic void histb_pcie_dbi_w_mode(struct dw_pcie_rp *pp, bool enable)\n{\n\tstruct dw_pcie *pci = to_dw_pcie_from_pp(pp);\n\tstruct histb_pcie *hipcie = to_histb_pcie(pci);\n\tu32 val;\n\n\tval = histb_pcie_readl(hipcie, PCIE_SYS_CTRL0);\n\tif (enable)\n\t\tval |= PCIE_ELBI_SLV_DBI_ENABLE;\n\telse\n\t\tval &= ~PCIE_ELBI_SLV_DBI_ENABLE;\n\thistb_pcie_writel(hipcie, PCIE_SYS_CTRL0, val);\n}\n\nstatic void histb_pcie_dbi_r_mode(struct dw_pcie_rp *pp, bool enable)\n{\n\tstruct dw_pcie *pci = to_dw_pcie_from_pp(pp);\n\tstruct histb_pcie *hipcie = to_histb_pcie(pci);\n\tu32 val;\n\n\tval = histb_pcie_readl(hipcie, PCIE_SYS_CTRL1);\n\tif (enable)\n\t\tval |= PCIE_ELBI_SLV_DBI_ENABLE;\n\telse\n\t\tval &= ~PCIE_ELBI_SLV_DBI_ENABLE;\n\thistb_pcie_writel(hipcie, PCIE_SYS_CTRL1, val);\n}\n\nstatic u32 histb_pcie_read_dbi(struct dw_pcie *pci, void __iomem *base,\n\t\t\t       u32 reg, size_t size)\n{\n\tu32 val;\n\n\thistb_pcie_dbi_r_mode(&pci->pp, true);\n\tdw_pcie_read(base + reg, size, &val);\n\thistb_pcie_dbi_r_mode(&pci->pp, false);\n\n\treturn val;\n}\n\nstatic void histb_pcie_write_dbi(struct dw_pcie *pci, void __iomem *base,\n\t\t\t\t u32 reg, size_t size, u32 val)\n{\n\thistb_pcie_dbi_w_mode(&pci->pp, true);\n\tdw_pcie_write(base + reg, size, val);\n\thistb_pcie_dbi_w_mode(&pci->pp, false);\n}\n\nstatic int histb_pcie_rd_own_conf(struct pci_bus *bus, unsigned int devfn,\n\t\t\t\t  int where, int size, u32 *val)\n{\n\tstruct dw_pcie *pci = to_dw_pcie_from_pp(bus->sysdata);\n\n\tif (PCI_SLOT(devfn))\n\t\treturn PCIBIOS_DEVICE_NOT_FOUND;\n\n\t*val = dw_pcie_read_dbi(pci, where, size);\n\treturn PCIBIOS_SUCCESSFUL;\n}\n\nstatic int histb_pcie_wr_own_conf(struct pci_bus *bus, unsigned int devfn,\n\t\t\t\t  int where, int size, u32 val)\n{\n\tstruct dw_pcie *pci = to_dw_pcie_from_pp(bus->sysdata);\n\n\tif (PCI_SLOT(devfn))\n\t\treturn PCIBIOS_DEVICE_NOT_FOUND;\n\n\tdw_pcie_write_dbi(pci, where, size, val);\n\treturn PCIBIOS_SUCCESSFUL;\n}\n\nstatic struct pci_ops histb_pci_ops = {\n\t.read = histb_pcie_rd_own_conf,\n\t.write = histb_pcie_wr_own_conf,\n};\n\nstatic int histb_pcie_link_up(struct dw_pcie *pci)\n{\n\tstruct histb_pcie *hipcie = to_histb_pcie(pci);\n\tu32 regval;\n\tu32 status;\n\n\tregval = histb_pcie_readl(hipcie, PCIE_SYS_STAT0);\n\tstatus = histb_pcie_readl(hipcie, PCIE_SYS_STAT4);\n\tstatus &= PCIE_LTSSM_STATE_MASK;\n\tif ((regval & PCIE_XMLH_LINK_UP) && (regval & PCIE_RDLH_LINK_UP) &&\n\t    (status == PCIE_LTSSM_STATE_ACTIVE))\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic int histb_pcie_start_link(struct dw_pcie *pci)\n{\n\tstruct histb_pcie *hipcie = to_histb_pcie(pci);\n\tu32 regval;\n\n\t \n\tregval = histb_pcie_readl(hipcie, PCIE_SYS_CTRL7);\n\tregval |= PCIE_APP_LTSSM_ENABLE;\n\thistb_pcie_writel(hipcie, PCIE_SYS_CTRL7, regval);\n\n\treturn 0;\n}\n\nstatic int histb_pcie_host_init(struct dw_pcie_rp *pp)\n{\n\tstruct dw_pcie *pci = to_dw_pcie_from_pp(pp);\n\tstruct histb_pcie *hipcie = to_histb_pcie(pci);\n\tu32 regval;\n\n\tpp->bridge->ops = &histb_pci_ops;\n\n\t \n\tregval = histb_pcie_readl(hipcie, PCIE_SYS_CTRL0);\n\tregval &= ~PCIE_DEVICE_TYPE_MASK;\n\tregval |= PCIE_WM_RC;\n\thistb_pcie_writel(hipcie, PCIE_SYS_CTRL0, regval);\n\n\treturn 0;\n}\n\nstatic const struct dw_pcie_host_ops histb_pcie_host_ops = {\n\t.host_init = histb_pcie_host_init,\n};\n\nstatic void histb_pcie_host_disable(struct histb_pcie *hipcie)\n{\n\treset_control_assert(hipcie->soft_reset);\n\treset_control_assert(hipcie->sys_reset);\n\treset_control_assert(hipcie->bus_reset);\n\n\tclk_disable_unprepare(hipcie->aux_clk);\n\tclk_disable_unprepare(hipcie->pipe_clk);\n\tclk_disable_unprepare(hipcie->sys_clk);\n\tclk_disable_unprepare(hipcie->bus_clk);\n\n\tif (hipcie->reset_gpio)\n\t\tgpiod_set_value_cansleep(hipcie->reset_gpio, 1);\n\n\tif (hipcie->vpcie)\n\t\tregulator_disable(hipcie->vpcie);\n}\n\nstatic int histb_pcie_host_enable(struct dw_pcie_rp *pp)\n{\n\tstruct dw_pcie *pci = to_dw_pcie_from_pp(pp);\n\tstruct histb_pcie *hipcie = to_histb_pcie(pci);\n\tstruct device *dev = pci->dev;\n\tint ret;\n\n\t \n\tif (hipcie->vpcie) {\n\t\tret = regulator_enable(hipcie->vpcie);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"failed to enable regulator: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (hipcie->reset_gpio)\n\t\tgpiod_set_value_cansleep(hipcie->reset_gpio, 0);\n\n\tret = clk_prepare_enable(hipcie->bus_clk);\n\tif (ret) {\n\t\tdev_err(dev, \"cannot prepare/enable bus clk\\n\");\n\t\tgoto err_bus_clk;\n\t}\n\n\tret = clk_prepare_enable(hipcie->sys_clk);\n\tif (ret) {\n\t\tdev_err(dev, \"cannot prepare/enable sys clk\\n\");\n\t\tgoto err_sys_clk;\n\t}\n\n\tret = clk_prepare_enable(hipcie->pipe_clk);\n\tif (ret) {\n\t\tdev_err(dev, \"cannot prepare/enable pipe clk\\n\");\n\t\tgoto err_pipe_clk;\n\t}\n\n\tret = clk_prepare_enable(hipcie->aux_clk);\n\tif (ret) {\n\t\tdev_err(dev, \"cannot prepare/enable aux clk\\n\");\n\t\tgoto err_aux_clk;\n\t}\n\n\treset_control_assert(hipcie->soft_reset);\n\treset_control_deassert(hipcie->soft_reset);\n\n\treset_control_assert(hipcie->sys_reset);\n\treset_control_deassert(hipcie->sys_reset);\n\n\treset_control_assert(hipcie->bus_reset);\n\treset_control_deassert(hipcie->bus_reset);\n\n\treturn 0;\n\nerr_aux_clk:\n\tclk_disable_unprepare(hipcie->pipe_clk);\nerr_pipe_clk:\n\tclk_disable_unprepare(hipcie->sys_clk);\nerr_sys_clk:\n\tclk_disable_unprepare(hipcie->bus_clk);\nerr_bus_clk:\n\tif (hipcie->vpcie)\n\t\tregulator_disable(hipcie->vpcie);\n\n\treturn ret;\n}\n\nstatic const struct dw_pcie_ops dw_pcie_ops = {\n\t.read_dbi = histb_pcie_read_dbi,\n\t.write_dbi = histb_pcie_write_dbi,\n\t.link_up = histb_pcie_link_up,\n\t.start_link = histb_pcie_start_link,\n};\n\nstatic int histb_pcie_probe(struct platform_device *pdev)\n{\n\tstruct histb_pcie *hipcie;\n\tstruct dw_pcie *pci;\n\tstruct dw_pcie_rp *pp;\n\tstruct device *dev = &pdev->dev;\n\tint ret;\n\n\thipcie = devm_kzalloc(dev, sizeof(*hipcie), GFP_KERNEL);\n\tif (!hipcie)\n\t\treturn -ENOMEM;\n\n\tpci = devm_kzalloc(dev, sizeof(*pci), GFP_KERNEL);\n\tif (!pci)\n\t\treturn -ENOMEM;\n\n\thipcie->pci = pci;\n\tpp = &pci->pp;\n\tpci->dev = dev;\n\tpci->ops = &dw_pcie_ops;\n\n\thipcie->ctrl = devm_platform_ioremap_resource_byname(pdev, \"control\");\n\tif (IS_ERR(hipcie->ctrl)) {\n\t\tdev_err(dev, \"cannot get control reg base\\n\");\n\t\treturn PTR_ERR(hipcie->ctrl);\n\t}\n\n\tpci->dbi_base = devm_platform_ioremap_resource_byname(pdev, \"rc-dbi\");\n\tif (IS_ERR(pci->dbi_base)) {\n\t\tdev_err(dev, \"cannot get rc-dbi base\\n\");\n\t\treturn PTR_ERR(pci->dbi_base);\n\t}\n\n\thipcie->vpcie = devm_regulator_get_optional(dev, \"vpcie\");\n\tif (IS_ERR(hipcie->vpcie)) {\n\t\tif (PTR_ERR(hipcie->vpcie) != -ENODEV)\n\t\t\treturn PTR_ERR(hipcie->vpcie);\n\t\thipcie->vpcie = NULL;\n\t}\n\n\thipcie->reset_gpio = devm_gpiod_get_optional(dev, \"reset\",\n\t\t\t\t\t\t     GPIOD_OUT_HIGH);\n\tret = PTR_ERR_OR_ZERO(hipcie->reset_gpio);\n\tif (ret) {\n\t\tdev_err(dev, \"unable to request reset gpio: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = gpiod_set_consumer_name(hipcie->reset_gpio,\n\t\t\t\t      \"PCIe device power control\");\n\tif (ret) {\n\t\tdev_err(dev, \"unable to set reset gpio name: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\thipcie->aux_clk = devm_clk_get(dev, \"aux\");\n\tif (IS_ERR(hipcie->aux_clk)) {\n\t\tdev_err(dev, \"Failed to get PCIe aux clk\\n\");\n\t\treturn PTR_ERR(hipcie->aux_clk);\n\t}\n\n\thipcie->pipe_clk = devm_clk_get(dev, \"pipe\");\n\tif (IS_ERR(hipcie->pipe_clk)) {\n\t\tdev_err(dev, \"Failed to get PCIe pipe clk\\n\");\n\t\treturn PTR_ERR(hipcie->pipe_clk);\n\t}\n\n\thipcie->sys_clk = devm_clk_get(dev, \"sys\");\n\tif (IS_ERR(hipcie->sys_clk)) {\n\t\tdev_err(dev, \"Failed to get PCIEe sys clk\\n\");\n\t\treturn PTR_ERR(hipcie->sys_clk);\n\t}\n\n\thipcie->bus_clk = devm_clk_get(dev, \"bus\");\n\tif (IS_ERR(hipcie->bus_clk)) {\n\t\tdev_err(dev, \"Failed to get PCIe bus clk\\n\");\n\t\treturn PTR_ERR(hipcie->bus_clk);\n\t}\n\n\thipcie->soft_reset = devm_reset_control_get(dev, \"soft\");\n\tif (IS_ERR(hipcie->soft_reset)) {\n\t\tdev_err(dev, \"couldn't get soft reset\\n\");\n\t\treturn PTR_ERR(hipcie->soft_reset);\n\t}\n\n\thipcie->sys_reset = devm_reset_control_get(dev, \"sys\");\n\tif (IS_ERR(hipcie->sys_reset)) {\n\t\tdev_err(dev, \"couldn't get sys reset\\n\");\n\t\treturn PTR_ERR(hipcie->sys_reset);\n\t}\n\n\thipcie->bus_reset = devm_reset_control_get(dev, \"bus\");\n\tif (IS_ERR(hipcie->bus_reset)) {\n\t\tdev_err(dev, \"couldn't get bus reset\\n\");\n\t\treturn PTR_ERR(hipcie->bus_reset);\n\t}\n\n\thipcie->phy = devm_phy_get(dev, \"phy\");\n\tif (IS_ERR(hipcie->phy)) {\n\t\tdev_info(dev, \"no pcie-phy found\\n\");\n\t\thipcie->phy = NULL;\n\t\t \n\t} else {\n\t\tphy_init(hipcie->phy);\n\t}\n\n\tpp->ops = &histb_pcie_host_ops;\n\n\tplatform_set_drvdata(pdev, hipcie);\n\n\tret = histb_pcie_host_enable(pp);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to enable host\\n\");\n\t\treturn ret;\n\t}\n\n\tret = dw_pcie_host_init(pp);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to initialize host\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void histb_pcie_remove(struct platform_device *pdev)\n{\n\tstruct histb_pcie *hipcie = platform_get_drvdata(pdev);\n\n\thistb_pcie_host_disable(hipcie);\n\n\tif (hipcie->phy)\n\t\tphy_exit(hipcie->phy);\n}\n\nstatic const struct of_device_id histb_pcie_of_match[] = {\n\t{ .compatible = \"hisilicon,hi3798cv200-pcie\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, histb_pcie_of_match);\n\nstatic struct platform_driver histb_pcie_platform_driver = {\n\t.probe\t= histb_pcie_probe,\n\t.remove_new = histb_pcie_remove,\n\t.driver = {\n\t\t.name = \"histb-pcie\",\n\t\t.of_match_table = histb_pcie_of_match,\n\t},\n};\nmodule_platform_driver(histb_pcie_platform_driver);\n\nMODULE_DESCRIPTION(\"HiSilicon STB PCIe host controller driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}