{
  "module_name": "pcie-mobiveil.c",
  "hash_id": "73d9e37834d0485ff6e4171875f29d04dac260e18a142b51218868ad391e595c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/controller/mobiveil/pcie-mobiveil.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/pci.h>\n#include <linux/platform_device.h>\n\n#include \"pcie-mobiveil.h\"\n\n \nstatic void mobiveil_pcie_sel_page(struct mobiveil_pcie *pcie, u8 pg_idx)\n{\n\tu32 val;\n\n\tval = readl(pcie->csr_axi_slave_base + PAB_CTRL);\n\tval &= ~(PAGE_SEL_MASK << PAGE_SEL_SHIFT);\n\tval |= (pg_idx & PAGE_SEL_MASK) << PAGE_SEL_SHIFT;\n\n\twritel(val, pcie->csr_axi_slave_base + PAB_CTRL);\n}\n\nstatic void __iomem *mobiveil_pcie_comp_addr(struct mobiveil_pcie *pcie,\n\t\t\t\t\t     u32 off)\n{\n\tif (off < PAGED_ADDR_BNDRY) {\n\t\t \n\t\tmobiveil_pcie_sel_page(pcie, 0);\n\t\treturn pcie->csr_axi_slave_base + off;\n\t}\n\n\tmobiveil_pcie_sel_page(pcie, OFFSET_TO_PAGE_IDX(off));\n\treturn pcie->csr_axi_slave_base + OFFSET_TO_PAGE_ADDR(off);\n}\n\nstatic int mobiveil_pcie_read(void __iomem *addr, int size, u32 *val)\n{\n\tif ((uintptr_t)addr & (size - 1)) {\n\t\t*val = 0;\n\t\treturn PCIBIOS_BAD_REGISTER_NUMBER;\n\t}\n\n\tswitch (size) {\n\tcase 4:\n\t\t*val = readl(addr);\n\t\tbreak;\n\tcase 2:\n\t\t*val = readw(addr);\n\t\tbreak;\n\tcase 1:\n\t\t*val = readb(addr);\n\t\tbreak;\n\tdefault:\n\t\t*val = 0;\n\t\treturn PCIBIOS_BAD_REGISTER_NUMBER;\n\t}\n\n\treturn PCIBIOS_SUCCESSFUL;\n}\n\nstatic int mobiveil_pcie_write(void __iomem *addr, int size, u32 val)\n{\n\tif ((uintptr_t)addr & (size - 1))\n\t\treturn PCIBIOS_BAD_REGISTER_NUMBER;\n\n\tswitch (size) {\n\tcase 4:\n\t\twritel(val, addr);\n\t\tbreak;\n\tcase 2:\n\t\twritew(val, addr);\n\t\tbreak;\n\tcase 1:\n\t\twriteb(val, addr);\n\t\tbreak;\n\tdefault:\n\t\treturn PCIBIOS_BAD_REGISTER_NUMBER;\n\t}\n\n\treturn PCIBIOS_SUCCESSFUL;\n}\n\nu32 mobiveil_csr_read(struct mobiveil_pcie *pcie, u32 off, size_t size)\n{\n\tvoid __iomem *addr;\n\tu32 val;\n\tint ret;\n\n\taddr = mobiveil_pcie_comp_addr(pcie, off);\n\n\tret = mobiveil_pcie_read(addr, size, &val);\n\tif (ret)\n\t\tdev_err(&pcie->pdev->dev, \"read CSR address failed\\n\");\n\n\treturn val;\n}\n\nvoid mobiveil_csr_write(struct mobiveil_pcie *pcie, u32 val, u32 off,\n\t\t\t       size_t size)\n{\n\tvoid __iomem *addr;\n\tint ret;\n\n\taddr = mobiveil_pcie_comp_addr(pcie, off);\n\n\tret = mobiveil_pcie_write(addr, size, val);\n\tif (ret)\n\t\tdev_err(&pcie->pdev->dev, \"write CSR address failed\\n\");\n}\n\nbool mobiveil_pcie_link_up(struct mobiveil_pcie *pcie)\n{\n\tif (pcie->ops->link_up)\n\t\treturn pcie->ops->link_up(pcie);\n\n\treturn (mobiveil_csr_readl(pcie, LTSSM_STATUS) &\n\t\tLTSSM_STATUS_L0_MASK) == LTSSM_STATUS_L0;\n}\n\nvoid program_ib_windows(struct mobiveil_pcie *pcie, int win_num,\n\t\t\tu64 cpu_addr, u64 pci_addr, u32 type, u64 size)\n{\n\tu32 value;\n\tu64 size64 = ~(size - 1);\n\n\tif (win_num >= pcie->ppio_wins) {\n\t\tdev_err(&pcie->pdev->dev,\n\t\t\t\"ERROR: max inbound windows reached !\\n\");\n\t\treturn;\n\t}\n\n\tvalue = mobiveil_csr_readl(pcie, PAB_PEX_AMAP_CTRL(win_num));\n\tvalue &= ~(AMAP_CTRL_TYPE_MASK << AMAP_CTRL_TYPE_SHIFT | WIN_SIZE_MASK);\n\tvalue |= type << AMAP_CTRL_TYPE_SHIFT | 1 << AMAP_CTRL_EN_SHIFT |\n\t\t (lower_32_bits(size64) & WIN_SIZE_MASK);\n\tmobiveil_csr_writel(pcie, value, PAB_PEX_AMAP_CTRL(win_num));\n\n\tmobiveil_csr_writel(pcie, upper_32_bits(size64),\n\t\t\t    PAB_EXT_PEX_AMAP_SIZEN(win_num));\n\n\tmobiveil_csr_writel(pcie, lower_32_bits(cpu_addr),\n\t\t\t    PAB_PEX_AMAP_AXI_WIN(win_num));\n\tmobiveil_csr_writel(pcie, upper_32_bits(cpu_addr),\n\t\t\t    PAB_EXT_PEX_AMAP_AXI_WIN(win_num));\n\n\tmobiveil_csr_writel(pcie, lower_32_bits(pci_addr),\n\t\t\t    PAB_PEX_AMAP_PEX_WIN_L(win_num));\n\tmobiveil_csr_writel(pcie, upper_32_bits(pci_addr),\n\t\t\t    PAB_PEX_AMAP_PEX_WIN_H(win_num));\n\n\tpcie->ib_wins_configured++;\n}\n\n \nvoid program_ob_windows(struct mobiveil_pcie *pcie, int win_num,\n\t\t\tu64 cpu_addr, u64 pci_addr, u32 type, u64 size)\n{\n\tu32 value;\n\tu64 size64 = ~(size - 1);\n\n\tif (win_num >= pcie->apio_wins) {\n\t\tdev_err(&pcie->pdev->dev,\n\t\t\t\"ERROR: max outbound windows reached !\\n\");\n\t\treturn;\n\t}\n\n\t \n\tvalue = mobiveil_csr_readl(pcie, PAB_AXI_AMAP_CTRL(win_num));\n\tvalue &= ~(WIN_TYPE_MASK << WIN_TYPE_SHIFT | WIN_SIZE_MASK);\n\tvalue |= 1 << WIN_ENABLE_SHIFT | type << WIN_TYPE_SHIFT |\n\t\t (lower_32_bits(size64) & WIN_SIZE_MASK);\n\tmobiveil_csr_writel(pcie, value, PAB_AXI_AMAP_CTRL(win_num));\n\n\tmobiveil_csr_writel(pcie, upper_32_bits(size64),\n\t\t\t    PAB_EXT_AXI_AMAP_SIZE(win_num));\n\n\t \n\tmobiveil_csr_writel(pcie,\n\t\t\t    lower_32_bits(cpu_addr) & (~AXI_WINDOW_ALIGN_MASK),\n\t\t\t    PAB_AXI_AMAP_AXI_WIN(win_num));\n\tmobiveil_csr_writel(pcie, upper_32_bits(cpu_addr),\n\t\t\t    PAB_EXT_AXI_AMAP_AXI_WIN(win_num));\n\n\tmobiveil_csr_writel(pcie, lower_32_bits(pci_addr),\n\t\t\t    PAB_AXI_AMAP_PEX_WIN_L(win_num));\n\tmobiveil_csr_writel(pcie, upper_32_bits(pci_addr),\n\t\t\t    PAB_AXI_AMAP_PEX_WIN_H(win_num));\n\n\tpcie->ob_wins_configured++;\n}\n\nint mobiveil_bringup_link(struct mobiveil_pcie *pcie)\n{\n\tint retries;\n\n\t \n\tfor (retries = 0; retries < LINK_WAIT_MAX_RETRIES; retries++) {\n\t\tif (mobiveil_pcie_link_up(pcie))\n\t\t\treturn 0;\n\n\t\tusleep_range(LINK_WAIT_MIN, LINK_WAIT_MAX);\n\t}\n\n\tdev_err(&pcie->pdev->dev, \"link never came up\\n\");\n\n\treturn -ETIMEDOUT;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}