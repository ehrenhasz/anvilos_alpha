{
  "module_name": "pcie-mobiveil-host.c",
  "hash_id": "84703b6ed8e1df7ccc380304617eaeccab2b6d94dcd0a1ddf520910d4e8c5d4c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/controller/mobiveil/pcie-mobiveil-host.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/irqchip/chained_irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/of_pci.h>\n#include <linux/pci.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n\n#include \"pcie-mobiveil.h\"\n\nstatic bool mobiveil_pcie_valid_device(struct pci_bus *bus, unsigned int devfn)\n{\n\t \n\tif (pci_is_root_bus(bus) && (devfn > 0))\n\t\treturn false;\n\n\t \n\tif ((bus->primary == to_pci_host_bridge(bus->bridge)->busnr) && (PCI_SLOT(devfn) > 0))\n\t\treturn false;\n\n\treturn true;\n}\n\n \nstatic void __iomem *mobiveil_pcie_map_bus(struct pci_bus *bus,\n\t\t\t\t\t   unsigned int devfn, int where)\n{\n\tstruct mobiveil_pcie *pcie = bus->sysdata;\n\tstruct mobiveil_root_port *rp = &pcie->rp;\n\tu32 value;\n\n\tif (!mobiveil_pcie_valid_device(bus, devfn))\n\t\treturn NULL;\n\n\t \n\tif (pci_is_root_bus(bus))\n\t\treturn pcie->csr_axi_slave_base + where;\n\n\t \n\tvalue = bus->number << PAB_BUS_SHIFT |\n\t\tPCI_SLOT(devfn) << PAB_DEVICE_SHIFT |\n\t\tPCI_FUNC(devfn) << PAB_FUNCTION_SHIFT;\n\n\tmobiveil_csr_writel(pcie, value, PAB_AXI_AMAP_PEX_WIN_L(WIN_NUM_0));\n\n\treturn rp->config_axi_slave_base + where;\n}\n\nstatic struct pci_ops mobiveil_pcie_ops = {\n\t.map_bus = mobiveil_pcie_map_bus,\n\t.read = pci_generic_config_read,\n\t.write = pci_generic_config_write,\n};\n\nstatic void mobiveil_pcie_isr(struct irq_desc *desc)\n{\n\tstruct irq_chip *chip = irq_desc_get_chip(desc);\n\tstruct mobiveil_pcie *pcie = irq_desc_get_handler_data(desc);\n\tstruct device *dev = &pcie->pdev->dev;\n\tstruct mobiveil_root_port *rp = &pcie->rp;\n\tstruct mobiveil_msi *msi = &rp->msi;\n\tu32 msi_data, msi_addr_lo, msi_addr_hi;\n\tu32 intr_status, msi_status;\n\tunsigned long shifted_status;\n\tu32 bit, val, mask;\n\n\t \n\n\tchained_irq_enter(chip, desc);\n\n\t \n\tval = mobiveil_csr_readl(pcie, PAB_INTP_AMBA_MISC_STAT);\n\tmask = mobiveil_csr_readl(pcie, PAB_INTP_AMBA_MISC_ENB);\n\tintr_status = val & mask;\n\n\t \n\tif (intr_status & PAB_INTP_INTX_MASK) {\n\t\tshifted_status = mobiveil_csr_readl(pcie,\n\t\t\t\t\t\t    PAB_INTP_AMBA_MISC_STAT);\n\t\tshifted_status &= PAB_INTP_INTX_MASK;\n\t\tshifted_status >>= PAB_INTX_START;\n\t\tdo {\n\t\t\tfor_each_set_bit(bit, &shifted_status, PCI_NUM_INTX) {\n\t\t\t\tint ret;\n\t\t\t\tret = generic_handle_domain_irq(rp->intx_domain,\n\t\t\t\t\t\t\t\tbit + 1);\n\t\t\t\tif (ret)\n\t\t\t\t\tdev_err_ratelimited(dev, \"unexpected IRQ, INT%d\\n\",\n\t\t\t\t\t\t\t    bit);\n\n\t\t\t\t \n\t\t\t\tmobiveil_csr_writel(pcie,\n\t\t\t\t\t\t    1 << (PAB_INTX_START + bit),\n\t\t\t\t\t\t    PAB_INTP_AMBA_MISC_STAT);\n\t\t\t}\n\n\t\t\tshifted_status = mobiveil_csr_readl(pcie,\n\t\t\t\t\t\t\t    PAB_INTP_AMBA_MISC_STAT);\n\t\t\tshifted_status &= PAB_INTP_INTX_MASK;\n\t\t\tshifted_status >>= PAB_INTX_START;\n\t\t} while (shifted_status != 0);\n\t}\n\n\t \n\tmsi_status = readl_relaxed(pcie->apb_csr_base + MSI_STATUS_OFFSET);\n\n\t \n\twhile (msi_status & 1) {\n\t\tmsi_data = readl_relaxed(pcie->apb_csr_base + MSI_DATA_OFFSET);\n\n\t\t \n\t\tmsi_addr_lo = readl_relaxed(pcie->apb_csr_base +\n\t\t\t\t\t    MSI_ADDR_L_OFFSET);\n\t\tmsi_addr_hi = readl_relaxed(pcie->apb_csr_base +\n\t\t\t\t\t    MSI_ADDR_H_OFFSET);\n\t\tdev_dbg(dev, \"MSI registers, data: %08x, addr: %08x:%08x\\n\",\n\t\t\tmsi_data, msi_addr_hi, msi_addr_lo);\n\n\t\tgeneric_handle_domain_irq(msi->dev_domain, msi_data);\n\n\t\tmsi_status = readl_relaxed(pcie->apb_csr_base +\n\t\t\t\t\t   MSI_STATUS_OFFSET);\n\t}\n\n\t \n\tmobiveil_csr_writel(pcie, intr_status, PAB_INTP_AMBA_MISC_STAT);\n\tchained_irq_exit(chip, desc);\n}\n\nstatic int mobiveil_pcie_parse_dt(struct mobiveil_pcie *pcie)\n{\n\tstruct device *dev = &pcie->pdev->dev;\n\tstruct platform_device *pdev = pcie->pdev;\n\tstruct device_node *node = dev->of_node;\n\tstruct mobiveil_root_port *rp = &pcie->rp;\n\tstruct resource *res;\n\n\t \n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM,\n\t\t\t\t\t   \"config_axi_slave\");\n\trp->config_axi_slave_base = devm_pci_remap_cfg_resource(dev, res);\n\tif (IS_ERR(rp->config_axi_slave_base))\n\t\treturn PTR_ERR(rp->config_axi_slave_base);\n\trp->ob_io_res = res;\n\n\t \n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM,\n\t\t\t\t\t   \"csr_axi_slave\");\n\tpcie->csr_axi_slave_base = devm_pci_remap_cfg_resource(dev, res);\n\tif (IS_ERR(pcie->csr_axi_slave_base))\n\t\treturn PTR_ERR(pcie->csr_axi_slave_base);\n\tpcie->pcie_reg_base = res->start;\n\n\t \n\tif (of_property_read_u32(node, \"apio-wins\", &pcie->apio_wins))\n\t\tpcie->apio_wins = MAX_PIO_WINDOWS;\n\n\tif (of_property_read_u32(node, \"ppio-wins\", &pcie->ppio_wins))\n\t\tpcie->ppio_wins = MAX_PIO_WINDOWS;\n\n\treturn 0;\n}\n\nstatic void mobiveil_pcie_enable_msi(struct mobiveil_pcie *pcie)\n{\n\tphys_addr_t msg_addr = pcie->pcie_reg_base;\n\tstruct mobiveil_msi *msi = &pcie->rp.msi;\n\n\tmsi->num_of_vectors = PCI_NUM_MSI;\n\tmsi->msi_pages_phys = (phys_addr_t)msg_addr;\n\n\twritel_relaxed(lower_32_bits(msg_addr),\n\t\t       pcie->apb_csr_base + MSI_BASE_LO_OFFSET);\n\twritel_relaxed(upper_32_bits(msg_addr),\n\t\t       pcie->apb_csr_base + MSI_BASE_HI_OFFSET);\n\twritel_relaxed(4096, pcie->apb_csr_base + MSI_SIZE_OFFSET);\n\twritel_relaxed(1, pcie->apb_csr_base + MSI_ENABLE_OFFSET);\n}\n\nint mobiveil_host_init(struct mobiveil_pcie *pcie, bool reinit)\n{\n\tstruct mobiveil_root_port *rp = &pcie->rp;\n\tstruct pci_host_bridge *bridge = rp->bridge;\n\tu32 value, pab_ctrl, type;\n\tstruct resource_entry *win;\n\n\tpcie->ib_wins_configured = 0;\n\tpcie->ob_wins_configured = 0;\n\n\tif (!reinit) {\n\t\t \n\t\tvalue = mobiveil_csr_readl(pcie, PCI_PRIMARY_BUS);\n\t\tvalue &= 0xff000000;\n\t\tvalue |= 0x00ff0100;\n\t\tmobiveil_csr_writel(pcie, value, PCI_PRIMARY_BUS);\n\t}\n\n\t \n\tvalue = mobiveil_csr_readl(pcie, PCI_COMMAND);\n\tvalue |= PCI_COMMAND_IO | PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER;\n\tmobiveil_csr_writel(pcie, value, PCI_COMMAND);\n\n\t \n\tpab_ctrl = mobiveil_csr_readl(pcie, PAB_CTRL);\n\tpab_ctrl |= (1 << AMBA_PIO_ENABLE_SHIFT) | (1 << PEX_PIO_ENABLE_SHIFT);\n\tmobiveil_csr_writel(pcie, pab_ctrl, PAB_CTRL);\n\n\t \n\tvalue = mobiveil_csr_readl(pcie, PAB_AXI_PIO_CTRL);\n\tvalue |= APIO_EN_MASK;\n\tmobiveil_csr_writel(pcie, value, PAB_AXI_PIO_CTRL);\n\n\t \n\tvalue = mobiveil_csr_readl(pcie, PAB_PEX_PIO_CTRL);\n\tvalue |= 1 << PIO_ENABLE_SHIFT;\n\tmobiveil_csr_writel(pcie, value, PAB_PEX_PIO_CTRL);\n\n\t \n\n\t \n\tprogram_ob_windows(pcie, WIN_NUM_0, rp->ob_io_res->start, 0,\n\t\t\t   CFG_WINDOW_TYPE, resource_size(rp->ob_io_res));\n\n\t \n\tprogram_ib_windows(pcie, WIN_NUM_0, 0, 0, MEM_WINDOW_TYPE, IB_WIN_SIZE);\n\n\t \n\tresource_list_for_each_entry(win, &bridge->windows) {\n\t\tif (resource_type(win->res) == IORESOURCE_MEM)\n\t\t\ttype = MEM_WINDOW_TYPE;\n\t\telse if (resource_type(win->res) == IORESOURCE_IO)\n\t\t\ttype = IO_WINDOW_TYPE;\n\t\telse\n\t\t\tcontinue;\n\n\t\t \n\t\tprogram_ob_windows(pcie, pcie->ob_wins_configured,\n\t\t\t\t   win->res->start,\n\t\t\t\t   win->res->start - win->offset,\n\t\t\t\t   type, resource_size(win->res));\n\t}\n\n\t \n\tvalue = mobiveil_csr_readl(pcie, PAB_INTP_AXI_PIO_CLASS);\n\tvalue &= 0xff;\n\tvalue |= PCI_CLASS_BRIDGE_PCI_NORMAL << 8;\n\tmobiveil_csr_writel(pcie, value, PAB_INTP_AXI_PIO_CLASS);\n\n\treturn 0;\n}\n\nstatic void mobiveil_mask_intx_irq(struct irq_data *data)\n{\n\tstruct mobiveil_pcie *pcie = irq_data_get_irq_chip_data(data);\n\tstruct mobiveil_root_port *rp;\n\tunsigned long flags;\n\tu32 mask, shifted_val;\n\n\trp = &pcie->rp;\n\tmask = 1 << ((data->hwirq + PAB_INTX_START) - 1);\n\traw_spin_lock_irqsave(&rp->intx_mask_lock, flags);\n\tshifted_val = mobiveil_csr_readl(pcie, PAB_INTP_AMBA_MISC_ENB);\n\tshifted_val &= ~mask;\n\tmobiveil_csr_writel(pcie, shifted_val, PAB_INTP_AMBA_MISC_ENB);\n\traw_spin_unlock_irqrestore(&rp->intx_mask_lock, flags);\n}\n\nstatic void mobiveil_unmask_intx_irq(struct irq_data *data)\n{\n\tstruct mobiveil_pcie *pcie = irq_data_get_irq_chip_data(data);\n\tstruct mobiveil_root_port *rp;\n\tunsigned long flags;\n\tu32 shifted_val, mask;\n\n\trp = &pcie->rp;\n\tmask = 1 << ((data->hwirq + PAB_INTX_START) - 1);\n\traw_spin_lock_irqsave(&rp->intx_mask_lock, flags);\n\tshifted_val = mobiveil_csr_readl(pcie, PAB_INTP_AMBA_MISC_ENB);\n\tshifted_val |= mask;\n\tmobiveil_csr_writel(pcie, shifted_val, PAB_INTP_AMBA_MISC_ENB);\n\traw_spin_unlock_irqrestore(&rp->intx_mask_lock, flags);\n}\n\nstatic struct irq_chip intx_irq_chip = {\n\t.name = \"mobiveil_pcie:intx\",\n\t.irq_enable = mobiveil_unmask_intx_irq,\n\t.irq_disable = mobiveil_mask_intx_irq,\n\t.irq_mask = mobiveil_mask_intx_irq,\n\t.irq_unmask = mobiveil_unmask_intx_irq,\n};\n\n \nstatic int mobiveil_pcie_intx_map(struct irq_domain *domain, unsigned int irq,\n\t\t\t\t  irq_hw_number_t hwirq)\n{\n\tirq_set_chip_and_handler(irq, &intx_irq_chip, handle_level_irq);\n\tirq_set_chip_data(irq, domain->host_data);\n\n\treturn 0;\n}\n\n \nstatic const struct irq_domain_ops intx_domain_ops = {\n\t.map = mobiveil_pcie_intx_map,\n};\n\nstatic struct irq_chip mobiveil_msi_irq_chip = {\n\t.name = \"Mobiveil PCIe MSI\",\n\t.irq_mask = pci_msi_mask_irq,\n\t.irq_unmask = pci_msi_unmask_irq,\n};\n\nstatic struct msi_domain_info mobiveil_msi_domain_info = {\n\t.flags\t= (MSI_FLAG_USE_DEF_DOM_OPS | MSI_FLAG_USE_DEF_CHIP_OPS |\n\t\t   MSI_FLAG_PCI_MSIX),\n\t.chip\t= &mobiveil_msi_irq_chip,\n};\n\nstatic void mobiveil_compose_msi_msg(struct irq_data *data, struct msi_msg *msg)\n{\n\tstruct mobiveil_pcie *pcie = irq_data_get_irq_chip_data(data);\n\tphys_addr_t addr = pcie->pcie_reg_base + (data->hwirq * sizeof(int));\n\n\tmsg->address_lo = lower_32_bits(addr);\n\tmsg->address_hi = upper_32_bits(addr);\n\tmsg->data = data->hwirq;\n\n\tdev_dbg(&pcie->pdev->dev, \"msi#%d address_hi %#x address_lo %#x\\n\",\n\t\t(int)data->hwirq, msg->address_hi, msg->address_lo);\n}\n\nstatic int mobiveil_msi_set_affinity(struct irq_data *irq_data,\n\t\t\t\t     const struct cpumask *mask, bool force)\n{\n\treturn -EINVAL;\n}\n\nstatic struct irq_chip mobiveil_msi_bottom_irq_chip = {\n\t.name\t\t\t= \"Mobiveil MSI\",\n\t.irq_compose_msi_msg\t= mobiveil_compose_msi_msg,\n\t.irq_set_affinity\t= mobiveil_msi_set_affinity,\n};\n\nstatic int mobiveil_irq_msi_domain_alloc(struct irq_domain *domain,\n\t\t\t\t\t unsigned int virq,\n\t\t\t\t\t unsigned int nr_irqs, void *args)\n{\n\tstruct mobiveil_pcie *pcie = domain->host_data;\n\tstruct mobiveil_msi *msi = &pcie->rp.msi;\n\tunsigned long bit;\n\n\tWARN_ON(nr_irqs != 1);\n\tmutex_lock(&msi->lock);\n\n\tbit = find_first_zero_bit(msi->msi_irq_in_use, msi->num_of_vectors);\n\tif (bit >= msi->num_of_vectors) {\n\t\tmutex_unlock(&msi->lock);\n\t\treturn -ENOSPC;\n\t}\n\n\tset_bit(bit, msi->msi_irq_in_use);\n\n\tmutex_unlock(&msi->lock);\n\n\tirq_domain_set_info(domain, virq, bit, &mobiveil_msi_bottom_irq_chip,\n\t\t\t    domain->host_data, handle_level_irq, NULL, NULL);\n\treturn 0;\n}\n\nstatic void mobiveil_irq_msi_domain_free(struct irq_domain *domain,\n\t\t\t\t\t unsigned int virq,\n\t\t\t\t\t unsigned int nr_irqs)\n{\n\tstruct irq_data *d = irq_domain_get_irq_data(domain, virq);\n\tstruct mobiveil_pcie *pcie = irq_data_get_irq_chip_data(d);\n\tstruct mobiveil_msi *msi = &pcie->rp.msi;\n\n\tmutex_lock(&msi->lock);\n\n\tif (!test_bit(d->hwirq, msi->msi_irq_in_use))\n\t\tdev_err(&pcie->pdev->dev, \"trying to free unused MSI#%lu\\n\",\n\t\t\td->hwirq);\n\telse\n\t\t__clear_bit(d->hwirq, msi->msi_irq_in_use);\n\n\tmutex_unlock(&msi->lock);\n}\nstatic const struct irq_domain_ops msi_domain_ops = {\n\t.alloc\t= mobiveil_irq_msi_domain_alloc,\n\t.free\t= mobiveil_irq_msi_domain_free,\n};\n\nstatic int mobiveil_allocate_msi_domains(struct mobiveil_pcie *pcie)\n{\n\tstruct device *dev = &pcie->pdev->dev;\n\tstruct fwnode_handle *fwnode = of_node_to_fwnode(dev->of_node);\n\tstruct mobiveil_msi *msi = &pcie->rp.msi;\n\n\tmutex_init(&msi->lock);\n\tmsi->dev_domain = irq_domain_add_linear(NULL, msi->num_of_vectors,\n\t\t\t\t\t\t&msi_domain_ops, pcie);\n\tif (!msi->dev_domain) {\n\t\tdev_err(dev, \"failed to create IRQ domain\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tmsi->msi_domain = pci_msi_create_irq_domain(fwnode,\n\t\t\t\t\t\t    &mobiveil_msi_domain_info,\n\t\t\t\t\t\t    msi->dev_domain);\n\tif (!msi->msi_domain) {\n\t\tdev_err(dev, \"failed to create MSI domain\\n\");\n\t\tirq_domain_remove(msi->dev_domain);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic int mobiveil_pcie_init_irq_domain(struct mobiveil_pcie *pcie)\n{\n\tstruct device *dev = &pcie->pdev->dev;\n\tstruct device_node *node = dev->of_node;\n\tstruct mobiveil_root_port *rp = &pcie->rp;\n\n\t \n\trp->intx_domain = irq_domain_add_linear(node, PCI_NUM_INTX,\n\t\t\t\t\t\t&intx_domain_ops, pcie);\n\n\tif (!rp->intx_domain) {\n\t\tdev_err(dev, \"Failed to get a INTx IRQ domain\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\traw_spin_lock_init(&rp->intx_mask_lock);\n\n\t \n\treturn mobiveil_allocate_msi_domains(pcie);\n}\n\nstatic int mobiveil_pcie_integrated_interrupt_init(struct mobiveil_pcie *pcie)\n{\n\tstruct platform_device *pdev = pcie->pdev;\n\tstruct device *dev = &pdev->dev;\n\tstruct mobiveil_root_port *rp = &pcie->rp;\n\tstruct resource *res;\n\tint ret;\n\n\t \n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"apb_csr\");\n\tpcie->apb_csr_base = devm_pci_remap_cfg_resource(dev, res);\n\tif (IS_ERR(pcie->apb_csr_base))\n\t\treturn PTR_ERR(pcie->apb_csr_base);\n\n\t \n\tmobiveil_pcie_enable_msi(pcie);\n\n\trp->irq = platform_get_irq(pdev, 0);\n\tif (rp->irq < 0)\n\t\treturn rp->irq;\n\n\t \n\tret = mobiveil_pcie_init_irq_domain(pcie);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed creating IRQ Domain\\n\");\n\t\treturn ret;\n\t}\n\n\tirq_set_chained_handler_and_data(rp->irq, mobiveil_pcie_isr, pcie);\n\n\t \n\tmobiveil_csr_writel(pcie, (PAB_INTP_INTX_MASK | PAB_INTP_MSI_MASK),\n\t\t\t    PAB_INTP_AMBA_MISC_ENB);\n\n\n\treturn 0;\n}\n\nstatic int mobiveil_pcie_interrupt_init(struct mobiveil_pcie *pcie)\n{\n\tstruct mobiveil_root_port *rp = &pcie->rp;\n\n\tif (rp->ops->interrupt_init)\n\t\treturn rp->ops->interrupt_init(pcie);\n\n\treturn mobiveil_pcie_integrated_interrupt_init(pcie);\n}\n\nstatic bool mobiveil_pcie_is_bridge(struct mobiveil_pcie *pcie)\n{\n\tu32 header_type;\n\n\theader_type = mobiveil_csr_readb(pcie, PCI_HEADER_TYPE);\n\theader_type &= 0x7f;\n\n\treturn header_type == PCI_HEADER_TYPE_BRIDGE;\n}\n\nint mobiveil_pcie_host_probe(struct mobiveil_pcie *pcie)\n{\n\tstruct mobiveil_root_port *rp = &pcie->rp;\n\tstruct pci_host_bridge *bridge = rp->bridge;\n\tstruct device *dev = &pcie->pdev->dev;\n\tint ret;\n\n\tret = mobiveil_pcie_parse_dt(pcie);\n\tif (ret) {\n\t\tdev_err(dev, \"Parsing DT failed, ret: %x\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (!mobiveil_pcie_is_bridge(pcie))\n\t\treturn -ENODEV;\n\n\t \n\tret = mobiveil_host_init(pcie, false);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to initialize host\\n\");\n\t\treturn ret;\n\t}\n\n\tret = mobiveil_pcie_interrupt_init(pcie);\n\tif (ret) {\n\t\tdev_err(dev, \"Interrupt init failed\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tbridge->sysdata = pcie;\n\tbridge->ops = &mobiveil_pcie_ops;\n\n\tret = mobiveil_bringup_link(pcie);\n\tif (ret) {\n\t\tdev_info(dev, \"link bring-up failed\\n\");\n\t\treturn ret;\n\t}\n\n\treturn pci_host_probe(bridge);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}