{
  "module_name": "pcie-layerscape-gen4.c",
  "hash_id": "c7f6418df138ffde64bce4471f8b1822d66daac39a4bcbc984f81c499093d821",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/controller/mobiveil/pcie-layerscape-gen4.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/of_pci.h>\n#include <linux/of_platform.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/pci.h>\n#include <linux/platform_device.h>\n#include <linux/resource.h>\n#include <linux/mfd/syscon.h>\n#include <linux/regmap.h>\n\n#include \"pcie-mobiveil.h\"\n\n \n#define PCIE_LUT_OFF\t\t\t0x80000\n#define PCIE_PF_OFF\t\t\t0xc0000\n#define PCIE_PF_INT_STAT\t\t0x18\n#define PF_INT_STAT_PABRST\t\tBIT(31)\n\n#define PCIE_PF_DBG\t\t\t0x7fc\n#define PF_DBG_LTSSM_MASK\t\t0x3f\n#define PF_DBG_LTSSM_L0\t\t\t0x2d  \n#define PF_DBG_WE\t\t\tBIT(31)\n#define PF_DBG_PABR\t\t\tBIT(27)\n\n#define to_ls_g4_pcie(x)\t\tplatform_get_drvdata((x)->pdev)\n\nstruct ls_g4_pcie {\n\tstruct mobiveil_pcie pci;\n\tstruct delayed_work dwork;\n\tint irq;\n};\n\nstatic inline u32 ls_g4_pcie_pf_readl(struct ls_g4_pcie *pcie, u32 off)\n{\n\treturn ioread32(pcie->pci.csr_axi_slave_base + PCIE_PF_OFF + off);\n}\n\nstatic inline void ls_g4_pcie_pf_writel(struct ls_g4_pcie *pcie,\n\t\t\t\t\tu32 off, u32 val)\n{\n\tiowrite32(val, pcie->pci.csr_axi_slave_base + PCIE_PF_OFF + off);\n}\n\nstatic int ls_g4_pcie_link_up(struct mobiveil_pcie *pci)\n{\n\tstruct ls_g4_pcie *pcie = to_ls_g4_pcie(pci);\n\tu32 state;\n\n\tstate = ls_g4_pcie_pf_readl(pcie, PCIE_PF_DBG);\n\tstate =\tstate & PF_DBG_LTSSM_MASK;\n\n\tif (state == PF_DBG_LTSSM_L0)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic void ls_g4_pcie_disable_interrupt(struct ls_g4_pcie *pcie)\n{\n\tstruct mobiveil_pcie *mv_pci = &pcie->pci;\n\n\tmobiveil_csr_writel(mv_pci, 0, PAB_INTP_AMBA_MISC_ENB);\n}\n\nstatic void ls_g4_pcie_enable_interrupt(struct ls_g4_pcie *pcie)\n{\n\tstruct mobiveil_pcie *mv_pci = &pcie->pci;\n\tu32 val;\n\n\t \n\tmobiveil_csr_writel(mv_pci, 0xffffffff, PAB_INTP_AMBA_MISC_STAT);\n\n\tval = PAB_INTP_INTX_MASK | PAB_INTP_MSI | PAB_INTP_RESET |\n\t      PAB_INTP_PCIE_UE | PAB_INTP_IE_PMREDI | PAB_INTP_IE_EC;\n\tmobiveil_csr_writel(mv_pci, val, PAB_INTP_AMBA_MISC_ENB);\n}\n\nstatic int ls_g4_pcie_reinit_hw(struct ls_g4_pcie *pcie)\n{\n\tstruct mobiveil_pcie *mv_pci = &pcie->pci;\n\tstruct device *dev = &mv_pci->pdev->dev;\n\tu32 val, act_stat;\n\tint to = 100;\n\n\t \n\tdo {\n\t\tusleep_range(10, 15);\n\t\tval = ls_g4_pcie_pf_readl(pcie, PCIE_PF_INT_STAT);\n\t\tact_stat = mobiveil_csr_readl(mv_pci, PAB_ACTIVITY_STAT);\n\t} while (((val & PF_INT_STAT_PABRST) == 0 || act_stat) && to--);\n\tif (to < 0) {\n\t\tdev_err(dev, \"Poll PABRST&PABACT timeout\\n\");\n\t\treturn -EIO;\n\t}\n\n\t \n\tval = ls_g4_pcie_pf_readl(pcie, PCIE_PF_DBG);\n\tval |= PF_DBG_WE;\n\tls_g4_pcie_pf_writel(pcie, PCIE_PF_DBG, val);\n\n\tval = ls_g4_pcie_pf_readl(pcie, PCIE_PF_DBG);\n\tval |= PF_DBG_PABR;\n\tls_g4_pcie_pf_writel(pcie, PCIE_PF_DBG, val);\n\n\tval = ls_g4_pcie_pf_readl(pcie, PCIE_PF_DBG);\n\tval &= ~PF_DBG_WE;\n\tls_g4_pcie_pf_writel(pcie, PCIE_PF_DBG, val);\n\n\tmobiveil_host_init(mv_pci, true);\n\n\tto = 100;\n\twhile (!ls_g4_pcie_link_up(mv_pci) && to--)\n\t\tusleep_range(200, 250);\n\tif (to < 0) {\n\t\tdev_err(dev, \"PCIe link training timeout\\n\");\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic irqreturn_t ls_g4_pcie_isr(int irq, void *dev_id)\n{\n\tstruct ls_g4_pcie *pcie = (struct ls_g4_pcie *)dev_id;\n\tstruct mobiveil_pcie *mv_pci = &pcie->pci;\n\tu32 val;\n\n\tval = mobiveil_csr_readl(mv_pci, PAB_INTP_AMBA_MISC_STAT);\n\tif (!val)\n\t\treturn IRQ_NONE;\n\n\tif (val & PAB_INTP_RESET) {\n\t\tls_g4_pcie_disable_interrupt(pcie);\n\t\tschedule_delayed_work(&pcie->dwork, msecs_to_jiffies(1));\n\t}\n\n\tmobiveil_csr_writel(mv_pci, val, PAB_INTP_AMBA_MISC_STAT);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int ls_g4_pcie_interrupt_init(struct mobiveil_pcie *mv_pci)\n{\n\tstruct ls_g4_pcie *pcie = to_ls_g4_pcie(mv_pci);\n\tstruct platform_device *pdev = mv_pci->pdev;\n\tstruct device *dev = &pdev->dev;\n\tint ret;\n\n\tpcie->irq = platform_get_irq_byname(pdev, \"intr\");\n\tif (pcie->irq < 0)\n\t\treturn pcie->irq;\n\n\tret = devm_request_irq(dev, pcie->irq, ls_g4_pcie_isr,\n\t\t\t       IRQF_SHARED, pdev->name, pcie);\n\tif (ret) {\n\t\tdev_err(dev, \"Can't register PCIe IRQ, errno = %d\\n\", ret);\n\t\treturn  ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void ls_g4_pcie_reset(struct work_struct *work)\n{\n\tstruct delayed_work *dwork = container_of(work, struct delayed_work,\n\t\t\t\t\t\t  work);\n\tstruct ls_g4_pcie *pcie = container_of(dwork, struct ls_g4_pcie, dwork);\n\tstruct mobiveil_pcie *mv_pci = &pcie->pci;\n\tu16 ctrl;\n\n\tctrl = mobiveil_csr_readw(mv_pci, PCI_BRIDGE_CONTROL);\n\tctrl &= ~PCI_BRIDGE_CTL_BUS_RESET;\n\tmobiveil_csr_writew(mv_pci, ctrl, PCI_BRIDGE_CONTROL);\n\n\tif (!ls_g4_pcie_reinit_hw(pcie))\n\t\treturn;\n\n\tls_g4_pcie_enable_interrupt(pcie);\n}\n\nstatic struct mobiveil_rp_ops ls_g4_pcie_rp_ops = {\n\t.interrupt_init = ls_g4_pcie_interrupt_init,\n};\n\nstatic const struct mobiveil_pab_ops ls_g4_pcie_pab_ops = {\n\t.link_up = ls_g4_pcie_link_up,\n};\n\nstatic int __init ls_g4_pcie_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct pci_host_bridge *bridge;\n\tstruct mobiveil_pcie *mv_pci;\n\tstruct ls_g4_pcie *pcie;\n\tstruct device_node *np = dev->of_node;\n\tint ret;\n\n\tif (!of_parse_phandle(np, \"msi-parent\", 0)) {\n\t\tdev_err(dev, \"Failed to find msi-parent\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tbridge = devm_pci_alloc_host_bridge(dev, sizeof(*pcie));\n\tif (!bridge)\n\t\treturn -ENOMEM;\n\n\tpcie = pci_host_bridge_priv(bridge);\n\tmv_pci = &pcie->pci;\n\n\tmv_pci->pdev = pdev;\n\tmv_pci->ops = &ls_g4_pcie_pab_ops;\n\tmv_pci->rp.ops = &ls_g4_pcie_rp_ops;\n\tmv_pci->rp.bridge = bridge;\n\n\tplatform_set_drvdata(pdev, pcie);\n\n\tINIT_DELAYED_WORK(&pcie->dwork, ls_g4_pcie_reset);\n\n\tret = mobiveil_pcie_host_probe(mv_pci);\n\tif (ret) {\n\t\tdev_err(dev, \"Fail to probe\\n\");\n\t\treturn  ret;\n\t}\n\n\tls_g4_pcie_enable_interrupt(pcie);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id ls_g4_pcie_of_match[] = {\n\t{ .compatible = \"fsl,lx2160a-pcie\", },\n\t{ },\n};\n\nstatic struct platform_driver ls_g4_pcie_driver = {\n\t.driver = {\n\t\t.name = \"layerscape-pcie-gen4\",\n\t\t.of_match_table = ls_g4_pcie_of_match,\n\t\t.suppress_bind_attrs = true,\n\t},\n};\n\nbuiltin_platform_driver_probe(ls_g4_pcie_driver, ls_g4_pcie_probe);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}