{
  "module_name": "pci-versatile.c",
  "hash_id": "8d4e50b557549274cdae569335bb2276d733485068e11a98d7d9e81f4d574930",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/controller/pci-versatile.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of_address.h>\n#include <linux/of_pci.h>\n#include <linux/of_platform.h>\n#include <linux/pci.h>\n#include <linux/platform_device.h>\n\n#include \"../pci.h\"\n\nstatic void __iomem *versatile_pci_base;\nstatic void __iomem *versatile_cfg_base[2];\n\n#define PCI_IMAP(m)\t\t(versatile_pci_base + ((m) * 4))\n#define PCI_SMAP(m)\t\t(versatile_pci_base + 0x14 + ((m) * 4))\n#define PCI_SELFID\t\t(versatile_pci_base + 0xc)\n\n#define VP_PCI_DEVICE_ID\t\t0x030010ee\n#define VP_PCI_CLASS_ID\t\t\t0x0b400000\n\nstatic u32 pci_slot_ignore;\n\nstatic int __init versatile_pci_slot_ignore(char *str)\n{\n\tint slot;\n\n\twhile (get_option(&str, &slot)) {\n\t\tif ((slot < 0) || (slot > 31))\n\t\t\tpr_err(\"Illegal slot value: %d\\n\", slot);\n\t\telse\n\t\t\tpci_slot_ignore |= (1 << slot);\n\t}\n\treturn 1;\n}\n__setup(\"pci_slot_ignore=\", versatile_pci_slot_ignore);\n\n\nstatic void __iomem *versatile_map_bus(struct pci_bus *bus,\n\t\t\t\t       unsigned int devfn, int offset)\n{\n\tunsigned int busnr = bus->number;\n\n\tif (pci_slot_ignore & (1 << PCI_SLOT(devfn)))\n\t\treturn NULL;\n\n\treturn versatile_cfg_base[1] + ((busnr << 16) | (devfn << 8) | offset);\n}\n\nstatic struct pci_ops pci_versatile_ops = {\n\t.map_bus = versatile_map_bus,\n\t.read\t= pci_generic_config_read32,\n\t.write\t= pci_generic_config_write,\n};\n\nstatic int versatile_pci_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct resource *res;\n\tstruct resource_entry *entry;\n\tint i, myslot = -1, mem = 1;\n\tu32 val;\n\tvoid __iomem *local_pci_cfg_base;\n\tstruct pci_host_bridge *bridge;\n\n\tbridge = devm_pci_alloc_host_bridge(dev, 0);\n\tif (!bridge)\n\t\treturn -ENOMEM;\n\n\tversatile_pci_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(versatile_pci_base))\n\t\treturn PTR_ERR(versatile_pci_base);\n\n\tversatile_cfg_base[0] = devm_platform_ioremap_resource(pdev, 1);\n\tif (IS_ERR(versatile_cfg_base[0]))\n\t\treturn PTR_ERR(versatile_cfg_base[0]);\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 2);\n\tversatile_cfg_base[1] = devm_pci_remap_cfg_resource(dev, res);\n\tif (IS_ERR(versatile_cfg_base[1]))\n\t\treturn PTR_ERR(versatile_cfg_base[1]);\n\n\tresource_list_for_each_entry(entry, &bridge->windows) {\n\t\tif (resource_type(entry->res) == IORESOURCE_MEM) {\n\t\t\twritel(entry->res->start >> 28, PCI_IMAP(mem));\n\t\t\twritel(__pa(PAGE_OFFSET) >> 28, PCI_SMAP(mem));\n\t\t\tmem++;\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < 32; i++) {\n\t\tif ((readl(versatile_cfg_base[0] + (i << 11) + PCI_VENDOR_ID) == VP_PCI_DEVICE_ID) &&\n\t\t    (readl(versatile_cfg_base[0] + (i << 11) + PCI_CLASS_REVISION) == VP_PCI_CLASS_ID)) {\n\t\t\tmyslot = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (myslot == -1) {\n\t\tdev_err(dev, \"Cannot find PCI core!\\n\");\n\t\treturn -EIO;\n\t}\n\t \n\tpci_slot_ignore |= (1 << myslot);\n\n\tdev_info(dev, \"PCI core found (slot %d)\\n\", myslot);\n\n\twritel(myslot, PCI_SELFID);\n\tlocal_pci_cfg_base = versatile_cfg_base[1] + (myslot << 11);\n\n\tval = readl(local_pci_cfg_base + PCI_COMMAND);\n\tval |= PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER | PCI_COMMAND_INVALIDATE;\n\twritel(val, local_pci_cfg_base + PCI_COMMAND);\n\n\t \n\twritel(__pa(PAGE_OFFSET), local_pci_cfg_base + PCI_BASE_ADDRESS_0);\n\twritel(__pa(PAGE_OFFSET), local_pci_cfg_base + PCI_BASE_ADDRESS_1);\n\twritel(__pa(PAGE_OFFSET), local_pci_cfg_base + PCI_BASE_ADDRESS_2);\n\n\t \n\twritel(0, versatile_cfg_base[0] + PCI_INTERRUPT_LINE);\n\n\tpci_add_flags(PCI_REASSIGN_ALL_BUS);\n\n\tbridge->ops = &pci_versatile_ops;\n\n\treturn pci_host_probe(bridge);\n}\n\nstatic const struct of_device_id versatile_pci_of_match[] = {\n\t{ .compatible = \"arm,versatile-pci\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, versatile_pci_of_match);\n\nstatic struct platform_driver versatile_pci_driver = {\n\t.driver = {\n\t\t.name = \"versatile-pci\",\n\t\t.of_match_table = versatile_pci_of_match,\n\t\t.suppress_bind_attrs = true,\n\t},\n\t.probe = versatile_pci_probe,\n};\nmodule_platform_driver(versatile_pci_driver);\n\nMODULE_DESCRIPTION(\"Versatile PCI driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}