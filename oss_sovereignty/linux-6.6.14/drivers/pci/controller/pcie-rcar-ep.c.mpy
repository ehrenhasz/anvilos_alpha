{
  "module_name": "pcie-rcar-ep.c",
  "hash_id": "90b4768aa8a48010c1f5aaa00faef61de84fb436b29b297edd726dc4f020c5bd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/controller/pcie-rcar-ep.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/of_address.h>\n#include <linux/of_platform.h>\n#include <linux/pci.h>\n#include <linux/pci-epc.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n\n#include \"pcie-rcar.h\"\n\n#define RCAR_EPC_MAX_FUNCTIONS\t\t1\n\n \nstruct rcar_pcie_endpoint {\n\tstruct rcar_pcie\tpcie;\n\tphys_addr_t\t\t*ob_mapped_addr;\n\tstruct pci_epc_mem_window *ob_window;\n\tu8\t\t\tmax_functions;\n\tunsigned int\t\tbar_to_atu[MAX_NR_INBOUND_MAPS];\n\tunsigned long\t\t*ib_window_map;\n\tu32\t\t\tnum_ib_windows;\n\tu32\t\t\tnum_ob_windows;\n};\n\nstatic void rcar_pcie_ep_hw_init(struct rcar_pcie *pcie)\n{\n\tu32 val;\n\n\trcar_pci_write_reg(pcie, 0, PCIETCTLR);\n\n\t \n\trcar_pci_write_reg(pcie, 0, PCIEMSR);\n\n\t \n\trcar_rmw32(pcie, REXPCAP(0), 0xff, PCI_CAP_ID_EXP);\n\trcar_rmw32(pcie, REXPCAP(PCI_EXP_FLAGS),\n\t\t   PCI_EXP_FLAGS_TYPE, PCI_EXP_TYPE_ENDPOINT << 4);\n\trcar_rmw32(pcie, RCONF(PCI_HEADER_TYPE), 0x7f,\n\t\t   PCI_HEADER_TYPE_NORMAL);\n\n\t \n\trcar_rmw32(pcie, REXPCAP(PCI_EXP_SLTCAP), PCI_EXP_SLTCAP_PSN, 0);\n\n\tval = rcar_pci_read_reg(pcie, EXPCAP(1));\n\t \n\tval &= ~GENMASK(2, 0);\n\trcar_pci_write_reg(pcie, val, EXPCAP(1));\n\n\tval = rcar_pci_read_reg(pcie, EXPCAP(2));\n\t \n\tval &= ~GENMASK(14, 12);\n\t \n\tval &= ~GENMASK(7, 5);\n\trcar_pci_write_reg(pcie, val, EXPCAP(2));\n\n\t \n\trcar_rmw32(pcie, EXPCAP(12), PCI_EXP_LNKSTA_CLS,\n\t\t   PCI_EXP_LNKSTA_CLS_5_0GB);\n\n\t \n\trcar_rmw32(pcie, TLCTLR + 1, 0x3f, 50);\n\n\t \n\trcar_rmw32(pcie, RVCCAP(0), 0xfff00000, 0);\n\n\t \n\twmb();\n}\n\nstatic int rcar_pcie_ep_get_window(struct rcar_pcie_endpoint *ep,\n\t\t\t\t   phys_addr_t addr)\n{\n\tint i;\n\n\tfor (i = 0; i < ep->num_ob_windows; i++)\n\t\tif (ep->ob_window[i].phys_base == addr)\n\t\t\treturn i;\n\n\treturn -EINVAL;\n}\n\nstatic int rcar_pcie_parse_outbound_ranges(struct rcar_pcie_endpoint *ep,\n\t\t\t\t\t   struct platform_device *pdev)\n{\n\tstruct rcar_pcie *pcie = &ep->pcie;\n\tchar outbound_name[10];\n\tstruct resource *res;\n\tunsigned int i = 0;\n\n\tep->num_ob_windows = 0;\n\tfor (i = 0; i < RCAR_PCI_MAX_RESOURCES; i++) {\n\t\tsprintf(outbound_name, \"memory%u\", i);\n\t\tres = platform_get_resource_byname(pdev,\n\t\t\t\t\t\t   IORESOURCE_MEM,\n\t\t\t\t\t\t   outbound_name);\n\t\tif (!res) {\n\t\t\tdev_err(pcie->dev, \"missing outbound window %u\\n\", i);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (!devm_request_mem_region(&pdev->dev, res->start,\n\t\t\t\t\t     resource_size(res),\n\t\t\t\t\t     outbound_name)) {\n\t\t\tdev_err(pcie->dev, \"Cannot request memory region %s.\\n\",\n\t\t\t\toutbound_name);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tep->ob_window[i].phys_base = res->start;\n\t\tep->ob_window[i].size = resource_size(res);\n\t\t \n\t\tep->ob_window[i].page_size = resource_size(res);\n\t}\n\tep->num_ob_windows = i;\n\n\treturn 0;\n}\n\nstatic int rcar_pcie_ep_get_pdata(struct rcar_pcie_endpoint *ep,\n\t\t\t\t  struct platform_device *pdev)\n{\n\tstruct rcar_pcie *pcie = &ep->pcie;\n\tstruct pci_epc_mem_window *window;\n\tstruct device *dev = pcie->dev;\n\tstruct resource res;\n\tint err;\n\n\terr = of_address_to_resource(dev->of_node, 0, &res);\n\tif (err)\n\t\treturn err;\n\tpcie->base = devm_ioremap_resource(dev, &res);\n\tif (IS_ERR(pcie->base))\n\t\treturn PTR_ERR(pcie->base);\n\n\tep->ob_window = devm_kcalloc(dev, RCAR_PCI_MAX_RESOURCES,\n\t\t\t\t     sizeof(*window), GFP_KERNEL);\n\tif (!ep->ob_window)\n\t\treturn -ENOMEM;\n\n\trcar_pcie_parse_outbound_ranges(ep, pdev);\n\n\terr = of_property_read_u8(dev->of_node, \"max-functions\",\n\t\t\t\t  &ep->max_functions);\n\tif (err < 0 || ep->max_functions > RCAR_EPC_MAX_FUNCTIONS)\n\t\tep->max_functions = RCAR_EPC_MAX_FUNCTIONS;\n\n\treturn 0;\n}\n\nstatic int rcar_pcie_ep_write_header(struct pci_epc *epc, u8 fn, u8 vfn,\n\t\t\t\t     struct pci_epf_header *hdr)\n{\n\tstruct rcar_pcie_endpoint *ep = epc_get_drvdata(epc);\n\tstruct rcar_pcie *pcie = &ep->pcie;\n\tu32 val;\n\n\tif (!fn)\n\t\tval = hdr->vendorid;\n\telse\n\t\tval = rcar_pci_read_reg(pcie, IDSETR0);\n\tval |= hdr->deviceid << 16;\n\trcar_pci_write_reg(pcie, val, IDSETR0);\n\n\tval = hdr->revid;\n\tval |= hdr->progif_code << 8;\n\tval |= hdr->subclass_code << 16;\n\tval |= hdr->baseclass_code << 24;\n\trcar_pci_write_reg(pcie, val, IDSETR1);\n\n\tif (!fn)\n\t\tval = hdr->subsys_vendor_id;\n\telse\n\t\tval = rcar_pci_read_reg(pcie, SUBIDSETR);\n\tval |= hdr->subsys_id << 16;\n\trcar_pci_write_reg(pcie, val, SUBIDSETR);\n\n\tif (hdr->interrupt_pin > PCI_INTERRUPT_INTA)\n\t\treturn -EINVAL;\n\tval = rcar_pci_read_reg(pcie, PCICONF(15));\n\tval |= (hdr->interrupt_pin << 8);\n\trcar_pci_write_reg(pcie, val, PCICONF(15));\n\n\treturn 0;\n}\n\nstatic int rcar_pcie_ep_set_bar(struct pci_epc *epc, u8 func_no, u8 vfunc_no,\n\t\t\t\tstruct pci_epf_bar *epf_bar)\n{\n\tint flags = epf_bar->flags | LAR_ENABLE | LAM_64BIT;\n\tstruct rcar_pcie_endpoint *ep = epc_get_drvdata(epc);\n\tu64 size = 1ULL << fls64(epf_bar->size - 1);\n\tdma_addr_t cpu_addr = epf_bar->phys_addr;\n\tenum pci_barno bar = epf_bar->barno;\n\tstruct rcar_pcie *pcie = &ep->pcie;\n\tu32 mask;\n\tint idx;\n\tint err;\n\n\tidx = find_first_zero_bit(ep->ib_window_map, ep->num_ib_windows);\n\tif (idx >= ep->num_ib_windows) {\n\t\tdev_err(pcie->dev, \"no free inbound window\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif ((flags & PCI_BASE_ADDRESS_SPACE) == PCI_BASE_ADDRESS_SPACE_IO)\n\t\tflags |= IO_SPACE;\n\n\tep->bar_to_atu[bar] = idx;\n\t \n\tset_bit(idx, ep->ib_window_map);\n\tset_bit(idx + 1, ep->ib_window_map);\n\n\tif (cpu_addr > 0) {\n\t\tunsigned long nr_zeros = __ffs64(cpu_addr);\n\t\tu64 alignment = 1ULL << nr_zeros;\n\n\t\tsize = min(size, alignment);\n\t}\n\n\tsize = min(size, 1ULL << 32);\n\n\tmask = roundup_pow_of_two(size) - 1;\n\tmask &= ~0xf;\n\n\trcar_pcie_set_inbound(pcie, cpu_addr,\n\t\t\t      0x0, mask | flags, idx, false);\n\n\terr = rcar_pcie_wait_for_phyrdy(pcie);\n\tif (err) {\n\t\tdev_err(pcie->dev, \"phy not ready\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void rcar_pcie_ep_clear_bar(struct pci_epc *epc, u8 fn, u8 vfn,\n\t\t\t\t   struct pci_epf_bar *epf_bar)\n{\n\tstruct rcar_pcie_endpoint *ep = epc_get_drvdata(epc);\n\tenum pci_barno bar = epf_bar->barno;\n\tu32 atu_index = ep->bar_to_atu[bar];\n\n\trcar_pcie_set_inbound(&ep->pcie, 0x0, 0x0, 0x0, bar, false);\n\n\tclear_bit(atu_index, ep->ib_window_map);\n\tclear_bit(atu_index + 1, ep->ib_window_map);\n}\n\nstatic int rcar_pcie_ep_set_msi(struct pci_epc *epc, u8 fn, u8 vfn,\n\t\t\t\tu8 interrupts)\n{\n\tstruct rcar_pcie_endpoint *ep = epc_get_drvdata(epc);\n\tstruct rcar_pcie *pcie = &ep->pcie;\n\tu32 flags;\n\n\tflags = rcar_pci_read_reg(pcie, MSICAP(fn));\n\tflags |= interrupts << MSICAP0_MMESCAP_OFFSET;\n\trcar_pci_write_reg(pcie, flags, MSICAP(fn));\n\n\treturn 0;\n}\n\nstatic int rcar_pcie_ep_get_msi(struct pci_epc *epc, u8 fn, u8 vfn)\n{\n\tstruct rcar_pcie_endpoint *ep = epc_get_drvdata(epc);\n\tstruct rcar_pcie *pcie = &ep->pcie;\n\tu32 flags;\n\n\tflags = rcar_pci_read_reg(pcie, MSICAP(fn));\n\tif (!(flags & MSICAP0_MSIE))\n\t\treturn -EINVAL;\n\n\treturn ((flags & MSICAP0_MMESE_MASK) >> MSICAP0_MMESE_OFFSET);\n}\n\nstatic int rcar_pcie_ep_map_addr(struct pci_epc *epc, u8 fn, u8 vfn,\n\t\t\t\t phys_addr_t addr, u64 pci_addr, size_t size)\n{\n\tstruct rcar_pcie_endpoint *ep = epc_get_drvdata(epc);\n\tstruct rcar_pcie *pcie = &ep->pcie;\n\tstruct resource_entry win;\n\tstruct resource res;\n\tint window;\n\tint err;\n\n\t \n\terr = rcar_pcie_wait_for_dl(pcie);\n\tif (err) {\n\t\tdev_err(pcie->dev, \"link not up\\n\");\n\t\treturn err;\n\t}\n\n\twindow = rcar_pcie_ep_get_window(ep, addr);\n\tif (window < 0) {\n\t\tdev_err(pcie->dev, \"failed to get corresponding window\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmemset(&win, 0x0, sizeof(win));\n\tmemset(&res, 0x0, sizeof(res));\n\tres.start = pci_addr;\n\tres.end = pci_addr + size - 1;\n\tres.flags = IORESOURCE_MEM;\n\twin.res = &res;\n\n\trcar_pcie_set_outbound(pcie, window, &win);\n\n\tep->ob_mapped_addr[window] = addr;\n\n\treturn 0;\n}\n\nstatic void rcar_pcie_ep_unmap_addr(struct pci_epc *epc, u8 fn, u8 vfn,\n\t\t\t\t    phys_addr_t addr)\n{\n\tstruct rcar_pcie_endpoint *ep = epc_get_drvdata(epc);\n\tstruct resource_entry win;\n\tstruct resource res;\n\tint idx;\n\n\tfor (idx = 0; idx < ep->num_ob_windows; idx++)\n\t\tif (ep->ob_mapped_addr[idx] == addr)\n\t\t\tbreak;\n\n\tif (idx >= ep->num_ob_windows)\n\t\treturn;\n\n\tmemset(&win, 0x0, sizeof(win));\n\tmemset(&res, 0x0, sizeof(res));\n\twin.res = &res;\n\trcar_pcie_set_outbound(&ep->pcie, idx, &win);\n\n\tep->ob_mapped_addr[idx] = 0;\n}\n\nstatic int rcar_pcie_ep_assert_intx(struct rcar_pcie_endpoint *ep,\n\t\t\t\t    u8 fn, u8 intx)\n{\n\tstruct rcar_pcie *pcie = &ep->pcie;\n\tu32 val;\n\n\tval = rcar_pci_read_reg(pcie, PCIEMSITXR);\n\tif ((val & PCI_MSI_FLAGS_ENABLE)) {\n\t\tdev_err(pcie->dev, \"MSI is enabled, cannot assert INTx\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tval = rcar_pci_read_reg(pcie, PCICONF(1));\n\tif ((val & INTDIS)) {\n\t\tdev_err(pcie->dev, \"INTx message transmission is disabled\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tval = rcar_pci_read_reg(pcie, PCIEINTXR);\n\tif ((val & ASTINTX)) {\n\t\tdev_err(pcie->dev, \"INTx is already asserted\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tval |= ASTINTX;\n\trcar_pci_write_reg(pcie, val, PCIEINTXR);\n\tusleep_range(1000, 1001);\n\tval = rcar_pci_read_reg(pcie, PCIEINTXR);\n\tval &= ~ASTINTX;\n\trcar_pci_write_reg(pcie, val, PCIEINTXR);\n\n\treturn 0;\n}\n\nstatic int rcar_pcie_ep_assert_msi(struct rcar_pcie *pcie,\n\t\t\t\t   u8 fn, u8 interrupt_num)\n{\n\tu16 msi_count;\n\tu32 val;\n\n\t \n\tval = rcar_pci_read_reg(pcie, MSICAP(fn));\n\tif (!(val & MSICAP0_MSIE))\n\t\treturn -EINVAL;\n\n\t \n\tmsi_count = ((val & MSICAP0_MMESE_MASK) >> MSICAP0_MMESE_OFFSET);\n\tmsi_count = 1 << msi_count;\n\n\tif (!interrupt_num || interrupt_num > msi_count)\n\t\treturn -EINVAL;\n\n\tval = rcar_pci_read_reg(pcie, PCIEMSITXR);\n\trcar_pci_write_reg(pcie, val | (interrupt_num - 1), PCIEMSITXR);\n\n\treturn 0;\n}\n\nstatic int rcar_pcie_ep_raise_irq(struct pci_epc *epc, u8 fn, u8 vfn,\n\t\t\t\t  enum pci_epc_irq_type type,\n\t\t\t\t  u16 interrupt_num)\n{\n\tstruct rcar_pcie_endpoint *ep = epc_get_drvdata(epc);\n\n\tswitch (type) {\n\tcase PCI_EPC_IRQ_LEGACY:\n\t\treturn rcar_pcie_ep_assert_intx(ep, fn, 0);\n\n\tcase PCI_EPC_IRQ_MSI:\n\t\treturn rcar_pcie_ep_assert_msi(&ep->pcie, fn, interrupt_num);\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int rcar_pcie_ep_start(struct pci_epc *epc)\n{\n\tstruct rcar_pcie_endpoint *ep = epc_get_drvdata(epc);\n\n\trcar_pci_write_reg(&ep->pcie, MACCTLR_INIT_VAL, MACCTLR);\n\trcar_pci_write_reg(&ep->pcie, CFINIT, PCIETCTLR);\n\n\treturn 0;\n}\n\nstatic void rcar_pcie_ep_stop(struct pci_epc *epc)\n{\n\tstruct rcar_pcie_endpoint *ep = epc_get_drvdata(epc);\n\n\trcar_pci_write_reg(&ep->pcie, 0, PCIETCTLR);\n}\n\nstatic const struct pci_epc_features rcar_pcie_epc_features = {\n\t.linkup_notifier = false,\n\t.msi_capable = true,\n\t.msix_capable = false,\n\t \n\t.reserved_bar = 1 << BAR_1 | 1 << BAR_3 | 1 << BAR_5,\n\t.bar_fixed_64bit = 1 << BAR_0 | 1 << BAR_2 | 1 << BAR_4,\n\t.bar_fixed_size[0] = 128,\n\t.bar_fixed_size[2] = 256,\n\t.bar_fixed_size[4] = 256,\n};\n\nstatic const struct pci_epc_features*\nrcar_pcie_ep_get_features(struct pci_epc *epc, u8 func_no, u8 vfunc_no)\n{\n\treturn &rcar_pcie_epc_features;\n}\n\nstatic const struct pci_epc_ops rcar_pcie_epc_ops = {\n\t.write_header\t= rcar_pcie_ep_write_header,\n\t.set_bar\t= rcar_pcie_ep_set_bar,\n\t.clear_bar\t= rcar_pcie_ep_clear_bar,\n\t.set_msi\t= rcar_pcie_ep_set_msi,\n\t.get_msi\t= rcar_pcie_ep_get_msi,\n\t.map_addr\t= rcar_pcie_ep_map_addr,\n\t.unmap_addr\t= rcar_pcie_ep_unmap_addr,\n\t.raise_irq\t= rcar_pcie_ep_raise_irq,\n\t.start\t\t= rcar_pcie_ep_start,\n\t.stop\t\t= rcar_pcie_ep_stop,\n\t.get_features\t= rcar_pcie_ep_get_features,\n};\n\nstatic const struct of_device_id rcar_pcie_ep_of_match[] = {\n\t{ .compatible = \"renesas,r8a774c0-pcie-ep\", },\n\t{ .compatible = \"renesas,rcar-gen3-pcie-ep\" },\n\t{ },\n};\n\nstatic int rcar_pcie_ep_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct rcar_pcie_endpoint *ep;\n\tstruct rcar_pcie *pcie;\n\tstruct pci_epc *epc;\n\tint err;\n\n\tep = devm_kzalloc(dev, sizeof(*ep), GFP_KERNEL);\n\tif (!ep)\n\t\treturn -ENOMEM;\n\n\tpcie = &ep->pcie;\n\tpcie->dev = dev;\n\n\tpm_runtime_enable(dev);\n\terr = pm_runtime_resume_and_get(dev);\n\tif (err < 0) {\n\t\tdev_err(dev, \"pm_runtime_resume_and_get failed\\n\");\n\t\tgoto err_pm_disable;\n\t}\n\n\terr = rcar_pcie_ep_get_pdata(ep, pdev);\n\tif (err < 0) {\n\t\tdev_err(dev, \"failed to request resources: %d\\n\", err);\n\t\tgoto err_pm_put;\n\t}\n\n\tep->num_ib_windows = MAX_NR_INBOUND_MAPS;\n\tep->ib_window_map =\n\t\t\tdevm_kcalloc(dev, BITS_TO_LONGS(ep->num_ib_windows),\n\t\t\t\t     sizeof(long), GFP_KERNEL);\n\tif (!ep->ib_window_map) {\n\t\terr = -ENOMEM;\n\t\tdev_err(dev, \"failed to allocate memory for inbound map\\n\");\n\t\tgoto err_pm_put;\n\t}\n\n\tep->ob_mapped_addr = devm_kcalloc(dev, ep->num_ob_windows,\n\t\t\t\t\t  sizeof(*ep->ob_mapped_addr),\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!ep->ob_mapped_addr) {\n\t\terr = -ENOMEM;\n\t\tdev_err(dev, \"failed to allocate memory for outbound memory pointers\\n\");\n\t\tgoto err_pm_put;\n\t}\n\n\tepc = devm_pci_epc_create(dev, &rcar_pcie_epc_ops);\n\tif (IS_ERR(epc)) {\n\t\tdev_err(dev, \"failed to create epc device\\n\");\n\t\terr = PTR_ERR(epc);\n\t\tgoto err_pm_put;\n\t}\n\n\tepc->max_functions = ep->max_functions;\n\tepc_set_drvdata(epc, ep);\n\n\trcar_pcie_ep_hw_init(pcie);\n\n\terr = pci_epc_multi_mem_init(epc, ep->ob_window, ep->num_ob_windows);\n\tif (err < 0) {\n\t\tdev_err(dev, \"failed to initialize the epc memory space\\n\");\n\t\tgoto err_pm_put;\n\t}\n\n\treturn 0;\n\nerr_pm_put:\n\tpm_runtime_put(dev);\n\nerr_pm_disable:\n\tpm_runtime_disable(dev);\n\n\treturn err;\n}\n\nstatic struct platform_driver rcar_pcie_ep_driver = {\n\t.driver = {\n\t\t.name = \"rcar-pcie-ep\",\n\t\t.of_match_table = rcar_pcie_ep_of_match,\n\t\t.suppress_bind_attrs = true,\n\t},\n\t.probe = rcar_pcie_ep_probe,\n};\nbuiltin_platform_driver(rcar_pcie_ep_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}