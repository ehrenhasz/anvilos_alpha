{
  "module_name": "pcie-brcmstb.c",
  "hash_id": "f2501ef717dfaea43c01535775e2d58bb8e6ac1854ba32a202fa4c34d45bce5f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/controller/pcie-brcmstb.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/bitops.h>\n#include <linux/clk.h>\n#include <linux/compiler.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/ioport.h>\n#include <linux/irqchip/chained_irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/log2.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/of_pci.h>\n#include <linux/of_platform.h>\n#include <linux/pci.h>\n#include <linux/pci-ecam.h>\n#include <linux/printk.h>\n#include <linux/regulator/consumer.h>\n#include <linux/reset.h>\n#include <linux/sizes.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/types.h>\n\n#include \"../pci.h\"\n\n \n#define BRCM_PCIE_CAP_REGS\t\t\t\t0x00ac\n\n \n#define PCIE_RC_CFG_VENDOR_VENDOR_SPECIFIC_REG1\t\t\t\t0x0188\n#define  PCIE_RC_CFG_VENDOR_VENDOR_SPECIFIC_REG1_ENDIAN_MODE_BAR2_MASK\t0xc\n#define  PCIE_RC_CFG_VENDOR_SPCIFIC_REG1_LITTLE_ENDIAN\t\t\t0x0\n\n#define PCIE_RC_CFG_PRIV1_ID_VAL3\t\t\t0x043c\n#define  PCIE_RC_CFG_PRIV1_ID_VAL3_CLASS_CODE_MASK\t0xffffff\n\n#define PCIE_RC_CFG_PRIV1_LINK_CAPABILITY\t\t\t0x04dc\n#define  PCIE_RC_CFG_PRIV1_LINK_CAPABILITY_ASPM_SUPPORT_MASK\t0xc00\n\n#define PCIE_RC_DL_MDIO_ADDR\t\t\t\t0x1100\n#define PCIE_RC_DL_MDIO_WR_DATA\t\t\t\t0x1104\n#define PCIE_RC_DL_MDIO_RD_DATA\t\t\t\t0x1108\n\n#define PCIE_MISC_MISC_CTRL\t\t\t\t0x4008\n#define  PCIE_MISC_MISC_CTRL_PCIE_RCB_64B_MODE_MASK\t0x80\n#define  PCIE_MISC_MISC_CTRL_PCIE_RCB_MPS_MODE_MASK\t0x400\n#define  PCIE_MISC_MISC_CTRL_SCB_ACCESS_EN_MASK\t\t0x1000\n#define  PCIE_MISC_MISC_CTRL_CFG_READ_UR_MODE_MASK\t0x2000\n#define  PCIE_MISC_MISC_CTRL_MAX_BURST_SIZE_MASK\t0x300000\n\n#define  PCIE_MISC_MISC_CTRL_SCB0_SIZE_MASK\t\t0xf8000000\n#define  PCIE_MISC_MISC_CTRL_SCB1_SIZE_MASK\t\t0x07c00000\n#define  PCIE_MISC_MISC_CTRL_SCB2_SIZE_MASK\t\t0x0000001f\n#define  SCB_SIZE_MASK(x) PCIE_MISC_MISC_CTRL_SCB ## x ## _SIZE_MASK\n\n#define PCIE_MISC_CPU_2_PCIE_MEM_WIN0_LO\t\t0x400c\n#define PCIE_MEM_WIN0_LO(win)\t\\\n\t\tPCIE_MISC_CPU_2_PCIE_MEM_WIN0_LO + ((win) * 8)\n\n#define PCIE_MISC_CPU_2_PCIE_MEM_WIN0_HI\t\t0x4010\n#define PCIE_MEM_WIN0_HI(win)\t\\\n\t\tPCIE_MISC_CPU_2_PCIE_MEM_WIN0_HI + ((win) * 8)\n\n#define PCIE_MISC_RC_BAR1_CONFIG_LO\t\t\t0x402c\n#define  PCIE_MISC_RC_BAR1_CONFIG_LO_SIZE_MASK\t\t0x1f\n\n#define PCIE_MISC_RC_BAR2_CONFIG_LO\t\t\t0x4034\n#define  PCIE_MISC_RC_BAR2_CONFIG_LO_SIZE_MASK\t\t0x1f\n#define PCIE_MISC_RC_BAR2_CONFIG_HI\t\t\t0x4038\n\n#define PCIE_MISC_RC_BAR3_CONFIG_LO\t\t\t0x403c\n#define  PCIE_MISC_RC_BAR3_CONFIG_LO_SIZE_MASK\t\t0x1f\n\n#define PCIE_MISC_MSI_BAR_CONFIG_LO\t\t\t0x4044\n#define PCIE_MISC_MSI_BAR_CONFIG_HI\t\t\t0x4048\n\n#define PCIE_MISC_MSI_DATA_CONFIG\t\t\t0x404c\n#define  PCIE_MISC_MSI_DATA_CONFIG_VAL_32\t\t0xffe06540\n#define  PCIE_MISC_MSI_DATA_CONFIG_VAL_8\t\t0xfff86540\n\n#define PCIE_MISC_PCIE_CTRL\t\t\t\t0x4064\n#define  PCIE_MISC_PCIE_CTRL_PCIE_L23_REQUEST_MASK\t0x1\n#define PCIE_MISC_PCIE_CTRL_PCIE_PERSTB_MASK\t\t0x4\n\n#define PCIE_MISC_PCIE_STATUS\t\t\t\t0x4068\n#define  PCIE_MISC_PCIE_STATUS_PCIE_PORT_MASK\t\t0x80\n#define  PCIE_MISC_PCIE_STATUS_PCIE_DL_ACTIVE_MASK\t0x20\n#define  PCIE_MISC_PCIE_STATUS_PCIE_PHYLINKUP_MASK\t0x10\n#define  PCIE_MISC_PCIE_STATUS_PCIE_LINK_IN_L23_MASK\t0x40\n\n#define PCIE_MISC_REVISION\t\t\t\t0x406c\n#define  BRCM_PCIE_HW_REV_33\t\t\t\t0x0303\n#define  BRCM_PCIE_HW_REV_3_20\t\t\t\t0x0320\n\n#define PCIE_MISC_CPU_2_PCIE_MEM_WIN0_BASE_LIMIT\t\t0x4070\n#define  PCIE_MISC_CPU_2_PCIE_MEM_WIN0_BASE_LIMIT_LIMIT_MASK\t0xfff00000\n#define  PCIE_MISC_CPU_2_PCIE_MEM_WIN0_BASE_LIMIT_BASE_MASK\t0xfff0\n#define PCIE_MEM_WIN0_BASE_LIMIT(win)\t\\\n\t\tPCIE_MISC_CPU_2_PCIE_MEM_WIN0_BASE_LIMIT + ((win) * 4)\n\n#define PCIE_MISC_CPU_2_PCIE_MEM_WIN0_BASE_HI\t\t\t0x4080\n#define  PCIE_MISC_CPU_2_PCIE_MEM_WIN0_BASE_HI_BASE_MASK\t0xff\n#define PCIE_MEM_WIN0_BASE_HI(win)\t\\\n\t\tPCIE_MISC_CPU_2_PCIE_MEM_WIN0_BASE_HI + ((win) * 8)\n\n#define PCIE_MISC_CPU_2_PCIE_MEM_WIN0_LIMIT_HI\t\t\t0x4084\n#define  PCIE_MISC_CPU_2_PCIE_MEM_WIN0_LIMIT_HI_LIMIT_MASK\t0xff\n#define PCIE_MEM_WIN0_LIMIT_HI(win)\t\\\n\t\tPCIE_MISC_CPU_2_PCIE_MEM_WIN0_LIMIT_HI + ((win) * 8)\n\n#define PCIE_MISC_HARD_PCIE_HARD_DEBUG\t\t\t\t\t0x4204\n#define  PCIE_MISC_HARD_PCIE_HARD_DEBUG_CLKREQ_DEBUG_ENABLE_MASK\t0x2\n#define  PCIE_MISC_HARD_PCIE_HARD_DEBUG_SERDES_IDDQ_MASK\t\t0x08000000\n#define  PCIE_BMIPS_MISC_HARD_PCIE_HARD_DEBUG_SERDES_IDDQ_MASK\t\t0x00800000\n\n\n#define PCIE_INTR2_CPU_BASE\t\t0x4300\n#define PCIE_MSI_INTR2_BASE\t\t0x4500\n \n#define  MSI_INT_STATUS\t\t\t0x0\n#define  MSI_INT_CLR\t\t\t0x8\n#define  MSI_INT_MASK_SET\t\t0x10\n#define  MSI_INT_MASK_CLR\t\t0x14\n\n#define PCIE_EXT_CFG_DATA\t\t\t\t0x8000\n#define PCIE_EXT_CFG_INDEX\t\t\t\t0x9000\n\n#define  PCIE_RGR1_SW_INIT_1_PERST_MASK\t\t\t0x1\n#define  PCIE_RGR1_SW_INIT_1_PERST_SHIFT\t\t0x0\n\n#define RGR1_SW_INIT_1_INIT_GENERIC_MASK\t\t0x2\n#define RGR1_SW_INIT_1_INIT_GENERIC_SHIFT\t\t0x1\n#define RGR1_SW_INIT_1_INIT_7278_MASK\t\t\t0x1\n#define RGR1_SW_INIT_1_INIT_7278_SHIFT\t\t\t0x0\n\n \n#define BRCM_NUM_PCIE_OUT_WINS\t\t0x4\n#define BRCM_INT_PCI_MSI_NR\t\t32\n#define BRCM_INT_PCI_MSI_LEGACY_NR\t8\n#define BRCM_INT_PCI_MSI_SHIFT\t\t0\n#define BRCM_INT_PCI_MSI_MASK\t\tGENMASK(BRCM_INT_PCI_MSI_NR - 1, 0)\n#define BRCM_INT_PCI_MSI_LEGACY_MASK\tGENMASK(31, \\\n\t\t\t\t\t\t32 - BRCM_INT_PCI_MSI_LEGACY_NR)\n\n \n#define BRCM_MSI_TARGET_ADDR_LT_4GB\t0x0fffffffcULL\n#define BRCM_MSI_TARGET_ADDR_GT_4GB\t0xffffffffcULL\n\n \n#define MDIO_PORT0\t\t\t0x0\n#define MDIO_DATA_MASK\t\t\t0x7fffffff\n#define MDIO_PORT_MASK\t\t\t0xf0000\n#define MDIO_REGAD_MASK\t\t\t0xffff\n#define MDIO_CMD_MASK\t\t\t0xfff00000\n#define MDIO_CMD_READ\t\t\t0x1\n#define MDIO_CMD_WRITE\t\t\t0x0\n#define MDIO_DATA_DONE_MASK\t\t0x80000000\n#define MDIO_RD_DONE(x)\t\t\t(((x) & MDIO_DATA_DONE_MASK) ? 1 : 0)\n#define MDIO_WT_DONE(x)\t\t\t(((x) & MDIO_DATA_DONE_MASK) ? 0 : 1)\n#define SSC_REGS_ADDR\t\t\t0x1100\n#define SET_ADDR_OFFSET\t\t\t0x1f\n#define SSC_CNTL_OFFSET\t\t\t0x2\n#define SSC_CNTL_OVRD_EN_MASK\t\t0x8000\n#define SSC_CNTL_OVRD_VAL_MASK\t\t0x4000\n#define SSC_STATUS_OFFSET\t\t0x1\n#define SSC_STATUS_SSC_MASK\t\t0x400\n#define SSC_STATUS_PLL_LOCK_MASK\t0x800\n#define PCIE_BRCM_MAX_MEMC\t\t3\n\n#define IDX_ADDR(pcie)\t\t\t(pcie->reg_offsets[EXT_CFG_INDEX])\n#define DATA_ADDR(pcie)\t\t\t(pcie->reg_offsets[EXT_CFG_DATA])\n#define PCIE_RGR1_SW_INIT_1(pcie)\t(pcie->reg_offsets[RGR1_SW_INIT_1])\n\n \n#define PCIE_DVT_PMU_PCIE_PHY_CTRL\t\t\t\t0xc700\n#define  PCIE_DVT_PMU_PCIE_PHY_CTRL_DAST_NFLDS\t\t\t0x3\n#define  PCIE_DVT_PMU_PCIE_PHY_CTRL_DAST_DIG_RESET_MASK\t\t0x4\n#define  PCIE_DVT_PMU_PCIE_PHY_CTRL_DAST_DIG_RESET_SHIFT\t0x2\n#define  PCIE_DVT_PMU_PCIE_PHY_CTRL_DAST_RESET_MASK\t\t0x2\n#define  PCIE_DVT_PMU_PCIE_PHY_CTRL_DAST_RESET_SHIFT\t\t0x1\n#define  PCIE_DVT_PMU_PCIE_PHY_CTRL_DAST_PWRDN_MASK\t\t0x1\n#define  PCIE_DVT_PMU_PCIE_PHY_CTRL_DAST_PWRDN_SHIFT\t\t0x0\n\n \nstruct brcm_pcie;\n\nenum {\n\tRGR1_SW_INIT_1,\n\tEXT_CFG_INDEX,\n\tEXT_CFG_DATA,\n};\n\nenum {\n\tRGR1_SW_INIT_1_INIT_MASK,\n\tRGR1_SW_INIT_1_INIT_SHIFT,\n};\n\nenum pcie_type {\n\tGENERIC,\n\tBCM7425,\n\tBCM7435,\n\tBCM4908,\n\tBCM7278,\n\tBCM2711,\n};\n\nstruct pcie_cfg_data {\n\tconst int *offsets;\n\tconst enum pcie_type type;\n\tvoid (*perst_set)(struct brcm_pcie *pcie, u32 val);\n\tvoid (*bridge_sw_init_set)(struct brcm_pcie *pcie, u32 val);\n};\n\nstruct subdev_regulators {\n\tunsigned int num_supplies;\n\tstruct regulator_bulk_data supplies[];\n};\n\nstruct brcm_msi {\n\tstruct device\t\t*dev;\n\tvoid __iomem\t\t*base;\n\tstruct device_node\t*np;\n\tstruct irq_domain\t*msi_domain;\n\tstruct irq_domain\t*inner_domain;\n\tstruct mutex\t\tlock;  \n\tu64\t\t\ttarget_addr;\n\tint\t\t\tirq;\n\tDECLARE_BITMAP(used, BRCM_INT_PCI_MSI_NR);\n\tbool\t\t\tlegacy;\n\t \n\tint\t\t\tlegacy_shift;\n\tint\t\t\tnr;  \n\t \n\tvoid __iomem\t\t*intr_base;\n};\n\n \nstruct brcm_pcie {\n\tstruct device\t\t*dev;\n\tvoid __iomem\t\t*base;\n\tstruct clk\t\t*clk;\n\tstruct device_node\t*np;\n\tbool\t\t\tssc;\n\tint\t\t\tgen;\n\tu64\t\t\tmsi_target_addr;\n\tstruct brcm_msi\t\t*msi;\n\tconst int\t\t*reg_offsets;\n\tenum pcie_type\t\ttype;\n\tstruct reset_control\t*rescal;\n\tstruct reset_control\t*perst_reset;\n\tint\t\t\tnum_memc;\n\tu64\t\t\tmemc_size[PCIE_BRCM_MAX_MEMC];\n\tu32\t\t\thw_rev;\n\tvoid\t\t\t(*perst_set)(struct brcm_pcie *pcie, u32 val);\n\tvoid\t\t\t(*bridge_sw_init_set)(struct brcm_pcie *pcie, u32 val);\n\tstruct subdev_regulators *sr;\n\tbool\t\t\tep_wakeup_capable;\n};\n\nstatic inline bool is_bmips(const struct brcm_pcie *pcie)\n{\n\treturn pcie->type == BCM7435 || pcie->type == BCM7425;\n}\n\n \nstatic int brcm_pcie_encode_ibar_size(u64 size)\n{\n\tint log2_in = ilog2(size);\n\n\tif (log2_in >= 12 && log2_in <= 15)\n\t\t \n\t\treturn (log2_in - 12) + 0x1c;\n\telse if (log2_in >= 16 && log2_in <= 35)\n\t\t \n\t\treturn log2_in - 15;\n\t \n\treturn 0;\n}\n\nstatic u32 brcm_pcie_mdio_form_pkt(int port, int regad, int cmd)\n{\n\tu32 pkt = 0;\n\n\tpkt |= FIELD_PREP(MDIO_PORT_MASK, port);\n\tpkt |= FIELD_PREP(MDIO_REGAD_MASK, regad);\n\tpkt |= FIELD_PREP(MDIO_CMD_MASK, cmd);\n\n\treturn pkt;\n}\n\n \nstatic int brcm_pcie_mdio_read(void __iomem *base, u8 port, u8 regad, u32 *val)\n{\n\tu32 data;\n\tint err;\n\n\twritel(brcm_pcie_mdio_form_pkt(port, regad, MDIO_CMD_READ),\n\t\t   base + PCIE_RC_DL_MDIO_ADDR);\n\treadl(base + PCIE_RC_DL_MDIO_ADDR);\n\terr = readl_poll_timeout_atomic(base + PCIE_RC_DL_MDIO_RD_DATA, data,\n\t\t\t\t\tMDIO_RD_DONE(data), 10, 100);\n\t*val = FIELD_GET(MDIO_DATA_MASK, data);\n\n\treturn err;\n}\n\n \nstatic int brcm_pcie_mdio_write(void __iomem *base, u8 port,\n\t\t\t\tu8 regad, u16 wrdata)\n{\n\tu32 data;\n\tint err;\n\n\twritel(brcm_pcie_mdio_form_pkt(port, regad, MDIO_CMD_WRITE),\n\t\t   base + PCIE_RC_DL_MDIO_ADDR);\n\treadl(base + PCIE_RC_DL_MDIO_ADDR);\n\twritel(MDIO_DATA_DONE_MASK | wrdata, base + PCIE_RC_DL_MDIO_WR_DATA);\n\n\terr = readw_poll_timeout_atomic(base + PCIE_RC_DL_MDIO_WR_DATA, data,\n\t\t\t\t\tMDIO_WT_DONE(data), 10, 100);\n\treturn err;\n}\n\n \nstatic int brcm_pcie_set_ssc(struct brcm_pcie *pcie)\n{\n\tint pll, ssc;\n\tint ret;\n\tu32 tmp;\n\n\tret = brcm_pcie_mdio_write(pcie->base, MDIO_PORT0, SET_ADDR_OFFSET,\n\t\t\t\t   SSC_REGS_ADDR);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = brcm_pcie_mdio_read(pcie->base, MDIO_PORT0,\n\t\t\t\t  SSC_CNTL_OFFSET, &tmp);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tu32p_replace_bits(&tmp, 1, SSC_CNTL_OVRD_EN_MASK);\n\tu32p_replace_bits(&tmp, 1, SSC_CNTL_OVRD_VAL_MASK);\n\tret = brcm_pcie_mdio_write(pcie->base, MDIO_PORT0,\n\t\t\t\t   SSC_CNTL_OFFSET, tmp);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tusleep_range(1000, 2000);\n\tret = brcm_pcie_mdio_read(pcie->base, MDIO_PORT0,\n\t\t\t\t  SSC_STATUS_OFFSET, &tmp);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tssc = FIELD_GET(SSC_STATUS_SSC_MASK, tmp);\n\tpll = FIELD_GET(SSC_STATUS_PLL_LOCK_MASK, tmp);\n\n\treturn ssc && pll ? 0 : -EIO;\n}\n\n \nstatic void brcm_pcie_set_gen(struct brcm_pcie *pcie, int gen)\n{\n\tu16 lnkctl2 = readw(pcie->base + BRCM_PCIE_CAP_REGS + PCI_EXP_LNKCTL2);\n\tu32 lnkcap = readl(pcie->base + BRCM_PCIE_CAP_REGS + PCI_EXP_LNKCAP);\n\n\tlnkcap = (lnkcap & ~PCI_EXP_LNKCAP_SLS) | gen;\n\twritel(lnkcap, pcie->base + BRCM_PCIE_CAP_REGS + PCI_EXP_LNKCAP);\n\n\tlnkctl2 = (lnkctl2 & ~0xf) | gen;\n\twritew(lnkctl2, pcie->base + BRCM_PCIE_CAP_REGS + PCI_EXP_LNKCTL2);\n}\n\nstatic void brcm_pcie_set_outbound_win(struct brcm_pcie *pcie,\n\t\t\t\t       unsigned int win, u64 cpu_addr,\n\t\t\t\t       u64 pcie_addr, u64 size)\n{\n\tu32 cpu_addr_mb_high, limit_addr_mb_high;\n\tphys_addr_t cpu_addr_mb, limit_addr_mb;\n\tint high_addr_shift;\n\tu32 tmp;\n\n\t \n\twritel(lower_32_bits(pcie_addr), pcie->base + PCIE_MEM_WIN0_LO(win));\n\twritel(upper_32_bits(pcie_addr), pcie->base + PCIE_MEM_WIN0_HI(win));\n\n\t \n\tcpu_addr_mb = cpu_addr / SZ_1M;\n\tlimit_addr_mb = (cpu_addr + size - 1) / SZ_1M;\n\n\ttmp = readl(pcie->base + PCIE_MEM_WIN0_BASE_LIMIT(win));\n\tu32p_replace_bits(&tmp, cpu_addr_mb,\n\t\t\t  PCIE_MISC_CPU_2_PCIE_MEM_WIN0_BASE_LIMIT_BASE_MASK);\n\tu32p_replace_bits(&tmp, limit_addr_mb,\n\t\t\t  PCIE_MISC_CPU_2_PCIE_MEM_WIN0_BASE_LIMIT_LIMIT_MASK);\n\twritel(tmp, pcie->base + PCIE_MEM_WIN0_BASE_LIMIT(win));\n\n\tif (is_bmips(pcie))\n\t\treturn;\n\n\t \n\thigh_addr_shift =\n\t\tHWEIGHT32(PCIE_MISC_CPU_2_PCIE_MEM_WIN0_BASE_LIMIT_BASE_MASK);\n\n\tcpu_addr_mb_high = cpu_addr_mb >> high_addr_shift;\n\ttmp = readl(pcie->base + PCIE_MEM_WIN0_BASE_HI(win));\n\tu32p_replace_bits(&tmp, cpu_addr_mb_high,\n\t\t\t  PCIE_MISC_CPU_2_PCIE_MEM_WIN0_BASE_HI_BASE_MASK);\n\twritel(tmp, pcie->base + PCIE_MEM_WIN0_BASE_HI(win));\n\n\tlimit_addr_mb_high = limit_addr_mb >> high_addr_shift;\n\ttmp = readl(pcie->base + PCIE_MEM_WIN0_LIMIT_HI(win));\n\tu32p_replace_bits(&tmp, limit_addr_mb_high,\n\t\t\t  PCIE_MISC_CPU_2_PCIE_MEM_WIN0_LIMIT_HI_LIMIT_MASK);\n\twritel(tmp, pcie->base + PCIE_MEM_WIN0_LIMIT_HI(win));\n}\n\nstatic struct irq_chip brcm_msi_irq_chip = {\n\t.name            = \"BRCM STB PCIe MSI\",\n\t.irq_ack         = irq_chip_ack_parent,\n\t.irq_mask        = pci_msi_mask_irq,\n\t.irq_unmask      = pci_msi_unmask_irq,\n};\n\nstatic struct msi_domain_info brcm_msi_domain_info = {\n\t.flags\t= (MSI_FLAG_USE_DEF_DOM_OPS | MSI_FLAG_USE_DEF_CHIP_OPS |\n\t\t   MSI_FLAG_MULTI_PCI_MSI),\n\t.chip\t= &brcm_msi_irq_chip,\n};\n\nstatic void brcm_pcie_msi_isr(struct irq_desc *desc)\n{\n\tstruct irq_chip *chip = irq_desc_get_chip(desc);\n\tunsigned long status;\n\tstruct brcm_msi *msi;\n\tstruct device *dev;\n\tu32 bit;\n\n\tchained_irq_enter(chip, desc);\n\tmsi = irq_desc_get_handler_data(desc);\n\tdev = msi->dev;\n\n\tstatus = readl(msi->intr_base + MSI_INT_STATUS);\n\tstatus >>= msi->legacy_shift;\n\n\tfor_each_set_bit(bit, &status, msi->nr) {\n\t\tint ret;\n\t\tret = generic_handle_domain_irq(msi->inner_domain, bit);\n\t\tif (ret)\n\t\t\tdev_dbg(dev, \"unexpected MSI\\n\");\n\t}\n\n\tchained_irq_exit(chip, desc);\n}\n\nstatic void brcm_msi_compose_msi_msg(struct irq_data *data, struct msi_msg *msg)\n{\n\tstruct brcm_msi *msi = irq_data_get_irq_chip_data(data);\n\n\tmsg->address_lo = lower_32_bits(msi->target_addr);\n\tmsg->address_hi = upper_32_bits(msi->target_addr);\n\tmsg->data = (0xffff & PCIE_MISC_MSI_DATA_CONFIG_VAL_32) | data->hwirq;\n}\n\nstatic int brcm_msi_set_affinity(struct irq_data *irq_data,\n\t\t\t\t const struct cpumask *mask, bool force)\n{\n\treturn -EINVAL;\n}\n\nstatic void brcm_msi_ack_irq(struct irq_data *data)\n{\n\tstruct brcm_msi *msi = irq_data_get_irq_chip_data(data);\n\tconst int shift_amt = data->hwirq + msi->legacy_shift;\n\n\twritel(1 << shift_amt, msi->intr_base + MSI_INT_CLR);\n}\n\n\nstatic struct irq_chip brcm_msi_bottom_irq_chip = {\n\t.name\t\t\t= \"BRCM STB MSI\",\n\t.irq_compose_msi_msg\t= brcm_msi_compose_msi_msg,\n\t.irq_set_affinity\t= brcm_msi_set_affinity,\n\t.irq_ack                = brcm_msi_ack_irq,\n};\n\nstatic int brcm_msi_alloc(struct brcm_msi *msi, unsigned int nr_irqs)\n{\n\tint hwirq;\n\n\tmutex_lock(&msi->lock);\n\thwirq = bitmap_find_free_region(msi->used, msi->nr,\n\t\t\t\t\torder_base_2(nr_irqs));\n\tmutex_unlock(&msi->lock);\n\n\treturn hwirq;\n}\n\nstatic void brcm_msi_free(struct brcm_msi *msi, unsigned long hwirq,\n\t\t\t  unsigned int nr_irqs)\n{\n\tmutex_lock(&msi->lock);\n\tbitmap_release_region(msi->used, hwirq, order_base_2(nr_irqs));\n\tmutex_unlock(&msi->lock);\n}\n\nstatic int brcm_irq_domain_alloc(struct irq_domain *domain, unsigned int virq,\n\t\t\t\t unsigned int nr_irqs, void *args)\n{\n\tstruct brcm_msi *msi = domain->host_data;\n\tint hwirq, i;\n\n\thwirq = brcm_msi_alloc(msi, nr_irqs);\n\n\tif (hwirq < 0)\n\t\treturn hwirq;\n\n\tfor (i = 0; i < nr_irqs; i++)\n\t\tirq_domain_set_info(domain, virq + i, hwirq + i,\n\t\t\t\t    &brcm_msi_bottom_irq_chip, domain->host_data,\n\t\t\t\t    handle_edge_irq, NULL, NULL);\n\treturn 0;\n}\n\nstatic void brcm_irq_domain_free(struct irq_domain *domain,\n\t\t\t\t unsigned int virq, unsigned int nr_irqs)\n{\n\tstruct irq_data *d = irq_domain_get_irq_data(domain, virq);\n\tstruct brcm_msi *msi = irq_data_get_irq_chip_data(d);\n\n\tbrcm_msi_free(msi, d->hwirq, nr_irqs);\n}\n\nstatic const struct irq_domain_ops msi_domain_ops = {\n\t.alloc\t= brcm_irq_domain_alloc,\n\t.free\t= brcm_irq_domain_free,\n};\n\nstatic int brcm_allocate_domains(struct brcm_msi *msi)\n{\n\tstruct fwnode_handle *fwnode = of_node_to_fwnode(msi->np);\n\tstruct device *dev = msi->dev;\n\n\tmsi->inner_domain = irq_domain_add_linear(NULL, msi->nr, &msi_domain_ops, msi);\n\tif (!msi->inner_domain) {\n\t\tdev_err(dev, \"failed to create IRQ domain\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tmsi->msi_domain = pci_msi_create_irq_domain(fwnode,\n\t\t\t\t\t\t    &brcm_msi_domain_info,\n\t\t\t\t\t\t    msi->inner_domain);\n\tif (!msi->msi_domain) {\n\t\tdev_err(dev, \"failed to create MSI domain\\n\");\n\t\tirq_domain_remove(msi->inner_domain);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic void brcm_free_domains(struct brcm_msi *msi)\n{\n\tirq_domain_remove(msi->msi_domain);\n\tirq_domain_remove(msi->inner_domain);\n}\n\nstatic void brcm_msi_remove(struct brcm_pcie *pcie)\n{\n\tstruct brcm_msi *msi = pcie->msi;\n\n\tif (!msi)\n\t\treturn;\n\tirq_set_chained_handler_and_data(msi->irq, NULL, NULL);\n\tbrcm_free_domains(msi);\n}\n\nstatic void brcm_msi_set_regs(struct brcm_msi *msi)\n{\n\tu32 val = msi->legacy ? BRCM_INT_PCI_MSI_LEGACY_MASK :\n\t\t\t\tBRCM_INT_PCI_MSI_MASK;\n\n\twritel(val, msi->intr_base + MSI_INT_MASK_CLR);\n\twritel(val, msi->intr_base + MSI_INT_CLR);\n\n\t \n\twritel(lower_32_bits(msi->target_addr) | 0x1,\n\t       msi->base + PCIE_MISC_MSI_BAR_CONFIG_LO);\n\twritel(upper_32_bits(msi->target_addr),\n\t       msi->base + PCIE_MISC_MSI_BAR_CONFIG_HI);\n\n\tval = msi->legacy ? PCIE_MISC_MSI_DATA_CONFIG_VAL_8 : PCIE_MISC_MSI_DATA_CONFIG_VAL_32;\n\twritel(val, msi->base + PCIE_MISC_MSI_DATA_CONFIG);\n}\n\nstatic int brcm_pcie_enable_msi(struct brcm_pcie *pcie)\n{\n\tstruct brcm_msi *msi;\n\tint irq, ret;\n\tstruct device *dev = pcie->dev;\n\n\tirq = irq_of_parse_and_map(dev->of_node, 1);\n\tif (irq <= 0) {\n\t\tdev_err(dev, \"cannot map MSI interrupt\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tmsi = devm_kzalloc(dev, sizeof(struct brcm_msi), GFP_KERNEL);\n\tif (!msi)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&msi->lock);\n\tmsi->dev = dev;\n\tmsi->base = pcie->base;\n\tmsi->np = pcie->np;\n\tmsi->target_addr = pcie->msi_target_addr;\n\tmsi->irq = irq;\n\tmsi->legacy = pcie->hw_rev < BRCM_PCIE_HW_REV_33;\n\n\t \n\tBUILD_BUG_ON(BRCM_INT_PCI_MSI_LEGACY_NR > BRCM_INT_PCI_MSI_NR);\n\n\tif (msi->legacy) {\n\t\tmsi->intr_base = msi->base + PCIE_INTR2_CPU_BASE;\n\t\tmsi->nr = BRCM_INT_PCI_MSI_LEGACY_NR;\n\t\tmsi->legacy_shift = 24;\n\t} else {\n\t\tmsi->intr_base = msi->base + PCIE_MSI_INTR2_BASE;\n\t\tmsi->nr = BRCM_INT_PCI_MSI_NR;\n\t\tmsi->legacy_shift = 0;\n\t}\n\n\tret = brcm_allocate_domains(msi);\n\tif (ret)\n\t\treturn ret;\n\n\tirq_set_chained_handler_and_data(msi->irq, brcm_pcie_msi_isr, msi);\n\n\tbrcm_msi_set_regs(msi);\n\tpcie->msi = msi;\n\n\treturn 0;\n}\n\n \nstatic bool brcm_pcie_rc_mode(struct brcm_pcie *pcie)\n{\n\tvoid __iomem *base = pcie->base;\n\tu32 val = readl(base + PCIE_MISC_PCIE_STATUS);\n\n\treturn !!FIELD_GET(PCIE_MISC_PCIE_STATUS_PCIE_PORT_MASK, val);\n}\n\nstatic bool brcm_pcie_link_up(struct brcm_pcie *pcie)\n{\n\tu32 val = readl(pcie->base + PCIE_MISC_PCIE_STATUS);\n\tu32 dla = FIELD_GET(PCIE_MISC_PCIE_STATUS_PCIE_DL_ACTIVE_MASK, val);\n\tu32 plu = FIELD_GET(PCIE_MISC_PCIE_STATUS_PCIE_PHYLINKUP_MASK, val);\n\n\treturn dla && plu;\n}\n\nstatic void __iomem *brcm_pcie_map_bus(struct pci_bus *bus,\n\t\t\t\t       unsigned int devfn, int where)\n{\n\tstruct brcm_pcie *pcie = bus->sysdata;\n\tvoid __iomem *base = pcie->base;\n\tint idx;\n\n\t \n\tif (pci_is_root_bus(bus))\n\t\treturn devfn ? NULL : base + PCIE_ECAM_REG(where);\n\n\t \n\tif (!brcm_pcie_link_up(pcie))\n\t\treturn NULL;\n\n\t \n\tidx = PCIE_ECAM_OFFSET(bus->number, devfn, 0);\n\twritel(idx, pcie->base + PCIE_EXT_CFG_INDEX);\n\treturn base + PCIE_EXT_CFG_DATA + PCIE_ECAM_REG(where);\n}\n\nstatic void __iomem *brcm7425_pcie_map_bus(struct pci_bus *bus,\n\t\t\t\t\t   unsigned int devfn, int where)\n{\n\tstruct brcm_pcie *pcie = bus->sysdata;\n\tvoid __iomem *base = pcie->base;\n\tint idx;\n\n\t \n\tif (pci_is_root_bus(bus))\n\t\treturn devfn ? NULL : base + PCIE_ECAM_REG(where);\n\n\t \n\tif (!brcm_pcie_link_up(pcie))\n\t\treturn NULL;\n\n\t \n\tidx = PCIE_ECAM_OFFSET(bus->number, devfn, where);\n\twritel(idx, base + IDX_ADDR(pcie));\n\treturn base + DATA_ADDR(pcie);\n}\n\nstatic void brcm_pcie_bridge_sw_init_set_generic(struct brcm_pcie *pcie, u32 val)\n{\n\tu32 tmp, mask =  RGR1_SW_INIT_1_INIT_GENERIC_MASK;\n\tu32 shift = RGR1_SW_INIT_1_INIT_GENERIC_SHIFT;\n\n\ttmp = readl(pcie->base + PCIE_RGR1_SW_INIT_1(pcie));\n\ttmp = (tmp & ~mask) | ((val << shift) & mask);\n\twritel(tmp, pcie->base + PCIE_RGR1_SW_INIT_1(pcie));\n}\n\nstatic void brcm_pcie_bridge_sw_init_set_7278(struct brcm_pcie *pcie, u32 val)\n{\n\tu32 tmp, mask =  RGR1_SW_INIT_1_INIT_7278_MASK;\n\tu32 shift = RGR1_SW_INIT_1_INIT_7278_SHIFT;\n\n\ttmp = readl(pcie->base + PCIE_RGR1_SW_INIT_1(pcie));\n\ttmp = (tmp & ~mask) | ((val << shift) & mask);\n\twritel(tmp, pcie->base + PCIE_RGR1_SW_INIT_1(pcie));\n}\n\nstatic void brcm_pcie_perst_set_4908(struct brcm_pcie *pcie, u32 val)\n{\n\tif (WARN_ONCE(!pcie->perst_reset, \"missing PERST# reset controller\\n\"))\n\t\treturn;\n\n\tif (val)\n\t\treset_control_assert(pcie->perst_reset);\n\telse\n\t\treset_control_deassert(pcie->perst_reset);\n}\n\nstatic void brcm_pcie_perst_set_7278(struct brcm_pcie *pcie, u32 val)\n{\n\tu32 tmp;\n\n\t \n\ttmp = readl(pcie->base + PCIE_MISC_PCIE_CTRL);\n\tu32p_replace_bits(&tmp, !val, PCIE_MISC_PCIE_CTRL_PCIE_PERSTB_MASK);\n\twritel(tmp, pcie->base +  PCIE_MISC_PCIE_CTRL);\n}\n\nstatic void brcm_pcie_perst_set_generic(struct brcm_pcie *pcie, u32 val)\n{\n\tu32 tmp;\n\n\ttmp = readl(pcie->base + PCIE_RGR1_SW_INIT_1(pcie));\n\tu32p_replace_bits(&tmp, val, PCIE_RGR1_SW_INIT_1_PERST_MASK);\n\twritel(tmp, pcie->base + PCIE_RGR1_SW_INIT_1(pcie));\n}\n\nstatic int brcm_pcie_get_rc_bar2_size_and_offset(struct brcm_pcie *pcie,\n\t\t\t\t\t\t\tu64 *rc_bar2_size,\n\t\t\t\t\t\t\tu64 *rc_bar2_offset)\n{\n\tstruct pci_host_bridge *bridge = pci_host_bridge_from_priv(pcie);\n\tstruct resource_entry *entry;\n\tstruct device *dev = pcie->dev;\n\tu64 lowest_pcie_addr = ~(u64)0;\n\tint ret, i = 0;\n\tu64 size = 0;\n\n\tresource_list_for_each_entry(entry, &bridge->dma_ranges) {\n\t\tu64 pcie_beg = entry->res->start - entry->offset;\n\n\t\tsize += entry->res->end - entry->res->start + 1;\n\t\tif (pcie_beg < lowest_pcie_addr)\n\t\t\tlowest_pcie_addr = pcie_beg;\n\t}\n\n\tif (lowest_pcie_addr == ~(u64)0) {\n\t\tdev_err(dev, \"DT node has no dma-ranges\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = of_property_read_variable_u64_array(pcie->np, \"brcm,scb-sizes\", pcie->memc_size, 1,\n\t\t\t\t\t\t  PCIE_BRCM_MAX_MEMC);\n\n\tif (ret <= 0) {\n\t\t \n\t\tpcie->num_memc = 1;\n\t\tpcie->memc_size[0] = 1ULL << fls64(size - 1);\n\t} else {\n\t\tpcie->num_memc = ret;\n\t}\n\n\t \n\tfor (i = 0, size = 0; i < pcie->num_memc; i++)\n\t\tsize += pcie->memc_size[i];\n\n\t \n\t*rc_bar2_offset = lowest_pcie_addr;\n\t \n\t*rc_bar2_size = 1ULL << fls64(size - 1);\n\n\t \n\tif (!*rc_bar2_size || (*rc_bar2_offset & (*rc_bar2_size - 1)) ||\n\t    (*rc_bar2_offset < SZ_4G && *rc_bar2_offset > SZ_2G)) {\n\t\tdev_err(dev, \"Invalid rc_bar2_offset/size: size 0x%llx, off 0x%llx\\n\",\n\t\t\t*rc_bar2_size, *rc_bar2_offset);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int brcm_pcie_setup(struct brcm_pcie *pcie)\n{\n\tu64 rc_bar2_offset, rc_bar2_size;\n\tvoid __iomem *base = pcie->base;\n\tstruct pci_host_bridge *bridge;\n\tstruct resource_entry *entry;\n\tu32 tmp, burst, aspm_support;\n\tint num_out_wins = 0;\n\tint ret, memc;\n\n\t \n\tpcie->bridge_sw_init_set(pcie, 1);\n\n\t \n\tif (pcie->type == BCM2711)\n\t\tpcie->perst_set(pcie, 1);\n\n\tusleep_range(100, 200);\n\n\t \n\tpcie->bridge_sw_init_set(pcie, 0);\n\n\ttmp = readl(base + PCIE_MISC_HARD_PCIE_HARD_DEBUG);\n\tif (is_bmips(pcie))\n\t\ttmp &= ~PCIE_BMIPS_MISC_HARD_PCIE_HARD_DEBUG_SERDES_IDDQ_MASK;\n\telse\n\t\ttmp &= ~PCIE_MISC_HARD_PCIE_HARD_DEBUG_SERDES_IDDQ_MASK;\n\twritel(tmp, base + PCIE_MISC_HARD_PCIE_HARD_DEBUG);\n\t \n\tusleep_range(100, 200);\n\n\t \n\tif (is_bmips(pcie))\n\t\tburst = 0x1;  \n\telse if (pcie->type == BCM2711)\n\t\tburst = 0x0;  \n\telse if (pcie->type == BCM7278)\n\t\tburst = 0x3;  \n\telse\n\t\tburst = 0x2;  \n\n\t \n\ttmp = readl(base + PCIE_MISC_MISC_CTRL);\n\tu32p_replace_bits(&tmp, 1, PCIE_MISC_MISC_CTRL_SCB_ACCESS_EN_MASK);\n\tu32p_replace_bits(&tmp, 1, PCIE_MISC_MISC_CTRL_CFG_READ_UR_MODE_MASK);\n\tu32p_replace_bits(&tmp, burst, PCIE_MISC_MISC_CTRL_MAX_BURST_SIZE_MASK);\n\tu32p_replace_bits(&tmp, 1, PCIE_MISC_MISC_CTRL_PCIE_RCB_MPS_MODE_MASK);\n\tu32p_replace_bits(&tmp, 1, PCIE_MISC_MISC_CTRL_PCIE_RCB_64B_MODE_MASK);\n\twritel(tmp, base + PCIE_MISC_MISC_CTRL);\n\n\tret = brcm_pcie_get_rc_bar2_size_and_offset(pcie, &rc_bar2_size,\n\t\t\t\t\t\t    &rc_bar2_offset);\n\tif (ret)\n\t\treturn ret;\n\n\ttmp = lower_32_bits(rc_bar2_offset);\n\tu32p_replace_bits(&tmp, brcm_pcie_encode_ibar_size(rc_bar2_size),\n\t\t\t  PCIE_MISC_RC_BAR2_CONFIG_LO_SIZE_MASK);\n\twritel(tmp, base + PCIE_MISC_RC_BAR2_CONFIG_LO);\n\twritel(upper_32_bits(rc_bar2_offset),\n\t       base + PCIE_MISC_RC_BAR2_CONFIG_HI);\n\n\ttmp = readl(base + PCIE_MISC_MISC_CTRL);\n\tfor (memc = 0; memc < pcie->num_memc; memc++) {\n\t\tu32 scb_size_val = ilog2(pcie->memc_size[memc]) - 15;\n\n\t\tif (memc == 0)\n\t\t\tu32p_replace_bits(&tmp, scb_size_val, SCB_SIZE_MASK(0));\n\t\telse if (memc == 1)\n\t\t\tu32p_replace_bits(&tmp, scb_size_val, SCB_SIZE_MASK(1));\n\t\telse if (memc == 2)\n\t\t\tu32p_replace_bits(&tmp, scb_size_val, SCB_SIZE_MASK(2));\n\t}\n\twritel(tmp, base + PCIE_MISC_MISC_CTRL);\n\n\t \n\tif (rc_bar2_offset >= SZ_4G || (rc_bar2_size + rc_bar2_offset) < SZ_4G)\n\t\tpcie->msi_target_addr = BRCM_MSI_TARGET_ADDR_LT_4GB;\n\telse\n\t\tpcie->msi_target_addr = BRCM_MSI_TARGET_ADDR_GT_4GB;\n\n\tif (!brcm_pcie_rc_mode(pcie)) {\n\t\tdev_err(pcie->dev, \"PCIe RC controller misconfigured as Endpoint\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\ttmp = readl(base + PCIE_MISC_RC_BAR1_CONFIG_LO);\n\ttmp &= ~PCIE_MISC_RC_BAR1_CONFIG_LO_SIZE_MASK;\n\twritel(tmp, base + PCIE_MISC_RC_BAR1_CONFIG_LO);\n\n\t \n\ttmp = readl(base + PCIE_MISC_RC_BAR3_CONFIG_LO);\n\ttmp &= ~PCIE_MISC_RC_BAR3_CONFIG_LO_SIZE_MASK;\n\twritel(tmp, base + PCIE_MISC_RC_BAR3_CONFIG_LO);\n\n\t \n\taspm_support = PCIE_LINK_STATE_L1;\n\tif (!of_property_read_bool(pcie->np, \"aspm-no-l0s\"))\n\t\taspm_support |= PCIE_LINK_STATE_L0S;\n\ttmp = readl(base + PCIE_RC_CFG_PRIV1_LINK_CAPABILITY);\n\tu32p_replace_bits(&tmp, aspm_support,\n\t\tPCIE_RC_CFG_PRIV1_LINK_CAPABILITY_ASPM_SUPPORT_MASK);\n\twritel(tmp, base + PCIE_RC_CFG_PRIV1_LINK_CAPABILITY);\n\n\t \n\ttmp = readl(base + PCIE_RC_CFG_PRIV1_ID_VAL3);\n\tu32p_replace_bits(&tmp, 0x060400,\n\t\t\t  PCIE_RC_CFG_PRIV1_ID_VAL3_CLASS_CODE_MASK);\n\twritel(tmp, base + PCIE_RC_CFG_PRIV1_ID_VAL3);\n\n\tbridge = pci_host_bridge_from_priv(pcie);\n\tresource_list_for_each_entry(entry, &bridge->windows) {\n\t\tstruct resource *res = entry->res;\n\n\t\tif (resource_type(res) != IORESOURCE_MEM)\n\t\t\tcontinue;\n\n\t\tif (num_out_wins >= BRCM_NUM_PCIE_OUT_WINS) {\n\t\t\tdev_err(pcie->dev, \"too many outbound wins\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (is_bmips(pcie)) {\n\t\t\tu64 start = res->start;\n\t\t\tunsigned int j, nwins = resource_size(res) / SZ_128M;\n\n\t\t\t \n\t\t\tif (nwins > BRCM_NUM_PCIE_OUT_WINS)\n\t\t\t\tnwins = BRCM_NUM_PCIE_OUT_WINS;\n\t\t\tfor (j = 0; j < nwins; j++, start += SZ_128M)\n\t\t\t\tbrcm_pcie_set_outbound_win(pcie, j, start,\n\t\t\t\t\t\t\t   start - entry->offset,\n\t\t\t\t\t\t\t   SZ_128M);\n\t\t\tbreak;\n\t\t}\n\t\tbrcm_pcie_set_outbound_win(pcie, num_out_wins, res->start,\n\t\t\t\t\t   res->start - entry->offset,\n\t\t\t\t\t   resource_size(res));\n\t\tnum_out_wins++;\n\t}\n\n\t \n\ttmp = readl(base + PCIE_RC_CFG_VENDOR_VENDOR_SPECIFIC_REG1);\n\tu32p_replace_bits(&tmp, PCIE_RC_CFG_VENDOR_SPCIFIC_REG1_LITTLE_ENDIAN,\n\t\tPCIE_RC_CFG_VENDOR_VENDOR_SPECIFIC_REG1_ENDIAN_MODE_BAR2_MASK);\n\twritel(tmp, base + PCIE_RC_CFG_VENDOR_VENDOR_SPECIFIC_REG1);\n\n\treturn 0;\n}\n\nstatic int brcm_pcie_start_link(struct brcm_pcie *pcie)\n{\n\tstruct device *dev = pcie->dev;\n\tvoid __iomem *base = pcie->base;\n\tu16 nlw, cls, lnksta;\n\tbool ssc_good = false;\n\tu32 tmp;\n\tint ret, i;\n\n\t \n\tpcie->perst_set(pcie, 0);\n\n\t \n\tmsleep(100);\n\n\t \n\tfor (i = 0; i < 100 && !brcm_pcie_link_up(pcie); i += 5)\n\t\tmsleep(5);\n\n\tif (!brcm_pcie_link_up(pcie)) {\n\t\tdev_err(dev, \"link down\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (pcie->gen)\n\t\tbrcm_pcie_set_gen(pcie, pcie->gen);\n\n\tif (pcie->ssc) {\n\t\tret = brcm_pcie_set_ssc(pcie);\n\t\tif (ret == 0)\n\t\t\tssc_good = true;\n\t\telse\n\t\t\tdev_err(dev, \"failed attempt to enter ssc mode\\n\");\n\t}\n\n\tlnksta = readw(base + BRCM_PCIE_CAP_REGS + PCI_EXP_LNKSTA);\n\tcls = FIELD_GET(PCI_EXP_LNKSTA_CLS, lnksta);\n\tnlw = FIELD_GET(PCI_EXP_LNKSTA_NLW, lnksta);\n\tdev_info(dev, \"link up, %s x%u %s\\n\",\n\t\t pci_speed_string(pcie_link_speed[cls]), nlw,\n\t\t ssc_good ? \"(SSC)\" : \"(!SSC)\");\n\n\t \n\ttmp = readl(base + PCIE_MISC_HARD_PCIE_HARD_DEBUG);\n\ttmp |= PCIE_MISC_HARD_PCIE_HARD_DEBUG_CLKREQ_DEBUG_ENABLE_MASK;\n\twritel(tmp, base + PCIE_MISC_HARD_PCIE_HARD_DEBUG);\n\n\treturn 0;\n}\n\nstatic const char * const supplies[] = {\n\t\"vpcie3v3\",\n\t\"vpcie3v3aux\",\n\t\"vpcie12v\",\n};\n\nstatic void *alloc_subdev_regulators(struct device *dev)\n{\n\tconst size_t size = sizeof(struct subdev_regulators) +\n\t\tsizeof(struct regulator_bulk_data) * ARRAY_SIZE(supplies);\n\tstruct subdev_regulators *sr;\n\tint i;\n\n\tsr = devm_kzalloc(dev, size, GFP_KERNEL);\n\tif (sr) {\n\t\tsr->num_supplies = ARRAY_SIZE(supplies);\n\t\tfor (i = 0; i < ARRAY_SIZE(supplies); i++)\n\t\t\tsr->supplies[i].supply = supplies[i];\n\t}\n\n\treturn sr;\n}\n\nstatic int brcm_pcie_add_bus(struct pci_bus *bus)\n{\n\tstruct brcm_pcie *pcie = bus->sysdata;\n\tstruct device *dev = &bus->dev;\n\tstruct subdev_regulators *sr;\n\tint ret;\n\n\tif (!bus->parent || !pci_is_root_bus(bus->parent))\n\t\treturn 0;\n\n\tif (dev->of_node) {\n\t\tsr = alloc_subdev_regulators(dev);\n\t\tif (!sr) {\n\t\t\tdev_info(dev, \"Can't allocate regulators for downstream device\\n\");\n\t\t\tgoto no_regulators;\n\t\t}\n\n\t\tpcie->sr = sr;\n\n\t\tret = regulator_bulk_get(dev, sr->num_supplies, sr->supplies);\n\t\tif (ret) {\n\t\t\tdev_info(dev, \"No regulators for downstream device\\n\");\n\t\t\tgoto no_regulators;\n\t\t}\n\n\t\tret = regulator_bulk_enable(sr->num_supplies, sr->supplies);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Can't enable regulators for downstream device\\n\");\n\t\t\tregulator_bulk_free(sr->num_supplies, sr->supplies);\n\t\t\tpcie->sr = NULL;\n\t\t}\n\t}\n\nno_regulators:\n\tbrcm_pcie_start_link(pcie);\n\treturn 0;\n}\n\nstatic void brcm_pcie_remove_bus(struct pci_bus *bus)\n{\n\tstruct brcm_pcie *pcie = bus->sysdata;\n\tstruct subdev_regulators *sr = pcie->sr;\n\tstruct device *dev = &bus->dev;\n\n\tif (!sr)\n\t\treturn;\n\n\tif (regulator_bulk_disable(sr->num_supplies, sr->supplies))\n\t\tdev_err(dev, \"Failed to disable regulators for downstream device\\n\");\n\tregulator_bulk_free(sr->num_supplies, sr->supplies);\n\tpcie->sr = NULL;\n}\n\n \nstatic void brcm_pcie_enter_l23(struct brcm_pcie *pcie)\n{\n\tvoid __iomem *base = pcie->base;\n\tint l23, i;\n\tu32 tmp;\n\n\t \n\ttmp = readl(base + PCIE_MISC_PCIE_CTRL);\n\tu32p_replace_bits(&tmp, 1, PCIE_MISC_PCIE_CTRL_PCIE_L23_REQUEST_MASK);\n\twritel(tmp, base + PCIE_MISC_PCIE_CTRL);\n\n\t \n\ttmp = readl(base + PCIE_MISC_PCIE_STATUS);\n\tl23 = FIELD_GET(PCIE_MISC_PCIE_STATUS_PCIE_LINK_IN_L23_MASK, tmp);\n\tfor (i = 0; i < 15 && !l23; i++) {\n\t\tusleep_range(2000, 2400);\n\t\ttmp = readl(base + PCIE_MISC_PCIE_STATUS);\n\t\tl23 = FIELD_GET(PCIE_MISC_PCIE_STATUS_PCIE_LINK_IN_L23_MASK,\n\t\t\t\ttmp);\n\t}\n\n\tif (!l23)\n\t\tdev_err(pcie->dev, \"failed to enter low-power link state\\n\");\n}\n\nstatic int brcm_phy_cntl(struct brcm_pcie *pcie, const int start)\n{\n\tstatic const u32 shifts[PCIE_DVT_PMU_PCIE_PHY_CTRL_DAST_NFLDS] = {\n\t\tPCIE_DVT_PMU_PCIE_PHY_CTRL_DAST_PWRDN_SHIFT,\n\t\tPCIE_DVT_PMU_PCIE_PHY_CTRL_DAST_RESET_SHIFT,\n\t\tPCIE_DVT_PMU_PCIE_PHY_CTRL_DAST_DIG_RESET_SHIFT,};\n\tstatic const u32 masks[PCIE_DVT_PMU_PCIE_PHY_CTRL_DAST_NFLDS] = {\n\t\tPCIE_DVT_PMU_PCIE_PHY_CTRL_DAST_PWRDN_MASK,\n\t\tPCIE_DVT_PMU_PCIE_PHY_CTRL_DAST_RESET_MASK,\n\t\tPCIE_DVT_PMU_PCIE_PHY_CTRL_DAST_DIG_RESET_MASK,};\n\tconst int beg = start ? 0 : PCIE_DVT_PMU_PCIE_PHY_CTRL_DAST_NFLDS - 1;\n\tconst int end = start ? PCIE_DVT_PMU_PCIE_PHY_CTRL_DAST_NFLDS : -1;\n\tu32 tmp, combined_mask = 0;\n\tu32 val;\n\tvoid __iomem *base = pcie->base;\n\tint i, ret;\n\n\tfor (i = beg; i != end; start ? i++ : i--) {\n\t\tval = start ? BIT_MASK(shifts[i]) : 0;\n\t\ttmp = readl(base + PCIE_DVT_PMU_PCIE_PHY_CTRL);\n\t\ttmp = (tmp & ~masks[i]) | (val & masks[i]);\n\t\twritel(tmp, base + PCIE_DVT_PMU_PCIE_PHY_CTRL);\n\t\tusleep_range(50, 200);\n\t\tcombined_mask |= masks[i];\n\t}\n\n\ttmp = readl(base + PCIE_DVT_PMU_PCIE_PHY_CTRL);\n\tval = start ? combined_mask : 0;\n\n\tret = (tmp & combined_mask) == val ? 0 : -EIO;\n\tif (ret)\n\t\tdev_err(pcie->dev, \"failed to %s phy\\n\", (start ? \"start\" : \"stop\"));\n\n\treturn ret;\n}\n\nstatic inline int brcm_phy_start(struct brcm_pcie *pcie)\n{\n\treturn pcie->rescal ? brcm_phy_cntl(pcie, 1) : 0;\n}\n\nstatic inline int brcm_phy_stop(struct brcm_pcie *pcie)\n{\n\treturn pcie->rescal ? brcm_phy_cntl(pcie, 0) : 0;\n}\n\nstatic void brcm_pcie_turn_off(struct brcm_pcie *pcie)\n{\n\tvoid __iomem *base = pcie->base;\n\tint tmp;\n\n\tif (brcm_pcie_link_up(pcie))\n\t\tbrcm_pcie_enter_l23(pcie);\n\t \n\tpcie->perst_set(pcie, 1);\n\n\t \n\ttmp = readl(base + PCIE_MISC_PCIE_CTRL);\n\tu32p_replace_bits(&tmp, 0, PCIE_MISC_PCIE_CTRL_PCIE_L23_REQUEST_MASK);\n\twritel(tmp, base + PCIE_MISC_PCIE_CTRL);\n\n\t \n\ttmp = readl(base + PCIE_MISC_HARD_PCIE_HARD_DEBUG);\n\tu32p_replace_bits(&tmp, 1, PCIE_MISC_HARD_PCIE_HARD_DEBUG_SERDES_IDDQ_MASK);\n\twritel(tmp, base + PCIE_MISC_HARD_PCIE_HARD_DEBUG);\n\n\t \n\tpcie->bridge_sw_init_set(pcie, 1);\n}\n\nstatic int pci_dev_may_wakeup(struct pci_dev *dev, void *data)\n{\n\tbool *ret = data;\n\n\tif (device_may_wakeup(&dev->dev)) {\n\t\t*ret = true;\n\t\tdev_info(&dev->dev, \"Possible wake-up device; regulators will not be disabled\\n\");\n\t}\n\treturn (int) *ret;\n}\n\nstatic int brcm_pcie_suspend_noirq(struct device *dev)\n{\n\tstruct brcm_pcie *pcie = dev_get_drvdata(dev);\n\tstruct pci_host_bridge *bridge = pci_host_bridge_from_priv(pcie);\n\tint ret;\n\n\tbrcm_pcie_turn_off(pcie);\n\t \n\tif (brcm_phy_stop(pcie))\n\t\tdev_err(dev, \"Could not stop phy for suspend\\n\");\n\n\tret = reset_control_rearm(pcie->rescal);\n\tif (ret) {\n\t\tdev_err(dev, \"Could not rearm rescal reset\\n\");\n\t\treturn ret;\n\t}\n\n\tif (pcie->sr) {\n\t\t \n\t\tpcie->ep_wakeup_capable = false;\n\t\tpci_walk_bus(bridge->bus, pci_dev_may_wakeup,\n\t\t\t     &pcie->ep_wakeup_capable);\n\t\tif (!pcie->ep_wakeup_capable) {\n\t\t\tret = regulator_bulk_disable(pcie->sr->num_supplies,\n\t\t\t\t\t\t     pcie->sr->supplies);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(dev, \"Could not turn off regulators\\n\");\n\t\t\t\treset_control_reset(pcie->rescal);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\tclk_disable_unprepare(pcie->clk);\n\n\treturn 0;\n}\n\nstatic int brcm_pcie_resume_noirq(struct device *dev)\n{\n\tstruct brcm_pcie *pcie = dev_get_drvdata(dev);\n\tvoid __iomem *base;\n\tu32 tmp;\n\tint ret;\n\n\tbase = pcie->base;\n\tret = clk_prepare_enable(pcie->clk);\n\tif (ret)\n\t\treturn ret;\n\n\tret = reset_control_reset(pcie->rescal);\n\tif (ret)\n\t\tgoto err_disable_clk;\n\n\tret = brcm_phy_start(pcie);\n\tif (ret)\n\t\tgoto err_reset;\n\n\t \n\tpcie->bridge_sw_init_set(pcie, 0);\n\n\t \n\ttmp = readl(base + PCIE_MISC_HARD_PCIE_HARD_DEBUG);\n\tu32p_replace_bits(&tmp, 0, PCIE_MISC_HARD_PCIE_HARD_DEBUG_SERDES_IDDQ_MASK);\n\twritel(tmp, base + PCIE_MISC_HARD_PCIE_HARD_DEBUG);\n\n\t \n\tudelay(100);\n\n\tret = brcm_pcie_setup(pcie);\n\tif (ret)\n\t\tgoto err_reset;\n\n\tif (pcie->sr) {\n\t\tif (pcie->ep_wakeup_capable) {\n\t\t\t \n\t\t\tpcie->ep_wakeup_capable = false;\n\t\t} else {\n\t\t\tret = regulator_bulk_enable(pcie->sr->num_supplies,\n\t\t\t\t\t\t    pcie->sr->supplies);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(dev, \"Could not turn on regulators\\n\");\n\t\t\t\tgoto err_reset;\n\t\t\t}\n\t\t}\n\t}\n\n\tret = brcm_pcie_start_link(pcie);\n\tif (ret)\n\t\tgoto err_regulator;\n\n\tif (pcie->msi)\n\t\tbrcm_msi_set_regs(pcie->msi);\n\n\treturn 0;\n\nerr_regulator:\n\tif (pcie->sr)\n\t\tregulator_bulk_disable(pcie->sr->num_supplies, pcie->sr->supplies);\nerr_reset:\n\treset_control_rearm(pcie->rescal);\nerr_disable_clk:\n\tclk_disable_unprepare(pcie->clk);\n\treturn ret;\n}\n\nstatic void __brcm_pcie_remove(struct brcm_pcie *pcie)\n{\n\tbrcm_msi_remove(pcie);\n\tbrcm_pcie_turn_off(pcie);\n\tif (brcm_phy_stop(pcie))\n\t\tdev_err(pcie->dev, \"Could not stop phy\\n\");\n\tif (reset_control_rearm(pcie->rescal))\n\t\tdev_err(pcie->dev, \"Could not rearm rescal reset\\n\");\n\tclk_disable_unprepare(pcie->clk);\n}\n\nstatic void brcm_pcie_remove(struct platform_device *pdev)\n{\n\tstruct brcm_pcie *pcie = platform_get_drvdata(pdev);\n\tstruct pci_host_bridge *bridge = pci_host_bridge_from_priv(pcie);\n\n\tpci_stop_root_bus(bridge->bus);\n\tpci_remove_root_bus(bridge->bus);\n\t__brcm_pcie_remove(pcie);\n}\n\nstatic const int pcie_offsets[] = {\n\t[RGR1_SW_INIT_1] = 0x9210,\n\t[EXT_CFG_INDEX]  = 0x9000,\n\t[EXT_CFG_DATA]   = 0x9004,\n};\n\nstatic const int pcie_offsets_bmips_7425[] = {\n\t[RGR1_SW_INIT_1] = 0x8010,\n\t[EXT_CFG_INDEX]  = 0x8300,\n\t[EXT_CFG_DATA]   = 0x8304,\n};\n\nstatic const struct pcie_cfg_data generic_cfg = {\n\t.offsets\t= pcie_offsets,\n\t.type\t\t= GENERIC,\n\t.perst_set\t= brcm_pcie_perst_set_generic,\n\t.bridge_sw_init_set = brcm_pcie_bridge_sw_init_set_generic,\n};\n\nstatic const struct pcie_cfg_data bcm7425_cfg = {\n\t.offsets\t= pcie_offsets_bmips_7425,\n\t.type\t\t= BCM7425,\n\t.perst_set\t= brcm_pcie_perst_set_generic,\n\t.bridge_sw_init_set = brcm_pcie_bridge_sw_init_set_generic,\n};\n\nstatic const struct pcie_cfg_data bcm7435_cfg = {\n\t.offsets\t= pcie_offsets,\n\t.type\t\t= BCM7435,\n\t.perst_set\t= brcm_pcie_perst_set_generic,\n\t.bridge_sw_init_set = brcm_pcie_bridge_sw_init_set_generic,\n};\n\nstatic const struct pcie_cfg_data bcm4908_cfg = {\n\t.offsets\t= pcie_offsets,\n\t.type\t\t= BCM4908,\n\t.perst_set\t= brcm_pcie_perst_set_4908,\n\t.bridge_sw_init_set = brcm_pcie_bridge_sw_init_set_generic,\n};\n\nstatic const int pcie_offset_bcm7278[] = {\n\t[RGR1_SW_INIT_1] = 0xc010,\n\t[EXT_CFG_INDEX] = 0x9000,\n\t[EXT_CFG_DATA] = 0x9004,\n};\n\nstatic const struct pcie_cfg_data bcm7278_cfg = {\n\t.offsets\t= pcie_offset_bcm7278,\n\t.type\t\t= BCM7278,\n\t.perst_set\t= brcm_pcie_perst_set_7278,\n\t.bridge_sw_init_set = brcm_pcie_bridge_sw_init_set_7278,\n};\n\nstatic const struct pcie_cfg_data bcm2711_cfg = {\n\t.offsets\t= pcie_offsets,\n\t.type\t\t= BCM2711,\n\t.perst_set\t= brcm_pcie_perst_set_generic,\n\t.bridge_sw_init_set = brcm_pcie_bridge_sw_init_set_generic,\n};\n\nstatic const struct of_device_id brcm_pcie_match[] = {\n\t{ .compatible = \"brcm,bcm2711-pcie\", .data = &bcm2711_cfg },\n\t{ .compatible = \"brcm,bcm4908-pcie\", .data = &bcm4908_cfg },\n\t{ .compatible = \"brcm,bcm7211-pcie\", .data = &generic_cfg },\n\t{ .compatible = \"brcm,bcm7278-pcie\", .data = &bcm7278_cfg },\n\t{ .compatible = \"brcm,bcm7216-pcie\", .data = &bcm7278_cfg },\n\t{ .compatible = \"brcm,bcm7445-pcie\", .data = &generic_cfg },\n\t{ .compatible = \"brcm,bcm7435-pcie\", .data = &bcm7435_cfg },\n\t{ .compatible = \"brcm,bcm7425-pcie\", .data = &bcm7425_cfg },\n\t{},\n};\n\nstatic struct pci_ops brcm_pcie_ops = {\n\t.map_bus = brcm_pcie_map_bus,\n\t.read = pci_generic_config_read,\n\t.write = pci_generic_config_write,\n\t.add_bus = brcm_pcie_add_bus,\n\t.remove_bus = brcm_pcie_remove_bus,\n};\n\nstatic struct pci_ops brcm7425_pcie_ops = {\n\t.map_bus = brcm7425_pcie_map_bus,\n\t.read = pci_generic_config_read32,\n\t.write = pci_generic_config_write32,\n\t.add_bus = brcm_pcie_add_bus,\n\t.remove_bus = brcm_pcie_remove_bus,\n};\n\nstatic int brcm_pcie_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node, *msi_np;\n\tstruct pci_host_bridge *bridge;\n\tconst struct pcie_cfg_data *data;\n\tstruct brcm_pcie *pcie;\n\tint ret;\n\n\tbridge = devm_pci_alloc_host_bridge(&pdev->dev, sizeof(*pcie));\n\tif (!bridge)\n\t\treturn -ENOMEM;\n\n\tdata = of_device_get_match_data(&pdev->dev);\n\tif (!data) {\n\t\tpr_err(\"failed to look up compatible string\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpcie = pci_host_bridge_priv(bridge);\n\tpcie->dev = &pdev->dev;\n\tpcie->np = np;\n\tpcie->reg_offsets = data->offsets;\n\tpcie->type = data->type;\n\tpcie->perst_set = data->perst_set;\n\tpcie->bridge_sw_init_set = data->bridge_sw_init_set;\n\n\tpcie->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(pcie->base))\n\t\treturn PTR_ERR(pcie->base);\n\n\tpcie->clk = devm_clk_get_optional(&pdev->dev, \"sw_pcie\");\n\tif (IS_ERR(pcie->clk))\n\t\treturn PTR_ERR(pcie->clk);\n\n\tret = of_pci_get_max_link_speed(np);\n\tpcie->gen = (ret < 0) ? 0 : ret;\n\n\tpcie->ssc = of_property_read_bool(np, \"brcm,enable-ssc\");\n\n\tret = clk_prepare_enable(pcie->clk);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"could not enable clock\\n\");\n\t\treturn ret;\n\t}\n\tpcie->rescal = devm_reset_control_get_optional_shared(&pdev->dev, \"rescal\");\n\tif (IS_ERR(pcie->rescal)) {\n\t\tclk_disable_unprepare(pcie->clk);\n\t\treturn PTR_ERR(pcie->rescal);\n\t}\n\tpcie->perst_reset = devm_reset_control_get_optional_exclusive(&pdev->dev, \"perst\");\n\tif (IS_ERR(pcie->perst_reset)) {\n\t\tclk_disable_unprepare(pcie->clk);\n\t\treturn PTR_ERR(pcie->perst_reset);\n\t}\n\n\tret = reset_control_reset(pcie->rescal);\n\tif (ret)\n\t\tdev_err(&pdev->dev, \"failed to deassert 'rescal'\\n\");\n\n\tret = brcm_phy_start(pcie);\n\tif (ret) {\n\t\treset_control_rearm(pcie->rescal);\n\t\tclk_disable_unprepare(pcie->clk);\n\t\treturn ret;\n\t}\n\n\tret = brcm_pcie_setup(pcie);\n\tif (ret)\n\t\tgoto fail;\n\n\tpcie->hw_rev = readl(pcie->base + PCIE_MISC_REVISION);\n\tif (pcie->type == BCM4908 && pcie->hw_rev >= BRCM_PCIE_HW_REV_3_20) {\n\t\tdev_err(pcie->dev, \"hardware revision with unsupported PERST# setup\\n\");\n\t\tret = -ENODEV;\n\t\tgoto fail;\n\t}\n\n\tmsi_np = of_parse_phandle(pcie->np, \"msi-parent\", 0);\n\tif (pci_msi_enabled() && msi_np == pcie->np) {\n\t\tret = brcm_pcie_enable_msi(pcie);\n\t\tif (ret) {\n\t\t\tdev_err(pcie->dev, \"probe of internal MSI failed\");\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tbridge->ops = pcie->type == BCM7425 ? &brcm7425_pcie_ops : &brcm_pcie_ops;\n\tbridge->sysdata = pcie;\n\n\tplatform_set_drvdata(pdev, pcie);\n\n\tret = pci_host_probe(bridge);\n\tif (!ret && !brcm_pcie_link_up(pcie))\n\t\tret = -ENODEV;\n\n\tif (ret) {\n\t\tbrcm_pcie_remove(pdev);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n\nfail:\n\t__brcm_pcie_remove(pcie);\n\treturn ret;\n}\n\nMODULE_DEVICE_TABLE(of, brcm_pcie_match);\n\nstatic const struct dev_pm_ops brcm_pcie_pm_ops = {\n\t.suspend_noirq = brcm_pcie_suspend_noirq,\n\t.resume_noirq = brcm_pcie_resume_noirq,\n};\n\nstatic struct platform_driver brcm_pcie_driver = {\n\t.probe = brcm_pcie_probe,\n\t.remove_new = brcm_pcie_remove,\n\t.driver = {\n\t\t.name = \"brcm-pcie\",\n\t\t.of_match_table = brcm_pcie_match,\n\t\t.pm = &brcm_pcie_pm_ops,\n\t},\n};\nmodule_platform_driver(brcm_pcie_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Broadcom STB PCIe RC driver\");\nMODULE_AUTHOR(\"Broadcom\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}