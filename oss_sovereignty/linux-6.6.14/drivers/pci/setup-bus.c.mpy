{
  "module_name": "setup-bus.c",
  "hash_id": "dcfe905c920674c48afdf5bdb83e821bb03740d086ca67b995dc73e97145a6a9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/setup-bus.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/errno.h>\n#include <linux/ioport.h>\n#include <linux/cache.h>\n#include <linux/slab.h>\n#include <linux/acpi.h>\n#include \"pci.h\"\n\nunsigned int pci_flags;\nEXPORT_SYMBOL_GPL(pci_flags);\n\nstruct pci_dev_resource {\n\tstruct list_head list;\n\tstruct resource *res;\n\tstruct pci_dev *dev;\n\tresource_size_t start;\n\tresource_size_t end;\n\tresource_size_t add_size;\n\tresource_size_t min_align;\n\tunsigned long flags;\n};\n\nstatic void free_list(struct list_head *head)\n{\n\tstruct pci_dev_resource *dev_res, *tmp;\n\n\tlist_for_each_entry_safe(dev_res, tmp, head, list) {\n\t\tlist_del(&dev_res->list);\n\t\tkfree(dev_res);\n\t}\n}\n\n \nstatic int add_to_list(struct list_head *head, struct pci_dev *dev,\n\t\t       struct resource *res, resource_size_t add_size,\n\t\t       resource_size_t min_align)\n{\n\tstruct pci_dev_resource *tmp;\n\n\ttmp = kzalloc(sizeof(*tmp), GFP_KERNEL);\n\tif (!tmp)\n\t\treturn -ENOMEM;\n\n\ttmp->res = res;\n\ttmp->dev = dev;\n\ttmp->start = res->start;\n\ttmp->end = res->end;\n\ttmp->flags = res->flags;\n\ttmp->add_size = add_size;\n\ttmp->min_align = min_align;\n\n\tlist_add(&tmp->list, head);\n\n\treturn 0;\n}\n\nstatic void remove_from_list(struct list_head *head, struct resource *res)\n{\n\tstruct pci_dev_resource *dev_res, *tmp;\n\n\tlist_for_each_entry_safe(dev_res, tmp, head, list) {\n\t\tif (dev_res->res == res) {\n\t\t\tlist_del(&dev_res->list);\n\t\t\tkfree(dev_res);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic struct pci_dev_resource *res_to_dev_res(struct list_head *head,\n\t\t\t\t\t       struct resource *res)\n{\n\tstruct pci_dev_resource *dev_res;\n\n\tlist_for_each_entry(dev_res, head, list) {\n\t\tif (dev_res->res == res)\n\t\t\treturn dev_res;\n\t}\n\n\treturn NULL;\n}\n\nstatic resource_size_t get_res_add_size(struct list_head *head,\n\t\t\t\t\tstruct resource *res)\n{\n\tstruct pci_dev_resource *dev_res;\n\n\tdev_res = res_to_dev_res(head, res);\n\treturn dev_res ? dev_res->add_size : 0;\n}\n\nstatic resource_size_t get_res_add_align(struct list_head *head,\n\t\t\t\t\t struct resource *res)\n{\n\tstruct pci_dev_resource *dev_res;\n\n\tdev_res = res_to_dev_res(head, res);\n\treturn dev_res ? dev_res->min_align : 0;\n}\n\n \nstatic void pdev_sort_resources(struct pci_dev *dev, struct list_head *head)\n{\n\tstruct resource *r;\n\tint i;\n\n\tpci_dev_for_each_resource(dev, r, i) {\n\t\tstruct pci_dev_resource *dev_res, *tmp;\n\t\tresource_size_t r_align;\n\t\tstruct list_head *n;\n\n\t\tif (r->flags & IORESOURCE_PCI_FIXED)\n\t\t\tcontinue;\n\n\t\tif (!(r->flags) || r->parent)\n\t\t\tcontinue;\n\n\t\tr_align = pci_resource_alignment(dev, r);\n\t\tif (!r_align) {\n\t\t\tpci_warn(dev, \"BAR %d: %pR has bogus alignment\\n\",\n\t\t\t\t i, r);\n\t\t\tcontinue;\n\t\t}\n\n\t\ttmp = kzalloc(sizeof(*tmp), GFP_KERNEL);\n\t\tif (!tmp)\n\t\t\tpanic(\"%s: kzalloc() failed!\\n\", __func__);\n\t\ttmp->res = r;\n\t\ttmp->dev = dev;\n\n\t\t \n\t\tn = head;\n\t\tlist_for_each_entry(dev_res, head, list) {\n\t\t\tresource_size_t align;\n\n\t\t\talign = pci_resource_alignment(dev_res->dev,\n\t\t\t\t\t\t\t dev_res->res);\n\n\t\t\tif (r_align > align) {\n\t\t\t\tn = &dev_res->list;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t \n\t\tlist_add_tail(&tmp->list, n);\n\t}\n}\n\nstatic void __dev_sort_resources(struct pci_dev *dev, struct list_head *head)\n{\n\tu16 class = dev->class >> 8;\n\n\t \n\tif (class == PCI_CLASS_NOT_DEFINED || class == PCI_CLASS_BRIDGE_HOST)\n\t\treturn;\n\n\t \n\tif (class == PCI_CLASS_SYSTEM_PIC) {\n\t\tu16 command;\n\t\tpci_read_config_word(dev, PCI_COMMAND, &command);\n\t\tif (command & (PCI_COMMAND_IO | PCI_COMMAND_MEMORY))\n\t\t\treturn;\n\t}\n\n\tpdev_sort_resources(dev, head);\n}\n\nstatic inline void reset_resource(struct resource *res)\n{\n\tres->start = 0;\n\tres->end = 0;\n\tres->flags = 0;\n}\n\n \nstatic void reassign_resources_sorted(struct list_head *realloc_head,\n\t\t\t\t      struct list_head *head)\n{\n\tstruct resource *res;\n\tstruct pci_dev_resource *add_res, *tmp;\n\tstruct pci_dev_resource *dev_res;\n\tresource_size_t add_size, align;\n\tint idx;\n\n\tlist_for_each_entry_safe(add_res, tmp, realloc_head, list) {\n\t\tbool found_match = false;\n\n\t\tres = add_res->res;\n\t\t \n\t\tif (!res->flags)\n\t\t\tgoto out;\n\n\t\t \n\t\tlist_for_each_entry(dev_res, head, list) {\n\t\t\tif (dev_res->res == res) {\n\t\t\t\tfound_match = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!found_match)  \n\t\t\tcontinue;\n\n\t\tidx = res - &add_res->dev->resource[0];\n\t\tadd_size = add_res->add_size;\n\t\talign = add_res->min_align;\n\t\tif (!resource_size(res)) {\n\t\t\tres->start = align;\n\t\t\tres->end = res->start + add_size - 1;\n\t\t\tif (pci_assign_resource(add_res->dev, idx))\n\t\t\t\treset_resource(res);\n\t\t} else {\n\t\t\tres->flags |= add_res->flags &\n\t\t\t\t (IORESOURCE_STARTALIGN|IORESOURCE_SIZEALIGN);\n\t\t\tif (pci_reassign_resource(add_res->dev, idx,\n\t\t\t\t\t\t  add_size, align))\n\t\t\t\tpci_info(add_res->dev, \"failed to add %llx res[%d]=%pR\\n\",\n\t\t\t\t\t (unsigned long long) add_size, idx,\n\t\t\t\t\t res);\n\t\t}\nout:\n\t\tlist_del(&add_res->list);\n\t\tkfree(add_res);\n\t}\n}\n\n \nstatic void assign_requested_resources_sorted(struct list_head *head,\n\t\t\t\t struct list_head *fail_head)\n{\n\tstruct resource *res;\n\tstruct pci_dev_resource *dev_res;\n\tint idx;\n\n\tlist_for_each_entry(dev_res, head, list) {\n\t\tres = dev_res->res;\n\t\tidx = res - &dev_res->dev->resource[0];\n\t\tif (resource_size(res) &&\n\t\t    pci_assign_resource(dev_res->dev, idx)) {\n\t\t\tif (fail_head) {\n\t\t\t\t \n\t\t\t\tif (!((idx == PCI_ROM_RESOURCE) &&\n\t\t\t\t      (!(res->flags & IORESOURCE_ROM_ENABLE))))\n\t\t\t\t\tadd_to_list(fail_head,\n\t\t\t\t\t\t    dev_res->dev, res,\n\t\t\t\t\t\t    0  ,\n\t\t\t\t\t\t    0  );\n\t\t\t}\n\t\t\treset_resource(res);\n\t\t}\n\t}\n}\n\nstatic unsigned long pci_fail_res_type_mask(struct list_head *fail_head)\n{\n\tstruct pci_dev_resource *fail_res;\n\tunsigned long mask = 0;\n\n\t \n\tlist_for_each_entry(fail_res, fail_head, list)\n\t\tmask |= fail_res->flags;\n\n\t \n\treturn mask & (IORESOURCE_IO | IORESOURCE_MEM | IORESOURCE_PREFETCH);\n}\n\nstatic bool pci_need_to_release(unsigned long mask, struct resource *res)\n{\n\tif (res->flags & IORESOURCE_IO)\n\t\treturn !!(mask & IORESOURCE_IO);\n\n\t \n\tif (res->flags & IORESOURCE_PREFETCH) {\n\t\tif (mask & IORESOURCE_PREFETCH)\n\t\t\treturn true;\n\t\t \n\t\telse if ((mask & IORESOURCE_MEM) &&\n\t\t\t !(res->parent->flags & IORESOURCE_PREFETCH))\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\n\tif (res->flags & IORESOURCE_MEM)\n\t\treturn !!(mask & IORESOURCE_MEM);\n\n\treturn false;\t \n}\n\nstatic void __assign_resources_sorted(struct list_head *head,\n\t\t\t\t      struct list_head *realloc_head,\n\t\t\t\t      struct list_head *fail_head)\n{\n\t \n\tLIST_HEAD(save_head);\n\tLIST_HEAD(local_fail_head);\n\tstruct pci_dev_resource *save_res;\n\tstruct pci_dev_resource *dev_res, *tmp_res, *dev_res2;\n\tunsigned long fail_type;\n\tresource_size_t add_align, align;\n\n\t \n\tif (!realloc_head || list_empty(realloc_head))\n\t\tgoto requested_and_reassign;\n\n\t \n\tlist_for_each_entry(dev_res, head, list) {\n\t\tif (add_to_list(&save_head, dev_res->dev, dev_res->res, 0, 0)) {\n\t\t\tfree_list(&save_head);\n\t\t\tgoto requested_and_reassign;\n\t\t}\n\t}\n\n\t \n\tlist_for_each_entry_safe(dev_res, tmp_res, head, list) {\n\t\tdev_res->res->end += get_res_add_size(realloc_head,\n\t\t\t\t\t\t\tdev_res->res);\n\n\t\t \n\t\tif (!(dev_res->res->flags & IORESOURCE_STARTALIGN))\n\t\t\tcontinue;\n\n\t\tadd_align = get_res_add_align(realloc_head, dev_res->res);\n\n\t\t \n\t\tif (add_align > dev_res->res->start) {\n\t\t\tresource_size_t r_size = resource_size(dev_res->res);\n\n\t\t\tdev_res->res->start = add_align;\n\t\t\tdev_res->res->end = add_align + r_size - 1;\n\n\t\t\tlist_for_each_entry(dev_res2, head, list) {\n\t\t\t\talign = pci_resource_alignment(dev_res2->dev,\n\t\t\t\t\t\t\t       dev_res2->res);\n\t\t\t\tif (add_align > align) {\n\t\t\t\t\tlist_move_tail(&dev_res->list,\n\t\t\t\t\t\t       &dev_res2->list);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\t \n\tassign_requested_resources_sorted(head, &local_fail_head);\n\n\t \n\tif (list_empty(&local_fail_head)) {\n\t\t \n\t\tlist_for_each_entry(dev_res, head, list)\n\t\t\tremove_from_list(realloc_head, dev_res->res);\n\t\tfree_list(&save_head);\n\t\tfree_list(head);\n\t\treturn;\n\t}\n\n\t \n\tfail_type = pci_fail_res_type_mask(&local_fail_head);\n\t \n\tlist_for_each_entry_safe(dev_res, tmp_res, head, list)\n\t\tif (dev_res->res->parent &&\n\t\t    !pci_need_to_release(fail_type, dev_res->res)) {\n\t\t\t \n\t\t\tremove_from_list(realloc_head, dev_res->res);\n\t\t\tremove_from_list(&save_head, dev_res->res);\n\t\t\tlist_del(&dev_res->list);\n\t\t\tkfree(dev_res);\n\t\t}\n\n\tfree_list(&local_fail_head);\n\t \n\tlist_for_each_entry(dev_res, head, list)\n\t\tif (dev_res->res->parent)\n\t\t\trelease_resource(dev_res->res);\n\t \n\tlist_for_each_entry(save_res, &save_head, list) {\n\t\tstruct resource *res = save_res->res;\n\n\t\tres->start = save_res->start;\n\t\tres->end = save_res->end;\n\t\tres->flags = save_res->flags;\n\t}\n\tfree_list(&save_head);\n\nrequested_and_reassign:\n\t \n\tassign_requested_resources_sorted(head, fail_head);\n\n\t \n\tif (realloc_head)\n\t\treassign_resources_sorted(realloc_head, head);\n\tfree_list(head);\n}\n\nstatic void pdev_assign_resources_sorted(struct pci_dev *dev,\n\t\t\t\t\t struct list_head *add_head,\n\t\t\t\t\t struct list_head *fail_head)\n{\n\tLIST_HEAD(head);\n\n\t__dev_sort_resources(dev, &head);\n\t__assign_resources_sorted(&head, add_head, fail_head);\n\n}\n\nstatic void pbus_assign_resources_sorted(const struct pci_bus *bus,\n\t\t\t\t\t struct list_head *realloc_head,\n\t\t\t\t\t struct list_head *fail_head)\n{\n\tstruct pci_dev *dev;\n\tLIST_HEAD(head);\n\n\tlist_for_each_entry(dev, &bus->devices, bus_list)\n\t\t__dev_sort_resources(dev, &head);\n\n\t__assign_resources_sorted(&head, realloc_head, fail_head);\n}\n\nvoid pci_setup_cardbus(struct pci_bus *bus)\n{\n\tstruct pci_dev *bridge = bus->self;\n\tstruct resource *res;\n\tstruct pci_bus_region region;\n\n\tpci_info(bridge, \"CardBus bridge to %pR\\n\",\n\t\t &bus->busn_res);\n\n\tres = bus->resource[0];\n\tpcibios_resource_to_bus(bridge->bus, &region, res);\n\tif (res->flags & IORESOURCE_IO) {\n\t\t \n\t\tpci_info(bridge, \"  bridge window %pR\\n\", res);\n\t\tpci_write_config_dword(bridge, PCI_CB_IO_BASE_0,\n\t\t\t\t\tregion.start);\n\t\tpci_write_config_dword(bridge, PCI_CB_IO_LIMIT_0,\n\t\t\t\t\tregion.end);\n\t}\n\n\tres = bus->resource[1];\n\tpcibios_resource_to_bus(bridge->bus, &region, res);\n\tif (res->flags & IORESOURCE_IO) {\n\t\tpci_info(bridge, \"  bridge window %pR\\n\", res);\n\t\tpci_write_config_dword(bridge, PCI_CB_IO_BASE_1,\n\t\t\t\t\tregion.start);\n\t\tpci_write_config_dword(bridge, PCI_CB_IO_LIMIT_1,\n\t\t\t\t\tregion.end);\n\t}\n\n\tres = bus->resource[2];\n\tpcibios_resource_to_bus(bridge->bus, &region, res);\n\tif (res->flags & IORESOURCE_MEM) {\n\t\tpci_info(bridge, \"  bridge window %pR\\n\", res);\n\t\tpci_write_config_dword(bridge, PCI_CB_MEMORY_BASE_0,\n\t\t\t\t\tregion.start);\n\t\tpci_write_config_dword(bridge, PCI_CB_MEMORY_LIMIT_0,\n\t\t\t\t\tregion.end);\n\t}\n\n\tres = bus->resource[3];\n\tpcibios_resource_to_bus(bridge->bus, &region, res);\n\tif (res->flags & IORESOURCE_MEM) {\n\t\tpci_info(bridge, \"  bridge window %pR\\n\", res);\n\t\tpci_write_config_dword(bridge, PCI_CB_MEMORY_BASE_1,\n\t\t\t\t\tregion.start);\n\t\tpci_write_config_dword(bridge, PCI_CB_MEMORY_LIMIT_1,\n\t\t\t\t\tregion.end);\n\t}\n}\nEXPORT_SYMBOL(pci_setup_cardbus);\n\n \nstatic void pci_setup_bridge_io(struct pci_dev *bridge)\n{\n\tstruct resource *res;\n\tstruct pci_bus_region region;\n\tunsigned long io_mask;\n\tu8 io_base_lo, io_limit_lo;\n\tu16 l;\n\tu32 io_upper16;\n\n\tio_mask = PCI_IO_RANGE_MASK;\n\tif (bridge->io_window_1k)\n\t\tio_mask = PCI_IO_1K_RANGE_MASK;\n\n\t \n\tres = &bridge->resource[PCI_BRIDGE_IO_WINDOW];\n\tpcibios_resource_to_bus(bridge->bus, &region, res);\n\tif (res->flags & IORESOURCE_IO) {\n\t\tpci_read_config_word(bridge, PCI_IO_BASE, &l);\n\t\tio_base_lo = (region.start >> 8) & io_mask;\n\t\tio_limit_lo = (region.end >> 8) & io_mask;\n\t\tl = ((u16) io_limit_lo << 8) | io_base_lo;\n\t\t \n\t\tio_upper16 = (region.end & 0xffff0000) | (region.start >> 16);\n\t\tpci_info(bridge, \"  bridge window %pR\\n\", res);\n\t} else {\n\t\t \n\t\tio_upper16 = 0;\n\t\tl = 0x00f0;\n\t}\n\t \n\tpci_write_config_dword(bridge, PCI_IO_BASE_UPPER16, 0x0000ffff);\n\t \n\tpci_write_config_word(bridge, PCI_IO_BASE, l);\n\t \n\tpci_write_config_dword(bridge, PCI_IO_BASE_UPPER16, io_upper16);\n}\n\nstatic void pci_setup_bridge_mmio(struct pci_dev *bridge)\n{\n\tstruct resource *res;\n\tstruct pci_bus_region region;\n\tu32 l;\n\n\t \n\tres = &bridge->resource[PCI_BRIDGE_MEM_WINDOW];\n\tpcibios_resource_to_bus(bridge->bus, &region, res);\n\tif (res->flags & IORESOURCE_MEM) {\n\t\tl = (region.start >> 16) & 0xfff0;\n\t\tl |= region.end & 0xfff00000;\n\t\tpci_info(bridge, \"  bridge window %pR\\n\", res);\n\t} else {\n\t\tl = 0x0000fff0;\n\t}\n\tpci_write_config_dword(bridge, PCI_MEMORY_BASE, l);\n}\n\nstatic void pci_setup_bridge_mmio_pref(struct pci_dev *bridge)\n{\n\tstruct resource *res;\n\tstruct pci_bus_region region;\n\tu32 l, bu, lu;\n\n\t \n\tpci_write_config_dword(bridge, PCI_PREF_LIMIT_UPPER32, 0);\n\n\t \n\tbu = lu = 0;\n\tres = &bridge->resource[PCI_BRIDGE_PREF_MEM_WINDOW];\n\tpcibios_resource_to_bus(bridge->bus, &region, res);\n\tif (res->flags & IORESOURCE_PREFETCH) {\n\t\tl = (region.start >> 16) & 0xfff0;\n\t\tl |= region.end & 0xfff00000;\n\t\tif (res->flags & IORESOURCE_MEM_64) {\n\t\t\tbu = upper_32_bits(region.start);\n\t\t\tlu = upper_32_bits(region.end);\n\t\t}\n\t\tpci_info(bridge, \"  bridge window %pR\\n\", res);\n\t} else {\n\t\tl = 0x0000fff0;\n\t}\n\tpci_write_config_dword(bridge, PCI_PREF_MEMORY_BASE, l);\n\n\t \n\tpci_write_config_dword(bridge, PCI_PREF_BASE_UPPER32, bu);\n\tpci_write_config_dword(bridge, PCI_PREF_LIMIT_UPPER32, lu);\n}\n\nstatic void __pci_setup_bridge(struct pci_bus *bus, unsigned long type)\n{\n\tstruct pci_dev *bridge = bus->self;\n\n\tpci_info(bridge, \"PCI bridge to %pR\\n\",\n\t\t &bus->busn_res);\n\n\tif (type & IORESOURCE_IO)\n\t\tpci_setup_bridge_io(bridge);\n\n\tif (type & IORESOURCE_MEM)\n\t\tpci_setup_bridge_mmio(bridge);\n\n\tif (type & IORESOURCE_PREFETCH)\n\t\tpci_setup_bridge_mmio_pref(bridge);\n\n\tpci_write_config_word(bridge, PCI_BRIDGE_CONTROL, bus->bridge_ctl);\n}\n\nvoid __weak pcibios_setup_bridge(struct pci_bus *bus, unsigned long type)\n{\n}\n\nvoid pci_setup_bridge(struct pci_bus *bus)\n{\n\tunsigned long type = IORESOURCE_IO | IORESOURCE_MEM |\n\t\t\t\t  IORESOURCE_PREFETCH;\n\n\tpcibios_setup_bridge(bus, type);\n\t__pci_setup_bridge(bus, type);\n}\n\n\nint pci_claim_bridge_resource(struct pci_dev *bridge, int i)\n{\n\tif (i < PCI_BRIDGE_RESOURCES || i > PCI_BRIDGE_RESOURCE_END)\n\t\treturn 0;\n\n\tif (pci_claim_resource(bridge, i) == 0)\n\t\treturn 0;\t \n\n\tif ((bridge->class >> 8) != PCI_CLASS_BRIDGE_PCI)\n\t\treturn 0;\n\n\tif (!pci_bus_clip_resource(bridge, i))\n\t\treturn -EINVAL;\t \n\n\tswitch (i) {\n\tcase PCI_BRIDGE_IO_WINDOW:\n\t\tpci_setup_bridge_io(bridge);\n\t\tbreak;\n\tcase PCI_BRIDGE_MEM_WINDOW:\n\t\tpci_setup_bridge_mmio(bridge);\n\t\tbreak;\n\tcase PCI_BRIDGE_PREF_MEM_WINDOW:\n\t\tpci_setup_bridge_mmio_pref(bridge);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (pci_claim_resource(bridge, i) == 0)\n\t\treturn 0;\t \n\n\treturn -EINVAL;\n}\n\n \nstatic void pci_bridge_check_ranges(struct pci_bus *bus)\n{\n\tstruct pci_dev *bridge = bus->self;\n\tstruct resource *b_res;\n\n\tb_res = &bridge->resource[PCI_BRIDGE_MEM_WINDOW];\n\tb_res->flags |= IORESOURCE_MEM;\n\n\tif (bridge->io_window) {\n\t\tb_res = &bridge->resource[PCI_BRIDGE_IO_WINDOW];\n\t\tb_res->flags |= IORESOURCE_IO;\n\t}\n\n\tif (bridge->pref_window) {\n\t\tb_res = &bridge->resource[PCI_BRIDGE_PREF_MEM_WINDOW];\n\t\tb_res->flags |= IORESOURCE_MEM | IORESOURCE_PREFETCH;\n\t\tif (bridge->pref_64_window) {\n\t\t\tb_res->flags |= IORESOURCE_MEM_64 |\n\t\t\t\t\tPCI_PREF_RANGE_TYPE_64;\n\t\t}\n\t}\n}\n\n \nstatic struct resource *find_bus_resource_of_type(struct pci_bus *bus,\n\t\t\t\t\t\t  unsigned long type_mask,\n\t\t\t\t\t\t  unsigned long type)\n{\n\tstruct resource *r, *r_assigned = NULL;\n\n\tpci_bus_for_each_resource(bus, r) {\n\t\tif (r == &ioport_resource || r == &iomem_resource)\n\t\t\tcontinue;\n\t\tif (r && (r->flags & type_mask) == type && !r->parent)\n\t\t\treturn r;\n\t\tif (r && (r->flags & type_mask) == type && !r_assigned)\n\t\t\tr_assigned = r;\n\t}\n\treturn r_assigned;\n}\n\nstatic resource_size_t calculate_iosize(resource_size_t size,\n\t\t\t\t\tresource_size_t min_size,\n\t\t\t\t\tresource_size_t size1,\n\t\t\t\t\tresource_size_t add_size,\n\t\t\t\t\tresource_size_t children_add_size,\n\t\t\t\t\tresource_size_t old_size,\n\t\t\t\t\tresource_size_t align)\n{\n\tif (size < min_size)\n\t\tsize = min_size;\n\tif (old_size == 1)\n\t\told_size = 0;\n\t \n#if defined(CONFIG_ISA) || defined(CONFIG_EISA)\n\tsize = (size & 0xff) + ((size & ~0xffUL) << 2);\n#endif\n\tsize = size + size1;\n\tif (size < old_size)\n\t\tsize = old_size;\n\n\tsize = ALIGN(max(size, add_size) + children_add_size, align);\n\treturn size;\n}\n\nstatic resource_size_t calculate_memsize(resource_size_t size,\n\t\t\t\t\t resource_size_t min_size,\n\t\t\t\t\t resource_size_t add_size,\n\t\t\t\t\t resource_size_t children_add_size,\n\t\t\t\t\t resource_size_t old_size,\n\t\t\t\t\t resource_size_t align)\n{\n\tif (size < min_size)\n\t\tsize = min_size;\n\tif (old_size == 1)\n\t\told_size = 0;\n\tif (size < old_size)\n\t\tsize = old_size;\n\n\tsize = ALIGN(max(size, add_size) + children_add_size, align);\n\treturn size;\n}\n\nresource_size_t __weak pcibios_window_alignment(struct pci_bus *bus,\n\t\t\t\t\t\tunsigned long type)\n{\n\treturn 1;\n}\n\n#define PCI_P2P_DEFAULT_MEM_ALIGN\t0x100000\t \n#define PCI_P2P_DEFAULT_IO_ALIGN\t0x1000\t\t \n#define PCI_P2P_DEFAULT_IO_ALIGN_1K\t0x400\t\t \n\nstatic resource_size_t window_alignment(struct pci_bus *bus, unsigned long type)\n{\n\tresource_size_t align = 1, arch_align;\n\n\tif (type & IORESOURCE_MEM)\n\t\talign = PCI_P2P_DEFAULT_MEM_ALIGN;\n\telse if (type & IORESOURCE_IO) {\n\t\t \n\t\tif (bus->self && bus->self->io_window_1k)\n\t\t\talign = PCI_P2P_DEFAULT_IO_ALIGN_1K;\n\t\telse\n\t\t\talign = PCI_P2P_DEFAULT_IO_ALIGN;\n\t}\n\n\tarch_align = pcibios_window_alignment(bus, type);\n\treturn max(align, arch_align);\n}\n\n \nstatic void pbus_size_io(struct pci_bus *bus, resource_size_t min_size,\n\t\t\t resource_size_t add_size,\n\t\t\t struct list_head *realloc_head)\n{\n\tstruct pci_dev *dev;\n\tstruct resource *b_res = find_bus_resource_of_type(bus, IORESOURCE_IO,\n\t\t\t\t\t\t\t   IORESOURCE_IO);\n\tresource_size_t size = 0, size0 = 0, size1 = 0;\n\tresource_size_t children_add_size = 0;\n\tresource_size_t min_align, align;\n\n\tif (!b_res)\n\t\treturn;\n\n\t \n\tif (b_res->parent)\n\t\treturn;\n\n\tmin_align = window_alignment(bus, IORESOURCE_IO);\n\tlist_for_each_entry(dev, &bus->devices, bus_list) {\n\t\tstruct resource *r;\n\n\t\tpci_dev_for_each_resource(dev, r) {\n\t\t\tunsigned long r_size;\n\n\t\t\tif (r->parent || !(r->flags & IORESOURCE_IO))\n\t\t\t\tcontinue;\n\t\t\tr_size = resource_size(r);\n\n\t\t\tif (r_size < 0x400)\n\t\t\t\t \n\t\t\t\tsize += r_size;\n\t\t\telse\n\t\t\t\tsize1 += r_size;\n\n\t\t\talign = pci_resource_alignment(dev, r);\n\t\t\tif (align > min_align)\n\t\t\t\tmin_align = align;\n\n\t\t\tif (realloc_head)\n\t\t\t\tchildren_add_size += get_res_add_size(realloc_head, r);\n\t\t}\n\t}\n\n\tsize0 = calculate_iosize(size, min_size, size1, 0, 0,\n\t\t\tresource_size(b_res), min_align);\n\tsize1 = (!realloc_head || (realloc_head && !add_size && !children_add_size)) ? size0 :\n\t\tcalculate_iosize(size, min_size, size1, add_size, children_add_size,\n\t\t\tresource_size(b_res), min_align);\n\tif (!size0 && !size1) {\n\t\tif (bus->self && (b_res->start || b_res->end))\n\t\t\tpci_info(bus->self, \"disabling bridge window %pR to %pR (unused)\\n\",\n\t\t\t\t b_res, &bus->busn_res);\n\t\tb_res->flags = 0;\n\t\treturn;\n\t}\n\n\tb_res->start = min_align;\n\tb_res->end = b_res->start + size0 - 1;\n\tb_res->flags |= IORESOURCE_STARTALIGN;\n\tif (bus->self && size1 > size0 && realloc_head) {\n\t\tadd_to_list(realloc_head, bus->self, b_res, size1-size0,\n\t\t\t    min_align);\n\t\tpci_info(bus->self, \"bridge window %pR to %pR add_size %llx\\n\",\n\t\t\t b_res, &bus->busn_res,\n\t\t\t (unsigned long long) size1 - size0);\n\t}\n}\n\nstatic inline resource_size_t calculate_mem_align(resource_size_t *aligns,\n\t\t\t\t\t\t  int max_order)\n{\n\tresource_size_t align = 0;\n\tresource_size_t min_align = 0;\n\tint order;\n\n\tfor (order = 0; order <= max_order; order++) {\n\t\tresource_size_t align1 = 1;\n\n\t\talign1 <<= (order + 20);\n\n\t\tif (!align)\n\t\t\tmin_align = align1;\n\t\telse if (ALIGN(align + min_align, min_align) < align1)\n\t\t\tmin_align = align1 >> 1;\n\t\talign += aligns[order];\n\t}\n\n\treturn min_align;\n}\n\n \nstatic int pbus_size_mem(struct pci_bus *bus, unsigned long mask,\n\t\t\t unsigned long type, unsigned long type2,\n\t\t\t unsigned long type3, resource_size_t min_size,\n\t\t\t resource_size_t add_size,\n\t\t\t struct list_head *realloc_head)\n{\n\tstruct pci_dev *dev;\n\tresource_size_t min_align, align, size, size0, size1;\n\tresource_size_t aligns[24];  \n\tint order, max_order;\n\tstruct resource *b_res = find_bus_resource_of_type(bus,\n\t\t\t\t\tmask | IORESOURCE_PREFETCH, type);\n\tresource_size_t children_add_size = 0;\n\tresource_size_t children_add_align = 0;\n\tresource_size_t add_align = 0;\n\n\tif (!b_res)\n\t\treturn -ENOSPC;\n\n\t \n\tif (b_res->parent)\n\t\treturn 0;\n\n\tmemset(aligns, 0, sizeof(aligns));\n\tmax_order = 0;\n\tsize = 0;\n\n\tlist_for_each_entry(dev, &bus->devices, bus_list) {\n\t\tstruct resource *r;\n\t\tint i;\n\n\t\tpci_dev_for_each_resource(dev, r, i) {\n\t\t\tresource_size_t r_size;\n\n\t\t\tif (r->parent || (r->flags & IORESOURCE_PCI_FIXED) ||\n\t\t\t    ((r->flags & mask) != type &&\n\t\t\t     (r->flags & mask) != type2 &&\n\t\t\t     (r->flags & mask) != type3))\n\t\t\t\tcontinue;\n\t\t\tr_size = resource_size(r);\n#ifdef CONFIG_PCI_IOV\n\t\t\t \n\t\t\tif (realloc_head && i >= PCI_IOV_RESOURCES &&\n\t\t\t\t\ti <= PCI_IOV_RESOURCE_END) {\n\t\t\t\tadd_align = max(pci_resource_alignment(dev, r), add_align);\n\t\t\t\tr->end = r->start - 1;\n\t\t\t\tadd_to_list(realloc_head, dev, r, r_size, 0  );\n\t\t\t\tchildren_add_size += r_size;\n\t\t\t\tcontinue;\n\t\t\t}\n#endif\n\t\t\t \n\t\t\talign = pci_resource_alignment(dev, r);\n\t\t\torder = __ffs(align) - 20;\n\t\t\tif (order < 0)\n\t\t\t\torder = 0;\n\t\t\tif (order >= ARRAY_SIZE(aligns)) {\n\t\t\t\tpci_warn(dev, \"disabling BAR %d: %pR (bad alignment %#llx)\\n\",\n\t\t\t\t\t i, r, (unsigned long long) align);\n\t\t\t\tr->flags = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsize += max(r_size, align);\n\t\t\t \n\t\t\tif (r_size <= align)\n\t\t\t\taligns[order] += align;\n\t\t\tif (order > max_order)\n\t\t\t\tmax_order = order;\n\n\t\t\tif (realloc_head) {\n\t\t\t\tchildren_add_size += get_res_add_size(realloc_head, r);\n\t\t\t\tchildren_add_align = get_res_add_align(realloc_head, r);\n\t\t\t\tadd_align = max(add_align, children_add_align);\n\t\t\t}\n\t\t}\n\t}\n\n\tmin_align = calculate_mem_align(aligns, max_order);\n\tmin_align = max(min_align, window_alignment(bus, b_res->flags));\n\tsize0 = calculate_memsize(size, min_size, 0, 0, resource_size(b_res), min_align);\n\tadd_align = max(min_align, add_align);\n\tsize1 = (!realloc_head || (realloc_head && !add_size && !children_add_size)) ? size0 :\n\t\tcalculate_memsize(size, min_size, add_size, children_add_size,\n\t\t\t\tresource_size(b_res), add_align);\n\tif (!size0 && !size1) {\n\t\tif (bus->self && (b_res->start || b_res->end))\n\t\t\tpci_info(bus->self, \"disabling bridge window %pR to %pR (unused)\\n\",\n\t\t\t\t b_res, &bus->busn_res);\n\t\tb_res->flags = 0;\n\t\treturn 0;\n\t}\n\tb_res->start = min_align;\n\tb_res->end = size0 + min_align - 1;\n\tb_res->flags |= IORESOURCE_STARTALIGN;\n\tif (bus->self && size1 > size0 && realloc_head) {\n\t\tadd_to_list(realloc_head, bus->self, b_res, size1-size0, add_align);\n\t\tpci_info(bus->self, \"bridge window %pR to %pR add_size %llx add_align %llx\\n\",\n\t\t\t   b_res, &bus->busn_res,\n\t\t\t   (unsigned long long) (size1 - size0),\n\t\t\t   (unsigned long long) add_align);\n\t}\n\treturn 0;\n}\n\nunsigned long pci_cardbus_resource_alignment(struct resource *res)\n{\n\tif (res->flags & IORESOURCE_IO)\n\t\treturn pci_cardbus_io_size;\n\tif (res->flags & IORESOURCE_MEM)\n\t\treturn pci_cardbus_mem_size;\n\treturn 0;\n}\n\nstatic void pci_bus_size_cardbus(struct pci_bus *bus,\n\t\t\t\t struct list_head *realloc_head)\n{\n\tstruct pci_dev *bridge = bus->self;\n\tstruct resource *b_res;\n\tresource_size_t b_res_3_size = pci_cardbus_mem_size * 2;\n\tu16 ctrl;\n\n\tb_res = &bridge->resource[PCI_CB_BRIDGE_IO_0_WINDOW];\n\tif (b_res->parent)\n\t\tgoto handle_b_res_1;\n\t \n\tb_res->start = pci_cardbus_io_size;\n\tb_res->end = b_res->start + pci_cardbus_io_size - 1;\n\tb_res->flags |= IORESOURCE_IO | IORESOURCE_STARTALIGN;\n\tif (realloc_head) {\n\t\tb_res->end -= pci_cardbus_io_size;\n\t\tadd_to_list(realloc_head, bridge, b_res, pci_cardbus_io_size,\n\t\t\t    pci_cardbus_io_size);\n\t}\n\nhandle_b_res_1:\n\tb_res = &bridge->resource[PCI_CB_BRIDGE_IO_1_WINDOW];\n\tif (b_res->parent)\n\t\tgoto handle_b_res_2;\n\tb_res->start = pci_cardbus_io_size;\n\tb_res->end = b_res->start + pci_cardbus_io_size - 1;\n\tb_res->flags |= IORESOURCE_IO | IORESOURCE_STARTALIGN;\n\tif (realloc_head) {\n\t\tb_res->end -= pci_cardbus_io_size;\n\t\tadd_to_list(realloc_head, bridge, b_res, pci_cardbus_io_size,\n\t\t\t    pci_cardbus_io_size);\n\t}\n\nhandle_b_res_2:\n\t \n\tpci_read_config_word(bridge, PCI_CB_BRIDGE_CONTROL, &ctrl);\n\tif (ctrl & PCI_CB_BRIDGE_CTL_PREFETCH_MEM1) {\n\t\tctrl &= ~PCI_CB_BRIDGE_CTL_PREFETCH_MEM1;\n\t\tpci_write_config_word(bridge, PCI_CB_BRIDGE_CONTROL, ctrl);\n\t\tpci_read_config_word(bridge, PCI_CB_BRIDGE_CONTROL, &ctrl);\n\t}\n\n\t \n\tpci_read_config_word(bridge, PCI_CB_BRIDGE_CONTROL, &ctrl);\n\tif (!(ctrl & PCI_CB_BRIDGE_CTL_PREFETCH_MEM0)) {\n\t\tctrl |= PCI_CB_BRIDGE_CTL_PREFETCH_MEM0;\n\t\tpci_write_config_word(bridge, PCI_CB_BRIDGE_CONTROL, ctrl);\n\t\tpci_read_config_word(bridge, PCI_CB_BRIDGE_CONTROL, &ctrl);\n\t}\n\n\tb_res = &bridge->resource[PCI_CB_BRIDGE_MEM_0_WINDOW];\n\tif (b_res->parent)\n\t\tgoto handle_b_res_3;\n\t \n\tif (ctrl & PCI_CB_BRIDGE_CTL_PREFETCH_MEM0) {\n\t\tb_res->start = pci_cardbus_mem_size;\n\t\tb_res->end = b_res->start + pci_cardbus_mem_size - 1;\n\t\tb_res->flags |= IORESOURCE_MEM | IORESOURCE_PREFETCH |\n\t\t\t\t    IORESOURCE_STARTALIGN;\n\t\tif (realloc_head) {\n\t\t\tb_res->end -= pci_cardbus_mem_size;\n\t\t\tadd_to_list(realloc_head, bridge, b_res,\n\t\t\t\t    pci_cardbus_mem_size, pci_cardbus_mem_size);\n\t\t}\n\n\t\t \n\t\tb_res_3_size = pci_cardbus_mem_size;\n\t}\n\nhandle_b_res_3:\n\tb_res = &bridge->resource[PCI_CB_BRIDGE_MEM_1_WINDOW];\n\tif (b_res->parent)\n\t\tgoto handle_done;\n\tb_res->start = pci_cardbus_mem_size;\n\tb_res->end = b_res->start + b_res_3_size - 1;\n\tb_res->flags |= IORESOURCE_MEM | IORESOURCE_STARTALIGN;\n\tif (realloc_head) {\n\t\tb_res->end -= b_res_3_size;\n\t\tadd_to_list(realloc_head, bridge, b_res, b_res_3_size,\n\t\t\t    pci_cardbus_mem_size);\n\t}\n\nhandle_done:\n\t;\n}\n\nvoid __pci_bus_size_bridges(struct pci_bus *bus, struct list_head *realloc_head)\n{\n\tstruct pci_dev *dev;\n\tunsigned long mask, prefmask, type2 = 0, type3 = 0;\n\tresource_size_t additional_io_size = 0, additional_mmio_size = 0,\n\t\t\tadditional_mmio_pref_size = 0;\n\tstruct resource *pref;\n\tstruct pci_host_bridge *host;\n\tint hdr_type, ret;\n\n\tlist_for_each_entry(dev, &bus->devices, bus_list) {\n\t\tstruct pci_bus *b = dev->subordinate;\n\t\tif (!b)\n\t\t\tcontinue;\n\n\t\tswitch (dev->hdr_type) {\n\t\tcase PCI_HEADER_TYPE_CARDBUS:\n\t\t\tpci_bus_size_cardbus(b, realloc_head);\n\t\t\tbreak;\n\n\t\tcase PCI_HEADER_TYPE_BRIDGE:\n\t\tdefault:\n\t\t\t__pci_bus_size_bridges(b, realloc_head);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (pci_is_root_bus(bus)) {\n\t\thost = to_pci_host_bridge(bus->bridge);\n\t\tif (!host->size_windows)\n\t\t\treturn;\n\t\tpci_bus_for_each_resource(bus, pref)\n\t\t\tif (pref && (pref->flags & IORESOURCE_PREFETCH))\n\t\t\t\tbreak;\n\t\thdr_type = -1;\t \n\t} else {\n\t\tpref = &bus->self->resource[PCI_BRIDGE_PREF_MEM_WINDOW];\n\t\thdr_type = bus->self->hdr_type;\n\t}\n\n\tswitch (hdr_type) {\n\tcase PCI_HEADER_TYPE_CARDBUS:\n\t\t \n\t\tbreak;\n\n\tcase PCI_HEADER_TYPE_BRIDGE:\n\t\tpci_bridge_check_ranges(bus);\n\t\tif (bus->self->is_hotplug_bridge) {\n\t\t\tadditional_io_size  = pci_hotplug_io_size;\n\t\t\tadditional_mmio_size = pci_hotplug_mmio_size;\n\t\t\tadditional_mmio_pref_size = pci_hotplug_mmio_pref_size;\n\t\t}\n\t\tfallthrough;\n\tdefault:\n\t\tpbus_size_io(bus, realloc_head ? 0 : additional_io_size,\n\t\t\t     additional_io_size, realloc_head);\n\n\t\t \n\t\tmask = IORESOURCE_MEM;\n\t\tprefmask = IORESOURCE_MEM | IORESOURCE_PREFETCH;\n\t\tif (pref && (pref->flags & IORESOURCE_MEM_64)) {\n\t\t\tprefmask |= IORESOURCE_MEM_64;\n\t\t\tret = pbus_size_mem(bus, prefmask, prefmask,\n\t\t\t\tprefmask, prefmask,\n\t\t\t\trealloc_head ? 0 : additional_mmio_pref_size,\n\t\t\t\tadditional_mmio_pref_size, realloc_head);\n\n\t\t\t \n\t\t\tif (ret == 0) {\n\t\t\t\tmask = prefmask;\n\t\t\t\ttype2 = prefmask & ~IORESOURCE_MEM_64;\n\t\t\t\ttype3 = prefmask & ~IORESOURCE_PREFETCH;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (!type2) {\n\t\t\tprefmask &= ~IORESOURCE_MEM_64;\n\t\t\tret = pbus_size_mem(bus, prefmask, prefmask,\n\t\t\t\tprefmask, prefmask,\n\t\t\t\trealloc_head ? 0 : additional_mmio_pref_size,\n\t\t\t\tadditional_mmio_pref_size, realloc_head);\n\n\t\t\t \n\t\t\tif (ret == 0)\n\t\t\t\tmask = prefmask;\n\t\t\telse\n\t\t\t\tadditional_mmio_size += additional_mmio_pref_size;\n\n\t\t\ttype2 = type3 = IORESOURCE_MEM;\n\t\t}\n\n\t\t \n\t\tpbus_size_mem(bus, mask, IORESOURCE_MEM, type2, type3,\n\t\t\t      realloc_head ? 0 : additional_mmio_size,\n\t\t\t      additional_mmio_size, realloc_head);\n\t\tbreak;\n\t}\n}\n\nvoid pci_bus_size_bridges(struct pci_bus *bus)\n{\n\t__pci_bus_size_bridges(bus, NULL);\n}\nEXPORT_SYMBOL(pci_bus_size_bridges);\n\nstatic void assign_fixed_resource_on_bus(struct pci_bus *b, struct resource *r)\n{\n\tstruct resource *parent_r;\n\tunsigned long mask = IORESOURCE_IO | IORESOURCE_MEM |\n\t\t\t     IORESOURCE_PREFETCH;\n\n\tpci_bus_for_each_resource(b, parent_r) {\n\t\tif (!parent_r)\n\t\t\tcontinue;\n\n\t\tif ((r->flags & mask) == (parent_r->flags & mask) &&\n\t\t    resource_contains(parent_r, r))\n\t\t\trequest_resource(parent_r, r);\n\t}\n}\n\n \nstatic void pdev_assign_fixed_resources(struct pci_dev *dev)\n{\n\tstruct resource *r;\n\n\tpci_dev_for_each_resource(dev, r) {\n\t\tstruct pci_bus *b;\n\n\t\tif (r->parent || !(r->flags & IORESOURCE_PCI_FIXED) ||\n\t\t    !(r->flags & (IORESOURCE_IO | IORESOURCE_MEM)))\n\t\t\tcontinue;\n\n\t\tb = dev->bus;\n\t\twhile (b && !r->parent) {\n\t\t\tassign_fixed_resource_on_bus(b, r);\n\t\t\tb = b->parent;\n\t\t}\n\t}\n}\n\nvoid __pci_bus_assign_resources(const struct pci_bus *bus,\n\t\t\t\tstruct list_head *realloc_head,\n\t\t\t\tstruct list_head *fail_head)\n{\n\tstruct pci_bus *b;\n\tstruct pci_dev *dev;\n\n\tpbus_assign_resources_sorted(bus, realloc_head, fail_head);\n\n\tlist_for_each_entry(dev, &bus->devices, bus_list) {\n\t\tpdev_assign_fixed_resources(dev);\n\n\t\tb = dev->subordinate;\n\t\tif (!b)\n\t\t\tcontinue;\n\n\t\t__pci_bus_assign_resources(b, realloc_head, fail_head);\n\n\t\tswitch (dev->hdr_type) {\n\t\tcase PCI_HEADER_TYPE_BRIDGE:\n\t\t\tif (!pci_is_enabled(dev))\n\t\t\t\tpci_setup_bridge(b);\n\t\t\tbreak;\n\n\t\tcase PCI_HEADER_TYPE_CARDBUS:\n\t\t\tpci_setup_cardbus(b);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tpci_info(dev, \"not setting up bridge for bus %04x:%02x\\n\",\n\t\t\t\t pci_domain_nr(b), b->number);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nvoid pci_bus_assign_resources(const struct pci_bus *bus)\n{\n\t__pci_bus_assign_resources(bus, NULL, NULL);\n}\nEXPORT_SYMBOL(pci_bus_assign_resources);\n\nstatic void pci_claim_device_resources(struct pci_dev *dev)\n{\n\tint i;\n\n\tfor (i = 0; i < PCI_BRIDGE_RESOURCES; i++) {\n\t\tstruct resource *r = &dev->resource[i];\n\n\t\tif (!r->flags || r->parent)\n\t\t\tcontinue;\n\n\t\tpci_claim_resource(dev, i);\n\t}\n}\n\nstatic void pci_claim_bridge_resources(struct pci_dev *dev)\n{\n\tint i;\n\n\tfor (i = PCI_BRIDGE_RESOURCES; i < PCI_NUM_RESOURCES; i++) {\n\t\tstruct resource *r = &dev->resource[i];\n\n\t\tif (!r->flags || r->parent)\n\t\t\tcontinue;\n\n\t\tpci_claim_bridge_resource(dev, i);\n\t}\n}\n\nstatic void pci_bus_allocate_dev_resources(struct pci_bus *b)\n{\n\tstruct pci_dev *dev;\n\tstruct pci_bus *child;\n\n\tlist_for_each_entry(dev, &b->devices, bus_list) {\n\t\tpci_claim_device_resources(dev);\n\n\t\tchild = dev->subordinate;\n\t\tif (child)\n\t\t\tpci_bus_allocate_dev_resources(child);\n\t}\n}\n\nstatic void pci_bus_allocate_resources(struct pci_bus *b)\n{\n\tstruct pci_bus *child;\n\n\t \n\tif (b->self) {\n\t\tpci_read_bridge_bases(b);\n\t\tpci_claim_bridge_resources(b->self);\n\t}\n\n\tlist_for_each_entry(child, &b->children, node)\n\t\tpci_bus_allocate_resources(child);\n}\n\nvoid pci_bus_claim_resources(struct pci_bus *b)\n{\n\tpci_bus_allocate_resources(b);\n\tpci_bus_allocate_dev_resources(b);\n}\nEXPORT_SYMBOL(pci_bus_claim_resources);\n\nstatic void __pci_bridge_assign_resources(const struct pci_dev *bridge,\n\t\t\t\t\t  struct list_head *add_head,\n\t\t\t\t\t  struct list_head *fail_head)\n{\n\tstruct pci_bus *b;\n\n\tpdev_assign_resources_sorted((struct pci_dev *)bridge,\n\t\t\t\t\t add_head, fail_head);\n\n\tb = bridge->subordinate;\n\tif (!b)\n\t\treturn;\n\n\t__pci_bus_assign_resources(b, add_head, fail_head);\n\n\tswitch (bridge->class >> 8) {\n\tcase PCI_CLASS_BRIDGE_PCI:\n\t\tpci_setup_bridge(b);\n\t\tbreak;\n\n\tcase PCI_CLASS_BRIDGE_CARDBUS:\n\t\tpci_setup_cardbus(b);\n\t\tbreak;\n\n\tdefault:\n\t\tpci_info(bridge, \"not setting up bridge for bus %04x:%02x\\n\",\n\t\t\t pci_domain_nr(b), b->number);\n\t\tbreak;\n\t}\n}\n\n#define PCI_RES_TYPE_MASK \\\n\t(IORESOURCE_IO | IORESOURCE_MEM | IORESOURCE_PREFETCH |\\\n\t IORESOURCE_MEM_64)\n\nstatic void pci_bridge_release_resources(struct pci_bus *bus,\n\t\t\t\t\t unsigned long type)\n{\n\tstruct pci_dev *dev = bus->self;\n\tstruct resource *r;\n\tunsigned int old_flags;\n\tstruct resource *b_res;\n\tint idx = 1;\n\n\tb_res = &dev->resource[PCI_BRIDGE_RESOURCES];\n\n\t \n\tif (type & IORESOURCE_IO)\n\t\tidx = 0;\n\telse if (!(type & IORESOURCE_PREFETCH))\n\t\tidx = 1;\n\telse if ((type & IORESOURCE_MEM_64) &&\n\t\t (b_res[2].flags & IORESOURCE_MEM_64))\n\t\tidx = 2;\n\telse if (!(b_res[2].flags & IORESOURCE_MEM_64) &&\n\t\t (b_res[2].flags & IORESOURCE_PREFETCH))\n\t\tidx = 2;\n\telse\n\t\tidx = 1;\n\n\tr = &b_res[idx];\n\n\tif (!r->parent)\n\t\treturn;\n\n\t \n\trelease_child_resources(r);\n\tif (!release_resource(r)) {\n\t\ttype = old_flags = r->flags & PCI_RES_TYPE_MASK;\n\t\tpci_info(dev, \"resource %d %pR released\\n\",\n\t\t\t PCI_BRIDGE_RESOURCES + idx, r);\n\t\t \n\t\tr->end = resource_size(r) - 1;\n\t\tr->start = 0;\n\t\tr->flags = 0;\n\n\t\t \n\t\tif (type & IORESOURCE_PREFETCH)\n\t\t\ttype = IORESOURCE_PREFETCH;\n\t\t__pci_setup_bridge(bus, type);\n\t\t \n\t\tr->flags = old_flags;\n\t}\n}\n\nenum release_type {\n\tleaf_only,\n\twhole_subtree,\n};\n\n \nstatic void pci_bus_release_bridge_resources(struct pci_bus *bus,\n\t\t\t\t\t     unsigned long type,\n\t\t\t\t\t     enum release_type rel_type)\n{\n\tstruct pci_dev *dev;\n\tbool is_leaf_bridge = true;\n\n\tlist_for_each_entry(dev, &bus->devices, bus_list) {\n\t\tstruct pci_bus *b = dev->subordinate;\n\t\tif (!b)\n\t\t\tcontinue;\n\n\t\tis_leaf_bridge = false;\n\n\t\tif ((dev->class >> 8) != PCI_CLASS_BRIDGE_PCI)\n\t\t\tcontinue;\n\n\t\tif (rel_type == whole_subtree)\n\t\t\tpci_bus_release_bridge_resources(b, type,\n\t\t\t\t\t\t whole_subtree);\n\t}\n\n\tif (pci_is_root_bus(bus))\n\t\treturn;\n\n\tif ((bus->self->class >> 8) != PCI_CLASS_BRIDGE_PCI)\n\t\treturn;\n\n\tif ((rel_type == whole_subtree) || is_leaf_bridge)\n\t\tpci_bridge_release_resources(bus, type);\n}\n\nstatic void pci_bus_dump_res(struct pci_bus *bus)\n{\n\tstruct resource *res;\n\tint i;\n\n\tpci_bus_for_each_resource(bus, res, i) {\n\t\tif (!res || !res->end || !res->flags)\n\t\t\tcontinue;\n\n\t\tdev_info(&bus->dev, \"resource %d %pR\\n\", i, res);\n\t}\n}\n\nstatic void pci_bus_dump_resources(struct pci_bus *bus)\n{\n\tstruct pci_bus *b;\n\tstruct pci_dev *dev;\n\n\n\tpci_bus_dump_res(bus);\n\n\tlist_for_each_entry(dev, &bus->devices, bus_list) {\n\t\tb = dev->subordinate;\n\t\tif (!b)\n\t\t\tcontinue;\n\n\t\tpci_bus_dump_resources(b);\n\t}\n}\n\nstatic int pci_bus_get_depth(struct pci_bus *bus)\n{\n\tint depth = 0;\n\tstruct pci_bus *child_bus;\n\n\tlist_for_each_entry(child_bus, &bus->children, node) {\n\t\tint ret;\n\n\t\tret = pci_bus_get_depth(child_bus);\n\t\tif (ret + 1 > depth)\n\t\t\tdepth = ret + 1;\n\t}\n\n\treturn depth;\n}\n\n \nenum enable_type {\n\tundefined = -1,\n\tuser_disabled,\n\tauto_disabled,\n\tuser_enabled,\n\tauto_enabled,\n};\n\nstatic enum enable_type pci_realloc_enable = undefined;\nvoid __init pci_realloc_get_opt(char *str)\n{\n\tif (!strncmp(str, \"off\", 3))\n\t\tpci_realloc_enable = user_disabled;\n\telse if (!strncmp(str, \"on\", 2))\n\t\tpci_realloc_enable = user_enabled;\n}\nstatic bool pci_realloc_enabled(enum enable_type enable)\n{\n\treturn enable >= user_enabled;\n}\n\n#if defined(CONFIG_PCI_IOV) && defined(CONFIG_PCI_REALLOC_ENABLE_AUTO)\nstatic int iov_resources_unassigned(struct pci_dev *dev, void *data)\n{\n\tint i;\n\tbool *unassigned = data;\n\n\tfor (i = 0; i < PCI_SRIOV_NUM_BARS; i++) {\n\t\tstruct resource *r = &dev->resource[i + PCI_IOV_RESOURCES];\n\t\tstruct pci_bus_region region;\n\n\t\t \n\t\tif (!r->flags)\n\t\t\tcontinue;\n\n\t\tpcibios_resource_to_bus(dev->bus, &region, r);\n\t\tif (!region.start) {\n\t\t\t*unassigned = true;\n\t\t\treturn 1;  \n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic enum enable_type pci_realloc_detect(struct pci_bus *bus,\n\t\t\t\t\t   enum enable_type enable_local)\n{\n\tbool unassigned = false;\n\tstruct pci_host_bridge *host;\n\n\tif (enable_local != undefined)\n\t\treturn enable_local;\n\n\thost = pci_find_host_bridge(bus);\n\tif (host->preserve_config)\n\t\treturn auto_disabled;\n\n\tpci_walk_bus(bus, iov_resources_unassigned, &unassigned);\n\tif (unassigned)\n\t\treturn auto_enabled;\n\n\treturn enable_local;\n}\n#else\nstatic enum enable_type pci_realloc_detect(struct pci_bus *bus,\n\t\t\t\t\t   enum enable_type enable_local)\n{\n\treturn enable_local;\n}\n#endif\n\nstatic void adjust_bridge_window(struct pci_dev *bridge, struct resource *res,\n\t\t\t\t struct list_head *add_list,\n\t\t\t\t resource_size_t new_size)\n{\n\tresource_size_t add_size, size = resource_size(res);\n\n\tif (res->parent)\n\t\treturn;\n\n\tif (!new_size)\n\t\treturn;\n\n\tif (new_size > size) {\n\t\tadd_size = new_size - size;\n\t\tpci_dbg(bridge, \"bridge window %pR extended by %pa\\n\", res,\n\t\t\t&add_size);\n\t} else if (new_size < size) {\n\t\tadd_size = size - new_size;\n\t\tpci_dbg(bridge, \"bridge window %pR shrunken by %pa\\n\", res,\n\t\t\t&add_size);\n\t} else {\n\t\treturn;\n\t}\n\n\tres->end = res->start + new_size - 1;\n\n\t \n\tif (add_list)\n\t\tremove_from_list(add_list, res);\n}\n\nstatic void remove_dev_resource(struct resource *avail, struct pci_dev *dev,\n\t\t\t\tstruct resource *res)\n{\n\tresource_size_t size, align, tmp;\n\n\tsize = resource_size(res);\n\tif (!size)\n\t\treturn;\n\n\talign = pci_resource_alignment(dev, res);\n\talign = align ? ALIGN(avail->start, align) - avail->start : 0;\n\ttmp = align + size;\n\tavail->start = min(avail->start + tmp, avail->end + 1);\n}\n\nstatic void remove_dev_resources(struct pci_dev *dev, struct resource *io,\n\t\t\t\t struct resource *mmio,\n\t\t\t\t struct resource *mmio_pref)\n{\n\tstruct resource *res;\n\n\tpci_dev_for_each_resource(dev, res) {\n\t\tif (resource_type(res) == IORESOURCE_IO) {\n\t\t\tremove_dev_resource(io, dev, res);\n\t\t} else if (resource_type(res) == IORESOURCE_MEM) {\n\n\t\t\t \n\t\t\tif ((res->flags & IORESOURCE_PREFETCH) &&\n\t\t\t    ((res->flags & IORESOURCE_MEM_64) ==\n\t\t\t     (mmio_pref->flags & IORESOURCE_MEM_64)))\n\t\t\t\tremove_dev_resource(mmio_pref, dev, res);\n\t\t\telse\n\t\t\t\tremove_dev_resource(mmio, dev, res);\n\t\t}\n\t}\n}\n\n \nstatic void pci_bus_distribute_available_resources(struct pci_bus *bus,\n\t\t\t\t\t    struct list_head *add_list,\n\t\t\t\t\t    struct resource io,\n\t\t\t\t\t    struct resource mmio,\n\t\t\t\t\t    struct resource mmio_pref)\n{\n\tunsigned int normal_bridges = 0, hotplug_bridges = 0;\n\tstruct resource *io_res, *mmio_res, *mmio_pref_res;\n\tstruct pci_dev *dev, *bridge = bus->self;\n\tresource_size_t io_per_b, mmio_per_b, mmio_pref_per_b, align;\n\n\tio_res = &bridge->resource[PCI_BRIDGE_IO_WINDOW];\n\tmmio_res = &bridge->resource[PCI_BRIDGE_MEM_WINDOW];\n\tmmio_pref_res = &bridge->resource[PCI_BRIDGE_PREF_MEM_WINDOW];\n\n\t \n\talign = pci_resource_alignment(bridge, io_res);\n\tif (!io_res->parent && align)\n\t\tio.start = min(ALIGN(io.start, align), io.end + 1);\n\n\talign = pci_resource_alignment(bridge, mmio_res);\n\tif (!mmio_res->parent && align)\n\t\tmmio.start = min(ALIGN(mmio.start, align), mmio.end + 1);\n\n\talign = pci_resource_alignment(bridge, mmio_pref_res);\n\tif (!mmio_pref_res->parent && align)\n\t\tmmio_pref.start = min(ALIGN(mmio_pref.start, align),\n\t\t\tmmio_pref.end + 1);\n\n\t \n\tadjust_bridge_window(bridge, io_res, add_list, resource_size(&io));\n\tadjust_bridge_window(bridge, mmio_res, add_list, resource_size(&mmio));\n\tadjust_bridge_window(bridge, mmio_pref_res, add_list,\n\t\t\t     resource_size(&mmio_pref));\n\n\t \n\tfor_each_pci_bridge(dev, bus) {\n\t\tif (dev->is_hotplug_bridge)\n\t\t\thotplug_bridges++;\n\t\telse\n\t\t\tnormal_bridges++;\n\t}\n\n\tif (!(hotplug_bridges + normal_bridges))\n\t\treturn;\n\n\t \n\tlist_for_each_entry(dev, &bus->devices, bus_list) {\n\t\tif (!dev->is_virtfn)\n\t\t\tremove_dev_resources(dev, &io, &mmio, &mmio_pref);\n\t}\n\n\t \n\tif (hotplug_bridges) {\n\t\tio_per_b = div64_ul(resource_size(&io), hotplug_bridges);\n\t\tmmio_per_b = div64_ul(resource_size(&mmio), hotplug_bridges);\n\t\tmmio_pref_per_b = div64_ul(resource_size(&mmio_pref),\n\t\t\t\t\t   hotplug_bridges);\n\t} else {\n\t\tio_per_b = div64_ul(resource_size(&io), normal_bridges);\n\t\tmmio_per_b = div64_ul(resource_size(&mmio), normal_bridges);\n\t\tmmio_pref_per_b = div64_ul(resource_size(&mmio_pref),\n\t\t\t\t\t   normal_bridges);\n\t}\n\n\tfor_each_pci_bridge(dev, bus) {\n\t\tstruct resource *res;\n\t\tstruct pci_bus *b;\n\n\t\tb = dev->subordinate;\n\t\tif (!b)\n\t\t\tcontinue;\n\t\tif (hotplug_bridges && !dev->is_hotplug_bridge)\n\t\t\tcontinue;\n\n\t\tres = &dev->resource[PCI_BRIDGE_IO_WINDOW];\n\n\t\t \n\t\talign = pci_resource_alignment(dev, res);\n\t\tio.end = align ? io.start + ALIGN_DOWN(io_per_b, align) - 1\n\t\t\t       : io.start + io_per_b - 1;\n\n\t\t \n\t\tio.start -= resource_size(res);\n\n\t\tres = &dev->resource[PCI_BRIDGE_MEM_WINDOW];\n\t\talign = pci_resource_alignment(dev, res);\n\t\tmmio.end = align ? mmio.start + ALIGN_DOWN(mmio_per_b, align) - 1\n\t\t\t\t : mmio.start + mmio_per_b - 1;\n\t\tmmio.start -= resource_size(res);\n\n\t\tres = &dev->resource[PCI_BRIDGE_PREF_MEM_WINDOW];\n\t\talign = pci_resource_alignment(dev, res);\n\t\tmmio_pref.end = align ? mmio_pref.start +\n\t\t\t\t\tALIGN_DOWN(mmio_pref_per_b, align) - 1\n\t\t\t\t      : mmio_pref.start + mmio_pref_per_b - 1;\n\t\tmmio_pref.start -= resource_size(res);\n\n\t\tpci_bus_distribute_available_resources(b, add_list, io, mmio,\n\t\t\t\t\t\t       mmio_pref);\n\n\t\tio.start += io.end + 1;\n\t\tmmio.start += mmio.end + 1;\n\t\tmmio_pref.start += mmio_pref.end + 1;\n\t}\n}\n\nstatic void pci_bridge_distribute_available_resources(struct pci_dev *bridge,\n\t\t\t\t\t\t      struct list_head *add_list)\n{\n\tstruct resource available_io, available_mmio, available_mmio_pref;\n\n\tif (!bridge->is_hotplug_bridge)\n\t\treturn;\n\n\tpci_dbg(bridge, \"distributing available resources\\n\");\n\n\t \n\tavailable_io = bridge->resource[PCI_BRIDGE_IO_WINDOW];\n\tavailable_mmio = bridge->resource[PCI_BRIDGE_MEM_WINDOW];\n\tavailable_mmio_pref = bridge->resource[PCI_BRIDGE_PREF_MEM_WINDOW];\n\n\tpci_bus_distribute_available_resources(bridge->subordinate,\n\t\t\t\t\t       add_list, available_io,\n\t\t\t\t\t       available_mmio,\n\t\t\t\t\t       available_mmio_pref);\n}\n\nstatic bool pci_bridge_resources_not_assigned(struct pci_dev *dev)\n{\n\tconst struct resource *r;\n\n\t \n\tr = &dev->resource[PCI_BRIDGE_IO_WINDOW];\n\tif (r->flags && !(r->flags & IORESOURCE_STARTALIGN))\n\t\treturn false;\n\tr = &dev->resource[PCI_BRIDGE_MEM_WINDOW];\n\tif (r->flags && !(r->flags & IORESOURCE_STARTALIGN))\n\t\treturn false;\n\tr = &dev->resource[PCI_BRIDGE_PREF_MEM_WINDOW];\n\tif (r->flags && !(r->flags & IORESOURCE_STARTALIGN))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic void\npci_root_bus_distribute_available_resources(struct pci_bus *bus,\n\t\t\t\t\t    struct list_head *add_list)\n{\n\tstruct pci_dev *dev, *bridge = bus->self;\n\n\tfor_each_pci_bridge(dev, bus) {\n\t\tstruct pci_bus *b;\n\n\t\tb = dev->subordinate;\n\t\tif (!b)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (bridge && pci_bridge_resources_not_assigned(dev))\n\t\t\tpci_bridge_distribute_available_resources(bridge,\n\t\t\t\t\t\t\t\t  add_list);\n\t\telse\n\t\t\tpci_root_bus_distribute_available_resources(b, add_list);\n\t}\n}\n\n \nvoid pci_assign_unassigned_root_bus_resources(struct pci_bus *bus)\n{\n\tLIST_HEAD(realloc_head);\n\t \n\tstruct list_head *add_list = NULL;\n\tint tried_times = 0;\n\tenum release_type rel_type = leaf_only;\n\tLIST_HEAD(fail_head);\n\tstruct pci_dev_resource *fail_res;\n\tint pci_try_num = 1;\n\tenum enable_type enable_local;\n\n\t \n\tenable_local = pci_realloc_detect(bus, pci_realloc_enable);\n\tif (pci_realloc_enabled(enable_local)) {\n\t\tint max_depth = pci_bus_get_depth(bus);\n\n\t\tpci_try_num = max_depth + 1;\n\t\tdev_info(&bus->dev, \"max bus depth: %d pci_try_num: %d\\n\",\n\t\t\t max_depth, pci_try_num);\n\t}\n\nagain:\n\t \n\tif (tried_times + 1 == pci_try_num)\n\t\tadd_list = &realloc_head;\n\t \n\t__pci_bus_size_bridges(bus, add_list);\n\n\tpci_root_bus_distribute_available_resources(bus, add_list);\n\n\t \n\t__pci_bus_assign_resources(bus, add_list, &fail_head);\n\tif (add_list)\n\t\tBUG_ON(!list_empty(add_list));\n\ttried_times++;\n\n\t \n\tif (list_empty(&fail_head))\n\t\tgoto dump;\n\n\tif (tried_times >= pci_try_num) {\n\t\tif (enable_local == undefined)\n\t\t\tdev_info(&bus->dev, \"Some PCI device resources are unassigned, try booting with pci=realloc\\n\");\n\t\telse if (enable_local == auto_enabled)\n\t\t\tdev_info(&bus->dev, \"Automatically enabled pci realloc, if you have problem, try booting with pci=realloc=off\\n\");\n\n\t\tfree_list(&fail_head);\n\t\tgoto dump;\n\t}\n\n\tdev_info(&bus->dev, \"No. %d try to assign unassigned res\\n\",\n\t\t tried_times + 1);\n\n\t \n\tif ((tried_times + 1) > 2)\n\t\trel_type = whole_subtree;\n\n\t \n\tlist_for_each_entry(fail_res, &fail_head, list)\n\t\tpci_bus_release_bridge_resources(fail_res->dev->bus,\n\t\t\t\t\t\t fail_res->flags & PCI_RES_TYPE_MASK,\n\t\t\t\t\t\t rel_type);\n\n\t \n\tlist_for_each_entry(fail_res, &fail_head, list) {\n\t\tstruct resource *res = fail_res->res;\n\t\tint idx;\n\n\t\tres->start = fail_res->start;\n\t\tres->end = fail_res->end;\n\t\tres->flags = fail_res->flags;\n\n\t\tif (pci_is_bridge(fail_res->dev)) {\n\t\t\tidx = res - &fail_res->dev->resource[0];\n\t\t\tif (idx >= PCI_BRIDGE_RESOURCES &&\n\t\t\t    idx <= PCI_BRIDGE_RESOURCE_END)\n\t\t\t\tres->flags = 0;\n\t\t}\n\t}\n\tfree_list(&fail_head);\n\n\tgoto again;\n\ndump:\n\t \n\tpci_bus_dump_resources(bus);\n}\n\nvoid __init pci_assign_unassigned_resources(void)\n{\n\tstruct pci_bus *root_bus;\n\n\tlist_for_each_entry(root_bus, &pci_root_buses, node) {\n\t\tpci_assign_unassigned_root_bus_resources(root_bus);\n\n\t\t \n\t\tif (ACPI_HANDLE(root_bus->bridge))\n\t\t\tacpi_ioapic_add(ACPI_HANDLE(root_bus->bridge));\n\t}\n}\n\nvoid pci_assign_unassigned_bridge_resources(struct pci_dev *bridge)\n{\n\tstruct pci_bus *parent = bridge->subordinate;\n\t \n\tLIST_HEAD(add_list);\n\n\tint tried_times = 0;\n\tLIST_HEAD(fail_head);\n\tstruct pci_dev_resource *fail_res;\n\tint retval;\n\nagain:\n\t__pci_bus_size_bridges(parent, &add_list);\n\n\t \n\tpci_bridge_distribute_available_resources(bridge, &add_list);\n\n\t__pci_bridge_assign_resources(bridge, &add_list, &fail_head);\n\tBUG_ON(!list_empty(&add_list));\n\ttried_times++;\n\n\tif (list_empty(&fail_head))\n\t\tgoto enable_all;\n\n\tif (tried_times >= 2) {\n\t\t \n\t\tfree_list(&fail_head);\n\t\tgoto enable_all;\n\t}\n\n\tprintk(KERN_DEBUG \"PCI: No. %d try to assign unassigned res\\n\",\n\t\t\t tried_times + 1);\n\n\t \n\tlist_for_each_entry(fail_res, &fail_head, list)\n\t\tpci_bus_release_bridge_resources(fail_res->dev->bus,\n\t\t\t\t\t\t fail_res->flags & PCI_RES_TYPE_MASK,\n\t\t\t\t\t\t whole_subtree);\n\n\t \n\tlist_for_each_entry(fail_res, &fail_head, list) {\n\t\tstruct resource *res = fail_res->res;\n\t\tint idx;\n\n\t\tres->start = fail_res->start;\n\t\tres->end = fail_res->end;\n\t\tres->flags = fail_res->flags;\n\n\t\tif (pci_is_bridge(fail_res->dev)) {\n\t\t\tidx = res - &fail_res->dev->resource[0];\n\t\t\tif (idx >= PCI_BRIDGE_RESOURCES &&\n\t\t\t    idx <= PCI_BRIDGE_RESOURCE_END)\n\t\t\t\tres->flags = 0;\n\t\t}\n\t}\n\tfree_list(&fail_head);\n\n\tgoto again;\n\nenable_all:\n\tretval = pci_reenable_device(bridge);\n\tif (retval)\n\t\tpci_err(bridge, \"Error reenabling bridge (%d)\\n\", retval);\n\tpci_set_master(bridge);\n}\nEXPORT_SYMBOL_GPL(pci_assign_unassigned_bridge_resources);\n\nint pci_reassign_bridge_resources(struct pci_dev *bridge, unsigned long type)\n{\n\tstruct pci_dev_resource *dev_res;\n\tstruct pci_dev *next;\n\tLIST_HEAD(saved);\n\tLIST_HEAD(added);\n\tLIST_HEAD(failed);\n\tunsigned int i;\n\tint ret;\n\n\tdown_read(&pci_bus_sem);\n\n\t \n\tnext = bridge;\n\tdo {\n\t\tbridge = next;\n\t\tfor (i = PCI_BRIDGE_RESOURCES; i < PCI_BRIDGE_RESOURCE_END;\n\t\t     i++) {\n\t\t\tstruct resource *res = &bridge->resource[i];\n\n\t\t\tif ((res->flags ^ type) & PCI_RES_TYPE_MASK)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tif (res->child)\n\t\t\t\tcontinue;\n\n\t\t\tret = add_to_list(&saved, bridge, res, 0, 0);\n\t\t\tif (ret)\n\t\t\t\tgoto cleanup;\n\n\t\t\tpci_info(bridge, \"BAR %d: releasing %pR\\n\",\n\t\t\t\t i, res);\n\n\t\t\tif (res->parent)\n\t\t\t\trelease_resource(res);\n\t\t\tres->start = 0;\n\t\t\tres->end = 0;\n\t\t\tbreak;\n\t\t}\n\t\tif (i == PCI_BRIDGE_RESOURCE_END)\n\t\t\tbreak;\n\n\t\tnext = bridge->bus ? bridge->bus->self : NULL;\n\t} while (next);\n\n\tif (list_empty(&saved)) {\n\t\tup_read(&pci_bus_sem);\n\t\treturn -ENOENT;\n\t}\n\n\t__pci_bus_size_bridges(bridge->subordinate, &added);\n\t__pci_bridge_assign_resources(bridge, &added, &failed);\n\tBUG_ON(!list_empty(&added));\n\n\tif (!list_empty(&failed)) {\n\t\tret = -ENOSPC;\n\t\tgoto cleanup;\n\t}\n\n\tlist_for_each_entry(dev_res, &saved, list) {\n\t\t \n\t\tif (bridge == dev_res->dev)\n\t\t\tcontinue;\n\n\t\tbridge = dev_res->dev;\n\t\tpci_setup_bridge(bridge->subordinate);\n\t}\n\n\tfree_list(&saved);\n\tup_read(&pci_bus_sem);\n\treturn 0;\n\ncleanup:\n\t \n\tlist_for_each_entry(dev_res, &failed, list) {\n\t\tstruct resource *res = dev_res->res;\n\n\t\tres->start = dev_res->start;\n\t\tres->end = dev_res->end;\n\t\tres->flags = dev_res->flags;\n\t}\n\tfree_list(&failed);\n\n\t \n\tlist_for_each_entry(dev_res, &saved, list) {\n\t\tstruct resource *res = dev_res->res;\n\n\t\tbridge = dev_res->dev;\n\t\ti = res - bridge->resource;\n\n\t\tres->start = dev_res->start;\n\t\tres->end = dev_res->end;\n\t\tres->flags = dev_res->flags;\n\n\t\tpci_claim_resource(bridge, i);\n\t\tpci_setup_bridge(bridge->subordinate);\n\t}\n\tfree_list(&saved);\n\tup_read(&pci_bus_sem);\n\n\treturn ret;\n}\n\nvoid pci_assign_unassigned_bus_resources(struct pci_bus *bus)\n{\n\tstruct pci_dev *dev;\n\t \n\tLIST_HEAD(add_list);\n\n\tdown_read(&pci_bus_sem);\n\tfor_each_pci_bridge(dev, bus)\n\t\tif (pci_has_subordinate(dev))\n\t\t\t__pci_bus_size_bridges(dev->subordinate, &add_list);\n\tup_read(&pci_bus_sem);\n\t__pci_bus_assign_resources(bus, &add_list, NULL);\n\tBUG_ON(!list_empty(&add_list));\n}\nEXPORT_SYMBOL_GPL(pci_assign_unassigned_bus_resources);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}