{
  "module_name": "of.c",
  "hash_id": "fab9ea0637bdfa9d0e5bd14fdb5501d7c470f0de75f8e7354e338dd6b2b6e95d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/of.c",
  "human_readable_source": "\n \n#define pr_fmt(fmt)\t\"PCI: OF: \" fmt\n\n#include <linux/irqdomain.h>\n#include <linux/kernel.h>\n#include <linux/pci.h>\n#include <linux/of.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of_pci.h>\n#include \"pci.h\"\n\n#ifdef CONFIG_PCI\n \nint pci_set_of_node(struct pci_dev *dev)\n{\n\tstruct device_node *node;\n\n\tif (!dev->bus->dev.of_node)\n\t\treturn 0;\n\n\tnode = of_pci_find_child_device(dev->bus->dev.of_node, dev->devfn);\n\tif (!node)\n\t\treturn 0;\n\n\tdevice_set_node(&dev->dev, of_fwnode_handle(node));\n\treturn 0;\n}\n\nvoid pci_release_of_node(struct pci_dev *dev)\n{\n\tof_node_put(dev->dev.of_node);\n\tdevice_set_node(&dev->dev, NULL);\n}\n\nvoid pci_set_bus_of_node(struct pci_bus *bus)\n{\n\tstruct device_node *node;\n\n\tif (bus->self == NULL) {\n\t\tnode = pcibios_get_phb_of_node(bus);\n\t} else {\n\t\tnode = of_node_get(bus->self->dev.of_node);\n\t\tif (node && of_property_read_bool(node, \"external-facing\"))\n\t\t\tbus->self->external_facing = true;\n\t}\n\n\tdevice_set_node(&bus->dev, of_fwnode_handle(node));\n}\n\nvoid pci_release_bus_of_node(struct pci_bus *bus)\n{\n\tof_node_put(bus->dev.of_node);\n\tdevice_set_node(&bus->dev, NULL);\n}\n\nstruct device_node * __weak pcibios_get_phb_of_node(struct pci_bus *bus)\n{\n\t \n\tif (WARN_ON(bus->self || bus->parent))\n\t\treturn NULL;\n\n\t \n\tif (bus->bridge->of_node)\n\t\treturn of_node_get(bus->bridge->of_node);\n\tif (bus->bridge->parent && bus->bridge->parent->of_node)\n\t\treturn of_node_get(bus->bridge->parent->of_node);\n\treturn NULL;\n}\n\nstruct irq_domain *pci_host_bridge_of_msi_domain(struct pci_bus *bus)\n{\n#ifdef CONFIG_IRQ_DOMAIN\n\tstruct irq_domain *d;\n\n\tif (!bus->dev.of_node)\n\t\treturn NULL;\n\n\t \n\td = of_msi_get_domain(&bus->dev, bus->dev.of_node, DOMAIN_BUS_PCI_MSI);\n\tif (d)\n\t\treturn d;\n\n\t \n\td = irq_find_matching_host(bus->dev.of_node, DOMAIN_BUS_PCI_MSI);\n\tif (d)\n\t\treturn d;\n\n\treturn irq_find_host(bus->dev.of_node);\n#else\n\treturn NULL;\n#endif\n}\n\nbool pci_host_of_has_msi_map(struct device *dev)\n{\n\tif (dev && dev->of_node)\n\t\treturn of_get_property(dev->of_node, \"msi-map\", NULL);\n\treturn false;\n}\n\nstatic inline int __of_pci_pci_compare(struct device_node *node,\n\t\t\t\t       unsigned int data)\n{\n\tint devfn;\n\n\tdevfn = of_pci_get_devfn(node);\n\tif (devfn < 0)\n\t\treturn 0;\n\n\treturn devfn == data;\n}\n\nstruct device_node *of_pci_find_child_device(struct device_node *parent,\n\t\t\t\t\t     unsigned int devfn)\n{\n\tstruct device_node *node, *node2;\n\n\tfor_each_child_of_node(parent, node) {\n\t\tif (__of_pci_pci_compare(node, devfn))\n\t\t\treturn node;\n\t\t \n\t\tif (of_node_name_eq(node, \"multifunc-device\")) {\n\t\t\tfor_each_child_of_node(node, node2) {\n\t\t\t\tif (__of_pci_pci_compare(node2, devfn)) {\n\t\t\t\t\tof_node_put(node);\n\t\t\t\t\treturn node2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(of_pci_find_child_device);\n\n \nint of_pci_get_devfn(struct device_node *np)\n{\n\tu32 reg[5];\n\tint error;\n\n\terror = of_property_read_u32_array(np, \"reg\", reg, ARRAY_SIZE(reg));\n\tif (error)\n\t\treturn error;\n\n\treturn (reg[0] >> 8) & 0xff;\n}\nEXPORT_SYMBOL_GPL(of_pci_get_devfn);\n\n \nint of_pci_parse_bus_range(struct device_node *node, struct resource *res)\n{\n\tu32 bus_range[2];\n\tint error;\n\n\terror = of_property_read_u32_array(node, \"bus-range\", bus_range,\n\t\t\t\t\t   ARRAY_SIZE(bus_range));\n\tif (error)\n\t\treturn error;\n\n\tres->name = node->name;\n\tres->start = bus_range[0];\n\tres->end = bus_range[1];\n\tres->flags = IORESOURCE_BUS;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(of_pci_parse_bus_range);\n\n \nint of_get_pci_domain_nr(struct device_node *node)\n{\n\tu32 domain;\n\tint error;\n\n\terror = of_property_read_u32(node, \"linux,pci-domain\", &domain);\n\tif (error)\n\t\treturn error;\n\n\treturn (u16)domain;\n}\nEXPORT_SYMBOL_GPL(of_get_pci_domain_nr);\n\n \nvoid of_pci_check_probe_only(void)\n{\n\tu32 val;\n\tint ret;\n\n\tret = of_property_read_u32(of_chosen, \"linux,pci-probe-only\", &val);\n\tif (ret) {\n\t\tif (ret == -ENODATA || ret == -EOVERFLOW)\n\t\t\tpr_warn(\"linux,pci-probe-only without valid value, ignoring\\n\");\n\t\treturn;\n\t}\n\n\tif (val)\n\t\tpci_add_flags(PCI_PROBE_ONLY);\n\telse\n\t\tpci_clear_flags(PCI_PROBE_ONLY);\n\n\tpr_info(\"PROBE_ONLY %s\\n\", val ? \"enabled\" : \"disabled\");\n}\nEXPORT_SYMBOL_GPL(of_pci_check_probe_only);\n\n \nstatic int devm_of_pci_get_host_bridge_resources(struct device *dev,\n\t\t\tunsigned char busno, unsigned char bus_max,\n\t\t\tstruct list_head *resources,\n\t\t\tstruct list_head *ib_resources,\n\t\t\tresource_size_t *io_base)\n{\n\tstruct device_node *dev_node = dev->of_node;\n\tstruct resource *res, tmp_res;\n\tstruct resource *bus_range;\n\tstruct of_pci_range range;\n\tstruct of_pci_range_parser parser;\n\tconst char *range_type;\n\tint err;\n\n\tif (io_base)\n\t\t*io_base = (resource_size_t)OF_BAD_ADDR;\n\n\tbus_range = devm_kzalloc(dev, sizeof(*bus_range), GFP_KERNEL);\n\tif (!bus_range)\n\t\treturn -ENOMEM;\n\n\tdev_info(dev, \"host bridge %pOF ranges:\\n\", dev_node);\n\n\terr = of_pci_parse_bus_range(dev_node, bus_range);\n\tif (err) {\n\t\tbus_range->start = busno;\n\t\tbus_range->end = bus_max;\n\t\tbus_range->flags = IORESOURCE_BUS;\n\t\tdev_info(dev, \"  No bus range found for %pOF, using %pR\\n\",\n\t\t\t dev_node, bus_range);\n\t} else {\n\t\tif (bus_range->end > bus_range->start + bus_max)\n\t\t\tbus_range->end = bus_range->start + bus_max;\n\t}\n\tpci_add_resource(resources, bus_range);\n\n\t \n\terr = of_pci_range_parser_init(&parser, dev_node);\n\tif (err)\n\t\treturn 0;\n\n\tdev_dbg(dev, \"Parsing ranges property...\\n\");\n\tfor_each_of_pci_range(&parser, &range) {\n\t\t \n\t\tif ((range.flags & IORESOURCE_TYPE_BITS) == IORESOURCE_IO)\n\t\t\trange_type = \"IO\";\n\t\telse if ((range.flags & IORESOURCE_TYPE_BITS) == IORESOURCE_MEM)\n\t\t\trange_type = \"MEM\";\n\t\telse\n\t\t\trange_type = \"err\";\n\t\tdev_info(dev, \"  %6s %#012llx..%#012llx -> %#012llx\\n\",\n\t\t\t range_type, range.cpu_addr,\n\t\t\t range.cpu_addr + range.size - 1, range.pci_addr);\n\n\t\t \n\t\tif (range.cpu_addr == OF_BAD_ADDR || range.size == 0)\n\t\t\tcontinue;\n\n\t\terr = of_pci_range_to_resource(&range, dev_node, &tmp_res);\n\t\tif (err)\n\t\t\tcontinue;\n\n\t\tres = devm_kmemdup(dev, &tmp_res, sizeof(tmp_res), GFP_KERNEL);\n\t\tif (!res) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto failed;\n\t\t}\n\n\t\tif (resource_type(res) == IORESOURCE_IO) {\n\t\t\tif (!io_base) {\n\t\t\t\tdev_err(dev, \"I/O range found for %pOF. Please provide an io_base pointer to save CPU base address\\n\",\n\t\t\t\t\tdev_node);\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto failed;\n\t\t\t}\n\t\t\tif (*io_base != (resource_size_t)OF_BAD_ADDR)\n\t\t\t\tdev_warn(dev, \"More than one I/O resource converted for %pOF. CPU base address for old range lost!\\n\",\n\t\t\t\t\t dev_node);\n\t\t\t*io_base = range.cpu_addr;\n\t\t} else if (resource_type(res) == IORESOURCE_MEM) {\n\t\t\tres->flags &= ~IORESOURCE_MEM_64;\n\t\t}\n\n\t\tpci_add_resource_offset(resources, res,\tres->start - range.pci_addr);\n\t}\n\n\t \n\tif (!ib_resources)\n\t\treturn 0;\n\terr = of_pci_dma_range_parser_init(&parser, dev_node);\n\tif (err)\n\t\treturn 0;\n\n\tdev_dbg(dev, \"Parsing dma-ranges property...\\n\");\n\tfor_each_of_pci_range(&parser, &range) {\n\t\t \n\t\tif (((range.flags & IORESOURCE_TYPE_BITS) != IORESOURCE_MEM) ||\n\t\t    range.cpu_addr == OF_BAD_ADDR || range.size == 0)\n\t\t\tcontinue;\n\n\t\tdev_info(dev, \"  %6s %#012llx..%#012llx -> %#012llx\\n\",\n\t\t\t \"IB MEM\", range.cpu_addr,\n\t\t\t range.cpu_addr + range.size - 1, range.pci_addr);\n\n\n\t\terr = of_pci_range_to_resource(&range, dev_node, &tmp_res);\n\t\tif (err)\n\t\t\tcontinue;\n\n\t\tres = devm_kmemdup(dev, &tmp_res, sizeof(tmp_res), GFP_KERNEL);\n\t\tif (!res) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto failed;\n\t\t}\n\n\t\tpci_add_resource_offset(ib_resources, res,\n\t\t\t\t\tres->start - range.pci_addr);\n\t}\n\n\treturn 0;\n\nfailed:\n\tpci_free_resource_list(resources);\n\treturn err;\n}\n\n#if IS_ENABLED(CONFIG_OF_IRQ)\n \nstatic int of_irq_parse_pci(const struct pci_dev *pdev, struct of_phandle_args *out_irq)\n{\n\tstruct device_node *dn, *ppnode = NULL;\n\tstruct pci_dev *ppdev;\n\t__be32 laddr[3];\n\tu8 pin;\n\tint rc;\n\n\t \n\tdn = pci_device_to_OF_node(pdev);\n\tif (dn) {\n\t\trc = of_irq_parse_one(dn, 0, out_irq);\n\t\tif (!rc)\n\t\t\treturn rc;\n\t}\n\n\t \n\trc = pci_read_config_byte(pdev, PCI_INTERRUPT_PIN, &pin);\n\tif (rc != 0)\n\t\tgoto err;\n\t \n\tif (pin == 0)\n\t\treturn -ENODEV;\n\n\t \n\tif (of_property_present(dn, \"interrupt-map\")) {\n\t\tpin = pci_swizzle_interrupt_pin(pdev, pin);\n\t\tppnode = dn;\n\t}\n\n\t \n\twhile (!ppnode) {\n\t\t \n\t\tppdev = pdev->bus->self;\n\n\t\t \n\t\tif (ppdev == NULL) {\n\t\t\tppnode = pci_bus_to_OF_node(pdev->bus);\n\n\t\t\t \n\t\t\tif (ppnode == NULL) {\n\t\t\t\trc = -EINVAL;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tppnode = pci_device_to_OF_node(ppdev);\n\t\t}\n\n\t\t \n\t\tif (ppnode)\n\t\t\tbreak;\n\n\t\t \n\t\tpin = pci_swizzle_interrupt_pin(pdev, pin);\n\t\tpdev = ppdev;\n\t}\n\n\tout_irq->np = ppnode;\n\tout_irq->args_count = 1;\n\tout_irq->args[0] = pin;\n\tladdr[0] = cpu_to_be32((pdev->bus->number << 16) | (pdev->devfn << 8));\n\tladdr[1] = laddr[2] = cpu_to_be32(0);\n\trc = of_irq_parse_raw(laddr, out_irq);\n\tif (rc)\n\t\tgoto err;\n\treturn 0;\nerr:\n\tif (rc == -ENOENT) {\n\t\tdev_warn(&pdev->dev,\n\t\t\t\"%s: no interrupt-map found, INTx interrupts not available\\n\",\n\t\t\t__func__);\n\t\tpr_warn_once(\"%s: possibly some PCI slots don't have level triggered interrupts capability\\n\",\n\t\t\t__func__);\n\t} else {\n\t\tdev_err(&pdev->dev, \"%s: failed with rc=%d\\n\", __func__, rc);\n\t}\n\treturn rc;\n}\n\n \nint of_irq_parse_and_map_pci(const struct pci_dev *dev, u8 slot, u8 pin)\n{\n\tstruct of_phandle_args oirq;\n\tint ret;\n\n\tret = of_irq_parse_pci(dev, &oirq);\n\tif (ret)\n\t\treturn 0;  \n\n\treturn irq_create_of_mapping(&oirq);\n}\nEXPORT_SYMBOL_GPL(of_irq_parse_and_map_pci);\n#endif\t \n\nstatic int pci_parse_request_of_pci_ranges(struct device *dev,\n\t\t\t\t\t   struct pci_host_bridge *bridge)\n{\n\tint err, res_valid = 0;\n\tresource_size_t iobase;\n\tstruct resource_entry *win, *tmp;\n\n\tINIT_LIST_HEAD(&bridge->windows);\n\tINIT_LIST_HEAD(&bridge->dma_ranges);\n\n\terr = devm_of_pci_get_host_bridge_resources(dev, 0, 0xff, &bridge->windows,\n\t\t\t\t\t\t    &bridge->dma_ranges, &iobase);\n\tif (err)\n\t\treturn err;\n\n\terr = devm_request_pci_bus_resources(dev, &bridge->windows);\n\tif (err)\n\t\treturn err;\n\n\tresource_list_for_each_entry_safe(win, tmp, &bridge->windows) {\n\t\tstruct resource *res = win->res;\n\n\t\tswitch (resource_type(res)) {\n\t\tcase IORESOURCE_IO:\n\t\t\terr = devm_pci_remap_iospace(dev, res, iobase);\n\t\t\tif (err) {\n\t\t\t\tdev_warn(dev, \"error %d: failed to map resource %pR\\n\",\n\t\t\t\t\t err, res);\n\t\t\t\tresource_list_destroy_entry(win);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase IORESOURCE_MEM:\n\t\t\tres_valid |= !(res->flags & IORESOURCE_PREFETCH);\n\n\t\t\tif (!(res->flags & IORESOURCE_PREFETCH))\n\t\t\t\tif (upper_32_bits(resource_size(res)))\n\t\t\t\t\tdev_warn(dev, \"Memory resource size exceeds max for 32 bits\\n\");\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!res_valid)\n\t\tdev_warn(dev, \"non-prefetchable memory resource required\\n\");\n\n\treturn 0;\n}\n\nint devm_of_pci_bridge_init(struct device *dev, struct pci_host_bridge *bridge)\n{\n\tif (!dev->of_node)\n\t\treturn 0;\n\n\tbridge->swizzle_irq = pci_common_swizzle;\n\tbridge->map_irq = of_irq_parse_and_map_pci;\n\n\treturn pci_parse_request_of_pci_ranges(dev, bridge);\n}\n\n#ifdef CONFIG_PCI_DYNAMIC_OF_NODES\n\nvoid of_pci_remove_node(struct pci_dev *pdev)\n{\n\tstruct device_node *np;\n\n\tnp = pci_device_to_OF_node(pdev);\n\tif (!np || !of_node_check_flag(np, OF_DYNAMIC))\n\t\treturn;\n\tpdev->dev.of_node = NULL;\n\n\tof_changeset_revert(np->data);\n\tof_changeset_destroy(np->data);\n\tof_node_put(np);\n}\n\nvoid of_pci_make_dev_node(struct pci_dev *pdev)\n{\n\tstruct device_node *ppnode, *np = NULL;\n\tconst char *pci_type;\n\tstruct of_changeset *cset;\n\tconst char *name;\n\tint ret;\n\n\t \n\tif (pci_device_to_OF_node(pdev))\n\t\treturn;\n\n\t \n\tif (!pdev->bus->self)\n\t\tppnode = pdev->bus->dev.of_node;\n\telse\n\t\tppnode = pdev->bus->self->dev.of_node;\n\tif (!ppnode)\n\t\treturn;\n\n\tif (pci_is_bridge(pdev))\n\t\tpci_type = \"pci\";\n\telse\n\t\tpci_type = \"dev\";\n\n\tname = kasprintf(GFP_KERNEL, \"%s@%x,%x\", pci_type,\n\t\t\t PCI_SLOT(pdev->devfn), PCI_FUNC(pdev->devfn));\n\tif (!name)\n\t\treturn;\n\n\tcset = kmalloc(sizeof(*cset), GFP_KERNEL);\n\tif (!cset)\n\t\tgoto out_free_name;\n\tof_changeset_init(cset);\n\n\tnp = of_changeset_create_node(cset, ppnode, name);\n\tif (!np)\n\t\tgoto out_destroy_cset;\n\n\tret = of_pci_add_properties(pdev, cset, np);\n\tif (ret)\n\t\tgoto out_free_node;\n\n\tret = of_changeset_apply(cset);\n\tif (ret)\n\t\tgoto out_free_node;\n\n\tnp->data = cset;\n\tpdev->dev.of_node = np;\n\tkfree(name);\n\n\treturn;\n\nout_free_node:\n\tof_node_put(np);\nout_destroy_cset:\n\tof_changeset_destroy(cset);\n\tkfree(cset);\nout_free_name:\n\tkfree(name);\n}\n#endif\n\n#endif  \n\n \nint of_pci_get_max_link_speed(struct device_node *node)\n{\n\tu32 max_link_speed;\n\n\tif (of_property_read_u32(node, \"max-link-speed\", &max_link_speed) ||\n\t    max_link_speed == 0 || max_link_speed > 4)\n\t\treturn -EINVAL;\n\n\treturn max_link_speed;\n}\nEXPORT_SYMBOL_GPL(of_pci_get_max_link_speed);\n\n \nu32 of_pci_get_slot_power_limit(struct device_node *node,\n\t\t\t\tu8 *slot_power_limit_value,\n\t\t\t\tu8 *slot_power_limit_scale)\n{\n\tu32 slot_power_limit_mw;\n\tu8 value, scale;\n\n\tif (of_property_read_u32(node, \"slot-power-limit-milliwatt\",\n\t\t\t\t &slot_power_limit_mw))\n\t\tslot_power_limit_mw = 0;\n\n\t \n\tif (slot_power_limit_mw == 0) {\n\t\tvalue = 0x00;\n\t\tscale = 0;\n\t} else if (slot_power_limit_mw <= 255) {\n\t\tvalue = slot_power_limit_mw;\n\t\tscale = 3;\n\t} else if (slot_power_limit_mw <= 255*10) {\n\t\tvalue = slot_power_limit_mw / 10;\n\t\tscale = 2;\n\t\tslot_power_limit_mw = slot_power_limit_mw / 10 * 10;\n\t} else if (slot_power_limit_mw <= 255*100) {\n\t\tvalue = slot_power_limit_mw / 100;\n\t\tscale = 1;\n\t\tslot_power_limit_mw = slot_power_limit_mw / 100 * 100;\n\t} else if (slot_power_limit_mw <= 239*1000) {\n\t\tvalue = slot_power_limit_mw / 1000;\n\t\tscale = 0;\n\t\tslot_power_limit_mw = slot_power_limit_mw / 1000 * 1000;\n\t} else if (slot_power_limit_mw < 250*1000) {\n\t\tvalue = 0xEF;\n\t\tscale = 0;\n\t\tslot_power_limit_mw = 239*1000;\n\t} else if (slot_power_limit_mw <= 600*1000) {\n\t\tvalue = 0xF0 + (slot_power_limit_mw / 1000 - 250) / 25;\n\t\tscale = 0;\n\t\tslot_power_limit_mw = slot_power_limit_mw / (1000*25) * (1000*25);\n\t} else {\n\t\tvalue = 0xFE;\n\t\tscale = 0;\n\t\tslot_power_limit_mw = 600*1000;\n\t}\n\n\tif (slot_power_limit_value)\n\t\t*slot_power_limit_value = value;\n\n\tif (slot_power_limit_scale)\n\t\t*slot_power_limit_scale = scale;\n\n\treturn slot_power_limit_mw;\n}\nEXPORT_SYMBOL_GPL(of_pci_get_slot_power_limit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}