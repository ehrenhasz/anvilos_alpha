{
  "module_name": "vc.c",
  "hash_id": "552fd185d3270ddce51b69032d5d70a9e8693e072b901261626f4ee8396c44bd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/vc.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/pci_regs.h>\n#include <linux/types.h>\n\n#include \"pci.h\"\n\n \nstatic void pci_vc_save_restore_dwords(struct pci_dev *dev, int pos,\n\t\t\t\t       u32 *buf, int dwords, bool save)\n{\n\tint i;\n\n\tfor (i = 0; i < dwords; i++, buf++) {\n\t\tif (save)\n\t\t\tpci_read_config_dword(dev, pos + (i * 4), buf);\n\t\telse\n\t\t\tpci_write_config_dword(dev, pos + (i * 4), *buf);\n\t}\n}\n\n \nstatic void pci_vc_load_arb_table(struct pci_dev *dev, int pos)\n{\n\tu16 ctrl;\n\n\tpci_read_config_word(dev, pos + PCI_VC_PORT_CTRL, &ctrl);\n\tpci_write_config_word(dev, pos + PCI_VC_PORT_CTRL,\n\t\t\t      ctrl | PCI_VC_PORT_CTRL_LOAD_TABLE);\n\tif (pci_wait_for_pending(dev, pos + PCI_VC_PORT_STATUS,\n\t\t\t\t PCI_VC_PORT_STATUS_TABLE))\n\t\treturn;\n\n\tpci_err(dev, \"VC arbitration table failed to load\\n\");\n}\n\n \nstatic void pci_vc_load_port_arb_table(struct pci_dev *dev, int pos, int res)\n{\n\tint ctrl_pos, status_pos;\n\tu32 ctrl;\n\n\tctrl_pos = pos + PCI_VC_RES_CTRL + (res * PCI_CAP_VC_PER_VC_SIZEOF);\n\tstatus_pos = pos + PCI_VC_RES_STATUS + (res * PCI_CAP_VC_PER_VC_SIZEOF);\n\n\tpci_read_config_dword(dev, ctrl_pos, &ctrl);\n\tpci_write_config_dword(dev, ctrl_pos,\n\t\t\t       ctrl | PCI_VC_RES_CTRL_LOAD_TABLE);\n\n\tif (pci_wait_for_pending(dev, status_pos, PCI_VC_RES_STATUS_TABLE))\n\t\treturn;\n\n\tpci_err(dev, \"VC%d port arbitration table failed to load\\n\", res);\n}\n\n \nstatic void pci_vc_enable(struct pci_dev *dev, int pos, int res)\n{\n\tint ctrl_pos, status_pos, id, pos2, evcc, i, ctrl_pos2, status_pos2;\n\tu32 ctrl, header, cap1, ctrl2;\n\tstruct pci_dev *link = NULL;\n\n\t \n\tif (!pci_is_pcie(dev) || !pcie_downstream_port(dev))\n\t\treturn;\n\n\tctrl_pos = pos + PCI_VC_RES_CTRL + (res * PCI_CAP_VC_PER_VC_SIZEOF);\n\tstatus_pos = pos + PCI_VC_RES_STATUS + (res * PCI_CAP_VC_PER_VC_SIZEOF);\n\n\tpci_read_config_dword(dev, ctrl_pos, &ctrl);\n\tid = ctrl & PCI_VC_RES_CTRL_ID;\n\n\tpci_read_config_dword(dev, pos, &header);\n\n\t \n\tif (PCI_EXT_CAP_ID(header) == PCI_EXT_CAP_ID_VC9 ||\n\t    pci_is_root_bus(dev->bus))\n\t\tgoto enable;\n\n\tpos2 = pci_find_ext_capability(dev->bus->self, PCI_EXT_CAP_ID_VC);\n\tif (!pos2)\n\t\tgoto enable;\n\n\tpci_read_config_dword(dev->bus->self, pos2 + PCI_VC_PORT_CAP1, &cap1);\n\tevcc = cap1 & PCI_VC_CAP1_EVCC;\n\n\t \n\tfor (i = 1; i < evcc + 1; i++) {\n\t\tctrl_pos2 = pos2 + PCI_VC_RES_CTRL +\n\t\t\t\t(i * PCI_CAP_VC_PER_VC_SIZEOF);\n\t\tstatus_pos2 = pos2 + PCI_VC_RES_STATUS +\n\t\t\t\t(i * PCI_CAP_VC_PER_VC_SIZEOF);\n\t\tpci_read_config_dword(dev->bus->self, ctrl_pos2, &ctrl2);\n\t\tif ((ctrl2 & PCI_VC_RES_CTRL_ID) == id) {\n\t\t\tlink = dev->bus->self;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!link)\n\t\tgoto enable;\n\n\t \n\tif (ctrl2 & PCI_VC_RES_CTRL_ENABLE) {\n\t\tctrl2 &= ~PCI_VC_RES_CTRL_ENABLE;\n\t\tpci_write_config_dword(link, ctrl_pos2, ctrl2);\n\t}\n\n\t \n\tctrl2 |= PCI_VC_RES_CTRL_ENABLE;\n\tpci_write_config_dword(link, ctrl_pos2, ctrl2);\nenable:\n\tctrl |= PCI_VC_RES_CTRL_ENABLE;\n\tpci_write_config_dword(dev, ctrl_pos, ctrl);\n\n\tif (!pci_wait_for_pending(dev, status_pos, PCI_VC_RES_STATUS_NEGO))\n\t\tpci_err(dev, \"VC%d negotiation stuck pending\\n\", id);\n\n\tif (link && !pci_wait_for_pending(link, status_pos2,\n\t\t\t\t\t  PCI_VC_RES_STATUS_NEGO))\n\t\tpci_err(link, \"VC%d negotiation stuck pending\\n\", id);\n}\n\n \nstatic int pci_vc_do_save_buffer(struct pci_dev *dev, int pos,\n\t\t\t\t struct pci_cap_saved_state *save_state,\n\t\t\t\t bool save)\n{\n\tu32 cap1;\n\tchar evcc, lpevcc, parb_size;\n\tint i, len = 0;\n\tu8 *buf = save_state ? (u8 *)save_state->cap.data : NULL;\n\n\t \n\tif (buf && save_state->cap.size !=\n\t    pci_vc_do_save_buffer(dev, pos, NULL, save)) {\n\t\tpci_err(dev, \"VC save buffer size does not match @0x%x\\n\", pos);\n\t\treturn -ENOMEM;\n\t}\n\n\tpci_read_config_dword(dev, pos + PCI_VC_PORT_CAP1, &cap1);\n\t \n\tevcc = cap1 & PCI_VC_CAP1_EVCC;\n\t \n\tlpevcc = (cap1 & PCI_VC_CAP1_LPEVCC) >> 4;\n\t \n\tparb_size = 1 << ((cap1 & PCI_VC_CAP1_ARB_SIZE) >> 10);\n\n\t \n\tif (buf) {\n\t\tif (save)\n\t\t\tpci_read_config_word(dev, pos + PCI_VC_PORT_CTRL,\n\t\t\t\t\t     (u16 *)buf);\n\t\telse\n\t\t\tpci_write_config_word(dev, pos + PCI_VC_PORT_CTRL,\n\t\t\t\t\t      *(u16 *)buf);\n\t\tbuf += 4;\n\t}\n\tlen += 4;\n\n\t \n\tif (lpevcc) {\n\t\tu32 cap2;\n\t\tint vcarb_offset;\n\n\t\tpci_read_config_dword(dev, pos + PCI_VC_PORT_CAP2, &cap2);\n\t\tvcarb_offset = ((cap2 & PCI_VC_CAP2_ARB_OFF) >> 24) * 16;\n\n\t\tif (vcarb_offset) {\n\t\t\tint size, vcarb_phases = 0;\n\n\t\t\tif (cap2 & PCI_VC_CAP2_128_PHASE)\n\t\t\t\tvcarb_phases = 128;\n\t\t\telse if (cap2 & PCI_VC_CAP2_64_PHASE)\n\t\t\t\tvcarb_phases = 64;\n\t\t\telse if (cap2 & PCI_VC_CAP2_32_PHASE)\n\t\t\t\tvcarb_phases = 32;\n\n\t\t\t \n\t\t\tsize = ((lpevcc + 1) * vcarb_phases * 4) / 8;\n\n\t\t\tif (size && buf) {\n\t\t\t\tpci_vc_save_restore_dwords(dev,\n\t\t\t\t\t\t\t   pos + vcarb_offset,\n\t\t\t\t\t\t\t   (u32 *)buf,\n\t\t\t\t\t\t\t   size / 4, save);\n\t\t\t\t \n\t\t\t\tif (!save)\n\t\t\t\t\tpci_vc_load_arb_table(dev, pos);\n\n\t\t\t\tbuf += size;\n\t\t\t}\n\t\t\tlen += size;\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < evcc + 1; i++) {\n\t\tu32 cap;\n\t\tint parb_offset;\n\n\t\tpci_read_config_dword(dev, pos + PCI_VC_RES_CAP +\n\t\t\t\t      (i * PCI_CAP_VC_PER_VC_SIZEOF), &cap);\n\t\tparb_offset = ((cap & PCI_VC_RES_CAP_ARB_OFF) >> 24) * 16;\n\t\tif (parb_offset) {\n\t\t\tint size, parb_phases = 0;\n\n\t\t\tif (cap & PCI_VC_RES_CAP_256_PHASE)\n\t\t\t\tparb_phases = 256;\n\t\t\telse if (cap & (PCI_VC_RES_CAP_128_PHASE |\n\t\t\t\t\tPCI_VC_RES_CAP_128_PHASE_TB))\n\t\t\t\tparb_phases = 128;\n\t\t\telse if (cap & PCI_VC_RES_CAP_64_PHASE)\n\t\t\t\tparb_phases = 64;\n\t\t\telse if (cap & PCI_VC_RES_CAP_32_PHASE)\n\t\t\t\tparb_phases = 32;\n\n\t\t\tsize = (parb_size * parb_phases) / 8;\n\n\t\t\tif (size && buf) {\n\t\t\t\tpci_vc_save_restore_dwords(dev,\n\t\t\t\t\t\t\t   pos + parb_offset,\n\t\t\t\t\t\t\t   (u32 *)buf,\n\t\t\t\t\t\t\t   size / 4, save);\n\t\t\t\tbuf += size;\n\t\t\t}\n\t\t\tlen += size;\n\t\t}\n\n\t\t \n\t\tif (buf) {\n\t\t\tint ctrl_pos = pos + PCI_VC_RES_CTRL +\n\t\t\t\t\t\t(i * PCI_CAP_VC_PER_VC_SIZEOF);\n\t\t\tif (save)\n\t\t\t\tpci_read_config_dword(dev, ctrl_pos,\n\t\t\t\t\t\t      (u32 *)buf);\n\t\t\telse {\n\t\t\t\tu32 tmp, ctrl = *(u32 *)buf;\n\t\t\t\t \n\t\t\t\tpci_read_config_dword(dev, ctrl_pos, &tmp);\n\t\t\t\ttmp &= PCI_VC_RES_CTRL_ENABLE;\n\t\t\t\ttmp |= ctrl & ~PCI_VC_RES_CTRL_ENABLE;\n\t\t\t\tpci_write_config_dword(dev, ctrl_pos, tmp);\n\t\t\t\t \n\t\t\t\tif (ctrl & PCI_VC_RES_CTRL_ARB_SELECT)\n\t\t\t\t\tpci_vc_load_port_arb_table(dev, pos, i);\n\t\t\t\t \n\t\t\t\tif ((ctrl ^ tmp) & PCI_VC_RES_CTRL_ENABLE)\n\t\t\t\t\tpci_vc_enable(dev, pos, i);\n\t\t\t}\n\t\t\tbuf += 4;\n\t\t}\n\t\tlen += 4;\n\t}\n\n\treturn buf ? 0 : len;\n}\n\nstatic struct {\n\tu16 id;\n\tconst char *name;\n} vc_caps[] = { { PCI_EXT_CAP_ID_MFVC, \"MFVC\" },\n\t\t{ PCI_EXT_CAP_ID_VC, \"VC\" },\n\t\t{ PCI_EXT_CAP_ID_VC9, \"VC9\" } };\n\n \nint pci_save_vc_state(struct pci_dev *dev)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(vc_caps); i++) {\n\t\tint pos, ret;\n\t\tstruct pci_cap_saved_state *save_state;\n\n\t\tpos = pci_find_ext_capability(dev, vc_caps[i].id);\n\t\tif (!pos)\n\t\t\tcontinue;\n\n\t\tsave_state = pci_find_saved_ext_cap(dev, vc_caps[i].id);\n\t\tif (!save_state) {\n\t\t\tpci_err(dev, \"%s buffer not found in %s\\n\",\n\t\t\t\tvc_caps[i].name, __func__);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tret = pci_vc_do_save_buffer(dev, pos, save_state, true);\n\t\tif (ret) {\n\t\t\tpci_err(dev, \"%s save unsuccessful %s\\n\",\n\t\t\t\tvc_caps[i].name, __func__);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nvoid pci_restore_vc_state(struct pci_dev *dev)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(vc_caps); i++) {\n\t\tint pos;\n\t\tstruct pci_cap_saved_state *save_state;\n\n\t\tpos = pci_find_ext_capability(dev, vc_caps[i].id);\n\t\tsave_state = pci_find_saved_ext_cap(dev, vc_caps[i].id);\n\t\tif (!save_state || !pos)\n\t\t\tcontinue;\n\n\t\tpci_vc_do_save_buffer(dev, pos, save_state, false);\n\t}\n}\n\n \nvoid pci_allocate_vc_save_buffers(struct pci_dev *dev)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(vc_caps); i++) {\n\t\tint len, pos = pci_find_ext_capability(dev, vc_caps[i].id);\n\n\t\tif (!pos)\n\t\t\tcontinue;\n\n\t\tlen = pci_vc_do_save_buffer(dev, pos, NULL, false);\n\t\tif (pci_add_ext_cap_save_buffer(dev, vc_caps[i].id, len))\n\t\t\tpci_err(dev, \"unable to preallocate %s save buffer\\n\",\n\t\t\t\tvc_caps[i].name);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}