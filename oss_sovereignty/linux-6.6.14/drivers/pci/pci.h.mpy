{
  "module_name": "pci.h",
  "hash_id": "ab7fac0b72101bb07d1cf943e7cf519c97d7943865f2555d5b2a17b815dda155",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/pci.h",
  "human_readable_source": " \n#ifndef DRIVERS_PCI_H\n#define DRIVERS_PCI_H\n\n#include <linux/pci.h>\n\n \n#define MAX_NR_DEVFNS 256\n\n#define PCI_FIND_CAP_TTL\t48\n\n#define PCI_VSEC_ID_INTEL_TBT\t0x1234\t \n\n#define PCIE_LINK_RETRAIN_TIMEOUT_MS\t1000\n\n \n#define PCIE_PME_TO_L2_TIMEOUT_US\t10000\n\nextern const unsigned char pcie_link_speed[];\nextern bool pci_early_dump;\n\nbool pcie_cap_has_lnkctl(const struct pci_dev *dev);\nbool pcie_cap_has_lnkctl2(const struct pci_dev *dev);\nbool pcie_cap_has_rtctl(const struct pci_dev *dev);\n\n \n\nint pci_create_sysfs_dev_files(struct pci_dev *pdev);\nvoid pci_remove_sysfs_dev_files(struct pci_dev *pdev);\nvoid pci_cleanup_rom(struct pci_dev *dev);\n#ifdef CONFIG_DMI\nextern const struct attribute_group pci_dev_smbios_attr_group;\n#endif\n\nenum pci_mmap_api {\n\tPCI_MMAP_SYSFS,\t \n\tPCI_MMAP_PROCFS\t \n};\nint pci_mmap_fits(struct pci_dev *pdev, int resno, struct vm_area_struct *vmai,\n\t\t  enum pci_mmap_api mmap_api);\n\nbool pci_reset_supported(struct pci_dev *dev);\nvoid pci_init_reset_methods(struct pci_dev *dev);\nint pci_bridge_secondary_bus_reset(struct pci_dev *dev);\nint pci_bus_error_reset(struct pci_dev *dev);\n\nstruct pci_cap_saved_data {\n\tu16\t\tcap_nr;\n\tbool\t\tcap_extended;\n\tunsigned int\tsize;\n\tu32\t\tdata[];\n};\n\nstruct pci_cap_saved_state {\n\tstruct hlist_node\t\tnext;\n\tstruct pci_cap_saved_data\tcap;\n};\n\nvoid pci_allocate_cap_save_buffers(struct pci_dev *dev);\nvoid pci_free_cap_save_buffers(struct pci_dev *dev);\nint pci_add_cap_save_buffer(struct pci_dev *dev, char cap, unsigned int size);\nint pci_add_ext_cap_save_buffer(struct pci_dev *dev,\n\t\t\t\tu16 cap, unsigned int size);\nstruct pci_cap_saved_state *pci_find_saved_cap(struct pci_dev *dev, char cap);\nstruct pci_cap_saved_state *pci_find_saved_ext_cap(struct pci_dev *dev,\n\t\t\t\t\t\t   u16 cap);\n\n#define PCI_PM_D2_DELAY         200\t \n#define PCI_PM_D3HOT_WAIT       10\t \n#define PCI_PM_D3COLD_WAIT      100\t \n\nvoid pci_update_current_state(struct pci_dev *dev, pci_power_t state);\nvoid pci_refresh_power_state(struct pci_dev *dev);\nint pci_power_up(struct pci_dev *dev);\nvoid pci_disable_enabled_device(struct pci_dev *dev);\nint pci_finish_runtime_suspend(struct pci_dev *dev);\nvoid pcie_clear_device_status(struct pci_dev *dev);\nvoid pcie_clear_root_pme_status(struct pci_dev *dev);\nbool pci_check_pme_status(struct pci_dev *dev);\nvoid pci_pme_wakeup_bus(struct pci_bus *bus);\nint __pci_pme_wakeup(struct pci_dev *dev, void *ign);\nvoid pci_pme_restore(struct pci_dev *dev);\nbool pci_dev_need_resume(struct pci_dev *dev);\nvoid pci_dev_adjust_pme(struct pci_dev *dev);\nvoid pci_dev_complete_resume(struct pci_dev *pci_dev);\nvoid pci_config_pm_runtime_get(struct pci_dev *dev);\nvoid pci_config_pm_runtime_put(struct pci_dev *dev);\nvoid pci_pm_init(struct pci_dev *dev);\nvoid pci_ea_init(struct pci_dev *dev);\nvoid pci_msi_init(struct pci_dev *dev);\nvoid pci_msix_init(struct pci_dev *dev);\nbool pci_bridge_d3_possible(struct pci_dev *dev);\nvoid pci_bridge_d3_update(struct pci_dev *dev);\nvoid pci_bridge_reconfigure_ltr(struct pci_dev *dev);\nint pci_bridge_wait_for_secondary_bus(struct pci_dev *dev, char *reset_type);\n\nstatic inline void pci_wakeup_event(struct pci_dev *dev)\n{\n\t \n\tpm_wakeup_event(&dev->dev, 100);\n}\n\nstatic inline bool pci_has_subordinate(struct pci_dev *pci_dev)\n{\n\treturn !!(pci_dev->subordinate);\n}\n\nstatic inline bool pci_power_manageable(struct pci_dev *pci_dev)\n{\n\t \n\treturn !pci_has_subordinate(pci_dev) || pci_dev->bridge_d3;\n}\n\nstatic inline bool pcie_downstream_port(const struct pci_dev *dev)\n{\n\tint type = pci_pcie_type(dev);\n\n\treturn type == PCI_EXP_TYPE_ROOT_PORT ||\n\t       type == PCI_EXP_TYPE_DOWNSTREAM ||\n\t       type == PCI_EXP_TYPE_PCIE_BRIDGE;\n}\n\nvoid pci_vpd_init(struct pci_dev *dev);\nvoid pci_vpd_release(struct pci_dev *dev);\nextern const struct attribute_group pci_dev_vpd_attr_group;\n\n \nint pci_save_vc_state(struct pci_dev *dev);\nvoid pci_restore_vc_state(struct pci_dev *dev);\nvoid pci_allocate_vc_save_buffers(struct pci_dev *dev);\n\n \n#ifdef CONFIG_PROC_FS\nint pci_proc_attach_device(struct pci_dev *dev);\nint pci_proc_detach_device(struct pci_dev *dev);\nint pci_proc_detach_bus(struct pci_bus *bus);\n#else\nstatic inline int pci_proc_attach_device(struct pci_dev *dev) { return 0; }\nstatic inline int pci_proc_detach_device(struct pci_dev *dev) { return 0; }\nstatic inline int pci_proc_detach_bus(struct pci_bus *bus) { return 0; }\n#endif\n\n \nint pci_hp_add_bridge(struct pci_dev *dev);\n\n#ifdef HAVE_PCI_LEGACY\nvoid pci_create_legacy_files(struct pci_bus *bus);\nvoid pci_remove_legacy_files(struct pci_bus *bus);\n#else\nstatic inline void pci_create_legacy_files(struct pci_bus *bus) { }\nstatic inline void pci_remove_legacy_files(struct pci_bus *bus) { }\n#endif\n\n \nextern struct rw_semaphore pci_bus_sem;\nextern struct mutex pci_slot_mutex;\n\nextern raw_spinlock_t pci_lock;\n\nextern unsigned int pci_pm_d3hot_delay;\n\n#ifdef CONFIG_PCI_MSI\nvoid pci_no_msi(void);\n#else\nstatic inline void pci_no_msi(void) { }\n#endif\n\nvoid pci_realloc_get_opt(char *);\n\nstatic inline int pci_no_d1d2(struct pci_dev *dev)\n{\n\tunsigned int parent_dstates = 0;\n\n\tif (dev->bus->self)\n\t\tparent_dstates = dev->bus->self->no_d1d2;\n\treturn (dev->no_d1d2 || parent_dstates);\n\n}\nextern const struct attribute_group *pci_dev_groups[];\nextern const struct attribute_group *pcibus_groups[];\nextern const struct device_type pci_dev_type;\nextern const struct attribute_group *pci_bus_groups[];\n\nextern unsigned long pci_hotplug_io_size;\nextern unsigned long pci_hotplug_mmio_size;\nextern unsigned long pci_hotplug_mmio_pref_size;\nextern unsigned long pci_hotplug_bus_size;\n\n \nstatic inline const struct pci_device_id *\npci_match_one_device(const struct pci_device_id *id, const struct pci_dev *dev)\n{\n\tif ((id->vendor == PCI_ANY_ID || id->vendor == dev->vendor) &&\n\t    (id->device == PCI_ANY_ID || id->device == dev->device) &&\n\t    (id->subvendor == PCI_ANY_ID || id->subvendor == dev->subsystem_vendor) &&\n\t    (id->subdevice == PCI_ANY_ID || id->subdevice == dev->subsystem_device) &&\n\t    !((id->class ^ dev->class) & id->class_mask))\n\t\treturn id;\n\treturn NULL;\n}\n\n \n#define to_pci_slot(s) container_of(s, struct pci_slot, kobj)\n\nextern struct kset *pci_slots_kset;\n\nstruct pci_slot_attribute {\n\tstruct attribute attr;\n\tssize_t (*show)(struct pci_slot *, char *);\n\tssize_t (*store)(struct pci_slot *, const char *, size_t);\n};\n#define to_pci_slot_attr(s) container_of(s, struct pci_slot_attribute, attr)\n\nenum pci_bar_type {\n\tpci_bar_unknown,\t \n\tpci_bar_io,\t\t \n\tpci_bar_mem32,\t\t \n\tpci_bar_mem64,\t\t \n};\n\nstruct device *pci_get_host_bridge_device(struct pci_dev *dev);\nvoid pci_put_host_bridge_device(struct device *dev);\n\nint pci_configure_extended_tags(struct pci_dev *dev, void *ign);\nbool pci_bus_read_dev_vendor_id(struct pci_bus *bus, int devfn, u32 *pl,\n\t\t\t\tint crs_timeout);\nbool pci_bus_generic_read_dev_vendor_id(struct pci_bus *bus, int devfn, u32 *pl,\n\t\t\t\t\tint crs_timeout);\nint pci_idt_bus_quirk(struct pci_bus *bus, int devfn, u32 *pl, int crs_timeout);\n\nint pci_setup_device(struct pci_dev *dev);\nint __pci_read_base(struct pci_dev *dev, enum pci_bar_type type,\n\t\t    struct resource *res, unsigned int reg);\nvoid pci_configure_ari(struct pci_dev *dev);\nvoid __pci_bus_size_bridges(struct pci_bus *bus,\n\t\t\tstruct list_head *realloc_head);\nvoid __pci_bus_assign_resources(const struct pci_bus *bus,\n\t\t\t\tstruct list_head *realloc_head,\n\t\t\t\tstruct list_head *fail_head);\nbool pci_bus_clip_resource(struct pci_dev *dev, int idx);\n\nvoid pci_reassigndev_resource_alignment(struct pci_dev *dev);\nvoid pci_disable_bridge_window(struct pci_dev *dev);\nstruct pci_bus *pci_bus_get(struct pci_bus *bus);\nvoid pci_bus_put(struct pci_bus *bus);\n\n \n#define PCIE_LNKCAP2_SLS2SPEED(lnkcap2) \\\n\t((lnkcap2) & PCI_EXP_LNKCAP2_SLS_64_0GB ? PCIE_SPEED_64_0GT : \\\n\t (lnkcap2) & PCI_EXP_LNKCAP2_SLS_32_0GB ? PCIE_SPEED_32_0GT : \\\n\t (lnkcap2) & PCI_EXP_LNKCAP2_SLS_16_0GB ? PCIE_SPEED_16_0GT : \\\n\t (lnkcap2) & PCI_EXP_LNKCAP2_SLS_8_0GB ? PCIE_SPEED_8_0GT : \\\n\t (lnkcap2) & PCI_EXP_LNKCAP2_SLS_5_0GB ? PCIE_SPEED_5_0GT : \\\n\t (lnkcap2) & PCI_EXP_LNKCAP2_SLS_2_5GB ? PCIE_SPEED_2_5GT : \\\n\t PCI_SPEED_UNKNOWN)\n\n \n#define PCIE_SPEED2MBS_ENC(speed) \\\n\t((speed) == PCIE_SPEED_64_0GT ? 64000*128/130 : \\\n\t (speed) == PCIE_SPEED_32_0GT ? 32000*128/130 : \\\n\t (speed) == PCIE_SPEED_16_0GT ? 16000*128/130 : \\\n\t (speed) == PCIE_SPEED_8_0GT  ?  8000*128/130 : \\\n\t (speed) == PCIE_SPEED_5_0GT  ?  5000*8/10 : \\\n\t (speed) == PCIE_SPEED_2_5GT  ?  2500*8/10 : \\\n\t 0)\n\nconst char *pci_speed_string(enum pci_bus_speed speed);\nenum pci_bus_speed pcie_get_speed_cap(struct pci_dev *dev);\nenum pcie_link_width pcie_get_width_cap(struct pci_dev *dev);\nu32 pcie_bandwidth_capable(struct pci_dev *dev, enum pci_bus_speed *speed,\n\t\t\t   enum pcie_link_width *width);\nvoid __pcie_print_link_status(struct pci_dev *dev, bool verbose);\nvoid pcie_report_downtraining(struct pci_dev *dev);\nvoid pcie_update_link_speed(struct pci_bus *bus, u16 link_status);\n\n \nstruct pci_sriov {\n\tint\t\tpos;\t\t \n\tint\t\tnres;\t\t \n\tu32\t\tcap;\t\t \n\tu16\t\tctrl;\t\t \n\tu16\t\ttotal_VFs;\t \n\tu16\t\tinitial_VFs;\t \n\tu16\t\tnum_VFs;\t \n\tu16\t\toffset;\t\t \n\tu16\t\tstride;\t\t \n\tu16\t\tvf_device;\t \n\tu32\t\tpgsz;\t\t \n\tu8\t\tlink;\t\t \n\tu8\t\tmax_VF_buses;\t \n\tu16\t\tdriver_max_VFs;\t \n\tstruct pci_dev\t*dev;\t\t \n\tstruct pci_dev\t*self;\t\t \n\tu32\t\tclass;\t\t \n\tu8\t\thdr_type;\t \n\tu16\t\tsubsystem_vendor;  \n\tu16\t\tsubsystem_device;  \n\tresource_size_t\tbarsz[PCI_SRIOV_NUM_BARS];\t \n\tbool\t\tdrivers_autoprobe;  \n};\n\n#ifdef CONFIG_PCI_DOE\nvoid pci_doe_init(struct pci_dev *pdev);\nvoid pci_doe_destroy(struct pci_dev *pdev);\nvoid pci_doe_disconnected(struct pci_dev *pdev);\n#else\nstatic inline void pci_doe_init(struct pci_dev *pdev) { }\nstatic inline void pci_doe_destroy(struct pci_dev *pdev) { }\nstatic inline void pci_doe_disconnected(struct pci_dev *pdev) { }\n#endif\n\n \nstatic inline bool pci_dev_set_io_state(struct pci_dev *dev,\n\t\t\t\t\tpci_channel_state_t new)\n{\n\tpci_channel_state_t old;\n\n\tswitch (new) {\n\tcase pci_channel_io_perm_failure:\n\t\txchg(&dev->error_state, pci_channel_io_perm_failure);\n\t\treturn true;\n\tcase pci_channel_io_frozen:\n\t\told = cmpxchg(&dev->error_state, pci_channel_io_normal,\n\t\t\t      pci_channel_io_frozen);\n\t\treturn old != pci_channel_io_perm_failure;\n\tcase pci_channel_io_normal:\n\t\told = cmpxchg(&dev->error_state, pci_channel_io_frozen,\n\t\t\t      pci_channel_io_normal);\n\t\treturn old != pci_channel_io_perm_failure;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic inline int pci_dev_set_disconnected(struct pci_dev *dev, void *unused)\n{\n\tpci_dev_set_io_state(dev, pci_channel_io_perm_failure);\n\tpci_doe_disconnected(dev);\n\n\treturn 0;\n}\n\nstatic inline bool pci_dev_is_disconnected(const struct pci_dev *dev)\n{\n\treturn dev->error_state == pci_channel_io_perm_failure;\n}\n\n \n#define PCI_DEV_ADDED 0\n#define PCI_DPC_RECOVERED 1\n#define PCI_DPC_RECOVERING 2\n\nstatic inline void pci_dev_assign_added(struct pci_dev *dev, bool added)\n{\n\tassign_bit(PCI_DEV_ADDED, &dev->priv_flags, added);\n}\n\nstatic inline bool pci_dev_is_added(const struct pci_dev *dev)\n{\n\treturn test_bit(PCI_DEV_ADDED, &dev->priv_flags);\n}\n\n#ifdef CONFIG_PCIEAER\n#include <linux/aer.h>\n\n#define AER_MAX_MULTI_ERR_DEVICES\t5\t \n\nstruct aer_err_info {\n\tstruct pci_dev *dev[AER_MAX_MULTI_ERR_DEVICES];\n\tint error_dev_num;\n\n\tunsigned int id:16;\n\n\tunsigned int severity:2;\t \n\tunsigned int __pad1:5;\n\tunsigned int multi_error_valid:1;\n\n\tunsigned int first_error:5;\n\tunsigned int __pad2:2;\n\tunsigned int tlp_header_valid:1;\n\n\tunsigned int status;\t\t \n\tunsigned int mask;\t\t \n\tstruct aer_header_log_regs tlp;\t \n};\n\nint aer_get_device_error_info(struct pci_dev *dev, struct aer_err_info *info);\nvoid aer_print_error(struct pci_dev *dev, struct aer_err_info *info);\n#endif\t \n\n#ifdef CONFIG_PCIEPORTBUS\n \nstruct rcec_ea {\n\tu8\t\tnextbusn;\n\tu8\t\tlastbusn;\n\tu32\t\tbitmap;\n};\n#endif\n\n#ifdef CONFIG_PCIE_DPC\nvoid pci_save_dpc_state(struct pci_dev *dev);\nvoid pci_restore_dpc_state(struct pci_dev *dev);\nvoid pci_dpc_init(struct pci_dev *pdev);\nvoid dpc_process_error(struct pci_dev *pdev);\npci_ers_result_t dpc_reset_link(struct pci_dev *pdev);\nbool pci_dpc_recovered(struct pci_dev *pdev);\n#else\nstatic inline void pci_save_dpc_state(struct pci_dev *dev) { }\nstatic inline void pci_restore_dpc_state(struct pci_dev *dev) { }\nstatic inline void pci_dpc_init(struct pci_dev *pdev) { }\nstatic inline bool pci_dpc_recovered(struct pci_dev *pdev) { return false; }\n#endif\n\n#ifdef CONFIG_PCIEPORTBUS\nvoid pci_rcec_init(struct pci_dev *dev);\nvoid pci_rcec_exit(struct pci_dev *dev);\nvoid pcie_link_rcec(struct pci_dev *rcec);\nvoid pcie_walk_rcec(struct pci_dev *rcec,\n\t\t    int (*cb)(struct pci_dev *, void *),\n\t\t    void *userdata);\n#else\nstatic inline void pci_rcec_init(struct pci_dev *dev) { }\nstatic inline void pci_rcec_exit(struct pci_dev *dev) { }\nstatic inline void pcie_link_rcec(struct pci_dev *rcec) { }\nstatic inline void pcie_walk_rcec(struct pci_dev *rcec,\n\t\t\t\t  int (*cb)(struct pci_dev *, void *),\n\t\t\t\t  void *userdata) { }\n#endif\n\n#ifdef CONFIG_PCI_ATS\n \nvoid pci_ats_init(struct pci_dev *dev);\nvoid pci_restore_ats_state(struct pci_dev *dev);\n#else\nstatic inline void pci_ats_init(struct pci_dev *d) { }\nstatic inline void pci_restore_ats_state(struct pci_dev *dev) { }\n#endif  \n\n#ifdef CONFIG_PCI_PRI\nvoid pci_pri_init(struct pci_dev *dev);\nvoid pci_restore_pri_state(struct pci_dev *pdev);\n#else\nstatic inline void pci_pri_init(struct pci_dev *dev) { }\nstatic inline void pci_restore_pri_state(struct pci_dev *pdev) { }\n#endif\n\n#ifdef CONFIG_PCI_PASID\nvoid pci_pasid_init(struct pci_dev *dev);\nvoid pci_restore_pasid_state(struct pci_dev *pdev);\n#else\nstatic inline void pci_pasid_init(struct pci_dev *dev) { }\nstatic inline void pci_restore_pasid_state(struct pci_dev *pdev) { }\n#endif\n\n#ifdef CONFIG_PCI_IOV\nint pci_iov_init(struct pci_dev *dev);\nvoid pci_iov_release(struct pci_dev *dev);\nvoid pci_iov_remove(struct pci_dev *dev);\nvoid pci_iov_update_resource(struct pci_dev *dev, int resno);\nresource_size_t pci_sriov_resource_alignment(struct pci_dev *dev, int resno);\nvoid pci_restore_iov_state(struct pci_dev *dev);\nint pci_iov_bus_range(struct pci_bus *bus);\nextern const struct attribute_group sriov_pf_dev_attr_group;\nextern const struct attribute_group sriov_vf_dev_attr_group;\n#else\nstatic inline int pci_iov_init(struct pci_dev *dev)\n{\n\treturn -ENODEV;\n}\nstatic inline void pci_iov_release(struct pci_dev *dev) { }\nstatic inline void pci_iov_remove(struct pci_dev *dev) { }\nstatic inline void pci_restore_iov_state(struct pci_dev *dev) { }\nstatic inline int pci_iov_bus_range(struct pci_bus *bus)\n{\n\treturn 0;\n}\n\n#endif  \n\n#ifdef CONFIG_PCIE_PTM\nvoid pci_ptm_init(struct pci_dev *dev);\nvoid pci_save_ptm_state(struct pci_dev *dev);\nvoid pci_restore_ptm_state(struct pci_dev *dev);\nvoid pci_suspend_ptm(struct pci_dev *dev);\nvoid pci_resume_ptm(struct pci_dev *dev);\n#else\nstatic inline void pci_ptm_init(struct pci_dev *dev) { }\nstatic inline void pci_save_ptm_state(struct pci_dev *dev) { }\nstatic inline void pci_restore_ptm_state(struct pci_dev *dev) { }\nstatic inline void pci_suspend_ptm(struct pci_dev *dev) { }\nstatic inline void pci_resume_ptm(struct pci_dev *dev) { }\n#endif\n\nunsigned long pci_cardbus_resource_alignment(struct resource *);\n\nstatic inline resource_size_t pci_resource_alignment(struct pci_dev *dev,\n\t\t\t\t\t\t     struct resource *res)\n{\n#ifdef CONFIG_PCI_IOV\n\tint resno = res - dev->resource;\n\n\tif (resno >= PCI_IOV_RESOURCES && resno <= PCI_IOV_RESOURCE_END)\n\t\treturn pci_sriov_resource_alignment(dev, resno);\n#endif\n\tif (dev->class >> 8 == PCI_CLASS_BRIDGE_CARDBUS)\n\t\treturn pci_cardbus_resource_alignment(res);\n\treturn resource_alignment(res);\n}\n\nvoid pci_acs_init(struct pci_dev *dev);\n#ifdef CONFIG_PCI_QUIRKS\nint pci_dev_specific_acs_enabled(struct pci_dev *dev, u16 acs_flags);\nint pci_dev_specific_enable_acs(struct pci_dev *dev);\nint pci_dev_specific_disable_acs_redir(struct pci_dev *dev);\nbool pcie_failed_link_retrain(struct pci_dev *dev);\n#else\nstatic inline int pci_dev_specific_acs_enabled(struct pci_dev *dev,\n\t\t\t\t\t       u16 acs_flags)\n{\n\treturn -ENOTTY;\n}\nstatic inline int pci_dev_specific_enable_acs(struct pci_dev *dev)\n{\n\treturn -ENOTTY;\n}\nstatic inline int pci_dev_specific_disable_acs_redir(struct pci_dev *dev)\n{\n\treturn -ENOTTY;\n}\nstatic inline bool pcie_failed_link_retrain(struct pci_dev *dev)\n{\n\treturn false;\n}\n#endif\n\n \npci_ers_result_t pcie_do_recovery(struct pci_dev *dev,\n\t\tpci_channel_state_t state,\n\t\tpci_ers_result_t (*reset_subordinates)(struct pci_dev *pdev));\n\nbool pcie_wait_for_link(struct pci_dev *pdev, bool active);\nint pcie_retrain_link(struct pci_dev *pdev, bool use_lt);\n#ifdef CONFIG_PCIEASPM\nvoid pcie_aspm_init_link_state(struct pci_dev *pdev);\nvoid pcie_aspm_exit_link_state(struct pci_dev *pdev);\nvoid pcie_aspm_pm_state_change(struct pci_dev *pdev);\nvoid pcie_aspm_powersave_config_link(struct pci_dev *pdev);\n#else\nstatic inline void pcie_aspm_init_link_state(struct pci_dev *pdev) { }\nstatic inline void pcie_aspm_exit_link_state(struct pci_dev *pdev) { }\nstatic inline void pcie_aspm_pm_state_change(struct pci_dev *pdev) { }\nstatic inline void pcie_aspm_powersave_config_link(struct pci_dev *pdev) { }\n#endif\n\n#ifdef CONFIG_PCIE_ECRC\nvoid pcie_set_ecrc_checking(struct pci_dev *dev);\nvoid pcie_ecrc_get_policy(char *str);\n#else\nstatic inline void pcie_set_ecrc_checking(struct pci_dev *dev) { }\nstatic inline void pcie_ecrc_get_policy(char *str) { }\n#endif\n\nstruct pci_dev_reset_methods {\n\tu16 vendor;\n\tu16 device;\n\tint (*reset)(struct pci_dev *dev, bool probe);\n};\n\nstruct pci_reset_fn_method {\n\tint (*reset_fn)(struct pci_dev *pdev, bool probe);\n\tchar *name;\n};\n\n#ifdef CONFIG_PCI_QUIRKS\nint pci_dev_specific_reset(struct pci_dev *dev, bool probe);\n#else\nstatic inline int pci_dev_specific_reset(struct pci_dev *dev, bool probe)\n{\n\treturn -ENOTTY;\n}\n#endif\n\n#if defined(CONFIG_PCI_QUIRKS) && defined(CONFIG_ARM64)\nint acpi_get_rc_resources(struct device *dev, const char *hid, u16 segment,\n\t\t\t  struct resource *res);\n#else\nstatic inline int acpi_get_rc_resources(struct device *dev, const char *hid,\n\t\t\t\t\tu16 segment, struct resource *res)\n{\n\treturn -ENODEV;\n}\n#endif\n\nint pci_rebar_get_current_size(struct pci_dev *pdev, int bar);\nint pci_rebar_set_size(struct pci_dev *pdev, int bar, int size);\nstatic inline u64 pci_rebar_size_to_bytes(int size)\n{\n\treturn 1ULL << (size + 20);\n}\n\nstruct device_node;\n\n#ifdef CONFIG_OF\nint of_pci_parse_bus_range(struct device_node *node, struct resource *res);\nint of_get_pci_domain_nr(struct device_node *node);\nint of_pci_get_max_link_speed(struct device_node *node);\nu32 of_pci_get_slot_power_limit(struct device_node *node,\n\t\t\t\tu8 *slot_power_limit_value,\n\t\t\t\tu8 *slot_power_limit_scale);\nint pci_set_of_node(struct pci_dev *dev);\nvoid pci_release_of_node(struct pci_dev *dev);\nvoid pci_set_bus_of_node(struct pci_bus *bus);\nvoid pci_release_bus_of_node(struct pci_bus *bus);\n\nint devm_of_pci_bridge_init(struct device *dev, struct pci_host_bridge *bridge);\n\n#else\nstatic inline int\nof_pci_parse_bus_range(struct device_node *node, struct resource *res)\n{\n\treturn -EINVAL;\n}\n\nstatic inline int\nof_get_pci_domain_nr(struct device_node *node)\n{\n\treturn -1;\n}\n\nstatic inline int\nof_pci_get_max_link_speed(struct device_node *node)\n{\n\treturn -EINVAL;\n}\n\nstatic inline u32\nof_pci_get_slot_power_limit(struct device_node *node,\n\t\t\t    u8 *slot_power_limit_value,\n\t\t\t    u8 *slot_power_limit_scale)\n{\n\tif (slot_power_limit_value)\n\t\t*slot_power_limit_value = 0;\n\tif (slot_power_limit_scale)\n\t\t*slot_power_limit_scale = 0;\n\treturn 0;\n}\n\nstatic inline int pci_set_of_node(struct pci_dev *dev) { return 0; }\nstatic inline void pci_release_of_node(struct pci_dev *dev) { }\nstatic inline void pci_set_bus_of_node(struct pci_bus *bus) { }\nstatic inline void pci_release_bus_of_node(struct pci_bus *bus) { }\n\nstatic inline int devm_of_pci_bridge_init(struct device *dev, struct pci_host_bridge *bridge)\n{\n\treturn 0;\n}\n\n#endif  \n\nstruct of_changeset;\n\n#ifdef CONFIG_PCI_DYNAMIC_OF_NODES\nvoid of_pci_make_dev_node(struct pci_dev *pdev);\nvoid of_pci_remove_node(struct pci_dev *pdev);\nint of_pci_add_properties(struct pci_dev *pdev, struct of_changeset *ocs,\n\t\t\t  struct device_node *np);\n#else\nstatic inline void of_pci_make_dev_node(struct pci_dev *pdev) { }\nstatic inline void of_pci_remove_node(struct pci_dev *pdev) { }\n#endif\n\n#ifdef CONFIG_PCIEAER\nvoid pci_no_aer(void);\nvoid pci_aer_init(struct pci_dev *dev);\nvoid pci_aer_exit(struct pci_dev *dev);\nextern const struct attribute_group aer_stats_attr_group;\nvoid pci_aer_clear_fatal_status(struct pci_dev *dev);\nint pci_aer_clear_status(struct pci_dev *dev);\nint pci_aer_raw_clear_status(struct pci_dev *dev);\nvoid pci_save_aer_state(struct pci_dev *dev);\nvoid pci_restore_aer_state(struct pci_dev *dev);\n#else\nstatic inline void pci_no_aer(void) { }\nstatic inline void pci_aer_init(struct pci_dev *d) { }\nstatic inline void pci_aer_exit(struct pci_dev *d) { }\nstatic inline void pci_aer_clear_fatal_status(struct pci_dev *dev) { }\nstatic inline int pci_aer_clear_status(struct pci_dev *dev) { return -EINVAL; }\nstatic inline int pci_aer_raw_clear_status(struct pci_dev *dev) { return -EINVAL; }\nstatic inline void pci_save_aer_state(struct pci_dev *dev) { }\nstatic inline void pci_restore_aer_state(struct pci_dev *dev) { }\n#endif\n\n#ifdef CONFIG_ACPI\nint pci_acpi_program_hp_params(struct pci_dev *dev);\nextern const struct attribute_group pci_dev_acpi_attr_group;\nvoid pci_set_acpi_fwnode(struct pci_dev *dev);\nint pci_dev_acpi_reset(struct pci_dev *dev, bool probe);\nbool acpi_pci_power_manageable(struct pci_dev *dev);\nbool acpi_pci_bridge_d3(struct pci_dev *dev);\nint acpi_pci_set_power_state(struct pci_dev *dev, pci_power_t state);\npci_power_t acpi_pci_get_power_state(struct pci_dev *dev);\nvoid acpi_pci_refresh_power_state(struct pci_dev *dev);\nint acpi_pci_wakeup(struct pci_dev *dev, bool enable);\nbool acpi_pci_need_resume(struct pci_dev *dev);\npci_power_t acpi_pci_choose_state(struct pci_dev *pdev);\n#else\nstatic inline int pci_dev_acpi_reset(struct pci_dev *dev, bool probe)\n{\n\treturn -ENOTTY;\n}\nstatic inline void pci_set_acpi_fwnode(struct pci_dev *dev) { }\nstatic inline int pci_acpi_program_hp_params(struct pci_dev *dev)\n{\n\treturn -ENODEV;\n}\nstatic inline bool acpi_pci_power_manageable(struct pci_dev *dev)\n{\n\treturn false;\n}\nstatic inline bool acpi_pci_bridge_d3(struct pci_dev *dev)\n{\n\treturn false;\n}\nstatic inline int acpi_pci_set_power_state(struct pci_dev *dev, pci_power_t state)\n{\n\treturn -ENODEV;\n}\nstatic inline pci_power_t acpi_pci_get_power_state(struct pci_dev *dev)\n{\n\treturn PCI_UNKNOWN;\n}\nstatic inline void acpi_pci_refresh_power_state(struct pci_dev *dev) { }\nstatic inline int acpi_pci_wakeup(struct pci_dev *dev, bool enable)\n{\n\treturn -ENODEV;\n}\nstatic inline bool acpi_pci_need_resume(struct pci_dev *dev)\n{\n\treturn false;\n}\nstatic inline pci_power_t acpi_pci_choose_state(struct pci_dev *pdev)\n{\n\treturn PCI_POWER_ERROR;\n}\n#endif\n\n#ifdef CONFIG_PCIEASPM\nextern const struct attribute_group aspm_ctrl_attr_group;\n#endif\n\nextern const struct attribute_group pci_dev_reset_method_attr_group;\n\n#ifdef CONFIG_X86_INTEL_MID\nbool pci_use_mid_pm(void);\nint mid_pci_set_power_state(struct pci_dev *pdev, pci_power_t state);\npci_power_t mid_pci_get_power_state(struct pci_dev *pdev);\n#else\nstatic inline bool pci_use_mid_pm(void)\n{\n\treturn false;\n}\nstatic inline int mid_pci_set_power_state(struct pci_dev *pdev, pci_power_t state)\n{\n\treturn -ENODEV;\n}\nstatic inline pci_power_t mid_pci_get_power_state(struct pci_dev *pdev)\n{\n\treturn PCI_UNKNOWN;\n}\n#endif\n\n \n\n#define PCI_CONF1_BUS_SHIFT\t16  \n#define PCI_CONF1_DEV_SHIFT\t11  \n#define PCI_CONF1_FUNC_SHIFT\t8   \n\n#define PCI_CONF1_BUS_MASK\t0xff\n#define PCI_CONF1_DEV_MASK\t0x1f\n#define PCI_CONF1_FUNC_MASK\t0x7\n#define PCI_CONF1_REG_MASK\t0xfc  \n\n#define PCI_CONF1_ENABLE\tBIT(31)\n#define PCI_CONF1_BUS(x)\t(((x) & PCI_CONF1_BUS_MASK) << PCI_CONF1_BUS_SHIFT)\n#define PCI_CONF1_DEV(x)\t(((x) & PCI_CONF1_DEV_MASK) << PCI_CONF1_DEV_SHIFT)\n#define PCI_CONF1_FUNC(x)\t(((x) & PCI_CONF1_FUNC_MASK) << PCI_CONF1_FUNC_SHIFT)\n#define PCI_CONF1_REG(x)\t((x) & PCI_CONF1_REG_MASK)\n\n#define PCI_CONF1_ADDRESS(bus, dev, func, reg) \\\n\t(PCI_CONF1_ENABLE | \\\n\t PCI_CONF1_BUS(bus) | \\\n\t PCI_CONF1_DEV(dev) | \\\n\t PCI_CONF1_FUNC(func) | \\\n\t PCI_CONF1_REG(reg))\n\n \n\n#define PCI_CONF1_EXT_REG_SHIFT\t16\n#define PCI_CONF1_EXT_REG_MASK\t0xf00\n#define PCI_CONF1_EXT_REG(x)\t(((x) & PCI_CONF1_EXT_REG_MASK) << PCI_CONF1_EXT_REG_SHIFT)\n\n#define PCI_CONF1_EXT_ADDRESS(bus, dev, func, reg) \\\n\t(PCI_CONF1_ADDRESS(bus, dev, func, reg) | \\\n\t PCI_CONF1_EXT_REG(reg))\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}