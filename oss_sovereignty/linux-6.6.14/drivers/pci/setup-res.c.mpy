{
  "module_name": "setup-res.c",
  "hash_id": "69f95eea8fd7d605ecbe8415448135ab26273c3076fe190fa449c48fc6ba0a4b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/setup-res.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/pci.h>\n#include <linux/errno.h>\n#include <linux/ioport.h>\n#include <linux/cache.h>\n#include <linux/slab.h>\n#include \"pci.h\"\n\nstatic void pci_std_update_resource(struct pci_dev *dev, int resno)\n{\n\tstruct pci_bus_region region;\n\tbool disable;\n\tu16 cmd;\n\tu32 new, check, mask;\n\tint reg;\n\tstruct resource *res = dev->resource + resno;\n\n\t \n\tif (dev->is_virtfn)\n\t\treturn;\n\n\t \n\tif (!res->flags)\n\t\treturn;\n\n\tif (res->flags & IORESOURCE_UNSET)\n\t\treturn;\n\n\t \n\tif (res->flags & IORESOURCE_PCI_FIXED)\n\t\treturn;\n\n\tpcibios_resource_to_bus(dev->bus, &region, res);\n\tnew = region.start;\n\n\tif (res->flags & IORESOURCE_IO) {\n\t\tmask = (u32)PCI_BASE_ADDRESS_IO_MASK;\n\t\tnew |= res->flags & ~PCI_BASE_ADDRESS_IO_MASK;\n\t} else if (resno == PCI_ROM_RESOURCE) {\n\t\tmask = PCI_ROM_ADDRESS_MASK;\n\t} else {\n\t\tmask = (u32)PCI_BASE_ADDRESS_MEM_MASK;\n\t\tnew |= res->flags & ~PCI_BASE_ADDRESS_MEM_MASK;\n\t}\n\n\tif (resno < PCI_ROM_RESOURCE) {\n\t\treg = PCI_BASE_ADDRESS_0 + 4 * resno;\n\t} else if (resno == PCI_ROM_RESOURCE) {\n\n\t\t \n\t\tif (!(res->flags & IORESOURCE_ROM_ENABLE) &&\n\t\t    !dev->rom_bar_overlap)\n\t\t\treturn;\n\n\t\treg = dev->rom_base_reg;\n\t\tif (res->flags & IORESOURCE_ROM_ENABLE)\n\t\t\tnew |= PCI_ROM_ADDRESS_ENABLE;\n\t} else\n\t\treturn;\n\n\t \n\tdisable = (res->flags & IORESOURCE_MEM_64) && !dev->mmio_always_on;\n\tif (disable) {\n\t\tpci_read_config_word(dev, PCI_COMMAND, &cmd);\n\t\tpci_write_config_word(dev, PCI_COMMAND,\n\t\t\t\t      cmd & ~PCI_COMMAND_MEMORY);\n\t}\n\n\tpci_write_config_dword(dev, reg, new);\n\tpci_read_config_dword(dev, reg, &check);\n\n\tif ((new ^ check) & mask) {\n\t\tpci_err(dev, \"BAR %d: error updating (%#010x != %#010x)\\n\",\n\t\t\tresno, new, check);\n\t}\n\n\tif (res->flags & IORESOURCE_MEM_64) {\n\t\tnew = region.start >> 16 >> 16;\n\t\tpci_write_config_dword(dev, reg + 4, new);\n\t\tpci_read_config_dword(dev, reg + 4, &check);\n\t\tif (check != new) {\n\t\t\tpci_err(dev, \"BAR %d: error updating (high %#010x != %#010x)\\n\",\n\t\t\t\tresno, new, check);\n\t\t}\n\t}\n\n\tif (disable)\n\t\tpci_write_config_word(dev, PCI_COMMAND, cmd);\n}\n\nvoid pci_update_resource(struct pci_dev *dev, int resno)\n{\n\tif (resno <= PCI_ROM_RESOURCE)\n\t\tpci_std_update_resource(dev, resno);\n#ifdef CONFIG_PCI_IOV\n\telse if (resno >= PCI_IOV_RESOURCES && resno <= PCI_IOV_RESOURCE_END)\n\t\tpci_iov_update_resource(dev, resno);\n#endif\n}\n\nint pci_claim_resource(struct pci_dev *dev, int resource)\n{\n\tstruct resource *res = &dev->resource[resource];\n\tstruct resource *root, *conflict;\n\n\tif (res->flags & IORESOURCE_UNSET) {\n\t\tpci_info(dev, \"can't claim BAR %d %pR: no address assigned\\n\",\n\t\t\t resource, res);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (res->flags & IORESOURCE_ROM_SHADOW)\n\t\treturn 0;\n\n\troot = pci_find_parent_resource(dev, res);\n\tif (!root) {\n\t\tpci_info(dev, \"can't claim BAR %d %pR: no compatible bridge window\\n\",\n\t\t\t resource, res);\n\t\tres->flags |= IORESOURCE_UNSET;\n\t\treturn -EINVAL;\n\t}\n\n\tconflict = request_resource_conflict(root, res);\n\tif (conflict) {\n\t\tpci_info(dev, \"can't claim BAR %d %pR: address conflict with %s %pR\\n\",\n\t\t\t resource, res, conflict->name, conflict);\n\t\tres->flags |= IORESOURCE_UNSET;\n\t\treturn -EBUSY;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(pci_claim_resource);\n\nvoid pci_disable_bridge_window(struct pci_dev *dev)\n{\n\t \n\tpci_write_config_dword(dev, PCI_MEMORY_BASE, 0x0000fff0);\n\n\t \n\tpci_write_config_dword(dev, PCI_PREF_LIMIT_UPPER32, 0);\n\tpci_write_config_dword(dev, PCI_PREF_MEMORY_BASE, 0x0000fff0);\n\tpci_write_config_dword(dev, PCI_PREF_BASE_UPPER32, 0xffffffff);\n}\n\n \nresource_size_t __weak pcibios_retrieve_fw_addr(struct pci_dev *dev, int idx)\n{\n\treturn 0;\n}\n\nstatic int pci_revert_fw_address(struct resource *res, struct pci_dev *dev,\n\t\tint resno, resource_size_t size)\n{\n\tstruct resource *root, *conflict;\n\tresource_size_t fw_addr, start, end;\n\n\tfw_addr = pcibios_retrieve_fw_addr(dev, resno);\n\tif (!fw_addr)\n\t\treturn -ENOMEM;\n\n\tstart = res->start;\n\tend = res->end;\n\tres->start = fw_addr;\n\tres->end = res->start + size - 1;\n\tres->flags &= ~IORESOURCE_UNSET;\n\n\troot = pci_find_parent_resource(dev, res);\n\tif (!root) {\n\t\t \n\t\tif (pci_upstream_bridge(dev))\n\t\t\treturn -ENXIO;\n\n\t\t \n\t\tif (res->flags & IORESOURCE_IO)\n\t\t\troot = &ioport_resource;\n\t\telse\n\t\t\troot = &iomem_resource;\n\t}\n\n\tpci_info(dev, \"BAR %d: trying firmware assignment %pR\\n\",\n\t\t resno, res);\n\tconflict = request_resource_conflict(root, res);\n\tif (conflict) {\n\t\tpci_info(dev, \"BAR %d: %pR conflicts with %s %pR\\n\",\n\t\t\t resno, res, conflict->name, conflict);\n\t\tres->start = start;\n\t\tres->end = end;\n\t\tres->flags |= IORESOURCE_UNSET;\n\t\treturn -EBUSY;\n\t}\n\treturn 0;\n}\n\n \nresource_size_t __weak pcibios_align_resource(void *data,\n\t\t\t\t\t      const struct resource *res,\n\t\t\t\t\t      resource_size_t size,\n\t\t\t\t\t      resource_size_t align)\n{\n       return res->start;\n}\n\nstatic int __pci_assign_resource(struct pci_bus *bus, struct pci_dev *dev,\n\t\tint resno, resource_size_t size, resource_size_t align)\n{\n\tstruct resource *res = dev->resource + resno;\n\tresource_size_t min;\n\tint ret;\n\n\tmin = (res->flags & IORESOURCE_IO) ? PCIBIOS_MIN_IO : PCIBIOS_MIN_MEM;\n\n\t \n\tret = pci_bus_alloc_resource(bus, res, size, align, min,\n\t\t\t\t     IORESOURCE_PREFETCH | IORESOURCE_MEM_64,\n\t\t\t\t     pcibios_align_resource, dev);\n\tif (ret == 0)\n\t\treturn 0;\n\n\t \n\tif ((res->flags & (IORESOURCE_PREFETCH | IORESOURCE_MEM_64)) ==\n\t     (IORESOURCE_PREFETCH | IORESOURCE_MEM_64)) {\n\t\tret = pci_bus_alloc_resource(bus, res, size, align, min,\n\t\t\t\t\t     IORESOURCE_PREFETCH,\n\t\t\t\t\t     pcibios_align_resource, dev);\n\t\tif (ret == 0)\n\t\t\treturn 0;\n\t}\n\n\t \n\tif (res->flags & (IORESOURCE_PREFETCH | IORESOURCE_MEM_64))\n\t\tret = pci_bus_alloc_resource(bus, res, size, align, min, 0,\n\t\t\t\t\t     pcibios_align_resource, dev);\n\n\treturn ret;\n}\n\nstatic int _pci_assign_resource(struct pci_dev *dev, int resno,\n\t\t\t\tresource_size_t size, resource_size_t min_align)\n{\n\tstruct pci_bus *bus;\n\tint ret;\n\n\tbus = dev->bus;\n\twhile ((ret = __pci_assign_resource(bus, dev, resno, size, min_align))) {\n\t\tif (!bus->parent || !bus->self->transparent)\n\t\t\tbreak;\n\t\tbus = bus->parent;\n\t}\n\n\treturn ret;\n}\n\nint pci_assign_resource(struct pci_dev *dev, int resno)\n{\n\tstruct resource *res = dev->resource + resno;\n\tresource_size_t align, size;\n\tint ret;\n\n\tif (res->flags & IORESOURCE_PCI_FIXED)\n\t\treturn 0;\n\n\tres->flags |= IORESOURCE_UNSET;\n\talign = pci_resource_alignment(dev, res);\n\tif (!align) {\n\t\tpci_info(dev, \"BAR %d: can't assign %pR (bogus alignment)\\n\",\n\t\t\t resno, res);\n\t\treturn -EINVAL;\n\t}\n\n\tsize = resource_size(res);\n\tret = _pci_assign_resource(dev, resno, size, align);\n\n\t \n\tif (ret < 0) {\n\t\tpci_info(dev, \"BAR %d: no space for %pR\\n\", resno, res);\n\t\tret = pci_revert_fw_address(res, dev, resno, size);\n\t}\n\n\tif (ret < 0) {\n\t\tpci_info(dev, \"BAR %d: failed to assign %pR\\n\", resno, res);\n\t\treturn ret;\n\t}\n\n\tres->flags &= ~IORESOURCE_UNSET;\n\tres->flags &= ~IORESOURCE_STARTALIGN;\n\tpci_info(dev, \"BAR %d: assigned %pR\\n\", resno, res);\n\tif (resno < PCI_BRIDGE_RESOURCES)\n\t\tpci_update_resource(dev, resno);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(pci_assign_resource);\n\nint pci_reassign_resource(struct pci_dev *dev, int resno, resource_size_t addsize,\n\t\t\tresource_size_t min_align)\n{\n\tstruct resource *res = dev->resource + resno;\n\tunsigned long flags;\n\tresource_size_t new_size;\n\tint ret;\n\n\tif (res->flags & IORESOURCE_PCI_FIXED)\n\t\treturn 0;\n\n\tflags = res->flags;\n\tres->flags |= IORESOURCE_UNSET;\n\tif (!res->parent) {\n\t\tpci_info(dev, \"BAR %d: can't reassign an unassigned resource %pR\\n\",\n\t\t\t resno, res);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tnew_size = resource_size(res) + addsize;\n\tret = _pci_assign_resource(dev, resno, new_size, min_align);\n\tif (ret) {\n\t\tres->flags = flags;\n\t\tpci_info(dev, \"BAR %d: %pR (failed to expand by %#llx)\\n\",\n\t\t\t resno, res, (unsigned long long) addsize);\n\t\treturn ret;\n\t}\n\n\tres->flags &= ~IORESOURCE_UNSET;\n\tres->flags &= ~IORESOURCE_STARTALIGN;\n\tpci_info(dev, \"BAR %d: reassigned %pR (expanded by %#llx)\\n\",\n\t\t resno, res, (unsigned long long) addsize);\n\tif (resno < PCI_BRIDGE_RESOURCES)\n\t\tpci_update_resource(dev, resno);\n\n\treturn 0;\n}\n\nvoid pci_release_resource(struct pci_dev *dev, int resno)\n{\n\tstruct resource *res = dev->resource + resno;\n\n\tpci_info(dev, \"BAR %d: releasing %pR\\n\", resno, res);\n\n\tif (!res->parent)\n\t\treturn;\n\n\trelease_resource(res);\n\tres->end = resource_size(res) - 1;\n\tres->start = 0;\n\tres->flags |= IORESOURCE_UNSET;\n}\nEXPORT_SYMBOL(pci_release_resource);\n\nint pci_resize_resource(struct pci_dev *dev, int resno, int size)\n{\n\tstruct resource *res = dev->resource + resno;\n\tstruct pci_host_bridge *host;\n\tint old, ret;\n\tu32 sizes;\n\tu16 cmd;\n\n\t \n\thost = pci_find_host_bridge(dev->bus);\n\tif (host->preserve_config)\n\t\treturn -ENOTSUPP;\n\n\t \n\tif (!(res->flags & IORESOURCE_UNSET))\n\t\treturn -EBUSY;\n\n\tpci_read_config_word(dev, PCI_COMMAND, &cmd);\n\tif (cmd & PCI_COMMAND_MEMORY)\n\t\treturn -EBUSY;\n\n\tsizes = pci_rebar_get_possible_sizes(dev, resno);\n\tif (!sizes)\n\t\treturn -ENOTSUPP;\n\n\tif (!(sizes & BIT(size)))\n\t\treturn -EINVAL;\n\n\told = pci_rebar_get_current_size(dev, resno);\n\tif (old < 0)\n\t\treturn old;\n\n\tret = pci_rebar_set_size(dev, resno, size);\n\tif (ret)\n\t\treturn ret;\n\n\tres->end = res->start + pci_rebar_size_to_bytes(size) - 1;\n\n\t \n\tif (dev->bus->self) {\n\t\tret = pci_reassign_bridge_resources(dev->bus->self, res->flags);\n\t\tif (ret)\n\t\t\tgoto error_resize;\n\t}\n\treturn 0;\n\nerror_resize:\n\tpci_rebar_set_size(dev, resno, old);\n\tres->end = res->start + pci_rebar_size_to_bytes(old) - 1;\n\treturn ret;\n}\nEXPORT_SYMBOL(pci_resize_resource);\n\nint pci_enable_resources(struct pci_dev *dev, int mask)\n{\n\tu16 cmd, old_cmd;\n\tint i;\n\tstruct resource *r;\n\n\tpci_read_config_word(dev, PCI_COMMAND, &cmd);\n\told_cmd = cmd;\n\n\tpci_dev_for_each_resource(dev, r, i) {\n\t\tif (!(mask & (1 << i)))\n\t\t\tcontinue;\n\n\t\tif (!(r->flags & (IORESOURCE_IO | IORESOURCE_MEM)))\n\t\t\tcontinue;\n\t\tif ((i == PCI_ROM_RESOURCE) &&\n\t\t\t\t(!(r->flags & IORESOURCE_ROM_ENABLE)))\n\t\t\tcontinue;\n\n\t\tif (r->flags & IORESOURCE_UNSET) {\n\t\t\tpci_err(dev, \"can't enable device: BAR %d %pR not assigned\\n\",\n\t\t\t\ti, r);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (!r->parent) {\n\t\t\tpci_err(dev, \"can't enable device: BAR %d %pR not claimed\\n\",\n\t\t\t\ti, r);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (r->flags & IORESOURCE_IO)\n\t\t\tcmd |= PCI_COMMAND_IO;\n\t\tif (r->flags & IORESOURCE_MEM)\n\t\t\tcmd |= PCI_COMMAND_MEMORY;\n\t}\n\n\tif (cmd != old_cmd) {\n\t\tpci_info(dev, \"enabling device (%04x -> %04x)\\n\", old_cmd, cmd);\n\t\tpci_write_config_word(dev, PCI_COMMAND, cmd);\n\t}\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}