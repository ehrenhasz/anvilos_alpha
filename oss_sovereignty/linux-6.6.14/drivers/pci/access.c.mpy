{
  "module_name": "access.c",
  "hash_id": "17ae575a26291cf9e2876d2358d9ee123b631caed1150f34b6558b12d6b980f6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/access.c",
  "human_readable_source": "\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/ioport.h>\n#include <linux/wait.h>\n\n#include \"pci.h\"\n\n \n\nDEFINE_RAW_SPINLOCK(pci_lock);\n\n \n\n#define PCI_byte_BAD 0\n#define PCI_word_BAD (pos & 1)\n#define PCI_dword_BAD (pos & 3)\n\n#ifdef CONFIG_PCI_LOCKLESS_CONFIG\n# define pci_lock_config(f)\tdo { (void)(f); } while (0)\n# define pci_unlock_config(f)\tdo { (void)(f); } while (0)\n#else\n# define pci_lock_config(f)\traw_spin_lock_irqsave(&pci_lock, f)\n# define pci_unlock_config(f)\traw_spin_unlock_irqrestore(&pci_lock, f)\n#endif\n\n#define PCI_OP_READ(size, type, len) \\\nint noinline pci_bus_read_config_##size \\\n\t(struct pci_bus *bus, unsigned int devfn, int pos, type *value)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tint res;\t\t\t\t\t\t\t\\\n\tunsigned long flags;\t\t\t\t\t\t\\\n\tu32 data = 0;\t\t\t\t\t\t\t\\\n\tif (PCI_##size##_BAD) return PCIBIOS_BAD_REGISTER_NUMBER;\t\\\n\tpci_lock_config(flags);\t\t\t\t\t\t\\\n\tres = bus->ops->read(bus, devfn, pos, len, &data);\t\t\\\n\tif (res)\t\t\t\t\t\t\t\\\n\t\tPCI_SET_ERROR_RESPONSE(value);\t\t\t\t\\\n\telse\t\t\t\t\t\t\t\t\\\n\t\t*value = (type)data;\t\t\t\t\t\\\n\tpci_unlock_config(flags);\t\t\t\t\t\\\n\treturn res;\t\t\t\t\t\t\t\\\n}\n\n#define PCI_OP_WRITE(size, type, len) \\\nint noinline pci_bus_write_config_##size \\\n\t(struct pci_bus *bus, unsigned int devfn, int pos, type value)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tint res;\t\t\t\t\t\t\t\\\n\tunsigned long flags;\t\t\t\t\t\t\\\n\tif (PCI_##size##_BAD) return PCIBIOS_BAD_REGISTER_NUMBER;\t\\\n\tpci_lock_config(flags);\t\t\t\t\t\t\\\n\tres = bus->ops->write(bus, devfn, pos, len, value);\t\t\\\n\tpci_unlock_config(flags);\t\t\t\t\t\\\n\treturn res;\t\t\t\t\t\t\t\\\n}\n\nPCI_OP_READ(byte, u8, 1)\nPCI_OP_READ(word, u16, 2)\nPCI_OP_READ(dword, u32, 4)\nPCI_OP_WRITE(byte, u8, 1)\nPCI_OP_WRITE(word, u16, 2)\nPCI_OP_WRITE(dword, u32, 4)\n\nEXPORT_SYMBOL(pci_bus_read_config_byte);\nEXPORT_SYMBOL(pci_bus_read_config_word);\nEXPORT_SYMBOL(pci_bus_read_config_dword);\nEXPORT_SYMBOL(pci_bus_write_config_byte);\nEXPORT_SYMBOL(pci_bus_write_config_word);\nEXPORT_SYMBOL(pci_bus_write_config_dword);\n\nint pci_generic_config_read(struct pci_bus *bus, unsigned int devfn,\n\t\t\t    int where, int size, u32 *val)\n{\n\tvoid __iomem *addr;\n\n\taddr = bus->ops->map_bus(bus, devfn, where);\n\tif (!addr)\n\t\treturn PCIBIOS_DEVICE_NOT_FOUND;\n\n\tif (size == 1)\n\t\t*val = readb(addr);\n\telse if (size == 2)\n\t\t*val = readw(addr);\n\telse\n\t\t*val = readl(addr);\n\n\treturn PCIBIOS_SUCCESSFUL;\n}\nEXPORT_SYMBOL_GPL(pci_generic_config_read);\n\nint pci_generic_config_write(struct pci_bus *bus, unsigned int devfn,\n\t\t\t     int where, int size, u32 val)\n{\n\tvoid __iomem *addr;\n\n\taddr = bus->ops->map_bus(bus, devfn, where);\n\tif (!addr)\n\t\treturn PCIBIOS_DEVICE_NOT_FOUND;\n\n\tif (size == 1)\n\t\twriteb(val, addr);\n\telse if (size == 2)\n\t\twritew(val, addr);\n\telse\n\t\twritel(val, addr);\n\n\treturn PCIBIOS_SUCCESSFUL;\n}\nEXPORT_SYMBOL_GPL(pci_generic_config_write);\n\nint pci_generic_config_read32(struct pci_bus *bus, unsigned int devfn,\n\t\t\t      int where, int size, u32 *val)\n{\n\tvoid __iomem *addr;\n\n\taddr = bus->ops->map_bus(bus, devfn, where & ~0x3);\n\tif (!addr)\n\t\treturn PCIBIOS_DEVICE_NOT_FOUND;\n\n\t*val = readl(addr);\n\n\tif (size <= 2)\n\t\t*val = (*val >> (8 * (where & 3))) & ((1 << (size * 8)) - 1);\n\n\treturn PCIBIOS_SUCCESSFUL;\n}\nEXPORT_SYMBOL_GPL(pci_generic_config_read32);\n\nint pci_generic_config_write32(struct pci_bus *bus, unsigned int devfn,\n\t\t\t       int where, int size, u32 val)\n{\n\tvoid __iomem *addr;\n\tu32 mask, tmp;\n\n\taddr = bus->ops->map_bus(bus, devfn, where & ~0x3);\n\tif (!addr)\n\t\treturn PCIBIOS_DEVICE_NOT_FOUND;\n\n\tif (size == 4) {\n\t\twritel(val, addr);\n\t\treturn PCIBIOS_SUCCESSFUL;\n\t}\n\n\t \n\tif (!bus->unsafe_warn) {\n\t\tdev_warn(&bus->dev, \"%d-byte config write to %04x:%02x:%02x.%d offset %#x may corrupt adjacent RW1C bits\\n\",\n\t\t\t size, pci_domain_nr(bus), bus->number,\n\t\t\t PCI_SLOT(devfn), PCI_FUNC(devfn), where);\n\t\tbus->unsafe_warn = 1;\n\t}\n\n\tmask = ~(((1 << (size * 8)) - 1) << ((where & 0x3) * 8));\n\ttmp = readl(addr) & mask;\n\ttmp |= val << ((where & 0x3) * 8);\n\twritel(tmp, addr);\n\n\treturn PCIBIOS_SUCCESSFUL;\n}\nEXPORT_SYMBOL_GPL(pci_generic_config_write32);\n\n \nstruct pci_ops *pci_bus_set_ops(struct pci_bus *bus, struct pci_ops *ops)\n{\n\tstruct pci_ops *old_ops;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&pci_lock, flags);\n\told_ops = bus->ops;\n\tbus->ops = ops;\n\traw_spin_unlock_irqrestore(&pci_lock, flags);\n\treturn old_ops;\n}\nEXPORT_SYMBOL(pci_bus_set_ops);\n\n \nstatic DECLARE_WAIT_QUEUE_HEAD(pci_cfg_wait);\n\nstatic noinline void pci_wait_cfg(struct pci_dev *dev)\n\t__must_hold(&pci_lock)\n{\n\tdo {\n\t\traw_spin_unlock_irq(&pci_lock);\n\t\twait_event(pci_cfg_wait, !dev->block_cfg_access);\n\t\traw_spin_lock_irq(&pci_lock);\n\t} while (dev->block_cfg_access);\n}\n\n \n#define PCI_USER_READ_CONFIG(size, type)\t\t\t\t\t\\\nint pci_user_read_config_##size\t\t\t\t\t\t\\\n\t(struct pci_dev *dev, int pos, type *val)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tint ret = PCIBIOS_SUCCESSFUL;\t\t\t\t\t\\\n\tu32 data = -1;\t\t\t\t\t\t\t\\\n\tif (PCI_##size##_BAD)\t\t\t\t\t\t\\\n\t\treturn -EINVAL;\t\t\t\t\t\t\\\n\traw_spin_lock_irq(&pci_lock);\t\t\t\t\\\n\tif (unlikely(dev->block_cfg_access))\t\t\t\t\\\n\t\tpci_wait_cfg(dev);\t\t\t\t\t\\\n\tret = dev->bus->ops->read(dev->bus, dev->devfn,\t\t\t\\\n\t\t\t\t\tpos, sizeof(type), &data);\t\\\n\traw_spin_unlock_irq(&pci_lock);\t\t\t\t\\\n\tif (ret)\t\t\t\t\t\t\t\\\n\t\tPCI_SET_ERROR_RESPONSE(val);\t\t\t\t\\\n\telse\t\t\t\t\t\t\t\t\\\n\t\t*val = (type)data;\t\t\t\t\t\\\n\treturn pcibios_err_to_errno(ret);\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nEXPORT_SYMBOL_GPL(pci_user_read_config_##size);\n\n \n#define PCI_USER_WRITE_CONFIG(size, type)\t\t\t\t\\\nint pci_user_write_config_##size\t\t\t\t\t\\\n\t(struct pci_dev *dev, int pos, type val)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tint ret = PCIBIOS_SUCCESSFUL;\t\t\t\t\t\\\n\tif (PCI_##size##_BAD)\t\t\t\t\t\t\\\n\t\treturn -EINVAL;\t\t\t\t\t\t\\\n\traw_spin_lock_irq(&pci_lock);\t\t\t\t\\\n\tif (unlikely(dev->block_cfg_access))\t\t\t\t\\\n\t\tpci_wait_cfg(dev);\t\t\t\t\t\\\n\tret = dev->bus->ops->write(dev->bus, dev->devfn,\t\t\\\n\t\t\t\t\tpos, sizeof(type), val);\t\\\n\traw_spin_unlock_irq(&pci_lock);\t\t\t\t\\\n\treturn pcibios_err_to_errno(ret);\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nEXPORT_SYMBOL_GPL(pci_user_write_config_##size);\n\nPCI_USER_READ_CONFIG(byte, u8)\nPCI_USER_READ_CONFIG(word, u16)\nPCI_USER_READ_CONFIG(dword, u32)\nPCI_USER_WRITE_CONFIG(byte, u8)\nPCI_USER_WRITE_CONFIG(word, u16)\nPCI_USER_WRITE_CONFIG(dword, u32)\n\n \nvoid pci_cfg_access_lock(struct pci_dev *dev)\n{\n\tmight_sleep();\n\n\traw_spin_lock_irq(&pci_lock);\n\tif (dev->block_cfg_access)\n\t\tpci_wait_cfg(dev);\n\tdev->block_cfg_access = 1;\n\traw_spin_unlock_irq(&pci_lock);\n}\nEXPORT_SYMBOL_GPL(pci_cfg_access_lock);\n\n \nbool pci_cfg_access_trylock(struct pci_dev *dev)\n{\n\tunsigned long flags;\n\tbool locked = true;\n\n\traw_spin_lock_irqsave(&pci_lock, flags);\n\tif (dev->block_cfg_access)\n\t\tlocked = false;\n\telse\n\t\tdev->block_cfg_access = 1;\n\traw_spin_unlock_irqrestore(&pci_lock, flags);\n\n\treturn locked;\n}\nEXPORT_SYMBOL_GPL(pci_cfg_access_trylock);\n\n \nvoid pci_cfg_access_unlock(struct pci_dev *dev)\n{\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&pci_lock, flags);\n\n\t \n\tWARN_ON(!dev->block_cfg_access);\n\n\tdev->block_cfg_access = 0;\n\traw_spin_unlock_irqrestore(&pci_lock, flags);\n\n\twake_up_all(&pci_cfg_wait);\n}\nEXPORT_SYMBOL_GPL(pci_cfg_access_unlock);\n\nstatic inline int pcie_cap_version(const struct pci_dev *dev)\n{\n\treturn pcie_caps_reg(dev) & PCI_EXP_FLAGS_VERS;\n}\n\nbool pcie_cap_has_lnkctl(const struct pci_dev *dev)\n{\n\tint type = pci_pcie_type(dev);\n\n\treturn type == PCI_EXP_TYPE_ENDPOINT ||\n\t       type == PCI_EXP_TYPE_LEG_END ||\n\t       type == PCI_EXP_TYPE_ROOT_PORT ||\n\t       type == PCI_EXP_TYPE_UPSTREAM ||\n\t       type == PCI_EXP_TYPE_DOWNSTREAM ||\n\t       type == PCI_EXP_TYPE_PCI_BRIDGE ||\n\t       type == PCI_EXP_TYPE_PCIE_BRIDGE;\n}\n\nbool pcie_cap_has_lnkctl2(const struct pci_dev *dev)\n{\n\treturn pcie_cap_has_lnkctl(dev) && pcie_cap_version(dev) > 1;\n}\n\nstatic inline bool pcie_cap_has_sltctl(const struct pci_dev *dev)\n{\n\treturn pcie_downstream_port(dev) &&\n\t       pcie_caps_reg(dev) & PCI_EXP_FLAGS_SLOT;\n}\n\nbool pcie_cap_has_rtctl(const struct pci_dev *dev)\n{\n\tint type = pci_pcie_type(dev);\n\n\treturn type == PCI_EXP_TYPE_ROOT_PORT ||\n\t       type == PCI_EXP_TYPE_RC_EC;\n}\n\nstatic bool pcie_capability_reg_implemented(struct pci_dev *dev, int pos)\n{\n\tif (!pci_is_pcie(dev))\n\t\treturn false;\n\n\tswitch (pos) {\n\tcase PCI_EXP_FLAGS:\n\t\treturn true;\n\tcase PCI_EXP_DEVCAP:\n\tcase PCI_EXP_DEVCTL:\n\tcase PCI_EXP_DEVSTA:\n\t\treturn true;\n\tcase PCI_EXP_LNKCAP:\n\tcase PCI_EXP_LNKCTL:\n\tcase PCI_EXP_LNKSTA:\n\t\treturn pcie_cap_has_lnkctl(dev);\n\tcase PCI_EXP_SLTCAP:\n\tcase PCI_EXP_SLTCTL:\n\tcase PCI_EXP_SLTSTA:\n\t\treturn pcie_cap_has_sltctl(dev);\n\tcase PCI_EXP_RTCTL:\n\tcase PCI_EXP_RTCAP:\n\tcase PCI_EXP_RTSTA:\n\t\treturn pcie_cap_has_rtctl(dev);\n\tcase PCI_EXP_DEVCAP2:\n\tcase PCI_EXP_DEVCTL2:\n\t\treturn pcie_cap_version(dev) > 1;\n\tcase PCI_EXP_LNKCAP2:\n\tcase PCI_EXP_LNKCTL2:\n\tcase PCI_EXP_LNKSTA2:\n\t\treturn pcie_cap_has_lnkctl2(dev);\n\tdefault:\n\t\treturn false;\n\t}\n}\n\n \nint pcie_capability_read_word(struct pci_dev *dev, int pos, u16 *val)\n{\n\tint ret;\n\n\t*val = 0;\n\tif (pos & 1)\n\t\treturn PCIBIOS_BAD_REGISTER_NUMBER;\n\n\tif (pcie_capability_reg_implemented(dev, pos)) {\n\t\tret = pci_read_config_word(dev, pci_pcie_cap(dev) + pos, val);\n\t\t \n\t\tif (ret)\n\t\t\t*val = 0;\n\t\treturn ret;\n\t}\n\n\t \n\tif (pci_is_pcie(dev) && pcie_downstream_port(dev) &&\n\t    pos == PCI_EXP_SLTSTA)\n\t\t*val = PCI_EXP_SLTSTA_PDS;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(pcie_capability_read_word);\n\nint pcie_capability_read_dword(struct pci_dev *dev, int pos, u32 *val)\n{\n\tint ret;\n\n\t*val = 0;\n\tif (pos & 3)\n\t\treturn PCIBIOS_BAD_REGISTER_NUMBER;\n\n\tif (pcie_capability_reg_implemented(dev, pos)) {\n\t\tret = pci_read_config_dword(dev, pci_pcie_cap(dev) + pos, val);\n\t\t \n\t\tif (ret)\n\t\t\t*val = 0;\n\t\treturn ret;\n\t}\n\n\tif (pci_is_pcie(dev) && pcie_downstream_port(dev) &&\n\t    pos == PCI_EXP_SLTSTA)\n\t\t*val = PCI_EXP_SLTSTA_PDS;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(pcie_capability_read_dword);\n\nint pcie_capability_write_word(struct pci_dev *dev, int pos, u16 val)\n{\n\tif (pos & 1)\n\t\treturn PCIBIOS_BAD_REGISTER_NUMBER;\n\n\tif (!pcie_capability_reg_implemented(dev, pos))\n\t\treturn 0;\n\n\treturn pci_write_config_word(dev, pci_pcie_cap(dev) + pos, val);\n}\nEXPORT_SYMBOL(pcie_capability_write_word);\n\nint pcie_capability_write_dword(struct pci_dev *dev, int pos, u32 val)\n{\n\tif (pos & 3)\n\t\treturn PCIBIOS_BAD_REGISTER_NUMBER;\n\n\tif (!pcie_capability_reg_implemented(dev, pos))\n\t\treturn 0;\n\n\treturn pci_write_config_dword(dev, pci_pcie_cap(dev) + pos, val);\n}\nEXPORT_SYMBOL(pcie_capability_write_dword);\n\nint pcie_capability_clear_and_set_word_unlocked(struct pci_dev *dev, int pos,\n\t\t\t\t\t\tu16 clear, u16 set)\n{\n\tint ret;\n\tu16 val;\n\n\tret = pcie_capability_read_word(dev, pos, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tval &= ~clear;\n\tval |= set;\n\treturn pcie_capability_write_word(dev, pos, val);\n}\nEXPORT_SYMBOL(pcie_capability_clear_and_set_word_unlocked);\n\nint pcie_capability_clear_and_set_word_locked(struct pci_dev *dev, int pos,\n\t\t\t\t\t      u16 clear, u16 set)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&dev->pcie_cap_lock, flags);\n\tret = pcie_capability_clear_and_set_word_unlocked(dev, pos, clear, set);\n\tspin_unlock_irqrestore(&dev->pcie_cap_lock, flags);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(pcie_capability_clear_and_set_word_locked);\n\nint pcie_capability_clear_and_set_dword(struct pci_dev *dev, int pos,\n\t\t\t\t\tu32 clear, u32 set)\n{\n\tint ret;\n\tu32 val;\n\n\tret = pcie_capability_read_dword(dev, pos, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tval &= ~clear;\n\tval |= set;\n\treturn pcie_capability_write_dword(dev, pos, val);\n}\nEXPORT_SYMBOL(pcie_capability_clear_and_set_dword);\n\nint pci_read_config_byte(const struct pci_dev *dev, int where, u8 *val)\n{\n\tif (pci_dev_is_disconnected(dev)) {\n\t\tPCI_SET_ERROR_RESPONSE(val);\n\t\treturn PCIBIOS_DEVICE_NOT_FOUND;\n\t}\n\treturn pci_bus_read_config_byte(dev->bus, dev->devfn, where, val);\n}\nEXPORT_SYMBOL(pci_read_config_byte);\n\nint pci_read_config_word(const struct pci_dev *dev, int where, u16 *val)\n{\n\tif (pci_dev_is_disconnected(dev)) {\n\t\tPCI_SET_ERROR_RESPONSE(val);\n\t\treturn PCIBIOS_DEVICE_NOT_FOUND;\n\t}\n\treturn pci_bus_read_config_word(dev->bus, dev->devfn, where, val);\n}\nEXPORT_SYMBOL(pci_read_config_word);\n\nint pci_read_config_dword(const struct pci_dev *dev, int where,\n\t\t\t\t\tu32 *val)\n{\n\tif (pci_dev_is_disconnected(dev)) {\n\t\tPCI_SET_ERROR_RESPONSE(val);\n\t\treturn PCIBIOS_DEVICE_NOT_FOUND;\n\t}\n\treturn pci_bus_read_config_dword(dev->bus, dev->devfn, where, val);\n}\nEXPORT_SYMBOL(pci_read_config_dword);\n\nint pci_write_config_byte(const struct pci_dev *dev, int where, u8 val)\n{\n\tif (pci_dev_is_disconnected(dev))\n\t\treturn PCIBIOS_DEVICE_NOT_FOUND;\n\treturn pci_bus_write_config_byte(dev->bus, dev->devfn, where, val);\n}\nEXPORT_SYMBOL(pci_write_config_byte);\n\nint pci_write_config_word(const struct pci_dev *dev, int where, u16 val)\n{\n\tif (pci_dev_is_disconnected(dev))\n\t\treturn PCIBIOS_DEVICE_NOT_FOUND;\n\treturn pci_bus_write_config_word(dev->bus, dev->devfn, where, val);\n}\nEXPORT_SYMBOL(pci_write_config_word);\n\nint pci_write_config_dword(const struct pci_dev *dev, int where,\n\t\t\t\t\t u32 val)\n{\n\tif (pci_dev_is_disconnected(dev))\n\t\treturn PCIBIOS_DEVICE_NOT_FOUND;\n\treturn pci_bus_write_config_dword(dev->bus, dev->devfn, where, val);\n}\nEXPORT_SYMBOL(pci_write_config_dword);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}