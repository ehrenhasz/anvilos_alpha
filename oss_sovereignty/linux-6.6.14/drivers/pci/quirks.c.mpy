{
  "module_name": "quirks.c",
  "hash_id": "5dbc065155eeaf6d56bb1a44d20c0dd48fe19c55d12311f1627135c8ceaa0662",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/quirks.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/pci.h>\n#include <linux/isa-dma.h>  \n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/acpi.h>\n#include <linux/dmi.h>\n#include <linux/ioport.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/mm.h>\n#include <linux/nvme.h>\n#include <linux/platform_data/x86/apple.h>\n#include <linux/pm_runtime.h>\n#include <linux/suspend.h>\n#include <linux/switchtec.h>\n#include \"pci.h\"\n\n \nbool pcie_failed_link_retrain(struct pci_dev *dev)\n{\n\tstatic const struct pci_device_id ids[] = {\n\t\t{ PCI_VDEVICE(ASMEDIA, 0x2824) },  \n\t\t{}\n\t};\n\tu16 lnksta, lnkctl2;\n\n\tif (!pci_is_pcie(dev) || !pcie_downstream_port(dev) ||\n\t    !pcie_cap_has_lnkctl2(dev) || !dev->link_active_reporting)\n\t\treturn false;\n\n\tpcie_capability_read_word(dev, PCI_EXP_LNKCTL2, &lnkctl2);\n\tpcie_capability_read_word(dev, PCI_EXP_LNKSTA, &lnksta);\n\tif ((lnksta & (PCI_EXP_LNKSTA_LBMS | PCI_EXP_LNKSTA_DLLLA)) ==\n\t    PCI_EXP_LNKSTA_LBMS) {\n\t\tpci_info(dev, \"broken device, retraining non-functional downstream link at 2.5GT/s\\n\");\n\n\t\tlnkctl2 &= ~PCI_EXP_LNKCTL2_TLS;\n\t\tlnkctl2 |= PCI_EXP_LNKCTL2_TLS_2_5GT;\n\t\tpcie_capability_write_word(dev, PCI_EXP_LNKCTL2, lnkctl2);\n\n\t\tif (pcie_retrain_link(dev, false)) {\n\t\t\tpci_info(dev, \"retraining failed\\n\");\n\t\t\treturn false;\n\t\t}\n\n\t\tpcie_capability_read_word(dev, PCI_EXP_LNKSTA, &lnksta);\n\t}\n\n\tif ((lnksta & PCI_EXP_LNKSTA_DLLLA) &&\n\t    (lnkctl2 & PCI_EXP_LNKCTL2_TLS) == PCI_EXP_LNKCTL2_TLS_2_5GT &&\n\t    pci_match_id(ids, dev)) {\n\t\tu32 lnkcap;\n\n\t\tpci_info(dev, \"removing 2.5GT/s downstream link speed restriction\\n\");\n\t\tpcie_capability_read_dword(dev, PCI_EXP_LNKCAP, &lnkcap);\n\t\tlnkctl2 &= ~PCI_EXP_LNKCTL2_TLS;\n\t\tlnkctl2 |= lnkcap & PCI_EXP_LNKCAP_SLS;\n\t\tpcie_capability_write_word(dev, PCI_EXP_LNKCTL2, lnkctl2);\n\n\t\tif (pcie_retrain_link(dev, false)) {\n\t\t\tpci_info(dev, \"retraining failed\\n\");\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nstatic ktime_t fixup_debug_start(struct pci_dev *dev,\n\t\t\t\t void (*fn)(struct pci_dev *dev))\n{\n\tif (initcall_debug)\n\t\tpci_info(dev, \"calling  %pS @ %i\\n\", fn, task_pid_nr(current));\n\n\treturn ktime_get();\n}\n\nstatic void fixup_debug_report(struct pci_dev *dev, ktime_t calltime,\n\t\t\t       void (*fn)(struct pci_dev *dev))\n{\n\tktime_t delta, rettime;\n\tunsigned long long duration;\n\n\trettime = ktime_get();\n\tdelta = ktime_sub(rettime, calltime);\n\tduration = (unsigned long long) ktime_to_ns(delta) >> 10;\n\tif (initcall_debug || duration > 10000)\n\t\tpci_info(dev, \"%pS took %lld usecs\\n\", fn, duration);\n}\n\nstatic void pci_do_fixups(struct pci_dev *dev, struct pci_fixup *f,\n\t\t\t  struct pci_fixup *end)\n{\n\tktime_t calltime;\n\n\tfor (; f < end; f++)\n\t\tif ((f->class == (u32) (dev->class >> f->class_shift) ||\n\t\t     f->class == (u32) PCI_ANY_ID) &&\n\t\t    (f->vendor == dev->vendor ||\n\t\t     f->vendor == (u16) PCI_ANY_ID) &&\n\t\t    (f->device == dev->device ||\n\t\t     f->device == (u16) PCI_ANY_ID)) {\n\t\t\tvoid (*hook)(struct pci_dev *dev);\n#ifdef CONFIG_HAVE_ARCH_PREL32_RELOCATIONS\n\t\t\thook = offset_to_ptr(&f->hook_offset);\n#else\n\t\t\thook = f->hook;\n#endif\n\t\t\tcalltime = fixup_debug_start(dev, hook);\n\t\t\thook(dev);\n\t\t\tfixup_debug_report(dev, calltime, hook);\n\t\t}\n}\n\nextern struct pci_fixup __start_pci_fixups_early[];\nextern struct pci_fixup __end_pci_fixups_early[];\nextern struct pci_fixup __start_pci_fixups_header[];\nextern struct pci_fixup __end_pci_fixups_header[];\nextern struct pci_fixup __start_pci_fixups_final[];\nextern struct pci_fixup __end_pci_fixups_final[];\nextern struct pci_fixup __start_pci_fixups_enable[];\nextern struct pci_fixup __end_pci_fixups_enable[];\nextern struct pci_fixup __start_pci_fixups_resume[];\nextern struct pci_fixup __end_pci_fixups_resume[];\nextern struct pci_fixup __start_pci_fixups_resume_early[];\nextern struct pci_fixup __end_pci_fixups_resume_early[];\nextern struct pci_fixup __start_pci_fixups_suspend[];\nextern struct pci_fixup __end_pci_fixups_suspend[];\nextern struct pci_fixup __start_pci_fixups_suspend_late[];\nextern struct pci_fixup __end_pci_fixups_suspend_late[];\n\nstatic bool pci_apply_fixup_final_quirks;\n\nvoid pci_fixup_device(enum pci_fixup_pass pass, struct pci_dev *dev)\n{\n\tstruct pci_fixup *start, *end;\n\n\tswitch (pass) {\n\tcase pci_fixup_early:\n\t\tstart = __start_pci_fixups_early;\n\t\tend = __end_pci_fixups_early;\n\t\tbreak;\n\n\tcase pci_fixup_header:\n\t\tstart = __start_pci_fixups_header;\n\t\tend = __end_pci_fixups_header;\n\t\tbreak;\n\n\tcase pci_fixup_final:\n\t\tif (!pci_apply_fixup_final_quirks)\n\t\t\treturn;\n\t\tstart = __start_pci_fixups_final;\n\t\tend = __end_pci_fixups_final;\n\t\tbreak;\n\n\tcase pci_fixup_enable:\n\t\tstart = __start_pci_fixups_enable;\n\t\tend = __end_pci_fixups_enable;\n\t\tbreak;\n\n\tcase pci_fixup_resume:\n\t\tstart = __start_pci_fixups_resume;\n\t\tend = __end_pci_fixups_resume;\n\t\tbreak;\n\n\tcase pci_fixup_resume_early:\n\t\tstart = __start_pci_fixups_resume_early;\n\t\tend = __end_pci_fixups_resume_early;\n\t\tbreak;\n\n\tcase pci_fixup_suspend:\n\t\tstart = __start_pci_fixups_suspend;\n\t\tend = __end_pci_fixups_suspend;\n\t\tbreak;\n\n\tcase pci_fixup_suspend_late:\n\t\tstart = __start_pci_fixups_suspend_late;\n\t\tend = __end_pci_fixups_suspend_late;\n\t\tbreak;\n\n\tdefault:\n\t\t \n\t\treturn;\n\t}\n\tpci_do_fixups(dev, start, end);\n}\nEXPORT_SYMBOL(pci_fixup_device);\n\nstatic int __init pci_apply_final_quirks(void)\n{\n\tstruct pci_dev *dev = NULL;\n\tu8 cls = 0;\n\tu8 tmp;\n\n\tif (pci_cache_line_size)\n\t\tpr_info(\"PCI: CLS %u bytes\\n\", pci_cache_line_size << 2);\n\n\tpci_apply_fixup_final_quirks = true;\n\tfor_each_pci_dev(dev) {\n\t\tpci_fixup_device(pci_fixup_final, dev);\n\t\t \n\t\tif (!pci_cache_line_size) {\n\t\t\tpci_read_config_byte(dev, PCI_CACHE_LINE_SIZE, &tmp);\n\t\t\tif (!cls)\n\t\t\t\tcls = tmp;\n\t\t\tif (!tmp || cls == tmp)\n\t\t\t\tcontinue;\n\n\t\t\tpci_info(dev, \"CLS mismatch (%u != %u), using %u bytes\\n\",\n\t\t\t         cls << 2, tmp << 2,\n\t\t\t\t pci_dfl_cache_line_size << 2);\n\t\t\tpci_cache_line_size = pci_dfl_cache_line_size;\n\t\t}\n\t}\n\n\tif (!pci_cache_line_size) {\n\t\tpr_info(\"PCI: CLS %u bytes, default %u\\n\", cls << 2,\n\t\t\tpci_dfl_cache_line_size << 2);\n\t\tpci_cache_line_size = cls ? cls : pci_dfl_cache_line_size;\n\t}\n\n\treturn 0;\n}\nfs_initcall_sync(pci_apply_final_quirks);\n\n \nstatic void quirk_mmio_always_on(struct pci_dev *dev)\n{\n\tdev->mmio_always_on = 1;\n}\nDECLARE_PCI_FIXUP_CLASS_EARLY(PCI_ANY_ID, PCI_ANY_ID,\n\t\t\t\tPCI_CLASS_BRIDGE_HOST, 8, quirk_mmio_always_on);\n\n \nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_MELLANOX, PCI_DEVICE_ID_MELLANOX_TAVOR, pci_disable_parity);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_MELLANOX, PCI_DEVICE_ID_MELLANOX_TAVOR_BRIDGE, pci_disable_parity);\n\n \nstatic void quirk_passive_release(struct pci_dev *dev)\n{\n\tstruct pci_dev *d = NULL;\n\tunsigned char dlc;\n\n\t \n\twhile ((d = pci_get_device(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82371SB_0, d))) {\n\t\tpci_read_config_byte(d, 0x82, &dlc);\n\t\tif (!(dlc & 1<<1)) {\n\t\t\tpci_info(d, \"PIIX3: Enabling Passive Release\\n\");\n\t\t\tdlc |= 1<<1;\n\t\t\tpci_write_config_byte(d, 0x82, dlc);\n\t\t}\n\t}\n}\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL,\tPCI_DEVICE_ID_INTEL_82441,\tquirk_passive_release);\nDECLARE_PCI_FIXUP_RESUME(PCI_VENDOR_ID_INTEL,\tPCI_DEVICE_ID_INTEL_82441,\tquirk_passive_release);\n\n#ifdef CONFIG_X86_32\n \nstatic void quirk_isa_dma_hangs(struct pci_dev *dev)\n{\n\tif (!isa_dma_bridge_buggy) {\n\t\tisa_dma_bridge_buggy = 1;\n\t\tpci_info(dev, \"Activating ISA DMA hang workarounds\\n\");\n\t}\n}\n \nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_VIA,\tPCI_DEVICE_ID_VIA_82C586_0,\tquirk_isa_dma_hangs);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_VIA,\tPCI_DEVICE_ID_VIA_82C596,\tquirk_isa_dma_hangs);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL,    PCI_DEVICE_ID_INTEL_82371SB_0,  quirk_isa_dma_hangs);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_AL,\tPCI_DEVICE_ID_AL_M1533,\t\tquirk_isa_dma_hangs);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_NEC,\tPCI_DEVICE_ID_NEC_CBUS_1,\tquirk_isa_dma_hangs);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_NEC,\tPCI_DEVICE_ID_NEC_CBUS_2,\tquirk_isa_dma_hangs);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_NEC,\tPCI_DEVICE_ID_NEC_CBUS_3,\tquirk_isa_dma_hangs);\n#endif\n\n#ifdef CONFIG_HAS_IOPORT\n \nstatic void quirk_tigerpoint_bm_sts(struct pci_dev *dev)\n{\n\tu32 pmbase;\n\tu16 pm1a;\n\n\tpci_read_config_dword(dev, 0x40, &pmbase);\n\tpmbase = pmbase & 0xff80;\n\tpm1a = inw(pmbase);\n\n\tif (pm1a & 0x10) {\n\t\tpci_info(dev, FW_BUG \"Tiger Point LPC.BM_STS cleared\\n\");\n\t\toutw(0x10, pmbase);\n\t}\n}\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_TGP_LPC, quirk_tigerpoint_bm_sts);\n#endif\n\n \nstatic void quirk_nopcipci(struct pci_dev *dev)\n{\n\tif ((pci_pci_problems & PCIPCI_FAIL) == 0) {\n\t\tpci_info(dev, \"Disabling direct PCI/PCI transfers\\n\");\n\t\tpci_pci_problems |= PCIPCI_FAIL;\n\t}\n}\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_SI,\tPCI_DEVICE_ID_SI_5597,\t\tquirk_nopcipci);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_SI,\tPCI_DEVICE_ID_SI_496,\t\tquirk_nopcipci);\n\nstatic void quirk_nopciamd(struct pci_dev *dev)\n{\n\tu8 rev;\n\tpci_read_config_byte(dev, 0x08, &rev);\n\tif (rev == 0x13) {\n\t\t \n\t\tpci_info(dev, \"Chipset erratum: Disabling direct PCI/AGP transfers\\n\");\n\t\tpci_pci_problems |= PCIAGP_FAIL;\n\t}\n}\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_AMD,\tPCI_DEVICE_ID_AMD_8151_0,\tquirk_nopciamd);\n\n \nstatic void quirk_triton(struct pci_dev *dev)\n{\n\tif ((pci_pci_problems&PCIPCI_TRITON) == 0) {\n\t\tpci_info(dev, \"Limiting direct PCI/PCI transfers\\n\");\n\t\tpci_pci_problems |= PCIPCI_TRITON;\n\t}\n}\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL,\tPCI_DEVICE_ID_INTEL_82437,\tquirk_triton);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL,\tPCI_DEVICE_ID_INTEL_82437VX,\tquirk_triton);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL,\tPCI_DEVICE_ID_INTEL_82439,\tquirk_triton);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL,\tPCI_DEVICE_ID_INTEL_82439TX,\tquirk_triton);\n\n \nstatic void quirk_vialatency(struct pci_dev *dev)\n{\n\tstruct pci_dev *p;\n\tu8 busarb;\n\n\t \n\tp = pci_get_device(PCI_VENDOR_ID_VIA, PCI_DEVICE_ID_VIA_82C686, NULL);\n\tif (p != NULL) {\n\n\t\t \n\t\tif (p->revision < 0x40 || p->revision > 0x42)\n\t\t\tgoto exit;\n\t} else {\n\t\tp = pci_get_device(PCI_VENDOR_ID_VIA, PCI_DEVICE_ID_VIA_8231, NULL);\n\t\tif (p == NULL)\t \n\t\t\tgoto exit;\n\n\t\t \n\t\tif (p->revision < 0x10 || p->revision > 0x12)\n\t\t\tgoto exit;\n\t}\n\n\t \n\tpci_read_config_byte(dev, 0x76, &busarb);\n\n\t \n\tbusarb &= ~(1<<5);\n\tbusarb |= (1<<4);\n\tpci_write_config_byte(dev, 0x76, busarb);\n\tpci_info(dev, \"Applying VIA southbridge workaround\\n\");\nexit:\n\tpci_dev_put(p);\n}\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_VIA,\tPCI_DEVICE_ID_VIA_8363_0,\tquirk_vialatency);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_VIA,\tPCI_DEVICE_ID_VIA_8371_1,\tquirk_vialatency);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_VIA,\tPCI_DEVICE_ID_VIA_8361,\t\tquirk_vialatency);\n \nDECLARE_PCI_FIXUP_RESUME(PCI_VENDOR_ID_VIA,\tPCI_DEVICE_ID_VIA_8363_0,\tquirk_vialatency);\nDECLARE_PCI_FIXUP_RESUME(PCI_VENDOR_ID_VIA,\tPCI_DEVICE_ID_VIA_8371_1,\tquirk_vialatency);\nDECLARE_PCI_FIXUP_RESUME(PCI_VENDOR_ID_VIA,\tPCI_DEVICE_ID_VIA_8361,\t\tquirk_vialatency);\n\n \nstatic void quirk_viaetbf(struct pci_dev *dev)\n{\n\tif ((pci_pci_problems&PCIPCI_VIAETBF) == 0) {\n\t\tpci_info(dev, \"Limiting direct PCI/PCI transfers\\n\");\n\t\tpci_pci_problems |= PCIPCI_VIAETBF;\n\t}\n}\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_VIA,\tPCI_DEVICE_ID_VIA_82C597_0,\tquirk_viaetbf);\n\nstatic void quirk_vsfx(struct pci_dev *dev)\n{\n\tif ((pci_pci_problems&PCIPCI_VSFX) == 0) {\n\t\tpci_info(dev, \"Limiting direct PCI/PCI transfers\\n\");\n\t\tpci_pci_problems |= PCIPCI_VSFX;\n\t}\n}\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_VIA,\tPCI_DEVICE_ID_VIA_82C576,\tquirk_vsfx);\n\n \nstatic void quirk_alimagik(struct pci_dev *dev)\n{\n\tif ((pci_pci_problems&PCIPCI_ALIMAGIK) == 0) {\n\t\tpci_info(dev, \"Limiting direct PCI/PCI transfers\\n\");\n\t\tpci_pci_problems |= PCIPCI_ALIMAGIK|PCIPCI_TRITON;\n\t}\n}\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_AL,\tPCI_DEVICE_ID_AL_M1647,\t\tquirk_alimagik);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_AL,\tPCI_DEVICE_ID_AL_M1651,\t\tquirk_alimagik);\n\n \nstatic void quirk_natoma(struct pci_dev *dev)\n{\n\tif ((pci_pci_problems&PCIPCI_NATOMA) == 0) {\n\t\tpci_info(dev, \"Limiting direct PCI/PCI transfers\\n\");\n\t\tpci_pci_problems |= PCIPCI_NATOMA;\n\t}\n}\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL,\tPCI_DEVICE_ID_INTEL_82441,\tquirk_natoma);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL,\tPCI_DEVICE_ID_INTEL_82443LX_0,\tquirk_natoma);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL,\tPCI_DEVICE_ID_INTEL_82443LX_1,\tquirk_natoma);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL,\tPCI_DEVICE_ID_INTEL_82443BX_0,\tquirk_natoma);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL,\tPCI_DEVICE_ID_INTEL_82443BX_1,\tquirk_natoma);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL,\tPCI_DEVICE_ID_INTEL_82443BX_2,\tquirk_natoma);\n\n \nstatic void quirk_citrine(struct pci_dev *dev)\n{\n\tdev->cfg_size = 0xA0;\n}\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_IBM,\tPCI_DEVICE_ID_IBM_CITRINE,\tquirk_citrine);\n\n \nstatic void quirk_nfp6000(struct pci_dev *dev)\n{\n\tdev->cfg_size = 0x600;\n}\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_NETRONOME,\tPCI_DEVICE_ID_NETRONOME_NFP4000,\tquirk_nfp6000);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_NETRONOME,\tPCI_DEVICE_ID_NETRONOME_NFP6000,\tquirk_nfp6000);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_NETRONOME,\tPCI_DEVICE_ID_NETRONOME_NFP5000,\tquirk_nfp6000);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_NETRONOME,\tPCI_DEVICE_ID_NETRONOME_NFP6000_VF,\tquirk_nfp6000);\n\n \nstatic void quirk_extend_bar_to_page(struct pci_dev *dev)\n{\n\tint i;\n\n\tfor (i = 0; i < PCI_STD_NUM_BARS; i++) {\n\t\tstruct resource *r = &dev->resource[i];\n\n\t\tif (r->flags & IORESOURCE_MEM && resource_size(r) < PAGE_SIZE) {\n\t\t\tr->end = PAGE_SIZE - 1;\n\t\t\tr->start = 0;\n\t\t\tr->flags |= IORESOURCE_UNSET;\n\t\t\tpci_info(dev, \"expanded BAR %d to page size: %pR\\n\",\n\t\t\t\t i, r);\n\t\t}\n\t}\n}\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_IBM, 0x034a, quirk_extend_bar_to_page);\n\n \nstatic void quirk_s3_64M(struct pci_dev *dev)\n{\n\tstruct resource *r = &dev->resource[0];\n\n\tif ((r->start & 0x3ffffff) || r->end != r->start + 0x3ffffff) {\n\t\tr->flags |= IORESOURCE_UNSET;\n\t\tr->start = 0;\n\t\tr->end = 0x3ffffff;\n\t}\n}\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_S3,\tPCI_DEVICE_ID_S3_868,\t\tquirk_s3_64M);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_S3,\tPCI_DEVICE_ID_S3_968,\t\tquirk_s3_64M);\n\nstatic void quirk_io(struct pci_dev *dev, int pos, unsigned int size,\n\t\t     const char *name)\n{\n\tu32 region;\n\tstruct pci_bus_region bus_region;\n\tstruct resource *res = dev->resource + pos;\n\n\tpci_read_config_dword(dev, PCI_BASE_ADDRESS_0 + (pos << 2), &region);\n\n\tif (!region)\n\t\treturn;\n\n\tres->name = pci_name(dev);\n\tres->flags = region & ~PCI_BASE_ADDRESS_IO_MASK;\n\tres->flags |=\n\t\t(IORESOURCE_IO | IORESOURCE_PCI_FIXED | IORESOURCE_SIZEALIGN);\n\tregion &= ~(size - 1);\n\n\t \n\tbus_region.start = region;\n\tbus_region.end = region + size - 1;\n\tpcibios_bus_to_resource(dev->bus, res, &bus_region);\n\n\tpci_info(dev, FW_BUG \"%s quirk: reg 0x%x: %pR\\n\",\n\t\t name, PCI_BASE_ADDRESS_0 + (pos << 2), res);\n}\n\n \nstatic void quirk_cs5536_vsa(struct pci_dev *dev)\n{\n\tstatic char *name = \"CS5536 ISA bridge\";\n\n\tif (pci_resource_len(dev, 0) != 8) {\n\t\tquirk_io(dev, 0,   8, name);\t \n\t\tquirk_io(dev, 1, 256, name);\t \n\t\tquirk_io(dev, 2,  64, name);\t \n\t\tpci_info(dev, \"%s bug detected (incorrect header); workaround applied\\n\",\n\t\t\t name);\n\t}\n}\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_CS5536_ISA, quirk_cs5536_vsa);\n\nstatic void quirk_io_region(struct pci_dev *dev, int port,\n\t\t\t    unsigned int size, int nr, const char *name)\n{\n\tu16 region;\n\tstruct pci_bus_region bus_region;\n\tstruct resource *res = dev->resource + nr;\n\n\tpci_read_config_word(dev, port, &region);\n\tregion &= ~(size - 1);\n\n\tif (!region)\n\t\treturn;\n\n\tres->name = pci_name(dev);\n\tres->flags = IORESOURCE_IO;\n\n\t \n\tbus_region.start = region;\n\tbus_region.end = region + size - 1;\n\tpcibios_bus_to_resource(dev->bus, res, &bus_region);\n\n\tif (!pci_claim_resource(dev, nr))\n\t\tpci_info(dev, \"quirk: %pR claimed by %s\\n\", res, name);\n}\n\n \nstatic void quirk_ati_exploding_mce(struct pci_dev *dev)\n{\n\tpci_info(dev, \"ATI Northbridge, reserving I/O ports 0x3b0 to 0x3bb\\n\");\n\t \n\trequest_region(0x3b0, 0x0C, \"RadeonIGP\");\n\trequest_region(0x3d3, 0x01, \"RadeonIGP\");\n}\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_ATI,\tPCI_DEVICE_ID_ATI_RS100,   quirk_ati_exploding_mce);\n\n \nstatic void quirk_amd_dwc_class(struct pci_dev *pdev)\n{\n\tu32 class = pdev->class;\n\n\t \n\tpdev->class = PCI_CLASS_SERIAL_USB_DEVICE;\n\tpci_info(pdev, \"PCI class overridden (%#08x -> %#08x) so dwc3 driver can claim this instead of xhci\\n\",\n\t\t class, pdev->class);\n}\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_NL_USB,\n\t\tquirk_amd_dwc_class);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_VANGOGH_USB,\n\t\tquirk_amd_dwc_class);\n\n \nstatic void quirk_synopsys_haps(struct pci_dev *pdev)\n{\n\tu32 class = pdev->class;\n\n\tswitch (pdev->device) {\n\tcase PCI_DEVICE_ID_SYNOPSYS_HAPSUSB3:\n\tcase PCI_DEVICE_ID_SYNOPSYS_HAPSUSB3_AXI:\n\tcase PCI_DEVICE_ID_SYNOPSYS_HAPSUSB31:\n\t\tpdev->class = PCI_CLASS_SERIAL_USB_DEVICE;\n\t\tpci_info(pdev, \"PCI class overridden (%#08x -> %#08x) so dwc3 driver can claim this instead of xhci\\n\",\n\t\t\t class, pdev->class);\n\t\tbreak;\n\t}\n}\nDECLARE_PCI_FIXUP_CLASS_HEADER(PCI_VENDOR_ID_SYNOPSYS, PCI_ANY_ID,\n\t\t\t       PCI_CLASS_SERIAL_USB_XHCI, 0,\n\t\t\t       quirk_synopsys_haps);\n\n \nstatic void quirk_ali7101_acpi(struct pci_dev *dev)\n{\n\tquirk_io_region(dev, 0xE0, 64, PCI_BRIDGE_RESOURCES, \"ali7101 ACPI\");\n\tquirk_io_region(dev, 0xE2, 32, PCI_BRIDGE_RESOURCES+1, \"ali7101 SMB\");\n}\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_AL,\tPCI_DEVICE_ID_AL_M7101,\t\tquirk_ali7101_acpi);\n\nstatic void piix4_io_quirk(struct pci_dev *dev, const char *name, unsigned int port, unsigned int enable)\n{\n\tu32 devres;\n\tu32 mask, size, base;\n\n\tpci_read_config_dword(dev, port, &devres);\n\tif ((devres & enable) != enable)\n\t\treturn;\n\tmask = (devres >> 16) & 15;\n\tbase = devres & 0xffff;\n\tsize = 16;\n\tfor (;;) {\n\t\tunsigned int bit = size >> 1;\n\t\tif ((bit & mask) == bit)\n\t\t\tbreak;\n\t\tsize = bit;\n\t}\n\t \n\tbase &= -size;\n\tpci_info(dev, \"%s PIO at %04x-%04x\\n\", name, base, base + size - 1);\n}\n\nstatic void piix4_mem_quirk(struct pci_dev *dev, const char *name, unsigned int port, unsigned int enable)\n{\n\tu32 devres;\n\tu32 mask, size, base;\n\n\tpci_read_config_dword(dev, port, &devres);\n\tif ((devres & enable) != enable)\n\t\treturn;\n\tbase = devres & 0xffff0000;\n\tmask = (devres & 0x3f) << 16;\n\tsize = 128 << 16;\n\tfor (;;) {\n\t\tunsigned int bit = size >> 1;\n\t\tif ((bit & mask) == bit)\n\t\t\tbreak;\n\t\tsize = bit;\n\t}\n\n\t \n\tbase &= -size;\n\tpci_info(dev, \"%s MMIO at %04x-%04x\\n\", name, base, base + size - 1);\n}\n\n \nstatic void quirk_piix4_acpi(struct pci_dev *dev)\n{\n\tu32 res_a;\n\n\tquirk_io_region(dev, 0x40, 64, PCI_BRIDGE_RESOURCES, \"PIIX4 ACPI\");\n\tquirk_io_region(dev, 0x90, 16, PCI_BRIDGE_RESOURCES+1, \"PIIX4 SMB\");\n\n\t \n\tpci_read_config_dword(dev, 0x5c, &res_a);\n\n\tpiix4_io_quirk(dev, \"PIIX4 devres B\", 0x60, 3 << 21);\n\tpiix4_io_quirk(dev, \"PIIX4 devres C\", 0x64, 3 << 21);\n\n\t \n\n\t \n\tif (res_a & (1 << 29)) {\n\t\tpiix4_io_quirk(dev, \"PIIX4 devres E\", 0x68, 1 << 20);\n\t\tpiix4_mem_quirk(dev, \"PIIX4 devres F\", 0x6c, 1 << 7);\n\t}\n\t \n\tif (res_a & (1 << 30)) {\n\t\tpiix4_io_quirk(dev, \"PIIX4 devres G\", 0x70, 1 << 20);\n\t\tpiix4_mem_quirk(dev, \"PIIX4 devres H\", 0x74, 1 << 7);\n\t}\n\tpiix4_io_quirk(dev, \"PIIX4 devres I\", 0x78, 1 << 20);\n\tpiix4_io_quirk(dev, \"PIIX4 devres J\", 0x7c, 1 << 20);\n}\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL,\tPCI_DEVICE_ID_INTEL_82371AB_3,\tquirk_piix4_acpi);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL,\tPCI_DEVICE_ID_INTEL_82443MX_3,\tquirk_piix4_acpi);\n\n#define ICH_PMBASE\t0x40\n#define ICH_ACPI_CNTL\t0x44\n#define  ICH4_ACPI_EN\t0x10\n#define  ICH6_ACPI_EN\t0x80\n#define ICH4_GPIOBASE\t0x58\n#define ICH4_GPIO_CNTL\t0x5c\n#define  ICH4_GPIO_EN\t0x10\n#define ICH6_GPIOBASE\t0x48\n#define ICH6_GPIO_CNTL\t0x4c\n#define  ICH6_GPIO_EN\t0x10\n\n \nstatic void quirk_ich4_lpc_acpi(struct pci_dev *dev)\n{\n\tu8 enable;\n\n\t \n\tpci_read_config_byte(dev, ICH_ACPI_CNTL, &enable);\n\tif (enable & ICH4_ACPI_EN)\n\t\tquirk_io_region(dev, ICH_PMBASE, 128, PCI_BRIDGE_RESOURCES,\n\t\t\t\t \"ICH4 ACPI/GPIO/TCO\");\n\n\tpci_read_config_byte(dev, ICH4_GPIO_CNTL, &enable);\n\tif (enable & ICH4_GPIO_EN)\n\t\tquirk_io_region(dev, ICH4_GPIOBASE, 64, PCI_BRIDGE_RESOURCES+1,\n\t\t\t\t\"ICH4 GPIO\");\n}\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL,    PCI_DEVICE_ID_INTEL_82801AA_0,\t\tquirk_ich4_lpc_acpi);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL,    PCI_DEVICE_ID_INTEL_82801AB_0,\t\tquirk_ich4_lpc_acpi);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL,    PCI_DEVICE_ID_INTEL_82801BA_0,\t\tquirk_ich4_lpc_acpi);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL,    PCI_DEVICE_ID_INTEL_82801BA_10,\tquirk_ich4_lpc_acpi);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL,    PCI_DEVICE_ID_INTEL_82801CA_0,\t\tquirk_ich4_lpc_acpi);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL,    PCI_DEVICE_ID_INTEL_82801CA_12,\tquirk_ich4_lpc_acpi);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL,    PCI_DEVICE_ID_INTEL_82801DB_0,\t\tquirk_ich4_lpc_acpi);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL,    PCI_DEVICE_ID_INTEL_82801DB_12,\tquirk_ich4_lpc_acpi);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL,    PCI_DEVICE_ID_INTEL_82801EB_0,\t\tquirk_ich4_lpc_acpi);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL,    PCI_DEVICE_ID_INTEL_ESB_1,\t\tquirk_ich4_lpc_acpi);\n\nstatic void ich6_lpc_acpi_gpio(struct pci_dev *dev)\n{\n\tu8 enable;\n\n\tpci_read_config_byte(dev, ICH_ACPI_CNTL, &enable);\n\tif (enable & ICH6_ACPI_EN)\n\t\tquirk_io_region(dev, ICH_PMBASE, 128, PCI_BRIDGE_RESOURCES,\n\t\t\t\t \"ICH6 ACPI/GPIO/TCO\");\n\n\tpci_read_config_byte(dev, ICH6_GPIO_CNTL, &enable);\n\tif (enable & ICH6_GPIO_EN)\n\t\tquirk_io_region(dev, ICH6_GPIOBASE, 64, PCI_BRIDGE_RESOURCES+1,\n\t\t\t\t\"ICH6 GPIO\");\n}\n\nstatic void ich6_lpc_generic_decode(struct pci_dev *dev, unsigned int reg,\n\t\t\t\t    const char *name, int dynsize)\n{\n\tu32 val;\n\tu32 size, base;\n\n\tpci_read_config_dword(dev, reg, &val);\n\n\t \n\tif (!(val & 1))\n\t\treturn;\n\tbase = val & 0xfffc;\n\tif (dynsize) {\n\t\t \n\t\tsize = 16;\n\t} else {\n\t\tsize = 128;\n\t}\n\tbase &= ~(size-1);\n\n\t \n\tpci_info(dev, \"%s PIO at %04x-%04x\\n\", name, base, base+size-1);\n}\n\nstatic void quirk_ich6_lpc(struct pci_dev *dev)\n{\n\t \n\tich6_lpc_acpi_gpio(dev);\n\n\t \n\tich6_lpc_generic_decode(dev, 0x84, \"LPC Generic IO decode 1\", 0);\n\tich6_lpc_generic_decode(dev, 0x88, \"LPC Generic IO decode 2\", 1);\n}\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL,\tPCI_DEVICE_ID_INTEL_ICH6_0, quirk_ich6_lpc);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL,\tPCI_DEVICE_ID_INTEL_ICH6_1, quirk_ich6_lpc);\n\nstatic void ich7_lpc_generic_decode(struct pci_dev *dev, unsigned int reg,\n\t\t\t\t    const char *name)\n{\n\tu32 val;\n\tu32 mask, base;\n\n\tpci_read_config_dword(dev, reg, &val);\n\n\t \n\tif (!(val & 1))\n\t\treturn;\n\n\t \n\tbase = val & 0xfffc;\n\tmask = (val >> 16) & 0xfc;\n\tmask |= 3;\n\n\t \n\tpci_info(dev, \"%s PIO at %04x (mask %04x)\\n\", name, base, mask);\n}\n\n \nstatic void quirk_ich7_lpc(struct pci_dev *dev)\n{\n\t \n\tich6_lpc_acpi_gpio(dev);\n\n\t \n\tich7_lpc_generic_decode(dev, 0x84, \"ICH7 LPC Generic IO decode 1\");\n\tich7_lpc_generic_decode(dev, 0x88, \"ICH7 LPC Generic IO decode 2\");\n\tich7_lpc_generic_decode(dev, 0x8c, \"ICH7 LPC Generic IO decode 3\");\n\tich7_lpc_generic_decode(dev, 0x90, \"ICH7 LPC Generic IO decode 4\");\n}\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL,\tPCI_DEVICE_ID_INTEL_ICH7_0, quirk_ich7_lpc);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL,\tPCI_DEVICE_ID_INTEL_ICH7_1, quirk_ich7_lpc);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL,\tPCI_DEVICE_ID_INTEL_ICH7_31, quirk_ich7_lpc);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL,\tPCI_DEVICE_ID_INTEL_ICH8_0, quirk_ich7_lpc);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL,\tPCI_DEVICE_ID_INTEL_ICH8_2, quirk_ich7_lpc);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL,\tPCI_DEVICE_ID_INTEL_ICH8_3, quirk_ich7_lpc);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL,\tPCI_DEVICE_ID_INTEL_ICH8_1, quirk_ich7_lpc);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL,\tPCI_DEVICE_ID_INTEL_ICH8_4, quirk_ich7_lpc);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL,\tPCI_DEVICE_ID_INTEL_ICH9_2, quirk_ich7_lpc);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL,\tPCI_DEVICE_ID_INTEL_ICH9_4, quirk_ich7_lpc);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL,\tPCI_DEVICE_ID_INTEL_ICH9_7, quirk_ich7_lpc);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL,\tPCI_DEVICE_ID_INTEL_ICH9_8, quirk_ich7_lpc);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL,   PCI_DEVICE_ID_INTEL_ICH10_1, quirk_ich7_lpc);\n\n \nstatic void quirk_vt82c586_acpi(struct pci_dev *dev)\n{\n\tif (dev->revision & 0x10)\n\t\tquirk_io_region(dev, 0x48, 256, PCI_BRIDGE_RESOURCES,\n\t\t\t\t\"vt82c586 ACPI\");\n}\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_VIA,\tPCI_DEVICE_ID_VIA_82C586_3,\tquirk_vt82c586_acpi);\n\n \nstatic void quirk_vt82c686_acpi(struct pci_dev *dev)\n{\n\tquirk_vt82c586_acpi(dev);\n\n\tquirk_io_region(dev, 0x70, 128, PCI_BRIDGE_RESOURCES+1,\n\t\t\t\t \"vt82c686 HW-mon\");\n\n\tquirk_io_region(dev, 0x90, 16, PCI_BRIDGE_RESOURCES+2, \"vt82c686 SMB\");\n}\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_VIA,\tPCI_DEVICE_ID_VIA_82C686_4,\tquirk_vt82c686_acpi);\n\n \nstatic void quirk_vt8235_acpi(struct pci_dev *dev)\n{\n\tquirk_io_region(dev, 0x88, 128, PCI_BRIDGE_RESOURCES, \"vt8235 PM\");\n\tquirk_io_region(dev, 0xd0, 16, PCI_BRIDGE_RESOURCES+1, \"vt8235 SMB\");\n}\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_VIA,\tPCI_DEVICE_ID_VIA_8235,\tquirk_vt8235_acpi);\n\n \nstatic void quirk_xio2000a(struct pci_dev *dev)\n{\n\tstruct pci_dev *pdev;\n\tu16 command;\n\n\tpci_warn(dev, \"TI XIO2000a quirk detected; secondary bus fast back-to-back transfers disabled\\n\");\n\tlist_for_each_entry(pdev, &dev->subordinate->devices, bus_list) {\n\t\tpci_read_config_word(pdev, PCI_COMMAND, &command);\n\t\tif (command & PCI_COMMAND_FAST_BACK)\n\t\t\tpci_write_config_word(pdev, PCI_COMMAND, command & ~PCI_COMMAND_FAST_BACK);\n\t}\n}\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_TI, PCI_DEVICE_ID_TI_XIO2000A,\n\t\t\tquirk_xio2000a);\n\n#ifdef CONFIG_X86_IO_APIC\n\n#include <asm/io_apic.h>\n\n \nstatic void quirk_via_ioapic(struct pci_dev *dev)\n{\n\tu8 tmp;\n\n\tif (nr_ioapics < 1)\n\t\ttmp = 0;     \n\telse\n\t\ttmp = 0x1f;  \n\n\tpci_info(dev, \"%s VIA external APIC routing\\n\",\n\t\t tmp ? \"Enabling\" : \"Disabling\");\n\n\t \n\tpci_write_config_byte(dev, 0x58, tmp);\n}\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_VIA,\tPCI_DEVICE_ID_VIA_82C686,\tquirk_via_ioapic);\nDECLARE_PCI_FIXUP_RESUME_EARLY(PCI_VENDOR_ID_VIA,\tPCI_DEVICE_ID_VIA_82C686,\tquirk_via_ioapic);\n\n \nstatic void quirk_via_vt8237_bypass_apic_deassert(struct pci_dev *dev)\n{\n\tu8 misc_control2;\n#define BYPASS_APIC_DEASSERT 8\n\n\tpci_read_config_byte(dev, 0x5B, &misc_control2);\n\tif (!(misc_control2 & BYPASS_APIC_DEASSERT)) {\n\t\tpci_info(dev, \"Bypassing VIA 8237 APIC De-Assert Message\\n\");\n\t\tpci_write_config_byte(dev, 0x5B, misc_control2|BYPASS_APIC_DEASSERT);\n\t}\n}\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_VIA,\tPCI_DEVICE_ID_VIA_8237,\t\tquirk_via_vt8237_bypass_apic_deassert);\nDECLARE_PCI_FIXUP_RESUME_EARLY(PCI_VENDOR_ID_VIA,\tPCI_DEVICE_ID_VIA_8237,\t\tquirk_via_vt8237_bypass_apic_deassert);\n\n \nstatic void quirk_amd_ioapic(struct pci_dev *dev)\n{\n\tif (dev->revision >= 0x02) {\n\t\tpci_warn(dev, \"I/O APIC: AMD Erratum #22 may be present. In the event of instability try\\n\");\n\t\tpci_warn(dev, \"        : booting with the \\\"noapic\\\" option\\n\");\n\t}\n}\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_AMD,\tPCI_DEVICE_ID_AMD_VIPER_7410,\tquirk_amd_ioapic);\n#endif  \n\n#if defined(CONFIG_ARM64) && defined(CONFIG_PCI_ATS)\n\nstatic void quirk_cavium_sriov_rnm_link(struct pci_dev *dev)\n{\n\t \n\tif (dev->subsystem_device == 0xa118)\n\t\tdev->sriov->link = dev->devfn;\n}\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_CAVIUM, 0xa018, quirk_cavium_sriov_rnm_link);\n#endif\n\n \nstatic void quirk_amd_8131_mmrbc(struct pci_dev *dev)\n{\n\tif (dev->subordinate && dev->revision <= 0x12) {\n\t\tpci_info(dev, \"AMD8131 rev %x detected; disabling PCI-X MMRBC\\n\",\n\t\t\t dev->revision);\n\t\tdev->subordinate->bus_flags |= PCI_BUS_FLAGS_NO_MMRBC;\n\t}\n}\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_8131_BRIDGE, quirk_amd_8131_mmrbc);\n\n \nstatic void quirk_via_acpi(struct pci_dev *d)\n{\n\tu8 irq;\n\n\t \n\tpci_read_config_byte(d, 0x42, &irq);\n\tirq &= 0xf;\n\tif (irq && (irq != 2))\n\t\td->irq = irq;\n}\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_VIA,\tPCI_DEVICE_ID_VIA_82C586_3,\tquirk_via_acpi);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_VIA,\tPCI_DEVICE_ID_VIA_82C686_4,\tquirk_via_acpi);\n\n \nstatic int via_vlink_dev_lo = -1, via_vlink_dev_hi = 18;\n\nstatic void quirk_via_bridge(struct pci_dev *dev)\n{\n\t \n\tswitch (dev->device) {\n\tcase PCI_DEVICE_ID_VIA_82C686:\n\t\t \n\t\tvia_vlink_dev_lo = PCI_SLOT(dev->devfn);\n\t\tvia_vlink_dev_hi = PCI_SLOT(dev->devfn);\n\t\tbreak;\n\tcase PCI_DEVICE_ID_VIA_8237:\n\tcase PCI_DEVICE_ID_VIA_8237A:\n\t\tvia_vlink_dev_lo = 15;\n\t\tbreak;\n\tcase PCI_DEVICE_ID_VIA_8235:\n\t\tvia_vlink_dev_lo = 16;\n\t\tbreak;\n\tcase PCI_DEVICE_ID_VIA_8231:\n\tcase PCI_DEVICE_ID_VIA_8233_0:\n\tcase PCI_DEVICE_ID_VIA_8233A:\n\tcase PCI_DEVICE_ID_VIA_8233C_0:\n\t\tvia_vlink_dev_lo = 17;\n\t\tbreak;\n\t}\n}\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_VIA,\tPCI_DEVICE_ID_VIA_82C686,\tquirk_via_bridge);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_VIA,\tPCI_DEVICE_ID_VIA_8231,\t\tquirk_via_bridge);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_VIA,\tPCI_DEVICE_ID_VIA_8233_0,\tquirk_via_bridge);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_VIA,\tPCI_DEVICE_ID_VIA_8233A,\tquirk_via_bridge);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_VIA,\tPCI_DEVICE_ID_VIA_8233C_0,\tquirk_via_bridge);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_VIA,\tPCI_DEVICE_ID_VIA_8235,\t\tquirk_via_bridge);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_VIA,\tPCI_DEVICE_ID_VIA_8237,\t\tquirk_via_bridge);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_VIA,\tPCI_DEVICE_ID_VIA_8237A,\tquirk_via_bridge);\n\n \nstatic void quirk_via_vlink(struct pci_dev *dev)\n{\n\tu8 irq, new_irq;\n\n\t \n\tif (via_vlink_dev_lo == -1)\n\t\treturn;\n\n\tnew_irq = dev->irq;\n\n\t \n\tif (!new_irq || new_irq > 15)\n\t\treturn;\n\n\t \n\tif (dev->bus->number != 0 || PCI_SLOT(dev->devfn) > via_vlink_dev_hi ||\n\t    PCI_SLOT(dev->devfn) < via_vlink_dev_lo)\n\t\treturn;\n\n\t \n\tpci_read_config_byte(dev, PCI_INTERRUPT_LINE, &irq);\n\tif (new_irq != irq) {\n\t\tpci_info(dev, \"VIA VLink IRQ fixup, from %d to %d\\n\",\n\t\t\tirq, new_irq);\n\t\tudelay(15);\t \n\t\tpci_write_config_byte(dev, PCI_INTERRUPT_LINE, new_irq);\n\t}\n}\nDECLARE_PCI_FIXUP_ENABLE(PCI_VENDOR_ID_VIA, PCI_ANY_ID, quirk_via_vlink);\n\n \nstatic void quirk_vt82c598_id(struct pci_dev *dev)\n{\n\tpci_write_config_byte(dev, 0xfc, 0);\n\tpci_read_config_word(dev, PCI_DEVICE_ID, &dev->device);\n}\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_VIA,\tPCI_DEVICE_ID_VIA_82C597_0,\tquirk_vt82c598_id);\n\n \nstatic void quirk_cardbus_legacy(struct pci_dev *dev)\n{\n\tpci_write_config_dword(dev, PCI_CB_LEGACY_MODE_BASE, 0);\n}\nDECLARE_PCI_FIXUP_CLASS_FINAL(PCI_ANY_ID, PCI_ANY_ID,\n\t\t\tPCI_CLASS_BRIDGE_CARDBUS, 8, quirk_cardbus_legacy);\nDECLARE_PCI_FIXUP_CLASS_RESUME_EARLY(PCI_ANY_ID, PCI_ANY_ID,\n\t\t\tPCI_CLASS_BRIDGE_CARDBUS, 8, quirk_cardbus_legacy);\n\n \nstatic void quirk_amd_ordering(struct pci_dev *dev)\n{\n\tu32 pcic;\n\tpci_read_config_dword(dev, 0x4C, &pcic);\n\tif ((pcic & 6) != 6) {\n\t\tpcic |= 6;\n\t\tpci_warn(dev, \"BIOS failed to enable PCI standards compliance; fixing this error\\n\");\n\t\tpci_write_config_dword(dev, 0x4C, pcic);\n\t\tpci_read_config_dword(dev, 0x84, &pcic);\n\t\tpcic |= (1 << 23);\t \n\t\tpci_write_config_dword(dev, 0x84, pcic);\n\t}\n}\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_AMD,\tPCI_DEVICE_ID_AMD_FE_GATE_700C, quirk_amd_ordering);\nDECLARE_PCI_FIXUP_RESUME_EARLY(PCI_VENDOR_ID_AMD,\tPCI_DEVICE_ID_AMD_FE_GATE_700C, quirk_amd_ordering);\n\n \nstatic void quirk_dunord(struct pci_dev *dev)\n{\n\tstruct resource *r = &dev->resource[1];\n\n\tr->flags |= IORESOURCE_UNSET;\n\tr->start = 0;\n\tr->end = 0xffffff;\n}\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_DUNORD,\tPCI_DEVICE_ID_DUNORD_I3000,\tquirk_dunord);\n\n \nstatic void quirk_transparent_bridge(struct pci_dev *dev)\n{\n\tdev->transparent = 1;\n}\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL,\tPCI_DEVICE_ID_INTEL_82380FB,\tquirk_transparent_bridge);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_TOSHIBA,\t0x605,\tquirk_transparent_bridge);\n\n \nstatic void quirk_mediagx_master(struct pci_dev *dev)\n{\n\tu8 reg;\n\n\tpci_read_config_byte(dev, 0x41, &reg);\n\tif (reg & 2) {\n\t\treg &= ~2;\n\t\tpci_info(dev, \"Fixup for MediaGX/Geode Slave Disconnect Boundary (0x41=0x%02x)\\n\",\n\t\t\t reg);\n\t\tpci_write_config_byte(dev, 0x41, reg);\n\t}\n}\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_CYRIX,\tPCI_DEVICE_ID_CYRIX_PCI_MASTER, quirk_mediagx_master);\nDECLARE_PCI_FIXUP_RESUME(PCI_VENDOR_ID_CYRIX,\tPCI_DEVICE_ID_CYRIX_PCI_MASTER, quirk_mediagx_master);\n\n \nstatic void quirk_disable_pxb(struct pci_dev *pdev)\n{\n\tu16 config;\n\n\tif (pdev->revision != 0x04)\t\t \n\t\treturn;\n\tpci_read_config_word(pdev, 0x40, &config);\n\tif (config & (1<<6)) {\n\t\tconfig &= ~(1<<6);\n\t\tpci_write_config_word(pdev, 0x40, config);\n\t\tpci_info(pdev, \"C0 revision 450NX. Disabling PCI restreaming\\n\");\n\t}\n}\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL,\tPCI_DEVICE_ID_INTEL_82454NX,\tquirk_disable_pxb);\nDECLARE_PCI_FIXUP_RESUME_EARLY(PCI_VENDOR_ID_INTEL,\tPCI_DEVICE_ID_INTEL_82454NX,\tquirk_disable_pxb);\n\nstatic void quirk_amd_ide_mode(struct pci_dev *pdev)\n{\n\t \n\tu8 tmp;\n\n\tpci_read_config_byte(pdev, PCI_CLASS_DEVICE, &tmp);\n\tif (tmp == 0x01) {\n\t\tpci_read_config_byte(pdev, 0x40, &tmp);\n\t\tpci_write_config_byte(pdev, 0x40, tmp|1);\n\t\tpci_write_config_byte(pdev, 0x9, 1);\n\t\tpci_write_config_byte(pdev, 0xa, 6);\n\t\tpci_write_config_byte(pdev, 0x40, tmp);\n\n\t\tpdev->class = PCI_CLASS_STORAGE_SATA_AHCI;\n\t\tpci_info(pdev, \"set SATA to AHCI mode\\n\");\n\t}\n}\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_IXP600_SATA, quirk_amd_ide_mode);\nDECLARE_PCI_FIXUP_RESUME_EARLY(PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_IXP600_SATA, quirk_amd_ide_mode);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_IXP700_SATA, quirk_amd_ide_mode);\nDECLARE_PCI_FIXUP_RESUME_EARLY(PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_IXP700_SATA, quirk_amd_ide_mode);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_HUDSON2_SATA_IDE, quirk_amd_ide_mode);\nDECLARE_PCI_FIXUP_RESUME_EARLY(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_HUDSON2_SATA_IDE, quirk_amd_ide_mode);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_AMD, 0x7900, quirk_amd_ide_mode);\nDECLARE_PCI_FIXUP_RESUME_EARLY(PCI_VENDOR_ID_AMD, 0x7900, quirk_amd_ide_mode);\n\n \nstatic void quirk_svwks_csb5ide(struct pci_dev *pdev)\n{\n\tu8 prog;\n\tpci_read_config_byte(pdev, PCI_CLASS_PROG, &prog);\n\tif (prog & 5) {\n\t\tprog &= ~5;\n\t\tpdev->class &= ~5;\n\t\tpci_write_config_byte(pdev, PCI_CLASS_PROG, prog);\n\t\t \n\t}\n}\nDECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_SERVERWORKS, PCI_DEVICE_ID_SERVERWORKS_CSB5IDE, quirk_svwks_csb5ide);\n\n \nstatic void quirk_ide_samemode(struct pci_dev *pdev)\n{\n\tu8 prog;\n\n\tpci_read_config_byte(pdev, PCI_CLASS_PROG, &prog);\n\n\tif (((prog & 1) && !(prog & 4)) || ((prog & 4) && !(prog & 1))) {\n\t\tpci_info(pdev, \"IDE mode mismatch; forcing legacy mode\\n\");\n\t\tprog &= ~5;\n\t\tpdev->class &= ~5;\n\t\tpci_write_config_byte(pdev, PCI_CLASS_PROG, prog);\n\t}\n}\nDECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82801CA_10, quirk_ide_samemode);\n\n \nstatic void quirk_no_ata_d3(struct pci_dev *pdev)\n{\n\tpdev->dev_flags |= PCI_DEV_FLAGS_NO_D3;\n}\n \nDECLARE_PCI_FIXUP_CLASS_EARLY(PCI_VENDOR_ID_SERVERWORKS, PCI_ANY_ID,\n\t\t\t\tPCI_CLASS_STORAGE_IDE, 8, quirk_no_ata_d3);\nDECLARE_PCI_FIXUP_CLASS_EARLY(PCI_VENDOR_ID_ATI, PCI_ANY_ID,\n\t\t\t\tPCI_CLASS_STORAGE_IDE, 8, quirk_no_ata_d3);\n \nDECLARE_PCI_FIXUP_CLASS_EARLY(PCI_VENDOR_ID_AL, PCI_ANY_ID,\n\t\t\t\tPCI_CLASS_STORAGE_IDE, 8, quirk_no_ata_d3);\n \nDECLARE_PCI_FIXUP_CLASS_EARLY(PCI_VENDOR_ID_VIA, PCI_ANY_ID,\n\t\t\t\tPCI_CLASS_STORAGE_IDE, 8, quirk_no_ata_d3);\n\n \nstatic void quirk_eisa_bridge(struct pci_dev *dev)\n{\n\tdev->class = PCI_CLASS_BRIDGE_EISA << 8;\n}\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL,\tPCI_DEVICE_ID_INTEL_82375,\tquirk_eisa_bridge);\n\n \nstatic int asus_hides_smbus;\n\nstatic void asus_hides_smbus_hostbridge(struct pci_dev *dev)\n{\n\tif (unlikely(dev->subsystem_vendor == PCI_VENDOR_ID_ASUSTEK)) {\n\t\tif (dev->device == PCI_DEVICE_ID_INTEL_82845_HB)\n\t\t\tswitch (dev->subsystem_device) {\n\t\t\tcase 0x8025:  \n\t\t\tcase 0x8070:  \n\t\t\tcase 0x8088:  \n\t\t\tcase 0x1626:  \n\t\t\t\tasus_hides_smbus = 1;\n\t\t\t}\n\t\telse if (dev->device == PCI_DEVICE_ID_INTEL_82845G_HB)\n\t\t\tswitch (dev->subsystem_device) {\n\t\t\tcase 0x80b1:  \n\t\t\tcase 0x80b2:  \n\t\t\tcase 0x8093:  \n\t\t\t\tasus_hides_smbus = 1;\n\t\t\t}\n\t\telse if (dev->device == PCI_DEVICE_ID_INTEL_82850_HB)\n\t\t\tswitch (dev->subsystem_device) {\n\t\t\tcase 0x8030:  \n\t\t\t\tasus_hides_smbus = 1;\n\t\t\t}\n\t\telse if (dev->device == PCI_DEVICE_ID_INTEL_7205_0)\n\t\t\tswitch (dev->subsystem_device) {\n\t\t\tcase 0x8070:  \n\t\t\t\tasus_hides_smbus = 1;\n\t\t\t}\n\t\telse if (dev->device == PCI_DEVICE_ID_INTEL_E7501_MCH)\n\t\t\tswitch (dev->subsystem_device) {\n\t\t\tcase 0x80c9:  \n\t\t\t\tasus_hides_smbus = 1;\n\t\t\t}\n\t\telse if (dev->device == PCI_DEVICE_ID_INTEL_82855GM_HB)\n\t\t\tswitch (dev->subsystem_device) {\n\t\t\tcase 0x1751:  \n\t\t\tcase 0x1821:  \n\t\t\tcase 0x1897:  \n\t\t\t\tasus_hides_smbus = 1;\n\t\t\t}\n\t\telse if (dev->device == PCI_DEVICE_ID_INTEL_82855PM_HB)\n\t\t\tswitch (dev->subsystem_device) {\n\t\t\tcase 0x184b:  \n\t\t\tcase 0x186a:  \n\t\t\t\tasus_hides_smbus = 1;\n\t\t\t}\n\t\telse if (dev->device == PCI_DEVICE_ID_INTEL_82865_HB)\n\t\t\tswitch (dev->subsystem_device) {\n\t\t\tcase 0x80f2:  \n\t\t\t\tasus_hides_smbus = 1;\n\t\t\t}\n\t\telse if (dev->device == PCI_DEVICE_ID_INTEL_82915GM_HB)\n\t\t\tswitch (dev->subsystem_device) {\n\t\t\tcase 0x1882:  \n\t\t\tcase 0x1977:  \n\t\t\t\tasus_hides_smbus = 1;\n\t\t\t}\n\t} else if (unlikely(dev->subsystem_vendor == PCI_VENDOR_ID_HP)) {\n\t\tif (dev->device ==  PCI_DEVICE_ID_INTEL_82855PM_HB)\n\t\t\tswitch (dev->subsystem_device) {\n\t\t\tcase 0x088C:  \n\t\t\tcase 0x0890:  \n\t\t\t\tasus_hides_smbus = 1;\n\t\t\t}\n\t\telse if (dev->device == PCI_DEVICE_ID_INTEL_82865_HB)\n\t\t\tswitch (dev->subsystem_device) {\n\t\t\tcase 0x12bc:  \n\t\t\tcase 0x12bd:  \n\t\t\tcase 0x006a:  \n\t\t\t\tasus_hides_smbus = 1;\n\t\t\t}\n\t\telse if (dev->device == PCI_DEVICE_ID_INTEL_82875_HB)\n\t\t\tswitch (dev->subsystem_device) {\n\t\t\tcase 0x12bf:  \n\t\t\t\tasus_hides_smbus = 1;\n\t\t\t}\n\t} else if (unlikely(dev->subsystem_vendor == PCI_VENDOR_ID_SAMSUNG)) {\n\t\tif (dev->device ==  PCI_DEVICE_ID_INTEL_82855PM_HB)\n\t\t\tswitch (dev->subsystem_device) {\n\t\t\tcase 0xC00C:  \n\t\t\t\tasus_hides_smbus = 1;\n\t\t}\n\t} else if (unlikely(dev->subsystem_vendor == PCI_VENDOR_ID_COMPAQ)) {\n\t\tif (dev->device == PCI_DEVICE_ID_INTEL_82855PM_HB)\n\t\t\tswitch (dev->subsystem_device) {\n\t\t\tcase 0x0058:  \n\t\t\t\tasus_hides_smbus = 1;\n\t\t\t}\n\t\telse if (dev->device == PCI_DEVICE_ID_INTEL_82810_IG3)\n\t\t\tswitch (dev->subsystem_device) {\n\t\t\tcase 0xB16C:  \n\t\t\t\t \n\t\t\t\tasus_hides_smbus = 1;\n\t\t\t}\n\t\telse if (dev->device == PCI_DEVICE_ID_INTEL_82801DB_2)\n\t\t\tswitch (dev->subsystem_device) {\n\t\t\tcase 0x00b8:  \n\t\t\tcase 0x00b9:  \n\t\t\tcase 0x00ba:  \n\t\t\t\t \n\t\t\t\tasus_hides_smbus = 1;\n\t\t\t}\n\t\telse if (dev->device == PCI_DEVICE_ID_INTEL_82815_CGC)\n\t\t\tswitch (dev->subsystem_device) {\n\t\t\tcase 0x001A:  \n\t\t\t\t \n\t\t\t\tasus_hides_smbus = 1;\n\t\t\t}\n\t}\n}\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL,\tPCI_DEVICE_ID_INTEL_82845_HB,\tasus_hides_smbus_hostbridge);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL,\tPCI_DEVICE_ID_INTEL_82845G_HB,\tasus_hides_smbus_hostbridge);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL,\tPCI_DEVICE_ID_INTEL_82850_HB,\tasus_hides_smbus_hostbridge);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL,\tPCI_DEVICE_ID_INTEL_82865_HB,\tasus_hides_smbus_hostbridge);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL,\tPCI_DEVICE_ID_INTEL_82875_HB,\tasus_hides_smbus_hostbridge);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL,\tPCI_DEVICE_ID_INTEL_7205_0,\tasus_hides_smbus_hostbridge);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL,\tPCI_DEVICE_ID_INTEL_E7501_MCH,\tasus_hides_smbus_hostbridge);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL,\tPCI_DEVICE_ID_INTEL_82855PM_HB,\tasus_hides_smbus_hostbridge);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL,\tPCI_DEVICE_ID_INTEL_82855GM_HB,\tasus_hides_smbus_hostbridge);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL,\tPCI_DEVICE_ID_INTEL_82915GM_HB, asus_hides_smbus_hostbridge);\n\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL,\tPCI_DEVICE_ID_INTEL_82810_IG3,\tasus_hides_smbus_hostbridge);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL,\tPCI_DEVICE_ID_INTEL_82801DB_2,\tasus_hides_smbus_hostbridge);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL,\tPCI_DEVICE_ID_INTEL_82815_CGC,\tasus_hides_smbus_hostbridge);\n\nstatic void asus_hides_smbus_lpc(struct pci_dev *dev)\n{\n\tu16 val;\n\n\tif (likely(!asus_hides_smbus))\n\t\treturn;\n\n\tpci_read_config_word(dev, 0xF2, &val);\n\tif (val & 0x8) {\n\t\tpci_write_config_word(dev, 0xF2, val & (~0x8));\n\t\tpci_read_config_word(dev, 0xF2, &val);\n\t\tif (val & 0x8)\n\t\t\tpci_info(dev, \"i801 SMBus device continues to play 'hide and seek'! 0x%x\\n\",\n\t\t\t\t val);\n\t\telse\n\t\t\tpci_info(dev, \"Enabled i801 SMBus device\\n\");\n\t}\n}\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL,\tPCI_DEVICE_ID_INTEL_82801AA_0,\tasus_hides_smbus_lpc);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL,\tPCI_DEVICE_ID_INTEL_82801DB_0,\tasus_hides_smbus_lpc);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL,\tPCI_DEVICE_ID_INTEL_82801BA_0,\tasus_hides_smbus_lpc);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL,\tPCI_DEVICE_ID_INTEL_82801CA_0,\tasus_hides_smbus_lpc);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL,\tPCI_DEVICE_ID_INTEL_82801CA_12,\tasus_hides_smbus_lpc);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL,\tPCI_DEVICE_ID_INTEL_82801DB_12,\tasus_hides_smbus_lpc);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL,\tPCI_DEVICE_ID_INTEL_82801EB_0,\tasus_hides_smbus_lpc);\nDECLARE_PCI_FIXUP_RESUME_EARLY(PCI_VENDOR_ID_INTEL,\tPCI_DEVICE_ID_INTEL_82801AA_0,\tasus_hides_smbus_lpc);\nDECLARE_PCI_FIXUP_RESUME_EARLY(PCI_VENDOR_ID_INTEL,\tPCI_DEVICE_ID_INTEL_82801DB_0,\tasus_hides_smbus_lpc);\nDECLARE_PCI_FIXUP_RESUME_EARLY(PCI_VENDOR_ID_INTEL,\tPCI_DEVICE_ID_INTEL_82801BA_0,\tasus_hides_smbus_lpc);\nDECLARE_PCI_FIXUP_RESUME_EARLY(PCI_VENDOR_ID_INTEL,\tPCI_DEVICE_ID_INTEL_82801CA_0,\tasus_hides_smbus_lpc);\nDECLARE_PCI_FIXUP_RESUME_EARLY(PCI_VENDOR_ID_INTEL,\tPCI_DEVICE_ID_INTEL_82801CA_12,\tasus_hides_smbus_lpc);\nDECLARE_PCI_FIXUP_RESUME_EARLY(PCI_VENDOR_ID_INTEL,\tPCI_DEVICE_ID_INTEL_82801DB_12,\tasus_hides_smbus_lpc);\nDECLARE_PCI_FIXUP_RESUME_EARLY(PCI_VENDOR_ID_INTEL,\tPCI_DEVICE_ID_INTEL_82801EB_0,\tasus_hides_smbus_lpc);\n\n \nstatic void __iomem *asus_rcba_base;\nstatic void asus_hides_smbus_lpc_ich6_suspend(struct pci_dev *dev)\n{\n\tu32 rcba;\n\n\tif (likely(!asus_hides_smbus))\n\t\treturn;\n\tWARN_ON(asus_rcba_base);\n\n\tpci_read_config_dword(dev, 0xF0, &rcba);\n\t \n\tasus_rcba_base = ioremap(rcba & 0xFFFFC000, 0x4000);\n\tif (asus_rcba_base == NULL)\n\t\treturn;\n}\n\nstatic void asus_hides_smbus_lpc_ich6_resume_early(struct pci_dev *dev)\n{\n\tu32 val;\n\n\tif (likely(!asus_hides_smbus || !asus_rcba_base))\n\t\treturn;\n\n\t \n\tval = readl(asus_rcba_base + 0x3418);\n\n\t \n\twritel(val & 0xFFFFFFF7, asus_rcba_base + 0x3418);\n}\n\nstatic void asus_hides_smbus_lpc_ich6_resume(struct pci_dev *dev)\n{\n\tif (likely(!asus_hides_smbus || !asus_rcba_base))\n\t\treturn;\n\n\tiounmap(asus_rcba_base);\n\tasus_rcba_base = NULL;\n\tpci_info(dev, \"Enabled ICH6/i801 SMBus device\\n\");\n}\n\nstatic void asus_hides_smbus_lpc_ich6(struct pci_dev *dev)\n{\n\tasus_hides_smbus_lpc_ich6_suspend(dev);\n\tasus_hides_smbus_lpc_ich6_resume_early(dev);\n\tasus_hides_smbus_lpc_ich6_resume(dev);\n}\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL,\tPCI_DEVICE_ID_INTEL_ICH6_1,\tasus_hides_smbus_lpc_ich6);\nDECLARE_PCI_FIXUP_SUSPEND(PCI_VENDOR_ID_INTEL,\tPCI_DEVICE_ID_INTEL_ICH6_1,\tasus_hides_smbus_lpc_ich6_suspend);\nDECLARE_PCI_FIXUP_RESUME(PCI_VENDOR_ID_INTEL,\tPCI_DEVICE_ID_INTEL_ICH6_1,\tasus_hides_smbus_lpc_ich6_resume);\nDECLARE_PCI_FIXUP_RESUME_EARLY(PCI_VENDOR_ID_INTEL,\tPCI_DEVICE_ID_INTEL_ICH6_1,\tasus_hides_smbus_lpc_ich6_resume_early);\n\n \nstatic void quirk_sis_96x_smbus(struct pci_dev *dev)\n{\n\tu8 val = 0;\n\tpci_read_config_byte(dev, 0x77, &val);\n\tif (val & 0x10) {\n\t\tpci_info(dev, \"Enabling SiS 96x SMBus\\n\");\n\t\tpci_write_config_byte(dev, 0x77, val & ~0x10);\n\t}\n}\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_SI,\tPCI_DEVICE_ID_SI_961,\t\tquirk_sis_96x_smbus);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_SI,\tPCI_DEVICE_ID_SI_962,\t\tquirk_sis_96x_smbus);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_SI,\tPCI_DEVICE_ID_SI_963,\t\tquirk_sis_96x_smbus);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_SI,\tPCI_DEVICE_ID_SI_LPC,\t\tquirk_sis_96x_smbus);\nDECLARE_PCI_FIXUP_RESUME_EARLY(PCI_VENDOR_ID_SI,\tPCI_DEVICE_ID_SI_961,\t\tquirk_sis_96x_smbus);\nDECLARE_PCI_FIXUP_RESUME_EARLY(PCI_VENDOR_ID_SI,\tPCI_DEVICE_ID_SI_962,\t\tquirk_sis_96x_smbus);\nDECLARE_PCI_FIXUP_RESUME_EARLY(PCI_VENDOR_ID_SI,\tPCI_DEVICE_ID_SI_963,\t\tquirk_sis_96x_smbus);\nDECLARE_PCI_FIXUP_RESUME_EARLY(PCI_VENDOR_ID_SI,\tPCI_DEVICE_ID_SI_LPC,\t\tquirk_sis_96x_smbus);\n\n \n#define SIS_DETECT_REGISTER 0x40\n\nstatic void quirk_sis_503(struct pci_dev *dev)\n{\n\tu8 reg;\n\tu16 devid;\n\n\tpci_read_config_byte(dev, SIS_DETECT_REGISTER, &reg);\n\tpci_write_config_byte(dev, SIS_DETECT_REGISTER, reg | (1 << 6));\n\tpci_read_config_word(dev, PCI_DEVICE_ID, &devid);\n\tif (((devid & 0xfff0) != 0x0960) && (devid != 0x0018)) {\n\t\tpci_write_config_byte(dev, SIS_DETECT_REGISTER, reg);\n\t\treturn;\n\t}\n\n\t \n\tdev->device = devid;\n\tquirk_sis_96x_smbus(dev);\n}\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_SI,\tPCI_DEVICE_ID_SI_503,\t\tquirk_sis_503);\nDECLARE_PCI_FIXUP_RESUME_EARLY(PCI_VENDOR_ID_SI,\tPCI_DEVICE_ID_SI_503,\t\tquirk_sis_503);\n\n \nstatic void asus_hides_ac97_lpc(struct pci_dev *dev)\n{\n\tu8 val;\n\tint asus_hides_ac97 = 0;\n\n\tif (likely(dev->subsystem_vendor == PCI_VENDOR_ID_ASUSTEK)) {\n\t\tif (dev->device == PCI_DEVICE_ID_VIA_8237)\n\t\t\tasus_hides_ac97 = 1;\n\t}\n\n\tif (!asus_hides_ac97)\n\t\treturn;\n\n\tpci_read_config_byte(dev, 0x50, &val);\n\tif (val & 0xc0) {\n\t\tpci_write_config_byte(dev, 0x50, val & (~0xc0));\n\t\tpci_read_config_byte(dev, 0x50, &val);\n\t\tif (val & 0xc0)\n\t\t\tpci_info(dev, \"Onboard AC97/MC97 devices continue to play 'hide and seek'! 0x%x\\n\",\n\t\t\t\t val);\n\t\telse\n\t\t\tpci_info(dev, \"Enabled onboard AC97/MC97 devices\\n\");\n\t}\n}\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_VIA,\tPCI_DEVICE_ID_VIA_8237, asus_hides_ac97_lpc);\nDECLARE_PCI_FIXUP_RESUME_EARLY(PCI_VENDOR_ID_VIA,\tPCI_DEVICE_ID_VIA_8237, asus_hides_ac97_lpc);\n\n#if defined(CONFIG_ATA) || defined(CONFIG_ATA_MODULE)\n\n \nstatic void quirk_jmicron_ata(struct pci_dev *pdev)\n{\n\tu32 conf1, conf5, class;\n\tu8 hdr;\n\n\t \n\tif (PCI_FUNC(pdev->devfn))\n\t\treturn;\n\n\tpci_read_config_dword(pdev, 0x40, &conf1);\n\tpci_read_config_dword(pdev, 0x80, &conf5);\n\n\tconf1 &= ~0x00CFF302;  \n\tconf5 &= ~(1 << 24);   \n\n\tswitch (pdev->device) {\n\tcase PCI_DEVICE_ID_JMICRON_JMB360:  \n\tcase PCI_DEVICE_ID_JMICRON_JMB362:  \n\tcase PCI_DEVICE_ID_JMICRON_JMB364:  \n\t\t \n\t\tconf1 |= 0x0002A100;  \n\t\tbreak;\n\n\tcase PCI_DEVICE_ID_JMICRON_JMB365:\n\tcase PCI_DEVICE_ID_JMICRON_JMB366:\n\t\t \n\t\tconf5 |= (1 << 24);\n\t\tfallthrough;\n\tcase PCI_DEVICE_ID_JMICRON_JMB361:\n\tcase PCI_DEVICE_ID_JMICRON_JMB363:\n\tcase PCI_DEVICE_ID_JMICRON_JMB369:\n\t\t \n\t\t \n\t\tconf1 |= 0x00C2A1B3;  \n\t\tbreak;\n\n\tcase PCI_DEVICE_ID_JMICRON_JMB368:\n\t\t \n\t\tconf1 |= 0x00C00000;  \n\t\tbreak;\n\t}\n\n\tpci_write_config_dword(pdev, 0x40, conf1);\n\tpci_write_config_dword(pdev, 0x80, conf5);\n\n\t \n\tpci_read_config_byte(pdev, PCI_HEADER_TYPE, &hdr);\n\tpdev->hdr_type = hdr & 0x7f;\n\tpdev->multifunction = !!(hdr & 0x80);\n\n\tpci_read_config_dword(pdev, PCI_CLASS_REVISION, &class);\n\tpdev->class = class >> 8;\n}\nDECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_JMICRON, PCI_DEVICE_ID_JMICRON_JMB360, quirk_jmicron_ata);\nDECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_JMICRON, PCI_DEVICE_ID_JMICRON_JMB361, quirk_jmicron_ata);\nDECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_JMICRON, PCI_DEVICE_ID_JMICRON_JMB362, quirk_jmicron_ata);\nDECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_JMICRON, PCI_DEVICE_ID_JMICRON_JMB363, quirk_jmicron_ata);\nDECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_JMICRON, PCI_DEVICE_ID_JMICRON_JMB364, quirk_jmicron_ata);\nDECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_JMICRON, PCI_DEVICE_ID_JMICRON_JMB365, quirk_jmicron_ata);\nDECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_JMICRON, PCI_DEVICE_ID_JMICRON_JMB366, quirk_jmicron_ata);\nDECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_JMICRON, PCI_DEVICE_ID_JMICRON_JMB368, quirk_jmicron_ata);\nDECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_JMICRON, PCI_DEVICE_ID_JMICRON_JMB369, quirk_jmicron_ata);\nDECLARE_PCI_FIXUP_RESUME_EARLY(PCI_VENDOR_ID_JMICRON, PCI_DEVICE_ID_JMICRON_JMB360, quirk_jmicron_ata);\nDECLARE_PCI_FIXUP_RESUME_EARLY(PCI_VENDOR_ID_JMICRON, PCI_DEVICE_ID_JMICRON_JMB361, quirk_jmicron_ata);\nDECLARE_PCI_FIXUP_RESUME_EARLY(PCI_VENDOR_ID_JMICRON, PCI_DEVICE_ID_JMICRON_JMB362, quirk_jmicron_ata);\nDECLARE_PCI_FIXUP_RESUME_EARLY(PCI_VENDOR_ID_JMICRON, PCI_DEVICE_ID_JMICRON_JMB363, quirk_jmicron_ata);\nDECLARE_PCI_FIXUP_RESUME_EARLY(PCI_VENDOR_ID_JMICRON, PCI_DEVICE_ID_JMICRON_JMB364, quirk_jmicron_ata);\nDECLARE_PCI_FIXUP_RESUME_EARLY(PCI_VENDOR_ID_JMICRON, PCI_DEVICE_ID_JMICRON_JMB365, quirk_jmicron_ata);\nDECLARE_PCI_FIXUP_RESUME_EARLY(PCI_VENDOR_ID_JMICRON, PCI_DEVICE_ID_JMICRON_JMB366, quirk_jmicron_ata);\nDECLARE_PCI_FIXUP_RESUME_EARLY(PCI_VENDOR_ID_JMICRON, PCI_DEVICE_ID_JMICRON_JMB368, quirk_jmicron_ata);\nDECLARE_PCI_FIXUP_RESUME_EARLY(PCI_VENDOR_ID_JMICRON, PCI_DEVICE_ID_JMICRON_JMB369, quirk_jmicron_ata);\n\n#endif\n\nstatic void quirk_jmicron_async_suspend(struct pci_dev *dev)\n{\n\tif (dev->multifunction) {\n\t\tdevice_disable_async_suspend(&dev->dev);\n\t\tpci_info(dev, \"async suspend disabled to avoid multi-function power-on ordering issue\\n\");\n\t}\n}\nDECLARE_PCI_FIXUP_CLASS_FINAL(PCI_VENDOR_ID_JMICRON, PCI_ANY_ID, PCI_CLASS_STORAGE_IDE, 8, quirk_jmicron_async_suspend);\nDECLARE_PCI_FIXUP_CLASS_FINAL(PCI_VENDOR_ID_JMICRON, PCI_ANY_ID, PCI_CLASS_STORAGE_SATA_AHCI, 0, quirk_jmicron_async_suspend);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_JMICRON, 0x2362, quirk_jmicron_async_suspend);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_JMICRON, 0x236f, quirk_jmicron_async_suspend);\n\n#ifdef CONFIG_X86_IO_APIC\nstatic void quirk_alder_ioapic(struct pci_dev *pdev)\n{\n\tint i;\n\n\tif ((pdev->class >> 8) != 0xff00)\n\t\treturn;\n\n\t \n\tif (pci_resource_start(pdev, 0) && pci_resource_len(pdev, 0))\n\t\tinsert_resource(&iomem_resource, &pdev->resource[0]);\n\n\t \n\tfor (i = 1; i < PCI_STD_NUM_BARS; i++)\n\t\tmemset(&pdev->resource[i], 0, sizeof(pdev->resource[i]));\n}\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL,\tPCI_DEVICE_ID_INTEL_EESSC,\tquirk_alder_ioapic);\n#endif\n\nstatic void quirk_no_msi(struct pci_dev *dev)\n{\n\tpci_info(dev, \"avoiding MSI to work around a hardware defect\\n\");\n\tdev->no_msi = 1;\n}\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_ATI, 0x4386, quirk_no_msi);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_ATI, 0x4387, quirk_no_msi);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_ATI, 0x4388, quirk_no_msi);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_ATI, 0x4389, quirk_no_msi);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_ATI, 0x438a, quirk_no_msi);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_ATI, 0x438b, quirk_no_msi);\n\nstatic void quirk_pcie_mch(struct pci_dev *pdev)\n{\n\tpdev->no_msi = 1;\n}\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL,\tPCI_DEVICE_ID_INTEL_E7520_MCH,\tquirk_pcie_mch);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL,\tPCI_DEVICE_ID_INTEL_E7320_MCH,\tquirk_pcie_mch);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL,\tPCI_DEVICE_ID_INTEL_E7525_MCH,\tquirk_pcie_mch);\n\nDECLARE_PCI_FIXUP_CLASS_FINAL(PCI_VENDOR_ID_HUAWEI, 0x1610, PCI_CLASS_BRIDGE_PCI, 8, quirk_pcie_mch);\n\n \nstatic void quirk_huawei_pcie_sva(struct pci_dev *pdev)\n{\n\tstruct property_entry properties[] = {\n\t\tPROPERTY_ENTRY_BOOL(\"dma-can-stall\"),\n\t\t{},\n\t};\n\n\tif (pdev->revision != 0x21 && pdev->revision != 0x30)\n\t\treturn;\n\n\tpdev->pasid_no_tlp = 1;\n\n\t \n\tif (!pdev->dev.of_node &&\n\t    device_create_managed_software_node(&pdev->dev, properties, NULL))\n\t\tpci_warn(pdev, \"could not add stall property\");\n}\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_HUAWEI, 0xa250, quirk_huawei_pcie_sva);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_HUAWEI, 0xa251, quirk_huawei_pcie_sva);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_HUAWEI, 0xa255, quirk_huawei_pcie_sva);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_HUAWEI, 0xa256, quirk_huawei_pcie_sva);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_HUAWEI, 0xa258, quirk_huawei_pcie_sva);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_HUAWEI, 0xa259, quirk_huawei_pcie_sva);\n\n \nstatic void quirk_pcie_pxh(struct pci_dev *dev)\n{\n\tdev->no_msi = 1;\n\tpci_warn(dev, \"PXH quirk detected; SHPC device MSI disabled\\n\");\n}\nDECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_INTEL,\tPCI_DEVICE_ID_INTEL_PXHD_0,\tquirk_pcie_pxh);\nDECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_INTEL,\tPCI_DEVICE_ID_INTEL_PXHD_1,\tquirk_pcie_pxh);\nDECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_INTEL,\tPCI_DEVICE_ID_INTEL_PXH_0,\tquirk_pcie_pxh);\nDECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_INTEL,\tPCI_DEVICE_ID_INTEL_PXH_1,\tquirk_pcie_pxh);\nDECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_INTEL,\tPCI_DEVICE_ID_INTEL_PXHV,\tquirk_pcie_pxh);\n\n \nstatic void quirk_intel_pcie_pm(struct pci_dev *dev)\n{\n\tpci_pm_d3hot_delay = 120;\n\tdev->no_d1d2 = 1;\n}\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL,\t0x25e2, quirk_intel_pcie_pm);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL,\t0x25e3, quirk_intel_pcie_pm);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL,\t0x25e4, quirk_intel_pcie_pm);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL,\t0x25e5, quirk_intel_pcie_pm);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL,\t0x25e6, quirk_intel_pcie_pm);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL,\t0x25e7, quirk_intel_pcie_pm);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL,\t0x25f7, quirk_intel_pcie_pm);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL,\t0x25f8, quirk_intel_pcie_pm);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL,\t0x25f9, quirk_intel_pcie_pm);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL,\t0x25fa, quirk_intel_pcie_pm);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL,\t0x2601, quirk_intel_pcie_pm);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL,\t0x2602, quirk_intel_pcie_pm);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL,\t0x2603, quirk_intel_pcie_pm);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL,\t0x2604, quirk_intel_pcie_pm);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL,\t0x2605, quirk_intel_pcie_pm);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL,\t0x2606, quirk_intel_pcie_pm);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL,\t0x2607, quirk_intel_pcie_pm);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL,\t0x2608, quirk_intel_pcie_pm);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL,\t0x2609, quirk_intel_pcie_pm);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL,\t0x260a, quirk_intel_pcie_pm);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL,\t0x260b, quirk_intel_pcie_pm);\n\nstatic void quirk_d3hot_delay(struct pci_dev *dev, unsigned int delay)\n{\n\tif (dev->d3hot_delay >= delay)\n\t\treturn;\n\n\tdev->d3hot_delay = delay;\n\tpci_info(dev, \"extending delay after power-on from D3hot to %d msec\\n\",\n\t\t dev->d3hot_delay);\n}\n\nstatic void quirk_radeon_pm(struct pci_dev *dev)\n{\n\tif (dev->subsystem_vendor == PCI_VENDOR_ID_APPLE &&\n\t    dev->subsystem_device == 0x00e2)\n\t\tquirk_d3hot_delay(dev, 20);\n}\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_ATI, 0x6741, quirk_radeon_pm);\n\n \nstatic void quirk_nvidia_hda_pm(struct pci_dev *dev)\n{\n\tquirk_d3hot_delay(dev, 20);\n}\nDECLARE_PCI_FIXUP_CLASS_FINAL(PCI_VENDOR_ID_NVIDIA, PCI_ANY_ID,\n\t\t\t      PCI_CLASS_MULTIMEDIA_HD_AUDIO, 8,\n\t\t\t      quirk_nvidia_hda_pm);\n\n \nstatic void quirk_ryzen_xhci_d3hot(struct pci_dev *dev)\n{\n\tquirk_d3hot_delay(dev, 20);\n}\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_AMD, 0x15e0, quirk_ryzen_xhci_d3hot);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_AMD, 0x15e1, quirk_ryzen_xhci_d3hot);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_AMD, 0x1639, quirk_ryzen_xhci_d3hot);\n\n#ifdef CONFIG_X86_IO_APIC\nstatic int dmi_disable_ioapicreroute(const struct dmi_system_id *d)\n{\n\tnoioapicreroute = 1;\n\tpr_info(\"%s detected: disable boot interrupt reroute\\n\", d->ident);\n\n\treturn 0;\n}\n\nstatic const struct dmi_system_id boot_interrupt_dmi_table[] = {\n\t \n\t{\n\t\t.callback = dmi_disable_ioapicreroute,\n\t\t.ident = \"ASUSTek Computer INC. M2N-LR\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"ASUSTek Computer INC.\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"M2N-LR\"),\n\t\t},\n\t},\n\t{}\n};\n\n \nstatic void quirk_reroute_to_boot_interrupts_intel(struct pci_dev *dev)\n{\n\tdmi_check_system(boot_interrupt_dmi_table);\n\tif (noioapicquirk || noioapicreroute)\n\t\treturn;\n\n\tdev->irq_reroute_variant = INTEL_IRQ_REROUTE_VARIANT;\n\tpci_info(dev, \"rerouting interrupts for [%04x:%04x]\\n\",\n\t\t dev->vendor, dev->device);\n}\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL,\tPCI_DEVICE_ID_INTEL_80333_0,\tquirk_reroute_to_boot_interrupts_intel);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL,\tPCI_DEVICE_ID_INTEL_80333_1,\tquirk_reroute_to_boot_interrupts_intel);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL,\tPCI_DEVICE_ID_INTEL_ESB2_0,\tquirk_reroute_to_boot_interrupts_intel);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL,\tPCI_DEVICE_ID_INTEL_PXH_0,\tquirk_reroute_to_boot_interrupts_intel);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL,\tPCI_DEVICE_ID_INTEL_PXH_1,\tquirk_reroute_to_boot_interrupts_intel);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL,\tPCI_DEVICE_ID_INTEL_PXHV,\tquirk_reroute_to_boot_interrupts_intel);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL,\tPCI_DEVICE_ID_INTEL_80332_0,\tquirk_reroute_to_boot_interrupts_intel);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL,\tPCI_DEVICE_ID_INTEL_80332_1,\tquirk_reroute_to_boot_interrupts_intel);\nDECLARE_PCI_FIXUP_RESUME(PCI_VENDOR_ID_INTEL,\tPCI_DEVICE_ID_INTEL_80333_0,\tquirk_reroute_to_boot_interrupts_intel);\nDECLARE_PCI_FIXUP_RESUME(PCI_VENDOR_ID_INTEL,\tPCI_DEVICE_ID_INTEL_80333_1,\tquirk_reroute_to_boot_interrupts_intel);\nDECLARE_PCI_FIXUP_RESUME(PCI_VENDOR_ID_INTEL,\tPCI_DEVICE_ID_INTEL_ESB2_0,\tquirk_reroute_to_boot_interrupts_intel);\nDECLARE_PCI_FIXUP_RESUME(PCI_VENDOR_ID_INTEL,\tPCI_DEVICE_ID_INTEL_PXH_0,\tquirk_reroute_to_boot_interrupts_intel);\nDECLARE_PCI_FIXUP_RESUME(PCI_VENDOR_ID_INTEL,\tPCI_DEVICE_ID_INTEL_PXH_1,\tquirk_reroute_to_boot_interrupts_intel);\nDECLARE_PCI_FIXUP_RESUME(PCI_VENDOR_ID_INTEL,\tPCI_DEVICE_ID_INTEL_PXHV,\tquirk_reroute_to_boot_interrupts_intel);\nDECLARE_PCI_FIXUP_RESUME(PCI_VENDOR_ID_INTEL,\tPCI_DEVICE_ID_INTEL_80332_0,\tquirk_reroute_to_boot_interrupts_intel);\nDECLARE_PCI_FIXUP_RESUME(PCI_VENDOR_ID_INTEL,\tPCI_DEVICE_ID_INTEL_80332_1,\tquirk_reroute_to_boot_interrupts_intel);\n\n \n\n \n#define INTEL_6300_IOAPIC_ABAR\t\t0x40\t \n#define INTEL_6300_DISABLE_BOOT_IRQ\t(1<<14)\n\n#define INTEL_CIPINTRC_CFG_OFFSET\t0x14C\t \n#define INTEL_CIPINTRC_DIS_INTX_ICH\t(1<<25)\n\nstatic void quirk_disable_intel_boot_interrupt(struct pci_dev *dev)\n{\n\tu16 pci_config_word;\n\tu32 pci_config_dword;\n\n\tif (noioapicquirk)\n\t\treturn;\n\n\tswitch (dev->device) {\n\tcase PCI_DEVICE_ID_INTEL_ESB_10:\n\t\tpci_read_config_word(dev, INTEL_6300_IOAPIC_ABAR,\n\t\t\t\t     &pci_config_word);\n\t\tpci_config_word |= INTEL_6300_DISABLE_BOOT_IRQ;\n\t\tpci_write_config_word(dev, INTEL_6300_IOAPIC_ABAR,\n\t\t\t\t      pci_config_word);\n\t\tbreak;\n\tcase 0x3c28:\t \n\tcase 0x0e28:\t \n\tcase 0x2f28:\t \n\tcase 0x6f28:\t \n\tcase 0x2034:\t \n\t\tpci_read_config_dword(dev, INTEL_CIPINTRC_CFG_OFFSET,\n\t\t\t\t      &pci_config_dword);\n\t\tpci_config_dword |= INTEL_CIPINTRC_DIS_INTX_ICH;\n\t\tpci_write_config_dword(dev, INTEL_CIPINTRC_CFG_OFFSET,\n\t\t\t\t       pci_config_dword);\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\tpci_info(dev, \"disabled boot interrupts on device [%04x:%04x]\\n\",\n\t\t dev->vendor, dev->device);\n}\n \nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL,\tPCI_DEVICE_ID_INTEL_ESB_10,\n\t\tquirk_disable_intel_boot_interrupt);\nDECLARE_PCI_FIXUP_RESUME(PCI_VENDOR_ID_INTEL,\tPCI_DEVICE_ID_INTEL_ESB_10,\n\t\tquirk_disable_intel_boot_interrupt);\n\n \nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL,\t0x3c28,\n\t\tquirk_disable_intel_boot_interrupt);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL,\t0x0e28,\n\t\tquirk_disable_intel_boot_interrupt);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL,\t0x2f28,\n\t\tquirk_disable_intel_boot_interrupt);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL,\t0x6f28,\n\t\tquirk_disable_intel_boot_interrupt);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL,\t0x2034,\n\t\tquirk_disable_intel_boot_interrupt);\nDECLARE_PCI_FIXUP_RESUME(PCI_VENDOR_ID_INTEL,\t0x3c28,\n\t\tquirk_disable_intel_boot_interrupt);\nDECLARE_PCI_FIXUP_RESUME(PCI_VENDOR_ID_INTEL,\t0x0e28,\n\t\tquirk_disable_intel_boot_interrupt);\nDECLARE_PCI_FIXUP_RESUME(PCI_VENDOR_ID_INTEL,\t0x2f28,\n\t\tquirk_disable_intel_boot_interrupt);\nDECLARE_PCI_FIXUP_RESUME(PCI_VENDOR_ID_INTEL,\t0x6f28,\n\t\tquirk_disable_intel_boot_interrupt);\nDECLARE_PCI_FIXUP_RESUME(PCI_VENDOR_ID_INTEL,\t0x2034,\n\t\tquirk_disable_intel_boot_interrupt);\n\n \n#define BC_HT1000_FEATURE_REG\t\t0x64\n#define BC_HT1000_PIC_REGS_ENABLE\t(1<<0)\n#define BC_HT1000_MAP_IDX\t\t0xC00\n#define BC_HT1000_MAP_DATA\t\t0xC01\n\nstatic void quirk_disable_broadcom_boot_interrupt(struct pci_dev *dev)\n{\n\tu32 pci_config_dword;\n\tu8 irq;\n\n\tif (noioapicquirk)\n\t\treturn;\n\n\tpci_read_config_dword(dev, BC_HT1000_FEATURE_REG, &pci_config_dword);\n\tpci_write_config_dword(dev, BC_HT1000_FEATURE_REG, pci_config_dword |\n\t\t\tBC_HT1000_PIC_REGS_ENABLE);\n\n\tfor (irq = 0x10; irq < 0x10 + 32; irq++) {\n\t\toutb(irq, BC_HT1000_MAP_IDX);\n\t\toutb(0x00, BC_HT1000_MAP_DATA);\n\t}\n\n\tpci_write_config_dword(dev, BC_HT1000_FEATURE_REG, pci_config_dword);\n\n\tpci_info(dev, \"disabled boot interrupts on device [%04x:%04x]\\n\",\n\t\t dev->vendor, dev->device);\n}\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_SERVERWORKS,   PCI_DEVICE_ID_SERVERWORKS_HT1000SB,\tquirk_disable_broadcom_boot_interrupt);\nDECLARE_PCI_FIXUP_RESUME(PCI_VENDOR_ID_SERVERWORKS,   PCI_DEVICE_ID_SERVERWORKS_HT1000SB,\tquirk_disable_broadcom_boot_interrupt);\n\n \n\n \n#define AMD_813X_MISC\t\t\t0x40\n#define AMD_813X_NOIOAMODE\t\t(1<<0)\n#define AMD_813X_REV_B1\t\t\t0x12\n#define AMD_813X_REV_B2\t\t\t0x13\n\nstatic void quirk_disable_amd_813x_boot_interrupt(struct pci_dev *dev)\n{\n\tu32 pci_config_dword;\n\n\tif (noioapicquirk)\n\t\treturn;\n\tif ((dev->revision == AMD_813X_REV_B1) ||\n\t    (dev->revision == AMD_813X_REV_B2))\n\t\treturn;\n\n\tpci_read_config_dword(dev, AMD_813X_MISC, &pci_config_dword);\n\tpci_config_dword &= ~AMD_813X_NOIOAMODE;\n\tpci_write_config_dword(dev, AMD_813X_MISC, pci_config_dword);\n\n\tpci_info(dev, \"disabled boot interrupts on device [%04x:%04x]\\n\",\n\t\t dev->vendor, dev->device);\n}\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_AMD,\tPCI_DEVICE_ID_AMD_8131_BRIDGE,\tquirk_disable_amd_813x_boot_interrupt);\nDECLARE_PCI_FIXUP_RESUME(PCI_VENDOR_ID_AMD,\tPCI_DEVICE_ID_AMD_8131_BRIDGE,\tquirk_disable_amd_813x_boot_interrupt);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_AMD,\tPCI_DEVICE_ID_AMD_8132_BRIDGE,\tquirk_disable_amd_813x_boot_interrupt);\nDECLARE_PCI_FIXUP_RESUME(PCI_VENDOR_ID_AMD,\tPCI_DEVICE_ID_AMD_8132_BRIDGE,\tquirk_disable_amd_813x_boot_interrupt);\n\n#define AMD_8111_PCI_IRQ_ROUTING\t0x56\n\nstatic void quirk_disable_amd_8111_boot_interrupt(struct pci_dev *dev)\n{\n\tu16 pci_config_word;\n\n\tif (noioapicquirk)\n\t\treturn;\n\n\tpci_read_config_word(dev, AMD_8111_PCI_IRQ_ROUTING, &pci_config_word);\n\tif (!pci_config_word) {\n\t\tpci_info(dev, \"boot interrupts on device [%04x:%04x] already disabled\\n\",\n\t\t\t dev->vendor, dev->device);\n\t\treturn;\n\t}\n\tpci_write_config_word(dev, AMD_8111_PCI_IRQ_ROUTING, 0);\n\tpci_info(dev, \"disabled boot interrupts on device [%04x:%04x]\\n\",\n\t\t dev->vendor, dev->device);\n}\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_AMD,   PCI_DEVICE_ID_AMD_8111_SMBUS,\tquirk_disable_amd_8111_boot_interrupt);\nDECLARE_PCI_FIXUP_RESUME(PCI_VENDOR_ID_AMD,   PCI_DEVICE_ID_AMD_8111_SMBUS,\tquirk_disable_amd_8111_boot_interrupt);\n#endif  \n\n \nstatic void quirk_tc86c001_ide(struct pci_dev *dev)\n{\n\tstruct resource *r = &dev->resource[0];\n\n\tif (r->start & 0x8) {\n\t\tr->flags |= IORESOURCE_UNSET;\n\t\tr->start = 0;\n\t\tr->end = 0xf;\n\t}\n}\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_TOSHIBA_2,\n\t\t\t PCI_DEVICE_ID_TOSHIBA_TC86C001_IDE,\n\t\t\t quirk_tc86c001_ide);\n\n \nstatic void quirk_plx_pci9050(struct pci_dev *dev)\n{\n\tunsigned int bar;\n\n\t \n\tif (dev->revision >= 2)\n\t\treturn;\n\tfor (bar = 0; bar <= 1; bar++)\n\t\tif (pci_resource_len(dev, bar) == 0x80 &&\n\t\t    (pci_resource_start(dev, bar) & 0x80)) {\n\t\t\tstruct resource *r = &dev->resource[bar];\n\t\t\tpci_info(dev, \"Re-allocating PLX PCI 9050 BAR %u to length 256 to avoid bit 7 bug\\n\",\n\t\t\t\t bar);\n\t\t\tr->flags |= IORESOURCE_UNSET;\n\t\t\tr->start = 0;\n\t\t\tr->end = 0xff;\n\t\t}\n}\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_PLX, PCI_DEVICE_ID_PLX_9050,\n\t\t\t quirk_plx_pci9050);\n \nDECLARE_PCI_FIXUP_HEADER(0x1402, 0x2000, quirk_plx_pci9050);\nDECLARE_PCI_FIXUP_HEADER(0x1402, 0x2600, quirk_plx_pci9050);\n\nstatic void quirk_netmos(struct pci_dev *dev)\n{\n\tunsigned int num_parallel = (dev->subsystem_device & 0xf0) >> 4;\n\tunsigned int num_serial = dev->subsystem_device & 0xf;\n\n\t \n\tswitch (dev->device) {\n\tcase PCI_DEVICE_ID_NETMOS_9835:\n\t\t \n\t\tif (dev->subsystem_vendor == PCI_VENDOR_ID_IBM &&\n\t\t\t\tdev->subsystem_device == 0x0299)\n\t\t\treturn;\n\t\tfallthrough;\n\tcase PCI_DEVICE_ID_NETMOS_9735:\n\tcase PCI_DEVICE_ID_NETMOS_9745:\n\tcase PCI_DEVICE_ID_NETMOS_9845:\n\tcase PCI_DEVICE_ID_NETMOS_9855:\n\t\tif (num_parallel) {\n\t\t\tpci_info(dev, \"Netmos %04x (%u parallel, %u serial); changing class SERIAL to OTHER (use parport_serial)\\n\",\n\t\t\t\tdev->device, num_parallel, num_serial);\n\t\t\tdev->class = (PCI_CLASS_COMMUNICATION_OTHER << 8) |\n\t\t\t    (dev->class & 0xff);\n\t\t}\n\t}\n}\nDECLARE_PCI_FIXUP_CLASS_HEADER(PCI_VENDOR_ID_NETMOS, PCI_ANY_ID,\n\t\t\t PCI_CLASS_COMMUNICATION_SERIAL, 8, quirk_netmos);\n\nstatic void quirk_e100_interrupt(struct pci_dev *dev)\n{\n\tu16 command, pmcsr;\n\tu8 __iomem *csr;\n\tu8 cmd_hi;\n\n\tswitch (dev->device) {\n\t \n\tcase 0x1029:\n\tcase 0x1030 ... 0x1034:\n\tcase 0x1038 ... 0x103E:\n\tcase 0x1050 ... 0x1057:\n\tcase 0x1059:\n\tcase 0x1064 ... 0x106B:\n\tcase 0x1091 ... 0x1095:\n\tcase 0x1209:\n\tcase 0x1229:\n\tcase 0x2449:\n\tcase 0x2459:\n\tcase 0x245D:\n\tcase 0x27DC:\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\t \n\tpci_read_config_word(dev, PCI_COMMAND, &command);\n\n\tif (!(command & PCI_COMMAND_MEMORY) || !pci_resource_start(dev, 0))\n\t\treturn;\n\n\t \n\tif (dev->pm_cap) {\n\t\tpci_read_config_word(dev, dev->pm_cap + PCI_PM_CTRL, &pmcsr);\n\t\tif ((pmcsr & PCI_PM_CTRL_STATE_MASK) != PCI_D0)\n\t\t\treturn;\n\t}\n\n\t \n\tcsr = ioremap(pci_resource_start(dev, 0), 8);\n\tif (!csr) {\n\t\tpci_warn(dev, \"Can't map e100 registers\\n\");\n\t\treturn;\n\t}\n\n\tcmd_hi = readb(csr + 3);\n\tif (cmd_hi == 0) {\n\t\tpci_warn(dev, \"Firmware left e100 interrupts enabled; disabling\\n\");\n\t\twriteb(1, csr + 3);\n\t}\n\n\tiounmap(csr);\n}\nDECLARE_PCI_FIXUP_CLASS_FINAL(PCI_VENDOR_ID_INTEL, PCI_ANY_ID,\n\t\t\tPCI_CLASS_NETWORK_ETHERNET, 8, quirk_e100_interrupt);\n\n \nstatic void quirk_disable_aspm_l0s(struct pci_dev *dev)\n{\n\tpci_info(dev, \"Disabling L0s\\n\");\n\tpci_disable_link_state(dev, PCIE_LINK_STATE_L0S);\n}\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x10a7, quirk_disable_aspm_l0s);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x10a9, quirk_disable_aspm_l0s);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x10b6, quirk_disable_aspm_l0s);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x10c6, quirk_disable_aspm_l0s);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x10c7, quirk_disable_aspm_l0s);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x10c8, quirk_disable_aspm_l0s);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x10d6, quirk_disable_aspm_l0s);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x10db, quirk_disable_aspm_l0s);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x10dd, quirk_disable_aspm_l0s);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x10e1, quirk_disable_aspm_l0s);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x10ec, quirk_disable_aspm_l0s);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x10f1, quirk_disable_aspm_l0s);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x10f4, quirk_disable_aspm_l0s);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x1508, quirk_disable_aspm_l0s);\n\nstatic void quirk_disable_aspm_l0s_l1(struct pci_dev *dev)\n{\n\tpci_info(dev, \"Disabling ASPM L0s/L1\\n\");\n\tpci_disable_link_state(dev, PCIE_LINK_STATE_L0S | PCIE_LINK_STATE_L1);\n}\n\n \nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_ASMEDIA, 0x1080, quirk_disable_aspm_l0s_l1);\n\n \nstatic void quirk_enable_clear_retrain_link(struct pci_dev *dev)\n{\n\tdev->clear_retrain_link = 1;\n\tpci_info(dev, \"Enable PCIe Retrain Link quirk\\n\");\n}\nDECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_PERICOM, 0xe110, quirk_enable_clear_retrain_link);\nDECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_PERICOM, 0xe111, quirk_enable_clear_retrain_link);\nDECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_PERICOM, 0xe130, quirk_enable_clear_retrain_link);\n\nstatic void fixup_rev1_53c810(struct pci_dev *dev)\n{\n\tu32 class = dev->class;\n\n\t \n\tif (class)\n\t\treturn;\n\n\tdev->class = PCI_CLASS_STORAGE_SCSI << 8;\n\tpci_info(dev, \"NCR 53c810 rev 1 PCI class overridden (%#08x -> %#08x)\\n\",\n\t\t class, dev->class);\n}\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_NCR, PCI_DEVICE_ID_NCR_53C810, fixup_rev1_53c810);\n\n \nstatic void quirk_p64h2_1k_io(struct pci_dev *dev)\n{\n\tu16 en1k;\n\n\tpci_read_config_word(dev, 0x40, &en1k);\n\n\tif (en1k & 0x200) {\n\t\tpci_info(dev, \"Enable I/O Space to 1KB granularity\\n\");\n\t\tdev->io_window_1k = 1;\n\t}\n}\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x1460, quirk_p64h2_1k_io);\n\n \nstatic void quirk_nvidia_ck804_pcie_aer_ext_cap(struct pci_dev *dev)\n{\n\tuint8_t b;\n\n\tif (pci_read_config_byte(dev, 0xf41, &b) == 0) {\n\t\tif (!(b & 0x20)) {\n\t\t\tpci_write_config_byte(dev, 0xf41, b | 0x20);\n\t\t\tpci_info(dev, \"Linking AER extended capability\\n\");\n\t\t}\n\t}\n}\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_NVIDIA,  PCI_DEVICE_ID_NVIDIA_CK804_PCIE,\n\t\t\tquirk_nvidia_ck804_pcie_aer_ext_cap);\nDECLARE_PCI_FIXUP_RESUME_EARLY(PCI_VENDOR_ID_NVIDIA,  PCI_DEVICE_ID_NVIDIA_CK804_PCIE,\n\t\t\tquirk_nvidia_ck804_pcie_aer_ext_cap);\n\nstatic void quirk_via_cx700_pci_parking_caching(struct pci_dev *dev)\n{\n\t \n\n\t \n\tstruct pci_dev *p = pci_get_device(PCI_VENDOR_ID_VIA,\n\t\tPCI_DEVICE_ID_VIA_8235_USB_2, NULL);\n\tuint8_t b;\n\n\t \n\tp = pci_get_device(PCI_VENDOR_ID_VIA, PCI_DEVICE_ID_VIA_8235_USB_2, p);\n\tif (!p)\n\t\treturn;\n\tpci_dev_put(p);\n\n\tif (pci_read_config_byte(dev, 0x76, &b) == 0) {\n\t\tif (b & 0x40) {\n\t\t\t \n\t\t\tpci_write_config_byte(dev, 0x76, b ^ 0x40);\n\n\t\t\tpci_info(dev, \"Disabling VIA CX700 PCI parking\\n\");\n\t\t}\n\t}\n\n\tif (pci_read_config_byte(dev, 0x72, &b) == 0) {\n\t\tif (b != 0) {\n\t\t\t \n\t\t\tpci_write_config_byte(dev, 0x72, 0x0);\n\n\t\t\t \n\t\t\tpci_write_config_byte(dev, 0x75, 0x1);\n\n\t\t\t \n\t\t\tpci_write_config_byte(dev, 0x77, 0x0);\n\n\t\t\tpci_info(dev, \"Disabling VIA CX700 PCI caching\\n\");\n\t\t}\n\t}\n}\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_VIA, 0x324e, quirk_via_cx700_pci_parking_caching);\n\nstatic void quirk_brcm_5719_limit_mrrs(struct pci_dev *dev)\n{\n\tu32 rev;\n\n\tpci_read_config_dword(dev, 0xf4, &rev);\n\n\t \n\tif (rev == 0x05719000) {\n\t\tint readrq = pcie_get_readrq(dev);\n\t\tif (readrq > 2048)\n\t\t\tpcie_set_readrq(dev, 2048);\n\t}\n}\nDECLARE_PCI_FIXUP_ENABLE(PCI_VENDOR_ID_BROADCOM,\n\t\t\t PCI_DEVICE_ID_TIGON3_5719,\n\t\t\t quirk_brcm_5719_limit_mrrs);\n\n \nstatic void quirk_unhide_mch_dev6(struct pci_dev *dev)\n{\n\tu8 reg;\n\n\tif (pci_read_config_byte(dev, 0xF4, &reg) == 0 && !(reg & 0x02)) {\n\t\tpci_info(dev, \"Enabling MCH 'Overflow' Device\\n\");\n\t\tpci_write_config_byte(dev, 0xF4, reg | 0x02);\n\t}\n}\nDECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82865_HB,\n\t\t\tquirk_unhide_mch_dev6);\nDECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82875_HB,\n\t\t\tquirk_unhide_mch_dev6);\n\n#ifdef CONFIG_PCI_MSI\n \nstatic void quirk_disable_all_msi(struct pci_dev *dev)\n{\n\tpci_no_msi();\n\tpci_warn(dev, \"MSI quirk detected; MSI disabled\\n\");\n}\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_SERVERWORKS, PCI_DEVICE_ID_SERVERWORKS_GCNB_LE, quirk_disable_all_msi);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_RS400_200, quirk_disable_all_msi);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_RS480, quirk_disable_all_msi);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_VIA, PCI_DEVICE_ID_VIA_VT3336, quirk_disable_all_msi);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_VIA, PCI_DEVICE_ID_VIA_VT3351, quirk_disable_all_msi);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_VIA, PCI_DEVICE_ID_VIA_VT3364, quirk_disable_all_msi);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_VIA, PCI_DEVICE_ID_VIA_8380_0, quirk_disable_all_msi);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_SI, 0x0761, quirk_disable_all_msi);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_SAMSUNG, 0xa5e3, quirk_disable_all_msi);\n\n \nstatic void quirk_disable_msi(struct pci_dev *dev)\n{\n\tif (dev->subordinate) {\n\t\tpci_warn(dev, \"MSI quirk detected; subordinate MSI disabled\\n\");\n\t\tdev->subordinate->bus_flags |= PCI_BUS_FLAGS_NO_MSI;\n\t}\n}\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_8131_BRIDGE, quirk_disable_msi);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_VIA, 0xa238, quirk_disable_msi);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_ATI, 0x5a3f, quirk_disable_msi);\n\n \nstatic void quirk_amd_780_apc_msi(struct pci_dev *host_bridge)\n{\n\tstruct pci_dev *apc_bridge;\n\n\tapc_bridge = pci_get_slot(host_bridge->bus, PCI_DEVFN(1, 0));\n\tif (apc_bridge) {\n\t\tif (apc_bridge->device == 0x9602)\n\t\t\tquirk_disable_msi(apc_bridge);\n\t\tpci_dev_put(apc_bridge);\n\t}\n}\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_AMD, 0x9600, quirk_amd_780_apc_msi);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_AMD, 0x9601, quirk_amd_780_apc_msi);\n\n \nstatic int msi_ht_cap_enabled(struct pci_dev *dev)\n{\n\tint pos, ttl = PCI_FIND_CAP_TTL;\n\n\tpos = pci_find_ht_capability(dev, HT_CAPTYPE_MSI_MAPPING);\n\twhile (pos && ttl--) {\n\t\tu8 flags;\n\n\t\tif (pci_read_config_byte(dev, pos + HT_MSI_FLAGS,\n\t\t\t\t\t &flags) == 0) {\n\t\t\tpci_info(dev, \"Found %s HT MSI Mapping\\n\",\n\t\t\t\tflags & HT_MSI_FLAGS_ENABLE ?\n\t\t\t\t\"enabled\" : \"disabled\");\n\t\t\treturn (flags & HT_MSI_FLAGS_ENABLE) != 0;\n\t\t}\n\n\t\tpos = pci_find_next_ht_capability(dev, pos,\n\t\t\t\t\t\t  HT_CAPTYPE_MSI_MAPPING);\n\t}\n\treturn 0;\n}\n\n \nstatic void quirk_msi_ht_cap(struct pci_dev *dev)\n{\n\tif (!msi_ht_cap_enabled(dev))\n\t\tquirk_disable_msi(dev);\n}\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_SERVERWORKS, PCI_DEVICE_ID_SERVERWORKS_HT2000_PCIE,\n\t\t\tquirk_msi_ht_cap);\n\n \nstatic void quirk_nvidia_ck804_msi_ht_cap(struct pci_dev *dev)\n{\n\tstruct pci_dev *pdev;\n\n\t \n\tpdev = pci_get_slot(dev->bus, 0);\n\tif (!pdev)\n\t\treturn;\n\tif (!msi_ht_cap_enabled(pdev))\n\t\tquirk_msi_ht_cap(dev);\n\tpci_dev_put(pdev);\n}\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_NVIDIA, PCI_DEVICE_ID_NVIDIA_CK804_PCIE,\n\t\t\tquirk_nvidia_ck804_msi_ht_cap);\n\n \nstatic void ht_enable_msi_mapping(struct pci_dev *dev)\n{\n\tint pos, ttl = PCI_FIND_CAP_TTL;\n\n\tpos = pci_find_ht_capability(dev, HT_CAPTYPE_MSI_MAPPING);\n\twhile (pos && ttl--) {\n\t\tu8 flags;\n\n\t\tif (pci_read_config_byte(dev, pos + HT_MSI_FLAGS,\n\t\t\t\t\t &flags) == 0) {\n\t\t\tpci_info(dev, \"Enabling HT MSI Mapping\\n\");\n\n\t\t\tpci_write_config_byte(dev, pos + HT_MSI_FLAGS,\n\t\t\t\t\t      flags | HT_MSI_FLAGS_ENABLE);\n\t\t}\n\t\tpos = pci_find_next_ht_capability(dev, pos,\n\t\t\t\t\t\t  HT_CAPTYPE_MSI_MAPPING);\n\t}\n}\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_SERVERWORKS,\n\t\t\t PCI_DEVICE_ID_SERVERWORKS_HT1000_PXB,\n\t\t\t ht_enable_msi_mapping);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_8132_BRIDGE,\n\t\t\t ht_enable_msi_mapping);\n\n \nstatic void nvenet_msi_disable(struct pci_dev *dev)\n{\n\tconst char *board_name = dmi_get_system_info(DMI_BOARD_NAME);\n\n\tif (board_name &&\n\t    (strstr(board_name, \"P5N32-SLI PREMIUM\") ||\n\t     strstr(board_name, \"P5N32-E SLI\"))) {\n\t\tpci_info(dev, \"Disabling MSI for MCP55 NIC on P5N32-SLI\\n\");\n\t\tdev->no_msi = 1;\n\t}\n}\nDECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_NVIDIA,\n\t\t\tPCI_DEVICE_ID_NVIDIA_NVENET_15,\n\t\t\tnvenet_msi_disable);\n\n \nstatic void pci_quirk_nvidia_tegra_disable_rp_msi(struct pci_dev *dev)\n{\n\tdev->no_msi = 1;\n}\nDECLARE_PCI_FIXUP_CLASS_EARLY(PCI_VENDOR_ID_NVIDIA, 0x1ad0,\n\t\t\t      PCI_CLASS_BRIDGE_PCI, 8,\n\t\t\t      pci_quirk_nvidia_tegra_disable_rp_msi);\nDECLARE_PCI_FIXUP_CLASS_EARLY(PCI_VENDOR_ID_NVIDIA, 0x1ad1,\n\t\t\t      PCI_CLASS_BRIDGE_PCI, 8,\n\t\t\t      pci_quirk_nvidia_tegra_disable_rp_msi);\nDECLARE_PCI_FIXUP_CLASS_EARLY(PCI_VENDOR_ID_NVIDIA, 0x1ad2,\n\t\t\t      PCI_CLASS_BRIDGE_PCI, 8,\n\t\t\t      pci_quirk_nvidia_tegra_disable_rp_msi);\nDECLARE_PCI_FIXUP_CLASS_EARLY(PCI_VENDOR_ID_NVIDIA, 0x0bf0,\n\t\t\t      PCI_CLASS_BRIDGE_PCI, 8,\n\t\t\t      pci_quirk_nvidia_tegra_disable_rp_msi);\nDECLARE_PCI_FIXUP_CLASS_EARLY(PCI_VENDOR_ID_NVIDIA, 0x0bf1,\n\t\t\t      PCI_CLASS_BRIDGE_PCI, 8,\n\t\t\t      pci_quirk_nvidia_tegra_disable_rp_msi);\nDECLARE_PCI_FIXUP_CLASS_EARLY(PCI_VENDOR_ID_NVIDIA, 0x0e1c,\n\t\t\t      PCI_CLASS_BRIDGE_PCI, 8,\n\t\t\t      pci_quirk_nvidia_tegra_disable_rp_msi);\nDECLARE_PCI_FIXUP_CLASS_EARLY(PCI_VENDOR_ID_NVIDIA, 0x0e1d,\n\t\t\t      PCI_CLASS_BRIDGE_PCI, 8,\n\t\t\t      pci_quirk_nvidia_tegra_disable_rp_msi);\nDECLARE_PCI_FIXUP_CLASS_EARLY(PCI_VENDOR_ID_NVIDIA, 0x0e12,\n\t\t\t      PCI_CLASS_BRIDGE_PCI, 8,\n\t\t\t      pci_quirk_nvidia_tegra_disable_rp_msi);\nDECLARE_PCI_FIXUP_CLASS_EARLY(PCI_VENDOR_ID_NVIDIA, 0x0e13,\n\t\t\t      PCI_CLASS_BRIDGE_PCI, 8,\n\t\t\t      pci_quirk_nvidia_tegra_disable_rp_msi);\nDECLARE_PCI_FIXUP_CLASS_EARLY(PCI_VENDOR_ID_NVIDIA, 0x0fae,\n\t\t\t      PCI_CLASS_BRIDGE_PCI, 8,\n\t\t\t      pci_quirk_nvidia_tegra_disable_rp_msi);\nDECLARE_PCI_FIXUP_CLASS_EARLY(PCI_VENDOR_ID_NVIDIA, 0x0faf,\n\t\t\t      PCI_CLASS_BRIDGE_PCI, 8,\n\t\t\t      pci_quirk_nvidia_tegra_disable_rp_msi);\nDECLARE_PCI_FIXUP_CLASS_EARLY(PCI_VENDOR_ID_NVIDIA, 0x10e5,\n\t\t\t      PCI_CLASS_BRIDGE_PCI, 8,\n\t\t\t      pci_quirk_nvidia_tegra_disable_rp_msi);\nDECLARE_PCI_FIXUP_CLASS_EARLY(PCI_VENDOR_ID_NVIDIA, 0x10e6,\n\t\t\t      PCI_CLASS_BRIDGE_PCI, 8,\n\t\t\t      pci_quirk_nvidia_tegra_disable_rp_msi);\nDECLARE_PCI_FIXUP_CLASS_EARLY(PCI_VENDOR_ID_NVIDIA, 0x229a,\n\t\t\t      PCI_CLASS_BRIDGE_PCI, 8,\n\t\t\t      pci_quirk_nvidia_tegra_disable_rp_msi);\nDECLARE_PCI_FIXUP_CLASS_EARLY(PCI_VENDOR_ID_NVIDIA, 0x229c,\n\t\t\t      PCI_CLASS_BRIDGE_PCI, 8,\n\t\t\t      pci_quirk_nvidia_tegra_disable_rp_msi);\nDECLARE_PCI_FIXUP_CLASS_EARLY(PCI_VENDOR_ID_NVIDIA, 0x229e,\n\t\t\t      PCI_CLASS_BRIDGE_PCI, 8,\n\t\t\t      pci_quirk_nvidia_tegra_disable_rp_msi);\n\n \nstatic void nvbridge_check_legacy_irq_routing(struct pci_dev *dev)\n{\n\tu32 cfg;\n\n\tif (!pci_find_capability(dev, PCI_CAP_ID_HT))\n\t\treturn;\n\n\tpci_read_config_dword(dev, 0x74, &cfg);\n\n\tif (cfg & ((1 << 2) | (1 << 15))) {\n\t\tpr_info(\"Rewriting IRQ routing register on MCP55\\n\");\n\t\tcfg &= ~((1 << 2) | (1 << 15));\n\t\tpci_write_config_dword(dev, 0x74, cfg);\n\t}\n}\nDECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_NVIDIA,\n\t\t\tPCI_DEVICE_ID_NVIDIA_MCP55_BRIDGE_V0,\n\t\t\tnvbridge_check_legacy_irq_routing);\nDECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_NVIDIA,\n\t\t\tPCI_DEVICE_ID_NVIDIA_MCP55_BRIDGE_V4,\n\t\t\tnvbridge_check_legacy_irq_routing);\n\nstatic int ht_check_msi_mapping(struct pci_dev *dev)\n{\n\tint pos, ttl = PCI_FIND_CAP_TTL;\n\tint found = 0;\n\n\t \n\tpos = pci_find_ht_capability(dev, HT_CAPTYPE_MSI_MAPPING);\n\twhile (pos && ttl--) {\n\t\tu8 flags;\n\n\t\tif (found < 1)\n\t\t\tfound = 1;\n\t\tif (pci_read_config_byte(dev, pos + HT_MSI_FLAGS,\n\t\t\t\t\t &flags) == 0) {\n\t\t\tif (flags & HT_MSI_FLAGS_ENABLE) {\n\t\t\t\tif (found < 2) {\n\t\t\t\t\tfound = 2;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpos = pci_find_next_ht_capability(dev, pos,\n\t\t\t\t\t\t  HT_CAPTYPE_MSI_MAPPING);\n\t}\n\n\treturn found;\n}\n\nstatic int host_bridge_with_leaf(struct pci_dev *host_bridge)\n{\n\tstruct pci_dev *dev;\n\tint pos;\n\tint i, dev_no;\n\tint found = 0;\n\n\tdev_no = host_bridge->devfn >> 3;\n\tfor (i = dev_no + 1; i < 0x20; i++) {\n\t\tdev = pci_get_slot(host_bridge->bus, PCI_DEVFN(i, 0));\n\t\tif (!dev)\n\t\t\tcontinue;\n\n\t\t \n\t\tpos = pci_find_ht_capability(dev, HT_CAPTYPE_SLAVE);\n\t\tif (pos != 0) {\n\t\t\tpci_dev_put(dev);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (ht_check_msi_mapping(dev)) {\n\t\t\tfound = 1;\n\t\t\tpci_dev_put(dev);\n\t\t\tbreak;\n\t\t}\n\t\tpci_dev_put(dev);\n\t}\n\n\treturn found;\n}\n\n#define PCI_HT_CAP_SLAVE_CTRL0     4     \n#define PCI_HT_CAP_SLAVE_CTRL1     8     \n\nstatic int is_end_of_ht_chain(struct pci_dev *dev)\n{\n\tint pos, ctrl_off;\n\tint end = 0;\n\tu16 flags, ctrl;\n\n\tpos = pci_find_ht_capability(dev, HT_CAPTYPE_SLAVE);\n\n\tif (!pos)\n\t\tgoto out;\n\n\tpci_read_config_word(dev, pos + PCI_CAP_FLAGS, &flags);\n\n\tctrl_off = ((flags >> 10) & 1) ?\n\t\t\tPCI_HT_CAP_SLAVE_CTRL0 : PCI_HT_CAP_SLAVE_CTRL1;\n\tpci_read_config_word(dev, pos + ctrl_off, &ctrl);\n\n\tif (ctrl & (1 << 6))\n\t\tend = 1;\n\nout:\n\treturn end;\n}\n\nstatic void nv_ht_enable_msi_mapping(struct pci_dev *dev)\n{\n\tstruct pci_dev *host_bridge;\n\tint pos;\n\tint i, dev_no;\n\tint found = 0;\n\n\tdev_no = dev->devfn >> 3;\n\tfor (i = dev_no; i >= 0; i--) {\n\t\thost_bridge = pci_get_slot(dev->bus, PCI_DEVFN(i, 0));\n\t\tif (!host_bridge)\n\t\t\tcontinue;\n\n\t\tpos = pci_find_ht_capability(host_bridge, HT_CAPTYPE_SLAVE);\n\t\tif (pos != 0) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t\tpci_dev_put(host_bridge);\n\t}\n\n\tif (!found)\n\t\treturn;\n\n\t \n\tif (host_bridge == dev && is_end_of_ht_chain(host_bridge) &&\n\t    host_bridge_with_leaf(host_bridge))\n\t\tgoto out;\n\n\t \n\tif (msi_ht_cap_enabled(host_bridge))\n\t\tgoto out;\n\n\tht_enable_msi_mapping(dev);\n\nout:\n\tpci_dev_put(host_bridge);\n}\n\nstatic void ht_disable_msi_mapping(struct pci_dev *dev)\n{\n\tint pos, ttl = PCI_FIND_CAP_TTL;\n\n\tpos = pci_find_ht_capability(dev, HT_CAPTYPE_MSI_MAPPING);\n\twhile (pos && ttl--) {\n\t\tu8 flags;\n\n\t\tif (pci_read_config_byte(dev, pos + HT_MSI_FLAGS,\n\t\t\t\t\t &flags) == 0) {\n\t\t\tpci_info(dev, \"Disabling HT MSI Mapping\\n\");\n\n\t\t\tpci_write_config_byte(dev, pos + HT_MSI_FLAGS,\n\t\t\t\t\t      flags & ~HT_MSI_FLAGS_ENABLE);\n\t\t}\n\t\tpos = pci_find_next_ht_capability(dev, pos,\n\t\t\t\t\t\t  HT_CAPTYPE_MSI_MAPPING);\n\t}\n}\n\nstatic void __nv_msi_ht_cap_quirk(struct pci_dev *dev, int all)\n{\n\tstruct pci_dev *host_bridge;\n\tint pos;\n\tint found;\n\n\tif (!pci_msi_enabled())\n\t\treturn;\n\n\t \n\tfound = ht_check_msi_mapping(dev);\n\n\t \n\tif (found == 0)\n\t\treturn;\n\n\t \n\thost_bridge = pci_get_domain_bus_and_slot(pci_domain_nr(dev->bus), 0,\n\t\t\t\t\t\t  PCI_DEVFN(0, 0));\n\tif (host_bridge == NULL) {\n\t\tpci_warn(dev, \"nv_msi_ht_cap_quirk didn't locate host bridge\\n\");\n\t\treturn;\n\t}\n\n\tpos = pci_find_ht_capability(host_bridge, HT_CAPTYPE_SLAVE);\n\tif (pos != 0) {\n\t\t \n\t\tif (found == 1) {\n\t\t\t \n\t\t\tif (all)\n\t\t\t\tht_enable_msi_mapping(dev);\n\t\t\telse\n\t\t\t\tnv_ht_enable_msi_mapping(dev);\n\t\t}\n\t\tgoto out;\n\t}\n\n\t \n\tif (found == 1)\n\t\tgoto out;\n\n\t \n\tht_disable_msi_mapping(dev);\n\nout:\n\tpci_dev_put(host_bridge);\n}\n\nstatic void nv_msi_ht_cap_quirk_all(struct pci_dev *dev)\n{\n\treturn __nv_msi_ht_cap_quirk(dev, 1);\n}\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_AL, PCI_ANY_ID, nv_msi_ht_cap_quirk_all);\nDECLARE_PCI_FIXUP_RESUME_EARLY(PCI_VENDOR_ID_AL, PCI_ANY_ID, nv_msi_ht_cap_quirk_all);\n\nstatic void nv_msi_ht_cap_quirk_leaf(struct pci_dev *dev)\n{\n\treturn __nv_msi_ht_cap_quirk(dev, 0);\n}\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_NVIDIA, PCI_ANY_ID, nv_msi_ht_cap_quirk_leaf);\nDECLARE_PCI_FIXUP_RESUME_EARLY(PCI_VENDOR_ID_NVIDIA, PCI_ANY_ID, nv_msi_ht_cap_quirk_leaf);\n\nstatic void quirk_msi_intx_disable_bug(struct pci_dev *dev)\n{\n\tdev->dev_flags |= PCI_DEV_FLAGS_MSI_INTX_DISABLE_BUG;\n}\n\nstatic void quirk_msi_intx_disable_ati_bug(struct pci_dev *dev)\n{\n\tstruct pci_dev *p;\n\n\t \n\tp = pci_get_device(PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_SBX00_SMBUS,\n\t\t\t   NULL);\n\tif (!p)\n\t\treturn;\n\n\tif ((p->revision < 0x3B) && (p->revision >= 0x30))\n\t\tdev->dev_flags |= PCI_DEV_FLAGS_MSI_INTX_DISABLE_BUG;\n\tpci_dev_put(p);\n}\n\nstatic void quirk_msi_intx_disable_qca_bug(struct pci_dev *dev)\n{\n\t \n\tif (dev->revision < 0x18) {\n\t\tpci_info(dev, \"set MSI_INTX_DISABLE_BUG flag\\n\");\n\t\tdev->dev_flags |= PCI_DEV_FLAGS_MSI_INTX_DISABLE_BUG;\n\t}\n}\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_BROADCOM,\n\t\t\tPCI_DEVICE_ID_TIGON3_5780,\n\t\t\tquirk_msi_intx_disable_bug);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_BROADCOM,\n\t\t\tPCI_DEVICE_ID_TIGON3_5780S,\n\t\t\tquirk_msi_intx_disable_bug);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_BROADCOM,\n\t\t\tPCI_DEVICE_ID_TIGON3_5714,\n\t\t\tquirk_msi_intx_disable_bug);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_BROADCOM,\n\t\t\tPCI_DEVICE_ID_TIGON3_5714S,\n\t\t\tquirk_msi_intx_disable_bug);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_BROADCOM,\n\t\t\tPCI_DEVICE_ID_TIGON3_5715,\n\t\t\tquirk_msi_intx_disable_bug);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_BROADCOM,\n\t\t\tPCI_DEVICE_ID_TIGON3_5715S,\n\t\t\tquirk_msi_intx_disable_bug);\n\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_ATI, 0x4390,\n\t\t\tquirk_msi_intx_disable_ati_bug);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_ATI, 0x4391,\n\t\t\tquirk_msi_intx_disable_ati_bug);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_ATI, 0x4392,\n\t\t\tquirk_msi_intx_disable_ati_bug);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_ATI, 0x4393,\n\t\t\tquirk_msi_intx_disable_ati_bug);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_ATI, 0x4394,\n\t\t\tquirk_msi_intx_disable_ati_bug);\n\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_ATI, 0x4373,\n\t\t\tquirk_msi_intx_disable_bug);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_ATI, 0x4374,\n\t\t\tquirk_msi_intx_disable_bug);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_ATI, 0x4375,\n\t\t\tquirk_msi_intx_disable_bug);\n\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_ATTANSIC, 0x1062,\n\t\t\tquirk_msi_intx_disable_bug);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_ATTANSIC, 0x1063,\n\t\t\tquirk_msi_intx_disable_bug);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_ATTANSIC, 0x2060,\n\t\t\tquirk_msi_intx_disable_bug);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_ATTANSIC, 0x2062,\n\t\t\tquirk_msi_intx_disable_bug);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_ATTANSIC, 0x1073,\n\t\t\tquirk_msi_intx_disable_bug);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_ATTANSIC, 0x1083,\n\t\t\tquirk_msi_intx_disable_bug);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_ATTANSIC, 0x1090,\n\t\t\tquirk_msi_intx_disable_qca_bug);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_ATTANSIC, 0x1091,\n\t\t\tquirk_msi_intx_disable_qca_bug);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_ATTANSIC, 0x10a0,\n\t\t\tquirk_msi_intx_disable_qca_bug);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_ATTANSIC, 0x10a1,\n\t\t\tquirk_msi_intx_disable_qca_bug);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_ATTANSIC, 0xe091,\n\t\t\tquirk_msi_intx_disable_qca_bug);\n\n \nstatic void quirk_al_msi_disable(struct pci_dev *dev)\n{\n\tdev->no_msi = 1;\n\tpci_warn(dev, \"Disabling MSI/MSI-X\\n\");\n}\nDECLARE_PCI_FIXUP_CLASS_FINAL(PCI_VENDOR_ID_AMAZON_ANNAPURNA_LABS, 0x0031,\n\t\t\t      PCI_CLASS_BRIDGE_PCI, 8, quirk_al_msi_disable);\n#endif  \n\n \nstatic void quirk_hotplug_bridge(struct pci_dev *dev)\n{\n\tdev->is_hotplug_bridge = 1;\n}\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_HINT, 0x0020, quirk_hotplug_bridge);\n\n \n#ifdef CONFIG_MMC_RICOH_MMC\nstatic void ricoh_mmc_fixup_rl5c476(struct pci_dev *dev)\n{\n\tu8 write_enable;\n\tu8 write_target;\n\tu8 disable;\n\n\t \n\tif (PCI_FUNC(dev->devfn))\n\t\treturn;\n\n\tpci_read_config_byte(dev, 0xB7, &disable);\n\tif (disable & 0x02)\n\t\treturn;\n\n\tpci_read_config_byte(dev, 0x8E, &write_enable);\n\tpci_write_config_byte(dev, 0x8E, 0xAA);\n\tpci_read_config_byte(dev, 0x8D, &write_target);\n\tpci_write_config_byte(dev, 0x8D, 0xB7);\n\tpci_write_config_byte(dev, 0xB7, disable | 0x02);\n\tpci_write_config_byte(dev, 0x8E, write_enable);\n\tpci_write_config_byte(dev, 0x8D, write_target);\n\n\tpci_notice(dev, \"proprietary Ricoh MMC controller disabled (via CardBus function)\\n\");\n\tpci_notice(dev, \"MMC cards are now supported by standard SDHCI controller\\n\");\n}\nDECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_RICOH, PCI_DEVICE_ID_RICOH_RL5C476, ricoh_mmc_fixup_rl5c476);\nDECLARE_PCI_FIXUP_RESUME_EARLY(PCI_VENDOR_ID_RICOH, PCI_DEVICE_ID_RICOH_RL5C476, ricoh_mmc_fixup_rl5c476);\n\nstatic void ricoh_mmc_fixup_r5c832(struct pci_dev *dev)\n{\n\tu8 write_enable;\n\tu8 disable;\n\n\t \n\tif (PCI_FUNC(dev->devfn))\n\t\treturn;\n\t \n\tif (dev->device == PCI_DEVICE_ID_RICOH_R5CE822 ||\n\t    dev->device == PCI_DEVICE_ID_RICOH_R5CE823) {\n\t\tpci_write_config_byte(dev, 0xf9, 0xfc);\n\t\tpci_write_config_byte(dev, 0x150, 0x10);\n\t\tpci_write_config_byte(dev, 0xf9, 0x00);\n\t\tpci_write_config_byte(dev, 0xfc, 0x01);\n\t\tpci_write_config_byte(dev, 0xe1, 0x32);\n\t\tpci_write_config_byte(dev, 0xfc, 0x00);\n\n\t\tpci_notice(dev, \"MMC controller base frequency changed to 50Mhz.\\n\");\n\t}\n\n\tpci_read_config_byte(dev, 0xCB, &disable);\n\n\tif (disable & 0x02)\n\t\treturn;\n\n\tpci_read_config_byte(dev, 0xCA, &write_enable);\n\tpci_write_config_byte(dev, 0xCA, 0x57);\n\tpci_write_config_byte(dev, 0xCB, disable | 0x02);\n\tpci_write_config_byte(dev, 0xCA, write_enable);\n\n\tpci_notice(dev, \"proprietary Ricoh MMC controller disabled (via FireWire function)\\n\");\n\tpci_notice(dev, \"MMC cards are now supported by standard SDHCI controller\\n\");\n\n}\nDECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_RICOH, PCI_DEVICE_ID_RICOH_R5C832, ricoh_mmc_fixup_r5c832);\nDECLARE_PCI_FIXUP_RESUME_EARLY(PCI_VENDOR_ID_RICOH, PCI_DEVICE_ID_RICOH_R5C832, ricoh_mmc_fixup_r5c832);\nDECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_RICOH, PCI_DEVICE_ID_RICOH_R5CE822, ricoh_mmc_fixup_r5c832);\nDECLARE_PCI_FIXUP_RESUME_EARLY(PCI_VENDOR_ID_RICOH, PCI_DEVICE_ID_RICOH_R5CE822, ricoh_mmc_fixup_r5c832);\nDECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_RICOH, PCI_DEVICE_ID_RICOH_R5CE823, ricoh_mmc_fixup_r5c832);\nDECLARE_PCI_FIXUP_RESUME_EARLY(PCI_VENDOR_ID_RICOH, PCI_DEVICE_ID_RICOH_R5CE823, ricoh_mmc_fixup_r5c832);\n#endif  \n\n#ifdef CONFIG_DMAR_TABLE\n#define VTUNCERRMSK_REG\t0x1ac\n#define VTD_MSK_SPEC_ERRORS\t(1 << 31)\n \nstatic void vtd_mask_spec_errors(struct pci_dev *dev)\n{\n\tu32 word;\n\n\tpci_read_config_dword(dev, VTUNCERRMSK_REG, &word);\n\tpci_write_config_dword(dev, VTUNCERRMSK_REG, word | VTD_MSK_SPEC_ERRORS);\n}\nDECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_INTEL, 0x342e, vtd_mask_spec_errors);\nDECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_INTEL, 0x3c28, vtd_mask_spec_errors);\n#endif\n\nstatic void fixup_ti816x_class(struct pci_dev *dev)\n{\n\tu32 class = dev->class;\n\n\t \n\tdev->class = PCI_CLASS_MULTIMEDIA_VIDEO << 8;\n\tpci_info(dev, \"PCI class overridden (%#08x -> %#08x)\\n\",\n\t\t class, dev->class);\n}\nDECLARE_PCI_FIXUP_CLASS_EARLY(PCI_VENDOR_ID_TI, 0xb800,\n\t\t\t      PCI_CLASS_NOT_DEFINED, 8, fixup_ti816x_class);\n\n \nstatic void fixup_mpss_256(struct pci_dev *dev)\n{\n\tdev->pcie_mpss = 1;  \n}\nDECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_SOLARFLARE,\n\t\t\tPCI_DEVICE_ID_SOLARFLARE_SFC4000A_0, fixup_mpss_256);\nDECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_SOLARFLARE,\n\t\t\tPCI_DEVICE_ID_SOLARFLARE_SFC4000A_1, fixup_mpss_256);\nDECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_SOLARFLARE,\n\t\t\tPCI_DEVICE_ID_SOLARFLARE_SFC4000B, fixup_mpss_256);\nDECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_ASMEDIA, 0x0612, fixup_mpss_256);\n\n \nstatic void quirk_intel_mc_errata(struct pci_dev *dev)\n{\n\tint err;\n\tu16 rcc;\n\n\tif (pcie_bus_config == PCIE_BUS_TUNE_OFF ||\n\t    pcie_bus_config == PCIE_BUS_DEFAULT)\n\t\treturn;\n\n\t \n\terr = pci_read_config_word(dev, 0x48, &rcc);\n\tif (err) {\n\t\tpci_err(dev, \"Error attempting to read the read completion coalescing register\\n\");\n\t\treturn;\n\t}\n\n\tif (!(rcc & (1 << 10)))\n\t\treturn;\n\n\trcc &= ~(1 << 10);\n\n\terr = pci_write_config_word(dev, 0x48, rcc);\n\tif (err) {\n\t\tpci_err(dev, \"Error attempting to write the read completion coalescing register\\n\");\n\t\treturn;\n\t}\n\n\tpr_info_once(\"Read completion coalescing disabled due to hardware erratum relating to 256B MPS\\n\");\n}\n \nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x25c0, quirk_intel_mc_errata);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x25d0, quirk_intel_mc_errata);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x25d4, quirk_intel_mc_errata);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x25d8, quirk_intel_mc_errata);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x25e2, quirk_intel_mc_errata);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x25e3, quirk_intel_mc_errata);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x25e4, quirk_intel_mc_errata);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x25e5, quirk_intel_mc_errata);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x25e6, quirk_intel_mc_errata);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x25e7, quirk_intel_mc_errata);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x25f7, quirk_intel_mc_errata);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x25f8, quirk_intel_mc_errata);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x25f9, quirk_intel_mc_errata);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x25fa, quirk_intel_mc_errata);\n \nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x65c0, quirk_intel_mc_errata);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x65e2, quirk_intel_mc_errata);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x65e3, quirk_intel_mc_errata);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x65e4, quirk_intel_mc_errata);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x65e5, quirk_intel_mc_errata);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x65e6, quirk_intel_mc_errata);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x65e7, quirk_intel_mc_errata);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x65f7, quirk_intel_mc_errata);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x65f8, quirk_intel_mc_errata);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x65f9, quirk_intel_mc_errata);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x65fa, quirk_intel_mc_errata);\n\n \nstatic void quirk_intel_ntb(struct pci_dev *dev)\n{\n\tint rc;\n\tu8 val;\n\n\trc = pci_read_config_byte(dev, 0x00D0, &val);\n\tif (rc)\n\t\treturn;\n\n\tdev->resource[2].end = dev->resource[2].start + ((u64) 1 << val) - 1;\n\n\trc = pci_read_config_byte(dev, 0x00D1, &val);\n\tif (rc)\n\t\treturn;\n\n\tdev->resource[4].end = dev->resource[4].start + ((u64) 1 << val) - 1;\n}\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x0e08, quirk_intel_ntb);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x0e0d, quirk_intel_ntb);\n\n \n#define I915_DEIER_REG 0x4400c\nstatic void disable_igfx_irq(struct pci_dev *dev)\n{\n\tvoid __iomem *regs = pci_iomap(dev, 0, 0);\n\tif (regs == NULL) {\n\t\tpci_warn(dev, \"igfx quirk: Can't iomap PCI device\\n\");\n\t\treturn;\n\t}\n\n\t \n\tif (readl(regs + I915_DEIER_REG) != 0) {\n\t\tpci_warn(dev, \"BIOS left Intel GPU interrupts enabled; disabling\\n\");\n\n\t\twritel(0, regs + I915_DEIER_REG);\n\t}\n\n\tpci_iounmap(dev, regs);\n}\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x0042, disable_igfx_irq);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x0046, disable_igfx_irq);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x004a, disable_igfx_irq);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x0102, disable_igfx_irq);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x0106, disable_igfx_irq);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x010a, disable_igfx_irq);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x0152, disable_igfx_irq);\n\n \nstatic void quirk_remove_d3hot_delay(struct pci_dev *dev)\n{\n\tdev->d3hot_delay = 0;\n}\n \nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x0412, quirk_remove_d3hot_delay);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x0c00, quirk_remove_d3hot_delay);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x0c0c, quirk_remove_d3hot_delay);\n \nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x8c02, quirk_remove_d3hot_delay);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x8c18, quirk_remove_d3hot_delay);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x8c1c, quirk_remove_d3hot_delay);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x8c20, quirk_remove_d3hot_delay);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x8c22, quirk_remove_d3hot_delay);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x8c26, quirk_remove_d3hot_delay);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x8c2d, quirk_remove_d3hot_delay);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x8c31, quirk_remove_d3hot_delay);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x8c3a, quirk_remove_d3hot_delay);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x8c3d, quirk_remove_d3hot_delay);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x8c4e, quirk_remove_d3hot_delay);\n \nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x2280, quirk_remove_d3hot_delay);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x2298, quirk_remove_d3hot_delay);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x229c, quirk_remove_d3hot_delay);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x22b0, quirk_remove_d3hot_delay);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x22b5, quirk_remove_d3hot_delay);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x22b7, quirk_remove_d3hot_delay);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x22b8, quirk_remove_d3hot_delay);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x22d8, quirk_remove_d3hot_delay);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x22dc, quirk_remove_d3hot_delay);\n\n \nstatic void quirk_broken_intx_masking(struct pci_dev *dev)\n{\n\tdev->broken_intx_masking = 1;\n}\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_CHELSIO, 0x0030,\n\t\t\tquirk_broken_intx_masking);\nDECLARE_PCI_FIXUP_FINAL(0x1814, 0x0601,  \n\t\t\tquirk_broken_intx_masking);\nDECLARE_PCI_FIXUP_FINAL(0x1b7c, 0x0004,  \n\t\t\tquirk_broken_intx_masking);\n\n \nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_REALTEK, 0x8169,\n\t\t\tquirk_broken_intx_masking);\n\n \nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x1572, quirk_broken_intx_masking);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x1574, quirk_broken_intx_masking);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x1580, quirk_broken_intx_masking);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x1581, quirk_broken_intx_masking);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x1583, quirk_broken_intx_masking);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x1584, quirk_broken_intx_masking);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x1585, quirk_broken_intx_masking);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x1586, quirk_broken_intx_masking);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x1587, quirk_broken_intx_masking);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x1588, quirk_broken_intx_masking);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x1589, quirk_broken_intx_masking);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x158a, quirk_broken_intx_masking);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x158b, quirk_broken_intx_masking);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x37d0, quirk_broken_intx_masking);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x37d1, quirk_broken_intx_masking);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x37d2, quirk_broken_intx_masking);\n\nstatic u16 mellanox_broken_intx_devs[] = {\n\tPCI_DEVICE_ID_MELLANOX_HERMON_SDR,\n\tPCI_DEVICE_ID_MELLANOX_HERMON_DDR,\n\tPCI_DEVICE_ID_MELLANOX_HERMON_QDR,\n\tPCI_DEVICE_ID_MELLANOX_HERMON_DDR_GEN2,\n\tPCI_DEVICE_ID_MELLANOX_HERMON_QDR_GEN2,\n\tPCI_DEVICE_ID_MELLANOX_HERMON_EN,\n\tPCI_DEVICE_ID_MELLANOX_HERMON_EN_GEN2,\n\tPCI_DEVICE_ID_MELLANOX_CONNECTX_EN,\n\tPCI_DEVICE_ID_MELLANOX_CONNECTX_EN_T_GEN2,\n\tPCI_DEVICE_ID_MELLANOX_CONNECTX_EN_GEN2,\n\tPCI_DEVICE_ID_MELLANOX_CONNECTX_EN_5_GEN2,\n\tPCI_DEVICE_ID_MELLANOX_CONNECTX2,\n\tPCI_DEVICE_ID_MELLANOX_CONNECTX3,\n\tPCI_DEVICE_ID_MELLANOX_CONNECTX3_PRO,\n};\n\n#define CONNECTX_4_CURR_MAX_MINOR 99\n#define CONNECTX_4_INTX_SUPPORT_MINOR 14\n\n \nstatic void mellanox_check_broken_intx_masking(struct pci_dev *pdev)\n{\n\t__be32 __iomem *fw_ver;\n\tu16 fw_major;\n\tu16 fw_minor;\n\tu16 fw_subminor;\n\tu32 fw_maj_min;\n\tu32 fw_sub_min;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(mellanox_broken_intx_devs); i++) {\n\t\tif (pdev->device == mellanox_broken_intx_devs[i]) {\n\t\t\tpdev->broken_intx_masking = 1;\n\t\t\treturn;\n\t\t}\n\t}\n\n\t \n\tif (pdev->device == PCI_DEVICE_ID_MELLANOX_CONNECTIB)\n\t\treturn;\n\n\tif (pdev->device != PCI_DEVICE_ID_MELLANOX_CONNECTX4 &&\n\t    pdev->device != PCI_DEVICE_ID_MELLANOX_CONNECTX4_LX)\n\t\treturn;\n\n\t \n\tif (pci_enable_device_mem(pdev)) {\n\t\tpci_warn(pdev, \"Can't enable device memory\\n\");\n\t\treturn;\n\t}\n\n\tfw_ver = ioremap(pci_resource_start(pdev, 0), 4);\n\tif (!fw_ver) {\n\t\tpci_warn(pdev, \"Can't map ConnectX-4 initialization segment\\n\");\n\t\tgoto out;\n\t}\n\n\t \n\tfw_maj_min = ioread32be(fw_ver);\n\tfw_sub_min = ioread32be(fw_ver + 1);\n\tfw_major = fw_maj_min & 0xffff;\n\tfw_minor = fw_maj_min >> 16;\n\tfw_subminor = fw_sub_min & 0xffff;\n\tif (fw_minor > CONNECTX_4_CURR_MAX_MINOR ||\n\t    fw_minor < CONNECTX_4_INTX_SUPPORT_MINOR) {\n\t\tpci_warn(pdev, \"ConnectX-4: FW %u.%u.%u doesn't support INTx masking, disabling. Please upgrade FW to %d.14.1100 and up for INTx support\\n\",\n\t\t\t fw_major, fw_minor, fw_subminor, pdev->device ==\n\t\t\t PCI_DEVICE_ID_MELLANOX_CONNECTX4 ? 12 : 14);\n\t\tpdev->broken_intx_masking = 1;\n\t}\n\n\tiounmap(fw_ver);\n\nout:\n\tpci_disable_device(pdev);\n}\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_MELLANOX, PCI_ANY_ID,\n\t\t\tmellanox_check_broken_intx_masking);\n\nstatic void quirk_no_bus_reset(struct pci_dev *dev)\n{\n\tdev->dev_flags |= PCI_DEV_FLAGS_NO_BUS_RESET;\n}\n\n \nstatic void quirk_nvidia_no_bus_reset(struct pci_dev *dev)\n{\n\tif ((dev->device & 0xffc0) == 0x2340)\n\t\tquirk_no_bus_reset(dev);\n}\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_NVIDIA, PCI_ANY_ID,\n\t\t\t quirk_nvidia_no_bus_reset);\n\n \nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_ATHEROS, 0x0030, quirk_no_bus_reset);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_ATHEROS, 0x0032, quirk_no_bus_reset);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_ATHEROS, 0x003c, quirk_no_bus_reset);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_ATHEROS, 0x0033, quirk_no_bus_reset);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_ATHEROS, 0x0034, quirk_no_bus_reset);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_ATHEROS, 0x003e, quirk_no_bus_reset);\n\n \nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_CAVIUM, 0xa100, quirk_no_bus_reset);\n\n \nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_TI, 0xb005, quirk_no_bus_reset);\n\nstatic void quirk_no_pm_reset(struct pci_dev *dev)\n{\n\t \n\tif (!pci_is_root_bus(dev->bus))\n\t\tdev->dev_flags |= PCI_DEV_FLAGS_NO_PM_RESET;\n}\n\n \nDECLARE_PCI_FIXUP_CLASS_HEADER(PCI_VENDOR_ID_ATI, PCI_ANY_ID,\n\t\t\t       PCI_CLASS_DISPLAY_VGA, 8, quirk_no_pm_reset);\n\n \nstatic void quirk_thunderbolt_hotplug_msi(struct pci_dev *pdev)\n{\n\tif (pdev->is_hotplug_bridge &&\n\t    (pdev->device != PCI_DEVICE_ID_INTEL_CACTUS_RIDGE_4C ||\n\t     pdev->revision <= 1))\n\t\tpdev->no_msi = 1;\n}\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_LIGHT_RIDGE,\n\t\t\tquirk_thunderbolt_hotplug_msi);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_EAGLE_RIDGE,\n\t\t\tquirk_thunderbolt_hotplug_msi);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_LIGHT_PEAK,\n\t\t\tquirk_thunderbolt_hotplug_msi);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_CACTUS_RIDGE_4C,\n\t\t\tquirk_thunderbolt_hotplug_msi);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_PORT_RIDGE,\n\t\t\tquirk_thunderbolt_hotplug_msi);\n\n#ifdef CONFIG_ACPI\n \nstatic void quirk_apple_poweroff_thunderbolt(struct pci_dev *dev)\n{\n\tacpi_handle bridge, SXIO, SXFP, SXLV;\n\n\tif (!x86_apple_machine)\n\t\treturn;\n\tif (pci_pcie_type(dev) != PCI_EXP_TYPE_UPSTREAM)\n\t\treturn;\n\n\t \n\tif (!pm_suspend_via_firmware())\n\t\treturn;\n\n\tbridge = ACPI_HANDLE(&dev->dev);\n\tif (!bridge)\n\t\treturn;\n\n\t \n\tif (ACPI_FAILURE(acpi_get_handle(bridge, \"DSB0.NHI0.SXIO\", &SXIO))\n\t    || ACPI_FAILURE(acpi_get_handle(bridge, \"DSB0.NHI0.SXFP\", &SXFP))\n\t    || ACPI_FAILURE(acpi_get_handle(bridge, \"DSB0.NHI0.SXLV\", &SXLV)))\n\t\treturn;\n\tpci_info(dev, \"quirk: cutting power to Thunderbolt controller...\\n\");\n\n\t \n\tacpi_execute_simple_method(SXIO, NULL, 1);\n\tacpi_execute_simple_method(SXFP, NULL, 0);\n\tmsleep(300);\n\tacpi_execute_simple_method(SXLV, NULL, 0);\n\tacpi_execute_simple_method(SXIO, NULL, 0);\n\tacpi_execute_simple_method(SXLV, NULL, 0);\n}\nDECLARE_PCI_FIXUP_SUSPEND_LATE(PCI_VENDOR_ID_INTEL,\n\t\t\t       PCI_DEVICE_ID_INTEL_CACTUS_RIDGE_4C,\n\t\t\t       quirk_apple_poweroff_thunderbolt);\n#endif\n\n \nstatic int reset_intel_82599_sfp_virtfn(struct pci_dev *dev, bool probe)\n{\n\t \n\tif (!probe)\n\t\tpcie_flr(dev);\n\treturn 0;\n}\n\n#define SOUTH_CHICKEN2\t\t0xc2004\n#define PCH_PP_STATUS\t\t0xc7200\n#define PCH_PP_CONTROL\t\t0xc7204\n#define MSG_CTL\t\t\t0x45010\n#define NSDE_PWR_STATE\t\t0xd0100\n#define IGD_OPERATION_TIMEOUT\t10000      \n\nstatic int reset_ivb_igd(struct pci_dev *dev, bool probe)\n{\n\tvoid __iomem *mmio_base;\n\tunsigned long timeout;\n\tu32 val;\n\n\tif (probe)\n\t\treturn 0;\n\n\tmmio_base = pci_iomap(dev, 0, 0);\n\tif (!mmio_base)\n\t\treturn -ENOMEM;\n\n\tiowrite32(0x00000002, mmio_base + MSG_CTL);\n\n\t \n\tiowrite32(0x00000005, mmio_base + SOUTH_CHICKEN2);\n\n\tval = ioread32(mmio_base + PCH_PP_CONTROL) & 0xfffffffe;\n\tiowrite32(val, mmio_base + PCH_PP_CONTROL);\n\n\ttimeout = jiffies + msecs_to_jiffies(IGD_OPERATION_TIMEOUT);\n\tdo {\n\t\tval = ioread32(mmio_base + PCH_PP_STATUS);\n\t\tif ((val & 0xb0000000) == 0)\n\t\t\tgoto reset_complete;\n\t\tmsleep(10);\n\t} while (time_before(jiffies, timeout));\n\tpci_warn(dev, \"timeout during reset\\n\");\n\nreset_complete:\n\tiowrite32(0x00000002, mmio_base + NSDE_PWR_STATE);\n\n\tpci_iounmap(dev, mmio_base);\n\treturn 0;\n}\n\n \nstatic int reset_chelsio_generic_dev(struct pci_dev *dev, bool probe)\n{\n\tu16 old_command;\n\tu16 msix_flags;\n\n\t \n\tif ((dev->device & 0xf000) != 0x4000)\n\t\treturn -ENOTTY;\n\n\t \n\tif (probe)\n\t\treturn 0;\n\n\t \n\tpci_read_config_word(dev, PCI_COMMAND, &old_command);\n\tpci_write_config_word(dev, PCI_COMMAND,\n\t\t\t      old_command | PCI_COMMAND_MASTER);\n\n\t \n\tpci_save_state(dev);\n\n\t \n\tpci_read_config_word(dev, dev->msix_cap+PCI_MSIX_FLAGS, &msix_flags);\n\tif ((msix_flags & PCI_MSIX_FLAGS_ENABLE) == 0)\n\t\tpci_write_config_word(dev, dev->msix_cap+PCI_MSIX_FLAGS,\n\t\t\t\t      msix_flags |\n\t\t\t\t      PCI_MSIX_FLAGS_ENABLE |\n\t\t\t\t      PCI_MSIX_FLAGS_MASKALL);\n\n\tpcie_flr(dev);\n\n\t \n\tpci_restore_state(dev);\n\tpci_write_config_word(dev, PCI_COMMAND, old_command);\n\treturn 0;\n}\n\n#define PCI_DEVICE_ID_INTEL_82599_SFP_VF   0x10ed\n#define PCI_DEVICE_ID_INTEL_IVB_M_VGA      0x0156\n#define PCI_DEVICE_ID_INTEL_IVB_M2_VGA     0x0166\n\n \nstatic int nvme_disable_and_flr(struct pci_dev *dev, bool probe)\n{\n\tvoid __iomem *bar;\n\tu16 cmd;\n\tu32 cfg;\n\n\tif (dev->class != PCI_CLASS_STORAGE_EXPRESS ||\n\t    pcie_reset_flr(dev, PCI_RESET_PROBE) || !pci_resource_start(dev, 0))\n\t\treturn -ENOTTY;\n\n\tif (probe)\n\t\treturn 0;\n\n\tbar = pci_iomap(dev, 0, NVME_REG_CC + sizeof(cfg));\n\tif (!bar)\n\t\treturn -ENOTTY;\n\n\tpci_read_config_word(dev, PCI_COMMAND, &cmd);\n\tpci_write_config_word(dev, PCI_COMMAND, cmd | PCI_COMMAND_MEMORY);\n\n\tcfg = readl(bar + NVME_REG_CC);\n\n\t \n\tif (cfg & NVME_CC_ENABLE) {\n\t\tu32 cap = readl(bar + NVME_REG_CAP);\n\t\tunsigned long timeout;\n\n\t\t \n\t\tcfg &= ~(NVME_CC_SHN_MASK | NVME_CC_ENABLE);\n\n\t\twritel(cfg, bar + NVME_REG_CC);\n\n\t\t \n\n\t\t \n\t\ttimeout = ((NVME_CAP_TIMEOUT(cap) + 1) * HZ / 2) + jiffies;\n\n\t\tfor (;;) {\n\t\t\tu32 status = readl(bar + NVME_REG_CSTS);\n\n\t\t\t \n\t\t\tif (!(status & NVME_CSTS_RDY))\n\t\t\t\tbreak;\n\n\t\t\tmsleep(100);\n\n\t\t\tif (time_after(jiffies, timeout)) {\n\t\t\t\tpci_warn(dev, \"Timeout waiting for NVMe ready status to clear after disable\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tpci_iounmap(dev, bar);\n\n\tpcie_flr(dev);\n\n\treturn 0;\n}\n\n \nstatic int delay_250ms_after_flr(struct pci_dev *dev, bool probe)\n{\n\tif (probe)\n\t\treturn pcie_reset_flr(dev, PCI_RESET_PROBE);\n\n\tpcie_reset_flr(dev, PCI_RESET_DO_RESET);\n\n\tmsleep(250);\n\n\treturn 0;\n}\n\n#define PCI_DEVICE_ID_HINIC_VF      0x375E\n#define HINIC_VF_FLR_TYPE           0x1000\n#define HINIC_VF_FLR_CAP_BIT        (1UL << 30)\n#define HINIC_VF_OP                 0xE80\n#define HINIC_VF_FLR_PROC_BIT       (1UL << 18)\n#define HINIC_OPERATION_TIMEOUT     15000\t \n\n \nstatic int reset_hinic_vf_dev(struct pci_dev *pdev, bool probe)\n{\n\tunsigned long timeout;\n\tvoid __iomem *bar;\n\tu32 val;\n\n\tif (probe)\n\t\treturn 0;\n\n\tbar = pci_iomap(pdev, 0, 0);\n\tif (!bar)\n\t\treturn -ENOTTY;\n\n\t \n\tval = ioread32be(bar + HINIC_VF_FLR_TYPE);\n\tif (!(val & HINIC_VF_FLR_CAP_BIT)) {\n\t\tpci_iounmap(pdev, bar);\n\t\treturn -ENOTTY;\n\t}\n\n\t \n\tval = ioread32be(bar + HINIC_VF_OP);\n\tval = val | HINIC_VF_FLR_PROC_BIT;\n\tiowrite32be(val, bar + HINIC_VF_OP);\n\n\tpcie_flr(pdev);\n\n\t \n\tpci_write_config_word(pdev, PCI_VENDOR_ID, 0);\n\n\t \n\ttimeout = jiffies + msecs_to_jiffies(HINIC_OPERATION_TIMEOUT);\n\tdo {\n\t\tval = ioread32be(bar + HINIC_VF_OP);\n\t\tif (!(val & HINIC_VF_FLR_PROC_BIT))\n\t\t\tgoto reset_complete;\n\t\tmsleep(20);\n\t} while (time_before(jiffies, timeout));\n\n\tval = ioread32be(bar + HINIC_VF_OP);\n\tif (!(val & HINIC_VF_FLR_PROC_BIT))\n\t\tgoto reset_complete;\n\n\tpci_warn(pdev, \"Reset dev timeout, FLR ack reg: %#010x\\n\", val);\n\nreset_complete:\n\tpci_iounmap(pdev, bar);\n\n\treturn 0;\n}\n\nstatic const struct pci_dev_reset_methods pci_dev_reset_methods[] = {\n\t{ PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82599_SFP_VF,\n\t\t reset_intel_82599_sfp_virtfn },\n\t{ PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_IVB_M_VGA,\n\t\treset_ivb_igd },\n\t{ PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_IVB_M2_VGA,\n\t\treset_ivb_igd },\n\t{ PCI_VENDOR_ID_SAMSUNG, 0xa804, nvme_disable_and_flr },\n\t{ PCI_VENDOR_ID_INTEL, 0x0953, delay_250ms_after_flr },\n\t{ PCI_VENDOR_ID_INTEL, 0x0a54, delay_250ms_after_flr },\n\t{ PCI_VENDOR_ID_SOLIDIGM, 0xf1ac, delay_250ms_after_flr },\n\t{ PCI_VENDOR_ID_CHELSIO, PCI_ANY_ID,\n\t\treset_chelsio_generic_dev },\n\t{ PCI_VENDOR_ID_HUAWEI, PCI_DEVICE_ID_HINIC_VF,\n\t\treset_hinic_vf_dev },\n\t{ 0 }\n};\n\n \nint pci_dev_specific_reset(struct pci_dev *dev, bool probe)\n{\n\tconst struct pci_dev_reset_methods *i;\n\n\tfor (i = pci_dev_reset_methods; i->reset; i++) {\n\t\tif ((i->vendor == dev->vendor ||\n\t\t     i->vendor == (u16)PCI_ANY_ID) &&\n\t\t    (i->device == dev->device ||\n\t\t     i->device == (u16)PCI_ANY_ID))\n\t\t\treturn i->reset(dev, probe);\n\t}\n\n\treturn -ENOTTY;\n}\n\nstatic void quirk_dma_func0_alias(struct pci_dev *dev)\n{\n\tif (PCI_FUNC(dev->devfn) != 0)\n\t\tpci_add_dma_alias(dev, PCI_DEVFN(PCI_SLOT(dev->devfn), 0), 1);\n}\n\n \nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_RICOH, 0xe832, quirk_dma_func0_alias);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_RICOH, 0xe476, quirk_dma_func0_alias);\n\nstatic void quirk_dma_func1_alias(struct pci_dev *dev)\n{\n\tif (PCI_FUNC(dev->devfn) != 1)\n\t\tpci_add_dma_alias(dev, PCI_DEVFN(PCI_SLOT(dev->devfn), 1), 1);\n}\n\n \nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_MARVELL_EXT, 0x9120,\n\t\t\t quirk_dma_func1_alias);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_MARVELL_EXT, 0x9123,\n\t\t\t quirk_dma_func1_alias);\n \nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_MARVELL_EXT, 0x9125,\n\t\t\t quirk_dma_func1_alias);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_MARVELL_EXT, 0x9128,\n\t\t\t quirk_dma_func1_alias);\n \nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_MARVELL_EXT, 0x9130,\n\t\t\t quirk_dma_func1_alias);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_MARVELL_EXT, 0x9170,\n\t\t\t quirk_dma_func1_alias);\n \nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_MARVELL_EXT, 0x9172,\n\t\t\t quirk_dma_func1_alias);\n \nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_MARVELL_EXT, 0x917a,\n\t\t\t quirk_dma_func1_alias);\n \nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_MARVELL_EXT, 0x9182,\n\t\t\t quirk_dma_func1_alias);\n \nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_MARVELL_EXT, 0x9183,\n\t\t\t quirk_dma_func1_alias);\n \nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_MARVELL_EXT, 0x91a0,\n\t\t\t quirk_dma_func1_alias);\n \nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_MARVELL_EXT, 0x9215,\n\t\t\t quirk_dma_func1_alias);\n \nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_MARVELL_EXT, 0x9220,\n\t\t\t quirk_dma_func1_alias);\n \nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_MARVELL_EXT, 0x9230,\n\t\t\t quirk_dma_func1_alias);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_MARVELL_EXT, 0x9235,\n\t\t\t quirk_dma_func1_alias);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_TTI, 0x0642,\n\t\t\t quirk_dma_func1_alias);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_TTI, 0x0645,\n\t\t\t quirk_dma_func1_alias);\n \nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_JMICRON,\n\t\t\t PCI_DEVICE_ID_JMICRON_JMB388_ESD,\n\t\t\t quirk_dma_func1_alias);\n \nDECLARE_PCI_FIXUP_HEADER(0x1c28,  \n\t\t\t 0x0122,  \n\t\t\t quirk_dma_func1_alias);\n\n \nstatic const struct pci_device_id fixed_dma_alias_tbl[] = {\n\t{ PCI_DEVICE_SUB(PCI_VENDOR_ID_ADAPTEC2, 0x0285,\n\t\t\t PCI_VENDOR_ID_ADAPTEC2, 0x02bb),  \n\t  .driver_data = PCI_DEVFN(1, 0) },\n\t{ PCI_DEVICE_SUB(PCI_VENDOR_ID_ADAPTEC2, 0x0285,\n\t\t\t PCI_VENDOR_ID_ADAPTEC2, 0x02bc),  \n\t  .driver_data = PCI_DEVFN(1, 0) },\n\t{ 0 }\n};\n\nstatic void quirk_fixed_dma_alias(struct pci_dev *dev)\n{\n\tconst struct pci_device_id *id;\n\n\tid = pci_match_id(fixed_dma_alias_tbl, dev);\n\tif (id)\n\t\tpci_add_dma_alias(dev, id->driver_data, 1);\n}\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_ADAPTEC2, 0x0285, quirk_fixed_dma_alias);\n\n \nstatic void quirk_use_pcie_bridge_dma_alias(struct pci_dev *pdev)\n{\n\tif (!pci_is_root_bus(pdev->bus) &&\n\t    pdev->hdr_type == PCI_HEADER_TYPE_BRIDGE &&\n\t    !pci_is_pcie(pdev) && pci_is_pcie(pdev->bus->self) &&\n\t    pci_pcie_type(pdev->bus->self) != PCI_EXP_TYPE_PCI_BRIDGE)\n\t\tpdev->dev_flags |= PCI_DEV_FLAG_PCIE_BRIDGE_ALIAS;\n}\n \nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_ASMEDIA, 0x1080,\n\t\t\t quirk_use_pcie_bridge_dma_alias);\n \nDECLARE_PCI_FIXUP_HEADER(0x10e3, 0x8113, quirk_use_pcie_bridge_dma_alias);\n \nDECLARE_PCI_FIXUP_HEADER(0x1283, 0x8892, quirk_use_pcie_bridge_dma_alias);\n \nDECLARE_PCI_FIXUP_HEADER(0x1283, 0x8893, quirk_use_pcie_bridge_dma_alias);\n \nDECLARE_PCI_FIXUP_HEADER(0x8086, 0x244e, quirk_use_pcie_bridge_dma_alias);\n\n \nstatic void quirk_mic_x200_dma_alias(struct pci_dev *pdev)\n{\n\tpci_add_dma_alias(pdev, PCI_DEVFN(0x10, 0x0), 1);\n\tpci_add_dma_alias(pdev, PCI_DEVFN(0x11, 0x0), 1);\n\tpci_add_dma_alias(pdev, PCI_DEVFN(0x12, 0x3), 1);\n}\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x2260, quirk_mic_x200_dma_alias);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x2264, quirk_mic_x200_dma_alias);\n\n \nstatic void quirk_pex_vca_alias(struct pci_dev *pdev)\n{\n\tconst unsigned int num_pci_slots = 0x20;\n\tunsigned int slot;\n\n\tfor (slot = 0; slot < num_pci_slots; slot++)\n\t\tpci_add_dma_alias(pdev, PCI_DEVFN(slot, 0x0), 5);\n}\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x2954, quirk_pex_vca_alias);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x2955, quirk_pex_vca_alias);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x2956, quirk_pex_vca_alias);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x2958, quirk_pex_vca_alias);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x2959, quirk_pex_vca_alias);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x295A, quirk_pex_vca_alias);\n\n \nstatic void quirk_bridge_cavm_thrx2_pcie_root(struct pci_dev *pdev)\n{\n\tpdev->dev_flags |= PCI_DEV_FLAGS_BRIDGE_XLATE_ROOT;\n}\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_BROADCOM, 0x9000,\n\t\t\t\tquirk_bridge_cavm_thrx2_pcie_root);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_BROADCOM, 0x9084,\n\t\t\t\tquirk_bridge_cavm_thrx2_pcie_root);\n\n \nstatic void quirk_tw686x_class(struct pci_dev *pdev)\n{\n\tu32 class = pdev->class;\n\n\t \n\tpdev->class = (PCI_CLASS_MULTIMEDIA_OTHER << 8) | 0x01;\n\tpci_info(pdev, \"TW686x PCI class overridden (%#08x -> %#08x)\\n\",\n\t\t class, pdev->class);\n}\nDECLARE_PCI_FIXUP_CLASS_EARLY(0x1797, 0x6864, PCI_CLASS_NOT_DEFINED, 8,\n\t\t\t      quirk_tw686x_class);\nDECLARE_PCI_FIXUP_CLASS_EARLY(0x1797, 0x6865, PCI_CLASS_NOT_DEFINED, 8,\n\t\t\t      quirk_tw686x_class);\nDECLARE_PCI_FIXUP_CLASS_EARLY(0x1797, 0x6868, PCI_CLASS_NOT_DEFINED, 8,\n\t\t\t      quirk_tw686x_class);\nDECLARE_PCI_FIXUP_CLASS_EARLY(0x1797, 0x6869, PCI_CLASS_NOT_DEFINED, 8,\n\t\t\t      quirk_tw686x_class);\n\n \nstatic void quirk_relaxedordering_disable(struct pci_dev *dev)\n{\n\tdev->dev_flags |= PCI_DEV_FLAGS_NO_RELAXED_ORDERING;\n\tpci_info(dev, \"Disable Relaxed Ordering Attributes to avoid PCIe Completion erratum\\n\");\n}\n\n \nDECLARE_PCI_FIXUP_CLASS_EARLY(PCI_VENDOR_ID_INTEL, 0x6f01, PCI_CLASS_NOT_DEFINED, 8,\n\t\t\t      quirk_relaxedordering_disable);\nDECLARE_PCI_FIXUP_CLASS_EARLY(PCI_VENDOR_ID_INTEL, 0x6f02, PCI_CLASS_NOT_DEFINED, 8,\n\t\t\t      quirk_relaxedordering_disable);\nDECLARE_PCI_FIXUP_CLASS_EARLY(PCI_VENDOR_ID_INTEL, 0x6f03, PCI_CLASS_NOT_DEFINED, 8,\n\t\t\t      quirk_relaxedordering_disable);\nDECLARE_PCI_FIXUP_CLASS_EARLY(PCI_VENDOR_ID_INTEL, 0x6f04, PCI_CLASS_NOT_DEFINED, 8,\n\t\t\t      quirk_relaxedordering_disable);\nDECLARE_PCI_FIXUP_CLASS_EARLY(PCI_VENDOR_ID_INTEL, 0x6f05, PCI_CLASS_NOT_DEFINED, 8,\n\t\t\t      quirk_relaxedordering_disable);\nDECLARE_PCI_FIXUP_CLASS_EARLY(PCI_VENDOR_ID_INTEL, 0x6f06, PCI_CLASS_NOT_DEFINED, 8,\n\t\t\t      quirk_relaxedordering_disable);\nDECLARE_PCI_FIXUP_CLASS_EARLY(PCI_VENDOR_ID_INTEL, 0x6f07, PCI_CLASS_NOT_DEFINED, 8,\n\t\t\t      quirk_relaxedordering_disable);\nDECLARE_PCI_FIXUP_CLASS_EARLY(PCI_VENDOR_ID_INTEL, 0x6f08, PCI_CLASS_NOT_DEFINED, 8,\n\t\t\t      quirk_relaxedordering_disable);\nDECLARE_PCI_FIXUP_CLASS_EARLY(PCI_VENDOR_ID_INTEL, 0x6f09, PCI_CLASS_NOT_DEFINED, 8,\n\t\t\t      quirk_relaxedordering_disable);\nDECLARE_PCI_FIXUP_CLASS_EARLY(PCI_VENDOR_ID_INTEL, 0x6f0a, PCI_CLASS_NOT_DEFINED, 8,\n\t\t\t      quirk_relaxedordering_disable);\nDECLARE_PCI_FIXUP_CLASS_EARLY(PCI_VENDOR_ID_INTEL, 0x6f0b, PCI_CLASS_NOT_DEFINED, 8,\n\t\t\t      quirk_relaxedordering_disable);\nDECLARE_PCI_FIXUP_CLASS_EARLY(PCI_VENDOR_ID_INTEL, 0x6f0c, PCI_CLASS_NOT_DEFINED, 8,\n\t\t\t      quirk_relaxedordering_disable);\nDECLARE_PCI_FIXUP_CLASS_EARLY(PCI_VENDOR_ID_INTEL, 0x6f0d, PCI_CLASS_NOT_DEFINED, 8,\n\t\t\t      quirk_relaxedordering_disable);\nDECLARE_PCI_FIXUP_CLASS_EARLY(PCI_VENDOR_ID_INTEL, 0x6f0e, PCI_CLASS_NOT_DEFINED, 8,\n\t\t\t      quirk_relaxedordering_disable);\nDECLARE_PCI_FIXUP_CLASS_EARLY(PCI_VENDOR_ID_INTEL, 0x2f01, PCI_CLASS_NOT_DEFINED, 8,\n\t\t\t      quirk_relaxedordering_disable);\nDECLARE_PCI_FIXUP_CLASS_EARLY(PCI_VENDOR_ID_INTEL, 0x2f02, PCI_CLASS_NOT_DEFINED, 8,\n\t\t\t      quirk_relaxedordering_disable);\nDECLARE_PCI_FIXUP_CLASS_EARLY(PCI_VENDOR_ID_INTEL, 0x2f03, PCI_CLASS_NOT_DEFINED, 8,\n\t\t\t      quirk_relaxedordering_disable);\nDECLARE_PCI_FIXUP_CLASS_EARLY(PCI_VENDOR_ID_INTEL, 0x2f04, PCI_CLASS_NOT_DEFINED, 8,\n\t\t\t      quirk_relaxedordering_disable);\nDECLARE_PCI_FIXUP_CLASS_EARLY(PCI_VENDOR_ID_INTEL, 0x2f05, PCI_CLASS_NOT_DEFINED, 8,\n\t\t\t      quirk_relaxedordering_disable);\nDECLARE_PCI_FIXUP_CLASS_EARLY(PCI_VENDOR_ID_INTEL, 0x2f06, PCI_CLASS_NOT_DEFINED, 8,\n\t\t\t      quirk_relaxedordering_disable);\nDECLARE_PCI_FIXUP_CLASS_EARLY(PCI_VENDOR_ID_INTEL, 0x2f07, PCI_CLASS_NOT_DEFINED, 8,\n\t\t\t      quirk_relaxedordering_disable);\nDECLARE_PCI_FIXUP_CLASS_EARLY(PCI_VENDOR_ID_INTEL, 0x2f08, PCI_CLASS_NOT_DEFINED, 8,\n\t\t\t      quirk_relaxedordering_disable);\nDECLARE_PCI_FIXUP_CLASS_EARLY(PCI_VENDOR_ID_INTEL, 0x2f09, PCI_CLASS_NOT_DEFINED, 8,\n\t\t\t      quirk_relaxedordering_disable);\nDECLARE_PCI_FIXUP_CLASS_EARLY(PCI_VENDOR_ID_INTEL, 0x2f0a, PCI_CLASS_NOT_DEFINED, 8,\n\t\t\t      quirk_relaxedordering_disable);\nDECLARE_PCI_FIXUP_CLASS_EARLY(PCI_VENDOR_ID_INTEL, 0x2f0b, PCI_CLASS_NOT_DEFINED, 8,\n\t\t\t      quirk_relaxedordering_disable);\nDECLARE_PCI_FIXUP_CLASS_EARLY(PCI_VENDOR_ID_INTEL, 0x2f0c, PCI_CLASS_NOT_DEFINED, 8,\n\t\t\t      quirk_relaxedordering_disable);\nDECLARE_PCI_FIXUP_CLASS_EARLY(PCI_VENDOR_ID_INTEL, 0x2f0d, PCI_CLASS_NOT_DEFINED, 8,\n\t\t\t      quirk_relaxedordering_disable);\nDECLARE_PCI_FIXUP_CLASS_EARLY(PCI_VENDOR_ID_INTEL, 0x2f0e, PCI_CLASS_NOT_DEFINED, 8,\n\t\t\t      quirk_relaxedordering_disable);\n\n \nDECLARE_PCI_FIXUP_CLASS_EARLY(PCI_VENDOR_ID_AMD, 0x1a00, PCI_CLASS_NOT_DEFINED, 8,\n\t\t\t      quirk_relaxedordering_disable);\nDECLARE_PCI_FIXUP_CLASS_EARLY(PCI_VENDOR_ID_AMD, 0x1a01, PCI_CLASS_NOT_DEFINED, 8,\n\t\t\t      quirk_relaxedordering_disable);\nDECLARE_PCI_FIXUP_CLASS_EARLY(PCI_VENDOR_ID_AMD, 0x1a02, PCI_CLASS_NOT_DEFINED, 8,\n\t\t\t      quirk_relaxedordering_disable);\n\n \nstatic void quirk_disable_root_port_attributes(struct pci_dev *pdev)\n{\n\tstruct pci_dev *root_port = pcie_find_root_port(pdev);\n\n\tif (!root_port) {\n\t\tpci_warn(pdev, \"PCIe Completion erratum may cause device errors\\n\");\n\t\treturn;\n\t}\n\n\tpci_info(root_port, \"Disabling No Snoop/Relaxed Ordering Attributes to avoid PCIe Completion erratum in %s\\n\",\n\t\t dev_name(&pdev->dev));\n\tpcie_capability_clear_and_set_word(root_port, PCI_EXP_DEVCTL,\n\t\t\t\t\t   PCI_EXP_DEVCTL_RELAX_EN |\n\t\t\t\t\t   PCI_EXP_DEVCTL_NOSNOOP_EN, 0);\n}\n\n \nstatic void quirk_chelsio_T5_disable_root_port_attributes(struct pci_dev *pdev)\n{\n\t \n\tif ((pdev->device & 0xff00) == 0x5400)\n\t\tquirk_disable_root_port_attributes(pdev);\n}\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_CHELSIO, PCI_ANY_ID,\n\t\t\t quirk_chelsio_T5_disable_root_port_attributes);\n\n \nstatic int pci_acs_ctrl_enabled(u16 acs_ctrl_req, u16 acs_ctrl_ena)\n{\n\tif ((acs_ctrl_req & acs_ctrl_ena) == acs_ctrl_req)\n\t\treturn 1;\n\treturn 0;\n}\n\n \nstatic int pci_quirk_amd_sb_acs(struct pci_dev *dev, u16 acs_flags)\n{\n#ifdef CONFIG_ACPI\n\tstruct acpi_table_header *header = NULL;\n\tacpi_status status;\n\n\t \n\tif (!dev->multifunction || !pci_is_root_bus(dev->bus))\n\t\treturn -ENODEV;\n\n\t \n\tstatus = acpi_get_table(\"IVRS\", 0, &header);\n\tif (ACPI_FAILURE(status))\n\t\treturn -ENODEV;\n\n\tacpi_put_table(header);\n\n\t \n\tacs_flags &= (PCI_ACS_RR | PCI_ACS_CR | PCI_ACS_EC | PCI_ACS_DT);\n\n\treturn pci_acs_ctrl_enabled(acs_flags, PCI_ACS_RR | PCI_ACS_CR);\n#else\n\treturn -ENODEV;\n#endif\n}\n\nstatic bool pci_quirk_cavium_acs_match(struct pci_dev *dev)\n{\n\tif (!pci_is_pcie(dev) || pci_pcie_type(dev) != PCI_EXP_TYPE_ROOT_PORT)\n\t\treturn false;\n\n\tswitch (dev->device) {\n\t \n\tcase 0xa000 ... 0xa7ff:  \n\tcase 0xaf84:   \n\tcase 0xb884:   \n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic int pci_quirk_cavium_acs(struct pci_dev *dev, u16 acs_flags)\n{\n\tif (!pci_quirk_cavium_acs_match(dev))\n\t\treturn -ENOTTY;\n\n\t \n\treturn pci_acs_ctrl_enabled(acs_flags,\n\t\tPCI_ACS_SV | PCI_ACS_RR | PCI_ACS_CR | PCI_ACS_UF);\n}\n\nstatic int pci_quirk_xgene_acs(struct pci_dev *dev, u16 acs_flags)\n{\n\t \n\treturn pci_acs_ctrl_enabled(acs_flags,\n\t\tPCI_ACS_SV | PCI_ACS_RR | PCI_ACS_CR | PCI_ACS_UF);\n}\n\n \nstatic int pci_quirk_zhaoxin_pcie_ports_acs(struct pci_dev *dev, u16 acs_flags)\n{\n\tif (!pci_is_pcie(dev) ||\n\t    ((pci_pcie_type(dev) != PCI_EXP_TYPE_ROOT_PORT) &&\n\t     (pci_pcie_type(dev) != PCI_EXP_TYPE_DOWNSTREAM)))\n\t\treturn -ENOTTY;\n\n\t \n\tswitch (dev->device) {\n\tcase 0x0710 ... 0x071e:\n\tcase 0x0721:\n\tcase 0x0723 ... 0x0752:\n\t\treturn pci_acs_ctrl_enabled(acs_flags,\n\t\t\tPCI_ACS_SV | PCI_ACS_RR | PCI_ACS_CR | PCI_ACS_UF);\n\t}\n\n\treturn false;\n}\n\n \nstatic const u16 pci_quirk_intel_pch_acs_ids[] = {\n\t \n\t0x3b42, 0x3b43, 0x3b44, 0x3b45, 0x3b46, 0x3b47, 0x3b48, 0x3b49,\n\t0x3b4a, 0x3b4b, 0x3b4c, 0x3b4d, 0x3b4e, 0x3b4f, 0x3b50, 0x3b51,\n\t \n\t0x1c10, 0x1c11, 0x1c12, 0x1c13, 0x1c14, 0x1c15, 0x1c16, 0x1c17,\n\t0x1c18, 0x1c19, 0x1c1a, 0x1c1b, 0x1c1c, 0x1c1d, 0x1c1e, 0x1c1f,\n\t \n\t0x1e10, 0x1e11, 0x1e12, 0x1e13, 0x1e14, 0x1e15, 0x1e16, 0x1e17,\n\t0x1e18, 0x1e19, 0x1e1a, 0x1e1b, 0x1e1c, 0x1e1d, 0x1e1e, 0x1e1f,\n\t \n\t0x8c10, 0x8c11, 0x8c12, 0x8c13, 0x8c14, 0x8c15, 0x8c16, 0x8c17,\n\t0x8c18, 0x8c19, 0x8c1a, 0x8c1b, 0x8c1c, 0x8c1d, 0x8c1e, 0x8c1f,\n\t \n\t0x9c10, 0x9c11, 0x9c12, 0x9c13, 0x9c14, 0x9c15, 0x9c16, 0x9c17,\n\t0x9c18, 0x9c19, 0x9c1a, 0x9c1b,\n\t \n\t0x9c90, 0x9c91, 0x9c92, 0x9c93, 0x9c94, 0x9c95, 0x9c96, 0x9c97,\n\t0x9c98, 0x9c99, 0x9c9a, 0x9c9b,\n\t \n\t0x1d10, 0x1d12, 0x1d14, 0x1d16, 0x1d18, 0x1d1a, 0x1d1c, 0x1d1e,\n\t \n\t0x8d10, 0x8d11, 0x8d12, 0x8d13, 0x8d14, 0x8d15, 0x8d16, 0x8d17,\n\t0x8d18, 0x8d19, 0x8d1a, 0x8d1b, 0x8d1c, 0x8d1d, 0x8d1e,\n\t \n\t0x8c90, 0x8c92, 0x8c94, 0x8c96, 0x8c98, 0x8c9a, 0x8c9c, 0x8c9e,\n};\n\nstatic bool pci_quirk_intel_pch_acs_match(struct pci_dev *dev)\n{\n\tint i;\n\n\t \n\tif (!pci_is_pcie(dev) || pci_pcie_type(dev) != PCI_EXP_TYPE_ROOT_PORT)\n\t\treturn false;\n\n\tfor (i = 0; i < ARRAY_SIZE(pci_quirk_intel_pch_acs_ids); i++)\n\t\tif (pci_quirk_intel_pch_acs_ids[i] == dev->device)\n\t\t\treturn true;\n\n\treturn false;\n}\n\nstatic int pci_quirk_intel_pch_acs(struct pci_dev *dev, u16 acs_flags)\n{\n\tif (!pci_quirk_intel_pch_acs_match(dev))\n\t\treturn -ENOTTY;\n\n\tif (dev->dev_flags & PCI_DEV_FLAGS_ACS_ENABLED_QUIRK)\n\t\treturn pci_acs_ctrl_enabled(acs_flags,\n\t\t\tPCI_ACS_SV | PCI_ACS_RR | PCI_ACS_CR | PCI_ACS_UF);\n\n\treturn pci_acs_ctrl_enabled(acs_flags, 0);\n}\n\n \nstatic int pci_quirk_qcom_rp_acs(struct pci_dev *dev, u16 acs_flags)\n{\n\treturn pci_acs_ctrl_enabled(acs_flags,\n\t\tPCI_ACS_SV | PCI_ACS_RR | PCI_ACS_CR | PCI_ACS_UF);\n}\n\n \nstatic int pci_quirk_nxp_rp_acs(struct pci_dev *dev, u16 acs_flags)\n{\n\treturn pci_acs_ctrl_enabled(acs_flags,\n\t\tPCI_ACS_SV | PCI_ACS_RR | PCI_ACS_CR | PCI_ACS_UF);\n}\n\nstatic int pci_quirk_al_acs(struct pci_dev *dev, u16 acs_flags)\n{\n\tif (pci_pcie_type(dev) != PCI_EXP_TYPE_ROOT_PORT)\n\t\treturn -ENOTTY;\n\n\t \n\tacs_flags &= ~(PCI_ACS_SV | PCI_ACS_RR | PCI_ACS_CR | PCI_ACS_UF);\n\n\treturn acs_flags ? 0 : 1;\n}\n\n \nstatic bool pci_quirk_intel_spt_pch_acs_match(struct pci_dev *dev)\n{\n\tif (!pci_is_pcie(dev) || pci_pcie_type(dev) != PCI_EXP_TYPE_ROOT_PORT)\n\t\treturn false;\n\n\tswitch (dev->device) {\n\tcase 0xa110 ... 0xa11f: case 0xa167 ... 0xa16a:  \n\tcase 0xa290 ... 0xa29f: case 0xa2e7 ... 0xa2ee:  \n\tcase 0x9d10 ... 0x9d1b:  \n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n#define INTEL_SPT_ACS_CTRL (PCI_ACS_CAP + 4)\n\nstatic int pci_quirk_intel_spt_pch_acs(struct pci_dev *dev, u16 acs_flags)\n{\n\tint pos;\n\tu32 cap, ctrl;\n\n\tif (!pci_quirk_intel_spt_pch_acs_match(dev))\n\t\treturn -ENOTTY;\n\n\tpos = dev->acs_cap;\n\tif (!pos)\n\t\treturn -ENOTTY;\n\n\t \n\tpci_read_config_dword(dev, pos + PCI_ACS_CAP, &cap);\n\tacs_flags &= (cap | PCI_ACS_EC);\n\n\tpci_read_config_dword(dev, pos + INTEL_SPT_ACS_CTRL, &ctrl);\n\n\treturn pci_acs_ctrl_enabled(acs_flags, ctrl);\n}\n\nstatic int pci_quirk_mf_endpoint_acs(struct pci_dev *dev, u16 acs_flags)\n{\n\t \n\treturn pci_acs_ctrl_enabled(acs_flags,\n\t\tPCI_ACS_SV | PCI_ACS_TB | PCI_ACS_RR |\n\t\tPCI_ACS_CR | PCI_ACS_UF | PCI_ACS_DT);\n}\n\nstatic int pci_quirk_rciep_acs(struct pci_dev *dev, u16 acs_flags)\n{\n\t \n\tif (pci_pcie_type(dev) != PCI_EXP_TYPE_RC_END)\n\t\treturn -ENOTTY;\n\n\treturn pci_acs_ctrl_enabled(acs_flags,\n\t\tPCI_ACS_SV | PCI_ACS_RR | PCI_ACS_CR | PCI_ACS_UF);\n}\n\nstatic int pci_quirk_brcm_acs(struct pci_dev *dev, u16 acs_flags)\n{\n\t \n\treturn pci_acs_ctrl_enabled(acs_flags,\n\t\tPCI_ACS_SV | PCI_ACS_RR | PCI_ACS_CR | PCI_ACS_UF);\n}\n\n \nstatic int  pci_quirk_wangxun_nic_acs(struct pci_dev *dev, u16 acs_flags)\n{\n\tswitch (dev->device) {\n\tcase 0x0100 ... 0x010F:\n\tcase 0x1001:\n\tcase 0x2001:\n\t\treturn pci_acs_ctrl_enabled(acs_flags,\n\t\t\tPCI_ACS_SV | PCI_ACS_RR | PCI_ACS_CR | PCI_ACS_UF);\n\t}\n\n\treturn false;\n}\n\nstatic const struct pci_dev_acs_enabled {\n\tu16 vendor;\n\tu16 device;\n\tint (*acs_enabled)(struct pci_dev *dev, u16 acs_flags);\n} pci_dev_acs_enabled[] = {\n\t{ PCI_VENDOR_ID_ATI, 0x4385, pci_quirk_amd_sb_acs },\n\t{ PCI_VENDOR_ID_ATI, 0x439c, pci_quirk_amd_sb_acs },\n\t{ PCI_VENDOR_ID_ATI, 0x4383, pci_quirk_amd_sb_acs },\n\t{ PCI_VENDOR_ID_ATI, 0x439d, pci_quirk_amd_sb_acs },\n\t{ PCI_VENDOR_ID_ATI, 0x4384, pci_quirk_amd_sb_acs },\n\t{ PCI_VENDOR_ID_ATI, 0x4399, pci_quirk_amd_sb_acs },\n\t{ PCI_VENDOR_ID_AMD, 0x780f, pci_quirk_amd_sb_acs },\n\t{ PCI_VENDOR_ID_AMD, 0x7809, pci_quirk_amd_sb_acs },\n\t{ PCI_VENDOR_ID_SOLARFLARE, 0x0903, pci_quirk_mf_endpoint_acs },\n\t{ PCI_VENDOR_ID_SOLARFLARE, 0x0923, pci_quirk_mf_endpoint_acs },\n\t{ PCI_VENDOR_ID_SOLARFLARE, 0x0A03, pci_quirk_mf_endpoint_acs },\n\t{ PCI_VENDOR_ID_INTEL, 0x10C6, pci_quirk_mf_endpoint_acs },\n\t{ PCI_VENDOR_ID_INTEL, 0x10DB, pci_quirk_mf_endpoint_acs },\n\t{ PCI_VENDOR_ID_INTEL, 0x10DD, pci_quirk_mf_endpoint_acs },\n\t{ PCI_VENDOR_ID_INTEL, 0x10E1, pci_quirk_mf_endpoint_acs },\n\t{ PCI_VENDOR_ID_INTEL, 0x10F1, pci_quirk_mf_endpoint_acs },\n\t{ PCI_VENDOR_ID_INTEL, 0x10F7, pci_quirk_mf_endpoint_acs },\n\t{ PCI_VENDOR_ID_INTEL, 0x10F8, pci_quirk_mf_endpoint_acs },\n\t{ PCI_VENDOR_ID_INTEL, 0x10F9, pci_quirk_mf_endpoint_acs },\n\t{ PCI_VENDOR_ID_INTEL, 0x10FA, pci_quirk_mf_endpoint_acs },\n\t{ PCI_VENDOR_ID_INTEL, 0x10FB, pci_quirk_mf_endpoint_acs },\n\t{ PCI_VENDOR_ID_INTEL, 0x10FC, pci_quirk_mf_endpoint_acs },\n\t{ PCI_VENDOR_ID_INTEL, 0x1507, pci_quirk_mf_endpoint_acs },\n\t{ PCI_VENDOR_ID_INTEL, 0x1514, pci_quirk_mf_endpoint_acs },\n\t{ PCI_VENDOR_ID_INTEL, 0x151C, pci_quirk_mf_endpoint_acs },\n\t{ PCI_VENDOR_ID_INTEL, 0x1529, pci_quirk_mf_endpoint_acs },\n\t{ PCI_VENDOR_ID_INTEL, 0x152A, pci_quirk_mf_endpoint_acs },\n\t{ PCI_VENDOR_ID_INTEL, 0x154D, pci_quirk_mf_endpoint_acs },\n\t{ PCI_VENDOR_ID_INTEL, 0x154F, pci_quirk_mf_endpoint_acs },\n\t{ PCI_VENDOR_ID_INTEL, 0x1551, pci_quirk_mf_endpoint_acs },\n\t{ PCI_VENDOR_ID_INTEL, 0x1558, pci_quirk_mf_endpoint_acs },\n\t \n\t{ PCI_VENDOR_ID_INTEL, 0x1509, pci_quirk_mf_endpoint_acs },\n\t{ PCI_VENDOR_ID_INTEL, 0x150E, pci_quirk_mf_endpoint_acs },\n\t{ PCI_VENDOR_ID_INTEL, 0x150F, pci_quirk_mf_endpoint_acs },\n\t{ PCI_VENDOR_ID_INTEL, 0x1510, pci_quirk_mf_endpoint_acs },\n\t{ PCI_VENDOR_ID_INTEL, 0x1511, pci_quirk_mf_endpoint_acs },\n\t{ PCI_VENDOR_ID_INTEL, 0x1516, pci_quirk_mf_endpoint_acs },\n\t{ PCI_VENDOR_ID_INTEL, 0x1527, pci_quirk_mf_endpoint_acs },\n\t \n\t{ PCI_VENDOR_ID_INTEL, 0x10C9, pci_quirk_mf_endpoint_acs },\n\t{ PCI_VENDOR_ID_INTEL, 0x10E6, pci_quirk_mf_endpoint_acs },\n\t{ PCI_VENDOR_ID_INTEL, 0x10E7, pci_quirk_mf_endpoint_acs },\n\t{ PCI_VENDOR_ID_INTEL, 0x10E8, pci_quirk_mf_endpoint_acs },\n\t{ PCI_VENDOR_ID_INTEL, 0x150A, pci_quirk_mf_endpoint_acs },\n\t{ PCI_VENDOR_ID_INTEL, 0x150D, pci_quirk_mf_endpoint_acs },\n\t{ PCI_VENDOR_ID_INTEL, 0x1518, pci_quirk_mf_endpoint_acs },\n\t{ PCI_VENDOR_ID_INTEL, 0x1526, pci_quirk_mf_endpoint_acs },\n\t \n\t{ PCI_VENDOR_ID_INTEL, 0x10A7, pci_quirk_mf_endpoint_acs },\n\t{ PCI_VENDOR_ID_INTEL, 0x10A9, pci_quirk_mf_endpoint_acs },\n\t{ PCI_VENDOR_ID_INTEL, 0x10D6, pci_quirk_mf_endpoint_acs },\n\t \n\t{ PCI_VENDOR_ID_INTEL, 0x1521, pci_quirk_mf_endpoint_acs },\n\t{ PCI_VENDOR_ID_INTEL, 0x1522, pci_quirk_mf_endpoint_acs },\n\t{ PCI_VENDOR_ID_INTEL, 0x1523, pci_quirk_mf_endpoint_acs },\n\t{ PCI_VENDOR_ID_INTEL, 0x1524, pci_quirk_mf_endpoint_acs },\n\t \n\t{ PCI_VENDOR_ID_INTEL, 0x105E, pci_quirk_mf_endpoint_acs },\n\t{ PCI_VENDOR_ID_INTEL, 0x105F, pci_quirk_mf_endpoint_acs },\n\t{ PCI_VENDOR_ID_INTEL, 0x1060, pci_quirk_mf_endpoint_acs },\n\t{ PCI_VENDOR_ID_INTEL, 0x10D9, pci_quirk_mf_endpoint_acs },\n\t \n\t{ PCI_VENDOR_ID_INTEL, 0x15b7, pci_quirk_mf_endpoint_acs },\n\t{ PCI_VENDOR_ID_INTEL, 0x15b8, pci_quirk_mf_endpoint_acs },\n\t{ PCI_VENDOR_ID_INTEL, PCI_ANY_ID, pci_quirk_rciep_acs },\n\t \n\t{ PCI_VENDOR_ID_QCOM, 0x0400, pci_quirk_qcom_rp_acs },\n\t{ PCI_VENDOR_ID_QCOM, 0x0401, pci_quirk_qcom_rp_acs },\n\t \n\t{ PCI_VENDOR_ID_HXT, 0x0401, pci_quirk_qcom_rp_acs },\n\t \n\t{ PCI_VENDOR_ID_INTEL, PCI_ANY_ID, pci_quirk_intel_pch_acs },\n\t{ PCI_VENDOR_ID_INTEL, PCI_ANY_ID, pci_quirk_intel_spt_pch_acs },\n\t{ 0x19a2, 0x710, pci_quirk_mf_endpoint_acs },  \n\t{ 0x10df, 0x720, pci_quirk_mf_endpoint_acs },  \n\t \n\t{ PCI_VENDOR_ID_CAVIUM, PCI_ANY_ID, pci_quirk_cavium_acs },\n\t \n\t{ PCI_VENDOR_ID_CAVIUM, 0xA026, pci_quirk_mf_endpoint_acs },\n\t{ PCI_VENDOR_ID_CAVIUM, 0xA059, pci_quirk_mf_endpoint_acs },\n\t{ PCI_VENDOR_ID_CAVIUM, 0xA060, pci_quirk_mf_endpoint_acs },\n\t \n\t{ PCI_VENDOR_ID_AMCC, 0xE004, pci_quirk_xgene_acs },\n\t \n\t{ PCI_VENDOR_ID_AMPERE, 0xE005, pci_quirk_xgene_acs },\n\t{ PCI_VENDOR_ID_AMPERE, 0xE006, pci_quirk_xgene_acs },\n\t{ PCI_VENDOR_ID_AMPERE, 0xE007, pci_quirk_xgene_acs },\n\t{ PCI_VENDOR_ID_AMPERE, 0xE008, pci_quirk_xgene_acs },\n\t{ PCI_VENDOR_ID_AMPERE, 0xE009, pci_quirk_xgene_acs },\n\t{ PCI_VENDOR_ID_AMPERE, 0xE00A, pci_quirk_xgene_acs },\n\t{ PCI_VENDOR_ID_AMPERE, 0xE00B, pci_quirk_xgene_acs },\n\t{ PCI_VENDOR_ID_AMPERE, 0xE00C, pci_quirk_xgene_acs },\n\t \n\t{ PCI_VENDOR_ID_BROADCOM, 0x16D7, pci_quirk_mf_endpoint_acs },\n\t{ PCI_VENDOR_ID_BROADCOM, 0x1750, pci_quirk_mf_endpoint_acs },\n\t{ PCI_VENDOR_ID_BROADCOM, 0x1751, pci_quirk_mf_endpoint_acs },\n\t{ PCI_VENDOR_ID_BROADCOM, 0x1752, pci_quirk_mf_endpoint_acs },\n\t{ PCI_VENDOR_ID_BROADCOM, 0xD714, pci_quirk_brcm_acs },\n\t \n\t{ PCI_VENDOR_ID_AMAZON_ANNAPURNA_LABS, 0x0031, pci_quirk_al_acs },\n\t \n\t{ PCI_VENDOR_ID_ZHAOXIN, 0x3038, pci_quirk_mf_endpoint_acs },\n\t{ PCI_VENDOR_ID_ZHAOXIN, 0x3104, pci_quirk_mf_endpoint_acs },\n\t{ PCI_VENDOR_ID_ZHAOXIN, 0x9083, pci_quirk_mf_endpoint_acs },\n\t \n\t \n\t{ PCI_VENDOR_ID_NXP, 0x8d81, pci_quirk_nxp_rp_acs },\n\t{ PCI_VENDOR_ID_NXP, 0x8da1, pci_quirk_nxp_rp_acs },\n\t{ PCI_VENDOR_ID_NXP, 0x8d83, pci_quirk_nxp_rp_acs },\n\t \n\t{ PCI_VENDOR_ID_NXP, 0x8d80, pci_quirk_nxp_rp_acs },\n\t{ PCI_VENDOR_ID_NXP, 0x8da0, pci_quirk_nxp_rp_acs },\n\t{ PCI_VENDOR_ID_NXP, 0x8d82, pci_quirk_nxp_rp_acs },\n\t \n\t{ PCI_VENDOR_ID_NXP, 0x8d90, pci_quirk_nxp_rp_acs },\n\t{ PCI_VENDOR_ID_NXP, 0x8db0, pci_quirk_nxp_rp_acs },\n\t{ PCI_VENDOR_ID_NXP, 0x8d92, pci_quirk_nxp_rp_acs },\n\t \n\t{ PCI_VENDOR_ID_NXP, 0x8d91, pci_quirk_nxp_rp_acs },\n\t{ PCI_VENDOR_ID_NXP, 0x8db1, pci_quirk_nxp_rp_acs },\n\t{ PCI_VENDOR_ID_NXP, 0x8d93, pci_quirk_nxp_rp_acs },\n\t \n\t{ PCI_VENDOR_ID_NXP, 0x8d89, pci_quirk_nxp_rp_acs },\n\t{ PCI_VENDOR_ID_NXP, 0x8da9, pci_quirk_nxp_rp_acs },\n\t{ PCI_VENDOR_ID_NXP, 0x8d8b, pci_quirk_nxp_rp_acs },\n\t \n\t{ PCI_VENDOR_ID_NXP, 0x8d88, pci_quirk_nxp_rp_acs },\n\t{ PCI_VENDOR_ID_NXP, 0x8da8, pci_quirk_nxp_rp_acs },\n\t{ PCI_VENDOR_ID_NXP, 0x8d8a, pci_quirk_nxp_rp_acs },\n\t \n\t{ PCI_VENDOR_ID_NXP, 0x8d98, pci_quirk_nxp_rp_acs },\n\t{ PCI_VENDOR_ID_NXP, 0x8db8, pci_quirk_nxp_rp_acs },\n\t{ PCI_VENDOR_ID_NXP, 0x8d9a, pci_quirk_nxp_rp_acs },\n\t \n\t{ PCI_VENDOR_ID_NXP, 0x8d99, pci_quirk_nxp_rp_acs },\n\t{ PCI_VENDOR_ID_NXP, 0x8db9, pci_quirk_nxp_rp_acs },\n\t{ PCI_VENDOR_ID_NXP, 0x8d9b, pci_quirk_nxp_rp_acs },\n\t \n\t{ PCI_VENDOR_ID_ZHAOXIN, PCI_ANY_ID, pci_quirk_zhaoxin_pcie_ports_acs },\n\t \n\t{ PCI_VENDOR_ID_WANGXUN, PCI_ANY_ID, pci_quirk_wangxun_nic_acs },\n\t{ 0 }\n};\n\n \nint pci_dev_specific_acs_enabled(struct pci_dev *dev, u16 acs_flags)\n{\n\tconst struct pci_dev_acs_enabled *i;\n\tint ret;\n\n\t \n\tfor (i = pci_dev_acs_enabled; i->acs_enabled; i++) {\n\t\tif ((i->vendor == dev->vendor ||\n\t\t     i->vendor == (u16)PCI_ANY_ID) &&\n\t\t    (i->device == dev->device ||\n\t\t     i->device == (u16)PCI_ANY_ID)) {\n\t\t\tret = i->acs_enabled(dev, acs_flags);\n\t\t\tif (ret >= 0)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn -ENOTTY;\n}\n\n \n#define INTEL_LPC_RCBA_REG 0xf0\n \n#define INTEL_LPC_RCBA_MASK 0xffffc000\n \n#define INTEL_LPC_RCBA_ENABLE (1 << 0)\n\n \n#define INTEL_BSPR_REG 0x1104\n \n#define INTEL_BSPR_REG_BPNPD (1 << 8)\n \n#define INTEL_BSPR_REG_BPPD  (1 << 9)\n\n \n#define INTEL_UPDCR_REG 0x1014\n \n#define INTEL_UPDCR_REG_MASK 0x3f\n\nstatic int pci_quirk_enable_intel_lpc_acs(struct pci_dev *dev)\n{\n\tu32 rcba, bspr, updcr;\n\tvoid __iomem *rcba_mem;\n\n\t \n\tpci_bus_read_config_dword(dev->bus, PCI_DEVFN(31, 0),\n\t\t\t\t  INTEL_LPC_RCBA_REG, &rcba);\n\tif (!(rcba & INTEL_LPC_RCBA_ENABLE))\n\t\treturn -EINVAL;\n\n\trcba_mem = ioremap(rcba & INTEL_LPC_RCBA_MASK,\n\t\t\t\t   PAGE_ALIGN(INTEL_UPDCR_REG));\n\tif (!rcba_mem)\n\t\treturn -ENOMEM;\n\n\t \n\tbspr = readl(rcba_mem + INTEL_BSPR_REG);\n\tbspr &= INTEL_BSPR_REG_BPNPD | INTEL_BSPR_REG_BPPD;\n\tif (bspr != (INTEL_BSPR_REG_BPNPD | INTEL_BSPR_REG_BPPD)) {\n\t\tupdcr = readl(rcba_mem + INTEL_UPDCR_REG);\n\t\tif (updcr & INTEL_UPDCR_REG_MASK) {\n\t\t\tpci_info(dev, \"Disabling UPDCR peer decodes\\n\");\n\t\t\tupdcr &= ~INTEL_UPDCR_REG_MASK;\n\t\t\twritel(updcr, rcba_mem + INTEL_UPDCR_REG);\n\t\t}\n\t}\n\n\tiounmap(rcba_mem);\n\treturn 0;\n}\n\n \n#define INTEL_MPC_REG 0xd8\n \n#define INTEL_MPC_REG_IRBNCE (1 << 26)\n\nstatic void pci_quirk_enable_intel_rp_mpc_acs(struct pci_dev *dev)\n{\n\tu32 mpc;\n\n\t \n\tpci_read_config_dword(dev, INTEL_MPC_REG, &mpc);\n\tif (!(mpc & INTEL_MPC_REG_IRBNCE)) {\n\t\tpci_info(dev, \"Enabling MPC IRBNCE\\n\");\n\t\tmpc |= INTEL_MPC_REG_IRBNCE;\n\t\tpci_write_config_word(dev, INTEL_MPC_REG, mpc);\n\t}\n}\n\n \nstatic int pci_quirk_enable_intel_pch_acs(struct pci_dev *dev)\n{\n\tif (!pci_quirk_intel_pch_acs_match(dev))\n\t\treturn -ENOTTY;\n\n\tif (pci_quirk_enable_intel_lpc_acs(dev)) {\n\t\tpci_warn(dev, \"Failed to enable Intel PCH ACS quirk\\n\");\n\t\treturn 0;\n\t}\n\n\tpci_quirk_enable_intel_rp_mpc_acs(dev);\n\n\tdev->dev_flags |= PCI_DEV_FLAGS_ACS_ENABLED_QUIRK;\n\n\tpci_info(dev, \"Intel PCH root port ACS workaround enabled\\n\");\n\n\treturn 0;\n}\n\nstatic int pci_quirk_enable_intel_spt_pch_acs(struct pci_dev *dev)\n{\n\tint pos;\n\tu32 cap, ctrl;\n\n\tif (!pci_quirk_intel_spt_pch_acs_match(dev))\n\t\treturn -ENOTTY;\n\n\tpos = dev->acs_cap;\n\tif (!pos)\n\t\treturn -ENOTTY;\n\n\tpci_read_config_dword(dev, pos + PCI_ACS_CAP, &cap);\n\tpci_read_config_dword(dev, pos + INTEL_SPT_ACS_CTRL, &ctrl);\n\n\tctrl |= (cap & PCI_ACS_SV);\n\tctrl |= (cap & PCI_ACS_RR);\n\tctrl |= (cap & PCI_ACS_CR);\n\tctrl |= (cap & PCI_ACS_UF);\n\n\tif (pci_ats_disabled() || dev->external_facing || dev->untrusted)\n\t\tctrl |= (cap & PCI_ACS_TB);\n\n\tpci_write_config_dword(dev, pos + INTEL_SPT_ACS_CTRL, ctrl);\n\n\tpci_info(dev, \"Intel SPT PCH root port ACS workaround enabled\\n\");\n\n\treturn 0;\n}\n\nstatic int pci_quirk_disable_intel_spt_pch_acs_redir(struct pci_dev *dev)\n{\n\tint pos;\n\tu32 cap, ctrl;\n\n\tif (!pci_quirk_intel_spt_pch_acs_match(dev))\n\t\treturn -ENOTTY;\n\n\tpos = dev->acs_cap;\n\tif (!pos)\n\t\treturn -ENOTTY;\n\n\tpci_read_config_dword(dev, pos + PCI_ACS_CAP, &cap);\n\tpci_read_config_dword(dev, pos + INTEL_SPT_ACS_CTRL, &ctrl);\n\n\tctrl &= ~(PCI_ACS_RR | PCI_ACS_CR | PCI_ACS_EC);\n\n\tpci_write_config_dword(dev, pos + INTEL_SPT_ACS_CTRL, ctrl);\n\n\tpci_info(dev, \"Intel SPT PCH root port workaround: disabled ACS redirect\\n\");\n\n\treturn 0;\n}\n\nstatic const struct pci_dev_acs_ops {\n\tu16 vendor;\n\tu16 device;\n\tint (*enable_acs)(struct pci_dev *dev);\n\tint (*disable_acs_redir)(struct pci_dev *dev);\n} pci_dev_acs_ops[] = {\n\t{ PCI_VENDOR_ID_INTEL, PCI_ANY_ID,\n\t    .enable_acs = pci_quirk_enable_intel_pch_acs,\n\t},\n\t{ PCI_VENDOR_ID_INTEL, PCI_ANY_ID,\n\t    .enable_acs = pci_quirk_enable_intel_spt_pch_acs,\n\t    .disable_acs_redir = pci_quirk_disable_intel_spt_pch_acs_redir,\n\t},\n};\n\nint pci_dev_specific_enable_acs(struct pci_dev *dev)\n{\n\tconst struct pci_dev_acs_ops *p;\n\tint i, ret;\n\n\tfor (i = 0; i < ARRAY_SIZE(pci_dev_acs_ops); i++) {\n\t\tp = &pci_dev_acs_ops[i];\n\t\tif ((p->vendor == dev->vendor ||\n\t\t     p->vendor == (u16)PCI_ANY_ID) &&\n\t\t    (p->device == dev->device ||\n\t\t     p->device == (u16)PCI_ANY_ID) &&\n\t\t    p->enable_acs) {\n\t\t\tret = p->enable_acs(dev);\n\t\t\tif (ret >= 0)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn -ENOTTY;\n}\n\nint pci_dev_specific_disable_acs_redir(struct pci_dev *dev)\n{\n\tconst struct pci_dev_acs_ops *p;\n\tint i, ret;\n\n\tfor (i = 0; i < ARRAY_SIZE(pci_dev_acs_ops); i++) {\n\t\tp = &pci_dev_acs_ops[i];\n\t\tif ((p->vendor == dev->vendor ||\n\t\t     p->vendor == (u16)PCI_ANY_ID) &&\n\t\t    (p->device == dev->device ||\n\t\t     p->device == (u16)PCI_ANY_ID) &&\n\t\t    p->disable_acs_redir) {\n\t\t\tret = p->disable_acs_redir(dev);\n\t\t\tif (ret >= 0)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn -ENOTTY;\n}\n\n \nstatic void quirk_intel_qat_vf_cap(struct pci_dev *pdev)\n{\n\tint pos, i = 0, ret;\n\tu8 next_cap;\n\tu16 reg16, *cap;\n\tstruct pci_cap_saved_state *state;\n\n\t \n\tif (pdev->pcie_cap || pci_find_capability(pdev, PCI_CAP_ID_EXP))\n\t\treturn;\n\n\t \n\tpos = pci_find_capability(pdev, PCI_CAP_ID_MSI);\n\tif (!pos)\n\t\treturn;\n\n\t \n\tpci_read_config_byte(pdev, pos + 1, &next_cap);\n\tif (next_cap)\n\t\treturn;\n\n\t \n\tpos = 0x50;\n\tpci_read_config_word(pdev, pos, &reg16);\n\tif (reg16 == (0x0000 | PCI_CAP_ID_EXP)) {\n\t\tu32 status;\n#ifndef PCI_EXP_SAVE_REGS\n#define PCI_EXP_SAVE_REGS     7\n#endif\n\t\tint size = PCI_EXP_SAVE_REGS * sizeof(u16);\n\n\t\tpdev->pcie_cap = pos;\n\t\tpci_read_config_word(pdev, pos + PCI_EXP_FLAGS, &reg16);\n\t\tpdev->pcie_flags_reg = reg16;\n\t\tpci_read_config_word(pdev, pos + PCI_EXP_DEVCAP, &reg16);\n\t\tpdev->pcie_mpss = reg16 & PCI_EXP_DEVCAP_PAYLOAD;\n\n\t\tpdev->cfg_size = PCI_CFG_SPACE_EXP_SIZE;\n\t\tret = pci_read_config_dword(pdev, PCI_CFG_SPACE_SIZE, &status);\n\t\tif ((ret != PCIBIOS_SUCCESSFUL) || (PCI_POSSIBLE_ERROR(status)))\n\t\t\tpdev->cfg_size = PCI_CFG_SPACE_SIZE;\n\n\t\tif (pci_find_saved_cap(pdev, PCI_CAP_ID_EXP))\n\t\t\treturn;\n\n\t\t \n\t\tstate = kzalloc(sizeof(*state) + size, GFP_KERNEL);\n\t\tif (!state)\n\t\t\treturn;\n\n\t\tstate->cap.cap_nr = PCI_CAP_ID_EXP;\n\t\tstate->cap.cap_extended = 0;\n\t\tstate->cap.size = size;\n\t\tcap = (u16 *)&state->cap.data[0];\n\t\tpcie_capability_read_word(pdev, PCI_EXP_DEVCTL, &cap[i++]);\n\t\tpcie_capability_read_word(pdev, PCI_EXP_LNKCTL, &cap[i++]);\n\t\tpcie_capability_read_word(pdev, PCI_EXP_SLTCTL, &cap[i++]);\n\t\tpcie_capability_read_word(pdev, PCI_EXP_RTCTL,  &cap[i++]);\n\t\tpcie_capability_read_word(pdev, PCI_EXP_DEVCTL2, &cap[i++]);\n\t\tpcie_capability_read_word(pdev, PCI_EXP_LNKCTL2, &cap[i++]);\n\t\tpcie_capability_read_word(pdev, PCI_EXP_SLTCTL2, &cap[i++]);\n\t\thlist_add_head(&state->next, &pdev->saved_cap_space);\n\t}\n}\nDECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_INTEL, 0x443, quirk_intel_qat_vf_cap);\n\n \nstatic void quirk_no_flr(struct pci_dev *dev)\n{\n\tdev->dev_flags |= PCI_DEV_FLAGS_NO_FLR_RESET;\n}\nDECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_AMD, 0x1487, quirk_no_flr);\nDECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_AMD, 0x148c, quirk_no_flr);\nDECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_AMD, 0x149c, quirk_no_flr);\nDECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_AMD, 0x7901, quirk_no_flr);\nDECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_INTEL, 0x1502, quirk_no_flr);\nDECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_INTEL, 0x1503, quirk_no_flr);\n\n \nstatic void quirk_no_flr_snet(struct pci_dev *dev)\n{\n\tif (dev->revision == 0x1)\n\t\tquirk_no_flr(dev);\n}\nDECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_SOLIDRUN, 0x1000, quirk_no_flr_snet);\n\nstatic void quirk_no_ext_tags(struct pci_dev *pdev)\n{\n\tstruct pci_host_bridge *bridge = pci_find_host_bridge(pdev->bus);\n\n\tif (!bridge)\n\t\treturn;\n\n\tbridge->no_ext_tags = 1;\n\tpci_info(pdev, \"disabling Extended Tags (this device can't handle them)\\n\");\n\n\tpci_walk_bus(bridge->bus, pci_configure_extended_tags, NULL);\n}\nDECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_SERVERWORKS, 0x0132, quirk_no_ext_tags);\nDECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_SERVERWORKS, 0x0140, quirk_no_ext_tags);\nDECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_SERVERWORKS, 0x0141, quirk_no_ext_tags);\nDECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_SERVERWORKS, 0x0142, quirk_no_ext_tags);\nDECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_SERVERWORKS, 0x0144, quirk_no_ext_tags);\nDECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_SERVERWORKS, 0x0420, quirk_no_ext_tags);\nDECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_SERVERWORKS, 0x0422, quirk_no_ext_tags);\n\n#ifdef CONFIG_PCI_ATS\nstatic void quirk_no_ats(struct pci_dev *pdev)\n{\n\tpci_info(pdev, \"disabling ATS\\n\");\n\tpdev->ats_cap = 0;\n}\n\n \nstatic void quirk_amd_harvest_no_ats(struct pci_dev *pdev)\n{\n\tif (pdev->device == 0x15d8) {\n\t\tif (pdev->revision == 0xcf &&\n\t\t    pdev->subsystem_vendor == 0xea50 &&\n\t\t    (pdev->subsystem_device == 0xce19 ||\n\t\t     pdev->subsystem_device == 0xcc10 ||\n\t\t     pdev->subsystem_device == 0xcc08))\n\t\t\tquirk_no_ats(pdev);\n\t} else {\n\t\tquirk_no_ats(pdev);\n\t}\n}\n\n \nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_ATI, 0x98e4, quirk_amd_harvest_no_ats);\n \nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_ATI, 0x6900, quirk_amd_harvest_no_ats);\n \nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_ATI, 0x7310, quirk_amd_harvest_no_ats);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_ATI, 0x7312, quirk_amd_harvest_no_ats);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_ATI, 0x7318, quirk_amd_harvest_no_ats);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_ATI, 0x7319, quirk_amd_harvest_no_ats);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_ATI, 0x731a, quirk_amd_harvest_no_ats);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_ATI, 0x731b, quirk_amd_harvest_no_ats);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_ATI, 0x731e, quirk_amd_harvest_no_ats);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_ATI, 0x731f, quirk_amd_harvest_no_ats);\n \nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_ATI, 0x7340, quirk_amd_harvest_no_ats);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_ATI, 0x7341, quirk_amd_harvest_no_ats);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_ATI, 0x7347, quirk_amd_harvest_no_ats);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_ATI, 0x734f, quirk_amd_harvest_no_ats);\n \nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_ATI, 0x15d8, quirk_amd_harvest_no_ats);\n\n \nstatic void quirk_intel_e2000_no_ats(struct pci_dev *pdev)\n{\n\tif (pdev->revision < 0x20)\n\t\tquirk_no_ats(pdev);\n}\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x1451, quirk_intel_e2000_no_ats);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x1452, quirk_intel_e2000_no_ats);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x1453, quirk_intel_e2000_no_ats);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x1454, quirk_intel_e2000_no_ats);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x1455, quirk_intel_e2000_no_ats);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x1457, quirk_intel_e2000_no_ats);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x1459, quirk_intel_e2000_no_ats);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x145a, quirk_intel_e2000_no_ats);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x145c, quirk_intel_e2000_no_ats);\n#endif  \n\n \nstatic void quirk_fsl_no_msi(struct pci_dev *pdev)\n{\n\tif (pci_pcie_type(pdev) == PCI_EXP_TYPE_ROOT_PORT)\n\t\tpdev->no_msi = 1;\n}\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_FREESCALE, PCI_ANY_ID, quirk_fsl_no_msi);\n\n \nstatic void pci_create_device_link(struct pci_dev *pdev, unsigned int consumer,\n\t\t\t\t   unsigned int supplier, unsigned int class,\n\t\t\t\t   unsigned int class_shift)\n{\n\tstruct pci_dev *supplier_pdev;\n\n\tif (PCI_FUNC(pdev->devfn) != consumer)\n\t\treturn;\n\n\tsupplier_pdev = pci_get_domain_bus_and_slot(pci_domain_nr(pdev->bus),\n\t\t\t\tpdev->bus->number,\n\t\t\t\tPCI_DEVFN(PCI_SLOT(pdev->devfn), supplier));\n\tif (!supplier_pdev || (supplier_pdev->class >> class_shift) != class) {\n\t\tpci_dev_put(supplier_pdev);\n\t\treturn;\n\t}\n\n\tif (device_link_add(&pdev->dev, &supplier_pdev->dev,\n\t\t\t    DL_FLAG_STATELESS | DL_FLAG_PM_RUNTIME))\n\t\tpci_info(pdev, \"D0 power state depends on %s\\n\",\n\t\t\t pci_name(supplier_pdev));\n\telse\n\t\tpci_err(pdev, \"Cannot enforce power dependency on %s\\n\",\n\t\t\tpci_name(supplier_pdev));\n\n\tpm_runtime_allow(&pdev->dev);\n\tpci_dev_put(supplier_pdev);\n}\n\n \nstatic void quirk_gpu_hda(struct pci_dev *hda)\n{\n\tpci_create_device_link(hda, 1, 0, PCI_BASE_CLASS_DISPLAY, 16);\n}\nDECLARE_PCI_FIXUP_CLASS_FINAL(PCI_VENDOR_ID_ATI, PCI_ANY_ID,\n\t\t\t      PCI_CLASS_MULTIMEDIA_HD_AUDIO, 8, quirk_gpu_hda);\nDECLARE_PCI_FIXUP_CLASS_FINAL(PCI_VENDOR_ID_AMD, PCI_ANY_ID,\n\t\t\t      PCI_CLASS_MULTIMEDIA_HD_AUDIO, 8, quirk_gpu_hda);\nDECLARE_PCI_FIXUP_CLASS_FINAL(PCI_VENDOR_ID_NVIDIA, PCI_ANY_ID,\n\t\t\t      PCI_CLASS_MULTIMEDIA_HD_AUDIO, 8, quirk_gpu_hda);\n\n \nstatic void quirk_gpu_usb(struct pci_dev *usb)\n{\n\tpci_create_device_link(usb, 2, 0, PCI_BASE_CLASS_DISPLAY, 16);\n}\nDECLARE_PCI_FIXUP_CLASS_FINAL(PCI_VENDOR_ID_NVIDIA, PCI_ANY_ID,\n\t\t\t      PCI_CLASS_SERIAL_USB, 8, quirk_gpu_usb);\nDECLARE_PCI_FIXUP_CLASS_FINAL(PCI_VENDOR_ID_ATI, PCI_ANY_ID,\n\t\t\t      PCI_CLASS_SERIAL_USB, 8, quirk_gpu_usb);\n\n \n#define PCI_CLASS_SERIAL_UNKNOWN\t0x0c80\nstatic void quirk_gpu_usb_typec_ucsi(struct pci_dev *ucsi)\n{\n\tpci_create_device_link(ucsi, 3, 0, PCI_BASE_CLASS_DISPLAY, 16);\n}\nDECLARE_PCI_FIXUP_CLASS_FINAL(PCI_VENDOR_ID_NVIDIA, PCI_ANY_ID,\n\t\t\t      PCI_CLASS_SERIAL_UNKNOWN, 8,\n\t\t\t      quirk_gpu_usb_typec_ucsi);\nDECLARE_PCI_FIXUP_CLASS_FINAL(PCI_VENDOR_ID_ATI, PCI_ANY_ID,\n\t\t\t      PCI_CLASS_SERIAL_UNKNOWN, 8,\n\t\t\t      quirk_gpu_usb_typec_ucsi);\n\n \nstatic void quirk_nvidia_hda(struct pci_dev *gpu)\n{\n\tu8 hdr_type;\n\tu32 val;\n\n\t \n\tif (gpu->device < PCI_DEVICE_ID_NVIDIA_GEFORCE_320M)\n\t\treturn;\n\n\t \n\tpci_read_config_dword(gpu, 0x488, &val);\n\tif (val & BIT(25))\n\t\treturn;\n\n\tpci_info(gpu, \"Enabling HDA controller\\n\");\n\tpci_write_config_dword(gpu, 0x488, val | BIT(25));\n\n\t \n\tpci_read_config_byte(gpu, PCI_HEADER_TYPE, &hdr_type);\n\tgpu->multifunction = !!(hdr_type & 0x80);\n}\nDECLARE_PCI_FIXUP_CLASS_HEADER(PCI_VENDOR_ID_NVIDIA, PCI_ANY_ID,\n\t\t\t       PCI_BASE_CLASS_DISPLAY, 16, quirk_nvidia_hda);\nDECLARE_PCI_FIXUP_CLASS_RESUME_EARLY(PCI_VENDOR_ID_NVIDIA, PCI_ANY_ID,\n\t\t\t       PCI_BASE_CLASS_DISPLAY, 16, quirk_nvidia_hda);\n\n \nint pci_idt_bus_quirk(struct pci_bus *bus, int devfn, u32 *l, int timeout)\n{\n\tint pos;\n\tu16 ctrl = 0;\n\tbool found;\n\tstruct pci_dev *bridge = bus->self;\n\n\tpos = bridge->acs_cap;\n\n\t \n\tif (pos) {\n\t\tpci_read_config_word(bridge, pos + PCI_ACS_CTRL, &ctrl);\n\t\tif (ctrl & PCI_ACS_SV)\n\t\t\tpci_write_config_word(bridge, pos + PCI_ACS_CTRL,\n\t\t\t\t\t      ctrl & ~PCI_ACS_SV);\n\t}\n\n\tfound = pci_bus_generic_read_dev_vendor_id(bus, devfn, l, timeout);\n\n\t \n\tif (found)\n\t\tpci_bus_write_config_word(bus, devfn, PCI_VENDOR_ID, 0);\n\n\t \n\tif (ctrl & PCI_ACS_SV)\n\t\tpci_write_config_word(bridge, pos + PCI_ACS_CTRL, ctrl);\n\n\treturn found;\n}\n\n \nstatic void quirk_switchtec_ntb_dma_alias(struct pci_dev *pdev)\n{\n\tvoid __iomem *mmio;\n\tstruct ntb_info_regs __iomem *mmio_ntb;\n\tstruct ntb_ctrl_regs __iomem *mmio_ctrl;\n\tu64 partition_map;\n\tu8 partition;\n\tint pp;\n\n\tif (pci_enable_device(pdev)) {\n\t\tpci_err(pdev, \"Cannot enable Switchtec device\\n\");\n\t\treturn;\n\t}\n\n\tmmio = pci_iomap(pdev, 0, 0);\n\tif (mmio == NULL) {\n\t\tpci_disable_device(pdev);\n\t\tpci_err(pdev, \"Cannot iomap Switchtec device\\n\");\n\t\treturn;\n\t}\n\n\tpci_info(pdev, \"Setting Switchtec proxy ID aliases\\n\");\n\n\tmmio_ntb = mmio + SWITCHTEC_GAS_NTB_OFFSET;\n\tmmio_ctrl = (void __iomem *) mmio_ntb + SWITCHTEC_NTB_REG_CTRL_OFFSET;\n\n\tpartition = ioread8(&mmio_ntb->partition_id);\n\n\tpartition_map = ioread32(&mmio_ntb->ep_map);\n\tpartition_map |= ((u64) ioread32(&mmio_ntb->ep_map + 4)) << 32;\n\tpartition_map &= ~(1ULL << partition);\n\n\tfor (pp = 0; pp < (sizeof(partition_map) * 8); pp++) {\n\t\tstruct ntb_ctrl_regs __iomem *mmio_peer_ctrl;\n\t\tu32 table_sz = 0;\n\t\tint te;\n\n\t\tif (!(partition_map & (1ULL << pp)))\n\t\t\tcontinue;\n\n\t\tpci_dbg(pdev, \"Processing partition %d\\n\", pp);\n\n\t\tmmio_peer_ctrl = &mmio_ctrl[pp];\n\n\t\ttable_sz = ioread16(&mmio_peer_ctrl->req_id_table_size);\n\t\tif (!table_sz) {\n\t\t\tpci_warn(pdev, \"Partition %d table_sz 0\\n\", pp);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (table_sz > 512) {\n\t\t\tpci_warn(pdev,\n\t\t\t\t \"Invalid Switchtec partition %d table_sz %d\\n\",\n\t\t\t\t pp, table_sz);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (te = 0; te < table_sz; te++) {\n\t\t\tu32 rid_entry;\n\t\t\tu8 devfn;\n\n\t\t\trid_entry = ioread32(&mmio_peer_ctrl->req_id_table[te]);\n\t\t\tdevfn = (rid_entry >> 1) & 0xFF;\n\t\t\tpci_dbg(pdev,\n\t\t\t\t\"Aliasing Partition %d Proxy ID %02x.%d\\n\",\n\t\t\t\tpp, PCI_SLOT(devfn), PCI_FUNC(devfn));\n\t\t\tpci_add_dma_alias(pdev, devfn, 1);\n\t\t}\n\t}\n\n\tpci_iounmap(pdev, mmio);\n\tpci_disable_device(pdev);\n}\n#define SWITCHTEC_QUIRK(vid) \\\n\tDECLARE_PCI_FIXUP_CLASS_FINAL(PCI_VENDOR_ID_MICROSEMI, vid, \\\n\t\tPCI_CLASS_BRIDGE_OTHER, 8, quirk_switchtec_ntb_dma_alias)\n\nSWITCHTEC_QUIRK(0x8531);   \nSWITCHTEC_QUIRK(0x8532);   \nSWITCHTEC_QUIRK(0x8533);   \nSWITCHTEC_QUIRK(0x8534);   \nSWITCHTEC_QUIRK(0x8535);   \nSWITCHTEC_QUIRK(0x8536);   \nSWITCHTEC_QUIRK(0x8541);   \nSWITCHTEC_QUIRK(0x8542);   \nSWITCHTEC_QUIRK(0x8543);   \nSWITCHTEC_QUIRK(0x8544);   \nSWITCHTEC_QUIRK(0x8545);   \nSWITCHTEC_QUIRK(0x8546);   \nSWITCHTEC_QUIRK(0x8551);   \nSWITCHTEC_QUIRK(0x8552);   \nSWITCHTEC_QUIRK(0x8553);   \nSWITCHTEC_QUIRK(0x8554);   \nSWITCHTEC_QUIRK(0x8555);   \nSWITCHTEC_QUIRK(0x8556);   \nSWITCHTEC_QUIRK(0x8561);   \nSWITCHTEC_QUIRK(0x8562);   \nSWITCHTEC_QUIRK(0x8563);   \nSWITCHTEC_QUIRK(0x8564);   \nSWITCHTEC_QUIRK(0x8565);   \nSWITCHTEC_QUIRK(0x8566);   \nSWITCHTEC_QUIRK(0x8571);   \nSWITCHTEC_QUIRK(0x8572);   \nSWITCHTEC_QUIRK(0x8573);   \nSWITCHTEC_QUIRK(0x8574);   \nSWITCHTEC_QUIRK(0x8575);   \nSWITCHTEC_QUIRK(0x8576);   \nSWITCHTEC_QUIRK(0x4000);   \nSWITCHTEC_QUIRK(0x4084);   \nSWITCHTEC_QUIRK(0x4068);   \nSWITCHTEC_QUIRK(0x4052);   \nSWITCHTEC_QUIRK(0x4036);   \nSWITCHTEC_QUIRK(0x4028);   \nSWITCHTEC_QUIRK(0x4100);   \nSWITCHTEC_QUIRK(0x4184);   \nSWITCHTEC_QUIRK(0x4168);   \nSWITCHTEC_QUIRK(0x4152);   \nSWITCHTEC_QUIRK(0x4136);   \nSWITCHTEC_QUIRK(0x4128);   \nSWITCHTEC_QUIRK(0x4200);   \nSWITCHTEC_QUIRK(0x4284);   \nSWITCHTEC_QUIRK(0x4268);   \nSWITCHTEC_QUIRK(0x4252);   \nSWITCHTEC_QUIRK(0x4236);   \nSWITCHTEC_QUIRK(0x4228);   \nSWITCHTEC_QUIRK(0x4352);   \nSWITCHTEC_QUIRK(0x4336);   \nSWITCHTEC_QUIRK(0x4328);   \nSWITCHTEC_QUIRK(0x4452);   \nSWITCHTEC_QUIRK(0x4436);   \nSWITCHTEC_QUIRK(0x4428);   \nSWITCHTEC_QUIRK(0x4552);   \nSWITCHTEC_QUIRK(0x4536);   \nSWITCHTEC_QUIRK(0x4528);   \nSWITCHTEC_QUIRK(0x5000);   \nSWITCHTEC_QUIRK(0x5084);   \nSWITCHTEC_QUIRK(0x5068);   \nSWITCHTEC_QUIRK(0x5052);   \nSWITCHTEC_QUIRK(0x5036);   \nSWITCHTEC_QUIRK(0x5028);   \nSWITCHTEC_QUIRK(0x5100);   \nSWITCHTEC_QUIRK(0x5184);   \nSWITCHTEC_QUIRK(0x5168);   \nSWITCHTEC_QUIRK(0x5152);   \nSWITCHTEC_QUIRK(0x5136);   \nSWITCHTEC_QUIRK(0x5128);   \nSWITCHTEC_QUIRK(0x5200);   \nSWITCHTEC_QUIRK(0x5284);   \nSWITCHTEC_QUIRK(0x5268);   \nSWITCHTEC_QUIRK(0x5252);   \nSWITCHTEC_QUIRK(0x5236);   \nSWITCHTEC_QUIRK(0x5228);   \nSWITCHTEC_QUIRK(0x5300);   \nSWITCHTEC_QUIRK(0x5384);   \nSWITCHTEC_QUIRK(0x5368);   \nSWITCHTEC_QUIRK(0x5352);   \nSWITCHTEC_QUIRK(0x5336);   \nSWITCHTEC_QUIRK(0x5328);   \nSWITCHTEC_QUIRK(0x5400);   \nSWITCHTEC_QUIRK(0x5484);   \nSWITCHTEC_QUIRK(0x5468);   \nSWITCHTEC_QUIRK(0x5452);   \nSWITCHTEC_QUIRK(0x5436);   \nSWITCHTEC_QUIRK(0x5428);   \nSWITCHTEC_QUIRK(0x5500);   \nSWITCHTEC_QUIRK(0x5584);   \nSWITCHTEC_QUIRK(0x5568);   \nSWITCHTEC_QUIRK(0x5552);   \nSWITCHTEC_QUIRK(0x5536);   \nSWITCHTEC_QUIRK(0x5528);   \n\n \nstatic void quirk_plx_ntb_dma_alias(struct pci_dev *pdev)\n{\n\tpci_info(pdev, \"Setting PLX NTB proxy ID aliases\\n\");\n\t \n\tpci_add_dma_alias(pdev, 0, 256);\n}\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_PLX, 0x87b0, quirk_plx_ntb_dma_alias);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_PLX, 0x87b1, quirk_plx_ntb_dma_alias);\n\n \nstatic void quirk_reset_lenovo_thinkpad_p50_nvgpu(struct pci_dev *pdev)\n{\n\tvoid __iomem *map;\n\tint ret;\n\n\tif (pdev->subsystem_vendor != PCI_VENDOR_ID_LENOVO ||\n\t    pdev->subsystem_device != 0x222e ||\n\t    !pci_reset_supported(pdev))\n\t\treturn;\n\n\tif (pci_enable_device_mem(pdev))\n\t\treturn;\n\n\t \n\tmap = pci_iomap(pdev, 0, 0x23000);\n\tif (!map) {\n\t\tpci_err(pdev, \"Can't map MMIO space\\n\");\n\t\tgoto out_disable;\n\t}\n\n\t \n\tif (ioread32(map + 0x2240c) & 0x2) {\n\t\tpci_info(pdev, FW_BUG \"GPU left initialized by EFI, resetting\\n\");\n\t\tret = pci_reset_bus(pdev);\n\t\tif (ret < 0)\n\t\t\tpci_err(pdev, \"Failed to reset GPU: %d\\n\", ret);\n\t}\n\n\tiounmap(map);\nout_disable:\n\tpci_disable_device(pdev);\n}\nDECLARE_PCI_FIXUP_CLASS_FINAL(PCI_VENDOR_ID_NVIDIA, 0x13b1,\n\t\t\t      PCI_CLASS_DISPLAY_VGA, 8,\n\t\t\t      quirk_reset_lenovo_thinkpad_p50_nvgpu);\n\n \nstatic void pci_fixup_no_d0_pme(struct pci_dev *dev)\n{\n\tpci_info(dev, \"PME# does not work under D0, disabling it\\n\");\n\tdev->pme_support &= ~(PCI_PM_CAP_PME_D0 >> PCI_PM_CAP_PME_SHIFT);\n}\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_ASMEDIA, 0x2142, pci_fixup_no_d0_pme);\n\n \nstatic void pci_fixup_no_msi_no_pme(struct pci_dev *dev)\n{\n#ifdef CONFIG_PCI_MSI\n\tpci_info(dev, \"MSI is not implemented on this device, disabling it\\n\");\n\tdev->no_msi = 1;\n#endif\n\tpci_info(dev, \"PME# is unreliable, disabling it\\n\");\n\tdev->pme_support = 0;\n}\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_PERICOM, 0x400e, pci_fixup_no_msi_no_pme);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_PERICOM, 0x400f, pci_fixup_no_msi_no_pme);\n\nstatic void apex_pci_fixup_class(struct pci_dev *pdev)\n{\n\tpdev->class = (PCI_CLASS_SYSTEM_OTHER << 8) | pdev->class;\n}\nDECLARE_PCI_FIXUP_CLASS_HEADER(0x1ac1, 0x089a,\n\t\t\t       PCI_CLASS_NOT_DEFINED, 8, apex_pci_fixup_class);\n\n \n#define PI7C9X2Gxxx_MODE_REG\t\t0x74\n#define PI7C9X2Gxxx_STORE_FORWARD_MODE\tBIT(0)\nstatic void pci_fixup_pericom_acs_store_forward(struct pci_dev *pdev)\n{\n\tstruct pci_dev *upstream;\n\tu16 val;\n\n\t \n\tif (pci_pcie_type(pdev) != PCI_EXP_TYPE_DOWNSTREAM)\n\t\treturn;\n\n\t \n\tif (!pdev->acs_cap)\n\t\treturn;\n\tpci_read_config_word(pdev, pdev->acs_cap + PCI_ACS_CTRL, &val);\n\tif (!(val & PCI_ACS_RR))\n\t\treturn;\n\n\tupstream = pci_upstream_bridge(pdev);\n\tif (!upstream)\n\t\treturn;\n\n\tpci_read_config_word(upstream, PI7C9X2Gxxx_MODE_REG, &val);\n\tif (!(val & PI7C9X2Gxxx_STORE_FORWARD_MODE)) {\n\t\tpci_info(upstream, \"Setting PI7C9X2Gxxx store-forward mode to avoid ACS erratum\\n\");\n\t\tpci_write_config_word(upstream, PI7C9X2Gxxx_MODE_REG, val |\n\t\t\t\t      PI7C9X2Gxxx_STORE_FORWARD_MODE);\n\t}\n}\n \nDECLARE_PCI_FIXUP_ENABLE(PCI_VENDOR_ID_PERICOM, 0x2404,\n\t\t\t pci_fixup_pericom_acs_store_forward);\nDECLARE_PCI_FIXUP_RESUME(PCI_VENDOR_ID_PERICOM, 0x2404,\n\t\t\t pci_fixup_pericom_acs_store_forward);\nDECLARE_PCI_FIXUP_ENABLE(PCI_VENDOR_ID_PERICOM, 0x2304,\n\t\t\t pci_fixup_pericom_acs_store_forward);\nDECLARE_PCI_FIXUP_RESUME(PCI_VENDOR_ID_PERICOM, 0x2304,\n\t\t\t pci_fixup_pericom_acs_store_forward);\nDECLARE_PCI_FIXUP_ENABLE(PCI_VENDOR_ID_PERICOM, 0x2303,\n\t\t\t pci_fixup_pericom_acs_store_forward);\nDECLARE_PCI_FIXUP_RESUME(PCI_VENDOR_ID_PERICOM, 0x2303,\n\t\t\t pci_fixup_pericom_acs_store_forward);\n\nstatic void nvidia_ion_ahci_fixup(struct pci_dev *pdev)\n{\n\tpdev->dev_flags |= PCI_DEV_FLAGS_HAS_MSI_MASKING;\n}\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_NVIDIA, 0x0ab8, nvidia_ion_ahci_fixup);\n\nstatic void rom_bar_overlap_defect(struct pci_dev *dev)\n{\n\tpci_info(dev, \"working around ROM BAR overlap defect\\n\");\n\tdev->rom_bar_overlap = 1;\n}\nDECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_INTEL, 0x1533, rom_bar_overlap_defect);\nDECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_INTEL, 0x1536, rom_bar_overlap_defect);\nDECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_INTEL, 0x1537, rom_bar_overlap_defect);\nDECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_INTEL, 0x1538, rom_bar_overlap_defect);\n\n#ifdef CONFIG_PCIEASPM\n \nstatic void aspm_l1_acceptable_latency(struct pci_dev *dev)\n{\n\tu32 l1_lat = FIELD_GET(PCI_EXP_DEVCAP_L1, dev->devcap);\n\n\tif (l1_lat < 7) {\n\t\tdev->devcap |= FIELD_PREP(PCI_EXP_DEVCAP_L1, 7);\n\t\tpci_info(dev, \"ASPM: overriding L1 acceptable latency from %#x to 0x7\\n\",\n\t\t\t l1_lat);\n\t}\n}\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x4f80, aspm_l1_acceptable_latency);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x4f81, aspm_l1_acceptable_latency);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x4f82, aspm_l1_acceptable_latency);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x4f83, aspm_l1_acceptable_latency);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x4f84, aspm_l1_acceptable_latency);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x4f85, aspm_l1_acceptable_latency);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x4f86, aspm_l1_acceptable_latency);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x4f87, aspm_l1_acceptable_latency);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x4f88, aspm_l1_acceptable_latency);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x5690, aspm_l1_acceptable_latency);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x5691, aspm_l1_acceptable_latency);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x5692, aspm_l1_acceptable_latency);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x5693, aspm_l1_acceptable_latency);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x5694, aspm_l1_acceptable_latency);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x5695, aspm_l1_acceptable_latency);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x56a0, aspm_l1_acceptable_latency);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x56a1, aspm_l1_acceptable_latency);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x56a2, aspm_l1_acceptable_latency);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x56a3, aspm_l1_acceptable_latency);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x56a4, aspm_l1_acceptable_latency);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x56a5, aspm_l1_acceptable_latency);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x56a6, aspm_l1_acceptable_latency);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x56b0, aspm_l1_acceptable_latency);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x56b1, aspm_l1_acceptable_latency);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x56c0, aspm_l1_acceptable_latency);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x56c1, aspm_l1_acceptable_latency);\n#endif\n\n#ifdef CONFIG_PCIE_DPC\n \nstatic void dpc_log_size(struct pci_dev *dev)\n{\n\tu16 dpc, val;\n\n\tdpc = pci_find_ext_capability(dev, PCI_EXT_CAP_ID_DPC);\n\tif (!dpc)\n\t\treturn;\n\n\tpci_read_config_word(dev, dpc + PCI_EXP_DPC_CAP, &val);\n\tif (!(val & PCI_EXP_DPC_CAP_RP_EXT))\n\t\treturn;\n\n\tif (!((val & PCI_EXP_DPC_RP_PIO_LOG_SIZE) >> 8)) {\n\t\tpci_info(dev, \"Overriding RP PIO Log Size to 4\\n\");\n\t\tdev->dpc_rp_log_size = 4;\n\t}\n}\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x461f, dpc_log_size);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x462f, dpc_log_size);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x463f, dpc_log_size);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x466e, dpc_log_size);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x8a1d, dpc_log_size);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x8a1f, dpc_log_size);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x8a21, dpc_log_size);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x8a23, dpc_log_size);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x9a23, dpc_log_size);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x9a25, dpc_log_size);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x9a27, dpc_log_size);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x9a29, dpc_log_size);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x9a2b, dpc_log_size);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x9a2d, dpc_log_size);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x9a2f, dpc_log_size);\nDECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x9a31, dpc_log_size);\n#endif\n\n \nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_XILINX, 0x5020, of_pci_make_dev_node);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_XILINX, 0x5021, of_pci_make_dev_node);\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_REDHAT, 0x0005, of_pci_make_dev_node);\n\n \nstatic void pci_fixup_d3cold_delay_1sec(struct pci_dev *pdev)\n{\n\tpdev->d3cold_delay = 1000;\n}\nDECLARE_PCI_FIXUP_FINAL(0x5555, 0x0004, pci_fixup_d3cold_delay_1sec);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}