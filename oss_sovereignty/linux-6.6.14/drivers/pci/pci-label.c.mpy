{
  "module_name": "pci-label.c",
  "hash_id": "55efaf11d712c68a6f3fac43d39d693b239c466e0906b0778524f0ac9568db0a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/pci-label.c",
  "human_readable_source": "\n \n\n#include <linux/dmi.h>\n#include <linux/sysfs.h>\n#include <linux/pci.h>\n#include <linux/pci_ids.h>\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/nls.h>\n#include <linux/acpi.h>\n#include <linux/pci-acpi.h>\n#include \"pci.h\"\n\nstatic bool device_has_acpi_name(struct device *dev)\n{\n#ifdef CONFIG_ACPI\n\tacpi_handle handle = ACPI_HANDLE(dev);\n\n\tif (!handle)\n\t\treturn false;\n\n\treturn acpi_check_dsm(handle, &pci_acpi_dsm_guid, 0x2,\n\t\t\t      1 << DSM_PCI_DEVICE_NAME);\n#else\n\treturn false;\n#endif\n}\n\n#ifdef CONFIG_DMI\nenum smbios_attr_enum {\n\tSMBIOS_ATTR_NONE = 0,\n\tSMBIOS_ATTR_LABEL_SHOW,\n\tSMBIOS_ATTR_INSTANCE_SHOW,\n};\n\nstatic size_t find_smbios_instance_string(struct pci_dev *pdev, char *buf,\n\t\t\t\t\t  enum smbios_attr_enum attribute)\n{\n\tconst struct dmi_device *dmi;\n\tstruct dmi_dev_onboard *donboard;\n\tint domain_nr = pci_domain_nr(pdev->bus);\n\tint bus = pdev->bus->number;\n\tint devfn = pdev->devfn;\n\n\tdmi = NULL;\n\twhile ((dmi = dmi_find_device(DMI_DEV_TYPE_DEV_ONBOARD,\n\t\t\t\t      NULL, dmi)) != NULL) {\n\t\tdonboard = dmi->device_data;\n\t\tif (donboard && donboard->segment == domain_nr &&\n\t\t\t\tdonboard->bus == bus &&\n\t\t\t\tdonboard->devfn == devfn) {\n\t\t\tif (buf) {\n\t\t\t\tif (attribute == SMBIOS_ATTR_INSTANCE_SHOW)\n\t\t\t\t\treturn sysfs_emit(buf, \"%d\\n\",\n\t\t\t\t\t\t\t  donboard->instance);\n\t\t\t\telse if (attribute == SMBIOS_ATTR_LABEL_SHOW)\n\t\t\t\t\treturn sysfs_emit(buf, \"%s\\n\",\n\t\t\t\t\t\t\t  dmi->name);\n\t\t\t}\n\t\t\treturn strlen(dmi->name);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic ssize_t smbios_label_show(struct device *dev,\n\t\t\t\t struct device_attribute *attr, char *buf)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\n\treturn find_smbios_instance_string(pdev, buf,\n\t\t\t\t\t   SMBIOS_ATTR_LABEL_SHOW);\n}\nstatic struct device_attribute dev_attr_smbios_label = __ATTR(label, 0444,\n\t\t\t\t\t\t    smbios_label_show, NULL);\n\nstatic ssize_t index_show(struct device *dev, struct device_attribute *attr,\n\t\t\t  char *buf)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\n\treturn find_smbios_instance_string(pdev, buf,\n\t\t\t\t\t   SMBIOS_ATTR_INSTANCE_SHOW);\n}\nstatic DEVICE_ATTR_RO(index);\n\nstatic struct attribute *smbios_attrs[] = {\n\t&dev_attr_smbios_label.attr,\n\t&dev_attr_index.attr,\n\tNULL,\n};\n\nstatic umode_t smbios_attr_is_visible(struct kobject *kobj, struct attribute *a,\n\t\t\t\t      int n)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\n\tif (device_has_acpi_name(dev))\n\t\treturn 0;\n\n\tif (!find_smbios_instance_string(pdev, NULL, SMBIOS_ATTR_NONE))\n\t\treturn 0;\n\n\treturn a->mode;\n}\n\nconst struct attribute_group pci_dev_smbios_attr_group = {\n\t.attrs = smbios_attrs,\n\t.is_visible = smbios_attr_is_visible,\n};\n#endif\n\n#ifdef CONFIG_ACPI\nenum acpi_attr_enum {\n\tACPI_ATTR_LABEL_SHOW,\n\tACPI_ATTR_INDEX_SHOW,\n};\n\nstatic int dsm_label_utf16s_to_utf8s(union acpi_object *obj, char *buf)\n{\n\tint len;\n\n\tlen = utf16s_to_utf8s((const wchar_t *)obj->buffer.pointer,\n\t\t\t      obj->buffer.length,\n\t\t\t      UTF16_LITTLE_ENDIAN,\n\t\t\t      buf, PAGE_SIZE - 1);\n\tbuf[len++] = '\\n';\n\n\treturn len;\n}\n\nstatic int dsm_get_label(struct device *dev, char *buf,\n\t\t\t enum acpi_attr_enum attr)\n{\n\tacpi_handle handle = ACPI_HANDLE(dev);\n\tunion acpi_object *obj, *tmp;\n\tint len = 0;\n\n\tif (!handle)\n\t\treturn -1;\n\n\tobj = acpi_evaluate_dsm(handle, &pci_acpi_dsm_guid, 0x2,\n\t\t\t\tDSM_PCI_DEVICE_NAME, NULL);\n\tif (!obj)\n\t\treturn -1;\n\n\ttmp = obj->package.elements;\n\tif (obj->type == ACPI_TYPE_PACKAGE && obj->package.count == 2 &&\n\t    tmp[0].type == ACPI_TYPE_INTEGER &&\n\t    (tmp[1].type == ACPI_TYPE_STRING ||\n\t     tmp[1].type == ACPI_TYPE_BUFFER)) {\n\t\t \n\t\tif (attr == ACPI_ATTR_INDEX_SHOW) {\n\t\t\tlen = sysfs_emit(buf, \"%llu\\n\", tmp->integer.value);\n\t\t} else if (attr == ACPI_ATTR_LABEL_SHOW) {\n\t\t\tif (tmp[1].type == ACPI_TYPE_STRING)\n\t\t\t\tlen = sysfs_emit(buf, \"%s\\n\",\n\t\t\t\t\t\t tmp[1].string.pointer);\n\t\t\telse if (tmp[1].type == ACPI_TYPE_BUFFER)\n\t\t\t\tlen = dsm_label_utf16s_to_utf8s(tmp + 1, buf);\n\t\t}\n\t}\n\n\tACPI_FREE(obj);\n\n\treturn len > 0 ? len : -1;\n}\n\nstatic ssize_t label_show(struct device *dev, struct device_attribute *attr,\n\t\t\t  char *buf)\n{\n\treturn dsm_get_label(dev, buf, ACPI_ATTR_LABEL_SHOW);\n}\nstatic DEVICE_ATTR_RO(label);\n\nstatic ssize_t acpi_index_show(struct device *dev,\n\t\t\t      struct device_attribute *attr, char *buf)\n{\n\treturn dsm_get_label(dev, buf, ACPI_ATTR_INDEX_SHOW);\n}\nstatic DEVICE_ATTR_RO(acpi_index);\n\nstatic struct attribute *acpi_attrs[] = {\n\t&dev_attr_label.attr,\n\t&dev_attr_acpi_index.attr,\n\tNULL,\n};\n\nstatic umode_t acpi_attr_is_visible(struct kobject *kobj, struct attribute *a,\n\t\t\t\t    int n)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\n\tif (!device_has_acpi_name(dev))\n\t\treturn 0;\n\n\treturn a->mode;\n}\n\nconst struct attribute_group pci_dev_acpi_attr_group = {\n\t.attrs = acpi_attrs,\n\t.is_visible = acpi_attr_is_visible,\n};\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}