{
  "module_name": "pci-acpi.c",
  "hash_id": "511812dc4607b83ea3a2bc8a7c26cac16222e90a4d404d48568227a56de0a565",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/pci-acpi.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/irqdomain.h>\n#include <linux/pci.h>\n#include <linux/msi.h>\n#include <linux/pci_hotplug.h>\n#include <linux/module.h>\n#include <linux/pci-acpi.h>\n#include <linux/pm_runtime.h>\n#include <linux/pm_qos.h>\n#include <linux/rwsem.h>\n#include \"pci.h\"\n\n \nconst guid_t pci_acpi_dsm_guid =\n\tGUID_INIT(0xe5c937d0, 0x3553, 0x4d7a,\n\t\t  0x91, 0x17, 0xea, 0x4d, 0x19, 0xc3, 0x43, 0x4d);\n\n#if defined(CONFIG_PCI_QUIRKS) && defined(CONFIG_ARM64)\nstatic int acpi_get_rc_addr(struct acpi_device *adev, struct resource *res)\n{\n\tstruct device *dev = &adev->dev;\n\tstruct resource_entry *entry;\n\tstruct list_head list;\n\tunsigned long flags;\n\tint ret;\n\n\tINIT_LIST_HEAD(&list);\n\tflags = IORESOURCE_MEM;\n\tret = acpi_dev_get_resources(adev, &list,\n\t\t\t\t     acpi_dev_filter_resource_type_cb,\n\t\t\t\t     (void *) flags);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to parse _CRS method, error code %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tif (ret == 0) {\n\t\tdev_err(dev, \"no IO and memory resources present in _CRS\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tentry = list_first_entry(&list, struct resource_entry, node);\n\t*res = *entry->res;\n\tacpi_dev_free_resource_list(&list);\n\treturn 0;\n}\n\nstatic acpi_status acpi_match_rc(acpi_handle handle, u32 lvl, void *context,\n\t\t\t\t void **retval)\n{\n\tu16 *segment = context;\n\tunsigned long long uid;\n\tacpi_status status;\n\n\tstatus = acpi_evaluate_integer(handle, METHOD_NAME__UID, NULL, &uid);\n\tif (ACPI_FAILURE(status) || uid != *segment)\n\t\treturn AE_CTRL_DEPTH;\n\n\t*(acpi_handle *)retval = handle;\n\treturn AE_CTRL_TERMINATE;\n}\n\nint acpi_get_rc_resources(struct device *dev, const char *hid, u16 segment,\n\t\t\t  struct resource *res)\n{\n\tstruct acpi_device *adev;\n\tacpi_status status;\n\tacpi_handle handle;\n\tint ret;\n\n\tstatus = acpi_get_devices(hid, acpi_match_rc, &segment, &handle);\n\tif (ACPI_FAILURE(status)) {\n\t\tdev_err(dev, \"can't find _HID %s device to locate resources\\n\",\n\t\t\thid);\n\t\treturn -ENODEV;\n\t}\n\n\tadev = acpi_fetch_acpi_dev(handle);\n\tif (!adev)\n\t\treturn -ENODEV;\n\n\tret = acpi_get_rc_addr(adev, res);\n\tif (ret) {\n\t\tdev_err(dev, \"can't get resource from %s\\n\",\n\t\t\tdev_name(&adev->dev));\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n#endif\n\nphys_addr_t acpi_pci_root_get_mcfg_addr(acpi_handle handle)\n{\n\tacpi_status status = AE_NOT_EXIST;\n\tunsigned long long mcfg_addr;\n\n\tif (handle)\n\t\tstatus = acpi_evaluate_integer(handle, METHOD_NAME__CBA,\n\t\t\t\t\t       NULL, &mcfg_addr);\n\tif (ACPI_FAILURE(status))\n\t\treturn 0;\n\n\treturn (phys_addr_t)mcfg_addr;\n}\n\n \nstruct hpx_type0 {\n\tu32 revision;\t\t \n\tu8  cache_line_size;\t \n\tu8  latency_timer;\t \n\tu8  enable_serr;\n\tu8  enable_perr;\n};\n\nstatic struct hpx_type0 pci_default_type0 = {\n\t.revision = 1,\n\t.cache_line_size = 8,\n\t.latency_timer = 0x40,\n\t.enable_serr = 0,\n\t.enable_perr = 0,\n};\n\nstatic void program_hpx_type0(struct pci_dev *dev, struct hpx_type0 *hpx)\n{\n\tu16 pci_cmd, pci_bctl;\n\n\tif (!hpx)\n\t\thpx = &pci_default_type0;\n\n\tif (hpx->revision > 1) {\n\t\tpci_warn(dev, \"PCI settings rev %d not supported; using defaults\\n\",\n\t\t\t hpx->revision);\n\t\thpx = &pci_default_type0;\n\t}\n\n\tpci_write_config_byte(dev, PCI_CACHE_LINE_SIZE, hpx->cache_line_size);\n\tpci_write_config_byte(dev, PCI_LATENCY_TIMER, hpx->latency_timer);\n\tpci_read_config_word(dev, PCI_COMMAND, &pci_cmd);\n\tif (hpx->enable_serr)\n\t\tpci_cmd |= PCI_COMMAND_SERR;\n\tif (hpx->enable_perr)\n\t\tpci_cmd |= PCI_COMMAND_PARITY;\n\tpci_write_config_word(dev, PCI_COMMAND, pci_cmd);\n\n\t \n\tif ((dev->class >> 8) == PCI_CLASS_BRIDGE_PCI) {\n\t\tpci_write_config_byte(dev, PCI_SEC_LATENCY_TIMER,\n\t\t\t\t      hpx->latency_timer);\n\t\tpci_read_config_word(dev, PCI_BRIDGE_CONTROL, &pci_bctl);\n\t\tif (hpx->enable_perr)\n\t\t\tpci_bctl |= PCI_BRIDGE_CTL_PARITY;\n\t\tpci_write_config_word(dev, PCI_BRIDGE_CONTROL, pci_bctl);\n\t}\n}\n\nstatic acpi_status decode_type0_hpx_record(union acpi_object *record,\n\t\t\t\t\t   struct hpx_type0 *hpx0)\n{\n\tint i;\n\tunion acpi_object *fields = record->package.elements;\n\tu32 revision = fields[1].integer.value;\n\n\tswitch (revision) {\n\tcase 1:\n\t\tif (record->package.count != 6)\n\t\t\treturn AE_ERROR;\n\t\tfor (i = 2; i < 6; i++)\n\t\t\tif (fields[i].type != ACPI_TYPE_INTEGER)\n\t\t\t\treturn AE_ERROR;\n\t\thpx0->revision        = revision;\n\t\thpx0->cache_line_size = fields[2].integer.value;\n\t\thpx0->latency_timer   = fields[3].integer.value;\n\t\thpx0->enable_serr     = fields[4].integer.value;\n\t\thpx0->enable_perr     = fields[5].integer.value;\n\t\tbreak;\n\tdefault:\n\t\tpr_warn(\"%s: Type 0 Revision %d record not supported\\n\",\n\t\t       __func__, revision);\n\t\treturn AE_ERROR;\n\t}\n\treturn AE_OK;\n}\n\n \nstruct hpx_type1 {\n\tu32 revision;\n\tu8  max_mem_read;\n\tu8  avg_max_split;\n\tu16 tot_max_split;\n};\n\nstatic void program_hpx_type1(struct pci_dev *dev, struct hpx_type1 *hpx)\n{\n\tint pos;\n\n\tif (!hpx)\n\t\treturn;\n\n\tpos = pci_find_capability(dev, PCI_CAP_ID_PCIX);\n\tif (!pos)\n\t\treturn;\n\n\tpci_warn(dev, \"PCI-X settings not supported\\n\");\n}\n\nstatic acpi_status decode_type1_hpx_record(union acpi_object *record,\n\t\t\t\t\t   struct hpx_type1 *hpx1)\n{\n\tint i;\n\tunion acpi_object *fields = record->package.elements;\n\tu32 revision = fields[1].integer.value;\n\n\tswitch (revision) {\n\tcase 1:\n\t\tif (record->package.count != 5)\n\t\t\treturn AE_ERROR;\n\t\tfor (i = 2; i < 5; i++)\n\t\t\tif (fields[i].type != ACPI_TYPE_INTEGER)\n\t\t\t\treturn AE_ERROR;\n\t\thpx1->revision      = revision;\n\t\thpx1->max_mem_read  = fields[2].integer.value;\n\t\thpx1->avg_max_split = fields[3].integer.value;\n\t\thpx1->tot_max_split = fields[4].integer.value;\n\t\tbreak;\n\tdefault:\n\t\tpr_warn(\"%s: Type 1 Revision %d record not supported\\n\",\n\t\t       __func__, revision);\n\t\treturn AE_ERROR;\n\t}\n\treturn AE_OK;\n}\n\nstatic bool pcie_root_rcb_set(struct pci_dev *dev)\n{\n\tstruct pci_dev *rp = pcie_find_root_port(dev);\n\tu16 lnkctl;\n\n\tif (!rp)\n\t\treturn false;\n\n\tpcie_capability_read_word(rp, PCI_EXP_LNKCTL, &lnkctl);\n\tif (lnkctl & PCI_EXP_LNKCTL_RCB)\n\t\treturn true;\n\n\treturn false;\n}\n\n \nstruct hpx_type2 {\n\tu32 revision;\n\tu32 unc_err_mask_and;\n\tu32 unc_err_mask_or;\n\tu32 unc_err_sever_and;\n\tu32 unc_err_sever_or;\n\tu32 cor_err_mask_and;\n\tu32 cor_err_mask_or;\n\tu32 adv_err_cap_and;\n\tu32 adv_err_cap_or;\n\tu16 pci_exp_devctl_and;\n\tu16 pci_exp_devctl_or;\n\tu16 pci_exp_lnkctl_and;\n\tu16 pci_exp_lnkctl_or;\n\tu32 sec_unc_err_sever_and;\n\tu32 sec_unc_err_sever_or;\n\tu32 sec_unc_err_mask_and;\n\tu32 sec_unc_err_mask_or;\n};\n\nstatic void program_hpx_type2(struct pci_dev *dev, struct hpx_type2 *hpx)\n{\n\tint pos;\n\tu32 reg32;\n\n\tif (!hpx)\n\t\treturn;\n\n\tif (!pci_is_pcie(dev))\n\t\treturn;\n\n\tif (hpx->revision > 1) {\n\t\tpci_warn(dev, \"PCIe settings rev %d not supported\\n\",\n\t\t\t hpx->revision);\n\t\treturn;\n\t}\n\n\t \n\thpx->pci_exp_devctl_and |= PCI_EXP_DEVCTL_PAYLOAD |\n\t\t\t\t    PCI_EXP_DEVCTL_READRQ;\n\thpx->pci_exp_devctl_or &= ~(PCI_EXP_DEVCTL_PAYLOAD |\n\t\t\t\t    PCI_EXP_DEVCTL_READRQ);\n\n\t \n\tpcie_capability_clear_and_set_word(dev, PCI_EXP_DEVCTL,\n\t\t\t~hpx->pci_exp_devctl_and, hpx->pci_exp_devctl_or);\n\n\t \n\tif (pcie_cap_has_lnkctl(dev)) {\n\n\t\t \n\t\thpx->pci_exp_lnkctl_and |= PCI_EXP_LNKCTL_RCB;\n\t\thpx->pci_exp_lnkctl_or &= ~PCI_EXP_LNKCTL_RCB;\n\t\tif (pcie_root_rcb_set(dev))\n\t\t\thpx->pci_exp_lnkctl_or |= PCI_EXP_LNKCTL_RCB;\n\n\t\tpcie_capability_clear_and_set_word(dev, PCI_EXP_LNKCTL,\n\t\t\t~hpx->pci_exp_lnkctl_and, hpx->pci_exp_lnkctl_or);\n\t}\n\n\t \n\tpos = pci_find_ext_capability(dev, PCI_EXT_CAP_ID_ERR);\n\tif (!pos)\n\t\treturn;\n\n\t \n\tpci_read_config_dword(dev, pos + PCI_ERR_UNCOR_MASK, &reg32);\n\treg32 = (reg32 & hpx->unc_err_mask_and) | hpx->unc_err_mask_or;\n\tpci_write_config_dword(dev, pos + PCI_ERR_UNCOR_MASK, reg32);\n\n\t \n\tpci_read_config_dword(dev, pos + PCI_ERR_UNCOR_SEVER, &reg32);\n\treg32 = (reg32 & hpx->unc_err_sever_and) | hpx->unc_err_sever_or;\n\tpci_write_config_dword(dev, pos + PCI_ERR_UNCOR_SEVER, reg32);\n\n\t \n\tpci_read_config_dword(dev, pos + PCI_ERR_COR_MASK, &reg32);\n\treg32 = (reg32 & hpx->cor_err_mask_and) | hpx->cor_err_mask_or;\n\tpci_write_config_dword(dev, pos + PCI_ERR_COR_MASK, reg32);\n\n\t \n\tpci_read_config_dword(dev, pos + PCI_ERR_CAP, &reg32);\n\treg32 = (reg32 & hpx->adv_err_cap_and) | hpx->adv_err_cap_or;\n\n\t \n\tif (!(reg32 & PCI_ERR_CAP_ECRC_GENC))\n\t\treg32 &= ~PCI_ERR_CAP_ECRC_GENE;\n\tif (!(reg32 & PCI_ERR_CAP_ECRC_CHKC))\n\t\treg32 &= ~PCI_ERR_CAP_ECRC_CHKE;\n\tpci_write_config_dword(dev, pos + PCI_ERR_CAP, reg32);\n\n\t \n}\n\nstatic acpi_status decode_type2_hpx_record(union acpi_object *record,\n\t\t\t\t\t   struct hpx_type2 *hpx2)\n{\n\tint i;\n\tunion acpi_object *fields = record->package.elements;\n\tu32 revision = fields[1].integer.value;\n\n\tswitch (revision) {\n\tcase 1:\n\t\tif (record->package.count != 18)\n\t\t\treturn AE_ERROR;\n\t\tfor (i = 2; i < 18; i++)\n\t\t\tif (fields[i].type != ACPI_TYPE_INTEGER)\n\t\t\t\treturn AE_ERROR;\n\t\thpx2->revision      = revision;\n\t\thpx2->unc_err_mask_and      = fields[2].integer.value;\n\t\thpx2->unc_err_mask_or       = fields[3].integer.value;\n\t\thpx2->unc_err_sever_and     = fields[4].integer.value;\n\t\thpx2->unc_err_sever_or      = fields[5].integer.value;\n\t\thpx2->cor_err_mask_and      = fields[6].integer.value;\n\t\thpx2->cor_err_mask_or       = fields[7].integer.value;\n\t\thpx2->adv_err_cap_and       = fields[8].integer.value;\n\t\thpx2->adv_err_cap_or        = fields[9].integer.value;\n\t\thpx2->pci_exp_devctl_and    = fields[10].integer.value;\n\t\thpx2->pci_exp_devctl_or     = fields[11].integer.value;\n\t\thpx2->pci_exp_lnkctl_and    = fields[12].integer.value;\n\t\thpx2->pci_exp_lnkctl_or     = fields[13].integer.value;\n\t\thpx2->sec_unc_err_sever_and = fields[14].integer.value;\n\t\thpx2->sec_unc_err_sever_or  = fields[15].integer.value;\n\t\thpx2->sec_unc_err_mask_and  = fields[16].integer.value;\n\t\thpx2->sec_unc_err_mask_or   = fields[17].integer.value;\n\t\tbreak;\n\tdefault:\n\t\tpr_warn(\"%s: Type 2 Revision %d record not supported\\n\",\n\t\t       __func__, revision);\n\t\treturn AE_ERROR;\n\t}\n\treturn AE_OK;\n}\n\n \nstruct hpx_type3 {\n\tu16 device_type;\n\tu16 function_type;\n\tu16 config_space_location;\n\tu16 pci_exp_cap_id;\n\tu16 pci_exp_cap_ver;\n\tu16 pci_exp_vendor_id;\n\tu16 dvsec_id;\n\tu16 dvsec_rev;\n\tu16 match_offset;\n\tu32 match_mask_and;\n\tu32 match_value;\n\tu16 reg_offset;\n\tu32 reg_mask_and;\n\tu32 reg_mask_or;\n};\n\nenum hpx_type3_dev_type {\n\tHPX_TYPE_ENDPOINT\t= BIT(0),\n\tHPX_TYPE_LEG_END\t= BIT(1),\n\tHPX_TYPE_RC_END\t\t= BIT(2),\n\tHPX_TYPE_RC_EC\t\t= BIT(3),\n\tHPX_TYPE_ROOT_PORT\t= BIT(4),\n\tHPX_TYPE_UPSTREAM\t= BIT(5),\n\tHPX_TYPE_DOWNSTREAM\t= BIT(6),\n\tHPX_TYPE_PCI_BRIDGE\t= BIT(7),\n\tHPX_TYPE_PCIE_BRIDGE\t= BIT(8),\n};\n\nstatic u16 hpx3_device_type(struct pci_dev *dev)\n{\n\tu16 pcie_type = pci_pcie_type(dev);\n\tstatic const int pcie_to_hpx3_type[] = {\n\t\t[PCI_EXP_TYPE_ENDPOINT]    = HPX_TYPE_ENDPOINT,\n\t\t[PCI_EXP_TYPE_LEG_END]     = HPX_TYPE_LEG_END,\n\t\t[PCI_EXP_TYPE_RC_END]      = HPX_TYPE_RC_END,\n\t\t[PCI_EXP_TYPE_RC_EC]       = HPX_TYPE_RC_EC,\n\t\t[PCI_EXP_TYPE_ROOT_PORT]   = HPX_TYPE_ROOT_PORT,\n\t\t[PCI_EXP_TYPE_UPSTREAM]    = HPX_TYPE_UPSTREAM,\n\t\t[PCI_EXP_TYPE_DOWNSTREAM]  = HPX_TYPE_DOWNSTREAM,\n\t\t[PCI_EXP_TYPE_PCI_BRIDGE]  = HPX_TYPE_PCI_BRIDGE,\n\t\t[PCI_EXP_TYPE_PCIE_BRIDGE] = HPX_TYPE_PCIE_BRIDGE,\n\t};\n\n\tif (pcie_type >= ARRAY_SIZE(pcie_to_hpx3_type))\n\t\treturn 0;\n\n\treturn pcie_to_hpx3_type[pcie_type];\n}\n\nenum hpx_type3_fn_type {\n\tHPX_FN_NORMAL\t\t= BIT(0),\n\tHPX_FN_SRIOV_PHYS\t= BIT(1),\n\tHPX_FN_SRIOV_VIRT\t= BIT(2),\n};\n\nstatic u8 hpx3_function_type(struct pci_dev *dev)\n{\n\tif (dev->is_virtfn)\n\t\treturn HPX_FN_SRIOV_VIRT;\n\telse if (pci_find_ext_capability(dev, PCI_EXT_CAP_ID_SRIOV) > 0)\n\t\treturn HPX_FN_SRIOV_PHYS;\n\telse\n\t\treturn HPX_FN_NORMAL;\n}\n\nstatic bool hpx3_cap_ver_matches(u8 pcie_cap_id, u8 hpx3_cap_id)\n{\n\tu8 cap_ver = hpx3_cap_id & 0xf;\n\n\tif ((hpx3_cap_id & BIT(4)) && cap_ver >= pcie_cap_id)\n\t\treturn true;\n\telse if (cap_ver == pcie_cap_id)\n\t\treturn true;\n\n\treturn false;\n}\n\nenum hpx_type3_cfg_loc {\n\tHPX_CFG_PCICFG\t\t= 0,\n\tHPX_CFG_PCIE_CAP\t= 1,\n\tHPX_CFG_PCIE_CAP_EXT\t= 2,\n\tHPX_CFG_VEND_CAP\t= 3,\n\tHPX_CFG_DVSEC\t\t= 4,\n\tHPX_CFG_MAX,\n};\n\nstatic void program_hpx_type3_register(struct pci_dev *dev,\n\t\t\t\t       const struct hpx_type3 *reg)\n{\n\tu32 match_reg, write_reg, header, orig_value;\n\tu16 pos;\n\n\tif (!(hpx3_device_type(dev) & reg->device_type))\n\t\treturn;\n\n\tif (!(hpx3_function_type(dev) & reg->function_type))\n\t\treturn;\n\n\tswitch (reg->config_space_location) {\n\tcase HPX_CFG_PCICFG:\n\t\tpos = 0;\n\t\tbreak;\n\tcase HPX_CFG_PCIE_CAP:\n\t\tpos = pci_find_capability(dev, reg->pci_exp_cap_id);\n\t\tif (pos == 0)\n\t\t\treturn;\n\n\t\tbreak;\n\tcase HPX_CFG_PCIE_CAP_EXT:\n\t\tpos = pci_find_ext_capability(dev, reg->pci_exp_cap_id);\n\t\tif (pos == 0)\n\t\t\treturn;\n\n\t\tpci_read_config_dword(dev, pos, &header);\n\t\tif (!hpx3_cap_ver_matches(PCI_EXT_CAP_VER(header),\n\t\t\t\t\t  reg->pci_exp_cap_ver))\n\t\t\treturn;\n\n\t\tbreak;\n\tcase HPX_CFG_VEND_CAP:\n\tcase HPX_CFG_DVSEC:\n\tdefault:\n\t\tpci_warn(dev, \"Encountered _HPX type 3 with unsupported config space location\");\n\t\treturn;\n\t}\n\n\tpci_read_config_dword(dev, pos + reg->match_offset, &match_reg);\n\n\tif ((match_reg & reg->match_mask_and) != reg->match_value)\n\t\treturn;\n\n\tpci_read_config_dword(dev, pos + reg->reg_offset, &write_reg);\n\torig_value = write_reg;\n\twrite_reg &= reg->reg_mask_and;\n\twrite_reg |= reg->reg_mask_or;\n\n\tif (orig_value == write_reg)\n\t\treturn;\n\n\tpci_write_config_dword(dev, pos + reg->reg_offset, write_reg);\n\n\tpci_dbg(dev, \"Applied _HPX3 at [0x%x]: 0x%08x -> 0x%08x\",\n\t\tpos, orig_value, write_reg);\n}\n\nstatic void program_hpx_type3(struct pci_dev *dev, struct hpx_type3 *hpx)\n{\n\tif (!hpx)\n\t\treturn;\n\n\tif (!pci_is_pcie(dev))\n\t\treturn;\n\n\tprogram_hpx_type3_register(dev, hpx);\n}\n\nstatic void parse_hpx3_register(struct hpx_type3 *hpx3_reg,\n\t\t\t\tunion acpi_object *reg_fields)\n{\n\thpx3_reg->device_type            = reg_fields[0].integer.value;\n\thpx3_reg->function_type          = reg_fields[1].integer.value;\n\thpx3_reg->config_space_location  = reg_fields[2].integer.value;\n\thpx3_reg->pci_exp_cap_id         = reg_fields[3].integer.value;\n\thpx3_reg->pci_exp_cap_ver        = reg_fields[4].integer.value;\n\thpx3_reg->pci_exp_vendor_id      = reg_fields[5].integer.value;\n\thpx3_reg->dvsec_id               = reg_fields[6].integer.value;\n\thpx3_reg->dvsec_rev              = reg_fields[7].integer.value;\n\thpx3_reg->match_offset           = reg_fields[8].integer.value;\n\thpx3_reg->match_mask_and         = reg_fields[9].integer.value;\n\thpx3_reg->match_value            = reg_fields[10].integer.value;\n\thpx3_reg->reg_offset             = reg_fields[11].integer.value;\n\thpx3_reg->reg_mask_and           = reg_fields[12].integer.value;\n\thpx3_reg->reg_mask_or            = reg_fields[13].integer.value;\n}\n\nstatic acpi_status program_type3_hpx_record(struct pci_dev *dev,\n\t\t\t\t\t   union acpi_object *record)\n{\n\tunion acpi_object *fields = record->package.elements;\n\tu32 desc_count, expected_length, revision;\n\tunion acpi_object *reg_fields;\n\tstruct hpx_type3 hpx3;\n\tint i;\n\n\trevision = fields[1].integer.value;\n\tswitch (revision) {\n\tcase 1:\n\t\tdesc_count = fields[2].integer.value;\n\t\texpected_length = 3 + desc_count * 14;\n\n\t\tif (record->package.count != expected_length)\n\t\t\treturn AE_ERROR;\n\n\t\tfor (i = 2; i < expected_length; i++)\n\t\t\tif (fields[i].type != ACPI_TYPE_INTEGER)\n\t\t\t\treturn AE_ERROR;\n\n\t\tfor (i = 0; i < desc_count; i++) {\n\t\t\treg_fields = fields + 3 + i * 14;\n\t\t\tparse_hpx3_register(&hpx3, reg_fields);\n\t\t\tprogram_hpx_type3(dev, &hpx3);\n\t\t}\n\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_WARNING\n\t\t\t\"%s: Type 3 Revision %d record not supported\\n\",\n\t\t\t__func__, revision);\n\t\treturn AE_ERROR;\n\t}\n\treturn AE_OK;\n}\n\nstatic acpi_status acpi_run_hpx(struct pci_dev *dev, acpi_handle handle)\n{\n\tacpi_status status;\n\tstruct acpi_buffer buffer = {ACPI_ALLOCATE_BUFFER, NULL};\n\tunion acpi_object *package, *record, *fields;\n\tstruct hpx_type0 hpx0;\n\tstruct hpx_type1 hpx1;\n\tstruct hpx_type2 hpx2;\n\tu32 type;\n\tint i;\n\n\tstatus = acpi_evaluate_object(handle, \"_HPX\", NULL, &buffer);\n\tif (ACPI_FAILURE(status))\n\t\treturn status;\n\n\tpackage = (union acpi_object *)buffer.pointer;\n\tif (package->type != ACPI_TYPE_PACKAGE) {\n\t\tstatus = AE_ERROR;\n\t\tgoto exit;\n\t}\n\n\tfor (i = 0; i < package->package.count; i++) {\n\t\trecord = &package->package.elements[i];\n\t\tif (record->type != ACPI_TYPE_PACKAGE) {\n\t\t\tstatus = AE_ERROR;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tfields = record->package.elements;\n\t\tif (fields[0].type != ACPI_TYPE_INTEGER ||\n\t\t    fields[1].type != ACPI_TYPE_INTEGER) {\n\t\t\tstatus = AE_ERROR;\n\t\t\tgoto exit;\n\t\t}\n\n\t\ttype = fields[0].integer.value;\n\t\tswitch (type) {\n\t\tcase 0:\n\t\t\tmemset(&hpx0, 0, sizeof(hpx0));\n\t\t\tstatus = decode_type0_hpx_record(record, &hpx0);\n\t\t\tif (ACPI_FAILURE(status))\n\t\t\t\tgoto exit;\n\t\t\tprogram_hpx_type0(dev, &hpx0);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tmemset(&hpx1, 0, sizeof(hpx1));\n\t\t\tstatus = decode_type1_hpx_record(record, &hpx1);\n\t\t\tif (ACPI_FAILURE(status))\n\t\t\t\tgoto exit;\n\t\t\tprogram_hpx_type1(dev, &hpx1);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tmemset(&hpx2, 0, sizeof(hpx2));\n\t\t\tstatus = decode_type2_hpx_record(record, &hpx2);\n\t\t\tif (ACPI_FAILURE(status))\n\t\t\t\tgoto exit;\n\t\t\tprogram_hpx_type2(dev, &hpx2);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tstatus = program_type3_hpx_record(dev, record);\n\t\t\tif (ACPI_FAILURE(status))\n\t\t\t\tgoto exit;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"%s: Type %d record not supported\\n\",\n\t\t\t       __func__, type);\n\t\t\tstatus = AE_ERROR;\n\t\t\tgoto exit;\n\t\t}\n\t}\n exit:\n\tkfree(buffer.pointer);\n\treturn status;\n}\n\nstatic acpi_status acpi_run_hpp(struct pci_dev *dev, acpi_handle handle)\n{\n\tacpi_status status;\n\tstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };\n\tunion acpi_object *package, *fields;\n\tstruct hpx_type0 hpx0;\n\tint i;\n\n\tmemset(&hpx0, 0, sizeof(hpx0));\n\n\tstatus = acpi_evaluate_object(handle, \"_HPP\", NULL, &buffer);\n\tif (ACPI_FAILURE(status))\n\t\treturn status;\n\n\tpackage = (union acpi_object *) buffer.pointer;\n\tif (package->type != ACPI_TYPE_PACKAGE ||\n\t    package->package.count != 4) {\n\t\tstatus = AE_ERROR;\n\t\tgoto exit;\n\t}\n\n\tfields = package->package.elements;\n\tfor (i = 0; i < 4; i++) {\n\t\tif (fields[i].type != ACPI_TYPE_INTEGER) {\n\t\t\tstatus = AE_ERROR;\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\thpx0.revision        = 1;\n\thpx0.cache_line_size = fields[0].integer.value;\n\thpx0.latency_timer   = fields[1].integer.value;\n\thpx0.enable_serr     = fields[2].integer.value;\n\thpx0.enable_perr     = fields[3].integer.value;\n\n\tprogram_hpx_type0(dev, &hpx0);\n\nexit:\n\tkfree(buffer.pointer);\n\treturn status;\n}\n\n \nint pci_acpi_program_hp_params(struct pci_dev *dev)\n{\n\tacpi_status status;\n\tacpi_handle handle, phandle;\n\tstruct pci_bus *pbus;\n\n\tif (acpi_pci_disabled)\n\t\treturn -ENODEV;\n\n\thandle = NULL;\n\tfor (pbus = dev->bus; pbus; pbus = pbus->parent) {\n\t\thandle = acpi_pci_get_bridge_handle(pbus);\n\t\tif (handle)\n\t\t\tbreak;\n\t}\n\n\t \n\twhile (handle) {\n\t\tstatus = acpi_run_hpx(dev, handle);\n\t\tif (ACPI_SUCCESS(status))\n\t\t\treturn 0;\n\t\tstatus = acpi_run_hpp(dev, handle);\n\t\tif (ACPI_SUCCESS(status))\n\t\t\treturn 0;\n\t\tif (acpi_is_root_bridge(handle))\n\t\t\tbreak;\n\t\tstatus = acpi_get_parent(handle, &phandle);\n\t\tif (ACPI_FAILURE(status))\n\t\t\tbreak;\n\t\thandle = phandle;\n\t}\n\treturn -ENODEV;\n}\n\n \nbool pciehp_is_native(struct pci_dev *bridge)\n{\n\tconst struct pci_host_bridge *host;\n\tu32 slot_cap;\n\n\tif (!IS_ENABLED(CONFIG_HOTPLUG_PCI_PCIE))\n\t\treturn false;\n\n\tpcie_capability_read_dword(bridge, PCI_EXP_SLTCAP, &slot_cap);\n\tif (!(slot_cap & PCI_EXP_SLTCAP_HPC))\n\t\treturn false;\n\n\tif (pcie_ports_native)\n\t\treturn true;\n\n\thost = pci_find_host_bridge(bridge->bus);\n\treturn host->native_pcie_hotplug;\n}\n\n \nbool shpchp_is_native(struct pci_dev *bridge)\n{\n\treturn bridge->shpc_managed;\n}\n\n \nstatic void pci_acpi_wake_bus(struct acpi_device_wakeup_context *context)\n{\n\tstruct acpi_device *adev;\n\tstruct acpi_pci_root *root;\n\n\tadev = container_of(context, struct acpi_device, wakeup.context);\n\troot = acpi_driver_data(adev);\n\tpci_pme_wakeup_bus(root->bus);\n}\n\n \nstatic void pci_acpi_wake_dev(struct acpi_device_wakeup_context *context)\n{\n\tstruct pci_dev *pci_dev;\n\n\tpci_dev = to_pci_dev(context->dev);\n\n\tif (pci_dev->pme_poll)\n\t\tpci_dev->pme_poll = false;\n\n\tif (pci_dev->current_state == PCI_D3cold) {\n\t\tpci_wakeup_event(pci_dev);\n\t\tpm_request_resume(&pci_dev->dev);\n\t\treturn;\n\t}\n\n\t \n\tif (pci_dev->pme_support)\n\t\tpci_check_pme_status(pci_dev);\n\n\tpci_wakeup_event(pci_dev);\n\tpm_request_resume(&pci_dev->dev);\n\n\tpci_pme_wakeup_bus(pci_dev->subordinate);\n}\n\n \nacpi_status pci_acpi_add_bus_pm_notifier(struct acpi_device *dev)\n{\n\treturn acpi_add_pm_notifier(dev, NULL, pci_acpi_wake_bus);\n}\n\n \nacpi_status pci_acpi_add_pm_notifier(struct acpi_device *dev,\n\t\t\t\t     struct pci_dev *pci_dev)\n{\n\treturn acpi_add_pm_notifier(dev, &pci_dev->dev, pci_acpi_wake_dev);\n}\n\n \n\npci_power_t acpi_pci_choose_state(struct pci_dev *pdev)\n{\n\tint acpi_state, d_max;\n\n\tif (pdev->no_d3cold || !pdev->d3cold_allowed)\n\t\td_max = ACPI_STATE_D3_HOT;\n\telse\n\t\td_max = ACPI_STATE_D3_COLD;\n\tacpi_state = acpi_pm_device_sleep_state(&pdev->dev, NULL, d_max);\n\tif (acpi_state < 0)\n\t\treturn PCI_POWER_ERROR;\n\n\tswitch (acpi_state) {\n\tcase ACPI_STATE_D0:\n\t\treturn PCI_D0;\n\tcase ACPI_STATE_D1:\n\t\treturn PCI_D1;\n\tcase ACPI_STATE_D2:\n\t\treturn PCI_D2;\n\tcase ACPI_STATE_D3_HOT:\n\t\treturn PCI_D3hot;\n\tcase ACPI_STATE_D3_COLD:\n\t\treturn PCI_D3cold;\n\t}\n\treturn PCI_POWER_ERROR;\n}\n\nstatic struct acpi_device *acpi_pci_find_companion(struct device *dev);\n\nvoid pci_set_acpi_fwnode(struct pci_dev *dev)\n{\n\tif (!dev_fwnode(&dev->dev) && !pci_dev_is_added(dev))\n\t\tACPI_COMPANION_SET(&dev->dev,\n\t\t\t\t   acpi_pci_find_companion(&dev->dev));\n}\n\n \nint pci_dev_acpi_reset(struct pci_dev *dev, bool probe)\n{\n\tacpi_handle handle = ACPI_HANDLE(&dev->dev);\n\n\tif (!handle || !acpi_has_method(handle, \"_RST\"))\n\t\treturn -ENOTTY;\n\n\tif (probe)\n\t\treturn 0;\n\n\tif (ACPI_FAILURE(acpi_evaluate_object(handle, \"_RST\", NULL, NULL))) {\n\t\tpci_warn(dev, \"ACPI _RST failed\\n\");\n\t\treturn -ENOTTY;\n\t}\n\n\treturn 0;\n}\n\nbool acpi_pci_power_manageable(struct pci_dev *dev)\n{\n\tstruct acpi_device *adev = ACPI_COMPANION(&dev->dev);\n\n\treturn adev && acpi_device_power_manageable(adev);\n}\n\nbool acpi_pci_bridge_d3(struct pci_dev *dev)\n{\n\tstruct pci_dev *rpdev;\n\tstruct acpi_device *adev, *rpadev;\n\tconst union acpi_object *obj;\n\n\tif (acpi_pci_disabled || !dev->is_hotplug_bridge)\n\t\treturn false;\n\n\tadev = ACPI_COMPANION(&dev->dev);\n\tif (adev) {\n\t\t \n\t\tif (acpi_dev_power_state_for_wake(adev) <= ACPI_STATE_D2)\n\t\t\treturn false;\n\n\t\t \n\t\tif (acpi_device_power_manageable(adev))\n\t\t\treturn true;\n\t}\n\n\trpdev = pcie_find_root_port(dev);\n\tif (!rpdev)\n\t\treturn false;\n\n\tif (rpdev == dev)\n\t\trpadev = adev;\n\telse\n\t\trpadev = ACPI_COMPANION(&rpdev->dev);\n\n\tif (!rpadev)\n\t\treturn false;\n\n\t \n\tif (!rpadev->wakeup.flags.valid)\n\t\treturn false;\n\n\t \n\tif (rpadev != adev &&\n\t    acpi_dev_power_state_for_wake(rpadev) <= ACPI_STATE_D2)\n\t\treturn false;\n\n\t \n\tif (!acpi_dev_get_property(rpadev, \"HotPlugSupportInD3\",\n\t\t\t\t   ACPI_TYPE_INTEGER, &obj) &&\n\t    obj->integer.value == 1)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic void acpi_pci_config_space_access(struct pci_dev *dev, bool enable)\n{\n\tint val = enable ? ACPI_REG_CONNECT : ACPI_REG_DISCONNECT;\n\tint ret = acpi_evaluate_reg(ACPI_HANDLE(&dev->dev),\n\t\t\t\t    ACPI_ADR_SPACE_PCI_CONFIG, val);\n\tif (ret)\n\t\tpci_dbg(dev, \"ACPI _REG %s evaluation failed (%d)\\n\",\n\t\t\tenable ? \"connect\" : \"disconnect\", ret);\n}\n\nint acpi_pci_set_power_state(struct pci_dev *dev, pci_power_t state)\n{\n\tstruct acpi_device *adev = ACPI_COMPANION(&dev->dev);\n\tstatic const u8 state_conv[] = {\n\t\t[PCI_D0] = ACPI_STATE_D0,\n\t\t[PCI_D1] = ACPI_STATE_D1,\n\t\t[PCI_D2] = ACPI_STATE_D2,\n\t\t[PCI_D3hot] = ACPI_STATE_D3_HOT,\n\t\t[PCI_D3cold] = ACPI_STATE_D3_COLD,\n\t};\n\tint error;\n\n\t \n\tif (!adev || acpi_has_method(adev->handle, \"_EJ0\"))\n\t\treturn -ENODEV;\n\n\tswitch (state) {\n\tcase PCI_D0:\n\tcase PCI_D1:\n\tcase PCI_D2:\n\tcase PCI_D3hot:\n\tcase PCI_D3cold:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (state == PCI_D3cold) {\n\t\tif (dev_pm_qos_flags(&dev->dev, PM_QOS_FLAG_NO_POWER_OFF) ==\n\t\t\t\tPM_QOS_FLAGS_ALL)\n\t\t\treturn -EBUSY;\n\n\t\t \n\t\tacpi_pci_config_space_access(dev, false);\n\t}\n\n\terror = acpi_device_set_power(adev, state_conv[state]);\n\tif (error)\n\t\treturn error;\n\n\tpci_dbg(dev, \"power state changed by ACPI to %s\\n\",\n\t        acpi_power_state_string(adev->power.state));\n\n\t \n\tif (state == PCI_D0)\n\t\tacpi_pci_config_space_access(dev, true);\n\n\treturn 0;\n}\n\npci_power_t acpi_pci_get_power_state(struct pci_dev *dev)\n{\n\tstruct acpi_device *adev = ACPI_COMPANION(&dev->dev);\n\tstatic const pci_power_t state_conv[] = {\n\t\t[ACPI_STATE_D0]      = PCI_D0,\n\t\t[ACPI_STATE_D1]      = PCI_D1,\n\t\t[ACPI_STATE_D2]      = PCI_D2,\n\t\t[ACPI_STATE_D3_HOT]  = PCI_D3hot,\n\t\t[ACPI_STATE_D3_COLD] = PCI_D3cold,\n\t};\n\tint state;\n\n\tif (!adev || !acpi_device_power_manageable(adev))\n\t\treturn PCI_UNKNOWN;\n\n\tstate = adev->power.state;\n\tif (state == ACPI_STATE_UNKNOWN)\n\t\treturn PCI_UNKNOWN;\n\n\treturn state_conv[state];\n}\n\nvoid acpi_pci_refresh_power_state(struct pci_dev *dev)\n{\n\tstruct acpi_device *adev = ACPI_COMPANION(&dev->dev);\n\n\tif (adev && acpi_device_power_manageable(adev))\n\t\tacpi_device_update_power(adev, NULL);\n}\n\nstatic int acpi_pci_propagate_wakeup(struct pci_bus *bus, bool enable)\n{\n\twhile (bus->parent) {\n\t\tif (acpi_pm_device_can_wakeup(&bus->self->dev))\n\t\t\treturn acpi_pm_set_device_wakeup(&bus->self->dev, enable);\n\n\t\tbus = bus->parent;\n\t}\n\n\t \n\tif (bus->bridge) {\n\t\tif (acpi_pm_device_can_wakeup(bus->bridge))\n\t\t\treturn acpi_pm_set_device_wakeup(bus->bridge, enable);\n\t}\n\treturn 0;\n}\n\nint acpi_pci_wakeup(struct pci_dev *dev, bool enable)\n{\n\tif (acpi_pci_disabled)\n\t\treturn 0;\n\n\tif (acpi_pm_device_can_wakeup(&dev->dev))\n\t\treturn acpi_pm_set_device_wakeup(&dev->dev, enable);\n\n\treturn acpi_pci_propagate_wakeup(dev->bus, enable);\n}\n\nbool acpi_pci_need_resume(struct pci_dev *dev)\n{\n\tstruct acpi_device *adev;\n\n\tif (acpi_pci_disabled)\n\t\treturn false;\n\n\t \n\tif (pci_is_bridge(dev) && acpi_target_system_state() != ACPI_STATE_S0)\n\t\treturn true;\n\n\tadev = ACPI_COMPANION(&dev->dev);\n\tif (!adev || !acpi_device_power_manageable(adev))\n\t\treturn false;\n\n\tif (adev->wakeup.flags.valid &&\n\t    device_may_wakeup(&dev->dev) != !!adev->wakeup.prepare_count)\n\t\treturn true;\n\n\tif (acpi_target_system_state() == ACPI_STATE_S0)\n\t\treturn false;\n\n\treturn !!adev->power.flags.dsw_present;\n}\n\nvoid acpi_pci_add_bus(struct pci_bus *bus)\n{\n\tunion acpi_object *obj;\n\tstruct pci_host_bridge *bridge;\n\n\tif (acpi_pci_disabled || !bus->bridge || !ACPI_HANDLE(bus->bridge))\n\t\treturn;\n\n\tacpi_pci_slot_enumerate(bus);\n\tacpiphp_enumerate_slots(bus);\n\n\t \n\tif (!pci_is_root_bus(bus))\n\t\treturn;\n\n\tobj = acpi_evaluate_dsm(ACPI_HANDLE(bus->bridge), &pci_acpi_dsm_guid, 3,\n\t\t\t\tDSM_PCI_POWER_ON_RESET_DELAY, NULL);\n\tif (!obj)\n\t\treturn;\n\n\tif (obj->type == ACPI_TYPE_INTEGER && obj->integer.value == 1) {\n\t\tbridge = pci_find_host_bridge(bus);\n\t\tbridge->ignore_reset_delay = 1;\n\t}\n\tACPI_FREE(obj);\n}\n\nvoid acpi_pci_remove_bus(struct pci_bus *bus)\n{\n\tif (acpi_pci_disabled || !bus->bridge)\n\t\treturn;\n\n\tacpiphp_remove_slots(bus);\n\tacpi_pci_slot_remove(bus);\n}\n\n \n\n\nstatic DECLARE_RWSEM(pci_acpi_companion_lookup_sem);\nstatic struct acpi_device *(*pci_acpi_find_companion_hook)(struct pci_dev *);\n\n \nint pci_acpi_set_companion_lookup_hook(struct acpi_device *(*func)(struct pci_dev *))\n{\n\tint ret;\n\n\tif (!func)\n\t\treturn -EINVAL;\n\n\tdown_write(&pci_acpi_companion_lookup_sem);\n\n\tif (pci_acpi_find_companion_hook) {\n\t\tret = -EBUSY;\n\t} else {\n\t\tpci_acpi_find_companion_hook = func;\n\t\tret = 0;\n\t}\n\n\tup_write(&pci_acpi_companion_lookup_sem);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(pci_acpi_set_companion_lookup_hook);\n\n \nvoid pci_acpi_clear_companion_lookup_hook(void)\n{\n\tdown_write(&pci_acpi_companion_lookup_sem);\n\n\tpci_acpi_find_companion_hook = NULL;\n\n\tup_write(&pci_acpi_companion_lookup_sem);\n}\nEXPORT_SYMBOL_GPL(pci_acpi_clear_companion_lookup_hook);\n\nstatic struct acpi_device *acpi_pci_find_companion(struct device *dev)\n{\n\tstruct pci_dev *pci_dev = to_pci_dev(dev);\n\tstruct acpi_device *adev;\n\tbool check_children;\n\tu64 addr;\n\n\tif (!dev->parent)\n\t\treturn NULL;\n\n\tdown_read(&pci_acpi_companion_lookup_sem);\n\n\tadev = pci_acpi_find_companion_hook ?\n\t\tpci_acpi_find_companion_hook(pci_dev) : NULL;\n\n\tup_read(&pci_acpi_companion_lookup_sem);\n\n\tif (adev)\n\t\treturn adev;\n\n\tcheck_children = pci_is_bridge(pci_dev);\n\t \n\taddr = (PCI_SLOT(pci_dev->devfn) << 16) | PCI_FUNC(pci_dev->devfn);\n\tadev = acpi_find_child_device(ACPI_COMPANION(dev->parent), addr,\n\t\t\t\t      check_children);\n\n\t \n\tif (adev && adev->pnp.type.platform_id && !addr &&\n\t    pci_is_root_bus(pci_dev->bus))\n\t\treturn NULL;\n\n\treturn adev;\n}\n\n \nstatic void pci_acpi_optimize_delay(struct pci_dev *pdev,\n\t\t\t\t    acpi_handle handle)\n{\n\tstruct pci_host_bridge *bridge = pci_find_host_bridge(pdev->bus);\n\tint value;\n\tunion acpi_object *obj, *elements;\n\n\tif (bridge->ignore_reset_delay)\n\t\tpdev->d3cold_delay = 0;\n\n\tobj = acpi_evaluate_dsm(handle, &pci_acpi_dsm_guid, 3,\n\t\t\t\tDSM_PCI_DEVICE_READINESS_DURATIONS, NULL);\n\tif (!obj)\n\t\treturn;\n\n\tif (obj->type == ACPI_TYPE_PACKAGE && obj->package.count == 5) {\n\t\telements = obj->package.elements;\n\t\tif (elements[0].type == ACPI_TYPE_INTEGER) {\n\t\t\tvalue = (int)elements[0].integer.value / 1000;\n\t\t\tif (value < PCI_PM_D3COLD_WAIT)\n\t\t\t\tpdev->d3cold_delay = value;\n\t\t}\n\t\tif (elements[3].type == ACPI_TYPE_INTEGER) {\n\t\t\tvalue = (int)elements[3].integer.value / 1000;\n\t\t\tif (value < PCI_PM_D3HOT_WAIT)\n\t\t\t\tpdev->d3hot_delay = value;\n\t\t}\n\t}\n\tACPI_FREE(obj);\n}\n\nstatic void pci_acpi_set_external_facing(struct pci_dev *dev)\n{\n\tu8 val;\n\n\tif (pci_pcie_type(dev) != PCI_EXP_TYPE_ROOT_PORT)\n\t\treturn;\n\tif (device_property_read_u8(&dev->dev, \"ExternalFacingPort\", &val))\n\t\treturn;\n\n\t \n\tif (val)\n\t\tdev->external_facing = 1;\n}\n\nvoid pci_acpi_setup(struct device *dev, struct acpi_device *adev)\n{\n\tstruct pci_dev *pci_dev = to_pci_dev(dev);\n\n\tpci_acpi_optimize_delay(pci_dev, adev->handle);\n\tpci_acpi_set_external_facing(pci_dev);\n\tpci_acpi_add_edr_notifier(pci_dev);\n\n\tpci_acpi_add_pm_notifier(adev, pci_dev);\n\tif (!adev->wakeup.flags.valid)\n\t\treturn;\n\n\tdevice_set_wakeup_capable(dev, true);\n\t \n\tif (pci_dev->bridge_d3)\n\t\tdevice_wakeup_enable(dev);\n\n\tacpi_pci_wakeup(pci_dev, false);\n\tacpi_device_power_add_dependent(adev, dev);\n\n\tif (pci_is_bridge(pci_dev))\n\t\tacpi_dev_power_up_children_with_adr(adev);\n}\n\nvoid pci_acpi_cleanup(struct device *dev, struct acpi_device *adev)\n{\n\tstruct pci_dev *pci_dev = to_pci_dev(dev);\n\n\tpci_acpi_remove_edr_notifier(pci_dev);\n\tpci_acpi_remove_pm_notifier(adev);\n\tif (adev->wakeup.flags.valid) {\n\t\tacpi_device_power_remove_dependent(adev, dev);\n\t\tif (pci_dev->bridge_d3)\n\t\t\tdevice_wakeup_disable(dev);\n\n\t\tdevice_set_wakeup_capable(dev, false);\n\t}\n}\n\nstatic struct fwnode_handle *(*pci_msi_get_fwnode_cb)(struct device *dev);\n\n \nvoid\npci_msi_register_fwnode_provider(struct fwnode_handle *(*fn)(struct device *))\n{\n\tpci_msi_get_fwnode_cb = fn;\n}\n\n \nstruct irq_domain *pci_host_bridge_acpi_msi_domain(struct pci_bus *bus)\n{\n\tstruct fwnode_handle *fwnode;\n\n\tif (!pci_msi_get_fwnode_cb)\n\t\treturn NULL;\n\n\tfwnode = pci_msi_get_fwnode_cb(&bus->dev);\n\tif (!fwnode)\n\t\treturn NULL;\n\n\treturn irq_find_matching_fwnode(fwnode, DOMAIN_BUS_PCI_MSI);\n}\n\nstatic int __init acpi_pci_init(void)\n{\n\tif (acpi_gbl_FADT.boot_flags & ACPI_FADT_NO_MSI) {\n\t\tpr_info(\"ACPI FADT declares the system doesn't support MSI, so disable it\\n\");\n\t\tpci_no_msi();\n\t}\n\n\tif (acpi_gbl_FADT.boot_flags & ACPI_FADT_NO_ASPM) {\n\t\tpr_info(\"ACPI FADT declares the system doesn't support PCIe ASPM, so disable it\\n\");\n\t\tpcie_no_aspm();\n\t}\n\n\tif (acpi_pci_disabled)\n\t\treturn 0;\n\n\tacpi_pci_slot_init();\n\tacpiphp_init();\n\n\treturn 0;\n}\narch_initcall(acpi_pci_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}