{
  "module_name": "probe.c",
  "hash_id": "ea886f90b2c99c7a39c387f1e2deb4ca57984239be318fabff674bd5d12eabe5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/probe.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/pci.h>\n#include <linux/msi.h>\n#include <linux/of_pci.h>\n#include <linux/pci_hotplug.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/cpumask.h>\n#include <linux/aer.h>\n#include <linux/acpi.h>\n#include <linux/hypervisor.h>\n#include <linux/irqdomain.h>\n#include <linux/pm_runtime.h>\n#include <linux/bitfield.h>\n#include \"pci.h\"\n\n#define CARDBUS_LATENCY_TIMER\t176\t \n#define CARDBUS_RESERVE_BUSNR\t3\n\nstatic struct resource busn_resource = {\n\t.name\t= \"PCI busn\",\n\t.start\t= 0,\n\t.end\t= 255,\n\t.flags\t= IORESOURCE_BUS,\n};\n\n \nLIST_HEAD(pci_root_buses);\nEXPORT_SYMBOL(pci_root_buses);\n\nstatic LIST_HEAD(pci_domain_busn_res_list);\n\nstruct pci_domain_busn_res {\n\tstruct list_head list;\n\tstruct resource res;\n\tint domain_nr;\n};\n\nstatic struct resource *get_pci_domain_busn_res(int domain_nr)\n{\n\tstruct pci_domain_busn_res *r;\n\n\tlist_for_each_entry(r, &pci_domain_busn_res_list, list)\n\t\tif (r->domain_nr == domain_nr)\n\t\t\treturn &r->res;\n\n\tr = kzalloc(sizeof(*r), GFP_KERNEL);\n\tif (!r)\n\t\treturn NULL;\n\n\tr->domain_nr = domain_nr;\n\tr->res.start = 0;\n\tr->res.end = 0xff;\n\tr->res.flags = IORESOURCE_BUS | IORESOURCE_PCI_FIXED;\n\n\tlist_add_tail(&r->list, &pci_domain_busn_res_list);\n\n\treturn &r->res;\n}\n\n \nint no_pci_devices(void)\n{\n\tstruct device *dev;\n\tint no_devices;\n\n\tdev = bus_find_next_device(&pci_bus_type, NULL);\n\tno_devices = (dev == NULL);\n\tput_device(dev);\n\treturn no_devices;\n}\nEXPORT_SYMBOL(no_pci_devices);\n\n \nstatic void release_pcibus_dev(struct device *dev)\n{\n\tstruct pci_bus *pci_bus = to_pci_bus(dev);\n\n\tput_device(pci_bus->bridge);\n\tpci_bus_remove_resources(pci_bus);\n\tpci_release_bus_of_node(pci_bus);\n\tkfree(pci_bus);\n}\n\nstatic struct class pcibus_class = {\n\t.name\t\t= \"pci_bus\",\n\t.dev_release\t= &release_pcibus_dev,\n\t.dev_groups\t= pcibus_groups,\n};\n\nstatic int __init pcibus_class_init(void)\n{\n\treturn class_register(&pcibus_class);\n}\npostcore_initcall(pcibus_class_init);\n\nstatic u64 pci_size(u64 base, u64 maxbase, u64 mask)\n{\n\tu64 size = mask & maxbase;\t \n\tif (!size)\n\t\treturn 0;\n\n\t \n\tsize = size & ~(size-1);\n\n\t \n\tif (base == maxbase && ((base | (size - 1)) & mask) != mask)\n\t\treturn 0;\n\n\treturn size;\n}\n\nstatic inline unsigned long decode_bar(struct pci_dev *dev, u32 bar)\n{\n\tu32 mem_type;\n\tunsigned long flags;\n\n\tif ((bar & PCI_BASE_ADDRESS_SPACE) == PCI_BASE_ADDRESS_SPACE_IO) {\n\t\tflags = bar & ~PCI_BASE_ADDRESS_IO_MASK;\n\t\tflags |= IORESOURCE_IO;\n\t\treturn flags;\n\t}\n\n\tflags = bar & ~PCI_BASE_ADDRESS_MEM_MASK;\n\tflags |= IORESOURCE_MEM;\n\tif (flags & PCI_BASE_ADDRESS_MEM_PREFETCH)\n\t\tflags |= IORESOURCE_PREFETCH;\n\n\tmem_type = bar & PCI_BASE_ADDRESS_MEM_TYPE_MASK;\n\tswitch (mem_type) {\n\tcase PCI_BASE_ADDRESS_MEM_TYPE_32:\n\t\tbreak;\n\tcase PCI_BASE_ADDRESS_MEM_TYPE_1M:\n\t\t \n\t\tbreak;\n\tcase PCI_BASE_ADDRESS_MEM_TYPE_64:\n\t\tflags |= IORESOURCE_MEM_64;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n\treturn flags;\n}\n\n#define PCI_COMMAND_DECODE_ENABLE\t(PCI_COMMAND_MEMORY | PCI_COMMAND_IO)\n\n \nint __pci_read_base(struct pci_dev *dev, enum pci_bar_type type,\n\t\t    struct resource *res, unsigned int pos)\n{\n\tu32 l = 0, sz = 0, mask;\n\tu64 l64, sz64, mask64;\n\tu16 orig_cmd;\n\tstruct pci_bus_region region, inverted_region;\n\n\tmask = type ? PCI_ROM_ADDRESS_MASK : ~0;\n\n\t \n\tif (!dev->mmio_always_on) {\n\t\tpci_read_config_word(dev, PCI_COMMAND, &orig_cmd);\n\t\tif (orig_cmd & PCI_COMMAND_DECODE_ENABLE) {\n\t\t\tpci_write_config_word(dev, PCI_COMMAND,\n\t\t\t\torig_cmd & ~PCI_COMMAND_DECODE_ENABLE);\n\t\t}\n\t}\n\n\tres->name = pci_name(dev);\n\n\tpci_read_config_dword(dev, pos, &l);\n\tpci_write_config_dword(dev, pos, l | mask);\n\tpci_read_config_dword(dev, pos, &sz);\n\tpci_write_config_dword(dev, pos, l);\n\n\t \n\tif (PCI_POSSIBLE_ERROR(sz))\n\t\tsz = 0;\n\n\t \n\tif (PCI_POSSIBLE_ERROR(l))\n\t\tl = 0;\n\n\tif (type == pci_bar_unknown) {\n\t\tres->flags = decode_bar(dev, l);\n\t\tres->flags |= IORESOURCE_SIZEALIGN;\n\t\tif (res->flags & IORESOURCE_IO) {\n\t\t\tl64 = l & PCI_BASE_ADDRESS_IO_MASK;\n\t\t\tsz64 = sz & PCI_BASE_ADDRESS_IO_MASK;\n\t\t\tmask64 = PCI_BASE_ADDRESS_IO_MASK & (u32)IO_SPACE_LIMIT;\n\t\t} else {\n\t\t\tl64 = l & PCI_BASE_ADDRESS_MEM_MASK;\n\t\t\tsz64 = sz & PCI_BASE_ADDRESS_MEM_MASK;\n\t\t\tmask64 = (u32)PCI_BASE_ADDRESS_MEM_MASK;\n\t\t}\n\t} else {\n\t\tif (l & PCI_ROM_ADDRESS_ENABLE)\n\t\t\tres->flags |= IORESOURCE_ROM_ENABLE;\n\t\tl64 = l & PCI_ROM_ADDRESS_MASK;\n\t\tsz64 = sz & PCI_ROM_ADDRESS_MASK;\n\t\tmask64 = PCI_ROM_ADDRESS_MASK;\n\t}\n\n\tif (res->flags & IORESOURCE_MEM_64) {\n\t\tpci_read_config_dword(dev, pos + 4, &l);\n\t\tpci_write_config_dword(dev, pos + 4, ~0);\n\t\tpci_read_config_dword(dev, pos + 4, &sz);\n\t\tpci_write_config_dword(dev, pos + 4, l);\n\n\t\tl64 |= ((u64)l << 32);\n\t\tsz64 |= ((u64)sz << 32);\n\t\tmask64 |= ((u64)~0 << 32);\n\t}\n\n\tif (!dev->mmio_always_on && (orig_cmd & PCI_COMMAND_DECODE_ENABLE))\n\t\tpci_write_config_word(dev, PCI_COMMAND, orig_cmd);\n\n\tif (!sz64)\n\t\tgoto fail;\n\n\tsz64 = pci_size(l64, sz64, mask64);\n\tif (!sz64) {\n\t\tpci_info(dev, FW_BUG \"reg 0x%x: invalid BAR (can't size)\\n\",\n\t\t\t pos);\n\t\tgoto fail;\n\t}\n\n\tif (res->flags & IORESOURCE_MEM_64) {\n\t\tif ((sizeof(pci_bus_addr_t) < 8 || sizeof(resource_size_t) < 8)\n\t\t    && sz64 > 0x100000000ULL) {\n\t\t\tres->flags |= IORESOURCE_UNSET | IORESOURCE_DISABLED;\n\t\t\tres->start = 0;\n\t\t\tres->end = 0;\n\t\t\tpci_err(dev, \"reg 0x%x: can't handle BAR larger than 4GB (size %#010llx)\\n\",\n\t\t\t\tpos, (unsigned long long)sz64);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif ((sizeof(pci_bus_addr_t) < 8) && l) {\n\t\t\t \n\t\t\tres->flags |= IORESOURCE_UNSET;\n\t\t\tres->start = 0;\n\t\t\tres->end = sz64 - 1;\n\t\t\tpci_info(dev, \"reg 0x%x: can't handle BAR above 4GB (bus address %#010llx)\\n\",\n\t\t\t\t pos, (unsigned long long)l64);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tregion.start = l64;\n\tregion.end = l64 + sz64 - 1;\n\n\tpcibios_bus_to_resource(dev->bus, res, &region);\n\tpcibios_resource_to_bus(dev->bus, &inverted_region, res);\n\n\t \n\tif (inverted_region.start != region.start) {\n\t\tres->flags |= IORESOURCE_UNSET;\n\t\tres->start = 0;\n\t\tres->end = region.end - region.start;\n\t\tpci_info(dev, \"reg 0x%x: initial BAR value %#010llx invalid\\n\",\n\t\t\t pos, (unsigned long long)region.start);\n\t}\n\n\tgoto out;\n\n\nfail:\n\tres->flags = 0;\nout:\n\tif (res->flags)\n\t\tpci_info(dev, \"reg 0x%x: %pR\\n\", pos, res);\n\n\treturn (res->flags & IORESOURCE_MEM_64) ? 1 : 0;\n}\n\nstatic void pci_read_bases(struct pci_dev *dev, unsigned int howmany, int rom)\n{\n\tunsigned int pos, reg;\n\n\tif (dev->non_compliant_bars)\n\t\treturn;\n\n\t \n\tif (dev->is_virtfn)\n\t\treturn;\n\n\tfor (pos = 0; pos < howmany; pos++) {\n\t\tstruct resource *res = &dev->resource[pos];\n\t\treg = PCI_BASE_ADDRESS_0 + (pos << 2);\n\t\tpos += __pci_read_base(dev, pci_bar_unknown, res, reg);\n\t}\n\n\tif (rom) {\n\t\tstruct resource *res = &dev->resource[PCI_ROM_RESOURCE];\n\t\tdev->rom_base_reg = rom;\n\t\tres->flags = IORESOURCE_MEM | IORESOURCE_PREFETCH |\n\t\t\t\tIORESOURCE_READONLY | IORESOURCE_SIZEALIGN;\n\t\t__pci_read_base(dev, pci_bar_mem32, res, rom);\n\t}\n}\n\nstatic void pci_read_bridge_windows(struct pci_dev *bridge)\n{\n\tu16 io;\n\tu32 pmem, tmp;\n\n\tpci_read_config_word(bridge, PCI_IO_BASE, &io);\n\tif (!io) {\n\t\tpci_write_config_word(bridge, PCI_IO_BASE, 0xe0f0);\n\t\tpci_read_config_word(bridge, PCI_IO_BASE, &io);\n\t\tpci_write_config_word(bridge, PCI_IO_BASE, 0x0);\n\t}\n\tif (io)\n\t\tbridge->io_window = 1;\n\n\t \n\tif (bridge->vendor == PCI_VENDOR_ID_DEC && bridge->device == 0x0001)\n\t\treturn;\n\n\tpci_read_config_dword(bridge, PCI_PREF_MEMORY_BASE, &pmem);\n\tif (!pmem) {\n\t\tpci_write_config_dword(bridge, PCI_PREF_MEMORY_BASE,\n\t\t\t\t\t       0xffe0fff0);\n\t\tpci_read_config_dword(bridge, PCI_PREF_MEMORY_BASE, &pmem);\n\t\tpci_write_config_dword(bridge, PCI_PREF_MEMORY_BASE, 0x0);\n\t}\n\tif (!pmem)\n\t\treturn;\n\n\tbridge->pref_window = 1;\n\n\tif ((pmem & PCI_PREF_RANGE_TYPE_MASK) == PCI_PREF_RANGE_TYPE_64) {\n\n\t\t \n\t\tpci_read_config_dword(bridge, PCI_PREF_BASE_UPPER32, &pmem);\n\t\tpci_write_config_dword(bridge, PCI_PREF_BASE_UPPER32,\n\t\t\t\t       0xffffffff);\n\t\tpci_read_config_dword(bridge, PCI_PREF_BASE_UPPER32, &tmp);\n\t\tpci_write_config_dword(bridge, PCI_PREF_BASE_UPPER32, pmem);\n\t\tif (tmp)\n\t\t\tbridge->pref_64_window = 1;\n\t}\n}\n\nstatic void pci_read_bridge_io(struct pci_bus *child)\n{\n\tstruct pci_dev *dev = child->self;\n\tu8 io_base_lo, io_limit_lo;\n\tunsigned long io_mask, io_granularity, base, limit;\n\tstruct pci_bus_region region;\n\tstruct resource *res;\n\n\tio_mask = PCI_IO_RANGE_MASK;\n\tio_granularity = 0x1000;\n\tif (dev->io_window_1k) {\n\t\t \n\t\tio_mask = PCI_IO_1K_RANGE_MASK;\n\t\tio_granularity = 0x400;\n\t}\n\n\tres = child->resource[0];\n\tpci_read_config_byte(dev, PCI_IO_BASE, &io_base_lo);\n\tpci_read_config_byte(dev, PCI_IO_LIMIT, &io_limit_lo);\n\tbase = (io_base_lo & io_mask) << 8;\n\tlimit = (io_limit_lo & io_mask) << 8;\n\n\tif ((io_base_lo & PCI_IO_RANGE_TYPE_MASK) == PCI_IO_RANGE_TYPE_32) {\n\t\tu16 io_base_hi, io_limit_hi;\n\n\t\tpci_read_config_word(dev, PCI_IO_BASE_UPPER16, &io_base_hi);\n\t\tpci_read_config_word(dev, PCI_IO_LIMIT_UPPER16, &io_limit_hi);\n\t\tbase |= ((unsigned long) io_base_hi << 16);\n\t\tlimit |= ((unsigned long) io_limit_hi << 16);\n\t}\n\n\tif (base <= limit) {\n\t\tres->flags = (io_base_lo & PCI_IO_RANGE_TYPE_MASK) | IORESOURCE_IO;\n\t\tregion.start = base;\n\t\tregion.end = limit + io_granularity - 1;\n\t\tpcibios_bus_to_resource(dev->bus, res, &region);\n\t\tpci_info(dev, \"  bridge window %pR\\n\", res);\n\t}\n}\n\nstatic void pci_read_bridge_mmio(struct pci_bus *child)\n{\n\tstruct pci_dev *dev = child->self;\n\tu16 mem_base_lo, mem_limit_lo;\n\tunsigned long base, limit;\n\tstruct pci_bus_region region;\n\tstruct resource *res;\n\n\tres = child->resource[1];\n\tpci_read_config_word(dev, PCI_MEMORY_BASE, &mem_base_lo);\n\tpci_read_config_word(dev, PCI_MEMORY_LIMIT, &mem_limit_lo);\n\tbase = ((unsigned long) mem_base_lo & PCI_MEMORY_RANGE_MASK) << 16;\n\tlimit = ((unsigned long) mem_limit_lo & PCI_MEMORY_RANGE_MASK) << 16;\n\tif (base <= limit) {\n\t\tres->flags = (mem_base_lo & PCI_MEMORY_RANGE_TYPE_MASK) | IORESOURCE_MEM;\n\t\tregion.start = base;\n\t\tregion.end = limit + 0xfffff;\n\t\tpcibios_bus_to_resource(dev->bus, res, &region);\n\t\tpci_info(dev, \"  bridge window %pR\\n\", res);\n\t}\n}\n\nstatic void pci_read_bridge_mmio_pref(struct pci_bus *child)\n{\n\tstruct pci_dev *dev = child->self;\n\tu16 mem_base_lo, mem_limit_lo;\n\tu64 base64, limit64;\n\tpci_bus_addr_t base, limit;\n\tstruct pci_bus_region region;\n\tstruct resource *res;\n\n\tres = child->resource[2];\n\tpci_read_config_word(dev, PCI_PREF_MEMORY_BASE, &mem_base_lo);\n\tpci_read_config_word(dev, PCI_PREF_MEMORY_LIMIT, &mem_limit_lo);\n\tbase64 = (mem_base_lo & PCI_PREF_RANGE_MASK) << 16;\n\tlimit64 = (mem_limit_lo & PCI_PREF_RANGE_MASK) << 16;\n\n\tif ((mem_base_lo & PCI_PREF_RANGE_TYPE_MASK) == PCI_PREF_RANGE_TYPE_64) {\n\t\tu32 mem_base_hi, mem_limit_hi;\n\n\t\tpci_read_config_dword(dev, PCI_PREF_BASE_UPPER32, &mem_base_hi);\n\t\tpci_read_config_dword(dev, PCI_PREF_LIMIT_UPPER32, &mem_limit_hi);\n\n\t\t \n\t\tif (mem_base_hi <= mem_limit_hi) {\n\t\t\tbase64 |= (u64) mem_base_hi << 32;\n\t\t\tlimit64 |= (u64) mem_limit_hi << 32;\n\t\t}\n\t}\n\n\tbase = (pci_bus_addr_t) base64;\n\tlimit = (pci_bus_addr_t) limit64;\n\n\tif (base != base64) {\n\t\tpci_err(dev, \"can't handle bridge window above 4GB (bus address %#010llx)\\n\",\n\t\t\t(unsigned long long) base64);\n\t\treturn;\n\t}\n\n\tif (base <= limit) {\n\t\tres->flags = (mem_base_lo & PCI_PREF_RANGE_TYPE_MASK) |\n\t\t\t\t\t IORESOURCE_MEM | IORESOURCE_PREFETCH;\n\t\tif (res->flags & PCI_PREF_RANGE_TYPE_64)\n\t\t\tres->flags |= IORESOURCE_MEM_64;\n\t\tregion.start = base;\n\t\tregion.end = limit + 0xfffff;\n\t\tpcibios_bus_to_resource(dev->bus, res, &region);\n\t\tpci_info(dev, \"  bridge window %pR\\n\", res);\n\t}\n}\n\nvoid pci_read_bridge_bases(struct pci_bus *child)\n{\n\tstruct pci_dev *dev = child->self;\n\tstruct resource *res;\n\tint i;\n\n\tif (pci_is_root_bus(child))\t \n\t\treturn;\n\n\tpci_info(dev, \"PCI bridge to %pR%s\\n\",\n\t\t &child->busn_res,\n\t\t dev->transparent ? \" (subtractive decode)\" : \"\");\n\n\tpci_bus_remove_resources(child);\n\tfor (i = 0; i < PCI_BRIDGE_RESOURCE_NUM; i++)\n\t\tchild->resource[i] = &dev->resource[PCI_BRIDGE_RESOURCES+i];\n\n\tpci_read_bridge_io(child);\n\tpci_read_bridge_mmio(child);\n\tpci_read_bridge_mmio_pref(child);\n\n\tif (dev->transparent) {\n\t\tpci_bus_for_each_resource(child->parent, res) {\n\t\t\tif (res && res->flags) {\n\t\t\t\tpci_bus_add_resource(child, res,\n\t\t\t\t\t\t     PCI_SUBTRACTIVE_DECODE);\n\t\t\t\tpci_info(dev, \"  bridge window %pR (subtractive decode)\\n\",\n\t\t\t\t\t   res);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic struct pci_bus *pci_alloc_bus(struct pci_bus *parent)\n{\n\tstruct pci_bus *b;\n\n\tb = kzalloc(sizeof(*b), GFP_KERNEL);\n\tif (!b)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&b->node);\n\tINIT_LIST_HEAD(&b->children);\n\tINIT_LIST_HEAD(&b->devices);\n\tINIT_LIST_HEAD(&b->slots);\n\tINIT_LIST_HEAD(&b->resources);\n\tb->max_bus_speed = PCI_SPEED_UNKNOWN;\n\tb->cur_bus_speed = PCI_SPEED_UNKNOWN;\n#ifdef CONFIG_PCI_DOMAINS_GENERIC\n\tif (parent)\n\t\tb->domain_nr = parent->domain_nr;\n#endif\n\treturn b;\n}\n\nstatic void pci_release_host_bridge_dev(struct device *dev)\n{\n\tstruct pci_host_bridge *bridge = to_pci_host_bridge(dev);\n\n\tif (bridge->release_fn)\n\t\tbridge->release_fn(bridge);\n\n\tpci_free_resource_list(&bridge->windows);\n\tpci_free_resource_list(&bridge->dma_ranges);\n\tkfree(bridge);\n}\n\nstatic void pci_init_host_bridge(struct pci_host_bridge *bridge)\n{\n\tINIT_LIST_HEAD(&bridge->windows);\n\tINIT_LIST_HEAD(&bridge->dma_ranges);\n\n\t \n\tbridge->native_aer = 1;\n\tbridge->native_pcie_hotplug = 1;\n\tbridge->native_shpc_hotplug = 1;\n\tbridge->native_pme = 1;\n\tbridge->native_ltr = 1;\n\tbridge->native_dpc = 1;\n\tbridge->domain_nr = PCI_DOMAIN_NR_NOT_SET;\n\tbridge->native_cxl_error = 1;\n\n\tdevice_initialize(&bridge->dev);\n}\n\nstruct pci_host_bridge *pci_alloc_host_bridge(size_t priv)\n{\n\tstruct pci_host_bridge *bridge;\n\n\tbridge = kzalloc(sizeof(*bridge) + priv, GFP_KERNEL);\n\tif (!bridge)\n\t\treturn NULL;\n\n\tpci_init_host_bridge(bridge);\n\tbridge->dev.release = pci_release_host_bridge_dev;\n\n\treturn bridge;\n}\nEXPORT_SYMBOL(pci_alloc_host_bridge);\n\nstatic void devm_pci_alloc_host_bridge_release(void *data)\n{\n\tpci_free_host_bridge(data);\n}\n\nstruct pci_host_bridge *devm_pci_alloc_host_bridge(struct device *dev,\n\t\t\t\t\t\t   size_t priv)\n{\n\tint ret;\n\tstruct pci_host_bridge *bridge;\n\n\tbridge = pci_alloc_host_bridge(priv);\n\tif (!bridge)\n\t\treturn NULL;\n\n\tbridge->dev.parent = dev;\n\n\tret = devm_add_action_or_reset(dev, devm_pci_alloc_host_bridge_release,\n\t\t\t\t       bridge);\n\tif (ret)\n\t\treturn NULL;\n\n\tret = devm_of_pci_bridge_init(dev, bridge);\n\tif (ret)\n\t\treturn NULL;\n\n\treturn bridge;\n}\nEXPORT_SYMBOL(devm_pci_alloc_host_bridge);\n\nvoid pci_free_host_bridge(struct pci_host_bridge *bridge)\n{\n\tput_device(&bridge->dev);\n}\nEXPORT_SYMBOL(pci_free_host_bridge);\n\n \nstatic const unsigned char pcix_bus_speed[] = {\n\tPCI_SPEED_UNKNOWN,\t\t \n\tPCI_SPEED_66MHz_PCIX,\t\t \n\tPCI_SPEED_100MHz_PCIX,\t\t \n\tPCI_SPEED_133MHz_PCIX,\t\t \n\tPCI_SPEED_UNKNOWN,\t\t \n\tPCI_SPEED_66MHz_PCIX_ECC,\t \n\tPCI_SPEED_100MHz_PCIX_ECC,\t \n\tPCI_SPEED_133MHz_PCIX_ECC,\t \n\tPCI_SPEED_UNKNOWN,\t\t \n\tPCI_SPEED_66MHz_PCIX_266,\t \n\tPCI_SPEED_100MHz_PCIX_266,\t \n\tPCI_SPEED_133MHz_PCIX_266,\t \n\tPCI_SPEED_UNKNOWN,\t\t \n\tPCI_SPEED_66MHz_PCIX_533,\t \n\tPCI_SPEED_100MHz_PCIX_533,\t \n\tPCI_SPEED_133MHz_PCIX_533\t \n};\n\n \nconst unsigned char pcie_link_speed[] = {\n\tPCI_SPEED_UNKNOWN,\t\t \n\tPCIE_SPEED_2_5GT,\t\t \n\tPCIE_SPEED_5_0GT,\t\t \n\tPCIE_SPEED_8_0GT,\t\t \n\tPCIE_SPEED_16_0GT,\t\t \n\tPCIE_SPEED_32_0GT,\t\t \n\tPCIE_SPEED_64_0GT,\t\t \n\tPCI_SPEED_UNKNOWN,\t\t \n\tPCI_SPEED_UNKNOWN,\t\t \n\tPCI_SPEED_UNKNOWN,\t\t \n\tPCI_SPEED_UNKNOWN,\t\t \n\tPCI_SPEED_UNKNOWN,\t\t \n\tPCI_SPEED_UNKNOWN,\t\t \n\tPCI_SPEED_UNKNOWN,\t\t \n\tPCI_SPEED_UNKNOWN,\t\t \n\tPCI_SPEED_UNKNOWN\t\t \n};\nEXPORT_SYMBOL_GPL(pcie_link_speed);\n\nconst char *pci_speed_string(enum pci_bus_speed speed)\n{\n\t \n\tstatic const char *speed_strings[] = {\n\t    \"33 MHz PCI\",\t\t \n\t    \"66 MHz PCI\",\t\t \n\t    \"66 MHz PCI-X\",\t\t \n\t    \"100 MHz PCI-X\",\t\t \n\t    \"133 MHz PCI-X\",\t\t \n\t    NULL,\t\t\t \n\t    NULL,\t\t\t \n\t    NULL,\t\t\t \n\t    NULL,\t\t\t \n\t    \"66 MHz PCI-X 266\",\t\t \n\t    \"100 MHz PCI-X 266\",\t \n\t    \"133 MHz PCI-X 266\",\t \n\t    \"Unknown AGP\",\t\t \n\t    \"1x AGP\",\t\t\t \n\t    \"2x AGP\",\t\t\t \n\t    \"4x AGP\",\t\t\t \n\t    \"8x AGP\",\t\t\t \n\t    \"66 MHz PCI-X 533\",\t\t \n\t    \"100 MHz PCI-X 533\",\t \n\t    \"133 MHz PCI-X 533\",\t \n\t    \"2.5 GT/s PCIe\",\t\t \n\t    \"5.0 GT/s PCIe\",\t\t \n\t    \"8.0 GT/s PCIe\",\t\t \n\t    \"16.0 GT/s PCIe\",\t\t \n\t    \"32.0 GT/s PCIe\",\t\t \n\t    \"64.0 GT/s PCIe\",\t\t \n\t};\n\n\tif (speed < ARRAY_SIZE(speed_strings))\n\t\treturn speed_strings[speed];\n\treturn \"Unknown\";\n}\nEXPORT_SYMBOL_GPL(pci_speed_string);\n\nvoid pcie_update_link_speed(struct pci_bus *bus, u16 linksta)\n{\n\tbus->cur_bus_speed = pcie_link_speed[linksta & PCI_EXP_LNKSTA_CLS];\n}\nEXPORT_SYMBOL_GPL(pcie_update_link_speed);\n\nstatic unsigned char agp_speeds[] = {\n\tAGP_UNKNOWN,\n\tAGP_1X,\n\tAGP_2X,\n\tAGP_4X,\n\tAGP_8X\n};\n\nstatic enum pci_bus_speed agp_speed(int agp3, int agpstat)\n{\n\tint index = 0;\n\n\tif (agpstat & 4)\n\t\tindex = 3;\n\telse if (agpstat & 2)\n\t\tindex = 2;\n\telse if (agpstat & 1)\n\t\tindex = 1;\n\telse\n\t\tgoto out;\n\n\tif (agp3) {\n\t\tindex += 2;\n\t\tif (index == 5)\n\t\t\tindex = 0;\n\t}\n\n out:\n\treturn agp_speeds[index];\n}\n\nstatic void pci_set_bus_speed(struct pci_bus *bus)\n{\n\tstruct pci_dev *bridge = bus->self;\n\tint pos;\n\n\tpos = pci_find_capability(bridge, PCI_CAP_ID_AGP);\n\tif (!pos)\n\t\tpos = pci_find_capability(bridge, PCI_CAP_ID_AGP3);\n\tif (pos) {\n\t\tu32 agpstat, agpcmd;\n\n\t\tpci_read_config_dword(bridge, pos + PCI_AGP_STATUS, &agpstat);\n\t\tbus->max_bus_speed = agp_speed(agpstat & 8, agpstat & 7);\n\n\t\tpci_read_config_dword(bridge, pos + PCI_AGP_COMMAND, &agpcmd);\n\t\tbus->cur_bus_speed = agp_speed(agpstat & 8, agpcmd & 7);\n\t}\n\n\tpos = pci_find_capability(bridge, PCI_CAP_ID_PCIX);\n\tif (pos) {\n\t\tu16 status;\n\t\tenum pci_bus_speed max;\n\n\t\tpci_read_config_word(bridge, pos + PCI_X_BRIDGE_SSTATUS,\n\t\t\t\t     &status);\n\n\t\tif (status & PCI_X_SSTATUS_533MHZ) {\n\t\t\tmax = PCI_SPEED_133MHz_PCIX_533;\n\t\t} else if (status & PCI_X_SSTATUS_266MHZ) {\n\t\t\tmax = PCI_SPEED_133MHz_PCIX_266;\n\t\t} else if (status & PCI_X_SSTATUS_133MHZ) {\n\t\t\tif ((status & PCI_X_SSTATUS_VERS) == PCI_X_SSTATUS_V2)\n\t\t\t\tmax = PCI_SPEED_133MHz_PCIX_ECC;\n\t\t\telse\n\t\t\t\tmax = PCI_SPEED_133MHz_PCIX;\n\t\t} else {\n\t\t\tmax = PCI_SPEED_66MHz_PCIX;\n\t\t}\n\n\t\tbus->max_bus_speed = max;\n\t\tbus->cur_bus_speed = pcix_bus_speed[\n\t\t\t(status & PCI_X_SSTATUS_FREQ) >> 6];\n\n\t\treturn;\n\t}\n\n\tif (pci_is_pcie(bridge)) {\n\t\tu32 linkcap;\n\t\tu16 linksta;\n\n\t\tpcie_capability_read_dword(bridge, PCI_EXP_LNKCAP, &linkcap);\n\t\tbus->max_bus_speed = pcie_link_speed[linkcap & PCI_EXP_LNKCAP_SLS];\n\n\t\tpcie_capability_read_word(bridge, PCI_EXP_LNKSTA, &linksta);\n\t\tpcie_update_link_speed(bus, linksta);\n\t}\n}\n\nstatic struct irq_domain *pci_host_bridge_msi_domain(struct pci_bus *bus)\n{\n\tstruct irq_domain *d;\n\n\t \n\td = dev_get_msi_domain(bus->bridge);\n\n\t \n\tif (!d)\n\t\td = pci_host_bridge_of_msi_domain(bus);\n\tif (!d)\n\t\td = pci_host_bridge_acpi_msi_domain(bus);\n\n\t \n\tif (!d) {\n\t\tstruct fwnode_handle *fwnode = pci_root_bus_fwnode(bus);\n\n\t\tif (fwnode)\n\t\t\td = irq_find_matching_fwnode(fwnode,\n\t\t\t\t\t\t     DOMAIN_BUS_PCI_MSI);\n\t}\n\n\treturn d;\n}\n\nstatic void pci_set_bus_msi_domain(struct pci_bus *bus)\n{\n\tstruct irq_domain *d;\n\tstruct pci_bus *b;\n\n\t \n\tfor (b = bus, d = NULL; !d && !pci_is_root_bus(b); b = b->parent) {\n\t\tif (b->self)\n\t\t\td = dev_get_msi_domain(&b->self->dev);\n\t}\n\n\tif (!d)\n\t\td = pci_host_bridge_msi_domain(b);\n\n\tdev_set_msi_domain(&bus->dev, d);\n}\n\nstatic int pci_register_host_bridge(struct pci_host_bridge *bridge)\n{\n\tstruct device *parent = bridge->dev.parent;\n\tstruct resource_entry *window, *next, *n;\n\tstruct pci_bus *bus, *b;\n\tresource_size_t offset, next_offset;\n\tLIST_HEAD(resources);\n\tstruct resource *res, *next_res;\n\tchar addr[64], *fmt;\n\tconst char *name;\n\tint err;\n\n\tbus = pci_alloc_bus(NULL);\n\tif (!bus)\n\t\treturn -ENOMEM;\n\n\tbridge->bus = bus;\n\n\tbus->sysdata = bridge->sysdata;\n\tbus->ops = bridge->ops;\n\tbus->number = bus->busn_res.start = bridge->busnr;\n#ifdef CONFIG_PCI_DOMAINS_GENERIC\n\tif (bridge->domain_nr == PCI_DOMAIN_NR_NOT_SET)\n\t\tbus->domain_nr = pci_bus_find_domain_nr(bus, parent);\n\telse\n\t\tbus->domain_nr = bridge->domain_nr;\n\tif (bus->domain_nr < 0) {\n\t\terr = bus->domain_nr;\n\t\tgoto free;\n\t}\n#endif\n\n\tb = pci_find_bus(pci_domain_nr(bus), bridge->busnr);\n\tif (b) {\n\t\t \n\t\tdev_dbg(&b->dev, \"bus already known\\n\");\n\t\terr = -EEXIST;\n\t\tgoto free;\n\t}\n\n\tdev_set_name(&bridge->dev, \"pci%04x:%02x\", pci_domain_nr(bus),\n\t\t     bridge->busnr);\n\n\terr = pcibios_root_bridge_prepare(bridge);\n\tif (err)\n\t\tgoto free;\n\n\t \n\tlist_splice_init(&bridge->windows, &resources);\n\terr = device_add(&bridge->dev);\n\tif (err) {\n\t\tput_device(&bridge->dev);\n\t\tgoto free;\n\t}\n\tbus->bridge = get_device(&bridge->dev);\n\tdevice_enable_async_suspend(bus->bridge);\n\tpci_set_bus_of_node(bus);\n\tpci_set_bus_msi_domain(bus);\n\tif (bridge->msi_domain && !dev_get_msi_domain(&bus->dev) &&\n\t    !pci_host_of_has_msi_map(parent))\n\t\tbus->bus_flags |= PCI_BUS_FLAGS_NO_MSI;\n\n\tif (!parent)\n\t\tset_dev_node(bus->bridge, pcibus_to_node(bus));\n\n\tbus->dev.class = &pcibus_class;\n\tbus->dev.parent = bus->bridge;\n\n\tdev_set_name(&bus->dev, \"%04x:%02x\", pci_domain_nr(bus), bus->number);\n\tname = dev_name(&bus->dev);\n\n\terr = device_register(&bus->dev);\n\tif (err)\n\t\tgoto unregister;\n\n\tpcibios_add_bus(bus);\n\n\tif (bus->ops->add_bus) {\n\t\terr = bus->ops->add_bus(bus);\n\t\tif (WARN_ON(err < 0))\n\t\t\tdev_err(&bus->dev, \"failed to add bus: %d\\n\", err);\n\t}\n\n\t \n\tpci_create_legacy_files(bus);\n\n\tif (parent)\n\t\tdev_info(parent, \"PCI host bridge to bus %s\\n\", name);\n\telse\n\t\tpr_info(\"PCI host bridge to bus %s\\n\", name);\n\n\tif (nr_node_ids > 1 && pcibus_to_node(bus) == NUMA_NO_NODE)\n\t\tdev_warn(&bus->dev, \"Unknown NUMA node; performance will be reduced\\n\");\n\n\t \n\tresource_list_for_each_entry_safe(window, n, &resources) {\n\t\tif (list_is_last(&window->node, &resources))\n\t\t\tbreak;\n\n\t\tnext = list_next_entry(window, node);\n\t\toffset = window->offset;\n\t\tres = window->res;\n\t\tnext_offset = next->offset;\n\t\tnext_res = next->res;\n\n\t\tif (res->flags != next_res->flags || offset != next_offset)\n\t\t\tcontinue;\n\n\t\tif (res->end + 1 == next_res->start) {\n\t\t\tnext_res->start = res->start;\n\t\t\tres->flags = res->start = res->end = 0;\n\t\t}\n\t}\n\n\t \n\tresource_list_for_each_entry_safe(window, n, &resources) {\n\t\toffset = window->offset;\n\t\tres = window->res;\n\t\tif (!res->flags && !res->start && !res->end) {\n\t\t\trelease_resource(res);\n\t\t\tresource_list_destroy_entry(window);\n\t\t\tcontinue;\n\t\t}\n\n\t\tlist_move_tail(&window->node, &bridge->windows);\n\n\t\tif (res->flags & IORESOURCE_BUS)\n\t\t\tpci_bus_insert_busn_res(bus, bus->number, res->end);\n\t\telse\n\t\t\tpci_bus_add_resource(bus, res, 0);\n\n\t\tif (offset) {\n\t\t\tif (resource_type(res) == IORESOURCE_IO)\n\t\t\t\tfmt = \" (bus address [%#06llx-%#06llx])\";\n\t\t\telse\n\t\t\t\tfmt = \" (bus address [%#010llx-%#010llx])\";\n\n\t\t\tsnprintf(addr, sizeof(addr), fmt,\n\t\t\t\t (unsigned long long)(res->start - offset),\n\t\t\t\t (unsigned long long)(res->end - offset));\n\t\t} else\n\t\t\taddr[0] = '\\0';\n\n\t\tdev_info(&bus->dev, \"root bus resource %pR%s\\n\", res, addr);\n\t}\n\n\tdown_write(&pci_bus_sem);\n\tlist_add_tail(&bus->node, &pci_root_buses);\n\tup_write(&pci_bus_sem);\n\n\treturn 0;\n\nunregister:\n\tput_device(&bridge->dev);\n\tdevice_del(&bridge->dev);\n\nfree:\n#ifdef CONFIG_PCI_DOMAINS_GENERIC\n\tpci_bus_release_domain_nr(bus, parent);\n#endif\n\tkfree(bus);\n\treturn err;\n}\n\nstatic bool pci_bridge_child_ext_cfg_accessible(struct pci_dev *bridge)\n{\n\tint pos;\n\tu32 status;\n\n\t \n\tif (bridge->bus->bus_flags & PCI_BUS_FLAGS_NO_EXTCFG)\n\t\treturn false;\n\n\t \n\tif (pci_is_pcie(bridge) &&\n\t    (pci_pcie_type(bridge) == PCI_EXP_TYPE_ROOT_PORT ||\n\t     pci_pcie_type(bridge) == PCI_EXP_TYPE_UPSTREAM ||\n\t     pci_pcie_type(bridge) == PCI_EXP_TYPE_DOWNSTREAM))\n\t\treturn true;\n\n\t \n\tpos = pci_find_capability(bridge, PCI_CAP_ID_PCIX);\n\tif (!pos)\n\t\treturn false;\n\n\tpci_read_config_dword(bridge, pos + PCI_X_STATUS, &status);\n\treturn status & (PCI_X_STATUS_266MHZ | PCI_X_STATUS_533MHZ);\n}\n\nstatic struct pci_bus *pci_alloc_child_bus(struct pci_bus *parent,\n\t\t\t\t\t   struct pci_dev *bridge, int busnr)\n{\n\tstruct pci_bus *child;\n\tstruct pci_host_bridge *host;\n\tint i;\n\tint ret;\n\n\t \n\tchild = pci_alloc_bus(parent);\n\tif (!child)\n\t\treturn NULL;\n\n\tchild->parent = parent;\n\tchild->sysdata = parent->sysdata;\n\tchild->bus_flags = parent->bus_flags;\n\n\thost = pci_find_host_bridge(parent);\n\tif (host->child_ops)\n\t\tchild->ops = host->child_ops;\n\telse\n\t\tchild->ops = parent->ops;\n\n\t \n\tchild->dev.class = &pcibus_class;\n\tdev_set_name(&child->dev, \"%04x:%02x\", pci_domain_nr(child), busnr);\n\n\t \n\tchild->number = child->busn_res.start = busnr;\n\tchild->primary = parent->busn_res.start;\n\tchild->busn_res.end = 0xff;\n\n\tif (!bridge) {\n\t\tchild->dev.parent = parent->bridge;\n\t\tgoto add_dev;\n\t}\n\n\tchild->self = bridge;\n\tchild->bridge = get_device(&bridge->dev);\n\tchild->dev.parent = child->bridge;\n\tpci_set_bus_of_node(child);\n\tpci_set_bus_speed(child);\n\n\t \n\tif (!pci_bridge_child_ext_cfg_accessible(bridge)) {\n\t\tchild->bus_flags |= PCI_BUS_FLAGS_NO_EXTCFG;\n\t\tpci_info(child, \"extended config space not accessible\\n\");\n\t}\n\n\t \n\tfor (i = 0; i < PCI_BRIDGE_RESOURCE_NUM; i++) {\n\t\tchild->resource[i] = &bridge->resource[PCI_BRIDGE_RESOURCES+i];\n\t\tchild->resource[i]->name = child->name;\n\t}\n\tbridge->subordinate = child;\n\nadd_dev:\n\tpci_set_bus_msi_domain(child);\n\tret = device_register(&child->dev);\n\tWARN_ON(ret < 0);\n\n\tpcibios_add_bus(child);\n\n\tif (child->ops->add_bus) {\n\t\tret = child->ops->add_bus(child);\n\t\tif (WARN_ON(ret < 0))\n\t\t\tdev_err(&child->dev, \"failed to add bus: %d\\n\", ret);\n\t}\n\n\t \n\tpci_create_legacy_files(child);\n\n\treturn child;\n}\n\nstruct pci_bus *pci_add_new_bus(struct pci_bus *parent, struct pci_dev *dev,\n\t\t\t\tint busnr)\n{\n\tstruct pci_bus *child;\n\n\tchild = pci_alloc_child_bus(parent, dev, busnr);\n\tif (child) {\n\t\tdown_write(&pci_bus_sem);\n\t\tlist_add_tail(&child->node, &parent->children);\n\t\tup_write(&pci_bus_sem);\n\t}\n\treturn child;\n}\nEXPORT_SYMBOL(pci_add_new_bus);\n\nstatic void pci_enable_crs(struct pci_dev *pdev)\n{\n\tu16 root_cap = 0;\n\n\t \n\tpcie_capability_read_word(pdev, PCI_EXP_RTCAP, &root_cap);\n\tif (root_cap & PCI_EXP_RTCAP_CRSVIS)\n\t\tpcie_capability_set_word(pdev, PCI_EXP_RTCTL,\n\t\t\t\t\t PCI_EXP_RTCTL_CRSSVE);\n}\n\nstatic unsigned int pci_scan_child_bus_extend(struct pci_bus *bus,\n\t\t\t\t\t      unsigned int available_buses);\n \nstatic bool pci_ea_fixed_busnrs(struct pci_dev *dev, u8 *sec, u8 *sub)\n{\n\tint ea, offset;\n\tu32 dw;\n\tu8 ea_sec, ea_sub;\n\n\tif (dev->hdr_type != PCI_HEADER_TYPE_BRIDGE)\n\t\treturn false;\n\n\t \n\tea = pci_find_capability(dev, PCI_CAP_ID_EA);\n\tif (!ea)\n\t\treturn false;\n\n\toffset = ea + PCI_EA_FIRST_ENT;\n\tpci_read_config_dword(dev, offset, &dw);\n\tea_sec =  dw & PCI_EA_SEC_BUS_MASK;\n\tea_sub = (dw & PCI_EA_SUB_BUS_MASK) >> PCI_EA_SUB_BUS_SHIFT;\n\tif (ea_sec  == 0 || ea_sub < ea_sec)\n\t\treturn false;\n\n\t*sec = ea_sec;\n\t*sub = ea_sub;\n\treturn true;\n}\n\n \nstatic int pci_scan_bridge_extend(struct pci_bus *bus, struct pci_dev *dev,\n\t\t\t\t  int max, unsigned int available_buses,\n\t\t\t\t  int pass)\n{\n\tstruct pci_bus *child;\n\tint is_cardbus = (dev->hdr_type == PCI_HEADER_TYPE_CARDBUS);\n\tu32 buses, i, j = 0;\n\tu16 bctl;\n\tu8 primary, secondary, subordinate;\n\tint broken = 0;\n\tbool fixed_buses;\n\tu8 fixed_sec, fixed_sub;\n\tint next_busnr;\n\n\t \n\tpm_runtime_get_sync(&dev->dev);\n\n\tpci_read_config_dword(dev, PCI_PRIMARY_BUS, &buses);\n\tprimary = buses & 0xFF;\n\tsecondary = (buses >> 8) & 0xFF;\n\tsubordinate = (buses >> 16) & 0xFF;\n\n\tpci_dbg(dev, \"scanning [bus %02x-%02x] behind bridge, pass %d\\n\",\n\t\tsecondary, subordinate, pass);\n\n\tif (!primary && (primary != bus->number) && secondary && subordinate) {\n\t\tpci_warn(dev, \"Primary bus is hard wired to 0\\n\");\n\t\tprimary = bus->number;\n\t}\n\n\t \n\tif (!pass &&\n\t    (primary != bus->number || secondary <= bus->number ||\n\t     secondary > subordinate)) {\n\t\tpci_info(dev, \"bridge configuration invalid ([bus %02x-%02x]), reconfiguring\\n\",\n\t\t\t secondary, subordinate);\n\t\tbroken = 1;\n\t}\n\n\t \n\tpci_read_config_word(dev, PCI_BRIDGE_CONTROL, &bctl);\n\tpci_write_config_word(dev, PCI_BRIDGE_CONTROL,\n\t\t\t      bctl & ~PCI_BRIDGE_CTL_MASTER_ABORT);\n\n\tpci_enable_crs(dev);\n\n\tif ((secondary || subordinate) && !pcibios_assign_all_busses() &&\n\t    !is_cardbus && !broken) {\n\t\tunsigned int cmax, buses;\n\n\t\t \n\t\tif (pass)\n\t\t\tgoto out;\n\n\t\t \n\t\tchild = pci_find_bus(pci_domain_nr(bus), secondary);\n\t\tif (!child) {\n\t\t\tchild = pci_add_new_bus(bus, dev, secondary);\n\t\t\tif (!child)\n\t\t\t\tgoto out;\n\t\t\tchild->primary = primary;\n\t\t\tpci_bus_insert_busn_res(child, secondary, subordinate);\n\t\t\tchild->bridge_ctl = bctl;\n\t\t}\n\n\t\tbuses = subordinate - secondary;\n\t\tcmax = pci_scan_child_bus_extend(child, buses);\n\t\tif (cmax > subordinate)\n\t\t\tpci_warn(dev, \"bridge has subordinate %02x but max busn %02x\\n\",\n\t\t\t\t subordinate, cmax);\n\n\t\t \n\t\tif (subordinate > max)\n\t\t\tmax = subordinate;\n\t} else {\n\n\t\t \n\t\tif (!pass) {\n\t\t\tif (pcibios_assign_all_busses() || broken || is_cardbus)\n\n\t\t\t\t \n\t\t\t\tpci_write_config_dword(dev, PCI_PRIMARY_BUS,\n\t\t\t\t\t\t       buses & ~0xffffff);\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tpci_write_config_word(dev, PCI_STATUS, 0xffff);\n\n\t\t \n\t\tfixed_buses = pci_ea_fixed_busnrs(dev, &fixed_sec, &fixed_sub);\n\t\tif (fixed_buses)\n\t\t\tnext_busnr = fixed_sec;\n\t\telse\n\t\t\tnext_busnr = max + 1;\n\n\t\t \n\t\tchild = pci_find_bus(pci_domain_nr(bus), next_busnr);\n\t\tif (!child) {\n\t\t\tchild = pci_add_new_bus(bus, dev, next_busnr);\n\t\t\tif (!child)\n\t\t\t\tgoto out;\n\t\t\tpci_bus_insert_busn_res(child, next_busnr,\n\t\t\t\t\t\tbus->busn_res.end);\n\t\t}\n\t\tmax++;\n\t\tif (available_buses)\n\t\t\tavailable_buses--;\n\n\t\tbuses = (buses & 0xff000000)\n\t\t      | ((unsigned int)(child->primary)     <<  0)\n\t\t      | ((unsigned int)(child->busn_res.start)   <<  8)\n\t\t      | ((unsigned int)(child->busn_res.end) << 16);\n\n\t\t \n\t\tif (is_cardbus) {\n\t\t\tbuses &= ~0xff000000;\n\t\t\tbuses |= CARDBUS_LATENCY_TIMER << 24;\n\t\t}\n\n\t\t \n\t\tpci_write_config_dword(dev, PCI_PRIMARY_BUS, buses);\n\n\t\tif (!is_cardbus) {\n\t\t\tchild->bridge_ctl = bctl;\n\t\t\tmax = pci_scan_child_bus_extend(child, available_buses);\n\t\t} else {\n\n\t\t\t \n\t\t\tfor (i = 0; i < CARDBUS_RESERVE_BUSNR; i++) {\n\t\t\t\tstruct pci_bus *parent = bus;\n\t\t\t\tif (pci_find_bus(pci_domain_nr(bus),\n\t\t\t\t\t\t\tmax+i+1))\n\t\t\t\t\tbreak;\n\t\t\t\twhile (parent->parent) {\n\t\t\t\t\tif ((!pcibios_assign_all_busses()) &&\n\t\t\t\t\t    (parent->busn_res.end > max) &&\n\t\t\t\t\t    (parent->busn_res.end <= max+i)) {\n\t\t\t\t\t\tj = 1;\n\t\t\t\t\t}\n\t\t\t\t\tparent = parent->parent;\n\t\t\t\t}\n\t\t\t\tif (j) {\n\n\t\t\t\t\t \n\t\t\t\t\ti /= 2;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmax += i;\n\t\t}\n\n\t\t \n\t\tif (fixed_buses)\n\t\t\tmax = fixed_sub;\n\t\tpci_bus_update_busn_res_end(child, max);\n\t\tpci_write_config_byte(dev, PCI_SUBORDINATE_BUS, max);\n\t}\n\n\tsprintf(child->name,\n\t\t(is_cardbus ? \"PCI CardBus %04x:%02x\" : \"PCI Bus %04x:%02x\"),\n\t\tpci_domain_nr(bus), child->number);\n\n\t \n\twhile (bus->parent) {\n\t\tif ((child->busn_res.end > bus->busn_res.end) ||\n\t\t    (child->number > bus->busn_res.end) ||\n\t\t    (child->number < bus->number) ||\n\t\t    (child->busn_res.end < bus->number)) {\n\t\t\tdev_info(&dev->dev, \"devices behind bridge are unusable because %pR cannot be assigned for them\\n\",\n\t\t\t\t &child->busn_res);\n\t\t\tbreak;\n\t\t}\n\t\tbus = bus->parent;\n\t}\n\nout:\n\tpci_write_config_word(dev, PCI_BRIDGE_CONTROL, bctl);\n\n\tpm_runtime_put(&dev->dev);\n\n\treturn max;\n}\n\n \nint pci_scan_bridge(struct pci_bus *bus, struct pci_dev *dev, int max, int pass)\n{\n\treturn pci_scan_bridge_extend(bus, dev, max, 0, pass);\n}\nEXPORT_SYMBOL(pci_scan_bridge);\n\n \nstatic void pci_read_irq(struct pci_dev *dev)\n{\n\tunsigned char irq;\n\n\t \n\tif (dev->is_virtfn) {\n\t\tdev->pin = 0;\n\t\tdev->irq = 0;\n\t\treturn;\n\t}\n\n\tpci_read_config_byte(dev, PCI_INTERRUPT_PIN, &irq);\n\tdev->pin = irq;\n\tif (irq)\n\t\tpci_read_config_byte(dev, PCI_INTERRUPT_LINE, &irq);\n\tdev->irq = irq;\n}\n\nvoid set_pcie_port_type(struct pci_dev *pdev)\n{\n\tint pos;\n\tu16 reg16;\n\tu32 reg32;\n\tint type;\n\tstruct pci_dev *parent;\n\n\tpos = pci_find_capability(pdev, PCI_CAP_ID_EXP);\n\tif (!pos)\n\t\treturn;\n\n\tpdev->pcie_cap = pos;\n\tpci_read_config_word(pdev, pos + PCI_EXP_FLAGS, &reg16);\n\tpdev->pcie_flags_reg = reg16;\n\tpci_read_config_dword(pdev, pos + PCI_EXP_DEVCAP, &pdev->devcap);\n\tpdev->pcie_mpss = FIELD_GET(PCI_EXP_DEVCAP_PAYLOAD, pdev->devcap);\n\n\tpcie_capability_read_dword(pdev, PCI_EXP_LNKCAP, &reg32);\n\tif (reg32 & PCI_EXP_LNKCAP_DLLLARC)\n\t\tpdev->link_active_reporting = 1;\n\n\tparent = pci_upstream_bridge(pdev);\n\tif (!parent)\n\t\treturn;\n\n\t \n\ttype = pci_pcie_type(pdev);\n\tif (type == PCI_EXP_TYPE_DOWNSTREAM) {\n\t\t \n\t\tif (pcie_downstream_port(parent)) {\n\t\t\tpci_info(pdev, \"claims to be downstream port but is acting as upstream port, correcting type\\n\");\n\t\t\tpdev->pcie_flags_reg &= ~PCI_EXP_FLAGS_TYPE;\n\t\t\tpdev->pcie_flags_reg |= PCI_EXP_TYPE_UPSTREAM;\n\t\t}\n\t} else if (type == PCI_EXP_TYPE_UPSTREAM) {\n\t\t \n\t\tif (pci_pcie_type(parent) == PCI_EXP_TYPE_UPSTREAM) {\n\t\t\tpci_info(pdev, \"claims to be upstream port but is acting as downstream port, correcting type\\n\");\n\t\t\tpdev->pcie_flags_reg &= ~PCI_EXP_FLAGS_TYPE;\n\t\t\tpdev->pcie_flags_reg |= PCI_EXP_TYPE_DOWNSTREAM;\n\t\t}\n\t}\n}\n\nvoid set_pcie_hotplug_bridge(struct pci_dev *pdev)\n{\n\tu32 reg32;\n\n\tpcie_capability_read_dword(pdev, PCI_EXP_SLTCAP, &reg32);\n\tif (reg32 & PCI_EXP_SLTCAP_HPC)\n\t\tpdev->is_hotplug_bridge = 1;\n}\n\nstatic void set_pcie_thunderbolt(struct pci_dev *dev)\n{\n\tu16 vsec;\n\n\t \n\tvsec = pci_find_vsec_capability(dev, PCI_VENDOR_ID_INTEL, PCI_VSEC_ID_INTEL_TBT);\n\tif (vsec)\n\t\tdev->is_thunderbolt = 1;\n}\n\nstatic void set_pcie_untrusted(struct pci_dev *dev)\n{\n\tstruct pci_dev *parent;\n\n\t \n\tparent = pci_upstream_bridge(dev);\n\tif (parent && (parent->untrusted || parent->external_facing))\n\t\tdev->untrusted = true;\n}\n\nstatic void pci_set_removable(struct pci_dev *dev)\n{\n\tstruct pci_dev *parent = pci_upstream_bridge(dev);\n\n\t \n\tif (parent &&\n\t    (parent->external_facing || dev_is_removable(&parent->dev)))\n\t\tdev_set_removable(&dev->dev, DEVICE_REMOVABLE);\n}\n\n \nstatic bool pci_ext_cfg_is_aliased(struct pci_dev *dev)\n{\n#ifdef CONFIG_PCI_QUIRKS\n\tint pos, ret;\n\tu32 header, tmp;\n\n\tpci_read_config_dword(dev, PCI_VENDOR_ID, &header);\n\n\tfor (pos = PCI_CFG_SPACE_SIZE;\n\t     pos < PCI_CFG_SPACE_EXP_SIZE; pos += PCI_CFG_SPACE_SIZE) {\n\t\tret = pci_read_config_dword(dev, pos, &tmp);\n\t\tif ((ret != PCIBIOS_SUCCESSFUL) || (header != tmp))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n#else\n\treturn false;\n#endif\n}\n\n \nstatic int pci_cfg_space_size_ext(struct pci_dev *dev)\n{\n\tu32 status;\n\tint pos = PCI_CFG_SPACE_SIZE;\n\n\tif (pci_read_config_dword(dev, pos, &status) != PCIBIOS_SUCCESSFUL)\n\t\treturn PCI_CFG_SPACE_SIZE;\n\tif (PCI_POSSIBLE_ERROR(status) || pci_ext_cfg_is_aliased(dev))\n\t\treturn PCI_CFG_SPACE_SIZE;\n\n\treturn PCI_CFG_SPACE_EXP_SIZE;\n}\n\nint pci_cfg_space_size(struct pci_dev *dev)\n{\n\tint pos;\n\tu32 status;\n\tu16 class;\n\n#ifdef CONFIG_PCI_IOV\n\t \n\tif (dev->is_virtfn)\n\t\treturn PCI_CFG_SPACE_EXP_SIZE;\n#endif\n\n\tif (dev->bus->bus_flags & PCI_BUS_FLAGS_NO_EXTCFG)\n\t\treturn PCI_CFG_SPACE_SIZE;\n\n\tclass = dev->class >> 8;\n\tif (class == PCI_CLASS_BRIDGE_HOST)\n\t\treturn pci_cfg_space_size_ext(dev);\n\n\tif (pci_is_pcie(dev))\n\t\treturn pci_cfg_space_size_ext(dev);\n\n\tpos = pci_find_capability(dev, PCI_CAP_ID_PCIX);\n\tif (!pos)\n\t\treturn PCI_CFG_SPACE_SIZE;\n\n\tpci_read_config_dword(dev, pos + PCI_X_STATUS, &status);\n\tif (status & (PCI_X_STATUS_266MHZ | PCI_X_STATUS_533MHZ))\n\t\treturn pci_cfg_space_size_ext(dev);\n\n\treturn PCI_CFG_SPACE_SIZE;\n}\n\nstatic u32 pci_class(struct pci_dev *dev)\n{\n\tu32 class;\n\n#ifdef CONFIG_PCI_IOV\n\tif (dev->is_virtfn)\n\t\treturn dev->physfn->sriov->class;\n#endif\n\tpci_read_config_dword(dev, PCI_CLASS_REVISION, &class);\n\treturn class;\n}\n\nstatic void pci_subsystem_ids(struct pci_dev *dev, u16 *vendor, u16 *device)\n{\n#ifdef CONFIG_PCI_IOV\n\tif (dev->is_virtfn) {\n\t\t*vendor = dev->physfn->sriov->subsystem_vendor;\n\t\t*device = dev->physfn->sriov->subsystem_device;\n\t\treturn;\n\t}\n#endif\n\tpci_read_config_word(dev, PCI_SUBSYSTEM_VENDOR_ID, vendor);\n\tpci_read_config_word(dev, PCI_SUBSYSTEM_ID, device);\n}\n\nstatic u8 pci_hdr_type(struct pci_dev *dev)\n{\n\tu8 hdr_type;\n\n#ifdef CONFIG_PCI_IOV\n\tif (dev->is_virtfn)\n\t\treturn dev->physfn->sriov->hdr_type;\n#endif\n\tpci_read_config_byte(dev, PCI_HEADER_TYPE, &hdr_type);\n\treturn hdr_type;\n}\n\n#define LEGACY_IO_RESOURCE\t(IORESOURCE_IO | IORESOURCE_PCI_FIXED)\n\n \nstatic int pci_intx_mask_broken(struct pci_dev *dev)\n{\n\tu16 orig, toggle, new;\n\n\tpci_read_config_word(dev, PCI_COMMAND, &orig);\n\ttoggle = orig ^ PCI_COMMAND_INTX_DISABLE;\n\tpci_write_config_word(dev, PCI_COMMAND, toggle);\n\tpci_read_config_word(dev, PCI_COMMAND, &new);\n\n\tpci_write_config_word(dev, PCI_COMMAND, orig);\n\n\t \n\tif (new != toggle)\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic void early_dump_pci_device(struct pci_dev *pdev)\n{\n\tu32 value[256 / 4];\n\tint i;\n\n\tpci_info(pdev, \"config space:\\n\");\n\n\tfor (i = 0; i < 256; i += 4)\n\t\tpci_read_config_dword(pdev, i, &value[i / 4]);\n\n\tprint_hex_dump(KERN_INFO, \"\", DUMP_PREFIX_OFFSET, 16, 1,\n\t\t       value, 256, false);\n}\n\n \nint pci_setup_device(struct pci_dev *dev)\n{\n\tu32 class;\n\tu16 cmd;\n\tu8 hdr_type;\n\tint err, pos = 0;\n\tstruct pci_bus_region region;\n\tstruct resource *res;\n\n\thdr_type = pci_hdr_type(dev);\n\n\tdev->sysdata = dev->bus->sysdata;\n\tdev->dev.parent = dev->bus->bridge;\n\tdev->dev.bus = &pci_bus_type;\n\tdev->hdr_type = hdr_type & 0x7f;\n\tdev->multifunction = !!(hdr_type & 0x80);\n\tdev->error_state = pci_channel_io_normal;\n\tset_pcie_port_type(dev);\n\n\terr = pci_set_of_node(dev);\n\tif (err)\n\t\treturn err;\n\tpci_set_acpi_fwnode(dev);\n\n\tpci_dev_assign_slot(dev);\n\n\t \n\tdev->dma_mask = 0xffffffff;\n\n\tdev_set_name(&dev->dev, \"%04x:%02x:%02x.%d\", pci_domain_nr(dev->bus),\n\t\t     dev->bus->number, PCI_SLOT(dev->devfn),\n\t\t     PCI_FUNC(dev->devfn));\n\n\tclass = pci_class(dev);\n\n\tdev->revision = class & 0xff;\n\tdev->class = class >> 8;\t\t     \n\n\tif (pci_early_dump)\n\t\tearly_dump_pci_device(dev);\n\n\t \n\tdev->cfg_size = pci_cfg_space_size(dev);\n\n\t \n\tset_pcie_thunderbolt(dev);\n\n\tset_pcie_untrusted(dev);\n\n\t \n\tdev->current_state = PCI_UNKNOWN;\n\n\t \n\tpci_fixup_device(pci_fixup_early, dev);\n\n\tpci_set_removable(dev);\n\n\tpci_info(dev, \"[%04x:%04x] type %02x class %#08x\\n\",\n\t\t dev->vendor, dev->device, dev->hdr_type, dev->class);\n\n\t \n\tclass = dev->class >> 8;\n\n\tif (dev->non_compliant_bars && !dev->mmio_always_on) {\n\t\tpci_read_config_word(dev, PCI_COMMAND, &cmd);\n\t\tif (cmd & (PCI_COMMAND_IO | PCI_COMMAND_MEMORY)) {\n\t\t\tpci_info(dev, \"device has non-compliant BARs; disabling IO/MEM decoding\\n\");\n\t\t\tcmd &= ~PCI_COMMAND_IO;\n\t\t\tcmd &= ~PCI_COMMAND_MEMORY;\n\t\t\tpci_write_config_word(dev, PCI_COMMAND, cmd);\n\t\t}\n\t}\n\n\tdev->broken_intx_masking = pci_intx_mask_broken(dev);\n\n\tswitch (dev->hdr_type) {\t\t     \n\tcase PCI_HEADER_TYPE_NORMAL:\t\t     \n\t\tif (class == PCI_CLASS_BRIDGE_PCI)\n\t\t\tgoto bad;\n\t\tpci_read_irq(dev);\n\t\tpci_read_bases(dev, 6, PCI_ROM_ADDRESS);\n\n\t\tpci_subsystem_ids(dev, &dev->subsystem_vendor, &dev->subsystem_device);\n\n\t\t \n\t\tif (class == PCI_CLASS_STORAGE_IDE) {\n\t\t\tu8 progif;\n\t\t\tpci_read_config_byte(dev, PCI_CLASS_PROG, &progif);\n\t\t\tif ((progif & 1) == 0) {\n\t\t\t\tregion.start = 0x1F0;\n\t\t\t\tregion.end = 0x1F7;\n\t\t\t\tres = &dev->resource[0];\n\t\t\t\tres->flags = LEGACY_IO_RESOURCE;\n\t\t\t\tpcibios_bus_to_resource(dev->bus, res, &region);\n\t\t\t\tpci_info(dev, \"legacy IDE quirk: reg 0x10: %pR\\n\",\n\t\t\t\t\t res);\n\t\t\t\tregion.start = 0x3F6;\n\t\t\t\tregion.end = 0x3F6;\n\t\t\t\tres = &dev->resource[1];\n\t\t\t\tres->flags = LEGACY_IO_RESOURCE;\n\t\t\t\tpcibios_bus_to_resource(dev->bus, res, &region);\n\t\t\t\tpci_info(dev, \"legacy IDE quirk: reg 0x14: %pR\\n\",\n\t\t\t\t\t res);\n\t\t\t}\n\t\t\tif ((progif & 4) == 0) {\n\t\t\t\tregion.start = 0x170;\n\t\t\t\tregion.end = 0x177;\n\t\t\t\tres = &dev->resource[2];\n\t\t\t\tres->flags = LEGACY_IO_RESOURCE;\n\t\t\t\tpcibios_bus_to_resource(dev->bus, res, &region);\n\t\t\t\tpci_info(dev, \"legacy IDE quirk: reg 0x18: %pR\\n\",\n\t\t\t\t\t res);\n\t\t\t\tregion.start = 0x376;\n\t\t\t\tregion.end = 0x376;\n\t\t\t\tres = &dev->resource[3];\n\t\t\t\tres->flags = LEGACY_IO_RESOURCE;\n\t\t\t\tpcibios_bus_to_resource(dev->bus, res, &region);\n\t\t\t\tpci_info(dev, \"legacy IDE quirk: reg 0x1c: %pR\\n\",\n\t\t\t\t\t res);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase PCI_HEADER_TYPE_BRIDGE:\t\t     \n\t\t \n\t\tpci_read_irq(dev);\n\t\tdev->transparent = ((dev->class & 0xff) == 1);\n\t\tpci_read_bases(dev, 2, PCI_ROM_ADDRESS1);\n\t\tpci_read_bridge_windows(dev);\n\t\tset_pcie_hotplug_bridge(dev);\n\t\tpos = pci_find_capability(dev, PCI_CAP_ID_SSVID);\n\t\tif (pos) {\n\t\t\tpci_read_config_word(dev, pos + PCI_SSVID_VENDOR_ID, &dev->subsystem_vendor);\n\t\t\tpci_read_config_word(dev, pos + PCI_SSVID_DEVICE_ID, &dev->subsystem_device);\n\t\t}\n\t\tbreak;\n\n\tcase PCI_HEADER_TYPE_CARDBUS:\t\t     \n\t\tif (class != PCI_CLASS_BRIDGE_CARDBUS)\n\t\t\tgoto bad;\n\t\tpci_read_irq(dev);\n\t\tpci_read_bases(dev, 1, 0);\n\t\tpci_read_config_word(dev, PCI_CB_SUBSYSTEM_VENDOR_ID, &dev->subsystem_vendor);\n\t\tpci_read_config_word(dev, PCI_CB_SUBSYSTEM_ID, &dev->subsystem_device);\n\t\tbreak;\n\n\tdefault:\t\t\t\t     \n\t\tpci_err(dev, \"unknown header type %02x, ignoring device\\n\",\n\t\t\tdev->hdr_type);\n\t\tpci_release_of_node(dev);\n\t\treturn -EIO;\n\n\tbad:\n\t\tpci_err(dev, \"ignoring class %#08x (doesn't match header type %02x)\\n\",\n\t\t\tdev->class, dev->hdr_type);\n\t\tdev->class = PCI_CLASS_NOT_DEFINED << 8;\n\t}\n\n\t \n\treturn 0;\n}\n\nstatic void pci_configure_mps(struct pci_dev *dev)\n{\n\tstruct pci_dev *bridge = pci_upstream_bridge(dev);\n\tint mps, mpss, p_mps, rc;\n\n\tif (!pci_is_pcie(dev))\n\t\treturn;\n\n\t \n\tif (dev->is_virtfn)\n\t\treturn;\n\n\t \n\tif (pci_pcie_type(dev) == PCI_EXP_TYPE_RC_END) {\n\t\tif (pcie_bus_config == PCIE_BUS_PEER2PEER)\n\t\t\tmps = 128;\n\t\telse\n\t\t\tmps = 128 << dev->pcie_mpss;\n\t\trc = pcie_set_mps(dev, mps);\n\t\tif (rc) {\n\t\t\tpci_warn(dev, \"can't set Max Payload Size to %d; if necessary, use \\\"pci=pcie_bus_safe\\\" and report a bug\\n\",\n\t\t\t\t mps);\n\t\t}\n\t\treturn;\n\t}\n\n\tif (!bridge || !pci_is_pcie(bridge))\n\t\treturn;\n\n\tmps = pcie_get_mps(dev);\n\tp_mps = pcie_get_mps(bridge);\n\n\tif (mps == p_mps)\n\t\treturn;\n\n\tif (pcie_bus_config == PCIE_BUS_TUNE_OFF) {\n\t\tpci_warn(dev, \"Max Payload Size %d, but upstream %s set to %d; if necessary, use \\\"pci=pcie_bus_safe\\\" and report a bug\\n\",\n\t\t\t mps, pci_name(bridge), p_mps);\n\t\treturn;\n\t}\n\n\t \n\tif (pcie_bus_config != PCIE_BUS_DEFAULT)\n\t\treturn;\n\n\tmpss = 128 << dev->pcie_mpss;\n\tif (mpss < p_mps && pci_pcie_type(bridge) == PCI_EXP_TYPE_ROOT_PORT) {\n\t\tpcie_set_mps(bridge, mpss);\n\t\tpci_info(dev, \"Upstream bridge's Max Payload Size set to %d (was %d, max %d)\\n\",\n\t\t\t mpss, p_mps, 128 << bridge->pcie_mpss);\n\t\tp_mps = pcie_get_mps(bridge);\n\t}\n\n\trc = pcie_set_mps(dev, p_mps);\n\tif (rc) {\n\t\tpci_warn(dev, \"can't set Max Payload Size to %d; if necessary, use \\\"pci=pcie_bus_safe\\\" and report a bug\\n\",\n\t\t\t p_mps);\n\t\treturn;\n\t}\n\n\tpci_info(dev, \"Max Payload Size set to %d (was %d, max %d)\\n\",\n\t\t p_mps, mps, mpss);\n}\n\nint pci_configure_extended_tags(struct pci_dev *dev, void *ign)\n{\n\tstruct pci_host_bridge *host;\n\tu32 cap;\n\tu16 ctl;\n\tint ret;\n\n\tif (!pci_is_pcie(dev))\n\t\treturn 0;\n\n\tret = pcie_capability_read_dword(dev, PCI_EXP_DEVCAP, &cap);\n\tif (ret)\n\t\treturn 0;\n\n\tif (!(cap & PCI_EXP_DEVCAP_EXT_TAG))\n\t\treturn 0;\n\n\tret = pcie_capability_read_word(dev, PCI_EXP_DEVCTL, &ctl);\n\tif (ret)\n\t\treturn 0;\n\n\thost = pci_find_host_bridge(dev->bus);\n\tif (!host)\n\t\treturn 0;\n\n\t \n\tif (host->no_ext_tags) {\n\t\tif (ctl & PCI_EXP_DEVCTL_EXT_TAG) {\n\t\t\tpci_info(dev, \"disabling Extended Tags\\n\");\n\t\t\tpcie_capability_clear_word(dev, PCI_EXP_DEVCTL,\n\t\t\t\t\t\t   PCI_EXP_DEVCTL_EXT_TAG);\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (!(ctl & PCI_EXP_DEVCTL_EXT_TAG)) {\n\t\tpci_info(dev, \"enabling Extended Tags\\n\");\n\t\tpcie_capability_set_word(dev, PCI_EXP_DEVCTL,\n\t\t\t\t\t PCI_EXP_DEVCTL_EXT_TAG);\n\t}\n\treturn 0;\n}\n\n \nbool pcie_relaxed_ordering_enabled(struct pci_dev *dev)\n{\n\tu16 v;\n\n\tpcie_capability_read_word(dev, PCI_EXP_DEVCTL, &v);\n\n\treturn !!(v & PCI_EXP_DEVCTL_RELAX_EN);\n}\nEXPORT_SYMBOL(pcie_relaxed_ordering_enabled);\n\nstatic void pci_configure_relaxed_ordering(struct pci_dev *dev)\n{\n\tstruct pci_dev *root;\n\n\t \n\tif (dev->is_virtfn)\n\t\treturn;\n\n\tif (!pcie_relaxed_ordering_enabled(dev))\n\t\treturn;\n\n\t \n\troot = pcie_find_root_port(dev);\n\tif (!root)\n\t\treturn;\n\n\tif (root->dev_flags & PCI_DEV_FLAGS_NO_RELAXED_ORDERING) {\n\t\tpcie_capability_clear_word(dev, PCI_EXP_DEVCTL,\n\t\t\t\t\t   PCI_EXP_DEVCTL_RELAX_EN);\n\t\tpci_info(dev, \"Relaxed Ordering disabled because the Root Port didn't support it\\n\");\n\t}\n}\n\nstatic void pci_configure_ltr(struct pci_dev *dev)\n{\n#ifdef CONFIG_PCIEASPM\n\tstruct pci_host_bridge *host = pci_find_host_bridge(dev->bus);\n\tstruct pci_dev *bridge;\n\tu32 cap, ctl;\n\n\tif (!pci_is_pcie(dev))\n\t\treturn;\n\n\t \n\tdev->l1ss = pci_find_ext_capability(dev, PCI_EXT_CAP_ID_L1SS);\n\n\tpcie_capability_read_dword(dev, PCI_EXP_DEVCAP2, &cap);\n\tif (!(cap & PCI_EXP_DEVCAP2_LTR))\n\t\treturn;\n\n\tpcie_capability_read_dword(dev, PCI_EXP_DEVCTL2, &ctl);\n\tif (ctl & PCI_EXP_DEVCTL2_LTR_EN) {\n\t\tif (pci_pcie_type(dev) == PCI_EXP_TYPE_ROOT_PORT) {\n\t\t\tdev->ltr_path = 1;\n\t\t\treturn;\n\t\t}\n\n\t\tbridge = pci_upstream_bridge(dev);\n\t\tif (bridge && bridge->ltr_path)\n\t\t\tdev->ltr_path = 1;\n\n\t\treturn;\n\t}\n\n\tif (!host->native_ltr)\n\t\treturn;\n\n\t \n\tif (pci_pcie_type(dev) == PCI_EXP_TYPE_ROOT_PORT) {\n\t\tpcie_capability_set_word(dev, PCI_EXP_DEVCTL2,\n\t\t\t\t\t PCI_EXP_DEVCTL2_LTR_EN);\n\t\tdev->ltr_path = 1;\n\t\treturn;\n\t}\n\n\t \n\tbridge = pci_upstream_bridge(dev);\n\tif (bridge && bridge->ltr_path) {\n\t\tpci_bridge_reconfigure_ltr(dev);\n\t\tpcie_capability_set_word(dev, PCI_EXP_DEVCTL2,\n\t\t\t\t\t PCI_EXP_DEVCTL2_LTR_EN);\n\t\tdev->ltr_path = 1;\n\t}\n#endif\n}\n\nstatic void pci_configure_eetlp_prefix(struct pci_dev *dev)\n{\n#ifdef CONFIG_PCI_PASID\n\tstruct pci_dev *bridge;\n\tint pcie_type;\n\tu32 cap;\n\n\tif (!pci_is_pcie(dev))\n\t\treturn;\n\n\tpcie_capability_read_dword(dev, PCI_EXP_DEVCAP2, &cap);\n\tif (!(cap & PCI_EXP_DEVCAP2_EE_PREFIX))\n\t\treturn;\n\n\tpcie_type = pci_pcie_type(dev);\n\tif (pcie_type == PCI_EXP_TYPE_ROOT_PORT ||\n\t    pcie_type == PCI_EXP_TYPE_RC_END)\n\t\tdev->eetlp_prefix_path = 1;\n\telse {\n\t\tbridge = pci_upstream_bridge(dev);\n\t\tif (bridge && bridge->eetlp_prefix_path)\n\t\t\tdev->eetlp_prefix_path = 1;\n\t}\n#endif\n}\n\nstatic void pci_configure_serr(struct pci_dev *dev)\n{\n\tu16 control;\n\n\tif (dev->hdr_type == PCI_HEADER_TYPE_BRIDGE) {\n\n\t\t \n\t\tpci_read_config_word(dev, PCI_BRIDGE_CONTROL, &control);\n\t\tif (!(control & PCI_BRIDGE_CTL_SERR)) {\n\t\t\tcontrol |= PCI_BRIDGE_CTL_SERR;\n\t\t\tpci_write_config_word(dev, PCI_BRIDGE_CONTROL, control);\n\t\t}\n\t}\n}\n\nstatic void pci_configure_device(struct pci_dev *dev)\n{\n\tpci_configure_mps(dev);\n\tpci_configure_extended_tags(dev, NULL);\n\tpci_configure_relaxed_ordering(dev);\n\tpci_configure_ltr(dev);\n\tpci_configure_eetlp_prefix(dev);\n\tpci_configure_serr(dev);\n\n\tpci_acpi_program_hp_params(dev);\n}\n\nstatic void pci_release_capabilities(struct pci_dev *dev)\n{\n\tpci_aer_exit(dev);\n\tpci_rcec_exit(dev);\n\tpci_iov_release(dev);\n\tpci_free_cap_save_buffers(dev);\n}\n\n \nstatic void pci_release_dev(struct device *dev)\n{\n\tstruct pci_dev *pci_dev;\n\n\tpci_dev = to_pci_dev(dev);\n\tpci_release_capabilities(pci_dev);\n\tpci_release_of_node(pci_dev);\n\tpcibios_release_device(pci_dev);\n\tpci_bus_put(pci_dev->bus);\n\tkfree(pci_dev->driver_override);\n\tbitmap_free(pci_dev->dma_alias_mask);\n\tdev_dbg(dev, \"device released\\n\");\n\tkfree(pci_dev);\n}\n\nstruct pci_dev *pci_alloc_dev(struct pci_bus *bus)\n{\n\tstruct pci_dev *dev;\n\n\tdev = kzalloc(sizeof(struct pci_dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&dev->bus_list);\n\tdev->dev.type = &pci_dev_type;\n\tdev->bus = pci_bus_get(bus);\n\tdev->driver_exclusive_resource = (struct resource) {\n\t\t.name = \"PCI Exclusive\",\n\t\t.start = 0,\n\t\t.end = -1,\n\t};\n\n\tspin_lock_init(&dev->pcie_cap_lock);\n#ifdef CONFIG_PCI_MSI\n\traw_spin_lock_init(&dev->msi_lock);\n#endif\n\treturn dev;\n}\nEXPORT_SYMBOL(pci_alloc_dev);\n\nstatic bool pci_bus_crs_vendor_id(u32 l)\n{\n\treturn (l & 0xffff) == PCI_VENDOR_ID_PCI_SIG;\n}\n\nstatic bool pci_bus_wait_crs(struct pci_bus *bus, int devfn, u32 *l,\n\t\t\t     int timeout)\n{\n\tint delay = 1;\n\n\tif (!pci_bus_crs_vendor_id(*l))\n\t\treturn true;\t \n\n\tif (!timeout)\n\t\treturn false;\t \n\n\t \n\twhile (pci_bus_crs_vendor_id(*l)) {\n\t\tif (delay > timeout) {\n\t\t\tpr_warn(\"pci %04x:%02x:%02x.%d: not ready after %dms; giving up\\n\",\n\t\t\t\tpci_domain_nr(bus), bus->number,\n\t\t\t\tPCI_SLOT(devfn), PCI_FUNC(devfn), delay - 1);\n\n\t\t\treturn false;\n\t\t}\n\t\tif (delay >= 1000)\n\t\t\tpr_info(\"pci %04x:%02x:%02x.%d: not ready after %dms; waiting\\n\",\n\t\t\t\tpci_domain_nr(bus), bus->number,\n\t\t\t\tPCI_SLOT(devfn), PCI_FUNC(devfn), delay - 1);\n\n\t\tmsleep(delay);\n\t\tdelay *= 2;\n\n\t\tif (pci_bus_read_config_dword(bus, devfn, PCI_VENDOR_ID, l))\n\t\t\treturn false;\n\t}\n\n\tif (delay >= 1000)\n\t\tpr_info(\"pci %04x:%02x:%02x.%d: ready after %dms\\n\",\n\t\t\tpci_domain_nr(bus), bus->number,\n\t\t\tPCI_SLOT(devfn), PCI_FUNC(devfn), delay - 1);\n\n\treturn true;\n}\n\nbool pci_bus_generic_read_dev_vendor_id(struct pci_bus *bus, int devfn, u32 *l,\n\t\t\t\t\tint timeout)\n{\n\tif (pci_bus_read_config_dword(bus, devfn, PCI_VENDOR_ID, l))\n\t\treturn false;\n\n\t \n\tif (PCI_POSSIBLE_ERROR(*l) || *l == 0x00000000 ||\n\t    *l == 0x0000ffff || *l == 0xffff0000)\n\t\treturn false;\n\n\tif (pci_bus_crs_vendor_id(*l))\n\t\treturn pci_bus_wait_crs(bus, devfn, l, timeout);\n\n\treturn true;\n}\n\nbool pci_bus_read_dev_vendor_id(struct pci_bus *bus, int devfn, u32 *l,\n\t\t\t\tint timeout)\n{\n#ifdef CONFIG_PCI_QUIRKS\n\tstruct pci_dev *bridge = bus->self;\n\n\t \n\tif (bridge && bridge->vendor == PCI_VENDOR_ID_IDT &&\n\t    bridge->device == 0x80b5)\n\t\treturn pci_idt_bus_quirk(bus, devfn, l, timeout);\n#endif\n\n\treturn pci_bus_generic_read_dev_vendor_id(bus, devfn, l, timeout);\n}\nEXPORT_SYMBOL(pci_bus_read_dev_vendor_id);\n\n \nstatic struct pci_dev *pci_scan_device(struct pci_bus *bus, int devfn)\n{\n\tstruct pci_dev *dev;\n\tu32 l;\n\n\tif (!pci_bus_read_dev_vendor_id(bus, devfn, &l, 60*1000))\n\t\treturn NULL;\n\n\tdev = pci_alloc_dev(bus);\n\tif (!dev)\n\t\treturn NULL;\n\n\tdev->devfn = devfn;\n\tdev->vendor = l & 0xffff;\n\tdev->device = (l >> 16) & 0xffff;\n\n\tif (pci_setup_device(dev)) {\n\t\tpci_bus_put(dev->bus);\n\t\tkfree(dev);\n\t\treturn NULL;\n\t}\n\n\treturn dev;\n}\n\nvoid pcie_report_downtraining(struct pci_dev *dev)\n{\n\tif (!pci_is_pcie(dev))\n\t\treturn;\n\n\t \n\tif ((pci_pcie_type(dev) != PCI_EXP_TYPE_ENDPOINT) &&\n\t    (pci_pcie_type(dev) != PCI_EXP_TYPE_LEG_END) &&\n\t    (pci_pcie_type(dev) != PCI_EXP_TYPE_UPSTREAM))\n\t\treturn;\n\n\t \n\tif (PCI_FUNC(dev->devfn) != 0 || dev->is_virtfn)\n\t\treturn;\n\n\t \n\t__pcie_print_link_status(dev, false);\n}\n\nstatic void pci_init_capabilities(struct pci_dev *dev)\n{\n\tpci_ea_init(dev);\t\t \n\tpci_msi_init(dev);\t\t \n\tpci_msix_init(dev);\t\t \n\n\t \n\tpci_allocate_cap_save_buffers(dev);\n\n\tpci_pm_init(dev);\t\t \n\tpci_vpd_init(dev);\t\t \n\tpci_configure_ari(dev);\t\t \n\tpci_iov_init(dev);\t\t \n\tpci_ats_init(dev);\t\t \n\tpci_pri_init(dev);\t\t \n\tpci_pasid_init(dev);\t\t \n\tpci_acs_init(dev);\t\t \n\tpci_ptm_init(dev);\t\t \n\tpci_aer_init(dev);\t\t \n\tpci_dpc_init(dev);\t\t \n\tpci_rcec_init(dev);\t\t \n\tpci_doe_init(dev);\t\t \n\n\tpcie_report_downtraining(dev);\n\tpci_init_reset_methods(dev);\n}\n\n \nstatic struct irq_domain *pci_dev_msi_domain(struct pci_dev *dev)\n{\n\tstruct irq_domain *d;\n\n\t \n\td = dev_get_msi_domain(&dev->dev);\n\tif (d)\n\t\treturn d;\n\n\t \n\td = pci_msi_get_device_domain(dev);\n\tif (d)\n\t\treturn d;\n\n\treturn NULL;\n}\n\nstatic void pci_set_msi_domain(struct pci_dev *dev)\n{\n\tstruct irq_domain *d;\n\n\t \n\td = pci_dev_msi_domain(dev);\n\tif (!d)\n\t\td = dev_get_msi_domain(&dev->bus->dev);\n\n\tdev_set_msi_domain(&dev->dev, d);\n}\n\nvoid pci_device_add(struct pci_dev *dev, struct pci_bus *bus)\n{\n\tint ret;\n\n\tpci_configure_device(dev);\n\n\tdevice_initialize(&dev->dev);\n\tdev->dev.release = pci_release_dev;\n\n\tset_dev_node(&dev->dev, pcibus_to_node(bus));\n\tdev->dev.dma_mask = &dev->dma_mask;\n\tdev->dev.dma_parms = &dev->dma_parms;\n\tdev->dev.coherent_dma_mask = 0xffffffffull;\n\n\tdma_set_max_seg_size(&dev->dev, 65536);\n\tdma_set_seg_boundary(&dev->dev, 0xffffffff);\n\n\tpcie_failed_link_retrain(dev);\n\n\t \n\tpci_fixup_device(pci_fixup_header, dev);\n\n\tpci_reassigndev_resource_alignment(dev);\n\n\tdev->state_saved = false;\n\n\tpci_init_capabilities(dev);\n\n\t \n\tdown_write(&pci_bus_sem);\n\tlist_add_tail(&dev->bus_list, &bus->devices);\n\tup_write(&pci_bus_sem);\n\n\tret = pcibios_device_add(dev);\n\tWARN_ON(ret < 0);\n\n\t \n\tpci_set_msi_domain(dev);\n\n\t \n\tdev->match_driver = false;\n\tret = device_add(&dev->dev);\n\tWARN_ON(ret < 0);\n}\n\nstruct pci_dev *pci_scan_single_device(struct pci_bus *bus, int devfn)\n{\n\tstruct pci_dev *dev;\n\n\tdev = pci_get_slot(bus, devfn);\n\tif (dev) {\n\t\tpci_dev_put(dev);\n\t\treturn dev;\n\t}\n\n\tdev = pci_scan_device(bus, devfn);\n\tif (!dev)\n\t\treturn NULL;\n\n\tpci_device_add(dev, bus);\n\n\treturn dev;\n}\nEXPORT_SYMBOL(pci_scan_single_device);\n\nstatic int next_ari_fn(struct pci_bus *bus, struct pci_dev *dev, int fn)\n{\n\tint pos;\n\tu16 cap = 0;\n\tunsigned int next_fn;\n\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tpos = pci_find_ext_capability(dev, PCI_EXT_CAP_ID_ARI);\n\tif (!pos)\n\t\treturn -ENODEV;\n\n\tpci_read_config_word(dev, pos + PCI_ARI_CAP, &cap);\n\tnext_fn = PCI_ARI_CAP_NFN(cap);\n\tif (next_fn <= fn)\n\t\treturn -ENODEV;\t \n\n\treturn next_fn;\n}\n\nstatic int next_fn(struct pci_bus *bus, struct pci_dev *dev, int fn)\n{\n\tif (pci_ari_enabled(bus))\n\t\treturn next_ari_fn(bus, dev, fn);\n\n\tif (fn >= 7)\n\t\treturn -ENODEV;\n\t \n\tif (dev && !dev->multifunction)\n\t\treturn -ENODEV;\n\n\treturn fn + 1;\n}\n\nstatic int only_one_child(struct pci_bus *bus)\n{\n\tstruct pci_dev *bridge = bus->self;\n\n\t \n\tif (pci_has_flag(PCI_SCAN_ALL_PCIE_DEVS))\n\t\treturn 0;\n\n\t \n\tif (bridge && pci_is_pcie(bridge) && pcie_downstream_port(bridge))\n\t\treturn 1;\n\n\treturn 0;\n}\n\n \nint pci_scan_slot(struct pci_bus *bus, int devfn)\n{\n\tstruct pci_dev *dev;\n\tint fn = 0, nr = 0;\n\n\tif (only_one_child(bus) && (devfn > 0))\n\t\treturn 0;  \n\n\tdo {\n\t\tdev = pci_scan_single_device(bus, devfn + fn);\n\t\tif (dev) {\n\t\t\tif (!pci_dev_is_added(dev))\n\t\t\t\tnr++;\n\t\t\tif (fn > 0)\n\t\t\t\tdev->multifunction = 1;\n\t\t} else if (fn == 0) {\n\t\t\t \n\t\t\tif (!hypervisor_isolated_pci_functions())\n\t\t\t\tbreak;\n\t\t}\n\t\tfn = next_fn(bus, dev, fn);\n\t} while (fn >= 0);\n\n\t \n\tif (bus->self && nr)\n\t\tpcie_aspm_init_link_state(bus->self);\n\n\treturn nr;\n}\nEXPORT_SYMBOL(pci_scan_slot);\n\nstatic int pcie_find_smpss(struct pci_dev *dev, void *data)\n{\n\tu8 *smpss = data;\n\n\tif (!pci_is_pcie(dev))\n\t\treturn 0;\n\n\t \n\tif (dev->is_hotplug_bridge &&\n\t    pci_pcie_type(dev) != PCI_EXP_TYPE_ROOT_PORT)\n\t\t*smpss = 0;\n\n\tif (*smpss > dev->pcie_mpss)\n\t\t*smpss = dev->pcie_mpss;\n\n\treturn 0;\n}\n\nstatic void pcie_write_mps(struct pci_dev *dev, int mps)\n{\n\tint rc;\n\n\tif (pcie_bus_config == PCIE_BUS_PERFORMANCE) {\n\t\tmps = 128 << dev->pcie_mpss;\n\n\t\tif (pci_pcie_type(dev) != PCI_EXP_TYPE_ROOT_PORT &&\n\t\t    dev->bus->self)\n\n\t\t\t \n\t\t\tmps = min(mps, pcie_get_mps(dev->bus->self));\n\t}\n\n\trc = pcie_set_mps(dev, mps);\n\tif (rc)\n\t\tpci_err(dev, \"Failed attempting to set the MPS\\n\");\n}\n\nstatic void pcie_write_mrrs(struct pci_dev *dev)\n{\n\tint rc, mrrs;\n\n\t \n\tif (pcie_bus_config != PCIE_BUS_PERFORMANCE)\n\t\treturn;\n\n\t \n\tmrrs = pcie_get_mps(dev);\n\n\t \n\twhile (mrrs != pcie_get_readrq(dev) && mrrs >= 128) {\n\t\trc = pcie_set_readrq(dev, mrrs);\n\t\tif (!rc)\n\t\t\tbreak;\n\n\t\tpci_warn(dev, \"Failed attempting to set the MRRS\\n\");\n\t\tmrrs /= 2;\n\t}\n\n\tif (mrrs < 128)\n\t\tpci_err(dev, \"MRRS was unable to be configured with a safe value.  If problems are experienced, try running with pci=pcie_bus_safe\\n\");\n}\n\nstatic int pcie_bus_configure_set(struct pci_dev *dev, void *data)\n{\n\tint mps, orig_mps;\n\n\tif (!pci_is_pcie(dev))\n\t\treturn 0;\n\n\tif (pcie_bus_config == PCIE_BUS_TUNE_OFF ||\n\t    pcie_bus_config == PCIE_BUS_DEFAULT)\n\t\treturn 0;\n\n\tmps = 128 << *(u8 *)data;\n\torig_mps = pcie_get_mps(dev);\n\n\tpcie_write_mps(dev, mps);\n\tpcie_write_mrrs(dev);\n\n\tpci_info(dev, \"Max Payload Size set to %4d/%4d (was %4d), Max Read Rq %4d\\n\",\n\t\t pcie_get_mps(dev), 128 << dev->pcie_mpss,\n\t\t orig_mps, pcie_get_readrq(dev));\n\n\treturn 0;\n}\n\n \nvoid pcie_bus_configure_settings(struct pci_bus *bus)\n{\n\tu8 smpss = 0;\n\n\tif (!bus->self)\n\t\treturn;\n\n\tif (!pci_is_pcie(bus->self))\n\t\treturn;\n\n\t \n\tif (pcie_bus_config == PCIE_BUS_PEER2PEER)\n\t\tsmpss = 0;\n\n\tif (pcie_bus_config == PCIE_BUS_SAFE) {\n\t\tsmpss = bus->self->pcie_mpss;\n\n\t\tpcie_find_smpss(bus->self, &smpss);\n\t\tpci_walk_bus(bus, pcie_find_smpss, &smpss);\n\t}\n\n\tpcie_bus_configure_set(bus->self, &smpss);\n\tpci_walk_bus(bus, pcie_bus_configure_set, &smpss);\n}\nEXPORT_SYMBOL_GPL(pcie_bus_configure_settings);\n\n \nvoid __weak pcibios_fixup_bus(struct pci_bus *bus)\n{\n        \n}\n\n \nstatic unsigned int pci_scan_child_bus_extend(struct pci_bus *bus,\n\t\t\t\t\t      unsigned int available_buses)\n{\n\tunsigned int used_buses, normal_bridges = 0, hotplug_bridges = 0;\n\tunsigned int start = bus->busn_res.start;\n\tunsigned int devfn, cmax, max = start;\n\tstruct pci_dev *dev;\n\n\tdev_dbg(&bus->dev, \"scanning bus\\n\");\n\n\t \n\tfor (devfn = 0; devfn < 256; devfn += 8)\n\t\tpci_scan_slot(bus, devfn);\n\n\t \n\tused_buses = pci_iov_bus_range(bus);\n\tmax += used_buses;\n\n\t \n\tif (!bus->is_added) {\n\t\tdev_dbg(&bus->dev, \"fixups for bus\\n\");\n\t\tpcibios_fixup_bus(bus);\n\t\tbus->is_added = 1;\n\t}\n\n\t \n\tfor_each_pci_bridge(dev, bus) {\n\t\tif (dev->is_hotplug_bridge)\n\t\t\thotplug_bridges++;\n\t\telse\n\t\t\tnormal_bridges++;\n\t}\n\n\t \n\tfor_each_pci_bridge(dev, bus) {\n\t\tcmax = max;\n\t\tmax = pci_scan_bridge_extend(bus, dev, max, 0, 0);\n\n\t\t \n\t\tused_buses++;\n\t\tif (max - cmax > 1)\n\t\t\tused_buses += max - cmax - 1;\n\t}\n\n\t \n\tfor_each_pci_bridge(dev, bus) {\n\t\tunsigned int buses = 0;\n\n\t\tif (!hotplug_bridges && normal_bridges == 1) {\n\t\t\t \n\t\t\tbuses = available_buses;\n\t\t} else if (dev->is_hotplug_bridge) {\n\t\t\t \n\t\t\tbuses = available_buses / hotplug_bridges;\n\t\t\tbuses = min(buses, available_buses - used_buses + 1);\n\t\t}\n\n\t\tcmax = max;\n\t\tmax = pci_scan_bridge_extend(bus, dev, cmax, buses, 1);\n\t\t \n\t\tif (max - cmax > 1)\n\t\t\tused_buses += max - cmax - 1;\n\t}\n\n\t \n\tif (bus->self && bus->self->is_hotplug_bridge) {\n\t\tused_buses = max_t(unsigned int, available_buses,\n\t\t\t\t   pci_hotplug_bus_size - 1);\n\t\tif (max - start < used_buses) {\n\t\t\tmax = start + used_buses;\n\n\t\t\t \n\t\t\tif (max > bus->busn_res.end)\n\t\t\t\tmax = bus->busn_res.end;\n\n\t\t\tdev_dbg(&bus->dev, \"%pR extended by %#02x\\n\",\n\t\t\t\t&bus->busn_res, max - start);\n\t\t}\n\t}\n\n\t \n\tdev_dbg(&bus->dev, \"bus scan returning with max=%02x\\n\", max);\n\treturn max;\n}\n\n \nunsigned int pci_scan_child_bus(struct pci_bus *bus)\n{\n\treturn pci_scan_child_bus_extend(bus, 0);\n}\nEXPORT_SYMBOL_GPL(pci_scan_child_bus);\n\n \nint __weak pcibios_root_bridge_prepare(struct pci_host_bridge *bridge)\n{\n\treturn 0;\n}\n\nvoid __weak pcibios_add_bus(struct pci_bus *bus)\n{\n}\n\nvoid __weak pcibios_remove_bus(struct pci_bus *bus)\n{\n}\n\nstruct pci_bus *pci_create_root_bus(struct device *parent, int bus,\n\t\tstruct pci_ops *ops, void *sysdata, struct list_head *resources)\n{\n\tint error;\n\tstruct pci_host_bridge *bridge;\n\n\tbridge = pci_alloc_host_bridge(0);\n\tif (!bridge)\n\t\treturn NULL;\n\n\tbridge->dev.parent = parent;\n\n\tlist_splice_init(resources, &bridge->windows);\n\tbridge->sysdata = sysdata;\n\tbridge->busnr = bus;\n\tbridge->ops = ops;\n\n\terror = pci_register_host_bridge(bridge);\n\tif (error < 0)\n\t\tgoto err_out;\n\n\treturn bridge->bus;\n\nerr_out:\n\tput_device(&bridge->dev);\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(pci_create_root_bus);\n\nint pci_host_probe(struct pci_host_bridge *bridge)\n{\n\tstruct pci_bus *bus, *child;\n\tint ret;\n\n\tret = pci_scan_root_bus_bridge(bridge);\n\tif (ret < 0) {\n\t\tdev_err(bridge->dev.parent, \"Scanning root bridge failed\");\n\t\treturn ret;\n\t}\n\n\tbus = bridge->bus;\n\n\t \n\tif (pci_has_flag(PCI_PROBE_ONLY)) {\n\t\tpci_bus_claim_resources(bus);\n\t} else {\n\t\tpci_bus_size_bridges(bus);\n\t\tpci_bus_assign_resources(bus);\n\n\t\tlist_for_each_entry(child, &bus->children, node)\n\t\t\tpcie_bus_configure_settings(child);\n\t}\n\n\tpci_bus_add_devices(bus);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(pci_host_probe);\n\nint pci_bus_insert_busn_res(struct pci_bus *b, int bus, int bus_max)\n{\n\tstruct resource *res = &b->busn_res;\n\tstruct resource *parent_res, *conflict;\n\n\tres->start = bus;\n\tres->end = bus_max;\n\tres->flags = IORESOURCE_BUS;\n\n\tif (!pci_is_root_bus(b))\n\t\tparent_res = &b->parent->busn_res;\n\telse {\n\t\tparent_res = get_pci_domain_busn_res(pci_domain_nr(b));\n\t\tres->flags |= IORESOURCE_PCI_FIXED;\n\t}\n\n\tconflict = request_resource_conflict(parent_res, res);\n\n\tif (conflict)\n\t\tdev_info(&b->dev,\n\t\t\t   \"busn_res: can not insert %pR under %s%pR (conflicts with %s %pR)\\n\",\n\t\t\t    res, pci_is_root_bus(b) ? \"domain \" : \"\",\n\t\t\t    parent_res, conflict->name, conflict);\n\n\treturn conflict == NULL;\n}\n\nint pci_bus_update_busn_res_end(struct pci_bus *b, int bus_max)\n{\n\tstruct resource *res = &b->busn_res;\n\tstruct resource old_res = *res;\n\tresource_size_t size;\n\tint ret;\n\n\tif (res->start > bus_max)\n\t\treturn -EINVAL;\n\n\tsize = bus_max - res->start + 1;\n\tret = adjust_resource(res, res->start, size);\n\tdev_info(&b->dev, \"busn_res: %pR end %s updated to %02x\\n\",\n\t\t\t&old_res, ret ? \"can not be\" : \"is\", bus_max);\n\n\tif (!ret && !res->parent)\n\t\tpci_bus_insert_busn_res(b, res->start, res->end);\n\n\treturn ret;\n}\n\nvoid pci_bus_release_busn_res(struct pci_bus *b)\n{\n\tstruct resource *res = &b->busn_res;\n\tint ret;\n\n\tif (!res->flags || !res->parent)\n\t\treturn;\n\n\tret = release_resource(res);\n\tdev_info(&b->dev, \"busn_res: %pR %s released\\n\",\n\t\t\tres, ret ? \"can not be\" : \"is\");\n}\n\nint pci_scan_root_bus_bridge(struct pci_host_bridge *bridge)\n{\n\tstruct resource_entry *window;\n\tbool found = false;\n\tstruct pci_bus *b;\n\tint max, bus, ret;\n\n\tif (!bridge)\n\t\treturn -EINVAL;\n\n\tresource_list_for_each_entry(window, &bridge->windows)\n\t\tif (window->res->flags & IORESOURCE_BUS) {\n\t\t\tbridge->busnr = window->res->start;\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\n\tret = pci_register_host_bridge(bridge);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tb = bridge->bus;\n\tbus = bridge->busnr;\n\n\tif (!found) {\n\t\tdev_info(&b->dev,\n\t\t \"No busn resource found for root bus, will use [bus %02x-ff]\\n\",\n\t\t\tbus);\n\t\tpci_bus_insert_busn_res(b, bus, 255);\n\t}\n\n\tmax = pci_scan_child_bus(b);\n\n\tif (!found)\n\t\tpci_bus_update_busn_res_end(b, max);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(pci_scan_root_bus_bridge);\n\nstruct pci_bus *pci_scan_root_bus(struct device *parent, int bus,\n\t\tstruct pci_ops *ops, void *sysdata, struct list_head *resources)\n{\n\tstruct resource_entry *window;\n\tbool found = false;\n\tstruct pci_bus *b;\n\tint max;\n\n\tresource_list_for_each_entry(window, resources)\n\t\tif (window->res->flags & IORESOURCE_BUS) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\n\tb = pci_create_root_bus(parent, bus, ops, sysdata, resources);\n\tif (!b)\n\t\treturn NULL;\n\n\tif (!found) {\n\t\tdev_info(&b->dev,\n\t\t \"No busn resource found for root bus, will use [bus %02x-ff]\\n\",\n\t\t\tbus);\n\t\tpci_bus_insert_busn_res(b, bus, 255);\n\t}\n\n\tmax = pci_scan_child_bus(b);\n\n\tif (!found)\n\t\tpci_bus_update_busn_res_end(b, max);\n\n\treturn b;\n}\nEXPORT_SYMBOL(pci_scan_root_bus);\n\nstruct pci_bus *pci_scan_bus(int bus, struct pci_ops *ops,\n\t\t\t\t\tvoid *sysdata)\n{\n\tLIST_HEAD(resources);\n\tstruct pci_bus *b;\n\n\tpci_add_resource(&resources, &ioport_resource);\n\tpci_add_resource(&resources, &iomem_resource);\n\tpci_add_resource(&resources, &busn_resource);\n\tb = pci_create_root_bus(NULL, bus, ops, sysdata, &resources);\n\tif (b) {\n\t\tpci_scan_child_bus(b);\n\t} else {\n\t\tpci_free_resource_list(&resources);\n\t}\n\treturn b;\n}\nEXPORT_SYMBOL(pci_scan_bus);\n\n \nunsigned int pci_rescan_bus_bridge_resize(struct pci_dev *bridge)\n{\n\tunsigned int max;\n\tstruct pci_bus *bus = bridge->subordinate;\n\n\tmax = pci_scan_child_bus(bus);\n\n\tpci_assign_unassigned_bridge_resources(bridge);\n\n\tpci_bus_add_devices(bus);\n\n\treturn max;\n}\n\n \nunsigned int pci_rescan_bus(struct pci_bus *bus)\n{\n\tunsigned int max;\n\n\tmax = pci_scan_child_bus(bus);\n\tpci_assign_unassigned_bus_resources(bus);\n\tpci_bus_add_devices(bus);\n\n\treturn max;\n}\nEXPORT_SYMBOL_GPL(pci_rescan_bus);\n\n \nstatic DEFINE_MUTEX(pci_rescan_remove_lock);\n\nvoid pci_lock_rescan_remove(void)\n{\n\tmutex_lock(&pci_rescan_remove_lock);\n}\nEXPORT_SYMBOL_GPL(pci_lock_rescan_remove);\n\nvoid pci_unlock_rescan_remove(void)\n{\n\tmutex_unlock(&pci_rescan_remove_lock);\n}\nEXPORT_SYMBOL_GPL(pci_unlock_rescan_remove);\n\nstatic int __init pci_sort_bf_cmp(const struct device *d_a,\n\t\t\t\t  const struct device *d_b)\n{\n\tconst struct pci_dev *a = to_pci_dev(d_a);\n\tconst struct pci_dev *b = to_pci_dev(d_b);\n\n\tif      (pci_domain_nr(a->bus) < pci_domain_nr(b->bus)) return -1;\n\telse if (pci_domain_nr(a->bus) > pci_domain_nr(b->bus)) return  1;\n\n\tif      (a->bus->number < b->bus->number) return -1;\n\telse if (a->bus->number > b->bus->number) return  1;\n\n\tif      (a->devfn < b->devfn) return -1;\n\telse if (a->devfn > b->devfn) return  1;\n\n\treturn 0;\n}\n\nvoid __init pci_sort_breadthfirst(void)\n{\n\tbus_sort_breadthfirst(&pci_bus_type, &pci_sort_bf_cmp);\n}\n\nint pci_hp_add_bridge(struct pci_dev *dev)\n{\n\tstruct pci_bus *parent = dev->bus;\n\tint busnr, start = parent->busn_res.start;\n\tunsigned int available_buses = 0;\n\tint end = parent->busn_res.end;\n\n\tfor (busnr = start; busnr <= end; busnr++) {\n\t\tif (!pci_find_bus(pci_domain_nr(parent), busnr))\n\t\t\tbreak;\n\t}\n\tif (busnr-- > end) {\n\t\tpci_err(dev, \"No bus number available for hot-added bridge\\n\");\n\t\treturn -1;\n\t}\n\n\t \n\tbusnr = pci_scan_bridge(parent, dev, busnr, 0);\n\n\t \n\tavailable_buses = end - busnr;\n\n\t \n\tpci_scan_bridge_extend(parent, dev, busnr, available_buses, 1);\n\n\tif (!dev->subordinate)\n\t\treturn -1;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(pci_hp_add_bridge);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}