{
  "module_name": "doe.c",
  "hash_id": "5ecb295d29bd1e4e84689ffe4ef34d11b861f34295e08adecf430431dc3b66bc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/doe.c",
  "human_readable_source": "\n \n\n#define dev_fmt(fmt) \"DOE: \" fmt\n\n#include <linux/bitfield.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/mutex.h>\n#include <linux/pci.h>\n#include <linux/pci-doe.h>\n#include <linux/workqueue.h>\n\n#include \"pci.h\"\n\n#define PCI_DOE_PROTOCOL_DISCOVERY 0\n\n \n#define PCI_DOE_TIMEOUT HZ\n#define PCI_DOE_POLL_INTERVAL\t(PCI_DOE_TIMEOUT / 128)\n\n#define PCI_DOE_FLAG_CANCEL\t0\n#define PCI_DOE_FLAG_DEAD\t1\n\n \n#define PCI_DOE_MAX_LENGTH\t(1 << 18)\n\n \nstruct pci_doe_mb {\n\tstruct pci_dev *pdev;\n\tu16 cap_offset;\n\tstruct xarray prots;\n\n\twait_queue_head_t wq;\n\tstruct workqueue_struct *work_queue;\n\tunsigned long flags;\n};\n\nstruct pci_doe_protocol {\n\tu16 vid;\n\tu8 type;\n};\n\n \nstruct pci_doe_task {\n\tstruct pci_doe_protocol prot;\n\tconst __le32 *request_pl;\n\tsize_t request_pl_sz;\n\t__le32 *response_pl;\n\tsize_t response_pl_sz;\n\tint rv;\n\tvoid (*complete)(struct pci_doe_task *task);\n\tvoid *private;\n\n\t \n\tstruct work_struct work;\n\tstruct pci_doe_mb *doe_mb;\n};\n\nstatic int pci_doe_wait(struct pci_doe_mb *doe_mb, unsigned long timeout)\n{\n\tif (wait_event_timeout(doe_mb->wq,\n\t\t\t       test_bit(PCI_DOE_FLAG_CANCEL, &doe_mb->flags),\n\t\t\t       timeout))\n\t\treturn -EIO;\n\treturn 0;\n}\n\nstatic void pci_doe_write_ctrl(struct pci_doe_mb *doe_mb, u32 val)\n{\n\tstruct pci_dev *pdev = doe_mb->pdev;\n\tint offset = doe_mb->cap_offset;\n\n\tpci_write_config_dword(pdev, offset + PCI_DOE_CTRL, val);\n}\n\nstatic int pci_doe_abort(struct pci_doe_mb *doe_mb)\n{\n\tstruct pci_dev *pdev = doe_mb->pdev;\n\tint offset = doe_mb->cap_offset;\n\tunsigned long timeout_jiffies;\n\n\tpci_dbg(pdev, \"[%x] Issuing Abort\\n\", offset);\n\n\ttimeout_jiffies = jiffies + PCI_DOE_TIMEOUT;\n\tpci_doe_write_ctrl(doe_mb, PCI_DOE_CTRL_ABORT);\n\n\tdo {\n\t\tint rc;\n\t\tu32 val;\n\n\t\trc = pci_doe_wait(doe_mb, PCI_DOE_POLL_INTERVAL);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tpci_read_config_dword(pdev, offset + PCI_DOE_STATUS, &val);\n\n\t\t \n\t\tif (!FIELD_GET(PCI_DOE_STATUS_ERROR, val) &&\n\t\t    !FIELD_GET(PCI_DOE_STATUS_BUSY, val))\n\t\t\treturn 0;\n\n\t} while (!time_after(jiffies, timeout_jiffies));\n\n\t \n\tpci_err(pdev, \"[%x] ABORT timed out\\n\", offset);\n\treturn -EIO;\n}\n\nstatic int pci_doe_send_req(struct pci_doe_mb *doe_mb,\n\t\t\t    struct pci_doe_task *task)\n{\n\tstruct pci_dev *pdev = doe_mb->pdev;\n\tint offset = doe_mb->cap_offset;\n\tsize_t length, remainder;\n\tu32 val;\n\tint i;\n\n\t \n\tpci_read_config_dword(pdev, offset + PCI_DOE_STATUS, &val);\n\tif (FIELD_GET(PCI_DOE_STATUS_BUSY, val))\n\t\treturn -EBUSY;\n\n\tif (FIELD_GET(PCI_DOE_STATUS_ERROR, val))\n\t\treturn -EIO;\n\n\t \n\tlength = 2 + DIV_ROUND_UP(task->request_pl_sz, sizeof(__le32));\n\tif (length > PCI_DOE_MAX_LENGTH)\n\t\treturn -EIO;\n\tif (length == PCI_DOE_MAX_LENGTH)\n\t\tlength = 0;\n\n\t \n\tval = FIELD_PREP(PCI_DOE_DATA_OBJECT_HEADER_1_VID, task->prot.vid) |\n\t\tFIELD_PREP(PCI_DOE_DATA_OBJECT_HEADER_1_TYPE, task->prot.type);\n\tpci_write_config_dword(pdev, offset + PCI_DOE_WRITE, val);\n\tpci_write_config_dword(pdev, offset + PCI_DOE_WRITE,\n\t\t\t       FIELD_PREP(PCI_DOE_DATA_OBJECT_HEADER_2_LENGTH,\n\t\t\t\t\t  length));\n\n\t \n\tfor (i = 0; i < task->request_pl_sz / sizeof(__le32); i++)\n\t\tpci_write_config_dword(pdev, offset + PCI_DOE_WRITE,\n\t\t\t\t       le32_to_cpu(task->request_pl[i]));\n\n\t \n\tremainder = task->request_pl_sz % sizeof(__le32);\n\tif (remainder) {\n\t\tval = 0;\n\t\tmemcpy(&val, &task->request_pl[i], remainder);\n\t\tle32_to_cpus(&val);\n\t\tpci_write_config_dword(pdev, offset + PCI_DOE_WRITE, val);\n\t}\n\n\tpci_doe_write_ctrl(doe_mb, PCI_DOE_CTRL_GO);\n\n\treturn 0;\n}\n\nstatic bool pci_doe_data_obj_ready(struct pci_doe_mb *doe_mb)\n{\n\tstruct pci_dev *pdev = doe_mb->pdev;\n\tint offset = doe_mb->cap_offset;\n\tu32 val;\n\n\tpci_read_config_dword(pdev, offset + PCI_DOE_STATUS, &val);\n\tif (FIELD_GET(PCI_DOE_STATUS_DATA_OBJECT_READY, val))\n\t\treturn true;\n\treturn false;\n}\n\nstatic int pci_doe_recv_resp(struct pci_doe_mb *doe_mb, struct pci_doe_task *task)\n{\n\tsize_t length, payload_length, remainder, received;\n\tstruct pci_dev *pdev = doe_mb->pdev;\n\tint offset = doe_mb->cap_offset;\n\tint i = 0;\n\tu32 val;\n\n\t \n\tpci_read_config_dword(pdev, offset + PCI_DOE_READ, &val);\n\tif ((FIELD_GET(PCI_DOE_DATA_OBJECT_HEADER_1_VID, val) != task->prot.vid) ||\n\t    (FIELD_GET(PCI_DOE_DATA_OBJECT_HEADER_1_TYPE, val) != task->prot.type)) {\n\t\tdev_err_ratelimited(&pdev->dev, \"[%x] expected [VID, Protocol] = [%04x, %02x], got [%04x, %02x]\\n\",\n\t\t\t\t    doe_mb->cap_offset, task->prot.vid, task->prot.type,\n\t\t\t\t    FIELD_GET(PCI_DOE_DATA_OBJECT_HEADER_1_VID, val),\n\t\t\t\t    FIELD_GET(PCI_DOE_DATA_OBJECT_HEADER_1_TYPE, val));\n\t\treturn -EIO;\n\t}\n\n\tpci_write_config_dword(pdev, offset + PCI_DOE_READ, 0);\n\t \n\tpci_read_config_dword(pdev, offset + PCI_DOE_READ, &val);\n\tpci_write_config_dword(pdev, offset + PCI_DOE_READ, 0);\n\n\tlength = FIELD_GET(PCI_DOE_DATA_OBJECT_HEADER_2_LENGTH, val);\n\t \n\tif (!length)\n\t\tlength = PCI_DOE_MAX_LENGTH;\n\tif (length < 2)\n\t\treturn -EIO;\n\n\t \n\tlength -= 2;\n\treceived = task->response_pl_sz;\n\tpayload_length = DIV_ROUND_UP(task->response_pl_sz, sizeof(__le32));\n\tremainder = task->response_pl_sz % sizeof(__le32);\n\n\t \n\tif (!remainder)\n\t\tremainder = sizeof(__le32);\n\n\tif (length < payload_length) {\n\t\treceived = length * sizeof(__le32);\n\t\tpayload_length = length;\n\t\tremainder = sizeof(__le32);\n\t}\n\n\tif (payload_length) {\n\t\t \n\t\tfor (; i < payload_length - 1; i++) {\n\t\t\tpci_read_config_dword(pdev, offset + PCI_DOE_READ,\n\t\t\t\t\t      &val);\n\t\t\ttask->response_pl[i] = cpu_to_le32(val);\n\t\t\tpci_write_config_dword(pdev, offset + PCI_DOE_READ, 0);\n\t\t}\n\n\t\t \n\t\tpci_read_config_dword(pdev, offset + PCI_DOE_READ, &val);\n\t\tcpu_to_le32s(&val);\n\t\tmemcpy(&task->response_pl[i], &val, remainder);\n\t\t \n\t\tif (!pci_doe_data_obj_ready(doe_mb))\n\t\t\treturn -EIO;\n\t\tpci_write_config_dword(pdev, offset + PCI_DOE_READ, 0);\n\t\ti++;\n\t}\n\n\t \n\tfor (; i < length; i++) {\n\t\tpci_read_config_dword(pdev, offset + PCI_DOE_READ, &val);\n\t\tpci_write_config_dword(pdev, offset + PCI_DOE_READ, 0);\n\t}\n\n\t \n\tpci_read_config_dword(pdev, offset + PCI_DOE_STATUS, &val);\n\tif (FIELD_GET(PCI_DOE_STATUS_ERROR, val))\n\t\treturn -EIO;\n\n\treturn received;\n}\n\nstatic void signal_task_complete(struct pci_doe_task *task, int rv)\n{\n\ttask->rv = rv;\n\tdestroy_work_on_stack(&task->work);\n\ttask->complete(task);\n}\n\nstatic void signal_task_abort(struct pci_doe_task *task, int rv)\n{\n\tstruct pci_doe_mb *doe_mb = task->doe_mb;\n\tstruct pci_dev *pdev = doe_mb->pdev;\n\n\tif (pci_doe_abort(doe_mb)) {\n\t\t \n\t\tpci_err(pdev, \"[%x] Abort failed marking mailbox dead\\n\",\n\t\t\tdoe_mb->cap_offset);\n\t\tset_bit(PCI_DOE_FLAG_DEAD, &doe_mb->flags);\n\t}\n\tsignal_task_complete(task, rv);\n}\n\nstatic void doe_statemachine_work(struct work_struct *work)\n{\n\tstruct pci_doe_task *task = container_of(work, struct pci_doe_task,\n\t\t\t\t\t\t work);\n\tstruct pci_doe_mb *doe_mb = task->doe_mb;\n\tstruct pci_dev *pdev = doe_mb->pdev;\n\tint offset = doe_mb->cap_offset;\n\tunsigned long timeout_jiffies;\n\tu32 val;\n\tint rc;\n\n\tif (test_bit(PCI_DOE_FLAG_DEAD, &doe_mb->flags)) {\n\t\tsignal_task_complete(task, -EIO);\n\t\treturn;\n\t}\n\n\t \n\trc = pci_doe_send_req(doe_mb, task);\n\tif (rc) {\n\t\t \n\t\tif (rc == -EBUSY)\n\t\t\tdev_err_ratelimited(&pdev->dev, \"[%x] busy detected; another entity is sending conflicting requests\\n\",\n\t\t\t\t\t    offset);\n\t\tsignal_task_abort(task, rc);\n\t\treturn;\n\t}\n\n\ttimeout_jiffies = jiffies + PCI_DOE_TIMEOUT;\n\t \nretry_resp:\n\tpci_read_config_dword(pdev, offset + PCI_DOE_STATUS, &val);\n\tif (FIELD_GET(PCI_DOE_STATUS_ERROR, val)) {\n\t\tsignal_task_abort(task, -EIO);\n\t\treturn;\n\t}\n\n\tif (!FIELD_GET(PCI_DOE_STATUS_DATA_OBJECT_READY, val)) {\n\t\tif (time_after(jiffies, timeout_jiffies)) {\n\t\t\tsignal_task_abort(task, -EIO);\n\t\t\treturn;\n\t\t}\n\t\trc = pci_doe_wait(doe_mb, PCI_DOE_POLL_INTERVAL);\n\t\tif (rc) {\n\t\t\tsignal_task_abort(task, rc);\n\t\t\treturn;\n\t\t}\n\t\tgoto retry_resp;\n\t}\n\n\trc  = pci_doe_recv_resp(doe_mb, task);\n\tif (rc < 0) {\n\t\tsignal_task_abort(task, rc);\n\t\treturn;\n\t}\n\n\tsignal_task_complete(task, rc);\n}\n\nstatic void pci_doe_task_complete(struct pci_doe_task *task)\n{\n\tcomplete(task->private);\n}\n\nstatic int pci_doe_discovery(struct pci_doe_mb *doe_mb, u8 *index, u16 *vid,\n\t\t\t     u8 *protocol)\n{\n\tu32 request_pl = FIELD_PREP(PCI_DOE_DATA_OBJECT_DISC_REQ_3_INDEX,\n\t\t\t\t    *index);\n\t__le32 request_pl_le = cpu_to_le32(request_pl);\n\t__le32 response_pl_le;\n\tu32 response_pl;\n\tint rc;\n\n\trc = pci_doe(doe_mb, PCI_VENDOR_ID_PCI_SIG, PCI_DOE_PROTOCOL_DISCOVERY,\n\t\t     &request_pl_le, sizeof(request_pl_le),\n\t\t     &response_pl_le, sizeof(response_pl_le));\n\tif (rc < 0)\n\t\treturn rc;\n\n\tif (rc != sizeof(response_pl_le))\n\t\treturn -EIO;\n\n\tresponse_pl = le32_to_cpu(response_pl_le);\n\t*vid = FIELD_GET(PCI_DOE_DATA_OBJECT_DISC_RSP_3_VID, response_pl);\n\t*protocol = FIELD_GET(PCI_DOE_DATA_OBJECT_DISC_RSP_3_PROTOCOL,\n\t\t\t      response_pl);\n\t*index = FIELD_GET(PCI_DOE_DATA_OBJECT_DISC_RSP_3_NEXT_INDEX,\n\t\t\t   response_pl);\n\n\treturn 0;\n}\n\nstatic void *pci_doe_xa_prot_entry(u16 vid, u8 prot)\n{\n\treturn xa_mk_value((vid << 8) | prot);\n}\n\nstatic int pci_doe_cache_protocols(struct pci_doe_mb *doe_mb)\n{\n\tu8 index = 0;\n\tu8 xa_idx = 0;\n\n\tdo {\n\t\tint rc;\n\t\tu16 vid;\n\t\tu8 prot;\n\n\t\trc = pci_doe_discovery(doe_mb, &index, &vid, &prot);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\tpci_dbg(doe_mb->pdev,\n\t\t\t\"[%x] Found protocol %d vid: %x prot: %x\\n\",\n\t\t\tdoe_mb->cap_offset, xa_idx, vid, prot);\n\n\t\trc = xa_insert(&doe_mb->prots, xa_idx++,\n\t\t\t       pci_doe_xa_prot_entry(vid, prot), GFP_KERNEL);\n\t\tif (rc)\n\t\t\treturn rc;\n\t} while (index);\n\n\treturn 0;\n}\n\nstatic void pci_doe_cancel_tasks(struct pci_doe_mb *doe_mb)\n{\n\t \n\tset_bit(PCI_DOE_FLAG_DEAD, &doe_mb->flags);\n\n\t \n\tset_bit(PCI_DOE_FLAG_CANCEL, &doe_mb->flags);\n\twake_up(&doe_mb->wq);\n}\n\n \nstatic struct pci_doe_mb *pci_doe_create_mb(struct pci_dev *pdev,\n\t\t\t\t\t    u16 cap_offset)\n{\n\tstruct pci_doe_mb *doe_mb;\n\tint rc;\n\n\tdoe_mb = kzalloc(sizeof(*doe_mb), GFP_KERNEL);\n\tif (!doe_mb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tdoe_mb->pdev = pdev;\n\tdoe_mb->cap_offset = cap_offset;\n\tinit_waitqueue_head(&doe_mb->wq);\n\txa_init(&doe_mb->prots);\n\n\tdoe_mb->work_queue = alloc_ordered_workqueue(\"%s %s DOE [%x]\", 0,\n\t\t\t\t\t\tdev_bus_name(&pdev->dev),\n\t\t\t\t\t\tpci_name(pdev),\n\t\t\t\t\t\tdoe_mb->cap_offset);\n\tif (!doe_mb->work_queue) {\n\t\tpci_err(pdev, \"[%x] failed to allocate work queue\\n\",\n\t\t\tdoe_mb->cap_offset);\n\t\trc = -ENOMEM;\n\t\tgoto err_free;\n\t}\n\n\t \n\trc = pci_doe_abort(doe_mb);\n\tif (rc) {\n\t\tpci_err(pdev, \"[%x] failed to reset mailbox with abort command : %d\\n\",\n\t\t\tdoe_mb->cap_offset, rc);\n\t\tgoto err_destroy_wq;\n\t}\n\n\t \n\trc = pci_doe_cache_protocols(doe_mb);\n\tif (rc) {\n\t\tpci_err(pdev, \"[%x] failed to cache protocols : %d\\n\",\n\t\t\tdoe_mb->cap_offset, rc);\n\t\tgoto err_cancel;\n\t}\n\n\treturn doe_mb;\n\nerr_cancel:\n\tpci_doe_cancel_tasks(doe_mb);\n\txa_destroy(&doe_mb->prots);\nerr_destroy_wq:\n\tdestroy_workqueue(doe_mb->work_queue);\nerr_free:\n\tkfree(doe_mb);\n\treturn ERR_PTR(rc);\n}\n\n \nstatic void pci_doe_destroy_mb(struct pci_doe_mb *doe_mb)\n{\n\tpci_doe_cancel_tasks(doe_mb);\n\txa_destroy(&doe_mb->prots);\n\tdestroy_workqueue(doe_mb->work_queue);\n\tkfree(doe_mb);\n}\n\n \nstatic bool pci_doe_supports_prot(struct pci_doe_mb *doe_mb, u16 vid, u8 type)\n{\n\tunsigned long index;\n\tvoid *entry;\n\n\t \n\tif (vid == PCI_VENDOR_ID_PCI_SIG && type == PCI_DOE_PROTOCOL_DISCOVERY)\n\t\treturn true;\n\n\txa_for_each(&doe_mb->prots, index, entry)\n\t\tif (entry == pci_doe_xa_prot_entry(vid, type))\n\t\t\treturn true;\n\n\treturn false;\n}\n\n \nstatic int pci_doe_submit_task(struct pci_doe_mb *doe_mb,\n\t\t\t       struct pci_doe_task *task)\n{\n\tif (!pci_doe_supports_prot(doe_mb, task->prot.vid, task->prot.type))\n\t\treturn -EINVAL;\n\n\tif (test_bit(PCI_DOE_FLAG_DEAD, &doe_mb->flags))\n\t\treturn -EIO;\n\n\ttask->doe_mb = doe_mb;\n\tINIT_WORK_ONSTACK(&task->work, doe_statemachine_work);\n\tqueue_work(doe_mb->work_queue, &task->work);\n\treturn 0;\n}\n\n \nint pci_doe(struct pci_doe_mb *doe_mb, u16 vendor, u8 type,\n\t    const void *request, size_t request_sz,\n\t    void *response, size_t response_sz)\n{\n\tDECLARE_COMPLETION_ONSTACK(c);\n\tstruct pci_doe_task task = {\n\t\t.prot.vid = vendor,\n\t\t.prot.type = type,\n\t\t.request_pl = request,\n\t\t.request_pl_sz = request_sz,\n\t\t.response_pl = response,\n\t\t.response_pl_sz = response_sz,\n\t\t.complete = pci_doe_task_complete,\n\t\t.private = &c,\n\t};\n\tint rc;\n\n\trc = pci_doe_submit_task(doe_mb, &task);\n\tif (rc)\n\t\treturn rc;\n\n\twait_for_completion(&c);\n\n\treturn task.rv;\n}\nEXPORT_SYMBOL_GPL(pci_doe);\n\n \nstruct pci_doe_mb *pci_find_doe_mailbox(struct pci_dev *pdev, u16 vendor,\n\t\t\t\t\tu8 type)\n{\n\tstruct pci_doe_mb *doe_mb;\n\tunsigned long index;\n\n\txa_for_each(&pdev->doe_mbs, index, doe_mb)\n\t\tif (pci_doe_supports_prot(doe_mb, vendor, type))\n\t\t\treturn doe_mb;\n\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(pci_find_doe_mailbox);\n\nvoid pci_doe_init(struct pci_dev *pdev)\n{\n\tstruct pci_doe_mb *doe_mb;\n\tu16 offset = 0;\n\tint rc;\n\n\txa_init(&pdev->doe_mbs);\n\n\twhile ((offset = pci_find_next_ext_capability(pdev, offset,\n\t\t\t\t\t\t      PCI_EXT_CAP_ID_DOE))) {\n\t\tdoe_mb = pci_doe_create_mb(pdev, offset);\n\t\tif (IS_ERR(doe_mb)) {\n\t\t\tpci_err(pdev, \"[%x] failed to create mailbox: %ld\\n\",\n\t\t\t\toffset, PTR_ERR(doe_mb));\n\t\t\tcontinue;\n\t\t}\n\n\t\trc = xa_insert(&pdev->doe_mbs, offset, doe_mb, GFP_KERNEL);\n\t\tif (rc) {\n\t\t\tpci_err(pdev, \"[%x] failed to insert mailbox: %d\\n\",\n\t\t\t\toffset, rc);\n\t\t\tpci_doe_destroy_mb(doe_mb);\n\t\t}\n\t}\n}\n\nvoid pci_doe_destroy(struct pci_dev *pdev)\n{\n\tstruct pci_doe_mb *doe_mb;\n\tunsigned long index;\n\n\txa_for_each(&pdev->doe_mbs, index, doe_mb)\n\t\tpci_doe_destroy_mb(doe_mb);\n\n\txa_destroy(&pdev->doe_mbs);\n}\n\nvoid pci_doe_disconnected(struct pci_dev *pdev)\n{\n\tstruct pci_doe_mb *doe_mb;\n\tunsigned long index;\n\n\txa_for_each(&pdev->doe_mbs, index, doe_mb)\n\t\tpci_doe_cancel_tasks(doe_mb);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}