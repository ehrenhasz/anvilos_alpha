{
  "module_name": "rpaphp_core.c",
  "hash_id": "b36a269c13d60b9b8227dbf02fb060a882e9dc60da81a41bc5dc614ab7534425",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/hotplug/rpaphp_core.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/of.h>\n#include <linux/pci.h>\n#include <linux/pci_hotplug.h>\n#include <linux/smp.h>\n#include <linux/init.h>\n#include <linux/vmalloc.h>\n#include <asm/firmware.h>\n#include <asm/eeh.h>        \n#include <asm/rtas.h>\t\t \n#include <asm/pci-bridge.h>\t \n#include <asm/prom.h>\n#include \"../pci.h\"\t\t \n\t\t\t\t \n#include \"rpaphp.h\"\n\nbool rpaphp_debug;\nLIST_HEAD(rpaphp_slot_head);\nEXPORT_SYMBOL_GPL(rpaphp_slot_head);\n\n#define DRIVER_VERSION\t\"0.1\"\n#define DRIVER_AUTHOR\t\"Linda Xie <lxie@us.ibm.com>\"\n#define DRIVER_DESC\t\"RPA HOT Plug PCI Controller Driver\"\n\n#define MAX_LOC_CODE 128\n\nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n\nmodule_param_named(debug, rpaphp_debug, bool, 0644);\n\n \nstatic int set_attention_status(struct hotplug_slot *hotplug_slot, u8 value)\n{\n\tint rc;\n\tstruct slot *slot = to_slot(hotplug_slot);\n\n\tswitch (value) {\n\tcase 0:\n\tcase 1:\n\tcase 2:\n\t\tbreak;\n\tdefault:\n\t\tvalue = 1;\n\t\tbreak;\n\t}\n\n\trc = rtas_set_indicator(DR_INDICATOR, slot->index, value);\n\tif (!rc)\n\t\tslot->attention_status = value;\n\n\treturn rc;\n}\n\n \nstatic int get_power_status(struct hotplug_slot *hotplug_slot, u8 *value)\n{\n\tint retval, level;\n\tstruct slot *slot = to_slot(hotplug_slot);\n\n\tretval = rtas_get_power_level(slot->power_domain, &level);\n\tif (!retval)\n\t\t*value = level;\n\treturn retval;\n}\n\n \nstatic int get_attention_status(struct hotplug_slot *hotplug_slot, u8 *value)\n{\n\tstruct slot *slot = to_slot(hotplug_slot);\n\t*value = slot->attention_status;\n\treturn 0;\n}\n\nstatic int get_adapter_status(struct hotplug_slot *hotplug_slot, u8 *value)\n{\n\tstruct slot *slot = to_slot(hotplug_slot);\n\tint rc, state;\n\n\trc = rpaphp_get_sensor_state(slot, &state);\n\n\t*value = NOT_VALID;\n\tif (rc)\n\t\treturn rc;\n\n\tif (state == EMPTY)\n\t\t*value = EMPTY;\n\telse if (state == PRESENT)\n\t\t*value = slot->state;\n\n\treturn 0;\n}\n\nstatic enum pci_bus_speed get_max_bus_speed(struct slot *slot)\n{\n\tenum pci_bus_speed speed;\n\tswitch (slot->type) {\n\tcase 1:\n\tcase 2:\n\tcase 3:\n\tcase 4:\n\tcase 5:\n\tcase 6:\n\t\tspeed = PCI_SPEED_33MHz;\t \n\t\tbreak;\n\tcase 7:\n\tcase 8:\n\t\tspeed = PCI_SPEED_66MHz;\n\t\tbreak;\n\tcase 11:\n\tcase 14:\n\t\tspeed = PCI_SPEED_66MHz_PCIX;\n\t\tbreak;\n\tcase 12:\n\tcase 15:\n\t\tspeed = PCI_SPEED_100MHz_PCIX;\n\t\tbreak;\n\tcase 13:\n\tcase 16:\n\t\tspeed = PCI_SPEED_133MHz_PCIX;\n\t\tbreak;\n\tdefault:\n\t\tspeed = PCI_SPEED_UNKNOWN;\n\t\tbreak;\n\t}\n\n\treturn speed;\n}\n\nstatic int get_children_props(struct device_node *dn, const __be32 **drc_indexes,\n\t\t\t      const __be32 **drc_names, const __be32 **drc_types,\n\t\t\t      const __be32 **drc_power_domains)\n{\n\tconst __be32 *indexes, *names, *types, *domains;\n\n\tindexes = of_get_property(dn, \"ibm,drc-indexes\", NULL);\n\tnames = of_get_property(dn, \"ibm,drc-names\", NULL);\n\ttypes = of_get_property(dn, \"ibm,drc-types\", NULL);\n\tdomains = of_get_property(dn, \"ibm,drc-power-domains\", NULL);\n\n\tif (!indexes || !names || !types || !domains) {\n\t\t \n\t\treturn -EINVAL;\n\t}\n\tif (drc_indexes)\n\t\t*drc_indexes = indexes;\n\tif (drc_names)\n\t\t \n\t\t*drc_names = names;\n\tif (drc_types)\n\t\t \n\t\t*drc_types = types;\n\tif (drc_power_domains)\n\t\t*drc_power_domains = domains;\n\n\treturn 0;\n}\n\n\n \n\nstatic int rpaphp_check_drc_props_v1(struct device_node *dn, char *drc_name,\n\t\t\t\tchar *drc_type, unsigned int my_index)\n{\n\tchar *name_tmp, *type_tmp;\n\tconst __be32 *indexes, *names;\n\tconst __be32 *types, *domains;\n\tint i, rc;\n\n\trc = get_children_props(dn->parent, &indexes, &names, &types, &domains);\n\tif (rc < 0) {\n\t\treturn -EINVAL;\n\t}\n\n\tname_tmp = (char *) &names[1];\n\ttype_tmp = (char *) &types[1];\n\n\t \n\tfor (i = 0; i < be32_to_cpu(indexes[0]); i++) {\n\t\tif (be32_to_cpu(indexes[i + 1]) == my_index)\n\t\t\tbreak;\n\n\t\tname_tmp += (strlen(name_tmp) + 1);\n\t\ttype_tmp += (strlen(type_tmp) + 1);\n\t}\n\n\tif (((drc_name == NULL) || (drc_name && !strcmp(drc_name, name_tmp))) &&\n\t    ((drc_type == NULL) || (drc_type && !strcmp(drc_type, type_tmp))))\n\t\treturn 0;\n\n\treturn -EINVAL;\n}\n\nstatic int rpaphp_check_drc_props_v2(struct device_node *dn, char *drc_name,\n\t\t\t\tchar *drc_type, unsigned int my_index)\n{\n\tstruct property *info;\n\tunsigned int entries;\n\tstruct of_drc_info drc;\n\tconst __be32 *value;\n\tchar cell_drc_name[MAX_DRC_NAME_LEN];\n\tint j;\n\n\tinfo = of_find_property(dn->parent, \"ibm,drc-info\", NULL);\n\tif (info == NULL)\n\t\treturn -EINVAL;\n\n\tvalue = of_prop_next_u32(info, NULL, &entries);\n\tif (!value)\n\t\treturn -EINVAL;\n\telse\n\t\tvalue++;\n\n\tfor (j = 0; j < entries; j++) {\n\t\tof_read_drc_info_cell(&info, &value, &drc);\n\n\t\t \n\n\t\t \n\t\tif (my_index >= drc.drc_index_start && my_index <= drc.last_drc_index) {\n\t\t\tint index = my_index - drc.drc_index_start;\n\t\t\tsprintf(cell_drc_name, \"%s%d\", drc.drc_name_prefix,\n\t\t\t\tdrc.drc_name_suffix_start + index);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (((drc_name == NULL) ||\n\t     (drc_name && !strcmp(drc_name, cell_drc_name))) &&\n\t    ((drc_type == NULL) ||\n\t     (drc_type && !strcmp(drc_type, drc.drc_type))))\n\t\treturn 0;\n\n\treturn -EINVAL;\n}\n\nint rpaphp_check_drc_props(struct device_node *dn, char *drc_name,\n\t\t\tchar *drc_type)\n{\n\tconst __be32 *my_index;\n\n\tmy_index = of_get_property(dn, \"ibm,my-drc-index\", NULL);\n\tif (!my_index) {\n\t\t \n\t\treturn -EINVAL;\n\t}\n\n\tif (of_property_present(dn->parent, \"ibm,drc-info\"))\n\t\treturn rpaphp_check_drc_props_v2(dn, drc_name, drc_type,\n\t\t\t\t\t\tbe32_to_cpu(*my_index));\n\telse\n\t\treturn rpaphp_check_drc_props_v1(dn, drc_name, drc_type,\n\t\t\t\t\t\tbe32_to_cpu(*my_index));\n}\nEXPORT_SYMBOL_GPL(rpaphp_check_drc_props);\n\n\nstatic int is_php_type(char *drc_type)\n{\n\tchar *endptr;\n\n\t \n\tsimple_strtoul(drc_type, &endptr, 10);\n\tif (endptr == drc_type)\n\t\treturn 0;\n\n\treturn 1;\n}\n\n \nstatic int is_php_dn(struct device_node *dn, const __be32 **indexes,\n\t\t     const __be32 **names, const __be32 **types,\n\t\t     const __be32 **power_domains)\n{\n\tconst __be32 *drc_types;\n\tint rc;\n\n\trc = get_children_props(dn, indexes, names, &drc_types, power_domains);\n\tif (rc < 0)\n\t\treturn 0;\n\n\tif (!is_php_type((char *) &drc_types[1]))\n\t\treturn 0;\n\n\t*types = drc_types;\n\treturn 1;\n}\n\nstatic int rpaphp_drc_info_add_slot(struct device_node *dn)\n{\n\tstruct slot *slot;\n\tstruct property *info;\n\tstruct of_drc_info drc;\n\tchar drc_name[MAX_DRC_NAME_LEN];\n\tconst __be32 *cur;\n\tu32 count;\n\tint retval = 0;\n\n\tinfo = of_find_property(dn, \"ibm,drc-info\", NULL);\n\tif (!info)\n\t\treturn 0;\n\n\tcur = of_prop_next_u32(info, NULL, &count);\n\tif (cur)\n\t\tcur++;\n\telse\n\t\treturn 0;\n\n\tof_read_drc_info_cell(&info, &cur, &drc);\n\tif (!is_php_type(drc.drc_type))\n\t\treturn 0;\n\n\tsprintf(drc_name, \"%s%d\", drc.drc_name_prefix, drc.drc_name_suffix_start);\n\n\tslot = alloc_slot_struct(dn, drc.drc_index_start, drc_name, drc.drc_power_domain);\n\tif (!slot)\n\t\treturn -ENOMEM;\n\n\tslot->type = simple_strtoul(drc.drc_type, NULL, 10);\n\tretval = rpaphp_enable_slot(slot);\n\tif (!retval)\n\t\tretval = rpaphp_register_slot(slot);\n\n\tif (retval)\n\t\tdealloc_slot_struct(slot);\n\n\treturn retval;\n}\n\nstatic int rpaphp_drc_add_slot(struct device_node *dn)\n{\n\tstruct slot *slot;\n\tint retval = 0;\n\tint i;\n\tconst __be32 *indexes, *names, *types, *power_domains;\n\tchar *name, *type;\n\n\t \n\tif (!is_php_dn(dn, &indexes, &names, &types, &power_domains))\n\t\treturn 0;\n\n\tdbg(\"Entry %s: dn=%pOF\\n\", __func__, dn);\n\n\t \n\tname = (char *) &names[1];\n\ttype = (char *) &types[1];\n\tfor (i = 0; i < be32_to_cpu(indexes[0]); i++) {\n\t\tint index;\n\n\t\tindex = be32_to_cpu(indexes[i + 1]);\n\t\tslot = alloc_slot_struct(dn, index, name,\n\t\t\t\t\t be32_to_cpu(power_domains[i + 1]));\n\t\tif (!slot)\n\t\t\treturn -ENOMEM;\n\n\t\tslot->type = simple_strtoul(type, NULL, 10);\n\n\t\tdbg(\"Found drc-index:0x%x drc-name:%s drc-type:%s\\n\",\n\t\t\t\tindex, name, type);\n\n\t\tretval = rpaphp_enable_slot(slot);\n\t\tif (!retval)\n\t\t\tretval = rpaphp_register_slot(slot);\n\n\t\tif (retval)\n\t\t\tdealloc_slot_struct(slot);\n\n\t\tname += strlen(name) + 1;\n\t\ttype += strlen(type) + 1;\n\t}\n\tdbg(\"%s - Exit: rc[%d]\\n\", __func__, retval);\n\n\t \n\treturn retval;\n}\n\n \nint rpaphp_add_slot(struct device_node *dn)\n{\n\tif (!of_node_name_eq(dn, \"pci\"))\n\t\treturn 0;\n\n\tif (of_property_present(dn, \"ibm,drc-info\"))\n\t\treturn rpaphp_drc_info_add_slot(dn);\n\telse\n\t\treturn rpaphp_drc_add_slot(dn);\n}\nEXPORT_SYMBOL_GPL(rpaphp_add_slot);\n\nstatic void __exit cleanup_slots(void)\n{\n\tstruct slot *slot, *next;\n\n\t \n\n\tlist_for_each_entry_safe(slot, next, &rpaphp_slot_head,\n\t\t\t\t rpaphp_slot_list) {\n\t\tlist_del(&slot->rpaphp_slot_list);\n\t\tpci_hp_deregister(&slot->hotplug_slot);\n\t\tdealloc_slot_struct(slot);\n\t}\n}\n\nstatic int __init rpaphp_init(void)\n{\n\tstruct device_node *dn;\n\n\tinfo(DRIVER_DESC \" version: \" DRIVER_VERSION \"\\n\");\n\n\tfor_each_node_by_name(dn, \"pci\")\n\t\trpaphp_add_slot(dn);\n\n\treturn 0;\n}\n\nstatic void __exit rpaphp_exit(void)\n{\n\tcleanup_slots();\n}\n\nstatic int enable_slot(struct hotplug_slot *hotplug_slot)\n{\n\tstruct slot *slot = to_slot(hotplug_slot);\n\tint state;\n\tint retval;\n\n\tif (slot->state == CONFIGURED)\n\t\treturn 0;\n\n\tretval = rpaphp_get_sensor_state(slot, &state);\n\tif (retval)\n\t\treturn retval;\n\n\tif (state == PRESENT) {\n\t\tpseries_eeh_init_edev_recursive(PCI_DN(slot->dn));\n\n\t\tpci_lock_rescan_remove();\n\t\tpci_hp_add_devices(slot->bus);\n\t\tpci_unlock_rescan_remove();\n\t\tslot->state = CONFIGURED;\n\t} else if (state == EMPTY) {\n\t\tslot->state = EMPTY;\n\t} else {\n\t\terr(\"%s: slot[%s] is in invalid state\\n\", __func__, slot->name);\n\t\tslot->state = NOT_VALID;\n\t\treturn -EINVAL;\n\t}\n\n\tslot->bus->max_bus_speed = get_max_bus_speed(slot);\n\treturn 0;\n}\n\nstatic int disable_slot(struct hotplug_slot *hotplug_slot)\n{\n\tstruct slot *slot = to_slot(hotplug_slot);\n\tif (slot->state == NOT_CONFIGURED)\n\t\treturn -EINVAL;\n\n\tpci_lock_rescan_remove();\n\tpci_hp_remove_devices(slot->bus);\n\tpci_unlock_rescan_remove();\n\tvm_unmap_aliases();\n\n\tslot->state = NOT_CONFIGURED;\n\treturn 0;\n}\n\nconst struct hotplug_slot_ops rpaphp_hotplug_slot_ops = {\n\t.enable_slot = enable_slot,\n\t.disable_slot = disable_slot,\n\t.set_attention_status = set_attention_status,\n\t.get_power_status = get_power_status,\n\t.get_attention_status = get_attention_status,\n\t.get_adapter_status = get_adapter_status,\n};\n\nmodule_init(rpaphp_init);\nmodule_exit(rpaphp_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}