{
  "module_name": "ibmphp_hpc.c",
  "hash_id": "5c81d8d2ed7da2c35af3edfb610a16261917d5a1a6774942e8b228cb5885ed38",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/hotplug/ibmphp_hpc.c",
  "human_readable_source": "\n \n\n#include <linux/wait.h>\n#include <linux/time.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/sched.h>\n#include <linux/kthread.h>\n#include \"ibmphp.h\"\n\nstatic int to_debug = 0;\n#define debug_polling(fmt, arg...)\tdo { if (to_debug) debug(fmt, arg); } while (0)\n\n\n\n\n#define CMD_COMPLETE_TOUT_SEC\t60\t\n#define HPC_CTLR_WORKING_TOUT\t60\t\n#define HPC_GETACCESS_TIMEOUT\t60\t\n#define POLL_INTERVAL_SEC\t2\t\n#define POLL_LATCH_CNT\t\t5\t\n\n\n\n\n#define WPG_I2CMBUFL_OFFSET\t0x08\t\n#define WPG_I2CMOSUP_OFFSET\t0x10\t\n#define WPG_I2CMCNTL_OFFSET\t0x20\t\n#define WPG_I2CPARM_OFFSET\t0x40\t\n#define WPG_I2CSTAT_OFFSET\t0x70\t\n\n\n\n\n#define WPG_I2C_AND\t\t0x1000\t\n#define WPG_I2C_OR\t\t0x2000\t\n\n\n\n\n#define WPG_READATADDR_MASK\t0x00010000\t\n#define WPG_WRITEATADDR_MASK\t0x40010000\t\n#define WPG_READDIRECT_MASK\t0x10010000\n#define WPG_WRITEDIRECT_MASK\t0x60010000\n\n\n\n\n\n#define WPG_I2CMCNTL_STARTOP_MASK\t0x00000002\t\n\n\n\n\n#define WPG_I2C_IOREMAP_SIZE\t0x2044\t\n\n\n\n\n#define WPG_1ST_SLOT_INDEX\t0x01\t\n#define WPG_CTLR_INDEX\t\t0x0F\t\n#define WPG_1ST_EXTSLOT_INDEX\t0x10\t\n#define WPG_1ST_BUS_INDEX\t0x1F\t\n\n\n\n\n\n#define HPC_I2CSTATUS_CHECK(s)\t((u8)((s & 0x00000A76) ? 0 : 1))\n\n\n\n\nstatic DEFINE_MUTEX(sem_hpcaccess);\t\nstatic DEFINE_MUTEX(operations_mutex);\t\n\t\t\t\t\t\nstatic DECLARE_COMPLETION(exit_complete); \nstatic struct task_struct *ibmphp_poll_thread;\n\n\n\nstatic u8 i2c_ctrl_read(struct controller *, void __iomem *, u8);\nstatic u8 i2c_ctrl_write(struct controller *, void __iomem *, u8, u8);\nstatic u8 hpc_writecmdtoindex(u8, u8);\nstatic u8 hpc_readcmdtoindex(u8, u8);\nstatic void get_hpc_access(void);\nstatic void free_hpc_access(void);\nstatic int poll_hpc(void *data);\nstatic int process_changeinstatus(struct slot *, struct slot *);\nstatic int process_changeinlatch(u8, u8, struct controller *);\nstatic int hpc_wait_ctlr_notworking(int, struct controller *, void __iomem *, u8 *);\n\n\n\n \nstatic u8 i2c_ctrl_read(struct controller *ctlr_ptr, void __iomem *WPGBbar, u8 index)\n{\n\tu8 status;\n\tint i;\n\tvoid __iomem *wpg_addr;\t\n\tunsigned long wpg_data;\t\n\tunsigned long ultemp;\n\tunsigned long data;\t\n\n\tdebug_polling(\"%s - Entry WPGBbar[%p] index[%x] \\n\", __func__, WPGBbar, index);\n\n\t\n\t\n\t\n\t\n\tif (ctlr_ptr->ctlr_type == 0x02) {\n\t\tdata = WPG_READATADDR_MASK;\n\t\t\n\t\tultemp = (unsigned long)ctlr_ptr->u.wpeg_ctlr.i2c_addr;\n\t\tultemp = ultemp >> 1;\n\t\tdata |= (ultemp << 8);\n\n\t\t\n\t\tdata |= (unsigned long)index;\n\t} else if (ctlr_ptr->ctlr_type == 0x04) {\n\t\tdata = WPG_READDIRECT_MASK;\n\n\t\t\n\t\tultemp = (unsigned long)index;\n\t\tultemp = ultemp << 8;\n\t\tdata |= ultemp;\n\t} else {\n\t\terr(\"this controller type is not supported \\n\");\n\t\treturn HPC_ERROR;\n\t}\n\n\twpg_data = swab32(data);\t\n\twpg_addr = WPGBbar + WPG_I2CMOSUP_OFFSET;\n\twritel(wpg_data, wpg_addr);\n\n\t\n\t\n\tdata = 0x00000000;\n\twpg_data = swab32(data);\n\twpg_addr = WPGBbar + WPG_I2CMBUFL_OFFSET;\n\twritel(wpg_data, wpg_addr);\n\n\t\n\t\n\t\n\tdata = WPG_I2CMCNTL_STARTOP_MASK;\n\twpg_data = swab32(data);\n\twpg_addr = WPGBbar + WPG_I2CMCNTL_OFFSET + WPG_I2C_OR;\n\twritel(wpg_data, wpg_addr);\n\n\t\n\t\n\ti = CMD_COMPLETE_TOUT_SEC;\n\twhile (i) {\n\t\tmsleep(10);\n\t\twpg_addr = WPGBbar + WPG_I2CMCNTL_OFFSET;\n\t\twpg_data = readl(wpg_addr);\n\t\tdata = swab32(wpg_data);\n\t\tif (!(data & WPG_I2CMCNTL_STARTOP_MASK))\n\t\t\tbreak;\n\t\ti--;\n\t}\n\tif (i == 0) {\n\t\tdebug(\"%s - Error : WPG timeout\\n\", __func__);\n\t\treturn HPC_ERROR;\n\t}\n\t\n\t\n\ti = CMD_COMPLETE_TOUT_SEC;\n\twhile (i) {\n\t\tmsleep(10);\n\t\twpg_addr = WPGBbar + WPG_I2CSTAT_OFFSET;\n\t\twpg_data = readl(wpg_addr);\n\t\tdata = swab32(wpg_data);\n\t\tif (HPC_I2CSTATUS_CHECK(data))\n\t\t\tbreak;\n\t\ti--;\n\t}\n\tif (i == 0) {\n\t\tdebug(\"ctrl_read - Exit Error:I2C timeout\\n\");\n\t\treturn HPC_ERROR;\n\t}\n\n\t\n\t\n\twpg_addr = WPGBbar + WPG_I2CMBUFL_OFFSET;\n\twpg_data = readl(wpg_addr);\n\tdata = swab32(wpg_data);\n\n\tstatus = (u8) data;\n\n\tdebug_polling(\"%s - Exit index[%x] status[%x]\\n\", __func__, index, status);\n\n\treturn (status);\n}\n\n \nstatic u8 i2c_ctrl_write(struct controller *ctlr_ptr, void __iomem *WPGBbar, u8 index, u8 cmd)\n{\n\tu8 rc;\n\tvoid __iomem *wpg_addr;\t\n\tunsigned long wpg_data;\t\n\tunsigned long ultemp;\n\tunsigned long data;\t\n\tint i;\n\n\tdebug_polling(\"%s - Entry WPGBbar[%p] index[%x] cmd[%x]\\n\", __func__, WPGBbar, index, cmd);\n\n\trc = 0;\n\t\n\t\n\t\n\t\n\tdata = 0x00000000;\n\n\tif (ctlr_ptr->ctlr_type == 0x02) {\n\t\tdata = WPG_WRITEATADDR_MASK;\n\t\t\n\t\tultemp = (unsigned long)ctlr_ptr->u.wpeg_ctlr.i2c_addr;\n\t\tultemp = ultemp >> 1;\n\t\tdata |= (ultemp << 8);\n\n\t\t\n\t\tdata |= (unsigned long)index;\n\t} else if (ctlr_ptr->ctlr_type == 0x04) {\n\t\tdata = WPG_WRITEDIRECT_MASK;\n\n\t\t\n\t\tultemp = (unsigned long)index;\n\t\tultemp = ultemp << 8;\n\t\tdata |= ultemp;\n\t} else {\n\t\terr(\"this controller type is not supported \\n\");\n\t\treturn HPC_ERROR;\n\t}\n\n\twpg_data = swab32(data);\t\n\twpg_addr = WPGBbar + WPG_I2CMOSUP_OFFSET;\n\twritel(wpg_data, wpg_addr);\n\n\t\n\t\n\tdata = 0x00000000 | (unsigned long)cmd;\n\twpg_data = swab32(data);\n\twpg_addr = WPGBbar + WPG_I2CMBUFL_OFFSET;\n\twritel(wpg_data, wpg_addr);\n\n\t\n\t\n\t\n\tdata = WPG_I2CMCNTL_STARTOP_MASK;\n\twpg_data = swab32(data);\n\twpg_addr = WPGBbar + WPG_I2CMCNTL_OFFSET + WPG_I2C_OR;\n\twritel(wpg_data, wpg_addr);\n\n\t\n\t\n\ti = CMD_COMPLETE_TOUT_SEC;\n\twhile (i) {\n\t\tmsleep(10);\n\t\twpg_addr = WPGBbar + WPG_I2CMCNTL_OFFSET;\n\t\twpg_data = readl(wpg_addr);\n\t\tdata = swab32(wpg_data);\n\t\tif (!(data & WPG_I2CMCNTL_STARTOP_MASK))\n\t\t\tbreak;\n\t\ti--;\n\t}\n\tif (i == 0) {\n\t\tdebug(\"%s - Exit Error:WPG timeout\\n\", __func__);\n\t\trc = HPC_ERROR;\n\t}\n\n\t\n\t\n\ti = CMD_COMPLETE_TOUT_SEC;\n\twhile (i) {\n\t\tmsleep(10);\n\t\twpg_addr = WPGBbar + WPG_I2CSTAT_OFFSET;\n\t\twpg_data = readl(wpg_addr);\n\t\tdata = swab32(wpg_data);\n\t\tif (HPC_I2CSTATUS_CHECK(data))\n\t\t\tbreak;\n\t\ti--;\n\t}\n\tif (i == 0) {\n\t\tdebug(\"ctrl_read - Error : I2C timeout\\n\");\n\t\trc = HPC_ERROR;\n\t}\n\n\tdebug_polling(\"%s Exit rc[%x]\\n\", __func__, rc);\n\treturn (rc);\n}\n\n\n\n\nstatic u8 isa_ctrl_read(struct controller *ctlr_ptr, u8 offset)\n{\n\tu16 start_address;\n\tu8 data;\n\n\tstart_address = ctlr_ptr->u.isa_ctlr.io_start;\n\tdata = inb(start_address + offset);\n\treturn data;\n}\n\n\n\n\nstatic void isa_ctrl_write(struct controller *ctlr_ptr, u8 offset, u8 data)\n{\n\tu16 start_address;\n\tu16 port_address;\n\n\tstart_address = ctlr_ptr->u.isa_ctlr.io_start;\n\tport_address = start_address + (u16) offset;\n\toutb(data, port_address);\n}\n\nstatic u8 pci_ctrl_read(struct controller *ctrl, u8 offset)\n{\n\tu8 data = 0x00;\n\tdebug(\"inside pci_ctrl_read\\n\");\n\tif (ctrl->ctrl_dev)\n\t\tpci_read_config_byte(ctrl->ctrl_dev, HPC_PCI_OFFSET + offset, &data);\n\treturn data;\n}\n\nstatic u8 pci_ctrl_write(struct controller *ctrl, u8 offset, u8 data)\n{\n\tu8 rc = -ENODEV;\n\tdebug(\"inside pci_ctrl_write\\n\");\n\tif (ctrl->ctrl_dev) {\n\t\tpci_write_config_byte(ctrl->ctrl_dev, HPC_PCI_OFFSET + offset, data);\n\t\trc = 0;\n\t}\n\treturn rc;\n}\n\nstatic u8 ctrl_read(struct controller *ctlr, void __iomem *base, u8 offset)\n{\n\tu8 rc;\n\tswitch (ctlr->ctlr_type) {\n\tcase 0:\n\t\trc = isa_ctrl_read(ctlr, offset);\n\t\tbreak;\n\tcase 1:\n\t\trc = pci_ctrl_read(ctlr, offset);\n\t\tbreak;\n\tcase 2:\n\tcase 4:\n\t\trc = i2c_ctrl_read(ctlr, base, offset);\n\t\tbreak;\n\tdefault:\n\t\treturn -ENODEV;\n\t}\n\treturn rc;\n}\n\nstatic u8 ctrl_write(struct controller *ctlr, void __iomem *base, u8 offset, u8 data)\n{\n\tu8 rc = 0;\n\tswitch (ctlr->ctlr_type) {\n\tcase 0:\n\t\tisa_ctrl_write(ctlr, offset, data);\n\t\tbreak;\n\tcase 1:\n\t\trc = pci_ctrl_write(ctlr, offset, data);\n\t\tbreak;\n\tcase 2:\n\tcase 4:\n\t\trc = i2c_ctrl_write(ctlr, base, offset, data);\n\t\tbreak;\n\tdefault:\n\t\treturn -ENODEV;\n\t}\n\treturn rc;\n}\n \nstatic u8 hpc_writecmdtoindex(u8 cmd, u8 index)\n{\n\tu8 rc;\n\n\tswitch (cmd) {\n\tcase HPC_CTLR_ENABLEIRQ:\t\n\tcase HPC_CTLR_CLEARIRQ:\t\n\tcase HPC_CTLR_RESET:\t\n\tcase HPC_CTLR_IRQSTEER:\t\n\tcase HPC_CTLR_DISABLEIRQ:\t\n\tcase HPC_ALLSLOT_ON:\t\n\tcase HPC_ALLSLOT_OFF:\t\n\t\trc = 0x0F;\n\t\tbreak;\n\n\tcase HPC_SLOT_OFF:\t\n\tcase HPC_SLOT_ON:\t\n\tcase HPC_SLOT_ATTNOFF:\t\n\tcase HPC_SLOT_ATTNON:\t\n\tcase HPC_SLOT_BLINKLED:\t\n\t\trc = index;\n\t\tbreak;\n\n\tcase HPC_BUS_33CONVMODE:\n\tcase HPC_BUS_66CONVMODE:\n\tcase HPC_BUS_66PCIXMODE:\n\tcase HPC_BUS_100PCIXMODE:\n\tcase HPC_BUS_133PCIXMODE:\n\t\trc = index + WPG_1ST_BUS_INDEX - 1;\n\t\tbreak;\n\n\tdefault:\n\t\terr(\"hpc_writecmdtoindex - Error invalid cmd[%x]\\n\", cmd);\n\t\trc = HPC_ERROR;\n\t}\n\n\treturn rc;\n}\n\n \nstatic u8 hpc_readcmdtoindex(u8 cmd, u8 index)\n{\n\tu8 rc;\n\n\tswitch (cmd) {\n\tcase READ_CTLRSTATUS:\n\t\trc = 0x0F;\n\t\tbreak;\n\tcase READ_SLOTSTATUS:\n\tcase READ_ALLSTAT:\n\t\trc = index;\n\t\tbreak;\n\tcase READ_EXTSLOTSTATUS:\n\t\trc = index + WPG_1ST_EXTSLOT_INDEX;\n\t\tbreak;\n\tcase READ_BUSSTATUS:\n\t\trc = index + WPG_1ST_BUS_INDEX - 1;\n\t\tbreak;\n\tcase READ_SLOTLATCHLOWREG:\n\t\trc = 0x28;\n\t\tbreak;\n\tcase READ_REVLEVEL:\n\t\trc = 0x25;\n\t\tbreak;\n\tcase READ_HPCOPTIONS:\n\t\trc = 0x27;\n\t\tbreak;\n\tdefault:\n\t\trc = HPC_ERROR;\n\t}\n\treturn rc;\n}\n\n \nint ibmphp_hpc_readslot(struct slot *pslot, u8 cmd, u8 *pstatus)\n{\n\tvoid __iomem *wpg_bbar = NULL;\n\tstruct controller *ctlr_ptr;\n\tu8 index, status;\n\tint rc = 0;\n\tint busindex;\n\n\tdebug_polling(\"%s - Entry pslot[%p] cmd[%x] pstatus[%p]\\n\", __func__, pslot, cmd, pstatus);\n\n\tif ((pslot == NULL)\n\t    || ((pstatus == NULL) && (cmd != READ_ALLSTAT) && (cmd != READ_BUSSTATUS))) {\n\t\trc = -EINVAL;\n\t\terr(\"%s - Error invalid pointer, rc[%d]\\n\", __func__, rc);\n\t\treturn rc;\n\t}\n\n\tif (cmd == READ_BUSSTATUS) {\n\t\tbusindex = ibmphp_get_bus_index(pslot->bus);\n\t\tif (busindex < 0) {\n\t\t\trc = -EINVAL;\n\t\t\terr(\"%s - Exit Error:invalid bus, rc[%d]\\n\", __func__, rc);\n\t\t\treturn rc;\n\t\t} else\n\t\t\tindex = (u8) busindex;\n\t} else\n\t\tindex = pslot->ctlr_index;\n\n\tindex = hpc_readcmdtoindex(cmd, index);\n\n\tif (index == HPC_ERROR) {\n\t\trc = -EINVAL;\n\t\terr(\"%s - Exit Error:invalid index, rc[%d]\\n\", __func__, rc);\n\t\treturn rc;\n\t}\n\n\tctlr_ptr = pslot->ctrl;\n\n\tget_hpc_access();\n\n\t\n\t\n\t\n\tif ((ctlr_ptr->ctlr_type == 2) || (ctlr_ptr->ctlr_type == 4))\n\t\twpg_bbar = ioremap(ctlr_ptr->u.wpeg_ctlr.wpegbbar, WPG_I2C_IOREMAP_SIZE);\n\n\t\n\t\n\t\n\trc = hpc_wait_ctlr_notworking(HPC_CTLR_WORKING_TOUT, ctlr_ptr, wpg_bbar, &status);\n\tif (!rc) {\n\t\tswitch (cmd) {\n\t\tcase READ_ALLSTAT:\n\t\t\t\n\t\t\tpslot->ctrl->status = status;\n\t\t\tpslot->status = ctrl_read(ctlr_ptr, wpg_bbar, index);\n\t\t\trc = hpc_wait_ctlr_notworking(HPC_CTLR_WORKING_TOUT, ctlr_ptr, wpg_bbar,\n\t\t\t\t\t\t       &status);\n\t\t\tif (!rc)\n\t\t\t\tpslot->ext_status = ctrl_read(ctlr_ptr, wpg_bbar, index + WPG_1ST_EXTSLOT_INDEX);\n\n\t\t\tbreak;\n\n\t\tcase READ_SLOTSTATUS:\n\t\t\t\n\t\t\t*pstatus = ctrl_read(ctlr_ptr, wpg_bbar, index);\n\t\t\tbreak;\n\n\t\tcase READ_EXTSLOTSTATUS:\n\t\t\t\n\t\t\t*pstatus = ctrl_read(ctlr_ptr, wpg_bbar, index);\n\t\t\tbreak;\n\n\t\tcase READ_CTLRSTATUS:\n\t\t\t\n\t\t\t*pstatus = status;\n\t\t\tbreak;\n\n\t\tcase READ_BUSSTATUS:\n\t\t\tpslot->busstatus = ctrl_read(ctlr_ptr, wpg_bbar, index);\n\t\t\tbreak;\n\t\tcase READ_REVLEVEL:\n\t\t\t*pstatus = ctrl_read(ctlr_ptr, wpg_bbar, index);\n\t\t\tbreak;\n\t\tcase READ_HPCOPTIONS:\n\t\t\t*pstatus = ctrl_read(ctlr_ptr, wpg_bbar, index);\n\t\t\tbreak;\n\t\tcase READ_SLOTLATCHLOWREG:\n\t\t\t\n\t\t\t*pstatus = ctrl_read(ctlr_ptr, wpg_bbar, index);\n\t\t\tbreak;\n\n\t\t\t\n\t\tcase READ_ALLSLOT:\n\t\t\tlist_for_each_entry(pslot, &ibmphp_slot_head,\n\t\t\t\t\t    ibm_slot_list) {\n\t\t\t\tindex = pslot->ctlr_index;\n\t\t\t\trc = hpc_wait_ctlr_notworking(HPC_CTLR_WORKING_TOUT, ctlr_ptr,\n\t\t\t\t\t\t\t\twpg_bbar, &status);\n\t\t\t\tif (!rc) {\n\t\t\t\t\tpslot->status = ctrl_read(ctlr_ptr, wpg_bbar, index);\n\t\t\t\t\trc = hpc_wait_ctlr_notworking(HPC_CTLR_WORKING_TOUT,\n\t\t\t\t\t\t\t\t\tctlr_ptr, wpg_bbar, &status);\n\t\t\t\t\tif (!rc)\n\t\t\t\t\t\tpslot->ext_status =\n\t\t\t\t\t\t    ctrl_read(ctlr_ptr, wpg_bbar,\n\t\t\t\t\t\t\t\tindex + WPG_1ST_EXTSLOT_INDEX);\n\t\t\t\t} else {\n\t\t\t\t\terr(\"%s - Error ctrl_read failed\\n\", __func__);\n\t\t\t\t\trc = -EINVAL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\trc = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\t\n\t\n\n\t\n\tif ((ctlr_ptr->ctlr_type == 2) || (ctlr_ptr->ctlr_type == 4))\n\t\tiounmap(wpg_bbar);\n\n\tfree_hpc_access();\n\n\tdebug_polling(\"%s - Exit rc[%d]\\n\", __func__, rc);\n\treturn rc;\n}\n\n \nint ibmphp_hpc_writeslot(struct slot *pslot, u8 cmd)\n{\n\tvoid __iomem *wpg_bbar = NULL;\n\tstruct controller *ctlr_ptr;\n\tu8 index, status;\n\tint busindex;\n\tu8 done;\n\tint rc = 0;\n\tint timeout;\n\n\tdebug_polling(\"%s - Entry pslot[%p] cmd[%x]\\n\", __func__, pslot, cmd);\n\tif (pslot == NULL) {\n\t\trc = -EINVAL;\n\t\terr(\"%s - Error Exit rc[%d]\\n\", __func__, rc);\n\t\treturn rc;\n\t}\n\n\tif ((cmd == HPC_BUS_33CONVMODE) || (cmd == HPC_BUS_66CONVMODE) ||\n\t\t(cmd == HPC_BUS_66PCIXMODE) || (cmd == HPC_BUS_100PCIXMODE) ||\n\t\t(cmd == HPC_BUS_133PCIXMODE)) {\n\t\tbusindex = ibmphp_get_bus_index(pslot->bus);\n\t\tif (busindex < 0) {\n\t\t\trc = -EINVAL;\n\t\t\terr(\"%s - Exit Error:invalid bus, rc[%d]\\n\", __func__, rc);\n\t\t\treturn rc;\n\t\t} else\n\t\t\tindex = (u8) busindex;\n\t} else\n\t\tindex = pslot->ctlr_index;\n\n\tindex = hpc_writecmdtoindex(cmd, index);\n\n\tif (index == HPC_ERROR) {\n\t\trc = -EINVAL;\n\t\terr(\"%s - Error Exit rc[%d]\\n\", __func__, rc);\n\t\treturn rc;\n\t}\n\n\tctlr_ptr = pslot->ctrl;\n\n\tget_hpc_access();\n\n\t\n\t\n\t\n\tif ((ctlr_ptr->ctlr_type == 2) || (ctlr_ptr->ctlr_type == 4)) {\n\t\twpg_bbar = ioremap(ctlr_ptr->u.wpeg_ctlr.wpegbbar, WPG_I2C_IOREMAP_SIZE);\n\n\t\tdebug(\"%s - ctlr id[%x] physical[%lx] logical[%lx] i2c[%x]\\n\", __func__,\n\t\tctlr_ptr->ctlr_id, (ulong) (ctlr_ptr->u.wpeg_ctlr.wpegbbar), (ulong) wpg_bbar,\n\t\tctlr_ptr->u.wpeg_ctlr.i2c_addr);\n\t}\n\t\n\t\n\t\n\trc = hpc_wait_ctlr_notworking(HPC_CTLR_WORKING_TOUT, ctlr_ptr, wpg_bbar, &status);\n\tif (!rc) {\n\n\t\tctrl_write(ctlr_ptr, wpg_bbar, index, cmd);\n\n\t\t\n\t\t\n\t\t\n\t\ttimeout = CMD_COMPLETE_TOUT_SEC;\n\t\tdone = 0;\n\t\twhile (!done) {\n\t\t\trc = hpc_wait_ctlr_notworking(HPC_CTLR_WORKING_TOUT, ctlr_ptr, wpg_bbar,\n\t\t\t\t\t\t\t&status);\n\t\t\tif (!rc) {\n\t\t\t\tif (NEEDTOCHECK_CMDSTATUS(cmd)) {\n\t\t\t\t\tif (CTLR_FINISHED(status) == HPC_CTLR_FINISHED_YES)\n\t\t\t\t\t\tdone = 1;\n\t\t\t\t} else\n\t\t\t\t\tdone = 1;\n\t\t\t}\n\t\t\tif (!done) {\n\t\t\t\tmsleep(1000);\n\t\t\t\tif (timeout < 1) {\n\t\t\t\t\tdone = 1;\n\t\t\t\t\terr(\"%s - Error command complete timeout\\n\", __func__);\n\t\t\t\t\trc = -EFAULT;\n\t\t\t\t} else\n\t\t\t\t\ttimeout--;\n\t\t\t}\n\t\t}\n\t\tctlr_ptr->status = status;\n\t}\n\t\n\n\t\n\tif ((ctlr_ptr->ctlr_type == 2) || (ctlr_ptr->ctlr_type == 4))\n\t\tiounmap(wpg_bbar);\n\tfree_hpc_access();\n\n\tdebug_polling(\"%s - Exit rc[%d]\\n\", __func__, rc);\n\treturn rc;\n}\n\n \nstatic void get_hpc_access(void)\n{\n\tmutex_lock(&sem_hpcaccess);\n}\n\n \nvoid free_hpc_access(void)\n{\n\tmutex_unlock(&sem_hpcaccess);\n}\n\n \nvoid ibmphp_lock_operations(void)\n{\n\tmutex_lock(&operations_mutex);\n\tto_debug = 1;\n}\n\n \nvoid ibmphp_unlock_operations(void)\n{\n\tdebug(\"%s - Entry\\n\", __func__);\n\tmutex_unlock(&operations_mutex);\n\tto_debug = 0;\n\tdebug(\"%s - Exit\\n\", __func__);\n}\n\n \n#define POLL_LATCH_REGISTER\t0\n#define POLL_SLOTS\t\t1\n#define POLL_SLEEP\t\t2\nstatic int poll_hpc(void *data)\n{\n\tstruct slot myslot;\n\tstruct slot *pslot = NULL;\n\tint rc;\n\tint poll_state = POLL_LATCH_REGISTER;\n\tu8 oldlatchlow = 0x00;\n\tu8 curlatchlow = 0x00;\n\tint poll_count = 0;\n\tu8 ctrl_count = 0x00;\n\n\tdebug(\"%s - Entry\\n\", __func__);\n\n\twhile (!kthread_should_stop()) {\n\t\t \n\t\tmutex_lock(&operations_mutex);\n\n\t\tswitch (poll_state) {\n\t\tcase POLL_LATCH_REGISTER:\n\t\t\toldlatchlow = curlatchlow;\n\t\t\tctrl_count = 0x00;\n\t\t\tlist_for_each_entry(pslot, &ibmphp_slot_head,\n\t\t\t\t\t    ibm_slot_list) {\n\t\t\t\tif (ctrl_count >= ibmphp_get_total_controllers())\n\t\t\t\t\tbreak;\n\t\t\t\tif (pslot->ctrl->ctlr_relative_id == ctrl_count) {\n\t\t\t\t\tctrl_count++;\n\t\t\t\t\tif (READ_SLOT_LATCH(pslot->ctrl)) {\n\t\t\t\t\t\trc = ibmphp_hpc_readslot(pslot,\n\t\t\t\t\t\t\t\t\t  READ_SLOTLATCHLOWREG,\n\t\t\t\t\t\t\t\t\t  &curlatchlow);\n\t\t\t\t\t\tif (oldlatchlow != curlatchlow)\n\t\t\t\t\t\t\tprocess_changeinlatch(oldlatchlow,\n\t\t\t\t\t\t\t\t\t       curlatchlow,\n\t\t\t\t\t\t\t\t\t       pslot->ctrl);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t++poll_count;\n\t\t\tpoll_state = POLL_SLEEP;\n\t\t\tbreak;\n\t\tcase POLL_SLOTS:\n\t\t\tlist_for_each_entry(pslot, &ibmphp_slot_head,\n\t\t\t\t\t    ibm_slot_list) {\n\t\t\t\t\n\t\t\t\tmemcpy((void *) &myslot, (void *) pslot,\n\t\t\t\t\tsizeof(struct slot));\n\t\t\t\trc = ibmphp_hpc_readslot(pslot, READ_ALLSTAT, NULL);\n\t\t\t\tif ((myslot.status != pslot->status)\n\t\t\t\t    || (myslot.ext_status != pslot->ext_status))\n\t\t\t\t\tprocess_changeinstatus(pslot, &myslot);\n\t\t\t}\n\t\t\tctrl_count = 0x00;\n\t\t\tlist_for_each_entry(pslot, &ibmphp_slot_head,\n\t\t\t\t\t    ibm_slot_list) {\n\t\t\t\tif (ctrl_count >= ibmphp_get_total_controllers())\n\t\t\t\t\tbreak;\n\t\t\t\tif (pslot->ctrl->ctlr_relative_id == ctrl_count) {\n\t\t\t\t\tctrl_count++;\n\t\t\t\t\tif (READ_SLOT_LATCH(pslot->ctrl))\n\t\t\t\t\t\trc = ibmphp_hpc_readslot(pslot,\n\t\t\t\t\t\t\t\t\t  READ_SLOTLATCHLOWREG,\n\t\t\t\t\t\t\t\t\t  &curlatchlow);\n\t\t\t\t}\n\t\t\t}\n\t\t\t++poll_count;\n\t\t\tpoll_state = POLL_SLEEP;\n\t\t\tbreak;\n\t\tcase POLL_SLEEP:\n\t\t\t \n\t\t\tmutex_unlock(&operations_mutex);\n\t\t\tmsleep(POLL_INTERVAL_SEC * 1000);\n\n\t\t\tif (kthread_should_stop())\n\t\t\t\tgoto out_sleep;\n\n\t\t\tmutex_lock(&operations_mutex);\n\n\t\t\tif (poll_count >= POLL_LATCH_CNT) {\n\t\t\t\tpoll_count = 0;\n\t\t\t\tpoll_state = POLL_SLOTS;\n\t\t\t} else\n\t\t\t\tpoll_state = POLL_LATCH_REGISTER;\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tmutex_unlock(&operations_mutex);\n\t\t \nout_sleep:\n\t\tmsleep(100);\n\t}\n\tcomplete(&exit_complete);\n\tdebug(\"%s - Exit\\n\", __func__);\n\treturn 0;\n}\n\n\n \nstatic int process_changeinstatus(struct slot *pslot, struct slot *poldslot)\n{\n\tu8 status;\n\tint rc = 0;\n\tu8 disable = 0;\n\tu8 update = 0;\n\n\tdebug(\"process_changeinstatus - Entry pslot[%p], poldslot[%p]\\n\", pslot, poldslot);\n\n\t\n\tif ((pslot->status & 0x01) != (poldslot->status & 0x01))\n\t\tupdate = 1;\n\n\t\n\t\n\n\t\n\tif ((pslot->status & 0x04) != (poldslot->status & 0x04))\n\t\tupdate = 1;\n\n\t\n\t\n\tif (((pslot->status & 0x08) != (poldslot->status & 0x08))\n\t\t|| ((pslot->status & 0x10) != (poldslot->status & 0x10)))\n\t\tupdate = 1;\n\n\t\n\tif ((pslot->status & 0x20) != (poldslot->status & 0x20))\n\t\t\n\t\tif ((poldslot->status & 0x20) && (SLOT_CONNECT(poldslot->status) == HPC_SLOT_CONNECTED) && (SLOT_PRESENT(poldslot->status)))\n\t\t\tdisable = 1;\n\n\t\n\t\n\n\t\n\tif ((pslot->status & 0x80) != (poldslot->status & 0x80)) {\n\t\tupdate = 1;\n\t\t\n\t\tif (pslot->status & 0x80) {\n\t\t\tif (SLOT_PWRGD(pslot->status)) {\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tmsleep(1000);\n\t\t\t\trc = ibmphp_hpc_readslot(pslot, READ_SLOTSTATUS, &status);\n\t\t\t\tif (SLOT_PWRGD(status))\n\t\t\t\t\tupdate = 1;\n\t\t\t\telse\t\n\t\t\t\t\tpslot->status &= ~HPC_SLOT_POWER;\n\t\t\t}\n\t\t}\n\t\t\n\t\telse if ((SLOT_PWRGD(poldslot->status) == HPC_SLOT_PWRGD_GOOD)\n\t\t\t&& (SLOT_CONNECT(poldslot->status) == HPC_SLOT_CONNECTED) && (SLOT_PRESENT(poldslot->status))) {\n\t\t\tdisable = 1;\n\t\t}\n\t\t\n\t}\n\t\n\tif ((pslot->ext_status & 0x08) != (poldslot->ext_status & 0x08))\n\t\tupdate = 1;\n\n\tif (disable) {\n\t\tdebug(\"process_changeinstatus - disable slot\\n\");\n\t\tpslot->flag = 0;\n\t\trc = ibmphp_do_disable_slot(pslot);\n\t}\n\n\tif (update || disable)\n\t\tibmphp_update_slot_info(pslot);\n\n\tdebug(\"%s - Exit rc[%d] disable[%x] update[%x]\\n\", __func__, rc, disable, update);\n\n\treturn rc;\n}\n\n \nstatic int process_changeinlatch(u8 old, u8 new, struct controller *ctrl)\n{\n\tstruct slot myslot, *pslot;\n\tu8 i;\n\tu8 mask;\n\tint rc = 0;\n\n\tdebug(\"%s - Entry old[%x], new[%x]\\n\", __func__, old, new);\n\t\n\n\tfor (i = ctrl->starting_slot_num; i <= ctrl->ending_slot_num; i++) {\n\t\tmask = 0x01 << i;\n\t\tif ((mask & old) != (mask & new)) {\n\t\t\tpslot = ibmphp_get_slot_from_physical_num(i);\n\t\t\tif (pslot) {\n\t\t\t\tmemcpy((void *) &myslot, (void *) pslot, sizeof(struct slot));\n\t\t\t\trc = ibmphp_hpc_readslot(pslot, READ_ALLSTAT, NULL);\n\t\t\t\tdebug(\"%s - call process_changeinstatus for slot[%d]\\n\", __func__, i);\n\t\t\t\tprocess_changeinstatus(pslot, &myslot);\n\t\t\t} else {\n\t\t\t\trc = -EINVAL;\n\t\t\t\terr(\"%s - Error bad pointer for slot[%d]\\n\", __func__, i);\n\t\t\t}\n\t\t}\n\t}\n\tdebug(\"%s - Exit rc[%d]\\n\", __func__, rc);\n\treturn rc;\n}\n\n \nint __init ibmphp_hpc_start_poll_thread(void)\n{\n\tdebug(\"%s - Entry\\n\", __func__);\n\n\tibmphp_poll_thread = kthread_run(poll_hpc, NULL, \"hpc_poll\");\n\tif (IS_ERR(ibmphp_poll_thread)) {\n\t\terr(\"%s - Error, thread not started\\n\", __func__);\n\t\treturn PTR_ERR(ibmphp_poll_thread);\n\t}\n\treturn 0;\n}\n\n \nvoid __exit ibmphp_hpc_stop_poll_thread(void)\n{\n\tdebug(\"%s - Entry\\n\", __func__);\n\n\tkthread_stop(ibmphp_poll_thread);\n\tdebug(\"before locking operations\\n\");\n\tibmphp_lock_operations();\n\tdebug(\"after locking operations\\n\");\n\n\t\n\tdebug(\"before exit_complete down\\n\");\n\twait_for_completion(&exit_complete);\n\tdebug(\"after exit_completion down\\n\");\n\n\t\n\tdebug(\"before free_hpc_access\\n\");\n\tfree_hpc_access();\n\tdebug(\"after free_hpc_access\\n\");\n\tibmphp_unlock_operations();\n\tdebug(\"after unlock operations\\n\");\n\n\tdebug(\"%s - Exit\\n\", __func__);\n}\n\n \nstatic int hpc_wait_ctlr_notworking(int timeout, struct controller *ctlr_ptr, void __iomem *wpg_bbar,\n\t\t\t\t    u8 *pstatus)\n{\n\tint rc = 0;\n\tu8 done = 0;\n\n\tdebug_polling(\"hpc_wait_ctlr_notworking - Entry timeout[%d]\\n\", timeout);\n\n\twhile (!done) {\n\t\t*pstatus = ctrl_read(ctlr_ptr, wpg_bbar, WPG_CTLR_INDEX);\n\t\tif (*pstatus == HPC_ERROR) {\n\t\t\trc = HPC_ERROR;\n\t\t\tdone = 1;\n\t\t}\n\t\tif (CTLR_WORKING(*pstatus) == HPC_CTLR_WORKING_NO)\n\t\t\tdone = 1;\n\t\tif (!done) {\n\t\t\tmsleep(1000);\n\t\t\tif (timeout < 1) {\n\t\t\t\tdone = 1;\n\t\t\t\terr(\"HPCreadslot - Error ctlr timeout\\n\");\n\t\t\t\trc = HPC_ERROR;\n\t\t\t} else\n\t\t\t\ttimeout--;\n\t\t}\n\t}\n\tdebug_polling(\"hpc_wait_ctlr_notworking - Exit rc[%x] status[%x]\\n\", rc, *pstatus);\n\treturn rc;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}