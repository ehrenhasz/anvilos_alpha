{
  "module_name": "cpqphp_pci.c",
  "hash_id": "304a3a0a48d2f72fb04d182fcba5c4109e41d105aad9f69a3b48629d3f4dbb4e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/hotplug/cpqphp_pci.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/pci.h>\n#include <linux/pci_hotplug.h>\n#include \"../pci.h\"\n#include \"cpqphp.h\"\n#include \"cpqphp_nvram.h\"\n\n\nu8 cpqhp_nic_irq;\nu8 cpqhp_disk_irq;\n\nstatic u16 unused_IRQ;\n\n \nstatic void __iomem *detect_HRT_floating_pointer(void __iomem *begin, void __iomem *end)\n{\n\tvoid __iomem *fp;\n\tvoid __iomem *endp;\n\tu8 temp1, temp2, temp3, temp4;\n\tint status = 0;\n\n\tendp = (end - sizeof(struct hrt) + 1);\n\n\tfor (fp = begin; fp <= endp; fp += 16) {\n\t\ttemp1 = readb(fp + SIG0);\n\t\ttemp2 = readb(fp + SIG1);\n\t\ttemp3 = readb(fp + SIG2);\n\t\ttemp4 = readb(fp + SIG3);\n\t\tif (temp1 == '$' &&\n\t\t    temp2 == 'H' &&\n\t\t    temp3 == 'R' &&\n\t\t    temp4 == 'T') {\n\t\t\tstatus = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!status)\n\t\tfp = NULL;\n\n\tdbg(\"Discovered Hotplug Resource Table at %p\\n\", fp);\n\treturn fp;\n}\n\n\nint cpqhp_configure_device(struct controller *ctrl, struct pci_func *func)\n{\n\tstruct pci_bus *child;\n\tint num;\n\n\tpci_lock_rescan_remove();\n\n\tif (func->pci_dev == NULL)\n\t\tfunc->pci_dev = pci_get_domain_bus_and_slot(0, func->bus,\n\t\t\t\t\t\t\tPCI_DEVFN(func->device,\n\t\t\t\t\t\t\tfunc->function));\n\n\t \n\tif (func->pci_dev == NULL) {\n\t\tdbg(\"INFO: pci_dev still null\\n\");\n\n\t\tnum = pci_scan_slot(ctrl->pci_dev->bus, PCI_DEVFN(func->device, func->function));\n\t\tif (num)\n\t\t\tpci_bus_add_devices(ctrl->pci_dev->bus);\n\n\t\tfunc->pci_dev = pci_get_domain_bus_and_slot(0, func->bus,\n\t\t\t\t\t\t\tPCI_DEVFN(func->device,\n\t\t\t\t\t\t\tfunc->function));\n\t\tif (func->pci_dev == NULL) {\n\t\t\tdbg(\"ERROR: pci_dev still null\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (func->pci_dev->hdr_type == PCI_HEADER_TYPE_BRIDGE) {\n\t\tpci_hp_add_bridge(func->pci_dev);\n\t\tchild = func->pci_dev->subordinate;\n\t\tif (child)\n\t\t\tpci_bus_add_devices(child);\n\t}\n\n\tpci_dev_put(func->pci_dev);\n\n out:\n\tpci_unlock_rescan_remove();\n\treturn 0;\n}\n\n\nint cpqhp_unconfigure_device(struct pci_func *func)\n{\n\tint j;\n\n\tdbg(\"%s: bus/dev/func = %x/%x/%x\\n\", __func__, func->bus, func->device, func->function);\n\n\tpci_lock_rescan_remove();\n\tfor (j = 0; j < 8 ; j++) {\n\t\tstruct pci_dev *temp = pci_get_domain_bus_and_slot(0,\n\t\t\t\t\t\t\tfunc->bus,\n\t\t\t\t\t\t\tPCI_DEVFN(func->device,\n\t\t\t\t\t\t\tj));\n\t\tif (temp) {\n\t\t\tpci_dev_put(temp);\n\t\t\tpci_stop_and_remove_bus_device(temp);\n\t\t}\n\t}\n\tpci_unlock_rescan_remove();\n\treturn 0;\n}\n\nstatic int PCI_RefinedAccessConfig(struct pci_bus *bus, unsigned int devfn, u8 offset, u32 *value)\n{\n\tu32 vendID = 0;\n\n\tif (pci_bus_read_config_dword(bus, devfn, PCI_VENDOR_ID, &vendID) == -1)\n\t\treturn -1;\n\tif (vendID == 0xffffffff)\n\t\treturn -1;\n\treturn pci_bus_read_config_dword(bus, devfn, offset, value);\n}\n\n\n \nint cpqhp_set_irq(u8 bus_num, u8 dev_num, u8 int_pin, u8 irq_num)\n{\n\tint rc = 0;\n\n\tif (cpqhp_legacy_mode) {\n\t\tstruct pci_dev *fakedev;\n\t\tstruct pci_bus *fakebus;\n\t\tu16 temp_word;\n\n\t\tfakedev = kmalloc(sizeof(*fakedev), GFP_KERNEL);\n\t\tfakebus = kmalloc(sizeof(*fakebus), GFP_KERNEL);\n\t\tif (!fakedev || !fakebus) {\n\t\t\tkfree(fakedev);\n\t\t\tkfree(fakebus);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tfakedev->devfn = dev_num << 3;\n\t\tfakedev->bus = fakebus;\n\t\tfakebus->number = bus_num;\n\t\tdbg(\"%s: dev %d, bus %d, pin %d, num %d\\n\",\n\t\t    __func__, dev_num, bus_num, int_pin, irq_num);\n\t\trc = pcibios_set_irq_routing(fakedev, int_pin - 1, irq_num);\n\t\tkfree(fakedev);\n\t\tkfree(fakebus);\n\t\tdbg(\"%s: rc %d\\n\", __func__, rc);\n\t\tif (!rc)\n\t\t\treturn !rc;\n\n\t\t \n\t\ttemp_word = inb(0x4d0);\n\t\ttemp_word |= inb(0x4d1) << 8;\n\n\t\ttemp_word |= 0x01 << irq_num;\n\n\t\t \n\t\toutb((u8)(temp_word & 0xFF), 0x4d0);\n\t\toutb((u8)((temp_word & 0xFF00) >> 8), 0x4d1);\n\t\trc = 0;\n\t}\n\n\treturn rc;\n}\n\n\nstatic int PCI_ScanBusForNonBridge(struct controller *ctrl, u8 bus_num, u8 *dev_num)\n{\n\tu16 tdevice;\n\tu32 work;\n\tu8 tbus;\n\n\tctrl->pci_bus->number = bus_num;\n\n\tfor (tdevice = 0; tdevice < 0xFF; tdevice++) {\n\t\t \n\t\tif (PCI_RefinedAccessConfig(ctrl->pci_bus, tdevice, 0x08, &work) == -1)\n\t\t\tcontinue;\n\t\tdbg(\"Looking for nonbridge bus_num %d dev_num %d\\n\", bus_num, tdevice);\n\t\t \n\t\tif ((work >> 8) != PCI_TO_PCI_BRIDGE_CLASS) {\n\t\t\t*dev_num = tdevice;\n\t\t\tdbg(\"found it !\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfor (tdevice = 0; tdevice < 0xFF; tdevice++) {\n\t\t \n\t\tif (PCI_RefinedAccessConfig(ctrl->pci_bus, tdevice, 0x08, &work) == -1)\n\t\t\tcontinue;\n\t\tdbg(\"Looking for bridge bus_num %d dev_num %d\\n\", bus_num, tdevice);\n\t\t \n\t\tif ((work >> 8) == PCI_TO_PCI_BRIDGE_CLASS) {\n\t\t\tpci_bus_read_config_byte(ctrl->pci_bus, PCI_DEVFN(tdevice, 0), PCI_SECONDARY_BUS, &tbus);\n\t\t\t \n\t\t\tdbg(\"Recurse on bus_num %d tdevice %d\\n\", tbus, tdevice);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -1;\n}\n\n\nstatic int PCI_GetBusDevHelper(struct controller *ctrl, u8 *bus_num, u8 *dev_num, u8 slot, u8 nobridge)\n{\n\tint loop, len;\n\tu32 work;\n\tu8 tbus, tdevice, tslot;\n\n\tlen = cpqhp_routing_table_length();\n\tfor (loop = 0; loop < len; ++loop) {\n\t\ttbus = cpqhp_routing_table->slots[loop].bus;\n\t\ttdevice = cpqhp_routing_table->slots[loop].devfn;\n\t\ttslot = cpqhp_routing_table->slots[loop].slot;\n\n\t\tif (tslot == slot) {\n\t\t\t*bus_num = tbus;\n\t\t\t*dev_num = tdevice;\n\t\t\tctrl->pci_bus->number = tbus;\n\t\t\tpci_bus_read_config_dword(ctrl->pci_bus, *dev_num, PCI_VENDOR_ID, &work);\n\t\t\tif (!nobridge || (work == 0xffffffff))\n\t\t\t\treturn 0;\n\n\t\t\tdbg(\"bus_num %d devfn %d\\n\", *bus_num, *dev_num);\n\t\t\tpci_bus_read_config_dword(ctrl->pci_bus, *dev_num, PCI_CLASS_REVISION, &work);\n\t\t\tdbg(\"work >> 8 (%x) = BRIDGE (%x)\\n\", work >> 8, PCI_TO_PCI_BRIDGE_CLASS);\n\n\t\t\tif ((work >> 8) == PCI_TO_PCI_BRIDGE_CLASS) {\n\t\t\t\tpci_bus_read_config_byte(ctrl->pci_bus, *dev_num, PCI_SECONDARY_BUS, &tbus);\n\t\t\t\tdbg(\"Scan bus for Non Bridge: bus %d\\n\", tbus);\n\t\t\t\tif (PCI_ScanBusForNonBridge(ctrl, tbus, dev_num) == 0) {\n\t\t\t\t\t*bus_num = tbus;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -1;\n}\n\n\nint cpqhp_get_bus_dev(struct controller *ctrl, u8 *bus_num, u8 *dev_num, u8 slot)\n{\n\t \n\treturn PCI_GetBusDevHelper(ctrl, bus_num, dev_num, slot, 0);\n}\n\n\n \n\n\n \nint cpqhp_save_config(struct controller *ctrl, int busnumber, int is_hot_plug)\n{\n\tlong rc;\n\tu8 class_code;\n\tu8 header_type;\n\tu32 ID;\n\tu8 secondary_bus;\n\tstruct pci_func *new_slot;\n\tint sub_bus;\n\tint FirstSupported;\n\tint LastSupported;\n\tint max_functions;\n\tint function;\n\tu8 DevError;\n\tint device = 0;\n\tint cloop = 0;\n\tint stop_it;\n\tint index;\n\tu16 devfn;\n\n\t \n\n\tif (is_hot_plug) {\n\t\t \n\t\tFirstSupported = is_hot_plug >> 4;\n\t\tLastSupported = FirstSupported + (is_hot_plug & 0x0F) - 1;\n\t} else {\n\t\tFirstSupported = 0;\n\t\tLastSupported = 0x1F;\n\t}\n\n\t \n\tctrl->pci_bus->number = busnumber;\n\tfor (device = FirstSupported; device <= LastSupported; device++) {\n\t\tID = 0xFFFFFFFF;\n\t\trc = pci_bus_read_config_dword(ctrl->pci_bus, PCI_DEVFN(device, 0), PCI_VENDOR_ID, &ID);\n\n\t\tif (ID == 0xFFFFFFFF) {\n\t\t\tif (is_hot_plug) {\n\t\t\t\t \n\t\t\t\tnew_slot = cpqhp_slot_create(busnumber);\n\t\t\t\tif (new_slot == NULL)\n\t\t\t\t\treturn 1;\n\n\t\t\t\tnew_slot->bus = (u8) busnumber;\n\t\t\t\tnew_slot->device = (u8) device;\n\t\t\t\tnew_slot->function = 0;\n\t\t\t\tnew_slot->is_a_board = 0;\n\t\t\t\tnew_slot->presence_save = 0;\n\t\t\t\tnew_slot->switch_save = 0;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\trc = pci_bus_read_config_byte(ctrl->pci_bus, PCI_DEVFN(device, 0), 0x0B, &class_code);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\trc = pci_bus_read_config_byte(ctrl->pci_bus, PCI_DEVFN(device, 0), PCI_HEADER_TYPE, &header_type);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\t \n\t\tif (header_type & 0x80)\n\t\t\tmax_functions = 8;\n\t\telse\n\t\t\tmax_functions = 1;\n\n\t\tfunction = 0;\n\n\t\tdo {\n\t\t\tDevError = 0;\n\t\t\tif ((header_type & 0x7F) == PCI_HEADER_TYPE_BRIDGE) {\n\t\t\t\t \n\t\t\t\trc = pci_bus_read_config_byte(ctrl->pci_bus, PCI_DEVFN(device, function), PCI_SECONDARY_BUS, &secondary_bus);\n\t\t\t\tif (rc) {\n\t\t\t\t\treturn rc;\n\t\t\t\t} else {\n\t\t\t\t\tsub_bus = (int) secondary_bus;\n\n\t\t\t\t\t \n\t\t\t\t\trc = cpqhp_save_config(ctrl, sub_bus, 0);\n\t\t\t\t\tif (rc)\n\t\t\t\t\t\treturn rc;\n\t\t\t\t\tctrl->pci_bus->number = busnumber;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tindex = 0;\n\t\t\tnew_slot = cpqhp_slot_find(busnumber, device, index++);\n\t\t\twhile (new_slot &&\n\t\t\t       (new_slot->function != (u8) function))\n\t\t\t\tnew_slot = cpqhp_slot_find(busnumber, device, index++);\n\n\t\t\tif (!new_slot) {\n\t\t\t\t \n\t\t\t\tnew_slot = cpqhp_slot_create(busnumber);\n\t\t\t\tif (new_slot == NULL)\n\t\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\tnew_slot->bus = (u8) busnumber;\n\t\t\tnew_slot->device = (u8) device;\n\t\t\tnew_slot->function = (u8) function;\n\t\t\tnew_slot->is_a_board = 1;\n\t\t\tnew_slot->switch_save = 0x10;\n\t\t\t \n\t\t\tnew_slot->status = DevError;\n\t\t\tdevfn = (new_slot->device << 3) | new_slot->function;\n\t\t\tnew_slot->pci_dev = pci_get_domain_bus_and_slot(0,\n\t\t\t\t\t\t\tnew_slot->bus, devfn);\n\n\t\t\tfor (cloop = 0; cloop < 0x20; cloop++) {\n\t\t\t\trc = pci_bus_read_config_dword(ctrl->pci_bus, PCI_DEVFN(device, function), cloop << 2, (u32 *) &(new_slot->config_space[cloop]));\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t}\n\n\t\t\tpci_dev_put(new_slot->pci_dev);\n\n\t\t\tfunction++;\n\n\t\t\tstop_it = 0;\n\n\t\t\t \n\t\t\twhile ((function < max_functions) && (!stop_it)) {\n\t\t\t\trc = pci_bus_read_config_dword(ctrl->pci_bus, PCI_DEVFN(device, function), PCI_VENDOR_ID, &ID);\n\t\t\t\tif (ID == 0xFFFFFFFF) {\n\t\t\t\t\tfunction++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\trc = pci_bus_read_config_byte(ctrl->pci_bus, PCI_DEVFN(device, function), 0x0B, &class_code);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\n\t\t\t\trc = pci_bus_read_config_byte(ctrl->pci_bus, PCI_DEVFN(device, function), PCI_HEADER_TYPE, &header_type);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\n\t\t\t\tstop_it++;\n\t\t\t}\n\n\t\t} while (function < max_functions);\n\t}\t\t\t \n\n\treturn 0;\n}\n\n\n \nint cpqhp_save_slot_config(struct controller *ctrl, struct pci_func *new_slot)\n{\n\tlong rc;\n\tu8 class_code;\n\tu8 header_type;\n\tu32 ID;\n\tu8 secondary_bus;\n\tint sub_bus;\n\tint max_functions;\n\tint function = 0;\n\tint cloop;\n\tint stop_it;\n\n\tID = 0xFFFFFFFF;\n\n\tctrl->pci_bus->number = new_slot->bus;\n\tpci_bus_read_config_dword(ctrl->pci_bus, PCI_DEVFN(new_slot->device, 0), PCI_VENDOR_ID, &ID);\n\n\tif (ID == 0xFFFFFFFF)\n\t\treturn 2;\n\n\tpci_bus_read_config_byte(ctrl->pci_bus, PCI_DEVFN(new_slot->device, 0), 0x0B, &class_code);\n\tpci_bus_read_config_byte(ctrl->pci_bus, PCI_DEVFN(new_slot->device, 0), PCI_HEADER_TYPE, &header_type);\n\n\tif (header_type & 0x80)\t \n\t\tmax_functions = 8;\n\telse\n\t\tmax_functions = 1;\n\n\twhile (function < max_functions) {\n\t\tif ((header_type & 0x7F) == PCI_HEADER_TYPE_BRIDGE) {\n\t\t\t \n\t\t\tpci_bus_read_config_byte(ctrl->pci_bus, PCI_DEVFN(new_slot->device, function), PCI_SECONDARY_BUS, &secondary_bus);\n\n\t\t\tsub_bus = (int) secondary_bus;\n\n\t\t\t \n\t\t\trc = cpqhp_save_config(ctrl, sub_bus, 0);\n\t\t\tif (rc)\n\t\t\t\treturn(rc);\n\t\t\tctrl->pci_bus->number = new_slot->bus;\n\n\t\t}\n\n\t\tnew_slot->status = 0;\n\n\t\tfor (cloop = 0; cloop < 0x20; cloop++)\n\t\t\tpci_bus_read_config_dword(ctrl->pci_bus, PCI_DEVFN(new_slot->device, function), cloop << 2, (u32 *) &(new_slot->config_space[cloop]));\n\n\t\tfunction++;\n\n\t\tstop_it = 0;\n\n\t\t \n\t\twhile ((function < max_functions) && (!stop_it)) {\n\t\t\tpci_bus_read_config_dword(ctrl->pci_bus, PCI_DEVFN(new_slot->device, function), PCI_VENDOR_ID, &ID);\n\n\t\t\tif (ID == 0xFFFFFFFF)\n\t\t\t\tfunction++;\n\t\t\telse {\n\t\t\t\tpci_bus_read_config_byte(ctrl->pci_bus, PCI_DEVFN(new_slot->device, function), 0x0B, &class_code);\n\t\t\t\tpci_bus_read_config_byte(ctrl->pci_bus, PCI_DEVFN(new_slot->device, function), PCI_HEADER_TYPE, &header_type);\n\t\t\t\tstop_it++;\n\t\t\t}\n\t\t}\n\n\t}\n\n\treturn 0;\n}\n\n\n \nint cpqhp_save_base_addr_length(struct controller *ctrl, struct pci_func *func)\n{\n\tu8 cloop;\n\tu8 header_type;\n\tu8 secondary_bus;\n\tu8 type;\n\tint sub_bus;\n\tu32 temp_register;\n\tu32 base;\n\tu32 rc;\n\tstruct pci_func *next;\n\tint index = 0;\n\tstruct pci_bus *pci_bus = ctrl->pci_bus;\n\tunsigned int devfn;\n\n\tfunc = cpqhp_slot_find(func->bus, func->device, index++);\n\n\twhile (func != NULL) {\n\t\tpci_bus->number = func->bus;\n\t\tdevfn = PCI_DEVFN(func->device, func->function);\n\n\t\t \n\t\tpci_bus_read_config_byte(pci_bus, devfn, PCI_HEADER_TYPE, &header_type);\n\n\t\tif ((header_type & 0x7F) == PCI_HEADER_TYPE_BRIDGE) {\n\t\t\tpci_bus_read_config_byte(pci_bus, devfn, PCI_SECONDARY_BUS, &secondary_bus);\n\n\t\t\tsub_bus = (int) secondary_bus;\n\n\t\t\tnext = cpqhp_slot_list[sub_bus];\n\n\t\t\twhile (next != NULL) {\n\t\t\t\trc = cpqhp_save_base_addr_length(ctrl, next);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\n\t\t\t\tnext = next->next;\n\t\t\t}\n\t\t\tpci_bus->number = func->bus;\n\n\t\t\t \n\t\t\tfor (cloop = 0x10; cloop <= 0x14; cloop += 4) {\n\t\t\t\ttemp_register = 0xFFFFFFFF;\n\t\t\t\tpci_bus_write_config_dword(pci_bus, devfn, cloop, temp_register);\n\t\t\t\tpci_bus_read_config_dword(pci_bus, devfn, cloop, &base);\n\t\t\t\t \n\t\t\t\tif (base) {\n\t\t\t\t\tif (base & 0x01L) {\n\t\t\t\t\t\t \n\t\t\t\t\t\tbase = base & 0xFFFFFFFE;\n\t\t\t\t\t\tbase = (~base) + 1;\n\n\t\t\t\t\t\ttype = 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t \n\t\t\t\t\t\tbase = base & 0xFFFFFFF0;\n\t\t\t\t\t\tbase = (~base) + 1;\n\n\t\t\t\t\t\ttype = 0;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tbase = 0x0L;\n\t\t\t\t\ttype = 0;\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tfunc->base_length[(cloop - 0x10) >> 2] =\n\t\t\t\tbase;\n\t\t\t\tfunc->base_type[(cloop - 0x10) >> 2] = type;\n\n\t\t\t}\t \n\n\t\t} else if ((header_type & 0x7F) == 0x00) {\n\t\t\t \n\t\t\tfor (cloop = 0x10; cloop <= 0x24; cloop += 4) {\n\t\t\t\ttemp_register = 0xFFFFFFFF;\n\t\t\t\tpci_bus_write_config_dword(pci_bus, devfn, cloop, temp_register);\n\t\t\t\tpci_bus_read_config_dword(pci_bus, devfn, cloop, &base);\n\n\t\t\t\t \n\t\t\t\tif (base) {\n\t\t\t\t\tif (base & 0x01L) {\n\t\t\t\t\t\t \n\t\t\t\t\t\tbase = base & 0xFFFFFFFE;\n\t\t\t\t\t\tbase = (~base) + 1;\n\n\t\t\t\t\t\ttype = 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t \n\t\t\t\t\t\tbase = base & 0xFFFFFFF0;\n\t\t\t\t\t\tbase = (~base) + 1;\n\n\t\t\t\t\t\ttype = 0;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tbase = 0x0L;\n\t\t\t\t\ttype = 0;\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tfunc->base_length[(cloop - 0x10) >> 2] = base;\n\t\t\t\tfunc->base_type[(cloop - 0x10) >> 2] = type;\n\n\t\t\t}\t \n\n\t\t} else {\t   \n\t\t}\n\n\t\t \n\t\tfunc = cpqhp_slot_find(func->bus, func->device, index++);\n\t}\n\n\treturn(0);\n}\n\n\n \nint cpqhp_save_used_resources(struct controller *ctrl, struct pci_func *func)\n{\n\tu8 cloop;\n\tu8 header_type;\n\tu8 secondary_bus;\n\tu8 temp_byte;\n\tu8 b_base;\n\tu8 b_length;\n\tu16 command;\n\tu16 save_command;\n\tu16 w_base;\n\tu16 w_length;\n\tu32 temp_register;\n\tu32 save_base;\n\tu32 base;\n\tint index = 0;\n\tstruct pci_resource *mem_node;\n\tstruct pci_resource *p_mem_node;\n\tstruct pci_resource *io_node;\n\tstruct pci_resource *bus_node;\n\tstruct pci_bus *pci_bus = ctrl->pci_bus;\n\tunsigned int devfn;\n\n\tfunc = cpqhp_slot_find(func->bus, func->device, index++);\n\n\twhile ((func != NULL) && func->is_a_board) {\n\t\tpci_bus->number = func->bus;\n\t\tdevfn = PCI_DEVFN(func->device, func->function);\n\n\t\t \n\t\tpci_bus_read_config_word(pci_bus, devfn, PCI_COMMAND, &save_command);\n\n\t\t \n\t\tcommand = 0x00;\n\t\tpci_bus_write_config_word(pci_bus, devfn, PCI_COMMAND, command);\n\n\t\t \n\t\tpci_bus_read_config_byte(pci_bus, devfn, PCI_HEADER_TYPE, &header_type);\n\n\t\tif ((header_type & 0x7F) == PCI_HEADER_TYPE_BRIDGE) {\n\t\t\t \n\t\t\tcommand = 0x00;\n\t\t\tpci_bus_write_config_word(pci_bus, devfn, PCI_BRIDGE_CONTROL, command);\n\t\t\tpci_bus_read_config_byte(pci_bus, devfn, PCI_SECONDARY_BUS, &secondary_bus);\n\t\t\tpci_bus_read_config_byte(pci_bus, devfn, PCI_SUBORDINATE_BUS, &temp_byte);\n\n\t\t\tbus_node = kmalloc(sizeof(*bus_node), GFP_KERNEL);\n\t\t\tif (!bus_node)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tbus_node->base = secondary_bus;\n\t\t\tbus_node->length = temp_byte - secondary_bus + 1;\n\n\t\t\tbus_node->next = func->bus_head;\n\t\t\tfunc->bus_head = bus_node;\n\n\t\t\t \n\t\t\tpci_bus_read_config_byte(pci_bus, devfn, PCI_IO_BASE, &b_base);\n\t\t\tpci_bus_read_config_byte(pci_bus, devfn, PCI_IO_LIMIT, &b_length);\n\n\t\t\tif ((b_base <= b_length) && (save_command & 0x01)) {\n\t\t\t\tio_node = kmalloc(sizeof(*io_node), GFP_KERNEL);\n\t\t\t\tif (!io_node)\n\t\t\t\t\treturn -ENOMEM;\n\n\t\t\t\tio_node->base = (b_base & 0xF0) << 8;\n\t\t\t\tio_node->length = (b_length - b_base + 0x10) << 8;\n\n\t\t\t\tio_node->next = func->io_head;\n\t\t\t\tfunc->io_head = io_node;\n\t\t\t}\n\n\t\t\t \n\t\t\tpci_bus_read_config_word(pci_bus, devfn, PCI_MEMORY_BASE, &w_base);\n\t\t\tpci_bus_read_config_word(pci_bus, devfn, PCI_MEMORY_LIMIT, &w_length);\n\n\t\t\tif ((w_base <= w_length) && (save_command & 0x02)) {\n\t\t\t\tmem_node = kmalloc(sizeof(*mem_node), GFP_KERNEL);\n\t\t\t\tif (!mem_node)\n\t\t\t\t\treturn -ENOMEM;\n\n\t\t\t\tmem_node->base = w_base << 16;\n\t\t\t\tmem_node->length = (w_length - w_base + 0x10) << 16;\n\n\t\t\t\tmem_node->next = func->mem_head;\n\t\t\t\tfunc->mem_head = mem_node;\n\t\t\t}\n\n\t\t\t \n\t\t\tpci_bus_read_config_word(pci_bus, devfn, PCI_PREF_MEMORY_BASE, &w_base);\n\t\t\tpci_bus_read_config_word(pci_bus, devfn, PCI_PREF_MEMORY_LIMIT, &w_length);\n\n\t\t\tif ((w_base <= w_length) && (save_command & 0x02)) {\n\t\t\t\tp_mem_node = kmalloc(sizeof(*p_mem_node), GFP_KERNEL);\n\t\t\t\tif (!p_mem_node)\n\t\t\t\t\treturn -ENOMEM;\n\n\t\t\t\tp_mem_node->base = w_base << 16;\n\t\t\t\tp_mem_node->length = (w_length - w_base + 0x10) << 16;\n\n\t\t\t\tp_mem_node->next = func->p_mem_head;\n\t\t\t\tfunc->p_mem_head = p_mem_node;\n\t\t\t}\n\t\t\t \n\t\t\tfor (cloop = 0x10; cloop <= 0x14; cloop += 4) {\n\t\t\t\tpci_bus_read_config_dword(pci_bus, devfn, cloop, &save_base);\n\n\t\t\t\ttemp_register = 0xFFFFFFFF;\n\t\t\t\tpci_bus_write_config_dword(pci_bus, devfn, cloop, temp_register);\n\t\t\t\tpci_bus_read_config_dword(pci_bus, devfn, cloop, &base);\n\n\t\t\t\ttemp_register = base;\n\n\t\t\t\t \n\t\t\t\tif (base) {\n\t\t\t\t\tif (((base & 0x03L) == 0x01)\n\t\t\t\t\t    && (save_command & 0x01)) {\n\t\t\t\t\t\t \n\t\t\t\t\t\ttemp_register = base & 0xFFFFFFFE;\n\t\t\t\t\t\ttemp_register = (~temp_register) + 1;\n\n\t\t\t\t\t\tio_node = kmalloc(sizeof(*io_node),\n\t\t\t\t\t\t\t\tGFP_KERNEL);\n\t\t\t\t\t\tif (!io_node)\n\t\t\t\t\t\t\treturn -ENOMEM;\n\n\t\t\t\t\t\tio_node->base =\n\t\t\t\t\t\tsave_base & (~0x03L);\n\t\t\t\t\t\tio_node->length = temp_register;\n\n\t\t\t\t\t\tio_node->next = func->io_head;\n\t\t\t\t\t\tfunc->io_head = io_node;\n\t\t\t\t\t} else\n\t\t\t\t\t\tif (((base & 0x0BL) == 0x08)\n\t\t\t\t\t\t    && (save_command & 0x02)) {\n\t\t\t\t\t\t \n\t\t\t\t\t\ttemp_register = base & 0xFFFFFFF0;\n\t\t\t\t\t\ttemp_register = (~temp_register) + 1;\n\n\t\t\t\t\t\tp_mem_node = kmalloc(sizeof(*p_mem_node),\n\t\t\t\t\t\t\t\tGFP_KERNEL);\n\t\t\t\t\t\tif (!p_mem_node)\n\t\t\t\t\t\t\treturn -ENOMEM;\n\n\t\t\t\t\t\tp_mem_node->base = save_base & (~0x0FL);\n\t\t\t\t\t\tp_mem_node->length = temp_register;\n\n\t\t\t\t\t\tp_mem_node->next = func->p_mem_head;\n\t\t\t\t\t\tfunc->p_mem_head = p_mem_node;\n\t\t\t\t\t} else\n\t\t\t\t\t\tif (((base & 0x0BL) == 0x00)\n\t\t\t\t\t\t    && (save_command & 0x02)) {\n\t\t\t\t\t\t \n\t\t\t\t\t\ttemp_register = base & 0xFFFFFFF0;\n\t\t\t\t\t\ttemp_register = (~temp_register) + 1;\n\n\t\t\t\t\t\tmem_node = kmalloc(sizeof(*mem_node),\n\t\t\t\t\t\t\t\tGFP_KERNEL);\n\t\t\t\t\t\tif (!mem_node)\n\t\t\t\t\t\t\treturn -ENOMEM;\n\n\t\t\t\t\t\tmem_node->base = save_base & (~0x0FL);\n\t\t\t\t\t\tmem_node->length = temp_register;\n\n\t\t\t\t\t\tmem_node->next = func->mem_head;\n\t\t\t\t\t\tfunc->mem_head = mem_node;\n\t\t\t\t\t} else\n\t\t\t\t\t\treturn(1);\n\t\t\t\t}\n\t\t\t}\t \n\t\t \n\t\t} else if ((header_type & 0x7F) == 0x00) {\n\t\t\t \n\t\t\tfor (cloop = 0x10; cloop <= 0x24; cloop += 4) {\n\t\t\t\tpci_bus_read_config_dword(pci_bus, devfn, cloop, &save_base);\n\n\t\t\t\ttemp_register = 0xFFFFFFFF;\n\t\t\t\tpci_bus_write_config_dword(pci_bus, devfn, cloop, temp_register);\n\t\t\t\tpci_bus_read_config_dword(pci_bus, devfn, cloop, &base);\n\n\t\t\t\ttemp_register = base;\n\n\t\t\t\t \n\t\t\t\tif (base) {\n\t\t\t\t\tif (((base & 0x03L) == 0x01)\n\t\t\t\t\t    && (save_command & 0x01)) {\n\t\t\t\t\t\t \n\t\t\t\t\t\ttemp_register = base & 0xFFFFFFFE;\n\t\t\t\t\t\ttemp_register = (~temp_register) + 1;\n\n\t\t\t\t\t\tio_node = kmalloc(sizeof(*io_node),\n\t\t\t\t\t\t\t\tGFP_KERNEL);\n\t\t\t\t\t\tif (!io_node)\n\t\t\t\t\t\t\treturn -ENOMEM;\n\n\t\t\t\t\t\tio_node->base = save_base & (~0x01L);\n\t\t\t\t\t\tio_node->length = temp_register;\n\n\t\t\t\t\t\tio_node->next = func->io_head;\n\t\t\t\t\t\tfunc->io_head = io_node;\n\t\t\t\t\t} else\n\t\t\t\t\t\tif (((base & 0x0BL) == 0x08)\n\t\t\t\t\t\t    && (save_command & 0x02)) {\n\t\t\t\t\t\t \n\t\t\t\t\t\ttemp_register = base & 0xFFFFFFF0;\n\t\t\t\t\t\ttemp_register = (~temp_register) + 1;\n\n\t\t\t\t\t\tp_mem_node = kmalloc(sizeof(*p_mem_node),\n\t\t\t\t\t\t\t\tGFP_KERNEL);\n\t\t\t\t\t\tif (!p_mem_node)\n\t\t\t\t\t\t\treturn -ENOMEM;\n\n\t\t\t\t\t\tp_mem_node->base = save_base & (~0x0FL);\n\t\t\t\t\t\tp_mem_node->length = temp_register;\n\n\t\t\t\t\t\tp_mem_node->next = func->p_mem_head;\n\t\t\t\t\t\tfunc->p_mem_head = p_mem_node;\n\t\t\t\t\t} else\n\t\t\t\t\t\tif (((base & 0x0BL) == 0x00)\n\t\t\t\t\t\t    && (save_command & 0x02)) {\n\t\t\t\t\t\t \n\t\t\t\t\t\ttemp_register = base & 0xFFFFFFF0;\n\t\t\t\t\t\ttemp_register = (~temp_register) + 1;\n\n\t\t\t\t\t\tmem_node = kmalloc(sizeof(*mem_node),\n\t\t\t\t\t\t\t\tGFP_KERNEL);\n\t\t\t\t\t\tif (!mem_node)\n\t\t\t\t\t\t\treturn -ENOMEM;\n\n\t\t\t\t\t\tmem_node->base = save_base & (~0x0FL);\n\t\t\t\t\t\tmem_node->length = temp_register;\n\n\t\t\t\t\t\tmem_node->next = func->mem_head;\n\t\t\t\t\t\tfunc->mem_head = mem_node;\n\t\t\t\t\t} else\n\t\t\t\t\t\treturn(1);\n\t\t\t\t}\n\t\t\t}\t \n\t\t}\n\n\t\t \n\t\tfunc = cpqhp_slot_find(func->bus, func->device, index++);\n\t}\n\n\treturn 0;\n}\n\n\n \nint cpqhp_configure_board(struct controller *ctrl, struct pci_func *func)\n{\n\tint cloop;\n\tu8 header_type;\n\tu8 secondary_bus;\n\tint sub_bus;\n\tstruct pci_func *next;\n\tu32 temp;\n\tu32 rc;\n\tint index = 0;\n\tstruct pci_bus *pci_bus = ctrl->pci_bus;\n\tunsigned int devfn;\n\n\tfunc = cpqhp_slot_find(func->bus, func->device, index++);\n\n\twhile (func != NULL) {\n\t\tpci_bus->number = func->bus;\n\t\tdevfn = PCI_DEVFN(func->device, func->function);\n\n\t\t \n\t\tfor (cloop = 0x3C; cloop > 0; cloop -= 4)\n\t\t\tpci_bus_write_config_dword(pci_bus, devfn, cloop, func->config_space[cloop >> 2]);\n\n\t\tpci_bus_read_config_byte(pci_bus, devfn, PCI_HEADER_TYPE, &header_type);\n\n\t\t \n\t\tif ((header_type & 0x7F) == PCI_HEADER_TYPE_BRIDGE) {\n\t\t\tpci_bus_read_config_byte(pci_bus, devfn, PCI_SECONDARY_BUS, &secondary_bus);\n\n\t\t\tsub_bus = (int) secondary_bus;\n\n\t\t\tnext = cpqhp_slot_list[sub_bus];\n\n\t\t\twhile (next != NULL) {\n\t\t\t\trc = cpqhp_configure_board(ctrl, next);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\n\t\t\t\tnext = next->next;\n\t\t\t}\n\t\t} else {\n\n\t\t\t \n\n\t\t\tfor (cloop = 16; cloop < 40; cloop += 4) {\n\t\t\t\tpci_bus_read_config_dword(pci_bus, devfn, cloop, &temp);\n\n\t\t\t\tif (temp != func->config_space[cloop >> 2]) {\n\t\t\t\t\tdbg(\"Config space compare failure!!! offset = %x\\n\", cloop);\n\t\t\t\t\tdbg(\"bus = %x, device = %x, function = %x\\n\", func->bus, func->device, func->function);\n\t\t\t\t\tdbg(\"temp = %x, config space = %x\\n\\n\", temp, func->config_space[cloop >> 2]);\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunc->configured = 1;\n\n\t\tfunc = cpqhp_slot_find(func->bus, func->device, index++);\n\t}\n\n\treturn 0;\n}\n\n\n \nint cpqhp_valid_replace(struct controller *ctrl, struct pci_func *func)\n{\n\tu8 cloop;\n\tu8 header_type;\n\tu8 secondary_bus;\n\tu8 type;\n\tu32 temp_register = 0;\n\tu32 base;\n\tu32 rc;\n\tstruct pci_func *next;\n\tint index = 0;\n\tstruct pci_bus *pci_bus = ctrl->pci_bus;\n\tunsigned int devfn;\n\n\tif (!func->is_a_board)\n\t\treturn(ADD_NOT_SUPPORTED);\n\n\tfunc = cpqhp_slot_find(func->bus, func->device, index++);\n\n\twhile (func != NULL) {\n\t\tpci_bus->number = func->bus;\n\t\tdevfn = PCI_DEVFN(func->device, func->function);\n\n\t\tpci_bus_read_config_dword(pci_bus, devfn, PCI_VENDOR_ID, &temp_register);\n\n\t\t \n\t\tif (temp_register == 0xFFFFFFFF)\n\t\t\treturn(NO_ADAPTER_PRESENT);\n\n\t\tif (temp_register != func->config_space[0])\n\t\t\treturn(ADAPTER_NOT_SAME);\n\n\t\t \n\t\tpci_bus_read_config_dword(pci_bus, devfn, PCI_CLASS_REVISION, &temp_register);\n\n\t\t \n\t\tif (temp_register != func->config_space[0x08 >> 2])\n\t\t\treturn(ADAPTER_NOT_SAME);\n\n\t\t \n\t\tpci_bus_read_config_byte(pci_bus, devfn, PCI_HEADER_TYPE, &header_type);\n\n\t\tif ((header_type & 0x7F) == PCI_HEADER_TYPE_BRIDGE) {\n\t\t\t \n\n\t\t\ttemp_register = func->config_space[0x18 >> 2];\n\t\t\tpci_bus_write_config_dword(pci_bus, devfn, PCI_PRIMARY_BUS, temp_register);\n\n\t\t\tsecondary_bus = (temp_register >> 8) & 0xFF;\n\n\t\t\tnext = cpqhp_slot_list[secondary_bus];\n\n\t\t\twhile (next != NULL) {\n\t\t\t\trc = cpqhp_valid_replace(ctrl, next);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\n\t\t\t\tnext = next->next;\n\t\t\t}\n\n\t\t}\n\t\t \n\t\telse if ((header_type & 0x7F) == PCI_HEADER_TYPE_NORMAL) {\n\t\t\t \n\t\t\tpci_bus_read_config_dword(pci_bus, devfn, PCI_SUBSYSTEM_VENDOR_ID, &temp_register);\n\n\t\t\tif (temp_register != func->config_space[0x2C >> 2]) {\n\t\t\t\t \n\t\t\t\tif (!((func->config_space[0] == 0xAE100E11)\n\t\t\t\t      && (temp_register == 0x00L)))\n\t\t\t\t\treturn(ADAPTER_NOT_SAME);\n\t\t\t}\n\t\t\t \n\t\t\tfor (cloop = 0x10; cloop <= 0x24; cloop += 4) {\n\t\t\t\ttemp_register = 0xFFFFFFFF;\n\t\t\t\tpci_bus_write_config_dword(pci_bus, devfn, cloop, temp_register);\n\t\t\t\tpci_bus_read_config_dword(pci_bus, devfn, cloop, &base);\n\n\t\t\t\t \n\t\t\t\tif (base) {\n\t\t\t\t\tif (base & 0x01L) {\n\t\t\t\t\t\t \n\t\t\t\t\t\tbase = base & 0xFFFFFFFE;\n\t\t\t\t\t\tbase = (~base) + 1;\n\n\t\t\t\t\t\ttype = 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t \n\t\t\t\t\t\tbase = base & 0xFFFFFFF0;\n\t\t\t\t\t\tbase = (~base) + 1;\n\n\t\t\t\t\t\ttype = 0;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tbase = 0x0L;\n\t\t\t\t\ttype = 0;\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tif (func->base_length[(cloop - 0x10) >> 2] != base)\n\t\t\t\t\treturn(ADAPTER_NOT_SAME);\n\n\t\t\t\tif (func->base_type[(cloop - 0x10) >> 2] != type)\n\t\t\t\t\treturn(ADAPTER_NOT_SAME);\n\n\t\t\t}\t \n\n\t\t}\t\t \n\t\telse {\n\t\t\t \n\t\t\treturn(DEVICE_TYPE_NOT_SUPPORTED);\n\t\t}\n\n\t\t \n\t\tfunc = cpqhp_slot_find(func->bus, func->device, index++);\n\t}\n\n\n\treturn 0;\n}\n\n\n \nint cpqhp_find_available_resources(struct controller *ctrl, void __iomem *rom_start)\n{\n\tu8 temp;\n\tu8 populated_slot;\n\tu8 bridged_slot;\n\tvoid __iomem *one_slot;\n\tvoid __iomem *rom_resource_table;\n\tstruct pci_func *func = NULL;\n\tint i = 10, index;\n\tu32 temp_dword, rc;\n\tstruct pci_resource *mem_node;\n\tstruct pci_resource *p_mem_node;\n\tstruct pci_resource *io_node;\n\tstruct pci_resource *bus_node;\n\n\trom_resource_table = detect_HRT_floating_pointer(rom_start, rom_start+0xffff);\n\tdbg(\"rom_resource_table = %p\\n\", rom_resource_table);\n\n\tif (rom_resource_table == NULL)\n\t\treturn -ENODEV;\n\n\t \n\tunused_IRQ = readl(rom_resource_table + UNUSED_IRQ);\n\tdbg(\"unused_IRQ = %x\\n\", unused_IRQ);\n\n\ttemp = 0;\n\twhile (unused_IRQ) {\n\t\tif (unused_IRQ & 1) {\n\t\t\tcpqhp_disk_irq = temp;\n\t\t\tbreak;\n\t\t}\n\t\tunused_IRQ = unused_IRQ >> 1;\n\t\ttemp++;\n\t}\n\n\tdbg(\"cpqhp_disk_irq= %d\\n\", cpqhp_disk_irq);\n\tunused_IRQ = unused_IRQ >> 1;\n\ttemp++;\n\n\twhile (unused_IRQ) {\n\t\tif (unused_IRQ & 1) {\n\t\t\tcpqhp_nic_irq = temp;\n\t\t\tbreak;\n\t\t}\n\t\tunused_IRQ = unused_IRQ >> 1;\n\t\ttemp++;\n\t}\n\n\tdbg(\"cpqhp_nic_irq= %d\\n\", cpqhp_nic_irq);\n\tunused_IRQ = readl(rom_resource_table + PCIIRQ);\n\n\ttemp = 0;\n\n\tif (!cpqhp_nic_irq)\n\t\tcpqhp_nic_irq = ctrl->cfgspc_irq;\n\n\tif (!cpqhp_disk_irq)\n\t\tcpqhp_disk_irq = ctrl->cfgspc_irq;\n\n\tdbg(\"cpqhp_disk_irq, cpqhp_nic_irq= %d, %d\\n\", cpqhp_disk_irq, cpqhp_nic_irq);\n\n\trc = compaq_nvram_load(rom_start, ctrl);\n\tif (rc)\n\t\treturn rc;\n\n\tone_slot = rom_resource_table + sizeof(struct hrt);\n\n\ti = readb(rom_resource_table + NUMBER_OF_ENTRIES);\n\tdbg(\"number_of_entries = %d\\n\", i);\n\n\tif (!readb(one_slot + SECONDARY_BUS))\n\t\treturn 1;\n\n\tdbg(\"dev|IO base|length|Mem base|length|Pre base|length|PB SB MB\\n\");\n\n\twhile (i && readb(one_slot + SECONDARY_BUS)) {\n\t\tu8 dev_func = readb(one_slot + DEV_FUNC);\n\t\tu8 primary_bus = readb(one_slot + PRIMARY_BUS);\n\t\tu8 secondary_bus = readb(one_slot + SECONDARY_BUS);\n\t\tu8 max_bus = readb(one_slot + MAX_BUS);\n\t\tu16 io_base = readw(one_slot + IO_BASE);\n\t\tu16 io_length = readw(one_slot + IO_LENGTH);\n\t\tu16 mem_base = readw(one_slot + MEM_BASE);\n\t\tu16 mem_length = readw(one_slot + MEM_LENGTH);\n\t\tu16 pre_mem_base = readw(one_slot + PRE_MEM_BASE);\n\t\tu16 pre_mem_length = readw(one_slot + PRE_MEM_LENGTH);\n\n\t\tdbg(\"%2.2x | %4.4x  | %4.4x | %4.4x   | %4.4x | %4.4x   | %4.4x |%2.2x %2.2x %2.2x\\n\",\n\t\t    dev_func, io_base, io_length, mem_base, mem_length, pre_mem_base, pre_mem_length,\n\t\t    primary_bus, secondary_bus, max_bus);\n\n\t\t \n\t\tif (primary_bus != ctrl->bus) {\n\t\t\ti--;\n\t\t\tone_slot += sizeof(struct slot_rt);\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\tctrl->pci_bus->number = primary_bus;\n\t\tpci_bus_read_config_dword(ctrl->pci_bus, dev_func, PCI_VENDOR_ID, &temp_dword);\n\t\tdbg(\"temp_D_word = %x\\n\", temp_dword);\n\n\t\tif (temp_dword != 0xFFFFFFFF) {\n\t\t\tindex = 0;\n\t\t\tfunc = cpqhp_slot_find(primary_bus, dev_func >> 3, 0);\n\n\t\t\twhile (func && (func->function != (dev_func & 0x07))) {\n\t\t\t\tdbg(\"func = %p (bus, dev, fun) = (%d, %d, %d)\\n\", func, primary_bus, dev_func >> 3, index);\n\t\t\t\tfunc = cpqhp_slot_find(primary_bus, dev_func >> 3, index++);\n\t\t\t}\n\n\t\t\t \n\t\t\tif (!func) {\n\t\t\t\ti--;\n\t\t\t\tone_slot += sizeof(struct slot_rt);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t \n\t\t\tif (secondary_bus != primary_bus)\n\t\t\t\tbridged_slot = 1;\n\t\t\telse\n\t\t\t\tbridged_slot = 0;\n\n\t\t\tpopulated_slot = 1;\n\t\t} else {\n\t\t\tpopulated_slot = 0;\n\t\t\tbridged_slot = 0;\n\t\t}\n\n\n\t\t \n\n\t\ttemp_dword = io_base + io_length;\n\n\t\tif ((io_base) && (temp_dword < 0x10000)) {\n\t\t\tio_node = kmalloc(sizeof(*io_node), GFP_KERNEL);\n\t\t\tif (!io_node)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tio_node->base = io_base;\n\t\t\tio_node->length = io_length;\n\n\t\t\tdbg(\"found io_node(base, length) = %x, %x\\n\",\n\t\t\t\t\tio_node->base, io_node->length);\n\t\t\tdbg(\"populated slot =%d \\n\", populated_slot);\n\t\t\tif (!populated_slot) {\n\t\t\t\tio_node->next = ctrl->io_head;\n\t\t\t\tctrl->io_head = io_node;\n\t\t\t} else {\n\t\t\t\tio_node->next = func->io_head;\n\t\t\t\tfunc->io_head = io_node;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\ttemp_dword = mem_base + mem_length;\n\t\tif ((mem_base) && (temp_dword < 0x10000)) {\n\t\t\tmem_node = kmalloc(sizeof(*mem_node), GFP_KERNEL);\n\t\t\tif (!mem_node)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tmem_node->base = mem_base << 16;\n\n\t\t\tmem_node->length = mem_length << 16;\n\n\t\t\tdbg(\"found mem_node(base, length) = %x, %x\\n\",\n\t\t\t\t\tmem_node->base, mem_node->length);\n\t\t\tdbg(\"populated slot =%d \\n\", populated_slot);\n\t\t\tif (!populated_slot) {\n\t\t\t\tmem_node->next = ctrl->mem_head;\n\t\t\t\tctrl->mem_head = mem_node;\n\t\t\t} else {\n\t\t\t\tmem_node->next = func->mem_head;\n\t\t\t\tfunc->mem_head = mem_node;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\ttemp_dword = pre_mem_base + pre_mem_length;\n\t\tif ((pre_mem_base) && (temp_dword < 0x10000)) {\n\t\t\tp_mem_node = kmalloc(sizeof(*p_mem_node), GFP_KERNEL);\n\t\t\tif (!p_mem_node)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tp_mem_node->base = pre_mem_base << 16;\n\n\t\t\tp_mem_node->length = pre_mem_length << 16;\n\t\t\tdbg(\"found p_mem_node(base, length) = %x, %x\\n\",\n\t\t\t\t\tp_mem_node->base, p_mem_node->length);\n\t\t\tdbg(\"populated slot =%d \\n\", populated_slot);\n\n\t\t\tif (!populated_slot) {\n\t\t\t\tp_mem_node->next = ctrl->p_mem_head;\n\t\t\t\tctrl->p_mem_head = p_mem_node;\n\t\t\t} else {\n\t\t\t\tp_mem_node->next = func->p_mem_head;\n\t\t\t\tfunc->p_mem_head = p_mem_node;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (secondary_bus && (secondary_bus != primary_bus)) {\n\t\t\tbus_node = kmalloc(sizeof(*bus_node), GFP_KERNEL);\n\t\t\tif (!bus_node)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tbus_node->base = secondary_bus;\n\t\t\tbus_node->length = max_bus - secondary_bus + 1;\n\t\t\tdbg(\"found bus_node(base, length) = %x, %x\\n\",\n\t\t\t\t\tbus_node->base, bus_node->length);\n\t\t\tdbg(\"populated slot =%d \\n\", populated_slot);\n\t\t\tif (!populated_slot) {\n\t\t\t\tbus_node->next = ctrl->bus_head;\n\t\t\t\tctrl->bus_head = bus_node;\n\t\t\t} else {\n\t\t\t\tbus_node->next = func->bus_head;\n\t\t\t\tfunc->bus_head = bus_node;\n\t\t\t}\n\t\t}\n\n\t\ti--;\n\t\tone_slot += sizeof(struct slot_rt);\n\t}\n\n\t \n\trc = 1;\n\trc &= cpqhp_resource_sort_and_combine(&(ctrl->mem_head));\n\trc &= cpqhp_resource_sort_and_combine(&(ctrl->p_mem_head));\n\trc &= cpqhp_resource_sort_and_combine(&(ctrl->io_head));\n\trc &= cpqhp_resource_sort_and_combine(&(ctrl->bus_head));\n\n\treturn rc;\n}\n\n\n \nint cpqhp_return_board_resources(struct pci_func *func, struct resource_lists *resources)\n{\n\tint rc = 0;\n\tstruct pci_resource *node;\n\tstruct pci_resource *t_node;\n\tdbg(\"%s\\n\", __func__);\n\n\tif (!func)\n\t\treturn 1;\n\n\tnode = func->io_head;\n\tfunc->io_head = NULL;\n\twhile (node) {\n\t\tt_node = node->next;\n\t\treturn_resource(&(resources->io_head), node);\n\t\tnode = t_node;\n\t}\n\n\tnode = func->mem_head;\n\tfunc->mem_head = NULL;\n\twhile (node) {\n\t\tt_node = node->next;\n\t\treturn_resource(&(resources->mem_head), node);\n\t\tnode = t_node;\n\t}\n\n\tnode = func->p_mem_head;\n\tfunc->p_mem_head = NULL;\n\twhile (node) {\n\t\tt_node = node->next;\n\t\treturn_resource(&(resources->p_mem_head), node);\n\t\tnode = t_node;\n\t}\n\n\tnode = func->bus_head;\n\tfunc->bus_head = NULL;\n\twhile (node) {\n\t\tt_node = node->next;\n\t\treturn_resource(&(resources->bus_head), node);\n\t\tnode = t_node;\n\t}\n\n\trc |= cpqhp_resource_sort_and_combine(&(resources->mem_head));\n\trc |= cpqhp_resource_sort_and_combine(&(resources->p_mem_head));\n\trc |= cpqhp_resource_sort_and_combine(&(resources->io_head));\n\trc |= cpqhp_resource_sort_and_combine(&(resources->bus_head));\n\n\treturn rc;\n}\n\n\n \nvoid cpqhp_destroy_resource_list(struct resource_lists *resources)\n{\n\tstruct pci_resource *res, *tres;\n\n\tres = resources->io_head;\n\tresources->io_head = NULL;\n\n\twhile (res) {\n\t\ttres = res;\n\t\tres = res->next;\n\t\tkfree(tres);\n\t}\n\n\tres = resources->mem_head;\n\tresources->mem_head = NULL;\n\n\twhile (res) {\n\t\ttres = res;\n\t\tres = res->next;\n\t\tkfree(tres);\n\t}\n\n\tres = resources->p_mem_head;\n\tresources->p_mem_head = NULL;\n\n\twhile (res) {\n\t\ttres = res;\n\t\tres = res->next;\n\t\tkfree(tres);\n\t}\n\n\tres = resources->bus_head;\n\tresources->bus_head = NULL;\n\n\twhile (res) {\n\t\ttres = res;\n\t\tres = res->next;\n\t\tkfree(tres);\n\t}\n}\n\n\n \nvoid cpqhp_destroy_board_resources(struct pci_func *func)\n{\n\tstruct pci_resource *res, *tres;\n\n\tres = func->io_head;\n\tfunc->io_head = NULL;\n\n\twhile (res) {\n\t\ttres = res;\n\t\tres = res->next;\n\t\tkfree(tres);\n\t}\n\n\tres = func->mem_head;\n\tfunc->mem_head = NULL;\n\n\twhile (res) {\n\t\ttres = res;\n\t\tres = res->next;\n\t\tkfree(tres);\n\t}\n\n\tres = func->p_mem_head;\n\tfunc->p_mem_head = NULL;\n\n\twhile (res) {\n\t\ttres = res;\n\t\tres = res->next;\n\t\tkfree(tres);\n\t}\n\n\tres = func->bus_head;\n\tfunc->bus_head = NULL;\n\n\twhile (res) {\n\t\ttres = res;\n\t\tres = res->next;\n\t\tkfree(tres);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}