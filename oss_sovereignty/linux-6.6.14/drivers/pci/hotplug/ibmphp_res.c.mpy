{
  "module_name": "ibmphp_res.c",
  "hash_id": "288d812eb3053d097bd1674498fca8735f256d74af8a90bd937b59a7324b9369",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/hotplug/ibmphp_res.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include \"ibmphp.h\"\n\nstatic int flags = 0;\t\t \n\nstatic void update_resources(struct bus_node *bus_cur, int type, int rangeno);\nstatic int once_over(void);\nstatic int remove_ranges(struct bus_node *, struct bus_node *);\nstatic int update_bridge_ranges(struct bus_node **);\nstatic int add_bus_range(int type, struct range_node *, struct bus_node *);\nstatic void fix_resources(struct bus_node *);\nstatic struct bus_node *find_bus_wprev(u8, struct bus_node **, u8);\n\nstatic LIST_HEAD(gbuses);\n\nstatic struct bus_node * __init alloc_error_bus(struct ebda_pci_rsrc *curr, u8 busno, int flag)\n{\n\tstruct bus_node *newbus;\n\n\tif (!(curr) && !(flag)) {\n\t\terr(\"NULL pointer passed\\n\");\n\t\treturn NULL;\n\t}\n\n\tnewbus = kzalloc(sizeof(struct bus_node), GFP_KERNEL);\n\tif (!newbus)\n\t\treturn NULL;\n\n\tif (flag)\n\t\tnewbus->busno = busno;\n\telse\n\t\tnewbus->busno = curr->bus_num;\n\tlist_add_tail(&newbus->bus_list, &gbuses);\n\treturn newbus;\n}\n\nstatic struct resource_node * __init alloc_resources(struct ebda_pci_rsrc *curr)\n{\n\tstruct resource_node *rs;\n\n\tif (!curr) {\n\t\terr(\"NULL passed to allocate\\n\");\n\t\treturn NULL;\n\t}\n\n\trs = kzalloc(sizeof(struct resource_node), GFP_KERNEL);\n\tif (!rs)\n\t\treturn NULL;\n\n\trs->busno = curr->bus_num;\n\trs->devfunc = curr->dev_fun;\n\trs->start = curr->start_addr;\n\trs->end = curr->end_addr;\n\trs->len = curr->end_addr - curr->start_addr + 1;\n\treturn rs;\n}\n\nstatic int __init alloc_bus_range(struct bus_node **new_bus, struct range_node **new_range, struct ebda_pci_rsrc *curr, int flag, u8 first_bus)\n{\n\tstruct bus_node *newbus;\n\tstruct range_node *newrange;\n\tu8 num_ranges = 0;\n\n\tif (first_bus) {\n\t\tnewbus = kzalloc(sizeof(struct bus_node), GFP_KERNEL);\n\t\tif (!newbus)\n\t\t\treturn -ENOMEM;\n\n\t\tnewbus->busno = curr->bus_num;\n\t} else {\n\t\tnewbus = *new_bus;\n\t\tswitch (flag) {\n\t\t\tcase MEM:\n\t\t\t\tnum_ranges = newbus->noMemRanges;\n\t\t\t\tbreak;\n\t\t\tcase PFMEM:\n\t\t\t\tnum_ranges = newbus->noPFMemRanges;\n\t\t\t\tbreak;\n\t\t\tcase IO:\n\t\t\t\tnum_ranges = newbus->noIORanges;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tnewrange = kzalloc(sizeof(struct range_node), GFP_KERNEL);\n\tif (!newrange) {\n\t\tif (first_bus)\n\t\t\tkfree(newbus);\n\t\treturn -ENOMEM;\n\t}\n\tnewrange->start = curr->start_addr;\n\tnewrange->end = curr->end_addr;\n\n\tif (first_bus || (!num_ranges))\n\t\tnewrange->rangeno = 1;\n\telse {\n\t\t \n\t\tadd_bus_range(flag, newrange, newbus);\n\t\tdebug(\"%d resource Primary Bus inserted on bus %x [%x - %x]\\n\", flag, newbus->busno, newrange->start, newrange->end);\n\t}\n\n\tswitch (flag) {\n\t\tcase MEM:\n\t\t\tnewbus->rangeMem = newrange;\n\t\t\tif (first_bus)\n\t\t\t\tnewbus->noMemRanges = 1;\n\t\t\telse {\n\t\t\t\tdebug(\"First Memory Primary on bus %x, [%x - %x]\\n\", newbus->busno, newrange->start, newrange->end);\n\t\t\t\t++newbus->noMemRanges;\n\t\t\t\tfix_resources(newbus);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase IO:\n\t\t\tnewbus->rangeIO = newrange;\n\t\t\tif (first_bus)\n\t\t\t\tnewbus->noIORanges = 1;\n\t\t\telse {\n\t\t\t\tdebug(\"First IO Primary on bus %x, [%x - %x]\\n\", newbus->busno, newrange->start, newrange->end);\n\t\t\t\t++newbus->noIORanges;\n\t\t\t\tfix_resources(newbus);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase PFMEM:\n\t\t\tnewbus->rangePFMem = newrange;\n\t\t\tif (first_bus)\n\t\t\t\tnewbus->noPFMemRanges = 1;\n\t\t\telse {\n\t\t\t\tdebug(\"1st PFMemory Primary on Bus %x [%x - %x]\\n\", newbus->busno, newrange->start, newrange->end);\n\t\t\t\t++newbus->noPFMemRanges;\n\t\t\t\tfix_resources(newbus);\n\t\t\t}\n\n\t\t\tbreak;\n\t}\n\n\t*new_bus = newbus;\n\t*new_range = newrange;\n\treturn 0;\n}\n\n\n \n\n \nint __init ibmphp_rsrc_init(void)\n{\n\tstruct ebda_pci_rsrc *curr;\n\tstruct range_node *newrange = NULL;\n\tstruct bus_node *newbus = NULL;\n\tstruct bus_node *bus_cur;\n\tstruct bus_node *bus_prev;\n\tstruct resource_node *new_io = NULL;\n\tstruct resource_node *new_mem = NULL;\n\tstruct resource_node *new_pfmem = NULL;\n\tint rc;\n\n\tlist_for_each_entry(curr, &ibmphp_ebda_pci_rsrc_head,\n\t\t\t    ebda_pci_rsrc_list) {\n\t\tif (!(curr->rsrc_type & PCIDEVMASK)) {\n\t\t\t \n\t\t\tdebug(\"this is not a PCI DEVICE in rsrc_init, please take care\\n\");\n\t\t\t \n\t\t}\n\n\t\t \n\t\tif (curr->rsrc_type & PRIMARYBUSMASK) {\n\t\t\t \n\t\t\tif ((curr->rsrc_type & RESTYPE) == MMASK) {\n\t\t\t\t \n\t\t\t\tif (list_empty(&gbuses)) {\n\t\t\t\t\trc = alloc_bus_range(&newbus, &newrange, curr, MEM, 1);\n\t\t\t\t\tif (rc)\n\t\t\t\t\t\treturn rc;\n\t\t\t\t\tlist_add_tail(&newbus->bus_list, &gbuses);\n\t\t\t\t\tdebug(\"gbuses = NULL, Memory Primary Bus %x [%x - %x]\\n\", newbus->busno, newrange->start, newrange->end);\n\t\t\t\t} else {\n\t\t\t\t\tbus_cur = find_bus_wprev(curr->bus_num, &bus_prev, 1);\n\t\t\t\t\t \n\t\t\t\t\tif (bus_cur) {\n\t\t\t\t\t\trc = alloc_bus_range(&bus_cur, &newrange, curr, MEM, 0);\n\t\t\t\t\t\tif (rc)\n\t\t\t\t\t\t\treturn rc;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t \n\t\t\t\t\t\trc = alloc_bus_range(&newbus, &newrange, curr, MEM, 1);\n\t\t\t\t\t\tif (rc)\n\t\t\t\t\t\t\treturn rc;\n\n\t\t\t\t\t\tlist_add_tail(&newbus->bus_list, &gbuses);\n\t\t\t\t\t\tdebug(\"New Bus, Memory Primary Bus %x [%x - %x]\\n\", newbus->busno, newrange->start, newrange->end);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if ((curr->rsrc_type & RESTYPE) == PFMASK) {\n\t\t\t\t \n\t\t\t\tif (list_empty(&gbuses)) {\n\t\t\t\t\t \n\t\t\t\t\trc = alloc_bus_range(&newbus, &newrange, curr, PFMEM, 1);\n\t\t\t\t\tif (rc)\n\t\t\t\t\t\treturn rc;\n\t\t\t\t\tlist_add_tail(&newbus->bus_list, &gbuses);\n\t\t\t\t\tdebug(\"gbuses = NULL, PFMemory Primary Bus %x [%x - %x]\\n\", newbus->busno, newrange->start, newrange->end);\n\t\t\t\t} else {\n\t\t\t\t\tbus_cur = find_bus_wprev(curr->bus_num, &bus_prev, 1);\n\t\t\t\t\tif (bus_cur) {\n\t\t\t\t\t\t \n\t\t\t\t\t\trc = alloc_bus_range(&bus_cur, &newrange, curr, PFMEM, 0);\n\t\t\t\t\t\tif (rc)\n\t\t\t\t\t\t\treturn rc;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t \n\t\t\t\t\t\trc = alloc_bus_range(&newbus, &newrange, curr, PFMEM, 1);\n\t\t\t\t\t\tif (rc)\n\t\t\t\t\t\t\treturn rc;\n\t\t\t\t\t\tlist_add_tail(&newbus->bus_list, &gbuses);\n\t\t\t\t\t\tdebug(\"1st Bus, PFMemory Primary Bus %x [%x - %x]\\n\", newbus->busno, newrange->start, newrange->end);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if ((curr->rsrc_type & RESTYPE) == IOMASK) {\n\t\t\t\t \n\t\t\t\tif (list_empty(&gbuses)) {\n\t\t\t\t\t \n\t\t\t\t\trc = alloc_bus_range(&newbus, &newrange, curr, IO, 1);\n\t\t\t\t\tif (rc)\n\t\t\t\t\t\treturn rc;\n\t\t\t\t\tlist_add_tail(&newbus->bus_list, &gbuses);\n\t\t\t\t\tdebug(\"gbuses = NULL, IO Primary Bus %x [%x - %x]\\n\", newbus->busno, newrange->start, newrange->end);\n\t\t\t\t} else {\n\t\t\t\t\tbus_cur = find_bus_wprev(curr->bus_num, &bus_prev, 1);\n\t\t\t\t\tif (bus_cur) {\n\t\t\t\t\t\trc = alloc_bus_range(&bus_cur, &newrange, curr, IO, 0);\n\t\t\t\t\t\tif (rc)\n\t\t\t\t\t\t\treturn rc;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t \n\t\t\t\t\t\trc = alloc_bus_range(&newbus, &newrange, curr, IO, 1);\n\t\t\t\t\t\tif (rc)\n\t\t\t\t\t\t\treturn rc;\n\t\t\t\t\t\tlist_add_tail(&newbus->bus_list, &gbuses);\n\t\t\t\t\t\tdebug(\"1st Bus, IO Primary Bus %x [%x - %x]\\n\", newbus->busno, newrange->start, newrange->end);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\t;\t \n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tif ((curr->rsrc_type & RESTYPE) == MMASK) {\n\t\t\t\t \n\t\t\t\tnew_mem = alloc_resources(curr);\n\t\t\t\tif (!new_mem)\n\t\t\t\t\treturn -ENOMEM;\n\t\t\t\tnew_mem->type = MEM;\n\t\t\t\t \n\t\t\t\tif (ibmphp_add_resource(new_mem) < 0) {\n\t\t\t\t\tnewbus = alloc_error_bus(curr, 0, 0);\n\t\t\t\t\tif (!newbus)\n\t\t\t\t\t\treturn -ENOMEM;\n\t\t\t\t\tnewbus->firstMem = new_mem;\n\t\t\t\t\t++newbus->needMemUpdate;\n\t\t\t\t\tnew_mem->rangeno = -1;\n\t\t\t\t}\n\t\t\t\tdebug(\"Memory resource for device %x, bus %x, [%x - %x]\\n\", new_mem->devfunc, new_mem->busno, new_mem->start, new_mem->end);\n\n\t\t\t} else if ((curr->rsrc_type & RESTYPE) == PFMASK) {\n\t\t\t\t \n\t\t\t\tnew_pfmem = alloc_resources(curr);\n\t\t\t\tif (!new_pfmem)\n\t\t\t\t\treturn -ENOMEM;\n\t\t\t\tnew_pfmem->type = PFMEM;\n\t\t\t\tnew_pfmem->fromMem = 0;\n\t\t\t\tif (ibmphp_add_resource(new_pfmem) < 0) {\n\t\t\t\t\tnewbus = alloc_error_bus(curr, 0, 0);\n\t\t\t\t\tif (!newbus)\n\t\t\t\t\t\treturn -ENOMEM;\n\t\t\t\t\tnewbus->firstPFMem = new_pfmem;\n\t\t\t\t\t++newbus->needPFMemUpdate;\n\t\t\t\t\tnew_pfmem->rangeno = -1;\n\t\t\t\t}\n\n\t\t\t\tdebug(\"PFMemory resource for device %x, bus %x, [%x - %x]\\n\", new_pfmem->devfunc, new_pfmem->busno, new_pfmem->start, new_pfmem->end);\n\t\t\t} else if ((curr->rsrc_type & RESTYPE) == IOMASK) {\n\t\t\t\t \n\t\t\t\tnew_io = alloc_resources(curr);\n\t\t\t\tif (!new_io)\n\t\t\t\t\treturn -ENOMEM;\n\t\t\t\tnew_io->type = IO;\n\n\t\t\t\t \n\t\t\t\tif (ibmphp_add_resource(new_io) < 0) {\n\t\t\t\t\tnewbus = alloc_error_bus(curr, 0, 0);\n\t\t\t\t\tif (!newbus)\n\t\t\t\t\t\treturn -ENOMEM;\n\t\t\t\t\tnewbus->firstIO = new_io;\n\t\t\t\t\t++newbus->needIOUpdate;\n\t\t\t\t\tnew_io->rangeno = -1;\n\t\t\t\t}\n\t\t\t\tdebug(\"IO resource for device %x, bus %x, [%x - %x]\\n\", new_io->devfunc, new_io->busno, new_io->start, new_io->end);\n\t\t\t}\n\t\t}\n\t}\n\n\tlist_for_each_entry(bus_cur, &gbuses, bus_list) {\n\t\t \n\t\trc = update_bridge_ranges(&bus_cur);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\treturn once_over();\t \n}\n\n \nstatic int add_bus_range(int type, struct range_node *range, struct bus_node *bus_cur)\n{\n\tstruct range_node *range_cur = NULL;\n\tstruct range_node *range_prev;\n\tint count = 0, i_init;\n\tint noRanges = 0;\n\n\tswitch (type) {\n\t\tcase MEM:\n\t\t\trange_cur = bus_cur->rangeMem;\n\t\t\tnoRanges = bus_cur->noMemRanges;\n\t\t\tbreak;\n\t\tcase PFMEM:\n\t\t\trange_cur = bus_cur->rangePFMem;\n\t\t\tnoRanges = bus_cur->noPFMemRanges;\n\t\t\tbreak;\n\t\tcase IO:\n\t\t\trange_cur = bus_cur->rangeIO;\n\t\t\tnoRanges = bus_cur->noIORanges;\n\t\t\tbreak;\n\t}\n\n\trange_prev = NULL;\n\twhile (range_cur) {\n\t\tif (range->start < range_cur->start)\n\t\t\tbreak;\n\t\trange_prev = range_cur;\n\t\trange_cur = range_cur->next;\n\t\tcount = count + 1;\n\t}\n\tif (!count) {\n\t\t \n\t\tswitch (type) {\n\t\t\tcase MEM:\n\t\t\t\tbus_cur->rangeMem = range;\n\t\t\t\tbreak;\n\t\t\tcase PFMEM:\n\t\t\t\tbus_cur->rangePFMem = range;\n\t\t\t\tbreak;\n\t\t\tcase IO:\n\t\t\t\tbus_cur->rangeIO = range;\n\t\t\t\tbreak;\n\t\t}\n\t\trange->next = range_cur;\n\t\trange->rangeno = 1;\n\t\ti_init = 0;\n\t} else if (!range_cur) {\n\t\t \n\t\trange->next = NULL;\n\t\trange_prev->next = range;\n\t\trange->rangeno = range_prev->rangeno + 1;\n\t\treturn 0;\n\t} else {\n\t\t \n\t\trange_prev->next = range;\n\t\trange->next = range_cur;\n\t\trange->rangeno = range_cur->rangeno;\n\t\ti_init = range_prev->rangeno;\n\t}\n\n\tfor (count = i_init; count < noRanges; ++count) {\n\t\t++range_cur->rangeno;\n\t\trange_cur = range_cur->next;\n\t}\n\n\tupdate_resources(bus_cur, type, i_init + 1);\n\treturn 0;\n}\n\n \nstatic void update_resources(struct bus_node *bus_cur, int type, int rangeno)\n{\n\tstruct resource_node *res = NULL;\n\tu8 eol = 0;\t \n\n\tswitch (type) {\n\t\tcase MEM:\n\t\t\tif (bus_cur->firstMem)\n\t\t\t\tres = bus_cur->firstMem;\n\t\t\tbreak;\n\t\tcase PFMEM:\n\t\t\tif (bus_cur->firstPFMem)\n\t\t\t\tres = bus_cur->firstPFMem;\n\t\t\tbreak;\n\t\tcase IO:\n\t\t\tif (bus_cur->firstIO)\n\t\t\t\tres = bus_cur->firstIO;\n\t\t\tbreak;\n\t}\n\n\tif (res) {\n\t\twhile (res) {\n\t\t\tif (res->rangeno == rangeno)\n\t\t\t\tbreak;\n\t\t\tif (res->next)\n\t\t\t\tres = res->next;\n\t\t\telse if (res->nextRange)\n\t\t\t\tres = res->nextRange;\n\t\t\telse {\n\t\t\t\teol = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!eol) {\n\t\t\t \n\t\t\twhile (res) {\n\t\t\t\t++res->rangeno;\n\t\t\t\tres = res->next;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void fix_me(struct resource_node *res, struct bus_node *bus_cur, struct range_node *range)\n{\n\tchar *str = \"\";\n\tswitch (res->type) {\n\t\tcase IO:\n\t\t\tstr = \"io\";\n\t\t\tbreak;\n\t\tcase MEM:\n\t\t\tstr = \"mem\";\n\t\t\tbreak;\n\t\tcase PFMEM:\n\t\t\tstr = \"pfmem\";\n\t\t\tbreak;\n\t}\n\n\twhile (res) {\n\t\tif (res->rangeno == -1) {\n\t\t\twhile (range) {\n\t\t\t\tif ((res->start >= range->start) && (res->end <= range->end)) {\n\t\t\t\t\tres->rangeno = range->rangeno;\n\t\t\t\t\tdebug(\"%s->rangeno in fix_resources is %d\\n\", str, res->rangeno);\n\t\t\t\t\tswitch (res->type) {\n\t\t\t\t\t\tcase IO:\n\t\t\t\t\t\t\t--bus_cur->needIOUpdate;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase MEM:\n\t\t\t\t\t\t\t--bus_cur->needMemUpdate;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase PFMEM:\n\t\t\t\t\t\t\t--bus_cur->needPFMemUpdate;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\trange = range->next;\n\t\t\t}\n\t\t}\n\t\tif (res->next)\n\t\t\tres = res->next;\n\t\telse\n\t\t\tres = res->nextRange;\n\t}\n\n}\n\n \nstatic void fix_resources(struct bus_node *bus_cur)\n{\n\tstruct range_node *range;\n\tstruct resource_node *res;\n\n\tdebug(\"%s - bus_cur->busno = %d\\n\", __func__, bus_cur->busno);\n\n\tif (bus_cur->needIOUpdate) {\n\t\tres = bus_cur->firstIO;\n\t\trange = bus_cur->rangeIO;\n\t\tfix_me(res, bus_cur, range);\n\t}\n\tif (bus_cur->needMemUpdate) {\n\t\tres = bus_cur->firstMem;\n\t\trange = bus_cur->rangeMem;\n\t\tfix_me(res, bus_cur, range);\n\t}\n\tif (bus_cur->needPFMemUpdate) {\n\t\tres = bus_cur->firstPFMem;\n\t\trange = bus_cur->rangePFMem;\n\t\tfix_me(res, bus_cur, range);\n\t}\n}\n\n \nint ibmphp_add_resource(struct resource_node *res)\n{\n\tstruct resource_node *res_cur;\n\tstruct resource_node *res_prev;\n\tstruct bus_node *bus_cur;\n\tstruct range_node *range_cur = NULL;\n\tstruct resource_node *res_start = NULL;\n\n\tdebug(\"%s - enter\\n\", __func__);\n\n\tif (!res) {\n\t\terr(\"NULL passed to add\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tbus_cur = find_bus_wprev(res->busno, NULL, 0);\n\n\tif (!bus_cur) {\n\t\t \n\t\tdebug(\"no bus in the system, either pci_dev's wrong or allocation failed\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tswitch (res->type) {\n\t\tcase IO:\n\t\t\trange_cur = bus_cur->rangeIO;\n\t\t\tres_start = bus_cur->firstIO;\n\t\t\tbreak;\n\t\tcase MEM:\n\t\t\trange_cur = bus_cur->rangeMem;\n\t\t\tres_start = bus_cur->firstMem;\n\t\t\tbreak;\n\t\tcase PFMEM:\n\t\t\trange_cur = bus_cur->rangePFMem;\n\t\t\tres_start = bus_cur->firstPFMem;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr(\"cannot read the type of the resource to add... problem\\n\");\n\t\t\treturn -EINVAL;\n\t}\n\twhile (range_cur) {\n\t\tif ((res->start >= range_cur->start) && (res->end <= range_cur->end)) {\n\t\t\tres->rangeno = range_cur->rangeno;\n\t\t\tbreak;\n\t\t}\n\t\trange_cur = range_cur->next;\n\t}\n\n\t \n\n\tif (!range_cur) {\n\t\tswitch (res->type) {\n\t\t\tcase IO:\n\t\t\t\t++bus_cur->needIOUpdate;\n\t\t\t\tbreak;\n\t\t\tcase MEM:\n\t\t\t\t++bus_cur->needMemUpdate;\n\t\t\t\tbreak;\n\t\t\tcase PFMEM:\n\t\t\t\t++bus_cur->needPFMemUpdate;\n\t\t\t\tbreak;\n\t\t}\n\t\tres->rangeno = -1;\n\t}\n\n\tdebug(\"The range is %d\\n\", res->rangeno);\n\tif (!res_start) {\n\t\t \n\t\tswitch (res->type) {\n\t\t\tcase IO:\n\t\t\t\tbus_cur->firstIO = res;\n\t\t\t\tbreak;\n\t\t\tcase MEM:\n\t\t\t\tbus_cur->firstMem = res;\n\t\t\t\tbreak;\n\t\t\tcase PFMEM:\n\t\t\t\tbus_cur->firstPFMem = res;\n\t\t\t\tbreak;\n\t\t}\n\t\tres->next = NULL;\n\t\tres->nextRange = NULL;\n\t} else {\n\t\tres_cur = res_start;\n\t\tres_prev = NULL;\n\n\t\tdebug(\"res_cur->rangeno is %d\\n\", res_cur->rangeno);\n\n\t\twhile (res_cur) {\n\t\t\tif (res_cur->rangeno >= res->rangeno)\n\t\t\t\tbreak;\n\t\t\tres_prev = res_cur;\n\t\t\tif (res_cur->next)\n\t\t\t\tres_cur = res_cur->next;\n\t\t\telse\n\t\t\t\tres_cur = res_cur->nextRange;\n\t\t}\n\n\t\tif (!res_cur) {\n\t\t\t \n\t\t\tdebug(\"i should be here, [%x - %x]\\n\", res->start, res->end);\n\t\t\tres_prev->nextRange = res;\n\t\t\tres->next = NULL;\n\t\t\tres->nextRange = NULL;\n\t\t} else if (res_cur->rangeno == res->rangeno) {\n\t\t\t \n\t\t\twhile (res_cur) {\n\t\t\t\tif (res->start < res_cur->start)\n\t\t\t\t\tbreak;\n\t\t\t\tres_prev = res_cur;\n\t\t\t\tres_cur = res_cur->next;\n\t\t\t}\n\t\t\tif (!res_cur) {\n\t\t\t\t \n\t\t\t\tres_prev->next = res;\n\t\t\t\tres->next = NULL;\n\t\t\t\tres->nextRange = res_prev->nextRange;\n\t\t\t\tres_prev->nextRange = NULL;\n\t\t\t} else if (res->start < res_cur->start) {\n\t\t\t\t \n\t\t\t\tif (!res_prev)\t{\n\t\t\t\t\tswitch (res->type) {\n\t\t\t\t\t\tcase IO:\n\t\t\t\t\t\t\tbus_cur->firstIO = res;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase MEM:\n\t\t\t\t\t\t\tbus_cur->firstMem = res;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase PFMEM:\n\t\t\t\t\t\t\tbus_cur->firstPFMem = res;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else if (res_prev->rangeno == res_cur->rangeno)\n\t\t\t\t\tres_prev->next = res;\n\t\t\t\telse\n\t\t\t\t\tres_prev->nextRange = res;\n\n\t\t\t\tres->next = res_cur;\n\t\t\t\tres->nextRange = NULL;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tif (!res_prev) {\n\t\t\t\t \n\t\t\t\tres->next = NULL;\n\t\t\t\tswitch (res->type) {\n\t\t\t\t\tcase IO:\n\t\t\t\t\t\tres->nextRange = bus_cur->firstIO;\n\t\t\t\t\t\tbus_cur->firstIO = res;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase MEM:\n\t\t\t\t\t\tres->nextRange = bus_cur->firstMem;\n\t\t\t\t\t\tbus_cur->firstMem = res;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase PFMEM:\n\t\t\t\t\t\tres->nextRange = bus_cur->firstPFMem;\n\t\t\t\t\t\tbus_cur->firstPFMem = res;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else if (res_cur->rangeno > res->rangeno) {\n\t\t\t\t \n\t\t\t\tres_prev->nextRange = res;\n\t\t\t\tres->next = NULL;\n\t\t\t\tres->nextRange = res_cur;\n\t\t\t}\n\t\t}\n\t}\n\n\tdebug(\"%s - exit\\n\", __func__);\n\treturn 0;\n}\n\n \nint ibmphp_remove_resource(struct resource_node *res)\n{\n\tstruct bus_node *bus_cur;\n\tstruct resource_node *res_cur = NULL;\n\tstruct resource_node *res_prev;\n\tstruct resource_node *mem_cur;\n\tchar *type = \"\";\n\n\tif (!res)  {\n\t\terr(\"resource to remove is NULL\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tbus_cur = find_bus_wprev(res->busno, NULL, 0);\n\n\tif (!bus_cur) {\n\t\terr(\"cannot find corresponding bus of the io resource to remove  bailing out...\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tswitch (res->type) {\n\t\tcase IO:\n\t\t\tres_cur = bus_cur->firstIO;\n\t\t\ttype = \"io\";\n\t\t\tbreak;\n\t\tcase MEM:\n\t\t\tres_cur = bus_cur->firstMem;\n\t\t\ttype = \"mem\";\n\t\t\tbreak;\n\t\tcase PFMEM:\n\t\t\tres_cur = bus_cur->firstPFMem;\n\t\t\ttype = \"pfmem\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr(\"unknown type for resource to remove\\n\");\n\t\t\treturn -EINVAL;\n\t}\n\tres_prev = NULL;\n\n\twhile (res_cur) {\n\t\tif ((res_cur->start == res->start) && (res_cur->end == res->end))\n\t\t\tbreak;\n\t\tres_prev = res_cur;\n\t\tif (res_cur->next)\n\t\t\tres_cur = res_cur->next;\n\t\telse\n\t\t\tres_cur = res_cur->nextRange;\n\t}\n\n\tif (!res_cur) {\n\t\tif (res->type == PFMEM) {\n\t\t\t \n\t\t\tres_cur = bus_cur->firstPFMemFromMem;\n\t\t\tres_prev = NULL;\n\n\t\t\twhile (res_cur) {\n\t\t\t\tif ((res_cur->start == res->start) && (res_cur->end == res->end)) {\n\t\t\t\t\tmem_cur = bus_cur->firstMem;\n\t\t\t\t\twhile (mem_cur) {\n\t\t\t\t\t\tif ((mem_cur->start == res_cur->start)\n\t\t\t\t\t\t    && (mem_cur->end == res_cur->end))\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tif (mem_cur->next)\n\t\t\t\t\t\t\tmem_cur = mem_cur->next;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tmem_cur = mem_cur->nextRange;\n\t\t\t\t\t}\n\t\t\t\t\tif (!mem_cur) {\n\t\t\t\t\t\terr(\"cannot find corresponding mem node for pfmem...\\n\");\n\t\t\t\t\t\treturn -EINVAL;\n\t\t\t\t\t}\n\n\t\t\t\t\tibmphp_remove_resource(mem_cur);\n\t\t\t\t\tif (!res_prev)\n\t\t\t\t\t\tbus_cur->firstPFMemFromMem = res_cur->next;\n\t\t\t\t\telse\n\t\t\t\t\t\tres_prev->next = res_cur->next;\n\t\t\t\t\tkfree(res_cur);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tres_prev = res_cur;\n\t\t\t\tif (res_cur->next)\n\t\t\t\t\tres_cur = res_cur->next;\n\t\t\t\telse\n\t\t\t\t\tres_cur = res_cur->nextRange;\n\t\t\t}\n\t\t\tif (!res_cur) {\n\t\t\t\terr(\"cannot find pfmem to delete...\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t} else {\n\t\t\terr(\"the %s resource is not in the list to be deleted...\\n\", type);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tif (!res_prev) {\n\t\t \n\t\tif (res_cur->next) {\n\t\t\tswitch (res->type) {\n\t\t\t\tcase IO:\n\t\t\t\t\tbus_cur->firstIO = res_cur->next;\n\t\t\t\t\tbreak;\n\t\t\t\tcase MEM:\n\t\t\t\t\tbus_cur->firstMem = res_cur->next;\n\t\t\t\t\tbreak;\n\t\t\t\tcase PFMEM:\n\t\t\t\t\tbus_cur->firstPFMem = res_cur->next;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (res_cur->nextRange) {\n\t\t\tswitch (res->type) {\n\t\t\t\tcase IO:\n\t\t\t\t\tbus_cur->firstIO = res_cur->nextRange;\n\t\t\t\t\tbreak;\n\t\t\t\tcase MEM:\n\t\t\t\t\tbus_cur->firstMem = res_cur->nextRange;\n\t\t\t\t\tbreak;\n\t\t\t\tcase PFMEM:\n\t\t\t\t\tbus_cur->firstPFMem = res_cur->nextRange;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tswitch (res->type) {\n\t\t\t\tcase IO:\n\t\t\t\t\tbus_cur->firstIO = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\tcase MEM:\n\t\t\t\t\tbus_cur->firstMem = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\tcase PFMEM:\n\t\t\t\t\tbus_cur->firstPFMem = NULL;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tkfree(res_cur);\n\t\treturn 0;\n\t} else {\n\t\tif (res_cur->next) {\n\t\t\tif (res_prev->rangeno == res_cur->rangeno)\n\t\t\t\tres_prev->next = res_cur->next;\n\t\t\telse\n\t\t\t\tres_prev->nextRange = res_cur->next;\n\t\t} else if (res_cur->nextRange) {\n\t\t\tres_prev->next = NULL;\n\t\t\tres_prev->nextRange = res_cur->nextRange;\n\t\t} else {\n\t\t\tres_prev->next = NULL;\n\t\t\tres_prev->nextRange = NULL;\n\t\t}\n\t\tkfree(res_cur);\n\t\treturn 0;\n\t}\n\n\treturn 0;\n}\n\nstatic struct range_node *find_range(struct bus_node *bus_cur, struct resource_node *res)\n{\n\tstruct range_node *range = NULL;\n\n\tswitch (res->type) {\n\t\tcase IO:\n\t\t\trange = bus_cur->rangeIO;\n\t\t\tbreak;\n\t\tcase MEM:\n\t\t\trange = bus_cur->rangeMem;\n\t\t\tbreak;\n\t\tcase PFMEM:\n\t\t\trange = bus_cur->rangePFMem;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr(\"cannot read resource type in find_range\\n\");\n\t}\n\n\twhile (range) {\n\t\tif (res->rangeno == range->rangeno)\n\t\t\tbreak;\n\t\trange = range->next;\n\t}\n\treturn range;\n}\n\n \nint ibmphp_check_resource(struct resource_node *res, u8 bridge)\n{\n\tstruct bus_node *bus_cur;\n\tstruct range_node *range = NULL;\n\tstruct resource_node *res_prev;\n\tstruct resource_node *res_cur = NULL;\n\tu32 len_cur = 0, start_cur = 0, len_tmp = 0;\n\tint noranges = 0;\n\tu32 tmp_start;\t\t \n\tu32 tmp_divide;\n\tu8 flag = 0;\n\n\tif (!res)\n\t\treturn -EINVAL;\n\n\tif (bridge) {\n\t\t \n\t\tif (res->type == IO)\n\t\t\ttmp_divide = IOBRIDGE;\n\t\telse\n\t\t\ttmp_divide = MEMBRIDGE;\n\t} else\n\t\ttmp_divide = res->len;\n\n\tbus_cur = find_bus_wprev(res->busno, NULL, 0);\n\n\tif (!bus_cur) {\n\t\t \n\t\tdebug(\"no bus in the system, either pci_dev's wrong or allocation failed\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdebug(\"%s - enter\\n\", __func__);\n\tdebug(\"bus_cur->busno is %d\\n\", bus_cur->busno);\n\n\t \n\tres->len -= 1;\n\n\tswitch (res->type) {\n\t\tcase IO:\n\t\t\tres_cur = bus_cur->firstIO;\n\t\t\tnoranges = bus_cur->noIORanges;\n\t\t\tbreak;\n\t\tcase MEM:\n\t\t\tres_cur = bus_cur->firstMem;\n\t\t\tnoranges = bus_cur->noMemRanges;\n\t\t\tbreak;\n\t\tcase PFMEM:\n\t\t\tres_cur = bus_cur->firstPFMem;\n\t\t\tnoranges = bus_cur->noPFMemRanges;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr(\"wrong type of resource to check\\n\");\n\t\t\treturn -EINVAL;\n\t}\n\tres_prev = NULL;\n\n\twhile (res_cur) {\n\t\trange = find_range(bus_cur, res_cur);\n\t\tdebug(\"%s - rangeno = %d\\n\", __func__, res_cur->rangeno);\n\n\t\tif (!range) {\n\t\t\terr(\"no range for the device exists... bailing out...\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tif (!res_prev) {\n\t\t\t \n\t\t\tlen_tmp = res_cur->start - 1 - range->start;\n\n\t\t\tif ((res_cur->start != range->start) && (len_tmp >= res->len)) {\n\t\t\t\tdebug(\"len_tmp = %x\\n\", len_tmp);\n\n\t\t\t\tif ((len_tmp < len_cur) || (len_cur == 0)) {\n\n\t\t\t\t\tif ((range->start % tmp_divide) == 0) {\n\t\t\t\t\t\t \n\t\t\t\t\t\tflag = 1;\n\t\t\t\t\t\tlen_cur = len_tmp;\n\t\t\t\t\t\tstart_cur = range->start;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t \n\t\t\t\t\t\ttmp_start = range->start;\n\t\t\t\t\t\tflag = 0;\n\n\t\t\t\t\t\twhile ((len_tmp = res_cur->start - 1 - tmp_start) >= res->len) {\n\t\t\t\t\t\t\tif ((tmp_start % tmp_divide) == 0) {\n\t\t\t\t\t\t\t\tflag = 1;\n\t\t\t\t\t\t\t\tlen_cur = len_tmp;\n\t\t\t\t\t\t\t\tstart_cur = tmp_start;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttmp_start += tmp_divide - tmp_start % tmp_divide;\n\t\t\t\t\t\t\tif (tmp_start >= res_cur->start - 1)\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (flag && len_cur == res->len) {\n\t\t\t\t\t\tdebug(\"but we are not here, right?\\n\");\n\t\t\t\t\t\tres->start = start_cur;\n\t\t\t\t\t\tres->len += 1;  \n\t\t\t\t\t\tres->end = res->start + res->len - 1;\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!res_cur->next) {\n\t\t\t \n\t\t\tlen_tmp = range->end - (res_cur->end + 1);\n\n\t\t\tif ((range->end != res_cur->end) && (len_tmp >= res->len)) {\n\t\t\t\tdebug(\"len_tmp = %x\\n\", len_tmp);\n\t\t\t\tif ((len_tmp < len_cur) || (len_cur == 0)) {\n\n\t\t\t\t\tif (((res_cur->end + 1) % tmp_divide) == 0) {\n\t\t\t\t\t\t \n\t\t\t\t\t\tflag = 1;\n\t\t\t\t\t\tlen_cur = len_tmp;\n\t\t\t\t\t\tstart_cur = res_cur->end + 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t \n\t\t\t\t\t\ttmp_start = res_cur->end + 1;\n\t\t\t\t\t\tflag = 0;\n\n\t\t\t\t\t\twhile ((len_tmp = range->end - tmp_start) >= res->len) {\n\t\t\t\t\t\t\tif ((tmp_start % tmp_divide) == 0) {\n\t\t\t\t\t\t\t\tflag = 1;\n\t\t\t\t\t\t\t\tlen_cur = len_tmp;\n\t\t\t\t\t\t\t\tstart_cur = tmp_start;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttmp_start += tmp_divide - tmp_start % tmp_divide;\n\t\t\t\t\t\t\tif (tmp_start >= range->end)\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (flag && len_cur == res->len) {\n\t\t\t\t\t\tres->start = start_cur;\n\t\t\t\t\t\tres->len += 1;  \n\t\t\t\t\t\tres->end = res->start + res->len - 1;\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (res_prev) {\n\t\t\tif (res_prev->rangeno != res_cur->rangeno) {\n\t\t\t\t \n\t\t\t\tlen_tmp = res_cur->start - 1 - range->start;\n\n\t\t\t\tif ((res_cur->start != range->start) &&\t(len_tmp >= res->len)) {\n\t\t\t\t\tif ((len_tmp < len_cur) || (len_cur == 0)) {\n\t\t\t\t\t\tif ((range->start % tmp_divide) == 0) {\n\t\t\t\t\t\t\t \n\t\t\t\t\t\t\tflag = 1;\n\t\t\t\t\t\t\tlen_cur = len_tmp;\n\t\t\t\t\t\t\tstart_cur = range->start;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t \n\t\t\t\t\t\t\ttmp_start = range->start;\n\t\t\t\t\t\t\tflag = 0;\n\n\t\t\t\t\t\t\twhile ((len_tmp = res_cur->start - 1 - tmp_start) >= res->len) {\n\t\t\t\t\t\t\t\tif ((tmp_start % tmp_divide) == 0) {\n\t\t\t\t\t\t\t\t\tflag = 1;\n\t\t\t\t\t\t\t\t\tlen_cur = len_tmp;\n\t\t\t\t\t\t\t\t\tstart_cur = tmp_start;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\ttmp_start += tmp_divide - tmp_start % tmp_divide;\n\t\t\t\t\t\t\t\tif (tmp_start >= res_cur->start - 1)\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (flag && len_cur == res->len) {\n\t\t\t\t\t\t\tres->start = start_cur;\n\t\t\t\t\t\t\tres->len += 1;  \n\t\t\t\t\t\t\tres->end = res->start + res->len - 1;\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tlen_tmp = res_cur->start - 1 - res_prev->end - 1;\n\n\t\t\t\tif (len_tmp >= res->len) {\n\t\t\t\t\tif ((len_tmp < len_cur) || (len_cur == 0)) {\n\t\t\t\t\t\tif (((res_prev->end + 1) % tmp_divide) == 0) {\n\t\t\t\t\t\t\t \n\t\t\t\t\t\t\tflag = 1;\n\t\t\t\t\t\t\tlen_cur = len_tmp;\n\t\t\t\t\t\t\tstart_cur = res_prev->end + 1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t \n\t\t\t\t\t\t\ttmp_start = res_prev->end + 1;\n\t\t\t\t\t\t\tflag = 0;\n\n\t\t\t\t\t\t\twhile ((len_tmp = res_cur->start - 1 - tmp_start) >= res->len) {\n\t\t\t\t\t\t\t\tif ((tmp_start % tmp_divide) == 0) {\n\t\t\t\t\t\t\t\t\tflag = 1;\n\t\t\t\t\t\t\t\t\tlen_cur = len_tmp;\n\t\t\t\t\t\t\t\t\tstart_cur = tmp_start;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\ttmp_start += tmp_divide - tmp_start % tmp_divide;\n\t\t\t\t\t\t\t\tif (tmp_start >= res_cur->start - 1)\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (flag && len_cur == res->len) {\n\t\t\t\t\t\t\tres->start = start_cur;\n\t\t\t\t\t\t\tres->len += 1;  \n\t\t\t\t\t\t\tres->end = res->start + res->len - 1;\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t \n\t\tres_prev = res_cur;\n\t\tif (res_cur->next)\n\t\t\tres_cur = res_cur->next;\n\t\telse\n\t\t\tres_cur = res_cur->nextRange;\n\t}\t \n\n\n\tif (!res_prev) {\n\t\t \n\t\t \n\t\tswitch (res->type) {\n\t\t\tcase IO:\n\t\t\t\trange = bus_cur->rangeIO;\n\t\t\t\tbreak;\n\t\t\tcase MEM:\n\t\t\t\trange = bus_cur->rangeMem;\n\t\t\t\tbreak;\n\t\t\tcase PFMEM:\n\t\t\t\trange = bus_cur->rangePFMem;\n\t\t\t\tbreak;\n\t\t}\n\t\twhile (range) {\n\t\t\tlen_tmp = range->end - range->start;\n\n\t\t\tif (len_tmp >= res->len) {\n\t\t\t\tif ((len_tmp < len_cur) || (len_cur == 0)) {\n\t\t\t\t\tif ((range->start % tmp_divide) == 0) {\n\t\t\t\t\t\t \n\t\t\t\t\t\tflag = 1;\n\t\t\t\t\t\tlen_cur = len_tmp;\n\t\t\t\t\t\tstart_cur = range->start;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t \n\t\t\t\t\t\ttmp_start = range->start;\n\t\t\t\t\t\tflag = 0;\n\n\t\t\t\t\t\twhile ((len_tmp = range->end - tmp_start) >= res->len) {\n\t\t\t\t\t\t\tif ((tmp_start % tmp_divide) == 0) {\n\t\t\t\t\t\t\t\tflag = 1;\n\t\t\t\t\t\t\t\tlen_cur = len_tmp;\n\t\t\t\t\t\t\t\tstart_cur = tmp_start;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttmp_start += tmp_divide - tmp_start % tmp_divide;\n\t\t\t\t\t\t\tif (tmp_start >= range->end)\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (flag && len_cur == res->len) {\n\t\t\t\t\t\tres->start = start_cur;\n\t\t\t\t\t\tres->len += 1;  \n\t\t\t\t\t\tres->end = res->start + res->len - 1;\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\trange = range->next;\n\t\t}\t\t \n\n\t\tif ((!range) && (len_cur == 0)) {\n\t\t\t \n\t\t\terr(\"no appropriate range.. bailing out...\\n\");\n\t\t\treturn -EINVAL;\n\t\t} else if (len_cur) {\n\t\t\tres->start = start_cur;\n\t\t\tres->len += 1;  \n\t\t\tres->end = res->start + res->len - 1;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (!res_cur) {\n\t\tdebug(\"prev->rangeno = %d, noranges = %d\\n\", res_prev->rangeno, noranges);\n\t\tif (res_prev->rangeno < noranges) {\n\t\t\t \n\t\t\tswitch (res->type) {\n\t\t\t\tcase IO:\n\t\t\t\t\trange = bus_cur->rangeIO;\n\t\t\t\t\tbreak;\n\t\t\t\tcase MEM:\n\t\t\t\t\trange = bus_cur->rangeMem;\n\t\t\t\t\tbreak;\n\t\t\t\tcase PFMEM:\n\t\t\t\t\trange = bus_cur->rangePFMem;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\twhile (range) {\n\t\t\t\tlen_tmp = range->end - range->start;\n\n\t\t\t\tif (len_tmp >= res->len) {\n\t\t\t\t\tif ((len_tmp < len_cur) || (len_cur == 0)) {\n\t\t\t\t\t\tif ((range->start % tmp_divide) == 0) {\n\t\t\t\t\t\t\t \n\t\t\t\t\t\t\tflag = 1;\n\t\t\t\t\t\t\tlen_cur = len_tmp;\n\t\t\t\t\t\t\tstart_cur = range->start;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t \n\t\t\t\t\t\t\ttmp_start = range->start;\n\t\t\t\t\t\t\tflag = 0;\n\n\t\t\t\t\t\t\twhile ((len_tmp = range->end - tmp_start) >= res->len) {\n\t\t\t\t\t\t\t\tif ((tmp_start % tmp_divide) == 0) {\n\t\t\t\t\t\t\t\t\tflag = 1;\n\t\t\t\t\t\t\t\t\tlen_cur = len_tmp;\n\t\t\t\t\t\t\t\t\tstart_cur = tmp_start;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\ttmp_start += tmp_divide - tmp_start % tmp_divide;\n\t\t\t\t\t\t\t\tif (tmp_start >= range->end)\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (flag && len_cur == res->len) {\n\t\t\t\t\t\t\tres->start = start_cur;\n\t\t\t\t\t\t\tres->len += 1;  \n\t\t\t\t\t\t\tres->end = res->start + res->len - 1;\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trange = range->next;\n\t\t\t}\t \n\n\t\t\tif ((!range) && (len_cur == 0)) {\n\t\t\t\t \n\t\t\t\terr(\"no appropriate range.. bailing out...\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t} else if (len_cur) {\n\t\t\t\tres->start = start_cur;\n\t\t\t\tres->len += 1;  \n\t\t\t\tres->end = res->start + res->len - 1;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tif (len_cur) {\n\t\t\t\tres->start = start_cur;\n\t\t\t\tres->len += 1;  \n\t\t\t\tres->end = res->start + res->len - 1;\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\terr(\"no appropriate range.. bailing out...\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t}\t \n\treturn -EINVAL;\n}\n\n \nint ibmphp_remove_bus(struct bus_node *bus, u8 parent_busno)\n{\n\tstruct resource_node *res_cur;\n\tstruct resource_node *res_tmp;\n\tstruct bus_node *prev_bus;\n\tint rc;\n\n\tprev_bus = find_bus_wprev(parent_busno, NULL, 0);\n\n\tif (!prev_bus) {\n\t\tdebug(\"something terribly wrong. Cannot find parent bus to the one to remove\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tdebug(\"In ibmphp_remove_bus... prev_bus->busno is %x\\n\", prev_bus->busno);\n\n\trc = remove_ranges(bus, prev_bus);\n\tif (rc)\n\t\treturn rc;\n\n\tif (bus->firstIO) {\n\t\tres_cur = bus->firstIO;\n\t\twhile (res_cur) {\n\t\t\tres_tmp = res_cur;\n\t\t\tif (res_cur->next)\n\t\t\t\tres_cur = res_cur->next;\n\t\t\telse\n\t\t\t\tres_cur = res_cur->nextRange;\n\t\t\tkfree(res_tmp);\n\t\t\tres_tmp = NULL;\n\t\t}\n\t\tbus->firstIO = NULL;\n\t}\n\tif (bus->firstMem) {\n\t\tres_cur = bus->firstMem;\n\t\twhile (res_cur) {\n\t\t\tres_tmp = res_cur;\n\t\t\tif (res_cur->next)\n\t\t\t\tres_cur = res_cur->next;\n\t\t\telse\n\t\t\t\tres_cur = res_cur->nextRange;\n\t\t\tkfree(res_tmp);\n\t\t\tres_tmp = NULL;\n\t\t}\n\t\tbus->firstMem = NULL;\n\t}\n\tif (bus->firstPFMem) {\n\t\tres_cur = bus->firstPFMem;\n\t\twhile (res_cur) {\n\t\t\tres_tmp = res_cur;\n\t\t\tif (res_cur->next)\n\t\t\t\tres_cur = res_cur->next;\n\t\t\telse\n\t\t\t\tres_cur = res_cur->nextRange;\n\t\t\tkfree(res_tmp);\n\t\t\tres_tmp = NULL;\n\t\t}\n\t\tbus->firstPFMem = NULL;\n\t}\n\n\tif (bus->firstPFMemFromMem) {\n\t\tres_cur = bus->firstPFMemFromMem;\n\t\twhile (res_cur) {\n\t\t\tres_tmp = res_cur;\n\t\t\tres_cur = res_cur->next;\n\n\t\t\tkfree(res_tmp);\n\t\t\tres_tmp = NULL;\n\t\t}\n\t\tbus->firstPFMemFromMem = NULL;\n\t}\n\n\tlist_del(&bus->bus_list);\n\tkfree(bus);\n\treturn 0;\n}\n\n \nstatic int remove_ranges(struct bus_node *bus_cur, struct bus_node *bus_prev)\n{\n\tstruct range_node *range_cur;\n\tstruct range_node *range_tmp;\n\tint i;\n\tstruct resource_node *res = NULL;\n\n\tif (bus_cur->noIORanges) {\n\t\trange_cur = bus_cur->rangeIO;\n\t\tfor (i = 0; i < bus_cur->noIORanges; i++) {\n\t\t\tif (ibmphp_find_resource(bus_prev, range_cur->start, &res, IO) < 0)\n\t\t\t\treturn -EINVAL;\n\t\t\tibmphp_remove_resource(res);\n\n\t\t\trange_tmp = range_cur;\n\t\t\trange_cur = range_cur->next;\n\t\t\tkfree(range_tmp);\n\t\t\trange_tmp = NULL;\n\t\t}\n\t\tbus_cur->rangeIO = NULL;\n\t}\n\tif (bus_cur->noMemRanges) {\n\t\trange_cur = bus_cur->rangeMem;\n\t\tfor (i = 0; i < bus_cur->noMemRanges; i++) {\n\t\t\tif (ibmphp_find_resource(bus_prev, range_cur->start, &res, MEM) < 0)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tibmphp_remove_resource(res);\n\t\t\trange_tmp = range_cur;\n\t\t\trange_cur = range_cur->next;\n\t\t\tkfree(range_tmp);\n\t\t\trange_tmp = NULL;\n\t\t}\n\t\tbus_cur->rangeMem = NULL;\n\t}\n\tif (bus_cur->noPFMemRanges) {\n\t\trange_cur = bus_cur->rangePFMem;\n\t\tfor (i = 0; i < bus_cur->noPFMemRanges; i++) {\n\t\t\tif (ibmphp_find_resource(bus_prev, range_cur->start, &res, PFMEM) < 0)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tibmphp_remove_resource(res);\n\t\t\trange_tmp = range_cur;\n\t\t\trange_cur = range_cur->next;\n\t\t\tkfree(range_tmp);\n\t\t\trange_tmp = NULL;\n\t\t}\n\t\tbus_cur->rangePFMem = NULL;\n\t}\n\treturn 0;\n}\n\n \nint ibmphp_find_resource(struct bus_node *bus, u32 start_address, struct resource_node **res, int flag)\n{\n\tstruct resource_node *res_cur = NULL;\n\tchar *type = \"\";\n\n\tif (!bus) {\n\t\terr(\"The bus passed in NULL to find resource\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tswitch (flag) {\n\t\tcase IO:\n\t\t\tres_cur = bus->firstIO;\n\t\t\ttype = \"io\";\n\t\t\tbreak;\n\t\tcase MEM:\n\t\t\tres_cur = bus->firstMem;\n\t\t\ttype = \"mem\";\n\t\t\tbreak;\n\t\tcase PFMEM:\n\t\t\tres_cur = bus->firstPFMem;\n\t\t\ttype = \"pfmem\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr(\"wrong type of flag\\n\");\n\t\t\treturn -EINVAL;\n\t}\n\n\twhile (res_cur) {\n\t\tif (res_cur->start == start_address) {\n\t\t\t*res = res_cur;\n\t\t\tbreak;\n\t\t}\n\t\tif (res_cur->next)\n\t\t\tres_cur = res_cur->next;\n\t\telse\n\t\t\tres_cur = res_cur->nextRange;\n\t}\n\n\tif (!res_cur) {\n\t\tif (flag == PFMEM) {\n\t\t\tres_cur = bus->firstPFMemFromMem;\n\t\t\twhile (res_cur) {\n\t\t\t\tif (res_cur->start == start_address) {\n\t\t\t\t\t*res = res_cur;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tres_cur = res_cur->next;\n\t\t\t}\n\t\t\tif (!res_cur) {\n\t\t\t\tdebug(\"SOS...cannot find %s resource in the bus.\\n\", type);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t} else {\n\t\t\tdebug(\"SOS... cannot find %s resource in the bus.\\n\", type);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (*res)\n\t\tdebug(\"*res->start = %x\\n\", (*res)->start);\n\n\treturn 0;\n}\n\n \nvoid ibmphp_free_resources(void)\n{\n\tstruct bus_node *bus_cur = NULL, *next;\n\tstruct bus_node *bus_tmp;\n\tstruct range_node *range_cur;\n\tstruct range_node *range_tmp;\n\tstruct resource_node *res_cur;\n\tstruct resource_node *res_tmp;\n\tint i = 0;\n\tflags = 1;\n\n\tlist_for_each_entry_safe(bus_cur, next, &gbuses, bus_list) {\n\t\tif (bus_cur->noIORanges) {\n\t\t\trange_cur = bus_cur->rangeIO;\n\t\t\tfor (i = 0; i < bus_cur->noIORanges; i++) {\n\t\t\t\tif (!range_cur)\n\t\t\t\t\tbreak;\n\t\t\t\trange_tmp = range_cur;\n\t\t\t\trange_cur = range_cur->next;\n\t\t\t\tkfree(range_tmp);\n\t\t\t\trange_tmp = NULL;\n\t\t\t}\n\t\t}\n\t\tif (bus_cur->noMemRanges) {\n\t\t\trange_cur = bus_cur->rangeMem;\n\t\t\tfor (i = 0; i < bus_cur->noMemRanges; i++) {\n\t\t\t\tif (!range_cur)\n\t\t\t\t\tbreak;\n\t\t\t\trange_tmp = range_cur;\n\t\t\t\trange_cur = range_cur->next;\n\t\t\t\tkfree(range_tmp);\n\t\t\t\trange_tmp = NULL;\n\t\t\t}\n\t\t}\n\t\tif (bus_cur->noPFMemRanges) {\n\t\t\trange_cur = bus_cur->rangePFMem;\n\t\t\tfor (i = 0; i < bus_cur->noPFMemRanges; i++) {\n\t\t\t\tif (!range_cur)\n\t\t\t\t\tbreak;\n\t\t\t\trange_tmp = range_cur;\n\t\t\t\trange_cur = range_cur->next;\n\t\t\t\tkfree(range_tmp);\n\t\t\t\trange_tmp = NULL;\n\t\t\t}\n\t\t}\n\n\t\tif (bus_cur->firstIO) {\n\t\t\tres_cur = bus_cur->firstIO;\n\t\t\twhile (res_cur) {\n\t\t\t\tres_tmp = res_cur;\n\t\t\t\tif (res_cur->next)\n\t\t\t\t\tres_cur = res_cur->next;\n\t\t\t\telse\n\t\t\t\t\tres_cur = res_cur->nextRange;\n\t\t\t\tkfree(res_tmp);\n\t\t\t\tres_tmp = NULL;\n\t\t\t}\n\t\t\tbus_cur->firstIO = NULL;\n\t\t}\n\t\tif (bus_cur->firstMem) {\n\t\t\tres_cur = bus_cur->firstMem;\n\t\t\twhile (res_cur) {\n\t\t\t\tres_tmp = res_cur;\n\t\t\t\tif (res_cur->next)\n\t\t\t\t\tres_cur = res_cur->next;\n\t\t\t\telse\n\t\t\t\t\tres_cur = res_cur->nextRange;\n\t\t\t\tkfree(res_tmp);\n\t\t\t\tres_tmp = NULL;\n\t\t\t}\n\t\t\tbus_cur->firstMem = NULL;\n\t\t}\n\t\tif (bus_cur->firstPFMem) {\n\t\t\tres_cur = bus_cur->firstPFMem;\n\t\t\twhile (res_cur) {\n\t\t\t\tres_tmp = res_cur;\n\t\t\t\tif (res_cur->next)\n\t\t\t\t\tres_cur = res_cur->next;\n\t\t\t\telse\n\t\t\t\t\tres_cur = res_cur->nextRange;\n\t\t\t\tkfree(res_tmp);\n\t\t\t\tres_tmp = NULL;\n\t\t\t}\n\t\t\tbus_cur->firstPFMem = NULL;\n\t\t}\n\n\t\tif (bus_cur->firstPFMemFromMem) {\n\t\t\tres_cur = bus_cur->firstPFMemFromMem;\n\t\t\twhile (res_cur) {\n\t\t\t\tres_tmp = res_cur;\n\t\t\t\tres_cur = res_cur->next;\n\n\t\t\t\tkfree(res_tmp);\n\t\t\t\tres_tmp = NULL;\n\t\t\t}\n\t\t\tbus_cur->firstPFMemFromMem = NULL;\n\t\t}\n\n\t\tbus_tmp = bus_cur;\n\t\tlist_del(&bus_cur->bus_list);\n\t\tkfree(bus_tmp);\n\t\tbus_tmp = NULL;\n\t}\n}\n\n \nstatic int __init once_over(void)\n{\n\tstruct resource_node *pfmem_cur;\n\tstruct resource_node *pfmem_prev;\n\tstruct resource_node *mem;\n\tstruct bus_node *bus_cur;\n\n\tlist_for_each_entry(bus_cur, &gbuses, bus_list) {\n\t\tif ((!bus_cur->rangePFMem) && (bus_cur->firstPFMem)) {\n\t\t\tfor (pfmem_cur = bus_cur->firstPFMem, pfmem_prev = NULL; pfmem_cur; pfmem_prev = pfmem_cur, pfmem_cur = pfmem_cur->next) {\n\t\t\t\tpfmem_cur->fromMem = 1;\n\t\t\t\tif (pfmem_prev)\n\t\t\t\t\tpfmem_prev->next = pfmem_cur->next;\n\t\t\t\telse\n\t\t\t\t\tbus_cur->firstPFMem = pfmem_cur->next;\n\n\t\t\t\tif (!bus_cur->firstPFMemFromMem)\n\t\t\t\t\tpfmem_cur->next = NULL;\n\t\t\t\telse\n\t\t\t\t\t \n\t\t\t\t\tpfmem_cur->next = bus_cur->firstPFMemFromMem;\n\n\t\t\t\tbus_cur->firstPFMemFromMem = pfmem_cur;\n\n\t\t\t\tmem = kzalloc(sizeof(struct resource_node), GFP_KERNEL);\n\t\t\t\tif (!mem)\n\t\t\t\t\treturn -ENOMEM;\n\n\t\t\t\tmem->type = MEM;\n\t\t\t\tmem->busno = pfmem_cur->busno;\n\t\t\t\tmem->devfunc = pfmem_cur->devfunc;\n\t\t\t\tmem->start = pfmem_cur->start;\n\t\t\t\tmem->end = pfmem_cur->end;\n\t\t\t\tmem->len = pfmem_cur->len;\n\t\t\t\tif (ibmphp_add_resource(mem) < 0)\n\t\t\t\t\terr(\"Trouble...trouble... EBDA allocated pfmem from mem, but system doesn't display it has this space... unless not PCI device...\\n\");\n\t\t\t\tpfmem_cur->rangeno = mem->rangeno;\n\t\t\t}\t \n\t\t}\t \n\t}\t \n\treturn 0;\n}\n\nint ibmphp_add_pfmem_from_mem(struct resource_node *pfmem)\n{\n\tstruct bus_node *bus_cur = find_bus_wprev(pfmem->busno, NULL, 0);\n\n\tif (!bus_cur) {\n\t\terr(\"cannot find bus of pfmem to add...\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (bus_cur->firstPFMemFromMem)\n\t\tpfmem->next = bus_cur->firstPFMemFromMem;\n\telse\n\t\tpfmem->next = NULL;\n\n\tbus_cur->firstPFMemFromMem = pfmem;\n\n\treturn 0;\n}\n\n \nstruct bus_node *ibmphp_find_res_bus(u8 bus_number)\n{\n\treturn find_bus_wprev(bus_number, NULL, 0);\n}\n\nstatic struct bus_node *find_bus_wprev(u8 bus_number, struct bus_node **prev, u8 flag)\n{\n\tstruct bus_node *bus_cur;\n\n\tlist_for_each_entry(bus_cur, &gbuses, bus_list) {\n\t\tif (flag)\n\t\t\t*prev = list_prev_entry(bus_cur, bus_list);\n\t\tif (bus_cur->busno == bus_number)\n\t\t\treturn bus_cur;\n\t}\n\n\treturn NULL;\n}\n\nvoid ibmphp_print_test(void)\n{\n\tint i = 0;\n\tstruct bus_node *bus_cur = NULL;\n\tstruct range_node *range;\n\tstruct resource_node *res;\n\n\tdebug_pci(\"*****************START**********************\\n\");\n\n\tif ((!list_empty(&gbuses)) && flags) {\n\t\terr(\"The GBUSES is not NULL?!?!?!?!?\\n\");\n\t\treturn;\n\t}\n\n\tlist_for_each_entry(bus_cur, &gbuses, bus_list) {\n\t\tdebug_pci (\"This is bus # %d.  There are\\n\", bus_cur->busno);\n\t\tdebug_pci (\"IORanges = %d\\t\", bus_cur->noIORanges);\n\t\tdebug_pci (\"MemRanges = %d\\t\", bus_cur->noMemRanges);\n\t\tdebug_pci (\"PFMemRanges = %d\\n\", bus_cur->noPFMemRanges);\n\t\tdebug_pci (\"The IO Ranges are as follows:\\n\");\n\t\tif (bus_cur->rangeIO) {\n\t\t\trange = bus_cur->rangeIO;\n\t\t\tfor (i = 0; i < bus_cur->noIORanges; i++) {\n\t\t\t\tdebug_pci(\"rangeno is %d\\n\", range->rangeno);\n\t\t\t\tdebug_pci(\"[%x - %x]\\n\", range->start, range->end);\n\t\t\t\trange = range->next;\n\t\t\t}\n\t\t}\n\n\t\tdebug_pci(\"The Mem Ranges are as follows:\\n\");\n\t\tif (bus_cur->rangeMem) {\n\t\t\trange = bus_cur->rangeMem;\n\t\t\tfor (i = 0; i < bus_cur->noMemRanges; i++) {\n\t\t\t\tdebug_pci(\"rangeno is %d\\n\", range->rangeno);\n\t\t\t\tdebug_pci(\"[%x - %x]\\n\", range->start, range->end);\n\t\t\t\trange = range->next;\n\t\t\t}\n\t\t}\n\n\t\tdebug_pci(\"The PFMem Ranges are as follows:\\n\");\n\n\t\tif (bus_cur->rangePFMem) {\n\t\t\trange = bus_cur->rangePFMem;\n\t\t\tfor (i = 0; i < bus_cur->noPFMemRanges; i++) {\n\t\t\t\tdebug_pci(\"rangeno is %d\\n\", range->rangeno);\n\t\t\t\tdebug_pci(\"[%x - %x]\\n\", range->start, range->end);\n\t\t\t\trange = range->next;\n\t\t\t}\n\t\t}\n\n\t\tdebug_pci(\"The resources on this bus are as follows\\n\");\n\n\t\tdebug_pci(\"IO...\\n\");\n\t\tif (bus_cur->firstIO) {\n\t\t\tres = bus_cur->firstIO;\n\t\t\twhile (res) {\n\t\t\t\tdebug_pci(\"The range # is %d\\n\", res->rangeno);\n\t\t\t\tdebug_pci(\"The bus, devfnc is %d, %x\\n\", res->busno, res->devfunc);\n\t\t\t\tdebug_pci(\"[%x - %x], len=%x\\n\", res->start, res->end, res->len);\n\t\t\t\tif (res->next)\n\t\t\t\t\tres = res->next;\n\t\t\t\telse if (res->nextRange)\n\t\t\t\t\tres = res->nextRange;\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tdebug_pci(\"Mem...\\n\");\n\t\tif (bus_cur->firstMem) {\n\t\t\tres = bus_cur->firstMem;\n\t\t\twhile (res) {\n\t\t\t\tdebug_pci(\"The range # is %d\\n\", res->rangeno);\n\t\t\t\tdebug_pci(\"The bus, devfnc is %d, %x\\n\", res->busno, res->devfunc);\n\t\t\t\tdebug_pci(\"[%x - %x], len=%x\\n\", res->start, res->end, res->len);\n\t\t\t\tif (res->next)\n\t\t\t\t\tres = res->next;\n\t\t\t\telse if (res->nextRange)\n\t\t\t\t\tres = res->nextRange;\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tdebug_pci(\"PFMem...\\n\");\n\t\tif (bus_cur->firstPFMem) {\n\t\t\tres = bus_cur->firstPFMem;\n\t\t\twhile (res) {\n\t\t\t\tdebug_pci(\"The range # is %d\\n\", res->rangeno);\n\t\t\t\tdebug_pci(\"The bus, devfnc is %d, %x\\n\", res->busno, res->devfunc);\n\t\t\t\tdebug_pci(\"[%x - %x], len=%x\\n\", res->start, res->end, res->len);\n\t\t\t\tif (res->next)\n\t\t\t\t\tres = res->next;\n\t\t\t\telse if (res->nextRange)\n\t\t\t\t\tres = res->nextRange;\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tdebug_pci(\"PFMemFromMem...\\n\");\n\t\tif (bus_cur->firstPFMemFromMem) {\n\t\t\tres = bus_cur->firstPFMemFromMem;\n\t\t\twhile (res) {\n\t\t\t\tdebug_pci(\"The range # is %d\\n\", res->rangeno);\n\t\t\t\tdebug_pci(\"The bus, devfnc is %d, %x\\n\", res->busno, res->devfunc);\n\t\t\t\tdebug_pci(\"[%x - %x], len=%x\\n\", res->start, res->end, res->len);\n\t\t\t\tres = res->next;\n\t\t\t}\n\t\t}\n\t}\n\tdebug_pci(\"***********************END***********************\\n\");\n}\n\nstatic int range_exists_already(struct range_node *range, struct bus_node *bus_cur, u8 type)\n{\n\tstruct range_node *range_cur = NULL;\n\tswitch (type) {\n\t\tcase IO:\n\t\t\trange_cur = bus_cur->rangeIO;\n\t\t\tbreak;\n\t\tcase MEM:\n\t\t\trange_cur = bus_cur->rangeMem;\n\t\t\tbreak;\n\t\tcase PFMEM:\n\t\t\trange_cur = bus_cur->rangePFMem;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr(\"wrong type passed to find out if range already exists\\n\");\n\t\t\treturn -ENODEV;\n\t}\n\n\twhile (range_cur) {\n\t\tif ((range_cur->start == range->start) && (range_cur->end == range->end))\n\t\t\treturn 1;\n\t\trange_cur = range_cur->next;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int __init update_bridge_ranges(struct bus_node **bus)\n{\n\tu8 sec_busno, device, function, hdr_type, start_io_address, end_io_address;\n\tu16 vendor_id, upper_io_start, upper_io_end, start_mem_address, end_mem_address;\n\tu32 start_address, end_address, upper_start, upper_end;\n\tstruct bus_node *bus_sec;\n\tstruct bus_node *bus_cur;\n\tstruct resource_node *io;\n\tstruct resource_node *mem;\n\tstruct resource_node *pfmem;\n\tstruct range_node *range;\n\tunsigned int devfn;\n\n\tbus_cur = *bus;\n\tif (!bus_cur)\n\t\treturn -ENODEV;\n\tibmphp_pci_bus->number = bus_cur->busno;\n\n\tdebug(\"inside %s\\n\", __func__);\n\tdebug(\"bus_cur->busno = %x\\n\", bus_cur->busno);\n\n\tfor (device = 0; device < 32; device++) {\n\t\tfor (function = 0x00; function < 0x08; function++) {\n\t\t\tdevfn = PCI_DEVFN(device, function);\n\t\t\tpci_bus_read_config_word(ibmphp_pci_bus, devfn, PCI_VENDOR_ID, &vendor_id);\n\n\t\t\tif (vendor_id != PCI_VENDOR_ID_NOTVALID) {\n\t\t\t\t \n\t\t\t\tpci_bus_read_config_byte(ibmphp_pci_bus, devfn, PCI_HEADER_TYPE, &hdr_type);\n\n\t\t\t\tswitch (hdr_type) {\n\t\t\t\t\tcase PCI_HEADER_TYPE_NORMAL:\n\t\t\t\t\t\tfunction = 0x8;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase PCI_HEADER_TYPE_MULTIDEVICE:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase PCI_HEADER_TYPE_BRIDGE:\n\t\t\t\t\t\tfunction = 0x8;\n\t\t\t\t\t\tfallthrough;\n\t\t\t\t\tcase PCI_HEADER_TYPE_MULTIBRIDGE:\n\t\t\t\t\t\t \n\t\t\t\t\t\tpci_bus_read_config_byte(ibmphp_pci_bus, devfn, PCI_SECONDARY_BUS, &sec_busno);\n\t\t\t\t\t\tbus_sec = find_bus_wprev(sec_busno, NULL, 0);\n\t\t\t\t\t\t \n\t\t\t\t\t\tif (!bus_sec) {\n\t\t\t\t\t\t\talloc_error_bus(NULL, sec_busno, 1);\n\t\t\t\t\t\t\t \n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpci_bus_read_config_byte(ibmphp_pci_bus, devfn, PCI_IO_BASE, &start_io_address);\n\t\t\t\t\t\tpci_bus_read_config_byte(ibmphp_pci_bus, devfn, PCI_IO_LIMIT, &end_io_address);\n\t\t\t\t\t\tpci_bus_read_config_word(ibmphp_pci_bus, devfn, PCI_IO_BASE_UPPER16, &upper_io_start);\n\t\t\t\t\t\tpci_bus_read_config_word(ibmphp_pci_bus, devfn, PCI_IO_LIMIT_UPPER16, &upper_io_end);\n\t\t\t\t\t\tstart_address = (start_io_address & PCI_IO_RANGE_MASK) << 8;\n\t\t\t\t\t\tstart_address |= (upper_io_start << 16);\n\t\t\t\t\t\tend_address = (end_io_address & PCI_IO_RANGE_MASK) << 8;\n\t\t\t\t\t\tend_address |= (upper_io_end << 16);\n\n\t\t\t\t\t\tif ((start_address) && (start_address <= end_address)) {\n\t\t\t\t\t\t\trange = kzalloc(sizeof(struct range_node), GFP_KERNEL);\n\t\t\t\t\t\t\tif (!range)\n\t\t\t\t\t\t\t\treturn -ENOMEM;\n\n\t\t\t\t\t\t\trange->start = start_address;\n\t\t\t\t\t\t\trange->end = end_address + 0xfff;\n\n\t\t\t\t\t\t\tif (bus_sec->noIORanges > 0) {\n\t\t\t\t\t\t\t\tif (!range_exists_already(range, bus_sec, IO)) {\n\t\t\t\t\t\t\t\t\tadd_bus_range(IO, range, bus_sec);\n\t\t\t\t\t\t\t\t\t++bus_sec->noIORanges;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tkfree(range);\n\t\t\t\t\t\t\t\t\trange = NULL;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t\trange->rangeno = 1;\n\t\t\t\t\t\t\t\tbus_sec->rangeIO = range;\n\t\t\t\t\t\t\t\t++bus_sec->noIORanges;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfix_resources(bus_sec);\n\n\t\t\t\t\t\t\tif (ibmphp_find_resource(bus_cur, start_address, &io, IO)) {\n\t\t\t\t\t\t\t\tio = kzalloc(sizeof(struct resource_node), GFP_KERNEL);\n\t\t\t\t\t\t\t\tif (!io) {\n\t\t\t\t\t\t\t\t\tkfree(range);\n\t\t\t\t\t\t\t\t\treturn -ENOMEM;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tio->type = IO;\n\t\t\t\t\t\t\t\tio->busno = bus_cur->busno;\n\t\t\t\t\t\t\t\tio->devfunc = ((device << 3) | (function & 0x7));\n\t\t\t\t\t\t\t\tio->start = start_address;\n\t\t\t\t\t\t\t\tio->end = end_address + 0xfff;\n\t\t\t\t\t\t\t\tio->len = io->end - io->start + 1;\n\t\t\t\t\t\t\t\tibmphp_add_resource(io);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tpci_bus_read_config_word(ibmphp_pci_bus, devfn, PCI_MEMORY_BASE, &start_mem_address);\n\t\t\t\t\t\tpci_bus_read_config_word(ibmphp_pci_bus, devfn, PCI_MEMORY_LIMIT, &end_mem_address);\n\n\t\t\t\t\t\tstart_address = 0x00000000 | (start_mem_address & PCI_MEMORY_RANGE_MASK) << 16;\n\t\t\t\t\t\tend_address = 0x00000000 | (end_mem_address & PCI_MEMORY_RANGE_MASK) << 16;\n\n\t\t\t\t\t\tif ((start_address) && (start_address <= end_address)) {\n\n\t\t\t\t\t\t\trange = kzalloc(sizeof(struct range_node), GFP_KERNEL);\n\t\t\t\t\t\t\tif (!range)\n\t\t\t\t\t\t\t\treturn -ENOMEM;\n\n\t\t\t\t\t\t\trange->start = start_address;\n\t\t\t\t\t\t\trange->end = end_address + 0xfffff;\n\n\t\t\t\t\t\t\tif (bus_sec->noMemRanges > 0) {\n\t\t\t\t\t\t\t\tif (!range_exists_already(range, bus_sec, MEM)) {\n\t\t\t\t\t\t\t\t\tadd_bus_range(MEM, range, bus_sec);\n\t\t\t\t\t\t\t\t\t++bus_sec->noMemRanges;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tkfree(range);\n\t\t\t\t\t\t\t\t\trange = NULL;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t\trange->rangeno = 1;\n\t\t\t\t\t\t\t\tbus_sec->rangeMem = range;\n\t\t\t\t\t\t\t\t++bus_sec->noMemRanges;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tfix_resources(bus_sec);\n\n\t\t\t\t\t\t\tif (ibmphp_find_resource(bus_cur, start_address, &mem, MEM)) {\n\t\t\t\t\t\t\t\tmem = kzalloc(sizeof(struct resource_node), GFP_KERNEL);\n\t\t\t\t\t\t\t\tif (!mem) {\n\t\t\t\t\t\t\t\t\tkfree(range);\n\t\t\t\t\t\t\t\t\treturn -ENOMEM;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tmem->type = MEM;\n\t\t\t\t\t\t\t\tmem->busno = bus_cur->busno;\n\t\t\t\t\t\t\t\tmem->devfunc = ((device << 3) | (function & 0x7));\n\t\t\t\t\t\t\t\tmem->start = start_address;\n\t\t\t\t\t\t\t\tmem->end = end_address + 0xfffff;\n\t\t\t\t\t\t\t\tmem->len = mem->end - mem->start + 1;\n\t\t\t\t\t\t\t\tibmphp_add_resource(mem);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpci_bus_read_config_word(ibmphp_pci_bus, devfn, PCI_PREF_MEMORY_BASE, &start_mem_address);\n\t\t\t\t\t\tpci_bus_read_config_word(ibmphp_pci_bus, devfn, PCI_PREF_MEMORY_LIMIT, &end_mem_address);\n\t\t\t\t\t\tpci_bus_read_config_dword(ibmphp_pci_bus, devfn, PCI_PREF_BASE_UPPER32, &upper_start);\n\t\t\t\t\t\tpci_bus_read_config_dword(ibmphp_pci_bus, devfn, PCI_PREF_LIMIT_UPPER32, &upper_end);\n\t\t\t\t\t\tstart_address = 0x00000000 | (start_mem_address & PCI_MEMORY_RANGE_MASK) << 16;\n\t\t\t\t\t\tend_address = 0x00000000 | (end_mem_address & PCI_MEMORY_RANGE_MASK) << 16;\n#if BITS_PER_LONG == 64\n\t\t\t\t\t\tstart_address |= ((long) upper_start) << 32;\n\t\t\t\t\t\tend_address |= ((long) upper_end) << 32;\n#endif\n\n\t\t\t\t\t\tif ((start_address) && (start_address <= end_address)) {\n\n\t\t\t\t\t\t\trange = kzalloc(sizeof(struct range_node), GFP_KERNEL);\n\t\t\t\t\t\t\tif (!range)\n\t\t\t\t\t\t\t\treturn -ENOMEM;\n\n\t\t\t\t\t\t\trange->start = start_address;\n\t\t\t\t\t\t\trange->end = end_address + 0xfffff;\n\n\t\t\t\t\t\t\tif (bus_sec->noPFMemRanges > 0) {\n\t\t\t\t\t\t\t\tif (!range_exists_already(range, bus_sec, PFMEM)) {\n\t\t\t\t\t\t\t\t\tadd_bus_range(PFMEM, range, bus_sec);\n\t\t\t\t\t\t\t\t\t++bus_sec->noPFMemRanges;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tkfree(range);\n\t\t\t\t\t\t\t\t\trange = NULL;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t\trange->rangeno = 1;\n\t\t\t\t\t\t\t\tbus_sec->rangePFMem = range;\n\t\t\t\t\t\t\t\t++bus_sec->noPFMemRanges;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tfix_resources(bus_sec);\n\t\t\t\t\t\t\tif (ibmphp_find_resource(bus_cur, start_address, &pfmem, PFMEM)) {\n\t\t\t\t\t\t\t\tpfmem = kzalloc(sizeof(struct resource_node), GFP_KERNEL);\n\t\t\t\t\t\t\t\tif (!pfmem) {\n\t\t\t\t\t\t\t\t\tkfree(range);\n\t\t\t\t\t\t\t\t\treturn -ENOMEM;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tpfmem->type = PFMEM;\n\t\t\t\t\t\t\t\tpfmem->busno = bus_cur->busno;\n\t\t\t\t\t\t\t\tpfmem->devfunc = ((device << 3) | (function & 0x7));\n\t\t\t\t\t\t\t\tpfmem->start = start_address;\n\t\t\t\t\t\t\t\tpfmem->end = end_address + 0xfffff;\n\t\t\t\t\t\t\t\tpfmem->len = pfmem->end - pfmem->start + 1;\n\t\t\t\t\t\t\t\tpfmem->fromMem = 0;\n\n\t\t\t\t\t\t\t\tibmphp_add_resource(pfmem);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\t \n\t\t\t}\t \n\t\t}\t \n\t}\t \n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}