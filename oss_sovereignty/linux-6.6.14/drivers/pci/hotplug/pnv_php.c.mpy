{
  "module_name": "pnv_php.c",
  "hash_id": "628bf50b70ba8e92a27f3ac6570b86fd157bf595fbd657e4f9d7418056bf028b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/hotplug/pnv_php.c",
  "human_readable_source": "\n \n\n#include <linux/libfdt.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/pci_hotplug.h>\n#include <linux/of_fdt.h>\n\n#include <asm/opal.h>\n#include <asm/pnv-pci.h>\n#include <asm/ppc-pci.h>\n\n#define DRIVER_VERSION\t\"0.1\"\n#define DRIVER_AUTHOR\t\"Gavin Shan, IBM Corporation\"\n#define DRIVER_DESC\t\"PowerPC PowerNV PCI Hotplug Driver\"\n\n#define SLOT_WARN(sl, x...) \\\n\t((sl)->pdev ? pci_warn((sl)->pdev, x) : dev_warn(&(sl)->bus->dev, x))\n\nstruct pnv_php_event {\n\tbool\t\t\tadded;\n\tstruct pnv_php_slot\t*php_slot;\n\tstruct work_struct\twork;\n};\n\nstatic LIST_HEAD(pnv_php_slot_list);\nstatic DEFINE_SPINLOCK(pnv_php_lock);\n\nstatic void pnv_php_register(struct device_node *dn);\nstatic void pnv_php_unregister_one(struct device_node *dn);\nstatic void pnv_php_unregister(struct device_node *dn);\n\nstatic void pnv_php_disable_irq(struct pnv_php_slot *php_slot,\n\t\t\t\tbool disable_device)\n{\n\tstruct pci_dev *pdev = php_slot->pdev;\n\tint irq = php_slot->irq;\n\tu16 ctrl;\n\n\tif (php_slot->irq > 0) {\n\t\tpcie_capability_read_word(pdev, PCI_EXP_SLTCTL, &ctrl);\n\t\tctrl &= ~(PCI_EXP_SLTCTL_HPIE |\n\t\t\t  PCI_EXP_SLTCTL_PDCE |\n\t\t\t  PCI_EXP_SLTCTL_DLLSCE);\n\t\tpcie_capability_write_word(pdev, PCI_EXP_SLTCTL, ctrl);\n\n\t\tfree_irq(php_slot->irq, php_slot);\n\t\tphp_slot->irq = 0;\n\t}\n\n\tif (php_slot->wq) {\n\t\tdestroy_workqueue(php_slot->wq);\n\t\tphp_slot->wq = NULL;\n\t}\n\n\tif (disable_device || irq > 0) {\n\t\tif (pdev->msix_enabled)\n\t\t\tpci_disable_msix(pdev);\n\t\telse if (pdev->msi_enabled)\n\t\t\tpci_disable_msi(pdev);\n\n\t\tpci_disable_device(pdev);\n\t}\n}\n\nstatic void pnv_php_free_slot(struct kref *kref)\n{\n\tstruct pnv_php_slot *php_slot = container_of(kref,\n\t\t\t\t\tstruct pnv_php_slot, kref);\n\n\tWARN_ON(!list_empty(&php_slot->children));\n\tpnv_php_disable_irq(php_slot, false);\n\tkfree(php_slot->name);\n\tkfree(php_slot);\n}\n\nstatic inline void pnv_php_put_slot(struct pnv_php_slot *php_slot)\n{\n\n\tif (!php_slot)\n\t\treturn;\n\n\tkref_put(&php_slot->kref, pnv_php_free_slot);\n}\n\nstatic struct pnv_php_slot *pnv_php_match(struct device_node *dn,\n\t\t\t\t\t  struct pnv_php_slot *php_slot)\n{\n\tstruct pnv_php_slot *target, *tmp;\n\n\tif (php_slot->dn == dn) {\n\t\tkref_get(&php_slot->kref);\n\t\treturn php_slot;\n\t}\n\n\tlist_for_each_entry(tmp, &php_slot->children, link) {\n\t\ttarget = pnv_php_match(dn, tmp);\n\t\tif (target)\n\t\t\treturn target;\n\t}\n\n\treturn NULL;\n}\n\nstruct pnv_php_slot *pnv_php_find_slot(struct device_node *dn)\n{\n\tstruct pnv_php_slot *php_slot, *tmp;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&pnv_php_lock, flags);\n\tlist_for_each_entry(tmp, &pnv_php_slot_list, link) {\n\t\tphp_slot = pnv_php_match(dn, tmp);\n\t\tif (php_slot) {\n\t\t\tspin_unlock_irqrestore(&pnv_php_lock, flags);\n\t\t\treturn php_slot;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&pnv_php_lock, flags);\n\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(pnv_php_find_slot);\n\n \nstatic void pnv_php_rmv_pdns(struct device_node *dn)\n{\n\tstruct device_node *child;\n\n\tfor_each_child_of_node(dn, child) {\n\t\tpnv_php_rmv_pdns(child);\n\n\t\tpci_remove_device_node_info(child);\n\t}\n}\n\n \nstatic void pnv_php_detach_device_nodes(struct device_node *parent)\n{\n\tstruct device_node *dn;\n\n\tfor_each_child_of_node(parent, dn) {\n\t\tpnv_php_detach_device_nodes(dn);\n\n\t\tof_node_put(dn);\n\t\tof_detach_node(dn);\n\t}\n}\n\nstatic void pnv_php_rmv_devtree(struct pnv_php_slot *php_slot)\n{\n\tpnv_php_rmv_pdns(php_slot->dn);\n\n\t \n\tif (php_slot->fdt)\n\t\tof_changeset_destroy(&php_slot->ocs);\n\tpnv_php_detach_device_nodes(php_slot->dn);\n\n\tif (php_slot->fdt) {\n\t\tkfree(php_slot->dt);\n\t\tkfree(php_slot->fdt);\n\t\tphp_slot->dt        = NULL;\n\t\tphp_slot->dn->child = NULL;\n\t\tphp_slot->fdt       = NULL;\n\t}\n}\n\n \nstatic void pnv_php_reverse_nodes(struct device_node *parent)\n{\n\tstruct device_node *child, *next;\n\n\t \n\tfor_each_child_of_node(parent, child)\n\t\tpnv_php_reverse_nodes(child);\n\n\t \n\tchild = parent->child;\n\tparent->child = NULL;\n\twhile (child) {\n\t\tnext = child->sibling;\n\n\t\tchild->sibling = parent->child;\n\t\tparent->child = child;\n\t\tchild = next;\n\t}\n}\n\nstatic int pnv_php_populate_changeset(struct of_changeset *ocs,\n\t\t\t\t      struct device_node *dn)\n{\n\tstruct device_node *child;\n\tint ret = 0;\n\n\tfor_each_child_of_node(dn, child) {\n\t\tret = of_changeset_attach_node(ocs, child);\n\t\tif (ret) {\n\t\t\tof_node_put(child);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = pnv_php_populate_changeset(ocs, child);\n\t\tif (ret) {\n\t\t\tof_node_put(child);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic void *pnv_php_add_one_pdn(struct device_node *dn, void *data)\n{\n\tstruct pci_controller *hose = (struct pci_controller *)data;\n\tstruct pci_dn *pdn;\n\n\tpdn = pci_add_device_node_info(hose, dn);\n\tif (!pdn)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\treturn NULL;\n}\n\nstatic void pnv_php_add_pdns(struct pnv_php_slot *slot)\n{\n\tstruct pci_controller *hose = pci_bus_to_host(slot->bus);\n\n\tpci_traverse_device_nodes(slot->dn, pnv_php_add_one_pdn, hose);\n}\n\nstatic int pnv_php_add_devtree(struct pnv_php_slot *php_slot)\n{\n\tvoid *fdt, *fdt1, *dt;\n\tint ret;\n\n\t \n\tfdt1 = kzalloc(0x10000, GFP_KERNEL);\n\tif (!fdt1) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tret = pnv_pci_get_device_tree(php_slot->dn->phandle, fdt1, 0x10000);\n\tif (ret) {\n\t\tSLOT_WARN(php_slot, \"Error %d getting FDT blob\\n\", ret);\n\t\tgoto free_fdt1;\n\t}\n\n\tfdt = kmemdup(fdt1, fdt_totalsize(fdt1), GFP_KERNEL);\n\tif (!fdt) {\n\t\tret = -ENOMEM;\n\t\tgoto free_fdt1;\n\t}\n\n\t \n\tdt = of_fdt_unflatten_tree(fdt, php_slot->dn, NULL);\n\tif (!dt) {\n\t\tret = -EINVAL;\n\t\tSLOT_WARN(php_slot, \"Cannot unflatten FDT\\n\");\n\t\tgoto free_fdt;\n\t}\n\n\t \n\tof_changeset_init(&php_slot->ocs);\n\tpnv_php_reverse_nodes(php_slot->dn);\n\tret = pnv_php_populate_changeset(&php_slot->ocs, php_slot->dn);\n\tif (ret) {\n\t\tpnv_php_reverse_nodes(php_slot->dn);\n\t\tSLOT_WARN(php_slot, \"Error %d populating changeset\\n\",\n\t\t\t  ret);\n\t\tgoto free_dt;\n\t}\n\n\tphp_slot->dn->child = NULL;\n\tret = of_changeset_apply(&php_slot->ocs);\n\tif (ret) {\n\t\tSLOT_WARN(php_slot, \"Error %d applying changeset\\n\", ret);\n\t\tgoto destroy_changeset;\n\t}\n\n\t \n\tpnv_php_add_pdns(php_slot);\n\tphp_slot->fdt = fdt;\n\tphp_slot->dt  = dt;\n\tkfree(fdt1);\n\tgoto out;\n\ndestroy_changeset:\n\tof_changeset_destroy(&php_slot->ocs);\nfree_dt:\n\tkfree(dt);\n\tphp_slot->dn->child = NULL;\nfree_fdt:\n\tkfree(fdt);\nfree_fdt1:\n\tkfree(fdt1);\nout:\n\treturn ret;\n}\n\nstatic inline struct pnv_php_slot *to_pnv_php_slot(struct hotplug_slot *slot)\n{\n\treturn container_of(slot, struct pnv_php_slot, slot);\n}\n\nint pnv_php_set_slot_power_state(struct hotplug_slot *slot,\n\t\t\t\t uint8_t state)\n{\n\tstruct pnv_php_slot *php_slot = to_pnv_php_slot(slot);\n\tstruct opal_msg msg;\n\tint ret;\n\n\tret = pnv_pci_set_power_state(php_slot->id, state, &msg);\n\tif (ret > 0) {\n\t\tif (be64_to_cpu(msg.params[1]) != php_slot->dn->phandle\t||\n\t\t    be64_to_cpu(msg.params[2]) != state) {\n\t\t\tSLOT_WARN(php_slot, \"Wrong msg (%lld, %lld, %lld)\\n\",\n\t\t\t\t  be64_to_cpu(msg.params[1]),\n\t\t\t\t  be64_to_cpu(msg.params[2]),\n\t\t\t\t  be64_to_cpu(msg.params[3]));\n\t\t\treturn -ENOMSG;\n\t\t}\n\t\tif (be64_to_cpu(msg.params[3]) != OPAL_SUCCESS) {\n\t\t\tret = -ENODEV;\n\t\t\tgoto error;\n\t\t}\n\t} else if (ret < 0) {\n\t\tgoto error;\n\t}\n\n\tif (state == OPAL_PCI_SLOT_POWER_OFF || state == OPAL_PCI_SLOT_OFFLINE)\n\t\tpnv_php_rmv_devtree(php_slot);\n\telse\n\t\tret = pnv_php_add_devtree(php_slot);\n\n\treturn ret;\n\nerror:\n\tSLOT_WARN(php_slot, \"Error %d powering %s\\n\",\n\t\t  ret, (state == OPAL_PCI_SLOT_POWER_ON) ? \"on\" : \"off\");\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(pnv_php_set_slot_power_state);\n\nstatic int pnv_php_get_power_state(struct hotplug_slot *slot, u8 *state)\n{\n\tstruct pnv_php_slot *php_slot = to_pnv_php_slot(slot);\n\tuint8_t power_state = OPAL_PCI_SLOT_POWER_ON;\n\tint ret;\n\n\t \n\tret = pnv_pci_get_power_state(php_slot->id, &power_state);\n\tif (ret) {\n\t\tSLOT_WARN(php_slot, \"Error %d getting power status\\n\",\n\t\t\t  ret);\n\t} else {\n\t\t*state = power_state;\n\t}\n\n\treturn 0;\n}\n\nstatic int pnv_php_get_adapter_state(struct hotplug_slot *slot, u8 *state)\n{\n\tstruct pnv_php_slot *php_slot = to_pnv_php_slot(slot);\n\tuint8_t presence = OPAL_PCI_SLOT_EMPTY;\n\tint ret;\n\n\t \n\tret = pnv_pci_get_presence_state(php_slot->id, &presence);\n\tif (ret >= 0) {\n\t\t*state = presence;\n\t\tret = 0;\n\t} else {\n\t\tSLOT_WARN(php_slot, \"Error %d getting presence\\n\", ret);\n\t}\n\n\treturn ret;\n}\n\nstatic int pnv_php_get_attention_state(struct hotplug_slot *slot, u8 *state)\n{\n\tstruct pnv_php_slot *php_slot = to_pnv_php_slot(slot);\n\n\t*state = php_slot->attention_state;\n\treturn 0;\n}\n\nstatic int pnv_php_set_attention_state(struct hotplug_slot *slot, u8 state)\n{\n\tstruct pnv_php_slot *php_slot = to_pnv_php_slot(slot);\n\tstruct pci_dev *bridge = php_slot->pdev;\n\tu16 new, mask;\n\n\tphp_slot->attention_state = state;\n\tif (!bridge)\n\t\treturn 0;\n\n\tmask = PCI_EXP_SLTCTL_AIC;\n\n\tif (state)\n\t\tnew = PCI_EXP_SLTCTL_ATTN_IND_ON;\n\telse\n\t\tnew = PCI_EXP_SLTCTL_ATTN_IND_OFF;\n\n\tpcie_capability_clear_and_set_word(bridge, PCI_EXP_SLTCTL, mask, new);\n\n\treturn 0;\n}\n\nstatic int pnv_php_enable(struct pnv_php_slot *php_slot, bool rescan)\n{\n\tstruct hotplug_slot *slot = &php_slot->slot;\n\tuint8_t presence = OPAL_PCI_SLOT_EMPTY;\n\tuint8_t power_status = OPAL_PCI_SLOT_POWER_ON;\n\tint ret;\n\n\t \n\tif (php_slot->state != PNV_PHP_STATE_REGISTERED)\n\t\treturn 0;\n\n\t \n\tret = pnv_php_get_adapter_state(slot, &presence);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (presence == OPAL_PCI_SLOT_EMPTY) {\n\t\tif (!php_slot->power_state_check) {\n\t\t\tphp_slot->power_state_check = true;\n\n\t\t\treturn 0;\n\t\t}\n\n\t\tgoto scan;\n\t}\n\n\t \n\tif (!php_slot->power_state_check) {\n\t\tphp_slot->power_state_check = true;\n\n\t\tret = pnv_php_get_power_state(slot, &power_status);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (power_status != OPAL_PCI_SLOT_POWER_ON)\n\t\t\treturn 0;\n\t}\n\n\t \n\tret = pnv_php_get_power_state(slot, &power_status);\n\tif (ret)\n\t\treturn ret;\n\n\tif (power_status == OPAL_PCI_SLOT_POWER_ON)\n\t\tgoto scan;\n\n\t \n\tret = pnv_php_set_slot_power_state(slot, OPAL_PCI_SLOT_POWER_ON);\n\tif (ret)\n\t\treturn ret;\n\nscan:\n\tif (presence == OPAL_PCI_SLOT_PRESENT) {\n\t\tif (rescan) {\n\t\t\tpci_lock_rescan_remove();\n\t\t\tpci_hp_add_devices(php_slot->bus);\n\t\t\tpci_unlock_rescan_remove();\n\t\t}\n\n\t\t \n\t\tphp_slot->state = PNV_PHP_STATE_POPULATED;\n\t\tif (rescan)\n\t\t\tpnv_php_register(php_slot->dn);\n\t} else {\n\t\tphp_slot->state = PNV_PHP_STATE_POPULATED;\n\t}\n\n\treturn 0;\n}\n\nstatic int pnv_php_reset_slot(struct hotplug_slot *slot, bool probe)\n{\n\tstruct pnv_php_slot *php_slot = to_pnv_php_slot(slot);\n\tstruct pci_dev *bridge = php_slot->pdev;\n\tuint16_t sts;\n\n\t \n\tif (probe)\n\t\treturn !bridge;\n\n\t \n\tif (php_slot->irq > 0)\n\t\tdisable_irq(php_slot->irq);\n\n\tpci_bridge_secondary_bus_reset(bridge);\n\n\t \n\tpcie_capability_read_word(php_slot->pdev, PCI_EXP_SLTSTA, &sts);\n\tsts &= (PCI_EXP_SLTSTA_PDC | PCI_EXP_SLTSTA_DLLSC);\n\tpcie_capability_write_word(php_slot->pdev, PCI_EXP_SLTSTA, sts);\n\n\tif (php_slot->irq > 0)\n\t\tenable_irq(php_slot->irq);\n\n\treturn 0;\n}\n\nstatic int pnv_php_enable_slot(struct hotplug_slot *slot)\n{\n\tstruct pnv_php_slot *php_slot = to_pnv_php_slot(slot);\n\n\treturn pnv_php_enable(php_slot, true);\n}\n\nstatic int pnv_php_disable_slot(struct hotplug_slot *slot)\n{\n\tstruct pnv_php_slot *php_slot = to_pnv_php_slot(slot);\n\tint ret;\n\n\t \n\tif (php_slot->state != PNV_PHP_STATE_POPULATED &&\n\t    php_slot->state != PNV_PHP_STATE_REGISTERED)\n\t\treturn 0;\n\n\t \n\tpci_lock_rescan_remove();\n\tpci_hp_remove_devices(php_slot->bus);\n\tpci_unlock_rescan_remove();\n\n\t \n\tpnv_php_unregister(php_slot->dn);\n\n\t \n\tret = pnv_php_set_slot_power_state(slot, OPAL_PCI_SLOT_POWER_OFF);\n\n\tphp_slot->state = PNV_PHP_STATE_REGISTERED;\n\treturn ret;\n}\n\nstatic const struct hotplug_slot_ops php_slot_ops = {\n\t.get_power_status\t= pnv_php_get_power_state,\n\t.get_adapter_status\t= pnv_php_get_adapter_state,\n\t.get_attention_status\t= pnv_php_get_attention_state,\n\t.set_attention_status\t= pnv_php_set_attention_state,\n\t.enable_slot\t\t= pnv_php_enable_slot,\n\t.disable_slot\t\t= pnv_php_disable_slot,\n\t.reset_slot\t\t= pnv_php_reset_slot,\n};\n\nstatic void pnv_php_release(struct pnv_php_slot *php_slot)\n{\n\tunsigned long flags;\n\n\t \n\tspin_lock_irqsave(&pnv_php_lock, flags);\n\tlist_del(&php_slot->link);\n\tspin_unlock_irqrestore(&pnv_php_lock, flags);\n\n\t \n\tpnv_php_put_slot(php_slot);\n\tpnv_php_put_slot(php_slot->parent);\n}\n\nstatic struct pnv_php_slot *pnv_php_alloc_slot(struct device_node *dn)\n{\n\tstruct pnv_php_slot *php_slot;\n\tstruct pci_bus *bus;\n\tconst char *label;\n\tuint64_t id;\n\tint ret;\n\n\tret = of_property_read_string(dn, \"ibm,slot-label\", &label);\n\tif (ret)\n\t\treturn NULL;\n\n\tif (pnv_pci_get_slot_id(dn, &id))\n\t\treturn NULL;\n\n\tbus = pci_find_bus_by_node(dn);\n\tif (!bus)\n\t\treturn NULL;\n\n\tphp_slot = kzalloc(sizeof(*php_slot), GFP_KERNEL);\n\tif (!php_slot)\n\t\treturn NULL;\n\n\tphp_slot->name = kstrdup(label, GFP_KERNEL);\n\tif (!php_slot->name) {\n\t\tkfree(php_slot);\n\t\treturn NULL;\n\t}\n\n\tif (dn->child && PCI_DN(dn->child))\n\t\tphp_slot->slot_no = PCI_SLOT(PCI_DN(dn->child)->devfn);\n\telse\n\t\tphp_slot->slot_no = -1;    \n\n\tkref_init(&php_slot->kref);\n\tphp_slot->state\t                = PNV_PHP_STATE_INITIALIZED;\n\tphp_slot->dn\t                = dn;\n\tphp_slot->pdev\t                = bus->self;\n\tphp_slot->bus\t                = bus;\n\tphp_slot->id\t                = id;\n\tphp_slot->power_state_check     = false;\n\tphp_slot->slot.ops              = &php_slot_ops;\n\n\tINIT_LIST_HEAD(&php_slot->children);\n\tINIT_LIST_HEAD(&php_slot->link);\n\n\treturn php_slot;\n}\n\nstatic int pnv_php_register_slot(struct pnv_php_slot *php_slot)\n{\n\tstruct pnv_php_slot *parent;\n\tstruct device_node *dn = php_slot->dn;\n\tunsigned long flags;\n\tint ret;\n\n\t \n\tparent = pnv_php_find_slot(php_slot->dn);\n\tif (parent) {\n\t\tpnv_php_put_slot(parent);\n\t\treturn -EEXIST;\n\t}\n\n\t \n\tret = pci_hp_register(&php_slot->slot, php_slot->bus,\n\t\t\t      php_slot->slot_no, php_slot->name);\n\tif (ret) {\n\t\tSLOT_WARN(php_slot, \"Error %d registering slot\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\twhile ((dn = of_get_parent(dn))) {\n\t\tif (!PCI_DN(dn)) {\n\t\t\tof_node_put(dn);\n\t\t\tbreak;\n\t\t}\n\n\t\tparent = pnv_php_find_slot(dn);\n\t\tif (parent) {\n\t\t\tof_node_put(dn);\n\t\t\tbreak;\n\t\t}\n\n\t\tof_node_put(dn);\n\t}\n\n\tspin_lock_irqsave(&pnv_php_lock, flags);\n\tphp_slot->parent = parent;\n\tif (parent)\n\t\tlist_add_tail(&php_slot->link, &parent->children);\n\telse\n\t\tlist_add_tail(&php_slot->link, &pnv_php_slot_list);\n\tspin_unlock_irqrestore(&pnv_php_lock, flags);\n\n\tphp_slot->state = PNV_PHP_STATE_REGISTERED;\n\treturn 0;\n}\n\nstatic int pnv_php_enable_msix(struct pnv_php_slot *php_slot)\n{\n\tstruct pci_dev *pdev = php_slot->pdev;\n\tstruct msix_entry entry;\n\tint nr_entries, ret;\n\tu16 pcie_flag;\n\n\t \n\tnr_entries = pci_msix_vec_count(pdev);\n\tif (nr_entries < 0)\n\t\treturn nr_entries;\n\n\t \n\tpcie_capability_read_word(pdev, PCI_EXP_FLAGS, &pcie_flag);\n\tentry.entry = (pcie_flag & PCI_EXP_FLAGS_IRQ) >> 9;\n\tif (entry.entry >= nr_entries)\n\t\treturn -ERANGE;\n\n\t \n\tret = pci_enable_msix_exact(pdev, &entry, 1);\n\tif (ret) {\n\t\tSLOT_WARN(php_slot, \"Error %d enabling MSIx\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn entry.vector;\n}\n\nstatic void pnv_php_event_handler(struct work_struct *work)\n{\n\tstruct pnv_php_event *event =\n\t\tcontainer_of(work, struct pnv_php_event, work);\n\tstruct pnv_php_slot *php_slot = event->php_slot;\n\n\tif (event->added)\n\t\tpnv_php_enable_slot(&php_slot->slot);\n\telse\n\t\tpnv_php_disable_slot(&php_slot->slot);\n\n\tkfree(event);\n}\n\nstatic irqreturn_t pnv_php_interrupt(int irq, void *data)\n{\n\tstruct pnv_php_slot *php_slot = data;\n\tstruct pci_dev *pchild, *pdev = php_slot->pdev;\n\tstruct eeh_dev *edev;\n\tstruct eeh_pe *pe;\n\tstruct pnv_php_event *event;\n\tu16 sts, lsts;\n\tu8 presence;\n\tbool added;\n\tunsigned long flags;\n\tint ret;\n\n\tpcie_capability_read_word(pdev, PCI_EXP_SLTSTA, &sts);\n\tsts &= (PCI_EXP_SLTSTA_PDC | PCI_EXP_SLTSTA_DLLSC);\n\tpcie_capability_write_word(pdev, PCI_EXP_SLTSTA, sts);\n\n\tpci_dbg(pdev, \"PCI slot [%s]: HP int! DLAct: %d, PresDet: %d\\n\",\n\t\t\tphp_slot->name,\n\t\t\t!!(sts & PCI_EXP_SLTSTA_DLLSC),\n\t\t\t!!(sts & PCI_EXP_SLTSTA_PDC));\n\n\tif (sts & PCI_EXP_SLTSTA_DLLSC) {\n\t\tpcie_capability_read_word(pdev, PCI_EXP_LNKSTA, &lsts);\n\t\tadded = !!(lsts & PCI_EXP_LNKSTA_DLLLA);\n\t} else if (!(php_slot->flags & PNV_PHP_FLAG_BROKEN_PDC) &&\n\t\t   (sts & PCI_EXP_SLTSTA_PDC)) {\n\t\tret = pnv_pci_get_presence_state(php_slot->id, &presence);\n\t\tif (ret) {\n\t\t\tSLOT_WARN(php_slot,\n\t\t\t\t  \"PCI slot [%s] error %d getting presence (0x%04x), to retry the operation.\\n\",\n\t\t\t\t  php_slot->name, ret, sts);\n\t\t\treturn IRQ_HANDLED;\n\t\t}\n\n\t\tadded = !!(presence == OPAL_PCI_SLOT_PRESENT);\n\t} else {\n\t\tpci_dbg(pdev, \"PCI slot [%s]: Spurious IRQ?\\n\", php_slot->name);\n\t\treturn IRQ_NONE;\n\t}\n\n\t \n\tif (!added) {\n\t\tpchild = list_first_entry_or_null(&php_slot->bus->devices,\n\t\t\t\t\t\t  struct pci_dev, bus_list);\n\t\tedev = pchild ? pci_dev_to_eeh_dev(pchild) : NULL;\n\t\tpe = edev ? edev->pe : NULL;\n\t\tif (pe) {\n\t\t\teeh_serialize_lock(&flags);\n\t\t\teeh_pe_mark_isolated(pe);\n\t\t\teeh_serialize_unlock(flags);\n\t\t\teeh_pe_set_option(pe, EEH_OPT_FREEZE_PE);\n\t\t}\n\t}\n\n\t \n\tevent = kzalloc(sizeof(*event), GFP_ATOMIC);\n\tif (!event) {\n\t\tSLOT_WARN(php_slot,\n\t\t\t  \"PCI slot [%s] missed hotplug event 0x%04x\\n\",\n\t\t\t  php_slot->name, sts);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tpci_info(pdev, \"PCI slot [%s] %s (IRQ: %d)\\n\",\n\t\t php_slot->name, added ? \"added\" : \"removed\", irq);\n\tINIT_WORK(&event->work, pnv_php_event_handler);\n\tevent->added = added;\n\tevent->php_slot = php_slot;\n\tqueue_work(php_slot->wq, &event->work);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void pnv_php_init_irq(struct pnv_php_slot *php_slot, int irq)\n{\n\tstruct pci_dev *pdev = php_slot->pdev;\n\tu32 broken_pdc = 0;\n\tu16 sts, ctrl;\n\tint ret;\n\n\t \n\tphp_slot->wq = alloc_workqueue(\"pciehp-%s\", 0, 0, php_slot->name);\n\tif (!php_slot->wq) {\n\t\tSLOT_WARN(php_slot, \"Cannot alloc workqueue\\n\");\n\t\tpnv_php_disable_irq(php_slot, true);\n\t\treturn;\n\t}\n\n\t \n\tret = of_property_read_u32(php_slot->dn, \"ibm,slot-broken-pdc\",\n\t\t\t\t   &broken_pdc);\n\tif (!ret && broken_pdc)\n\t\tphp_slot->flags |= PNV_PHP_FLAG_BROKEN_PDC;\n\n\t \n\tpcie_capability_read_word(pdev, PCI_EXP_SLTSTA, &sts);\n\tif (php_slot->flags & PNV_PHP_FLAG_BROKEN_PDC)\n\t\tsts |= PCI_EXP_SLTSTA_DLLSC;\n\telse\n\t\tsts |= (PCI_EXP_SLTSTA_PDC | PCI_EXP_SLTSTA_DLLSC);\n\tpcie_capability_write_word(pdev, PCI_EXP_SLTSTA, sts);\n\n\t \n\tret = request_irq(irq, pnv_php_interrupt, IRQF_SHARED,\n\t\t\t  php_slot->name, php_slot);\n\tif (ret) {\n\t\tpnv_php_disable_irq(php_slot, true);\n\t\tSLOT_WARN(php_slot, \"Error %d enabling IRQ %d\\n\", ret, irq);\n\t\treturn;\n\t}\n\n\t \n\tpcie_capability_read_word(pdev, PCI_EXP_SLTCTL, &ctrl);\n\tif (php_slot->flags & PNV_PHP_FLAG_BROKEN_PDC) {\n\t\tctrl &= ~PCI_EXP_SLTCTL_PDCE;\n\t\tctrl |= (PCI_EXP_SLTCTL_HPIE |\n\t\t\t PCI_EXP_SLTCTL_DLLSCE);\n\t} else {\n\t\tctrl |= (PCI_EXP_SLTCTL_HPIE |\n\t\t\t PCI_EXP_SLTCTL_PDCE |\n\t\t\t PCI_EXP_SLTCTL_DLLSCE);\n\t}\n\tpcie_capability_write_word(pdev, PCI_EXP_SLTCTL, ctrl);\n\n\t \n\tphp_slot->irq = irq;\n}\n\nstatic void pnv_php_enable_irq(struct pnv_php_slot *php_slot)\n{\n\tstruct pci_dev *pdev = php_slot->pdev;\n\tint irq, ret;\n\n\t \n\tif (pci_dev_msi_enabled(pdev))\n\t\treturn;\n\n\tret = pci_enable_device(pdev);\n\tif (ret) {\n\t\tSLOT_WARN(php_slot, \"Error %d enabling device\\n\", ret);\n\t\treturn;\n\t}\n\n\tpci_set_master(pdev);\n\n\t \n\tirq = pnv_php_enable_msix(php_slot);\n\tif (irq > 0) {\n\t\tpnv_php_init_irq(php_slot, irq);\n\t\treturn;\n\t}\n\n\t \n\tret = pci_enable_msi(pdev);\n\tif (!ret || pdev->irq) {\n\t\tirq = pdev->irq;\n\t\tpnv_php_init_irq(php_slot, irq);\n\t}\n}\n\nstatic int pnv_php_register_one(struct device_node *dn)\n{\n\tstruct pnv_php_slot *php_slot;\n\tu32 prop32;\n\tint ret;\n\n\t \n\tret = of_property_read_u32(dn, \"ibm,slot-pluggable\", &prop32);\n\tif (ret || !prop32)\n\t\treturn -ENXIO;\n\n\tret = of_property_read_u32(dn, \"ibm,reset-by-firmware\", &prop32);\n\tif (ret || !prop32)\n\t\treturn -ENXIO;\n\n\tphp_slot = pnv_php_alloc_slot(dn);\n\tif (!php_slot)\n\t\treturn -ENODEV;\n\n\tret = pnv_php_register_slot(php_slot);\n\tif (ret)\n\t\tgoto free_slot;\n\n\tret = pnv_php_enable(php_slot, false);\n\tif (ret)\n\t\tgoto unregister_slot;\n\n\t \n\tret = of_property_read_u32(dn, \"ibm,slot-surprise-pluggable\", &prop32);\n\tif (!ret && prop32)\n\t\tpnv_php_enable_irq(php_slot);\n\n\treturn 0;\n\nunregister_slot:\n\tpnv_php_unregister_one(php_slot->dn);\nfree_slot:\n\tpnv_php_put_slot(php_slot);\n\treturn ret;\n}\n\nstatic void pnv_php_register(struct device_node *dn)\n{\n\tstruct device_node *child;\n\n\t \n\tfor_each_child_of_node(dn, child) {\n\t\tpnv_php_register_one(child);\n\t\tpnv_php_register(child);\n\t}\n}\n\nstatic void pnv_php_unregister_one(struct device_node *dn)\n{\n\tstruct pnv_php_slot *php_slot;\n\n\tphp_slot = pnv_php_find_slot(dn);\n\tif (!php_slot)\n\t\treturn;\n\n\tphp_slot->state = PNV_PHP_STATE_OFFLINE;\n\tpci_hp_deregister(&php_slot->slot);\n\tpnv_php_release(php_slot);\n\tpnv_php_put_slot(php_slot);\n}\n\nstatic void pnv_php_unregister(struct device_node *dn)\n{\n\tstruct device_node *child;\n\n\t \n\tfor_each_child_of_node(dn, child) {\n\t\tpnv_php_unregister(child);\n\t\tpnv_php_unregister_one(child);\n\t}\n}\n\nstatic int __init pnv_php_init(void)\n{\n\tstruct device_node *dn;\n\n\tpr_info(DRIVER_DESC \" version: \" DRIVER_VERSION \"\\n\");\n\tfor_each_compatible_node(dn, NULL, \"ibm,ioda2-phb\")\n\t\tpnv_php_register(dn);\n\n\tfor_each_compatible_node(dn, NULL, \"ibm,ioda3-phb\")\n\t\tpnv_php_register(dn);\n\n\tfor_each_compatible_node(dn, NULL, \"ibm,ioda2-npu2-opencapi-phb\")\n\t\tpnv_php_register_one(dn);  \n\treturn 0;\n}\n\nstatic void __exit pnv_php_exit(void)\n{\n\tstruct device_node *dn;\n\n\tfor_each_compatible_node(dn, NULL, \"ibm,ioda2-phb\")\n\t\tpnv_php_unregister(dn);\n\n\tfor_each_compatible_node(dn, NULL, \"ibm,ioda3-phb\")\n\t\tpnv_php_unregister(dn);\n\n\tfor_each_compatible_node(dn, NULL, \"ibm,ioda2-npu2-opencapi-phb\")\n\t\tpnv_php_unregister_one(dn);  \n}\n\nmodule_init(pnv_php_init);\nmodule_exit(pnv_php_exit);\n\nMODULE_VERSION(DRIVER_VERSION);\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_DESCRIPTION(DRIVER_DESC);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}