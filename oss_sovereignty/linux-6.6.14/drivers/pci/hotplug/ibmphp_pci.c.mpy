{
  "module_name": "ibmphp_pci.c",
  "hash_id": "bd9d4c3a7945d344299e723cfeccc9d71d43b38f94c21e3b74fa83850ef2e259",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/hotplug/ibmphp_pci.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include \"ibmphp.h\"\n\n\nstatic int configure_device(struct pci_func *);\nstatic int configure_bridge(struct pci_func **, u8);\nstatic struct res_needed *scan_behind_bridge(struct pci_func *, u8);\nstatic int add_new_bus(struct bus_node *, struct resource_node *, struct resource_node *, struct resource_node *, u8);\nstatic u8 find_sec_number(u8 primary_busno, u8 slotno);\n\n \nstatic void assign_alt_irq(struct pci_func *cur_func, u8 class_code)\n{\n\tint j;\n\tfor (j = 0; j < 4; j++) {\n\t\tif (cur_func->irq[j] == 0xff) {\n\t\t\tswitch (class_code) {\n\t\t\t\tcase PCI_BASE_CLASS_STORAGE:\n\t\t\t\t\tcur_func->irq[j] = SCSI_IRQ;\n\t\t\t\t\tbreak;\n\t\t\t\tcase PCI_BASE_CLASS_NETWORK:\n\t\t\t\t\tcur_func->irq[j] = LAN_IRQ;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tcur_func->irq[j] = OTHER_IRQ;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\n \nint ibmphp_configure_card(struct pci_func *func, u8 slotno)\n{\n\tu16 vendor_id;\n\tu32 class;\n\tu8 class_code;\n\tu8 hdr_type, device, sec_number;\n\tu8 function;\n\tstruct pci_func *newfunc;\t \n\tstruct pci_func *cur_func, *prev_func;\n\tint rc, i, j;\n\tint cleanup_count;\n\tu8 flag;\n\tu8 valid_device = 0x00;  \n\n\tdebug(\"inside configure_card, func->busno = %x\\n\", func->busno);\n\n\tdevice = func->device;\n\tcur_func = func;\n\n\t \n\n\t \n\tfor (function = 0x00; function < 0x08; function++) {\n\t\tunsigned int devfn = PCI_DEVFN(device, function);\n\t\tibmphp_pci_bus->number = cur_func->busno;\n\n\t\tcur_func->function = function;\n\n\t\tdebug(\"inside the loop, cur_func->busno = %x, cur_func->device = %x, cur_func->function = %x\\n\",\n\t\t\tcur_func->busno, cur_func->device, cur_func->function);\n\n\t\tpci_bus_read_config_word(ibmphp_pci_bus, devfn, PCI_VENDOR_ID, &vendor_id);\n\n\t\tdebug(\"vendor_id is %x\\n\", vendor_id);\n\t\tif (vendor_id != PCI_VENDOR_ID_NOTVALID) {\n\t\t\t \n\t\t\tdebug(\"found valid device, vendor_id = %x\\n\", vendor_id);\n\n\t\t\t++valid_device;\n\n\t\t\t \n\n\t\t\tpci_bus_read_config_byte(ibmphp_pci_bus, devfn, PCI_HEADER_TYPE, &hdr_type);\n\t\t\tpci_bus_read_config_dword(ibmphp_pci_bus, devfn, PCI_CLASS_REVISION, &class);\n\n\t\t\tclass_code = class >> 24;\n\t\t\tdebug(\"hrd_type = %x, class = %x, class_code %x\\n\", hdr_type, class, class_code);\n\t\t\tclass >>= 8;\t \n\t\t\tif (class == PCI_CLASS_NOT_DEFINED_VGA) {\n\t\t\t\terr(\"The device %x is VGA compatible and as is not supported for hot plugging. \"\n\t\t\t\t     \"Please choose another device.\\n\", cur_func->device);\n\t\t\t\treturn -ENODEV;\n\t\t\t} else if (class == PCI_CLASS_DISPLAY_VGA) {\n\t\t\t\terr(\"The device %x is not supported for hot plugging. Please choose another device.\\n\",\n\t\t\t\t     cur_func->device);\n\t\t\t\treturn -ENODEV;\n\t\t\t}\n\t\t\tswitch (hdr_type) {\n\t\t\t\tcase PCI_HEADER_TYPE_NORMAL:\n\t\t\t\t\tdebug(\"single device case.... vendor id = %x, hdr_type = %x, class = %x\\n\", vendor_id, hdr_type, class);\n\t\t\t\t\tassign_alt_irq(cur_func, class_code);\n\t\t\t\t\trc = configure_device(cur_func);\n\t\t\t\t\tif (rc < 0) {\n\t\t\t\t\t\t \n\t\t\t\t\t\terr(\"was not able to configure devfunc %x on bus %x.\\n\",\n\t\t\t\t\t\t     cur_func->device, cur_func->busno);\n\t\t\t\t\t\tcleanup_count = 6;\n\t\t\t\t\t\tgoto error;\n\t\t\t\t\t}\n\t\t\t\t\tcur_func->next = NULL;\n\t\t\t\t\tfunction = 0x8;\n\t\t\t\t\tbreak;\n\t\t\t\tcase PCI_HEADER_TYPE_MULTIDEVICE:\n\t\t\t\t\tassign_alt_irq(cur_func, class_code);\n\t\t\t\t\trc = configure_device(cur_func);\n\t\t\t\t\tif (rc < 0) {\n\t\t\t\t\t\t \n\t\t\t\t\t\terr(\"was not able to configure devfunc %x on bus %x...bailing out\\n\",\n\t\t\t\t\t\t     cur_func->device, cur_func->busno);\n\t\t\t\t\t\tcleanup_count = 6;\n\t\t\t\t\t\tgoto error;\n\t\t\t\t\t}\n\t\t\t\t\tnewfunc = kzalloc(sizeof(*newfunc), GFP_KERNEL);\n\t\t\t\t\tif (!newfunc)\n\t\t\t\t\t\treturn -ENOMEM;\n\n\t\t\t\t\tnewfunc->busno = cur_func->busno;\n\t\t\t\t\tnewfunc->device = device;\n\t\t\t\t\tcur_func->next = newfunc;\n\t\t\t\t\tcur_func = newfunc;\n\t\t\t\t\tfor (j = 0; j < 4; j++)\n\t\t\t\t\t\tnewfunc->irq[j] = cur_func->irq[j];\n\t\t\t\t\tbreak;\n\t\t\t\tcase PCI_HEADER_TYPE_MULTIBRIDGE:\n\t\t\t\t\tclass >>= 8;\n\t\t\t\t\tif (class != PCI_CLASS_BRIDGE_PCI) {\n\t\t\t\t\t\terr(\"This %x is not PCI-to-PCI bridge, and as is not supported for hot-plugging.  Please insert another card.\\n\",\n\t\t\t\t\t\t     cur_func->device);\n\t\t\t\t\t\treturn -ENODEV;\n\t\t\t\t\t}\n\t\t\t\t\tassign_alt_irq(cur_func, class_code);\n\t\t\t\t\trc = configure_bridge(&cur_func, slotno);\n\t\t\t\t\tif (rc == -ENODEV) {\n\t\t\t\t\t\terr(\"You chose to insert Single Bridge, or nested bridges, this is not supported...\\n\");\n\t\t\t\t\t\terr(\"Bus %x, devfunc %x\\n\", cur_func->busno, cur_func->device);\n\t\t\t\t\t\treturn rc;\n\t\t\t\t\t}\n\t\t\t\t\tif (rc) {\n\t\t\t\t\t\t \n\t\t\t\t\t\terr(\"was not able to hot-add PPB properly.\\n\");\n\t\t\t\t\t\tfunc->bus = 1;  \n\t\t\t\t\t\tcleanup_count = 2;\n\t\t\t\t\t\tgoto error;\n\t\t\t\t\t}\n\n\t\t\t\t\tpci_bus_read_config_byte(ibmphp_pci_bus, devfn, PCI_SECONDARY_BUS, &sec_number);\n\t\t\t\t\tflag = 0;\n\t\t\t\t\tfor (i = 0; i < 32; i++) {\n\t\t\t\t\t\tif (func->devices[i]) {\n\t\t\t\t\t\t\tnewfunc = kzalloc(sizeof(*newfunc), GFP_KERNEL);\n\t\t\t\t\t\t\tif (!newfunc)\n\t\t\t\t\t\t\t\treturn -ENOMEM;\n\n\t\t\t\t\t\t\tnewfunc->busno = sec_number;\n\t\t\t\t\t\t\tnewfunc->device = (u8) i;\n\t\t\t\t\t\t\tfor (j = 0; j < 4; j++)\n\t\t\t\t\t\t\t\tnewfunc->irq[j] = cur_func->irq[j];\n\n\t\t\t\t\t\t\tif (flag) {\n\t\t\t\t\t\t\t\tfor (prev_func = cur_func; prev_func->next; prev_func = prev_func->next) ;\n\t\t\t\t\t\t\t\tprev_func->next = newfunc;\n\t\t\t\t\t\t\t} else\n\t\t\t\t\t\t\t\tcur_func->next = newfunc;\n\n\t\t\t\t\t\t\trc = ibmphp_configure_card(newfunc, slotno);\n\t\t\t\t\t\t\t \n\t\t\t\t\t\t\tif (rc) {\n\t\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t\tfunc->bus = 1;  \n\t\t\t\t\t\t\t\tcleanup_count = 2;\n\t\t\t\t\t\t\t\tgoto error;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tflag = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tnewfunc = kzalloc(sizeof(*newfunc), GFP_KERNEL);\n\t\t\t\t\tif (!newfunc)\n\t\t\t\t\t\treturn -ENOMEM;\n\n\t\t\t\t\tnewfunc->busno = cur_func->busno;\n\t\t\t\t\tnewfunc->device = device;\n\t\t\t\t\tfor (j = 0; j < 4; j++)\n\t\t\t\t\t\tnewfunc->irq[j] = cur_func->irq[j];\n\t\t\t\t\tfor (prev_func = cur_func; prev_func->next; prev_func = prev_func->next);\n\t\t\t\t\tprev_func->next = newfunc;\n\t\t\t\t\tcur_func = newfunc;\n\t\t\t\t\tbreak;\n\t\t\t\tcase PCI_HEADER_TYPE_BRIDGE:\n\t\t\t\t\tclass >>= 8;\n\t\t\t\t\tdebug(\"class now is %x\\n\", class);\n\t\t\t\t\tif (class != PCI_CLASS_BRIDGE_PCI) {\n\t\t\t\t\t\terr(\"This %x is not PCI-to-PCI bridge, and as is not supported for hot-plugging.  Please insert another card.\\n\",\n\t\t\t\t\t\t     cur_func->device);\n\t\t\t\t\t\treturn -ENODEV;\n\t\t\t\t\t}\n\n\t\t\t\t\tassign_alt_irq(cur_func, class_code);\n\n\t\t\t\t\tdebug(\"cur_func->busno b4 configure_bridge is %x\\n\", cur_func->busno);\n\t\t\t\t\trc = configure_bridge(&cur_func, slotno);\n\t\t\t\t\tif (rc == -ENODEV) {\n\t\t\t\t\t\terr(\"You chose to insert Single Bridge, or nested bridges, this is not supported...\\n\");\n\t\t\t\t\t\terr(\"Bus %x, devfunc %x\\n\", cur_func->busno, cur_func->device);\n\t\t\t\t\t\treturn rc;\n\t\t\t\t\t}\n\t\t\t\t\tif (rc) {\n\t\t\t\t\t\t \n\t\t\t\t\t\tfunc->bus = 1;  \n\t\t\t\t\t\terr(\"was not able to hot-add PPB properly.\\n\");\n\t\t\t\t\t\tcleanup_count = 2;\n\t\t\t\t\t\tgoto error;\n\t\t\t\t\t}\n\t\t\t\t\tdebug(\"cur_func->busno = %x, device = %x, function = %x\\n\",\n\t\t\t\t\t\tcur_func->busno, device, function);\n\t\t\t\t\tpci_bus_read_config_byte(ibmphp_pci_bus, devfn, PCI_SECONDARY_BUS, &sec_number);\n\t\t\t\t\tdebug(\"after configuring bridge..., sec_number = %x\\n\", sec_number);\n\t\t\t\t\tflag = 0;\n\t\t\t\t\tfor (i = 0; i < 32; i++) {\n\t\t\t\t\t\tif (func->devices[i]) {\n\t\t\t\t\t\t\tdebug(\"inside for loop, device is %x\\n\", i);\n\t\t\t\t\t\t\tnewfunc = kzalloc(sizeof(*newfunc), GFP_KERNEL);\n\t\t\t\t\t\t\tif (!newfunc)\n\t\t\t\t\t\t\t\treturn -ENOMEM;\n\n\t\t\t\t\t\t\tnewfunc->busno = sec_number;\n\t\t\t\t\t\t\tnewfunc->device = (u8) i;\n\t\t\t\t\t\t\tfor (j = 0; j < 4; j++)\n\t\t\t\t\t\t\t\tnewfunc->irq[j] = cur_func->irq[j];\n\n\t\t\t\t\t\t\tif (flag) {\n\t\t\t\t\t\t\t\tfor (prev_func = cur_func; prev_func->next; prev_func = prev_func->next);\n\t\t\t\t\t\t\t\tprev_func->next = newfunc;\n\t\t\t\t\t\t\t} else\n\t\t\t\t\t\t\t\tcur_func->next = newfunc;\n\n\t\t\t\t\t\t\trc = ibmphp_configure_card(newfunc, slotno);\n\n\t\t\t\t\t\t\t \n\t\t\t\t\t\t\tif (rc) {\n\t\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t\tfunc->bus = 1;  \n\t\t\t\t\t\t\t\tcleanup_count = 2;\n\t\t\t\t\t\t\t\tgoto error;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tflag = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tfunction = 0x8;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\terr(\"MAJOR PROBLEM!!!!, header type not supported? %x\\n\", hdr_type);\n\t\t\t\t\treturn -ENXIO;\n\t\t\t}\t \n\t\t}\t \n\t}\t \n\n\tif (!valid_device) {\n\t\terr(\"Cannot find any valid devices on the card.  Or unable to read from card.\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n\nerror:\n\tfor (i = 0; i < cleanup_count; i++) {\n\t\tif (cur_func->io[i]) {\n\t\t\tibmphp_remove_resource(cur_func->io[i]);\n\t\t\tcur_func->io[i] = NULL;\n\t\t} else if (cur_func->pfmem[i]) {\n\t\t\tibmphp_remove_resource(cur_func->pfmem[i]);\n\t\t\tcur_func->pfmem[i] = NULL;\n\t\t} else if (cur_func->mem[i]) {\n\t\t\tibmphp_remove_resource(cur_func->mem[i]);\n\t\t\tcur_func->mem[i] = NULL;\n\t\t}\n\t}\n\treturn rc;\n}\n\n \nstatic int configure_device(struct pci_func *func)\n{\n\tu32 bar[6];\n\tstatic const u32 address[] = {\n\t\tPCI_BASE_ADDRESS_0,\n\t\tPCI_BASE_ADDRESS_1,\n\t\tPCI_BASE_ADDRESS_2,\n\t\tPCI_BASE_ADDRESS_3,\n\t\tPCI_BASE_ADDRESS_4,\n\t\tPCI_BASE_ADDRESS_5,\n\t\t0\n\t};\n\tu8 irq;\n\tint count;\n\tint len[6];\n\tstruct resource_node *io[6];\n\tstruct resource_node *mem[6];\n\tstruct resource_node *mem_tmp;\n\tstruct resource_node *pfmem[6];\n\tunsigned int devfn;\n\n\tdebug(\"%s - inside\\n\", __func__);\n\n\tdevfn = PCI_DEVFN(func->device, func->function);\n\tibmphp_pci_bus->number = func->busno;\n\n\tfor (count = 0; address[count]; count++) {\t \n\n\t\t \n\t\tpci_bus_write_config_dword(ibmphp_pci_bus, devfn, address[count], 0xFFFFFFFF);\n\t\tpci_bus_read_config_dword(ibmphp_pci_bus, devfn, address[count], &bar[count]);\n\n\t\tif (!bar[count])\t \n\t\t\tcontinue;\n\n\t\tdebug(\"Device %x BAR %d wants %x\\n\", func->device, count, bar[count]);\n\n\t\tif (bar[count] & PCI_BASE_ADDRESS_SPACE_IO) {\n\t\t\t \n\t\t\tdebug(\"inside IO SPACE\\n\");\n\n\t\t\tlen[count] = bar[count] & 0xFFFFFFFC;\n\t\t\tlen[count] = ~len[count] + 1;\n\n\t\t\tdebug(\"len[count] in IO %x, count %d\\n\", len[count], count);\n\n\t\t\tio[count] = kzalloc(sizeof(struct resource_node), GFP_KERNEL);\n\n\t\t\tif (!io[count])\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tio[count]->type = IO;\n\t\t\tio[count]->busno = func->busno;\n\t\t\tio[count]->devfunc = PCI_DEVFN(func->device, func->function);\n\t\t\tio[count]->len = len[count];\n\t\t\tif (ibmphp_check_resource(io[count], 0) == 0) {\n\t\t\t\tibmphp_add_resource(io[count]);\n\t\t\t\tfunc->io[count] = io[count];\n\t\t\t} else {\n\t\t\t\terr(\"cannot allocate requested io for bus %x device %x function %x len %x\\n\",\n\t\t\t\t     func->busno, func->device, func->function, len[count]);\n\t\t\t\tkfree(io[count]);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t\tpci_bus_write_config_dword(ibmphp_pci_bus, devfn, address[count], func->io[count]->start);\n\n\t\t\t \n\t\t\tdebug(\"b4 writing, the IO address is %x\\n\", func->io[count]->start);\n\t\t\tpci_bus_read_config_dword(ibmphp_pci_bus, devfn, address[count], &bar[count]);\n\t\t\tdebug(\"after writing.... the start address is %x\\n\", bar[count]);\n\t\t\t \n\n\t\t} else {\n\t\t\t \n\t\t\tif (bar[count] & PCI_BASE_ADDRESS_MEM_PREFETCH) {\n\t\t\t\t \n\t\t\t\tdebug(\"PFMEM SPACE\\n\");\n\n\t\t\t\tlen[count] = bar[count] & 0xFFFFFFF0;\n\t\t\t\tlen[count] = ~len[count] + 1;\n\n\t\t\t\tdebug(\"len[count] in PFMEM %x, count %d\\n\", len[count], count);\n\n\t\t\t\tpfmem[count] = kzalloc(sizeof(struct resource_node), GFP_KERNEL);\n\t\t\t\tif (!pfmem[count])\n\t\t\t\t\treturn -ENOMEM;\n\n\t\t\t\tpfmem[count]->type = PFMEM;\n\t\t\t\tpfmem[count]->busno = func->busno;\n\t\t\t\tpfmem[count]->devfunc = PCI_DEVFN(func->device,\n\t\t\t\t\t\t\tfunc->function);\n\t\t\t\tpfmem[count]->len = len[count];\n\t\t\t\tpfmem[count]->fromMem = 0;\n\t\t\t\tif (ibmphp_check_resource(pfmem[count], 0) == 0) {\n\t\t\t\t\tibmphp_add_resource(pfmem[count]);\n\t\t\t\t\tfunc->pfmem[count] = pfmem[count];\n\t\t\t\t} else {\n\t\t\t\t\tmem_tmp = kzalloc(sizeof(*mem_tmp), GFP_KERNEL);\n\t\t\t\t\tif (!mem_tmp) {\n\t\t\t\t\t\tkfree(pfmem[count]);\n\t\t\t\t\t\treturn -ENOMEM;\n\t\t\t\t\t}\n\t\t\t\t\tmem_tmp->type = MEM;\n\t\t\t\t\tmem_tmp->busno = pfmem[count]->busno;\n\t\t\t\t\tmem_tmp->devfunc = pfmem[count]->devfunc;\n\t\t\t\t\tmem_tmp->len = pfmem[count]->len;\n\t\t\t\t\tdebug(\"there's no pfmem... going into mem.\\n\");\n\t\t\t\t\tif (ibmphp_check_resource(mem_tmp, 0) == 0) {\n\t\t\t\t\t\tibmphp_add_resource(mem_tmp);\n\t\t\t\t\t\tpfmem[count]->fromMem = 1;\n\t\t\t\t\t\tpfmem[count]->rangeno = mem_tmp->rangeno;\n\t\t\t\t\t\tpfmem[count]->start = mem_tmp->start;\n\t\t\t\t\t\tpfmem[count]->end = mem_tmp->end;\n\t\t\t\t\t\tibmphp_add_pfmem_from_mem(pfmem[count]);\n\t\t\t\t\t\tfunc->pfmem[count] = pfmem[count];\n\t\t\t\t\t} else {\n\t\t\t\t\t\terr(\"cannot allocate requested pfmem for bus %x, device %x, len %x\\n\",\n\t\t\t\t\t\t     func->busno, func->device, len[count]);\n\t\t\t\t\t\tkfree(mem_tmp);\n\t\t\t\t\t\tkfree(pfmem[count]);\n\t\t\t\t\t\treturn -EIO;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tpci_bus_write_config_dword(ibmphp_pci_bus, devfn, address[count], func->pfmem[count]->start);\n\n\t\t\t\t \n\t\t\t\tdebug(\"b4 writing, start address is %x\\n\", func->pfmem[count]->start);\n\t\t\t\tpci_bus_read_config_dword(ibmphp_pci_bus, devfn, address[count], &bar[count]);\n\t\t\t\tdebug(\"after writing, start address is %x\\n\", bar[count]);\n\t\t\t\t \n\n\t\t\t\tif (bar[count] & PCI_BASE_ADDRESS_MEM_TYPE_64) {\t \n\t\t\t\t\tdebug(\"inside the mem 64 case, count %d\\n\", count);\n\t\t\t\t\tcount += 1;\n\t\t\t\t\t \n\t\t\t\t\tpci_bus_write_config_dword(ibmphp_pci_bus, devfn, address[count], 0x00000000);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tdebug(\"REGULAR MEM SPACE\\n\");\n\n\t\t\t\tlen[count] = bar[count] & 0xFFFFFFF0;\n\t\t\t\tlen[count] = ~len[count] + 1;\n\n\t\t\t\tdebug(\"len[count] in Mem %x, count %d\\n\", len[count], count);\n\n\t\t\t\tmem[count] = kzalloc(sizeof(struct resource_node), GFP_KERNEL);\n\t\t\t\tif (!mem[count])\n\t\t\t\t\treturn -ENOMEM;\n\n\t\t\t\tmem[count]->type = MEM;\n\t\t\t\tmem[count]->busno = func->busno;\n\t\t\t\tmem[count]->devfunc = PCI_DEVFN(func->device,\n\t\t\t\t\t\t\tfunc->function);\n\t\t\t\tmem[count]->len = len[count];\n\t\t\t\tif (ibmphp_check_resource(mem[count], 0) == 0) {\n\t\t\t\t\tibmphp_add_resource(mem[count]);\n\t\t\t\t\tfunc->mem[count] = mem[count];\n\t\t\t\t} else {\n\t\t\t\t\terr(\"cannot allocate requested mem for bus %x, device %x, len %x\\n\",\n\t\t\t\t\t     func->busno, func->device, len[count]);\n\t\t\t\t\tkfree(mem[count]);\n\t\t\t\t\treturn -EIO;\n\t\t\t\t}\n\t\t\t\tpci_bus_write_config_dword(ibmphp_pci_bus, devfn, address[count], func->mem[count]->start);\n\t\t\t\t \n\t\t\t\tdebug(\"b4 writing, start address is %x\\n\", func->mem[count]->start);\n\t\t\t\tpci_bus_read_config_dword(ibmphp_pci_bus, devfn, address[count], &bar[count]);\n\t\t\t\tdebug(\"after writing, the address is %x\\n\", bar[count]);\n\t\t\t\t \n\n\t\t\t\tif (bar[count] & PCI_BASE_ADDRESS_MEM_TYPE_64) {\n\t\t\t\t\t \n\t\t\t\t\tdebug(\"inside mem 64 case, reg. mem, count %d\\n\", count);\n\t\t\t\t\tcount += 1;\n\t\t\t\t\t \n\t\t\t\t\tpci_bus_write_config_dword(ibmphp_pci_bus, devfn, address[count], 0x00000000);\n\t\t\t\t}\n\t\t\t}\n\t\t}\t\t \n\t}\t\t\t \n\n\tfunc->bus = 0;\t\t \n\tpci_bus_read_config_byte(ibmphp_pci_bus, devfn, PCI_INTERRUPT_PIN, &irq);\n\tif ((irq > 0x00) && (irq < 0x05))\n\t\tpci_bus_write_config_byte(ibmphp_pci_bus, devfn, PCI_INTERRUPT_LINE, func->irq[irq - 1]);\n\n\tpci_bus_write_config_byte(ibmphp_pci_bus, devfn, PCI_CACHE_LINE_SIZE, CACHE);\n\tpci_bus_write_config_byte(ibmphp_pci_bus, devfn, PCI_LATENCY_TIMER, LATENCY);\n\n\tpci_bus_write_config_dword(ibmphp_pci_bus, devfn, PCI_ROM_ADDRESS, 0x00L);\n\tpci_bus_write_config_word(ibmphp_pci_bus, devfn, PCI_COMMAND, DEVICEENABLE);\n\n\treturn 0;\n}\n\n \nstatic int configure_bridge(struct pci_func **func_passed, u8 slotno)\n{\n\tint count;\n\tint i;\n\tint rc;\n\tu8 sec_number;\n\tu8 io_base;\n\tu16 pfmem_base;\n\tu32 bar[2];\n\tu32 len[2];\n\tu8 flag_io = 0;\n\tu8 flag_mem = 0;\n\tu8 flag_pfmem = 0;\n\tu8 need_io_upper = 0;\n\tu8 need_pfmem_upper = 0;\n\tstruct res_needed *amount_needed = NULL;\n\tstruct resource_node *io = NULL;\n\tstruct resource_node *bus_io[2] = {NULL, NULL};\n\tstruct resource_node *mem = NULL;\n\tstruct resource_node *bus_mem[2] = {NULL, NULL};\n\tstruct resource_node *mem_tmp = NULL;\n\tstruct resource_node *pfmem = NULL;\n\tstruct resource_node *bus_pfmem[2] = {NULL, NULL};\n\tstruct bus_node *bus;\n\tstatic const u32 address[] = {\n\t\tPCI_BASE_ADDRESS_0,\n\t\tPCI_BASE_ADDRESS_1,\n\t\t0\n\t};\n\tstruct pci_func *func = *func_passed;\n\tunsigned int devfn;\n\tu8 irq;\n\tint retval;\n\n\tdebug(\"%s - enter\\n\", __func__);\n\n\tdevfn = PCI_DEVFN(func->function, func->device);\n\tibmphp_pci_bus->number = func->busno;\n\n\t \n\n\tpci_bus_write_config_byte(ibmphp_pci_bus, devfn, PCI_PRIMARY_BUS, func->busno);\n\n\t \n\n\t \n\tsec_number = find_sec_number(func->busno, slotno);\n\tif (sec_number == 0xff) {\n\t\terr(\"cannot allocate secondary bus number for the bridged device\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdebug(\"after find_sec_number, the number we got is %x\\n\", sec_number);\n\tdebug(\"AFTER FIND_SEC_NUMBER, func->busno IS %x\\n\", func->busno);\n\n\tpci_bus_write_config_byte(ibmphp_pci_bus, devfn, PCI_SECONDARY_BUS, sec_number);\n\n\t \n\n\tpci_bus_write_config_byte(ibmphp_pci_bus, devfn, PCI_SUBORDINATE_BUS, sec_number);\n\n\t \n\n\tpci_bus_write_config_byte(ibmphp_pci_bus, devfn, PCI_CACHE_LINE_SIZE, CACHE);\n\tpci_bus_write_config_byte(ibmphp_pci_bus, devfn, PCI_LATENCY_TIMER, LATENCY);\n\tpci_bus_write_config_byte(ibmphp_pci_bus, devfn, PCI_SEC_LATENCY_TIMER, LATENCY);\n\n\tdebug(\"func->busno is %x\\n\", func->busno);\n\tdebug(\"sec_number after writing is %x\\n\", sec_number);\n\n\n\t \n\n\n\t \n\tfor (count = 0; address[count]; count++) {\t \n\t\tpci_bus_write_config_dword(ibmphp_pci_bus, devfn, address[count], 0xFFFFFFFF);\n\t\tpci_bus_read_config_dword(ibmphp_pci_bus, devfn, address[count], &bar[count]);\n\n\t\tif (!bar[count]) {\n\t\t\t \n\t\t\tdebug(\"so we come here then, eh?, count = %d\\n\", count);\n\t\t\tcontinue;\n\t\t}\n\t\t\n\n\t\tdebug(\"Bar %d wants %x\\n\", count, bar[count]);\n\n\t\tif (bar[count] & PCI_BASE_ADDRESS_SPACE_IO) {\n\t\t\t \n\t\t\tlen[count] = bar[count] & 0xFFFFFFFC;\n\t\t\tlen[count] = ~len[count] + 1;\n\n\t\t\tdebug(\"len[count] in IO = %x\\n\", len[count]);\n\n\t\t\tbus_io[count] = kzalloc(sizeof(struct resource_node), GFP_KERNEL);\n\n\t\t\tif (!bus_io[count]) {\n\t\t\t\tretval = -ENOMEM;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tbus_io[count]->type = IO;\n\t\t\tbus_io[count]->busno = func->busno;\n\t\t\tbus_io[count]->devfunc = PCI_DEVFN(func->device,\n\t\t\t\t\t\t\tfunc->function);\n\t\t\tbus_io[count]->len = len[count];\n\t\t\tif (ibmphp_check_resource(bus_io[count], 0) == 0) {\n\t\t\t\tibmphp_add_resource(bus_io[count]);\n\t\t\t\tfunc->io[count] = bus_io[count];\n\t\t\t} else {\n\t\t\t\terr(\"cannot allocate requested io for bus %x, device %x, len %x\\n\",\n\t\t\t\t     func->busno, func->device, len[count]);\n\t\t\t\tkfree(bus_io[count]);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\n\t\t\tpci_bus_write_config_dword(ibmphp_pci_bus, devfn, address[count], func->io[count]->start);\n\n\t\t} else {\n\t\t\t \n\t\t\tif (bar[count] & PCI_BASE_ADDRESS_MEM_PREFETCH) {\n\t\t\t\t \n\t\t\t\tlen[count] = bar[count] & 0xFFFFFFF0;\n\t\t\t\tlen[count] = ~len[count] + 1;\n\n\t\t\t\tdebug(\"len[count] in PFMEM = %x\\n\", len[count]);\n\n\t\t\t\tbus_pfmem[count] = kzalloc(sizeof(struct resource_node), GFP_KERNEL);\n\t\t\t\tif (!bus_pfmem[count]) {\n\t\t\t\t\tretval = -ENOMEM;\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\tbus_pfmem[count]->type = PFMEM;\n\t\t\t\tbus_pfmem[count]->busno = func->busno;\n\t\t\t\tbus_pfmem[count]->devfunc = PCI_DEVFN(func->device,\n\t\t\t\t\t\t\tfunc->function);\n\t\t\t\tbus_pfmem[count]->len = len[count];\n\t\t\t\tbus_pfmem[count]->fromMem = 0;\n\t\t\t\tif (ibmphp_check_resource(bus_pfmem[count], 0) == 0) {\n\t\t\t\t\tibmphp_add_resource(bus_pfmem[count]);\n\t\t\t\t\tfunc->pfmem[count] = bus_pfmem[count];\n\t\t\t\t} else {\n\t\t\t\t\tmem_tmp = kzalloc(sizeof(*mem_tmp), GFP_KERNEL);\n\t\t\t\t\tif (!mem_tmp) {\n\t\t\t\t\t\tretval = -ENOMEM;\n\t\t\t\t\t\tgoto error;\n\t\t\t\t\t}\n\t\t\t\t\tmem_tmp->type = MEM;\n\t\t\t\t\tmem_tmp->busno = bus_pfmem[count]->busno;\n\t\t\t\t\tmem_tmp->devfunc = bus_pfmem[count]->devfunc;\n\t\t\t\t\tmem_tmp->len = bus_pfmem[count]->len;\n\t\t\t\t\tif (ibmphp_check_resource(mem_tmp, 0) == 0) {\n\t\t\t\t\t\tibmphp_add_resource(mem_tmp);\n\t\t\t\t\t\tbus_pfmem[count]->fromMem = 1;\n\t\t\t\t\t\tbus_pfmem[count]->rangeno = mem_tmp->rangeno;\n\t\t\t\t\t\tibmphp_add_pfmem_from_mem(bus_pfmem[count]);\n\t\t\t\t\t\tfunc->pfmem[count] = bus_pfmem[count];\n\t\t\t\t\t} else {\n\t\t\t\t\t\terr(\"cannot allocate requested pfmem for bus %x, device %x, len %x\\n\",\n\t\t\t\t\t\t     func->busno, func->device, len[count]);\n\t\t\t\t\t\tkfree(mem_tmp);\n\t\t\t\t\t\tkfree(bus_pfmem[count]);\n\t\t\t\t\t\treturn -EIO;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tpci_bus_write_config_dword(ibmphp_pci_bus, devfn, address[count], func->pfmem[count]->start);\n\n\t\t\t\tif (bar[count] & PCI_BASE_ADDRESS_MEM_TYPE_64) {\n\t\t\t\t\t \n\t\t\t\t\tcount += 1;\n\t\t\t\t\t \n\t\t\t\t\tpci_bus_write_config_dword(ibmphp_pci_bus, devfn, address[count], 0x00000000);\n\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tlen[count] = bar[count] & 0xFFFFFFF0;\n\t\t\t\tlen[count] = ~len[count] + 1;\n\n\t\t\t\tdebug(\"len[count] in Memory is %x\\n\", len[count]);\n\n\t\t\t\tbus_mem[count] = kzalloc(sizeof(struct resource_node), GFP_KERNEL);\n\t\t\t\tif (!bus_mem[count]) {\n\t\t\t\t\tretval = -ENOMEM;\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\tbus_mem[count]->type = MEM;\n\t\t\t\tbus_mem[count]->busno = func->busno;\n\t\t\t\tbus_mem[count]->devfunc = PCI_DEVFN(func->device,\n\t\t\t\t\t\t\tfunc->function);\n\t\t\t\tbus_mem[count]->len = len[count];\n\t\t\t\tif (ibmphp_check_resource(bus_mem[count], 0) == 0) {\n\t\t\t\t\tibmphp_add_resource(bus_mem[count]);\n\t\t\t\t\tfunc->mem[count] = bus_mem[count];\n\t\t\t\t} else {\n\t\t\t\t\terr(\"cannot allocate requested mem for bus %x, device %x, len %x\\n\",\n\t\t\t\t\t     func->busno, func->device, len[count]);\n\t\t\t\t\tkfree(bus_mem[count]);\n\t\t\t\t\treturn -EIO;\n\t\t\t\t}\n\n\t\t\t\tpci_bus_write_config_dword(ibmphp_pci_bus, devfn, address[count], func->mem[count]->start);\n\n\t\t\t\tif (bar[count] & PCI_BASE_ADDRESS_MEM_TYPE_64) {\n\t\t\t\t\t \n\t\t\t\t\tcount += 1;\n\t\t\t\t\t \n\t\t\t\t\tpci_bus_write_config_dword(ibmphp_pci_bus, devfn, address[count], 0x00000000);\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\t\t \n\t}\t\t\t \n\n\t \n\tamount_needed = scan_behind_bridge(func, sec_number);\n\tif (amount_needed == NULL)\n\t\treturn -ENOMEM;\n\n\tibmphp_pci_bus->number = func->busno;\n\tdebug(\"after coming back from scan_behind_bridge\\n\");\n\tdebug(\"amount_needed->not_correct = %x\\n\", amount_needed->not_correct);\n\tdebug(\"amount_needed->io = %x\\n\", amount_needed->io);\n\tdebug(\"amount_needed->mem = %x\\n\", amount_needed->mem);\n\tdebug(\"amount_needed->pfmem =  %x\\n\", amount_needed->pfmem);\n\n\tif (amount_needed->not_correct) {\n\t\tdebug(\"amount_needed is not correct\\n\");\n\t\tfor (count = 0; address[count]; count++) {\n\t\t\t \n\t\t\tif (bus_io[count]) {\n\t\t\t\tibmphp_remove_resource(bus_io[count]);\n\t\t\t\tfunc->io[count] = NULL;\n\t\t\t} else if (bus_pfmem[count]) {\n\t\t\t\tibmphp_remove_resource(bus_pfmem[count]);\n\t\t\t\tfunc->pfmem[count] = NULL;\n\t\t\t} else if (bus_mem[count]) {\n\t\t\t\tibmphp_remove_resource(bus_mem[count]);\n\t\t\t\tfunc->mem[count] = NULL;\n\t\t\t}\n\t\t}\n\t\tkfree(amount_needed);\n\t\treturn -ENODEV;\n\t}\n\n\tif (!amount_needed->io) {\n\t\tdebug(\"it doesn't want IO?\\n\");\n\t\tflag_io = 1;\n\t} else {\n\t\tdebug(\"it wants %x IO behind the bridge\\n\", amount_needed->io);\n\t\tio = kzalloc(sizeof(*io), GFP_KERNEL);\n\n\t\tif (!io) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto error;\n\t\t}\n\t\tio->type = IO;\n\t\tio->busno = func->busno;\n\t\tio->devfunc = PCI_DEVFN(func->device, func->function);\n\t\tio->len = amount_needed->io;\n\t\tif (ibmphp_check_resource(io, 1) == 0) {\n\t\t\tdebug(\"were we able to add io\\n\");\n\t\t\tibmphp_add_resource(io);\n\t\t\tflag_io = 1;\n\t\t}\n\t}\n\n\tif (!amount_needed->mem) {\n\t\tdebug(\"it doesn't want n.e.memory?\\n\");\n\t\tflag_mem = 1;\n\t} else {\n\t\tdebug(\"it wants %x memory behind the bridge\\n\", amount_needed->mem);\n\t\tmem = kzalloc(sizeof(*mem), GFP_KERNEL);\n\t\tif (!mem) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto error;\n\t\t}\n\t\tmem->type = MEM;\n\t\tmem->busno = func->busno;\n\t\tmem->devfunc = PCI_DEVFN(func->device, func->function);\n\t\tmem->len = amount_needed->mem;\n\t\tif (ibmphp_check_resource(mem, 1) == 0) {\n\t\t\tibmphp_add_resource(mem);\n\t\t\tflag_mem = 1;\n\t\t\tdebug(\"were we able to add mem\\n\");\n\t\t}\n\t}\n\n\tif (!amount_needed->pfmem) {\n\t\tdebug(\"it doesn't want n.e.pfmem mem?\\n\");\n\t\tflag_pfmem = 1;\n\t} else {\n\t\tdebug(\"it wants %x pfmemory behind the bridge\\n\", amount_needed->pfmem);\n\t\tpfmem = kzalloc(sizeof(*pfmem), GFP_KERNEL);\n\t\tif (!pfmem) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto error;\n\t\t}\n\t\tpfmem->type = PFMEM;\n\t\tpfmem->busno = func->busno;\n\t\tpfmem->devfunc = PCI_DEVFN(func->device, func->function);\n\t\tpfmem->len = amount_needed->pfmem;\n\t\tpfmem->fromMem = 0;\n\t\tif (ibmphp_check_resource(pfmem, 1) == 0) {\n\t\t\tibmphp_add_resource(pfmem);\n\t\t\tflag_pfmem = 1;\n\t\t} else {\n\t\t\tmem_tmp = kzalloc(sizeof(*mem_tmp), GFP_KERNEL);\n\t\t\tif (!mem_tmp) {\n\t\t\t\tretval = -ENOMEM;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tmem_tmp->type = MEM;\n\t\t\tmem_tmp->busno = pfmem->busno;\n\t\t\tmem_tmp->devfunc = pfmem->devfunc;\n\t\t\tmem_tmp->len = pfmem->len;\n\t\t\tif (ibmphp_check_resource(mem_tmp, 1) == 0) {\n\t\t\t\tibmphp_add_resource(mem_tmp);\n\t\t\t\tpfmem->fromMem = 1;\n\t\t\t\tpfmem->rangeno = mem_tmp->rangeno;\n\t\t\t\tibmphp_add_pfmem_from_mem(pfmem);\n\t\t\t\tflag_pfmem = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tdebug(\"b4 if (flag_io && flag_mem && flag_pfmem)\\n\");\n\tdebug(\"flag_io = %x, flag_mem = %x, flag_pfmem = %x\\n\", flag_io, flag_mem, flag_pfmem);\n\n\tif (flag_io && flag_mem && flag_pfmem) {\n\t\t \n\t\tbus = ibmphp_find_res_bus(sec_number);\n\t\tif (!bus) {\n\t\t\tbus = kzalloc(sizeof(*bus), GFP_KERNEL);\n\t\t\tif (!bus) {\n\t\t\t\tretval = -ENOMEM;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tbus->busno = sec_number;\n\t\t\tdebug(\"b4 adding new bus\\n\");\n\t\t\trc = add_new_bus(bus, io, mem, pfmem, func->busno);\n\t\t} else if (!(bus->rangeIO) && !(bus->rangeMem) && !(bus->rangePFMem))\n\t\t\trc = add_new_bus(bus, io, mem, pfmem, 0xFF);\n\t\telse {\n\t\t\terr(\"expected bus structure not empty?\\n\");\n\t\t\tretval = -EIO;\n\t\t\tgoto error;\n\t\t}\n\t\tif (rc) {\n\t\t\tif (rc == -ENOMEM) {\n\t\t\t\tibmphp_remove_bus(bus, func->busno);\n\t\t\t\tkfree(amount_needed);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t\tretval = rc;\n\t\t\tgoto error;\n\t\t}\n\t\tpci_bus_read_config_byte(ibmphp_pci_bus, devfn, PCI_IO_BASE, &io_base);\n\t\tpci_bus_read_config_word(ibmphp_pci_bus, devfn, PCI_PREF_MEMORY_BASE, &pfmem_base);\n\n\t\tif ((io_base & PCI_IO_RANGE_TYPE_MASK) == PCI_IO_RANGE_TYPE_32) {\n\t\t\tdebug(\"io 32\\n\");\n\t\t\tneed_io_upper = 1;\n\t\t}\n\t\tif ((pfmem_base & PCI_PREF_RANGE_TYPE_MASK) == PCI_PREF_RANGE_TYPE_64) {\n\t\t\tdebug(\"pfmem 64\\n\");\n\t\t\tneed_pfmem_upper = 1;\n\t\t}\n\n\t\tif (bus->noIORanges) {\n\t\t\tpci_bus_write_config_byte(ibmphp_pci_bus, devfn, PCI_IO_BASE, 0x00 | bus->rangeIO->start >> 8);\n\t\t\tpci_bus_write_config_byte(ibmphp_pci_bus, devfn, PCI_IO_LIMIT, 0x00 | bus->rangeIO->end >> 8);\n\n\t\t\t \n\n\t\t\tif (need_io_upper) {\t \n\t\t\t\tpci_bus_write_config_word(ibmphp_pci_bus, devfn, PCI_IO_BASE_UPPER16, 0x0000);\n\t\t\t\tpci_bus_write_config_word(ibmphp_pci_bus, devfn, PCI_IO_LIMIT_UPPER16, 0x0000);\n\t\t\t}\n\t\t} else {\n\t\t\tpci_bus_write_config_byte(ibmphp_pci_bus, devfn, PCI_IO_BASE, 0x00);\n\t\t\tpci_bus_write_config_byte(ibmphp_pci_bus, devfn, PCI_IO_LIMIT, 0x00);\n\t\t}\n\n\t\tif (bus->noMemRanges) {\n\t\t\tpci_bus_write_config_word(ibmphp_pci_bus, devfn, PCI_MEMORY_BASE, 0x0000 | bus->rangeMem->start >> 16);\n\t\t\tpci_bus_write_config_word(ibmphp_pci_bus, devfn, PCI_MEMORY_LIMIT, 0x0000 | bus->rangeMem->end >> 16);\n\n\t\t\t \n\n\t\t} else {\n\t\t\tpci_bus_write_config_word(ibmphp_pci_bus, devfn, PCI_MEMORY_BASE, 0xffff);\n\t\t\tpci_bus_write_config_word(ibmphp_pci_bus, devfn, PCI_MEMORY_LIMIT, 0x0000);\n\t\t}\n\t\tif (bus->noPFMemRanges) {\n\t\t\tpci_bus_write_config_word(ibmphp_pci_bus, devfn, PCI_PREF_MEMORY_BASE, 0x0000 | bus->rangePFMem->start >> 16);\n\t\t\tpci_bus_write_config_word(ibmphp_pci_bus, devfn, PCI_PREF_MEMORY_LIMIT, 0x0000 | bus->rangePFMem->end >> 16);\n\n\t\t\t \n\n\t\t\tif (need_pfmem_upper) {\t \n\t\t\t\tpci_bus_write_config_dword(ibmphp_pci_bus, devfn, PCI_PREF_BASE_UPPER32, 0x00000000);\n\t\t\t\tpci_bus_write_config_dword(ibmphp_pci_bus, devfn, PCI_PREF_LIMIT_UPPER32, 0x00000000);\n\t\t\t}\n\t\t} else {\n\t\t\tpci_bus_write_config_word(ibmphp_pci_bus, devfn, PCI_PREF_MEMORY_BASE, 0xffff);\n\t\t\tpci_bus_write_config_word(ibmphp_pci_bus, devfn, PCI_PREF_MEMORY_LIMIT, 0x0000);\n\t\t}\n\n\t\tdebug(\"b4 writing control information\\n\");\n\n\t\tpci_bus_read_config_byte(ibmphp_pci_bus, devfn, PCI_INTERRUPT_PIN, &irq);\n\t\tif ((irq > 0x00) && (irq < 0x05))\n\t\t\tpci_bus_write_config_byte(ibmphp_pci_bus, devfn, PCI_INTERRUPT_LINE, func->irq[irq - 1]);\n\t\t \n\n\t\tpci_bus_write_config_word(ibmphp_pci_bus, devfn, PCI_COMMAND, DEVICEENABLE);\n\t\tpci_bus_write_config_word(ibmphp_pci_bus, devfn, PCI_BRIDGE_CONTROL, 0x07);\n\t\tfor (i = 0; i < 32; i++) {\n\t\t\tif (amount_needed->devices[i]) {\n\t\t\t\tdebug(\"device where devices[i] is 1 = %x\\n\", i);\n\t\t\t\tfunc->devices[i] = 1;\n\t\t\t}\n\t\t}\n\t\tfunc->bus = 1;\t \n\t\tfunc_passed = &func;\n\t\tdebug(\"func->busno b4 returning is %x\\n\", func->busno);\n\t\tdebug(\"func->busno b4 returning in the other structure is %x\\n\", (*func_passed)->busno);\n\t\tkfree(amount_needed);\n\t\treturn 0;\n\t} else {\n\t\terr(\"Configuring bridge was unsuccessful...\\n\");\n\t\tmem_tmp = NULL;\n\t\tretval = -EIO;\n\t\tgoto error;\n\t}\n\nerror:\n\tkfree(amount_needed);\n\tif (pfmem)\n\t\tibmphp_remove_resource(pfmem);\n\tif (io)\n\t\tibmphp_remove_resource(io);\n\tif (mem)\n\t\tibmphp_remove_resource(mem);\n\tfor (i = 0; i < 2; i++) {\t \n\t\tif (bus_io[i]) {\n\t\t\tibmphp_remove_resource(bus_io[i]);\n\t\t\tfunc->io[i] = NULL;\n\t\t} else if (bus_pfmem[i]) {\n\t\t\tibmphp_remove_resource(bus_pfmem[i]);\n\t\t\tfunc->pfmem[i] = NULL;\n\t\t} else if (bus_mem[i]) {\n\t\t\tibmphp_remove_resource(bus_mem[i]);\n\t\t\tfunc->mem[i] = NULL;\n\t\t}\n\t}\n\treturn retval;\n}\n\n \nstatic struct res_needed *scan_behind_bridge(struct pci_func *func, u8 busno)\n{\n\tint count, len[6];\n\tu16 vendor_id;\n\tu8 hdr_type;\n\tu8 device, function;\n\tunsigned int devfn;\n\tint howmany = 0;\t \n\n\tu32 bar[6], class;\n\tstatic const u32 address[] = {\n\t\tPCI_BASE_ADDRESS_0,\n\t\tPCI_BASE_ADDRESS_1,\n\t\tPCI_BASE_ADDRESS_2,\n\t\tPCI_BASE_ADDRESS_3,\n\t\tPCI_BASE_ADDRESS_4,\n\t\tPCI_BASE_ADDRESS_5,\n\t\t0\n\t};\n\tstruct res_needed *amount;\n\n\tamount = kzalloc(sizeof(*amount), GFP_KERNEL);\n\tif (amount == NULL)\n\t\treturn NULL;\n\n\tibmphp_pci_bus->number = busno;\n\n\tdebug(\"the bus_no behind the bridge is %x\\n\", busno);\n\tdebug(\"scanning devices behind the bridge...\\n\");\n\tfor (device = 0; device < 32; device++) {\n\t\tamount->devices[device] = 0;\n\t\tfor (function = 0; function < 8; function++) {\n\t\t\tdevfn = PCI_DEVFN(device, function);\n\n\t\t\tpci_bus_read_config_word(ibmphp_pci_bus, devfn, PCI_VENDOR_ID, &vendor_id);\n\n\t\t\tif (vendor_id != PCI_VENDOR_ID_NOTVALID) {\n\t\t\t\t \n\t\t\t\thowmany++;\n\n\t\t\t\tpci_bus_read_config_byte(ibmphp_pci_bus, devfn, PCI_HEADER_TYPE, &hdr_type);\n\t\t\t\tpci_bus_read_config_dword(ibmphp_pci_bus, devfn, PCI_CLASS_REVISION, &class);\n\n\t\t\t\tdebug(\"hdr_type behind the bridge is %x\\n\", hdr_type);\n\t\t\t\tif ((hdr_type & 0x7f) == PCI_HEADER_TYPE_BRIDGE) {\n\t\t\t\t\terr(\"embedded bridges not supported for hot-plugging.\\n\");\n\t\t\t\t\tamount->not_correct = 1;\n\t\t\t\t\treturn amount;\n\t\t\t\t}\n\n\t\t\t\tclass >>= 8;\t \n\t\t\t\tif (class == PCI_CLASS_NOT_DEFINED_VGA) {\n\t\t\t\t\terr(\"The device %x is VGA compatible and as is not supported for hot plugging.  Please choose another device.\\n\", device);\n\t\t\t\t\tamount->not_correct = 1;\n\t\t\t\t\treturn amount;\n\t\t\t\t} else if (class == PCI_CLASS_DISPLAY_VGA) {\n\t\t\t\t\terr(\"The device %x is not supported for hot plugging.  Please choose another device.\\n\", device);\n\t\t\t\t\tamount->not_correct = 1;\n\t\t\t\t\treturn amount;\n\t\t\t\t}\n\n\t\t\t\tamount->devices[device] = 1;\n\n\t\t\t\tfor (count = 0; address[count]; count++) {\n\t\t\t\t\t \n\t\t\t\t\t \n\t\t\t\t\tpci_bus_write_config_dword(ibmphp_pci_bus, devfn, address[count], 0xFFFFFFFF);\n\t\t\t\t\tpci_bus_read_config_dword(ibmphp_pci_bus, devfn, address[count], &bar[count]);\n\n\t\t\t\t\tdebug(\"what is bar[count]? %x, count = %d\\n\", bar[count], count);\n\n\t\t\t\t\tif (!bar[count])\t \n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\n\n\t\t\t\t\tdebug(\"count %d device %x function %x wants %x resources\\n\", count, device, function, bar[count]);\n\n\t\t\t\t\tif (bar[count] & PCI_BASE_ADDRESS_SPACE_IO) {\n\t\t\t\t\t\t \n\t\t\t\t\t\tlen[count] = bar[count] & 0xFFFFFFFC;\n\t\t\t\t\t\tlen[count] = ~len[count] + 1;\n\t\t\t\t\t\tamount->io += len[count];\n\t\t\t\t\t} else {\n\t\t\t\t\t\t \n\t\t\t\t\t\tif (bar[count] & PCI_BASE_ADDRESS_MEM_PREFETCH) {\n\t\t\t\t\t\t\t \n\t\t\t\t\t\t\tlen[count] = bar[count] & 0xFFFFFFF0;\n\t\t\t\t\t\t\tlen[count] = ~len[count] + 1;\n\t\t\t\t\t\t\tamount->pfmem += len[count];\n\t\t\t\t\t\t\tif (bar[count] & PCI_BASE_ADDRESS_MEM_TYPE_64)\n\t\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t\tcount += 1;\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t \n\t\t\t\t\t\t\tlen[count] = bar[count] & 0xFFFFFFF0;\n\t\t\t\t\t\t\tlen[count] = ~len[count] + 1;\n\t\t\t\t\t\t\tamount->mem += len[count];\n\t\t\t\t\t\t\tif (bar[count] & PCI_BASE_ADDRESS_MEM_TYPE_64) {\n\t\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t\tcount += 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\t \n\t\t\t}\t \n\t\t}\t \n\t}\t \n\n\tif (!howmany)\n\t\tamount->not_correct = 1;\n\telse\n\t\tamount->not_correct = 0;\n\tif ((amount->io) && (amount->io < IOBRIDGE))\n\t\tamount->io = IOBRIDGE;\n\tif ((amount->mem) && (amount->mem < MEMBRIDGE))\n\t\tamount->mem = MEMBRIDGE;\n\tif ((amount->pfmem) && (amount->pfmem < MEMBRIDGE))\n\t\tamount->pfmem = MEMBRIDGE;\n\treturn amount;\n}\n\n \nstatic int unconfigure_boot_device(u8 busno, u8 device, u8 function)\n{\n\tu32 start_address;\n\tstatic const u32 address[] = {\n\t\tPCI_BASE_ADDRESS_0,\n\t\tPCI_BASE_ADDRESS_1,\n\t\tPCI_BASE_ADDRESS_2,\n\t\tPCI_BASE_ADDRESS_3,\n\t\tPCI_BASE_ADDRESS_4,\n\t\tPCI_BASE_ADDRESS_5,\n\t\t0\n\t};\n\tint count;\n\tstruct resource_node *io;\n\tstruct resource_node *mem;\n\tstruct resource_node *pfmem;\n\tstruct bus_node *bus;\n\tu32 end_address;\n\tu32 temp_end;\n\tu32 size;\n\tu32 tmp_address;\n\tunsigned int devfn;\n\n\tdebug(\"%s - enter\\n\", __func__);\n\n\tbus = ibmphp_find_res_bus(busno);\n\tif (!bus) {\n\t\tdebug(\"cannot find corresponding bus.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdevfn = PCI_DEVFN(device, function);\n\tibmphp_pci_bus->number = busno;\n\tfor (count = 0; address[count]; count++) {\t \n\t\tpci_bus_read_config_dword(ibmphp_pci_bus, devfn, address[count], &start_address);\n\n\t\t \n\n\t\tpci_bus_write_config_dword(ibmphp_pci_bus, devfn, address[count], 0xFFFFFFFF);\n\t\tpci_bus_read_config_dword(ibmphp_pci_bus, devfn, address[count], &size);\n\t\tpci_bus_write_config_dword(ibmphp_pci_bus, devfn, address[count], start_address);\n\n\t\tdebug(\"start_address is %x\\n\", start_address);\n\t\tdebug(\"busno, device, function %x %x %x\\n\", busno, device, function);\n\t\tif (!size) {\n\t\t\t \n\t\t\tdebug(\"is this bar no implemented?, count = %d\\n\", count);\n\t\t\tcontinue;\n\t\t}\n\t\ttmp_address = start_address;\n\t\tif (start_address & PCI_BASE_ADDRESS_SPACE_IO) {\n\t\t\t \n\t\t\tstart_address &= PCI_BASE_ADDRESS_IO_MASK;\n\t\t\tsize = size & 0xFFFFFFFC;\n\t\t\tsize = ~size + 1;\n\t\t\tend_address = start_address + size - 1;\n\t\t\tif (ibmphp_find_resource(bus, start_address, &io, IO))\n\t\t\t\tgoto report_search_failure;\n\n\t\t\tdebug(\"io->start = %x\\n\", io->start);\n\t\t\ttemp_end = io->end;\n\t\t\tstart_address = io->end + 1;\n\t\t\tibmphp_remove_resource(io);\n\t\t\t \n\t\t\twhile (temp_end < end_address) {\n\t\t\t\tif (ibmphp_find_resource(bus, start_address,\n\t\t\t\t\t\t\t &io, IO))\n\t\t\t\t\tgoto report_search_failure;\n\n\t\t\t\tdebug(\"io->start = %x\\n\", io->start);\n\t\t\t\ttemp_end = io->end;\n\t\t\t\tstart_address = io->end + 1;\n\t\t\t\tibmphp_remove_resource(io);\n\t\t\t}\n\n\t\t\t \n\t\t} else {\n\t\t\t \n\t\t\tif (start_address & PCI_BASE_ADDRESS_MEM_PREFETCH) {\n\t\t\t\t \n\t\t\t\tdebug(\"start address of pfmem is %x\\n\", start_address);\n\t\t\t\tstart_address &= PCI_BASE_ADDRESS_MEM_MASK;\n\n\t\t\t\tif (ibmphp_find_resource(bus, start_address, &pfmem, PFMEM) < 0) {\n\t\t\t\t\terr(\"cannot find corresponding PFMEM resource to remove\\n\");\n\t\t\t\t\treturn -EIO;\n\t\t\t\t}\n\t\t\t\tif (pfmem) {\n\t\t\t\t\tdebug(\"pfmem->start = %x\\n\", pfmem->start);\n\n\t\t\t\t\tibmphp_remove_resource(pfmem);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tdebug(\"start address of mem is %x\\n\", start_address);\n\t\t\t\tstart_address &= PCI_BASE_ADDRESS_MEM_MASK;\n\n\t\t\t\tif (ibmphp_find_resource(bus, start_address, &mem, MEM) < 0) {\n\t\t\t\t\terr(\"cannot find corresponding MEM resource to remove\\n\");\n\t\t\t\t\treturn -EIO;\n\t\t\t\t}\n\t\t\t\tif (mem) {\n\t\t\t\t\tdebug(\"mem->start = %x\\n\", mem->start);\n\n\t\t\t\t\tibmphp_remove_resource(mem);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (tmp_address & PCI_BASE_ADDRESS_MEM_TYPE_64) {\n\t\t\t\t \n\t\t\t\tcount += 1;\n\t\t\t}\n\t\t}\t \n\t}\t \n\n\treturn 0;\n\nreport_search_failure:\n\terr(\"cannot find corresponding IO resource to remove\\n\");\n\treturn -EIO;\n}\n\nstatic int unconfigure_boot_bridge(u8 busno, u8 device, u8 function)\n{\n\tint count;\n\tint bus_no, pri_no, sub_no, sec_no = 0;\n\tu32 start_address, tmp_address;\n\tu8 sec_number, sub_number, pri_number;\n\tstruct resource_node *io = NULL;\n\tstruct resource_node *mem = NULL;\n\tstruct resource_node *pfmem = NULL;\n\tstruct bus_node *bus;\n\tstatic const u32 address[] = {\n\t\tPCI_BASE_ADDRESS_0,\n\t\tPCI_BASE_ADDRESS_1,\n\t\t0\n\t};\n\tunsigned int devfn;\n\n\tdevfn = PCI_DEVFN(device, function);\n\tibmphp_pci_bus->number = busno;\n\tbus_no = (int) busno;\n\tdebug(\"busno is %x\\n\", busno);\n\tpci_bus_read_config_byte(ibmphp_pci_bus, devfn, PCI_PRIMARY_BUS, &pri_number);\n\tdebug(\"%s - busno = %x, primary_number = %x\\n\", __func__, busno, pri_number);\n\n\tpci_bus_read_config_byte(ibmphp_pci_bus, devfn, PCI_SECONDARY_BUS, &sec_number);\n\tdebug(\"sec_number is %x\\n\", sec_number);\n\tsec_no = (int) sec_number;\n\tpri_no = (int) pri_number;\n\tif (pri_no != bus_no) {\n\t\terr(\"primary numbers in our structures and pci config space don't match.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpci_bus_read_config_byte(ibmphp_pci_bus, devfn, PCI_SUBORDINATE_BUS, &sub_number);\n\tsub_no = (int) sub_number;\n\tdebug(\"sub_no is %d, sec_no is %d\\n\", sub_no, sec_no);\n\tif (sec_no != sub_number) {\n\t\terr(\"there're more buses behind this bridge.  Hot removal is not supported.  Please choose another card\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tbus = ibmphp_find_res_bus(sec_number);\n\tif (!bus) {\n\t\terr(\"cannot find Bus structure for the bridged device\\n\");\n\t\treturn -EINVAL;\n\t}\n\tdebug(\"bus->busno is %x\\n\", bus->busno);\n\tdebug(\"sec_number is %x\\n\", sec_number);\n\n\tibmphp_remove_bus(bus, busno);\n\n\tfor (count = 0; address[count]; count++) {\n\t\t \n\t\tpci_bus_read_config_dword(ibmphp_pci_bus, devfn, address[count], &start_address);\n\n\t\tif (!start_address) {\n\t\t\t \n\t\t\tcontinue;\n\t\t}\n\n\t\ttmp_address = start_address;\n\n\t\tif (start_address & PCI_BASE_ADDRESS_SPACE_IO) {\n\t\t\t \n\t\t\tstart_address &= PCI_BASE_ADDRESS_IO_MASK;\n\t\t\tif (ibmphp_find_resource(bus, start_address, &io, IO) < 0) {\n\t\t\t\terr(\"cannot find corresponding IO resource to remove\\n\");\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t\tif (io)\n\t\t\t\tdebug(\"io->start = %x\\n\", io->start);\n\n\t\t\tibmphp_remove_resource(io);\n\n\t\t\t \n\t\t} else {\n\t\t\t \n\t\t\tif (start_address & PCI_BASE_ADDRESS_MEM_PREFETCH) {\n\t\t\t\t \n\t\t\t\tstart_address &= PCI_BASE_ADDRESS_MEM_MASK;\n\t\t\t\tif (ibmphp_find_resource(bus, start_address, &pfmem, PFMEM) < 0) {\n\t\t\t\t\terr(\"cannot find corresponding PFMEM resource to remove\\n\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t\tif (pfmem) {\n\t\t\t\t\tdebug(\"pfmem->start = %x\\n\", pfmem->start);\n\n\t\t\t\t\tibmphp_remove_resource(pfmem);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tstart_address &= PCI_BASE_ADDRESS_MEM_MASK;\n\t\t\t\tif (ibmphp_find_resource(bus, start_address, &mem, MEM) < 0) {\n\t\t\t\t\terr(\"cannot find corresponding MEM resource to remove\\n\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t\tif (mem) {\n\t\t\t\t\tdebug(\"mem->start = %x\\n\", mem->start);\n\n\t\t\t\t\tibmphp_remove_resource(mem);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (tmp_address & PCI_BASE_ADDRESS_MEM_TYPE_64) {\n\t\t\t\t \n\t\t\t\tcount += 1;\n\t\t\t}\n\t\t}\t \n\t}\t \n\tdebug(\"%s - exiting, returning success\\n\", __func__);\n\treturn 0;\n}\n\nstatic int unconfigure_boot_card(struct slot *slot_cur)\n{\n\tu16 vendor_id;\n\tu32 class;\n\tu8 hdr_type;\n\tu8 device;\n\tu8 busno;\n\tu8 function;\n\tint rc;\n\tunsigned int devfn;\n\tu8 valid_device = 0x00;  \n\n\tdebug(\"%s - enter\\n\", __func__);\n\n\tdevice = slot_cur->device;\n\tbusno = slot_cur->bus;\n\n\tdebug(\"b4 for loop, device is %x\\n\", device);\n\t \n\tfor (function = 0x0; function < 0x08; function++) {\n\t\tdevfn = PCI_DEVFN(device, function);\n\t\tibmphp_pci_bus->number = busno;\n\n\t\tpci_bus_read_config_word(ibmphp_pci_bus, devfn, PCI_VENDOR_ID, &vendor_id);\n\n\t\tif (vendor_id != PCI_VENDOR_ID_NOTVALID) {\n\t\t\t \n\t\t\t++valid_device;\n\n\t\t\tdebug(\"%s - found correct device\\n\", __func__);\n\n\t\t\t \n\n\t\t\tpci_bus_read_config_byte(ibmphp_pci_bus, devfn, PCI_HEADER_TYPE, &hdr_type);\n\t\t\tpci_bus_read_config_dword(ibmphp_pci_bus, devfn, PCI_CLASS_REVISION, &class);\n\n\t\t\tdebug(\"hdr_type %x, class %x\\n\", hdr_type, class);\n\t\t\tclass >>= 8;\t \n\t\t\tif (class == PCI_CLASS_NOT_DEFINED_VGA) {\n\t\t\t\terr(\"The device %x function %x is VGA compatible and is not supported for hot removing.  Please choose another device.\\n\", device, function);\n\t\t\t\treturn -ENODEV;\n\t\t\t} else if (class == PCI_CLASS_DISPLAY_VGA) {\n\t\t\t\terr(\"The device %x function %x is not supported for hot removing.  Please choose another device.\\n\", device, function);\n\t\t\t\treturn -ENODEV;\n\t\t\t}\n\n\t\t\tswitch (hdr_type) {\n\t\t\t\tcase PCI_HEADER_TYPE_NORMAL:\n\t\t\t\t\trc = unconfigure_boot_device(busno, device, function);\n\t\t\t\t\tif (rc) {\n\t\t\t\t\t\terr(\"was not able to unconfigure device %x func %x on bus %x. bailing out...\\n\",\n\t\t\t\t\t\t     device, function, busno);\n\t\t\t\t\t\treturn rc;\n\t\t\t\t\t}\n\t\t\t\t\tfunction = 0x8;\n\t\t\t\t\tbreak;\n\t\t\t\tcase PCI_HEADER_TYPE_MULTIDEVICE:\n\t\t\t\t\trc = unconfigure_boot_device(busno, device, function);\n\t\t\t\t\tif (rc) {\n\t\t\t\t\t\terr(\"was not able to unconfigure device %x func %x on bus %x. bailing out...\\n\",\n\t\t\t\t\t\t     device, function, busno);\n\t\t\t\t\t\treturn rc;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase PCI_HEADER_TYPE_BRIDGE:\n\t\t\t\t\tclass >>= 8;\n\t\t\t\t\tif (class != PCI_CLASS_BRIDGE_PCI) {\n\t\t\t\t\t\terr(\"This device %x function %x is not PCI-to-PCI bridge, and is not supported for hot-removing.  Please try another card.\\n\", device, function);\n\t\t\t\t\t\treturn -ENODEV;\n\t\t\t\t\t}\n\t\t\t\t\trc = unconfigure_boot_bridge(busno, device, function);\n\t\t\t\t\tif (rc != 0) {\n\t\t\t\t\t\terr(\"was not able to hot-remove PPB properly.\\n\");\n\t\t\t\t\t\treturn rc;\n\t\t\t\t\t}\n\n\t\t\t\t\tfunction = 0x8;\n\t\t\t\t\tbreak;\n\t\t\t\tcase PCI_HEADER_TYPE_MULTIBRIDGE:\n\t\t\t\t\tclass >>= 8;\n\t\t\t\t\tif (class != PCI_CLASS_BRIDGE_PCI) {\n\t\t\t\t\t\terr(\"This device %x function %x is not PCI-to-PCI bridge,  and is not supported for hot-removing.  Please try another card.\\n\", device, function);\n\t\t\t\t\t\treturn -ENODEV;\n\t\t\t\t\t}\n\t\t\t\t\trc = unconfigure_boot_bridge(busno, device, function);\n\t\t\t\t\tif (rc != 0) {\n\t\t\t\t\t\terr(\"was not able to hot-remove PPB properly.\\n\");\n\t\t\t\t\t\treturn rc;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\terr(\"MAJOR PROBLEM!!!! Cannot read device's header\\n\");\n\t\t\t\t\treturn -1;\n\t\t\t}\t \n\t\t}\t \n\t}\t \n\n\tif (!valid_device) {\n\t\terr(\"Could not find device to unconfigure.  Or could not read the card.\\n\");\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\n \nint ibmphp_unconfigure_card(struct slot **slot_cur, int the_end)\n{\n\tint i;\n\tint count;\n\tint rc;\n\tstruct slot *sl = *slot_cur;\n\tstruct pci_func *cur_func = NULL;\n\tstruct pci_func *temp_func;\n\n\tdebug(\"%s - enter\\n\", __func__);\n\n\tif (!the_end) {\n\t\t \n\t\trc = unconfigure_boot_card(sl);\n\t\tif ((rc == -ENODEV) || (rc == -EIO) || (rc == -EINVAL)) {\n\t\t\t \n\t\t\treturn rc;\n\t\t}\n\t}\n\n\tif (sl->func) {\n\t\tcur_func = sl->func;\n\t\twhile (cur_func) {\n\t\t\t \n\t\t\tif (cur_func->bus) {\n\t\t\t\t \n\t\t\t\tcount = 2;\n\t\t\t} else {\n\t\t\t\tcount = 6;\n\t\t\t}\n\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\tif (cur_func->io[i]) {\n\t\t\t\t\tdebug(\"io[%d] exists\\n\", i);\n\t\t\t\t\tif (the_end > 0)\n\t\t\t\t\t\tibmphp_remove_resource(cur_func->io[i]);\n\t\t\t\t\tcur_func->io[i] = NULL;\n\t\t\t\t}\n\t\t\t\tif (cur_func->mem[i]) {\n\t\t\t\t\tdebug(\"mem[%d] exists\\n\", i);\n\t\t\t\t\tif (the_end > 0)\n\t\t\t\t\t\tibmphp_remove_resource(cur_func->mem[i]);\n\t\t\t\t\tcur_func->mem[i] = NULL;\n\t\t\t\t}\n\t\t\t\tif (cur_func->pfmem[i]) {\n\t\t\t\t\tdebug(\"pfmem[%d] exists\\n\", i);\n\t\t\t\t\tif (the_end > 0)\n\t\t\t\t\t\tibmphp_remove_resource(cur_func->pfmem[i]);\n\t\t\t\t\tcur_func->pfmem[i] = NULL;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttemp_func = cur_func->next;\n\t\t\tkfree(cur_func);\n\t\t\tcur_func = temp_func;\n\t\t}\n\t}\n\n\tsl->func = NULL;\n\t*slot_cur = sl;\n\tdebug(\"%s - exit\\n\", __func__);\n\treturn 0;\n}\n\n \nstatic int add_new_bus(struct bus_node *bus, struct resource_node *io, struct resource_node *mem, struct resource_node *pfmem, u8 parent_busno)\n{\n\tstruct range_node *io_range = NULL;\n\tstruct range_node *mem_range = NULL;\n\tstruct range_node *pfmem_range = NULL;\n\tstruct bus_node *cur_bus = NULL;\n\n\t \n\tif (parent_busno != 0xFF) {\n\t\tcur_bus\t= ibmphp_find_res_bus(parent_busno);\n\t\tif (!cur_bus) {\n\t\t\terr(\"strange, cannot find bus which is supposed to be at the system... something is terribly wrong...\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\tlist_add(&bus->bus_list, &cur_bus->bus_list);\n\t}\n\tif (io) {\n\t\tio_range = kzalloc(sizeof(*io_range), GFP_KERNEL);\n\t\tif (!io_range)\n\t\t\treturn -ENOMEM;\n\n\t\tio_range->start = io->start;\n\t\tio_range->end = io->end;\n\t\tio_range->rangeno = 1;\n\t\tbus->noIORanges = 1;\n\t\tbus->rangeIO = io_range;\n\t}\n\tif (mem) {\n\t\tmem_range = kzalloc(sizeof(*mem_range), GFP_KERNEL);\n\t\tif (!mem_range)\n\t\t\treturn -ENOMEM;\n\n\t\tmem_range->start = mem->start;\n\t\tmem_range->end = mem->end;\n\t\tmem_range->rangeno = 1;\n\t\tbus->noMemRanges = 1;\n\t\tbus->rangeMem = mem_range;\n\t}\n\tif (pfmem) {\n\t\tpfmem_range = kzalloc(sizeof(*pfmem_range), GFP_KERNEL);\n\t\tif (!pfmem_range)\n\t\t\treturn -ENOMEM;\n\n\t\tpfmem_range->start = pfmem->start;\n\t\tpfmem_range->end = pfmem->end;\n\t\tpfmem_range->rangeno = 1;\n\t\tbus->noPFMemRanges = 1;\n\t\tbus->rangePFMem = pfmem_range;\n\t}\n\treturn 0;\n}\n\n \nstatic u8 find_sec_number(u8 primary_busno, u8 slotno)\n{\n\tint min, max;\n\tu8 busno;\n\tstruct bus_info *bus;\n\tstruct bus_node *bus_cur;\n\n\tbus = ibmphp_find_same_bus_num(primary_busno);\n\tif (!bus) {\n\t\terr(\"cannot get slot range of the bus from the BIOS\\n\");\n\t\treturn 0xff;\n\t}\n\tmax = bus->slot_max;\n\tmin = bus->slot_min;\n\tif ((slotno > max) || (slotno < min)) {\n\t\terr(\"got the wrong range\\n\");\n\t\treturn 0xff;\n\t}\n\tbusno = (u8) (slotno - (u8) min);\n\tbusno += primary_busno + 0x01;\n\tbus_cur = ibmphp_find_res_bus(busno);\n\t \n\tif ((!bus_cur) || (!(bus_cur->rangeIO) && !(bus_cur->rangeMem) && !(bus_cur->rangePFMem)))\n\t\treturn busno;\n\treturn 0xff;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}