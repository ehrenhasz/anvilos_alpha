{
  "module_name": "pciehp_core.c",
  "hash_id": "3fbe43161dc3a8c6e7813601466d929524cc327a515a0965142d15ef5331c268",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/hotplug/pciehp_core.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"pciehp: \" fmt\n#define dev_fmt pr_fmt\n\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/pci.h>\n#include \"pciehp.h\"\n\n#include \"../pci.h\"\n\n \nbool pciehp_poll_mode;\nint pciehp_poll_time;\n\n \nmodule_param(pciehp_poll_mode, bool, 0644);\nmodule_param(pciehp_poll_time, int, 0644);\nMODULE_PARM_DESC(pciehp_poll_mode, \"Using polling mechanism for hot-plug events or not\");\nMODULE_PARM_DESC(pciehp_poll_time, \"Polling mechanism frequency, in seconds\");\n\nstatic int set_attention_status(struct hotplug_slot *slot, u8 value);\nstatic int get_power_status(struct hotplug_slot *slot, u8 *value);\nstatic int get_latch_status(struct hotplug_slot *slot, u8 *value);\nstatic int get_adapter_status(struct hotplug_slot *slot, u8 *value);\n\nstatic int init_slot(struct controller *ctrl)\n{\n\tstruct hotplug_slot_ops *ops;\n\tchar name[SLOT_NAME_SIZE];\n\tint retval;\n\n\t \n\tops = kzalloc(sizeof(*ops), GFP_KERNEL);\n\tif (!ops)\n\t\treturn -ENOMEM;\n\n\tops->enable_slot = pciehp_sysfs_enable_slot;\n\tops->disable_slot = pciehp_sysfs_disable_slot;\n\tops->get_power_status = get_power_status;\n\tops->get_adapter_status = get_adapter_status;\n\tops->reset_slot = pciehp_reset_slot;\n\tif (MRL_SENS(ctrl))\n\t\tops->get_latch_status = get_latch_status;\n\tif (ATTN_LED(ctrl)) {\n\t\tops->get_attention_status = pciehp_get_attention_status;\n\t\tops->set_attention_status = set_attention_status;\n\t} else if (ctrl->pcie->port->hotplug_user_indicators) {\n\t\tops->get_attention_status = pciehp_get_raw_indicator_status;\n\t\tops->set_attention_status = pciehp_set_raw_indicator_status;\n\t}\n\n\t \n\tctrl->hotplug_slot.ops = ops;\n\tsnprintf(name, SLOT_NAME_SIZE, \"%u\", PSN(ctrl));\n\n\tretval = pci_hp_initialize(&ctrl->hotplug_slot,\n\t\t\t\t   ctrl->pcie->port->subordinate, 0, name);\n\tif (retval) {\n\t\tctrl_err(ctrl, \"pci_hp_initialize failed: error %d\\n\", retval);\n\t\tkfree(ops);\n\t}\n\treturn retval;\n}\n\nstatic void cleanup_slot(struct controller *ctrl)\n{\n\tstruct hotplug_slot *hotplug_slot = &ctrl->hotplug_slot;\n\n\tpci_hp_destroy(hotplug_slot);\n\tkfree(hotplug_slot->ops);\n}\n\n \nstatic int set_attention_status(struct hotplug_slot *hotplug_slot, u8 status)\n{\n\tstruct controller *ctrl = to_ctrl(hotplug_slot);\n\tstruct pci_dev *pdev = ctrl->pcie->port;\n\n\tif (status)\n\t\tstatus <<= PCI_EXP_SLTCTL_ATTN_IND_SHIFT;\n\telse\n\t\tstatus = PCI_EXP_SLTCTL_ATTN_IND_OFF;\n\n\tpci_config_pm_runtime_get(pdev);\n\tpciehp_set_indicators(ctrl, INDICATOR_NOOP, status);\n\tpci_config_pm_runtime_put(pdev);\n\treturn 0;\n}\n\nstatic int get_power_status(struct hotplug_slot *hotplug_slot, u8 *value)\n{\n\tstruct controller *ctrl = to_ctrl(hotplug_slot);\n\tstruct pci_dev *pdev = ctrl->pcie->port;\n\n\tpci_config_pm_runtime_get(pdev);\n\tpciehp_get_power_status(ctrl, value);\n\tpci_config_pm_runtime_put(pdev);\n\treturn 0;\n}\n\nstatic int get_latch_status(struct hotplug_slot *hotplug_slot, u8 *value)\n{\n\tstruct controller *ctrl = to_ctrl(hotplug_slot);\n\tstruct pci_dev *pdev = ctrl->pcie->port;\n\n\tpci_config_pm_runtime_get(pdev);\n\tpciehp_get_latch_status(ctrl, value);\n\tpci_config_pm_runtime_put(pdev);\n\treturn 0;\n}\n\nstatic int get_adapter_status(struct hotplug_slot *hotplug_slot, u8 *value)\n{\n\tstruct controller *ctrl = to_ctrl(hotplug_slot);\n\tstruct pci_dev *pdev = ctrl->pcie->port;\n\tint ret;\n\n\tpci_config_pm_runtime_get(pdev);\n\tret = pciehp_card_present_or_link_active(ctrl);\n\tpci_config_pm_runtime_put(pdev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*value = ret;\n\treturn 0;\n}\n\n \nstatic void pciehp_check_presence(struct controller *ctrl)\n{\n\tint occupied;\n\n\tdown_read_nested(&ctrl->reset_lock, ctrl->depth);\n\tmutex_lock(&ctrl->state_lock);\n\n\toccupied = pciehp_card_present_or_link_active(ctrl);\n\tif ((occupied > 0 && (ctrl->state == OFF_STATE ||\n\t\t\t  ctrl->state == BLINKINGON_STATE)) ||\n\t    (!occupied && (ctrl->state == ON_STATE ||\n\t\t\t   ctrl->state == BLINKINGOFF_STATE)))\n\t\tpciehp_request(ctrl, PCI_EXP_SLTSTA_PDC);\n\n\tmutex_unlock(&ctrl->state_lock);\n\tup_read(&ctrl->reset_lock);\n}\n\nstatic int pciehp_probe(struct pcie_device *dev)\n{\n\tint rc;\n\tstruct controller *ctrl;\n\n\t \n\tif (dev->service != PCIE_PORT_SERVICE_HP)\n\t\treturn -ENODEV;\n\n\tif (!dev->port->subordinate) {\n\t\t \n\t\tpci_err(dev->port,\n\t\t\t\"Hotplug bridge without secondary bus, ignoring\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tctrl = pcie_init(dev);\n\tif (!ctrl) {\n\t\tpci_err(dev->port, \"Controller initialization failed\\n\");\n\t\treturn -ENODEV;\n\t}\n\tset_service_data(dev, ctrl);\n\n\t \n\trc = init_slot(ctrl);\n\tif (rc) {\n\t\tif (rc == -EBUSY)\n\t\t\tctrl_warn(ctrl, \"Slot already registered by another hotplug driver\\n\");\n\t\telse\n\t\t\tctrl_err(ctrl, \"Slot initialization failed (%d)\\n\", rc);\n\t\tgoto err_out_release_ctlr;\n\t}\n\n\t \n\trc = pcie_init_notification(ctrl);\n\tif (rc) {\n\t\tctrl_err(ctrl, \"Notification initialization failed (%d)\\n\", rc);\n\t\tgoto err_out_free_ctrl_slot;\n\t}\n\n\t \n\trc = pci_hp_add(&ctrl->hotplug_slot);\n\tif (rc) {\n\t\tctrl_err(ctrl, \"Publication to user space failed (%d)\\n\", rc);\n\t\tgoto err_out_shutdown_notification;\n\t}\n\n\tpciehp_check_presence(ctrl);\n\n\treturn 0;\n\nerr_out_shutdown_notification:\n\tpcie_shutdown_notification(ctrl);\nerr_out_free_ctrl_slot:\n\tcleanup_slot(ctrl);\nerr_out_release_ctlr:\n\tpciehp_release_ctrl(ctrl);\n\treturn -ENODEV;\n}\n\nstatic void pciehp_remove(struct pcie_device *dev)\n{\n\tstruct controller *ctrl = get_service_data(dev);\n\n\tpci_hp_del(&ctrl->hotplug_slot);\n\tpcie_shutdown_notification(ctrl);\n\tcleanup_slot(ctrl);\n\tpciehp_release_ctrl(ctrl);\n}\n\n#ifdef CONFIG_PM\nstatic bool pme_is_native(struct pcie_device *dev)\n{\n\tconst struct pci_host_bridge *host;\n\n\thost = pci_find_host_bridge(dev->port->bus);\n\treturn pcie_ports_native || host->native_pme;\n}\n\nstatic void pciehp_disable_interrupt(struct pcie_device *dev)\n{\n\t \n\tif (pme_is_native(dev))\n\t\tpcie_disable_interrupt(get_service_data(dev));\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int pciehp_suspend(struct pcie_device *dev)\n{\n\t \n\tif (dev_pm_skip_suspend(&dev->port->dev))\n\t\treturn 0;\n\n\tpciehp_disable_interrupt(dev);\n\treturn 0;\n}\n\nstatic int pciehp_resume_noirq(struct pcie_device *dev)\n{\n\tstruct controller *ctrl = get_service_data(dev);\n\n\t \n\tctrl->cmd_started = jiffies;\n\tctrl->cmd_busy = true;\n\n\t \n\tif (ctrl->state == ON_STATE || ctrl->state == BLINKINGOFF_STATE)\n\t\tpcie_clear_hotplug_events(ctrl);\n\n\treturn 0;\n}\n#endif\n\nstatic int pciehp_resume(struct pcie_device *dev)\n{\n\tstruct controller *ctrl = get_service_data(dev);\n\n\tif (pme_is_native(dev))\n\t\tpcie_enable_interrupt(ctrl);\n\n\tpciehp_check_presence(ctrl);\n\n\treturn 0;\n}\n\nstatic int pciehp_runtime_suspend(struct pcie_device *dev)\n{\n\tpciehp_disable_interrupt(dev);\n\treturn 0;\n}\n\nstatic int pciehp_runtime_resume(struct pcie_device *dev)\n{\n\tstruct controller *ctrl = get_service_data(dev);\n\n\t \n\tctrl->cmd_started = jiffies;\n\tctrl->cmd_busy = true;\n\n\t \n\tif ((ctrl->state == ON_STATE || ctrl->state == BLINKINGOFF_STATE) &&\n\t     pme_is_native(dev))\n\t\tpcie_clear_hotplug_events(ctrl);\n\n\treturn pciehp_resume(dev);\n}\n#endif  \n\nstatic struct pcie_port_service_driver hpdriver_portdrv = {\n\t.name\t\t= \"pciehp\",\n\t.port_type\t= PCIE_ANY_PORT,\n\t.service\t= PCIE_PORT_SERVICE_HP,\n\n\t.probe\t\t= pciehp_probe,\n\t.remove\t\t= pciehp_remove,\n\n#ifdef\tCONFIG_PM\n#ifdef\tCONFIG_PM_SLEEP\n\t.suspend\t= pciehp_suspend,\n\t.resume_noirq\t= pciehp_resume_noirq,\n\t.resume\t\t= pciehp_resume,\n#endif\n\t.runtime_suspend = pciehp_runtime_suspend,\n\t.runtime_resume\t= pciehp_runtime_resume,\n#endif\t \n\n\t.slot_reset\t= pciehp_slot_reset,\n};\n\nint __init pcie_hp_init(void)\n{\n\tint retval = 0;\n\n\tretval = pcie_port_service_register(&hpdriver_portdrv);\n\tpr_debug(\"pcie_port_service_register = %d\\n\", retval);\n\tif (retval)\n\t\tpr_debug(\"Failure to register service\\n\");\n\n\treturn retval;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}