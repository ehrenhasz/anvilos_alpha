{
  "module_name": "pciehp.h",
  "hash_id": "eb06d6a867c09967ee8f51334d01384512d9ef4110eb4104cb970fd58784df75",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/hotplug/pciehp.h",
  "human_readable_source": " \n \n#ifndef _PCIEHP_H\n#define _PCIEHP_H\n\n#include <linux/types.h>\n#include <linux/pci.h>\n#include <linux/pci_hotplug.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/rwsem.h>\n#include <linux/workqueue.h>\n\n#include \"../pcie/portdrv.h\"\n\nextern bool pciehp_poll_mode;\nextern int pciehp_poll_time;\n\n \n#define ctrl_dbg(ctrl, format, arg...)\t\t\t\t\t\\\n\tpci_dbg(ctrl->pcie->port, format, ## arg)\n#define ctrl_err(ctrl, format, arg...)\t\t\t\t\t\\\n\tpci_err(ctrl->pcie->port, format, ## arg)\n#define ctrl_info(ctrl, format, arg...)\t\t\t\t\t\\\n\tpci_info(ctrl->pcie->port, format, ## arg)\n#define ctrl_warn(ctrl, format, arg...)\t\t\t\t\t\\\n\tpci_warn(ctrl->pcie->port, format, ## arg)\n\n#define SLOT_NAME_SIZE 10\n\n \nstruct controller {\n\tstruct pcie_device *pcie;\n\n\tu32 slot_cap;\t\t\t\t \n\tunsigned int inband_presence_disabled:1;\n\n\tu16 slot_ctrl;\t\t\t\t \n\tstruct mutex ctrl_lock;\n\tunsigned long cmd_started;\n\tunsigned int cmd_busy:1;\n\twait_queue_head_t queue;\n\n\tatomic_t pending_events;\t\t \n\tunsigned int notification_enabled:1;\n\tunsigned int power_fault_detected;\n\tstruct task_struct *poll_thread;\n\n\tu8 state;\t\t\t\t \n\tstruct mutex state_lock;\n\tstruct delayed_work button_work;\n\n\tstruct hotplug_slot hotplug_slot;\t \n\tstruct rw_semaphore reset_lock;\n\tunsigned int depth;\n\tunsigned int ist_running;\n\tint request_result;\n\twait_queue_head_t requester;\n};\n\n \n#define OFF_STATE\t\t\t0\n#define BLINKINGON_STATE\t\t1\n#define BLINKINGOFF_STATE\t\t2\n#define POWERON_STATE\t\t\t3\n#define POWEROFF_STATE\t\t\t4\n#define ON_STATE\t\t\t5\n\n \n#define DISABLE_SLOT\t\t(1 << 16)\n#define RERUN_ISR\t\t(1 << 17)\n\n#define ATTN_BUTTN(ctrl)\t((ctrl)->slot_cap & PCI_EXP_SLTCAP_ABP)\n#define POWER_CTRL(ctrl)\t((ctrl)->slot_cap & PCI_EXP_SLTCAP_PCP)\n#define MRL_SENS(ctrl)\t\t((ctrl)->slot_cap & PCI_EXP_SLTCAP_MRLSP)\n#define ATTN_LED(ctrl)\t\t((ctrl)->slot_cap & PCI_EXP_SLTCAP_AIP)\n#define PWR_LED(ctrl)\t\t((ctrl)->slot_cap & PCI_EXP_SLTCAP_PIP)\n#define NO_CMD_CMPL(ctrl)\t((ctrl)->slot_cap & PCI_EXP_SLTCAP_NCCS)\n#define PSN(ctrl)\t\t(((ctrl)->slot_cap & PCI_EXP_SLTCAP_PSN) >> 19)\n\nvoid pciehp_request(struct controller *ctrl, int action);\nvoid pciehp_handle_button_press(struct controller *ctrl);\nvoid pciehp_handle_disable_request(struct controller *ctrl);\nvoid pciehp_handle_presence_or_link_change(struct controller *ctrl, u32 events);\nint pciehp_configure_device(struct controller *ctrl);\nvoid pciehp_unconfigure_device(struct controller *ctrl, bool presence);\nvoid pciehp_queue_pushbutton_work(struct work_struct *work);\nstruct controller *pcie_init(struct pcie_device *dev);\nint pcie_init_notification(struct controller *ctrl);\nvoid pcie_shutdown_notification(struct controller *ctrl);\nvoid pcie_clear_hotplug_events(struct controller *ctrl);\nvoid pcie_enable_interrupt(struct controller *ctrl);\nvoid pcie_disable_interrupt(struct controller *ctrl);\nint pciehp_power_on_slot(struct controller *ctrl);\nvoid pciehp_power_off_slot(struct controller *ctrl);\nvoid pciehp_get_power_status(struct controller *ctrl, u8 *status);\n\n#define INDICATOR_NOOP -1\t \nvoid pciehp_set_indicators(struct controller *ctrl, int pwr, int attn);\n\nvoid pciehp_get_latch_status(struct controller *ctrl, u8 *status);\nint pciehp_query_power_fault(struct controller *ctrl);\nint pciehp_card_present(struct controller *ctrl);\nint pciehp_card_present_or_link_active(struct controller *ctrl);\nint pciehp_check_link_status(struct controller *ctrl);\nint pciehp_check_link_active(struct controller *ctrl);\nvoid pciehp_release_ctrl(struct controller *ctrl);\n\nint pciehp_sysfs_enable_slot(struct hotplug_slot *hotplug_slot);\nint pciehp_sysfs_disable_slot(struct hotplug_slot *hotplug_slot);\nint pciehp_reset_slot(struct hotplug_slot *hotplug_slot, bool probe);\nint pciehp_get_attention_status(struct hotplug_slot *hotplug_slot, u8 *status);\nint pciehp_set_raw_indicator_status(struct hotplug_slot *h_slot, u8 status);\nint pciehp_get_raw_indicator_status(struct hotplug_slot *h_slot, u8 *status);\n\nint pciehp_slot_reset(struct pcie_device *dev);\n\nstatic inline const char *slot_name(struct controller *ctrl)\n{\n\treturn hotplug_slot_name(&ctrl->hotplug_slot);\n}\n\nstatic inline struct controller *to_ctrl(struct hotplug_slot *hotplug_slot)\n{\n\treturn container_of(hotplug_slot, struct controller, hotplug_slot);\n}\n\n#endif\t\t\t\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}