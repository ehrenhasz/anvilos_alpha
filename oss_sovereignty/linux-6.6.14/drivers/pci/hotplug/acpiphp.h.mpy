{
  "module_name": "acpiphp.h",
  "hash_id": "eb9d51c01da3423ef912dd37a5d295ad56132eddef0d7ccadebeb158d87b6d7a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/hotplug/acpiphp.h",
  "human_readable_source": " \n \n\n#ifndef _ACPIPHP_H\n#define _ACPIPHP_H\n\n#include <linux/acpi.h>\n#include <linux/mutex.h>\n#include <linux/pci_hotplug.h>\n\nstruct acpiphp_context;\nstruct acpiphp_bridge;\nstruct acpiphp_slot;\n\n \nstruct slot {\n\tstruct hotplug_slot\thotplug_slot;\n\tstruct acpiphp_slot\t*acpi_slot;\n\tunsigned int sun;\t \n};\n\nstatic inline const char *slot_name(struct slot *slot)\n{\n\treturn hotplug_slot_name(&slot->hotplug_slot);\n}\n\nstatic inline struct slot *to_slot(struct hotplug_slot *hotplug_slot)\n{\n\treturn container_of(hotplug_slot, struct slot, hotplug_slot);\n}\n\n \nstruct acpiphp_bridge {\n\tstruct list_head list;\n\tstruct list_head slots;\n\tstruct kref ref;\n\n\tstruct acpiphp_context *context;\n\n\tint nr_slots;\n\n\t \n\tstruct pci_bus *pci_bus;\n\n\t \n\tstruct pci_dev *pci_dev;\n\n\tbool is_going_away;\n};\n\n\n \nstruct acpiphp_slot {\n\tstruct list_head node;\n\tstruct pci_bus *bus;\n\tstruct list_head funcs;\t\t \n\tstruct slot *slot;\n\n\tu8\t\tdevice;\t\t \n\tu32\t\tflags;\t\t \n};\n\n\n \nstruct acpiphp_func {\n\tstruct acpiphp_bridge *parent;\n\tstruct acpiphp_slot *slot;\n\n\tstruct list_head sibling;\n\n\tu8\t\tfunction;\t \n\tu32\t\tflags;\t\t \n};\n\nstruct acpiphp_context {\n\tstruct acpi_hotplug_context hp;\n\tstruct acpiphp_func func;\n\tstruct acpiphp_bridge *bridge;\n\tunsigned int refcount;\n};\n\nstatic inline struct acpiphp_context *to_acpiphp_context(struct acpi_hotplug_context *hp)\n{\n\treturn container_of(hp, struct acpiphp_context, hp);\n}\n\nstatic inline struct acpiphp_context *func_to_context(struct acpiphp_func *func)\n{\n\treturn container_of(func, struct acpiphp_context, func);\n}\n\nstatic inline struct acpi_device *func_to_acpi_device(struct acpiphp_func *func)\n{\n\treturn func_to_context(func)->hp.self;\n}\n\nstatic inline acpi_handle func_to_handle(struct acpiphp_func *func)\n{\n\treturn func_to_acpi_device(func)->handle;\n}\n\nstruct acpiphp_root_context {\n\tstruct acpi_hotplug_context hp;\n\tstruct acpiphp_bridge *root_bridge;\n};\n\nstatic inline struct acpiphp_root_context *to_acpiphp_root_context(struct acpi_hotplug_context *hp)\n{\n\treturn container_of(hp, struct acpiphp_root_context, hp);\n}\n\n \nstruct acpiphp_attention_info {\n\tint (*set_attn)(struct hotplug_slot *slot, u8 status);\n\tint (*get_attn)(struct hotplug_slot *slot, u8 *status);\n\tstruct module *owner;\n};\n\n \n#define ACPI_STA_ALL\t\t\t(0x0000000f)\n\n \n\n#define SLOT_ENABLED\t\t(0x00000001)\n#define SLOT_IS_GOING_AWAY\t(0x00000002)\n\n \n\n#define FUNC_HAS_STA\t\t(0x00000001)\n#define FUNC_HAS_EJ0\t\t(0x00000002)\n\n \n\n \nint acpiphp_register_attention(struct acpiphp_attention_info *info);\nint acpiphp_unregister_attention(struct acpiphp_attention_info *info);\nint acpiphp_register_hotplug_slot(struct acpiphp_slot *slot, unsigned int sun);\nvoid acpiphp_unregister_hotplug_slot(struct acpiphp_slot *slot);\n\nint acpiphp_enable_slot(struct acpiphp_slot *slot);\nint acpiphp_disable_slot(struct acpiphp_slot *slot);\nu8 acpiphp_get_power_status(struct acpiphp_slot *slot);\nu8 acpiphp_get_latch_status(struct acpiphp_slot *slot);\nu8 acpiphp_get_adapter_status(struct acpiphp_slot *slot);\n\n \nextern bool acpiphp_disabled;\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}