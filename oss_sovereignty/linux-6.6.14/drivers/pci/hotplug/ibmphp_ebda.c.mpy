{
  "module_name": "ibmphp_ebda.c",
  "hash_id": "2f58e3c6c2fd2d27cda63b91619cc1269b0e2977febc66c65f7d1399309f8a88",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/hotplug/ibmphp_ebda.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include \"ibmphp.h\"\n\n \n\n \nLIST_HEAD(ibmphp_ebda_pci_rsrc_head);\nLIST_HEAD(ibmphp_slot_head);\n\n \nstatic struct ebda_hpc_list *hpc_list_ptr;\nstatic struct ebda_rsrc_list *rsrc_list_ptr;\nstatic struct rio_table_hdr *rio_table_ptr = NULL;\nstatic LIST_HEAD(ebda_hpc_head);\nstatic LIST_HEAD(bus_info_head);\nstatic LIST_HEAD(rio_vg_head);\nstatic LIST_HEAD(rio_lo_head);\nstatic LIST_HEAD(opt_vg_head);\nstatic LIST_HEAD(opt_lo_head);\nstatic void __iomem *io_mem;\n\n \nstatic int ebda_rsrc_controller(void);\nstatic int ebda_rsrc_rsrc(void);\nstatic int ebda_rio_table(void);\n\nstatic struct ebda_hpc_list * __init alloc_ebda_hpc_list(void)\n{\n\treturn kzalloc(sizeof(struct ebda_hpc_list), GFP_KERNEL);\n}\n\nstatic struct controller *alloc_ebda_hpc(u32 slot_count, u32 bus_count)\n{\n\tstruct controller *controller;\n\tstruct ebda_hpc_slot *slots;\n\tstruct ebda_hpc_bus *buses;\n\n\tcontroller = kzalloc(sizeof(struct controller), GFP_KERNEL);\n\tif (!controller)\n\t\tgoto error;\n\n\tslots = kcalloc(slot_count, sizeof(struct ebda_hpc_slot), GFP_KERNEL);\n\tif (!slots)\n\t\tgoto error_contr;\n\tcontroller->slots = slots;\n\n\tbuses = kcalloc(bus_count, sizeof(struct ebda_hpc_bus), GFP_KERNEL);\n\tif (!buses)\n\t\tgoto error_slots;\n\tcontroller->buses = buses;\n\n\treturn controller;\nerror_slots:\n\tkfree(controller->slots);\nerror_contr:\n\tkfree(controller);\nerror:\n\treturn NULL;\n}\n\nstatic void free_ebda_hpc(struct controller *controller)\n{\n\tkfree(controller->slots);\n\tkfree(controller->buses);\n\tkfree(controller);\n}\n\nstatic struct ebda_rsrc_list * __init alloc_ebda_rsrc_list(void)\n{\n\treturn kzalloc(sizeof(struct ebda_rsrc_list), GFP_KERNEL);\n}\n\nstatic struct ebda_pci_rsrc *alloc_ebda_pci_rsrc(void)\n{\n\treturn kzalloc(sizeof(struct ebda_pci_rsrc), GFP_KERNEL);\n}\n\nstatic void __init print_bus_info(void)\n{\n\tstruct bus_info *ptr;\n\n\tlist_for_each_entry(ptr, &bus_info_head, bus_info_list) {\n\t\tdebug(\"%s - slot_min = %x\\n\", __func__, ptr->slot_min);\n\t\tdebug(\"%s - slot_max = %x\\n\", __func__, ptr->slot_max);\n\t\tdebug(\"%s - slot_count = %x\\n\", __func__, ptr->slot_count);\n\t\tdebug(\"%s - bus# = %x\\n\", __func__, ptr->busno);\n\t\tdebug(\"%s - current_speed = %x\\n\", __func__, ptr->current_speed);\n\t\tdebug(\"%s - controller_id = %x\\n\", __func__, ptr->controller_id);\n\n\t\tdebug(\"%s - slots_at_33_conv = %x\\n\", __func__, ptr->slots_at_33_conv);\n\t\tdebug(\"%s - slots_at_66_conv = %x\\n\", __func__, ptr->slots_at_66_conv);\n\t\tdebug(\"%s - slots_at_66_pcix = %x\\n\", __func__, ptr->slots_at_66_pcix);\n\t\tdebug(\"%s - slots_at_100_pcix = %x\\n\", __func__, ptr->slots_at_100_pcix);\n\t\tdebug(\"%s - slots_at_133_pcix = %x\\n\", __func__, ptr->slots_at_133_pcix);\n\n\t}\n}\n\nstatic void print_lo_info(void)\n{\n\tstruct rio_detail *ptr;\n\tdebug(\"print_lo_info ----\\n\");\n\tlist_for_each_entry(ptr, &rio_lo_head, rio_detail_list) {\n\t\tdebug(\"%s - rio_node_id = %x\\n\", __func__, ptr->rio_node_id);\n\t\tdebug(\"%s - rio_type = %x\\n\", __func__, ptr->rio_type);\n\t\tdebug(\"%s - owner_id = %x\\n\", __func__, ptr->owner_id);\n\t\tdebug(\"%s - first_slot_num = %x\\n\", __func__, ptr->first_slot_num);\n\t\tdebug(\"%s - wpindex = %x\\n\", __func__, ptr->wpindex);\n\t\tdebug(\"%s - chassis_num = %x\\n\", __func__, ptr->chassis_num);\n\n\t}\n}\n\nstatic void print_vg_info(void)\n{\n\tstruct rio_detail *ptr;\n\tdebug(\"%s ---\\n\", __func__);\n\tlist_for_each_entry(ptr, &rio_vg_head, rio_detail_list) {\n\t\tdebug(\"%s - rio_node_id = %x\\n\", __func__, ptr->rio_node_id);\n\t\tdebug(\"%s - rio_type = %x\\n\", __func__, ptr->rio_type);\n\t\tdebug(\"%s - owner_id = %x\\n\", __func__, ptr->owner_id);\n\t\tdebug(\"%s - first_slot_num = %x\\n\", __func__, ptr->first_slot_num);\n\t\tdebug(\"%s - wpindex = %x\\n\", __func__, ptr->wpindex);\n\t\tdebug(\"%s - chassis_num = %x\\n\", __func__, ptr->chassis_num);\n\n\t}\n}\n\nstatic void __init print_ebda_pci_rsrc(void)\n{\n\tstruct ebda_pci_rsrc *ptr;\n\n\tlist_for_each_entry(ptr, &ibmphp_ebda_pci_rsrc_head, ebda_pci_rsrc_list) {\n\t\tdebug(\"%s - rsrc type: %x bus#: %x dev_func: %x start addr: %x end addr: %x\\n\",\n\t\t\t__func__, ptr->rsrc_type, ptr->bus_num, ptr->dev_fun, ptr->start_addr, ptr->end_addr);\n\t}\n}\n\nstatic void __init print_ibm_slot(void)\n{\n\tstruct slot *ptr;\n\n\tlist_for_each_entry(ptr, &ibmphp_slot_head, ibm_slot_list) {\n\t\tdebug(\"%s - slot_number: %x\\n\", __func__, ptr->number);\n\t}\n}\n\nstatic void __init print_opt_vg(void)\n{\n\tstruct opt_rio *ptr;\n\tdebug(\"%s ---\\n\", __func__);\n\tlist_for_each_entry(ptr, &opt_vg_head, opt_rio_list) {\n\t\tdebug(\"%s - rio_type %x\\n\", __func__, ptr->rio_type);\n\t\tdebug(\"%s - chassis_num: %x\\n\", __func__, ptr->chassis_num);\n\t\tdebug(\"%s - first_slot_num: %x\\n\", __func__, ptr->first_slot_num);\n\t\tdebug(\"%s - middle_num: %x\\n\", __func__, ptr->middle_num);\n\t}\n}\n\nstatic void __init print_ebda_hpc(void)\n{\n\tstruct controller *hpc_ptr;\n\tu16 index;\n\n\tlist_for_each_entry(hpc_ptr, &ebda_hpc_head, ebda_hpc_list) {\n\t\tfor (index = 0; index < hpc_ptr->slot_count; index++) {\n\t\t\tdebug(\"%s - physical slot#: %x\\n\", __func__, hpc_ptr->slots[index].slot_num);\n\t\t\tdebug(\"%s - pci bus# of the slot: %x\\n\", __func__, hpc_ptr->slots[index].slot_bus_num);\n\t\t\tdebug(\"%s - index into ctlr addr: %x\\n\", __func__, hpc_ptr->slots[index].ctl_index);\n\t\t\tdebug(\"%s - cap of the slot: %x\\n\", __func__, hpc_ptr->slots[index].slot_cap);\n\t\t}\n\n\t\tfor (index = 0; index < hpc_ptr->bus_count; index++)\n\t\t\tdebug(\"%s - bus# of each bus controlled by this ctlr: %x\\n\", __func__, hpc_ptr->buses[index].bus_num);\n\n\t\tdebug(\"%s - type of hpc: %x\\n\", __func__, hpc_ptr->ctlr_type);\n\t\tswitch (hpc_ptr->ctlr_type) {\n\t\tcase 1:\n\t\t\tdebug(\"%s - bus: %x\\n\", __func__, hpc_ptr->u.pci_ctlr.bus);\n\t\t\tdebug(\"%s - dev_fun: %x\\n\", __func__, hpc_ptr->u.pci_ctlr.dev_fun);\n\t\t\tdebug(\"%s - irq: %x\\n\", __func__, hpc_ptr->irq);\n\t\t\tbreak;\n\n\t\tcase 0:\n\t\t\tdebug(\"%s - io_start: %x\\n\", __func__, hpc_ptr->u.isa_ctlr.io_start);\n\t\t\tdebug(\"%s - io_end: %x\\n\", __func__, hpc_ptr->u.isa_ctlr.io_end);\n\t\t\tdebug(\"%s - irq: %x\\n\", __func__, hpc_ptr->irq);\n\t\t\tbreak;\n\n\t\tcase 2:\n\t\tcase 4:\n\t\t\tdebug(\"%s - wpegbbar: %lx\\n\", __func__, hpc_ptr->u.wpeg_ctlr.wpegbbar);\n\t\t\tdebug(\"%s - i2c_addr: %x\\n\", __func__, hpc_ptr->u.wpeg_ctlr.i2c_addr);\n\t\t\tdebug(\"%s - irq: %x\\n\", __func__, hpc_ptr->irq);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nint __init ibmphp_access_ebda(void)\n{\n\tu8 format, num_ctlrs, rio_complete, hs_complete, ebda_sz;\n\tu16 ebda_seg, num_entries, next_offset, offset, blk_id, sub_addr, re, rc_id, re_id, base;\n\tint rc = 0;\n\n\n\trio_complete = 0;\n\ths_complete = 0;\n\n\tio_mem = ioremap((0x40 << 4) + 0x0e, 2);\n\tif (!io_mem)\n\t\treturn -ENOMEM;\n\tebda_seg = readw(io_mem);\n\tiounmap(io_mem);\n\tdebug(\"returned ebda segment: %x\\n\", ebda_seg);\n\n\tio_mem = ioremap(ebda_seg<<4, 1);\n\tif (!io_mem)\n\t\treturn -ENOMEM;\n\tebda_sz = readb(io_mem);\n\tiounmap(io_mem);\n\tdebug(\"ebda size: %d(KiB)\\n\", ebda_sz);\n\tif (ebda_sz == 0)\n\t\treturn -ENOMEM;\n\n\tio_mem = ioremap(ebda_seg<<4, (ebda_sz * 1024));\n\tif (!io_mem)\n\t\treturn -ENOMEM;\n\tnext_offset = 0x180;\n\n\tfor (;;) {\n\t\toffset = next_offset;\n\n\t\t \n\t\tif (WARN(offset > (ebda_sz * 1024 - 4),\n\t\t\t \"ibmphp_ebda: next read is beyond ebda_sz\\n\"))\n\t\t\tbreak;\n\n\t\tnext_offset = readw(io_mem + offset);\t \n\n\t\toffset += 2;\n\t\tif (next_offset == 0)\t \n\t\t\tbreak;\n\t\tblk_id = readw(io_mem + offset);\t \n\n\t\toffset += 2;\n\t\t \n\t\tif (blk_id != 0x4853 && blk_id != 0x4752)\n\t\t\tcontinue;\n\t\t \n\t\tif (blk_id == 0x4853) {\n\t\t\tdebug(\"now enter hot swap block---\\n\");\n\t\t\tdebug(\"hot blk id: %x\\n\", blk_id);\n\t\t\tformat = readb(io_mem + offset);\n\n\t\t\toffset += 1;\n\t\t\tif (format != 4)\n\t\t\t\tgoto error_nodev;\n\t\t\tdebug(\"hot blk format: %x\\n\", format);\n\t\t\t \n\t\t\tbase = offset;\n\n\t\t\tsub_addr = base;\n\t\t\tre = readw(io_mem + sub_addr);\t \n\n\t\t\tsub_addr += 2;\n\t\t\trc_id = readw(io_mem + sub_addr);\t \n\n\t\t\tsub_addr += 2;\n\t\t\tif (rc_id != 0x5243)\n\t\t\t\tgoto error_nodev;\n\t\t\t \n\t\t\tnum_ctlrs = readb(io_mem + sub_addr);\n\n\t\t\tsub_addr += 1;\n\t\t\thpc_list_ptr = alloc_ebda_hpc_list();\n\t\t\tif (!hpc_list_ptr) {\n\t\t\t\trc = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\thpc_list_ptr->format = format;\n\t\t\thpc_list_ptr->num_ctlrs = num_ctlrs;\n\t\t\thpc_list_ptr->phys_addr = sub_addr;\t \n\t\t\tdebug(\"info about hpc descriptor---\\n\");\n\t\t\tdebug(\"hot blk format: %x\\n\", format);\n\t\t\tdebug(\"num of controller: %x\\n\", num_ctlrs);\n\t\t\tdebug(\"offset of hpc data structure entries: %x\\n \", sub_addr);\n\n\t\t\tsub_addr = base + re;\t \n\t\t\t \n\t\t\trc = readw(io_mem + sub_addr);\t \n\n\t\t\tsub_addr += 2;\n\t\t\tre_id = readw(io_mem + sub_addr);\t \n\n\t\t\tsub_addr += 2;\n\t\t\tif (re_id != 0x5245)\n\t\t\t\tgoto error_nodev;\n\n\t\t\t \n\t\t\tnum_entries = readw(io_mem + sub_addr);\n\n\t\t\tsub_addr += 2;\t \n\t\t\trsrc_list_ptr = alloc_ebda_rsrc_list();\n\t\t\tif (!rsrc_list_ptr) {\n\t\t\t\trc = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\trsrc_list_ptr->format = format;\n\t\t\trsrc_list_ptr->num_entries = num_entries;\n\t\t\trsrc_list_ptr->phys_addr = sub_addr;\n\n\t\t\tdebug(\"info about rsrc descriptor---\\n\");\n\t\t\tdebug(\"format: %x\\n\", format);\n\t\t\tdebug(\"num of rsrc: %x\\n\", num_entries);\n\t\t\tdebug(\"offset of rsrc data structure entries: %x\\n \", sub_addr);\n\n\t\t\ths_complete = 1;\n\t\t} else {\n\t\t \n\t\t\tdebug(\"now enter io table ---\\n\");\n\t\t\tdebug(\"rio blk id: %x\\n\", blk_id);\n\n\t\t\trio_table_ptr = kzalloc(sizeof(struct rio_table_hdr), GFP_KERNEL);\n\t\t\tif (!rio_table_ptr) {\n\t\t\t\trc = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\trio_table_ptr->ver_num = readb(io_mem + offset);\n\t\t\trio_table_ptr->scal_count = readb(io_mem + offset + 1);\n\t\t\trio_table_ptr->riodev_count = readb(io_mem + offset + 2);\n\t\t\trio_table_ptr->offset = offset + 3 ;\n\n\t\t\tdebug(\"info about rio table hdr ---\\n\");\n\t\t\tdebug(\"ver_num: %x\\nscal_count: %x\\nriodev_count: %x\\noffset of rio table: %x\\n \",\n\t\t\t\trio_table_ptr->ver_num, rio_table_ptr->scal_count,\n\t\t\t\trio_table_ptr->riodev_count, rio_table_ptr->offset);\n\n\t\t\trio_complete = 1;\n\t\t}\n\t}\n\n\tif (!hs_complete && !rio_complete)\n\t\tgoto error_nodev;\n\n\tif (rio_table_ptr) {\n\t\tif (rio_complete && rio_table_ptr->ver_num == 3) {\n\t\t\trc = ebda_rio_table();\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\trc = ebda_rsrc_controller();\n\tif (rc)\n\t\tgoto out;\n\n\trc = ebda_rsrc_rsrc();\n\tgoto out;\nerror_nodev:\n\trc = -ENODEV;\nout:\n\tiounmap(io_mem);\n\treturn rc;\n}\n\n \nstatic int __init ebda_rio_table(void)\n{\n\tu16 offset;\n\tu8 i;\n\tstruct rio_detail *rio_detail_ptr;\n\n\toffset = rio_table_ptr->offset;\n\toffset += 12 * rio_table_ptr->scal_count;\n\n\t \n\tfor (i = 0; i < rio_table_ptr->riodev_count; i++) {\n\t\trio_detail_ptr = kzalloc(sizeof(struct rio_detail), GFP_KERNEL);\n\t\tif (!rio_detail_ptr)\n\t\t\treturn -ENOMEM;\n\t\trio_detail_ptr->rio_node_id = readb(io_mem + offset);\n\t\trio_detail_ptr->bbar = readl(io_mem + offset + 1);\n\t\trio_detail_ptr->rio_type = readb(io_mem + offset + 5);\n\t\trio_detail_ptr->owner_id = readb(io_mem + offset + 6);\n\t\trio_detail_ptr->port0_node_connect = readb(io_mem + offset + 7);\n\t\trio_detail_ptr->port0_port_connect = readb(io_mem + offset + 8);\n\t\trio_detail_ptr->port1_node_connect = readb(io_mem + offset + 9);\n\t\trio_detail_ptr->port1_port_connect = readb(io_mem + offset + 10);\n\t\trio_detail_ptr->first_slot_num = readb(io_mem + offset + 11);\n\t\trio_detail_ptr->status = readb(io_mem + offset + 12);\n\t\trio_detail_ptr->wpindex = readb(io_mem + offset + 13);\n\t\trio_detail_ptr->chassis_num = readb(io_mem + offset + 14);\n \n\t\t \n\t\tif (rio_detail_ptr->rio_type == 4 || rio_detail_ptr->rio_type == 5)\n\t\t\tlist_add(&rio_detail_ptr->rio_detail_list, &rio_vg_head);\n\t\t \n\t\telse if (rio_detail_ptr->rio_type == 6 || rio_detail_ptr->rio_type == 7)\n\t\t\tlist_add(&rio_detail_ptr->rio_detail_list, &rio_lo_head);\n\t\telse\n\t\t\t \n\t\t\tkfree(rio_detail_ptr);\n\t\toffset += 15;\n\t}\n\tprint_lo_info();\n\tprint_vg_info();\n\treturn 0;\n}\n\n \nstatic struct opt_rio *search_opt_vg(u8 chassis_num)\n{\n\tstruct opt_rio *ptr;\n\tlist_for_each_entry(ptr, &opt_vg_head, opt_rio_list) {\n\t\tif (ptr->chassis_num == chassis_num)\n\t\t\treturn ptr;\n\t}\n\treturn NULL;\n}\n\nstatic int __init combine_wpg_for_chassis(void)\n{\n\tstruct opt_rio *opt_rio_ptr = NULL;\n\tstruct rio_detail *rio_detail_ptr = NULL;\n\n\tlist_for_each_entry(rio_detail_ptr, &rio_vg_head, rio_detail_list) {\n\t\topt_rio_ptr = search_opt_vg(rio_detail_ptr->chassis_num);\n\t\tif (!opt_rio_ptr) {\n\t\t\topt_rio_ptr = kzalloc(sizeof(struct opt_rio), GFP_KERNEL);\n\t\t\tif (!opt_rio_ptr)\n\t\t\t\treturn -ENOMEM;\n\t\t\topt_rio_ptr->rio_type = rio_detail_ptr->rio_type;\n\t\t\topt_rio_ptr->chassis_num = rio_detail_ptr->chassis_num;\n\t\t\topt_rio_ptr->first_slot_num = rio_detail_ptr->first_slot_num;\n\t\t\topt_rio_ptr->middle_num = rio_detail_ptr->first_slot_num;\n\t\t\tlist_add(&opt_rio_ptr->opt_rio_list, &opt_vg_head);\n\t\t} else {\n\t\t\topt_rio_ptr->first_slot_num = min(opt_rio_ptr->first_slot_num, rio_detail_ptr->first_slot_num);\n\t\t\topt_rio_ptr->middle_num = max(opt_rio_ptr->middle_num, rio_detail_ptr->first_slot_num);\n\t\t}\n\t}\n\tprint_opt_vg();\n\treturn 0;\n}\n\n \nstatic struct opt_rio_lo *search_opt_lo(u8 chassis_num)\n{\n\tstruct opt_rio_lo *ptr;\n\tlist_for_each_entry(ptr, &opt_lo_head, opt_rio_lo_list) {\n\t\tif (ptr->chassis_num == chassis_num)\n\t\t\treturn ptr;\n\t}\n\treturn NULL;\n}\n\nstatic int combine_wpg_for_expansion(void)\n{\n\tstruct opt_rio_lo *opt_rio_lo_ptr = NULL;\n\tstruct rio_detail *rio_detail_ptr = NULL;\n\n\tlist_for_each_entry(rio_detail_ptr, &rio_lo_head, rio_detail_list) {\n\t\topt_rio_lo_ptr = search_opt_lo(rio_detail_ptr->chassis_num);\n\t\tif (!opt_rio_lo_ptr) {\n\t\t\topt_rio_lo_ptr = kzalloc(sizeof(struct opt_rio_lo), GFP_KERNEL);\n\t\t\tif (!opt_rio_lo_ptr)\n\t\t\t\treturn -ENOMEM;\n\t\t\topt_rio_lo_ptr->rio_type = rio_detail_ptr->rio_type;\n\t\t\topt_rio_lo_ptr->chassis_num = rio_detail_ptr->chassis_num;\n\t\t\topt_rio_lo_ptr->first_slot_num = rio_detail_ptr->first_slot_num;\n\t\t\topt_rio_lo_ptr->middle_num = rio_detail_ptr->first_slot_num;\n\t\t\topt_rio_lo_ptr->pack_count = 1;\n\n\t\t\tlist_add(&opt_rio_lo_ptr->opt_rio_lo_list, &opt_lo_head);\n\t\t} else {\n\t\t\topt_rio_lo_ptr->first_slot_num = min(opt_rio_lo_ptr->first_slot_num, rio_detail_ptr->first_slot_num);\n\t\t\topt_rio_lo_ptr->middle_num = max(opt_rio_lo_ptr->middle_num, rio_detail_ptr->first_slot_num);\n\t\t\topt_rio_lo_ptr->pack_count = 2;\n\t\t}\n\t}\n\treturn 0;\n}\n\n\n \nstatic int first_slot_num(u8 slot_num, u8 first_slot, u8 var)\n{\n\tstruct opt_rio *opt_vg_ptr = NULL;\n\tstruct opt_rio_lo *opt_lo_ptr = NULL;\n\tint rc = 0;\n\n\tif (!var) {\n\t\tlist_for_each_entry(opt_vg_ptr, &opt_vg_head, opt_rio_list) {\n\t\t\tif ((first_slot < opt_vg_ptr->first_slot_num) && (slot_num >= opt_vg_ptr->first_slot_num)) {\n\t\t\t\trc = -ENODEV;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tlist_for_each_entry(opt_lo_ptr, &opt_lo_head, opt_rio_lo_list) {\n\t\t\tif ((first_slot < opt_lo_ptr->first_slot_num) && (slot_num >= opt_lo_ptr->first_slot_num)) {\n\t\t\t\trc = -ENODEV;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn rc;\n}\n\nstatic struct opt_rio_lo *find_rxe_num(u8 slot_num)\n{\n\tstruct opt_rio_lo *opt_lo_ptr;\n\n\tlist_for_each_entry(opt_lo_ptr, &opt_lo_head, opt_rio_lo_list) {\n\t\t\n\t\tif ((slot_num >= opt_lo_ptr->first_slot_num) && (!first_slot_num(slot_num, opt_lo_ptr->first_slot_num, 1)))\n\t\t\treturn opt_lo_ptr;\n\t}\n\treturn NULL;\n}\n\nstatic struct opt_rio *find_chassis_num(u8 slot_num)\n{\n\tstruct opt_rio *opt_vg_ptr;\n\n\tlist_for_each_entry(opt_vg_ptr, &opt_vg_head, opt_rio_list) {\n\t\t\n\t\tif ((slot_num >= opt_vg_ptr->first_slot_num) && (!first_slot_num(slot_num, opt_vg_ptr->first_slot_num, 0)))\n\t\t\treturn opt_vg_ptr;\n\t}\n\treturn NULL;\n}\n\n \nstatic u8 calculate_first_slot(u8 slot_num)\n{\n\tu8 first_slot = 1;\n\tstruct slot *slot_cur;\n\n\tlist_for_each_entry(slot_cur, &ibmphp_slot_head, ibm_slot_list) {\n\t\tif (slot_cur->ctrl) {\n\t\t\tif ((slot_cur->ctrl->ctlr_type != 4) && (slot_cur->ctrl->ending_slot_num > first_slot) && (slot_num > slot_cur->ctrl->ending_slot_num))\n\t\t\t\tfirst_slot = slot_cur->ctrl->ending_slot_num;\n\t\t}\n\t}\n\treturn first_slot + 1;\n\n}\n\n#define SLOT_NAME_SIZE 30\n\nstatic char *create_file_name(struct slot *slot_cur)\n{\n\tstruct opt_rio *opt_vg_ptr = NULL;\n\tstruct opt_rio_lo *opt_lo_ptr = NULL;\n\tstatic char str[SLOT_NAME_SIZE];\n\tint which = 0;  \n\tu8 number = 1;  \n\tu8 first_slot = 1;\n\tu8 slot_num;\n\tu8 flag = 0;\n\n\tif (!slot_cur) {\n\t\terr(\"Structure passed is empty\\n\");\n\t\treturn NULL;\n\t}\n\n\tslot_num = slot_cur->number;\n\n\tmemset(str, 0, sizeof(str));\n\n\tif (rio_table_ptr) {\n\t\tif (rio_table_ptr->ver_num == 3) {\n\t\t\topt_vg_ptr = find_chassis_num(slot_num);\n\t\t\topt_lo_ptr = find_rxe_num(slot_num);\n\t\t}\n\t}\n\tif (opt_vg_ptr) {\n\t\tif (opt_lo_ptr) {\n\t\t\tif ((slot_num - opt_vg_ptr->first_slot_num) > (slot_num - opt_lo_ptr->first_slot_num)) {\n\t\t\t\tnumber = opt_lo_ptr->chassis_num;\n\t\t\t\tfirst_slot = opt_lo_ptr->first_slot_num;\n\t\t\t\twhich = 1;  \n\t\t\t} else {\n\t\t\t\tfirst_slot = opt_vg_ptr->first_slot_num;\n\t\t\t\tnumber = opt_vg_ptr->chassis_num;\n\t\t\t\twhich = 0;\n\t\t\t}\n\t\t} else {\n\t\t\tfirst_slot = opt_vg_ptr->first_slot_num;\n\t\t\tnumber = opt_vg_ptr->chassis_num;\n\t\t\twhich = 0;\n\t\t}\n\t\t++flag;\n\t} else if (opt_lo_ptr) {\n\t\tnumber = opt_lo_ptr->chassis_num;\n\t\tfirst_slot = opt_lo_ptr->first_slot_num;\n\t\twhich = 1;\n\t\t++flag;\n\t} else if (rio_table_ptr) {\n\t\tif (rio_table_ptr->ver_num == 3) {\n\t\t\t \n\t\t\treturn NULL;\n\t\t}\n\t}\n\tif (!flag) {\n\t\tif (slot_cur->ctrl->ctlr_type == 4) {\n\t\t\tfirst_slot = calculate_first_slot(slot_num);\n\t\t\twhich = 1;\n\t\t} else {\n\t\t\twhich = 0;\n\t\t}\n\t}\n\n\tsprintf(str, \"%s%dslot%d\",\n\t\twhich == 0 ? \"chassis\" : \"rxe\",\n\t\tnumber, slot_num - first_slot + 1);\n\treturn str;\n}\n\nstatic int fillslotinfo(struct hotplug_slot *hotplug_slot)\n{\n\tstruct slot *slot;\n\tint rc = 0;\n\n\tslot = to_slot(hotplug_slot);\n\trc = ibmphp_hpc_readslot(slot, READ_ALLSTAT, NULL);\n\treturn rc;\n}\n\nstatic struct pci_driver ibmphp_driver;\n\n \nstatic int __init ebda_rsrc_controller(void)\n{\n\tu16 addr, addr_slot, addr_bus;\n\tu8 ctlr_id, temp, bus_index;\n\tu16 ctlr, slot, bus;\n\tu16 slot_num, bus_num, index;\n\tstruct controller *hpc_ptr;\n\tstruct ebda_hpc_bus *bus_ptr;\n\tstruct ebda_hpc_slot *slot_ptr;\n\tstruct bus_info *bus_info_ptr1, *bus_info_ptr2;\n\tint rc;\n\tstruct slot *tmp_slot;\n\tchar name[SLOT_NAME_SIZE];\n\n\taddr = hpc_list_ptr->phys_addr;\n\tfor (ctlr = 0; ctlr < hpc_list_ptr->num_ctlrs; ctlr++) {\n\t\tbus_index = 1;\n\t\tctlr_id = readb(io_mem + addr);\n\t\taddr += 1;\n\t\tslot_num = readb(io_mem + addr);\n\n\t\taddr += 1;\n\t\taddr_slot = addr;\t \n\t\taddr += (slot_num * 4);\n\n\t\tbus_num = readb(io_mem + addr);\n\n\t\taddr += 1;\n\t\taddr_bus = addr;\t \n\t\taddr += (bus_num * 9);\t \n\t\ttemp = readb(io_mem + addr);\n\n\t\taddr += 1;\n\t\t \n\t\thpc_ptr = alloc_ebda_hpc(slot_num, bus_num);\n\t\tif (!hpc_ptr) {\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\thpc_ptr->ctlr_id = ctlr_id;\n\t\thpc_ptr->ctlr_relative_id = ctlr;\n\t\thpc_ptr->slot_count = slot_num;\n\t\thpc_ptr->bus_count = bus_num;\n\t\tdebug(\"now enter ctlr data structure ---\\n\");\n\t\tdebug(\"ctlr id: %x\\n\", ctlr_id);\n\t\tdebug(\"ctlr_relative_id: %x\\n\", hpc_ptr->ctlr_relative_id);\n\t\tdebug(\"count of slots controlled by this ctlr: %x\\n\", slot_num);\n\t\tdebug(\"count of buses controlled by this ctlr: %x\\n\", bus_num);\n\n\t\t \n\t\tslot_ptr = hpc_ptr->slots;\n\t\tfor (slot = 0; slot < slot_num; slot++) {\n\t\t\tslot_ptr->slot_num = readb(io_mem + addr_slot);\n\t\t\tslot_ptr->slot_bus_num = readb(io_mem + addr_slot + slot_num);\n\t\t\tslot_ptr->ctl_index = readb(io_mem + addr_slot + 2*slot_num);\n\t\t\tslot_ptr->slot_cap = readb(io_mem + addr_slot + 3*slot_num);\n\n\t\t\t\n\n\t\t\tbus_info_ptr2 = ibmphp_find_same_bus_num(slot_ptr->slot_bus_num);\n\t\t\tif (!bus_info_ptr2) {\n\t\t\t\tbus_info_ptr1 = kzalloc(sizeof(struct bus_info), GFP_KERNEL);\n\t\t\t\tif (!bus_info_ptr1) {\n\t\t\t\t\trc = -ENOMEM;\n\t\t\t\t\tgoto error_no_slot;\n\t\t\t\t}\n\t\t\t\tbus_info_ptr1->slot_min = slot_ptr->slot_num;\n\t\t\t\tbus_info_ptr1->slot_max = slot_ptr->slot_num;\n\t\t\t\tbus_info_ptr1->slot_count += 1;\n\t\t\t\tbus_info_ptr1->busno = slot_ptr->slot_bus_num;\n\t\t\t\tbus_info_ptr1->index = bus_index++;\n\t\t\t\tbus_info_ptr1->current_speed = 0xff;\n\t\t\t\tbus_info_ptr1->current_bus_mode = 0xff;\n\n\t\t\t\tbus_info_ptr1->controller_id = hpc_ptr->ctlr_id;\n\n\t\t\t\tlist_add_tail(&bus_info_ptr1->bus_info_list, &bus_info_head);\n\n\t\t\t} else {\n\t\t\t\tbus_info_ptr2->slot_min = min(bus_info_ptr2->slot_min, slot_ptr->slot_num);\n\t\t\t\tbus_info_ptr2->slot_max = max(bus_info_ptr2->slot_max, slot_ptr->slot_num);\n\t\t\t\tbus_info_ptr2->slot_count += 1;\n\n\t\t\t}\n\n\t\t\t\n\n\t\t\tslot_ptr++;\n\t\t\taddr_slot += 1;\n\t\t}\n\n\t\t \n\t\tbus_ptr = hpc_ptr->buses;\n\t\tfor (bus = 0; bus < bus_num; bus++) {\n\t\t\tbus_ptr->bus_num = readb(io_mem + addr_bus + bus);\n\t\t\tbus_ptr->slots_at_33_conv = readb(io_mem + addr_bus + bus_num + 8 * bus);\n\t\t\tbus_ptr->slots_at_66_conv = readb(io_mem + addr_bus + bus_num + 8 * bus + 1);\n\n\t\t\tbus_ptr->slots_at_66_pcix = readb(io_mem + addr_bus + bus_num + 8 * bus + 2);\n\n\t\t\tbus_ptr->slots_at_100_pcix = readb(io_mem + addr_bus + bus_num + 8 * bus + 3);\n\n\t\t\tbus_ptr->slots_at_133_pcix = readb(io_mem + addr_bus + bus_num + 8 * bus + 4);\n\n\t\t\tbus_info_ptr2 = ibmphp_find_same_bus_num(bus_ptr->bus_num);\n\t\t\tif (bus_info_ptr2) {\n\t\t\t\tbus_info_ptr2->slots_at_33_conv = bus_ptr->slots_at_33_conv;\n\t\t\t\tbus_info_ptr2->slots_at_66_conv = bus_ptr->slots_at_66_conv;\n\t\t\t\tbus_info_ptr2->slots_at_66_pcix = bus_ptr->slots_at_66_pcix;\n\t\t\t\tbus_info_ptr2->slots_at_100_pcix = bus_ptr->slots_at_100_pcix;\n\t\t\t\tbus_info_ptr2->slots_at_133_pcix = bus_ptr->slots_at_133_pcix;\n\t\t\t}\n\t\t\tbus_ptr++;\n\t\t}\n\n\t\thpc_ptr->ctlr_type = temp;\n\n\t\tswitch (hpc_ptr->ctlr_type) {\n\t\t\tcase 1:\n\t\t\t\thpc_ptr->u.pci_ctlr.bus = readb(io_mem + addr);\n\t\t\t\thpc_ptr->u.pci_ctlr.dev_fun = readb(io_mem + addr + 1);\n\t\t\t\thpc_ptr->irq = readb(io_mem + addr + 2);\n\t\t\t\taddr += 3;\n\t\t\t\tdebug(\"ctrl bus = %x, ctlr devfun = %x, irq = %x\\n\",\n\t\t\t\t\thpc_ptr->u.pci_ctlr.bus,\n\t\t\t\t\thpc_ptr->u.pci_ctlr.dev_fun, hpc_ptr->irq);\n\t\t\t\tbreak;\n\n\t\t\tcase 0:\n\t\t\t\thpc_ptr->u.isa_ctlr.io_start = readw(io_mem + addr);\n\t\t\t\thpc_ptr->u.isa_ctlr.io_end = readw(io_mem + addr + 2);\n\t\t\t\tif (!request_region(hpc_ptr->u.isa_ctlr.io_start,\n\t\t\t\t\t\t     (hpc_ptr->u.isa_ctlr.io_end - hpc_ptr->u.isa_ctlr.io_start + 1),\n\t\t\t\t\t\t     \"ibmphp\")) {\n\t\t\t\t\trc = -ENODEV;\n\t\t\t\t\tgoto error_no_slot;\n\t\t\t\t}\n\t\t\t\thpc_ptr->irq = readb(io_mem + addr + 4);\n\t\t\t\taddr += 5;\n\t\t\t\tbreak;\n\n\t\t\tcase 2:\n\t\t\tcase 4:\n\t\t\t\thpc_ptr->u.wpeg_ctlr.wpegbbar = readl(io_mem + addr);\n\t\t\t\thpc_ptr->u.wpeg_ctlr.i2c_addr = readb(io_mem + addr + 4);\n\t\t\t\thpc_ptr->irq = readb(io_mem + addr + 5);\n\t\t\t\taddr += 6;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\trc = -ENODEV;\n\t\t\t\tgoto error_no_slot;\n\t\t}\n\n\t\t\n\t\tcombine_wpg_for_chassis();\n\t\tcombine_wpg_for_expansion();\n\t\thpc_ptr->revision = 0xff;\n\t\thpc_ptr->options = 0xff;\n\t\thpc_ptr->starting_slot_num = hpc_ptr->slots[0].slot_num;\n\t\thpc_ptr->ending_slot_num = hpc_ptr->slots[slot_num-1].slot_num;\n\n\t\t\n\t\tfor (index = 0; index < hpc_ptr->slot_count; index++) {\n\t\t\ttmp_slot = kzalloc(sizeof(*tmp_slot), GFP_KERNEL);\n\t\t\tif (!tmp_slot) {\n\t\t\t\trc = -ENOMEM;\n\t\t\t\tgoto error_no_slot;\n\t\t\t}\n\n\t\t\ttmp_slot->flag = 1;\n\n\t\t\ttmp_slot->capabilities = hpc_ptr->slots[index].slot_cap;\n\t\t\tif ((hpc_ptr->slots[index].slot_cap & EBDA_SLOT_133_MAX) == EBDA_SLOT_133_MAX)\n\t\t\t\ttmp_slot->supported_speed =  3;\n\t\t\telse if ((hpc_ptr->slots[index].slot_cap & EBDA_SLOT_100_MAX) == EBDA_SLOT_100_MAX)\n\t\t\t\ttmp_slot->supported_speed =  2;\n\t\t\telse if ((hpc_ptr->slots[index].slot_cap & EBDA_SLOT_66_MAX) == EBDA_SLOT_66_MAX)\n\t\t\t\ttmp_slot->supported_speed =  1;\n\n\t\t\tif ((hpc_ptr->slots[index].slot_cap & EBDA_SLOT_PCIX_CAP) == EBDA_SLOT_PCIX_CAP)\n\t\t\t\ttmp_slot->supported_bus_mode = 1;\n\t\t\telse\n\t\t\t\ttmp_slot->supported_bus_mode = 0;\n\n\n\t\t\ttmp_slot->bus = hpc_ptr->slots[index].slot_bus_num;\n\n\t\t\tbus_info_ptr1 = ibmphp_find_same_bus_num(hpc_ptr->slots[index].slot_bus_num);\n\t\t\tif (!bus_info_ptr1) {\n\t\t\t\trc = -ENODEV;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\ttmp_slot->bus_on = bus_info_ptr1;\n\t\t\tbus_info_ptr1 = NULL;\n\t\t\ttmp_slot->ctrl = hpc_ptr;\n\n\t\t\ttmp_slot->ctlr_index = hpc_ptr->slots[index].ctl_index;\n\t\t\ttmp_slot->number = hpc_ptr->slots[index].slot_num;\n\n\t\t\trc = fillslotinfo(&tmp_slot->hotplug_slot);\n\t\t\tif (rc)\n\t\t\t\tgoto error;\n\n\t\t\trc = ibmphp_init_devno(&tmp_slot);\n\t\t\tif (rc)\n\t\t\t\tgoto error;\n\t\t\ttmp_slot->hotplug_slot.ops = &ibmphp_hotplug_slot_ops;\n\n\t\t\t\n\n\t\t\tlist_add(&tmp_slot->ibm_slot_list, &ibmphp_slot_head);\n\t\t}\n\n\t\tprint_bus_info();\n\t\tlist_add(&hpc_ptr->ebda_hpc_list, &ebda_hpc_head);\n\n\t}\t\t\t \n\n\tlist_for_each_entry(tmp_slot, &ibmphp_slot_head, ibm_slot_list) {\n\t\tsnprintf(name, SLOT_NAME_SIZE, \"%s\", create_file_name(tmp_slot));\n\t\tpci_hp_register(&tmp_slot->hotplug_slot,\n\t\t\tpci_find_bus(0, tmp_slot->bus), tmp_slot->device, name);\n\t}\n\n\tprint_ebda_hpc();\n\tprint_ibm_slot();\n\treturn 0;\n\nerror:\n\tkfree(tmp_slot);\nerror_no_slot:\n\tfree_ebda_hpc(hpc_ptr);\n\treturn rc;\n}\n\n \nstatic int __init ebda_rsrc_rsrc(void)\n{\n\tu16 addr;\n\tshort rsrc;\n\tu8 type, rsrc_type;\n\tstruct ebda_pci_rsrc *rsrc_ptr;\n\n\taddr = rsrc_list_ptr->phys_addr;\n\tdebug(\"now entering rsrc land\\n\");\n\tdebug(\"offset of rsrc: %x\\n\", rsrc_list_ptr->phys_addr);\n\n\tfor (rsrc = 0; rsrc < rsrc_list_ptr->num_entries; rsrc++) {\n\t\ttype = readb(io_mem + addr);\n\n\t\taddr += 1;\n\t\trsrc_type = type & EBDA_RSRC_TYPE_MASK;\n\n\t\tif (rsrc_type == EBDA_IO_RSRC_TYPE) {\n\t\t\trsrc_ptr = alloc_ebda_pci_rsrc();\n\t\t\tif (!rsrc_ptr) {\n\t\t\t\tiounmap(io_mem);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\trsrc_ptr->rsrc_type = type;\n\n\t\t\trsrc_ptr->bus_num = readb(io_mem + addr);\n\t\t\trsrc_ptr->dev_fun = readb(io_mem + addr + 1);\n\t\t\trsrc_ptr->start_addr = readw(io_mem + addr + 2);\n\t\t\trsrc_ptr->end_addr = readw(io_mem + addr + 4);\n\t\t\taddr += 6;\n\n\t\t\tdebug(\"rsrc from io type ----\\n\");\n\t\t\tdebug(\"rsrc type: %x bus#: %x dev_func: %x start addr: %x end addr: %x\\n\",\n\t\t\t\trsrc_ptr->rsrc_type, rsrc_ptr->bus_num, rsrc_ptr->dev_fun, rsrc_ptr->start_addr, rsrc_ptr->end_addr);\n\n\t\t\tlist_add(&rsrc_ptr->ebda_pci_rsrc_list, &ibmphp_ebda_pci_rsrc_head);\n\t\t}\n\n\t\tif (rsrc_type == EBDA_MEM_RSRC_TYPE || rsrc_type == EBDA_PFM_RSRC_TYPE) {\n\t\t\trsrc_ptr = alloc_ebda_pci_rsrc();\n\t\t\tif (!rsrc_ptr) {\n\t\t\t\tiounmap(io_mem);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\trsrc_ptr->rsrc_type = type;\n\n\t\t\trsrc_ptr->bus_num = readb(io_mem + addr);\n\t\t\trsrc_ptr->dev_fun = readb(io_mem + addr + 1);\n\t\t\trsrc_ptr->start_addr = readl(io_mem + addr + 2);\n\t\t\trsrc_ptr->end_addr = readl(io_mem + addr + 6);\n\t\t\taddr += 10;\n\n\t\t\tdebug(\"rsrc from mem or pfm ---\\n\");\n\t\t\tdebug(\"rsrc type: %x bus#: %x dev_func: %x start addr: %x end addr: %x\\n\",\n\t\t\t\trsrc_ptr->rsrc_type, rsrc_ptr->bus_num, rsrc_ptr->dev_fun, rsrc_ptr->start_addr, rsrc_ptr->end_addr);\n\n\t\t\tlist_add(&rsrc_ptr->ebda_pci_rsrc_list, &ibmphp_ebda_pci_rsrc_head);\n\t\t}\n\t}\n\tkfree(rsrc_list_ptr);\n\trsrc_list_ptr = NULL;\n\tprint_ebda_pci_rsrc();\n\treturn 0;\n}\n\nu16 ibmphp_get_total_controllers(void)\n{\n\treturn hpc_list_ptr->num_ctlrs;\n}\n\nstruct slot *ibmphp_get_slot_from_physical_num(u8 physical_num)\n{\n\tstruct slot *slot;\n\n\tlist_for_each_entry(slot, &ibmphp_slot_head, ibm_slot_list) {\n\t\tif (slot->number == physical_num)\n\t\t\treturn slot;\n\t}\n\treturn NULL;\n}\n\n \nstruct bus_info *ibmphp_find_same_bus_num(u32 num)\n{\n\tstruct bus_info *ptr;\n\n\tlist_for_each_entry(ptr, &bus_info_head, bus_info_list) {\n\t\tif (ptr->busno == num)\n\t\t\t return ptr;\n\t}\n\treturn NULL;\n}\n\n \nint ibmphp_get_bus_index(u8 num)\n{\n\tstruct bus_info *ptr;\n\n\tlist_for_each_entry(ptr, &bus_info_head, bus_info_list) {\n\t\tif (ptr->busno == num)\n\t\t\treturn ptr->index;\n\t}\n\treturn -ENODEV;\n}\n\nvoid ibmphp_free_bus_info_queue(void)\n{\n\tstruct bus_info *bus_info, *next;\n\n\tlist_for_each_entry_safe(bus_info, next, &bus_info_head,\n\t\t\t\t bus_info_list) {\n\t\tkfree (bus_info);\n\t}\n}\n\nvoid ibmphp_free_ebda_hpc_queue(void)\n{\n\tstruct controller *controller = NULL, *next;\n\tint pci_flag = 0;\n\n\tlist_for_each_entry_safe(controller, next, &ebda_hpc_head,\n\t\t\t\t ebda_hpc_list) {\n\t\tif (controller->ctlr_type == 0)\n\t\t\trelease_region(controller->u.isa_ctlr.io_start, (controller->u.isa_ctlr.io_end - controller->u.isa_ctlr.io_start + 1));\n\t\telse if ((controller->ctlr_type == 1) && (!pci_flag)) {\n\t\t\t++pci_flag;\n\t\t\tpci_unregister_driver(&ibmphp_driver);\n\t\t}\n\t\tfree_ebda_hpc(controller);\n\t}\n}\n\nvoid ibmphp_free_ebda_pci_rsrc_queue(void)\n{\n\tstruct ebda_pci_rsrc *resource, *next;\n\n\tlist_for_each_entry_safe(resource, next, &ibmphp_ebda_pci_rsrc_head,\n\t\t\t\t ebda_pci_rsrc_list) {\n\t\tkfree (resource);\n\t\tresource = NULL;\n\t}\n}\n\nstatic const struct pci_device_id id_table[] = {\n\t{\n\t\t.vendor\t\t= PCI_VENDOR_ID_IBM,\n\t\t.device\t\t= HPC_DEVICE_ID,\n\t\t.subvendor\t= PCI_VENDOR_ID_IBM,\n\t\t.subdevice\t= HPC_SUBSYSTEM_ID,\n\t\t.class\t\t= ((PCI_CLASS_SYSTEM_PCI_HOTPLUG << 8) | 0x00),\n\t}, {}\n};\n\nMODULE_DEVICE_TABLE(pci, id_table);\n\nstatic int ibmphp_probe(struct pci_dev *, const struct pci_device_id *);\nstatic struct pci_driver ibmphp_driver = {\n\t.name\t\t= \"ibmphp\",\n\t.id_table\t= id_table,\n\t.probe\t\t= ibmphp_probe,\n};\n\nint ibmphp_register_pci(void)\n{\n\tstruct controller *ctrl;\n\tint rc = 0;\n\n\tlist_for_each_entry(ctrl, &ebda_hpc_head, ebda_hpc_list) {\n\t\tif (ctrl->ctlr_type == 1) {\n\t\t\trc = pci_register_driver(&ibmphp_driver);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn rc;\n}\nstatic int ibmphp_probe(struct pci_dev *dev, const struct pci_device_id *ids)\n{\n\tstruct controller *ctrl;\n\n\tdebug(\"inside ibmphp_probe\\n\");\n\n\tlist_for_each_entry(ctrl, &ebda_hpc_head, ebda_hpc_list) {\n\t\tif (ctrl->ctlr_type == 1) {\n\t\t\tif ((dev->devfn == ctrl->u.pci_ctlr.dev_fun) && (dev->bus->number == ctrl->u.pci_ctlr.bus)) {\n\t\t\t\tctrl->ctrl_dev = dev;\n\t\t\t\tdebug(\"found device!!!\\n\");\n\t\t\t\tdebug(\"dev->device = %x, dev->subsystem_device = %x\\n\", dev->device, dev->subsystem_device);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\treturn -ENODEV;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}