{
  "module_name": "cpcihp_zt5550.c",
  "hash_id": "eda7630fd689d30fd263deeba56ff2da29378ce0cd6544d0b82203d1d1394bc4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/hotplug/cpcihp_zt5550.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/init.h>\n#include <linux/errno.h>\n#include <linux/pci.h>\n#include <linux/interrupt.h>\n#include <linux/signal.h>\t \n#include \"cpci_hotplug.h\"\n#include \"cpcihp_zt5550.h\"\n\n#define DRIVER_VERSION\t\"0.2\"\n#define DRIVER_AUTHOR\t\"Scott Murray <scottm@somanetworks.com>\"\n#define DRIVER_DESC\t\"ZT5550 CompactPCI Hot Plug Driver\"\n\n#define MY_NAME\t\"cpcihp_zt5550\"\n\n#define dbg(format, arg...)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\\\n\t\tif (debug)\t\t\t\t\t\\\n\t\t\tprintk(KERN_DEBUG \"%s: \" format \"\\n\",\t\\\n\t\t\t\tMY_NAME, ## arg);\t\t\\\n\t} while (0)\n#define err(format, arg...) printk(KERN_ERR \"%s: \" format \"\\n\", MY_NAME, ## arg)\n#define info(format, arg...) printk(KERN_INFO \"%s: \" format \"\\n\", MY_NAME, ## arg)\n#define warn(format, arg...) printk(KERN_WARNING \"%s: \" format \"\\n\", MY_NAME, ## arg)\n\n \nstatic bool debug;\nstatic bool poll;\nstatic struct cpci_hp_controller_ops zt5550_hpc_ops;\nstatic struct cpci_hp_controller zt5550_hpc;\n\n \nstatic struct pci_dev *bus0_dev;\nstatic struct pci_bus *bus0;\n\n \nstatic struct pci_dev *hc_dev;\n\n \nstatic void __iomem *hc_registers;\nstatic void __iomem *csr_hc_index;\nstatic void __iomem *csr_hc_data;\nstatic void __iomem *csr_int_status;\nstatic void __iomem *csr_int_mask;\n\n\nstatic int zt5550_hc_config(struct pci_dev *pdev)\n{\n\tint ret;\n\n\t \n\tif (hc_dev) {\n\t\terr(\"too many host controller devices?\");\n\t\treturn -EBUSY;\n\t}\n\n\tret = pci_enable_device(pdev);\n\tif (ret) {\n\t\terr(\"cannot enable %s\\n\", pci_name(pdev));\n\t\treturn ret;\n\t}\n\n\thc_dev = pdev;\n\tdbg(\"hc_dev = %p\", hc_dev);\n\tdbg(\"pci resource start %llx\", (unsigned long long)pci_resource_start(hc_dev, 1));\n\tdbg(\"pci resource len %llx\", (unsigned long long)pci_resource_len(hc_dev, 1));\n\n\tif (!request_mem_region(pci_resource_start(hc_dev, 1),\n\t\t\t\tpci_resource_len(hc_dev, 1), MY_NAME)) {\n\t\terr(\"cannot reserve MMIO region\");\n\t\tret = -ENOMEM;\n\t\tgoto exit_disable_device;\n\t}\n\n\thc_registers =\n\t    ioremap(pci_resource_start(hc_dev, 1), pci_resource_len(hc_dev, 1));\n\tif (!hc_registers) {\n\t\terr(\"cannot remap MMIO region %llx @ %llx\",\n\t\t\t(unsigned long long)pci_resource_len(hc_dev, 1),\n\t\t\t(unsigned long long)pci_resource_start(hc_dev, 1));\n\t\tret = -ENODEV;\n\t\tgoto exit_release_region;\n\t}\n\n\tcsr_hc_index = hc_registers + CSR_HCINDEX;\n\tcsr_hc_data = hc_registers + CSR_HCDATA;\n\tcsr_int_status = hc_registers + CSR_INTSTAT;\n\tcsr_int_mask = hc_registers + CSR_INTMASK;\n\n\t \n\tdbg(\"disabling host control, fault and serial interrupts\");\n\twriteb((u8) HC_INT_MASK_REG, csr_hc_index);\n\twriteb((u8) ALL_INDEXED_INTS_MASK, csr_hc_data);\n\tdbg(\"disabled host control, fault and serial interrupts\");\n\n\t \n\tdbg(\"disabling timer0, timer1 and ENUM interrupts\");\n\twriteb((u8) ALL_DIRECT_INTS_MASK, csr_int_mask);\n\tdbg(\"disabled timer0, timer1 and ENUM interrupts\");\n\treturn 0;\n\nexit_release_region:\n\trelease_mem_region(pci_resource_start(hc_dev, 1),\n\t\t\t   pci_resource_len(hc_dev, 1));\nexit_disable_device:\n\tpci_disable_device(hc_dev);\n\treturn ret;\n}\n\nstatic int zt5550_hc_cleanup(void)\n{\n\tif (!hc_dev)\n\t\treturn -ENODEV;\n\n\tiounmap(hc_registers);\n\trelease_mem_region(pci_resource_start(hc_dev, 1),\n\t\t\t   pci_resource_len(hc_dev, 1));\n\tpci_disable_device(hc_dev);\n\treturn 0;\n}\n\nstatic int zt5550_hc_query_enum(void)\n{\n\tu8 value;\n\n\tvalue = inb_p(ENUM_PORT);\n\treturn ((value & ENUM_MASK) == ENUM_MASK);\n}\n\nstatic int zt5550_hc_check_irq(void *dev_id)\n{\n\tint ret;\n\tu8 reg;\n\n\tret = 0;\n\tif (dev_id == zt5550_hpc.dev_id) {\n\t\treg = readb(csr_int_status);\n\t\tif (reg)\n\t\t\tret = 1;\n\t}\n\treturn ret;\n}\n\nstatic int zt5550_hc_enable_irq(void)\n{\n\tu8 reg;\n\n\tif (hc_dev == NULL)\n\t\treturn -ENODEV;\n\n\treg = readb(csr_int_mask);\n\treg = reg & ~ENUM_INT_MASK;\n\twriteb(reg, csr_int_mask);\n\treturn 0;\n}\n\nstatic int zt5550_hc_disable_irq(void)\n{\n\tu8 reg;\n\n\tif (hc_dev == NULL)\n\t\treturn -ENODEV;\n\n\treg = readb(csr_int_mask);\n\treg = reg | ENUM_INT_MASK;\n\twriteb(reg, csr_int_mask);\n\treturn 0;\n}\n\nstatic int zt5550_hc_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tint status;\n\n\tstatus = zt5550_hc_config(pdev);\n\tif (status != 0)\n\t\treturn status;\n\n\tdbg(\"returned from zt5550_hc_config\");\n\n\tmemset(&zt5550_hpc, 0, sizeof(struct cpci_hp_controller));\n\tzt5550_hpc_ops.query_enum = zt5550_hc_query_enum;\n\tzt5550_hpc.ops = &zt5550_hpc_ops;\n\tif (!poll) {\n\t\tzt5550_hpc.irq = hc_dev->irq;\n\t\tzt5550_hpc.irq_flags = IRQF_SHARED;\n\t\tzt5550_hpc.dev_id = hc_dev;\n\n\t\tzt5550_hpc_ops.enable_irq = zt5550_hc_enable_irq;\n\t\tzt5550_hpc_ops.disable_irq = zt5550_hc_disable_irq;\n\t\tzt5550_hpc_ops.check_irq = zt5550_hc_check_irq;\n\t} else {\n\t\tinfo(\"using ENUM# polling mode\");\n\t}\n\n\tstatus = cpci_hp_register_controller(&zt5550_hpc);\n\tif (status != 0) {\n\t\terr(\"could not register cPCI hotplug controller\");\n\t\tgoto init_hc_error;\n\t}\n\tdbg(\"registered controller\");\n\n\t \n\tbus0_dev = pci_get_device(PCI_VENDOR_ID_DEC,\n\t\t\t\t  PCI_DEVICE_ID_DEC_21154, NULL);\n\tif (!bus0_dev) {\n\t\tstatus = -ENODEV;\n\t\tgoto init_register_error;\n\t}\n\tbus0 = bus0_dev->subordinate;\n\tpci_dev_put(bus0_dev);\n\n\tstatus = cpci_hp_register_bus(bus0, 0x0a, 0x0f);\n\tif (status != 0) {\n\t\terr(\"could not register cPCI hotplug bus\");\n\t\tgoto init_register_error;\n\t}\n\tdbg(\"registered bus\");\n\n\tstatus = cpci_hp_start();\n\tif (status != 0) {\n\t\terr(\"could not started cPCI hotplug system\");\n\t\tcpci_hp_unregister_bus(bus0);\n\t\tgoto init_register_error;\n\t}\n\tdbg(\"started cpci hp system\");\n\n\treturn 0;\ninit_register_error:\n\tcpci_hp_unregister_controller(&zt5550_hpc);\ninit_hc_error:\n\terr(\"status = %d\", status);\n\tzt5550_hc_cleanup();\n\treturn status;\n\n}\n\nstatic void zt5550_hc_remove_one(struct pci_dev *pdev)\n{\n\tcpci_hp_stop();\n\tcpci_hp_unregister_bus(bus0);\n\tcpci_hp_unregister_controller(&zt5550_hpc);\n\tzt5550_hc_cleanup();\n}\n\n\nstatic const struct pci_device_id zt5550_hc_pci_tbl[] = {\n\t{ PCI_VENDOR_ID_ZIATECH, PCI_DEVICE_ID_ZIATECH_5550_HC, PCI_ANY_ID, PCI_ANY_ID, },\n\t{ 0, }\n};\nMODULE_DEVICE_TABLE(pci, zt5550_hc_pci_tbl);\n\nstatic struct pci_driver zt5550_hc_driver = {\n\t.name\t\t= \"zt5550_hc\",\n\t.id_table\t= zt5550_hc_pci_tbl,\n\t.probe\t\t= zt5550_hc_init_one,\n\t.remove\t\t= zt5550_hc_remove_one,\n};\n\nstatic int __init zt5550_init(void)\n{\n\tstruct resource *r;\n\tint rc;\n\n\tinfo(DRIVER_DESC \" version: \" DRIVER_VERSION);\n\tr = request_region(ENUM_PORT, 1, \"#ENUM hotswap signal register\");\n\tif (!r)\n\t\treturn -EBUSY;\n\n\trc = pci_register_driver(&zt5550_hc_driver);\n\tif (rc < 0)\n\t\trelease_region(ENUM_PORT, 1);\n\treturn rc;\n}\n\nstatic void __exit\nzt5550_exit(void)\n{\n\tpci_unregister_driver(&zt5550_hc_driver);\n\trelease_region(ENUM_PORT, 1);\n}\n\nmodule_init(zt5550_init);\nmodule_exit(zt5550_exit);\n\nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\nmodule_param(debug, bool, 0644);\nMODULE_PARM_DESC(debug, \"Debugging mode enabled or not\");\nmodule_param(poll, bool, 0644);\nMODULE_PARM_DESC(poll, \"#ENUM polling mode enabled or not\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}