{
  "module_name": "rpadlpar_core.c",
  "hash_id": "6caea50970d0d174424db5d282b158d3b6a003586eff85a44dd1e3adf22eac8d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/hotplug/rpadlpar_core.c",
  "human_readable_source": "\n \n\n#undef DEBUG\n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/pci.h>\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n\n#include <asm/pci-bridge.h>\n#include <linux/mutex.h>\n#include <asm/rtas.h>\n#include <asm/vio.h>\n#include <linux/firmware.h>\n\n#include \"../pci.h\"\n#include \"rpaphp.h\"\n#include \"rpadlpar.h\"\n\nstatic DEFINE_MUTEX(rpadlpar_mutex);\n\n#define DLPAR_MODULE_NAME \"rpadlpar_io\"\n\n#define NODE_TYPE_VIO  1\n#define NODE_TYPE_SLOT 2\n#define NODE_TYPE_PHB  3\n\nstatic struct device_node *find_vio_slot_node(char *drc_name)\n{\n\tstruct device_node *parent = of_find_node_by_name(NULL, \"vdevice\");\n\tstruct device_node *dn;\n\tint rc;\n\n\tif (!parent)\n\t\treturn NULL;\n\n\tfor_each_child_of_node(parent, dn) {\n\t\trc = rpaphp_check_drc_props(dn, drc_name, NULL);\n\t\tif (rc == 0)\n\t\t\tbreak;\n\t}\n\tof_node_put(parent);\n\n\treturn dn;\n}\n\n \nstatic struct device_node *find_php_slot_pci_node(char *drc_name,\n\t\t\t\t\t\t  char *drc_type)\n{\n\tstruct device_node *np;\n\tint rc;\n\n\tfor_each_node_by_name(np, \"pci\") {\n\t\trc = rpaphp_check_drc_props(np, drc_name, drc_type);\n\t\tif (rc == 0)\n\t\t\tbreak;\n\t}\n\n\treturn np;\n}\n\n \nstatic struct device_node *find_dlpar_node(char *drc_name, int *node_type)\n{\n\tstruct device_node *dn;\n\n\tdn = find_php_slot_pci_node(drc_name, \"SLOT\");\n\tif (dn) {\n\t\t*node_type = NODE_TYPE_SLOT;\n\t\treturn dn;\n\t}\n\n\tdn = find_php_slot_pci_node(drc_name, \"PHB\");\n\tif (dn) {\n\t\t*node_type = NODE_TYPE_PHB;\n\t\treturn dn;\n\t}\n\n\tdn = find_vio_slot_node(drc_name);\n\tif (dn) {\n\t\t*node_type = NODE_TYPE_VIO;\n\t\treturn dn;\n\t}\n\n\treturn NULL;\n}\n\n \nstatic struct slot *find_php_slot(struct device_node *dn)\n{\n\tstruct slot *slot, *next;\n\n\tlist_for_each_entry_safe(slot, next, &rpaphp_slot_head,\n\t\t\t\t rpaphp_slot_list) {\n\t\tif (slot->dn == dn)\n\t\t\treturn slot;\n\t}\n\n\treturn NULL;\n}\n\nstatic struct pci_dev *dlpar_find_new_dev(struct pci_bus *parent,\n\t\t\t\t\tstruct device_node *dev_dn)\n{\n\tstruct pci_dev *tmp = NULL;\n\tstruct device_node *child_dn;\n\n\tlist_for_each_entry(tmp, &parent->devices, bus_list) {\n\t\tchild_dn = pci_device_to_OF_node(tmp);\n\t\tif (child_dn == dev_dn)\n\t\t\treturn tmp;\n\t}\n\treturn NULL;\n}\n\nstatic void dlpar_pci_add_bus(struct device_node *dn)\n{\n\tstruct pci_dn *pdn = PCI_DN(dn);\n\tstruct pci_controller *phb = pdn->phb;\n\tstruct pci_dev *dev = NULL;\n\n\tpseries_eeh_init_edev_recursive(pdn);\n\n\t \n\tdev = of_create_pci_dev(dn, phb->bus, pdn->devfn);\n\tif (!dev) {\n\t\tprintk(KERN_ERR \"%s: failed to create pci dev for %pOF\\n\",\n\t\t\t\t__func__, dn);\n\t\treturn;\n\t}\n\n\t \n\tif (pci_is_bridge(dev))\n\t\tof_scan_pci_bridge(dev);\n\n\t \n\tpcibios_map_io_space(dev->subordinate);\n\n\t \n\tpcibios_finish_adding_to_bus(phb->bus);\n}\n\nstatic int dlpar_add_pci_slot(char *drc_name, struct device_node *dn)\n{\n\tstruct pci_dev *dev;\n\tstruct pci_controller *phb;\n\n\tif (pci_find_bus_by_node(dn))\n\t\treturn -EINVAL;\n\n\t \n\tdlpar_pci_add_bus(dn);\n\n\t \n\tphb = PCI_DN(dn)->phb;\n\tdev = dlpar_find_new_dev(phb->bus, dn);\n\n\tif (!dev) {\n\t\tprintk(KERN_ERR \"%s: unable to add bus %s\\n\", __func__,\n\t\t\tdrc_name);\n\t\treturn -EIO;\n\t}\n\n\tif (dev->hdr_type != PCI_HEADER_TYPE_BRIDGE) {\n\t\tprintk(KERN_ERR \"%s: unexpected header type %d, unable to add bus %s\\n\",\n\t\t\t__func__, dev->hdr_type, drc_name);\n\t\treturn -EIO;\n\t}\n\n\t \n\tif (rpaphp_add_slot(dn)) {\n\t\tprintk(KERN_ERR \"%s: unable to add hotplug slot %s\\n\",\n\t\t\t__func__, drc_name);\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}\n\nstatic int dlpar_remove_phb(char *drc_name, struct device_node *dn)\n{\n\tstruct slot *slot;\n\tstruct pci_dn *pdn;\n\tint rc = 0;\n\n\tif (!pci_find_bus_by_node(dn))\n\t\treturn -EINVAL;\n\n\t \n\tslot = find_php_slot(dn);\n\tif (slot && rpaphp_deregister_slot(slot)) {\n\t\tprintk(KERN_ERR \"%s: unable to remove hotplug slot %s\\n\",\n\t\t       __func__, drc_name);\n\t\treturn -EIO;\n\t}\n\n\tpdn = dn->data;\n\tBUG_ON(!pdn || !pdn->phb);\n\trc = remove_phb_dynamic(pdn->phb);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tpdn->phb = NULL;\n\n\treturn 0;\n}\n\nstatic int dlpar_add_phb(char *drc_name, struct device_node *dn)\n{\n\tstruct pci_controller *phb;\n\n\tif (PCI_DN(dn) && PCI_DN(dn)->phb) {\n\t\t \n\t\treturn -EINVAL;\n\t}\n\n\tphb = init_phb_dynamic(dn);\n\tif (!phb)\n\t\treturn -EIO;\n\n\tif (rpaphp_add_slot(dn)) {\n\t\tprintk(KERN_ERR \"%s: unable to add hotplug slot %s\\n\",\n\t\t\t__func__, drc_name);\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}\n\nstatic int dlpar_add_vio_slot(char *drc_name, struct device_node *dn)\n{\n\tstruct vio_dev *vio_dev;\n\n\tvio_dev = vio_find_node(dn);\n\tif (vio_dev) {\n\t\tput_device(&vio_dev->dev);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!vio_register_device_node(dn)) {\n\t\tprintk(KERN_ERR\n\t\t\t\"%s: failed to register vio node %s\\n\",\n\t\t\t__func__, drc_name);\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}\n\n \nint dlpar_add_slot(char *drc_name)\n{\n\tstruct device_node *dn = NULL;\n\tint node_type;\n\tint rc = -EIO;\n\n\tif (mutex_lock_interruptible(&rpadlpar_mutex))\n\t\treturn -ERESTARTSYS;\n\n\t \n\tdn = find_dlpar_node(drc_name, &node_type);\n\tif (!dn) {\n\t\trc = -ENODEV;\n\t\tgoto exit;\n\t}\n\n\tswitch (node_type) {\n\t\tcase NODE_TYPE_VIO:\n\t\t\trc = dlpar_add_vio_slot(drc_name, dn);\n\t\t\tbreak;\n\t\tcase NODE_TYPE_SLOT:\n\t\t\trc = dlpar_add_pci_slot(drc_name, dn);\n\t\t\tbreak;\n\t\tcase NODE_TYPE_PHB:\n\t\t\trc = dlpar_add_phb(drc_name, dn);\n\t\t\tbreak;\n\t}\n\tof_node_put(dn);\n\n\tprintk(KERN_INFO \"%s: slot %s added\\n\", DLPAR_MODULE_NAME, drc_name);\nexit:\n\tmutex_unlock(&rpadlpar_mutex);\n\treturn rc;\n}\n\n \nstatic int dlpar_remove_vio_slot(char *drc_name, struct device_node *dn)\n{\n\tstruct vio_dev *vio_dev;\n\n\tvio_dev = vio_find_node(dn);\n\tif (!vio_dev)\n\t\treturn -EINVAL;\n\n\tvio_unregister_device(vio_dev);\n\n\tput_device(&vio_dev->dev);\n\n\treturn 0;\n}\n\n \nstatic int dlpar_remove_pci_slot(char *drc_name, struct device_node *dn)\n{\n\tstruct pci_bus *bus;\n\tstruct slot *slot;\n\tint ret = 0;\n\n\tpci_lock_rescan_remove();\n\n\tbus = pci_find_bus_by_node(dn);\n\tif (!bus) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tpr_debug(\"PCI: Removing PCI slot below EADS bridge %s\\n\",\n\t\t bus->self ? pci_name(bus->self) : \"<!PHB!>\");\n\n\tslot = find_php_slot(dn);\n\tif (slot) {\n\t\tpr_debug(\"PCI: Removing hotplug slot for %04x:%02x...\\n\",\n\t\t\t pci_domain_nr(bus), bus->number);\n\n\t\tif (rpaphp_deregister_slot(slot)) {\n\t\t\tprintk(KERN_ERR\n\t\t\t\t\"%s: unable to remove hotplug slot %s\\n\",\n\t\t\t\t__func__, drc_name);\n\t\t\tret = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tpci_hp_remove_devices(bus);\n\n\t \n\tif (pcibios_unmap_io_space(bus)) {\n\t\tprintk(KERN_ERR \"%s: failed to unmap bus range\\n\",\n\t\t\t__func__);\n\t\tret = -ERANGE;\n\t\tgoto out;\n\t}\n\n\t \n\tBUG_ON(!bus->self);\n\tpr_debug(\"PCI: Now removing bridge device %s\\n\", pci_name(bus->self));\n\tpci_stop_and_remove_bus_device(bus->self);\n\n out:\n\tpci_unlock_rescan_remove();\n\treturn ret;\n}\n\n \nint dlpar_remove_slot(char *drc_name)\n{\n\tstruct device_node *dn;\n\tint node_type;\n\tint rc = 0;\n\n\tif (mutex_lock_interruptible(&rpadlpar_mutex))\n\t\treturn -ERESTARTSYS;\n\n\tdn = find_dlpar_node(drc_name, &node_type);\n\tif (!dn) {\n\t\trc = -ENODEV;\n\t\tgoto exit;\n\t}\n\n\tswitch (node_type) {\n\t\tcase NODE_TYPE_VIO:\n\t\t\trc = dlpar_remove_vio_slot(drc_name, dn);\n\t\t\tbreak;\n\t\tcase NODE_TYPE_PHB:\n\t\t\trc = dlpar_remove_phb(drc_name, dn);\n\t\t\tbreak;\n\t\tcase NODE_TYPE_SLOT:\n\t\t\trc = dlpar_remove_pci_slot(drc_name, dn);\n\t\t\tbreak;\n\t}\n\tof_node_put(dn);\n\tvm_unmap_aliases();\n\n\tprintk(KERN_INFO \"%s: slot %s removed\\n\", DLPAR_MODULE_NAME, drc_name);\nexit:\n\tmutex_unlock(&rpadlpar_mutex);\n\treturn rc;\n}\n\nstatic inline int is_dlpar_capable(void)\n{\n\tint rc = rtas_token(\"ibm,configure-connector\");\n\n\treturn (int) (rc != RTAS_UNKNOWN_SERVICE);\n}\n\nstatic int __init rpadlpar_io_init(void)\n{\n\n\tif (!is_dlpar_capable()) {\n\t\tprintk(KERN_WARNING \"%s: partition not DLPAR capable\\n\",\n\t\t\t__func__);\n\t\treturn -EPERM;\n\t}\n\n\treturn dlpar_sysfs_init();\n}\n\nstatic void __exit rpadlpar_io_exit(void)\n{\n\tdlpar_sysfs_exit();\n}\n\nmodule_init(rpadlpar_io_init);\nmodule_exit(rpadlpar_io_exit);\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"RPA Dynamic Logical Partitioning driver for I/O slots\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}