{
  "module_name": "shpchp_ctrl.c",
  "hash_id": "e1cc483ea5cd1b8fdc2b5a3d5d12cc8e5aa05cd47129f6e592b0a43fa2ff08de",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/hotplug/shpchp_ctrl.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include \"../pci.h\"\n#include \"shpchp.h\"\n\nstatic void interrupt_event_handler(struct work_struct *work);\nstatic int shpchp_enable_slot(struct slot *p_slot);\nstatic int shpchp_disable_slot(struct slot *p_slot);\n\nstatic int queue_interrupt_event(struct slot *p_slot, u32 event_type)\n{\n\tstruct event_info *info;\n\n\tinfo = kmalloc(sizeof(*info), GFP_ATOMIC);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tinfo->event_type = event_type;\n\tinfo->p_slot = p_slot;\n\tINIT_WORK(&info->work, interrupt_event_handler);\n\n\tqueue_work(p_slot->wq, &info->work);\n\n\treturn 0;\n}\n\nu8 shpchp_handle_attention_button(u8 hp_slot, struct controller *ctrl)\n{\n\tstruct slot *p_slot;\n\tu32 event_type;\n\n\t \n\tctrl_dbg(ctrl, \"Attention button interrupt received\\n\");\n\n\tp_slot = shpchp_find_slot(ctrl, hp_slot + ctrl->slot_device_offset);\n\tp_slot->hpc_ops->get_adapter_status(p_slot, &(p_slot->presence_save));\n\n\t \n\tctrl_info(ctrl, \"Button pressed on Slot(%s)\\n\", slot_name(p_slot));\n\tevent_type = INT_BUTTON_PRESS;\n\n\tqueue_interrupt_event(p_slot, event_type);\n\n\treturn 0;\n\n}\n\nu8 shpchp_handle_switch_change(u8 hp_slot, struct controller *ctrl)\n{\n\tstruct slot *p_slot;\n\tu8 getstatus;\n\tu32 event_type;\n\n\t \n\tctrl_dbg(ctrl, \"Switch interrupt received\\n\");\n\n\tp_slot = shpchp_find_slot(ctrl, hp_slot + ctrl->slot_device_offset);\n\tp_slot->hpc_ops->get_adapter_status(p_slot, &(p_slot->presence_save));\n\tp_slot->hpc_ops->get_latch_status(p_slot, &getstatus);\n\tctrl_dbg(ctrl, \"Card present %x Power status %x\\n\",\n\t\t p_slot->presence_save, p_slot->pwr_save);\n\n\tif (getstatus) {\n\t\t \n\t\tctrl_info(ctrl, \"Latch open on Slot(%s)\\n\", slot_name(p_slot));\n\t\tevent_type = INT_SWITCH_OPEN;\n\t\tif (p_slot->pwr_save && p_slot->presence_save) {\n\t\t\tevent_type = INT_POWER_FAULT;\n\t\t\tctrl_err(ctrl, \"Surprise Removal of card\\n\");\n\t\t}\n\t} else {\n\t\t \n\t\tctrl_info(ctrl, \"Latch close on Slot(%s)\\n\", slot_name(p_slot));\n\t\tevent_type = INT_SWITCH_CLOSE;\n\t}\n\n\tqueue_interrupt_event(p_slot, event_type);\n\n\treturn 1;\n}\n\nu8 shpchp_handle_presence_change(u8 hp_slot, struct controller *ctrl)\n{\n\tstruct slot *p_slot;\n\tu32 event_type;\n\n\t \n\tctrl_dbg(ctrl, \"Presence/Notify input change\\n\");\n\n\tp_slot = shpchp_find_slot(ctrl, hp_slot + ctrl->slot_device_offset);\n\n\t \n\tp_slot->hpc_ops->get_adapter_status(p_slot, &(p_slot->presence_save));\n\tif (p_slot->presence_save) {\n\t\t \n\t\tctrl_info(ctrl, \"Card present on Slot(%s)\\n\",\n\t\t\t  slot_name(p_slot));\n\t\tevent_type = INT_PRESENCE_ON;\n\t} else {\n\t\t \n\t\tctrl_info(ctrl, \"Card not present on Slot(%s)\\n\",\n\t\t\t  slot_name(p_slot));\n\t\tevent_type = INT_PRESENCE_OFF;\n\t}\n\n\tqueue_interrupt_event(p_slot, event_type);\n\n\treturn 1;\n}\n\nu8 shpchp_handle_power_fault(u8 hp_slot, struct controller *ctrl)\n{\n\tstruct slot *p_slot;\n\tu32 event_type;\n\n\t \n\tctrl_dbg(ctrl, \"Power fault interrupt received\\n\");\n\n\tp_slot = shpchp_find_slot(ctrl, hp_slot + ctrl->slot_device_offset);\n\n\tif (!(p_slot->hpc_ops->query_power_fault(p_slot))) {\n\t\t \n\t\tctrl_info(ctrl, \"Power fault cleared on Slot(%s)\\n\",\n\t\t\t  slot_name(p_slot));\n\t\tp_slot->status = 0x00;\n\t\tevent_type = INT_POWER_FAULT_CLEAR;\n\t} else {\n\t\t \n\t\tctrl_info(ctrl, \"Power fault on Slot(%s)\\n\", slot_name(p_slot));\n\t\tevent_type = INT_POWER_FAULT;\n\t\t \n\t\tp_slot->status = 0xFF;\n\t\tctrl_info(ctrl, \"Power fault bit %x set\\n\", hp_slot);\n\t}\n\n\tqueue_interrupt_event(p_slot, event_type);\n\n\treturn 1;\n}\n\n \nstatic int change_bus_speed(struct controller *ctrl, struct slot *p_slot,\n\t\tenum pci_bus_speed speed)\n{\n\tint rc = 0;\n\n\tctrl_dbg(ctrl, \"Change speed to %d\\n\", speed);\n\trc = p_slot->hpc_ops->set_bus_speed_mode(p_slot, speed);\n\tif (rc) {\n\t\tctrl_err(ctrl, \"%s: Issue of set bus speed mode command failed\\n\",\n\t\t\t __func__);\n\t\treturn WRONG_BUS_FREQUENCY;\n\t}\n\treturn rc;\n}\n\nstatic int fix_bus_speed(struct controller *ctrl, struct slot *pslot,\n\t\tu8 flag, enum pci_bus_speed asp, enum pci_bus_speed bsp,\n\t\tenum pci_bus_speed msp)\n{\n\tint rc = 0;\n\n\t \n\tif (flag) {\n\t\tif (asp < bsp) {\n\t\t\tctrl_err(ctrl, \"Speed of bus %x and adapter %x mismatch\\n\",\n\t\t\t\t bsp, asp);\n\t\t\trc = WRONG_BUS_FREQUENCY;\n\t\t}\n\t\treturn rc;\n\t}\n\n\tif (asp < msp) {\n\t\tif (bsp != asp)\n\t\t\trc = change_bus_speed(ctrl, pslot, asp);\n\t} else {\n\t\tif (bsp != msp)\n\t\t\trc = change_bus_speed(ctrl, pslot, msp);\n\t}\n\treturn rc;\n}\n\n \nstatic int board_added(struct slot *p_slot)\n{\n\tu8 hp_slot;\n\tu8 slots_not_empty = 0;\n\tint rc = 0;\n\tenum pci_bus_speed asp, bsp, msp;\n\tstruct controller *ctrl = p_slot->ctrl;\n\tstruct pci_bus *parent = ctrl->pci_dev->subordinate;\n\n\thp_slot = p_slot->device - ctrl->slot_device_offset;\n\n\tctrl_dbg(ctrl, \"%s: p_slot->device, slot_offset, hp_slot = %d, %d ,%d\\n\",\n\t\t __func__, p_slot->device, ctrl->slot_device_offset, hp_slot);\n\n\t \n\trc = p_slot->hpc_ops->power_on_slot(p_slot);\n\tif (rc) {\n\t\tctrl_err(ctrl, \"Failed to power on slot\\n\");\n\t\treturn -1;\n\t}\n\n\tif ((ctrl->pci_dev->vendor == 0x8086) && (ctrl->pci_dev->device == 0x0332)) {\n\t\trc = p_slot->hpc_ops->set_bus_speed_mode(p_slot, PCI_SPEED_33MHz);\n\t\tif (rc) {\n\t\t\tctrl_err(ctrl, \"%s: Issue of set bus speed mode command failed\\n\",\n\t\t\t\t __func__);\n\t\t\treturn WRONG_BUS_FREQUENCY;\n\t\t}\n\n\t\t \n\t\trc = p_slot->hpc_ops->slot_enable(p_slot);\n\t\tif (rc) {\n\t\t\tctrl_err(ctrl, \"Issue of Slot Enable command failed\\n\");\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\trc = p_slot->hpc_ops->get_adapter_speed(p_slot, &asp);\n\tif (rc) {\n\t\tctrl_err(ctrl, \"Can't get adapter speed or bus mode mismatch\\n\");\n\t\treturn WRONG_BUS_FREQUENCY;\n\t}\n\n\tbsp = ctrl->pci_dev->subordinate->cur_bus_speed;\n\tmsp = ctrl->pci_dev->subordinate->max_bus_speed;\n\n\t \n\tif (!list_empty(&ctrl->pci_dev->subordinate->devices))\n\t\tslots_not_empty = 1;\n\n\tctrl_dbg(ctrl, \"%s: slots_not_empty %d, adapter_speed %d, bus_speed %d, max_bus_speed %d\\n\",\n\t\t __func__, slots_not_empty, asp,\n\t\t bsp, msp);\n\n\trc = fix_bus_speed(ctrl, p_slot, slots_not_empty, asp, bsp, msp);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\trc = p_slot->hpc_ops->slot_enable(p_slot);\n\tif (rc) {\n\t\tctrl_err(ctrl, \"Issue of Slot Enable command failed\\n\");\n\t\treturn rc;\n\t}\n\n\t \n\tmsleep(1000);\n\n\tctrl_dbg(ctrl, \"%s: slot status = %x\\n\", __func__, p_slot->status);\n\t \n\tif (p_slot->status == 0xFF) {\n\t\t \n\t\tctrl_dbg(ctrl, \"%s: Power fault\\n\", __func__);\n\t\tp_slot->status = 0;\n\t\tgoto err_exit;\n\t}\n\n\tif (shpchp_configure_device(p_slot)) {\n\t\tctrl_err(ctrl, \"Cannot add device at %04x:%02x:%02x\\n\",\n\t\t\t pci_domain_nr(parent), p_slot->bus, p_slot->device);\n\t\tgoto err_exit;\n\t}\n\n\tp_slot->status = 0;\n\tp_slot->is_a_board = 0x01;\n\tp_slot->pwr_save = 1;\n\n\tp_slot->hpc_ops->green_led_on(p_slot);\n\n\treturn 0;\n\nerr_exit:\n\t \n\trc = p_slot->hpc_ops->slot_disable(p_slot);\n\tif (rc) {\n\t\tctrl_err(ctrl, \"%s: Issue of Slot Disable command failed\\n\",\n\t\t\t __func__);\n\t\treturn rc;\n\t}\n\n\treturn(rc);\n}\n\n\n \nstatic int remove_board(struct slot *p_slot)\n{\n\tstruct controller *ctrl = p_slot->ctrl;\n\tu8 hp_slot;\n\tint rc;\n\n\tshpchp_unconfigure_device(p_slot);\n\n\thp_slot = p_slot->device - ctrl->slot_device_offset;\n\tp_slot = shpchp_find_slot(ctrl, hp_slot + ctrl->slot_device_offset);\n\n\tctrl_dbg(ctrl, \"%s: hp_slot = %d\\n\", __func__, hp_slot);\n\n\t \n\tif (p_slot->is_a_board)\n\t\tp_slot->status = 0x01;\n\n\t \n\trc = p_slot->hpc_ops->slot_disable(p_slot);\n\tif (rc) {\n\t\tctrl_err(ctrl, \"%s: Issue of Slot Disable command failed\\n\",\n\t\t\t __func__);\n\t\treturn rc;\n\t}\n\n\trc = p_slot->hpc_ops->set_attention_status(p_slot, 0);\n\tif (rc) {\n\t\tctrl_err(ctrl, \"Issue of Set Attention command failed\\n\");\n\t\treturn rc;\n\t}\n\n\tp_slot->pwr_save = 0;\n\tp_slot->is_a_board = 0;\n\n\treturn 0;\n}\n\n\nstruct pushbutton_work_info {\n\tstruct slot *p_slot;\n\tstruct work_struct work;\n};\n\n \nstatic void shpchp_pushbutton_thread(struct work_struct *work)\n{\n\tstruct pushbutton_work_info *info =\n\t\tcontainer_of(work, struct pushbutton_work_info, work);\n\tstruct slot *p_slot = info->p_slot;\n\n\tmutex_lock(&p_slot->lock);\n\tswitch (p_slot->state) {\n\tcase POWEROFF_STATE:\n\t\tmutex_unlock(&p_slot->lock);\n\t\tshpchp_disable_slot(p_slot);\n\t\tmutex_lock(&p_slot->lock);\n\t\tp_slot->state = STATIC_STATE;\n\t\tbreak;\n\tcase POWERON_STATE:\n\t\tmutex_unlock(&p_slot->lock);\n\t\tif (shpchp_enable_slot(p_slot))\n\t\t\tp_slot->hpc_ops->green_led_off(p_slot);\n\t\tmutex_lock(&p_slot->lock);\n\t\tp_slot->state = STATIC_STATE;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tmutex_unlock(&p_slot->lock);\n\n\tkfree(info);\n}\n\nvoid shpchp_queue_pushbutton_work(struct work_struct *work)\n{\n\tstruct slot *p_slot = container_of(work, struct slot, work.work);\n\tstruct pushbutton_work_info *info;\n\n\tinfo = kmalloc(sizeof(*info), GFP_KERNEL);\n\tif (!info) {\n\t\tctrl_err(p_slot->ctrl, \"%s: Cannot allocate memory\\n\",\n\t\t\t __func__);\n\t\treturn;\n\t}\n\tinfo->p_slot = p_slot;\n\tINIT_WORK(&info->work, shpchp_pushbutton_thread);\n\n\tmutex_lock(&p_slot->lock);\n\tswitch (p_slot->state) {\n\tcase BLINKINGOFF_STATE:\n\t\tp_slot->state = POWEROFF_STATE;\n\t\tbreak;\n\tcase BLINKINGON_STATE:\n\t\tp_slot->state = POWERON_STATE;\n\t\tbreak;\n\tdefault:\n\t\tkfree(info);\n\t\tgoto out;\n\t}\n\tqueue_work(p_slot->wq, &info->work);\n out:\n\tmutex_unlock(&p_slot->lock);\n}\n\nstatic void update_slot_info(struct slot *slot)\n{\n\tslot->hpc_ops->get_power_status(slot, &slot->pwr_save);\n\tslot->hpc_ops->get_attention_status(slot, &slot->attention_save);\n\tslot->hpc_ops->get_latch_status(slot, &slot->latch_save);\n\tslot->hpc_ops->get_adapter_status(slot, &slot->presence_save);\n}\n\n \nstatic void handle_button_press_event(struct slot *p_slot)\n{\n\tu8 getstatus;\n\tstruct controller *ctrl = p_slot->ctrl;\n\n\tswitch (p_slot->state) {\n\tcase STATIC_STATE:\n\t\tp_slot->hpc_ops->get_power_status(p_slot, &getstatus);\n\t\tif (getstatus) {\n\t\t\tp_slot->state = BLINKINGOFF_STATE;\n\t\t\tctrl_info(ctrl, \"PCI slot #%s - powering off due to button press\\n\",\n\t\t\t\t  slot_name(p_slot));\n\t\t} else {\n\t\t\tp_slot->state = BLINKINGON_STATE;\n\t\t\tctrl_info(ctrl, \"PCI slot #%s - powering on due to button press\\n\",\n\t\t\t\t  slot_name(p_slot));\n\t\t}\n\t\t \n\t\tp_slot->hpc_ops->green_led_blink(p_slot);\n\t\tp_slot->hpc_ops->set_attention_status(p_slot, 0);\n\n\t\tqueue_delayed_work(p_slot->wq, &p_slot->work, 5*HZ);\n\t\tbreak;\n\tcase BLINKINGOFF_STATE:\n\tcase BLINKINGON_STATE:\n\t\t \n\t\tctrl_info(ctrl, \"Button cancel on Slot(%s)\\n\",\n\t\t\t  slot_name(p_slot));\n\t\tcancel_delayed_work(&p_slot->work);\n\t\tif (p_slot->state == BLINKINGOFF_STATE)\n\t\t\tp_slot->hpc_ops->green_led_on(p_slot);\n\t\telse\n\t\t\tp_slot->hpc_ops->green_led_off(p_slot);\n\t\tp_slot->hpc_ops->set_attention_status(p_slot, 0);\n\t\tctrl_info(ctrl, \"PCI slot #%s - action canceled due to button press\\n\",\n\t\t\t  slot_name(p_slot));\n\t\tp_slot->state = STATIC_STATE;\n\t\tbreak;\n\tcase POWEROFF_STATE:\n\tcase POWERON_STATE:\n\t\t \n\t\tctrl_info(ctrl, \"Button ignore on Slot(%s)\\n\",\n\t\t\t  slot_name(p_slot));\n\t\tupdate_slot_info(p_slot);\n\t\tbreak;\n\tdefault:\n\t\tctrl_warn(ctrl, \"Not a valid state\\n\");\n\t\tbreak;\n\t}\n}\n\nstatic void interrupt_event_handler(struct work_struct *work)\n{\n\tstruct event_info *info = container_of(work, struct event_info, work);\n\tstruct slot *p_slot = info->p_slot;\n\n\tmutex_lock(&p_slot->lock);\n\tswitch (info->event_type) {\n\tcase INT_BUTTON_PRESS:\n\t\thandle_button_press_event(p_slot);\n\t\tbreak;\n\tcase INT_POWER_FAULT:\n\t\tctrl_dbg(p_slot->ctrl, \"%s: Power fault\\n\", __func__);\n\t\tp_slot->hpc_ops->set_attention_status(p_slot, 1);\n\t\tp_slot->hpc_ops->green_led_off(p_slot);\n\t\tbreak;\n\tdefault:\n\t\tupdate_slot_info(p_slot);\n\t\tbreak;\n\t}\n\tmutex_unlock(&p_slot->lock);\n\n\tkfree(info);\n}\n\n\nstatic int shpchp_enable_slot (struct slot *p_slot)\n{\n\tu8 getstatus = 0;\n\tint rc, retval = -ENODEV;\n\tstruct controller *ctrl = p_slot->ctrl;\n\n\t \n\tmutex_lock(&p_slot->ctrl->crit_sect);\n\trc = p_slot->hpc_ops->get_adapter_status(p_slot, &getstatus);\n\tif (rc || !getstatus) {\n\t\tctrl_info(ctrl, \"No adapter on slot(%s)\\n\", slot_name(p_slot));\n\t\tgoto out;\n\t}\n\trc = p_slot->hpc_ops->get_latch_status(p_slot, &getstatus);\n\tif (rc || getstatus) {\n\t\tctrl_info(ctrl, \"Latch open on slot(%s)\\n\", slot_name(p_slot));\n\t\tgoto out;\n\t}\n\trc = p_slot->hpc_ops->get_power_status(p_slot, &getstatus);\n\tif (rc || getstatus) {\n\t\tctrl_info(ctrl, \"Already enabled on slot(%s)\\n\",\n\t\t\t  slot_name(p_slot));\n\t\tgoto out;\n\t}\n\n\tp_slot->is_a_board = 1;\n\n\t \n\tp_slot->hpc_ops->get_adapter_status(p_slot, &(p_slot->presence_save));\n\tp_slot->hpc_ops->get_power_status(p_slot, &(p_slot->pwr_save));\n\tctrl_dbg(ctrl, \"%s: p_slot->pwr_save %x\\n\", __func__, p_slot->pwr_save);\n\tp_slot->hpc_ops->get_latch_status(p_slot, &getstatus);\n\n\tif ((p_slot->ctrl->pci_dev->vendor == PCI_VENDOR_ID_AMD &&\n\t     p_slot->ctrl->pci_dev->device == PCI_DEVICE_ID_AMD_POGO_7458)\n\t     && p_slot->ctrl->num_slots == 1) {\n\t\t \n\t\tamd_pogo_errata_save_misc_reg(p_slot);\n\t\tretval = board_added(p_slot);\n\t\t \n\t\tamd_pogo_errata_restore_misc_reg(p_slot);\n\t} else\n\t\tretval = board_added(p_slot);\n\n\tif (retval) {\n\t\tp_slot->hpc_ops->get_adapter_status(p_slot,\n\t\t\t\t&(p_slot->presence_save));\n\t\tp_slot->hpc_ops->get_latch_status(p_slot, &getstatus);\n\t}\n\n\tupdate_slot_info(p_slot);\n out:\n\tmutex_unlock(&p_slot->ctrl->crit_sect);\n\treturn retval;\n}\n\n\nstatic int shpchp_disable_slot (struct slot *p_slot)\n{\n\tu8 getstatus = 0;\n\tint rc, retval = -ENODEV;\n\tstruct controller *ctrl = p_slot->ctrl;\n\n\tif (!p_slot->ctrl)\n\t\treturn -ENODEV;\n\n\t \n\tmutex_lock(&p_slot->ctrl->crit_sect);\n\n\trc = p_slot->hpc_ops->get_adapter_status(p_slot, &getstatus);\n\tif (rc || !getstatus) {\n\t\tctrl_info(ctrl, \"No adapter on slot(%s)\\n\", slot_name(p_slot));\n\t\tgoto out;\n\t}\n\trc = p_slot->hpc_ops->get_latch_status(p_slot, &getstatus);\n\tif (rc || getstatus) {\n\t\tctrl_info(ctrl, \"Latch open on slot(%s)\\n\", slot_name(p_slot));\n\t\tgoto out;\n\t}\n\trc = p_slot->hpc_ops->get_power_status(p_slot, &getstatus);\n\tif (rc || !getstatus) {\n\t\tctrl_info(ctrl, \"Already disabled on slot(%s)\\n\",\n\t\t\t  slot_name(p_slot));\n\t\tgoto out;\n\t}\n\n\tretval = remove_board(p_slot);\n\tupdate_slot_info(p_slot);\n out:\n\tmutex_unlock(&p_slot->ctrl->crit_sect);\n\treturn retval;\n}\n\nint shpchp_sysfs_enable_slot(struct slot *p_slot)\n{\n\tint retval = -ENODEV;\n\tstruct controller *ctrl = p_slot->ctrl;\n\n\tmutex_lock(&p_slot->lock);\n\tswitch (p_slot->state) {\n\tcase BLINKINGON_STATE:\n\t\tcancel_delayed_work(&p_slot->work);\n\t\tfallthrough;\n\tcase STATIC_STATE:\n\t\tp_slot->state = POWERON_STATE;\n\t\tmutex_unlock(&p_slot->lock);\n\t\tretval = shpchp_enable_slot(p_slot);\n\t\tmutex_lock(&p_slot->lock);\n\t\tp_slot->state = STATIC_STATE;\n\t\tbreak;\n\tcase POWERON_STATE:\n\t\tctrl_info(ctrl, \"Slot %s is already in powering on state\\n\",\n\t\t\t  slot_name(p_slot));\n\t\tbreak;\n\tcase BLINKINGOFF_STATE:\n\tcase POWEROFF_STATE:\n\t\tctrl_info(ctrl, \"Already enabled on slot %s\\n\",\n\t\t\t  slot_name(p_slot));\n\t\tbreak;\n\tdefault:\n\t\tctrl_err(ctrl, \"Not a valid state on slot %s\\n\",\n\t\t\t slot_name(p_slot));\n\t\tbreak;\n\t}\n\tmutex_unlock(&p_slot->lock);\n\n\treturn retval;\n}\n\nint shpchp_sysfs_disable_slot(struct slot *p_slot)\n{\n\tint retval = -ENODEV;\n\tstruct controller *ctrl = p_slot->ctrl;\n\n\tmutex_lock(&p_slot->lock);\n\tswitch (p_slot->state) {\n\tcase BLINKINGOFF_STATE:\n\t\tcancel_delayed_work(&p_slot->work);\n\t\tfallthrough;\n\tcase STATIC_STATE:\n\t\tp_slot->state = POWEROFF_STATE;\n\t\tmutex_unlock(&p_slot->lock);\n\t\tretval = shpchp_disable_slot(p_slot);\n\t\tmutex_lock(&p_slot->lock);\n\t\tp_slot->state = STATIC_STATE;\n\t\tbreak;\n\tcase POWEROFF_STATE:\n\t\tctrl_info(ctrl, \"Slot %s is already in powering off state\\n\",\n\t\t\t  slot_name(p_slot));\n\t\tbreak;\n\tcase BLINKINGON_STATE:\n\tcase POWERON_STATE:\n\t\tctrl_info(ctrl, \"Already disabled on slot %s\\n\",\n\t\t\t  slot_name(p_slot));\n\t\tbreak;\n\tdefault:\n\t\tctrl_err(ctrl, \"Not a valid state on slot %s\\n\",\n\t\t\t slot_name(p_slot));\n\t\tbreak;\n\t}\n\tmutex_unlock(&p_slot->lock);\n\n\treturn retval;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}