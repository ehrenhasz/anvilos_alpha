{
  "module_name": "cpcihp_generic.c",
  "hash_id": "36341450a51e3522321d7352431dcc8fc455edeee5fb7413cc0ec986e3105f73",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/hotplug/cpcihp_generic.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/errno.h>\n#include <linux/pci.h>\n#include <linux/string.h>\n#include \"cpci_hotplug.h\"\n\n#define DRIVER_VERSION\t\"0.1\"\n#define DRIVER_AUTHOR\t\"Scott Murray <scottm@somanetworks.com>\"\n#define DRIVER_DESC\t\"Generic port I/O CompactPCI Hot Plug Driver\"\n\n#if !defined(MODULE)\n#define MY_NAME\t\"cpcihp_generic\"\n#else\n#define MY_NAME\tTHIS_MODULE->name\n#endif\n\n#define dbg(format, arg...)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\\\n\t\tif (debug)\t\t\t\t\t\\\n\t\t\tprintk(KERN_DEBUG \"%s: \" format \"\\n\",\t\\\n\t\t\t\tMY_NAME, ## arg);\t\t\\\n\t} while (0)\n#define err(format, arg...) printk(KERN_ERR \"%s: \" format \"\\n\", MY_NAME, ## arg)\n#define info(format, arg...) printk(KERN_INFO \"%s: \" format \"\\n\", MY_NAME, ## arg)\n#define warn(format, arg...) printk(KERN_WARNING \"%s: \" format \"\\n\", MY_NAME, ## arg)\n\n \nstatic bool debug;\nstatic char *bridge;\nstatic u8 bridge_busnr;\nstatic u8 bridge_slot;\nstatic struct pci_bus *bus;\nstatic u8 first_slot;\nstatic u8 last_slot;\nstatic u16 port;\nstatic unsigned int enum_bit;\nstatic u8 enum_mask;\n\nstatic struct cpci_hp_controller_ops generic_hpc_ops;\nstatic struct cpci_hp_controller generic_hpc;\n\nstatic int __init validate_parameters(void)\n{\n\tchar *str;\n\tchar *p;\n\tunsigned long tmp;\n\n\tif (!bridge) {\n\t\tinfo(\"not configured, disabling.\");\n\t\treturn -EINVAL;\n\t}\n\tstr = bridge;\n\tif (!*str)\n\t\treturn -EINVAL;\n\n\ttmp = simple_strtoul(str, &p, 16);\n\tif (p == str || tmp > 0xff) {\n\t\terr(\"Invalid hotplug bus bridge device bus number\");\n\t\treturn -EINVAL;\n\t}\n\tbridge_busnr = (u8) tmp;\n\tdbg(\"bridge_busnr = 0x%02x\", bridge_busnr);\n\tif (*p != ':') {\n\t\terr(\"Invalid hotplug bus bridge device\");\n\t\treturn -EINVAL;\n\t}\n\tstr = p + 1;\n\ttmp = simple_strtoul(str, &p, 16);\n\tif (p == str || tmp > 0x1f) {\n\t\terr(\"Invalid hotplug bus bridge device slot number\");\n\t\treturn -EINVAL;\n\t}\n\tbridge_slot = (u8) tmp;\n\tdbg(\"bridge_slot = 0x%02x\", bridge_slot);\n\n\tdbg(\"first_slot = 0x%02x\", first_slot);\n\tdbg(\"last_slot = 0x%02x\", last_slot);\n\tif (!(first_slot && last_slot)) {\n\t\terr(\"Need to specify first_slot and last_slot\");\n\t\treturn -EINVAL;\n\t}\n\tif (last_slot < first_slot) {\n\t\terr(\"first_slot must be less than last_slot\");\n\t\treturn -EINVAL;\n\t}\n\n\tdbg(\"port = 0x%04x\", port);\n\tdbg(\"enum_bit = 0x%02x\", enum_bit);\n\tif (enum_bit > 7) {\n\t\terr(\"Invalid #ENUM bit\");\n\t\treturn -EINVAL;\n\t}\n\tenum_mask = 1 << enum_bit;\n\treturn 0;\n}\n\nstatic int query_enum(void)\n{\n\tu8 value;\n\n\tvalue = inb_p(port);\n\treturn ((value & enum_mask) == enum_mask);\n}\n\nstatic int __init cpcihp_generic_init(void)\n{\n\tint status;\n\tstruct resource *r;\n\tstruct pci_dev *dev;\n\n\tinfo(DRIVER_DESC \" version: \" DRIVER_VERSION);\n\tstatus = validate_parameters();\n\tif (status)\n\t\treturn status;\n\n\tr = request_region(port, 1, \"#ENUM hotswap signal register\");\n\tif (!r)\n\t\treturn -EBUSY;\n\n\tdev = pci_get_domain_bus_and_slot(0, bridge_busnr,\n\t\t\t\t\t  PCI_DEVFN(bridge_slot, 0));\n\tif (!dev || dev->hdr_type != PCI_HEADER_TYPE_BRIDGE) {\n\t\terr(\"Invalid bridge device %s\", bridge);\n\t\tpci_dev_put(dev);\n\t\treturn -EINVAL;\n\t}\n\tbus = dev->subordinate;\n\tpci_dev_put(dev);\n\n\tmemset(&generic_hpc, 0, sizeof(struct cpci_hp_controller));\n\tgeneric_hpc_ops.query_enum = query_enum;\n\tgeneric_hpc.ops = &generic_hpc_ops;\n\n\tstatus = cpci_hp_register_controller(&generic_hpc);\n\tif (status != 0) {\n\t\terr(\"Could not register cPCI hotplug controller\");\n\t\treturn -ENODEV;\n\t}\n\tdbg(\"registered controller\");\n\n\tstatus = cpci_hp_register_bus(bus, first_slot, last_slot);\n\tif (status != 0) {\n\t\terr(\"Could not register cPCI hotplug bus\");\n\t\tgoto init_bus_register_error;\n\t}\n\tdbg(\"registered bus\");\n\n\tstatus = cpci_hp_start();\n\tif (status != 0) {\n\t\terr(\"Could not started cPCI hotplug system\");\n\t\tgoto init_start_error;\n\t}\n\tdbg(\"started cpci hp system\");\n\treturn 0;\ninit_start_error:\n\tcpci_hp_unregister_bus(bus);\ninit_bus_register_error:\n\tcpci_hp_unregister_controller(&generic_hpc);\n\terr(\"status = %d\", status);\n\treturn status;\n\n}\n\nstatic void __exit cpcihp_generic_exit(void)\n{\n\tcpci_hp_stop();\n\tcpci_hp_unregister_bus(bus);\n\tcpci_hp_unregister_controller(&generic_hpc);\n\trelease_region(port, 1);\n}\n\nmodule_init(cpcihp_generic_init);\nmodule_exit(cpcihp_generic_exit);\n\nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\nmodule_param(debug, bool, S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(debug, \"Debugging mode enabled or not\");\nmodule_param(bridge, charp, 0);\nMODULE_PARM_DESC(bridge, \"Hotswap bus bridge device, <bus>:<slot> (bus and slot are in hexadecimal)\");\nmodule_param(first_slot, byte, 0);\nMODULE_PARM_DESC(first_slot, \"Hotswap bus first slot number\");\nmodule_param(last_slot, byte, 0);\nMODULE_PARM_DESC(last_slot, \"Hotswap bus last slot number\");\nmodule_param_hw(port, ushort, ioport, 0);\nMODULE_PARM_DESC(port, \"#ENUM signal I/O port\");\nmodule_param(enum_bit, uint, 0);\nMODULE_PARM_DESC(enum_bit, \"#ENUM signal bit (0-7)\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}