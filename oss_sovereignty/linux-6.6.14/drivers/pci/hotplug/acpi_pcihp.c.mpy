{
  "module_name": "acpi_pcihp.c",
  "hash_id": "3ecd3efd584d0c44de631454c0cf48b1dcdc27f8a9b0b62d18d6bbf24618c5bc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/hotplug/acpi_pcihp.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/pci.h>\n#include <linux/pci_hotplug.h>\n#include <linux/acpi.h>\n#include <linux/pci-acpi.h>\n#include <linux/slab.h>\n\n#define MY_NAME\t\"acpi_pcihp\"\n\n#define dbg(fmt, arg...) do { if (debug_acpi) printk(KERN_DEBUG \"%s: %s: \" fmt, MY_NAME, __func__, ## arg); } while (0)\n#define err(format, arg...) printk(KERN_ERR \"%s: \" format, MY_NAME, ## arg)\n#define info(format, arg...) printk(KERN_INFO \"%s: \" format, MY_NAME, ## arg)\n#define warn(format, arg...) printk(KERN_WARNING \"%s: \" format, MY_NAME, ## arg)\n\n#define\tMETHOD_NAME__SUN\t\"_SUN\"\n#define\tMETHOD_NAME_OSHP\t\"OSHP\"\n\nstatic bool debug_acpi;\n\n \nstatic acpi_status acpi_run_oshp(acpi_handle handle)\n{\n\tacpi_status\t\tstatus;\n\tstruct acpi_buffer\tstring = { ACPI_ALLOCATE_BUFFER, NULL };\n\n\tacpi_get_name(handle, ACPI_FULL_PATHNAME, &string);\n\n\t \n\tstatus = acpi_evaluate_object(handle, METHOD_NAME_OSHP, NULL, NULL);\n\tif (ACPI_FAILURE(status))\n\t\tif (status != AE_NOT_FOUND)\n\t\t\tprintk(KERN_ERR \"%s:%s OSHP fails=0x%x\\n\",\n\t\t\t       __func__, (char *)string.pointer, status);\n\t\telse\n\t\t\tdbg(\"%s:%s OSHP not found\\n\",\n\t\t\t    __func__, (char *)string.pointer);\n\telse\n\t\tpr_debug(\"%s:%s OSHP passes\\n\", __func__,\n\t\t\t(char *)string.pointer);\n\n\tkfree(string.pointer);\n\treturn status;\n}\n\n \nint acpi_get_hp_hw_control_from_firmware(struct pci_dev *pdev)\n{\n\tconst struct pci_host_bridge *host;\n\tconst struct acpi_pci_root *root;\n\tacpi_status status;\n\tacpi_handle chandle, handle;\n\tstruct acpi_buffer string = { ACPI_ALLOCATE_BUFFER, NULL };\n\n\t \n\thost = pci_find_host_bridge(pdev->bus);\n\troot = acpi_pci_find_root(ACPI_HANDLE(&host->dev));\n\tif (!root)\n\t\treturn 0;\n\n\t \n\tif (root->osc_support_set) {\n\t\tif (host->native_shpc_hotplug)\n\t\t\treturn 0;\n\t\treturn -ENODEV;\n\t}\n\n\t \n\thandle = ACPI_HANDLE(&pdev->dev);\n\tif (!handle) {\n\t\t \n\t\tstruct pci_bus *pbus;\n\t\tfor (pbus = pdev->bus; pbus; pbus = pbus->parent) {\n\t\t\thandle = acpi_pci_get_bridge_handle(pbus);\n\t\t\tif (handle)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\twhile (handle) {\n\t\tacpi_get_name(handle, ACPI_FULL_PATHNAME, &string);\n\t\tpci_info(pdev, \"Requesting control of SHPC hotplug via OSHP (%s)\\n\",\n\t\t\t (char *)string.pointer);\n\t\tstatus = acpi_run_oshp(handle);\n\t\tif (ACPI_SUCCESS(status))\n\t\t\tgoto got_one;\n\t\tif (acpi_is_root_bridge(handle))\n\t\t\tbreak;\n\t\tchandle = handle;\n\t\tstatus = acpi_get_parent(chandle, &handle);\n\t\tif (ACPI_FAILURE(status))\n\t\t\tbreak;\n\t}\n\n\tpci_info(pdev, \"Cannot get control of SHPC hotplug\\n\");\n\tkfree(string.pointer);\n\treturn -ENODEV;\ngot_one:\n\tpci_info(pdev, \"Gained control of SHPC hotplug (%s)\\n\",\n\t\t (char *)string.pointer);\n\tkfree(string.pointer);\n\treturn 0;\n}\nEXPORT_SYMBOL(acpi_get_hp_hw_control_from_firmware);\n\nstatic int pcihp_is_ejectable(acpi_handle handle)\n{\n\tacpi_status status;\n\tunsigned long long removable;\n\tif (!acpi_has_method(handle, \"_ADR\"))\n\t\treturn 0;\n\tif (acpi_has_method(handle, \"_EJ0\"))\n\t\treturn 1;\n\tstatus = acpi_evaluate_integer(handle, \"_RMV\", NULL, &removable);\n\tif (ACPI_SUCCESS(status) && removable)\n\t\treturn 1;\n\treturn 0;\n}\n\n \nint acpi_pci_check_ejectable(struct pci_bus *pbus, acpi_handle handle)\n{\n\tacpi_handle bridge_handle, parent_handle;\n\n\tbridge_handle = acpi_pci_get_bridge_handle(pbus);\n\tif (!bridge_handle)\n\t\treturn 0;\n\tif ((ACPI_FAILURE(acpi_get_parent(handle, &parent_handle))))\n\t\treturn 0;\n\tif (bridge_handle != parent_handle)\n\t\treturn 0;\n\treturn pcihp_is_ejectable(handle);\n}\nEXPORT_SYMBOL_GPL(acpi_pci_check_ejectable);\n\nstatic acpi_status\ncheck_hotplug(acpi_handle handle, u32 lvl, void *context, void **rv)\n{\n\tint *found = (int *)context;\n\tif (pcihp_is_ejectable(handle)) {\n\t\t*found = 1;\n\t\treturn AE_CTRL_TERMINATE;\n\t}\n\treturn AE_OK;\n}\n\n \nint acpi_pci_detect_ejectable(acpi_handle handle)\n{\n\tint found = 0;\n\n\tif (!handle)\n\t\treturn found;\n\n\tacpi_walk_namespace(ACPI_TYPE_DEVICE, handle, 1,\n\t\t\t    check_hotplug, NULL, (void *)&found, NULL);\n\treturn found;\n}\nEXPORT_SYMBOL_GPL(acpi_pci_detect_ejectable);\n\nmodule_param(debug_acpi, bool, 0644);\nMODULE_PARM_DESC(debug_acpi, \"Debugging mode for ACPI enabled or not\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}