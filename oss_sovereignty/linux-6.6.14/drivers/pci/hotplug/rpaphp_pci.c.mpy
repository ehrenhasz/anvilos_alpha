{
  "module_name": "rpaphp_pci.c",
  "hash_id": "14b341d844227f2dc98e22e1fca73a914eb9f8072d8f664cd484da583647fbe2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/hotplug/rpaphp_pci.c",
  "human_readable_source": "\n \n#include <linux/of.h>\n#include <linux/pci.h>\n#include <linux/string.h>\n\n#include <asm/pci-bridge.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n\n#include \"../pci.h\"\t\t \n#include \"rpaphp.h\"\n\n \n#define RTAS_SLOT_UNISOLATED\t\t-9000\n#define RTAS_SLOT_NOT_UNISOLATED\t-9001\n#define RTAS_SLOT_NOT_USABLE\t\t-9002\n\nstatic int rtas_get_sensor_errno(int rtas_rc)\n{\n\tswitch (rtas_rc) {\n\tcase 0:\n\t\t \n\t\treturn 0;\n\tcase RTAS_SLOT_UNISOLATED:\n\tcase RTAS_SLOT_NOT_UNISOLATED:\n\t\treturn -EFAULT;\n\tcase RTAS_SLOT_NOT_USABLE:\n\t\treturn -ENODEV;\n\tcase RTAS_BUSY:\n\tcase RTAS_EXTENDED_DELAY_MIN...RTAS_EXTENDED_DELAY_MAX:\n\t\treturn -EBUSY;\n\tdefault:\n\t\treturn rtas_error_rc(rtas_rc);\n\t}\n}\n\n \n\nstatic int __rpaphp_get_sensor_state(struct slot *slot, int *state)\n{\n\tint rc;\n\tint token = rtas_token(\"get-sensor-state\");\n\tstruct pci_dn *pdn;\n\tstruct eeh_pe *pe;\n\tstruct pci_controller *phb = PCI_DN(slot->dn)->phb;\n\n\tif (token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -ENOENT;\n\n\t \n\tpdn = list_first_entry_or_null(&PCI_DN(phb->dn)->child_list,\n\t\t\t\t\tstruct pci_dn, list);\n\tif (!pdn)\n\t\tgoto fallback;\n\n\tpe = eeh_dev_to_pe(pdn->edev);\n\tif (pe && (pe->state & EEH_PE_RECOVERING)) {\n\t\trc = rtas_call(token, 2, 2, state, DR_ENTITY_SENSE,\n\t\t\t       slot->index);\n\t\treturn rtas_get_sensor_errno(rc);\n\t}\nfallback:\n\treturn rtas_get_sensor(DR_ENTITY_SENSE, slot->index, state);\n}\n\nint rpaphp_get_sensor_state(struct slot *slot, int *state)\n{\n\tint rc;\n\tint setlevel;\n\n\trc = __rpaphp_get_sensor_state(slot, state);\n\n\tif (rc < 0) {\n\t\tif (rc == -EFAULT || rc == -EEXIST) {\n\t\t\tdbg(\"%s: slot must be power up to get sensor-state\\n\",\n\t\t\t    __func__);\n\n\t\t\t \n\t\t\trc = rtas_set_power_level(slot->power_domain, POWER_ON,\n\t\t\t\t\t\t  &setlevel);\n\t\t\tif (rc < 0) {\n\t\t\t\tdbg(\"%s: power on slot[%s] failed rc=%d.\\n\",\n\t\t\t\t    __func__, slot->name, rc);\n\t\t\t} else {\n\t\t\t\trc = __rpaphp_get_sensor_state(slot, state);\n\t\t\t}\n\t\t} else if (rc == -ENODEV)\n\t\t\tinfo(\"%s: slot is unusable\\n\", __func__);\n\t\telse\n\t\t\terr(\"%s failed to get sensor state\\n\", __func__);\n\t}\n\treturn rc;\n}\n\n \nint rpaphp_enable_slot(struct slot *slot)\n{\n\tint rc, level, state;\n\tstruct pci_bus *bus;\n\n\tslot->state = EMPTY;\n\n\t \n\trc = rtas_get_power_level(slot->power_domain, &level);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\trc = rpaphp_get_sensor_state(slot, &state);\n\tif (rc)\n\t\treturn rc;\n\n\tbus = pci_find_bus_by_node(slot->dn);\n\tif (!bus) {\n\t\terr(\"%s: no pci_bus for dn %pOF\\n\", __func__, slot->dn);\n\t\treturn -EINVAL;\n\t}\n\n\tslot->bus = bus;\n\tslot->pci_devs = &bus->devices;\n\n\t \n\tif (state == PRESENT) {\n\t\tslot->state = NOT_CONFIGURED;\n\n\t\t \n\t\tif (!slot->dn->child) {\n\t\t\terr(\"%s: slot[%s]'s device_node doesn't have child for adapter\\n\",\n\t\t\t    __func__, slot->name);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (list_empty(&bus->devices)) {\n\t\t\tpseries_eeh_init_edev_recursive(PCI_DN(slot->dn));\n\t\t\tpci_hp_add_devices(bus);\n\t\t}\n\n\t\tif (!list_empty(&bus->devices)) {\n\t\t\tslot->state = CONFIGURED;\n\t\t}\n\n\t\tif (rpaphp_debug) {\n\t\t\tstruct pci_dev *dev;\n\t\t\tdbg(\"%s: pci_devs of slot[%pOF]\\n\", __func__, slot->dn);\n\t\t\tlist_for_each_entry(dev, &bus->devices, bus_list)\n\t\t\t\tdbg(\"\\t%s\\n\", pci_name(dev));\n\t\t}\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}