{
  "module_name": "cpqphp.h",
  "hash_id": "e1d2924d9407e23001b28fb682f50d6a7d06d7658a067cb221d7118e7896d0d6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/hotplug/cpqphp.h",
  "human_readable_source": " \n \n#ifndef _CPQPHP_H\n#define _CPQPHP_H\n\n#include <linux/interrupt.h>\n#include <linux/io.h>\t\t \n#include <linux/delay.h>\t \n#include <linux/mutex.h>\n#include <linux/sched/signal.h>\t \n\n#define MY_NAME\t\"cpqphp\"\n\n#define dbg(fmt, arg...) do { if (cpqhp_debug) printk(KERN_DEBUG \"%s: \" fmt, MY_NAME, ## arg); } while (0)\n#define err(format, arg...) printk(KERN_ERR \"%s: \" format, MY_NAME, ## arg)\n#define info(format, arg...) printk(KERN_INFO \"%s: \" format, MY_NAME, ## arg)\n#define warn(format, arg...) printk(KERN_WARNING \"%s: \" format, MY_NAME, ## arg)\n\n\n\nstruct smbios_system_slot {\n\tu8 type;\n\tu8 length;\n\tu16 handle;\n\tu8 name_string_num;\n\tu8 slot_type;\n\tu8 slot_width;\n\tu8 slot_current_usage;\n\tu8 slot_length;\n\tu16 slot_number;\n\tu8 properties1;\n\tu8 properties2;\n} __attribute__ ((packed));\n\n \nenum smbios_system_slot_offsets {\n\tSMBIOS_SLOT_GENERIC_TYPE =\toffsetof(struct smbios_system_slot, type),\n\tSMBIOS_SLOT_GENERIC_LENGTH =\toffsetof(struct smbios_system_slot, length),\n\tSMBIOS_SLOT_GENERIC_HANDLE =\toffsetof(struct smbios_system_slot, handle),\n\tSMBIOS_SLOT_NAME_STRING_NUM =\toffsetof(struct smbios_system_slot, name_string_num),\n\tSMBIOS_SLOT_TYPE =\t\toffsetof(struct smbios_system_slot, slot_type),\n\tSMBIOS_SLOT_WIDTH =\t\toffsetof(struct smbios_system_slot, slot_width),\n\tSMBIOS_SLOT_CURRENT_USAGE =\toffsetof(struct smbios_system_slot, slot_current_usage),\n\tSMBIOS_SLOT_LENGTH =\t\toffsetof(struct smbios_system_slot, slot_length),\n\tSMBIOS_SLOT_NUMBER =\t\toffsetof(struct smbios_system_slot, slot_number),\n\tSMBIOS_SLOT_PROPERTIES1 =\toffsetof(struct smbios_system_slot, properties1),\n\tSMBIOS_SLOT_PROPERTIES2 =\toffsetof(struct smbios_system_slot, properties2),\n};\n\nstruct smbios_generic {\n\tu8 type;\n\tu8 length;\n\tu16 handle;\n} __attribute__ ((packed));\n\n \nenum smbios_generic_offsets {\n\tSMBIOS_GENERIC_TYPE =\toffsetof(struct smbios_generic, type),\n\tSMBIOS_GENERIC_LENGTH =\toffsetof(struct smbios_generic, length),\n\tSMBIOS_GENERIC_HANDLE =\toffsetof(struct smbios_generic, handle),\n};\n\nstruct smbios_entry_point {\n\tchar anchor[4];\n\tu8 ep_checksum;\n\tu8 ep_length;\n\tu8 major_version;\n\tu8 minor_version;\n\tu16 max_size_entry;\n\tu8 ep_rev;\n\tu8 reserved[5];\n\tchar int_anchor[5];\n\tu8 int_checksum;\n\tu16 st_length;\n\tu32 st_address;\n\tu16 number_of_entrys;\n\tu8 bcd_rev;\n} __attribute__ ((packed));\n\n \nenum smbios_entry_point_offsets {\n\tANCHOR =\t\toffsetof(struct smbios_entry_point, anchor[0]),\n\tEP_CHECKSUM =\t\toffsetof(struct smbios_entry_point, ep_checksum),\n\tEP_LENGTH =\t\toffsetof(struct smbios_entry_point, ep_length),\n\tMAJOR_VERSION =\t\toffsetof(struct smbios_entry_point, major_version),\n\tMINOR_VERSION =\t\toffsetof(struct smbios_entry_point, minor_version),\n\tMAX_SIZE_ENTRY =\toffsetof(struct smbios_entry_point, max_size_entry),\n\tEP_REV =\t\toffsetof(struct smbios_entry_point, ep_rev),\n\tINT_ANCHOR =\t\toffsetof(struct smbios_entry_point, int_anchor[0]),\n\tINT_CHECKSUM =\t\toffsetof(struct smbios_entry_point, int_checksum),\n\tST_LENGTH =\t\toffsetof(struct smbios_entry_point, st_length),\n\tST_ADDRESS =\t\toffsetof(struct smbios_entry_point, st_address),\n\tNUMBER_OF_ENTRYS =\toffsetof(struct smbios_entry_point, number_of_entrys),\n\tBCD_REV =\t\toffsetof(struct smbios_entry_point, bcd_rev),\n};\n\nstruct ctrl_reg {\t\t\t \n\tu8\tslot_RST;\t\t \n\tu8\tslot_enable;\t\t \n\tu16\tmisc;\t\t\t \n\tu32\tled_control;\t\t \n\tu32\tint_input_clear;\t \n\tu32\tint_mask;\t\t \n\tu8\treserved0;\t\t \n\tu8\treserved1;\t\t \n\tu8\treserved2;\t\t \n\tu8\tgen_output_AB;\t\t \n\tu32\tnon_int_input;\t\t \n\tu32\treserved3;\t\t \n\tu32\treserved4;\t\t \n\tu32\treserved5;\t\t \n\tu8\treserved6;\t\t \n\tu8\treserved7;\t\t \n\tu16\treserved8;\t\t \n\tu8\tslot_mask;\t\t \n\tu8\treserved9;\t\t \n\tu8\treserved10;\t\t \n\tu8\treserved11;\t\t \n\tu8\tslot_SERR;\t\t \n\tu8\tslot_power;\t\t \n\tu8\treserved12;\t\t \n\tu8\treserved13;\t\t \n\tu8\tnext_curr_freq;\t\t \n\tu8\treset_freq_mode;\t \n} __attribute__ ((packed));\n\n \nenum ctrl_offsets {\n\tSLOT_RST =\t\toffsetof(struct ctrl_reg, slot_RST),\n\tSLOT_ENABLE =\t\toffsetof(struct ctrl_reg, slot_enable),\n\tMISC =\t\t\toffsetof(struct ctrl_reg, misc),\n\tLED_CONTROL =\t\toffsetof(struct ctrl_reg, led_control),\n\tINT_INPUT_CLEAR =\toffsetof(struct ctrl_reg, int_input_clear),\n\tINT_MASK =\t\toffsetof(struct ctrl_reg, int_mask),\n\tCTRL_RESERVED0 =\toffsetof(struct ctrl_reg, reserved0),\n\tCTRL_RESERVED1 =\toffsetof(struct ctrl_reg, reserved1),\n\tCTRL_RESERVED2 =\toffsetof(struct ctrl_reg, reserved1),\n\tGEN_OUTPUT_AB =\t\toffsetof(struct ctrl_reg, gen_output_AB),\n\tNON_INT_INPUT =\t\toffsetof(struct ctrl_reg, non_int_input),\n\tCTRL_RESERVED3 =\toffsetof(struct ctrl_reg, reserved3),\n\tCTRL_RESERVED4 =\toffsetof(struct ctrl_reg, reserved4),\n\tCTRL_RESERVED5 =\toffsetof(struct ctrl_reg, reserved5),\n\tCTRL_RESERVED6 =\toffsetof(struct ctrl_reg, reserved6),\n\tCTRL_RESERVED7 =\toffsetof(struct ctrl_reg, reserved7),\n\tCTRL_RESERVED8 =\toffsetof(struct ctrl_reg, reserved8),\n\tSLOT_MASK =\t\toffsetof(struct ctrl_reg, slot_mask),\n\tCTRL_RESERVED9 =\toffsetof(struct ctrl_reg, reserved9),\n\tCTRL_RESERVED10 =\toffsetof(struct ctrl_reg, reserved10),\n\tCTRL_RESERVED11 =\toffsetof(struct ctrl_reg, reserved11),\n\tSLOT_SERR =\t\toffsetof(struct ctrl_reg, slot_SERR),\n\tSLOT_POWER =\t\toffsetof(struct ctrl_reg, slot_power),\n\tNEXT_CURR_FREQ =\toffsetof(struct ctrl_reg, next_curr_freq),\n\tRESET_FREQ_MODE =\toffsetof(struct ctrl_reg, reset_freq_mode),\n};\n\nstruct hrt {\n\tchar sig0;\n\tchar sig1;\n\tchar sig2;\n\tchar sig3;\n\tu16 unused_IRQ;\n\tu16 PCIIRQ;\n\tu8 number_of_entries;\n\tu8 revision;\n\tu16 reserved1;\n\tu32 reserved2;\n} __attribute__ ((packed));\n\n \nenum hrt_offsets {\n\tSIG0 =\t\t\toffsetof(struct hrt, sig0),\n\tSIG1 =\t\t\toffsetof(struct hrt, sig1),\n\tSIG2 =\t\t\toffsetof(struct hrt, sig2),\n\tSIG3 =\t\t\toffsetof(struct hrt, sig3),\n\tUNUSED_IRQ =\t\toffsetof(struct hrt, unused_IRQ),\n\tPCIIRQ =\t\toffsetof(struct hrt, PCIIRQ),\n\tNUMBER_OF_ENTRIES =\toffsetof(struct hrt, number_of_entries),\n\tREVISION =\t\toffsetof(struct hrt, revision),\n\tHRT_RESERVED1 =\t\toffsetof(struct hrt, reserved1),\n\tHRT_RESERVED2 =\t\toffsetof(struct hrt, reserved2),\n};\n\nstruct slot_rt {\n\tu8 dev_func;\n\tu8 primary_bus;\n\tu8 secondary_bus;\n\tu8 max_bus;\n\tu16 io_base;\n\tu16 io_length;\n\tu16 mem_base;\n\tu16 mem_length;\n\tu16 pre_mem_base;\n\tu16 pre_mem_length;\n} __attribute__ ((packed));\n\n \nenum slot_rt_offsets {\n\tDEV_FUNC =\t\toffsetof(struct slot_rt, dev_func),\n\tPRIMARY_BUS =\t\toffsetof(struct slot_rt, primary_bus),\n\tSECONDARY_BUS =\t\toffsetof(struct slot_rt, secondary_bus),\n\tMAX_BUS =\t\toffsetof(struct slot_rt, max_bus),\n\tIO_BASE =\t\toffsetof(struct slot_rt, io_base),\n\tIO_LENGTH =\t\toffsetof(struct slot_rt, io_length),\n\tMEM_BASE =\t\toffsetof(struct slot_rt, mem_base),\n\tMEM_LENGTH =\t\toffsetof(struct slot_rt, mem_length),\n\tPRE_MEM_BASE =\t\toffsetof(struct slot_rt, pre_mem_base),\n\tPRE_MEM_LENGTH =\toffsetof(struct slot_rt, pre_mem_length),\n};\n\nstruct pci_func {\n\tstruct pci_func *next;\n\tu8 bus;\n\tu8 device;\n\tu8 function;\n\tu8 is_a_board;\n\tu16 status;\n\tu8 configured;\n\tu8 switch_save;\n\tu8 presence_save;\n\tu32 base_length[0x06];\n\tu8 base_type[0x06];\n\tu16 reserved2;\n\tu32 config_space[0x20];\n\tstruct pci_resource *mem_head;\n\tstruct pci_resource *p_mem_head;\n\tstruct pci_resource *io_head;\n\tstruct pci_resource *bus_head;\n\tstruct timer_list *p_task_event;\n\tstruct pci_dev *pci_dev;\n};\n\nstruct slot {\n\tstruct slot *next;\n\tu8 bus;\n\tu8 device;\n\tu8 number;\n\tu8 is_a_board;\n\tu8 configured;\n\tu8 state;\n\tu8 switch_save;\n\tu8 presence_save;\n\tu32 capabilities;\n\tu16 reserved2;\n\tstruct timer_list task_event;\n\tu8 hp_slot;\n\tstruct controller *ctrl;\n\tvoid __iomem *p_sm_slot;\n\tstruct hotplug_slot hotplug_slot;\n};\n\nstruct pci_resource {\n\tstruct pci_resource *next;\n\tu32 base;\n\tu32 length;\n};\n\nstruct event_info {\n\tu32 event_type;\n\tu8 hp_slot;\n};\n\nstruct controller {\n\tstruct controller *next;\n\tu32 ctrl_int_comp;\n\tstruct mutex crit_sect;\t \n\tvoid __iomem *hpc_reg;\t \n\tstruct pci_resource *mem_head;\n\tstruct pci_resource *p_mem_head;\n\tstruct pci_resource *io_head;\n\tstruct pci_resource *bus_head;\n\tstruct pci_dev *pci_dev;\n\tstruct pci_bus *pci_bus;\n\tstruct event_info event_queue[10];\n\tstruct slot *slot;\n\tu8 next_event;\n\tu8 interrupt;\n\tu8 cfgspc_irq;\n\tu8 bus;\t\t\t \n\tu8 rev;\n\tu8 slot_device_offset;\n\tu8 first_slot;\n\tu8 add_support;\n\tu8 push_flag;\n\tu8 push_button;\t\t\t \n\tu8 slot_switch_type;\t\t \n\tu8 defeature_PHP;\t\t \n\tu8 alternate_base_address;\t \n\tu8 pci_config_space;\t\t \n\tu8 pcix_speed_capability;\t \n\tu8 pcix_support;\t\t \n\tu16 vendor_id;\n\tstruct work_struct int_task_event;\n\twait_queue_head_t queue;\t \n\tstruct dentry *dentry;\t\t \n};\n\nstruct irq_mapping {\n\tu8 barber_pole;\n\tu8 valid_INT;\n\tu8 interrupt[4];\n};\n\nstruct resource_lists {\n\tstruct pci_resource *mem_head;\n\tstruct pci_resource *p_mem_head;\n\tstruct pci_resource *io_head;\n\tstruct pci_resource *bus_head;\n\tstruct irq_mapping *irqs;\n};\n\n#define ROM_PHY_ADDR\t\t\t0x0F0000\n#define ROM_PHY_LEN\t\t\t0x00ffff\n\n#define PCI_HPC_ID\t\t\t0xA0F7\n#define PCI_SUB_HPC_ID\t\t\t0xA2F7\n#define PCI_SUB_HPC_ID2\t\t\t0xA2F8\n#define PCI_SUB_HPC_ID3\t\t\t0xA2F9\n#define PCI_SUB_HPC_ID_INTC\t\t0xA2FA\n#define PCI_SUB_HPC_ID4\t\t\t0xA2FD\n\n#define INT_BUTTON_IGNORE\t\t0\n#define INT_PRESENCE_ON\t\t\t1\n#define INT_PRESENCE_OFF\t\t2\n#define INT_SWITCH_CLOSE\t\t3\n#define INT_SWITCH_OPEN\t\t\t4\n#define INT_POWER_FAULT\t\t\t5\n#define INT_POWER_FAULT_CLEAR\t\t6\n#define INT_BUTTON_PRESS\t\t7\n#define INT_BUTTON_RELEASE\t\t8\n#define INT_BUTTON_CANCEL\t\t9\n\n#define STATIC_STATE\t\t\t0\n#define BLINKINGON_STATE\t\t1\n#define BLINKINGOFF_STATE\t\t2\n#define POWERON_STATE\t\t\t3\n#define POWEROFF_STATE\t\t\t4\n\n#define PCISLOT_INTERLOCK_CLOSED\t0x00000001\n#define PCISLOT_ADAPTER_PRESENT\t\t0x00000002\n#define PCISLOT_POWERED\t\t\t0x00000004\n#define PCISLOT_66_MHZ_OPERATION\t0x00000008\n#define PCISLOT_64_BIT_OPERATION\t0x00000010\n#define PCISLOT_REPLACE_SUPPORTED\t0x00000020\n#define PCISLOT_ADD_SUPPORTED\t\t0x00000040\n#define PCISLOT_INTERLOCK_SUPPORTED\t0x00000080\n#define PCISLOT_66_MHZ_SUPPORTED\t0x00000100\n#define PCISLOT_64_BIT_SUPPORTED\t0x00000200\n\n#define PCI_TO_PCI_BRIDGE_CLASS\t\t0x00060400\n\n#define INTERLOCK_OPEN\t\t\t0x00000002\n#define ADD_NOT_SUPPORTED\t\t0x00000003\n#define CARD_FUNCTIONING\t\t0x00000005\n#define ADAPTER_NOT_SAME\t\t0x00000006\n#define NO_ADAPTER_PRESENT\t\t0x00000009\n#define NOT_ENOUGH_RESOURCES\t\t0x0000000B\n#define DEVICE_TYPE_NOT_SUPPORTED\t0x0000000C\n#define POWER_FAILURE\t\t\t0x0000000E\n\n#define REMOVE_NOT_SUPPORTED\t\t0x00000003\n\n\n \n#define msg_initialization_err\t\"Initialization failure, error=%d\\n\"\n#define msg_HPC_rev_error\t\"Unsupported revision of the PCI hot plug controller found.\\n\"\n#define msg_HPC_non_compaq_or_intel\t\"The PCI hot plug controller is not supported by this driver.\\n\"\n#define msg_HPC_not_supported\t\"this system is not supported by this version of cpqphpd. Upgrade to a newer version of cpqphpd\\n\"\n#define msg_unable_to_save\t\"unable to store PCI hot plug add resource information. This system must be rebooted before adding any PCI devices.\\n\"\n#define msg_button_on\t\t\"PCI slot #%d - powering on due to button press.\\n\"\n#define msg_button_off\t\t\"PCI slot #%d - powering off due to button press.\\n\"\n#define msg_button_cancel\t\"PCI slot #%d - action canceled due to button press.\\n\"\n#define msg_button_ignore\t\"PCI slot #%d - button press ignored.  (action in progress...)\\n\"\n\n\n \nvoid cpqhp_initialize_debugfs(void);\nvoid cpqhp_shutdown_debugfs(void);\nvoid cpqhp_create_debugfs_files(struct controller *ctrl);\nvoid cpqhp_remove_debugfs_files(struct controller *ctrl);\n\n \nvoid cpqhp_pushbutton_thread(struct timer_list *t);\nirqreturn_t cpqhp_ctrl_intr(int IRQ, void *data);\nint cpqhp_find_available_resources(struct controller *ctrl,\n\t\t\t\t   void __iomem *rom_start);\nint cpqhp_event_start_thread(void);\nvoid cpqhp_event_stop_thread(void);\nstruct pci_func *cpqhp_slot_create(unsigned char busnumber);\nstruct pci_func *cpqhp_slot_find(unsigned char bus, unsigned char device,\n\t\t\t\t unsigned char index);\nint cpqhp_process_SI(struct controller *ctrl, struct pci_func *func);\nint cpqhp_process_SS(struct controller *ctrl, struct pci_func *func);\nint cpqhp_hardware_test(struct controller *ctrl, int test_num);\n\n \nint\tcpqhp_resource_sort_and_combine(struct pci_resource **head);\n\n \nint cpqhp_set_irq(u8 bus_num, u8 dev_num, u8 int_pin, u8 irq_num);\nint cpqhp_get_bus_dev(struct controller *ctrl, u8 *bus_num, u8 *dev_num,\n\t\t      u8 slot);\nint cpqhp_save_config(struct controller *ctrl, int busnumber, int is_hot_plug);\nint cpqhp_save_base_addr_length(struct controller *ctrl, struct pci_func *func);\nint cpqhp_save_used_resources(struct controller *ctrl, struct pci_func *func);\nint cpqhp_configure_board(struct controller *ctrl, struct pci_func *func);\nint cpqhp_save_slot_config(struct controller *ctrl, struct pci_func *new_slot);\nint cpqhp_valid_replace(struct controller *ctrl, struct pci_func *func);\nvoid cpqhp_destroy_board_resources(struct pci_func *func);\nint cpqhp_return_board_resources(struct pci_func *func,\n\t\t\t\t struct resource_lists *resources);\nvoid cpqhp_destroy_resource_list(struct resource_lists *resources);\nint cpqhp_configure_device(struct controller *ctrl, struct pci_func *func);\nint cpqhp_unconfigure_device(struct pci_func *func);\n\n \nextern int cpqhp_debug;\nextern int cpqhp_legacy_mode;\nextern struct controller *cpqhp_ctrl_list;\nextern struct pci_func *cpqhp_slot_list[256];\nextern struct irq_routing_table *cpqhp_routing_table;\n\n \nextern u8 cpqhp_nic_irq;\nextern u8 cpqhp_disk_irq;\n\n\n \n\nstatic inline const char *slot_name(struct slot *slot)\n{\n\treturn hotplug_slot_name(&slot->hotplug_slot);\n}\n\nstatic inline struct slot *to_slot(struct hotplug_slot *hotplug_slot)\n{\n\treturn container_of(hotplug_slot, struct slot, hotplug_slot);\n}\n\n \nstatic inline void return_resource(struct pci_resource **head,\n\t\t\t\t   struct pci_resource *node)\n{\n\tif (!node || !head)\n\t\treturn;\n\tnode->next = *head;\n\t*head = node;\n}\n\nstatic inline void set_SOGO(struct controller *ctrl)\n{\n\tu16 misc;\n\n\tmisc = readw(ctrl->hpc_reg + MISC);\n\tmisc = (misc | 0x0001) & 0xFFFB;\n\twritew(misc, ctrl->hpc_reg + MISC);\n}\n\n\nstatic inline void amber_LED_on(struct controller *ctrl, u8 slot)\n{\n\tu32 led_control;\n\n\tled_control = readl(ctrl->hpc_reg + LED_CONTROL);\n\tled_control |= (0x01010000L << slot);\n\twritel(led_control, ctrl->hpc_reg + LED_CONTROL);\n}\n\n\nstatic inline void amber_LED_off(struct controller *ctrl, u8 slot)\n{\n\tu32 led_control;\n\n\tled_control = readl(ctrl->hpc_reg + LED_CONTROL);\n\tled_control &= ~(0x01010000L << slot);\n\twritel(led_control, ctrl->hpc_reg + LED_CONTROL);\n}\n\n\nstatic inline int read_amber_LED(struct controller *ctrl, u8 slot)\n{\n\tu32 led_control;\n\n\tled_control = readl(ctrl->hpc_reg + LED_CONTROL);\n\tled_control &= (0x01010000L << slot);\n\n\treturn led_control ? 1 : 0;\n}\n\n\nstatic inline void green_LED_on(struct controller *ctrl, u8 slot)\n{\n\tu32 led_control;\n\n\tled_control = readl(ctrl->hpc_reg + LED_CONTROL);\n\tled_control |= 0x0101L << slot;\n\twritel(led_control, ctrl->hpc_reg + LED_CONTROL);\n}\n\nstatic inline void green_LED_off(struct controller *ctrl, u8 slot)\n{\n\tu32 led_control;\n\n\tled_control = readl(ctrl->hpc_reg + LED_CONTROL);\n\tled_control &= ~(0x0101L << slot);\n\twritel(led_control, ctrl->hpc_reg + LED_CONTROL);\n}\n\n\nstatic inline void green_LED_blink(struct controller *ctrl, u8 slot)\n{\n\tu32 led_control;\n\n\tled_control = readl(ctrl->hpc_reg + LED_CONTROL);\n\tled_control &= ~(0x0101L << slot);\n\tled_control |= (0x0001L << slot);\n\twritel(led_control, ctrl->hpc_reg + LED_CONTROL);\n}\n\n\nstatic inline void slot_disable(struct controller *ctrl, u8 slot)\n{\n\tu8 slot_enable;\n\n\tslot_enable = readb(ctrl->hpc_reg + SLOT_ENABLE);\n\tslot_enable &= ~(0x01 << slot);\n\twriteb(slot_enable, ctrl->hpc_reg + SLOT_ENABLE);\n}\n\n\nstatic inline void slot_enable(struct controller *ctrl, u8 slot)\n{\n\tu8 slot_enable;\n\n\tslot_enable = readb(ctrl->hpc_reg + SLOT_ENABLE);\n\tslot_enable |= (0x01 << slot);\n\twriteb(slot_enable, ctrl->hpc_reg + SLOT_ENABLE);\n}\n\n\nstatic inline u8 is_slot_enabled(struct controller *ctrl, u8 slot)\n{\n\tu8 slot_enable;\n\n\tslot_enable = readb(ctrl->hpc_reg + SLOT_ENABLE);\n\tslot_enable &= (0x01 << slot);\n\treturn slot_enable ? 1 : 0;\n}\n\n\nstatic inline u8 read_slot_enable(struct controller *ctrl)\n{\n\treturn readb(ctrl->hpc_reg + SLOT_ENABLE);\n}\n\n\n \nstatic inline u8 get_controller_speed(struct controller *ctrl)\n{\n\tu8 curr_freq;\n\tu16 misc;\n\n\tif (ctrl->pcix_support) {\n\t\tcurr_freq = readb(ctrl->hpc_reg + NEXT_CURR_FREQ);\n\t\tif ((curr_freq & 0xB0) == 0xB0)\n\t\t\treturn PCI_SPEED_133MHz_PCIX;\n\t\tif ((curr_freq & 0xA0) == 0xA0)\n\t\t\treturn PCI_SPEED_100MHz_PCIX;\n\t\tif ((curr_freq & 0x90) == 0x90)\n\t\t\treturn PCI_SPEED_66MHz_PCIX;\n\t\tif (curr_freq & 0x10)\n\t\t\treturn PCI_SPEED_66MHz;\n\n\t\treturn PCI_SPEED_33MHz;\n\t}\n\n\tmisc = readw(ctrl->hpc_reg + MISC);\n\treturn (misc & 0x0800) ? PCI_SPEED_66MHz : PCI_SPEED_33MHz;\n}\n\n\n \nstatic inline u8 get_adapter_speed(struct controller *ctrl, u8 hp_slot)\n{\n\tu32 temp_dword = readl(ctrl->hpc_reg + NON_INT_INPUT);\n\tdbg(\"slot: %d, PCIXCAP: %8x\\n\", hp_slot, temp_dword);\n\tif (ctrl->pcix_support) {\n\t\tif (temp_dword & (0x10000 << hp_slot))\n\t\t\treturn PCI_SPEED_133MHz_PCIX;\n\t\tif (temp_dword & (0x100 << hp_slot))\n\t\t\treturn PCI_SPEED_66MHz_PCIX;\n\t}\n\n\tif (temp_dword & (0x01 << hp_slot))\n\t\treturn PCI_SPEED_66MHz;\n\n\treturn PCI_SPEED_33MHz;\n}\n\nstatic inline void enable_slot_power(struct controller *ctrl, u8 slot)\n{\n\tu8 slot_power;\n\n\tslot_power = readb(ctrl->hpc_reg + SLOT_POWER);\n\tslot_power |= (0x01 << slot);\n\twriteb(slot_power, ctrl->hpc_reg + SLOT_POWER);\n}\n\nstatic inline void disable_slot_power(struct controller *ctrl, u8 slot)\n{\n\tu8 slot_power;\n\n\tslot_power = readb(ctrl->hpc_reg + SLOT_POWER);\n\tslot_power &= ~(0x01 << slot);\n\twriteb(slot_power, ctrl->hpc_reg + SLOT_POWER);\n}\n\n\nstatic inline int cpq_get_attention_status(struct controller *ctrl, struct slot *slot)\n{\n\tu8 hp_slot;\n\n\thp_slot = slot->device - ctrl->slot_device_offset;\n\n\treturn read_amber_LED(ctrl, hp_slot);\n}\n\n\nstatic inline int get_slot_enabled(struct controller *ctrl, struct slot *slot)\n{\n\tu8 hp_slot;\n\n\thp_slot = slot->device - ctrl->slot_device_offset;\n\n\treturn is_slot_enabled(ctrl, hp_slot);\n}\n\n\nstatic inline int cpq_get_latch_status(struct controller *ctrl,\n\t\t\t\t       struct slot *slot)\n{\n\tu32 status;\n\tu8 hp_slot;\n\n\thp_slot = slot->device - ctrl->slot_device_offset;\n\tdbg(\"%s: slot->device = %d, ctrl->slot_device_offset = %d\\n\",\n\t    __func__, slot->device, ctrl->slot_device_offset);\n\n\tstatus = (readl(ctrl->hpc_reg + INT_INPUT_CLEAR) & (0x01L << hp_slot));\n\n\treturn (status == 0) ? 1 : 0;\n}\n\n\nstatic inline int get_presence_status(struct controller *ctrl,\n\t\t\t\t      struct slot *slot)\n{\n\tint presence_save = 0;\n\tu8 hp_slot;\n\tu32 tempdword;\n\n\thp_slot = slot->device - ctrl->slot_device_offset;\n\n\ttempdword = readl(ctrl->hpc_reg + INT_INPUT_CLEAR);\n\tpresence_save = (int) ((((~tempdword) >> 23) | ((~tempdword) >> 15))\n\t\t\t\t>> hp_slot) & 0x02;\n\n\treturn presence_save;\n}\n\nstatic inline int wait_for_ctrl_irq(struct controller *ctrl)\n{\n\tDECLARE_WAITQUEUE(wait, current);\n\tint retval = 0;\n\n\tdbg(\"%s - start\\n\", __func__);\n\tadd_wait_queue(&ctrl->queue, &wait);\n\t \n\tmsleep_interruptible(1000);\n\tremove_wait_queue(&ctrl->queue, &wait);\n\tif (signal_pending(current))\n\t\tretval =  -EINTR;\n\n\tdbg(\"%s - end\\n\", __func__);\n\treturn retval;\n}\n\n#include <asm/pci_x86.h>\nstatic inline int cpqhp_routing_table_length(void)\n{\n\tBUG_ON(cpqhp_routing_table == NULL);\n\treturn ((cpqhp_routing_table->size - sizeof(struct irq_routing_table)) /\n\t\tsizeof(struct irq_info));\n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}