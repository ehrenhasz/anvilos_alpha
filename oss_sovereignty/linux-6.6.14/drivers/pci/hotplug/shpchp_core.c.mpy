{
  "module_name": "shpchp_core.c",
  "hash_id": "dd10d625bf3123d0be336dd7535cf5964d430a776fe99e80f67ff2c0a2c2f926",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/hotplug/shpchp_core.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include \"shpchp.h\"\n\n \nbool shpchp_debug;\nbool shpchp_poll_mode;\nint shpchp_poll_time;\n\n#define DRIVER_VERSION\t\"0.4\"\n#define DRIVER_AUTHOR\t\"Dan Zink <dan.zink@compaq.com>, Greg Kroah-Hartman <greg@kroah.com>, Dely Sy <dely.l.sy@intel.com>\"\n#define DRIVER_DESC\t\"Standard Hot Plug PCI Controller Driver\"\n\nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_DESCRIPTION(DRIVER_DESC);\n\nmodule_param(shpchp_debug, bool, 0644);\nmodule_param(shpchp_poll_mode, bool, 0644);\nmodule_param(shpchp_poll_time, int, 0644);\nMODULE_PARM_DESC(shpchp_debug, \"Debugging mode enabled or not\");\nMODULE_PARM_DESC(shpchp_poll_mode, \"Using polling mechanism for hot-plug events or not\");\nMODULE_PARM_DESC(shpchp_poll_time, \"Polling mechanism frequency, in seconds\");\n\n#define SHPC_MODULE_NAME \"shpchp\"\n\nstatic int set_attention_status(struct hotplug_slot *slot, u8 value);\nstatic int enable_slot(struct hotplug_slot *slot);\nstatic int disable_slot(struct hotplug_slot *slot);\nstatic int get_power_status(struct hotplug_slot *slot, u8 *value);\nstatic int get_attention_status(struct hotplug_slot *slot, u8 *value);\nstatic int get_latch_status(struct hotplug_slot *slot, u8 *value);\nstatic int get_adapter_status(struct hotplug_slot *slot, u8 *value);\n\nstatic const struct hotplug_slot_ops shpchp_hotplug_slot_ops = {\n\t.set_attention_status =\tset_attention_status,\n\t.enable_slot =\t\tenable_slot,\n\t.disable_slot =\t\tdisable_slot,\n\t.get_power_status =\tget_power_status,\n\t.get_attention_status =\tget_attention_status,\n\t.get_latch_status =\tget_latch_status,\n\t.get_adapter_status =\tget_adapter_status,\n};\n\nstatic int init_slots(struct controller *ctrl)\n{\n\tstruct slot *slot;\n\tstruct hotplug_slot *hotplug_slot;\n\tchar name[SLOT_NAME_SIZE];\n\tint retval;\n\tint i;\n\n\tfor (i = 0; i < ctrl->num_slots; i++) {\n\t\tslot = kzalloc(sizeof(*slot), GFP_KERNEL);\n\t\tif (!slot) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto error;\n\t\t}\n\n\t\thotplug_slot = &slot->hotplug_slot;\n\n\t\tslot->hp_slot = i;\n\t\tslot->ctrl = ctrl;\n\t\tslot->bus = ctrl->pci_dev->subordinate->number;\n\t\tslot->device = ctrl->slot_device_offset + i;\n\t\tslot->hpc_ops = ctrl->hpc_ops;\n\t\tslot->number = ctrl->first_slot + (ctrl->slot_num_inc * i);\n\n\t\tslot->wq = alloc_workqueue(\"shpchp-%d\", 0, 0, slot->number);\n\t\tif (!slot->wq) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto error_slot;\n\t\t}\n\n\t\tmutex_init(&slot->lock);\n\t\tINIT_DELAYED_WORK(&slot->work, shpchp_queue_pushbutton_work);\n\n\t\t \n\t\tsnprintf(name, SLOT_NAME_SIZE, \"%d\", slot->number);\n\t\thotplug_slot->ops = &shpchp_hotplug_slot_ops;\n\n\t\tctrl_dbg(ctrl, \"Registering domain:bus:dev=%04x:%02x:%02x hp_slot=%x sun=%x slot_device_offset=%x\\n\",\n\t\t\t pci_domain_nr(ctrl->pci_dev->subordinate),\n\t\t\t slot->bus, slot->device, slot->hp_slot, slot->number,\n\t\t\t ctrl->slot_device_offset);\n\t\tretval = pci_hp_register(hotplug_slot,\n\t\t\t\tctrl->pci_dev->subordinate, slot->device, name);\n\t\tif (retval) {\n\t\t\tctrl_err(ctrl, \"pci_hp_register failed with error %d\\n\",\n\t\t\t\t retval);\n\t\t\tgoto error_slotwq;\n\t\t}\n\n\t\tget_power_status(hotplug_slot, &slot->pwr_save);\n\t\tget_attention_status(hotplug_slot, &slot->attention_save);\n\t\tget_latch_status(hotplug_slot, &slot->latch_save);\n\t\tget_adapter_status(hotplug_slot, &slot->presence_save);\n\n\t\tlist_add(&slot->slot_list, &ctrl->slot_list);\n\t}\n\n\treturn 0;\nerror_slotwq:\n\tdestroy_workqueue(slot->wq);\nerror_slot:\n\tkfree(slot);\nerror:\n\treturn retval;\n}\n\nvoid cleanup_slots(struct controller *ctrl)\n{\n\tstruct slot *slot, *next;\n\n\tlist_for_each_entry_safe(slot, next, &ctrl->slot_list, slot_list) {\n\t\tlist_del(&slot->slot_list);\n\t\tcancel_delayed_work(&slot->work);\n\t\tdestroy_workqueue(slot->wq);\n\t\tpci_hp_deregister(&slot->hotplug_slot);\n\t\tkfree(slot);\n\t}\n}\n\n \nstatic int set_attention_status(struct hotplug_slot *hotplug_slot, u8 status)\n{\n\tstruct slot *slot = get_slot(hotplug_slot);\n\n\tctrl_dbg(slot->ctrl, \"%s: physical_slot = %s\\n\",\n\t\t __func__, slot_name(slot));\n\n\tslot->attention_save = status;\n\tslot->hpc_ops->set_attention_status(slot, status);\n\n\treturn 0;\n}\n\nstatic int enable_slot(struct hotplug_slot *hotplug_slot)\n{\n\tstruct slot *slot = get_slot(hotplug_slot);\n\n\tctrl_dbg(slot->ctrl, \"%s: physical_slot = %s\\n\",\n\t\t __func__, slot_name(slot));\n\n\treturn shpchp_sysfs_enable_slot(slot);\n}\n\nstatic int disable_slot(struct hotplug_slot *hotplug_slot)\n{\n\tstruct slot *slot = get_slot(hotplug_slot);\n\n\tctrl_dbg(slot->ctrl, \"%s: physical_slot = %s\\n\",\n\t\t __func__, slot_name(slot));\n\n\treturn shpchp_sysfs_disable_slot(slot);\n}\n\nstatic int get_power_status(struct hotplug_slot *hotplug_slot, u8 *value)\n{\n\tstruct slot *slot = get_slot(hotplug_slot);\n\tint retval;\n\n\tctrl_dbg(slot->ctrl, \"%s: physical_slot = %s\\n\",\n\t\t __func__, slot_name(slot));\n\n\tretval = slot->hpc_ops->get_power_status(slot, value);\n\tif (retval < 0)\n\t\t*value = slot->pwr_save;\n\n\treturn 0;\n}\n\nstatic int get_attention_status(struct hotplug_slot *hotplug_slot, u8 *value)\n{\n\tstruct slot *slot = get_slot(hotplug_slot);\n\tint retval;\n\n\tctrl_dbg(slot->ctrl, \"%s: physical_slot = %s\\n\",\n\t\t __func__, slot_name(slot));\n\n\tretval = slot->hpc_ops->get_attention_status(slot, value);\n\tif (retval < 0)\n\t\t*value = slot->attention_save;\n\n\treturn 0;\n}\n\nstatic int get_latch_status(struct hotplug_slot *hotplug_slot, u8 *value)\n{\n\tstruct slot *slot = get_slot(hotplug_slot);\n\tint retval;\n\n\tctrl_dbg(slot->ctrl, \"%s: physical_slot = %s\\n\",\n\t\t __func__, slot_name(slot));\n\n\tretval = slot->hpc_ops->get_latch_status(slot, value);\n\tif (retval < 0)\n\t\t*value = slot->latch_save;\n\n\treturn 0;\n}\n\nstatic int get_adapter_status(struct hotplug_slot *hotplug_slot, u8 *value)\n{\n\tstruct slot *slot = get_slot(hotplug_slot);\n\tint retval;\n\n\tctrl_dbg(slot->ctrl, \"%s: physical_slot = %s\\n\",\n\t\t __func__, slot_name(slot));\n\n\tretval = slot->hpc_ops->get_adapter_status(slot, value);\n\tif (retval < 0)\n\t\t*value = slot->presence_save;\n\n\treturn 0;\n}\n\nstatic bool shpc_capable(struct pci_dev *bridge)\n{\n\t \n\tif (bridge->vendor == PCI_VENDOR_ID_AMD &&\n\t    bridge->device == PCI_DEVICE_ID_AMD_GOLAM_7450)\n\t\treturn true;\n\n\tif (pci_find_capability(bridge, PCI_CAP_ID_SHPC))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic int shpc_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tint rc;\n\tstruct controller *ctrl;\n\n\tif (!shpc_capable(pdev))\n\t\treturn -ENODEV;\n\n\tif (acpi_get_hp_hw_control_from_firmware(pdev))\n\t\treturn -ENODEV;\n\n\tctrl = kzalloc(sizeof(*ctrl), GFP_KERNEL);\n\tif (!ctrl)\n\t\tgoto err_out_none;\n\n\tINIT_LIST_HEAD(&ctrl->slot_list);\n\n\trc = shpc_init(ctrl, pdev);\n\tif (rc) {\n\t\tctrl_dbg(ctrl, \"Controller initialization failed\\n\");\n\t\tgoto err_out_free_ctrl;\n\t}\n\n\tpci_set_drvdata(pdev, ctrl);\n\n\t \n\trc = init_slots(ctrl);\n\tif (rc) {\n\t\tctrl_err(ctrl, \"Slot initialization failed\\n\");\n\t\tgoto err_out_release_ctlr;\n\t}\n\n\trc = shpchp_create_ctrl_files(ctrl);\n\tif (rc)\n\t\tgoto err_cleanup_slots;\n\n\tpdev->shpc_managed = 1;\n\treturn 0;\n\nerr_cleanup_slots:\n\tcleanup_slots(ctrl);\nerr_out_release_ctlr:\n\tctrl->hpc_ops->release_ctlr(ctrl);\nerr_out_free_ctrl:\n\tkfree(ctrl);\nerr_out_none:\n\treturn -ENODEV;\n}\n\nstatic void shpc_remove(struct pci_dev *dev)\n{\n\tstruct controller *ctrl = pci_get_drvdata(dev);\n\n\tdev->shpc_managed = 0;\n\tshpchp_remove_ctrl_files(ctrl);\n\tctrl->hpc_ops->release_ctlr(ctrl);\n\tkfree(ctrl);\n}\n\nstatic const struct pci_device_id shpcd_pci_tbl[] = {\n\t{PCI_DEVICE_CLASS(PCI_CLASS_BRIDGE_PCI_NORMAL, ~0)},\n\t{   }\n};\nMODULE_DEVICE_TABLE(pci, shpcd_pci_tbl);\n\nstatic struct pci_driver shpc_driver = {\n\t.name =\t\tSHPC_MODULE_NAME,\n\t.id_table =\tshpcd_pci_tbl,\n\t.probe =\tshpc_probe,\n\t.remove =\tshpc_remove,\n};\n\nstatic int __init shpcd_init(void)\n{\n\tint retval;\n\n\tretval = pci_register_driver(&shpc_driver);\n\tdbg(\"%s: pci_register_driver = %d\\n\", __func__, retval);\n\tinfo(DRIVER_DESC \" version: \" DRIVER_VERSION \"\\n\");\n\n\treturn retval;\n}\n\nstatic void __exit shpcd_cleanup(void)\n{\n\tdbg(\"unload_shpchpd()\\n\");\n\tpci_unregister_driver(&shpc_driver);\n\tinfo(DRIVER_DESC \" version: \" DRIVER_VERSION \" unloaded\\n\");\n}\n\nmodule_init(shpcd_init);\nmodule_exit(shpcd_cleanup);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}