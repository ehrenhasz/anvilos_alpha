{
  "module_name": "pciehp_hpc.c",
  "hash_id": "119ba09702240df3758336a3702b96a3520c1cdb041ae76df2981e114a1ab4d3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/hotplug/pciehp_hpc.c",
  "human_readable_source": "\n \n\n#define dev_fmt(fmt) \"pciehp: \" fmt\n\n#include <linux/dmi.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/jiffies.h>\n#include <linux/kthread.h>\n#include <linux/pci.h>\n#include <linux/pm_runtime.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n\n#include \"../pci.h\"\n#include \"pciehp.h\"\n\nstatic const struct dmi_system_id inband_presence_disabled_dmi_table[] = {\n\t \n\t{\n\t\t.ident = \"Dell System\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_OEM_STRING, \"Dell System\"),\n\t\t},\n\t},\n\t{}\n};\n\nstatic inline struct pci_dev *ctrl_dev(struct controller *ctrl)\n{\n\treturn ctrl->pcie->port;\n}\n\nstatic irqreturn_t pciehp_isr(int irq, void *dev_id);\nstatic irqreturn_t pciehp_ist(int irq, void *dev_id);\nstatic int pciehp_poll(void *data);\n\nstatic inline int pciehp_request_irq(struct controller *ctrl)\n{\n\tint retval, irq = ctrl->pcie->irq;\n\n\tif (pciehp_poll_mode) {\n\t\tctrl->poll_thread = kthread_run(&pciehp_poll, ctrl,\n\t\t\t\t\t\t\"pciehp_poll-%s\",\n\t\t\t\t\t\tslot_name(ctrl));\n\t\treturn PTR_ERR_OR_ZERO(ctrl->poll_thread);\n\t}\n\n\t \n\tretval = request_threaded_irq(irq, pciehp_isr, pciehp_ist,\n\t\t\t\t      IRQF_SHARED, \"pciehp\", ctrl);\n\tif (retval)\n\t\tctrl_err(ctrl, \"Cannot get irq %d for the hotplug controller\\n\",\n\t\t\t irq);\n\treturn retval;\n}\n\nstatic inline void pciehp_free_irq(struct controller *ctrl)\n{\n\tif (pciehp_poll_mode)\n\t\tkthread_stop(ctrl->poll_thread);\n\telse\n\t\tfree_irq(ctrl->pcie->irq, ctrl);\n}\n\nstatic int pcie_poll_cmd(struct controller *ctrl, int timeout)\n{\n\tstruct pci_dev *pdev = ctrl_dev(ctrl);\n\tu16 slot_status;\n\n\tdo {\n\t\tpcie_capability_read_word(pdev, PCI_EXP_SLTSTA, &slot_status);\n\t\tif (PCI_POSSIBLE_ERROR(slot_status)) {\n\t\t\tctrl_info(ctrl, \"%s: no response from device\\n\",\n\t\t\t\t  __func__);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (slot_status & PCI_EXP_SLTSTA_CC) {\n\t\t\tpcie_capability_write_word(pdev, PCI_EXP_SLTSTA,\n\t\t\t\t\t\t   PCI_EXP_SLTSTA_CC);\n\t\t\tctrl->cmd_busy = 0;\n\t\t\tsmp_mb();\n\t\t\treturn 1;\n\t\t}\n\t\tmsleep(10);\n\t\ttimeout -= 10;\n\t} while (timeout >= 0);\n\treturn 0;\t \n}\n\nstatic void pcie_wait_cmd(struct controller *ctrl)\n{\n\tunsigned int msecs = pciehp_poll_mode ? 2500 : 1000;\n\tunsigned long duration = msecs_to_jiffies(msecs);\n\tunsigned long cmd_timeout = ctrl->cmd_started + duration;\n\tunsigned long now, timeout;\n\tint rc;\n\n\t \n\tif (NO_CMD_CMPL(ctrl))\n\t\treturn;\n\n\tif (!ctrl->cmd_busy)\n\t\treturn;\n\n\t \n\tnow = jiffies;\n\tif (time_before_eq(cmd_timeout, now))\n\t\ttimeout = 1;\n\telse\n\t\ttimeout = cmd_timeout - now;\n\n\tif (ctrl->slot_ctrl & PCI_EXP_SLTCTL_HPIE &&\n\t    ctrl->slot_ctrl & PCI_EXP_SLTCTL_CCIE)\n\t\trc = wait_event_timeout(ctrl->queue, !ctrl->cmd_busy, timeout);\n\telse\n\t\trc = pcie_poll_cmd(ctrl, jiffies_to_msecs(timeout));\n\n\tif (!rc)\n\t\tctrl_info(ctrl, \"Timeout on hotplug command %#06x (issued %u msec ago)\\n\",\n\t\t\t  ctrl->slot_ctrl,\n\t\t\t  jiffies_to_msecs(jiffies - ctrl->cmd_started));\n}\n\n#define CC_ERRATUM_MASK\t\t(PCI_EXP_SLTCTL_PCC |\t\\\n\t\t\t\t PCI_EXP_SLTCTL_PIC |\t\\\n\t\t\t\t PCI_EXP_SLTCTL_AIC |\t\\\n\t\t\t\t PCI_EXP_SLTCTL_EIC)\n\nstatic void pcie_do_write_cmd(struct controller *ctrl, u16 cmd,\n\t\t\t      u16 mask, bool wait)\n{\n\tstruct pci_dev *pdev = ctrl_dev(ctrl);\n\tu16 slot_ctrl_orig, slot_ctrl;\n\n\tmutex_lock(&ctrl->ctrl_lock);\n\n\t \n\tpcie_wait_cmd(ctrl);\n\n\tpcie_capability_read_word(pdev, PCI_EXP_SLTCTL, &slot_ctrl);\n\tif (PCI_POSSIBLE_ERROR(slot_ctrl)) {\n\t\tctrl_info(ctrl, \"%s: no response from device\\n\", __func__);\n\t\tgoto out;\n\t}\n\n\tslot_ctrl_orig = slot_ctrl;\n\tslot_ctrl &= ~mask;\n\tslot_ctrl |= (cmd & mask);\n\tctrl->cmd_busy = 1;\n\tsmp_mb();\n\tctrl->slot_ctrl = slot_ctrl;\n\tpcie_capability_write_word(pdev, PCI_EXP_SLTCTL, slot_ctrl);\n\tctrl->cmd_started = jiffies;\n\n\t \n\tif (pdev->broken_cmd_compl &&\n\t    (slot_ctrl_orig & CC_ERRATUM_MASK) == (slot_ctrl & CC_ERRATUM_MASK))\n\t\tctrl->cmd_busy = 0;\n\n\t \n\tif (wait)\n\t\tpcie_wait_cmd(ctrl);\n\nout:\n\tmutex_unlock(&ctrl->ctrl_lock);\n}\n\n \nstatic void pcie_write_cmd(struct controller *ctrl, u16 cmd, u16 mask)\n{\n\tpcie_do_write_cmd(ctrl, cmd, mask, true);\n}\n\n \nstatic void pcie_write_cmd_nowait(struct controller *ctrl, u16 cmd, u16 mask)\n{\n\tpcie_do_write_cmd(ctrl, cmd, mask, false);\n}\n\n \nint pciehp_check_link_active(struct controller *ctrl)\n{\n\tstruct pci_dev *pdev = ctrl_dev(ctrl);\n\tu16 lnk_status;\n\tint ret;\n\n\tret = pcie_capability_read_word(pdev, PCI_EXP_LNKSTA, &lnk_status);\n\tif (ret == PCIBIOS_DEVICE_NOT_FOUND || PCI_POSSIBLE_ERROR(lnk_status))\n\t\treturn -ENODEV;\n\n\tret = !!(lnk_status & PCI_EXP_LNKSTA_DLLLA);\n\tctrl_dbg(ctrl, \"%s: lnk_status = %x\\n\", __func__, lnk_status);\n\n\treturn ret;\n}\n\nstatic bool pci_bus_check_dev(struct pci_bus *bus, int devfn)\n{\n\tu32 l;\n\tint count = 0;\n\tint delay = 1000, step = 20;\n\tbool found = false;\n\n\tdo {\n\t\tfound = pci_bus_read_dev_vendor_id(bus, devfn, &l, 0);\n\t\tcount++;\n\n\t\tif (found)\n\t\t\tbreak;\n\n\t\tmsleep(step);\n\t\tdelay -= step;\n\t} while (delay > 0);\n\n\tif (count > 1)\n\t\tpr_debug(\"pci %04x:%02x:%02x.%d id reading try %d times with interval %d ms to get %08x\\n\",\n\t\t\tpci_domain_nr(bus), bus->number, PCI_SLOT(devfn),\n\t\t\tPCI_FUNC(devfn), count, step, l);\n\n\treturn found;\n}\n\nstatic void pcie_wait_for_presence(struct pci_dev *pdev)\n{\n\tint timeout = 1250;\n\tu16 slot_status;\n\n\tdo {\n\t\tpcie_capability_read_word(pdev, PCI_EXP_SLTSTA, &slot_status);\n\t\tif (slot_status & PCI_EXP_SLTSTA_PDS)\n\t\t\treturn;\n\t\tmsleep(10);\n\t\ttimeout -= 10;\n\t} while (timeout > 0);\n}\n\nint pciehp_check_link_status(struct controller *ctrl)\n{\n\tstruct pci_dev *pdev = ctrl_dev(ctrl);\n\tbool found;\n\tu16 lnk_status;\n\n\tif (!pcie_wait_for_link(pdev, true)) {\n\t\tctrl_info(ctrl, \"Slot(%s): No link\\n\", slot_name(ctrl));\n\t\treturn -1;\n\t}\n\n\tif (ctrl->inband_presence_disabled)\n\t\tpcie_wait_for_presence(pdev);\n\n\tfound = pci_bus_check_dev(ctrl->pcie->port->subordinate,\n\t\t\t\t\tPCI_DEVFN(0, 0));\n\n\t \n\tif (found)\n\t\tatomic_and(~(PCI_EXP_SLTSTA_DLLSC | PCI_EXP_SLTSTA_PDC),\n\t\t\t   &ctrl->pending_events);\n\n\tpcie_capability_read_word(pdev, PCI_EXP_LNKSTA, &lnk_status);\n\tctrl_dbg(ctrl, \"%s: lnk_status = %x\\n\", __func__, lnk_status);\n\tif ((lnk_status & PCI_EXP_LNKSTA_LT) ||\n\t    !(lnk_status & PCI_EXP_LNKSTA_NLW)) {\n\t\tctrl_info(ctrl, \"Slot(%s): Cannot train link: status %#06x\\n\",\n\t\t\t  slot_name(ctrl), lnk_status);\n\t\treturn -1;\n\t}\n\n\tpcie_update_link_speed(ctrl->pcie->port->subordinate, lnk_status);\n\n\tif (!found) {\n\t\tctrl_info(ctrl, \"Slot(%s): No device found\\n\",\n\t\t\t  slot_name(ctrl));\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int __pciehp_link_set(struct controller *ctrl, bool enable)\n{\n\tstruct pci_dev *pdev = ctrl_dev(ctrl);\n\n\tpcie_capability_clear_and_set_word(pdev, PCI_EXP_LNKCTL,\n\t\t\t\t\t   PCI_EXP_LNKCTL_LD,\n\t\t\t\t\t   enable ? 0 : PCI_EXP_LNKCTL_LD);\n\n\treturn 0;\n}\n\nstatic int pciehp_link_enable(struct controller *ctrl)\n{\n\treturn __pciehp_link_set(ctrl, true);\n}\n\nint pciehp_get_raw_indicator_status(struct hotplug_slot *hotplug_slot,\n\t\t\t\t    u8 *status)\n{\n\tstruct controller *ctrl = to_ctrl(hotplug_slot);\n\tstruct pci_dev *pdev = ctrl_dev(ctrl);\n\tu16 slot_ctrl;\n\n\tpci_config_pm_runtime_get(pdev);\n\tpcie_capability_read_word(pdev, PCI_EXP_SLTCTL, &slot_ctrl);\n\tpci_config_pm_runtime_put(pdev);\n\t*status = (slot_ctrl & (PCI_EXP_SLTCTL_AIC | PCI_EXP_SLTCTL_PIC)) >> 6;\n\treturn 0;\n}\n\nint pciehp_get_attention_status(struct hotplug_slot *hotplug_slot, u8 *status)\n{\n\tstruct controller *ctrl = to_ctrl(hotplug_slot);\n\tstruct pci_dev *pdev = ctrl_dev(ctrl);\n\tu16 slot_ctrl;\n\n\tpci_config_pm_runtime_get(pdev);\n\tpcie_capability_read_word(pdev, PCI_EXP_SLTCTL, &slot_ctrl);\n\tpci_config_pm_runtime_put(pdev);\n\tctrl_dbg(ctrl, \"%s: SLOTCTRL %x, value read %x\\n\", __func__,\n\t\t pci_pcie_cap(ctrl->pcie->port) + PCI_EXP_SLTCTL, slot_ctrl);\n\n\tswitch (slot_ctrl & PCI_EXP_SLTCTL_AIC) {\n\tcase PCI_EXP_SLTCTL_ATTN_IND_ON:\n\t\t*status = 1;\t \n\t\tbreak;\n\tcase PCI_EXP_SLTCTL_ATTN_IND_BLINK:\n\t\t*status = 2;\t \n\t\tbreak;\n\tcase PCI_EXP_SLTCTL_ATTN_IND_OFF:\n\t\t*status = 0;\t \n\t\tbreak;\n\tdefault:\n\t\t*status = 0xFF;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nvoid pciehp_get_power_status(struct controller *ctrl, u8 *status)\n{\n\tstruct pci_dev *pdev = ctrl_dev(ctrl);\n\tu16 slot_ctrl;\n\n\tpcie_capability_read_word(pdev, PCI_EXP_SLTCTL, &slot_ctrl);\n\tctrl_dbg(ctrl, \"%s: SLOTCTRL %x value read %x\\n\", __func__,\n\t\t pci_pcie_cap(ctrl->pcie->port) + PCI_EXP_SLTCTL, slot_ctrl);\n\n\tswitch (slot_ctrl & PCI_EXP_SLTCTL_PCC) {\n\tcase PCI_EXP_SLTCTL_PWR_ON:\n\t\t*status = 1;\t \n\t\tbreak;\n\tcase PCI_EXP_SLTCTL_PWR_OFF:\n\t\t*status = 0;\t \n\t\tbreak;\n\tdefault:\n\t\t*status = 0xFF;\n\t\tbreak;\n\t}\n}\n\nvoid pciehp_get_latch_status(struct controller *ctrl, u8 *status)\n{\n\tstruct pci_dev *pdev = ctrl_dev(ctrl);\n\tu16 slot_status;\n\n\tpcie_capability_read_word(pdev, PCI_EXP_SLTSTA, &slot_status);\n\t*status = !!(slot_status & PCI_EXP_SLTSTA_MRLSS);\n}\n\n \nint pciehp_card_present(struct controller *ctrl)\n{\n\tstruct pci_dev *pdev = ctrl_dev(ctrl);\n\tu16 slot_status;\n\tint ret;\n\n\tret = pcie_capability_read_word(pdev, PCI_EXP_SLTSTA, &slot_status);\n\tif (ret == PCIBIOS_DEVICE_NOT_FOUND || PCI_POSSIBLE_ERROR(slot_status))\n\t\treturn -ENODEV;\n\n\treturn !!(slot_status & PCI_EXP_SLTSTA_PDS);\n}\n\n \nint pciehp_card_present_or_link_active(struct controller *ctrl)\n{\n\tint ret;\n\n\tret = pciehp_card_present(ctrl);\n\tif (ret)\n\t\treturn ret;\n\n\treturn pciehp_check_link_active(ctrl);\n}\n\nint pciehp_query_power_fault(struct controller *ctrl)\n{\n\tstruct pci_dev *pdev = ctrl_dev(ctrl);\n\tu16 slot_status;\n\n\tpcie_capability_read_word(pdev, PCI_EXP_SLTSTA, &slot_status);\n\treturn !!(slot_status & PCI_EXP_SLTSTA_PFD);\n}\n\nint pciehp_set_raw_indicator_status(struct hotplug_slot *hotplug_slot,\n\t\t\t\t    u8 status)\n{\n\tstruct controller *ctrl = to_ctrl(hotplug_slot);\n\tstruct pci_dev *pdev = ctrl_dev(ctrl);\n\n\tpci_config_pm_runtime_get(pdev);\n\tpcie_write_cmd_nowait(ctrl, status << 6,\n\t\t\t      PCI_EXP_SLTCTL_AIC | PCI_EXP_SLTCTL_PIC);\n\tpci_config_pm_runtime_put(pdev);\n\treturn 0;\n}\n\n \nvoid pciehp_set_indicators(struct controller *ctrl, int pwr, int attn)\n{\n\tu16 cmd = 0, mask = 0;\n\n\tif (PWR_LED(ctrl) && pwr != INDICATOR_NOOP) {\n\t\tcmd |= (pwr & PCI_EXP_SLTCTL_PIC);\n\t\tmask |= PCI_EXP_SLTCTL_PIC;\n\t}\n\n\tif (ATTN_LED(ctrl) && attn != INDICATOR_NOOP) {\n\t\tcmd |= (attn & PCI_EXP_SLTCTL_AIC);\n\t\tmask |= PCI_EXP_SLTCTL_AIC;\n\t}\n\n\tif (cmd) {\n\t\tpcie_write_cmd_nowait(ctrl, cmd, mask);\n\t\tctrl_dbg(ctrl, \"%s: SLOTCTRL %x write cmd %x\\n\", __func__,\n\t\t\t pci_pcie_cap(ctrl->pcie->port) + PCI_EXP_SLTCTL, cmd);\n\t}\n}\n\nint pciehp_power_on_slot(struct controller *ctrl)\n{\n\tstruct pci_dev *pdev = ctrl_dev(ctrl);\n\tu16 slot_status;\n\tint retval;\n\n\t \n\tpcie_capability_read_word(pdev, PCI_EXP_SLTSTA, &slot_status);\n\tif (slot_status & PCI_EXP_SLTSTA_PFD)\n\t\tpcie_capability_write_word(pdev, PCI_EXP_SLTSTA,\n\t\t\t\t\t   PCI_EXP_SLTSTA_PFD);\n\tctrl->power_fault_detected = 0;\n\n\tpcie_write_cmd(ctrl, PCI_EXP_SLTCTL_PWR_ON, PCI_EXP_SLTCTL_PCC);\n\tctrl_dbg(ctrl, \"%s: SLOTCTRL %x write cmd %x\\n\", __func__,\n\t\t pci_pcie_cap(ctrl->pcie->port) + PCI_EXP_SLTCTL,\n\t\t PCI_EXP_SLTCTL_PWR_ON);\n\n\tretval = pciehp_link_enable(ctrl);\n\tif (retval)\n\t\tctrl_err(ctrl, \"%s: Can not enable the link!\\n\", __func__);\n\n\treturn retval;\n}\n\nvoid pciehp_power_off_slot(struct controller *ctrl)\n{\n\tpcie_write_cmd(ctrl, PCI_EXP_SLTCTL_PWR_OFF, PCI_EXP_SLTCTL_PCC);\n\tctrl_dbg(ctrl, \"%s: SLOTCTRL %x write cmd %x\\n\", __func__,\n\t\t pci_pcie_cap(ctrl->pcie->port) + PCI_EXP_SLTCTL,\n\t\t PCI_EXP_SLTCTL_PWR_OFF);\n}\n\nstatic void pciehp_ignore_dpc_link_change(struct controller *ctrl,\n\t\t\t\t\t  struct pci_dev *pdev, int irq)\n{\n\t \n\tsynchronize_hardirq(irq);\n\tatomic_and(~PCI_EXP_SLTSTA_DLLSC, &ctrl->pending_events);\n\tif (pciehp_poll_mode)\n\t\tpcie_capability_write_word(pdev, PCI_EXP_SLTSTA,\n\t\t\t\t\t   PCI_EXP_SLTSTA_DLLSC);\n\tctrl_info(ctrl, \"Slot(%s): Link Down/Up ignored (recovered by DPC)\\n\",\n\t\t  slot_name(ctrl));\n\n\t \n\tdown_read_nested(&ctrl->reset_lock, ctrl->depth);\n\tif (!pciehp_check_link_active(ctrl))\n\t\tpciehp_request(ctrl, PCI_EXP_SLTSTA_DLLSC);\n\tup_read(&ctrl->reset_lock);\n}\n\nstatic irqreturn_t pciehp_isr(int irq, void *dev_id)\n{\n\tstruct controller *ctrl = (struct controller *)dev_id;\n\tstruct pci_dev *pdev = ctrl_dev(ctrl);\n\tstruct device *parent = pdev->dev.parent;\n\tu16 status, events = 0;\n\n\t \n\tif (pdev->current_state == PCI_D3cold ||\n\t    (!(ctrl->slot_ctrl & PCI_EXP_SLTCTL_HPIE) && !pciehp_poll_mode))\n\t\treturn IRQ_NONE;\n\n\t \n\tif (parent) {\n\t\tpm_runtime_get_noresume(parent);\n\t\tif (!pm_runtime_active(parent)) {\n\t\t\tpm_runtime_put(parent);\n\t\t\tdisable_irq_nosync(irq);\n\t\t\tatomic_or(RERUN_ISR, &ctrl->pending_events);\n\t\t\treturn IRQ_WAKE_THREAD;\n\t\t}\n\t}\n\nread_status:\n\tpcie_capability_read_word(pdev, PCI_EXP_SLTSTA, &status);\n\tif (PCI_POSSIBLE_ERROR(status)) {\n\t\tctrl_info(ctrl, \"%s: no response from device\\n\", __func__);\n\t\tif (parent)\n\t\t\tpm_runtime_put(parent);\n\t\treturn IRQ_NONE;\n\t}\n\n\t \n\tstatus &= PCI_EXP_SLTSTA_ABP | PCI_EXP_SLTSTA_PFD |\n\t\t  PCI_EXP_SLTSTA_PDC | PCI_EXP_SLTSTA_CC |\n\t\t  PCI_EXP_SLTSTA_DLLSC;\n\n\t \n\tif (ctrl->power_fault_detected)\n\t\tstatus &= ~PCI_EXP_SLTSTA_PFD;\n\telse if (status & PCI_EXP_SLTSTA_PFD)\n\t\tctrl->power_fault_detected = true;\n\n\tevents |= status;\n\tif (!events) {\n\t\tif (parent)\n\t\t\tpm_runtime_put(parent);\n\t\treturn IRQ_NONE;\n\t}\n\n\tif (status) {\n\t\tpcie_capability_write_word(pdev, PCI_EXP_SLTSTA, status);\n\n\t\t \n\t\tif (pci_dev_msi_enabled(pdev) && !pciehp_poll_mode)\n\t\t\tgoto read_status;\n\t}\n\n\tctrl_dbg(ctrl, \"pending interrupts %#06x from Slot Status\\n\", events);\n\tif (parent)\n\t\tpm_runtime_put(parent);\n\n\t \n\tif (events & PCI_EXP_SLTSTA_CC) {\n\t\tctrl->cmd_busy = 0;\n\t\tsmp_mb();\n\t\twake_up(&ctrl->queue);\n\n\t\tif (events == PCI_EXP_SLTSTA_CC)\n\t\t\treturn IRQ_HANDLED;\n\n\t\tevents &= ~PCI_EXP_SLTSTA_CC;\n\t}\n\n\tif (pdev->ignore_hotplug) {\n\t\tctrl_dbg(ctrl, \"ignoring hotplug event %#06x\\n\", events);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\t \n\tatomic_or(events, &ctrl->pending_events);\n\treturn IRQ_WAKE_THREAD;\n}\n\nstatic irqreturn_t pciehp_ist(int irq, void *dev_id)\n{\n\tstruct controller *ctrl = (struct controller *)dev_id;\n\tstruct pci_dev *pdev = ctrl_dev(ctrl);\n\tirqreturn_t ret;\n\tu32 events;\n\n\tctrl->ist_running = true;\n\tpci_config_pm_runtime_get(pdev);\n\n\t \n\tif (atomic_fetch_and(~RERUN_ISR, &ctrl->pending_events) & RERUN_ISR) {\n\t\tret = pciehp_isr(irq, dev_id);\n\t\tenable_irq(irq);\n\t\tif (ret != IRQ_WAKE_THREAD)\n\t\t\tgoto out;\n\t}\n\n\tsynchronize_hardirq(irq);\n\tevents = atomic_xchg(&ctrl->pending_events, 0);\n\tif (!events) {\n\t\tret = IRQ_NONE;\n\t\tgoto out;\n\t}\n\n\t \n\tif (events & PCI_EXP_SLTSTA_ABP)\n\t\tpciehp_handle_button_press(ctrl);\n\n\t \n\tif (events & PCI_EXP_SLTSTA_PFD) {\n\t\tctrl_err(ctrl, \"Slot(%s): Power fault\\n\", slot_name(ctrl));\n\t\tpciehp_set_indicators(ctrl, PCI_EXP_SLTCTL_PWR_IND_OFF,\n\t\t\t\t      PCI_EXP_SLTCTL_ATTN_IND_ON);\n\t}\n\n\t \n\tif ((events & PCI_EXP_SLTSTA_DLLSC) && pci_dpc_recovered(pdev) &&\n\t    ctrl->state == ON_STATE) {\n\t\tevents &= ~PCI_EXP_SLTSTA_DLLSC;\n\t\tpciehp_ignore_dpc_link_change(ctrl, pdev, irq);\n\t}\n\n\t \n\tdown_read_nested(&ctrl->reset_lock, ctrl->depth);\n\tif (events & DISABLE_SLOT)\n\t\tpciehp_handle_disable_request(ctrl);\n\telse if (events & (PCI_EXP_SLTSTA_PDC | PCI_EXP_SLTSTA_DLLSC))\n\t\tpciehp_handle_presence_or_link_change(ctrl, events);\n\tup_read(&ctrl->reset_lock);\n\n\tret = IRQ_HANDLED;\nout:\n\tpci_config_pm_runtime_put(pdev);\n\tctrl->ist_running = false;\n\twake_up(&ctrl->requester);\n\treturn ret;\n}\n\nstatic int pciehp_poll(void *data)\n{\n\tstruct controller *ctrl = data;\n\n\tschedule_timeout_idle(10 * HZ);  \n\n\twhile (!kthread_should_stop()) {\n\t\t \n\t\twhile (pciehp_isr(IRQ_NOTCONNECTED, ctrl) == IRQ_WAKE_THREAD ||\n\t\t       atomic_read(&ctrl->pending_events))\n\t\t\tpciehp_ist(IRQ_NOTCONNECTED, ctrl);\n\n\t\tif (pciehp_poll_time <= 0 || pciehp_poll_time > 60)\n\t\t\tpciehp_poll_time = 2;  \n\n\t\tschedule_timeout_idle(pciehp_poll_time * HZ);\n\t}\n\n\treturn 0;\n}\n\nstatic void pcie_enable_notification(struct controller *ctrl)\n{\n\tu16 cmd, mask;\n\n\t \n\n\t \n\tcmd = PCI_EXP_SLTCTL_DLLSCE;\n\tif (ATTN_BUTTN(ctrl))\n\t\tcmd |= PCI_EXP_SLTCTL_ABPE;\n\telse\n\t\tcmd |= PCI_EXP_SLTCTL_PDCE;\n\tif (!pciehp_poll_mode)\n\t\tcmd |= PCI_EXP_SLTCTL_HPIE;\n\tif (!pciehp_poll_mode && !NO_CMD_CMPL(ctrl))\n\t\tcmd |= PCI_EXP_SLTCTL_CCIE;\n\n\tmask = (PCI_EXP_SLTCTL_PDCE | PCI_EXP_SLTCTL_ABPE |\n\t\tPCI_EXP_SLTCTL_PFDE |\n\t\tPCI_EXP_SLTCTL_HPIE | PCI_EXP_SLTCTL_CCIE |\n\t\tPCI_EXP_SLTCTL_DLLSCE);\n\n\tpcie_write_cmd_nowait(ctrl, cmd, mask);\n\tctrl_dbg(ctrl, \"%s: SLOTCTRL %x write cmd %x\\n\", __func__,\n\t\t pci_pcie_cap(ctrl->pcie->port) + PCI_EXP_SLTCTL, cmd);\n}\n\nstatic void pcie_disable_notification(struct controller *ctrl)\n{\n\tu16 mask;\n\n\tmask = (PCI_EXP_SLTCTL_PDCE | PCI_EXP_SLTCTL_ABPE |\n\t\tPCI_EXP_SLTCTL_MRLSCE | PCI_EXP_SLTCTL_PFDE |\n\t\tPCI_EXP_SLTCTL_HPIE | PCI_EXP_SLTCTL_CCIE |\n\t\tPCI_EXP_SLTCTL_DLLSCE);\n\tpcie_write_cmd(ctrl, 0, mask);\n\tctrl_dbg(ctrl, \"%s: SLOTCTRL %x write cmd %x\\n\", __func__,\n\t\t pci_pcie_cap(ctrl->pcie->port) + PCI_EXP_SLTCTL, 0);\n}\n\nvoid pcie_clear_hotplug_events(struct controller *ctrl)\n{\n\tpcie_capability_write_word(ctrl_dev(ctrl), PCI_EXP_SLTSTA,\n\t\t\t\t   PCI_EXP_SLTSTA_PDC | PCI_EXP_SLTSTA_DLLSC);\n}\n\nvoid pcie_enable_interrupt(struct controller *ctrl)\n{\n\tu16 mask;\n\n\tmask = PCI_EXP_SLTCTL_HPIE | PCI_EXP_SLTCTL_DLLSCE;\n\tpcie_write_cmd(ctrl, mask, mask);\n}\n\nvoid pcie_disable_interrupt(struct controller *ctrl)\n{\n\tu16 mask;\n\n\t \n\tmask = PCI_EXP_SLTCTL_HPIE | PCI_EXP_SLTCTL_DLLSCE;\n\tpcie_write_cmd(ctrl, 0, mask);\n}\n\n \nint pciehp_slot_reset(struct pcie_device *dev)\n{\n\tstruct controller *ctrl = get_service_data(dev);\n\n\tif (ctrl->state != ON_STATE)\n\t\treturn 0;\n\n\tpcie_capability_write_word(dev->port, PCI_EXP_SLTSTA,\n\t\t\t\t   PCI_EXP_SLTSTA_DLLSC);\n\n\tif (!pciehp_check_link_active(ctrl))\n\t\tpciehp_request(ctrl, PCI_EXP_SLTSTA_DLLSC);\n\n\treturn 0;\n}\n\n \nint pciehp_reset_slot(struct hotplug_slot *hotplug_slot, bool probe)\n{\n\tstruct controller *ctrl = to_ctrl(hotplug_slot);\n\tstruct pci_dev *pdev = ctrl_dev(ctrl);\n\tu16 stat_mask = 0, ctrl_mask = 0;\n\tint rc;\n\n\tif (probe)\n\t\treturn 0;\n\n\tdown_write_nested(&ctrl->reset_lock, ctrl->depth);\n\n\tif (!ATTN_BUTTN(ctrl)) {\n\t\tctrl_mask |= PCI_EXP_SLTCTL_PDCE;\n\t\tstat_mask |= PCI_EXP_SLTSTA_PDC;\n\t}\n\tctrl_mask |= PCI_EXP_SLTCTL_DLLSCE;\n\tstat_mask |= PCI_EXP_SLTSTA_DLLSC;\n\n\tpcie_write_cmd(ctrl, 0, ctrl_mask);\n\tctrl_dbg(ctrl, \"%s: SLOTCTRL %x write cmd %x\\n\", __func__,\n\t\t pci_pcie_cap(ctrl->pcie->port) + PCI_EXP_SLTCTL, 0);\n\n\trc = pci_bridge_secondary_bus_reset(ctrl->pcie->port);\n\n\tpcie_capability_write_word(pdev, PCI_EXP_SLTSTA, stat_mask);\n\tpcie_write_cmd_nowait(ctrl, ctrl_mask, ctrl_mask);\n\tctrl_dbg(ctrl, \"%s: SLOTCTRL %x write cmd %x\\n\", __func__,\n\t\t pci_pcie_cap(ctrl->pcie->port) + PCI_EXP_SLTCTL, ctrl_mask);\n\n\tup_write(&ctrl->reset_lock);\n\treturn rc;\n}\n\nint pcie_init_notification(struct controller *ctrl)\n{\n\tif (pciehp_request_irq(ctrl))\n\t\treturn -1;\n\tpcie_enable_notification(ctrl);\n\tctrl->notification_enabled = 1;\n\treturn 0;\n}\n\nvoid pcie_shutdown_notification(struct controller *ctrl)\n{\n\tif (ctrl->notification_enabled) {\n\t\tpcie_disable_notification(ctrl);\n\t\tpciehp_free_irq(ctrl);\n\t\tctrl->notification_enabled = 0;\n\t}\n}\n\nstatic inline void dbg_ctrl(struct controller *ctrl)\n{\n\tstruct pci_dev *pdev = ctrl->pcie->port;\n\tu16 reg16;\n\n\tctrl_dbg(ctrl, \"Slot Capabilities      : 0x%08x\\n\", ctrl->slot_cap);\n\tpcie_capability_read_word(pdev, PCI_EXP_SLTSTA, &reg16);\n\tctrl_dbg(ctrl, \"Slot Status            : 0x%04x\\n\", reg16);\n\tpcie_capability_read_word(pdev, PCI_EXP_SLTCTL, &reg16);\n\tctrl_dbg(ctrl, \"Slot Control           : 0x%04x\\n\", reg16);\n}\n\n#define FLAG(x, y)\t(((x) & (y)) ? '+' : '-')\n\nstatic inline int pcie_hotplug_depth(struct pci_dev *dev)\n{\n\tstruct pci_bus *bus = dev->bus;\n\tint depth = 0;\n\n\twhile (bus->parent) {\n\t\tbus = bus->parent;\n\t\tif (bus->self && bus->self->is_hotplug_bridge)\n\t\t\tdepth++;\n\t}\n\n\treturn depth;\n}\n\nstruct controller *pcie_init(struct pcie_device *dev)\n{\n\tstruct controller *ctrl;\n\tu32 slot_cap, slot_cap2;\n\tu8 poweron;\n\tstruct pci_dev *pdev = dev->port;\n\tstruct pci_bus *subordinate = pdev->subordinate;\n\n\tctrl = kzalloc(sizeof(*ctrl), GFP_KERNEL);\n\tif (!ctrl)\n\t\treturn NULL;\n\n\tctrl->pcie = dev;\n\tctrl->depth = pcie_hotplug_depth(dev->port);\n\tpcie_capability_read_dword(pdev, PCI_EXP_SLTCAP, &slot_cap);\n\n\tif (pdev->hotplug_user_indicators)\n\t\tslot_cap &= ~(PCI_EXP_SLTCAP_AIP | PCI_EXP_SLTCAP_PIP);\n\n\t \n\tif (pdev->is_thunderbolt)\n\t\tslot_cap |= PCI_EXP_SLTCAP_NCCS;\n\n\tctrl->slot_cap = slot_cap;\n\tmutex_init(&ctrl->ctrl_lock);\n\tmutex_init(&ctrl->state_lock);\n\tinit_rwsem(&ctrl->reset_lock);\n\tinit_waitqueue_head(&ctrl->requester);\n\tinit_waitqueue_head(&ctrl->queue);\n\tINIT_DELAYED_WORK(&ctrl->button_work, pciehp_queue_pushbutton_work);\n\tdbg_ctrl(ctrl);\n\n\tdown_read(&pci_bus_sem);\n\tctrl->state = list_empty(&subordinate->devices) ? OFF_STATE : ON_STATE;\n\tup_read(&pci_bus_sem);\n\n\tpcie_capability_read_dword(pdev, PCI_EXP_SLTCAP2, &slot_cap2);\n\tif (slot_cap2 & PCI_EXP_SLTCAP2_IBPD) {\n\t\tpcie_write_cmd_nowait(ctrl, PCI_EXP_SLTCTL_IBPD_DISABLE,\n\t\t\t\t      PCI_EXP_SLTCTL_IBPD_DISABLE);\n\t\tctrl->inband_presence_disabled = 1;\n\t}\n\n\tif (dmi_first_match(inband_presence_disabled_dmi_table))\n\t\tctrl->inband_presence_disabled = 1;\n\n\t \n\tpcie_capability_write_word(pdev, PCI_EXP_SLTSTA,\n\t\tPCI_EXP_SLTSTA_ABP | PCI_EXP_SLTSTA_PFD |\n\t\tPCI_EXP_SLTSTA_MRLSC | PCI_EXP_SLTSTA_CC |\n\t\tPCI_EXP_SLTSTA_DLLSC | PCI_EXP_SLTSTA_PDC);\n\n\tctrl_info(ctrl, \"Slot #%d AttnBtn%c PwrCtrl%c MRL%c AttnInd%c PwrInd%c HotPlug%c Surprise%c Interlock%c NoCompl%c IbPresDis%c LLActRep%c%s\\n\",\n\t\t(slot_cap & PCI_EXP_SLTCAP_PSN) >> 19,\n\t\tFLAG(slot_cap, PCI_EXP_SLTCAP_ABP),\n\t\tFLAG(slot_cap, PCI_EXP_SLTCAP_PCP),\n\t\tFLAG(slot_cap, PCI_EXP_SLTCAP_MRLSP),\n\t\tFLAG(slot_cap, PCI_EXP_SLTCAP_AIP),\n\t\tFLAG(slot_cap, PCI_EXP_SLTCAP_PIP),\n\t\tFLAG(slot_cap, PCI_EXP_SLTCAP_HPC),\n\t\tFLAG(slot_cap, PCI_EXP_SLTCAP_HPS),\n\t\tFLAG(slot_cap, PCI_EXP_SLTCAP_EIP),\n\t\tFLAG(slot_cap, PCI_EXP_SLTCAP_NCCS),\n\t\tFLAG(slot_cap2, PCI_EXP_SLTCAP2_IBPD),\n\t\tFLAG(pdev->link_active_reporting, true),\n\t\tpdev->broken_cmd_compl ? \" (with Cmd Compl erratum)\" : \"\");\n\n\t \n\tif (POWER_CTRL(ctrl)) {\n\t\tpciehp_get_power_status(ctrl, &poweron);\n\t\tif (!pciehp_card_present_or_link_active(ctrl) && poweron) {\n\t\t\tpcie_disable_notification(ctrl);\n\t\t\tpciehp_power_off_slot(ctrl);\n\t\t}\n\t}\n\n\treturn ctrl;\n}\n\nvoid pciehp_release_ctrl(struct controller *ctrl)\n{\n\tcancel_delayed_work_sync(&ctrl->button_work);\n\tkfree(ctrl);\n}\n\nstatic void quirk_cmd_compl(struct pci_dev *pdev)\n{\n\tu32 slot_cap;\n\n\tif (pci_is_pcie(pdev)) {\n\t\tpcie_capability_read_dword(pdev, PCI_EXP_SLTCAP, &slot_cap);\n\t\tif (slot_cap & PCI_EXP_SLTCAP_HPC &&\n\t\t    !(slot_cap & PCI_EXP_SLTCAP_NCCS))\n\t\t\tpdev->broken_cmd_compl = 1;\n\t}\n}\nDECLARE_PCI_FIXUP_CLASS_EARLY(PCI_VENDOR_ID_INTEL, PCI_ANY_ID,\n\t\t\t      PCI_CLASS_BRIDGE_PCI, 8, quirk_cmd_compl);\nDECLARE_PCI_FIXUP_CLASS_EARLY(PCI_VENDOR_ID_QCOM, 0x010e,\n\t\t\t      PCI_CLASS_BRIDGE_PCI, 8, quirk_cmd_compl);\nDECLARE_PCI_FIXUP_CLASS_EARLY(PCI_VENDOR_ID_QCOM, 0x0110,\n\t\t\t      PCI_CLASS_BRIDGE_PCI, 8, quirk_cmd_compl);\nDECLARE_PCI_FIXUP_CLASS_EARLY(PCI_VENDOR_ID_QCOM, 0x0400,\n\t\t\t      PCI_CLASS_BRIDGE_PCI, 8, quirk_cmd_compl);\nDECLARE_PCI_FIXUP_CLASS_EARLY(PCI_VENDOR_ID_QCOM, 0x0401,\n\t\t\t      PCI_CLASS_BRIDGE_PCI, 8, quirk_cmd_compl);\nDECLARE_PCI_FIXUP_CLASS_EARLY(PCI_VENDOR_ID_HXT, 0x0401,\n\t\t\t      PCI_CLASS_BRIDGE_PCI, 8, quirk_cmd_compl);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}