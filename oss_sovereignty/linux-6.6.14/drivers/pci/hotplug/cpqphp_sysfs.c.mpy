{
  "module_name": "cpqphp_sysfs.c",
  "hash_id": "574f4994346e2b60ac3cf846bccff342a8d6439b561c1bd9888227f0c686d8fc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/hotplug/cpqphp_sysfs.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/proc_fs.h>\n#include <linux/workqueue.h>\n#include <linux/pci.h>\n#include <linux/pci_hotplug.h>\n#include <linux/mutex.h>\n#include <linux/debugfs.h>\n#include \"cpqphp.h\"\n\nstatic DEFINE_MUTEX(cpqphp_mutex);\nstatic int show_ctrl(struct controller *ctrl, char *buf)\n{\n\tchar *out = buf;\n\tint index;\n\tstruct pci_resource *res;\n\n\tout += sprintf(buf, \"Free resources: memory\\n\");\n\tindex = 11;\n\tres = ctrl->mem_head;\n\twhile (res && index--) {\n\t\tout += sprintf(out, \"start = %8.8x, length = %8.8x\\n\", res->base, res->length);\n\t\tres = res->next;\n\t}\n\tout += sprintf(out, \"Free resources: prefetchable memory\\n\");\n\tindex = 11;\n\tres = ctrl->p_mem_head;\n\twhile (res && index--) {\n\t\tout += sprintf(out, \"start = %8.8x, length = %8.8x\\n\", res->base, res->length);\n\t\tres = res->next;\n\t}\n\tout += sprintf(out, \"Free resources: IO\\n\");\n\tindex = 11;\n\tres = ctrl->io_head;\n\twhile (res && index--) {\n\t\tout += sprintf(out, \"start = %8.8x, length = %8.8x\\n\", res->base, res->length);\n\t\tres = res->next;\n\t}\n\tout += sprintf(out, \"Free resources: bus numbers\\n\");\n\tindex = 11;\n\tres = ctrl->bus_head;\n\twhile (res && index--) {\n\t\tout += sprintf(out, \"start = %8.8x, length = %8.8x\\n\", res->base, res->length);\n\t\tres = res->next;\n\t}\n\n\treturn out - buf;\n}\n\nstatic int show_dev(struct controller *ctrl, char *buf)\n{\n\tchar *out = buf;\n\tint index;\n\tstruct pci_resource *res;\n\tstruct pci_func *new_slot;\n\tstruct slot *slot;\n\n\tslot = ctrl->slot;\n\n\twhile (slot) {\n\t\tnew_slot = cpqhp_slot_find(slot->bus, slot->device, 0);\n\t\tif (!new_slot)\n\t\t\tbreak;\n\t\tout += sprintf(out, \"assigned resources: memory\\n\");\n\t\tindex = 11;\n\t\tres = new_slot->mem_head;\n\t\twhile (res && index--) {\n\t\t\tout += sprintf(out, \"start = %8.8x, length = %8.8x\\n\", res->base, res->length);\n\t\t\tres = res->next;\n\t\t}\n\t\tout += sprintf(out, \"assigned resources: prefetchable memory\\n\");\n\t\tindex = 11;\n\t\tres = new_slot->p_mem_head;\n\t\twhile (res && index--) {\n\t\t\tout += sprintf(out, \"start = %8.8x, length = %8.8x\\n\", res->base, res->length);\n\t\t\tres = res->next;\n\t\t}\n\t\tout += sprintf(out, \"assigned resources: IO\\n\");\n\t\tindex = 11;\n\t\tres = new_slot->io_head;\n\t\twhile (res && index--) {\n\t\t\tout += sprintf(out, \"start = %8.8x, length = %8.8x\\n\", res->base, res->length);\n\t\t\tres = res->next;\n\t\t}\n\t\tout += sprintf(out, \"assigned resources: bus numbers\\n\");\n\t\tindex = 11;\n\t\tres = new_slot->bus_head;\n\t\twhile (res && index--) {\n\t\t\tout += sprintf(out, \"start = %8.8x, length = %8.8x\\n\", res->base, res->length);\n\t\t\tres = res->next;\n\t\t}\n\t\tslot = slot->next;\n\t}\n\n\treturn out - buf;\n}\n\nstatic int spew_debug_info(struct controller *ctrl, char *data, int size)\n{\n\tint used;\n\n\tused = size - show_ctrl(ctrl, data);\n\tused = (size - used) - show_dev(ctrl, &data[used]);\n\treturn used;\n}\n\nstruct ctrl_dbg {\n\tint size;\n\tchar *data;\n\tstruct controller *ctrl;\n};\n\n#define MAX_OUTPUT\t(4*PAGE_SIZE)\n\nstatic int open(struct inode *inode, struct file *file)\n{\n\tstruct controller *ctrl = inode->i_private;\n\tstruct ctrl_dbg *dbg;\n\tint retval = -ENOMEM;\n\n\tmutex_lock(&cpqphp_mutex);\n\tdbg = kmalloc(sizeof(*dbg), GFP_KERNEL);\n\tif (!dbg)\n\t\tgoto exit;\n\tdbg->data = kmalloc(MAX_OUTPUT, GFP_KERNEL);\n\tif (!dbg->data) {\n\t\tkfree(dbg);\n\t\tgoto exit;\n\t}\n\tdbg->size = spew_debug_info(ctrl, dbg->data, MAX_OUTPUT);\n\tfile->private_data = dbg;\n\tretval = 0;\nexit:\n\tmutex_unlock(&cpqphp_mutex);\n\treturn retval;\n}\n\nstatic loff_t lseek(struct file *file, loff_t off, int whence)\n{\n\tstruct ctrl_dbg *dbg = file->private_data;\n\treturn fixed_size_llseek(file, off, whence, dbg->size);\n}\n\nstatic ssize_t read(struct file *file, char __user *buf,\n\t\t    size_t nbytes, loff_t *ppos)\n{\n\tstruct ctrl_dbg *dbg = file->private_data;\n\treturn simple_read_from_buffer(buf, nbytes, ppos, dbg->data, dbg->size);\n}\n\nstatic int release(struct inode *inode, struct file *file)\n{\n\tstruct ctrl_dbg *dbg = file->private_data;\n\n\tkfree(dbg->data);\n\tkfree(dbg);\n\treturn 0;\n}\n\nstatic const struct file_operations debug_ops = {\n\t.owner = THIS_MODULE,\n\t.open = open,\n\t.llseek = lseek,\n\t.read = read,\n\t.release = release,\n};\n\nstatic struct dentry *root;\n\nvoid cpqhp_initialize_debugfs(void)\n{\n\tif (!root)\n\t\troot = debugfs_create_dir(\"cpqhp\", NULL);\n}\n\nvoid cpqhp_shutdown_debugfs(void)\n{\n\tdebugfs_remove(root);\n}\n\nvoid cpqhp_create_debugfs_files(struct controller *ctrl)\n{\n\tctrl->dentry = debugfs_create_file(dev_name(&ctrl->pci_dev->dev),\n\t\t\t\t\t   S_IRUGO, root, ctrl, &debug_ops);\n}\n\nvoid cpqhp_remove_debugfs_files(struct controller *ctrl)\n{\n\tdebugfs_remove(ctrl->dentry);\n\tctrl->dentry = NULL;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}