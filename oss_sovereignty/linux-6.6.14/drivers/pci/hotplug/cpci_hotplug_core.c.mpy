{
  "module_name": "cpci_hotplug_core.c",
  "hash_id": "40f19539e68a623a1d7c919481cc2659baa19a0d7de3b5da7ada4c08c4b8e2fd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/hotplug/cpci_hotplug_core.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/pci_hotplug.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/atomic.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include \"cpci_hotplug.h\"\n\n#define DRIVER_AUTHOR\t\"Scott Murray <scottm@somanetworks.com>\"\n#define DRIVER_DESC\t\"CompactPCI Hot Plug Core\"\n\n#define MY_NAME\t\"cpci_hotplug\"\n\n#define dbg(format, arg...)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\\\n\t\tif (cpci_debug)\t\t\t\t\t\\\n\t\t\tprintk(KERN_DEBUG \"%s: \" format \"\\n\",\t\\\n\t\t\t\tMY_NAME, ## arg);\t\t\\\n\t} while (0)\n#define err(format, arg...) printk(KERN_ERR \"%s: \" format \"\\n\", MY_NAME, ## arg)\n#define info(format, arg...) printk(KERN_INFO \"%s: \" format \"\\n\", MY_NAME, ## arg)\n#define warn(format, arg...) printk(KERN_WARNING \"%s: \" format \"\\n\", MY_NAME, ## arg)\n\n \nstatic DECLARE_RWSEM(list_rwsem);\nstatic LIST_HEAD(slot_list);\nstatic int slots;\nstatic atomic_t extracting;\nint cpci_debug;\nstatic struct cpci_hp_controller *controller;\nstatic struct task_struct *cpci_thread;\nstatic int thread_finished;\n\nstatic int enable_slot(struct hotplug_slot *slot);\nstatic int disable_slot(struct hotplug_slot *slot);\nstatic int set_attention_status(struct hotplug_slot *slot, u8 value);\nstatic int get_power_status(struct hotplug_slot *slot, u8 *value);\nstatic int get_attention_status(struct hotplug_slot *slot, u8 *value);\nstatic int get_adapter_status(struct hotplug_slot *slot, u8 *value);\nstatic int get_latch_status(struct hotplug_slot *slot, u8 *value);\n\nstatic const struct hotplug_slot_ops cpci_hotplug_slot_ops = {\n\t.enable_slot = enable_slot,\n\t.disable_slot = disable_slot,\n\t.set_attention_status = set_attention_status,\n\t.get_power_status = get_power_status,\n\t.get_attention_status = get_attention_status,\n\t.get_adapter_status = get_adapter_status,\n\t.get_latch_status = get_latch_status,\n};\n\nstatic int\nenable_slot(struct hotplug_slot *hotplug_slot)\n{\n\tstruct slot *slot = to_slot(hotplug_slot);\n\tint retval = 0;\n\n\tdbg(\"%s - physical_slot = %s\", __func__, slot_name(slot));\n\n\tif (controller->ops->set_power)\n\t\tretval = controller->ops->set_power(slot, 1);\n\treturn retval;\n}\n\nstatic int\ndisable_slot(struct hotplug_slot *hotplug_slot)\n{\n\tstruct slot *slot = to_slot(hotplug_slot);\n\tint retval = 0;\n\n\tdbg(\"%s - physical_slot = %s\", __func__, slot_name(slot));\n\n\tdown_write(&list_rwsem);\n\n\t \n\tdbg(\"%s - unconfiguring slot %s\", __func__, slot_name(slot));\n\tretval = cpci_unconfigure_slot(slot);\n\tif (retval) {\n\t\terr(\"%s - could not unconfigure slot %s\",\n\t\t    __func__, slot_name(slot));\n\t\tgoto disable_error;\n\t}\n\tdbg(\"%s - finished unconfiguring slot %s\", __func__, slot_name(slot));\n\n\t \n\tif (cpci_clear_ext(slot)) {\n\t\terr(\"%s - could not clear EXT for slot %s\",\n\t\t    __func__, slot_name(slot));\n\t\tretval = -ENODEV;\n\t\tgoto disable_error;\n\t}\n\tcpci_led_on(slot);\n\n\tif (controller->ops->set_power) {\n\t\tretval = controller->ops->set_power(slot, 0);\n\t\tif (retval)\n\t\t\tgoto disable_error;\n\t}\n\n\tslot->adapter_status = 0;\n\n\tif (slot->extracting) {\n\t\tslot->extracting = 0;\n\t\tatomic_dec(&extracting);\n\t}\ndisable_error:\n\tup_write(&list_rwsem);\n\treturn retval;\n}\n\nstatic u8\ncpci_get_power_status(struct slot *slot)\n{\n\tu8 power = 1;\n\n\tif (controller->ops->get_power)\n\t\tpower = controller->ops->get_power(slot);\n\treturn power;\n}\n\nstatic int\nget_power_status(struct hotplug_slot *hotplug_slot, u8 *value)\n{\n\tstruct slot *slot = to_slot(hotplug_slot);\n\n\t*value = cpci_get_power_status(slot);\n\treturn 0;\n}\n\nstatic int\nget_attention_status(struct hotplug_slot *hotplug_slot, u8 *value)\n{\n\tstruct slot *slot = to_slot(hotplug_slot);\n\n\t*value = cpci_get_attention_status(slot);\n\treturn 0;\n}\n\nstatic int\nset_attention_status(struct hotplug_slot *hotplug_slot, u8 status)\n{\n\treturn cpci_set_attention_status(to_slot(hotplug_slot), status);\n}\n\nstatic int\nget_adapter_status(struct hotplug_slot *hotplug_slot, u8 *value)\n{\n\tstruct slot *slot = to_slot(hotplug_slot);\n\n\t*value = slot->adapter_status;\n\treturn 0;\n}\n\nstatic int\nget_latch_status(struct hotplug_slot *hotplug_slot, u8 *value)\n{\n\tstruct slot *slot = to_slot(hotplug_slot);\n\n\t*value = slot->latch_status;\n\treturn 0;\n}\n\nstatic void release_slot(struct slot *slot)\n{\n\tpci_dev_put(slot->dev);\n\tkfree(slot);\n}\n\n#define SLOT_NAME_SIZE\t6\n\nint\ncpci_hp_register_bus(struct pci_bus *bus, u8 first, u8 last)\n{\n\tstruct slot *slot;\n\tchar name[SLOT_NAME_SIZE];\n\tint status;\n\tint i;\n\n\tif (!(controller && bus))\n\t\treturn -ENODEV;\n\n\t \n\tfor (i = first; i <= last; ++i) {\n\t\tslot = kzalloc(sizeof(struct slot), GFP_KERNEL);\n\t\tif (!slot) {\n\t\t\tstatus = -ENOMEM;\n\t\t\tgoto error;\n\t\t}\n\n\t\tslot->bus = bus;\n\t\tslot->number = i;\n\t\tslot->devfn = PCI_DEVFN(i, 0);\n\n\t\tsnprintf(name, SLOT_NAME_SIZE, \"%02x:%02x\", bus->number, i);\n\n\t\tslot->hotplug_slot.ops = &cpci_hotplug_slot_ops;\n\n\t\tdbg(\"registering slot %s\", name);\n\t\tstatus = pci_hp_register(&slot->hotplug_slot, bus, i, name);\n\t\tif (status) {\n\t\t\terr(\"pci_hp_register failed with error %d\", status);\n\t\t\tgoto error_slot;\n\t\t}\n\t\tdbg(\"slot registered with name: %s\", slot_name(slot));\n\n\t\t \n\t\tdown_write(&list_rwsem);\n\t\tlist_add(&slot->slot_list, &slot_list);\n\t\tslots++;\n\t\tup_write(&list_rwsem);\n\t}\n\treturn 0;\nerror_slot:\n\tkfree(slot);\nerror:\n\treturn status;\n}\nEXPORT_SYMBOL_GPL(cpci_hp_register_bus);\n\nint\ncpci_hp_unregister_bus(struct pci_bus *bus)\n{\n\tstruct slot *slot;\n\tstruct slot *tmp;\n\tint status = 0;\n\n\tdown_write(&list_rwsem);\n\tif (!slots) {\n\t\tup_write(&list_rwsem);\n\t\treturn -1;\n\t}\n\tlist_for_each_entry_safe(slot, tmp, &slot_list, slot_list) {\n\t\tif (slot->bus == bus) {\n\t\t\tlist_del(&slot->slot_list);\n\t\t\tslots--;\n\n\t\t\tdbg(\"deregistering slot %s\", slot_name(slot));\n\t\t\tpci_hp_deregister(&slot->hotplug_slot);\n\t\t\trelease_slot(slot);\n\t\t}\n\t}\n\tup_write(&list_rwsem);\n\treturn status;\n}\nEXPORT_SYMBOL_GPL(cpci_hp_unregister_bus);\n\n \nstatic irqreturn_t\ncpci_hp_intr(int irq, void *data)\n{\n\tdbg(\"entered cpci_hp_intr\");\n\n\t \n\tif ((controller->irq_flags & IRQF_SHARED) &&\n\t    !controller->ops->check_irq(controller->dev_id)) {\n\t\tdbg(\"exited cpci_hp_intr, not our interrupt\");\n\t\treturn IRQ_NONE;\n\t}\n\n\t \n\tcontroller->ops->disable_irq();\n\n\t \n\twake_up_process(cpci_thread);\n\treturn IRQ_HANDLED;\n}\n\n \nstatic int\ninit_slots(int clear_ins)\n{\n\tstruct slot *slot;\n\tstruct pci_dev *dev;\n\n\tdbg(\"%s - enter\", __func__);\n\tdown_read(&list_rwsem);\n\tif (!slots) {\n\t\tup_read(&list_rwsem);\n\t\treturn -1;\n\t}\n\tlist_for_each_entry(slot, &slot_list, slot_list) {\n\t\tdbg(\"%s - looking at slot %s\", __func__, slot_name(slot));\n\t\tif (clear_ins && cpci_check_and_clear_ins(slot))\n\t\t\tdbg(\"%s - cleared INS for slot %s\",\n\t\t\t    __func__, slot_name(slot));\n\t\tdev = pci_get_slot(slot->bus, PCI_DEVFN(slot->number, 0));\n\t\tif (dev) {\n\t\t\tslot->adapter_status = 1;\n\t\t\tslot->latch_status = 1;\n\t\t\tslot->dev = dev;\n\t\t}\n\t}\n\tup_read(&list_rwsem);\n\tdbg(\"%s - exit\", __func__);\n\treturn 0;\n}\n\nstatic int\ncheck_slots(void)\n{\n\tstruct slot *slot;\n\tint extracted;\n\tint inserted;\n\tu16 hs_csr;\n\n\tdown_read(&list_rwsem);\n\tif (!slots) {\n\t\tup_read(&list_rwsem);\n\t\terr(\"no slots registered, shutting down\");\n\t\treturn -1;\n\t}\n\textracted = inserted = 0;\n\tlist_for_each_entry(slot, &slot_list, slot_list) {\n\t\tdbg(\"%s - looking at slot %s\", __func__, slot_name(slot));\n\t\tif (cpci_check_and_clear_ins(slot)) {\n\t\t\t \n\t\t\tif (slot->dev) {\n\t\t\t\twarn(\"slot %s already inserted\",\n\t\t\t\t     slot_name(slot));\n\t\t\t\tinserted++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t \n\t\t\tdbg(\"%s - slot %s inserted\", __func__, slot_name(slot));\n\n\t\t\t \n\t\t\ths_csr = cpci_get_hs_csr(slot);\n\t\t\tdbg(\"%s - slot %s HS_CSR (1) = %04x\",\n\t\t\t    __func__, slot_name(slot), hs_csr);\n\n\t\t\t \n\t\t\tdbg(\"%s - configuring slot %s\",\n\t\t\t    __func__, slot_name(slot));\n\t\t\tif (cpci_configure_slot(slot)) {\n\t\t\t\terr(\"%s - could not configure slot %s\",\n\t\t\t\t    __func__, slot_name(slot));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdbg(\"%s - finished configuring slot %s\",\n\t\t\t    __func__, slot_name(slot));\n\n\t\t\t \n\t\t\ths_csr = cpci_get_hs_csr(slot);\n\t\t\tdbg(\"%s - slot %s HS_CSR (2) = %04x\",\n\t\t\t    __func__, slot_name(slot), hs_csr);\n\n\t\t\tslot->latch_status = 1;\n\t\t\tslot->adapter_status = 1;\n\n\t\t\tcpci_led_off(slot);\n\n\t\t\t \n\t\t\ths_csr = cpci_get_hs_csr(slot);\n\t\t\tdbg(\"%s - slot %s HS_CSR (3) = %04x\",\n\t\t\t    __func__, slot_name(slot), hs_csr);\n\n\t\t\tinserted++;\n\t\t} else if (cpci_check_ext(slot)) {\n\t\t\t \n\t\t\tdbg(\"%s - slot %s extracted\",\n\t\t\t    __func__, slot_name(slot));\n\n\t\t\t \n\t\t\ths_csr = cpci_get_hs_csr(slot);\n\t\t\tdbg(\"%s - slot %s HS_CSR = %04x\",\n\t\t\t    __func__, slot_name(slot), hs_csr);\n\n\t\t\tif (!slot->extracting) {\n\t\t\t\tslot->latch_status = 0;\n\t\t\t\tslot->extracting = 1;\n\t\t\t\tatomic_inc(&extracting);\n\t\t\t}\n\t\t\textracted++;\n\t\t} else if (slot->extracting) {\n\t\t\ths_csr = cpci_get_hs_csr(slot);\n\t\t\tif (hs_csr == 0xffff) {\n\t\t\t\t \n\t\t\t\terr(\"card in slot %s was improperly removed\",\n\t\t\t\t    slot_name(slot));\n\t\t\t\tslot->adapter_status = 0;\n\t\t\t\tslot->extracting = 0;\n\t\t\t\tatomic_dec(&extracting);\n\t\t\t}\n\t\t}\n\t}\n\tup_read(&list_rwsem);\n\tdbg(\"inserted=%d, extracted=%d, extracting=%d\",\n\t    inserted, extracted, atomic_read(&extracting));\n\tif (inserted || extracted)\n\t\treturn extracted;\n\telse if (!atomic_read(&extracting)) {\n\t\terr(\"cannot find ENUM# source, shutting down\");\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\n \nstatic int\nevent_thread(void *data)\n{\n\tint rc;\n\n\tdbg(\"%s - event thread started\", __func__);\n\twhile (1) {\n\t\tdbg(\"event thread sleeping\");\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tschedule();\n\t\tif (kthread_should_stop())\n\t\t\tbreak;\n\t\tdo {\n\t\t\trc = check_slots();\n\t\t\tif (rc > 0) {\n\t\t\t\t \n\t\t\t\tmsleep(500);\n\t\t\t} else if (rc < 0) {\n\t\t\t\tdbg(\"%s - error checking slots\", __func__);\n\t\t\t\tthread_finished = 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} while (atomic_read(&extracting) && !kthread_should_stop());\n\t\tif (kthread_should_stop())\n\t\t\tbreak;\n\n\t\t \n\t\tdbg(\"%s - re-enabling irq\", __func__);\n\t\tcontroller->ops->enable_irq();\n\t}\n out:\n\treturn 0;\n}\n\n \nstatic int\npoll_thread(void *data)\n{\n\tint rc;\n\n\twhile (1) {\n\t\tif (kthread_should_stop() || signal_pending(current))\n\t\t\tbreak;\n\t\tif (controller->ops->query_enum()) {\n\t\t\tdo {\n\t\t\t\trc = check_slots();\n\t\t\t\tif (rc > 0) {\n\t\t\t\t\t \n\t\t\t\t\tmsleep(500);\n\t\t\t\t} else if (rc < 0) {\n\t\t\t\t\tdbg(\"%s - error checking slots\", __func__);\n\t\t\t\t\tthread_finished = 1;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t} while (atomic_read(&extracting) && !kthread_should_stop());\n\t\t}\n\t\tmsleep(100);\n\t}\n out:\n\treturn 0;\n}\n\nstatic int\ncpci_start_thread(void)\n{\n\tif (controller->irq)\n\t\tcpci_thread = kthread_run(event_thread, NULL, \"cpci_hp_eventd\");\n\telse\n\t\tcpci_thread = kthread_run(poll_thread, NULL, \"cpci_hp_polld\");\n\tif (IS_ERR(cpci_thread)) {\n\t\terr(\"Can't start up our thread\");\n\t\treturn PTR_ERR(cpci_thread);\n\t}\n\tthread_finished = 0;\n\treturn 0;\n}\n\nstatic void\ncpci_stop_thread(void)\n{\n\tkthread_stop(cpci_thread);\n\tthread_finished = 1;\n}\n\nint\ncpci_hp_register_controller(struct cpci_hp_controller *new_controller)\n{\n\tint status = 0;\n\n\tif (controller)\n\t\treturn -1;\n\tif (!(new_controller && new_controller->ops))\n\t\treturn -EINVAL;\n\tif (new_controller->irq) {\n\t\tif (!(new_controller->ops->enable_irq &&\n\t\t     new_controller->ops->disable_irq))\n\t\t\tstatus = -EINVAL;\n\t\tif (request_irq(new_controller->irq,\n\t\t\t       cpci_hp_intr,\n\t\t\t       new_controller->irq_flags,\n\t\t\t       MY_NAME,\n\t\t\t       new_controller->dev_id)) {\n\t\t\terr(\"Can't get irq %d for the hotplug cPCI controller\",\n\t\t\t    new_controller->irq);\n\t\t\tstatus = -ENODEV;\n\t\t}\n\t\tdbg(\"%s - acquired controller irq %d\",\n\t\t    __func__, new_controller->irq);\n\t}\n\tif (!status)\n\t\tcontroller = new_controller;\n\treturn status;\n}\nEXPORT_SYMBOL_GPL(cpci_hp_register_controller);\n\nstatic void\ncleanup_slots(void)\n{\n\tstruct slot *slot;\n\tstruct slot *tmp;\n\n\t \n\tdown_write(&list_rwsem);\n\tif (!slots)\n\t\tgoto cleanup_null;\n\tlist_for_each_entry_safe(slot, tmp, &slot_list, slot_list) {\n\t\tlist_del(&slot->slot_list);\n\t\tpci_hp_deregister(&slot->hotplug_slot);\n\t\trelease_slot(slot);\n\t}\ncleanup_null:\n\tup_write(&list_rwsem);\n}\n\nint\ncpci_hp_unregister_controller(struct cpci_hp_controller *old_controller)\n{\n\tint status = 0;\n\n\tif (controller) {\n\t\tif (!thread_finished)\n\t\t\tcpci_stop_thread();\n\t\tif (controller->irq)\n\t\t\tfree_irq(controller->irq, controller->dev_id);\n\t\tcontroller = NULL;\n\t\tcleanup_slots();\n\t} else\n\t\tstatus = -ENODEV;\n\treturn status;\n}\nEXPORT_SYMBOL_GPL(cpci_hp_unregister_controller);\n\nint\ncpci_hp_start(void)\n{\n\tstatic int first = 1;\n\tint status;\n\n\tdbg(\"%s - enter\", __func__);\n\tif (!controller)\n\t\treturn -ENODEV;\n\n\tdown_read(&list_rwsem);\n\tif (list_empty(&slot_list)) {\n\t\tup_read(&list_rwsem);\n\t\treturn -ENODEV;\n\t}\n\tup_read(&list_rwsem);\n\n\tstatus = init_slots(first);\n\tif (first)\n\t\tfirst = 0;\n\tif (status)\n\t\treturn status;\n\n\tstatus = cpci_start_thread();\n\tif (status)\n\t\treturn status;\n\tdbg(\"%s - thread started\", __func__);\n\n\tif (controller->irq) {\n\t\t \n\t\tdbg(\"%s - enabling irq\", __func__);\n\t\tcontroller->ops->enable_irq();\n\t}\n\tdbg(\"%s - exit\", __func__);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(cpci_hp_start);\n\nint\ncpci_hp_stop(void)\n{\n\tif (!controller)\n\t\treturn -ENODEV;\n\tif (controller->irq) {\n\t\t \n\t\tdbg(\"%s - disabling irq\", __func__);\n\t\tcontroller->ops->disable_irq();\n\t}\n\tcpci_stop_thread();\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(cpci_hp_stop);\n\nint __init\ncpci_hotplug_init(int debug)\n{\n\tcpci_debug = debug;\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}