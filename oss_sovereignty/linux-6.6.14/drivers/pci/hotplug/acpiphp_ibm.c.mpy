{
  "module_name": "acpiphp_ibm.c",
  "hash_id": "60757d3f9b67705c9dc46b1510d7ccc3fcedc93967adeb66a7e8b85991c9eddc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/hotplug/acpiphp_ibm.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"acpiphp_ibm: \" fmt\n\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/moduleparam.h>\n#include <linux/pci.h>\n#include <linux/uaccess.h>\n\n#include \"acpiphp.h\"\n#include \"../pci.h\"\n\n#define DRIVER_VERSION\t\"1.0.1\"\n#define DRIVER_AUTHOR\t\"Irene Zubarev <zubarev@us.ibm.com>, Vernon Mauery <vernux@us.ibm.com>\"\n#define DRIVER_DESC\t\"ACPI Hot Plug PCI Controller Driver IBM extension\"\n\n\nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(DRIVER_VERSION);\n\n#define FOUND_APCI 0x61504349\n \n#define IBM_HARDWARE_ID1 \"IBM37D0\"\n#define IBM_HARDWARE_ID2 \"IBM37D4\"\n\n#define hpslot_to_sun(A) (to_slot(A)->sun)\n\n \nunion apci_descriptor {\n\tstruct {\n\t\tchar sig[4];\n\t\tu8   len;\n\t} header;\n\tstruct {\n\t\tu8  type;\n\t\tu8  len;\n\t\tu16 slot_id;\n\t\tu8  bus_id;\n\t\tu8  dev_num;\n\t\tu8  slot_num;\n\t\tu8  slot_attr[2];\n\t\tu8  attn;\n\t\tu8  status[2];\n\t\tu8  sun;\n\t\tu8  res[3];\n\t} slot;\n\tstruct {\n\t\tu8 type;\n\t\tu8 len;\n\t} generic;\n};\n\n \nstruct notification {\n\tstruct acpi_device *device;\n\tu8                  event;\n};\n\nstatic int ibm_set_attention_status(struct hotplug_slot *slot, u8 status);\nstatic int ibm_get_attention_status(struct hotplug_slot *slot, u8 *status);\nstatic void ibm_handle_events(acpi_handle handle, u32 event, void *context);\nstatic int ibm_get_table_from_acpi(char **bufp);\nstatic ssize_t ibm_read_apci_table(struct file *filp, struct kobject *kobj,\n\t\t\t\t   struct bin_attribute *bin_attr,\n\t\t\t\t   char *buffer, loff_t pos, size_t size);\nstatic acpi_status __init ibm_find_acpi_device(acpi_handle handle,\n\t\tu32 lvl, void *context, void **rv);\nstatic int __init ibm_acpiphp_init(void);\nstatic void __exit ibm_acpiphp_exit(void);\n\nstatic acpi_handle ibm_acpi_handle;\nstatic struct notification ibm_note;\nstatic struct bin_attribute ibm_apci_table_attr __ro_after_init = {\n\t    .attr = {\n\t\t    .name = \"apci_table\",\n\t\t    .mode = S_IRUGO,\n\t    },\n\t    .read = ibm_read_apci_table,\n\t    .write = NULL,\n};\nstatic struct acpiphp_attention_info ibm_attention_info =\n{\n\t.set_attn = ibm_set_attention_status,\n\t.get_attn = ibm_get_attention_status,\n\t.owner = THIS_MODULE,\n};\n\n \nstatic union apci_descriptor *ibm_slot_from_id(int id)\n{\n\tint ind = 0, size;\n\tunion apci_descriptor *ret = NULL, *des;\n\tchar *table;\n\n\tsize = ibm_get_table_from_acpi(&table);\n\tif (size < 0)\n\t\treturn NULL;\n\tdes = (union apci_descriptor *)table;\n\tif (memcmp(des->header.sig, \"aPCI\", 4) != 0)\n\t\tgoto ibm_slot_done;\n\n\tdes = (union apci_descriptor *)&table[ind += des->header.len];\n\twhile (ind < size && (des->generic.type != 0x82 ||\n\t\t\tdes->slot.slot_num != id)) {\n\t\tdes = (union apci_descriptor *)&table[ind += des->generic.len];\n\t}\n\n\tif (ind < size && des->slot.slot_num == id)\n\t\tret = des;\n\nibm_slot_done:\n\tif (ret) {\n\t\tret = kmalloc(sizeof(union apci_descriptor), GFP_KERNEL);\n\t\tif (ret)\n\t\t\tmemcpy(ret, des, sizeof(union apci_descriptor));\n\t}\n\tkfree(table);\n\treturn ret;\n}\n\n \nstatic int ibm_set_attention_status(struct hotplug_slot *slot, u8 status)\n{\n\tunion acpi_object args[2];\n\tstruct acpi_object_list params = { .pointer = args, .count = 2 };\n\tacpi_status stat;\n\tunsigned long long rc;\n\tunion apci_descriptor *ibm_slot;\n\tint id = hpslot_to_sun(slot);\n\n\tibm_slot = ibm_slot_from_id(id);\n\tif (!ibm_slot) {\n\t\tpr_err(\"APLS null ACPI descriptor for slot %d\\n\", id);\n\t\treturn -ENODEV;\n\t}\n\n\tpr_debug(\"%s: set slot %d (%d) attention status to %d\\n\", __func__,\n\t\t\tibm_slot->slot.slot_num, ibm_slot->slot.slot_id,\n\t\t\t(status ? 1 : 0));\n\n\targs[0].type = ACPI_TYPE_INTEGER;\n\targs[0].integer.value = ibm_slot->slot.slot_id;\n\targs[1].type = ACPI_TYPE_INTEGER;\n\targs[1].integer.value = (status) ? 1 : 0;\n\n\tkfree(ibm_slot);\n\n\tstat = acpi_evaluate_integer(ibm_acpi_handle, \"APLS\", &params, &rc);\n\tif (ACPI_FAILURE(stat)) {\n\t\tpr_err(\"APLS evaluation failed:  0x%08x\\n\", stat);\n\t\treturn -ENODEV;\n\t} else if (!rc) {\n\t\tpr_err(\"APLS method failed:  0x%08llx\\n\", rc);\n\t\treturn -ERANGE;\n\t}\n\treturn 0;\n}\n\n \nstatic int ibm_get_attention_status(struct hotplug_slot *slot, u8 *status)\n{\n\tunion apci_descriptor *ibm_slot;\n\tint id = hpslot_to_sun(slot);\n\n\tibm_slot = ibm_slot_from_id(id);\n\tif (!ibm_slot) {\n\t\tpr_err(\"APLS null ACPI descriptor for slot %d\\n\", id);\n\t\treturn -ENODEV;\n\t}\n\n\tif (ibm_slot->slot.attn & 0xa0 || ibm_slot->slot.status[1] & 0x08)\n\t\t*status = 1;\n\telse\n\t\t*status = 0;\n\n\tpr_debug(\"%s: get slot %d (%d) attention status is %d\\n\", __func__,\n\t\t\tibm_slot->slot.slot_num, ibm_slot->slot.slot_id,\n\t\t\t*status);\n\n\tkfree(ibm_slot);\n\treturn 0;\n}\n\n \nstatic void ibm_handle_events(acpi_handle handle, u32 event, void *context)\n{\n\tu8 detail = event & 0x0f;\n\tu8 subevent = event & 0xf0;\n\tstruct notification *note = context;\n\n\tpr_debug(\"%s: Received notification %02x\\n\", __func__, event);\n\n\tif (subevent == 0x80) {\n\t\tpr_debug(\"%s: generating bus event\\n\", __func__);\n\t\tacpi_bus_generate_netlink_event(note->device->pnp.device_class,\n\t\t\t\t\t\t  dev_name(&note->device->dev),\n\t\t\t\t\t\t  note->event, detail);\n\t} else\n\t\tnote->event = event;\n}\n\n \nstatic int ibm_get_table_from_acpi(char **bufp)\n{\n\tunion acpi_object *package;\n\tstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };\n\tacpi_status status;\n\tchar *lbuf = NULL;\n\tint i, size = -EIO;\n\n\tstatus = acpi_evaluate_object(ibm_acpi_handle, \"APCI\", NULL, &buffer);\n\tif (ACPI_FAILURE(status)) {\n\t\tpr_err(\"%s:  APCI evaluation failed\\n\", __func__);\n\t\treturn -ENODEV;\n\t}\n\n\tpackage = (union acpi_object *) buffer.pointer;\n\tif (!(package) ||\n\t\t\t(package->type != ACPI_TYPE_PACKAGE) ||\n\t\t\t!(package->package.elements)) {\n\t\tpr_err(\"%s:  Invalid APCI object\\n\", __func__);\n\t\tgoto read_table_done;\n\t}\n\n\tfor (size = 0, i = 0; i < package->package.count; i++) {\n\t\tif (package->package.elements[i].type != ACPI_TYPE_BUFFER) {\n\t\t\tpr_err(\"%s:  Invalid APCI element %d\\n\", __func__, i);\n\t\t\tgoto read_table_done;\n\t\t}\n\t\tsize += package->package.elements[i].buffer.length;\n\t}\n\n\tif (bufp == NULL)\n\t\tgoto read_table_done;\n\n\tlbuf = kzalloc(size, GFP_KERNEL);\n\tpr_debug(\"%s: element count: %i, ASL table size: %i, &table = 0x%p\\n\",\n\t\t\t__func__, package->package.count, size, lbuf);\n\n\tif (lbuf) {\n\t\t*bufp = lbuf;\n\t} else {\n\t\tsize = -ENOMEM;\n\t\tgoto read_table_done;\n\t}\n\n\tsize = 0;\n\tfor (i = 0; i < package->package.count; i++) {\n\t\tmemcpy(&lbuf[size],\n\t\t\t\tpackage->package.elements[i].buffer.pointer,\n\t\t\t\tpackage->package.elements[i].buffer.length);\n\t\tsize += package->package.elements[i].buffer.length;\n\t}\n\nread_table_done:\n\tkfree(buffer.pointer);\n\treturn size;\n}\n\n \nstatic ssize_t ibm_read_apci_table(struct file *filp, struct kobject *kobj,\n\t\t\t\t   struct bin_attribute *bin_attr,\n\t\t\t\t   char *buffer, loff_t pos, size_t size)\n{\n\tint bytes_read = -EINVAL;\n\tchar *table = NULL;\n\n\tpr_debug(\"%s: pos = %d, size = %zd\\n\", __func__, (int)pos, size);\n\n\tif (pos == 0) {\n\t\tbytes_read = ibm_get_table_from_acpi(&table);\n\t\tif (bytes_read > 0 && bytes_read <= size)\n\t\t\tmemcpy(buffer, table, bytes_read);\n\t\tkfree(table);\n\t}\n\treturn bytes_read;\n}\n\n \nstatic acpi_status __init ibm_find_acpi_device(acpi_handle handle,\n\t\tu32 lvl, void *context, void **rv)\n{\n\tacpi_handle *phandle = (acpi_handle *)context;\n\tunsigned long long current_status = 0;\n\tacpi_status status;\n\tstruct acpi_device_info *info;\n\tint retval = 0;\n\n\tstatus = acpi_get_object_info(handle, &info);\n\tif (ACPI_FAILURE(status)) {\n\t\tpr_err(\"%s:  Failed to get device information status=0x%x\\n\",\n\t\t\t__func__, status);\n\t\treturn retval;\n\t}\n\n\tacpi_bus_get_status_handle(handle, &current_status);\n\n\tif (current_status && (info->valid & ACPI_VALID_HID) &&\n\t\t\t(!strcmp(info->hardware_id.string, IBM_HARDWARE_ID1) ||\n\t\t\t !strcmp(info->hardware_id.string, IBM_HARDWARE_ID2))) {\n\t\tpr_debug(\"found hardware: %s, handle: %p\\n\",\n\t\t\tinfo->hardware_id.string, handle);\n\t\t*phandle = handle;\n\t\t \n\t\tretval = FOUND_APCI;\n\t}\n\tkfree(info);\n\treturn retval;\n}\n\nstatic int __init ibm_acpiphp_init(void)\n{\n\tint retval = 0;\n\tacpi_status status;\n\tstruct acpi_device *device;\n\tstruct kobject *sysdir = &pci_slots_kset->kobj;\n\n\tpr_debug(\"%s\\n\", __func__);\n\n\tif (acpi_walk_namespace(ACPI_TYPE_DEVICE, ACPI_ROOT_OBJECT,\n\t\t\tACPI_UINT32_MAX, ibm_find_acpi_device, NULL,\n\t\t\t&ibm_acpi_handle, NULL) != FOUND_APCI) {\n\t\tpr_err(\"%s: acpi_walk_namespace failed\\n\", __func__);\n\t\tretval = -ENODEV;\n\t\tgoto init_return;\n\t}\n\tpr_debug(\"%s: found IBM aPCI device\\n\", __func__);\n\tdevice = acpi_fetch_acpi_dev(ibm_acpi_handle);\n\tif (!device) {\n\t\tpr_err(\"%s: acpi_fetch_acpi_dev failed\\n\", __func__);\n\t\tretval = -ENODEV;\n\t\tgoto init_return;\n\t}\n\tif (acpiphp_register_attention(&ibm_attention_info)) {\n\t\tretval = -ENODEV;\n\t\tgoto init_return;\n\t}\n\n\tibm_note.device = device;\n\tstatus = acpi_install_notify_handler(ibm_acpi_handle,\n\t\t\tACPI_DEVICE_NOTIFY, ibm_handle_events,\n\t\t\t&ibm_note);\n\tif (ACPI_FAILURE(status)) {\n\t\tpr_err(\"%s: Failed to register notification handler\\n\",\n\t\t\t\t__func__);\n\t\tretval = -EBUSY;\n\t\tgoto init_cleanup;\n\t}\n\n\tibm_apci_table_attr.size = ibm_get_table_from_acpi(NULL);\n\tretval = sysfs_create_bin_file(sysdir, &ibm_apci_table_attr);\n\n\treturn retval;\n\ninit_cleanup:\n\tacpiphp_unregister_attention(&ibm_attention_info);\ninit_return:\n\treturn retval;\n}\n\nstatic void __exit ibm_acpiphp_exit(void)\n{\n\tacpi_status status;\n\tstruct kobject *sysdir = &pci_slots_kset->kobj;\n\n\tpr_debug(\"%s\\n\", __func__);\n\n\tif (acpiphp_unregister_attention(&ibm_attention_info))\n\t\tpr_err(\"%s: attention info deregistration failed\", __func__);\n\n\tstatus = acpi_remove_notify_handler(\n\t\t\t   ibm_acpi_handle,\n\t\t\t   ACPI_DEVICE_NOTIFY,\n\t\t\t   ibm_handle_events);\n\tif (ACPI_FAILURE(status))\n\t\tpr_err(\"%s: Notification handler removal failed\\n\", __func__);\n\t \n\tsysfs_remove_bin_file(sysdir, &ibm_apci_table_attr);\n}\n\nmodule_init(ibm_acpiphp_init);\nmodule_exit(ibm_acpiphp_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}