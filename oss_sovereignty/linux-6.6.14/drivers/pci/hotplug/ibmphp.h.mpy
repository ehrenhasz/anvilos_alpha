{
  "module_name": "ibmphp.h",
  "hash_id": "6886ddc1fa82c5127fb73302aa18984a6549095e39022747f13d4db4be44f24a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/hotplug/ibmphp.h",
  "human_readable_source": " \n#ifndef __IBMPHP_H\n#define __IBMPHP_H\n\n \n\n#include <linux/pci_hotplug.h>\n\nextern int ibmphp_debug;\n\n#if !defined(MODULE)\n\t#define MY_NAME \"ibmphpd\"\n#else\n\t#define MY_NAME THIS_MODULE->name\n#endif\n#define debug(fmt, arg...) do { if (ibmphp_debug == 1) printk(KERN_DEBUG \"%s: \" fmt, MY_NAME, ## arg); } while (0)\n#define debug_pci(fmt, arg...) do { if (ibmphp_debug) printk(KERN_DEBUG \"%s: \" fmt, MY_NAME, ## arg); } while (0)\n#define err(format, arg...) printk(KERN_ERR \"%s: \" format, MY_NAME, ## arg)\n#define info(format, arg...) printk(KERN_INFO \"%s: \" format, MY_NAME, ## arg)\n#define warn(format, arg...) printk(KERN_WARNING \"%s: \" format, MY_NAME, ## arg)\n\n\n \n\n \n\n#define EBDA_SLOT_133_MAX\t\t0x20\n#define EBDA_SLOT_100_MAX\t\t0x10\n#define EBDA_SLOT_66_MAX\t\t0x02\n#define EBDA_SLOT_PCIX_CAP\t\t0x08\n\n\n \n\n#define EBDA_RSRC_TYPE_MASK\t\t0x03\n#define EBDA_IO_RSRC_TYPE\t\t0x00\n#define EBDA_MEM_RSRC_TYPE\t\t0x01\n#define EBDA_PFM_RSRC_TYPE\t\t0x03\n#define EBDA_RES_RSRC_TYPE\t\t0x02\n\n\n \n\n#define EBDA_IO_RESTRI_MASK\t\t0x0c\n#define EBDA_NO_RESTRI\t\t\t0x00\n#define EBDA_AVO_VGA_ADDR\t\t0x04\n#define EBDA_AVO_VGA_ADDR_AND_ALIA\t0x08\n#define EBDA_AVO_ISA_ADDR\t\t0x0c\n\n\n \n\n#define EBDA_DEV_TYPE_MASK\t\t0x10\n#define EBDA_PCI_DEV\t\t\t0x10\n#define EBDA_NON_PCI_DEV\t\t0x00\n\n\n \n\n#define EBDA_PRI_DEF_MASK\t\t0x20\n#define EBDA_PRI_PCI_BUS_INFO\t\t0x20\n#define EBDA_NORM_DEV_RSRC_INFO\t\t0x00\n\n\n\n\n\n\nstruct rio_table_hdr {\n\tu8 ver_num;\n\tu8 scal_count;\n\tu8 riodev_count;\n\tu16 offset;\n};\n\n\n\n\n\nstruct scal_detail {\n\tu8 node_id;\n\tu32 cbar;\n\tu8 port0_node_connect;\n\tu8 port0_port_connect;\n\tu8 port1_node_connect;\n\tu8 port1_port_connect;\n\tu8 port2_node_connect;\n\tu8 port2_port_connect;\n\tu8 chassis_num;\n\n};\n\n\n\n\n\nstruct rio_detail {\n\tu8 rio_node_id;\n\tu32 bbar;\n\tu8 rio_type;\n\tu8 owner_id;\n\tu8 port0_node_connect;\n\tu8 port0_port_connect;\n\tu8 port1_node_connect;\n\tu8 port1_port_connect;\n\tu8 first_slot_num;\n\tu8 status;\n\tu8 wpindex;\n\tu8 chassis_num;\n\tstruct list_head rio_detail_list;\n};\n\nstruct opt_rio {\n\tu8 rio_type;\n\tu8 chassis_num;\n\tu8 first_slot_num;\n\tu8 middle_num;\n\tstruct list_head opt_rio_list;\n};\n\nstruct opt_rio_lo {\n\tu8 rio_type;\n\tu8 chassis_num;\n\tu8 first_slot_num;\n\tu8 middle_num;\n\tu8 pack_count;\n\tstruct list_head opt_rio_lo_list;\n};\n\n \n\nstruct ebda_hpc_list {\n\tu8 format;\n\tu16 num_ctlrs;\n\tshort phys_addr;\n\n};\n \n\nstruct ebda_hpc_slot {\n\tu8 slot_num;\n\tu32 slot_bus_num;\n\tu8 ctl_index;\n\tu8 slot_cap;\n};\n\nstruct ebda_hpc_bus {\n\tu32 bus_num;\n\tu8 slots_at_33_conv;\n\tu8 slots_at_66_conv;\n\tu8 slots_at_66_pcix;\n\tu8 slots_at_100_pcix;\n\tu8 slots_at_133_pcix;\n};\n\n\n \n\nstruct isa_ctlr_access {\n\tu16 io_start;\n\tu16 io_end;\n};\n\nstruct pci_ctlr_access {\n\tu8 bus;\n\tu8 dev_fun;\n};\n\nstruct wpeg_i2c_ctlr_access {\n\tulong wpegbbar;\n\tu8 i2c_addr;\n};\n\n#define HPC_DEVICE_ID\t\t0x0246\n#define HPC_SUBSYSTEM_ID\t0x0247\n#define HPC_PCI_OFFSET\t\t0x40\n \n\nstruct ebda_rsrc_list {\n\tu8 format;\n\tu16 num_entries;\n\tu16 phys_addr;\n\tstruct ebda_rsrc_list *next;\n};\n\n\n \n\nstruct ebda_pci_rsrc {\n\tu8 rsrc_type;\n\tu8 bus_num;\n\tu8 dev_fun;\n\tu32 start_addr;\n\tu32 end_addr;\n\tu8 marked;\t \n\tstruct list_head ebda_pci_rsrc_list;\n};\n\n\n \n\nstruct bus_info {\n\tu8 slot_min;\n\tu8 slot_max;\n\tu8 slot_count;\n\tu8 busno;\n\tu8 controller_id;\n\tu8 current_speed;\n\tu8 current_bus_mode;\n\tu8 index;\n\tu8 slots_at_33_conv;\n\tu8 slots_at_66_conv;\n\tu8 slots_at_66_pcix;\n\tu8 slots_at_100_pcix;\n\tu8 slots_at_133_pcix;\n\tstruct list_head bus_info_list;\n};\n\n\n \nextern struct list_head ibmphp_ebda_pci_rsrc_head;\nextern struct list_head ibmphp_slot_head;\n \n\nvoid ibmphp_free_ebda_hpc_queue(void);\nint ibmphp_access_ebda(void);\nstruct slot *ibmphp_get_slot_from_physical_num(u8);\nvoid ibmphp_free_bus_info_queue(void);\nvoid ibmphp_free_ebda_pci_rsrc_queue(void);\nstruct bus_info *ibmphp_find_same_bus_num(u32);\nint ibmphp_get_bus_index(u8);\nu16 ibmphp_get_total_controllers(void);\nint ibmphp_register_pci(void);\n\n \n#define MEM\t\t0\n#define IO\t\t1\n#define PFMEM\t\t2\n\n \n#define RESTYPE\t\t0x03\n#define IOMASK\t\t0x00\t \n#define MMASK\t\t0x01\n#define PFMASK\t\t0x03\n#define PCIDEVMASK\t0x10\t \n#define PRIMARYBUSMASK\t0x20\n\n \n#define PCI_VENDOR_ID_NOTVALID\t\t0xFFFF\n#define PCI_HEADER_TYPE_MULTIDEVICE\t0x80\n#define PCI_HEADER_TYPE_MULTIBRIDGE\t0x81\n\n#define LATENCY\t\t0x64\n#define CACHE\t\t64\n#define DEVICEENABLE\t0x015F\t\t \n\n#define IOBRIDGE\t0x1000\t\t \n#define MEMBRIDGE\t0x100000\t \n\n \n#define SCSI_IRQ\t0x09\n#define LAN_IRQ\t\t0x0A\n#define OTHER_IRQ\t0x0B\n\n \n\n \n\n\n \nstruct range_node {\n\tint rangeno;\n\tu32 start;\n\tu32 end;\n\tstruct range_node *next;\n};\n\nstruct bus_node {\n\tu8 busno;\n\tint noIORanges;\n\tstruct range_node *rangeIO;\n\tint noMemRanges;\n\tstruct range_node *rangeMem;\n\tint noPFMemRanges;\n\tstruct range_node *rangePFMem;\n\tint needIOUpdate;\n\tint needMemUpdate;\n\tint needPFMemUpdate;\n\tstruct resource_node *firstIO;\t \n\tstruct resource_node *firstMem;\t \n\tstruct resource_node *firstPFMem;\t \n\tstruct resource_node *firstPFMemFromMem;\t \n\tstruct list_head bus_list;\n};\n\nstruct resource_node {\n\tint rangeno;\n\tu8 busno;\n\tu8 devfunc;\n\tu32 start;\n\tu32 end;\n\tu32 len;\n\tint type;\t\t \n\tu8 fromMem;\t\t \n\tstruct resource_node *next;\n\tstruct resource_node *nextRange;\t \n};\n\nstruct res_needed {\n\tu32 mem;\n\tu32 pfmem;\n\tu32 io;\n\tu8 not_correct;\t\t \n\tint devices[32];\t \n};\n\n \n\nint ibmphp_rsrc_init(void);\nint ibmphp_add_resource(struct resource_node *);\nint ibmphp_remove_resource(struct resource_node *);\nint ibmphp_find_resource(struct bus_node *, u32, struct resource_node **, int);\nint ibmphp_check_resource(struct resource_node *, u8);\nint ibmphp_remove_bus(struct bus_node *, u8);\nvoid ibmphp_free_resources(void);\nint ibmphp_add_pfmem_from_mem(struct resource_node *);\nstruct bus_node *ibmphp_find_res_bus(u8);\nvoid ibmphp_print_test(void);\t \n\nint ibmphp_hpc_readslot(struct slot *, u8, u8 *);\nint ibmphp_hpc_writeslot(struct slot *, u8);\nvoid ibmphp_lock_operations(void);\nvoid ibmphp_unlock_operations(void);\nint ibmphp_hpc_start_poll_thread(void);\nvoid ibmphp_hpc_stop_poll_thread(void);\n\n\n\n\n\n\n\n#define HPC_ERROR\t\t\t0xFF\n\n\n\n\n#define BUS_SPEED\t\t\t0x30\n#define BUS_MODE\t\t\t0x40\n#define BUS_MODE_PCIX\t\t\t0x01\n#define BUS_MODE_PCI\t\t\t0x00\n#define BUS_SPEED_2\t\t\t0x20\n#define BUS_SPEED_1\t\t\t0x10\n#define BUS_SPEED_33\t\t\t0x00\n#define BUS_SPEED_66\t\t\t0x01\n#define BUS_SPEED_100\t\t\t0x02\n#define BUS_SPEED_133\t\t\t0x03\n#define BUS_SPEED_66PCIX\t\t0x04\n#define BUS_SPEED_66UNKNOWN\t\t0x05\n#define BUS_STATUS_AVAILABLE\t\t0x01\n#define BUS_CONTROL_AVAILABLE\t\t0x02\n#define SLOT_LATCH_REGS_SUPPORTED\t0x10\n\n#define PRGM_MODEL_REV_LEVEL\t\t0xF0\n#define MAX_ADAPTER_NONE\t\t0x09\n\n\n\n\n\n\n\n#define HPC_CTLR_ENABLEIRQ\t0x00\t\n#define HPC_CTLR_DISABLEIRQ\t0x01\t\n#define HPC_SLOT_OFF\t\t0x02\t\n#define HPC_SLOT_ON\t\t0x03\t\n#define HPC_SLOT_ATTNOFF\t0x04\t\n#define HPC_SLOT_ATTNON\t\t0x05\t\n#define HPC_CTLR_CLEARIRQ\t0x06\t\n#define HPC_CTLR_RESET\t\t0x07\t\n#define HPC_CTLR_IRQSTEER\t0x08\t\n#define HPC_BUS_33CONVMODE\t0x09\t\n#define HPC_BUS_66CONVMODE\t0x0A\t\n#define HPC_BUS_66PCIXMODE\t0x0B\t\n#define HPC_BUS_100PCIXMODE\t0x0C\t\n#define HPC_BUS_133PCIXMODE\t0x0D\t\n#define HPC_ALLSLOT_OFF\t\t0x11\t\n#define HPC_ALLSLOT_ON\t\t0x12\t\n#define HPC_SLOT_BLINKLED\t0x13\t\n\n\n\n\n#define READ_SLOTSTATUS\t\t0x01\n#define READ_EXTSLOTSTATUS\t0x02\n#define READ_BUSSTATUS\t\t0x03\n#define READ_CTLRSTATUS\t\t0x04\n#define READ_ALLSTAT\t\t0x05\n#define READ_ALLSLOT\t\t0x06\n#define READ_SLOTLATCHLOWREG\t0x07\n#define READ_REVLEVEL\t\t0x08\n#define READ_HPCOPTIONS\t\t0x09\n\n\n\n#define HPC_SLOT_POWER\t\t0x01\n#define HPC_SLOT_CONNECT\t0x02\n#define HPC_SLOT_ATTN\t\t0x04\n#define HPC_SLOT_PRSNT2\t\t0x08\n#define HPC_SLOT_PRSNT1\t\t0x10\n#define HPC_SLOT_PWRGD\t\t0x20\n#define HPC_SLOT_BUS_SPEED\t0x40\n#define HPC_SLOT_LATCH\t\t0x80\n\n\n\n\n#define HPC_SLOT_POWER_OFF\t0x00\n#define HPC_SLOT_POWER_ON\t0x01\n\n\n\n\n#define HPC_SLOT_CONNECTED\t0x00\n#define HPC_SLOT_DISCONNECTED\t0x01\n\n\n\n\n#define HPC_SLOT_ATTN_OFF\t0x00\n#define HPC_SLOT_ATTN_ON\t0x01\n#define HPC_SLOT_ATTN_BLINK\t0x02\n\n\n\n\n#define HPC_SLOT_EMPTY\t\t0x00\n#define HPC_SLOT_PRSNT_7\t0x01\n#define HPC_SLOT_PRSNT_15\t0x02\n#define HPC_SLOT_PRSNT_25\t0x03\n\n\n\n\n#define HPC_SLOT_PWRGD_FAULT_NONE\t0x00\n#define HPC_SLOT_PWRGD_GOOD\t\t0x01\n\n\n\n\n#define HPC_SLOT_BUS_SPEED_OK\t0x00\n#define HPC_SLOT_BUS_SPEED_MISM\t0x01\n\n\n\n\n#define HPC_SLOT_LATCH_OPEN\t0x01\t\n#define HPC_SLOT_LATCH_CLOSED\t0x00\t\n\n\n\n\n\n#define HPC_SLOT_PCIX\t\t0x01\n#define HPC_SLOT_SPEED1\t\t0x02\n#define HPC_SLOT_SPEED2\t\t0x04\n#define HPC_SLOT_BLINK_ATTN\t0x08\n#define HPC_SLOT_RSRVD1\t\t0x10\n#define HPC_SLOT_RSRVD2\t\t0x20\n#define HPC_SLOT_BUS_MODE\t0x40\n#define HPC_SLOT_RSRVD3\t\t0x80\n\n\n\n\n#define HPC_SLOT_PCIX_NO\t0x00\n#define HPC_SLOT_PCIX_YES\t0x01\n\n\n\n\n#define HPC_SLOT_SPEED_33\t0x00\n#define HPC_SLOT_SPEED_66\t0x01\n#define HPC_SLOT_SPEED_133\t0x02\n\n\n\n\n#define HPC_SLOT_ATTN_BLINK_OFF\t0x00\n#define HPC_SLOT_ATTN_BLINK_ON\t0x01\n\n\n\n\n#define HPC_SLOT_BUS_MODE_OK\t0x00\n#define HPC_SLOT_BUS_MODE_MISM\t0x01\n\n\n\n\n#define HPC_CTLR_WORKING\t0x01\n#define HPC_CTLR_FINISHED\t0x02\n#define HPC_CTLR_RESULT0\t0x04\n#define HPC_CTLR_RESULT1\t0x08\n#define HPC_CTLR_RESULE2\t0x10\n#define HPC_CTLR_RESULT3\t0x20\n#define HPC_CTLR_IRQ_ROUTG\t0x40\n#define HPC_CTLR_IRQ_PENDG\t0x80\n\n\n\n\n#define HPC_CTLR_WORKING_NO\t0x00\n#define HPC_CTLR_WORKING_YES\t0x01\n\n\n\n\n#define HPC_CTLR_FINISHED_NO\t0x00\n#define HPC_CTLR_FINISHED_YES\t0x01\n\n\n\n\n#define HPC_CTLR_RESULT_SUCCESS\t0x00\n#define HPC_CTLR_RESULT_FAILED\t0x01\n#define HPC_CTLR_RESULT_RSVD\t0x02\n#define HPC_CTLR_RESULT_NORESP\t0x03\n\n\n\n\n\n#define SLOT_POWER(s)\t((u8) ((s & HPC_SLOT_POWER) \\\n\t? HPC_SLOT_POWER_ON : HPC_SLOT_POWER_OFF))\n\n#define SLOT_CONNECT(s)\t((u8) ((s & HPC_SLOT_CONNECT) \\\n\t? HPC_SLOT_DISCONNECTED : HPC_SLOT_CONNECTED))\n\n#define SLOT_ATTN(s, es)\t((u8) ((es & HPC_SLOT_BLINK_ATTN) \\\n\t? HPC_SLOT_ATTN_BLINK \\\n\t: ((s & HPC_SLOT_ATTN) ? HPC_SLOT_ATTN_ON : HPC_SLOT_ATTN_OFF)))\n\n#define SLOT_PRESENT(s)\t((u8) ((s & HPC_SLOT_PRSNT1) \\\n\t? ((s & HPC_SLOT_PRSNT2) ? HPC_SLOT_EMPTY : HPC_SLOT_PRSNT_15) \\\n\t: ((s & HPC_SLOT_PRSNT2) ? HPC_SLOT_PRSNT_25 : HPC_SLOT_PRSNT_7)))\n\n#define SLOT_PWRGD(s)\t((u8) ((s & HPC_SLOT_PWRGD) \\\n\t? HPC_SLOT_PWRGD_GOOD : HPC_SLOT_PWRGD_FAULT_NONE))\n\n#define SLOT_BUS_SPEED(s)\t((u8) ((s & HPC_SLOT_BUS_SPEED) \\\n\t? HPC_SLOT_BUS_SPEED_MISM : HPC_SLOT_BUS_SPEED_OK))\n\n#define SLOT_LATCH(s)\t((u8) ((s & HPC_SLOT_LATCH) \\\n\t? HPC_SLOT_LATCH_CLOSED : HPC_SLOT_LATCH_OPEN))\n\n#define SLOT_PCIX(es)\t((u8) ((es & HPC_SLOT_PCIX) \\\n\t? HPC_SLOT_PCIX_YES : HPC_SLOT_PCIX_NO))\n\n#define SLOT_SPEED(es)\t((u8) ((es & HPC_SLOT_SPEED2) \\\n\t? ((es & HPC_SLOT_SPEED1) ? HPC_SLOT_SPEED_133   \\\n\t\t\t\t: HPC_SLOT_SPEED_66)   \\\n\t: HPC_SLOT_SPEED_33))\n\n#define SLOT_BUS_MODE(es)\t((u8) ((es & HPC_SLOT_BUS_MODE) \\\n\t? HPC_SLOT_BUS_MODE_MISM : HPC_SLOT_BUS_MODE_OK))\n\n\n\n\n#define CURRENT_BUS_SPEED(s)\t((u8) (s & BUS_SPEED_2) \\\n\t? ((s & BUS_SPEED_1) ? BUS_SPEED_133 : BUS_SPEED_100) \\\n\t: ((s & BUS_SPEED_1) ? BUS_SPEED_66 : BUS_SPEED_33))\n\n#define CURRENT_BUS_MODE(s)\t((u8) (s & BUS_MODE) ? BUS_MODE_PCIX : BUS_MODE_PCI)\n\n#define READ_BUS_STATUS(s)\t((u8) (s->options & BUS_STATUS_AVAILABLE))\n\n#define READ_BUS_MODE(s)\t((s->revision & PRGM_MODEL_REV_LEVEL) >= 0x20)\n\n#define SET_BUS_STATUS(s)\t((u8) (s->options & BUS_CONTROL_AVAILABLE))\n\n#define READ_SLOT_LATCH(s)\t((u8) (s->options & SLOT_LATCH_REGS_SUPPORTED))\n\n\n\n\n#define CTLR_WORKING(c) ((u8) ((c & HPC_CTLR_WORKING) \\\n\t? HPC_CTLR_WORKING_YES : HPC_CTLR_WORKING_NO))\n#define CTLR_FINISHED(c) ((u8) ((c & HPC_CTLR_FINISHED) \\\n\t? HPC_CTLR_FINISHED_YES : HPC_CTLR_FINISHED_NO))\n#define CTLR_RESULT(c) ((u8) ((c & HPC_CTLR_RESULT1)  \\\n\t? ((c & HPC_CTLR_RESULT0) ? HPC_CTLR_RESULT_NORESP \\\n\t\t\t\t: HPC_CTLR_RESULT_RSVD)  \\\n\t: ((c & HPC_CTLR_RESULT0) ? HPC_CTLR_RESULT_FAILED \\\n\t\t\t\t: HPC_CTLR_RESULT_SUCCESS)))\n\n\n#define NEEDTOCHECK_CMDSTATUS(c) ((c == HPC_SLOT_OFF)        || \\\n\t\t\t\t  (c == HPC_SLOT_ON)         || \\\n\t\t\t\t  (c == HPC_CTLR_RESET)      || \\\n\t\t\t\t  (c == HPC_BUS_33CONVMODE)  || \\\n\t\t\t\t  (c == HPC_BUS_66CONVMODE)  || \\\n\t\t\t\t  (c == HPC_BUS_66PCIXMODE)  || \\\n\t\t\t\t  (c == HPC_BUS_100PCIXMODE) || \\\n\t\t\t\t  (c == HPC_BUS_133PCIXMODE) || \\\n\t\t\t\t  (c == HPC_ALLSLOT_OFF)     || \\\n\t\t\t\t  (c == HPC_ALLSLOT_ON))\n\n\n \n\n#define ENABLE\t\t1\n#define DISABLE\t\t0\n\n#define CARD_INFO\t0x07\n#define PCIX133\t\t0x07\n#define PCIX66\t\t0x05\n#define PCI66\t\t0x04\n\nextern struct pci_bus *ibmphp_pci_bus;\n\n \n\nstruct pci_func {\n\tstruct pci_dev *dev;\t \n\tu8 busno;\n\tu8 device;\n\tu8 function;\n\tstruct resource_node *io[6];\n\tstruct resource_node *mem[6];\n\tstruct resource_node *pfmem[6];\n\tstruct pci_func *next;\n\tint devices[32];\t \n\tu8 irq[4];\t\t \n\tu8 bus;\t\t\t \n};\n\nstruct slot {\n\tu8 bus;\n\tu8 device;\n\tu8 number;\n\tu8 real_physical_slot_num;\n\tu32 capabilities;\n\tu8 supported_speed;\n\tu8 supported_bus_mode;\n\tu8 flag;\t\t \n\tu8 ctlr_index;\n\tstruct hotplug_slot hotplug_slot;\n\tstruct controller *ctrl;\n\tstruct pci_func *func;\n\tu8 irq[4];\n\tint bit_mode;\t\t \n\tstruct bus_info *bus_on;\n\tstruct list_head ibm_slot_list;\n\tu8 status;\n\tu8 ext_status;\n\tu8 busstatus;\n};\n\nstruct controller {\n\tstruct ebda_hpc_slot *slots;\n\tstruct ebda_hpc_bus *buses;\n\tstruct pci_dev *ctrl_dev;  \n\tu8 starting_slot_num;\t \n\tu8 ending_slot_num;\n\tu8 revision;\n\tu8 options;\t\t \n\tu8 status;\n\tu8 ctlr_id;\n\tu8 slot_count;\n\tu8 bus_count;\n\tu8 ctlr_relative_id;\n\tu32 irq;\n\tunion {\n\t\tstruct isa_ctlr_access isa_ctlr;\n\t\tstruct pci_ctlr_access pci_ctlr;\n\t\tstruct wpeg_i2c_ctlr_access wpeg_ctlr;\n\t} u;\n\tu8 ctlr_type;\n\tstruct list_head ebda_hpc_list;\n};\n\n \n\nint ibmphp_init_devno(struct slot **);\t \nint ibmphp_do_disable_slot(struct slot *slot_cur);\nint ibmphp_update_slot_info(struct slot *);\t \nint ibmphp_configure_card(struct pci_func *, u8);\nint ibmphp_unconfigure_card(struct slot **, int);\nextern const struct hotplug_slot_ops ibmphp_hotplug_slot_ops;\n\nstatic inline struct slot *to_slot(struct hotplug_slot *hotplug_slot)\n{\n\treturn container_of(hotplug_slot, struct slot, hotplug_slot);\n}\n\n#endif\t\t\t\t\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}