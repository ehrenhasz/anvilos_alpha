{
  "module_name": "cpci_hotplug_pci.c",
  "hash_id": "df39cd956d156af2ac2bf526e5b294f086f8bcdac4dff33c6bddd04b77699955",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/hotplug/cpci_hotplug_pci.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/pci.h>\n#include <linux/pci_hotplug.h>\n#include <linux/proc_fs.h>\n#include \"../pci.h\"\n#include \"cpci_hotplug.h\"\n\n#define MY_NAME\t\"cpci_hotplug\"\n\n#define dbg(format, arg...)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\\\n\t\tif (cpci_debug)\t\t\t\t\t\\\n\t\t\tprintk(KERN_DEBUG \"%s: \" format \"\\n\",\t\\\n\t\t\t\tMY_NAME, ## arg);\t\t\\\n\t} while (0)\n#define err(format, arg...) printk(KERN_ERR \"%s: \" format \"\\n\", MY_NAME, ## arg)\n#define info(format, arg...) printk(KERN_INFO \"%s: \" format \"\\n\", MY_NAME, ## arg)\n#define warn(format, arg...) printk(KERN_WARNING \"%s: \" format \"\\n\", MY_NAME, ## arg)\n\n\nu8 cpci_get_attention_status(struct slot *slot)\n{\n\tint hs_cap;\n\tu16 hs_csr;\n\n\ths_cap = pci_bus_find_capability(slot->bus,\n\t\t\t\t\t slot->devfn,\n\t\t\t\t\t PCI_CAP_ID_CHSWP);\n\tif (!hs_cap)\n\t\treturn 0;\n\n\tif (pci_bus_read_config_word(slot->bus,\n\t\t\t\t     slot->devfn,\n\t\t\t\t     hs_cap + 2,\n\t\t\t\t     &hs_csr))\n\t\treturn 0;\n\n\treturn hs_csr & 0x0008 ? 1 : 0;\n}\n\nint cpci_set_attention_status(struct slot *slot, int status)\n{\n\tint hs_cap;\n\tu16 hs_csr;\n\n\ths_cap = pci_bus_find_capability(slot->bus,\n\t\t\t\t\t slot->devfn,\n\t\t\t\t\t PCI_CAP_ID_CHSWP);\n\tif (!hs_cap)\n\t\treturn 0;\n\tif (pci_bus_read_config_word(slot->bus,\n\t\t\t\t     slot->devfn,\n\t\t\t\t     hs_cap + 2,\n\t\t\t\t     &hs_csr))\n\t\treturn 0;\n\tif (status)\n\t\ths_csr |= HS_CSR_LOO;\n\telse\n\t\ths_csr &= ~HS_CSR_LOO;\n\tif (pci_bus_write_config_word(slot->bus,\n\t\t\t\t      slot->devfn,\n\t\t\t\t      hs_cap + 2,\n\t\t\t\t      hs_csr))\n\t\treturn 0;\n\treturn 1;\n}\n\nu16 cpci_get_hs_csr(struct slot *slot)\n{\n\tint hs_cap;\n\tu16 hs_csr;\n\n\ths_cap = pci_bus_find_capability(slot->bus,\n\t\t\t\t\t slot->devfn,\n\t\t\t\t\t PCI_CAP_ID_CHSWP);\n\tif (!hs_cap)\n\t\treturn 0xFFFF;\n\tif (pci_bus_read_config_word(slot->bus,\n\t\t\t\t     slot->devfn,\n\t\t\t\t     hs_cap + 2,\n\t\t\t\t     &hs_csr))\n\t\treturn 0xFFFF;\n\treturn hs_csr;\n}\n\nint cpci_check_and_clear_ins(struct slot *slot)\n{\n\tint hs_cap;\n\tu16 hs_csr;\n\tint ins = 0;\n\n\ths_cap = pci_bus_find_capability(slot->bus,\n\t\t\t\t\t slot->devfn,\n\t\t\t\t\t PCI_CAP_ID_CHSWP);\n\tif (!hs_cap)\n\t\treturn 0;\n\tif (pci_bus_read_config_word(slot->bus,\n\t\t\t\t     slot->devfn,\n\t\t\t\t     hs_cap + 2,\n\t\t\t\t     &hs_csr))\n\t\treturn 0;\n\tif (hs_csr & HS_CSR_INS) {\n\t\t \n\t\tif (pci_bus_write_config_word(slot->bus,\n\t\t\t\t\t      slot->devfn,\n\t\t\t\t\t      hs_cap + 2,\n\t\t\t\t\t      hs_csr))\n\t\t\tins = 0;\n\t\telse\n\t\t\tins = 1;\n\t}\n\treturn ins;\n}\n\nint cpci_check_ext(struct slot *slot)\n{\n\tint hs_cap;\n\tu16 hs_csr;\n\tint ext = 0;\n\n\ths_cap = pci_bus_find_capability(slot->bus,\n\t\t\t\t\t slot->devfn,\n\t\t\t\t\t PCI_CAP_ID_CHSWP);\n\tif (!hs_cap)\n\t\treturn 0;\n\tif (pci_bus_read_config_word(slot->bus,\n\t\t\t\t     slot->devfn,\n\t\t\t\t     hs_cap + 2,\n\t\t\t\t     &hs_csr))\n\t\treturn 0;\n\tif (hs_csr & HS_CSR_EXT)\n\t\text = 1;\n\treturn ext;\n}\n\nint cpci_clear_ext(struct slot *slot)\n{\n\tint hs_cap;\n\tu16 hs_csr;\n\n\ths_cap = pci_bus_find_capability(slot->bus,\n\t\t\t\t\t slot->devfn,\n\t\t\t\t\t PCI_CAP_ID_CHSWP);\n\tif (!hs_cap)\n\t\treturn -ENODEV;\n\tif (pci_bus_read_config_word(slot->bus,\n\t\t\t\t     slot->devfn,\n\t\t\t\t     hs_cap + 2,\n\t\t\t\t     &hs_csr))\n\t\treturn -ENODEV;\n\tif (hs_csr & HS_CSR_EXT) {\n\t\t \n\t\tif (pci_bus_write_config_word(slot->bus,\n\t\t\t\t\t      slot->devfn,\n\t\t\t\t\t      hs_cap + 2,\n\t\t\t\t\t      hs_csr))\n\t\t\treturn -ENODEV;\n\t}\n\treturn 0;\n}\n\nint cpci_led_on(struct slot *slot)\n{\n\tint hs_cap;\n\tu16 hs_csr;\n\n\ths_cap = pci_bus_find_capability(slot->bus,\n\t\t\t\t\t slot->devfn,\n\t\t\t\t\t PCI_CAP_ID_CHSWP);\n\tif (!hs_cap)\n\t\treturn -ENODEV;\n\tif (pci_bus_read_config_word(slot->bus,\n\t\t\t\t     slot->devfn,\n\t\t\t\t     hs_cap + 2,\n\t\t\t\t     &hs_csr))\n\t\treturn -ENODEV;\n\tif ((hs_csr & HS_CSR_LOO) != HS_CSR_LOO) {\n\t\ths_csr |= HS_CSR_LOO;\n\t\tif (pci_bus_write_config_word(slot->bus,\n\t\t\t\t\t      slot->devfn,\n\t\t\t\t\t      hs_cap + 2,\n\t\t\t\t\t      hs_csr)) {\n\t\t\terr(\"Could not set LOO for slot %s\", slot_name(slot));\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint cpci_led_off(struct slot *slot)\n{\n\tint hs_cap;\n\tu16 hs_csr;\n\n\ths_cap = pci_bus_find_capability(slot->bus,\n\t\t\t\t\t slot->devfn,\n\t\t\t\t\t PCI_CAP_ID_CHSWP);\n\tif (!hs_cap)\n\t\treturn -ENODEV;\n\tif (pci_bus_read_config_word(slot->bus,\n\t\t\t\t     slot->devfn,\n\t\t\t\t     hs_cap + 2,\n\t\t\t\t     &hs_csr))\n\t\treturn -ENODEV;\n\tif (hs_csr & HS_CSR_LOO) {\n\t\ths_csr &= ~HS_CSR_LOO;\n\t\tif (pci_bus_write_config_word(slot->bus,\n\t\t\t\t\t      slot->devfn,\n\t\t\t\t\t      hs_cap + 2,\n\t\t\t\t\t      hs_csr)) {\n\t\t\terr(\"Could not clear LOO for slot %s\", slot_name(slot));\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\treturn 0;\n}\n\n\n \n\nint cpci_configure_slot(struct slot *slot)\n{\n\tstruct pci_dev *dev;\n\tstruct pci_bus *parent;\n\tint ret = 0;\n\n\tdbg(\"%s - enter\", __func__);\n\n\tpci_lock_rescan_remove();\n\n\tif (slot->dev == NULL) {\n\t\tdbg(\"pci_dev null, finding %02x:%02x:%x\",\n\t\t    slot->bus->number, PCI_SLOT(slot->devfn), PCI_FUNC(slot->devfn));\n\t\tslot->dev = pci_get_slot(slot->bus, slot->devfn);\n\t}\n\n\t \n\tif (slot->dev == NULL) {\n\t\tint n;\n\t\tdbg(\"pci_dev still null\");\n\n\t\t \n\t\tn = pci_scan_slot(slot->bus, slot->devfn);\n\t\tdbg(\"%s: pci_scan_slot returned %d\", __func__, n);\n\t\tslot->dev = pci_get_slot(slot->bus, slot->devfn);\n\t\tif (slot->dev == NULL) {\n\t\t\terr(\"Could not find PCI device for slot %02x\", slot->number);\n\t\t\tret = -ENODEV;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tparent = slot->dev->bus;\n\n\tfor_each_pci_bridge(dev, parent) {\n\t\tif (PCI_SLOT(dev->devfn) == PCI_SLOT(slot->devfn))\n\t\t\tpci_hp_add_bridge(dev);\n\t}\n\n\tpci_assign_unassigned_bridge_resources(parent->self);\n\n\tpci_bus_add_devices(parent);\n\n out:\n\tpci_unlock_rescan_remove();\n\tdbg(\"%s - exit\", __func__);\n\treturn ret;\n}\n\nint cpci_unconfigure_slot(struct slot *slot)\n{\n\tstruct pci_dev *dev, *temp;\n\n\tdbg(\"%s - enter\", __func__);\n\tif (!slot->dev) {\n\t\terr(\"No device for slot %02x\\n\", slot->number);\n\t\treturn -ENODEV;\n\t}\n\n\tpci_lock_rescan_remove();\n\n\tlist_for_each_entry_safe(dev, temp, &slot->bus->devices, bus_list) {\n\t\tif (PCI_SLOT(dev->devfn) != PCI_SLOT(slot->devfn))\n\t\t\tcontinue;\n\t\tpci_dev_get(dev);\n\t\tpci_stop_and_remove_bus_device(dev);\n\t\tpci_dev_put(dev);\n\t}\n\tpci_dev_put(slot->dev);\n\tslot->dev = NULL;\n\n\tpci_unlock_rescan_remove();\n\n\tdbg(\"%s - exit\", __func__);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}