{
  "module_name": "acpiphp_glue.c",
  "hash_id": "001686d1715c71c952aebeafac15442fbe39792928daf4a4d21316853280e444",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/hotplug/acpiphp_glue.c",
  "human_readable_source": "\n \n\n \n\n#define pr_fmt(fmt) \"acpiphp_glue: \" fmt\n\n#include <linux/module.h>\n\n#include <linux/kernel.h>\n#include <linux/pci.h>\n#include <linux/pci_hotplug.h>\n#include <linux/pci-acpi.h>\n#include <linux/pm_runtime.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/acpi.h>\n\n#include \"../pci.h\"\n#include \"acpiphp.h\"\n\nstatic LIST_HEAD(bridge_list);\nstatic DEFINE_MUTEX(bridge_mutex);\n\nstatic int acpiphp_hotplug_notify(struct acpi_device *adev, u32 type);\nstatic void acpiphp_post_dock_fixup(struct acpi_device *adev);\nstatic void acpiphp_sanitize_bus(struct pci_bus *bus);\nstatic void hotplug_event(u32 type, struct acpiphp_context *context);\nstatic void free_bridge(struct kref *kref);\n\n \nstatic struct acpiphp_context *acpiphp_init_context(struct acpi_device *adev)\n{\n\tstruct acpiphp_context *context;\n\n\tcontext = kzalloc(sizeof(*context), GFP_KERNEL);\n\tif (!context)\n\t\treturn NULL;\n\n\tcontext->refcount = 1;\n\tcontext->hp.notify = acpiphp_hotplug_notify;\n\tcontext->hp.fixup = acpiphp_post_dock_fixup;\n\tacpi_set_hp_context(adev, &context->hp);\n\treturn context;\n}\n\n \nstatic struct acpiphp_context *acpiphp_get_context(struct acpi_device *adev)\n{\n\tstruct acpiphp_context *context;\n\n\tif (!adev->hp)\n\t\treturn NULL;\n\n\tcontext = to_acpiphp_context(adev->hp);\n\tcontext->refcount++;\n\treturn context;\n}\n\n \nstatic void acpiphp_put_context(struct acpiphp_context *context)\n{\n\tif (--context->refcount)\n\t\treturn;\n\n\tWARN_ON(context->bridge);\n\tcontext->hp.self->hp = NULL;\n\tkfree(context);\n}\n\nstatic inline void get_bridge(struct acpiphp_bridge *bridge)\n{\n\tkref_get(&bridge->ref);\n}\n\nstatic inline void put_bridge(struct acpiphp_bridge *bridge)\n{\n\tkref_put(&bridge->ref, free_bridge);\n}\n\nstatic struct acpiphp_context *acpiphp_grab_context(struct acpi_device *adev)\n{\n\tstruct acpiphp_context *context;\n\n\tacpi_lock_hp_context();\n\n\tcontext = acpiphp_get_context(adev);\n\tif (!context)\n\t\tgoto unlock;\n\n\tif (context->func.parent->is_going_away) {\n\t\tacpiphp_put_context(context);\n\t\tcontext = NULL;\n\t\tgoto unlock;\n\t}\n\n\tget_bridge(context->func.parent);\n\tacpiphp_put_context(context);\n\nunlock:\n\tacpi_unlock_hp_context();\n\treturn context;\n}\n\nstatic void acpiphp_let_context_go(struct acpiphp_context *context)\n{\n\tput_bridge(context->func.parent);\n}\n\nstatic void free_bridge(struct kref *kref)\n{\n\tstruct acpiphp_context *context;\n\tstruct acpiphp_bridge *bridge;\n\tstruct acpiphp_slot *slot, *next;\n\tstruct acpiphp_func *func, *tmp;\n\n\tacpi_lock_hp_context();\n\n\tbridge = container_of(kref, struct acpiphp_bridge, ref);\n\n\tlist_for_each_entry_safe(slot, next, &bridge->slots, node) {\n\t\tlist_for_each_entry_safe(func, tmp, &slot->funcs, sibling)\n\t\t\tacpiphp_put_context(func_to_context(func));\n\n\t\tkfree(slot);\n\t}\n\n\tcontext = bridge->context;\n\t \n\tif (context) {\n\t\t \n\t\tput_bridge(context->func.parent);\n\t\tcontext->bridge = NULL;\n\t\tacpiphp_put_context(context);\n\t}\n\n\tput_device(&bridge->pci_bus->dev);\n\tpci_dev_put(bridge->pci_dev);\n\tkfree(bridge);\n\n\tacpi_unlock_hp_context();\n}\n\n \nstatic void acpiphp_post_dock_fixup(struct acpi_device *adev)\n{\n\tstruct acpiphp_context *context = acpiphp_grab_context(adev);\n\tstruct pci_bus *bus;\n\tu32 buses;\n\n\tif (!context)\n\t\treturn;\n\n\tbus = context->func.slot->bus;\n\tif (!bus->self)\n\t\tgoto out;\n\n\t \n\tpci_read_config_dword(bus->self, PCI_PRIMARY_BUS, &buses);\n\n\tif (((buses >> 8) & 0xff) != bus->busn_res.start) {\n\t\tbuses = (buses & 0xff000000)\n\t\t\t| ((unsigned int)(bus->primary)     <<  0)\n\t\t\t| ((unsigned int)(bus->busn_res.start)   <<  8)\n\t\t\t| ((unsigned int)(bus->busn_res.end) << 16);\n\t\tpci_write_config_dword(bus->self, PCI_PRIMARY_BUS, buses);\n\t}\n\n out:\n\tacpiphp_let_context_go(context);\n}\n\n \nstatic acpi_status acpiphp_add_context(acpi_handle handle, u32 lvl, void *data,\n\t\t\t\t       void **rv)\n{\n\tstruct acpi_device *adev = acpi_fetch_acpi_dev(handle);\n\tstruct acpiphp_bridge *bridge = data;\n\tstruct acpiphp_context *context;\n\tstruct acpiphp_slot *slot;\n\tstruct acpiphp_func *newfunc;\n\tacpi_status status = AE_OK;\n\tunsigned long long adr;\n\tint device, function;\n\tstruct pci_bus *pbus = bridge->pci_bus;\n\tstruct pci_dev *pdev = bridge->pci_dev;\n\tu32 val;\n\n\tif (!adev)\n\t\treturn AE_OK;\n\n\tstatus = acpi_evaluate_integer(handle, \"_ADR\", NULL, &adr);\n\tif (ACPI_FAILURE(status)) {\n\t\tif (status != AE_NOT_FOUND)\n\t\t\tacpi_handle_warn(handle,\n\t\t\t\t\"can't evaluate _ADR (%#x)\\n\", status);\n\t\treturn AE_OK;\n\t}\n\n\tdevice = (adr >> 16) & 0xffff;\n\tfunction = adr & 0xffff;\n\n\tacpi_lock_hp_context();\n\tcontext = acpiphp_init_context(adev);\n\tif (!context) {\n\t\tacpi_unlock_hp_context();\n\t\tacpi_handle_err(handle, \"No hotplug context\\n\");\n\t\treturn AE_NOT_EXIST;\n\t}\n\tnewfunc = &context->func;\n\tnewfunc->function = function;\n\tnewfunc->parent = bridge;\n\tacpi_unlock_hp_context();\n\n\t \n\tif (!is_dock_device(adev) && acpi_has_method(handle, \"_EJ0\"))\n\t\tnewfunc->flags = FUNC_HAS_EJ0;\n\n\tif (acpi_has_method(handle, \"_STA\"))\n\t\tnewfunc->flags |= FUNC_HAS_STA;\n\n\t \n\tlist_for_each_entry(slot, &bridge->slots, node)\n\t\tif (slot->device == device)\n\t\t\tgoto slot_found;\n\n\tslot = kzalloc(sizeof(struct acpiphp_slot), GFP_KERNEL);\n\tif (!slot) {\n\t\tacpi_lock_hp_context();\n\t\tacpiphp_put_context(context);\n\t\tacpi_unlock_hp_context();\n\t\treturn AE_NO_MEMORY;\n\t}\n\n\tslot->bus = bridge->pci_bus;\n\tslot->device = device;\n\tINIT_LIST_HEAD(&slot->funcs);\n\n\tlist_add_tail(&slot->node, &bridge->slots);\n\n\t \n\tif ((acpi_pci_check_ejectable(pbus, handle) || is_dock_device(adev))\n\t    && !(pdev && hotplug_is_native(pdev))) {\n\t\tunsigned long long sun;\n\t\tint retval;\n\n\t\tbridge->nr_slots++;\n\t\tstatus = acpi_evaluate_integer(handle, \"_SUN\", NULL, &sun);\n\t\tif (ACPI_FAILURE(status))\n\t\t\tsun = bridge->nr_slots;\n\n\t\tpr_debug(\"found ACPI PCI Hotplug slot %llu at PCI %04x:%02x:%02x\\n\",\n\t\t    sun, pci_domain_nr(pbus), pbus->number, device);\n\n\t\tretval = acpiphp_register_hotplug_slot(slot, sun);\n\t\tif (retval) {\n\t\t\tslot->slot = NULL;\n\t\t\tbridge->nr_slots--;\n\t\t\tif (retval == -EBUSY)\n\t\t\t\tpr_warn(\"Slot %llu already registered by another hotplug driver\\n\", sun);\n\t\t\telse\n\t\t\t\tpr_warn(\"acpiphp_register_hotplug_slot failed (err code = 0x%x)\\n\", retval);\n\t\t}\n\t\t \n\t}\n\n slot_found:\n\tnewfunc->slot = slot;\n\tlist_add_tail(&newfunc->sibling, &slot->funcs);\n\n\tif (pci_bus_read_dev_vendor_id(pbus, PCI_DEVFN(device, function),\n\t\t\t\t       &val, 60*1000))\n\t\tslot->flags |= SLOT_ENABLED;\n\n\treturn AE_OK;\n}\n\nstatic void cleanup_bridge(struct acpiphp_bridge *bridge)\n{\n\tstruct acpiphp_slot *slot;\n\tstruct acpiphp_func *func;\n\n\tlist_for_each_entry(slot, &bridge->slots, node) {\n\t\tlist_for_each_entry(func, &slot->funcs, sibling) {\n\t\t\tstruct acpi_device *adev = func_to_acpi_device(func);\n\n\t\t\tacpi_lock_hp_context();\n\t\t\tadev->hp->notify = NULL;\n\t\t\tadev->hp->fixup = NULL;\n\t\t\tacpi_unlock_hp_context();\n\t\t}\n\t\tslot->flags |= SLOT_IS_GOING_AWAY;\n\t\tif (slot->slot)\n\t\t\tacpiphp_unregister_hotplug_slot(slot);\n\t}\n\n\tmutex_lock(&bridge_mutex);\n\tlist_del(&bridge->list);\n\tmutex_unlock(&bridge_mutex);\n\n\tacpi_lock_hp_context();\n\tbridge->is_going_away = true;\n\tacpi_unlock_hp_context();\n}\n\n \nstatic unsigned char acpiphp_max_busnr(struct pci_bus *bus)\n{\n\tstruct pci_bus *tmp;\n\tunsigned char max, n;\n\n\t \n\tmax = bus->busn_res.start;\n\n\tlist_for_each_entry(tmp, &bus->children, node) {\n\t\tn = pci_bus_max_busnr(tmp);\n\t\tif (n > max)\n\t\t\tmax = n;\n\t}\n\treturn max;\n}\n\nstatic void acpiphp_set_acpi_region(struct acpiphp_slot *slot)\n{\n\tstruct acpiphp_func *func;\n\n\tlist_for_each_entry(func, &slot->funcs, sibling) {\n\t\t \n\t\tacpi_evaluate_reg(func_to_handle(func),\n\t\t\t\t  ACPI_ADR_SPACE_PCI_CONFIG,\n\t\t\t\t  ACPI_REG_CONNECT);\n\t}\n}\n\nstatic void check_hotplug_bridge(struct acpiphp_slot *slot, struct pci_dev *dev)\n{\n\tstruct acpiphp_func *func;\n\n\t \n\tif (dev->is_hotplug_bridge)\n\t\treturn;\n\n\t \n\tif (pci_is_pcie(dev) && pci_pcie_type(dev) == PCI_EXP_TYPE_UPSTREAM)\n\t\treturn;\n\n\tlist_for_each_entry(func, &slot->funcs, sibling) {\n\t\tif (PCI_FUNC(dev->devfn) == func->function) {\n\t\t\tdev->is_hotplug_bridge = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic int acpiphp_rescan_slot(struct acpiphp_slot *slot)\n{\n\tstruct acpiphp_func *func;\n\n\tlist_for_each_entry(func, &slot->funcs, sibling) {\n\t\tstruct acpi_device *adev = func_to_acpi_device(func);\n\n\t\tacpi_bus_scan(adev->handle);\n\t\tif (acpi_device_enumerated(adev))\n\t\t\tacpi_device_set_power(adev, ACPI_STATE_D0);\n\t}\n\treturn pci_scan_slot(slot->bus, PCI_DEVFN(slot->device, 0));\n}\n\nstatic void acpiphp_native_scan_bridge(struct pci_dev *bridge)\n{\n\tstruct pci_bus *bus = bridge->subordinate;\n\tstruct pci_dev *dev;\n\tint max;\n\n\tif (!bus)\n\t\treturn;\n\n\tmax = bus->busn_res.start;\n\t \n\tfor_each_pci_bridge(dev, bus) {\n\t\tif (!hotplug_is_native(dev))\n\t\t\tmax = pci_scan_bridge(bus, dev, max, 0);\n\t}\n\n\t \n\tfor_each_pci_bridge(dev, bus) {\n\t\tif (hotplug_is_native(dev))\n\t\t\tcontinue;\n\n\t\tmax = pci_scan_bridge(bus, dev, max, 1);\n\t\tif (dev->subordinate) {\n\t\t\tpcibios_resource_survey_bus(dev->subordinate);\n\t\t\tpci_bus_size_bridges(dev->subordinate);\n\t\t\tpci_bus_assign_resources(dev->subordinate);\n\t\t}\n\t}\n}\n\n \nstatic void enable_slot(struct acpiphp_slot *slot, bool bridge)\n{\n\tstruct pci_dev *dev;\n\tstruct pci_bus *bus = slot->bus;\n\tstruct acpiphp_func *func;\n\n\tif (bridge && bus->self && hotplug_is_native(bus->self)) {\n\t\t \n\t\tfor_each_pci_bridge(dev, bus) {\n\t\t\tif (PCI_SLOT(dev->devfn) == slot->device)\n\t\t\t\tacpiphp_native_scan_bridge(dev);\n\t\t}\n\t} else {\n\t\tLIST_HEAD(add_list);\n\t\tint max, pass;\n\n\t\tacpiphp_rescan_slot(slot);\n\t\tmax = acpiphp_max_busnr(bus);\n\t\tfor (pass = 0; pass < 2; pass++) {\n\t\t\tfor_each_pci_bridge(dev, bus) {\n\t\t\t\tif (PCI_SLOT(dev->devfn) != slot->device)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tmax = pci_scan_bridge(bus, dev, max, pass);\n\t\t\t\tif (pass && dev->subordinate) {\n\t\t\t\t\tcheck_hotplug_bridge(slot, dev);\n\t\t\t\t\tpcibios_resource_survey_bus(dev->subordinate);\n\t\t\t\t\t__pci_bus_size_bridges(dev->subordinate,\n\t\t\t\t\t\t\t       &add_list);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t__pci_bus_assign_resources(bus, &add_list, NULL);\n\t}\n\n\tacpiphp_sanitize_bus(bus);\n\tpcie_bus_configure_settings(bus);\n\tacpiphp_set_acpi_region(slot);\n\n\tlist_for_each_entry(dev, &bus->devices, bus_list) {\n\t\t \n\t\tif (!pci_dev_is_added(dev))\n\t\t\tdev->current_state = PCI_D0;\n\t}\n\n\tpci_bus_add_devices(bus);\n\n\tslot->flags |= SLOT_ENABLED;\n\tlist_for_each_entry(func, &slot->funcs, sibling) {\n\t\tdev = pci_get_slot(bus, PCI_DEVFN(slot->device,\n\t\t\t\t\t\t  func->function));\n\t\tif (!dev) {\n\t\t\t \n\t\t\tslot->flags &= ~SLOT_ENABLED;\n\t\t\tcontinue;\n\t\t}\n\t\tpci_dev_put(dev);\n\t}\n}\n\n \nstatic void disable_slot(struct acpiphp_slot *slot)\n{\n\tstruct pci_bus *bus = slot->bus;\n\tstruct pci_dev *dev, *prev;\n\tstruct acpiphp_func *func;\n\n\t \n\tlist_for_each_entry_safe_reverse(dev, prev, &bus->devices, bus_list)\n\t\tif (PCI_SLOT(dev->devfn) == slot->device)\n\t\t\tpci_stop_and_remove_bus_device(dev);\n\n\tlist_for_each_entry(func, &slot->funcs, sibling)\n\t\tacpi_bus_trim(func_to_acpi_device(func));\n\n\tslot->flags &= ~SLOT_ENABLED;\n}\n\nstatic bool slot_no_hotplug(struct acpiphp_slot *slot)\n{\n\tstruct pci_bus *bus = slot->bus;\n\tstruct pci_dev *dev;\n\n\tlist_for_each_entry(dev, &bus->devices, bus_list) {\n\t\tif (PCI_SLOT(dev->devfn) == slot->device && dev->ignore_hotplug)\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\n \nstatic unsigned int get_slot_status(struct acpiphp_slot *slot)\n{\n\tunsigned long long sta = 0;\n\tstruct acpiphp_func *func;\n\tu32 dvid;\n\n\tlist_for_each_entry(func, &slot->funcs, sibling) {\n\t\tif (func->flags & FUNC_HAS_STA) {\n\t\t\tacpi_status status;\n\n\t\t\tstatus = acpi_evaluate_integer(func_to_handle(func),\n\t\t\t\t\t\t       \"_STA\", NULL, &sta);\n\t\t\tif (ACPI_SUCCESS(status) && sta)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tif (pci_bus_read_dev_vendor_id(slot->bus,\n\t\t\t\t\tPCI_DEVFN(slot->device, func->function),\n\t\t\t\t\t&dvid, 0)) {\n\t\t\t\tsta = ACPI_STA_ALL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!sta) {\n\t\t \n\t\tif (pci_bus_read_dev_vendor_id(slot->bus,\n\t\t\t\tPCI_DEVFN(slot->device, 0), &dvid, 0)) {\n\t\t\tsta = ACPI_STA_ALL;\n\t\t}\n\t}\n\n\treturn (unsigned int)sta;\n}\n\nstatic inline bool device_status_valid(unsigned int sta)\n{\n\t \n\tunsigned int mask = ACPI_STA_DEVICE_ENABLED | ACPI_STA_DEVICE_FUNCTIONING;\n\treturn (sta & mask) == mask;\n}\n\n \nstatic void trim_stale_devices(struct pci_dev *dev)\n{\n\tstruct acpi_device *adev = ACPI_COMPANION(&dev->dev);\n\tstruct pci_bus *bus = dev->subordinate;\n\tbool alive = dev->ignore_hotplug;\n\n\tif (adev) {\n\t\tacpi_status status;\n\t\tunsigned long long sta;\n\n\t\tstatus = acpi_evaluate_integer(adev->handle, \"_STA\", NULL, &sta);\n\t\talive = alive || (ACPI_SUCCESS(status) && device_status_valid(sta));\n\t}\n\tif (!alive)\n\t\talive = pci_device_is_present(dev);\n\n\tif (!alive) {\n\t\tpci_dev_set_disconnected(dev, NULL);\n\t\tif (pci_has_subordinate(dev))\n\t\t\tpci_walk_bus(dev->subordinate, pci_dev_set_disconnected,\n\t\t\t\t     NULL);\n\n\t\tpci_stop_and_remove_bus_device(dev);\n\t\tif (adev)\n\t\t\tacpi_bus_trim(adev);\n\t} else if (bus) {\n\t\tstruct pci_dev *child, *tmp;\n\n\t\t \n\t\tpm_runtime_get_sync(&dev->dev);\n\t\tlist_for_each_entry_safe_reverse(child, tmp, &bus->devices, bus_list)\n\t\t\ttrim_stale_devices(child);\n\n\t\tpm_runtime_put(&dev->dev);\n\t}\n}\n\n \nstatic void acpiphp_check_bridge(struct acpiphp_bridge *bridge)\n{\n\tstruct acpiphp_slot *slot;\n\n\t \n\tif (bridge->is_going_away)\n\t\treturn;\n\n\tif (bridge->pci_dev)\n\t\tpm_runtime_get_sync(&bridge->pci_dev->dev);\n\n\tlist_for_each_entry(slot, &bridge->slots, node) {\n\t\tstruct pci_bus *bus = slot->bus;\n\t\tstruct pci_dev *dev, *tmp;\n\n\t\tif (slot_no_hotplug(slot)) {\n\t\t\t;  \n\t\t} else if (device_status_valid(get_slot_status(slot))) {\n\t\t\t \n\t\t\tlist_for_each_entry_safe_reverse(dev, tmp,\n\t\t\t\t\t\t\t &bus->devices, bus_list)\n\t\t\t\tif (PCI_SLOT(dev->devfn) == slot->device)\n\t\t\t\t\ttrim_stale_devices(dev);\n\n\t\t\t \n\t\t\tenable_slot(slot, true);\n\t\t} else {\n\t\t\tdisable_slot(slot);\n\t\t}\n\t}\n\n\tif (bridge->pci_dev)\n\t\tpm_runtime_put(&bridge->pci_dev->dev);\n}\n\n \nstatic void acpiphp_sanitize_bus(struct pci_bus *bus)\n{\n\tstruct pci_dev *dev, *tmp;\n\tint i;\n\tunsigned long type_mask = IORESOURCE_IO | IORESOURCE_MEM;\n\n\tlist_for_each_entry_safe_reverse(dev, tmp, &bus->devices, bus_list) {\n\t\tfor (i = 0; i < PCI_BRIDGE_RESOURCES; i++) {\n\t\t\tstruct resource *res = &dev->resource[i];\n\t\t\tif ((res->flags & type_mask) && !res->start &&\n\t\t\t\t\tres->end) {\n\t\t\t\t \n\t\t\t\tpci_stop_and_remove_bus_device(dev);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\n \n\nvoid acpiphp_check_host_bridge(struct acpi_device *adev)\n{\n\tstruct acpiphp_bridge *bridge = NULL;\n\n\tacpi_lock_hp_context();\n\tif (adev->hp) {\n\t\tbridge = to_acpiphp_root_context(adev->hp)->root_bridge;\n\t\tif (bridge)\n\t\t\tget_bridge(bridge);\n\t}\n\tacpi_unlock_hp_context();\n\tif (bridge) {\n\t\tpci_lock_rescan_remove();\n\n\t\tacpiphp_check_bridge(bridge);\n\n\t\tpci_unlock_rescan_remove();\n\t\tput_bridge(bridge);\n\t}\n}\n\nstatic int acpiphp_disable_and_eject_slot(struct acpiphp_slot *slot);\n\nstatic void hotplug_event(u32 type, struct acpiphp_context *context)\n{\n\tacpi_handle handle = context->hp.self->handle;\n\tstruct acpiphp_func *func = &context->func;\n\tstruct acpiphp_slot *slot = func->slot;\n\tstruct acpiphp_bridge *bridge;\n\n\tacpi_lock_hp_context();\n\tbridge = context->bridge;\n\tif (bridge)\n\t\tget_bridge(bridge);\n\n\tacpi_unlock_hp_context();\n\n\tpci_lock_rescan_remove();\n\n\tswitch (type) {\n\tcase ACPI_NOTIFY_BUS_CHECK:\n\t\t \n\t\tacpi_handle_debug(handle, \"Bus check in %s()\\n\", __func__);\n\t\tif (bridge)\n\t\t\tacpiphp_check_bridge(bridge);\n\t\telse if (!(slot->flags & SLOT_IS_GOING_AWAY))\n\t\t\tenable_slot(slot, false);\n\n\t\tbreak;\n\n\tcase ACPI_NOTIFY_DEVICE_CHECK:\n\t\t \n\t\tacpi_handle_debug(handle, \"Device check in %s()\\n\", __func__);\n\t\tif (bridge) {\n\t\t\tacpiphp_check_bridge(bridge);\n\t\t} else if (!(slot->flags & SLOT_IS_GOING_AWAY)) {\n\t\t\t \n\t\t\tif (acpiphp_rescan_slot(slot))\n\t\t\t\tacpiphp_check_bridge(func->parent);\n\t\t}\n\t\tbreak;\n\n\tcase ACPI_NOTIFY_EJECT_REQUEST:\n\t\t \n\t\tacpi_handle_debug(handle, \"Eject request in %s()\\n\", __func__);\n\t\tacpiphp_disable_and_eject_slot(slot);\n\t\tbreak;\n\t}\n\n\tpci_unlock_rescan_remove();\n\tif (bridge)\n\t\tput_bridge(bridge);\n}\n\nstatic int acpiphp_hotplug_notify(struct acpi_device *adev, u32 type)\n{\n\tstruct acpiphp_context *context;\n\n\tcontext = acpiphp_grab_context(adev);\n\tif (!context)\n\t\treturn -ENODATA;\n\n\thotplug_event(type, context);\n\tacpiphp_let_context_go(context);\n\treturn 0;\n}\n\n \nvoid acpiphp_enumerate_slots(struct pci_bus *bus)\n{\n\tstruct acpiphp_bridge *bridge;\n\tstruct acpi_device *adev;\n\tacpi_handle handle;\n\tacpi_status status;\n\n\tif (acpiphp_disabled)\n\t\treturn;\n\n\tadev = ACPI_COMPANION(bus->bridge);\n\tif (!adev)\n\t\treturn;\n\n\thandle = adev->handle;\n\tbridge = kzalloc(sizeof(struct acpiphp_bridge), GFP_KERNEL);\n\tif (!bridge)\n\t\treturn;\n\n\tINIT_LIST_HEAD(&bridge->slots);\n\tkref_init(&bridge->ref);\n\tbridge->pci_dev = pci_dev_get(bus->self);\n\tbridge->pci_bus = bus;\n\n\t \n\tget_device(&bus->dev);\n\n\tacpi_lock_hp_context();\n\tif (pci_is_root_bus(bridge->pci_bus)) {\n\t\tstruct acpiphp_root_context *root_context;\n\n\t\troot_context = kzalloc(sizeof(*root_context), GFP_KERNEL);\n\t\tif (!root_context)\n\t\t\tgoto err;\n\n\t\troot_context->root_bridge = bridge;\n\t\tacpi_set_hp_context(adev, &root_context->hp);\n\t} else {\n\t\tstruct acpiphp_context *context;\n\n\t\t \n\t\tcontext = acpiphp_get_context(adev);\n\t\tif (!context)\n\t\t\tgoto err;\n\n\t\tbridge->context = context;\n\t\tcontext->bridge = bridge;\n\t\t \n\t\tget_bridge(context->func.parent);\n\t}\n\tacpi_unlock_hp_context();\n\n\t \n\tmutex_lock(&bridge_mutex);\n\tlist_add(&bridge->list, &bridge_list);\n\tmutex_unlock(&bridge_mutex);\n\n\t \n\tstatus = acpi_walk_namespace(ACPI_TYPE_DEVICE, handle, 1,\n\t\t\t\t     acpiphp_add_context, NULL, bridge, NULL);\n\tif (ACPI_FAILURE(status)) {\n\t\tacpi_handle_err(handle, \"failed to register slots\\n\");\n\t\tcleanup_bridge(bridge);\n\t\tput_bridge(bridge);\n\t}\n\treturn;\n\n err:\n\tacpi_unlock_hp_context();\n\tput_device(&bus->dev);\n\tpci_dev_put(bridge->pci_dev);\n\tkfree(bridge);\n}\n\nstatic void acpiphp_drop_bridge(struct acpiphp_bridge *bridge)\n{\n\tif (pci_is_root_bus(bridge->pci_bus)) {\n\t\tstruct acpiphp_root_context *root_context;\n\t\tstruct acpi_device *adev;\n\n\t\tacpi_lock_hp_context();\n\t\tadev = ACPI_COMPANION(bridge->pci_bus->bridge);\n\t\troot_context = to_acpiphp_root_context(adev->hp);\n\t\tadev->hp = NULL;\n\t\tacpi_unlock_hp_context();\n\t\tkfree(root_context);\n\t}\n\tcleanup_bridge(bridge);\n\tput_bridge(bridge);\n}\n\n \nvoid acpiphp_remove_slots(struct pci_bus *bus)\n{\n\tstruct acpiphp_bridge *bridge;\n\n\tif (acpiphp_disabled)\n\t\treturn;\n\n\tmutex_lock(&bridge_mutex);\n\tlist_for_each_entry(bridge, &bridge_list, list)\n\t\tif (bridge->pci_bus == bus) {\n\t\t\tmutex_unlock(&bridge_mutex);\n\t\t\tacpiphp_drop_bridge(bridge);\n\t\t\treturn;\n\t\t}\n\n\tmutex_unlock(&bridge_mutex);\n}\n\n \nint acpiphp_enable_slot(struct acpiphp_slot *slot)\n{\n\tpci_lock_rescan_remove();\n\n\tif (slot->flags & SLOT_IS_GOING_AWAY) {\n\t\tpci_unlock_rescan_remove();\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tif (!(slot->flags & SLOT_ENABLED))\n\t\tenable_slot(slot, false);\n\n\tpci_unlock_rescan_remove();\n\treturn 0;\n}\n\n \nstatic int acpiphp_disable_and_eject_slot(struct acpiphp_slot *slot)\n{\n\tstruct acpiphp_func *func;\n\n\tif (slot->flags & SLOT_IS_GOING_AWAY)\n\t\treturn -ENODEV;\n\n\t \n\tdisable_slot(slot);\n\n\tlist_for_each_entry(func, &slot->funcs, sibling)\n\t\tif (func->flags & FUNC_HAS_EJ0) {\n\t\t\tacpi_handle handle = func_to_handle(func);\n\n\t\t\tif (ACPI_FAILURE(acpi_evaluate_ej0(handle)))\n\t\t\t\tacpi_handle_err(handle, \"_EJ0 failed\\n\");\n\n\t\t\tbreak;\n\t\t}\n\n\treturn 0;\n}\n\nint acpiphp_disable_slot(struct acpiphp_slot *slot)\n{\n\tint ret;\n\n\t \n\tacpi_scan_lock_acquire();\n\tpci_lock_rescan_remove();\n\tret = acpiphp_disable_and_eject_slot(slot);\n\tpci_unlock_rescan_remove();\n\tacpi_scan_lock_release();\n\treturn ret;\n}\n\n \nu8 acpiphp_get_power_status(struct acpiphp_slot *slot)\n{\n\treturn (slot->flags & SLOT_ENABLED);\n}\n\n \nu8 acpiphp_get_latch_status(struct acpiphp_slot *slot)\n{\n\treturn !(get_slot_status(slot) & ACPI_STA_DEVICE_UI);\n}\n\n \nu8 acpiphp_get_adapter_status(struct acpiphp_slot *slot)\n{\n\treturn !!get_slot_status(slot);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}