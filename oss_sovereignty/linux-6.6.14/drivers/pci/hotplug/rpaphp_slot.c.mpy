{
  "module_name": "rpaphp_slot.c",
  "hash_id": "3c3db06998bef7d1817bde51f22e9b50c4febf2defc66b752eec66489b72e831",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/hotplug/rpaphp_slot.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/sysfs.h>\n#include <linux/of.h>\n#include <linux/pci.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n\n#include <asm/rtas.h>\n#include \"rpaphp.h\"\n\n \nvoid dealloc_slot_struct(struct slot *slot)\n{\n\tof_node_put(slot->dn);\n\tkfree(slot->name);\n\tkfree(slot);\n}\n\nstruct slot *alloc_slot_struct(struct device_node *dn,\n\t\tint drc_index, char *drc_name, int power_domain)\n{\n\tstruct slot *slot;\n\n\tslot = kzalloc(sizeof(struct slot), GFP_KERNEL);\n\tif (!slot)\n\t\tgoto error_nomem;\n\tslot->name = kstrdup(drc_name, GFP_KERNEL);\n\tif (!slot->name)\n\t\tgoto error_slot;\n\tslot->dn = of_node_get(dn);\n\tslot->index = drc_index;\n\tslot->power_domain = power_domain;\n\tslot->hotplug_slot.ops = &rpaphp_hotplug_slot_ops;\n\n\treturn (slot);\n\nerror_slot:\n\tkfree(slot);\nerror_nomem:\n\treturn NULL;\n}\n\nstatic int is_registered(struct slot *slot)\n{\n\tstruct slot *tmp_slot;\n\n\tlist_for_each_entry(tmp_slot, &rpaphp_slot_head, rpaphp_slot_list) {\n\t\tif (!strcmp(tmp_slot->name, slot->name))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nint rpaphp_deregister_slot(struct slot *slot)\n{\n\tint retval = 0;\n\tstruct hotplug_slot *php_slot = &slot->hotplug_slot;\n\n\t dbg(\"%s - Entry: deregistering slot=%s\\n\",\n\t\t__func__, slot->name);\n\n\tlist_del(&slot->rpaphp_slot_list);\n\tpci_hp_deregister(php_slot);\n\tdealloc_slot_struct(slot);\n\n\tdbg(\"%s - Exit: rc[%d]\\n\", __func__, retval);\n\treturn retval;\n}\nEXPORT_SYMBOL_GPL(rpaphp_deregister_slot);\n\nint rpaphp_register_slot(struct slot *slot)\n{\n\tstruct hotplug_slot *php_slot = &slot->hotplug_slot;\n\tstruct device_node *child;\n\tu32 my_index;\n\tint retval;\n\tint slotno = -1;\n\n\tdbg(\"%s registering slot:path[%pOF] index[%x], name[%s] pdomain[%x] type[%d]\\n\",\n\t\t__func__, slot->dn, slot->index, slot->name,\n\t\tslot->power_domain, slot->type);\n\n\t \n\tif (is_registered(slot)) {\n\t\terr(\"rpaphp_register_slot: slot[%s] is already registered\\n\", slot->name);\n\t\treturn -EAGAIN;\n\t}\n\n\tfor_each_child_of_node(slot->dn, child) {\n\t\tretval = of_property_read_u32(child, \"ibm,my-drc-index\", &my_index);\n\t\tif (my_index == slot->index) {\n\t\t\tslotno = PCI_SLOT(PCI_DN(child)->devfn);\n\t\t\tof_node_put(child);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tretval = pci_hp_register(php_slot, slot->bus, slotno, slot->name);\n\tif (retval) {\n\t\terr(\"pci_hp_register failed with error %d\\n\", retval);\n\t\treturn retval;\n\t}\n\n\t \n\tlist_add(&slot->rpaphp_slot_list, &rpaphp_slot_head);\n\tinfo(\"Slot [%s] registered\\n\", slot->name);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}