{
  "module_name": "cpqphp_nvram.c",
  "hash_id": "20486c2d8443f76e071099122d7e134c5a5bcea8ab4be16199b34e127b88fc0f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/hotplug/cpqphp_nvram.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/proc_fs.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/pci.h>\n#include <linux/pci_hotplug.h>\n#include <linux/uaccess.h>\n#include \"cpqphp.h\"\n#include \"cpqphp_nvram.h\"\n\n\n#define ROM_INT15_PHY_ADDR\t\t0x0FF859\n#define READ_EV\t\t\t\t0xD8A4\n#define WRITE_EV\t\t\t0xD8A5\n\nstruct register_foo {\n\tunion {\n\t\tunsigned long lword;\t\t \n\t\tunsigned short word;\t\t \n\n\t\tstruct {\n\t\t\tunsigned char low;\t \n\t\t\tunsigned char high;\t \n\t\t} byte;\n\t} data;\n\n\tunsigned char opcode;\t \n\tunsigned long length;\t \n} __attribute__ ((packed));\n\nstruct all_reg {\n\tstruct register_foo eax_reg;\n\tstruct register_foo ebx_reg;\n\tstruct register_foo ecx_reg;\n\tstruct register_foo edx_reg;\n\tstruct register_foo edi_reg;\n\tstruct register_foo esi_reg;\n\tstruct register_foo eflags_reg;\n} __attribute__ ((packed));\n\n\nstruct ev_hrt_header {\n\tu8 Version;\n\tu8 num_of_ctrl;\n\tu8 next;\n};\n\nstruct ev_hrt_ctrl {\n\tu8 bus;\n\tu8 device;\n\tu8 function;\n\tu8 mem_avail;\n\tu8 p_mem_avail;\n\tu8 io_avail;\n\tu8 bus_avail;\n\tu8 next;\n};\n\n\nstatic u8 evbuffer_init;\nstatic u8 evbuffer_length;\nstatic u8 evbuffer[1024];\n\nstatic void __iomem *compaq_int15_entry_point;\n\n \nstatic DEFINE_SPINLOCK(int15_lock);\n\n\n \n\n \n\n\nstatic u32 add_byte(u32 **p_buffer, u8 value, u32 *used, u32 *avail)\n{\n\tu8 **tByte;\n\n\tif ((*used + 1) > *avail)\n\t\treturn(1);\n\n\t*((u8 *)*p_buffer) = value;\n\ttByte = (u8 **)p_buffer;\n\t(*tByte)++;\n\t*used += 1;\n\treturn(0);\n}\n\n\nstatic u32 add_dword(u32 **p_buffer, u32 value, u32 *used, u32 *avail)\n{\n\tif ((*used + 4) > *avail)\n\t\treturn(1);\n\n\t**p_buffer = value;\n\t(*p_buffer)++;\n\t*used += 4;\n\treturn(0);\n}\n\n\n \nstatic int check_for_compaq_ROM(void __iomem *rom_start)\n{\n\tu8 temp1, temp2, temp3, temp4, temp5, temp6;\n\tint result = 0;\n\n\ttemp1 = readb(rom_start + 0xffea + 0);\n\ttemp2 = readb(rom_start + 0xffea + 1);\n\ttemp3 = readb(rom_start + 0xffea + 2);\n\ttemp4 = readb(rom_start + 0xffea + 3);\n\ttemp5 = readb(rom_start + 0xffea + 4);\n\ttemp6 = readb(rom_start + 0xffea + 5);\n\tif ((temp1 == 'C') &&\n\t    (temp2 == 'O') &&\n\t    (temp3 == 'M') &&\n\t    (temp4 == 'P') &&\n\t    (temp5 == 'A') &&\n\t    (temp6 == 'Q')) {\n\t\tresult = 1;\n\t}\n\tdbg(\"%s - returned %d\\n\", __func__, result);\n\treturn result;\n}\n\n\nstatic u32 access_EV(u16 operation, u8 *ev_name, u8 *buffer, u32 *buf_size)\n{\n\tunsigned long flags;\n\tint op = operation;\n\tint ret_val;\n\n\tif (!compaq_int15_entry_point)\n\t\treturn -ENODEV;\n\n\tspin_lock_irqsave(&int15_lock, flags);\n\t__asm__ (\n\t\t\"xorl   %%ebx,%%ebx\\n\" \\\n\t\t\"xorl    %%edx,%%edx\\n\" \\\n\t\t\"pushf\\n\" \\\n\t\t\"push %%cs\\n\" \\\n\t\t\"cli\\n\" \\\n\t\t\"call *%6\\n\"\n\t\t: \"=c\" (*buf_size), \"=a\" (ret_val)\n\t\t: \"a\" (op), \"c\" (*buf_size), \"S\" (ev_name),\n\t\t\"D\" (buffer), \"m\" (compaq_int15_entry_point)\n\t\t: \"%ebx\", \"%edx\");\n\tspin_unlock_irqrestore(&int15_lock, flags);\n\n\treturn((ret_val & 0xFF00) >> 8);\n}\n\n\n \nstatic int load_HRT(void __iomem *rom_start)\n{\n\tu32 available;\n\tu32 temp_dword;\n\tu8 temp_byte = 0xFF;\n\tu32 rc;\n\n\tif (!check_for_compaq_ROM(rom_start))\n\t\treturn -ENODEV;\n\n\tavailable = 1024;\n\n\t \n\ttemp_dword = available;\n\n\trc = access_EV(READ_EV, \"CQTHPS\", evbuffer, &temp_dword);\n\n\tevbuffer_length = temp_dword;\n\n\t \n\ttemp_dword = 1;\n\n\trc = access_EV(WRITE_EV, \"CQTHPS\", &temp_byte, &temp_dword);\n\n\treturn rc;\n}\n\n\n \nstatic u32 store_HRT(void __iomem *rom_start)\n{\n\tu32 *buffer;\n\tu32 *pFill;\n\tu32 usedbytes;\n\tu32 available;\n\tu32 temp_dword;\n\tu32 rc;\n\tu8 loop;\n\tu8 numCtrl = 0;\n\tstruct controller *ctrl;\n\tstruct pci_resource *resNode;\n\tstruct ev_hrt_header *p_EV_header;\n\tstruct ev_hrt_ctrl *p_ev_ctrl;\n\n\tavailable = 1024;\n\n\tif (!check_for_compaq_ROM(rom_start))\n\t\treturn(1);\n\n\tbuffer = (u32 *) evbuffer;\n\n\tif (!buffer)\n\t\treturn(1);\n\n\tpFill = buffer;\n\tusedbytes = 0;\n\n\tp_EV_header = (struct ev_hrt_header *) pFill;\n\n\tctrl = cpqhp_ctrl_list;\n\n\t \n\trc = add_byte(&pFill, 1 + ctrl->push_flag, &usedbytes, &available);\n\tif (rc)\n\t\treturn(rc);\n\n\t \n\trc = add_byte(&pFill, 1, &usedbytes, &available);\n\tif (rc)\n\t\treturn(rc);\n\n\twhile (ctrl) {\n\t\tp_ev_ctrl = (struct ev_hrt_ctrl *) pFill;\n\n\t\tnumCtrl++;\n\n\t\t \n\t\trc = add_byte(&pFill, ctrl->bus, &usedbytes, &available);\n\t\tif (rc)\n\t\t\treturn(rc);\n\n\t\t \n\t\trc = add_byte(&pFill, PCI_SLOT(ctrl->pci_dev->devfn), &usedbytes, &available);\n\t\tif (rc)\n\t\t\treturn(rc);\n\n\t\t \n\t\trc = add_byte(&pFill, PCI_FUNC(ctrl->pci_dev->devfn), &usedbytes, &available);\n\t\tif (rc)\n\t\t\treturn(rc);\n\n\t\t \n\t\trc = add_dword(&pFill, 0, &usedbytes, &available);\n\t\tif (rc)\n\t\t\treturn(rc);\n\n\t\t \n\n\t\tresNode = ctrl->mem_head;\n\n\t\tloop = 0;\n\n\t\twhile (resNode) {\n\t\t\tloop++;\n\n\t\t\t \n\t\t\trc = add_dword(&pFill, resNode->base, &usedbytes, &available);\n\t\t\tif (rc)\n\t\t\t\treturn(rc);\n\n\t\t\t \n\t\t\trc = add_dword(&pFill, resNode->length, &usedbytes, &available);\n\t\t\tif (rc)\n\t\t\t\treturn(rc);\n\n\t\t\tresNode = resNode->next;\n\t\t}\n\n\t\t \n\t\tp_ev_ctrl->mem_avail = loop;\n\n\t\t \n\n\t\tresNode = ctrl->p_mem_head;\n\n\t\tloop = 0;\n\n\t\twhile (resNode) {\n\t\t\tloop++;\n\n\t\t\t \n\t\t\trc = add_dword(&pFill, resNode->base, &usedbytes, &available);\n\t\t\tif (rc)\n\t\t\t\treturn(rc);\n\n\t\t\t \n\t\t\trc = add_dword(&pFill, resNode->length, &usedbytes, &available);\n\t\t\tif (rc)\n\t\t\t\treturn(rc);\n\n\t\t\tresNode = resNode->next;\n\t\t}\n\n\t\t \n\t\tp_ev_ctrl->p_mem_avail = loop;\n\n\t\t \n\n\t\tresNode = ctrl->io_head;\n\n\t\tloop = 0;\n\n\t\twhile (resNode) {\n\t\t\tloop++;\n\n\t\t\t \n\t\t\trc = add_dword(&pFill, resNode->base, &usedbytes, &available);\n\t\t\tif (rc)\n\t\t\t\treturn(rc);\n\n\t\t\t \n\t\t\trc = add_dword(&pFill, resNode->length, &usedbytes, &available);\n\t\t\tif (rc)\n\t\t\t\treturn(rc);\n\n\t\t\tresNode = resNode->next;\n\t\t}\n\n\t\t \n\t\tp_ev_ctrl->io_avail = loop;\n\n\t\t \n\n\t\tresNode = ctrl->bus_head;\n\n\t\tloop = 0;\n\n\t\twhile (resNode) {\n\t\t\tloop++;\n\n\t\t\t \n\t\t\trc = add_dword(&pFill, resNode->base, &usedbytes, &available);\n\t\t\tif (rc)\n\t\t\t\treturn(rc);\n\n\t\t\t \n\t\t\trc = add_dword(&pFill, resNode->length, &usedbytes, &available);\n\t\t\tif (rc)\n\t\t\t\treturn(rc);\n\n\t\t\tresNode = resNode->next;\n\t\t}\n\n\t\t \n\t\tp_ev_ctrl->bus_avail = loop;\n\n\t\tctrl = ctrl->next;\n\t}\n\n\tp_EV_header->num_of_ctrl = numCtrl;\n\n\t \n\n\ttemp_dword = usedbytes;\n\n\trc = access_EV(WRITE_EV, \"CQTHPS\", (u8 *) buffer, &temp_dword);\n\n\tdbg(\"usedbytes = 0x%x, length = 0x%x\\n\", usedbytes, temp_dword);\n\n\tevbuffer_length = temp_dword;\n\n\tif (rc) {\n\t\terr(msg_unable_to_save);\n\t\treturn(1);\n\t}\n\n\treturn(0);\n}\n\n\nvoid compaq_nvram_init(void __iomem *rom_start)\n{\n\tif (rom_start)\n\t\tcompaq_int15_entry_point = (rom_start + ROM_INT15_PHY_ADDR - ROM_PHY_ADDR);\n\n\tdbg(\"int15 entry  = %p\\n\", compaq_int15_entry_point);\n}\n\n\nint compaq_nvram_load(void __iomem *rom_start, struct controller *ctrl)\n{\n\tu8 bus, device, function;\n\tu8 nummem, numpmem, numio, numbus;\n\tu32 rc;\n\tu8 *p_byte;\n\tstruct pci_resource *mem_node;\n\tstruct pci_resource *p_mem_node;\n\tstruct pci_resource *io_node;\n\tstruct pci_resource *bus_node;\n\tstruct ev_hrt_ctrl *p_ev_ctrl;\n\tstruct ev_hrt_header *p_EV_header;\n\n\tif (!evbuffer_init) {\n\t\t \n\t\tif (load_HRT(rom_start))\n\t\t\tmemset(evbuffer, 0, 1024);\n\n\t\tevbuffer_init = 1;\n\t}\n\n\t \n\tp_EV_header = (struct ev_hrt_header *) evbuffer;\n\n\t \n\tif ((p_EV_header->Version == 2) ||\n\t    ((p_EV_header->Version == 1) && !ctrl->push_flag)) {\n\t\tp_byte = &(p_EV_header->next);\n\n\t\tp_ev_ctrl = (struct ev_hrt_ctrl *) &(p_EV_header->next);\n\n\t\tp_byte += 3;\n\n\t\tif (p_byte > ((u8 *)p_EV_header + evbuffer_length))\n\t\t\treturn 2;\n\n\t\tbus = p_ev_ctrl->bus;\n\t\tdevice = p_ev_ctrl->device;\n\t\tfunction = p_ev_ctrl->function;\n\n\t\twhile ((bus != ctrl->bus) ||\n\t\t       (device != PCI_SLOT(ctrl->pci_dev->devfn)) ||\n\t\t       (function != PCI_FUNC(ctrl->pci_dev->devfn))) {\n\t\t\tnummem = p_ev_ctrl->mem_avail;\n\t\t\tnumpmem = p_ev_ctrl->p_mem_avail;\n\t\t\tnumio = p_ev_ctrl->io_avail;\n\t\t\tnumbus = p_ev_ctrl->bus_avail;\n\n\t\t\tp_byte += 4;\n\n\t\t\tif (p_byte > ((u8 *)p_EV_header + evbuffer_length))\n\t\t\t\treturn 2;\n\n\t\t\t \n\t\t\tp_byte += (nummem + numpmem + numio + numbus) * 8;\n\n\t\t\tif (p_byte > ((u8 *)p_EV_header + evbuffer_length))\n\t\t\t\treturn 2;\n\n\t\t\tp_ev_ctrl = (struct ev_hrt_ctrl *) p_byte;\n\n\t\t\tp_byte += 3;\n\n\t\t\tif (p_byte > ((u8 *)p_EV_header + evbuffer_length))\n\t\t\t\treturn 2;\n\n\t\t\tbus = p_ev_ctrl->bus;\n\t\t\tdevice = p_ev_ctrl->device;\n\t\t\tfunction = p_ev_ctrl->function;\n\t\t}\n\n\t\tnummem = p_ev_ctrl->mem_avail;\n\t\tnumpmem = p_ev_ctrl->p_mem_avail;\n\t\tnumio = p_ev_ctrl->io_avail;\n\t\tnumbus = p_ev_ctrl->bus_avail;\n\n\t\tp_byte += 4;\n\n\t\tif (p_byte > ((u8 *)p_EV_header + evbuffer_length))\n\t\t\treturn 2;\n\n\t\twhile (nummem--) {\n\t\t\tmem_node = kmalloc(sizeof(struct pci_resource), GFP_KERNEL);\n\n\t\t\tif (!mem_node)\n\t\t\t\tbreak;\n\n\t\t\tmem_node->base = *(u32 *)p_byte;\n\t\t\tdbg(\"mem base = %8.8x\\n\", mem_node->base);\n\t\t\tp_byte += 4;\n\n\t\t\tif (p_byte > ((u8 *)p_EV_header + evbuffer_length)) {\n\t\t\t\tkfree(mem_node);\n\t\t\t\treturn 2;\n\t\t\t}\n\n\t\t\tmem_node->length = *(u32 *)p_byte;\n\t\t\tdbg(\"mem length = %8.8x\\n\", mem_node->length);\n\t\t\tp_byte += 4;\n\n\t\t\tif (p_byte > ((u8 *)p_EV_header + evbuffer_length)) {\n\t\t\t\tkfree(mem_node);\n\t\t\t\treturn 2;\n\t\t\t}\n\n\t\t\tmem_node->next = ctrl->mem_head;\n\t\t\tctrl->mem_head = mem_node;\n\t\t}\n\n\t\twhile (numpmem--) {\n\t\t\tp_mem_node = kmalloc(sizeof(struct pci_resource), GFP_KERNEL);\n\n\t\t\tif (!p_mem_node)\n\t\t\t\tbreak;\n\n\t\t\tp_mem_node->base = *(u32 *)p_byte;\n\t\t\tdbg(\"pre-mem base = %8.8x\\n\", p_mem_node->base);\n\t\t\tp_byte += 4;\n\n\t\t\tif (p_byte > ((u8 *)p_EV_header + evbuffer_length)) {\n\t\t\t\tkfree(p_mem_node);\n\t\t\t\treturn 2;\n\t\t\t}\n\n\t\t\tp_mem_node->length = *(u32 *)p_byte;\n\t\t\tdbg(\"pre-mem length = %8.8x\\n\", p_mem_node->length);\n\t\t\tp_byte += 4;\n\n\t\t\tif (p_byte > ((u8 *)p_EV_header + evbuffer_length)) {\n\t\t\t\tkfree(p_mem_node);\n\t\t\t\treturn 2;\n\t\t\t}\n\n\t\t\tp_mem_node->next = ctrl->p_mem_head;\n\t\t\tctrl->p_mem_head = p_mem_node;\n\t\t}\n\n\t\twhile (numio--) {\n\t\t\tio_node = kmalloc(sizeof(struct pci_resource), GFP_KERNEL);\n\n\t\t\tif (!io_node)\n\t\t\t\tbreak;\n\n\t\t\tio_node->base = *(u32 *)p_byte;\n\t\t\tdbg(\"io base = %8.8x\\n\", io_node->base);\n\t\t\tp_byte += 4;\n\n\t\t\tif (p_byte > ((u8 *)p_EV_header + evbuffer_length)) {\n\t\t\t\tkfree(io_node);\n\t\t\t\treturn 2;\n\t\t\t}\n\n\t\t\tio_node->length = *(u32 *)p_byte;\n\t\t\tdbg(\"io length = %8.8x\\n\", io_node->length);\n\t\t\tp_byte += 4;\n\n\t\t\tif (p_byte > ((u8 *)p_EV_header + evbuffer_length)) {\n\t\t\t\tkfree(io_node);\n\t\t\t\treturn 2;\n\t\t\t}\n\n\t\t\tio_node->next = ctrl->io_head;\n\t\t\tctrl->io_head = io_node;\n\t\t}\n\n\t\twhile (numbus--) {\n\t\t\tbus_node = kmalloc(sizeof(struct pci_resource), GFP_KERNEL);\n\n\t\t\tif (!bus_node)\n\t\t\t\tbreak;\n\n\t\t\tbus_node->base = *(u32 *)p_byte;\n\t\t\tp_byte += 4;\n\n\t\t\tif (p_byte > ((u8 *)p_EV_header + evbuffer_length)) {\n\t\t\t\tkfree(bus_node);\n\t\t\t\treturn 2;\n\t\t\t}\n\n\t\t\tbus_node->length = *(u32 *)p_byte;\n\t\t\tp_byte += 4;\n\n\t\t\tif (p_byte > ((u8 *)p_EV_header + evbuffer_length)) {\n\t\t\t\tkfree(bus_node);\n\t\t\t\treturn 2;\n\t\t\t}\n\n\t\t\tbus_node->next = ctrl->bus_head;\n\t\t\tctrl->bus_head = bus_node;\n\t\t}\n\n\t\t \n\t\trc = 1;\n\t\trc &= cpqhp_resource_sort_and_combine(&(ctrl->mem_head));\n\t\trc &= cpqhp_resource_sort_and_combine(&(ctrl->p_mem_head));\n\t\trc &= cpqhp_resource_sort_and_combine(&(ctrl->io_head));\n\t\trc &= cpqhp_resource_sort_and_combine(&(ctrl->bus_head));\n\n\t\tif (rc)\n\t\t\treturn(rc);\n\t} else {\n\t\tif ((evbuffer[0] != 0) && (!ctrl->push_flag))\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n\nint compaq_nvram_store(void __iomem *rom_start)\n{\n\tint rc = 1;\n\n\tif (rom_start == NULL)\n\t\treturn -ENODEV;\n\n\tif (evbuffer_init) {\n\t\trc = store_HRT(rom_start);\n\t\tif (rc)\n\t\t\terr(msg_unable_to_save);\n\t}\n\treturn rc;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}