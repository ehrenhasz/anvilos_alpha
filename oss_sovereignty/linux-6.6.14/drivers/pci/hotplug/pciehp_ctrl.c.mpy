{
  "module_name": "pciehp_ctrl.c",
  "hash_id": "f57310bc2523bdc9293c3f84f899d776da1b8032f9aff9fed82a5ca16af5e00d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/hotplug/pciehp_ctrl.c",
  "human_readable_source": "\n \n\n#define dev_fmt(fmt) \"pciehp: \" fmt\n\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/pm_runtime.h>\n#include <linux/pci.h>\n#include \"pciehp.h\"\n\n \n\n#define SAFE_REMOVAL\t true\n#define SURPRISE_REMOVAL false\n\nstatic void set_slot_off(struct controller *ctrl)\n{\n\t \n\tif (POWER_CTRL(ctrl)) {\n\t\tpciehp_power_off_slot(ctrl);\n\n\t\t \n\t\tmsleep(1000);\n\t}\n\n\tpciehp_set_indicators(ctrl, PCI_EXP_SLTCTL_PWR_IND_OFF,\n\t\t\t      PCI_EXP_SLTCTL_ATTN_IND_ON);\n}\n\n \nstatic int board_added(struct controller *ctrl)\n{\n\tint retval = 0;\n\tstruct pci_bus *parent = ctrl->pcie->port->subordinate;\n\n\tif (POWER_CTRL(ctrl)) {\n\t\t \n\t\tretval = pciehp_power_on_slot(ctrl);\n\t\tif (retval)\n\t\t\treturn retval;\n\t}\n\n\tpciehp_set_indicators(ctrl, PCI_EXP_SLTCTL_PWR_IND_BLINK,\n\t\t\t      INDICATOR_NOOP);\n\n\t \n\tretval = pciehp_check_link_status(ctrl);\n\tif (retval)\n\t\tgoto err_exit;\n\n\t \n\tif (ctrl->power_fault_detected || pciehp_query_power_fault(ctrl)) {\n\t\tctrl_err(ctrl, \"Slot(%s): Power fault\\n\", slot_name(ctrl));\n\t\tretval = -EIO;\n\t\tgoto err_exit;\n\t}\n\n\tretval = pciehp_configure_device(ctrl);\n\tif (retval) {\n\t\tif (retval != -EEXIST) {\n\t\t\tctrl_err(ctrl, \"Cannot add device at %04x:%02x:00\\n\",\n\t\t\t\t pci_domain_nr(parent), parent->number);\n\t\t\tgoto err_exit;\n\t\t}\n\t}\n\n\tpciehp_set_indicators(ctrl, PCI_EXP_SLTCTL_PWR_IND_ON,\n\t\t\t      PCI_EXP_SLTCTL_ATTN_IND_OFF);\n\treturn 0;\n\nerr_exit:\n\tset_slot_off(ctrl);\n\treturn retval;\n}\n\n \nstatic void remove_board(struct controller *ctrl, bool safe_removal)\n{\n\tpciehp_unconfigure_device(ctrl, safe_removal);\n\n\tif (POWER_CTRL(ctrl)) {\n\t\tpciehp_power_off_slot(ctrl);\n\n\t\t \n\t\tmsleep(1000);\n\n\t\t \n\t\tatomic_and(~(PCI_EXP_SLTSTA_DLLSC | PCI_EXP_SLTSTA_PDC),\n\t\t\t   &ctrl->pending_events);\n\t}\n\n\tpciehp_set_indicators(ctrl, PCI_EXP_SLTCTL_PWR_IND_OFF,\n\t\t\t      INDICATOR_NOOP);\n}\n\nstatic int pciehp_enable_slot(struct controller *ctrl);\nstatic int pciehp_disable_slot(struct controller *ctrl, bool safe_removal);\n\nvoid pciehp_request(struct controller *ctrl, int action)\n{\n\tatomic_or(action, &ctrl->pending_events);\n\tif (!pciehp_poll_mode)\n\t\tirq_wake_thread(ctrl->pcie->irq, ctrl);\n}\n\nvoid pciehp_queue_pushbutton_work(struct work_struct *work)\n{\n\tstruct controller *ctrl = container_of(work, struct controller,\n\t\t\t\t\t       button_work.work);\n\n\tmutex_lock(&ctrl->state_lock);\n\tswitch (ctrl->state) {\n\tcase BLINKINGOFF_STATE:\n\t\tpciehp_request(ctrl, DISABLE_SLOT);\n\t\tbreak;\n\tcase BLINKINGON_STATE:\n\t\tpciehp_request(ctrl, PCI_EXP_SLTSTA_PDC);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tmutex_unlock(&ctrl->state_lock);\n}\n\nvoid pciehp_handle_button_press(struct controller *ctrl)\n{\n\tmutex_lock(&ctrl->state_lock);\n\tswitch (ctrl->state) {\n\tcase OFF_STATE:\n\tcase ON_STATE:\n\t\tif (ctrl->state == ON_STATE) {\n\t\t\tctrl->state = BLINKINGOFF_STATE;\n\t\t\tctrl_info(ctrl, \"Slot(%s): Button press: will power off in 5 sec\\n\",\n\t\t\t\t  slot_name(ctrl));\n\t\t} else {\n\t\t\tctrl->state = BLINKINGON_STATE;\n\t\t\tctrl_info(ctrl, \"Slot(%s): Button press: will power on in 5 sec\\n\",\n\t\t\t\t  slot_name(ctrl));\n\t\t}\n\t\t \n\t\tpciehp_set_indicators(ctrl, PCI_EXP_SLTCTL_PWR_IND_BLINK,\n\t\t\t\t      PCI_EXP_SLTCTL_ATTN_IND_OFF);\n\t\tschedule_delayed_work(&ctrl->button_work, 5 * HZ);\n\t\tbreak;\n\tcase BLINKINGOFF_STATE:\n\tcase BLINKINGON_STATE:\n\t\t \n\t\tcancel_delayed_work(&ctrl->button_work);\n\t\tif (ctrl->state == BLINKINGOFF_STATE) {\n\t\t\tctrl->state = ON_STATE;\n\t\t\tpciehp_set_indicators(ctrl, PCI_EXP_SLTCTL_PWR_IND_ON,\n\t\t\t\t\t      PCI_EXP_SLTCTL_ATTN_IND_OFF);\n\t\t\tctrl_info(ctrl, \"Slot(%s): Button press: canceling request to power off\\n\",\n\t\t\t\t  slot_name(ctrl));\n\t\t} else {\n\t\t\tctrl->state = OFF_STATE;\n\t\t\tpciehp_set_indicators(ctrl, PCI_EXP_SLTCTL_PWR_IND_OFF,\n\t\t\t\t\t      PCI_EXP_SLTCTL_ATTN_IND_OFF);\n\t\t\tctrl_info(ctrl, \"Slot(%s): Button press: canceling request to power on\\n\",\n\t\t\t\t  slot_name(ctrl));\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tctrl_err(ctrl, \"Slot(%s): Button press: ignoring invalid state %#x\\n\",\n\t\t\t slot_name(ctrl), ctrl->state);\n\t\tbreak;\n\t}\n\tmutex_unlock(&ctrl->state_lock);\n}\n\nvoid pciehp_handle_disable_request(struct controller *ctrl)\n{\n\tmutex_lock(&ctrl->state_lock);\n\tswitch (ctrl->state) {\n\tcase BLINKINGON_STATE:\n\tcase BLINKINGOFF_STATE:\n\t\tcancel_delayed_work(&ctrl->button_work);\n\t\tbreak;\n\t}\n\tctrl->state = POWEROFF_STATE;\n\tmutex_unlock(&ctrl->state_lock);\n\n\tctrl->request_result = pciehp_disable_slot(ctrl, SAFE_REMOVAL);\n}\n\nvoid pciehp_handle_presence_or_link_change(struct controller *ctrl, u32 events)\n{\n\tint present, link_active;\n\n\t \n\tmutex_lock(&ctrl->state_lock);\n\tswitch (ctrl->state) {\n\tcase BLINKINGOFF_STATE:\n\t\tcancel_delayed_work(&ctrl->button_work);\n\t\tfallthrough;\n\tcase ON_STATE:\n\t\tctrl->state = POWEROFF_STATE;\n\t\tmutex_unlock(&ctrl->state_lock);\n\t\tif (events & PCI_EXP_SLTSTA_DLLSC)\n\t\t\tctrl_info(ctrl, \"Slot(%s): Link Down\\n\",\n\t\t\t\t  slot_name(ctrl));\n\t\tif (events & PCI_EXP_SLTSTA_PDC)\n\t\t\tctrl_info(ctrl, \"Slot(%s): Card not present\\n\",\n\t\t\t\t  slot_name(ctrl));\n\t\tpciehp_disable_slot(ctrl, SURPRISE_REMOVAL);\n\t\tbreak;\n\tdefault:\n\t\tmutex_unlock(&ctrl->state_lock);\n\t\tbreak;\n\t}\n\n\t \n\tmutex_lock(&ctrl->state_lock);\n\tpresent = pciehp_card_present(ctrl);\n\tlink_active = pciehp_check_link_active(ctrl);\n\tif (present <= 0 && link_active <= 0) {\n\t\tif (ctrl->state == BLINKINGON_STATE) {\n\t\t\tctrl->state = OFF_STATE;\n\t\t\tcancel_delayed_work(&ctrl->button_work);\n\t\t\tpciehp_set_indicators(ctrl, PCI_EXP_SLTCTL_PWR_IND_OFF,\n\t\t\t\t\t      INDICATOR_NOOP);\n\t\t\tctrl_info(ctrl, \"Slot(%s): Card not present\\n\",\n\t\t\t\t  slot_name(ctrl));\n\t\t}\n\t\tmutex_unlock(&ctrl->state_lock);\n\t\treturn;\n\t}\n\n\tswitch (ctrl->state) {\n\tcase BLINKINGON_STATE:\n\t\tcancel_delayed_work(&ctrl->button_work);\n\t\tfallthrough;\n\tcase OFF_STATE:\n\t\tctrl->state = POWERON_STATE;\n\t\tmutex_unlock(&ctrl->state_lock);\n\t\tif (present)\n\t\t\tctrl_info(ctrl, \"Slot(%s): Card present\\n\",\n\t\t\t\t  slot_name(ctrl));\n\t\tif (link_active)\n\t\t\tctrl_info(ctrl, \"Slot(%s): Link Up\\n\",\n\t\t\t\t  slot_name(ctrl));\n\t\tctrl->request_result = pciehp_enable_slot(ctrl);\n\t\tbreak;\n\tdefault:\n\t\tmutex_unlock(&ctrl->state_lock);\n\t\tbreak;\n\t}\n}\n\nstatic int __pciehp_enable_slot(struct controller *ctrl)\n{\n\tu8 getstatus = 0;\n\n\tif (MRL_SENS(ctrl)) {\n\t\tpciehp_get_latch_status(ctrl, &getstatus);\n\t\tif (getstatus) {\n\t\t\tctrl_info(ctrl, \"Slot(%s): Latch open\\n\",\n\t\t\t\t  slot_name(ctrl));\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\tif (POWER_CTRL(ctrl)) {\n\t\tpciehp_get_power_status(ctrl, &getstatus);\n\t\tif (getstatus) {\n\t\t\tctrl_info(ctrl, \"Slot(%s): Already enabled\\n\",\n\t\t\t\t  slot_name(ctrl));\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn board_added(ctrl);\n}\n\nstatic int pciehp_enable_slot(struct controller *ctrl)\n{\n\tint ret;\n\n\tpm_runtime_get_sync(&ctrl->pcie->port->dev);\n\tret = __pciehp_enable_slot(ctrl);\n\tif (ret && ATTN_BUTTN(ctrl))\n\t\t \n\t\tpciehp_set_indicators(ctrl, PCI_EXP_SLTCTL_PWR_IND_OFF,\n\t\t\t\t      INDICATOR_NOOP);\n\tpm_runtime_put(&ctrl->pcie->port->dev);\n\n\tmutex_lock(&ctrl->state_lock);\n\tctrl->state = ret ? OFF_STATE : ON_STATE;\n\tmutex_unlock(&ctrl->state_lock);\n\n\treturn ret;\n}\n\nstatic int __pciehp_disable_slot(struct controller *ctrl, bool safe_removal)\n{\n\tu8 getstatus = 0;\n\n\tif (POWER_CTRL(ctrl)) {\n\t\tpciehp_get_power_status(ctrl, &getstatus);\n\t\tif (!getstatus) {\n\t\t\tctrl_info(ctrl, \"Slot(%s): Already disabled\\n\",\n\t\t\t\t  slot_name(ctrl));\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tremove_board(ctrl, safe_removal);\n\treturn 0;\n}\n\nstatic int pciehp_disable_slot(struct controller *ctrl, bool safe_removal)\n{\n\tint ret;\n\n\tpm_runtime_get_sync(&ctrl->pcie->port->dev);\n\tret = __pciehp_disable_slot(ctrl, safe_removal);\n\tpm_runtime_put(&ctrl->pcie->port->dev);\n\n\tmutex_lock(&ctrl->state_lock);\n\tctrl->state = OFF_STATE;\n\tmutex_unlock(&ctrl->state_lock);\n\n\treturn ret;\n}\n\nint pciehp_sysfs_enable_slot(struct hotplug_slot *hotplug_slot)\n{\n\tstruct controller *ctrl = to_ctrl(hotplug_slot);\n\n\tmutex_lock(&ctrl->state_lock);\n\tswitch (ctrl->state) {\n\tcase BLINKINGON_STATE:\n\tcase OFF_STATE:\n\t\tmutex_unlock(&ctrl->state_lock);\n\t\t \n\t\tctrl->request_result = -ENODEV;\n\t\tpciehp_request(ctrl, PCI_EXP_SLTSTA_PDC);\n\t\twait_event(ctrl->requester,\n\t\t\t   !atomic_read(&ctrl->pending_events) &&\n\t\t\t   !ctrl->ist_running);\n\t\treturn ctrl->request_result;\n\tcase POWERON_STATE:\n\t\tctrl_info(ctrl, \"Slot(%s): Already in powering on state\\n\",\n\t\t\t  slot_name(ctrl));\n\t\tbreak;\n\tcase BLINKINGOFF_STATE:\n\tcase ON_STATE:\n\tcase POWEROFF_STATE:\n\t\tctrl_info(ctrl, \"Slot(%s): Already enabled\\n\",\n\t\t\t  slot_name(ctrl));\n\t\tbreak;\n\tdefault:\n\t\tctrl_err(ctrl, \"Slot(%s): Invalid state %#x\\n\",\n\t\t\t slot_name(ctrl), ctrl->state);\n\t\tbreak;\n\t}\n\tmutex_unlock(&ctrl->state_lock);\n\n\treturn -ENODEV;\n}\n\nint pciehp_sysfs_disable_slot(struct hotplug_slot *hotplug_slot)\n{\n\tstruct controller *ctrl = to_ctrl(hotplug_slot);\n\n\tmutex_lock(&ctrl->state_lock);\n\tswitch (ctrl->state) {\n\tcase BLINKINGOFF_STATE:\n\tcase ON_STATE:\n\t\tmutex_unlock(&ctrl->state_lock);\n\t\tpciehp_request(ctrl, DISABLE_SLOT);\n\t\twait_event(ctrl->requester,\n\t\t\t   !atomic_read(&ctrl->pending_events) &&\n\t\t\t   !ctrl->ist_running);\n\t\treturn ctrl->request_result;\n\tcase POWEROFF_STATE:\n\t\tctrl_info(ctrl, \"Slot(%s): Already in powering off state\\n\",\n\t\t\t  slot_name(ctrl));\n\t\tbreak;\n\tcase BLINKINGON_STATE:\n\tcase OFF_STATE:\n\tcase POWERON_STATE:\n\t\tctrl_info(ctrl, \"Slot(%s): Already disabled\\n\",\n\t\t\t  slot_name(ctrl));\n\t\tbreak;\n\tdefault:\n\t\tctrl_err(ctrl, \"Slot(%s): Invalid state %#x\\n\",\n\t\t\t slot_name(ctrl), ctrl->state);\n\t\tbreak;\n\t}\n\tmutex_unlock(&ctrl->state_lock);\n\n\treturn -ENODEV;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}