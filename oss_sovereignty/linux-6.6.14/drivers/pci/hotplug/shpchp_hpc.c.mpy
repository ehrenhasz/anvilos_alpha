{
  "module_name": "shpchp_hpc.c",
  "hash_id": "a9828117c1d8c14bd2442e505dd525281f525ebd04f816a0c766fae9cd71371c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/hotplug/shpchp_hpc.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/pci.h>\n#include <linux/interrupt.h>\n\n#include \"shpchp.h\"\n\n \n#define SLOT_33MHZ\t\t0x0000001f\n#define SLOT_66MHZ_PCIX\t\t0x00001f00\n#define SLOT_100MHZ_PCIX\t0x001f0000\n#define SLOT_133MHZ_PCIX\t0x1f000000\n\n \n#define SLOT_66MHZ\t\t0x0000001f\n#define SLOT_66MHZ_PCIX_266\t0x00000f00\n#define SLOT_100MHZ_PCIX_266\t0x0000f000\n#define SLOT_133MHZ_PCIX_266\t0x000f0000\n#define SLOT_66MHZ_PCIX_533\t0x00f00000\n#define SLOT_100MHZ_PCIX_533\t0x0f000000\n#define SLOT_133MHZ_PCIX_533\t0xf0000000\n\n \n#define SLOT_NUM\t\t0x0000001F\n#define\tFIRST_DEV_NUM\t\t0x00001F00\n#define PSN\t\t\t0x07FF0000\n#define\tUPDOWN\t\t\t0x20000000\n#define\tMRLSENSOR\t\t0x40000000\n#define ATTN_BUTTON\t\t0x80000000\n\n \n#define CMD_INTR_PENDING\t(1 << 0)\n#define SLOT_INTR_PENDING(i)\t(1 << (i + 1))\n\n \n#define GLOBAL_INTR_MASK\t(1 << 0)\n#define GLOBAL_SERR_MASK\t(1 << 1)\n#define COMMAND_INTR_MASK\t(1 << 2)\n#define ARBITER_SERR_MASK\t(1 << 3)\n#define COMMAND_DETECTED\t(1 << 16)\n#define ARBITER_DETECTED\t(1 << 17)\n#define SERR_INTR_RSVDZ_MASK\t0xfffc0000\n\n \n#define SLOT_REG(i)\t\t(SLOT1 + (4 * i))\n\n#define SLOT_STATE_SHIFT\t(0)\n#define SLOT_STATE_MASK\t\t(3 << 0)\n#define SLOT_STATE_PWRONLY\t(1)\n#define SLOT_STATE_ENABLED\t(2)\n#define SLOT_STATE_DISABLED\t(3)\n#define PWR_LED_STATE_SHIFT\t(2)\n#define PWR_LED_STATE_MASK\t(3 << 2)\n#define ATN_LED_STATE_SHIFT\t(4)\n#define ATN_LED_STATE_MASK\t(3 << 4)\n#define ATN_LED_STATE_ON\t(1)\n#define ATN_LED_STATE_BLINK\t(2)\n#define ATN_LED_STATE_OFF\t(3)\n#define POWER_FAULT\t\t(1 << 6)\n#define ATN_BUTTON\t\t(1 << 7)\n#define MRL_SENSOR\t\t(1 << 8)\n#define MHZ66_CAP\t\t(1 << 9)\n#define PRSNT_SHIFT\t\t(10)\n#define PRSNT_MASK\t\t(3 << 10)\n#define PCIX_CAP_SHIFT\t\t(12)\n#define PCIX_CAP_MASK_PI1\t(3 << 12)\n#define PCIX_CAP_MASK_PI2\t(7 << 12)\n#define PRSNT_CHANGE_DETECTED\t(1 << 16)\n#define ISO_PFAULT_DETECTED\t(1 << 17)\n#define BUTTON_PRESS_DETECTED\t(1 << 18)\n#define MRL_CHANGE_DETECTED\t(1 << 19)\n#define CON_PFAULT_DETECTED\t(1 << 20)\n#define PRSNT_CHANGE_INTR_MASK\t(1 << 24)\n#define ISO_PFAULT_INTR_MASK\t(1 << 25)\n#define BUTTON_PRESS_INTR_MASK\t(1 << 26)\n#define MRL_CHANGE_INTR_MASK\t(1 << 27)\n#define CON_PFAULT_INTR_MASK\t(1 << 28)\n#define MRL_CHANGE_SERR_MASK\t(1 << 29)\n#define CON_PFAULT_SERR_MASK\t(1 << 30)\n#define SLOT_REG_RSVDZ_MASK\t((1 << 15) | (7 << 21))\n\n \n#define SET_SLOT_PWR\t\t0x01\t \n#define SET_SLOT_ENABLE\t\t0x02\n#define SET_SLOT_DISABLE\t0x03\n#define SET_PWR_ON\t\t0x04\n#define SET_PWR_BLINK\t\t0x08\n#define SET_PWR_OFF\t\t0x0c\n#define SET_ATTN_ON\t\t0x10\n#define SET_ATTN_BLINK\t\t0x20\n#define SET_ATTN_OFF\t\t0x30\n#define SETA_PCI_33MHZ\t\t0x40\t \n#define SETA_PCI_66MHZ\t\t0x41\n#define SETA_PCIX_66MHZ\t\t0x42\n#define SETA_PCIX_100MHZ\t0x43\n#define SETA_PCIX_133MHZ\t0x44\n#define SETA_RESERVED1\t\t0x45\n#define SETA_RESERVED2\t\t0x46\n#define SETA_RESERVED3\t\t0x47\n#define SET_PWR_ONLY_ALL\t0x48\t \n#define SET_ENABLE_ALL\t\t0x49\t \n#define\tSETB_PCI_33MHZ\t\t0x50\t \n#define SETB_PCI_66MHZ\t\t0x51\n#define SETB_PCIX_66MHZ_PM\t0x52\n#define SETB_PCIX_100MHZ_PM\t0x53\n#define SETB_PCIX_133MHZ_PM\t0x54\n#define SETB_PCIX_66MHZ_EM\t0x55\n#define SETB_PCIX_100MHZ_EM\t0x56\n#define SETB_PCIX_133MHZ_EM\t0x57\n#define SETB_PCIX_66MHZ_266\t0x58\n#define SETB_PCIX_100MHZ_266\t0x59\n#define SETB_PCIX_133MHZ_266\t0x5a\n#define SETB_PCIX_66MHZ_533\t0x5b\n#define SETB_PCIX_100MHZ_533\t0x5c\n#define SETB_PCIX_133MHZ_533\t0x5d\n#define SETB_RESERVED1\t\t0x5e\n#define SETB_RESERVED2\t\t0x5f\n\n \n#define SWITCH_OPEN\t\t0x1\n#define INVALID_CMD\t\t0x2\n#define INVALID_SPEED_MODE\t0x4\n\n \n#define DWORD_SELECT\t\t0x2\n#define DWORD_DATA\t\t0x4\n\n \n#define SLOT_EVENT_LATCH\t0x2\n#define SLOT_SERR_INT_MASK\t0x3\n\nstatic irqreturn_t shpc_isr(int irq, void *dev_id);\nstatic void start_int_poll_timer(struct controller *ctrl, int sec);\nstatic int hpc_check_cmd_status(struct controller *ctrl);\n\nstatic inline u8 shpc_readb(struct controller *ctrl, int reg)\n{\n\treturn readb(ctrl->creg + reg);\n}\n\nstatic inline u16 shpc_readw(struct controller *ctrl, int reg)\n{\n\treturn readw(ctrl->creg + reg);\n}\n\nstatic inline void shpc_writew(struct controller *ctrl, int reg, u16 val)\n{\n\twritew(val, ctrl->creg + reg);\n}\n\nstatic inline u32 shpc_readl(struct controller *ctrl, int reg)\n{\n\treturn readl(ctrl->creg + reg);\n}\n\nstatic inline void shpc_writel(struct controller *ctrl, int reg, u32 val)\n{\n\twritel(val, ctrl->creg + reg);\n}\n\nstatic inline int shpc_indirect_read(struct controller *ctrl, int index,\n\t\t\t\t     u32 *value)\n{\n\tint rc;\n\tu32 cap_offset = ctrl->cap_offset;\n\tstruct pci_dev *pdev = ctrl->pci_dev;\n\n\trc = pci_write_config_byte(pdev, cap_offset + DWORD_SELECT, index);\n\tif (rc)\n\t\treturn rc;\n\treturn pci_read_config_dword(pdev, cap_offset + DWORD_DATA, value);\n}\n\n \nstatic void int_poll_timeout(struct timer_list *t)\n{\n\tstruct controller *ctrl = from_timer(ctrl, t, poll_timer);\n\n\t \n\tshpc_isr(0, ctrl);\n\n\tif (!shpchp_poll_time)\n\t\tshpchp_poll_time = 2;  \n\n\tstart_int_poll_timer(ctrl, shpchp_poll_time);\n}\n\n \nstatic void start_int_poll_timer(struct controller *ctrl, int sec)\n{\n\t \n\tif ((sec <= 0) || (sec > 60))\n\t\tsec = 2;\n\n\tctrl->poll_timer.expires = jiffies + sec * HZ;\n\tadd_timer(&ctrl->poll_timer);\n}\n\nstatic inline int is_ctrl_busy(struct controller *ctrl)\n{\n\tu16 cmd_status = shpc_readw(ctrl, CMD_STATUS);\n\treturn cmd_status & 0x1;\n}\n\n \nstatic inline int shpc_poll_ctrl_busy(struct controller *ctrl)\n{\n\tint i;\n\n\tif (!is_ctrl_busy(ctrl))\n\t\treturn 1;\n\n\t \n\tfor (i = 0; i < 10; i++) {\n\t\tmsleep(100);\n\t\tif (!is_ctrl_busy(ctrl))\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic inline int shpc_wait_cmd(struct controller *ctrl)\n{\n\tint retval = 0;\n\tunsigned long timeout = msecs_to_jiffies(1000);\n\tint rc;\n\n\tif (shpchp_poll_mode)\n\t\trc = shpc_poll_ctrl_busy(ctrl);\n\telse\n\t\trc = wait_event_interruptible_timeout(ctrl->queue,\n\t\t\t\t\t\t!is_ctrl_busy(ctrl), timeout);\n\tif (!rc && is_ctrl_busy(ctrl)) {\n\t\tretval = -EIO;\n\t\tctrl_err(ctrl, \"Command not completed in 1000 msec\\n\");\n\t} else if (rc < 0) {\n\t\tretval = -EINTR;\n\t\tctrl_info(ctrl, \"Command was interrupted by a signal\\n\");\n\t}\n\n\treturn retval;\n}\n\nstatic int shpc_write_cmd(struct slot *slot, u8 t_slot, u8 cmd)\n{\n\tstruct controller *ctrl = slot->ctrl;\n\tu16 cmd_status;\n\tint retval = 0;\n\tu16 temp_word;\n\n\tmutex_lock(&slot->ctrl->cmd_lock);\n\n\tif (!shpc_poll_ctrl_busy(ctrl)) {\n\t\t \n\t\tctrl_err(ctrl, \"Controller is still busy after 1 sec\\n\");\n\t\tretval = -EBUSY;\n\t\tgoto out;\n\t}\n\n\t++t_slot;\n\ttemp_word =  (t_slot << 8) | (cmd & 0xFF);\n\tctrl_dbg(ctrl, \"%s: t_slot %x cmd %x\\n\", __func__, t_slot, cmd);\n\n\t \n\tshpc_writew(ctrl, CMD, temp_word);\n\n\t \n\tretval = shpc_wait_cmd(slot->ctrl);\n\tif (retval)\n\t\tgoto out;\n\n\tcmd_status = hpc_check_cmd_status(slot->ctrl);\n\tif (cmd_status) {\n\t\tctrl_err(ctrl, \"Failed to issued command 0x%x (error code = %d)\\n\",\n\t\t\t cmd, cmd_status);\n\t\tretval = -EIO;\n\t}\n out:\n\tmutex_unlock(&slot->ctrl->cmd_lock);\n\treturn retval;\n}\n\nstatic int hpc_check_cmd_status(struct controller *ctrl)\n{\n\tint retval = 0;\n\tu16 cmd_status = shpc_readw(ctrl, CMD_STATUS) & 0x000F;\n\n\tswitch (cmd_status >> 1) {\n\tcase 0:\n\t\tretval = 0;\n\t\tbreak;\n\tcase 1:\n\t\tretval = SWITCH_OPEN;\n\t\tctrl_err(ctrl, \"Switch opened!\\n\");\n\t\tbreak;\n\tcase 2:\n\t\tretval = INVALID_CMD;\n\t\tctrl_err(ctrl, \"Invalid HPC command!\\n\");\n\t\tbreak;\n\tcase 4:\n\t\tretval = INVALID_SPEED_MODE;\n\t\tctrl_err(ctrl, \"Invalid bus speed/mode!\\n\");\n\t\tbreak;\n\tdefault:\n\t\tretval = cmd_status;\n\t}\n\n\treturn retval;\n}\n\n\nstatic int hpc_get_attention_status(struct slot *slot, u8 *status)\n{\n\tstruct controller *ctrl = slot->ctrl;\n\tu32 slot_reg = shpc_readl(ctrl, SLOT_REG(slot->hp_slot));\n\tu8 state = (slot_reg & ATN_LED_STATE_MASK) >> ATN_LED_STATE_SHIFT;\n\n\tswitch (state) {\n\tcase ATN_LED_STATE_ON:\n\t\t*status = 1;\t \n\t\tbreak;\n\tcase ATN_LED_STATE_BLINK:\n\t\t*status = 2;\t \n\t\tbreak;\n\tcase ATN_LED_STATE_OFF:\n\t\t*status = 0;\t \n\t\tbreak;\n\tdefault:\n\t\t*status = 0xFF;\t \n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int hpc_get_power_status(struct slot *slot, u8 *status)\n{\n\tstruct controller *ctrl = slot->ctrl;\n\tu32 slot_reg = shpc_readl(ctrl, SLOT_REG(slot->hp_slot));\n\tu8 state = (slot_reg & SLOT_STATE_MASK) >> SLOT_STATE_SHIFT;\n\n\tswitch (state) {\n\tcase SLOT_STATE_PWRONLY:\n\t\t*status = 2;\t \n\t\tbreak;\n\tcase SLOT_STATE_ENABLED:\n\t\t*status = 1;\t \n\t\tbreak;\n\tcase SLOT_STATE_DISABLED:\n\t\t*status = 0;\t \n\t\tbreak;\n\tdefault:\n\t\t*status = 0xFF;\t \n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n\nstatic int hpc_get_latch_status(struct slot *slot, u8 *status)\n{\n\tstruct controller *ctrl = slot->ctrl;\n\tu32 slot_reg = shpc_readl(ctrl, SLOT_REG(slot->hp_slot));\n\n\t*status = !!(slot_reg & MRL_SENSOR);\t \n\n\treturn 0;\n}\n\nstatic int hpc_get_adapter_status(struct slot *slot, u8 *status)\n{\n\tstruct controller *ctrl = slot->ctrl;\n\tu32 slot_reg = shpc_readl(ctrl, SLOT_REG(slot->hp_slot));\n\tu8 state = (slot_reg & PRSNT_MASK) >> PRSNT_SHIFT;\n\n\t*status = (state != 0x3) ? 1 : 0;\n\n\treturn 0;\n}\n\nstatic int hpc_get_prog_int(struct slot *slot, u8 *prog_int)\n{\n\tstruct controller *ctrl = slot->ctrl;\n\n\t*prog_int = shpc_readb(ctrl, PROG_INTERFACE);\n\n\treturn 0;\n}\n\nstatic int hpc_get_adapter_speed(struct slot *slot, enum pci_bus_speed *value)\n{\n\tint retval = 0;\n\tstruct controller *ctrl = slot->ctrl;\n\tu32 slot_reg = shpc_readl(ctrl, SLOT_REG(slot->hp_slot));\n\tu8 m66_cap  = !!(slot_reg & MHZ66_CAP);\n\tu8 pi, pcix_cap;\n\n\tretval = hpc_get_prog_int(slot, &pi);\n\tif (retval)\n\t\treturn retval;\n\n\tswitch (pi) {\n\tcase 1:\n\t\tpcix_cap = (slot_reg & PCIX_CAP_MASK_PI1) >> PCIX_CAP_SHIFT;\n\t\tbreak;\n\tcase 2:\n\t\tpcix_cap = (slot_reg & PCIX_CAP_MASK_PI2) >> PCIX_CAP_SHIFT;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENODEV;\n\t}\n\n\tctrl_dbg(ctrl, \"%s: slot_reg = %x, pcix_cap = %x, m66_cap = %x\\n\",\n\t\t __func__, slot_reg, pcix_cap, m66_cap);\n\n\tswitch (pcix_cap) {\n\tcase 0x0:\n\t\t*value = m66_cap ? PCI_SPEED_66MHz : PCI_SPEED_33MHz;\n\t\tbreak;\n\tcase 0x1:\n\t\t*value = PCI_SPEED_66MHz_PCIX;\n\t\tbreak;\n\tcase 0x3:\n\t\t*value = PCI_SPEED_133MHz_PCIX;\n\t\tbreak;\n\tcase 0x4:\n\t\t*value = PCI_SPEED_133MHz_PCIX_266;\n\t\tbreak;\n\tcase 0x5:\n\t\t*value = PCI_SPEED_133MHz_PCIX_533;\n\t\tbreak;\n\tcase 0x2:\n\tdefault:\n\t\t*value = PCI_SPEED_UNKNOWN;\n\t\tretval = -ENODEV;\n\t\tbreak;\n\t}\n\n\tctrl_dbg(ctrl, \"Adapter speed = %d\\n\", *value);\n\treturn retval;\n}\n\nstatic int hpc_query_power_fault(struct slot *slot)\n{\n\tstruct controller *ctrl = slot->ctrl;\n\tu32 slot_reg = shpc_readl(ctrl, SLOT_REG(slot->hp_slot));\n\n\t \n\treturn !(slot_reg & POWER_FAULT);\n}\n\nstatic int hpc_set_attention_status(struct slot *slot, u8 value)\n{\n\tu8 slot_cmd = 0;\n\n\tswitch (value) {\n\t\tcase 0:\n\t\t\tslot_cmd = SET_ATTN_OFF;\t \n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tslot_cmd = SET_ATTN_ON;\t\t \n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tslot_cmd = SET_ATTN_BLINK;\t \n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t}\n\n\treturn shpc_write_cmd(slot, slot->hp_slot, slot_cmd);\n}\n\n\nstatic void hpc_set_green_led_on(struct slot *slot)\n{\n\tshpc_write_cmd(slot, slot->hp_slot, SET_PWR_ON);\n}\n\nstatic void hpc_set_green_led_off(struct slot *slot)\n{\n\tshpc_write_cmd(slot, slot->hp_slot, SET_PWR_OFF);\n}\n\nstatic void hpc_set_green_led_blink(struct slot *slot)\n{\n\tshpc_write_cmd(slot, slot->hp_slot, SET_PWR_BLINK);\n}\n\nstatic void hpc_release_ctlr(struct controller *ctrl)\n{\n\tint i;\n\tu32 slot_reg, serr_int;\n\n\t \n\tfor (i = 0; i < ctrl->num_slots; i++) {\n\t\tslot_reg = shpc_readl(ctrl, SLOT_REG(i));\n\t\tslot_reg |= (PRSNT_CHANGE_INTR_MASK | ISO_PFAULT_INTR_MASK |\n\t\t\t     BUTTON_PRESS_INTR_MASK | MRL_CHANGE_INTR_MASK |\n\t\t\t     CON_PFAULT_INTR_MASK   | MRL_CHANGE_SERR_MASK |\n\t\t\t     CON_PFAULT_SERR_MASK);\n\t\tslot_reg &= ~SLOT_REG_RSVDZ_MASK;\n\t\tshpc_writel(ctrl, SLOT_REG(i), slot_reg);\n\t}\n\n\tcleanup_slots(ctrl);\n\n\t \n\tserr_int = shpc_readl(ctrl, SERR_INTR_ENABLE);\n\tserr_int |= (GLOBAL_INTR_MASK  | GLOBAL_SERR_MASK |\n\t\t     COMMAND_INTR_MASK | ARBITER_SERR_MASK);\n\tserr_int &= ~SERR_INTR_RSVDZ_MASK;\n\tshpc_writel(ctrl, SERR_INTR_ENABLE, serr_int);\n\n\tif (shpchp_poll_mode)\n\t\tdel_timer(&ctrl->poll_timer);\n\telse {\n\t\tfree_irq(ctrl->pci_dev->irq, ctrl);\n\t\tpci_disable_msi(ctrl->pci_dev);\n\t}\n\n\tiounmap(ctrl->creg);\n\trelease_mem_region(ctrl->mmio_base, ctrl->mmio_size);\n}\n\nstatic int hpc_power_on_slot(struct slot *slot)\n{\n\tint retval;\n\n\tretval = shpc_write_cmd(slot, slot->hp_slot, SET_SLOT_PWR);\n\tif (retval)\n\t\tctrl_err(slot->ctrl, \"%s: Write command failed!\\n\", __func__);\n\n\treturn retval;\n}\n\nstatic int hpc_slot_enable(struct slot *slot)\n{\n\tint retval;\n\n\t \n\tretval = shpc_write_cmd(slot, slot->hp_slot,\n\t\t\tSET_SLOT_ENABLE | SET_PWR_BLINK | SET_ATTN_OFF);\n\tif (retval)\n\t\tctrl_err(slot->ctrl, \"%s: Write command failed!\\n\", __func__);\n\n\treturn retval;\n}\n\nstatic int hpc_slot_disable(struct slot *slot)\n{\n\tint retval;\n\n\t \n\tretval = shpc_write_cmd(slot, slot->hp_slot,\n\t\t\tSET_SLOT_DISABLE | SET_PWR_OFF | SET_ATTN_ON);\n\tif (retval)\n\t\tctrl_err(slot->ctrl, \"%s: Write command failed!\\n\", __func__);\n\n\treturn retval;\n}\n\nstatic int shpc_get_cur_bus_speed(struct controller *ctrl)\n{\n\tint retval = 0;\n\tstruct pci_bus *bus = ctrl->pci_dev->subordinate;\n\tenum pci_bus_speed bus_speed = PCI_SPEED_UNKNOWN;\n\tu16 sec_bus_reg = shpc_readw(ctrl, SEC_BUS_CONFIG);\n\tu8 pi = shpc_readb(ctrl, PROG_INTERFACE);\n\tu8 speed_mode = (pi == 2) ? (sec_bus_reg & 0xF) : (sec_bus_reg & 0x7);\n\n\tif ((pi == 1) && (speed_mode > 4)) {\n\t\tretval = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tswitch (speed_mode) {\n\tcase 0x0:\n\t\tbus_speed = PCI_SPEED_33MHz;\n\t\tbreak;\n\tcase 0x1:\n\t\tbus_speed = PCI_SPEED_66MHz;\n\t\tbreak;\n\tcase 0x2:\n\t\tbus_speed = PCI_SPEED_66MHz_PCIX;\n\t\tbreak;\n\tcase 0x3:\n\t\tbus_speed = PCI_SPEED_100MHz_PCIX;\n\t\tbreak;\n\tcase 0x4:\n\t\tbus_speed = PCI_SPEED_133MHz_PCIX;\n\t\tbreak;\n\tcase 0x5:\n\t\tbus_speed = PCI_SPEED_66MHz_PCIX_ECC;\n\t\tbreak;\n\tcase 0x6:\n\t\tbus_speed = PCI_SPEED_100MHz_PCIX_ECC;\n\t\tbreak;\n\tcase 0x7:\n\t\tbus_speed = PCI_SPEED_133MHz_PCIX_ECC;\n\t\tbreak;\n\tcase 0x8:\n\t\tbus_speed = PCI_SPEED_66MHz_PCIX_266;\n\t\tbreak;\n\tcase 0x9:\n\t\tbus_speed = PCI_SPEED_100MHz_PCIX_266;\n\t\tbreak;\n\tcase 0xa:\n\t\tbus_speed = PCI_SPEED_133MHz_PCIX_266;\n\t\tbreak;\n\tcase 0xb:\n\t\tbus_speed = PCI_SPEED_66MHz_PCIX_533;\n\t\tbreak;\n\tcase 0xc:\n\t\tbus_speed = PCI_SPEED_100MHz_PCIX_533;\n\t\tbreak;\n\tcase 0xd:\n\t\tbus_speed = PCI_SPEED_133MHz_PCIX_533;\n\t\tbreak;\n\tdefault:\n\t\tretval = -ENODEV;\n\t\tbreak;\n\t}\n\n out:\n\tbus->cur_bus_speed = bus_speed;\n\tdbg(\"Current bus speed = %d\\n\", bus_speed);\n\treturn retval;\n}\n\n\nstatic int hpc_set_bus_speed_mode(struct slot *slot, enum pci_bus_speed value)\n{\n\tint retval;\n\tstruct controller *ctrl = slot->ctrl;\n\tu8 pi, cmd;\n\n\tpi = shpc_readb(ctrl, PROG_INTERFACE);\n\tif ((pi == 1) && (value > PCI_SPEED_133MHz_PCIX))\n\t\treturn -EINVAL;\n\n\tswitch (value) {\n\tcase PCI_SPEED_33MHz:\n\t\tcmd = SETA_PCI_33MHZ;\n\t\tbreak;\n\tcase PCI_SPEED_66MHz:\n\t\tcmd = SETA_PCI_66MHZ;\n\t\tbreak;\n\tcase PCI_SPEED_66MHz_PCIX:\n\t\tcmd = SETA_PCIX_66MHZ;\n\t\tbreak;\n\tcase PCI_SPEED_100MHz_PCIX:\n\t\tcmd = SETA_PCIX_100MHZ;\n\t\tbreak;\n\tcase PCI_SPEED_133MHz_PCIX:\n\t\tcmd = SETA_PCIX_133MHZ;\n\t\tbreak;\n\tcase PCI_SPEED_66MHz_PCIX_ECC:\n\t\tcmd = SETB_PCIX_66MHZ_EM;\n\t\tbreak;\n\tcase PCI_SPEED_100MHz_PCIX_ECC:\n\t\tcmd = SETB_PCIX_100MHZ_EM;\n\t\tbreak;\n\tcase PCI_SPEED_133MHz_PCIX_ECC:\n\t\tcmd = SETB_PCIX_133MHZ_EM;\n\t\tbreak;\n\tcase PCI_SPEED_66MHz_PCIX_266:\n\t\tcmd = SETB_PCIX_66MHZ_266;\n\t\tbreak;\n\tcase PCI_SPEED_100MHz_PCIX_266:\n\t\tcmd = SETB_PCIX_100MHZ_266;\n\t\tbreak;\n\tcase PCI_SPEED_133MHz_PCIX_266:\n\t\tcmd = SETB_PCIX_133MHZ_266;\n\t\tbreak;\n\tcase PCI_SPEED_66MHz_PCIX_533:\n\t\tcmd = SETB_PCIX_66MHZ_533;\n\t\tbreak;\n\tcase PCI_SPEED_100MHz_PCIX_533:\n\t\tcmd = SETB_PCIX_100MHZ_533;\n\t\tbreak;\n\tcase PCI_SPEED_133MHz_PCIX_533:\n\t\tcmd = SETB_PCIX_133MHZ_533;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tretval = shpc_write_cmd(slot, 0, cmd);\n\tif (retval)\n\t\tctrl_err(ctrl, \"%s: Write command failed!\\n\", __func__);\n\telse\n\t\tshpc_get_cur_bus_speed(ctrl);\n\n\treturn retval;\n}\n\nstatic irqreturn_t shpc_isr(int irq, void *dev_id)\n{\n\tstruct controller *ctrl = (struct controller *)dev_id;\n\tu32 serr_int, slot_reg, intr_loc, intr_loc2;\n\tint hp_slot;\n\n\t \n\tintr_loc = shpc_readl(ctrl, INTR_LOC);\n\tif (!intr_loc)\n\t\treturn IRQ_NONE;\n\n\tctrl_dbg(ctrl, \"%s: intr_loc = %x\\n\", __func__, intr_loc);\n\n\tif (!shpchp_poll_mode) {\n\t\t \n\t\tserr_int = shpc_readl(ctrl, SERR_INTR_ENABLE);\n\t\tserr_int |= GLOBAL_INTR_MASK;\n\t\tserr_int &= ~SERR_INTR_RSVDZ_MASK;\n\t\tshpc_writel(ctrl, SERR_INTR_ENABLE, serr_int);\n\n\t\tintr_loc2 = shpc_readl(ctrl, INTR_LOC);\n\t\tctrl_dbg(ctrl, \"%s: intr_loc2 = %x\\n\", __func__, intr_loc2);\n\t}\n\n\tif (intr_loc & CMD_INTR_PENDING) {\n\t\t \n\t\tserr_int = shpc_readl(ctrl, SERR_INTR_ENABLE);\n\t\tserr_int &= ~SERR_INTR_RSVDZ_MASK;\n\t\tshpc_writel(ctrl, SERR_INTR_ENABLE, serr_int);\n\n\t\twake_up_interruptible(&ctrl->queue);\n\t}\n\n\tif (!(intr_loc & ~CMD_INTR_PENDING))\n\t\tgoto out;\n\n\tfor (hp_slot = 0; hp_slot < ctrl->num_slots; hp_slot++) {\n\t\t \n\t\tif (!(intr_loc & SLOT_INTR_PENDING(hp_slot)))\n\t\t\tcontinue;\n\n\t\tslot_reg = shpc_readl(ctrl, SLOT_REG(hp_slot));\n\t\tctrl_dbg(ctrl, \"Slot %x with intr, slot register = %x\\n\",\n\t\t\t hp_slot, slot_reg);\n\n\t\tif (slot_reg & MRL_CHANGE_DETECTED)\n\t\t\tshpchp_handle_switch_change(hp_slot, ctrl);\n\n\t\tif (slot_reg & BUTTON_PRESS_DETECTED)\n\t\t\tshpchp_handle_attention_button(hp_slot, ctrl);\n\n\t\tif (slot_reg & PRSNT_CHANGE_DETECTED)\n\t\t\tshpchp_handle_presence_change(hp_slot, ctrl);\n\n\t\tif (slot_reg & (ISO_PFAULT_DETECTED | CON_PFAULT_DETECTED))\n\t\t\tshpchp_handle_power_fault(hp_slot, ctrl);\n\n\t\t \n\t\tslot_reg &= ~SLOT_REG_RSVDZ_MASK;\n\t\tshpc_writel(ctrl, SLOT_REG(hp_slot), slot_reg);\n\t}\n out:\n\tif (!shpchp_poll_mode) {\n\t\t \n\t\tserr_int = shpc_readl(ctrl, SERR_INTR_ENABLE);\n\t\tserr_int &= ~(GLOBAL_INTR_MASK | SERR_INTR_RSVDZ_MASK);\n\t\tshpc_writel(ctrl, SERR_INTR_ENABLE, serr_int);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int shpc_get_max_bus_speed(struct controller *ctrl)\n{\n\tint retval = 0;\n\tstruct pci_bus *bus = ctrl->pci_dev->subordinate;\n\tenum pci_bus_speed bus_speed = PCI_SPEED_UNKNOWN;\n\tu8 pi = shpc_readb(ctrl, PROG_INTERFACE);\n\tu32 slot_avail1 = shpc_readl(ctrl, SLOT_AVAIL1);\n\tu32 slot_avail2 = shpc_readl(ctrl, SLOT_AVAIL2);\n\n\tif (pi == 2) {\n\t\tif (slot_avail2 & SLOT_133MHZ_PCIX_533)\n\t\t\tbus_speed = PCI_SPEED_133MHz_PCIX_533;\n\t\telse if (slot_avail2 & SLOT_100MHZ_PCIX_533)\n\t\t\tbus_speed = PCI_SPEED_100MHz_PCIX_533;\n\t\telse if (slot_avail2 & SLOT_66MHZ_PCIX_533)\n\t\t\tbus_speed = PCI_SPEED_66MHz_PCIX_533;\n\t\telse if (slot_avail2 & SLOT_133MHZ_PCIX_266)\n\t\t\tbus_speed = PCI_SPEED_133MHz_PCIX_266;\n\t\telse if (slot_avail2 & SLOT_100MHZ_PCIX_266)\n\t\t\tbus_speed = PCI_SPEED_100MHz_PCIX_266;\n\t\telse if (slot_avail2 & SLOT_66MHZ_PCIX_266)\n\t\t\tbus_speed = PCI_SPEED_66MHz_PCIX_266;\n\t}\n\n\tif (bus_speed == PCI_SPEED_UNKNOWN) {\n\t\tif (slot_avail1 & SLOT_133MHZ_PCIX)\n\t\t\tbus_speed = PCI_SPEED_133MHz_PCIX;\n\t\telse if (slot_avail1 & SLOT_100MHZ_PCIX)\n\t\t\tbus_speed = PCI_SPEED_100MHz_PCIX;\n\t\telse if (slot_avail1 & SLOT_66MHZ_PCIX)\n\t\t\tbus_speed = PCI_SPEED_66MHz_PCIX;\n\t\telse if (slot_avail2 & SLOT_66MHZ)\n\t\t\tbus_speed = PCI_SPEED_66MHz;\n\t\telse if (slot_avail1 & SLOT_33MHZ)\n\t\t\tbus_speed = PCI_SPEED_33MHz;\n\t\telse\n\t\t\tretval = -ENODEV;\n\t}\n\n\tbus->max_bus_speed = bus_speed;\n\tctrl_dbg(ctrl, \"Max bus speed = %d\\n\", bus_speed);\n\n\treturn retval;\n}\n\nstatic const struct hpc_ops shpchp_hpc_ops = {\n\t.power_on_slot\t\t\t= hpc_power_on_slot,\n\t.slot_enable\t\t\t= hpc_slot_enable,\n\t.slot_disable\t\t\t= hpc_slot_disable,\n\t.set_bus_speed_mode\t\t= hpc_set_bus_speed_mode,\n\t.set_attention_status\t= hpc_set_attention_status,\n\t.get_power_status\t\t= hpc_get_power_status,\n\t.get_attention_status\t= hpc_get_attention_status,\n\t.get_latch_status\t\t= hpc_get_latch_status,\n\t.get_adapter_status\t\t= hpc_get_adapter_status,\n\n\t.get_adapter_speed\t\t= hpc_get_adapter_speed,\n\t.get_prog_int\t\t\t= hpc_get_prog_int,\n\n\t.query_power_fault\t\t= hpc_query_power_fault,\n\t.green_led_on\t\t\t= hpc_set_green_led_on,\n\t.green_led_off\t\t\t= hpc_set_green_led_off,\n\t.green_led_blink\t\t= hpc_set_green_led_blink,\n\n\t.release_ctlr\t\t\t= hpc_release_ctlr,\n};\n\nint shpc_init(struct controller *ctrl, struct pci_dev *pdev)\n{\n\tint rc = -1, num_slots = 0;\n\tu8 hp_slot;\n\tu32 shpc_base_offset;\n\tu32 tempdword, slot_reg, slot_config;\n\tu8 i;\n\n\tctrl->pci_dev = pdev;   \n\tctrl_dbg(ctrl, \"Hotplug Controller:\\n\");\n\n\tif (pdev->vendor == PCI_VENDOR_ID_AMD &&\n\t    pdev->device == PCI_DEVICE_ID_AMD_GOLAM_7450) {\n\t\t \n\t\tctrl->mmio_base = pci_resource_start(pdev, 0);\n\t\tctrl->mmio_size = pci_resource_len(pdev, 0);\n\t} else {\n\t\tctrl->cap_offset = pci_find_capability(pdev, PCI_CAP_ID_SHPC);\n\t\tif (!ctrl->cap_offset) {\n\t\t\tctrl_err(ctrl, \"Cannot find PCI capability\\n\");\n\t\t\tgoto abort;\n\t\t}\n\t\tctrl_dbg(ctrl, \" cap_offset = %x\\n\", ctrl->cap_offset);\n\n\t\trc = shpc_indirect_read(ctrl, 0, &shpc_base_offset);\n\t\tif (rc) {\n\t\t\tctrl_err(ctrl, \"Cannot read base_offset\\n\");\n\t\t\tgoto abort;\n\t\t}\n\n\t\trc = shpc_indirect_read(ctrl, 3, &tempdword);\n\t\tif (rc) {\n\t\t\tctrl_err(ctrl, \"Cannot read slot config\\n\");\n\t\t\tgoto abort;\n\t\t}\n\t\tnum_slots = tempdword & SLOT_NUM;\n\t\tctrl_dbg(ctrl, \" num_slots (indirect) %x\\n\", num_slots);\n\n\t\tfor (i = 0; i < 9 + num_slots; i++) {\n\t\t\trc = shpc_indirect_read(ctrl, i, &tempdword);\n\t\t\tif (rc) {\n\t\t\t\tctrl_err(ctrl, \"Cannot read creg (index = %d)\\n\",\n\t\t\t\t\t i);\n\t\t\t\tgoto abort;\n\t\t\t}\n\t\t\tctrl_dbg(ctrl, \" offset %d: value %x\\n\", i, tempdword);\n\t\t}\n\n\t\tctrl->mmio_base =\n\t\t\tpci_resource_start(pdev, 0) + shpc_base_offset;\n\t\tctrl->mmio_size = 0x24 + 0x4 * num_slots;\n\t}\n\n\tctrl_info(ctrl, \"HPC vendor_id %x device_id %x ss_vid %x ss_did %x\\n\",\n\t\t  pdev->vendor, pdev->device, pdev->subsystem_vendor,\n\t\t  pdev->subsystem_device);\n\n\trc = pci_enable_device(pdev);\n\tif (rc) {\n\t\tctrl_err(ctrl, \"pci_enable_device failed\\n\");\n\t\tgoto abort;\n\t}\n\n\tif (!request_mem_region(ctrl->mmio_base, ctrl->mmio_size, MY_NAME)) {\n\t\tctrl_err(ctrl, \"Cannot reserve MMIO region\\n\");\n\t\trc = -1;\n\t\tgoto abort;\n\t}\n\n\tctrl->creg = ioremap(ctrl->mmio_base, ctrl->mmio_size);\n\tif (!ctrl->creg) {\n\t\tctrl_err(ctrl, \"Cannot remap MMIO region %lx @ %lx\\n\",\n\t\t\t ctrl->mmio_size, ctrl->mmio_base);\n\t\trelease_mem_region(ctrl->mmio_base, ctrl->mmio_size);\n\t\trc = -1;\n\t\tgoto abort;\n\t}\n\tctrl_dbg(ctrl, \"ctrl->creg %p\\n\", ctrl->creg);\n\n\tmutex_init(&ctrl->crit_sect);\n\tmutex_init(&ctrl->cmd_lock);\n\n\t \n\tinit_waitqueue_head(&ctrl->queue);\n\n\tctrl->hpc_ops = &shpchp_hpc_ops;\n\n\t \n\tslot_config = shpc_readl(ctrl, SLOT_CONFIG);\n\tctrl->slot_device_offset = (slot_config & FIRST_DEV_NUM) >> 8;\n\tctrl->num_slots = slot_config & SLOT_NUM;\n\tctrl->first_slot = (slot_config & PSN) >> 16;\n\tctrl->slot_num_inc = ((slot_config & UPDOWN) >> 29) ? 1 : -1;\n\n\t \n\ttempdword = shpc_readl(ctrl, SERR_INTR_ENABLE);\n\tctrl_dbg(ctrl, \"SERR_INTR_ENABLE = %x\\n\", tempdword);\n\ttempdword |= (GLOBAL_INTR_MASK  | GLOBAL_SERR_MASK |\n\t\t      COMMAND_INTR_MASK | ARBITER_SERR_MASK);\n\ttempdword &= ~SERR_INTR_RSVDZ_MASK;\n\tshpc_writel(ctrl, SERR_INTR_ENABLE, tempdword);\n\ttempdword = shpc_readl(ctrl, SERR_INTR_ENABLE);\n\tctrl_dbg(ctrl, \"SERR_INTR_ENABLE = %x\\n\", tempdword);\n\n\t \n\tfor (hp_slot = 0; hp_slot < ctrl->num_slots; hp_slot++) {\n\t\tslot_reg = shpc_readl(ctrl, SLOT_REG(hp_slot));\n\t\tctrl_dbg(ctrl, \"Default Logical Slot Register %d value %x\\n\",\n\t\t\t hp_slot, slot_reg);\n\t\tslot_reg |= (PRSNT_CHANGE_INTR_MASK | ISO_PFAULT_INTR_MASK |\n\t\t\t     BUTTON_PRESS_INTR_MASK | MRL_CHANGE_INTR_MASK |\n\t\t\t     CON_PFAULT_INTR_MASK   | MRL_CHANGE_SERR_MASK |\n\t\t\t     CON_PFAULT_SERR_MASK);\n\t\tslot_reg &= ~SLOT_REG_RSVDZ_MASK;\n\t\tshpc_writel(ctrl, SLOT_REG(hp_slot), slot_reg);\n\t}\n\n\tif (shpchp_poll_mode) {\n\t\t \n\t\ttimer_setup(&ctrl->poll_timer, int_poll_timeout, 0);\n\t\tstart_int_poll_timer(ctrl, 10);\n\t} else {\n\t\t \n\t\trc = pci_enable_msi(pdev);\n\t\tif (rc) {\n\t\t\tctrl_info(ctrl, \"Can't get msi for the hotplug controller\\n\");\n\t\t\tctrl_info(ctrl, \"Use INTx for the hotplug controller\\n\");\n\t\t} else {\n\t\t\tpci_set_master(pdev);\n\t\t}\n\n\t\trc = request_irq(ctrl->pci_dev->irq, shpc_isr, IRQF_SHARED,\n\t\t\t\t MY_NAME, (void *)ctrl);\n\t\tctrl_dbg(ctrl, \"request_irq %d (returns %d)\\n\",\n\t\t\t ctrl->pci_dev->irq, rc);\n\t\tif (rc) {\n\t\t\tctrl_err(ctrl, \"Can't get irq %d for the hotplug controller\\n\",\n\t\t\t\t ctrl->pci_dev->irq);\n\t\t\tgoto abort_iounmap;\n\t\t}\n\t}\n\tctrl_dbg(ctrl, \"HPC at %s irq=%x\\n\", pci_name(pdev), pdev->irq);\n\n\tshpc_get_max_bus_speed(ctrl);\n\tshpc_get_cur_bus_speed(ctrl);\n\n\t \n\tfor (hp_slot = 0; hp_slot < ctrl->num_slots; hp_slot++) {\n\t\tslot_reg = shpc_readl(ctrl, SLOT_REG(hp_slot));\n\t\tctrl_dbg(ctrl, \"Default Logical Slot Register %d value %x\\n\",\n\t\t\t hp_slot, slot_reg);\n\t\tslot_reg &= ~(PRSNT_CHANGE_INTR_MASK | ISO_PFAULT_INTR_MASK |\n\t\t\t      BUTTON_PRESS_INTR_MASK | MRL_CHANGE_INTR_MASK |\n\t\t\t      CON_PFAULT_INTR_MASK | SLOT_REG_RSVDZ_MASK);\n\t\tshpc_writel(ctrl, SLOT_REG(hp_slot), slot_reg);\n\t}\n\tif (!shpchp_poll_mode) {\n\t\t \n\t\ttempdword = shpc_readl(ctrl, SERR_INTR_ENABLE);\n\t\ttempdword &= ~(GLOBAL_INTR_MASK | COMMAND_INTR_MASK |\n\t\t\t       SERR_INTR_RSVDZ_MASK);\n\t\tshpc_writel(ctrl, SERR_INTR_ENABLE, tempdword);\n\t\ttempdword = shpc_readl(ctrl, SERR_INTR_ENABLE);\n\t\tctrl_dbg(ctrl, \"SERR_INTR_ENABLE = %x\\n\", tempdword);\n\t}\n\n\treturn 0;\n\n\t \nabort_iounmap:\n\tiounmap(ctrl->creg);\nabort:\n\treturn rc;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}