{
  "module_name": "pci_hotplug_core.c",
  "hash_id": "f9dda5ece00ad3687840aef2e333cb364fa2a5de8eea4bfc70984b73f2d7f4dd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/hotplug/pci_hotplug_core.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\t \n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/list.h>\n#include <linux/kobject.h>\n#include <linux/sysfs.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/pci.h>\n#include <linux/pci_hotplug.h>\n#include <linux/uaccess.h>\n#include \"../pci.h\"\n#include \"cpci_hotplug.h\"\n\n#define MY_NAME\t\"pci_hotplug\"\n\n#define dbg(fmt, arg...) do { if (debug) printk(KERN_DEBUG \"%s: %s: \" fmt, MY_NAME, __func__, ## arg); } while (0)\n#define err(format, arg...) printk(KERN_ERR \"%s: \" format, MY_NAME, ## arg)\n#define info(format, arg...) printk(KERN_INFO \"%s: \" format, MY_NAME, ## arg)\n#define warn(format, arg...) printk(KERN_WARNING \"%s: \" format, MY_NAME, ## arg)\n\n \nstatic bool debug;\n\nstatic LIST_HEAD(pci_hotplug_slot_list);\nstatic DEFINE_MUTEX(pci_hp_mutex);\n\n \n#define GET_STATUS(name, type)\t\\\nstatic int get_##name(struct hotplug_slot *slot, type *value)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tconst struct hotplug_slot_ops *ops = slot->ops;\t\t\t\\\n\tint retval = 0;\t\t\t\t\t\t\t\\\n\tif (!try_module_get(slot->owner))\t\t\t\t\\\n\t\treturn -ENODEV;\t\t\t\t\t\t\\\n\tif (ops->get_##name)\t\t\t\t\t\t\\\n\t\tretval = ops->get_##name(slot, value);\t\t\t\\\n\tmodule_put(slot->owner);\t\t\t\t\t\\\n\treturn retval;\t\t\t\t\t\t\t\\\n}\n\nGET_STATUS(power_status, u8)\nGET_STATUS(attention_status, u8)\nGET_STATUS(latch_status, u8)\nGET_STATUS(adapter_status, u8)\n\nstatic ssize_t power_read_file(struct pci_slot *pci_slot, char *buf)\n{\n\tint retval;\n\tu8 value;\n\n\tretval = get_power_status(pci_slot->hotplug, &value);\n\tif (retval)\n\t\treturn retval;\n\n\treturn sysfs_emit(buf, \"%d\\n\", value);\n}\n\nstatic ssize_t power_write_file(struct pci_slot *pci_slot, const char *buf,\n\t\t\t\tsize_t count)\n{\n\tstruct hotplug_slot *slot = pci_slot->hotplug;\n\tunsigned long lpower;\n\tu8 power;\n\tint retval = 0;\n\n\tlpower = simple_strtoul(buf, NULL, 10);\n\tpower = (u8)(lpower & 0xff);\n\tdbg(\"power = %d\\n\", power);\n\n\tif (!try_module_get(slot->owner)) {\n\t\tretval = -ENODEV;\n\t\tgoto exit;\n\t}\n\tswitch (power) {\n\tcase 0:\n\t\tif (slot->ops->disable_slot)\n\t\t\tretval = slot->ops->disable_slot(slot);\n\t\tbreak;\n\n\tcase 1:\n\t\tif (slot->ops->enable_slot)\n\t\t\tretval = slot->ops->enable_slot(slot);\n\t\tbreak;\n\n\tdefault:\n\t\terr(\"Illegal value specified for power\\n\");\n\t\tretval = -EINVAL;\n\t}\n\tmodule_put(slot->owner);\n\nexit:\n\tif (retval)\n\t\treturn retval;\n\treturn count;\n}\n\nstatic struct pci_slot_attribute hotplug_slot_attr_power = {\n\t.attr = {.name = \"power\", .mode = S_IFREG | S_IRUGO | S_IWUSR},\n\t.show = power_read_file,\n\t.store = power_write_file\n};\n\nstatic ssize_t attention_read_file(struct pci_slot *pci_slot, char *buf)\n{\n\tint retval;\n\tu8 value;\n\n\tretval = get_attention_status(pci_slot->hotplug, &value);\n\tif (retval)\n\t\treturn retval;\n\n\treturn sysfs_emit(buf, \"%d\\n\", value);\n}\n\nstatic ssize_t attention_write_file(struct pci_slot *pci_slot, const char *buf,\n\t\t\t\t    size_t count)\n{\n\tstruct hotplug_slot *slot = pci_slot->hotplug;\n\tconst struct hotplug_slot_ops *ops = slot->ops;\n\tunsigned long lattention;\n\tu8 attention;\n\tint retval = 0;\n\n\tlattention = simple_strtoul(buf, NULL, 10);\n\tattention = (u8)(lattention & 0xff);\n\tdbg(\" - attention = %d\\n\", attention);\n\n\tif (!try_module_get(slot->owner)) {\n\t\tretval = -ENODEV;\n\t\tgoto exit;\n\t}\n\tif (ops->set_attention_status)\n\t\tretval = ops->set_attention_status(slot, attention);\n\tmodule_put(slot->owner);\n\nexit:\n\tif (retval)\n\t\treturn retval;\n\treturn count;\n}\n\nstatic struct pci_slot_attribute hotplug_slot_attr_attention = {\n\t.attr = {.name = \"attention\", .mode = S_IFREG | S_IRUGO | S_IWUSR},\n\t.show = attention_read_file,\n\t.store = attention_write_file\n};\n\nstatic ssize_t latch_read_file(struct pci_slot *pci_slot, char *buf)\n{\n\tint retval;\n\tu8 value;\n\n\tretval = get_latch_status(pci_slot->hotplug, &value);\n\tif (retval)\n\t\treturn retval;\n\n\treturn sysfs_emit(buf, \"%d\\n\", value);\n}\n\nstatic struct pci_slot_attribute hotplug_slot_attr_latch = {\n\t.attr = {.name = \"latch\", .mode = S_IFREG | S_IRUGO},\n\t.show = latch_read_file,\n};\n\nstatic ssize_t presence_read_file(struct pci_slot *pci_slot, char *buf)\n{\n\tint retval;\n\tu8 value;\n\n\tretval = get_adapter_status(pci_slot->hotplug, &value);\n\tif (retval)\n\t\treturn retval;\n\n\treturn sysfs_emit(buf, \"%d\\n\", value);\n}\n\nstatic struct pci_slot_attribute hotplug_slot_attr_presence = {\n\t.attr = {.name = \"adapter\", .mode = S_IFREG | S_IRUGO},\n\t.show = presence_read_file,\n};\n\nstatic ssize_t test_write_file(struct pci_slot *pci_slot, const char *buf,\n\t\t\t       size_t count)\n{\n\tstruct hotplug_slot *slot = pci_slot->hotplug;\n\tunsigned long ltest;\n\tu32 test;\n\tint retval = 0;\n\n\tltest = simple_strtoul(buf, NULL, 10);\n\ttest = (u32)(ltest & 0xffffffff);\n\tdbg(\"test = %d\\n\", test);\n\n\tif (!try_module_get(slot->owner)) {\n\t\tretval = -ENODEV;\n\t\tgoto exit;\n\t}\n\tif (slot->ops->hardware_test)\n\t\tretval = slot->ops->hardware_test(slot, test);\n\tmodule_put(slot->owner);\n\nexit:\n\tif (retval)\n\t\treturn retval;\n\treturn count;\n}\n\nstatic struct pci_slot_attribute hotplug_slot_attr_test = {\n\t.attr = {.name = \"test\", .mode = S_IFREG | S_IRUGO | S_IWUSR},\n\t.store = test_write_file\n};\n\nstatic bool has_power_file(struct pci_slot *pci_slot)\n{\n\tstruct hotplug_slot *slot = pci_slot->hotplug;\n\n\tif ((!slot) || (!slot->ops))\n\t\treturn false;\n\tif ((slot->ops->enable_slot) ||\n\t    (slot->ops->disable_slot) ||\n\t    (slot->ops->get_power_status))\n\t\treturn true;\n\treturn false;\n}\n\nstatic bool has_attention_file(struct pci_slot *pci_slot)\n{\n\tstruct hotplug_slot *slot = pci_slot->hotplug;\n\n\tif ((!slot) || (!slot->ops))\n\t\treturn false;\n\tif ((slot->ops->set_attention_status) ||\n\t    (slot->ops->get_attention_status))\n\t\treturn true;\n\treturn false;\n}\n\nstatic bool has_latch_file(struct pci_slot *pci_slot)\n{\n\tstruct hotplug_slot *slot = pci_slot->hotplug;\n\n\tif ((!slot) || (!slot->ops))\n\t\treturn false;\n\tif (slot->ops->get_latch_status)\n\t\treturn true;\n\treturn false;\n}\n\nstatic bool has_adapter_file(struct pci_slot *pci_slot)\n{\n\tstruct hotplug_slot *slot = pci_slot->hotplug;\n\n\tif ((!slot) || (!slot->ops))\n\t\treturn false;\n\tif (slot->ops->get_adapter_status)\n\t\treturn true;\n\treturn false;\n}\n\nstatic bool has_test_file(struct pci_slot *pci_slot)\n{\n\tstruct hotplug_slot *slot = pci_slot->hotplug;\n\n\tif ((!slot) || (!slot->ops))\n\t\treturn false;\n\tif (slot->ops->hardware_test)\n\t\treturn true;\n\treturn false;\n}\n\nstatic int fs_add_slot(struct pci_slot *pci_slot)\n{\n\tint retval = 0;\n\n\t \n\tpci_hp_create_module_link(pci_slot);\n\n\tif (has_power_file(pci_slot)) {\n\t\tretval = sysfs_create_file(&pci_slot->kobj,\n\t\t\t\t\t   &hotplug_slot_attr_power.attr);\n\t\tif (retval)\n\t\t\tgoto exit_power;\n\t}\n\n\tif (has_attention_file(pci_slot)) {\n\t\tretval = sysfs_create_file(&pci_slot->kobj,\n\t\t\t\t\t   &hotplug_slot_attr_attention.attr);\n\t\tif (retval)\n\t\t\tgoto exit_attention;\n\t}\n\n\tif (has_latch_file(pci_slot)) {\n\t\tretval = sysfs_create_file(&pci_slot->kobj,\n\t\t\t\t\t   &hotplug_slot_attr_latch.attr);\n\t\tif (retval)\n\t\t\tgoto exit_latch;\n\t}\n\n\tif (has_adapter_file(pci_slot)) {\n\t\tretval = sysfs_create_file(&pci_slot->kobj,\n\t\t\t\t\t   &hotplug_slot_attr_presence.attr);\n\t\tif (retval)\n\t\t\tgoto exit_adapter;\n\t}\n\n\tif (has_test_file(pci_slot)) {\n\t\tretval = sysfs_create_file(&pci_slot->kobj,\n\t\t\t\t\t   &hotplug_slot_attr_test.attr);\n\t\tif (retval)\n\t\t\tgoto exit_test;\n\t}\n\n\tgoto exit;\n\nexit_test:\n\tif (has_adapter_file(pci_slot))\n\t\tsysfs_remove_file(&pci_slot->kobj,\n\t\t\t\t  &hotplug_slot_attr_presence.attr);\nexit_adapter:\n\tif (has_latch_file(pci_slot))\n\t\tsysfs_remove_file(&pci_slot->kobj, &hotplug_slot_attr_latch.attr);\nexit_latch:\n\tif (has_attention_file(pci_slot))\n\t\tsysfs_remove_file(&pci_slot->kobj,\n\t\t\t\t  &hotplug_slot_attr_attention.attr);\nexit_attention:\n\tif (has_power_file(pci_slot))\n\t\tsysfs_remove_file(&pci_slot->kobj, &hotplug_slot_attr_power.attr);\nexit_power:\n\tpci_hp_remove_module_link(pci_slot);\nexit:\n\treturn retval;\n}\n\nstatic void fs_remove_slot(struct pci_slot *pci_slot)\n{\n\tif (has_power_file(pci_slot))\n\t\tsysfs_remove_file(&pci_slot->kobj, &hotplug_slot_attr_power.attr);\n\n\tif (has_attention_file(pci_slot))\n\t\tsysfs_remove_file(&pci_slot->kobj,\n\t\t\t\t  &hotplug_slot_attr_attention.attr);\n\n\tif (has_latch_file(pci_slot))\n\t\tsysfs_remove_file(&pci_slot->kobj, &hotplug_slot_attr_latch.attr);\n\n\tif (has_adapter_file(pci_slot))\n\t\tsysfs_remove_file(&pci_slot->kobj,\n\t\t\t\t  &hotplug_slot_attr_presence.attr);\n\n\tif (has_test_file(pci_slot))\n\t\tsysfs_remove_file(&pci_slot->kobj, &hotplug_slot_attr_test.attr);\n\n\tpci_hp_remove_module_link(pci_slot);\n}\n\nstatic struct hotplug_slot *get_slot_from_name(const char *name)\n{\n\tstruct hotplug_slot *slot;\n\n\tlist_for_each_entry(slot, &pci_hotplug_slot_list, slot_list) {\n\t\tif (strcmp(hotplug_slot_name(slot), name) == 0)\n\t\t\treturn slot;\n\t}\n\treturn NULL;\n}\n\n \nint __pci_hp_register(struct hotplug_slot *slot, struct pci_bus *bus,\n\t\t      int devnr, const char *name,\n\t\t      struct module *owner, const char *mod_name)\n{\n\tint result;\n\n\tresult = __pci_hp_initialize(slot, bus, devnr, name, owner, mod_name);\n\tif (result)\n\t\treturn result;\n\n\tresult = pci_hp_add(slot);\n\tif (result)\n\t\tpci_hp_destroy(slot);\n\n\treturn result;\n}\nEXPORT_SYMBOL_GPL(__pci_hp_register);\n\n \nint __pci_hp_initialize(struct hotplug_slot *slot, struct pci_bus *bus,\n\t\t\tint devnr, const char *name, struct module *owner,\n\t\t\tconst char *mod_name)\n{\n\tstruct pci_slot *pci_slot;\n\n\tif (slot == NULL)\n\t\treturn -ENODEV;\n\tif (slot->ops == NULL)\n\t\treturn -EINVAL;\n\n\tslot->owner = owner;\n\tslot->mod_name = mod_name;\n\n\t \n\tpci_slot = pci_create_slot(bus, devnr, name, slot);\n\tif (IS_ERR(pci_slot))\n\t\treturn PTR_ERR(pci_slot);\n\n\tslot->pci_slot = pci_slot;\n\tpci_slot->hotplug = slot;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(__pci_hp_initialize);\n\n \nint pci_hp_add(struct hotplug_slot *slot)\n{\n\tstruct pci_slot *pci_slot = slot->pci_slot;\n\tint result;\n\n\tresult = fs_add_slot(pci_slot);\n\tif (result)\n\t\treturn result;\n\n\tkobject_uevent(&pci_slot->kobj, KOBJ_ADD);\n\tmutex_lock(&pci_hp_mutex);\n\tlist_add(&slot->slot_list, &pci_hotplug_slot_list);\n\tmutex_unlock(&pci_hp_mutex);\n\tdbg(\"Added slot %s to the list\\n\", hotplug_slot_name(slot));\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(pci_hp_add);\n\n \nvoid pci_hp_deregister(struct hotplug_slot *slot)\n{\n\tpci_hp_del(slot);\n\tpci_hp_destroy(slot);\n}\nEXPORT_SYMBOL_GPL(pci_hp_deregister);\n\n \nvoid pci_hp_del(struct hotplug_slot *slot)\n{\n\tstruct hotplug_slot *temp;\n\n\tif (WARN_ON(!slot))\n\t\treturn;\n\n\tmutex_lock(&pci_hp_mutex);\n\ttemp = get_slot_from_name(hotplug_slot_name(slot));\n\tif (WARN_ON(temp != slot)) {\n\t\tmutex_unlock(&pci_hp_mutex);\n\t\treturn;\n\t}\n\n\tlist_del(&slot->slot_list);\n\tmutex_unlock(&pci_hp_mutex);\n\tdbg(\"Removed slot %s from the list\\n\", hotplug_slot_name(slot));\n\tfs_remove_slot(slot->pci_slot);\n}\nEXPORT_SYMBOL_GPL(pci_hp_del);\n\n \nvoid pci_hp_destroy(struct hotplug_slot *slot)\n{\n\tstruct pci_slot *pci_slot = slot->pci_slot;\n\n\tslot->pci_slot = NULL;\n\tpci_slot->hotplug = NULL;\n\tpci_destroy_slot(pci_slot);\n}\nEXPORT_SYMBOL_GPL(pci_hp_destroy);\n\nstatic int __init pci_hotplug_init(void)\n{\n\tint result;\n\n\tresult = cpci_hotplug_init(debug);\n\tif (result) {\n\t\terr(\"cpci_hotplug_init with error %d\\n\", result);\n\t\treturn result;\n\t}\n\n\treturn result;\n}\ndevice_initcall(pci_hotplug_init);\n\n \nmodule_param(debug, bool, 0644);\nMODULE_PARM_DESC(debug, \"Debugging mode enabled or not\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}