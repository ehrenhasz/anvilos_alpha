{
  "module_name": "shpchp.h",
  "hash_id": "6b2a08ef74b61663b5c409397883252710d4a82a42c13839a12c90434f0665c9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/hotplug/shpchp.h",
  "human_readable_source": " \n \n#ifndef _SHPCHP_H\n#define _SHPCHP_H\n\n#include <linux/types.h>\n#include <linux/pci.h>\n#include <linux/pci_hotplug.h>\n#include <linux/delay.h>\n#include <linux/sched/signal.h>\t \n#include <linux/mutex.h>\n#include <linux/workqueue.h>\n\n#if !defined(MODULE)\n\t#define MY_NAME\t\"shpchp\"\n#else\n\t#define MY_NAME\tTHIS_MODULE->name\n#endif\n\nextern bool shpchp_poll_mode;\nextern int shpchp_poll_time;\nextern bool shpchp_debug;\n\n#define dbg(format, arg...)\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tif (shpchp_debug)\t\t\t\t\t\t\\\n\t\tprintk(KERN_DEBUG \"%s: \" format, MY_NAME, ## arg);\t\\\n} while (0)\n#define err(format, arg...)\t\t\t\t\t\t\\\n\tprintk(KERN_ERR \"%s: \" format, MY_NAME, ## arg)\n#define info(format, arg...)\t\t\t\t\t\t\\\n\tprintk(KERN_INFO \"%s: \" format, MY_NAME, ## arg)\n#define warn(format, arg...)\t\t\t\t\t\t\\\n\tprintk(KERN_WARNING \"%s: \" format, MY_NAME, ## arg)\n\n#define ctrl_dbg(ctrl, format, arg...)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tif (shpchp_debug)\t\t\t\t\t\\\n\t\t\tpci_printk(KERN_DEBUG, ctrl->pci_dev,\t\t\\\n\t\t\t\t\tformat, ## arg);\t\t\\\n\t} while (0)\n#define ctrl_err(ctrl, format, arg...)\t\t\t\t\t\\\n\tpci_err(ctrl->pci_dev, format, ## arg)\n#define ctrl_info(ctrl, format, arg...)\t\t\t\t\t\\\n\tpci_info(ctrl->pci_dev, format, ## arg)\n#define ctrl_warn(ctrl, format, arg...)\t\t\t\t\t\\\n\tpci_warn(ctrl->pci_dev, format, ## arg)\n\n\n#define SLOT_NAME_SIZE 10\nstruct slot {\n\tu8 bus;\n\tu8 device;\n\tu16 status;\n\tu32 number;\n\tu8 is_a_board;\n\tu8 state;\n\tu8 attention_save;\n\tu8 presence_save;\n\tu8 latch_save;\n\tu8 pwr_save;\n\tstruct controller *ctrl;\n\tconst struct hpc_ops *hpc_ops;\n\tstruct hotplug_slot hotplug_slot;\n\tstruct list_head\tslot_list;\n\tstruct delayed_work work;\t \n\tstruct mutex lock;\n\tstruct workqueue_struct *wq;\n\tu8 hp_slot;\n};\n\nstruct event_info {\n\tu32 event_type;\n\tstruct slot *p_slot;\n\tstruct work_struct work;\n};\n\nstruct controller {\n\tstruct mutex crit_sect;\t\t \n\tstruct mutex cmd_lock;\t\t \n\tint num_slots;\t\t\t \n\tint slot_num_inc;\t\t \n\tstruct pci_dev *pci_dev;\n\tstruct list_head slot_list;\n\tconst struct hpc_ops *hpc_ops;\n\twait_queue_head_t queue;\t \n\tu8 slot_device_offset;\n\tu32 pcix_misc2_reg;\t \n\tu32 first_slot;\t\t \n\tu32 cap_offset;\n\tunsigned long mmio_base;\n\tunsigned long mmio_size;\n\tvoid __iomem *creg;\n\tstruct timer_list poll_timer;\n};\n\n \n#define PCI_DEVICE_ID_AMD_POGO_7458\t0x7458\n\n \n#define PCIX_MEM_BASE_LIMIT_OFFSET\t0x1C\n#define PCIX_MISCII_OFFSET\t\t0x48\n#define PCIX_MISC_BRIDGE_ERRORS_OFFSET\t0x80\n\n \n#define PERRNONFATALENABLE_MASK\t\t0x00040000\n#define PERRFATALENABLE_MASK\t\t0x00080000\n#define PERRFLOODENABLE_MASK\t\t0x00100000\n#define SERRNONFATALENABLE_MASK\t\t0x00200000\n#define SERRFATALENABLE_MASK\t\t0x00400000\n\n \n#define PERR_OBSERVED_MASK\t\t0x00000001\n\n \n#define RSE_MASK\t\t\t0x40000000\n\n#define INT_BUTTON_IGNORE\t\t0\n#define INT_PRESENCE_ON\t\t\t1\n#define INT_PRESENCE_OFF\t\t2\n#define INT_SWITCH_CLOSE\t\t3\n#define INT_SWITCH_OPEN\t\t\t4\n#define INT_POWER_FAULT\t\t\t5\n#define INT_POWER_FAULT_CLEAR\t\t6\n#define INT_BUTTON_PRESS\t\t7\n#define INT_BUTTON_RELEASE\t\t8\n#define INT_BUTTON_CANCEL\t\t9\n\n#define STATIC_STATE\t\t\t0\n#define BLINKINGON_STATE\t\t1\n#define BLINKINGOFF_STATE\t\t2\n#define POWERON_STATE\t\t\t3\n#define POWEROFF_STATE\t\t\t4\n\n \n#define INTERLOCK_OPEN\t\t\t0x00000002\n#define ADD_NOT_SUPPORTED\t\t0x00000003\n#define CARD_FUNCTIONING\t\t0x00000005\n#define ADAPTER_NOT_SAME\t\t0x00000006\n#define NO_ADAPTER_PRESENT\t\t0x00000009\n#define NOT_ENOUGH_RESOURCES\t\t0x0000000B\n#define DEVICE_TYPE_NOT_SUPPORTED\t0x0000000C\n#define WRONG_BUS_FREQUENCY\t\t0x0000000D\n#define POWER_FAILURE\t\t\t0x0000000E\n\nint __must_check shpchp_create_ctrl_files(struct controller *ctrl);\nvoid shpchp_remove_ctrl_files(struct controller *ctrl);\nint shpchp_sysfs_enable_slot(struct slot *slot);\nint shpchp_sysfs_disable_slot(struct slot *slot);\nu8 shpchp_handle_attention_button(u8 hp_slot, struct controller *ctrl);\nu8 shpchp_handle_switch_change(u8 hp_slot, struct controller *ctrl);\nu8 shpchp_handle_presence_change(u8 hp_slot, struct controller *ctrl);\nu8 shpchp_handle_power_fault(u8 hp_slot, struct controller *ctrl);\nint shpchp_configure_device(struct slot *p_slot);\nvoid shpchp_unconfigure_device(struct slot *p_slot);\nvoid cleanup_slots(struct controller *ctrl);\nvoid shpchp_queue_pushbutton_work(struct work_struct *work);\nint shpc_init(struct controller *ctrl, struct pci_dev *pdev);\n\nstatic inline const char *slot_name(struct slot *slot)\n{\n\treturn hotplug_slot_name(&slot->hotplug_slot);\n}\n\nstruct ctrl_reg {\n\tvolatile u32 base_offset;\n\tvolatile u32 slot_avail1;\n\tvolatile u32 slot_avail2;\n\tvolatile u32 slot_config;\n\tvolatile u16 sec_bus_config;\n\tvolatile u8  msi_ctrl;\n\tvolatile u8  prog_interface;\n\tvolatile u16 cmd;\n\tvolatile u16 cmd_status;\n\tvolatile u32 intr_loc;\n\tvolatile u32 serr_loc;\n\tvolatile u32 serr_intr_enable;\n\tvolatile u32 slot1;\n} __attribute__ ((packed));\n\n \nenum ctrl_offsets {\n\tBASE_OFFSET\t = offsetof(struct ctrl_reg, base_offset),\n\tSLOT_AVAIL1\t = offsetof(struct ctrl_reg, slot_avail1),\n\tSLOT_AVAIL2\t = offsetof(struct ctrl_reg, slot_avail2),\n\tSLOT_CONFIG\t = offsetof(struct ctrl_reg, slot_config),\n\tSEC_BUS_CONFIG\t = offsetof(struct ctrl_reg, sec_bus_config),\n\tMSI_CTRL\t = offsetof(struct ctrl_reg, msi_ctrl),\n\tPROG_INTERFACE\t = offsetof(struct ctrl_reg, prog_interface),\n\tCMD\t\t = offsetof(struct ctrl_reg, cmd),\n\tCMD_STATUS\t = offsetof(struct ctrl_reg, cmd_status),\n\tINTR_LOC\t = offsetof(struct ctrl_reg, intr_loc),\n\tSERR_LOC\t = offsetof(struct ctrl_reg, serr_loc),\n\tSERR_INTR_ENABLE = offsetof(struct ctrl_reg, serr_intr_enable),\n\tSLOT1\t\t = offsetof(struct ctrl_reg, slot1),\n};\n\nstatic inline struct slot *get_slot(struct hotplug_slot *hotplug_slot)\n{\n\treturn container_of(hotplug_slot, struct slot, hotplug_slot);\n}\n\nstatic inline struct slot *shpchp_find_slot(struct controller *ctrl, u8 device)\n{\n\tstruct slot *slot;\n\n\tlist_for_each_entry(slot, &ctrl->slot_list, slot_list) {\n\t\tif (slot->device == device)\n\t\t\treturn slot;\n\t}\n\n\tctrl_err(ctrl, \"Slot (device=0x%02x) not found\\n\", device);\n\treturn NULL;\n}\n\nstatic inline void amd_pogo_errata_save_misc_reg(struct slot *p_slot)\n{\n\tu32 pcix_misc2_temp;\n\n\t \n\tpci_read_config_dword(p_slot->ctrl->pci_dev, PCIX_MISCII_OFFSET, &pcix_misc2_temp);\n\n\tp_slot->ctrl->pcix_misc2_reg = pcix_misc2_temp;\n\n\t \n\tpcix_misc2_temp &= ~SERRFATALENABLE_MASK;\n\tpcix_misc2_temp &= ~SERRNONFATALENABLE_MASK;\n\tpcix_misc2_temp &= ~PERRFLOODENABLE_MASK;\n\tpcix_misc2_temp &= ~PERRFATALENABLE_MASK;\n\tpcix_misc2_temp &= ~PERRNONFATALENABLE_MASK;\n\tpci_write_config_dword(p_slot->ctrl->pci_dev, PCIX_MISCII_OFFSET, pcix_misc2_temp);\n}\n\nstatic inline void amd_pogo_errata_restore_misc_reg(struct slot *p_slot)\n{\n\tu32 pcix_misc2_temp;\n\tu32 pcix_bridge_errors_reg;\n\tu32 pcix_mem_base_reg;\n\tu8  perr_set;\n\tu8  rse_set;\n\n\t \n\tpci_read_config_dword(p_slot->ctrl->pci_dev, PCIX_MISC_BRIDGE_ERRORS_OFFSET, &pcix_bridge_errors_reg);\n\tperr_set = pcix_bridge_errors_reg & PERR_OBSERVED_MASK;\n\tif (perr_set) {\n\t\tctrl_dbg(p_slot->ctrl,\n\t\t\t \"Bridge_Errors[ PERR_OBSERVED = %08X] (W1C)\\n\",\n\t\t\t perr_set);\n\n\t\tpci_write_config_dword(p_slot->ctrl->pci_dev, PCIX_MISC_BRIDGE_ERRORS_OFFSET, perr_set);\n\t}\n\n\t \n\tpci_read_config_dword(p_slot->ctrl->pci_dev, PCIX_MEM_BASE_LIMIT_OFFSET, &pcix_mem_base_reg);\n\trse_set = pcix_mem_base_reg & RSE_MASK;\n\tif (rse_set) {\n\t\tctrl_dbg(p_slot->ctrl, \"Memory_Base_Limit[ RSE ] (W1C)\\n\");\n\n\t\tpci_write_config_dword(p_slot->ctrl->pci_dev, PCIX_MEM_BASE_LIMIT_OFFSET, rse_set);\n\t}\n\t \n\tpci_read_config_dword(p_slot->ctrl->pci_dev, PCIX_MISCII_OFFSET, &pcix_misc2_temp);\n\n\tif (p_slot->ctrl->pcix_misc2_reg & SERRFATALENABLE_MASK)\n\t\tpcix_misc2_temp |= SERRFATALENABLE_MASK;\n\telse\n\t\tpcix_misc2_temp &= ~SERRFATALENABLE_MASK;\n\n\tif (p_slot->ctrl->pcix_misc2_reg & SERRNONFATALENABLE_MASK)\n\t\tpcix_misc2_temp |= SERRNONFATALENABLE_MASK;\n\telse\n\t\tpcix_misc2_temp &= ~SERRNONFATALENABLE_MASK;\n\n\tif (p_slot->ctrl->pcix_misc2_reg & PERRFLOODENABLE_MASK)\n\t\tpcix_misc2_temp |= PERRFLOODENABLE_MASK;\n\telse\n\t\tpcix_misc2_temp &= ~PERRFLOODENABLE_MASK;\n\n\tif (p_slot->ctrl->pcix_misc2_reg & PERRFATALENABLE_MASK)\n\t\tpcix_misc2_temp |= PERRFATALENABLE_MASK;\n\telse\n\t\tpcix_misc2_temp &= ~PERRFATALENABLE_MASK;\n\n\tif (p_slot->ctrl->pcix_misc2_reg & PERRNONFATALENABLE_MASK)\n\t\tpcix_misc2_temp |= PERRNONFATALENABLE_MASK;\n\telse\n\t\tpcix_misc2_temp &= ~PERRNONFATALENABLE_MASK;\n\tpci_write_config_dword(p_slot->ctrl->pci_dev, PCIX_MISCII_OFFSET, pcix_misc2_temp);\n}\n\nstruct hpc_ops {\n\tint (*power_on_slot)(struct slot *slot);\n\tint (*slot_enable)(struct slot *slot);\n\tint (*slot_disable)(struct slot *slot);\n\tint (*set_bus_speed_mode)(struct slot *slot, enum pci_bus_speed speed);\n\tint (*get_power_status)(struct slot *slot, u8 *status);\n\tint (*get_attention_status)(struct slot *slot, u8 *status);\n\tint (*set_attention_status)(struct slot *slot, u8 status);\n\tint (*get_latch_status)(struct slot *slot, u8 *status);\n\tint (*get_adapter_status)(struct slot *slot, u8 *status);\n\tint (*get_adapter_speed)(struct slot *slot, enum pci_bus_speed *speed);\n\tint (*get_prog_int)(struct slot *slot, u8 *prog_int);\n\tint (*query_power_fault)(struct slot *slot);\n\tvoid (*green_led_on)(struct slot *slot);\n\tvoid (*green_led_off)(struct slot *slot);\n\tvoid (*green_led_blink)(struct slot *slot);\n\tvoid (*release_ctlr)(struct controller *ctrl);\n\tint (*check_cmd_status)(struct controller *ctrl);\n};\n\n#endif\t\t\t\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}