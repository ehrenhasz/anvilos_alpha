{
  "module_name": "cpqphp_core.c",
  "hash_id": "03ecb7564db46fa6377ad6e555ca83639f7190e3d6126897bf9233e2b0a75796",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/hotplug/cpqphp_core.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/proc_fs.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/pci.h>\n#include <linux/pci_hotplug.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n\n#include <linux/uaccess.h>\n\n#include \"cpqphp.h\"\n#include \"cpqphp_nvram.h\"\n\n\n \nint cpqhp_debug;\nint cpqhp_legacy_mode;\nstruct controller *cpqhp_ctrl_list;\t \nstruct pci_func *cpqhp_slot_list[256];\nstruct irq_routing_table *cpqhp_routing_table;\n\n \nstatic void __iomem *smbios_table;\nstatic void __iomem *smbios_start;\nstatic void __iomem *cpqhp_rom_start;\nstatic bool power_mode;\nstatic bool debug;\nstatic int initialized;\n\n#define DRIVER_VERSION\t\"0.9.8\"\n#define DRIVER_AUTHOR\t\"Dan Zink <dan.zink@compaq.com>, Greg Kroah-Hartman <greg@kroah.com>\"\n#define DRIVER_DESC\t\"Compaq Hot Plug PCI Controller Driver\"\n\nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n\nmodule_param(power_mode, bool, 0644);\nMODULE_PARM_DESC(power_mode, \"Power mode enabled or not\");\n\nmodule_param(debug, bool, 0644);\nMODULE_PARM_DESC(debug, \"Debugging mode enabled or not\");\n\n#define CPQHPC_MODULE_MINOR 208\n\nstatic inline int is_slot64bit(struct slot *slot)\n{\n\treturn (readb(slot->p_sm_slot + SMBIOS_SLOT_WIDTH) == 0x06) ? 1 : 0;\n}\n\nstatic inline int is_slot66mhz(struct slot *slot)\n{\n\treturn (readb(slot->p_sm_slot + SMBIOS_SLOT_TYPE) == 0x0E) ? 1 : 0;\n}\n\n \nstatic void __iomem *detect_SMBIOS_pointer(void __iomem *begin, void __iomem *end)\n{\n\tvoid __iomem *fp;\n\tvoid __iomem *endp;\n\tu8 temp1, temp2, temp3, temp4;\n\tint status = 0;\n\n\tendp = (end - sizeof(u32) + 1);\n\n\tfor (fp = begin; fp <= endp; fp += 16) {\n\t\ttemp1 = readb(fp);\n\t\ttemp2 = readb(fp+1);\n\t\ttemp3 = readb(fp+2);\n\t\ttemp4 = readb(fp+3);\n\t\tif (temp1 == '_' &&\n\t\t    temp2 == 'S' &&\n\t\t    temp3 == 'M' &&\n\t\t    temp4 == '_') {\n\t\t\tstatus = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!status)\n\t\tfp = NULL;\n\n\tdbg(\"Discovered SMBIOS Entry point at %p\\n\", fp);\n\n\treturn fp;\n}\n\n \nstatic int init_SERR(struct controller *ctrl)\n{\n\tu32 tempdword;\n\tu32 number_of_slots;\n\n\tif (!ctrl)\n\t\treturn 1;\n\n\ttempdword = ctrl->first_slot;\n\n\tnumber_of_slots = readb(ctrl->hpc_reg + SLOT_MASK) & 0x0F;\n\t \n\twhile (number_of_slots) {\n\t\twriteb(0, ctrl->hpc_reg + SLOT_SERR);\n\t\ttempdword++;\n\t\tnumber_of_slots--;\n\t}\n\n\treturn 0;\n}\n\nstatic int init_cpqhp_routing_table(void)\n{\n\tint len;\n\n\tcpqhp_routing_table = pcibios_get_irq_routing_table();\n\tif (cpqhp_routing_table == NULL)\n\t\treturn -ENOMEM;\n\n\tlen = cpqhp_routing_table_length();\n\tif (len == 0) {\n\t\tkfree(cpqhp_routing_table);\n\t\tcpqhp_routing_table = NULL;\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void pci_print_IRQ_route(void)\n{\n\tint len;\n\tint loop;\n\tu8 tbus, tdevice, tslot;\n\n\tlen = cpqhp_routing_table_length();\n\n\tdbg(\"bus dev func slot\\n\");\n\tfor (loop = 0; loop < len; ++loop) {\n\t\ttbus = cpqhp_routing_table->slots[loop].bus;\n\t\ttdevice = cpqhp_routing_table->slots[loop].devfn;\n\t\ttslot = cpqhp_routing_table->slots[loop].slot;\n\t\tdbg(\"%d %d %d %d\\n\", tbus, tdevice >> 3, tdevice & 0x7, tslot);\n\n\t}\n}\n\n\n \nstatic void __iomem *get_subsequent_smbios_entry(void __iomem *smbios_start,\n\t\t\t\t\t\tvoid __iomem *smbios_table,\n\t\t\t\t\t\tvoid __iomem *curr)\n{\n\tu8 bail = 0;\n\tu8 previous_byte = 1;\n\tvoid __iomem *p_temp;\n\tvoid __iomem *p_max;\n\n\tif (!smbios_table || !curr)\n\t\treturn NULL;\n\n\t \n\tp_max = smbios_start + readw(smbios_table + ST_LENGTH);\n\n\tp_temp = curr;\n\tp_temp += readb(curr + SMBIOS_GENERIC_LENGTH);\n\n\twhile ((p_temp < p_max) && !bail) {\n\t\t \n\t\tif (!previous_byte && !(readb(p_temp)))\n\t\t\tbail = 1;\n\n\t\tprevious_byte = readb(p_temp);\n\t\tp_temp++;\n\t}\n\n\tif (p_temp < p_max)\n\t\treturn p_temp;\n\telse\n\t\treturn NULL;\n}\n\n\n \nstatic void __iomem *get_SMBIOS_entry(void __iomem *smbios_start,\n\t\t\t\t\tvoid __iomem *smbios_table,\n\t\t\t\t\tu8 type,\n\t\t\t\t\tvoid __iomem *previous)\n{\n\tif (!smbios_table)\n\t\treturn NULL;\n\n\tif (!previous)\n\t\tprevious = smbios_start;\n\telse\n\t\tprevious = get_subsequent_smbios_entry(smbios_start,\n\t\t\t\t\tsmbios_table, previous);\n\n\twhile (previous)\n\t\tif (readb(previous + SMBIOS_GENERIC_TYPE) != type)\n\t\t\tprevious = get_subsequent_smbios_entry(smbios_start,\n\t\t\t\t\t\tsmbios_table, previous);\n\t\telse\n\t\t\tbreak;\n\n\treturn previous;\n}\n\nstatic int ctrl_slot_cleanup(struct controller *ctrl)\n{\n\tstruct slot *old_slot, *next_slot;\n\n\told_slot = ctrl->slot;\n\tctrl->slot = NULL;\n\n\twhile (old_slot) {\n\t\tnext_slot = old_slot->next;\n\t\tpci_hp_deregister(&old_slot->hotplug_slot);\n\t\tkfree(old_slot);\n\t\told_slot = next_slot;\n\t}\n\n\tcpqhp_remove_debugfs_files(ctrl);\n\n\t \n\tfree_irq(ctrl->interrupt, ctrl);\n\t \n\tiounmap(ctrl->hpc_reg);\n\t \n\trelease_mem_region(pci_resource_start(ctrl->pci_dev, 0),\n\t\t\t   pci_resource_len(ctrl->pci_dev, 0));\n\n\treturn 0;\n}\n\n\n \nstatic int\nget_slot_mapping(struct pci_bus *bus, u8 bus_num, u8 dev_num, u8 *slot)\n{\n\tu32 work;\n\tlong len;\n\tlong loop;\n\n\tu8 tbus, tdevice, tslot, bridgeSlot;\n\n\tdbg(\"%s: %p, %d, %d, %p\\n\", __func__, bus, bus_num, dev_num, slot);\n\n\tbridgeSlot = 0xFF;\n\n\tlen = cpqhp_routing_table_length();\n\tfor (loop = 0; loop < len; ++loop) {\n\t\ttbus = cpqhp_routing_table->slots[loop].bus;\n\t\ttdevice = cpqhp_routing_table->slots[loop].devfn >> 3;\n\t\ttslot = cpqhp_routing_table->slots[loop].slot;\n\n\t\tif ((tbus == bus_num) && (tdevice == dev_num)) {\n\t\t\t*slot = tslot;\n\t\t\treturn 0;\n\t\t} else {\n\t\t\t \n\t\t\tbus->number = tbus;\n\t\t\tpci_bus_read_config_dword(bus, PCI_DEVFN(tdevice, 0),\n\t\t\t\t\t\tPCI_CLASS_REVISION, &work);\n\n\t\t\tif ((work >> 8) == PCI_TO_PCI_BRIDGE_CLASS) {\n\t\t\t\tpci_bus_read_config_dword(bus,\n\t\t\t\t\t\t\tPCI_DEVFN(tdevice, 0),\n\t\t\t\t\t\t\tPCI_PRIMARY_BUS, &work);\n\t\t\t\t \n\t\t\t\tif (((work >> 8) & 0x000000FF) == (long) bus_num)\n\t\t\t\t\tbridgeSlot = tslot;\n\t\t\t}\n\t\t}\n\n\t}\n\n\t \n\tif (bridgeSlot != 0xFF) {\n\t\t*slot = bridgeSlot;\n\t\treturn 0;\n\t}\n\t \n\treturn -1;\n}\n\n\n \nstatic int\ncpqhp_set_attention_status(struct controller *ctrl, struct pci_func *func,\n\t\t\t\tu32 status)\n{\n\tu8 hp_slot;\n\n\tif (func == NULL)\n\t\treturn 1;\n\n\thp_slot = func->device - ctrl->slot_device_offset;\n\n\t \n\tmutex_lock(&ctrl->crit_sect);\n\n\tif (status == 1)\n\t\tamber_LED_on(ctrl, hp_slot);\n\telse if (status == 0)\n\t\tamber_LED_off(ctrl, hp_slot);\n\telse {\n\t\t \n\t\tmutex_unlock(&ctrl->crit_sect);\n\t\treturn 1;\n\t}\n\n\tset_SOGO(ctrl);\n\n\t \n\twait_for_ctrl_irq(ctrl);\n\n\t \n\tmutex_unlock(&ctrl->crit_sect);\n\n\treturn 0;\n}\n\n\n \nstatic int set_attention_status(struct hotplug_slot *hotplug_slot, u8 status)\n{\n\tstruct pci_func *slot_func;\n\tstruct slot *slot = to_slot(hotplug_slot);\n\tstruct controller *ctrl = slot->ctrl;\n\tu8 bus;\n\tu8 devfn;\n\tu8 device;\n\tu8 function;\n\n\tdbg(\"%s - physical_slot = %s\\n\", __func__, slot_name(slot));\n\n\tif (cpqhp_get_bus_dev(ctrl, &bus, &devfn, slot->number) == -1)\n\t\treturn -ENODEV;\n\n\tdevice = devfn >> 3;\n\tfunction = devfn & 0x7;\n\tdbg(\"bus, dev, fn = %d, %d, %d\\n\", bus, device, function);\n\n\tslot_func = cpqhp_slot_find(bus, device, function);\n\tif (!slot_func)\n\t\treturn -ENODEV;\n\n\treturn cpqhp_set_attention_status(ctrl, slot_func, status);\n}\n\n\nstatic int process_SI(struct hotplug_slot *hotplug_slot)\n{\n\tstruct pci_func *slot_func;\n\tstruct slot *slot = to_slot(hotplug_slot);\n\tstruct controller *ctrl = slot->ctrl;\n\tu8 bus;\n\tu8 devfn;\n\tu8 device;\n\tu8 function;\n\n\tdbg(\"%s - physical_slot = %s\\n\", __func__, slot_name(slot));\n\n\tif (cpqhp_get_bus_dev(ctrl, &bus, &devfn, slot->number) == -1)\n\t\treturn -ENODEV;\n\n\tdevice = devfn >> 3;\n\tfunction = devfn & 0x7;\n\tdbg(\"bus, dev, fn = %d, %d, %d\\n\", bus, device, function);\n\n\tslot_func = cpqhp_slot_find(bus, device, function);\n\tif (!slot_func)\n\t\treturn -ENODEV;\n\n\tslot_func->bus = bus;\n\tslot_func->device = device;\n\tslot_func->function = function;\n\tslot_func->configured = 0;\n\tdbg(\"board_added(%p, %p)\\n\", slot_func, ctrl);\n\treturn cpqhp_process_SI(ctrl, slot_func);\n}\n\n\nstatic int process_SS(struct hotplug_slot *hotplug_slot)\n{\n\tstruct pci_func *slot_func;\n\tstruct slot *slot = to_slot(hotplug_slot);\n\tstruct controller *ctrl = slot->ctrl;\n\tu8 bus;\n\tu8 devfn;\n\tu8 device;\n\tu8 function;\n\n\tdbg(\"%s - physical_slot = %s\\n\", __func__, slot_name(slot));\n\n\tif (cpqhp_get_bus_dev(ctrl, &bus, &devfn, slot->number) == -1)\n\t\treturn -ENODEV;\n\n\tdevice = devfn >> 3;\n\tfunction = devfn & 0x7;\n\tdbg(\"bus, dev, fn = %d, %d, %d\\n\", bus, device, function);\n\n\tslot_func = cpqhp_slot_find(bus, device, function);\n\tif (!slot_func)\n\t\treturn -ENODEV;\n\n\tdbg(\"In %s, slot_func = %p, ctrl = %p\\n\", __func__, slot_func, ctrl);\n\treturn cpqhp_process_SS(ctrl, slot_func);\n}\n\n\nstatic int hardware_test(struct hotplug_slot *hotplug_slot, u32 value)\n{\n\tstruct slot *slot = to_slot(hotplug_slot);\n\tstruct controller *ctrl = slot->ctrl;\n\n\tdbg(\"%s - physical_slot = %s\\n\", __func__, slot_name(slot));\n\n\treturn cpqhp_hardware_test(ctrl, value);\n}\n\n\nstatic int get_power_status(struct hotplug_slot *hotplug_slot, u8 *value)\n{\n\tstruct slot *slot = to_slot(hotplug_slot);\n\tstruct controller *ctrl = slot->ctrl;\n\n\tdbg(\"%s - physical_slot = %s\\n\", __func__, slot_name(slot));\n\n\t*value = get_slot_enabled(ctrl, slot);\n\treturn 0;\n}\n\nstatic int get_attention_status(struct hotplug_slot *hotplug_slot, u8 *value)\n{\n\tstruct slot *slot = to_slot(hotplug_slot);\n\tstruct controller *ctrl = slot->ctrl;\n\n\tdbg(\"%s - physical_slot = %s\\n\", __func__, slot_name(slot));\n\n\t*value = cpq_get_attention_status(ctrl, slot);\n\treturn 0;\n}\n\nstatic int get_latch_status(struct hotplug_slot *hotplug_slot, u8 *value)\n{\n\tstruct slot *slot = to_slot(hotplug_slot);\n\tstruct controller *ctrl = slot->ctrl;\n\n\tdbg(\"%s - physical_slot = %s\\n\", __func__, slot_name(slot));\n\n\t*value = cpq_get_latch_status(ctrl, slot);\n\n\treturn 0;\n}\n\nstatic int get_adapter_status(struct hotplug_slot *hotplug_slot, u8 *value)\n{\n\tstruct slot *slot = to_slot(hotplug_slot);\n\tstruct controller *ctrl = slot->ctrl;\n\n\tdbg(\"%s - physical_slot = %s\\n\", __func__, slot_name(slot));\n\n\t*value = get_presence_status(ctrl, slot);\n\n\treturn 0;\n}\n\nstatic const struct hotplug_slot_ops cpqphp_hotplug_slot_ops = {\n\t.set_attention_status =\tset_attention_status,\n\t.enable_slot =\t\tprocess_SI,\n\t.disable_slot =\t\tprocess_SS,\n\t.hardware_test =\thardware_test,\n\t.get_power_status =\tget_power_status,\n\t.get_attention_status =\tget_attention_status,\n\t.get_latch_status =\tget_latch_status,\n\t.get_adapter_status =\tget_adapter_status,\n};\n\n#define SLOT_NAME_SIZE 10\n\nstatic int ctrl_slot_setup(struct controller *ctrl,\n\t\t\tvoid __iomem *smbios_start,\n\t\t\tvoid __iomem *smbios_table)\n{\n\tstruct slot *slot;\n\tstruct pci_bus *bus = ctrl->pci_bus;\n\tu8 number_of_slots;\n\tu8 slot_device;\n\tu8 slot_number;\n\tu8 ctrl_slot;\n\tu32 tempdword;\n\tchar name[SLOT_NAME_SIZE];\n\tvoid __iomem *slot_entry = NULL;\n\tint result;\n\n\tdbg(\"%s\\n\", __func__);\n\n\ttempdword = readl(ctrl->hpc_reg + INT_INPUT_CLEAR);\n\n\tnumber_of_slots = readb(ctrl->hpc_reg + SLOT_MASK) & 0x0F;\n\tslot_device = readb(ctrl->hpc_reg + SLOT_MASK) >> 4;\n\tslot_number = ctrl->first_slot;\n\n\twhile (number_of_slots) {\n\t\tslot = kzalloc(sizeof(*slot), GFP_KERNEL);\n\t\tif (!slot) {\n\t\t\tresult = -ENOMEM;\n\t\t\tgoto error;\n\t\t}\n\n\t\tslot->ctrl = ctrl;\n\t\tslot->bus = ctrl->bus;\n\t\tslot->device = slot_device;\n\t\tslot->number = slot_number;\n\t\tdbg(\"slot->number = %u\\n\", slot->number);\n\n\t\tslot_entry = get_SMBIOS_entry(smbios_start, smbios_table, 9,\n\t\t\t\t\tslot_entry);\n\n\t\twhile (slot_entry && (readw(slot_entry + SMBIOS_SLOT_NUMBER) !=\n\t\t\t\tslot->number)) {\n\t\t\tslot_entry = get_SMBIOS_entry(smbios_start,\n\t\t\t\t\t\tsmbios_table, 9, slot_entry);\n\t\t}\n\n\t\tslot->p_sm_slot = slot_entry;\n\n\t\ttimer_setup(&slot->task_event, cpqhp_pushbutton_thread, 0);\n\t\tslot->task_event.expires = jiffies + 5 * HZ;\n\n\t\t \n\t\tslot->capabilities |= PCISLOT_REPLACE_SUPPORTED;\n\t\tslot->capabilities |= PCISLOT_INTERLOCK_SUPPORTED;\n\n\t\tif (is_slot64bit(slot))\n\t\t\tslot->capabilities |= PCISLOT_64_BIT_SUPPORTED;\n\t\tif (is_slot66mhz(slot))\n\t\t\tslot->capabilities |= PCISLOT_66_MHZ_SUPPORTED;\n\t\tif (bus->cur_bus_speed == PCI_SPEED_66MHz)\n\t\t\tslot->capabilities |= PCISLOT_66_MHZ_OPERATION;\n\n\t\tctrl_slot =\n\t\t\tslot_device - (readb(ctrl->hpc_reg + SLOT_MASK) >> 4);\n\n\t\t \n\t\tslot->capabilities |=\n\t\t\t((((~tempdword) >> 23) |\n\t\t\t ((~tempdword) >> 15)) >> ctrl_slot) & 0x02;\n\t\t \n\t\tslot->capabilities |=\n\t\t\t((~tempdword & 0xFF) >> ctrl_slot) & 0x01;\n\t\t \n\t\tslot->capabilities |=\n\t\t\t((read_slot_enable(ctrl) << 2) >> ctrl_slot) & 0x04;\n\n\t\t \n\t\tsnprintf(name, SLOT_NAME_SIZE, \"%u\", slot->number);\n\t\tslot->hotplug_slot.ops = &cpqphp_hotplug_slot_ops;\n\n\t\tdbg(\"registering bus %d, dev %d, number %d, ctrl->slot_device_offset %d, slot %d\\n\",\n\t\t\t\tslot->bus, slot->device,\n\t\t\t\tslot->number, ctrl->slot_device_offset,\n\t\t\t\tslot_number);\n\t\tresult = pci_hp_register(&slot->hotplug_slot,\n\t\t\t\t\t ctrl->pci_dev->bus,\n\t\t\t\t\t slot->device,\n\t\t\t\t\t name);\n\t\tif (result) {\n\t\t\terr(\"pci_hp_register failed with error %d\\n\", result);\n\t\t\tgoto error_slot;\n\t\t}\n\n\t\tslot->next = ctrl->slot;\n\t\tctrl->slot = slot;\n\n\t\tnumber_of_slots--;\n\t\tslot_device++;\n\t\tslot_number++;\n\t}\n\n\treturn 0;\nerror_slot:\n\tkfree(slot);\nerror:\n\treturn result;\n}\n\nstatic int one_time_init(void)\n{\n\tint loop;\n\tint retval = 0;\n\n\tif (initialized)\n\t\treturn 0;\n\n\tpower_mode = 0;\n\n\tretval = init_cpqhp_routing_table();\n\tif (retval)\n\t\tgoto error;\n\n\tif (cpqhp_debug)\n\t\tpci_print_IRQ_route();\n\n\tdbg(\"Initialize + Start the notification mechanism\\n\");\n\n\tretval = cpqhp_event_start_thread();\n\tif (retval)\n\t\tgoto error;\n\n\tdbg(\"Initialize slot lists\\n\");\n\tfor (loop = 0; loop < 256; loop++)\n\t\tcpqhp_slot_list[loop] = NULL;\n\n\t \n\t \n\tcpqhp_rom_start = ioremap(ROM_PHY_ADDR, ROM_PHY_LEN);\n\tif (!cpqhp_rom_start) {\n\t\terr(\"Could not ioremap memory region for ROM\\n\");\n\t\tretval = -EIO;\n\t\tgoto error;\n\t}\n\n\t \n\tcompaq_nvram_init(cpqhp_rom_start);\n\n\t \n\tsmbios_table = detect_SMBIOS_pointer(cpqhp_rom_start,\n\t\t\t\t\tcpqhp_rom_start + ROM_PHY_LEN);\n\tif (!smbios_table) {\n\t\terr(\"Could not find the SMBIOS pointer in memory\\n\");\n\t\tretval = -EIO;\n\t\tgoto error_rom_start;\n\t}\n\n\tsmbios_start = ioremap(readl(smbios_table + ST_ADDRESS),\n\t\t\t\t\treadw(smbios_table + ST_LENGTH));\n\tif (!smbios_start) {\n\t\terr(\"Could not ioremap memory region taken from SMBIOS values\\n\");\n\t\tretval = -EIO;\n\t\tgoto error_smbios_start;\n\t}\n\n\tinitialized = 1;\n\n\treturn retval;\n\nerror_smbios_start:\n\tiounmap(smbios_start);\nerror_rom_start:\n\tiounmap(cpqhp_rom_start);\nerror:\n\treturn retval;\n}\n\nstatic int cpqhpc_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tu8 num_of_slots = 0;\n\tu8 hp_slot = 0;\n\tu8 device;\n\tu8 bus_cap;\n\tu16 temp_word;\n\tu16 vendor_id;\n\tu16 subsystem_vid;\n\tu16 subsystem_deviceid;\n\tu32 rc;\n\tstruct controller *ctrl;\n\tstruct pci_func *func;\n\tstruct pci_bus *bus;\n\tint err;\n\n\terr = pci_enable_device(pdev);\n\tif (err) {\n\t\tprintk(KERN_ERR MY_NAME \": cannot enable PCI device %s (%d)\\n\",\n\t\t\tpci_name(pdev), err);\n\t\treturn err;\n\t}\n\n\tbus = pdev->subordinate;\n\tif (!bus) {\n\t\tpci_notice(pdev, \"the device is not a bridge, skipping\\n\");\n\t\trc = -ENODEV;\n\t\tgoto err_disable_device;\n\t}\n\n\t \n\tvendor_id = pdev->vendor;\n\tif ((vendor_id != PCI_VENDOR_ID_COMPAQ) &&\n\t    (vendor_id != PCI_VENDOR_ID_INTEL)) {\n\t\terr(msg_HPC_non_compaq_or_intel);\n\t\trc = -ENODEV;\n\t\tgoto err_disable_device;\n\t}\n\tdbg(\"Vendor ID: %x\\n\", vendor_id);\n\n\tdbg(\"revision: %d\\n\", pdev->revision);\n\tif ((vendor_id == PCI_VENDOR_ID_COMPAQ) && (!pdev->revision)) {\n\t\terr(msg_HPC_rev_error);\n\t\trc = -ENODEV;\n\t\tgoto err_disable_device;\n\t}\n\n\t \n\tif ((pdev->revision <= 2) && (vendor_id != PCI_VENDOR_ID_INTEL)) {\n\t\terr(msg_HPC_not_supported);\n\t\trc = -ENODEV;\n\t\tgoto err_disable_device;\n\t}\n\n\t \n\tsubsystem_vid = pdev->subsystem_vendor;\n\tdbg(\"Subsystem Vendor ID: %x\\n\", subsystem_vid);\n\tif ((subsystem_vid != PCI_VENDOR_ID_COMPAQ) && (subsystem_vid != PCI_VENDOR_ID_INTEL)) {\n\t\terr(msg_HPC_non_compaq_or_intel);\n\t\trc = -ENODEV;\n\t\tgoto err_disable_device;\n\t}\n\n\tctrl = kzalloc(sizeof(struct controller), GFP_KERNEL);\n\tif (!ctrl) {\n\t\trc = -ENOMEM;\n\t\tgoto err_disable_device;\n\t}\n\n\tsubsystem_deviceid = pdev->subsystem_device;\n\n\tinfo(\"Hot Plug Subsystem Device ID: %x\\n\", subsystem_deviceid);\n\n\t \n\tctrl->vendor_id = vendor_id;\n\n\tswitch (subsystem_vid) {\n\tcase PCI_VENDOR_ID_COMPAQ:\n\t\tif (pdev->revision >= 0x13) {  \n\t\t\tctrl->push_flag = 1;\n\t\t\tctrl->slot_switch_type = 1;\n\t\t\tctrl->push_button = 1;\n\t\t\tctrl->pci_config_space = 1;\n\t\t\tctrl->defeature_PHP = 1;\n\t\t\tctrl->pcix_support = 1;\n\t\t\tctrl->pcix_speed_capability = 1;\n\t\t\tpci_read_config_byte(pdev, 0x41, &bus_cap);\n\t\t\tif (bus_cap & 0x80) {\n\t\t\t\tdbg(\"bus max supports 133MHz PCI-X\\n\");\n\t\t\t\tbus->max_bus_speed = PCI_SPEED_133MHz_PCIX;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (bus_cap & 0x40) {\n\t\t\t\tdbg(\"bus max supports 100MHz PCI-X\\n\");\n\t\t\t\tbus->max_bus_speed = PCI_SPEED_100MHz_PCIX;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (bus_cap & 0x20) {\n\t\t\t\tdbg(\"bus max supports 66MHz PCI-X\\n\");\n\t\t\t\tbus->max_bus_speed = PCI_SPEED_66MHz_PCIX;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (bus_cap & 0x10) {\n\t\t\t\tdbg(\"bus max supports 66MHz PCI\\n\");\n\t\t\t\tbus->max_bus_speed = PCI_SPEED_66MHz;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (subsystem_deviceid) {\n\t\tcase PCI_SUB_HPC_ID:\n\t\t\t \n\t\t\tctrl->slot_switch_type = 1;\n\t\t\tbus->max_bus_speed = PCI_SPEED_33MHz;\n\t\t\tctrl->push_button = 0;\n\t\t\tctrl->pci_config_space = 1;\n\t\t\tctrl->defeature_PHP = 1;\n\t\t\tctrl->pcix_support = 0;\n\t\t\tctrl->pcix_speed_capability = 0;\n\t\t\tbreak;\n\t\tcase PCI_SUB_HPC_ID2:\n\t\t\t \n\t\t\tctrl->push_flag = 1;\n\t\t\tctrl->slot_switch_type = 1;\n\t\t\tbus->max_bus_speed = PCI_SPEED_33MHz;\n\t\t\tctrl->push_button = 1;\n\t\t\tctrl->pci_config_space = 1;\n\t\t\tctrl->defeature_PHP = 1;\n\t\t\tctrl->pcix_support = 0;\n\t\t\tctrl->pcix_speed_capability = 0;\n\t\t\tbreak;\n\t\tcase PCI_SUB_HPC_ID_INTC:\n\t\t\t \n\t\t\tctrl->slot_switch_type = 1;\n\t\t\tbus->max_bus_speed = PCI_SPEED_33MHz;\n\t\t\tctrl->push_button = 0;\n\t\t\tctrl->pci_config_space = 1;\n\t\t\tctrl->defeature_PHP = 1;\n\t\t\tctrl->pcix_support = 0;\n\t\t\tctrl->pcix_speed_capability = 0;\n\t\t\tbreak;\n\t\tcase PCI_SUB_HPC_ID3:\n\t\t\t \n\t\t\tctrl->push_flag = 1;\n\t\t\tctrl->slot_switch_type = 1;\n\t\t\tbus->max_bus_speed = PCI_SPEED_66MHz;\n\t\t\tctrl->push_button = 1;\n\t\t\tctrl->pci_config_space = 1;\n\t\t\tctrl->defeature_PHP = 1;\n\t\t\tctrl->pcix_support = 0;\n\t\t\tctrl->pcix_speed_capability = 0;\n\t\t\tbreak;\n\t\tcase PCI_SUB_HPC_ID4:\n\t\t\t \n\t\t\tctrl->push_flag = 1;\n\t\t\tctrl->slot_switch_type = 1;\n\t\t\tbus->max_bus_speed = PCI_SPEED_100MHz_PCIX;\n\t\t\tctrl->push_button = 1;\n\t\t\tctrl->pci_config_space = 1;\n\t\t\tctrl->defeature_PHP = 1;\n\t\t\tctrl->pcix_support = 1;\n\t\t\tctrl->pcix_speed_capability = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr(msg_HPC_not_supported);\n\t\t\trc = -ENODEV;\n\t\t\tgoto err_free_ctrl;\n\t\t}\n\t\tbreak;\n\n\tcase PCI_VENDOR_ID_INTEL:\n\t\t \n\t\tif (subsystem_deviceid & 0x0001)\n\t\t\tbus->max_bus_speed = PCI_SPEED_66MHz;\n\t\telse\n\t\t\tbus->max_bus_speed = PCI_SPEED_33MHz;\n\n\t\t \n\t\tif (subsystem_deviceid & 0x0002)\n\t\t\tctrl->push_button = 0;\n\t\telse\n\t\t\tctrl->push_button = 1;\n\n\t\t \n\t\tif (subsystem_deviceid & 0x0004)\n\t\t\tctrl->slot_switch_type = 0;\n\t\telse\n\t\t\tctrl->slot_switch_type = 1;\n\n\t\t \n\t\tif (subsystem_deviceid & 0x0008)\n\t\t\tctrl->defeature_PHP = 1;\t \n\t\telse\n\t\t\tctrl->defeature_PHP = 0;\t \n\n\t\t \n\t\tif (subsystem_deviceid & 0x0010)\n\t\t\tctrl->alternate_base_address = 1;\n\t\telse\n\t\t\tctrl->alternate_base_address = 0;\n\n\t\t \n\t\tif (subsystem_deviceid & 0x0020)\n\t\t\tctrl->pci_config_space = 1;\n\t\telse\n\t\t\tctrl->pci_config_space = 0;\n\n\t\t \n\t\tif (subsystem_deviceid & 0x0080) {\n\t\t\tctrl->pcix_support = 1;\n\t\t\tif (subsystem_deviceid & 0x0040)\n\t\t\t\t \n\t\t\t\tctrl->pcix_speed_capability = 1;\n\t\t\telse\n\t\t\t\t \n\t\t\t\t \n\t\t\t\tctrl->pcix_speed_capability = 0;\n\t\t} else {\n\t\t\t \n\t\t\tctrl->pcix_support = 0;\n\t\t\tctrl->pcix_speed_capability = 0;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\terr(msg_HPC_not_supported);\n\t\trc = -ENODEV;\n\t\tgoto err_free_ctrl;\n\t}\n\n\t \n\tinfo(\"Initializing the PCI hot plug controller residing on PCI bus %d\\n\",\n\t\t\t\t\tpdev->bus->number);\n\n\tdbg(\"Hotplug controller capabilities:\\n\");\n\tdbg(\"    speed_capability       %d\\n\", bus->max_bus_speed);\n\tdbg(\"    slot_switch_type       %s\\n\", ctrl->slot_switch_type ?\n\t\t\t\t\t\"switch present\" : \"no switch\");\n\tdbg(\"    defeature_PHP          %s\\n\", ctrl->defeature_PHP ?\n\t\t\t\t\t\"PHP supported\" : \"PHP not supported\");\n\tdbg(\"    alternate_base_address %s\\n\", ctrl->alternate_base_address ?\n\t\t\t\t\t\"supported\" : \"not supported\");\n\tdbg(\"    pci_config_space       %s\\n\", ctrl->pci_config_space ?\n\t\t\t\t\t\"supported\" : \"not supported\");\n\tdbg(\"    pcix_speed_capability  %s\\n\", ctrl->pcix_speed_capability ?\n\t\t\t\t\t\"supported\" : \"not supported\");\n\tdbg(\"    pcix_support           %s\\n\", ctrl->pcix_support ?\n\t\t\t\t\t\"supported\" : \"not supported\");\n\n\tctrl->pci_dev = pdev;\n\tpci_set_drvdata(pdev, ctrl);\n\n\t \n\tctrl->pci_bus = kmemdup(pdev->bus, sizeof(*ctrl->pci_bus), GFP_KERNEL);\n\tif (!ctrl->pci_bus) {\n\t\terr(\"out of memory\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto err_free_ctrl;\n\t}\n\n\tctrl->bus = pdev->bus->number;\n\tctrl->rev = pdev->revision;\n\tdbg(\"bus device function rev: %d %d %d %d\\n\", ctrl->bus,\n\t\tPCI_SLOT(pdev->devfn), PCI_FUNC(pdev->devfn), ctrl->rev);\n\n\tmutex_init(&ctrl->crit_sect);\n\tinit_waitqueue_head(&ctrl->queue);\n\n\t \n\trc = one_time_init();\n\tif (rc)\n\t\tgoto err_free_bus;\n\n\tdbg(\"pdev = %p\\n\", pdev);\n\tdbg(\"pci resource start %llx\\n\", (unsigned long long)pci_resource_start(pdev, 0));\n\tdbg(\"pci resource len %llx\\n\", (unsigned long long)pci_resource_len(pdev, 0));\n\n\tif (!request_mem_region(pci_resource_start(pdev, 0),\n\t\t\t\tpci_resource_len(pdev, 0), MY_NAME)) {\n\t\terr(\"cannot reserve MMIO region\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto err_free_bus;\n\t}\n\n\tctrl->hpc_reg = ioremap(pci_resource_start(pdev, 0),\n\t\t\t\t\tpci_resource_len(pdev, 0));\n\tif (!ctrl->hpc_reg) {\n\t\terr(\"cannot remap MMIO region %llx @ %llx\\n\",\n\t\t    (unsigned long long)pci_resource_len(pdev, 0),\n\t\t    (unsigned long long)pci_resource_start(pdev, 0));\n\t\trc = -ENODEV;\n\t\tgoto err_free_mem_region;\n\t}\n\n\t \n\tbus->cur_bus_speed = get_controller_speed(ctrl);\n\n\n\t \n\n\t \n\n\t \n\trc = get_slot_mapping(ctrl->pci_bus, pdev->bus->number,\n\t\t\t\t(readb(ctrl->hpc_reg + SLOT_MASK) >> 4),\n\t\t\t\t&(ctrl->first_slot));\n\tdbg(\"get_slot_mapping: first_slot = %d, returned = %d\\n\",\n\t\t\t\tctrl->first_slot, rc);\n\tif (rc) {\n\t\terr(msg_initialization_err, rc);\n\t\tgoto err_iounmap;\n\t}\n\n\t \n\trc = cpqhp_save_config(ctrl, ctrl->bus, readb(ctrl->hpc_reg + SLOT_MASK));\n\tif (rc) {\n\t\terr(\"%s: unable to save PCI configuration data, error %d\\n\",\n\t\t\t\t__func__, rc);\n\t\tgoto err_iounmap;\n\t}\n\n\t \n\t \n\tctrl->interrupt = pdev->irq;\n\tif (ctrl->interrupt < 0x10) {\n\t\tcpqhp_legacy_mode = 1;\n\t\tdbg(\"System seems to be configured for Full Table Mapped MPS mode\\n\");\n\t}\n\n\tctrl->cfgspc_irq = 0;\n\tpci_read_config_byte(pdev, PCI_INTERRUPT_LINE, &ctrl->cfgspc_irq);\n\n\trc = cpqhp_find_available_resources(ctrl, cpqhp_rom_start);\n\tctrl->add_support = !rc;\n\tif (rc) {\n\t\tdbg(\"cpqhp_find_available_resources = 0x%x\\n\", rc);\n\t\terr(\"unable to locate PCI configuration resources for hot plug add.\\n\");\n\t\tgoto err_iounmap;\n\t}\n\n\t \n\tctrl->slot_device_offset = readb(ctrl->hpc_reg + SLOT_MASK) >> 4;\n\tdbg(\"NumSlots %d\\n\", ctrl->slot_device_offset);\n\n\tctrl->next_event = 0;\n\n\t \n\trc = ctrl_slot_setup(ctrl, smbios_start, smbios_table);\n\tif (rc) {\n\t\terr(msg_initialization_err, 6);\n\t\terr(\"%s: unable to save PCI configuration data, error %d\\n\",\n\t\t\t__func__, rc);\n\t\tgoto err_iounmap;\n\t}\n\n\t \n\twritel(0xFFFFFFFFL, ctrl->hpc_reg + INT_MASK);\n\n\t \n\tdbg(\"HPC interrupt = %d\\n\", ctrl->interrupt);\n\tif (request_irq(ctrl->interrupt, cpqhp_ctrl_intr,\n\t\t\tIRQF_SHARED, MY_NAME, ctrl)) {\n\t\terr(\"Can't get irq %d for the hotplug pci controller\\n\",\n\t\t\tctrl->interrupt);\n\t\trc = -ENODEV;\n\t\tgoto err_iounmap;\n\t}\n\n\t \n\ttemp_word = readw(ctrl->hpc_reg + MISC);\n\ttemp_word |= 0x4006;\n\twritew(temp_word, ctrl->hpc_reg + MISC);\n\n\t \n\twritel(0xFFFFFFFFL, ctrl->hpc_reg + INT_INPUT_CLEAR);\n\n\tctrl->ctrl_int_comp = readl(ctrl->hpc_reg + INT_INPUT_CLEAR);\n\n\twritel(0x0L, ctrl->hpc_reg + INT_MASK);\n\n\tif (!cpqhp_ctrl_list) {\n\t\tcpqhp_ctrl_list = ctrl;\n\t\tctrl->next = NULL;\n\t} else {\n\t\tctrl->next = cpqhp_ctrl_list;\n\t\tcpqhp_ctrl_list = ctrl;\n\t}\n\n\t \n\tmutex_lock(&ctrl->crit_sect);\n\n\tnum_of_slots = readb(ctrl->hpc_reg + SLOT_MASK) & 0x0F;\n\n\t \n\tdevice = readb(ctrl->hpc_reg + SLOT_MASK) >> 4;\n\n\twhile (num_of_slots) {\n\t\tdbg(\"num_of_slots: %d\\n\", num_of_slots);\n\t\tfunc = cpqhp_slot_find(ctrl->bus, device, 0);\n\t\tif (!func)\n\t\t\tbreak;\n\n\t\thp_slot = func->device - ctrl->slot_device_offset;\n\t\tdbg(\"hp_slot: %d\\n\", hp_slot);\n\n\t\t \n\t\ttemp_word = ctrl->ctrl_int_comp >> 16;\n\t\tfunc->presence_save = (temp_word >> hp_slot) & 0x01;\n\t\tfunc->presence_save |= (temp_word >> (hp_slot + 7)) & 0x02;\n\n\t\tif (ctrl->ctrl_int_comp & (0x1L << hp_slot))\n\t\t\tfunc->switch_save = 0;\n\t\telse\n\t\t\tfunc->switch_save = 0x10;\n\n\t\tif (!power_mode)\n\t\t\tif (!func->is_a_board) {\n\t\t\t\tgreen_LED_off(ctrl, hp_slot);\n\t\t\t\tslot_disable(ctrl, hp_slot);\n\t\t\t}\n\n\t\tdevice++;\n\t\tnum_of_slots--;\n\t}\n\n\tif (!power_mode) {\n\t\tset_SOGO(ctrl);\n\t\t \n\t\twait_for_ctrl_irq(ctrl);\n\t}\n\n\trc = init_SERR(ctrl);\n\tif (rc) {\n\t\terr(\"init_SERR failed\\n\");\n\t\tmutex_unlock(&ctrl->crit_sect);\n\t\tgoto err_free_irq;\n\t}\n\n\t \n\tmutex_unlock(&ctrl->crit_sect);\n\n\tcpqhp_create_debugfs_files(ctrl);\n\n\treturn 0;\n\nerr_free_irq:\n\tfree_irq(ctrl->interrupt, ctrl);\nerr_iounmap:\n\tiounmap(ctrl->hpc_reg);\nerr_free_mem_region:\n\trelease_mem_region(pci_resource_start(pdev, 0), pci_resource_len(pdev, 0));\nerr_free_bus:\n\tkfree(ctrl->pci_bus);\nerr_free_ctrl:\n\tkfree(ctrl);\nerr_disable_device:\n\tpci_disable_device(pdev);\n\treturn rc;\n}\n\nstatic void __exit unload_cpqphpd(void)\n{\n\tstruct pci_func *next;\n\tstruct pci_func *TempSlot;\n\tint loop;\n\tu32 rc;\n\tstruct controller *ctrl;\n\tstruct controller *tctrl;\n\tstruct pci_resource *res;\n\tstruct pci_resource *tres;\n\n\tcompaq_nvram_store(cpqhp_rom_start);\n\n\tctrl = cpqhp_ctrl_list;\n\n\twhile (ctrl) {\n\t\tif (ctrl->hpc_reg) {\n\t\t\tu16 misc;\n\t\t\trc = read_slot_enable(ctrl);\n\n\t\t\twriteb(0, ctrl->hpc_reg + SLOT_SERR);\n\t\t\twritel(0xFFFFFFC0L | ~rc, ctrl->hpc_reg + INT_MASK);\n\n\t\t\tmisc = readw(ctrl->hpc_reg + MISC);\n\t\t\tmisc &= 0xFFFD;\n\t\t\twritew(misc, ctrl->hpc_reg + MISC);\n\t\t}\n\n\t\tctrl_slot_cleanup(ctrl);\n\n\t\tres = ctrl->io_head;\n\t\twhile (res) {\n\t\t\ttres = res;\n\t\t\tres = res->next;\n\t\t\tkfree(tres);\n\t\t}\n\n\t\tres = ctrl->mem_head;\n\t\twhile (res) {\n\t\t\ttres = res;\n\t\t\tres = res->next;\n\t\t\tkfree(tres);\n\t\t}\n\n\t\tres = ctrl->p_mem_head;\n\t\twhile (res) {\n\t\t\ttres = res;\n\t\t\tres = res->next;\n\t\t\tkfree(tres);\n\t\t}\n\n\t\tres = ctrl->bus_head;\n\t\twhile (res) {\n\t\t\ttres = res;\n\t\t\tres = res->next;\n\t\t\tkfree(tres);\n\t\t}\n\n\t\tkfree(ctrl->pci_bus);\n\n\t\ttctrl = ctrl;\n\t\tctrl = ctrl->next;\n\t\tkfree(tctrl);\n\t}\n\n\tfor (loop = 0; loop < 256; loop++) {\n\t\tnext = cpqhp_slot_list[loop];\n\t\twhile (next != NULL) {\n\t\t\tres = next->io_head;\n\t\t\twhile (res) {\n\t\t\t\ttres = res;\n\t\t\t\tres = res->next;\n\t\t\t\tkfree(tres);\n\t\t\t}\n\n\t\t\tres = next->mem_head;\n\t\t\twhile (res) {\n\t\t\t\ttres = res;\n\t\t\t\tres = res->next;\n\t\t\t\tkfree(tres);\n\t\t\t}\n\n\t\t\tres = next->p_mem_head;\n\t\t\twhile (res) {\n\t\t\t\ttres = res;\n\t\t\t\tres = res->next;\n\t\t\t\tkfree(tres);\n\t\t\t}\n\n\t\t\tres = next->bus_head;\n\t\t\twhile (res) {\n\t\t\t\ttres = res;\n\t\t\t\tres = res->next;\n\t\t\t\tkfree(tres);\n\t\t\t}\n\n\t\t\tTempSlot = next;\n\t\t\tnext = next->next;\n\t\t\tkfree(TempSlot);\n\t\t}\n\t}\n\n\t \n\tif (initialized)\n\t\tcpqhp_event_stop_thread();\n\n\t \n\tif (cpqhp_rom_start)\n\t\tiounmap(cpqhp_rom_start);\n\tif (smbios_start)\n\t\tiounmap(smbios_start);\n}\n\nstatic const struct pci_device_id hpcd_pci_tbl[] = {\n\t{\n\t \n\t.class =        ((PCI_CLASS_SYSTEM_PCI_HOTPLUG << 8) | 0x00),\n\t.class_mask =   ~0,\n\n\t \n\t.vendor =       PCI_ANY_ID,\n\t.device =       PCI_ANY_ID,\n\t.subvendor =    PCI_ANY_ID,\n\t.subdevice =    PCI_ANY_ID,\n\n\t}, {   }\n};\n\nMODULE_DEVICE_TABLE(pci, hpcd_pci_tbl);\n\nstatic struct pci_driver cpqhpc_driver = {\n\t.name =\t\t\"compaq_pci_hotplug\",\n\t.id_table =\thpcd_pci_tbl,\n\t.probe =\tcpqhpc_probe,\n\t \n};\n\nstatic int __init cpqhpc_init(void)\n{\n\tint result;\n\n\tcpqhp_debug = debug;\n\n\tinfo(DRIVER_DESC \" version: \" DRIVER_VERSION \"\\n\");\n\tcpqhp_initialize_debugfs();\n\tresult = pci_register_driver(&cpqhpc_driver);\n\tdbg(\"pci_register_driver = %d\\n\", result);\n\treturn result;\n}\n\nstatic void __exit cpqhpc_cleanup(void)\n{\n\tdbg(\"unload_cpqphpd()\\n\");\n\tunload_cpqphpd();\n\n\tdbg(\"pci_unregister_driver\\n\");\n\tpci_unregister_driver(&cpqhpc_driver);\n\tcpqhp_shutdown_debugfs();\n}\n\nmodule_init(cpqhpc_init);\nmodule_exit(cpqhpc_cleanup);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}