{
  "module_name": "ibmphp_core.c",
  "hash_id": "8965981486c11e9ee72b8090a680823c01676551e6cc2874303da48ec069331d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/hotplug/ibmphp_core.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n#include <linux/wait.h>\n#include \"../pci.h\"\n#include <asm/pci_x86.h>\t\t \n#include <asm/io_apic.h>\n#include \"ibmphp.h\"\n\n#define attn_on(sl)  ibmphp_hpc_writeslot(sl, HPC_SLOT_ATTNON)\n#define attn_off(sl) ibmphp_hpc_writeslot(sl, HPC_SLOT_ATTNOFF)\n#define attn_LED_blink(sl) ibmphp_hpc_writeslot(sl, HPC_SLOT_BLINKLED)\n#define get_ctrl_revision(sl, rev) ibmphp_hpc_readslot(sl, READ_REVLEVEL, rev)\n#define get_hpc_options(sl, opt) ibmphp_hpc_readslot(sl, READ_HPCOPTIONS, opt)\n\n#define DRIVER_VERSION\t\"0.6\"\n#define DRIVER_DESC\t\"IBM Hot Plug PCI Controller Driver\"\n\nint ibmphp_debug;\n\nstatic bool debug;\nmodule_param(debug, bool, S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(debug, \"Debugging mode enabled or not\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(DRIVER_DESC);\n\nstruct pci_bus *ibmphp_pci_bus;\nstatic int max_slots;\n\nstatic int irqs[16];     \n\nstatic int init_flag;\n\nstatic inline int get_cur_bus_info(struct slot **sl)\n{\n\tint rc = 1;\n\tstruct slot *slot_cur = *sl;\n\n\tdebug(\"options = %x\\n\", slot_cur->ctrl->options);\n\tdebug(\"revision = %x\\n\", slot_cur->ctrl->revision);\n\n\tif (READ_BUS_STATUS(slot_cur->ctrl))\n\t\trc = ibmphp_hpc_readslot(slot_cur, READ_BUSSTATUS, NULL);\n\n\tif (rc)\n\t\treturn rc;\n\n\tslot_cur->bus_on->current_speed = CURRENT_BUS_SPEED(slot_cur->busstatus);\n\tif (READ_BUS_MODE(slot_cur->ctrl))\n\t\tslot_cur->bus_on->current_bus_mode =\n\t\t\t\tCURRENT_BUS_MODE(slot_cur->busstatus);\n\telse\n\t\tslot_cur->bus_on->current_bus_mode = 0xFF;\n\n\tdebug(\"busstatus = %x, bus_speed = %x, bus_mode = %x\\n\",\n\t\t\tslot_cur->busstatus,\n\t\t\tslot_cur->bus_on->current_speed,\n\t\t\tslot_cur->bus_on->current_bus_mode);\n\n\t*sl = slot_cur;\n\treturn 0;\n}\n\nstatic inline int slot_update(struct slot **sl)\n{\n\tint rc;\n\trc = ibmphp_hpc_readslot(*sl, READ_ALLSTAT, NULL);\n\tif (rc)\n\t\treturn rc;\n\tif (!init_flag)\n\t\trc = get_cur_bus_info(sl);\n\treturn rc;\n}\n\nstatic int __init get_max_slots(void)\n{\n\tstruct slot *slot_cur;\n\tu8 slot_count = 0;\n\n\tlist_for_each_entry(slot_cur, &ibmphp_slot_head, ibm_slot_list) {\n\t\t \n\t\tslot_count = max(slot_count, slot_cur->number);\n\t}\n\treturn slot_count;\n}\n\n \nint ibmphp_init_devno(struct slot **cur_slot)\n{\n\tstruct irq_routing_table *rtable;\n\tint len;\n\tint loop;\n\tint i;\n\n\trtable = pcibios_get_irq_routing_table();\n\tif (!rtable) {\n\t\terr(\"no BIOS routing table...\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tlen = (rtable->size - sizeof(struct irq_routing_table)) /\n\t\t\tsizeof(struct irq_info);\n\n\tif (!len) {\n\t\tkfree(rtable);\n\t\treturn -1;\n\t}\n\tfor (loop = 0; loop < len; loop++) {\n\t\tif ((*cur_slot)->number == rtable->slots[loop].slot &&\n\t\t    (*cur_slot)->bus == rtable->slots[loop].bus) {\n\t\t\t(*cur_slot)->device = PCI_SLOT(rtable->slots[loop].devfn);\n\t\t\tfor (i = 0; i < 4; i++)\n\t\t\t\t(*cur_slot)->irq[i] = IO_APIC_get_PCI_irq_vector((int) (*cur_slot)->bus,\n\t\t\t\t\t\t(int) (*cur_slot)->device, i);\n\n\t\t\tdebug(\"(*cur_slot)->irq[0] = %x\\n\",\n\t\t\t\t\t(*cur_slot)->irq[0]);\n\t\t\tdebug(\"(*cur_slot)->irq[1] = %x\\n\",\n\t\t\t\t\t(*cur_slot)->irq[1]);\n\t\t\tdebug(\"(*cur_slot)->irq[2] = %x\\n\",\n\t\t\t\t\t(*cur_slot)->irq[2]);\n\t\t\tdebug(\"(*cur_slot)->irq[3] = %x\\n\",\n\t\t\t\t\t(*cur_slot)->irq[3]);\n\n\t\t\tdebug(\"rtable->exclusive_irqs = %x\\n\",\n\t\t\t\t\trtable->exclusive_irqs);\n\t\t\tdebug(\"rtable->slots[loop].irq[0].bitmap = %x\\n\",\n\t\t\t\t\trtable->slots[loop].irq[0].bitmap);\n\t\t\tdebug(\"rtable->slots[loop].irq[1].bitmap = %x\\n\",\n\t\t\t\t\trtable->slots[loop].irq[1].bitmap);\n\t\t\tdebug(\"rtable->slots[loop].irq[2].bitmap = %x\\n\",\n\t\t\t\t\trtable->slots[loop].irq[2].bitmap);\n\t\t\tdebug(\"rtable->slots[loop].irq[3].bitmap = %x\\n\",\n\t\t\t\t\trtable->slots[loop].irq[3].bitmap);\n\n\t\t\tdebug(\"rtable->slots[loop].irq[0].link = %x\\n\",\n\t\t\t\t\trtable->slots[loop].irq[0].link);\n\t\t\tdebug(\"rtable->slots[loop].irq[1].link = %x\\n\",\n\t\t\t\t\trtable->slots[loop].irq[1].link);\n\t\t\tdebug(\"rtable->slots[loop].irq[2].link = %x\\n\",\n\t\t\t\t\trtable->slots[loop].irq[2].link);\n\t\t\tdebug(\"rtable->slots[loop].irq[3].link = %x\\n\",\n\t\t\t\t\trtable->slots[loop].irq[3].link);\n\t\t\tdebug(\"end of init_devno\\n\");\n\t\t\tkfree(rtable);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tkfree(rtable);\n\treturn -1;\n}\n\nstatic inline int power_on(struct slot *slot_cur)\n{\n\tu8 cmd = HPC_SLOT_ON;\n\tint retval;\n\n\tretval = ibmphp_hpc_writeslot(slot_cur, cmd);\n\tif (retval) {\n\t\terr(\"power on failed\\n\");\n\t\treturn retval;\n\t}\n\tif (CTLR_RESULT(slot_cur->ctrl->status)) {\n\t\terr(\"command not completed successfully in power_on\\n\");\n\t\treturn -EIO;\n\t}\n\tmsleep(3000);\t \n\treturn 0;\n}\n\nstatic inline int power_off(struct slot *slot_cur)\n{\n\tu8 cmd = HPC_SLOT_OFF;\n\tint retval;\n\n\tretval = ibmphp_hpc_writeslot(slot_cur, cmd);\n\tif (retval) {\n\t\terr(\"power off failed\\n\");\n\t\treturn retval;\n\t}\n\tif (CTLR_RESULT(slot_cur->ctrl->status)) {\n\t\terr(\"command not completed successfully in power_off\\n\");\n\t\tretval = -EIO;\n\t}\n\treturn retval;\n}\n\nstatic int set_attention_status(struct hotplug_slot *hotplug_slot, u8 value)\n{\n\tint rc = 0;\n\tstruct slot *pslot;\n\tu8 cmd = 0x00;      \n\n\tdebug(\"set_attention_status - Entry hotplug_slot[%lx] value[%x]\\n\",\n\t\t\t(ulong) hotplug_slot, value);\n\tibmphp_lock_operations();\n\n\n\tif (hotplug_slot) {\n\t\tswitch (value) {\n\t\tcase HPC_SLOT_ATTN_OFF:\n\t\t\tcmd = HPC_SLOT_ATTNOFF;\n\t\t\tbreak;\n\t\tcase HPC_SLOT_ATTN_ON:\n\t\t\tcmd = HPC_SLOT_ATTNON;\n\t\t\tbreak;\n\t\tcase HPC_SLOT_ATTN_BLINK:\n\t\t\tcmd = HPC_SLOT_BLINKLED;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\trc = -ENODEV;\n\t\t\terr(\"set_attention_status - Error : invalid input [%x]\\n\",\n\t\t\t\t\tvalue);\n\t\t\tbreak;\n\t\t}\n\t\tif (rc == 0) {\n\t\t\tpslot = to_slot(hotplug_slot);\n\t\t\trc = ibmphp_hpc_writeslot(pslot, cmd);\n\t\t}\n\t} else\n\t\trc = -ENODEV;\n\n\tibmphp_unlock_operations();\n\n\tdebug(\"set_attention_status - Exit rc[%d]\\n\", rc);\n\treturn rc;\n}\n\nstatic int get_attention_status(struct hotplug_slot *hotplug_slot, u8 *value)\n{\n\tint rc = -ENODEV;\n\tstruct slot *pslot;\n\tstruct slot myslot;\n\n\tdebug(\"get_attention_status - Entry hotplug_slot[%lx] pvalue[%lx]\\n\",\n\t\t\t\t\t(ulong) hotplug_slot, (ulong) value);\n\n\tibmphp_lock_operations();\n\tif (hotplug_slot) {\n\t\tpslot = to_slot(hotplug_slot);\n\t\tmemcpy(&myslot, pslot, sizeof(struct slot));\n\t\trc = ibmphp_hpc_readslot(pslot, READ_SLOTSTATUS,\n\t\t\t\t\t &myslot.status);\n\t\tif (!rc)\n\t\t\trc = ibmphp_hpc_readslot(pslot, READ_EXTSLOTSTATUS,\n\t\t\t\t\t\t &myslot.ext_status);\n\t\tif (!rc)\n\t\t\t*value = SLOT_ATTN(myslot.status, myslot.ext_status);\n\t}\n\n\tibmphp_unlock_operations();\n\tdebug(\"get_attention_status - Exit rc[%d] value[%x]\\n\", rc, *value);\n\treturn rc;\n}\n\nstatic int get_latch_status(struct hotplug_slot *hotplug_slot, u8 *value)\n{\n\tint rc = -ENODEV;\n\tstruct slot *pslot;\n\tstruct slot myslot;\n\n\tdebug(\"get_latch_status - Entry hotplug_slot[%lx] pvalue[%lx]\\n\",\n\t\t\t\t\t(ulong) hotplug_slot, (ulong) value);\n\tibmphp_lock_operations();\n\tif (hotplug_slot) {\n\t\tpslot = to_slot(hotplug_slot);\n\t\tmemcpy(&myslot, pslot, sizeof(struct slot));\n\t\trc = ibmphp_hpc_readslot(pslot, READ_SLOTSTATUS,\n\t\t\t\t\t &myslot.status);\n\t\tif (!rc)\n\t\t\t*value = SLOT_LATCH(myslot.status);\n\t}\n\n\tibmphp_unlock_operations();\n\tdebug(\"get_latch_status - Exit rc[%d] rc[%x] value[%x]\\n\",\n\t\t\trc, rc, *value);\n\treturn rc;\n}\n\n\nstatic int get_power_status(struct hotplug_slot *hotplug_slot, u8 *value)\n{\n\tint rc = -ENODEV;\n\tstruct slot *pslot;\n\tstruct slot myslot;\n\n\tdebug(\"get_power_status - Entry hotplug_slot[%lx] pvalue[%lx]\\n\",\n\t\t\t\t\t(ulong) hotplug_slot, (ulong) value);\n\tibmphp_lock_operations();\n\tif (hotplug_slot) {\n\t\tpslot = to_slot(hotplug_slot);\n\t\tmemcpy(&myslot, pslot, sizeof(struct slot));\n\t\trc = ibmphp_hpc_readslot(pslot, READ_SLOTSTATUS,\n\t\t\t\t\t &myslot.status);\n\t\tif (!rc)\n\t\t\t*value = SLOT_PWRGD(myslot.status);\n\t}\n\n\tibmphp_unlock_operations();\n\tdebug(\"get_power_status - Exit rc[%d] rc[%x] value[%x]\\n\",\n\t\t\trc, rc, *value);\n\treturn rc;\n}\n\nstatic int get_adapter_present(struct hotplug_slot *hotplug_slot, u8 *value)\n{\n\tint rc = -ENODEV;\n\tstruct slot *pslot;\n\tu8 present;\n\tstruct slot myslot;\n\n\tdebug(\"get_adapter_status - Entry hotplug_slot[%lx] pvalue[%lx]\\n\",\n\t\t\t\t\t(ulong) hotplug_slot, (ulong) value);\n\tibmphp_lock_operations();\n\tif (hotplug_slot) {\n\t\tpslot = to_slot(hotplug_slot);\n\t\tmemcpy(&myslot, pslot, sizeof(struct slot));\n\t\trc = ibmphp_hpc_readslot(pslot, READ_SLOTSTATUS,\n\t\t\t\t\t &myslot.status);\n\t\tif (!rc) {\n\t\t\tpresent = SLOT_PRESENT(myslot.status);\n\t\t\tif (present == HPC_SLOT_EMPTY)\n\t\t\t\t*value = 0;\n\t\t\telse\n\t\t\t\t*value = 1;\n\t\t}\n\t}\n\n\tibmphp_unlock_operations();\n\tdebug(\"get_adapter_present - Exit rc[%d] value[%x]\\n\", rc, *value);\n\treturn rc;\n}\n\nstatic int get_max_bus_speed(struct slot *slot)\n{\n\tint rc = 0;\n\tu8 mode = 0;\n\tenum pci_bus_speed speed;\n\tstruct pci_bus *bus = slot->hotplug_slot.pci_slot->bus;\n\n\tdebug(\"%s - Entry slot[%p]\\n\", __func__, slot);\n\n\tibmphp_lock_operations();\n\tmode = slot->supported_bus_mode;\n\tspeed = slot->supported_speed;\n\tibmphp_unlock_operations();\n\n\tswitch (speed) {\n\tcase BUS_SPEED_33:\n\t\tbreak;\n\tcase BUS_SPEED_66:\n\t\tif (mode == BUS_MODE_PCIX)\n\t\t\tspeed += 0x01;\n\t\tbreak;\n\tcase BUS_SPEED_100:\n\tcase BUS_SPEED_133:\n\t\tspeed += 0x01;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\trc = -ENODEV;\n\t}\n\n\tif (!rc)\n\t\tbus->max_bus_speed = speed;\n\n\tdebug(\"%s - Exit rc[%d] speed[%x]\\n\", __func__, rc, speed);\n\treturn rc;\n}\n\n \nstatic int __init init_ops(void)\n{\n\tstruct slot *slot_cur;\n\tint retval;\n\tint rc;\n\n\tlist_for_each_entry(slot_cur, &ibmphp_slot_head, ibm_slot_list) {\n\t\tdebug(\"BEFORE GETTING SLOT STATUS, slot # %x\\n\",\n\t\t\t\t\t\t\tslot_cur->number);\n\t\tif (slot_cur->ctrl->revision == 0xFF)\n\t\t\tif (get_ctrl_revision(slot_cur,\n\t\t\t\t\t\t&slot_cur->ctrl->revision))\n\t\t\t\treturn -1;\n\n\t\tif (slot_cur->bus_on->current_speed == 0xFF)\n\t\t\tif (get_cur_bus_info(&slot_cur))\n\t\t\t\treturn -1;\n\t\tget_max_bus_speed(slot_cur);\n\n\t\tif (slot_cur->ctrl->options == 0xFF)\n\t\t\tif (get_hpc_options(slot_cur, &slot_cur->ctrl->options))\n\t\t\t\treturn -1;\n\n\t\tretval = slot_update(&slot_cur);\n\t\tif (retval)\n\t\t\treturn retval;\n\n\t\tdebug(\"status = %x\\n\", slot_cur->status);\n\t\tdebug(\"ext_status = %x\\n\", slot_cur->ext_status);\n\t\tdebug(\"SLOT_POWER = %x\\n\", SLOT_POWER(slot_cur->status));\n\t\tdebug(\"SLOT_PRESENT = %x\\n\", SLOT_PRESENT(slot_cur->status));\n\t\tdebug(\"SLOT_LATCH = %x\\n\", SLOT_LATCH(slot_cur->status));\n\n\t\tif ((SLOT_PWRGD(slot_cur->status)) &&\n\t\t    !(SLOT_PRESENT(slot_cur->status)) &&\n\t\t    !(SLOT_LATCH(slot_cur->status))) {\n\t\t\tdebug(\"BEFORE POWER OFF COMMAND\\n\");\n\t\t\t\trc = power_off(slot_cur);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\n\t \n\t\t}\n\t}\n\tinit_flag = 0;\n\treturn 0;\n}\n\n \nstatic int validate(struct slot *slot_cur, int opn)\n{\n\tint number;\n\tint retval;\n\n\tif (!slot_cur)\n\t\treturn -ENODEV;\n\tnumber = slot_cur->number;\n\tif ((number > max_slots) || (number < 0))\n\t\treturn -EBADSLT;\n\tdebug(\"slot_number in validate is %d\\n\", slot_cur->number);\n\n\tretval = slot_update(&slot_cur);\n\tif (retval)\n\t\treturn retval;\n\n\tswitch (opn) {\n\t\tcase ENABLE:\n\t\t\tif (!(SLOT_PWRGD(slot_cur->status)) &&\n\t\t\t     (SLOT_PRESENT(slot_cur->status)) &&\n\t\t\t     !(SLOT_LATCH(slot_cur->status)))\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tcase DISABLE:\n\t\t\tif ((SLOT_PWRGD(slot_cur->status)) &&\n\t\t\t    (SLOT_PRESENT(slot_cur->status)) &&\n\t\t\t    !(SLOT_LATCH(slot_cur->status)))\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\terr(\"validate failed....\\n\");\n\treturn -EINVAL;\n}\n\n \nint ibmphp_update_slot_info(struct slot *slot_cur)\n{\n\tstruct pci_bus *bus = slot_cur->hotplug_slot.pci_slot->bus;\n\tu8 bus_speed;\n\tu8 mode;\n\n\tbus_speed = slot_cur->bus_on->current_speed;\n\tmode = slot_cur->bus_on->current_bus_mode;\n\n\tswitch (bus_speed) {\n\t\tcase BUS_SPEED_33:\n\t\t\tbreak;\n\t\tcase BUS_SPEED_66:\n\t\t\tif (mode == BUS_MODE_PCIX)\n\t\t\t\tbus_speed += 0x01;\n\t\t\telse if (mode == BUS_MODE_PCI)\n\t\t\t\t;\n\t\t\telse\n\t\t\t\tbus_speed = PCI_SPEED_UNKNOWN;\n\t\t\tbreak;\n\t\tcase BUS_SPEED_100:\n\t\tcase BUS_SPEED_133:\n\t\t\tbus_speed += 0x01;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbus_speed = PCI_SPEED_UNKNOWN;\n\t}\n\n\tbus->cur_bus_speed = bus_speed;\n\t \n\n\treturn 0;\n}\n\n\n \n\nstatic struct pci_func *ibm_slot_find(u8 busno, u8 device, u8 function)\n{\n\tstruct pci_func *func_cur;\n\tstruct slot *slot_cur;\n\tlist_for_each_entry(slot_cur, &ibmphp_slot_head, ibm_slot_list) {\n\t\tif (slot_cur->func) {\n\t\t\tfunc_cur = slot_cur->func;\n\t\t\twhile (func_cur) {\n\t\t\t\tif ((func_cur->busno == busno) &&\n\t\t\t\t\t\t(func_cur->device == device) &&\n\t\t\t\t\t\t(func_cur->function == function))\n\t\t\t\t\treturn func_cur;\n\t\t\t\tfunc_cur = func_cur->next;\n\t\t\t}\n\t\t}\n\t}\n\treturn NULL;\n}\n\n \nstatic void free_slots(void)\n{\n\tstruct slot *slot_cur, *next;\n\n\tdebug(\"%s -- enter\\n\", __func__);\n\n\tlist_for_each_entry_safe(slot_cur, next, &ibmphp_slot_head,\n\t\t\t\t ibm_slot_list) {\n\t\tpci_hp_del(&slot_cur->hotplug_slot);\n\t\tslot_cur->ctrl = NULL;\n\t\tslot_cur->bus_on = NULL;\n\n\t\t \n\t\tibmphp_unconfigure_card(&slot_cur, -1);\n\n\t\tpci_hp_destroy(&slot_cur->hotplug_slot);\n\t\tkfree(slot_cur);\n\t}\n\tdebug(\"%s -- exit\\n\", __func__);\n}\n\nstatic void ibm_unconfigure_device(struct pci_func *func)\n{\n\tstruct pci_dev *temp;\n\tu8 j;\n\n\tdebug(\"inside %s\\n\", __func__);\n\tdebug(\"func->device = %x, func->function = %x\\n\",\n\t\t\t\t\tfunc->device, func->function);\n\tdebug(\"func->device << 3 | 0x0  = %x\\n\", func->device << 3 | 0x0);\n\n\tpci_lock_rescan_remove();\n\n\tfor (j = 0; j < 0x08; j++) {\n\t\ttemp = pci_get_domain_bus_and_slot(0, func->busno,\n\t\t\t\t\t\t   (func->device << 3) | j);\n\t\tif (temp) {\n\t\t\tpci_stop_and_remove_bus_device(temp);\n\t\t\tpci_dev_put(temp);\n\t\t}\n\t}\n\n\tpci_dev_put(func->dev);\n\n\tpci_unlock_rescan_remove();\n}\n\n \nstatic u8 bus_structure_fixup(u8 busno)\n{\n\tstruct pci_bus *bus, *b;\n\tstruct pci_dev *dev;\n\tu16 l;\n\n\tif (pci_find_bus(0, busno) || !(ibmphp_find_same_bus_num(busno)))\n\t\treturn 1;\n\n\tbus = kmalloc(sizeof(*bus), GFP_KERNEL);\n\tif (!bus)\n\t\treturn 1;\n\n\tdev = kmalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev) {\n\t\tkfree(bus);\n\t\treturn 1;\n\t}\n\n\tbus->number = busno;\n\tbus->ops = ibmphp_pci_bus->ops;\n\tdev->bus = bus;\n\tfor (dev->devfn = 0; dev->devfn < 256; dev->devfn += 8) {\n\t\tif (!pci_read_config_word(dev, PCI_VENDOR_ID, &l) &&\n\t\t\t\t\t(l != 0x0000) && (l != 0xffff)) {\n\t\t\tdebug(\"%s - Inside bus_structure_fixup()\\n\",\n\t\t\t\t\t\t\t__func__);\n\t\t\tb = pci_scan_bus(busno, ibmphp_pci_bus->ops, NULL);\n\t\t\tif (!b)\n\t\t\t\tcontinue;\n\n\t\t\tpci_bus_add_devices(b);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tkfree(dev);\n\tkfree(bus);\n\n\treturn 0;\n}\n\nstatic int ibm_configure_device(struct pci_func *func)\n{\n\tstruct pci_bus *child;\n\tint num;\n\tint flag = 0;\t \n\n\tpci_lock_rescan_remove();\n\n\tif (!(bus_structure_fixup(func->busno)))\n\t\tflag = 1;\n\tif (func->dev == NULL)\n\t\tfunc->dev = pci_get_domain_bus_and_slot(0, func->busno,\n\t\t\t\tPCI_DEVFN(func->device, func->function));\n\n\tif (func->dev == NULL) {\n\t\tstruct pci_bus *bus = pci_find_bus(0, func->busno);\n\t\tif (!bus)\n\t\t\tgoto out;\n\n\t\tnum = pci_scan_slot(bus,\n\t\t\t\tPCI_DEVFN(func->device, func->function));\n\t\tif (num)\n\t\t\tpci_bus_add_devices(bus);\n\n\t\tfunc->dev = pci_get_domain_bus_and_slot(0, func->busno,\n\t\t\t\tPCI_DEVFN(func->device, func->function));\n\t\tif (func->dev == NULL) {\n\t\t\terr(\"ERROR... : pci_dev still NULL\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif (!(flag) && (func->dev->hdr_type == PCI_HEADER_TYPE_BRIDGE)) {\n\t\tpci_hp_add_bridge(func->dev);\n\t\tchild = func->dev->subordinate;\n\t\tif (child)\n\t\t\tpci_bus_add_devices(child);\n\t}\n\n out:\n\tpci_unlock_rescan_remove();\n\treturn 0;\n}\n\n \nstatic int is_bus_empty(struct slot *slot_cur)\n{\n\tint rc;\n\tstruct slot *tmp_slot;\n\tu8 i = slot_cur->bus_on->slot_min;\n\n\twhile (i <= slot_cur->bus_on->slot_max) {\n\t\tif (i == slot_cur->number) {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\ttmp_slot = ibmphp_get_slot_from_physical_num(i);\n\t\tif (!tmp_slot)\n\t\t\treturn 0;\n\t\trc = slot_update(&tmp_slot);\n\t\tif (rc)\n\t\t\treturn 0;\n\t\tif (SLOT_PRESENT(tmp_slot->status) &&\n\t\t\t\t\tSLOT_PWRGD(tmp_slot->status))\n\t\t\treturn 0;\n\t\ti++;\n\t}\n\treturn 1;\n}\n\n \nstatic int set_bus(struct slot *slot_cur)\n{\n\tint rc;\n\tu8 speed;\n\tu8 cmd = 0x0;\n\tint retval;\n\tstatic const struct pci_device_id ciobx[] = {\n\t\t{ PCI_DEVICE(PCI_VENDOR_ID_SERVERWORKS, 0x0101) },\n\t\t{ },\n\t};\n\n\tdebug(\"%s - entry slot # %d\\n\", __func__, slot_cur->number);\n\tif (SET_BUS_STATUS(slot_cur->ctrl) && is_bus_empty(slot_cur)) {\n\t\trc = slot_update(&slot_cur);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tspeed = SLOT_SPEED(slot_cur->ext_status);\n\t\tdebug(\"ext_status = %x, speed = %x\\n\", slot_cur->ext_status, speed);\n\t\tswitch (speed) {\n\t\tcase HPC_SLOT_SPEED_33:\n\t\t\tcmd = HPC_BUS_33CONVMODE;\n\t\t\tbreak;\n\t\tcase HPC_SLOT_SPEED_66:\n\t\t\tif (SLOT_PCIX(slot_cur->ext_status)) {\n\t\t\t\tif ((slot_cur->supported_speed >= BUS_SPEED_66) &&\n\t\t\t\t\t\t(slot_cur->supported_bus_mode == BUS_MODE_PCIX))\n\t\t\t\t\tcmd = HPC_BUS_66PCIXMODE;\n\t\t\t\telse if (!SLOT_BUS_MODE(slot_cur->ext_status))\n\t\t\t\t\t \n\t\t\t\t\tcmd = HPC_BUS_66CONVMODE;\n\t\t\t\telse\n\t\t\t\t\tcmd = HPC_BUS_33CONVMODE;\n\t\t\t} else {\n\t\t\t\tif (slot_cur->supported_speed >= BUS_SPEED_66)\n\t\t\t\t\tcmd = HPC_BUS_66CONVMODE;\n\t\t\t\telse\n\t\t\t\t\tcmd = HPC_BUS_33CONVMODE;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase HPC_SLOT_SPEED_133:\n\t\t\tswitch (slot_cur->supported_speed) {\n\t\t\tcase BUS_SPEED_33:\n\t\t\t\tcmd = HPC_BUS_33CONVMODE;\n\t\t\t\tbreak;\n\t\t\tcase BUS_SPEED_66:\n\t\t\t\tif (slot_cur->supported_bus_mode == BUS_MODE_PCIX)\n\t\t\t\t\tcmd = HPC_BUS_66PCIXMODE;\n\t\t\t\telse\n\t\t\t\t\tcmd = HPC_BUS_66CONVMODE;\n\t\t\t\tbreak;\n\t\t\tcase BUS_SPEED_100:\n\t\t\t\tcmd = HPC_BUS_100PCIXMODE;\n\t\t\t\tbreak;\n\t\t\tcase BUS_SPEED_133:\n\t\t\t\t \n\t\t\t\tif (pci_dev_present(ciobx))\n\t\t\t\t\tibmphp_hpc_writeslot(slot_cur,\n\t\t\t\t\t\t\tHPC_BUS_100PCIXMODE);\n\t\t\t\tcmd = HPC_BUS_133PCIXMODE;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\terr(\"Wrong bus speed\\n\");\n\t\t\t\treturn -ENODEV;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr(\"wrong slot speed\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t\tdebug(\"setting bus speed for slot %d, cmd %x\\n\",\n\t\t\t\t\t\tslot_cur->number, cmd);\n\t\tretval = ibmphp_hpc_writeslot(slot_cur, cmd);\n\t\tif (retval) {\n\t\t\terr(\"setting bus speed failed\\n\");\n\t\t\treturn retval;\n\t\t}\n\t\tif (CTLR_RESULT(slot_cur->ctrl->status)) {\n\t\t\terr(\"command not completed successfully in set_bus\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\t \n\tmsleep(1000);\n\tdebug(\"%s -Exit\\n\", __func__);\n\treturn 0;\n}\n\n \nstatic int check_limitations(struct slot *slot_cur)\n{\n\tu8 i;\n\tstruct slot *tmp_slot;\n\tu8 count = 0;\n\tu8 limitation = 0;\n\n\tfor (i = slot_cur->bus_on->slot_min; i <= slot_cur->bus_on->slot_max; i++) {\n\t\ttmp_slot = ibmphp_get_slot_from_physical_num(i);\n\t\tif (!tmp_slot)\n\t\t\treturn -ENODEV;\n\t\tif ((SLOT_PWRGD(tmp_slot->status)) &&\n\t\t\t\t\t!(SLOT_CONNECT(tmp_slot->status)))\n\t\t\tcount++;\n\t}\n\tget_cur_bus_info(&slot_cur);\n\tswitch (slot_cur->bus_on->current_speed) {\n\tcase BUS_SPEED_33:\n\t\tlimitation = slot_cur->bus_on->slots_at_33_conv;\n\t\tbreak;\n\tcase BUS_SPEED_66:\n\t\tif (slot_cur->bus_on->current_bus_mode == BUS_MODE_PCIX)\n\t\t\tlimitation = slot_cur->bus_on->slots_at_66_pcix;\n\t\telse\n\t\t\tlimitation = slot_cur->bus_on->slots_at_66_conv;\n\t\tbreak;\n\tcase BUS_SPEED_100:\n\t\tlimitation = slot_cur->bus_on->slots_at_100_pcix;\n\t\tbreak;\n\tcase BUS_SPEED_133:\n\t\tlimitation = slot_cur->bus_on->slots_at_133_pcix;\n\t\tbreak;\n\t}\n\n\tif ((count + 1) > limitation)\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic inline void print_card_capability(struct slot *slot_cur)\n{\n\tinfo(\"capability of the card is \");\n\tif ((slot_cur->ext_status & CARD_INFO) == PCIX133)\n\t\tinfo(\"   133 MHz PCI-X\\n\");\n\telse if ((slot_cur->ext_status & CARD_INFO) == PCIX66)\n\t\tinfo(\"    66 MHz PCI-X\\n\");\n\telse if ((slot_cur->ext_status & CARD_INFO) == PCI66)\n\t\tinfo(\"    66 MHz PCI\\n\");\n\telse\n\t\tinfo(\"    33 MHz PCI\\n\");\n\n}\n\n \nstatic int enable_slot(struct hotplug_slot *hs)\n{\n\tint rc, i, rcpr;\n\tstruct slot *slot_cur;\n\tu8 function;\n\tstruct pci_func *tmp_func;\n\n\tibmphp_lock_operations();\n\n\tdebug(\"ENABLING SLOT........\\n\");\n\tslot_cur = to_slot(hs);\n\n\trc = validate(slot_cur, ENABLE);\n\tif (rc) {\n\t\terr(\"validate function failed\\n\");\n\t\tgoto error_nopower;\n\t}\n\n\tattn_LED_blink(slot_cur);\n\n\trc = set_bus(slot_cur);\n\tif (rc) {\n\t\terr(\"was not able to set the bus\\n\");\n\t\tgoto error_nopower;\n\t}\n\n\t \n\tget_cur_bus_info(&slot_cur);\n\tdebug(\"the current bus speed right after set_bus = %x\\n\",\n\t\t\t\t\tslot_cur->bus_on->current_speed);\n\t \n\n\trc = check_limitations(slot_cur);\n\tif (rc) {\n\t\terr(\"Adding this card exceeds the limitations of this bus.\\n\");\n\t\terr(\"(i.e., >1 133MHz cards running on same bus, or >2 66 PCI cards running on same bus.\\n\");\n\t\terr(\"Try hot-adding into another bus\\n\");\n\t\trc = -EINVAL;\n\t\tgoto error_nopower;\n\t}\n\n\trc = power_on(slot_cur);\n\n\tif (rc) {\n\t\terr(\"something wrong when powering up... please see below for details\\n\");\n\t\t \n\t\tattn_off(slot_cur);\n\t\tattn_on(slot_cur);\n\t\tif (slot_update(&slot_cur)) {\n\t\t\tattn_off(slot_cur);\n\t\t\tattn_on(slot_cur);\n\t\t\trc = -ENODEV;\n\t\t\tgoto exit;\n\t\t}\n\t\t \n\t\tif ((SLOT_POWER(slot_cur->status)) &&\n\t\t\t\t\t!(SLOT_PWRGD(slot_cur->status)))\n\t\t\terr(\"power fault occurred trying to power up\\n\");\n\t\telse if (SLOT_BUS_SPEED(slot_cur->status)) {\n\t\t\terr(\"bus speed mismatch occurred.  please check current bus speed and card capability\\n\");\n\t\t\tprint_card_capability(slot_cur);\n\t\t} else if (SLOT_BUS_MODE(slot_cur->ext_status)) {\n\t\t\terr(\"bus mode mismatch occurred.  please check current bus mode and card capability\\n\");\n\t\t\tprint_card_capability(slot_cur);\n\t\t}\n\t\tibmphp_update_slot_info(slot_cur);\n\t\tgoto exit;\n\t}\n\tdebug(\"after power_on\\n\");\n\t \n\tget_cur_bus_info(&slot_cur);\n\tdebug(\"the current bus speed right after power_on = %x\\n\",\n\t\t\t\t\tslot_cur->bus_on->current_speed);\n\t \n\n\trc = slot_update(&slot_cur);\n\tif (rc)\n\t\tgoto error_power;\n\n\trc = -EINVAL;\n\tif (SLOT_POWER(slot_cur->status) && !(SLOT_PWRGD(slot_cur->status))) {\n\t\terr(\"power fault occurred trying to power up...\\n\");\n\t\tgoto error_power;\n\t}\n\tif (SLOT_POWER(slot_cur->status) && (SLOT_BUS_SPEED(slot_cur->status))) {\n\t\terr(\"bus speed mismatch occurred.  please check current bus speed and card capability\\n\");\n\t\tprint_card_capability(slot_cur);\n\t\tgoto error_power;\n\t}\n\t \n\tif (!(SLOT_POWER(slot_cur->status))) {\n\t\terr(\"power on failed...\\n\");\n\t\tgoto error_power;\n\t}\n\n\tslot_cur->func = kzalloc(sizeof(struct pci_func), GFP_KERNEL);\n\tif (!slot_cur->func) {\n\t\t \n\t\trc = -ENOMEM;\n\t\tgoto error_power;\n\t}\n\tslot_cur->func->busno = slot_cur->bus;\n\tslot_cur->func->device = slot_cur->device;\n\tfor (i = 0; i < 4; i++)\n\t\tslot_cur->func->irq[i] = slot_cur->irq[i];\n\n\tdebug(\"b4 configure_card, slot_cur->bus = %x, slot_cur->device = %x\\n\",\n\t\t\t\t\tslot_cur->bus, slot_cur->device);\n\n\tif (ibmphp_configure_card(slot_cur->func, slot_cur->number)) {\n\t\terr(\"configure_card was unsuccessful...\\n\");\n\t\t \n\t\tibmphp_unconfigure_card(&slot_cur, 1);\n\t\tdebug(\"after unconfigure_card\\n\");\n\t\tslot_cur->func = NULL;\n\t\trc = -ENOMEM;\n\t\tgoto error_power;\n\t}\n\n\tfunction = 0x00;\n\tdo {\n\t\ttmp_func = ibm_slot_find(slot_cur->bus, slot_cur->func->device,\n\t\t\t\t\t\t\tfunction++);\n\t\tif (tmp_func && !(tmp_func->dev))\n\t\t\tibm_configure_device(tmp_func);\n\t} while (tmp_func);\n\n\tattn_off(slot_cur);\n\tif (slot_update(&slot_cur)) {\n\t\trc = -EFAULT;\n\t\tgoto exit;\n\t}\n\tibmphp_print_test();\n\trc = ibmphp_update_slot_info(slot_cur);\nexit:\n\tibmphp_unlock_operations();\n\treturn rc;\n\nerror_nopower:\n\tattn_off(slot_cur);\t \n\tattn_on(slot_cur);\nerror_cont:\n\trcpr = slot_update(&slot_cur);\n\tif (rcpr) {\n\t\trc = rcpr;\n\t\tgoto exit;\n\t}\n\tibmphp_update_slot_info(slot_cur);\n\tgoto exit;\n\nerror_power:\n\tattn_off(slot_cur);\t \n\tattn_on(slot_cur);\n\trcpr = power_off(slot_cur);\n\tif (rcpr) {\n\t\trc = rcpr;\n\t\tgoto exit;\n\t}\n\tgoto error_cont;\n}\n\n \nstatic int ibmphp_disable_slot(struct hotplug_slot *hotplug_slot)\n{\n\tstruct slot *slot = to_slot(hotplug_slot);\n\tint rc;\n\n\tibmphp_lock_operations();\n\trc = ibmphp_do_disable_slot(slot);\n\tibmphp_unlock_operations();\n\treturn rc;\n}\n\nint ibmphp_do_disable_slot(struct slot *slot_cur)\n{\n\tint rc;\n\tu8 flag;\n\n\tdebug(\"DISABLING SLOT...\\n\");\n\n\tif ((slot_cur == NULL) || (slot_cur->ctrl == NULL))\n\t\treturn -ENODEV;\n\n\tflag = slot_cur->flag;\n\tslot_cur->flag = 1;\n\n\tif (flag == 1) {\n\t\trc = validate(slot_cur, DISABLE);\n\t\t\t \n\t\tif (rc)\n\t\t\tgoto error;\n\t}\n\tattn_LED_blink(slot_cur);\n\n\tif (slot_cur->func == NULL) {\n\t\t \n\t\tslot_cur->func = kzalloc(sizeof(struct pci_func), GFP_KERNEL);\n\t\tif (!slot_cur->func) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto error;\n\t\t}\n\t\tslot_cur->func->busno = slot_cur->bus;\n\t\tslot_cur->func->device = slot_cur->device;\n\t}\n\n\tibm_unconfigure_device(slot_cur->func);\n\n\t \n\n\tif (!flag) {\n\t\tattn_off(slot_cur);\n\t\treturn 0;\n\t}\n\n\trc = ibmphp_unconfigure_card(&slot_cur, 0);\n\tslot_cur->func = NULL;\n\tdebug(\"in disable_slot. after unconfigure_card\\n\");\n\tif (rc) {\n\t\terr(\"could not unconfigure card.\\n\");\n\t\tgoto error;\n\t}\n\n\trc = ibmphp_hpc_writeslot(slot_cur, HPC_SLOT_OFF);\n\tif (rc)\n\t\tgoto error;\n\n\tattn_off(slot_cur);\n\trc = slot_update(&slot_cur);\n\tif (rc)\n\t\tgoto exit;\n\n\trc = ibmphp_update_slot_info(slot_cur);\n\tibmphp_print_test();\nexit:\n\treturn rc;\n\nerror:\n\t \n\tattn_off(slot_cur);\n\tattn_on(slot_cur);\n\tif (slot_update(&slot_cur)) {\n\t\trc = -EFAULT;\n\t\tgoto exit;\n\t}\n\tif (flag)\n\t\tibmphp_update_slot_info(slot_cur);\n\tgoto exit;\n}\n\nconst struct hotplug_slot_ops ibmphp_hotplug_slot_ops = {\n\t.set_attention_status =\t\tset_attention_status,\n\t.enable_slot =\t\t\tenable_slot,\n\t.disable_slot =\t\t\tibmphp_disable_slot,\n\t.hardware_test =\t\tNULL,\n\t.get_power_status =\t\tget_power_status,\n\t.get_attention_status =\t\tget_attention_status,\n\t.get_latch_status =\t\tget_latch_status,\n\t.get_adapter_status =\t\tget_adapter_present,\n};\n\nstatic void ibmphp_unload(void)\n{\n\tfree_slots();\n\tdebug(\"after slots\\n\");\n\tibmphp_free_resources();\n\tdebug(\"after resources\\n\");\n\tibmphp_free_bus_info_queue();\n\tdebug(\"after bus info\\n\");\n\tibmphp_free_ebda_hpc_queue();\n\tdebug(\"after ebda hpc\\n\");\n\tibmphp_free_ebda_pci_rsrc_queue();\n\tdebug(\"after ebda pci rsrc\\n\");\n\tkfree(ibmphp_pci_bus);\n}\n\nstatic int __init ibmphp_init(void)\n{\n\tstruct pci_bus *bus;\n\tint i = 0;\n\tint rc = 0;\n\n\tinit_flag = 1;\n\n\tinfo(DRIVER_DESC \" version: \" DRIVER_VERSION \"\\n\");\n\n\tibmphp_pci_bus = kmalloc(sizeof(*ibmphp_pci_bus), GFP_KERNEL);\n\tif (!ibmphp_pci_bus) {\n\t\trc = -ENOMEM;\n\t\tgoto exit;\n\t}\n\n\tbus = pci_find_bus(0, 0);\n\tif (!bus) {\n\t\terr(\"Can't find the root pci bus, can not continue\\n\");\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\tmemcpy(ibmphp_pci_bus, bus, sizeof(*ibmphp_pci_bus));\n\n\tibmphp_debug = debug;\n\n\tfor (i = 0; i < 16; i++)\n\t\tirqs[i] = 0;\n\n\trc = ibmphp_access_ebda();\n\tif (rc)\n\t\tgoto error;\n\tdebug(\"after ibmphp_access_ebda()\\n\");\n\n\trc = ibmphp_rsrc_init();\n\tif (rc)\n\t\tgoto error;\n\tdebug(\"AFTER Resource & EBDA INITIALIZATIONS\\n\");\n\n\tmax_slots = get_max_slots();\n\n\trc = ibmphp_register_pci();\n\tif (rc)\n\t\tgoto error;\n\n\tif (init_ops()) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\n\tibmphp_print_test();\n\trc = ibmphp_hpc_start_poll_thread();\n\tif (rc)\n\t\tgoto error;\n\nexit:\n\treturn rc;\n\nerror:\n\tibmphp_unload();\n\tgoto exit;\n}\n\nstatic void __exit ibmphp_exit(void)\n{\n\tibmphp_hpc_stop_poll_thread();\n\tdebug(\"after polling\\n\");\n\tibmphp_unload();\n\tdebug(\"done\\n\");\n}\n\nmodule_init(ibmphp_init);\nmodule_exit(ibmphp_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}