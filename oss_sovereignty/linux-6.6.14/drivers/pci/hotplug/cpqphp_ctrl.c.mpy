{
  "module_name": "cpqphp_ctrl.c",
  "hash_id": "460add8de8e07409db639a97f646d3cf1c9e8160e6624ccb2058e98cde293202",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/hotplug/cpqphp_ctrl.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n#include <linux/wait.h>\n#include <linux/pci.h>\n#include <linux/pci_hotplug.h>\n#include <linux/kthread.h>\n#include \"cpqphp.h\"\n\nstatic u32 configure_new_device(struct controller *ctrl, struct pci_func *func,\n\t\t\tu8 behind_bridge, struct resource_lists *resources);\nstatic int configure_new_function(struct controller *ctrl, struct pci_func *func,\n\t\t\tu8 behind_bridge, struct resource_lists *resources);\nstatic void interrupt_event_handler(struct controller *ctrl);\n\n\nstatic struct task_struct *cpqhp_event_thread;\nstatic struct timer_list *pushbutton_pending;\t \n\n \nstatic void long_delay(int delay)\n{\n\t \n\tmsleep_interruptible(jiffies_to_msecs(delay));\n}\n\n\n \n#define WRONG_BUS_FREQUENCY 0x07\nstatic u8 handle_switch_change(u8 change, struct controller *ctrl)\n{\n\tint hp_slot;\n\tu8 rc = 0;\n\tu16 temp_word;\n\tstruct pci_func *func;\n\tstruct event_info *taskInfo;\n\n\tif (!change)\n\t\treturn 0;\n\n\t \n\tdbg(\"cpqsbd:  Switch interrupt received.\\n\");\n\n\tfor (hp_slot = 0; hp_slot < 6; hp_slot++) {\n\t\tif (change & (0x1L << hp_slot)) {\n\t\t\t \n\t\t\tfunc = cpqhp_slot_find(ctrl->bus,\n\t\t\t\t(hp_slot + ctrl->slot_device_offset), 0);\n\n\t\t\t \n\t\t\ttaskInfo = &(ctrl->event_queue[ctrl->next_event]);\n\t\t\tctrl->next_event = (ctrl->next_event + 1) % 10;\n\t\t\ttaskInfo->hp_slot = hp_slot;\n\n\t\t\trc++;\n\n\t\t\ttemp_word = ctrl->ctrl_int_comp >> 16;\n\t\t\tfunc->presence_save = (temp_word >> hp_slot) & 0x01;\n\t\t\tfunc->presence_save |= (temp_word >> (hp_slot + 7)) & 0x02;\n\n\t\t\tif (ctrl->ctrl_int_comp & (0x1L << hp_slot)) {\n\t\t\t\t \n\n\t\t\t\tfunc->switch_save = 0;\n\n\t\t\t\ttaskInfo->event_type = INT_SWITCH_OPEN;\n\t\t\t} else {\n\t\t\t\t \n\n\t\t\t\tfunc->switch_save = 0x10;\n\n\t\t\t\ttaskInfo->event_type = INT_SWITCH_CLOSE;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn rc;\n}\n\n \nstatic struct slot *cpqhp_find_slot(struct controller *ctrl, u8 device)\n{\n\tstruct slot *slot = ctrl->slot;\n\n\twhile (slot && (slot->device != device))\n\t\tslot = slot->next;\n\n\treturn slot;\n}\n\n\nstatic u8 handle_presence_change(u16 change, struct controller *ctrl)\n{\n\tint hp_slot;\n\tu8 rc = 0;\n\tu8 temp_byte;\n\tu16 temp_word;\n\tstruct pci_func *func;\n\tstruct event_info *taskInfo;\n\tstruct slot *p_slot;\n\n\tif (!change)\n\t\treturn 0;\n\n\t \n\tdbg(\"cpqsbd:  Presence/Notify input change.\\n\");\n\tdbg(\"         Changed bits are 0x%4.4x\\n\", change);\n\n\tfor (hp_slot = 0; hp_slot < 6; hp_slot++) {\n\t\tif (change & (0x0101 << hp_slot)) {\n\t\t\t \n\t\t\tfunc = cpqhp_slot_find(ctrl->bus,\n\t\t\t\t(hp_slot + ctrl->slot_device_offset), 0);\n\n\t\t\ttaskInfo = &(ctrl->event_queue[ctrl->next_event]);\n\t\t\tctrl->next_event = (ctrl->next_event + 1) % 10;\n\t\t\ttaskInfo->hp_slot = hp_slot;\n\n\t\t\trc++;\n\n\t\t\tp_slot = cpqhp_find_slot(ctrl, hp_slot + (readb(ctrl->hpc_reg + SLOT_MASK) >> 4));\n\t\t\tif (!p_slot)\n\t\t\t\treturn 0;\n\n\t\t\t \n\t\t\tif (func->switch_save && (ctrl->push_button == 1)) {\n\t\t\t\ttemp_word = ctrl->ctrl_int_comp >> 16;\n\t\t\t\ttemp_byte = (temp_word >> hp_slot) & 0x01;\n\t\t\t\ttemp_byte |= (temp_word >> (hp_slot + 7)) & 0x02;\n\n\t\t\t\tif (temp_byte != func->presence_save) {\n\t\t\t\t\t \n\t\t\t\t\tdbg(\"hp_slot %d button pressed\\n\", hp_slot);\n\t\t\t\t\ttaskInfo->event_type = INT_BUTTON_PRESS;\n\t\t\t\t} else {\n\t\t\t\t\t \n\t\t\t\t\tdbg(\"hp_slot %d button released\\n\", hp_slot);\n\t\t\t\t\ttaskInfo->event_type = INT_BUTTON_RELEASE;\n\n\t\t\t\t\t \n\t\t\t\t\tif ((p_slot->state == BLINKINGON_STATE)\n\t\t\t\t\t    || (p_slot->state == BLINKINGOFF_STATE)) {\n\t\t\t\t\t\ttaskInfo->event_type = INT_BUTTON_CANCEL;\n\t\t\t\t\t\tdbg(\"hp_slot %d button cancel\\n\", hp_slot);\n\t\t\t\t\t} else if ((p_slot->state == POWERON_STATE)\n\t\t\t\t\t\t   || (p_slot->state == POWEROFF_STATE)) {\n\t\t\t\t\t\t \n\t\t\t\t\t\ttaskInfo->event_type = INT_BUTTON_IGNORE;\n\t\t\t\t\t\tdbg(\"hp_slot %d button ignore\\n\", hp_slot);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\ttemp_word = ctrl->ctrl_int_comp >> 16;\n\t\t\t\tfunc->presence_save = (temp_word >> hp_slot) & 0x01;\n\t\t\t\tfunc->presence_save |= (temp_word >> (hp_slot + 7)) & 0x02;\n\n\t\t\t\tif ((!(ctrl->ctrl_int_comp & (0x010000 << hp_slot))) ||\n\t\t\t\t    (!(ctrl->ctrl_int_comp & (0x01000000 << hp_slot)))) {\n\t\t\t\t\t \n\t\t\t\t\ttaskInfo->event_type = INT_PRESENCE_ON;\n\t\t\t\t} else {\n\t\t\t\t\t \n\t\t\t\t\ttaskInfo->event_type = INT_PRESENCE_OFF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn rc;\n}\n\n\nstatic u8 handle_power_fault(u8 change, struct controller *ctrl)\n{\n\tint hp_slot;\n\tu8 rc = 0;\n\tstruct pci_func *func;\n\tstruct event_info *taskInfo;\n\n\tif (!change)\n\t\treturn 0;\n\n\t \n\n\tinfo(\"power fault interrupt\\n\");\n\n\tfor (hp_slot = 0; hp_slot < 6; hp_slot++) {\n\t\tif (change & (0x01 << hp_slot)) {\n\t\t\t \n\t\t\tfunc = cpqhp_slot_find(ctrl->bus,\n\t\t\t\t(hp_slot + ctrl->slot_device_offset), 0);\n\n\t\t\ttaskInfo = &(ctrl->event_queue[ctrl->next_event]);\n\t\t\tctrl->next_event = (ctrl->next_event + 1) % 10;\n\t\t\ttaskInfo->hp_slot = hp_slot;\n\n\t\t\trc++;\n\n\t\t\tif (ctrl->ctrl_int_comp & (0x00000100 << hp_slot)) {\n\t\t\t\t \n\t\t\t\tfunc->status = 0x00;\n\n\t\t\t\ttaskInfo->event_type = INT_POWER_FAULT_CLEAR;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\ttaskInfo->event_type = INT_POWER_FAULT;\n\n\t\t\t\tif (ctrl->rev < 4) {\n\t\t\t\t\tamber_LED_on(ctrl, hp_slot);\n\t\t\t\t\tgreen_LED_off(ctrl, hp_slot);\n\t\t\t\t\tset_SOGO(ctrl);\n\n\t\t\t\t\t \n\t\t\t\t\t \n\n\t\t\t\t\t \n\t\t\t\t\t \n\t\t\t\t} else {\n\t\t\t\t\t \n\t\t\t\t\tfunc->status = 0xFF;\n\t\t\t\t\tinfo(\"power fault bit %x set\\n\", hp_slot);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn rc;\n}\n\n\n \nstatic int sort_by_size(struct pci_resource **head)\n{\n\tstruct pci_resource *current_res;\n\tstruct pci_resource *next_res;\n\tint out_of_order = 1;\n\n\tif (!(*head))\n\t\treturn 1;\n\n\tif (!((*head)->next))\n\t\treturn 0;\n\n\twhile (out_of_order) {\n\t\tout_of_order = 0;\n\n\t\t \n\t\tif (((*head)->next) &&\n\t\t    ((*head)->length > (*head)->next->length)) {\n\t\t\tout_of_order++;\n\t\t\tcurrent_res = *head;\n\t\t\t*head = (*head)->next;\n\t\t\tcurrent_res->next = (*head)->next;\n\t\t\t(*head)->next = current_res;\n\t\t}\n\n\t\tcurrent_res = *head;\n\n\t\twhile (current_res->next && current_res->next->next) {\n\t\t\tif (current_res->next->length > current_res->next->next->length) {\n\t\t\t\tout_of_order++;\n\t\t\t\tnext_res = current_res->next;\n\t\t\t\tcurrent_res->next = current_res->next->next;\n\t\t\t\tcurrent_res = current_res->next;\n\t\t\t\tnext_res->next = current_res->next;\n\t\t\t\tcurrent_res->next = next_res;\n\t\t\t} else\n\t\t\t\tcurrent_res = current_res->next;\n\t\t}\n\t}   \n\n\treturn 0;\n}\n\n\n \nstatic int sort_by_max_size(struct pci_resource **head)\n{\n\tstruct pci_resource *current_res;\n\tstruct pci_resource *next_res;\n\tint out_of_order = 1;\n\n\tif (!(*head))\n\t\treturn 1;\n\n\tif (!((*head)->next))\n\t\treturn 0;\n\n\twhile (out_of_order) {\n\t\tout_of_order = 0;\n\n\t\t \n\t\tif (((*head)->next) &&\n\t\t    ((*head)->length < (*head)->next->length)) {\n\t\t\tout_of_order++;\n\t\t\tcurrent_res = *head;\n\t\t\t*head = (*head)->next;\n\t\t\tcurrent_res->next = (*head)->next;\n\t\t\t(*head)->next = current_res;\n\t\t}\n\n\t\tcurrent_res = *head;\n\n\t\twhile (current_res->next && current_res->next->next) {\n\t\t\tif (current_res->next->length < current_res->next->next->length) {\n\t\t\t\tout_of_order++;\n\t\t\t\tnext_res = current_res->next;\n\t\t\t\tcurrent_res->next = current_res->next->next;\n\t\t\t\tcurrent_res = current_res->next;\n\t\t\t\tnext_res->next = current_res->next;\n\t\t\t\tcurrent_res->next = next_res;\n\t\t\t} else\n\t\t\t\tcurrent_res = current_res->next;\n\t\t}\n\t}   \n\n\treturn 0;\n}\n\n\n \nstatic struct pci_resource *do_pre_bridge_resource_split(struct pci_resource **head,\n\t\t\t\tstruct pci_resource **orig_head, u32 alignment)\n{\n\tstruct pci_resource *prevnode = NULL;\n\tstruct pci_resource *node;\n\tstruct pci_resource *split_node;\n\tu32 rc;\n\tu32 temp_dword;\n\tdbg(\"do_pre_bridge_resource_split\\n\");\n\n\tif (!(*head) || !(*orig_head))\n\t\treturn NULL;\n\n\trc = cpqhp_resource_sort_and_combine(head);\n\n\tif (rc)\n\t\treturn NULL;\n\n\tif ((*head)->base != (*orig_head)->base)\n\t\treturn NULL;\n\n\tif ((*head)->length == (*orig_head)->length)\n\t\treturn NULL;\n\n\n\t \n\n\tnode = *head;\n\n\tif (node->length & (alignment - 1)) {\n\t\t \n\t\tsplit_node = kmalloc(sizeof(*split_node), GFP_KERNEL);\n\n\t\tif (!split_node)\n\t\t\treturn NULL;\n\n\t\ttemp_dword = (node->length | (alignment-1)) + 1 - alignment;\n\n\t\tsplit_node->base = node->base;\n\t\tsplit_node->length = temp_dword;\n\n\t\tnode->length -= temp_dword;\n\t\tnode->base += split_node->length;\n\n\t\t \n\t\t*head = split_node;\n\t\tsplit_node->next = node;\n\t}\n\n\tif (node->length < alignment)\n\t\treturn NULL;\n\n\t \n\tif (*head == node) {\n\t\t*head = node->next;\n\t} else {\n\t\tprevnode = *head;\n\t\twhile (prevnode->next != node)\n\t\t\tprevnode = prevnode->next;\n\n\t\tprevnode->next = node->next;\n\t}\n\tnode->next = NULL;\n\n\treturn node;\n}\n\n\n \nstatic struct pci_resource *do_bridge_resource_split(struct pci_resource **head, u32 alignment)\n{\n\tstruct pci_resource *prevnode = NULL;\n\tstruct pci_resource *node;\n\tu32 rc;\n\tu32 temp_dword;\n\n\trc = cpqhp_resource_sort_and_combine(head);\n\n\tif (rc)\n\t\treturn NULL;\n\n\tnode = *head;\n\n\twhile (node->next) {\n\t\tprevnode = node;\n\t\tnode = node->next;\n\t\tkfree(prevnode);\n\t}\n\n\tif (node->length < alignment)\n\t\tgoto error;\n\n\tif (node->base & (alignment - 1)) {\n\t\t \n\t\ttemp_dword = (node->base | (alignment-1)) + 1;\n\t\tif ((node->length - (temp_dword - node->base)) < alignment)\n\t\t\tgoto error;\n\n\t\tnode->length -= (temp_dword - node->base);\n\t\tnode->base = temp_dword;\n\t}\n\n\tif (node->length & (alignment - 1))\n\t\t \n\t\tgoto error;\n\n\treturn node;\nerror:\n\tkfree(node);\n\treturn NULL;\n}\n\n\n \nstatic struct pci_resource *get_io_resource(struct pci_resource **head, u32 size)\n{\n\tstruct pci_resource *prevnode;\n\tstruct pci_resource *node;\n\tstruct pci_resource *split_node;\n\tu32 temp_dword;\n\n\tif (!(*head))\n\t\treturn NULL;\n\n\tif (cpqhp_resource_sort_and_combine(head))\n\t\treturn NULL;\n\n\tif (sort_by_size(head))\n\t\treturn NULL;\n\n\tfor (node = *head; node; node = node->next) {\n\t\tif (node->length < size)\n\t\t\tcontinue;\n\n\t\tif (node->base & (size - 1)) {\n\t\t\t \n\t\t\ttemp_dword = (node->base | (size-1)) + 1;\n\n\t\t\t \n\t\t\tif ((node->length - (temp_dword - node->base)) < size)\n\t\t\t\tcontinue;\n\n\t\t\tsplit_node = kmalloc(sizeof(*split_node), GFP_KERNEL);\n\n\t\t\tif (!split_node)\n\t\t\t\treturn NULL;\n\n\t\t\tsplit_node->base = node->base;\n\t\t\tsplit_node->length = temp_dword - node->base;\n\t\t\tnode->base = temp_dword;\n\t\t\tnode->length -= split_node->length;\n\n\t\t\t \n\t\t\tsplit_node->next = node->next;\n\t\t\tnode->next = split_node;\n\t\t}  \n\n\t\t \n\t\tif (node->length > size) {\n\t\t\t \n\t\t\tsplit_node = kmalloc(sizeof(*split_node), GFP_KERNEL);\n\n\t\t\tif (!split_node)\n\t\t\t\treturn NULL;\n\n\t\t\tsplit_node->base = node->base + size;\n\t\t\tsplit_node->length = node->length - size;\n\t\t\tnode->length = size;\n\n\t\t\t \n\t\t\tsplit_node->next = node->next;\n\t\t\tnode->next = split_node;\n\t\t}   \n\n\t\t \n\t\tif (node->base & 0x300L)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (*head == node) {\n\t\t\t*head = node->next;\n\t\t} else {\n\t\t\tprevnode = *head;\n\t\t\twhile (prevnode->next != node)\n\t\t\t\tprevnode = prevnode->next;\n\n\t\t\tprevnode->next = node->next;\n\t\t}\n\t\tnode->next = NULL;\n\t\tbreak;\n\t}\n\n\treturn node;\n}\n\n\n \nstatic struct pci_resource *get_max_resource(struct pci_resource **head, u32 size)\n{\n\tstruct pci_resource *max;\n\tstruct pci_resource *temp;\n\tstruct pci_resource *split_node;\n\tu32 temp_dword;\n\n\tif (cpqhp_resource_sort_and_combine(head))\n\t\treturn NULL;\n\n\tif (sort_by_max_size(head))\n\t\treturn NULL;\n\n\tfor (max = *head; max; max = max->next) {\n\t\t \n\t\tif (max->length < size)\n\t\t\tcontinue;\n\n\t\tif (max->base & (size - 1)) {\n\t\t\t \n\t\t\ttemp_dword = (max->base | (size-1)) + 1;\n\n\t\t\t \n\t\t\tif ((max->length - (temp_dword - max->base)) < size)\n\t\t\t\tcontinue;\n\n\t\t\tsplit_node = kmalloc(sizeof(*split_node), GFP_KERNEL);\n\n\t\t\tif (!split_node)\n\t\t\t\treturn NULL;\n\n\t\t\tsplit_node->base = max->base;\n\t\t\tsplit_node->length = temp_dword - max->base;\n\t\t\tmax->base = temp_dword;\n\t\t\tmax->length -= split_node->length;\n\n\t\t\tsplit_node->next = max->next;\n\t\t\tmax->next = split_node;\n\t\t}\n\n\t\tif ((max->base + max->length) & (size - 1)) {\n\t\t\t \n\t\t\tsplit_node = kmalloc(sizeof(*split_node), GFP_KERNEL);\n\n\t\t\tif (!split_node)\n\t\t\t\treturn NULL;\n\t\t\ttemp_dword = ((max->base + max->length) & ~(size - 1));\n\t\t\tsplit_node->base = temp_dword;\n\t\t\tsplit_node->length = max->length + max->base\n\t\t\t\t\t     - split_node->base;\n\t\t\tmax->length -= split_node->length;\n\n\t\t\tsplit_node->next = max->next;\n\t\t\tmax->next = split_node;\n\t\t}\n\n\t\t \n\t\tif (max->length < size)\n\t\t\tcontinue;\n\n\t\t \n\t\ttemp = *head;\n\t\tif (temp == max) {\n\t\t\t*head = max->next;\n\t\t} else {\n\t\t\twhile (temp && temp->next != max)\n\t\t\t\ttemp = temp->next;\n\n\t\t\tif (temp)\n\t\t\t\ttemp->next = max->next;\n\t\t}\n\n\t\tmax->next = NULL;\n\t\tbreak;\n\t}\n\n\treturn max;\n}\n\n\n \nstatic struct pci_resource *get_resource(struct pci_resource **head, u32 size)\n{\n\tstruct pci_resource *prevnode;\n\tstruct pci_resource *node;\n\tstruct pci_resource *split_node;\n\tu32 temp_dword;\n\n\tif (cpqhp_resource_sort_and_combine(head))\n\t\treturn NULL;\n\n\tif (sort_by_size(head))\n\t\treturn NULL;\n\n\tfor (node = *head; node; node = node->next) {\n\t\tdbg(\"%s: req_size =%x node=%p, base=%x, length=%x\\n\",\n\t\t    __func__, size, node, node->base, node->length);\n\t\tif (node->length < size)\n\t\t\tcontinue;\n\n\t\tif (node->base & (size - 1)) {\n\t\t\tdbg(\"%s: not aligned\\n\", __func__);\n\t\t\t \n\t\t\ttemp_dword = (node->base | (size-1)) + 1;\n\n\t\t\t \n\t\t\tif ((node->length - (temp_dword - node->base)) < size)\n\t\t\t\tcontinue;\n\n\t\t\tsplit_node = kmalloc(sizeof(*split_node), GFP_KERNEL);\n\n\t\t\tif (!split_node)\n\t\t\t\treturn NULL;\n\n\t\t\tsplit_node->base = node->base;\n\t\t\tsplit_node->length = temp_dword - node->base;\n\t\t\tnode->base = temp_dword;\n\t\t\tnode->length -= split_node->length;\n\n\t\t\tsplit_node->next = node->next;\n\t\t\tnode->next = split_node;\n\t\t}  \n\n\t\t \n\t\tif (node->length > size) {\n\t\t\tdbg(\"%s: too big\\n\", __func__);\n\t\t\t \n\t\t\tsplit_node = kmalloc(sizeof(*split_node), GFP_KERNEL);\n\n\t\t\tif (!split_node)\n\t\t\t\treturn NULL;\n\n\t\t\tsplit_node->base = node->base + size;\n\t\t\tsplit_node->length = node->length - size;\n\t\t\tnode->length = size;\n\n\t\t\t \n\t\t\tsplit_node->next = node->next;\n\t\t\tnode->next = split_node;\n\t\t}   \n\n\t\tdbg(\"%s: got one!!!\\n\", __func__);\n\t\t \n\t\tif (*head == node) {\n\t\t\t*head = node->next;\n\t\t} else {\n\t\t\tprevnode = *head;\n\t\t\twhile (prevnode->next != node)\n\t\t\t\tprevnode = prevnode->next;\n\n\t\t\tprevnode->next = node->next;\n\t\t}\n\t\tnode->next = NULL;\n\t\tbreak;\n\t}\n\treturn node;\n}\n\n\n \nint cpqhp_resource_sort_and_combine(struct pci_resource **head)\n{\n\tstruct pci_resource *node1;\n\tstruct pci_resource *node2;\n\tint out_of_order = 1;\n\n\tdbg(\"%s: head = %p, *head = %p\\n\", __func__, head, *head);\n\n\tif (!(*head))\n\t\treturn 1;\n\n\tdbg(\"*head->next = %p\\n\", (*head)->next);\n\n\tif (!(*head)->next)\n\t\treturn 0;\t \n\n\tdbg(\"*head->base = 0x%x\\n\", (*head)->base);\n\tdbg(\"*head->next->base = 0x%x\\n\", (*head)->next->base);\n\twhile (out_of_order) {\n\t\tout_of_order = 0;\n\n\t\t \n\t\tif (((*head)->next) &&\n\t\t    ((*head)->base > (*head)->next->base)) {\n\t\t\tnode1 = *head;\n\t\t\t(*head) = (*head)->next;\n\t\t\tnode1->next = (*head)->next;\n\t\t\t(*head)->next = node1;\n\t\t\tout_of_order++;\n\t\t}\n\n\t\tnode1 = (*head);\n\n\t\twhile (node1->next && node1->next->next) {\n\t\t\tif (node1->next->base > node1->next->next->base) {\n\t\t\t\tout_of_order++;\n\t\t\t\tnode2 = node1->next;\n\t\t\t\tnode1->next = node1->next->next;\n\t\t\t\tnode1 = node1->next;\n\t\t\t\tnode2->next = node1->next;\n\t\t\t\tnode1->next = node2;\n\t\t\t} else\n\t\t\t\tnode1 = node1->next;\n\t\t}\n\t}   \n\n\tnode1 = *head;\n\n\twhile (node1 && node1->next) {\n\t\tif ((node1->base + node1->length) == node1->next->base) {\n\t\t\t \n\t\t\tdbg(\"8..\\n\");\n\t\t\tnode1->length += node1->next->length;\n\t\t\tnode2 = node1->next;\n\t\t\tnode1->next = node1->next->next;\n\t\t\tkfree(node2);\n\t\t} else\n\t\t\tnode1 = node1->next;\n\t}\n\n\treturn 0;\n}\n\n\nirqreturn_t cpqhp_ctrl_intr(int IRQ, void *data)\n{\n\tstruct controller *ctrl = data;\n\tu8 schedule_flag = 0;\n\tu8 reset;\n\tu16 misc;\n\tu32 Diff;\n\n\n\tmisc = readw(ctrl->hpc_reg + MISC);\n\t \n\tif (!(misc & 0x000C))\n\t\treturn IRQ_NONE;\n\n\tif (misc & 0x0004) {\n\t\t \n\n\t\t \n\t\tmisc |= 0x0004;\n\t\twritew(misc, ctrl->hpc_reg + MISC);\n\n\t\t \n\t\tmisc = readw(ctrl->hpc_reg + MISC);\n\n\t\tdbg(\"%s - waking up\\n\", __func__);\n\t\twake_up_interruptible(&ctrl->queue);\n\t}\n\n\tif (misc & 0x0008) {\n\t\t \n\t\tDiff = readl(ctrl->hpc_reg + INT_INPUT_CLEAR) ^ ctrl->ctrl_int_comp;\n\n\t\tctrl->ctrl_int_comp = readl(ctrl->hpc_reg + INT_INPUT_CLEAR);\n\n\t\t \n\t\twritel(Diff, ctrl->hpc_reg + INT_INPUT_CLEAR);\n\n\t\t \n\t\treadl(ctrl->hpc_reg + INT_INPUT_CLEAR);\n\n\t\tif (!Diff)\n\t\t\t \n\t\t\twritel(0xFFFFFFFF, ctrl->hpc_reg + INT_INPUT_CLEAR);\n\n\t\tschedule_flag += handle_switch_change((u8)(Diff & 0xFFL), ctrl);\n\t\tschedule_flag += handle_presence_change((u16)((Diff & 0xFFFF0000L) >> 16), ctrl);\n\t\tschedule_flag += handle_power_fault((u8)((Diff & 0xFF00L) >> 8), ctrl);\n\t}\n\n\treset = readb(ctrl->hpc_reg + RESET_FREQ_MODE);\n\tif (reset & 0x40) {\n\t\t \n\t\treset &= 0xCF;\n\t\twriteb(reset, ctrl->hpc_reg + RESET_FREQ_MODE);\n\t\treset = readb(ctrl->hpc_reg + RESET_FREQ_MODE);\n\t\twake_up_interruptible(&ctrl->queue);\n\t}\n\n\tif (schedule_flag) {\n\t\twake_up_process(cpqhp_event_thread);\n\t\tdbg(\"Waking even thread\");\n\t}\n\treturn IRQ_HANDLED;\n}\n\n\n \nstruct pci_func *cpqhp_slot_create(u8 busnumber)\n{\n\tstruct pci_func *new_slot;\n\tstruct pci_func *next;\n\n\tnew_slot = kzalloc(sizeof(*new_slot), GFP_KERNEL);\n\tif (new_slot == NULL)\n\t\treturn new_slot;\n\n\tnew_slot->next = NULL;\n\tnew_slot->configured = 1;\n\n\tif (cpqhp_slot_list[busnumber] == NULL) {\n\t\tcpqhp_slot_list[busnumber] = new_slot;\n\t} else {\n\t\tnext = cpqhp_slot_list[busnumber];\n\t\twhile (next->next != NULL)\n\t\t\tnext = next->next;\n\t\tnext->next = new_slot;\n\t}\n\treturn new_slot;\n}\n\n\n \nstatic int slot_remove(struct pci_func *old_slot)\n{\n\tstruct pci_func *next;\n\n\tif (old_slot == NULL)\n\t\treturn 1;\n\n\tnext = cpqhp_slot_list[old_slot->bus];\n\tif (next == NULL)\n\t\treturn 1;\n\n\tif (next == old_slot) {\n\t\tcpqhp_slot_list[old_slot->bus] = old_slot->next;\n\t\tcpqhp_destroy_board_resources(old_slot);\n\t\tkfree(old_slot);\n\t\treturn 0;\n\t}\n\n\twhile ((next->next != old_slot) && (next->next != NULL))\n\t\tnext = next->next;\n\n\tif (next->next == old_slot) {\n\t\tnext->next = old_slot->next;\n\t\tcpqhp_destroy_board_resources(old_slot);\n\t\tkfree(old_slot);\n\t\treturn 0;\n\t} else\n\t\treturn 2;\n}\n\n\n \nstatic int bridge_slot_remove(struct pci_func *bridge)\n{\n\tu8 subordinateBus, secondaryBus;\n\tu8 tempBus;\n\tstruct pci_func *next;\n\n\tsecondaryBus = (bridge->config_space[0x06] >> 8) & 0xFF;\n\tsubordinateBus = (bridge->config_space[0x06] >> 16) & 0xFF;\n\n\tfor (tempBus = secondaryBus; tempBus <= subordinateBus; tempBus++) {\n\t\tnext = cpqhp_slot_list[tempBus];\n\n\t\twhile (!slot_remove(next))\n\t\t\tnext = cpqhp_slot_list[tempBus];\n\t}\n\n\tnext = cpqhp_slot_list[bridge->bus];\n\n\tif (next == NULL)\n\t\treturn 1;\n\n\tif (next == bridge) {\n\t\tcpqhp_slot_list[bridge->bus] = bridge->next;\n\t\tgoto out;\n\t}\n\n\twhile ((next->next != bridge) && (next->next != NULL))\n\t\tnext = next->next;\n\n\tif (next->next != bridge)\n\t\treturn 2;\n\tnext->next = bridge->next;\nout:\n\tkfree(bridge);\n\treturn 0;\n}\n\n\n \nstruct pci_func *cpqhp_slot_find(u8 bus, u8 device, u8 index)\n{\n\tint found = -1;\n\tstruct pci_func *func;\n\n\tfunc = cpqhp_slot_list[bus];\n\n\tif ((func == NULL) || ((func->device == device) && (index == 0)))\n\t\treturn func;\n\n\tif (func->device == device)\n\t\tfound++;\n\n\twhile (func->next != NULL) {\n\t\tfunc = func->next;\n\n\t\tif (func->device == device)\n\t\t\tfound++;\n\n\t\tif (found == index)\n\t\t\treturn func;\n\t}\n\n\treturn NULL;\n}\n\n\n \nstatic int is_bridge(struct pci_func *func)\n{\n\t \n\tif (((func->config_space[0x03] >> 16) & 0xFF) == 0x01)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\n\n \nstatic u8 set_controller_speed(struct controller *ctrl, u8 adapter_speed, u8 hp_slot)\n{\n\tstruct slot *slot;\n\tstruct pci_bus *bus = ctrl->pci_bus;\n\tu8 reg;\n\tu8 slot_power = readb(ctrl->hpc_reg + SLOT_POWER);\n\tu16 reg16;\n\tu32 leds = readl(ctrl->hpc_reg + LED_CONTROL);\n\n\tif (bus->cur_bus_speed == adapter_speed)\n\t\treturn 0;\n\n\t \n\tfor (slot = ctrl->slot; slot; slot = slot->next) {\n\t\tif (slot->device == (hp_slot + ctrl->slot_device_offset))\n\t\t\tcontinue;\n\t\tif (get_presence_status(ctrl, slot) == 0)\n\t\t\tcontinue;\n\t\t \n\t\tif (bus->cur_bus_speed < adapter_speed)\n\t\t\treturn 0;\n\n\t\treturn 1;\n\t}\n\n\t \n\tif ((bus->cur_bus_speed > adapter_speed) && (!ctrl->pcix_speed_capability))\n\t\treturn 1;\n\n\t \n\tif ((bus->cur_bus_speed < adapter_speed) && (!ctrl->pcix_speed_capability))\n\t\treturn 0;\n\n\t \n\tif (bus->max_bus_speed < adapter_speed) {\n\t\tif (bus->cur_bus_speed == bus->max_bus_speed)\n\t\t\treturn 0;\n\t\tadapter_speed = bus->max_bus_speed;\n\t}\n\n\twritel(0x0L, ctrl->hpc_reg + LED_CONTROL);\n\twriteb(0x00, ctrl->hpc_reg + SLOT_ENABLE);\n\n\tset_SOGO(ctrl);\n\twait_for_ctrl_irq(ctrl);\n\n\tif (adapter_speed != PCI_SPEED_133MHz_PCIX)\n\t\treg = 0xF5;\n\telse\n\t\treg = 0xF4;\n\tpci_write_config_byte(ctrl->pci_dev, 0x41, reg);\n\n\treg16 = readw(ctrl->hpc_reg + NEXT_CURR_FREQ);\n\treg16 &= ~0x000F;\n\tswitch (adapter_speed) {\n\t\tcase(PCI_SPEED_133MHz_PCIX):\n\t\t\treg = 0x75;\n\t\t\treg16 |= 0xB;\n\t\t\tbreak;\n\t\tcase(PCI_SPEED_100MHz_PCIX):\n\t\t\treg = 0x74;\n\t\t\treg16 |= 0xA;\n\t\t\tbreak;\n\t\tcase(PCI_SPEED_66MHz_PCIX):\n\t\t\treg = 0x73;\n\t\t\treg16 |= 0x9;\n\t\t\tbreak;\n\t\tcase(PCI_SPEED_66MHz):\n\t\t\treg = 0x73;\n\t\t\treg16 |= 0x1;\n\t\t\tbreak;\n\t\tdefault:  \n\t\t\treg = 0x71;\n\t\t\tbreak;\n\n\t}\n\treg16 |= 0xB << 12;\n\twritew(reg16, ctrl->hpc_reg + NEXT_CURR_FREQ);\n\n\tmdelay(5);\n\n\t \n\twritel(0, ctrl->hpc_reg + INT_MASK);\n\n\tpci_write_config_byte(ctrl->pci_dev, 0x41, reg);\n\n\t \n\treg = ~0xF;\n\tpci_read_config_byte(ctrl->pci_dev, 0x43, &reg);\n\tpci_write_config_byte(ctrl->pci_dev, 0x43, reg);\n\n\t \n\tif (((bus->cur_bus_speed == PCI_SPEED_66MHz) && (adapter_speed == PCI_SPEED_66MHz_PCIX)) ||\n\t\t((bus->cur_bus_speed == PCI_SPEED_66MHz_PCIX) && (adapter_speed == PCI_SPEED_66MHz)))\n\t\t\tset_SOGO(ctrl);\n\n\twait_for_ctrl_irq(ctrl);\n\tmdelay(1100);\n\n\t \n\twritel(leds, ctrl->hpc_reg + LED_CONTROL);\n\twriteb(slot_power, ctrl->hpc_reg + SLOT_ENABLE);\n\n\tset_SOGO(ctrl);\n\twait_for_ctrl_irq(ctrl);\n\n\tbus->cur_bus_speed = adapter_speed;\n\tslot = cpqhp_find_slot(ctrl, hp_slot + ctrl->slot_device_offset);\n\n\tinfo(\"Successfully changed frequency/mode for adapter in slot %d\\n\",\n\t\t\tslot->number);\n\treturn 0;\n}\n\n \n\n\n \nstatic u32 board_replaced(struct pci_func *func, struct controller *ctrl)\n{\n\tstruct pci_bus *bus = ctrl->pci_bus;\n\tu8 hp_slot;\n\tu8 temp_byte;\n\tu8 adapter_speed;\n\tu32 rc = 0;\n\n\thp_slot = func->device - ctrl->slot_device_offset;\n\n\t \n\tif (readl(ctrl->hpc_reg + INT_INPUT_CLEAR) & (0x01L << hp_slot))\n\t\trc = INTERLOCK_OPEN;\n\t \n\telse if (is_slot_enabled(ctrl, hp_slot))\n\t\trc = CARD_FUNCTIONING;\n\telse {\n\t\tmutex_lock(&ctrl->crit_sect);\n\n\t\t \n\t\tenable_slot_power(ctrl, hp_slot);\n\n\t\tset_SOGO(ctrl);\n\n\t\t \n\t\twait_for_ctrl_irq(ctrl);\n\n\t\t \n\t\ttemp_byte = readb(ctrl->hpc_reg + SLOT_POWER);\n\t\twriteb(0x00, ctrl->hpc_reg + SLOT_POWER);\n\t\twriteb(temp_byte, ctrl->hpc_reg + SLOT_POWER);\n\n\t\tset_SOGO(ctrl);\n\n\t\t \n\t\twait_for_ctrl_irq(ctrl);\n\n\t\tadapter_speed = get_adapter_speed(ctrl, hp_slot);\n\t\tif (bus->cur_bus_speed != adapter_speed)\n\t\t\tif (set_controller_speed(ctrl, adapter_speed, hp_slot))\n\t\t\t\trc = WRONG_BUS_FREQUENCY;\n\n\t\t \n\t\tdisable_slot_power(ctrl, hp_slot);\n\n\t\tset_SOGO(ctrl);\n\n\t\t \n\t\twait_for_ctrl_irq(ctrl);\n\n\t\tmutex_unlock(&ctrl->crit_sect);\n\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\tmutex_lock(&ctrl->crit_sect);\n\n\t\tslot_enable(ctrl, hp_slot);\n\t\tgreen_LED_blink(ctrl, hp_slot);\n\n\t\tamber_LED_off(ctrl, hp_slot);\n\n\t\tset_SOGO(ctrl);\n\n\t\t \n\t\twait_for_ctrl_irq(ctrl);\n\n\t\tmutex_unlock(&ctrl->crit_sect);\n\n\t\t \n\t\tlong_delay(1*HZ);\n\n\t\t \n\t\tif (func->status == 0xFF) {\n\t\t\t \n\t\t\trc = POWER_FAILURE;\n\t\t\tfunc->status = 0;\n\t\t} else\n\t\t\trc = cpqhp_valid_replace(ctrl, func);\n\n\t\tif (!rc) {\n\t\t\t \n\n\t\t\trc = cpqhp_configure_board(ctrl, func);\n\n\t\t\t \n\n\t\t\tmutex_lock(&ctrl->crit_sect);\n\n\t\t\tamber_LED_on(ctrl, hp_slot);\n\t\t\tgreen_LED_off(ctrl, hp_slot);\n\t\t\tslot_disable(ctrl, hp_slot);\n\n\t\t\tset_SOGO(ctrl);\n\n\t\t\t \n\t\t\twait_for_ctrl_irq(ctrl);\n\n\t\t\tmutex_unlock(&ctrl->crit_sect);\n\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t\telse\n\t\t\t\treturn 1;\n\n\t\t} else {\n\t\t\t \n\n\t\t\tmutex_lock(&ctrl->crit_sect);\n\n\t\t\tamber_LED_on(ctrl, hp_slot);\n\t\t\tgreen_LED_off(ctrl, hp_slot);\n\t\t\tslot_disable(ctrl, hp_slot);\n\n\t\t\tset_SOGO(ctrl);\n\n\t\t\t \n\t\t\twait_for_ctrl_irq(ctrl);\n\n\t\t\tmutex_unlock(&ctrl->crit_sect);\n\t\t}\n\n\t}\n\treturn rc;\n\n}\n\n\n \nstatic u32 board_added(struct pci_func *func, struct controller *ctrl)\n{\n\tu8 hp_slot;\n\tu8 temp_byte;\n\tu8 adapter_speed;\n\tint index;\n\tu32 temp_register = 0xFFFFFFFF;\n\tu32 rc = 0;\n\tstruct pci_func *new_slot = NULL;\n\tstruct pci_bus *bus = ctrl->pci_bus;\n\tstruct resource_lists res_lists;\n\n\thp_slot = func->device - ctrl->slot_device_offset;\n\tdbg(\"%s: func->device, slot_offset, hp_slot = %d, %d ,%d\\n\",\n\t    __func__, func->device, ctrl->slot_device_offset, hp_slot);\n\n\tmutex_lock(&ctrl->crit_sect);\n\n\t \n\tenable_slot_power(ctrl, hp_slot);\n\n\tset_SOGO(ctrl);\n\n\t \n\twait_for_ctrl_irq(ctrl);\n\n\t \n\ttemp_byte = readb(ctrl->hpc_reg + SLOT_POWER);\n\twriteb(0x00, ctrl->hpc_reg + SLOT_POWER);\n\twriteb(temp_byte, ctrl->hpc_reg + SLOT_POWER);\n\n\tset_SOGO(ctrl);\n\n\t \n\twait_for_ctrl_irq(ctrl);\n\n\tadapter_speed = get_adapter_speed(ctrl, hp_slot);\n\tif (bus->cur_bus_speed != adapter_speed)\n\t\tif (set_controller_speed(ctrl, adapter_speed, hp_slot))\n\t\t\trc = WRONG_BUS_FREQUENCY;\n\n\t \n\tdisable_slot_power(ctrl, hp_slot);\n\n\tset_SOGO(ctrl);\n\n\t \n\twait_for_ctrl_irq(ctrl);\n\n\tmutex_unlock(&ctrl->crit_sect);\n\n\tif (rc)\n\t\treturn rc;\n\n\tcpqhp_find_slot(ctrl, hp_slot + ctrl->slot_device_offset);\n\n\t \n\n\tdbg(\"%s: before down\\n\", __func__);\n\tmutex_lock(&ctrl->crit_sect);\n\tdbg(\"%s: after down\\n\", __func__);\n\n\tdbg(\"%s: before slot_enable\\n\", __func__);\n\tslot_enable(ctrl, hp_slot);\n\n\tdbg(\"%s: before green_LED_blink\\n\", __func__);\n\tgreen_LED_blink(ctrl, hp_slot);\n\n\tdbg(\"%s: before amber_LED_blink\\n\", __func__);\n\tamber_LED_off(ctrl, hp_slot);\n\n\tdbg(\"%s: before set_SOGO\\n\", __func__);\n\tset_SOGO(ctrl);\n\n\t \n\tdbg(\"%s: before wait_for_ctrl_irq\\n\", __func__);\n\twait_for_ctrl_irq(ctrl);\n\tdbg(\"%s: after wait_for_ctrl_irq\\n\", __func__);\n\n\tdbg(\"%s: before up\\n\", __func__);\n\tmutex_unlock(&ctrl->crit_sect);\n\tdbg(\"%s: after up\\n\", __func__);\n\n\t \n\tdbg(\"%s: before long_delay\\n\", __func__);\n\tlong_delay(1*HZ);\n\tdbg(\"%s: after long_delay\\n\", __func__);\n\n\tdbg(\"%s: func status = %x\\n\", __func__, func->status);\n\t \n\tif (func->status == 0xFF) {\n\t\t \n\t\ttemp_register = 0xFFFFFFFF;\n\t\tdbg(\"%s: temp register set to %x by power fault\\n\", __func__, temp_register);\n\t\trc = POWER_FAILURE;\n\t\tfunc->status = 0;\n\t} else {\n\t\t \n\t\tctrl->pci_bus->number = func->bus;\n\t\trc = pci_bus_read_config_dword(ctrl->pci_bus, PCI_DEVFN(func->device, func->function), PCI_VENDOR_ID, &temp_register);\n\t\tdbg(\"%s: pci_read_config_dword returns %d\\n\", __func__, rc);\n\t\tdbg(\"%s: temp_register is %x\\n\", __func__, temp_register);\n\n\t\tif (rc != 0) {\n\t\t\t \n\t\t\ttemp_register = 0xFFFFFFFF;\n\t\t\tdbg(\"%s: temp register set to %x by error\\n\", __func__, temp_register);\n\t\t}\n\t\t \n\t\trc = NO_ADAPTER_PRESENT;\n\t}\n\n\t \n\tif (temp_register != 0xFFFFFFFF) {\n\t\tres_lists.io_head = ctrl->io_head;\n\t\tres_lists.mem_head = ctrl->mem_head;\n\t\tres_lists.p_mem_head = ctrl->p_mem_head;\n\t\tres_lists.bus_head = ctrl->bus_head;\n\t\tres_lists.irqs = NULL;\n\n\t\trc = configure_new_device(ctrl, func, 0, &res_lists);\n\n\t\tdbg(\"%s: back from configure_new_device\\n\", __func__);\n\t\tctrl->io_head = res_lists.io_head;\n\t\tctrl->mem_head = res_lists.mem_head;\n\t\tctrl->p_mem_head = res_lists.p_mem_head;\n\t\tctrl->bus_head = res_lists.bus_head;\n\n\t\tcpqhp_resource_sort_and_combine(&(ctrl->mem_head));\n\t\tcpqhp_resource_sort_and_combine(&(ctrl->p_mem_head));\n\t\tcpqhp_resource_sort_and_combine(&(ctrl->io_head));\n\t\tcpqhp_resource_sort_and_combine(&(ctrl->bus_head));\n\n\t\tif (rc) {\n\t\t\tmutex_lock(&ctrl->crit_sect);\n\n\t\t\tamber_LED_on(ctrl, hp_slot);\n\t\t\tgreen_LED_off(ctrl, hp_slot);\n\t\t\tslot_disable(ctrl, hp_slot);\n\n\t\t\tset_SOGO(ctrl);\n\n\t\t\t \n\t\t\twait_for_ctrl_irq(ctrl);\n\n\t\t\tmutex_unlock(&ctrl->crit_sect);\n\t\t\treturn rc;\n\t\t} else {\n\t\t\tcpqhp_save_slot_config(ctrl, func);\n\t\t}\n\n\n\t\tfunc->status = 0;\n\t\tfunc->switch_save = 0x10;\n\t\tfunc->is_a_board = 0x01;\n\n\t\t \n\t\tdbg(\"%s: configure linux pci_dev structure\\n\", __func__);\n\t\tindex = 0;\n\t\tdo {\n\t\t\tnew_slot = cpqhp_slot_find(ctrl->bus, func->device, index++);\n\t\t\tif (new_slot && !new_slot->pci_dev)\n\t\t\t\tcpqhp_configure_device(ctrl, new_slot);\n\t\t} while (new_slot);\n\n\t\tmutex_lock(&ctrl->crit_sect);\n\n\t\tgreen_LED_on(ctrl, hp_slot);\n\n\t\tset_SOGO(ctrl);\n\n\t\t \n\t\twait_for_ctrl_irq(ctrl);\n\n\t\tmutex_unlock(&ctrl->crit_sect);\n\t} else {\n\t\tmutex_lock(&ctrl->crit_sect);\n\n\t\tamber_LED_on(ctrl, hp_slot);\n\t\tgreen_LED_off(ctrl, hp_slot);\n\t\tslot_disable(ctrl, hp_slot);\n\n\t\tset_SOGO(ctrl);\n\n\t\t \n\t\twait_for_ctrl_irq(ctrl);\n\n\t\tmutex_unlock(&ctrl->crit_sect);\n\n\t\treturn rc;\n\t}\n\treturn 0;\n}\n\n\n \nstatic u32 remove_board(struct pci_func *func, u32 replace_flag, struct controller *ctrl)\n{\n\tint index;\n\tu8 skip = 0;\n\tu8 device;\n\tu8 hp_slot;\n\tu8 temp_byte;\n\tstruct resource_lists res_lists;\n\tstruct pci_func *temp_func;\n\n\tif (cpqhp_unconfigure_device(func))\n\t\treturn 1;\n\n\tdevice = func->device;\n\n\thp_slot = func->device - ctrl->slot_device_offset;\n\tdbg(\"In %s, hp_slot = %d\\n\", __func__, hp_slot);\n\n\t \n\tif (replace_flag || !ctrl->add_support)\n\t\tcpqhp_save_base_addr_length(ctrl, func);\n\telse if (!func->bus_head && !func->mem_head &&\n\t\t !func->p_mem_head && !func->io_head) {\n\t\t \n\t\tindex = 0;\n\t\ttemp_func = cpqhp_slot_find(func->bus, func->device, index++);\n\t\twhile (temp_func) {\n\t\t\tif (temp_func->bus_head || temp_func->mem_head\n\t\t\t    || temp_func->p_mem_head || temp_func->io_head) {\n\t\t\t\tskip = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttemp_func = cpqhp_slot_find(temp_func->bus, temp_func->device, index++);\n\t\t}\n\n\t\tif (!skip)\n\t\t\tcpqhp_save_used_resources(ctrl, func);\n\t}\n\t \n\tif (func->is_a_board)\n\t\tfunc->status = 0x01;\n\tfunc->configured = 0;\n\n\tmutex_lock(&ctrl->crit_sect);\n\n\tgreen_LED_off(ctrl, hp_slot);\n\tslot_disable(ctrl, hp_slot);\n\n\tset_SOGO(ctrl);\n\n\t \n\ttemp_byte = readb(ctrl->hpc_reg + SLOT_SERR);\n\ttemp_byte &= ~(0x01 << hp_slot);\n\twriteb(temp_byte, ctrl->hpc_reg + SLOT_SERR);\n\n\t \n\twait_for_ctrl_irq(ctrl);\n\n\tmutex_unlock(&ctrl->crit_sect);\n\n\tif (!replace_flag && ctrl->add_support) {\n\t\twhile (func) {\n\t\t\tres_lists.io_head = ctrl->io_head;\n\t\t\tres_lists.mem_head = ctrl->mem_head;\n\t\t\tres_lists.p_mem_head = ctrl->p_mem_head;\n\t\t\tres_lists.bus_head = ctrl->bus_head;\n\n\t\t\tcpqhp_return_board_resources(func, &res_lists);\n\n\t\t\tctrl->io_head = res_lists.io_head;\n\t\t\tctrl->mem_head = res_lists.mem_head;\n\t\t\tctrl->p_mem_head = res_lists.p_mem_head;\n\t\t\tctrl->bus_head = res_lists.bus_head;\n\n\t\t\tcpqhp_resource_sort_and_combine(&(ctrl->mem_head));\n\t\t\tcpqhp_resource_sort_and_combine(&(ctrl->p_mem_head));\n\t\t\tcpqhp_resource_sort_and_combine(&(ctrl->io_head));\n\t\t\tcpqhp_resource_sort_and_combine(&(ctrl->bus_head));\n\n\t\t\tif (is_bridge(func)) {\n\t\t\t\tbridge_slot_remove(func);\n\t\t\t} else\n\t\t\t\tslot_remove(func);\n\n\t\t\tfunc = cpqhp_slot_find(ctrl->bus, device, 0);\n\t\t}\n\n\t\t \n\t\tfunc = cpqhp_slot_create(ctrl->bus);\n\n\t\tif (func == NULL)\n\t\t\treturn 1;\n\n\t\tfunc->bus = ctrl->bus;\n\t\tfunc->device = device;\n\t\tfunc->function = 0;\n\t\tfunc->configured = 0;\n\t\tfunc->switch_save = 0x10;\n\t\tfunc->is_a_board = 0;\n\t\tfunc->p_task_event = NULL;\n\t}\n\n\treturn 0;\n}\n\nstatic void pushbutton_helper_thread(struct timer_list *t)\n{\n\tpushbutton_pending = t;\n\n\twake_up_process(cpqhp_event_thread);\n}\n\n\n \nstatic int event_thread(void *data)\n{\n\tstruct controller *ctrl;\n\n\twhile (1) {\n\t\tdbg(\"!!!!event_thread sleeping\\n\");\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tschedule();\n\n\t\tif (kthread_should_stop())\n\t\t\tbreak;\n\t\t \n\t\tif (pushbutton_pending)\n\t\t\tcpqhp_pushbutton_thread(pushbutton_pending);\n\t\telse\n\t\t\tfor (ctrl = cpqhp_ctrl_list; ctrl; ctrl = ctrl->next)\n\t\t\t\tinterrupt_event_handler(ctrl);\n\t}\n\tdbg(\"event_thread signals exit\\n\");\n\treturn 0;\n}\n\nint cpqhp_event_start_thread(void)\n{\n\tcpqhp_event_thread = kthread_run(event_thread, NULL, \"phpd_event\");\n\tif (IS_ERR(cpqhp_event_thread)) {\n\t\terr(\"Can't start up our event thread\\n\");\n\t\treturn PTR_ERR(cpqhp_event_thread);\n\t}\n\n\treturn 0;\n}\n\n\nvoid cpqhp_event_stop_thread(void)\n{\n\tkthread_stop(cpqhp_event_thread);\n}\n\n\nstatic void interrupt_event_handler(struct controller *ctrl)\n{\n\tint loop;\n\tint change = 1;\n\tstruct pci_func *func;\n\tu8 hp_slot;\n\tstruct slot *p_slot;\n\n\twhile (change) {\n\t\tchange = 0;\n\n\t\tfor (loop = 0; loop < 10; loop++) {\n\t\t\t \n\t\t\tif (ctrl->event_queue[loop].event_type != 0) {\n\t\t\t\thp_slot = ctrl->event_queue[loop].hp_slot;\n\n\t\t\t\tfunc = cpqhp_slot_find(ctrl->bus, (hp_slot + ctrl->slot_device_offset), 0);\n\t\t\t\tif (!func)\n\t\t\t\t\treturn;\n\n\t\t\t\tp_slot = cpqhp_find_slot(ctrl, hp_slot + ctrl->slot_device_offset);\n\t\t\t\tif (!p_slot)\n\t\t\t\t\treturn;\n\n\t\t\t\tdbg(\"hp_slot %d, func %p, p_slot %p\\n\",\n\t\t\t\t    hp_slot, func, p_slot);\n\n\t\t\t\tif (ctrl->event_queue[loop].event_type == INT_BUTTON_PRESS) {\n\t\t\t\t\tdbg(\"button pressed\\n\");\n\t\t\t\t} else if (ctrl->event_queue[loop].event_type ==\n\t\t\t\t\t   INT_BUTTON_CANCEL) {\n\t\t\t\t\tdbg(\"button cancel\\n\");\n\t\t\t\t\tdel_timer(&p_slot->task_event);\n\n\t\t\t\t\tmutex_lock(&ctrl->crit_sect);\n\n\t\t\t\t\tif (p_slot->state == BLINKINGOFF_STATE) {\n\t\t\t\t\t\t \n\t\t\t\t\t\tdbg(\"turn on green LED\\n\");\n\t\t\t\t\t\tgreen_LED_on(ctrl, hp_slot);\n\t\t\t\t\t} else if (p_slot->state == BLINKINGON_STATE) {\n\t\t\t\t\t\t \n\t\t\t\t\t\tdbg(\"turn off green LED\\n\");\n\t\t\t\t\t\tgreen_LED_off(ctrl, hp_slot);\n\t\t\t\t\t}\n\n\t\t\t\t\tinfo(msg_button_cancel, p_slot->number);\n\n\t\t\t\t\tp_slot->state = STATIC_STATE;\n\n\t\t\t\t\tamber_LED_off(ctrl, hp_slot);\n\n\t\t\t\t\tset_SOGO(ctrl);\n\n\t\t\t\t\t \n\t\t\t\t\twait_for_ctrl_irq(ctrl);\n\n\t\t\t\t\tmutex_unlock(&ctrl->crit_sect);\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\telse if (ctrl->event_queue[loop].event_type == INT_BUTTON_RELEASE) {\n\t\t\t\t\tdbg(\"button release\\n\");\n\n\t\t\t\t\tif (is_slot_enabled(ctrl, hp_slot)) {\n\t\t\t\t\t\tdbg(\"slot is on\\n\");\n\t\t\t\t\t\tp_slot->state = BLINKINGOFF_STATE;\n\t\t\t\t\t\tinfo(msg_button_off, p_slot->number);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdbg(\"slot is off\\n\");\n\t\t\t\t\t\tp_slot->state = BLINKINGON_STATE;\n\t\t\t\t\t\tinfo(msg_button_on, p_slot->number);\n\t\t\t\t\t}\n\t\t\t\t\tmutex_lock(&ctrl->crit_sect);\n\n\t\t\t\t\tdbg(\"blink green LED and turn off amber\\n\");\n\n\t\t\t\t\tamber_LED_off(ctrl, hp_slot);\n\t\t\t\t\tgreen_LED_blink(ctrl, hp_slot);\n\n\t\t\t\t\tset_SOGO(ctrl);\n\n\t\t\t\t\t \n\t\t\t\t\twait_for_ctrl_irq(ctrl);\n\n\t\t\t\t\tmutex_unlock(&ctrl->crit_sect);\n\t\t\t\t\ttimer_setup(&p_slot->task_event,\n\t\t\t\t\t\t    pushbutton_helper_thread,\n\t\t\t\t\t\t    0);\n\t\t\t\t\tp_slot->hp_slot = hp_slot;\n\t\t\t\t\tp_slot->ctrl = ctrl;\n \n\t\t\t\t\tp_slot->task_event.expires = jiffies + 5 * HZ;    \n\n\t\t\t\t\tdbg(\"add_timer p_slot = %p\\n\", p_slot);\n\t\t\t\t\tadd_timer(&p_slot->task_event);\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\telse if (ctrl->event_queue[loop].event_type == INT_POWER_FAULT) {\n\t\t\t\t\tdbg(\"power fault\\n\");\n\t\t\t\t}\n\n\t\t\t\tctrl->event_queue[loop].event_type = 0;\n\n\t\t\t\tchange = 1;\n\t\t\t}\n\t\t}\t\t \n\t}\n}\n\n\n \nvoid cpqhp_pushbutton_thread(struct timer_list *t)\n{\n\tu8 hp_slot;\n\tstruct pci_func *func;\n\tstruct slot *p_slot = from_timer(p_slot, t, task_event);\n\tstruct controller *ctrl = (struct controller *) p_slot->ctrl;\n\n\tpushbutton_pending = NULL;\n\thp_slot = p_slot->hp_slot;\n\n\tif (is_slot_enabled(ctrl, hp_slot)) {\n\t\tp_slot->state = POWEROFF_STATE;\n\t\t \n\t\tfunc = cpqhp_slot_find(p_slot->bus, p_slot->device, 0);\n\t\tdbg(\"In power_down_board, func = %p, ctrl = %p\\n\", func, ctrl);\n\t\tif (!func) {\n\t\t\tdbg(\"Error! func NULL in %s\\n\", __func__);\n\t\t\treturn;\n\t\t}\n\n\t\tif (cpqhp_process_SS(ctrl, func) != 0) {\n\t\t\tamber_LED_on(ctrl, hp_slot);\n\t\t\tgreen_LED_on(ctrl, hp_slot);\n\n\t\t\tset_SOGO(ctrl);\n\n\t\t\t \n\t\t\twait_for_ctrl_irq(ctrl);\n\t\t}\n\n\t\tp_slot->state = STATIC_STATE;\n\t} else {\n\t\tp_slot->state = POWERON_STATE;\n\t\t \n\n\t\tfunc = cpqhp_slot_find(p_slot->bus, p_slot->device, 0);\n\t\tdbg(\"In add_board, func = %p, ctrl = %p\\n\", func, ctrl);\n\t\tif (!func) {\n\t\t\tdbg(\"Error! func NULL in %s\\n\", __func__);\n\t\t\treturn;\n\t\t}\n\n\t\tif (ctrl != NULL) {\n\t\t\tif (cpqhp_process_SI(ctrl, func) != 0) {\n\t\t\t\tamber_LED_on(ctrl, hp_slot);\n\t\t\t\tgreen_LED_off(ctrl, hp_slot);\n\n\t\t\t\tset_SOGO(ctrl);\n\n\t\t\t\t \n\t\t\t\twait_for_ctrl_irq(ctrl);\n\t\t\t}\n\t\t}\n\n\t\tp_slot->state = STATIC_STATE;\n\t}\n}\n\n\nint cpqhp_process_SI(struct controller *ctrl, struct pci_func *func)\n{\n\tu8 device, hp_slot;\n\tu16 temp_word;\n\tu32 tempdword;\n\tint rc;\n\tstruct slot *p_slot;\n\n\ttempdword = 0;\n\n\tdevice = func->device;\n\thp_slot = device - ctrl->slot_device_offset;\n\tp_slot = cpqhp_find_slot(ctrl, device);\n\n\t \n\ttempdword = readl(ctrl->hpc_reg + INT_INPUT_CLEAR);\n\n\tif (tempdword & (0x01 << hp_slot))\n\t\treturn 1;\n\n\tif (func->is_a_board) {\n\t\trc = board_replaced(func, ctrl);\n\t} else {\n\t\t \n\t\tslot_remove(func);\n\n\t\tfunc = cpqhp_slot_create(ctrl->bus);\n\t\tif (func == NULL)\n\t\t\treturn 1;\n\n\t\tfunc->bus = ctrl->bus;\n\t\tfunc->device = device;\n\t\tfunc->function = 0;\n\t\tfunc->configured = 0;\n\t\tfunc->is_a_board = 1;\n\n\t\t \n\t\ttemp_word = ctrl->ctrl_int_comp >> 16;\n\t\tfunc->presence_save = (temp_word >> hp_slot) & 0x01;\n\t\tfunc->presence_save |= (temp_word >> (hp_slot + 7)) & 0x02;\n\n\t\tif (ctrl->ctrl_int_comp & (0x1L << hp_slot)) {\n\t\t\tfunc->switch_save = 0;\n\t\t} else {\n\t\t\tfunc->switch_save = 0x10;\n\t\t}\n\n\t\trc = board_added(func, ctrl);\n\t\tif (rc) {\n\t\t\tif (is_bridge(func)) {\n\t\t\t\tbridge_slot_remove(func);\n\t\t\t} else\n\t\t\t\tslot_remove(func);\n\n\t\t\t \n\t\t\tfunc = cpqhp_slot_create(ctrl->bus);\n\n\t\t\tif (func == NULL)\n\t\t\t\treturn 1;\n\n\t\t\tfunc->bus = ctrl->bus;\n\t\t\tfunc->device = device;\n\t\t\tfunc->function = 0;\n\t\t\tfunc->configured = 0;\n\t\t\tfunc->is_a_board = 0;\n\n\t\t\t \n\t\t\ttemp_word = ctrl->ctrl_int_comp >> 16;\n\t\t\tfunc->presence_save = (temp_word >> hp_slot) & 0x01;\n\t\t\tfunc->presence_save |=\n\t\t\t(temp_word >> (hp_slot + 7)) & 0x02;\n\n\t\t\tif (ctrl->ctrl_int_comp & (0x1L << hp_slot)) {\n\t\t\t\tfunc->switch_save = 0;\n\t\t\t} else {\n\t\t\t\tfunc->switch_save = 0x10;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (rc)\n\t\tdbg(\"%s: rc = %d\\n\", __func__, rc);\n\n\treturn rc;\n}\n\n\nint cpqhp_process_SS(struct controller *ctrl, struct pci_func *func)\n{\n\tu8 device, class_code, header_type, BCR;\n\tu8 index = 0;\n\tu8 replace_flag;\n\tu32 rc = 0;\n\tunsigned int devfn;\n\tstruct slot *p_slot;\n\tstruct pci_bus *pci_bus = ctrl->pci_bus;\n\n\tdevice = func->device;\n\tfunc = cpqhp_slot_find(ctrl->bus, device, index++);\n\tp_slot = cpqhp_find_slot(ctrl, device);\n\n\t \n\twhile (func && !rc) {\n\t\tpci_bus->number = func->bus;\n\t\tdevfn = PCI_DEVFN(func->device, func->function);\n\n\t\t \n\t\trc = pci_bus_read_config_byte(pci_bus, devfn, 0x0B, &class_code);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\tif (class_code == PCI_BASE_CLASS_DISPLAY) {\n\t\t\t \n\t\t\trc = REMOVE_NOT_SUPPORTED;\n\t\t} else {\n\t\t\t \n\t\t\trc = pci_bus_read_config_byte(pci_bus, devfn, PCI_HEADER_TYPE, &header_type);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\n\t\t\t \n\t\t\tif ((header_type & 0x7F) == PCI_HEADER_TYPE_BRIDGE) {\n\t\t\t\trc = pci_bus_read_config_byte(pci_bus, devfn, PCI_BRIDGE_CONTROL, &BCR);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\n\t\t\t\t \n\t\t\t\tif (BCR & PCI_BRIDGE_CTL_VGA)\n\t\t\t\t\trc = REMOVE_NOT_SUPPORTED;\n\t\t\t}\n\t\t}\n\n\t\tfunc = cpqhp_slot_find(ctrl->bus, device, index++);\n\t}\n\n\tfunc = cpqhp_slot_find(ctrl->bus, device, 0);\n\tif ((func != NULL) && !rc) {\n\t\t \n\t\treplace_flag = !(ctrl->add_support);\n\t\trc = remove_board(func, replace_flag, ctrl);\n\t} else if (!rc) {\n\t\trc = 1;\n\t}\n\n\treturn rc;\n}\n\n \nstatic void switch_leds(struct controller *ctrl, const int num_of_slots,\n\t\t\tu32 *work_LED, const int direction)\n{\n\tint loop;\n\n\tfor (loop = 0; loop < num_of_slots; loop++) {\n\t\tif (direction)\n\t\t\t*work_LED = *work_LED >> 1;\n\t\telse\n\t\t\t*work_LED = *work_LED << 1;\n\t\twritel(*work_LED, ctrl->hpc_reg + LED_CONTROL);\n\n\t\tset_SOGO(ctrl);\n\n\t\t \n\t\twait_for_ctrl_irq(ctrl);\n\n\t\t \n\t\tlong_delay((2*HZ)/10);\n\t}\n}\n\n \nint cpqhp_hardware_test(struct controller *ctrl, int test_num)\n{\n\tu32 save_LED;\n\tu32 work_LED;\n\tint loop;\n\tint num_of_slots;\n\n\tnum_of_slots = readb(ctrl->hpc_reg + SLOT_MASK) & 0x0f;\n\n\tswitch (test_num) {\n\tcase 1:\n\t\t \n\n\t\t \n\t\t \n\t\tsave_LED = readl(ctrl->hpc_reg + LED_CONTROL);\n\t\twork_LED = 0x01010101;\n\t\tswitch_leds(ctrl, num_of_slots, &work_LED, 0);\n\t\tswitch_leds(ctrl, num_of_slots, &work_LED, 1);\n\t\tswitch_leds(ctrl, num_of_slots, &work_LED, 0);\n\t\tswitch_leds(ctrl, num_of_slots, &work_LED, 1);\n\n\t\twork_LED = 0x01010000;\n\t\twritel(work_LED, ctrl->hpc_reg + LED_CONTROL);\n\t\tswitch_leds(ctrl, num_of_slots, &work_LED, 0);\n\t\tswitch_leds(ctrl, num_of_slots, &work_LED, 1);\n\t\twork_LED = 0x00000101;\n\t\twritel(work_LED, ctrl->hpc_reg + LED_CONTROL);\n\t\tswitch_leds(ctrl, num_of_slots, &work_LED, 0);\n\t\tswitch_leds(ctrl, num_of_slots, &work_LED, 1);\n\n\t\twork_LED = 0x01010000;\n\t\twritel(work_LED, ctrl->hpc_reg + LED_CONTROL);\n\t\tfor (loop = 0; loop < num_of_slots; loop++) {\n\t\t\tset_SOGO(ctrl);\n\n\t\t\t \n\t\t\twait_for_ctrl_irq(ctrl);\n\n\t\t\t \n\t\t\tlong_delay((3*HZ)/10);\n\t\t\twork_LED = work_LED >> 16;\n\t\t\twritel(work_LED, ctrl->hpc_reg + LED_CONTROL);\n\n\t\t\tset_SOGO(ctrl);\n\n\t\t\t \n\t\t\twait_for_ctrl_irq(ctrl);\n\n\t\t\t \n\t\t\tlong_delay((3*HZ)/10);\n\t\t\twork_LED = work_LED << 16;\n\t\t\twritel(work_LED, ctrl->hpc_reg + LED_CONTROL);\n\t\t\twork_LED = work_LED << 1;\n\t\t\twritel(work_LED, ctrl->hpc_reg + LED_CONTROL);\n\t\t}\n\n\t\t \n\t\twritel(save_LED, ctrl->hpc_reg + LED_CONTROL);\n\n\t\tset_SOGO(ctrl);\n\n\t\t \n\t\twait_for_ctrl_irq(ctrl);\n\t\tbreak;\n\tcase 2:\n\t\t \n\t\tbreak;\n\tcase 3:\n\t\t \n\t\tbreak;\n\t}\n\treturn 0;\n}\n\n\n \nstatic u32 configure_new_device(struct controller  *ctrl, struct pci_func  *func,\n\t\t\t\t u8 behind_bridge, struct resource_lists  *resources)\n{\n\tu8 temp_byte, function, max_functions, stop_it;\n\tint rc;\n\tu32 ID;\n\tstruct pci_func *new_slot;\n\tint index;\n\n\tnew_slot = func;\n\n\tdbg(\"%s\\n\", __func__);\n\t \n\tctrl->pci_bus->number = func->bus;\n\trc = pci_bus_read_config_byte(ctrl->pci_bus, PCI_DEVFN(func->device, func->function), 0x0E, &temp_byte);\n\tif (rc) {\n\t\tdbg(\"%s: rc = %d\\n\", __func__, rc);\n\t\treturn rc;\n\t}\n\n\tif (temp_byte & 0x80)\t \n\t\tmax_functions = 8;\n\telse\n\t\tmax_functions = 1;\n\n\tfunction = 0;\n\n\tdo {\n\t\trc = configure_new_function(ctrl, new_slot, behind_bridge, resources);\n\n\t\tif (rc) {\n\t\t\tdbg(\"configure_new_function failed %d\\n\", rc);\n\t\t\tindex = 0;\n\n\t\t\twhile (new_slot) {\n\t\t\t\tnew_slot = cpqhp_slot_find(new_slot->bus, new_slot->device, index++);\n\n\t\t\t\tif (new_slot)\n\t\t\t\t\tcpqhp_return_board_resources(new_slot, resources);\n\t\t\t}\n\n\t\t\treturn rc;\n\t\t}\n\n\t\tfunction++;\n\n\t\tstop_it = 0;\n\n\t\t \n\n\t\twhile ((function < max_functions) && (!stop_it)) {\n\t\t\tpci_bus_read_config_dword(ctrl->pci_bus, PCI_DEVFN(func->device, function), 0x00, &ID);\n\n\t\t\tif (PCI_POSSIBLE_ERROR(ID)) {\n\t\t\t\tfunction++;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tnew_slot = cpqhp_slot_create(func->bus);\n\n\t\t\t\tif (new_slot == NULL)\n\t\t\t\t\treturn 1;\n\n\t\t\t\tnew_slot->bus = func->bus;\n\t\t\t\tnew_slot->device = func->device;\n\t\t\t\tnew_slot->function = function;\n\t\t\t\tnew_slot->is_a_board = 1;\n\t\t\t\tnew_slot->status = 0;\n\n\t\t\t\tstop_it++;\n\t\t\t}\n\t\t}\n\n\t} while (function < max_functions);\n\tdbg(\"returning from configure_new_device\\n\");\n\n\treturn 0;\n}\n\n\n \n\n\n \nstatic int configure_new_function(struct controller *ctrl, struct pci_func *func,\n\t\t\t\t   u8 behind_bridge,\n\t\t\t\t   struct resource_lists *resources)\n{\n\tint cloop;\n\tu8 IRQ = 0;\n\tu8 temp_byte;\n\tu8 device;\n\tu8 class_code;\n\tu16 command;\n\tu16 temp_word;\n\tu32 temp_dword;\n\tu32 rc;\n\tu32 temp_register;\n\tu32 base;\n\tu32 ID;\n\tunsigned int devfn;\n\tstruct pci_resource *mem_node;\n\tstruct pci_resource *p_mem_node;\n\tstruct pci_resource *io_node;\n\tstruct pci_resource *bus_node;\n\tstruct pci_resource *hold_mem_node;\n\tstruct pci_resource *hold_p_mem_node;\n\tstruct pci_resource *hold_IO_node;\n\tstruct pci_resource *hold_bus_node;\n\tstruct irq_mapping irqs;\n\tstruct pci_func *new_slot;\n\tstruct pci_bus *pci_bus;\n\tstruct resource_lists temp_resources;\n\n\tpci_bus = ctrl->pci_bus;\n\tpci_bus->number = func->bus;\n\tdevfn = PCI_DEVFN(func->device, func->function);\n\n\t \n\trc = pci_bus_read_config_byte(pci_bus, devfn, PCI_HEADER_TYPE, &temp_byte);\n\tif (rc)\n\t\treturn rc;\n\n\tif ((temp_byte & 0x7F) == PCI_HEADER_TYPE_BRIDGE) {\n\t\t \n\t\tdbg(\"set Primary bus = %d\\n\", func->bus);\n\t\trc = pci_bus_write_config_byte(pci_bus, devfn, PCI_PRIMARY_BUS, func->bus);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\t \n\t\tdbg(\"find ranges of buses to use\\n\");\n\t\tbus_node = get_max_resource(&(resources->bus_head), 1);\n\n\t\t \n\t\tif (!bus_node)\n\t\t\treturn -ENOMEM;\n\n\t\t \n\t\ttemp_byte = bus_node->base;\n\t\tdbg(\"set Secondary bus = %d\\n\", bus_node->base);\n\t\trc = pci_bus_write_config_byte(pci_bus, devfn, PCI_SECONDARY_BUS, temp_byte);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\t \n\t\ttemp_byte = bus_node->base + bus_node->length - 1;\n\t\tdbg(\"set subordinate bus = %d\\n\", bus_node->base + bus_node->length - 1);\n\t\trc = pci_bus_write_config_byte(pci_bus, devfn, PCI_SUBORDINATE_BUS, temp_byte);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\t \n\t\ttemp_byte = 0x40;\n\t\trc = pci_bus_write_config_byte(pci_bus, devfn, PCI_SEC_LATENCY_TIMER, temp_byte);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\trc = pci_bus_write_config_byte(pci_bus, devfn, PCI_LATENCY_TIMER, temp_byte);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\t \n\t\ttemp_byte = 0x08;\n\t\trc = pci_bus_write_config_byte(pci_bus, devfn, PCI_CACHE_LINE_SIZE, temp_byte);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\t \n\t\tio_node = get_max_resource(&(resources->io_head), 0x1000);\n\t\tif (!io_node)\n\t\t\treturn -ENOMEM;\n\t\tmem_node = get_max_resource(&(resources->mem_head), 0x100000);\n\t\tif (!mem_node)\n\t\t\treturn -ENOMEM;\n\t\tp_mem_node = get_max_resource(&(resources->p_mem_head), 0x100000);\n\t\tif (!p_mem_node)\n\t\t\treturn -ENOMEM;\n\t\tdbg(\"Setup the IO, memory, and prefetchable windows\\n\");\n\t\tdbg(\"io_node\\n\");\n\t\tdbg(\"(base, len, next) (%x, %x, %p)\\n\", io_node->base,\n\t\t\t\t\tio_node->length, io_node->next);\n\t\tdbg(\"mem_node\\n\");\n\t\tdbg(\"(base, len, next) (%x, %x, %p)\\n\", mem_node->base,\n\t\t\t\t\tmem_node->length, mem_node->next);\n\t\tdbg(\"p_mem_node\\n\");\n\t\tdbg(\"(base, len, next) (%x, %x, %p)\\n\", p_mem_node->base,\n\t\t\t\t\tp_mem_node->length, p_mem_node->next);\n\n\t\t \n\t\tif (!resources->irqs) {\n\t\t\tirqs.barber_pole = 0;\n\t\t\tirqs.interrupt[0] = 0;\n\t\t\tirqs.interrupt[1] = 0;\n\t\t\tirqs.interrupt[2] = 0;\n\t\t\tirqs.interrupt[3] = 0;\n\t\t\tirqs.valid_INT = 0;\n\t\t} else {\n\t\t\tirqs.barber_pole = resources->irqs->barber_pole;\n\t\t\tirqs.interrupt[0] = resources->irqs->interrupt[0];\n\t\t\tirqs.interrupt[1] = resources->irqs->interrupt[1];\n\t\t\tirqs.interrupt[2] = resources->irqs->interrupt[2];\n\t\t\tirqs.interrupt[3] = resources->irqs->interrupt[3];\n\t\t\tirqs.valid_INT = resources->irqs->valid_INT;\n\t\t}\n\n\t\t \n\t\ttemp_resources.bus_head = bus_node;\n\t\ttemp_resources.io_head = io_node;\n\t\ttemp_resources.mem_head = mem_node;\n\t\ttemp_resources.p_mem_head = p_mem_node;\n\t\ttemp_resources.irqs = &irqs;\n\n\t\t \n\t\thold_bus_node = kmalloc(sizeof(*hold_bus_node), GFP_KERNEL);\n\t\thold_IO_node = kmalloc(sizeof(*hold_IO_node), GFP_KERNEL);\n\t\thold_mem_node = kmalloc(sizeof(*hold_mem_node), GFP_KERNEL);\n\t\thold_p_mem_node = kmalloc(sizeof(*hold_p_mem_node), GFP_KERNEL);\n\n\t\tif (!hold_bus_node || !hold_IO_node || !hold_mem_node || !hold_p_mem_node) {\n\t\t\tkfree(hold_bus_node);\n\t\t\tkfree(hold_IO_node);\n\t\t\tkfree(hold_mem_node);\n\t\t\tkfree(hold_p_mem_node);\n\n\t\t\treturn 1;\n\t\t}\n\n\t\tmemcpy(hold_bus_node, bus_node, sizeof(struct pci_resource));\n\n\t\tbus_node->base += 1;\n\t\tbus_node->length -= 1;\n\t\tbus_node->next = NULL;\n\n\t\t \n\t\tmemcpy(hold_IO_node, io_node, sizeof(struct pci_resource));\n\t\tio_node->next = NULL;\n\n\t\t \n\t\ttemp_byte = io_node->base >> 8;\n\t\trc = pci_bus_write_config_byte(pci_bus, devfn, PCI_IO_BASE, temp_byte);\n\n\t\ttemp_byte = (io_node->base + io_node->length - 1) >> 8;\n\t\trc = pci_bus_write_config_byte(pci_bus, devfn, PCI_IO_LIMIT, temp_byte);\n\n\t\t \n\t\tmemcpy(hold_mem_node, mem_node, sizeof(struct pci_resource));\n\t\tmem_node->next = NULL;\n\n\t\t \n\t\ttemp_word = mem_node->base >> 16;\n\t\trc = pci_bus_write_config_word(pci_bus, devfn, PCI_MEMORY_BASE, temp_word);\n\n\t\ttemp_word = (mem_node->base + mem_node->length - 1) >> 16;\n\t\trc = pci_bus_write_config_word(pci_bus, devfn, PCI_MEMORY_LIMIT, temp_word);\n\n\t\tmemcpy(hold_p_mem_node, p_mem_node, sizeof(struct pci_resource));\n\t\tp_mem_node->next = NULL;\n\n\t\t \n\t\ttemp_word = p_mem_node->base >> 16;\n\t\trc = pci_bus_write_config_word(pci_bus, devfn, PCI_PREF_MEMORY_BASE, temp_word);\n\n\t\ttemp_word = (p_mem_node->base + p_mem_node->length - 1) >> 16;\n\t\trc = pci_bus_write_config_word(pci_bus, devfn, PCI_PREF_MEMORY_LIMIT, temp_word);\n\n\t\t \n\t\tirqs.barber_pole--;\n\n\t\trc = 0;\n\n\t\t \n\t\tfor (device = 0; (device <= 0x1F) && !rc; device++) {\n\t\t\tirqs.barber_pole = (irqs.barber_pole + 1) & 0x03;\n\n\t\t\tID = 0xFFFFFFFF;\n\t\t\tpci_bus->number = hold_bus_node->base;\n\t\t\tpci_bus_read_config_dword(pci_bus, PCI_DEVFN(device, 0), 0x00, &ID);\n\t\t\tpci_bus->number = func->bus;\n\n\t\t\tif (!PCI_POSSIBLE_ERROR(ID)) {\t   \n\t\t\t\t \n\t\t\t\tnew_slot = cpqhp_slot_create(hold_bus_node->base);\n\n\t\t\t\tif (new_slot == NULL) {\n\t\t\t\t\trc = -ENOMEM;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tnew_slot->bus = hold_bus_node->base;\n\t\t\t\tnew_slot->device = device;\n\t\t\t\tnew_slot->function = 0;\n\t\t\t\tnew_slot->is_a_board = 1;\n\t\t\t\tnew_slot->status = 0;\n\n\t\t\t\trc = configure_new_device(ctrl, new_slot, 1, &temp_resources);\n\t\t\t\tdbg(\"configure_new_device rc=0x%x\\n\", rc);\n\t\t\t}\t \n\t\t}\t\t \n\n\t\tif (rc)\n\t\t\tgoto free_and_out;\n\t\t \n\t\tif (resources->irqs) {\n\t\t\tresources->irqs->interrupt[0] = irqs.interrupt[0];\n\t\t\tresources->irqs->interrupt[1] = irqs.interrupt[1];\n\t\t\tresources->irqs->interrupt[2] = irqs.interrupt[2];\n\t\t\tresources->irqs->interrupt[3] = irqs.interrupt[3];\n\t\t\tresources->irqs->valid_INT = irqs.valid_INT;\n\t\t} else if (!behind_bridge) {\n\t\t\t \n\t\t\tfor (cloop = 0; cloop < 4; cloop++) {\n\t\t\t\tif (irqs.valid_INT & (0x01 << cloop)) {\n\t\t\t\t\trc = cpqhp_set_irq(func->bus, func->device,\n\t\t\t\t\t\t\t   cloop + 1, irqs.interrupt[cloop]);\n\t\t\t\t\tif (rc)\n\t\t\t\t\t\tgoto free_and_out;\n\t\t\t\t}\n\t\t\t}\t \n\t\t}\n\t\t \n\t\tif (bus_node && temp_resources.bus_head) {\n\t\t\thold_bus_node->length = bus_node->base - hold_bus_node->base;\n\n\t\t\thold_bus_node->next = func->bus_head;\n\t\t\tfunc->bus_head = hold_bus_node;\n\n\t\t\ttemp_byte = temp_resources.bus_head->base - 1;\n\n\t\t\t \n\t\t\trc = pci_bus_write_config_byte(pci_bus, devfn, PCI_SUBORDINATE_BUS, temp_byte);\n\n\t\t\tif (temp_resources.bus_head->length == 0) {\n\t\t\t\tkfree(temp_resources.bus_head);\n\t\t\t\ttemp_resources.bus_head = NULL;\n\t\t\t} else {\n\t\t\t\treturn_resource(&(resources->bus_head), temp_resources.bus_head);\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (hold_IO_node && temp_resources.io_head) {\n\t\t\tio_node = do_pre_bridge_resource_split(&(temp_resources.io_head),\n\t\t\t\t\t\t\t       &hold_IO_node, 0x1000);\n\n\t\t\t \n\t\t\tif (io_node) {\n\t\t\t\thold_IO_node->base = io_node->base + io_node->length;\n\n\t\t\t\ttemp_byte = (hold_IO_node->base) >> 8;\n\t\t\t\trc = pci_bus_write_config_word(pci_bus, devfn, PCI_IO_BASE, temp_byte);\n\n\t\t\t\treturn_resource(&(resources->io_head), io_node);\n\t\t\t}\n\n\t\t\tio_node = do_bridge_resource_split(&(temp_resources.io_head), 0x1000);\n\n\t\t\t \n\t\t\tif (io_node) {\n\t\t\t\t \n\t\t\t\thold_IO_node->length = io_node->base - hold_IO_node->base;\n\n\t\t\t\t \n\t\t\t\tif (hold_IO_node->length) {\n\t\t\t\t\thold_IO_node->next = func->io_head;\n\t\t\t\t\tfunc->io_head = hold_IO_node;\n\n\t\t\t\t\ttemp_byte = (io_node->base - 1) >> 8;\n\t\t\t\t\trc = pci_bus_write_config_byte(pci_bus, devfn, PCI_IO_LIMIT, temp_byte);\n\n\t\t\t\t\treturn_resource(&(resources->io_head), io_node);\n\t\t\t\t} else {\n\t\t\t\t\t \n\t\t\t\t\ttemp_word = 0x0000;\n\t\t\t\t\trc = pci_bus_write_config_word(pci_bus, devfn, PCI_IO_LIMIT, temp_word);\n\n\t\t\t\t\treturn_resource(&(resources->io_head), io_node);\n\t\t\t\t\tkfree(hold_IO_node);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\thold_IO_node->next = func->io_head;\n\t\t\t\tfunc->io_head = hold_IO_node;\n\t\t\t}\n\t\t} else if (hold_IO_node) {\n\t\t\t \n\t\t\thold_IO_node->next = func->io_head;\n\t\t\tfunc->io_head = hold_IO_node;\n\t\t}\n\t\t \n\t\tif (hold_mem_node && temp_resources.mem_head) {\n\t\t\tmem_node = do_pre_bridge_resource_split(&(temp_resources.  mem_head),\n\t\t\t\t\t\t\t\t&hold_mem_node, 0x100000);\n\n\t\t\t \n\t\t\tif (mem_node) {\n\t\t\t\thold_mem_node->base = mem_node->base + mem_node->length;\n\n\t\t\t\ttemp_word = (hold_mem_node->base) >> 16;\n\t\t\t\trc = pci_bus_write_config_word(pci_bus, devfn, PCI_MEMORY_BASE, temp_word);\n\n\t\t\t\treturn_resource(&(resources->mem_head), mem_node);\n\t\t\t}\n\n\t\t\tmem_node = do_bridge_resource_split(&(temp_resources.mem_head), 0x100000);\n\n\t\t\t \n\t\t\tif (mem_node) {\n\t\t\t\t \n\t\t\t\thold_mem_node->length = mem_node->base - hold_mem_node->base;\n\n\t\t\t\tif (hold_mem_node->length) {\n\t\t\t\t\thold_mem_node->next = func->mem_head;\n\t\t\t\t\tfunc->mem_head = hold_mem_node;\n\n\t\t\t\t\t \n\t\t\t\t\ttemp_word = (mem_node->base - 1) >> 16;\n\t\t\t\t\trc = pci_bus_write_config_word(pci_bus, devfn, PCI_MEMORY_LIMIT, temp_word);\n\n\t\t\t\t\t \n\t\t\t\t\treturn_resource(&(resources->mem_head), mem_node);\n\t\t\t\t} else {\n\t\t\t\t\t \n\t\t\t\t\ttemp_word = 0x0000;\n\t\t\t\t\trc = pci_bus_write_config_word(pci_bus, devfn, PCI_MEMORY_LIMIT, temp_word);\n\n\t\t\t\t\treturn_resource(&(resources->mem_head), mem_node);\n\t\t\t\t\tkfree(hold_mem_node);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\thold_mem_node->next = func->mem_head;\n\t\t\t\tfunc->mem_head = hold_mem_node;\n\t\t\t}\n\t\t} else if (hold_mem_node) {\n\t\t\t \n\t\t\thold_mem_node->next = func->mem_head;\n\t\t\tfunc->mem_head = hold_mem_node;\n\t\t}\n\t\t \n\t\tif (temp_resources.p_mem_head) {\n\t\t\tp_mem_node = do_pre_bridge_resource_split(&(temp_resources.p_mem_head),\n\t\t\t\t\t\t\t\t  &hold_p_mem_node, 0x100000);\n\n\t\t\t \n\t\t\tif (p_mem_node) {\n\t\t\t\thold_p_mem_node->base = p_mem_node->base + p_mem_node->length;\n\n\t\t\t\ttemp_word = (hold_p_mem_node->base) >> 16;\n\t\t\t\trc = pci_bus_write_config_word(pci_bus, devfn, PCI_PREF_MEMORY_BASE, temp_word);\n\n\t\t\t\treturn_resource(&(resources->p_mem_head), p_mem_node);\n\t\t\t}\n\n\t\t\tp_mem_node = do_bridge_resource_split(&(temp_resources.p_mem_head), 0x100000);\n\n\t\t\t \n\t\t\tif (p_mem_node) {\n\t\t\t\t \n\t\t\t\thold_p_mem_node->length = p_mem_node->base - hold_p_mem_node->base;\n\n\t\t\t\t \n\t\t\t\tif (hold_p_mem_node->length) {\n\t\t\t\t\thold_p_mem_node->next = func->p_mem_head;\n\t\t\t\t\tfunc->p_mem_head = hold_p_mem_node;\n\n\t\t\t\t\ttemp_word = (p_mem_node->base - 1) >> 16;\n\t\t\t\t\trc = pci_bus_write_config_word(pci_bus, devfn, PCI_PREF_MEMORY_LIMIT, temp_word);\n\n\t\t\t\t\treturn_resource(&(resources->p_mem_head), p_mem_node);\n\t\t\t\t} else {\n\t\t\t\t\t \n\t\t\t\t\ttemp_word = 0x0000;\n\t\t\t\t\trc = pci_bus_write_config_word(pci_bus, devfn, PCI_PREF_MEMORY_LIMIT, temp_word);\n\n\t\t\t\t\treturn_resource(&(resources->p_mem_head), p_mem_node);\n\t\t\t\t\tkfree(hold_p_mem_node);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\thold_p_mem_node->next = func->p_mem_head;\n\t\t\t\tfunc->p_mem_head = hold_p_mem_node;\n\t\t\t}\n\t\t} else if (hold_p_mem_node) {\n\t\t\t \n\t\t\thold_p_mem_node->next = func->p_mem_head;\n\t\t\tfunc->p_mem_head = hold_p_mem_node;\n\t\t}\n\t\t \n\n\t\t \n\t\tcommand = 0x0157;\t \n\t\trc = pci_bus_write_config_word(pci_bus, devfn, PCI_COMMAND, command);\n\n\t\t \n\t\tcommand = 0x07;\t\t \n\t\trc = pci_bus_write_config_word(pci_bus, devfn, PCI_BRIDGE_CONTROL, command);\n\t} else if ((temp_byte & 0x7F) == PCI_HEADER_TYPE_NORMAL) {\n\t\t \n\t\trc = pci_bus_read_config_byte(pci_bus, devfn, 0x0B, &class_code);\n\n\t\tif (class_code == PCI_BASE_CLASS_DISPLAY) {\n\t\t\t \n\t\t\treturn DEVICE_TYPE_NOT_SUPPORTED;\n\t\t}\n\t\t \n\t\tfor (cloop = 0x10; cloop <= 0x24; cloop += 4) {\n\t\t\ttemp_register = 0xFFFFFFFF;\n\n\t\t\tdbg(\"CND: bus=%d, devfn=%d, offset=%d\\n\", pci_bus->number, devfn, cloop);\n\t\t\trc = pci_bus_write_config_dword(pci_bus, devfn, cloop, temp_register);\n\n\t\t\trc = pci_bus_read_config_dword(pci_bus, devfn, cloop, &temp_register);\n\t\t\tdbg(\"CND: base = 0x%x\\n\", temp_register);\n\n\t\t\tif (temp_register) {\t   \n\t\t\t\tif ((temp_register & 0x03L) == 0x01) {\n\t\t\t\t\t \n\n\t\t\t\t\t \n\t\t\t\t\tbase = temp_register & 0xFFFFFFFC;\n\t\t\t\t\tbase = ~base + 1;\n\n\t\t\t\t\tdbg(\"CND:      length = 0x%x\\n\", base);\n\t\t\t\t\tio_node = get_io_resource(&(resources->io_head), base);\n\t\t\t\t\tif (!io_node)\n\t\t\t\t\t\treturn -ENOMEM;\n\t\t\t\t\tdbg(\"Got io_node start = %8.8x, length = %8.8x next (%p)\\n\",\n\t\t\t\t\t    io_node->base, io_node->length, io_node->next);\n\t\t\t\t\tdbg(\"func (%p) io_head (%p)\\n\", func, func->io_head);\n\n\t\t\t\t\t \n\t\t\t\t\tbase = io_node->base;\n\t\t\t\t\tio_node->next = func->io_head;\n\t\t\t\t\tfunc->io_head = io_node;\n\t\t\t\t} else if ((temp_register & 0x0BL) == 0x08) {\n\t\t\t\t\t \n\t\t\t\t\tbase = temp_register & 0xFFFFFFF0;\n\t\t\t\t\tbase = ~base + 1;\n\n\t\t\t\t\tdbg(\"CND:      length = 0x%x\\n\", base);\n\t\t\t\t\tp_mem_node = get_resource(&(resources->p_mem_head), base);\n\n\t\t\t\t\t \n\t\t\t\t\tif (p_mem_node) {\n\t\t\t\t\t\tbase = p_mem_node->base;\n\n\t\t\t\t\t\tp_mem_node->next = func->p_mem_head;\n\t\t\t\t\t\tfunc->p_mem_head = p_mem_node;\n\t\t\t\t\t} else\n\t\t\t\t\t\treturn -ENOMEM;\n\t\t\t\t} else if ((temp_register & 0x0BL) == 0x00) {\n\t\t\t\t\t \n\t\t\t\t\tbase = temp_register & 0xFFFFFFF0;\n\t\t\t\t\tbase = ~base + 1;\n\n\t\t\t\t\tdbg(\"CND:      length = 0x%x\\n\", base);\n\t\t\t\t\tmem_node = get_resource(&(resources->mem_head), base);\n\n\t\t\t\t\t \n\t\t\t\t\tif (mem_node) {\n\t\t\t\t\t\tbase = mem_node->base;\n\n\t\t\t\t\t\tmem_node->next = func->mem_head;\n\t\t\t\t\t\tfunc->mem_head = mem_node;\n\t\t\t\t\t} else\n\t\t\t\t\t\treturn -ENOMEM;\n\t\t\t\t} else {\n\t\t\t\t\t \n\t\t\t\t\treturn NOT_ENOUGH_RESOURCES;\n\t\t\t\t}\n\n\t\t\t\trc = pci_bus_write_config_dword(pci_bus, devfn, cloop, base);\n\n\t\t\t\t \n\t\t\t\tif ((temp_register & 0x07L) == 0x04) {\n\t\t\t\t\tcloop += 4;\n\n\t\t\t\t\t \n\t\t\t\t\t \n\t\t\t\t\tbase = 0;\n\t\t\t\t\trc = pci_bus_write_config_dword(pci_bus, devfn, cloop, base);\n\t\t\t\t}\n\t\t\t}\n\t\t}\t\t \n\t\tif (cpqhp_legacy_mode) {\n\t\t\t \n\t\t\trc = pci_bus_read_config_byte(pci_bus, devfn,\n\t\t\t\tPCI_INTERRUPT_PIN, &temp_byte);\n\n\t\t\t \n\t\t\tif (temp_byte && resources->irqs &&\n\t\t\t    (resources->irqs->valid_INT &\n\t\t\t     (0x01 << ((temp_byte + resources->irqs->barber_pole - 1) & 0x03)))) {\n\t\t\t\t \n\t\t\t\tIRQ = resources->irqs->interrupt[(temp_byte +\n\t\t\t\t\tresources->irqs->barber_pole - 1) & 0x03];\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\trc = pci_bus_read_config_byte(pci_bus, devfn, 0x0B, &class_code);\n\n\t\t\t\tif (class_code == PCI_BASE_CLASS_STORAGE)\n\t\t\t\t\tIRQ = cpqhp_disk_irq;\n\t\t\t\telse\n\t\t\t\t\tIRQ = cpqhp_nic_irq;\n\t\t\t}\n\n\t\t\t \n\t\t\trc = pci_bus_write_config_byte(pci_bus, devfn, PCI_INTERRUPT_LINE, IRQ);\n\t\t}\n\n\t\tif (!behind_bridge) {\n\t\t\trc = cpqhp_set_irq(func->bus, func->device, temp_byte, IRQ);\n\t\t\tif (rc)\n\t\t\t\treturn 1;\n\t\t} else {\n\t\t\t \n\t\t\tresources->irqs->interrupt[(temp_byte + resources->irqs->barber_pole - 1) & 0x03] = IRQ;\n\t\t\tresources->irqs->valid_INT |= 0x01 << (temp_byte + resources->irqs->barber_pole - 1) & 0x03;\n\t\t}\n\n\t\t \n\t\ttemp_byte = 0x40;\n\t\trc = pci_bus_write_config_byte(pci_bus, devfn,\n\t\t\t\t\tPCI_LATENCY_TIMER, temp_byte);\n\n\t\t \n\t\ttemp_byte = 0x08;\n\t\trc = pci_bus_write_config_byte(pci_bus, devfn,\n\t\t\t\t\tPCI_CACHE_LINE_SIZE, temp_byte);\n\n\t\t \n\t\ttemp_dword = 0x00L;\n\t\trc = pci_bus_write_config_word(pci_bus, devfn,\n\t\t\t\t\tPCI_ROM_ADDRESS, temp_dword);\n\n\t\t \n\t\ttemp_word = 0x0157;\t \n\t\trc = pci_bus_write_config_word(pci_bus, devfn,\n\t\t\t\t\tPCI_COMMAND, temp_word);\n\t} else {\t\t \n\t\t \n\t\treturn DEVICE_TYPE_NOT_SUPPORTED;\n\t}\n\n\tfunc->configured = 1;\n\n\treturn 0;\nfree_and_out:\n\tcpqhp_destroy_resource_list(&temp_resources);\n\n\treturn_resource(&(resources->bus_head), hold_bus_node);\n\treturn_resource(&(resources->io_head), hold_IO_node);\n\treturn_resource(&(resources->mem_head), hold_mem_node);\n\treturn_resource(&(resources->p_mem_head), hold_p_mem_node);\n\treturn rc;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}