{
  "module_name": "switchtec.c",
  "hash_id": "464244ef93ad890787f8fdadb243700c9a08e6b3292f5d3ec9bbdd3633ae95ff",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/switch/switchtec.c",
  "human_readable_source": "\n \n\n#include <linux/switchtec.h>\n#include <linux/switchtec_ioctl.h>\n\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/uaccess.h>\n#include <linux/poll.h>\n#include <linux/wait.h>\n#include <linux/io-64-nonatomic-lo-hi.h>\n#include <linux/nospec.h>\n\nMODULE_DESCRIPTION(\"Microsemi Switchtec(tm) PCIe Management Driver\");\nMODULE_VERSION(\"0.1\");\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Microsemi Corporation\");\n\nstatic int max_devices = 16;\nmodule_param(max_devices, int, 0644);\nMODULE_PARM_DESC(max_devices, \"max number of switchtec device instances\");\n\nstatic bool use_dma_mrpc = true;\nmodule_param(use_dma_mrpc, bool, 0644);\nMODULE_PARM_DESC(use_dma_mrpc,\n\t\t \"Enable the use of the DMA MRPC feature\");\n\nstatic int nirqs = 32;\nmodule_param(nirqs, int, 0644);\nMODULE_PARM_DESC(nirqs, \"number of interrupts to allocate (more may be useful for NTB applications)\");\n\nstatic dev_t switchtec_devt;\nstatic DEFINE_IDA(switchtec_minor_ida);\n\nstruct class *switchtec_class;\nEXPORT_SYMBOL_GPL(switchtec_class);\n\nenum mrpc_state {\n\tMRPC_IDLE = 0,\n\tMRPC_QUEUED,\n\tMRPC_RUNNING,\n\tMRPC_DONE,\n\tMRPC_IO_ERROR,\n};\n\nstruct switchtec_user {\n\tstruct switchtec_dev *stdev;\n\n\tenum mrpc_state state;\n\n\twait_queue_head_t cmd_comp;\n\tstruct kref kref;\n\tstruct list_head list;\n\n\tbool cmd_done;\n\tu32 cmd;\n\tu32 status;\n\tu32 return_code;\n\tsize_t data_len;\n\tsize_t read_len;\n\tunsigned char data[SWITCHTEC_MRPC_PAYLOAD_SIZE];\n\tint event_cnt;\n};\n\n \nstatic int is_firmware_running(struct switchtec_dev *stdev)\n{\n\tu32 device = ioread32(&stdev->mmio_sys_info->device_id);\n\n\treturn stdev->pdev->device == device;\n}\n\nstatic struct switchtec_user *stuser_create(struct switchtec_dev *stdev)\n{\n\tstruct switchtec_user *stuser;\n\n\tstuser = kzalloc(sizeof(*stuser), GFP_KERNEL);\n\tif (!stuser)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tget_device(&stdev->dev);\n\tstuser->stdev = stdev;\n\tkref_init(&stuser->kref);\n\tINIT_LIST_HEAD(&stuser->list);\n\tinit_waitqueue_head(&stuser->cmd_comp);\n\tstuser->event_cnt = atomic_read(&stdev->event_cnt);\n\n\tdev_dbg(&stdev->dev, \"%s: %p\\n\", __func__, stuser);\n\n\treturn stuser;\n}\n\nstatic void stuser_free(struct kref *kref)\n{\n\tstruct switchtec_user *stuser;\n\n\tstuser = container_of(kref, struct switchtec_user, kref);\n\n\tdev_dbg(&stuser->stdev->dev, \"%s: %p\\n\", __func__, stuser);\n\n\tput_device(&stuser->stdev->dev);\n\tkfree(stuser);\n}\n\nstatic void stuser_put(struct switchtec_user *stuser)\n{\n\tkref_put(&stuser->kref, stuser_free);\n}\n\nstatic void stuser_set_state(struct switchtec_user *stuser,\n\t\t\t     enum mrpc_state state)\n{\n\t \n\n\tstatic const char * const state_names[] = {\n\t\t[MRPC_IDLE] = \"IDLE\",\n\t\t[MRPC_QUEUED] = \"QUEUED\",\n\t\t[MRPC_RUNNING] = \"RUNNING\",\n\t\t[MRPC_DONE] = \"DONE\",\n\t\t[MRPC_IO_ERROR] = \"IO_ERROR\",\n\t};\n\n\tstuser->state = state;\n\n\tdev_dbg(&stuser->stdev->dev, \"stuser state %p -> %s\",\n\t\tstuser, state_names[state]);\n}\n\nstatic void mrpc_complete_cmd(struct switchtec_dev *stdev);\n\nstatic void flush_wc_buf(struct switchtec_dev *stdev)\n{\n\tstruct ntb_dbmsg_regs __iomem *mmio_dbmsg;\n\n\t \n\tmmio_dbmsg = (void __iomem *)stdev->mmio_ntb +\n\t\tSWITCHTEC_NTB_REG_DBMSG_OFFSET;\n\tioread32(&mmio_dbmsg->odb);\n}\n\nstatic void mrpc_cmd_submit(struct switchtec_dev *stdev)\n{\n\t \n\n\tstruct switchtec_user *stuser;\n\n\tif (stdev->mrpc_busy)\n\t\treturn;\n\n\tif (list_empty(&stdev->mrpc_queue))\n\t\treturn;\n\n\tstuser = list_entry(stdev->mrpc_queue.next, struct switchtec_user,\n\t\t\t    list);\n\n\tif (stdev->dma_mrpc) {\n\t\tstdev->dma_mrpc->status = SWITCHTEC_MRPC_STATUS_INPROGRESS;\n\t\tmemset(stdev->dma_mrpc->data, 0xFF, SWITCHTEC_MRPC_PAYLOAD_SIZE);\n\t}\n\n\tstuser_set_state(stuser, MRPC_RUNNING);\n\tstdev->mrpc_busy = 1;\n\tmemcpy_toio(&stdev->mmio_mrpc->input_data,\n\t\t    stuser->data, stuser->data_len);\n\tflush_wc_buf(stdev);\n\tiowrite32(stuser->cmd, &stdev->mmio_mrpc->cmd);\n\n\tschedule_delayed_work(&stdev->mrpc_timeout,\n\t\t\t      msecs_to_jiffies(500));\n}\n\nstatic int mrpc_queue_cmd(struct switchtec_user *stuser)\n{\n\t \n\n\tstruct switchtec_dev *stdev = stuser->stdev;\n\n\tkref_get(&stuser->kref);\n\tstuser->read_len = sizeof(stuser->data);\n\tstuser_set_state(stuser, MRPC_QUEUED);\n\tstuser->cmd_done = false;\n\tlist_add_tail(&stuser->list, &stdev->mrpc_queue);\n\n\tmrpc_cmd_submit(stdev);\n\n\treturn 0;\n}\n\nstatic void mrpc_cleanup_cmd(struct switchtec_dev *stdev)\n{\n\t \n\n\tstruct switchtec_user *stuser = list_entry(stdev->mrpc_queue.next,\n\t\t\t\t\t\t   struct switchtec_user, list);\n\n\tstuser->cmd_done = true;\n\twake_up_interruptible(&stuser->cmd_comp);\n\tlist_del_init(&stuser->list);\n\tstuser_put(stuser);\n\tstdev->mrpc_busy = 0;\n\n\tmrpc_cmd_submit(stdev);\n}\n\nstatic void mrpc_complete_cmd(struct switchtec_dev *stdev)\n{\n\t \n\n\tstruct switchtec_user *stuser;\n\n\tif (list_empty(&stdev->mrpc_queue))\n\t\treturn;\n\n\tstuser = list_entry(stdev->mrpc_queue.next, struct switchtec_user,\n\t\t\t    list);\n\n\tif (stdev->dma_mrpc)\n\t\tstuser->status = stdev->dma_mrpc->status;\n\telse\n\t\tstuser->status = ioread32(&stdev->mmio_mrpc->status);\n\n\tif (stuser->status == SWITCHTEC_MRPC_STATUS_INPROGRESS)\n\t\treturn;\n\n\tstuser_set_state(stuser, MRPC_DONE);\n\tstuser->return_code = 0;\n\n\tif (stuser->status != SWITCHTEC_MRPC_STATUS_DONE &&\n\t    stuser->status != SWITCHTEC_MRPC_STATUS_ERROR)\n\t\tgoto out;\n\n\tif (stdev->dma_mrpc)\n\t\tstuser->return_code = stdev->dma_mrpc->rtn_code;\n\telse\n\t\tstuser->return_code = ioread32(&stdev->mmio_mrpc->ret_value);\n\tif (stuser->return_code != 0)\n\t\tgoto out;\n\n\tif (stdev->dma_mrpc)\n\t\tmemcpy(stuser->data, &stdev->dma_mrpc->data,\n\t\t\t      stuser->read_len);\n\telse\n\t\tmemcpy_fromio(stuser->data, &stdev->mmio_mrpc->output_data,\n\t\t\t      stuser->read_len);\nout:\n\tmrpc_cleanup_cmd(stdev);\n}\n\nstatic void mrpc_event_work(struct work_struct *work)\n{\n\tstruct switchtec_dev *stdev;\n\n\tstdev = container_of(work, struct switchtec_dev, mrpc_work);\n\n\tdev_dbg(&stdev->dev, \"%s\\n\", __func__);\n\n\tmutex_lock(&stdev->mrpc_mutex);\n\tcancel_delayed_work(&stdev->mrpc_timeout);\n\tmrpc_complete_cmd(stdev);\n\tmutex_unlock(&stdev->mrpc_mutex);\n}\n\nstatic void mrpc_error_complete_cmd(struct switchtec_dev *stdev)\n{\n\t \n\n\tstruct switchtec_user *stuser;\n\n\tif (list_empty(&stdev->mrpc_queue))\n\t\treturn;\n\n\tstuser = list_entry(stdev->mrpc_queue.next,\n\t\t\t    struct switchtec_user, list);\n\n\tstuser_set_state(stuser, MRPC_IO_ERROR);\n\n\tmrpc_cleanup_cmd(stdev);\n}\n\nstatic void mrpc_timeout_work(struct work_struct *work)\n{\n\tstruct switchtec_dev *stdev;\n\tu32 status;\n\n\tstdev = container_of(work, struct switchtec_dev, mrpc_timeout.work);\n\n\tdev_dbg(&stdev->dev, \"%s\\n\", __func__);\n\n\tmutex_lock(&stdev->mrpc_mutex);\n\n\tif (!is_firmware_running(stdev)) {\n\t\tmrpc_error_complete_cmd(stdev);\n\t\tgoto out;\n\t}\n\n\tif (stdev->dma_mrpc)\n\t\tstatus = stdev->dma_mrpc->status;\n\telse\n\t\tstatus = ioread32(&stdev->mmio_mrpc->status);\n\tif (status == SWITCHTEC_MRPC_STATUS_INPROGRESS) {\n\t\tschedule_delayed_work(&stdev->mrpc_timeout,\n\t\t\t\t      msecs_to_jiffies(500));\n\t\tgoto out;\n\t}\n\n\tmrpc_complete_cmd(stdev);\nout:\n\tmutex_unlock(&stdev->mrpc_mutex);\n}\n\nstatic ssize_t device_version_show(struct device *dev,\n\tstruct device_attribute *attr, char *buf)\n{\n\tstruct switchtec_dev *stdev = to_stdev(dev);\n\tu32 ver;\n\n\tver = ioread32(&stdev->mmio_sys_info->device_version);\n\n\treturn sysfs_emit(buf, \"%x\\n\", ver);\n}\nstatic DEVICE_ATTR_RO(device_version);\n\nstatic ssize_t fw_version_show(struct device *dev,\n\tstruct device_attribute *attr, char *buf)\n{\n\tstruct switchtec_dev *stdev = to_stdev(dev);\n\tu32 ver;\n\n\tver = ioread32(&stdev->mmio_sys_info->firmware_version);\n\n\treturn sysfs_emit(buf, \"%08x\\n\", ver);\n}\nstatic DEVICE_ATTR_RO(fw_version);\n\nstatic ssize_t io_string_show(char *buf, void __iomem *attr, size_t len)\n{\n\tint i;\n\n\tmemcpy_fromio(buf, attr, len);\n\tbuf[len] = '\\n';\n\tbuf[len + 1] = 0;\n\n\tfor (i = len - 1; i > 0; i--) {\n\t\tif (buf[i] != ' ')\n\t\t\tbreak;\n\t\tbuf[i] = '\\n';\n\t\tbuf[i + 1] = 0;\n\t}\n\n\treturn strlen(buf);\n}\n\n#define DEVICE_ATTR_SYS_INFO_STR(field) \\\nstatic ssize_t field ## _show(struct device *dev, \\\n\tstruct device_attribute *attr, char *buf) \\\n{ \\\n\tstruct switchtec_dev *stdev = to_stdev(dev); \\\n\tstruct sys_info_regs __iomem *si = stdev->mmio_sys_info; \\\n\tif (stdev->gen == SWITCHTEC_GEN3) \\\n\t\treturn io_string_show(buf, &si->gen3.field, \\\n\t\t\t\t      sizeof(si->gen3.field)); \\\n\telse if (stdev->gen >= SWITCHTEC_GEN4) \\\n\t\treturn io_string_show(buf, &si->gen4.field, \\\n\t\t\t\t      sizeof(si->gen4.field)); \\\n\telse \\\n\t\treturn -EOPNOTSUPP; \\\n} \\\n\\\nstatic DEVICE_ATTR_RO(field)\n\nDEVICE_ATTR_SYS_INFO_STR(vendor_id);\nDEVICE_ATTR_SYS_INFO_STR(product_id);\nDEVICE_ATTR_SYS_INFO_STR(product_revision);\n\nstatic ssize_t component_vendor_show(struct device *dev,\n\t\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct switchtec_dev *stdev = to_stdev(dev);\n\tstruct sys_info_regs __iomem *si = stdev->mmio_sys_info;\n\n\t \n\tif (stdev->gen != SWITCHTEC_GEN3)\n\t\treturn sysfs_emit(buf, \"none\\n\");\n\n\treturn io_string_show(buf, &si->gen3.component_vendor,\n\t\t\t      sizeof(si->gen3.component_vendor));\n}\nstatic DEVICE_ATTR_RO(component_vendor);\n\nstatic ssize_t component_id_show(struct device *dev,\n\tstruct device_attribute *attr, char *buf)\n{\n\tstruct switchtec_dev *stdev = to_stdev(dev);\n\tint id = ioread16(&stdev->mmio_sys_info->gen3.component_id);\n\n\t \n\tif (stdev->gen != SWITCHTEC_GEN3)\n\t\treturn sysfs_emit(buf, \"none\\n\");\n\n\treturn sysfs_emit(buf, \"PM%04X\\n\", id);\n}\nstatic DEVICE_ATTR_RO(component_id);\n\nstatic ssize_t component_revision_show(struct device *dev,\n\tstruct device_attribute *attr, char *buf)\n{\n\tstruct switchtec_dev *stdev = to_stdev(dev);\n\tint rev = ioread8(&stdev->mmio_sys_info->gen3.component_revision);\n\n\t \n\tif (stdev->gen != SWITCHTEC_GEN3)\n\t\treturn sysfs_emit(buf, \"255\\n\");\n\n\treturn sysfs_emit(buf, \"%d\\n\", rev);\n}\nstatic DEVICE_ATTR_RO(component_revision);\n\nstatic ssize_t partition_show(struct device *dev,\n\tstruct device_attribute *attr, char *buf)\n{\n\tstruct switchtec_dev *stdev = to_stdev(dev);\n\n\treturn sysfs_emit(buf, \"%d\\n\", stdev->partition);\n}\nstatic DEVICE_ATTR_RO(partition);\n\nstatic ssize_t partition_count_show(struct device *dev,\n\tstruct device_attribute *attr, char *buf)\n{\n\tstruct switchtec_dev *stdev = to_stdev(dev);\n\n\treturn sysfs_emit(buf, \"%d\\n\", stdev->partition_count);\n}\nstatic DEVICE_ATTR_RO(partition_count);\n\nstatic struct attribute *switchtec_device_attrs[] = {\n\t&dev_attr_device_version.attr,\n\t&dev_attr_fw_version.attr,\n\t&dev_attr_vendor_id.attr,\n\t&dev_attr_product_id.attr,\n\t&dev_attr_product_revision.attr,\n\t&dev_attr_component_vendor.attr,\n\t&dev_attr_component_id.attr,\n\t&dev_attr_component_revision.attr,\n\t&dev_attr_partition.attr,\n\t&dev_attr_partition_count.attr,\n\tNULL,\n};\n\nATTRIBUTE_GROUPS(switchtec_device);\n\nstatic int switchtec_dev_open(struct inode *inode, struct file *filp)\n{\n\tstruct switchtec_dev *stdev;\n\tstruct switchtec_user *stuser;\n\n\tstdev = container_of(inode->i_cdev, struct switchtec_dev, cdev);\n\n\tstuser = stuser_create(stdev);\n\tif (IS_ERR(stuser))\n\t\treturn PTR_ERR(stuser);\n\n\tfilp->private_data = stuser;\n\tstream_open(inode, filp);\n\n\tdev_dbg(&stdev->dev, \"%s: %p\\n\", __func__, stuser);\n\n\treturn 0;\n}\n\nstatic int switchtec_dev_release(struct inode *inode, struct file *filp)\n{\n\tstruct switchtec_user *stuser = filp->private_data;\n\n\tstuser_put(stuser);\n\n\treturn 0;\n}\n\nstatic int lock_mutex_and_test_alive(struct switchtec_dev *stdev)\n{\n\tif (mutex_lock_interruptible(&stdev->mrpc_mutex))\n\t\treturn -EINTR;\n\n\tif (!stdev->alive) {\n\t\tmutex_unlock(&stdev->mrpc_mutex);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic ssize_t switchtec_dev_write(struct file *filp, const char __user *data,\n\t\t\t\t   size_t size, loff_t *off)\n{\n\tstruct switchtec_user *stuser = filp->private_data;\n\tstruct switchtec_dev *stdev = stuser->stdev;\n\tint rc;\n\n\tif (size < sizeof(stuser->cmd) ||\n\t    size > sizeof(stuser->cmd) + sizeof(stuser->data))\n\t\treturn -EINVAL;\n\n\tstuser->data_len = size - sizeof(stuser->cmd);\n\n\trc = lock_mutex_and_test_alive(stdev);\n\tif (rc)\n\t\treturn rc;\n\n\tif (stuser->state != MRPC_IDLE) {\n\t\trc = -EBADE;\n\t\tgoto out;\n\t}\n\n\trc = copy_from_user(&stuser->cmd, data, sizeof(stuser->cmd));\n\tif (rc) {\n\t\trc = -EFAULT;\n\t\tgoto out;\n\t}\n\tif (((MRPC_CMD_ID(stuser->cmd) == MRPC_GAS_WRITE) ||\n\t     (MRPC_CMD_ID(stuser->cmd) == MRPC_GAS_READ)) &&\n\t    !capable(CAP_SYS_ADMIN)) {\n\t\trc = -EPERM;\n\t\tgoto out;\n\t}\n\n\tdata += sizeof(stuser->cmd);\n\trc = copy_from_user(&stuser->data, data, size - sizeof(stuser->cmd));\n\tif (rc) {\n\t\trc = -EFAULT;\n\t\tgoto out;\n\t}\n\n\trc = mrpc_queue_cmd(stuser);\n\nout:\n\tmutex_unlock(&stdev->mrpc_mutex);\n\n\tif (rc)\n\t\treturn rc;\n\n\treturn size;\n}\n\nstatic ssize_t switchtec_dev_read(struct file *filp, char __user *data,\n\t\t\t\t  size_t size, loff_t *off)\n{\n\tstruct switchtec_user *stuser = filp->private_data;\n\tstruct switchtec_dev *stdev = stuser->stdev;\n\tint rc;\n\n\tif (size < sizeof(stuser->cmd) ||\n\t    size > sizeof(stuser->cmd) + sizeof(stuser->data))\n\t\treturn -EINVAL;\n\n\trc = lock_mutex_and_test_alive(stdev);\n\tif (rc)\n\t\treturn rc;\n\n\tif (stuser->state == MRPC_IDLE) {\n\t\tmutex_unlock(&stdev->mrpc_mutex);\n\t\treturn -EBADE;\n\t}\n\n\tstuser->read_len = size - sizeof(stuser->return_code);\n\n\tmutex_unlock(&stdev->mrpc_mutex);\n\n\tif (filp->f_flags & O_NONBLOCK) {\n\t\tif (!stuser->cmd_done)\n\t\t\treturn -EAGAIN;\n\t} else {\n\t\trc = wait_event_interruptible(stuser->cmd_comp,\n\t\t\t\t\t      stuser->cmd_done);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t}\n\n\trc = lock_mutex_and_test_alive(stdev);\n\tif (rc)\n\t\treturn rc;\n\n\tif (stuser->state == MRPC_IO_ERROR) {\n\t\tmutex_unlock(&stdev->mrpc_mutex);\n\t\treturn -EIO;\n\t}\n\n\tif (stuser->state != MRPC_DONE) {\n\t\tmutex_unlock(&stdev->mrpc_mutex);\n\t\treturn -EBADE;\n\t}\n\n\trc = copy_to_user(data, &stuser->return_code,\n\t\t\t  sizeof(stuser->return_code));\n\tif (rc) {\n\t\tmutex_unlock(&stdev->mrpc_mutex);\n\t\treturn -EFAULT;\n\t}\n\n\tdata += sizeof(stuser->return_code);\n\trc = copy_to_user(data, &stuser->data,\n\t\t\t  size - sizeof(stuser->return_code));\n\tif (rc) {\n\t\tmutex_unlock(&stdev->mrpc_mutex);\n\t\treturn -EFAULT;\n\t}\n\n\tstuser_set_state(stuser, MRPC_IDLE);\n\n\tmutex_unlock(&stdev->mrpc_mutex);\n\n\tif (stuser->status == SWITCHTEC_MRPC_STATUS_DONE ||\n\t    stuser->status == SWITCHTEC_MRPC_STATUS_ERROR)\n\t\treturn size;\n\telse if (stuser->status == SWITCHTEC_MRPC_STATUS_INTERRUPTED)\n\t\treturn -ENXIO;\n\telse\n\t\treturn -EBADMSG;\n}\n\nstatic __poll_t switchtec_dev_poll(struct file *filp, poll_table *wait)\n{\n\tstruct switchtec_user *stuser = filp->private_data;\n\tstruct switchtec_dev *stdev = stuser->stdev;\n\t__poll_t ret = 0;\n\n\tpoll_wait(filp, &stuser->cmd_comp, wait);\n\tpoll_wait(filp, &stdev->event_wq, wait);\n\n\tif (lock_mutex_and_test_alive(stdev))\n\t\treturn EPOLLIN | EPOLLRDHUP | EPOLLOUT | EPOLLERR | EPOLLHUP;\n\n\tmutex_unlock(&stdev->mrpc_mutex);\n\n\tif (stuser->cmd_done)\n\t\tret |= EPOLLIN | EPOLLRDNORM;\n\n\tif (stuser->event_cnt != atomic_read(&stdev->event_cnt))\n\t\tret |= EPOLLPRI | EPOLLRDBAND;\n\n\treturn ret;\n}\n\nstatic int ioctl_flash_info(struct switchtec_dev *stdev,\n\t\t\t    struct switchtec_ioctl_flash_info __user *uinfo)\n{\n\tstruct switchtec_ioctl_flash_info info = {0};\n\tstruct flash_info_regs __iomem *fi = stdev->mmio_flash_info;\n\n\tif (stdev->gen == SWITCHTEC_GEN3) {\n\t\tinfo.flash_length = ioread32(&fi->gen3.flash_length);\n\t\tinfo.num_partitions = SWITCHTEC_NUM_PARTITIONS_GEN3;\n\t} else if (stdev->gen >= SWITCHTEC_GEN4) {\n\t\tinfo.flash_length = ioread32(&fi->gen4.flash_length);\n\t\tinfo.num_partitions = SWITCHTEC_NUM_PARTITIONS_GEN4;\n\t} else {\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (copy_to_user(uinfo, &info, sizeof(info)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic void set_fw_info_part(struct switchtec_ioctl_flash_part_info *info,\n\t\t\t     struct partition_info __iomem *pi)\n{\n\tinfo->address = ioread32(&pi->address);\n\tinfo->length = ioread32(&pi->length);\n}\n\nstatic int flash_part_info_gen3(struct switchtec_dev *stdev,\n\t\tstruct switchtec_ioctl_flash_part_info *info)\n{\n\tstruct flash_info_regs_gen3 __iomem *fi =\n\t\t&stdev->mmio_flash_info->gen3;\n\tstruct sys_info_regs_gen3 __iomem *si = &stdev->mmio_sys_info->gen3;\n\tu32 active_addr = -1;\n\n\tswitch (info->flash_partition) {\n\tcase SWITCHTEC_IOCTL_PART_CFG0:\n\t\tactive_addr = ioread32(&fi->active_cfg);\n\t\tset_fw_info_part(info, &fi->cfg0);\n\t\tif (ioread16(&si->cfg_running) == SWITCHTEC_GEN3_CFG0_RUNNING)\n\t\t\tinfo->active |= SWITCHTEC_IOCTL_PART_RUNNING;\n\t\tbreak;\n\tcase SWITCHTEC_IOCTL_PART_CFG1:\n\t\tactive_addr = ioread32(&fi->active_cfg);\n\t\tset_fw_info_part(info, &fi->cfg1);\n\t\tif (ioread16(&si->cfg_running) == SWITCHTEC_GEN3_CFG1_RUNNING)\n\t\t\tinfo->active |= SWITCHTEC_IOCTL_PART_RUNNING;\n\t\tbreak;\n\tcase SWITCHTEC_IOCTL_PART_IMG0:\n\t\tactive_addr = ioread32(&fi->active_img);\n\t\tset_fw_info_part(info, &fi->img0);\n\t\tif (ioread16(&si->img_running) == SWITCHTEC_GEN3_IMG0_RUNNING)\n\t\t\tinfo->active |= SWITCHTEC_IOCTL_PART_RUNNING;\n\t\tbreak;\n\tcase SWITCHTEC_IOCTL_PART_IMG1:\n\t\tactive_addr = ioread32(&fi->active_img);\n\t\tset_fw_info_part(info, &fi->img1);\n\t\tif (ioread16(&si->img_running) == SWITCHTEC_GEN3_IMG1_RUNNING)\n\t\t\tinfo->active |= SWITCHTEC_IOCTL_PART_RUNNING;\n\t\tbreak;\n\tcase SWITCHTEC_IOCTL_PART_NVLOG:\n\t\tset_fw_info_part(info, &fi->nvlog);\n\t\tbreak;\n\tcase SWITCHTEC_IOCTL_PART_VENDOR0:\n\t\tset_fw_info_part(info, &fi->vendor[0]);\n\t\tbreak;\n\tcase SWITCHTEC_IOCTL_PART_VENDOR1:\n\t\tset_fw_info_part(info, &fi->vendor[1]);\n\t\tbreak;\n\tcase SWITCHTEC_IOCTL_PART_VENDOR2:\n\t\tset_fw_info_part(info, &fi->vendor[2]);\n\t\tbreak;\n\tcase SWITCHTEC_IOCTL_PART_VENDOR3:\n\t\tset_fw_info_part(info, &fi->vendor[3]);\n\t\tbreak;\n\tcase SWITCHTEC_IOCTL_PART_VENDOR4:\n\t\tset_fw_info_part(info, &fi->vendor[4]);\n\t\tbreak;\n\tcase SWITCHTEC_IOCTL_PART_VENDOR5:\n\t\tset_fw_info_part(info, &fi->vendor[5]);\n\t\tbreak;\n\tcase SWITCHTEC_IOCTL_PART_VENDOR6:\n\t\tset_fw_info_part(info, &fi->vendor[6]);\n\t\tbreak;\n\tcase SWITCHTEC_IOCTL_PART_VENDOR7:\n\t\tset_fw_info_part(info, &fi->vendor[7]);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (info->address == active_addr)\n\t\tinfo->active |= SWITCHTEC_IOCTL_PART_ACTIVE;\n\n\treturn 0;\n}\n\nstatic int flash_part_info_gen4(struct switchtec_dev *stdev,\n\t\tstruct switchtec_ioctl_flash_part_info *info)\n{\n\tstruct flash_info_regs_gen4 __iomem *fi = &stdev->mmio_flash_info->gen4;\n\tstruct sys_info_regs_gen4 __iomem *si = &stdev->mmio_sys_info->gen4;\n\tstruct active_partition_info_gen4 __iomem *af = &fi->active_flag;\n\n\tswitch (info->flash_partition) {\n\tcase SWITCHTEC_IOCTL_PART_MAP_0:\n\t\tset_fw_info_part(info, &fi->map0);\n\t\tbreak;\n\tcase SWITCHTEC_IOCTL_PART_MAP_1:\n\t\tset_fw_info_part(info, &fi->map1);\n\t\tbreak;\n\tcase SWITCHTEC_IOCTL_PART_KEY_0:\n\t\tset_fw_info_part(info, &fi->key0);\n\t\tif (ioread8(&af->key) == SWITCHTEC_GEN4_KEY0_ACTIVE)\n\t\t\tinfo->active |= SWITCHTEC_IOCTL_PART_ACTIVE;\n\t\tif (ioread16(&si->key_running) == SWITCHTEC_GEN4_KEY0_RUNNING)\n\t\t\tinfo->active |= SWITCHTEC_IOCTL_PART_RUNNING;\n\t\tbreak;\n\tcase SWITCHTEC_IOCTL_PART_KEY_1:\n\t\tset_fw_info_part(info, &fi->key1);\n\t\tif (ioread8(&af->key) == SWITCHTEC_GEN4_KEY1_ACTIVE)\n\t\t\tinfo->active |= SWITCHTEC_IOCTL_PART_ACTIVE;\n\t\tif (ioread16(&si->key_running) == SWITCHTEC_GEN4_KEY1_RUNNING)\n\t\t\tinfo->active |= SWITCHTEC_IOCTL_PART_RUNNING;\n\t\tbreak;\n\tcase SWITCHTEC_IOCTL_PART_BL2_0:\n\t\tset_fw_info_part(info, &fi->bl2_0);\n\t\tif (ioread8(&af->bl2) == SWITCHTEC_GEN4_BL2_0_ACTIVE)\n\t\t\tinfo->active |= SWITCHTEC_IOCTL_PART_ACTIVE;\n\t\tif (ioread16(&si->bl2_running) == SWITCHTEC_GEN4_BL2_0_RUNNING)\n\t\t\tinfo->active |= SWITCHTEC_IOCTL_PART_RUNNING;\n\t\tbreak;\n\tcase SWITCHTEC_IOCTL_PART_BL2_1:\n\t\tset_fw_info_part(info, &fi->bl2_1);\n\t\tif (ioread8(&af->bl2) == SWITCHTEC_GEN4_BL2_1_ACTIVE)\n\t\t\tinfo->active |= SWITCHTEC_IOCTL_PART_ACTIVE;\n\t\tif (ioread16(&si->bl2_running) == SWITCHTEC_GEN4_BL2_1_RUNNING)\n\t\t\tinfo->active |= SWITCHTEC_IOCTL_PART_RUNNING;\n\t\tbreak;\n\tcase SWITCHTEC_IOCTL_PART_CFG0:\n\t\tset_fw_info_part(info, &fi->cfg0);\n\t\tif (ioread8(&af->cfg) == SWITCHTEC_GEN4_CFG0_ACTIVE)\n\t\t\tinfo->active |= SWITCHTEC_IOCTL_PART_ACTIVE;\n\t\tif (ioread16(&si->cfg_running) == SWITCHTEC_GEN4_CFG0_RUNNING)\n\t\t\tinfo->active |= SWITCHTEC_IOCTL_PART_RUNNING;\n\t\tbreak;\n\tcase SWITCHTEC_IOCTL_PART_CFG1:\n\t\tset_fw_info_part(info, &fi->cfg1);\n\t\tif (ioread8(&af->cfg) == SWITCHTEC_GEN4_CFG1_ACTIVE)\n\t\t\tinfo->active |= SWITCHTEC_IOCTL_PART_ACTIVE;\n\t\tif (ioread16(&si->cfg_running) == SWITCHTEC_GEN4_CFG1_RUNNING)\n\t\t\tinfo->active |= SWITCHTEC_IOCTL_PART_RUNNING;\n\t\tbreak;\n\tcase SWITCHTEC_IOCTL_PART_IMG0:\n\t\tset_fw_info_part(info, &fi->img0);\n\t\tif (ioread8(&af->img) == SWITCHTEC_GEN4_IMG0_ACTIVE)\n\t\t\tinfo->active |= SWITCHTEC_IOCTL_PART_ACTIVE;\n\t\tif (ioread16(&si->img_running) == SWITCHTEC_GEN4_IMG0_RUNNING)\n\t\t\tinfo->active |= SWITCHTEC_IOCTL_PART_RUNNING;\n\t\tbreak;\n\tcase SWITCHTEC_IOCTL_PART_IMG1:\n\t\tset_fw_info_part(info, &fi->img1);\n\t\tif (ioread8(&af->img) == SWITCHTEC_GEN4_IMG1_ACTIVE)\n\t\t\tinfo->active |= SWITCHTEC_IOCTL_PART_ACTIVE;\n\t\tif (ioread16(&si->img_running) == SWITCHTEC_GEN4_IMG1_RUNNING)\n\t\t\tinfo->active |= SWITCHTEC_IOCTL_PART_RUNNING;\n\t\tbreak;\n\tcase SWITCHTEC_IOCTL_PART_NVLOG:\n\t\tset_fw_info_part(info, &fi->nvlog);\n\t\tbreak;\n\tcase SWITCHTEC_IOCTL_PART_VENDOR0:\n\t\tset_fw_info_part(info, &fi->vendor[0]);\n\t\tbreak;\n\tcase SWITCHTEC_IOCTL_PART_VENDOR1:\n\t\tset_fw_info_part(info, &fi->vendor[1]);\n\t\tbreak;\n\tcase SWITCHTEC_IOCTL_PART_VENDOR2:\n\t\tset_fw_info_part(info, &fi->vendor[2]);\n\t\tbreak;\n\tcase SWITCHTEC_IOCTL_PART_VENDOR3:\n\t\tset_fw_info_part(info, &fi->vendor[3]);\n\t\tbreak;\n\tcase SWITCHTEC_IOCTL_PART_VENDOR4:\n\t\tset_fw_info_part(info, &fi->vendor[4]);\n\t\tbreak;\n\tcase SWITCHTEC_IOCTL_PART_VENDOR5:\n\t\tset_fw_info_part(info, &fi->vendor[5]);\n\t\tbreak;\n\tcase SWITCHTEC_IOCTL_PART_VENDOR6:\n\t\tset_fw_info_part(info, &fi->vendor[6]);\n\t\tbreak;\n\tcase SWITCHTEC_IOCTL_PART_VENDOR7:\n\t\tset_fw_info_part(info, &fi->vendor[7]);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int ioctl_flash_part_info(struct switchtec_dev *stdev,\n\t\tstruct switchtec_ioctl_flash_part_info __user *uinfo)\n{\n\tint ret;\n\tstruct switchtec_ioctl_flash_part_info info = {0};\n\n\tif (copy_from_user(&info, uinfo, sizeof(info)))\n\t\treturn -EFAULT;\n\n\tif (stdev->gen == SWITCHTEC_GEN3) {\n\t\tret = flash_part_info_gen3(stdev, &info);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else if (stdev->gen >= SWITCHTEC_GEN4) {\n\t\tret = flash_part_info_gen4(stdev, &info);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (copy_to_user(uinfo, &info, sizeof(info)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int ioctl_event_summary(struct switchtec_dev *stdev,\n\tstruct switchtec_user *stuser,\n\tstruct switchtec_ioctl_event_summary __user *usum,\n\tsize_t size)\n{\n\tstruct switchtec_ioctl_event_summary *s;\n\tint i;\n\tu32 reg;\n\tint ret = 0;\n\n\ts = kzalloc(sizeof(*s), GFP_KERNEL);\n\tif (!s)\n\t\treturn -ENOMEM;\n\n\ts->global = ioread32(&stdev->mmio_sw_event->global_summary);\n\ts->part_bitmap = ioread64(&stdev->mmio_sw_event->part_event_bitmap);\n\ts->local_part = ioread32(&stdev->mmio_part_cfg->part_event_summary);\n\n\tfor (i = 0; i < stdev->partition_count; i++) {\n\t\treg = ioread32(&stdev->mmio_part_cfg_all[i].part_event_summary);\n\t\ts->part[i] = reg;\n\t}\n\n\tfor (i = 0; i < stdev->pff_csr_count; i++) {\n\t\treg = ioread32(&stdev->mmio_pff_csr[i].pff_event_summary);\n\t\ts->pff[i] = reg;\n\t}\n\n\tif (copy_to_user(usum, s, size)) {\n\t\tret = -EFAULT;\n\t\tgoto error_case;\n\t}\n\n\tstuser->event_cnt = atomic_read(&stdev->event_cnt);\n\nerror_case:\n\tkfree(s);\n\treturn ret;\n}\n\nstatic u32 __iomem *global_ev_reg(struct switchtec_dev *stdev,\n\t\t\t\t  size_t offset, int index)\n{\n\treturn (void __iomem *)stdev->mmio_sw_event + offset;\n}\n\nstatic u32 __iomem *part_ev_reg(struct switchtec_dev *stdev,\n\t\t\t\tsize_t offset, int index)\n{\n\treturn (void __iomem *)&stdev->mmio_part_cfg_all[index] + offset;\n}\n\nstatic u32 __iomem *pff_ev_reg(struct switchtec_dev *stdev,\n\t\t\t       size_t offset, int index)\n{\n\treturn (void __iomem *)&stdev->mmio_pff_csr[index] + offset;\n}\n\n#define EV_GLB(i, r)[i] = {offsetof(struct sw_event_regs, r), global_ev_reg}\n#define EV_PAR(i, r)[i] = {offsetof(struct part_cfg_regs, r), part_ev_reg}\n#define EV_PFF(i, r)[i] = {offsetof(struct pff_csr_regs, r), pff_ev_reg}\n\nstatic const struct event_reg {\n\tsize_t offset;\n\tu32 __iomem *(*map_reg)(struct switchtec_dev *stdev,\n\t\t\t\tsize_t offset, int index);\n} event_regs[] = {\n\tEV_GLB(SWITCHTEC_IOCTL_EVENT_STACK_ERROR, stack_error_event_hdr),\n\tEV_GLB(SWITCHTEC_IOCTL_EVENT_PPU_ERROR, ppu_error_event_hdr),\n\tEV_GLB(SWITCHTEC_IOCTL_EVENT_ISP_ERROR, isp_error_event_hdr),\n\tEV_GLB(SWITCHTEC_IOCTL_EVENT_SYS_RESET, sys_reset_event_hdr),\n\tEV_GLB(SWITCHTEC_IOCTL_EVENT_FW_EXC, fw_exception_hdr),\n\tEV_GLB(SWITCHTEC_IOCTL_EVENT_FW_NMI, fw_nmi_hdr),\n\tEV_GLB(SWITCHTEC_IOCTL_EVENT_FW_NON_FATAL, fw_non_fatal_hdr),\n\tEV_GLB(SWITCHTEC_IOCTL_EVENT_FW_FATAL, fw_fatal_hdr),\n\tEV_GLB(SWITCHTEC_IOCTL_EVENT_TWI_MRPC_COMP, twi_mrpc_comp_hdr),\n\tEV_GLB(SWITCHTEC_IOCTL_EVENT_TWI_MRPC_COMP_ASYNC,\n\t       twi_mrpc_comp_async_hdr),\n\tEV_GLB(SWITCHTEC_IOCTL_EVENT_CLI_MRPC_COMP, cli_mrpc_comp_hdr),\n\tEV_GLB(SWITCHTEC_IOCTL_EVENT_CLI_MRPC_COMP_ASYNC,\n\t       cli_mrpc_comp_async_hdr),\n\tEV_GLB(SWITCHTEC_IOCTL_EVENT_GPIO_INT, gpio_interrupt_hdr),\n\tEV_GLB(SWITCHTEC_IOCTL_EVENT_GFMS, gfms_event_hdr),\n\tEV_PAR(SWITCHTEC_IOCTL_EVENT_PART_RESET, part_reset_hdr),\n\tEV_PAR(SWITCHTEC_IOCTL_EVENT_MRPC_COMP, mrpc_comp_hdr),\n\tEV_PAR(SWITCHTEC_IOCTL_EVENT_MRPC_COMP_ASYNC, mrpc_comp_async_hdr),\n\tEV_PAR(SWITCHTEC_IOCTL_EVENT_DYN_PART_BIND_COMP, dyn_binding_hdr),\n\tEV_PAR(SWITCHTEC_IOCTL_EVENT_INTERCOMM_REQ_NOTIFY,\n\t       intercomm_notify_hdr),\n\tEV_PFF(SWITCHTEC_IOCTL_EVENT_AER_IN_P2P, aer_in_p2p_hdr),\n\tEV_PFF(SWITCHTEC_IOCTL_EVENT_AER_IN_VEP, aer_in_vep_hdr),\n\tEV_PFF(SWITCHTEC_IOCTL_EVENT_DPC, dpc_hdr),\n\tEV_PFF(SWITCHTEC_IOCTL_EVENT_CTS, cts_hdr),\n\tEV_PFF(SWITCHTEC_IOCTL_EVENT_UEC, uec_hdr),\n\tEV_PFF(SWITCHTEC_IOCTL_EVENT_HOTPLUG, hotplug_hdr),\n\tEV_PFF(SWITCHTEC_IOCTL_EVENT_IER, ier_hdr),\n\tEV_PFF(SWITCHTEC_IOCTL_EVENT_THRESH, threshold_hdr),\n\tEV_PFF(SWITCHTEC_IOCTL_EVENT_POWER_MGMT, power_mgmt_hdr),\n\tEV_PFF(SWITCHTEC_IOCTL_EVENT_TLP_THROTTLING, tlp_throttling_hdr),\n\tEV_PFF(SWITCHTEC_IOCTL_EVENT_FORCE_SPEED, force_speed_hdr),\n\tEV_PFF(SWITCHTEC_IOCTL_EVENT_CREDIT_TIMEOUT, credit_timeout_hdr),\n\tEV_PFF(SWITCHTEC_IOCTL_EVENT_LINK_STATE, link_state_hdr),\n};\n\nstatic u32 __iomem *event_hdr_addr(struct switchtec_dev *stdev,\n\t\t\t\t   int event_id, int index)\n{\n\tsize_t off;\n\n\tif (event_id < 0 || event_id >= SWITCHTEC_IOCTL_MAX_EVENTS)\n\t\treturn (u32 __iomem *)ERR_PTR(-EINVAL);\n\n\toff = event_regs[event_id].offset;\n\n\tif (event_regs[event_id].map_reg == part_ev_reg) {\n\t\tif (index == SWITCHTEC_IOCTL_EVENT_LOCAL_PART_IDX)\n\t\t\tindex = stdev->partition;\n\t\telse if (index < 0 || index >= stdev->partition_count)\n\t\t\treturn (u32 __iomem *)ERR_PTR(-EINVAL);\n\t} else if (event_regs[event_id].map_reg == pff_ev_reg) {\n\t\tif (index < 0 || index >= stdev->pff_csr_count)\n\t\t\treturn (u32 __iomem *)ERR_PTR(-EINVAL);\n\t}\n\n\treturn event_regs[event_id].map_reg(stdev, off, index);\n}\n\nstatic int event_ctl(struct switchtec_dev *stdev,\n\t\t     struct switchtec_ioctl_event_ctl *ctl)\n{\n\tint i;\n\tu32 __iomem *reg;\n\tu32 hdr;\n\n\treg = event_hdr_addr(stdev, ctl->event_id, ctl->index);\n\tif (IS_ERR(reg))\n\t\treturn PTR_ERR(reg);\n\n\thdr = ioread32(reg);\n\tif (hdr & SWITCHTEC_EVENT_NOT_SUPP)\n\t\treturn -EOPNOTSUPP;\n\n\tfor (i = 0; i < ARRAY_SIZE(ctl->data); i++)\n\t\tctl->data[i] = ioread32(&reg[i + 1]);\n\n\tctl->occurred = hdr & SWITCHTEC_EVENT_OCCURRED;\n\tctl->count = (hdr >> 5) & 0xFF;\n\n\tif (!(ctl->flags & SWITCHTEC_IOCTL_EVENT_FLAG_CLEAR))\n\t\thdr &= ~SWITCHTEC_EVENT_CLEAR;\n\tif (ctl->flags & SWITCHTEC_IOCTL_EVENT_FLAG_EN_POLL)\n\t\thdr |= SWITCHTEC_EVENT_EN_IRQ;\n\tif (ctl->flags & SWITCHTEC_IOCTL_EVENT_FLAG_DIS_POLL)\n\t\thdr &= ~SWITCHTEC_EVENT_EN_IRQ;\n\tif (ctl->flags & SWITCHTEC_IOCTL_EVENT_FLAG_EN_LOG)\n\t\thdr |= SWITCHTEC_EVENT_EN_LOG;\n\tif (ctl->flags & SWITCHTEC_IOCTL_EVENT_FLAG_DIS_LOG)\n\t\thdr &= ~SWITCHTEC_EVENT_EN_LOG;\n\tif (ctl->flags & SWITCHTEC_IOCTL_EVENT_FLAG_EN_CLI)\n\t\thdr |= SWITCHTEC_EVENT_EN_CLI;\n\tif (ctl->flags & SWITCHTEC_IOCTL_EVENT_FLAG_DIS_CLI)\n\t\thdr &= ~SWITCHTEC_EVENT_EN_CLI;\n\tif (ctl->flags & SWITCHTEC_IOCTL_EVENT_FLAG_EN_FATAL)\n\t\thdr |= SWITCHTEC_EVENT_FATAL;\n\tif (ctl->flags & SWITCHTEC_IOCTL_EVENT_FLAG_DIS_FATAL)\n\t\thdr &= ~SWITCHTEC_EVENT_FATAL;\n\n\tif (ctl->flags)\n\t\tiowrite32(hdr, reg);\n\n\tctl->flags = 0;\n\tif (hdr & SWITCHTEC_EVENT_EN_IRQ)\n\t\tctl->flags |= SWITCHTEC_IOCTL_EVENT_FLAG_EN_POLL;\n\tif (hdr & SWITCHTEC_EVENT_EN_LOG)\n\t\tctl->flags |= SWITCHTEC_IOCTL_EVENT_FLAG_EN_LOG;\n\tif (hdr & SWITCHTEC_EVENT_EN_CLI)\n\t\tctl->flags |= SWITCHTEC_IOCTL_EVENT_FLAG_EN_CLI;\n\tif (hdr & SWITCHTEC_EVENT_FATAL)\n\t\tctl->flags |= SWITCHTEC_IOCTL_EVENT_FLAG_EN_FATAL;\n\n\treturn 0;\n}\n\nstatic int ioctl_event_ctl(struct switchtec_dev *stdev,\n\tstruct switchtec_ioctl_event_ctl __user *uctl)\n{\n\tint ret;\n\tint nr_idxs;\n\tunsigned int event_flags;\n\tstruct switchtec_ioctl_event_ctl ctl;\n\n\tif (copy_from_user(&ctl, uctl, sizeof(ctl)))\n\t\treturn -EFAULT;\n\n\tif (ctl.event_id >= SWITCHTEC_IOCTL_MAX_EVENTS)\n\t\treturn -EINVAL;\n\n\tif (ctl.flags & SWITCHTEC_IOCTL_EVENT_FLAG_UNUSED)\n\t\treturn -EINVAL;\n\n\tif (ctl.index == SWITCHTEC_IOCTL_EVENT_IDX_ALL) {\n\t\tif (event_regs[ctl.event_id].map_reg == global_ev_reg)\n\t\t\tnr_idxs = 1;\n\t\telse if (event_regs[ctl.event_id].map_reg == part_ev_reg)\n\t\t\tnr_idxs = stdev->partition_count;\n\t\telse if (event_regs[ctl.event_id].map_reg == pff_ev_reg)\n\t\t\tnr_idxs = stdev->pff_csr_count;\n\t\telse\n\t\t\treturn -EINVAL;\n\n\t\tevent_flags = ctl.flags;\n\t\tfor (ctl.index = 0; ctl.index < nr_idxs; ctl.index++) {\n\t\t\tctl.flags = event_flags;\n\t\t\tret = event_ctl(stdev, &ctl);\n\t\t\tif (ret < 0 && ret != -EOPNOTSUPP)\n\t\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\tret = event_ctl(stdev, &ctl);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tif (copy_to_user(uctl, &ctl, sizeof(ctl)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int ioctl_pff_to_port(struct switchtec_dev *stdev,\n\t\t\t     struct switchtec_ioctl_pff_port __user *up)\n{\n\tint i, part;\n\tu32 reg;\n\tstruct part_cfg_regs __iomem *pcfg;\n\tstruct switchtec_ioctl_pff_port p;\n\n\tif (copy_from_user(&p, up, sizeof(p)))\n\t\treturn -EFAULT;\n\n\tp.port = -1;\n\tfor (part = 0; part < stdev->partition_count; part++) {\n\t\tpcfg = &stdev->mmio_part_cfg_all[part];\n\t\tp.partition = part;\n\n\t\treg = ioread32(&pcfg->usp_pff_inst_id);\n\t\tif (reg == p.pff) {\n\t\t\tp.port = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\treg = ioread32(&pcfg->vep_pff_inst_id) & 0xFF;\n\t\tif (reg == p.pff) {\n\t\t\tp.port = SWITCHTEC_IOCTL_PFF_VEP;\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (i = 0; i < ARRAY_SIZE(pcfg->dsp_pff_inst_id); i++) {\n\t\t\treg = ioread32(&pcfg->dsp_pff_inst_id[i]);\n\t\t\tif (reg != p.pff)\n\t\t\t\tcontinue;\n\n\t\t\tp.port = i + 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (p.port != -1)\n\t\t\tbreak;\n\t}\n\n\tif (copy_to_user(up, &p, sizeof(p)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int ioctl_port_to_pff(struct switchtec_dev *stdev,\n\t\t\t     struct switchtec_ioctl_pff_port __user *up)\n{\n\tstruct switchtec_ioctl_pff_port p;\n\tstruct part_cfg_regs __iomem *pcfg;\n\n\tif (copy_from_user(&p, up, sizeof(p)))\n\t\treturn -EFAULT;\n\n\tif (p.partition == SWITCHTEC_IOCTL_EVENT_LOCAL_PART_IDX)\n\t\tpcfg = stdev->mmio_part_cfg;\n\telse if (p.partition < stdev->partition_count)\n\t\tpcfg = &stdev->mmio_part_cfg_all[p.partition];\n\telse\n\t\treturn -EINVAL;\n\n\tswitch (p.port) {\n\tcase 0:\n\t\tp.pff = ioread32(&pcfg->usp_pff_inst_id);\n\t\tbreak;\n\tcase SWITCHTEC_IOCTL_PFF_VEP:\n\t\tp.pff = ioread32(&pcfg->vep_pff_inst_id) & 0xFF;\n\t\tbreak;\n\tdefault:\n\t\tif (p.port > ARRAY_SIZE(pcfg->dsp_pff_inst_id))\n\t\t\treturn -EINVAL;\n\t\tp.port = array_index_nospec(p.port,\n\t\t\t\t\tARRAY_SIZE(pcfg->dsp_pff_inst_id) + 1);\n\t\tp.pff = ioread32(&pcfg->dsp_pff_inst_id[p.port - 1]);\n\t\tbreak;\n\t}\n\n\tif (copy_to_user(up, &p, sizeof(p)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic long switchtec_dev_ioctl(struct file *filp, unsigned int cmd,\n\t\t\t\tunsigned long arg)\n{\n\tstruct switchtec_user *stuser = filp->private_data;\n\tstruct switchtec_dev *stdev = stuser->stdev;\n\tint rc;\n\tvoid __user *argp = (void __user *)arg;\n\n\trc = lock_mutex_and_test_alive(stdev);\n\tif (rc)\n\t\treturn rc;\n\n\tswitch (cmd) {\n\tcase SWITCHTEC_IOCTL_FLASH_INFO:\n\t\trc = ioctl_flash_info(stdev, argp);\n\t\tbreak;\n\tcase SWITCHTEC_IOCTL_FLASH_PART_INFO:\n\t\trc = ioctl_flash_part_info(stdev, argp);\n\t\tbreak;\n\tcase SWITCHTEC_IOCTL_EVENT_SUMMARY_LEGACY:\n\t\trc = ioctl_event_summary(stdev, stuser, argp,\n\t\t\t\t\t sizeof(struct switchtec_ioctl_event_summary_legacy));\n\t\tbreak;\n\tcase SWITCHTEC_IOCTL_EVENT_CTL:\n\t\trc = ioctl_event_ctl(stdev, argp);\n\t\tbreak;\n\tcase SWITCHTEC_IOCTL_PFF_TO_PORT:\n\t\trc = ioctl_pff_to_port(stdev, argp);\n\t\tbreak;\n\tcase SWITCHTEC_IOCTL_PORT_TO_PFF:\n\t\trc = ioctl_port_to_pff(stdev, argp);\n\t\tbreak;\n\tcase SWITCHTEC_IOCTL_EVENT_SUMMARY:\n\t\trc = ioctl_event_summary(stdev, stuser, argp,\n\t\t\t\t\t sizeof(struct switchtec_ioctl_event_summary));\n\t\tbreak;\n\tdefault:\n\t\trc = -ENOTTY;\n\t\tbreak;\n\t}\n\n\tmutex_unlock(&stdev->mrpc_mutex);\n\treturn rc;\n}\n\nstatic const struct file_operations switchtec_fops = {\n\t.owner = THIS_MODULE,\n\t.open = switchtec_dev_open,\n\t.release = switchtec_dev_release,\n\t.write = switchtec_dev_write,\n\t.read = switchtec_dev_read,\n\t.poll = switchtec_dev_poll,\n\t.unlocked_ioctl = switchtec_dev_ioctl,\n\t.compat_ioctl = compat_ptr_ioctl,\n};\n\nstatic void link_event_work(struct work_struct *work)\n{\n\tstruct switchtec_dev *stdev;\n\n\tstdev = container_of(work, struct switchtec_dev, link_event_work);\n\n\tif (stdev->link_notifier)\n\t\tstdev->link_notifier(stdev);\n}\n\nstatic void check_link_state_events(struct switchtec_dev *stdev)\n{\n\tint idx;\n\tu32 reg;\n\tint count;\n\tint occurred = 0;\n\n\tfor (idx = 0; idx < stdev->pff_csr_count; idx++) {\n\t\treg = ioread32(&stdev->mmio_pff_csr[idx].link_state_hdr);\n\t\tdev_dbg(&stdev->dev, \"link_state: %d->%08x\\n\", idx, reg);\n\t\tcount = (reg >> 5) & 0xFF;\n\n\t\tif (count != stdev->link_event_count[idx]) {\n\t\t\toccurred = 1;\n\t\t\tstdev->link_event_count[idx] = count;\n\t\t}\n\t}\n\n\tif (occurred)\n\t\tschedule_work(&stdev->link_event_work);\n}\n\nstatic void enable_link_state_events(struct switchtec_dev *stdev)\n{\n\tint idx;\n\n\tfor (idx = 0; idx < stdev->pff_csr_count; idx++) {\n\t\tiowrite32(SWITCHTEC_EVENT_CLEAR |\n\t\t\t  SWITCHTEC_EVENT_EN_IRQ,\n\t\t\t  &stdev->mmio_pff_csr[idx].link_state_hdr);\n\t}\n}\n\nstatic void enable_dma_mrpc(struct switchtec_dev *stdev)\n{\n\twriteq(stdev->dma_mrpc_dma_addr, &stdev->mmio_mrpc->dma_addr);\n\tflush_wc_buf(stdev);\n\tiowrite32(SWITCHTEC_DMA_MRPC_EN, &stdev->mmio_mrpc->dma_en);\n}\n\nstatic void stdev_release(struct device *dev)\n{\n\tstruct switchtec_dev *stdev = to_stdev(dev);\n\n\tif (stdev->dma_mrpc) {\n\t\tiowrite32(0, &stdev->mmio_mrpc->dma_en);\n\t\tflush_wc_buf(stdev);\n\t\twriteq(0, &stdev->mmio_mrpc->dma_addr);\n\t\tdma_free_coherent(&stdev->pdev->dev, sizeof(*stdev->dma_mrpc),\n\t\t\t\tstdev->dma_mrpc, stdev->dma_mrpc_dma_addr);\n\t}\n\tkfree(stdev);\n}\n\nstatic void stdev_kill(struct switchtec_dev *stdev)\n{\n\tstruct switchtec_user *stuser, *tmpuser;\n\n\tpci_clear_master(stdev->pdev);\n\n\tcancel_delayed_work_sync(&stdev->mrpc_timeout);\n\n\t \n\tmutex_lock(&stdev->mrpc_mutex);\n\tstdev->alive = false;\n\n\t \n\tlist_for_each_entry_safe(stuser, tmpuser, &stdev->mrpc_queue, list) {\n\t\tstuser->cmd_done = true;\n\t\twake_up_interruptible(&stuser->cmd_comp);\n\t\tlist_del_init(&stuser->list);\n\t\tstuser_put(stuser);\n\t}\n\n\tmutex_unlock(&stdev->mrpc_mutex);\n\n\t \n\twake_up_interruptible(&stdev->event_wq);\n}\n\nstatic struct switchtec_dev *stdev_create(struct pci_dev *pdev)\n{\n\tstruct switchtec_dev *stdev;\n\tint minor;\n\tstruct device *dev;\n\tstruct cdev *cdev;\n\tint rc;\n\n\tstdev = kzalloc_node(sizeof(*stdev), GFP_KERNEL,\n\t\t\t     dev_to_node(&pdev->dev));\n\tif (!stdev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tstdev->alive = true;\n\tstdev->pdev = pdev;\n\tINIT_LIST_HEAD(&stdev->mrpc_queue);\n\tmutex_init(&stdev->mrpc_mutex);\n\tstdev->mrpc_busy = 0;\n\tINIT_WORK(&stdev->mrpc_work, mrpc_event_work);\n\tINIT_DELAYED_WORK(&stdev->mrpc_timeout, mrpc_timeout_work);\n\tINIT_WORK(&stdev->link_event_work, link_event_work);\n\tinit_waitqueue_head(&stdev->event_wq);\n\tatomic_set(&stdev->event_cnt, 0);\n\n\tdev = &stdev->dev;\n\tdevice_initialize(dev);\n\tdev->class = switchtec_class;\n\tdev->parent = &pdev->dev;\n\tdev->groups = switchtec_device_groups;\n\tdev->release = stdev_release;\n\n\tminor = ida_alloc(&switchtec_minor_ida, GFP_KERNEL);\n\tif (minor < 0) {\n\t\trc = minor;\n\t\tgoto err_put;\n\t}\n\n\tdev->devt = MKDEV(MAJOR(switchtec_devt), minor);\n\tdev_set_name(dev, \"switchtec%d\", minor);\n\n\tcdev = &stdev->cdev;\n\tcdev_init(cdev, &switchtec_fops);\n\tcdev->owner = THIS_MODULE;\n\n\treturn stdev;\n\nerr_put:\n\tput_device(&stdev->dev);\n\treturn ERR_PTR(rc);\n}\n\nstatic int mask_event(struct switchtec_dev *stdev, int eid, int idx)\n{\n\tsize_t off = event_regs[eid].offset;\n\tu32 __iomem *hdr_reg;\n\tu32 hdr;\n\n\thdr_reg = event_regs[eid].map_reg(stdev, off, idx);\n\thdr = ioread32(hdr_reg);\n\n\tif (hdr & SWITCHTEC_EVENT_NOT_SUPP)\n\t\treturn 0;\n\n\tif (!(hdr & SWITCHTEC_EVENT_OCCURRED && hdr & SWITCHTEC_EVENT_EN_IRQ))\n\t\treturn 0;\n\n\tdev_dbg(&stdev->dev, \"%s: %d %d %x\\n\", __func__, eid, idx, hdr);\n\thdr &= ~(SWITCHTEC_EVENT_EN_IRQ | SWITCHTEC_EVENT_OCCURRED);\n\tiowrite32(hdr, hdr_reg);\n\n\treturn 1;\n}\n\nstatic int mask_all_events(struct switchtec_dev *stdev, int eid)\n{\n\tint idx;\n\tint count = 0;\n\n\tif (event_regs[eid].map_reg == part_ev_reg) {\n\t\tfor (idx = 0; idx < stdev->partition_count; idx++)\n\t\t\tcount += mask_event(stdev, eid, idx);\n\t} else if (event_regs[eid].map_reg == pff_ev_reg) {\n\t\tfor (idx = 0; idx < stdev->pff_csr_count; idx++) {\n\t\t\tif (!stdev->pff_local[idx])\n\t\t\t\tcontinue;\n\n\t\t\tcount += mask_event(stdev, eid, idx);\n\t\t}\n\t} else {\n\t\tcount += mask_event(stdev, eid, 0);\n\t}\n\n\treturn count;\n}\n\nstatic irqreturn_t switchtec_event_isr(int irq, void *dev)\n{\n\tstruct switchtec_dev *stdev = dev;\n\tu32 reg;\n\tirqreturn_t ret = IRQ_NONE;\n\tint eid, event_count = 0;\n\n\treg = ioread32(&stdev->mmio_part_cfg->mrpc_comp_hdr);\n\tif (reg & SWITCHTEC_EVENT_OCCURRED) {\n\t\tdev_dbg(&stdev->dev, \"%s: mrpc comp\\n\", __func__);\n\t\tret = IRQ_HANDLED;\n\t\tschedule_work(&stdev->mrpc_work);\n\t\tiowrite32(reg, &stdev->mmio_part_cfg->mrpc_comp_hdr);\n\t}\n\n\tcheck_link_state_events(stdev);\n\n\tfor (eid = 0; eid < SWITCHTEC_IOCTL_MAX_EVENTS; eid++) {\n\t\tif (eid == SWITCHTEC_IOCTL_EVENT_LINK_STATE ||\n\t\t    eid == SWITCHTEC_IOCTL_EVENT_MRPC_COMP)\n\t\t\tcontinue;\n\n\t\tevent_count += mask_all_events(stdev, eid);\n\t}\n\n\tif (event_count) {\n\t\tatomic_inc(&stdev->event_cnt);\n\t\twake_up_interruptible(&stdev->event_wq);\n\t\tdev_dbg(&stdev->dev, \"%s: %d events\\n\", __func__,\n\t\t\tevent_count);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\treturn ret;\n}\n\n\nstatic irqreturn_t switchtec_dma_mrpc_isr(int irq, void *dev)\n{\n\tstruct switchtec_dev *stdev = dev;\n\n\tiowrite32(SWITCHTEC_EVENT_CLEAR |\n\t\t  SWITCHTEC_EVENT_EN_IRQ,\n\t\t  &stdev->mmio_part_cfg->mrpc_comp_hdr);\n\tschedule_work(&stdev->mrpc_work);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int switchtec_init_isr(struct switchtec_dev *stdev)\n{\n\tint nvecs;\n\tint event_irq;\n\tint dma_mrpc_irq;\n\tint rc;\n\n\tif (nirqs < 4)\n\t\tnirqs = 4;\n\n\tnvecs = pci_alloc_irq_vectors(stdev->pdev, 1, nirqs,\n\t\t\t\t      PCI_IRQ_MSIX | PCI_IRQ_MSI |\n\t\t\t\t      PCI_IRQ_VIRTUAL);\n\tif (nvecs < 0)\n\t\treturn nvecs;\n\n\tevent_irq = ioread16(&stdev->mmio_part_cfg->vep_vector_number);\n\tif (event_irq < 0 || event_irq >= nvecs)\n\t\treturn -EFAULT;\n\n\tevent_irq = pci_irq_vector(stdev->pdev, event_irq);\n\tif (event_irq < 0)\n\t\treturn event_irq;\n\n\trc = devm_request_irq(&stdev->pdev->dev, event_irq,\n\t\t\t\tswitchtec_event_isr, 0,\n\t\t\t\tKBUILD_MODNAME, stdev);\n\n\tif (rc)\n\t\treturn rc;\n\n\tif (!stdev->dma_mrpc)\n\t\treturn rc;\n\n\tdma_mrpc_irq = ioread32(&stdev->mmio_mrpc->dma_vector);\n\tif (dma_mrpc_irq < 0 || dma_mrpc_irq >= nvecs)\n\t\treturn -EFAULT;\n\n\tdma_mrpc_irq  = pci_irq_vector(stdev->pdev, dma_mrpc_irq);\n\tif (dma_mrpc_irq < 0)\n\t\treturn dma_mrpc_irq;\n\n\trc = devm_request_irq(&stdev->pdev->dev, dma_mrpc_irq,\n\t\t\t\tswitchtec_dma_mrpc_isr, 0,\n\t\t\t\tKBUILD_MODNAME, stdev);\n\n\treturn rc;\n}\n\nstatic void init_pff(struct switchtec_dev *stdev)\n{\n\tint i;\n\tu32 reg;\n\tstruct part_cfg_regs __iomem *pcfg = stdev->mmio_part_cfg;\n\n\tfor (i = 0; i < SWITCHTEC_MAX_PFF_CSR; i++) {\n\t\treg = ioread16(&stdev->mmio_pff_csr[i].vendor_id);\n\t\tif (reg != PCI_VENDOR_ID_MICROSEMI)\n\t\t\tbreak;\n\t}\n\n\tstdev->pff_csr_count = i;\n\n\treg = ioread32(&pcfg->usp_pff_inst_id);\n\tif (reg < stdev->pff_csr_count)\n\t\tstdev->pff_local[reg] = 1;\n\n\treg = ioread32(&pcfg->vep_pff_inst_id) & 0xFF;\n\tif (reg < stdev->pff_csr_count)\n\t\tstdev->pff_local[reg] = 1;\n\n\tfor (i = 0; i < ARRAY_SIZE(pcfg->dsp_pff_inst_id); i++) {\n\t\treg = ioread32(&pcfg->dsp_pff_inst_id[i]);\n\t\tif (reg < stdev->pff_csr_count)\n\t\t\tstdev->pff_local[reg] = 1;\n\t}\n}\n\nstatic int switchtec_init_pci(struct switchtec_dev *stdev,\n\t\t\t      struct pci_dev *pdev)\n{\n\tint rc;\n\tvoid __iomem *map;\n\tunsigned long res_start, res_len;\n\tu32 __iomem *part_id;\n\n\trc = pcim_enable_device(pdev);\n\tif (rc)\n\t\treturn rc;\n\n\trc = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(64));\n\tif (rc)\n\t\treturn rc;\n\n\tpci_set_master(pdev);\n\n\tres_start = pci_resource_start(pdev, 0);\n\tres_len = pci_resource_len(pdev, 0);\n\n\tif (!devm_request_mem_region(&pdev->dev, res_start,\n\t\t\t\t     res_len, KBUILD_MODNAME))\n\t\treturn -EBUSY;\n\n\tstdev->mmio_mrpc = devm_ioremap_wc(&pdev->dev, res_start,\n\t\t\t\t\t   SWITCHTEC_GAS_TOP_CFG_OFFSET);\n\tif (!stdev->mmio_mrpc)\n\t\treturn -ENOMEM;\n\n\tmap = devm_ioremap(&pdev->dev,\n\t\t\t   res_start + SWITCHTEC_GAS_TOP_CFG_OFFSET,\n\t\t\t   res_len - SWITCHTEC_GAS_TOP_CFG_OFFSET);\n\tif (!map)\n\t\treturn -ENOMEM;\n\n\tstdev->mmio = map - SWITCHTEC_GAS_TOP_CFG_OFFSET;\n\tstdev->mmio_sw_event = stdev->mmio + SWITCHTEC_GAS_SW_EVENT_OFFSET;\n\tstdev->mmio_sys_info = stdev->mmio + SWITCHTEC_GAS_SYS_INFO_OFFSET;\n\tstdev->mmio_flash_info = stdev->mmio + SWITCHTEC_GAS_FLASH_INFO_OFFSET;\n\tstdev->mmio_ntb = stdev->mmio + SWITCHTEC_GAS_NTB_OFFSET;\n\n\tif (stdev->gen == SWITCHTEC_GEN3)\n\t\tpart_id = &stdev->mmio_sys_info->gen3.partition_id;\n\telse if (stdev->gen >= SWITCHTEC_GEN4)\n\t\tpart_id = &stdev->mmio_sys_info->gen4.partition_id;\n\telse\n\t\treturn -EOPNOTSUPP;\n\n\tstdev->partition = ioread8(part_id);\n\tstdev->partition_count = ioread8(&stdev->mmio_ntb->partition_count);\n\tstdev->mmio_part_cfg_all = stdev->mmio + SWITCHTEC_GAS_PART_CFG_OFFSET;\n\tstdev->mmio_part_cfg = &stdev->mmio_part_cfg_all[stdev->partition];\n\tstdev->mmio_pff_csr = stdev->mmio + SWITCHTEC_GAS_PFF_CSR_OFFSET;\n\n\tif (stdev->partition_count < 1)\n\t\tstdev->partition_count = 1;\n\n\tinit_pff(stdev);\n\n\tpci_set_drvdata(pdev, stdev);\n\n\tif (!use_dma_mrpc)\n\t\treturn 0;\n\n\tif (ioread32(&stdev->mmio_mrpc->dma_ver) == 0)\n\t\treturn 0;\n\n\tstdev->dma_mrpc = dma_alloc_coherent(&stdev->pdev->dev,\n\t\t\t\t\t     sizeof(*stdev->dma_mrpc),\n\t\t\t\t\t     &stdev->dma_mrpc_dma_addr,\n\t\t\t\t\t     GFP_KERNEL);\n\tif (stdev->dma_mrpc == NULL)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic int switchtec_pci_probe(struct pci_dev *pdev,\n\t\t\t       const struct pci_device_id *id)\n{\n\tstruct switchtec_dev *stdev;\n\tint rc;\n\n\tif (pdev->class == (PCI_CLASS_BRIDGE_OTHER << 8))\n\t\trequest_module_nowait(\"ntb_hw_switchtec\");\n\n\tstdev = stdev_create(pdev);\n\tif (IS_ERR(stdev))\n\t\treturn PTR_ERR(stdev);\n\n\tstdev->gen = id->driver_data;\n\n\trc = switchtec_init_pci(stdev, pdev);\n\tif (rc)\n\t\tgoto err_put;\n\n\trc = switchtec_init_isr(stdev);\n\tif (rc) {\n\t\tdev_err(&stdev->dev, \"failed to init isr.\\n\");\n\t\tgoto err_put;\n\t}\n\n\tiowrite32(SWITCHTEC_EVENT_CLEAR |\n\t\t  SWITCHTEC_EVENT_EN_IRQ,\n\t\t  &stdev->mmio_part_cfg->mrpc_comp_hdr);\n\tenable_link_state_events(stdev);\n\n\tif (stdev->dma_mrpc)\n\t\tenable_dma_mrpc(stdev);\n\n\trc = cdev_device_add(&stdev->cdev, &stdev->dev);\n\tif (rc)\n\t\tgoto err_devadd;\n\n\tdev_info(&stdev->dev, \"Management device registered.\\n\");\n\n\treturn 0;\n\nerr_devadd:\n\tstdev_kill(stdev);\nerr_put:\n\tida_free(&switchtec_minor_ida, MINOR(stdev->dev.devt));\n\tput_device(&stdev->dev);\n\treturn rc;\n}\n\nstatic void switchtec_pci_remove(struct pci_dev *pdev)\n{\n\tstruct switchtec_dev *stdev = pci_get_drvdata(pdev);\n\n\tpci_set_drvdata(pdev, NULL);\n\n\tcdev_device_del(&stdev->cdev, &stdev->dev);\n\tida_free(&switchtec_minor_ida, MINOR(stdev->dev.devt));\n\tdev_info(&stdev->dev, \"unregistered.\\n\");\n\tstdev_kill(stdev);\n\tput_device(&stdev->dev);\n}\n\n#define SWITCHTEC_PCI_DEVICE(device_id, gen) \\\n\t{ \\\n\t\t.vendor     = PCI_VENDOR_ID_MICROSEMI, \\\n\t\t.device     = device_id, \\\n\t\t.subvendor  = PCI_ANY_ID, \\\n\t\t.subdevice  = PCI_ANY_ID, \\\n\t\t.class      = (PCI_CLASS_MEMORY_OTHER << 8), \\\n\t\t.class_mask = 0xFFFFFFFF, \\\n\t\t.driver_data = gen, \\\n\t}, \\\n\t{ \\\n\t\t.vendor     = PCI_VENDOR_ID_MICROSEMI, \\\n\t\t.device     = device_id, \\\n\t\t.subvendor  = PCI_ANY_ID, \\\n\t\t.subdevice  = PCI_ANY_ID, \\\n\t\t.class      = (PCI_CLASS_BRIDGE_OTHER << 8), \\\n\t\t.class_mask = 0xFFFFFFFF, \\\n\t\t.driver_data = gen, \\\n\t}\n\nstatic const struct pci_device_id switchtec_pci_tbl[] = {\n\tSWITCHTEC_PCI_DEVICE(0x8531, SWITCHTEC_GEN3),   \n\tSWITCHTEC_PCI_DEVICE(0x8532, SWITCHTEC_GEN3),   \n\tSWITCHTEC_PCI_DEVICE(0x8533, SWITCHTEC_GEN3),   \n\tSWITCHTEC_PCI_DEVICE(0x8534, SWITCHTEC_GEN3),   \n\tSWITCHTEC_PCI_DEVICE(0x8535, SWITCHTEC_GEN3),   \n\tSWITCHTEC_PCI_DEVICE(0x8536, SWITCHTEC_GEN3),   \n\tSWITCHTEC_PCI_DEVICE(0x8541, SWITCHTEC_GEN3),   \n\tSWITCHTEC_PCI_DEVICE(0x8542, SWITCHTEC_GEN3),   \n\tSWITCHTEC_PCI_DEVICE(0x8543, SWITCHTEC_GEN3),   \n\tSWITCHTEC_PCI_DEVICE(0x8544, SWITCHTEC_GEN3),   \n\tSWITCHTEC_PCI_DEVICE(0x8545, SWITCHTEC_GEN3),   \n\tSWITCHTEC_PCI_DEVICE(0x8546, SWITCHTEC_GEN3),   \n\tSWITCHTEC_PCI_DEVICE(0x8551, SWITCHTEC_GEN3),   \n\tSWITCHTEC_PCI_DEVICE(0x8552, SWITCHTEC_GEN3),   \n\tSWITCHTEC_PCI_DEVICE(0x8553, SWITCHTEC_GEN3),   \n\tSWITCHTEC_PCI_DEVICE(0x8554, SWITCHTEC_GEN3),   \n\tSWITCHTEC_PCI_DEVICE(0x8555, SWITCHTEC_GEN3),   \n\tSWITCHTEC_PCI_DEVICE(0x8556, SWITCHTEC_GEN3),   \n\tSWITCHTEC_PCI_DEVICE(0x8561, SWITCHTEC_GEN3),   \n\tSWITCHTEC_PCI_DEVICE(0x8562, SWITCHTEC_GEN3),   \n\tSWITCHTEC_PCI_DEVICE(0x8563, SWITCHTEC_GEN3),   \n\tSWITCHTEC_PCI_DEVICE(0x8564, SWITCHTEC_GEN3),   \n\tSWITCHTEC_PCI_DEVICE(0x8565, SWITCHTEC_GEN3),   \n\tSWITCHTEC_PCI_DEVICE(0x8566, SWITCHTEC_GEN3),   \n\tSWITCHTEC_PCI_DEVICE(0x8571, SWITCHTEC_GEN3),   \n\tSWITCHTEC_PCI_DEVICE(0x8572, SWITCHTEC_GEN3),   \n\tSWITCHTEC_PCI_DEVICE(0x8573, SWITCHTEC_GEN3),   \n\tSWITCHTEC_PCI_DEVICE(0x8574, SWITCHTEC_GEN3),   \n\tSWITCHTEC_PCI_DEVICE(0x8575, SWITCHTEC_GEN3),   \n\tSWITCHTEC_PCI_DEVICE(0x8576, SWITCHTEC_GEN3),   \n\tSWITCHTEC_PCI_DEVICE(0x4000, SWITCHTEC_GEN4),   \n\tSWITCHTEC_PCI_DEVICE(0x4084, SWITCHTEC_GEN4),   \n\tSWITCHTEC_PCI_DEVICE(0x4068, SWITCHTEC_GEN4),   \n\tSWITCHTEC_PCI_DEVICE(0x4052, SWITCHTEC_GEN4),   \n\tSWITCHTEC_PCI_DEVICE(0x4036, SWITCHTEC_GEN4),   \n\tSWITCHTEC_PCI_DEVICE(0x4028, SWITCHTEC_GEN4),   \n\tSWITCHTEC_PCI_DEVICE(0x4100, SWITCHTEC_GEN4),   \n\tSWITCHTEC_PCI_DEVICE(0x4184, SWITCHTEC_GEN4),   \n\tSWITCHTEC_PCI_DEVICE(0x4168, SWITCHTEC_GEN4),   \n\tSWITCHTEC_PCI_DEVICE(0x4152, SWITCHTEC_GEN4),   \n\tSWITCHTEC_PCI_DEVICE(0x4136, SWITCHTEC_GEN4),   \n\tSWITCHTEC_PCI_DEVICE(0x4128, SWITCHTEC_GEN4),   \n\tSWITCHTEC_PCI_DEVICE(0x4200, SWITCHTEC_GEN4),   \n\tSWITCHTEC_PCI_DEVICE(0x4284, SWITCHTEC_GEN4),   \n\tSWITCHTEC_PCI_DEVICE(0x4268, SWITCHTEC_GEN4),   \n\tSWITCHTEC_PCI_DEVICE(0x4252, SWITCHTEC_GEN4),   \n\tSWITCHTEC_PCI_DEVICE(0x4236, SWITCHTEC_GEN4),   \n\tSWITCHTEC_PCI_DEVICE(0x4228, SWITCHTEC_GEN4),   \n\tSWITCHTEC_PCI_DEVICE(0x4352, SWITCHTEC_GEN4),   \n\tSWITCHTEC_PCI_DEVICE(0x4336, SWITCHTEC_GEN4),   \n\tSWITCHTEC_PCI_DEVICE(0x4328, SWITCHTEC_GEN4),   \n\tSWITCHTEC_PCI_DEVICE(0x4452, SWITCHTEC_GEN4),   \n\tSWITCHTEC_PCI_DEVICE(0x4436, SWITCHTEC_GEN4),   \n\tSWITCHTEC_PCI_DEVICE(0x4428, SWITCHTEC_GEN4),   \n\tSWITCHTEC_PCI_DEVICE(0x4552, SWITCHTEC_GEN4),   \n\tSWITCHTEC_PCI_DEVICE(0x4536, SWITCHTEC_GEN4),   \n\tSWITCHTEC_PCI_DEVICE(0x4528, SWITCHTEC_GEN4),   \n\tSWITCHTEC_PCI_DEVICE(0x5000, SWITCHTEC_GEN5),   \n\tSWITCHTEC_PCI_DEVICE(0x5084, SWITCHTEC_GEN5),   \n\tSWITCHTEC_PCI_DEVICE(0x5068, SWITCHTEC_GEN5),   \n\tSWITCHTEC_PCI_DEVICE(0x5052, SWITCHTEC_GEN5),   \n\tSWITCHTEC_PCI_DEVICE(0x5036, SWITCHTEC_GEN5),   \n\tSWITCHTEC_PCI_DEVICE(0x5028, SWITCHTEC_GEN5),   \n\tSWITCHTEC_PCI_DEVICE(0x5100, SWITCHTEC_GEN5),   \n\tSWITCHTEC_PCI_DEVICE(0x5184, SWITCHTEC_GEN5),   \n\tSWITCHTEC_PCI_DEVICE(0x5168, SWITCHTEC_GEN5),   \n\tSWITCHTEC_PCI_DEVICE(0x5152, SWITCHTEC_GEN5),   \n\tSWITCHTEC_PCI_DEVICE(0x5136, SWITCHTEC_GEN5),   \n\tSWITCHTEC_PCI_DEVICE(0x5128, SWITCHTEC_GEN5),   \n\tSWITCHTEC_PCI_DEVICE(0x5200, SWITCHTEC_GEN5),   \n\tSWITCHTEC_PCI_DEVICE(0x5284, SWITCHTEC_GEN5),   \n\tSWITCHTEC_PCI_DEVICE(0x5268, SWITCHTEC_GEN5),   \n\tSWITCHTEC_PCI_DEVICE(0x5252, SWITCHTEC_GEN5),   \n\tSWITCHTEC_PCI_DEVICE(0x5236, SWITCHTEC_GEN5),   \n\tSWITCHTEC_PCI_DEVICE(0x5228, SWITCHTEC_GEN5),   \n\tSWITCHTEC_PCI_DEVICE(0x5300, SWITCHTEC_GEN5),   \n\tSWITCHTEC_PCI_DEVICE(0x5384, SWITCHTEC_GEN5),   \n\tSWITCHTEC_PCI_DEVICE(0x5368, SWITCHTEC_GEN5),   \n\tSWITCHTEC_PCI_DEVICE(0x5352, SWITCHTEC_GEN5),   \n\tSWITCHTEC_PCI_DEVICE(0x5336, SWITCHTEC_GEN5),   \n\tSWITCHTEC_PCI_DEVICE(0x5328, SWITCHTEC_GEN5),   \n\tSWITCHTEC_PCI_DEVICE(0x5400, SWITCHTEC_GEN5),   \n\tSWITCHTEC_PCI_DEVICE(0x5484, SWITCHTEC_GEN5),   \n\tSWITCHTEC_PCI_DEVICE(0x5468, SWITCHTEC_GEN5),   \n\tSWITCHTEC_PCI_DEVICE(0x5452, SWITCHTEC_GEN5),   \n\tSWITCHTEC_PCI_DEVICE(0x5436, SWITCHTEC_GEN5),   \n\tSWITCHTEC_PCI_DEVICE(0x5428, SWITCHTEC_GEN5),   \n\tSWITCHTEC_PCI_DEVICE(0x5500, SWITCHTEC_GEN5),   \n\tSWITCHTEC_PCI_DEVICE(0x5584, SWITCHTEC_GEN5),   \n\tSWITCHTEC_PCI_DEVICE(0x5568, SWITCHTEC_GEN5),   \n\tSWITCHTEC_PCI_DEVICE(0x5552, SWITCHTEC_GEN5),   \n\tSWITCHTEC_PCI_DEVICE(0x5536, SWITCHTEC_GEN5),   \n\tSWITCHTEC_PCI_DEVICE(0x5528, SWITCHTEC_GEN5),   \n\t{0}\n};\nMODULE_DEVICE_TABLE(pci, switchtec_pci_tbl);\n\nstatic struct pci_driver switchtec_pci_driver = {\n\t.name\t\t= KBUILD_MODNAME,\n\t.id_table\t= switchtec_pci_tbl,\n\t.probe\t\t= switchtec_pci_probe,\n\t.remove\t\t= switchtec_pci_remove,\n};\n\nstatic int __init switchtec_init(void)\n{\n\tint rc;\n\n\trc = alloc_chrdev_region(&switchtec_devt, 0, max_devices,\n\t\t\t\t \"switchtec\");\n\tif (rc)\n\t\treturn rc;\n\n\tswitchtec_class = class_create(\"switchtec\");\n\tif (IS_ERR(switchtec_class)) {\n\t\trc = PTR_ERR(switchtec_class);\n\t\tgoto err_create_class;\n\t}\n\n\trc = pci_register_driver(&switchtec_pci_driver);\n\tif (rc)\n\t\tgoto err_pci_register;\n\n\tpr_info(KBUILD_MODNAME \": loaded.\\n\");\n\n\treturn 0;\n\nerr_pci_register:\n\tclass_destroy(switchtec_class);\n\nerr_create_class:\n\tunregister_chrdev_region(switchtec_devt, max_devices);\n\n\treturn rc;\n}\nmodule_init(switchtec_init);\n\nstatic void __exit switchtec_exit(void)\n{\n\tpci_unregister_driver(&switchtec_pci_driver);\n\tclass_destroy(switchtec_class);\n\tunregister_chrdev_region(switchtec_devt, max_devices);\n\tida_destroy(&switchtec_minor_ida);\n\n\tpr_info(KBUILD_MODNAME \": unloaded.\\n\");\n}\nmodule_exit(switchtec_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}