{
  "module_name": "ecam.c",
  "hash_id": "ef4f2c2078f3e4202cc0e64872949ed6939a8b4bc230f40ebcdaab447a52a7dd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/ecam.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/pci-ecam.h>\n#include <linux/slab.h>\n\n \nstatic const bool per_bus_mapping = !IS_ENABLED(CONFIG_64BIT);\n\n \nstruct pci_config_window *pci_ecam_create(struct device *dev,\n\t\tstruct resource *cfgres, struct resource *busr,\n\t\tconst struct pci_ecam_ops *ops)\n{\n\tunsigned int bus_shift = ops->bus_shift;\n\tstruct pci_config_window *cfg;\n\tunsigned int bus_range, bus_range_max, bsz;\n\tstruct resource *conflict;\n\tint err;\n\n\tif (busr->start > busr->end)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tcfg = kzalloc(sizeof(*cfg), GFP_KERNEL);\n\tif (!cfg)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t \n\tif (!bus_shift)\n\t\tbus_shift = PCIE_ECAM_BUS_SHIFT;\n\n\tcfg->parent = dev;\n\tcfg->ops = ops;\n\tcfg->busr.start = busr->start;\n\tcfg->busr.end = busr->end;\n\tcfg->busr.flags = IORESOURCE_BUS;\n\tcfg->bus_shift = bus_shift;\n\tbus_range = resource_size(&cfg->busr);\n\tbus_range_max = resource_size(cfgres) >> bus_shift;\n\tif (bus_range > bus_range_max) {\n\t\tbus_range = bus_range_max;\n\t\tcfg->busr.end = busr->start + bus_range - 1;\n\t\tdev_warn(dev, \"ECAM area %pR can only accommodate %pR (reduced from %pR desired)\\n\",\n\t\t\t cfgres, &cfg->busr, busr);\n\t}\n\tbsz = 1 << bus_shift;\n\n\tcfg->res.start = cfgres->start;\n\tcfg->res.end = cfgres->end;\n\tcfg->res.flags = IORESOURCE_MEM | IORESOURCE_BUSY;\n\tcfg->res.name = \"PCI ECAM\";\n\n\tconflict = request_resource_conflict(&iomem_resource, &cfg->res);\n\tif (conflict) {\n\t\terr = -EBUSY;\n\t\tdev_err(dev, \"can't claim ECAM area %pR: address conflict with %s %pR\\n\",\n\t\t\t&cfg->res, conflict->name, conflict);\n\t\tgoto err_exit;\n\t}\n\n\tif (per_bus_mapping) {\n\t\tcfg->winp = kcalloc(bus_range, sizeof(*cfg->winp), GFP_KERNEL);\n\t\tif (!cfg->winp)\n\t\t\tgoto err_exit_malloc;\n\t} else {\n\t\tcfg->win = pci_remap_cfgspace(cfgres->start, bus_range * bsz);\n\t\tif (!cfg->win)\n\t\t\tgoto err_exit_iomap;\n\t}\n\n\tif (ops->init) {\n\t\terr = ops->init(cfg);\n\t\tif (err)\n\t\t\tgoto err_exit;\n\t}\n\tdev_info(dev, \"ECAM at %pR for %pR\\n\", &cfg->res, &cfg->busr);\n\treturn cfg;\n\nerr_exit_iomap:\n\tdev_err(dev, \"ECAM ioremap failed\\n\");\nerr_exit_malloc:\n\terr = -ENOMEM;\nerr_exit:\n\tpci_ecam_free(cfg);\n\treturn ERR_PTR(err);\n}\nEXPORT_SYMBOL_GPL(pci_ecam_create);\n\nvoid pci_ecam_free(struct pci_config_window *cfg)\n{\n\tint i;\n\n\tif (per_bus_mapping) {\n\t\tif (cfg->winp) {\n\t\t\tfor (i = 0; i < resource_size(&cfg->busr); i++)\n\t\t\t\tif (cfg->winp[i])\n\t\t\t\t\tiounmap(cfg->winp[i]);\n\t\t\tkfree(cfg->winp);\n\t\t}\n\t} else {\n\t\tif (cfg->win)\n\t\t\tiounmap(cfg->win);\n\t}\n\tif (cfg->res.parent)\n\t\trelease_resource(&cfg->res);\n\tkfree(cfg);\n}\nEXPORT_SYMBOL_GPL(pci_ecam_free);\n\nstatic int pci_ecam_add_bus(struct pci_bus *bus)\n{\n\tstruct pci_config_window *cfg = bus->sysdata;\n\tunsigned int bsz = 1 << cfg->bus_shift;\n\tunsigned int busn = bus->number;\n\tphys_addr_t start;\n\n\tif (!per_bus_mapping)\n\t\treturn 0;\n\n\tif (busn < cfg->busr.start || busn > cfg->busr.end)\n\t\treturn -EINVAL;\n\n\tbusn -= cfg->busr.start;\n\tstart = cfg->res.start + busn * bsz;\n\n\tcfg->winp[busn] = pci_remap_cfgspace(start, bsz);\n\tif (!cfg->winp[busn])\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic void pci_ecam_remove_bus(struct pci_bus *bus)\n{\n\tstruct pci_config_window *cfg = bus->sysdata;\n\tunsigned int busn = bus->number;\n\n\tif (!per_bus_mapping || busn < cfg->busr.start || busn > cfg->busr.end)\n\t\treturn;\n\n\tbusn -= cfg->busr.start;\n\tif (cfg->winp[busn]) {\n\t\tiounmap(cfg->winp[busn]);\n\t\tcfg->winp[busn] = NULL;\n\t}\n}\n\n \nvoid __iomem *pci_ecam_map_bus(struct pci_bus *bus, unsigned int devfn,\n\t\t\t       int where)\n{\n\tstruct pci_config_window *cfg = bus->sysdata;\n\tunsigned int bus_shift = cfg->ops->bus_shift;\n\tunsigned int devfn_shift = cfg->ops->bus_shift - 8;\n\tunsigned int busn = bus->number;\n\tvoid __iomem *base;\n\tu32 bus_offset, devfn_offset;\n\n\tif (busn < cfg->busr.start || busn > cfg->busr.end)\n\t\treturn NULL;\n\n\tbusn -= cfg->busr.start;\n\tif (per_bus_mapping) {\n\t\tbase = cfg->winp[busn];\n\t\tbusn = 0;\n\t} else\n\t\tbase = cfg->win;\n\n\tif (cfg->ops->bus_shift) {\n\t\tbus_offset = (busn & PCIE_ECAM_BUS_MASK) << bus_shift;\n\t\tdevfn_offset = (devfn & PCIE_ECAM_DEVFN_MASK) << devfn_shift;\n\t\twhere &= PCIE_ECAM_REG_MASK;\n\n\t\treturn base + (bus_offset | devfn_offset | where);\n\t}\n\n\treturn base + PCIE_ECAM_OFFSET(busn, devfn, where);\n}\nEXPORT_SYMBOL_GPL(pci_ecam_map_bus);\n\n \nconst struct pci_ecam_ops pci_generic_ecam_ops = {\n\t.pci_ops\t= {\n\t\t.add_bus\t= pci_ecam_add_bus,\n\t\t.remove_bus\t= pci_ecam_remove_bus,\n\t\t.map_bus\t= pci_ecam_map_bus,\n\t\t.read\t\t= pci_generic_config_read,\n\t\t.write\t\t= pci_generic_config_write,\n\t}\n};\nEXPORT_SYMBOL_GPL(pci_generic_ecam_ops);\n\n#if defined(CONFIG_ACPI) && defined(CONFIG_PCI_QUIRKS)\n \nconst struct pci_ecam_ops pci_32b_ops = {\n\t.pci_ops\t= {\n\t\t.add_bus\t= pci_ecam_add_bus,\n\t\t.remove_bus\t= pci_ecam_remove_bus,\n\t\t.map_bus\t= pci_ecam_map_bus,\n\t\t.read\t\t= pci_generic_config_read32,\n\t\t.write\t\t= pci_generic_config_write32,\n\t}\n};\n\n \nconst struct pci_ecam_ops pci_32b_read_ops = {\n\t.pci_ops\t= {\n\t\t.add_bus\t= pci_ecam_add_bus,\n\t\t.remove_bus\t= pci_ecam_remove_bus,\n\t\t.map_bus\t= pci_ecam_map_bus,\n\t\t.read\t\t= pci_generic_config_read32,\n\t\t.write\t\t= pci_generic_config_write,\n\t}\n};\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}