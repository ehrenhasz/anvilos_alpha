{
  "module_name": "xen-pcifront.c",
  "hash_id": "877a8347a1ae2bce502f246e9890db3a2eb0591c27d054f5784068954cb00a40",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/xen-pcifront.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <xen/xenbus.h>\n#include <xen/events.h>\n#include <xen/grant_table.h>\n#include <xen/page.h>\n#include <linux/spinlock.h>\n#include <linux/pci.h>\n#include <linux/msi.h>\n#include <xen/interface/io/pciif.h>\n#include <asm/xen/pci.h>\n#include <linux/interrupt.h>\n#include <linux/atomic.h>\n#include <linux/workqueue.h>\n#include <linux/bitops.h>\n#include <linux/time.h>\n#include <linux/ktime.h>\n#include <xen/platform_pci.h>\n\n#include <asm/xen/swiotlb-xen.h>\n\n#define INVALID_EVTCHN    (-1)\n\nstruct pci_bus_entry {\n\tstruct list_head list;\n\tstruct pci_bus *bus;\n};\n\n#define _PDEVB_op_active\t\t(0)\n#define PDEVB_op_active\t\t\t(1 << (_PDEVB_op_active))\n\nstruct pcifront_device {\n\tstruct xenbus_device *xdev;\n\tstruct list_head root_buses;\n\n\tint evtchn;\n\tgrant_ref_t gnt_ref;\n\n\tint irq;\n\n\t \n\tspinlock_t sh_info_lock;\n\tstruct xen_pci_sharedinfo *sh_info;\n\tstruct work_struct op_work;\n\tunsigned long flags;\n\n};\n\nstruct pcifront_sd {\n\tstruct pci_sysdata sd;\n\tstruct pcifront_device *pdev;\n};\n\nstatic inline struct pcifront_device *\npcifront_get_pdev(struct pcifront_sd *sd)\n{\n\treturn sd->pdev;\n}\n\nstatic inline void pcifront_init_sd(struct pcifront_sd *sd,\n\t\t\t\t    unsigned int domain, unsigned int bus,\n\t\t\t\t    struct pcifront_device *pdev)\n{\n\t \n\tsd->sd.node = first_online_node;\n\tsd->sd.domain = domain;\n\tsd->pdev = pdev;\n}\n\nstatic DEFINE_SPINLOCK(pcifront_dev_lock);\nstatic struct pcifront_device *pcifront_dev;\n\nstatic int errno_to_pcibios_err(int errno)\n{\n\tswitch (errno) {\n\tcase XEN_PCI_ERR_success:\n\t\treturn PCIBIOS_SUCCESSFUL;\n\n\tcase XEN_PCI_ERR_dev_not_found:\n\t\treturn PCIBIOS_DEVICE_NOT_FOUND;\n\n\tcase XEN_PCI_ERR_invalid_offset:\n\tcase XEN_PCI_ERR_op_failed:\n\t\treturn PCIBIOS_BAD_REGISTER_NUMBER;\n\n\tcase XEN_PCI_ERR_not_implemented:\n\t\treturn PCIBIOS_FUNC_NOT_SUPPORTED;\n\n\tcase XEN_PCI_ERR_access_denied:\n\t\treturn PCIBIOS_SET_FAILED;\n\t}\n\treturn errno;\n}\n\nstatic inline void schedule_pcifront_aer_op(struct pcifront_device *pdev)\n{\n\tif (test_bit(_XEN_PCIB_active, (unsigned long *)&pdev->sh_info->flags)\n\t\t&& !test_and_set_bit(_PDEVB_op_active, &pdev->flags)) {\n\t\tdev_dbg(&pdev->xdev->dev, \"schedule aer frontend job\\n\");\n\t\tschedule_work(&pdev->op_work);\n\t}\n}\n\nstatic int do_pci_op(struct pcifront_device *pdev, struct xen_pci_op *op)\n{\n\tint err = 0;\n\tstruct xen_pci_op *active_op = &pdev->sh_info->op;\n\tunsigned long irq_flags;\n\tevtchn_port_t port = pdev->evtchn;\n\tunsigned int irq = pdev->irq;\n\ts64 ns, ns_timeout;\n\n\tspin_lock_irqsave(&pdev->sh_info_lock, irq_flags);\n\n\tmemcpy(active_op, op, sizeof(struct xen_pci_op));\n\n\t \n\twmb();\n\tset_bit(_XEN_PCIF_active, (unsigned long *)&pdev->sh_info->flags);\n\tnotify_remote_via_evtchn(port);\n\n\t \n\tns_timeout = ktime_get_ns() + 2 * (s64)NSEC_PER_SEC;\n\n\txen_clear_irq_pending(irq);\n\n\twhile (test_bit(_XEN_PCIF_active,\n\t\t\t(unsigned long *)&pdev->sh_info->flags)) {\n\t\txen_poll_irq_timeout(irq, jiffies + 3*HZ);\n\t\txen_clear_irq_pending(irq);\n\t\tns = ktime_get_ns();\n\t\tif (ns > ns_timeout) {\n\t\t\tdev_err(&pdev->xdev->dev,\n\t\t\t\t\"pciback not responding!!!\\n\");\n\t\t\tclear_bit(_XEN_PCIF_active,\n\t\t\t\t  (unsigned long *)&pdev->sh_info->flags);\n\t\t\terr = XEN_PCI_ERR_dev_not_found;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tif (test_bit(_XEN_PCIB_active,\n\t\t\t(unsigned long *)&pdev->sh_info->flags)) {\n\t\tdev_err(&pdev->xdev->dev,\n\t\t\t\"schedule aer pcifront service\\n\");\n\t\tschedule_pcifront_aer_op(pdev);\n\t}\n\n\tmemcpy(op, active_op, sizeof(struct xen_pci_op));\n\n\terr = op->err;\nout:\n\tspin_unlock_irqrestore(&pdev->sh_info_lock, irq_flags);\n\treturn err;\n}\n\n \nstatic int pcifront_bus_read(struct pci_bus *bus, unsigned int devfn,\n\t\t\t     int where, int size, u32 *val)\n{\n\tint err = 0;\n\tstruct xen_pci_op op = {\n\t\t.cmd    = XEN_PCI_OP_conf_read,\n\t\t.domain = pci_domain_nr(bus),\n\t\t.bus    = bus->number,\n\t\t.devfn  = devfn,\n\t\t.offset = where,\n\t\t.size   = size,\n\t};\n\tstruct pcifront_sd *sd = bus->sysdata;\n\tstruct pcifront_device *pdev = pcifront_get_pdev(sd);\n\n\tdev_dbg(&pdev->xdev->dev,\n\t\t\"read dev=%04x:%02x:%02x.%d - offset %x size %d\\n\",\n\t\tpci_domain_nr(bus), bus->number, PCI_SLOT(devfn),\n\t\tPCI_FUNC(devfn), where, size);\n\n\terr = do_pci_op(pdev, &op);\n\n\tif (likely(!err)) {\n\t\tdev_dbg(&pdev->xdev->dev, \"read got back value %x\\n\",\n\t\t\top.value);\n\n\t\t*val = op.value;\n\t} else if (err == -ENODEV) {\n\t\t \n\t\terr = 0;\n\t\t*val = 0;\n\t}\n\n\treturn errno_to_pcibios_err(err);\n}\n\n \nstatic int pcifront_bus_write(struct pci_bus *bus, unsigned int devfn,\n\t\t\t      int where, int size, u32 val)\n{\n\tstruct xen_pci_op op = {\n\t\t.cmd    = XEN_PCI_OP_conf_write,\n\t\t.domain = pci_domain_nr(bus),\n\t\t.bus    = bus->number,\n\t\t.devfn  = devfn,\n\t\t.offset = where,\n\t\t.size   = size,\n\t\t.value  = val,\n\t};\n\tstruct pcifront_sd *sd = bus->sysdata;\n\tstruct pcifront_device *pdev = pcifront_get_pdev(sd);\n\n\tdev_dbg(&pdev->xdev->dev,\n\t\t\"write dev=%04x:%02x:%02x.%d - offset %x size %d val %x\\n\",\n\t\tpci_domain_nr(bus), bus->number,\n\t\tPCI_SLOT(devfn), PCI_FUNC(devfn), where, size, val);\n\n\treturn errno_to_pcibios_err(do_pci_op(pdev, &op));\n}\n\nstatic struct pci_ops pcifront_bus_ops = {\n\t.read = pcifront_bus_read,\n\t.write = pcifront_bus_write,\n};\n\n#ifdef CONFIG_PCI_MSI\nstatic int pci_frontend_enable_msix(struct pci_dev *dev,\n\t\t\t\t    int vector[], int nvec)\n{\n\tint err;\n\tint i;\n\tstruct xen_pci_op op = {\n\t\t.cmd    = XEN_PCI_OP_enable_msix,\n\t\t.domain = pci_domain_nr(dev->bus),\n\t\t.bus = dev->bus->number,\n\t\t.devfn = dev->devfn,\n\t\t.value = nvec,\n\t};\n\tstruct pcifront_sd *sd = dev->bus->sysdata;\n\tstruct pcifront_device *pdev = pcifront_get_pdev(sd);\n\tstruct msi_desc *entry;\n\n\tif (nvec > SH_INFO_MAX_VEC) {\n\t\tpci_err(dev, \"too many vectors (0x%x) for PCI frontend:\"\n\t\t\t\t   \" Increase SH_INFO_MAX_VEC\\n\", nvec);\n\t\treturn -EINVAL;\n\t}\n\n\ti = 0;\n\tmsi_for_each_desc(entry, &dev->dev, MSI_DESC_NOTASSOCIATED) {\n\t\top.msix_entries[i].entry = entry->msi_index;\n\t\t \n\t\top.msix_entries[i].vector = -1;\n\t\ti++;\n\t}\n\n\terr = do_pci_op(pdev, &op);\n\n\tif (likely(!err)) {\n\t\tif (likely(!op.value)) {\n\t\t\t \n\t\t\tfor (i = 0; i < nvec; i++) {\n\t\t\t\tif (op.msix_entries[i].vector <= 0) {\n\t\t\t\t\tpci_warn(dev, \"MSI-X entry %d is invalid: %d!\\n\",\n\t\t\t\t\t\ti, op.msix_entries[i].vector);\n\t\t\t\t\terr = -EINVAL;\n\t\t\t\t\tvector[i] = -1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tvector[i] = op.msix_entries[i].vector;\n\t\t\t}\n\t\t} else {\n\t\t\tpr_info(\"enable msix get value %x\\n\", op.value);\n\t\t\terr = op.value;\n\t\t}\n\t} else {\n\t\tpci_err(dev, \"enable msix get err %x\\n\", err);\n\t}\n\treturn err;\n}\n\nstatic void pci_frontend_disable_msix(struct pci_dev *dev)\n{\n\tint err;\n\tstruct xen_pci_op op = {\n\t\t.cmd    = XEN_PCI_OP_disable_msix,\n\t\t.domain = pci_domain_nr(dev->bus),\n\t\t.bus = dev->bus->number,\n\t\t.devfn = dev->devfn,\n\t};\n\tstruct pcifront_sd *sd = dev->bus->sysdata;\n\tstruct pcifront_device *pdev = pcifront_get_pdev(sd);\n\n\terr = do_pci_op(pdev, &op);\n\n\t \n\tif (err)\n\t\tpci_err(dev, \"pci_disable_msix get err %x\\n\", err);\n}\n\nstatic int pci_frontend_enable_msi(struct pci_dev *dev, int vector[])\n{\n\tint err;\n\tstruct xen_pci_op op = {\n\t\t.cmd    = XEN_PCI_OP_enable_msi,\n\t\t.domain = pci_domain_nr(dev->bus),\n\t\t.bus = dev->bus->number,\n\t\t.devfn = dev->devfn,\n\t};\n\tstruct pcifront_sd *sd = dev->bus->sysdata;\n\tstruct pcifront_device *pdev = pcifront_get_pdev(sd);\n\n\terr = do_pci_op(pdev, &op);\n\tif (likely(!err)) {\n\t\tvector[0] = op.value;\n\t\tif (op.value <= 0) {\n\t\t\tpci_warn(dev, \"MSI entry is invalid: %d!\\n\",\n\t\t\t\top.value);\n\t\t\terr = -EINVAL;\n\t\t\tvector[0] = -1;\n\t\t}\n\t} else {\n\t\tpci_err(dev, \"pci frontend enable msi failed for dev \"\n\t\t\t\t    \"%x:%x\\n\", op.bus, op.devfn);\n\t\terr = -EINVAL;\n\t}\n\treturn err;\n}\n\nstatic void pci_frontend_disable_msi(struct pci_dev *dev)\n{\n\tint err;\n\tstruct xen_pci_op op = {\n\t\t.cmd    = XEN_PCI_OP_disable_msi,\n\t\t.domain = pci_domain_nr(dev->bus),\n\t\t.bus = dev->bus->number,\n\t\t.devfn = dev->devfn,\n\t};\n\tstruct pcifront_sd *sd = dev->bus->sysdata;\n\tstruct pcifront_device *pdev = pcifront_get_pdev(sd);\n\n\terr = do_pci_op(pdev, &op);\n\tif (err == XEN_PCI_ERR_dev_not_found) {\n\t\t \n\t\tpr_info(\"get no response from backend for disable MSI\\n\");\n\t\treturn;\n\t}\n\tif (err)\n\t\t \n\t\tpr_info(\"get fake response from backend\\n\");\n}\n\nstatic struct xen_pci_frontend_ops pci_frontend_ops = {\n\t.enable_msi = pci_frontend_enable_msi,\n\t.disable_msi = pci_frontend_disable_msi,\n\t.enable_msix = pci_frontend_enable_msix,\n\t.disable_msix = pci_frontend_disable_msix,\n};\n\nstatic void pci_frontend_registrar(int enable)\n{\n\tif (enable)\n\t\txen_pci_frontend = &pci_frontend_ops;\n\telse\n\t\txen_pci_frontend = NULL;\n};\n#else\nstatic inline void pci_frontend_registrar(int enable) { };\n#endif  \n\n \nstatic int pcifront_claim_resource(struct pci_dev *dev, void *data)\n{\n\tstruct pcifront_device *pdev = data;\n\tint i;\n\tstruct resource *r;\n\n\tpci_dev_for_each_resource(dev, r, i) {\n\t\tif (!r->parent && r->start && r->flags) {\n\t\t\tdev_info(&pdev->xdev->dev, \"claiming resource %s/%d\\n\",\n\t\t\t\tpci_name(dev), i);\n\t\t\tif (pci_claim_resource(dev, i)) {\n\t\t\t\tdev_err(&pdev->xdev->dev, \"Could not claim resource %s/%d! \"\n\t\t\t\t\t\"Device offline. Try using e820_host=1 in the guest config.\\n\",\n\t\t\t\t\tpci_name(dev), i);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int pcifront_scan_bus(struct pcifront_device *pdev,\n\t\t\t\tunsigned int domain, unsigned int bus,\n\t\t\t\tstruct pci_bus *b)\n{\n\tstruct pci_dev *d;\n\tunsigned int devfn;\n\n\t \n\tfor (devfn = 0; devfn < 0x100; devfn++) {\n\t\td = pci_get_slot(b, devfn);\n\t\tif (d) {\n\t\t\t \n\t\t\tpci_dev_put(d);\n\t\t\tcontinue;\n\t\t}\n\n\t\td = pci_scan_single_device(b, devfn);\n\t\tif (d)\n\t\t\tdev_info(&pdev->xdev->dev, \"New device on \"\n\t\t\t\t \"%04x:%02x:%02x.%d found.\\n\", domain, bus,\n\t\t\t\t PCI_SLOT(devfn), PCI_FUNC(devfn));\n\t}\n\n\treturn 0;\n}\n\nstatic int pcifront_scan_root(struct pcifront_device *pdev,\n\t\t\t\t unsigned int domain, unsigned int bus)\n{\n\tstruct pci_bus *b;\n\tLIST_HEAD(resources);\n\tstruct pcifront_sd *sd = NULL;\n\tstruct pci_bus_entry *bus_entry = NULL;\n\tint err = 0;\n\tstatic struct resource busn_res = {\n\t\t.start = 0,\n\t\t.end = 255,\n\t\t.flags = IORESOURCE_BUS,\n\t};\n\n#ifndef CONFIG_PCI_DOMAINS\n\tif (domain != 0) {\n\t\tdev_err(&pdev->xdev->dev,\n\t\t\t\"PCI Root in non-zero PCI Domain! domain=%d\\n\", domain);\n\t\tdev_err(&pdev->xdev->dev,\n\t\t\t\"Please compile with CONFIG_PCI_DOMAINS\\n\");\n\t\terr = -EINVAL;\n\t\tgoto err_out;\n\t}\n#endif\n\n\tdev_info(&pdev->xdev->dev, \"Creating PCI Frontend Bus %04x:%02x\\n\",\n\t\t domain, bus);\n\n\tbus_entry = kzalloc(sizeof(*bus_entry), GFP_KERNEL);\n\tsd = kzalloc(sizeof(*sd), GFP_KERNEL);\n\tif (!bus_entry || !sd) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\tpci_add_resource(&resources, &ioport_resource);\n\tpci_add_resource(&resources, &iomem_resource);\n\tpci_add_resource(&resources, &busn_res);\n\tpcifront_init_sd(sd, domain, bus, pdev);\n\n\tpci_lock_rescan_remove();\n\n\tb = pci_scan_root_bus(&pdev->xdev->dev, bus,\n\t\t\t\t  &pcifront_bus_ops, sd, &resources);\n\tif (!b) {\n\t\tdev_err(&pdev->xdev->dev,\n\t\t\t\"Error creating PCI Frontend Bus!\\n\");\n\t\terr = -ENOMEM;\n\t\tpci_unlock_rescan_remove();\n\t\tpci_free_resource_list(&resources);\n\t\tgoto err_out;\n\t}\n\n\tbus_entry->bus = b;\n\n\tlist_add(&bus_entry->list, &pdev->root_buses);\n\n\t \n\terr = pcifront_scan_bus(pdev, domain, bus, b);\n\n\t \n\tpci_walk_bus(b, pcifront_claim_resource, pdev);\n\n\t \n\tpci_bus_add_devices(b);\n\n\tpci_unlock_rescan_remove();\n\treturn err;\n\nerr_out:\n\tkfree(bus_entry);\n\tkfree(sd);\n\n\treturn err;\n}\n\nstatic int pcifront_rescan_root(struct pcifront_device *pdev,\n\t\t\t\t   unsigned int domain, unsigned int bus)\n{\n\tint err;\n\tstruct pci_bus *b;\n\n\tb = pci_find_bus(domain, bus);\n\tif (!b)\n\t\t \n\t\treturn pcifront_scan_root(pdev, domain, bus);\n\n\tdev_info(&pdev->xdev->dev, \"Rescanning PCI Frontend Bus %04x:%02x\\n\",\n\t\t domain, bus);\n\n\terr = pcifront_scan_bus(pdev, domain, bus, b);\n\n\t \n\tpci_walk_bus(b, pcifront_claim_resource, pdev);\n\n\t \n\tpci_bus_add_devices(b);\n\n\treturn err;\n}\n\nstatic void free_root_bus_devs(struct pci_bus *bus)\n{\n\tstruct pci_dev *dev;\n\n\twhile (!list_empty(&bus->devices)) {\n\t\tdev = container_of(bus->devices.next, struct pci_dev,\n\t\t\t\t   bus_list);\n\t\tpci_dbg(dev, \"removing device\\n\");\n\t\tpci_stop_and_remove_bus_device(dev);\n\t}\n}\n\nstatic void pcifront_free_roots(struct pcifront_device *pdev)\n{\n\tstruct pci_bus_entry *bus_entry, *t;\n\n\tdev_dbg(&pdev->xdev->dev, \"cleaning up root buses\\n\");\n\n\tpci_lock_rescan_remove();\n\tlist_for_each_entry_safe(bus_entry, t, &pdev->root_buses, list) {\n\t\tlist_del(&bus_entry->list);\n\n\t\tfree_root_bus_devs(bus_entry->bus);\n\n\t\tkfree(bus_entry->bus->sysdata);\n\n\t\tdevice_unregister(bus_entry->bus->bridge);\n\t\tpci_remove_bus(bus_entry->bus);\n\n\t\tkfree(bus_entry);\n\t}\n\tpci_unlock_rescan_remove();\n}\n\nstatic pci_ers_result_t pcifront_common_process(int cmd,\n\t\t\t\t\t\tstruct pcifront_device *pdev,\n\t\t\t\t\t\tpci_channel_state_t state)\n{\n\tstruct pci_driver *pdrv;\n\tint bus = pdev->sh_info->aer_op.bus;\n\tint devfn = pdev->sh_info->aer_op.devfn;\n\tint domain = pdev->sh_info->aer_op.domain;\n\tstruct pci_dev *pcidev;\n\n\tdev_dbg(&pdev->xdev->dev,\n\t\t\"pcifront AER process: cmd %x (bus:%x, devfn%x)\",\n\t\tcmd, bus, devfn);\n\n\tpcidev = pci_get_domain_bus_and_slot(domain, bus, devfn);\n\tif (!pcidev || !pcidev->dev.driver) {\n\t\tdev_err(&pdev->xdev->dev, \"device or AER driver is NULL\\n\");\n\t\tpci_dev_put(pcidev);\n\t\treturn PCI_ERS_RESULT_NONE;\n\t}\n\tpdrv = to_pci_driver(pcidev->dev.driver);\n\n\tif (pdrv->err_handler && pdrv->err_handler->error_detected) {\n\t\tpci_dbg(pcidev, \"trying to call AER service\\n\");\n\t\tswitch (cmd) {\n\t\tcase XEN_PCI_OP_aer_detected:\n\t\t\treturn pdrv->err_handler->error_detected(pcidev, state);\n\t\tcase XEN_PCI_OP_aer_mmio:\n\t\t\treturn pdrv->err_handler->mmio_enabled(pcidev);\n\t\tcase XEN_PCI_OP_aer_slotreset:\n\t\t\treturn pdrv->err_handler->slot_reset(pcidev);\n\t\tcase XEN_PCI_OP_aer_resume:\n\t\t\tpdrv->err_handler->resume(pcidev);\n\t\t\treturn PCI_ERS_RESULT_NONE;\n\t\tdefault:\n\t\t\tdev_err(&pdev->xdev->dev,\n\t\t\t\t\"bad request in aer recovery operation!\\n\");\n\t\t}\n\t}\n\n\treturn PCI_ERS_RESULT_NONE;\n}\n\n\nstatic void pcifront_do_aer(struct work_struct *data)\n{\n\tstruct pcifront_device *pdev =\n\t\tcontainer_of(data, struct pcifront_device, op_work);\n\tint cmd = pdev->sh_info->aer_op.cmd;\n\tpci_channel_state_t state =\n\t\t(pci_channel_state_t)pdev->sh_info->aer_op.err;\n\n\t \n\tdev_dbg(&pdev->xdev->dev,\n\t\t\"pcifront service aer bus %x devfn %x\\n\",\n\t\tpdev->sh_info->aer_op.bus, pdev->sh_info->aer_op.devfn);\n\n\tpdev->sh_info->aer_op.err = pcifront_common_process(cmd, pdev, state);\n\n\t \n\twmb();\n\tclear_bit(_XEN_PCIB_active, (unsigned long *)&pdev->sh_info->flags);\n\tnotify_remote_via_evtchn(pdev->evtchn);\n\n\t \n\tsmp_mb__before_atomic();\n\tclear_bit(_PDEVB_op_active, &pdev->flags);\n\tsmp_mb__after_atomic();\n\n\tschedule_pcifront_aer_op(pdev);\n\n}\n\nstatic irqreturn_t pcifront_handler_aer(int irq, void *dev)\n{\n\tstruct pcifront_device *pdev = dev;\n\n\tschedule_pcifront_aer_op(pdev);\n\treturn IRQ_HANDLED;\n}\nstatic int pcifront_connect_and_init_dma(struct pcifront_device *pdev)\n{\n\tint err = 0;\n\n\tspin_lock(&pcifront_dev_lock);\n\n\tif (!pcifront_dev) {\n\t\tdev_info(&pdev->xdev->dev, \"Installing PCI frontend\\n\");\n\t\tpcifront_dev = pdev;\n\t} else\n\t\terr = -EEXIST;\n\n\tspin_unlock(&pcifront_dev_lock);\n\n\treturn err;\n}\n\nstatic void pcifront_disconnect(struct pcifront_device *pdev)\n{\n\tspin_lock(&pcifront_dev_lock);\n\n\tif (pdev == pcifront_dev) {\n\t\tdev_info(&pdev->xdev->dev,\n\t\t\t \"Disconnecting PCI Frontend Buses\\n\");\n\t\tpcifront_dev = NULL;\n\t}\n\n\tspin_unlock(&pcifront_dev_lock);\n}\nstatic struct pcifront_device *alloc_pdev(struct xenbus_device *xdev)\n{\n\tstruct pcifront_device *pdev;\n\n\tpdev = kzalloc(sizeof(struct pcifront_device), GFP_KERNEL);\n\tif (pdev == NULL)\n\t\tgoto out;\n\n\tif (xenbus_setup_ring(xdev, GFP_KERNEL, (void **)&pdev->sh_info, 1,\n\t\t\t      &pdev->gnt_ref)) {\n\t\tkfree(pdev);\n\t\tpdev = NULL;\n\t\tgoto out;\n\t}\n\tpdev->sh_info->flags = 0;\n\n\t \n\tset_bit(_XEN_PCIB_AERHANDLER, (void *)&pdev->sh_info->flags);\n\n\tdev_set_drvdata(&xdev->dev, pdev);\n\tpdev->xdev = xdev;\n\n\tINIT_LIST_HEAD(&pdev->root_buses);\n\n\tspin_lock_init(&pdev->sh_info_lock);\n\n\tpdev->evtchn = INVALID_EVTCHN;\n\tpdev->irq = -1;\n\n\tINIT_WORK(&pdev->op_work, pcifront_do_aer);\n\n\tdev_dbg(&xdev->dev, \"Allocated pdev @ 0x%p pdev->sh_info @ 0x%p\\n\",\n\t\tpdev, pdev->sh_info);\nout:\n\treturn pdev;\n}\n\nstatic void free_pdev(struct pcifront_device *pdev)\n{\n\tdev_dbg(&pdev->xdev->dev, \"freeing pdev @ 0x%p\\n\", pdev);\n\n\tpcifront_free_roots(pdev);\n\n\tcancel_work_sync(&pdev->op_work);\n\n\tif (pdev->irq >= 0)\n\t\tunbind_from_irqhandler(pdev->irq, pdev);\n\n\tif (pdev->evtchn != INVALID_EVTCHN)\n\t\txenbus_free_evtchn(pdev->xdev, pdev->evtchn);\n\n\txenbus_teardown_ring((void **)&pdev->sh_info, 1, &pdev->gnt_ref);\n\n\tdev_set_drvdata(&pdev->xdev->dev, NULL);\n\n\tkfree(pdev);\n}\n\nstatic int pcifront_publish_info(struct pcifront_device *pdev)\n{\n\tint err = 0;\n\tstruct xenbus_transaction trans;\n\n\terr = xenbus_alloc_evtchn(pdev->xdev, &pdev->evtchn);\n\tif (err)\n\t\tgoto out;\n\n\terr = bind_evtchn_to_irqhandler(pdev->evtchn, pcifront_handler_aer,\n\t\t0, \"pcifront\", pdev);\n\n\tif (err < 0)\n\t\treturn err;\n\n\tpdev->irq = err;\n\ndo_publish:\n\terr = xenbus_transaction_start(&trans);\n\tif (err) {\n\t\txenbus_dev_fatal(pdev->xdev, err,\n\t\t\t\t \"Error writing configuration for backend \"\n\t\t\t\t \"(start transaction)\");\n\t\tgoto out;\n\t}\n\n\terr = xenbus_printf(trans, pdev->xdev->nodename,\n\t\t\t    \"pci-op-ref\", \"%u\", pdev->gnt_ref);\n\tif (!err)\n\t\terr = xenbus_printf(trans, pdev->xdev->nodename,\n\t\t\t\t    \"event-channel\", \"%u\", pdev->evtchn);\n\tif (!err)\n\t\terr = xenbus_printf(trans, pdev->xdev->nodename,\n\t\t\t\t    \"magic\", XEN_PCI_MAGIC);\n\n\tif (err) {\n\t\txenbus_transaction_end(trans, 1);\n\t\txenbus_dev_fatal(pdev->xdev, err,\n\t\t\t\t \"Error writing configuration for backend\");\n\t\tgoto out;\n\t} else {\n\t\terr = xenbus_transaction_end(trans, 0);\n\t\tif (err == -EAGAIN)\n\t\t\tgoto do_publish;\n\t\telse if (err) {\n\t\t\txenbus_dev_fatal(pdev->xdev, err,\n\t\t\t\t\t \"Error completing transaction \"\n\t\t\t\t\t \"for backend\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\txenbus_switch_state(pdev->xdev, XenbusStateInitialised);\n\n\tdev_dbg(&pdev->xdev->dev, \"publishing successful!\\n\");\n\nout:\n\treturn err;\n}\n\nstatic void pcifront_connect(struct pcifront_device *pdev)\n{\n\tint err;\n\tint i, num_roots, len;\n\tchar str[64];\n\tunsigned int domain, bus;\n\n\terr = xenbus_scanf(XBT_NIL, pdev->xdev->otherend,\n\t\t\t   \"root_num\", \"%d\", &num_roots);\n\tif (err == -ENOENT) {\n\t\txenbus_dev_error(pdev->xdev, err,\n\t\t\t\t \"No PCI Roots found, trying 0000:00\");\n\t\terr = pcifront_rescan_root(pdev, 0, 0);\n\t\tif (err) {\n\t\t\txenbus_dev_fatal(pdev->xdev, err,\n\t\t\t\t\t \"Error scanning PCI root 0000:00\");\n\t\t\treturn;\n\t\t}\n\t\tnum_roots = 0;\n\t} else if (err != 1) {\n\t\txenbus_dev_fatal(pdev->xdev, err >= 0 ? -EINVAL : err,\n\t\t\t\t \"Error reading number of PCI roots\");\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < num_roots; i++) {\n\t\tlen = snprintf(str, sizeof(str), \"root-%d\", i);\n\t\tif (unlikely(len >= (sizeof(str) - 1)))\n\t\t\treturn;\n\n\t\terr = xenbus_scanf(XBT_NIL, pdev->xdev->otherend, str,\n\t\t\t\t   \"%x:%x\", &domain, &bus);\n\t\tif (err != 2) {\n\t\t\txenbus_dev_fatal(pdev->xdev, err >= 0 ? -EINVAL : err,\n\t\t\t\t\t \"Error reading PCI root %d\", i);\n\t\t\treturn;\n\t\t}\n\n\t\terr = pcifront_rescan_root(pdev, domain, bus);\n\t\tif (err) {\n\t\t\txenbus_dev_fatal(pdev->xdev, err,\n\t\t\t\t\t \"Error scanning PCI root %04x:%02x\",\n\t\t\t\t\t domain, bus);\n\t\t\treturn;\n\t\t}\n\t}\n\n\txenbus_switch_state(pdev->xdev, XenbusStateConnected);\n}\n\nstatic void pcifront_try_connect(struct pcifront_device *pdev)\n{\n\tint err;\n\n\t \n\tif (xenbus_read_driver_state(pdev->xdev->nodename) !=\n\t    XenbusStateInitialised)\n\t\treturn;\n\n\terr = pcifront_connect_and_init_dma(pdev);\n\tif (err && err != -EEXIST) {\n\t\txenbus_dev_fatal(pdev->xdev, err,\n\t\t\t\t \"Error setting up PCI Frontend\");\n\t\treturn;\n\t}\n\n\tpcifront_connect(pdev);\n}\n\nstatic int pcifront_try_disconnect(struct pcifront_device *pdev)\n{\n\tint err = 0;\n\tenum xenbus_state prev_state;\n\n\n\tprev_state = xenbus_read_driver_state(pdev->xdev->nodename);\n\n\tif (prev_state >= XenbusStateClosing)\n\t\tgoto out;\n\n\tif (prev_state == XenbusStateConnected) {\n\t\tpcifront_free_roots(pdev);\n\t\tpcifront_disconnect(pdev);\n\t}\n\n\terr = xenbus_switch_state(pdev->xdev, XenbusStateClosed);\n\nout:\n\n\treturn err;\n}\n\nstatic void pcifront_attach_devices(struct pcifront_device *pdev)\n{\n\tif (xenbus_read_driver_state(pdev->xdev->nodename) ==\n\t    XenbusStateReconfiguring)\n\t\tpcifront_connect(pdev);\n}\n\nstatic int pcifront_detach_devices(struct pcifront_device *pdev)\n{\n\tint err = 0;\n\tint i, num_devs;\n\tenum xenbus_state state;\n\tunsigned int domain, bus, slot, func;\n\tstruct pci_dev *pci_dev;\n\tchar str[64];\n\n\tstate = xenbus_read_driver_state(pdev->xdev->nodename);\n\tif (state == XenbusStateInitialised) {\n\t\tdev_dbg(&pdev->xdev->dev, \"Handle skipped connect.\\n\");\n\t\t \n\t\terr = pcifront_connect_and_init_dma(pdev);\n\t\tif (err && err != -EEXIST) {\n\t\t\txenbus_dev_fatal(pdev->xdev, err,\n\t\t\t\t\t \"Error setting up PCI Frontend\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tgoto out_switch_state;\n\t} else if (state != XenbusStateConnected) {\n\t\tgoto out;\n\t}\n\n\terr = xenbus_scanf(XBT_NIL, pdev->xdev->otherend, \"num_devs\", \"%d\",\n\t\t\t   &num_devs);\n\tif (err != 1) {\n\t\tif (err >= 0)\n\t\t\terr = -EINVAL;\n\t\txenbus_dev_fatal(pdev->xdev, err,\n\t\t\t\t \"Error reading number of PCI devices\");\n\t\tgoto out;\n\t}\n\n\t \n\tfor (i = 0; i < num_devs; i++) {\n\t\tint l, state;\n\n\t\tl = snprintf(str, sizeof(str), \"state-%d\", i);\n\t\tif (unlikely(l >= (sizeof(str) - 1))) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tstate = xenbus_read_unsigned(pdev->xdev->otherend, str,\n\t\t\t\t\t     XenbusStateUnknown);\n\n\t\tif (state != XenbusStateClosing)\n\t\t\tcontinue;\n\n\t\t \n\t\tl = snprintf(str, sizeof(str), \"vdev-%d\", i);\n\t\tif (unlikely(l >= (sizeof(str) - 1))) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\terr = xenbus_scanf(XBT_NIL, pdev->xdev->otherend, str,\n\t\t\t\t   \"%x:%x:%x.%x\", &domain, &bus, &slot, &func);\n\t\tif (err != 4) {\n\t\t\tif (err >= 0)\n\t\t\t\terr = -EINVAL;\n\t\t\txenbus_dev_fatal(pdev->xdev, err,\n\t\t\t\t\t \"Error reading PCI device %d\", i);\n\t\t\tgoto out;\n\t\t}\n\n\t\tpci_dev = pci_get_domain_bus_and_slot(domain, bus,\n\t\t\t\tPCI_DEVFN(slot, func));\n\t\tif (!pci_dev) {\n\t\t\tdev_dbg(&pdev->xdev->dev,\n\t\t\t\t\"Cannot get PCI device %04x:%02x:%02x.%d\\n\",\n\t\t\t\tdomain, bus, slot, func);\n\t\t\tcontinue;\n\t\t}\n\t\tpci_lock_rescan_remove();\n\t\tpci_stop_and_remove_bus_device(pci_dev);\n\t\tpci_dev_put(pci_dev);\n\t\tpci_unlock_rescan_remove();\n\n\t\tdev_dbg(&pdev->xdev->dev,\n\t\t\t\"PCI device %04x:%02x:%02x.%d removed.\\n\",\n\t\t\tdomain, bus, slot, func);\n\t}\n\n out_switch_state:\n\terr = xenbus_switch_state(pdev->xdev, XenbusStateReconfiguring);\n\nout:\n\treturn err;\n}\n\nstatic void pcifront_backend_changed(struct xenbus_device *xdev,\n\t\t\t\t\t\t  enum xenbus_state be_state)\n{\n\tstruct pcifront_device *pdev = dev_get_drvdata(&xdev->dev);\n\n\tswitch (be_state) {\n\tcase XenbusStateUnknown:\n\tcase XenbusStateInitialising:\n\tcase XenbusStateInitWait:\n\tcase XenbusStateInitialised:\n\t\tbreak;\n\n\tcase XenbusStateConnected:\n\t\tpcifront_try_connect(pdev);\n\t\tbreak;\n\n\tcase XenbusStateClosed:\n\t\tif (xdev->state == XenbusStateClosed)\n\t\t\tbreak;\n\t\tfallthrough;\t \n\tcase XenbusStateClosing:\n\t\tdev_warn(&xdev->dev, \"backend going away!\\n\");\n\t\tpcifront_try_disconnect(pdev);\n\t\tbreak;\n\n\tcase XenbusStateReconfiguring:\n\t\tpcifront_detach_devices(pdev);\n\t\tbreak;\n\n\tcase XenbusStateReconfigured:\n\t\tpcifront_attach_devices(pdev);\n\t\tbreak;\n\t}\n}\n\nstatic int pcifront_xenbus_probe(struct xenbus_device *xdev,\n\t\t\t\t const struct xenbus_device_id *id)\n{\n\tint err = 0;\n\tstruct pcifront_device *pdev = alloc_pdev(xdev);\n\n\tif (pdev == NULL) {\n\t\terr = -ENOMEM;\n\t\txenbus_dev_fatal(xdev, err,\n\t\t\t\t \"Error allocating pcifront_device struct\");\n\t\tgoto out;\n\t}\n\n\terr = pcifront_publish_info(pdev);\n\tif (err)\n\t\tfree_pdev(pdev);\n\nout:\n\treturn err;\n}\n\nstatic void pcifront_xenbus_remove(struct xenbus_device *xdev)\n{\n\tstruct pcifront_device *pdev = dev_get_drvdata(&xdev->dev);\n\n\tif (pdev)\n\t\tfree_pdev(pdev);\n}\n\nstatic const struct xenbus_device_id xenpci_ids[] = {\n\t{\"pci\"},\n\t{\"\"},\n};\n\nstatic struct xenbus_driver xenpci_driver = {\n\t.name\t\t\t= \"pcifront\",\n\t.ids\t\t\t= xenpci_ids,\n\t.probe\t\t\t= pcifront_xenbus_probe,\n\t.remove\t\t\t= pcifront_xenbus_remove,\n\t.otherend_changed\t= pcifront_backend_changed,\n};\n\nstatic int __init pcifront_init(void)\n{\n\tif (!xen_pv_domain() || xen_initial_domain())\n\t\treturn -ENODEV;\n\n\tif (!xen_has_pv_devices())\n\t\treturn -ENODEV;\n\n\tpci_frontend_registrar(1  );\n\n\treturn xenbus_register_frontend(&xenpci_driver);\n}\n\nstatic void __exit pcifront_cleanup(void)\n{\n\txenbus_unregister_driver(&xenpci_driver);\n\tpci_frontend_registrar(0  );\n}\nmodule_init(pcifront_init);\nmodule_exit(pcifront_cleanup);\n\nMODULE_DESCRIPTION(\"Xen PCI passthrough frontend.\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"xen:pci\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}