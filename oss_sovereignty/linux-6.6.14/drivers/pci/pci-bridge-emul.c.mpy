{
  "module_name": "pci-bridge-emul.c",
  "hash_id": "c6315d8b4d2aa4a5ef42930f651d14dec94c093b8b80b9338a0c3519f19f9300",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/pci-bridge-emul.c",
  "human_readable_source": "\n \n\n#include <linux/pci.h>\n#include \"pci-bridge-emul.h\"\n\n#define PCI_BRIDGE_CONF_END\tPCI_STD_HEADER_SIZEOF\n#define PCI_CAP_SSID_SIZEOF\t(PCI_SSVID_DEVICE_ID + 2)\n#define PCI_CAP_PCIE_SIZEOF\t(PCI_EXP_SLTSTA2 + 2)\n\n \nstruct pci_bridge_reg_behavior {\n\t \n\tu32 ro;\n\n\t \n\tu32 rw;\n\n\t \n\tu32 w1c;\n};\n\nstatic const\nstruct pci_bridge_reg_behavior pci_regs_behavior[PCI_STD_HEADER_SIZEOF / 4] = {\n\t[PCI_VENDOR_ID / 4] = { .ro = ~0 },\n\t[PCI_COMMAND / 4] = {\n\t\t.rw = (PCI_COMMAND_IO | PCI_COMMAND_MEMORY |\n\t\t       PCI_COMMAND_MASTER | PCI_COMMAND_PARITY |\n\t\t       PCI_COMMAND_SERR),\n\t\t.ro = ((PCI_COMMAND_SPECIAL | PCI_COMMAND_INVALIDATE |\n\t\t\tPCI_COMMAND_VGA_PALETTE | PCI_COMMAND_WAIT |\n\t\t\tPCI_COMMAND_FAST_BACK) |\n\t\t       (PCI_STATUS_CAP_LIST | PCI_STATUS_66MHZ |\n\t\t\tPCI_STATUS_FAST_BACK | PCI_STATUS_DEVSEL_MASK) << 16),\n\t\t.w1c = PCI_STATUS_ERROR_BITS << 16,\n\t},\n\t[PCI_CLASS_REVISION / 4] = { .ro = ~0 },\n\n\t \n\t[PCI_CACHE_LINE_SIZE / 4] = { .ro = ~0 },\n\n\t \n\t[PCI_BASE_ADDRESS_0 / 4] = { .ro = ~0 },\n\t[PCI_BASE_ADDRESS_1 / 4] = { .ro = ~0 },\n\n\t[PCI_PRIMARY_BUS / 4] = {\n\t\t \n\t\t.rw = GENMASK(24, 0),\n\t\t \n\t\t.ro = GENMASK(31, 24),\n\t},\n\n\t[PCI_IO_BASE / 4] = {\n\t\t \n\t\t.rw = (GENMASK(15, 12) | GENMASK(7, 4)),\n\n\t\t \n\t\t.ro = (((PCI_STATUS_66MHZ | PCI_STATUS_FAST_BACK |\n\t\t\t PCI_STATUS_DEVSEL_MASK) << 16) |\n\t\t       GENMASK(11, 8) | GENMASK(3, 0)),\n\n\t\t.w1c = PCI_STATUS_ERROR_BITS << 16,\n\t},\n\n\t[PCI_MEMORY_BASE / 4] = {\n\t\t \n\t\t.rw = GENMASK(31, 20) | GENMASK(15, 4),\n\n\t\t \n\t\t.ro = GENMASK(19, 16) | GENMASK(3, 0),\n\t},\n\n\t[PCI_PREF_MEMORY_BASE / 4] = {\n\t\t \n\t\t.rw = GENMASK(31, 20) | GENMASK(15, 4),\n\n\t\t \n\t\t.ro = GENMASK(19, 16) | GENMASK(3, 0),\n\t},\n\n\t[PCI_PREF_BASE_UPPER32 / 4] = {\n\t\t.rw = ~0,\n\t},\n\n\t[PCI_PREF_LIMIT_UPPER32 / 4] = {\n\t\t.rw = ~0,\n\t},\n\n\t[PCI_IO_BASE_UPPER16 / 4] = {\n\t\t.rw = ~0,\n\t},\n\n\t[PCI_CAPABILITY_LIST / 4] = {\n\t\t.ro = GENMASK(7, 0),\n\t},\n\n\t \n\t[PCI_ROM_ADDRESS1 / 4] = {\n\t\t.ro = ~0,\n\t},\n\n\t \n\t[PCI_INTERRUPT_LINE / 4] = {\n\t\t \n\t\t.rw = (GENMASK(7, 0) |\n\t\t       ((PCI_BRIDGE_CTL_PARITY |\n\t\t\t PCI_BRIDGE_CTL_SERR |\n\t\t\t PCI_BRIDGE_CTL_ISA |\n\t\t\t PCI_BRIDGE_CTL_VGA |\n\t\t\t PCI_BRIDGE_CTL_MASTER_ABORT |\n\t\t\t PCI_BRIDGE_CTL_BUS_RESET |\n\t\t\t BIT(8) | BIT(9) | BIT(11)) << 16)),\n\n\t\t \n\t\t.ro = (GENMASK(15, 8) | ((PCI_BRIDGE_CTL_FAST_BACK) << 16)),\n\n\t\t.w1c = BIT(10) << 16,\n\t},\n};\n\nstatic const\nstruct pci_bridge_reg_behavior pcie_cap_regs_behavior[PCI_CAP_PCIE_SIZEOF / 4] = {\n\t[PCI_CAP_LIST_ID / 4] = {\n\t\t \n\t\t.ro = GENMASK(30, 0),\n\t},\n\n\t[PCI_EXP_DEVCAP / 4] = {\n\t\t \n\t\t.ro = BIT(15) | GENMASK(5, 0),\n\t},\n\n\t[PCI_EXP_DEVCTL / 4] = {\n\t\t \n\t\t.rw = GENMASK(14, 0),\n\n\t\t \n\t\t.w1c = GENMASK(3, 0) << 16,\n\t\t.ro = GENMASK(5, 4) << 16,\n\t},\n\n\t[PCI_EXP_LNKCAP / 4] = {\n\t\t \n\t\t.ro = lower_32_bits(~(BIT(23) | PCI_EXP_LNKCAP_CLKPM)),\n\t},\n\n\t[PCI_EXP_LNKCTL / 4] = {\n\t\t \n\t\t.rw = GENMASK(15, 14) | GENMASK(11, 9) | GENMASK(7, 3) | GENMASK(1, 0),\n\t\t.ro = GENMASK(13, 0) << 16,\n\t\t.w1c = GENMASK(15, 14) << 16,\n\t},\n\n\t[PCI_EXP_SLTCAP / 4] = {\n\t\t.ro = ~0,\n\t},\n\n\t[PCI_EXP_SLTCTL / 4] = {\n\t\t \n\t\t.rw = GENMASK(14, 0),\n\t\t.w1c = (PCI_EXP_SLTSTA_ABP | PCI_EXP_SLTSTA_PFD |\n\t\t\tPCI_EXP_SLTSTA_MRLSC | PCI_EXP_SLTSTA_PDC |\n\t\t\tPCI_EXP_SLTSTA_CC | PCI_EXP_SLTSTA_DLLSC) << 16,\n\t\t.ro = (PCI_EXP_SLTSTA_MRLSS | PCI_EXP_SLTSTA_PDS |\n\t\t       PCI_EXP_SLTSTA_EIS) << 16,\n\t},\n\n\t[PCI_EXP_RTCTL / 4] = {\n\t\t \n\t\t.rw = (PCI_EXP_RTCTL_SECEE | PCI_EXP_RTCTL_SENFEE |\n\t\t       PCI_EXP_RTCTL_SEFEE | PCI_EXP_RTCTL_PMEIE |\n\t\t       PCI_EXP_RTCTL_CRSSVE),\n\t\t.ro = PCI_EXP_RTCAP_CRSVIS << 16,\n\t},\n\n\t[PCI_EXP_RTSTA / 4] = {\n\t\t \n\t\t.ro = GENMASK(15, 0) | PCI_EXP_RTSTA_PENDING,\n\t\t.w1c = PCI_EXP_RTSTA_PME,\n\t},\n\n\t[PCI_EXP_DEVCAP2 / 4] = {\n\t\t \n\t\t.ro = BIT(31) | GENMASK(23, 0),\n\t},\n\n\t[PCI_EXP_DEVCTL2 / 4] = {\n\t\t \n\t\t.rw = GENMASK(15, 12) | GENMASK(10, 0),\n\t},\n\n\t[PCI_EXP_LNKCAP2 / 4] = {\n\t\t \n\t\t.ro = BIT(31) | GENMASK(24, 1),\n\t},\n\n\t[PCI_EXP_LNKCTL2 / 4] = {\n\t\t \n\t\t.rw = GENMASK(15, 0),\n\t\t.w1c = (BIT(15) | BIT(5)) << 16,\n\t\t.ro = (GENMASK(14, 12) | GENMASK(9, 6) | GENMASK(4, 0)) << 16,\n\t},\n\n\t[PCI_EXP_SLTCAP2 / 4] = {\n\t\t \n\t},\n\n\t[PCI_EXP_SLTCTL2 / 4] = {\n\t\t \n\t},\n};\n\nstatic pci_bridge_emul_read_status_t\npci_bridge_emul_read_ssid(struct pci_bridge_emul *bridge, int reg, u32 *value)\n{\n\tswitch (reg) {\n\tcase PCI_CAP_LIST_ID:\n\t\t*value = PCI_CAP_ID_SSVID |\n\t\t\t((bridge->pcie_start > bridge->ssid_start) ? (bridge->pcie_start << 8) : 0);\n\t\treturn PCI_BRIDGE_EMUL_HANDLED;\n\n\tcase PCI_SSVID_VENDOR_ID:\n\t\t*value = bridge->subsystem_vendor_id |\n\t\t\t(bridge->subsystem_id << 16);\n\t\treturn PCI_BRIDGE_EMUL_HANDLED;\n\n\tdefault:\n\t\treturn PCI_BRIDGE_EMUL_NOT_HANDLED;\n\t}\n}\n\n \nint pci_bridge_emul_init(struct pci_bridge_emul *bridge,\n\t\t\t unsigned int flags)\n{\n\tBUILD_BUG_ON(sizeof(bridge->conf) != PCI_BRIDGE_CONF_END);\n\n\t \n\tbridge->conf.class_revision |=\n\t\tcpu_to_le32(PCI_CLASS_BRIDGE_PCI_NORMAL << 8);\n\tbridge->conf.header_type = PCI_HEADER_TYPE_BRIDGE;\n\tbridge->conf.cache_line_size = 0x10;\n\tbridge->conf.status = cpu_to_le16(PCI_STATUS_CAP_LIST);\n\tbridge->pci_regs_behavior = kmemdup(pci_regs_behavior,\n\t\t\t\t\t    sizeof(pci_regs_behavior),\n\t\t\t\t\t    GFP_KERNEL);\n\tif (!bridge->pci_regs_behavior)\n\t\treturn -ENOMEM;\n\n\t \n\tif (!bridge->ssid_start && !bridge->pcie_start) {\n\t\tif (bridge->subsystem_vendor_id)\n\t\t\tbridge->ssid_start = PCI_BRIDGE_CONF_END;\n\t\tif (bridge->has_pcie)\n\t\t\tbridge->pcie_start = bridge->ssid_start + PCI_CAP_SSID_SIZEOF;\n\t} else if (!bridge->ssid_start && bridge->subsystem_vendor_id) {\n\t\tif (bridge->pcie_start - PCI_BRIDGE_CONF_END >= PCI_CAP_SSID_SIZEOF)\n\t\t\tbridge->ssid_start = PCI_BRIDGE_CONF_END;\n\t\telse\n\t\t\tbridge->ssid_start = bridge->pcie_start + PCI_CAP_PCIE_SIZEOF;\n\t} else if (!bridge->pcie_start && bridge->has_pcie) {\n\t\tif (bridge->ssid_start - PCI_BRIDGE_CONF_END >= PCI_CAP_PCIE_SIZEOF)\n\t\t\tbridge->pcie_start = PCI_BRIDGE_CONF_END;\n\t\telse\n\t\t\tbridge->pcie_start = bridge->ssid_start + PCI_CAP_SSID_SIZEOF;\n\t}\n\n\tbridge->conf.capabilities_pointer = min(bridge->ssid_start, bridge->pcie_start);\n\n\tif (bridge->conf.capabilities_pointer)\n\t\tbridge->conf.status |= cpu_to_le16(PCI_STATUS_CAP_LIST);\n\n\tif (bridge->has_pcie) {\n\t\tbridge->pcie_conf.cap_id = PCI_CAP_ID_EXP;\n\t\tbridge->pcie_conf.next = (bridge->ssid_start > bridge->pcie_start) ?\n\t\t\t\t\t bridge->ssid_start : 0;\n\t\tbridge->pcie_conf.cap |= cpu_to_le16(PCI_EXP_TYPE_ROOT_PORT << 4);\n\t\tbridge->pcie_cap_regs_behavior =\n\t\t\tkmemdup(pcie_cap_regs_behavior,\n\t\t\t\tsizeof(pcie_cap_regs_behavior),\n\t\t\t\tGFP_KERNEL);\n\t\tif (!bridge->pcie_cap_regs_behavior) {\n\t\t\tkfree(bridge->pci_regs_behavior);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\t \n\t\tbridge->pci_regs_behavior[PCI_CACHE_LINE_SIZE / 4].ro &=\n\t\t\t~GENMASK(15, 8);\n\t\tbridge->pci_regs_behavior[PCI_COMMAND / 4].ro &=\n\t\t\t~((PCI_COMMAND_SPECIAL | PCI_COMMAND_INVALIDATE |\n\t\t\t   PCI_COMMAND_VGA_PALETTE | PCI_COMMAND_WAIT |\n\t\t\t   PCI_COMMAND_FAST_BACK) |\n\t\t\t  (PCI_STATUS_66MHZ | PCI_STATUS_FAST_BACK |\n\t\t\t   PCI_STATUS_DEVSEL_MASK) << 16);\n\t\tbridge->pci_regs_behavior[PCI_PRIMARY_BUS / 4].ro &=\n\t\t\t~GENMASK(31, 24);\n\t\tbridge->pci_regs_behavior[PCI_IO_BASE / 4].ro &=\n\t\t\t~((PCI_STATUS_66MHZ | PCI_STATUS_FAST_BACK |\n\t\t\t   PCI_STATUS_DEVSEL_MASK) << 16);\n\t\tbridge->pci_regs_behavior[PCI_INTERRUPT_LINE / 4].rw &=\n\t\t\t~((PCI_BRIDGE_CTL_MASTER_ABORT |\n\t\t\t   BIT(8) | BIT(9) | BIT(11)) << 16);\n\t\tbridge->pci_regs_behavior[PCI_INTERRUPT_LINE / 4].ro &=\n\t\t\t~((PCI_BRIDGE_CTL_FAST_BACK) << 16);\n\t\tbridge->pci_regs_behavior[PCI_INTERRUPT_LINE / 4].w1c &=\n\t\t\t~(BIT(10) << 16);\n\t}\n\n\tif (flags & PCI_BRIDGE_EMUL_NO_PREFMEM_FORWARD) {\n\t\tbridge->pci_regs_behavior[PCI_PREF_MEMORY_BASE / 4].ro = ~0;\n\t\tbridge->pci_regs_behavior[PCI_PREF_MEMORY_BASE / 4].rw = 0;\n\t}\n\n\tif (flags & PCI_BRIDGE_EMUL_NO_IO_FORWARD) {\n\t\tbridge->pci_regs_behavior[PCI_COMMAND / 4].ro |= PCI_COMMAND_IO;\n\t\tbridge->pci_regs_behavior[PCI_COMMAND / 4].rw &= ~PCI_COMMAND_IO;\n\t\tbridge->pci_regs_behavior[PCI_IO_BASE / 4].ro |= GENMASK(15, 0);\n\t\tbridge->pci_regs_behavior[PCI_IO_BASE / 4].rw &= ~GENMASK(15, 0);\n\t\tbridge->pci_regs_behavior[PCI_IO_BASE_UPPER16 / 4].ro = ~0;\n\t\tbridge->pci_regs_behavior[PCI_IO_BASE_UPPER16 / 4].rw = 0;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(pci_bridge_emul_init);\n\n \nvoid pci_bridge_emul_cleanup(struct pci_bridge_emul *bridge)\n{\n\tif (bridge->has_pcie)\n\t\tkfree(bridge->pcie_cap_regs_behavior);\n\tkfree(bridge->pci_regs_behavior);\n}\nEXPORT_SYMBOL_GPL(pci_bridge_emul_cleanup);\n\n \nint pci_bridge_emul_conf_read(struct pci_bridge_emul *bridge, int where,\n\t\t\t      int size, u32 *value)\n{\n\tint ret;\n\tint reg = where & ~3;\n\tpci_bridge_emul_read_status_t (*read_op)(struct pci_bridge_emul *bridge,\n\t\t\t\t\t\t int reg, u32 *value);\n\t__le32 *cfgspace;\n\tconst struct pci_bridge_reg_behavior *behavior;\n\n\tif (reg < PCI_BRIDGE_CONF_END) {\n\t\t \n\t\tread_op = bridge->ops->read_base;\n\t\tcfgspace = (__le32 *) &bridge->conf;\n\t\tbehavior = bridge->pci_regs_behavior;\n\t} else if (reg >= bridge->ssid_start && reg < bridge->ssid_start + PCI_CAP_SSID_SIZEOF &&\n\t\t   bridge->subsystem_vendor_id) {\n\t\t \n\t\treg -= bridge->ssid_start;\n\t\tread_op = pci_bridge_emul_read_ssid;\n\t\tcfgspace = NULL;\n\t\tbehavior = NULL;\n\t} else if (reg >= bridge->pcie_start && reg < bridge->pcie_start + PCI_CAP_PCIE_SIZEOF &&\n\t\t   bridge->has_pcie) {\n\t\t \n\t\treg -= bridge->pcie_start;\n\t\tread_op = bridge->ops->read_pcie;\n\t\tcfgspace = (__le32 *) &bridge->pcie_conf;\n\t\tbehavior = bridge->pcie_cap_regs_behavior;\n\t} else if (reg >= PCI_CFG_SPACE_SIZE && bridge->has_pcie) {\n\t\t \n\t\treg -= PCI_CFG_SPACE_SIZE;\n\t\tread_op = bridge->ops->read_ext;\n\t\tcfgspace = NULL;\n\t\tbehavior = NULL;\n\t} else {\n\t\t \n\t\t*value = 0;\n\t\treturn PCIBIOS_SUCCESSFUL;\n\t}\n\n\tif (read_op)\n\t\tret = read_op(bridge, reg, value);\n\telse\n\t\tret = PCI_BRIDGE_EMUL_NOT_HANDLED;\n\n\tif (ret == PCI_BRIDGE_EMUL_NOT_HANDLED) {\n\t\tif (cfgspace)\n\t\t\t*value = le32_to_cpu(cfgspace[reg / 4]);\n\t\telse\n\t\t\t*value = 0;\n\t}\n\n\t \n\tif (behavior)\n\t\t*value &= behavior[reg / 4].ro | behavior[reg / 4].rw |\n\t\t\t  behavior[reg / 4].w1c;\n\n\tif (size == 1)\n\t\t*value = (*value >> (8 * (where & 3))) & 0xff;\n\telse if (size == 2)\n\t\t*value = (*value >> (8 * (where & 3))) & 0xffff;\n\telse if (size != 4)\n\t\treturn PCIBIOS_BAD_REGISTER_NUMBER;\n\n\treturn PCIBIOS_SUCCESSFUL;\n}\nEXPORT_SYMBOL_GPL(pci_bridge_emul_conf_read);\n\n \nint pci_bridge_emul_conf_write(struct pci_bridge_emul *bridge, int where,\n\t\t\t       int size, u32 value)\n{\n\tint reg = where & ~3;\n\tint mask, ret, old, new, shift;\n\tvoid (*write_op)(struct pci_bridge_emul *bridge, int reg,\n\t\t\t u32 old, u32 new, u32 mask);\n\t__le32 *cfgspace;\n\tconst struct pci_bridge_reg_behavior *behavior;\n\n\tret = pci_bridge_emul_conf_read(bridge, reg, 4, &old);\n\tif (ret != PCIBIOS_SUCCESSFUL)\n\t\treturn ret;\n\n\tif (reg < PCI_BRIDGE_CONF_END) {\n\t\t \n\t\twrite_op = bridge->ops->write_base;\n\t\tcfgspace = (__le32 *) &bridge->conf;\n\t\tbehavior = bridge->pci_regs_behavior;\n\t} else if (reg >= bridge->pcie_start && reg < bridge->pcie_start + PCI_CAP_PCIE_SIZEOF &&\n\t\t   bridge->has_pcie) {\n\t\t \n\t\treg -= bridge->pcie_start;\n\t\twrite_op = bridge->ops->write_pcie;\n\t\tcfgspace = (__le32 *) &bridge->pcie_conf;\n\t\tbehavior = bridge->pcie_cap_regs_behavior;\n\t} else if (reg >= PCI_CFG_SPACE_SIZE && bridge->has_pcie) {\n\t\t \n\t\treg -= PCI_CFG_SPACE_SIZE;\n\t\twrite_op = bridge->ops->write_ext;\n\t\tcfgspace = NULL;\n\t\tbehavior = NULL;\n\t} else {\n\t\t \n\t\treturn PCIBIOS_SUCCESSFUL;\n\t}\n\n\tshift = (where & 0x3) * 8;\n\n\tif (size == 4)\n\t\tmask = 0xffffffff;\n\telse if (size == 2)\n\t\tmask = 0xffff << shift;\n\telse if (size == 1)\n\t\tmask = 0xff << shift;\n\telse\n\t\treturn PCIBIOS_BAD_REGISTER_NUMBER;\n\n\tif (behavior) {\n\t\t \n\t\tnew = old & (~mask | ~behavior[reg / 4].rw);\n\n\t\t \n\t\tnew |= (value << shift) & (behavior[reg / 4].rw & mask);\n\n\t\t \n\t\tnew &= ~((value << shift) & (behavior[reg / 4].w1c & mask));\n\t} else {\n\t\tnew = old & ~mask;\n\t\tnew |= (value << shift) & mask;\n\t}\n\n\tif (cfgspace) {\n\t\t \n\t\tcfgspace[reg / 4] = cpu_to_le32(new);\n\t}\n\n\tif (behavior) {\n\t\t \n\t\tnew &= ~(behavior[reg / 4].w1c & ~mask);\n\n\t\t \n\t\tnew |= (value << shift) & (behavior[reg / 4].w1c & mask);\n\t}\n\n\tif (write_op)\n\t\twrite_op(bridge, reg, old, new, mask);\n\n\treturn PCIBIOS_SUCCESSFUL;\n}\nEXPORT_SYMBOL_GPL(pci_bridge_emul_conf_write);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}