{
  "module_name": "ats.c",
  "hash_id": "66def9c8f565bdd83653e4c1c4a3f62a14bc5f9de6b3dad4b3db2b967fe1e058",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/ats.c",
  "human_readable_source": "\n \n\n#include <linux/export.h>\n#include <linux/pci-ats.h>\n#include <linux/pci.h>\n#include <linux/slab.h>\n\n#include \"pci.h\"\n\nvoid pci_ats_init(struct pci_dev *dev)\n{\n\tint pos;\n\n\tif (pci_ats_disabled())\n\t\treturn;\n\n\tpos = pci_find_ext_capability(dev, PCI_EXT_CAP_ID_ATS);\n\tif (!pos)\n\t\treturn;\n\n\tdev->ats_cap = pos;\n}\n\n \nbool pci_ats_supported(struct pci_dev *dev)\n{\n\tif (!dev->ats_cap)\n\t\treturn false;\n\n\treturn (dev->untrusted == 0);\n}\nEXPORT_SYMBOL_GPL(pci_ats_supported);\n\n \nint pci_enable_ats(struct pci_dev *dev, int ps)\n{\n\tu16 ctrl;\n\tstruct pci_dev *pdev;\n\n\tif (!pci_ats_supported(dev))\n\t\treturn -EINVAL;\n\n\tif (WARN_ON(dev->ats_enabled))\n\t\treturn -EBUSY;\n\n\tif (ps < PCI_ATS_MIN_STU)\n\t\treturn -EINVAL;\n\n\t \n\tctrl = PCI_ATS_CTRL_ENABLE;\n\tif (dev->is_virtfn) {\n\t\tpdev = pci_physfn(dev);\n\t\tif (pdev->ats_stu != ps)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tdev->ats_stu = ps;\n\t\tctrl |= PCI_ATS_CTRL_STU(dev->ats_stu - PCI_ATS_MIN_STU);\n\t}\n\tpci_write_config_word(dev, dev->ats_cap + PCI_ATS_CTRL, ctrl);\n\n\tdev->ats_enabled = 1;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(pci_enable_ats);\n\n \nvoid pci_disable_ats(struct pci_dev *dev)\n{\n\tu16 ctrl;\n\n\tif (WARN_ON(!dev->ats_enabled))\n\t\treturn;\n\n\tpci_read_config_word(dev, dev->ats_cap + PCI_ATS_CTRL, &ctrl);\n\tctrl &= ~PCI_ATS_CTRL_ENABLE;\n\tpci_write_config_word(dev, dev->ats_cap + PCI_ATS_CTRL, ctrl);\n\n\tdev->ats_enabled = 0;\n}\nEXPORT_SYMBOL_GPL(pci_disable_ats);\n\nvoid pci_restore_ats_state(struct pci_dev *dev)\n{\n\tu16 ctrl;\n\n\tif (!dev->ats_enabled)\n\t\treturn;\n\n\tctrl = PCI_ATS_CTRL_ENABLE;\n\tif (!dev->is_virtfn)\n\t\tctrl |= PCI_ATS_CTRL_STU(dev->ats_stu - PCI_ATS_MIN_STU);\n\tpci_write_config_word(dev, dev->ats_cap + PCI_ATS_CTRL, ctrl);\n}\n\n \nint pci_ats_queue_depth(struct pci_dev *dev)\n{\n\tu16 cap;\n\n\tif (!dev->ats_cap)\n\t\treturn -EINVAL;\n\n\tif (dev->is_virtfn)\n\t\treturn 0;\n\n\tpci_read_config_word(dev, dev->ats_cap + PCI_ATS_CAP, &cap);\n\treturn PCI_ATS_CAP_QDEP(cap) ? PCI_ATS_CAP_QDEP(cap) : PCI_ATS_MAX_QDEP;\n}\n\n \nint pci_ats_page_aligned(struct pci_dev *pdev)\n{\n\tu16 cap;\n\n\tif (!pdev->ats_cap)\n\t\treturn 0;\n\n\tpci_read_config_word(pdev, pdev->ats_cap + PCI_ATS_CAP, &cap);\n\n\tif (cap & PCI_ATS_CAP_PAGE_ALIGNED)\n\t\treturn 1;\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PCI_PRI\nvoid pci_pri_init(struct pci_dev *pdev)\n{\n\tu16 status;\n\n\tpdev->pri_cap = pci_find_ext_capability(pdev, PCI_EXT_CAP_ID_PRI);\n\n\tif (!pdev->pri_cap)\n\t\treturn;\n\n\tpci_read_config_word(pdev, pdev->pri_cap + PCI_PRI_STATUS, &status);\n\tif (status & PCI_PRI_STATUS_PASID)\n\t\tpdev->pasid_required = 1;\n}\n\n \nint pci_enable_pri(struct pci_dev *pdev, u32 reqs)\n{\n\tu16 control, status;\n\tu32 max_requests;\n\tint pri = pdev->pri_cap;\n\n\t \n\tif (pdev->is_virtfn) {\n\t\tif (pci_physfn(pdev)->pri_enabled)\n\t\t\treturn 0;\n\t\treturn -EINVAL;\n\t}\n\n\tif (WARN_ON(pdev->pri_enabled))\n\t\treturn -EBUSY;\n\n\tif (!pri)\n\t\treturn -EINVAL;\n\n\tpci_read_config_word(pdev, pri + PCI_PRI_STATUS, &status);\n\tif (!(status & PCI_PRI_STATUS_STOPPED))\n\t\treturn -EBUSY;\n\n\tpci_read_config_dword(pdev, pri + PCI_PRI_MAX_REQ, &max_requests);\n\treqs = min(max_requests, reqs);\n\tpdev->pri_reqs_alloc = reqs;\n\tpci_write_config_dword(pdev, pri + PCI_PRI_ALLOC_REQ, reqs);\n\n\tcontrol = PCI_PRI_CTRL_ENABLE;\n\tpci_write_config_word(pdev, pri + PCI_PRI_CTRL, control);\n\n\tpdev->pri_enabled = 1;\n\n\treturn 0;\n}\n\n \nvoid pci_disable_pri(struct pci_dev *pdev)\n{\n\tu16 control;\n\tint pri = pdev->pri_cap;\n\n\t \n\tif (pdev->is_virtfn)\n\t\treturn;\n\n\tif (WARN_ON(!pdev->pri_enabled))\n\t\treturn;\n\n\tif (!pri)\n\t\treturn;\n\n\tpci_read_config_word(pdev, pri + PCI_PRI_CTRL, &control);\n\tcontrol &= ~PCI_PRI_CTRL_ENABLE;\n\tpci_write_config_word(pdev, pri + PCI_PRI_CTRL, control);\n\n\tpdev->pri_enabled = 0;\n}\nEXPORT_SYMBOL_GPL(pci_disable_pri);\n\n \nvoid pci_restore_pri_state(struct pci_dev *pdev)\n{\n\tu16 control = PCI_PRI_CTRL_ENABLE;\n\tu32 reqs = pdev->pri_reqs_alloc;\n\tint pri = pdev->pri_cap;\n\n\tif (pdev->is_virtfn)\n\t\treturn;\n\n\tif (!pdev->pri_enabled)\n\t\treturn;\n\n\tif (!pri)\n\t\treturn;\n\n\tpci_write_config_dword(pdev, pri + PCI_PRI_ALLOC_REQ, reqs);\n\tpci_write_config_word(pdev, pri + PCI_PRI_CTRL, control);\n}\n\n \nint pci_reset_pri(struct pci_dev *pdev)\n{\n\tu16 control;\n\tint pri = pdev->pri_cap;\n\n\tif (pdev->is_virtfn)\n\t\treturn 0;\n\n\tif (WARN_ON(pdev->pri_enabled))\n\t\treturn -EBUSY;\n\n\tif (!pri)\n\t\treturn -EINVAL;\n\n\tcontrol = PCI_PRI_CTRL_RESET;\n\tpci_write_config_word(pdev, pri + PCI_PRI_CTRL, control);\n\n\treturn 0;\n}\n\n \nint pci_prg_resp_pasid_required(struct pci_dev *pdev)\n{\n\tif (pdev->is_virtfn)\n\t\tpdev = pci_physfn(pdev);\n\n\treturn pdev->pasid_required;\n}\n\n \nbool pci_pri_supported(struct pci_dev *pdev)\n{\n\t \n\tif (pci_physfn(pdev)->pri_cap)\n\t\treturn true;\n\treturn false;\n}\nEXPORT_SYMBOL_GPL(pci_pri_supported);\n#endif  \n\n#ifdef CONFIG_PCI_PASID\nvoid pci_pasid_init(struct pci_dev *pdev)\n{\n\tpdev->pasid_cap = pci_find_ext_capability(pdev, PCI_EXT_CAP_ID_PASID);\n}\n\n \nint pci_enable_pasid(struct pci_dev *pdev, int features)\n{\n\tu16 control, supported;\n\tint pasid = pdev->pasid_cap;\n\n\t \n\tif (pdev->is_virtfn) {\n\t\tif (pci_physfn(pdev)->pasid_enabled)\n\t\t\treturn 0;\n\t\treturn -EINVAL;\n\t}\n\n\tif (WARN_ON(pdev->pasid_enabled))\n\t\treturn -EBUSY;\n\n\tif (!pdev->eetlp_prefix_path && !pdev->pasid_no_tlp)\n\t\treturn -EINVAL;\n\n\tif (!pasid)\n\t\treturn -EINVAL;\n\n\tif (!pci_acs_path_enabled(pdev, NULL, PCI_ACS_RR | PCI_ACS_UF))\n\t\treturn -EINVAL;\n\n\tpci_read_config_word(pdev, pasid + PCI_PASID_CAP, &supported);\n\tsupported &= PCI_PASID_CAP_EXEC | PCI_PASID_CAP_PRIV;\n\n\t \n\tif ((supported & features) != features)\n\t\treturn -EINVAL;\n\n\tcontrol = PCI_PASID_CTRL_ENABLE | features;\n\tpdev->pasid_features = features;\n\n\tpci_write_config_word(pdev, pasid + PCI_PASID_CTRL, control);\n\n\tpdev->pasid_enabled = 1;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(pci_enable_pasid);\n\n \nvoid pci_disable_pasid(struct pci_dev *pdev)\n{\n\tu16 control = 0;\n\tint pasid = pdev->pasid_cap;\n\n\t \n\tif (pdev->is_virtfn)\n\t\treturn;\n\n\tif (WARN_ON(!pdev->pasid_enabled))\n\t\treturn;\n\n\tif (!pasid)\n\t\treturn;\n\n\tpci_write_config_word(pdev, pasid + PCI_PASID_CTRL, control);\n\n\tpdev->pasid_enabled = 0;\n}\nEXPORT_SYMBOL_GPL(pci_disable_pasid);\n\n \nvoid pci_restore_pasid_state(struct pci_dev *pdev)\n{\n\tu16 control;\n\tint pasid = pdev->pasid_cap;\n\n\tif (pdev->is_virtfn)\n\t\treturn;\n\n\tif (!pdev->pasid_enabled)\n\t\treturn;\n\n\tif (!pasid)\n\t\treturn;\n\n\tcontrol = PCI_PASID_CTRL_ENABLE | pdev->pasid_features;\n\tpci_write_config_word(pdev, pasid + PCI_PASID_CTRL, control);\n}\n\n \nint pci_pasid_features(struct pci_dev *pdev)\n{\n\tu16 supported;\n\tint pasid;\n\n\tif (pdev->is_virtfn)\n\t\tpdev = pci_physfn(pdev);\n\n\tpasid = pdev->pasid_cap;\n\tif (!pasid)\n\t\treturn -EINVAL;\n\n\tpci_read_config_word(pdev, pasid + PCI_PASID_CAP, &supported);\n\n\tsupported &= PCI_PASID_CAP_EXEC | PCI_PASID_CAP_PRIV;\n\n\treturn supported;\n}\nEXPORT_SYMBOL_GPL(pci_pasid_features);\n\n#define PASID_NUMBER_SHIFT\t8\n#define PASID_NUMBER_MASK\t(0x1f << PASID_NUMBER_SHIFT)\n \nint pci_max_pasids(struct pci_dev *pdev)\n{\n\tu16 supported;\n\tint pasid;\n\n\tif (pdev->is_virtfn)\n\t\tpdev = pci_physfn(pdev);\n\n\tpasid = pdev->pasid_cap;\n\tif (!pasid)\n\t\treturn -EINVAL;\n\n\tpci_read_config_word(pdev, pasid + PCI_PASID_CAP, &supported);\n\n\tsupported = (supported & PASID_NUMBER_MASK) >> PASID_NUMBER_SHIFT;\n\n\treturn (1 << supported);\n}\nEXPORT_SYMBOL_GPL(pci_max_pasids);\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}