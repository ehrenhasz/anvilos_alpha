{
  "module_name": "remove.c",
  "hash_id": "72542248b0b316e6a5a1e5ae17cf51c13cd59cc660ca3d130d2153f60118ec0a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/remove.c",
  "human_readable_source": "\n#include <linux/pci.h>\n#include <linux/module.h>\n#include \"pci.h\"\n\nstatic void pci_free_resources(struct pci_dev *dev)\n{\n\tstruct resource *res;\n\n\tpci_dev_for_each_resource(dev, res) {\n\t\tif (res->parent)\n\t\t\trelease_resource(res);\n\t}\n}\n\nstatic void pci_stop_dev(struct pci_dev *dev)\n{\n\tpci_pme_active(dev, false);\n\n\tif (pci_dev_is_added(dev)) {\n\n\t\tdevice_release_driver(&dev->dev);\n\t\tpci_proc_detach_device(dev);\n\t\tpci_remove_sysfs_dev_files(dev);\n\t\tof_pci_remove_node(dev);\n\n\t\tpci_dev_assign_added(dev, false);\n\t}\n}\n\nstatic void pci_destroy_dev(struct pci_dev *dev)\n{\n\tif (!dev->dev.kobj.parent)\n\t\treturn;\n\n\tdevice_del(&dev->dev);\n\n\tdown_write(&pci_bus_sem);\n\tlist_del(&dev->bus_list);\n\tup_write(&pci_bus_sem);\n\n\tpci_doe_destroy(dev);\n\tpcie_aspm_exit_link_state(dev);\n\tpci_bridge_d3_update(dev);\n\tpci_free_resources(dev);\n\tput_device(&dev->dev);\n}\n\nvoid pci_remove_bus(struct pci_bus *bus)\n{\n\tpci_proc_detach_bus(bus);\n\n\tdown_write(&pci_bus_sem);\n\tlist_del(&bus->node);\n\tpci_bus_release_busn_res(bus);\n\tup_write(&pci_bus_sem);\n\tpci_remove_legacy_files(bus);\n\n\tif (bus->ops->remove_bus)\n\t\tbus->ops->remove_bus(bus);\n\n\tpcibios_remove_bus(bus);\n\tdevice_unregister(&bus->dev);\n}\nEXPORT_SYMBOL(pci_remove_bus);\n\nstatic void pci_stop_bus_device(struct pci_dev *dev)\n{\n\tstruct pci_bus *bus = dev->subordinate;\n\tstruct pci_dev *child, *tmp;\n\n\t \n\tif (bus) {\n\t\tlist_for_each_entry_safe_reverse(child, tmp,\n\t\t\t\t\t\t &bus->devices, bus_list)\n\t\t\tpci_stop_bus_device(child);\n\t}\n\n\tpci_stop_dev(dev);\n}\n\nstatic void pci_remove_bus_device(struct pci_dev *dev)\n{\n\tstruct pci_bus *bus = dev->subordinate;\n\tstruct pci_dev *child, *tmp;\n\n\tif (bus) {\n\t\tlist_for_each_entry_safe(child, tmp,\n\t\t\t\t\t &bus->devices, bus_list)\n\t\t\tpci_remove_bus_device(child);\n\n\t\tpci_remove_bus(bus);\n\t\tdev->subordinate = NULL;\n\t}\n\n\tpci_destroy_dev(dev);\n}\n\n \nvoid pci_stop_and_remove_bus_device(struct pci_dev *dev)\n{\n\tpci_stop_bus_device(dev);\n\tpci_remove_bus_device(dev);\n}\nEXPORT_SYMBOL(pci_stop_and_remove_bus_device);\n\nvoid pci_stop_and_remove_bus_device_locked(struct pci_dev *dev)\n{\n\tpci_lock_rescan_remove();\n\tpci_stop_and_remove_bus_device(dev);\n\tpci_unlock_rescan_remove();\n}\nEXPORT_SYMBOL_GPL(pci_stop_and_remove_bus_device_locked);\n\nvoid pci_stop_root_bus(struct pci_bus *bus)\n{\n\tstruct pci_dev *child, *tmp;\n\tstruct pci_host_bridge *host_bridge;\n\n\tif (!pci_is_root_bus(bus))\n\t\treturn;\n\n\thost_bridge = to_pci_host_bridge(bus->bridge);\n\tlist_for_each_entry_safe_reverse(child, tmp,\n\t\t\t\t\t &bus->devices, bus_list)\n\t\tpci_stop_bus_device(child);\n\n\t \n\tdevice_release_driver(&host_bridge->dev);\n}\nEXPORT_SYMBOL_GPL(pci_stop_root_bus);\n\nvoid pci_remove_root_bus(struct pci_bus *bus)\n{\n\tstruct pci_dev *child, *tmp;\n\tstruct pci_host_bridge *host_bridge;\n\n\tif (!pci_is_root_bus(bus))\n\t\treturn;\n\n\thost_bridge = to_pci_host_bridge(bus->bridge);\n\tlist_for_each_entry_safe(child, tmp,\n\t\t\t\t &bus->devices, bus_list)\n\t\tpci_remove_bus_device(child);\n\n#ifdef CONFIG_PCI_DOMAINS_GENERIC\n\t \n\tif (host_bridge->domain_nr == PCI_DOMAIN_NR_NOT_SET)\n\t\tpci_bus_release_domain_nr(bus, host_bridge->dev.parent);\n#endif\n\n\tpci_remove_bus(bus);\n\thost_bridge->bus = NULL;\n\n\t \n\tdevice_del(&host_bridge->dev);\n}\nEXPORT_SYMBOL_GPL(pci_remove_root_bus);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}