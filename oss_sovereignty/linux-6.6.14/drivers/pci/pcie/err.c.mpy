{
  "module_name": "err.c",
  "hash_id": "487855897c5ae820767ba59e8ff9cb9ac2319acb3b7f6c6a748f38042aa1f461",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/pcie/err.c",
  "human_readable_source": "\n \n\n#define dev_fmt(fmt) \"AER: \" fmt\n\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/aer.h>\n#include \"portdrv.h\"\n#include \"../pci.h\"\n\nstatic pci_ers_result_t merge_result(enum pci_ers_result orig,\n\t\t\t\t  enum pci_ers_result new)\n{\n\tif (new == PCI_ERS_RESULT_NO_AER_DRIVER)\n\t\treturn PCI_ERS_RESULT_NO_AER_DRIVER;\n\n\tif (new == PCI_ERS_RESULT_NONE)\n\t\treturn orig;\n\n\tswitch (orig) {\n\tcase PCI_ERS_RESULT_CAN_RECOVER:\n\tcase PCI_ERS_RESULT_RECOVERED:\n\t\torig = new;\n\t\tbreak;\n\tcase PCI_ERS_RESULT_DISCONNECT:\n\t\tif (new == PCI_ERS_RESULT_NEED_RESET)\n\t\t\torig = PCI_ERS_RESULT_NEED_RESET;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn orig;\n}\n\nstatic int report_error_detected(struct pci_dev *dev,\n\t\t\t\t pci_channel_state_t state,\n\t\t\t\t enum pci_ers_result *result)\n{\n\tstruct pci_driver *pdrv;\n\tpci_ers_result_t vote;\n\tconst struct pci_error_handlers *err_handler;\n\n\tdevice_lock(&dev->dev);\n\tpdrv = dev->driver;\n\tif (pci_dev_is_disconnected(dev)) {\n\t\tvote = PCI_ERS_RESULT_DISCONNECT;\n\t} else if (!pci_dev_set_io_state(dev, state)) {\n\t\tpci_info(dev, \"can't recover (state transition %u -> %u invalid)\\n\",\n\t\t\tdev->error_state, state);\n\t\tvote = PCI_ERS_RESULT_NONE;\n\t} else if (!pdrv || !pdrv->err_handler ||\n\t\t   !pdrv->err_handler->error_detected) {\n\t\t \n\t\tif (dev->hdr_type != PCI_HEADER_TYPE_BRIDGE) {\n\t\t\tvote = PCI_ERS_RESULT_NO_AER_DRIVER;\n\t\t\tpci_info(dev, \"can't recover (no error_detected callback)\\n\");\n\t\t} else {\n\t\t\tvote = PCI_ERS_RESULT_NONE;\n\t\t}\n\t} else {\n\t\terr_handler = pdrv->err_handler;\n\t\tvote = err_handler->error_detected(dev, state);\n\t}\n\tpci_uevent_ers(dev, vote);\n\t*result = merge_result(*result, vote);\n\tdevice_unlock(&dev->dev);\n\treturn 0;\n}\n\nstatic int report_frozen_detected(struct pci_dev *dev, void *data)\n{\n\treturn report_error_detected(dev, pci_channel_io_frozen, data);\n}\n\nstatic int report_normal_detected(struct pci_dev *dev, void *data)\n{\n\treturn report_error_detected(dev, pci_channel_io_normal, data);\n}\n\nstatic int report_mmio_enabled(struct pci_dev *dev, void *data)\n{\n\tstruct pci_driver *pdrv;\n\tpci_ers_result_t vote, *result = data;\n\tconst struct pci_error_handlers *err_handler;\n\n\tdevice_lock(&dev->dev);\n\tpdrv = dev->driver;\n\tif (!pdrv ||\n\t\t!pdrv->err_handler ||\n\t\t!pdrv->err_handler->mmio_enabled)\n\t\tgoto out;\n\n\terr_handler = pdrv->err_handler;\n\tvote = err_handler->mmio_enabled(dev);\n\t*result = merge_result(*result, vote);\nout:\n\tdevice_unlock(&dev->dev);\n\treturn 0;\n}\n\nstatic int report_slot_reset(struct pci_dev *dev, void *data)\n{\n\tstruct pci_driver *pdrv;\n\tpci_ers_result_t vote, *result = data;\n\tconst struct pci_error_handlers *err_handler;\n\n\tdevice_lock(&dev->dev);\n\tpdrv = dev->driver;\n\tif (!pdrv ||\n\t\t!pdrv->err_handler ||\n\t\t!pdrv->err_handler->slot_reset)\n\t\tgoto out;\n\n\terr_handler = pdrv->err_handler;\n\tvote = err_handler->slot_reset(dev);\n\t*result = merge_result(*result, vote);\nout:\n\tdevice_unlock(&dev->dev);\n\treturn 0;\n}\n\nstatic int report_resume(struct pci_dev *dev, void *data)\n{\n\tstruct pci_driver *pdrv;\n\tconst struct pci_error_handlers *err_handler;\n\n\tdevice_lock(&dev->dev);\n\tpdrv = dev->driver;\n\tif (!pci_dev_set_io_state(dev, pci_channel_io_normal) ||\n\t\t!pdrv ||\n\t\t!pdrv->err_handler ||\n\t\t!pdrv->err_handler->resume)\n\t\tgoto out;\n\n\terr_handler = pdrv->err_handler;\n\terr_handler->resume(dev);\nout:\n\tpci_uevent_ers(dev, PCI_ERS_RESULT_RECOVERED);\n\tdevice_unlock(&dev->dev);\n\treturn 0;\n}\n\n \nstatic void pci_walk_bridge(struct pci_dev *bridge,\n\t\t\t    int (*cb)(struct pci_dev *, void *),\n\t\t\t    void *userdata)\n{\n\tif (bridge->subordinate)\n\t\tpci_walk_bus(bridge->subordinate, cb, userdata);\n\telse\n\t\tcb(bridge, userdata);\n}\n\npci_ers_result_t pcie_do_recovery(struct pci_dev *dev,\n\t\tpci_channel_state_t state,\n\t\tpci_ers_result_t (*reset_subordinates)(struct pci_dev *pdev))\n{\n\tint type = pci_pcie_type(dev);\n\tstruct pci_dev *bridge;\n\tpci_ers_result_t status = PCI_ERS_RESULT_CAN_RECOVER;\n\tstruct pci_host_bridge *host = pci_find_host_bridge(dev->bus);\n\n\t \n\tif (type == PCI_EXP_TYPE_ROOT_PORT ||\n\t    type == PCI_EXP_TYPE_DOWNSTREAM ||\n\t    type == PCI_EXP_TYPE_RC_EC ||\n\t    type == PCI_EXP_TYPE_RC_END)\n\t\tbridge = dev;\n\telse\n\t\tbridge = pci_upstream_bridge(dev);\n\n\tpci_dbg(bridge, \"broadcast error_detected message\\n\");\n\tif (state == pci_channel_io_frozen) {\n\t\tpci_walk_bridge(bridge, report_frozen_detected, &status);\n\t\tif (reset_subordinates(bridge) != PCI_ERS_RESULT_RECOVERED) {\n\t\t\tpci_warn(bridge, \"subordinate device reset failed\\n\");\n\t\t\tgoto failed;\n\t\t}\n\t} else {\n\t\tpci_walk_bridge(bridge, report_normal_detected, &status);\n\t}\n\n\tif (status == PCI_ERS_RESULT_CAN_RECOVER) {\n\t\tstatus = PCI_ERS_RESULT_RECOVERED;\n\t\tpci_dbg(bridge, \"broadcast mmio_enabled message\\n\");\n\t\tpci_walk_bridge(bridge, report_mmio_enabled, &status);\n\t}\n\n\tif (status == PCI_ERS_RESULT_NEED_RESET) {\n\t\t \n\t\tstatus = PCI_ERS_RESULT_RECOVERED;\n\t\tpci_dbg(bridge, \"broadcast slot_reset message\\n\");\n\t\tpci_walk_bridge(bridge, report_slot_reset, &status);\n\t}\n\n\tif (status != PCI_ERS_RESULT_RECOVERED)\n\t\tgoto failed;\n\n\tpci_dbg(bridge, \"broadcast resume message\\n\");\n\tpci_walk_bridge(bridge, report_resume, &status);\n\n\t \n\tif (host->native_aer || pcie_ports_native) {\n\t\tpcie_clear_device_status(dev);\n\t\tpci_aer_clear_nonfatal_status(dev);\n\t}\n\tpci_info(bridge, \"device recovery successful\\n\");\n\treturn status;\n\nfailed:\n\tpci_uevent_ers(bridge, PCI_ERS_RESULT_DISCONNECT);\n\n\t \n\tpci_info(bridge, \"device recovery failed\\n\");\n\n\treturn status;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}