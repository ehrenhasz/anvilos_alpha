{
  "module_name": "portdrv.c",
  "hash_id": "3c045429aa59cf3d745d607ff5b9b691a3834e5a6eb96ae5c491a1a9f1996ba9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/pcie/portdrv.c",
  "human_readable_source": "\n \n\n#include <linux/dmi.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/pm.h>\n#include <linux/pm_runtime.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/aer.h>\n\n#include \"../pci.h\"\n#include \"portdrv.h\"\n\n \n#define PCIE_PORT_MAX_MSI_ENTRIES\t32\n\n#define get_descriptor_id(type, service) (((type - 4) << 8) | service)\n\nstruct portdrv_service_data {\n\tstruct pcie_port_service_driver *drv;\n\tstruct device *dev;\n\tu32 service;\n};\n\n \nstatic void release_pcie_device(struct device *dev)\n{\n\tkfree(to_pcie_device(dev));\n}\n\n \nstatic int pcie_message_numbers(struct pci_dev *dev, int mask,\n\t\t\t\tu32 *pme, u32 *aer, u32 *dpc)\n{\n\tu32 nvec = 0, pos;\n\tu16 reg16;\n\n\t \n\n\tif (mask & (PCIE_PORT_SERVICE_PME | PCIE_PORT_SERVICE_HP |\n\t\t    PCIE_PORT_SERVICE_BWNOTIF)) {\n\t\tpcie_capability_read_word(dev, PCI_EXP_FLAGS, &reg16);\n\t\t*pme = (reg16 & PCI_EXP_FLAGS_IRQ) >> 9;\n\t\tnvec = *pme + 1;\n\t}\n\n#ifdef CONFIG_PCIEAER\n\tif (mask & PCIE_PORT_SERVICE_AER) {\n\t\tu32 reg32;\n\n\t\tpos = dev->aer_cap;\n\t\tif (pos) {\n\t\t\tpci_read_config_dword(dev, pos + PCI_ERR_ROOT_STATUS,\n\t\t\t\t\t      &reg32);\n\t\t\t*aer = (reg32 & PCI_ERR_ROOT_AER_IRQ) >> 27;\n\t\t\tnvec = max(nvec, *aer + 1);\n\t\t}\n\t}\n#endif\n\n\tif (mask & PCIE_PORT_SERVICE_DPC) {\n\t\tpos = pci_find_ext_capability(dev, PCI_EXT_CAP_ID_DPC);\n\t\tif (pos) {\n\t\t\tpci_read_config_word(dev, pos + PCI_EXP_DPC_CAP,\n\t\t\t\t\t     &reg16);\n\t\t\t*dpc = reg16 & PCI_EXP_DPC_IRQ;\n\t\t\tnvec = max(nvec, *dpc + 1);\n\t\t}\n\t}\n\n\treturn nvec;\n}\n\n \nstatic int pcie_port_enable_irq_vec(struct pci_dev *dev, int *irqs, int mask)\n{\n\tint nr_entries, nvec, pcie_irq;\n\tu32 pme = 0, aer = 0, dpc = 0;\n\n\t \n\tnr_entries = pci_alloc_irq_vectors(dev, 1, PCIE_PORT_MAX_MSI_ENTRIES,\n\t\t\tPCI_IRQ_MSIX | PCI_IRQ_MSI);\n\tif (nr_entries < 0)\n\t\treturn nr_entries;\n\n\t \n\tnvec = pcie_message_numbers(dev, mask, &pme, &aer, &dpc);\n\tif (nvec > nr_entries) {\n\t\tpci_free_irq_vectors(dev);\n\t\treturn -EIO;\n\t}\n\n\t \n\tif (nvec != nr_entries) {\n\t\tpci_free_irq_vectors(dev);\n\n\t\tnr_entries = pci_alloc_irq_vectors(dev, nvec, nvec,\n\t\t\t\tPCI_IRQ_MSIX | PCI_IRQ_MSI);\n\t\tif (nr_entries < 0)\n\t\t\treturn nr_entries;\n\t}\n\n\t \n\tif (mask & (PCIE_PORT_SERVICE_PME | PCIE_PORT_SERVICE_HP |\n\t\t    PCIE_PORT_SERVICE_BWNOTIF)) {\n\t\tpcie_irq = pci_irq_vector(dev, pme);\n\t\tirqs[PCIE_PORT_SERVICE_PME_SHIFT] = pcie_irq;\n\t\tirqs[PCIE_PORT_SERVICE_HP_SHIFT] = pcie_irq;\n\t\tirqs[PCIE_PORT_SERVICE_BWNOTIF_SHIFT] = pcie_irq;\n\t}\n\n\tif (mask & PCIE_PORT_SERVICE_AER)\n\t\tirqs[PCIE_PORT_SERVICE_AER_SHIFT] = pci_irq_vector(dev, aer);\n\n\tif (mask & PCIE_PORT_SERVICE_DPC)\n\t\tirqs[PCIE_PORT_SERVICE_DPC_SHIFT] = pci_irq_vector(dev, dpc);\n\n\treturn 0;\n}\n\n \nstatic int pcie_init_service_irqs(struct pci_dev *dev, int *irqs, int mask)\n{\n\tint ret, i;\n\n\tfor (i = 0; i < PCIE_PORT_DEVICE_MAXSERVICES; i++)\n\t\tirqs[i] = -1;\n\n\t \n\tif ((mask & PCIE_PORT_SERVICE_PME) && pcie_pme_no_msi())\n\t\tgoto legacy_irq;\n\n\t \n\tif (pcie_port_enable_irq_vec(dev, irqs, mask) == 0)\n\t\treturn 0;\n\nlegacy_irq:\n\t \n\tret = pci_alloc_irq_vectors(dev, 1, 1, PCI_IRQ_LEGACY);\n\tif (ret < 0)\n\t\treturn -ENODEV;\n\n\tfor (i = 0; i < PCIE_PORT_DEVICE_MAXSERVICES; i++)\n\t\tirqs[i] = pci_irq_vector(dev, 0);\n\n\treturn 0;\n}\n\n \nstatic int get_port_device_capability(struct pci_dev *dev)\n{\n\tstruct pci_host_bridge *host = pci_find_host_bridge(dev->bus);\n\tint services = 0;\n\n\tif (dev->is_hotplug_bridge &&\n\t    (pci_pcie_type(dev) == PCI_EXP_TYPE_ROOT_PORT ||\n\t     pci_pcie_type(dev) == PCI_EXP_TYPE_DOWNSTREAM) &&\n\t    (pcie_ports_native || host->native_pcie_hotplug)) {\n\t\tservices |= PCIE_PORT_SERVICE_HP;\n\n\t\t \n\t\tpcie_capability_clear_word(dev, PCI_EXP_SLTCTL,\n\t\t\t  PCI_EXP_SLTCTL_CCIE | PCI_EXP_SLTCTL_HPIE);\n\t}\n\n#ifdef CONFIG_PCIEAER\n\tif ((pci_pcie_type(dev) == PCI_EXP_TYPE_ROOT_PORT ||\n             pci_pcie_type(dev) == PCI_EXP_TYPE_RC_EC) &&\n\t    dev->aer_cap && pci_aer_available() &&\n\t    (pcie_ports_native || host->native_aer))\n\t\tservices |= PCIE_PORT_SERVICE_AER;\n#endif\n\n\t \n\tif ((pci_pcie_type(dev) == PCI_EXP_TYPE_ROOT_PORT ||\n\t     pci_pcie_type(dev) == PCI_EXP_TYPE_RC_EC) &&\n\t    (pcie_ports_native || host->native_pme)) {\n\t\tservices |= PCIE_PORT_SERVICE_PME;\n\n\t\t \n\t\tpcie_pme_interrupt_enable(dev, false);\n\t}\n\n\t \n\tif (pci_find_ext_capability(dev, PCI_EXT_CAP_ID_DPC) &&\n\t    pci_aer_available() &&\n\t    (pcie_ports_dpc_native || (services & PCIE_PORT_SERVICE_AER)))\n\t\tservices |= PCIE_PORT_SERVICE_DPC;\n\n\tif (pci_pcie_type(dev) == PCI_EXP_TYPE_DOWNSTREAM ||\n\t    pci_pcie_type(dev) == PCI_EXP_TYPE_ROOT_PORT) {\n\t\tu32 linkcap;\n\n\t\tpcie_capability_read_dword(dev, PCI_EXP_LNKCAP, &linkcap);\n\t\tif (linkcap & PCI_EXP_LNKCAP_LBNC)\n\t\t\tservices |= PCIE_PORT_SERVICE_BWNOTIF;\n\t}\n\n\treturn services;\n}\n\n \nstatic int pcie_device_init(struct pci_dev *pdev, int service, int irq)\n{\n\tint retval;\n\tstruct pcie_device *pcie;\n\tstruct device *device;\n\n\tpcie = kzalloc(sizeof(*pcie), GFP_KERNEL);\n\tif (!pcie)\n\t\treturn -ENOMEM;\n\tpcie->port = pdev;\n\tpcie->irq = irq;\n\tpcie->service = service;\n\n\t \n\tdevice = &pcie->device;\n\tdevice->bus = &pcie_port_bus_type;\n\tdevice->release = release_pcie_device;\t \n\tdev_set_name(device, \"%s:pcie%03x\",\n\t\t     pci_name(pdev),\n\t\t     get_descriptor_id(pci_pcie_type(pdev), service));\n\tdevice->parent = &pdev->dev;\n\tdevice_enable_async_suspend(device);\n\n\tretval = device_register(device);\n\tif (retval) {\n\t\tput_device(device);\n\t\treturn retval;\n\t}\n\n\tpm_runtime_no_callbacks(device);\n\n\treturn 0;\n}\n\n \nstatic int pcie_port_device_register(struct pci_dev *dev)\n{\n\tint status, capabilities, i, nr_service;\n\tint irqs[PCIE_PORT_DEVICE_MAXSERVICES];\n\n\t \n\tstatus = pci_enable_device(dev);\n\tif (status)\n\t\treturn status;\n\n\t \n\tcapabilities = get_port_device_capability(dev);\n\tif (!capabilities)\n\t\treturn 0;\n\n\tpci_set_master(dev);\n\t \n\tstatus = pcie_init_service_irqs(dev, irqs, capabilities);\n\tif (status) {\n\t\tcapabilities &= PCIE_PORT_SERVICE_HP;\n\t\tif (!capabilities)\n\t\t\tgoto error_disable;\n\t}\n\n\t \n\tstatus = -ENODEV;\n\tnr_service = 0;\n\tfor (i = 0; i < PCIE_PORT_DEVICE_MAXSERVICES; i++) {\n\t\tint service = 1 << i;\n\t\tif (!(capabilities & service))\n\t\t\tcontinue;\n\t\tif (!pcie_device_init(dev, service, irqs[i]))\n\t\t\tnr_service++;\n\t}\n\tif (!nr_service)\n\t\tgoto error_cleanup_irqs;\n\n\treturn 0;\n\nerror_cleanup_irqs:\n\tpci_free_irq_vectors(dev);\nerror_disable:\n\tpci_disable_device(dev);\n\treturn status;\n}\n\ntypedef int (*pcie_callback_t)(struct pcie_device *);\n\nstatic int pcie_port_device_iter(struct device *dev, void *data)\n{\n\tstruct pcie_port_service_driver *service_driver;\n\tsize_t offset = *(size_t *)data;\n\tpcie_callback_t cb;\n\n\tif ((dev->bus == &pcie_port_bus_type) && dev->driver) {\n\t\tservice_driver = to_service_driver(dev->driver);\n\t\tcb = *(pcie_callback_t *)((void *)service_driver + offset);\n\t\tif (cb)\n\t\t\treturn cb(to_pcie_device(dev));\n\t}\n\treturn 0;\n}\n\n#ifdef CONFIG_PM\n \nstatic int pcie_port_device_suspend(struct device *dev)\n{\n\tsize_t off = offsetof(struct pcie_port_service_driver, suspend);\n\treturn device_for_each_child(dev, &off, pcie_port_device_iter);\n}\n\nstatic int pcie_port_device_resume_noirq(struct device *dev)\n{\n\tsize_t off = offsetof(struct pcie_port_service_driver, resume_noirq);\n\treturn device_for_each_child(dev, &off, pcie_port_device_iter);\n}\n\n \nstatic int pcie_port_device_resume(struct device *dev)\n{\n\tsize_t off = offsetof(struct pcie_port_service_driver, resume);\n\treturn device_for_each_child(dev, &off, pcie_port_device_iter);\n}\n\n \nstatic int pcie_port_device_runtime_suspend(struct device *dev)\n{\n\tsize_t off = offsetof(struct pcie_port_service_driver, runtime_suspend);\n\treturn device_for_each_child(dev, &off, pcie_port_device_iter);\n}\n\n \nstatic int pcie_port_device_runtime_resume(struct device *dev)\n{\n\tsize_t off = offsetof(struct pcie_port_service_driver, runtime_resume);\n\treturn device_for_each_child(dev, &off, pcie_port_device_iter);\n}\n#endif  \n\nstatic int remove_iter(struct device *dev, void *data)\n{\n\tif (dev->bus == &pcie_port_bus_type)\n\t\tdevice_unregister(dev);\n\treturn 0;\n}\n\nstatic int find_service_iter(struct device *device, void *data)\n{\n\tstruct pcie_port_service_driver *service_driver;\n\tstruct portdrv_service_data *pdrvs;\n\tu32 service;\n\n\tpdrvs = (struct portdrv_service_data *) data;\n\tservice = pdrvs->service;\n\n\tif (device->bus == &pcie_port_bus_type && device->driver) {\n\t\tservice_driver = to_service_driver(device->driver);\n\t\tif (service_driver->service == service) {\n\t\t\tpdrvs->drv = service_driver;\n\t\t\tpdrvs->dev = device;\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstruct device *pcie_port_find_device(struct pci_dev *dev,\n\t\t\t\t      u32 service)\n{\n\tstruct device *device;\n\tstruct portdrv_service_data pdrvs;\n\n\tpdrvs.dev = NULL;\n\tpdrvs.service = service;\n\tdevice_for_each_child(&dev->dev, &pdrvs, find_service_iter);\n\n\tdevice = pdrvs.dev;\n\treturn device;\n}\nEXPORT_SYMBOL_GPL(pcie_port_find_device);\n\n \nstatic void pcie_port_device_remove(struct pci_dev *dev)\n{\n\tdevice_for_each_child(&dev->dev, NULL, remove_iter);\n\tpci_free_irq_vectors(dev);\n}\n\n \nstatic int pcie_port_probe_service(struct device *dev)\n{\n\tstruct pcie_device *pciedev;\n\tstruct pcie_port_service_driver *driver;\n\tint status;\n\n\tif (!dev || !dev->driver)\n\t\treturn -ENODEV;\n\n\tdriver = to_service_driver(dev->driver);\n\tif (!driver || !driver->probe)\n\t\treturn -ENODEV;\n\n\tpciedev = to_pcie_device(dev);\n\tstatus = driver->probe(pciedev);\n\tif (status)\n\t\treturn status;\n\n\tget_device(dev);\n\treturn 0;\n}\n\n \nstatic int pcie_port_remove_service(struct device *dev)\n{\n\tstruct pcie_device *pciedev;\n\tstruct pcie_port_service_driver *driver;\n\n\tif (!dev || !dev->driver)\n\t\treturn 0;\n\n\tpciedev = to_pcie_device(dev);\n\tdriver = to_service_driver(dev->driver);\n\tif (driver && driver->remove) {\n\t\tdriver->remove(pciedev);\n\t\tput_device(dev);\n\t}\n\treturn 0;\n}\n\n \nstatic void pcie_port_shutdown_service(struct device *dev) {}\n\n \nint pcie_port_service_register(struct pcie_port_service_driver *new)\n{\n\tif (pcie_ports_disabled)\n\t\treturn -ENODEV;\n\n\tnew->driver.name = new->name;\n\tnew->driver.bus = &pcie_port_bus_type;\n\tnew->driver.probe = pcie_port_probe_service;\n\tnew->driver.remove = pcie_port_remove_service;\n\tnew->driver.shutdown = pcie_port_shutdown_service;\n\n\treturn driver_register(&new->driver);\n}\n\n \nvoid pcie_port_service_unregister(struct pcie_port_service_driver *drv)\n{\n\tdriver_unregister(&drv->driver);\n}\n\n \nbool pcie_ports_disabled;\n\n \nbool pcie_ports_native;\n\n \nbool pcie_ports_dpc_native;\n\nstatic int __init pcie_port_setup(char *str)\n{\n\tif (!strncmp(str, \"compat\", 6))\n\t\tpcie_ports_disabled = true;\n\telse if (!strncmp(str, \"native\", 6))\n\t\tpcie_ports_native = true;\n\telse if (!strncmp(str, \"dpc-native\", 10))\n\t\tpcie_ports_dpc_native = true;\n\n\treturn 1;\n}\n__setup(\"pcie_ports=\", pcie_port_setup);\n\n \n\n#ifdef CONFIG_PM\nstatic int pcie_port_runtime_suspend(struct device *dev)\n{\n\tif (!to_pci_dev(dev)->bridge_d3)\n\t\treturn -EBUSY;\n\n\treturn pcie_port_device_runtime_suspend(dev);\n}\n\nstatic int pcie_port_runtime_idle(struct device *dev)\n{\n\t \n\treturn to_pci_dev(dev)->bridge_d3 ? 0 : -EBUSY;\n}\n\nstatic const struct dev_pm_ops pcie_portdrv_pm_ops = {\n\t.suspend\t= pcie_port_device_suspend,\n\t.resume_noirq\t= pcie_port_device_resume_noirq,\n\t.resume\t\t= pcie_port_device_resume,\n\t.freeze\t\t= pcie_port_device_suspend,\n\t.thaw\t\t= pcie_port_device_resume,\n\t.poweroff\t= pcie_port_device_suspend,\n\t.restore_noirq\t= pcie_port_device_resume_noirq,\n\t.restore\t= pcie_port_device_resume,\n\t.runtime_suspend = pcie_port_runtime_suspend,\n\t.runtime_resume\t= pcie_port_device_runtime_resume,\n\t.runtime_idle\t= pcie_port_runtime_idle,\n};\n\n#define PCIE_PORTDRV_PM_OPS\t(&pcie_portdrv_pm_ops)\n\n#else  \n\n#define PCIE_PORTDRV_PM_OPS\tNULL\n#endif  \n\n \nstatic int pcie_portdrv_probe(struct pci_dev *dev,\n\t\t\t\t\tconst struct pci_device_id *id)\n{\n\tint type = pci_pcie_type(dev);\n\tint status;\n\n\tif (!pci_is_pcie(dev) ||\n\t    ((type != PCI_EXP_TYPE_ROOT_PORT) &&\n\t     (type != PCI_EXP_TYPE_UPSTREAM) &&\n\t     (type != PCI_EXP_TYPE_DOWNSTREAM) &&\n\t     (type != PCI_EXP_TYPE_RC_EC)))\n\t\treturn -ENODEV;\n\n\tif (type == PCI_EXP_TYPE_RC_EC)\n\t\tpcie_link_rcec(dev);\n\n\tstatus = pcie_port_device_register(dev);\n\tif (status)\n\t\treturn status;\n\n\tpci_save_state(dev);\n\n\tdev_pm_set_driver_flags(&dev->dev, DPM_FLAG_NO_DIRECT_COMPLETE |\n\t\t\t\t\t   DPM_FLAG_SMART_SUSPEND);\n\n\tif (pci_bridge_d3_possible(dev)) {\n\t\t \n\t\tpm_runtime_set_autosuspend_delay(&dev->dev, 100);\n\t\tpm_runtime_use_autosuspend(&dev->dev);\n\t\tpm_runtime_mark_last_busy(&dev->dev);\n\t\tpm_runtime_put_autosuspend(&dev->dev);\n\t\tpm_runtime_allow(&dev->dev);\n\t}\n\n\treturn 0;\n}\n\nstatic void pcie_portdrv_remove(struct pci_dev *dev)\n{\n\tif (pci_bridge_d3_possible(dev)) {\n\t\tpm_runtime_forbid(&dev->dev);\n\t\tpm_runtime_get_noresume(&dev->dev);\n\t\tpm_runtime_dont_use_autosuspend(&dev->dev);\n\t}\n\n\tpcie_port_device_remove(dev);\n\n\tpci_disable_device(dev);\n}\n\nstatic void pcie_portdrv_shutdown(struct pci_dev *dev)\n{\n\tif (pci_bridge_d3_possible(dev)) {\n\t\tpm_runtime_forbid(&dev->dev);\n\t\tpm_runtime_get_noresume(&dev->dev);\n\t\tpm_runtime_dont_use_autosuspend(&dev->dev);\n\t}\n\n\tpcie_port_device_remove(dev);\n}\n\nstatic pci_ers_result_t pcie_portdrv_error_detected(struct pci_dev *dev,\n\t\t\t\t\tpci_channel_state_t error)\n{\n\tif (error == pci_channel_io_frozen)\n\t\treturn PCI_ERS_RESULT_NEED_RESET;\n\treturn PCI_ERS_RESULT_CAN_RECOVER;\n}\n\nstatic pci_ers_result_t pcie_portdrv_slot_reset(struct pci_dev *dev)\n{\n\tsize_t off = offsetof(struct pcie_port_service_driver, slot_reset);\n\tdevice_for_each_child(&dev->dev, &off, pcie_port_device_iter);\n\n\tpci_restore_state(dev);\n\tpci_save_state(dev);\n\treturn PCI_ERS_RESULT_RECOVERED;\n}\n\nstatic pci_ers_result_t pcie_portdrv_mmio_enabled(struct pci_dev *dev)\n{\n\treturn PCI_ERS_RESULT_RECOVERED;\n}\n\n \nstatic const struct pci_device_id port_pci_ids[] = {\n\t \n\t{ PCI_DEVICE_CLASS(PCI_CLASS_BRIDGE_PCI_NORMAL, ~0) },\n\t \n\t{ PCI_DEVICE_CLASS(PCI_CLASS_BRIDGE_PCI_SUBTRACTIVE, ~0) },\n\t \n\t{ PCI_DEVICE_CLASS(((PCI_CLASS_SYSTEM_RCEC << 8) | 0x00), ~0) },\n\t{ },\n};\n\nstatic const struct pci_error_handlers pcie_portdrv_err_handler = {\n\t.error_detected = pcie_portdrv_error_detected,\n\t.slot_reset = pcie_portdrv_slot_reset,\n\t.mmio_enabled = pcie_portdrv_mmio_enabled,\n};\n\nstatic struct pci_driver pcie_portdriver = {\n\t.name\t\t= \"pcieport\",\n\t.id_table\t= &port_pci_ids[0],\n\n\t.probe\t\t= pcie_portdrv_probe,\n\t.remove\t\t= pcie_portdrv_remove,\n\t.shutdown\t= pcie_portdrv_shutdown,\n\n\t.err_handler\t= &pcie_portdrv_err_handler,\n\n\t.driver_managed_dma = true,\n\n\t.driver.pm\t= PCIE_PORTDRV_PM_OPS,\n};\n\nstatic int __init dmi_pcie_pme_disable_msi(const struct dmi_system_id *d)\n{\n\tpr_notice(\"%s detected: will not use MSI for PCIe PME signaling\\n\",\n\t\t  d->ident);\n\tpcie_pme_disable_msi();\n\treturn 0;\n}\n\nstatic const struct dmi_system_id pcie_portdrv_dmi_table[] __initconst = {\n\t \n\t{\n\t .callback = dmi_pcie_pme_disable_msi,\n\t .ident = \"MSI Wind U-100\",\n\t .matches = {\n\t\t     DMI_MATCH(DMI_SYS_VENDOR,\n\t\t\t\t\"MICRO-STAR INTERNATIONAL CO., LTD\"),\n\t\t     DMI_MATCH(DMI_PRODUCT_NAME, \"U-100\"),\n\t\t     },\n\t },\n\t {}\n};\n\nstatic void __init pcie_init_services(void)\n{\n\tpcie_aer_init();\n\tpcie_pme_init();\n\tpcie_dpc_init();\n\tpcie_hp_init();\n}\n\nstatic int __init pcie_portdrv_init(void)\n{\n\tif (pcie_ports_disabled)\n\t\treturn -EACCES;\n\n\tpcie_init_services();\n\tdmi_check_system(pcie_portdrv_dmi_table);\n\n\treturn pci_register_driver(&pcie_portdriver);\n}\ndevice_initcall(pcie_portdrv_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}