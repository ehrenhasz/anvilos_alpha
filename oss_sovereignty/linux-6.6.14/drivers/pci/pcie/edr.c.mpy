{
  "module_name": "edr.c",
  "hash_id": "151f76b8d48bb2dd417c952d957892a2b78f11ac371e4f8995b2334341253223",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/pcie/edr.c",
  "human_readable_source": "\n \n\n#define dev_fmt(fmt) \"EDR: \" fmt\n\n#include <linux/pci.h>\n#include <linux/pci-acpi.h>\n\n#include \"portdrv.h\"\n#include \"../pci.h\"\n\n#define EDR_PORT_DPC_ENABLE_DSM\t\t0x0C\n#define EDR_PORT_LOCATE_DSM\t\t0x0D\n#define EDR_OST_SUCCESS\t\t\t0x80\n#define EDR_OST_FAILED\t\t\t0x81\n\n \nstatic int acpi_enable_dpc(struct pci_dev *pdev)\n{\n\tstruct acpi_device *adev = ACPI_COMPANION(&pdev->dev);\n\tunion acpi_object *obj, argv4, req;\n\tint status = 0;\n\n\t \n\tif (!acpi_check_dsm(adev->handle, &pci_acpi_dsm_guid, 5,\n\t\t\t    1ULL << EDR_PORT_DPC_ENABLE_DSM))\n\t\treturn 0;\n\n\treq.type = ACPI_TYPE_INTEGER;\n\treq.integer.value = 1;\n\n\targv4.type = ACPI_TYPE_PACKAGE;\n\targv4.package.count = 1;\n\targv4.package.elements = &req;\n\n\t \n\tobj = acpi_evaluate_dsm(adev->handle, &pci_acpi_dsm_guid, 5,\n\t\t\t\tEDR_PORT_DPC_ENABLE_DSM, &argv4);\n\tif (!obj)\n\t\treturn 0;\n\n\tif (obj->type != ACPI_TYPE_INTEGER) {\n\t\tpci_err(pdev, FW_BUG \"Enable DPC _DSM returned non integer\\n\");\n\t\tstatus = -EIO;\n\t}\n\n\tif (obj->integer.value != 1) {\n\t\tpci_err(pdev, \"Enable DPC _DSM failed to enable DPC\\n\");\n\t\tstatus = -EIO;\n\t}\n\n\tACPI_FREE(obj);\n\n\treturn status;\n}\n\n \nstatic struct pci_dev *acpi_dpc_port_get(struct pci_dev *pdev)\n{\n\tstruct acpi_device *adev = ACPI_COMPANION(&pdev->dev);\n\tunion acpi_object *obj;\n\tu16 port;\n\n\t \n\tif (!acpi_check_dsm(adev->handle, &pci_acpi_dsm_guid, 5,\n\t\t\t    1ULL << EDR_PORT_LOCATE_DSM))\n\t\treturn pci_dev_get(pdev);\n\n\tobj = acpi_evaluate_dsm(adev->handle, &pci_acpi_dsm_guid, 5,\n\t\t\t\tEDR_PORT_LOCATE_DSM, NULL);\n\tif (!obj)\n\t\treturn pci_dev_get(pdev);\n\n\tif (obj->type != ACPI_TYPE_INTEGER) {\n\t\tACPI_FREE(obj);\n\t\tpci_err(pdev, FW_BUG \"Locate Port _DSM returned non integer\\n\");\n\t\treturn NULL;\n\t}\n\n\t \n\tport = obj->integer.value;\n\n\tACPI_FREE(obj);\n\n\treturn pci_get_domain_bus_and_slot(pci_domain_nr(pdev->bus),\n\t\t\t\t\t   PCI_BUS_NUM(port), port & 0xff);\n}\n\n \nstatic int acpi_send_edr_status(struct pci_dev *pdev, struct pci_dev *edev,\n\t\t\t\tu16 status)\n{\n\tstruct acpi_device *adev = ACPI_COMPANION(&pdev->dev);\n\tu32 ost_status;\n\n\tpci_dbg(pdev, \"Status for %s: %#x\\n\", pci_name(edev), status);\n\n\tost_status = PCI_DEVID(edev->bus->number, edev->devfn) << 16;\n\tost_status |= status;\n\n\tstatus = acpi_evaluate_ost(adev->handle, ACPI_NOTIFY_DISCONNECT_RECOVER,\n\t\t\t\t   ost_status, NULL);\n\tif (ACPI_FAILURE(status))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic void edr_handle_event(acpi_handle handle, u32 event, void *data)\n{\n\tstruct pci_dev *pdev = data, *edev;\n\tpci_ers_result_t estate = PCI_ERS_RESULT_DISCONNECT;\n\tu16 status;\n\n\tif (event != ACPI_NOTIFY_DISCONNECT_RECOVER)\n\t\treturn;\n\n\t \n\tpci_info(pdev, \"EDR event received\\n\");\n\n\t \n\tedev = acpi_dpc_port_get(pdev);\n\tif (!edev) {\n\t\tpci_err(pdev, \"Firmware failed to locate DPC port\\n\");\n\t\treturn;\n\t}\n\n\tpci_dbg(pdev, \"Reported EDR dev: %s\\n\", pci_name(edev));\n\n\t \n\tif (!edev->dpc_cap) {\n\t\tpci_err(edev, FW_BUG \"This device doesn't support DPC\\n\");\n\t\tgoto send_ost;\n\t}\n\n\t \n\tpci_read_config_word(edev, edev->dpc_cap + PCI_EXP_DPC_STATUS, &status);\n\tif (!(status & PCI_EXP_DPC_STATUS_TRIGGER)) {\n\t\tpci_err(edev, \"Invalid DPC trigger %#010x\\n\", status);\n\t\tgoto send_ost;\n\t}\n\n\tdpc_process_error(edev);\n\tpci_aer_raw_clear_status(edev);\n\n\t \n\testate = pcie_do_recovery(edev, pci_channel_io_frozen, dpc_reset_link);\n\nsend_ost:\n\n\t \n\tif (estate == PCI_ERS_RESULT_RECOVERED) {\n\t\tpci_dbg(edev, \"DPC port successfully recovered\\n\");\n\t\tpcie_clear_device_status(edev);\n\t\tacpi_send_edr_status(pdev, edev, EDR_OST_SUCCESS);\n\t} else {\n\t\tpci_dbg(edev, \"DPC port recovery failed\\n\");\n\t\tacpi_send_edr_status(pdev, edev, EDR_OST_FAILED);\n\t}\n\n\tpci_dev_put(edev);\n}\n\nvoid pci_acpi_add_edr_notifier(struct pci_dev *pdev)\n{\n\tstruct acpi_device *adev = ACPI_COMPANION(&pdev->dev);\n\tacpi_status status;\n\n\tif (!adev) {\n\t\tpci_dbg(pdev, \"No valid ACPI node, skipping EDR init\\n\");\n\t\treturn;\n\t}\n\n\tstatus = acpi_install_notify_handler(adev->handle, ACPI_SYSTEM_NOTIFY,\n\t\t\t\t\t     edr_handle_event, pdev);\n\tif (ACPI_FAILURE(status)) {\n\t\tpci_err(pdev, \"Failed to install notify handler\\n\");\n\t\treturn;\n\t}\n\n\tif (acpi_enable_dpc(pdev))\n\t\tacpi_remove_notify_handler(adev->handle, ACPI_SYSTEM_NOTIFY,\n\t\t\t\t\t   edr_handle_event);\n\telse\n\t\tpci_dbg(pdev, \"Notify handler installed\\n\");\n}\n\nvoid pci_acpi_remove_edr_notifier(struct pci_dev *pdev)\n{\n\tstruct acpi_device *adev = ACPI_COMPANION(&pdev->dev);\n\n\tif (!adev)\n\t\treturn;\n\n\tacpi_remove_notify_handler(adev->handle, ACPI_SYSTEM_NOTIFY,\n\t\t\t\t   edr_handle_event);\n\tpci_dbg(pdev, \"Notify handler removed\\n\");\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}