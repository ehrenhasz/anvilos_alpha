{
  "module_name": "aer_inject.c",
  "hash_id": "652e5c79b52daf947a42e836846e9eb425b1594c3ffe176b6a0952e28fce2740",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/pcie/aer_inject.c",
  "human_readable_source": "\n \n\n#define dev_fmt(fmt) \"aer_inject: \" fmt\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/miscdevice.h>\n#include <linux/pci.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/uaccess.h>\n#include <linux/stddef.h>\n#include <linux/device.h>\n\n#include \"portdrv.h\"\n\n \nstatic bool aer_mask_override;\nmodule_param(aer_mask_override, bool, 0);\n\nstruct aer_error_inj {\n\tu8 bus;\n\tu8 dev;\n\tu8 fn;\n\tu32 uncor_status;\n\tu32 cor_status;\n\tu32 header_log0;\n\tu32 header_log1;\n\tu32 header_log2;\n\tu32 header_log3;\n\tu32 domain;\n};\n\nstruct aer_error {\n\tstruct list_head list;\n\tu32 domain;\n\tunsigned int bus;\n\tunsigned int devfn;\n\tint pos_cap_err;\n\n\tu32 uncor_status;\n\tu32 cor_status;\n\tu32 header_log0;\n\tu32 header_log1;\n\tu32 header_log2;\n\tu32 header_log3;\n\tu32 root_status;\n\tu32 source_id;\n};\n\nstruct pci_bus_ops {\n\tstruct list_head list;\n\tstruct pci_bus *bus;\n\tstruct pci_ops *ops;\n};\n\nstatic LIST_HEAD(einjected);\n\nstatic LIST_HEAD(pci_bus_ops_list);\n\n \nstatic DEFINE_SPINLOCK(inject_lock);\n\nstatic void aer_error_init(struct aer_error *err, u32 domain,\n\t\t\t   unsigned int bus, unsigned int devfn,\n\t\t\t   int pos_cap_err)\n{\n\tINIT_LIST_HEAD(&err->list);\n\terr->domain = domain;\n\terr->bus = bus;\n\terr->devfn = devfn;\n\terr->pos_cap_err = pos_cap_err;\n}\n\n \nstatic struct aer_error *__find_aer_error(u32 domain, unsigned int bus,\n\t\t\t\t\t  unsigned int devfn)\n{\n\tstruct aer_error *err;\n\n\tlist_for_each_entry(err, &einjected, list) {\n\t\tif (domain == err->domain &&\n\t\t    bus == err->bus &&\n\t\t    devfn == err->devfn)\n\t\t\treturn err;\n\t}\n\treturn NULL;\n}\n\n \nstatic struct aer_error *__find_aer_error_by_dev(struct pci_dev *dev)\n{\n\tint domain = pci_domain_nr(dev->bus);\n\tif (domain < 0)\n\t\treturn NULL;\n\treturn __find_aer_error(domain, dev->bus->number, dev->devfn);\n}\n\n \nstatic struct pci_ops *__find_pci_bus_ops(struct pci_bus *bus)\n{\n\tstruct pci_bus_ops *bus_ops;\n\n\tlist_for_each_entry(bus_ops, &pci_bus_ops_list, list) {\n\t\tif (bus_ops->bus == bus)\n\t\t\treturn bus_ops->ops;\n\t}\n\treturn NULL;\n}\n\nstatic struct pci_bus_ops *pci_bus_ops_pop(void)\n{\n\tunsigned long flags;\n\tstruct pci_bus_ops *bus_ops;\n\n\tspin_lock_irqsave(&inject_lock, flags);\n\tbus_ops = list_first_entry_or_null(&pci_bus_ops_list,\n\t\t\t\t\t   struct pci_bus_ops, list);\n\tif (bus_ops)\n\t\tlist_del(&bus_ops->list);\n\tspin_unlock_irqrestore(&inject_lock, flags);\n\treturn bus_ops;\n}\n\nstatic u32 *find_pci_config_dword(struct aer_error *err, int where,\n\t\t\t\t  int *prw1cs)\n{\n\tint rw1cs = 0;\n\tu32 *target = NULL;\n\n\tif (err->pos_cap_err == -1)\n\t\treturn NULL;\n\n\tswitch (where - err->pos_cap_err) {\n\tcase PCI_ERR_UNCOR_STATUS:\n\t\ttarget = &err->uncor_status;\n\t\trw1cs = 1;\n\t\tbreak;\n\tcase PCI_ERR_COR_STATUS:\n\t\ttarget = &err->cor_status;\n\t\trw1cs = 1;\n\t\tbreak;\n\tcase PCI_ERR_HEADER_LOG:\n\t\ttarget = &err->header_log0;\n\t\tbreak;\n\tcase PCI_ERR_HEADER_LOG+4:\n\t\ttarget = &err->header_log1;\n\t\tbreak;\n\tcase PCI_ERR_HEADER_LOG+8:\n\t\ttarget = &err->header_log2;\n\t\tbreak;\n\tcase PCI_ERR_HEADER_LOG+12:\n\t\ttarget = &err->header_log3;\n\t\tbreak;\n\tcase PCI_ERR_ROOT_STATUS:\n\t\ttarget = &err->root_status;\n\t\trw1cs = 1;\n\t\tbreak;\n\tcase PCI_ERR_ROOT_ERR_SRC:\n\t\ttarget = &err->source_id;\n\t\tbreak;\n\t}\n\tif (prw1cs)\n\t\t*prw1cs = rw1cs;\n\treturn target;\n}\n\nstatic int aer_inj_read(struct pci_bus *bus, unsigned int devfn, int where,\n\t\t\tint size, u32 *val)\n{\n\tstruct pci_ops *ops, *my_ops;\n\tint rv;\n\n\tops = __find_pci_bus_ops(bus);\n\tif (!ops)\n\t\treturn -1;\n\n\tmy_ops = bus->ops;\n\tbus->ops = ops;\n\trv = ops->read(bus, devfn, where, size, val);\n\tbus->ops = my_ops;\n\n\treturn rv;\n}\n\nstatic int aer_inj_write(struct pci_bus *bus, unsigned int devfn, int where,\n\t\t\t int size, u32 val)\n{\n\tstruct pci_ops *ops, *my_ops;\n\tint rv;\n\n\tops = __find_pci_bus_ops(bus);\n\tif (!ops)\n\t\treturn -1;\n\n\tmy_ops = bus->ops;\n\tbus->ops = ops;\n\trv = ops->write(bus, devfn, where, size, val);\n\tbus->ops = my_ops;\n\n\treturn rv;\n}\n\nstatic int aer_inj_read_config(struct pci_bus *bus, unsigned int devfn,\n\t\t\t       int where, int size, u32 *val)\n{\n\tu32 *sim;\n\tstruct aer_error *err;\n\tunsigned long flags;\n\tint domain;\n\tint rv;\n\n\tspin_lock_irqsave(&inject_lock, flags);\n\tif (size != sizeof(u32))\n\t\tgoto out;\n\tdomain = pci_domain_nr(bus);\n\tif (domain < 0)\n\t\tgoto out;\n\terr = __find_aer_error(domain, bus->number, devfn);\n\tif (!err)\n\t\tgoto out;\n\n\tsim = find_pci_config_dword(err, where, NULL);\n\tif (sim) {\n\t\t*val = *sim;\n\t\tspin_unlock_irqrestore(&inject_lock, flags);\n\t\treturn 0;\n\t}\nout:\n\trv = aer_inj_read(bus, devfn, where, size, val);\n\tspin_unlock_irqrestore(&inject_lock, flags);\n\treturn rv;\n}\n\nstatic int aer_inj_write_config(struct pci_bus *bus, unsigned int devfn,\n\t\t\t\tint where, int size, u32 val)\n{\n\tu32 *sim;\n\tstruct aer_error *err;\n\tunsigned long flags;\n\tint rw1cs;\n\tint domain;\n\tint rv;\n\n\tspin_lock_irqsave(&inject_lock, flags);\n\tif (size != sizeof(u32))\n\t\tgoto out;\n\tdomain = pci_domain_nr(bus);\n\tif (domain < 0)\n\t\tgoto out;\n\terr = __find_aer_error(domain, bus->number, devfn);\n\tif (!err)\n\t\tgoto out;\n\n\tsim = find_pci_config_dword(err, where, &rw1cs);\n\tif (sim) {\n\t\tif (rw1cs)\n\t\t\t*sim ^= val;\n\t\telse\n\t\t\t*sim = val;\n\t\tspin_unlock_irqrestore(&inject_lock, flags);\n\t\treturn 0;\n\t}\nout:\n\trv = aer_inj_write(bus, devfn, where, size, val);\n\tspin_unlock_irqrestore(&inject_lock, flags);\n\treturn rv;\n}\n\nstatic struct pci_ops aer_inj_pci_ops = {\n\t.read = aer_inj_read_config,\n\t.write = aer_inj_write_config,\n};\n\nstatic void pci_bus_ops_init(struct pci_bus_ops *bus_ops,\n\t\t\t     struct pci_bus *bus,\n\t\t\t     struct pci_ops *ops)\n{\n\tINIT_LIST_HEAD(&bus_ops->list);\n\tbus_ops->bus = bus;\n\tbus_ops->ops = ops;\n}\n\nstatic int pci_bus_set_aer_ops(struct pci_bus *bus)\n{\n\tstruct pci_ops *ops;\n\tstruct pci_bus_ops *bus_ops;\n\tunsigned long flags;\n\n\tbus_ops = kmalloc(sizeof(*bus_ops), GFP_KERNEL);\n\tif (!bus_ops)\n\t\treturn -ENOMEM;\n\tops = pci_bus_set_ops(bus, &aer_inj_pci_ops);\n\tspin_lock_irqsave(&inject_lock, flags);\n\tif (ops == &aer_inj_pci_ops)\n\t\tgoto out;\n\tpci_bus_ops_init(bus_ops, bus, ops);\n\tlist_add(&bus_ops->list, &pci_bus_ops_list);\n\tbus_ops = NULL;\nout:\n\tspin_unlock_irqrestore(&inject_lock, flags);\n\tkfree(bus_ops);\n\treturn 0;\n}\n\nstatic int aer_inject(struct aer_error_inj *einj)\n{\n\tstruct aer_error *err, *rperr;\n\tstruct aer_error *err_alloc = NULL, *rperr_alloc = NULL;\n\tstruct pci_dev *dev, *rpdev;\n\tstruct pcie_device *edev;\n\tstruct device *device;\n\tunsigned long flags;\n\tunsigned int devfn = PCI_DEVFN(einj->dev, einj->fn);\n\tint pos_cap_err, rp_pos_cap_err;\n\tu32 sever, cor_mask, uncor_mask, cor_mask_orig = 0, uncor_mask_orig = 0;\n\tint ret = 0;\n\n\tdev = pci_get_domain_bus_and_slot(einj->domain, einj->bus, devfn);\n\tif (!dev)\n\t\treturn -ENODEV;\n\trpdev = pcie_find_root_port(dev);\n\t \n\tif (!rpdev)\n\t\trpdev = dev->rcec;\n\tif (!rpdev) {\n\t\tpci_err(dev, \"Neither Root Port nor RCEC found\\n\");\n\t\tret = -ENODEV;\n\t\tgoto out_put;\n\t}\n\n\tpos_cap_err = dev->aer_cap;\n\tif (!pos_cap_err) {\n\t\tpci_err(dev, \"Device doesn't support AER\\n\");\n\t\tret = -EPROTONOSUPPORT;\n\t\tgoto out_put;\n\t}\n\tpci_read_config_dword(dev, pos_cap_err + PCI_ERR_UNCOR_SEVER, &sever);\n\tpci_read_config_dword(dev, pos_cap_err + PCI_ERR_COR_MASK, &cor_mask);\n\tpci_read_config_dword(dev, pos_cap_err + PCI_ERR_UNCOR_MASK,\n\t\t\t      &uncor_mask);\n\n\trp_pos_cap_err = rpdev->aer_cap;\n\tif (!rp_pos_cap_err) {\n\t\tpci_err(rpdev, \"Root port doesn't support AER\\n\");\n\t\tret = -EPROTONOSUPPORT;\n\t\tgoto out_put;\n\t}\n\n\terr_alloc =  kzalloc(sizeof(struct aer_error), GFP_KERNEL);\n\tif (!err_alloc) {\n\t\tret = -ENOMEM;\n\t\tgoto out_put;\n\t}\n\trperr_alloc =  kzalloc(sizeof(struct aer_error), GFP_KERNEL);\n\tif (!rperr_alloc) {\n\t\tret = -ENOMEM;\n\t\tgoto out_put;\n\t}\n\n\tif (aer_mask_override) {\n\t\tcor_mask_orig = cor_mask;\n\t\tcor_mask &= !(einj->cor_status);\n\t\tpci_write_config_dword(dev, pos_cap_err + PCI_ERR_COR_MASK,\n\t\t\t\t       cor_mask);\n\n\t\tuncor_mask_orig = uncor_mask;\n\t\tuncor_mask &= !(einj->uncor_status);\n\t\tpci_write_config_dword(dev, pos_cap_err + PCI_ERR_UNCOR_MASK,\n\t\t\t\t       uncor_mask);\n\t}\n\n\tspin_lock_irqsave(&inject_lock, flags);\n\n\terr = __find_aer_error_by_dev(dev);\n\tif (!err) {\n\t\terr = err_alloc;\n\t\terr_alloc = NULL;\n\t\taer_error_init(err, einj->domain, einj->bus, devfn,\n\t\t\t       pos_cap_err);\n\t\tlist_add(&err->list, &einjected);\n\t}\n\terr->uncor_status |= einj->uncor_status;\n\terr->cor_status |= einj->cor_status;\n\terr->header_log0 = einj->header_log0;\n\terr->header_log1 = einj->header_log1;\n\terr->header_log2 = einj->header_log2;\n\terr->header_log3 = einj->header_log3;\n\n\tif (!aer_mask_override && einj->cor_status &&\n\t    !(einj->cor_status & ~cor_mask)) {\n\t\tret = -EINVAL;\n\t\tpci_warn(dev, \"The correctable error(s) is masked by device\\n\");\n\t\tspin_unlock_irqrestore(&inject_lock, flags);\n\t\tgoto out_put;\n\t}\n\tif (!aer_mask_override && einj->uncor_status &&\n\t    !(einj->uncor_status & ~uncor_mask)) {\n\t\tret = -EINVAL;\n\t\tpci_warn(dev, \"The uncorrectable error(s) is masked by device\\n\");\n\t\tspin_unlock_irqrestore(&inject_lock, flags);\n\t\tgoto out_put;\n\t}\n\n\trperr = __find_aer_error_by_dev(rpdev);\n\tif (!rperr) {\n\t\trperr = rperr_alloc;\n\t\trperr_alloc = NULL;\n\t\taer_error_init(rperr, pci_domain_nr(rpdev->bus),\n\t\t\t       rpdev->bus->number, rpdev->devfn,\n\t\t\t       rp_pos_cap_err);\n\t\tlist_add(&rperr->list, &einjected);\n\t}\n\tif (einj->cor_status) {\n\t\tif (rperr->root_status & PCI_ERR_ROOT_COR_RCV)\n\t\t\trperr->root_status |= PCI_ERR_ROOT_MULTI_COR_RCV;\n\t\telse\n\t\t\trperr->root_status |= PCI_ERR_ROOT_COR_RCV;\n\t\trperr->source_id &= 0xffff0000;\n\t\trperr->source_id |= (einj->bus << 8) | devfn;\n\t}\n\tif (einj->uncor_status) {\n\t\tif (rperr->root_status & PCI_ERR_ROOT_UNCOR_RCV)\n\t\t\trperr->root_status |= PCI_ERR_ROOT_MULTI_UNCOR_RCV;\n\t\tif (sever & einj->uncor_status) {\n\t\t\trperr->root_status |= PCI_ERR_ROOT_FATAL_RCV;\n\t\t\tif (!(rperr->root_status & PCI_ERR_ROOT_UNCOR_RCV))\n\t\t\t\trperr->root_status |= PCI_ERR_ROOT_FIRST_FATAL;\n\t\t} else\n\t\t\trperr->root_status |= PCI_ERR_ROOT_NONFATAL_RCV;\n\t\trperr->root_status |= PCI_ERR_ROOT_UNCOR_RCV;\n\t\trperr->source_id &= 0x0000ffff;\n\t\trperr->source_id |= ((einj->bus << 8) | devfn) << 16;\n\t}\n\tspin_unlock_irqrestore(&inject_lock, flags);\n\n\tif (aer_mask_override) {\n\t\tpci_write_config_dword(dev, pos_cap_err + PCI_ERR_COR_MASK,\n\t\t\t\t       cor_mask_orig);\n\t\tpci_write_config_dword(dev, pos_cap_err + PCI_ERR_UNCOR_MASK,\n\t\t\t\t       uncor_mask_orig);\n\t}\n\n\tret = pci_bus_set_aer_ops(dev->bus);\n\tif (ret)\n\t\tgoto out_put;\n\tret = pci_bus_set_aer_ops(rpdev->bus);\n\tif (ret)\n\t\tgoto out_put;\n\n\tdevice = pcie_port_find_device(rpdev, PCIE_PORT_SERVICE_AER);\n\tif (device) {\n\t\tedev = to_pcie_device(device);\n\t\tif (!get_service_data(edev)) {\n\t\t\tpci_warn(edev->port, \"AER service is not initialized\\n\");\n\t\t\tret = -EPROTONOSUPPORT;\n\t\t\tgoto out_put;\n\t\t}\n\t\tpci_info(edev->port, \"Injecting errors %08x/%08x into device %s\\n\",\n\t\t\t einj->cor_status, einj->uncor_status, pci_name(dev));\n\t\tret = irq_inject_interrupt(edev->irq);\n\t} else {\n\t\tpci_err(rpdev, \"AER device not found\\n\");\n\t\tret = -ENODEV;\n\t}\nout_put:\n\tkfree(err_alloc);\n\tkfree(rperr_alloc);\n\tpci_dev_put(dev);\n\treturn ret;\n}\n\nstatic ssize_t aer_inject_write(struct file *filp, const char __user *ubuf,\n\t\t\t\tsize_t usize, loff_t *off)\n{\n\tstruct aer_error_inj einj;\n\tint ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\tif (usize < offsetof(struct aer_error_inj, domain) ||\n\t    usize > sizeof(einj))\n\t\treturn -EINVAL;\n\n\tmemset(&einj, 0, sizeof(einj));\n\tif (copy_from_user(&einj, ubuf, usize))\n\t\treturn -EFAULT;\n\n\tret = aer_inject(&einj);\n\treturn ret ? ret : usize;\n}\n\nstatic const struct file_operations aer_inject_fops = {\n\t.write = aer_inject_write,\n\t.owner = THIS_MODULE,\n\t.llseek = noop_llseek,\n};\n\nstatic struct miscdevice aer_inject_device = {\n\t.minor = MISC_DYNAMIC_MINOR,\n\t.name = \"aer_inject\",\n\t.fops = &aer_inject_fops,\n};\n\nstatic int __init aer_inject_init(void)\n{\n\treturn misc_register(&aer_inject_device);\n}\n\nstatic void __exit aer_inject_exit(void)\n{\n\tstruct aer_error *err, *err_next;\n\tunsigned long flags;\n\tstruct pci_bus_ops *bus_ops;\n\n\tmisc_deregister(&aer_inject_device);\n\n\twhile ((bus_ops = pci_bus_ops_pop())) {\n\t\tpci_bus_set_ops(bus_ops->bus, bus_ops->ops);\n\t\tkfree(bus_ops);\n\t}\n\n\tspin_lock_irqsave(&inject_lock, flags);\n\tlist_for_each_entry_safe(err, err_next, &einjected, list) {\n\t\tlist_del(&err->list);\n\t\tkfree(err);\n\t}\n\tspin_unlock_irqrestore(&inject_lock, flags);\n}\n\nmodule_init(aer_inject_init);\nmodule_exit(aer_inject_exit);\n\nMODULE_DESCRIPTION(\"PCIe AER software error injector\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}