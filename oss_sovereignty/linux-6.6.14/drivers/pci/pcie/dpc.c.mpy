{
  "module_name": "dpc.c",
  "hash_id": "77bc9a83e18d5db2a79b56f82f22f2a2cb461e3bcc22093380e975c701e21e1a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/pcie/dpc.c",
  "human_readable_source": "\n \n\n#define dev_fmt(fmt) \"DPC: \" fmt\n\n#include <linux/aer.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/pci.h>\n\n#include \"portdrv.h\"\n#include \"../pci.h\"\n\nstatic const char * const rp_pio_error_string[] = {\n\t\"Configuration Request received UR Completion\",\t  \n\t\"Configuration Request received CA Completion\",\t  \n\t\"Configuration Request Completion Timeout\",\t  \n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\t\"I/O Request received UR Completion\",\t\t  \n\t\"I/O Request received CA Completion\",\t\t  \n\t\"I/O Request Completion Timeout\",\t\t  \n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\t\"Memory Request received UR Completion\",\t  \n\t\"Memory Request received CA Completion\",\t  \n\t\"Memory Request Completion Timeout\",\t\t  \n};\n\nvoid pci_save_dpc_state(struct pci_dev *dev)\n{\n\tstruct pci_cap_saved_state *save_state;\n\tu16 *cap;\n\n\tif (!pci_is_pcie(dev))\n\t\treturn;\n\n\tsave_state = pci_find_saved_ext_cap(dev, PCI_EXT_CAP_ID_DPC);\n\tif (!save_state)\n\t\treturn;\n\n\tcap = (u16 *)&save_state->cap.data[0];\n\tpci_read_config_word(dev, dev->dpc_cap + PCI_EXP_DPC_CTL, cap);\n}\n\nvoid pci_restore_dpc_state(struct pci_dev *dev)\n{\n\tstruct pci_cap_saved_state *save_state;\n\tu16 *cap;\n\n\tif (!pci_is_pcie(dev))\n\t\treturn;\n\n\tsave_state = pci_find_saved_ext_cap(dev, PCI_EXT_CAP_ID_DPC);\n\tif (!save_state)\n\t\treturn;\n\n\tcap = (u16 *)&save_state->cap.data[0];\n\tpci_write_config_word(dev, dev->dpc_cap + PCI_EXP_DPC_CTL, *cap);\n}\n\nstatic DECLARE_WAIT_QUEUE_HEAD(dpc_completed_waitqueue);\n\n#ifdef CONFIG_HOTPLUG_PCI_PCIE\nstatic bool dpc_completed(struct pci_dev *pdev)\n{\n\tu16 status;\n\n\tpci_read_config_word(pdev, pdev->dpc_cap + PCI_EXP_DPC_STATUS, &status);\n\tif ((!PCI_POSSIBLE_ERROR(status)) && (status & PCI_EXP_DPC_STATUS_TRIGGER))\n\t\treturn false;\n\n\tif (test_bit(PCI_DPC_RECOVERING, &pdev->priv_flags))\n\t\treturn false;\n\n\treturn true;\n}\n\n \nbool pci_dpc_recovered(struct pci_dev *pdev)\n{\n\tstruct pci_host_bridge *host;\n\n\tif (!pdev->dpc_cap)\n\t\treturn false;\n\n\t \n\thost = pci_find_host_bridge(pdev->bus);\n\tif (!host->native_dpc && !IS_ENABLED(CONFIG_PCIE_EDR))\n\t\treturn false;\n\n\t \n\twait_event_timeout(dpc_completed_waitqueue, dpc_completed(pdev),\n\t\t\t   msecs_to_jiffies(4000));\n\n\treturn test_and_clear_bit(PCI_DPC_RECOVERED, &pdev->priv_flags);\n}\n#endif  \n\nstatic int dpc_wait_rp_inactive(struct pci_dev *pdev)\n{\n\tunsigned long timeout = jiffies + HZ;\n\tu16 cap = pdev->dpc_cap, status;\n\n\tpci_read_config_word(pdev, cap + PCI_EXP_DPC_STATUS, &status);\n\twhile (status & PCI_EXP_DPC_RP_BUSY &&\n\t\t\t\t\t!time_after(jiffies, timeout)) {\n\t\tmsleep(10);\n\t\tpci_read_config_word(pdev, cap + PCI_EXP_DPC_STATUS, &status);\n\t}\n\tif (status & PCI_EXP_DPC_RP_BUSY) {\n\t\tpci_warn(pdev, \"root port still busy\\n\");\n\t\treturn -EBUSY;\n\t}\n\treturn 0;\n}\n\npci_ers_result_t dpc_reset_link(struct pci_dev *pdev)\n{\n\tpci_ers_result_t ret;\n\tu16 cap;\n\n\tset_bit(PCI_DPC_RECOVERING, &pdev->priv_flags);\n\n\t \n\tcap = pdev->dpc_cap;\n\n\t \n\tif (!pcie_wait_for_link(pdev, false))\n\t\tpci_info(pdev, \"Data Link Layer Link Active not cleared in 1000 msec\\n\");\n\n\tif (pdev->dpc_rp_extensions && dpc_wait_rp_inactive(pdev)) {\n\t\tclear_bit(PCI_DPC_RECOVERED, &pdev->priv_flags);\n\t\tret = PCI_ERS_RESULT_DISCONNECT;\n\t\tgoto out;\n\t}\n\n\tpci_write_config_word(pdev, cap + PCI_EXP_DPC_STATUS,\n\t\t\t      PCI_EXP_DPC_STATUS_TRIGGER);\n\n\tif (pci_bridge_wait_for_secondary_bus(pdev, \"DPC\")) {\n\t\tclear_bit(PCI_DPC_RECOVERED, &pdev->priv_flags);\n\t\tret = PCI_ERS_RESULT_DISCONNECT;\n\t} else {\n\t\tset_bit(PCI_DPC_RECOVERED, &pdev->priv_flags);\n\t\tret = PCI_ERS_RESULT_RECOVERED;\n\t}\nout:\n\tclear_bit(PCI_DPC_RECOVERING, &pdev->priv_flags);\n\twake_up_all(&dpc_completed_waitqueue);\n\treturn ret;\n}\n\nstatic void dpc_process_rp_pio_error(struct pci_dev *pdev)\n{\n\tu16 cap = pdev->dpc_cap, dpc_status, first_error;\n\tu32 status, mask, sev, syserr, exc, dw0, dw1, dw2, dw3, log, prefix;\n\tint i;\n\n\tpci_read_config_dword(pdev, cap + PCI_EXP_DPC_RP_PIO_STATUS, &status);\n\tpci_read_config_dword(pdev, cap + PCI_EXP_DPC_RP_PIO_MASK, &mask);\n\tpci_err(pdev, \"rp_pio_status: %#010x, rp_pio_mask: %#010x\\n\",\n\t\tstatus, mask);\n\n\tpci_read_config_dword(pdev, cap + PCI_EXP_DPC_RP_PIO_SEVERITY, &sev);\n\tpci_read_config_dword(pdev, cap + PCI_EXP_DPC_RP_PIO_SYSERROR, &syserr);\n\tpci_read_config_dword(pdev, cap + PCI_EXP_DPC_RP_PIO_EXCEPTION, &exc);\n\tpci_err(pdev, \"RP PIO severity=%#010x, syserror=%#010x, exception=%#010x\\n\",\n\t\tsev, syserr, exc);\n\n\t \n\tpci_read_config_word(pdev, cap + PCI_EXP_DPC_STATUS, &dpc_status);\n\tfirst_error = (dpc_status & 0x1f00) >> 8;\n\n\tfor (i = 0; i < ARRAY_SIZE(rp_pio_error_string); i++) {\n\t\tif ((status & ~mask) & (1 << i))\n\t\t\tpci_err(pdev, \"[%2d] %s%s\\n\", i, rp_pio_error_string[i],\n\t\t\t\tfirst_error == i ? \" (First)\" : \"\");\n\t}\n\n\tif (pdev->dpc_rp_log_size < 4)\n\t\tgoto clear_status;\n\tpci_read_config_dword(pdev, cap + PCI_EXP_DPC_RP_PIO_HEADER_LOG,\n\t\t\t      &dw0);\n\tpci_read_config_dword(pdev, cap + PCI_EXP_DPC_RP_PIO_HEADER_LOG + 4,\n\t\t\t      &dw1);\n\tpci_read_config_dword(pdev, cap + PCI_EXP_DPC_RP_PIO_HEADER_LOG + 8,\n\t\t\t      &dw2);\n\tpci_read_config_dword(pdev, cap + PCI_EXP_DPC_RP_PIO_HEADER_LOG + 12,\n\t\t\t      &dw3);\n\tpci_err(pdev, \"TLP Header: %#010x %#010x %#010x %#010x\\n\",\n\t\tdw0, dw1, dw2, dw3);\n\n\tif (pdev->dpc_rp_log_size < 5)\n\t\tgoto clear_status;\n\tpci_read_config_dword(pdev, cap + PCI_EXP_DPC_RP_PIO_IMPSPEC_LOG, &log);\n\tpci_err(pdev, \"RP PIO ImpSpec Log %#010x\\n\", log);\n\n\tfor (i = 0; i < pdev->dpc_rp_log_size - 5; i++) {\n\t\tpci_read_config_dword(pdev,\n\t\t\tcap + PCI_EXP_DPC_RP_PIO_TLPPREFIX_LOG, &prefix);\n\t\tpci_err(pdev, \"TLP Prefix Header: dw%d, %#010x\\n\", i, prefix);\n\t}\n clear_status:\n\tpci_write_config_dword(pdev, cap + PCI_EXP_DPC_RP_PIO_STATUS, status);\n}\n\nstatic int dpc_get_aer_uncorrect_severity(struct pci_dev *dev,\n\t\t\t\t\t  struct aer_err_info *info)\n{\n\tint pos = dev->aer_cap;\n\tu32 status, mask, sev;\n\n\tpci_read_config_dword(dev, pos + PCI_ERR_UNCOR_STATUS, &status);\n\tpci_read_config_dword(dev, pos + PCI_ERR_UNCOR_MASK, &mask);\n\tstatus &= ~mask;\n\tif (!status)\n\t\treturn 0;\n\n\tpci_read_config_dword(dev, pos + PCI_ERR_UNCOR_SEVER, &sev);\n\tstatus &= sev;\n\tif (status)\n\t\tinfo->severity = AER_FATAL;\n\telse\n\t\tinfo->severity = AER_NONFATAL;\n\n\treturn 1;\n}\n\nvoid dpc_process_error(struct pci_dev *pdev)\n{\n\tu16 cap = pdev->dpc_cap, status, source, reason, ext_reason;\n\tstruct aer_err_info info;\n\n\tpci_read_config_word(pdev, cap + PCI_EXP_DPC_STATUS, &status);\n\tpci_read_config_word(pdev, cap + PCI_EXP_DPC_SOURCE_ID, &source);\n\n\tpci_info(pdev, \"containment event, status:%#06x source:%#06x\\n\",\n\t\t status, source);\n\n\treason = (status & PCI_EXP_DPC_STATUS_TRIGGER_RSN) >> 1;\n\text_reason = (status & PCI_EXP_DPC_STATUS_TRIGGER_RSN_EXT) >> 5;\n\tpci_warn(pdev, \"%s detected\\n\",\n\t\t (reason == 0) ? \"unmasked uncorrectable error\" :\n\t\t (reason == 1) ? \"ERR_NONFATAL\" :\n\t\t (reason == 2) ? \"ERR_FATAL\" :\n\t\t (ext_reason == 0) ? \"RP PIO error\" :\n\t\t (ext_reason == 1) ? \"software trigger\" :\n\t\t\t\t     \"reserved error\");\n\n\t \n\tif (pdev->dpc_rp_extensions && reason == 3 && ext_reason == 0)\n\t\tdpc_process_rp_pio_error(pdev);\n\telse if (reason == 0 &&\n\t\t dpc_get_aer_uncorrect_severity(pdev, &info) &&\n\t\t aer_get_device_error_info(pdev, &info)) {\n\t\taer_print_error(pdev, &info);\n\t\tpci_aer_clear_nonfatal_status(pdev);\n\t\tpci_aer_clear_fatal_status(pdev);\n\t}\n}\n\nstatic irqreturn_t dpc_handler(int irq, void *context)\n{\n\tstruct pci_dev *pdev = context;\n\n\tdpc_process_error(pdev);\n\n\t \n\tpcie_do_recovery(pdev, pci_channel_io_frozen, dpc_reset_link);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t dpc_irq(int irq, void *context)\n{\n\tstruct pci_dev *pdev = context;\n\tu16 cap = pdev->dpc_cap, status;\n\n\tpci_read_config_word(pdev, cap + PCI_EXP_DPC_STATUS, &status);\n\n\tif (!(status & PCI_EXP_DPC_STATUS_INTERRUPT) || PCI_POSSIBLE_ERROR(status))\n\t\treturn IRQ_NONE;\n\n\tpci_write_config_word(pdev, cap + PCI_EXP_DPC_STATUS,\n\t\t\t      PCI_EXP_DPC_STATUS_INTERRUPT);\n\tif (status & PCI_EXP_DPC_STATUS_TRIGGER)\n\t\treturn IRQ_WAKE_THREAD;\n\treturn IRQ_HANDLED;\n}\n\nvoid pci_dpc_init(struct pci_dev *pdev)\n{\n\tu16 cap;\n\n\tpdev->dpc_cap = pci_find_ext_capability(pdev, PCI_EXT_CAP_ID_DPC);\n\tif (!pdev->dpc_cap)\n\t\treturn;\n\n\tpci_read_config_word(pdev, pdev->dpc_cap + PCI_EXP_DPC_CAP, &cap);\n\tif (!(cap & PCI_EXP_DPC_CAP_RP_EXT))\n\t\treturn;\n\n\tpdev->dpc_rp_extensions = true;\n\n\t \n\tif (!pdev->dpc_rp_log_size) {\n\t\tpdev->dpc_rp_log_size =\n\t\t\t(cap & PCI_EXP_DPC_RP_PIO_LOG_SIZE) >> 8;\n\t\tif (pdev->dpc_rp_log_size < 4 || pdev->dpc_rp_log_size > 9) {\n\t\t\tpci_err(pdev, \"RP PIO log size %u is invalid\\n\",\n\t\t\t\tpdev->dpc_rp_log_size);\n\t\t\tpdev->dpc_rp_log_size = 0;\n\t\t}\n\t}\n}\n\n#define FLAG(x, y) (((x) & (y)) ? '+' : '-')\nstatic int dpc_probe(struct pcie_device *dev)\n{\n\tstruct pci_dev *pdev = dev->port;\n\tstruct device *device = &dev->device;\n\tint status;\n\tu16 ctl, cap;\n\n\tif (!pcie_aer_is_native(pdev) && !pcie_ports_dpc_native)\n\t\treturn -ENOTSUPP;\n\n\tstatus = devm_request_threaded_irq(device, dev->irq, dpc_irq,\n\t\t\t\t\t   dpc_handler, IRQF_SHARED,\n\t\t\t\t\t   \"pcie-dpc\", pdev);\n\tif (status) {\n\t\tpci_warn(pdev, \"request IRQ%d failed: %d\\n\", dev->irq,\n\t\t\t status);\n\t\treturn status;\n\t}\n\n\tpci_read_config_word(pdev, pdev->dpc_cap + PCI_EXP_DPC_CAP, &cap);\n\tpci_read_config_word(pdev, pdev->dpc_cap + PCI_EXP_DPC_CTL, &ctl);\n\n\tctl = (ctl & 0xfff4) | PCI_EXP_DPC_CTL_EN_FATAL | PCI_EXP_DPC_CTL_INT_EN;\n\tpci_write_config_word(pdev, pdev->dpc_cap + PCI_EXP_DPC_CTL, ctl);\n\tpci_info(pdev, \"enabled with IRQ %d\\n\", dev->irq);\n\n\tpci_info(pdev, \"error containment capabilities: Int Msg #%d, RPExt%c PoisonedTLP%c SwTrigger%c RP PIO Log %d, DL_ActiveErr%c\\n\",\n\t\t cap & PCI_EXP_DPC_IRQ, FLAG(cap, PCI_EXP_DPC_CAP_RP_EXT),\n\t\t FLAG(cap, PCI_EXP_DPC_CAP_POISONED_TLP),\n\t\t FLAG(cap, PCI_EXP_DPC_CAP_SW_TRIGGER), pdev->dpc_rp_log_size,\n\t\t FLAG(cap, PCI_EXP_DPC_CAP_DL_ACTIVE));\n\n\tpci_add_ext_cap_save_buffer(pdev, PCI_EXT_CAP_ID_DPC, sizeof(u16));\n\treturn status;\n}\n\nstatic void dpc_remove(struct pcie_device *dev)\n{\n\tstruct pci_dev *pdev = dev->port;\n\tu16 ctl;\n\n\tpci_read_config_word(pdev, pdev->dpc_cap + PCI_EXP_DPC_CTL, &ctl);\n\tctl &= ~(PCI_EXP_DPC_CTL_EN_FATAL | PCI_EXP_DPC_CTL_INT_EN);\n\tpci_write_config_word(pdev, pdev->dpc_cap + PCI_EXP_DPC_CTL, ctl);\n}\n\nstatic struct pcie_port_service_driver dpcdriver = {\n\t.name\t\t= \"dpc\",\n\t.port_type\t= PCIE_ANY_PORT,\n\t.service\t= PCIE_PORT_SERVICE_DPC,\n\t.probe\t\t= dpc_probe,\n\t.remove\t\t= dpc_remove,\n};\n\nint __init pcie_dpc_init(void)\n{\n\treturn pcie_port_service_register(&dpcdriver);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}