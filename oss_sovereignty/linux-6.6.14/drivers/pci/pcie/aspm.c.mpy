{
  "module_name": "aspm.c",
  "hash_id": "366fd4f63918d947d0ff7b65d607ff0f7852101296d737d1bb91b68bb898c417",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/pcie/aspm.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/math.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/pci.h>\n#include <linux/pci_regs.h>\n#include <linux/errno.h>\n#include <linux/pm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include \"../pci.h\"\n\n#ifdef MODULE_PARAM_PREFIX\n#undef MODULE_PARAM_PREFIX\n#endif\n#define MODULE_PARAM_PREFIX \"pcie_aspm.\"\n\n \n#define ASPM_STATE_L0S_UP\t(1)\t \n#define ASPM_STATE_L0S_DW\t(2)\t \n#define ASPM_STATE_L1\t\t(4)\t \n#define ASPM_STATE_L1_1\t\t(8)\t \n#define ASPM_STATE_L1_2\t\t(0x10)\t \n#define ASPM_STATE_L1_1_PCIPM\t(0x20)\t \n#define ASPM_STATE_L1_2_PCIPM\t(0x40)\t \n#define ASPM_STATE_L1_SS_PCIPM\t(ASPM_STATE_L1_1_PCIPM | ASPM_STATE_L1_2_PCIPM)\n#define ASPM_STATE_L1_2_MASK\t(ASPM_STATE_L1_2 | ASPM_STATE_L1_2_PCIPM)\n#define ASPM_STATE_L1SS\t\t(ASPM_STATE_L1_1 | ASPM_STATE_L1_1_PCIPM |\\\n\t\t\t\t ASPM_STATE_L1_2_MASK)\n#define ASPM_STATE_L0S\t\t(ASPM_STATE_L0S_UP | ASPM_STATE_L0S_DW)\n#define ASPM_STATE_ALL\t\t(ASPM_STATE_L0S | ASPM_STATE_L1 |\t\\\n\t\t\t\t ASPM_STATE_L1SS)\n\nstruct pcie_link_state {\n\tstruct pci_dev *pdev;\t\t \n\tstruct pci_dev *downstream;\t \n\tstruct pcie_link_state *root;\t \n\tstruct pcie_link_state *parent;\t \n\tstruct list_head sibling;\t \n\n\t \n\tu32 aspm_support:7;\t\t \n\tu32 aspm_enabled:7;\t\t \n\tu32 aspm_capable:7;\t\t \n\tu32 aspm_default:7;\t\t \n\tu32 aspm_disable:7;\t\t \n\n\t \n\tu32 clkpm_capable:1;\t\t \n\tu32 clkpm_enabled:1;\t\t \n\tu32 clkpm_default:1;\t\t \n\tu32 clkpm_disable:1;\t\t \n};\n\nstatic int aspm_disabled, aspm_force;\nstatic bool aspm_support_enabled = true;\nstatic DEFINE_MUTEX(aspm_lock);\nstatic LIST_HEAD(link_list);\n\n#define POLICY_DEFAULT 0\t \n#define POLICY_PERFORMANCE 1\t \n#define POLICY_POWERSAVE 2\t \n#define POLICY_POWER_SUPERSAVE 3  \n\n#ifdef CONFIG_PCIEASPM_PERFORMANCE\nstatic int aspm_policy = POLICY_PERFORMANCE;\n#elif defined CONFIG_PCIEASPM_POWERSAVE\nstatic int aspm_policy = POLICY_POWERSAVE;\n#elif defined CONFIG_PCIEASPM_POWER_SUPERSAVE\nstatic int aspm_policy = POLICY_POWER_SUPERSAVE;\n#else\nstatic int aspm_policy;\n#endif\n\nstatic const char *policy_str[] = {\n\t[POLICY_DEFAULT] = \"default\",\n\t[POLICY_PERFORMANCE] = \"performance\",\n\t[POLICY_POWERSAVE] = \"powersave\",\n\t[POLICY_POWER_SUPERSAVE] = \"powersupersave\"\n};\n\n \nstatic struct pci_dev *pci_function_0(struct pci_bus *linkbus)\n{\n\tstruct pci_dev *child;\n\n\tlist_for_each_entry(child, &linkbus->devices, bus_list)\n\t\tif (PCI_FUNC(child->devfn) == 0)\n\t\t\treturn child;\n\treturn NULL;\n}\n\nstatic int policy_to_aspm_state(struct pcie_link_state *link)\n{\n\tswitch (aspm_policy) {\n\tcase POLICY_PERFORMANCE:\n\t\t \n\t\treturn 0;\n\tcase POLICY_POWERSAVE:\n\t\t \n\t\treturn (ASPM_STATE_L0S | ASPM_STATE_L1);\n\tcase POLICY_POWER_SUPERSAVE:\n\t\t \n\t\treturn ASPM_STATE_ALL;\n\tcase POLICY_DEFAULT:\n\t\treturn link->aspm_default;\n\t}\n\treturn 0;\n}\n\nstatic int policy_to_clkpm_state(struct pcie_link_state *link)\n{\n\tswitch (aspm_policy) {\n\tcase POLICY_PERFORMANCE:\n\t\t \n\t\treturn 0;\n\tcase POLICY_POWERSAVE:\n\tcase POLICY_POWER_SUPERSAVE:\n\t\t \n\t\treturn 1;\n\tcase POLICY_DEFAULT:\n\t\treturn link->clkpm_default;\n\t}\n\treturn 0;\n}\n\nstatic void pcie_set_clkpm_nocheck(struct pcie_link_state *link, int enable)\n{\n\tstruct pci_dev *child;\n\tstruct pci_bus *linkbus = link->pdev->subordinate;\n\tu32 val = enable ? PCI_EXP_LNKCTL_CLKREQ_EN : 0;\n\n\tlist_for_each_entry(child, &linkbus->devices, bus_list)\n\t\tpcie_capability_clear_and_set_word(child, PCI_EXP_LNKCTL,\n\t\t\t\t\t\t   PCI_EXP_LNKCTL_CLKREQ_EN,\n\t\t\t\t\t\t   val);\n\tlink->clkpm_enabled = !!enable;\n}\n\nstatic void pcie_set_clkpm(struct pcie_link_state *link, int enable)\n{\n\t \n\tif (!link->clkpm_capable || link->clkpm_disable)\n\t\tenable = 0;\n\t \n\tif (link->clkpm_enabled == enable)\n\t\treturn;\n\tpcie_set_clkpm_nocheck(link, enable);\n}\n\nstatic void pcie_clkpm_cap_init(struct pcie_link_state *link, int blacklist)\n{\n\tint capable = 1, enabled = 1;\n\tu32 reg32;\n\tu16 reg16;\n\tstruct pci_dev *child;\n\tstruct pci_bus *linkbus = link->pdev->subordinate;\n\n\t \n\tlist_for_each_entry(child, &linkbus->devices, bus_list) {\n\t\tpcie_capability_read_dword(child, PCI_EXP_LNKCAP, &reg32);\n\t\tif (!(reg32 & PCI_EXP_LNKCAP_CLKPM)) {\n\t\t\tcapable = 0;\n\t\t\tenabled = 0;\n\t\t\tbreak;\n\t\t}\n\t\tpcie_capability_read_word(child, PCI_EXP_LNKCTL, &reg16);\n\t\tif (!(reg16 & PCI_EXP_LNKCTL_CLKREQ_EN))\n\t\t\tenabled = 0;\n\t}\n\tlink->clkpm_enabled = enabled;\n\tlink->clkpm_default = enabled;\n\tlink->clkpm_capable = capable;\n\tlink->clkpm_disable = blacklist ? 1 : 0;\n}\n\n \nstatic void pcie_aspm_configure_common_clock(struct pcie_link_state *link)\n{\n\tint same_clock = 1;\n\tu16 reg16, ccc, parent_old_ccc, child_old_ccc[8];\n\tstruct pci_dev *child, *parent = link->pdev;\n\tstruct pci_bus *linkbus = parent->subordinate;\n\t \n\tchild = list_entry(linkbus->devices.next, struct pci_dev, bus_list);\n\tBUG_ON(!pci_is_pcie(child));\n\n\t \n\tpcie_capability_read_word(child, PCI_EXP_LNKSTA, &reg16);\n\tif (!(reg16 & PCI_EXP_LNKSTA_SLC))\n\t\tsame_clock = 0;\n\n\t \n\tpcie_capability_read_word(parent, PCI_EXP_LNKSTA, &reg16);\n\tif (!(reg16 & PCI_EXP_LNKSTA_SLC))\n\t\tsame_clock = 0;\n\n\t \n\tpcie_capability_read_word(parent, PCI_EXP_LNKCTL, &reg16);\n\tparent_old_ccc = reg16 & PCI_EXP_LNKCTL_CCC;\n\tif (same_clock && (reg16 & PCI_EXP_LNKCTL_CCC)) {\n\t\tbool consistent = true;\n\n\t\tlist_for_each_entry(child, &linkbus->devices, bus_list) {\n\t\t\tpcie_capability_read_word(child, PCI_EXP_LNKCTL,\n\t\t\t\t\t\t  &reg16);\n\t\t\tif (!(reg16 & PCI_EXP_LNKCTL_CCC)) {\n\t\t\t\tconsistent = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (consistent)\n\t\t\treturn;\n\t\tpci_info(parent, \"ASPM: current common clock configuration is inconsistent, reconfiguring\\n\");\n\t}\n\n\tccc = same_clock ? PCI_EXP_LNKCTL_CCC : 0;\n\t \n\tlist_for_each_entry(child, &linkbus->devices, bus_list) {\n\t\tpcie_capability_read_word(child, PCI_EXP_LNKCTL, &reg16);\n\t\tchild_old_ccc[PCI_FUNC(child->devfn)] = reg16 & PCI_EXP_LNKCTL_CCC;\n\t\tpcie_capability_clear_and_set_word(child, PCI_EXP_LNKCTL,\n\t\t\t\t\t\t   PCI_EXP_LNKCTL_CCC, ccc);\n\t}\n\n\t \n\tpcie_capability_clear_and_set_word(parent, PCI_EXP_LNKCTL,\n\t\t\t\t\t   PCI_EXP_LNKCTL_CCC, ccc);\n\n\tif (pcie_retrain_link(link->pdev, true)) {\n\n\t\t \n\t\tpci_err(parent, \"ASPM: Could not configure common clock\\n\");\n\t\tlist_for_each_entry(child, &linkbus->devices, bus_list)\n\t\t\tpcie_capability_clear_and_set_word(child, PCI_EXP_LNKCTL,\n\t\t\t\t\t\t\t   PCI_EXP_LNKCTL_CCC,\n\t\t\t\t\t\t\t   child_old_ccc[PCI_FUNC(child->devfn)]);\n\t\tpcie_capability_clear_and_set_word(parent, PCI_EXP_LNKCTL,\n\t\t\t\t\t\t   PCI_EXP_LNKCTL_CCC, parent_old_ccc);\n\t}\n}\n\n \nstatic u32 calc_l0s_latency(u32 lnkcap)\n{\n\tu32 encoding = (lnkcap & PCI_EXP_LNKCAP_L0SEL) >> 12;\n\n\tif (encoding == 0x7)\n\t\treturn (5 * 1000);\t \n\treturn (64 << encoding);\n}\n\n \nstatic u32 calc_l0s_acceptable(u32 encoding)\n{\n\tif (encoding == 0x7)\n\t\treturn -1U;\n\treturn (64 << encoding);\n}\n\n \nstatic u32 calc_l1_latency(u32 lnkcap)\n{\n\tu32 encoding = (lnkcap & PCI_EXP_LNKCAP_L1EL) >> 15;\n\n\tif (encoding == 0x7)\n\t\treturn (65 * 1000);\t \n\treturn (1000 << encoding);\n}\n\n \nstatic u32 calc_l1_acceptable(u32 encoding)\n{\n\tif (encoding == 0x7)\n\t\treturn -1U;\n\treturn (1000 << encoding);\n}\n\n \nstatic u32 calc_l12_pwron(struct pci_dev *pdev, u32 scale, u32 val)\n{\n\tswitch (scale) {\n\tcase 0:\n\t\treturn val * 2;\n\tcase 1:\n\t\treturn val * 10;\n\tcase 2:\n\t\treturn val * 100;\n\t}\n\tpci_err(pdev, \"%s: Invalid T_PwrOn scale: %u\\n\", __func__, scale);\n\treturn 0;\n}\n\n \nstatic void encode_l12_threshold(u32 threshold_us, u32 *scale, u32 *value)\n{\n\tu64 threshold_ns = (u64) threshold_us * 1000;\n\n\t \n\tif (threshold_ns <= 0x3ff * 1) {\n\t\t*scale = 0;\t\t \n\t\t*value = threshold_ns;\n\t} else if (threshold_ns <= 0x3ff * 32) {\n\t\t*scale = 1;\t\t \n\t\t*value = roundup(threshold_ns, 32) / 32;\n\t} else if (threshold_ns <= 0x3ff * 1024) {\n\t\t*scale = 2;\t\t \n\t\t*value = roundup(threshold_ns, 1024) / 1024;\n\t} else if (threshold_ns <= 0x3ff * 32768) {\n\t\t*scale = 3;\t\t \n\t\t*value = roundup(threshold_ns, 32768) / 32768;\n\t} else if (threshold_ns <= 0x3ff * 1048576) {\n\t\t*scale = 4;\t\t \n\t\t*value = roundup(threshold_ns, 1048576) / 1048576;\n\t} else if (threshold_ns <= 0x3ff * (u64) 33554432) {\n\t\t*scale = 5;\t\t \n\t\t*value = roundup(threshold_ns, 33554432) / 33554432;\n\t} else {\n\t\t*scale = 5;\n\t\t*value = 0x3ff;\t\t \n\t}\n}\n\nstatic void pcie_aspm_check_latency(struct pci_dev *endpoint)\n{\n\tu32 latency, encoding, lnkcap_up, lnkcap_dw;\n\tu32 l1_switch_latency = 0, latency_up_l0s;\n\tu32 latency_up_l1, latency_dw_l0s, latency_dw_l1;\n\tu32 acceptable_l0s, acceptable_l1;\n\tstruct pcie_link_state *link;\n\n\t \n\tif ((endpoint->current_state != PCI_D0) &&\n\t    (endpoint->current_state != PCI_UNKNOWN))\n\t\treturn;\n\n\tlink = endpoint->bus->self->link_state;\n\n\t \n\tencoding = (endpoint->devcap & PCI_EXP_DEVCAP_L0S) >> 6;\n\tacceptable_l0s = calc_l0s_acceptable(encoding);\n\n\t \n\tencoding = (endpoint->devcap & PCI_EXP_DEVCAP_L1) >> 9;\n\tacceptable_l1 = calc_l1_acceptable(encoding);\n\n\twhile (link) {\n\t\tstruct pci_dev *dev = pci_function_0(link->pdev->subordinate);\n\n\t\t \n\t\tpcie_capability_read_dword(link->pdev, PCI_EXP_LNKCAP,\n\t\t\t\t\t   &lnkcap_up);\n\t\tpcie_capability_read_dword(dev, PCI_EXP_LNKCAP,\n\t\t\t\t\t   &lnkcap_dw);\n\t\tlatency_up_l0s = calc_l0s_latency(lnkcap_up);\n\t\tlatency_up_l1 = calc_l1_latency(lnkcap_up);\n\t\tlatency_dw_l0s = calc_l0s_latency(lnkcap_dw);\n\t\tlatency_dw_l1 = calc_l1_latency(lnkcap_dw);\n\n\t\t \n\t\tif ((link->aspm_capable & ASPM_STATE_L0S_UP) &&\n\t\t    (latency_up_l0s > acceptable_l0s))\n\t\t\tlink->aspm_capable &= ~ASPM_STATE_L0S_UP;\n\n\t\t \n\t\tif ((link->aspm_capable & ASPM_STATE_L0S_DW) &&\n\t\t    (latency_dw_l0s > acceptable_l0s))\n\t\t\tlink->aspm_capable &= ~ASPM_STATE_L0S_DW;\n\t\t \n\t\tlatency = max_t(u32, latency_up_l1, latency_dw_l1);\n\t\tif ((link->aspm_capable & ASPM_STATE_L1) &&\n\t\t    (latency + l1_switch_latency > acceptable_l1))\n\t\t\tlink->aspm_capable &= ~ASPM_STATE_L1;\n\t\tl1_switch_latency += 1000;\n\n\t\tlink = link->parent;\n\t}\n}\n\nstatic void pci_clear_and_set_dword(struct pci_dev *pdev, int pos,\n\t\t\t\t    u32 clear, u32 set)\n{\n\tu32 val;\n\n\tpci_read_config_dword(pdev, pos, &val);\n\tval &= ~clear;\n\tval |= set;\n\tpci_write_config_dword(pdev, pos, val);\n}\n\n \nstatic void aspm_calc_l12_info(struct pcie_link_state *link,\n\t\t\t\tu32 parent_l1ss_cap, u32 child_l1ss_cap)\n{\n\tstruct pci_dev *child = link->downstream, *parent = link->pdev;\n\tu32 val1, val2, scale1, scale2;\n\tu32 t_common_mode, t_power_on, l1_2_threshold, scale, value;\n\tu32 ctl1 = 0, ctl2 = 0;\n\tu32 pctl1, pctl2, cctl1, cctl2;\n\tu32 pl1_2_enables, cl1_2_enables;\n\n\t \n\tval1 = (parent_l1ss_cap & PCI_L1SS_CAP_CM_RESTORE_TIME) >> 8;\n\tval2 = (child_l1ss_cap & PCI_L1SS_CAP_CM_RESTORE_TIME) >> 8;\n\tt_common_mode = max(val1, val2);\n\n\t \n\tval1   = (parent_l1ss_cap & PCI_L1SS_CAP_P_PWR_ON_VALUE) >> 19;\n\tscale1 = (parent_l1ss_cap & PCI_L1SS_CAP_P_PWR_ON_SCALE) >> 16;\n\tval2   = (child_l1ss_cap & PCI_L1SS_CAP_P_PWR_ON_VALUE) >> 19;\n\tscale2 = (child_l1ss_cap & PCI_L1SS_CAP_P_PWR_ON_SCALE) >> 16;\n\n\tif (calc_l12_pwron(parent, scale1, val1) >\n\t    calc_l12_pwron(child, scale2, val2)) {\n\t\tctl2 |= scale1 | (val1 << 3);\n\t\tt_power_on = calc_l12_pwron(parent, scale1, val1);\n\t} else {\n\t\tctl2 |= scale2 | (val2 << 3);\n\t\tt_power_on = calc_l12_pwron(child, scale2, val2);\n\t}\n\n\t \n\tl1_2_threshold = 2 + 4 + t_common_mode + t_power_on;\n\tencode_l12_threshold(l1_2_threshold, &scale, &value);\n\tctl1 |= t_common_mode << 8 | scale << 29 | value << 16;\n\n\t \n\tpci_read_config_dword(parent, parent->l1ss + PCI_L1SS_CTL1, &pctl1);\n\tpci_read_config_dword(parent, parent->l1ss + PCI_L1SS_CTL2, &pctl2);\n\tpci_read_config_dword(child, child->l1ss + PCI_L1SS_CTL1, &cctl1);\n\tpci_read_config_dword(child, child->l1ss + PCI_L1SS_CTL2, &cctl2);\n\n\tif (ctl1 == pctl1 && ctl1 == cctl1 &&\n\t    ctl2 == pctl2 && ctl2 == cctl2)\n\t\treturn;\n\n\t \n\tpl1_2_enables = pctl1 & PCI_L1SS_CTL1_L1_2_MASK;\n\tcl1_2_enables = cctl1 & PCI_L1SS_CTL1_L1_2_MASK;\n\n\tif (pl1_2_enables || cl1_2_enables) {\n\t\tpci_clear_and_set_dword(child, child->l1ss + PCI_L1SS_CTL1,\n\t\t\t\t\tPCI_L1SS_CTL1_L1_2_MASK, 0);\n\t\tpci_clear_and_set_dword(parent, parent->l1ss + PCI_L1SS_CTL1,\n\t\t\t\t\tPCI_L1SS_CTL1_L1_2_MASK, 0);\n\t}\n\n\t \n\tpci_write_config_dword(parent, parent->l1ss + PCI_L1SS_CTL2, ctl2);\n\tpci_write_config_dword(child, child->l1ss + PCI_L1SS_CTL2, ctl2);\n\n\t \n\tpci_clear_and_set_dword(parent, parent->l1ss + PCI_L1SS_CTL1,\n\t\t\t\tPCI_L1SS_CTL1_CM_RESTORE_TIME, ctl1);\n\n\t \n\tpci_clear_and_set_dword(parent,\tparent->l1ss + PCI_L1SS_CTL1,\n\t\t\t\tPCI_L1SS_CTL1_LTR_L12_TH_VALUE |\n\t\t\t\tPCI_L1SS_CTL1_LTR_L12_TH_SCALE, ctl1);\n\tpci_clear_and_set_dword(child, child->l1ss + PCI_L1SS_CTL1,\n\t\t\t\tPCI_L1SS_CTL1_LTR_L12_TH_VALUE |\n\t\t\t\tPCI_L1SS_CTL1_LTR_L12_TH_SCALE, ctl1);\n\n\tif (pl1_2_enables || cl1_2_enables) {\n\t\tpci_clear_and_set_dword(parent, parent->l1ss + PCI_L1SS_CTL1, 0,\n\t\t\t\t\tpl1_2_enables);\n\t\tpci_clear_and_set_dword(child, child->l1ss + PCI_L1SS_CTL1, 0,\n\t\t\t\t\tcl1_2_enables);\n\t}\n}\n\nstatic void aspm_l1ss_init(struct pcie_link_state *link)\n{\n\tstruct pci_dev *child = link->downstream, *parent = link->pdev;\n\tu32 parent_l1ss_cap, child_l1ss_cap;\n\tu32 parent_l1ss_ctl1 = 0, child_l1ss_ctl1 = 0;\n\n\tif (!parent->l1ss || !child->l1ss)\n\t\treturn;\n\n\t \n\tpci_read_config_dword(parent, parent->l1ss + PCI_L1SS_CAP,\n\t\t\t      &parent_l1ss_cap);\n\tpci_read_config_dword(child, child->l1ss + PCI_L1SS_CAP,\n\t\t\t      &child_l1ss_cap);\n\n\tif (!(parent_l1ss_cap & PCI_L1SS_CAP_L1_PM_SS))\n\t\tparent_l1ss_cap = 0;\n\tif (!(child_l1ss_cap & PCI_L1SS_CAP_L1_PM_SS))\n\t\tchild_l1ss_cap = 0;\n\n\t \n\tif (!child->ltr_path)\n\t\tchild_l1ss_cap &= ~PCI_L1SS_CAP_ASPM_L1_2;\n\n\tif (parent_l1ss_cap & child_l1ss_cap & PCI_L1SS_CAP_ASPM_L1_1)\n\t\tlink->aspm_support |= ASPM_STATE_L1_1;\n\tif (parent_l1ss_cap & child_l1ss_cap & PCI_L1SS_CAP_ASPM_L1_2)\n\t\tlink->aspm_support |= ASPM_STATE_L1_2;\n\tif (parent_l1ss_cap & child_l1ss_cap & PCI_L1SS_CAP_PCIPM_L1_1)\n\t\tlink->aspm_support |= ASPM_STATE_L1_1_PCIPM;\n\tif (parent_l1ss_cap & child_l1ss_cap & PCI_L1SS_CAP_PCIPM_L1_2)\n\t\tlink->aspm_support |= ASPM_STATE_L1_2_PCIPM;\n\n\tif (parent_l1ss_cap)\n\t\tpci_read_config_dword(parent, parent->l1ss + PCI_L1SS_CTL1,\n\t\t\t\t      &parent_l1ss_ctl1);\n\tif (child_l1ss_cap)\n\t\tpci_read_config_dword(child, child->l1ss + PCI_L1SS_CTL1,\n\t\t\t\t      &child_l1ss_ctl1);\n\n\tif (parent_l1ss_ctl1 & child_l1ss_ctl1 & PCI_L1SS_CTL1_ASPM_L1_1)\n\t\tlink->aspm_enabled |= ASPM_STATE_L1_1;\n\tif (parent_l1ss_ctl1 & child_l1ss_ctl1 & PCI_L1SS_CTL1_ASPM_L1_2)\n\t\tlink->aspm_enabled |= ASPM_STATE_L1_2;\n\tif (parent_l1ss_ctl1 & child_l1ss_ctl1 & PCI_L1SS_CTL1_PCIPM_L1_1)\n\t\tlink->aspm_enabled |= ASPM_STATE_L1_1_PCIPM;\n\tif (parent_l1ss_ctl1 & child_l1ss_ctl1 & PCI_L1SS_CTL1_PCIPM_L1_2)\n\t\tlink->aspm_enabled |= ASPM_STATE_L1_2_PCIPM;\n\n\tif (link->aspm_support & ASPM_STATE_L1_2_MASK)\n\t\taspm_calc_l12_info(link, parent_l1ss_cap, child_l1ss_cap);\n}\n\nstatic void pcie_aspm_cap_init(struct pcie_link_state *link, int blacklist)\n{\n\tstruct pci_dev *child = link->downstream, *parent = link->pdev;\n\tu32 parent_lnkcap, child_lnkcap;\n\tu16 parent_lnkctl, child_lnkctl;\n\tstruct pci_bus *linkbus = parent->subordinate;\n\n\tif (blacklist) {\n\t\t \n\t\tlink->aspm_enabled = ASPM_STATE_ALL;\n\t\tlink->aspm_disable = ASPM_STATE_ALL;\n\t\treturn;\n\t}\n\n\t \n\tpcie_capability_read_dword(parent, PCI_EXP_LNKCAP, &parent_lnkcap);\n\tpcie_capability_read_dword(child, PCI_EXP_LNKCAP, &child_lnkcap);\n\tif (!(parent_lnkcap & child_lnkcap & PCI_EXP_LNKCAP_ASPMS))\n\t\treturn;\n\n\t \n\tpcie_aspm_configure_common_clock(link);\n\n\t \n\tpcie_capability_read_dword(parent, PCI_EXP_LNKCAP, &parent_lnkcap);\n\tpcie_capability_read_dword(child, PCI_EXP_LNKCAP, &child_lnkcap);\n\tpcie_capability_read_word(parent, PCI_EXP_LNKCTL, &parent_lnkctl);\n\tpcie_capability_read_word(child, PCI_EXP_LNKCTL, &child_lnkctl);\n\n\t \n\tif (parent_lnkcap & child_lnkcap & PCI_EXP_LNKCAP_ASPM_L0S)\n\t\tlink->aspm_support |= ASPM_STATE_L0S;\n\n\tif (child_lnkctl & PCI_EXP_LNKCTL_ASPM_L0S)\n\t\tlink->aspm_enabled |= ASPM_STATE_L0S_UP;\n\tif (parent_lnkctl & PCI_EXP_LNKCTL_ASPM_L0S)\n\t\tlink->aspm_enabled |= ASPM_STATE_L0S_DW;\n\n\t \n\tif (parent_lnkcap & child_lnkcap & PCI_EXP_LNKCAP_ASPM_L1)\n\t\tlink->aspm_support |= ASPM_STATE_L1;\n\n\tif (parent_lnkctl & child_lnkctl & PCI_EXP_LNKCTL_ASPM_L1)\n\t\tlink->aspm_enabled |= ASPM_STATE_L1;\n\n\taspm_l1ss_init(link);\n\n\t \n\tlink->aspm_default = link->aspm_enabled;\n\n\t \n\tlink->aspm_capable = link->aspm_support;\n\n\t \n\tlist_for_each_entry(child, &linkbus->devices, bus_list) {\n\t\tif (pci_pcie_type(child) != PCI_EXP_TYPE_ENDPOINT &&\n\t\t    pci_pcie_type(child) != PCI_EXP_TYPE_LEG_END)\n\t\t\tcontinue;\n\n\t\tpcie_aspm_check_latency(child);\n\t}\n}\n\n \nstatic void pcie_config_aspm_l1ss(struct pcie_link_state *link, u32 state)\n{\n\tu32 val, enable_req;\n\tstruct pci_dev *child = link->downstream, *parent = link->pdev;\n\n\tenable_req = (link->aspm_enabled ^ state) & state;\n\n\t \n\n\t \n\tpci_clear_and_set_dword(child, child->l1ss + PCI_L1SS_CTL1,\n\t\t\t\tPCI_L1SS_CTL1_L1SS_MASK, 0);\n\tpci_clear_and_set_dword(parent, parent->l1ss + PCI_L1SS_CTL1,\n\t\t\t\tPCI_L1SS_CTL1_L1SS_MASK, 0);\n\t \n\tif (enable_req & (ASPM_STATE_L1_1 | ASPM_STATE_L1_2)) {\n\t\tpcie_capability_clear_and_set_word(child, PCI_EXP_LNKCTL,\n\t\t\t\t\t\t   PCI_EXP_LNKCTL_ASPM_L1, 0);\n\t\tpcie_capability_clear_and_set_word(parent, PCI_EXP_LNKCTL,\n\t\t\t\t\t\t   PCI_EXP_LNKCTL_ASPM_L1, 0);\n\t}\n\n\tval = 0;\n\tif (state & ASPM_STATE_L1_1)\n\t\tval |= PCI_L1SS_CTL1_ASPM_L1_1;\n\tif (state & ASPM_STATE_L1_2)\n\t\tval |= PCI_L1SS_CTL1_ASPM_L1_2;\n\tif (state & ASPM_STATE_L1_1_PCIPM)\n\t\tval |= PCI_L1SS_CTL1_PCIPM_L1_1;\n\tif (state & ASPM_STATE_L1_2_PCIPM)\n\t\tval |= PCI_L1SS_CTL1_PCIPM_L1_2;\n\n\t \n\tpci_clear_and_set_dword(parent, parent->l1ss + PCI_L1SS_CTL1,\n\t\t\t\tPCI_L1SS_CTL1_L1SS_MASK, val);\n\tpci_clear_and_set_dword(child, child->l1ss + PCI_L1SS_CTL1,\n\t\t\t\tPCI_L1SS_CTL1_L1SS_MASK, val);\n}\n\nstatic void pcie_config_aspm_dev(struct pci_dev *pdev, u32 val)\n{\n\tpcie_capability_clear_and_set_word(pdev, PCI_EXP_LNKCTL,\n\t\t\t\t\t   PCI_EXP_LNKCTL_ASPMC, val);\n}\n\nstatic void pcie_config_aspm_link(struct pcie_link_state *link, u32 state)\n{\n\tu32 upstream = 0, dwstream = 0;\n\tstruct pci_dev *child = link->downstream, *parent = link->pdev;\n\tstruct pci_bus *linkbus = parent->subordinate;\n\n\t \n\tstate &= (link->aspm_capable & ~link->aspm_disable);\n\n\t \n\tif (!(state & ASPM_STATE_L1))\n\t\tstate &= ~ASPM_STATE_L1SS;\n\n\t \n\tif (parent->current_state != PCI_D0 || child->current_state != PCI_D0) {\n\t\tstate &= ~ASPM_STATE_L1_SS_PCIPM;\n\t\tstate |= (link->aspm_enabled & ASPM_STATE_L1_SS_PCIPM);\n\t}\n\n\t \n\tif (link->aspm_enabled == state)\n\t\treturn;\n\t \n\tif (state & ASPM_STATE_L0S_UP)\n\t\tdwstream |= PCI_EXP_LNKCTL_ASPM_L0S;\n\tif (state & ASPM_STATE_L0S_DW)\n\t\tupstream |= PCI_EXP_LNKCTL_ASPM_L0S;\n\tif (state & ASPM_STATE_L1) {\n\t\tupstream |= PCI_EXP_LNKCTL_ASPM_L1;\n\t\tdwstream |= PCI_EXP_LNKCTL_ASPM_L1;\n\t}\n\n\tif (link->aspm_capable & ASPM_STATE_L1SS)\n\t\tpcie_config_aspm_l1ss(link, state);\n\n\t \n\tif (state & ASPM_STATE_L1)\n\t\tpcie_config_aspm_dev(parent, upstream);\n\tlist_for_each_entry(child, &linkbus->devices, bus_list)\n\t\tpcie_config_aspm_dev(child, dwstream);\n\tif (!(state & ASPM_STATE_L1))\n\t\tpcie_config_aspm_dev(parent, upstream);\n\n\tlink->aspm_enabled = state;\n}\n\nstatic void pcie_config_aspm_path(struct pcie_link_state *link)\n{\n\twhile (link) {\n\t\tpcie_config_aspm_link(link, policy_to_aspm_state(link));\n\t\tlink = link->parent;\n\t}\n}\n\nstatic void free_link_state(struct pcie_link_state *link)\n{\n\tlink->pdev->link_state = NULL;\n\tkfree(link);\n}\n\nstatic int pcie_aspm_sanity_check(struct pci_dev *pdev)\n{\n\tstruct pci_dev *child;\n\tu32 reg32;\n\n\t \n\tlist_for_each_entry(child, &pdev->subordinate->devices, bus_list) {\n\t\tif (!pci_is_pcie(child))\n\t\t\treturn -EINVAL;\n\n\t\t \n\n\t\tif (aspm_disabled)\n\t\t\tcontinue;\n\n\t\t \n\t\tpcie_capability_read_dword(child, PCI_EXP_DEVCAP, &reg32);\n\t\tif (!(reg32 & PCI_EXP_DEVCAP_RBER) && !aspm_force) {\n\t\t\tpci_info(child, \"disabling ASPM on pre-1.1 PCIe device.  You can enable it with 'pcie_aspm=force'\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic struct pcie_link_state *alloc_pcie_link_state(struct pci_dev *pdev)\n{\n\tstruct pcie_link_state *link;\n\n\tlink = kzalloc(sizeof(*link), GFP_KERNEL);\n\tif (!link)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&link->sibling);\n\tlink->pdev = pdev;\n\tlink->downstream = pci_function_0(pdev->subordinate);\n\n\t \n\tif (pci_pcie_type(pdev) == PCI_EXP_TYPE_ROOT_PORT ||\n\t    pci_pcie_type(pdev) == PCI_EXP_TYPE_PCIE_BRIDGE ||\n\t    !pdev->bus->parent->self) {\n\t\tlink->root = link;\n\t} else {\n\t\tstruct pcie_link_state *parent;\n\n\t\tparent = pdev->bus->parent->self->link_state;\n\t\tif (!parent) {\n\t\t\tkfree(link);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tlink->parent = parent;\n\t\tlink->root = link->parent->root;\n\t}\n\n\tlist_add(&link->sibling, &link_list);\n\tpdev->link_state = link;\n\treturn link;\n}\n\nstatic void pcie_aspm_update_sysfs_visibility(struct pci_dev *pdev)\n{\n\tstruct pci_dev *child;\n\n\tlist_for_each_entry(child, &pdev->subordinate->devices, bus_list)\n\t\tsysfs_update_group(&child->dev.kobj, &aspm_ctrl_attr_group);\n}\n\n \nvoid pcie_aspm_init_link_state(struct pci_dev *pdev)\n{\n\tstruct pcie_link_state *link;\n\tint blacklist = !!pcie_aspm_sanity_check(pdev);\n\n\tif (!aspm_support_enabled)\n\t\treturn;\n\n\tif (pdev->link_state)\n\t\treturn;\n\n\t \n\tif (!pcie_downstream_port(pdev))\n\t\treturn;\n\n\t \n\tif (pci_pcie_type(pdev) == PCI_EXP_TYPE_ROOT_PORT &&\n\t    pdev->bus->self)\n\t\treturn;\n\n\tdown_read(&pci_bus_sem);\n\tif (list_empty(&pdev->subordinate->devices))\n\t\tgoto out;\n\n\tmutex_lock(&aspm_lock);\n\tlink = alloc_pcie_link_state(pdev);\n\tif (!link)\n\t\tgoto unlock;\n\t \n\tpcie_aspm_cap_init(link, blacklist);\n\n\t \n\tpcie_clkpm_cap_init(link, blacklist);\n\n\t \n\tif (aspm_policy != POLICY_POWERSAVE &&\n\t    aspm_policy != POLICY_POWER_SUPERSAVE) {\n\t\tpcie_config_aspm_path(link);\n\t\tpcie_set_clkpm(link, policy_to_clkpm_state(link));\n\t}\n\n\tpcie_aspm_update_sysfs_visibility(pdev);\n\nunlock:\n\tmutex_unlock(&aspm_lock);\nout:\n\tup_read(&pci_bus_sem);\n}\n\n \nstatic void pcie_update_aspm_capable(struct pcie_link_state *root)\n{\n\tstruct pcie_link_state *link;\n\tBUG_ON(root->parent);\n\tlist_for_each_entry(link, &link_list, sibling) {\n\t\tif (link->root != root)\n\t\t\tcontinue;\n\t\tlink->aspm_capable = link->aspm_support;\n\t}\n\tlist_for_each_entry(link, &link_list, sibling) {\n\t\tstruct pci_dev *child;\n\t\tstruct pci_bus *linkbus = link->pdev->subordinate;\n\t\tif (link->root != root)\n\t\t\tcontinue;\n\t\tlist_for_each_entry(child, &linkbus->devices, bus_list) {\n\t\t\tif ((pci_pcie_type(child) != PCI_EXP_TYPE_ENDPOINT) &&\n\t\t\t    (pci_pcie_type(child) != PCI_EXP_TYPE_LEG_END))\n\t\t\t\tcontinue;\n\t\t\tpcie_aspm_check_latency(child);\n\t\t}\n\t}\n}\n\n \nvoid pcie_aspm_exit_link_state(struct pci_dev *pdev)\n{\n\tstruct pci_dev *parent = pdev->bus->self;\n\tstruct pcie_link_state *link, *root, *parent_link;\n\n\tif (!parent || !parent->link_state)\n\t\treturn;\n\n\tdown_read(&pci_bus_sem);\n\tmutex_lock(&aspm_lock);\n\n\tlink = parent->link_state;\n\troot = link->root;\n\tparent_link = link->parent;\n\n\t \n\tpcie_config_aspm_link(link, 0);\n\tlist_del(&link->sibling);\n\tfree_link_state(link);\n\n\t \n\tif (parent_link) {\n\t\tpcie_update_aspm_capable(root);\n\t\tpcie_config_aspm_path(parent_link);\n\t}\n\n\tmutex_unlock(&aspm_lock);\n\tup_read(&pci_bus_sem);\n}\n\n \nvoid pcie_aspm_pm_state_change(struct pci_dev *pdev)\n{\n\tstruct pcie_link_state *link = pdev->link_state;\n\n\tif (aspm_disabled || !link)\n\t\treturn;\n\t \n\tdown_read(&pci_bus_sem);\n\tmutex_lock(&aspm_lock);\n\tpcie_update_aspm_capable(link->root);\n\tpcie_config_aspm_path(link);\n\tmutex_unlock(&aspm_lock);\n\tup_read(&pci_bus_sem);\n}\n\nvoid pcie_aspm_powersave_config_link(struct pci_dev *pdev)\n{\n\tstruct pcie_link_state *link = pdev->link_state;\n\n\tif (aspm_disabled || !link)\n\t\treturn;\n\n\tif (aspm_policy != POLICY_POWERSAVE &&\n\t    aspm_policy != POLICY_POWER_SUPERSAVE)\n\t\treturn;\n\n\tdown_read(&pci_bus_sem);\n\tmutex_lock(&aspm_lock);\n\tpcie_config_aspm_path(link);\n\tpcie_set_clkpm(link, policy_to_clkpm_state(link));\n\tmutex_unlock(&aspm_lock);\n\tup_read(&pci_bus_sem);\n}\n\nstatic struct pcie_link_state *pcie_aspm_get_link(struct pci_dev *pdev)\n{\n\tstruct pci_dev *bridge;\n\n\tif (!pci_is_pcie(pdev))\n\t\treturn NULL;\n\n\tbridge = pci_upstream_bridge(pdev);\n\tif (!bridge || !pci_is_pcie(bridge))\n\t\treturn NULL;\n\n\treturn bridge->link_state;\n}\n\nstatic int __pci_disable_link_state(struct pci_dev *pdev, int state, bool sem)\n{\n\tstruct pcie_link_state *link = pcie_aspm_get_link(pdev);\n\n\tif (!link)\n\t\treturn -EINVAL;\n\t \n\tif (aspm_disabled) {\n\t\tpci_warn(pdev, \"can't disable ASPM; OS doesn't have ASPM control\\n\");\n\t\treturn -EPERM;\n\t}\n\n\tif (sem)\n\t\tdown_read(&pci_bus_sem);\n\tmutex_lock(&aspm_lock);\n\tif (state & PCIE_LINK_STATE_L0S)\n\t\tlink->aspm_disable |= ASPM_STATE_L0S;\n\tif (state & PCIE_LINK_STATE_L1)\n\t\t \n\t\tlink->aspm_disable |= ASPM_STATE_L1 | ASPM_STATE_L1SS;\n\tif (state & PCIE_LINK_STATE_L1_1)\n\t\tlink->aspm_disable |= ASPM_STATE_L1_1;\n\tif (state & PCIE_LINK_STATE_L1_2)\n\t\tlink->aspm_disable |= ASPM_STATE_L1_2;\n\tif (state & PCIE_LINK_STATE_L1_1_PCIPM)\n\t\tlink->aspm_disable |= ASPM_STATE_L1_1_PCIPM;\n\tif (state & PCIE_LINK_STATE_L1_2_PCIPM)\n\t\tlink->aspm_disable |= ASPM_STATE_L1_2_PCIPM;\n\tpcie_config_aspm_link(link, policy_to_aspm_state(link));\n\n\tif (state & PCIE_LINK_STATE_CLKPM)\n\t\tlink->clkpm_disable = 1;\n\tpcie_set_clkpm(link, policy_to_clkpm_state(link));\n\tmutex_unlock(&aspm_lock);\n\tif (sem)\n\t\tup_read(&pci_bus_sem);\n\n\treturn 0;\n}\n\nint pci_disable_link_state_locked(struct pci_dev *pdev, int state)\n{\n\treturn __pci_disable_link_state(pdev, state, false);\n}\nEXPORT_SYMBOL(pci_disable_link_state_locked);\n\n \nint pci_disable_link_state(struct pci_dev *pdev, int state)\n{\n\treturn __pci_disable_link_state(pdev, state, true);\n}\nEXPORT_SYMBOL(pci_disable_link_state);\n\nstatic int __pci_enable_link_state(struct pci_dev *pdev, int state, bool locked)\n{\n\tstruct pcie_link_state *link = pcie_aspm_get_link(pdev);\n\n\tif (!link)\n\t\treturn -EINVAL;\n\t \n\tif (aspm_disabled) {\n\t\tpci_warn(pdev, \"can't override BIOS ASPM; OS doesn't have ASPM control\\n\");\n\t\treturn -EPERM;\n\t}\n\n\tif (!locked)\n\t\tdown_read(&pci_bus_sem);\n\tmutex_lock(&aspm_lock);\n\tlink->aspm_default = 0;\n\tif (state & PCIE_LINK_STATE_L0S)\n\t\tlink->aspm_default |= ASPM_STATE_L0S;\n\tif (state & PCIE_LINK_STATE_L1)\n\t\tlink->aspm_default |= ASPM_STATE_L1;\n\t \n\tif (state & PCIE_LINK_STATE_L1_1)\n\t\tlink->aspm_default |= ASPM_STATE_L1_1 | ASPM_STATE_L1;\n\tif (state & PCIE_LINK_STATE_L1_2)\n\t\tlink->aspm_default |= ASPM_STATE_L1_2 | ASPM_STATE_L1;\n\tif (state & PCIE_LINK_STATE_L1_1_PCIPM)\n\t\tlink->aspm_default |= ASPM_STATE_L1_1_PCIPM | ASPM_STATE_L1;\n\tif (state & PCIE_LINK_STATE_L1_2_PCIPM)\n\t\tlink->aspm_default |= ASPM_STATE_L1_2_PCIPM | ASPM_STATE_L1;\n\tpcie_config_aspm_link(link, policy_to_aspm_state(link));\n\n\tlink->clkpm_default = (state & PCIE_LINK_STATE_CLKPM) ? 1 : 0;\n\tpcie_set_clkpm(link, policy_to_clkpm_state(link));\n\tmutex_unlock(&aspm_lock);\n\tif (!locked)\n\t\tup_read(&pci_bus_sem);\n\n\treturn 0;\n}\n\n \nint pci_enable_link_state(struct pci_dev *pdev, int state)\n{\n\treturn __pci_enable_link_state(pdev, state, false);\n}\nEXPORT_SYMBOL(pci_enable_link_state);\n\n \nint pci_enable_link_state_locked(struct pci_dev *pdev, int state)\n{\n\tlockdep_assert_held_read(&pci_bus_sem);\n\n\treturn __pci_enable_link_state(pdev, state, true);\n}\nEXPORT_SYMBOL(pci_enable_link_state_locked);\n\nstatic int pcie_aspm_set_policy(const char *val,\n\t\t\t\tconst struct kernel_param *kp)\n{\n\tint i;\n\tstruct pcie_link_state *link;\n\n\tif (aspm_disabled)\n\t\treturn -EPERM;\n\ti = sysfs_match_string(policy_str, val);\n\tif (i < 0)\n\t\treturn i;\n\tif (i == aspm_policy)\n\t\treturn 0;\n\n\tdown_read(&pci_bus_sem);\n\tmutex_lock(&aspm_lock);\n\taspm_policy = i;\n\tlist_for_each_entry(link, &link_list, sibling) {\n\t\tpcie_config_aspm_link(link, policy_to_aspm_state(link));\n\t\tpcie_set_clkpm(link, policy_to_clkpm_state(link));\n\t}\n\tmutex_unlock(&aspm_lock);\n\tup_read(&pci_bus_sem);\n\treturn 0;\n}\n\nstatic int pcie_aspm_get_policy(char *buffer, const struct kernel_param *kp)\n{\n\tint i, cnt = 0;\n\tfor (i = 0; i < ARRAY_SIZE(policy_str); i++)\n\t\tif (i == aspm_policy)\n\t\t\tcnt += sprintf(buffer + cnt, \"[%s] \", policy_str[i]);\n\t\telse\n\t\t\tcnt += sprintf(buffer + cnt, \"%s \", policy_str[i]);\n\tcnt += sprintf(buffer + cnt, \"\\n\");\n\treturn cnt;\n}\n\nmodule_param_call(policy, pcie_aspm_set_policy, pcie_aspm_get_policy,\n\tNULL, 0644);\n\n \nbool pcie_aspm_enabled(struct pci_dev *pdev)\n{\n\tstruct pcie_link_state *link = pcie_aspm_get_link(pdev);\n\n\tif (!link)\n\t\treturn false;\n\n\treturn link->aspm_enabled;\n}\nEXPORT_SYMBOL_GPL(pcie_aspm_enabled);\n\nstatic ssize_t aspm_attr_show_common(struct device *dev,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     char *buf, u8 state)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tstruct pcie_link_state *link = pcie_aspm_get_link(pdev);\n\n\treturn sysfs_emit(buf, \"%d\\n\", (link->aspm_enabled & state) ? 1 : 0);\n}\n\nstatic ssize_t aspm_attr_store_common(struct device *dev,\n\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t      const char *buf, size_t len, u8 state)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tstruct pcie_link_state *link = pcie_aspm_get_link(pdev);\n\tbool state_enable;\n\n\tif (kstrtobool(buf, &state_enable) < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&pci_bus_sem);\n\tmutex_lock(&aspm_lock);\n\n\tif (state_enable) {\n\t\tlink->aspm_disable &= ~state;\n\t\t \n\t\tif (state & ASPM_STATE_L1SS)\n\t\t\tlink->aspm_disable &= ~ASPM_STATE_L1;\n\t} else {\n\t\tlink->aspm_disable |= state;\n\t\tif (state & ASPM_STATE_L1)\n\t\t\tlink->aspm_disable |= ASPM_STATE_L1SS;\n\t}\n\n\tpcie_config_aspm_link(link, policy_to_aspm_state(link));\n\n\tmutex_unlock(&aspm_lock);\n\tup_read(&pci_bus_sem);\n\n\treturn len;\n}\n\n#define ASPM_ATTR(_f, _s)\t\t\t\t\t\t\\\nstatic ssize_t _f##_show(struct device *dev,\t\t\t\t\\\n\t\t\t struct device_attribute *attr, char *buf)\t\\\n{ return aspm_attr_show_common(dev, attr, buf, ASPM_STATE_##_s); }\t\\\n\t\t\t\t\t\t\t\t\t\\\nstatic ssize_t _f##_store(struct device *dev,\t\t\t\t\\\n\t\t\t  struct device_attribute *attr,\t\t\\\n\t\t\t  const char *buf, size_t len)\t\t\t\\\n{ return aspm_attr_store_common(dev, attr, buf, len, ASPM_STATE_##_s); }\n\nASPM_ATTR(l0s_aspm, L0S)\nASPM_ATTR(l1_aspm, L1)\nASPM_ATTR(l1_1_aspm, L1_1)\nASPM_ATTR(l1_2_aspm, L1_2)\nASPM_ATTR(l1_1_pcipm, L1_1_PCIPM)\nASPM_ATTR(l1_2_pcipm, L1_2_PCIPM)\n\nstatic ssize_t clkpm_show(struct device *dev,\n\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tstruct pcie_link_state *link = pcie_aspm_get_link(pdev);\n\n\treturn sysfs_emit(buf, \"%d\\n\", link->clkpm_enabled);\n}\n\nstatic ssize_t clkpm_store(struct device *dev,\n\t\t\t   struct device_attribute *attr,\n\t\t\t   const char *buf, size_t len)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tstruct pcie_link_state *link = pcie_aspm_get_link(pdev);\n\tbool state_enable;\n\n\tif (kstrtobool(buf, &state_enable) < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&pci_bus_sem);\n\tmutex_lock(&aspm_lock);\n\n\tlink->clkpm_disable = !state_enable;\n\tpcie_set_clkpm(link, policy_to_clkpm_state(link));\n\n\tmutex_unlock(&aspm_lock);\n\tup_read(&pci_bus_sem);\n\n\treturn len;\n}\n\nstatic DEVICE_ATTR_RW(clkpm);\nstatic DEVICE_ATTR_RW(l0s_aspm);\nstatic DEVICE_ATTR_RW(l1_aspm);\nstatic DEVICE_ATTR_RW(l1_1_aspm);\nstatic DEVICE_ATTR_RW(l1_2_aspm);\nstatic DEVICE_ATTR_RW(l1_1_pcipm);\nstatic DEVICE_ATTR_RW(l1_2_pcipm);\n\nstatic struct attribute *aspm_ctrl_attrs[] = {\n\t&dev_attr_clkpm.attr,\n\t&dev_attr_l0s_aspm.attr,\n\t&dev_attr_l1_aspm.attr,\n\t&dev_attr_l1_1_aspm.attr,\n\t&dev_attr_l1_2_aspm.attr,\n\t&dev_attr_l1_1_pcipm.attr,\n\t&dev_attr_l1_2_pcipm.attr,\n\tNULL\n};\n\nstatic umode_t aspm_ctrl_attrs_are_visible(struct kobject *kobj,\n\t\t\t\t\t   struct attribute *a, int n)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tstruct pcie_link_state *link = pcie_aspm_get_link(pdev);\n\tstatic const u8 aspm_state_map[] = {\n\t\tASPM_STATE_L0S,\n\t\tASPM_STATE_L1,\n\t\tASPM_STATE_L1_1,\n\t\tASPM_STATE_L1_2,\n\t\tASPM_STATE_L1_1_PCIPM,\n\t\tASPM_STATE_L1_2_PCIPM,\n\t};\n\n\tif (aspm_disabled || !link)\n\t\treturn 0;\n\n\tif (n == 0)\n\t\treturn link->clkpm_capable ? a->mode : 0;\n\n\treturn link->aspm_capable & aspm_state_map[n - 1] ? a->mode : 0;\n}\n\nconst struct attribute_group aspm_ctrl_attr_group = {\n\t.name = \"link\",\n\t.attrs = aspm_ctrl_attrs,\n\t.is_visible = aspm_ctrl_attrs_are_visible,\n};\n\nstatic int __init pcie_aspm_disable(char *str)\n{\n\tif (!strcmp(str, \"off\")) {\n\t\taspm_policy = POLICY_DEFAULT;\n\t\taspm_disabled = 1;\n\t\taspm_support_enabled = false;\n\t\tprintk(KERN_INFO \"PCIe ASPM is disabled\\n\");\n\t} else if (!strcmp(str, \"force\")) {\n\t\taspm_force = 1;\n\t\tprintk(KERN_INFO \"PCIe ASPM is forcibly enabled\\n\");\n\t}\n\treturn 1;\n}\n\n__setup(\"pcie_aspm=\", pcie_aspm_disable);\n\nvoid pcie_no_aspm(void)\n{\n\t \n\tif (!aspm_force) {\n\t\taspm_policy = POLICY_DEFAULT;\n\t\taspm_disabled = 1;\n\t}\n}\n\nbool pcie_aspm_support_enabled(void)\n{\n\treturn aspm_support_enabled;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}