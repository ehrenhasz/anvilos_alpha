{
  "module_name": "portdrv.h",
  "hash_id": "a1fb10b339aa0690b5302e9b7d0209c905b32f0eb32cdf18c1e30d9873fdf835",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/pcie/portdrv.h",
  "human_readable_source": " \n \n\n#ifndef _PORTDRV_H_\n#define _PORTDRV_H_\n\n#include <linux/compiler.h>\n\n \n#define PCIE_PORT_SERVICE_PME_SHIFT\t0\t \n#define PCIE_PORT_SERVICE_PME\t\t(1 << PCIE_PORT_SERVICE_PME_SHIFT)\n#define PCIE_PORT_SERVICE_AER_SHIFT\t1\t \n#define PCIE_PORT_SERVICE_AER\t\t(1 << PCIE_PORT_SERVICE_AER_SHIFT)\n#define PCIE_PORT_SERVICE_HP_SHIFT\t2\t \n#define PCIE_PORT_SERVICE_HP\t\t(1 << PCIE_PORT_SERVICE_HP_SHIFT)\n#define PCIE_PORT_SERVICE_DPC_SHIFT\t3\t \n#define PCIE_PORT_SERVICE_DPC\t\t(1 << PCIE_PORT_SERVICE_DPC_SHIFT)\n#define PCIE_PORT_SERVICE_BWNOTIF_SHIFT\t4\t \n#define PCIE_PORT_SERVICE_BWNOTIF\t(1 << PCIE_PORT_SERVICE_BWNOTIF_SHIFT)\n\n#define PCIE_PORT_DEVICE_MAXSERVICES   5\n\nextern bool pcie_ports_dpc_native;\n\n#ifdef CONFIG_PCIEAER\nint pcie_aer_init(void);\n#else\nstatic inline int pcie_aer_init(void) { return 0; }\n#endif\n\n#ifdef CONFIG_HOTPLUG_PCI_PCIE\nint pcie_hp_init(void);\n#else\nstatic inline int pcie_hp_init(void) { return 0; }\n#endif\n\n#ifdef CONFIG_PCIE_PME\nint pcie_pme_init(void);\n#else\nstatic inline int pcie_pme_init(void) { return 0; }\n#endif\n\n#ifdef CONFIG_PCIE_DPC\nint pcie_dpc_init(void);\n#else\nstatic inline int pcie_dpc_init(void) { return 0; }\n#endif\n\n \n#define PCIE_ANY_PORT\t\t\t(~0)\n\nstruct pcie_device {\n\tint\t\tirq;\t     \n\tstruct pci_dev *port;\t     \n\tu32\t\tservice;     \n\tvoid\t\t*priv_data;  \n\tstruct device\tdevice;      \n};\n#define to_pcie_device(d) container_of(d, struct pcie_device, device)\n\nstatic inline void set_service_data(struct pcie_device *dev, void *data)\n{\n\tdev->priv_data = data;\n}\n\nstatic inline void *get_service_data(struct pcie_device *dev)\n{\n\treturn dev->priv_data;\n}\n\nstruct pcie_port_service_driver {\n\tconst char *name;\n\tint (*probe)(struct pcie_device *dev);\n\tvoid (*remove)(struct pcie_device *dev);\n\tint (*suspend)(struct pcie_device *dev);\n\tint (*resume_noirq)(struct pcie_device *dev);\n\tint (*resume)(struct pcie_device *dev);\n\tint (*runtime_suspend)(struct pcie_device *dev);\n\tint (*runtime_resume)(struct pcie_device *dev);\n\n\tint (*slot_reset)(struct pcie_device *dev);\n\n\tint port_type;   \n\tu32 service;     \n\n\tstruct device_driver driver;\n};\n#define to_service_driver(d) \\\n\tcontainer_of(d, struct pcie_port_service_driver, driver)\n\nint pcie_port_service_register(struct pcie_port_service_driver *new);\nvoid pcie_port_service_unregister(struct pcie_port_service_driver *new);\n\nextern struct bus_type pcie_port_bus_type;\n\nstruct pci_dev;\n\n#ifdef CONFIG_PCIE_PME\nextern bool pcie_pme_msi_disabled;\n\nstatic inline void pcie_pme_disable_msi(void)\n{\n\tpcie_pme_msi_disabled = true;\n}\n\nstatic inline bool pcie_pme_no_msi(void)\n{\n\treturn pcie_pme_msi_disabled;\n}\n\nvoid pcie_pme_interrupt_enable(struct pci_dev *dev, bool enable);\n#else  \nstatic inline void pcie_pme_disable_msi(void) {}\nstatic inline bool pcie_pme_no_msi(void) { return false; }\nstatic inline void pcie_pme_interrupt_enable(struct pci_dev *dev, bool en) {}\n#endif  \n\nstruct device *pcie_port_find_device(struct pci_dev *dev, u32 service);\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}