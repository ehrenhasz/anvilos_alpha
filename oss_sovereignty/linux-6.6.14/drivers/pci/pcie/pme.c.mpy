{
  "module_name": "pme.c",
  "hash_id": "1a8fa88bf2432b690358101e026279d3fbcd1ffbc617bf12cb0e182a6ac69c29",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/pcie/pme.c",
  "human_readable_source": "\n \n\n#define dev_fmt(fmt) \"PME: \" fmt\n\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/device.h>\n#include <linux/pm_runtime.h>\n\n#include \"../pci.h\"\n#include \"portdrv.h\"\n\n \nbool pcie_pme_msi_disabled;\n\nstatic int __init pcie_pme_setup(char *str)\n{\n\tif (!strncmp(str, \"nomsi\", 5))\n\t\tpcie_pme_msi_disabled = true;\n\n\treturn 1;\n}\n__setup(\"pcie_pme=\", pcie_pme_setup);\n\nstruct pcie_pme_service_data {\n\tspinlock_t lock;\n\tstruct pcie_device *srv;\n\tstruct work_struct work;\n\tbool noirq;  \n};\n\n \nvoid pcie_pme_interrupt_enable(struct pci_dev *dev, bool enable)\n{\n\tif (enable)\n\t\tpcie_capability_set_word(dev, PCI_EXP_RTCTL,\n\t\t\t\t\t PCI_EXP_RTCTL_PMEIE);\n\telse\n\t\tpcie_capability_clear_word(dev, PCI_EXP_RTCTL,\n\t\t\t\t\t   PCI_EXP_RTCTL_PMEIE);\n}\n\n \nstatic bool pcie_pme_walk_bus(struct pci_bus *bus)\n{\n\tstruct pci_dev *dev;\n\tbool ret = false;\n\n\tlist_for_each_entry(dev, &bus->devices, bus_list) {\n\t\t \n\t\tif (!pci_is_pcie(dev) && pci_check_pme_status(dev)) {\n\t\t\tif (dev->pme_poll)\n\t\t\t\tdev->pme_poll = false;\n\n\t\t\tpci_wakeup_event(dev);\n\t\t\tpm_request_resume(&dev->dev);\n\t\t\tret = true;\n\t\t}\n\n\t\tif (dev->subordinate && pcie_pme_walk_bus(dev->subordinate))\n\t\t\tret = true;\n\t}\n\n\treturn ret;\n}\n\n \nstatic bool pcie_pme_from_pci_bridge(struct pci_bus *bus, u8 devfn)\n{\n\tstruct pci_dev *dev;\n\tbool found = false;\n\n\tif (devfn)\n\t\treturn false;\n\n\tdev = pci_dev_get(bus->self);\n\tif (!dev)\n\t\treturn false;\n\n\tif (pci_is_pcie(dev) && pci_pcie_type(dev) == PCI_EXP_TYPE_PCI_BRIDGE) {\n\t\tdown_read(&pci_bus_sem);\n\t\tif (pcie_pme_walk_bus(bus))\n\t\t\tfound = true;\n\t\tup_read(&pci_bus_sem);\n\t}\n\n\tpci_dev_put(dev);\n\treturn found;\n}\n\n \nstatic void pcie_pme_handle_request(struct pci_dev *port, u16 req_id)\n{\n\tu8 busnr = req_id >> 8, devfn = req_id & 0xff;\n\tstruct pci_bus *bus;\n\tstruct pci_dev *dev;\n\tbool found = false;\n\n\t \n\tif (port->devfn == devfn && port->bus->number == busnr) {\n\t\tif (port->pme_poll)\n\t\t\tport->pme_poll = false;\n\n\t\tif (pci_check_pme_status(port)) {\n\t\t\tpm_request_resume(&port->dev);\n\t\t\tfound = true;\n\t\t} else {\n\t\t\t \n\t\t\tdown_read(&pci_bus_sem);\n\t\t\tfound = pcie_pme_walk_bus(port->subordinate);\n\t\t\tup_read(&pci_bus_sem);\n\t\t}\n\t\tgoto out;\n\t}\n\n\t \n\tbus = pci_find_bus(pci_domain_nr(port->bus), busnr);\n\tif (!bus)\n\t\tgoto out;\n\n\t \n\tfound = pcie_pme_from_pci_bridge(bus, devfn);\n\tif (found)\n\t\tgoto out;\n\n\t \n\tdown_read(&pci_bus_sem);\n\tlist_for_each_entry(dev, &bus->devices, bus_list) {\n\t\tpci_dev_get(dev);\n\t\tif (dev->devfn == devfn) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t\tpci_dev_put(dev);\n\t}\n\tup_read(&pci_bus_sem);\n\n\tif (found) {\n\t\t \n\t\tfound = pci_check_pme_status(dev);\n\t\tif (found) {\n\t\t\tif (dev->pme_poll)\n\t\t\t\tdev->pme_poll = false;\n\n\t\t\tpci_wakeup_event(dev);\n\t\t\tpm_request_resume(&dev->dev);\n\t\t}\n\t\tpci_dev_put(dev);\n\t} else if (devfn) {\n\t\t \n\t\tpci_info(port, \"interrupt generated for non-existent device %02x:%02x.%d\\n\",\n\t\t\t busnr, PCI_SLOT(devfn), PCI_FUNC(devfn));\n\t\tfound = pcie_pme_from_pci_bridge(bus, 0);\n\t}\n\n out:\n\tif (!found)\n\t\tpci_info(port, \"Spurious native interrupt!\\n\");\n}\n\n \nstatic void pcie_pme_work_fn(struct work_struct *work)\n{\n\tstruct pcie_pme_service_data *data =\n\t\t\tcontainer_of(work, struct pcie_pme_service_data, work);\n\tstruct pci_dev *port = data->srv->port;\n\tu32 rtsta;\n\n\tspin_lock_irq(&data->lock);\n\n\tfor (;;) {\n\t\tif (data->noirq)\n\t\t\tbreak;\n\n\t\tpcie_capability_read_dword(port, PCI_EXP_RTSTA, &rtsta);\n\t\tif (PCI_POSSIBLE_ERROR(rtsta))\n\t\t\tbreak;\n\n\t\tif (rtsta & PCI_EXP_RTSTA_PME) {\n\t\t\t \n\t\t\tpcie_clear_root_pme_status(port);\n\n\t\t\tspin_unlock_irq(&data->lock);\n\t\t\tpcie_pme_handle_request(port, rtsta & 0xffff);\n\t\t\tspin_lock_irq(&data->lock);\n\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (!(rtsta & PCI_EXP_RTSTA_PENDING))\n\t\t\tbreak;\n\n\t\tspin_unlock_irq(&data->lock);\n\t\tcpu_relax();\n\t\tspin_lock_irq(&data->lock);\n\t}\n\n\tif (!data->noirq)\n\t\tpcie_pme_interrupt_enable(port, true);\n\n\tspin_unlock_irq(&data->lock);\n}\n\n \nstatic irqreturn_t pcie_pme_irq(int irq, void *context)\n{\n\tstruct pci_dev *port;\n\tstruct pcie_pme_service_data *data;\n\tu32 rtsta;\n\tunsigned long flags;\n\n\tport = ((struct pcie_device *)context)->port;\n\tdata = get_service_data((struct pcie_device *)context);\n\n\tspin_lock_irqsave(&data->lock, flags);\n\tpcie_capability_read_dword(port, PCI_EXP_RTSTA, &rtsta);\n\n\tif (PCI_POSSIBLE_ERROR(rtsta) || !(rtsta & PCI_EXP_RTSTA_PME)) {\n\t\tspin_unlock_irqrestore(&data->lock, flags);\n\t\treturn IRQ_NONE;\n\t}\n\n\tpcie_pme_interrupt_enable(port, false);\n\tspin_unlock_irqrestore(&data->lock, flags);\n\n\t \n\tschedule_work(&data->work);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic int pcie_pme_can_wakeup(struct pci_dev *dev, void *ign)\n{\n\tdevice_set_wakeup_capable(&dev->dev, true);\n\treturn 0;\n}\n\n \nstatic void pcie_pme_mark_devices(struct pci_dev *port)\n{\n\tpcie_pme_can_wakeup(port, NULL);\n\n\tif (pci_pcie_type(port) == PCI_EXP_TYPE_RC_EC)\n\t\tpcie_walk_rcec(port, pcie_pme_can_wakeup, NULL);\n\telse if (port->subordinate)\n\t\tpci_walk_bus(port->subordinate, pcie_pme_can_wakeup, NULL);\n}\n\n \nstatic int pcie_pme_probe(struct pcie_device *srv)\n{\n\tstruct pci_dev *port = srv->port;\n\tstruct pcie_pme_service_data *data;\n\tint type = pci_pcie_type(port);\n\tint ret;\n\n\t \n\tif (type != PCI_EXP_TYPE_RC_EC &&\n\t    type != PCI_EXP_TYPE_ROOT_PORT)\n\t\treturn -ENODEV;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&data->lock);\n\tINIT_WORK(&data->work, pcie_pme_work_fn);\n\tdata->srv = srv;\n\tset_service_data(srv, data);\n\n\tpcie_pme_interrupt_enable(port, false);\n\tpcie_clear_root_pme_status(port);\n\n\tret = request_irq(srv->irq, pcie_pme_irq, IRQF_SHARED, \"PCIe PME\", srv);\n\tif (ret) {\n\t\tkfree(data);\n\t\treturn ret;\n\t}\n\n\tpci_info(port, \"Signaling with IRQ %d\\n\", srv->irq);\n\n\tpcie_pme_mark_devices(port);\n\tpcie_pme_interrupt_enable(port, true);\n\treturn 0;\n}\n\nstatic bool pcie_pme_check_wakeup(struct pci_bus *bus)\n{\n\tstruct pci_dev *dev;\n\n\tif (!bus)\n\t\treturn false;\n\n\tlist_for_each_entry(dev, &bus->devices, bus_list)\n\t\tif (device_may_wakeup(&dev->dev)\n\t\t    || pcie_pme_check_wakeup(dev->subordinate))\n\t\t\treturn true;\n\n\treturn false;\n}\n\nstatic void pcie_pme_disable_interrupt(struct pci_dev *port,\n\t\t\t\t       struct pcie_pme_service_data *data)\n{\n\tspin_lock_irq(&data->lock);\n\tpcie_pme_interrupt_enable(port, false);\n\tpcie_clear_root_pme_status(port);\n\tdata->noirq = true;\n\tspin_unlock_irq(&data->lock);\n}\n\n \nstatic int pcie_pme_suspend(struct pcie_device *srv)\n{\n\tstruct pcie_pme_service_data *data = get_service_data(srv);\n\tstruct pci_dev *port = srv->port;\n\tbool wakeup;\n\tint ret;\n\n\tif (device_may_wakeup(&port->dev)) {\n\t\twakeup = true;\n\t} else {\n\t\tdown_read(&pci_bus_sem);\n\t\twakeup = pcie_pme_check_wakeup(port->subordinate);\n\t\tup_read(&pci_bus_sem);\n\t}\n\tif (wakeup) {\n\t\tret = enable_irq_wake(srv->irq);\n\t\tif (!ret)\n\t\t\treturn 0;\n\t}\n\n\tpcie_pme_disable_interrupt(port, data);\n\n\tsynchronize_irq(srv->irq);\n\n\treturn 0;\n}\n\n \nstatic int pcie_pme_resume(struct pcie_device *srv)\n{\n\tstruct pcie_pme_service_data *data = get_service_data(srv);\n\n\tspin_lock_irq(&data->lock);\n\tif (data->noirq) {\n\t\tstruct pci_dev *port = srv->port;\n\n\t\tpcie_clear_root_pme_status(port);\n\t\tpcie_pme_interrupt_enable(port, true);\n\t\tdata->noirq = false;\n\t} else {\n\t\tdisable_irq_wake(srv->irq);\n\t}\n\tspin_unlock_irq(&data->lock);\n\n\treturn 0;\n}\n\n \nstatic void pcie_pme_remove(struct pcie_device *srv)\n{\n\tstruct pcie_pme_service_data *data = get_service_data(srv);\n\n\tpcie_pme_disable_interrupt(srv->port, data);\n\tfree_irq(srv->irq, srv);\n\tcancel_work_sync(&data->work);\n\tkfree(data);\n}\n\nstatic struct pcie_port_service_driver pcie_pme_driver = {\n\t.name\t\t= \"pcie_pme\",\n\t.port_type\t= PCIE_ANY_PORT,\n\t.service\t= PCIE_PORT_SERVICE_PME,\n\n\t.probe\t\t= pcie_pme_probe,\n\t.suspend\t= pcie_pme_suspend,\n\t.resume\t\t= pcie_pme_resume,\n\t.remove\t\t= pcie_pme_remove,\n};\n\n \nint __init pcie_pme_init(void)\n{\n\treturn pcie_port_service_register(&pcie_pme_driver);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}