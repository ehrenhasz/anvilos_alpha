{
  "module_name": "rcec.c",
  "hash_id": "9e741310beff7db12affae7863aea75587bac40e416b242817ea87de4efeadb9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/pcie/rcec.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/pci.h>\n#include <linux/pci_regs.h>\n\n#include \"../pci.h\"\n\nstruct walk_rcec_data {\n\tstruct pci_dev *rcec;\n\tint (*user_callback)(struct pci_dev *dev, void *data);\n\tvoid *user_data;\n};\n\nstatic bool rcec_assoc_rciep(struct pci_dev *rcec, struct pci_dev *rciep)\n{\n\tunsigned long bitmap = rcec->rcec_ea->bitmap;\n\tunsigned int devn;\n\n\t \n\tif (rcec->bus->number != rciep->bus->number)\n\t\treturn true;\n\n\t \n\tfor_each_set_bit(devn, &bitmap, 32)\n\t\tif (devn == PCI_SLOT(rciep->devfn))\n\t\t\treturn true;\n\n\treturn false;\n}\n\nstatic int link_rcec_helper(struct pci_dev *dev, void *data)\n{\n\tstruct walk_rcec_data *rcec_data = data;\n\tstruct pci_dev *rcec = rcec_data->rcec;\n\n\tif ((pci_pcie_type(dev) == PCI_EXP_TYPE_RC_END) &&\n\t    rcec_assoc_rciep(rcec, dev)) {\n\t\tdev->rcec = rcec;\n\t\tpci_dbg(dev, \"PME & error events signaled via %s\\n\",\n\t\t\tpci_name(rcec));\n\t}\n\n\treturn 0;\n}\n\nstatic int walk_rcec_helper(struct pci_dev *dev, void *data)\n{\n\tstruct walk_rcec_data *rcec_data = data;\n\tstruct pci_dev *rcec = rcec_data->rcec;\n\n\tif ((pci_pcie_type(dev) == PCI_EXP_TYPE_RC_END) &&\n\t    rcec_assoc_rciep(rcec, dev))\n\t\trcec_data->user_callback(dev, rcec_data->user_data);\n\n\treturn 0;\n}\n\nstatic void walk_rcec(int (*cb)(struct pci_dev *dev, void *data),\n\t\t      void *userdata)\n{\n\tstruct walk_rcec_data *rcec_data = userdata;\n\tstruct pci_dev *rcec = rcec_data->rcec;\n\tu8 nextbusn, lastbusn;\n\tstruct pci_bus *bus;\n\tunsigned int bnr;\n\n\tif (!rcec->rcec_ea)\n\t\treturn;\n\n\t \n\tpci_walk_bus(rcec->bus, cb, rcec_data);\n\n\tnextbusn = rcec->rcec_ea->nextbusn;\n\tlastbusn = rcec->rcec_ea->lastbusn;\n\n\t \n\tif (nextbusn == 0xff && lastbusn == 0x00)\n\t\treturn;\n\n\tfor (bnr = nextbusn; bnr <= lastbusn; bnr++) {\n\t\t \n\t\tif (bnr == rcec->bus->number)\n\t\t\tcontinue;\n\n\t\tbus = pci_find_bus(pci_domain_nr(rcec->bus), bnr);\n\t\tif (!bus)\n\t\t\tcontinue;\n\n\t\t \n\t\tpci_walk_bus(bus, cb, rcec_data);\n\t}\n}\n\n \nvoid pcie_link_rcec(struct pci_dev *rcec)\n{\n\tstruct walk_rcec_data rcec_data;\n\n\tif (!rcec->rcec_ea)\n\t\treturn;\n\n\trcec_data.rcec = rcec;\n\trcec_data.user_callback = NULL;\n\trcec_data.user_data = NULL;\n\n\twalk_rcec(link_rcec_helper, &rcec_data);\n}\n\n \nvoid pcie_walk_rcec(struct pci_dev *rcec, int (*cb)(struct pci_dev *, void *),\n\t\t    void *userdata)\n{\n\tstruct walk_rcec_data rcec_data;\n\n\tif (!rcec->rcec_ea)\n\t\treturn;\n\n\trcec_data.rcec = rcec;\n\trcec_data.user_callback = cb;\n\trcec_data.user_data = userdata;\n\n\twalk_rcec(walk_rcec_helper, &rcec_data);\n}\n\nvoid pci_rcec_init(struct pci_dev *dev)\n{\n\tstruct rcec_ea *rcec_ea;\n\tu32 rcec, hdr, busn;\n\tu8 ver;\n\n\t \n\tif (pci_pcie_type(dev) != PCI_EXP_TYPE_RC_EC)\n\t\treturn;\n\n\trcec = pci_find_ext_capability(dev, PCI_EXT_CAP_ID_RCEC);\n\tif (!rcec)\n\t\treturn;\n\n\trcec_ea = kzalloc(sizeof(*rcec_ea), GFP_KERNEL);\n\tif (!rcec_ea)\n\t\treturn;\n\n\tpci_read_config_dword(dev, rcec + PCI_RCEC_RCIEP_BITMAP,\n\t\t\t      &rcec_ea->bitmap);\n\n\t \n\tpci_read_config_dword(dev, rcec, &hdr);\n\tver = PCI_EXT_CAP_VER(hdr);\n\tif (ver >= PCI_RCEC_BUSN_REG_VER) {\n\t\tpci_read_config_dword(dev, rcec + PCI_RCEC_BUSN, &busn);\n\t\trcec_ea->nextbusn = PCI_RCEC_BUSN_NEXT(busn);\n\t\trcec_ea->lastbusn = PCI_RCEC_BUSN_LAST(busn);\n\t} else {\n\t\t \n\t\trcec_ea->nextbusn = 0xff;\n\t\trcec_ea->lastbusn = 0x00;\n\t}\n\n\tdev->rcec_ea = rcec_ea;\n}\n\nvoid pci_rcec_exit(struct pci_dev *dev)\n{\n\tkfree(dev->rcec_ea);\n\tdev->rcec_ea = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}