{
  "module_name": "aer.c",
  "hash_id": "c168db03367f484b089083104a6519a8e861af86176d9ced825ec11a5d9e94a0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/pcie/aer.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"AER: \" fmt\n#define dev_fmt pr_fmt\n\n#include <linux/bitops.h>\n#include <linux/cper.h>\n#include <linux/pci.h>\n#include <linux/pci-acpi.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/pm.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n#include <linux/kfifo.h>\n#include <linux/slab.h>\n#include <acpi/apei.h>\n#include <acpi/ghes.h>\n#include <ras/ras_event.h>\n\n#include \"../pci.h\"\n#include \"portdrv.h\"\n\n#define AER_ERROR_SOURCES_MAX\t\t128\n\n#define AER_MAX_TYPEOF_COR_ERRS\t\t16\t \n#define AER_MAX_TYPEOF_UNCOR_ERRS\t27\t \n\nstruct aer_err_source {\n\tunsigned int status;\n\tunsigned int id;\n};\n\nstruct aer_rpc {\n\tstruct pci_dev *rpd;\t\t \n\tDECLARE_KFIFO(aer_fifo, struct aer_err_source, AER_ERROR_SOURCES_MAX);\n};\n\n \nstruct aer_stats {\n\n\t \n\t \n\tu64 dev_cor_errs[AER_MAX_TYPEOF_COR_ERRS];\n\t \n\tu64 dev_fatal_errs[AER_MAX_TYPEOF_UNCOR_ERRS];\n\t \n\tu64 dev_nonfatal_errs[AER_MAX_TYPEOF_UNCOR_ERRS];\n\t \n\tu64 dev_total_cor_errs;\n\t \n\tu64 dev_total_fatal_errs;\n\t \n\tu64 dev_total_nonfatal_errs;\n\n\t \n\tu64 rootport_total_cor_errs;\n\tu64 rootport_total_fatal_errs;\n\tu64 rootport_total_nonfatal_errs;\n};\n\n#define AER_LOG_TLP_MASKS\t\t(PCI_ERR_UNC_POISON_TLP|\t\\\n\t\t\t\t\tPCI_ERR_UNC_ECRC|\t\t\\\n\t\t\t\t\tPCI_ERR_UNC_UNSUP|\t\t\\\n\t\t\t\t\tPCI_ERR_UNC_COMP_ABORT|\t\t\\\n\t\t\t\t\tPCI_ERR_UNC_UNX_COMP|\t\t\\\n\t\t\t\t\tPCI_ERR_UNC_MALF_TLP)\n\n#define SYSTEM_ERROR_INTR_ON_MESG_MASK\t(PCI_EXP_RTCTL_SECEE|\t\\\n\t\t\t\t\tPCI_EXP_RTCTL_SENFEE|\t\\\n\t\t\t\t\tPCI_EXP_RTCTL_SEFEE)\n#define ROOT_PORT_INTR_ON_MESG_MASK\t(PCI_ERR_ROOT_CMD_COR_EN|\t\\\n\t\t\t\t\tPCI_ERR_ROOT_CMD_NONFATAL_EN|\t\\\n\t\t\t\t\tPCI_ERR_ROOT_CMD_FATAL_EN)\n#define ERR_COR_ID(d)\t\t\t(d & 0xffff)\n#define ERR_UNCOR_ID(d)\t\t\t(d >> 16)\n\n#define AER_ERR_STATUS_MASK\t\t(PCI_ERR_ROOT_UNCOR_RCV |\t\\\n\t\t\t\t\tPCI_ERR_ROOT_COR_RCV |\t\t\\\n\t\t\t\t\tPCI_ERR_ROOT_MULTI_COR_RCV |\t\\\n\t\t\t\t\tPCI_ERR_ROOT_MULTI_UNCOR_RCV)\n\nstatic int pcie_aer_disable;\nstatic pci_ers_result_t aer_root_reset(struct pci_dev *dev);\n\nvoid pci_no_aer(void)\n{\n\tpcie_aer_disable = 1;\n}\n\nbool pci_aer_available(void)\n{\n\treturn !pcie_aer_disable && pci_msi_enabled();\n}\n\n#ifdef CONFIG_PCIE_ECRC\n\n#define ECRC_POLICY_DEFAULT 0\t\t \n#define ECRC_POLICY_OFF     1\t\t \n#define ECRC_POLICY_ON      2\t\t \n\nstatic int ecrc_policy = ECRC_POLICY_DEFAULT;\n\nstatic const char * const ecrc_policy_str[] = {\n\t[ECRC_POLICY_DEFAULT] = \"bios\",\n\t[ECRC_POLICY_OFF] = \"off\",\n\t[ECRC_POLICY_ON] = \"on\"\n};\n\n \nstatic int enable_ecrc_checking(struct pci_dev *dev)\n{\n\tint aer = dev->aer_cap;\n\tu32 reg32;\n\n\tif (!aer)\n\t\treturn -ENODEV;\n\n\tpci_read_config_dword(dev, aer + PCI_ERR_CAP, &reg32);\n\tif (reg32 & PCI_ERR_CAP_ECRC_GENC)\n\t\treg32 |= PCI_ERR_CAP_ECRC_GENE;\n\tif (reg32 & PCI_ERR_CAP_ECRC_CHKC)\n\t\treg32 |= PCI_ERR_CAP_ECRC_CHKE;\n\tpci_write_config_dword(dev, aer + PCI_ERR_CAP, reg32);\n\n\treturn 0;\n}\n\n \nstatic int disable_ecrc_checking(struct pci_dev *dev)\n{\n\tint aer = dev->aer_cap;\n\tu32 reg32;\n\n\tif (!aer)\n\t\treturn -ENODEV;\n\n\tpci_read_config_dword(dev, aer + PCI_ERR_CAP, &reg32);\n\treg32 &= ~(PCI_ERR_CAP_ECRC_GENE | PCI_ERR_CAP_ECRC_CHKE);\n\tpci_write_config_dword(dev, aer + PCI_ERR_CAP, reg32);\n\n\treturn 0;\n}\n\n \nvoid pcie_set_ecrc_checking(struct pci_dev *dev)\n{\n\tif (!pcie_aer_is_native(dev))\n\t\treturn;\n\n\tswitch (ecrc_policy) {\n\tcase ECRC_POLICY_DEFAULT:\n\t\treturn;\n\tcase ECRC_POLICY_OFF:\n\t\tdisable_ecrc_checking(dev);\n\t\tbreak;\n\tcase ECRC_POLICY_ON:\n\t\tenable_ecrc_checking(dev);\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n}\n\n \nvoid pcie_ecrc_get_policy(char *str)\n{\n\tint i;\n\n\ti = match_string(ecrc_policy_str, ARRAY_SIZE(ecrc_policy_str), str);\n\tif (i < 0)\n\t\treturn;\n\n\tecrc_policy = i;\n}\n#endif\t \n\n#define\tPCI_EXP_AER_FLAGS\t(PCI_EXP_DEVCTL_CERE | PCI_EXP_DEVCTL_NFERE | \\\n\t\t\t\t PCI_EXP_DEVCTL_FERE | PCI_EXP_DEVCTL_URRE)\n\nint pcie_aer_is_native(struct pci_dev *dev)\n{\n\tstruct pci_host_bridge *host = pci_find_host_bridge(dev->bus);\n\n\tif (!dev->aer_cap)\n\t\treturn 0;\n\n\treturn pcie_ports_native || host->native_aer;\n}\nEXPORT_SYMBOL_NS_GPL(pcie_aer_is_native, CXL);\n\nstatic int pci_enable_pcie_error_reporting(struct pci_dev *dev)\n{\n\tint rc;\n\n\tif (!pcie_aer_is_native(dev))\n\t\treturn -EIO;\n\n\trc = pcie_capability_set_word(dev, PCI_EXP_DEVCTL, PCI_EXP_AER_FLAGS);\n\treturn pcibios_err_to_errno(rc);\n}\n\nint pci_aer_clear_nonfatal_status(struct pci_dev *dev)\n{\n\tint aer = dev->aer_cap;\n\tu32 status, sev;\n\n\tif (!pcie_aer_is_native(dev))\n\t\treturn -EIO;\n\n\t \n\tpci_read_config_dword(dev, aer + PCI_ERR_UNCOR_STATUS, &status);\n\tpci_read_config_dword(dev, aer + PCI_ERR_UNCOR_SEVER, &sev);\n\tstatus &= ~sev;\n\tif (status)\n\t\tpci_write_config_dword(dev, aer + PCI_ERR_UNCOR_STATUS, status);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(pci_aer_clear_nonfatal_status);\n\nvoid pci_aer_clear_fatal_status(struct pci_dev *dev)\n{\n\tint aer = dev->aer_cap;\n\tu32 status, sev;\n\n\tif (!pcie_aer_is_native(dev))\n\t\treturn;\n\n\t \n\tpci_read_config_dword(dev, aer + PCI_ERR_UNCOR_STATUS, &status);\n\tpci_read_config_dword(dev, aer + PCI_ERR_UNCOR_SEVER, &sev);\n\tstatus &= sev;\n\tif (status)\n\t\tpci_write_config_dword(dev, aer + PCI_ERR_UNCOR_STATUS, status);\n}\n\n \nint pci_aer_raw_clear_status(struct pci_dev *dev)\n{\n\tint aer = dev->aer_cap;\n\tu32 status;\n\tint port_type;\n\n\tif (!aer)\n\t\treturn -EIO;\n\n\tport_type = pci_pcie_type(dev);\n\tif (port_type == PCI_EXP_TYPE_ROOT_PORT ||\n\t    port_type == PCI_EXP_TYPE_RC_EC) {\n\t\tpci_read_config_dword(dev, aer + PCI_ERR_ROOT_STATUS, &status);\n\t\tpci_write_config_dword(dev, aer + PCI_ERR_ROOT_STATUS, status);\n\t}\n\n\tpci_read_config_dword(dev, aer + PCI_ERR_COR_STATUS, &status);\n\tpci_write_config_dword(dev, aer + PCI_ERR_COR_STATUS, status);\n\n\tpci_read_config_dword(dev, aer + PCI_ERR_UNCOR_STATUS, &status);\n\tpci_write_config_dword(dev, aer + PCI_ERR_UNCOR_STATUS, status);\n\n\treturn 0;\n}\n\nint pci_aer_clear_status(struct pci_dev *dev)\n{\n\tif (!pcie_aer_is_native(dev))\n\t\treturn -EIO;\n\n\treturn pci_aer_raw_clear_status(dev);\n}\n\nvoid pci_save_aer_state(struct pci_dev *dev)\n{\n\tint aer = dev->aer_cap;\n\tstruct pci_cap_saved_state *save_state;\n\tu32 *cap;\n\n\tif (!aer)\n\t\treturn;\n\n\tsave_state = pci_find_saved_ext_cap(dev, PCI_EXT_CAP_ID_ERR);\n\tif (!save_state)\n\t\treturn;\n\n\tcap = &save_state->cap.data[0];\n\tpci_read_config_dword(dev, aer + PCI_ERR_UNCOR_MASK, cap++);\n\tpci_read_config_dword(dev, aer + PCI_ERR_UNCOR_SEVER, cap++);\n\tpci_read_config_dword(dev, aer + PCI_ERR_COR_MASK, cap++);\n\tpci_read_config_dword(dev, aer + PCI_ERR_CAP, cap++);\n\tif (pcie_cap_has_rtctl(dev))\n\t\tpci_read_config_dword(dev, aer + PCI_ERR_ROOT_COMMAND, cap++);\n}\n\nvoid pci_restore_aer_state(struct pci_dev *dev)\n{\n\tint aer = dev->aer_cap;\n\tstruct pci_cap_saved_state *save_state;\n\tu32 *cap;\n\n\tif (!aer)\n\t\treturn;\n\n\tsave_state = pci_find_saved_ext_cap(dev, PCI_EXT_CAP_ID_ERR);\n\tif (!save_state)\n\t\treturn;\n\n\tcap = &save_state->cap.data[0];\n\tpci_write_config_dword(dev, aer + PCI_ERR_UNCOR_MASK, *cap++);\n\tpci_write_config_dword(dev, aer + PCI_ERR_UNCOR_SEVER, *cap++);\n\tpci_write_config_dword(dev, aer + PCI_ERR_COR_MASK, *cap++);\n\tpci_write_config_dword(dev, aer + PCI_ERR_CAP, *cap++);\n\tif (pcie_cap_has_rtctl(dev))\n\t\tpci_write_config_dword(dev, aer + PCI_ERR_ROOT_COMMAND, *cap++);\n}\n\nvoid pci_aer_init(struct pci_dev *dev)\n{\n\tint n;\n\n\tdev->aer_cap = pci_find_ext_capability(dev, PCI_EXT_CAP_ID_ERR);\n\tif (!dev->aer_cap)\n\t\treturn;\n\n\tdev->aer_stats = kzalloc(sizeof(struct aer_stats), GFP_KERNEL);\n\n\t \n\tn = pcie_cap_has_rtctl(dev) ? 5 : 4;\n\tpci_add_ext_cap_save_buffer(dev, PCI_EXT_CAP_ID_ERR, sizeof(u32) * n);\n\n\tpci_aer_clear_status(dev);\n\n\tif (pci_aer_available())\n\t\tpci_enable_pcie_error_reporting(dev);\n\n\tpcie_set_ecrc_checking(dev);\n}\n\nvoid pci_aer_exit(struct pci_dev *dev)\n{\n\tkfree(dev->aer_stats);\n\tdev->aer_stats = NULL;\n}\n\n#define AER_AGENT_RECEIVER\t\t0\n#define AER_AGENT_REQUESTER\t\t1\n#define AER_AGENT_COMPLETER\t\t2\n#define AER_AGENT_TRANSMITTER\t\t3\n\n#define AER_AGENT_REQUESTER_MASK(t)\t((t == AER_CORRECTABLE) ?\t\\\n\t0 : (PCI_ERR_UNC_COMP_TIME|PCI_ERR_UNC_UNSUP))\n#define AER_AGENT_COMPLETER_MASK(t)\t((t == AER_CORRECTABLE) ?\t\\\n\t0 : PCI_ERR_UNC_COMP_ABORT)\n#define AER_AGENT_TRANSMITTER_MASK(t)\t((t == AER_CORRECTABLE) ?\t\\\n\t(PCI_ERR_COR_REP_ROLL|PCI_ERR_COR_REP_TIMER) : 0)\n\n#define AER_GET_AGENT(t, e)\t\t\t\t\t\t\\\n\t((e & AER_AGENT_COMPLETER_MASK(t)) ? AER_AGENT_COMPLETER :\t\\\n\t(e & AER_AGENT_REQUESTER_MASK(t)) ? AER_AGENT_REQUESTER :\t\\\n\t(e & AER_AGENT_TRANSMITTER_MASK(t)) ? AER_AGENT_TRANSMITTER :\t\\\n\tAER_AGENT_RECEIVER)\n\n#define AER_PHYSICAL_LAYER_ERROR\t0\n#define AER_DATA_LINK_LAYER_ERROR\t1\n#define AER_TRANSACTION_LAYER_ERROR\t2\n\n#define AER_PHYSICAL_LAYER_ERROR_MASK(t) ((t == AER_CORRECTABLE) ?\t\\\n\tPCI_ERR_COR_RCVR : 0)\n#define AER_DATA_LINK_LAYER_ERROR_MASK(t) ((t == AER_CORRECTABLE) ?\t\\\n\t(PCI_ERR_COR_BAD_TLP|\t\t\t\t\t\t\\\n\tPCI_ERR_COR_BAD_DLLP|\t\t\t\t\t\t\\\n\tPCI_ERR_COR_REP_ROLL|\t\t\t\t\t\t\\\n\tPCI_ERR_COR_REP_TIMER) : PCI_ERR_UNC_DLP)\n\n#define AER_GET_LAYER_ERROR(t, e)\t\t\t\t\t\\\n\t((e & AER_PHYSICAL_LAYER_ERROR_MASK(t)) ? AER_PHYSICAL_LAYER_ERROR : \\\n\t(e & AER_DATA_LINK_LAYER_ERROR_MASK(t)) ? AER_DATA_LINK_LAYER_ERROR : \\\n\tAER_TRANSACTION_LAYER_ERROR)\n\n \nstatic const char *aer_error_severity_string[] = {\n\t\"Uncorrected (Non-Fatal)\",\n\t\"Uncorrected (Fatal)\",\n\t\"Corrected\"\n};\n\nstatic const char *aer_error_layer[] = {\n\t\"Physical Layer\",\n\t\"Data Link Layer\",\n\t\"Transaction Layer\"\n};\n\nstatic const char *aer_correctable_error_string[] = {\n\t\"RxErr\",\t\t\t \n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\t\"BadTLP\",\t\t\t \n\t\"BadDLLP\",\t\t\t \n\t\"Rollover\",\t\t\t \n\tNULL,\n\tNULL,\n\tNULL,\n\t\"Timeout\",\t\t\t \n\t\"NonFatalErr\",\t\t\t \n\t\"CorrIntErr\",\t\t\t \n\t\"HeaderOF\",\t\t\t \n\tNULL,\t\t\t\t \n\tNULL,\t\t\t\t \n\tNULL,\t\t\t\t \n\tNULL,\t\t\t\t \n\tNULL,\t\t\t\t \n\tNULL,\t\t\t\t \n\tNULL,\t\t\t\t \n\tNULL,\t\t\t\t \n\tNULL,\t\t\t\t \n\tNULL,\t\t\t\t \n\tNULL,\t\t\t\t \n\tNULL,\t\t\t\t \n\tNULL,\t\t\t\t \n\tNULL,\t\t\t\t \n\tNULL,\t\t\t\t \n\tNULL,\t\t\t\t \n};\n\nstatic const char *aer_uncorrectable_error_string[] = {\n\t\"Undefined\",\t\t\t \n\tNULL,\n\tNULL,\n\tNULL,\n\t\"DLP\",\t\t\t\t \n\t\"SDES\",\t\t\t\t \n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\t\"TLP\",\t\t\t\t \n\t\"FCP\",\t\t\t\t \n\t\"CmpltTO\",\t\t\t \n\t\"CmpltAbrt\",\t\t\t \n\t\"UnxCmplt\",\t\t\t \n\t\"RxOF\",\t\t\t\t \n\t\"MalfTLP\",\t\t\t \n\t\"ECRC\",\t\t\t\t \n\t\"UnsupReq\",\t\t\t \n\t\"ACSViol\",\t\t\t \n\t\"UncorrIntErr\",\t\t\t \n\t\"BlockedTLP\",\t\t\t \n\t\"AtomicOpBlocked\",\t\t \n\t\"TLPBlockedErr\",\t\t \n\t\"PoisonTLPBlocked\",\t\t \n\tNULL,\t\t\t\t \n\tNULL,\t\t\t\t \n\tNULL,\t\t\t\t \n\tNULL,\t\t\t\t \n\tNULL,\t\t\t\t \n};\n\nstatic const char *aer_agent_string[] = {\n\t\"Receiver ID\",\n\t\"Requester ID\",\n\t\"Completer ID\",\n\t\"Transmitter ID\"\n};\n\n#define aer_stats_dev_attr(name, stats_array, strings_array,\t\t\\\n\t\t\t   total_string, total_field)\t\t\t\\\n\tstatic ssize_t\t\t\t\t\t\t\t\\\n\tname##_show(struct device *dev, struct device_attribute *attr,\t\\\n\t\t     char *buf)\t\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tunsigned int i;\t\t\t\t\t\t\t\\\n\tstruct pci_dev *pdev = to_pci_dev(dev);\t\t\t\t\\\n\tu64 *stats = pdev->aer_stats->stats_array;\t\t\t\\\n\tsize_t len = 0;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tfor (i = 0; i < ARRAY_SIZE(pdev->aer_stats->stats_array); i++) {\\\n\t\tif (strings_array[i])\t\t\t\t\t\\\n\t\t\tlen += sysfs_emit_at(buf, len, \"%s %llu\\n\",\t\\\n\t\t\t\t\t     strings_array[i],\t\t\\\n\t\t\t\t\t     stats[i]);\t\t\t\\\n\t\telse if (stats[i])\t\t\t\t\t\\\n\t\t\tlen += sysfs_emit_at(buf, len,\t\t\t\\\n\t\t\t\t\t     #stats_array \"_bit[%d] %llu\\n\",\\\n\t\t\t\t\t     i, stats[i]);\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tlen += sysfs_emit_at(buf, len, \"TOTAL_%s %llu\\n\", total_string,\t\\\n\t\t\t     pdev->aer_stats->total_field);\t\t\\\n\treturn len;\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic DEVICE_ATTR_RO(name)\n\naer_stats_dev_attr(aer_dev_correctable, dev_cor_errs,\n\t\t   aer_correctable_error_string, \"ERR_COR\",\n\t\t   dev_total_cor_errs);\naer_stats_dev_attr(aer_dev_fatal, dev_fatal_errs,\n\t\t   aer_uncorrectable_error_string, \"ERR_FATAL\",\n\t\t   dev_total_fatal_errs);\naer_stats_dev_attr(aer_dev_nonfatal, dev_nonfatal_errs,\n\t\t   aer_uncorrectable_error_string, \"ERR_NONFATAL\",\n\t\t   dev_total_nonfatal_errs);\n\n#define aer_stats_rootport_attr(name, field)\t\t\t\t\\\n\tstatic ssize_t\t\t\t\t\t\t\t\\\n\tname##_show(struct device *dev, struct device_attribute *attr,\t\\\n\t\t     char *buf)\t\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct pci_dev *pdev = to_pci_dev(dev);\t\t\t\t\\\n\treturn sysfs_emit(buf, \"%llu\\n\", pdev->aer_stats->field);\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic DEVICE_ATTR_RO(name)\n\naer_stats_rootport_attr(aer_rootport_total_err_cor,\n\t\t\t rootport_total_cor_errs);\naer_stats_rootport_attr(aer_rootport_total_err_fatal,\n\t\t\t rootport_total_fatal_errs);\naer_stats_rootport_attr(aer_rootport_total_err_nonfatal,\n\t\t\t rootport_total_nonfatal_errs);\n\nstatic struct attribute *aer_stats_attrs[] __ro_after_init = {\n\t&dev_attr_aer_dev_correctable.attr,\n\t&dev_attr_aer_dev_fatal.attr,\n\t&dev_attr_aer_dev_nonfatal.attr,\n\t&dev_attr_aer_rootport_total_err_cor.attr,\n\t&dev_attr_aer_rootport_total_err_fatal.attr,\n\t&dev_attr_aer_rootport_total_err_nonfatal.attr,\n\tNULL\n};\n\nstatic umode_t aer_stats_attrs_are_visible(struct kobject *kobj,\n\t\t\t\t\t   struct attribute *a, int n)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\n\tif (!pdev->aer_stats)\n\t\treturn 0;\n\n\tif ((a == &dev_attr_aer_rootport_total_err_cor.attr ||\n\t     a == &dev_attr_aer_rootport_total_err_fatal.attr ||\n\t     a == &dev_attr_aer_rootport_total_err_nonfatal.attr) &&\n\t    ((pci_pcie_type(pdev) != PCI_EXP_TYPE_ROOT_PORT) &&\n\t     (pci_pcie_type(pdev) != PCI_EXP_TYPE_RC_EC)))\n\t\treturn 0;\n\n\treturn a->mode;\n}\n\nconst struct attribute_group aer_stats_attr_group = {\n\t.attrs  = aer_stats_attrs,\n\t.is_visible = aer_stats_attrs_are_visible,\n};\n\nstatic void pci_dev_aer_stats_incr(struct pci_dev *pdev,\n\t\t\t\t   struct aer_err_info *info)\n{\n\tunsigned long status = info->status & ~info->mask;\n\tint i, max = -1;\n\tu64 *counter = NULL;\n\tstruct aer_stats *aer_stats = pdev->aer_stats;\n\n\tif (!aer_stats)\n\t\treturn;\n\n\tswitch (info->severity) {\n\tcase AER_CORRECTABLE:\n\t\taer_stats->dev_total_cor_errs++;\n\t\tcounter = &aer_stats->dev_cor_errs[0];\n\t\tmax = AER_MAX_TYPEOF_COR_ERRS;\n\t\tbreak;\n\tcase AER_NONFATAL:\n\t\taer_stats->dev_total_nonfatal_errs++;\n\t\tcounter = &aer_stats->dev_nonfatal_errs[0];\n\t\tmax = AER_MAX_TYPEOF_UNCOR_ERRS;\n\t\tbreak;\n\tcase AER_FATAL:\n\t\taer_stats->dev_total_fatal_errs++;\n\t\tcounter = &aer_stats->dev_fatal_errs[0];\n\t\tmax = AER_MAX_TYPEOF_UNCOR_ERRS;\n\t\tbreak;\n\t}\n\n\tfor_each_set_bit(i, &status, max)\n\t\tcounter[i]++;\n}\n\nstatic void pci_rootport_aer_stats_incr(struct pci_dev *pdev,\n\t\t\t\t struct aer_err_source *e_src)\n{\n\tstruct aer_stats *aer_stats = pdev->aer_stats;\n\n\tif (!aer_stats)\n\t\treturn;\n\n\tif (e_src->status & PCI_ERR_ROOT_COR_RCV)\n\t\taer_stats->rootport_total_cor_errs++;\n\n\tif (e_src->status & PCI_ERR_ROOT_UNCOR_RCV) {\n\t\tif (e_src->status & PCI_ERR_ROOT_FATAL_RCV)\n\t\t\taer_stats->rootport_total_fatal_errs++;\n\t\telse\n\t\t\taer_stats->rootport_total_nonfatal_errs++;\n\t}\n}\n\nstatic void __print_tlp_header(struct pci_dev *dev,\n\t\t\t       struct aer_header_log_regs *t)\n{\n\tpci_err(dev, \"  TLP Header: %08x %08x %08x %08x\\n\",\n\t\tt->dw0, t->dw1, t->dw2, t->dw3);\n}\n\nstatic void __aer_print_error(struct pci_dev *dev,\n\t\t\t      struct aer_err_info *info)\n{\n\tconst char **strings;\n\tunsigned long status = info->status & ~info->mask;\n\tconst char *level, *errmsg;\n\tint i;\n\n\tif (info->severity == AER_CORRECTABLE) {\n\t\tstrings = aer_correctable_error_string;\n\t\tlevel = KERN_WARNING;\n\t} else {\n\t\tstrings = aer_uncorrectable_error_string;\n\t\tlevel = KERN_ERR;\n\t}\n\n\tfor_each_set_bit(i, &status, 32) {\n\t\terrmsg = strings[i];\n\t\tif (!errmsg)\n\t\t\terrmsg = \"Unknown Error Bit\";\n\n\t\tpci_printk(level, dev, \"   [%2d] %-22s%s\\n\", i, errmsg,\n\t\t\t\tinfo->first_error == i ? \" (First)\" : \"\");\n\t}\n\tpci_dev_aer_stats_incr(dev, info);\n}\n\nvoid aer_print_error(struct pci_dev *dev, struct aer_err_info *info)\n{\n\tint layer, agent;\n\tint id = pci_dev_id(dev);\n\tconst char *level;\n\n\tif (!info->status) {\n\t\tpci_err(dev, \"PCIe Bus Error: severity=%s, type=Inaccessible, (Unregistered Agent ID)\\n\",\n\t\t\taer_error_severity_string[info->severity]);\n\t\tgoto out;\n\t}\n\n\tlayer = AER_GET_LAYER_ERROR(info->severity, info->status);\n\tagent = AER_GET_AGENT(info->severity, info->status);\n\n\tlevel = (info->severity == AER_CORRECTABLE) ? KERN_WARNING : KERN_ERR;\n\n\tpci_printk(level, dev, \"PCIe Bus Error: severity=%s, type=%s, (%s)\\n\",\n\t\t   aer_error_severity_string[info->severity],\n\t\t   aer_error_layer[layer], aer_agent_string[agent]);\n\n\tpci_printk(level, dev, \"  device [%04x:%04x] error status/mask=%08x/%08x\\n\",\n\t\t   dev->vendor, dev->device, info->status, info->mask);\n\n\t__aer_print_error(dev, info);\n\n\tif (info->tlp_header_valid)\n\t\t__print_tlp_header(dev, &info->tlp);\n\nout:\n\tif (info->id && info->error_dev_num > 1 && info->id == id)\n\t\tpci_err(dev, \"  Error of this Agent is reported first\\n\");\n\n\ttrace_aer_event(dev_name(&dev->dev), (info->status & ~info->mask),\n\t\t\tinfo->severity, info->tlp_header_valid, &info->tlp);\n}\n\nstatic void aer_print_port_info(struct pci_dev *dev, struct aer_err_info *info)\n{\n\tu8 bus = info->id >> 8;\n\tu8 devfn = info->id & 0xff;\n\n\tpci_info(dev, \"%s%s error received: %04x:%02x:%02x.%d\\n\",\n\t\t info->multi_error_valid ? \"Multiple \" : \"\",\n\t\t aer_error_severity_string[info->severity],\n\t\t pci_domain_nr(dev->bus), bus, PCI_SLOT(devfn),\n\t\t PCI_FUNC(devfn));\n}\n\n#ifdef CONFIG_ACPI_APEI_PCIEAER\nint cper_severity_to_aer(int cper_severity)\n{\n\tswitch (cper_severity) {\n\tcase CPER_SEV_RECOVERABLE:\n\t\treturn AER_NONFATAL;\n\tcase CPER_SEV_FATAL:\n\t\treturn AER_FATAL;\n\tdefault:\n\t\treturn AER_CORRECTABLE;\n\t}\n}\nEXPORT_SYMBOL_GPL(cper_severity_to_aer);\n\nvoid cper_print_aer(struct pci_dev *dev, int aer_severity,\n\t\t    struct aer_capability_regs *aer)\n{\n\tint layer, agent, tlp_header_valid = 0;\n\tu32 status, mask;\n\tstruct aer_err_info info;\n\n\tif (aer_severity == AER_CORRECTABLE) {\n\t\tstatus = aer->cor_status;\n\t\tmask = aer->cor_mask;\n\t} else {\n\t\tstatus = aer->uncor_status;\n\t\tmask = aer->uncor_mask;\n\t\ttlp_header_valid = status & AER_LOG_TLP_MASKS;\n\t}\n\n\tlayer = AER_GET_LAYER_ERROR(aer_severity, status);\n\tagent = AER_GET_AGENT(aer_severity, status);\n\n\tmemset(&info, 0, sizeof(info));\n\tinfo.severity = aer_severity;\n\tinfo.status = status;\n\tinfo.mask = mask;\n\tinfo.first_error = PCI_ERR_CAP_FEP(aer->cap_control);\n\n\tpci_err(dev, \"aer_status: 0x%08x, aer_mask: 0x%08x\\n\", status, mask);\n\t__aer_print_error(dev, &info);\n\tpci_err(dev, \"aer_layer=%s, aer_agent=%s\\n\",\n\t\taer_error_layer[layer], aer_agent_string[agent]);\n\n\tif (aer_severity != AER_CORRECTABLE)\n\t\tpci_err(dev, \"aer_uncor_severity: 0x%08x\\n\",\n\t\t\taer->uncor_severity);\n\n\tif (tlp_header_valid)\n\t\t__print_tlp_header(dev, &aer->header_log);\n\n\ttrace_aer_event(dev_name(&dev->dev), (status & ~mask),\n\t\t\taer_severity, tlp_header_valid, &aer->header_log);\n}\n#endif\n\n \nstatic int add_error_device(struct aer_err_info *e_info, struct pci_dev *dev)\n{\n\tif (e_info->error_dev_num < AER_MAX_MULTI_ERR_DEVICES) {\n\t\te_info->dev[e_info->error_dev_num] = pci_dev_get(dev);\n\t\te_info->error_dev_num++;\n\t\treturn 0;\n\t}\n\treturn -ENOSPC;\n}\n\n \nstatic bool is_error_source(struct pci_dev *dev, struct aer_err_info *e_info)\n{\n\tint aer = dev->aer_cap;\n\tu32 status, mask;\n\tu16 reg16;\n\n\t \n\tif ((PCI_BUS_NUM(e_info->id) != 0) &&\n\t    !(dev->bus->bus_flags & PCI_BUS_FLAGS_NO_AERSID)) {\n\t\t \n\t\tif (e_info->id == pci_dev_id(dev))\n\t\t\treturn true;\n\n\t\t \n\t\tif (!e_info->multi_error_valid)\n\t\t\treturn false;\n\t}\n\n\t \n\tif (atomic_read(&dev->enable_cnt) == 0)\n\t\treturn false;\n\n\t \n\tpcie_capability_read_word(dev, PCI_EXP_DEVCTL, &reg16);\n\tif (!(reg16 & PCI_EXP_AER_FLAGS))\n\t\treturn false;\n\n\tif (!aer)\n\t\treturn false;\n\n\t \n\tif (e_info->severity == AER_CORRECTABLE) {\n\t\tpci_read_config_dword(dev, aer + PCI_ERR_COR_STATUS, &status);\n\t\tpci_read_config_dword(dev, aer + PCI_ERR_COR_MASK, &mask);\n\t} else {\n\t\tpci_read_config_dword(dev, aer + PCI_ERR_UNCOR_STATUS, &status);\n\t\tpci_read_config_dword(dev, aer + PCI_ERR_UNCOR_MASK, &mask);\n\t}\n\tif (status & ~mask)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic int find_device_iter(struct pci_dev *dev, void *data)\n{\n\tstruct aer_err_info *e_info = (struct aer_err_info *)data;\n\n\tif (is_error_source(dev, e_info)) {\n\t\t \n\t\tif (add_error_device(e_info, dev)) {\n\t\t\t \n\t\t\t \n\t\t\treturn 1;\n\t\t}\n\n\t\t \n\t\tif (!e_info->multi_error_valid)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n \nstatic bool find_source_device(struct pci_dev *parent,\n\t\tstruct aer_err_info *e_info)\n{\n\tstruct pci_dev *dev = parent;\n\tint result;\n\n\t \n\te_info->error_dev_num = 0;\n\n\t \n\tresult = find_device_iter(dev, e_info);\n\tif (result)\n\t\treturn true;\n\n\tif (pci_pcie_type(parent) == PCI_EXP_TYPE_RC_EC)\n\t\tpcie_walk_rcec(parent, find_device_iter, e_info);\n\telse\n\t\tpci_walk_bus(parent->subordinate, find_device_iter, e_info);\n\n\tif (!e_info->error_dev_num) {\n\t\tpci_info(parent, \"can't find device of ID%04x\\n\", e_info->id);\n\t\treturn false;\n\t}\n\treturn true;\n}\n\n \nstatic void handle_error_source(struct pci_dev *dev, struct aer_err_info *info)\n{\n\tint aer = dev->aer_cap;\n\n\tif (info->severity == AER_CORRECTABLE) {\n\t\t \n\t\tif (aer)\n\t\t\tpci_write_config_dword(dev, aer + PCI_ERR_COR_STATUS,\n\t\t\t\t\tinfo->status);\n\t\tif (pcie_aer_is_native(dev)) {\n\t\t\tstruct pci_driver *pdrv = dev->driver;\n\n\t\t\tif (pdrv && pdrv->err_handler &&\n\t\t\t    pdrv->err_handler->cor_error_detected)\n\t\t\t\tpdrv->err_handler->cor_error_detected(dev);\n\t\t\tpcie_clear_device_status(dev);\n\t\t}\n\t} else if (info->severity == AER_NONFATAL)\n\t\tpcie_do_recovery(dev, pci_channel_io_normal, aer_root_reset);\n\telse if (info->severity == AER_FATAL)\n\t\tpcie_do_recovery(dev, pci_channel_io_frozen, aer_root_reset);\n\tpci_dev_put(dev);\n}\n\n#ifdef CONFIG_ACPI_APEI_PCIEAER\n\n#define AER_RECOVER_RING_SIZE\t\t16\n\nstruct aer_recover_entry {\n\tu8\tbus;\n\tu8\tdevfn;\n\tu16\tdomain;\n\tint\tseverity;\n\tstruct aer_capability_regs *regs;\n};\n\nstatic DEFINE_KFIFO(aer_recover_ring, struct aer_recover_entry,\n\t\t    AER_RECOVER_RING_SIZE);\n\nstatic void aer_recover_work_func(struct work_struct *work)\n{\n\tstruct aer_recover_entry entry;\n\tstruct pci_dev *pdev;\n\n\twhile (kfifo_get(&aer_recover_ring, &entry)) {\n\t\tpdev = pci_get_domain_bus_and_slot(entry.domain, entry.bus,\n\t\t\t\t\t\t   entry.devfn);\n\t\tif (!pdev) {\n\t\t\tpr_err(\"no pci_dev for %04x:%02x:%02x.%x\\n\",\n\t\t\t       entry.domain, entry.bus,\n\t\t\t       PCI_SLOT(entry.devfn), PCI_FUNC(entry.devfn));\n\t\t\tcontinue;\n\t\t}\n\t\tcper_print_aer(pdev, entry.severity, entry.regs);\n\t\t \n\t\tghes_estatus_pool_region_free((unsigned long)entry.regs,\n\t\t\t\t\t      sizeof(struct aer_capability_regs));\n\n\t\tif (entry.severity == AER_NONFATAL)\n\t\t\tpcie_do_recovery(pdev, pci_channel_io_normal,\n\t\t\t\t\t aer_root_reset);\n\t\telse if (entry.severity == AER_FATAL)\n\t\t\tpcie_do_recovery(pdev, pci_channel_io_frozen,\n\t\t\t\t\t aer_root_reset);\n\t\tpci_dev_put(pdev);\n\t}\n}\n\n \nstatic DEFINE_SPINLOCK(aer_recover_ring_lock);\nstatic DECLARE_WORK(aer_recover_work, aer_recover_work_func);\n\nvoid aer_recover_queue(int domain, unsigned int bus, unsigned int devfn,\n\t\t       int severity, struct aer_capability_regs *aer_regs)\n{\n\tstruct aer_recover_entry entry = {\n\t\t.bus\t\t= bus,\n\t\t.devfn\t\t= devfn,\n\t\t.domain\t\t= domain,\n\t\t.severity\t= severity,\n\t\t.regs\t\t= aer_regs,\n\t};\n\n\tif (kfifo_in_spinlocked(&aer_recover_ring, &entry, 1,\n\t\t\t\t &aer_recover_ring_lock))\n\t\tschedule_work(&aer_recover_work);\n\telse\n\t\tpr_err(\"buffer overflow in recovery for %04x:%02x:%02x.%x\\n\",\n\t\t       domain, bus, PCI_SLOT(devfn), PCI_FUNC(devfn));\n}\nEXPORT_SYMBOL_GPL(aer_recover_queue);\n#endif\n\n \nint aer_get_device_error_info(struct pci_dev *dev, struct aer_err_info *info)\n{\n\tint type = pci_pcie_type(dev);\n\tint aer = dev->aer_cap;\n\tint temp;\n\n\t \n\tinfo->status = 0;\n\tinfo->tlp_header_valid = 0;\n\n\t \n\tif (!aer)\n\t\treturn 0;\n\n\tif (info->severity == AER_CORRECTABLE) {\n\t\tpci_read_config_dword(dev, aer + PCI_ERR_COR_STATUS,\n\t\t\t&info->status);\n\t\tpci_read_config_dword(dev, aer + PCI_ERR_COR_MASK,\n\t\t\t&info->mask);\n\t\tif (!(info->status & ~info->mask))\n\t\t\treturn 0;\n\t} else if (type == PCI_EXP_TYPE_ROOT_PORT ||\n\t\t   type == PCI_EXP_TYPE_RC_EC ||\n\t\t   type == PCI_EXP_TYPE_DOWNSTREAM ||\n\t\t   info->severity == AER_NONFATAL) {\n\n\t\t \n\t\tpci_read_config_dword(dev, aer + PCI_ERR_UNCOR_STATUS,\n\t\t\t&info->status);\n\t\tpci_read_config_dword(dev, aer + PCI_ERR_UNCOR_MASK,\n\t\t\t&info->mask);\n\t\tif (!(info->status & ~info->mask))\n\t\t\treturn 0;\n\n\t\t \n\t\tpci_read_config_dword(dev, aer + PCI_ERR_CAP, &temp);\n\t\tinfo->first_error = PCI_ERR_CAP_FEP(temp);\n\n\t\tif (info->status & AER_LOG_TLP_MASKS) {\n\t\t\tinfo->tlp_header_valid = 1;\n\t\t\tpci_read_config_dword(dev,\n\t\t\t\taer + PCI_ERR_HEADER_LOG, &info->tlp.dw0);\n\t\t\tpci_read_config_dword(dev,\n\t\t\t\taer + PCI_ERR_HEADER_LOG + 4, &info->tlp.dw1);\n\t\t\tpci_read_config_dword(dev,\n\t\t\t\taer + PCI_ERR_HEADER_LOG + 8, &info->tlp.dw2);\n\t\t\tpci_read_config_dword(dev,\n\t\t\t\taer + PCI_ERR_HEADER_LOG + 12, &info->tlp.dw3);\n\t\t}\n\t}\n\n\treturn 1;\n}\n\nstatic inline void aer_process_err_devices(struct aer_err_info *e_info)\n{\n\tint i;\n\n\t \n\tfor (i = 0; i < e_info->error_dev_num && e_info->dev[i]; i++) {\n\t\tif (aer_get_device_error_info(e_info->dev[i], e_info))\n\t\t\taer_print_error(e_info->dev[i], e_info);\n\t}\n\tfor (i = 0; i < e_info->error_dev_num && e_info->dev[i]; i++) {\n\t\tif (aer_get_device_error_info(e_info->dev[i], e_info))\n\t\t\thandle_error_source(e_info->dev[i], e_info);\n\t}\n}\n\n \nstatic void aer_isr_one_error(struct aer_rpc *rpc,\n\t\tstruct aer_err_source *e_src)\n{\n\tstruct pci_dev *pdev = rpc->rpd;\n\tstruct aer_err_info e_info;\n\n\tpci_rootport_aer_stats_incr(pdev, e_src);\n\n\t \n\tif (e_src->status & PCI_ERR_ROOT_COR_RCV) {\n\t\te_info.id = ERR_COR_ID(e_src->id);\n\t\te_info.severity = AER_CORRECTABLE;\n\n\t\tif (e_src->status & PCI_ERR_ROOT_MULTI_COR_RCV)\n\t\t\te_info.multi_error_valid = 1;\n\t\telse\n\t\t\te_info.multi_error_valid = 0;\n\t\taer_print_port_info(pdev, &e_info);\n\n\t\tif (find_source_device(pdev, &e_info))\n\t\t\taer_process_err_devices(&e_info);\n\t}\n\n\tif (e_src->status & PCI_ERR_ROOT_UNCOR_RCV) {\n\t\te_info.id = ERR_UNCOR_ID(e_src->id);\n\n\t\tif (e_src->status & PCI_ERR_ROOT_FATAL_RCV)\n\t\t\te_info.severity = AER_FATAL;\n\t\telse\n\t\t\te_info.severity = AER_NONFATAL;\n\n\t\tif (e_src->status & PCI_ERR_ROOT_MULTI_UNCOR_RCV)\n\t\t\te_info.multi_error_valid = 1;\n\t\telse\n\t\t\te_info.multi_error_valid = 0;\n\n\t\taer_print_port_info(pdev, &e_info);\n\n\t\tif (find_source_device(pdev, &e_info))\n\t\t\taer_process_err_devices(&e_info);\n\t}\n}\n\n \nstatic irqreturn_t aer_isr(int irq, void *context)\n{\n\tstruct pcie_device *dev = (struct pcie_device *)context;\n\tstruct aer_rpc *rpc = get_service_data(dev);\n\tstruct aer_err_source e_src;\n\n\tif (kfifo_is_empty(&rpc->aer_fifo))\n\t\treturn IRQ_NONE;\n\n\twhile (kfifo_get(&rpc->aer_fifo, &e_src))\n\t\taer_isr_one_error(rpc, &e_src);\n\treturn IRQ_HANDLED;\n}\n\n \nstatic irqreturn_t aer_irq(int irq, void *context)\n{\n\tstruct pcie_device *pdev = (struct pcie_device *)context;\n\tstruct aer_rpc *rpc = get_service_data(pdev);\n\tstruct pci_dev *rp = rpc->rpd;\n\tint aer = rp->aer_cap;\n\tstruct aer_err_source e_src = {};\n\n\tpci_read_config_dword(rp, aer + PCI_ERR_ROOT_STATUS, &e_src.status);\n\tif (!(e_src.status & AER_ERR_STATUS_MASK))\n\t\treturn IRQ_NONE;\n\n\tpci_read_config_dword(rp, aer + PCI_ERR_ROOT_ERR_SRC, &e_src.id);\n\tpci_write_config_dword(rp, aer + PCI_ERR_ROOT_STATUS, e_src.status);\n\n\tif (!kfifo_put(&rpc->aer_fifo, e_src))\n\t\treturn IRQ_HANDLED;\n\n\treturn IRQ_WAKE_THREAD;\n}\n\n \nstatic void aer_enable_rootport(struct aer_rpc *rpc)\n{\n\tstruct pci_dev *pdev = rpc->rpd;\n\tint aer = pdev->aer_cap;\n\tu16 reg16;\n\tu32 reg32;\n\n\t \n\tpcie_capability_read_word(pdev, PCI_EXP_DEVSTA, &reg16);\n\tpcie_capability_write_word(pdev, PCI_EXP_DEVSTA, reg16);\n\n\t \n\tpcie_capability_clear_word(pdev, PCI_EXP_RTCTL,\n\t\t\t\t   SYSTEM_ERROR_INTR_ON_MESG_MASK);\n\n\t \n\tpci_read_config_dword(pdev, aer + PCI_ERR_ROOT_STATUS, &reg32);\n\tpci_write_config_dword(pdev, aer + PCI_ERR_ROOT_STATUS, reg32);\n\tpci_read_config_dword(pdev, aer + PCI_ERR_COR_STATUS, &reg32);\n\tpci_write_config_dword(pdev, aer + PCI_ERR_COR_STATUS, reg32);\n\tpci_read_config_dword(pdev, aer + PCI_ERR_UNCOR_STATUS, &reg32);\n\tpci_write_config_dword(pdev, aer + PCI_ERR_UNCOR_STATUS, reg32);\n\n\t \n\tpci_read_config_dword(pdev, aer + PCI_ERR_ROOT_COMMAND, &reg32);\n\treg32 |= ROOT_PORT_INTR_ON_MESG_MASK;\n\tpci_write_config_dword(pdev, aer + PCI_ERR_ROOT_COMMAND, reg32);\n}\n\n \nstatic void aer_disable_rootport(struct aer_rpc *rpc)\n{\n\tstruct pci_dev *pdev = rpc->rpd;\n\tint aer = pdev->aer_cap;\n\tu32 reg32;\n\n\t \n\tpci_read_config_dword(pdev, aer + PCI_ERR_ROOT_COMMAND, &reg32);\n\treg32 &= ~ROOT_PORT_INTR_ON_MESG_MASK;\n\tpci_write_config_dword(pdev, aer + PCI_ERR_ROOT_COMMAND, reg32);\n\n\t \n\tpci_read_config_dword(pdev, aer + PCI_ERR_ROOT_STATUS, &reg32);\n\tpci_write_config_dword(pdev, aer + PCI_ERR_ROOT_STATUS, reg32);\n}\n\n \nstatic void aer_remove(struct pcie_device *dev)\n{\n\tstruct aer_rpc *rpc = get_service_data(dev);\n\n\taer_disable_rootport(rpc);\n}\n\n \nstatic int aer_probe(struct pcie_device *dev)\n{\n\tint status;\n\tstruct aer_rpc *rpc;\n\tstruct device *device = &dev->device;\n\tstruct pci_dev *port = dev->port;\n\n\tBUILD_BUG_ON(ARRAY_SIZE(aer_correctable_error_string) <\n\t\t     AER_MAX_TYPEOF_COR_ERRS);\n\tBUILD_BUG_ON(ARRAY_SIZE(aer_uncorrectable_error_string) <\n\t\t     AER_MAX_TYPEOF_UNCOR_ERRS);\n\n\t \n\tif ((pci_pcie_type(port) != PCI_EXP_TYPE_RC_EC) &&\n\t    (pci_pcie_type(port) != PCI_EXP_TYPE_ROOT_PORT))\n\t\treturn -ENODEV;\n\n\trpc = devm_kzalloc(device, sizeof(struct aer_rpc), GFP_KERNEL);\n\tif (!rpc)\n\t\treturn -ENOMEM;\n\n\trpc->rpd = port;\n\tINIT_KFIFO(rpc->aer_fifo);\n\tset_service_data(dev, rpc);\n\n\tstatus = devm_request_threaded_irq(device, dev->irq, aer_irq, aer_isr,\n\t\t\t\t\t   IRQF_SHARED, \"aerdrv\", dev);\n\tif (status) {\n\t\tpci_err(port, \"request AER IRQ %d failed\\n\", dev->irq);\n\t\treturn status;\n\t}\n\n\taer_enable_rootport(rpc);\n\tpci_info(port, \"enabled with IRQ %d\\n\", dev->irq);\n\treturn 0;\n}\n\n \nstatic pci_ers_result_t aer_root_reset(struct pci_dev *dev)\n{\n\tint type = pci_pcie_type(dev);\n\tstruct pci_dev *root;\n\tint aer;\n\tstruct pci_host_bridge *host = pci_find_host_bridge(dev->bus);\n\tu32 reg32;\n\tint rc;\n\n\t \n\tif (type == PCI_EXP_TYPE_RC_END)\n\t\troot = dev->rcec;\n\telse\n\t\troot = pcie_find_root_port(dev);\n\n\t \n\taer = root ? root->aer_cap : 0;\n\n\tif ((host->native_aer || pcie_ports_native) && aer) {\n\t\t \n\t\tpci_read_config_dword(root, aer + PCI_ERR_ROOT_COMMAND, &reg32);\n\t\treg32 &= ~ROOT_PORT_INTR_ON_MESG_MASK;\n\t\tpci_write_config_dword(root, aer + PCI_ERR_ROOT_COMMAND, reg32);\n\t}\n\n\tif (type == PCI_EXP_TYPE_RC_EC || type == PCI_EXP_TYPE_RC_END) {\n\t\trc = pcie_reset_flr(dev, PCI_RESET_DO_RESET);\n\t\tif (!rc)\n\t\t\tpci_info(dev, \"has been reset\\n\");\n\t\telse\n\t\t\tpci_info(dev, \"not reset (no FLR support: %d)\\n\", rc);\n\t} else {\n\t\trc = pci_bus_error_reset(dev);\n\t\tpci_info(dev, \"%s Port link has been reset (%d)\\n\",\n\t\t\tpci_is_root_bus(dev->bus) ? \"Root\" : \"Downstream\", rc);\n\t}\n\n\tif ((host->native_aer || pcie_ports_native) && aer) {\n\t\t \n\t\tpci_read_config_dword(root, aer + PCI_ERR_ROOT_STATUS, &reg32);\n\t\tpci_write_config_dword(root, aer + PCI_ERR_ROOT_STATUS, reg32);\n\n\t\t \n\t\tpci_read_config_dword(root, aer + PCI_ERR_ROOT_COMMAND, &reg32);\n\t\treg32 |= ROOT_PORT_INTR_ON_MESG_MASK;\n\t\tpci_write_config_dword(root, aer + PCI_ERR_ROOT_COMMAND, reg32);\n\t}\n\n\treturn rc ? PCI_ERS_RESULT_DISCONNECT : PCI_ERS_RESULT_RECOVERED;\n}\n\nstatic struct pcie_port_service_driver aerdriver = {\n\t.name\t\t= \"aer\",\n\t.port_type\t= PCIE_ANY_PORT,\n\t.service\t= PCIE_PORT_SERVICE_AER,\n\n\t.probe\t\t= aer_probe,\n\t.remove\t\t= aer_remove,\n};\n\n \nint __init pcie_aer_init(void)\n{\n\tif (!pci_aer_available())\n\t\treturn -ENXIO;\n\treturn pcie_port_service_register(&aerdriver);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}