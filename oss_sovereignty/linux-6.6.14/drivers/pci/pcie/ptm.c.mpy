{
  "module_name": "ptm.c",
  "hash_id": "05cd007b354ee057783498558adaa4cb37486473d2a728b623f3c2cc1b0f4fef",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/pcie/ptm.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/pci.h>\n#include \"../pci.h\"\n\n \nstatic struct pci_dev *pci_upstream_ptm(struct pci_dev *dev)\n{\n\tstruct pci_dev *ups = pci_upstream_bridge(dev);\n\n\t \n\tif (ups && pci_pcie_type(ups) == PCI_EXP_TYPE_DOWNSTREAM)\n\t\tups = pci_upstream_bridge(ups);\n\n\tif (ups && ups->ptm_cap)\n\t\treturn ups;\n\n\treturn NULL;\n}\n\n \nvoid pci_ptm_init(struct pci_dev *dev)\n{\n\tu16 ptm;\n\tu32 cap;\n\tstruct pci_dev *ups;\n\n\tif (!pci_is_pcie(dev))\n\t\treturn;\n\n\tptm = pci_find_ext_capability(dev, PCI_EXT_CAP_ID_PTM);\n\tif (!ptm)\n\t\treturn;\n\n\tdev->ptm_cap = ptm;\n\tpci_add_ext_cap_save_buffer(dev, PCI_EXT_CAP_ID_PTM, sizeof(u32));\n\n\tpci_read_config_dword(dev, ptm + PCI_PTM_CAP, &cap);\n\tdev->ptm_granularity = (cap & PCI_PTM_GRANULARITY_MASK) >> 8;\n\n\t \n\tups = pci_upstream_ptm(dev);\n\tif (ups) {\n\t\tif (ups->ptm_granularity == 0)\n\t\t\tdev->ptm_granularity = 0;\n\t\telse if (ups->ptm_granularity > dev->ptm_granularity)\n\t\t\tdev->ptm_granularity = ups->ptm_granularity;\n\t} else if (cap & PCI_PTM_CAP_ROOT) {\n\t\tdev->ptm_root = 1;\n\t} else if (pci_pcie_type(dev) == PCI_EXP_TYPE_RC_END) {\n\n\t\t \n\t\tdev->ptm_granularity = 0;\n\t}\n\n\tif (pci_pcie_type(dev) == PCI_EXP_TYPE_ROOT_PORT ||\n\t    pci_pcie_type(dev) == PCI_EXP_TYPE_UPSTREAM)\n\t\tpci_enable_ptm(dev, NULL);\n}\n\nvoid pci_save_ptm_state(struct pci_dev *dev)\n{\n\tu16 ptm = dev->ptm_cap;\n\tstruct pci_cap_saved_state *save_state;\n\tu32 *cap;\n\n\tif (!ptm)\n\t\treturn;\n\n\tsave_state = pci_find_saved_ext_cap(dev, PCI_EXT_CAP_ID_PTM);\n\tif (!save_state)\n\t\treturn;\n\n\tcap = (u32 *)&save_state->cap.data[0];\n\tpci_read_config_dword(dev, ptm + PCI_PTM_CTRL, cap);\n}\n\nvoid pci_restore_ptm_state(struct pci_dev *dev)\n{\n\tu16 ptm = dev->ptm_cap;\n\tstruct pci_cap_saved_state *save_state;\n\tu32 *cap;\n\n\tif (!ptm)\n\t\treturn;\n\n\tsave_state = pci_find_saved_ext_cap(dev, PCI_EXT_CAP_ID_PTM);\n\tif (!save_state)\n\t\treturn;\n\n\tcap = (u32 *)&save_state->cap.data[0];\n\tpci_write_config_dword(dev, ptm + PCI_PTM_CTRL, *cap);\n}\n\n \nstatic int __pci_enable_ptm(struct pci_dev *dev)\n{\n\tu16 ptm = dev->ptm_cap;\n\tstruct pci_dev *ups;\n\tu32 ctrl;\n\n\tif (!ptm)\n\t\treturn -EINVAL;\n\n\t \n\tif (!dev->ptm_root) {\n\t\tups = pci_upstream_ptm(dev);\n\t\tif (!ups || !ups->ptm_enabled)\n\t\t\treturn -EINVAL;\n\t}\n\n\tpci_read_config_dword(dev, ptm + PCI_PTM_CTRL, &ctrl);\n\n\tctrl |= PCI_PTM_CTRL_ENABLE;\n\tctrl &= ~PCI_PTM_GRANULARITY_MASK;\n\tctrl |= dev->ptm_granularity << 8;\n\tif (dev->ptm_root)\n\t\tctrl |= PCI_PTM_CTRL_ROOT;\n\n\tpci_write_config_dword(dev, ptm + PCI_PTM_CTRL, ctrl);\n\treturn 0;\n}\n\n \nint pci_enable_ptm(struct pci_dev *dev, u8 *granularity)\n{\n\tint rc;\n\tchar clock_desc[8];\n\n\trc = __pci_enable_ptm(dev);\n\tif (rc)\n\t\treturn rc;\n\n\tdev->ptm_enabled = 1;\n\n\tif (granularity)\n\t\t*granularity = dev->ptm_granularity;\n\n\tswitch (dev->ptm_granularity) {\n\tcase 0:\n\t\tsnprintf(clock_desc, sizeof(clock_desc), \"unknown\");\n\t\tbreak;\n\tcase 255:\n\t\tsnprintf(clock_desc, sizeof(clock_desc), \">254ns\");\n\t\tbreak;\n\tdefault:\n\t\tsnprintf(clock_desc, sizeof(clock_desc), \"%uns\",\n\t\t\t dev->ptm_granularity);\n\t\tbreak;\n\t}\n\tpci_info(dev, \"PTM enabled%s, %s granularity\\n\",\n\t\t dev->ptm_root ? \" (root)\" : \"\", clock_desc);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(pci_enable_ptm);\n\nstatic void __pci_disable_ptm(struct pci_dev *dev)\n{\n\tu16 ptm = dev->ptm_cap;\n\tu32 ctrl;\n\n\tif (!ptm)\n\t\treturn;\n\n\tpci_read_config_dword(dev, ptm + PCI_PTM_CTRL, &ctrl);\n\tctrl &= ~(PCI_PTM_CTRL_ENABLE | PCI_PTM_CTRL_ROOT);\n\tpci_write_config_dword(dev, ptm + PCI_PTM_CTRL, ctrl);\n}\n\n \nvoid pci_disable_ptm(struct pci_dev *dev)\n{\n\tif (dev->ptm_enabled) {\n\t\t__pci_disable_ptm(dev);\n\t\tdev->ptm_enabled = 0;\n\t}\n}\nEXPORT_SYMBOL(pci_disable_ptm);\n\n \nvoid pci_suspend_ptm(struct pci_dev *dev)\n{\n\tif (dev->ptm_enabled)\n\t\t__pci_disable_ptm(dev);\n}\n\n \nvoid pci_resume_ptm(struct pci_dev *dev)\n{\n\tif (dev->ptm_enabled)\n\t\t__pci_enable_ptm(dev);\n}\n\nbool pcie_ptm_enabled(struct pci_dev *dev)\n{\n\tif (!dev)\n\t\treturn false;\n\n\treturn dev->ptm_enabled;\n}\nEXPORT_SYMBOL(pcie_ptm_enabled);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}