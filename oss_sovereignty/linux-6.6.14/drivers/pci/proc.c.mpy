{
  "module_name": "proc.c",
  "hash_id": "30a1ccde7b63e543898edfdd85ffd9aae84a1afa1551772cc63629b67b98f9ad",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/proc.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/pci.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <asm/byteorder.h>\n#include \"pci.h\"\n\nstatic int proc_initialized;\t \n\nstatic loff_t proc_bus_pci_lseek(struct file *file, loff_t off, int whence)\n{\n\tstruct pci_dev *dev = pde_data(file_inode(file));\n\treturn fixed_size_llseek(file, off, whence, dev->cfg_size);\n}\n\nstatic ssize_t proc_bus_pci_read(struct file *file, char __user *buf,\n\t\t\t\t size_t nbytes, loff_t *ppos)\n{\n\tstruct pci_dev *dev = pde_data(file_inode(file));\n\tunsigned int pos = *ppos;\n\tunsigned int cnt, size;\n\n\t \n\n\tif (capable(CAP_SYS_ADMIN))\n\t\tsize = dev->cfg_size;\n\telse if (dev->hdr_type == PCI_HEADER_TYPE_CARDBUS)\n\t\tsize = 128;\n\telse\n\t\tsize = 64;\n\n\tif (pos >= size)\n\t\treturn 0;\n\tif (nbytes >= size)\n\t\tnbytes = size;\n\tif (pos + nbytes > size)\n\t\tnbytes = size - pos;\n\tcnt = nbytes;\n\n\tif (!access_ok(buf, cnt))\n\t\treturn -EINVAL;\n\n\tpci_config_pm_runtime_get(dev);\n\n\tif ((pos & 1) && cnt) {\n\t\tunsigned char val;\n\t\tpci_user_read_config_byte(dev, pos, &val);\n\t\t__put_user(val, buf);\n\t\tbuf++;\n\t\tpos++;\n\t\tcnt--;\n\t}\n\n\tif ((pos & 3) && cnt > 2) {\n\t\tunsigned short val;\n\t\tpci_user_read_config_word(dev, pos, &val);\n\t\t__put_user(cpu_to_le16(val), (__le16 __user *) buf);\n\t\tbuf += 2;\n\t\tpos += 2;\n\t\tcnt -= 2;\n\t}\n\n\twhile (cnt >= 4) {\n\t\tunsigned int val;\n\t\tpci_user_read_config_dword(dev, pos, &val);\n\t\t__put_user(cpu_to_le32(val), (__le32 __user *) buf);\n\t\tbuf += 4;\n\t\tpos += 4;\n\t\tcnt -= 4;\n\t\tcond_resched();\n\t}\n\n\tif (cnt >= 2) {\n\t\tunsigned short val;\n\t\tpci_user_read_config_word(dev, pos, &val);\n\t\t__put_user(cpu_to_le16(val), (__le16 __user *) buf);\n\t\tbuf += 2;\n\t\tpos += 2;\n\t\tcnt -= 2;\n\t}\n\n\tif (cnt) {\n\t\tunsigned char val;\n\t\tpci_user_read_config_byte(dev, pos, &val);\n\t\t__put_user(val, buf);\n\t\tpos++;\n\t}\n\n\tpci_config_pm_runtime_put(dev);\n\n\t*ppos = pos;\n\treturn nbytes;\n}\n\nstatic ssize_t proc_bus_pci_write(struct file *file, const char __user *buf,\n\t\t\t\t  size_t nbytes, loff_t *ppos)\n{\n\tstruct inode *ino = file_inode(file);\n\tstruct pci_dev *dev = pde_data(ino);\n\tint pos = *ppos;\n\tint size = dev->cfg_size;\n\tint cnt, ret;\n\n\tret = security_locked_down(LOCKDOWN_PCI_ACCESS);\n\tif (ret)\n\t\treturn ret;\n\n\tif (pos >= size)\n\t\treturn 0;\n\tif (nbytes >= size)\n\t\tnbytes = size;\n\tif (pos + nbytes > size)\n\t\tnbytes = size - pos;\n\tcnt = nbytes;\n\n\tif (!access_ok(buf, cnt))\n\t\treturn -EINVAL;\n\n\tpci_config_pm_runtime_get(dev);\n\n\tif ((pos & 1) && cnt) {\n\t\tunsigned char val;\n\t\t__get_user(val, buf);\n\t\tpci_user_write_config_byte(dev, pos, val);\n\t\tbuf++;\n\t\tpos++;\n\t\tcnt--;\n\t}\n\n\tif ((pos & 3) && cnt > 2) {\n\t\t__le16 val;\n\t\t__get_user(val, (__le16 __user *) buf);\n\t\tpci_user_write_config_word(dev, pos, le16_to_cpu(val));\n\t\tbuf += 2;\n\t\tpos += 2;\n\t\tcnt -= 2;\n\t}\n\n\twhile (cnt >= 4) {\n\t\t__le32 val;\n\t\t__get_user(val, (__le32 __user *) buf);\n\t\tpci_user_write_config_dword(dev, pos, le32_to_cpu(val));\n\t\tbuf += 4;\n\t\tpos += 4;\n\t\tcnt -= 4;\n\t}\n\n\tif (cnt >= 2) {\n\t\t__le16 val;\n\t\t__get_user(val, (__le16 __user *) buf);\n\t\tpci_user_write_config_word(dev, pos, le16_to_cpu(val));\n\t\tbuf += 2;\n\t\tpos += 2;\n\t\tcnt -= 2;\n\t}\n\n\tif (cnt) {\n\t\tunsigned char val;\n\t\t__get_user(val, buf);\n\t\tpci_user_write_config_byte(dev, pos, val);\n\t\tpos++;\n\t}\n\n\tpci_config_pm_runtime_put(dev);\n\n\t*ppos = pos;\n\ti_size_write(ino, dev->cfg_size);\n\treturn nbytes;\n}\n\n#ifdef HAVE_PCI_MMAP\nstruct pci_filp_private {\n\tenum pci_mmap_state mmap_state;\n\tint write_combine;\n};\n#endif  \n\nstatic long proc_bus_pci_ioctl(struct file *file, unsigned int cmd,\n\t\t\t       unsigned long arg)\n{\n\tstruct pci_dev *dev = pde_data(file_inode(file));\n#ifdef HAVE_PCI_MMAP\n\tstruct pci_filp_private *fpriv = file->private_data;\n#endif  \n\tint ret = 0;\n\n\tret = security_locked_down(LOCKDOWN_PCI_ACCESS);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (cmd) {\n\tcase PCIIOC_CONTROLLER:\n\t\tret = pci_domain_nr(dev->bus);\n\t\tbreak;\n\n#ifdef HAVE_PCI_MMAP\n\tcase PCIIOC_MMAP_IS_IO:\n\t\tif (!arch_can_pci_mmap_io())\n\t\t\treturn -EINVAL;\n\t\tfpriv->mmap_state = pci_mmap_io;\n\t\tbreak;\n\n\tcase PCIIOC_MMAP_IS_MEM:\n\t\tfpriv->mmap_state = pci_mmap_mem;\n\t\tbreak;\n\n\tcase PCIIOC_WRITE_COMBINE:\n\t\tif (arch_can_pci_mmap_wc()) {\n\t\t\tif (arg)\n\t\t\t\tfpriv->write_combine = 1;\n\t\t\telse\n\t\t\t\tfpriv->write_combine = 0;\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tfallthrough;\n#endif  \n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\n#ifdef HAVE_PCI_MMAP\nstatic int proc_bus_pci_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tstruct pci_dev *dev = pde_data(file_inode(file));\n\tstruct pci_filp_private *fpriv = file->private_data;\n\tresource_size_t start, end;\n\tint i, ret, write_combine = 0, res_bit = IORESOURCE_MEM;\n\n\tif (!capable(CAP_SYS_RAWIO) ||\n\t    security_locked_down(LOCKDOWN_PCI_ACCESS))\n\t\treturn -EPERM;\n\n\tif (fpriv->mmap_state == pci_mmap_io) {\n\t\tif (!arch_can_pci_mmap_io())\n\t\t\treturn -EINVAL;\n\t\tres_bit = IORESOURCE_IO;\n\t}\n\n\t \n\tfor (i = 0; i < PCI_STD_NUM_BARS; i++) {\n\t\tif (dev->resource[i].flags & res_bit &&\n\t\t    pci_mmap_fits(dev, i, vma,  PCI_MMAP_PROCFS))\n\t\t\tbreak;\n\t}\n\n\tif (i >= PCI_STD_NUM_BARS)\n\t\treturn -ENODEV;\n\n\tif (fpriv->mmap_state == pci_mmap_mem &&\n\t    fpriv->write_combine) {\n\t\tif (dev->resource[i].flags & IORESOURCE_PREFETCH)\n\t\t\twrite_combine = 1;\n\t\telse\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (dev->resource[i].flags & IORESOURCE_MEM &&\n\t    iomem_is_exclusive(dev->resource[i].start))\n\t\treturn -EINVAL;\n\n\tpci_resource_to_user(dev, i, &dev->resource[i], &start, &end);\n\n\t \n\tvma->vm_pgoff -= start >> PAGE_SHIFT;\n\tret = pci_mmap_resource_range(dev, i, vma,\n\t\t\t\t  fpriv->mmap_state, write_combine);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int proc_bus_pci_open(struct inode *inode, struct file *file)\n{\n\tstruct pci_filp_private *fpriv = kmalloc(sizeof(*fpriv), GFP_KERNEL);\n\n\tif (!fpriv)\n\t\treturn -ENOMEM;\n\n\tfpriv->mmap_state = pci_mmap_io;\n\tfpriv->write_combine = 0;\n\n\tfile->private_data = fpriv;\n\tfile->f_mapping = iomem_get_mapping();\n\n\treturn 0;\n}\n\nstatic int proc_bus_pci_release(struct inode *inode, struct file *file)\n{\n\tkfree(file->private_data);\n\tfile->private_data = NULL;\n\n\treturn 0;\n}\n#endif  \n\nstatic const struct proc_ops proc_bus_pci_ops = {\n\t.proc_lseek\t= proc_bus_pci_lseek,\n\t.proc_read\t= proc_bus_pci_read,\n\t.proc_write\t= proc_bus_pci_write,\n\t.proc_ioctl\t= proc_bus_pci_ioctl,\n#ifdef CONFIG_COMPAT\n\t.proc_compat_ioctl = proc_bus_pci_ioctl,\n#endif\n#ifdef HAVE_PCI_MMAP\n\t.proc_open\t= proc_bus_pci_open,\n\t.proc_release\t= proc_bus_pci_release,\n\t.proc_mmap\t= proc_bus_pci_mmap,\n#ifdef HAVE_ARCH_PCI_GET_UNMAPPED_AREA\n\t.proc_get_unmapped_area = get_pci_unmapped_area,\n#endif  \n#endif  \n};\n\n \nstatic void *pci_seq_start(struct seq_file *m, loff_t *pos)\n{\n\tstruct pci_dev *dev = NULL;\n\tloff_t n = *pos;\n\n\tfor_each_pci_dev(dev) {\n\t\tif (!n--)\n\t\t\tbreak;\n\t}\n\treturn dev;\n}\n\nstatic void *pci_seq_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\tstruct pci_dev *dev = v;\n\n\t(*pos)++;\n\tdev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, dev);\n\treturn dev;\n}\n\nstatic void pci_seq_stop(struct seq_file *m, void *v)\n{\n\tif (v) {\n\t\tstruct pci_dev *dev = v;\n\t\tpci_dev_put(dev);\n\t}\n}\n\nstatic int show_device(struct seq_file *m, void *v)\n{\n\tconst struct pci_dev *dev = v;\n\tconst struct pci_driver *drv;\n\tint i;\n\n\tif (dev == NULL)\n\t\treturn 0;\n\n\tdrv = pci_dev_driver(dev);\n\tseq_printf(m, \"%02x%02x\\t%04x%04x\\t%x\",\n\t\t\tdev->bus->number,\n\t\t\tdev->devfn,\n\t\t\tdev->vendor,\n\t\t\tdev->device,\n\t\t\tdev->irq);\n\n\t \n\tfor (i = 0; i <= PCI_ROM_RESOURCE; i++) {\n\t\tresource_size_t start, end;\n\t\tpci_resource_to_user(dev, i, &dev->resource[i], &start, &end);\n\t\tseq_printf(m, \"\\t%16llx\",\n\t\t\t(unsigned long long)(start |\n\t\t\t(dev->resource[i].flags & PCI_REGION_FLAG_MASK)));\n\t}\n\tfor (i = 0; i <= PCI_ROM_RESOURCE; i++) {\n\t\tresource_size_t start, end;\n\t\tpci_resource_to_user(dev, i, &dev->resource[i], &start, &end);\n\t\tseq_printf(m, \"\\t%16llx\",\n\t\t\tdev->resource[i].start < dev->resource[i].end ?\n\t\t\t(unsigned long long)(end - start) + 1 : 0);\n\t}\n\tseq_putc(m, '\\t');\n\tif (drv)\n\t\tseq_puts(m, drv->name);\n\tseq_putc(m, '\\n');\n\treturn 0;\n}\n\nstatic const struct seq_operations proc_bus_pci_devices_op = {\n\t.start\t= pci_seq_start,\n\t.next\t= pci_seq_next,\n\t.stop\t= pci_seq_stop,\n\t.show\t= show_device\n};\n\nstatic struct proc_dir_entry *proc_bus_pci_dir;\n\nint pci_proc_attach_device(struct pci_dev *dev)\n{\n\tstruct pci_bus *bus = dev->bus;\n\tstruct proc_dir_entry *e;\n\tchar name[16];\n\n\tif (!proc_initialized)\n\t\treturn -EACCES;\n\n\tif (!bus->procdir) {\n\t\tif (pci_proc_domain(bus)) {\n\t\t\tsprintf(name, \"%04x:%02x\", pci_domain_nr(bus),\n\t\t\t\t\tbus->number);\n\t\t} else {\n\t\t\tsprintf(name, \"%02x\", bus->number);\n\t\t}\n\t\tbus->procdir = proc_mkdir(name, proc_bus_pci_dir);\n\t\tif (!bus->procdir)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tsprintf(name, \"%02x.%x\", PCI_SLOT(dev->devfn), PCI_FUNC(dev->devfn));\n\te = proc_create_data(name, S_IFREG | S_IRUGO | S_IWUSR, bus->procdir,\n\t\t\t     &proc_bus_pci_ops, dev);\n\tif (!e)\n\t\treturn -ENOMEM;\n\tproc_set_size(e, dev->cfg_size);\n\tdev->procent = e;\n\n\treturn 0;\n}\n\nint pci_proc_detach_device(struct pci_dev *dev)\n{\n\tproc_remove(dev->procent);\n\tdev->procent = NULL;\n\treturn 0;\n}\n\nint pci_proc_detach_bus(struct pci_bus *bus)\n{\n\tproc_remove(bus->procdir);\n\treturn 0;\n}\n\nstatic int __init pci_proc_init(void)\n{\n\tstruct pci_dev *dev = NULL;\n\tproc_bus_pci_dir = proc_mkdir(\"bus/pci\", NULL);\n\tproc_create_seq(\"devices\", 0, proc_bus_pci_dir,\n\t\t    &proc_bus_pci_devices_op);\n\tproc_initialized = 1;\n\tfor_each_pci_dev(dev)\n\t\tpci_proc_attach_device(dev);\n\n\treturn 0;\n}\ndevice_initcall(pci_proc_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}