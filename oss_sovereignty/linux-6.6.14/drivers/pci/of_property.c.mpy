{
  "module_name": "of_property.c",
  "hash_id": "e1186df426abc735f082a69d747c6eeb7df61a428f16b3648df258a76d486566",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/of_property.c",
  "human_readable_source": "\n \n\n#include <linux/pci.h>\n#include <linux/of.h>\n#include <linux/of_irq.h>\n#include <linux/bitfield.h>\n#include <linux/bits.h>\n#include \"pci.h\"\n\n#define OF_PCI_ADDRESS_CELLS\t\t3\n#define OF_PCI_SIZE_CELLS\t\t2\n#define OF_PCI_MAX_INT_PIN\t\t4\n\nstruct of_pci_addr_pair {\n\tu32\t\tphys_addr[OF_PCI_ADDRESS_CELLS];\n\tu32\t\tsize[OF_PCI_SIZE_CELLS];\n};\n\n \nstruct of_pci_range {\n\tu32\t\tchild_addr[OF_PCI_ADDRESS_CELLS];\n\tu32\t\tparent_addr[OF_PCI_ADDRESS_CELLS];\n\tu32\t\tsize[OF_PCI_SIZE_CELLS];\n};\n\n#define OF_PCI_ADDR_SPACE_IO\t\t0x1\n#define OF_PCI_ADDR_SPACE_MEM32\t\t0x2\n#define OF_PCI_ADDR_SPACE_MEM64\t\t0x3\n\n#define OF_PCI_ADDR_FIELD_NONRELOC\tBIT(31)\n#define OF_PCI_ADDR_FIELD_SS\t\tGENMASK(25, 24)\n#define OF_PCI_ADDR_FIELD_PREFETCH\tBIT(30)\n#define OF_PCI_ADDR_FIELD_BUS\t\tGENMASK(23, 16)\n#define OF_PCI_ADDR_FIELD_DEV\t\tGENMASK(15, 11)\n#define OF_PCI_ADDR_FIELD_FUNC\t\tGENMASK(10, 8)\n#define OF_PCI_ADDR_FIELD_REG\t\tGENMASK(7, 0)\n\nenum of_pci_prop_compatible {\n\tPROP_COMPAT_PCI_VVVV_DDDD,\n\tPROP_COMPAT_PCICLASS_CCSSPP,\n\tPROP_COMPAT_PCICLASS_CCSS,\n\tPROP_COMPAT_NUM,\n};\n\nstatic void of_pci_set_address(struct pci_dev *pdev, u32 *prop, u64 addr,\n\t\t\t       u32 reg_num, u32 flags, bool reloc)\n{\n\tprop[0] = FIELD_PREP(OF_PCI_ADDR_FIELD_BUS, pdev->bus->number) |\n\t\tFIELD_PREP(OF_PCI_ADDR_FIELD_DEV, PCI_SLOT(pdev->devfn)) |\n\t\tFIELD_PREP(OF_PCI_ADDR_FIELD_FUNC, PCI_FUNC(pdev->devfn));\n\tprop[0] |= flags | reg_num;\n\tif (!reloc) {\n\t\tprop[0] |= OF_PCI_ADDR_FIELD_NONRELOC;\n\t\tprop[1] = upper_32_bits(addr);\n\t\tprop[2] = lower_32_bits(addr);\n\t}\n}\n\nstatic int of_pci_get_addr_flags(struct resource *res, u32 *flags)\n{\n\tu32 ss;\n\n\tif (res->flags & IORESOURCE_IO)\n\t\tss = OF_PCI_ADDR_SPACE_IO;\n\telse if (res->flags & IORESOURCE_MEM_64)\n\t\tss = OF_PCI_ADDR_SPACE_MEM64;\n\telse if (res->flags & IORESOURCE_MEM)\n\t\tss = OF_PCI_ADDR_SPACE_MEM32;\n\telse\n\t\treturn -EINVAL;\n\n\t*flags = 0;\n\tif (res->flags & IORESOURCE_PREFETCH)\n\t\t*flags |= OF_PCI_ADDR_FIELD_PREFETCH;\n\n\t*flags |= FIELD_PREP(OF_PCI_ADDR_FIELD_SS, ss);\n\n\treturn 0;\n}\n\nstatic int of_pci_prop_bus_range(struct pci_dev *pdev,\n\t\t\t\t struct of_changeset *ocs,\n\t\t\t\t struct device_node *np)\n{\n\tu32 bus_range[] = { pdev->subordinate->busn_res.start,\n\t\t\t    pdev->subordinate->busn_res.end };\n\n\treturn of_changeset_add_prop_u32_array(ocs, np, \"bus-range\", bus_range,\n\t\t\t\t\t       ARRAY_SIZE(bus_range));\n}\n\nstatic int of_pci_prop_ranges(struct pci_dev *pdev, struct of_changeset *ocs,\n\t\t\t      struct device_node *np)\n{\n\tstruct of_pci_range *rp;\n\tstruct resource *res;\n\tint i, j, ret;\n\tu32 flags, num;\n\tu64 val64;\n\n\tif (pci_is_bridge(pdev)) {\n\t\tnum = PCI_BRIDGE_RESOURCE_NUM;\n\t\tres = &pdev->resource[PCI_BRIDGE_RESOURCES];\n\t} else {\n\t\tnum = PCI_STD_NUM_BARS;\n\t\tres = &pdev->resource[PCI_STD_RESOURCES];\n\t}\n\n\trp = kcalloc(num, sizeof(*rp), GFP_KERNEL);\n\tif (!rp)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0, j = 0; j < num; j++) {\n\t\tif (!resource_size(&res[j]))\n\t\t\tcontinue;\n\n\t\tif (of_pci_get_addr_flags(&res[j], &flags))\n\t\t\tcontinue;\n\n\t\tval64 = res[j].start;\n\t\tof_pci_set_address(pdev, rp[i].parent_addr, val64, 0, flags,\n\t\t\t\t   false);\n\t\tif (pci_is_bridge(pdev)) {\n\t\t\tmemcpy(rp[i].child_addr, rp[i].parent_addr,\n\t\t\t       sizeof(rp[i].child_addr));\n\t\t} else {\n\t\t\t \n\t\t\trp[i].child_addr[0] = j;\n\t\t}\n\n\t\tval64 = resource_size(&res[j]);\n\t\trp[i].size[0] = upper_32_bits(val64);\n\t\trp[i].size[1] = lower_32_bits(val64);\n\n\t\ti++;\n\t}\n\n\tret = of_changeset_add_prop_u32_array(ocs, np, \"ranges\", (u32 *)rp,\n\t\t\t\t\t      i * sizeof(*rp) / sizeof(u32));\n\tkfree(rp);\n\n\treturn ret;\n}\n\nstatic int of_pci_prop_reg(struct pci_dev *pdev, struct of_changeset *ocs,\n\t\t\t   struct device_node *np)\n{\n\tstruct of_pci_addr_pair reg = { 0 };\n\n\t \n\tof_pci_set_address(pdev, reg.phys_addr, 0, 0, 0, true);\n\n\treturn of_changeset_add_prop_u32_array(ocs, np, \"reg\", (u32 *)&reg,\n\t\t\t\t\t       sizeof(reg) / sizeof(u32));\n}\n\nstatic int of_pci_prop_interrupts(struct pci_dev *pdev,\n\t\t\t\t  struct of_changeset *ocs,\n\t\t\t\t  struct device_node *np)\n{\n\tint ret;\n\tu8 pin;\n\n\tret = pci_read_config_byte(pdev, PCI_INTERRUPT_PIN, &pin);\n\tif (ret != 0)\n\t\treturn ret;\n\n\tif (!pin)\n\t\treturn 0;\n\n\treturn of_changeset_add_prop_u32(ocs, np, \"interrupts\", (u32)pin);\n}\n\nstatic int of_pci_prop_intr_map(struct pci_dev *pdev, struct of_changeset *ocs,\n\t\t\t\tstruct device_node *np)\n{\n\tu32 i, addr_sz[OF_PCI_MAX_INT_PIN] = { 0 }, map_sz = 0;\n\tstruct of_phandle_args out_irq[OF_PCI_MAX_INT_PIN];\n\t__be32 laddr[OF_PCI_ADDRESS_CELLS] = { 0 };\n\tu32 int_map_mask[] = { 0xffff00, 0, 0, 7 };\n\tstruct device_node *pnode;\n\tstruct pci_dev *child;\n\tu32 *int_map, *mapp;\n\tint ret;\n\tu8 pin;\n\n\tpnode = pci_device_to_OF_node(pdev->bus->self);\n\tif (!pnode)\n\t\tpnode = pci_bus_to_OF_node(pdev->bus);\n\n\tif (!pnode) {\n\t\tpci_err(pdev, \"failed to get parent device node\");\n\t\treturn -EINVAL;\n\t}\n\n\tladdr[0] = cpu_to_be32((pdev->bus->number << 16) | (pdev->devfn << 8));\n\tfor (pin = 1; pin <= OF_PCI_MAX_INT_PIN;  pin++) {\n\t\ti = pin - 1;\n\t\tout_irq[i].np = pnode;\n\t\tout_irq[i].args_count = 1;\n\t\tout_irq[i].args[0] = pin;\n\t\tret = of_irq_parse_raw(laddr, &out_irq[i]);\n\t\tif (ret) {\n\t\t\tout_irq[i].np = NULL;\n\t\t\tpci_dbg(pdev, \"parse irq %d failed, ret %d\", pin, ret);\n\t\t\tcontinue;\n\t\t}\n\t\tof_property_read_u32(out_irq[i].np, \"#address-cells\",\n\t\t\t\t     &addr_sz[i]);\n\t}\n\n\tlist_for_each_entry(child, &pdev->subordinate->devices, bus_list) {\n\t\tfor (pin = 1; pin <= OF_PCI_MAX_INT_PIN; pin++) {\n\t\t\ti = pci_swizzle_interrupt_pin(child, pin) - 1;\n\t\t\tif (!out_irq[i].np)\n\t\t\t\tcontinue;\n\t\t\tmap_sz += 5 + addr_sz[i] + out_irq[i].args_count;\n\t\t}\n\t}\n\n\t \n\tif (!map_sz)\n\t\treturn 0;\n\n\tint_map = kcalloc(map_sz, sizeof(u32), GFP_KERNEL);\n\tmapp = int_map;\n\n\tlist_for_each_entry(child, &pdev->subordinate->devices, bus_list) {\n\t\tfor (pin = 1; pin <= OF_PCI_MAX_INT_PIN; pin++) {\n\t\t\ti = pci_swizzle_interrupt_pin(child, pin) - 1;\n\t\t\tif (!out_irq[i].np)\n\t\t\t\tcontinue;\n\n\t\t\t*mapp = (child->bus->number << 16) |\n\t\t\t\t(child->devfn << 8);\n\t\t\tmapp += OF_PCI_ADDRESS_CELLS;\n\t\t\t*mapp = pin;\n\t\t\tmapp++;\n\t\t\t*mapp = out_irq[i].np->phandle;\n\t\t\tmapp++;\n\t\t\tif (addr_sz[i]) {\n\t\t\t\tret = of_property_read_u32_array(out_irq[i].np,\n\t\t\t\t\t\t\t\t \"reg\", mapp,\n\t\t\t\t\t\t\t\t addr_sz[i]);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto failed;\n\t\t\t}\n\t\t\tmapp += addr_sz[i];\n\t\t\tmemcpy(mapp, out_irq[i].args,\n\t\t\t       out_irq[i].args_count * sizeof(u32));\n\t\t\tmapp += out_irq[i].args_count;\n\t\t}\n\t}\n\n\tret = of_changeset_add_prop_u32_array(ocs, np, \"interrupt-map\", int_map,\n\t\t\t\t\t      map_sz);\n\tif (ret)\n\t\tgoto failed;\n\n\tret = of_changeset_add_prop_u32(ocs, np, \"#interrupt-cells\", 1);\n\tif (ret)\n\t\tgoto failed;\n\n\tret = of_changeset_add_prop_u32_array(ocs, np, \"interrupt-map-mask\",\n\t\t\t\t\t      int_map_mask,\n\t\t\t\t\t      ARRAY_SIZE(int_map_mask));\n\tif (ret)\n\t\tgoto failed;\n\n\tkfree(int_map);\n\treturn 0;\n\nfailed:\n\tkfree(int_map);\n\treturn ret;\n}\n\nstatic int of_pci_prop_compatible(struct pci_dev *pdev,\n\t\t\t\t  struct of_changeset *ocs,\n\t\t\t\t  struct device_node *np)\n{\n\tconst char *compat_strs[PROP_COMPAT_NUM] = { 0 };\n\tint i, ret;\n\n\tcompat_strs[PROP_COMPAT_PCI_VVVV_DDDD] =\n\t\tkasprintf(GFP_KERNEL, \"pci%x,%x\", pdev->vendor, pdev->device);\n\tcompat_strs[PROP_COMPAT_PCICLASS_CCSSPP] =\n\t\tkasprintf(GFP_KERNEL, \"pciclass,%06x\", pdev->class);\n\tcompat_strs[PROP_COMPAT_PCICLASS_CCSS] =\n\t\tkasprintf(GFP_KERNEL, \"pciclass,%04x\", pdev->class >> 8);\n\n\tret = of_changeset_add_prop_string_array(ocs, np, \"compatible\",\n\t\t\t\t\t\t compat_strs, PROP_COMPAT_NUM);\n\tfor (i = 0; i < PROP_COMPAT_NUM; i++)\n\t\tkfree(compat_strs[i]);\n\n\treturn ret;\n}\n\nint of_pci_add_properties(struct pci_dev *pdev, struct of_changeset *ocs,\n\t\t\t  struct device_node *np)\n{\n\tint ret;\n\n\t \n\tif (pci_is_bridge(pdev)) {\n\t\tret = of_changeset_add_prop_string(ocs, np, \"device_type\",\n\t\t\t\t\t\t   \"pci\");\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = of_pci_prop_bus_range(pdev, ocs, np);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = of_pci_prop_intr_map(pdev, ocs, np);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = of_pci_prop_ranges(pdev, ocs, np);\n\tif (ret)\n\t\treturn ret;\n\n\tret = of_changeset_add_prop_u32(ocs, np, \"#address-cells\",\n\t\t\t\t\tOF_PCI_ADDRESS_CELLS);\n\tif (ret)\n\t\treturn ret;\n\n\tret = of_changeset_add_prop_u32(ocs, np, \"#size-cells\",\n\t\t\t\t\tOF_PCI_SIZE_CELLS);\n\tif (ret)\n\t\treturn ret;\n\n\tret = of_pci_prop_reg(pdev, ocs, np);\n\tif (ret)\n\t\treturn ret;\n\n\tret = of_pci_prop_compatible(pdev, ocs, np);\n\tif (ret)\n\t\treturn ret;\n\n\tret = of_pci_prop_interrupts(pdev, ocs, np);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}