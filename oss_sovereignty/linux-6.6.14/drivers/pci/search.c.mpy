{
  "module_name": "search.c",
  "hash_id": "9ee75161d5ce668b25e4b408038acdaca6c3f6469061c49c46143a472f5d17f0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/search.c",
  "human_readable_source": "\n \n\n#include <linux/pci.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include \"pci.h\"\n\nDECLARE_RWSEM(pci_bus_sem);\n\n \nint pci_for_each_dma_alias(struct pci_dev *pdev,\n\t\t\t   int (*fn)(struct pci_dev *pdev,\n\t\t\t\t     u16 alias, void *data), void *data)\n{\n\tstruct pci_bus *bus;\n\tint ret;\n\n\t \n\tpdev = pci_real_dma_dev(pdev);\n\n\tret = fn(pdev, pci_dev_id(pdev), data);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (unlikely(pdev->dma_alias_mask)) {\n\t\tunsigned int devfn;\n\n\t\tfor_each_set_bit(devfn, pdev->dma_alias_mask, MAX_NR_DEVFNS) {\n\t\t\tret = fn(pdev, PCI_DEVID(pdev->bus->number, devfn),\n\t\t\t\t data);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\tfor (bus = pdev->bus; !pci_is_root_bus(bus); bus = bus->parent) {\n\t\tstruct pci_dev *tmp;\n\n\t\t \n\t\tif (!bus->self)\n\t\t\tcontinue;\n\n\t\ttmp = bus->self;\n\n\t\t \n\t\tif (tmp->dev_flags & PCI_DEV_FLAGS_BRIDGE_XLATE_ROOT)\n\t\t\treturn ret;\n\n\t\t \n\t\tif (pci_is_pcie(tmp)) {\n\t\t\tswitch (pci_pcie_type(tmp)) {\n\t\t\tcase PCI_EXP_TYPE_ROOT_PORT:\n\t\t\tcase PCI_EXP_TYPE_UPSTREAM:\n\t\t\tcase PCI_EXP_TYPE_DOWNSTREAM:\n\t\t\t\tcontinue;\n\t\t\tcase PCI_EXP_TYPE_PCI_BRIDGE:\n\t\t\t\tret = fn(tmp,\n\t\t\t\t\t PCI_DEVID(tmp->subordinate->number,\n\t\t\t\t\t\t   PCI_DEVFN(0, 0)), data);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\t\t\t\tcontinue;\n\t\t\tcase PCI_EXP_TYPE_PCIE_BRIDGE:\n\t\t\t\tret = fn(tmp, pci_dev_id(tmp), data);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tif (tmp->dev_flags & PCI_DEV_FLAG_PCIE_BRIDGE_ALIAS)\n\t\t\t\tret = fn(tmp,\n\t\t\t\t\t PCI_DEVID(tmp->subordinate->number,\n\t\t\t\t\t\t   PCI_DEVFN(0, 0)), data);\n\t\t\telse\n\t\t\t\tret = fn(tmp, pci_dev_id(tmp), data);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic struct pci_bus *pci_do_find_bus(struct pci_bus *bus, unsigned char busnr)\n{\n\tstruct pci_bus *child;\n\tstruct pci_bus *tmp;\n\n\tif (bus->number == busnr)\n\t\treturn bus;\n\n\tlist_for_each_entry(tmp, &bus->children, node) {\n\t\tchild = pci_do_find_bus(tmp, busnr);\n\t\tif (child)\n\t\t\treturn child;\n\t}\n\treturn NULL;\n}\n\n \nstruct pci_bus *pci_find_bus(int domain, int busnr)\n{\n\tstruct pci_bus *bus = NULL;\n\tstruct pci_bus *tmp_bus;\n\n\twhile ((bus = pci_find_next_bus(bus)) != NULL)  {\n\t\tif (pci_domain_nr(bus) != domain)\n\t\t\tcontinue;\n\t\ttmp_bus = pci_do_find_bus(bus, busnr);\n\t\tif (tmp_bus)\n\t\t\treturn tmp_bus;\n\t}\n\treturn NULL;\n}\nEXPORT_SYMBOL(pci_find_bus);\n\n \nstruct pci_bus *pci_find_next_bus(const struct pci_bus *from)\n{\n\tstruct list_head *n;\n\tstruct pci_bus *b = NULL;\n\n\tdown_read(&pci_bus_sem);\n\tn = from ? from->node.next : pci_root_buses.next;\n\tif (n != &pci_root_buses)\n\t\tb = list_entry(n, struct pci_bus, node);\n\tup_read(&pci_bus_sem);\n\treturn b;\n}\nEXPORT_SYMBOL(pci_find_next_bus);\n\n \nstruct pci_dev *pci_get_slot(struct pci_bus *bus, unsigned int devfn)\n{\n\tstruct pci_dev *dev;\n\n\tdown_read(&pci_bus_sem);\n\n\tlist_for_each_entry(dev, &bus->devices, bus_list) {\n\t\tif (dev->devfn == devfn)\n\t\t\tgoto out;\n\t}\n\n\tdev = NULL;\n out:\n\tpci_dev_get(dev);\n\tup_read(&pci_bus_sem);\n\treturn dev;\n}\nEXPORT_SYMBOL(pci_get_slot);\n\n \nstruct pci_dev *pci_get_domain_bus_and_slot(int domain, unsigned int bus,\n\t\t\t\t\t    unsigned int devfn)\n{\n\tstruct pci_dev *dev = NULL;\n\n\tfor_each_pci_dev(dev) {\n\t\tif (pci_domain_nr(dev->bus) == domain &&\n\t\t    (dev->bus->number == bus && dev->devfn == devfn))\n\t\t\treturn dev;\n\t}\n\treturn NULL;\n}\nEXPORT_SYMBOL(pci_get_domain_bus_and_slot);\n\nstatic int match_pci_dev_by_id(struct device *dev, const void *data)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tconst struct pci_device_id *id = data;\n\n\tif (pci_match_one_device(id, pdev))\n\t\treturn 1;\n\treturn 0;\n}\n\n \nstatic struct pci_dev *pci_get_dev_by_id(const struct pci_device_id *id,\n\t\t\t\t\t struct pci_dev *from)\n{\n\tstruct device *dev;\n\tstruct device *dev_start = NULL;\n\tstruct pci_dev *pdev = NULL;\n\n\tif (from)\n\t\tdev_start = &from->dev;\n\tdev = bus_find_device(&pci_bus_type, dev_start, (void *)id,\n\t\t\t      match_pci_dev_by_id);\n\tif (dev)\n\t\tpdev = to_pci_dev(dev);\n\tpci_dev_put(from);\n\treturn pdev;\n}\n\n \nstruct pci_dev *pci_get_subsys(unsigned int vendor, unsigned int device,\n\t\t\t       unsigned int ss_vendor, unsigned int ss_device,\n\t\t\t       struct pci_dev *from)\n{\n\tstruct pci_device_id id = {\n\t\t.vendor = vendor,\n\t\t.device = device,\n\t\t.subvendor = ss_vendor,\n\t\t.subdevice = ss_device,\n\t};\n\n\treturn pci_get_dev_by_id(&id, from);\n}\nEXPORT_SYMBOL(pci_get_subsys);\n\n \nstruct pci_dev *pci_get_device(unsigned int vendor, unsigned int device,\n\t\t\t       struct pci_dev *from)\n{\n\treturn pci_get_subsys(vendor, device, PCI_ANY_ID, PCI_ANY_ID, from);\n}\nEXPORT_SYMBOL(pci_get_device);\n\n \nstruct pci_dev *pci_get_class(unsigned int class, struct pci_dev *from)\n{\n\tstruct pci_device_id id = {\n\t\t.vendor = PCI_ANY_ID,\n\t\t.device = PCI_ANY_ID,\n\t\t.subvendor = PCI_ANY_ID,\n\t\t.subdevice = PCI_ANY_ID,\n\t\t.class_mask = PCI_ANY_ID,\n\t\t.class = class,\n\t};\n\n\treturn pci_get_dev_by_id(&id, from);\n}\nEXPORT_SYMBOL(pci_get_class);\n\n \nint pci_dev_present(const struct pci_device_id *ids)\n{\n\tstruct pci_dev *found = NULL;\n\n\twhile (ids->vendor || ids->subvendor || ids->class_mask) {\n\t\tfound = pci_get_dev_by_id(ids, NULL);\n\t\tif (found) {\n\t\t\tpci_dev_put(found);\n\t\t\treturn 1;\n\t\t}\n\t\tids++;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(pci_dev_present);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}