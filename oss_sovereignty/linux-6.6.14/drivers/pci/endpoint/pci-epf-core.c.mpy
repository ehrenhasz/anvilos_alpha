{
  "module_name": "pci-epf-core.c",
  "hash_id": "a3a07bb95d11dcfc612a0bfb2f1229174dc6237b67d28b0fb6319cf39352b4fb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/endpoint/pci-epf-core.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/dma-mapping.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\n#include <linux/pci-epc.h>\n#include <linux/pci-epf.h>\n#include <linux/pci-ep-cfs.h>\n\nstatic DEFINE_MUTEX(pci_epf_mutex);\n\nstatic struct bus_type pci_epf_bus_type;\nstatic const struct device_type pci_epf_type;\n\n \nvoid pci_epf_unbind(struct pci_epf *epf)\n{\n\tstruct pci_epf *epf_vf;\n\n\tif (!epf->driver) {\n\t\tdev_WARN(&epf->dev, \"epf device not bound to driver\\n\");\n\t\treturn;\n\t}\n\n\tmutex_lock(&epf->lock);\n\tlist_for_each_entry(epf_vf, &epf->pci_vepf, list) {\n\t\tif (epf_vf->is_bound)\n\t\t\tepf_vf->driver->ops->unbind(epf_vf);\n\t}\n\tif (epf->is_bound)\n\t\tepf->driver->ops->unbind(epf);\n\tmutex_unlock(&epf->lock);\n\tmodule_put(epf->driver->owner);\n}\nEXPORT_SYMBOL_GPL(pci_epf_unbind);\n\n \nint pci_epf_bind(struct pci_epf *epf)\n{\n\tstruct device *dev = &epf->dev;\n\tstruct pci_epf *epf_vf;\n\tu8 func_no, vfunc_no;\n\tstruct pci_epc *epc;\n\tint ret;\n\n\tif (!epf->driver) {\n\t\tdev_WARN(dev, \"epf device not bound to driver\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!try_module_get(epf->driver->owner))\n\t\treturn -EAGAIN;\n\n\tmutex_lock(&epf->lock);\n\tlist_for_each_entry(epf_vf, &epf->pci_vepf, list) {\n\t\tvfunc_no = epf_vf->vfunc_no;\n\n\t\tif (vfunc_no < 1) {\n\t\t\tdev_err(dev, \"Invalid virtual function number\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto ret;\n\t\t}\n\n\t\tepc = epf->epc;\n\t\tfunc_no = epf->func_no;\n\t\tif (!IS_ERR_OR_NULL(epc)) {\n\t\t\tif (!epc->max_vfs) {\n\t\t\t\tdev_err(dev, \"No support for virt function\\n\");\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto ret;\n\t\t\t}\n\n\t\t\tif (vfunc_no > epc->max_vfs[func_no]) {\n\t\t\t\tdev_err(dev, \"PF%d: Exceeds max vfunc number\\n\",\n\t\t\t\t\tfunc_no);\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto ret;\n\t\t\t}\n\t\t}\n\n\t\tepc = epf->sec_epc;\n\t\tfunc_no = epf->sec_epc_func_no;\n\t\tif (!IS_ERR_OR_NULL(epc)) {\n\t\t\tif (!epc->max_vfs) {\n\t\t\t\tdev_err(dev, \"No support for virt function\\n\");\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto ret;\n\t\t\t}\n\n\t\t\tif (vfunc_no > epc->max_vfs[func_no]) {\n\t\t\t\tdev_err(dev, \"PF%d: Exceeds max vfunc number\\n\",\n\t\t\t\t\tfunc_no);\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto ret;\n\t\t\t}\n\t\t}\n\n\t\tepf_vf->func_no = epf->func_no;\n\t\tepf_vf->sec_epc_func_no = epf->sec_epc_func_no;\n\t\tepf_vf->epc = epf->epc;\n\t\tepf_vf->sec_epc = epf->sec_epc;\n\t\tret = epf_vf->driver->ops->bind(epf_vf);\n\t\tif (ret)\n\t\t\tgoto ret;\n\t\tepf_vf->is_bound = true;\n\t}\n\n\tret = epf->driver->ops->bind(epf);\n\tif (ret)\n\t\tgoto ret;\n\tepf->is_bound = true;\n\n\tmutex_unlock(&epf->lock);\n\treturn 0;\n\nret:\n\tmutex_unlock(&epf->lock);\n\tpci_epf_unbind(epf);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(pci_epf_bind);\n\n \nint pci_epf_add_vepf(struct pci_epf *epf_pf, struct pci_epf *epf_vf)\n{\n\tu32 vfunc_no;\n\n\tif (IS_ERR_OR_NULL(epf_pf) || IS_ERR_OR_NULL(epf_vf))\n\t\treturn -EINVAL;\n\n\tif (epf_pf->epc || epf_vf->epc || epf_vf->epf_pf)\n\t\treturn -EBUSY;\n\n\tif (epf_pf->sec_epc || epf_vf->sec_epc)\n\t\treturn -EBUSY;\n\n\tmutex_lock(&epf_pf->lock);\n\tvfunc_no = find_first_zero_bit(&epf_pf->vfunction_num_map,\n\t\t\t\t       BITS_PER_LONG);\n\tif (vfunc_no >= BITS_PER_LONG) {\n\t\tmutex_unlock(&epf_pf->lock);\n\t\treturn -EINVAL;\n\t}\n\n\tset_bit(vfunc_no, &epf_pf->vfunction_num_map);\n\tepf_vf->vfunc_no = vfunc_no;\n\n\tepf_vf->epf_pf = epf_pf;\n\tepf_vf->is_vf = true;\n\n\tlist_add_tail(&epf_vf->list, &epf_pf->pci_vepf);\n\tmutex_unlock(&epf_pf->lock);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(pci_epf_add_vepf);\n\n \nvoid pci_epf_remove_vepf(struct pci_epf *epf_pf, struct pci_epf *epf_vf)\n{\n\tif (IS_ERR_OR_NULL(epf_pf) || IS_ERR_OR_NULL(epf_vf))\n\t\treturn;\n\n\tmutex_lock(&epf_pf->lock);\n\tclear_bit(epf_vf->vfunc_no, &epf_pf->vfunction_num_map);\n\tlist_del(&epf_vf->list);\n\tmutex_unlock(&epf_pf->lock);\n}\nEXPORT_SYMBOL_GPL(pci_epf_remove_vepf);\n\n \nvoid pci_epf_free_space(struct pci_epf *epf, void *addr, enum pci_barno bar,\n\t\t\tenum pci_epc_interface_type type)\n{\n\tstruct device *dev;\n\tstruct pci_epf_bar *epf_bar;\n\tstruct pci_epc *epc;\n\n\tif (!addr)\n\t\treturn;\n\n\tif (type == PRIMARY_INTERFACE) {\n\t\tepc = epf->epc;\n\t\tepf_bar = epf->bar;\n\t} else {\n\t\tepc = epf->sec_epc;\n\t\tepf_bar = epf->sec_epc_bar;\n\t}\n\n\tdev = epc->dev.parent;\n\tdma_free_coherent(dev, epf_bar[bar].size, addr,\n\t\t\t  epf_bar[bar].phys_addr);\n\n\tepf_bar[bar].phys_addr = 0;\n\tepf_bar[bar].addr = NULL;\n\tepf_bar[bar].size = 0;\n\tepf_bar[bar].barno = 0;\n\tepf_bar[bar].flags = 0;\n}\nEXPORT_SYMBOL_GPL(pci_epf_free_space);\n\n \nvoid *pci_epf_alloc_space(struct pci_epf *epf, size_t size, enum pci_barno bar,\n\t\t\t  size_t align, enum pci_epc_interface_type type)\n{\n\tstruct pci_epf_bar *epf_bar;\n\tdma_addr_t phys_addr;\n\tstruct pci_epc *epc;\n\tstruct device *dev;\n\tvoid *space;\n\n\tif (size < 128)\n\t\tsize = 128;\n\n\tif (align)\n\t\tsize = ALIGN(size, align);\n\telse\n\t\tsize = roundup_pow_of_two(size);\n\n\tif (type == PRIMARY_INTERFACE) {\n\t\tepc = epf->epc;\n\t\tepf_bar = epf->bar;\n\t} else {\n\t\tepc = epf->sec_epc;\n\t\tepf_bar = epf->sec_epc_bar;\n\t}\n\n\tdev = epc->dev.parent;\n\tspace = dma_alloc_coherent(dev, size, &phys_addr, GFP_KERNEL);\n\tif (!space) {\n\t\tdev_err(dev, \"failed to allocate mem space\\n\");\n\t\treturn NULL;\n\t}\n\n\tepf_bar[bar].phys_addr = phys_addr;\n\tepf_bar[bar].addr = space;\n\tepf_bar[bar].size = size;\n\tepf_bar[bar].barno = bar;\n\tepf_bar[bar].flags |= upper_32_bits(size) ?\n\t\t\t\tPCI_BASE_ADDRESS_MEM_TYPE_64 :\n\t\t\t\tPCI_BASE_ADDRESS_MEM_TYPE_32;\n\n\treturn space;\n}\nEXPORT_SYMBOL_GPL(pci_epf_alloc_space);\n\nstatic void pci_epf_remove_cfs(struct pci_epf_driver *driver)\n{\n\tstruct config_group *group, *tmp;\n\n\tif (!IS_ENABLED(CONFIG_PCI_ENDPOINT_CONFIGFS))\n\t\treturn;\n\n\tmutex_lock(&pci_epf_mutex);\n\tlist_for_each_entry_safe(group, tmp, &driver->epf_group, group_entry)\n\t\tpci_ep_cfs_remove_epf_group(group);\n\tlist_del(&driver->epf_group);\n\tmutex_unlock(&pci_epf_mutex);\n}\n\n \nvoid pci_epf_unregister_driver(struct pci_epf_driver *driver)\n{\n\tpci_epf_remove_cfs(driver);\n\tdriver_unregister(&driver->driver);\n}\nEXPORT_SYMBOL_GPL(pci_epf_unregister_driver);\n\nstatic int pci_epf_add_cfs(struct pci_epf_driver *driver)\n{\n\tstruct config_group *group;\n\tconst struct pci_epf_device_id *id;\n\n\tif (!IS_ENABLED(CONFIG_PCI_ENDPOINT_CONFIGFS))\n\t\treturn 0;\n\n\tINIT_LIST_HEAD(&driver->epf_group);\n\n\tid = driver->id_table;\n\twhile (id->name[0]) {\n\t\tgroup = pci_ep_cfs_add_epf_group(id->name);\n\t\tif (IS_ERR(group)) {\n\t\t\tpci_epf_remove_cfs(driver);\n\t\t\treturn PTR_ERR(group);\n\t\t}\n\n\t\tmutex_lock(&pci_epf_mutex);\n\t\tlist_add_tail(&group->group_entry, &driver->epf_group);\n\t\tmutex_unlock(&pci_epf_mutex);\n\t\tid++;\n\t}\n\n\treturn 0;\n}\n\n \nint __pci_epf_register_driver(struct pci_epf_driver *driver,\n\t\t\t      struct module *owner)\n{\n\tint ret;\n\n\tif (!driver->ops)\n\t\treturn -EINVAL;\n\n\tif (!driver->ops->bind || !driver->ops->unbind)\n\t\treturn -EINVAL;\n\n\tdriver->driver.bus = &pci_epf_bus_type;\n\tdriver->driver.owner = owner;\n\n\tret = driver_register(&driver->driver);\n\tif (ret)\n\t\treturn ret;\n\n\tpci_epf_add_cfs(driver);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(__pci_epf_register_driver);\n\n \nvoid pci_epf_destroy(struct pci_epf *epf)\n{\n\tdevice_unregister(&epf->dev);\n}\nEXPORT_SYMBOL_GPL(pci_epf_destroy);\n\n \nstruct pci_epf *pci_epf_create(const char *name)\n{\n\tint ret;\n\tstruct pci_epf *epf;\n\tstruct device *dev;\n\tint len;\n\n\tepf = kzalloc(sizeof(*epf), GFP_KERNEL);\n\tif (!epf)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tlen = strchrnul(name, '.') - name;\n\tepf->name = kstrndup(name, len, GFP_KERNEL);\n\tif (!epf->name) {\n\t\tkfree(epf);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\t \n\tepf->vfunction_num_map = 1;\n\tINIT_LIST_HEAD(&epf->pci_vepf);\n\n\tdev = &epf->dev;\n\tdevice_initialize(dev);\n\tdev->bus = &pci_epf_bus_type;\n\tdev->type = &pci_epf_type;\n\tmutex_init(&epf->lock);\n\n\tret = dev_set_name(dev, \"%s\", name);\n\tif (ret) {\n\t\tput_device(dev);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tret = device_add(dev);\n\tif (ret) {\n\t\tput_device(dev);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn epf;\n}\nEXPORT_SYMBOL_GPL(pci_epf_create);\n\nstatic void pci_epf_dev_release(struct device *dev)\n{\n\tstruct pci_epf *epf = to_pci_epf(dev);\n\n\tkfree(epf->name);\n\tkfree(epf);\n}\n\nstatic const struct device_type pci_epf_type = {\n\t.release\t= pci_epf_dev_release,\n};\n\nstatic const struct pci_epf_device_id *\npci_epf_match_id(const struct pci_epf_device_id *id, const struct pci_epf *epf)\n{\n\twhile (id->name[0]) {\n\t\tif (strcmp(epf->name, id->name) == 0)\n\t\t\treturn id;\n\t\tid++;\n\t}\n\n\treturn NULL;\n}\n\nstatic int pci_epf_device_match(struct device *dev, struct device_driver *drv)\n{\n\tstruct pci_epf *epf = to_pci_epf(dev);\n\tstruct pci_epf_driver *driver = to_pci_epf_driver(drv);\n\n\tif (driver->id_table)\n\t\treturn !!pci_epf_match_id(driver->id_table, epf);\n\n\treturn !strcmp(epf->name, drv->name);\n}\n\nstatic int pci_epf_device_probe(struct device *dev)\n{\n\tstruct pci_epf *epf = to_pci_epf(dev);\n\tstruct pci_epf_driver *driver = to_pci_epf_driver(dev->driver);\n\n\tif (!driver->probe)\n\t\treturn -ENODEV;\n\n\tepf->driver = driver;\n\n\treturn driver->probe(epf, pci_epf_match_id(driver->id_table, epf));\n}\n\nstatic void pci_epf_device_remove(struct device *dev)\n{\n\tstruct pci_epf *epf = to_pci_epf(dev);\n\tstruct pci_epf_driver *driver = to_pci_epf_driver(dev->driver);\n\n\tif (driver->remove)\n\t\tdriver->remove(epf);\n\tepf->driver = NULL;\n}\n\nstatic struct bus_type pci_epf_bus_type = {\n\t.name\t\t= \"pci-epf\",\n\t.match\t\t= pci_epf_device_match,\n\t.probe\t\t= pci_epf_device_probe,\n\t.remove\t\t= pci_epf_device_remove,\n};\n\nstatic int __init pci_epf_init(void)\n{\n\tint ret;\n\n\tret = bus_register(&pci_epf_bus_type);\n\tif (ret) {\n\t\tpr_err(\"failed to register pci epf bus --> %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\nmodule_init(pci_epf_init);\n\nstatic void __exit pci_epf_exit(void)\n{\n\tbus_unregister(&pci_epf_bus_type);\n}\nmodule_exit(pci_epf_exit);\n\nMODULE_DESCRIPTION(\"PCI EPF Library\");\nMODULE_AUTHOR(\"Kishon Vijay Abraham I <kishon@ti.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}