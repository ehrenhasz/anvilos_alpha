{
  "module_name": "pci-ep-cfs.c",
  "hash_id": "acd2f2ea642fe324f39c51ffac3b48552dcabe3175c0b01ac2caedd786ae5fb6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/endpoint/pci-ep-cfs.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n\n#include <linux/pci-epc.h>\n#include <linux/pci-epf.h>\n#include <linux/pci-ep-cfs.h>\n\nstatic DEFINE_IDR(functions_idr);\nstatic DEFINE_MUTEX(functions_mutex);\nstatic struct config_group *functions_group;\nstatic struct config_group *controllers_group;\n\nstruct pci_epf_group {\n\tstruct config_group group;\n\tstruct config_group primary_epc_group;\n\tstruct config_group secondary_epc_group;\n\tstruct config_group *type_group;\n\tstruct delayed_work cfs_work;\n\tstruct pci_epf *epf;\n\tint index;\n};\n\nstruct pci_epc_group {\n\tstruct config_group group;\n\tstruct pci_epc *epc;\n\tbool start;\n};\n\nstatic inline struct pci_epf_group *to_pci_epf_group(struct config_item *item)\n{\n\treturn container_of(to_config_group(item), struct pci_epf_group, group);\n}\n\nstatic inline struct pci_epc_group *to_pci_epc_group(struct config_item *item)\n{\n\treturn container_of(to_config_group(item), struct pci_epc_group, group);\n}\n\nstatic int pci_secondary_epc_epf_link(struct config_item *epf_item,\n\t\t\t\t      struct config_item *epc_item)\n{\n\tint ret;\n\tstruct pci_epf_group *epf_group = to_pci_epf_group(epf_item->ci_parent);\n\tstruct pci_epc_group *epc_group = to_pci_epc_group(epc_item);\n\tstruct pci_epc *epc = epc_group->epc;\n\tstruct pci_epf *epf = epf_group->epf;\n\n\tret = pci_epc_add_epf(epc, epf, SECONDARY_INTERFACE);\n\tif (ret)\n\t\treturn ret;\n\n\tret = pci_epf_bind(epf);\n\tif (ret) {\n\t\tpci_epc_remove_epf(epc, epf, SECONDARY_INTERFACE);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void pci_secondary_epc_epf_unlink(struct config_item *epc_item,\n\t\t\t\t\t struct config_item *epf_item)\n{\n\tstruct pci_epf_group *epf_group = to_pci_epf_group(epf_item->ci_parent);\n\tstruct pci_epc_group *epc_group = to_pci_epc_group(epc_item);\n\tstruct pci_epc *epc;\n\tstruct pci_epf *epf;\n\n\tWARN_ON_ONCE(epc_group->start);\n\n\tepc = epc_group->epc;\n\tepf = epf_group->epf;\n\tpci_epf_unbind(epf);\n\tpci_epc_remove_epf(epc, epf, SECONDARY_INTERFACE);\n}\n\nstatic struct configfs_item_operations pci_secondary_epc_item_ops = {\n\t.allow_link\t= pci_secondary_epc_epf_link,\n\t.drop_link\t= pci_secondary_epc_epf_unlink,\n};\n\nstatic const struct config_item_type pci_secondary_epc_type = {\n\t.ct_item_ops\t= &pci_secondary_epc_item_ops,\n\t.ct_owner\t= THIS_MODULE,\n};\n\nstatic struct config_group\n*pci_ep_cfs_add_secondary_group(struct pci_epf_group *epf_group)\n{\n\tstruct config_group *secondary_epc_group;\n\n\tsecondary_epc_group = &epf_group->secondary_epc_group;\n\tconfig_group_init_type_name(secondary_epc_group, \"secondary\",\n\t\t\t\t    &pci_secondary_epc_type);\n\tconfigfs_register_group(&epf_group->group, secondary_epc_group);\n\n\treturn secondary_epc_group;\n}\n\nstatic int pci_primary_epc_epf_link(struct config_item *epf_item,\n\t\t\t\t    struct config_item *epc_item)\n{\n\tint ret;\n\tstruct pci_epf_group *epf_group = to_pci_epf_group(epf_item->ci_parent);\n\tstruct pci_epc_group *epc_group = to_pci_epc_group(epc_item);\n\tstruct pci_epc *epc = epc_group->epc;\n\tstruct pci_epf *epf = epf_group->epf;\n\n\tret = pci_epc_add_epf(epc, epf, PRIMARY_INTERFACE);\n\tif (ret)\n\t\treturn ret;\n\n\tret = pci_epf_bind(epf);\n\tif (ret) {\n\t\tpci_epc_remove_epf(epc, epf, PRIMARY_INTERFACE);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void pci_primary_epc_epf_unlink(struct config_item *epc_item,\n\t\t\t\t       struct config_item *epf_item)\n{\n\tstruct pci_epf_group *epf_group = to_pci_epf_group(epf_item->ci_parent);\n\tstruct pci_epc_group *epc_group = to_pci_epc_group(epc_item);\n\tstruct pci_epc *epc;\n\tstruct pci_epf *epf;\n\n\tWARN_ON_ONCE(epc_group->start);\n\n\tepc = epc_group->epc;\n\tepf = epf_group->epf;\n\tpci_epf_unbind(epf);\n\tpci_epc_remove_epf(epc, epf, PRIMARY_INTERFACE);\n}\n\nstatic struct configfs_item_operations pci_primary_epc_item_ops = {\n\t.allow_link\t= pci_primary_epc_epf_link,\n\t.drop_link\t= pci_primary_epc_epf_unlink,\n};\n\nstatic const struct config_item_type pci_primary_epc_type = {\n\t.ct_item_ops\t= &pci_primary_epc_item_ops,\n\t.ct_owner\t= THIS_MODULE,\n};\n\nstatic struct config_group\n*pci_ep_cfs_add_primary_group(struct pci_epf_group *epf_group)\n{\n\tstruct config_group *primary_epc_group = &epf_group->primary_epc_group;\n\n\tconfig_group_init_type_name(primary_epc_group, \"primary\",\n\t\t\t\t    &pci_primary_epc_type);\n\tconfigfs_register_group(&epf_group->group, primary_epc_group);\n\n\treturn primary_epc_group;\n}\n\nstatic ssize_t pci_epc_start_store(struct config_item *item, const char *page,\n\t\t\t\t   size_t len)\n{\n\tint ret;\n\tbool start;\n\tstruct pci_epc *epc;\n\tstruct pci_epc_group *epc_group = to_pci_epc_group(item);\n\n\tepc = epc_group->epc;\n\n\tif (kstrtobool(page, &start) < 0)\n\t\treturn -EINVAL;\n\n\tif (start == epc_group->start)\n\t\treturn -EALREADY;\n\n\tif (!start) {\n\t\tpci_epc_stop(epc);\n\t\tepc_group->start = 0;\n\t\treturn len;\n\t}\n\n\tret = pci_epc_start(epc);\n\tif (ret) {\n\t\tdev_err(&epc->dev, \"failed to start endpoint controller\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tepc_group->start = start;\n\n\treturn len;\n}\n\nstatic ssize_t pci_epc_start_show(struct config_item *item, char *page)\n{\n\treturn sysfs_emit(page, \"%d\\n\", to_pci_epc_group(item)->start);\n}\n\nCONFIGFS_ATTR(pci_epc_, start);\n\nstatic struct configfs_attribute *pci_epc_attrs[] = {\n\t&pci_epc_attr_start,\n\tNULL,\n};\n\nstatic int pci_epc_epf_link(struct config_item *epc_item,\n\t\t\t    struct config_item *epf_item)\n{\n\tint ret;\n\tstruct pci_epf_group *epf_group = to_pci_epf_group(epf_item);\n\tstruct pci_epc_group *epc_group = to_pci_epc_group(epc_item);\n\tstruct pci_epc *epc = epc_group->epc;\n\tstruct pci_epf *epf = epf_group->epf;\n\n\tret = pci_epc_add_epf(epc, epf, PRIMARY_INTERFACE);\n\tif (ret)\n\t\treturn ret;\n\n\tret = pci_epf_bind(epf);\n\tif (ret) {\n\t\tpci_epc_remove_epf(epc, epf, PRIMARY_INTERFACE);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void pci_epc_epf_unlink(struct config_item *epc_item,\n\t\t\t       struct config_item *epf_item)\n{\n\tstruct pci_epc *epc;\n\tstruct pci_epf *epf;\n\tstruct pci_epf_group *epf_group = to_pci_epf_group(epf_item);\n\tstruct pci_epc_group *epc_group = to_pci_epc_group(epc_item);\n\n\tWARN_ON_ONCE(epc_group->start);\n\n\tepc = epc_group->epc;\n\tepf = epf_group->epf;\n\tpci_epf_unbind(epf);\n\tpci_epc_remove_epf(epc, epf, PRIMARY_INTERFACE);\n}\n\nstatic struct configfs_item_operations pci_epc_item_ops = {\n\t.allow_link\t= pci_epc_epf_link,\n\t.drop_link\t= pci_epc_epf_unlink,\n};\n\nstatic const struct config_item_type pci_epc_type = {\n\t.ct_item_ops\t= &pci_epc_item_ops,\n\t.ct_attrs\t= pci_epc_attrs,\n\t.ct_owner\t= THIS_MODULE,\n};\n\nstruct config_group *pci_ep_cfs_add_epc_group(const char *name)\n{\n\tint ret;\n\tstruct pci_epc *epc;\n\tstruct config_group *group;\n\tstruct pci_epc_group *epc_group;\n\n\tepc_group = kzalloc(sizeof(*epc_group), GFP_KERNEL);\n\tif (!epc_group) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tgroup = &epc_group->group;\n\n\tconfig_group_init_type_name(group, name, &pci_epc_type);\n\tret = configfs_register_group(controllers_group, group);\n\tif (ret) {\n\t\tpr_err(\"failed to register configfs group for %s\\n\", name);\n\t\tgoto err_register_group;\n\t}\n\n\tepc = pci_epc_get(name);\n\tif (IS_ERR(epc)) {\n\t\tret = PTR_ERR(epc);\n\t\tgoto err_epc_get;\n\t}\n\n\tepc_group->epc = epc;\n\n\treturn group;\n\nerr_epc_get:\n\tconfigfs_unregister_group(group);\n\nerr_register_group:\n\tkfree(epc_group);\n\nerr:\n\treturn ERR_PTR(ret);\n}\nEXPORT_SYMBOL(pci_ep_cfs_add_epc_group);\n\nvoid pci_ep_cfs_remove_epc_group(struct config_group *group)\n{\n\tstruct pci_epc_group *epc_group;\n\n\tif (!group)\n\t\treturn;\n\n\tepc_group = container_of(group, struct pci_epc_group, group);\n\tpci_epc_put(epc_group->epc);\n\tconfigfs_unregister_group(&epc_group->group);\n\tkfree(epc_group);\n}\nEXPORT_SYMBOL(pci_ep_cfs_remove_epc_group);\n\n#define PCI_EPF_HEADER_R(_name)\t\t\t\t\t\t       \\\nstatic ssize_t pci_epf_##_name##_show(struct config_item *item,\tchar *page)    \\\n{\t\t\t\t\t\t\t\t\t       \\\n\tstruct pci_epf *epf = to_pci_epf_group(item)->epf;\t\t       \\\n\tif (WARN_ON_ONCE(!epf->header))\t\t\t\t\t       \\\n\t\treturn -EINVAL;\t\t\t\t\t\t       \\\n\treturn sysfs_emit(page, \"0x%04x\\n\", epf->header->_name);\t       \\\n}\n\n#define PCI_EPF_HEADER_W_u32(_name)\t\t\t\t\t       \\\nstatic ssize_t pci_epf_##_name##_store(struct config_item *item,\t       \\\n\t\t\t\t       const char *page, size_t len)\t       \\\n{\t\t\t\t\t\t\t\t\t       \\\n\tu32 val;\t\t\t\t\t\t\t       \\\n\tstruct pci_epf *epf = to_pci_epf_group(item)->epf;\t\t       \\\n\tif (WARN_ON_ONCE(!epf->header))\t\t\t\t\t       \\\n\t\treturn -EINVAL;\t\t\t\t\t\t       \\\n\tif (kstrtou32(page, 0, &val) < 0)\t\t\t\t       \\\n\t\treturn -EINVAL;\t\t\t\t\t\t       \\\n\tepf->header->_name = val;\t\t\t\t\t       \\\n\treturn len;\t\t\t\t\t\t\t       \\\n}\n\n#define PCI_EPF_HEADER_W_u16(_name)\t\t\t\t\t       \\\nstatic ssize_t pci_epf_##_name##_store(struct config_item *item,\t       \\\n\t\t\t\t       const char *page, size_t len)\t       \\\n{\t\t\t\t\t\t\t\t\t       \\\n\tu16 val;\t\t\t\t\t\t\t       \\\n\tstruct pci_epf *epf = to_pci_epf_group(item)->epf;\t\t       \\\n\tif (WARN_ON_ONCE(!epf->header))\t\t\t\t\t       \\\n\t\treturn -EINVAL;\t\t\t\t\t\t       \\\n\tif (kstrtou16(page, 0, &val) < 0)\t\t\t\t       \\\n\t\treturn -EINVAL;\t\t\t\t\t\t       \\\n\tepf->header->_name = val;\t\t\t\t\t       \\\n\treturn len;\t\t\t\t\t\t\t       \\\n}\n\n#define PCI_EPF_HEADER_W_u8(_name)\t\t\t\t\t       \\\nstatic ssize_t pci_epf_##_name##_store(struct config_item *item,\t       \\\n\t\t\t\t       const char *page, size_t len)\t       \\\n{\t\t\t\t\t\t\t\t\t       \\\n\tu8 val;\t\t\t\t\t\t\t\t       \\\n\tstruct pci_epf *epf = to_pci_epf_group(item)->epf;\t\t       \\\n\tif (WARN_ON_ONCE(!epf->header))\t\t\t\t\t       \\\n\t\treturn -EINVAL;\t\t\t\t\t\t       \\\n\tif (kstrtou8(page, 0, &val) < 0)\t\t\t\t       \\\n\t\treturn -EINVAL;\t\t\t\t\t\t       \\\n\tepf->header->_name = val;\t\t\t\t\t       \\\n\treturn len;\t\t\t\t\t\t\t       \\\n}\n\nstatic ssize_t pci_epf_msi_interrupts_store(struct config_item *item,\n\t\t\t\t\t    const char *page, size_t len)\n{\n\tu8 val;\n\n\tif (kstrtou8(page, 0, &val) < 0)\n\t\treturn -EINVAL;\n\n\tto_pci_epf_group(item)->epf->msi_interrupts = val;\n\n\treturn len;\n}\n\nstatic ssize_t pci_epf_msi_interrupts_show(struct config_item *item,\n\t\t\t\t\t   char *page)\n{\n\treturn sysfs_emit(page, \"%d\\n\",\n\t\t\t  to_pci_epf_group(item)->epf->msi_interrupts);\n}\n\nstatic ssize_t pci_epf_msix_interrupts_store(struct config_item *item,\n\t\t\t\t\t     const char *page, size_t len)\n{\n\tu16 val;\n\n\tif (kstrtou16(page, 0, &val) < 0)\n\t\treturn -EINVAL;\n\n\tto_pci_epf_group(item)->epf->msix_interrupts = val;\n\n\treturn len;\n}\n\nstatic ssize_t pci_epf_msix_interrupts_show(struct config_item *item,\n\t\t\t\t\t    char *page)\n{\n\treturn sysfs_emit(page, \"%d\\n\",\n\t\t\t  to_pci_epf_group(item)->epf->msix_interrupts);\n}\n\nPCI_EPF_HEADER_R(vendorid)\nPCI_EPF_HEADER_W_u16(vendorid)\n\nPCI_EPF_HEADER_R(deviceid)\nPCI_EPF_HEADER_W_u16(deviceid)\n\nPCI_EPF_HEADER_R(revid)\nPCI_EPF_HEADER_W_u8(revid)\n\nPCI_EPF_HEADER_R(progif_code)\nPCI_EPF_HEADER_W_u8(progif_code)\n\nPCI_EPF_HEADER_R(subclass_code)\nPCI_EPF_HEADER_W_u8(subclass_code)\n\nPCI_EPF_HEADER_R(baseclass_code)\nPCI_EPF_HEADER_W_u8(baseclass_code)\n\nPCI_EPF_HEADER_R(cache_line_size)\nPCI_EPF_HEADER_W_u8(cache_line_size)\n\nPCI_EPF_HEADER_R(subsys_vendor_id)\nPCI_EPF_HEADER_W_u16(subsys_vendor_id)\n\nPCI_EPF_HEADER_R(subsys_id)\nPCI_EPF_HEADER_W_u16(subsys_id)\n\nPCI_EPF_HEADER_R(interrupt_pin)\nPCI_EPF_HEADER_W_u8(interrupt_pin)\n\nCONFIGFS_ATTR(pci_epf_, vendorid);\nCONFIGFS_ATTR(pci_epf_, deviceid);\nCONFIGFS_ATTR(pci_epf_, revid);\nCONFIGFS_ATTR(pci_epf_, progif_code);\nCONFIGFS_ATTR(pci_epf_, subclass_code);\nCONFIGFS_ATTR(pci_epf_, baseclass_code);\nCONFIGFS_ATTR(pci_epf_, cache_line_size);\nCONFIGFS_ATTR(pci_epf_, subsys_vendor_id);\nCONFIGFS_ATTR(pci_epf_, subsys_id);\nCONFIGFS_ATTR(pci_epf_, interrupt_pin);\nCONFIGFS_ATTR(pci_epf_, msi_interrupts);\nCONFIGFS_ATTR(pci_epf_, msix_interrupts);\n\nstatic struct configfs_attribute *pci_epf_attrs[] = {\n\t&pci_epf_attr_vendorid,\n\t&pci_epf_attr_deviceid,\n\t&pci_epf_attr_revid,\n\t&pci_epf_attr_progif_code,\n\t&pci_epf_attr_subclass_code,\n\t&pci_epf_attr_baseclass_code,\n\t&pci_epf_attr_cache_line_size,\n\t&pci_epf_attr_subsys_vendor_id,\n\t&pci_epf_attr_subsys_id,\n\t&pci_epf_attr_interrupt_pin,\n\t&pci_epf_attr_msi_interrupts,\n\t&pci_epf_attr_msix_interrupts,\n\tNULL,\n};\n\nstatic int pci_epf_vepf_link(struct config_item *epf_pf_item,\n\t\t\t     struct config_item *epf_vf_item)\n{\n\tstruct pci_epf_group *epf_vf_group = to_pci_epf_group(epf_vf_item);\n\tstruct pci_epf_group *epf_pf_group = to_pci_epf_group(epf_pf_item);\n\tstruct pci_epf *epf_pf = epf_pf_group->epf;\n\tstruct pci_epf *epf_vf = epf_vf_group->epf;\n\n\treturn pci_epf_add_vepf(epf_pf, epf_vf);\n}\n\nstatic void pci_epf_vepf_unlink(struct config_item *epf_pf_item,\n\t\t\t\tstruct config_item *epf_vf_item)\n{\n\tstruct pci_epf_group *epf_vf_group = to_pci_epf_group(epf_vf_item);\n\tstruct pci_epf_group *epf_pf_group = to_pci_epf_group(epf_pf_item);\n\tstruct pci_epf *epf_pf = epf_pf_group->epf;\n\tstruct pci_epf *epf_vf = epf_vf_group->epf;\n\n\tpci_epf_remove_vepf(epf_pf, epf_vf);\n}\n\nstatic void pci_epf_release(struct config_item *item)\n{\n\tstruct pci_epf_group *epf_group = to_pci_epf_group(item);\n\n\tmutex_lock(&functions_mutex);\n\tidr_remove(&functions_idr, epf_group->index);\n\tmutex_unlock(&functions_mutex);\n\tpci_epf_destroy(epf_group->epf);\n\tkfree(epf_group);\n}\n\nstatic struct configfs_item_operations pci_epf_ops = {\n\t.allow_link\t\t= pci_epf_vepf_link,\n\t.drop_link\t\t= pci_epf_vepf_unlink,\n\t.release\t\t= pci_epf_release,\n};\n\nstatic const struct config_item_type pci_epf_type = {\n\t.ct_item_ops\t= &pci_epf_ops,\n\t.ct_attrs\t= pci_epf_attrs,\n\t.ct_owner\t= THIS_MODULE,\n};\n\n \nstatic struct config_group *pci_epf_type_add_cfs(struct pci_epf *epf,\n\t\t\t\t\t\t struct config_group *group)\n{\n\tstruct config_group *epf_type_group;\n\n\tif (!epf->driver) {\n\t\tdev_err(&epf->dev, \"epf device not bound to driver\\n\");\n\t\treturn ERR_PTR(-ENODEV);\n\t}\n\n\tif (!epf->driver->ops->add_cfs)\n\t\treturn NULL;\n\n\tmutex_lock(&epf->lock);\n\tepf_type_group = epf->driver->ops->add_cfs(epf, group);\n\tmutex_unlock(&epf->lock);\n\n\treturn epf_type_group;\n}\n\nstatic void pci_ep_cfs_add_type_group(struct pci_epf_group *epf_group)\n{\n\tstruct config_group *group;\n\n\tgroup = pci_epf_type_add_cfs(epf_group->epf, &epf_group->group);\n\tif (!group)\n\t\treturn;\n\n\tif (IS_ERR(group)) {\n\t\tdev_err(&epf_group->epf->dev,\n\t\t\t\"failed to create epf type specific attributes\\n\");\n\t\treturn;\n\t}\n\n\tconfigfs_register_group(&epf_group->group, group);\n}\n\nstatic void pci_epf_cfs_work(struct work_struct *work)\n{\n\tstruct pci_epf_group *epf_group;\n\tstruct config_group *group;\n\n\tepf_group = container_of(work, struct pci_epf_group, cfs_work.work);\n\tgroup = pci_ep_cfs_add_primary_group(epf_group);\n\tif (IS_ERR(group)) {\n\t\tpr_err(\"failed to create 'primary' EPC interface\\n\");\n\t\treturn;\n\t}\n\n\tgroup = pci_ep_cfs_add_secondary_group(epf_group);\n\tif (IS_ERR(group)) {\n\t\tpr_err(\"failed to create 'secondary' EPC interface\\n\");\n\t\treturn;\n\t}\n\n\tpci_ep_cfs_add_type_group(epf_group);\n}\n\nstatic struct config_group *pci_epf_make(struct config_group *group,\n\t\t\t\t\t const char *name)\n{\n\tstruct pci_epf_group *epf_group;\n\tstruct pci_epf *epf;\n\tchar *epf_name;\n\tint index, err;\n\n\tepf_group = kzalloc(sizeof(*epf_group), GFP_KERNEL);\n\tif (!epf_group)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmutex_lock(&functions_mutex);\n\tindex = idr_alloc(&functions_idr, epf_group, 0, 0, GFP_KERNEL);\n\tmutex_unlock(&functions_mutex);\n\tif (index < 0) {\n\t\terr = index;\n\t\tgoto free_group;\n\t}\n\n\tepf_group->index = index;\n\n\tconfig_group_init_type_name(&epf_group->group, name, &pci_epf_type);\n\n\tepf_name = kasprintf(GFP_KERNEL, \"%s.%d\",\n\t\t\t     group->cg_item.ci_name, epf_group->index);\n\tif (!epf_name) {\n\t\terr = -ENOMEM;\n\t\tgoto remove_idr;\n\t}\n\n\tepf = pci_epf_create(epf_name);\n\tif (IS_ERR(epf)) {\n\t\tpr_err(\"failed to create endpoint function device\\n\");\n\t\terr = -EINVAL;\n\t\tgoto free_name;\n\t}\n\n\tepf->group = &epf_group->group;\n\tepf_group->epf = epf;\n\n\tkfree(epf_name);\n\n\tINIT_DELAYED_WORK(&epf_group->cfs_work, pci_epf_cfs_work);\n\tqueue_delayed_work(system_wq, &epf_group->cfs_work,\n\t\t\t   msecs_to_jiffies(1));\n\n\treturn &epf_group->group;\n\nfree_name:\n\tkfree(epf_name);\n\nremove_idr:\n\tmutex_lock(&functions_mutex);\n\tidr_remove(&functions_idr, epf_group->index);\n\tmutex_unlock(&functions_mutex);\n\nfree_group:\n\tkfree(epf_group);\n\n\treturn ERR_PTR(err);\n}\n\nstatic void pci_epf_drop(struct config_group *group, struct config_item *item)\n{\n\tconfig_item_put(item);\n}\n\nstatic struct configfs_group_operations pci_epf_group_ops = {\n\t.make_group     = &pci_epf_make,\n\t.drop_item      = &pci_epf_drop,\n};\n\nstatic const struct config_item_type pci_epf_group_type = {\n\t.ct_group_ops\t= &pci_epf_group_ops,\n\t.ct_owner\t= THIS_MODULE,\n};\n\nstruct config_group *pci_ep_cfs_add_epf_group(const char *name)\n{\n\tstruct config_group *group;\n\n\tgroup = configfs_register_default_group(functions_group, name,\n\t\t\t\t\t\t&pci_epf_group_type);\n\tif (IS_ERR(group))\n\t\tpr_err(\"failed to register configfs group for %s function\\n\",\n\t\t       name);\n\n\treturn group;\n}\nEXPORT_SYMBOL(pci_ep_cfs_add_epf_group);\n\nvoid pci_ep_cfs_remove_epf_group(struct config_group *group)\n{\n\tif (IS_ERR_OR_NULL(group))\n\t\treturn;\n\n\tconfigfs_unregister_default_group(group);\n}\nEXPORT_SYMBOL(pci_ep_cfs_remove_epf_group);\n\nstatic const struct config_item_type pci_functions_type = {\n\t.ct_owner\t= THIS_MODULE,\n};\n\nstatic const struct config_item_type pci_controllers_type = {\n\t.ct_owner\t= THIS_MODULE,\n};\n\nstatic const struct config_item_type pci_ep_type = {\n\t.ct_owner\t= THIS_MODULE,\n};\n\nstatic struct configfs_subsystem pci_ep_cfs_subsys = {\n\t.su_group = {\n\t\t.cg_item = {\n\t\t\t.ci_namebuf = \"pci_ep\",\n\t\t\t.ci_type = &pci_ep_type,\n\t\t},\n\t},\n\t.su_mutex = __MUTEX_INITIALIZER(pci_ep_cfs_subsys.su_mutex),\n};\n\nstatic int __init pci_ep_cfs_init(void)\n{\n\tint ret;\n\tstruct config_group *root = &pci_ep_cfs_subsys.su_group;\n\n\tconfig_group_init(root);\n\n\tret = configfs_register_subsystem(&pci_ep_cfs_subsys);\n\tif (ret) {\n\t\tpr_err(\"Error %d while registering subsystem %s\\n\",\n\t\t       ret, root->cg_item.ci_namebuf);\n\t\tgoto err;\n\t}\n\n\tfunctions_group = configfs_register_default_group(root, \"functions\",\n\t\t\t\t\t\t\t  &pci_functions_type);\n\tif (IS_ERR(functions_group)) {\n\t\tret = PTR_ERR(functions_group);\n\t\tpr_err(\"Error %d while registering functions group\\n\",\n\t\t       ret);\n\t\tgoto err_functions_group;\n\t}\n\n\tcontrollers_group =\n\t\tconfigfs_register_default_group(root, \"controllers\",\n\t\t\t\t\t\t&pci_controllers_type);\n\tif (IS_ERR(controllers_group)) {\n\t\tret = PTR_ERR(controllers_group);\n\t\tpr_err(\"Error %d while registering controllers group\\n\",\n\t\t       ret);\n\t\tgoto err_controllers_group;\n\t}\n\n\treturn 0;\n\nerr_controllers_group:\n\tconfigfs_unregister_default_group(functions_group);\n\nerr_functions_group:\n\tconfigfs_unregister_subsystem(&pci_ep_cfs_subsys);\n\nerr:\n\treturn ret;\n}\nmodule_init(pci_ep_cfs_init);\n\nstatic void __exit pci_ep_cfs_exit(void)\n{\n\tconfigfs_unregister_default_group(controllers_group);\n\tconfigfs_unregister_default_group(functions_group);\n\tconfigfs_unregister_subsystem(&pci_ep_cfs_subsys);\n}\nmodule_exit(pci_ep_cfs_exit);\n\nMODULE_DESCRIPTION(\"PCI EP CONFIGFS\");\nMODULE_AUTHOR(\"Kishon Vijay Abraham I <kishon@ti.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}