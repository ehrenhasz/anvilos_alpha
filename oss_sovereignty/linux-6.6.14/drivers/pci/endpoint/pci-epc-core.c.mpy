{
  "module_name": "pci-epc-core.c",
  "hash_id": "e7dc9b04fa4ed0f66167c4bd7ed6831c871128408183fcae8df55d8cee19e685",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/endpoint/pci-epc-core.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\n#include <linux/pci-epc.h>\n#include <linux/pci-epf.h>\n#include <linux/pci-ep-cfs.h>\n\nstatic struct class *pci_epc_class;\n\nstatic void devm_pci_epc_release(struct device *dev, void *res)\n{\n\tstruct pci_epc *epc = *(struct pci_epc **)res;\n\n\tpci_epc_destroy(epc);\n}\n\nstatic int devm_pci_epc_match(struct device *dev, void *res, void *match_data)\n{\n\tstruct pci_epc **epc = res;\n\n\treturn *epc == match_data;\n}\n\n \nvoid pci_epc_put(struct pci_epc *epc)\n{\n\tif (!epc || IS_ERR(epc))\n\t\treturn;\n\n\tmodule_put(epc->ops->owner);\n\tput_device(&epc->dev);\n}\nEXPORT_SYMBOL_GPL(pci_epc_put);\n\n \nstruct pci_epc *pci_epc_get(const char *epc_name)\n{\n\tint ret = -EINVAL;\n\tstruct pci_epc *epc;\n\tstruct device *dev;\n\tstruct class_dev_iter iter;\n\n\tclass_dev_iter_init(&iter, pci_epc_class, NULL, NULL);\n\twhile ((dev = class_dev_iter_next(&iter))) {\n\t\tif (strcmp(epc_name, dev_name(dev)))\n\t\t\tcontinue;\n\n\t\tepc = to_pci_epc(dev);\n\t\tif (!try_module_get(epc->ops->owner)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\n\t\tclass_dev_iter_exit(&iter);\n\t\tget_device(&epc->dev);\n\t\treturn epc;\n\t}\n\nerr:\n\tclass_dev_iter_exit(&iter);\n\treturn ERR_PTR(ret);\n}\nEXPORT_SYMBOL_GPL(pci_epc_get);\n\n \nenum pci_barno\npci_epc_get_first_free_bar(const struct pci_epc_features *epc_features)\n{\n\treturn pci_epc_get_next_free_bar(epc_features, BAR_0);\n}\nEXPORT_SYMBOL_GPL(pci_epc_get_first_free_bar);\n\n \nenum pci_barno pci_epc_get_next_free_bar(const struct pci_epc_features\n\t\t\t\t\t *epc_features, enum pci_barno bar)\n{\n\tunsigned long free_bar;\n\n\tif (!epc_features)\n\t\treturn BAR_0;\n\n\t \n\tif ((epc_features->bar_fixed_64bit << 1) & 1 << bar)\n\t\tbar++;\n\n\t \n\tfree_bar = epc_features->reserved_bar & epc_features->bar_fixed_64bit;\n\n\t \n\tfree_bar <<= 1;\n\tfree_bar |= epc_features->reserved_bar;\n\n\tfree_bar = find_next_zero_bit(&free_bar, 6, bar);\n\tif (free_bar > 5)\n\t\treturn NO_BAR;\n\n\treturn free_bar;\n}\nEXPORT_SYMBOL_GPL(pci_epc_get_next_free_bar);\n\n \nconst struct pci_epc_features *pci_epc_get_features(struct pci_epc *epc,\n\t\t\t\t\t\t    u8 func_no, u8 vfunc_no)\n{\n\tconst struct pci_epc_features *epc_features;\n\n\tif (IS_ERR_OR_NULL(epc) || func_no >= epc->max_functions)\n\t\treturn NULL;\n\n\tif (vfunc_no > 0 && (!epc->max_vfs || vfunc_no > epc->max_vfs[func_no]))\n\t\treturn NULL;\n\n\tif (!epc->ops->get_features)\n\t\treturn NULL;\n\n\tmutex_lock(&epc->lock);\n\tepc_features = epc->ops->get_features(epc, func_no, vfunc_no);\n\tmutex_unlock(&epc->lock);\n\n\treturn epc_features;\n}\nEXPORT_SYMBOL_GPL(pci_epc_get_features);\n\n \nvoid pci_epc_stop(struct pci_epc *epc)\n{\n\tif (IS_ERR(epc) || !epc->ops->stop)\n\t\treturn;\n\n\tmutex_lock(&epc->lock);\n\tepc->ops->stop(epc);\n\tmutex_unlock(&epc->lock);\n}\nEXPORT_SYMBOL_GPL(pci_epc_stop);\n\n \nint pci_epc_start(struct pci_epc *epc)\n{\n\tint ret;\n\n\tif (IS_ERR(epc))\n\t\treturn -EINVAL;\n\n\tif (!epc->ops->start)\n\t\treturn 0;\n\n\tmutex_lock(&epc->lock);\n\tret = epc->ops->start(epc);\n\tmutex_unlock(&epc->lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(pci_epc_start);\n\n \nint pci_epc_raise_irq(struct pci_epc *epc, u8 func_no, u8 vfunc_no,\n\t\t      enum pci_epc_irq_type type, u16 interrupt_num)\n{\n\tint ret;\n\n\tif (IS_ERR_OR_NULL(epc) || func_no >= epc->max_functions)\n\t\treturn -EINVAL;\n\n\tif (vfunc_no > 0 && (!epc->max_vfs || vfunc_no > epc->max_vfs[func_no]))\n\t\treturn -EINVAL;\n\n\tif (!epc->ops->raise_irq)\n\t\treturn 0;\n\n\tmutex_lock(&epc->lock);\n\tret = epc->ops->raise_irq(epc, func_no, vfunc_no, type, interrupt_num);\n\tmutex_unlock(&epc->lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(pci_epc_raise_irq);\n\n \nint pci_epc_map_msi_irq(struct pci_epc *epc, u8 func_no, u8 vfunc_no,\n\t\t\tphys_addr_t phys_addr, u8 interrupt_num, u32 entry_size,\n\t\t\tu32 *msi_data, u32 *msi_addr_offset)\n{\n\tint ret;\n\n\tif (IS_ERR_OR_NULL(epc))\n\t\treturn -EINVAL;\n\n\tif (vfunc_no > 0 && (!epc->max_vfs || vfunc_no > epc->max_vfs[func_no]))\n\t\treturn -EINVAL;\n\n\tif (!epc->ops->map_msi_irq)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&epc->lock);\n\tret = epc->ops->map_msi_irq(epc, func_no, vfunc_no, phys_addr,\n\t\t\t\t    interrupt_num, entry_size, msi_data,\n\t\t\t\t    msi_addr_offset);\n\tmutex_unlock(&epc->lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(pci_epc_map_msi_irq);\n\n \nint pci_epc_get_msi(struct pci_epc *epc, u8 func_no, u8 vfunc_no)\n{\n\tint interrupt;\n\n\tif (IS_ERR_OR_NULL(epc) || func_no >= epc->max_functions)\n\t\treturn 0;\n\n\tif (vfunc_no > 0 && (!epc->max_vfs || vfunc_no > epc->max_vfs[func_no]))\n\t\treturn 0;\n\n\tif (!epc->ops->get_msi)\n\t\treturn 0;\n\n\tmutex_lock(&epc->lock);\n\tinterrupt = epc->ops->get_msi(epc, func_no, vfunc_no);\n\tmutex_unlock(&epc->lock);\n\n\tif (interrupt < 0)\n\t\treturn 0;\n\n\tinterrupt = 1 << interrupt;\n\n\treturn interrupt;\n}\nEXPORT_SYMBOL_GPL(pci_epc_get_msi);\n\n \nint pci_epc_set_msi(struct pci_epc *epc, u8 func_no, u8 vfunc_no, u8 interrupts)\n{\n\tint ret;\n\tu8 encode_int;\n\n\tif (IS_ERR_OR_NULL(epc) || func_no >= epc->max_functions ||\n\t    interrupts < 1 || interrupts > 32)\n\t\treturn -EINVAL;\n\n\tif (vfunc_no > 0 && (!epc->max_vfs || vfunc_no > epc->max_vfs[func_no]))\n\t\treturn -EINVAL;\n\n\tif (!epc->ops->set_msi)\n\t\treturn 0;\n\n\tencode_int = order_base_2(interrupts);\n\n\tmutex_lock(&epc->lock);\n\tret = epc->ops->set_msi(epc, func_no, vfunc_no, encode_int);\n\tmutex_unlock(&epc->lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(pci_epc_set_msi);\n\n \nint pci_epc_get_msix(struct pci_epc *epc, u8 func_no, u8 vfunc_no)\n{\n\tint interrupt;\n\n\tif (IS_ERR_OR_NULL(epc) || func_no >= epc->max_functions)\n\t\treturn 0;\n\n\tif (vfunc_no > 0 && (!epc->max_vfs || vfunc_no > epc->max_vfs[func_no]))\n\t\treturn 0;\n\n\tif (!epc->ops->get_msix)\n\t\treturn 0;\n\n\tmutex_lock(&epc->lock);\n\tinterrupt = epc->ops->get_msix(epc, func_no, vfunc_no);\n\tmutex_unlock(&epc->lock);\n\n\tif (interrupt < 0)\n\t\treturn 0;\n\n\treturn interrupt + 1;\n}\nEXPORT_SYMBOL_GPL(pci_epc_get_msix);\n\n \nint pci_epc_set_msix(struct pci_epc *epc, u8 func_no, u8 vfunc_no,\n\t\t     u16 interrupts, enum pci_barno bir, u32 offset)\n{\n\tint ret;\n\n\tif (IS_ERR_OR_NULL(epc) || func_no >= epc->max_functions ||\n\t    interrupts < 1 || interrupts > 2048)\n\t\treturn -EINVAL;\n\n\tif (vfunc_no > 0 && (!epc->max_vfs || vfunc_no > epc->max_vfs[func_no]))\n\t\treturn -EINVAL;\n\n\tif (!epc->ops->set_msix)\n\t\treturn 0;\n\n\tmutex_lock(&epc->lock);\n\tret = epc->ops->set_msix(epc, func_no, vfunc_no, interrupts - 1, bir,\n\t\t\t\t offset);\n\tmutex_unlock(&epc->lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(pci_epc_set_msix);\n\n \nvoid pci_epc_unmap_addr(struct pci_epc *epc, u8 func_no, u8 vfunc_no,\n\t\t\tphys_addr_t phys_addr)\n{\n\tif (IS_ERR_OR_NULL(epc) || func_no >= epc->max_functions)\n\t\treturn;\n\n\tif (vfunc_no > 0 && (!epc->max_vfs || vfunc_no > epc->max_vfs[func_no]))\n\t\treturn;\n\n\tif (!epc->ops->unmap_addr)\n\t\treturn;\n\n\tmutex_lock(&epc->lock);\n\tepc->ops->unmap_addr(epc, func_no, vfunc_no, phys_addr);\n\tmutex_unlock(&epc->lock);\n}\nEXPORT_SYMBOL_GPL(pci_epc_unmap_addr);\n\n \nint pci_epc_map_addr(struct pci_epc *epc, u8 func_no, u8 vfunc_no,\n\t\t     phys_addr_t phys_addr, u64 pci_addr, size_t size)\n{\n\tint ret;\n\n\tif (IS_ERR_OR_NULL(epc) || func_no >= epc->max_functions)\n\t\treturn -EINVAL;\n\n\tif (vfunc_no > 0 && (!epc->max_vfs || vfunc_no > epc->max_vfs[func_no]))\n\t\treturn -EINVAL;\n\n\tif (!epc->ops->map_addr)\n\t\treturn 0;\n\n\tmutex_lock(&epc->lock);\n\tret = epc->ops->map_addr(epc, func_no, vfunc_no, phys_addr, pci_addr,\n\t\t\t\t size);\n\tmutex_unlock(&epc->lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(pci_epc_map_addr);\n\n \nvoid pci_epc_clear_bar(struct pci_epc *epc, u8 func_no, u8 vfunc_no,\n\t\t       struct pci_epf_bar *epf_bar)\n{\n\tif (IS_ERR_OR_NULL(epc) || func_no >= epc->max_functions ||\n\t    (epf_bar->barno == BAR_5 &&\n\t     epf_bar->flags & PCI_BASE_ADDRESS_MEM_TYPE_64))\n\t\treturn;\n\n\tif (vfunc_no > 0 && (!epc->max_vfs || vfunc_no > epc->max_vfs[func_no]))\n\t\treturn;\n\n\tif (!epc->ops->clear_bar)\n\t\treturn;\n\n\tmutex_lock(&epc->lock);\n\tepc->ops->clear_bar(epc, func_no, vfunc_no, epf_bar);\n\tmutex_unlock(&epc->lock);\n}\nEXPORT_SYMBOL_GPL(pci_epc_clear_bar);\n\n \nint pci_epc_set_bar(struct pci_epc *epc, u8 func_no, u8 vfunc_no,\n\t\t    struct pci_epf_bar *epf_bar)\n{\n\tint ret;\n\tint flags = epf_bar->flags;\n\n\tif (IS_ERR_OR_NULL(epc) || func_no >= epc->max_functions ||\n\t    (epf_bar->barno == BAR_5 &&\n\t     flags & PCI_BASE_ADDRESS_MEM_TYPE_64) ||\n\t    (flags & PCI_BASE_ADDRESS_SPACE_IO &&\n\t     flags & PCI_BASE_ADDRESS_IO_MASK) ||\n\t    (upper_32_bits(epf_bar->size) &&\n\t     !(flags & PCI_BASE_ADDRESS_MEM_TYPE_64)))\n\t\treturn -EINVAL;\n\n\tif (vfunc_no > 0 && (!epc->max_vfs || vfunc_no > epc->max_vfs[func_no]))\n\t\treturn -EINVAL;\n\n\tif (!epc->ops->set_bar)\n\t\treturn 0;\n\n\tmutex_lock(&epc->lock);\n\tret = epc->ops->set_bar(epc, func_no, vfunc_no, epf_bar);\n\tmutex_unlock(&epc->lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(pci_epc_set_bar);\n\n \nint pci_epc_write_header(struct pci_epc *epc, u8 func_no, u8 vfunc_no,\n\t\t\t struct pci_epf_header *header)\n{\n\tint ret;\n\n\tif (IS_ERR_OR_NULL(epc) || func_no >= epc->max_functions)\n\t\treturn -EINVAL;\n\n\tif (vfunc_no > 0 && (!epc->max_vfs || vfunc_no > epc->max_vfs[func_no]))\n\t\treturn -EINVAL;\n\n\t \n\tif (vfunc_no > 1)\n\t\treturn -EINVAL;\n\n\tif (!epc->ops->write_header)\n\t\treturn 0;\n\n\tmutex_lock(&epc->lock);\n\tret = epc->ops->write_header(epc, func_no, vfunc_no, header);\n\tmutex_unlock(&epc->lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(pci_epc_write_header);\n\n \nint pci_epc_add_epf(struct pci_epc *epc, struct pci_epf *epf,\n\t\t    enum pci_epc_interface_type type)\n{\n\tstruct list_head *list;\n\tu32 func_no;\n\tint ret = 0;\n\n\tif (IS_ERR_OR_NULL(epc) || epf->is_vf)\n\t\treturn -EINVAL;\n\n\tif (type == PRIMARY_INTERFACE && epf->epc)\n\t\treturn -EBUSY;\n\n\tif (type == SECONDARY_INTERFACE && epf->sec_epc)\n\t\treturn -EBUSY;\n\n\tmutex_lock(&epc->list_lock);\n\tfunc_no = find_first_zero_bit(&epc->function_num_map,\n\t\t\t\t      BITS_PER_LONG);\n\tif (func_no >= BITS_PER_LONG) {\n\t\tret = -EINVAL;\n\t\tgoto ret;\n\t}\n\n\tif (func_no > epc->max_functions - 1) {\n\t\tdev_err(&epc->dev, \"Exceeding max supported Function Number\\n\");\n\t\tret = -EINVAL;\n\t\tgoto ret;\n\t}\n\n\tset_bit(func_no, &epc->function_num_map);\n\tif (type == PRIMARY_INTERFACE) {\n\t\tepf->func_no = func_no;\n\t\tepf->epc = epc;\n\t\tlist = &epf->list;\n\t} else {\n\t\tepf->sec_epc_func_no = func_no;\n\t\tepf->sec_epc = epc;\n\t\tlist = &epf->sec_epc_list;\n\t}\n\n\tlist_add_tail(list, &epc->pci_epf);\nret:\n\tmutex_unlock(&epc->list_lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(pci_epc_add_epf);\n\n \nvoid pci_epc_remove_epf(struct pci_epc *epc, struct pci_epf *epf,\n\t\t\tenum pci_epc_interface_type type)\n{\n\tstruct list_head *list;\n\tu32 func_no = 0;\n\n\tif (!epc || IS_ERR(epc) || !epf)\n\t\treturn;\n\n\tif (type == PRIMARY_INTERFACE) {\n\t\tfunc_no = epf->func_no;\n\t\tlist = &epf->list;\n\t} else {\n\t\tfunc_no = epf->sec_epc_func_no;\n\t\tlist = &epf->sec_epc_list;\n\t}\n\n\tmutex_lock(&epc->list_lock);\n\tclear_bit(func_no, &epc->function_num_map);\n\tlist_del(list);\n\tepf->epc = NULL;\n\tmutex_unlock(&epc->list_lock);\n}\nEXPORT_SYMBOL_GPL(pci_epc_remove_epf);\n\n \nvoid pci_epc_linkup(struct pci_epc *epc)\n{\n\tstruct pci_epf *epf;\n\n\tif (!epc || IS_ERR(epc))\n\t\treturn;\n\n\tmutex_lock(&epc->list_lock);\n\tlist_for_each_entry(epf, &epc->pci_epf, list) {\n\t\tmutex_lock(&epf->lock);\n\t\tif (epf->event_ops && epf->event_ops->link_up)\n\t\t\tepf->event_ops->link_up(epf);\n\t\tmutex_unlock(&epf->lock);\n\t}\n\tmutex_unlock(&epc->list_lock);\n}\nEXPORT_SYMBOL_GPL(pci_epc_linkup);\n\n \nvoid pci_epc_linkdown(struct pci_epc *epc)\n{\n\tstruct pci_epf *epf;\n\n\tif (!epc || IS_ERR(epc))\n\t\treturn;\n\n\tmutex_lock(&epc->list_lock);\n\tlist_for_each_entry(epf, &epc->pci_epf, list) {\n\t\tmutex_lock(&epf->lock);\n\t\tif (epf->event_ops && epf->event_ops->link_down)\n\t\t\tepf->event_ops->link_down(epf);\n\t\tmutex_unlock(&epf->lock);\n\t}\n\tmutex_unlock(&epc->list_lock);\n}\nEXPORT_SYMBOL_GPL(pci_epc_linkdown);\n\n \nvoid pci_epc_init_notify(struct pci_epc *epc)\n{\n\tstruct pci_epf *epf;\n\n\tif (!epc || IS_ERR(epc))\n\t\treturn;\n\n\tmutex_lock(&epc->list_lock);\n\tlist_for_each_entry(epf, &epc->pci_epf, list) {\n\t\tmutex_lock(&epf->lock);\n\t\tif (epf->event_ops && epf->event_ops->core_init)\n\t\t\tepf->event_ops->core_init(epf);\n\t\tmutex_unlock(&epf->lock);\n\t}\n\tmutex_unlock(&epc->list_lock);\n}\nEXPORT_SYMBOL_GPL(pci_epc_init_notify);\n\n \nvoid pci_epc_bme_notify(struct pci_epc *epc)\n{\n\tstruct pci_epf *epf;\n\n\tif (!epc || IS_ERR(epc))\n\t\treturn;\n\n\tmutex_lock(&epc->list_lock);\n\tlist_for_each_entry(epf, &epc->pci_epf, list) {\n\t\tmutex_lock(&epf->lock);\n\t\tif (epf->event_ops && epf->event_ops->bme)\n\t\t\tepf->event_ops->bme(epf);\n\t\tmutex_unlock(&epf->lock);\n\t}\n\tmutex_unlock(&epc->list_lock);\n}\nEXPORT_SYMBOL_GPL(pci_epc_bme_notify);\n\n \nvoid pci_epc_destroy(struct pci_epc *epc)\n{\n\tpci_ep_cfs_remove_epc_group(epc->group);\n\tdevice_unregister(&epc->dev);\n}\nEXPORT_SYMBOL_GPL(pci_epc_destroy);\n\n \nvoid devm_pci_epc_destroy(struct device *dev, struct pci_epc *epc)\n{\n\tint r;\n\n\tr = devres_destroy(dev, devm_pci_epc_release, devm_pci_epc_match,\n\t\t\t   epc);\n\tdev_WARN_ONCE(dev, r, \"couldn't find PCI EPC resource\\n\");\n}\nEXPORT_SYMBOL_GPL(devm_pci_epc_destroy);\n\nstatic void pci_epc_release(struct device *dev)\n{\n\tkfree(to_pci_epc(dev));\n}\n\n \nstruct pci_epc *\n__pci_epc_create(struct device *dev, const struct pci_epc_ops *ops,\n\t\t struct module *owner)\n{\n\tint ret;\n\tstruct pci_epc *epc;\n\n\tif (WARN_ON(!dev)) {\n\t\tret = -EINVAL;\n\t\tgoto err_ret;\n\t}\n\n\tepc = kzalloc(sizeof(*epc), GFP_KERNEL);\n\tif (!epc) {\n\t\tret = -ENOMEM;\n\t\tgoto err_ret;\n\t}\n\n\tmutex_init(&epc->lock);\n\tmutex_init(&epc->list_lock);\n\tINIT_LIST_HEAD(&epc->pci_epf);\n\n\tdevice_initialize(&epc->dev);\n\tepc->dev.class = pci_epc_class;\n\tepc->dev.parent = dev;\n\tepc->dev.release = pci_epc_release;\n\tepc->ops = ops;\n\n\tret = dev_set_name(&epc->dev, \"%s\", dev_name(dev));\n\tif (ret)\n\t\tgoto put_dev;\n\n\tret = device_add(&epc->dev);\n\tif (ret)\n\t\tgoto put_dev;\n\n\tepc->group = pci_ep_cfs_add_epc_group(dev_name(dev));\n\n\treturn epc;\n\nput_dev:\n\tput_device(&epc->dev);\n\nerr_ret:\n\treturn ERR_PTR(ret);\n}\nEXPORT_SYMBOL_GPL(__pci_epc_create);\n\n \nstruct pci_epc *\n__devm_pci_epc_create(struct device *dev, const struct pci_epc_ops *ops,\n\t\t      struct module *owner)\n{\n\tstruct pci_epc **ptr, *epc;\n\n\tptr = devres_alloc(devm_pci_epc_release, sizeof(*ptr), GFP_KERNEL);\n\tif (!ptr)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tepc = __pci_epc_create(dev, ops, owner);\n\tif (!IS_ERR(epc)) {\n\t\t*ptr = epc;\n\t\tdevres_add(dev, ptr);\n\t} else {\n\t\tdevres_free(ptr);\n\t}\n\n\treturn epc;\n}\nEXPORT_SYMBOL_GPL(__devm_pci_epc_create);\n\nstatic int __init pci_epc_init(void)\n{\n\tpci_epc_class = class_create(\"pci_epc\");\n\tif (IS_ERR(pci_epc_class)) {\n\t\tpr_err(\"failed to create pci epc class --> %ld\\n\",\n\t\t       PTR_ERR(pci_epc_class));\n\t\treturn PTR_ERR(pci_epc_class);\n\t}\n\n\treturn 0;\n}\nmodule_init(pci_epc_init);\n\nstatic void __exit pci_epc_exit(void)\n{\n\tclass_destroy(pci_epc_class);\n}\nmodule_exit(pci_epc_exit);\n\nMODULE_DESCRIPTION(\"PCI EPC Library\");\nMODULE_AUTHOR(\"Kishon Vijay Abraham I <kishon@ti.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}