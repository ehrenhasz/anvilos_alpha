{
  "module_name": "pci-epc-mem.c",
  "hash_id": "1737fc84428317d80d54e38dee62ff8ef783164dc35192ba57110d49119e289e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/endpoint/pci-epc-mem.c",
  "human_readable_source": "\n \n\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\n#include <linux/pci-epc.h>\n\n \nstatic int pci_epc_mem_get_order(struct pci_epc_mem *mem, size_t size)\n{\n\tint order;\n\tunsigned int page_shift = ilog2(mem->window.page_size);\n\n\tsize--;\n\tsize >>= page_shift;\n#if BITS_PER_LONG == 32\n\torder = fls(size);\n#else\n\torder = fls64(size);\n#endif\n\treturn order;\n}\n\n \nint pci_epc_multi_mem_init(struct pci_epc *epc,\n\t\t\t   struct pci_epc_mem_window *windows,\n\t\t\t   unsigned int num_windows)\n{\n\tstruct pci_epc_mem *mem = NULL;\n\tunsigned long *bitmap = NULL;\n\tunsigned int page_shift;\n\tsize_t page_size;\n\tint bitmap_size;\n\tint pages;\n\tint ret;\n\tint i;\n\n\tepc->num_windows = 0;\n\n\tif (!windows || !num_windows)\n\t\treturn -EINVAL;\n\n\tepc->windows = kcalloc(num_windows, sizeof(*epc->windows), GFP_KERNEL);\n\tif (!epc->windows)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < num_windows; i++) {\n\t\tpage_size = windows[i].page_size;\n\t\tif (page_size < PAGE_SIZE)\n\t\t\tpage_size = PAGE_SIZE;\n\t\tpage_shift = ilog2(page_size);\n\t\tpages = windows[i].size >> page_shift;\n\t\tbitmap_size = BITS_TO_LONGS(pages) * sizeof(long);\n\n\t\tmem = kzalloc(sizeof(*mem), GFP_KERNEL);\n\t\tif (!mem) {\n\t\t\tret = -ENOMEM;\n\t\t\ti--;\n\t\t\tgoto err_mem;\n\t\t}\n\n\t\tbitmap = kzalloc(bitmap_size, GFP_KERNEL);\n\t\tif (!bitmap) {\n\t\t\tret = -ENOMEM;\n\t\t\tkfree(mem);\n\t\t\ti--;\n\t\t\tgoto err_mem;\n\t\t}\n\n\t\tmem->window.phys_base = windows[i].phys_base;\n\t\tmem->window.size = windows[i].size;\n\t\tmem->window.page_size = page_size;\n\t\tmem->bitmap = bitmap;\n\t\tmem->pages = pages;\n\t\tmutex_init(&mem->lock);\n\t\tepc->windows[i] = mem;\n\t}\n\n\tepc->mem = epc->windows[0];\n\tepc->num_windows = num_windows;\n\n\treturn 0;\n\nerr_mem:\n\tfor (; i >= 0; i--) {\n\t\tmem = epc->windows[i];\n\t\tkfree(mem->bitmap);\n\t\tkfree(mem);\n\t}\n\tkfree(epc->windows);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(pci_epc_multi_mem_init);\n\n \nint pci_epc_mem_init(struct pci_epc *epc, phys_addr_t base,\n\t\t     size_t size, size_t page_size)\n{\n\tstruct pci_epc_mem_window mem_window;\n\n\tmem_window.phys_base = base;\n\tmem_window.size = size;\n\tmem_window.page_size = page_size;\n\n\treturn pci_epc_multi_mem_init(epc, &mem_window, 1);\n}\nEXPORT_SYMBOL_GPL(pci_epc_mem_init);\n\n \nvoid pci_epc_mem_exit(struct pci_epc *epc)\n{\n\tstruct pci_epc_mem *mem;\n\tint i;\n\n\tif (!epc->num_windows)\n\t\treturn;\n\n\tfor (i = 0; i < epc->num_windows; i++) {\n\t\tmem = epc->windows[i];\n\t\tkfree(mem->bitmap);\n\t\tkfree(mem);\n\t}\n\tkfree(epc->windows);\n\n\tepc->windows = NULL;\n\tepc->mem = NULL;\n\tepc->num_windows = 0;\n}\nEXPORT_SYMBOL_GPL(pci_epc_mem_exit);\n\n \nvoid __iomem *pci_epc_mem_alloc_addr(struct pci_epc *epc,\n\t\t\t\t     phys_addr_t *phys_addr, size_t size)\n{\n\tvoid __iomem *virt_addr = NULL;\n\tstruct pci_epc_mem *mem;\n\tunsigned int page_shift;\n\tsize_t align_size;\n\tint pageno;\n\tint order;\n\tint i;\n\n\tfor (i = 0; i < epc->num_windows; i++) {\n\t\tmem = epc->windows[i];\n\t\tmutex_lock(&mem->lock);\n\t\talign_size = ALIGN(size, mem->window.page_size);\n\t\torder = pci_epc_mem_get_order(mem, align_size);\n\n\t\tpageno = bitmap_find_free_region(mem->bitmap, mem->pages,\n\t\t\t\t\t\t order);\n\t\tif (pageno >= 0) {\n\t\t\tpage_shift = ilog2(mem->window.page_size);\n\t\t\t*phys_addr = mem->window.phys_base +\n\t\t\t\t((phys_addr_t)pageno << page_shift);\n\t\t\tvirt_addr = ioremap(*phys_addr, align_size);\n\t\t\tif (!virt_addr) {\n\t\t\t\tbitmap_release_region(mem->bitmap,\n\t\t\t\t\t\t      pageno, order);\n\t\t\t\tmutex_unlock(&mem->lock);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tmutex_unlock(&mem->lock);\n\t\t\treturn virt_addr;\n\t\t}\n\t\tmutex_unlock(&mem->lock);\n\t}\n\n\treturn virt_addr;\n}\nEXPORT_SYMBOL_GPL(pci_epc_mem_alloc_addr);\n\nstatic struct pci_epc_mem *pci_epc_get_matching_window(struct pci_epc *epc,\n\t\t\t\t\t\t       phys_addr_t phys_addr)\n{\n\tstruct pci_epc_mem *mem;\n\tint i;\n\n\tfor (i = 0; i < epc->num_windows; i++) {\n\t\tmem = epc->windows[i];\n\n\t\tif (phys_addr >= mem->window.phys_base &&\n\t\t    phys_addr < (mem->window.phys_base + mem->window.size))\n\t\t\treturn mem;\n\t}\n\n\treturn NULL;\n}\n\n \nvoid pci_epc_mem_free_addr(struct pci_epc *epc, phys_addr_t phys_addr,\n\t\t\t   void __iomem *virt_addr, size_t size)\n{\n\tstruct pci_epc_mem *mem;\n\tunsigned int page_shift;\n\tsize_t page_size;\n\tint pageno;\n\tint order;\n\n\tmem = pci_epc_get_matching_window(epc, phys_addr);\n\tif (!mem) {\n\t\tpr_err(\"failed to get matching window\\n\");\n\t\treturn;\n\t}\n\n\tpage_size = mem->window.page_size;\n\tpage_shift = ilog2(page_size);\n\tiounmap(virt_addr);\n\tpageno = (phys_addr - mem->window.phys_base) >> page_shift;\n\tsize = ALIGN(size, page_size);\n\torder = pci_epc_mem_get_order(mem, size);\n\tmutex_lock(&mem->lock);\n\tbitmap_release_region(mem->bitmap, pageno, order);\n\tmutex_unlock(&mem->lock);\n}\nEXPORT_SYMBOL_GPL(pci_epc_mem_free_addr);\n\nMODULE_DESCRIPTION(\"PCI EPC Address Space Management\");\nMODULE_AUTHOR(\"Kishon Vijay Abraham I <kishon@ti.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}