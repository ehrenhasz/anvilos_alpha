{
  "module_name": "pci-epf-test.c",
  "hash_id": "f999daefd8610bcbc060bc32456f71039a8783d9b9a7db355a84558cabe7f251",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/endpoint/functions/pci-epf-test.c",
  "human_readable_source": "\n \n\n#include <linux/crc32.h>\n#include <linux/delay.h>\n#include <linux/dmaengine.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/pci_ids.h>\n#include <linux/random.h>\n\n#include <linux/pci-epc.h>\n#include <linux/pci-epf.h>\n#include <linux/pci_regs.h>\n\n#define IRQ_TYPE_LEGACY\t\t\t0\n#define IRQ_TYPE_MSI\t\t\t1\n#define IRQ_TYPE_MSIX\t\t\t2\n\n#define COMMAND_RAISE_LEGACY_IRQ\tBIT(0)\n#define COMMAND_RAISE_MSI_IRQ\t\tBIT(1)\n#define COMMAND_RAISE_MSIX_IRQ\t\tBIT(2)\n#define COMMAND_READ\t\t\tBIT(3)\n#define COMMAND_WRITE\t\t\tBIT(4)\n#define COMMAND_COPY\t\t\tBIT(5)\n\n#define STATUS_READ_SUCCESS\t\tBIT(0)\n#define STATUS_READ_FAIL\t\tBIT(1)\n#define STATUS_WRITE_SUCCESS\t\tBIT(2)\n#define STATUS_WRITE_FAIL\t\tBIT(3)\n#define STATUS_COPY_SUCCESS\t\tBIT(4)\n#define STATUS_COPY_FAIL\t\tBIT(5)\n#define STATUS_IRQ_RAISED\t\tBIT(6)\n#define STATUS_SRC_ADDR_INVALID\t\tBIT(7)\n#define STATUS_DST_ADDR_INVALID\t\tBIT(8)\n\n#define FLAG_USE_DMA\t\t\tBIT(0)\n\n#define TIMER_RESOLUTION\t\t1\n\nstatic struct workqueue_struct *kpcitest_workqueue;\n\nstruct pci_epf_test {\n\tvoid\t\t\t*reg[PCI_STD_NUM_BARS];\n\tstruct pci_epf\t\t*epf;\n\tenum pci_barno\t\ttest_reg_bar;\n\tsize_t\t\t\tmsix_table_offset;\n\tstruct delayed_work\tcmd_handler;\n\tstruct dma_chan\t\t*dma_chan_tx;\n\tstruct dma_chan\t\t*dma_chan_rx;\n\tstruct dma_chan\t\t*transfer_chan;\n\tdma_cookie_t\t\ttransfer_cookie;\n\tenum dma_status\t\ttransfer_status;\n\tstruct completion\ttransfer_complete;\n\tbool\t\t\tdma_supported;\n\tbool\t\t\tdma_private;\n\tconst struct pci_epc_features *epc_features;\n};\n\nstruct pci_epf_test_reg {\n\tu32\tmagic;\n\tu32\tcommand;\n\tu32\tstatus;\n\tu64\tsrc_addr;\n\tu64\tdst_addr;\n\tu32\tsize;\n\tu32\tchecksum;\n\tu32\tirq_type;\n\tu32\tirq_number;\n\tu32\tflags;\n} __packed;\n\nstatic struct pci_epf_header test_header = {\n\t.vendorid\t= PCI_ANY_ID,\n\t.deviceid\t= PCI_ANY_ID,\n\t.baseclass_code = PCI_CLASS_OTHERS,\n\t.interrupt_pin\t= PCI_INTERRUPT_INTA,\n};\n\nstatic size_t bar_size[] = { 512, 512, 1024, 16384, 131072, 1048576 };\n\nstatic void pci_epf_test_dma_callback(void *param)\n{\n\tstruct pci_epf_test *epf_test = param;\n\tstruct dma_tx_state state;\n\n\tepf_test->transfer_status =\n\t\tdmaengine_tx_status(epf_test->transfer_chan,\n\t\t\t\t    epf_test->transfer_cookie, &state);\n\tif (epf_test->transfer_status == DMA_COMPLETE ||\n\t    epf_test->transfer_status == DMA_ERROR)\n\t\tcomplete(&epf_test->transfer_complete);\n}\n\n \nstatic int pci_epf_test_data_transfer(struct pci_epf_test *epf_test,\n\t\t\t\t      dma_addr_t dma_dst, dma_addr_t dma_src,\n\t\t\t\t      size_t len, dma_addr_t dma_remote,\n\t\t\t\t      enum dma_transfer_direction dir)\n{\n\tstruct dma_chan *chan = (dir == DMA_MEM_TO_DEV) ?\n\t\t\t\t epf_test->dma_chan_tx : epf_test->dma_chan_rx;\n\tdma_addr_t dma_local = (dir == DMA_MEM_TO_DEV) ? dma_src : dma_dst;\n\tenum dma_ctrl_flags flags = DMA_CTRL_ACK | DMA_PREP_INTERRUPT;\n\tstruct pci_epf *epf = epf_test->epf;\n\tstruct dma_async_tx_descriptor *tx;\n\tstruct dma_slave_config sconf = {};\n\tstruct device *dev = &epf->dev;\n\tint ret;\n\n\tif (IS_ERR_OR_NULL(chan)) {\n\t\tdev_err(dev, \"Invalid DMA memcpy channel\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (epf_test->dma_private) {\n\t\tsconf.direction = dir;\n\t\tif (dir == DMA_MEM_TO_DEV)\n\t\t\tsconf.dst_addr = dma_remote;\n\t\telse\n\t\t\tsconf.src_addr = dma_remote;\n\n\t\tif (dmaengine_slave_config(chan, &sconf)) {\n\t\t\tdev_err(dev, \"DMA slave config fail\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t\ttx = dmaengine_prep_slave_single(chan, dma_local, len, dir,\n\t\t\t\t\t\t flags);\n\t} else {\n\t\ttx = dmaengine_prep_dma_memcpy(chan, dma_dst, dma_src, len,\n\t\t\t\t\t       flags);\n\t}\n\n\tif (!tx) {\n\t\tdev_err(dev, \"Failed to prepare DMA memcpy\\n\");\n\t\treturn -EIO;\n\t}\n\n\treinit_completion(&epf_test->transfer_complete);\n\tepf_test->transfer_chan = chan;\n\ttx->callback = pci_epf_test_dma_callback;\n\ttx->callback_param = epf_test;\n\tepf_test->transfer_cookie = dmaengine_submit(tx);\n\n\tret = dma_submit_error(epf_test->transfer_cookie);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to do DMA tx_submit %d\\n\", ret);\n\t\tgoto terminate;\n\t}\n\n\tdma_async_issue_pending(chan);\n\tret = wait_for_completion_interruptible(&epf_test->transfer_complete);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"DMA wait_for_completion interrupted\\n\");\n\t\tgoto terminate;\n\t}\n\n\tif (epf_test->transfer_status == DMA_ERROR) {\n\t\tdev_err(dev, \"DMA transfer failed\\n\");\n\t\tret = -EIO;\n\t}\n\nterminate:\n\tdmaengine_terminate_sync(chan);\n\n\treturn ret;\n}\n\nstruct epf_dma_filter {\n\tstruct device *dev;\n\tu32 dma_mask;\n};\n\nstatic bool epf_dma_filter_fn(struct dma_chan *chan, void *node)\n{\n\tstruct epf_dma_filter *filter = node;\n\tstruct dma_slave_caps caps;\n\n\tmemset(&caps, 0, sizeof(caps));\n\tdma_get_slave_caps(chan, &caps);\n\n\treturn chan->device->dev == filter->dev\n\t\t&& (filter->dma_mask & caps.directions);\n}\n\n \nstatic int pci_epf_test_init_dma_chan(struct pci_epf_test *epf_test)\n{\n\tstruct pci_epf *epf = epf_test->epf;\n\tstruct device *dev = &epf->dev;\n\tstruct epf_dma_filter filter;\n\tstruct dma_chan *dma_chan;\n\tdma_cap_mask_t mask;\n\tint ret;\n\n\tfilter.dev = epf->epc->dev.parent;\n\tfilter.dma_mask = BIT(DMA_DEV_TO_MEM);\n\n\tdma_cap_zero(mask);\n\tdma_cap_set(DMA_SLAVE, mask);\n\tdma_chan = dma_request_channel(mask, epf_dma_filter_fn, &filter);\n\tif (!dma_chan) {\n\t\tdev_info(dev, \"Failed to get private DMA rx channel. Falling back to generic one\\n\");\n\t\tgoto fail_back_tx;\n\t}\n\n\tepf_test->dma_chan_rx = dma_chan;\n\n\tfilter.dma_mask = BIT(DMA_MEM_TO_DEV);\n\tdma_chan = dma_request_channel(mask, epf_dma_filter_fn, &filter);\n\n\tif (!dma_chan) {\n\t\tdev_info(dev, \"Failed to get private DMA tx channel. Falling back to generic one\\n\");\n\t\tgoto fail_back_rx;\n\t}\n\n\tepf_test->dma_chan_tx = dma_chan;\n\tepf_test->dma_private = true;\n\n\tinit_completion(&epf_test->transfer_complete);\n\n\treturn 0;\n\nfail_back_rx:\n\tdma_release_channel(epf_test->dma_chan_rx);\n\tepf_test->dma_chan_tx = NULL;\n\nfail_back_tx:\n\tdma_cap_zero(mask);\n\tdma_cap_set(DMA_MEMCPY, mask);\n\n\tdma_chan = dma_request_chan_by_mask(&mask);\n\tif (IS_ERR(dma_chan)) {\n\t\tret = PTR_ERR(dma_chan);\n\t\tif (ret != -EPROBE_DEFER)\n\t\t\tdev_err(dev, \"Failed to get DMA channel\\n\");\n\t\treturn ret;\n\t}\n\tinit_completion(&epf_test->transfer_complete);\n\n\tepf_test->dma_chan_tx = epf_test->dma_chan_rx = dma_chan;\n\n\treturn 0;\n}\n\n \nstatic void pci_epf_test_clean_dma_chan(struct pci_epf_test *epf_test)\n{\n\tif (!epf_test->dma_supported)\n\t\treturn;\n\n\tdma_release_channel(epf_test->dma_chan_tx);\n\tif (epf_test->dma_chan_tx == epf_test->dma_chan_rx) {\n\t\tepf_test->dma_chan_tx = NULL;\n\t\tepf_test->dma_chan_rx = NULL;\n\t\treturn;\n\t}\n\n\tdma_release_channel(epf_test->dma_chan_rx);\n\tepf_test->dma_chan_rx = NULL;\n\n\treturn;\n}\n\nstatic void pci_epf_test_print_rate(struct pci_epf_test *epf_test,\n\t\t\t\t    const char *op, u64 size,\n\t\t\t\t    struct timespec64 *start,\n\t\t\t\t    struct timespec64 *end, bool dma)\n{\n\tstruct timespec64 ts = timespec64_sub(*end, *start);\n\tu64 rate = 0, ns;\n\n\t \n\tns = timespec64_to_ns(&ts);\n\tif (ns)\n\t\trate = div64_u64(size * NSEC_PER_SEC, ns * 1000);\n\n\tdev_info(&epf_test->epf->dev,\n\t\t \"%s => Size: %llu B, DMA: %s, Time: %llu.%09u s, Rate: %llu KB/s\\n\",\n\t\t op, size, dma ? \"YES\" : \"NO\",\n\t\t (u64)ts.tv_sec, (u32)ts.tv_nsec, rate);\n}\n\nstatic void pci_epf_test_copy(struct pci_epf_test *epf_test,\n\t\t\t      struct pci_epf_test_reg *reg)\n{\n\tint ret;\n\tvoid __iomem *src_addr;\n\tvoid __iomem *dst_addr;\n\tphys_addr_t src_phys_addr;\n\tphys_addr_t dst_phys_addr;\n\tstruct timespec64 start, end;\n\tstruct pci_epf *epf = epf_test->epf;\n\tstruct device *dev = &epf->dev;\n\tstruct pci_epc *epc = epf->epc;\n\n\tsrc_addr = pci_epc_mem_alloc_addr(epc, &src_phys_addr, reg->size);\n\tif (!src_addr) {\n\t\tdev_err(dev, \"Failed to allocate source address\\n\");\n\t\treg->status = STATUS_SRC_ADDR_INVALID;\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tret = pci_epc_map_addr(epc, epf->func_no, epf->vfunc_no, src_phys_addr,\n\t\t\t       reg->src_addr, reg->size);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to map source address\\n\");\n\t\treg->status = STATUS_SRC_ADDR_INVALID;\n\t\tgoto err_src_addr;\n\t}\n\n\tdst_addr = pci_epc_mem_alloc_addr(epc, &dst_phys_addr, reg->size);\n\tif (!dst_addr) {\n\t\tdev_err(dev, \"Failed to allocate destination address\\n\");\n\t\treg->status = STATUS_DST_ADDR_INVALID;\n\t\tret = -ENOMEM;\n\t\tgoto err_src_map_addr;\n\t}\n\n\tret = pci_epc_map_addr(epc, epf->func_no, epf->vfunc_no, dst_phys_addr,\n\t\t\t       reg->dst_addr, reg->size);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to map destination address\\n\");\n\t\treg->status = STATUS_DST_ADDR_INVALID;\n\t\tgoto err_dst_addr;\n\t}\n\n\tktime_get_ts64(&start);\n\tif (reg->flags & FLAG_USE_DMA) {\n\t\tif (epf_test->dma_private) {\n\t\t\tdev_err(dev, \"Cannot transfer data using DMA\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_map_addr;\n\t\t}\n\n\t\tret = pci_epf_test_data_transfer(epf_test, dst_phys_addr,\n\t\t\t\t\t\t src_phys_addr, reg->size, 0,\n\t\t\t\t\t\t DMA_MEM_TO_MEM);\n\t\tif (ret)\n\t\t\tdev_err(dev, \"Data transfer failed\\n\");\n\t} else {\n\t\tvoid *buf;\n\n\t\tbuf = kzalloc(reg->size, GFP_KERNEL);\n\t\tif (!buf) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_map_addr;\n\t\t}\n\n\t\tmemcpy_fromio(buf, src_addr, reg->size);\n\t\tmemcpy_toio(dst_addr, buf, reg->size);\n\t\tkfree(buf);\n\t}\n\tktime_get_ts64(&end);\n\tpci_epf_test_print_rate(epf_test, \"COPY\", reg->size, &start, &end,\n\t\t\t\treg->flags & FLAG_USE_DMA);\n\nerr_map_addr:\n\tpci_epc_unmap_addr(epc, epf->func_no, epf->vfunc_no, dst_phys_addr);\n\nerr_dst_addr:\n\tpci_epc_mem_free_addr(epc, dst_phys_addr, dst_addr, reg->size);\n\nerr_src_map_addr:\n\tpci_epc_unmap_addr(epc, epf->func_no, epf->vfunc_no, src_phys_addr);\n\nerr_src_addr:\n\tpci_epc_mem_free_addr(epc, src_phys_addr, src_addr, reg->size);\n\nerr:\n\tif (!ret)\n\t\treg->status |= STATUS_COPY_SUCCESS;\n\telse\n\t\treg->status |= STATUS_COPY_FAIL;\n}\n\nstatic void pci_epf_test_read(struct pci_epf_test *epf_test,\n\t\t\t      struct pci_epf_test_reg *reg)\n{\n\tint ret;\n\tvoid __iomem *src_addr;\n\tvoid *buf;\n\tu32 crc32;\n\tphys_addr_t phys_addr;\n\tphys_addr_t dst_phys_addr;\n\tstruct timespec64 start, end;\n\tstruct pci_epf *epf = epf_test->epf;\n\tstruct device *dev = &epf->dev;\n\tstruct pci_epc *epc = epf->epc;\n\tstruct device *dma_dev = epf->epc->dev.parent;\n\n\tsrc_addr = pci_epc_mem_alloc_addr(epc, &phys_addr, reg->size);\n\tif (!src_addr) {\n\t\tdev_err(dev, \"Failed to allocate address\\n\");\n\t\treg->status = STATUS_SRC_ADDR_INVALID;\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tret = pci_epc_map_addr(epc, epf->func_no, epf->vfunc_no, phys_addr,\n\t\t\t       reg->src_addr, reg->size);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to map address\\n\");\n\t\treg->status = STATUS_SRC_ADDR_INVALID;\n\t\tgoto err_addr;\n\t}\n\n\tbuf = kzalloc(reg->size, GFP_KERNEL);\n\tif (!buf) {\n\t\tret = -ENOMEM;\n\t\tgoto err_map_addr;\n\t}\n\n\tif (reg->flags & FLAG_USE_DMA) {\n\t\tdst_phys_addr = dma_map_single(dma_dev, buf, reg->size,\n\t\t\t\t\t       DMA_FROM_DEVICE);\n\t\tif (dma_mapping_error(dma_dev, dst_phys_addr)) {\n\t\t\tdev_err(dev, \"Failed to map destination buffer addr\\n\");\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_dma_map;\n\t\t}\n\n\t\tktime_get_ts64(&start);\n\t\tret = pci_epf_test_data_transfer(epf_test, dst_phys_addr,\n\t\t\t\t\t\t phys_addr, reg->size,\n\t\t\t\t\t\t reg->src_addr, DMA_DEV_TO_MEM);\n\t\tif (ret)\n\t\t\tdev_err(dev, \"Data transfer failed\\n\");\n\t\tktime_get_ts64(&end);\n\n\t\tdma_unmap_single(dma_dev, dst_phys_addr, reg->size,\n\t\t\t\t DMA_FROM_DEVICE);\n\t} else {\n\t\tktime_get_ts64(&start);\n\t\tmemcpy_fromio(buf, src_addr, reg->size);\n\t\tktime_get_ts64(&end);\n\t}\n\n\tpci_epf_test_print_rate(epf_test, \"READ\", reg->size, &start, &end,\n\t\t\t\treg->flags & FLAG_USE_DMA);\n\n\tcrc32 = crc32_le(~0, buf, reg->size);\n\tif (crc32 != reg->checksum)\n\t\tret = -EIO;\n\nerr_dma_map:\n\tkfree(buf);\n\nerr_map_addr:\n\tpci_epc_unmap_addr(epc, epf->func_no, epf->vfunc_no, phys_addr);\n\nerr_addr:\n\tpci_epc_mem_free_addr(epc, phys_addr, src_addr, reg->size);\n\nerr:\n\tif (!ret)\n\t\treg->status |= STATUS_READ_SUCCESS;\n\telse\n\t\treg->status |= STATUS_READ_FAIL;\n}\n\nstatic void pci_epf_test_write(struct pci_epf_test *epf_test,\n\t\t\t       struct pci_epf_test_reg *reg)\n{\n\tint ret;\n\tvoid __iomem *dst_addr;\n\tvoid *buf;\n\tphys_addr_t phys_addr;\n\tphys_addr_t src_phys_addr;\n\tstruct timespec64 start, end;\n\tstruct pci_epf *epf = epf_test->epf;\n\tstruct device *dev = &epf->dev;\n\tstruct pci_epc *epc = epf->epc;\n\tstruct device *dma_dev = epf->epc->dev.parent;\n\n\tdst_addr = pci_epc_mem_alloc_addr(epc, &phys_addr, reg->size);\n\tif (!dst_addr) {\n\t\tdev_err(dev, \"Failed to allocate address\\n\");\n\t\treg->status = STATUS_DST_ADDR_INVALID;\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tret = pci_epc_map_addr(epc, epf->func_no, epf->vfunc_no, phys_addr,\n\t\t\t       reg->dst_addr, reg->size);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to map address\\n\");\n\t\treg->status = STATUS_DST_ADDR_INVALID;\n\t\tgoto err_addr;\n\t}\n\n\tbuf = kzalloc(reg->size, GFP_KERNEL);\n\tif (!buf) {\n\t\tret = -ENOMEM;\n\t\tgoto err_map_addr;\n\t}\n\n\tget_random_bytes(buf, reg->size);\n\treg->checksum = crc32_le(~0, buf, reg->size);\n\n\tif (reg->flags & FLAG_USE_DMA) {\n\t\tsrc_phys_addr = dma_map_single(dma_dev, buf, reg->size,\n\t\t\t\t\t       DMA_TO_DEVICE);\n\t\tif (dma_mapping_error(dma_dev, src_phys_addr)) {\n\t\t\tdev_err(dev, \"Failed to map source buffer addr\\n\");\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_dma_map;\n\t\t}\n\n\t\tktime_get_ts64(&start);\n\n\t\tret = pci_epf_test_data_transfer(epf_test, phys_addr,\n\t\t\t\t\t\t src_phys_addr, reg->size,\n\t\t\t\t\t\t reg->dst_addr,\n\t\t\t\t\t\t DMA_MEM_TO_DEV);\n\t\tif (ret)\n\t\t\tdev_err(dev, \"Data transfer failed\\n\");\n\t\tktime_get_ts64(&end);\n\n\t\tdma_unmap_single(dma_dev, src_phys_addr, reg->size,\n\t\t\t\t DMA_TO_DEVICE);\n\t} else {\n\t\tktime_get_ts64(&start);\n\t\tmemcpy_toio(dst_addr, buf, reg->size);\n\t\tktime_get_ts64(&end);\n\t}\n\n\tpci_epf_test_print_rate(epf_test, \"WRITE\", reg->size, &start, &end,\n\t\t\t\treg->flags & FLAG_USE_DMA);\n\n\t \n\tusleep_range(1000, 2000);\n\nerr_dma_map:\n\tkfree(buf);\n\nerr_map_addr:\n\tpci_epc_unmap_addr(epc, epf->func_no, epf->vfunc_no, phys_addr);\n\nerr_addr:\n\tpci_epc_mem_free_addr(epc, phys_addr, dst_addr, reg->size);\n\nerr:\n\tif (!ret)\n\t\treg->status |= STATUS_WRITE_SUCCESS;\n\telse\n\t\treg->status |= STATUS_WRITE_FAIL;\n}\n\nstatic void pci_epf_test_raise_irq(struct pci_epf_test *epf_test,\n\t\t\t\t   struct pci_epf_test_reg *reg)\n{\n\tstruct pci_epf *epf = epf_test->epf;\n\tstruct device *dev = &epf->dev;\n\tstruct pci_epc *epc = epf->epc;\n\tu32 status = reg->status | STATUS_IRQ_RAISED;\n\tint count;\n\n\t \n\tWRITE_ONCE(reg->status, status);\n\n\tswitch (reg->irq_type) {\n\tcase IRQ_TYPE_LEGACY:\n\t\tpci_epc_raise_irq(epc, epf->func_no, epf->vfunc_no,\n\t\t\t\t  PCI_EPC_IRQ_LEGACY, 0);\n\t\tbreak;\n\tcase IRQ_TYPE_MSI:\n\t\tcount = pci_epc_get_msi(epc, epf->func_no, epf->vfunc_no);\n\t\tif (reg->irq_number > count || count <= 0) {\n\t\t\tdev_err(dev, \"Invalid MSI IRQ number %d / %d\\n\",\n\t\t\t\treg->irq_number, count);\n\t\t\treturn;\n\t\t}\n\t\tpci_epc_raise_irq(epc, epf->func_no, epf->vfunc_no,\n\t\t\t\t  PCI_EPC_IRQ_MSI, reg->irq_number);\n\t\tbreak;\n\tcase IRQ_TYPE_MSIX:\n\t\tcount = pci_epc_get_msix(epc, epf->func_no, epf->vfunc_no);\n\t\tif (reg->irq_number > count || count <= 0) {\n\t\t\tdev_err(dev, \"Invalid MSIX IRQ number %d / %d\\n\",\n\t\t\t\treg->irq_number, count);\n\t\t\treturn;\n\t\t}\n\t\tpci_epc_raise_irq(epc, epf->func_no, epf->vfunc_no,\n\t\t\t\t  PCI_EPC_IRQ_MSIX, reg->irq_number);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"Failed to raise IRQ, unknown type\\n\");\n\t\tbreak;\n\t}\n}\n\nstatic void pci_epf_test_cmd_handler(struct work_struct *work)\n{\n\tu32 command;\n\tstruct pci_epf_test *epf_test = container_of(work, struct pci_epf_test,\n\t\t\t\t\t\t     cmd_handler.work);\n\tstruct pci_epf *epf = epf_test->epf;\n\tstruct device *dev = &epf->dev;\n\tenum pci_barno test_reg_bar = epf_test->test_reg_bar;\n\tstruct pci_epf_test_reg *reg = epf_test->reg[test_reg_bar];\n\n\tcommand = READ_ONCE(reg->command);\n\tif (!command)\n\t\tgoto reset_handler;\n\n\tWRITE_ONCE(reg->command, 0);\n\tWRITE_ONCE(reg->status, 0);\n\n\tif ((READ_ONCE(reg->flags) & FLAG_USE_DMA) &&\n\t    !epf_test->dma_supported) {\n\t\tdev_err(dev, \"Cannot transfer data using DMA\\n\");\n\t\tgoto reset_handler;\n\t}\n\n\tif (reg->irq_type > IRQ_TYPE_MSIX) {\n\t\tdev_err(dev, \"Failed to detect IRQ type\\n\");\n\t\tgoto reset_handler;\n\t}\n\n\tswitch (command) {\n\tcase COMMAND_RAISE_LEGACY_IRQ:\n\tcase COMMAND_RAISE_MSI_IRQ:\n\tcase COMMAND_RAISE_MSIX_IRQ:\n\t\tpci_epf_test_raise_irq(epf_test, reg);\n\t\tbreak;\n\tcase COMMAND_WRITE:\n\t\tpci_epf_test_write(epf_test, reg);\n\t\tpci_epf_test_raise_irq(epf_test, reg);\n\t\tbreak;\n\tcase COMMAND_READ:\n\t\tpci_epf_test_read(epf_test, reg);\n\t\tpci_epf_test_raise_irq(epf_test, reg);\n\t\tbreak;\n\tcase COMMAND_COPY:\n\t\tpci_epf_test_copy(epf_test, reg);\n\t\tpci_epf_test_raise_irq(epf_test, reg);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"Invalid command 0x%x\\n\", command);\n\t\tbreak;\n\t}\n\nreset_handler:\n\tqueue_delayed_work(kpcitest_workqueue, &epf_test->cmd_handler,\n\t\t\t   msecs_to_jiffies(1));\n}\n\nstatic void pci_epf_test_unbind(struct pci_epf *epf)\n{\n\tstruct pci_epf_test *epf_test = epf_get_drvdata(epf);\n\tstruct pci_epc *epc = epf->epc;\n\tstruct pci_epf_bar *epf_bar;\n\tint bar;\n\n\tcancel_delayed_work(&epf_test->cmd_handler);\n\tpci_epf_test_clean_dma_chan(epf_test);\n\tfor (bar = 0; bar < PCI_STD_NUM_BARS; bar++) {\n\t\tepf_bar = &epf->bar[bar];\n\n\t\tif (epf_test->reg[bar]) {\n\t\t\tpci_epc_clear_bar(epc, epf->func_no, epf->vfunc_no,\n\t\t\t\t\t  epf_bar);\n\t\t\tpci_epf_free_space(epf, epf_test->reg[bar], bar,\n\t\t\t\t\t   PRIMARY_INTERFACE);\n\t\t}\n\t}\n}\n\nstatic int pci_epf_test_set_bar(struct pci_epf *epf)\n{\n\tint bar, add;\n\tint ret;\n\tstruct pci_epf_bar *epf_bar;\n\tstruct pci_epc *epc = epf->epc;\n\tstruct device *dev = &epf->dev;\n\tstruct pci_epf_test *epf_test = epf_get_drvdata(epf);\n\tenum pci_barno test_reg_bar = epf_test->test_reg_bar;\n\tconst struct pci_epc_features *epc_features;\n\n\tepc_features = epf_test->epc_features;\n\n\tfor (bar = 0; bar < PCI_STD_NUM_BARS; bar += add) {\n\t\tepf_bar = &epf->bar[bar];\n\t\t \n\t\tadd = (epf_bar->flags & PCI_BASE_ADDRESS_MEM_TYPE_64) ? 2 : 1;\n\n\t\tif (!!(epc_features->reserved_bar & (1 << bar)))\n\t\t\tcontinue;\n\n\t\tret = pci_epc_set_bar(epc, epf->func_no, epf->vfunc_no,\n\t\t\t\t      epf_bar);\n\t\tif (ret) {\n\t\t\tpci_epf_free_space(epf, epf_test->reg[bar], bar,\n\t\t\t\t\t   PRIMARY_INTERFACE);\n\t\t\tdev_err(dev, \"Failed to set BAR%d\\n\", bar);\n\t\t\tif (bar == test_reg_bar)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int pci_epf_test_core_init(struct pci_epf *epf)\n{\n\tstruct pci_epf_test *epf_test = epf_get_drvdata(epf);\n\tstruct pci_epf_header *header = epf->header;\n\tconst struct pci_epc_features *epc_features;\n\tstruct pci_epc *epc = epf->epc;\n\tstruct device *dev = &epf->dev;\n\tbool msix_capable = false;\n\tbool msi_capable = true;\n\tint ret;\n\n\tepc_features = pci_epc_get_features(epc, epf->func_no, epf->vfunc_no);\n\tif (epc_features) {\n\t\tmsix_capable = epc_features->msix_capable;\n\t\tmsi_capable = epc_features->msi_capable;\n\t}\n\n\tif (epf->vfunc_no <= 1) {\n\t\tret = pci_epc_write_header(epc, epf->func_no, epf->vfunc_no, header);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Configuration header write failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = pci_epf_test_set_bar(epf);\n\tif (ret)\n\t\treturn ret;\n\n\tif (msi_capable) {\n\t\tret = pci_epc_set_msi(epc, epf->func_no, epf->vfunc_no,\n\t\t\t\t      epf->msi_interrupts);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"MSI configuration failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (msix_capable) {\n\t\tret = pci_epc_set_msix(epc, epf->func_no, epf->vfunc_no,\n\t\t\t\t       epf->msix_interrupts,\n\t\t\t\t       epf_test->test_reg_bar,\n\t\t\t\t       epf_test->msix_table_offset);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"MSI-X configuration failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int pci_epf_test_link_up(struct pci_epf *epf)\n{\n\tstruct pci_epf_test *epf_test = epf_get_drvdata(epf);\n\n\tqueue_delayed_work(kpcitest_workqueue, &epf_test->cmd_handler,\n\t\t\t   msecs_to_jiffies(1));\n\n\treturn 0;\n}\n\nstatic const struct pci_epc_event_ops pci_epf_test_event_ops = {\n\t.core_init = pci_epf_test_core_init,\n\t.link_up = pci_epf_test_link_up,\n};\n\nstatic int pci_epf_test_alloc_space(struct pci_epf *epf)\n{\n\tstruct pci_epf_test *epf_test = epf_get_drvdata(epf);\n\tstruct device *dev = &epf->dev;\n\tstruct pci_epf_bar *epf_bar;\n\tsize_t msix_table_size = 0;\n\tsize_t test_reg_bar_size;\n\tsize_t pba_size = 0;\n\tbool msix_capable;\n\tvoid *base;\n\tint bar, add;\n\tenum pci_barno test_reg_bar = epf_test->test_reg_bar;\n\tconst struct pci_epc_features *epc_features;\n\tsize_t test_reg_size;\n\n\tepc_features = epf_test->epc_features;\n\n\ttest_reg_bar_size = ALIGN(sizeof(struct pci_epf_test_reg), 128);\n\n\tmsix_capable = epc_features->msix_capable;\n\tif (msix_capable) {\n\t\tmsix_table_size = PCI_MSIX_ENTRY_SIZE * epf->msix_interrupts;\n\t\tepf_test->msix_table_offset = test_reg_bar_size;\n\t\t \n\t\tpba_size = ALIGN(DIV_ROUND_UP(epf->msix_interrupts, 8), 8);\n\t}\n\ttest_reg_size = test_reg_bar_size + msix_table_size + pba_size;\n\n\tif (epc_features->bar_fixed_size[test_reg_bar]) {\n\t\tif (test_reg_size > bar_size[test_reg_bar])\n\t\t\treturn -ENOMEM;\n\t\ttest_reg_size = bar_size[test_reg_bar];\n\t}\n\n\tbase = pci_epf_alloc_space(epf, test_reg_size, test_reg_bar,\n\t\t\t\t   epc_features->align, PRIMARY_INTERFACE);\n\tif (!base) {\n\t\tdev_err(dev, \"Failed to allocated register space\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tepf_test->reg[test_reg_bar] = base;\n\n\tfor (bar = 0; bar < PCI_STD_NUM_BARS; bar += add) {\n\t\tepf_bar = &epf->bar[bar];\n\t\tadd = (epf_bar->flags & PCI_BASE_ADDRESS_MEM_TYPE_64) ? 2 : 1;\n\n\t\tif (bar == test_reg_bar)\n\t\t\tcontinue;\n\n\t\tif (!!(epc_features->reserved_bar & (1 << bar)))\n\t\t\tcontinue;\n\n\t\tbase = pci_epf_alloc_space(epf, bar_size[bar], bar,\n\t\t\t\t\t   epc_features->align,\n\t\t\t\t\t   PRIMARY_INTERFACE);\n\t\tif (!base)\n\t\t\tdev_err(dev, \"Failed to allocate space for BAR%d\\n\",\n\t\t\t\tbar);\n\t\tepf_test->reg[bar] = base;\n\t}\n\n\treturn 0;\n}\n\nstatic void pci_epf_configure_bar(struct pci_epf *epf,\n\t\t\t\t  const struct pci_epc_features *epc_features)\n{\n\tstruct pci_epf_bar *epf_bar;\n\tbool bar_fixed_64bit;\n\tint i;\n\n\tfor (i = 0; i < PCI_STD_NUM_BARS; i++) {\n\t\tepf_bar = &epf->bar[i];\n\t\tbar_fixed_64bit = !!(epc_features->bar_fixed_64bit & (1 << i));\n\t\tif (bar_fixed_64bit)\n\t\t\tepf_bar->flags |= PCI_BASE_ADDRESS_MEM_TYPE_64;\n\t\tif (epc_features->bar_fixed_size[i])\n\t\t\tbar_size[i] = epc_features->bar_fixed_size[i];\n\t}\n}\n\nstatic int pci_epf_test_bind(struct pci_epf *epf)\n{\n\tint ret;\n\tstruct pci_epf_test *epf_test = epf_get_drvdata(epf);\n\tconst struct pci_epc_features *epc_features;\n\tenum pci_barno test_reg_bar = BAR_0;\n\tstruct pci_epc *epc = epf->epc;\n\tbool linkup_notifier = false;\n\tbool core_init_notifier = false;\n\n\tif (WARN_ON_ONCE(!epc))\n\t\treturn -EINVAL;\n\n\tepc_features = pci_epc_get_features(epc, epf->func_no, epf->vfunc_no);\n\tif (!epc_features) {\n\t\tdev_err(&epf->dev, \"epc_features not implemented\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tlinkup_notifier = epc_features->linkup_notifier;\n\tcore_init_notifier = epc_features->core_init_notifier;\n\ttest_reg_bar = pci_epc_get_first_free_bar(epc_features);\n\tif (test_reg_bar < 0)\n\t\treturn -EINVAL;\n\tpci_epf_configure_bar(epf, epc_features);\n\n\tepf_test->test_reg_bar = test_reg_bar;\n\tepf_test->epc_features = epc_features;\n\n\tret = pci_epf_test_alloc_space(epf);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!core_init_notifier) {\n\t\tret = pci_epf_test_core_init(epf);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tepf_test->dma_supported = true;\n\n\tret = pci_epf_test_init_dma_chan(epf_test);\n\tif (ret)\n\t\tepf_test->dma_supported = false;\n\n\tif (!linkup_notifier && !core_init_notifier)\n\t\tqueue_work(kpcitest_workqueue, &epf_test->cmd_handler.work);\n\n\treturn 0;\n}\n\nstatic const struct pci_epf_device_id pci_epf_test_ids[] = {\n\t{\n\t\t.name = \"pci_epf_test\",\n\t},\n\t{},\n};\n\nstatic int pci_epf_test_probe(struct pci_epf *epf,\n\t\t\t      const struct pci_epf_device_id *id)\n{\n\tstruct pci_epf_test *epf_test;\n\tstruct device *dev = &epf->dev;\n\n\tepf_test = devm_kzalloc(dev, sizeof(*epf_test), GFP_KERNEL);\n\tif (!epf_test)\n\t\treturn -ENOMEM;\n\n\tepf->header = &test_header;\n\tepf_test->epf = epf;\n\n\tINIT_DELAYED_WORK(&epf_test->cmd_handler, pci_epf_test_cmd_handler);\n\n\tepf->event_ops = &pci_epf_test_event_ops;\n\n\tepf_set_drvdata(epf, epf_test);\n\treturn 0;\n}\n\nstatic struct pci_epf_ops ops = {\n\t.unbind\t= pci_epf_test_unbind,\n\t.bind\t= pci_epf_test_bind,\n};\n\nstatic struct pci_epf_driver test_driver = {\n\t.driver.name\t= \"pci_epf_test\",\n\t.probe\t\t= pci_epf_test_probe,\n\t.id_table\t= pci_epf_test_ids,\n\t.ops\t\t= &ops,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic int __init pci_epf_test_init(void)\n{\n\tint ret;\n\n\tkpcitest_workqueue = alloc_workqueue(\"kpcitest\",\n\t\t\t\t\t     WQ_MEM_RECLAIM | WQ_HIGHPRI, 0);\n\tif (!kpcitest_workqueue) {\n\t\tpr_err(\"Failed to allocate the kpcitest work queue\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tret = pci_epf_register_driver(&test_driver);\n\tif (ret) {\n\t\tdestroy_workqueue(kpcitest_workqueue);\n\t\tpr_err(\"Failed to register pci epf test driver --> %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\nmodule_init(pci_epf_test_init);\n\nstatic void __exit pci_epf_test_exit(void)\n{\n\tif (kpcitest_workqueue)\n\t\tdestroy_workqueue(kpcitest_workqueue);\n\tpci_epf_unregister_driver(&test_driver);\n}\nmodule_exit(pci_epf_test_exit);\n\nMODULE_DESCRIPTION(\"PCI EPF TEST DRIVER\");\nMODULE_AUTHOR(\"Kishon Vijay Abraham I <kishon@ti.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}