{
  "module_name": "pci-epf-vntb.c",
  "hash_id": "680c3f3d4a7f164dee46750dc59dcbd9c7b3bfee3e862c4462e72cd1b1cac2a6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/endpoint/functions/pci-epf-vntb.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\n#include <linux/pci-epc.h>\n#include <linux/pci-epf.h>\n#include <linux/ntb.h>\n\nstatic struct workqueue_struct *kpcintb_workqueue;\n\n#define COMMAND_CONFIGURE_DOORBELL\t1\n#define COMMAND_TEARDOWN_DOORBELL\t2\n#define COMMAND_CONFIGURE_MW\t\t3\n#define COMMAND_TEARDOWN_MW\t\t4\n#define COMMAND_LINK_UP\t\t\t5\n#define COMMAND_LINK_DOWN\t\t6\n\n#define COMMAND_STATUS_OK\t\t1\n#define COMMAND_STATUS_ERROR\t\t2\n\n#define LINK_STATUS_UP\t\t\tBIT(0)\n\n#define SPAD_COUNT\t\t\t64\n#define DB_COUNT\t\t\t4\n#define NTB_MW_OFFSET\t\t\t2\n#define DB_COUNT_MASK\t\t\tGENMASK(15, 0)\n#define MSIX_ENABLE\t\t\tBIT(16)\n#define MAX_DB_COUNT\t\t\t32\n#define MAX_MW\t\t\t\t4\n\nenum epf_ntb_bar {\n\tBAR_CONFIG,\n\tBAR_DB,\n\tBAR_MW0,\n\tBAR_MW1,\n\tBAR_MW2,\n};\n\n \nstruct epf_ntb_ctrl {\n\tu32 command;\n\tu32 argument;\n\tu16 command_status;\n\tu16 link_status;\n\tu32 topology;\n\tu64 addr;\n\tu64 size;\n\tu32 num_mws;\n\tu32 reserved;\n\tu32 spad_offset;\n\tu32 spad_count;\n\tu32 db_entry_size;\n\tu32 db_data[MAX_DB_COUNT];\n\tu32 db_offset[MAX_DB_COUNT];\n} __packed;\n\nstruct epf_ntb {\n\tstruct ntb_dev ntb;\n\tstruct pci_epf *epf;\n\tstruct config_group group;\n\n\tu32 num_mws;\n\tu32 db_count;\n\tu32 spad_count;\n\tu64 mws_size[MAX_MW];\n\tu64 db;\n\tu32 vbus_number;\n\tu16 vntb_pid;\n\tu16 vntb_vid;\n\n\tbool linkup;\n\tu32 spad_size;\n\n\tenum pci_barno epf_ntb_bar[6];\n\n\tstruct epf_ntb_ctrl *reg;\n\n\tu32 *epf_db;\n\n\tphys_addr_t vpci_mw_phy[MAX_MW];\n\tvoid __iomem *vpci_mw_addr[MAX_MW];\n\n\tstruct delayed_work cmd_handler;\n};\n\n#define to_epf_ntb(epf_group) container_of((epf_group), struct epf_ntb, group)\n#define ntb_ndev(__ntb) container_of(__ntb, struct epf_ntb, ntb)\n\nstatic struct pci_epf_header epf_ntb_header = {\n\t.vendorid\t= PCI_ANY_ID,\n\t.deviceid\t= PCI_ANY_ID,\n\t.baseclass_code\t= PCI_BASE_CLASS_MEMORY,\n\t.interrupt_pin\t= PCI_INTERRUPT_INTA,\n};\n\n \nstatic int epf_ntb_link_up(struct epf_ntb *ntb, bool link_up)\n{\n\tif (link_up)\n\t\tntb->reg->link_status |= LINK_STATUS_UP;\n\telse\n\t\tntb->reg->link_status &= ~LINK_STATUS_UP;\n\n\tntb_link_event(&ntb->ntb);\n\treturn 0;\n}\n\n \nstatic int epf_ntb_configure_mw(struct epf_ntb *ntb, u32 mw)\n{\n\tphys_addr_t phys_addr;\n\tu8 func_no, vfunc_no;\n\tu64 addr, size;\n\tint ret = 0;\n\n\tphys_addr = ntb->vpci_mw_phy[mw];\n\taddr = ntb->reg->addr;\n\tsize = ntb->reg->size;\n\n\tfunc_no = ntb->epf->func_no;\n\tvfunc_no = ntb->epf->vfunc_no;\n\n\tret = pci_epc_map_addr(ntb->epf->epc, func_no, vfunc_no, phys_addr, addr, size);\n\tif (ret)\n\t\tdev_err(&ntb->epf->epc->dev,\n\t\t\t\"Failed to map memory window %d address\\n\", mw);\n\treturn ret;\n}\n\n \nstatic void epf_ntb_teardown_mw(struct epf_ntb *ntb, u32 mw)\n{\n\tpci_epc_unmap_addr(ntb->epf->epc,\n\t\t\t   ntb->epf->func_no,\n\t\t\t   ntb->epf->vfunc_no,\n\t\t\t   ntb->vpci_mw_phy[mw]);\n}\n\n \nstatic void epf_ntb_cmd_handler(struct work_struct *work)\n{\n\tstruct epf_ntb_ctrl *ctrl;\n\tu32 command, argument;\n\tstruct epf_ntb *ntb;\n\tstruct device *dev;\n\tint ret;\n\tint i;\n\n\tntb = container_of(work, struct epf_ntb, cmd_handler.work);\n\n\tfor (i = 1; i < ntb->db_count; i++) {\n\t\tif (ntb->epf_db[i]) {\n\t\t\tntb->db |= 1 << (i - 1);\n\t\t\tntb_db_event(&ntb->ntb, i);\n\t\t\tntb->epf_db[i] = 0;\n\t\t}\n\t}\n\n\tctrl = ntb->reg;\n\tcommand = ctrl->command;\n\tif (!command)\n\t\tgoto reset_handler;\n\targument = ctrl->argument;\n\n\tctrl->command = 0;\n\tctrl->argument = 0;\n\n\tctrl = ntb->reg;\n\tdev = &ntb->epf->dev;\n\n\tswitch (command) {\n\tcase COMMAND_CONFIGURE_DOORBELL:\n\t\tctrl->command_status = COMMAND_STATUS_OK;\n\t\tbreak;\n\tcase COMMAND_TEARDOWN_DOORBELL:\n\t\tctrl->command_status = COMMAND_STATUS_OK;\n\t\tbreak;\n\tcase COMMAND_CONFIGURE_MW:\n\t\tret = epf_ntb_configure_mw(ntb, argument);\n\t\tif (ret < 0)\n\t\t\tctrl->command_status = COMMAND_STATUS_ERROR;\n\t\telse\n\t\t\tctrl->command_status = COMMAND_STATUS_OK;\n\t\tbreak;\n\tcase COMMAND_TEARDOWN_MW:\n\t\tepf_ntb_teardown_mw(ntb, argument);\n\t\tctrl->command_status = COMMAND_STATUS_OK;\n\t\tbreak;\n\tcase COMMAND_LINK_UP:\n\t\tntb->linkup = true;\n\t\tret = epf_ntb_link_up(ntb, true);\n\t\tif (ret < 0)\n\t\t\tctrl->command_status = COMMAND_STATUS_ERROR;\n\t\telse\n\t\t\tctrl->command_status = COMMAND_STATUS_OK;\n\t\tgoto reset_handler;\n\tcase COMMAND_LINK_DOWN:\n\t\tntb->linkup = false;\n\t\tret = epf_ntb_link_up(ntb, false);\n\t\tif (ret < 0)\n\t\t\tctrl->command_status = COMMAND_STATUS_ERROR;\n\t\telse\n\t\t\tctrl->command_status = COMMAND_STATUS_OK;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"UNKNOWN command: %d\\n\", command);\n\t\tbreak;\n\t}\n\nreset_handler:\n\tqueue_delayed_work(kpcintb_workqueue, &ntb->cmd_handler,\n\t\t\t   msecs_to_jiffies(5));\n}\n\n \nstatic void epf_ntb_config_sspad_bar_clear(struct epf_ntb *ntb)\n{\n\tstruct pci_epf_bar *epf_bar;\n\tenum pci_barno barno;\n\n\tbarno = ntb->epf_ntb_bar[BAR_CONFIG];\n\tepf_bar = &ntb->epf->bar[barno];\n\n\tpci_epc_clear_bar(ntb->epf->epc, ntb->epf->func_no, ntb->epf->vfunc_no, epf_bar);\n}\n\n \nstatic int epf_ntb_config_sspad_bar_set(struct epf_ntb *ntb)\n{\n\tstruct pci_epf_bar *epf_bar;\n\tenum pci_barno barno;\n\tu8 func_no, vfunc_no;\n\tstruct device *dev;\n\tint ret;\n\n\tdev = &ntb->epf->dev;\n\tfunc_no = ntb->epf->func_no;\n\tvfunc_no = ntb->epf->vfunc_no;\n\tbarno = ntb->epf_ntb_bar[BAR_CONFIG];\n\tepf_bar = &ntb->epf->bar[barno];\n\n\tret = pci_epc_set_bar(ntb->epf->epc, func_no, vfunc_no, epf_bar);\n\tif (ret) {\n\t\tdev_err(dev, \"inft: Config/Status/SPAD BAR set failed\\n\");\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\n \nstatic void epf_ntb_config_spad_bar_free(struct epf_ntb *ntb)\n{\n\tenum pci_barno barno;\n\n\tbarno = ntb->epf_ntb_bar[BAR_CONFIG];\n\tpci_epf_free_space(ntb->epf, ntb->reg, barno, 0);\n}\n\n \nstatic int epf_ntb_config_spad_bar_alloc(struct epf_ntb *ntb)\n{\n\tsize_t align;\n\tenum pci_barno barno;\n\tstruct epf_ntb_ctrl *ctrl;\n\tu32 spad_size, ctrl_size;\n\tu64 size;\n\tstruct pci_epf *epf = ntb->epf;\n\tstruct device *dev = &epf->dev;\n\tu32 spad_count;\n\tvoid *base;\n\tint i;\n\tconst struct pci_epc_features *epc_features = pci_epc_get_features(epf->epc,\n\t\t\t\t\t\t\t\tepf->func_no,\n\t\t\t\t\t\t\t\tepf->vfunc_no);\n\tbarno = ntb->epf_ntb_bar[BAR_CONFIG];\n\tsize = epc_features->bar_fixed_size[barno];\n\talign = epc_features->align;\n\n\tif ((!IS_ALIGNED(size, align)))\n\t\treturn -EINVAL;\n\n\tspad_count = ntb->spad_count;\n\n\tctrl_size = sizeof(struct epf_ntb_ctrl);\n\tspad_size = 2 * spad_count * sizeof(u32);\n\n\tif (!align) {\n\t\tctrl_size = roundup_pow_of_two(ctrl_size);\n\t\tspad_size = roundup_pow_of_two(spad_size);\n\t} else {\n\t\tctrl_size = ALIGN(ctrl_size, align);\n\t\tspad_size = ALIGN(spad_size, align);\n\t}\n\n\tif (!size)\n\t\tsize = ctrl_size + spad_size;\n\telse if (size < ctrl_size + spad_size)\n\t\treturn -EINVAL;\n\n\tbase = pci_epf_alloc_space(epf, size, barno, align, 0);\n\tif (!base) {\n\t\tdev_err(dev, \"Config/Status/SPAD alloc region fail\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tntb->reg = base;\n\n\tctrl = ntb->reg;\n\tctrl->spad_offset = ctrl_size;\n\n\tctrl->spad_count = spad_count;\n\tctrl->num_mws = ntb->num_mws;\n\tntb->spad_size = spad_size;\n\n\tctrl->db_entry_size = sizeof(u32);\n\n\tfor (i = 0; i < ntb->db_count; i++) {\n\t\tntb->reg->db_data[i] = 1 + i;\n\t\tntb->reg->db_offset[i] = 0;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int epf_ntb_configure_interrupt(struct epf_ntb *ntb)\n{\n\tconst struct pci_epc_features *epc_features;\n\tstruct device *dev;\n\tu32 db_count;\n\tint ret;\n\n\tdev = &ntb->epf->dev;\n\n\tepc_features = pci_epc_get_features(ntb->epf->epc, ntb->epf->func_no, ntb->epf->vfunc_no);\n\n\tif (!(epc_features->msix_capable || epc_features->msi_capable)) {\n\t\tdev_err(dev, \"MSI or MSI-X is required for doorbell\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdb_count = ntb->db_count;\n\tif (db_count > MAX_DB_COUNT) {\n\t\tdev_err(dev, \"DB count cannot be more than %d\\n\", MAX_DB_COUNT);\n\t\treturn -EINVAL;\n\t}\n\n\tntb->db_count = db_count;\n\n\tif (epc_features->msi_capable) {\n\t\tret = pci_epc_set_msi(ntb->epf->epc,\n\t\t\t\t      ntb->epf->func_no,\n\t\t\t\t      ntb->epf->vfunc_no,\n\t\t\t\t      16);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"MSI configuration failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int epf_ntb_db_bar_init(struct epf_ntb *ntb)\n{\n\tconst struct pci_epc_features *epc_features;\n\tu32 align;\n\tstruct device *dev = &ntb->epf->dev;\n\tint ret;\n\tstruct pci_epf_bar *epf_bar;\n\tvoid __iomem *mw_addr;\n\tenum pci_barno barno;\n\tsize_t size = sizeof(u32) * ntb->db_count;\n\n\tepc_features = pci_epc_get_features(ntb->epf->epc,\n\t\t\t\t\t    ntb->epf->func_no,\n\t\t\t\t\t    ntb->epf->vfunc_no);\n\talign = epc_features->align;\n\n\tif (size < 128)\n\t\tsize = 128;\n\n\tif (align)\n\t\tsize = ALIGN(size, align);\n\telse\n\t\tsize = roundup_pow_of_two(size);\n\n\tbarno = ntb->epf_ntb_bar[BAR_DB];\n\n\tmw_addr = pci_epf_alloc_space(ntb->epf, size, barno, align, 0);\n\tif (!mw_addr) {\n\t\tdev_err(dev, \"Failed to allocate OB address\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tntb->epf_db = mw_addr;\n\n\tepf_bar = &ntb->epf->bar[barno];\n\n\tret = pci_epc_set_bar(ntb->epf->epc, ntb->epf->func_no, ntb->epf->vfunc_no, epf_bar);\n\tif (ret) {\n\t\tdev_err(dev, \"Doorbell BAR set failed\\n\");\n\t\t\tgoto err_alloc_peer_mem;\n\t}\n\treturn ret;\n\nerr_alloc_peer_mem:\n\tpci_epf_free_space(ntb->epf, mw_addr, barno, 0);\n\treturn -1;\n}\n\nstatic void epf_ntb_mw_bar_clear(struct epf_ntb *ntb, int num_mws);\n\n \nstatic void epf_ntb_db_bar_clear(struct epf_ntb *ntb)\n{\n\tenum pci_barno barno;\n\n\tbarno = ntb->epf_ntb_bar[BAR_DB];\n\tpci_epf_free_space(ntb->epf, ntb->epf_db, barno, 0);\n\tpci_epc_clear_bar(ntb->epf->epc,\n\t\t\t  ntb->epf->func_no,\n\t\t\t  ntb->epf->vfunc_no,\n\t\t\t  &ntb->epf->bar[barno]);\n}\n\n \nstatic int epf_ntb_mw_bar_init(struct epf_ntb *ntb)\n{\n\tint ret = 0;\n\tint i;\n\tu64 size;\n\tenum pci_barno barno;\n\tstruct device *dev = &ntb->epf->dev;\n\n\tfor (i = 0; i < ntb->num_mws; i++) {\n\t\tsize = ntb->mws_size[i];\n\t\tbarno = ntb->epf_ntb_bar[BAR_MW0 + i];\n\n\t\tntb->epf->bar[barno].barno = barno;\n\t\tntb->epf->bar[barno].size = size;\n\t\tntb->epf->bar[barno].addr = NULL;\n\t\tntb->epf->bar[barno].phys_addr = 0;\n\t\tntb->epf->bar[barno].flags |= upper_32_bits(size) ?\n\t\t\t\tPCI_BASE_ADDRESS_MEM_TYPE_64 :\n\t\t\t\tPCI_BASE_ADDRESS_MEM_TYPE_32;\n\n\t\tret = pci_epc_set_bar(ntb->epf->epc,\n\t\t\t\t      ntb->epf->func_no,\n\t\t\t\t      ntb->epf->vfunc_no,\n\t\t\t\t      &ntb->epf->bar[barno]);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"MW set failed\\n\");\n\t\t\tgoto err_alloc_mem;\n\t\t}\n\n\t\t \n\t\tntb->vpci_mw_addr[i] = pci_epc_mem_alloc_addr(ntb->epf->epc,\n\t\t\t\t\t\t\t      &ntb->vpci_mw_phy[i],\n\t\t\t\t\t\t\t      size);\n\t\tif (!ntb->vpci_mw_addr[i]) {\n\t\t\tret = -ENOMEM;\n\t\t\tdev_err(dev, \"Failed to allocate source address\\n\");\n\t\t\tgoto err_set_bar;\n\t\t}\n\t}\n\n\treturn ret;\n\nerr_set_bar:\n\tpci_epc_clear_bar(ntb->epf->epc,\n\t\t\t  ntb->epf->func_no,\n\t\t\t  ntb->epf->vfunc_no,\n\t\t\t  &ntb->epf->bar[barno]);\nerr_alloc_mem:\n\tepf_ntb_mw_bar_clear(ntb, i);\n\treturn ret;\n}\n\n \nstatic void epf_ntb_mw_bar_clear(struct epf_ntb *ntb, int num_mws)\n{\n\tenum pci_barno barno;\n\tint i;\n\n\tfor (i = 0; i < num_mws; i++) {\n\t\tbarno = ntb->epf_ntb_bar[BAR_MW0 + i];\n\t\tpci_epc_clear_bar(ntb->epf->epc,\n\t\t\t\t  ntb->epf->func_no,\n\t\t\t\t  ntb->epf->vfunc_no,\n\t\t\t\t  &ntb->epf->bar[barno]);\n\n\t\tpci_epc_mem_free_addr(ntb->epf->epc,\n\t\t\t\t      ntb->vpci_mw_phy[i],\n\t\t\t\t      ntb->vpci_mw_addr[i],\n\t\t\t\t      ntb->mws_size[i]);\n\t}\n}\n\n \nstatic void epf_ntb_epc_destroy(struct epf_ntb *ntb)\n{\n\tpci_epc_remove_epf(ntb->epf->epc, ntb->epf, 0);\n\tpci_epc_put(ntb->epf->epc);\n}\n\n \nstatic int epf_ntb_init_epc_bar(struct epf_ntb *ntb)\n{\n\tconst struct pci_epc_features *epc_features;\n\tenum pci_barno barno;\n\tenum epf_ntb_bar bar;\n\tstruct device *dev;\n\tu32 num_mws;\n\tint i;\n\n\tbarno = BAR_0;\n\tnum_mws = ntb->num_mws;\n\tdev = &ntb->epf->dev;\n\tepc_features = pci_epc_get_features(ntb->epf->epc, ntb->epf->func_no, ntb->epf->vfunc_no);\n\n\t \n\tfor (bar = BAR_CONFIG; bar <= BAR_MW0; bar++, barno++) {\n\t\tbarno = pci_epc_get_next_free_bar(epc_features, barno);\n\t\tif (barno < 0) {\n\t\t\tdev_err(dev, \"Fail to get NTB function BAR\\n\");\n\t\t\treturn barno;\n\t\t}\n\t\tntb->epf_ntb_bar[bar] = barno;\n\t}\n\n\t \n\tfor (bar = BAR_MW1, i = 1; i < num_mws; bar++, barno++, i++) {\n\t\tbarno = pci_epc_get_next_free_bar(epc_features, barno);\n\t\tif (barno < 0) {\n\t\t\tntb->num_mws = i;\n\t\t\tdev_dbg(dev, \"BAR not available for > MW%d\\n\", i + 1);\n\t\t}\n\t\tntb->epf_ntb_bar[bar] = barno;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int epf_ntb_epc_init(struct epf_ntb *ntb)\n{\n\tu8 func_no, vfunc_no;\n\tstruct pci_epc *epc;\n\tstruct pci_epf *epf;\n\tstruct device *dev;\n\tint ret;\n\n\tepf = ntb->epf;\n\tdev = &epf->dev;\n\tepc = epf->epc;\n\tfunc_no = ntb->epf->func_no;\n\tvfunc_no = ntb->epf->vfunc_no;\n\n\tret = epf_ntb_config_sspad_bar_set(ntb);\n\tif (ret) {\n\t\tdev_err(dev, \"Config/self SPAD BAR init failed\");\n\t\treturn ret;\n\t}\n\n\tret = epf_ntb_configure_interrupt(ntb);\n\tif (ret) {\n\t\tdev_err(dev, \"Interrupt configuration failed\\n\");\n\t\tgoto err_config_interrupt;\n\t}\n\n\tret = epf_ntb_db_bar_init(ntb);\n\tif (ret) {\n\t\tdev_err(dev, \"DB BAR init failed\\n\");\n\t\tgoto err_db_bar_init;\n\t}\n\n\tret = epf_ntb_mw_bar_init(ntb);\n\tif (ret) {\n\t\tdev_err(dev, \"MW BAR init failed\\n\");\n\t\tgoto err_mw_bar_init;\n\t}\n\n\tif (vfunc_no <= 1) {\n\t\tret = pci_epc_write_header(epc, func_no, vfunc_no, epf->header);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Configuration header write failed\\n\");\n\t\t\tgoto err_write_header;\n\t\t}\n\t}\n\n\tINIT_DELAYED_WORK(&ntb->cmd_handler, epf_ntb_cmd_handler);\n\tqueue_work(kpcintb_workqueue, &ntb->cmd_handler.work);\n\n\treturn 0;\n\nerr_write_header:\n\tepf_ntb_mw_bar_clear(ntb, ntb->num_mws);\nerr_mw_bar_init:\n\tepf_ntb_db_bar_clear(ntb);\nerr_db_bar_init:\nerr_config_interrupt:\n\tepf_ntb_config_sspad_bar_clear(ntb);\n\n\treturn ret;\n}\n\n\n \nstatic void epf_ntb_epc_cleanup(struct epf_ntb *ntb)\n{\n\tepf_ntb_db_bar_clear(ntb);\n\tepf_ntb_mw_bar_clear(ntb, ntb->num_mws);\n}\n\n#define EPF_NTB_R(_name)\t\t\t\t\t\t\\\nstatic ssize_t epf_ntb_##_name##_show(struct config_item *item,\t\t\\\n\t\t\t\t      char *page)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct config_group *group = to_config_group(item);\t\t\\\n\tstruct epf_ntb *ntb = to_epf_ntb(group);\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\treturn sprintf(page, \"%d\\n\", ntb->_name);\t\t\t\\\n}\n\n#define EPF_NTB_W(_name)\t\t\t\t\t\t\\\nstatic ssize_t epf_ntb_##_name##_store(struct config_item *item,\t\\\n\t\t\t\t       const char *page, size_t len)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct config_group *group = to_config_group(item);\t\t\\\n\tstruct epf_ntb *ntb = to_epf_ntb(group);\t\t\t\\\n\tu32 val;\t\t\t\t\t\t\t\\\n\tint ret;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tret = kstrtou32(page, 0, &val);\t\t\t\t\t\\\n\tif (ret)\t\t\t\t\t\t\t\\\n\t\treturn ret;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tntb->_name = val;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\treturn len;\t\t\t\t\t\t\t\\\n}\n\n#define EPF_NTB_MW_R(_name)\t\t\t\t\t\t\\\nstatic ssize_t epf_ntb_##_name##_show(struct config_item *item,\t\t\\\n\t\t\t\t      char *page)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct config_group *group = to_config_group(item);\t\t\\\n\tstruct epf_ntb *ntb = to_epf_ntb(group);\t\t\t\\\n\tstruct device *dev = &ntb->epf->dev;\t\t\t\t\\\n\tint win_no;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (sscanf(#_name, \"mw%d\", &win_no) != 1)\t\t\t\\\n\t\treturn -EINVAL;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (win_no <= 0 || win_no > ntb->num_mws) {\t\t\t\\\n\t\tdev_err(dev, \"Invalid num_nws: %d value\\n\", ntb->num_mws); \\\n\t\treturn -EINVAL;\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\treturn sprintf(page, \"%lld\\n\", ntb->mws_size[win_no - 1]);\t\\\n}\n\n#define EPF_NTB_MW_W(_name)\t\t\t\t\t\t\\\nstatic ssize_t epf_ntb_##_name##_store(struct config_item *item,\t\\\n\t\t\t\t       const char *page, size_t len)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct config_group *group = to_config_group(item);\t\t\\\n\tstruct epf_ntb *ntb = to_epf_ntb(group);\t\t\t\\\n\tstruct device *dev = &ntb->epf->dev;\t\t\t\t\\\n\tint win_no;\t\t\t\t\t\t\t\\\n\tu64 val;\t\t\t\t\t\t\t\\\n\tint ret;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tret = kstrtou64(page, 0, &val);\t\t\t\t\t\\\n\tif (ret)\t\t\t\t\t\t\t\\\n\t\treturn ret;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (sscanf(#_name, \"mw%d\", &win_no) != 1)\t\t\t\\\n\t\treturn -EINVAL;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (win_no <= 0 || win_no > ntb->num_mws) {\t\t\t\\\n\t\tdev_err(dev, \"Invalid num_nws: %d value\\n\", ntb->num_mws); \\\n\t\treturn -EINVAL;\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tntb->mws_size[win_no - 1] = val;\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\treturn len;\t\t\t\t\t\t\t\\\n}\n\nstatic ssize_t epf_ntb_num_mws_store(struct config_item *item,\n\t\t\t\t     const char *page, size_t len)\n{\n\tstruct config_group *group = to_config_group(item);\n\tstruct epf_ntb *ntb = to_epf_ntb(group);\n\tu32 val;\n\tint ret;\n\n\tret = kstrtou32(page, 0, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (val > MAX_MW)\n\t\treturn -EINVAL;\n\n\tntb->num_mws = val;\n\n\treturn len;\n}\n\nEPF_NTB_R(spad_count)\nEPF_NTB_W(spad_count)\nEPF_NTB_R(db_count)\nEPF_NTB_W(db_count)\nEPF_NTB_R(num_mws)\nEPF_NTB_R(vbus_number)\nEPF_NTB_W(vbus_number)\nEPF_NTB_R(vntb_pid)\nEPF_NTB_W(vntb_pid)\nEPF_NTB_R(vntb_vid)\nEPF_NTB_W(vntb_vid)\nEPF_NTB_MW_R(mw1)\nEPF_NTB_MW_W(mw1)\nEPF_NTB_MW_R(mw2)\nEPF_NTB_MW_W(mw2)\nEPF_NTB_MW_R(mw3)\nEPF_NTB_MW_W(mw3)\nEPF_NTB_MW_R(mw4)\nEPF_NTB_MW_W(mw4)\n\nCONFIGFS_ATTR(epf_ntb_, spad_count);\nCONFIGFS_ATTR(epf_ntb_, db_count);\nCONFIGFS_ATTR(epf_ntb_, num_mws);\nCONFIGFS_ATTR(epf_ntb_, mw1);\nCONFIGFS_ATTR(epf_ntb_, mw2);\nCONFIGFS_ATTR(epf_ntb_, mw3);\nCONFIGFS_ATTR(epf_ntb_, mw4);\nCONFIGFS_ATTR(epf_ntb_, vbus_number);\nCONFIGFS_ATTR(epf_ntb_, vntb_pid);\nCONFIGFS_ATTR(epf_ntb_, vntb_vid);\n\nstatic struct configfs_attribute *epf_ntb_attrs[] = {\n\t&epf_ntb_attr_spad_count,\n\t&epf_ntb_attr_db_count,\n\t&epf_ntb_attr_num_mws,\n\t&epf_ntb_attr_mw1,\n\t&epf_ntb_attr_mw2,\n\t&epf_ntb_attr_mw3,\n\t&epf_ntb_attr_mw4,\n\t&epf_ntb_attr_vbus_number,\n\t&epf_ntb_attr_vntb_pid,\n\t&epf_ntb_attr_vntb_vid,\n\tNULL,\n};\n\nstatic const struct config_item_type ntb_group_type = {\n\t.ct_attrs\t= epf_ntb_attrs,\n\t.ct_owner\t= THIS_MODULE,\n};\n\n \nstatic struct config_group *epf_ntb_add_cfs(struct pci_epf *epf,\n\t\t\t\t\t    struct config_group *group)\n{\n\tstruct epf_ntb *ntb = epf_get_drvdata(epf);\n\tstruct config_group *ntb_group = &ntb->group;\n\tstruct device *dev = &epf->dev;\n\n\tconfig_group_init_type_name(ntb_group, dev_name(dev), &ntb_group_type);\n\n\treturn ntb_group;\n}\n\n \n\nstatic u32 pci_space[] = {\n\t0xffffffff,\t \n\t0,\t\t \n\t0xffffffff,\t \n\t0x40,\t\t \n\t0,\t\t \n\t0,\t\t \n\t0,\t\t \n\t0,\t\t \n\t0,\t\t \n\t0,\t\t \n\t0,\t\t \n\t0,\t\t \n\t0,\t\t \n\t0,\t\t \n\t0,\t\t \n\t0,\t\t \n};\n\nstatic int pci_read(struct pci_bus *bus, unsigned int devfn, int where, int size, u32 *val)\n{\n\tif (devfn == 0) {\n\t\tmemcpy(val, ((u8 *)pci_space) + where, size);\n\t\treturn PCIBIOS_SUCCESSFUL;\n\t}\n\treturn PCIBIOS_DEVICE_NOT_FOUND;\n}\n\nstatic int pci_write(struct pci_bus *bus, unsigned int devfn, int where, int size, u32 val)\n{\n\treturn 0;\n}\n\nstatic struct pci_ops vpci_ops = {\n\t.read = pci_read,\n\t.write = pci_write,\n};\n\nstatic int vpci_scan_bus(void *sysdata)\n{\n\tstruct pci_bus *vpci_bus;\n\tstruct epf_ntb *ndev = sysdata;\n\n\tvpci_bus = pci_scan_bus(ndev->vbus_number, &vpci_ops, sysdata);\n\tif (vpci_bus)\n\t\tpr_err(\"create pci bus\\n\");\n\n\tpci_bus_add_devices(vpci_bus);\n\n\treturn 0;\n}\n\n \n\nstatic int vntb_epf_mw_count(struct ntb_dev *ntb, int pidx)\n{\n\tstruct epf_ntb *ndev = ntb_ndev(ntb);\n\n\treturn ndev->num_mws;\n}\n\nstatic int vntb_epf_spad_count(struct ntb_dev *ntb)\n{\n\treturn ntb_ndev(ntb)->spad_count;\n}\n\nstatic int vntb_epf_peer_mw_count(struct ntb_dev *ntb)\n{\n\treturn ntb_ndev(ntb)->num_mws;\n}\n\nstatic u64 vntb_epf_db_valid_mask(struct ntb_dev *ntb)\n{\n\treturn BIT_ULL(ntb_ndev(ntb)->db_count) - 1;\n}\n\nstatic int vntb_epf_db_set_mask(struct ntb_dev *ntb, u64 db_bits)\n{\n\treturn 0;\n}\n\nstatic int vntb_epf_mw_set_trans(struct ntb_dev *ndev, int pidx, int idx,\n\t\tdma_addr_t addr, resource_size_t size)\n{\n\tstruct epf_ntb *ntb = ntb_ndev(ndev);\n\tstruct pci_epf_bar *epf_bar;\n\tenum pci_barno barno;\n\tint ret;\n\tstruct device *dev;\n\n\tdev = &ntb->ntb.dev;\n\tbarno = ntb->epf_ntb_bar[BAR_MW0 + idx];\n\tepf_bar = &ntb->epf->bar[barno];\n\tepf_bar->phys_addr = addr;\n\tepf_bar->barno = barno;\n\tepf_bar->size = size;\n\n\tret = pci_epc_set_bar(ntb->epf->epc, 0, 0, epf_bar);\n\tif (ret) {\n\t\tdev_err(dev, \"failure set mw trans\\n\");\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic int vntb_epf_mw_clear_trans(struct ntb_dev *ntb, int pidx, int idx)\n{\n\treturn 0;\n}\n\nstatic int vntb_epf_peer_mw_get_addr(struct ntb_dev *ndev, int idx,\n\t\t\t\tphys_addr_t *base, resource_size_t *size)\n{\n\n\tstruct epf_ntb *ntb = ntb_ndev(ndev);\n\n\tif (base)\n\t\t*base = ntb->vpci_mw_phy[idx];\n\n\tif (size)\n\t\t*size = ntb->mws_size[idx];\n\n\treturn 0;\n}\n\nstatic int vntb_epf_link_enable(struct ntb_dev *ntb,\n\t\t\tenum ntb_speed max_speed,\n\t\t\tenum ntb_width max_width)\n{\n\treturn 0;\n}\n\nstatic u32 vntb_epf_spad_read(struct ntb_dev *ndev, int idx)\n{\n\tstruct epf_ntb *ntb = ntb_ndev(ndev);\n\tint off = ntb->reg->spad_offset, ct = ntb->reg->spad_count * sizeof(u32);\n\tu32 val;\n\tvoid __iomem *base = (void __iomem *)ntb->reg;\n\n\tval = readl(base + off + ct + idx * sizeof(u32));\n\treturn val;\n}\n\nstatic int vntb_epf_spad_write(struct ntb_dev *ndev, int idx, u32 val)\n{\n\tstruct epf_ntb *ntb = ntb_ndev(ndev);\n\tstruct epf_ntb_ctrl *ctrl = ntb->reg;\n\tint off = ctrl->spad_offset, ct = ctrl->spad_count * sizeof(u32);\n\tvoid __iomem *base = (void __iomem *)ntb->reg;\n\n\twritel(val, base + off + ct + idx * sizeof(u32));\n\treturn 0;\n}\n\nstatic u32 vntb_epf_peer_spad_read(struct ntb_dev *ndev, int pidx, int idx)\n{\n\tstruct epf_ntb *ntb = ntb_ndev(ndev);\n\tstruct epf_ntb_ctrl *ctrl = ntb->reg;\n\tint off = ctrl->spad_offset;\n\tvoid __iomem *base = (void __iomem *)ntb->reg;\n\tu32 val;\n\n\tval = readl(base + off + idx * sizeof(u32));\n\treturn val;\n}\n\nstatic int vntb_epf_peer_spad_write(struct ntb_dev *ndev, int pidx, int idx, u32 val)\n{\n\tstruct epf_ntb *ntb = ntb_ndev(ndev);\n\tstruct epf_ntb_ctrl *ctrl = ntb->reg;\n\tint off = ctrl->spad_offset;\n\tvoid __iomem *base = (void __iomem *)ntb->reg;\n\n\twritel(val, base + off + idx * sizeof(u32));\n\treturn 0;\n}\n\nstatic int vntb_epf_peer_db_set(struct ntb_dev *ndev, u64 db_bits)\n{\n\tu32 interrupt_num = ffs(db_bits) + 1;\n\tstruct epf_ntb *ntb = ntb_ndev(ndev);\n\tu8 func_no, vfunc_no;\n\tint ret;\n\n\tfunc_no = ntb->epf->func_no;\n\tvfunc_no = ntb->epf->vfunc_no;\n\n\tret = pci_epc_raise_irq(ntb->epf->epc,\n\t\t\t\tfunc_no,\n\t\t\t\tvfunc_no,\n\t\t\t\tPCI_EPC_IRQ_MSI,\n\t\t\t\tinterrupt_num + 1);\n\tif (ret)\n\t\tdev_err(&ntb->ntb.dev, \"Failed to raise IRQ\\n\");\n\n\treturn ret;\n}\n\nstatic u64 vntb_epf_db_read(struct ntb_dev *ndev)\n{\n\tstruct epf_ntb *ntb = ntb_ndev(ndev);\n\n\treturn ntb->db;\n}\n\nstatic int vntb_epf_mw_get_align(struct ntb_dev *ndev, int pidx, int idx,\n\t\t\tresource_size_t *addr_align,\n\t\t\tresource_size_t *size_align,\n\t\t\tresource_size_t *size_max)\n{\n\tstruct epf_ntb *ntb = ntb_ndev(ndev);\n\n\tif (addr_align)\n\t\t*addr_align = SZ_4K;\n\n\tif (size_align)\n\t\t*size_align = 1;\n\n\tif (size_max)\n\t\t*size_max = ntb->mws_size[idx];\n\n\treturn 0;\n}\n\nstatic u64 vntb_epf_link_is_up(struct ntb_dev *ndev,\n\t\t\tenum ntb_speed *speed,\n\t\t\tenum ntb_width *width)\n{\n\tstruct epf_ntb *ntb = ntb_ndev(ndev);\n\n\treturn ntb->reg->link_status;\n}\n\nstatic int vntb_epf_db_clear_mask(struct ntb_dev *ndev, u64 db_bits)\n{\n\treturn 0;\n}\n\nstatic int vntb_epf_db_clear(struct ntb_dev *ndev, u64 db_bits)\n{\n\tstruct epf_ntb *ntb = ntb_ndev(ndev);\n\n\tntb->db &= ~db_bits;\n\treturn 0;\n}\n\nstatic int vntb_epf_link_disable(struct ntb_dev *ntb)\n{\n\treturn 0;\n}\n\nstatic const struct ntb_dev_ops vntb_epf_ops = {\n\t.mw_count\t\t= vntb_epf_mw_count,\n\t.spad_count\t\t= vntb_epf_spad_count,\n\t.peer_mw_count\t\t= vntb_epf_peer_mw_count,\n\t.db_valid_mask\t\t= vntb_epf_db_valid_mask,\n\t.db_set_mask\t\t= vntb_epf_db_set_mask,\n\t.mw_set_trans\t\t= vntb_epf_mw_set_trans,\n\t.mw_clear_trans\t\t= vntb_epf_mw_clear_trans,\n\t.peer_mw_get_addr\t= vntb_epf_peer_mw_get_addr,\n\t.link_enable\t\t= vntb_epf_link_enable,\n\t.spad_read\t\t= vntb_epf_spad_read,\n\t.spad_write\t\t= vntb_epf_spad_write,\n\t.peer_spad_read\t\t= vntb_epf_peer_spad_read,\n\t.peer_spad_write\t= vntb_epf_peer_spad_write,\n\t.peer_db_set\t\t= vntb_epf_peer_db_set,\n\t.db_read\t\t= vntb_epf_db_read,\n\t.mw_get_align\t\t= vntb_epf_mw_get_align,\n\t.link_is_up\t\t= vntb_epf_link_is_up,\n\t.db_clear_mask\t\t= vntb_epf_db_clear_mask,\n\t.db_clear\t\t= vntb_epf_db_clear,\n\t.link_disable\t\t= vntb_epf_link_disable,\n};\n\nstatic int pci_vntb_probe(struct pci_dev *pdev, const struct pci_device_id *id)\n{\n\tint ret;\n\tstruct epf_ntb *ndev = (struct epf_ntb *)pdev->sysdata;\n\tstruct device *dev = &pdev->dev;\n\n\tndev->ntb.pdev = pdev;\n\tndev->ntb.topo = NTB_TOPO_NONE;\n\tndev->ntb.ops =  &vntb_epf_ops;\n\n\tret = dma_set_mask_and_coherent(dev, DMA_BIT_MASK(32));\n\tif (ret) {\n\t\tdev_err(dev, \"Cannot set DMA mask\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = ntb_register_device(&ndev->ntb);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to register NTB device\\n\");\n\t\tgoto err_register_dev;\n\t}\n\n\tdev_dbg(dev, \"PCI Virtual NTB driver loaded\\n\");\n\treturn 0;\n\nerr_register_dev:\n\tput_device(&ndev->ntb.dev);\n\treturn -EINVAL;\n}\n\nstatic struct pci_device_id pci_vntb_table[] = {\n\t{\n\t\tPCI_DEVICE(0xffff, 0xffff),\n\t},\n\t{},\n};\n\nstatic struct pci_driver vntb_pci_driver = {\n\t.name           = \"pci-vntb\",\n\t.id_table       = pci_vntb_table,\n\t.probe          = pci_vntb_probe,\n};\n\n \n\n \nstatic int epf_ntb_bind(struct pci_epf *epf)\n{\n\tstruct epf_ntb *ntb = epf_get_drvdata(epf);\n\tstruct device *dev = &epf->dev;\n\tint ret;\n\n\tif (!epf->epc) {\n\t\tdev_dbg(dev, \"PRIMARY EPC interface not yet bound\\n\");\n\t\treturn 0;\n\t}\n\n\tret = epf_ntb_init_epc_bar(ntb);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to create NTB EPC\\n\");\n\t\tgoto err_bar_init;\n\t}\n\n\tret = epf_ntb_config_spad_bar_alloc(ntb);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to allocate BAR memory\\n\");\n\t\tgoto err_bar_alloc;\n\t}\n\n\tret = epf_ntb_epc_init(ntb);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to initialize EPC\\n\");\n\t\tgoto err_bar_alloc;\n\t}\n\n\tepf_set_drvdata(epf, ntb);\n\n\tpci_space[0] = (ntb->vntb_pid << 16) | ntb->vntb_vid;\n\tpci_vntb_table[0].vendor = ntb->vntb_vid;\n\tpci_vntb_table[0].device = ntb->vntb_pid;\n\n\tret = pci_register_driver(&vntb_pci_driver);\n\tif (ret) {\n\t\tdev_err(dev, \"failure register vntb pci driver\\n\");\n\t\tgoto err_bar_alloc;\n\t}\n\n\tvpci_scan_bus(ntb);\n\n\treturn 0;\n\nerr_bar_alloc:\n\tepf_ntb_config_spad_bar_free(ntb);\n\nerr_bar_init:\n\tepf_ntb_epc_destroy(ntb);\n\n\treturn ret;\n}\n\n \nstatic void epf_ntb_unbind(struct pci_epf *epf)\n{\n\tstruct epf_ntb *ntb = epf_get_drvdata(epf);\n\n\tepf_ntb_epc_cleanup(ntb);\n\tepf_ntb_config_spad_bar_free(ntb);\n\tepf_ntb_epc_destroy(ntb);\n\n\tpci_unregister_driver(&vntb_pci_driver);\n}\n\n\nstatic struct pci_epf_ops epf_ntb_ops = {\n\t.bind   = epf_ntb_bind,\n\t.unbind = epf_ntb_unbind,\n\t.add_cfs = epf_ntb_add_cfs,\n};\n\n \nstatic int epf_ntb_probe(struct pci_epf *epf,\n\t\t\t const struct pci_epf_device_id *id)\n{\n\tstruct epf_ntb *ntb;\n\tstruct device *dev;\n\n\tdev = &epf->dev;\n\n\tntb = devm_kzalloc(dev, sizeof(*ntb), GFP_KERNEL);\n\tif (!ntb)\n\t\treturn -ENOMEM;\n\n\tepf->header = &epf_ntb_header;\n\tntb->epf = epf;\n\tntb->vbus_number = 0xff;\n\tepf_set_drvdata(epf, ntb);\n\n\tdev_info(dev, \"pci-ep epf driver loaded\\n\");\n\treturn 0;\n}\n\nstatic const struct pci_epf_device_id epf_ntb_ids[] = {\n\t{\n\t\t.name = \"pci_epf_vntb\",\n\t},\n\t{},\n};\n\nstatic struct pci_epf_driver epf_ntb_driver = {\n\t.driver.name    = \"pci_epf_vntb\",\n\t.probe          = epf_ntb_probe,\n\t.id_table       = epf_ntb_ids,\n\t.ops            = &epf_ntb_ops,\n\t.owner          = THIS_MODULE,\n};\n\nstatic int __init epf_ntb_init(void)\n{\n\tint ret;\n\n\tkpcintb_workqueue = alloc_workqueue(\"kpcintb\", WQ_MEM_RECLAIM |\n\t\t\t\t\t    WQ_HIGHPRI, 0);\n\tret = pci_epf_register_driver(&epf_ntb_driver);\n\tif (ret) {\n\t\tdestroy_workqueue(kpcintb_workqueue);\n\t\tpr_err(\"Failed to register pci epf ntb driver --> %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\nmodule_init(epf_ntb_init);\n\nstatic void __exit epf_ntb_exit(void)\n{\n\tpci_epf_unregister_driver(&epf_ntb_driver);\n\tdestroy_workqueue(kpcintb_workqueue);\n}\nmodule_exit(epf_ntb_exit);\n\nMODULE_DESCRIPTION(\"PCI EPF NTB DRIVER\");\nMODULE_AUTHOR(\"Frank Li <Frank.li@nxp.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}