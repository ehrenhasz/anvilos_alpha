{
  "module_name": "pci-epf-ntb.c",
  "hash_id": "2fed8e6fdc8cda114feb4f14011cba55679d2fd291a0448a28676f8b5fa2d7c3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/endpoint/functions/pci-epf-ntb.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\n#include <linux/pci-epc.h>\n#include <linux/pci-epf.h>\n\nstatic struct workqueue_struct *kpcintb_workqueue;\n\n#define COMMAND_CONFIGURE_DOORBELL\t1\n#define COMMAND_TEARDOWN_DOORBELL\t2\n#define COMMAND_CONFIGURE_MW\t\t3\n#define COMMAND_TEARDOWN_MW\t\t4\n#define COMMAND_LINK_UP\t\t\t5\n#define COMMAND_LINK_DOWN\t\t6\n\n#define COMMAND_STATUS_OK\t\t1\n#define COMMAND_STATUS_ERROR\t\t2\n\n#define LINK_STATUS_UP\t\t\tBIT(0)\n\n#define SPAD_COUNT\t\t\t64\n#define DB_COUNT\t\t\t4\n#define NTB_MW_OFFSET\t\t\t2\n#define DB_COUNT_MASK\t\t\tGENMASK(15, 0)\n#define MSIX_ENABLE\t\t\tBIT(16)\n#define MAX_DB_COUNT\t\t\t32\n#define MAX_MW\t\t\t\t4\n\nenum epf_ntb_bar {\n\tBAR_CONFIG,\n\tBAR_PEER_SPAD,\n\tBAR_DB_MW1,\n\tBAR_MW2,\n\tBAR_MW3,\n\tBAR_MW4,\n};\n\nstruct epf_ntb {\n\tu32 num_mws;\n\tu32 db_count;\n\tu32 spad_count;\n\tstruct pci_epf *epf;\n\tu64 mws_size[MAX_MW];\n\tstruct config_group group;\n\tstruct epf_ntb_epc *epc[2];\n};\n\n#define to_epf_ntb(epf_group) container_of((epf_group), struct epf_ntb, group)\n\nstruct epf_ntb_epc {\n\tu8 func_no;\n\tu8 vfunc_no;\n\tbool linkup;\n\tbool is_msix;\n\tint msix_bar;\n\tu32 spad_size;\n\tstruct pci_epc *epc;\n\tstruct epf_ntb *epf_ntb;\n\tvoid __iomem *mw_addr[6];\n\tsize_t msix_table_offset;\n\tstruct epf_ntb_ctrl *reg;\n\tstruct pci_epf_bar *epf_bar;\n\tenum pci_barno epf_ntb_bar[6];\n\tstruct delayed_work cmd_handler;\n\tenum pci_epc_interface_type type;\n\tconst struct pci_epc_features *epc_features;\n};\n\nstruct epf_ntb_ctrl {\n\tu32\tcommand;\n\tu32\targument;\n\tu16\tcommand_status;\n\tu16\tlink_status;\n\tu32\ttopology;\n\tu64\taddr;\n\tu64\tsize;\n\tu32\tnum_mws;\n\tu32\tmw1_offset;\n\tu32\tspad_offset;\n\tu32\tspad_count;\n\tu32\tdb_entry_size;\n\tu32\tdb_data[MAX_DB_COUNT];\n\tu32\tdb_offset[MAX_DB_COUNT];\n} __packed;\n\nstatic struct pci_epf_header epf_ntb_header = {\n\t.vendorid\t= PCI_ANY_ID,\n\t.deviceid\t= PCI_ANY_ID,\n\t.baseclass_code\t= PCI_BASE_CLASS_MEMORY,\n\t.interrupt_pin\t= PCI_INTERRUPT_INTA,\n};\n\n \nstatic int epf_ntb_link_up(struct epf_ntb *ntb, bool link_up)\n{\n\tenum pci_epc_interface_type type;\n\tenum pci_epc_irq_type irq_type;\n\tstruct epf_ntb_epc *ntb_epc;\n\tstruct epf_ntb_ctrl *ctrl;\n\tstruct pci_epc *epc;\n\tu8 func_no, vfunc_no;\n\tbool is_msix;\n\tint ret;\n\n\tfor (type = PRIMARY_INTERFACE; type <= SECONDARY_INTERFACE; type++) {\n\t\tntb_epc = ntb->epc[type];\n\t\tepc = ntb_epc->epc;\n\t\tfunc_no = ntb_epc->func_no;\n\t\tvfunc_no = ntb_epc->vfunc_no;\n\t\tis_msix = ntb_epc->is_msix;\n\t\tctrl = ntb_epc->reg;\n\t\tif (link_up)\n\t\t\tctrl->link_status |= LINK_STATUS_UP;\n\t\telse\n\t\t\tctrl->link_status &= ~LINK_STATUS_UP;\n\t\tirq_type = is_msix ? PCI_EPC_IRQ_MSIX : PCI_EPC_IRQ_MSI;\n\t\tret = pci_epc_raise_irq(epc, func_no, vfunc_no, irq_type, 1);\n\t\tif (ret) {\n\t\t\tdev_err(&epc->dev,\n\t\t\t\t\"%s intf: Failed to raise Link Up IRQ\\n\",\n\t\t\t\tpci_epc_interface_string(type));\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int epf_ntb_configure_mw(struct epf_ntb *ntb,\n\t\t\t\tenum pci_epc_interface_type type, u32 mw)\n{\n\tstruct epf_ntb_epc *peer_ntb_epc, *ntb_epc;\n\tstruct pci_epf_bar *peer_epf_bar;\n\tenum pci_barno peer_barno;\n\tstruct epf_ntb_ctrl *ctrl;\n\tphys_addr_t phys_addr;\n\tu8 func_no, vfunc_no;\n\tstruct pci_epc *epc;\n\tu64 addr, size;\n\tint ret = 0;\n\n\tntb_epc = ntb->epc[type];\n\tepc = ntb_epc->epc;\n\n\tpeer_ntb_epc = ntb->epc[!type];\n\tpeer_barno = peer_ntb_epc->epf_ntb_bar[mw + NTB_MW_OFFSET];\n\tpeer_epf_bar = &peer_ntb_epc->epf_bar[peer_barno];\n\n\tphys_addr = peer_epf_bar->phys_addr;\n\tctrl = ntb_epc->reg;\n\taddr = ctrl->addr;\n\tsize = ctrl->size;\n\tif (mw + NTB_MW_OFFSET == BAR_DB_MW1)\n\t\tphys_addr += ctrl->mw1_offset;\n\n\tif (size > ntb->mws_size[mw]) {\n\t\tdev_err(&epc->dev,\n\t\t\t\"%s intf: MW: %d Req Sz:%llxx > Supported Sz:%llx\\n\",\n\t\t\tpci_epc_interface_string(type), mw, size,\n\t\t\tntb->mws_size[mw]);\n\t\tret = -EINVAL;\n\t\tgoto err_invalid_size;\n\t}\n\n\tfunc_no = ntb_epc->func_no;\n\tvfunc_no = ntb_epc->vfunc_no;\n\n\tret = pci_epc_map_addr(epc, func_no, vfunc_no, phys_addr, addr, size);\n\tif (ret)\n\t\tdev_err(&epc->dev,\n\t\t\t\"%s intf: Failed to map memory window %d address\\n\",\n\t\t\tpci_epc_interface_string(type), mw);\n\nerr_invalid_size:\n\n\treturn ret;\n}\n\n \nstatic void epf_ntb_teardown_mw(struct epf_ntb *ntb,\n\t\t\t\tenum pci_epc_interface_type type, u32 mw)\n{\n\tstruct epf_ntb_epc *peer_ntb_epc, *ntb_epc;\n\tstruct pci_epf_bar *peer_epf_bar;\n\tenum pci_barno peer_barno;\n\tstruct epf_ntb_ctrl *ctrl;\n\tphys_addr_t phys_addr;\n\tu8 func_no, vfunc_no;\n\tstruct pci_epc *epc;\n\n\tntb_epc = ntb->epc[type];\n\tepc = ntb_epc->epc;\n\n\tpeer_ntb_epc = ntb->epc[!type];\n\tpeer_barno = peer_ntb_epc->epf_ntb_bar[mw + NTB_MW_OFFSET];\n\tpeer_epf_bar = &peer_ntb_epc->epf_bar[peer_barno];\n\n\tphys_addr = peer_epf_bar->phys_addr;\n\tctrl = ntb_epc->reg;\n\tif (mw + NTB_MW_OFFSET == BAR_DB_MW1)\n\t\tphys_addr += ctrl->mw1_offset;\n\tfunc_no = ntb_epc->func_no;\n\tvfunc_no = ntb_epc->vfunc_no;\n\n\tpci_epc_unmap_addr(epc, func_no, vfunc_no, phys_addr);\n}\n\n \nstatic int epf_ntb_configure_msi(struct epf_ntb *ntb,\n\t\t\t\t enum pci_epc_interface_type type, u16 db_count)\n{\n\tstruct epf_ntb_epc *peer_ntb_epc, *ntb_epc;\n\tu32 db_entry_size, db_data, db_offset;\n\tstruct pci_epf_bar *peer_epf_bar;\n\tstruct epf_ntb_ctrl *peer_ctrl;\n\tenum pci_barno peer_barno;\n\tphys_addr_t phys_addr;\n\tu8 func_no, vfunc_no;\n\tstruct pci_epc *epc;\n\tint ret, i;\n\n\tntb_epc = ntb->epc[type];\n\tepc = ntb_epc->epc;\n\n\tpeer_ntb_epc = ntb->epc[!type];\n\tpeer_barno = peer_ntb_epc->epf_ntb_bar[BAR_DB_MW1];\n\tpeer_epf_bar = &peer_ntb_epc->epf_bar[peer_barno];\n\tpeer_ctrl = peer_ntb_epc->reg;\n\tdb_entry_size = peer_ctrl->db_entry_size;\n\n\tphys_addr = peer_epf_bar->phys_addr;\n\tfunc_no = ntb_epc->func_no;\n\tvfunc_no = ntb_epc->vfunc_no;\n\n\tret = pci_epc_map_msi_irq(epc, func_no, vfunc_no, phys_addr, db_count,\n\t\t\t\t  db_entry_size, &db_data, &db_offset);\n\tif (ret) {\n\t\tdev_err(&epc->dev, \"%s intf: Failed to map MSI IRQ\\n\",\n\t\t\tpci_epc_interface_string(type));\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < db_count; i++) {\n\t\tpeer_ctrl->db_data[i] = db_data | i;\n\t\tpeer_ctrl->db_offset[i] = db_offset;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int epf_ntb_configure_msix(struct epf_ntb *ntb,\n\t\t\t\t  enum pci_epc_interface_type type,\n\t\t\t\t  u16 db_count)\n{\n\tconst struct pci_epc_features *epc_features;\n\tstruct epf_ntb_epc *peer_ntb_epc, *ntb_epc;\n\tstruct pci_epf_bar *peer_epf_bar, *epf_bar;\n\tstruct pci_epf_msix_tbl *msix_tbl;\n\tstruct epf_ntb_ctrl *peer_ctrl;\n\tu32 db_entry_size, msg_data;\n\tenum pci_barno peer_barno;\n\tphys_addr_t phys_addr;\n\tu8 func_no, vfunc_no;\n\tstruct pci_epc *epc;\n\tsize_t align;\n\tu64 msg_addr;\n\tint ret, i;\n\n\tntb_epc = ntb->epc[type];\n\tepc = ntb_epc->epc;\n\n\tepf_bar = &ntb_epc->epf_bar[ntb_epc->msix_bar];\n\tmsix_tbl = epf_bar->addr + ntb_epc->msix_table_offset;\n\n\tpeer_ntb_epc = ntb->epc[!type];\n\tpeer_barno = peer_ntb_epc->epf_ntb_bar[BAR_DB_MW1];\n\tpeer_epf_bar = &peer_ntb_epc->epf_bar[peer_barno];\n\tphys_addr = peer_epf_bar->phys_addr;\n\tpeer_ctrl = peer_ntb_epc->reg;\n\tepc_features = ntb_epc->epc_features;\n\talign = epc_features->align;\n\n\tfunc_no = ntb_epc->func_no;\n\tvfunc_no = ntb_epc->vfunc_no;\n\tdb_entry_size = peer_ctrl->db_entry_size;\n\n\tfor (i = 0; i < db_count; i++) {\n\t\tmsg_addr = ALIGN_DOWN(msix_tbl[i].msg_addr, align);\n\t\tmsg_data = msix_tbl[i].msg_data;\n\t\tret = pci_epc_map_addr(epc, func_no, vfunc_no, phys_addr, msg_addr,\n\t\t\t\t       db_entry_size);\n\t\tif (ret) {\n\t\t\tdev_err(&epc->dev,\n\t\t\t\t\"%s intf: Failed to configure MSI-X IRQ\\n\",\n\t\t\t\tpci_epc_interface_string(type));\n\t\t\treturn ret;\n\t\t}\n\t\tphys_addr = phys_addr + db_entry_size;\n\t\tpeer_ctrl->db_data[i] = msg_data;\n\t\tpeer_ctrl->db_offset[i] = msix_tbl[i].msg_addr & (align - 1);\n\t}\n\tntb_epc->is_msix = true;\n\n\treturn 0;\n}\n\n \nstatic int epf_ntb_configure_db(struct epf_ntb *ntb,\n\t\t\t\tenum pci_epc_interface_type type,\n\t\t\t\tu16 db_count, bool msix)\n{\n\tstruct epf_ntb_epc *ntb_epc;\n\tstruct pci_epc *epc;\n\tint ret;\n\n\tif (db_count > MAX_DB_COUNT)\n\t\treturn -EINVAL;\n\n\tntb_epc = ntb->epc[type];\n\tepc = ntb_epc->epc;\n\n\tif (msix)\n\t\tret = epf_ntb_configure_msix(ntb, type, db_count);\n\telse\n\t\tret = epf_ntb_configure_msi(ntb, type, db_count);\n\n\tif (ret)\n\t\tdev_err(&epc->dev, \"%s intf: Failed to configure DB\\n\",\n\t\t\tpci_epc_interface_string(type));\n\n\treturn ret;\n}\n\n \nstatic void\nepf_ntb_teardown_db(struct epf_ntb *ntb, enum pci_epc_interface_type type)\n{\n\tstruct epf_ntb_epc *peer_ntb_epc, *ntb_epc;\n\tstruct pci_epf_bar *peer_epf_bar;\n\tenum pci_barno peer_barno;\n\tphys_addr_t phys_addr;\n\tu8 func_no, vfunc_no;\n\tstruct pci_epc *epc;\n\n\tntb_epc = ntb->epc[type];\n\tepc = ntb_epc->epc;\n\n\tpeer_ntb_epc = ntb->epc[!type];\n\tpeer_barno = peer_ntb_epc->epf_ntb_bar[BAR_DB_MW1];\n\tpeer_epf_bar = &peer_ntb_epc->epf_bar[peer_barno];\n\tphys_addr = peer_epf_bar->phys_addr;\n\tfunc_no = ntb_epc->func_no;\n\tvfunc_no = ntb_epc->vfunc_no;\n\n\tpci_epc_unmap_addr(epc, func_no, vfunc_no, phys_addr);\n}\n\n \nstatic void epf_ntb_cmd_handler(struct work_struct *work)\n{\n\tenum pci_epc_interface_type type;\n\tstruct epf_ntb_epc *ntb_epc;\n\tstruct epf_ntb_ctrl *ctrl;\n\tu32 command, argument;\n\tstruct epf_ntb *ntb;\n\tstruct device *dev;\n\tu16 db_count;\n\tbool is_msix;\n\tint ret;\n\n\tntb_epc = container_of(work, struct epf_ntb_epc, cmd_handler.work);\n\tctrl = ntb_epc->reg;\n\tcommand = ctrl->command;\n\tif (!command)\n\t\tgoto reset_handler;\n\targument = ctrl->argument;\n\n\tctrl->command = 0;\n\tctrl->argument = 0;\n\n\tctrl = ntb_epc->reg;\n\ttype = ntb_epc->type;\n\tntb = ntb_epc->epf_ntb;\n\tdev = &ntb->epf->dev;\n\n\tswitch (command) {\n\tcase COMMAND_CONFIGURE_DOORBELL:\n\t\tdb_count = argument & DB_COUNT_MASK;\n\t\tis_msix = argument & MSIX_ENABLE;\n\t\tret = epf_ntb_configure_db(ntb, type, db_count, is_msix);\n\t\tif (ret < 0)\n\t\t\tctrl->command_status = COMMAND_STATUS_ERROR;\n\t\telse\n\t\t\tctrl->command_status = COMMAND_STATUS_OK;\n\t\tbreak;\n\tcase COMMAND_TEARDOWN_DOORBELL:\n\t\tepf_ntb_teardown_db(ntb, type);\n\t\tctrl->command_status = COMMAND_STATUS_OK;\n\t\tbreak;\n\tcase COMMAND_CONFIGURE_MW:\n\t\tret = epf_ntb_configure_mw(ntb, type, argument);\n\t\tif (ret < 0)\n\t\t\tctrl->command_status = COMMAND_STATUS_ERROR;\n\t\telse\n\t\t\tctrl->command_status = COMMAND_STATUS_OK;\n\t\tbreak;\n\tcase COMMAND_TEARDOWN_MW:\n\t\tepf_ntb_teardown_mw(ntb, type, argument);\n\t\tctrl->command_status = COMMAND_STATUS_OK;\n\t\tbreak;\n\tcase COMMAND_LINK_UP:\n\t\tntb_epc->linkup = true;\n\t\tif (ntb->epc[PRIMARY_INTERFACE]->linkup &&\n\t\t    ntb->epc[SECONDARY_INTERFACE]->linkup) {\n\t\t\tret = epf_ntb_link_up(ntb, true);\n\t\t\tif (ret < 0)\n\t\t\t\tctrl->command_status = COMMAND_STATUS_ERROR;\n\t\t\telse\n\t\t\t\tctrl->command_status = COMMAND_STATUS_OK;\n\t\t\tgoto reset_handler;\n\t\t}\n\t\tctrl->command_status = COMMAND_STATUS_OK;\n\t\tbreak;\n\tcase COMMAND_LINK_DOWN:\n\t\tntb_epc->linkup = false;\n\t\tret = epf_ntb_link_up(ntb, false);\n\t\tif (ret < 0)\n\t\t\tctrl->command_status = COMMAND_STATUS_ERROR;\n\t\telse\n\t\t\tctrl->command_status = COMMAND_STATUS_OK;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"%s intf UNKNOWN command: %d\\n\",\n\t\t\tpci_epc_interface_string(type), command);\n\t\tbreak;\n\t}\n\nreset_handler:\n\tqueue_delayed_work(kpcintb_workqueue, &ntb_epc->cmd_handler,\n\t\t\t   msecs_to_jiffies(5));\n}\n\n \nstatic void epf_ntb_peer_spad_bar_clear(struct epf_ntb_epc *ntb_epc)\n{\n\tstruct pci_epf_bar *epf_bar;\n\tenum pci_barno barno;\n\tu8 func_no, vfunc_no;\n\tstruct pci_epc *epc;\n\n\tepc = ntb_epc->epc;\n\tfunc_no = ntb_epc->func_no;\n\tvfunc_no = ntb_epc->vfunc_no;\n\tbarno = ntb_epc->epf_ntb_bar[BAR_PEER_SPAD];\n\tepf_bar = &ntb_epc->epf_bar[barno];\n\tpci_epc_clear_bar(epc, func_no, vfunc_no, epf_bar);\n}\n\n \nstatic int epf_ntb_peer_spad_bar_set(struct epf_ntb *ntb,\n\t\t\t\t     enum pci_epc_interface_type type)\n{\n\tstruct epf_ntb_epc *peer_ntb_epc, *ntb_epc;\n\tstruct pci_epf_bar *peer_epf_bar, *epf_bar;\n\tenum pci_barno peer_barno, barno;\n\tu32 peer_spad_offset;\n\tu8 func_no, vfunc_no;\n\tstruct pci_epc *epc;\n\tstruct device *dev;\n\tint ret;\n\n\tdev = &ntb->epf->dev;\n\n\tpeer_ntb_epc = ntb->epc[!type];\n\tpeer_barno = peer_ntb_epc->epf_ntb_bar[BAR_CONFIG];\n\tpeer_epf_bar = &peer_ntb_epc->epf_bar[peer_barno];\n\n\tntb_epc = ntb->epc[type];\n\tbarno = ntb_epc->epf_ntb_bar[BAR_PEER_SPAD];\n\tepf_bar = &ntb_epc->epf_bar[barno];\n\tfunc_no = ntb_epc->func_no;\n\tvfunc_no = ntb_epc->vfunc_no;\n\tepc = ntb_epc->epc;\n\n\tpeer_spad_offset = peer_ntb_epc->reg->spad_offset;\n\tepf_bar->phys_addr = peer_epf_bar->phys_addr + peer_spad_offset;\n\tepf_bar->size = peer_ntb_epc->spad_size;\n\tepf_bar->barno = barno;\n\tepf_bar->flags = PCI_BASE_ADDRESS_MEM_TYPE_32;\n\n\tret = pci_epc_set_bar(epc, func_no, vfunc_no, epf_bar);\n\tif (ret) {\n\t\tdev_err(dev, \"%s intf: peer SPAD BAR set failed\\n\",\n\t\t\tpci_epc_interface_string(type));\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void epf_ntb_config_sspad_bar_clear(struct epf_ntb_epc *ntb_epc)\n{\n\tstruct pci_epf_bar *epf_bar;\n\tenum pci_barno barno;\n\tu8 func_no, vfunc_no;\n\tstruct pci_epc *epc;\n\n\tepc = ntb_epc->epc;\n\tfunc_no = ntb_epc->func_no;\n\tvfunc_no = ntb_epc->vfunc_no;\n\tbarno = ntb_epc->epf_ntb_bar[BAR_CONFIG];\n\tepf_bar = &ntb_epc->epf_bar[barno];\n\tpci_epc_clear_bar(epc, func_no, vfunc_no, epf_bar);\n}\n\n \nstatic int epf_ntb_config_sspad_bar_set(struct epf_ntb_epc *ntb_epc)\n{\n\tstruct pci_epf_bar *epf_bar;\n\tenum pci_barno barno;\n\tu8 func_no, vfunc_no;\n\tstruct epf_ntb *ntb;\n\tstruct pci_epc *epc;\n\tstruct device *dev;\n\tint ret;\n\n\tntb = ntb_epc->epf_ntb;\n\tdev = &ntb->epf->dev;\n\n\tepc = ntb_epc->epc;\n\tfunc_no = ntb_epc->func_no;\n\tvfunc_no = ntb_epc->vfunc_no;\n\tbarno = ntb_epc->epf_ntb_bar[BAR_CONFIG];\n\tepf_bar = &ntb_epc->epf_bar[barno];\n\n\tret = pci_epc_set_bar(epc, func_no, vfunc_no, epf_bar);\n\tif (ret) {\n\t\tdev_err(dev, \"%s inft: Config/Status/SPAD BAR set failed\\n\",\n\t\t\tpci_epc_interface_string(ntb_epc->type));\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void epf_ntb_config_spad_bar_free(struct epf_ntb *ntb)\n{\n\tenum pci_epc_interface_type type;\n\tstruct epf_ntb_epc *ntb_epc;\n\tenum pci_barno barno;\n\tstruct pci_epf *epf;\n\n\tepf = ntb->epf;\n\tfor (type = PRIMARY_INTERFACE; type <= SECONDARY_INTERFACE; type++) {\n\t\tntb_epc = ntb->epc[type];\n\t\tbarno = ntb_epc->epf_ntb_bar[BAR_CONFIG];\n\t\tif (ntb_epc->reg)\n\t\t\tpci_epf_free_space(epf, ntb_epc->reg, barno, type);\n\t}\n}\n\n \nstatic int epf_ntb_config_spad_bar_alloc(struct epf_ntb *ntb,\n\t\t\t\t\t enum pci_epc_interface_type type)\n{\n\tconst struct pci_epc_features *peer_epc_features, *epc_features;\n\tstruct epf_ntb_epc *peer_ntb_epc, *ntb_epc;\n\tsize_t msix_table_size, pba_size, align;\n\tenum pci_barno peer_barno, barno;\n\tstruct epf_ntb_ctrl *ctrl;\n\tu32 spad_size, ctrl_size;\n\tu64 size, peer_size;\n\tstruct pci_epf *epf;\n\tstruct device *dev;\n\tbool msix_capable;\n\tu32 spad_count;\n\tvoid *base;\n\n\tepf = ntb->epf;\n\tdev = &epf->dev;\n\tntb_epc = ntb->epc[type];\n\n\tepc_features = ntb_epc->epc_features;\n\tbarno = ntb_epc->epf_ntb_bar[BAR_CONFIG];\n\tsize = epc_features->bar_fixed_size[barno];\n\talign = epc_features->align;\n\n\tpeer_ntb_epc = ntb->epc[!type];\n\tpeer_epc_features = peer_ntb_epc->epc_features;\n\tpeer_barno = ntb_epc->epf_ntb_bar[BAR_PEER_SPAD];\n\tpeer_size = peer_epc_features->bar_fixed_size[peer_barno];\n\n\t \n\tif ((!IS_ALIGNED(size, align)))\n\t\treturn -EINVAL;\n\n\tspad_count = ntb->spad_count;\n\n\tctrl_size = sizeof(struct epf_ntb_ctrl);\n\tspad_size = spad_count * 4;\n\n\tmsix_capable = epc_features->msix_capable;\n\tif (msix_capable) {\n\t\tmsix_table_size = PCI_MSIX_ENTRY_SIZE * ntb->db_count;\n\t\tctrl_size = ALIGN(ctrl_size, 8);\n\t\tntb_epc->msix_table_offset = ctrl_size;\n\t\tntb_epc->msix_bar = barno;\n\t\t \n\t\tpba_size = ALIGN(DIV_ROUND_UP(ntb->db_count, 8), 8);\n\t\tctrl_size = ctrl_size + msix_table_size + pba_size;\n\t}\n\n\tif (!align) {\n\t\tctrl_size = roundup_pow_of_two(ctrl_size);\n\t\tspad_size = roundup_pow_of_two(spad_size);\n\t} else {\n\t\tctrl_size = ALIGN(ctrl_size, align);\n\t\tspad_size = ALIGN(spad_size, align);\n\t}\n\n\tif (peer_size) {\n\t\tif (peer_size < spad_size)\n\t\t\tspad_count = peer_size / 4;\n\t\tspad_size = peer_size;\n\t}\n\n\t \n\tif (spad_size > ctrl_size)\n\t\tctrl_size = spad_size;\n\n\tif (!size)\n\t\tsize = ctrl_size + spad_size;\n\telse if (size < ctrl_size + spad_size)\n\t\treturn -EINVAL;\n\n\tbase = pci_epf_alloc_space(epf, size, barno, align, type);\n\tif (!base) {\n\t\tdev_err(dev, \"%s intf: Config/Status/SPAD alloc region fail\\n\",\n\t\t\tpci_epc_interface_string(type));\n\t\treturn -ENOMEM;\n\t}\n\n\tntb_epc->reg = base;\n\n\tctrl = ntb_epc->reg;\n\tctrl->spad_offset = ctrl_size;\n\tctrl->spad_count = spad_count;\n\tctrl->num_mws = ntb->num_mws;\n\tctrl->db_entry_size = align ? align : 4;\n\tntb_epc->spad_size = spad_size;\n\n\treturn 0;\n}\n\n \nstatic int epf_ntb_config_spad_bar_alloc_interface(struct epf_ntb *ntb)\n{\n\tenum pci_epc_interface_type type;\n\tstruct device *dev;\n\tint ret;\n\n\tdev = &ntb->epf->dev;\n\n\tfor (type = PRIMARY_INTERFACE; type <= SECONDARY_INTERFACE; type++) {\n\t\tret = epf_ntb_config_spad_bar_alloc(ntb, type);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"%s intf: Config/SPAD BAR alloc failed\\n\",\n\t\t\t\tpci_epc_interface_string(type));\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic void epf_ntb_free_peer_mem(struct epf_ntb_epc *ntb_epc)\n{\n\tstruct pci_epf_bar *epf_bar;\n\tvoid __iomem *mw_addr;\n\tphys_addr_t phys_addr;\n\tenum epf_ntb_bar bar;\n\tenum pci_barno barno;\n\tstruct pci_epc *epc;\n\tsize_t size;\n\n\tepc = ntb_epc->epc;\n\n\tfor (bar = BAR_DB_MW1; bar < BAR_MW4; bar++) {\n\t\tbarno = ntb_epc->epf_ntb_bar[bar];\n\t\tmw_addr = ntb_epc->mw_addr[barno];\n\t\tepf_bar = &ntb_epc->epf_bar[barno];\n\t\tphys_addr = epf_bar->phys_addr;\n\t\tsize = epf_bar->size;\n\t\tif (mw_addr) {\n\t\t\tpci_epc_mem_free_addr(epc, phys_addr, mw_addr, size);\n\t\t\tntb_epc->mw_addr[barno] = NULL;\n\t\t}\n\t}\n}\n\n \nstatic void epf_ntb_db_mw_bar_clear(struct epf_ntb_epc *ntb_epc)\n{\n\tstruct pci_epf_bar *epf_bar;\n\tenum epf_ntb_bar bar;\n\tenum pci_barno barno;\n\tu8 func_no, vfunc_no;\n\tstruct pci_epc *epc;\n\n\tepc = ntb_epc->epc;\n\n\tfunc_no = ntb_epc->func_no;\n\tvfunc_no = ntb_epc->vfunc_no;\n\n\tfor (bar = BAR_DB_MW1; bar < BAR_MW4; bar++) {\n\t\tbarno = ntb_epc->epf_ntb_bar[bar];\n\t\tepf_bar = &ntb_epc->epf_bar[barno];\n\t\tpci_epc_clear_bar(epc, func_no, vfunc_no, epf_bar);\n\t}\n}\n\n \nstatic void epf_ntb_db_mw_bar_cleanup(struct epf_ntb *ntb,\n\t\t\t\t      enum pci_epc_interface_type type)\n{\n\tstruct epf_ntb_epc *peer_ntb_epc, *ntb_epc;\n\n\tntb_epc = ntb->epc[type];\n\tpeer_ntb_epc = ntb->epc[!type];\n\n\tepf_ntb_db_mw_bar_clear(ntb_epc);\n\tepf_ntb_free_peer_mem(peer_ntb_epc);\n}\n\n \nstatic int epf_ntb_configure_interrupt(struct epf_ntb *ntb,\n\t\t\t\t       enum pci_epc_interface_type type)\n{\n\tconst struct pci_epc_features *epc_features;\n\tbool msix_capable, msi_capable;\n\tstruct epf_ntb_epc *ntb_epc;\n\tu8 func_no, vfunc_no;\n\tstruct pci_epc *epc;\n\tstruct device *dev;\n\tu32 db_count;\n\tint ret;\n\n\tntb_epc = ntb->epc[type];\n\tdev = &ntb->epf->dev;\n\n\tepc_features = ntb_epc->epc_features;\n\tmsix_capable = epc_features->msix_capable;\n\tmsi_capable = epc_features->msi_capable;\n\n\tif (!(msix_capable || msi_capable)) {\n\t\tdev_err(dev, \"MSI or MSI-X is required for doorbell\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tfunc_no = ntb_epc->func_no;\n\tvfunc_no = ntb_epc->vfunc_no;\n\n\tdb_count = ntb->db_count;\n\tif (db_count > MAX_DB_COUNT) {\n\t\tdev_err(dev, \"DB count cannot be more than %d\\n\", MAX_DB_COUNT);\n\t\treturn -EINVAL;\n\t}\n\n\tntb->db_count = db_count;\n\tepc = ntb_epc->epc;\n\n\tif (msi_capable) {\n\t\tret = pci_epc_set_msi(epc, func_no, vfunc_no, db_count);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"%s intf: MSI configuration failed\\n\",\n\t\t\t\tpci_epc_interface_string(type));\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (msix_capable) {\n\t\tret = pci_epc_set_msix(epc, func_no, vfunc_no, db_count,\n\t\t\t\t       ntb_epc->msix_bar,\n\t\t\t\t       ntb_epc->msix_table_offset);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"MSI configuration failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int epf_ntb_alloc_peer_mem(struct device *dev,\n\t\t\t\t  struct epf_ntb_epc *ntb_epc,\n\t\t\t\t  enum epf_ntb_bar bar,\n\t\t\t\t  struct epf_ntb_epc *peer_ntb_epc,\n\t\t\t\t  size_t size)\n{\n\tconst struct pci_epc_features *epc_features;\n\tstruct pci_epf_bar *epf_bar;\n\tstruct pci_epc *peer_epc;\n\tphys_addr_t phys_addr;\n\tvoid __iomem *mw_addr;\n\tenum pci_barno barno;\n\tsize_t align;\n\n\tepc_features = ntb_epc->epc_features;\n\talign = epc_features->align;\n\n\tif (size < 128)\n\t\tsize = 128;\n\n\tif (align)\n\t\tsize = ALIGN(size, align);\n\telse\n\t\tsize = roundup_pow_of_two(size);\n\n\tpeer_epc = peer_ntb_epc->epc;\n\tmw_addr = pci_epc_mem_alloc_addr(peer_epc, &phys_addr, size);\n\tif (!mw_addr) {\n\t\tdev_err(dev, \"%s intf: Failed to allocate OB address\\n\",\n\t\t\tpci_epc_interface_string(peer_ntb_epc->type));\n\t\treturn -ENOMEM;\n\t}\n\n\tbarno = ntb_epc->epf_ntb_bar[bar];\n\tepf_bar = &ntb_epc->epf_bar[barno];\n\tntb_epc->mw_addr[barno] = mw_addr;\n\n\tepf_bar->phys_addr = phys_addr;\n\tepf_bar->size = size;\n\tepf_bar->barno = barno;\n\tepf_bar->flags = PCI_BASE_ADDRESS_MEM_TYPE_32;\n\n\treturn 0;\n}\n\n \nstatic int epf_ntb_db_mw_bar_init(struct epf_ntb *ntb,\n\t\t\t\t  enum pci_epc_interface_type type)\n{\n\tconst struct pci_epc_features *epc_features;\n\tstruct epf_ntb_epc *peer_ntb_epc, *ntb_epc;\n\tstruct pci_epf_bar *epf_bar;\n\tstruct epf_ntb_ctrl *ctrl;\n\tu32 num_mws, db_count;\n\tenum epf_ntb_bar bar;\n\tenum pci_barno barno;\n\tu8 func_no, vfunc_no;\n\tstruct pci_epc *epc;\n\tstruct device *dev;\n\tsize_t align;\n\tint ret, i;\n\tu64 size;\n\n\tntb_epc = ntb->epc[type];\n\tpeer_ntb_epc = ntb->epc[!type];\n\n\tdev = &ntb->epf->dev;\n\tepc_features = ntb_epc->epc_features;\n\talign = epc_features->align;\n\tfunc_no = ntb_epc->func_no;\n\tvfunc_no = ntb_epc->vfunc_no;\n\tepc = ntb_epc->epc;\n\tnum_mws = ntb->num_mws;\n\tdb_count = ntb->db_count;\n\n\tfor (bar = BAR_DB_MW1, i = 0; i < num_mws; bar++, i++) {\n\t\tif (bar == BAR_DB_MW1) {\n\t\t\talign = align ? align : 4;\n\t\t\tsize = db_count * align;\n\t\t\tsize = ALIGN(size, ntb->mws_size[i]);\n\t\t\tctrl = ntb_epc->reg;\n\t\t\tctrl->mw1_offset = size;\n\t\t\tsize += ntb->mws_size[i];\n\t\t} else {\n\t\t\tsize = ntb->mws_size[i];\n\t\t}\n\n\t\tret = epf_ntb_alloc_peer_mem(dev, ntb_epc, bar,\n\t\t\t\t\t     peer_ntb_epc, size);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"%s intf: DoorBell mem alloc failed\\n\",\n\t\t\t\tpci_epc_interface_string(type));\n\t\t\tgoto err_alloc_peer_mem;\n\t\t}\n\n\t\tbarno = ntb_epc->epf_ntb_bar[bar];\n\t\tepf_bar = &ntb_epc->epf_bar[barno];\n\n\t\tret = pci_epc_set_bar(epc, func_no, vfunc_no, epf_bar);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"%s intf: DoorBell BAR set failed\\n\",\n\t\t\t\tpci_epc_interface_string(type));\n\t\t\tgoto err_alloc_peer_mem;\n\t\t}\n\t}\n\n\treturn 0;\n\nerr_alloc_peer_mem:\n\tepf_ntb_db_mw_bar_cleanup(ntb, type);\n\n\treturn ret;\n}\n\n \nstatic void epf_ntb_epc_destroy_interface(struct epf_ntb *ntb,\n\t\t\t\t\t  enum pci_epc_interface_type type)\n{\n\tstruct epf_ntb_epc *ntb_epc;\n\tstruct pci_epc *epc;\n\tstruct pci_epf *epf;\n\n\tif (type < 0)\n\t\treturn;\n\n\tepf = ntb->epf;\n\tntb_epc = ntb->epc[type];\n\tif (!ntb_epc)\n\t\treturn;\n\tepc = ntb_epc->epc;\n\tpci_epc_remove_epf(epc, epf, type);\n\tpci_epc_put(epc);\n}\n\n \nstatic void epf_ntb_epc_destroy(struct epf_ntb *ntb)\n{\n\tenum pci_epc_interface_type type;\n\n\tfor (type = PRIMARY_INTERFACE; type <= SECONDARY_INTERFACE; type++)\n\t\tepf_ntb_epc_destroy_interface(ntb, type);\n}\n\n \nstatic int epf_ntb_epc_create_interface(struct epf_ntb *ntb,\n\t\t\t\t\tstruct pci_epc *epc,\n\t\t\t\t\tenum pci_epc_interface_type type)\n{\n\tconst struct pci_epc_features *epc_features;\n\tstruct pci_epf_bar *epf_bar;\n\tstruct epf_ntb_epc *ntb_epc;\n\tu8 func_no, vfunc_no;\n\tstruct pci_epf *epf;\n\tstruct device *dev;\n\n\tdev = &ntb->epf->dev;\n\n\tntb_epc = devm_kzalloc(dev, sizeof(*ntb_epc), GFP_KERNEL);\n\tif (!ntb_epc)\n\t\treturn -ENOMEM;\n\n\tepf = ntb->epf;\n\tvfunc_no = epf->vfunc_no;\n\tif (type == PRIMARY_INTERFACE) {\n\t\tfunc_no = epf->func_no;\n\t\tepf_bar = epf->bar;\n\t} else {\n\t\tfunc_no = epf->sec_epc_func_no;\n\t\tepf_bar = epf->sec_epc_bar;\n\t}\n\n\tntb_epc->linkup = false;\n\tntb_epc->epc = epc;\n\tntb_epc->func_no = func_no;\n\tntb_epc->vfunc_no = vfunc_no;\n\tntb_epc->type = type;\n\tntb_epc->epf_bar = epf_bar;\n\tntb_epc->epf_ntb = ntb;\n\n\tepc_features = pci_epc_get_features(epc, func_no, vfunc_no);\n\tif (!epc_features)\n\t\treturn -EINVAL;\n\tntb_epc->epc_features = epc_features;\n\n\tntb->epc[type] = ntb_epc;\n\n\treturn 0;\n}\n\n \nstatic int epf_ntb_epc_create(struct epf_ntb *ntb)\n{\n\tstruct pci_epf *epf;\n\tstruct device *dev;\n\tint ret;\n\n\tepf = ntb->epf;\n\tdev = &epf->dev;\n\n\tret = epf_ntb_epc_create_interface(ntb, epf->epc, PRIMARY_INTERFACE);\n\tif (ret) {\n\t\tdev_err(dev, \"PRIMARY intf: Fail to create NTB EPC\\n\");\n\t\treturn ret;\n\t}\n\n\tret = epf_ntb_epc_create_interface(ntb, epf->sec_epc,\n\t\t\t\t\t   SECONDARY_INTERFACE);\n\tif (ret) {\n\t\tdev_err(dev, \"SECONDARY intf: Fail to create NTB EPC\\n\");\n\t\tgoto err_epc_create;\n\t}\n\n\treturn 0;\n\nerr_epc_create:\n\tepf_ntb_epc_destroy_interface(ntb, PRIMARY_INTERFACE);\n\n\treturn ret;\n}\n\n \nstatic int epf_ntb_init_epc_bar_interface(struct epf_ntb *ntb,\n\t\t\t\t\t  enum pci_epc_interface_type type)\n{\n\tconst struct pci_epc_features *epc_features;\n\tstruct epf_ntb_epc *ntb_epc;\n\tenum pci_barno barno;\n\tenum epf_ntb_bar bar;\n\tstruct device *dev;\n\tu32 num_mws;\n\tint i;\n\n\tbarno = BAR_0;\n\tntb_epc = ntb->epc[type];\n\tnum_mws = ntb->num_mws;\n\tdev = &ntb->epf->dev;\n\tepc_features = ntb_epc->epc_features;\n\n\t \n\tfor (bar = BAR_CONFIG; bar <= BAR_DB_MW1; bar++, barno++) {\n\t\tbarno = pci_epc_get_next_free_bar(epc_features, barno);\n\t\tif (barno < 0) {\n\t\t\tdev_err(dev, \"%s intf: Fail to get NTB function BAR\\n\",\n\t\t\t\tpci_epc_interface_string(type));\n\t\t\treturn barno;\n\t\t}\n\t\tntb_epc->epf_ntb_bar[bar] = barno;\n\t}\n\n\t \n\tfor (bar = BAR_MW2, i = 1; i < num_mws; bar++, barno++, i++) {\n\t\tbarno = pci_epc_get_next_free_bar(epc_features, barno);\n\t\tif (barno < 0) {\n\t\t\tntb->num_mws = i;\n\t\t\tdev_dbg(dev, \"BAR not available for > MW%d\\n\", i + 1);\n\t\t}\n\t\tntb_epc->epf_ntb_bar[bar] = barno;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int epf_ntb_init_epc_bar(struct epf_ntb *ntb)\n{\n\tenum pci_epc_interface_type type;\n\tstruct device *dev;\n\tint ret;\n\n\tdev = &ntb->epf->dev;\n\tfor (type = PRIMARY_INTERFACE; type <= SECONDARY_INTERFACE; type++) {\n\t\tret = epf_ntb_init_epc_bar_interface(ntb, type);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Fail to init EPC bar for %s interface\\n\",\n\t\t\t\tpci_epc_interface_string(type));\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int epf_ntb_epc_init_interface(struct epf_ntb *ntb,\n\t\t\t\t      enum pci_epc_interface_type type)\n{\n\tstruct epf_ntb_epc *ntb_epc;\n\tu8 func_no, vfunc_no;\n\tstruct pci_epc *epc;\n\tstruct pci_epf *epf;\n\tstruct device *dev;\n\tint ret;\n\n\tntb_epc = ntb->epc[type];\n\tepf = ntb->epf;\n\tdev = &epf->dev;\n\tepc = ntb_epc->epc;\n\tfunc_no = ntb_epc->func_no;\n\tvfunc_no = ntb_epc->vfunc_no;\n\n\tret = epf_ntb_config_sspad_bar_set(ntb->epc[type]);\n\tif (ret) {\n\t\tdev_err(dev, \"%s intf: Config/self SPAD BAR init failed\\n\",\n\t\t\tpci_epc_interface_string(type));\n\t\treturn ret;\n\t}\n\n\tret = epf_ntb_peer_spad_bar_set(ntb, type);\n\tif (ret) {\n\t\tdev_err(dev, \"%s intf: Peer SPAD BAR init failed\\n\",\n\t\t\tpci_epc_interface_string(type));\n\t\tgoto err_peer_spad_bar_init;\n\t}\n\n\tret = epf_ntb_configure_interrupt(ntb, type);\n\tif (ret) {\n\t\tdev_err(dev, \"%s intf: Interrupt configuration failed\\n\",\n\t\t\tpci_epc_interface_string(type));\n\t\tgoto err_peer_spad_bar_init;\n\t}\n\n\tret = epf_ntb_db_mw_bar_init(ntb, type);\n\tif (ret) {\n\t\tdev_err(dev, \"%s intf: DB/MW BAR init failed\\n\",\n\t\t\tpci_epc_interface_string(type));\n\t\tgoto err_db_mw_bar_init;\n\t}\n\n\tif (vfunc_no <= 1) {\n\t\tret = pci_epc_write_header(epc, func_no, vfunc_no, epf->header);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"%s intf: Configuration header write failed\\n\",\n\t\t\t\tpci_epc_interface_string(type));\n\t\t\tgoto err_write_header;\n\t\t}\n\t}\n\n\tINIT_DELAYED_WORK(&ntb->epc[type]->cmd_handler, epf_ntb_cmd_handler);\n\tqueue_work(kpcintb_workqueue, &ntb->epc[type]->cmd_handler.work);\n\n\treturn 0;\n\nerr_write_header:\n\tepf_ntb_db_mw_bar_cleanup(ntb, type);\n\nerr_db_mw_bar_init:\n\tepf_ntb_peer_spad_bar_clear(ntb->epc[type]);\n\nerr_peer_spad_bar_init:\n\tepf_ntb_config_sspad_bar_clear(ntb->epc[type]);\n\n\treturn ret;\n}\n\n \nstatic void epf_ntb_epc_cleanup_interface(struct epf_ntb *ntb,\n\t\t\t\t\t  enum pci_epc_interface_type type)\n{\n\tstruct epf_ntb_epc *ntb_epc;\n\n\tif (type < 0)\n\t\treturn;\n\n\tntb_epc = ntb->epc[type];\n\tcancel_delayed_work(&ntb_epc->cmd_handler);\n\tepf_ntb_db_mw_bar_cleanup(ntb, type);\n\tepf_ntb_peer_spad_bar_clear(ntb_epc);\n\tepf_ntb_config_sspad_bar_clear(ntb_epc);\n}\n\n \nstatic void epf_ntb_epc_cleanup(struct epf_ntb *ntb)\n{\n\tenum pci_epc_interface_type type;\n\n\tfor (type = PRIMARY_INTERFACE; type <= SECONDARY_INTERFACE; type++)\n\t\tepf_ntb_epc_cleanup_interface(ntb, type);\n}\n\n \nstatic int epf_ntb_epc_init(struct epf_ntb *ntb)\n{\n\tenum pci_epc_interface_type type;\n\tstruct device *dev;\n\tint ret;\n\n\tdev = &ntb->epf->dev;\n\n\tfor (type = PRIMARY_INTERFACE; type <= SECONDARY_INTERFACE; type++) {\n\t\tret = epf_ntb_epc_init_interface(ntb, type);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"%s intf: Failed to initialize\\n\",\n\t\t\t\tpci_epc_interface_string(type));\n\t\t\tgoto err_init_type;\n\t\t}\n\t}\n\n\treturn 0;\n\nerr_init_type:\n\tepf_ntb_epc_cleanup_interface(ntb, type - 1);\n\n\treturn ret;\n}\n\n \nstatic int epf_ntb_bind(struct pci_epf *epf)\n{\n\tstruct epf_ntb *ntb = epf_get_drvdata(epf);\n\tstruct device *dev = &epf->dev;\n\tint ret;\n\n\tif (!epf->epc) {\n\t\tdev_dbg(dev, \"PRIMARY EPC interface not yet bound\\n\");\n\t\treturn 0;\n\t}\n\n\tif (!epf->sec_epc) {\n\t\tdev_dbg(dev, \"SECONDARY EPC interface not yet bound\\n\");\n\t\treturn 0;\n\t}\n\n\tret = epf_ntb_epc_create(ntb);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to create NTB EPC\\n\");\n\t\treturn ret;\n\t}\n\n\tret = epf_ntb_init_epc_bar(ntb);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to create NTB EPC\\n\");\n\t\tgoto err_bar_init;\n\t}\n\n\tret = epf_ntb_config_spad_bar_alloc_interface(ntb);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to allocate BAR memory\\n\");\n\t\tgoto err_bar_alloc;\n\t}\n\n\tret = epf_ntb_epc_init(ntb);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to initialize EPC\\n\");\n\t\tgoto err_bar_alloc;\n\t}\n\n\tepf_set_drvdata(epf, ntb);\n\n\treturn 0;\n\nerr_bar_alloc:\n\tepf_ntb_config_spad_bar_free(ntb);\n\nerr_bar_init:\n\tepf_ntb_epc_destroy(ntb);\n\n\treturn ret;\n}\n\n \nstatic void epf_ntb_unbind(struct pci_epf *epf)\n{\n\tstruct epf_ntb *ntb = epf_get_drvdata(epf);\n\n\tepf_ntb_epc_cleanup(ntb);\n\tepf_ntb_config_spad_bar_free(ntb);\n\tepf_ntb_epc_destroy(ntb);\n}\n\n#define EPF_NTB_R(_name)\t\t\t\t\t\t\\\nstatic ssize_t epf_ntb_##_name##_show(struct config_item *item,\t\t\\\n\t\t\t\t      char *page)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct config_group *group = to_config_group(item);\t\t\\\n\tstruct epf_ntb *ntb = to_epf_ntb(group);\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\treturn sysfs_emit(page, \"%d\\n\", ntb->_name);\t\t\t\\\n}\n\n#define EPF_NTB_W(_name)\t\t\t\t\t\t\\\nstatic ssize_t epf_ntb_##_name##_store(struct config_item *item,\t\\\n\t\t\t\t       const char *page, size_t len)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct config_group *group = to_config_group(item);\t\t\\\n\tstruct epf_ntb *ntb = to_epf_ntb(group);\t\t\t\\\n\tu32 val;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (kstrtou32(page, 0, &val) < 0)\t\t\t\t\\\n\t\treturn -EINVAL;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tntb->_name = val;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\treturn len;\t\t\t\t\t\t\t\\\n}\n\n#define EPF_NTB_MW_R(_name)\t\t\t\t\t\t\\\nstatic ssize_t epf_ntb_##_name##_show(struct config_item *item,\t\t\\\n\t\t\t\t      char *page)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct config_group *group = to_config_group(item);\t\t\\\n\tstruct epf_ntb *ntb = to_epf_ntb(group);\t\t\t\\\n\tint win_no;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tsscanf(#_name, \"mw%d\", &win_no);\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\treturn sysfs_emit(page, \"%lld\\n\", ntb->mws_size[win_no - 1]);\t\\\n}\n\n#define EPF_NTB_MW_W(_name)\t\t\t\t\t\t\\\nstatic ssize_t epf_ntb_##_name##_store(struct config_item *item,\t\\\n\t\t\t\t       const char *page, size_t len)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct config_group *group = to_config_group(item);\t\t\\\n\tstruct epf_ntb *ntb = to_epf_ntb(group);\t\t\t\\\n\tstruct device *dev = &ntb->epf->dev;\t\t\t\t\\\n\tint win_no;\t\t\t\t\t\t\t\\\n\tu64 val;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (kstrtou64(page, 0, &val) < 0)\t\t\t\t\\\n\t\treturn -EINVAL;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (sscanf(#_name, \"mw%d\", &win_no) != 1)\t\t\t\\\n\t\treturn -EINVAL;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (ntb->num_mws < win_no) {\t\t\t\t\t\\\n\t\tdev_err(dev, \"Invalid num_nws: %d value\\n\", ntb->num_mws); \\\n\t\treturn -EINVAL;\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tntb->mws_size[win_no - 1] = val;\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\treturn len;\t\t\t\t\t\t\t\\\n}\n\nstatic ssize_t epf_ntb_num_mws_store(struct config_item *item,\n\t\t\t\t     const char *page, size_t len)\n{\n\tstruct config_group *group = to_config_group(item);\n\tstruct epf_ntb *ntb = to_epf_ntb(group);\n\tu32 val;\n\n\tif (kstrtou32(page, 0, &val) < 0)\n\t\treturn -EINVAL;\n\n\tif (val > MAX_MW)\n\t\treturn -EINVAL;\n\n\tntb->num_mws = val;\n\n\treturn len;\n}\n\nEPF_NTB_R(spad_count)\nEPF_NTB_W(spad_count)\nEPF_NTB_R(db_count)\nEPF_NTB_W(db_count)\nEPF_NTB_R(num_mws)\nEPF_NTB_MW_R(mw1)\nEPF_NTB_MW_W(mw1)\nEPF_NTB_MW_R(mw2)\nEPF_NTB_MW_W(mw2)\nEPF_NTB_MW_R(mw3)\nEPF_NTB_MW_W(mw3)\nEPF_NTB_MW_R(mw4)\nEPF_NTB_MW_W(mw4)\n\nCONFIGFS_ATTR(epf_ntb_, spad_count);\nCONFIGFS_ATTR(epf_ntb_, db_count);\nCONFIGFS_ATTR(epf_ntb_, num_mws);\nCONFIGFS_ATTR(epf_ntb_, mw1);\nCONFIGFS_ATTR(epf_ntb_, mw2);\nCONFIGFS_ATTR(epf_ntb_, mw3);\nCONFIGFS_ATTR(epf_ntb_, mw4);\n\nstatic struct configfs_attribute *epf_ntb_attrs[] = {\n\t&epf_ntb_attr_spad_count,\n\t&epf_ntb_attr_db_count,\n\t&epf_ntb_attr_num_mws,\n\t&epf_ntb_attr_mw1,\n\t&epf_ntb_attr_mw2,\n\t&epf_ntb_attr_mw3,\n\t&epf_ntb_attr_mw4,\n\tNULL,\n};\n\nstatic const struct config_item_type ntb_group_type = {\n\t.ct_attrs\t= epf_ntb_attrs,\n\t.ct_owner\t= THIS_MODULE,\n};\n\n \nstatic struct config_group *epf_ntb_add_cfs(struct pci_epf *epf,\n\t\t\t\t\t    struct config_group *group)\n{\n\tstruct epf_ntb *ntb = epf_get_drvdata(epf);\n\tstruct config_group *ntb_group = &ntb->group;\n\tstruct device *dev = &epf->dev;\n\n\tconfig_group_init_type_name(ntb_group, dev_name(dev), &ntb_group_type);\n\n\treturn ntb_group;\n}\n\n \nstatic int epf_ntb_probe(struct pci_epf *epf,\n\t\t\t const struct pci_epf_device_id *id)\n{\n\tstruct epf_ntb *ntb;\n\tstruct device *dev;\n\n\tdev = &epf->dev;\n\n\tntb = devm_kzalloc(dev, sizeof(*ntb), GFP_KERNEL);\n\tif (!ntb)\n\t\treturn -ENOMEM;\n\n\tepf->header = &epf_ntb_header;\n\tntb->epf = epf;\n\tepf_set_drvdata(epf, ntb);\n\n\treturn 0;\n}\n\nstatic struct pci_epf_ops epf_ntb_ops = {\n\t.bind\t= epf_ntb_bind,\n\t.unbind\t= epf_ntb_unbind,\n\t.add_cfs = epf_ntb_add_cfs,\n};\n\nstatic const struct pci_epf_device_id epf_ntb_ids[] = {\n\t{\n\t\t.name = \"pci_epf_ntb\",\n\t},\n\t{},\n};\n\nstatic struct pci_epf_driver epf_ntb_driver = {\n\t.driver.name\t= \"pci_epf_ntb\",\n\t.probe\t\t= epf_ntb_probe,\n\t.id_table\t= epf_ntb_ids,\n\t.ops\t\t= &epf_ntb_ops,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic int __init epf_ntb_init(void)\n{\n\tint ret;\n\n\tkpcintb_workqueue = alloc_workqueue(\"kpcintb\", WQ_MEM_RECLAIM |\n\t\t\t\t\t    WQ_HIGHPRI, 0);\n\tret = pci_epf_register_driver(&epf_ntb_driver);\n\tif (ret) {\n\t\tdestroy_workqueue(kpcintb_workqueue);\n\t\tpr_err(\"Failed to register pci epf ntb driver --> %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\nmodule_init(epf_ntb_init);\n\nstatic void __exit epf_ntb_exit(void)\n{\n\tpci_epf_unregister_driver(&epf_ntb_driver);\n\tdestroy_workqueue(kpcintb_workqueue);\n}\nmodule_exit(epf_ntb_exit);\n\nMODULE_DESCRIPTION(\"PCI EPF NTB DRIVER\");\nMODULE_AUTHOR(\"Kishon Vijay Abraham I <kishon@ti.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}