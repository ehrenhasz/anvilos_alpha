{
  "module_name": "pci-driver.c",
  "hash_id": "c508b86a5d0a098ceb6b0b148b80dd1842223e70b1c42df5097703c2f4c9d9f4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/pci-driver.c",
  "human_readable_source": "\n \n\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/mempolicy.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/cpu.h>\n#include <linux/pm_runtime.h>\n#include <linux/suspend.h>\n#include <linux/kexec.h>\n#include <linux/of_device.h>\n#include <linux/acpi.h>\n#include <linux/dma-map-ops.h>\n#include <linux/iommu.h>\n#include \"pci.h\"\n#include \"pcie/portdrv.h\"\n\nstruct pci_dynid {\n\tstruct list_head node;\n\tstruct pci_device_id id;\n};\n\n \nint pci_add_dynid(struct pci_driver *drv,\n\t\t  unsigned int vendor, unsigned int device,\n\t\t  unsigned int subvendor, unsigned int subdevice,\n\t\t  unsigned int class, unsigned int class_mask,\n\t\t  unsigned long driver_data)\n{\n\tstruct pci_dynid *dynid;\n\n\tdynid = kzalloc(sizeof(*dynid), GFP_KERNEL);\n\tif (!dynid)\n\t\treturn -ENOMEM;\n\n\tdynid->id.vendor = vendor;\n\tdynid->id.device = device;\n\tdynid->id.subvendor = subvendor;\n\tdynid->id.subdevice = subdevice;\n\tdynid->id.class = class;\n\tdynid->id.class_mask = class_mask;\n\tdynid->id.driver_data = driver_data;\n\n\tspin_lock(&drv->dynids.lock);\n\tlist_add_tail(&dynid->node, &drv->dynids.list);\n\tspin_unlock(&drv->dynids.lock);\n\n\treturn driver_attach(&drv->driver);\n}\nEXPORT_SYMBOL_GPL(pci_add_dynid);\n\nstatic void pci_free_dynids(struct pci_driver *drv)\n{\n\tstruct pci_dynid *dynid, *n;\n\n\tspin_lock(&drv->dynids.lock);\n\tlist_for_each_entry_safe(dynid, n, &drv->dynids.list, node) {\n\t\tlist_del(&dynid->node);\n\t\tkfree(dynid);\n\t}\n\tspin_unlock(&drv->dynids.lock);\n}\n\n \nconst struct pci_device_id *pci_match_id(const struct pci_device_id *ids,\n\t\t\t\t\t struct pci_dev *dev)\n{\n\tif (ids) {\n\t\twhile (ids->vendor || ids->subvendor || ids->class_mask) {\n\t\t\tif (pci_match_one_device(ids, dev))\n\t\t\t\treturn ids;\n\t\t\tids++;\n\t\t}\n\t}\n\treturn NULL;\n}\nEXPORT_SYMBOL(pci_match_id);\n\nstatic const struct pci_device_id pci_device_id_any = {\n\t.vendor = PCI_ANY_ID,\n\t.device = PCI_ANY_ID,\n\t.subvendor = PCI_ANY_ID,\n\t.subdevice = PCI_ANY_ID,\n};\n\n \nstatic const struct pci_device_id *pci_match_device(struct pci_driver *drv,\n\t\t\t\t\t\t    struct pci_dev *dev)\n{\n\tstruct pci_dynid *dynid;\n\tconst struct pci_device_id *found_id = NULL, *ids;\n\n\t \n\tif (dev->driver_override && strcmp(dev->driver_override, drv->name))\n\t\treturn NULL;\n\n\t \n\tspin_lock(&drv->dynids.lock);\n\tlist_for_each_entry(dynid, &drv->dynids.list, node) {\n\t\tif (pci_match_one_device(&dynid->id, dev)) {\n\t\t\tfound_id = &dynid->id;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&drv->dynids.lock);\n\n\tif (found_id)\n\t\treturn found_id;\n\n\tfor (ids = drv->id_table; (found_id = pci_match_id(ids, dev));\n\t     ids = found_id + 1) {\n\t\t \n\t\tif (found_id->override_only) {\n\t\t\tif (dev->driver_override)\n\t\t\t\treturn found_id;\n\t\t} else {\n\t\t\treturn found_id;\n\t\t}\n\t}\n\n\t \n\tif (dev->driver_override)\n\t\treturn &pci_device_id_any;\n\treturn NULL;\n}\n\n \nstatic ssize_t new_id_store(struct device_driver *driver, const char *buf,\n\t\t\t    size_t count)\n{\n\tstruct pci_driver *pdrv = to_pci_driver(driver);\n\tconst struct pci_device_id *ids = pdrv->id_table;\n\tu32 vendor, device, subvendor = PCI_ANY_ID,\n\t\tsubdevice = PCI_ANY_ID, class = 0, class_mask = 0;\n\tunsigned long driver_data = 0;\n\tint fields;\n\tint retval = 0;\n\n\tfields = sscanf(buf, \"%x %x %x %x %x %x %lx\",\n\t\t\t&vendor, &device, &subvendor, &subdevice,\n\t\t\t&class, &class_mask, &driver_data);\n\tif (fields < 2)\n\t\treturn -EINVAL;\n\n\tif (fields != 7) {\n\t\tstruct pci_dev *pdev = kzalloc(sizeof(*pdev), GFP_KERNEL);\n\t\tif (!pdev)\n\t\t\treturn -ENOMEM;\n\n\t\tpdev->vendor = vendor;\n\t\tpdev->device = device;\n\t\tpdev->subsystem_vendor = subvendor;\n\t\tpdev->subsystem_device = subdevice;\n\t\tpdev->class = class;\n\n\t\tif (pci_match_device(pdrv, pdev))\n\t\t\tretval = -EEXIST;\n\n\t\tkfree(pdev);\n\n\t\tif (retval)\n\t\t\treturn retval;\n\t}\n\n\t \n\tif (ids) {\n\t\tretval = -EINVAL;\n\t\twhile (ids->vendor || ids->subvendor || ids->class_mask) {\n\t\t\tif (driver_data == ids->driver_data) {\n\t\t\t\tretval = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tids++;\n\t\t}\n\t\tif (retval)\t \n\t\t\treturn retval;\n\t}\n\n\tretval = pci_add_dynid(pdrv, vendor, device, subvendor, subdevice,\n\t\t\t       class, class_mask, driver_data);\n\tif (retval)\n\t\treturn retval;\n\treturn count;\n}\nstatic DRIVER_ATTR_WO(new_id);\n\n \nstatic ssize_t remove_id_store(struct device_driver *driver, const char *buf,\n\t\t\t       size_t count)\n{\n\tstruct pci_dynid *dynid, *n;\n\tstruct pci_driver *pdrv = to_pci_driver(driver);\n\tu32 vendor, device, subvendor = PCI_ANY_ID,\n\t\tsubdevice = PCI_ANY_ID, class = 0, class_mask = 0;\n\tint fields;\n\tsize_t retval = -ENODEV;\n\n\tfields = sscanf(buf, \"%x %x %x %x %x %x\",\n\t\t\t&vendor, &device, &subvendor, &subdevice,\n\t\t\t&class, &class_mask);\n\tif (fields < 2)\n\t\treturn -EINVAL;\n\n\tspin_lock(&pdrv->dynids.lock);\n\tlist_for_each_entry_safe(dynid, n, &pdrv->dynids.list, node) {\n\t\tstruct pci_device_id *id = &dynid->id;\n\t\tif ((id->vendor == vendor) &&\n\t\t    (id->device == device) &&\n\t\t    (subvendor == PCI_ANY_ID || id->subvendor == subvendor) &&\n\t\t    (subdevice == PCI_ANY_ID || id->subdevice == subdevice) &&\n\t\t    !((id->class ^ class) & class_mask)) {\n\t\t\tlist_del(&dynid->node);\n\t\t\tkfree(dynid);\n\t\t\tretval = count;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&pdrv->dynids.lock);\n\n\treturn retval;\n}\nstatic DRIVER_ATTR_WO(remove_id);\n\nstatic struct attribute *pci_drv_attrs[] = {\n\t&driver_attr_new_id.attr,\n\t&driver_attr_remove_id.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(pci_drv);\n\nstruct drv_dev_and_id {\n\tstruct pci_driver *drv;\n\tstruct pci_dev *dev;\n\tconst struct pci_device_id *id;\n};\n\nstatic long local_pci_probe(void *_ddi)\n{\n\tstruct drv_dev_and_id *ddi = _ddi;\n\tstruct pci_dev *pci_dev = ddi->dev;\n\tstruct pci_driver *pci_drv = ddi->drv;\n\tstruct device *dev = &pci_dev->dev;\n\tint rc;\n\n\t \n\tpm_runtime_get_sync(dev);\n\tpci_dev->driver = pci_drv;\n\trc = pci_drv->probe(pci_dev, ddi->id);\n\tif (!rc)\n\t\treturn rc;\n\tif (rc < 0) {\n\t\tpci_dev->driver = NULL;\n\t\tpm_runtime_put_sync(dev);\n\t\treturn rc;\n\t}\n\t \n\tpci_warn(pci_dev, \"Driver probe function unexpectedly returned %d\\n\",\n\t\t rc);\n\treturn 0;\n}\n\nstatic bool pci_physfn_is_probed(struct pci_dev *dev)\n{\n#ifdef CONFIG_PCI_IOV\n\treturn dev->is_virtfn && dev->physfn->is_probed;\n#else\n\treturn false;\n#endif\n}\n\nstatic int pci_call_probe(struct pci_driver *drv, struct pci_dev *dev,\n\t\t\t  const struct pci_device_id *id)\n{\n\tint error, node, cpu;\n\tstruct drv_dev_and_id ddi = { drv, dev, id };\n\n\t \n\tnode = dev_to_node(&dev->dev);\n\tdev->is_probed = 1;\n\n\tcpu_hotplug_disable();\n\n\t \n\tif (node < 0 || node >= MAX_NUMNODES || !node_online(node) ||\n\t    pci_physfn_is_probed(dev)) {\n\t\tcpu = nr_cpu_ids;\n\t} else {\n\t\tcpumask_var_t wq_domain_mask;\n\n\t\tif (!zalloc_cpumask_var(&wq_domain_mask, GFP_KERNEL)) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tcpumask_and(wq_domain_mask,\n\t\t\t    housekeeping_cpumask(HK_TYPE_WQ),\n\t\t\t    housekeeping_cpumask(HK_TYPE_DOMAIN));\n\n\t\tcpu = cpumask_any_and(cpumask_of_node(node),\n\t\t\t\t      wq_domain_mask);\n\t\tfree_cpumask_var(wq_domain_mask);\n\t}\n\n\tif (cpu < nr_cpu_ids)\n\t\terror = work_on_cpu(cpu, local_pci_probe, &ddi);\n\telse\n\t\terror = local_pci_probe(&ddi);\nout:\n\tdev->is_probed = 0;\n\tcpu_hotplug_enable();\n\treturn error;\n}\n\n \nstatic int __pci_device_probe(struct pci_driver *drv, struct pci_dev *pci_dev)\n{\n\tconst struct pci_device_id *id;\n\tint error = 0;\n\n\tif (drv->probe) {\n\t\terror = -ENODEV;\n\n\t\tid = pci_match_device(drv, pci_dev);\n\t\tif (id)\n\t\t\terror = pci_call_probe(drv, pci_dev, id);\n\t}\n\treturn error;\n}\n\nint __weak pcibios_alloc_irq(struct pci_dev *dev)\n{\n\treturn 0;\n}\n\nvoid __weak pcibios_free_irq(struct pci_dev *dev)\n{\n}\n\n#ifdef CONFIG_PCI_IOV\nstatic inline bool pci_device_can_probe(struct pci_dev *pdev)\n{\n\treturn (!pdev->is_virtfn || pdev->physfn->sriov->drivers_autoprobe ||\n\t\tpdev->driver_override);\n}\n#else\nstatic inline bool pci_device_can_probe(struct pci_dev *pdev)\n{\n\treturn true;\n}\n#endif\n\nstatic int pci_device_probe(struct device *dev)\n{\n\tint error;\n\tstruct pci_dev *pci_dev = to_pci_dev(dev);\n\tstruct pci_driver *drv = to_pci_driver(dev->driver);\n\n\tif (!pci_device_can_probe(pci_dev))\n\t\treturn -ENODEV;\n\n\tpci_assign_irq(pci_dev);\n\n\terror = pcibios_alloc_irq(pci_dev);\n\tif (error < 0)\n\t\treturn error;\n\n\tpci_dev_get(pci_dev);\n\terror = __pci_device_probe(drv, pci_dev);\n\tif (error) {\n\t\tpcibios_free_irq(pci_dev);\n\t\tpci_dev_put(pci_dev);\n\t}\n\n\treturn error;\n}\n\nstatic void pci_device_remove(struct device *dev)\n{\n\tstruct pci_dev *pci_dev = to_pci_dev(dev);\n\tstruct pci_driver *drv = pci_dev->driver;\n\n\tif (drv->remove) {\n\t\tpm_runtime_get_sync(dev);\n\t\tdrv->remove(pci_dev);\n\t\tpm_runtime_put_noidle(dev);\n\t}\n\tpcibios_free_irq(pci_dev);\n\tpci_dev->driver = NULL;\n\tpci_iov_remove(pci_dev);\n\n\t \n\tpm_runtime_put_sync(dev);\n\n\t \n\tif (pci_dev->current_state == PCI_D0)\n\t\tpci_dev->current_state = PCI_UNKNOWN;\n\n\t \n\n\tpci_dev_put(pci_dev);\n}\n\nstatic void pci_device_shutdown(struct device *dev)\n{\n\tstruct pci_dev *pci_dev = to_pci_dev(dev);\n\tstruct pci_driver *drv = pci_dev->driver;\n\n\tpm_runtime_resume(dev);\n\n\tif (drv && drv->shutdown)\n\t\tdrv->shutdown(pci_dev);\n\n\t \n\tif (kexec_in_progress && (pci_dev->current_state <= PCI_D3hot))\n\t\tpci_clear_master(pci_dev);\n}\n\n#ifdef CONFIG_PM_SLEEP\n\n \n\n \nstatic int pci_restore_standard_config(struct pci_dev *pci_dev)\n{\n\tpci_update_current_state(pci_dev, PCI_UNKNOWN);\n\n\tif (pci_dev->current_state != PCI_D0) {\n\t\tint error = pci_set_power_state(pci_dev, PCI_D0);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tpci_restore_state(pci_dev);\n\tpci_pme_restore(pci_dev);\n\treturn 0;\n}\n#endif  \n\n#ifdef CONFIG_PM\n\n \n\nstatic void pci_pm_default_resume(struct pci_dev *pci_dev)\n{\n\tpci_fixup_device(pci_fixup_resume, pci_dev);\n\tpci_enable_wake(pci_dev, PCI_D0, false);\n}\n\nstatic void pci_pm_power_up_and_verify_state(struct pci_dev *pci_dev)\n{\n\tpci_power_up(pci_dev);\n\tpci_update_current_state(pci_dev, PCI_D0);\n}\n\nstatic void pci_pm_default_resume_early(struct pci_dev *pci_dev)\n{\n\tpci_pm_power_up_and_verify_state(pci_dev);\n\tpci_restore_state(pci_dev);\n\tpci_pme_restore(pci_dev);\n}\n\nstatic void pci_pm_bridge_power_up_actions(struct pci_dev *pci_dev)\n{\n\tint ret;\n\n\tret = pci_bridge_wait_for_secondary_bus(pci_dev, \"resume\");\n\tif (ret) {\n\t\t \n\t\tpci_walk_bus(pci_dev->subordinate, pci_dev_set_disconnected,\n\t\t\t     NULL);\n\t\treturn;\n\t}\n\n\t \n\tpci_resume_bus(pci_dev->subordinate);\n}\n\n#endif  \n\n#ifdef CONFIG_PM_SLEEP\n\n \nstatic void pci_pm_set_unknown_state(struct pci_dev *pci_dev)\n{\n\t \n\tif (pci_dev->current_state == PCI_D0)\n\t\tpci_dev->current_state = PCI_UNKNOWN;\n}\n\n \nstatic int pci_pm_reenable_device(struct pci_dev *pci_dev)\n{\n\tint retval;\n\n\t \n\tretval = pci_reenable_device(pci_dev);\n\t \n\tif (pci_dev->is_busmaster)\n\t\tpci_set_master(pci_dev);\n\n\treturn retval;\n}\n\nstatic int pci_legacy_suspend(struct device *dev, pm_message_t state)\n{\n\tstruct pci_dev *pci_dev = to_pci_dev(dev);\n\tstruct pci_driver *drv = pci_dev->driver;\n\n\tif (drv && drv->suspend) {\n\t\tpci_power_t prev = pci_dev->current_state;\n\t\tint error;\n\n\t\terror = drv->suspend(pci_dev, state);\n\t\tsuspend_report_result(dev, drv->suspend, error);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tif (!pci_dev->state_saved && pci_dev->current_state != PCI_D0\n\t\t    && pci_dev->current_state != PCI_UNKNOWN) {\n\t\t\tpci_WARN_ONCE(pci_dev, pci_dev->current_state != prev,\n\t\t\t\t      \"PCI PM: Device state not saved by %pS\\n\",\n\t\t\t\t      drv->suspend);\n\t\t}\n\t}\n\n\tpci_fixup_device(pci_fixup_suspend, pci_dev);\n\n\treturn 0;\n}\n\nstatic int pci_legacy_suspend_late(struct device *dev)\n{\n\tstruct pci_dev *pci_dev = to_pci_dev(dev);\n\n\tif (!pci_dev->state_saved)\n\t\tpci_save_state(pci_dev);\n\n\tpci_pm_set_unknown_state(pci_dev);\n\n\tpci_fixup_device(pci_fixup_suspend_late, pci_dev);\n\n\treturn 0;\n}\n\nstatic int pci_legacy_resume(struct device *dev)\n{\n\tstruct pci_dev *pci_dev = to_pci_dev(dev);\n\tstruct pci_driver *drv = pci_dev->driver;\n\n\tpci_fixup_device(pci_fixup_resume, pci_dev);\n\n\treturn drv && drv->resume ?\n\t\t\tdrv->resume(pci_dev) : pci_pm_reenable_device(pci_dev);\n}\n\n \n\nstatic void pci_pm_default_suspend(struct pci_dev *pci_dev)\n{\n\t \n\tif (!pci_has_subordinate(pci_dev))\n\t\tpci_disable_enabled_device(pci_dev);\n}\n\nstatic bool pci_has_legacy_pm_support(struct pci_dev *pci_dev)\n{\n\tstruct pci_driver *drv = pci_dev->driver;\n\tbool ret = drv && (drv->suspend || drv->resume);\n\n\t \n\tpci_WARN(pci_dev, ret && drv->driver.pm, \"device %04x:%04x\\n\",\n\t\t pci_dev->vendor, pci_dev->device);\n\n\treturn ret;\n}\n\n \n\nstatic int pci_pm_prepare(struct device *dev)\n{\n\tstruct pci_dev *pci_dev = to_pci_dev(dev);\n\tconst struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;\n\n\tif (pm && pm->prepare) {\n\t\tint error = pm->prepare(dev);\n\t\tif (error < 0)\n\t\t\treturn error;\n\n\t\tif (!error && dev_pm_test_driver_flags(dev, DPM_FLAG_SMART_PREPARE))\n\t\t\treturn 0;\n\t}\n\tif (pci_dev_need_resume(pci_dev))\n\t\treturn 0;\n\n\t \n\tpci_dev_adjust_pme(pci_dev);\n\treturn 1;\n}\n\nstatic void pci_pm_complete(struct device *dev)\n{\n\tstruct pci_dev *pci_dev = to_pci_dev(dev);\n\n\tpci_dev_complete_resume(pci_dev);\n\tpm_generic_complete(dev);\n\n\t \n\tif (pm_runtime_suspended(dev) && pm_resume_via_firmware()) {\n\t\tpci_power_t pre_sleep_state = pci_dev->current_state;\n\n\t\tpci_refresh_power_state(pci_dev);\n\t\t \n\t\tif (pci_dev->current_state < pre_sleep_state)\n\t\t\tpm_request_resume(dev);\n\t}\n}\n\n#else  \n\n#define pci_pm_prepare\tNULL\n#define pci_pm_complete\tNULL\n\n#endif  \n\n#ifdef CONFIG_SUSPEND\nstatic void pcie_pme_root_status_cleanup(struct pci_dev *pci_dev)\n{\n\t \n\tif (pci_is_pcie(pci_dev) &&\n\t    (pci_pcie_type(pci_dev) == PCI_EXP_TYPE_ROOT_PORT ||\n\t     pci_pcie_type(pci_dev) == PCI_EXP_TYPE_RC_EC))\n\t\tpcie_clear_root_pme_status(pci_dev);\n}\n\nstatic int pci_pm_suspend(struct device *dev)\n{\n\tstruct pci_dev *pci_dev = to_pci_dev(dev);\n\tconst struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;\n\n\tpci_dev->skip_bus_pm = false;\n\n\t \n\tpci_suspend_ptm(pci_dev);\n\n\tif (pci_has_legacy_pm_support(pci_dev))\n\t\treturn pci_legacy_suspend(dev, PMSG_SUSPEND);\n\n\tif (!pm) {\n\t\tpci_pm_default_suspend(pci_dev);\n\t\treturn 0;\n\t}\n\n\t \n\tif (!dev_pm_test_driver_flags(dev, DPM_FLAG_SMART_SUSPEND) ||\n\t    pci_dev_need_resume(pci_dev)) {\n\t\tpm_runtime_resume(dev);\n\t\tpci_dev->state_saved = false;\n\t} else {\n\t\tpci_dev_adjust_pme(pci_dev);\n\t}\n\n\tif (pm->suspend) {\n\t\tpci_power_t prev = pci_dev->current_state;\n\t\tint error;\n\n\t\terror = pm->suspend(dev);\n\t\tsuspend_report_result(dev, pm->suspend, error);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tif (!pci_dev->state_saved && pci_dev->current_state != PCI_D0\n\t\t    && pci_dev->current_state != PCI_UNKNOWN) {\n\t\t\tpci_WARN_ONCE(pci_dev, pci_dev->current_state != prev,\n\t\t\t\t      \"PCI PM: State of device not saved by %pS\\n\",\n\t\t\t\t      pm->suspend);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int pci_pm_suspend_late(struct device *dev)\n{\n\tif (dev_pm_skip_suspend(dev))\n\t\treturn 0;\n\n\tpci_fixup_device(pci_fixup_suspend, to_pci_dev(dev));\n\n\treturn pm_generic_suspend_late(dev);\n}\n\nstatic int pci_pm_suspend_noirq(struct device *dev)\n{\n\tstruct pci_dev *pci_dev = to_pci_dev(dev);\n\tconst struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;\n\n\tif (dev_pm_skip_suspend(dev))\n\t\treturn 0;\n\n\tif (pci_has_legacy_pm_support(pci_dev))\n\t\treturn pci_legacy_suspend_late(dev);\n\n\tif (!pm) {\n\t\tpci_save_state(pci_dev);\n\t\tgoto Fixup;\n\t}\n\n\tif (pm->suspend_noirq) {\n\t\tpci_power_t prev = pci_dev->current_state;\n\t\tint error;\n\n\t\terror = pm->suspend_noirq(dev);\n\t\tsuspend_report_result(dev, pm->suspend_noirq, error);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tif (!pci_dev->state_saved && pci_dev->current_state != PCI_D0\n\t\t    && pci_dev->current_state != PCI_UNKNOWN) {\n\t\t\tpci_WARN_ONCE(pci_dev, pci_dev->current_state != prev,\n\t\t\t\t      \"PCI PM: State of device not saved by %pS\\n\",\n\t\t\t\t      pm->suspend_noirq);\n\t\t\tgoto Fixup;\n\t\t}\n\t}\n\n\tif (!pci_dev->state_saved) {\n\t\tpci_save_state(pci_dev);\n\n\t\t \n\t\tif (!pci_dev->skip_bus_pm && pci_power_manageable(pci_dev))\n\t\t\tpci_prepare_to_sleep(pci_dev);\n\t}\n\n\tpci_dbg(pci_dev, \"PCI PM: Suspend power state: %s\\n\",\n\t\tpci_power_name(pci_dev->current_state));\n\n\tif (pci_dev->current_state == PCI_D0) {\n\t\tpci_dev->skip_bus_pm = true;\n\t\t \n\t\tif (pci_dev->bus->self)\n\t\t\tpci_dev->bus->self->skip_bus_pm = true;\n\t}\n\n\tif (pci_dev->skip_bus_pm && pm_suspend_no_platform()) {\n\t\tpci_dbg(pci_dev, \"PCI PM: Skipped\\n\");\n\t\tgoto Fixup;\n\t}\n\n\tpci_pm_set_unknown_state(pci_dev);\n\n\t \n\tif (pci_dev->class == PCI_CLASS_SERIAL_USB_EHCI)\n\t\tpci_write_config_word(pci_dev, PCI_COMMAND, 0);\n\nFixup:\n\tpci_fixup_device(pci_fixup_suspend_late, pci_dev);\n\n\t \n\tif (device_can_wakeup(dev) && !device_may_wakeup(dev))\n\t\tdev->power.may_skip_resume = false;\n\n\treturn 0;\n}\n\nstatic int pci_pm_resume_noirq(struct device *dev)\n{\n\tstruct pci_dev *pci_dev = to_pci_dev(dev);\n\tconst struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;\n\tpci_power_t prev_state = pci_dev->current_state;\n\tbool skip_bus_pm = pci_dev->skip_bus_pm;\n\n\tif (dev_pm_skip_resume(dev))\n\t\treturn 0;\n\n\t \n\tif (!(skip_bus_pm && pm_suspend_no_platform()))\n\t\tpci_pm_default_resume_early(pci_dev);\n\n\tpci_fixup_device(pci_fixup_resume_early, pci_dev);\n\tpcie_pme_root_status_cleanup(pci_dev);\n\n\tif (!skip_bus_pm && prev_state == PCI_D3cold)\n\t\tpci_pm_bridge_power_up_actions(pci_dev);\n\n\tif (pci_has_legacy_pm_support(pci_dev))\n\t\treturn 0;\n\n\tif (pm && pm->resume_noirq)\n\t\treturn pm->resume_noirq(dev);\n\n\treturn 0;\n}\n\nstatic int pci_pm_resume_early(struct device *dev)\n{\n\tif (dev_pm_skip_resume(dev))\n\t\treturn 0;\n\n\treturn pm_generic_resume_early(dev);\n}\n\nstatic int pci_pm_resume(struct device *dev)\n{\n\tstruct pci_dev *pci_dev = to_pci_dev(dev);\n\tconst struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;\n\n\t \n\tif (pci_dev->state_saved)\n\t\tpci_restore_standard_config(pci_dev);\n\n\tpci_resume_ptm(pci_dev);\n\n\tif (pci_has_legacy_pm_support(pci_dev))\n\t\treturn pci_legacy_resume(dev);\n\n\tpci_pm_default_resume(pci_dev);\n\n\tif (pm) {\n\t\tif (pm->resume)\n\t\t\treturn pm->resume(dev);\n\t} else {\n\t\tpci_pm_reenable_device(pci_dev);\n\t}\n\n\treturn 0;\n}\n\n#else  \n\n#define pci_pm_suspend\t\tNULL\n#define pci_pm_suspend_late\tNULL\n#define pci_pm_suspend_noirq\tNULL\n#define pci_pm_resume\t\tNULL\n#define pci_pm_resume_early\tNULL\n#define pci_pm_resume_noirq\tNULL\n\n#endif  \n\n#ifdef CONFIG_HIBERNATE_CALLBACKS\n\nstatic int pci_pm_freeze(struct device *dev)\n{\n\tstruct pci_dev *pci_dev = to_pci_dev(dev);\n\tconst struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;\n\n\tif (pci_has_legacy_pm_support(pci_dev))\n\t\treturn pci_legacy_suspend(dev, PMSG_FREEZE);\n\n\tif (!pm) {\n\t\tpci_pm_default_suspend(pci_dev);\n\t\treturn 0;\n\t}\n\n\t \n\tpm_runtime_resume(dev);\n\tpci_dev->state_saved = false;\n\n\tif (pm->freeze) {\n\t\tint error;\n\n\t\terror = pm->freeze(dev);\n\t\tsuspend_report_result(dev, pm->freeze, error);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic int pci_pm_freeze_noirq(struct device *dev)\n{\n\tstruct pci_dev *pci_dev = to_pci_dev(dev);\n\tconst struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;\n\n\tif (pci_has_legacy_pm_support(pci_dev))\n\t\treturn pci_legacy_suspend_late(dev);\n\n\tif (pm && pm->freeze_noirq) {\n\t\tint error;\n\n\t\terror = pm->freeze_noirq(dev);\n\t\tsuspend_report_result(dev, pm->freeze_noirq, error);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tif (!pci_dev->state_saved)\n\t\tpci_save_state(pci_dev);\n\n\tpci_pm_set_unknown_state(pci_dev);\n\n\treturn 0;\n}\n\nstatic int pci_pm_thaw_noirq(struct device *dev)\n{\n\tstruct pci_dev *pci_dev = to_pci_dev(dev);\n\tconst struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;\n\n\t \n\tpci_pm_power_up_and_verify_state(pci_dev);\n\tpci_restore_state(pci_dev);\n\n\tif (pci_has_legacy_pm_support(pci_dev))\n\t\treturn 0;\n\n\tif (pm && pm->thaw_noirq)\n\t\treturn pm->thaw_noirq(dev);\n\n\treturn 0;\n}\n\nstatic int pci_pm_thaw(struct device *dev)\n{\n\tstruct pci_dev *pci_dev = to_pci_dev(dev);\n\tconst struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;\n\tint error = 0;\n\n\tif (pci_has_legacy_pm_support(pci_dev))\n\t\treturn pci_legacy_resume(dev);\n\n\tif (pm) {\n\t\tif (pm->thaw)\n\t\t\terror = pm->thaw(dev);\n\t} else {\n\t\tpci_pm_reenable_device(pci_dev);\n\t}\n\n\tpci_dev->state_saved = false;\n\n\treturn error;\n}\n\nstatic int pci_pm_poweroff(struct device *dev)\n{\n\tstruct pci_dev *pci_dev = to_pci_dev(dev);\n\tconst struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;\n\n\tif (pci_has_legacy_pm_support(pci_dev))\n\t\treturn pci_legacy_suspend(dev, PMSG_HIBERNATE);\n\n\tif (!pm) {\n\t\tpci_pm_default_suspend(pci_dev);\n\t\treturn 0;\n\t}\n\n\t \n\tif (!dev_pm_test_driver_flags(dev, DPM_FLAG_SMART_SUSPEND) ||\n\t    pci_dev_need_resume(pci_dev)) {\n\t\tpm_runtime_resume(dev);\n\t\tpci_dev->state_saved = false;\n\t} else {\n\t\tpci_dev_adjust_pme(pci_dev);\n\t}\n\n\tif (pm->poweroff) {\n\t\tint error;\n\n\t\terror = pm->poweroff(dev);\n\t\tsuspend_report_result(dev, pm->poweroff, error);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic int pci_pm_poweroff_late(struct device *dev)\n{\n\tif (dev_pm_skip_suspend(dev))\n\t\treturn 0;\n\n\tpci_fixup_device(pci_fixup_suspend, to_pci_dev(dev));\n\n\treturn pm_generic_poweroff_late(dev);\n}\n\nstatic int pci_pm_poweroff_noirq(struct device *dev)\n{\n\tstruct pci_dev *pci_dev = to_pci_dev(dev);\n\tconst struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;\n\n\tif (dev_pm_skip_suspend(dev))\n\t\treturn 0;\n\n\tif (pci_has_legacy_pm_support(pci_dev))\n\t\treturn pci_legacy_suspend_late(dev);\n\n\tif (!pm) {\n\t\tpci_fixup_device(pci_fixup_suspend_late, pci_dev);\n\t\treturn 0;\n\t}\n\n\tif (pm->poweroff_noirq) {\n\t\tint error;\n\n\t\terror = pm->poweroff_noirq(dev);\n\t\tsuspend_report_result(dev, pm->poweroff_noirq, error);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tif (!pci_dev->state_saved && !pci_has_subordinate(pci_dev))\n\t\tpci_prepare_to_sleep(pci_dev);\n\n\t \n\tif (pci_dev->class == PCI_CLASS_SERIAL_USB_EHCI)\n\t\tpci_write_config_word(pci_dev, PCI_COMMAND, 0);\n\n\tpci_fixup_device(pci_fixup_suspend_late, pci_dev);\n\n\treturn 0;\n}\n\nstatic int pci_pm_restore_noirq(struct device *dev)\n{\n\tstruct pci_dev *pci_dev = to_pci_dev(dev);\n\tconst struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;\n\n\tpci_pm_default_resume_early(pci_dev);\n\tpci_fixup_device(pci_fixup_resume_early, pci_dev);\n\n\tif (pci_has_legacy_pm_support(pci_dev))\n\t\treturn 0;\n\n\tif (pm && pm->restore_noirq)\n\t\treturn pm->restore_noirq(dev);\n\n\treturn 0;\n}\n\nstatic int pci_pm_restore(struct device *dev)\n{\n\tstruct pci_dev *pci_dev = to_pci_dev(dev);\n\tconst struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;\n\n\t \n\tif (pci_dev->state_saved)\n\t\tpci_restore_standard_config(pci_dev);\n\n\tif (pci_has_legacy_pm_support(pci_dev))\n\t\treturn pci_legacy_resume(dev);\n\n\tpci_pm_default_resume(pci_dev);\n\n\tif (pm) {\n\t\tif (pm->restore)\n\t\t\treturn pm->restore(dev);\n\t} else {\n\t\tpci_pm_reenable_device(pci_dev);\n\t}\n\n\treturn 0;\n}\n\n#else  \n\n#define pci_pm_freeze\t\tNULL\n#define pci_pm_freeze_noirq\tNULL\n#define pci_pm_thaw\t\tNULL\n#define pci_pm_thaw_noirq\tNULL\n#define pci_pm_poweroff\t\tNULL\n#define pci_pm_poweroff_late\tNULL\n#define pci_pm_poweroff_noirq\tNULL\n#define pci_pm_restore\t\tNULL\n#define pci_pm_restore_noirq\tNULL\n\n#endif  \n\n#ifdef CONFIG_PM\n\nstatic int pci_pm_runtime_suspend(struct device *dev)\n{\n\tstruct pci_dev *pci_dev = to_pci_dev(dev);\n\tconst struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;\n\tpci_power_t prev = pci_dev->current_state;\n\tint error;\n\n\tpci_suspend_ptm(pci_dev);\n\n\t \n\tif (!pci_dev->driver) {\n\t\tpci_save_state(pci_dev);\n\t\treturn 0;\n\t}\n\n\tpci_dev->state_saved = false;\n\tif (pm && pm->runtime_suspend) {\n\t\terror = pm->runtime_suspend(dev);\n\t\t \n\t\tif (error == -EBUSY || error == -EAGAIN) {\n\t\t\tpci_dbg(pci_dev, \"can't suspend now (%ps returned %d)\\n\",\n\t\t\t\tpm->runtime_suspend, error);\n\t\t\treturn error;\n\t\t} else if (error) {\n\t\t\tpci_err(pci_dev, \"can't suspend (%ps returned %d)\\n\",\n\t\t\t\tpm->runtime_suspend, error);\n\t\t\treturn error;\n\t\t}\n\t}\n\n\tpci_fixup_device(pci_fixup_suspend, pci_dev);\n\n\tif (pm && pm->runtime_suspend\n\t    && !pci_dev->state_saved && pci_dev->current_state != PCI_D0\n\t    && pci_dev->current_state != PCI_UNKNOWN) {\n\t\tpci_WARN_ONCE(pci_dev, pci_dev->current_state != prev,\n\t\t\t      \"PCI PM: State of device not saved by %pS\\n\",\n\t\t\t      pm->runtime_suspend);\n\t\treturn 0;\n\t}\n\n\tif (!pci_dev->state_saved) {\n\t\tpci_save_state(pci_dev);\n\t\tpci_finish_runtime_suspend(pci_dev);\n\t}\n\n\treturn 0;\n}\n\nstatic int pci_pm_runtime_resume(struct device *dev)\n{\n\tstruct pci_dev *pci_dev = to_pci_dev(dev);\n\tconst struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;\n\tpci_power_t prev_state = pci_dev->current_state;\n\tint error = 0;\n\n\t \n\tpci_pm_default_resume_early(pci_dev);\n\tpci_resume_ptm(pci_dev);\n\n\tif (!pci_dev->driver)\n\t\treturn 0;\n\n\tpci_fixup_device(pci_fixup_resume_early, pci_dev);\n\tpci_pm_default_resume(pci_dev);\n\n\tif (prev_state == PCI_D3cold)\n\t\tpci_pm_bridge_power_up_actions(pci_dev);\n\n\tif (pm && pm->runtime_resume)\n\t\terror = pm->runtime_resume(dev);\n\n\treturn error;\n}\n\nstatic int pci_pm_runtime_idle(struct device *dev)\n{\n\tstruct pci_dev *pci_dev = to_pci_dev(dev);\n\tconst struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;\n\n\t \n\tif (!pci_dev->driver)\n\t\treturn 0;\n\n\tif (!pm)\n\t\treturn -ENOSYS;\n\n\tif (pm->runtime_idle)\n\t\treturn pm->runtime_idle(dev);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops pci_dev_pm_ops = {\n\t.prepare = pci_pm_prepare,\n\t.complete = pci_pm_complete,\n\t.suspend = pci_pm_suspend,\n\t.suspend_late = pci_pm_suspend_late,\n\t.resume = pci_pm_resume,\n\t.resume_early = pci_pm_resume_early,\n\t.freeze = pci_pm_freeze,\n\t.thaw = pci_pm_thaw,\n\t.poweroff = pci_pm_poweroff,\n\t.poweroff_late = pci_pm_poweroff_late,\n\t.restore = pci_pm_restore,\n\t.suspend_noirq = pci_pm_suspend_noirq,\n\t.resume_noirq = pci_pm_resume_noirq,\n\t.freeze_noirq = pci_pm_freeze_noirq,\n\t.thaw_noirq = pci_pm_thaw_noirq,\n\t.poweroff_noirq = pci_pm_poweroff_noirq,\n\t.restore_noirq = pci_pm_restore_noirq,\n\t.runtime_suspend = pci_pm_runtime_suspend,\n\t.runtime_resume = pci_pm_runtime_resume,\n\t.runtime_idle = pci_pm_runtime_idle,\n};\n\n#define PCI_PM_OPS_PTR\t(&pci_dev_pm_ops)\n\n#else  \n\n#define pci_pm_runtime_suspend\tNULL\n#define pci_pm_runtime_resume\tNULL\n#define pci_pm_runtime_idle\tNULL\n\n#define PCI_PM_OPS_PTR\tNULL\n\n#endif  \n\n \nint __pci_register_driver(struct pci_driver *drv, struct module *owner,\n\t\t\t  const char *mod_name)\n{\n\t \n\tdrv->driver.name = drv->name;\n\tdrv->driver.bus = &pci_bus_type;\n\tdrv->driver.owner = owner;\n\tdrv->driver.mod_name = mod_name;\n\tdrv->driver.groups = drv->groups;\n\tdrv->driver.dev_groups = drv->dev_groups;\n\n\tspin_lock_init(&drv->dynids.lock);\n\tINIT_LIST_HEAD(&drv->dynids.list);\n\n\t \n\treturn driver_register(&drv->driver);\n}\nEXPORT_SYMBOL(__pci_register_driver);\n\n \n\nvoid pci_unregister_driver(struct pci_driver *drv)\n{\n\tdriver_unregister(&drv->driver);\n\tpci_free_dynids(drv);\n}\nEXPORT_SYMBOL(pci_unregister_driver);\n\nstatic struct pci_driver pci_compat_driver = {\n\t.name = \"compat\"\n};\n\n \nstruct pci_driver *pci_dev_driver(const struct pci_dev *dev)\n{\n\tint i;\n\n\tif (dev->driver)\n\t\treturn dev->driver;\n\n\tfor (i = 0; i <= PCI_ROM_RESOURCE; i++)\n\t\tif (dev->resource[i].flags & IORESOURCE_BUSY)\n\t\t\treturn &pci_compat_driver;\n\n\treturn NULL;\n}\nEXPORT_SYMBOL(pci_dev_driver);\n\n \nstatic int pci_bus_match(struct device *dev, struct device_driver *drv)\n{\n\tstruct pci_dev *pci_dev = to_pci_dev(dev);\n\tstruct pci_driver *pci_drv;\n\tconst struct pci_device_id *found_id;\n\n\tif (!pci_dev->match_driver)\n\t\treturn 0;\n\n\tpci_drv = to_pci_driver(drv);\n\tfound_id = pci_match_device(pci_drv, pci_dev);\n\tif (found_id)\n\t\treturn 1;\n\n\treturn 0;\n}\n\n \nstruct pci_dev *pci_dev_get(struct pci_dev *dev)\n{\n\tif (dev)\n\t\tget_device(&dev->dev);\n\treturn dev;\n}\nEXPORT_SYMBOL(pci_dev_get);\n\n \nvoid pci_dev_put(struct pci_dev *dev)\n{\n\tif (dev)\n\t\tput_device(&dev->dev);\n}\nEXPORT_SYMBOL(pci_dev_put);\n\nstatic int pci_uevent(const struct device *dev, struct kobj_uevent_env *env)\n{\n\tconst struct pci_dev *pdev;\n\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tpdev = to_pci_dev(dev);\n\n\tif (add_uevent_var(env, \"PCI_CLASS=%04X\", pdev->class))\n\t\treturn -ENOMEM;\n\n\tif (add_uevent_var(env, \"PCI_ID=%04X:%04X\", pdev->vendor, pdev->device))\n\t\treturn -ENOMEM;\n\n\tif (add_uevent_var(env, \"PCI_SUBSYS_ID=%04X:%04X\", pdev->subsystem_vendor,\n\t\t\t   pdev->subsystem_device))\n\t\treturn -ENOMEM;\n\n\tif (add_uevent_var(env, \"PCI_SLOT_NAME=%s\", pci_name(pdev)))\n\t\treturn -ENOMEM;\n\n\tif (add_uevent_var(env, \"MODALIAS=pci:v%08Xd%08Xsv%08Xsd%08Xbc%02Xsc%02Xi%02X\",\n\t\t\t   pdev->vendor, pdev->device,\n\t\t\t   pdev->subsystem_vendor, pdev->subsystem_device,\n\t\t\t   (u8)(pdev->class >> 16), (u8)(pdev->class >> 8),\n\t\t\t   (u8)(pdev->class)))\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\n#if defined(CONFIG_PCIEAER) || defined(CONFIG_EEH)\n \nvoid pci_uevent_ers(struct pci_dev *pdev, enum pci_ers_result err_type)\n{\n\tint idx = 0;\n\tchar *envp[3];\n\n\tswitch (err_type) {\n\tcase PCI_ERS_RESULT_NONE:\n\tcase PCI_ERS_RESULT_CAN_RECOVER:\n\t\tenvp[idx++] = \"ERROR_EVENT=BEGIN_RECOVERY\";\n\t\tenvp[idx++] = \"DEVICE_ONLINE=0\";\n\t\tbreak;\n\tcase PCI_ERS_RESULT_RECOVERED:\n\t\tenvp[idx++] = \"ERROR_EVENT=SUCCESSFUL_RECOVERY\";\n\t\tenvp[idx++] = \"DEVICE_ONLINE=1\";\n\t\tbreak;\n\tcase PCI_ERS_RESULT_DISCONNECT:\n\t\tenvp[idx++] = \"ERROR_EVENT=FAILED_RECOVERY\";\n\t\tenvp[idx++] = \"DEVICE_ONLINE=0\";\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (idx > 0) {\n\t\tenvp[idx++] = NULL;\n\t\tkobject_uevent_env(&pdev->dev.kobj, KOBJ_CHANGE, envp);\n\t}\n}\n#endif\n\nstatic int pci_bus_num_vf(struct device *dev)\n{\n\treturn pci_num_vf(to_pci_dev(dev));\n}\n\n \nstatic int pci_dma_configure(struct device *dev)\n{\n\tstruct pci_driver *driver = to_pci_driver(dev->driver);\n\tstruct device *bridge;\n\tint ret = 0;\n\n\tbridge = pci_get_host_bridge_device(to_pci_dev(dev));\n\n\tif (IS_ENABLED(CONFIG_OF) && bridge->parent &&\n\t    bridge->parent->of_node) {\n\t\tret = of_dma_configure(dev, bridge->parent->of_node, true);\n\t} else if (has_acpi_companion(bridge)) {\n\t\tstruct acpi_device *adev = to_acpi_device_node(bridge->fwnode);\n\n\t\tret = acpi_dma_configure(dev, acpi_get_dma_attr(adev));\n\t}\n\n\tpci_put_host_bridge_device(bridge);\n\n\tif (!ret && !driver->driver_managed_dma) {\n\t\tret = iommu_device_use_default_domain(dev);\n\t\tif (ret)\n\t\t\tarch_teardown_dma_ops(dev);\n\t}\n\n\treturn ret;\n}\n\nstatic void pci_dma_cleanup(struct device *dev)\n{\n\tstruct pci_driver *driver = to_pci_driver(dev->driver);\n\n\tif (!driver->driver_managed_dma)\n\t\tiommu_device_unuse_default_domain(dev);\n}\n\nstruct bus_type pci_bus_type = {\n\t.name\t\t= \"pci\",\n\t.match\t\t= pci_bus_match,\n\t.uevent\t\t= pci_uevent,\n\t.probe\t\t= pci_device_probe,\n\t.remove\t\t= pci_device_remove,\n\t.shutdown\t= pci_device_shutdown,\n\t.dev_groups\t= pci_dev_groups,\n\t.bus_groups\t= pci_bus_groups,\n\t.drv_groups\t= pci_drv_groups,\n\t.pm\t\t= PCI_PM_OPS_PTR,\n\t.num_vf\t\t= pci_bus_num_vf,\n\t.dma_configure\t= pci_dma_configure,\n\t.dma_cleanup\t= pci_dma_cleanup,\n};\nEXPORT_SYMBOL(pci_bus_type);\n\n#ifdef CONFIG_PCIEPORTBUS\nstatic int pcie_port_bus_match(struct device *dev, struct device_driver *drv)\n{\n\tstruct pcie_device *pciedev;\n\tstruct pcie_port_service_driver *driver;\n\n\tif (drv->bus != &pcie_port_bus_type || dev->bus != &pcie_port_bus_type)\n\t\treturn 0;\n\n\tpciedev = to_pcie_device(dev);\n\tdriver = to_service_driver(drv);\n\n\tif (driver->service != pciedev->service)\n\t\treturn 0;\n\n\tif (driver->port_type != PCIE_ANY_PORT &&\n\t    driver->port_type != pci_pcie_type(pciedev->port))\n\t\treturn 0;\n\n\treturn 1;\n}\n\nstruct bus_type pcie_port_bus_type = {\n\t.name\t\t= \"pci_express\",\n\t.match\t\t= pcie_port_bus_match,\n};\n#endif\n\nstatic int __init pci_driver_init(void)\n{\n\tint ret;\n\n\tret = bus_register(&pci_bus_type);\n\tif (ret)\n\t\treturn ret;\n\n#ifdef CONFIG_PCIEPORTBUS\n\tret = bus_register(&pcie_port_bus_type);\n\tif (ret)\n\t\treturn ret;\n#endif\n\tdma_debug_add_bus(&pci_bus_type);\n\treturn 0;\n}\npostcore_initcall(pci_driver_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}