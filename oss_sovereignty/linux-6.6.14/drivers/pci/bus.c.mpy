{
  "module_name": "bus.c",
  "hash_id": "f382d3df45bdb5ac251cded3c04d9ea5ed1d68898bd3f035b9c447581d238840",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/bus.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/pci.h>\n#include <linux/errno.h>\n#include <linux/ioport.h>\n#include <linux/of.h>\n#include <linux/proc_fs.h>\n#include <linux/slab.h>\n\n#include \"pci.h\"\n\nvoid pci_add_resource_offset(struct list_head *resources, struct resource *res,\n\t\t\t     resource_size_t offset)\n{\n\tstruct resource_entry *entry;\n\n\tentry = resource_list_create_entry(res, 0);\n\tif (!entry) {\n\t\tpr_err(\"PCI: can't add host bridge window %pR\\n\", res);\n\t\treturn;\n\t}\n\n\tentry->offset = offset;\n\tresource_list_add_tail(entry, resources);\n}\nEXPORT_SYMBOL(pci_add_resource_offset);\n\nvoid pci_add_resource(struct list_head *resources, struct resource *res)\n{\n\tpci_add_resource_offset(resources, res, 0);\n}\nEXPORT_SYMBOL(pci_add_resource);\n\nvoid pci_free_resource_list(struct list_head *resources)\n{\n\tresource_list_free(resources);\n}\nEXPORT_SYMBOL(pci_free_resource_list);\n\nvoid pci_bus_add_resource(struct pci_bus *bus, struct resource *res,\n\t\t\t  unsigned int flags)\n{\n\tstruct pci_bus_resource *bus_res;\n\n\tbus_res = kzalloc(sizeof(struct pci_bus_resource), GFP_KERNEL);\n\tif (!bus_res) {\n\t\tdev_err(&bus->dev, \"can't add %pR resource\\n\", res);\n\t\treturn;\n\t}\n\n\tbus_res->res = res;\n\tbus_res->flags = flags;\n\tlist_add_tail(&bus_res->list, &bus->resources);\n}\n\nstruct resource *pci_bus_resource_n(const struct pci_bus *bus, int n)\n{\n\tstruct pci_bus_resource *bus_res;\n\n\tif (n < PCI_BRIDGE_RESOURCE_NUM)\n\t\treturn bus->resource[n];\n\n\tn -= PCI_BRIDGE_RESOURCE_NUM;\n\tlist_for_each_entry(bus_res, &bus->resources, list) {\n\t\tif (n-- == 0)\n\t\t\treturn bus_res->res;\n\t}\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(pci_bus_resource_n);\n\nvoid pci_bus_remove_resource(struct pci_bus *bus, struct resource *res)\n{\n\tstruct pci_bus_resource *bus_res, *tmp;\n\tint i;\n\n\tfor (i = 0; i < PCI_BRIDGE_RESOURCE_NUM; i++) {\n\t\tif (bus->resource[i] == res) {\n\t\t\tbus->resource[i] = NULL;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tlist_for_each_entry_safe(bus_res, tmp, &bus->resources, list) {\n\t\tif (bus_res->res == res) {\n\t\t\tlist_del(&bus_res->list);\n\t\t\tkfree(bus_res);\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nvoid pci_bus_remove_resources(struct pci_bus *bus)\n{\n\tint i;\n\tstruct pci_bus_resource *bus_res, *tmp;\n\n\tfor (i = 0; i < PCI_BRIDGE_RESOURCE_NUM; i++)\n\t\tbus->resource[i] = NULL;\n\n\tlist_for_each_entry_safe(bus_res, tmp, &bus->resources, list) {\n\t\tlist_del(&bus_res->list);\n\t\tkfree(bus_res);\n\t}\n}\n\nint devm_request_pci_bus_resources(struct device *dev,\n\t\t\t\t   struct list_head *resources)\n{\n\tstruct resource_entry *win;\n\tstruct resource *parent, *res;\n\tint err;\n\n\tresource_list_for_each_entry(win, resources) {\n\t\tres = win->res;\n\t\tswitch (resource_type(res)) {\n\t\tcase IORESOURCE_IO:\n\t\t\tparent = &ioport_resource;\n\t\t\tbreak;\n\t\tcase IORESOURCE_MEM:\n\t\t\tparent = &iomem_resource;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\n\t\terr = devm_request_resource(dev, parent, res);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(devm_request_pci_bus_resources);\n\nstatic struct pci_bus_region pci_32_bit = {0, 0xffffffffULL};\n#ifdef CONFIG_ARCH_DMA_ADDR_T_64BIT\nstatic struct pci_bus_region pci_64_bit = {0,\n\t\t\t\t(pci_bus_addr_t) 0xffffffffffffffffULL};\nstatic struct pci_bus_region pci_high = {(pci_bus_addr_t) 0x100000000ULL,\n\t\t\t\t(pci_bus_addr_t) 0xffffffffffffffffULL};\n#endif\n\n \nstatic void pci_clip_resource_to_region(struct pci_bus *bus,\n\t\t\t\t\tstruct resource *res,\n\t\t\t\t\tstruct pci_bus_region *region)\n{\n\tstruct pci_bus_region r;\n\n\tpcibios_resource_to_bus(bus, &r, res);\n\tif (r.start < region->start)\n\t\tr.start = region->start;\n\tif (r.end > region->end)\n\t\tr.end = region->end;\n\n\tif (r.end < r.start)\n\t\tres->end = res->start - 1;\n\telse\n\t\tpcibios_bus_to_resource(bus, res, &r);\n}\n\nstatic int pci_bus_alloc_from_region(struct pci_bus *bus, struct resource *res,\n\t\tresource_size_t size, resource_size_t align,\n\t\tresource_size_t min, unsigned long type_mask,\n\t\tresource_size_t (*alignf)(void *,\n\t\t\t\t\t  const struct resource *,\n\t\t\t\t\t  resource_size_t,\n\t\t\t\t\t  resource_size_t),\n\t\tvoid *alignf_data,\n\t\tstruct pci_bus_region *region)\n{\n\tstruct resource *r, avail;\n\tresource_size_t max;\n\tint ret;\n\n\ttype_mask |= IORESOURCE_TYPE_BITS;\n\n\tpci_bus_for_each_resource(bus, r) {\n\t\tresource_size_t min_used = min;\n\n\t\tif (!r)\n\t\t\tcontinue;\n\n\t\t \n\t\tif ((res->flags ^ r->flags) & type_mask)\n\t\t\tcontinue;\n\n\t\t \n\t\tif ((r->flags & IORESOURCE_PREFETCH) &&\n\t\t    !(res->flags & IORESOURCE_PREFETCH))\n\t\t\tcontinue;\n\n\t\tavail = *r;\n\t\tpci_clip_resource_to_region(bus, &avail, region);\n\n\t\t \n\t\tif (avail.start)\n\t\t\tmin_used = avail.start;\n\n\t\tmax = avail.end;\n\n\t\t \n\t\tif (size > max - min_used + 1)\n\t\t\tcontinue;\n\n\t\t \n\t\tret = allocate_resource(r, res, size, min_used, max,\n\t\t\t\t\talign, alignf, alignf_data);\n\t\tif (ret == 0)\n\t\t\treturn 0;\n\t}\n\treturn -ENOMEM;\n}\n\n \nint pci_bus_alloc_resource(struct pci_bus *bus, struct resource *res,\n\t\tresource_size_t size, resource_size_t align,\n\t\tresource_size_t min, unsigned long type_mask,\n\t\tresource_size_t (*alignf)(void *,\n\t\t\t\t\t  const struct resource *,\n\t\t\t\t\t  resource_size_t,\n\t\t\t\t\t  resource_size_t),\n\t\tvoid *alignf_data)\n{\n#ifdef CONFIG_ARCH_DMA_ADDR_T_64BIT\n\tint rc;\n\n\tif (res->flags & IORESOURCE_MEM_64) {\n\t\trc = pci_bus_alloc_from_region(bus, res, size, align, min,\n\t\t\t\t\t       type_mask, alignf, alignf_data,\n\t\t\t\t\t       &pci_high);\n\t\tif (rc == 0)\n\t\t\treturn 0;\n\n\t\treturn pci_bus_alloc_from_region(bus, res, size, align, min,\n\t\t\t\t\t\t type_mask, alignf, alignf_data,\n\t\t\t\t\t\t &pci_64_bit);\n\t}\n#endif\n\n\treturn pci_bus_alloc_from_region(bus, res, size, align, min,\n\t\t\t\t\t type_mask, alignf, alignf_data,\n\t\t\t\t\t &pci_32_bit);\n}\nEXPORT_SYMBOL(pci_bus_alloc_resource);\n\n \nbool pci_bus_clip_resource(struct pci_dev *dev, int idx)\n{\n\tstruct pci_bus *bus = dev->bus;\n\tstruct resource *res = &dev->resource[idx];\n\tstruct resource orig_res = *res;\n\tstruct resource *r;\n\n\tpci_bus_for_each_resource(bus, r) {\n\t\tresource_size_t start, end;\n\n\t\tif (!r)\n\t\t\tcontinue;\n\n\t\tif (resource_type(res) != resource_type(r))\n\t\t\tcontinue;\n\n\t\tstart = max(r->start, res->start);\n\t\tend = min(r->end, res->end);\n\n\t\tif (start > end)\n\t\t\tcontinue;\t \n\n\t\tif (res->start == start && res->end == end)\n\t\t\treturn false;\t \n\n\t\tres->start = start;\n\t\tres->end = end;\n\t\tres->flags &= ~IORESOURCE_UNSET;\n\t\torig_res.flags &= ~IORESOURCE_UNSET;\n\t\tpci_info(dev, \"%pR clipped to %pR\\n\", &orig_res, res);\n\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nvoid __weak pcibios_resource_survey_bus(struct pci_bus *bus) { }\n\nvoid __weak pcibios_bus_add_device(struct pci_dev *pdev) { }\n\n \nvoid pci_bus_add_device(struct pci_dev *dev)\n{\n\tstruct device_node *dn = dev->dev.of_node;\n\tint retval;\n\n\t \n\tpcibios_bus_add_device(dev);\n\tpci_fixup_device(pci_fixup_final, dev);\n\tif (pci_is_bridge(dev))\n\t\tof_pci_make_dev_node(dev);\n\tpci_create_sysfs_dev_files(dev);\n\tpci_proc_attach_device(dev);\n\tpci_bridge_d3_update(dev);\n\n\tdev->match_driver = !dn || of_device_is_available(dn);\n\tretval = device_attach(&dev->dev);\n\tif (retval < 0 && retval != -EPROBE_DEFER)\n\t\tpci_warn(dev, \"device attach failed (%d)\\n\", retval);\n\n\tpci_dev_assign_added(dev, true);\n}\nEXPORT_SYMBOL_GPL(pci_bus_add_device);\n\n \nvoid pci_bus_add_devices(const struct pci_bus *bus)\n{\n\tstruct pci_dev *dev;\n\tstruct pci_bus *child;\n\n\tlist_for_each_entry(dev, &bus->devices, bus_list) {\n\t\t \n\t\tif (pci_dev_is_added(dev))\n\t\t\tcontinue;\n\t\tpci_bus_add_device(dev);\n\t}\n\n\tlist_for_each_entry(dev, &bus->devices, bus_list) {\n\t\t \n\t\tif (!pci_dev_is_added(dev))\n\t\t\tcontinue;\n\t\tchild = dev->subordinate;\n\t\tif (child)\n\t\t\tpci_bus_add_devices(child);\n\t}\n}\nEXPORT_SYMBOL(pci_bus_add_devices);\n\n \nvoid pci_walk_bus(struct pci_bus *top, int (*cb)(struct pci_dev *, void *),\n\t\t  void *userdata)\n{\n\tstruct pci_dev *dev;\n\tstruct pci_bus *bus;\n\tstruct list_head *next;\n\tint retval;\n\n\tbus = top;\n\tdown_read(&pci_bus_sem);\n\tnext = top->devices.next;\n\tfor (;;) {\n\t\tif (next == &bus->devices) {\n\t\t\t \n\t\t\tif (bus == top)\n\t\t\t\tbreak;\n\t\t\tnext = bus->self->bus_list.next;\n\t\t\tbus = bus->self->bus;\n\t\t\tcontinue;\n\t\t}\n\t\tdev = list_entry(next, struct pci_dev, bus_list);\n\t\tif (dev->subordinate) {\n\t\t\t \n\t\t\tnext = dev->subordinate->devices.next;\n\t\t\tbus = dev->subordinate;\n\t\t} else\n\t\t\tnext = dev->bus_list.next;\n\n\t\tretval = cb(dev, userdata);\n\t\tif (retval)\n\t\t\tbreak;\n\t}\n\tup_read(&pci_bus_sem);\n}\nEXPORT_SYMBOL_GPL(pci_walk_bus);\n\nstruct pci_bus *pci_bus_get(struct pci_bus *bus)\n{\n\tif (bus)\n\t\tget_device(&bus->dev);\n\treturn bus;\n}\n\nvoid pci_bus_put(struct pci_bus *bus)\n{\n\tif (bus)\n\t\tput_device(&bus->dev);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}