{
  "module_name": "slot.c",
  "hash_id": "a5ba3ae6ff7fe4d6efded618e139a036e4e8e2ee7fd71a586cc4eea7a1cf2ff7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/slot.c",
  "human_readable_source": "\n \n\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/err.h>\n#include \"pci.h\"\n\nstruct kset *pci_slots_kset;\nEXPORT_SYMBOL_GPL(pci_slots_kset);\n\nstatic ssize_t pci_slot_attr_show(struct kobject *kobj,\n\t\t\t\t\tstruct attribute *attr, char *buf)\n{\n\tstruct pci_slot *slot = to_pci_slot(kobj);\n\tstruct pci_slot_attribute *attribute = to_pci_slot_attr(attr);\n\treturn attribute->show ? attribute->show(slot, buf) : -EIO;\n}\n\nstatic ssize_t pci_slot_attr_store(struct kobject *kobj,\n\t\t\tstruct attribute *attr, const char *buf, size_t len)\n{\n\tstruct pci_slot *slot = to_pci_slot(kobj);\n\tstruct pci_slot_attribute *attribute = to_pci_slot_attr(attr);\n\treturn attribute->store ? attribute->store(slot, buf, len) : -EIO;\n}\n\nstatic const struct sysfs_ops pci_slot_sysfs_ops = {\n\t.show = pci_slot_attr_show,\n\t.store = pci_slot_attr_store,\n};\n\nstatic ssize_t address_read_file(struct pci_slot *slot, char *buf)\n{\n\tif (slot->number == 0xff)\n\t\treturn sysfs_emit(buf, \"%04x:%02x\\n\",\n\t\t\t\t  pci_domain_nr(slot->bus),\n\t\t\t\t  slot->bus->number);\n\n\treturn sysfs_emit(buf, \"%04x:%02x:%02x\\n\",\n\t\t\t  pci_domain_nr(slot->bus),\n\t\t\t  slot->bus->number,\n\t\t\t  slot->number);\n}\n\nstatic ssize_t bus_speed_read(enum pci_bus_speed speed, char *buf)\n{\n\treturn sysfs_emit(buf, \"%s\\n\", pci_speed_string(speed));\n}\n\nstatic ssize_t max_speed_read_file(struct pci_slot *slot, char *buf)\n{\n\treturn bus_speed_read(slot->bus->max_bus_speed, buf);\n}\n\nstatic ssize_t cur_speed_read_file(struct pci_slot *slot, char *buf)\n{\n\treturn bus_speed_read(slot->bus->cur_bus_speed, buf);\n}\n\nstatic void pci_slot_release(struct kobject *kobj)\n{\n\tstruct pci_dev *dev;\n\tstruct pci_slot *slot = to_pci_slot(kobj);\n\n\tdev_dbg(&slot->bus->dev, \"dev %02x, released physical slot %s\\n\",\n\t\tslot->number, pci_slot_name(slot));\n\n\tdown_read(&pci_bus_sem);\n\tlist_for_each_entry(dev, &slot->bus->devices, bus_list)\n\t\tif (PCI_SLOT(dev->devfn) == slot->number)\n\t\t\tdev->slot = NULL;\n\tup_read(&pci_bus_sem);\n\n\tlist_del(&slot->list);\n\n\tkfree(slot);\n}\n\nstatic struct pci_slot_attribute pci_slot_attr_address =\n\t__ATTR(address, S_IRUGO, address_read_file, NULL);\nstatic struct pci_slot_attribute pci_slot_attr_max_speed =\n\t__ATTR(max_bus_speed, S_IRUGO, max_speed_read_file, NULL);\nstatic struct pci_slot_attribute pci_slot_attr_cur_speed =\n\t__ATTR(cur_bus_speed, S_IRUGO, cur_speed_read_file, NULL);\n\nstatic struct attribute *pci_slot_default_attrs[] = {\n\t&pci_slot_attr_address.attr,\n\t&pci_slot_attr_max_speed.attr,\n\t&pci_slot_attr_cur_speed.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(pci_slot_default);\n\nstatic const struct kobj_type pci_slot_ktype = {\n\t.sysfs_ops = &pci_slot_sysfs_ops,\n\t.release = &pci_slot_release,\n\t.default_groups = pci_slot_default_groups,\n};\n\nstatic char *make_slot_name(const char *name)\n{\n\tchar *new_name;\n\tint len, max, dup;\n\n\tnew_name = kstrdup(name, GFP_KERNEL);\n\tif (!new_name)\n\t\treturn NULL;\n\n\t \n\tlen = strlen(name) + 2;\n\tmax = 1;\n\tdup = 1;\n\n\tfor (;;) {\n\t\tstruct kobject *dup_slot;\n\t\tdup_slot = kset_find_obj(pci_slots_kset, new_name);\n\t\tif (!dup_slot)\n\t\t\tbreak;\n\t\tkobject_put(dup_slot);\n\t\tif (dup == max) {\n\t\t\tlen++;\n\t\t\tmax *= 10;\n\t\t\tkfree(new_name);\n\t\t\tnew_name = kmalloc(len, GFP_KERNEL);\n\t\t\tif (!new_name)\n\t\t\t\tbreak;\n\t\t}\n\t\tsprintf(new_name, \"%s-%d\", name, dup++);\n\t}\n\n\treturn new_name;\n}\n\nstatic int rename_slot(struct pci_slot *slot, const char *name)\n{\n\tint result = 0;\n\tchar *slot_name;\n\n\tif (strcmp(pci_slot_name(slot), name) == 0)\n\t\treturn result;\n\n\tslot_name = make_slot_name(name);\n\tif (!slot_name)\n\t\treturn -ENOMEM;\n\n\tresult = kobject_rename(&slot->kobj, slot_name);\n\tkfree(slot_name);\n\n\treturn result;\n}\n\nvoid pci_dev_assign_slot(struct pci_dev *dev)\n{\n\tstruct pci_slot *slot;\n\n\tmutex_lock(&pci_slot_mutex);\n\tlist_for_each_entry(slot, &dev->bus->slots, list)\n\t\tif (PCI_SLOT(dev->devfn) == slot->number)\n\t\t\tdev->slot = slot;\n\tmutex_unlock(&pci_slot_mutex);\n}\n\nstatic struct pci_slot *get_slot(struct pci_bus *parent, int slot_nr)\n{\n\tstruct pci_slot *slot;\n\n\t \n\tlist_for_each_entry(slot, &parent->slots, list)\n\t\tif (slot->number == slot_nr) {\n\t\t\tkobject_get(&slot->kobj);\n\t\t\treturn slot;\n\t\t}\n\n\treturn NULL;\n}\n\n \nstruct pci_slot *pci_create_slot(struct pci_bus *parent, int slot_nr,\n\t\t\t\t const char *name,\n\t\t\t\t struct hotplug_slot *hotplug)\n{\n\tstruct pci_dev *dev;\n\tstruct pci_slot *slot;\n\tint err = 0;\n\tchar *slot_name = NULL;\n\n\tmutex_lock(&pci_slot_mutex);\n\n\tif (slot_nr == -1)\n\t\tgoto placeholder;\n\n\t \n\tslot = get_slot(parent, slot_nr);\n\tif (slot) {\n\t\tif (hotplug) {\n\t\t\tif ((err = slot->hotplug ? -EBUSY : 0)\n\t\t\t     || (err = rename_slot(slot, name))) {\n\t\t\t\tkobject_put(&slot->kobj);\n\t\t\t\tslot = NULL;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\t\tgoto out;\n\t}\n\nplaceholder:\n\tslot = kzalloc(sizeof(*slot), GFP_KERNEL);\n\tif (!slot) {\n\t\terr = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tslot->bus = parent;\n\tslot->number = slot_nr;\n\n\tslot->kobj.kset = pci_slots_kset;\n\n\tslot_name = make_slot_name(name);\n\tif (!slot_name) {\n\t\terr = -ENOMEM;\n\t\tkfree(slot);\n\t\tgoto err;\n\t}\n\n\tINIT_LIST_HEAD(&slot->list);\n\tlist_add(&slot->list, &parent->slots);\n\n\terr = kobject_init_and_add(&slot->kobj, &pci_slot_ktype, NULL,\n\t\t\t\t   \"%s\", slot_name);\n\tif (err) {\n\t\tkobject_put(&slot->kobj);\n\t\tgoto err;\n\t}\n\n\tdown_read(&pci_bus_sem);\n\tlist_for_each_entry(dev, &parent->devices, bus_list)\n\t\tif (PCI_SLOT(dev->devfn) == slot_nr)\n\t\t\tdev->slot = slot;\n\tup_read(&pci_bus_sem);\n\n\tdev_dbg(&parent->dev, \"dev %02x, created physical slot %s\\n\",\n\t\tslot_nr, pci_slot_name(slot));\n\nout:\n\tkfree(slot_name);\n\tmutex_unlock(&pci_slot_mutex);\n\treturn slot;\nerr:\n\tslot = ERR_PTR(err);\n\tgoto out;\n}\nEXPORT_SYMBOL_GPL(pci_create_slot);\n\n \nvoid pci_destroy_slot(struct pci_slot *slot)\n{\n\tdev_dbg(&slot->bus->dev, \"dev %02x, dec refcount to %d\\n\",\n\t\tslot->number, kref_read(&slot->kobj.kref) - 1);\n\n\tmutex_lock(&pci_slot_mutex);\n\tkobject_put(&slot->kobj);\n\tmutex_unlock(&pci_slot_mutex);\n}\nEXPORT_SYMBOL_GPL(pci_destroy_slot);\n\n#if defined(CONFIG_HOTPLUG_PCI) || defined(CONFIG_HOTPLUG_PCI_MODULE)\n#include <linux/pci_hotplug.h>\n \nvoid pci_hp_create_module_link(struct pci_slot *pci_slot)\n{\n\tstruct hotplug_slot *slot = pci_slot->hotplug;\n\tstruct kobject *kobj = NULL;\n\tint ret;\n\n\tif (!slot || !slot->ops)\n\t\treturn;\n\tkobj = kset_find_obj(module_kset, slot->mod_name);\n\tif (!kobj)\n\t\treturn;\n\tret = sysfs_create_link(&pci_slot->kobj, kobj, \"module\");\n\tif (ret)\n\t\tdev_err(&pci_slot->bus->dev, \"Error creating sysfs link (%d)\\n\",\n\t\t\tret);\n\tkobject_put(kobj);\n}\nEXPORT_SYMBOL_GPL(pci_hp_create_module_link);\n\n \nvoid pci_hp_remove_module_link(struct pci_slot *pci_slot)\n{\n\tsysfs_remove_link(&pci_slot->kobj, \"module\");\n}\nEXPORT_SYMBOL_GPL(pci_hp_remove_module_link);\n#endif\n\nstatic int pci_slot_init(void)\n{\n\tstruct kset *pci_bus_kset;\n\n\tpci_bus_kset = bus_get_kset(&pci_bus_type);\n\tpci_slots_kset = kset_create_and_add(\"slots\", NULL,\n\t\t\t\t\t\t&pci_bus_kset->kobj);\n\tif (!pci_slots_kset) {\n\t\tpr_err(\"PCI: Slot initialization failure\\n\");\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}\n\nsubsys_initcall(pci_slot_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}