{
  "module_name": "iov.c",
  "hash_id": "de0427aa2b66e99c89744dabc886e602e3ec3ef1a14142525a7454d8c92a521a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/iov.c",
  "human_readable_source": "\n \n\n#include <linux/pci.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/delay.h>\n#include \"pci.h\"\n\n#define VIRTFN_ID_LEN\t17\t \n\nint pci_iov_virtfn_bus(struct pci_dev *dev, int vf_id)\n{\n\tif (!dev->is_physfn)\n\t\treturn -EINVAL;\n\treturn dev->bus->number + ((dev->devfn + dev->sriov->offset +\n\t\t\t\t    dev->sriov->stride * vf_id) >> 8);\n}\n\nint pci_iov_virtfn_devfn(struct pci_dev *dev, int vf_id)\n{\n\tif (!dev->is_physfn)\n\t\treturn -EINVAL;\n\treturn (dev->devfn + dev->sriov->offset +\n\t\tdev->sriov->stride * vf_id) & 0xff;\n}\nEXPORT_SYMBOL_GPL(pci_iov_virtfn_devfn);\n\nint pci_iov_vf_id(struct pci_dev *dev)\n{\n\tstruct pci_dev *pf;\n\n\tif (!dev->is_virtfn)\n\t\treturn -EINVAL;\n\n\tpf = pci_physfn(dev);\n\treturn (pci_dev_id(dev) - (pci_dev_id(pf) + pf->sriov->offset)) /\n\t       pf->sriov->stride;\n}\nEXPORT_SYMBOL_GPL(pci_iov_vf_id);\n\n \nvoid *pci_iov_get_pf_drvdata(struct pci_dev *dev, struct pci_driver *pf_driver)\n{\n\tstruct pci_dev *pf_dev;\n\n\tif (!dev->is_virtfn)\n\t\treturn ERR_PTR(-EINVAL);\n\tpf_dev = dev->physfn;\n\tif (pf_dev->driver != pf_driver)\n\t\treturn ERR_PTR(-EINVAL);\n\treturn pci_get_drvdata(pf_dev);\n}\nEXPORT_SYMBOL_GPL(pci_iov_get_pf_drvdata);\n\n \nstatic inline void pci_iov_set_numvfs(struct pci_dev *dev, int nr_virtfn)\n{\n\tstruct pci_sriov *iov = dev->sriov;\n\n\tpci_write_config_word(dev, iov->pos + PCI_SRIOV_NUM_VF, nr_virtfn);\n\tpci_read_config_word(dev, iov->pos + PCI_SRIOV_VF_OFFSET, &iov->offset);\n\tpci_read_config_word(dev, iov->pos + PCI_SRIOV_VF_STRIDE, &iov->stride);\n}\n\n \nstatic int compute_max_vf_buses(struct pci_dev *dev)\n{\n\tstruct pci_sriov *iov = dev->sriov;\n\tint nr_virtfn, busnr, rc = 0;\n\n\tfor (nr_virtfn = iov->total_VFs; nr_virtfn; nr_virtfn--) {\n\t\tpci_iov_set_numvfs(dev, nr_virtfn);\n\t\tif (!iov->offset || (nr_virtfn > 1 && !iov->stride)) {\n\t\t\trc = -EIO;\n\t\t\tgoto out;\n\t\t}\n\n\t\tbusnr = pci_iov_virtfn_bus(dev, nr_virtfn - 1);\n\t\tif (busnr > iov->max_VF_buses)\n\t\t\tiov->max_VF_buses = busnr;\n\t}\n\nout:\n\tpci_iov_set_numvfs(dev, 0);\n\treturn rc;\n}\n\nstatic struct pci_bus *virtfn_add_bus(struct pci_bus *bus, int busnr)\n{\n\tstruct pci_bus *child;\n\n\tif (bus->number == busnr)\n\t\treturn bus;\n\n\tchild = pci_find_bus(pci_domain_nr(bus), busnr);\n\tif (child)\n\t\treturn child;\n\n\tchild = pci_add_new_bus(bus, NULL, busnr);\n\tif (!child)\n\t\treturn NULL;\n\n\tpci_bus_insert_busn_res(child, busnr, busnr);\n\n\treturn child;\n}\n\nstatic void virtfn_remove_bus(struct pci_bus *physbus, struct pci_bus *virtbus)\n{\n\tif (physbus != virtbus && list_empty(&virtbus->devices))\n\t\tpci_remove_bus(virtbus);\n}\n\nresource_size_t pci_iov_resource_size(struct pci_dev *dev, int resno)\n{\n\tif (!dev->is_physfn)\n\t\treturn 0;\n\n\treturn dev->sriov->barsz[resno - PCI_IOV_RESOURCES];\n}\n\nstatic void pci_read_vf_config_common(struct pci_dev *virtfn)\n{\n\tstruct pci_dev *physfn = virtfn->physfn;\n\n\t \n\tpci_read_config_dword(virtfn, PCI_CLASS_REVISION,\n\t\t\t      &physfn->sriov->class);\n\tpci_read_config_byte(virtfn, PCI_HEADER_TYPE,\n\t\t\t     &physfn->sriov->hdr_type);\n\tpci_read_config_word(virtfn, PCI_SUBSYSTEM_VENDOR_ID,\n\t\t\t     &physfn->sriov->subsystem_vendor);\n\tpci_read_config_word(virtfn, PCI_SUBSYSTEM_ID,\n\t\t\t     &physfn->sriov->subsystem_device);\n}\n\nint pci_iov_sysfs_link(struct pci_dev *dev,\n\t\tstruct pci_dev *virtfn, int id)\n{\n\tchar buf[VIRTFN_ID_LEN];\n\tint rc;\n\n\tsprintf(buf, \"virtfn%u\", id);\n\trc = sysfs_create_link(&dev->dev.kobj, &virtfn->dev.kobj, buf);\n\tif (rc)\n\t\tgoto failed;\n\trc = sysfs_create_link(&virtfn->dev.kobj, &dev->dev.kobj, \"physfn\");\n\tif (rc)\n\t\tgoto failed1;\n\n\tkobject_uevent(&virtfn->dev.kobj, KOBJ_CHANGE);\n\n\treturn 0;\n\nfailed1:\n\tsysfs_remove_link(&dev->dev.kobj, buf);\nfailed:\n\treturn rc;\n}\n\n#ifdef CONFIG_PCI_MSI\nstatic ssize_t sriov_vf_total_msix_show(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tu32 vf_total_msix = 0;\n\n\tdevice_lock(dev);\n\tif (!pdev->driver || !pdev->driver->sriov_get_vf_total_msix)\n\t\tgoto unlock;\n\n\tvf_total_msix = pdev->driver->sriov_get_vf_total_msix(pdev);\nunlock:\n\tdevice_unlock(dev);\n\treturn sysfs_emit(buf, \"%u\\n\", vf_total_msix);\n}\nstatic DEVICE_ATTR_RO(sriov_vf_total_msix);\n\nstatic ssize_t sriov_vf_msix_count_store(struct device *dev,\n\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t const char *buf, size_t count)\n{\n\tstruct pci_dev *vf_dev = to_pci_dev(dev);\n\tstruct pci_dev *pdev = pci_physfn(vf_dev);\n\tint val, ret = 0;\n\n\tif (kstrtoint(buf, 0, &val) < 0)\n\t\treturn -EINVAL;\n\n\tif (val < 0)\n\t\treturn -EINVAL;\n\n\tdevice_lock(&pdev->dev);\n\tif (!pdev->driver || !pdev->driver->sriov_set_msix_vec_count) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto err_pdev;\n\t}\n\n\tdevice_lock(&vf_dev->dev);\n\tif (vf_dev->driver) {\n\t\t \n\t\tret = -EBUSY;\n\t\tgoto err_dev;\n\t}\n\n\tret = pdev->driver->sriov_set_msix_vec_count(vf_dev, val);\n\nerr_dev:\n\tdevice_unlock(&vf_dev->dev);\nerr_pdev:\n\tdevice_unlock(&pdev->dev);\n\treturn ret ? : count;\n}\nstatic DEVICE_ATTR_WO(sriov_vf_msix_count);\n#endif\n\nstatic struct attribute *sriov_vf_dev_attrs[] = {\n#ifdef CONFIG_PCI_MSI\n\t&dev_attr_sriov_vf_msix_count.attr,\n#endif\n\tNULL,\n};\n\nstatic umode_t sriov_vf_attrs_are_visible(struct kobject *kobj,\n\t\t\t\t\t  struct attribute *a, int n)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\n\tif (!pdev->is_virtfn)\n\t\treturn 0;\n\n\treturn a->mode;\n}\n\nconst struct attribute_group sriov_vf_dev_attr_group = {\n\t.attrs = sriov_vf_dev_attrs,\n\t.is_visible = sriov_vf_attrs_are_visible,\n};\n\nint pci_iov_add_virtfn(struct pci_dev *dev, int id)\n{\n\tint i;\n\tint rc = -ENOMEM;\n\tu64 size;\n\tstruct pci_dev *virtfn;\n\tstruct resource *res;\n\tstruct pci_sriov *iov = dev->sriov;\n\tstruct pci_bus *bus;\n\n\tbus = virtfn_add_bus(dev->bus, pci_iov_virtfn_bus(dev, id));\n\tif (!bus)\n\t\tgoto failed;\n\n\tvirtfn = pci_alloc_dev(bus);\n\tif (!virtfn)\n\t\tgoto failed0;\n\n\tvirtfn->devfn = pci_iov_virtfn_devfn(dev, id);\n\tvirtfn->vendor = dev->vendor;\n\tvirtfn->device = iov->vf_device;\n\tvirtfn->is_virtfn = 1;\n\tvirtfn->physfn = pci_dev_get(dev);\n\tvirtfn->no_command_memory = 1;\n\n\tif (id == 0)\n\t\tpci_read_vf_config_common(virtfn);\n\n\trc = pci_setup_device(virtfn);\n\tif (rc)\n\t\tgoto failed1;\n\n\tvirtfn->dev.parent = dev->dev.parent;\n\tvirtfn->multifunction = 0;\n\n\tfor (i = 0; i < PCI_SRIOV_NUM_BARS; i++) {\n\t\tres = &dev->resource[i + PCI_IOV_RESOURCES];\n\t\tif (!res->parent)\n\t\t\tcontinue;\n\t\tvirtfn->resource[i].name = pci_name(virtfn);\n\t\tvirtfn->resource[i].flags = res->flags;\n\t\tsize = pci_iov_resource_size(dev, i + PCI_IOV_RESOURCES);\n\t\tvirtfn->resource[i].start = res->start + size * id;\n\t\tvirtfn->resource[i].end = virtfn->resource[i].start + size - 1;\n\t\trc = request_resource(res, &virtfn->resource[i]);\n\t\tBUG_ON(rc);\n\t}\n\n\tpci_device_add(virtfn, virtfn->bus);\n\trc = pci_iov_sysfs_link(dev, virtfn, id);\n\tif (rc)\n\t\tgoto failed1;\n\n\tpci_bus_add_device(virtfn);\n\n\treturn 0;\n\nfailed1:\n\tpci_stop_and_remove_bus_device(virtfn);\n\tpci_dev_put(dev);\nfailed0:\n\tvirtfn_remove_bus(dev->bus, bus);\nfailed:\n\n\treturn rc;\n}\n\nvoid pci_iov_remove_virtfn(struct pci_dev *dev, int id)\n{\n\tchar buf[VIRTFN_ID_LEN];\n\tstruct pci_dev *virtfn;\n\n\tvirtfn = pci_get_domain_bus_and_slot(pci_domain_nr(dev->bus),\n\t\t\t\t\t     pci_iov_virtfn_bus(dev, id),\n\t\t\t\t\t     pci_iov_virtfn_devfn(dev, id));\n\tif (!virtfn)\n\t\treturn;\n\n\tsprintf(buf, \"virtfn%u\", id);\n\tsysfs_remove_link(&dev->dev.kobj, buf);\n\t \n\tif (virtfn->dev.kobj.sd)\n\t\tsysfs_remove_link(&virtfn->dev.kobj, \"physfn\");\n\n\tpci_stop_and_remove_bus_device(virtfn);\n\tvirtfn_remove_bus(dev->bus, virtfn->bus);\n\n\t \n\tpci_dev_put(virtfn);\n\tpci_dev_put(dev);\n}\n\nstatic ssize_t sriov_totalvfs_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t   char *buf)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\n\treturn sysfs_emit(buf, \"%u\\n\", pci_sriov_get_totalvfs(pdev));\n}\n\nstatic ssize_t sriov_numvfs_show(struct device *dev,\n\t\t\t\t struct device_attribute *attr,\n\t\t\t\t char *buf)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tu16 num_vfs;\n\n\t \n\tdevice_lock(&pdev->dev);\n\tnum_vfs = pdev->sriov->num_VFs;\n\tdevice_unlock(&pdev->dev);\n\n\treturn sysfs_emit(buf, \"%u\\n\", num_vfs);\n}\n\n \nstatic ssize_t sriov_numvfs_store(struct device *dev,\n\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t  const char *buf, size_t count)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tint ret = 0;\n\tu16 num_vfs;\n\n\tif (kstrtou16(buf, 0, &num_vfs) < 0)\n\t\treturn -EINVAL;\n\n\tif (num_vfs > pci_sriov_get_totalvfs(pdev))\n\t\treturn -ERANGE;\n\n\tdevice_lock(&pdev->dev);\n\n\tif (num_vfs == pdev->sriov->num_VFs)\n\t\tgoto exit;\n\n\t \n\tif (!pdev->driver) {\n\t\tpci_info(pdev, \"no driver bound to device; cannot configure SR-IOV\\n\");\n\t\tret = -ENOENT;\n\t\tgoto exit;\n\t}\n\n\t \n\tif (!pdev->driver->sriov_configure) {\n\t\tpci_info(pdev, \"driver does not support SR-IOV configuration via sysfs\\n\");\n\t\tret = -ENOENT;\n\t\tgoto exit;\n\t}\n\n\tif (num_vfs == 0) {\n\t\t \n\t\tret = pdev->driver->sriov_configure(pdev, 0);\n\t\tgoto exit;\n\t}\n\n\t \n\tif (pdev->sriov->num_VFs) {\n\t\tpci_warn(pdev, \"%d VFs already enabled. Disable before enabling %d VFs\\n\",\n\t\t\t pdev->sriov->num_VFs, num_vfs);\n\t\tret = -EBUSY;\n\t\tgoto exit;\n\t}\n\n\tret = pdev->driver->sriov_configure(pdev, num_vfs);\n\tif (ret < 0)\n\t\tgoto exit;\n\n\tif (ret != num_vfs)\n\t\tpci_warn(pdev, \"%d VFs requested; only %d enabled\\n\",\n\t\t\t num_vfs, ret);\n\nexit:\n\tdevice_unlock(&pdev->dev);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn count;\n}\n\nstatic ssize_t sriov_offset_show(struct device *dev,\n\t\t\t\t struct device_attribute *attr,\n\t\t\t\t char *buf)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\n\treturn sysfs_emit(buf, \"%u\\n\", pdev->sriov->offset);\n}\n\nstatic ssize_t sriov_stride_show(struct device *dev,\n\t\t\t\t struct device_attribute *attr,\n\t\t\t\t char *buf)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\n\treturn sysfs_emit(buf, \"%u\\n\", pdev->sriov->stride);\n}\n\nstatic ssize_t sriov_vf_device_show(struct device *dev,\n\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t    char *buf)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\n\treturn sysfs_emit(buf, \"%x\\n\", pdev->sriov->vf_device);\n}\n\nstatic ssize_t sriov_drivers_autoprobe_show(struct device *dev,\n\t\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t\t    char *buf)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\n\treturn sysfs_emit(buf, \"%u\\n\", pdev->sriov->drivers_autoprobe);\n}\n\nstatic ssize_t sriov_drivers_autoprobe_store(struct device *dev,\n\t\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t\t     const char *buf, size_t count)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tbool drivers_autoprobe;\n\n\tif (kstrtobool(buf, &drivers_autoprobe) < 0)\n\t\treturn -EINVAL;\n\n\tpdev->sriov->drivers_autoprobe = drivers_autoprobe;\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR_RO(sriov_totalvfs);\nstatic DEVICE_ATTR_RW(sriov_numvfs);\nstatic DEVICE_ATTR_RO(sriov_offset);\nstatic DEVICE_ATTR_RO(sriov_stride);\nstatic DEVICE_ATTR_RO(sriov_vf_device);\nstatic DEVICE_ATTR_RW(sriov_drivers_autoprobe);\n\nstatic struct attribute *sriov_pf_dev_attrs[] = {\n\t&dev_attr_sriov_totalvfs.attr,\n\t&dev_attr_sriov_numvfs.attr,\n\t&dev_attr_sriov_offset.attr,\n\t&dev_attr_sriov_stride.attr,\n\t&dev_attr_sriov_vf_device.attr,\n\t&dev_attr_sriov_drivers_autoprobe.attr,\n#ifdef CONFIG_PCI_MSI\n\t&dev_attr_sriov_vf_total_msix.attr,\n#endif\n\tNULL,\n};\n\nstatic umode_t sriov_pf_attrs_are_visible(struct kobject *kobj,\n\t\t\t\t\t  struct attribute *a, int n)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\n\tif (!dev_is_pf(dev))\n\t\treturn 0;\n\n\treturn a->mode;\n}\n\nconst struct attribute_group sriov_pf_dev_attr_group = {\n\t.attrs = sriov_pf_dev_attrs,\n\t.is_visible = sriov_pf_attrs_are_visible,\n};\n\nint __weak pcibios_sriov_enable(struct pci_dev *pdev, u16 num_vfs)\n{\n\treturn 0;\n}\n\nint __weak pcibios_sriov_disable(struct pci_dev *pdev)\n{\n\treturn 0;\n}\n\nstatic int sriov_add_vfs(struct pci_dev *dev, u16 num_vfs)\n{\n\tunsigned int i;\n\tint rc;\n\n\tif (dev->no_vf_scan)\n\t\treturn 0;\n\n\tfor (i = 0; i < num_vfs; i++) {\n\t\trc = pci_iov_add_virtfn(dev, i);\n\t\tif (rc)\n\t\t\tgoto failed;\n\t}\n\treturn 0;\nfailed:\n\twhile (i--)\n\t\tpci_iov_remove_virtfn(dev, i);\n\n\treturn rc;\n}\n\nstatic int sriov_enable(struct pci_dev *dev, int nr_virtfn)\n{\n\tint rc;\n\tint i;\n\tint nres;\n\tu16 initial;\n\tstruct resource *res;\n\tstruct pci_dev *pdev;\n\tstruct pci_sriov *iov = dev->sriov;\n\tint bars = 0;\n\tint bus;\n\n\tif (!nr_virtfn)\n\t\treturn 0;\n\n\tif (iov->num_VFs)\n\t\treturn -EINVAL;\n\n\tpci_read_config_word(dev, iov->pos + PCI_SRIOV_INITIAL_VF, &initial);\n\tif (initial > iov->total_VFs ||\n\t    (!(iov->cap & PCI_SRIOV_CAP_VFM) && (initial != iov->total_VFs)))\n\t\treturn -EIO;\n\n\tif (nr_virtfn < 0 || nr_virtfn > iov->total_VFs ||\n\t    (!(iov->cap & PCI_SRIOV_CAP_VFM) && (nr_virtfn > initial)))\n\t\treturn -EINVAL;\n\n\tnres = 0;\n\tfor (i = 0; i < PCI_SRIOV_NUM_BARS; i++) {\n\t\tbars |= (1 << (i + PCI_IOV_RESOURCES));\n\t\tres = &dev->resource[i + PCI_IOV_RESOURCES];\n\t\tif (res->parent)\n\t\t\tnres++;\n\t}\n\tif (nres != iov->nres) {\n\t\tpci_err(dev, \"not enough MMIO resources for SR-IOV\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tbus = pci_iov_virtfn_bus(dev, nr_virtfn - 1);\n\tif (bus > dev->bus->busn_res.end) {\n\t\tpci_err(dev, \"can't enable %d VFs (bus %02x out of range of %pR)\\n\",\n\t\t\tnr_virtfn, bus, &dev->bus->busn_res);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (pci_enable_resources(dev, bars)) {\n\t\tpci_err(dev, \"SR-IOV: IOV BARS not allocated\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tif (iov->link != dev->devfn) {\n\t\tpdev = pci_get_slot(dev->bus, iov->link);\n\t\tif (!pdev)\n\t\t\treturn -ENODEV;\n\n\t\tif (!pdev->is_physfn) {\n\t\t\tpci_dev_put(pdev);\n\t\t\treturn -ENOSYS;\n\t\t}\n\n\t\trc = sysfs_create_link(&dev->dev.kobj,\n\t\t\t\t\t&pdev->dev.kobj, \"dep_link\");\n\t\tpci_dev_put(pdev);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\tiov->initial_VFs = initial;\n\tif (nr_virtfn < initial)\n\t\tinitial = nr_virtfn;\n\n\trc = pcibios_sriov_enable(dev, initial);\n\tif (rc) {\n\t\tpci_err(dev, \"failure %d from pcibios_sriov_enable()\\n\", rc);\n\t\tgoto err_pcibios;\n\t}\n\n\tpci_iov_set_numvfs(dev, nr_virtfn);\n\tiov->ctrl |= PCI_SRIOV_CTRL_VFE | PCI_SRIOV_CTRL_MSE;\n\tpci_cfg_access_lock(dev);\n\tpci_write_config_word(dev, iov->pos + PCI_SRIOV_CTRL, iov->ctrl);\n\tmsleep(100);\n\tpci_cfg_access_unlock(dev);\n\n\trc = sriov_add_vfs(dev, initial);\n\tif (rc)\n\t\tgoto err_pcibios;\n\n\tkobject_uevent(&dev->dev.kobj, KOBJ_CHANGE);\n\tiov->num_VFs = nr_virtfn;\n\n\treturn 0;\n\nerr_pcibios:\n\tiov->ctrl &= ~(PCI_SRIOV_CTRL_VFE | PCI_SRIOV_CTRL_MSE);\n\tpci_cfg_access_lock(dev);\n\tpci_write_config_word(dev, iov->pos + PCI_SRIOV_CTRL, iov->ctrl);\n\tssleep(1);\n\tpci_cfg_access_unlock(dev);\n\n\tpcibios_sriov_disable(dev);\n\n\tif (iov->link != dev->devfn)\n\t\tsysfs_remove_link(&dev->dev.kobj, \"dep_link\");\n\n\tpci_iov_set_numvfs(dev, 0);\n\treturn rc;\n}\n\nstatic void sriov_del_vfs(struct pci_dev *dev)\n{\n\tstruct pci_sriov *iov = dev->sriov;\n\tint i;\n\n\tfor (i = 0; i < iov->num_VFs; i++)\n\t\tpci_iov_remove_virtfn(dev, i);\n}\n\nstatic void sriov_disable(struct pci_dev *dev)\n{\n\tstruct pci_sriov *iov = dev->sriov;\n\n\tif (!iov->num_VFs)\n\t\treturn;\n\n\tsriov_del_vfs(dev);\n\tiov->ctrl &= ~(PCI_SRIOV_CTRL_VFE | PCI_SRIOV_CTRL_MSE);\n\tpci_cfg_access_lock(dev);\n\tpci_write_config_word(dev, iov->pos + PCI_SRIOV_CTRL, iov->ctrl);\n\tssleep(1);\n\tpci_cfg_access_unlock(dev);\n\n\tpcibios_sriov_disable(dev);\n\n\tif (iov->link != dev->devfn)\n\t\tsysfs_remove_link(&dev->dev.kobj, \"dep_link\");\n\n\tiov->num_VFs = 0;\n\tpci_iov_set_numvfs(dev, 0);\n}\n\nstatic int sriov_init(struct pci_dev *dev, int pos)\n{\n\tint i, bar64;\n\tint rc;\n\tint nres;\n\tu32 pgsz;\n\tu16 ctrl, total;\n\tstruct pci_sriov *iov;\n\tstruct resource *res;\n\tstruct pci_dev *pdev;\n\n\tpci_read_config_word(dev, pos + PCI_SRIOV_CTRL, &ctrl);\n\tif (ctrl & PCI_SRIOV_CTRL_VFE) {\n\t\tpci_write_config_word(dev, pos + PCI_SRIOV_CTRL, 0);\n\t\tssleep(1);\n\t}\n\n\tctrl = 0;\n\tlist_for_each_entry(pdev, &dev->bus->devices, bus_list)\n\t\tif (pdev->is_physfn)\n\t\t\tgoto found;\n\n\tpdev = NULL;\n\tif (pci_ari_enabled(dev->bus))\n\t\tctrl |= PCI_SRIOV_CTRL_ARI;\n\nfound:\n\tpci_write_config_word(dev, pos + PCI_SRIOV_CTRL, ctrl);\n\n\tpci_read_config_word(dev, pos + PCI_SRIOV_TOTAL_VF, &total);\n\tif (!total)\n\t\treturn 0;\n\n\tpci_read_config_dword(dev, pos + PCI_SRIOV_SUP_PGSIZE, &pgsz);\n\ti = PAGE_SHIFT > 12 ? PAGE_SHIFT - 12 : 0;\n\tpgsz &= ~((1 << i) - 1);\n\tif (!pgsz)\n\t\treturn -EIO;\n\n\tpgsz &= ~(pgsz - 1);\n\tpci_write_config_dword(dev, pos + PCI_SRIOV_SYS_PGSIZE, pgsz);\n\n\tiov = kzalloc(sizeof(*iov), GFP_KERNEL);\n\tif (!iov)\n\t\treturn -ENOMEM;\n\n\tnres = 0;\n\tfor (i = 0; i < PCI_SRIOV_NUM_BARS; i++) {\n\t\tres = &dev->resource[i + PCI_IOV_RESOURCES];\n\t\t \n\t\tif (res->flags & IORESOURCE_PCI_FIXED)\n\t\t\tbar64 = (res->flags & IORESOURCE_MEM_64) ? 1 : 0;\n\t\telse\n\t\t\tbar64 = __pci_read_base(dev, pci_bar_unknown, res,\n\t\t\t\t\t\tpos + PCI_SRIOV_BAR + i * 4);\n\t\tif (!res->flags)\n\t\t\tcontinue;\n\t\tif (resource_size(res) & (PAGE_SIZE - 1)) {\n\t\t\trc = -EIO;\n\t\t\tgoto failed;\n\t\t}\n\t\tiov->barsz[i] = resource_size(res);\n\t\tres->end = res->start + resource_size(res) * total - 1;\n\t\tpci_info(dev, \"VF(n) BAR%d space: %pR (contains BAR%d for %d VFs)\\n\",\n\t\t\t i, res, i, total);\n\t\ti += bar64;\n\t\tnres++;\n\t}\n\n\tiov->pos = pos;\n\tiov->nres = nres;\n\tiov->ctrl = ctrl;\n\tiov->total_VFs = total;\n\tiov->driver_max_VFs = total;\n\tpci_read_config_word(dev, pos + PCI_SRIOV_VF_DID, &iov->vf_device);\n\tiov->pgsz = pgsz;\n\tiov->self = dev;\n\tiov->drivers_autoprobe = true;\n\tpci_read_config_dword(dev, pos + PCI_SRIOV_CAP, &iov->cap);\n\tpci_read_config_byte(dev, pos + PCI_SRIOV_FUNC_LINK, &iov->link);\n\tif (pci_pcie_type(dev) == PCI_EXP_TYPE_RC_END)\n\t\tiov->link = PCI_DEVFN(PCI_SLOT(dev->devfn), iov->link);\n\n\tif (pdev)\n\t\tiov->dev = pci_dev_get(pdev);\n\telse\n\t\tiov->dev = dev;\n\n\tdev->sriov = iov;\n\tdev->is_physfn = 1;\n\trc = compute_max_vf_buses(dev);\n\tif (rc)\n\t\tgoto fail_max_buses;\n\n\treturn 0;\n\nfail_max_buses:\n\tdev->sriov = NULL;\n\tdev->is_physfn = 0;\nfailed:\n\tfor (i = 0; i < PCI_SRIOV_NUM_BARS; i++) {\n\t\tres = &dev->resource[i + PCI_IOV_RESOURCES];\n\t\tres->flags = 0;\n\t}\n\n\tkfree(iov);\n\treturn rc;\n}\n\nstatic void sriov_release(struct pci_dev *dev)\n{\n\tBUG_ON(dev->sriov->num_VFs);\n\n\tif (dev != dev->sriov->dev)\n\t\tpci_dev_put(dev->sriov->dev);\n\n\tkfree(dev->sriov);\n\tdev->sriov = NULL;\n}\n\nstatic void sriov_restore_state(struct pci_dev *dev)\n{\n\tint i;\n\tu16 ctrl;\n\tstruct pci_sriov *iov = dev->sriov;\n\n\tpci_read_config_word(dev, iov->pos + PCI_SRIOV_CTRL, &ctrl);\n\tif (ctrl & PCI_SRIOV_CTRL_VFE)\n\t\treturn;\n\n\t \n\tctrl &= ~PCI_SRIOV_CTRL_ARI;\n\tctrl |= iov->ctrl & PCI_SRIOV_CTRL_ARI;\n\tpci_write_config_word(dev, iov->pos + PCI_SRIOV_CTRL, ctrl);\n\n\tfor (i = 0; i < PCI_SRIOV_NUM_BARS; i++)\n\t\tpci_update_resource(dev, i + PCI_IOV_RESOURCES);\n\n\tpci_write_config_dword(dev, iov->pos + PCI_SRIOV_SYS_PGSIZE, iov->pgsz);\n\tpci_iov_set_numvfs(dev, iov->num_VFs);\n\tpci_write_config_word(dev, iov->pos + PCI_SRIOV_CTRL, iov->ctrl);\n\tif (iov->ctrl & PCI_SRIOV_CTRL_VFE)\n\t\tmsleep(100);\n}\n\n \nint pci_iov_init(struct pci_dev *dev)\n{\n\tint pos;\n\n\tif (!pci_is_pcie(dev))\n\t\treturn -ENODEV;\n\n\tpos = pci_find_ext_capability(dev, PCI_EXT_CAP_ID_SRIOV);\n\tif (pos)\n\t\treturn sriov_init(dev, pos);\n\n\treturn -ENODEV;\n}\n\n \nvoid pci_iov_release(struct pci_dev *dev)\n{\n\tif (dev->is_physfn)\n\t\tsriov_release(dev);\n}\n\n \nvoid pci_iov_remove(struct pci_dev *dev)\n{\n\tstruct pci_sriov *iov = dev->sriov;\n\n\tif (!dev->is_physfn)\n\t\treturn;\n\n\tiov->driver_max_VFs = iov->total_VFs;\n\tif (iov->num_VFs)\n\t\tpci_warn(dev, \"driver left SR-IOV enabled after remove\\n\");\n}\n\n \nvoid pci_iov_update_resource(struct pci_dev *dev, int resno)\n{\n\tstruct pci_sriov *iov = dev->is_physfn ? dev->sriov : NULL;\n\tstruct resource *res = dev->resource + resno;\n\tint vf_bar = resno - PCI_IOV_RESOURCES;\n\tstruct pci_bus_region region;\n\tu16 cmd;\n\tu32 new;\n\tint reg;\n\n\t \n\tif (!iov)\n\t\treturn;\n\n\tpci_read_config_word(dev, iov->pos + PCI_SRIOV_CTRL, &cmd);\n\tif ((cmd & PCI_SRIOV_CTRL_VFE) && (cmd & PCI_SRIOV_CTRL_MSE)) {\n\t\tdev_WARN(&dev->dev, \"can't update enabled VF BAR%d %pR\\n\",\n\t\t\t vf_bar, res);\n\t\treturn;\n\t}\n\n\t \n\tif (!res->flags)\n\t\treturn;\n\n\tif (res->flags & IORESOURCE_UNSET)\n\t\treturn;\n\n\tif (res->flags & IORESOURCE_PCI_FIXED)\n\t\treturn;\n\n\tpcibios_resource_to_bus(dev->bus, &region, res);\n\tnew = region.start;\n\tnew |= res->flags & ~PCI_BASE_ADDRESS_MEM_MASK;\n\n\treg = iov->pos + PCI_SRIOV_BAR + 4 * vf_bar;\n\tpci_write_config_dword(dev, reg, new);\n\tif (res->flags & IORESOURCE_MEM_64) {\n\t\tnew = region.start >> 16 >> 16;\n\t\tpci_write_config_dword(dev, reg + 4, new);\n\t}\n}\n\nresource_size_t __weak pcibios_iov_resource_alignment(struct pci_dev *dev,\n\t\t\t\t\t\t      int resno)\n{\n\treturn pci_iov_resource_size(dev, resno);\n}\n\n \nresource_size_t pci_sriov_resource_alignment(struct pci_dev *dev, int resno)\n{\n\treturn pcibios_iov_resource_alignment(dev, resno);\n}\n\n \nvoid pci_restore_iov_state(struct pci_dev *dev)\n{\n\tif (dev->is_physfn)\n\t\tsriov_restore_state(dev);\n}\n\n \nvoid pci_vf_drivers_autoprobe(struct pci_dev *dev, bool auto_probe)\n{\n\tif (dev->is_physfn)\n\t\tdev->sriov->drivers_autoprobe = auto_probe;\n}\n\n \nint pci_iov_bus_range(struct pci_bus *bus)\n{\n\tint max = 0;\n\tstruct pci_dev *dev;\n\n\tlist_for_each_entry(dev, &bus->devices, bus_list) {\n\t\tif (!dev->is_physfn)\n\t\t\tcontinue;\n\t\tif (dev->sriov->max_VF_buses > max)\n\t\t\tmax = dev->sriov->max_VF_buses;\n\t}\n\n\treturn max ? max - bus->number : 0;\n}\n\n \nint pci_enable_sriov(struct pci_dev *dev, int nr_virtfn)\n{\n\tmight_sleep();\n\n\tif (!dev->is_physfn)\n\t\treturn -ENOSYS;\n\n\treturn sriov_enable(dev, nr_virtfn);\n}\nEXPORT_SYMBOL_GPL(pci_enable_sriov);\n\n \nvoid pci_disable_sriov(struct pci_dev *dev)\n{\n\tmight_sleep();\n\n\tif (!dev->is_physfn)\n\t\treturn;\n\n\tsriov_disable(dev);\n}\nEXPORT_SYMBOL_GPL(pci_disable_sriov);\n\n \nint pci_num_vf(struct pci_dev *dev)\n{\n\tif (!dev->is_physfn)\n\t\treturn 0;\n\n\treturn dev->sriov->num_VFs;\n}\nEXPORT_SYMBOL_GPL(pci_num_vf);\n\n \nint pci_vfs_assigned(struct pci_dev *dev)\n{\n\tstruct pci_dev *vfdev;\n\tunsigned int vfs_assigned = 0;\n\tunsigned short dev_id;\n\n\t \n\tif (!dev->is_physfn)\n\t\treturn 0;\n\n\t \n\tdev_id = dev->sriov->vf_device;\n\n\t \n\tvfdev = pci_get_device(dev->vendor, dev_id, NULL);\n\twhile (vfdev) {\n\t\t \n\t\tif (vfdev->is_virtfn && (vfdev->physfn == dev) &&\n\t\t\tpci_is_dev_assigned(vfdev))\n\t\t\tvfs_assigned++;\n\n\t\tvfdev = pci_get_device(dev->vendor, dev_id, vfdev);\n\t}\n\n\treturn vfs_assigned;\n}\nEXPORT_SYMBOL_GPL(pci_vfs_assigned);\n\n \nint pci_sriov_set_totalvfs(struct pci_dev *dev, u16 numvfs)\n{\n\tif (!dev->is_physfn)\n\t\treturn -ENOSYS;\n\n\tif (numvfs > dev->sriov->total_VFs)\n\t\treturn -EINVAL;\n\n\t \n\tif (dev->sriov->ctrl & PCI_SRIOV_CTRL_VFE)\n\t\treturn -EBUSY;\n\n\tdev->sriov->driver_max_VFs = numvfs;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(pci_sriov_set_totalvfs);\n\n \nint pci_sriov_get_totalvfs(struct pci_dev *dev)\n{\n\tif (!dev->is_physfn)\n\t\treturn 0;\n\n\treturn dev->sriov->driver_max_VFs;\n}\nEXPORT_SYMBOL_GPL(pci_sriov_get_totalvfs);\n\n \nint pci_sriov_configure_simple(struct pci_dev *dev, int nr_virtfn)\n{\n\tint rc;\n\n\tmight_sleep();\n\n\tif (!dev->is_physfn)\n\t\treturn -ENODEV;\n\n\tif (pci_vfs_assigned(dev)) {\n\t\tpci_warn(dev, \"Cannot modify SR-IOV while VFs are assigned\\n\");\n\t\treturn -EPERM;\n\t}\n\n\tif (nr_virtfn == 0) {\n\t\tsriov_disable(dev);\n\t\treturn 0;\n\t}\n\n\trc = sriov_enable(dev, nr_virtfn);\n\tif (rc < 0)\n\t\treturn rc;\n\n\treturn nr_virtfn;\n}\nEXPORT_SYMBOL_GPL(pci_sriov_configure_simple);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}