{
  "module_name": "Kconfig",
  "hash_id": "93f35926feb7db4129fde9b8b6ecc0662fbfe560b7a95bb54267249c8bf5faa0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/Kconfig",
  "human_readable_source": "# SPDX-License-Identifier: GPL-2.0\n#\n# PCI configuration\n#\n\n# select this to offer the PCI prompt\nconfig HAVE_PCI\n\tbool\n\n# select this to unconditionally force on PCI support\nconfig FORCE_PCI\n\tbool\n\tselect HAVE_PCI\n\tselect PCI\n\nmenuconfig PCI\n\tbool \"PCI support\"\n\tdepends on HAVE_PCI\n\thelp\n\t  This option enables support for the PCI local bus, including\n\t  support for PCI-X and the foundations for PCI Express support.\n\t  Say 'Y' here unless you know what you are doing.\n\nif PCI\n\nconfig PCI_DOMAINS\n\tbool\n\tdepends on PCI\n\nconfig PCI_DOMAINS_GENERIC\n\tbool\n\tselect PCI_DOMAINS\n\nconfig PCI_SYSCALL\n\tbool\n\nsource \"drivers/pci/pcie/Kconfig\"\n\nconfig PCI_MSI\n\tbool \"Message Signaled Interrupts (MSI and MSI-X)\"\n\tselect GENERIC_MSI_IRQ\n\thelp\n\t   This allows device drivers to enable MSI (Message Signaled\n\t   Interrupts).  Message Signaled Interrupts enable a device to\n\t   generate an interrupt using an inbound Memory Write on its\n\t   PCI bus instead of asserting a device IRQ pin.\n\n\t   Use of PCI MSI interrupts can be disabled at kernel boot time\n\t   by using the 'pci=nomsi' option.  This disables MSI for the\n\t   entire system.\n\n\t   If you don't know what to do here, say Y.\n\nconfig PCI_MSI_ARCH_FALLBACKS\n\tbool\n\nconfig PCI_QUIRKS\n\tdefault y\n\tbool \"Enable PCI quirk workarounds\" if EXPERT\n\thelp\n\t  This enables workarounds for various PCI chipset bugs/quirks.\n\t  Disable this only if your target machine is unaffected by PCI\n\t  quirks.\n\nconfig PCI_DEBUG\n\tbool \"PCI Debugging\"\n\tdepends on DEBUG_KERNEL\n\thelp\n\t  Say Y here if you want the PCI core to produce a bunch of debug\n\t  messages to the system log.  Select this if you are having a\n\t  problem with PCI support and want to see more of what is going on.\n\n\t  When in doubt, say N.\n\nconfig PCI_REALLOC_ENABLE_AUTO\n\tbool \"Enable PCI resource re-allocation detection\"\n\tdepends on PCI_IOV\n\thelp\n\t  Say Y here if you want the PCI core to detect if PCI resource\n\t  re-allocation needs to be enabled. You can always use pci=realloc=on\n\t  or pci=realloc=off to override it.  It will automatically\n\t  re-allocate PCI resources if SR-IOV BARs have not been allocated by\n\t  the BIOS.\n\n\t  When in doubt, say N.\n\nconfig PCI_STUB\n\ttristate \"PCI Stub driver\"\n\thelp\n\t  Say Y or M here if you want be able to reserve a PCI device\n\t  when it is going to be assigned to a guest operating system.\n\n\t  When in doubt, say N.\n\nconfig PCI_PF_STUB\n\ttristate \"PCI PF Stub driver\"\n\tdepends on PCI_IOV\n\thelp\n\t  Say Y or M here if you want to enable support for devices that\n\t  require SR-IOV support, while at the same time the PF (Physical\n\t  Function) itself is not providing any actual services on the\n\t  host itself such as storage or networking.\n\n\t  When in doubt, say N.\n\nconfig XEN_PCIDEV_FRONTEND\n\ttristate \"Xen PCI Frontend\"\n\tdepends on XEN_PV\n\tselect PCI_XEN\n\tselect XEN_XENBUS_FRONTEND\n\tdefault y\n\thelp\n\t  The PCI device frontend driver allows the kernel to import arbitrary\n\t  PCI devices from a PCI backend to support PCI driver domains.\n\nconfig PCI_ATS\n\tbool\n\nconfig PCI_DOE\n\tbool\n\nconfig PCI_ECAM\n\tbool\n\nconfig PCI_LOCKLESS_CONFIG\n\tbool\n\nconfig PCI_BRIDGE_EMUL\n\tbool\n\nconfig PCI_IOV\n\tbool \"PCI IOV support\"\n\tselect PCI_ATS\n\thelp\n\t  I/O Virtualization is a PCI feature supported by some devices\n\t  which allows them to create virtual devices which share their\n\t  physical resources.\n\n\t  If unsure, say N.\n\nconfig PCI_PRI\n\tbool \"PCI PRI support\"\n\tselect PCI_ATS\n\thelp\n\t  PRI is the PCI Page Request Interface. It allows PCI devices that are\n\t  behind an IOMMU to recover from page faults.\n\n\t  If unsure, say N.\n\nconfig PCI_PASID\n\tbool \"PCI PASID support\"\n\tselect PCI_ATS\n\thelp\n\t  Process Address Space Identifiers (PASIDs) can be used by PCI devices\n\t  to access more than one IO address space at the same time. To make\n\t  use of this feature an IOMMU is required which also supports PASIDs.\n\t  Select this option if you have such an IOMMU and want to compile the\n\t  driver for it into your kernel.\n\n\t  If unsure, say N.\n\nconfig PCI_P2PDMA\n\tbool \"PCI peer-to-peer transfer support\"\n\tdepends on ZONE_DEVICE\n\t#\n\t# The need for the scatterlist DMA bus address flag means PCI P2PDMA\n\t# requires 64bit\n\t#\n\tdepends on 64BIT\n\tselect GENERIC_ALLOCATOR\n\tselect NEED_SG_DMA_FLAGS\n\thelp\n\t  Enable\u0455 drivers to do PCI peer-to-peer transactions to and from\n\t  BARs that are exposed in other devices that are the part of\n\t  the hierarchy where peer-to-peer DMA is guaranteed by the PCI\n\t  specification to work (ie. anything below a single PCI bridge).\n\n\t  Many PCIe root complexes do not support P2P transactions and\n\t  it's hard to tell which support it at all, so at this time,\n\t  P2P DMA transactions must be between devices behind the same root\n\t  port.\n\n\t  If unsure, say N.\n\nconfig PCI_LABEL\n\tdef_bool y if (DMI || ACPI)\n\tselect NLS\n\nconfig PCI_HYPERV\n\ttristate \"Hyper-V PCI Frontend\"\n\tdepends on ((X86 && X86_64) || ARM64) && HYPERV && PCI_MSI && SYSFS\n\tselect PCI_HYPERV_INTERFACE\n\thelp\n\t  The PCI device frontend driver allows the kernel to import arbitrary\n\t  PCI devices from a PCI backend to support PCI driver domains.\n\nconfig PCI_DYNAMIC_OF_NODES\n\tbool \"Create Device tree nodes for PCI devices\"\n\tdepends on OF_IRQ\n\tselect OF_DYNAMIC\n\thelp\n\t  This option enables support for generating device tree nodes for some\n\t  PCI devices. Thus, the driver of this kind can load and overlay\n\t  flattened device tree for its downstream devices.\n\n\t  Once this option is selected, the device tree nodes will be generated\n\t  for all PCI bridges.\n\nchoice\n\tprompt \"PCI Express hierarchy optimization setting\"\n\tdefault PCIE_BUS_DEFAULT\n\tdepends on PCI && EXPERT\n\thelp\n\t  MPS (Max Payload Size) and MRRS (Max Read Request Size) are PCIe\n\t  device parameters that affect performance and the ability to\n\t  support hotplug and peer-to-peer DMA.\n\n\t  The following choices set the MPS and MRRS optimization strategy\n\t  at compile-time.  The choices are the same as those offered for\n\t  the kernel command-line parameter 'pci', i.e.,\n\t  'pci=pcie_bus_tune_off', 'pci=pcie_bus_safe',\n\t  'pci=pcie_bus_perf', and 'pci=pcie_bus_peer2peer'.\n\n\t  This is a compile-time setting and can be overridden by the above\n\t  command-line parameters.  If unsure, choose PCIE_BUS_DEFAULT.\n\nconfig PCIE_BUS_TUNE_OFF\n\tbool \"Tune Off\"\n\tdepends on PCI\n\thelp\n\t  Use the BIOS defaults; don't touch MPS at all.  This is the same\n\t  as booting with 'pci=pcie_bus_tune_off'.\n\nconfig PCIE_BUS_DEFAULT\n\tbool \"Default\"\n\tdepends on PCI\n\thelp\n\t  Default choice; ensure that the MPS matches upstream bridge.\n\nconfig PCIE_BUS_SAFE\n\tbool \"Safe\"\n\tdepends on PCI\n\thelp\n\t  Use largest MPS that boot-time devices support.  If you have a\n\t  closed system with no possibility of adding new devices, this\n\t  will use the largest MPS that's supported by all devices.  This\n\t  is the same as booting with 'pci=pcie_bus_safe'.\n\nconfig PCIE_BUS_PERFORMANCE\n\tbool \"Performance\"\n\tdepends on PCI\n\thelp\n\t  Use MPS and MRRS for best performance.  Ensure that a given\n\t  device's MPS is no larger than its parent MPS, which allows us to\n\t  keep all switches/bridges to the max MPS supported by their\n\t  parent.  This is the same as booting with 'pci=pcie_bus_perf'.\n\nconfig PCIE_BUS_PEER2PEER\n\tbool \"Peer2peer\"\n\tdepends on PCI\n\thelp\n\t  Set MPS = 128 for all devices.  MPS configuration effected by the\n\t  other options could cause the MPS on one root port to be\n\t  different than that of the MPS on another, which may cause\n\t  hot-added devices or peer-to-peer DMA to fail.  Set MPS to the\n\t  smallest possible value (128B) system-wide to avoid these issues.\n\t  This is the same as booting with 'pci=pcie_bus_peer2peer'.\n\nendchoice\n\nconfig VGA_ARB\n\tbool \"VGA Arbitration\" if EXPERT\n\tdefault y\n\tdepends on (PCI && !S390)\n\thelp\n\t  Some \"legacy\" VGA devices implemented on PCI typically have the same\n\t  hard-decoded addresses as they did on ISA. When multiple PCI devices\n\t  are accessed at same time they need some kind of coordination. Please\n\t  see Documentation/gpu/vgaarbiter.rst for more details. Select this to\n\t  enable VGA arbiter.\n\nconfig VGA_ARB_MAX_GPUS\n\tint \"Maximum number of GPUs\"\n\tdefault 16\n\tdepends on VGA_ARB\n\thelp\n\t  Reserves space in the kernel to maintain resource locking for\n\t  multiple GPUS.  The overhead for each GPU is very small.\n\nsource \"drivers/pci/hotplug/Kconfig\"\nsource \"drivers/pci/controller/Kconfig\"\nsource \"drivers/pci/endpoint/Kconfig\"\nsource \"drivers/pci/switch/Kconfig\"\n\nendif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}