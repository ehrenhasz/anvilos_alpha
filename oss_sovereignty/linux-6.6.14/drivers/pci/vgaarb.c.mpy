{
  "module_name": "vgaarb.c",
  "hash_id": "1e1d347bc6dc91209c6fd0de686338de7ebe32701667ae86353b54dae8ca0492",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pci/vgaarb.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"vgaarb: \" fmt\n\n#define vgaarb_dbg(dev, fmt, arg...)\tdev_dbg(dev, \"vgaarb: \" fmt, ##arg)\n#define vgaarb_info(dev, fmt, arg...)\tdev_info(dev, \"vgaarb: \" fmt, ##arg)\n#define vgaarb_err(dev, fmt, arg...)\tdev_err(dev, \"vgaarb: \" fmt, ##arg)\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/pci.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/sched/signal.h>\n#include <linux/wait.h>\n#include <linux/spinlock.h>\n#include <linux/poll.h>\n#include <linux/miscdevice.h>\n#include <linux/slab.h>\n#include <linux/screen_info.h>\n#include <linux/vt.h>\n#include <linux/console.h>\n#include <linux/acpi.h>\n#include <linux/uaccess.h>\n#include <linux/vgaarb.h>\n\nstatic void vga_arbiter_notify_clients(void);\n\n \nstruct vga_device {\n\tstruct list_head list;\n\tstruct pci_dev *pdev;\n\tunsigned int decodes;\t\t \n\tunsigned int owns;\t\t \n\tunsigned int locks;\t\t \n\tunsigned int io_lock_cnt;\t \n\tunsigned int mem_lock_cnt;\t \n\tunsigned int io_norm_cnt;\t \n\tunsigned int mem_norm_cnt;\t \n\tbool bridge_has_one_vga;\n\tbool is_firmware_default;\t \n\tunsigned int (*set_decode)(struct pci_dev *pdev, bool decode);\n};\n\nstatic LIST_HEAD(vga_list);\nstatic int vga_count, vga_decode_count;\nstatic bool vga_arbiter_used;\nstatic DEFINE_SPINLOCK(vga_lock);\nstatic DECLARE_WAIT_QUEUE_HEAD(vga_wait_queue);\n\nstatic const char *vga_iostate_to_str(unsigned int iostate)\n{\n\t \n\tiostate &= VGA_RSRC_LEGACY_IO | VGA_RSRC_LEGACY_MEM;\n\tswitch (iostate) {\n\tcase VGA_RSRC_LEGACY_IO | VGA_RSRC_LEGACY_MEM:\n\t\treturn \"io+mem\";\n\tcase VGA_RSRC_LEGACY_IO:\n\t\treturn \"io\";\n\tcase VGA_RSRC_LEGACY_MEM:\n\t\treturn \"mem\";\n\t}\n\treturn \"none\";\n}\n\nstatic int vga_str_to_iostate(char *buf, int str_size, unsigned int *io_state)\n{\n\t \n\tif (strncmp(buf, \"none\", 4) == 0) {\n\t\t*io_state = VGA_RSRC_NONE;\n\t\treturn 1;\n\t}\n\n\t \n\tif (strncmp(buf, \"io+mem\", 6) == 0)\n\t\tgoto both;\n\telse if (strncmp(buf, \"io\", 2) == 0)\n\t\tgoto both;\n\telse if (strncmp(buf, \"mem\", 3) == 0)\n\t\tgoto both;\n\treturn 0;\nboth:\n\t*io_state = VGA_RSRC_LEGACY_IO | VGA_RSRC_LEGACY_MEM;\n\treturn 1;\n}\n\n \nstatic struct pci_dev *vga_default;\n\n \nstatic struct vga_device *vgadev_find(struct pci_dev *pdev)\n{\n\tstruct vga_device *vgadev;\n\n\tlist_for_each_entry(vgadev, &vga_list, list)\n\t\tif (pdev == vgadev->pdev)\n\t\t\treturn vgadev;\n\treturn NULL;\n}\n\n \nstruct pci_dev *vga_default_device(void)\n{\n\treturn vga_default;\n}\nEXPORT_SYMBOL_GPL(vga_default_device);\n\nvoid vga_set_default_device(struct pci_dev *pdev)\n{\n\tif (vga_default == pdev)\n\t\treturn;\n\n\tpci_dev_put(vga_default);\n\tvga_default = pci_dev_get(pdev);\n}\n\n \n#if !defined(CONFIG_VGA_CONSOLE)\nint vga_remove_vgacon(struct pci_dev *pdev)\n{\n\treturn 0;\n}\n#elif !defined(CONFIG_DUMMY_CONSOLE)\nint vga_remove_vgacon(struct pci_dev *pdev)\n{\n\treturn -ENODEV;\n}\n#else\nint vga_remove_vgacon(struct pci_dev *pdev)\n{\n\tint ret = 0;\n\n\tif (pdev != vga_default)\n\t\treturn 0;\n\tvgaarb_info(&pdev->dev, \"deactivate vga console\\n\");\n\n\tconsole_lock();\n\tif (con_is_bound(&vga_con))\n\t\tret = do_take_over_console(&dummy_con, 0,\n\t\t\t\t\t   MAX_NR_CONSOLES - 1, 1);\n\tif (ret == 0) {\n\t\tret = do_unregister_con_driver(&vga_con);\n\n\t\t \n\t\tif (ret == -ENODEV)\n\t\t\tret = 0;\n\t}\n\tconsole_unlock();\n\n\treturn ret;\n}\n#endif\nEXPORT_SYMBOL(vga_remove_vgacon);\n\n \nstatic void vga_check_first_use(void)\n{\n\t \n\tif (!vga_arbiter_used) {\n\t\tvga_arbiter_used = true;\n\t\tvga_arbiter_notify_clients();\n\t}\n}\n\nstatic struct vga_device *__vga_tryget(struct vga_device *vgadev,\n\t\t\t\t       unsigned int rsrc)\n{\n\tstruct device *dev = &vgadev->pdev->dev;\n\tunsigned int wants, legacy_wants, match;\n\tstruct vga_device *conflict;\n\tunsigned int pci_bits;\n\tu32 flags = 0;\n\n\t \n\tif ((rsrc & VGA_RSRC_NORMAL_IO) &&\n\t    (vgadev->decodes & VGA_RSRC_LEGACY_IO))\n\t\trsrc |= VGA_RSRC_LEGACY_IO;\n\tif ((rsrc & VGA_RSRC_NORMAL_MEM) &&\n\t    (vgadev->decodes & VGA_RSRC_LEGACY_MEM))\n\t\trsrc |= VGA_RSRC_LEGACY_MEM;\n\n\tvgaarb_dbg(dev, \"%s: %d\\n\", __func__, rsrc);\n\tvgaarb_dbg(dev, \"%s: owns: %d\\n\", __func__, vgadev->owns);\n\n\t \n\twants = rsrc & ~vgadev->owns;\n\n\t \n\tif (wants == 0)\n\t\tgoto lock_them;\n\n\t \n\tlegacy_wants = wants & VGA_RSRC_LEGACY_MASK;\n\tif (legacy_wants == 0)\n\t\tgoto enable_them;\n\n\t \n\tlist_for_each_entry(conflict, &vga_list, list) {\n\t\tunsigned int lwants = legacy_wants;\n\t\tunsigned int change_bridge = 0;\n\n\t\t \n\t\tif (vgadev == conflict)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (vgadev->pdev->bus != conflict->pdev->bus) {\n\t\t\tchange_bridge = 1;\n\t\t\tlwants = VGA_RSRC_LEGACY_IO | VGA_RSRC_LEGACY_MEM;\n\t\t}\n\n\t\t \n\t\tif (conflict->locks & lwants)\n\t\t\treturn conflict;\n\n\t\t \n\t\tmatch = lwants & conflict->owns;\n\t\tif (!match)\n\t\t\tcontinue;\n\n\t\t \n\n\t\tflags = 0;\n\t\tpci_bits = 0;\n\n\t\t \n\t\tif (!conflict->bridge_has_one_vga) {\n\t\t\tif ((match & conflict->decodes) & VGA_RSRC_LEGACY_MEM)\n\t\t\t\tpci_bits |= PCI_COMMAND_MEMORY;\n\t\t\tif ((match & conflict->decodes) & VGA_RSRC_LEGACY_IO)\n\t\t\t\tpci_bits |= PCI_COMMAND_IO;\n\n\t\t\tif (pci_bits)\n\t\t\t\tflags |= PCI_VGA_STATE_CHANGE_DECODES;\n\t\t}\n\n\t\tif (change_bridge)\n\t\t\tflags |= PCI_VGA_STATE_CHANGE_BRIDGE;\n\n\t\tpci_set_vga_state(conflict->pdev, false, pci_bits, flags);\n\t\tconflict->owns &= ~match;\n\n\t\t \n\t\tif (pci_bits & PCI_COMMAND_MEMORY)\n\t\t\tconflict->owns &= ~VGA_RSRC_NORMAL_MEM;\n\t\tif (pci_bits & PCI_COMMAND_IO)\n\t\t\tconflict->owns &= ~VGA_RSRC_NORMAL_IO;\n\t}\n\nenable_them:\n\t \n\tflags = 0;\n\tpci_bits = 0;\n\n\tif (!vgadev->bridge_has_one_vga) {\n\t\tflags |= PCI_VGA_STATE_CHANGE_DECODES;\n\t\tif (wants & (VGA_RSRC_LEGACY_MEM|VGA_RSRC_NORMAL_MEM))\n\t\t\tpci_bits |= PCI_COMMAND_MEMORY;\n\t\tif (wants & (VGA_RSRC_LEGACY_IO|VGA_RSRC_NORMAL_IO))\n\t\t\tpci_bits |= PCI_COMMAND_IO;\n\t}\n\tif (wants & VGA_RSRC_LEGACY_MASK)\n\t\tflags |= PCI_VGA_STATE_CHANGE_BRIDGE;\n\n\tpci_set_vga_state(vgadev->pdev, true, pci_bits, flags);\n\n\tvgadev->owns |= wants;\nlock_them:\n\tvgadev->locks |= (rsrc & VGA_RSRC_LEGACY_MASK);\n\tif (rsrc & VGA_RSRC_LEGACY_IO)\n\t\tvgadev->io_lock_cnt++;\n\tif (rsrc & VGA_RSRC_LEGACY_MEM)\n\t\tvgadev->mem_lock_cnt++;\n\tif (rsrc & VGA_RSRC_NORMAL_IO)\n\t\tvgadev->io_norm_cnt++;\n\tif (rsrc & VGA_RSRC_NORMAL_MEM)\n\t\tvgadev->mem_norm_cnt++;\n\n\treturn NULL;\n}\n\nstatic void __vga_put(struct vga_device *vgadev, unsigned int rsrc)\n{\n\tstruct device *dev = &vgadev->pdev->dev;\n\tunsigned int old_locks = vgadev->locks;\n\n\tvgaarb_dbg(dev, \"%s\\n\", __func__);\n\n\t \n\tif ((rsrc & VGA_RSRC_NORMAL_IO) && vgadev->io_norm_cnt > 0) {\n\t\tvgadev->io_norm_cnt--;\n\t\tif (vgadev->decodes & VGA_RSRC_LEGACY_IO)\n\t\t\trsrc |= VGA_RSRC_LEGACY_IO;\n\t}\n\tif ((rsrc & VGA_RSRC_NORMAL_MEM) && vgadev->mem_norm_cnt > 0) {\n\t\tvgadev->mem_norm_cnt--;\n\t\tif (vgadev->decodes & VGA_RSRC_LEGACY_MEM)\n\t\t\trsrc |= VGA_RSRC_LEGACY_MEM;\n\t}\n\tif ((rsrc & VGA_RSRC_LEGACY_IO) && vgadev->io_lock_cnt > 0)\n\t\tvgadev->io_lock_cnt--;\n\tif ((rsrc & VGA_RSRC_LEGACY_MEM) && vgadev->mem_lock_cnt > 0)\n\t\tvgadev->mem_lock_cnt--;\n\n\t \n\tif (vgadev->io_lock_cnt == 0)\n\t\tvgadev->locks &= ~VGA_RSRC_LEGACY_IO;\n\tif (vgadev->mem_lock_cnt == 0)\n\t\tvgadev->locks &= ~VGA_RSRC_LEGACY_MEM;\n\n\t \n\tif (old_locks != vgadev->locks)\n\t\twake_up_all(&vga_wait_queue);\n}\n\n \nint vga_get(struct pci_dev *pdev, unsigned int rsrc, int interruptible)\n{\n\tstruct vga_device *vgadev, *conflict;\n\tunsigned long flags;\n\twait_queue_entry_t wait;\n\tint rc = 0;\n\n\tvga_check_first_use();\n\t \n\tif (pdev == NULL)\n\t\tpdev = vga_default_device();\n\tif (pdev == NULL)\n\t\treturn 0;\n\n\tfor (;;) {\n\t\tspin_lock_irqsave(&vga_lock, flags);\n\t\tvgadev = vgadev_find(pdev);\n\t\tif (vgadev == NULL) {\n\t\t\tspin_unlock_irqrestore(&vga_lock, flags);\n\t\t\trc = -ENODEV;\n\t\t\tbreak;\n\t\t}\n\t\tconflict = __vga_tryget(vgadev, rsrc);\n\t\tspin_unlock_irqrestore(&vga_lock, flags);\n\t\tif (conflict == NULL)\n\t\t\tbreak;\n\n\t\t \n\t\tinit_waitqueue_entry(&wait, current);\n\t\tadd_wait_queue(&vga_wait_queue, &wait);\n\t\tset_current_state(interruptible ?\n\t\t\t\t  TASK_INTERRUPTIBLE :\n\t\t\t\t  TASK_UNINTERRUPTIBLE);\n\t\tif (interruptible && signal_pending(current)) {\n\t\t\t__set_current_state(TASK_RUNNING);\n\t\t\tremove_wait_queue(&vga_wait_queue, &wait);\n\t\t\trc = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\t\tschedule();\n\t\tremove_wait_queue(&vga_wait_queue, &wait);\n\t}\n\treturn rc;\n}\nEXPORT_SYMBOL(vga_get);\n\n \nstatic int vga_tryget(struct pci_dev *pdev, unsigned int rsrc)\n{\n\tstruct vga_device *vgadev;\n\tunsigned long flags;\n\tint rc = 0;\n\n\tvga_check_first_use();\n\n\t \n\tif (pdev == NULL)\n\t\tpdev = vga_default_device();\n\tif (pdev == NULL)\n\t\treturn 0;\n\tspin_lock_irqsave(&vga_lock, flags);\n\tvgadev = vgadev_find(pdev);\n\tif (vgadev == NULL) {\n\t\trc = -ENODEV;\n\t\tgoto bail;\n\t}\n\tif (__vga_tryget(vgadev, rsrc))\n\t\trc = -EBUSY;\nbail:\n\tspin_unlock_irqrestore(&vga_lock, flags);\n\treturn rc;\n}\n\n \nvoid vga_put(struct pci_dev *pdev, unsigned int rsrc)\n{\n\tstruct vga_device *vgadev;\n\tunsigned long flags;\n\n\t \n\tif (pdev == NULL)\n\t\tpdev = vga_default_device();\n\tif (pdev == NULL)\n\t\treturn;\n\tspin_lock_irqsave(&vga_lock, flags);\n\tvgadev = vgadev_find(pdev);\n\tif (vgadev == NULL)\n\t\tgoto bail;\n\t__vga_put(vgadev, rsrc);\nbail:\n\tspin_unlock_irqrestore(&vga_lock, flags);\n}\nEXPORT_SYMBOL(vga_put);\n\nstatic bool vga_is_firmware_default(struct pci_dev *pdev)\n{\n#if defined(CONFIG_X86) || defined(CONFIG_IA64)\n\tu64 base = screen_info.lfb_base;\n\tu64 size = screen_info.lfb_size;\n\tstruct resource *r;\n\tu64 limit;\n\n\t \n\n\tif (screen_info.capabilities & VIDEO_CAPABILITY_64BIT_BASE)\n\t\tbase |= (u64)screen_info.ext_lfb_base << 32;\n\n\tlimit = base + size;\n\n\t \n\tpci_dev_for_each_resource(pdev, r) {\n\t\tif (resource_type(r) != IORESOURCE_MEM)\n\t\t\tcontinue;\n\n\t\tif (!r->start || !r->end)\n\t\t\tcontinue;\n\n\t\tif (base < r->start || limit >= r->end)\n\t\t\tcontinue;\n\n\t\treturn true;\n\t}\n#endif\n\treturn false;\n}\n\nstatic bool vga_arb_integrated_gpu(struct device *dev)\n{\n#if defined(CONFIG_ACPI)\n\tstruct acpi_device *adev = ACPI_COMPANION(dev);\n\n\treturn adev && !strcmp(acpi_device_hid(adev), ACPI_VIDEO_HID);\n#else\n\treturn false;\n#endif\n}\n\n \nstatic bool vga_is_boot_device(struct vga_device *vgadev)\n{\n\tstruct vga_device *boot_vga = vgadev_find(vga_default_device());\n\tstruct pci_dev *pdev = vgadev->pdev;\n\tu16 cmd, boot_cmd;\n\n\t \n\n\t \n\tif (boot_vga && boot_vga->is_firmware_default)\n\t\treturn false;\n\n\tif (vga_is_firmware_default(pdev)) {\n\t\tvgadev->is_firmware_default = true;\n\t\treturn true;\n\t}\n\n\t \n\tif (boot_vga &&\n\t    (boot_vga->owns & VGA_RSRC_LEGACY_MASK) == VGA_RSRC_LEGACY_MASK)\n\t\treturn false;\n\n\tif ((vgadev->owns & VGA_RSRC_LEGACY_MASK) == VGA_RSRC_LEGACY_MASK)\n\t\treturn true;\n\n\t \n\tpci_read_config_word(pdev, PCI_COMMAND, &cmd);\n\tif (cmd & (PCI_COMMAND_IO | PCI_COMMAND_MEMORY)) {\n\n\t\t \n\t\tif (vga_arb_integrated_gpu(&pdev->dev))\n\t\t\treturn true;\n\n\t\t \n\t\tif (boot_vga) {\n\t\t\tpci_read_config_word(boot_vga->pdev, PCI_COMMAND,\n\t\t\t\t\t     &boot_cmd);\n\t\t\tif (boot_cmd & (PCI_COMMAND_IO | PCI_COMMAND_MEMORY))\n\t\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\t \n\tif (!boot_vga)\n\t\treturn true;\n\n\treturn false;\n}\n\n \nstatic void vga_arbiter_check_bridge_sharing(struct vga_device *vgadev)\n{\n\tstruct vga_device *same_bridge_vgadev;\n\tstruct pci_bus *new_bus, *bus;\n\tstruct pci_dev *new_bridge, *bridge;\n\n\tvgadev->bridge_has_one_vga = true;\n\n\tif (list_empty(&vga_list)) {\n\t\tvgaarb_info(&vgadev->pdev->dev, \"bridge control possible\\n\");\n\t\treturn;\n\t}\n\n\t \n\tnew_bus = vgadev->pdev->bus;\n\twhile (new_bus) {\n\t\tnew_bridge = new_bus->self;\n\n\t\t \n\t\tlist_for_each_entry(same_bridge_vgadev, &vga_list, list) {\n\t\t\tbus = same_bridge_vgadev->pdev->bus;\n\t\t\tbridge = bus->self;\n\n\t\t\t \n\t\t\tif (new_bridge == bridge) {\n\t\t\t\t \n\t\t\t\tsame_bridge_vgadev->bridge_has_one_vga = false;\n\t\t\t}\n\n\t\t\t \n\t\t\twhile (bus) {\n\t\t\t\tbridge = bus->self;\n\n\t\t\t\tif (bridge && bridge == vgadev->pdev->bus->self)\n\t\t\t\t\tvgadev->bridge_has_one_vga = false;\n\n\t\t\t\tbus = bus->parent;\n\t\t\t}\n\t\t}\n\t\tnew_bus = new_bus->parent;\n\t}\n\n\tif (vgadev->bridge_has_one_vga)\n\t\tvgaarb_info(&vgadev->pdev->dev, \"bridge control possible\\n\");\n\telse\n\t\tvgaarb_info(&vgadev->pdev->dev, \"no bridge control possible\\n\");\n}\n\n \nstatic bool vga_arbiter_add_pci_device(struct pci_dev *pdev)\n{\n\tstruct vga_device *vgadev;\n\tunsigned long flags;\n\tstruct pci_bus *bus;\n\tstruct pci_dev *bridge;\n\tu16 cmd;\n\n\t \n\tif ((pdev->class >> 8) != PCI_CLASS_DISPLAY_VGA)\n\t\treturn false;\n\n\t \n\tvgadev = kzalloc(sizeof(struct vga_device), GFP_KERNEL);\n\tif (vgadev == NULL) {\n\t\tvgaarb_err(&pdev->dev, \"failed to allocate VGA arbiter data\\n\");\n\t\t \n\t\treturn false;\n\t}\n\n\t \n\tspin_lock_irqsave(&vga_lock, flags);\n\tif (vgadev_find(pdev) != NULL) {\n\t\tBUG_ON(1);\n\t\tgoto fail;\n\t}\n\tvgadev->pdev = pdev;\n\n\t \n\tvgadev->decodes = VGA_RSRC_LEGACY_IO | VGA_RSRC_LEGACY_MEM |\n\t\t\t  VGA_RSRC_NORMAL_IO | VGA_RSRC_NORMAL_MEM;\n\n\t \n\tvga_decode_count++;\n\n\t \n\tpci_read_config_word(pdev, PCI_COMMAND, &cmd);\n\tif (cmd & PCI_COMMAND_IO)\n\t\tvgadev->owns |= VGA_RSRC_LEGACY_IO;\n\tif (cmd & PCI_COMMAND_MEMORY)\n\t\tvgadev->owns |= VGA_RSRC_LEGACY_MEM;\n\n\t \n\tbus = pdev->bus;\n\twhile (bus) {\n\t\tbridge = bus->self;\n\t\tif (bridge) {\n\t\t\tu16 l;\n\n\t\t\tpci_read_config_word(bridge, PCI_BRIDGE_CONTROL, &l);\n\t\t\tif (!(l & PCI_BRIDGE_CTL_VGA)) {\n\t\t\t\tvgadev->owns = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbus = bus->parent;\n\t}\n\n\tif (vga_is_boot_device(vgadev)) {\n\t\tvgaarb_info(&pdev->dev, \"setting as boot VGA device%s\\n\",\n\t\t\t    vga_default_device() ?\n\t\t\t    \" (overriding previous)\" : \"\");\n\t\tvga_set_default_device(pdev);\n\t}\n\n\tvga_arbiter_check_bridge_sharing(vgadev);\n\n\t \n\tlist_add_tail(&vgadev->list, &vga_list);\n\tvga_count++;\n\tvgaarb_info(&pdev->dev, \"VGA device added: decodes=%s,owns=%s,locks=%s\\n\",\n\t\tvga_iostate_to_str(vgadev->decodes),\n\t\tvga_iostate_to_str(vgadev->owns),\n\t\tvga_iostate_to_str(vgadev->locks));\n\n\tspin_unlock_irqrestore(&vga_lock, flags);\n\treturn true;\nfail:\n\tspin_unlock_irqrestore(&vga_lock, flags);\n\tkfree(vgadev);\n\treturn false;\n}\n\nstatic bool vga_arbiter_del_pci_device(struct pci_dev *pdev)\n{\n\tstruct vga_device *vgadev;\n\tunsigned long flags;\n\tbool ret = true;\n\n\tspin_lock_irqsave(&vga_lock, flags);\n\tvgadev = vgadev_find(pdev);\n\tif (vgadev == NULL) {\n\t\tret = false;\n\t\tgoto bail;\n\t}\n\n\tif (vga_default == pdev)\n\t\tvga_set_default_device(NULL);\n\n\tif (vgadev->decodes & (VGA_RSRC_LEGACY_IO | VGA_RSRC_LEGACY_MEM))\n\t\tvga_decode_count--;\n\n\t \n\tlist_del(&vgadev->list);\n\tvga_count--;\n\n\t \n\twake_up_all(&vga_wait_queue);\nbail:\n\tspin_unlock_irqrestore(&vga_lock, flags);\n\tkfree(vgadev);\n\treturn ret;\n}\n\n \nstatic void vga_update_device_decodes(struct vga_device *vgadev,\n\t\t\t\t      unsigned int new_decodes)\n{\n\tstruct device *dev = &vgadev->pdev->dev;\n\tunsigned int old_decodes = vgadev->decodes;\n\tunsigned int decodes_removed = ~new_decodes & old_decodes;\n\tunsigned int decodes_unlocked = vgadev->locks & decodes_removed;\n\n\tvgadev->decodes = new_decodes;\n\n\tvgaarb_info(dev, \"VGA decodes changed: olddecodes=%s,decodes=%s:owns=%s\\n\",\n\t\t    vga_iostate_to_str(old_decodes),\n\t\t    vga_iostate_to_str(vgadev->decodes),\n\t\t    vga_iostate_to_str(vgadev->owns));\n\n\t \n\tif (decodes_unlocked) {\n\t\tif (decodes_unlocked & VGA_RSRC_LEGACY_IO)\n\t\t\tvgadev->io_lock_cnt = 0;\n\t\tif (decodes_unlocked & VGA_RSRC_LEGACY_MEM)\n\t\t\tvgadev->mem_lock_cnt = 0;\n\t\t__vga_put(vgadev, decodes_unlocked);\n\t}\n\n\t \n\tif (old_decodes & VGA_RSRC_LEGACY_MASK &&\n\t    !(new_decodes & VGA_RSRC_LEGACY_MASK))\n\t\tvga_decode_count--;\n\tif (!(old_decodes & VGA_RSRC_LEGACY_MASK) &&\n\t    new_decodes & VGA_RSRC_LEGACY_MASK)\n\t\tvga_decode_count++;\n\tvgaarb_dbg(dev, \"decoding count now is: %d\\n\", vga_decode_count);\n}\n\nstatic void __vga_set_legacy_decoding(struct pci_dev *pdev,\n\t\t\t\t      unsigned int decodes,\n\t\t\t\t      bool userspace)\n{\n\tstruct vga_device *vgadev;\n\tunsigned long flags;\n\n\tdecodes &= VGA_RSRC_LEGACY_MASK;\n\n\tspin_lock_irqsave(&vga_lock, flags);\n\tvgadev = vgadev_find(pdev);\n\tif (vgadev == NULL)\n\t\tgoto bail;\n\n\t \n\tif (userspace && vgadev->set_decode)\n\t\tgoto bail;\n\n\t \n\tvga_update_device_decodes(vgadev, decodes);\n\n\t \nbail:\n\tspin_unlock_irqrestore(&vga_lock, flags);\n}\n\n \nvoid vga_set_legacy_decoding(struct pci_dev *pdev, unsigned int decodes)\n{\n\t__vga_set_legacy_decoding(pdev, decodes, false);\n}\nEXPORT_SYMBOL(vga_set_legacy_decoding);\n\n \nint vga_client_register(struct pci_dev *pdev,\n\t\tunsigned int (*set_decode)(struct pci_dev *pdev, bool decode))\n{\n\tunsigned long flags;\n\tstruct vga_device *vgadev;\n\n\tspin_lock_irqsave(&vga_lock, flags);\n\tvgadev = vgadev_find(pdev);\n\tif (vgadev)\n\t\tvgadev->set_decode = set_decode;\n\tspin_unlock_irqrestore(&vga_lock, flags);\n\tif (!vgadev)\n\t\treturn -ENODEV;\n\treturn 0;\n}\nEXPORT_SYMBOL(vga_client_register);\n\n \n\n#define MAX_USER_CARDS         CONFIG_VGA_ARB_MAX_GPUS\n#define PCI_INVALID_CARD       ((struct pci_dev *)-1UL)\n\n \nstruct vga_arb_user_card {\n\tstruct pci_dev *pdev;\n\tunsigned int mem_cnt;\n\tunsigned int io_cnt;\n};\n\nstruct vga_arb_private {\n\tstruct list_head list;\n\tstruct pci_dev *target;\n\tstruct vga_arb_user_card cards[MAX_USER_CARDS];\n\tspinlock_t lock;\n};\n\nstatic LIST_HEAD(vga_user_list);\nstatic DEFINE_SPINLOCK(vga_user_lock);\n\n\n \nstatic int vga_pci_str_to_vars(char *buf, int count, unsigned int *domain,\n\t\t\t       unsigned int *bus, unsigned int *devfn)\n{\n\tint n;\n\tunsigned int slot, func;\n\n\tn = sscanf(buf, \"PCI:%x:%x:%x.%x\", domain, bus, &slot, &func);\n\tif (n != 4)\n\t\treturn 0;\n\n\t*devfn = PCI_DEVFN(slot, func);\n\n\treturn 1;\n}\n\nstatic ssize_t vga_arb_read(struct file *file, char __user *buf,\n\t\t\t    size_t count, loff_t *ppos)\n{\n\tstruct vga_arb_private *priv = file->private_data;\n\tstruct vga_device *vgadev;\n\tstruct pci_dev *pdev;\n\tunsigned long flags;\n\tsize_t len;\n\tint rc;\n\tchar *lbuf;\n\n\tlbuf = kmalloc(1024, GFP_KERNEL);\n\tif (lbuf == NULL)\n\t\treturn -ENOMEM;\n\n\t \n\tspin_lock_irqsave(&vga_lock, flags);\n\n\t \n\tpdev = priv->target;\n\tif (pdev == NULL || pdev == PCI_INVALID_CARD) {\n\t\tspin_unlock_irqrestore(&vga_lock, flags);\n\t\tlen = sprintf(lbuf, \"invalid\");\n\t\tgoto done;\n\t}\n\n\t \n\tvgadev = vgadev_find(pdev);\n\tif (vgadev == NULL) {\n\t\t \n\t\tspin_unlock_irqrestore(&vga_lock, flags);\n\t\tlen = sprintf(lbuf, \"invalid\");\n\t\tgoto done;\n\t}\n\n\t \n\tlen = snprintf(lbuf, 1024,\n\t\t       \"count:%d,PCI:%s,decodes=%s,owns=%s,locks=%s(%u:%u)\\n\",\n\t\t       vga_decode_count, pci_name(pdev),\n\t\t       vga_iostate_to_str(vgadev->decodes),\n\t\t       vga_iostate_to_str(vgadev->owns),\n\t\t       vga_iostate_to_str(vgadev->locks),\n\t\t       vgadev->io_lock_cnt, vgadev->mem_lock_cnt);\n\n\tspin_unlock_irqrestore(&vga_lock, flags);\ndone:\n\n\t \n\tif (len > count)\n\t\tlen = count;\n\trc = copy_to_user(buf, lbuf, len);\n\tkfree(lbuf);\n\tif (rc)\n\t\treturn -EFAULT;\n\treturn len;\n}\n\n \nstatic ssize_t vga_arb_write(struct file *file, const char __user *buf,\n\t\t\t     size_t count, loff_t *ppos)\n{\n\tstruct vga_arb_private *priv = file->private_data;\n\tstruct vga_arb_user_card *uc = NULL;\n\tstruct pci_dev *pdev;\n\n\tunsigned int io_state;\n\n\tchar kbuf[64], *curr_pos;\n\tsize_t remaining = count;\n\n\tint ret_val;\n\tint i;\n\n\tif (count >= sizeof(kbuf))\n\t\treturn -EINVAL;\n\tif (copy_from_user(kbuf, buf, count))\n\t\treturn -EFAULT;\n\tcurr_pos = kbuf;\n\tkbuf[count] = '\\0';\n\n\tif (strncmp(curr_pos, \"lock \", 5) == 0) {\n\t\tcurr_pos += 5;\n\t\tremaining -= 5;\n\n\t\tpr_debug(\"client 0x%p called 'lock'\\n\", priv);\n\n\t\tif (!vga_str_to_iostate(curr_pos, remaining, &io_state)) {\n\t\t\tret_val = -EPROTO;\n\t\t\tgoto done;\n\t\t}\n\t\tif (io_state == VGA_RSRC_NONE) {\n\t\t\tret_val = -EPROTO;\n\t\t\tgoto done;\n\t\t}\n\n\t\tpdev = priv->target;\n\t\tif (priv->target == NULL) {\n\t\t\tret_val = -ENODEV;\n\t\t\tgoto done;\n\t\t}\n\n\t\tvga_get_uninterruptible(pdev, io_state);\n\n\t\t \n\t\tfor (i = 0; i < MAX_USER_CARDS; i++) {\n\t\t\tif (priv->cards[i].pdev == pdev) {\n\t\t\t\tif (io_state & VGA_RSRC_LEGACY_IO)\n\t\t\t\t\tpriv->cards[i].io_cnt++;\n\t\t\t\tif (io_state & VGA_RSRC_LEGACY_MEM)\n\t\t\t\t\tpriv->cards[i].mem_cnt++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tret_val = count;\n\t\tgoto done;\n\t} else if (strncmp(curr_pos, \"unlock \", 7) == 0) {\n\t\tcurr_pos += 7;\n\t\tremaining -= 7;\n\n\t\tpr_debug(\"client 0x%p called 'unlock'\\n\", priv);\n\n\t\tif (strncmp(curr_pos, \"all\", 3) == 0)\n\t\t\tio_state = VGA_RSRC_LEGACY_IO | VGA_RSRC_LEGACY_MEM;\n\t\telse {\n\t\t\tif (!vga_str_to_iostate\n\t\t\t    (curr_pos, remaining, &io_state)) {\n\t\t\t\tret_val = -EPROTO;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\t \n\t\t}\n\n\t\tpdev = priv->target;\n\t\tif (priv->target == NULL) {\n\t\t\tret_val = -ENODEV;\n\t\t\tgoto done;\n\t\t}\n\t\tfor (i = 0; i < MAX_USER_CARDS; i++) {\n\t\t\tif (priv->cards[i].pdev == pdev)\n\t\t\t\tuc = &priv->cards[i];\n\t\t}\n\n\t\tif (!uc) {\n\t\t\tret_val = -EINVAL;\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (io_state & VGA_RSRC_LEGACY_IO && uc->io_cnt == 0) {\n\t\t\tret_val = -EINVAL;\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (io_state & VGA_RSRC_LEGACY_MEM && uc->mem_cnt == 0) {\n\t\t\tret_val = -EINVAL;\n\t\t\tgoto done;\n\t\t}\n\n\t\tvga_put(pdev, io_state);\n\n\t\tif (io_state & VGA_RSRC_LEGACY_IO)\n\t\t\tuc->io_cnt--;\n\t\tif (io_state & VGA_RSRC_LEGACY_MEM)\n\t\t\tuc->mem_cnt--;\n\n\t\tret_val = count;\n\t\tgoto done;\n\t} else if (strncmp(curr_pos, \"trylock \", 8) == 0) {\n\t\tcurr_pos += 8;\n\t\tremaining -= 8;\n\n\t\tpr_debug(\"client 0x%p called 'trylock'\\n\", priv);\n\n\t\tif (!vga_str_to_iostate(curr_pos, remaining, &io_state)) {\n\t\t\tret_val = -EPROTO;\n\t\t\tgoto done;\n\t\t}\n\t\t \n\n\t\tpdev = priv->target;\n\t\tif (priv->target == NULL) {\n\t\t\tret_val = -ENODEV;\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (vga_tryget(pdev, io_state)) {\n\t\t\t \n\t\t\tfor (i = 0; i < MAX_USER_CARDS; i++) {\n\t\t\t\tif (priv->cards[i].pdev == pdev) {\n\t\t\t\t\tif (io_state & VGA_RSRC_LEGACY_IO)\n\t\t\t\t\t\tpriv->cards[i].io_cnt++;\n\t\t\t\t\tif (io_state & VGA_RSRC_LEGACY_MEM)\n\t\t\t\t\t\tpriv->cards[i].mem_cnt++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tret_val = count;\n\t\t\tgoto done;\n\t\t} else {\n\t\t\tret_val = -EBUSY;\n\t\t\tgoto done;\n\t\t}\n\n\t} else if (strncmp(curr_pos, \"target \", 7) == 0) {\n\t\tunsigned int domain, bus, devfn;\n\t\tstruct vga_device *vgadev;\n\n\t\tcurr_pos += 7;\n\t\tremaining -= 7;\n\t\tpr_debug(\"client 0x%p called 'target'\\n\", priv);\n\t\t \n\t\tif (!strncmp(curr_pos, \"default\", 7))\n\t\t\tpdev = pci_dev_get(vga_default_device());\n\t\telse {\n\t\t\tif (!vga_pci_str_to_vars(curr_pos, remaining,\n\t\t\t\t\t\t &domain, &bus, &devfn)) {\n\t\t\t\tret_val = -EPROTO;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tpdev = pci_get_domain_bus_and_slot(domain, bus, devfn);\n\t\t\tif (!pdev) {\n\t\t\t\tpr_debug(\"invalid PCI address %04x:%02x:%02x.%x\\n\",\n\t\t\t\t\t domain, bus, PCI_SLOT(devfn),\n\t\t\t\t\t PCI_FUNC(devfn));\n\t\t\t\tret_val = -ENODEV;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tpr_debug(\"%s ==> %04x:%02x:%02x.%x pdev %p\\n\", curr_pos,\n\t\t\t\tdomain, bus, PCI_SLOT(devfn), PCI_FUNC(devfn),\n\t\t\t\tpdev);\n\t\t}\n\n\t\tvgadev = vgadev_find(pdev);\n\t\tpr_debug(\"vgadev %p\\n\", vgadev);\n\t\tif (vgadev == NULL) {\n\t\t\tif (pdev) {\n\t\t\t\tvgaarb_dbg(&pdev->dev, \"not a VGA device\\n\");\n\t\t\t\tpci_dev_put(pdev);\n\t\t\t}\n\n\t\t\tret_val = -ENODEV;\n\t\t\tgoto done;\n\t\t}\n\n\t\tpriv->target = pdev;\n\t\tfor (i = 0; i < MAX_USER_CARDS; i++) {\n\t\t\tif (priv->cards[i].pdev == pdev)\n\t\t\t\tbreak;\n\t\t\tif (priv->cards[i].pdev == NULL) {\n\t\t\t\tpriv->cards[i].pdev = pdev;\n\t\t\t\tpriv->cards[i].io_cnt = 0;\n\t\t\t\tpriv->cards[i].mem_cnt = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (i == MAX_USER_CARDS) {\n\t\t\tvgaarb_dbg(&pdev->dev, \"maximum user cards (%d) number reached, ignoring this one!\\n\",\n\t\t\t\tMAX_USER_CARDS);\n\t\t\tpci_dev_put(pdev);\n\t\t\t \n\t\t\tret_val =  -ENOMEM;\n\t\t\tgoto done;\n\t\t}\n\n\t\tret_val = count;\n\t\tpci_dev_put(pdev);\n\t\tgoto done;\n\n\n\t} else if (strncmp(curr_pos, \"decodes \", 8) == 0) {\n\t\tcurr_pos += 8;\n\t\tremaining -= 8;\n\t\tpr_debug(\"client 0x%p called 'decodes'\\n\", priv);\n\n\t\tif (!vga_str_to_iostate(curr_pos, remaining, &io_state)) {\n\t\t\tret_val = -EPROTO;\n\t\t\tgoto done;\n\t\t}\n\t\tpdev = priv->target;\n\t\tif (priv->target == NULL) {\n\t\t\tret_val = -ENODEV;\n\t\t\tgoto done;\n\t\t}\n\n\t\t__vga_set_legacy_decoding(pdev, io_state, true);\n\t\tret_val = count;\n\t\tgoto done;\n\t}\n\t \n\treturn -EPROTO;\n\ndone:\n\treturn ret_val;\n}\n\nstatic __poll_t vga_arb_fpoll(struct file *file, poll_table *wait)\n{\n\tpr_debug(\"%s\\n\", __func__);\n\n\tpoll_wait(file, &vga_wait_queue, wait);\n\treturn EPOLLIN;\n}\n\nstatic int vga_arb_open(struct inode *inode, struct file *file)\n{\n\tstruct vga_arb_private *priv;\n\tunsigned long flags;\n\n\tpr_debug(\"%s\\n\", __func__);\n\n\tpriv = kzalloc(sizeof(*priv), GFP_KERNEL);\n\tif (priv == NULL)\n\t\treturn -ENOMEM;\n\tspin_lock_init(&priv->lock);\n\tfile->private_data = priv;\n\n\tspin_lock_irqsave(&vga_user_lock, flags);\n\tlist_add(&priv->list, &vga_user_list);\n\tspin_unlock_irqrestore(&vga_user_lock, flags);\n\n\t \n\tpriv->target = vga_default_device();  \n\tpriv->cards[0].pdev = priv->target;\n\tpriv->cards[0].io_cnt = 0;\n\tpriv->cards[0].mem_cnt = 0;\n\n\treturn 0;\n}\n\nstatic int vga_arb_release(struct inode *inode, struct file *file)\n{\n\tstruct vga_arb_private *priv = file->private_data;\n\tstruct vga_arb_user_card *uc;\n\tunsigned long flags;\n\tint i;\n\n\tpr_debug(\"%s\\n\", __func__);\n\n\tspin_lock_irqsave(&vga_user_lock, flags);\n\tlist_del(&priv->list);\n\tfor (i = 0; i < MAX_USER_CARDS; i++) {\n\t\tuc = &priv->cards[i];\n\t\tif (uc->pdev == NULL)\n\t\t\tcontinue;\n\t\tvgaarb_dbg(&uc->pdev->dev, \"uc->io_cnt == %d, uc->mem_cnt == %d\\n\",\n\t\t\tuc->io_cnt, uc->mem_cnt);\n\t\twhile (uc->io_cnt--)\n\t\t\tvga_put(uc->pdev, VGA_RSRC_LEGACY_IO);\n\t\twhile (uc->mem_cnt--)\n\t\t\tvga_put(uc->pdev, VGA_RSRC_LEGACY_MEM);\n\t}\n\tspin_unlock_irqrestore(&vga_user_lock, flags);\n\n\tkfree(priv);\n\n\treturn 0;\n}\n\n \nstatic void vga_arbiter_notify_clients(void)\n{\n\tstruct vga_device *vgadev;\n\tunsigned long flags;\n\tunsigned int new_decodes;\n\tbool new_state;\n\n\tif (!vga_arbiter_used)\n\t\treturn;\n\n\tnew_state = (vga_count > 1) ? false : true;\n\n\tspin_lock_irqsave(&vga_lock, flags);\n\tlist_for_each_entry(vgadev, &vga_list, list) {\n\t\tif (vgadev->set_decode) {\n\t\t\tnew_decodes = vgadev->set_decode(vgadev->pdev,\n\t\t\t\t\t\t\t new_state);\n\t\t\tvga_update_device_decodes(vgadev, new_decodes);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&vga_lock, flags);\n}\n\nstatic int pci_notify(struct notifier_block *nb, unsigned long action,\n\t\t      void *data)\n{\n\tstruct device *dev = data;\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tbool notify = false;\n\n\tvgaarb_dbg(dev, \"%s\\n\", __func__);\n\n\t \n\tif (action == BUS_NOTIFY_ADD_DEVICE)\n\t\tnotify = vga_arbiter_add_pci_device(pdev);\n\telse if (action == BUS_NOTIFY_DEL_DEVICE)\n\t\tnotify = vga_arbiter_del_pci_device(pdev);\n\n\tif (notify)\n\t\tvga_arbiter_notify_clients();\n\treturn 0;\n}\n\nstatic struct notifier_block pci_notifier = {\n\t.notifier_call = pci_notify,\n};\n\nstatic const struct file_operations vga_arb_device_fops = {\n\t.read = vga_arb_read,\n\t.write = vga_arb_write,\n\t.poll = vga_arb_fpoll,\n\t.open = vga_arb_open,\n\t.release = vga_arb_release,\n\t.llseek = noop_llseek,\n};\n\nstatic struct miscdevice vga_arb_device = {\n\tMISC_DYNAMIC_MINOR, \"vga_arbiter\", &vga_arb_device_fops\n};\n\nstatic int __init vga_arb_device_init(void)\n{\n\tint rc;\n\tstruct pci_dev *pdev;\n\n\trc = misc_register(&vga_arb_device);\n\tif (rc < 0)\n\t\tpr_err(\"error %d registering device\\n\", rc);\n\n\tbus_register_notifier(&pci_bus_type, &pci_notifier);\n\n\t \n\tpdev = NULL;\n\twhile ((pdev =\n\t\tpci_get_subsys(PCI_ANY_ID, PCI_ANY_ID, PCI_ANY_ID,\n\t\t\t       PCI_ANY_ID, pdev)) != NULL)\n\t\tvga_arbiter_add_pci_device(pdev);\n\n\tpr_info(\"loaded\\n\");\n\treturn rc;\n}\nsubsys_initcall_sync(vga_arb_device_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}