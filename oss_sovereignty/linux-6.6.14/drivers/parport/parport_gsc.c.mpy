{
  "module_name": "parport_gsc.c",
  "hash_id": "8dcdf7a84a3cd5b4a714e6dc403f7f3bb1ce77af6d87223da689dc4790966ade",
  "original_prompt": "Ingested from linux-6.6.14/drivers/parport/parport_gsc.c",
  "human_readable_source": "\n \n\n#undef DEBUG\t \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/errno.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/sysctl.h>\n\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <asm/superio.h>\n\n#include <linux/parport.h>\n#include <asm/pdc.h>\n#include <asm/parisc-device.h>\n#include <asm/hardware.h>\n#include \"parport_gsc.h\"\n\n\nMODULE_AUTHOR(\"Helge Deller <deller@gmx.de>\");\nMODULE_DESCRIPTION(\"HP-PARISC PC-style parallel port driver\");\nMODULE_LICENSE(\"GPL\");\n\n\n \nstatic int clear_epp_timeout(struct parport *pb)\n{\n\tunsigned char r;\n\n\tif (!(parport_gsc_read_status(pb) & 0x01))\n\t\treturn 1;\n\n\t \n\tparport_gsc_read_status(pb);\n\tr = parport_gsc_read_status(pb);\n\tparport_writeb (r | 0x01, STATUS (pb));  \n\tparport_writeb (r & 0xfe, STATUS (pb));  \n\tr = parport_gsc_read_status(pb);\n\n\treturn !(r & 0x01);\n}\n\n \n\nvoid parport_gsc_init_state(struct pardevice *dev, struct parport_state *s)\n{\n\ts->u.pc.ctr = 0xc | (dev->irq_func ? 0x10 : 0x0);\n}\n\nvoid parport_gsc_save_state(struct parport *p, struct parport_state *s)\n{\n\ts->u.pc.ctr = parport_readb (CONTROL (p));\n}\n\nvoid parport_gsc_restore_state(struct parport *p, struct parport_state *s)\n{\n\tparport_writeb (s->u.pc.ctr, CONTROL (p));\n}\n\nstruct parport_operations parport_gsc_ops = \n{\n\t.write_data\t= parport_gsc_write_data,\n\t.read_data\t= parport_gsc_read_data,\n\n\t.write_control\t= parport_gsc_write_control,\n\t.read_control\t= parport_gsc_read_control,\n\t.frob_control\t= parport_gsc_frob_control,\n\n\t.read_status\t= parport_gsc_read_status,\n\n\t.enable_irq\t= parport_gsc_enable_irq,\n\t.disable_irq\t= parport_gsc_disable_irq,\n\n\t.data_forward\t= parport_gsc_data_forward,\n\t.data_reverse\t= parport_gsc_data_reverse,\n\n\t.init_state\t= parport_gsc_init_state,\n\t.save_state\t= parport_gsc_save_state,\n\t.restore_state\t= parport_gsc_restore_state,\n\n\t.epp_write_data\t= parport_ieee1284_epp_write_data,\n\t.epp_read_data\t= parport_ieee1284_epp_read_data,\n\t.epp_write_addr\t= parport_ieee1284_epp_write_addr,\n\t.epp_read_addr\t= parport_ieee1284_epp_read_addr,\n\n\t.ecp_write_data\t= parport_ieee1284_ecp_write_data,\n\t.ecp_read_data\t= parport_ieee1284_ecp_read_data,\n\t.ecp_write_addr\t= parport_ieee1284_ecp_write_addr,\n\n\t.compat_write_data \t= parport_ieee1284_write_compat,\n\t.nibble_read_data\t= parport_ieee1284_read_nibble,\n\t.byte_read_data\t\t= parport_ieee1284_read_byte,\n\n\t.owner\t\t= THIS_MODULE,\n};\n\n \n\n \nstatic int parport_SPP_supported(struct parport *pb)\n{\n\tunsigned char r, w;\n\n\t \n\tclear_epp_timeout(pb);\n\n\t \n\tw = 0xc;\n\tparport_writeb (w, CONTROL (pb));\n\n\t \n\tr = parport_readb (CONTROL (pb));\n\tif ((r & 0xf) == w) {\n\t\tw = 0xe;\n\t\tparport_writeb (w, CONTROL (pb));\n\t\tr = parport_readb (CONTROL (pb));\n\t\tparport_writeb (0xc, CONTROL (pb));\n\t\tif ((r & 0xf) == w)\n\t\t\treturn PARPORT_MODE_PCSPP;\n\t}\n\n\t \n\tw = 0xaa;\n\tparport_gsc_write_data (pb, w);\n\tr = parport_gsc_read_data (pb);\n\tif (r == w) {\n\t\tw = 0x55;\n\t\tparport_gsc_write_data (pb, w);\n\t\tr = parport_gsc_read_data (pb);\n\t\tif (r == w)\n\t\t\treturn PARPORT_MODE_PCSPP;\n\t}\n\n\treturn 0;\n}\n\n \n\nstatic int parport_PS2_supported(struct parport *pb)\n{\n\tint ok = 0;\n  \n\tclear_epp_timeout(pb);\n\n\t \n\tparport_gsc_data_reverse (pb);\n\t\n\tparport_gsc_write_data(pb, 0x55);\n\tif (parport_gsc_read_data(pb) != 0x55) ok++;\n\n\tparport_gsc_write_data(pb, 0xaa);\n\tif (parport_gsc_read_data(pb) != 0xaa) ok++;\n\n\t \n\tparport_gsc_data_forward (pb);\n\n\tif (ok) {\n\t\tpb->modes |= PARPORT_MODE_TRISTATE;\n\t} else {\n\t\tstruct parport_gsc_private *priv = pb->private_data;\n\t\tpriv->ctr_writable &= ~0x20;\n\t}\n\n\treturn ok;\n}\n\n\n \n\nstatic struct parport *parport_gsc_probe_port(unsigned long base,\n\t\t\t\t       unsigned long base_hi, int irq,\n\t\t\t\t       struct parisc_device *padev)\n{\n\tstruct parport_gsc_private *priv;\n\tstruct parport_operations *ops;\n\tstruct parport tmp;\n\tstruct parport *p = &tmp;\n\n\tpriv = kzalloc (sizeof (struct parport_gsc_private), GFP_KERNEL);\n\tif (!priv) {\n\t\tprintk(KERN_DEBUG \"parport (0x%lx): no memory!\\n\", base);\n\t\treturn NULL;\n\t}\n\tops = kmemdup(&parport_gsc_ops, sizeof(struct parport_operations),\n\t\t      GFP_KERNEL);\n\tif (!ops) {\n\t\tprintk(KERN_DEBUG \"parport (0x%lx): no memory for ops!\\n\",\n\t\t       base);\n\t\tkfree (priv);\n\t\treturn NULL;\n\t}\n\tpriv->ctr = 0xc;\n\tpriv->ctr_writable = 0xff;\n\tp->base = base;\n\tp->base_hi = base_hi;\n\tp->irq = irq;\n\tp->modes = PARPORT_MODE_PCSPP | PARPORT_MODE_SAFEININT;\n\tp->ops = ops;\n\tp->private_data = priv;\n\tp->physport = p;\n\tif (!parport_SPP_supported (p)) {\n\t\t \n\t\tkfree (priv);\n\t\tkfree(ops);\n\t\treturn NULL;\n\t}\n\tparport_PS2_supported (p);\n\n\tif (!(p = parport_register_port(base, PARPORT_IRQ_NONE,\n\t\t\t\t\tPARPORT_DMA_NONE, ops))) {\n\t\tkfree (priv);\n\t\tkfree (ops);\n\t\treturn NULL;\n\t}\n\n\tp->dev = &padev->dev;\n\tp->base_hi = base_hi;\n\tp->modes = tmp.modes;\n\tp->size = (p->modes & PARPORT_MODE_EPP)?8:3;\n\tp->private_data = priv;\n\n\tpr_info(\"%s: PC-style at 0x%lx\", p->name, p->base);\n\tp->irq = irq;\n\tif (p->irq == PARPORT_IRQ_AUTO) {\n\t\tp->irq = PARPORT_IRQ_NONE;\n\t}\n\tif (p->irq != PARPORT_IRQ_NONE)\n\t\tpr_cont(\", irq %d\", p->irq);\n\n\tpr_cont(\" [\");\n#define printmode(x)\t\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tif (p->modes & PARPORT_MODE_##x)\t\t\t\t\\\n\t\tpr_cont(\"%s%s\", f++ ? \",\" : \"\", #x);\t\t\t\\\n} while (0)\n\t{\n\t\tint f = 0;\n\t\tprintmode(PCSPP);\n\t\tprintmode(TRISTATE);\n\t\tprintmode(COMPAT);\n\t\tprintmode(EPP);\n\n\n\t}\n#undef printmode\n\tpr_cont(\"]\\n\");\n\n\tif (p->irq != PARPORT_IRQ_NONE) {\n\t\tif (request_irq (p->irq, parport_irq_handler,\n\t\t\t\t 0, p->name, p)) {\n\t\t\tpr_warn(\"%s: irq %d in use, resorting to polled operation\\n\",\n\t\t\t\tp->name, p->irq);\n\t\t\tp->irq = PARPORT_IRQ_NONE;\n\t\t}\n\t}\n\n\t \n\n\tparport_gsc_write_data(p, 0);\n\tparport_gsc_data_forward (p);\n\n\t \n\tparport_announce_port (p);\n\n\treturn p;\n}\n\n\n#define PARPORT_GSC_OFFSET 0x800\n\nstatic int parport_count;\n\nstatic int __init parport_init_chip(struct parisc_device *dev)\n{\n\tstruct parport *p;\n\tunsigned long port;\n\n\tif (!dev->irq) {\n\t\tpr_warn(\"IRQ not found for parallel device at 0x%llx\\n\",\n\t\t\t(unsigned long long)dev->hpa.start);\n\t\treturn -ENODEV;\n\t}\n\n\tport = dev->hpa.start + PARPORT_GSC_OFFSET;\n\t\n\t \n\tif (boot_cpu_data.cpu_type > pcxt && !pdc_add_valid(port+4)) {\n\n\t\t \n\t\tpr_info(\"%s: initialize bidirectional-mode\\n\", __func__);\n\t\tparport_writeb ( (0x10 + 0x20), port + 4);\n\n\t} else {\n\t\tpr_info(\"%s: enhanced parport-modes not supported\\n\", __func__);\n\t}\n\t\n\tp = parport_gsc_probe_port(port, 0, dev->irq, dev);\n\tif (p)\n\t\tparport_count++;\n\tdev_set_drvdata(&dev->dev, p);\n\n\treturn 0;\n}\n\nstatic void __exit parport_remove_chip(struct parisc_device *dev)\n{\n\tstruct parport *p = dev_get_drvdata(&dev->dev);\n\tif (p) {\n\t\tstruct parport_operations *ops = p->ops;\n\t\tparport_remove_port(p);\n\t\tif (p->irq != PARPORT_IRQ_NONE)\n\t\t\tfree_irq(p->irq, p);\n\t\tkfree (p->private_data);\n\t\tparport_put_port(p);\n\t\tkfree (ops);  \n\t}\n}\n\nstatic const struct parisc_device_id parport_tbl[] __initconst = {\n\t{ HPHW_FIO, HVERSION_REV_ANY_ID, HVERSION_ANY_ID, 0x74 },\n\t{ 0, }\n};\n\nMODULE_DEVICE_TABLE(parisc, parport_tbl);\n\nstatic struct parisc_driver parport_driver __refdata = {\n\t.name\t\t= \"Parallel\",\n\t.id_table\t= parport_tbl,\n\t.probe\t\t= parport_init_chip,\n\t.remove\t\t= __exit_p(parport_remove_chip),\n};\n\nint parport_gsc_init(void)\n{\n\treturn register_parisc_driver(&parport_driver);\n}\n\nstatic void parport_gsc_exit(void)\n{\n\tunregister_parisc_driver(&parport_driver);\n}\n\nmodule_init(parport_gsc_init);\nmodule_exit(parport_gsc_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}