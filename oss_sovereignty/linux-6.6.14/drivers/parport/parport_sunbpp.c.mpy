{
  "module_name": "parport_sunbpp.c",
  "hash_id": "bd1326c964d93d36216123c3620984f3c190ee565a7af75d18cedbc137997dc6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/parport/parport_sunbpp.c",
  "human_readable_source": "\n \n\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/errno.h>\n#include <linux/ioport.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n\n#include <linux/parport.h>\n\n#include <asm/ptrace.h>\n#include <linux/interrupt.h>\n\n#include <asm/io.h>\n#include <asm/oplib.h>            \n#include <asm/dma.h>              \n#include <asm/irq.h>\n#include <asm/sunbpp.h>\n\n#undef __SUNBPP_DEBUG\n#ifdef __SUNBPP_DEBUG\n#define dprintk(x) printk x\n#else\n#define dprintk(x)\n#endif\n\nstatic void parport_sunbpp_disable_irq(struct parport *p)\n{\n\tstruct bpp_regs __iomem *regs = (struct bpp_regs __iomem *)p->base;\n\tu32 tmp;\n\n\ttmp = sbus_readl(&regs->p_csr);\n\ttmp &= ~DMA_INT_ENAB;\n\tsbus_writel(tmp, &regs->p_csr);\n}\n\nstatic void parport_sunbpp_enable_irq(struct parport *p)\n{\n\tstruct bpp_regs __iomem *regs = (struct bpp_regs __iomem *)p->base;\n\tu32 tmp;\n\n\ttmp = sbus_readl(&regs->p_csr);\n\ttmp |= DMA_INT_ENAB;\n\tsbus_writel(tmp, &regs->p_csr);\n}\n\nstatic void parport_sunbpp_write_data(struct parport *p, unsigned char d)\n{\n\tstruct bpp_regs __iomem *regs = (struct bpp_regs __iomem *)p->base;\n\n\tsbus_writeb(d, &regs->p_dr);\n\tdprintk((KERN_DEBUG \"wrote 0x%x\\n\", d));\n}\n\nstatic unsigned char parport_sunbpp_read_data(struct parport *p)\n{\n\tstruct bpp_regs __iomem *regs = (struct bpp_regs __iomem *)p->base;\n\n\treturn sbus_readb(&regs->p_dr);\n}\n\nstatic unsigned char status_sunbpp_to_pc(struct parport *p)\n{\n\tstruct bpp_regs __iomem *regs = (struct bpp_regs __iomem *)p->base;\n\tunsigned char bits = 0;\n\tunsigned char value_tcr = sbus_readb(&regs->p_tcr);\n\tunsigned char value_ir = sbus_readb(&regs->p_ir);\n\n\tif (!(value_ir & P_IR_ERR))\n\t\tbits |= PARPORT_STATUS_ERROR;\n\tif (!(value_ir & P_IR_SLCT))\n\t\tbits |= PARPORT_STATUS_SELECT;\n\tif (!(value_ir & P_IR_PE))\n\t\tbits |= PARPORT_STATUS_PAPEROUT;\n\tif (value_tcr & P_TCR_ACK)\n\t\tbits |= PARPORT_STATUS_ACK;\n\tif (!(value_tcr & P_TCR_BUSY))\n\t\tbits |= PARPORT_STATUS_BUSY;\n\n\tdprintk((KERN_DEBUG \"tcr 0x%x ir 0x%x\\n\", value_tcr, value_ir));\n\tdprintk((KERN_DEBUG \"read status 0x%x\\n\", bits));\n\treturn bits;\n}\n\nstatic unsigned char control_sunbpp_to_pc(struct parport *p)\n{\n\tstruct bpp_regs __iomem *regs = (struct bpp_regs __iomem *)p->base;\n\tunsigned char bits = 0;\n\tunsigned char value_tcr = sbus_readb(&regs->p_tcr);\n\tunsigned char value_or = sbus_readb(&regs->p_or);\n\n\tif (!(value_tcr & P_TCR_DS))\n\t\tbits |= PARPORT_CONTROL_STROBE;\n\tif (!(value_or & P_OR_AFXN))\n\t\tbits |= PARPORT_CONTROL_AUTOFD;\n\tif (!(value_or & P_OR_INIT))\n\t\tbits |= PARPORT_CONTROL_INIT;\n\tif (value_or & P_OR_SLCT_IN)\n\t\tbits |= PARPORT_CONTROL_SELECT;\n\n\tdprintk((KERN_DEBUG \"tcr 0x%x or 0x%x\\n\", value_tcr, value_or));\n\tdprintk((KERN_DEBUG \"read control 0x%x\\n\", bits));\n\treturn bits;\n}\n\nstatic unsigned char parport_sunbpp_read_control(struct parport *p)\n{\n\treturn control_sunbpp_to_pc(p);\n}\n\nstatic unsigned char parport_sunbpp_frob_control(struct parport *p,\n\t\t\t\t\t\t unsigned char mask,\n\t\t\t\t\t\t unsigned char val)\n{\n\tstruct bpp_regs __iomem *regs = (struct bpp_regs __iomem *)p->base;\n\tunsigned char value_tcr = sbus_readb(&regs->p_tcr);\n\tunsigned char value_or = sbus_readb(&regs->p_or);\n\n\tdprintk((KERN_DEBUG \"frob1: tcr 0x%x or 0x%x\\n\",\n\t\t value_tcr, value_or));\n\tif (mask & PARPORT_CONTROL_STROBE) {\n\t\tif (val & PARPORT_CONTROL_STROBE) {\n\t\t\tvalue_tcr &= ~P_TCR_DS;\n\t\t} else {\n\t\t\tvalue_tcr |= P_TCR_DS;\n\t\t}\n\t}\n\tif (mask & PARPORT_CONTROL_AUTOFD) {\n\t\tif (val & PARPORT_CONTROL_AUTOFD) {\n\t\t\tvalue_or &= ~P_OR_AFXN;\n\t\t} else {\n\t\t\tvalue_or |= P_OR_AFXN;\n\t\t}\n\t}\n\tif (mask & PARPORT_CONTROL_INIT) {\n\t\tif (val & PARPORT_CONTROL_INIT) {\n\t\t\tvalue_or &= ~P_OR_INIT;\n\t\t} else {\n\t\t\tvalue_or |= P_OR_INIT;\n\t\t}\n\t}\n\tif (mask & PARPORT_CONTROL_SELECT) {\n\t\tif (val & PARPORT_CONTROL_SELECT) {\n\t\t\tvalue_or |= P_OR_SLCT_IN;\n\t\t} else {\n\t\t\tvalue_or &= ~P_OR_SLCT_IN;\n\t\t}\n\t}\n\n\tsbus_writeb(value_or, &regs->p_or);\n\tsbus_writeb(value_tcr, &regs->p_tcr);\n\tdprintk((KERN_DEBUG \"frob2: tcr 0x%x or 0x%x\\n\",\n\t\t value_tcr, value_or));\n\treturn parport_sunbpp_read_control(p);\n}\n\nstatic void parport_sunbpp_write_control(struct parport *p, unsigned char d)\n{\n\tconst unsigned char wm = (PARPORT_CONTROL_STROBE |\n\t\t\t\t  PARPORT_CONTROL_AUTOFD |\n\t\t\t\t  PARPORT_CONTROL_INIT |\n\t\t\t\t  PARPORT_CONTROL_SELECT);\n\n\tparport_sunbpp_frob_control (p, wm, d & wm);\n}\n\nstatic unsigned char parport_sunbpp_read_status(struct parport *p)\n{\n\treturn status_sunbpp_to_pc(p);\n}\n\nstatic void parport_sunbpp_data_forward (struct parport *p)\n{\n\tstruct bpp_regs __iomem *regs = (struct bpp_regs __iomem *)p->base;\n\tunsigned char value_tcr = sbus_readb(&regs->p_tcr);\n\n\tdprintk((KERN_DEBUG \"forward\\n\"));\n\tvalue_tcr &= ~P_TCR_DIR;\n\tsbus_writeb(value_tcr, &regs->p_tcr);\n}\n\nstatic void parport_sunbpp_data_reverse (struct parport *p)\n{\n\tstruct bpp_regs __iomem *regs = (struct bpp_regs __iomem *)p->base;\n\tu8 val = sbus_readb(&regs->p_tcr);\n\n\tdprintk((KERN_DEBUG \"reverse\\n\"));\n\tval |= P_TCR_DIR;\n\tsbus_writeb(val, &regs->p_tcr);\n}\n\nstatic void parport_sunbpp_init_state(struct pardevice *dev, struct parport_state *s)\n{\n\ts->u.pc.ctr = 0xc;\n\ts->u.pc.ecr = 0x0;\n}\n\nstatic void parport_sunbpp_save_state(struct parport *p, struct parport_state *s)\n{\n\ts->u.pc.ctr = parport_sunbpp_read_control(p);\n}\n\nstatic void parport_sunbpp_restore_state(struct parport *p, struct parport_state *s)\n{\n\tparport_sunbpp_write_control(p, s->u.pc.ctr);\n}\n\nstatic struct parport_operations parport_sunbpp_ops = \n{\n\t.write_data\t= parport_sunbpp_write_data,\n\t.read_data\t= parport_sunbpp_read_data,\n\n\t.write_control\t= parport_sunbpp_write_control,\n\t.read_control\t= parport_sunbpp_read_control,\n\t.frob_control\t= parport_sunbpp_frob_control,\n\n\t.read_status\t= parport_sunbpp_read_status,\n\n\t.enable_irq\t= parport_sunbpp_enable_irq,\n\t.disable_irq\t= parport_sunbpp_disable_irq,\n\n\t.data_forward\t= parport_sunbpp_data_forward,\n\t.data_reverse\t= parport_sunbpp_data_reverse,\n\n\t.init_state\t= parport_sunbpp_init_state,\n\t.save_state\t= parport_sunbpp_save_state,\n\t.restore_state\t= parport_sunbpp_restore_state,\n\n\t.epp_write_data\t= parport_ieee1284_epp_write_data,\n\t.epp_read_data\t= parport_ieee1284_epp_read_data,\n\t.epp_write_addr\t= parport_ieee1284_epp_write_addr,\n\t.epp_read_addr\t= parport_ieee1284_epp_read_addr,\n\n\t.ecp_write_data\t= parport_ieee1284_ecp_write_data,\n\t.ecp_read_data\t= parport_ieee1284_ecp_read_data,\n\t.ecp_write_addr\t= parport_ieee1284_ecp_write_addr,\n\n\t.compat_write_data\t= parport_ieee1284_write_compat,\n\t.nibble_read_data\t= parport_ieee1284_read_nibble,\n\t.byte_read_data\t\t= parport_ieee1284_read_byte,\n\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic int bpp_probe(struct platform_device *op)\n{\n\tstruct parport_operations *ops;\n\tstruct bpp_regs __iomem *regs;\n\tint irq, dma, err = 0, size;\n\tunsigned char value_tcr;\n\tvoid __iomem *base;\n\tstruct parport *p;\n\n\tirq = op->archdata.irqs[0];\n\tbase = of_ioremap(&op->resource[0], 0,\n\t\t\t  resource_size(&op->resource[0]),\n\t\t\t  \"sunbpp\");\n\tif (!base)\n\t\treturn -ENODEV;\n\n\tsize = resource_size(&op->resource[0]);\n\tdma = PARPORT_DMA_NONE;\n\n\tops = kmemdup(&parport_sunbpp_ops, sizeof(struct parport_operations),\n\t\t      GFP_KERNEL);\n\tif (!ops) {\n\t\terr = -ENOMEM;\n\t\tgoto out_unmap;\n\t}\n\n\tdprintk((\"register_port\\n\"));\n\tif (!(p = parport_register_port((unsigned long)base, irq, dma, ops))) {\n\t\terr = -ENOMEM;\n\t\tgoto out_free_ops;\n\t}\n\n\tp->size = size;\n\tp->dev = &op->dev;\n\n\tif ((err = request_irq(p->irq, parport_irq_handler,\n\t\t\t       IRQF_SHARED, p->name, p)) != 0) {\n\t\tgoto out_put_port;\n\t}\n\n\tparport_sunbpp_enable_irq(p);\n\n\tregs = (struct bpp_regs __iomem *)p->base;\n\n\tvalue_tcr = sbus_readb(&regs->p_tcr);\n\tvalue_tcr &= ~P_TCR_DIR;\n\tsbus_writeb(value_tcr, &regs->p_tcr);\n\n\tpr_info(\"%s: sunbpp at 0x%lx\\n\", p->name, p->base);\n\n\tdev_set_drvdata(&op->dev, p);\n\n\tparport_announce_port(p);\n\n\treturn 0;\n\nout_put_port:\n\tparport_put_port(p);\n\nout_free_ops:\n\tkfree(ops);\n\nout_unmap:\n\tof_iounmap(&op->resource[0], base, size);\n\n\treturn err;\n}\n\nstatic int bpp_remove(struct platform_device *op)\n{\n\tstruct parport *p = dev_get_drvdata(&op->dev);\n\tstruct parport_operations *ops = p->ops;\n\n\tparport_remove_port(p);\n\n\tif (p->irq != PARPORT_IRQ_NONE) {\n\t\tparport_sunbpp_disable_irq(p);\n\t\tfree_irq(p->irq, p);\n\t}\n\n\tof_iounmap(&op->resource[0], (void __iomem *) p->base, p->size);\n\tparport_put_port(p);\n\tkfree(ops);\n\n\tdev_set_drvdata(&op->dev, NULL);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id bpp_match[] = {\n\t{\n\t\t.name = \"SUNW,bpp\",\n\t},\n\t{},\n};\n\nMODULE_DEVICE_TABLE(of, bpp_match);\n\nstatic struct platform_driver bpp_sbus_driver = {\n\t.driver = {\n\t\t.name = \"bpp\",\n\t\t.of_match_table = bpp_match,\n\t},\n\t.probe\t\t= bpp_probe,\n\t.remove\t\t= bpp_remove,\n};\n\nmodule_platform_driver(bpp_sbus_driver);\n\nMODULE_AUTHOR(\"Derrick J Brashear\");\nMODULE_DESCRIPTION(\"Parport Driver for Sparc bidirectional Port\");\nMODULE_VERSION(\"2.0\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}