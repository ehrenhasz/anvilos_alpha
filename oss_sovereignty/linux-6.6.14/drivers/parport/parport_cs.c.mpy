{
  "module_name": "parport_cs.c",
  "hash_id": "715e5c871c0d0d5cf3112f20689b90848a932027632153b02d8a8c8a087726a4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/parport/parport_cs.c",
  "human_readable_source": " \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/ptrace.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/timer.h>\n#include <linux/ioport.h>\n#include <linux/major.h>\n#include <linux/interrupt.h>\n\n#include <linux/parport.h>\n#include <linux/parport_pc.h>\n\n#include <pcmcia/cistpl.h>\n#include <pcmcia/ds.h>\n#include <pcmcia/cisreg.h>\n#include <pcmcia/ciscode.h>\n\n \n\n \n\nMODULE_AUTHOR(\"David Hinds <dahinds@users.sourceforge.net>\");\nMODULE_DESCRIPTION(\"PCMCIA parallel port card driver\");\nMODULE_LICENSE(\"Dual MPL/GPL\");\n\n#define INT_MODULE_PARM(n, v) static int n = v; module_param(n, int, 0)\n\nINT_MODULE_PARM(epp_mode, 1);\n\n\n \n\n#define FORCE_EPP_MODE\t0x08\n\ntypedef struct parport_info_t {\n\tstruct pcmcia_device\t*p_dev;\n    int\t\t\tndev;\n    struct parport\t*port;\n} parport_info_t;\n\nstatic void parport_detach(struct pcmcia_device *p_dev);\nstatic int parport_config(struct pcmcia_device *link);\nstatic void parport_cs_release(struct pcmcia_device *);\n\nstatic int parport_probe(struct pcmcia_device *link)\n{\n    parport_info_t *info;\n\n    dev_dbg(&link->dev, \"parport_attach()\\n\");\n\n     \n    info = kzalloc(sizeof(*info), GFP_KERNEL);\n    if (!info) return -ENOMEM;\n    link->priv = info;\n    info->p_dev = link;\n\n    link->config_flags |= CONF_ENABLE_IRQ | CONF_AUTO_SET_IO;\n\n    return parport_config(link);\n}  \n\nstatic void parport_detach(struct pcmcia_device *link)\n{\n    dev_dbg(&link->dev, \"parport_detach\\n\");\n\n    parport_cs_release(link);\n\n    kfree(link->priv);\n}  \n\nstatic int parport_config_check(struct pcmcia_device *p_dev, void *priv_data)\n{\n\tp_dev->resource[0]->flags &= ~IO_DATA_PATH_WIDTH;\n\tp_dev->resource[0]->flags |= IO_DATA_PATH_WIDTH_8;\n\tp_dev->resource[1]->flags &= ~IO_DATA_PATH_WIDTH;\n\tp_dev->resource[1]->flags |= IO_DATA_PATH_WIDTH_8;\n\n\treturn pcmcia_request_io(p_dev);\n}\n\nstatic int parport_config(struct pcmcia_device *link)\n{\n    parport_info_t *info = link->priv;\n    struct parport *p;\n    int ret;\n\n    dev_dbg(&link->dev, \"parport_config\\n\");\n\n    if (epp_mode)\n\t    link->config_index |= FORCE_EPP_MODE;\n\n    ret = pcmcia_loop_config(link, parport_config_check, NULL);\n    if (ret)\n\t    goto failed;\n\n    if (!link->irq)\n\t    goto failed;\n    ret = pcmcia_enable_device(link);\n    if (ret)\n\t    goto failed;\n\n    p = parport_pc_probe_port(link->resource[0]->start,\n\t\t\t      link->resource[1]->start,\n\t\t\t      link->irq, PARPORT_DMA_NONE,\n\t\t\t      &link->dev, IRQF_SHARED);\n    if (p == NULL) {\n\t    pr_notice(\"parport_cs: parport_pc_probe_port() at 0x%3x, irq %u failed\\n\",\n\t\t      (unsigned int)link->resource[0]->start, link->irq);\n\tgoto failed;\n    }\n\n    p->modes |= PARPORT_MODE_PCSPP;\n    if (epp_mode)\n\tp->modes |= PARPORT_MODE_TRISTATE | PARPORT_MODE_EPP;\n    info->ndev = 1;\n    info->port = p;\n\n    return 0;\n\nfailed:\n\tparport_cs_release(link);\n\tkfree(link->priv);\n\treturn -ENODEV;\n}  \n\nstatic void parport_cs_release(struct pcmcia_device *link)\n{\n\tparport_info_t *info = link->priv;\n\n\tdev_dbg(&link->dev, \"parport_release\\n\");\n\n\tif (info->ndev) {\n\t\tstruct parport *p = info->port;\n\t\tparport_pc_unregister_port(p);\n\t}\n\tinfo->ndev = 0;\n\n\tpcmcia_disable_device(link);\n}  \n\n\nstatic const struct pcmcia_device_id parport_ids[] = {\n\tPCMCIA_DEVICE_FUNC_ID(3),\n\tPCMCIA_MFC_DEVICE_PROD_ID12(1,\"Elan\",\"Serial+Parallel Port: SP230\",0x3beb8cf2,0xdb9e58bc),\n\tPCMCIA_DEVICE_MANF_CARD(0x0137, 0x0003),\n\tPCMCIA_DEVICE_NULL\n};\nMODULE_DEVICE_TABLE(pcmcia, parport_ids);\n\nstatic struct pcmcia_driver parport_cs_driver = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"parport_cs\",\n\t.probe\t\t= parport_probe,\n\t.remove\t\t= parport_detach,\n\t.id_table\t= parport_ids,\n};\nmodule_pcmcia_driver(parport_cs_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}