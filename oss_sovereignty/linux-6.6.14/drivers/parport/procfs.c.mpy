{
  "module_name": "procfs.c",
  "hash_id": "a4f078a9048f0c9cc9f85b6954bbe9284f6bcd5dd8d8ba16232e54272fbf56c0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/parport/procfs.c",
  "human_readable_source": "\n \n\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/parport.h>\n#include <linux/ctype.h>\n#include <linux/sysctl.h>\n#include <linux/device.h>\n\n#include <linux/uaccess.h>\n\n#if defined(CONFIG_SYSCTL) && defined(CONFIG_PROC_FS)\n\n#define PARPORT_MIN_TIMESLICE_VALUE 1ul \n#define PARPORT_MAX_TIMESLICE_VALUE ((unsigned long) HZ)\n#define PARPORT_MIN_SPINTIME_VALUE 1\n#define PARPORT_MAX_SPINTIME_VALUE 1000\n \n#define PARPORT_BASE_PATH_SIZE 13\n#define PARPORT_BASE_DEVICES_PATH_SIZE 22\n\nstatic int do_active_device(struct ctl_table *table, int write,\n\t\t      void *result, size_t *lenp, loff_t *ppos)\n{\n\tstruct parport *port = (struct parport *)table->extra1;\n\tchar buffer[256];\n\tstruct pardevice *dev;\n\tint len = 0;\n\n\tif (write)\t\t \n\t\treturn -EACCES;\n\n\tif (*ppos) {\n\t\t*lenp = 0;\n\t\treturn 0;\n\t}\n\t\n\tfor (dev = port->devices; dev ; dev = dev->next) {\n\t\tif(dev == port->cad) {\n\t\t\tlen += sprintf(buffer, \"%s\\n\", dev->name);\n\t\t}\n\t}\n\n\tif(!len) {\n\t\tlen += sprintf(buffer, \"%s\\n\", \"none\");\n\t}\n\n\tif (len > *lenp)\n\t\tlen = *lenp;\n\telse\n\t\t*lenp = len;\n\n\t*ppos += len;\n\tmemcpy(result, buffer, len);\n\treturn 0;\n}\n\n#ifdef CONFIG_PARPORT_1284\nstatic int do_autoprobe(struct ctl_table *table, int write,\n\t\t\tvoid *result, size_t *lenp, loff_t *ppos)\n{\n\tstruct parport_device_info *info = table->extra2;\n\tconst char *str;\n\tchar buffer[256];\n\tint len = 0;\n\n\tif (write)  \n\t\treturn -EACCES;\n\n\tif (*ppos) {\n\t\t*lenp = 0;\n\t\treturn 0;\n\t}\n\t\n\tif ((str = info->class_name) != NULL)\n\t\tlen += sprintf (buffer + len, \"CLASS:%s;\\n\", str);\n\n\tif ((str = info->model) != NULL)\n\t\tlen += sprintf (buffer + len, \"MODEL:%s;\\n\", str);\n\n\tif ((str = info->mfr) != NULL)\n\t\tlen += sprintf (buffer + len, \"MANUFACTURER:%s;\\n\", str);\n\n\tif ((str = info->description) != NULL)\n\t\tlen += sprintf (buffer + len, \"DESCRIPTION:%s;\\n\", str);\n\n\tif ((str = info->cmdset) != NULL)\n\t\tlen += sprintf (buffer + len, \"COMMAND SET:%s;\\n\", str);\n\n\tif (len > *lenp)\n\t\tlen = *lenp;\n\telse\n\t\t*lenp = len;\n\n\t*ppos += len;\n\n\tmemcpy(result, buffer, len);\n\treturn 0;\n}\n#endif  \n\nstatic int do_hardware_base_addr(struct ctl_table *table, int write,\n\t\t\t\t void *result, size_t *lenp, loff_t *ppos)\n{\n\tstruct parport *port = (struct parport *)table->extra1;\n\tchar buffer[20];\n\tint len = 0;\n\n\tif (*ppos) {\n\t\t*lenp = 0;\n\t\treturn 0;\n\t}\n\n\tif (write)  \n\t\treturn -EACCES;\n\n\tlen += sprintf (buffer, \"%lu\\t%lu\\n\", port->base, port->base_hi);\n\n\tif (len > *lenp)\n\t\tlen = *lenp;\n\telse\n\t\t*lenp = len;\n\n\t*ppos += len;\n\tmemcpy(result, buffer, len);\n\treturn 0;\n}\n\nstatic int do_hardware_irq(struct ctl_table *table, int write,\n\t\t\t   void *result, size_t *lenp, loff_t *ppos)\n{\n\tstruct parport *port = (struct parport *)table->extra1;\n\tchar buffer[20];\n\tint len = 0;\n\n\tif (*ppos) {\n\t\t*lenp = 0;\n\t\treturn 0;\n\t}\n\n\tif (write)  \n\t\treturn -EACCES;\n\n\tlen += sprintf (buffer, \"%d\\n\", port->irq);\n\n\tif (len > *lenp)\n\t\tlen = *lenp;\n\telse\n\t\t*lenp = len;\n\n\t*ppos += len;\n\tmemcpy(result, buffer, len);\n\treturn 0;\n}\n\nstatic int do_hardware_dma(struct ctl_table *table, int write,\n\t\t\t   void *result, size_t *lenp, loff_t *ppos)\n{\n\tstruct parport *port = (struct parport *)table->extra1;\n\tchar buffer[20];\n\tint len = 0;\n\n\tif (*ppos) {\n\t\t*lenp = 0;\n\t\treturn 0;\n\t}\n\n\tif (write)  \n\t\treturn -EACCES;\n\n\tlen += sprintf (buffer, \"%d\\n\", port->dma);\n\n\tif (len > *lenp)\n\t\tlen = *lenp;\n\telse\n\t\t*lenp = len;\n\n\t*ppos += len;\n\tmemcpy(result, buffer, len);\n\treturn 0;\n}\n\nstatic int do_hardware_modes(struct ctl_table *table, int write,\n\t\t\t     void *result, size_t *lenp, loff_t *ppos)\n{\n\tstruct parport *port = (struct parport *)table->extra1;\n\tchar buffer[40];\n\tint len = 0;\n\n\tif (*ppos) {\n\t\t*lenp = 0;\n\t\treturn 0;\n\t}\n\n\tif (write)  \n\t\treturn -EACCES;\n\n\t{\n#define printmode(x)\t\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tif (port->modes & PARPORT_MODE_##x)\t\t\t\t\\\n\t\tlen += sprintf(buffer + len, \"%s%s\", f++ ? \",\" : \"\", #x); \\\n} while (0)\n\t\tint f = 0;\n\t\tprintmode(PCSPP);\n\t\tprintmode(TRISTATE);\n\t\tprintmode(COMPAT);\n\t\tprintmode(EPP);\n\t\tprintmode(ECP);\n\t\tprintmode(DMA);\n#undef printmode\n\t}\n\tbuffer[len++] = '\\n';\n\n\tif (len > *lenp)\n\t\tlen = *lenp;\n\telse\n\t\t*lenp = len;\n\n\t*ppos += len;\n\tmemcpy(result, buffer, len);\n\treturn 0;\n}\n\nstatic const unsigned long parport_min_timeslice_value =\nPARPORT_MIN_TIMESLICE_VALUE;\n\nstatic const unsigned long parport_max_timeslice_value =\nPARPORT_MAX_TIMESLICE_VALUE;\n\nstatic const  int parport_min_spintime_value =\nPARPORT_MIN_SPINTIME_VALUE;\n\nstatic const int parport_max_spintime_value =\nPARPORT_MAX_SPINTIME_VALUE;\n\n\nstruct parport_sysctl_table {\n\tstruct ctl_table_header *port_header;\n\tstruct ctl_table_header *devices_header;\n\tstruct ctl_table vars[12];\n\tstruct ctl_table device_dir[2];\n};\n\nstatic const struct parport_sysctl_table parport_sysctl_template = {\n\t.port_header = NULL,\n\t.devices_header = NULL,\n\t{\n\t\t{\n\t\t\t.procname\t= \"spintime\",\n\t\t\t.data\t\t= NULL,\n\t\t\t.maxlen\t\t= sizeof(int),\n\t\t\t.mode\t\t= 0644,\n\t\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t\t.extra1\t\t= (void*) &parport_min_spintime_value,\n\t\t\t.extra2\t\t= (void*) &parport_max_spintime_value\n\t\t},\n\t\t{\n\t\t\t.procname\t= \"base-addr\",\n\t\t\t.data\t\t= NULL,\n\t\t\t.maxlen\t\t= 0,\n\t\t\t.mode\t\t= 0444,\n\t\t\t.proc_handler\t= do_hardware_base_addr\n\t\t},\n\t\t{\n\t\t\t.procname\t= \"irq\",\n\t\t\t.data\t\t= NULL,\n\t\t\t.maxlen\t\t= 0,\n\t\t\t.mode\t\t= 0444,\n\t\t\t.proc_handler\t= do_hardware_irq\n\t\t},\n\t\t{\n\t\t\t.procname\t= \"dma\",\n\t\t\t.data\t\t= NULL,\n\t\t\t.maxlen\t\t= 0,\n\t\t\t.mode\t\t= 0444,\n\t\t\t.proc_handler\t= do_hardware_dma\n\t\t},\n\t\t{\n\t\t\t.procname\t= \"modes\",\n\t\t\t.data\t\t= NULL,\n\t\t\t.maxlen\t\t= 0,\n\t\t\t.mode\t\t= 0444,\n\t\t\t.proc_handler\t= do_hardware_modes\n\t\t},\n#ifdef CONFIG_PARPORT_1284\n\t\t{\n\t\t\t.procname\t= \"autoprobe\",\n\t\t\t.data\t\t= NULL,\n\t\t\t.maxlen\t\t= 0,\n\t\t\t.mode\t\t= 0444,\n\t\t\t.proc_handler\t= do_autoprobe\n\t\t},\n\t\t{\n\t\t\t.procname\t= \"autoprobe0\",\n\t\t\t.data\t\t= NULL,\n\t\t\t.maxlen\t\t= 0,\n\t\t\t.mode\t\t= 0444,\n\t\t\t.proc_handler\t= do_autoprobe\n\t\t},\n\t\t{\n\t\t\t.procname\t= \"autoprobe1\",\n\t\t\t.data\t\t= NULL,\n\t\t\t.maxlen\t\t= 0,\n\t\t\t.mode\t\t= 0444,\n\t\t\t.proc_handler\t= do_autoprobe\n\t\t},\n\t\t{\n\t\t\t.procname\t= \"autoprobe2\",\n\t\t\t.data\t\t= NULL,\n\t\t\t.maxlen\t\t= 0,\n\t\t\t.mode\t\t= 0444,\n\t\t\t.proc_handler\t= do_autoprobe\n\t\t},\n\t\t{\n\t\t\t.procname\t= \"autoprobe3\",\n\t\t\t.data\t\t= NULL,\n\t\t\t.maxlen\t\t= 0,\n\t\t\t.mode\t\t= 0444,\n\t\t\t.proc_handler\t= do_autoprobe\n\t\t},\n#endif  \n\t\t{}\n\t},\n\t{\n\t\t{\n\t\t\t.procname\t= \"active\",\n\t\t\t.data\t\t= NULL,\n\t\t\t.maxlen\t\t= 0,\n\t\t\t.mode\t\t= 0444,\n\t\t\t.proc_handler\t= do_active_device\n\t\t},\n\t\t{}\n\t},\n};\n\nstruct parport_device_sysctl_table\n{\n\tstruct ctl_table_header *sysctl_header;\n\tstruct ctl_table vars[2];\n\tstruct ctl_table device_dir[2];\n\tstruct ctl_table devices_root_dir[2];\n\tstruct ctl_table port_dir[2];\n\tstruct ctl_table parport_dir[2];\n\tstruct ctl_table dev_dir[2];\n};\n\nstatic const struct parport_device_sysctl_table\nparport_device_sysctl_template = {\n\t.sysctl_header = NULL,\n\t{\n\t\t{\n\t\t\t.procname \t= \"timeslice\",\n\t\t\t.data\t\t= NULL,\n\t\t\t.maxlen\t\t= sizeof(unsigned long),\n\t\t\t.mode\t\t= 0644,\n\t\t\t.proc_handler\t= proc_doulongvec_ms_jiffies_minmax,\n\t\t\t.extra1\t\t= (void*) &parport_min_timeslice_value,\n\t\t\t.extra2\t\t= (void*) &parport_max_timeslice_value\n\t\t},\n\t\t{}\n\t},\n\t{\n\t\t{\n\t\t\t.procname\t= NULL,\n\t\t\t.data\t\t= NULL,\n\t\t\t.maxlen\t\t= 0,\n\t\t\t.mode\t\t= 0555,\n\t\t},\n\t\t{}\n\t}\n};\n\nstruct parport_default_sysctl_table\n{\n\tstruct ctl_table_header *sysctl_header;\n\tstruct ctl_table vars[3];\n\tstruct ctl_table default_dir[2];\n\tstruct ctl_table parport_dir[2];\n\tstruct ctl_table dev_dir[2];\n};\n\nstatic struct parport_default_sysctl_table\nparport_default_sysctl_table = {\n\t.sysctl_header\t= NULL,\n\t{\n\t\t{\n\t\t\t.procname\t= \"timeslice\",\n\t\t\t.data\t\t= &parport_default_timeslice,\n\t\t\t.maxlen\t\t= sizeof(parport_default_timeslice),\n\t\t\t.mode\t\t= 0644,\n\t\t\t.proc_handler\t= proc_doulongvec_ms_jiffies_minmax,\n\t\t\t.extra1\t\t= (void*) &parport_min_timeslice_value,\n\t\t\t.extra2\t\t= (void*) &parport_max_timeslice_value\n\t\t},\n\t\t{\n\t\t\t.procname\t= \"spintime\",\n\t\t\t.data\t\t= &parport_default_spintime,\n\t\t\t.maxlen\t\t= sizeof(parport_default_spintime),\n\t\t\t.mode\t\t= 0644,\n\t\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t\t.extra1\t\t= (void*) &parport_min_spintime_value,\n\t\t\t.extra2\t\t= (void*) &parport_max_spintime_value\n\t\t},\n\t\t{}\n\t}\n};\n\nint parport_proc_register(struct parport *port)\n{\n\tstruct parport_sysctl_table *t;\n\tchar *tmp_dir_path;\n\tsize_t tmp_path_len, port_name_len;\n\tint bytes_written, i, err = 0;\n\n\tt = kmemdup(&parport_sysctl_template, sizeof(*t), GFP_KERNEL);\n\tif (t == NULL)\n\t\treturn -ENOMEM;\n\n\tt->device_dir[0].extra1 = port;\n\n\tt->vars[0].data = &port->spintime;\n\tfor (i = 0; i < 5; i++) {\n\t\tt->vars[i].extra1 = port;\n\t\tt->vars[5 + i].extra2 = &port->probe_info[i];\n\t}\n\n\tport_name_len = strnlen(port->name, PARPORT_NAME_MAX_LEN);\n\t \n\ttmp_path_len = PARPORT_BASE_DEVICES_PATH_SIZE + port_name_len;\n\ttmp_dir_path = kzalloc(tmp_path_len, GFP_KERNEL);\n\tif (!tmp_dir_path) {\n\t\terr = -ENOMEM;\n\t\tgoto exit_free_t;\n\t}\n\n\tbytes_written = snprintf(tmp_dir_path, tmp_path_len,\n\t\t\t\t \"dev/parport/%s/devices\", port->name);\n\tif (tmp_path_len <= bytes_written) {\n\t\terr = -ENOENT;\n\t\tgoto exit_free_tmp_dir_path;\n\t}\n\tt->devices_header = register_sysctl(tmp_dir_path, t->device_dir);\n\tif (t->devices_header == NULL) {\n\t\terr = -ENOENT;\n\t\tgoto  exit_free_tmp_dir_path;\n\t}\n\n\ttmp_path_len = PARPORT_BASE_PATH_SIZE + port_name_len;\n\tbytes_written = snprintf(tmp_dir_path, tmp_path_len,\n\t\t\t\t \"dev/parport/%s\", port->name);\n\tif (tmp_path_len <= bytes_written) {\n\t\terr = -ENOENT;\n\t\tgoto unregister_devices_h;\n\t}\n\n\tt->port_header = register_sysctl(tmp_dir_path, t->vars);\n\tif (t->port_header == NULL) {\n\t\terr = -ENOENT;\n\t\tgoto unregister_devices_h;\n\t}\n\n\tport->sysctl_table = t;\n\n\tkfree(tmp_dir_path);\n\treturn 0;\n\nunregister_devices_h:\n\tunregister_sysctl_table(t->devices_header);\n\nexit_free_tmp_dir_path:\n\tkfree(tmp_dir_path);\n\nexit_free_t:\n\tkfree(t);\n\treturn err;\n}\n\nint parport_proc_unregister(struct parport *port)\n{\n\tif (port->sysctl_table) {\n\t\tstruct parport_sysctl_table *t = port->sysctl_table;\n\t\tport->sysctl_table = NULL;\n\t\tunregister_sysctl_table(t->devices_header);\n\t\tunregister_sysctl_table(t->port_header);\n\t\tkfree(t);\n\t}\n\treturn 0;\n}\n\nint parport_device_proc_register(struct pardevice *device)\n{\n\tint bytes_written, err = 0;\n\tstruct parport_device_sysctl_table *t;\n\tstruct parport * port = device->port;\n\tsize_t port_name_len, device_name_len, tmp_dir_path_len;\n\tchar *tmp_dir_path;\n\t\n\tt = kmemdup(&parport_device_sysctl_template, sizeof(*t), GFP_KERNEL);\n\tif (t == NULL)\n\t\treturn -ENOMEM;\n\n\tport_name_len = strnlen(port->name, PARPORT_NAME_MAX_LEN);\n\tdevice_name_len = strnlen(device->name, PATH_MAX);\n\n\t \n\ttmp_dir_path_len = PARPORT_BASE_DEVICES_PATH_SIZE + port_name_len + device_name_len;\n\ttmp_dir_path = kzalloc(tmp_dir_path_len, GFP_KERNEL);\n\tif (!tmp_dir_path) {\n\t\terr = -ENOMEM;\n\t\tgoto exit_free_t;\n\t}\n\n\tbytes_written = snprintf(tmp_dir_path, tmp_dir_path_len, \"dev/parport/%s/devices/%s\",\n\t\t\t\t port->name, device->name);\n\tif (tmp_dir_path_len <= bytes_written) {\n\t\terr = -ENOENT;\n\t\tgoto exit_free_path;\n\t}\n\n\tt->vars[0].data = &device->timeslice;\n\n\tt->sysctl_header = register_sysctl(tmp_dir_path, t->vars);\n\tif (t->sysctl_header == NULL) {\n\t\tkfree(t);\n\t\tt = NULL;\n\t}\n\tdevice->sysctl_table = t;\n\n\tkfree(tmp_dir_path);\n\treturn 0;\n\nexit_free_path:\n\tkfree(tmp_dir_path);\n\nexit_free_t:\n\tkfree(t);\n\n\treturn err;\n}\n\nint parport_device_proc_unregister(struct pardevice *device)\n{\n\tif (device->sysctl_table) {\n\t\tstruct parport_device_sysctl_table *t = device->sysctl_table;\n\t\tdevice->sysctl_table = NULL;\n\t\tunregister_sysctl_table(t->sysctl_header);\n\t\tkfree(t);\n\t}\n\treturn 0;\n}\n\nstatic int __init parport_default_proc_register(void)\n{\n\tint ret;\n\n\tparport_default_sysctl_table.sysctl_header =\n\t\tregister_sysctl(\"dev/parport/default\", parport_default_sysctl_table.vars);\n\tif (!parport_default_sysctl_table.sysctl_header)\n\t\treturn -ENOMEM;\n\tret = parport_bus_init();\n\tif (ret) {\n\t\tunregister_sysctl_table(parport_default_sysctl_table.\n\t\t\t\t\tsysctl_header);\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic void __exit parport_default_proc_unregister(void)\n{\n\tif (parport_default_sysctl_table.sysctl_header) {\n\t\tunregister_sysctl_table(parport_default_sysctl_table.\n\t\t\t\t\tsysctl_header);\n\t\tparport_default_sysctl_table.sysctl_header = NULL;\n\t}\n\tparport_bus_exit();\n}\n\n#else  \n\nint parport_proc_register(struct parport *pp)\n{\n\treturn 0;\n}\n\nint parport_proc_unregister(struct parport *pp)\n{\n\treturn 0;\n}\n\nint parport_device_proc_register(struct pardevice *device)\n{\n\treturn 0;\n}\n\nint parport_device_proc_unregister(struct pardevice *device)\n{\n\treturn 0;\n}\n\nstatic int __init parport_default_proc_register (void)\n{\n\treturn parport_bus_init();\n}\n\nstatic void __exit parport_default_proc_unregister (void)\n{\n\tparport_bus_exit();\n}\n#endif\n\nsubsys_initcall(parport_default_proc_register)\nmodule_exit(parport_default_proc_unregister)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}