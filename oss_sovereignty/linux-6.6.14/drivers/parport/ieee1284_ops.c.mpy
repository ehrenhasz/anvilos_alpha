{
  "module_name": "ieee1284_ops.c",
  "hash_id": "b46d121cc802f85ea57e895d7601618bf80e186a33d3476bcd9a742ed131b6b2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/parport/ieee1284_ops.c",
  "human_readable_source": "\n \n\n\n#include <linux/module.h>\n#include <linux/parport.h>\n#include <linux/delay.h>\n#include <linux/sched/signal.h>\n#include <linux/uaccess.h>\n\n#undef DEBUG  \n\n#ifdef CONFIG_LP_CONSOLE\n#undef DEBUG  \n#endif\n\n \n\n \nsize_t parport_ieee1284_write_compat (struct parport *port,\n\t\t\t\t      const void *buffer, size_t len,\n\t\t\t\t      int flags)\n{\n\tint no_irq = 1;\n\tssize_t count = 0;\n\tconst unsigned char *addr = buffer;\n\tunsigned char byte;\n\tstruct pardevice *dev = port->physport->cad;\n\tunsigned char ctl = (PARPORT_CONTROL_SELECT\n\t\t\t     | PARPORT_CONTROL_INIT);\n\n\tif (port->irq != PARPORT_IRQ_NONE) {\n\t\tparport_enable_irq (port);\n\t\tno_irq = 0;\n\t}\n\n\tport->physport->ieee1284.phase = IEEE1284_PH_FWD_DATA;\n\tparport_write_control (port, ctl);\n\tparport_data_forward (port);\n\twhile (count < len) {\n\t\tunsigned long expire = jiffies + dev->timeout;\n\t\tlong wait = msecs_to_jiffies(10);\n\t\tunsigned char mask = (PARPORT_STATUS_ERROR\n\t\t\t\t      | PARPORT_STATUS_BUSY);\n\t\tunsigned char val = (PARPORT_STATUS_ERROR\n\t\t\t\t     | PARPORT_STATUS_BUSY);\n\n\t\t \n\t\tdo {\n\t\t\t \n\t\t\tif (!parport_wait_peripheral (port, mask, val))\n\t\t\t\t \n\t\t\t\tgoto ready;\n\n\t\t\t \n\t\t\tif ((parport_read_status (port) &\n\t\t\t     (PARPORT_STATUS_PAPEROUT |\n\t\t\t      PARPORT_STATUS_SELECT |\n\t\t\t      PARPORT_STATUS_ERROR))\n\t\t\t    != (PARPORT_STATUS_SELECT |\n\t\t\t\tPARPORT_STATUS_ERROR))\n\t\t\t\t \n\t\t\t\tgoto stop;\n\n\t\t\t \n\t\t\tif (!time_before (jiffies, expire))\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tif (count && no_irq) {\n\t\t\t\tparport_release (dev);\n\t\t\t\tschedule_timeout_interruptible(wait);\n\t\t\t\tparport_claim_or_block (dev);\n\t\t\t}\n\t\t\telse\n\t\t\t\t \n\t\t\t\tparport_wait_event (port, wait);\n\n\t\t\t \n\t\t\tif (signal_pending (current))\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\twait *= 2;\n\t\t} while (time_before (jiffies, expire));\n\n\t\tif (signal_pending (current))\n\t\t\tbreak;\n\n\t\tpr_debug(\"%s: Timed out\\n\", port->name);\n\t\tbreak;\n\n\tready:\n\t\t \n\t\tbyte = *addr++;\n\t\tparport_write_data (port, byte);\n\t\tudelay (1);\n\n\t\t \n\t\tparport_write_control (port, ctl | PARPORT_CONTROL_STROBE);\n\t\tudelay (1);  \n\n\t\tparport_write_control (port, ctl);\n\t\tudelay (1);  \n\n\t\t \n\t\tcount++;\n\n                 \n\t\tif (time_before (jiffies, expire))\n\t\t\tif (!parport_yield_blocking (dev)\n\t\t\t    && need_resched())\n\t\t\t\tschedule ();\n\t}\n stop:\n\tport->physport->ieee1284.phase = IEEE1284_PH_FWD_IDLE;\n\n\treturn count;\n}\n\n \nsize_t parport_ieee1284_read_nibble (struct parport *port, \n\t\t\t\t     void *buffer, size_t len,\n\t\t\t\t     int flags)\n{\n#ifndef CONFIG_PARPORT_1284\n\treturn 0;\n#else\n\tunsigned char *buf = buffer;\n\tint i;\n\tunsigned char byte = 0;\n\n\tlen *= 2;  \n\tfor (i=0; i < len; i++) {\n\t\tunsigned char nibble;\n\n\t\t \n\t\tif (((i & 1) == 0) &&\n\t\t    (parport_read_status(port) & PARPORT_STATUS_ERROR)) {\n\t\t\tgoto end_of_data;\n\t\t}\n\n\t\t \n\t\tparport_frob_control (port,\n\t\t\t\t      PARPORT_CONTROL_AUTOFD,\n\t\t\t\t      PARPORT_CONTROL_AUTOFD);\n\n\t\t \n\t\tport->ieee1284.phase = IEEE1284_PH_REV_DATA;\n\t\tif (parport_wait_peripheral (port,\n\t\t\t\t\t     PARPORT_STATUS_ACK, 0)) {\n\t\t\t \n\t\t\tpr_debug(\"%s: Nibble timeout at event 9 (%d bytes)\\n\",\n\t\t\t\t port->name, i / 2);\n\t\t\tparport_frob_control (port, PARPORT_CONTROL_AUTOFD, 0);\n\t\t\tbreak;\n\t\t}\n\n\n\t\t \n\t\tnibble = parport_read_status (port) >> 3;\n\t\tnibble &= ~8;\n\t\tif ((nibble & 0x10) == 0)\n\t\t\tnibble |= 8;\n\t\tnibble &= 0xf;\n\n\t\t \n\t\tparport_frob_control (port, PARPORT_CONTROL_AUTOFD, 0);\n\n\t\t \n\t\tif (parport_wait_peripheral (port,\n\t\t\t\t\t     PARPORT_STATUS_ACK,\n\t\t\t\t\t     PARPORT_STATUS_ACK)) {\n\t\t\t \n\t\t\tpr_debug(\"%s: Nibble timeout at event 11\\n\",\n\t\t\t\t port->name);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (i & 1) {\n\t\t\t \n\t\t\tbyte |= nibble << 4;\n\t\t\t*buf++ = byte;\n\t\t} else \n\t\t\tbyte = nibble;\n\t}\n\n\tif (i == len) {\n\t\t \n\t\tif (parport_read_status (port) & PARPORT_STATUS_ERROR) {\n\t\tend_of_data:\n\t\t\tpr_debug(\"%s: No more nibble data (%d bytes)\\n\",\n\t\t\t\t port->name, i / 2);\n\n\t\t\t \n\t\t\tparport_frob_control (port,\n\t\t\t\t\t      PARPORT_CONTROL_AUTOFD,\n\t\t\t\t\t      PARPORT_CONTROL_AUTOFD);\n\t\t\tport->physport->ieee1284.phase = IEEE1284_PH_REV_IDLE;\n\t\t}\n\t\telse\n\t\t\tport->physport->ieee1284.phase = IEEE1284_PH_HBUSY_DAVAIL;\n\t}\n\n\treturn i/2;\n#endif  \n}\n\n \nsize_t parport_ieee1284_read_byte (struct parport *port,\n\t\t\t\t   void *buffer, size_t len,\n\t\t\t\t   int flags)\n{\n#ifndef CONFIG_PARPORT_1284\n\treturn 0;\n#else\n\tunsigned char *buf = buffer;\n\tssize_t count = 0;\n\n\tfor (count = 0; count < len; count++) {\n\t\tunsigned char byte;\n\n\t\t \n\t\tif (parport_read_status (port) & PARPORT_STATUS_ERROR) {\n\t\t\tgoto end_of_data;\n\t\t}\n\n\t\t \n\t\tparport_data_reverse (port);\n\n\t\t \n\t\tparport_frob_control (port,\n\t\t\t\t      PARPORT_CONTROL_AUTOFD,\n\t\t\t\t      PARPORT_CONTROL_AUTOFD);\n\n\t\t \n\t\tport->physport->ieee1284.phase = IEEE1284_PH_REV_DATA;\n\t\tif (parport_wait_peripheral (port,\n\t\t\t\t\t     PARPORT_STATUS_ACK,\n\t\t\t\t\t     0)) {\n\t\t\t \n\t\t\tparport_frob_control (port, PARPORT_CONTROL_AUTOFD,\n\t\t\t\t\t\t 0);\n\t\t\tpr_debug(\"%s: Byte timeout at event 9\\n\", port->name);\n\t\t\tbreak;\n\t\t}\n\n\t\tbyte = parport_read_data (port);\n\t\t*buf++ = byte;\n\n\t\t \n\t\tparport_frob_control (port, PARPORT_CONTROL_AUTOFD, 0);\n\n\t\t \n\t\tif (parport_wait_peripheral (port,\n\t\t\t\t\t     PARPORT_STATUS_ACK,\n\t\t\t\t\t     PARPORT_STATUS_ACK)) {\n\t\t\t \n\t\t\tpr_debug(\"%s: Byte timeout at event 11\\n\", port->name);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tparport_frob_control (port,\n\t\t\t\t      PARPORT_CONTROL_STROBE,\n\t\t\t\t      PARPORT_CONTROL_STROBE);\n\t\tudelay (5);\n\n\t\t \n\t\tparport_frob_control (port, PARPORT_CONTROL_STROBE, 0);\n\t}\n\n\tif (count == len) {\n\t\t \n\t\tif (parport_read_status (port) & PARPORT_STATUS_ERROR) {\n\t\tend_of_data:\n\t\t\tpr_debug(\"%s: No more byte data (%zd bytes)\\n\",\n\t\t\t\t port->name, count);\n\n\t\t\t \n\t\t\tparport_frob_control (port,\n\t\t\t\t\t      PARPORT_CONTROL_AUTOFD,\n\t\t\t\t\t      PARPORT_CONTROL_AUTOFD);\n\t\t\tport->physport->ieee1284.phase = IEEE1284_PH_REV_IDLE;\n\t\t}\n\t\telse\n\t\t\tport->physport->ieee1284.phase = IEEE1284_PH_HBUSY_DAVAIL;\n\t}\n\n\treturn count;\n#endif  \n}\n\n \n\n#ifdef CONFIG_PARPORT_1284\n\nstatic inline\nint ecp_forward_to_reverse (struct parport *port)\n{\n\tint retval;\n\n\t \n\tparport_frob_control (port,\n\t\t\t      PARPORT_CONTROL_AUTOFD,\n\t\t\t      PARPORT_CONTROL_AUTOFD);\n\tparport_data_reverse (port);\n\tudelay (5);\n\n\t \n\tparport_frob_control (port,\n\t\t\t      PARPORT_CONTROL_INIT,\n\t\t\t      0);\n\n\t \n\tretval = parport_wait_peripheral (port,\n\t\t\t\t\t  PARPORT_STATUS_PAPEROUT, 0);\n\n\tif (!retval) {\n\t\tpr_debug(\"%s: ECP direction: reverse\\n\", port->name);\n\t\tport->ieee1284.phase = IEEE1284_PH_REV_IDLE;\n\t} else {\n\t\tpr_debug(\"%s: ECP direction: failed to reverse\\n\", port->name);\n\t\tport->ieee1284.phase = IEEE1284_PH_ECP_DIR_UNKNOWN;\n\t}\n\n\treturn retval;\n}\n\nstatic inline\nint ecp_reverse_to_forward (struct parport *port)\n{\n\tint retval;\n\n\t \n\tparport_frob_control (port,\n\t\t\t      PARPORT_CONTROL_INIT\n\t\t\t      | PARPORT_CONTROL_AUTOFD,\n\t\t\t      PARPORT_CONTROL_INIT\n\t\t\t      | PARPORT_CONTROL_AUTOFD);\n\n\t \n\tretval = parport_wait_peripheral (port,\n\t\t\t\t\t  PARPORT_STATUS_PAPEROUT,\n\t\t\t\t\t  PARPORT_STATUS_PAPEROUT);\n\n\tif (!retval) {\n\t\tparport_data_forward (port);\n\t\tpr_debug(\"%s: ECP direction: forward\\n\", port->name);\n\t\tport->ieee1284.phase = IEEE1284_PH_FWD_IDLE;\n\t} else {\n\t\tpr_debug(\"%s: ECP direction: failed to switch forward\\n\",\n\t\t\t port->name);\n\t\tport->ieee1284.phase = IEEE1284_PH_ECP_DIR_UNKNOWN;\n\t}\n\n\n\treturn retval;\n}\n\n#endif  \n\n \nsize_t parport_ieee1284_ecp_write_data (struct parport *port,\n\t\t\t\t\tconst void *buffer, size_t len,\n\t\t\t\t\tint flags)\n{\n#ifndef CONFIG_PARPORT_1284\n\treturn 0;\n#else\n\tconst unsigned char *buf = buffer;\n\tsize_t written;\n\tint retry;\n\n\tport = port->physport;\n\n\tif (port->ieee1284.phase != IEEE1284_PH_FWD_IDLE)\n\t\tif (ecp_reverse_to_forward (port))\n\t\t\treturn 0;\n\n\tport->ieee1284.phase = IEEE1284_PH_FWD_DATA;\n\n\t \n\tparport_frob_control (port,\n\t\t\t      PARPORT_CONTROL_AUTOFD\n\t\t\t      | PARPORT_CONTROL_STROBE\n\t\t\t      | PARPORT_CONTROL_INIT,\n\t\t\t      PARPORT_CONTROL_INIT);\n\tfor (written = 0; written < len; written++, buf++) {\n\t\tunsigned long expire = jiffies + port->cad->timeout;\n\t\tunsigned char byte;\n\n\t\tbyte = *buf;\n\ttry_again:\n\t\tparport_write_data (port, byte);\n\t\tparport_frob_control (port, PARPORT_CONTROL_STROBE,\n\t\t\t\t      PARPORT_CONTROL_STROBE);\n\t\tudelay (5);\n\t\tfor (retry = 0; retry < 100; retry++) {\n\t\t\tif (!parport_wait_peripheral (port,\n\t\t\t\t\t\t      PARPORT_STATUS_BUSY, 0))\n\t\t\t\tgoto success;\n\n\t\t\tif (signal_pending (current)) {\n\t\t\t\tparport_frob_control (port,\n\t\t\t\t\t\t      PARPORT_CONTROL_STROBE,\n\t\t\t\t\t\t      0);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tpr_debug(\"%s: ECP transfer stalled!\\n\", port->name);\n\n\t\tparport_frob_control (port, PARPORT_CONTROL_INIT,\n\t\t\t\t      PARPORT_CONTROL_INIT);\n\t\tudelay (50);\n\t\tif (parport_read_status (port) & PARPORT_STATUS_PAPEROUT) {\n\t\t\t \n\t\t\tparport_frob_control (port, PARPORT_CONTROL_INIT, 0);\n\t\t\tbreak;\n\t\t}\n\n\t\tparport_frob_control (port, PARPORT_CONTROL_INIT, 0);\n\t\tudelay (50);\n\t\tif (!(parport_read_status (port) & PARPORT_STATUS_PAPEROUT))\n\t\t\tbreak;\n\n\t\tpr_debug(\"%s: Host transfer recovered\\n\", port->name);\n\n\t\tif (time_after_eq (jiffies, expire)) break;\n\t\tgoto try_again;\n\tsuccess:\n\t\tparport_frob_control (port, PARPORT_CONTROL_STROBE, 0);\n\t\tudelay (5);\n\t\tif (parport_wait_peripheral (port,\n\t\t\t\t\t     PARPORT_STATUS_BUSY,\n\t\t\t\t\t     PARPORT_STATUS_BUSY))\n\t\t\t \n\t\t\tbreak;\n\t}\n\n\tport->ieee1284.phase = IEEE1284_PH_FWD_IDLE;\n\n\treturn written;\n#endif  \n}\n\n \nsize_t parport_ieee1284_ecp_read_data (struct parport *port,\n\t\t\t\t       void *buffer, size_t len, int flags)\n{\n#ifndef CONFIG_PARPORT_1284\n\treturn 0;\n#else\n\tstruct pardevice *dev = port->cad;\n\tunsigned char *buf = buffer;\n\tint rle_count = 0;  \n\tunsigned char ctl;\n\tint rle = 0;\n\tssize_t count = 0;\n\n\tport = port->physport;\n\n\tif (port->ieee1284.phase != IEEE1284_PH_REV_IDLE)\n\t\tif (ecp_forward_to_reverse (port))\n\t\t\treturn 0;\n\n\tport->ieee1284.phase = IEEE1284_PH_REV_DATA;\n\n\t \n\tctl = parport_read_control (port);\n\tctl &= ~(PARPORT_CONTROL_STROBE | PARPORT_CONTROL_INIT |\n\t\t PARPORT_CONTROL_AUTOFD);\n\tparport_write_control (port,\n\t\t\t       ctl | PARPORT_CONTROL_AUTOFD);\n\twhile (count < len) {\n\t\tunsigned long expire = jiffies + dev->timeout;\n\t\tunsigned char byte;\n\t\tint command;\n\n\t\t \n\t\twhile (parport_wait_peripheral (port, PARPORT_STATUS_ACK, 0)) {\n\t\t\t \n\t\t\tif (count)\n\t\t\t\tgoto out;\n\n\t\t\t \n\t\t\tif (!time_before (jiffies, expire))\n\t\t\t\tgoto out;\n\n\t\t\t \n\t\t\tif (dev->port->irq != PARPORT_IRQ_NONE) {\n\t\t\t\tparport_release (dev);\n\t\t\t\tschedule_timeout_interruptible(msecs_to_jiffies(40));\n\t\t\t\tparport_claim_or_block (dev);\n\t\t\t}\n\t\t\telse\n\t\t\t\t \n\t\t\t\tparport_wait_event (port, msecs_to_jiffies(40));\n\n\t\t\t \n\t\t\tif (signal_pending (current))\n\t\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tif (rle)\n\t\t\t \n\t\t\tcommand = 0;\n\t\telse\n\t\t\tcommand = (parport_read_status (port) &\n\t\t\t\t   PARPORT_STATUS_BUSY) ? 1 : 0;\n\n\t\t \n\t\tbyte = parport_read_data (port);\n\n\t\t \n\t\tif (command) {\n\t\t\tif (byte & 0x80) {\n\t\t\t\tpr_debug(\"%s: stopping short at channel command (%02x)\\n\",\n\t\t\t\t\t port->name, byte);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\telse if (port->ieee1284.mode != IEEE1284_MODE_ECPRLE)\n\t\t\t\tpr_debug(\"%s: device illegally using RLE; accepting anyway\\n\",\n\t\t\t\t\t port->name);\n\n\t\t\trle_count = byte + 1;\n\n\t\t\t \n\t\t\tif (rle_count > (len - count)) {\n\t\t\t\tpr_debug(\"%s: leaving %d RLE bytes for next time\\n\",\n\t\t\t\t\t port->name, rle_count);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\trle = 1;\n\t\t}\n\n\t\t \n\t\tparport_write_control (port, ctl);\n\n\t\t \n\t\tif (parport_wait_peripheral (port, PARPORT_STATUS_ACK,\n\t\t\t\t\t     PARPORT_STATUS_ACK)) {\n\t\t\t \n\t\t\tpr_debug(\"ECP read timed out at 45\\n\");\n\n\t\t\tif (command)\n\t\t\t\tpr_warn(\"%s: command ignored (%02x)\\n\",\n\t\t\t\t\tport->name, byte);\n\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tparport_write_control (port,\n\t\t\t\t       ctl | PARPORT_CONTROL_AUTOFD);\n\n\t\t \n\t\tif (command)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (rle) {\n\t\t\trle = 0;\n\t\t\tmemset (buf, byte, rle_count);\n\t\t\tbuf += rle_count;\n\t\t\tcount += rle_count;\n\t\t\tpr_debug(\"%s: decompressed to %d bytes\\n\",\n\t\t\t\t port->name, rle_count);\n\t\t} else {\n\t\t\t \n\t\t\t*buf = byte;\n\t\t\tbuf++, count++;\n\t\t}\n\t}\n\n out:\n\tport->ieee1284.phase = IEEE1284_PH_REV_IDLE;\n\treturn count;\n#endif  \n}\n\n \nsize_t parport_ieee1284_ecp_write_addr (struct parport *port,\n\t\t\t\t\tconst void *buffer, size_t len,\n\t\t\t\t\tint flags)\n{\n#ifndef CONFIG_PARPORT_1284\n\treturn 0;\n#else\n\tconst unsigned char *buf = buffer;\n\tsize_t written;\n\tint retry;\n\n\tport = port->physport;\n\n\tif (port->ieee1284.phase != IEEE1284_PH_FWD_IDLE)\n\t\tif (ecp_reverse_to_forward (port))\n\t\t\treturn 0;\n\n\tport->ieee1284.phase = IEEE1284_PH_FWD_DATA;\n\n\t \n\tparport_frob_control (port,\n\t\t\t      PARPORT_CONTROL_AUTOFD\n\t\t\t      | PARPORT_CONTROL_STROBE\n\t\t\t      | PARPORT_CONTROL_INIT,\n\t\t\t      PARPORT_CONTROL_AUTOFD\n\t\t\t      | PARPORT_CONTROL_INIT);\n\tfor (written = 0; written < len; written++, buf++) {\n\t\tunsigned long expire = jiffies + port->cad->timeout;\n\t\tunsigned char byte;\n\n\t\tbyte = *buf;\n\ttry_again:\n\t\tparport_write_data (port, byte);\n\t\tparport_frob_control (port, PARPORT_CONTROL_STROBE,\n\t\t\t\t      PARPORT_CONTROL_STROBE);\n\t\tudelay (5);\n\t\tfor (retry = 0; retry < 100; retry++) {\n\t\t\tif (!parport_wait_peripheral (port,\n\t\t\t\t\t\t      PARPORT_STATUS_BUSY, 0))\n\t\t\t\tgoto success;\n\n\t\t\tif (signal_pending (current)) {\n\t\t\t\tparport_frob_control (port,\n\t\t\t\t\t\t      PARPORT_CONTROL_STROBE,\n\t\t\t\t\t\t      0);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tpr_debug(\"%s: ECP transfer stalled!\\n\", port->name);\n\n\t\tparport_frob_control (port, PARPORT_CONTROL_INIT,\n\t\t\t\t      PARPORT_CONTROL_INIT);\n\t\tudelay (50);\n\t\tif (parport_read_status (port) & PARPORT_STATUS_PAPEROUT) {\n\t\t\t \n\t\t\tparport_frob_control (port, PARPORT_CONTROL_INIT, 0);\n\t\t\tbreak;\n\t\t}\n\n\t\tparport_frob_control (port, PARPORT_CONTROL_INIT, 0);\n\t\tudelay (50);\n\t\tif (!(parport_read_status (port) & PARPORT_STATUS_PAPEROUT))\n\t\t\tbreak;\n\n\t\tpr_debug(\"%s: Host transfer recovered\\n\", port->name);\n\n\t\tif (time_after_eq (jiffies, expire)) break;\n\t\tgoto try_again;\n\tsuccess:\n\t\tparport_frob_control (port, PARPORT_CONTROL_STROBE, 0);\n\t\tudelay (5);\n\t\tif (parport_wait_peripheral (port,\n\t\t\t\t\t     PARPORT_STATUS_BUSY,\n\t\t\t\t\t     PARPORT_STATUS_BUSY))\n\t\t\t \n\t\t\tbreak;\n\t}\n\n\tport->ieee1284.phase = IEEE1284_PH_FWD_IDLE;\n\n\treturn written;\n#endif  \n}\n\n \n\n \nsize_t parport_ieee1284_epp_write_data (struct parport *port,\n\t\t\t\t\tconst void *buffer, size_t len,\n\t\t\t\t\tint flags)\n{\n\tunsigned char *bp = (unsigned char *) buffer;\n\tsize_t ret = 0;\n\n\t \n\tparport_frob_control (port,\n\t\t\t      PARPORT_CONTROL_STROBE |\n\t\t\t      PARPORT_CONTROL_AUTOFD |\n\t\t\t      PARPORT_CONTROL_SELECT |\n\t\t\t      PARPORT_CONTROL_INIT,\n\t\t\t      PARPORT_CONTROL_STROBE |\n\t\t\t      PARPORT_CONTROL_INIT);\n\tport->ops->data_forward (port);\n\tfor (; len > 0; len--, bp++) {\n\t\t \n\t\tparport_write_data (port, *bp);\n\t\tparport_frob_control (port, PARPORT_CONTROL_AUTOFD,\n\t\t\t\t      PARPORT_CONTROL_AUTOFD);\n\n\t\t \n\t\tif (parport_poll_peripheral (port, PARPORT_STATUS_BUSY, 0, 10))\n\t\t\tbreak;\n\n\t\t \n\t\tparport_frob_control (port, PARPORT_CONTROL_AUTOFD, 0);\n\n\t\t \n\t\tif (parport_poll_peripheral (port, PARPORT_STATUS_BUSY,\n\t\t\t\t\t     PARPORT_STATUS_BUSY, 5))\n\t\t\tbreak;\n\n\t\tret++;\n\t}\n\n\t \n\tparport_frob_control (port, PARPORT_CONTROL_STROBE, 0);\n\n\treturn ret;\n}\n\n \nsize_t parport_ieee1284_epp_read_data (struct parport *port,\n\t\t\t\t       void *buffer, size_t len,\n\t\t\t\t       int flags)\n{\n\tunsigned char *bp = (unsigned char *) buffer;\n\tunsigned ret = 0;\n\n\t \n\tparport_frob_control (port,\n\t\t\t      PARPORT_CONTROL_STROBE |\n\t\t\t      PARPORT_CONTROL_AUTOFD |\n\t\t\t      PARPORT_CONTROL_SELECT |\n\t\t\t      PARPORT_CONTROL_INIT,\n\t\t\t      PARPORT_CONTROL_INIT);\n\tport->ops->data_reverse (port);\n\tfor (; len > 0; len--, bp++) {\n\t\t \n\t\tparport_frob_control (port,\n\t\t\t\t      PARPORT_CONTROL_AUTOFD,\n\t\t\t\t      PARPORT_CONTROL_AUTOFD);\n\t\t \n\t\tif (parport_wait_peripheral (port, PARPORT_STATUS_BUSY, 0)) {\n\t\t\tbreak;\n\t\t}\n\n\t\t*bp = parport_read_data (port);\n\n\t\t \n\t\tparport_frob_control (port, PARPORT_CONTROL_AUTOFD, 0);\n\n\t\t \n\t\tif (parport_poll_peripheral (port, PARPORT_STATUS_BUSY,\n\t\t\t\t\t     PARPORT_STATUS_BUSY, 5)) {\n\t\t\tbreak;\n\t\t}\n\n\t\tret++;\n\t}\n\tport->ops->data_forward (port);\n\n\treturn ret;\n}\n\n \nsize_t parport_ieee1284_epp_write_addr (struct parport *port,\n\t\t\t\t\tconst void *buffer, size_t len,\n\t\t\t\t\tint flags)\n{\n\tunsigned char *bp = (unsigned char *) buffer;\n\tsize_t ret = 0;\n\n\t \n\tparport_frob_control (port,\n\t\t\t      PARPORT_CONTROL_STROBE |\n\t\t\t      PARPORT_CONTROL_AUTOFD |\n\t\t\t      PARPORT_CONTROL_SELECT |\n\t\t\t      PARPORT_CONTROL_INIT,\n\t\t\t      PARPORT_CONTROL_STROBE |\n\t\t\t      PARPORT_CONTROL_INIT);\n\tport->ops->data_forward (port);\n\tfor (; len > 0; len--, bp++) {\n\t\t \n\t\tparport_write_data (port, *bp);\n\t\tparport_frob_control (port, PARPORT_CONTROL_SELECT,\n\t\t\t\t      PARPORT_CONTROL_SELECT);\n\n\t\t \n\t\tif (parport_poll_peripheral (port, PARPORT_STATUS_BUSY, 0, 10))\n\t\t\tbreak;\n\n\t\t \n\t\tparport_frob_control (port, PARPORT_CONTROL_SELECT, 0);\n\n\t\t \n\t\tif (parport_poll_peripheral (port, PARPORT_STATUS_BUSY,\n\t\t\t\t\t     PARPORT_STATUS_BUSY, 5))\n\t\t\tbreak;\n\n\t\tret++;\n\t}\n\n\t \n\tparport_frob_control (port, PARPORT_CONTROL_STROBE, 0);\n\n\treturn ret;\n}\n\n \nsize_t parport_ieee1284_epp_read_addr (struct parport *port,\n\t\t\t\t       void *buffer, size_t len,\n\t\t\t\t       int flags)\n{\n\tunsigned char *bp = (unsigned char *) buffer;\n\tunsigned ret = 0;\n\n\t \n\tparport_frob_control (port,\n\t\t\t      PARPORT_CONTROL_STROBE |\n\t\t\t      PARPORT_CONTROL_AUTOFD |\n\t\t\t      PARPORT_CONTROL_SELECT |\n\t\t\t      PARPORT_CONTROL_INIT,\n\t\t\t      PARPORT_CONTROL_INIT);\n\tport->ops->data_reverse (port);\n\tfor (; len > 0; len--, bp++) {\n\t\t \n\t\tparport_frob_control (port, PARPORT_CONTROL_SELECT,\n\t\t\t\t      PARPORT_CONTROL_SELECT);\n\n\t\t \n\t\tif (parport_wait_peripheral (port, PARPORT_STATUS_BUSY, 0)) {\n\t\t\tbreak;\n\t\t}\n\n\t\t*bp = parport_read_data (port);\n\n\t\t \n\t\tparport_frob_control (port, PARPORT_CONTROL_SELECT,\n\t\t\t\t      0);\n\n\t\t \n\t\tif (parport_poll_peripheral (port, PARPORT_STATUS_BUSY, \n\t\t\t\t\t     PARPORT_STATUS_BUSY, 5))\n\t\t\tbreak;\n\n\t\tret++;\n\t}\n\tport->ops->data_forward (port);\n\n\treturn ret;\n}\n\nEXPORT_SYMBOL(parport_ieee1284_ecp_write_data);\nEXPORT_SYMBOL(parport_ieee1284_ecp_read_data);\nEXPORT_SYMBOL(parport_ieee1284_ecp_write_addr);\nEXPORT_SYMBOL(parport_ieee1284_write_compat);\nEXPORT_SYMBOL(parport_ieee1284_read_nibble);\nEXPORT_SYMBOL(parport_ieee1284_read_byte);\nEXPORT_SYMBOL(parport_ieee1284_epp_write_data);\nEXPORT_SYMBOL(parport_ieee1284_epp_read_data);\nEXPORT_SYMBOL(parport_ieee1284_epp_write_addr);\nEXPORT_SYMBOL(parport_ieee1284_epp_read_addr);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}