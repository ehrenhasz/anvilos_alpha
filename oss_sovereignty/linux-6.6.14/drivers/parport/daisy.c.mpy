{
  "module_name": "daisy.c",
  "hash_id": "20214b5122eee80c902f706fff2d07b9ad9a79a46eeccfa1570800b277727a39",
  "original_prompt": "Ingested from linux-6.6.14/drivers/parport/daisy.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/parport.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n\n#include <asm/current.h>\n#include <linux/uaccess.h>\n\n#undef DEBUG\n\nstatic struct daisydev {\n\tstruct daisydev *next;\n\tstruct parport *port;\n\tint daisy;\n\tint devnum;\n} *topology = NULL;\nstatic DEFINE_SPINLOCK(topology_lock);\n\nstatic int numdevs;\nstatic bool daisy_init_done;\n\n \nstatic int mux_present(struct parport *port);\nstatic int num_mux_ports(struct parport *port);\nstatic int select_port(struct parport *port);\nstatic int assign_addrs(struct parport *port);\n\n \nstatic void add_dev(int devnum, struct parport *port, int daisy)\n{\n\tstruct daisydev *newdev, **p;\n\tnewdev = kmalloc(sizeof(struct daisydev), GFP_KERNEL);\n\tif (newdev) {\n\t\tnewdev->port = port;\n\t\tnewdev->daisy = daisy;\n\t\tnewdev->devnum = devnum;\n\t\tspin_lock(&topology_lock);\n\t\tfor (p = &topology; *p && (*p)->devnum<devnum; p = &(*p)->next)\n\t\t\t;\n\t\tnewdev->next = *p;\n\t\t*p = newdev;\n\t\tspin_unlock(&topology_lock);\n\t}\n}\n\n \nstatic struct parport *clone_parport(struct parport *real, int muxport)\n{\n\tstruct parport *extra = parport_register_port(real->base,\n\t\t\t\t\t\t       real->irq,\n\t\t\t\t\t\t       real->dma,\n\t\t\t\t\t\t       real->ops);\n\tif (extra) {\n\t\textra->portnum = real->portnum;\n\t\textra->physport = real;\n\t\textra->muxport = muxport;\n\t\treal->slaves[muxport-1] = extra;\n\t}\n\n\treturn extra;\n}\n\nstatic int daisy_drv_probe(struct pardevice *par_dev)\n{\n\tstruct device_driver *drv = par_dev->dev.driver;\n\n\tif (strcmp(drv->name, \"daisy_drv\"))\n\t\treturn -ENODEV;\n\tif (strcmp(par_dev->name, daisy_dev_name))\n\t\treturn -ENODEV;\n\n\treturn 0;\n}\n\nstatic struct parport_driver daisy_driver = {\n\t.name = \"daisy_drv\",\n\t.probe = daisy_drv_probe,\n\t.devmodel = true,\n};\n\n \nint parport_daisy_init(struct parport *port)\n{\n\tint detected = 0;\n\tchar *deviceid;\n\tstatic const char *th[] = {  \"th\", \"st\", \"nd\", \"rd\", \"th\" };\n\tint num_ports;\n\tint i;\n\tint last_try = 0;\n\n\tif (!daisy_init_done) {\n\t\t \n\t\tdaisy_init_done = true;\n\t\ti = parport_register_driver(&daisy_driver);\n\t\tif (i) {\n\t\t\tpr_err(\"daisy registration failed\\n\");\n\t\t\tdaisy_init_done = false;\n\t\t\treturn i;\n\t\t}\n\t}\n\nagain:\n\t \n\n\t \n\tif (port->muxport < 0 && mux_present(port) &&\n\t     \n\t    ((num_ports = num_mux_ports(port)) == 2 || num_ports == 4)) {\n\t\t \n\t\tport->muxport = 0;\n\t\tpr_info(\"%s: 1st (default) port of %d-way multiplexor\\n\",\n\t\t\tport->name, num_ports);\n\t\tfor (i = 1; i < num_ports; i++) {\n\t\t\t \n\t\t\tstruct parport *extra = clone_parport(port, i);\n\t\t\tif (!extra) {\n\t\t\t\tif (signal_pending(current))\n\t\t\t\t\tbreak;\n\n\t\t\t\tschedule();\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tpr_info(\"%s: %d%s port of %d-way multiplexor on %s\\n\",\n\t\t\t\textra->name, i + 1, th[i + 1], num_ports,\n\t\t\t\tport->name);\n\n\t\t\t \n\t\t\tparport_daisy_init(extra);\n\t\t}\n\t}\n\n\tif (port->muxport >= 0)\n\t\tselect_port(port);\n\n\tparport_daisy_deselect_all(port);\n\tdetected += assign_addrs(port);\n\n\t \n\tadd_dev(numdevs++, port, -1);\n\n\t \n\tdeviceid = kmalloc(1024, GFP_KERNEL);\n\tif (deviceid) {\n\t\tif (parport_device_id(numdevs - 1, deviceid, 1024) > 2)\n\t\t\tdetected++;\n\n\t\tkfree(deviceid);\n\t}\n\n\tif (!detected && !last_try) {\n\t\t \n\t\tparport_daisy_fini(port);\n\t\tparport_write_control(port, PARPORT_CONTROL_SELECT);\n\t\tudelay(50);\n\t\tparport_write_control(port,\n\t\t\t\t       PARPORT_CONTROL_SELECT |\n\t\t\t\t       PARPORT_CONTROL_INIT);\n\t\tudelay(50);\n\t\tlast_try = 1;\n\t\tgoto again;\n\t}\n\n\treturn detected;\n}\n\n \nvoid parport_daisy_fini(struct parport *port)\n{\n\tstruct daisydev **p;\n\n\tspin_lock(&topology_lock);\n\tp = &topology;\n\twhile (*p) {\n\t\tstruct daisydev *dev = *p;\n\t\tif (dev->port != port) {\n\t\t\tp = &dev->next;\n\t\t\tcontinue;\n\t\t}\n\t\t*p = dev->next;\n\t\tkfree(dev);\n\t}\n\n\t \n\tif (!topology) numdevs = 0;\n\tspin_unlock(&topology_lock);\n\treturn;\n}\n\n \n\nstruct pardevice *parport_open(int devnum, const char *name)\n{\n\tstruct daisydev *p = topology;\n\tstruct pardev_cb par_cb;\n\tstruct parport *port;\n\tstruct pardevice *dev;\n\tint daisy;\n\n\tmemset(&par_cb, 0, sizeof(par_cb));\n\tspin_lock(&topology_lock);\n\twhile (p && p->devnum != devnum)\n\t\tp = p->next;\n\n\tif (!p) {\n\t\tspin_unlock(&topology_lock);\n\t\treturn NULL;\n\t}\n\n\tdaisy = p->daisy;\n\tport = parport_get_port(p->port);\n\tspin_unlock(&topology_lock);\n\n\tdev = parport_register_dev_model(port, name, &par_cb, devnum);\n\tparport_put_port(port);\n\tif (!dev)\n\t\treturn NULL;\n\n\tdev->daisy = daisy;\n\n\t \n\tif (daisy >= 0) {\n\t\tint selected;\n\t\tparport_claim_or_block(dev);\n\t\tselected = port->daisy;\n\t\tparport_release(dev);\n\n\t\tif (selected != daisy) {\n\t\t\t \n\t\t\tparport_unregister_device(dev);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn dev;\n}\n\n \n\nvoid parport_close(struct pardevice *dev)\n{\n\tparport_unregister_device(dev);\n}\n\n \nstatic int cpp_daisy(struct parport *port, int cmd)\n{\n\tunsigned char s;\n\n\tparport_data_forward(port);\n\tparport_write_data(port, 0xaa); udelay(2);\n\tparport_write_data(port, 0x55); udelay(2);\n\tparport_write_data(port, 0x00); udelay(2);\n\tparport_write_data(port, 0xff); udelay(2);\n\ts = parport_read_status(port) & (PARPORT_STATUS_BUSY\n\t\t\t\t\t  | PARPORT_STATUS_PAPEROUT\n\t\t\t\t\t  | PARPORT_STATUS_SELECT\n\t\t\t\t\t  | PARPORT_STATUS_ERROR);\n\tif (s != (PARPORT_STATUS_BUSY\n\t\t  | PARPORT_STATUS_PAPEROUT\n\t\t  | PARPORT_STATUS_SELECT\n\t\t  | PARPORT_STATUS_ERROR)) {\n\t\tpr_debug(\"%s: cpp_daisy: aa5500ff(%02x)\\n\", port->name, s);\n\t\treturn -ENXIO;\n\t}\n\n\tparport_write_data(port, 0x87); udelay(2);\n\ts = parport_read_status(port) & (PARPORT_STATUS_BUSY\n\t\t\t\t\t  | PARPORT_STATUS_PAPEROUT\n\t\t\t\t\t  | PARPORT_STATUS_SELECT\n\t\t\t\t\t  | PARPORT_STATUS_ERROR);\n\tif (s != (PARPORT_STATUS_SELECT | PARPORT_STATUS_ERROR)) {\n\t\tpr_debug(\"%s: cpp_daisy: aa5500ff87(%02x)\\n\", port->name, s);\n\t\treturn -ENXIO;\n\t}\n\n\tparport_write_data(port, 0x78); udelay(2);\n\tparport_write_data(port, cmd); udelay(2);\n\tparport_frob_control(port,\n\t\t\t      PARPORT_CONTROL_STROBE,\n\t\t\t      PARPORT_CONTROL_STROBE);\n\tudelay(1);\n\ts = parport_read_status(port);\n\tparport_frob_control(port, PARPORT_CONTROL_STROBE, 0);\n\tudelay(1);\n\tparport_write_data(port, 0xff); udelay(2);\n\n\treturn s;\n}\n\n \nstatic int cpp_mux(struct parport *port, int cmd)\n{\n\tunsigned char s;\n\tint rc;\n\n\tparport_data_forward(port);\n\tparport_write_data(port, 0xaa); udelay(2);\n\tparport_write_data(port, 0x55); udelay(2);\n\tparport_write_data(port, 0xf0); udelay(2);\n\tparport_write_data(port, 0x0f); udelay(2);\n\tparport_write_data(port, 0x52); udelay(2);\n\tparport_write_data(port, 0xad); udelay(2);\n\tparport_write_data(port, cmd); udelay(2);\n\n\ts = parport_read_status(port);\n\tif (!(s & PARPORT_STATUS_ACK)) {\n\t\tpr_debug(\"%s: cpp_mux: aa55f00f52ad%02x(%02x)\\n\",\n\t\t\t port->name, cmd, s);\n\t\treturn -EIO;\n\t}\n\n\trc = (((s & PARPORT_STATUS_SELECT   ? 1 : 0) << 0) |\n\t      ((s & PARPORT_STATUS_PAPEROUT ? 1 : 0) << 1) |\n\t      ((s & PARPORT_STATUS_BUSY     ? 0 : 1) << 2) |\n\t      ((s & PARPORT_STATUS_ERROR    ? 0 : 1) << 3));\n\n\treturn rc;\n}\n\nvoid parport_daisy_deselect_all(struct parport *port)\n{\n\tcpp_daisy(port, 0x30);\n}\n\nint parport_daisy_select(struct parport *port, int daisy, int mode)\n{\n\tswitch (mode)\n\t{\n\t\t \n\t\tcase IEEE1284_MODE_EPP:\n\t\tcase IEEE1284_MODE_EPPSL:\n\t\tcase IEEE1284_MODE_EPPSWE:\n\t\t\treturn !(cpp_daisy(port, 0x20 + daisy) &\n\t\t\t\t PARPORT_STATUS_ERROR);\n\n\t\t \n\t\tcase IEEE1284_MODE_ECP:\n\t\tcase IEEE1284_MODE_ECPRLE:\n\t\tcase IEEE1284_MODE_ECPSWE: \n\t\t\treturn !(cpp_daisy(port, 0xd0 + daisy) &\n\t\t\t\t PARPORT_STATUS_ERROR);\n\n\t\t \n\t\t \n\t\tcase IEEE1284_MODE_BECP:\n\t\t\n\t\tcase IEEE1284_MODE_NIBBLE:\n\t\tcase IEEE1284_MODE_BYTE:\n\t\tcase IEEE1284_MODE_COMPAT:\n\t\tdefault:\n\t\t\treturn !(cpp_daisy(port, 0xe0 + daisy) &\n\t\t\t\t PARPORT_STATUS_ERROR);\n\t}\n}\n\nstatic int mux_present(struct parport *port)\n{\n\treturn cpp_mux(port, 0x51) == 3;\n}\n\nstatic int num_mux_ports(struct parport *port)\n{\n\treturn cpp_mux(port, 0x58);\n}\n\nstatic int select_port(struct parport *port)\n{\n\tint muxport = port->muxport;\n\treturn cpp_mux(port, 0x60 + muxport) == muxport;\n}\n\nstatic int assign_addrs(struct parport *port)\n{\n\tunsigned char s;\n\tunsigned char daisy;\n\tint thisdev = numdevs;\n\tint detected;\n\tchar *deviceid;\n\n\tparport_data_forward(port);\n\tparport_write_data(port, 0xaa); udelay(2);\n\tparport_write_data(port, 0x55); udelay(2);\n\tparport_write_data(port, 0x00); udelay(2);\n\tparport_write_data(port, 0xff); udelay(2);\n\ts = parport_read_status(port) & (PARPORT_STATUS_BUSY\n\t\t\t\t\t  | PARPORT_STATUS_PAPEROUT\n\t\t\t\t\t  | PARPORT_STATUS_SELECT\n\t\t\t\t\t  | PARPORT_STATUS_ERROR);\n\tif (s != (PARPORT_STATUS_BUSY\n\t\t  | PARPORT_STATUS_PAPEROUT\n\t\t  | PARPORT_STATUS_SELECT\n\t\t  | PARPORT_STATUS_ERROR)) {\n\t\tpr_debug(\"%s: assign_addrs: aa5500ff(%02x)\\n\", port->name, s);\n\t\treturn 0;\n\t}\n\n\tparport_write_data(port, 0x87); udelay(2);\n\ts = parport_read_status(port) & (PARPORT_STATUS_BUSY\n\t\t\t\t\t  | PARPORT_STATUS_PAPEROUT\n\t\t\t\t\t  | PARPORT_STATUS_SELECT\n\t\t\t\t\t  | PARPORT_STATUS_ERROR);\n\tif (s != (PARPORT_STATUS_SELECT | PARPORT_STATUS_ERROR)) {\n\t\tpr_debug(\"%s: assign_addrs: aa5500ff87(%02x)\\n\", port->name, s);\n\t\treturn 0;\n\t}\n\n\tparport_write_data(port, 0x78); udelay(2);\n\ts = parport_read_status(port);\n\n\tfor (daisy = 0;\n\t     (s & (PARPORT_STATUS_PAPEROUT|PARPORT_STATUS_SELECT))\n\t\t     == (PARPORT_STATUS_PAPEROUT|PARPORT_STATUS_SELECT)\n\t\t     && daisy < 4;\n\t     ++daisy) {\n\t\tparport_write_data(port, daisy);\n\t\tudelay(2);\n\t\tparport_frob_control(port,\n\t\t\t\t      PARPORT_CONTROL_STROBE,\n\t\t\t\t      PARPORT_CONTROL_STROBE);\n\t\tudelay(1);\n\t\tparport_frob_control(port, PARPORT_CONTROL_STROBE, 0);\n\t\tudelay(1);\n\n\t\tadd_dev(numdevs++, port, daisy);\n\n\t\t \n\t\tif (!(s & PARPORT_STATUS_BUSY))\n\t\t\tbreak;\n\n\t\t \n\t\ts = parport_read_status(port);\n\t}\n\n\tparport_write_data(port, 0xff); udelay(2);\n\tdetected = numdevs - thisdev;\n\tpr_debug(\"%s: Found %d daisy-chained devices\\n\", port->name, detected);\n\n\t \n\tdeviceid = kmalloc(1024, GFP_KERNEL);\n\tif (!deviceid) return 0;\n\n\tfor (daisy = 0; thisdev < numdevs; thisdev++, daisy++)\n\t\tparport_device_id(thisdev, deviceid, 1024);\n\n\tkfree(deviceid);\n\treturn detected;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}