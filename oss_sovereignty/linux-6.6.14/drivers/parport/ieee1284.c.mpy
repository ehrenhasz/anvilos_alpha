{
  "module_name": "ieee1284.c",
  "hash_id": "d8a473abbe5841227153cf08a4e8b28318f565e3055b4590c2993a107ca5fd05",
  "original_prompt": "Ingested from linux-6.6.14/drivers/parport/ieee1284.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/threads.h>\n#include <linux/parport.h>\n#include <linux/delay.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/timer.h>\n#include <linux/sched/signal.h>\n\n#undef DEBUG  \n\n#ifdef CONFIG_LP_CONSOLE\n#undef DEBUG  \n#endif\n\n \nstatic void parport_ieee1284_wakeup (struct parport *port)\n{\n\tup (&port->physport->ieee1284.irq);\n}\n\nstatic void timeout_waiting_on_port (struct timer_list *t)\n{\n\tstruct parport *port = from_timer(port, t, timer);\n\n\tparport_ieee1284_wakeup (port);\n}\n\n \n\nint parport_wait_event (struct parport *port, signed long timeout)\n{\n\tint ret;\n\n\tif (!port->physport->cad->timeout)\n\t\t \n\t\treturn 1;\n\n\ttimer_setup(&port->timer, timeout_waiting_on_port, 0);\n\tmod_timer(&port->timer, jiffies + timeout);\n\tret = down_interruptible (&port->physport->ieee1284.irq);\n\tif (!del_timer_sync(&port->timer) && !ret)\n\t\t \n\t\tret = 1;\n\n\treturn ret;\n}\n\n \n\nint parport_poll_peripheral(struct parport *port,\n\t\t\t    unsigned char mask,\n\t\t\t    unsigned char result,\n\t\t\t    int usec)\n{\n\t \n\tint count = usec / 5 + 2;\n\tint i;\n\tunsigned char status;\n\tfor (i = 0; i < count; i++) {\n\t\tstatus = parport_read_status (port);\n\t\tif ((status & mask) == result)\n\t\t\treturn 0;\n\t\tif (signal_pending (current))\n\t\t\treturn -EINTR;\n\t\tif (need_resched())\n\t\t\tbreak;\n\t\tif (i >= 2)\n\t\t\tudelay (5);\n\t}\n\n\treturn 1;\n}\n\n \n\nint parport_wait_peripheral(struct parport *port,\n\t\t\t    unsigned char mask, \n\t\t\t    unsigned char result)\n{\n\tint ret;\n\tint usec;\n\tunsigned long deadline;\n\tunsigned char status;\n\n\tusec = port->physport->spintime;  \n\tif (!port->physport->cad->timeout)\n\t\t \n\t\tusec = 35000;\n\n\t \n\tret = parport_poll_peripheral (port, mask, result, usec);\n\tif (ret != 1)\n\t\treturn ret;\n\n\tif (!port->physport->cad->timeout)\n\t\t \n\t\treturn 1;\n\n\t \n\tdeadline = jiffies + msecs_to_jiffies(40);\n\twhile (time_before (jiffies, deadline)) {\n\t\tif (signal_pending (current))\n\t\t\treturn -EINTR;\n\n\t\t \n\t\tif ((ret = parport_wait_event (port, msecs_to_jiffies(10))) < 0)\n\t\t\treturn ret;\n\n\t\tstatus = parport_read_status (port);\n\t\tif ((status & mask) == result)\n\t\t\treturn 0;\n\n\t\tif (!ret) {\n\t\t\t \n\t\t\tschedule_timeout_interruptible(msecs_to_jiffies(10));\n\t\t}\n\t}\n\n\treturn 1;\n}\n\n#ifdef CONFIG_PARPORT_1284\n \nstatic void parport_ieee1284_terminate (struct parport *port)\n{\n\tint r;\n\tport = port->physport;\n\n\t \n\tswitch (port->ieee1284.mode) {\n\tcase IEEE1284_MODE_EPP:\n\tcase IEEE1284_MODE_EPPSL:\n\tcase IEEE1284_MODE_EPPSWE:\n\t\t \n\n\t\t \n\t\tparport_frob_control (port, PARPORT_CONTROL_INIT, 0);\n\t\tudelay (50);\n\n\t\t \n\t\tparport_frob_control (port,\n\t\t\t\t      PARPORT_CONTROL_SELECT\n\t\t\t\t      | PARPORT_CONTROL_INIT,\n\t\t\t\t      PARPORT_CONTROL_SELECT\n\t\t\t\t      | PARPORT_CONTROL_INIT);\n\t\tbreak;\n\n\tcase IEEE1284_MODE_ECP:\n\tcase IEEE1284_MODE_ECPRLE:\n\tcase IEEE1284_MODE_ECPSWE:\n\t\t \n\t\tif (port->ieee1284.phase != IEEE1284_PH_FWD_IDLE) {\n\t\t\t \n\t\t\tparport_frob_control (port,\n\t\t\t\t\t      PARPORT_CONTROL_INIT\n\t\t\t\t\t      | PARPORT_CONTROL_AUTOFD,\n\t\t\t\t\t      PARPORT_CONTROL_INIT\n\t\t\t\t\t      | PARPORT_CONTROL_AUTOFD);\n\n\t\t\t \n\t\t\tr = parport_wait_peripheral (port,\n\t\t\t\t\t\t     PARPORT_STATUS_PAPEROUT,\n\t\t\t\t\t\t     PARPORT_STATUS_PAPEROUT);\n\t\t\tif (r)\n\t\t\t\tpr_debug(\"%s: Timeout at event 49\\n\",\n\t\t\t\t\t port->name);\n\n\t\t\tparport_data_forward (port);\n\t\t\tpr_debug(\"%s: ECP direction: forward\\n\", port->name);\n\t\t\tport->ieee1284.phase = IEEE1284_PH_FWD_IDLE;\n\t\t}\n\n\t\tfallthrough;\n\n\tdefault:\n\t\t \n\n\t\t \n\t\tparport_frob_control (port,\n\t\t\t\t      PARPORT_CONTROL_SELECT\n\t\t\t\t      | PARPORT_CONTROL_AUTOFD,\n\t\t\t\t      PARPORT_CONTROL_SELECT);\n\n\t\t \n\t\tr = parport_wait_peripheral (port, PARPORT_STATUS_ACK, 0);\n\t\tif (r)\n\t\t\tpr_debug(\"%s: Timeout at event 24\\n\", port->name);\n\n\t\t \n\t\tparport_frob_control (port,\n\t\t\t\t      PARPORT_CONTROL_AUTOFD,\n\t\t\t\t      PARPORT_CONTROL_AUTOFD);\n\n\t\t \n\t\tr = parport_wait_peripheral (port,\n\t\t\t\t\t     PARPORT_STATUS_ACK, \n\t\t\t\t\t     PARPORT_STATUS_ACK);\n\t\tif (r)\n\t\t\tpr_debug(\"%s: Timeout at event 27\\n\", port->name);\n\n\t\t \n\t\tparport_frob_control (port, PARPORT_CONTROL_AUTOFD, 0);\n\t}\n\n\tport->ieee1284.mode = IEEE1284_MODE_COMPAT;\n\tport->ieee1284.phase = IEEE1284_PH_FWD_IDLE;\n\n\tpr_debug(\"%s: In compatibility (forward idle) mode\\n\", port->name);\n}\t\t\n#endif  \n\n \n\nint parport_negotiate (struct parport *port, int mode)\n{\n#ifndef CONFIG_PARPORT_1284\n\tif (mode == IEEE1284_MODE_COMPAT)\n\t\treturn 0;\n\tpr_err(\"parport: IEEE1284 not supported in this kernel\\n\");\n\treturn -1;\n#else\n\tint m = mode & ~IEEE1284_ADDR;\n\tint r;\n\tunsigned char xflag;\n\n\tport = port->physport;\n\n\t \n\tif (port->ieee1284.mode == mode)\n\t\treturn 0;\n\n\t \n\tif ((port->ieee1284.mode & ~IEEE1284_ADDR) == (mode & ~IEEE1284_ADDR)){\n\t\tport->ieee1284.mode = mode;\n\t\treturn 0;\n\t}\n\n\t \n\tif (port->ieee1284.mode != IEEE1284_MODE_COMPAT)\n\t\tparport_ieee1284_terminate (port);\n\n\tif (mode == IEEE1284_MODE_COMPAT)\n\t\t \n\t\treturn 0; \n\n\tswitch (mode) {\n\tcase IEEE1284_MODE_ECPSWE:\n\t\tm = IEEE1284_MODE_ECP;\n\t\tbreak;\n\tcase IEEE1284_MODE_EPPSL:\n\tcase IEEE1284_MODE_EPPSWE:\n\t\tm = IEEE1284_MODE_EPP;\n\t\tbreak;\n\tcase IEEE1284_MODE_BECP:\n\t\treturn -ENOSYS;  \n\t}\n\n\tif (mode & IEEE1284_EXT_LINK)\n\t\tm = 1<<7;  \n\n\tport->ieee1284.phase = IEEE1284_PH_NEGOTIATION;\n\n\t \n\tparport_frob_control (port,\n\t\t\t      PARPORT_CONTROL_STROBE\n\t\t\t      | PARPORT_CONTROL_AUTOFD\n\t\t\t      | PARPORT_CONTROL_SELECT,\n\t\t\t      PARPORT_CONTROL_SELECT);\n\tudelay(1);\n\n\t \n\tparport_data_forward (port);\n\tparport_write_data (port, m);\n\tudelay (400);  \n\n\t \n\tparport_frob_control (port,\n\t\t\t      PARPORT_CONTROL_SELECT\n\t\t\t      | PARPORT_CONTROL_AUTOFD,\n\t\t\t      PARPORT_CONTROL_AUTOFD);\n\n\t \n\tif (parport_wait_peripheral (port,\n\t\t\t\t     PARPORT_STATUS_ERROR\n\t\t\t\t     | PARPORT_STATUS_SELECT\n\t\t\t\t     | PARPORT_STATUS_PAPEROUT\n\t\t\t\t     | PARPORT_STATUS_ACK,\n\t\t\t\t     PARPORT_STATUS_ERROR\n\t\t\t\t     | PARPORT_STATUS_SELECT\n\t\t\t\t     | PARPORT_STATUS_PAPEROUT)) {\n\t\t \n\t\tparport_frob_control (port,\n\t\t\t\t      PARPORT_CONTROL_SELECT\n\t\t\t\t      | PARPORT_CONTROL_AUTOFD,\n\t\t\t\t      PARPORT_CONTROL_SELECT);\n\t\tpr_debug(\"%s: Peripheral not IEEE1284 compliant (0x%02X)\\n\",\n\t\t\t port->name, parport_read_status (port));\n\t\tport->ieee1284.phase = IEEE1284_PH_FWD_IDLE;\n\t\treturn -1;  \n\t}\n\n\t \n\tparport_frob_control (port,\n\t\t\t      PARPORT_CONTROL_STROBE,\n\t\t\t      PARPORT_CONTROL_STROBE);\n\n\t \n\tudelay (5);\n\tparport_frob_control (port,\n\t\t\t      PARPORT_CONTROL_STROBE\n\t\t\t      | PARPORT_CONTROL_AUTOFD,\n\t\t\t      0);\n\n\t \n\tif (parport_wait_peripheral (port,\n\t\t\t\t     PARPORT_STATUS_ACK,\n\t\t\t\t     PARPORT_STATUS_ACK)) {\n\t\t \n\t\tpr_debug(\"%s: Mode 0x%02x not supported? (0x%02x)\\n\",\n\t\t\t port->name, mode, port->ops->read_status (port));\n\t\tparport_ieee1284_terminate (port);\n\t\treturn 1;\n\t}\n\n\txflag = parport_read_status (port) & PARPORT_STATUS_SELECT;\n\n\t \n\tif (mode && !xflag) {\n\t\t \n\t\tpr_debug(\"%s: Mode 0x%02x rejected by peripheral\\n\",\n\t\t\t port->name, mode);\n\t\tparport_ieee1284_terminate (port);\n\t\treturn 1;\n\t}\n\n\t \n\tif (mode & IEEE1284_EXT_LINK) {\n\t\tm = mode & 0x7f;\n\t\tudelay (1);\n\t\tparport_write_data (port, m);\n\t\tudelay (1);\n\n\t\t \n\t\tparport_frob_control (port,\n\t\t\t\t      PARPORT_CONTROL_STROBE,\n\t\t\t\t      PARPORT_CONTROL_STROBE);\n\n\t\t \n\t\tif (parport_wait_peripheral (port, PARPORT_STATUS_ACK, 0)) {\n\t\t\t \n\t\t\tpr_debug(\"%s: Event 52 didn't happen\\n\", port->name);\n\t\t\tparport_ieee1284_terminate (port);\n\t\t\treturn 1;\n\t\t}\n\n\t\t \n\t\tparport_frob_control (port,\n\t\t\t\t      PARPORT_CONTROL_STROBE,\n\t\t\t\t      0);\n\n\t\t \n\t\tif (parport_wait_peripheral (port,\n\t\t\t\t\t     PARPORT_STATUS_ACK,\n\t\t\t\t\t     PARPORT_STATUS_ACK)) {\n\t\t\t \n\t\t\tpr_debug(\"%s: Mode 0x%02x not supported? (0x%02x)\\n\",\n\t\t\t\t port->name, mode,\n\t\t\t\t port->ops->read_status(port));\n\t\t\tparport_ieee1284_terminate (port);\n\t\t\treturn 1;\n\t\t}\n\n\t\t \n\t\txflag = parport_read_status (port) & PARPORT_STATUS_SELECT;\n\n\t\t \n\t\tif (!xflag) {\n\t\t\t \n\t\t\tpr_debug(\"%s: Extended mode 0x%02x not supported\\n\",\n\t\t\t\t port->name, mode);\n\t\t\tparport_ieee1284_terminate (port);\n\t\t\treturn 1;\n\t\t}\n\n\t\t \n\t}\n\n\t \n\tpr_debug(\"%s: In mode 0x%02x\\n\", port->name, mode);\n\tport->ieee1284.mode = mode;\n\n\t \n\tif (!(mode & IEEE1284_EXT_LINK) && (m & IEEE1284_MODE_ECP)) {\n\t\tport->ieee1284.phase = IEEE1284_PH_ECP_SETUP;\n\n\t\t \n\t\tparport_frob_control (port,\n\t\t\t\t      PARPORT_CONTROL_AUTOFD,\n\t\t\t\t      PARPORT_CONTROL_AUTOFD);\n\n\t\t \n\t\tr = parport_wait_peripheral (port,\n\t\t\t\t\t     PARPORT_STATUS_PAPEROUT,\n\t\t\t\t\t     PARPORT_STATUS_PAPEROUT);\n\t\tif (r) {\n\t\t\tpr_debug(\"%s: Timeout at event 31\\n\", port->name);\n\t\t}\n\n\t\tport->ieee1284.phase = IEEE1284_PH_FWD_IDLE;\n\t\tpr_debug(\"%s: ECP direction: forward\\n\", port->name);\n\t} else switch (mode) {\n\tcase IEEE1284_MODE_NIBBLE:\n\tcase IEEE1284_MODE_BYTE:\n\t\tport->ieee1284.phase = IEEE1284_PH_REV_IDLE;\n\t\tbreak;\n\tdefault:\n\t\tport->ieee1284.phase = IEEE1284_PH_FWD_IDLE;\n\t}\n\n\n\treturn 0;\n#endif  \n}\n\n \n#ifdef CONFIG_PARPORT_1284\nstatic int parport_ieee1284_ack_data_avail (struct parport *port)\n{\n\tif (parport_read_status (port) & PARPORT_STATUS_ERROR)\n\t\t \n\t\treturn -1;\n\n\t \n\tport->ops->frob_control (port, PARPORT_CONTROL_AUTOFD, 0);\n\tport->ieee1284.phase = IEEE1284_PH_HBUSY_DAVAIL;\n\treturn 0;\n}\n#endif  \n\n \nvoid parport_ieee1284_interrupt (void *handle)\n{\n\tstruct parport *port = handle;\n\tparport_ieee1284_wakeup (port);\n\n#ifdef CONFIG_PARPORT_1284\n\tif (port->ieee1284.phase == IEEE1284_PH_REV_IDLE) {\n\t\t \n\t\tpr_debug(\"%s: Data available\\n\", port->name);\n\t\tparport_ieee1284_ack_data_avail (port);\n\t}\n#endif  \n}\n\n \n\nssize_t parport_write (struct parport *port, const void *buffer, size_t len)\n{\n#ifndef CONFIG_PARPORT_1284\n\treturn port->ops->compat_write_data (port, buffer, len, 0);\n#else\n\tssize_t retval;\n\tint mode = port->ieee1284.mode;\n\tint addr = mode & IEEE1284_ADDR;\n\tsize_t (*fn) (struct parport *, const void *, size_t, int);\n\n\t \n\tmode &= ~(IEEE1284_DEVICEID | IEEE1284_ADDR);\n\n\t \n\tswitch (mode) {\n\tcase IEEE1284_MODE_NIBBLE:\n\tcase IEEE1284_MODE_BYTE:\n\t\tparport_negotiate (port, IEEE1284_MODE_COMPAT);\n\t\tfallthrough;\n\tcase IEEE1284_MODE_COMPAT:\n\t\tpr_debug(\"%s: Using compatibility mode\\n\", port->name);\n\t\tfn = port->ops->compat_write_data;\n\t\tbreak;\n\n\tcase IEEE1284_MODE_EPP:\n\t\tpr_debug(\"%s: Using EPP mode\\n\", port->name);\n\t\tif (addr) {\n\t\t\tfn = port->ops->epp_write_addr;\n\t\t} else {\n\t\t\tfn = port->ops->epp_write_data;\n\t\t}\n\t\tbreak;\n\tcase IEEE1284_MODE_EPPSWE:\n\t\tpr_debug(\"%s: Using software-emulated EPP mode\\n\", port->name);\n\t\tif (addr) {\n\t\t\tfn = parport_ieee1284_epp_write_addr;\n\t\t} else {\n\t\t\tfn = parport_ieee1284_epp_write_data;\n\t\t}\n\t\tbreak;\n\tcase IEEE1284_MODE_ECP:\n\tcase IEEE1284_MODE_ECPRLE:\n\t\tpr_debug(\"%s: Using ECP mode\\n\", port->name);\n\t\tif (addr) {\n\t\t\tfn = port->ops->ecp_write_addr;\n\t\t} else {\n\t\t\tfn = port->ops->ecp_write_data;\n\t\t}\n\t\tbreak;\n\n\tcase IEEE1284_MODE_ECPSWE:\n\t\tpr_debug(\"%s: Using software-emulated ECP mode\\n\", port->name);\n\t\t \n\t\tif (addr) {\n\t\t\tfn = parport_ieee1284_ecp_write_addr;\n\t\t} else {\n\t\t\tfn = parport_ieee1284_ecp_write_data;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tpr_debug(\"%s: Unknown mode 0x%02x\\n\",\n\t\t\t port->name, port->ieee1284.mode);\n\t\treturn -ENOSYS;\n\t}\n\n\tretval = (*fn) (port, buffer, len, 0);\n\tpr_debug(\"%s: wrote %zd/%zu bytes\\n\", port->name, retval, len);\n\treturn retval;\n#endif  \n}\n\n \n\nssize_t parport_read (struct parport *port, void *buffer, size_t len)\n{\n#ifndef CONFIG_PARPORT_1284\n\tpr_err(\"parport: IEEE1284 not supported in this kernel\\n\");\n\treturn -ENODEV;\n#else\n\tint mode = port->physport->ieee1284.mode;\n\tint addr = mode & IEEE1284_ADDR;\n\tsize_t (*fn) (struct parport *, void *, size_t, int);\n\n\t \n\tmode &= ~(IEEE1284_DEVICEID | IEEE1284_ADDR);\n\n\t \n\tswitch (mode) {\n\tcase IEEE1284_MODE_COMPAT:\n\t\t \n\t\tif ((port->physport->modes & PARPORT_MODE_TRISTATE) &&\n\t\t    !parport_negotiate (port, IEEE1284_MODE_BYTE)) {\n\t\t\t \n\t\t\tpr_debug(\"%s: Using byte mode\\n\", port->name);\n\t\t\tfn = port->ops->byte_read_data;\n\t\t\tbreak;\n\t\t}\n\t\tif (parport_negotiate (port, IEEE1284_MODE_NIBBLE)) {\n\t\t\treturn -EIO;\n\t\t}\n\t\tfallthrough;\t \n\tcase IEEE1284_MODE_NIBBLE:\n\t\tpr_debug(\"%s: Using nibble mode\\n\", port->name);\n\t\tfn = port->ops->nibble_read_data;\n\t\tbreak;\n\n\tcase IEEE1284_MODE_BYTE:\n\t\tpr_debug(\"%s: Using byte mode\\n\", port->name);\n\t\tfn = port->ops->byte_read_data;\n\t\tbreak;\n\n\tcase IEEE1284_MODE_EPP:\n\t\tpr_debug(\"%s: Using EPP mode\\n\", port->name);\n\t\tif (addr) {\n\t\t\tfn = port->ops->epp_read_addr;\n\t\t} else {\n\t\t\tfn = port->ops->epp_read_data;\n\t\t}\n\t\tbreak;\n\tcase IEEE1284_MODE_EPPSWE:\n\t\tpr_debug(\"%s: Using software-emulated EPP mode\\n\", port->name);\n\t\tif (addr) {\n\t\t\tfn = parport_ieee1284_epp_read_addr;\n\t\t} else {\n\t\t\tfn = parport_ieee1284_epp_read_data;\n\t\t}\n\t\tbreak;\n\tcase IEEE1284_MODE_ECP:\n\tcase IEEE1284_MODE_ECPRLE:\n\t\tpr_debug(\"%s: Using ECP mode\\n\", port->name);\n\t\tfn = port->ops->ecp_read_data;\n\t\tbreak;\n\n\tcase IEEE1284_MODE_ECPSWE:\n\t\tpr_debug(\"%s: Using software-emulated ECP mode\\n\", port->name);\n\t\tfn = parport_ieee1284_ecp_read_data;\n\t\tbreak;\n\n\tdefault:\n\t\tpr_debug(\"%s: Unknown mode 0x%02x\\n\",\n\t\t\t port->name, port->physport->ieee1284.mode);\n\t\treturn -ENOSYS;\n\t}\n\n\treturn (*fn) (port, buffer, len, 0);\n#endif  \n}\n\n \n\nlong parport_set_timeout (struct pardevice *dev, long inactivity)\n{\n\tlong int old = dev->timeout;\n\n\tdev->timeout = inactivity;\n\n\tif (dev->port->physport->cad == dev)\n\t\tparport_ieee1284_wakeup (dev->port);\n\n\treturn old;\n}\n\n \n\nEXPORT_SYMBOL(parport_negotiate);\nEXPORT_SYMBOL(parport_write);\nEXPORT_SYMBOL(parport_read);\nEXPORT_SYMBOL(parport_wait_peripheral);\nEXPORT_SYMBOL(parport_wait_event);\nEXPORT_SYMBOL(parport_set_timeout);\nEXPORT_SYMBOL(parport_ieee1284_interrupt);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}