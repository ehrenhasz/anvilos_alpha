{
  "module_name": "share.c",
  "hash_id": "85f2a3caa65ec56fbe79549cf44c4aa74444478ac2a3ce4bb25563a1138ce647",
  "original_prompt": "Ingested from linux-6.6.14/drivers/parport/share.c",
  "human_readable_source": " \n\n#undef PARPORT_DEBUG_SHARING\t\t \n\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/threads.h>\n#include <linux/parport.h>\n#include <linux/delay.h>\n#include <linux/errno.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/kmod.h>\n#include <linux/device.h>\n\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <asm/irq.h>\n\n#undef PARPORT_PARANOID\n\n#define PARPORT_DEFAULT_TIMESLICE\t(HZ/5)\n\nunsigned long parport_default_timeslice = PARPORT_DEFAULT_TIMESLICE;\nint parport_default_spintime =  DEFAULT_SPIN_TIME;\n\nstatic LIST_HEAD(portlist);\nstatic DEFINE_SPINLOCK(parportlist_lock);\n\n \nstatic LIST_HEAD(all_ports);\nstatic DEFINE_SPINLOCK(full_list_lock);\n\nstatic LIST_HEAD(drivers);\n\nstatic DEFINE_MUTEX(registration_lock);\n\n \nstatic void dead_write_lines(struct parport *p, unsigned char b){}\nstatic unsigned char dead_read_lines(struct parport *p) { return 0; }\nstatic unsigned char dead_frob_lines(struct parport *p, unsigned char b,\n\t\t\t     unsigned char c) { return 0; }\nstatic void dead_onearg(struct parport *p){}\nstatic void dead_initstate(struct pardevice *d, struct parport_state *s) { }\nstatic void dead_state(struct parport *p, struct parport_state *s) { }\nstatic size_t dead_write(struct parport *p, const void *b, size_t l, int f)\n{ return 0; }\nstatic size_t dead_read(struct parport *p, void *b, size_t l, int f)\n{ return 0; }\nstatic struct parport_operations dead_ops = {\n\t.write_data\t= dead_write_lines,\t \n\t.read_data\t= dead_read_lines,\n\n\t.write_control\t= dead_write_lines,\t \n\t.read_control\t= dead_read_lines,\n\t.frob_control\t= dead_frob_lines,\n\n\t.read_status\t= dead_read_lines,\t \n\n\t.enable_irq\t= dead_onearg,\t\t \n\t.disable_irq\t= dead_onearg,\t\t \n\n\t.data_forward\t= dead_onearg,\t\t \n\t.data_reverse\t= dead_onearg,\t\t \n\n\t.init_state\t= dead_initstate,\t \n\t.save_state\t= dead_state,\n\t.restore_state\t= dead_state,\n\n\t.epp_write_data\t= dead_write,\t\t \n\t.epp_read_data\t= dead_read,\n\t.epp_write_addr\t= dead_write,\n\t.epp_read_addr\t= dead_read,\n\n\t.ecp_write_data\t= dead_write,\t\t \n\t.ecp_read_data\t= dead_read,\n\t.ecp_write_addr\t= dead_write,\n\n\t.compat_write_data\t= dead_write,\t \n\t.nibble_read_data\t= dead_read,\t \n\t.byte_read_data\t\t= dead_read,\t \n\n\t.owner\t\t= NULL,\n};\n\nstatic struct device_type parport_device_type = {\n\t.name = \"parport\",\n};\n\nstatic int is_parport(struct device *dev)\n{\n\treturn dev->type == &parport_device_type;\n}\n\nstatic int parport_probe(struct device *dev)\n{\n\tstruct parport_driver *drv;\n\n\tif (is_parport(dev))\n\t\treturn -ENODEV;\n\n\tdrv = to_parport_driver(dev->driver);\n\tif (!drv->probe) {\n\t\t \n\t\tstruct pardevice *par_dev = to_pardevice(dev);\n\n\t\tif (strcmp(par_dev->name, drv->name))\n\t\t\treturn -ENODEV;\n\t\treturn 0;\n\t}\n\t \n\treturn drv->probe(to_pardevice(dev));\n}\n\nstatic struct bus_type parport_bus_type = {\n\t.name = \"parport\",\n\t.probe = parport_probe,\n};\n\nint parport_bus_init(void)\n{\n\treturn bus_register(&parport_bus_type);\n}\n\nvoid parport_bus_exit(void)\n{\n\tbus_unregister(&parport_bus_type);\n}\n\n \nstatic int driver_check(struct device_driver *dev_drv, void *_port)\n{\n\tstruct parport *port = _port;\n\tstruct parport_driver *drv = to_parport_driver(dev_drv);\n\n\tif (drv->match_port)\n\t\tdrv->match_port(port);\n\treturn 0;\n}\n\n \nstatic void attach_driver_chain(struct parport *port)\n{\n\t \n\tstruct parport_driver *drv;\n\n\tlist_for_each_entry(drv, &drivers, list)\n\t\tdrv->attach(port);\n\n\t \n\n\tbus_for_each_drv(&parport_bus_type, NULL, port, driver_check);\n}\n\nstatic int driver_detach(struct device_driver *_drv, void *_port)\n{\n\tstruct parport *port = _port;\n\tstruct parport_driver *drv = to_parport_driver(_drv);\n\n\tif (drv->detach)\n\t\tdrv->detach(port);\n\treturn 0;\n}\n\n \nstatic void detach_driver_chain(struct parport *port)\n{\n\tstruct parport_driver *drv;\n\t \n\tlist_for_each_entry(drv, &drivers, list)\n\t\tdrv->detach(port);\n\n\t \n\n\tbus_for_each_drv(&parport_bus_type, NULL, port, driver_detach);\n}\n\n \nstatic void get_lowlevel_driver(void)\n{\n\t \n\trequest_module(\"parport_lowlevel\");\n}\n\n \nstatic int port_check(struct device *dev, void *dev_drv)\n{\n\tstruct parport_driver *drv = dev_drv;\n\n\t \n\tif (is_parport(dev))\n\t\tdrv->match_port(to_parport_dev(dev));\n\treturn 0;\n}\n\n \n\nstatic int port_detect(struct device *dev, void *dev_drv)\n{\n\tif (is_parport(dev))\n\t\treturn 1;\n\treturn 0;\n}\n\n \n\nint __parport_register_driver(struct parport_driver *drv, struct module *owner,\n\t\t\t      const char *mod_name)\n{\n\t \n\tint ret;\n\n\t \n\tdrv->driver.name = drv->name;\n\tdrv->driver.bus = &parport_bus_type;\n\tdrv->driver.owner = owner;\n\tdrv->driver.mod_name = mod_name;\n\tret = driver_register(&drv->driver);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = bus_for_each_dev(&parport_bus_type, NULL, NULL,\n\t\t\t       port_detect);\n\tif (!ret)\n\t\tget_lowlevel_driver();\n\n\tmutex_lock(&registration_lock);\n\tif (drv->match_port)\n\t\tbus_for_each_dev(&parport_bus_type, NULL, drv,\n\t\t\t\t port_check);\n\tmutex_unlock(&registration_lock);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(__parport_register_driver);\n\nstatic int port_detach(struct device *dev, void *_drv)\n{\n\tstruct parport_driver *drv = _drv;\n\n\tif (is_parport(dev) && drv->detach)\n\t\tdrv->detach(to_parport_dev(dev));\n\n\treturn 0;\n}\n\n \n\nvoid parport_unregister_driver(struct parport_driver *drv)\n{\n\tmutex_lock(&registration_lock);\n\tbus_for_each_dev(&parport_bus_type, NULL, drv, port_detach);\n\tdriver_unregister(&drv->driver);\n\tmutex_unlock(&registration_lock);\n}\nEXPORT_SYMBOL(parport_unregister_driver);\n\nstatic void free_port(struct device *dev)\n{\n\tint d;\n\tstruct parport *port = to_parport_dev(dev);\n\n\tspin_lock(&full_list_lock);\n\tlist_del(&port->full_list);\n\tspin_unlock(&full_list_lock);\n\tfor (d = 0; d < 5; d++) {\n\t\tkfree(port->probe_info[d].class_name);\n\t\tkfree(port->probe_info[d].mfr);\n\t\tkfree(port->probe_info[d].model);\n\t\tkfree(port->probe_info[d].cmdset);\n\t\tkfree(port->probe_info[d].description);\n\t}\n\n\tkfree(port->name);\n\tkfree(port);\n}\n\n \n\nstruct parport *parport_get_port(struct parport *port)\n{\n\tstruct device *dev = get_device(&port->bus_dev);\n\n\treturn to_parport_dev(dev);\n}\nEXPORT_SYMBOL(parport_get_port);\n\nvoid parport_del_port(struct parport *port)\n{\n\tdevice_unregister(&port->bus_dev);\n}\nEXPORT_SYMBOL(parport_del_port);\n\n \n\nvoid parport_put_port(struct parport *port)\n{\n\tput_device(&port->bus_dev);\n}\nEXPORT_SYMBOL(parport_put_port);\n\n \n\nstruct parport *parport_register_port(unsigned long base, int irq, int dma,\n\t\t\t\t      struct parport_operations *ops)\n{\n\tstruct list_head *l;\n\tstruct parport *tmp;\n\tint num;\n\tint device;\n\tchar *name;\n\tint ret;\n\n\ttmp = kzalloc(sizeof(struct parport), GFP_KERNEL);\n\tif (!tmp)\n\t\treturn NULL;\n\n\t \n\ttmp->base = base;\n\ttmp->irq = irq;\n\ttmp->dma = dma;\n\ttmp->muxport = tmp->daisy = tmp->muxsel = -1;\n\ttmp->modes = 0;\n\tINIT_LIST_HEAD(&tmp->list);\n\ttmp->devices = tmp->cad = NULL;\n\ttmp->flags = 0;\n\ttmp->ops = ops;\n\ttmp->physport = tmp;\n\tmemset(tmp->probe_info, 0, 5 * sizeof(struct parport_device_info));\n\trwlock_init(&tmp->cad_lock);\n\tspin_lock_init(&tmp->waitlist_lock);\n\tspin_lock_init(&tmp->pardevice_lock);\n\ttmp->ieee1284.mode = IEEE1284_MODE_COMPAT;\n\ttmp->ieee1284.phase = IEEE1284_PH_FWD_IDLE;\n\tsema_init(&tmp->ieee1284.irq, 0);\n\ttmp->spintime = parport_default_spintime;\n\tatomic_set(&tmp->ref_count, 1);\n\tINIT_LIST_HEAD(&tmp->full_list);\n\n\tname = kmalloc(PARPORT_NAME_MAX_LEN, GFP_KERNEL);\n\tif (!name) {\n\t\tkfree(tmp);\n\t\treturn NULL;\n\t}\n\t \n\n\tspin_lock(&full_list_lock);\n\tfor (l = all_ports.next, num = 0; l != &all_ports; l = l->next, num++) {\n\t\tstruct parport *p = list_entry(l, struct parport, full_list);\n\t\tif (p->number != num)\n\t\t\tbreak;\n\t}\n\ttmp->portnum = tmp->number = num;\n\tlist_add_tail(&tmp->full_list, l);\n\tspin_unlock(&full_list_lock);\n\n\t \n\tsprintf(name, \"parport%d\", tmp->portnum = tmp->number);\n\ttmp->name = name;\n\ttmp->bus_dev.bus = &parport_bus_type;\n\ttmp->bus_dev.release = free_port;\n\tdev_set_name(&tmp->bus_dev, name);\n\ttmp->bus_dev.type = &parport_device_type;\n\n\tfor (device = 0; device < 5; device++)\n\t\t \n\t\ttmp->probe_info[device].class = PARPORT_CLASS_LEGACY;\n\n\ttmp->waithead = tmp->waittail = NULL;\n\n\tret = device_register(&tmp->bus_dev);\n\tif (ret) {\n\t\tput_device(&tmp->bus_dev);\n\t\treturn NULL;\n\t}\n\n\treturn tmp;\n}\nEXPORT_SYMBOL(parport_register_port);\n\n \n\nvoid parport_announce_port(struct parport *port)\n{\n\tint i;\n\n#ifdef CONFIG_PARPORT_1284\n\t \n\tparport_daisy_init(port);\n#endif\n\n\tif (!port->dev)\n\t\tpr_warn(\"%s: fix this legacy no-device port driver!\\n\",\n\t\t\tport->name);\n\n\tparport_proc_register(port);\n\tmutex_lock(&registration_lock);\n\tspin_lock_irq(&parportlist_lock);\n\tlist_add_tail(&port->list, &portlist);\n\tfor (i = 1; i < 3; i++) {\n\t\tstruct parport *slave = port->slaves[i-1];\n\t\tif (slave)\n\t\t\tlist_add_tail(&slave->list, &portlist);\n\t}\n\tspin_unlock_irq(&parportlist_lock);\n\n\t \n\tattach_driver_chain(port);\n\tfor (i = 1; i < 3; i++) {\n\t\tstruct parport *slave = port->slaves[i-1];\n\t\tif (slave)\n\t\t\tattach_driver_chain(slave);\n\t}\n\tmutex_unlock(&registration_lock);\n}\nEXPORT_SYMBOL(parport_announce_port);\n\n \n\nvoid parport_remove_port(struct parport *port)\n{\n\tint i;\n\n\tmutex_lock(&registration_lock);\n\n\t \n\tdetach_driver_chain(port);\n\n#ifdef CONFIG_PARPORT_1284\n\t \n\tparport_daisy_fini(port);\n\tfor (i = 1; i < 3; i++) {\n\t\tstruct parport *slave = port->slaves[i-1];\n\t\tif (!slave)\n\t\t\tcontinue;\n\t\tdetach_driver_chain(slave);\n\t\tparport_daisy_fini(slave);\n\t}\n#endif\n\n\tport->ops = &dead_ops;\n\tspin_lock(&parportlist_lock);\n\tlist_del_init(&port->list);\n\tfor (i = 1; i < 3; i++) {\n\t\tstruct parport *slave = port->slaves[i-1];\n\t\tif (slave)\n\t\t\tlist_del_init(&slave->list);\n\t}\n\tspin_unlock(&parportlist_lock);\n\n\tmutex_unlock(&registration_lock);\n\n\tparport_proc_unregister(port);\n\n\tfor (i = 1; i < 3; i++) {\n\t\tstruct parport *slave = port->slaves[i-1];\n\t\tif (slave)\n\t\t\tparport_put_port(slave);\n\t}\n}\nEXPORT_SYMBOL(parport_remove_port);\n\nstatic void free_pardevice(struct device *dev)\n{\n\tstruct pardevice *par_dev = to_pardevice(dev);\n\n\tkfree(par_dev->name);\n\tkfree(par_dev);\n}\n\n \n\nstruct pardevice *\nparport_register_dev_model(struct parport *port, const char *name,\n\t\t\t   const struct pardev_cb *par_dev_cb, int id)\n{\n\tstruct pardevice *par_dev;\n\tint ret;\n\tchar *devname;\n\n\tif (port->physport->flags & PARPORT_FLAG_EXCL) {\n\t\t \n\t\tpr_err(\"%s: no more devices allowed\\n\", port->name);\n\t\treturn NULL;\n\t}\n\n\tif (par_dev_cb->flags & PARPORT_DEV_LURK) {\n\t\tif (!par_dev_cb->preempt || !par_dev_cb->wakeup) {\n\t\t\tpr_info(\"%s: refused to register lurking device (%s) without callbacks\\n\",\n\t\t\t\tport->name, name);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tif (par_dev_cb->flags & PARPORT_DEV_EXCL) {\n\t\tif (port->physport->devices) {\n\t\t\t \n\t\t\tpr_err(\"%s: cannot grant exclusive access for device %s\\n\",\n\t\t\t       port->name, name);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tif (!try_module_get(port->ops->owner))\n\t\treturn NULL;\n\n\tparport_get_port(port);\n\n\tpar_dev = kzalloc(sizeof(*par_dev), GFP_KERNEL);\n\tif (!par_dev)\n\t\tgoto err_put_port;\n\n\tpar_dev->state = kzalloc(sizeof(*par_dev->state), GFP_KERNEL);\n\tif (!par_dev->state)\n\t\tgoto err_put_par_dev;\n\n\tdevname = kstrdup(name, GFP_KERNEL);\n\tif (!devname)\n\t\tgoto err_free_par_dev;\n\n\tpar_dev->name = devname;\n\tpar_dev->port = port;\n\tpar_dev->daisy = -1;\n\tpar_dev->preempt = par_dev_cb->preempt;\n\tpar_dev->wakeup = par_dev_cb->wakeup;\n\tpar_dev->private = par_dev_cb->private;\n\tpar_dev->flags = par_dev_cb->flags;\n\tpar_dev->irq_func = par_dev_cb->irq_func;\n\tpar_dev->waiting = 0;\n\tpar_dev->timeout = 5 * HZ;\n\n\tpar_dev->dev.parent = &port->bus_dev;\n\tpar_dev->dev.bus = &parport_bus_type;\n\tret = dev_set_name(&par_dev->dev, \"%s.%d\", devname, id);\n\tif (ret)\n\t\tgoto err_free_devname;\n\tpar_dev->dev.release = free_pardevice;\n\tpar_dev->devmodel = true;\n\tret = device_register(&par_dev->dev);\n\tif (ret) {\n\t\tkfree(par_dev->state);\n\t\tput_device(&par_dev->dev);\n\t\tgoto err_put_port;\n\t}\n\n\t \n\tpar_dev->prev = NULL;\n\t \n\tspin_lock(&port->physport->pardevice_lock);\n\n\tif (par_dev_cb->flags & PARPORT_DEV_EXCL) {\n\t\tif (port->physport->devices) {\n\t\t\tspin_unlock(&port->physport->pardevice_lock);\n\t\t\tpr_debug(\"%s: cannot grant exclusive access for device %s\\n\",\n\t\t\t\t port->name, name);\n\t\t\tkfree(par_dev->state);\n\t\t\tdevice_unregister(&par_dev->dev);\n\t\t\tgoto err_put_port;\n\t\t}\n\t\tport->flags |= PARPORT_FLAG_EXCL;\n\t}\n\n\tpar_dev->next = port->physport->devices;\n\twmb();\t \n\tif (port->physport->devices)\n\t\tport->physport->devices->prev = par_dev;\n\tport->physport->devices = par_dev;\n\tspin_unlock(&port->physport->pardevice_lock);\n\n\tinit_waitqueue_head(&par_dev->wait_q);\n\tpar_dev->timeslice = parport_default_timeslice;\n\tpar_dev->waitnext = NULL;\n\tpar_dev->waitprev = NULL;\n\n\t \n\tport->ops->init_state(par_dev, par_dev->state);\n\tif (!test_and_set_bit(PARPORT_DEVPROC_REGISTERED, &port->devflags)) {\n\t\tport->proc_device = par_dev;\n\t\tparport_device_proc_register(par_dev);\n\t}\n\n\treturn par_dev;\n\nerr_free_devname:\n\tkfree(devname);\nerr_free_par_dev:\n\tkfree(par_dev->state);\nerr_put_par_dev:\n\tif (!par_dev->devmodel)\n\t\tkfree(par_dev);\nerr_put_port:\n\tparport_put_port(port);\n\tmodule_put(port->ops->owner);\n\n\treturn NULL;\n}\nEXPORT_SYMBOL(parport_register_dev_model);\n\n \n\nvoid parport_unregister_device(struct pardevice *dev)\n{\n\tstruct parport *port;\n\n#ifdef PARPORT_PARANOID\n\tif (!dev) {\n\t\tpr_err(\"%s: passed NULL\\n\", __func__);\n\t\treturn;\n\t}\n#endif\n\n\tport = dev->port->physport;\n\n\tif (port->proc_device == dev) {\n\t\tport->proc_device = NULL;\n\t\tclear_bit(PARPORT_DEVPROC_REGISTERED, &port->devflags);\n\t\tparport_device_proc_unregister(dev);\n\t}\n\n\tif (port->cad == dev) {\n\t\tprintk(KERN_DEBUG \"%s: %s forgot to release port\\n\",\n\t\t       port->name, dev->name);\n\t\tparport_release(dev);\n\t}\n\n\tspin_lock(&port->pardevice_lock);\n\tif (dev->next)\n\t\tdev->next->prev = dev->prev;\n\tif (dev->prev)\n\t\tdev->prev->next = dev->next;\n\telse\n\t\tport->devices = dev->next;\n\n\tif (dev->flags & PARPORT_DEV_EXCL)\n\t\tport->flags &= ~PARPORT_FLAG_EXCL;\n\n\tspin_unlock(&port->pardevice_lock);\n\n\t \n\tspin_lock_irq(&port->waitlist_lock);\n\tif (dev->waitprev || dev->waitnext || port->waithead == dev) {\n\t\tif (dev->waitprev)\n\t\t\tdev->waitprev->waitnext = dev->waitnext;\n\t\telse\n\t\t\tport->waithead = dev->waitnext;\n\t\tif (dev->waitnext)\n\t\t\tdev->waitnext->waitprev = dev->waitprev;\n\t\telse\n\t\t\tport->waittail = dev->waitprev;\n\t}\n\tspin_unlock_irq(&port->waitlist_lock);\n\n\tkfree(dev->state);\n\tdevice_unregister(&dev->dev);\n\n\tmodule_put(port->ops->owner);\n\tparport_put_port(port);\n}\nEXPORT_SYMBOL(parport_unregister_device);\n\n \n\nstruct parport *parport_find_number(int number)\n{\n\tstruct parport *port, *result = NULL;\n\n\tif (list_empty(&portlist))\n\t\tget_lowlevel_driver();\n\n\tspin_lock(&parportlist_lock);\n\tlist_for_each_entry(port, &portlist, list) {\n\t\tif (port->number == number) {\n\t\t\tresult = parport_get_port(port);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&parportlist_lock);\n\treturn result;\n}\nEXPORT_SYMBOL(parport_find_number);\n\n \n\nstruct parport *parport_find_base(unsigned long base)\n{\n\tstruct parport *port, *result = NULL;\n\n\tif (list_empty(&portlist))\n\t\tget_lowlevel_driver();\n\n\tspin_lock(&parportlist_lock);\n\tlist_for_each_entry(port, &portlist, list) {\n\t\tif (port->base == base) {\n\t\t\tresult = parport_get_port(port);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&parportlist_lock);\n\treturn result;\n}\nEXPORT_SYMBOL(parport_find_base);\n\n \n\nint parport_claim(struct pardevice *dev)\n{\n\tstruct pardevice *oldcad;\n\tstruct parport *port = dev->port->physport;\n\tunsigned long flags;\n\n\tif (port->cad == dev) {\n\t\tpr_info(\"%s: %s already owner\\n\", dev->port->name, dev->name);\n\t\treturn 0;\n\t}\n\n\t \n\twrite_lock_irqsave(&port->cad_lock, flags);\n\toldcad = port->cad;\n\tif (oldcad) {\n\t\tif (oldcad->preempt) {\n\t\t\tif (oldcad->preempt(oldcad->private))\n\t\t\t\tgoto blocked;\n\t\t\tport->ops->save_state(port, dev->state);\n\t\t} else\n\t\t\tgoto blocked;\n\n\t\tif (port->cad != oldcad) {\n\t\t\t \n\t\t\tpr_warn(\"%s: %s released port when preempted!\\n\",\n\t\t\t\tport->name, oldcad->name);\n\t\t\tif (port->cad)\n\t\t\t\tgoto blocked;\n\t\t}\n\t}\n\n\t \n\tif (dev->waiting & 1) {\n\t\tdev->waiting = 0;\n\n\t\t \n\t\tspin_lock_irq(&port->waitlist_lock);\n\t\tif (dev->waitprev)\n\t\t\tdev->waitprev->waitnext = dev->waitnext;\n\t\telse\n\t\t\tport->waithead = dev->waitnext;\n\t\tif (dev->waitnext)\n\t\t\tdev->waitnext->waitprev = dev->waitprev;\n\t\telse\n\t\t\tport->waittail = dev->waitprev;\n\t\tspin_unlock_irq(&port->waitlist_lock);\n\t\tdev->waitprev = dev->waitnext = NULL;\n\t}\n\n\t \n\tport->cad = dev;\n\n#ifdef CONFIG_PARPORT_1284\n\t \n\tif (dev->port->muxport >= 0) {\n\t\t \n\t\tport->muxsel = dev->port->muxport;\n\t}\n\n\t \n\tif (dev->daisy >= 0) {\n\t\t \n\t\tif (!parport_daisy_select(port, dev->daisy,\n\t\t\t\t\t   IEEE1284_MODE_COMPAT))\n\t\t\tport->daisy = dev->daisy;\n\t}\n#endif  \n\n\t \n\tport->ops->restore_state(port, dev->state);\n\twrite_unlock_irqrestore(&port->cad_lock, flags);\n\tdev->time = jiffies;\n\treturn 0;\n\nblocked:\n\t \n\n\t \n\tif (dev->waiting & 2 || dev->wakeup) {\n\t\tspin_lock(&port->waitlist_lock);\n\t\tif (test_and_set_bit(0, &dev->waiting) == 0) {\n\t\t\t \n\t\t\tdev->waitnext = NULL;\n\t\t\tdev->waitprev = port->waittail;\n\t\t\tif (port->waittail) {\n\t\t\t\tport->waittail->waitnext = dev;\n\t\t\t\tport->waittail = dev;\n\t\t\t} else\n\t\t\t\tport->waithead = port->waittail = dev;\n\t\t}\n\t\tspin_unlock(&port->waitlist_lock);\n\t}\n\twrite_unlock_irqrestore(&port->cad_lock, flags);\n\treturn -EAGAIN;\n}\nEXPORT_SYMBOL(parport_claim);\n\n \n\nint parport_claim_or_block(struct pardevice *dev)\n{\n\tint r;\n\n\t \n\tdev->waiting = 2;\n\n\t \n\tr = parport_claim(dev);\n\tif (r == -EAGAIN) {\n#ifdef PARPORT_DEBUG_SHARING\n\t\tprintk(KERN_DEBUG \"%s: parport_claim() returned -EAGAIN\\n\",\n\t\t       dev->name);\n#endif\n\t\t \n\n\t\t \n\t\tif (dev->waiting) {\n\t\t\twait_event_interruptible(dev->wait_q,\n\t\t\t\t\t\t !dev->waiting);\n\t\t\tif (signal_pending(current))\n\t\t\t\treturn -EINTR;\n\t\t\tr = 1;\n\t\t} else {\n\t\t\tr = 0;\n#ifdef PARPORT_DEBUG_SHARING\n\t\t\tprintk(KERN_DEBUG \"%s: didn't sleep in parport_claim_or_block()\\n\",\n\t\t\t       dev->name);\n#endif\n\t\t}\n\n#ifdef PARPORT_DEBUG_SHARING\n\t\tif (dev->port->physport->cad != dev)\n\t\t\tprintk(KERN_DEBUG \"%s: exiting parport_claim_or_block but %s owns port!\\n\",\n\t\t\t       dev->name, dev->port->physport->cad ?\n\t\t\t       dev->port->physport->cad->name : \"nobody\");\n#endif\n\t}\n\tdev->waiting = 0;\n\treturn r;\n}\nEXPORT_SYMBOL(parport_claim_or_block);\n\n \n\nvoid parport_release(struct pardevice *dev)\n{\n\tstruct parport *port = dev->port->physport;\n\tstruct pardevice *pd;\n\tunsigned long flags;\n\n\t \n\twrite_lock_irqsave(&port->cad_lock, flags);\n\tif (port->cad != dev) {\n\t\twrite_unlock_irqrestore(&port->cad_lock, flags);\n\t\tpr_warn(\"%s: %s tried to release parport when not owner\\n\",\n\t\t\tport->name, dev->name);\n\t\treturn;\n\t}\n\n#ifdef CONFIG_PARPORT_1284\n\t \n\tif (dev->port->muxport >= 0) {\n\t\t \n\t\tport->muxsel = -1;\n\t}\n\n\t \n\tif (dev->daisy >= 0) {\n\t\tparport_daisy_deselect_all(port);\n\t\tport->daisy = -1;\n\t}\n#endif\n\n\tport->cad = NULL;\n\twrite_unlock_irqrestore(&port->cad_lock, flags);\n\n\t \n\tport->ops->save_state(port, dev->state);\n\n\t \n\t \n\tfor (pd = port->waithead; pd; pd = pd->waitnext) {\n\t\tif (pd->waiting & 2) {  \n\t\t\tparport_claim(pd);\n\t\t\tif (waitqueue_active(&pd->wait_q))\n\t\t\t\twake_up_interruptible(&pd->wait_q);\n\t\t\treturn;\n\t\t} else if (pd->wakeup) {\n\t\t\tpd->wakeup(pd->private);\n\t\t\tif (dev->port->cad)  \n\t\t\t\treturn;\n\t\t} else {\n\t\t\tpr_err(\"%s: don't know how to wake %s\\n\",\n\t\t\t       port->name, pd->name);\n\t\t}\n\t}\n\n\t \n\t \n\tfor (pd = port->devices; !port->cad && pd; pd = pd->next) {\n\t\tif (pd->wakeup && pd != dev)\n\t\t\tpd->wakeup(pd->private);\n\t}\n}\nEXPORT_SYMBOL(parport_release);\n\nirqreturn_t parport_irq_handler(int irq, void *dev_id)\n{\n\tstruct parport *port = dev_id;\n\n\tparport_generic_irq(port);\n\n\treturn IRQ_HANDLED;\n}\nEXPORT_SYMBOL(parport_irq_handler);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}