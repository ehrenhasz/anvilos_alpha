{
  "module_name": "probe.c",
  "hash_id": "2a61d2c812705bd7ccac5bca4d30893c3e2fdf37eecf91c11f99d8a33149c7d5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/parport/probe.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/parport.h>\n#include <linux/string.h>\n#include <linux/string_helpers.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic const struct {\n\tconst char *token;\n\tconst char *descr;\n} classes[] = {\n\t{ \"\",            \"Legacy device\" },\n\t{ \"PRINTER\",     \"Printer\" },\n\t{ \"MODEM\",       \"Modem\" },\n\t{ \"NET\",         \"Network device\" },\n\t{ \"HDC\",       \t \"Hard disk\" },\n\t{ \"PCMCIA\",      \"PCMCIA\" },\n\t{ \"MEDIA\",       \"Multimedia device\" },\n\t{ \"FDC\",         \"Floppy disk\" },\n\t{ \"PORTS\",       \"Ports\" },\n\t{ \"SCANNER\",     \"Scanner\" },\n\t{ \"DIGICAM\",     \"Digital camera\" },\n\t{ \"\",            \"Unknown device\" },\n\t{ \"\",            \"Unspecified\" },\n\t{ \"SCSIADAPTER\", \"SCSI adapter\" },\n\t{ NULL,          NULL }\n};\n\nstatic void pretty_print(struct parport *port, int device)\n{\n\tstruct parport_device_info *info = &port->probe_info[device + 1];\n\n\tpr_info(\"%s\", port->name);\n\n\tif (device >= 0)\n\t\tpr_cont(\" (addr %d)\", device);\n\n\tpr_cont(\": %s\", classes[info->class].descr);\n\tif (info->class)\n\t\tpr_cont(\", %s %s\", info->mfr, info->model);\n\n\tpr_cont(\"\\n\");\n}\n\nstatic void parse_data(struct parport *port, int device, char *str)\n{\n\tchar *txt = kmalloc(strlen(str)+1, GFP_KERNEL);\n\tchar *p = txt, *q;\n\tint guessed_class = PARPORT_CLASS_UNSPEC;\n\tstruct parport_device_info *info = &port->probe_info[device + 1];\n\n\tif (!txt) {\n\t\tpr_warn(\"%s probe: memory squeeze\\n\", port->name);\n\t\treturn;\n\t}\n\tstrcpy(txt, str);\n\twhile (p) {\n\t\tchar *sep;\n\t\tq = strchr(p, ';');\n\t\tif (q) *q = 0;\n\t\tsep = strchr(p, ':');\n\t\tif (sep) {\n\t\t\tchar *u;\n\t\t\t*(sep++) = 0;\n\t\t\t \n\t\t\tu = sep + strlen (sep) - 1;\n\t\t\twhile (u >= p && *u == ' ')\n\t\t\t\t*u-- = '\\0';\n\t\t\tstring_upper(p, p);\n\t\t\tif (!strcmp(p, \"MFG\") || !strcmp(p, \"MANUFACTURER\")) {\n\t\t\t\tkfree(info->mfr);\n\t\t\t\tinfo->mfr = kstrdup(sep, GFP_KERNEL);\n\t\t\t} else if (!strcmp(p, \"MDL\") || !strcmp(p, \"MODEL\")) {\n\t\t\t\tkfree(info->model);\n\t\t\t\tinfo->model = kstrdup(sep, GFP_KERNEL);\n\t\t\t} else if (!strcmp(p, \"CLS\") || !strcmp(p, \"CLASS\")) {\n\t\t\t\tint i;\n\n\t\t\t\tkfree(info->class_name);\n\t\t\t\tinfo->class_name = kstrdup(sep, GFP_KERNEL);\n\t\t\t\tstring_upper(sep, sep);\n\t\t\t\tfor (i = 0; classes[i].token; i++) {\n\t\t\t\t\tif (!strcmp(classes[i].token, sep)) {\n\t\t\t\t\t\tinfo->class = i;\n\t\t\t\t\t\tgoto rock_on;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpr_warn(\"%s probe: warning, class '%s' not understood\\n\",\n\t\t\t\t\tport->name, sep);\n\t\t\t\tinfo->class = PARPORT_CLASS_OTHER;\n\t\t\t} else if (!strcmp(p, \"CMD\") ||\n\t\t\t\t   !strcmp(p, \"COMMAND SET\")) {\n\t\t\t\tkfree(info->cmdset);\n\t\t\t\tinfo->cmdset = kstrdup(sep, GFP_KERNEL);\n\t\t\t\t \n\t\t\t\tif (strstr(sep, \"PJL\") || strstr(sep, \"PCL\"))\n\t\t\t\t\tguessed_class = PARPORT_CLASS_PRINTER;\n\t\t\t} else if (!strcmp(p, \"DES\") || !strcmp(p, \"DESCRIPTION\")) {\n\t\t\t\tkfree(info->description);\n\t\t\t\tinfo->description = kstrdup(sep, GFP_KERNEL);\n\t\t\t}\n\t\t}\n\trock_on:\n\t\tif (q)\n\t\t\tp = q + 1;\n\t\telse\n\t\t\tp = NULL;\n\t}\n\n\t \n\tif (info->class == PARPORT_CLASS_UNSPEC)\n\t\tinfo->class = guessed_class;\n\n\tpretty_print (port, device);\n\n\tkfree(txt);\n}\n\n \nstatic ssize_t parport_read_device_id (struct parport *port, char *buffer,\n\t\t\t\t       size_t count)\n{\n\tunsigned char length[2];\n\tunsigned lelen, belen;\n\tsize_t idlens[4];\n\tunsigned numidlens;\n\tunsigned current_idlen;\n\tssize_t retval;\n\tsize_t len;\n\n\t \n\tretval = parport_read (port, length, 2);\n\n\tif (retval < 0)\n\t\treturn retval;\n\tif (retval != 2)\n\t\treturn -EIO;\n\n\tif (count < 2)\n\t\treturn 0;\n\tmemcpy(buffer, length, 2);\n\tlen = 2;\n\n\t \n\tbelen = (length[0] << 8) + length[1];\n\tlelen = (length[1] << 8) + length[0];\n\tidlens[0] = min(belen, lelen);\n\tidlens[1] = idlens[0]+2;\n\tif (belen != lelen) {\n\t\tint off = 2;\n\t\t \n\t\tif (idlens[0] <= 2)\n\t\t\toff = 0;\n\t\tidlens[off] = max(belen, lelen);\n\t\tidlens[off+1] = idlens[off]+2;\n\t\tnumidlens = off+2;\n\t}\n\telse {\n\t\t \n\t\tif (idlens[0] == 0 || idlens[0] > 0xFFF) {\n\t\t\tprintk(KERN_DEBUG \"%s: reported broken Device ID length of %#zX bytes\\n\",\n\t\t\t       port->name, idlens[0]);\n\t\t\treturn -EIO;\n\t\t}\n\t\tnumidlens = 2;\n\t}\n\n\t \n\tfor (current_idlen = 0; current_idlen < numidlens; ++current_idlen) {\n\t\tsize_t idlen = idlens[current_idlen];\n\t\tif (idlen+1 >= count)\n\t\t\tbreak;\n\n\t\tretval = parport_read (port, buffer+len, idlen-len);\n\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t\tlen += retval;\n\n\t\tif (port->physport->ieee1284.phase != IEEE1284_PH_HBUSY_DAVAIL) {\n\t\t\tif (belen != len) {\n\t\t\t\tprintk(KERN_DEBUG \"%s: Device ID was %zd bytes while device told it would be %d bytes\\n\",\n\t\t\t\t       port->name, len, belen);\n\t\t\t}\n\t\t\tgoto done;\n\t\t}\n\n\t\t \n\t\tif (buffer[len-1] == ';') {\n\t\t\tprintk(KERN_DEBUG \"%s: Device ID reading stopped before device told data not available. Current idlen %u of %u, len bytes %02X %02X\\n\",\n\t\t\t       port->name, current_idlen, numidlens,\n\t\t\t       length[0], length[1]);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tif (current_idlen < numidlens) {\n\t\t \n\t\tsize_t idlen, len2;\n\t\tif (len+1 < count) {\n\t\t\tretval = parport_read (port, buffer+len, count-len-1);\n\t\t\tif (retval < 0)\n\t\t\t\treturn retval;\n\t\t\tlen += retval;\n\t\t}\n\t\t \n\t\tidlen = idlens[current_idlen];\n\t\tlen2 = len;\n\t\twhile(len2 < idlen && retval > 0) {\n\t\t\tchar tmp[4];\n\t\t\tretval = parport_read (port, tmp,\n\t\t\t\t\t       min(sizeof tmp, idlen-len2));\n\t\t\tif (retval < 0)\n\t\t\t\treturn retval;\n\t\t\tlen2 += retval;\n\t\t}\n\t}\n\t \n done:\n\tbuffer[len] = '\\0';\n\treturn len;\n}\n\n \nssize_t parport_device_id (int devnum, char *buffer, size_t count)\n{\n\tssize_t retval = -ENXIO;\n\tstruct pardevice *dev = parport_open(devnum, daisy_dev_name);\n\tif (!dev)\n\t\treturn -ENXIO;\n\n\tparport_claim_or_block (dev);\n\n\t \n\tparport_negotiate (dev->port, IEEE1284_MODE_COMPAT);\n\tretval = parport_negotiate (dev->port,\n\t\t\t\t    IEEE1284_MODE_NIBBLE | IEEE1284_DEVICEID);\n\n\tif (!retval) {\n\t\tretval = parport_read_device_id (dev->port, buffer, count);\n\t\tparport_negotiate (dev->port, IEEE1284_MODE_COMPAT);\n\t\tif (retval > 2)\n\t\t\tparse_data (dev->port, dev->daisy, buffer+2);\n\t}\n\n\tparport_release (dev);\n\tparport_close (dev);\n\treturn retval;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}