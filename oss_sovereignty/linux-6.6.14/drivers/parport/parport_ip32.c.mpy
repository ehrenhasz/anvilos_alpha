{
  "module_name": "parport_ip32.c",
  "hash_id": "fd7dfa30cfa28f8c54a98db5ee1ac43e45843f6f105d416da3ddacb475d2cd16",
  "original_prompt": "Ingested from linux-6.6.14/drivers/parport/parport_ip32.c",
  "human_readable_source": "\n \n\n \n\n \n\n \n\n \n#if !defined(DEBUG_PARPORT_IP32)\n#\tdefine DEBUG_PARPORT_IP32  0\t \n#endif\n\n \n\n \n#if DEBUG_PARPORT_IP32 == 1\n#\twarning DEBUG_PARPORT_IP32 == 1\n#elif DEBUG_PARPORT_IP32 == 2\n#\twarning DEBUG_PARPORT_IP32 == 2\n#elif DEBUG_PARPORT_IP32 >= 3\n#\twarning DEBUG_PARPORT_IP32 >= 3\n#\tif !defined(DEBUG)\n#\t\tdefine DEBUG  \n#\tendif\n#endif\n\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/dma-mapping.h>\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/parport.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n#include <asm/io.h>\n#include <asm/ip32/ip32_ints.h>\n#include <asm/ip32/mace.h>\n\n \n\n \n#if DEBUG_PARPORT_IP32 >= 1\n#\tdefine DEFAULT_VERBOSE_PROBING\t1\n#else\n#\tdefine DEFAULT_VERBOSE_PROBING\t0\n#endif\n\n \n#define PPIP32 \"parport_ip32: \"\n\n \n#define PARPORT_IP32_ENABLE_IRQ\t(1U << 0)\n#define PARPORT_IP32_ENABLE_DMA\t(1U << 1)\n#define PARPORT_IP32_ENABLE_SPP\t(1U << 2)\n#define PARPORT_IP32_ENABLE_EPP\t(1U << 3)\n#define PARPORT_IP32_ENABLE_ECP\t(1U << 4)\nstatic unsigned int features =\t~0U;\nstatic bool verbose_probing =\tDEFAULT_VERBOSE_PROBING;\n\n \nstatic struct parport *this_port;\n\n \n#define FIFO_NFAULT_TIMEOUT\t100\t \n#define FIFO_POLLING_INTERVAL\t50\t \n\n \n\n \nstruct parport_ip32_regs {\n\tvoid __iomem *data;\n\tvoid __iomem *dsr;\n\tvoid __iomem *dcr;\n\tvoid __iomem *eppAddr;\n\tvoid __iomem *eppData0;\n\tvoid __iomem *eppData1;\n\tvoid __iomem *eppData2;\n\tvoid __iomem *eppData3;\n\tvoid __iomem *ecpAFifo;\n\tvoid __iomem *fifo;\n\tvoid __iomem *cnfgA;\n\tvoid __iomem *cnfgB;\n\tvoid __iomem *ecr;\n};\n\n \n#define DSR_nBUSY\t\t(1U << 7)\t \n#define DSR_nACK\t\t(1U << 6)\t \n#define DSR_PERROR\t\t(1U << 5)\t \n#define DSR_SELECT\t\t(1U << 4)\t \n#define DSR_nFAULT\t\t(1U << 3)\t \n#define DSR_nPRINT\t\t(1U << 2)\t \n \n#define DSR_TIMEOUT\t\t(1U << 0)\t \n\n \n \n#define DCR_DIR\t\t\t(1U << 5)\t \n#define DCR_IRQ\t\t\t(1U << 4)\t \n#define DCR_SELECT\t\t(1U << 3)\t \n#define DCR_nINIT\t\t(1U << 2)\t \n#define DCR_AUTOFD\t\t(1U << 1)\t \n#define DCR_STROBE\t\t(1U << 0)\t \n\n \n#define CNFGA_IRQ\t\t(1U << 7)\n#define CNFGA_ID_MASK\t\t((1U << 6) | (1U << 5) | (1U << 4))\n#define CNFGA_ID_SHIFT\t\t4\n#define CNFGA_ID_16\t\t(00U << CNFGA_ID_SHIFT)\n#define CNFGA_ID_8\t\t(01U << CNFGA_ID_SHIFT)\n#define CNFGA_ID_32\t\t(02U << CNFGA_ID_SHIFT)\n \n#define CNFGA_nBYTEINTRANS\t(1U << 2)\n#define CNFGA_PWORDLEFT\t\t((1U << 1) | (1U << 0))\n\n \n#define CNFGB_COMPRESS\t\t(1U << 7)\n#define CNFGB_INTRVAL\t\t(1U << 6)\n#define CNFGB_IRQ_MASK\t\t((1U << 5) | (1U << 4) | (1U << 3))\n#define CNFGB_IRQ_SHIFT\t\t3\n#define CNFGB_DMA_MASK\t\t((1U << 2) | (1U << 1) | (1U << 0))\n#define CNFGB_DMA_SHIFT\t\t0\n\n \n#define ECR_MODE_MASK\t\t((1U << 7) | (1U << 6) | (1U << 5))\n#define ECR_MODE_SHIFT\t\t5\n#define ECR_MODE_SPP\t\t(00U << ECR_MODE_SHIFT)\n#define ECR_MODE_PS2\t\t(01U << ECR_MODE_SHIFT)\n#define ECR_MODE_PPF\t\t(02U << ECR_MODE_SHIFT)\n#define ECR_MODE_ECP\t\t(03U << ECR_MODE_SHIFT)\n#define ECR_MODE_EPP\t\t(04U << ECR_MODE_SHIFT)\n \n#define ECR_MODE_TST\t\t(06U << ECR_MODE_SHIFT)\n#define ECR_MODE_CFG\t\t(07U << ECR_MODE_SHIFT)\n#define ECR_nERRINTR\t\t(1U << 4)\n#define ECR_DMAEN\t\t(1U << 3)\n#define ECR_SERVINTR\t\t(1U << 2)\n#define ECR_F_FULL\t\t(1U << 1)\n#define ECR_F_EMPTY\t\t(1U << 0)\n\n \n\n \nenum parport_ip32_irq_mode { PARPORT_IP32_IRQ_FWD, PARPORT_IP32_IRQ_HERE };\n\n \nstruct parport_ip32_private {\n\tstruct parport_ip32_regs\tregs;\n\tunsigned int\t\t\tdcr_cache;\n\tunsigned int\t\t\tdcr_writable;\n\tunsigned int\t\t\tpword;\n\tunsigned int\t\t\tfifo_depth;\n\tunsigned int\t\t\treadIntrThreshold;\n\tunsigned int\t\t\twriteIntrThreshold;\n\tenum parport_ip32_irq_mode\tirq_mode;\n\tstruct completion\t\tirq_complete;\n};\n\n \n\n \n#if DEBUG_PARPORT_IP32 >= 1\n#\tdefine pr_debug1(...)\tprintk(KERN_DEBUG __VA_ARGS__)\n#else  \n#\tdefine pr_debug1(...)\tdo { } while (0)\n#endif\n\n \n#define __pr_trace(pr, p, fmt, ...)\t\t\t\t\t\\\n\tpr(\"%s: %s\" fmt \"\\n\",\t\t\t\t\t\t\\\n\t   ({ const struct parport *__p = (p);\t\t\t\t\\\n\t\t   __p ? __p->name : \"parport_ip32\"; }),\t\t\\\n\t   __func__ , ##__VA_ARGS__)\n#define pr_trace(p, fmt, ...)\t__pr_trace(pr_debug, p, fmt , ##__VA_ARGS__)\n#define pr_trace1(p, fmt, ...)\t__pr_trace(pr_debug1, p, fmt , ##__VA_ARGS__)\n\n \n#define __pr_probe(...)\t\t\t\t\t\t\t\\\n\tdo { if (verbose_probing) printk(__VA_ARGS__); } while (0)\n#define pr_probe(p, fmt, ...)\t\t\t\t\t\t\\\n\t__pr_probe(KERN_INFO PPIP32 \"0x%lx: \" fmt, (p)->base , ##__VA_ARGS__)\n\n \n#if DEBUG_PARPORT_IP32 >= 2\nstatic void parport_ip32_dump_state(struct parport *p, char *str,\n\t\t\t\t    unsigned int show_ecp_config)\n{\n\tstruct parport_ip32_private * const priv = p->physport->private_data;\n\tunsigned int i;\n\n\tprintk(KERN_DEBUG PPIP32 \"%s: state (%s):\\n\", p->name, str);\n\t{\n\t\tstatic const char ecr_modes[8][4] = {\"SPP\", \"PS2\", \"PPF\",\n\t\t\t\t\t\t     \"ECP\", \"EPP\", \"???\",\n\t\t\t\t\t\t     \"TST\", \"CFG\"};\n\t\tunsigned int ecr = readb(priv->regs.ecr);\n\t\tprintk(KERN_DEBUG PPIP32 \"    ecr=0x%02x\", ecr);\n\t\tpr_cont(\" %s\",\n\t\t\tecr_modes[(ecr & ECR_MODE_MASK) >> ECR_MODE_SHIFT]);\n\t\tif (ecr & ECR_nERRINTR)\n\t\t\tpr_cont(\",nErrIntrEn\");\n\t\tif (ecr & ECR_DMAEN)\n\t\t\tpr_cont(\",dmaEn\");\n\t\tif (ecr & ECR_SERVINTR)\n\t\t\tpr_cont(\",serviceIntr\");\n\t\tif (ecr & ECR_F_FULL)\n\t\t\tpr_cont(\",f_full\");\n\t\tif (ecr & ECR_F_EMPTY)\n\t\t\tpr_cont(\",f_empty\");\n\t\tpr_cont(\"\\n\");\n\t}\n\tif (show_ecp_config) {\n\t\tunsigned int oecr, cnfgA, cnfgB;\n\t\toecr = readb(priv->regs.ecr);\n\t\twriteb(ECR_MODE_PS2, priv->regs.ecr);\n\t\twriteb(ECR_MODE_CFG, priv->regs.ecr);\n\t\tcnfgA = readb(priv->regs.cnfgA);\n\t\tcnfgB = readb(priv->regs.cnfgB);\n\t\twriteb(ECR_MODE_PS2, priv->regs.ecr);\n\t\twriteb(oecr, priv->regs.ecr);\n\t\tprintk(KERN_DEBUG PPIP32 \"    cnfgA=0x%02x\", cnfgA);\n\t\tpr_cont(\" ISA-%s\", (cnfgA & CNFGA_IRQ) ? \"Level\" : \"Pulses\");\n\t\tswitch (cnfgA & CNFGA_ID_MASK) {\n\t\tcase CNFGA_ID_8:\n\t\t\tpr_cont(\",8 bits\");\n\t\t\tbreak;\n\t\tcase CNFGA_ID_16:\n\t\t\tpr_cont(\",16 bits\");\n\t\t\tbreak;\n\t\tcase CNFGA_ID_32:\n\t\t\tpr_cont(\",32 bits\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_cont(\",unknown ID\");\n\t\t\tbreak;\n\t\t}\n\t\tif (!(cnfgA & CNFGA_nBYTEINTRANS))\n\t\t\tpr_cont(\",ByteInTrans\");\n\t\tif ((cnfgA & CNFGA_ID_MASK) != CNFGA_ID_8)\n\t\t\tpr_cont(\",%d byte%s left\",\n\t\t\t\tcnfgA & CNFGA_PWORDLEFT,\n\t\t\t\t((cnfgA & CNFGA_PWORDLEFT) > 1) ? \"s\" : \"\");\n\t\tpr_cont(\"\\n\");\n\t\tprintk(KERN_DEBUG PPIP32 \"    cnfgB=0x%02x\", cnfgB);\n\t\tpr_cont(\" irq=%u,dma=%u\",\n\t\t\t(cnfgB & CNFGB_IRQ_MASK) >> CNFGB_IRQ_SHIFT,\n\t\t\t(cnfgB & CNFGB_DMA_MASK) >> CNFGB_DMA_SHIFT);\n\t\tpr_cont(\",intrValue=%d\", !!(cnfgB & CNFGB_INTRVAL));\n\t\tif (cnfgB & CNFGB_COMPRESS)\n\t\t\tpr_cont(\",compress\");\n\t\tpr_cont(\"\\n\");\n\t}\n\tfor (i = 0; i < 2; i++) {\n\t\tunsigned int dcr = i ? priv->dcr_cache : readb(priv->regs.dcr);\n\t\tprintk(KERN_DEBUG PPIP32 \"    dcr(%s)=0x%02x\",\n\t\t       i ? \"soft\" : \"hard\", dcr);\n\t\tpr_cont(\" %s\", (dcr & DCR_DIR) ? \"rev\" : \"fwd\");\n\t\tif (dcr & DCR_IRQ)\n\t\t\tpr_cont(\",ackIntEn\");\n\t\tif (!(dcr & DCR_SELECT))\n\t\t\tpr_cont(\",nSelectIn\");\n\t\tif (dcr & DCR_nINIT)\n\t\t\tpr_cont(\",nInit\");\n\t\tif (!(dcr & DCR_AUTOFD))\n\t\t\tpr_cont(\",nAutoFD\");\n\t\tif (!(dcr & DCR_STROBE))\n\t\t\tpr_cont(\",nStrobe\");\n\t\tpr_cont(\"\\n\");\n\t}\n#define sep (f++ ? ',' : ' ')\n\t{\n\t\tunsigned int f = 0;\n\t\tunsigned int dsr = readb(priv->regs.dsr);\n\t\tprintk(KERN_DEBUG PPIP32 \"    dsr=0x%02x\", dsr);\n\t\tif (!(dsr & DSR_nBUSY))\n\t\t\tpr_cont(\"%cBusy\", sep);\n\t\tif (dsr & DSR_nACK)\n\t\t\tpr_cont(\"%cnAck\", sep);\n\t\tif (dsr & DSR_PERROR)\n\t\t\tpr_cont(\"%cPError\", sep);\n\t\tif (dsr & DSR_SELECT)\n\t\t\tpr_cont(\"%cSelect\", sep);\n\t\tif (dsr & DSR_nFAULT)\n\t\t\tpr_cont(\"%cnFault\", sep);\n\t\tif (!(dsr & DSR_nPRINT))\n\t\t\tpr_cont(\"%c(Print)\", sep);\n\t\tif (dsr & DSR_TIMEOUT)\n\t\t\tpr_cont(\"%cTimeout\", sep);\n\t\tpr_cont(\"\\n\");\n\t}\n#undef sep\n}\n#else  \n#define parport_ip32_dump_state(...)\tdo { } while (0)\n#endif\n\n \n#if DEBUG_PARPORT_IP32 >= 1\n#define CHECK_EXTRA_BITS(p, b, m)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tunsigned int __b = (b), __m = (m);\t\t\t\\\n\t\tif (__b & ~__m)\t\t\t\t\t\t\\\n\t\t\tpr_debug1(PPIP32 \"%s: extra bits in %s(%s): \"\t\\\n\t\t\t\t  \"0x%02x/0x%02x\\n\",\t\t\t\\\n\t\t\t\t  (p)->name, __func__, #b, __b, __m);\t\\\n\t} while (0)\n#else  \n#define CHECK_EXTRA_BITS(...)\tdo { } while (0)\n#endif\n\n \n\n \nstruct parport_ip32_dma_data {\n\tenum dma_data_direction\t\tdir;\n\tdma_addr_t\t\t\tbuf;\n\tdma_addr_t\t\t\tnext;\n\tsize_t\t\t\t\tlen;\n\tsize_t\t\t\t\tleft;\n\tunsigned int\t\t\tctx;\n\tunsigned int\t\t\tirq_on;\n\tspinlock_t\t\t\tlock;\n};\nstatic struct parport_ip32_dma_data parport_ip32_dma;\n\n \nstatic void parport_ip32_dma_setup_context(unsigned int limit)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&parport_ip32_dma.lock, flags);\n\tif (parport_ip32_dma.left > 0) {\n\t\t \n\t\tvolatile u64 __iomem *ctxreg = (parport_ip32_dma.ctx == 0) ?\n\t\t\t&mace->perif.ctrl.parport.context_a :\n\t\t\t&mace->perif.ctrl.parport.context_b;\n\t\tu64 count;\n\t\tu64 ctxval;\n\t\tif (parport_ip32_dma.left <= limit) {\n\t\t\tcount = parport_ip32_dma.left;\n\t\t\tctxval = MACEPAR_CONTEXT_LASTFLAG;\n\t\t} else {\n\t\t\tcount = limit;\n\t\t\tctxval = 0;\n\t\t}\n\n\t\tpr_trace(NULL,\n\t\t\t \"(%u): 0x%04x:0x%04x, %u -> %u%s\",\n\t\t\t limit,\n\t\t\t (unsigned int)parport_ip32_dma.buf,\n\t\t\t (unsigned int)parport_ip32_dma.next,\n\t\t\t (unsigned int)count,\n\t\t\t parport_ip32_dma.ctx, ctxval ? \"*\" : \"\");\n\n\t\tctxval |= parport_ip32_dma.next &\n\t\t\tMACEPAR_CONTEXT_BASEADDR_MASK;\n\t\tctxval |= ((count - 1) << MACEPAR_CONTEXT_DATALEN_SHIFT) &\n\t\t\tMACEPAR_CONTEXT_DATALEN_MASK;\n\t\twriteq(ctxval, ctxreg);\n\t\tparport_ip32_dma.next += count;\n\t\tparport_ip32_dma.left -= count;\n\t\tparport_ip32_dma.ctx ^= 1U;\n\t}\n\t \n\tif (parport_ip32_dma.left == 0 && parport_ip32_dma.irq_on) {\n\t\tpr_debug(PPIP32 \"IRQ off (ctx)\\n\");\n\t\tdisable_irq_nosync(MACEISA_PAR_CTXA_IRQ);\n\t\tdisable_irq_nosync(MACEISA_PAR_CTXB_IRQ);\n\t\tparport_ip32_dma.irq_on = 0;\n\t}\n\tspin_unlock_irqrestore(&parport_ip32_dma.lock, flags);\n}\n\n \nstatic irqreturn_t parport_ip32_dma_interrupt(int irq, void *dev_id)\n{\n\tif (parport_ip32_dma.left)\n\t\tpr_trace(NULL, \"(%d): ctx=%d\", irq, parport_ip32_dma.ctx);\n\tparport_ip32_dma_setup_context(MACEPAR_CONTEXT_DATA_BOUND);\n\treturn IRQ_HANDLED;\n}\n\n#if DEBUG_PARPORT_IP32\nstatic irqreturn_t parport_ip32_merr_interrupt(int irq, void *dev_id)\n{\n\tpr_trace1(NULL, \"(%d)\", irq);\n\treturn IRQ_HANDLED;\n}\n#endif\n\n \nstatic int parport_ip32_dma_start(struct parport *p,\n\t\tenum dma_data_direction dir, void *addr, size_t count)\n{\n\tunsigned int limit;\n\tu64 ctrl;\n\n\tpr_trace(NULL, \"(%d, %lu)\", dir, (unsigned long)count);\n\n\t \n\tBUG_ON(dir != DMA_TO_DEVICE);\n\n\t \n\tctrl = MACEPAR_CTLSTAT_RESET;\n\twriteq(ctrl, &mace->perif.ctrl.parport.cntlstat);\n\n\t \n\tif (!parport_ip32_dma.irq_on) {\n\t\tWARN_ON(1);\n\t\tenable_irq(MACEISA_PAR_CTXA_IRQ);\n\t\tenable_irq(MACEISA_PAR_CTXB_IRQ);\n\t\tparport_ip32_dma.irq_on = 1;\n\t}\n\n\t \n\tparport_ip32_dma.dir = dir;\n\tparport_ip32_dma.buf = dma_map_single(&p->bus_dev, addr, count, dir);\n\tparport_ip32_dma.len = count;\n\tparport_ip32_dma.next = parport_ip32_dma.buf;\n\tparport_ip32_dma.left = parport_ip32_dma.len;\n\tparport_ip32_dma.ctx = 0;\n\n\t \n\tctrl = (dir == DMA_TO_DEVICE) ? 0 : MACEPAR_CTLSTAT_DIRECTION;\n\twriteq(ctrl, &mace->perif.ctrl.parport.cntlstat);\n\t \n\tlimit = MACEPAR_CONTEXT_DATA_BOUND -\n\t\t(parport_ip32_dma.next & (MACEPAR_CONTEXT_DATA_BOUND - 1));\n\tparport_ip32_dma_setup_context(limit);\n\tparport_ip32_dma_setup_context(MACEPAR_CONTEXT_DATA_BOUND);\n\n\t \n\tctrl |= MACEPAR_CTLSTAT_ENABLE;\n\twriteq(ctrl, &mace->perif.ctrl.parport.cntlstat);\n\n\treturn 0;\n}\n\n \nstatic void parport_ip32_dma_stop(struct parport *p)\n{\n\tu64 ctx_a;\n\tu64 ctx_b;\n\tu64 ctrl;\n\tu64 diag;\n\tsize_t res[2];\t \n\n\tpr_trace(NULL, \"()\");\n\n\t \n\tspin_lock_irq(&parport_ip32_dma.lock);\n\tif (parport_ip32_dma.irq_on) {\n\t\tpr_debug(PPIP32 \"IRQ off (stop)\\n\");\n\t\tdisable_irq_nosync(MACEISA_PAR_CTXA_IRQ);\n\t\tdisable_irq_nosync(MACEISA_PAR_CTXB_IRQ);\n\t\tparport_ip32_dma.irq_on = 0;\n\t}\n\tspin_unlock_irq(&parport_ip32_dma.lock);\n\t \n\tsynchronize_irq(MACEISA_PAR_CTXA_IRQ);\n\tsynchronize_irq(MACEISA_PAR_CTXB_IRQ);\n\n\t \n\tctrl = readq(&mace->perif.ctrl.parport.cntlstat);\n\tctrl &= ~MACEPAR_CTLSTAT_ENABLE;\n\twriteq(ctrl, &mace->perif.ctrl.parport.cntlstat);\n\n\t \n\tctx_a = readq(&mace->perif.ctrl.parport.context_a);\n\tctx_b = readq(&mace->perif.ctrl.parport.context_b);\n\tctrl = readq(&mace->perif.ctrl.parport.cntlstat);\n\tdiag = readq(&mace->perif.ctrl.parport.diagnostic);\n\tres[0] = (ctrl & MACEPAR_CTLSTAT_CTXA_VALID) ?\n\t\t1 + ((ctx_a & MACEPAR_CONTEXT_DATALEN_MASK) >>\n\t\t     MACEPAR_CONTEXT_DATALEN_SHIFT) :\n\t\t0;\n\tres[1] = (ctrl & MACEPAR_CTLSTAT_CTXB_VALID) ?\n\t\t1 + ((ctx_b & MACEPAR_CONTEXT_DATALEN_MASK) >>\n\t\t     MACEPAR_CONTEXT_DATALEN_SHIFT) :\n\t\t0;\n\tif (diag & MACEPAR_DIAG_DMACTIVE)\n\t\tres[(diag & MACEPAR_DIAG_CTXINUSE) != 0] =\n\t\t\t1 + ((diag & MACEPAR_DIAG_CTRMASK) >>\n\t\t\t     MACEPAR_DIAG_CTRSHIFT);\n\tparport_ip32_dma.left += res[0] + res[1];\n\n\t \n\tctrl = MACEPAR_CTLSTAT_RESET;\n\twriteq(ctrl, &mace->perif.ctrl.parport.cntlstat);\n\tpr_debug(PPIP32 \"IRQ on (stop)\\n\");\n\tenable_irq(MACEISA_PAR_CTXA_IRQ);\n\tenable_irq(MACEISA_PAR_CTXB_IRQ);\n\tparport_ip32_dma.irq_on = 1;\n\n\tdma_unmap_single(&p->bus_dev, parport_ip32_dma.buf,\n\t\t\t parport_ip32_dma.len, parport_ip32_dma.dir);\n}\n\n \nstatic inline size_t parport_ip32_dma_get_residue(void)\n{\n\treturn parport_ip32_dma.left;\n}\n\n \nstatic int parport_ip32_dma_register(void)\n{\n\tint err;\n\n\tspin_lock_init(&parport_ip32_dma.lock);\n\tparport_ip32_dma.irq_on = 1;\n\n\t \n\twriteq(MACEPAR_CTLSTAT_RESET, &mace->perif.ctrl.parport.cntlstat);\n\n\t \n\terr = request_irq(MACEISA_PAR_CTXA_IRQ, parport_ip32_dma_interrupt,\n\t\t\t  0, \"parport_ip32\", NULL);\n\tif (err)\n\t\tgoto fail_a;\n\terr = request_irq(MACEISA_PAR_CTXB_IRQ, parport_ip32_dma_interrupt,\n\t\t\t  0, \"parport_ip32\", NULL);\n\tif (err)\n\t\tgoto fail_b;\n#if DEBUG_PARPORT_IP32\n\t \n\terr = request_irq(MACEISA_PAR_MERR_IRQ, parport_ip32_merr_interrupt,\n\t\t\t  0, \"parport_ip32\", NULL);\n\tif (err)\n\t\tgoto fail_merr;\n#endif\n\treturn 0;\n\n#if DEBUG_PARPORT_IP32\nfail_merr:\n\tfree_irq(MACEISA_PAR_CTXB_IRQ, NULL);\n#endif\nfail_b:\n\tfree_irq(MACEISA_PAR_CTXA_IRQ, NULL);\nfail_a:\n\treturn err;\n}\n\n \nstatic void parport_ip32_dma_unregister(void)\n{\n#if DEBUG_PARPORT_IP32\n\tfree_irq(MACEISA_PAR_MERR_IRQ, NULL);\n#endif\n\tfree_irq(MACEISA_PAR_CTXB_IRQ, NULL);\n\tfree_irq(MACEISA_PAR_CTXA_IRQ, NULL);\n}\n\n \n\n \nstatic inline void parport_ip32_wakeup(struct parport *p)\n{\n\tstruct parport_ip32_private * const priv = p->physport->private_data;\n\tcomplete(&priv->irq_complete);\n}\n\n \nstatic irqreturn_t parport_ip32_interrupt(int irq, void *dev_id)\n{\n\tstruct parport * const p = dev_id;\n\tstruct parport_ip32_private * const priv = p->physport->private_data;\n\tenum parport_ip32_irq_mode irq_mode = priv->irq_mode;\n\n\tswitch (irq_mode) {\n\tcase PARPORT_IP32_IRQ_FWD:\n\t\treturn parport_irq_handler(irq, dev_id);\n\n\tcase PARPORT_IP32_IRQ_HERE:\n\t\tparport_ip32_wakeup(p);\n\t\tbreak;\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\n \n\n \nstatic inline unsigned int parport_ip32_read_econtrol(struct parport *p)\n{\n\tstruct parport_ip32_private * const priv = p->physport->private_data;\n\treturn readb(priv->regs.ecr);\n}\n\n \nstatic inline void parport_ip32_write_econtrol(struct parport *p,\n\t\t\t\t\t       unsigned int c)\n{\n\tstruct parport_ip32_private * const priv = p->physport->private_data;\n\twriteb(c, priv->regs.ecr);\n}\n\n \nstatic inline void parport_ip32_frob_econtrol(struct parport *p,\n\t\t\t\t\t      unsigned int mask,\n\t\t\t\t\t      unsigned int val)\n{\n\tunsigned int c;\n\tc = (parport_ip32_read_econtrol(p) & ~mask) ^ val;\n\tparport_ip32_write_econtrol(p, c);\n}\n\n \nstatic void parport_ip32_set_mode(struct parport *p, unsigned int mode)\n{\n\tunsigned int omode;\n\n\tmode &= ECR_MODE_MASK;\n\tomode = parport_ip32_read_econtrol(p) & ECR_MODE_MASK;\n\n\tif (!(mode == ECR_MODE_SPP || mode == ECR_MODE_PS2\n\t      || omode == ECR_MODE_SPP || omode == ECR_MODE_PS2)) {\n\t\t \n\t\tunsigned int ecr = ECR_MODE_PS2 | ECR_nERRINTR | ECR_SERVINTR;\n\t\tparport_ip32_write_econtrol(p, ecr);\n\t}\n\tparport_ip32_write_econtrol(p, mode | ECR_nERRINTR | ECR_SERVINTR);\n}\n\n \n\n \nstatic inline unsigned char parport_ip32_read_data(struct parport *p)\n{\n\tstruct parport_ip32_private * const priv = p->physport->private_data;\n\treturn readb(priv->regs.data);\n}\n\n \nstatic inline void parport_ip32_write_data(struct parport *p, unsigned char d)\n{\n\tstruct parport_ip32_private * const priv = p->physport->private_data;\n\twriteb(d, priv->regs.data);\n}\n\n \nstatic inline unsigned char parport_ip32_read_status(struct parport *p)\n{\n\tstruct parport_ip32_private * const priv = p->physport->private_data;\n\treturn readb(priv->regs.dsr);\n}\n\n \nstatic inline unsigned int __parport_ip32_read_control(struct parport *p)\n{\n\tstruct parport_ip32_private * const priv = p->physport->private_data;\n\treturn priv->dcr_cache;  \n}\n\n \nstatic inline void __parport_ip32_write_control(struct parport *p,\n\t\t\t\t\t\tunsigned int c)\n{\n\tstruct parport_ip32_private * const priv = p->physport->private_data;\n\tCHECK_EXTRA_BITS(p, c, priv->dcr_writable);\n\tc &= priv->dcr_writable;  \n\twriteb(c, priv->regs.dcr);\n\tpriv->dcr_cache = c;\t\t \n}\n\n \nstatic inline void __parport_ip32_frob_control(struct parport *p,\n\t\t\t\t\t       unsigned int mask,\n\t\t\t\t\t       unsigned int val)\n{\n\tunsigned int c;\n\tc = (__parport_ip32_read_control(p) & ~mask) ^ val;\n\t__parport_ip32_write_control(p, c);\n}\n\n \nstatic inline unsigned char parport_ip32_read_control(struct parport *p)\n{\n\tconst unsigned int rm =\n\t\tDCR_STROBE | DCR_AUTOFD | DCR_nINIT | DCR_SELECT;\n\treturn __parport_ip32_read_control(p) & rm;\n}\n\n \nstatic inline void parport_ip32_write_control(struct parport *p,\n\t\t\t\t\t      unsigned char c)\n{\n\tconst unsigned int wm =\n\t\tDCR_STROBE | DCR_AUTOFD | DCR_nINIT | DCR_SELECT;\n\tCHECK_EXTRA_BITS(p, c, wm);\n\t__parport_ip32_frob_control(p, wm, c & wm);\n}\n\n \nstatic inline unsigned char parport_ip32_frob_control(struct parport *p,\n\t\t\t\t\t\t      unsigned char mask,\n\t\t\t\t\t\t      unsigned char val)\n{\n\tconst unsigned int wm =\n\t\tDCR_STROBE | DCR_AUTOFD | DCR_nINIT | DCR_SELECT;\n\tCHECK_EXTRA_BITS(p, mask, wm);\n\tCHECK_EXTRA_BITS(p, val, wm);\n\t__parport_ip32_frob_control(p, mask & wm, val & wm);\n\treturn parport_ip32_read_control(p);\n}\n\n \nstatic inline void parport_ip32_disable_irq(struct parport *p)\n{\n\t__parport_ip32_frob_control(p, DCR_IRQ, 0);\n}\n\n \nstatic inline void parport_ip32_enable_irq(struct parport *p)\n{\n\t__parport_ip32_frob_control(p, DCR_IRQ, DCR_IRQ);\n}\n\n \nstatic inline void parport_ip32_data_forward(struct parport *p)\n{\n\t__parport_ip32_frob_control(p, DCR_DIR, 0);\n}\n\n \nstatic inline void parport_ip32_data_reverse(struct parport *p)\n{\n\t__parport_ip32_frob_control(p, DCR_DIR, DCR_DIR);\n}\n\n \nstatic void parport_ip32_init_state(struct pardevice *dev,\n\t\t\t\t    struct parport_state *s)\n{\n\ts->u.ip32.dcr = DCR_SELECT | DCR_nINIT;\n\ts->u.ip32.ecr = ECR_MODE_PS2 | ECR_nERRINTR | ECR_SERVINTR;\n}\n\n \nstatic void parport_ip32_save_state(struct parport *p,\n\t\t\t\t    struct parport_state *s)\n{\n\ts->u.ip32.dcr = __parport_ip32_read_control(p);\n\ts->u.ip32.ecr = parport_ip32_read_econtrol(p);\n}\n\n \nstatic void parport_ip32_restore_state(struct parport *p,\n\t\t\t\t       struct parport_state *s)\n{\n\tparport_ip32_set_mode(p, s->u.ip32.ecr & ECR_MODE_MASK);\n\tparport_ip32_write_econtrol(p, s->u.ip32.ecr);\n\t__parport_ip32_write_control(p, s->u.ip32.dcr);\n}\n\n \n\n \nstatic unsigned int parport_ip32_clear_epp_timeout(struct parport *p)\n{\n\tstruct parport_ip32_private * const priv = p->physport->private_data;\n\tunsigned int cleared;\n\n\tif (!(parport_ip32_read_status(p) & DSR_TIMEOUT))\n\t\tcleared = 1;\n\telse {\n\t\tunsigned int r;\n\t\t \n\t\tparport_ip32_read_status(p);\n\t\tr = parport_ip32_read_status(p);\n\t\t \n\t\twriteb(r | DSR_TIMEOUT, priv->regs.dsr);\n\t\t \n\t\twriteb(r & ~DSR_TIMEOUT, priv->regs.dsr);\n\n\t\tr = parport_ip32_read_status(p);\n\t\tcleared = !(r & DSR_TIMEOUT);\n\t}\n\n\tpr_trace(p, \"(): %s\", cleared ? \"cleared\" : \"failed\");\n\treturn cleared;\n}\n\n \nstatic size_t parport_ip32_epp_read(void __iomem *eppreg,\n\t\t\t\t    struct parport *p, void *buf,\n\t\t\t\t    size_t len, int flags)\n{\n\tstruct parport_ip32_private * const priv = p->physport->private_data;\n\tsize_t got;\n\tparport_ip32_set_mode(p, ECR_MODE_EPP);\n\tparport_ip32_data_reverse(p);\n\tparport_ip32_write_control(p, DCR_nINIT);\n\tif ((flags & PARPORT_EPP_FAST) && (len > 1)) {\n\t\treadsb(eppreg, buf, len);\n\t\tif (readb(priv->regs.dsr) & DSR_TIMEOUT) {\n\t\t\tparport_ip32_clear_epp_timeout(p);\n\t\t\treturn -EIO;\n\t\t}\n\t\tgot = len;\n\t} else {\n\t\tu8 *bufp = buf;\n\t\tfor (got = 0; got < len; got++) {\n\t\t\t*bufp++ = readb(eppreg);\n\t\t\tif (readb(priv->regs.dsr) & DSR_TIMEOUT) {\n\t\t\t\tparport_ip32_clear_epp_timeout(p);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tparport_ip32_data_forward(p);\n\tparport_ip32_set_mode(p, ECR_MODE_PS2);\n\treturn got;\n}\n\n \nstatic size_t parport_ip32_epp_write(void __iomem *eppreg,\n\t\t\t\t     struct parport *p, const void *buf,\n\t\t\t\t     size_t len, int flags)\n{\n\tstruct parport_ip32_private * const priv = p->physport->private_data;\n\tsize_t written;\n\tparport_ip32_set_mode(p, ECR_MODE_EPP);\n\tparport_ip32_data_forward(p);\n\tparport_ip32_write_control(p, DCR_nINIT);\n\tif ((flags & PARPORT_EPP_FAST) && (len > 1)) {\n\t\twritesb(eppreg, buf, len);\n\t\tif (readb(priv->regs.dsr) & DSR_TIMEOUT) {\n\t\t\tparport_ip32_clear_epp_timeout(p);\n\t\t\treturn -EIO;\n\t\t}\n\t\twritten = len;\n\t} else {\n\t\tconst u8 *bufp = buf;\n\t\tfor (written = 0; written < len; written++) {\n\t\t\twriteb(*bufp++, eppreg);\n\t\t\tif (readb(priv->regs.dsr) & DSR_TIMEOUT) {\n\t\t\t\tparport_ip32_clear_epp_timeout(p);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tparport_ip32_set_mode(p, ECR_MODE_PS2);\n\treturn written;\n}\n\n \nstatic size_t parport_ip32_epp_read_data(struct parport *p, void *buf,\n\t\t\t\t\t size_t len, int flags)\n{\n\tstruct parport_ip32_private * const priv = p->physport->private_data;\n\treturn parport_ip32_epp_read(priv->regs.eppData0, p, buf, len, flags);\n}\n\n \nstatic size_t parport_ip32_epp_write_data(struct parport *p, const void *buf,\n\t\t\t\t\t  size_t len, int flags)\n{\n\tstruct parport_ip32_private * const priv = p->physport->private_data;\n\treturn parport_ip32_epp_write(priv->regs.eppData0, p, buf, len, flags);\n}\n\n \nstatic size_t parport_ip32_epp_read_addr(struct parport *p, void *buf,\n\t\t\t\t\t size_t len, int flags)\n{\n\tstruct parport_ip32_private * const priv = p->physport->private_data;\n\treturn parport_ip32_epp_read(priv->regs.eppAddr, p, buf, len, flags);\n}\n\n \nstatic size_t parport_ip32_epp_write_addr(struct parport *p, const void *buf,\n\t\t\t\t\t  size_t len, int flags)\n{\n\tstruct parport_ip32_private * const priv = p->physport->private_data;\n\treturn parport_ip32_epp_write(priv->regs.eppAddr, p, buf, len, flags);\n}\n\n \n\n \nstatic unsigned int parport_ip32_fifo_wait_break(struct parport *p,\n\t\t\t\t\t\t unsigned long expire)\n{\n\tcond_resched();\n\tif (time_after(jiffies, expire)) {\n\t\tpr_debug1(PPIP32 \"%s: FIFO write timed out\\n\", p->name);\n\t\treturn 1;\n\t}\n\tif (signal_pending(current)) {\n\t\tpr_debug1(PPIP32 \"%s: Signal pending\\n\", p->name);\n\t\treturn 1;\n\t}\n\tif (!(parport_ip32_read_status(p) & DSR_nFAULT)) {\n\t\tpr_debug1(PPIP32 \"%s: nFault asserted low\\n\", p->name);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n \nstatic unsigned int parport_ip32_fwp_wait_polling(struct parport *p)\n{\n\tstruct parport_ip32_private * const priv = p->physport->private_data;\n\tstruct parport * const physport = p->physport;\n\tunsigned long expire;\n\tunsigned int count;\n\tunsigned int ecr;\n\n\texpire = jiffies + physport->cad->timeout;\n\tcount = 0;\n\twhile (1) {\n\t\tif (parport_ip32_fifo_wait_break(p, expire))\n\t\t\tbreak;\n\n\t\t \n\t\tecr = parport_ip32_read_econtrol(p);\n\t\tif (ecr & ECR_F_EMPTY) {\n\t\t\t \n\t\t\tcount = priv->fifo_depth;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tudelay(FIFO_POLLING_INTERVAL);\n\t}  \n\n\treturn count;\n}\n\n \nstatic unsigned int parport_ip32_fwp_wait_interrupt(struct parport *p)\n{\n\tstatic unsigned int lost_interrupt = 0;\n\tstruct parport_ip32_private * const priv = p->physport->private_data;\n\tstruct parport * const physport = p->physport;\n\tunsigned long nfault_timeout;\n\tunsigned long expire;\n\tunsigned int count;\n\tunsigned int ecr;\n\n\tnfault_timeout = min((unsigned long)physport->cad->timeout,\n\t\t\t     msecs_to_jiffies(FIFO_NFAULT_TIMEOUT));\n\texpire = jiffies + physport->cad->timeout;\n\tcount = 0;\n\twhile (1) {\n\t\tif (parport_ip32_fifo_wait_break(p, expire))\n\t\t\tbreak;\n\n\t\t \n\t\treinit_completion(&priv->irq_complete);\n\n\t\t \n\t\tparport_ip32_frob_econtrol(p, ECR_SERVINTR, 0);\n\n\t\t \n\t\tecr = parport_ip32_read_econtrol(p);\n\t\tif (!(ecr & ECR_F_EMPTY)) {\n\t\t\t \n\t\t\twait_for_completion_interruptible_timeout(\n\t\t\t\t&priv->irq_complete, nfault_timeout);\n\t\t\tecr = parport_ip32_read_econtrol(p);\n\t\t\tif ((ecr & ECR_F_EMPTY) && !(ecr & ECR_SERVINTR)\n\t\t\t    && !lost_interrupt) {\n\t\t\t\tpr_warn(PPIP32 \"%s: lost interrupt in %s\\n\",\n\t\t\t\t\tp->name, __func__);\n\t\t\t\tlost_interrupt = 1;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tparport_ip32_frob_econtrol(p, ECR_SERVINTR, ECR_SERVINTR);\n\n\t\t \n\t\tif (ecr & ECR_F_EMPTY) {\n\t\t\t \n\t\t\tcount = priv->fifo_depth;\n\t\t\tbreak;\n\t\t} else if (ecr & ECR_SERVINTR) {\n\t\t\t \n\t\t\tcount = priv->writeIntrThreshold;\n\t\t\tbreak;\n\t\t}\n\t\t \n\t}  \n\n\treturn count;\n}\n\n \nstatic size_t parport_ip32_fifo_write_block_pio(struct parport *p,\n\t\t\t\t\t\tconst void *buf, size_t len)\n{\n\tstruct parport_ip32_private * const priv = p->physport->private_data;\n\tconst u8 *bufp = buf;\n\tsize_t left = len;\n\n\tpriv->irq_mode = PARPORT_IP32_IRQ_HERE;\n\n\twhile (left > 0) {\n\t\tunsigned int count;\n\n\t\tcount = (p->irq == PARPORT_IRQ_NONE) ?\n\t\t\tparport_ip32_fwp_wait_polling(p) :\n\t\t\tparport_ip32_fwp_wait_interrupt(p);\n\t\tif (count == 0)\n\t\t\tbreak;\t \n\t\tif (count > left)\n\t\t\tcount = left;\n\t\tif (count == 1) {\n\t\t\twriteb(*bufp, priv->regs.fifo);\n\t\t\tbufp++, left--;\n\t\t} else {\n\t\t\twritesb(priv->regs.fifo, bufp, count);\n\t\t\tbufp += count, left -= count;\n\t\t}\n\t}\n\n\tpriv->irq_mode = PARPORT_IP32_IRQ_FWD;\n\n\treturn len - left;\n}\n\n \nstatic size_t parport_ip32_fifo_write_block_dma(struct parport *p,\n\t\t\t\t\t\tconst void *buf, size_t len)\n{\n\tstruct parport_ip32_private * const priv = p->physport->private_data;\n\tstruct parport * const physport = p->physport;\n\tunsigned long nfault_timeout;\n\tunsigned long expire;\n\tsize_t written;\n\tunsigned int ecr;\n\n\tpriv->irq_mode = PARPORT_IP32_IRQ_HERE;\n\n\tparport_ip32_dma_start(p, DMA_TO_DEVICE, (void *)buf, len);\n\treinit_completion(&priv->irq_complete);\n\tparport_ip32_frob_econtrol(p, ECR_DMAEN | ECR_SERVINTR, ECR_DMAEN);\n\n\tnfault_timeout = min((unsigned long)physport->cad->timeout,\n\t\t\t     msecs_to_jiffies(FIFO_NFAULT_TIMEOUT));\n\texpire = jiffies + physport->cad->timeout;\n\twhile (1) {\n\t\tif (parport_ip32_fifo_wait_break(p, expire))\n\t\t\tbreak;\n\t\twait_for_completion_interruptible_timeout(&priv->irq_complete,\n\t\t\t\t\t\t\t  nfault_timeout);\n\t\tecr = parport_ip32_read_econtrol(p);\n\t\tif (ecr & ECR_SERVINTR)\n\t\t\tbreak;\t \n\t}\n\tparport_ip32_dma_stop(p);\n\twritten = len - parport_ip32_dma_get_residue();\n\n\tpriv->irq_mode = PARPORT_IP32_IRQ_FWD;\n\n\treturn written;\n}\n\n \nstatic size_t parport_ip32_fifo_write_block(struct parport *p,\n\t\t\t\t\t    const void *buf, size_t len)\n{\n\tsize_t written = 0;\n\tif (len)\n\t\t \n\t\twritten = (p->modes & PARPORT_MODE_DMA) ?\n\t\t\tparport_ip32_fifo_write_block_dma(p, buf, len) :\n\t\t\tparport_ip32_fifo_write_block_pio(p, buf, len);\n\treturn written;\n}\n\n \nstatic unsigned int parport_ip32_drain_fifo(struct parport *p,\n\t\t\t\t\t    unsigned long timeout)\n{\n\tunsigned long expire = jiffies + timeout;\n\tunsigned int polling_interval;\n\tunsigned int counter;\n\n\t \n\tfor (counter = 0; counter < 40; counter++) {\n\t\tif (parport_ip32_read_econtrol(p) & ECR_F_EMPTY)\n\t\t\tbreak;\n\t\tif (time_after(jiffies, expire))\n\t\t\tbreak;\n\t\tif (signal_pending(current))\n\t\t\tbreak;\n\t\tudelay(5);\n\t}\n\t \n\tpolling_interval = 1;  \n\twhile (!(parport_ip32_read_econtrol(p) & ECR_F_EMPTY)) {\n\t\tif (time_after_eq(jiffies, expire))\n\t\t\tbreak;\n\t\tmsleep_interruptible(polling_interval);\n\t\tif (signal_pending(current))\n\t\t\tbreak;\n\t\tif (polling_interval < 128)\n\t\t\tpolling_interval *= 2;\n\t}\n\n\treturn !!(parport_ip32_read_econtrol(p) & ECR_F_EMPTY);\n}\n\n \nstatic unsigned int parport_ip32_get_fifo_residue(struct parport *p,\n\t\t\t\t\t\t  unsigned int mode)\n{\n\tstruct parport_ip32_private * const priv = p->physport->private_data;\n\tunsigned int residue;\n\tunsigned int cnfga;\n\n\t \n\tif (parport_ip32_read_econtrol(p) & ECR_F_EMPTY)\n\t\tresidue = 0;\n\telse {\n\t\tpr_debug1(PPIP32 \"%s: FIFO is stuck\\n\", p->name);\n\n\t\t \n\t\tparport_ip32_frob_control(p, DCR_STROBE, 0);\n\n\t\t \n\t\tfor (residue = priv->fifo_depth; residue > 0; residue--) {\n\t\t\tif (parport_ip32_read_econtrol(p) & ECR_F_FULL)\n\t\t\t\tbreak;\n\t\t\twriteb(0x00, priv->regs.fifo);\n\t\t}\n\t}\n\tif (residue)\n\t\tpr_debug1(PPIP32 \"%s: %d PWord%s left in FIFO\\n\",\n\t\t\t  p->name, residue,\n\t\t\t  (residue == 1) ? \" was\" : \"s were\");\n\n\t \n\tparport_ip32_set_mode(p, ECR_MODE_PS2);\n\n\t \n\tif (mode == ECR_MODE_ECP) {\n\t\tparport_ip32_data_reverse(p);\n\t\tparport_ip32_frob_control(p, DCR_nINIT, 0);\n\t\tif (parport_wait_peripheral(p, DSR_PERROR, 0))\n\t\t\tpr_debug1(PPIP32 \"%s: PEerror timeout 1 in %s\\n\",\n\t\t\t\t  p->name, __func__);\n\t\tparport_ip32_frob_control(p, DCR_STROBE, DCR_STROBE);\n\t\tparport_ip32_frob_control(p, DCR_nINIT, DCR_nINIT);\n\t\tif (parport_wait_peripheral(p, DSR_PERROR, DSR_PERROR))\n\t\t\tpr_debug1(PPIP32 \"%s: PEerror timeout 2 in %s\\n\",\n\t\t\t\t  p->name, __func__);\n\t}\n\n\t \n\tparport_ip32_set_mode(p, ECR_MODE_CFG);\n\tcnfga = readb(priv->regs.cnfgA);\n\tif (!(cnfga & CNFGA_nBYTEINTRANS)) {\n\t\tpr_debug1(PPIP32 \"%s: cnfgA contains 0x%02x\\n\",\n\t\t\t  p->name, cnfga);\n\t\tpr_debug1(PPIP32 \"%s: Accounting for extra byte\\n\",\n\t\t\t  p->name);\n\t\tresidue++;\n\t}\n\n\t \n\n\t \n\tparport_ip32_set_mode(p, ECR_MODE_PS2);\n\tparport_ip32_data_forward(p);\n\n\treturn residue;\n}\n\n \nstatic size_t parport_ip32_compat_write_data(struct parport *p,\n\t\t\t\t\t     const void *buf, size_t len,\n\t\t\t\t\t     int flags)\n{\n\tstatic unsigned int ready_before = 1;\n\tstruct parport_ip32_private * const priv = p->physport->private_data;\n\tstruct parport * const physport = p->physport;\n\tsize_t written = 0;\n\n\t \n\tif (physport->cad->timeout <= PARPORT_INACTIVITY_O_NONBLOCK)\n\t\treturn parport_ieee1284_write_compat(p, buf, len, flags);\n\n\t \n\tparport_ip32_set_mode(p, ECR_MODE_PS2);\n\tparport_ip32_write_control(p, DCR_SELECT | DCR_nINIT);\n\tparport_ip32_data_forward(p);\n\tparport_ip32_disable_irq(p);\n\tparport_ip32_set_mode(p, ECR_MODE_PPF);\n\tphysport->ieee1284.phase = IEEE1284_PH_FWD_DATA;\n\n\t \n\tif (parport_wait_peripheral(p, DSR_nBUSY | DSR_nFAULT,\n\t\t\t\t       DSR_nBUSY | DSR_nFAULT)) {\n\t\t \n\t\tif (ready_before)\n\t\t\tpr_info(PPIP32 \"%s: not ready in %s\\n\",\n\t\t\t\tp->name, __func__);\n\t\tready_before = 0;\n\t\tgoto stop;\n\t}\n\tready_before = 1;\n\n\twritten = parport_ip32_fifo_write_block(p, buf, len);\n\n\t \n\tparport_ip32_drain_fifo(p, physport->cad->timeout * priv->fifo_depth);\n\n\t \n\twritten -= parport_ip32_get_fifo_residue(p, ECR_MODE_PPF);\n\n\t \n\tif (parport_wait_peripheral(p, DSR_nBUSY, DSR_nBUSY))\n\t\tprintk(KERN_DEBUG PPIP32 \"%s: BUSY timeout in %s\\n\",\n\t\t       p->name, __func__);\n\nstop:\n\t \n\tparport_ip32_set_mode(p, ECR_MODE_PS2);\n\tphysport->ieee1284.phase = IEEE1284_PH_FWD_IDLE;\n\n\treturn written;\n}\n\n \n\n \nstatic size_t parport_ip32_ecp_write_data(struct parport *p,\n\t\t\t\t\t  const void *buf, size_t len,\n\t\t\t\t\t  int flags)\n{\n\tstatic unsigned int ready_before = 1;\n\tstruct parport_ip32_private * const priv = p->physport->private_data;\n\tstruct parport * const physport = p->physport;\n\tsize_t written = 0;\n\n\t \n\tif (physport->cad->timeout <= PARPORT_INACTIVITY_O_NONBLOCK)\n\t\treturn parport_ieee1284_ecp_write_data(p, buf, len, flags);\n\n\t \n\tif (physport->ieee1284.phase != IEEE1284_PH_FWD_IDLE) {\n\t\t \n\t\tparport_ip32_frob_control(p, DCR_nINIT | DCR_AUTOFD,\n\t\t\t\t\t     DCR_nINIT | DCR_AUTOFD);\n\n\t\t \n\t\tif (parport_wait_peripheral(p, DSR_PERROR, DSR_PERROR)) {\n\t\t\tprintk(KERN_DEBUG PPIP32 \"%s: PError timeout in %s\\n\",\n\t\t\t       p->name, __func__);\n\t\t\tphysport->ieee1284.phase = IEEE1284_PH_ECP_DIR_UNKNOWN;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t \n\tparport_ip32_set_mode(p, ECR_MODE_PS2);\n\tparport_ip32_write_control(p, DCR_SELECT | DCR_nINIT);\n\tparport_ip32_data_forward(p);\n\tparport_ip32_disable_irq(p);\n\tparport_ip32_set_mode(p, ECR_MODE_ECP);\n\tphysport->ieee1284.phase = IEEE1284_PH_FWD_DATA;\n\n\t \n\tif (parport_wait_peripheral(p, DSR_nBUSY | DSR_nFAULT,\n\t\t\t\t       DSR_nBUSY | DSR_nFAULT)) {\n\t\t \n\t\tif (ready_before)\n\t\t\tpr_info(PPIP32 \"%s: not ready in %s\\n\",\n\t\t\t\tp->name, __func__);\n\t\tready_before = 0;\n\t\tgoto stop;\n\t}\n\tready_before = 1;\n\n\twritten = parport_ip32_fifo_write_block(p, buf, len);\n\n\t \n\tparport_ip32_drain_fifo(p, physport->cad->timeout * priv->fifo_depth);\n\n\t \n\twritten -= parport_ip32_get_fifo_residue(p, ECR_MODE_ECP);\n\n\t \n\tif (parport_wait_peripheral(p, DSR_nBUSY, DSR_nBUSY))\n\t\tprintk(KERN_DEBUG PPIP32 \"%s: BUSY timeout in %s\\n\",\n\t\t       p->name, __func__);\n\nstop:\n\t \n\tparport_ip32_set_mode(p, ECR_MODE_PS2);\n\tphysport->ieee1284.phase = IEEE1284_PH_FWD_IDLE;\n\n\treturn written;\n}\n\n \n\n \n\nstatic const struct parport_operations parport_ip32_ops __initconst = {\n\t.write_data\t\t= parport_ip32_write_data,\n\t.read_data\t\t= parport_ip32_read_data,\n\n\t.write_control\t\t= parport_ip32_write_control,\n\t.read_control\t\t= parport_ip32_read_control,\n\t.frob_control\t\t= parport_ip32_frob_control,\n\n\t.read_status\t\t= parport_ip32_read_status,\n\n\t.enable_irq\t\t= parport_ip32_enable_irq,\n\t.disable_irq\t\t= parport_ip32_disable_irq,\n\n\t.data_forward\t\t= parport_ip32_data_forward,\n\t.data_reverse\t\t= parport_ip32_data_reverse,\n\n\t.init_state\t\t= parport_ip32_init_state,\n\t.save_state\t\t= parport_ip32_save_state,\n\t.restore_state\t\t= parport_ip32_restore_state,\n\n\t.epp_write_data\t\t= parport_ieee1284_epp_write_data,\n\t.epp_read_data\t\t= parport_ieee1284_epp_read_data,\n\t.epp_write_addr\t\t= parport_ieee1284_epp_write_addr,\n\t.epp_read_addr\t\t= parport_ieee1284_epp_read_addr,\n\n\t.ecp_write_data\t\t= parport_ieee1284_ecp_write_data,\n\t.ecp_read_data\t\t= parport_ieee1284_ecp_read_data,\n\t.ecp_write_addr\t\t= parport_ieee1284_ecp_write_addr,\n\n\t.compat_write_data\t= parport_ieee1284_write_compat,\n\t.nibble_read_data\t= parport_ieee1284_read_nibble,\n\t.byte_read_data\t\t= parport_ieee1284_read_byte,\n\n\t.owner\t\t\t= THIS_MODULE,\n};\n\n \n\n \nstatic __init unsigned int parport_ip32_ecp_supported(struct parport *p)\n{\n\tstruct parport_ip32_private * const priv = p->physport->private_data;\n\tunsigned int ecr;\n\n\tecr = ECR_MODE_PS2 | ECR_nERRINTR | ECR_SERVINTR;\n\twriteb(ecr, priv->regs.ecr);\n\tif (readb(priv->regs.ecr) != (ecr | ECR_F_EMPTY))\n\t\tgoto fail;\n\n\tpr_probe(p, \"Found working ECR register\\n\");\n\tparport_ip32_set_mode(p, ECR_MODE_SPP);\n\tparport_ip32_write_control(p, DCR_SELECT | DCR_nINIT);\n\treturn 1;\n\nfail:\n\tpr_probe(p, \"ECR register not found\\n\");\n\treturn 0;\n}\n\n \nstatic __init unsigned int parport_ip32_fifo_supported(struct parport *p)\n{\n\tstruct parport_ip32_private * const priv = p->physport->private_data;\n\tunsigned int configa, configb;\n\tunsigned int pword;\n\tunsigned int i;\n\n\t \n\tparport_ip32_set_mode(p, ECR_MODE_CFG);\n\tconfiga = readb(priv->regs.cnfgA);\n\tconfigb = readb(priv->regs.cnfgB);\n\n\t \n\tswitch (configa & CNFGA_ID_MASK) {\n\tcase CNFGA_ID_8:\n\t\tpword = 1;\n\t\tbreak;\n\tcase CNFGA_ID_16:\n\t\tpword = 2;\n\t\tbreak;\n\tcase CNFGA_ID_32:\n\t\tpword = 4;\n\t\tbreak;\n\tdefault:\n\t\tpr_probe(p, \"Unknown implementation ID: 0x%0x\\n\",\n\t\t\t (configa & CNFGA_ID_MASK) >> CNFGA_ID_SHIFT);\n\t\tgoto fail;\n\t\tbreak;\n\t}\n\tif (pword != 1) {\n\t\tpr_probe(p, \"Unsupported PWord size: %u\\n\", pword);\n\t\tgoto fail;\n\t}\n\tpriv->pword = pword;\n\tpr_probe(p, \"PWord is %u bits\\n\", 8 * priv->pword);\n\n\t \n\twriteb(configb | CNFGB_COMPRESS, priv->regs.cnfgB);\n\tif (readb(priv->regs.cnfgB) & CNFGB_COMPRESS)\n\t\tpr_probe(p, \"Hardware compression detected (unsupported)\\n\");\n\twriteb(configb & ~CNFGB_COMPRESS, priv->regs.cnfgB);\n\n\t \n\tparport_ip32_set_mode(p, ECR_MODE_TST);\n\n\t \n\tif (!(readb(priv->regs.ecr) & ECR_F_EMPTY)) {\n\t\tpr_probe(p, \"FIFO not reset\\n\");\n\t\tgoto fail;\n\t}\n\n\t \n\tpriv->fifo_depth = 0;\n\tfor (i = 0; i < 1024; i++) {\n\t\tif (readb(priv->regs.ecr) & ECR_F_FULL) {\n\t\t\t \n\t\t\tpriv->fifo_depth = i;\n\t\t\tbreak;\n\t\t}\n\t\twriteb((u8)i, priv->regs.fifo);\n\t}\n\tif (i >= 1024) {\n\t\tpr_probe(p, \"Can't fill FIFO\\n\");\n\t\tgoto fail;\n\t}\n\tif (!priv->fifo_depth) {\n\t\tpr_probe(p, \"Can't get FIFO depth\\n\");\n\t\tgoto fail;\n\t}\n\tpr_probe(p, \"FIFO is %u PWords deep\\n\", priv->fifo_depth);\n\n\t \n\tparport_ip32_frob_econtrol(p, ECR_SERVINTR, 0);\n\n\t \n\tpriv->writeIntrThreshold = 0;\n\tfor (i = 0; i < priv->fifo_depth; i++) {\n\t\tif (readb(priv->regs.fifo) != (u8)i) {\n\t\t\tpr_probe(p, \"Invalid data in FIFO\\n\");\n\t\t\tgoto fail;\n\t\t}\n\t\tif (!priv->writeIntrThreshold\n\t\t    && readb(priv->regs.ecr) & ECR_SERVINTR)\n\t\t\t \n\t\t\tpriv->writeIntrThreshold = i + 1;\n\t\tif (i + 1 < priv->fifo_depth\n\t\t    && readb(priv->regs.ecr) & ECR_F_EMPTY) {\n\t\t\t \n\t\t\tpr_probe(p, \"Data lost in FIFO\\n\");\n\t\t\tgoto fail;\n\t\t}\n\t}\n\tif (!priv->writeIntrThreshold) {\n\t\tpr_probe(p, \"Can't get writeIntrThreshold\\n\");\n\t\tgoto fail;\n\t}\n\tpr_probe(p, \"writeIntrThreshold is %u\\n\", priv->writeIntrThreshold);\n\n\t \n\tif (!(readb(priv->regs.ecr) & ECR_F_EMPTY)) {\n\t\tpr_probe(p, \"Can't empty FIFO\\n\");\n\t\tgoto fail;\n\t}\n\n\t \n\tparport_ip32_set_mode(p, ECR_MODE_PS2);\n\t \n\tparport_ip32_data_reverse(p);\n\t \n\tparport_ip32_set_mode(p, ECR_MODE_TST);\n\t \n\tparport_ip32_frob_econtrol(p, ECR_SERVINTR, 0);\n\n\t \n\tpriv->readIntrThreshold = 0;\n\tfor (i = 0; i < priv->fifo_depth; i++) {\n\t\twriteb(0xaa, priv->regs.fifo);\n\t\tif (readb(priv->regs.ecr) & ECR_SERVINTR) {\n\t\t\t \n\t\t\tpriv->readIntrThreshold = i + 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!priv->readIntrThreshold) {\n\t\tpr_probe(p, \"Can't get readIntrThreshold\\n\");\n\t\tgoto fail;\n\t}\n\tpr_probe(p, \"readIntrThreshold is %u\\n\", priv->readIntrThreshold);\n\n\t \n\tparport_ip32_set_mode(p, ECR_MODE_PS2);\n\tparport_ip32_data_forward(p);\n\tparport_ip32_set_mode(p, ECR_MODE_SPP);\n\treturn 1;\n\nfail:\n\tpriv->fifo_depth = 0;\n\tparport_ip32_set_mode(p, ECR_MODE_SPP);\n\treturn 0;\n}\n\n \n\n \nstatic void __init\nparport_ip32_make_isa_registers(struct parport_ip32_regs *regs,\n\t\t\t\tvoid __iomem *base, void __iomem *base_hi,\n\t\t\t\tunsigned int regshift)\n{\n#define r_base(offset)    ((u8 __iomem *)base    + ((offset) << regshift))\n#define r_base_hi(offset) ((u8 __iomem *)base_hi + ((offset) << regshift))\n\t*regs = (struct parport_ip32_regs){\n\t\t.data\t\t= r_base(0),\n\t\t.dsr\t\t= r_base(1),\n\t\t.dcr\t\t= r_base(2),\n\t\t.eppAddr\t= r_base(3),\n\t\t.eppData0\t= r_base(4),\n\t\t.eppData1\t= r_base(5),\n\t\t.eppData2\t= r_base(6),\n\t\t.eppData3\t= r_base(7),\n\t\t.ecpAFifo\t= r_base(0),\n\t\t.fifo\t\t= r_base_hi(0),\n\t\t.cnfgA\t\t= r_base_hi(0),\n\t\t.cnfgB\t\t= r_base_hi(1),\n\t\t.ecr\t\t= r_base_hi(2)\n\t};\n#undef r_base_hi\n#undef r_base\n}\n\n \nstatic __init struct parport *parport_ip32_probe_port(void)\n{\n\tstruct parport_ip32_regs regs;\n\tstruct parport_ip32_private *priv = NULL;\n\tstruct parport_operations *ops = NULL;\n\tstruct parport *p = NULL;\n\tint err;\n\n\tparport_ip32_make_isa_registers(&regs, &mace->isa.parallel,\n\t\t\t\t\t&mace->isa.ecp1284, 8  );\n\n\tops = kmalloc(sizeof(struct parport_operations), GFP_KERNEL);\n\tpriv = kmalloc(sizeof(struct parport_ip32_private), GFP_KERNEL);\n\tp = parport_register_port(0, PARPORT_IRQ_NONE, PARPORT_DMA_NONE, ops);\n\tif (ops == NULL || priv == NULL || p == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto fail;\n\t}\n\tp->base = MACE_BASE + offsetof(struct sgi_mace, isa.parallel);\n\tp->base_hi = MACE_BASE + offsetof(struct sgi_mace, isa.ecp1284);\n\tp->private_data = priv;\n\n\t*ops = parport_ip32_ops;\n\t*priv = (struct parport_ip32_private){\n\t\t.regs\t\t\t= regs,\n\t\t.dcr_writable\t\t= DCR_DIR | DCR_SELECT | DCR_nINIT |\n\t\t\t\t\t  DCR_AUTOFD | DCR_STROBE,\n\t\t.irq_mode\t\t= PARPORT_IP32_IRQ_FWD,\n\t};\n\tinit_completion(&priv->irq_complete);\n\n\t \n\tif (!parport_ip32_ecp_supported(p)) {\n\t\terr = -ENODEV;\n\t\tgoto fail;\n\t}\n\tparport_ip32_dump_state(p, \"begin init\", 0);\n\n\t \n\tp->modes = PARPORT_MODE_PCSPP | PARPORT_MODE_SAFEININT;\n\tp->modes |= PARPORT_MODE_TRISTATE;\n\n\tif (!parport_ip32_fifo_supported(p)) {\n\t\tpr_warn(PPIP32 \"%s: error: FIFO disabled\\n\", p->name);\n\t\t \n\t\tfeatures &= ~PARPORT_IP32_ENABLE_SPP;\n\t\tfeatures &= ~PARPORT_IP32_ENABLE_ECP;\n\t\t \n\t\tfeatures &= ~PARPORT_IP32_ENABLE_DMA;\n\t}\n\n\t \n\tif (features & PARPORT_IP32_ENABLE_IRQ) {\n\t\tint irq = MACEISA_PARALLEL_IRQ;\n\t\tif (request_irq(irq, parport_ip32_interrupt, 0, p->name, p)) {\n\t\t\tpr_warn(PPIP32 \"%s: error: IRQ disabled\\n\", p->name);\n\t\t\t \n\t\t\tfeatures &= ~PARPORT_IP32_ENABLE_DMA;\n\t\t} else {\n\t\t\tpr_probe(p, \"Interrupt support enabled\\n\");\n\t\t\tp->irq = irq;\n\t\t\tpriv->dcr_writable |= DCR_IRQ;\n\t\t}\n\t}\n\n\t \n\tif (features & PARPORT_IP32_ENABLE_DMA) {\n\t\tif (parport_ip32_dma_register())\n\t\t\tpr_warn(PPIP32 \"%s: error: DMA disabled\\n\", p->name);\n\t\telse {\n\t\t\tpr_probe(p, \"DMA support enabled\\n\");\n\t\t\tp->dma = 0;  \n\t\t\tp->modes |= PARPORT_MODE_DMA;\n\t\t}\n\t}\n\n\tif (features & PARPORT_IP32_ENABLE_SPP) {\n\t\t \n\t\tp->ops->compat_write_data = parport_ip32_compat_write_data;\n\t\tp->modes |= PARPORT_MODE_COMPAT;\n\t\tpr_probe(p, \"Hardware support for SPP mode enabled\\n\");\n\t}\n\tif (features & PARPORT_IP32_ENABLE_EPP) {\n\t\t \n\t\tp->ops->epp_read_data = parport_ip32_epp_read_data;\n\t\tp->ops->epp_write_data = parport_ip32_epp_write_data;\n\t\tp->ops->epp_read_addr = parport_ip32_epp_read_addr;\n\t\tp->ops->epp_write_addr = parport_ip32_epp_write_addr;\n\t\tp->modes |= PARPORT_MODE_EPP;\n\t\tpr_probe(p, \"Hardware support for EPP mode enabled\\n\");\n\t}\n\tif (features & PARPORT_IP32_ENABLE_ECP) {\n\t\t \n\t\tp->ops->ecp_write_data = parport_ip32_ecp_write_data;\n\t\t \n \n \n\t\tp->modes |= PARPORT_MODE_ECP;\n\t\tpr_probe(p, \"Hardware support for ECP mode enabled\\n\");\n\t}\n\n\t \n\tparport_ip32_set_mode(p, ECR_MODE_PS2);\n\tparport_ip32_write_control(p, DCR_SELECT | DCR_nINIT);\n\tparport_ip32_data_forward(p);\n\tparport_ip32_disable_irq(p);\n\tparport_ip32_write_data(p, 0x00);\n\tparport_ip32_dump_state(p, \"end init\", 0);\n\n\t \n\tpr_info(\"%s: SGI IP32 at 0x%lx (0x%lx)\", p->name, p->base, p->base_hi);\n\tif (p->irq != PARPORT_IRQ_NONE)\n\t\tpr_cont(\", irq %d\", p->irq);\n\tpr_cont(\" [\");\n#define printmode(x)\t\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tif (p->modes & PARPORT_MODE_##x)\t\t\t\t\\\n\t\tpr_cont(\"%s%s\", f++ ? \",\" : \"\", #x);\t\t\t\\\n} while (0)\n\t{\n\t\tunsigned int f = 0;\n\t\tprintmode(PCSPP);\n\t\tprintmode(TRISTATE);\n\t\tprintmode(COMPAT);\n\t\tprintmode(EPP);\n\t\tprintmode(ECP);\n\t\tprintmode(DMA);\n\t}\n#undef printmode\n\tpr_cont(\"]\\n\");\n\n\tparport_announce_port(p);\n\treturn p;\n\nfail:\n\tif (p)\n\t\tparport_put_port(p);\n\tkfree(priv);\n\tkfree(ops);\n\treturn ERR_PTR(err);\n}\n\n \nstatic __exit void parport_ip32_unregister_port(struct parport *p)\n{\n\tstruct parport_ip32_private * const priv = p->physport->private_data;\n\tstruct parport_operations *ops = p->ops;\n\n\tparport_remove_port(p);\n\tif (p->modes & PARPORT_MODE_DMA)\n\t\tparport_ip32_dma_unregister();\n\tif (p->irq != PARPORT_IRQ_NONE)\n\t\tfree_irq(p->irq, p);\n\tparport_put_port(p);\n\tkfree(priv);\n\tkfree(ops);\n}\n\n \nstatic int __init parport_ip32_init(void)\n{\n\tpr_info(PPIP32 \"SGI IP32 built-in parallel port driver v0.6\\n\");\n\tthis_port = parport_ip32_probe_port();\n\treturn PTR_ERR_OR_ZERO(this_port);\n}\n\n \nstatic void __exit parport_ip32_exit(void)\n{\n\tparport_ip32_unregister_port(this_port);\n}\n\n \n\nMODULE_AUTHOR(\"Arnaud Giersch <arnaud.giersch@free.fr>\");\nMODULE_DESCRIPTION(\"SGI IP32 built-in parallel port driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(\"0.6\");\t\t \n\nmodule_init(parport_ip32_init);\nmodule_exit(parport_ip32_exit);\n\nmodule_param(verbose_probing, bool, S_IRUGO);\nMODULE_PARM_DESC(verbose_probing, \"Log chit-chat during initialization\");\n\nmodule_param(features, uint, S_IRUGO);\nMODULE_PARM_DESC(features,\n\t\t \"Bit mask of features to enable\"\n\t\t \", bit 0: IRQ support\"\n\t\t \", bit 1: DMA support\"\n\t\t \", bit 2: hardware SPP mode\"\n\t\t \", bit 3: hardware EPP mode\"\n\t\t \", bit 4: hardware ECP mode\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}