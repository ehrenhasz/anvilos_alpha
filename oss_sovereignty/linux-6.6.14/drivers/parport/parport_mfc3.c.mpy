{
  "module_name": "parport_mfc3.c",
  "hash_id": "f5679c29eb0fbd7975de77e884f0c8381dbfcfcdf825245b3b8b78e4587e5f17",
  "original_prompt": "Ingested from linux-6.6.14/drivers/parport/parport_mfc3.c",
  "human_readable_source": "\n \n\n#include \"multiface.h\"\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/parport.h>\n#include <linux/delay.h>\n#include <linux/mc6821.h>\n#include <linux/zorro.h>\n#include <linux/interrupt.h>\n#include <asm/setup.h>\n#include <asm/amigahw.h>\n#include <asm/irq.h>\n#include <asm/amigaints.h>\n\n \n#define MAX_MFC 5\n\n#undef DEBUG\n\nstatic struct parport *this_port[MAX_MFC] = {NULL, };\nstatic volatile int dummy;  \n\n#define pia(dev) ((struct pia *)(dev->base))\nstatic struct parport_operations pp_mfc3_ops;\n\nstatic void mfc3_write_data(struct parport *p, unsigned char data)\n{\n\tpr_debug(\"write_data %c\\n\", data);\n\n\tdummy = pia(p)->pprb;  \n\t \n\tpia(p)->pprb = data;\n}\n\nstatic unsigned char mfc3_read_data(struct parport *p)\n{\n\t \n\treturn pia(p)->pprb;\n}\n\nstatic unsigned char control_pc_to_mfc3(unsigned char control)\n{\n\tunsigned char ret = 32|64;\n\n\tif (control & PARPORT_CONTROL_SELECT)  \n\t\tret &= ~32;  \n\tif (control & PARPORT_CONTROL_INIT)  \n\t\tret |= 128;\n\tif (control & PARPORT_CONTROL_AUTOFD)  \n\t\tret &= ~64;\n\tif (control & PARPORT_CONTROL_STROBE)  \n\t\t ;\n\treturn ret;\n}\n\nstatic unsigned char control_mfc3_to_pc(unsigned char control)\n{\n\tunsigned char ret = PARPORT_CONTROL_STROBE \n\t\t\t  | PARPORT_CONTROL_AUTOFD | PARPORT_CONTROL_SELECT;\n\n\tif (control & 128)  \n\t\tret |= PARPORT_CONTROL_INIT;\n\tif (control & 64)  \n\t\tret &= ~PARPORT_CONTROL_AUTOFD;\n\tif (control & 32)  \n\t\tret &= ~PARPORT_CONTROL_SELECT;\n\treturn ret;\n}\n\nstatic void mfc3_write_control(struct parport *p, unsigned char control)\n{\n\tpr_debug(\"write_control %02x\\n\", control);\n\tpia(p)->ppra = (pia(p)->ppra & 0x1f) | control_pc_to_mfc3(control);\n}\n\t\nstatic unsigned char mfc3_read_control( struct parport *p)\n{\n\tpr_debug(\"read_control\\n\");\n\treturn control_mfc3_to_pc(pia(p)->ppra & 0xe0);\n}\n\nstatic unsigned char mfc3_frob_control( struct parport *p, unsigned char mask, unsigned char val)\n{\n\tunsigned char old;\n\n\tpr_debug(\"frob_control mask %02x, value %02x\\n\", mask, val);\n\told = mfc3_read_control(p);\n\tmfc3_write_control(p, (old & ~mask) ^ val);\n\treturn old;\n}\n\nstatic unsigned char status_mfc3_to_pc(unsigned char status)\n{\n\tunsigned char ret = PARPORT_STATUS_BUSY;\n\n\tif (status & 1)  \n\t\tret &= ~PARPORT_STATUS_BUSY;\n\tif (status & 2)  \n\t\tret |= PARPORT_STATUS_PAPEROUT;\n\tif (status & 4)  \n\t\tret |= PARPORT_STATUS_SELECT;\n\tif (status & 8)  \n\t\tret |= PARPORT_STATUS_ACK;\n\tif (status & 16)  \n\t\tret |= PARPORT_STATUS_ERROR;\n\n\treturn ret;\n}\n\nstatic unsigned char mfc3_read_status(struct parport *p)\n{\n\tunsigned char status;\n\n\tstatus = status_mfc3_to_pc(pia(p)->ppra & 0x1f);\n\tpr_debug(\"read_status %02x\\n\", status);\n\treturn status;\n}\n\nstatic int use_cnt;\n\nstatic irqreturn_t mfc3_interrupt(int irq, void *dev_id)\n{\n\tint i;\n\n\tfor( i = 0; i < MAX_MFC; i++)\n\t\tif (this_port[i] != NULL)\n\t\t\tif (pia(this_port[i])->crb & 128) {  \n\t\t\t\tdummy = pia(this_port[i])->pprb;  \n\t\t\t\tparport_generic_irq(this_port[i]);\n\t\t\t}\n\treturn IRQ_HANDLED;\n}\n\nstatic void mfc3_enable_irq(struct parport *p)\n{\n\tpia(p)->crb |= PIA_C1_ENABLE_IRQ;\n}\n\nstatic void mfc3_disable_irq(struct parport *p)\n{\n\tpia(p)->crb &= ~PIA_C1_ENABLE_IRQ;\n}\n\nstatic void mfc3_data_forward(struct parport *p)\n{\n\tpr_debug(\"forward\\n\");\n\tpia(p)->crb &= ~PIA_DDR;  \n\tpia(p)->pddrb = 255;  \n\tpia(p)->crb |= PIA_DDR;  \n}\n\nstatic void mfc3_data_reverse(struct parport *p)\n{\n\tpr_debug(\"reverse\\n\");\n\tpia(p)->crb &= ~PIA_DDR;  \n\tpia(p)->pddrb = 0;  \n\tpia(p)->crb |= PIA_DDR;  \n}\n\nstatic void mfc3_init_state(struct pardevice *dev, struct parport_state *s)\n{\n\ts->u.amiga.data = 0;\n\ts->u.amiga.datadir = 255;\n\ts->u.amiga.status = 0;\n\ts->u.amiga.statusdir = 0xe0;\n}\n\nstatic void mfc3_save_state(struct parport *p, struct parport_state *s)\n{\n\ts->u.amiga.data = pia(p)->pprb;\n\tpia(p)->crb &= ~PIA_DDR;\n\ts->u.amiga.datadir = pia(p)->pddrb;\n\tpia(p)->crb |= PIA_DDR;\n\ts->u.amiga.status = pia(p)->ppra;\n\tpia(p)->cra &= ~PIA_DDR;\n\ts->u.amiga.statusdir = pia(p)->pddrb;\n\tpia(p)->cra |= PIA_DDR;\n}\n\nstatic void mfc3_restore_state(struct parport *p, struct parport_state *s)\n{\n\tpia(p)->pprb = s->u.amiga.data;\n\tpia(p)->crb &= ~PIA_DDR;\n\tpia(p)->pddrb = s->u.amiga.datadir;\n\tpia(p)->crb |= PIA_DDR;\n\tpia(p)->ppra = s->u.amiga.status;\n\tpia(p)->cra &= ~PIA_DDR;\n\tpia(p)->pddrb = s->u.amiga.statusdir;\n\tpia(p)->cra |= PIA_DDR;\n}\n\nstatic struct parport_operations pp_mfc3_ops = {\n\t.write_data\t= mfc3_write_data,\n\t.read_data\t= mfc3_read_data,\n\n\t.write_control\t= mfc3_write_control,\n\t.read_control\t= mfc3_read_control,\n\t.frob_control\t= mfc3_frob_control,\n\n\t.read_status\t= mfc3_read_status,\n\n\t.enable_irq\t= mfc3_enable_irq,\n\t.disable_irq\t= mfc3_disable_irq,\n\n\t.data_forward\t= mfc3_data_forward, \n\t.data_reverse\t= mfc3_data_reverse, \n\n\t.init_state\t= mfc3_init_state,\n\t.save_state\t= mfc3_save_state,\n\t.restore_state\t= mfc3_restore_state,\n\n\t.epp_write_data\t= parport_ieee1284_epp_write_data,\n\t.epp_read_data\t= parport_ieee1284_epp_read_data,\n\t.epp_write_addr\t= parport_ieee1284_epp_write_addr,\n\t.epp_read_addr\t= parport_ieee1284_epp_read_addr,\n\n\t.ecp_write_data\t= parport_ieee1284_ecp_write_data,\n\t.ecp_read_data\t= parport_ieee1284_ecp_read_data,\n\t.ecp_write_addr\t= parport_ieee1284_ecp_write_addr,\n\n\t.compat_write_data\t= parport_ieee1284_write_compat,\n\t.nibble_read_data\t= parport_ieee1284_read_nibble,\n\t.byte_read_data\t\t= parport_ieee1284_read_byte,\n\n\t.owner\t\t= THIS_MODULE,\n};\n\n \n\nstatic int __init parport_mfc3_init(void)\n{\n\tstruct parport *p;\n\tint pias = 0;\n\tstruct pia *pp;\n\tstruct zorro_dev *z = NULL;\n\n\tif (!MACH_IS_AMIGA)\n\t\treturn -ENODEV;\n\n\twhile ((z = zorro_find_device(ZORRO_PROD_BSC_MULTIFACE_III, z))) {\n\t\tunsigned long piabase = z->resource.start+PIABASE;\n\t\tif (!request_mem_region(piabase, sizeof(struct pia), \"PIA\"))\n\t\t\tcontinue;\n\n\t\tpp = ZTWO_VADDR(piabase);\n\t\tpp->crb = 0;\n\t\tpp->pddrb = 255;  \n\t\tpp->crb = PIA_DDR|32|8;\n\t\tdummy = pp->pddrb;  \n\t\tpp->cra = 0;\n\t\tpp->pddra = 0xe0;  \n\t\tpp->cra = PIA_DDR;\n\t\tpp->ppra = 0;  \n\t\tudelay(10);\n\t\tpp->ppra = 128;\n\t\tp = parport_register_port((unsigned long)pp, IRQ_AMIGA_PORTS,\n\t\t\t\t\t  PARPORT_DMA_NONE, &pp_mfc3_ops);\n\t\tif (!p)\n\t\t\tgoto out_port;\n\n\t\tif (p->irq != PARPORT_IRQ_NONE) {\n\t\t\tif (use_cnt++ == 0)\n\t\t\t\tif (request_irq(IRQ_AMIGA_PORTS, mfc3_interrupt, IRQF_SHARED, p->name, &pp_mfc3_ops))\n\t\t\t\t\tgoto out_irq;\n\t\t}\n\t\tp->dev = &z->dev;\n\n\t\tthis_port[pias++] = p;\n\t\tpr_info(\"%s: Multiface III port using irq\\n\", p->name);\n\t\t \n\n\t\tp->private_data = (void *)piabase;\n\t\tparport_announce_port (p);\n\n\t\tif (pias >= MAX_MFC)\n\t\t\tbreak;\n\t\tcontinue;\n\n\tout_irq:\n\t\tparport_put_port(p);\n\tout_port:\n\t\trelease_mem_region(piabase, sizeof(struct pia));\n\t}\n\n\treturn pias ? 0 : -ENODEV;\n}\n\nstatic void __exit parport_mfc3_exit(void)\n{\n\tint i;\n\n\tfor (i = 0; i < MAX_MFC; i++) {\n\t\tif (!this_port[i])\n\t\t\tcontinue;\n\t\tparport_remove_port(this_port[i]);\n\t\tif (this_port[i]->irq != PARPORT_IRQ_NONE) {\n\t\t\tif (--use_cnt == 0) \n\t\t\t\tfree_irq(IRQ_AMIGA_PORTS, &pp_mfc3_ops);\n\t\t}\n\t\trelease_mem_region(ZTWO_PADDR(this_port[i]->private_data), sizeof(struct pia));\n\t\tparport_put_port(this_port[i]);\n\t}\n}\n\n\nMODULE_AUTHOR(\"Joerg Dorchain <joerg@dorchain.net>\");\nMODULE_DESCRIPTION(\"Parport Driver for Multiface 3 expansion cards Parallel Port\");\nMODULE_LICENSE(\"GPL\");\n\nmodule_init(parport_mfc3_init)\nmodule_exit(parport_mfc3_exit)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}