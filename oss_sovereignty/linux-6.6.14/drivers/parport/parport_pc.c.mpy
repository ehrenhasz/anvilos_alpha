{
  "module_name": "parport_pc.c",
  "hash_id": "26b5be7a16408a9551c38c30ff761684c62e80b07d4907f19d630795ab9f8307",
  "original_prompt": "Ingested from linux-6.6.14/drivers/parport/parport_pc.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sched/signal.h>\n#include <linux/delay.h>\n#include <linux/errno.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/dma-mapping.h>\n#include <linux/pci.h>\n#include <linux/pnp.h>\n#include <linux/platform_device.h>\n#include <linux/sysctl.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n\n#include <asm/dma.h>\n\n#include <linux/parport.h>\n#include <linux/parport_pc.h>\n#include <linux/via.h>\n#include <asm/parport.h>\n\n#define PARPORT_PC_MAX_PORTS PARPORT_MAX\n\n#ifdef CONFIG_ISA_DMA_API\n#define HAS_DMA\n#endif\n\n \n#define ECR_SPP 00\n#define ECR_PS2 01\n#define ECR_PPF 02\n#define ECR_ECP 03\n#define ECR_EPP 04\n#define ECR_VND 05\n#define ECR_TST 06\n#define ECR_CNF 07\n#define ECR_MODE_MASK 0xe0\n#define ECR_WRITE(p, v) frob_econtrol((p), 0xff, (v))\n\n#undef DEBUG\n\n#define NR_SUPERIOS 3\nstatic struct superio_struct {\t \n\tint io;\n\tint irq;\n\tint dma;\n} superios[NR_SUPERIOS] = { {0,},};\n\nstatic int user_specified;\n#if defined(CONFIG_PARPORT_PC_SUPERIO) || \\\n       (defined(CONFIG_PARPORT_1284) && defined(CONFIG_PARPORT_PC_FIFO))\nstatic int verbose_probing;\n#endif\nstatic int pci_registered_parport;\nstatic int pnp_registered_parport;\n\n \nstatic void frob_econtrol(struct parport *pb, unsigned char m,\n\t\t\t   unsigned char v)\n{\n\tconst struct parport_pc_private *priv = pb->physport->private_data;\n\tunsigned char ecr_writable = priv->ecr_writable;\n\tunsigned char ectr = 0;\n\tunsigned char new;\n\n\tif (m != 0xff)\n\t\tectr = inb(ECONTROL(pb));\n\n\tnew = (ectr & ~m) ^ v;\n\tif (ecr_writable)\n\t\t \n\t\tnew = (new & ecr_writable) | 1;\n\n\tpr_debug(\"frob_econtrol(%02x,%02x): %02x -> %02x\\n\", m, v, ectr, new);\n\n\toutb(new, ECONTROL(pb));\n}\n\nstatic inline void frob_set_mode(struct parport *p, int mode)\n{\n\tfrob_econtrol(p, ECR_MODE_MASK, mode << 5);\n}\n\n#ifdef CONFIG_PARPORT_PC_FIFO\n \nstatic int change_mode(struct parport *p, int m)\n{\n\tconst struct parport_pc_private *priv = p->physport->private_data;\n\tunsigned char oecr;\n\tint mode;\n\n\tpr_debug(\"parport change_mode ECP-ISA to mode 0x%02x\\n\", m);\n\n\tif (!priv->ecr) {\n\t\tprintk(KERN_DEBUG \"change_mode: but there's no ECR!\\n\");\n\t\treturn 0;\n\t}\n\n\t \n\toecr = inb(ECONTROL(p));\n\tmode = (oecr >> 5) & 0x7;\n\tif (mode == m)\n\t\treturn 0;\n\n\tif (mode >= 2 && !(priv->ctr & 0x20)) {\n\t\t \n\t\tunsigned long expire = jiffies + p->physport->cad->timeout;\n\t\tint counter;\n\t\tswitch (mode) {\n\t\tcase ECR_PPF:  \n\t\tcase ECR_ECP:  \n\t\t\t \n\t\t\tfor (counter = 0; counter < 40; counter++) {\n\t\t\t\tif (inb(ECONTROL(p)) & 0x01)\n\t\t\t\t\tbreak;\n\t\t\t\tif (signal_pending(current))\n\t\t\t\t\tbreak;\n\t\t\t\tudelay(5);\n\t\t\t}\n\n\t\t\t \n\t\t\twhile (!(inb(ECONTROL(p)) & 0x01)) {\n\t\t\t\tif (time_after_eq(jiffies, expire))\n\t\t\t\t\t \n\t\t\t\t\treturn -EBUSY;\n\t\t\t\tschedule_timeout_interruptible(\n\t\t\t\t\t\t\tmsecs_to_jiffies(10));\n\t\t\t\tif (signal_pending(current))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (mode >= 2 && m >= 2) {\n\t\t \n\t\toecr &= ~(7 << 5);\n\t\toecr |= ECR_PS2 << 5;\n\t\tECR_WRITE(p, oecr);\n\t}\n\n\t \n\toecr &= ~(7 << 5);\n\toecr |= m << 5;\n\tECR_WRITE(p, oecr);\n\treturn 0;\n}\n#endif  \n\n \nstatic int clear_epp_timeout(struct parport *pb)\n{\n\tunsigned char r;\n\n\tif (!(parport_pc_read_status(pb) & 0x01))\n\t\treturn 1;\n\n\t \n\tparport_pc_read_status(pb);\n\tr = parport_pc_read_status(pb);\n\toutb(r | 0x01, STATUS(pb));  \n\toutb(r & 0xfe, STATUS(pb));  \n\tr = parport_pc_read_status(pb);\n\n\treturn !(r & 0x01);\n}\n\n \n\nstatic void parport_pc_init_state(struct pardevice *dev,\n\t\t\t\t\t\tstruct parport_state *s)\n{\n\ts->u.pc.ctr = 0xc;\n\tif (dev->irq_func &&\n\t    dev->port->irq != PARPORT_IRQ_NONE)\n\t\t \n\t\ts->u.pc.ctr |= 0x10;\n\n\ts->u.pc.ecr = 0x34;  \n}\n\nstatic void parport_pc_save_state(struct parport *p, struct parport_state *s)\n{\n\tconst struct parport_pc_private *priv = p->physport->private_data;\n\ts->u.pc.ctr = priv->ctr;\n\tif (priv->ecr)\n\t\ts->u.pc.ecr = inb(ECONTROL(p));\n}\n\nstatic void parport_pc_restore_state(struct parport *p,\n\t\t\t\t\t\tstruct parport_state *s)\n{\n\tstruct parport_pc_private *priv = p->physport->private_data;\n\tregister unsigned char c = s->u.pc.ctr & priv->ctr_writable;\n\toutb(c, CONTROL(p));\n\tpriv->ctr = c;\n\tif (priv->ecr)\n\t\tECR_WRITE(p, s->u.pc.ecr);\n}\n\n#ifdef CONFIG_PARPORT_1284\nstatic size_t parport_pc_epp_read_data(struct parport *port, void *buf,\n\t\t\t\t       size_t length, int flags)\n{\n\tsize_t got = 0;\n\n\tif (flags & PARPORT_W91284PIC) {\n\t\tunsigned char status;\n\t\tsize_t left = length;\n\n\t\t \n\t\tstatus = inb(STATUS(port));\n\n\t\twhile (!(status & 0x08) && got < length) {\n\t\t\tif (left >= 16 && (status & 0x20) && !(status & 0x08)) {\n\t\t\t\t \n\t\t\t\tif (!((long)buf & 0x03))\n\t\t\t\t\tinsl(EPPDATA(port), buf, 4);\n\t\t\t\telse\n\t\t\t\t\tinsb(EPPDATA(port), buf, 16);\n\t\t\t\tbuf += 16;\n\t\t\t\tgot += 16;\n\t\t\t\tleft -= 16;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\t*((char *)buf) = inb(EPPDATA(port));\n\t\t\t\tbuf++;\n\t\t\t\tgot++;\n\t\t\t\tleft--;\n\t\t\t}\n\t\t\tstatus = inb(STATUS(port));\n\t\t\tif (status & 0x01) {\n\t\t\t\t \n\t\t\t\tprintk(KERN_DEBUG \"%s: EPP timeout occurred while talking to w91284pic (should not have done)\\n\",\n\t\t\t\t       port->name);\n\t\t\t\tclear_epp_timeout(port);\n\t\t\t}\n\t\t}\n\t\treturn got;\n\t}\n\tif ((length > 1) && ((flags & PARPORT_EPP_FAST_32)\n\t\t\t   || flags & PARPORT_EPP_FAST_16\n\t\t\t   || flags & PARPORT_EPP_FAST_8)) {\n\t\tif ((flags & PARPORT_EPP_FAST_32)\n\t\t    && !(((long)buf | length) & 0x03))\n\t\t\tinsl(EPPDATA(port), buf, (length >> 2));\n\t\telse if ((flags & PARPORT_EPP_FAST_16)\n\t\t\t && !(((long)buf | length) & 0x01))\n\t\t\tinsw(EPPDATA(port), buf, length >> 1);\n\t\telse\n\t\t\tinsb(EPPDATA(port), buf, length);\n\t\tif (inb(STATUS(port)) & 0x01) {\n\t\t\tclear_epp_timeout(port);\n\t\t\treturn -EIO;\n\t\t}\n\t\treturn length;\n\t}\n\tfor (; got < length; got++) {\n\t\t*((char *)buf) = inb(EPPDATA(port));\n\t\tbuf++;\n\t\tif (inb(STATUS(port)) & 0x01) {\n\t\t\t \n\t\t\tclear_epp_timeout(port);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn got;\n}\n\nstatic size_t parport_pc_epp_write_data(struct parport *port, const void *buf,\n\t\t\t\t\tsize_t length, int flags)\n{\n\tsize_t written = 0;\n\n\tif ((length > 1) && ((flags & PARPORT_EPP_FAST_32)\n\t\t\t   || flags & PARPORT_EPP_FAST_16\n\t\t\t   || flags & PARPORT_EPP_FAST_8)) {\n\t\tif ((flags & PARPORT_EPP_FAST_32)\n\t\t    && !(((long)buf | length) & 0x03))\n\t\t\toutsl(EPPDATA(port), buf, (length >> 2));\n\t\telse if ((flags & PARPORT_EPP_FAST_16)\n\t\t\t && !(((long)buf | length) & 0x01))\n\t\t\toutsw(EPPDATA(port), buf, length >> 1);\n\t\telse\n\t\t\toutsb(EPPDATA(port), buf, length);\n\t\tif (inb(STATUS(port)) & 0x01) {\n\t\t\tclear_epp_timeout(port);\n\t\t\treturn -EIO;\n\t\t}\n\t\treturn length;\n\t}\n\tfor (; written < length; written++) {\n\t\toutb(*((char *)buf), EPPDATA(port));\n\t\tbuf++;\n\t\tif (inb(STATUS(port)) & 0x01) {\n\t\t\tclear_epp_timeout(port);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn written;\n}\n\nstatic size_t parport_pc_epp_read_addr(struct parport *port, void *buf,\n\t\t\t\t\tsize_t length, int flags)\n{\n\tsize_t got = 0;\n\n\tif ((flags & PARPORT_EPP_FAST) && (length > 1)) {\n\t\tinsb(EPPADDR(port), buf, length);\n\t\tif (inb(STATUS(port)) & 0x01) {\n\t\t\tclear_epp_timeout(port);\n\t\t\treturn -EIO;\n\t\t}\n\t\treturn length;\n\t}\n\tfor (; got < length; got++) {\n\t\t*((char *)buf) = inb(EPPADDR(port));\n\t\tbuf++;\n\t\tif (inb(STATUS(port)) & 0x01) {\n\t\t\tclear_epp_timeout(port);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn got;\n}\n\nstatic size_t parport_pc_epp_write_addr(struct parport *port,\n\t\t\t\t\t const void *buf, size_t length,\n\t\t\t\t\t int flags)\n{\n\tsize_t written = 0;\n\n\tif ((flags & PARPORT_EPP_FAST) && (length > 1)) {\n\t\toutsb(EPPADDR(port), buf, length);\n\t\tif (inb(STATUS(port)) & 0x01) {\n\t\t\tclear_epp_timeout(port);\n\t\t\treturn -EIO;\n\t\t}\n\t\treturn length;\n\t}\n\tfor (; written < length; written++) {\n\t\toutb(*((char *)buf), EPPADDR(port));\n\t\tbuf++;\n\t\tif (inb(STATUS(port)) & 0x01) {\n\t\t\tclear_epp_timeout(port);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn written;\n}\n\nstatic size_t parport_pc_ecpepp_read_data(struct parport *port, void *buf,\n\t\t\t\t\t  size_t length, int flags)\n{\n\tsize_t got;\n\n\tfrob_set_mode(port, ECR_EPP);\n\tparport_pc_data_reverse(port);\n\tparport_pc_write_control(port, 0x4);\n\tgot = parport_pc_epp_read_data(port, buf, length, flags);\n\tfrob_set_mode(port, ECR_PS2);\n\n\treturn got;\n}\n\nstatic size_t parport_pc_ecpepp_write_data(struct parport *port,\n\t\t\t\t\t   const void *buf, size_t length,\n\t\t\t\t\t   int flags)\n{\n\tsize_t written;\n\n\tfrob_set_mode(port, ECR_EPP);\n\tparport_pc_write_control(port, 0x4);\n\tparport_pc_data_forward(port);\n\twritten = parport_pc_epp_write_data(port, buf, length, flags);\n\tfrob_set_mode(port, ECR_PS2);\n\n\treturn written;\n}\n\nstatic size_t parport_pc_ecpepp_read_addr(struct parport *port, void *buf,\n\t\t\t\t\t  size_t length, int flags)\n{\n\tsize_t got;\n\n\tfrob_set_mode(port, ECR_EPP);\n\tparport_pc_data_reverse(port);\n\tparport_pc_write_control(port, 0x4);\n\tgot = parport_pc_epp_read_addr(port, buf, length, flags);\n\tfrob_set_mode(port, ECR_PS2);\n\n\treturn got;\n}\n\nstatic size_t parport_pc_ecpepp_write_addr(struct parport *port,\n\t\t\t\t\t    const void *buf, size_t length,\n\t\t\t\t\t    int flags)\n{\n\tsize_t written;\n\n\tfrob_set_mode(port, ECR_EPP);\n\tparport_pc_write_control(port, 0x4);\n\tparport_pc_data_forward(port);\n\twritten = parport_pc_epp_write_addr(port, buf, length, flags);\n\tfrob_set_mode(port, ECR_PS2);\n\n\treturn written;\n}\n#endif  \n\n#ifdef CONFIG_PARPORT_PC_FIFO\nstatic size_t parport_pc_fifo_write_block_pio(struct parport *port,\n\t\t\t\t\t       const void *buf, size_t length)\n{\n\tint ret = 0;\n\tconst unsigned char *bufp = buf;\n\tsize_t left = length;\n\tunsigned long expire = jiffies + port->physport->cad->timeout;\n\tconst unsigned long fifo = FIFO(port);\n\tint poll_for = 8;  \n\tconst struct parport_pc_private *priv = port->physport->private_data;\n\tconst int fifo_depth = priv->fifo_depth;\n\n\tport = port->physport;\n\n\t \n\tparport_pc_disable_irq(port);\n\t \n\tfrob_econtrol(port, (1<<4) | (1<<2), (1<<4) | (1<<2));\n\n\t \n\tparport_pc_data_forward(port);  \n\n\twhile (left) {\n\t\tunsigned char byte;\n\t\tunsigned char ecrval = inb(ECONTROL(port));\n\t\tint i = 0;\n\n\t\tif (need_resched() && time_before(jiffies, expire))\n\t\t\t \n\t\t\tschedule();\n\n\t\t \n\t\tif (port->waithead) {\n\t\t\tprintk(KERN_DEBUG \"Somebody wants the port\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif (ecrval & 0x02) {\n\t\t\t \n\n\t\t\t \n\t\t\tECR_WRITE(port, ecrval & ~(1<<2));\nfalse_alarm:\n\t\t\tret = parport_wait_event(port, HZ);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t\tret = 0;\n\t\t\tif (!time_before(jiffies, expire)) {\n\t\t\t\t \n\t\t\t\tprintk(KERN_DEBUG \"FIFO write timed out\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tecrval = inb(ECONTROL(port));\n\t\t\tif (!(ecrval & (1<<2))) {\n\t\t\t\tif (need_resched() &&\n\t\t\t\t    time_before(jiffies, expire))\n\t\t\t\t\tschedule();\n\n\t\t\t\tgoto false_alarm;\n\t\t\t}\n\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\texpire = jiffies + port->cad->timeout;\n\npoll:\n\t\tif (signal_pending(current))\n\t\t\tbreak;\n\n\t\tif (ecrval & 0x01) {\n\t\t\t \n\t\t\tconst int n = left < fifo_depth ? left : fifo_depth;\n\t\t\toutsb(fifo, bufp, n);\n\t\t\tbufp += n;\n\t\t\tleft -= n;\n\n\t\t\t \n\t\t\tif (i < (poll_for - 2))\n\t\t\t\tpoll_for--;\n\t\t\tcontinue;\n\t\t} else if (i++ < poll_for) {\n\t\t\tudelay(10);\n\t\t\tecrval = inb(ECONTROL(port));\n\t\t\tgoto poll;\n\t\t}\n\n\t\t \n\t\tbyte = *bufp++;\n\t\toutb(byte, fifo);\n\t\tleft--;\n\t}\n\tdump_parport_state(\"leave fifo_write_block_pio\", port);\n\treturn length - left;\n}\n\n#ifdef HAS_DMA\nstatic size_t parport_pc_fifo_write_block_dma(struct parport *port,\n\t\t\t\t\t       const void *buf, size_t length)\n{\n\tint ret = 0;\n\tunsigned long dmaflag;\n\tsize_t left = length;\n\tconst struct parport_pc_private *priv = port->physport->private_data;\n\tstruct device *dev = port->physport->dev;\n\tdma_addr_t dma_addr, dma_handle;\n\tsize_t maxlen = 0x10000;  \n\tunsigned long start = (unsigned long) buf;\n\tunsigned long end = (unsigned long) buf + length - 1;\n\n\tdump_parport_state(\"enter fifo_write_block_dma\", port);\n\tif (end < MAX_DMA_ADDRESS) {\n\t\t \n\t\tif ((start ^ end) & ~0xffffUL)\n\t\t\tmaxlen = 0x10000 - (start & 0xffff);\n\n\t\tdma_addr = dma_handle = dma_map_single(dev, (void *)buf, length,\n\t\t\t\t\t\t       DMA_TO_DEVICE);\n\t} else {\n\t\t \n\t\tmaxlen   = PAGE_SIZE;           \n\t\tdma_addr = priv->dma_handle;\n\t\tdma_handle = 0;\n\t}\n\n\tport = port->physport;\n\n\t \n\tparport_pc_disable_irq(port);\n\t \n\tfrob_econtrol(port, (1<<4) | (1<<2), (1<<4) | (1<<2));\n\n\t \n\tparport_pc_data_forward(port);  \n\n\twhile (left) {\n\t\tunsigned long expire = jiffies + port->physport->cad->timeout;\n\n\t\tsize_t count = left;\n\n\t\tif (count > maxlen)\n\t\t\tcount = maxlen;\n\n\t\tif (!dma_handle)    \n\t\t\tmemcpy(priv->dma_buf, buf, count);\n\n\t\tdmaflag = claim_dma_lock();\n\t\tdisable_dma(port->dma);\n\t\tclear_dma_ff(port->dma);\n\t\tset_dma_mode(port->dma, DMA_MODE_WRITE);\n\t\tset_dma_addr(port->dma, dma_addr);\n\t\tset_dma_count(port->dma, count);\n\n\t\t \n\t\tfrob_econtrol(port, 1<<3, 1<<3);\n\n\t\t \n\t\tfrob_econtrol(port, 1<<2, 0);\n\n\t\tenable_dma(port->dma);\n\t\trelease_dma_lock(dmaflag);\n\n\t\t \n\t\tleft -= count;\n\t\tbuf  += count;\n\t\tif (dma_handle)\n\t\t\tdma_addr += count;\n\n\t\t \nfalse_alarm:\n\t\tret = parport_wait_event(port, HZ);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tret = 0;\n\t\tif (!time_before(jiffies, expire)) {\n\t\t\t \n\t\t\tprintk(KERN_DEBUG \"DMA write timed out\\n\");\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tif (!(inb(ECONTROL(port)) & (1<<2))) {\n\t\t\tcond_resched();\n\n\t\t\tgoto false_alarm;\n\t\t}\n\n\t\tdmaflag = claim_dma_lock();\n\t\tdisable_dma(port->dma);\n\t\tclear_dma_ff(port->dma);\n\t\tcount = get_dma_residue(port->dma);\n\t\trelease_dma_lock(dmaflag);\n\n\t\tcond_resched();  \n\n\t\t \n\t\tif (port->waithead) {\n\t\t\tprintk(KERN_DEBUG \"Somebody wants the port\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tbuf  -= count;\n\t\tleft += count;\n\t\tif (dma_handle)\n\t\t\tdma_addr -= count;\n\t}\n\n\t \n\tdmaflag = claim_dma_lock();\n\tdisable_dma(port->dma);\n\tclear_dma_ff(port->dma);\n\tleft += get_dma_residue(port->dma);\n\trelease_dma_lock(dmaflag);\n\n\t \n\tfrob_econtrol(port, 1<<3, 0);\n\n\tif (dma_handle)\n\t\tdma_unmap_single(dev, dma_handle, length, DMA_TO_DEVICE);\n\n\tdump_parport_state(\"leave fifo_write_block_dma\", port);\n\treturn length - left;\n}\n#endif\n\nstatic inline size_t parport_pc_fifo_write_block(struct parport *port,\n\t\t\t\t\t       const void *buf, size_t length)\n{\n#ifdef HAS_DMA\n\tif (port->dma != PARPORT_DMA_NONE)\n\t\treturn parport_pc_fifo_write_block_dma(port, buf, length);\n#endif\n\treturn parport_pc_fifo_write_block_pio(port, buf, length);\n}\n\n \nstatic size_t parport_pc_compat_write_block_pio(struct parport *port,\n\t\t\t\t\t\t const void *buf, size_t length,\n\t\t\t\t\t\t int flags)\n{\n\tsize_t written;\n\tint r;\n\tunsigned long expire;\n\tconst struct parport_pc_private *priv = port->physport->private_data;\n\n\t \n\tif (port->physport->cad->timeout <= PARPORT_INACTIVITY_O_NONBLOCK)\n\t\treturn parport_ieee1284_write_compat(port, buf,\n\t\t\t\t\t\t      length, flags);\n\n\t \n\tparport_pc_data_forward(port);  \n\tparport_pc_frob_control(port, PARPORT_CONTROL_STROBE, 0);\n\tr = change_mode(port, ECR_PPF);  \n\tif (r)\n\t\tprintk(KERN_DEBUG \"%s: Warning change_mode ECR_PPF failed\\n\",\n\t\t       port->name);\n\n\tport->physport->ieee1284.phase = IEEE1284_PH_FWD_DATA;\n\n\t \n\twritten = parport_pc_fifo_write_block(port, buf, length);\n\n\t \n\t \n\texpire = jiffies + (priv->fifo_depth * HZ * 4);\n\tdo {\n\t\t \n\t\tr = change_mode(port, ECR_PS2);\n\t\tif (r != -EBUSY)\n\t\t\tbreak;\n\t} while (time_before(jiffies, expire));\n\tif (r == -EBUSY) {\n\n\t\tprintk(KERN_DEBUG \"%s: FIFO is stuck\\n\", port->name);\n\n\t\t \n\t\tfrob_set_mode(port, ECR_TST);\n\n\t\t \n\t\tfor (written -= priv->fifo_depth; ; written++) {\n\t\t\tif (inb(ECONTROL(port)) & 0x2) {\n\t\t\t\t \n\t\t\t\tbreak;\n\t\t\t}\n\t\t\toutb(0, FIFO(port));\n\t\t}\n\n\t\t \n\t\tfrob_set_mode(port, ECR_PS2);\n\t}\n\n\tr = parport_wait_peripheral(port,\n\t\t\t\t     PARPORT_STATUS_BUSY,\n\t\t\t\t     PARPORT_STATUS_BUSY);\n\tif (r)\n\t\tprintk(KERN_DEBUG \"%s: BUSY timeout (%d) in compat_write_block_pio\\n\",\n\t\t       port->name, r);\n\n\tport->physport->ieee1284.phase = IEEE1284_PH_FWD_IDLE;\n\n\treturn written;\n}\n\n \n#ifdef CONFIG_PARPORT_1284\nstatic size_t parport_pc_ecp_write_block_pio(struct parport *port,\n\t\t\t\t\t      const void *buf, size_t length,\n\t\t\t\t\t      int flags)\n{\n\tsize_t written;\n\tint r;\n\tunsigned long expire;\n\tconst struct parport_pc_private *priv = port->physport->private_data;\n\n\t \n\tif (port->physport->cad->timeout <= PARPORT_INACTIVITY_O_NONBLOCK)\n\t\treturn parport_ieee1284_ecp_write_data(port, buf,\n\t\t\t\t\t\t\tlength, flags);\n\n\t \n\tif (port->physport->ieee1284.phase != IEEE1284_PH_FWD_IDLE) {\n\t\t \n\t\tparport_frob_control(port,\n\t\t\t\t      PARPORT_CONTROL_INIT\n\t\t\t\t      | PARPORT_CONTROL_AUTOFD,\n\t\t\t\t      PARPORT_CONTROL_INIT\n\t\t\t\t      | PARPORT_CONTROL_AUTOFD);\n\n\t\t \n\t\tr = parport_wait_peripheral(port,\n\t\t\t\t\t     PARPORT_STATUS_PAPEROUT,\n\t\t\t\t\t     PARPORT_STATUS_PAPEROUT);\n\t\tif (r) {\n\t\t\tprintk(KERN_DEBUG \"%s: PError timeout (%d) in ecp_write_block_pio\\n\",\n\t\t\t       port->name, r);\n\t\t}\n\t}\n\n\t \n\tparport_pc_data_forward(port);  \n\tparport_pc_frob_control(port,\n\t\t\t\t PARPORT_CONTROL_STROBE |\n\t\t\t\t PARPORT_CONTROL_AUTOFD,\n\t\t\t\t 0);\n\tr = change_mode(port, ECR_ECP);  \n\tif (r)\n\t\tprintk(KERN_DEBUG \"%s: Warning change_mode ECR_ECP failed\\n\",\n\t\t       port->name);\n\tport->physport->ieee1284.phase = IEEE1284_PH_FWD_DATA;\n\n\t \n\twritten = parport_pc_fifo_write_block(port, buf, length);\n\n\t \n\t \n\texpire = jiffies + (priv->fifo_depth * (HZ * 4));\n\tdo {\n\t\t \n\t\tr = change_mode(port, ECR_PS2);\n\t\tif (r != -EBUSY)\n\t\t\tbreak;\n\t} while (time_before(jiffies, expire));\n\tif (r == -EBUSY) {\n\n\t\tprintk(KERN_DEBUG \"%s: FIFO is stuck\\n\", port->name);\n\n\t\t \n\t\tfrob_set_mode(port, ECR_TST);\n\n\t\t \n\t\tfor (written -= priv->fifo_depth; ; written++) {\n\t\t\tif (inb(ECONTROL(port)) & 0x2) {\n\t\t\t\t \n\t\t\t\tbreak;\n\t\t\t}\n\t\t\toutb(0, FIFO(port));\n\t\t}\n\n\t\t \n\t\tfrob_set_mode(port, ECR_PS2);\n\n\t\t \n\t\tparport_pc_data_reverse(port);  \n\t\tudelay(5);\n\t\tparport_frob_control(port, PARPORT_CONTROL_INIT, 0);\n\t\tr = parport_wait_peripheral(port, PARPORT_STATUS_PAPEROUT, 0);\n\t\tif (r)\n\t\t\tprintk(KERN_DEBUG \"%s: PE,1 timeout (%d) in ecp_write_block_pio\\n\",\n\t\t\t       port->name, r);\n\n\t\tparport_frob_control(port,\n\t\t\t\t      PARPORT_CONTROL_INIT,\n\t\t\t\t      PARPORT_CONTROL_INIT);\n\t\tr = parport_wait_peripheral(port,\n\t\t\t\t\t     PARPORT_STATUS_PAPEROUT,\n\t\t\t\t\t     PARPORT_STATUS_PAPEROUT);\n\t\tif (r)\n\t\t\tprintk(KERN_DEBUG \"%s: PE,2 timeout (%d) in ecp_write_block_pio\\n\",\n\t\t\t       port->name, r);\n\t}\n\n\tr = parport_wait_peripheral(port,\n\t\t\t\t     PARPORT_STATUS_BUSY,\n\t\t\t\t     PARPORT_STATUS_BUSY);\n\tif (r)\n\t\tprintk(KERN_DEBUG \"%s: BUSY timeout (%d) in ecp_write_block_pio\\n\",\n\t\t       port->name, r);\n\n\tport->physport->ieee1284.phase = IEEE1284_PH_FWD_IDLE;\n\n\treturn written;\n}\n#endif  \n#endif  \n\n\n \n\n \nstatic const struct parport_operations parport_pc_ops = {\n\t.write_data\t= parport_pc_write_data,\n\t.read_data\t= parport_pc_read_data,\n\n\t.write_control\t= parport_pc_write_control,\n\t.read_control\t= parport_pc_read_control,\n\t.frob_control\t= parport_pc_frob_control,\n\n\t.read_status\t= parport_pc_read_status,\n\n\t.enable_irq\t= parport_pc_enable_irq,\n\t.disable_irq\t= parport_pc_disable_irq,\n\n\t.data_forward\t= parport_pc_data_forward,\n\t.data_reverse\t= parport_pc_data_reverse,\n\n\t.init_state\t= parport_pc_init_state,\n\t.save_state\t= parport_pc_save_state,\n\t.restore_state\t= parport_pc_restore_state,\n\n\t.epp_write_data\t= parport_ieee1284_epp_write_data,\n\t.epp_read_data\t= parport_ieee1284_epp_read_data,\n\t.epp_write_addr\t= parport_ieee1284_epp_write_addr,\n\t.epp_read_addr\t= parport_ieee1284_epp_read_addr,\n\n\t.ecp_write_data\t= parport_ieee1284_ecp_write_data,\n\t.ecp_read_data\t= parport_ieee1284_ecp_read_data,\n\t.ecp_write_addr\t= parport_ieee1284_ecp_write_addr,\n\n\t.compat_write_data\t= parport_ieee1284_write_compat,\n\t.nibble_read_data\t= parport_ieee1284_read_nibble,\n\t.byte_read_data\t\t= parport_ieee1284_read_byte,\n\n\t.owner\t\t= THIS_MODULE,\n};\n\n#ifdef CONFIG_PARPORT_PC_SUPERIO\n\nstatic struct superio_struct *find_free_superio(void)\n{\n\tint i;\n\tfor (i = 0; i < NR_SUPERIOS; i++)\n\t\tif (superios[i].io == 0)\n\t\t\treturn &superios[i];\n\treturn NULL;\n}\n\n\n \nstatic void show_parconfig_smsc37c669(int io, int key)\n{\n\tint cr1, cr4, cra, cr23, cr26, cr27;\n\tstruct superio_struct *s;\n\n\tstatic const char *const modes[] = {\n\t\t\"SPP and Bidirectional (PS/2)\",\n\t\t\"EPP and SPP\",\n\t\t\"ECP\",\n\t\t\"ECP and EPP\" };\n\n\toutb(key, io);\n\toutb(key, io);\n\toutb(1, io);\n\tcr1 = inb(io + 1);\n\toutb(4, io);\n\tcr4 = inb(io + 1);\n\toutb(0x0a, io);\n\tcra = inb(io + 1);\n\toutb(0x23, io);\n\tcr23 = inb(io + 1);\n\toutb(0x26, io);\n\tcr26 = inb(io + 1);\n\toutb(0x27, io);\n\tcr27 = inb(io + 1);\n\toutb(0xaa, io);\n\n\tif (verbose_probing) {\n\t\tpr_info(\"SMSC 37c669 LPT Config: cr_1=0x%02x, 4=0x%02x, A=0x%2x, 23=0x%02x, 26=0x%02x, 27=0x%02x\\n\",\n\t\t\tcr1, cr4, cra, cr23, cr26, cr27);\n\n\t\t \n\t\tpr_info(\"SMSC LPT Config: io=0x%04x, irq=%c, dma=%c, fifo threshold=%d\\n\",\n\t\t\tcr23 * 4,\n\t\t\t(cr27 & 0x0f) ? 'A' - 1 + (cr27 & 0x0f) : '-',\n\t\t\t(cr26 & 0x0f) ? 'A' - 1 + (cr26 & 0x0f) : '-',\n\t\t\tcra & 0x0f);\n\t\tpr_info(\"SMSC LPT Config: enabled=%s power=%s\\n\",\n\t\t\t(cr23 * 4 >= 0x100) ? \"yes\" : \"no\",\n\t\t\t(cr1 & 4) ? \"yes\" : \"no\");\n\t\tpr_info(\"SMSC LPT Config: Port mode=%s, EPP version =%s\\n\",\n\t\t\t(cr1 & 0x08) ? \"Standard mode only (SPP)\"\n\t\t\t: modes[cr4 & 0x03],\n\t\t\t(cr4 & 0x40) ? \"1.7\" : \"1.9\");\n\t}\n\n\t \n\tif (cr23 * 4 >= 0x100) {  \n\t\ts = find_free_superio();\n\t\tif (s == NULL)\n\t\t\tpr_info(\"Super-IO: too many chips!\\n\");\n\t\telse {\n\t\t\tint d;\n\t\t\tswitch (cr23 * 4) {\n\t\t\tcase 0x3bc:\n\t\t\t\ts->io = 0x3bc;\n\t\t\t\ts->irq = 7;\n\t\t\t\tbreak;\n\t\t\tcase 0x378:\n\t\t\t\ts->io = 0x378;\n\t\t\t\ts->irq = 7;\n\t\t\t\tbreak;\n\t\t\tcase 0x278:\n\t\t\t\ts->io = 0x278;\n\t\t\t\ts->irq = 5;\n\t\t\t}\n\t\t\td = (cr26 & 0x0f);\n\t\t\tif (d == 1 || d == 3)\n\t\t\t\ts->dma = d;\n\t\t\telse\n\t\t\t\ts->dma = PARPORT_DMA_NONE;\n\t\t}\n\t}\n}\n\n\nstatic void show_parconfig_winbond(int io, int key)\n{\n\tint cr30, cr60, cr61, cr70, cr74, crf0;\n\tstruct superio_struct *s;\n\tstatic const char *const modes[] = {\n\t\t\"Standard (SPP) and Bidirectional(PS/2)\",  \n\t\t\"EPP-1.9 and SPP\",\n\t\t\"ECP\",\n\t\t\"ECP and EPP-1.9\",\n\t\t\"Standard (SPP)\",\n\t\t\"EPP-1.7 and SPP\",\t\t \n\t\t\"undefined!\",\n\t\t\"ECP and EPP-1.7\" };\n\tstatic char *const irqtypes[] = {\n\t\t\"pulsed low, high-Z\",\n\t\t\"follows nACK\" };\n\n\t \n\toutb(key, io);\n\toutb(key, io);\n\toutb(0x07, io);    \n\toutb(0x01, io + 1);  \n\toutb(0x30, io);\n\tcr30 = inb(io + 1);\n\toutb(0x60, io);\n\tcr60 = inb(io + 1);\n\toutb(0x61, io);\n\tcr61 = inb(io + 1);\n\toutb(0x70, io);\n\tcr70 = inb(io + 1);\n\toutb(0x74, io);\n\tcr74 = inb(io + 1);\n\toutb(0xf0, io);\n\tcrf0 = inb(io + 1);\n\toutb(0xaa, io);\n\n\tif (verbose_probing) {\n\t\tpr_info(\"Winbond LPT Config: cr_30=%02x 60,61=%02x%02x 70=%02x 74=%02x, f0=%02x\\n\",\n\t\t\tcr30, cr60, cr61, cr70, cr74, crf0);\n\t\tpr_info(\"Winbond LPT Config: active=%s, io=0x%02x%02x irq=%d, \",\n\t\t\t(cr30 & 0x01) ? \"yes\" : \"no\", cr60, cr61, cr70 & 0x0f);\n\t\tif ((cr74 & 0x07) > 3)\n\t\t\tpr_cont(\"dma=none\\n\");\n\t\telse\n\t\t\tpr_cont(\"dma=%d\\n\", cr74 & 0x07);\n\t\tpr_info(\"Winbond LPT Config: irqtype=%s, ECP fifo threshold=%d\\n\",\n\t\t\tirqtypes[crf0 >> 7], (crf0 >> 3) & 0x0f);\n\t\tpr_info(\"Winbond LPT Config: Port mode=%s\\n\",\n\t\t\tmodes[crf0 & 0x07]);\n\t}\n\n\tif (cr30 & 0x01) {  \n\t\ts = find_free_superio();\n\t\tif (s == NULL)\n\t\t\tpr_info(\"Super-IO: too many chips!\\n\");\n\t\telse {\n\t\t\ts->io = (cr60 << 8) | cr61;\n\t\t\ts->irq = cr70 & 0x0f;\n\t\t\ts->dma = (((cr74 & 0x07) > 3) ?\n\t\t\t\t\t   PARPORT_DMA_NONE : (cr74 & 0x07));\n\t\t}\n\t}\n}\n\nstatic void decode_winbond(int efer, int key, int devid, int devrev, int oldid)\n{\n\tconst char *type = \"unknown\";\n\tint id, progif = 2;\n\n\tif (devid == devrev)\n\t\t \n\t\treturn;\n\n\tid = (devid << 8) | devrev;\n\n\t \n\tif (id == 0x9771)\n\t\ttype = \"83977F/AF\";\n\telse if (id == 0x9773)\n\t\ttype = \"83977TF / SMSC 97w33x/97w34x\";\n\telse if (id == 0x9774)\n\t\ttype = \"83977ATF\";\n\telse if ((id & ~0x0f) == 0x5270)\n\t\ttype = \"83977CTF / SMSC 97w36x\";\n\telse if ((id & ~0x0f) == 0x52f0)\n\t\ttype = \"83977EF / SMSC 97w35x\";\n\telse if ((id & ~0x0f) == 0x5210)\n\t\ttype = \"83627\";\n\telse if ((id & ~0x0f) == 0x6010)\n\t\ttype = \"83697HF\";\n\telse if ((oldid & 0x0f) == 0x0a) {\n\t\ttype = \"83877F\";\n\t\tprogif = 1;\n\t} else if ((oldid & 0x0f) == 0x0b) {\n\t\ttype = \"83877AF\";\n\t\tprogif = 1;\n\t} else if ((oldid & 0x0f) == 0x0c) {\n\t\ttype = \"83877TF\";\n\t\tprogif = 1;\n\t} else if ((oldid & 0x0f) == 0x0d) {\n\t\ttype = \"83877ATF\";\n\t\tprogif = 1;\n\t} else\n\t\tprogif = 0;\n\n\tif (verbose_probing)\n\t\tpr_info(\"Winbond chip at EFER=0x%x key=0x%02x devid=%02x devrev=%02x oldid=%02x type=%s\\n\",\n\t\t\tefer, key, devid, devrev, oldid, type);\n\n\tif (progif == 2)\n\t\tshow_parconfig_winbond(efer, key);\n}\n\nstatic void decode_smsc(int efer, int key, int devid, int devrev)\n{\n\tconst char *type = \"unknown\";\n\tvoid (*func)(int io, int key);\n\tint id;\n\n\tif (devid == devrev)\n\t\t \n\t\treturn;\n\n\tfunc = NULL;\n\tid = (devid << 8) | devrev;\n\n\tif (id == 0x0302) {\n\t\ttype = \"37c669\";\n\t\tfunc = show_parconfig_smsc37c669;\n\t} else if (id == 0x6582)\n\t\ttype = \"37c665IR\";\n\telse if\t(devid == 0x65)\n\t\ttype = \"37c665GT\";\n\telse if\t(devid == 0x66)\n\t\ttype = \"37c666GT\";\n\n\tif (verbose_probing)\n\t\tpr_info(\"SMSC chip at EFER=0x%x key=0x%02x devid=%02x devrev=%02x type=%s\\n\",\n\t\t\tefer, key, devid, devrev, type);\n\n\tif (func)\n\t\tfunc(efer, key);\n}\n\n\nstatic void winbond_check(int io, int key)\n{\n\tint origval, devid, devrev, oldid, x_devid, x_devrev, x_oldid;\n\n\tif (!request_region(io, 3, __func__))\n\t\treturn;\n\n\torigval = inb(io);  \n\n\t \n\toutb(0x20, io);\n\tx_devid = inb(io + 1);\n\toutb(0x21, io);\n\tx_devrev = inb(io + 1);\n\toutb(0x09, io);\n\tx_oldid = inb(io + 1);\n\n\toutb(key, io);\n\toutb(key, io);      \n\toutb(0x20, io);     \n\tdevid = inb(io + 1);   \n\toutb(0x21, io);\n\tdevrev = inb(io + 1);\n\toutb(0x09, io);\n\toldid = inb(io + 1);\n\toutb(0xaa, io);     \n\n\toutb(origval, io);  \n\n\tif ((x_devid == devid) && (x_devrev == devrev) && (x_oldid == oldid))\n\t\tgoto out;  \n\n\tdecode_winbond(io, key, devid, devrev, oldid);\nout:\n\trelease_region(io, 3);\n}\n\nstatic void winbond_check2(int io, int key)\n{\n\tint origval[3], devid, devrev, oldid, x_devid, x_devrev, x_oldid;\n\n\tif (!request_region(io, 3, __func__))\n\t\treturn;\n\n\torigval[0] = inb(io);  \n\torigval[1] = inb(io + 1);\n\torigval[2] = inb(io + 2);\n\n\t \n\toutb(0x20, io + 2);\n\tx_devid = inb(io + 2);\n\toutb(0x21, io + 1);\n\tx_devrev = inb(io + 2);\n\toutb(0x09, io + 1);\n\tx_oldid = inb(io + 2);\n\n\toutb(key, io);      \n\toutb(0x20, io + 2);   \n\tdevid = inb(io + 2);   \n\toutb(0x21, io + 1);\n\tdevrev = inb(io + 2);\n\toutb(0x09, io + 1);\n\toldid = inb(io + 2);\n\toutb(0xaa, io);     \n\n\toutb(origval[0], io);  \n\toutb(origval[1], io + 1);\n\toutb(origval[2], io + 2);\n\n\tif (x_devid == devid && x_devrev == devrev && x_oldid == oldid)\n\t\tgoto out;  \n\n\tdecode_winbond(io, key, devid, devrev, oldid);\nout:\n\trelease_region(io, 3);\n}\n\nstatic void smsc_check(int io, int key)\n{\n\tint origval, id, rev, oldid, oldrev, x_id, x_rev, x_oldid, x_oldrev;\n\n\tif (!request_region(io, 3, __func__))\n\t\treturn;\n\n\torigval = inb(io);  \n\n\t \n\toutb(0x0d, io);\n\tx_oldid = inb(io + 1);\n\toutb(0x0e, io);\n\tx_oldrev = inb(io + 1);\n\toutb(0x20, io);\n\tx_id = inb(io + 1);\n\toutb(0x21, io);\n\tx_rev = inb(io + 1);\n\n\toutb(key, io);\n\toutb(key, io);      \n\toutb(0x0d, io);     \n\toldid = inb(io + 1);   \n\toutb(0x0e, io);\n\toldrev = inb(io + 1);\n\toutb(0x20, io);\n\tid = inb(io + 1);\n\toutb(0x21, io);\n\trev = inb(io + 1);\n\toutb(0xaa, io);     \n\n\toutb(origval, io);  \n\n\tif (x_id == id && x_oldrev == oldrev &&\n\t    x_oldid == oldid && x_rev == rev)\n\t\tgoto out;  \n\n\tdecode_smsc(io, key, oldid, oldrev);\nout:\n\trelease_region(io, 3);\n}\n\n\nstatic void detect_and_report_winbond(void)\n{\n\tif (verbose_probing)\n\t\tprintk(KERN_DEBUG \"Winbond Super-IO detection, now testing ports 3F0,370,250,4E,2E ...\\n\");\n\twinbond_check(0x3f0, 0x87);\n\twinbond_check(0x370, 0x87);\n\twinbond_check(0x2e , 0x87);\n\twinbond_check(0x4e , 0x87);\n\twinbond_check(0x3f0, 0x86);\n\twinbond_check2(0x250, 0x88);\n\twinbond_check2(0x250, 0x89);\n}\n\nstatic void detect_and_report_smsc(void)\n{\n\tif (verbose_probing)\n\t\tprintk(KERN_DEBUG \"SMSC Super-IO detection, now testing Ports 2F0, 370 ...\\n\");\n\tsmsc_check(0x3f0, 0x55);\n\tsmsc_check(0x370, 0x55);\n\tsmsc_check(0x3f0, 0x44);\n\tsmsc_check(0x370, 0x44);\n}\n\nstatic void detect_and_report_it87(void)\n{\n\tu16 dev;\n\tu8 origval, r;\n\tif (verbose_probing)\n\t\tprintk(KERN_DEBUG \"IT8705 Super-IO detection, now testing port 2E ...\\n\");\n\tif (!request_muxed_region(0x2e, 2, __func__))\n\t\treturn;\n\torigval = inb(0x2e);\t\t \n\toutb(0x87, 0x2e);\n\toutb(0x01, 0x2e);\n\toutb(0x55, 0x2e);\n\toutb(0x55, 0x2e);\n\toutb(0x20, 0x2e);\n\tdev = inb(0x2f) << 8;\n\toutb(0x21, 0x2e);\n\tdev |= inb(0x2f);\n\tif (dev == 0x8712 || dev == 0x8705 || dev == 0x8715 ||\n\t    dev == 0x8716 || dev == 0x8718 || dev == 0x8726) {\n\t\tpr_info(\"IT%04X SuperIO detected\\n\", dev);\n\t\toutb(0x07, 0x2E);\t \n\t\toutb(0x03, 0x2F);\n\t\toutb(0xF0, 0x2E);\t \n\t\tr = inb(0x2f);\n\t\toutb(0xF0, 0x2E);\n\t\toutb(r | 8, 0x2F);\n\t\toutb(0x02, 0x2E);\t \n\t\toutb(0x02, 0x2F);\n\t} else {\n\t\toutb(origval, 0x2e);\t \n\t}\n\trelease_region(0x2e, 2);\n}\n#endif  \n\nstatic struct superio_struct *find_superio(struct parport *p)\n{\n\tint i;\n\tfor (i = 0; i < NR_SUPERIOS; i++)\n\t\tif (superios[i].io == p->base)\n\t\t\treturn &superios[i];\n\treturn NULL;\n}\n\nstatic int get_superio_dma(struct parport *p)\n{\n\tstruct superio_struct *s = find_superio(p);\n\tif (s)\n\t\treturn s->dma;\n\treturn PARPORT_DMA_NONE;\n}\n\nstatic int get_superio_irq(struct parport *p)\n{\n\tstruct superio_struct *s = find_superio(p);\n\tif (s)\n\t\treturn s->irq;\n\treturn PARPORT_IRQ_NONE;\n}\n\n\n \n\n \nstatic int parport_SPP_supported(struct parport *pb)\n{\n\tunsigned char r, w;\n\n\t \n\tclear_epp_timeout(pb);\n\n\t \n\tw = 0xc;\n\toutb(w, CONTROL(pb));\n\n\t \n\tr = inb(CONTROL(pb));\n\tif ((r & 0xf) == w) {\n\t\tw = 0xe;\n\t\toutb(w, CONTROL(pb));\n\t\tr = inb(CONTROL(pb));\n\t\toutb(0xc, CONTROL(pb));\n\t\tif ((r & 0xf) == w)\n\t\t\treturn PARPORT_MODE_PCSPP;\n\t}\n\n\tif (user_specified)\n\t\t \n\t\tpr_info(\"parport 0x%lx (WARNING): CTR: wrote 0x%02x, read 0x%02x\\n\",\n\t\t\tpb->base, w, r);\n\n\t \n\tw = 0xaa;\n\tparport_pc_write_data(pb, w);\n\tr = parport_pc_read_data(pb);\n\tif (r == w) {\n\t\tw = 0x55;\n\t\tparport_pc_write_data(pb, w);\n\t\tr = parport_pc_read_data(pb);\n\t\tif (r == w)\n\t\t\treturn PARPORT_MODE_PCSPP;\n\t}\n\n\tif (user_specified) {\n\t\t \n\t\tpr_info(\"parport 0x%lx (WARNING): DATA: wrote 0x%02x, read 0x%02x\\n\",\n\t\t\tpb->base, w, r);\n\t\tpr_info(\"parport 0x%lx: You gave this address, but there is probably no parallel port there!\\n\",\n\t\t\tpb->base);\n\t}\n\n\t \n\tif (user_specified)\n\t\treturn PARPORT_MODE_PCSPP;\n\n\treturn 0;\n}\n\n \nstatic int parport_ECR_present(struct parport *pb)\n{\n\tstruct parport_pc_private *priv = pb->private_data;\n\tunsigned char r = 0xc;\n\n\tif (!priv->ecr_writable) {\n\t\toutb(r, CONTROL(pb));\n\t\tif ((inb(ECONTROL(pb)) & 0x3) == (r & 0x3)) {\n\t\t\toutb(r ^ 0x2, CONTROL(pb));  \n\n\t\t\tr = inb(CONTROL(pb));\n\t\t\tif ((inb(ECONTROL(pb)) & 0x2) == (r & 0x2))\n\t\t\t\t \n\t\t\t\tgoto no_reg;\n\t\t}\n\n\t\tif ((inb(ECONTROL(pb)) & 0x3) != 0x1)\n\t\t\tgoto no_reg;\n\n\t\tECR_WRITE(pb, 0x34);\n\t\tif (inb(ECONTROL(pb)) != 0x35)\n\t\t\tgoto no_reg;\n\t}\n\n\tpriv->ecr = 1;\n\toutb(0xc, CONTROL(pb));\n\n\t \n\tfrob_set_mode(pb, ECR_SPP);\n\n\treturn 1;\n\n no_reg:\n\toutb(0xc, CONTROL(pb));\n\treturn 0;\n}\n\n#ifdef CONFIG_PARPORT_1284\n \n\nstatic int parport_PS2_supported(struct parport *pb)\n{\n\tint ok = 0;\n\n\tclear_epp_timeout(pb);\n\n\t \n\tparport_pc_data_reverse(pb);\n\n\tparport_pc_write_data(pb, 0x55);\n\tif (parport_pc_read_data(pb) != 0x55)\n\t\tok++;\n\n\tparport_pc_write_data(pb, 0xaa);\n\tif (parport_pc_read_data(pb) != 0xaa)\n\t\tok++;\n\n\t \n\tparport_pc_data_forward(pb);\n\n\tif (ok) {\n\t\tpb->modes |= PARPORT_MODE_TRISTATE;\n\t} else {\n\t\tstruct parport_pc_private *priv = pb->private_data;\n\t\tpriv->ctr_writable &= ~0x20;\n\t}\n\n\treturn ok;\n}\n\n#ifdef CONFIG_PARPORT_PC_FIFO\nstatic int parport_ECP_supported(struct parport *pb)\n{\n\tint i;\n\tint config, configb;\n\tint pword;\n\tstruct parport_pc_private *priv = pb->private_data;\n\t \n\tstatic const int intrline[] = { 0, 7, 9, 10, 11, 14, 15, 5 };\n\n\t \n\tif (!priv->ecr)\n\t\treturn 0;\n\n\t \n\tECR_WRITE(pb, ECR_SPP << 5);  \n\tECR_WRITE(pb, ECR_TST << 5);  \n\tfor (i = 0; i < 1024 && !(inb(ECONTROL(pb)) & 0x02); i++)\n\t\toutb(0xaa, FIFO(pb));\n\n\t \n\tif (i == 1024) {\n\t\tECR_WRITE(pb, ECR_SPP << 5);\n\t\treturn 0;\n\t}\n\n\tpriv->fifo_depth = i;\n\tif (verbose_probing)\n\t\tprintk(KERN_DEBUG \"0x%lx: FIFO is %d bytes\\n\", pb->base, i);\n\n\t \n\tfrob_econtrol(pb, 1<<2, 1<<2);\n\tfrob_econtrol(pb, 1<<2, 0);\n\tfor (i = 1; i <= priv->fifo_depth; i++) {\n\t\tinb(FIFO(pb));\n\t\tudelay(50);\n\t\tif (inb(ECONTROL(pb)) & (1<<2))\n\t\t\tbreak;\n\t}\n\n\tif (i <= priv->fifo_depth) {\n\t\tif (verbose_probing)\n\t\t\tprintk(KERN_DEBUG \"0x%lx: writeIntrThreshold is %d\\n\",\n\t\t\t       pb->base, i);\n\t} else\n\t\t \n\t\ti = 0;\n\n\tpriv->writeIntrThreshold = i;\n\n\t \n\tfrob_set_mode(pb, ECR_PS2);  \n\tparport_pc_data_reverse(pb);  \n\tfrob_set_mode(pb, ECR_TST);  \n\tfrob_econtrol(pb, 1<<2, 1<<2);\n\tfrob_econtrol(pb, 1<<2, 0);\n\tfor (i = 1; i <= priv->fifo_depth; i++) {\n\t\toutb(0xaa, FIFO(pb));\n\t\tif (inb(ECONTROL(pb)) & (1<<2))\n\t\t\tbreak;\n\t}\n\n\tif (i <= priv->fifo_depth) {\n\t\tif (verbose_probing)\n\t\t\tpr_info(\"0x%lx: readIntrThreshold is %d\\n\",\n\t\t\t\tpb->base, i);\n\t} else\n\t\t \n\t\ti = 0;\n\n\tpriv->readIntrThreshold = i;\n\n\tECR_WRITE(pb, ECR_SPP << 5);  \n\tECR_WRITE(pb, 0xf4);  \n\tconfig = inb(CONFIGA(pb));\n\tpword = (config >> 4) & 0x7;\n\tswitch (pword) {\n\tcase 0:\n\t\tpword = 2;\n\t\tpr_warn(\"0x%lx: Unsupported pword size!\\n\", pb->base);\n\t\tbreak;\n\tcase 2:\n\t\tpword = 4;\n\t\tpr_warn(\"0x%lx: Unsupported pword size!\\n\", pb->base);\n\t\tbreak;\n\tdefault:\n\t\tpr_warn(\"0x%lx: Unknown implementation ID\\n\", pb->base);\n\t\tfallthrough;\t \n\tcase 1:\n\t\tpword = 1;\n\t}\n\tpriv->pword = pword;\n\n\tif (verbose_probing) {\n\t\tprintk(KERN_DEBUG \"0x%lx: PWord is %d bits\\n\",\n\t\t       pb->base, 8 * pword);\n\n\t\tprintk(KERN_DEBUG \"0x%lx: Interrupts are ISA-%s\\n\",\n\t\t       pb->base, config & 0x80 ? \"Level\" : \"Pulses\");\n\n\t\tconfigb = inb(CONFIGB(pb));\n\t\tprintk(KERN_DEBUG \"0x%lx: ECP port cfgA=0x%02x cfgB=0x%02x\\n\",\n\t\t       pb->base, config, configb);\n\t\tprintk(KERN_DEBUG \"0x%lx: ECP settings irq=\", pb->base);\n\t\tif ((configb >> 3) & 0x07)\n\t\t\tpr_cont(\"%d\", intrline[(configb >> 3) & 0x07]);\n\t\telse\n\t\t\tpr_cont(\"<none or set by other means>\");\n\t\tpr_cont(\" dma=\");\n\t\tif ((configb & 0x03) == 0x00)\n\t\t\tpr_cont(\"<none or set by other means>\\n\");\n\t\telse\n\t\t\tpr_cont(\"%d\\n\", configb & 0x07);\n\t}\n\n\t \n\tfrob_set_mode(pb, ECR_SPP);\n\n\treturn 1;\n}\n#endif\n\n#ifdef CONFIG_X86_32\nstatic int intel_bug_present_check_epp(struct parport *pb)\n{\n\tconst struct parport_pc_private *priv = pb->private_data;\n\tint bug_present = 0;\n\n\tif (priv->ecr) {\n\t\t \n\t\tunsigned char ecr = inb(ECONTROL(pb));\n\t\tunsigned char i;\n\t\tfor (i = 0x00; i < 0x80; i += 0x20) {\n\t\t\tECR_WRITE(pb, i);\n\t\t\tif (clear_epp_timeout(pb)) {\n\t\t\t\t \n\t\t\t\tbug_present = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t \n\t\tECR_WRITE(pb, ecr);\n\t}\n\n\treturn bug_present;\n}\nstatic int intel_bug_present(struct parport *pb)\n{\n \n\tif (pb->dev != NULL) {\n\t\treturn 0;\n\t}\n\n\treturn intel_bug_present_check_epp(pb);\n}\n#else\nstatic int intel_bug_present(struct parport *pb)\n{\n\treturn 0;\n}\n#endif  \n\nstatic int parport_ECPPS2_supported(struct parport *pb)\n{\n\tconst struct parport_pc_private *priv = pb->private_data;\n\tint result;\n\tunsigned char oecr;\n\n\tif (!priv->ecr)\n\t\treturn 0;\n\n\toecr = inb(ECONTROL(pb));\n\tECR_WRITE(pb, ECR_PS2 << 5);\n\tresult = parport_PS2_supported(pb);\n\tECR_WRITE(pb, oecr);\n\treturn result;\n}\n\n \n\nstatic int parport_EPP_supported(struct parport *pb)\n{\n\t \n\n\t \n\tif (!clear_epp_timeout(pb))\n\t\treturn 0;   \n\n\t \n\tif (intel_bug_present(pb))\n\t\treturn 0;\n\n\tpb->modes |= PARPORT_MODE_EPP;\n\n\t \n\tpb->ops->epp_read_data = parport_pc_epp_read_data;\n\tpb->ops->epp_write_data = parport_pc_epp_write_data;\n\tpb->ops->epp_read_addr = parport_pc_epp_read_addr;\n\tpb->ops->epp_write_addr = parport_pc_epp_write_addr;\n\n\treturn 1;\n}\n\nstatic int parport_ECPEPP_supported(struct parport *pb)\n{\n\tstruct parport_pc_private *priv = pb->private_data;\n\tint result;\n\tunsigned char oecr;\n\n\tif (!priv->ecr)\n\t\treturn 0;\n\n\toecr = inb(ECONTROL(pb));\n\t \n\tECR_WRITE(pb, 0x80);\n\toutb(0x04, CONTROL(pb));\n\tresult = parport_EPP_supported(pb);\n\n\tECR_WRITE(pb, oecr);\n\n\tif (result) {\n\t\t \n\t\tpb->ops->epp_read_data = parport_pc_ecpepp_read_data;\n\t\tpb->ops->epp_write_data = parport_pc_ecpepp_write_data;\n\t\tpb->ops->epp_read_addr = parport_pc_ecpepp_read_addr;\n\t\tpb->ops->epp_write_addr = parport_pc_ecpepp_write_addr;\n\t}\n\n\treturn result;\n}\n\n#else  \n\n \nstatic int parport_PS2_supported(struct parport *pb) { return 0; }\n#ifdef CONFIG_PARPORT_PC_FIFO\nstatic int parport_ECP_supported(struct parport *pb)\n{\n\treturn 0;\n}\n#endif\nstatic int parport_EPP_supported(struct parport *pb)\n{\n\treturn 0;\n}\n\nstatic int parport_ECPEPP_supported(struct parport *pb)\n{\n\treturn 0;\n}\n\nstatic int parport_ECPPS2_supported(struct parport *pb)\n{\n\treturn 0;\n}\n\n#endif  \n\n \n\n \nstatic int programmable_irq_support(struct parport *pb)\n{\n\tint irq, intrLine;\n\tunsigned char oecr = inb(ECONTROL(pb));\n\tstatic const int lookup[8] = {\n\t\tPARPORT_IRQ_NONE, 7, 9, 10, 11, 14, 15, 5\n\t};\n\n\tECR_WRITE(pb, ECR_CNF << 5);  \n\n\tintrLine = (inb(CONFIGB(pb)) >> 3) & 0x07;\n\tirq = lookup[intrLine];\n\n\tECR_WRITE(pb, oecr);\n\treturn irq;\n}\n\nstatic int irq_probe_ECP(struct parport *pb)\n{\n\tint i;\n\tunsigned long irqs;\n\n\tirqs = probe_irq_on();\n\n\tECR_WRITE(pb, ECR_SPP << 5);  \n\tECR_WRITE(pb, (ECR_TST << 5) | 0x04);\n\tECR_WRITE(pb, ECR_TST << 5);\n\n\t \n\tfor (i = 0; i < 1024 && !(inb(ECONTROL(pb)) & 0x02) ; i++)\n\t\toutb(0xaa, FIFO(pb));\n\n\tpb->irq = probe_irq_off(irqs);\n\tECR_WRITE(pb, ECR_SPP << 5);\n\n\tif (pb->irq <= 0)\n\t\tpb->irq = PARPORT_IRQ_NONE;\n\n\treturn pb->irq;\n}\n\n \nstatic int irq_probe_EPP(struct parport *pb)\n{\n#ifndef ADVANCED_DETECT\n\treturn PARPORT_IRQ_NONE;\n#else\n\tint irqs;\n\tunsigned char oecr;\n\n\tif (pb->modes & PARPORT_MODE_PCECR)\n\t\toecr = inb(ECONTROL(pb));\n\n\tirqs = probe_irq_on();\n\n\tif (pb->modes & PARPORT_MODE_PCECR)\n\t\tfrob_econtrol(pb, 0x10, 0x10);\n\n\tclear_epp_timeout(pb);\n\tparport_pc_frob_control(pb, 0x20, 0x20);\n\tparport_pc_frob_control(pb, 0x10, 0x10);\n\tclear_epp_timeout(pb);\n\n\t \n\tparport_pc_read_epp(pb);\n\tudelay(20);\n\n\tpb->irq = probe_irq_off(irqs);\n\tif (pb->modes & PARPORT_MODE_PCECR)\n\t\tECR_WRITE(pb, oecr);\n\tparport_pc_write_control(pb, 0xc);\n\n\tif (pb->irq <= 0)\n\t\tpb->irq = PARPORT_IRQ_NONE;\n\n\treturn pb->irq;\n#endif  \n}\n\nstatic int irq_probe_SPP(struct parport *pb)\n{\n\t \n\treturn PARPORT_IRQ_NONE;\n}\n\n \nstatic int parport_irq_probe(struct parport *pb)\n{\n\tstruct parport_pc_private *priv = pb->private_data;\n\n\tif (priv->ecr) {\n\t\tpb->irq = programmable_irq_support(pb);\n\n\t\tif (pb->irq == PARPORT_IRQ_NONE)\n\t\t\tpb->irq = irq_probe_ECP(pb);\n\t}\n\n\tif ((pb->irq == PARPORT_IRQ_NONE) && priv->ecr &&\n\t    (pb->modes & PARPORT_MODE_EPP))\n\t\tpb->irq = irq_probe_EPP(pb);\n\n\tclear_epp_timeout(pb);\n\n\tif (pb->irq == PARPORT_IRQ_NONE && (pb->modes & PARPORT_MODE_EPP))\n\t\tpb->irq = irq_probe_EPP(pb);\n\n\tclear_epp_timeout(pb);\n\n\tif (pb->irq == PARPORT_IRQ_NONE)\n\t\tpb->irq = irq_probe_SPP(pb);\n\n\tif (pb->irq == PARPORT_IRQ_NONE)\n\t\tpb->irq = get_superio_irq(pb);\n\n\treturn pb->irq;\n}\n\n \n\n \nstatic int programmable_dma_support(struct parport *p)\n{\n\tunsigned char oecr = inb(ECONTROL(p));\n\tint dma;\n\n\tfrob_set_mode(p, ECR_CNF);\n\n\tdma = inb(CONFIGB(p)) & 0x07;\n\t \n\tif ((dma & 0x03) == 0)\n\t\tdma = PARPORT_DMA_NONE;\n\n\tECR_WRITE(p, oecr);\n\treturn dma;\n}\n\nstatic int parport_dma_probe(struct parport *p)\n{\n\tconst struct parport_pc_private *priv = p->private_data;\n\tif (priv->ecr)\t\t \n\t\tp->dma = programmable_dma_support(p);\n\tif (p->dma == PARPORT_DMA_NONE) {\n\t\t \n\t\tp->dma = get_superio_dma(p);\n\t}\n\n\treturn p->dma;\n}\n\n \n\nstatic LIST_HEAD(ports_list);\nstatic DEFINE_SPINLOCK(ports_lock);\n\nstatic struct parport *__parport_pc_probe_port(unsigned long int base,\n\t\t\t\t\t       unsigned long int base_hi,\n\t\t\t\t\t       int irq, int dma,\n\t\t\t\t\t       struct device *dev,\n\t\t\t\t\t       int irqflags,\n\t\t\t\t\t       unsigned int mode_mask,\n\t\t\t\t\t       unsigned char ecr_writable)\n{\n\tstruct parport_pc_private *priv;\n\tstruct parport_operations *ops;\n\tstruct parport *p;\n\tint probedirq = PARPORT_IRQ_NONE;\n\tstruct resource *base_res;\n\tstruct resource\t*ECR_res = NULL;\n\tstruct resource\t*EPP_res = NULL;\n\tstruct platform_device *pdev = NULL;\n\tint ret;\n\n\tif (!dev) {\n\t\t \n\t\tpdev = platform_device_register_simple(\"parport_pc\",\n\t\t\t\t\t\t       base, NULL, 0);\n\t\tif (IS_ERR(pdev))\n\t\t\treturn NULL;\n\t\tdev = &pdev->dev;\n\n\t\tret = dma_coerce_mask_and_coherent(dev, DMA_BIT_MASK(24));\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Unable to set coherent dma mask: disabling DMA\\n\");\n\t\t\tdma = PARPORT_DMA_NONE;\n\t\t}\n\t}\n\n\tops = kmalloc(sizeof(struct parport_operations), GFP_KERNEL);\n\tif (!ops)\n\t\tgoto out1;\n\n\tpriv = kmalloc(sizeof(struct parport_pc_private), GFP_KERNEL);\n\tif (!priv)\n\t\tgoto out2;\n\n\t \n\tp = parport_register_port(base, irq, dma, ops);\n\tif (!p)\n\t\tgoto out3;\n\n\tbase_res = request_region(base, 3, p->name);\n\tif (!base_res)\n\t\tgoto out4;\n\n\tmemcpy(ops, &parport_pc_ops, sizeof(struct parport_operations));\n\tpriv->ctr = 0xc;\n\tpriv->ctr_writable = ~0x10;\n\tpriv->ecr = 0;\n\tpriv->ecr_writable = ecr_writable;\n\tpriv->fifo_depth = 0;\n\tpriv->dma_buf = NULL;\n\tpriv->dma_handle = 0;\n\tINIT_LIST_HEAD(&priv->list);\n\tpriv->port = p;\n\n\tp->dev = dev;\n\tp->base_hi = base_hi;\n\tp->modes = PARPORT_MODE_PCSPP | PARPORT_MODE_SAFEININT;\n\tp->private_data = priv;\n\n\tif (base_hi) {\n\t\tECR_res = request_region(base_hi, 3, p->name);\n\t\tif (ECR_res)\n\t\t\tparport_ECR_present(p);\n\t}\n\n\tif (base != 0x3bc) {\n\t\tEPP_res = request_region(base+0x3, 5, p->name);\n\t\tif (EPP_res)\n\t\t\tif (!parport_EPP_supported(p))\n\t\t\t\tparport_ECPEPP_supported(p);\n\t}\n\tif (!parport_SPP_supported(p))\n\t\t \n\t\tgoto out5;\n\tif (priv->ecr)\n\t\tparport_ECPPS2_supported(p);\n\telse\n\t\tparport_PS2_supported(p);\n\n\tp->size = (p->modes & PARPORT_MODE_EPP) ? 8 : 3;\n\n\tpr_info(\"%s: PC-style at 0x%lx\", p->name, p->base);\n\tif (p->base_hi && priv->ecr)\n\t\tpr_cont(\" (0x%lx)\", p->base_hi);\n\tif (p->irq == PARPORT_IRQ_AUTO) {\n\t\tp->irq = PARPORT_IRQ_NONE;\n\t\tparport_irq_probe(p);\n\t} else if (p->irq == PARPORT_IRQ_PROBEONLY) {\n\t\tp->irq = PARPORT_IRQ_NONE;\n\t\tparport_irq_probe(p);\n\t\tprobedirq = p->irq;\n\t\tp->irq = PARPORT_IRQ_NONE;\n\t}\n\tif (p->irq != PARPORT_IRQ_NONE) {\n\t\tpr_cont(\", irq %d\", p->irq);\n\t\tpriv->ctr_writable |= 0x10;\n\n\t\tif (p->dma == PARPORT_DMA_AUTO) {\n\t\t\tp->dma = PARPORT_DMA_NONE;\n\t\t\tparport_dma_probe(p);\n\t\t}\n\t}\n\tif (p->dma == PARPORT_DMA_AUTO)  \n\t\tp->dma = PARPORT_DMA_NONE;\n\n#ifdef CONFIG_PARPORT_PC_FIFO\n\tif (parport_ECP_supported(p) &&\n\t    p->dma != PARPORT_DMA_NOFIFO &&\n\t    priv->fifo_depth > 0 && p->irq != PARPORT_IRQ_NONE) {\n\t\tp->modes |= PARPORT_MODE_ECP | PARPORT_MODE_COMPAT;\n\t\tif (p->dma != PARPORT_DMA_NONE)\n\t\t\tp->modes |= PARPORT_MODE_DMA;\n\t} else\n\t\t \n\t\tp->dma = PARPORT_DMA_NONE;\n#endif  \n\n\tp->modes &= ~mode_mask;\n\n#ifdef CONFIG_PARPORT_PC_FIFO\n\tif ((p->modes & PARPORT_MODE_COMPAT) != 0)\n\t\tp->ops->compat_write_data = parport_pc_compat_write_block_pio;\n#ifdef CONFIG_PARPORT_1284\n\tif ((p->modes & PARPORT_MODE_ECP) != 0)\n\t\tp->ops->ecp_write_data = parport_pc_ecp_write_block_pio;\n#endif\n\tif ((p->modes & (PARPORT_MODE_ECP | PARPORT_MODE_COMPAT)) != 0) {\n\t\tif ((p->modes & PARPORT_MODE_DMA) != 0)\n\t\t\tpr_cont(\", dma %d\", p->dma);\n\t\telse\n\t\t\tpr_cont(\", using FIFO\");\n\t}\n#endif  \n\n\tpr_cont(\" [\");\n\n#define printmode(x)\t\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tif (p->modes & PARPORT_MODE_##x)\t\t\t\t\\\n\t\tpr_cont(\"%s%s\", f++ ? \",\" : \"\", #x);\t\t\t\\\n} while (0)\n\n\t{\n\t\tint f = 0;\n\t\tprintmode(PCSPP);\n\t\tprintmode(TRISTATE);\n\t\tprintmode(COMPAT);\n\t\tprintmode(EPP);\n\t\tprintmode(ECP);\n\t\tprintmode(DMA);\n\t}\n#undef printmode\n#ifndef CONFIG_PARPORT_1284\n\tpr_cont(\"(,...)\");\n#endif  \n\tpr_cont(\"]\\n\");\n\tif (probedirq != PARPORT_IRQ_NONE)\n\t\tpr_info(\"%s: irq %d detected\\n\", p->name, probedirq);\n\n\t \n\tif (ECR_res && (p->modes & PARPORT_MODE_ECP) == 0) {\n\t\trelease_region(base_hi, 3);\n\t\tECR_res = NULL;\n\t}\n\t \n\tif (EPP_res && (p->modes & PARPORT_MODE_EPP) == 0) {\n\t\trelease_region(base+3, 5);\n\t\tEPP_res = NULL;\n\t}\n\tif (p->irq != PARPORT_IRQ_NONE) {\n\t\tif (request_irq(p->irq, parport_irq_handler,\n\t\t\t\t irqflags, p->name, p)) {\n\t\t\tpr_warn(\"%s: irq %d in use, resorting to polled operation\\n\",\n\t\t\t\tp->name, p->irq);\n\t\t\tp->irq = PARPORT_IRQ_NONE;\n\t\t\tp->dma = PARPORT_DMA_NONE;\n\t\t}\n\n#ifdef CONFIG_PARPORT_PC_FIFO\n#ifdef HAS_DMA\n\t\tif (p->dma != PARPORT_DMA_NONE) {\n\t\t\tif (request_dma(p->dma, p->name)) {\n\t\t\t\tpr_warn(\"%s: dma %d in use, resorting to PIO operation\\n\",\n\t\t\t\t\tp->name, p->dma);\n\t\t\t\tp->dma = PARPORT_DMA_NONE;\n\t\t\t} else {\n\t\t\t\tpriv->dma_buf =\n\t\t\t\t  dma_alloc_coherent(dev,\n\t\t\t\t\t\t       PAGE_SIZE,\n\t\t\t\t\t\t       &priv->dma_handle,\n\t\t\t\t\t\t       GFP_KERNEL);\n\t\t\t\tif (!priv->dma_buf) {\n\t\t\t\t\tpr_warn(\"%s: cannot get buffer for DMA, resorting to PIO operation\\n\",\n\t\t\t\t\t\tp->name);\n\t\t\t\t\tfree_dma(p->dma);\n\t\t\t\t\tp->dma = PARPORT_DMA_NONE;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n#endif\n#endif\n\t}\n\n\t \n\tif (priv->ecr)\n\t\t \n\t\tECR_WRITE(p, 0x34);\n\n\tparport_pc_write_data(p, 0);\n\tparport_pc_data_forward(p);\n\n\t \n\tspin_lock(&ports_lock);\n\tlist_add(&priv->list, &ports_list);\n\tspin_unlock(&ports_lock);\n\tparport_announce_port(p);\n\n\treturn p;\n\nout5:\n\tif (ECR_res)\n\t\trelease_region(base_hi, 3);\n\tif (EPP_res)\n\t\trelease_region(base+0x3, 5);\n\trelease_region(base, 3);\nout4:\n\tparport_del_port(p);\nout3:\n\tkfree(priv);\nout2:\n\tkfree(ops);\nout1:\n\tif (pdev)\n\t\tplatform_device_unregister(pdev);\n\treturn NULL;\n}\n\nstruct parport *parport_pc_probe_port(unsigned long int base,\n\t\t\t\t      unsigned long int base_hi,\n\t\t\t\t      int irq, int dma,\n\t\t\t\t      struct device *dev,\n\t\t\t\t      int irqflags)\n{\n\treturn __parport_pc_probe_port(base, base_hi, irq, dma,\n\t\t\t\t       dev, irqflags, 0, 0);\n}\nEXPORT_SYMBOL(parport_pc_probe_port);\n\nvoid parport_pc_unregister_port(struct parport *p)\n{\n\tstruct parport_pc_private *priv = p->private_data;\n\tstruct parport_operations *ops = p->ops;\n\n\tparport_remove_port(p);\n\tspin_lock(&ports_lock);\n\tlist_del_init(&priv->list);\n\tspin_unlock(&ports_lock);\n#if defined(CONFIG_PARPORT_PC_FIFO) && defined(HAS_DMA)\n\tif (p->dma != PARPORT_DMA_NONE)\n\t\tfree_dma(p->dma);\n#endif\n\tif (p->irq != PARPORT_IRQ_NONE)\n\t\tfree_irq(p->irq, p);\n\trelease_region(p->base, 3);\n\tif (p->size > 3)\n\t\trelease_region(p->base + 3, p->size - 3);\n\tif (p->modes & PARPORT_MODE_ECP)\n\t\trelease_region(p->base_hi, 3);\n#if defined(CONFIG_PARPORT_PC_FIFO) && defined(HAS_DMA)\n\tif (priv->dma_buf)\n\t\tdma_free_coherent(p->physport->dev, PAGE_SIZE,\n\t\t\t\t    priv->dma_buf,\n\t\t\t\t    priv->dma_handle);\n#endif\n\tkfree(p->private_data);\n\tparport_del_port(p);\n\tkfree(ops);  \n}\nEXPORT_SYMBOL(parport_pc_unregister_port);\n\n#ifdef CONFIG_PCI\n\n \nstatic int sio_ite_8872_probe(struct pci_dev *pdev, int autoirq, int autodma,\n\t\t\t      const struct parport_pc_via_data *via)\n{\n\tshort inta_addr[6] = { 0x2A0, 0x2C0, 0x220, 0x240, 0x1E0 };\n\tu32 ite8872set;\n\tu32 ite8872_lpt, ite8872_lpthi;\n\tu8 ite8872_irq, type;\n\tint irq;\n\tint i;\n\n\tpr_debug(\"sio_ite_8872_probe()\\n\");\n\n\t \n\tfor (i = 0; i < 5; i++) {\n\t\tif (request_region(inta_addr[i], 32, \"it887x\")) {\n\t\t\tint test;\n\t\t\tpci_write_config_dword(pdev, 0x60,\n\t\t\t\t\t\t0xe5000000 | inta_addr[i]);\n\t\t\tpci_write_config_dword(pdev, 0x78,\n\t\t\t\t\t\t0x00000000 | inta_addr[i]);\n\t\t\ttest = inb(inta_addr[i]);\n\t\t\tif (test != 0xff)\n\t\t\t\tbreak;\n\t\t\trelease_region(inta_addr[i], 32);\n\t\t}\n\t}\n\tif (i >= 5) {\n\t\tpr_info(\"parport_pc: cannot find ITE8872 INTA\\n\");\n\t\treturn 0;\n\t}\n\n\ttype = inb(inta_addr[i] + 0x18);\n\ttype &= 0x0f;\n\n\tswitch (type) {\n\tcase 0x2:\n\t\tpr_info(\"parport_pc: ITE8871 found (1P)\\n\");\n\t\tite8872set = 0x64200000;\n\t\tbreak;\n\tcase 0xa:\n\t\tpr_info(\"parport_pc: ITE8875 found (1P)\\n\");\n\t\tite8872set = 0x64200000;\n\t\tbreak;\n\tcase 0xe:\n\t\tpr_info(\"parport_pc: ITE8872 found (2S1P)\\n\");\n\t\tite8872set = 0x64e00000;\n\t\tbreak;\n\tcase 0x6:\n\t\tpr_info(\"parport_pc: ITE8873 found (1S)\\n\");\n\t\trelease_region(inta_addr[i], 32);\n\t\treturn 0;\n\tcase 0x8:\n\t\tpr_info(\"parport_pc: ITE8874 found (2S)\\n\");\n\t\trelease_region(inta_addr[i], 32);\n\t\treturn 0;\n\tdefault:\n\t\tpr_info(\"parport_pc: unknown ITE887x\\n\");\n\t\tpr_info(\"parport_pc: please mail 'lspci -nvv' output to Rich.Liu@ite.com.tw\\n\");\n\t\trelease_region(inta_addr[i], 32);\n\t\treturn 0;\n\t}\n\n\tpci_read_config_byte(pdev, 0x3c, &ite8872_irq);\n\tpci_read_config_dword(pdev, 0x1c, &ite8872_lpt);\n\tite8872_lpt &= 0x0000ff00;\n\tpci_read_config_dword(pdev, 0x20, &ite8872_lpthi);\n\tite8872_lpthi &= 0x0000ff00;\n\tpci_write_config_dword(pdev, 0x6c, 0xe3000000 | ite8872_lpt);\n\tpci_write_config_dword(pdev, 0x70, 0xe3000000 | ite8872_lpthi);\n\tpci_write_config_dword(pdev, 0x80, (ite8872_lpthi<<16) | ite8872_lpt);\n\t \n\t \n\tpci_write_config_dword(pdev, 0x9c,\n\t\t\t\tite8872set | (ite8872_irq * 0x11111));\n\n\tpr_debug(\"ITE887x: The IRQ is %d\\n\", ite8872_irq);\n\tpr_debug(\"ITE887x: The PARALLEL I/O port is 0x%x\\n\", ite8872_lpt);\n\tpr_debug(\"ITE887x: The PARALLEL I/O porthi is 0x%x\\n\", ite8872_lpthi);\n\n\t \n\tirq = ite8872_irq;\n\tif (autoirq != PARPORT_IRQ_AUTO)\n\t\tirq = PARPORT_IRQ_NONE;\n\n\t \n\trelease_region(inta_addr[i], 32);\n\tif (parport_pc_probe_port(ite8872_lpt, ite8872_lpthi,\n\t\t\t\t   irq, PARPORT_DMA_NONE, &pdev->dev, 0)) {\n\t\tpr_info(\"parport_pc: ITE 8872 parallel port: io=0x%X\",\n\t\t\tite8872_lpt);\n\t\tif (irq != PARPORT_IRQ_NONE)\n\t\t\tpr_cont(\", irq=%d\", irq);\n\t\tpr_cont(\"\\n\");\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int parport_init_mode;\n\n \nstatic struct parport_pc_via_data via_686a_data = {\n\t0x51,\n\t0x50,\n\t0x85,\n\t0x02,\n\t0xE2,\n\t0xF0,\n\t0xE6\n};\nstatic struct parport_pc_via_data via_8231_data = {\n\t0x45,\n\t0x44,\n\t0x50,\n\t0x04,\n\t0xF2,\n\t0xFA,\n\t0xF6\n};\n\nstatic int sio_via_probe(struct pci_dev *pdev, int autoirq, int autodma,\n\t\t\t const struct parport_pc_via_data *via)\n{\n\tu8 tmp, tmp2, siofunc;\n\tu8 ppcontrol = 0;\n\tint dma, irq;\n\tunsigned port1, port2;\n\tunsigned have_epp = 0;\n\n\tprintk(KERN_DEBUG \"parport_pc: VIA 686A/8231 detected\\n\");\n\n\tswitch (parport_init_mode) {\n\tcase 1:\n\t\tprintk(KERN_DEBUG \"parport_pc: setting SPP mode\\n\");\n\t\tsiofunc = VIA_FUNCTION_PARPORT_SPP;\n\t\tbreak;\n\tcase 2:\n\t\tprintk(KERN_DEBUG \"parport_pc: setting PS/2 mode\\n\");\n\t\tsiofunc = VIA_FUNCTION_PARPORT_SPP;\n\t\tppcontrol = VIA_PARPORT_BIDIR;\n\t\tbreak;\n\tcase 3:\n\t\tprintk(KERN_DEBUG \"parport_pc: setting EPP mode\\n\");\n\t\tsiofunc = VIA_FUNCTION_PARPORT_EPP;\n\t\tppcontrol = VIA_PARPORT_BIDIR;\n\t\thave_epp = 1;\n\t\tbreak;\n\tcase 4:\n\t\tprintk(KERN_DEBUG \"parport_pc: setting ECP mode\\n\");\n\t\tsiofunc = VIA_FUNCTION_PARPORT_ECP;\n\t\tppcontrol = VIA_PARPORT_BIDIR;\n\t\tbreak;\n\tcase 5:\n\t\tprintk(KERN_DEBUG \"parport_pc: setting EPP+ECP mode\\n\");\n\t\tsiofunc = VIA_FUNCTION_PARPORT_ECP;\n\t\tppcontrol = VIA_PARPORT_BIDIR|VIA_PARPORT_ECPEPP;\n\t\thave_epp = 1;\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_DEBUG \"parport_pc: probing current configuration\\n\");\n\t\tsiofunc = VIA_FUNCTION_PROBE;\n\t\tbreak;\n\t}\n\t \n\tpci_read_config_byte(pdev, via->via_pci_superio_config_reg, &tmp);\n\ttmp |= via->via_pci_superio_config_data;\n\tpci_write_config_byte(pdev, via->via_pci_superio_config_reg, tmp);\n\n\t \n\toutb(via->viacfg_function, VIA_CONFIG_INDEX);\n\ttmp = inb(VIA_CONFIG_DATA);\n\t \n\toutb(via->viacfg_parport_control, VIA_CONFIG_INDEX);\n\ttmp2 = inb(VIA_CONFIG_DATA);\n\tif (siofunc == VIA_FUNCTION_PROBE) {\n\t\tsiofunc = tmp & VIA_FUNCTION_PARPORT_DISABLE;\n\t\tppcontrol = tmp2;\n\t} else {\n\t\ttmp &= ~VIA_FUNCTION_PARPORT_DISABLE;\n\t\ttmp |= siofunc;\n\t\toutb(via->viacfg_function, VIA_CONFIG_INDEX);\n\t\toutb(tmp, VIA_CONFIG_DATA);\n\t\ttmp2 &= ~(VIA_PARPORT_BIDIR|VIA_PARPORT_ECPEPP);\n\t\ttmp2 |= ppcontrol;\n\t\toutb(via->viacfg_parport_control, VIA_CONFIG_INDEX);\n\t\toutb(tmp2, VIA_CONFIG_DATA);\n\t}\n\n\t \n\toutb(via->viacfg_parport_base, VIA_CONFIG_INDEX);\n\tport1 = inb(VIA_CONFIG_DATA) << 2;\n\n\tprintk(KERN_DEBUG \"parport_pc: Current parallel port base: 0x%X\\n\",\n\t       port1);\n\tif (port1 == 0x3BC && have_epp) {\n\t\toutb(via->viacfg_parport_base, VIA_CONFIG_INDEX);\n\t\toutb((0x378 >> 2), VIA_CONFIG_DATA);\n\t\tprintk(KERN_DEBUG \"parport_pc: Parallel port base changed to 0x378\\n\");\n\t\tport1 = 0x378;\n\t}\n\n\t \n\tpci_read_config_byte(pdev, via->via_pci_superio_config_reg, &tmp);\n\ttmp &= ~via->via_pci_superio_config_data;\n\tpci_write_config_byte(pdev, via->via_pci_superio_config_reg, tmp);\n\n\tif (siofunc == VIA_FUNCTION_PARPORT_DISABLE) {\n\t\tpr_info(\"parport_pc: VIA parallel port disabled in BIOS\\n\");\n\t\treturn 0;\n\t}\n\n\t \n\tpci_read_config_byte(pdev, via->via_pci_parport_irq_reg, &tmp);\n\tirq = ((tmp & VIA_IRQCONTROL_PARALLEL) >> 4);\n\n\tif (siofunc == VIA_FUNCTION_PARPORT_ECP) {\n\t\t \n\t\tpci_read_config_byte(pdev, via->via_pci_parport_dma_reg, &tmp);\n\t\tdma = ((tmp & VIA_DMACONTROL_PARALLEL) >> 2);\n\t} else\n\t\t \n\t\tdma = PARPORT_DMA_NONE;\n\n\t \n\tif (autoirq == PARPORT_IRQ_NONE) {\n\t\tirq = PARPORT_IRQ_NONE;\n\t\tdma = PARPORT_DMA_NONE;\n\t}\n\tif (autodma == PARPORT_DMA_NONE)\n\t\tdma = PARPORT_DMA_NONE;\n\n\tswitch (port1) {\n\tcase 0x3bc:\n\t\tport2 = 0x7bc; break;\n\tcase 0x378:\n\t\tport2 = 0x778; break;\n\tcase 0x278:\n\t\tport2 = 0x678; break;\n\tdefault:\n\t\tpr_info(\"parport_pc: Weird VIA parport base 0x%X, ignoring\\n\",\n\t\t\tport1);\n\t\treturn 0;\n\t}\n\n\t \n\tswitch (irq) {\n\tcase 0:\n\tcase 2:\n\tcase 8:\n\tcase 13:\n\t\tirq = PARPORT_IRQ_NONE;\n\t\tbreak;\n\n\tdefault:  \n\t\tbreak;\n\t}\n\n\t \n\tif (parport_pc_probe_port(port1, port2, irq, dma, &pdev->dev, 0)) {\n\t\tpr_info(\"parport_pc: VIA parallel port: io=0x%X\", port1);\n\t\tif (irq != PARPORT_IRQ_NONE)\n\t\t\tpr_cont(\", irq=%d\", irq);\n\t\tif (dma != PARPORT_DMA_NONE)\n\t\t\tpr_cont(\", dma=%d\", dma);\n\t\tpr_cont(\"\\n\");\n\t\treturn 1;\n\t}\n\n\tpr_warn(\"parport_pc: Strange, can't probe VIA parallel port: io=0x%X, irq=%d, dma=%d\\n\",\n\t\tport1, irq, dma);\n\treturn 0;\n}\n\n\nenum parport_pc_sio_types {\n\tsio_via_686a = 0,    \n\tsio_via_8231,\t     \n\tsio_ite_8872,\n\tlast_sio\n};\n\n \nstatic struct parport_pc_superio {\n\tint (*probe) (struct pci_dev *pdev, int autoirq, int autodma,\n\t\t      const struct parport_pc_via_data *via);\n\tconst struct parport_pc_via_data *via;\n} parport_pc_superio_info[] = {\n\t{ sio_via_probe, &via_686a_data, },\n\t{ sio_via_probe, &via_8231_data, },\n\t{ sio_ite_8872_probe, NULL, },\n};\n\nenum parport_pc_pci_cards {\n\tsiig_1p_10x = last_sio,\n\tsiig_2p_10x,\n\tsiig_1p_20x,\n\tsiig_2p_20x,\n\tlava_parallel,\n\tlava_parallel_dual_a,\n\tlava_parallel_dual_b,\n\tboca_ioppar,\n\tplx_9050,\n\ttimedia_4006a,\n\ttimedia_4014,\n\ttimedia_4008a,\n\ttimedia_4018,\n\ttimedia_9018a,\n\tsyba_2p_epp,\n\tsyba_1p_ecp,\n\ttitan_010l,\n\tavlab_1p,\n\tavlab_2p,\n\toxsemi_952,\n\toxsemi_954,\n\toxsemi_840,\n\toxsemi_pcie_pport,\n\taks_0100,\n\tmobility_pp,\n\tnetmos_9900,\n\tnetmos_9705,\n\tnetmos_9715,\n\tnetmos_9755,\n\tnetmos_9805,\n\tnetmos_9815,\n\tnetmos_9901,\n\tnetmos_9865,\n\tasix_ax99100,\n\tquatech_sppxp100,\n\twch_ch382l,\n\tbrainboxes_uc146,\n\tbrainboxes_px203,\n};\n\n\n \nstatic struct parport_pc_pci {\n\tint numports;\n\tstruct {  \n\t\tint lo;\n\t\tint hi;\n\t\t \n\t} addr[2];\n\n\t \n\tunsigned int mode_mask;\n\n\t \n\tunsigned char ecr_writable;\n\n\t \n\tint (*preinit_hook) (struct pci_dev *pdev, int autoirq, int autodma);\n\n\t \n\tvoid (*postinit_hook) (struct pci_dev *pdev, int failed);\n} cards[] = {\n\t \t\t{ 1, { { 2, 3 }, } },\n\t \t\t{ 2, { { 2, 3 }, { 4, 5 }, } },\n\t \t\t{ 1, { { 0, 1 }, } },\n\t \t\t{ 2, { { 0, 1 }, { 2, 3 }, } },\n\t \t\t{ 1, { { 0, -1 }, } },\n\t \t{ 1, { { 0, -1 }, } },\n\t \t{ 1, { { 0, -1 }, } },\n\t \t\t{ 1, { { 0, -1 }, } },\n\t \t\t\t{ 2, { { 4, -1 }, { 5, -1 }, } },\n\t              { 1, { { 0, -1 }, } },\n\t              { 2, { { 0, -1 }, { 2, -1 }, } },\n\t              { 1, { { 0, 1 }, } },\n\t              { 2, { { 0, 1 }, { 2, 3 }, } },\n\t              { 2, { { 0, 1 }, { 2, 3 }, } },\n\t\t\t\t\t \n\t \t{ 2, { { 0, 0x078 }, { 0, 0x178 }, } },\n\t \t{ 1, { { 0, 0x078 }, } },\n\t \t\t{ 1, { { 3, -1 }, } },\n\t \t{ 1, { { 0, 1}, } },\n\t \t{ 2, { { 0, 1}, { 2, 3 },} },\n\t \n\t \t\t{ 1, { { 0, 1 }, },\n\t\t\t\t\t  PARPORT_MODE_COMPAT, ECR_MODE_MASK },\n\t \t\t{ 1, { { 0, 1 }, },\n\t\t\t\t\t  PARPORT_MODE_ECP |\n\t\t\t\t\t  PARPORT_MODE_COMPAT, ECR_MODE_MASK },\n\t \t\t{ 1, { { 0, 1 }, },\n\t\t\t\t\t  PARPORT_MODE_COMPAT, ECR_MODE_MASK },\n\t \t\t{ 1, { { 0, 1 }, },\n\t\t\t\t\t  PARPORT_MODE_COMPAT, ECR_MODE_MASK },\n\t                   { 1, { { 0, -1 }, } },\n\t \t\t{ 1, { { 0, 1 }, } },\n\t \t\t{ 1, { { 0, -1 }, } },\n\n\t \n\t                { 1, { { 0, -1 }, } },\n\t                { 2, { { 0, 1 }, { 2, 3 },} },\n\t                { 2, { { 0, 1 }, { 2, 3 },} },\n\t \t\t{ 1, { { 0, 1 }, } },\n\t \t\t{ 2, { { 0, 1 }, { 2, 3 }, } },\n\t                { 1, { { 0, -1 }, } },\n\t                { 1, { { 0, -1 }, } },\n\t \t\t{ 1, { { 0, 1 }, } },\n\t \t\t{ 1, { { 0, 1 }, } },\n\t \t\t{ 1, { { 2, -1 }, } },\n\t \t{ 1, { { 3, -1 }, } },\n\t \t{ 1, { { 0, -1 }, } },\n};\n\nstatic const struct pci_device_id parport_pc_pci_tbl[] = {\n\t \n\t{ 0x1106, 0x0686, PCI_ANY_ID, PCI_ANY_ID, 0, 0, sio_via_686a },\n\t{ 0x1106, 0x8231, PCI_ANY_ID, PCI_ANY_ID, 0, 0, sio_via_8231 },\n\t{ PCI_VENDOR_ID_ITE, PCI_DEVICE_ID_ITE_8872,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, sio_ite_8872 },\n\n\t \n\t{ PCI_VENDOR_ID_SIIG, PCI_DEVICE_ID_SIIG_1P_10x,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, siig_1p_10x },\n\t{ PCI_VENDOR_ID_SIIG, PCI_DEVICE_ID_SIIG_2P_10x,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, siig_2p_10x },\n\t{ PCI_VENDOR_ID_SIIG, PCI_DEVICE_ID_SIIG_1P_20x,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, siig_1p_20x },\n\t{ PCI_VENDOR_ID_SIIG, PCI_DEVICE_ID_SIIG_2P_20x,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, siig_2p_20x },\n\t{ PCI_VENDOR_ID_LAVA, PCI_DEVICE_ID_LAVA_PARALLEL,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, lava_parallel },\n\t{ PCI_VENDOR_ID_LAVA, PCI_DEVICE_ID_LAVA_DUAL_PAR_A,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, lava_parallel_dual_a },\n\t{ PCI_VENDOR_ID_LAVA, PCI_DEVICE_ID_LAVA_DUAL_PAR_B,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, lava_parallel_dual_b },\n\t{ PCI_VENDOR_ID_LAVA, PCI_DEVICE_ID_LAVA_BOCA_IOPPAR,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, boca_ioppar },\n\t{ PCI_VENDOR_ID_PLX, PCI_DEVICE_ID_PLX_9050,\n\t  PCI_SUBVENDOR_ID_EXSYS, PCI_SUBDEVICE_ID_EXSYS_4014, 0, 0, plx_9050 },\n\t \n\t{ 0x1409, 0x7268, 0x1409, 0x0101, 0, 0, timedia_4006a },\n\t{ 0x1409, 0x7268, 0x1409, 0x0102, 0, 0, timedia_4014 },\n\t{ 0x1409, 0x7268, 0x1409, 0x0103, 0, 0, timedia_4008a },\n\t{ 0x1409, 0x7268, 0x1409, 0x0104, 0, 0, timedia_4018 },\n\t{ 0x1409, 0x7268, 0x1409, 0x9018, 0, 0, timedia_9018a },\n\t{ PCI_VENDOR_ID_SYBA, PCI_DEVICE_ID_SYBA_2P_EPP,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, syba_2p_epp },\n\t{ PCI_VENDOR_ID_SYBA, PCI_DEVICE_ID_SYBA_1P_ECP,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, syba_1p_ecp },\n\t{ PCI_VENDOR_ID_TITAN, PCI_DEVICE_ID_TITAN_010L,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, titan_010l },\n\t \n\t \n\t{ 0x14db, 0x2120, PCI_ANY_ID, PCI_ANY_ID, 0, 0, avlab_1p},\n\t{ 0x14db, 0x2121, PCI_ANY_ID, PCI_ANY_ID, 0, 0, avlab_2p},\n\t{ PCI_VENDOR_ID_OXSEMI, PCI_DEVICE_ID_OXSEMI_16PCI952PP,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, oxsemi_952 },\n\t{ PCI_VENDOR_ID_OXSEMI, PCI_DEVICE_ID_OXSEMI_16PCI954PP,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, oxsemi_954 },\n\t{ PCI_VENDOR_ID_OXSEMI, PCI_DEVICE_ID_OXSEMI_12PCI840,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, oxsemi_840 },\n\t{ PCI_VENDOR_ID_OXSEMI, PCI_DEVICE_ID_OXSEMI_PCIe840,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, oxsemi_pcie_pport },\n\t{ PCI_VENDOR_ID_OXSEMI, PCI_DEVICE_ID_OXSEMI_PCIe840_G,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, oxsemi_pcie_pport },\n\t{ PCI_VENDOR_ID_OXSEMI, PCI_DEVICE_ID_OXSEMI_PCIe952_0,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, oxsemi_pcie_pport },\n\t{ PCI_VENDOR_ID_OXSEMI, PCI_DEVICE_ID_OXSEMI_PCIe952_0_G,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, oxsemi_pcie_pport },\n\t{ PCI_VENDOR_ID_OXSEMI, PCI_DEVICE_ID_OXSEMI_PCIe952_1,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, oxsemi_pcie_pport },\n\t{ PCI_VENDOR_ID_OXSEMI, PCI_DEVICE_ID_OXSEMI_PCIe952_1_G,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, oxsemi_pcie_pport },\n\t{ PCI_VENDOR_ID_OXSEMI, PCI_DEVICE_ID_OXSEMI_PCIe952_1_U,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, oxsemi_pcie_pport },\n\t{ PCI_VENDOR_ID_OXSEMI, PCI_DEVICE_ID_OXSEMI_PCIe952_1_GU,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, oxsemi_pcie_pport },\n\t{ PCI_VENDOR_ID_AKS, PCI_DEVICE_ID_AKS_ALADDINCARD,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, aks_0100 },\n\t{ 0x14f2, 0x0121, PCI_ANY_ID, PCI_ANY_ID, 0, 0, mobility_pp },\n\t \n\t{ PCI_VENDOR_ID_NETMOS, PCI_DEVICE_ID_NETMOS_9900,\n\t  0xA000, 0x2000, 0, 0, netmos_9900 },\n\t{ PCI_VENDOR_ID_NETMOS, PCI_DEVICE_ID_NETMOS_9705,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, netmos_9705 },\n\t{ PCI_VENDOR_ID_NETMOS, PCI_DEVICE_ID_NETMOS_9715,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, netmos_9715 },\n\t{ PCI_VENDOR_ID_NETMOS, PCI_DEVICE_ID_NETMOS_9755,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, netmos_9755 },\n\t{ PCI_VENDOR_ID_NETMOS, PCI_DEVICE_ID_NETMOS_9805,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, netmos_9805 },\n\t{ PCI_VENDOR_ID_NETMOS, PCI_DEVICE_ID_NETMOS_9815,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, netmos_9815 },\n\t{ PCI_VENDOR_ID_NETMOS, PCI_DEVICE_ID_NETMOS_9901,\n\t  0xA000, 0x2000, 0, 0, netmos_9901 },\n\t{ PCI_VENDOR_ID_NETMOS, PCI_DEVICE_ID_NETMOS_9865,\n\t  0xA000, 0x1000, 0, 0, netmos_9865 },\n\t{ PCI_VENDOR_ID_NETMOS, PCI_DEVICE_ID_NETMOS_9865,\n\t  0xA000, 0x2000, 0, 0, netmos_9865 },\n\t \n\t{ PCI_VENDOR_ID_ASIX, PCI_DEVICE_ID_ASIX_AX99100,\n\t  0xA000, 0x2000, 0, 0, asix_ax99100 },\n\t \n\t{ PCI_VENDOR_ID_QUATECH, PCI_DEVICE_ID_QUATECH_SPPXP_100,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, quatech_sppxp100 },\n\t \n\t{ 0x1c00, 0x3050, 0x1c00, 0x3050, 0, 0, wch_ch382l },\n\t \n\t{ PCI_VENDOR_ID_INTASHIELD, 0x402a,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, oxsemi_pcie_pport },\n\t \n\t{ PCI_VENDOR_ID_INTASHIELD, 0x0be1,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, brainboxes_uc146 },\n\t{ PCI_VENDOR_ID_INTASHIELD, 0x0be2,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, brainboxes_uc146 },\n\t \n\t{ PCI_VENDOR_ID_INTASHIELD, 0x401c,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, oxsemi_pcie_pport },\n\t \n\t{ PCI_VENDOR_ID_INTASHIELD, 0x4007,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, brainboxes_px203 },\n\t \n\t{ PCI_VENDOR_ID_INTASHIELD, 0x401f,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, oxsemi_pcie_pport },\n\t{ 0, }  \n};\nMODULE_DEVICE_TABLE(pci, parport_pc_pci_tbl);\n\nstruct pci_parport_data {\n\tint num;\n\tstruct parport *ports[2];\n};\n\nstatic int parport_pc_pci_probe(struct pci_dev *dev,\n\t\t\t\t\t   const struct pci_device_id *id)\n{\n\tint err, count, n, i = id->driver_data;\n\tstruct pci_parport_data *data;\n\n\tif (i < last_sio)\n\t\t \n\t\treturn 0;\n\n\t \n\ti -= last_sio;\n\tcount = 0;\n\terr = pci_enable_device(dev);\n\tif (err)\n\t\treturn err;\n\n\tdata = kmalloc(sizeof(struct pci_parport_data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tif (cards[i].preinit_hook &&\n\t    cards[i].preinit_hook(dev, PARPORT_IRQ_NONE, PARPORT_DMA_NONE)) {\n\t\tkfree(data);\n\t\treturn -ENODEV;\n\t}\n\n\tfor (n = 0; n < cards[i].numports; n++) {\n\t\tint lo = cards[i].addr[n].lo;\n\t\tint hi = cards[i].addr[n].hi;\n\t\tint irq;\n\t\tunsigned long io_lo, io_hi;\n\t\tio_lo = pci_resource_start(dev, lo);\n\t\tio_hi = 0;\n\t\tif ((hi >= 0) && (hi <= 6))\n\t\t\tio_hi = pci_resource_start(dev, hi);\n\t\telse if (hi > 6)\n\t\t\tio_lo += hi;  \n\t\t \n\t\tirq = dev->irq;\n\t\tif (irq == IRQ_NONE) {\n\t\t\tprintk(KERN_DEBUG \"PCI parallel port detected: %04x:%04x, I/O at %#lx(%#lx)\\n\",\n\t\t\t       id->vendor, id->device, io_lo, io_hi);\n\t\t\tirq = PARPORT_IRQ_NONE;\n\t\t} else {\n\t\t\tprintk(KERN_DEBUG \"PCI parallel port detected: %04x:%04x, I/O at %#lx(%#lx), IRQ %d\\n\",\n\t\t\t       id->vendor, id->device, io_lo, io_hi, irq);\n\t\t}\n\t\tdata->ports[count] =\n\t\t\t__parport_pc_probe_port(io_lo, io_hi, irq,\n\t\t\t\t\t\tPARPORT_DMA_NONE, &dev->dev,\n\t\t\t\t\t\tIRQF_SHARED,\n\t\t\t\t\t\tcards[i].mode_mask,\n\t\t\t\t\t\tcards[i].ecr_writable);\n\t\tif (data->ports[count])\n\t\t\tcount++;\n\t}\n\n\tdata->num = count;\n\n\tif (cards[i].postinit_hook)\n\t\tcards[i].postinit_hook(dev, count == 0);\n\n\tif (count) {\n\t\tpci_set_drvdata(dev, data);\n\t\treturn 0;\n\t}\n\n\tkfree(data);\n\n\treturn -ENODEV;\n}\n\nstatic void parport_pc_pci_remove(struct pci_dev *dev)\n{\n\tstruct pci_parport_data *data = pci_get_drvdata(dev);\n\tint i;\n\n\tif (data) {\n\t\tfor (i = data->num - 1; i >= 0; i--)\n\t\t\tparport_pc_unregister_port(data->ports[i]);\n\n\t\tkfree(data);\n\t}\n}\n\nstatic struct pci_driver parport_pc_pci_driver = {\n\t.name\t\t= \"parport_pc\",\n\t.id_table\t= parport_pc_pci_tbl,\n\t.probe\t\t= parport_pc_pci_probe,\n\t.remove\t\t= parport_pc_pci_remove,\n};\n\nstatic int __init parport_pc_init_superio(int autoirq, int autodma)\n{\n\tconst struct pci_device_id *id;\n\tstruct pci_dev *pdev = NULL;\n\tint ret = 0;\n\n\tfor_each_pci_dev(pdev) {\n\t\tid = pci_match_id(parport_pc_pci_tbl, pdev);\n\t\tif (id == NULL || id->driver_data >= last_sio)\n\t\t\tcontinue;\n\n\t\tif (parport_pc_superio_info[id->driver_data].probe(\n\t\t\tpdev, autoirq, autodma,\n\t\t\tparport_pc_superio_info[id->driver_data].via)) {\n\t\t\tret++;\n\t\t}\n\t}\n\n\treturn ret;  \n}\n#else\nstatic struct pci_driver parport_pc_pci_driver;\nstatic int __init parport_pc_init_superio(int autoirq, int autodma)\n{\n\treturn 0;\n}\n#endif  \n\n#ifdef CONFIG_PNP\n\nstatic const struct pnp_device_id parport_pc_pnp_tbl[] = {\n\t \n\t{.id = \"PNP0400\", .driver_data = 0},\n\t \n\t{.id = \"PNP0401\", .driver_data = 0},\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(pnp, parport_pc_pnp_tbl);\n\nstatic int parport_pc_pnp_probe(struct pnp_dev *dev,\n\t\t\t\t\t\tconst struct pnp_device_id *id)\n{\n\tstruct parport *pdata;\n\tunsigned long io_lo, io_hi;\n\tint dma, irq;\n\n\tif (pnp_port_valid(dev, 0) &&\n\t\t!(pnp_port_flags(dev, 0) & IORESOURCE_DISABLED)) {\n\t\tio_lo = pnp_port_start(dev, 0);\n\t} else\n\t\treturn -EINVAL;\n\n\tif (pnp_port_valid(dev, 1) &&\n\t\t!(pnp_port_flags(dev, 1) & IORESOURCE_DISABLED)) {\n\t\tio_hi = pnp_port_start(dev, 1);\n\t} else\n\t\tio_hi = 0;\n\n\tif (pnp_irq_valid(dev, 0) &&\n\t\t!(pnp_irq_flags(dev, 0) & IORESOURCE_DISABLED)) {\n\t\tirq = pnp_irq(dev, 0);\n\t} else\n\t\tirq = PARPORT_IRQ_NONE;\n\n\tif (pnp_dma_valid(dev, 0) &&\n\t\t!(pnp_dma_flags(dev, 0) & IORESOURCE_DISABLED)) {\n\t\tdma = pnp_dma(dev, 0);\n\t} else\n\t\tdma = PARPORT_DMA_NONE;\n\n\tdev_info(&dev->dev, \"reported by %s\\n\", dev->protocol->name);\n\tpdata = parport_pc_probe_port(io_lo, io_hi, irq, dma, &dev->dev, 0);\n\tif (pdata == NULL)\n\t\treturn -ENODEV;\n\n\tpnp_set_drvdata(dev, pdata);\n\treturn 0;\n}\n\nstatic void parport_pc_pnp_remove(struct pnp_dev *dev)\n{\n\tstruct parport *pdata = (struct parport *)pnp_get_drvdata(dev);\n\tif (!pdata)\n\t\treturn;\n\n\tparport_pc_unregister_port(pdata);\n}\n\n \nstatic struct pnp_driver parport_pc_pnp_driver = {\n\t.name\t\t= \"parport_pc\",\n\t.id_table\t= parport_pc_pnp_tbl,\n\t.probe\t\t= parport_pc_pnp_probe,\n\t.remove\t\t= parport_pc_pnp_remove,\n};\n\n#else\nstatic struct pnp_driver parport_pc_pnp_driver;\n#endif  \n\nstatic int parport_pc_platform_probe(struct platform_device *pdev)\n{\n\t \n\treturn 0;\n}\n\nstatic struct platform_driver parport_pc_platform_driver = {\n\t.driver = {\n\t\t.name\t= \"parport_pc\",\n\t},\n\t.probe\t\t= parport_pc_platform_probe,\n};\n\n \nstatic int __attribute__((unused))\nparport_pc_find_isa_ports(int autoirq, int autodma)\n{\n\tint count = 0;\n\n\tif (parport_pc_probe_port(0x3bc, 0x7bc, autoirq, autodma, NULL, 0))\n\t\tcount++;\n\tif (parport_pc_probe_port(0x378, 0x778, autoirq, autodma, NULL, 0))\n\t\tcount++;\n\tif (parport_pc_probe_port(0x278, 0x678, autoirq, autodma, NULL, 0))\n\t\tcount++;\n\n\treturn count;\n}\n\n \nstatic void __init parport_pc_find_ports(int autoirq, int autodma)\n{\n\tint count = 0, err;\n\n#ifdef CONFIG_PARPORT_PC_SUPERIO\n\tdetect_and_report_it87();\n\tdetect_and_report_winbond();\n\tdetect_and_report_smsc();\n#endif\n\n\t \n\tcount += parport_pc_init_superio(autoirq, autodma);\n\n\t \n\tif (!count) {\n\t\terr = pnp_register_driver(&parport_pc_pnp_driver);\n\t\tif (!err)\n\t\t\tpnp_registered_parport = 1;\n\t}\n\n\t \n\tparport_pc_find_nonpci_ports(autoirq, autodma);\n\n\terr = pci_register_driver(&parport_pc_pci_driver);\n\tif (!err)\n\t\tpci_registered_parport = 1;\n}\n\n \n\nstatic int __initdata io[PARPORT_PC_MAX_PORTS+1] = {\n\t[0 ... PARPORT_PC_MAX_PORTS] = 0\n};\nstatic int __initdata io_hi[PARPORT_PC_MAX_PORTS+1] = {\n\t[0 ... PARPORT_PC_MAX_PORTS] = PARPORT_IOHI_AUTO\n};\nstatic int __initdata dmaval[PARPORT_PC_MAX_PORTS] = {\n\t[0 ... PARPORT_PC_MAX_PORTS-1] = PARPORT_DMA_NONE\n};\nstatic int __initdata irqval[PARPORT_PC_MAX_PORTS] = {\n\t[0 ... PARPORT_PC_MAX_PORTS-1] = PARPORT_IRQ_PROBEONLY\n};\n\nstatic int __init parport_parse_param(const char *s, int *val,\n\t\t\t\tint automatic, int none, int nofifo)\n{\n\tif (!s)\n\t\treturn 0;\n\tif (!strncmp(s, \"auto\", 4))\n\t\t*val = automatic;\n\telse if (!strncmp(s, \"none\", 4))\n\t\t*val = none;\n\telse if (nofifo && !strncmp(s, \"nofifo\", 6))\n\t\t*val = nofifo;\n\telse {\n\t\tchar *ep;\n\t\tunsigned long r = simple_strtoul(s, &ep, 0);\n\t\tif (ep != s)\n\t\t\t*val = r;\n\t\telse {\n\t\t\tpr_err(\"parport: bad specifier `%s'\\n\", s);\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int __init parport_parse_irq(const char *irqstr, int *val)\n{\n\treturn parport_parse_param(irqstr, val, PARPORT_IRQ_AUTO,\n\t\t\t\t     PARPORT_IRQ_NONE, 0);\n}\n\nstatic int __init parport_parse_dma(const char *dmastr, int *val)\n{\n\treturn parport_parse_param(dmastr, val, PARPORT_DMA_AUTO,\n\t\t\t\t     PARPORT_DMA_NONE, PARPORT_DMA_NOFIFO);\n}\n\n#ifdef CONFIG_PCI\nstatic int __init parport_init_mode_setup(char *str)\n{\n\tprintk(KERN_DEBUG \"parport_pc.c: Specified parameter parport_init_mode=%s\\n\",\n\t       str);\n\n\tif (!strcmp(str, \"spp\"))\n\t\tparport_init_mode = 1;\n\tif (!strcmp(str, \"ps2\"))\n\t\tparport_init_mode = 2;\n\tif (!strcmp(str, \"epp\"))\n\t\tparport_init_mode = 3;\n\tif (!strcmp(str, \"ecp\"))\n\t\tparport_init_mode = 4;\n\tif (!strcmp(str, \"ecpepp\"))\n\t\tparport_init_mode = 5;\n\treturn 1;\n}\n#endif\n\n#ifdef MODULE\nstatic char *irq[PARPORT_PC_MAX_PORTS];\nstatic char *dma[PARPORT_PC_MAX_PORTS];\n\nMODULE_PARM_DESC(io, \"Base I/O address (SPP regs)\");\nmodule_param_hw_array(io, int, ioport, NULL, 0);\nMODULE_PARM_DESC(io_hi, \"Base I/O address (ECR)\");\nmodule_param_hw_array(io_hi, int, ioport, NULL, 0);\nMODULE_PARM_DESC(irq, \"IRQ line\");\nmodule_param_hw_array(irq, charp, irq, NULL, 0);\nMODULE_PARM_DESC(dma, \"DMA channel\");\nmodule_param_hw_array(dma, charp, dma, NULL, 0);\n#if defined(CONFIG_PARPORT_PC_SUPERIO) || \\\n       (defined(CONFIG_PARPORT_1284) && defined(CONFIG_PARPORT_PC_FIFO))\nMODULE_PARM_DESC(verbose_probing, \"Log chit-chat during initialisation\");\nmodule_param(verbose_probing, int, 0644);\n#endif\n#ifdef CONFIG_PCI\nstatic char *init_mode;\nMODULE_PARM_DESC(init_mode,\n\t\"Initialise mode for VIA VT8231 port (spp, ps2, epp, ecp or ecpepp)\");\nmodule_param(init_mode, charp, 0);\n#endif\n\nstatic int __init parse_parport_params(void)\n{\n\tunsigned int i;\n\tint val;\n\n#ifdef CONFIG_PCI\n\tif (init_mode)\n\t\tparport_init_mode_setup(init_mode);\n#endif\n\n\tfor (i = 0; i < PARPORT_PC_MAX_PORTS && io[i]; i++) {\n\t\tif (parport_parse_irq(irq[i], &val))\n\t\t\treturn 1;\n\t\tirqval[i] = val;\n\t\tif (parport_parse_dma(dma[i], &val))\n\t\t\treturn 1;\n\t\tdmaval[i] = val;\n\t}\n\tif (!io[0]) {\n\t\t \n\t\tif (irq[0] && !parport_parse_irq(irq[0], &val))\n\t\t\tswitch (val) {\n\t\t\tcase PARPORT_IRQ_NONE:\n\t\t\tcase PARPORT_IRQ_AUTO:\n\t\t\t\tirqval[0] = val;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tpr_warn(\"parport_pc: irq specified without base address.  Use 'io=' to specify one\\n\");\n\t\t\t}\n\n\t\tif (dma[0] && !parport_parse_dma(dma[0], &val))\n\t\t\tswitch (val) {\n\t\t\tcase PARPORT_DMA_NONE:\n\t\t\tcase PARPORT_DMA_AUTO:\n\t\t\t\tdmaval[0] = val;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tpr_warn(\"parport_pc: dma specified without base address.  Use 'io=' to specify one\\n\");\n\t\t\t}\n\t}\n\treturn 0;\n}\n\n#else\n\nstatic int parport_setup_ptr __initdata;\n\n \nstatic int __init parport_setup(char *str)\n{\n\tchar *endptr;\n\tchar *sep;\n\tint val;\n\n\tif (!str || !*str || (*str == '0' && !*(str+1))) {\n\t\t \n\t\tio[0] = PARPORT_DISABLE;\n\t\treturn 1;\n\t}\n\n\tif (!strncmp(str, \"auto\", 4)) {\n\t\tirqval[0] = PARPORT_IRQ_AUTO;\n\t\tdmaval[0] = PARPORT_DMA_AUTO;\n\t\treturn 1;\n\t}\n\n\tval = simple_strtoul(str, &endptr, 0);\n\tif (endptr == str) {\n\t\tpr_warn(\"parport=%s not understood\\n\", str);\n\t\treturn 1;\n\t}\n\n\tif (parport_setup_ptr == PARPORT_PC_MAX_PORTS) {\n\t\tpr_err(\"parport=%s ignored, too many ports\\n\", str);\n\t\treturn 1;\n\t}\n\n\tio[parport_setup_ptr] = val;\n\tirqval[parport_setup_ptr] = PARPORT_IRQ_NONE;\n\tdmaval[parport_setup_ptr] = PARPORT_DMA_NONE;\n\n\tsep = strchr(str, ',');\n\tif (sep++) {\n\t\tif (parport_parse_irq(sep, &val))\n\t\t\treturn 1;\n\t\tirqval[parport_setup_ptr] = val;\n\t\tsep = strchr(sep, ',');\n\t\tif (sep++) {\n\t\t\tif (parport_parse_dma(sep, &val))\n\t\t\t\treturn 1;\n\t\t\tdmaval[parport_setup_ptr] = val;\n\t\t}\n\t}\n\tparport_setup_ptr++;\n\treturn 1;\n}\n\nstatic int __init parse_parport_params(void)\n{\n\treturn io[0] == PARPORT_DISABLE;\n}\n\n__setup(\"parport=\", parport_setup);\n\n \n#ifdef CONFIG_PCI\n__setup(\"parport_init_mode=\", parport_init_mode_setup);\n#endif\n#endif\n\n \n\nstatic int __init parport_pc_init(void)\n{\n\tint err;\n\n\tif (parse_parport_params())\n\t\treturn -EINVAL;\n\n\terr = platform_driver_register(&parport_pc_platform_driver);\n\tif (err)\n\t\treturn err;\n\n\tif (io[0]) {\n\t\tint i;\n\t\t \n\t\tuser_specified = 1;\n\t\tfor (i = 0; i < PARPORT_PC_MAX_PORTS; i++) {\n\t\t\tif (!io[i])\n\t\t\t\tbreak;\n\t\t\tif (io_hi[i] == PARPORT_IOHI_AUTO)\n\t\t\t\tio_hi[i] = 0x400 + io[i];\n\t\t\tparport_pc_probe_port(io[i], io_hi[i],\n\t\t\t\t\tirqval[i], dmaval[i], NULL, 0);\n\t\t}\n\t} else\n\t\tparport_pc_find_ports(irqval[0], dmaval[0]);\n\n\treturn 0;\n}\n\nstatic void __exit parport_pc_exit(void)\n{\n\tif (pci_registered_parport)\n\t\tpci_unregister_driver(&parport_pc_pci_driver);\n\tif (pnp_registered_parport)\n\t\tpnp_unregister_driver(&parport_pc_pnp_driver);\n\tplatform_driver_unregister(&parport_pc_platform_driver);\n\n\twhile (!list_empty(&ports_list)) {\n\t\tstruct parport_pc_private *priv;\n\t\tstruct parport *port;\n\t\tstruct device *dev;\n\t\tpriv = list_entry(ports_list.next,\n\t\t\t\t  struct parport_pc_private, list);\n\t\tport = priv->port;\n\t\tdev = port->dev;\n\t\tparport_pc_unregister_port(port);\n\t\tif (dev && dev->bus == &platform_bus_type)\n\t\t\tplatform_device_unregister(to_platform_device(dev));\n\t}\n}\n\nMODULE_AUTHOR(\"Phil Blundell, Tim Waugh, others\");\nMODULE_DESCRIPTION(\"PC-style parallel port driver\");\nMODULE_LICENSE(\"GPL\");\nmodule_init(parport_pc_init)\nmodule_exit(parport_pc_exit)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}