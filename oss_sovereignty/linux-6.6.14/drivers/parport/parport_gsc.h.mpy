{
  "module_name": "parport_gsc.h",
  "hash_id": "e0f2565c0e38b41d5592962a4f8de0da48a2c4fadf3400adea9f0bf0b91566f1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/parport/parport_gsc.h",
  "human_readable_source": " \n \n\n#ifndef\t__DRIVERS_PARPORT_PARPORT_GSC_H\n#define\t__DRIVERS_PARPORT_PARPORT_GSC_H\n\n#include <asm/io.h>\n#include <linux/delay.h>\n\n#undef\tDEBUG_PARPORT\t \n#define DELAY_TIME \t0\n\n#if DELAY_TIME == 0\n#define parport_readb\tgsc_readb\n#define parport_writeb\tgsc_writeb\n#else\nstatic __inline__ unsigned char parport_readb( unsigned long port )\n{\n    udelay(DELAY_TIME);\n    return gsc_readb(port);\n}\n\nstatic __inline__ void parport_writeb( unsigned char value, unsigned long port )\n{\n    gsc_writeb(value,port);\n    udelay(DELAY_TIME);\n}\n#endif\n\n \n\n#define EPPDATA(p)  ((p)->base    + 0x4)\n#define EPPADDR(p)  ((p)->base    + 0x3)\n#define CONTROL(p)  ((p)->base    + 0x2)\n#define STATUS(p)   ((p)->base    + 0x1)\n#define DATA(p)     ((p)->base    + 0x0)\n\nstruct parport_gsc_private {\n\t \n\tunsigned char ctr;\n\n\t \n\tunsigned char ctr_writable;\n\n\t \n\tint pword;\n\n\t \n\tint readIntrThreshold;\n\tint writeIntrThreshold;\n\n\t \n\tstruct pci_dev *dev;\n};\n\nstatic inline void parport_gsc_write_data(struct parport *p, unsigned char d)\n{\n#ifdef DEBUG_PARPORT\n\tprintk(KERN_DEBUG \"%s(%p,0x%02x)\\n\", __func__, p, d);\n#endif\n\tparport_writeb(d, DATA(p));\n}\n\nstatic inline unsigned char parport_gsc_read_data(struct parport *p)\n{\n\tunsigned char val = parport_readb (DATA (p));\n#ifdef DEBUG_PARPORT\n\tprintk(KERN_DEBUG \"%s(%p) = 0x%02x\\n\", __func__, p, val);\n#endif\n\treturn val;\n}\n\n \nstatic inline unsigned char __parport_gsc_frob_control(struct parport *p,\n\t\t\t\t\t\t\tunsigned char mask,\n\t\t\t\t\t\t\tunsigned char val)\n{\n\tstruct parport_gsc_private *priv = p->physport->private_data;\n\tunsigned char ctr = priv->ctr;\n#ifdef DEBUG_PARPORT\n\tprintk(KERN_DEBUG \"%s(%02x,%02x): %02x -> %02x\\n\",\n\t       __func__, mask, val,\n\t       ctr, ((ctr & ~mask) ^ val) & priv->ctr_writable);\n#endif\n\tctr = (ctr & ~mask) ^ val;\n\tctr &= priv->ctr_writable;  \n\tparport_writeb (ctr, CONTROL (p));\n\tpriv->ctr = ctr;\t \n\treturn ctr;\n}\n\nstatic inline void parport_gsc_data_reverse(struct parport *p)\n{\n\t__parport_gsc_frob_control (p, 0x20, 0x20);\n}\n\nstatic inline void parport_gsc_data_forward(struct parport *p)\n{\n\t__parport_gsc_frob_control (p, 0x20, 0x00);\n}\n\nstatic inline void parport_gsc_write_control(struct parport *p,\n\t\t\t\t\t\t unsigned char d)\n{\n\tconst unsigned char wm = (PARPORT_CONTROL_STROBE |\n\t\t\t\t  PARPORT_CONTROL_AUTOFD |\n\t\t\t\t  PARPORT_CONTROL_INIT |\n\t\t\t\t  PARPORT_CONTROL_SELECT);\n\n\t \n\tif (d & 0x20) {\n\t\tprintk(KERN_DEBUG \"%s (%s): use data_reverse for this!\\n\",\n\t\t       p->name, p->cad->name);\n\t\tparport_gsc_data_reverse (p);\n\t}\n\n\t__parport_gsc_frob_control (p, wm, d & wm);\n}\n\nstatic inline unsigned char parport_gsc_read_control(struct parport *p)\n{\n\tconst unsigned char rm = (PARPORT_CONTROL_STROBE |\n\t\t\t\t  PARPORT_CONTROL_AUTOFD |\n\t\t\t\t  PARPORT_CONTROL_INIT |\n\t\t\t\t  PARPORT_CONTROL_SELECT);\n\tconst struct parport_gsc_private *priv = p->physport->private_data;\n\treturn priv->ctr & rm;  \n}\n\nstatic inline unsigned char parport_gsc_frob_control(struct parport *p,\n\t\t\t\t\t\t\tunsigned char mask,\n\t\t\t\t\t\t\tunsigned char val)\n{\n\tconst unsigned char wm = (PARPORT_CONTROL_STROBE |\n\t\t\t\t  PARPORT_CONTROL_AUTOFD |\n\t\t\t\t  PARPORT_CONTROL_INIT |\n\t\t\t\t  PARPORT_CONTROL_SELECT);\n\n\t \n\tif (mask & 0x20) {\n\t\tprintk(KERN_DEBUG \"%s (%s): use data_%s for this!\\n\",\n\t\t       p->name, p->cad->name,\n\t\t       (val & 0x20) ? \"reverse\" : \"forward\");\n\t\tif (val & 0x20)\n\t\t\tparport_gsc_data_reverse (p);\n\t\telse\n\t\t\tparport_gsc_data_forward (p);\n\t}\n\n\t \n\tmask &= wm;\n\tval &= wm;\n\n\treturn __parport_gsc_frob_control (p, mask, val);\n}\n\nstatic inline unsigned char parport_gsc_read_status(struct parport *p)\n{\n\treturn parport_readb (STATUS(p));\n}\n\nstatic inline void parport_gsc_disable_irq(struct parport *p)\n{\n\t__parport_gsc_frob_control (p, 0x10, 0x00);\n}\n\nstatic inline void parport_gsc_enable_irq(struct parport *p)\n{\n\t__parport_gsc_frob_control (p, 0x10, 0x10);\n}\n\nextern void parport_gsc_release_resources(struct parport *p);\n\nextern int parport_gsc_claim_resources(struct parport *p);\n\nextern void parport_gsc_init_state(struct pardevice *, struct parport_state *s);\n\nextern void parport_gsc_save_state(struct parport *p, struct parport_state *s);\n\nextern void parport_gsc_restore_state(struct parport *p, struct parport_state *s);\n\nextern void parport_gsc_inc_use_count(void);\n\nextern void parport_gsc_dec_use_count(void);\n\n#endif\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}