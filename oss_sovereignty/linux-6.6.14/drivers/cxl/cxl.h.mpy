{
  "module_name": "cxl.h",
  "hash_id": "26582d175a7d20d906adb48ffbab30a0db670808cf31d324ab8e2c043062fa94",
  "original_prompt": "Ingested from linux-6.6.14/drivers/cxl/cxl.h",
  "human_readable_source": " \n \n\n#ifndef __CXL_H__\n#define __CXL_H__\n\n#include <linux/libnvdimm.h>\n#include <linux/bitfield.h>\n#include <linux/bitops.h>\n#include <linux/log2.h>\n#include <linux/io.h>\n\n \n\n \n#define CXL_COMPONENT_REG_BLOCK_SIZE SZ_64K\n\n \n#define CXL_CM_OFFSET 0x1000\n#define CXL_CM_CAP_HDR_OFFSET 0x0\n#define   CXL_CM_CAP_HDR_ID_MASK GENMASK(15, 0)\n#define     CM_CAP_HDR_CAP_ID 1\n#define   CXL_CM_CAP_HDR_VERSION_MASK GENMASK(19, 16)\n#define     CM_CAP_HDR_CAP_VERSION 1\n#define   CXL_CM_CAP_HDR_CACHE_MEM_VERSION_MASK GENMASK(23, 20)\n#define     CM_CAP_HDR_CACHE_MEM_VERSION 1\n#define   CXL_CM_CAP_HDR_ARRAY_SIZE_MASK GENMASK(31, 24)\n#define CXL_CM_CAP_PTR_MASK GENMASK(31, 20)\n\n#define   CXL_CM_CAP_CAP_ID_RAS 0x2\n#define   CXL_CM_CAP_CAP_ID_HDM 0x5\n#define   CXL_CM_CAP_CAP_HDM_VERSION 1\n\n \n#define CXL_HDM_DECODER_CAP_OFFSET 0x0\n#define   CXL_HDM_DECODER_COUNT_MASK GENMASK(3, 0)\n#define   CXL_HDM_DECODER_TARGET_COUNT_MASK GENMASK(7, 4)\n#define   CXL_HDM_DECODER_INTERLEAVE_11_8 BIT(8)\n#define   CXL_HDM_DECODER_INTERLEAVE_14_12 BIT(9)\n#define CXL_HDM_DECODER_CTRL_OFFSET 0x4\n#define   CXL_HDM_DECODER_ENABLE BIT(1)\n#define CXL_HDM_DECODER0_BASE_LOW_OFFSET(i) (0x20 * (i) + 0x10)\n#define CXL_HDM_DECODER0_BASE_HIGH_OFFSET(i) (0x20 * (i) + 0x14)\n#define CXL_HDM_DECODER0_SIZE_LOW_OFFSET(i) (0x20 * (i) + 0x18)\n#define CXL_HDM_DECODER0_SIZE_HIGH_OFFSET(i) (0x20 * (i) + 0x1c)\n#define CXL_HDM_DECODER0_CTRL_OFFSET(i) (0x20 * (i) + 0x20)\n#define   CXL_HDM_DECODER0_CTRL_IG_MASK GENMASK(3, 0)\n#define   CXL_HDM_DECODER0_CTRL_IW_MASK GENMASK(7, 4)\n#define   CXL_HDM_DECODER0_CTRL_LOCK BIT(8)\n#define   CXL_HDM_DECODER0_CTRL_COMMIT BIT(9)\n#define   CXL_HDM_DECODER0_CTRL_COMMITTED BIT(10)\n#define   CXL_HDM_DECODER0_CTRL_COMMIT_ERROR BIT(11)\n#define   CXL_HDM_DECODER0_CTRL_HOSTONLY BIT(12)\n#define CXL_HDM_DECODER0_TL_LOW(i) (0x20 * (i) + 0x24)\n#define CXL_HDM_DECODER0_TL_HIGH(i) (0x20 * (i) + 0x28)\n#define CXL_HDM_DECODER0_SKIP_LOW(i) CXL_HDM_DECODER0_TL_LOW(i)\n#define CXL_HDM_DECODER0_SKIP_HIGH(i) CXL_HDM_DECODER0_TL_HIGH(i)\n\n \n#define CXL_DECODER_MIN_GRANULARITY 256\n#define CXL_DECODER_MAX_ENCODED_IG 6\n\nstatic inline int cxl_hdm_decoder_count(u32 cap_hdr)\n{\n\tint val = FIELD_GET(CXL_HDM_DECODER_COUNT_MASK, cap_hdr);\n\n\treturn val ? val * 2 : 1;\n}\n\n \nstatic inline int eig_to_granularity(u16 eig, unsigned int *granularity)\n{\n\tif (eig > CXL_DECODER_MAX_ENCODED_IG)\n\t\treturn -EINVAL;\n\t*granularity = CXL_DECODER_MIN_GRANULARITY << eig;\n\treturn 0;\n}\n\n \nstatic inline int eiw_to_ways(u8 eiw, unsigned int *ways)\n{\n\tswitch (eiw) {\n\tcase 0 ... 4:\n\t\t*ways = 1 << eiw;\n\t\tbreak;\n\tcase 8 ... 10:\n\t\t*ways = 3 << (eiw - 8);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic inline int granularity_to_eig(int granularity, u16 *eig)\n{\n\tif (granularity > SZ_16K || granularity < CXL_DECODER_MIN_GRANULARITY ||\n\t    !is_power_of_2(granularity))\n\t\treturn -EINVAL;\n\t*eig = ilog2(granularity) - 8;\n\treturn 0;\n}\n\nstatic inline int ways_to_eiw(unsigned int ways, u8 *eiw)\n{\n\tif (ways > 16)\n\t\treturn -EINVAL;\n\tif (is_power_of_2(ways)) {\n\t\t*eiw = ilog2(ways);\n\t\treturn 0;\n\t}\n\tif (ways % 3)\n\t\treturn -EINVAL;\n\tways /= 3;\n\tif (!is_power_of_2(ways))\n\t\treturn -EINVAL;\n\t*eiw = ilog2(ways) + 8;\n\treturn 0;\n}\n\n \n#define CXL_RAS_UNCORRECTABLE_STATUS_OFFSET 0x0\n#define   CXL_RAS_UNCORRECTABLE_STATUS_MASK (GENMASK(16, 14) | GENMASK(11, 0))\n#define CXL_RAS_UNCORRECTABLE_MASK_OFFSET 0x4\n#define   CXL_RAS_UNCORRECTABLE_MASK_MASK (GENMASK(16, 14) | GENMASK(11, 0))\n#define   CXL_RAS_UNCORRECTABLE_MASK_F256B_MASK BIT(8)\n#define CXL_RAS_UNCORRECTABLE_SEVERITY_OFFSET 0x8\n#define   CXL_RAS_UNCORRECTABLE_SEVERITY_MASK (GENMASK(16, 14) | GENMASK(11, 0))\n#define CXL_RAS_CORRECTABLE_STATUS_OFFSET 0xC\n#define   CXL_RAS_CORRECTABLE_STATUS_MASK GENMASK(6, 0)\n#define CXL_RAS_CORRECTABLE_MASK_OFFSET 0x10\n#define   CXL_RAS_CORRECTABLE_MASK_MASK GENMASK(6, 0)\n#define CXL_RAS_CAP_CONTROL_OFFSET 0x14\n#define CXL_RAS_CAP_CONTROL_FE_MASK GENMASK(5, 0)\n#define CXL_RAS_HEADER_LOG_OFFSET 0x18\n#define CXL_RAS_CAPABILITY_LENGTH 0x58\n#define CXL_HEADERLOG_SIZE SZ_512\n#define CXL_HEADERLOG_SIZE_U32 SZ_512 / sizeof(u32)\n\n \n#define CXLDEV_CAP_ARRAY_OFFSET 0x0\n#define   CXLDEV_CAP_ARRAY_CAP_ID 0\n#define   CXLDEV_CAP_ARRAY_ID_MASK GENMASK_ULL(15, 0)\n#define   CXLDEV_CAP_ARRAY_COUNT_MASK GENMASK_ULL(47, 32)\n \n#define CXLDEV_CAP_HDR_CAP_ID_MASK GENMASK(15, 0)\n \n#define CXLDEV_CAP_CAP_ID_DEVICE_STATUS 0x1\n#define CXLDEV_CAP_CAP_ID_PRIMARY_MAILBOX 0x2\n#define CXLDEV_CAP_CAP_ID_SECONDARY_MAILBOX 0x3\n#define CXLDEV_CAP_CAP_ID_MEMDEV 0x4000\n\n \n#define CXLDEV_DEV_EVENT_STATUS_OFFSET\t\t0x00\n#define CXLDEV_EVENT_STATUS_INFO\t\tBIT(0)\n#define CXLDEV_EVENT_STATUS_WARN\t\tBIT(1)\n#define CXLDEV_EVENT_STATUS_FAIL\t\tBIT(2)\n#define CXLDEV_EVENT_STATUS_FATAL\t\tBIT(3)\n\n#define CXLDEV_EVENT_STATUS_ALL (CXLDEV_EVENT_STATUS_INFO |\t\\\n\t\t\t\t CXLDEV_EVENT_STATUS_WARN |\t\\\n\t\t\t\t CXLDEV_EVENT_STATUS_FAIL |\t\\\n\t\t\t\t CXLDEV_EVENT_STATUS_FATAL)\n\n \n#define CXLDEV_EVENT_INT_MODE_MASK\tGENMASK(1, 0)\n#define CXLDEV_EVENT_INT_MSGNUM_MASK\tGENMASK(7, 4)\n\n \n#define CXLDEV_MBOX_CAPS_OFFSET 0x00\n#define   CXLDEV_MBOX_CAP_PAYLOAD_SIZE_MASK GENMASK(4, 0)\n#define   CXLDEV_MBOX_CAP_BG_CMD_IRQ BIT(6)\n#define   CXLDEV_MBOX_CAP_IRQ_MSGNUM_MASK GENMASK(10, 7)\n#define CXLDEV_MBOX_CTRL_OFFSET 0x04\n#define   CXLDEV_MBOX_CTRL_DOORBELL BIT(0)\n#define   CXLDEV_MBOX_CTRL_BG_CMD_IRQ BIT(2)\n#define CXLDEV_MBOX_CMD_OFFSET 0x08\n#define   CXLDEV_MBOX_CMD_COMMAND_OPCODE_MASK GENMASK_ULL(15, 0)\n#define   CXLDEV_MBOX_CMD_PAYLOAD_LENGTH_MASK GENMASK_ULL(36, 16)\n#define CXLDEV_MBOX_STATUS_OFFSET 0x10\n#define   CXLDEV_MBOX_STATUS_BG_CMD BIT(0)\n#define   CXLDEV_MBOX_STATUS_RET_CODE_MASK GENMASK_ULL(47, 32)\n#define CXLDEV_MBOX_BG_CMD_STATUS_OFFSET 0x18\n#define   CXLDEV_MBOX_BG_CMD_COMMAND_OPCODE_MASK GENMASK_ULL(15, 0)\n#define   CXLDEV_MBOX_BG_CMD_COMMAND_PCT_MASK GENMASK_ULL(22, 16)\n#define   CXLDEV_MBOX_BG_CMD_COMMAND_RC_MASK GENMASK_ULL(47, 32)\n#define   CXLDEV_MBOX_BG_CMD_COMMAND_VENDOR_MASK GENMASK_ULL(63, 48)\n#define CXLDEV_MBOX_PAYLOAD_OFFSET 0x20\n\n \nstruct cxl_regs {\n\t \n\tstruct_group_tagged(cxl_component_regs, component,\n\t\tvoid __iomem *hdm_decoder;\n\t\tvoid __iomem *ras;\n\t);\n\t \n\tstruct_group_tagged(cxl_device_regs, device_regs,\n\t\tvoid __iomem *status, *mbox, *memdev;\n\t);\n\n\tstruct_group_tagged(cxl_pmu_regs, pmu_regs,\n\t\tvoid __iomem *pmu;\n\t);\n};\n\nstruct cxl_reg_map {\n\tbool valid;\n\tint id;\n\tunsigned long offset;\n\tunsigned long size;\n};\n\nstruct cxl_component_reg_map {\n\tstruct cxl_reg_map hdm_decoder;\n\tstruct cxl_reg_map ras;\n};\n\nstruct cxl_device_reg_map {\n\tstruct cxl_reg_map status;\n\tstruct cxl_reg_map mbox;\n\tstruct cxl_reg_map memdev;\n};\n\nstruct cxl_pmu_reg_map {\n\tstruct cxl_reg_map pmu;\n};\n\n \nstruct cxl_register_map {\n\tstruct device *host;\n\tvoid __iomem *base;\n\tresource_size_t resource;\n\tresource_size_t max_size;\n\tu8 reg_type;\n\tunion {\n\t\tstruct cxl_component_reg_map component_map;\n\t\tstruct cxl_device_reg_map device_map;\n\t\tstruct cxl_pmu_reg_map pmu_map;\n\t};\n};\n\nvoid cxl_probe_component_regs(struct device *dev, void __iomem *base,\n\t\t\t      struct cxl_component_reg_map *map);\nvoid cxl_probe_device_regs(struct device *dev, void __iomem *base,\n\t\t\t   struct cxl_device_reg_map *map);\nint cxl_map_component_regs(const struct cxl_register_map *map,\n\t\t\t   struct cxl_component_regs *regs,\n\t\t\t   unsigned long map_mask);\nint cxl_map_device_regs(const struct cxl_register_map *map,\n\t\t\tstruct cxl_device_regs *regs);\nint cxl_map_pmu_regs(struct pci_dev *pdev, struct cxl_pmu_regs *regs,\n\t\t     struct cxl_register_map *map);\n\nenum cxl_regloc_type;\nint cxl_count_regblock(struct pci_dev *pdev, enum cxl_regloc_type type);\nint cxl_find_regblock_instance(struct pci_dev *pdev, enum cxl_regloc_type type,\n\t\t\t       struct cxl_register_map *map, int index);\nint cxl_find_regblock(struct pci_dev *pdev, enum cxl_regloc_type type,\n\t\t      struct cxl_register_map *map);\nint cxl_setup_regs(struct cxl_register_map *map);\nstruct cxl_dport;\nresource_size_t cxl_rcd_component_reg_phys(struct device *dev,\n\t\t\t\t\t   struct cxl_dport *dport);\n\n#define CXL_RESOURCE_NONE ((resource_size_t) -1)\n#define CXL_TARGET_STRLEN 20\n\n \n#define CXL_DECODER_F_RAM   BIT(0)\n#define CXL_DECODER_F_PMEM  BIT(1)\n#define CXL_DECODER_F_TYPE2 BIT(2)\n#define CXL_DECODER_F_TYPE3 BIT(3)\n#define CXL_DECODER_F_LOCK  BIT(4)\n#define CXL_DECODER_F_ENABLE    BIT(5)\n#define CXL_DECODER_F_MASK  GENMASK(5, 0)\n\nenum cxl_decoder_type {\n\tCXL_DECODER_DEVMEM = 2,\n\tCXL_DECODER_HOSTONLYMEM = 3,\n};\n\n \n#define CXL_DECODER_MAX_INTERLEAVE 16\n\n\n \nstruct cxl_decoder {\n\tstruct device dev;\n\tint id;\n\tstruct range hpa_range;\n\tint interleave_ways;\n\tint interleave_granularity;\n\tenum cxl_decoder_type target_type;\n\tstruct cxl_region *region;\n\tunsigned long flags;\n\tint (*commit)(struct cxl_decoder *cxld);\n\tint (*reset)(struct cxl_decoder *cxld);\n};\n\n \nenum cxl_decoder_mode {\n\tCXL_DECODER_NONE,\n\tCXL_DECODER_RAM,\n\tCXL_DECODER_PMEM,\n\tCXL_DECODER_MIXED,\n\tCXL_DECODER_DEAD,\n};\n\nstatic inline const char *cxl_decoder_mode_name(enum cxl_decoder_mode mode)\n{\n\tstatic const char * const names[] = {\n\t\t[CXL_DECODER_NONE] = \"none\",\n\t\t[CXL_DECODER_RAM] = \"ram\",\n\t\t[CXL_DECODER_PMEM] = \"pmem\",\n\t\t[CXL_DECODER_MIXED] = \"mixed\",\n\t};\n\n\tif (mode >= CXL_DECODER_NONE && mode <= CXL_DECODER_MIXED)\n\t\treturn names[mode];\n\treturn \"mixed\";\n}\n\n \nenum cxl_decoder_state {\n\tCXL_DECODER_STATE_MANUAL,\n\tCXL_DECODER_STATE_AUTO,\n};\n\n \nstruct cxl_endpoint_decoder {\n\tstruct cxl_decoder cxld;\n\tstruct resource *dpa_res;\n\tresource_size_t skip;\n\tenum cxl_decoder_mode mode;\n\tenum cxl_decoder_state state;\n\tint pos;\n};\n\n \nstruct cxl_switch_decoder {\n\tstruct cxl_decoder cxld;\n\tint nr_targets;\n\tstruct cxl_dport *target[];\n};\n\nstruct cxl_root_decoder;\ntypedef struct cxl_dport *(*cxl_calc_hb_fn)(struct cxl_root_decoder *cxlrd,\n\t\t\t\t\t    int pos);\n\n \nstruct cxl_root_decoder {\n\tstruct resource *res;\n\tatomic_t region_id;\n\tcxl_calc_hb_fn calc_hb;\n\tvoid *platform_data;\n\tstruct mutex range_lock;\n\tstruct cxl_switch_decoder cxlsd;\n};\n\n \nenum cxl_config_state {\n\tCXL_CONFIG_IDLE,\n\tCXL_CONFIG_INTERLEAVE_ACTIVE,\n\tCXL_CONFIG_ACTIVE,\n\tCXL_CONFIG_RESET_PENDING,\n\tCXL_CONFIG_COMMIT,\n};\n\n \nstruct cxl_region_params {\n\tenum cxl_config_state state;\n\tuuid_t uuid;\n\tint interleave_ways;\n\tint interleave_granularity;\n\tstruct resource *res;\n\tstruct cxl_endpoint_decoder *targets[CXL_DECODER_MAX_INTERLEAVE];\n\tint nr_targets;\n};\n\n \n#define CXL_REGION_F_AUTO 0\n\n \n#define CXL_REGION_F_NEEDS_RESET 1\n\n \nstruct cxl_region {\n\tstruct device dev;\n\tint id;\n\tenum cxl_decoder_mode mode;\n\tenum cxl_decoder_type type;\n\tstruct cxl_nvdimm_bridge *cxl_nvb;\n\tstruct cxl_pmem_region *cxlr_pmem;\n\tunsigned long flags;\n\tstruct cxl_region_params params;\n};\n\nstruct cxl_nvdimm_bridge {\n\tint id;\n\tstruct device dev;\n\tstruct cxl_port *port;\n\tstruct nvdimm_bus *nvdimm_bus;\n\tstruct nvdimm_bus_descriptor nd_desc;\n};\n\n#define CXL_DEV_ID_LEN 19\n\nstruct cxl_nvdimm {\n\tstruct device dev;\n\tstruct cxl_memdev *cxlmd;\n\tu8 dev_id[CXL_DEV_ID_LEN];  \n};\n\nstruct cxl_pmem_region_mapping {\n\tstruct cxl_memdev *cxlmd;\n\tstruct cxl_nvdimm *cxl_nvd;\n\tu64 start;\n\tu64 size;\n\tint position;\n};\n\nstruct cxl_pmem_region {\n\tstruct device dev;\n\tstruct cxl_region *cxlr;\n\tstruct nd_region *nd_region;\n\tstruct range hpa_range;\n\tint nr_mappings;\n\tstruct cxl_pmem_region_mapping mapping[];\n};\n\nstruct cxl_dax_region {\n\tstruct device dev;\n\tstruct cxl_region *cxlr;\n\tstruct range hpa_range;\n};\n\n \nstruct cxl_port {\n\tstruct device dev;\n\tstruct device *uport_dev;\n\tstruct device *host_bridge;\n\tint id;\n\tstruct xarray dports;\n\tstruct xarray endpoints;\n\tstruct xarray regions;\n\tstruct cxl_dport *parent_dport;\n\tstruct ida decoder_ida;\n\tstruct cxl_register_map comp_map;\n\tint nr_dports;\n\tint hdm_end;\n\tint commit_end;\n\tresource_size_t component_reg_phys;\n\tbool dead;\n\tunsigned int depth;\n\tstruct cxl_cdat {\n\t\tvoid *table;\n\t\tsize_t length;\n\t} cdat;\n\tbool cdat_available;\n};\n\nstatic inline struct cxl_dport *\ncxl_find_dport_by_dev(struct cxl_port *port, const struct device *dport_dev)\n{\n\treturn xa_load(&port->dports, (unsigned long)dport_dev);\n}\n\nstruct cxl_rcrb_info {\n\tresource_size_t base;\n\tu16 aer_cap;\n};\n\n \nstruct cxl_dport {\n\tstruct device *dport_dev;\n\tstruct cxl_register_map comp_map;\n\tint port_id;\n\tstruct cxl_rcrb_info rcrb;\n\tbool rch;\n\tstruct cxl_port *port;\n};\n\n \nstruct cxl_ep {\n\tstruct device *ep;\n\tstruct cxl_dport *dport;\n\tstruct cxl_port *next;\n};\n\n \nstruct cxl_region_ref {\n\tstruct cxl_port *port;\n\tstruct cxl_decoder *decoder;\n\tstruct cxl_region *region;\n\tstruct xarray endpoints;\n\tint nr_targets_set;\n\tint nr_eps;\n\tint nr_targets;\n};\n\n \nstatic inline bool is_cxl_root(struct cxl_port *port)\n{\n\treturn port->uport_dev == port->dev.parent;\n}\n\nint cxl_num_decoders_committed(struct cxl_port *port);\nbool is_cxl_port(const struct device *dev);\nstruct cxl_port *to_cxl_port(const struct device *dev);\nstruct pci_bus;\nint devm_cxl_register_pci_bus(struct device *host, struct device *uport_dev,\n\t\t\t      struct pci_bus *bus);\nstruct pci_bus *cxl_port_to_pci_bus(struct cxl_port *port);\nstruct cxl_port *devm_cxl_add_port(struct device *host,\n\t\t\t\t   struct device *uport_dev,\n\t\t\t\t   resource_size_t component_reg_phys,\n\t\t\t\t   struct cxl_dport *parent_dport);\nstruct cxl_port *find_cxl_root(struct cxl_port *port);\nint devm_cxl_enumerate_ports(struct cxl_memdev *cxlmd);\nvoid cxl_bus_rescan(void);\nvoid cxl_bus_drain(void);\nstruct cxl_port *cxl_pci_find_port(struct pci_dev *pdev,\n\t\t\t\t   struct cxl_dport **dport);\nstruct cxl_port *cxl_mem_find_port(struct cxl_memdev *cxlmd,\n\t\t\t\t   struct cxl_dport **dport);\nbool schedule_cxl_memdev_detach(struct cxl_memdev *cxlmd);\n\nstruct cxl_dport *devm_cxl_add_dport(struct cxl_port *port,\n\t\t\t\t     struct device *dport, int port_id,\n\t\t\t\t     resource_size_t component_reg_phys);\nstruct cxl_dport *devm_cxl_add_rch_dport(struct cxl_port *port,\n\t\t\t\t\t struct device *dport_dev, int port_id,\n\t\t\t\t\t resource_size_t rcrb);\n\nstruct cxl_decoder *to_cxl_decoder(struct device *dev);\nstruct cxl_root_decoder *to_cxl_root_decoder(struct device *dev);\nstruct cxl_switch_decoder *to_cxl_switch_decoder(struct device *dev);\nstruct cxl_endpoint_decoder *to_cxl_endpoint_decoder(struct device *dev);\nbool is_root_decoder(struct device *dev);\nbool is_switch_decoder(struct device *dev);\nbool is_endpoint_decoder(struct device *dev);\nstruct cxl_root_decoder *cxl_root_decoder_alloc(struct cxl_port *port,\n\t\t\t\t\t\tunsigned int nr_targets,\n\t\t\t\t\t\tcxl_calc_hb_fn calc_hb);\nstruct cxl_dport *cxl_hb_modulo(struct cxl_root_decoder *cxlrd, int pos);\nstruct cxl_switch_decoder *cxl_switch_decoder_alloc(struct cxl_port *port,\n\t\t\t\t\t\t    unsigned int nr_targets);\nint cxl_decoder_add(struct cxl_decoder *cxld, int *target_map);\nstruct cxl_endpoint_decoder *cxl_endpoint_decoder_alloc(struct cxl_port *port);\nint cxl_decoder_add_locked(struct cxl_decoder *cxld, int *target_map);\nint cxl_decoder_autoremove(struct device *host, struct cxl_decoder *cxld);\nint cxl_endpoint_autoremove(struct cxl_memdev *cxlmd, struct cxl_port *endpoint);\n\n \nstruct cxl_endpoint_dvsec_info {\n\tbool mem_enabled;\n\tint ranges;\n\tstruct cxl_port *port;\n\tstruct range dvsec_range[2];\n};\n\nstruct cxl_hdm;\nstruct cxl_hdm *devm_cxl_setup_hdm(struct cxl_port *port,\n\t\t\t\t   struct cxl_endpoint_dvsec_info *info);\nint devm_cxl_enumerate_decoders(struct cxl_hdm *cxlhdm,\n\t\t\t\tstruct cxl_endpoint_dvsec_info *info);\nint devm_cxl_add_passthrough_decoder(struct cxl_port *port);\nint cxl_dvsec_rr_decode(struct device *dev, int dvsec,\n\t\t\tstruct cxl_endpoint_dvsec_info *info);\n\nbool is_cxl_region(struct device *dev);\n\nextern struct bus_type cxl_bus_type;\n\nstruct cxl_driver {\n\tconst char *name;\n\tint (*probe)(struct device *dev);\n\tvoid (*remove)(struct device *dev);\n\tstruct device_driver drv;\n\tint id;\n};\n\nstatic inline struct cxl_driver *to_cxl_drv(struct device_driver *drv)\n{\n\treturn container_of(drv, struct cxl_driver, drv);\n}\n\nint __cxl_driver_register(struct cxl_driver *cxl_drv, struct module *owner,\n\t\t\t  const char *modname);\n#define cxl_driver_register(x) __cxl_driver_register(x, THIS_MODULE, KBUILD_MODNAME)\nvoid cxl_driver_unregister(struct cxl_driver *cxl_drv);\n\n#define module_cxl_driver(__cxl_driver) \\\n\tmodule_driver(__cxl_driver, cxl_driver_register, cxl_driver_unregister)\n\n#define CXL_DEVICE_NVDIMM_BRIDGE\t1\n#define CXL_DEVICE_NVDIMM\t\t2\n#define CXL_DEVICE_PORT\t\t\t3\n#define CXL_DEVICE_ROOT\t\t\t4\n#define CXL_DEVICE_MEMORY_EXPANDER\t5\n#define CXL_DEVICE_REGION\t\t6\n#define CXL_DEVICE_PMEM_REGION\t\t7\n#define CXL_DEVICE_DAX_REGION\t\t8\n#define CXL_DEVICE_PMU\t\t\t9\n\n#define MODULE_ALIAS_CXL(type) MODULE_ALIAS(\"cxl:t\" __stringify(type) \"*\")\n#define CXL_MODALIAS_FMT \"cxl:t%d\"\n\nstruct cxl_nvdimm_bridge *to_cxl_nvdimm_bridge(struct device *dev);\nstruct cxl_nvdimm_bridge *devm_cxl_add_nvdimm_bridge(struct device *host,\n\t\t\t\t\t\t     struct cxl_port *port);\nstruct cxl_nvdimm *to_cxl_nvdimm(struct device *dev);\nbool is_cxl_nvdimm(struct device *dev);\nbool is_cxl_nvdimm_bridge(struct device *dev);\nint devm_cxl_add_nvdimm(struct cxl_memdev *cxlmd);\nstruct cxl_nvdimm_bridge *cxl_find_nvdimm_bridge(struct cxl_memdev *cxlmd);\n\n#ifdef CONFIG_CXL_REGION\nbool is_cxl_pmem_region(struct device *dev);\nstruct cxl_pmem_region *to_cxl_pmem_region(struct device *dev);\nint cxl_add_to_region(struct cxl_port *root,\n\t\t      struct cxl_endpoint_decoder *cxled);\nstruct cxl_dax_region *to_cxl_dax_region(struct device *dev);\n#else\nstatic inline bool is_cxl_pmem_region(struct device *dev)\n{\n\treturn false;\n}\nstatic inline struct cxl_pmem_region *to_cxl_pmem_region(struct device *dev)\n{\n\treturn NULL;\n}\nstatic inline int cxl_add_to_region(struct cxl_port *root,\n\t\t\t\t    struct cxl_endpoint_decoder *cxled)\n{\n\treturn 0;\n}\nstatic inline struct cxl_dax_region *to_cxl_dax_region(struct device *dev)\n{\n\treturn NULL;\n}\n#endif\n\n \n#ifndef __mock\n#define __mock static\n#endif\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}