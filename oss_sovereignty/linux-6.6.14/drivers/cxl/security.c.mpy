{
  "module_name": "security.c",
  "hash_id": "e0a72d2a4c86b8f6df52134af5ed41196b130e052815933b8f6bcdf076f44969",
  "original_prompt": "Ingested from linux-6.6.14/drivers/cxl/security.c",
  "human_readable_source": "\n \n#include <linux/libnvdimm.h>\n#include <asm/unaligned.h>\n#include <linux/module.h>\n#include <linux/async.h>\n#include <linux/slab.h>\n#include <linux/memregion.h>\n#include \"cxlmem.h\"\n#include \"cxl.h\"\n\nstatic unsigned long cxl_pmem_get_security_flags(struct nvdimm *nvdimm,\n\t\t\t\t\t\t enum nvdimm_passphrase_type ptype)\n{\n\tstruct cxl_nvdimm *cxl_nvd = nvdimm_provider_data(nvdimm);\n\tstruct cxl_memdev *cxlmd = cxl_nvd->cxlmd;\n\tstruct cxl_memdev_state *mds = to_cxl_memdev_state(cxlmd->cxlds);\n\tunsigned long security_flags = 0;\n\tstruct cxl_get_security_output {\n\t\t__le32 flags;\n\t} out;\n\tstruct cxl_mbox_cmd mbox_cmd;\n\tu32 sec_out;\n\tint rc;\n\n\tmbox_cmd = (struct cxl_mbox_cmd) {\n\t\t.opcode = CXL_MBOX_OP_GET_SECURITY_STATE,\n\t\t.size_out = sizeof(out),\n\t\t.payload_out = &out,\n\t};\n\n\trc = cxl_internal_send_cmd(mds, &mbox_cmd);\n\tif (rc < 0)\n\t\treturn 0;\n\n\tsec_out = le32_to_cpu(out.flags);\n\t \n\tmds->security.state = sec_out;\n\n\tif (ptype == NVDIMM_MASTER) {\n\t\tif (sec_out & CXL_PMEM_SEC_STATE_MASTER_PASS_SET)\n\t\t\tset_bit(NVDIMM_SECURITY_UNLOCKED, &security_flags);\n\t\telse\n\t\t\tset_bit(NVDIMM_SECURITY_DISABLED, &security_flags);\n\t\tif (sec_out & CXL_PMEM_SEC_STATE_MASTER_PLIMIT)\n\t\t\tset_bit(NVDIMM_SECURITY_FROZEN, &security_flags);\n\t\treturn security_flags;\n\t}\n\n\tif (sec_out & CXL_PMEM_SEC_STATE_USER_PASS_SET) {\n\t\tif (sec_out & CXL_PMEM_SEC_STATE_FROZEN ||\n\t\t    sec_out & CXL_PMEM_SEC_STATE_USER_PLIMIT)\n\t\t\tset_bit(NVDIMM_SECURITY_FROZEN, &security_flags);\n\n\t\tif (sec_out & CXL_PMEM_SEC_STATE_LOCKED)\n\t\t\tset_bit(NVDIMM_SECURITY_LOCKED, &security_flags);\n\t\telse\n\t\t\tset_bit(NVDIMM_SECURITY_UNLOCKED, &security_flags);\n\t} else {\n\t\tset_bit(NVDIMM_SECURITY_DISABLED, &security_flags);\n\t}\n\n\treturn security_flags;\n}\n\nstatic int cxl_pmem_security_change_key(struct nvdimm *nvdimm,\n\t\t\t\t\tconst struct nvdimm_key_data *old_data,\n\t\t\t\t\tconst struct nvdimm_key_data *new_data,\n\t\t\t\t\tenum nvdimm_passphrase_type ptype)\n{\n\tstruct cxl_nvdimm *cxl_nvd = nvdimm_provider_data(nvdimm);\n\tstruct cxl_memdev *cxlmd = cxl_nvd->cxlmd;\n\tstruct cxl_memdev_state *mds = to_cxl_memdev_state(cxlmd->cxlds);\n\tstruct cxl_mbox_cmd mbox_cmd;\n\tstruct cxl_set_pass set_pass;\n\n\tset_pass = (struct cxl_set_pass) {\n\t\t.type = ptype == NVDIMM_MASTER ? CXL_PMEM_SEC_PASS_MASTER :\n\t\t\t\t\t\t CXL_PMEM_SEC_PASS_USER,\n\t};\n\tmemcpy(set_pass.old_pass, old_data->data, NVDIMM_PASSPHRASE_LEN);\n\tmemcpy(set_pass.new_pass, new_data->data, NVDIMM_PASSPHRASE_LEN);\n\n\tmbox_cmd = (struct cxl_mbox_cmd) {\n\t\t.opcode = CXL_MBOX_OP_SET_PASSPHRASE,\n\t\t.size_in = sizeof(set_pass),\n\t\t.payload_in = &set_pass,\n\t};\n\n\treturn cxl_internal_send_cmd(mds, &mbox_cmd);\n}\n\nstatic int __cxl_pmem_security_disable(struct nvdimm *nvdimm,\n\t\t\t\t       const struct nvdimm_key_data *key_data,\n\t\t\t\t       enum nvdimm_passphrase_type ptype)\n{\n\tstruct cxl_nvdimm *cxl_nvd = nvdimm_provider_data(nvdimm);\n\tstruct cxl_memdev *cxlmd = cxl_nvd->cxlmd;\n\tstruct cxl_memdev_state *mds = to_cxl_memdev_state(cxlmd->cxlds);\n\tstruct cxl_disable_pass dis_pass;\n\tstruct cxl_mbox_cmd mbox_cmd;\n\n\tdis_pass = (struct cxl_disable_pass) {\n\t\t.type = ptype == NVDIMM_MASTER ? CXL_PMEM_SEC_PASS_MASTER :\n\t\t\t\t\t\t CXL_PMEM_SEC_PASS_USER,\n\t};\n\tmemcpy(dis_pass.pass, key_data->data, NVDIMM_PASSPHRASE_LEN);\n\n\tmbox_cmd = (struct cxl_mbox_cmd) {\n\t\t.opcode = CXL_MBOX_OP_DISABLE_PASSPHRASE,\n\t\t.size_in = sizeof(dis_pass),\n\t\t.payload_in = &dis_pass,\n\t};\n\n\treturn cxl_internal_send_cmd(mds, &mbox_cmd);\n}\n\nstatic int cxl_pmem_security_disable(struct nvdimm *nvdimm,\n\t\t\t\t     const struct nvdimm_key_data *key_data)\n{\n\treturn __cxl_pmem_security_disable(nvdimm, key_data, NVDIMM_USER);\n}\n\nstatic int cxl_pmem_security_disable_master(struct nvdimm *nvdimm,\n\t\t\t\t\t    const struct nvdimm_key_data *key_data)\n{\n\treturn __cxl_pmem_security_disable(nvdimm, key_data, NVDIMM_MASTER);\n}\n\nstatic int cxl_pmem_security_freeze(struct nvdimm *nvdimm)\n{\n\tstruct cxl_nvdimm *cxl_nvd = nvdimm_provider_data(nvdimm);\n\tstruct cxl_memdev *cxlmd = cxl_nvd->cxlmd;\n\tstruct cxl_memdev_state *mds = to_cxl_memdev_state(cxlmd->cxlds);\n\tstruct cxl_mbox_cmd mbox_cmd = {\n\t\t.opcode = CXL_MBOX_OP_FREEZE_SECURITY,\n\t};\n\n\treturn cxl_internal_send_cmd(mds, &mbox_cmd);\n}\n\nstatic int cxl_pmem_security_unlock(struct nvdimm *nvdimm,\n\t\t\t\t    const struct nvdimm_key_data *key_data)\n{\n\tstruct cxl_nvdimm *cxl_nvd = nvdimm_provider_data(nvdimm);\n\tstruct cxl_memdev *cxlmd = cxl_nvd->cxlmd;\n\tstruct cxl_memdev_state *mds = to_cxl_memdev_state(cxlmd->cxlds);\n\tu8 pass[NVDIMM_PASSPHRASE_LEN];\n\tstruct cxl_mbox_cmd mbox_cmd;\n\tint rc;\n\n\tmemcpy(pass, key_data->data, NVDIMM_PASSPHRASE_LEN);\n\tmbox_cmd = (struct cxl_mbox_cmd) {\n\t\t.opcode = CXL_MBOX_OP_UNLOCK,\n\t\t.size_in = NVDIMM_PASSPHRASE_LEN,\n\t\t.payload_in = pass,\n\t};\n\n\trc = cxl_internal_send_cmd(mds, &mbox_cmd);\n\tif (rc < 0)\n\t\treturn rc;\n\n\treturn 0;\n}\n\nstatic int cxl_pmem_security_passphrase_erase(struct nvdimm *nvdimm,\n\t\t\t\t\t      const struct nvdimm_key_data *key,\n\t\t\t\t\t      enum nvdimm_passphrase_type ptype)\n{\n\tstruct cxl_nvdimm *cxl_nvd = nvdimm_provider_data(nvdimm);\n\tstruct cxl_memdev *cxlmd = cxl_nvd->cxlmd;\n\tstruct cxl_memdev_state *mds = to_cxl_memdev_state(cxlmd->cxlds);\n\tstruct cxl_mbox_cmd mbox_cmd;\n\tstruct cxl_pass_erase erase;\n\tint rc;\n\n\terase = (struct cxl_pass_erase) {\n\t\t.type = ptype == NVDIMM_MASTER ? CXL_PMEM_SEC_PASS_MASTER :\n\t\t\t\t\t\t CXL_PMEM_SEC_PASS_USER,\n\t};\n\tmemcpy(erase.pass, key->data, NVDIMM_PASSPHRASE_LEN);\n\tmbox_cmd = (struct cxl_mbox_cmd) {\n\t\t.opcode = CXL_MBOX_OP_PASSPHRASE_SECURE_ERASE,\n\t\t.size_in = sizeof(erase),\n\t\t.payload_in = &erase,\n\t};\n\n\trc = cxl_internal_send_cmd(mds, &mbox_cmd);\n\tif (rc < 0)\n\t\treturn rc;\n\n\treturn 0;\n}\n\nstatic const struct nvdimm_security_ops __cxl_security_ops = {\n\t.get_flags = cxl_pmem_get_security_flags,\n\t.change_key = cxl_pmem_security_change_key,\n\t.disable = cxl_pmem_security_disable,\n\t.freeze = cxl_pmem_security_freeze,\n\t.unlock = cxl_pmem_security_unlock,\n\t.erase = cxl_pmem_security_passphrase_erase,\n\t.disable_master = cxl_pmem_security_disable_master,\n};\n\nconst struct nvdimm_security_ops *cxl_security_ops = &__cxl_security_ops;\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}