{
  "module_name": "pmem.c",
  "hash_id": "589f8900a4868f87a695b92bdfa61af020435763fd364cf19d09d7d0c7813299",
  "original_prompt": "Ingested from linux-6.6.14/drivers/cxl/pmem.c",
  "human_readable_source": "\n \n#include <linux/libnvdimm.h>\n#include <asm/unaligned.h>\n#include <linux/device.h>\n#include <linux/module.h>\n#include <linux/ndctl.h>\n#include <linux/async.h>\n#include <linux/slab.h>\n#include <linux/nd.h>\n#include \"cxlmem.h\"\n#include \"cxl.h\"\n\nextern const struct nvdimm_security_ops *cxl_security_ops;\n\nstatic __read_mostly DECLARE_BITMAP(exclusive_cmds, CXL_MEM_COMMAND_ID_MAX);\n\nstatic void clear_exclusive(void *mds)\n{\n\tclear_exclusive_cxl_commands(mds, exclusive_cmds);\n}\n\nstatic void unregister_nvdimm(void *nvdimm)\n{\n\tnvdimm_delete(nvdimm);\n}\n\nstatic ssize_t provider_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct nvdimm *nvdimm = to_nvdimm(dev);\n\tstruct cxl_nvdimm *cxl_nvd = nvdimm_provider_data(nvdimm);\n\n\treturn sysfs_emit(buf, \"%s\\n\", dev_name(&cxl_nvd->dev));\n}\nstatic DEVICE_ATTR_RO(provider);\n\nstatic ssize_t id_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct nvdimm *nvdimm = to_nvdimm(dev);\n\tstruct cxl_nvdimm *cxl_nvd = nvdimm_provider_data(nvdimm);\n\tstruct cxl_dev_state *cxlds = cxl_nvd->cxlmd->cxlds;\n\n\treturn sysfs_emit(buf, \"%lld\\n\", cxlds->serial);\n}\nstatic DEVICE_ATTR_RO(id);\n\nstatic struct attribute *cxl_dimm_attributes[] = {\n\t&dev_attr_id.attr,\n\t&dev_attr_provider.attr,\n\tNULL\n};\n\nstatic const struct attribute_group cxl_dimm_attribute_group = {\n\t.name = \"cxl\",\n\t.attrs = cxl_dimm_attributes,\n};\n\nstatic const struct attribute_group *cxl_dimm_attribute_groups[] = {\n\t&cxl_dimm_attribute_group,\n\tNULL\n};\n\nstatic int cxl_nvdimm_probe(struct device *dev)\n{\n\tstruct cxl_nvdimm *cxl_nvd = to_cxl_nvdimm(dev);\n\tstruct cxl_memdev *cxlmd = cxl_nvd->cxlmd;\n\tstruct cxl_nvdimm_bridge *cxl_nvb = cxlmd->cxl_nvb;\n\tstruct cxl_memdev_state *mds = to_cxl_memdev_state(cxlmd->cxlds);\n\tunsigned long flags = 0, cmd_mask = 0;\n\tstruct nvdimm *nvdimm;\n\tint rc;\n\n\tset_exclusive_cxl_commands(mds, exclusive_cmds);\n\trc = devm_add_action_or_reset(dev, clear_exclusive, mds);\n\tif (rc)\n\t\treturn rc;\n\n\tset_bit(NDD_LABELING, &flags);\n\tset_bit(NDD_REGISTER_SYNC, &flags);\n\tset_bit(ND_CMD_GET_CONFIG_SIZE, &cmd_mask);\n\tset_bit(ND_CMD_GET_CONFIG_DATA, &cmd_mask);\n\tset_bit(ND_CMD_SET_CONFIG_DATA, &cmd_mask);\n\tnvdimm = __nvdimm_create(cxl_nvb->nvdimm_bus, cxl_nvd,\n\t\t\t\t cxl_dimm_attribute_groups, flags,\n\t\t\t\t cmd_mask, 0, NULL, cxl_nvd->dev_id,\n\t\t\t\t cxl_security_ops, NULL);\n\tif (!nvdimm)\n\t\treturn -ENOMEM;\n\n\tdev_set_drvdata(dev, nvdimm);\n\treturn devm_add_action_or_reset(dev, unregister_nvdimm, nvdimm);\n}\n\nstatic struct cxl_driver cxl_nvdimm_driver = {\n\t.name = \"cxl_nvdimm\",\n\t.probe = cxl_nvdimm_probe,\n\t.id = CXL_DEVICE_NVDIMM,\n\t.drv = {\n\t\t.suppress_bind_attrs = true,\n\t},\n};\n\nstatic int cxl_pmem_get_config_size(struct cxl_memdev_state *mds,\n\t\t\t\t    struct nd_cmd_get_config_size *cmd,\n\t\t\t\t    unsigned int buf_len)\n{\n\tif (sizeof(*cmd) > buf_len)\n\t\treturn -EINVAL;\n\n\t*cmd = (struct nd_cmd_get_config_size){\n\t\t.config_size = mds->lsa_size,\n\t\t.max_xfer =\n\t\t\tmds->payload_size - sizeof(struct cxl_mbox_set_lsa),\n\t};\n\n\treturn 0;\n}\n\nstatic int cxl_pmem_get_config_data(struct cxl_memdev_state *mds,\n\t\t\t\t    struct nd_cmd_get_config_data_hdr *cmd,\n\t\t\t\t    unsigned int buf_len)\n{\n\tstruct cxl_mbox_get_lsa get_lsa;\n\tstruct cxl_mbox_cmd mbox_cmd;\n\tint rc;\n\n\tif (sizeof(*cmd) > buf_len)\n\t\treturn -EINVAL;\n\tif (struct_size(cmd, out_buf, cmd->in_length) > buf_len)\n\t\treturn -EINVAL;\n\n\tget_lsa = (struct cxl_mbox_get_lsa) {\n\t\t.offset = cpu_to_le32(cmd->in_offset),\n\t\t.length = cpu_to_le32(cmd->in_length),\n\t};\n\tmbox_cmd = (struct cxl_mbox_cmd) {\n\t\t.opcode = CXL_MBOX_OP_GET_LSA,\n\t\t.payload_in = &get_lsa,\n\t\t.size_in = sizeof(get_lsa),\n\t\t.size_out = cmd->in_length,\n\t\t.payload_out = cmd->out_buf,\n\t};\n\n\trc = cxl_internal_send_cmd(mds, &mbox_cmd);\n\tcmd->status = 0;\n\n\treturn rc;\n}\n\nstatic int cxl_pmem_set_config_data(struct cxl_memdev_state *mds,\n\t\t\t\t    struct nd_cmd_set_config_hdr *cmd,\n\t\t\t\t    unsigned int buf_len)\n{\n\tstruct cxl_mbox_set_lsa *set_lsa;\n\tstruct cxl_mbox_cmd mbox_cmd;\n\tint rc;\n\n\tif (sizeof(*cmd) > buf_len)\n\t\treturn -EINVAL;\n\n\t \n\tif (size_add(struct_size(cmd, in_buf, cmd->in_length), 4) > buf_len)\n\t\treturn -EINVAL;\n\n\tset_lsa =\n\t\tkvzalloc(struct_size(set_lsa, data, cmd->in_length), GFP_KERNEL);\n\tif (!set_lsa)\n\t\treturn -ENOMEM;\n\n\t*set_lsa = (struct cxl_mbox_set_lsa) {\n\t\t.offset = cpu_to_le32(cmd->in_offset),\n\t};\n\tmemcpy(set_lsa->data, cmd->in_buf, cmd->in_length);\n\tmbox_cmd = (struct cxl_mbox_cmd) {\n\t\t.opcode = CXL_MBOX_OP_SET_LSA,\n\t\t.payload_in = set_lsa,\n\t\t.size_in = struct_size(set_lsa, data, cmd->in_length),\n\t};\n\n\trc = cxl_internal_send_cmd(mds, &mbox_cmd);\n\n\t \n\tput_unaligned(0, (u32 *) &cmd->in_buf[cmd->in_length]);\n\tkvfree(set_lsa);\n\n\treturn rc;\n}\n\nstatic int cxl_pmem_nvdimm_ctl(struct nvdimm *nvdimm, unsigned int cmd,\n\t\t\t       void *buf, unsigned int buf_len)\n{\n\tstruct cxl_nvdimm *cxl_nvd = nvdimm_provider_data(nvdimm);\n\tunsigned long cmd_mask = nvdimm_cmd_mask(nvdimm);\n\tstruct cxl_memdev *cxlmd = cxl_nvd->cxlmd;\n\tstruct cxl_memdev_state *mds = to_cxl_memdev_state(cxlmd->cxlds);\n\n\tif (!test_bit(cmd, &cmd_mask))\n\t\treturn -ENOTTY;\n\n\tswitch (cmd) {\n\tcase ND_CMD_GET_CONFIG_SIZE:\n\t\treturn cxl_pmem_get_config_size(mds, buf, buf_len);\n\tcase ND_CMD_GET_CONFIG_DATA:\n\t\treturn cxl_pmem_get_config_data(mds, buf, buf_len);\n\tcase ND_CMD_SET_CONFIG_DATA:\n\t\treturn cxl_pmem_set_config_data(mds, buf, buf_len);\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n}\n\nstatic int cxl_pmem_ctl(struct nvdimm_bus_descriptor *nd_desc,\n\t\t\tstruct nvdimm *nvdimm, unsigned int cmd, void *buf,\n\t\t\tunsigned int buf_len, int *cmd_rc)\n{\n\t \n\t*cmd_rc = 0;\n\n\tif (!nvdimm)\n\t\treturn -ENOTTY;\n\treturn cxl_pmem_nvdimm_ctl(nvdimm, cmd, buf, buf_len);\n}\n\nstatic int detach_nvdimm(struct device *dev, void *data)\n{\n\tstruct cxl_nvdimm *cxl_nvd;\n\tbool release = false;\n\n\tif (!is_cxl_nvdimm(dev))\n\t\treturn 0;\n\n\tdevice_lock(dev);\n\tif (!dev->driver)\n\t\tgoto out;\n\n\tcxl_nvd = to_cxl_nvdimm(dev);\n\tif (cxl_nvd->cxlmd && cxl_nvd->cxlmd->cxl_nvb == data)\n\t\trelease = true;\nout:\n\tdevice_unlock(dev);\n\tif (release)\n\t\tdevice_release_driver(dev);\n\treturn 0;\n}\n\nstatic void unregister_nvdimm_bus(void *_cxl_nvb)\n{\n\tstruct cxl_nvdimm_bridge *cxl_nvb = _cxl_nvb;\n\tstruct nvdimm_bus *nvdimm_bus = cxl_nvb->nvdimm_bus;\n\n\tbus_for_each_dev(&cxl_bus_type, NULL, cxl_nvb, detach_nvdimm);\n\n\tcxl_nvb->nvdimm_bus = NULL;\n\tnvdimm_bus_unregister(nvdimm_bus);\n}\n\nstatic int cxl_nvdimm_bridge_probe(struct device *dev)\n{\n\tstruct cxl_nvdimm_bridge *cxl_nvb = to_cxl_nvdimm_bridge(dev);\n\n\tcxl_nvb->nd_desc = (struct nvdimm_bus_descriptor) {\n\t\t.provider_name = \"CXL\",\n\t\t.module = THIS_MODULE,\n\t\t.ndctl = cxl_pmem_ctl,\n\t};\n\n\tcxl_nvb->nvdimm_bus =\n\t\tnvdimm_bus_register(&cxl_nvb->dev, &cxl_nvb->nd_desc);\n\n\tif (!cxl_nvb->nvdimm_bus)\n\t\treturn -ENOMEM;\n\n\treturn devm_add_action_or_reset(dev, unregister_nvdimm_bus, cxl_nvb);\n}\n\nstatic struct cxl_driver cxl_nvdimm_bridge_driver = {\n\t.name = \"cxl_nvdimm_bridge\",\n\t.probe = cxl_nvdimm_bridge_probe,\n\t.id = CXL_DEVICE_NVDIMM_BRIDGE,\n\t.drv = {\n\t\t.suppress_bind_attrs = true,\n\t},\n};\n\nstatic void unregister_nvdimm_region(void *nd_region)\n{\n\tnvdimm_region_delete(nd_region);\n}\n\nstatic void cxlr_pmem_remove_resource(void *res)\n{\n\tremove_resource(res);\n}\n\nstruct cxl_pmem_region_info {\n\tu64 offset;\n\tu64 serial;\n};\n\nstatic int cxl_pmem_region_probe(struct device *dev)\n{\n\tstruct nd_mapping_desc mappings[CXL_DECODER_MAX_INTERLEAVE];\n\tstruct cxl_pmem_region *cxlr_pmem = to_cxl_pmem_region(dev);\n\tstruct cxl_region *cxlr = cxlr_pmem->cxlr;\n\tstruct cxl_nvdimm_bridge *cxl_nvb = cxlr->cxl_nvb;\n\tstruct cxl_pmem_region_info *info = NULL;\n\tstruct nd_interleave_set *nd_set;\n\tstruct nd_region_desc ndr_desc;\n\tstruct cxl_nvdimm *cxl_nvd;\n\tstruct nvdimm *nvdimm;\n\tstruct resource *res;\n\tint rc, i = 0;\n\n\tmemset(&mappings, 0, sizeof(mappings));\n\tmemset(&ndr_desc, 0, sizeof(ndr_desc));\n\n\tres = devm_kzalloc(dev, sizeof(*res), GFP_KERNEL);\n\tif (!res)\n\t\treturn -ENOMEM;\n\n\tres->name = \"Persistent Memory\";\n\tres->start = cxlr_pmem->hpa_range.start;\n\tres->end = cxlr_pmem->hpa_range.end;\n\tres->flags = IORESOURCE_MEM;\n\tres->desc = IORES_DESC_PERSISTENT_MEMORY;\n\n\trc = insert_resource(&iomem_resource, res);\n\tif (rc)\n\t\treturn rc;\n\n\trc = devm_add_action_or_reset(dev, cxlr_pmem_remove_resource, res);\n\tif (rc)\n\t\treturn rc;\n\n\tndr_desc.res = res;\n\tndr_desc.provider_data = cxlr_pmem;\n\n\tndr_desc.numa_node = memory_add_physaddr_to_nid(res->start);\n\tndr_desc.target_node = phys_to_target_node(res->start);\n\tif (ndr_desc.target_node == NUMA_NO_NODE) {\n\t\tndr_desc.target_node = ndr_desc.numa_node;\n\t\tdev_dbg(&cxlr->dev, \"changing target node from %d to %d\",\n\t\t\tNUMA_NO_NODE, ndr_desc.target_node);\n\t}\n\n\tnd_set = devm_kzalloc(dev, sizeof(*nd_set), GFP_KERNEL);\n\tif (!nd_set)\n\t\treturn -ENOMEM;\n\n\tndr_desc.memregion = cxlr->id;\n\tset_bit(ND_REGION_CXL, &ndr_desc.flags);\n\tset_bit(ND_REGION_PERSIST_MEMCTRL, &ndr_desc.flags);\n\n\tinfo = kmalloc_array(cxlr_pmem->nr_mappings, sizeof(*info), GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < cxlr_pmem->nr_mappings; i++) {\n\t\tstruct cxl_pmem_region_mapping *m = &cxlr_pmem->mapping[i];\n\t\tstruct cxl_memdev *cxlmd = m->cxlmd;\n\t\tstruct cxl_dev_state *cxlds = cxlmd->cxlds;\n\n\t\tcxl_nvd = cxlmd->cxl_nvd;\n\t\tnvdimm = dev_get_drvdata(&cxl_nvd->dev);\n\t\tif (!nvdimm) {\n\t\t\tdev_dbg(dev, \"[%d]: %s: no nvdimm found\\n\", i,\n\t\t\t\tdev_name(&cxlmd->dev));\n\t\t\trc = -ENODEV;\n\t\t\tgoto out_nvd;\n\t\t}\n\n\t\tm->cxl_nvd = cxl_nvd;\n\t\tmappings[i] = (struct nd_mapping_desc) {\n\t\t\t.nvdimm = nvdimm,\n\t\t\t.start = m->start,\n\t\t\t.size = m->size,\n\t\t\t.position = i,\n\t\t};\n\t\tinfo[i].offset = m->start;\n\t\tinfo[i].serial = cxlds->serial;\n\t}\n\tndr_desc.num_mappings = cxlr_pmem->nr_mappings;\n\tndr_desc.mapping = mappings;\n\n\t \n\tnd_set->cookie1 =\n\t\tnd_fletcher64(info, sizeof(*info) * cxlr_pmem->nr_mappings, 0);\n\tnd_set->cookie2 = nd_set->cookie1;\n\tndr_desc.nd_set = nd_set;\n\n\tcxlr_pmem->nd_region =\n\t\tnvdimm_pmem_region_create(cxl_nvb->nvdimm_bus, &ndr_desc);\n\tif (!cxlr_pmem->nd_region) {\n\t\trc = -ENOMEM;\n\t\tgoto out_nvd;\n\t}\n\n\trc = devm_add_action_or_reset(dev, unregister_nvdimm_region,\n\t\t\t\t      cxlr_pmem->nd_region);\nout_nvd:\n\tkfree(info);\n\n\treturn rc;\n}\n\nstatic struct cxl_driver cxl_pmem_region_driver = {\n\t.name = \"cxl_pmem_region\",\n\t.probe = cxl_pmem_region_probe,\n\t.id = CXL_DEVICE_PMEM_REGION,\n\t.drv = {\n\t\t.suppress_bind_attrs = true,\n\t},\n};\n\nstatic __init int cxl_pmem_init(void)\n{\n\tint rc;\n\n\tset_bit(CXL_MEM_COMMAND_ID_SET_SHUTDOWN_STATE, exclusive_cmds);\n\tset_bit(CXL_MEM_COMMAND_ID_SET_LSA, exclusive_cmds);\n\n\trc = cxl_driver_register(&cxl_nvdimm_bridge_driver);\n\tif (rc)\n\t\treturn rc;\n\n\trc = cxl_driver_register(&cxl_nvdimm_driver);\n\tif (rc)\n\t\tgoto err_nvdimm;\n\n\trc = cxl_driver_register(&cxl_pmem_region_driver);\n\tif (rc)\n\t\tgoto err_region;\n\n\treturn 0;\n\nerr_region:\n\tcxl_driver_unregister(&cxl_nvdimm_driver);\nerr_nvdimm:\n\tcxl_driver_unregister(&cxl_nvdimm_bridge_driver);\n\treturn rc;\n}\n\nstatic __exit void cxl_pmem_exit(void)\n{\n\tcxl_driver_unregister(&cxl_pmem_region_driver);\n\tcxl_driver_unregister(&cxl_nvdimm_driver);\n\tcxl_driver_unregister(&cxl_nvdimm_bridge_driver);\n}\n\nMODULE_LICENSE(\"GPL v2\");\nmodule_init(cxl_pmem_init);\nmodule_exit(cxl_pmem_exit);\nMODULE_IMPORT_NS(CXL);\nMODULE_ALIAS_CXL(CXL_DEVICE_NVDIMM_BRIDGE);\nMODULE_ALIAS_CXL(CXL_DEVICE_NVDIMM);\nMODULE_ALIAS_CXL(CXL_DEVICE_PMEM_REGION);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}