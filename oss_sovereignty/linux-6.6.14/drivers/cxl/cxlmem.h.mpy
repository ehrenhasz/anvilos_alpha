{
  "module_name": "cxlmem.h",
  "hash_id": "117edc820945b413fb73cf08ce988d57f5286f5742e7482b79093a45c9ba49a2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/cxl/cxlmem.h",
  "human_readable_source": " \n \n#ifndef __CXL_MEM_H__\n#define __CXL_MEM_H__\n#include <uapi/linux/cxl_mem.h>\n#include <linux/cdev.h>\n#include <linux/uuid.h>\n#include <linux/rcuwait.h>\n#include \"cxl.h\"\n\n \n#define CXLMDEV_STATUS_OFFSET 0x0\n#define   CXLMDEV_DEV_FATAL BIT(0)\n#define   CXLMDEV_FW_HALT BIT(1)\n#define   CXLMDEV_STATUS_MEDIA_STATUS_MASK GENMASK(3, 2)\n#define     CXLMDEV_MS_NOT_READY 0\n#define     CXLMDEV_MS_READY 1\n#define     CXLMDEV_MS_ERROR 2\n#define     CXLMDEV_MS_DISABLED 3\n#define CXLMDEV_READY(status)                                                  \\\n\t(FIELD_GET(CXLMDEV_STATUS_MEDIA_STATUS_MASK, status) ==                \\\n\t CXLMDEV_MS_READY)\n#define   CXLMDEV_MBOX_IF_READY BIT(4)\n#define   CXLMDEV_RESET_NEEDED_MASK GENMASK(7, 5)\n#define     CXLMDEV_RESET_NEEDED_NOT 0\n#define     CXLMDEV_RESET_NEEDED_COLD 1\n#define     CXLMDEV_RESET_NEEDED_WARM 2\n#define     CXLMDEV_RESET_NEEDED_HOT 3\n#define     CXLMDEV_RESET_NEEDED_CXL 4\n#define CXLMDEV_RESET_NEEDED(status)                                           \\\n\t(FIELD_GET(CXLMDEV_RESET_NEEDED_MASK, status) !=                       \\\n\t CXLMDEV_RESET_NEEDED_NOT)\n\n \nstruct cxl_memdev {\n\tstruct device dev;\n\tstruct cdev cdev;\n\tstruct cxl_dev_state *cxlds;\n\tstruct work_struct detach_work;\n\tstruct cxl_nvdimm_bridge *cxl_nvb;\n\tstruct cxl_nvdimm *cxl_nvd;\n\tstruct cxl_port *endpoint;\n\tint id;\n\tint depth;\n};\n\nstatic inline struct cxl_memdev *to_cxl_memdev(struct device *dev)\n{\n\treturn container_of(dev, struct cxl_memdev, dev);\n}\n\nstatic inline struct cxl_port *cxled_to_port(struct cxl_endpoint_decoder *cxled)\n{\n\treturn to_cxl_port(cxled->cxld.dev.parent);\n}\n\nstatic inline struct cxl_port *cxlrd_to_port(struct cxl_root_decoder *cxlrd)\n{\n\treturn to_cxl_port(cxlrd->cxlsd.cxld.dev.parent);\n}\n\nstatic inline struct cxl_memdev *\ncxled_to_memdev(struct cxl_endpoint_decoder *cxled)\n{\n\tstruct cxl_port *port = to_cxl_port(cxled->cxld.dev.parent);\n\n\treturn to_cxl_memdev(port->uport_dev);\n}\n\nbool is_cxl_memdev(const struct device *dev);\nstatic inline bool is_cxl_endpoint(struct cxl_port *port)\n{\n\treturn is_cxl_memdev(port->uport_dev);\n}\n\nstruct cxl_memdev *devm_cxl_add_memdev(struct device *host,\n\t\t\t\t       struct cxl_dev_state *cxlds);\nint devm_cxl_sanitize_setup_notifier(struct device *host,\n\t\t\t\t     struct cxl_memdev *cxlmd);\nstruct cxl_memdev_state;\nint devm_cxl_setup_fw_upload(struct device *host, struct cxl_memdev_state *mds);\nint devm_cxl_dpa_reserve(struct cxl_endpoint_decoder *cxled,\n\t\t\t resource_size_t base, resource_size_t len,\n\t\t\t resource_size_t skipped);\n\nstatic inline struct cxl_ep *cxl_ep_load(struct cxl_port *port,\n\t\t\t\t\t struct cxl_memdev *cxlmd)\n{\n\tif (!port)\n\t\treturn NULL;\n\n\treturn xa_load(&port->endpoints, (unsigned long)&cxlmd->dev);\n}\n\n \nstruct cxl_mbox_cmd {\n\tu16 opcode;\n\tvoid *payload_in;\n\tvoid *payload_out;\n\tsize_t size_in;\n\tsize_t size_out;\n\tsize_t min_out;\n\tint poll_count;\n\tint poll_interval_ms;\n\tu16 return_code;\n};\n\n \n#define CMD_CMD_RC_TABLE\t\t\t\t\t\t\t\\\n\tC(SUCCESS, 0, NULL),\t\t\t\t\t\t\t\\\n\tC(BACKGROUND, -ENXIO, \"background cmd started successfully\"),           \\\n\tC(INPUT, -ENXIO, \"cmd input was invalid\"),\t\t\t\t\\\n\tC(UNSUPPORTED, -ENXIO, \"cmd is not supported\"),\t\t\t\t\\\n\tC(INTERNAL, -ENXIO, \"internal device error\"),\t\t\t\t\\\n\tC(RETRY, -ENXIO, \"temporary error, retry once\"),\t\t\t\\\n\tC(BUSY, -ENXIO, \"ongoing background operation\"),\t\t\t\\\n\tC(MEDIADISABLED, -ENXIO, \"media access is disabled\"),\t\t\t\\\n\tC(FWINPROGRESS, -ENXIO,\t\"one FW package can be transferred at a time\"), \\\n\tC(FWOOO, -ENXIO, \"FW package content was transferred out of order\"),    \\\n\tC(FWAUTH, -ENXIO, \"FW package authentication failed\"),\t\t\t\\\n\tC(FWSLOT, -ENXIO, \"FW slot is not supported for requested operation\"),  \\\n\tC(FWROLLBACK, -ENXIO, \"rolled back to the previous active FW\"),         \\\n\tC(FWRESET, -ENXIO, \"FW failed to activate, needs cold reset\"),\t\t\\\n\tC(HANDLE, -ENXIO, \"one or more Event Record Handles were invalid\"),     \\\n\tC(PADDR, -EFAULT, \"physical address specified is invalid\"),\t\t\\\n\tC(POISONLMT, -ENXIO, \"poison injection limit has been reached\"),        \\\n\tC(MEDIAFAILURE, -ENXIO, \"permanent issue with the media\"),\t\t\\\n\tC(ABORT, -ENXIO, \"background cmd was aborted by device\"),               \\\n\tC(SECURITY, -ENXIO, \"not valid in the current security state\"),         \\\n\tC(PASSPHRASE, -ENXIO, \"phrase doesn't match current set passphrase\"),   \\\n\tC(MBUNSUPPORTED, -ENXIO, \"unsupported on the mailbox it was issued on\"),\\\n\tC(PAYLOADLEN, -ENXIO, \"invalid payload length\"),\t\t\t\\\n\tC(LOG, -ENXIO, \"invalid or unsupported log page\"),\t\t\t\\\n\tC(INTERRUPTED, -ENXIO, \"asynchronous event occured\"),\t\t\t\\\n\tC(FEATUREVERSION, -ENXIO, \"unsupported feature version\"),\t\t\\\n\tC(FEATURESELVALUE, -ENXIO, \"unsupported feature selection value\"),\t\\\n\tC(FEATURETRANSFERIP, -ENXIO, \"feature transfer in progress\"),\t\t\\\n\tC(FEATURETRANSFEROOO, -ENXIO, \"feature transfer out of order\"),\t\t\\\n\tC(RESOURCEEXHAUSTED, -ENXIO, \"resources are exhausted\"),\t\t\\\n\tC(EXTLIST, -ENXIO, \"invalid Extent List\"),\t\t\t\t\\\n\n#undef C\n#define C(a, b, c) CXL_MBOX_CMD_RC_##a\nenum  { CMD_CMD_RC_TABLE };\n#undef C\n#define C(a, b, c) { b, c }\nstruct cxl_mbox_cmd_rc {\n\tint err;\n\tconst char *desc;\n};\n\nstatic const\nstruct cxl_mbox_cmd_rc cxl_mbox_cmd_rctable[] ={ CMD_CMD_RC_TABLE };\n#undef C\n\nstatic inline const char *cxl_mbox_cmd_rc2str(struct cxl_mbox_cmd *mbox_cmd)\n{\n\treturn cxl_mbox_cmd_rctable[mbox_cmd->return_code].desc;\n}\n\nstatic inline int cxl_mbox_cmd_rc2errno(struct cxl_mbox_cmd *mbox_cmd)\n{\n\treturn cxl_mbox_cmd_rctable[mbox_cmd->return_code].err;\n}\n\n \n#define CXL_CAPACITY_MULTIPLIER SZ_256M\n\n \nenum cxl_event_int_mode {\n\tCXL_INT_NONE\t\t= 0x00,\n\tCXL_INT_MSI_MSIX\t= 0x01,\n\tCXL_INT_FW\t\t= 0x02\n};\nstruct cxl_event_interrupt_policy {\n\tu8 info_settings;\n\tu8 warn_settings;\n\tu8 failure_settings;\n\tu8 fatal_settings;\n} __packed;\n\n \nstruct cxl_event_state {\n\tstruct cxl_get_event_payload *buf;\n\tstruct mutex log_lock;\n};\n\n \nenum poison_cmd_enabled_bits {\n\tCXL_POISON_ENABLED_LIST,\n\tCXL_POISON_ENABLED_INJECT,\n\tCXL_POISON_ENABLED_CLEAR,\n\tCXL_POISON_ENABLED_SCAN_CAPS,\n\tCXL_POISON_ENABLED_SCAN_MEDIA,\n\tCXL_POISON_ENABLED_SCAN_RESULTS,\n\tCXL_POISON_ENABLED_MAX\n};\n\n \nenum security_cmd_enabled_bits {\n\tCXL_SEC_ENABLED_SANITIZE,\n\tCXL_SEC_ENABLED_SECURE_ERASE,\n\tCXL_SEC_ENABLED_GET_SECURITY_STATE,\n\tCXL_SEC_ENABLED_SET_PASSPHRASE,\n\tCXL_SEC_ENABLED_DISABLE_PASSPHRASE,\n\tCXL_SEC_ENABLED_UNLOCK,\n\tCXL_SEC_ENABLED_FREEZE_SECURITY,\n\tCXL_SEC_ENABLED_PASSPHRASE_SECURE_ERASE,\n\tCXL_SEC_ENABLED_MAX\n};\n\n \nstruct cxl_poison_state {\n\tu32 max_errors;\n\tDECLARE_BITMAP(enabled_cmds, CXL_POISON_ENABLED_MAX);\n\tstruct cxl_mbox_poison_out *list_out;\n\tstruct mutex lock;   \n};\n\n \nstruct cxl_mbox_get_fw_info {\n\tu8 num_slots;\n\tu8 slot_info;\n\tu8 activation_cap;\n\tu8 reserved[13];\n\tchar slot_1_revision[16];\n\tchar slot_2_revision[16];\n\tchar slot_3_revision[16];\n\tchar slot_4_revision[16];\n} __packed;\n\n#define CXL_FW_INFO_SLOT_INFO_CUR_MASK\t\t\tGENMASK(2, 0)\n#define CXL_FW_INFO_SLOT_INFO_NEXT_MASK\t\t\tGENMASK(5, 3)\n#define CXL_FW_INFO_SLOT_INFO_NEXT_SHIFT\t\t3\n#define CXL_FW_INFO_ACTIVATION_CAP_HAS_LIVE_ACTIVATE\tBIT(0)\n\n \nstruct cxl_mbox_transfer_fw {\n\tu8 action;\n\tu8 slot;\n\tu8 reserved[2];\n\t__le32 offset;\n\tu8 reserved2[0x78];\n\tu8 data[];\n} __packed;\n\n#define CXL_FW_TRANSFER_ACTION_FULL\t0x0\n#define CXL_FW_TRANSFER_ACTION_INITIATE\t0x1\n#define CXL_FW_TRANSFER_ACTION_CONTINUE\t0x2\n#define CXL_FW_TRANSFER_ACTION_END\t0x3\n#define CXL_FW_TRANSFER_ACTION_ABORT\t0x4\n\n \n#define CXL_FW_TRANSFER_ALIGNMENT\t128\n\n \nstruct cxl_mbox_activate_fw {\n\tu8 action;\n\tu8 slot;\n} __packed;\n\n#define CXL_FW_ACTIVATE_ONLINE\t\t0x0\n#define CXL_FW_ACTIVATE_OFFLINE\t\t0x1\n\n \n#define CXL_FW_STATE_BITS\t\t32\n#define CXL_FW_CANCEL\t\t\t0\n\n \nstruct cxl_fw_state {\n\tDECLARE_BITMAP(state, CXL_FW_STATE_BITS);\n\tbool oneshot;\n\tint num_slots;\n\tint cur_slot;\n\tint next_slot;\n};\n\n \nstruct cxl_security_state {\n\tunsigned long state;\n\tDECLARE_BITMAP(enabled_cmds, CXL_SEC_ENABLED_MAX);\n\tint poll_tmo_secs;\n\tbool sanitize_active;\n\tstruct delayed_work poll_dwork;\n\tstruct kernfs_node *sanitize_node;\n};\n\n \nenum cxl_devtype {\n\tCXL_DEVTYPE_DEVMEM,\n\tCXL_DEVTYPE_CLASSMEM,\n};\n\n \nstruct cxl_dev_state {\n\tstruct device *dev;\n\tstruct cxl_memdev *cxlmd;\n\tstruct cxl_regs regs;\n\tint cxl_dvsec;\n\tbool rcd;\n\tbool media_ready;\n\tstruct resource dpa_res;\n\tstruct resource pmem_res;\n\tstruct resource ram_res;\n\tresource_size_t component_reg_phys;\n\tu64 serial;\n\tenum cxl_devtype type;\n};\n\n \nstruct cxl_memdev_state {\n\tstruct cxl_dev_state cxlds;\n\tsize_t payload_size;\n\tsize_t lsa_size;\n\tstruct mutex mbox_mutex;  \n\tchar firmware_version[0x10];\n\tDECLARE_BITMAP(enabled_cmds, CXL_MEM_COMMAND_ID_MAX);\n\tDECLARE_BITMAP(exclusive_cmds, CXL_MEM_COMMAND_ID_MAX);\n\tu64 total_bytes;\n\tu64 volatile_only_bytes;\n\tu64 persistent_only_bytes;\n\tu64 partition_align_bytes;\n\tu64 active_volatile_bytes;\n\tu64 active_persistent_bytes;\n\tu64 next_volatile_bytes;\n\tu64 next_persistent_bytes;\n\tstruct cxl_event_state event;\n\tstruct cxl_poison_state poison;\n\tstruct cxl_security_state security;\n\tstruct cxl_fw_state fw;\n\n\tstruct rcuwait mbox_wait;\n\tint (*mbox_send)(struct cxl_memdev_state *mds,\n\t\t\t struct cxl_mbox_cmd *cmd);\n};\n\nstatic inline struct cxl_memdev_state *\nto_cxl_memdev_state(struct cxl_dev_state *cxlds)\n{\n\tif (cxlds->type != CXL_DEVTYPE_CLASSMEM)\n\t\treturn NULL;\n\treturn container_of(cxlds, struct cxl_memdev_state, cxlds);\n}\n\nenum cxl_opcode {\n\tCXL_MBOX_OP_INVALID\t\t= 0x0000,\n\tCXL_MBOX_OP_RAW\t\t\t= CXL_MBOX_OP_INVALID,\n\tCXL_MBOX_OP_GET_EVENT_RECORD\t= 0x0100,\n\tCXL_MBOX_OP_CLEAR_EVENT_RECORD\t= 0x0101,\n\tCXL_MBOX_OP_GET_EVT_INT_POLICY\t= 0x0102,\n\tCXL_MBOX_OP_SET_EVT_INT_POLICY\t= 0x0103,\n\tCXL_MBOX_OP_GET_FW_INFO\t\t= 0x0200,\n\tCXL_MBOX_OP_TRANSFER_FW\t\t= 0x0201,\n\tCXL_MBOX_OP_ACTIVATE_FW\t\t= 0x0202,\n\tCXL_MBOX_OP_SET_TIMESTAMP\t= 0x0301,\n\tCXL_MBOX_OP_GET_SUPPORTED_LOGS\t= 0x0400,\n\tCXL_MBOX_OP_GET_LOG\t\t= 0x0401,\n\tCXL_MBOX_OP_IDENTIFY\t\t= 0x4000,\n\tCXL_MBOX_OP_GET_PARTITION_INFO\t= 0x4100,\n\tCXL_MBOX_OP_SET_PARTITION_INFO\t= 0x4101,\n\tCXL_MBOX_OP_GET_LSA\t\t= 0x4102,\n\tCXL_MBOX_OP_SET_LSA\t\t= 0x4103,\n\tCXL_MBOX_OP_GET_HEALTH_INFO\t= 0x4200,\n\tCXL_MBOX_OP_GET_ALERT_CONFIG\t= 0x4201,\n\tCXL_MBOX_OP_SET_ALERT_CONFIG\t= 0x4202,\n\tCXL_MBOX_OP_GET_SHUTDOWN_STATE\t= 0x4203,\n\tCXL_MBOX_OP_SET_SHUTDOWN_STATE\t= 0x4204,\n\tCXL_MBOX_OP_GET_POISON\t\t= 0x4300,\n\tCXL_MBOX_OP_INJECT_POISON\t= 0x4301,\n\tCXL_MBOX_OP_CLEAR_POISON\t= 0x4302,\n\tCXL_MBOX_OP_GET_SCAN_MEDIA_CAPS\t= 0x4303,\n\tCXL_MBOX_OP_SCAN_MEDIA\t\t= 0x4304,\n\tCXL_MBOX_OP_GET_SCAN_MEDIA\t= 0x4305,\n\tCXL_MBOX_OP_SANITIZE\t\t= 0x4400,\n\tCXL_MBOX_OP_SECURE_ERASE\t= 0x4401,\n\tCXL_MBOX_OP_GET_SECURITY_STATE\t= 0x4500,\n\tCXL_MBOX_OP_SET_PASSPHRASE\t= 0x4501,\n\tCXL_MBOX_OP_DISABLE_PASSPHRASE\t= 0x4502,\n\tCXL_MBOX_OP_UNLOCK\t\t= 0x4503,\n\tCXL_MBOX_OP_FREEZE_SECURITY\t= 0x4504,\n\tCXL_MBOX_OP_PASSPHRASE_SECURE_ERASE\t= 0x4505,\n\tCXL_MBOX_OP_MAX\t\t\t= 0x10000\n};\n\n#define DEFINE_CXL_CEL_UUID                                                    \\\n\tUUID_INIT(0xda9c0b5, 0xbf41, 0x4b78, 0x8f, 0x79, 0x96, 0xb1, 0x62,     \\\n\t\t  0x3b, 0x3f, 0x17)\n\n#define DEFINE_CXL_VENDOR_DEBUG_UUID                                           \\\n\tUUID_INIT(0xe1819d9, 0x11a9, 0x400c, 0x81, 0x1f, 0xd6, 0x07, 0x19,     \\\n\t\t  0x40, 0x3d, 0x86)\n\nstruct cxl_mbox_get_supported_logs {\n\t__le16 entries;\n\tu8 rsvd[6];\n\tstruct cxl_gsl_entry {\n\t\tuuid_t uuid;\n\t\t__le32 size;\n\t} __packed entry[];\n}  __packed;\n\nstruct cxl_cel_entry {\n\t__le16 opcode;\n\t__le16 effect;\n} __packed;\n\nstruct cxl_mbox_get_log {\n\tuuid_t uuid;\n\t__le32 offset;\n\t__le32 length;\n} __packed;\n\n \nstruct cxl_mbox_identify {\n\tchar fw_revision[0x10];\n\t__le64 total_capacity;\n\t__le64 volatile_capacity;\n\t__le64 persistent_capacity;\n\t__le64 partition_align;\n\t__le16 info_event_log_size;\n\t__le16 warning_event_log_size;\n\t__le16 failure_event_log_size;\n\t__le16 fatal_event_log_size;\n\t__le32 lsa_size;\n\tu8 poison_list_max_mer[3];\n\t__le16 inject_poison_limit;\n\tu8 poison_caps;\n\tu8 qos_telemetry_caps;\n} __packed;\n\n \nstruct cxl_event_record_hdr {\n\tuuid_t id;\n\tu8 length;\n\tu8 flags[3];\n\t__le16 handle;\n\t__le16 related_handle;\n\t__le64 timestamp;\n\tu8 maint_op_class;\n\tu8 reserved[15];\n} __packed;\n\n#define CXL_EVENT_RECORD_DATA_LENGTH 0x50\nstruct cxl_event_record_raw {\n\tstruct cxl_event_record_hdr hdr;\n\tu8 data[CXL_EVENT_RECORD_DATA_LENGTH];\n} __packed;\n\n \n#define CXL_GET_EVENT_FLAG_OVERFLOW\t\tBIT(0)\n#define CXL_GET_EVENT_FLAG_MORE_RECORDS\t\tBIT(1)\nstruct cxl_get_event_payload {\n\tu8 flags;\n\tu8 reserved1;\n\t__le16 overflow_err_count;\n\t__le64 first_overflow_timestamp;\n\t__le64 last_overflow_timestamp;\n\t__le16 record_count;\n\tu8 reserved2[10];\n\tstruct cxl_event_record_raw records[];\n} __packed;\n\n \nenum cxl_event_log_type {\n\tCXL_EVENT_TYPE_INFO = 0x00,\n\tCXL_EVENT_TYPE_WARN,\n\tCXL_EVENT_TYPE_FAIL,\n\tCXL_EVENT_TYPE_FATAL,\n\tCXL_EVENT_TYPE_MAX\n};\n\n \nstruct cxl_mbox_clear_event_payload {\n\tu8 event_log;\t\t \n\tu8 clear_flags;\n\tu8 nr_recs;\n\tu8 reserved[3];\n\t__le16 handles[];\n} __packed;\n#define CXL_CLEAR_EVENT_MAX_HANDLES U8_MAX\n\n \n#define CXL_EVENT_GEN_MED_COMP_ID_SIZE\t0x10\nstruct cxl_event_gen_media {\n\tstruct cxl_event_record_hdr hdr;\n\t__le64 phys_addr;\n\tu8 descriptor;\n\tu8 type;\n\tu8 transaction_type;\n\tu8 validity_flags[2];\n\tu8 channel;\n\tu8 rank;\n\tu8 device[3];\n\tu8 component_id[CXL_EVENT_GEN_MED_COMP_ID_SIZE];\n\tu8 reserved[46];\n} __packed;\n\n \n#define CXL_EVENT_DER_CORRECTION_MASK_SIZE\t0x20\nstruct cxl_event_dram {\n\tstruct cxl_event_record_hdr hdr;\n\t__le64 phys_addr;\n\tu8 descriptor;\n\tu8 type;\n\tu8 transaction_type;\n\tu8 validity_flags[2];\n\tu8 channel;\n\tu8 rank;\n\tu8 nibble_mask[3];\n\tu8 bank_group;\n\tu8 bank;\n\tu8 row[3];\n\tu8 column[2];\n\tu8 correction_mask[CXL_EVENT_DER_CORRECTION_MASK_SIZE];\n\tu8 reserved[0x17];\n} __packed;\n\n \nstruct cxl_get_health_info {\n\tu8 health_status;\n\tu8 media_status;\n\tu8 add_status;\n\tu8 life_used;\n\tu8 device_temp[2];\n\tu8 dirty_shutdown_cnt[4];\n\tu8 cor_vol_err_cnt[4];\n\tu8 cor_per_err_cnt[4];\n} __packed;\n\n \nstruct cxl_event_mem_module {\n\tstruct cxl_event_record_hdr hdr;\n\tu8 event_type;\n\tstruct cxl_get_health_info info;\n\tu8 reserved[0x3d];\n} __packed;\n\nstruct cxl_mbox_get_partition_info {\n\t__le64 active_volatile_cap;\n\t__le64 active_persistent_cap;\n\t__le64 next_volatile_cap;\n\t__le64 next_persistent_cap;\n} __packed;\n\nstruct cxl_mbox_get_lsa {\n\t__le32 offset;\n\t__le32 length;\n} __packed;\n\nstruct cxl_mbox_set_lsa {\n\t__le32 offset;\n\t__le32 reserved;\n\tu8 data[];\n} __packed;\n\nstruct cxl_mbox_set_partition_info {\n\t__le64 volatile_capacity;\n\tu8 flags;\n} __packed;\n\n#define  CXL_SET_PARTITION_IMMEDIATE_FLAG\tBIT(0)\n\n \nstruct cxl_mbox_set_timestamp_in {\n\t__le64 timestamp;\n\n} __packed;\n\n \nstruct cxl_mbox_poison_in {\n\t__le64 offset;\n\t__le64 length;\n} __packed;\n\nstruct cxl_mbox_poison_out {\n\tu8 flags;\n\tu8 rsvd1;\n\t__le64 overflow_ts;\n\t__le16 count;\n\tu8 rsvd2[20];\n\tstruct cxl_poison_record {\n\t\t__le64 address;\n\t\t__le32 length;\n\t\t__le32 rsvd;\n\t} __packed record[];\n} __packed;\n\n \n#define CXL_POISON_START_MASK\t\tGENMASK_ULL(63, 6)\n#define CXL_POISON_SOURCE_MASK\t\tGENMASK(2, 0)\n\n \n#define CXL_POISON_LEN_MULT\t64\n\n \n#define CXL_POISON_LIST_MAX\t1024\n\n \n#define CXL_POISON_FLAG_MORE            BIT(0)\n#define CXL_POISON_FLAG_OVERFLOW        BIT(1)\n#define CXL_POISON_FLAG_SCANNING        BIT(2)\n\n \n#define CXL_POISON_SOURCE_UNKNOWN\t0\n#define CXL_POISON_SOURCE_EXTERNAL\t1\n#define CXL_POISON_SOURCE_INTERNAL\t2\n#define CXL_POISON_SOURCE_INJECTED\t3\n#define CXL_POISON_SOURCE_VENDOR\t7\n\n \nstruct cxl_mbox_inject_poison {\n\t__le64 address;\n};\n\n \nstruct cxl_mbox_clear_poison {\n\t__le64 address;\n\tu8 write_data[CXL_POISON_LEN_MULT];\n} __packed;\n\n \nstruct cxl_mem_command {\n\tstruct cxl_command_info info;\n\tenum cxl_opcode opcode;\n\tu32 flags;\n#define CXL_CMD_FLAG_FORCE_ENABLE BIT(0)\n};\n\n#define CXL_PMEM_SEC_STATE_USER_PASS_SET\t0x01\n#define CXL_PMEM_SEC_STATE_MASTER_PASS_SET\t0x02\n#define CXL_PMEM_SEC_STATE_LOCKED\t\t0x04\n#define CXL_PMEM_SEC_STATE_FROZEN\t\t0x08\n#define CXL_PMEM_SEC_STATE_USER_PLIMIT\t\t0x10\n#define CXL_PMEM_SEC_STATE_MASTER_PLIMIT\t0x20\n\n \nstruct cxl_set_pass {\n\tu8 type;\n\tu8 reserved[31];\n\t \n\tu8 old_pass[NVDIMM_PASSPHRASE_LEN];\n\tu8 new_pass[NVDIMM_PASSPHRASE_LEN];\n} __packed;\n\n \nstruct cxl_disable_pass {\n\tu8 type;\n\tu8 reserved[31];\n\tu8 pass[NVDIMM_PASSPHRASE_LEN];\n} __packed;\n\n \nstruct cxl_pass_erase {\n\tu8 type;\n\tu8 reserved[31];\n\tu8 pass[NVDIMM_PASSPHRASE_LEN];\n} __packed;\n\nenum {\n\tCXL_PMEM_SEC_PASS_MASTER = 0,\n\tCXL_PMEM_SEC_PASS_USER,\n};\n\nint cxl_internal_send_cmd(struct cxl_memdev_state *mds,\n\t\t\t  struct cxl_mbox_cmd *cmd);\nint cxl_dev_state_identify(struct cxl_memdev_state *mds);\nint cxl_await_media_ready(struct cxl_dev_state *cxlds);\nint cxl_enumerate_cmds(struct cxl_memdev_state *mds);\nint cxl_mem_create_range_info(struct cxl_memdev_state *mds);\nstruct cxl_memdev_state *cxl_memdev_state_create(struct device *dev);\nvoid set_exclusive_cxl_commands(struct cxl_memdev_state *mds,\n\t\t\t\tunsigned long *cmds);\nvoid clear_exclusive_cxl_commands(struct cxl_memdev_state *mds,\n\t\t\t\t  unsigned long *cmds);\nvoid cxl_mem_get_event_records(struct cxl_memdev_state *mds, u32 status);\nint cxl_set_timestamp(struct cxl_memdev_state *mds);\nint cxl_poison_state_init(struct cxl_memdev_state *mds);\nint cxl_mem_get_poison(struct cxl_memdev *cxlmd, u64 offset, u64 len,\n\t\t       struct cxl_region *cxlr);\nint cxl_trigger_poison_list(struct cxl_memdev *cxlmd);\nint cxl_inject_poison(struct cxl_memdev *cxlmd, u64 dpa);\nint cxl_clear_poison(struct cxl_memdev *cxlmd, u64 dpa);\n\n#ifdef CONFIG_CXL_SUSPEND\nvoid cxl_mem_active_inc(void);\nvoid cxl_mem_active_dec(void);\n#else\nstatic inline void cxl_mem_active_inc(void)\n{\n}\nstatic inline void cxl_mem_active_dec(void)\n{\n}\n#endif\n\nint cxl_mem_sanitize(struct cxl_memdev *cxlmd, u16 cmd);\n\nstruct cxl_hdm {\n\tstruct cxl_component_regs regs;\n\tunsigned int decoder_count;\n\tunsigned int target_count;\n\tunsigned int interleave_mask;\n\tstruct cxl_port *port;\n};\n\nstruct seq_file;\nstruct dentry *cxl_debugfs_create_dir(const char *dir);\nvoid cxl_dpa_debug(struct seq_file *file, struct cxl_dev_state *cxlds);\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}