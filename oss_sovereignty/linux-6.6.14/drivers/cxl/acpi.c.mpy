{
  "module_name": "acpi.c",
  "hash_id": "a5df31e9559af4573d58feff8552c26fb484114863ef1705c2b22c8f8a3c4699",
  "original_prompt": "Ingested from linux-6.6.14/drivers/cxl/acpi.c",
  "human_readable_source": "\n \n#include <linux/platform_device.h>\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/acpi.h>\n#include <linux/pci.h>\n#include <asm/div64.h>\n#include \"cxlpci.h\"\n#include \"cxl.h\"\n\n#define CXL_RCRB_SIZE\tSZ_8K\n\nstruct cxl_cxims_data {\n\tint nr_maps;\n\tu64 xormaps[] __counted_by(nr_maps);\n};\n\n \nstatic int cxl_xor_calc_n(u64 hpa, struct cxl_cxims_data *cximsd, int iw,\n\t\t\t  int ig)\n{\n\tint i = 0, n = 0;\n\tu8 eiw;\n\n\t \n\tif (iw != 3) {\n\t\tfor (i = 0; i < cximsd->nr_maps; i++)\n\t\t\tn |= (hweight64(hpa & cximsd->xormaps[i]) & 1) << i;\n\t}\n\t \n\tif (!is_power_of_2(iw)) {\n\t\tif (ways_to_eiw(iw, &eiw))\n\t\t\treturn -1;\n\t\thpa &= GENMASK_ULL(51, eiw + ig);\n\t\tn |= do_div(hpa, 3) << i;\n\t}\n\treturn n;\n}\n\nstatic struct cxl_dport *cxl_hb_xor(struct cxl_root_decoder *cxlrd, int pos)\n{\n\tstruct cxl_cxims_data *cximsd = cxlrd->platform_data;\n\tstruct cxl_switch_decoder *cxlsd = &cxlrd->cxlsd;\n\tstruct cxl_decoder *cxld = &cxlsd->cxld;\n\tint ig = cxld->interleave_granularity;\n\tint iw = cxld->interleave_ways;\n\tint n = 0;\n\tu64 hpa;\n\n\tif (dev_WARN_ONCE(&cxld->dev,\n\t\t\t  cxld->interleave_ways != cxlsd->nr_targets,\n\t\t\t  \"misconfigured root decoder\\n\"))\n\t\treturn NULL;\n\n\thpa = cxlrd->res->start + pos * ig;\n\n\t \n\tif (iw != 1)\n\t\tn = cxl_xor_calc_n(hpa, cximsd, iw, ig);\n\n\tif (n < 0)\n\t\treturn NULL;\n\n\treturn cxlrd->cxlsd.target[n];\n}\n\nstruct cxl_cxims_context {\n\tstruct device *dev;\n\tstruct cxl_root_decoder *cxlrd;\n};\n\nstatic int cxl_parse_cxims(union acpi_subtable_headers *header, void *arg,\n\t\t\t   const unsigned long end)\n{\n\tstruct acpi_cedt_cxims *cxims = (struct acpi_cedt_cxims *)header;\n\tstruct cxl_cxims_context *ctx = arg;\n\tstruct cxl_root_decoder *cxlrd = ctx->cxlrd;\n\tstruct cxl_decoder *cxld = &cxlrd->cxlsd.cxld;\n\tstruct device *dev = ctx->dev;\n\tstruct cxl_cxims_data *cximsd;\n\tunsigned int hbig, nr_maps;\n\tint rc;\n\n\trc = eig_to_granularity(cxims->hbig, &hbig);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tif (hbig != cxld->interleave_granularity)\n\t\treturn 0;\n\n\t \n\tif (is_power_of_2(cxld->interleave_ways))\n\t\t \n\t\tnr_maps = ilog2(cxld->interleave_ways);\n\telse\n\t\t \n\t\tnr_maps = ilog2(cxld->interleave_ways / 3);\n\n\tif (cxims->nr_xormaps < nr_maps) {\n\t\tdev_dbg(dev, \"CXIMS nr_xormaps[%d] expected[%d]\\n\",\n\t\t\tcxims->nr_xormaps, nr_maps);\n\t\treturn -ENXIO;\n\t}\n\n\tcximsd = devm_kzalloc(dev, struct_size(cximsd, xormaps, nr_maps),\n\t\t\t      GFP_KERNEL);\n\tif (!cximsd)\n\t\treturn -ENOMEM;\n\tcximsd->nr_maps = nr_maps;\n\tmemcpy(cximsd->xormaps, cxims->xormap_list,\n\t       nr_maps * sizeof(*cximsd->xormaps));\n\tcxlrd->platform_data = cximsd;\n\n\treturn 0;\n}\n\nstatic unsigned long cfmws_to_decoder_flags(int restrictions)\n{\n\tunsigned long flags = CXL_DECODER_F_ENABLE;\n\n\tif (restrictions & ACPI_CEDT_CFMWS_RESTRICT_TYPE2)\n\t\tflags |= CXL_DECODER_F_TYPE2;\n\tif (restrictions & ACPI_CEDT_CFMWS_RESTRICT_TYPE3)\n\t\tflags |= CXL_DECODER_F_TYPE3;\n\tif (restrictions & ACPI_CEDT_CFMWS_RESTRICT_VOLATILE)\n\t\tflags |= CXL_DECODER_F_RAM;\n\tif (restrictions & ACPI_CEDT_CFMWS_RESTRICT_PMEM)\n\t\tflags |= CXL_DECODER_F_PMEM;\n\tif (restrictions & ACPI_CEDT_CFMWS_RESTRICT_FIXED)\n\t\tflags |= CXL_DECODER_F_LOCK;\n\n\treturn flags;\n}\n\nstatic int cxl_acpi_cfmws_verify(struct device *dev,\n\t\t\t\t struct acpi_cedt_cfmws *cfmws)\n{\n\tint rc, expected_len;\n\tunsigned int ways;\n\n\tif (cfmws->interleave_arithmetic != ACPI_CEDT_CFMWS_ARITHMETIC_MODULO &&\n\t    cfmws->interleave_arithmetic != ACPI_CEDT_CFMWS_ARITHMETIC_XOR) {\n\t\tdev_err(dev, \"CFMWS Unknown Interleave Arithmetic: %d\\n\",\n\t\t\tcfmws->interleave_arithmetic);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!IS_ALIGNED(cfmws->base_hpa, SZ_256M)) {\n\t\tdev_err(dev, \"CFMWS Base HPA not 256MB aligned\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!IS_ALIGNED(cfmws->window_size, SZ_256M)) {\n\t\tdev_err(dev, \"CFMWS Window Size not 256MB aligned\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\trc = eiw_to_ways(cfmws->interleave_ways, &ways);\n\tif (rc) {\n\t\tdev_err(dev, \"CFMWS Interleave Ways (%d) invalid\\n\",\n\t\t\tcfmws->interleave_ways);\n\t\treturn -EINVAL;\n\t}\n\n\texpected_len = struct_size(cfmws, interleave_targets, ways);\n\n\tif (cfmws->header.length < expected_len) {\n\t\tdev_err(dev, \"CFMWS length %d less than expected %d\\n\",\n\t\t\tcfmws->header.length, expected_len);\n\t\treturn -EINVAL;\n\t}\n\n\tif (cfmws->header.length > expected_len)\n\t\tdev_dbg(dev, \"CFMWS length %d greater than expected %d\\n\",\n\t\t\tcfmws->header.length, expected_len);\n\n\treturn 0;\n}\n\n \nstruct cxl_cfmws_context {\n\tstruct device *dev;\n\tstruct cxl_port *root_port;\n\tstruct resource *cxl_res;\n\tint id;\n};\n\nstatic int cxl_parse_cfmws(union acpi_subtable_headers *header, void *arg,\n\t\t\t   const unsigned long end)\n{\n\tint target_map[CXL_DECODER_MAX_INTERLEAVE];\n\tstruct cxl_cfmws_context *ctx = arg;\n\tstruct cxl_port *root_port = ctx->root_port;\n\tstruct resource *cxl_res = ctx->cxl_res;\n\tstruct cxl_cxims_context cxims_ctx;\n\tstruct cxl_root_decoder *cxlrd;\n\tstruct device *dev = ctx->dev;\n\tstruct acpi_cedt_cfmws *cfmws;\n\tcxl_calc_hb_fn cxl_calc_hb;\n\tstruct cxl_decoder *cxld;\n\tunsigned int ways, i, ig;\n\tstruct resource *res;\n\tint rc;\n\n\tcfmws = (struct acpi_cedt_cfmws *) header;\n\n\trc = cxl_acpi_cfmws_verify(dev, cfmws);\n\tif (rc) {\n\t\tdev_err(dev, \"CFMWS range %#llx-%#llx not registered\\n\",\n\t\t\tcfmws->base_hpa,\n\t\t\tcfmws->base_hpa + cfmws->window_size - 1);\n\t\treturn 0;\n\t}\n\n\trc = eiw_to_ways(cfmws->interleave_ways, &ways);\n\tif (rc)\n\t\treturn rc;\n\trc = eig_to_granularity(cfmws->granularity, &ig);\n\tif (rc)\n\t\treturn rc;\n\tfor (i = 0; i < ways; i++)\n\t\ttarget_map[i] = cfmws->interleave_targets[i];\n\n\tres = kzalloc(sizeof(*res), GFP_KERNEL);\n\tif (!res)\n\t\treturn -ENOMEM;\n\n\tres->name = kasprintf(GFP_KERNEL, \"CXL Window %d\", ctx->id++);\n\tif (!res->name)\n\t\tgoto err_name;\n\n\tres->start = cfmws->base_hpa;\n\tres->end = cfmws->base_hpa + cfmws->window_size - 1;\n\tres->flags = IORESOURCE_MEM;\n\n\t \n\trc = insert_resource(cxl_res, res);\n\tif (rc)\n\t\tgoto err_insert;\n\n\tif (cfmws->interleave_arithmetic == ACPI_CEDT_CFMWS_ARITHMETIC_MODULO)\n\t\tcxl_calc_hb = cxl_hb_modulo;\n\telse\n\t\tcxl_calc_hb = cxl_hb_xor;\n\n\tcxlrd = cxl_root_decoder_alloc(root_port, ways, cxl_calc_hb);\n\tif (IS_ERR(cxlrd))\n\t\treturn 0;\n\n\tcxld = &cxlrd->cxlsd.cxld;\n\tcxld->flags = cfmws_to_decoder_flags(cfmws->restrictions);\n\tcxld->target_type = CXL_DECODER_HOSTONLYMEM;\n\tcxld->hpa_range = (struct range) {\n\t\t.start = res->start,\n\t\t.end = res->end,\n\t};\n\tcxld->interleave_ways = ways;\n\t \n\tif (ways == 1)\n\t\tig = CXL_DECODER_MIN_GRANULARITY;\n\tcxld->interleave_granularity = ig;\n\n\tif (cfmws->interleave_arithmetic == ACPI_CEDT_CFMWS_ARITHMETIC_XOR) {\n\t\tif (ways != 1 && ways != 3) {\n\t\t\tcxims_ctx = (struct cxl_cxims_context) {\n\t\t\t\t.dev = dev,\n\t\t\t\t.cxlrd = cxlrd,\n\t\t\t};\n\t\t\trc = acpi_table_parse_cedt(ACPI_CEDT_TYPE_CXIMS,\n\t\t\t\t\t\t   cxl_parse_cxims, &cxims_ctx);\n\t\t\tif (rc < 0)\n\t\t\t\tgoto err_xormap;\n\t\t\tif (!cxlrd->platform_data) {\n\t\t\t\tdev_err(dev, \"No CXIMS for HBIG %u\\n\", ig);\n\t\t\t\trc = -EINVAL;\n\t\t\t\tgoto err_xormap;\n\t\t\t}\n\t\t}\n\t}\n\trc = cxl_decoder_add(cxld, target_map);\nerr_xormap:\n\tif (rc)\n\t\tput_device(&cxld->dev);\n\telse\n\t\trc = cxl_decoder_autoremove(dev, cxld);\n\tif (rc) {\n\t\tdev_err(dev, \"Failed to add decode range: %pr\", res);\n\t\treturn rc;\n\t}\n\tdev_dbg(dev, \"add: %s node: %d range [%#llx - %#llx]\\n\",\n\t\tdev_name(&cxld->dev),\n\t\tphys_to_target_node(cxld->hpa_range.start),\n\t\tcxld->hpa_range.start, cxld->hpa_range.end);\n\n\treturn 0;\n\nerr_insert:\n\tkfree(res->name);\nerr_name:\n\tkfree(res);\n\treturn -ENOMEM;\n}\n\n__mock struct acpi_device *to_cxl_host_bridge(struct device *host,\n\t\t\t\t\t      struct device *dev)\n{\n\tstruct acpi_device *adev = to_acpi_device(dev);\n\n\tif (!acpi_pci_find_root(adev->handle))\n\t\treturn NULL;\n\n\tif (strcmp(acpi_device_hid(adev), \"ACPI0016\") == 0)\n\t\treturn adev;\n\treturn NULL;\n}\n\n \nstruct cxl_chbs_context {\n\tstruct device *dev;\n\tunsigned long long uid;\n\tresource_size_t base;\n\tu32 cxl_version;\n};\n\nstatic int cxl_get_chbs_iter(union acpi_subtable_headers *header, void *arg,\n\t\t\t     const unsigned long end)\n{\n\tstruct cxl_chbs_context *ctx = arg;\n\tstruct acpi_cedt_chbs *chbs;\n\n\tif (ctx->base != CXL_RESOURCE_NONE)\n\t\treturn 0;\n\n\tchbs = (struct acpi_cedt_chbs *) header;\n\n\tif (ctx->uid != chbs->uid)\n\t\treturn 0;\n\n\tctx->cxl_version = chbs->cxl_version;\n\tif (!chbs->base)\n\t\treturn 0;\n\n\tif (chbs->cxl_version == ACPI_CEDT_CHBS_VERSION_CXL11 &&\n\t    chbs->length != CXL_RCRB_SIZE)\n\t\treturn 0;\n\n\tctx->base = chbs->base;\n\n\treturn 0;\n}\n\nstatic int cxl_get_chbs(struct device *dev, struct acpi_device *hb,\n\t\t\tstruct cxl_chbs_context *ctx)\n{\n\tunsigned long long uid;\n\tint rc;\n\n\trc = acpi_evaluate_integer(hb->handle, METHOD_NAME__UID, NULL, &uid);\n\tif (rc != AE_OK) {\n\t\tdev_err(dev, \"unable to retrieve _UID\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\tdev_dbg(dev, \"UID found: %lld\\n\", uid);\n\t*ctx = (struct cxl_chbs_context) {\n\t\t.dev = dev,\n\t\t.uid = uid,\n\t\t.base = CXL_RESOURCE_NONE,\n\t\t.cxl_version = UINT_MAX,\n\t};\n\n\tacpi_table_parse_cedt(ACPI_CEDT_TYPE_CHBS, cxl_get_chbs_iter, ctx);\n\n\treturn 0;\n}\n\nstatic int add_host_bridge_dport(struct device *match, void *arg)\n{\n\tacpi_status rc;\n\tstruct device *bridge;\n\tstruct cxl_dport *dport;\n\tstruct cxl_chbs_context ctx;\n\tstruct acpi_pci_root *pci_root;\n\tstruct cxl_port *root_port = arg;\n\tstruct device *host = root_port->dev.parent;\n\tstruct acpi_device *hb = to_cxl_host_bridge(host, match);\n\n\tif (!hb)\n\t\treturn 0;\n\n\trc = cxl_get_chbs(match, hb, &ctx);\n\tif (rc)\n\t\treturn rc;\n\n\tif (ctx.cxl_version == UINT_MAX) {\n\t\tdev_warn(match, \"No CHBS found for Host Bridge (UID %lld)\\n\",\n\t\t\t ctx.uid);\n\t\treturn 0;\n\t}\n\n\tif (ctx.base == CXL_RESOURCE_NONE) {\n\t\tdev_warn(match, \"CHBS invalid for Host Bridge (UID %lld)\\n\",\n\t\t\t ctx.uid);\n\t\treturn 0;\n\t}\n\n\tpci_root = acpi_pci_find_root(hb->handle);\n\tbridge = pci_root->bus->bridge;\n\n\t \n\tif (ctx.cxl_version == ACPI_CEDT_CHBS_VERSION_CXL11) {\n\t\tdev_dbg(match, \"RCRB found for UID %lld: %pa\\n\", ctx.uid,\n\t\t\t&ctx.base);\n\t\tdport = devm_cxl_add_rch_dport(root_port, bridge, ctx.uid,\n\t\t\t\t\t       ctx.base);\n\t} else {\n\t\tdport = devm_cxl_add_dport(root_port, bridge, ctx.uid,\n\t\t\t\t\t   CXL_RESOURCE_NONE);\n\t}\n\n\tif (IS_ERR(dport))\n\t\treturn PTR_ERR(dport);\n\n\treturn 0;\n}\n\n \nstatic int add_host_bridge_uport(struct device *match, void *arg)\n{\n\tstruct cxl_port *root_port = arg;\n\tstruct device *host = root_port->dev.parent;\n\tstruct acpi_device *hb = to_cxl_host_bridge(host, match);\n\tstruct acpi_pci_root *pci_root;\n\tstruct cxl_dport *dport;\n\tstruct cxl_port *port;\n\tstruct device *bridge;\n\tstruct cxl_chbs_context ctx;\n\tresource_size_t component_reg_phys;\n\tint rc;\n\n\tif (!hb)\n\t\treturn 0;\n\n\tpci_root = acpi_pci_find_root(hb->handle);\n\tbridge = pci_root->bus->bridge;\n\tdport = cxl_find_dport_by_dev(root_port, bridge);\n\tif (!dport) {\n\t\tdev_dbg(host, \"host bridge expected and not found\\n\");\n\t\treturn 0;\n\t}\n\n\tif (dport->rch) {\n\t\tdev_info(bridge, \"host supports CXL (restricted)\\n\");\n\t\treturn 0;\n\t}\n\n\trc = cxl_get_chbs(match, hb, &ctx);\n\tif (rc)\n\t\treturn rc;\n\n\tif (ctx.cxl_version == ACPI_CEDT_CHBS_VERSION_CXL11) {\n\t\tdev_warn(bridge,\n\t\t\t \"CXL CHBS version mismatch, skip port registration\\n\");\n\t\treturn 0;\n\t}\n\n\tcomponent_reg_phys = ctx.base;\n\tif (component_reg_phys != CXL_RESOURCE_NONE)\n\t\tdev_dbg(match, \"CHBCR found for UID %lld: %pa\\n\",\n\t\t\tctx.uid, &component_reg_phys);\n\n\trc = devm_cxl_register_pci_bus(host, bridge, pci_root->bus);\n\tif (rc)\n\t\treturn rc;\n\n\tport = devm_cxl_add_port(host, bridge, component_reg_phys, dport);\n\tif (IS_ERR(port))\n\t\treturn PTR_ERR(port);\n\n\tdev_info(bridge, \"host supports CXL\\n\");\n\n\treturn 0;\n}\n\nstatic int add_root_nvdimm_bridge(struct device *match, void *data)\n{\n\tstruct cxl_decoder *cxld;\n\tstruct cxl_port *root_port = data;\n\tstruct cxl_nvdimm_bridge *cxl_nvb;\n\tstruct device *host = root_port->dev.parent;\n\n\tif (!is_root_decoder(match))\n\t\treturn 0;\n\n\tcxld = to_cxl_decoder(match);\n\tif (!(cxld->flags & CXL_DECODER_F_PMEM))\n\t\treturn 0;\n\n\tcxl_nvb = devm_cxl_add_nvdimm_bridge(host, root_port);\n\tif (IS_ERR(cxl_nvb)) {\n\t\tdev_dbg(host, \"failed to register pmem\\n\");\n\t\treturn PTR_ERR(cxl_nvb);\n\t}\n\tdev_dbg(host, \"%s: add: %s\\n\", dev_name(&root_port->dev),\n\t\tdev_name(&cxl_nvb->dev));\n\treturn 1;\n}\n\nstatic struct lock_class_key cxl_root_key;\n\nstatic void cxl_acpi_lock_reset_class(void *dev)\n{\n\tdevice_lock_reset_class(dev);\n}\n\nstatic void del_cxl_resource(struct resource *res)\n{\n\tkfree(res->name);\n\tkfree(res);\n}\n\nstatic void cxl_set_public_resource(struct resource *priv, struct resource *pub)\n{\n\tpriv->desc = (unsigned long) pub;\n}\n\nstatic struct resource *cxl_get_public_resource(struct resource *priv)\n{\n\treturn (struct resource *) priv->desc;\n}\n\nstatic void remove_cxl_resources(void *data)\n{\n\tstruct resource *res, *next, *cxl = data;\n\n\tfor (res = cxl->child; res; res = next) {\n\t\tstruct resource *victim = cxl_get_public_resource(res);\n\n\t\tnext = res->sibling;\n\t\tremove_resource(res);\n\n\t\tif (victim) {\n\t\t\tremove_resource(victim);\n\t\t\tkfree(victim);\n\t\t}\n\n\t\tdel_cxl_resource(res);\n\t}\n}\n\n \nstatic int add_cxl_resources(struct resource *cxl_res)\n{\n\tstruct resource *res, *new, *next;\n\n\tfor (res = cxl_res->child; res; res = next) {\n\t\tnew = kzalloc(sizeof(*new), GFP_KERNEL);\n\t\tif (!new)\n\t\t\treturn -ENOMEM;\n\t\tnew->name = res->name;\n\t\tnew->start = res->start;\n\t\tnew->end = res->end;\n\t\tnew->flags = IORESOURCE_MEM;\n\t\tnew->desc = IORES_DESC_CXL;\n\n\t\t \n\t\tcxl_set_public_resource(res, new);\n\n\t\tinsert_resource_expand_to_fit(&iomem_resource, new);\n\n\t\tnext = res->sibling;\n\t\twhile (next && resource_overlaps(new, next)) {\n\t\t\tif (resource_contains(new, next)) {\n\t\t\t\tstruct resource *_next = next->sibling;\n\n\t\t\t\tremove_resource(next);\n\t\t\t\tdel_cxl_resource(next);\n\t\t\t\tnext = _next;\n\t\t\t} else\n\t\t\t\tnext->start = new->end + 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int pair_cxl_resource(struct device *dev, void *data)\n{\n\tstruct resource *cxl_res = data;\n\tstruct resource *p;\n\n\tif (!is_root_decoder(dev))\n\t\treturn 0;\n\n\tfor (p = cxl_res->child; p; p = p->sibling) {\n\t\tstruct cxl_root_decoder *cxlrd = to_cxl_root_decoder(dev);\n\t\tstruct cxl_decoder *cxld = &cxlrd->cxlsd.cxld;\n\t\tstruct resource res = {\n\t\t\t.start = cxld->hpa_range.start,\n\t\t\t.end = cxld->hpa_range.end,\n\t\t\t.flags = IORESOURCE_MEM,\n\t\t};\n\n\t\tif (resource_contains(p, &res)) {\n\t\t\tcxlrd->res = cxl_get_public_resource(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int cxl_acpi_probe(struct platform_device *pdev)\n{\n\tint rc;\n\tstruct resource *cxl_res;\n\tstruct cxl_port *root_port;\n\tstruct device *host = &pdev->dev;\n\tstruct acpi_device *adev = ACPI_COMPANION(host);\n\tstruct cxl_cfmws_context ctx;\n\n\tdevice_lock_set_class(&pdev->dev, &cxl_root_key);\n\trc = devm_add_action_or_reset(&pdev->dev, cxl_acpi_lock_reset_class,\n\t\t\t\t      &pdev->dev);\n\tif (rc)\n\t\treturn rc;\n\n\tcxl_res = devm_kzalloc(host, sizeof(*cxl_res), GFP_KERNEL);\n\tif (!cxl_res)\n\t\treturn -ENOMEM;\n\tcxl_res->name = \"CXL mem\";\n\tcxl_res->start = 0;\n\tcxl_res->end = -1;\n\tcxl_res->flags = IORESOURCE_MEM;\n\n\troot_port = devm_cxl_add_port(host, host, CXL_RESOURCE_NONE, NULL);\n\tif (IS_ERR(root_port))\n\t\treturn PTR_ERR(root_port);\n\n\trc = bus_for_each_dev(adev->dev.bus, NULL, root_port,\n\t\t\t      add_host_bridge_dport);\n\tif (rc < 0)\n\t\treturn rc;\n\n\trc = devm_add_action_or_reset(host, remove_cxl_resources, cxl_res);\n\tif (rc)\n\t\treturn rc;\n\n\tctx = (struct cxl_cfmws_context) {\n\t\t.dev = host,\n\t\t.root_port = root_port,\n\t\t.cxl_res = cxl_res,\n\t};\n\trc = acpi_table_parse_cedt(ACPI_CEDT_TYPE_CFMWS, cxl_parse_cfmws, &ctx);\n\tif (rc < 0)\n\t\treturn -ENXIO;\n\n\trc = add_cxl_resources(cxl_res);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tdevice_for_each_child(&root_port->dev, cxl_res, pair_cxl_resource);\n\n\t \n\trc = bus_for_each_dev(adev->dev.bus, NULL, root_port,\n\t\t\t      add_host_bridge_uport);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tif (IS_ENABLED(CONFIG_CXL_PMEM))\n\t\trc = device_for_each_child(&root_port->dev, root_port,\n\t\t\t\t\t   add_root_nvdimm_bridge);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t \n\tcxl_bus_rescan();\n\treturn 0;\n}\n\nstatic const struct acpi_device_id cxl_acpi_ids[] = {\n\t{ \"ACPI0017\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(acpi, cxl_acpi_ids);\n\nstatic const struct platform_device_id cxl_test_ids[] = {\n\t{ \"cxl_acpi\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(platform, cxl_test_ids);\n\nstatic struct platform_driver cxl_acpi_driver = {\n\t.probe = cxl_acpi_probe,\n\t.driver = {\n\t\t.name = KBUILD_MODNAME,\n\t\t.acpi_match_table = cxl_acpi_ids,\n\t},\n\t.id_table = cxl_test_ids,\n};\n\nstatic int __init cxl_acpi_init(void)\n{\n\treturn platform_driver_register(&cxl_acpi_driver);\n}\n\nstatic void __exit cxl_acpi_exit(void)\n{\n\tplatform_driver_unregister(&cxl_acpi_driver);\n\tcxl_bus_drain();\n}\n\n \nsubsys_initcall(cxl_acpi_init);\nmodule_exit(cxl_acpi_exit);\nMODULE_LICENSE(\"GPL v2\");\nMODULE_IMPORT_NS(CXL);\nMODULE_IMPORT_NS(ACPI);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}