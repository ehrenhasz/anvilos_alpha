{
  "module_name": "port.c",
  "hash_id": "f40be76fbcdcf6bc3a01567e1a176c04c1431e0db5f675bac19e418c7880cc4c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/cxl/port.c",
  "human_readable_source": "\n \n#include <linux/device.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\n#include \"cxlmem.h\"\n#include \"cxlpci.h\"\n\n \n\nstatic void schedule_detach(void *cxlmd)\n{\n\tschedule_cxl_memdev_detach(cxlmd);\n}\n\nstatic int discover_region(struct device *dev, void *root)\n{\n\tstruct cxl_endpoint_decoder *cxled;\n\tint rc;\n\n\tif (!is_endpoint_decoder(dev))\n\t\treturn 0;\n\n\tcxled = to_cxl_endpoint_decoder(dev);\n\tif ((cxled->cxld.flags & CXL_DECODER_F_ENABLE) == 0)\n\t\treturn 0;\n\n\tif (cxled->state != CXL_DECODER_STATE_AUTO)\n\t\treturn 0;\n\n\t \n\trc = cxl_add_to_region(root, cxled);\n\tif (rc)\n\t\tdev_dbg(dev, \"failed to add to region: %#llx-%#llx\\n\",\n\t\t\tcxled->cxld.hpa_range.start, cxled->cxld.hpa_range.end);\n\n\treturn 0;\n}\n\nstatic int cxl_switch_port_probe(struct cxl_port *port)\n{\n\tstruct cxl_hdm *cxlhdm;\n\tint rc;\n\n\trc = devm_cxl_port_enumerate_dports(port);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tcxlhdm = devm_cxl_setup_hdm(port, NULL);\n\tif (!IS_ERR(cxlhdm))\n\t\treturn devm_cxl_enumerate_decoders(cxlhdm, NULL);\n\n\tif (PTR_ERR(cxlhdm) != -ENODEV) {\n\t\tdev_err(&port->dev, \"Failed to map HDM decoder capability\\n\");\n\t\treturn PTR_ERR(cxlhdm);\n\t}\n\n\tif (rc == 1) {\n\t\tdev_dbg(&port->dev, \"Fallback to passthrough decoder\\n\");\n\t\treturn devm_cxl_add_passthrough_decoder(port);\n\t}\n\n\tdev_err(&port->dev, \"HDM decoder capability not found\\n\");\n\treturn -ENXIO;\n}\n\nstatic int cxl_endpoint_port_probe(struct cxl_port *port)\n{\n\tstruct cxl_endpoint_dvsec_info info = { .port = port };\n\tstruct cxl_memdev *cxlmd = to_cxl_memdev(port->uport_dev);\n\tstruct cxl_dev_state *cxlds = cxlmd->cxlds;\n\tstruct cxl_hdm *cxlhdm;\n\tstruct cxl_port *root;\n\tint rc;\n\n\trc = cxl_dvsec_rr_decode(cxlds->dev, cxlds->cxl_dvsec, &info);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tcxlhdm = devm_cxl_setup_hdm(port, &info);\n\tif (IS_ERR(cxlhdm)) {\n\t\tif (PTR_ERR(cxlhdm) == -ENODEV)\n\t\t\tdev_err(&port->dev, \"HDM decoder registers not found\\n\");\n\t\treturn PTR_ERR(cxlhdm);\n\t}\n\n\t \n\tread_cdat_data(port);\n\n\tget_device(&cxlmd->dev);\n\trc = devm_add_action_or_reset(&port->dev, schedule_detach, cxlmd);\n\tif (rc)\n\t\treturn rc;\n\n\trc = cxl_hdm_decode_init(cxlds, cxlhdm, &info);\n\tif (rc)\n\t\treturn rc;\n\n\trc = devm_cxl_enumerate_decoders(cxlhdm, &info);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\troot = find_cxl_root(port);\n\n\t \n\tdevice_for_each_child(&port->dev, root, discover_region);\n\tput_device(&root->dev);\n\n\treturn 0;\n}\n\nstatic int cxl_port_probe(struct device *dev)\n{\n\tstruct cxl_port *port = to_cxl_port(dev);\n\n\tif (is_cxl_endpoint(port))\n\t\treturn cxl_endpoint_port_probe(port);\n\treturn cxl_switch_port_probe(port);\n}\n\nstatic ssize_t CDAT_read(struct file *filp, struct kobject *kobj,\n\t\t\t struct bin_attribute *bin_attr, char *buf,\n\t\t\t loff_t offset, size_t count)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct cxl_port *port = to_cxl_port(dev);\n\n\tif (!port->cdat_available)\n\t\treturn -ENXIO;\n\n\tif (!port->cdat.table)\n\t\treturn 0;\n\n\treturn memory_read_from_buffer(buf, count, &offset,\n\t\t\t\t       port->cdat.table,\n\t\t\t\t       port->cdat.length);\n}\n\nstatic BIN_ATTR_ADMIN_RO(CDAT, 0);\n\nstatic umode_t cxl_port_bin_attr_is_visible(struct kobject *kobj,\n\t\t\t\t\t    struct bin_attribute *attr, int i)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct cxl_port *port = to_cxl_port(dev);\n\n\tif ((attr == &bin_attr_CDAT) && port->cdat_available)\n\t\treturn attr->attr.mode;\n\n\treturn 0;\n}\n\nstatic struct bin_attribute *cxl_cdat_bin_attributes[] = {\n\t&bin_attr_CDAT,\n\tNULL,\n};\n\nstatic struct attribute_group cxl_cdat_attribute_group = {\n\t.bin_attrs = cxl_cdat_bin_attributes,\n\t.is_bin_visible = cxl_port_bin_attr_is_visible,\n};\n\nstatic const struct attribute_group *cxl_port_attribute_groups[] = {\n\t&cxl_cdat_attribute_group,\n\tNULL,\n};\n\nstatic struct cxl_driver cxl_port_driver = {\n\t.name = \"cxl_port\",\n\t.probe = cxl_port_probe,\n\t.id = CXL_DEVICE_PORT,\n\t.drv = {\n\t\t.dev_groups = cxl_port_attribute_groups,\n\t},\n};\n\nmodule_cxl_driver(cxl_port_driver);\nMODULE_LICENSE(\"GPL v2\");\nMODULE_IMPORT_NS(CXL);\nMODULE_ALIAS_CXL(CXL_DEVICE_PORT);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}