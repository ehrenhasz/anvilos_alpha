{
  "module_name": "mem.c",
  "hash_id": "65c60fb34ef2b01099e49e953f137f38eddf8be5721615bb2be6c230f609daa0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/cxl/mem.c",
  "human_readable_source": "\n \n#include <linux/debugfs.h>\n#include <linux/device.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n\n#include \"cxlmem.h\"\n#include \"cxlpci.h\"\n\n \n\nstatic void enable_suspend(void *data)\n{\n\tcxl_mem_active_dec();\n}\n\nstatic void remove_debugfs(void *dentry)\n{\n\tdebugfs_remove_recursive(dentry);\n}\n\nstatic int cxl_mem_dpa_show(struct seq_file *file, void *data)\n{\n\tstruct device *dev = file->private;\n\tstruct cxl_memdev *cxlmd = to_cxl_memdev(dev);\n\n\tcxl_dpa_debug(file, cxlmd->cxlds);\n\n\treturn 0;\n}\n\nstatic int devm_cxl_add_endpoint(struct device *host, struct cxl_memdev *cxlmd,\n\t\t\t\t struct cxl_dport *parent_dport)\n{\n\tstruct cxl_port *parent_port = parent_dport->port;\n\tstruct cxl_dev_state *cxlds = cxlmd->cxlds;\n\tstruct cxl_port *endpoint, *iter, *down;\n\tint rc;\n\n\t \n\tfor (iter = parent_port, down = NULL; !is_cxl_root(iter);\n\t     down = iter, iter = to_cxl_port(iter->dev.parent)) {\n\t\tstruct cxl_ep *ep;\n\n\t\tep = cxl_ep_load(iter, cxlmd);\n\t\tep->next = down;\n\t}\n\n\tendpoint = devm_cxl_add_port(host, &cxlmd->dev,\n\t\t\t\t     cxlds->component_reg_phys,\n\t\t\t\t     parent_dport);\n\tif (IS_ERR(endpoint))\n\t\treturn PTR_ERR(endpoint);\n\n\trc = cxl_endpoint_autoremove(cxlmd, endpoint);\n\tif (rc)\n\t\treturn rc;\n\n\tif (!endpoint->dev.driver) {\n\t\tdev_err(&cxlmd->dev, \"%s failed probe\\n\",\n\t\t\tdev_name(&endpoint->dev));\n\t\treturn -ENXIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int cxl_debugfs_poison_inject(void *data, u64 dpa)\n{\n\tstruct cxl_memdev *cxlmd = data;\n\n\treturn cxl_inject_poison(cxlmd, dpa);\n}\n\nDEFINE_DEBUGFS_ATTRIBUTE(cxl_poison_inject_fops, NULL,\n\t\t\t cxl_debugfs_poison_inject, \"%llx\\n\");\n\nstatic int cxl_debugfs_poison_clear(void *data, u64 dpa)\n{\n\tstruct cxl_memdev *cxlmd = data;\n\n\treturn cxl_clear_poison(cxlmd, dpa);\n}\n\nDEFINE_DEBUGFS_ATTRIBUTE(cxl_poison_clear_fops, NULL,\n\t\t\t cxl_debugfs_poison_clear, \"%llx\\n\");\n\nstatic int cxl_mem_probe(struct device *dev)\n{\n\tstruct cxl_memdev *cxlmd = to_cxl_memdev(dev);\n\tstruct cxl_memdev_state *mds = to_cxl_memdev_state(cxlmd->cxlds);\n\tstruct cxl_dev_state *cxlds = cxlmd->cxlds;\n\tstruct device *endpoint_parent;\n\tstruct cxl_port *parent_port;\n\tstruct cxl_dport *dport;\n\tstruct dentry *dentry;\n\tint rc;\n\n\tif (!cxlds->media_ready)\n\t\treturn -EBUSY;\n\n\t \n\tif (work_pending(&cxlmd->detach_work))\n\t\treturn -EBUSY;\n\n\tdentry = cxl_debugfs_create_dir(dev_name(dev));\n\tdebugfs_create_devm_seqfile(dev, \"dpamem\", dentry, cxl_mem_dpa_show);\n\n\tif (test_bit(CXL_POISON_ENABLED_INJECT, mds->poison.enabled_cmds))\n\t\tdebugfs_create_file(\"inject_poison\", 0200, dentry, cxlmd,\n\t\t\t\t    &cxl_poison_inject_fops);\n\tif (test_bit(CXL_POISON_ENABLED_CLEAR, mds->poison.enabled_cmds))\n\t\tdebugfs_create_file(\"clear_poison\", 0200, dentry, cxlmd,\n\t\t\t\t    &cxl_poison_clear_fops);\n\n\trc = devm_add_action_or_reset(dev, remove_debugfs, dentry);\n\tif (rc)\n\t\treturn rc;\n\n\trc = devm_cxl_enumerate_ports(cxlmd);\n\tif (rc)\n\t\treturn rc;\n\n\tparent_port = cxl_mem_find_port(cxlmd, &dport);\n\tif (!parent_port) {\n\t\tdev_err(dev, \"CXL port topology not found\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tif (dport->rch)\n\t\tendpoint_parent = parent_port->uport_dev;\n\telse\n\t\tendpoint_parent = &parent_port->dev;\n\n\tdevice_lock(endpoint_parent);\n\tif (!endpoint_parent->driver) {\n\t\tdev_err(dev, \"CXL port topology %s not enabled\\n\",\n\t\t\tdev_name(endpoint_parent));\n\t\trc = -ENXIO;\n\t\tgoto unlock;\n\t}\n\n\trc = devm_cxl_add_endpoint(endpoint_parent, cxlmd, dport);\nunlock:\n\tdevice_unlock(endpoint_parent);\n\tput_device(&parent_port->dev);\n\tif (rc)\n\t\treturn rc;\n\n\tif (resource_size(&cxlds->pmem_res) && IS_ENABLED(CONFIG_CXL_PMEM)) {\n\t\trc = devm_cxl_add_nvdimm(cxlmd);\n\t\tif (rc == -ENODEV)\n\t\t\tdev_info(dev, \"PMEM disabled by platform\\n\");\n\t\telse\n\t\t\treturn rc;\n\t}\n\n\t \n\tcxl_mem_active_inc();\n\treturn devm_add_action_or_reset(dev, enable_suspend, NULL);\n}\n\nstatic ssize_t trigger_poison_list_store(struct device *dev,\n\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t const char *buf, size_t len)\n{\n\tbool trigger;\n\tint rc;\n\n\tif (kstrtobool(buf, &trigger) || !trigger)\n\t\treturn -EINVAL;\n\n\trc = cxl_trigger_poison_list(to_cxl_memdev(dev));\n\n\treturn rc ? rc : len;\n}\nstatic DEVICE_ATTR_WO(trigger_poison_list);\n\nstatic umode_t cxl_mem_visible(struct kobject *kobj, struct attribute *a, int n)\n{\n\tif (a == &dev_attr_trigger_poison_list.attr) {\n\t\tstruct device *dev = kobj_to_dev(kobj);\n\t\tstruct cxl_memdev *cxlmd = to_cxl_memdev(dev);\n\t\tstruct cxl_memdev_state *mds =\n\t\t\tto_cxl_memdev_state(cxlmd->cxlds);\n\n\t\tif (!test_bit(CXL_POISON_ENABLED_LIST,\n\t\t\t      mds->poison.enabled_cmds))\n\t\t\treturn 0;\n\t}\n\treturn a->mode;\n}\n\nstatic struct attribute *cxl_mem_attrs[] = {\n\t&dev_attr_trigger_poison_list.attr,\n\tNULL\n};\n\nstatic struct attribute_group cxl_mem_group = {\n\t.attrs = cxl_mem_attrs,\n\t.is_visible = cxl_mem_visible,\n};\n\n__ATTRIBUTE_GROUPS(cxl_mem);\n\nstatic struct cxl_driver cxl_mem_driver = {\n\t.name = \"cxl_mem\",\n\t.probe = cxl_mem_probe,\n\t.id = CXL_DEVICE_MEMORY_EXPANDER,\n\t.drv = {\n\t\t.dev_groups = cxl_mem_groups,\n\t},\n};\n\nmodule_cxl_driver(cxl_mem_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_IMPORT_NS(CXL);\nMODULE_ALIAS_CXL(CXL_DEVICE_MEMORY_EXPANDER);\n \nMODULE_SOFTDEP(\"pre: cxl_port\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}