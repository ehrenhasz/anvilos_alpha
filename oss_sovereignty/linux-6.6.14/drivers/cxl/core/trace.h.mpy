{
  "module_name": "trace.h",
  "hash_id": "05848adb5c7d5ba24c1430ece8ff1830545465c841be0fb6a2e48ad9781700c7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/cxl/core/trace.h",
  "human_readable_source": "\n \n#undef TRACE_SYSTEM\n#define TRACE_SYSTEM cxl\n\n#if !defined(_CXL_EVENTS_H) || defined(TRACE_HEADER_MULTI_READ)\n#define _CXL_EVENTS_H\n\n#include <linux/tracepoint.h>\n#include <linux/pci.h>\n#include <asm-generic/unaligned.h>\n\n#include <cxl.h>\n#include <cxlmem.h>\n#include \"core.h\"\n\n#define CXL_RAS_UC_CACHE_DATA_PARITY\tBIT(0)\n#define CXL_RAS_UC_CACHE_ADDR_PARITY\tBIT(1)\n#define CXL_RAS_UC_CACHE_BE_PARITY\tBIT(2)\n#define CXL_RAS_UC_CACHE_DATA_ECC\tBIT(3)\n#define CXL_RAS_UC_MEM_DATA_PARITY\tBIT(4)\n#define CXL_RAS_UC_MEM_ADDR_PARITY\tBIT(5)\n#define CXL_RAS_UC_MEM_BE_PARITY\tBIT(6)\n#define CXL_RAS_UC_MEM_DATA_ECC\t\tBIT(7)\n#define CXL_RAS_UC_REINIT_THRESH\tBIT(8)\n#define CXL_RAS_UC_RSVD_ENCODE\t\tBIT(9)\n#define CXL_RAS_UC_POISON\t\tBIT(10)\n#define CXL_RAS_UC_RECV_OVERFLOW\tBIT(11)\n#define CXL_RAS_UC_INTERNAL_ERR\t\tBIT(14)\n#define CXL_RAS_UC_IDE_TX_ERR\t\tBIT(15)\n#define CXL_RAS_UC_IDE_RX_ERR\t\tBIT(16)\n\n#define show_uc_errs(status)\t__print_flags(status, \" | \",\t\t  \\\n\t{ CXL_RAS_UC_CACHE_DATA_PARITY, \"Cache Data Parity Error\" },\t  \\\n\t{ CXL_RAS_UC_CACHE_ADDR_PARITY, \"Cache Address Parity Error\" },\t  \\\n\t{ CXL_RAS_UC_CACHE_BE_PARITY, \"Cache Byte Enable Parity Error\" }, \\\n\t{ CXL_RAS_UC_CACHE_DATA_ECC, \"Cache Data ECC Error\" },\t\t  \\\n\t{ CXL_RAS_UC_MEM_DATA_PARITY, \"Memory Data Parity Error\" },\t  \\\n\t{ CXL_RAS_UC_MEM_ADDR_PARITY, \"Memory Address Parity Error\" },\t  \\\n\t{ CXL_RAS_UC_MEM_BE_PARITY, \"Memory Byte Enable Parity Error\" },  \\\n\t{ CXL_RAS_UC_MEM_DATA_ECC, \"Memory Data ECC Error\" },\t\t  \\\n\t{ CXL_RAS_UC_REINIT_THRESH, \"REINIT Threshold Hit\" },\t\t  \\\n\t{ CXL_RAS_UC_RSVD_ENCODE, \"Received Unrecognized Encoding\" },\t  \\\n\t{ CXL_RAS_UC_POISON, \"Received Poison From Peer\" },\t\t  \\\n\t{ CXL_RAS_UC_RECV_OVERFLOW, \"Receiver Overflow\" },\t\t  \\\n\t{ CXL_RAS_UC_INTERNAL_ERR, \"Component Specific Error\" },\t  \\\n\t{ CXL_RAS_UC_IDE_TX_ERR, \"IDE Tx Error\" },\t\t\t  \\\n\t{ CXL_RAS_UC_IDE_RX_ERR, \"IDE Rx Error\" }\t\t\t  \\\n)\n\nTRACE_EVENT(cxl_aer_uncorrectable_error,\n\tTP_PROTO(const struct cxl_memdev *cxlmd, u32 status, u32 fe, u32 *hl),\n\tTP_ARGS(cxlmd, status, fe, hl),\n\tTP_STRUCT__entry(\n\t\t__string(memdev, dev_name(&cxlmd->dev))\n\t\t__string(host, dev_name(cxlmd->dev.parent))\n\t\t__field(u64, serial)\n\t\t__field(u32, status)\n\t\t__field(u32, first_error)\n\t\t__array(u32, header_log, CXL_HEADERLOG_SIZE_U32)\n\t),\n\tTP_fast_assign(\n\t\t__assign_str(memdev, dev_name(&cxlmd->dev));\n\t\t__assign_str(host, dev_name(cxlmd->dev.parent));\n\t\t__entry->serial = cxlmd->cxlds->serial;\n\t\t__entry->status = status;\n\t\t__entry->first_error = fe;\n\t\t \n\t\tmemcpy(__entry->header_log, hl, CXL_HEADERLOG_SIZE);\n\t),\n\tTP_printk(\"memdev=%s host=%s serial=%lld: status: '%s' first_error: '%s'\",\n\t\t  __get_str(memdev), __get_str(host), __entry->serial,\n\t\t  show_uc_errs(__entry->status),\n\t\t  show_uc_errs(__entry->first_error)\n\t)\n);\n\n#define CXL_RAS_CE_CACHE_DATA_ECC\tBIT(0)\n#define CXL_RAS_CE_MEM_DATA_ECC\t\tBIT(1)\n#define CXL_RAS_CE_CRC_THRESH\t\tBIT(2)\n#define CLX_RAS_CE_RETRY_THRESH\t\tBIT(3)\n#define CXL_RAS_CE_CACHE_POISON\t\tBIT(4)\n#define CXL_RAS_CE_MEM_POISON\t\tBIT(5)\n#define CXL_RAS_CE_PHYS_LAYER_ERR\tBIT(6)\n\n#define show_ce_errs(status)\t__print_flags(status, \" | \",\t\t\t\\\n\t{ CXL_RAS_CE_CACHE_DATA_ECC, \"Cache Data ECC Error\" },\t\t\t\\\n\t{ CXL_RAS_CE_MEM_DATA_ECC, \"Memory Data ECC Error\" },\t\t\t\\\n\t{ CXL_RAS_CE_CRC_THRESH, \"CRC Threshold Hit\" },\t\t\t\t\\\n\t{ CLX_RAS_CE_RETRY_THRESH, \"Retry Threshold\" },\t\t\t\t\\\n\t{ CXL_RAS_CE_CACHE_POISON, \"Received Cache Poison From Peer\" },\t\t\\\n\t{ CXL_RAS_CE_MEM_POISON, \"Received Memory Poison From Peer\" },\t\t\\\n\t{ CXL_RAS_CE_PHYS_LAYER_ERR, \"Received Error From Physical Layer\" }\t\\\n)\n\nTRACE_EVENT(cxl_aer_correctable_error,\n\tTP_PROTO(const struct cxl_memdev *cxlmd, u32 status),\n\tTP_ARGS(cxlmd, status),\n\tTP_STRUCT__entry(\n\t\t__string(memdev, dev_name(&cxlmd->dev))\n\t\t__string(host, dev_name(cxlmd->dev.parent))\n\t\t__field(u64, serial)\n\t\t__field(u32, status)\n\t),\n\tTP_fast_assign(\n\t\t__assign_str(memdev, dev_name(&cxlmd->dev));\n\t\t__assign_str(host, dev_name(cxlmd->dev.parent));\n\t\t__entry->serial = cxlmd->cxlds->serial;\n\t\t__entry->status = status;\n\t),\n\tTP_printk(\"memdev=%s host=%s serial=%lld: status: '%s'\",\n\t\t  __get_str(memdev), __get_str(host), __entry->serial,\n\t\t  show_ce_errs(__entry->status)\n\t)\n);\n\n#define cxl_event_log_type_str(type)\t\t\t\t\\\n\t__print_symbolic(type,\t\t\t\t\t\\\n\t\t{ CXL_EVENT_TYPE_INFO, \"Informational\" },\t\\\n\t\t{ CXL_EVENT_TYPE_WARN, \"Warning\" },\t\t\\\n\t\t{ CXL_EVENT_TYPE_FAIL, \"Failure\" },\t\t\\\n\t\t{ CXL_EVENT_TYPE_FATAL, \"Fatal\" })\n\nTRACE_EVENT(cxl_overflow,\n\n\tTP_PROTO(const struct cxl_memdev *cxlmd, enum cxl_event_log_type log,\n\t\t struct cxl_get_event_payload *payload),\n\n\tTP_ARGS(cxlmd, log, payload),\n\n\tTP_STRUCT__entry(\n\t\t__string(memdev, dev_name(&cxlmd->dev))\n\t\t__string(host, dev_name(cxlmd->dev.parent))\n\t\t__field(int, log)\n\t\t__field(u64, serial)\n\t\t__field(u64, first_ts)\n\t\t__field(u64, last_ts)\n\t\t__field(u16, count)\n\t),\n\n\tTP_fast_assign(\n\t\t__assign_str(memdev, dev_name(&cxlmd->dev));\n\t\t__assign_str(host, dev_name(cxlmd->dev.parent));\n\t\t__entry->serial = cxlmd->cxlds->serial;\n\t\t__entry->log = log;\n\t\t__entry->count = le16_to_cpu(payload->overflow_err_count);\n\t\t__entry->first_ts = le64_to_cpu(payload->first_overflow_timestamp);\n\t\t__entry->last_ts = le64_to_cpu(payload->last_overflow_timestamp);\n\t),\n\n\tTP_printk(\"memdev=%s host=%s serial=%lld: log=%s : %u records from %llu to %llu\",\n\t\t__get_str(memdev), __get_str(host), __entry->serial,\n\t\tcxl_event_log_type_str(__entry->log), __entry->count,\n\t\t__entry->first_ts, __entry->last_ts)\n\n);\n\n \n#define CXL_EVENT_RECORD_FLAG_PERMANENT\t\tBIT(2)\n#define CXL_EVENT_RECORD_FLAG_MAINT_NEEDED\tBIT(3)\n#define CXL_EVENT_RECORD_FLAG_PERF_DEGRADED\tBIT(4)\n#define CXL_EVENT_RECORD_FLAG_HW_REPLACE\tBIT(5)\n#define show_hdr_flags(flags)\t__print_flags(flags, \" | \",\t\t\t   \\\n\t{ CXL_EVENT_RECORD_FLAG_PERMANENT,\t\"PERMANENT_CONDITION\"\t\t}, \\\n\t{ CXL_EVENT_RECORD_FLAG_MAINT_NEEDED,\t\"MAINTENANCE_NEEDED\"\t\t}, \\\n\t{ CXL_EVENT_RECORD_FLAG_PERF_DEGRADED,\t\"PERFORMANCE_DEGRADED\"\t\t}, \\\n\t{ CXL_EVENT_RECORD_FLAG_HW_REPLACE,\t\"HARDWARE_REPLACEMENT_NEEDED\"\t}  \\\n)\n\n \n#define CXL_EVT_TP_entry\t\t\t\t\t\\\n\t__string(memdev, dev_name(&cxlmd->dev))\t\t\t\\\n\t__string(host, dev_name(cxlmd->dev.parent))\t\t\\\n\t__field(int, log)\t\t\t\t\t\\\n\t__field_struct(uuid_t, hdr_uuid)\t\t\t\\\n\t__field(u64, serial)\t\t\t\t\t\\\n\t__field(u32, hdr_flags)\t\t\t\t\t\\\n\t__field(u16, hdr_handle)\t\t\t\t\\\n\t__field(u16, hdr_related_handle)\t\t\t\\\n\t__field(u64, hdr_timestamp)\t\t\t\t\\\n\t__field(u8, hdr_length)\t\t\t\t\t\\\n\t__field(u8, hdr_maint_op_class)\n\n#define CXL_EVT_TP_fast_assign(cxlmd, l, hdr)\t\t\t\t\t\\\n\t__assign_str(memdev, dev_name(&(cxlmd)->dev));\t\t\t\t\\\n\t__assign_str(host, dev_name((cxlmd)->dev.parent));\t\t\t\\\n\t__entry->log = (l);\t\t\t\t\t\t\t\\\n\t__entry->serial = (cxlmd)->cxlds->serial;\t\t\t\t\\\n\tmemcpy(&__entry->hdr_uuid, &(hdr).id, sizeof(uuid_t));\t\t\t\\\n\t__entry->hdr_length = (hdr).length;\t\t\t\t\t\\\n\t__entry->hdr_flags = get_unaligned_le24((hdr).flags);\t\t\t\\\n\t__entry->hdr_handle = le16_to_cpu((hdr).handle);\t\t\t\\\n\t__entry->hdr_related_handle = le16_to_cpu((hdr).related_handle);\t\\\n\t__entry->hdr_timestamp = le64_to_cpu((hdr).timestamp);\t\t\t\\\n\t__entry->hdr_maint_op_class = (hdr).maint_op_class\n\n#define CXL_EVT_TP_printk(fmt, ...) \\\n\tTP_printk(\"memdev=%s host=%s serial=%lld log=%s : time=%llu uuid=%pUb \"\t\\\n\t\t\"len=%d flags='%s' handle=%x related_handle=%x \"\t\t\\\n\t\t\"maint_op_class=%u : \" fmt,\t\t\t\t\t\\\n\t\t__get_str(memdev), __get_str(host), __entry->serial,\t\t\\\n\t\tcxl_event_log_type_str(__entry->log),\t\t\t\t\\\n\t\t__entry->hdr_timestamp, &__entry->hdr_uuid, __entry->hdr_length,\\\n\t\tshow_hdr_flags(__entry->hdr_flags), __entry->hdr_handle,\t\\\n\t\t__entry->hdr_related_handle, __entry->hdr_maint_op_class,\t\\\n\t\t##__VA_ARGS__)\n\nTRACE_EVENT(cxl_generic_event,\n\n\tTP_PROTO(const struct cxl_memdev *cxlmd, enum cxl_event_log_type log,\n\t\t struct cxl_event_record_raw *rec),\n\n\tTP_ARGS(cxlmd, log, rec),\n\n\tTP_STRUCT__entry(\n\t\tCXL_EVT_TP_entry\n\t\t__array(u8, data, CXL_EVENT_RECORD_DATA_LENGTH)\n\t),\n\n\tTP_fast_assign(\n\t\tCXL_EVT_TP_fast_assign(cxlmd, log, rec->hdr);\n\t\tmemcpy(__entry->data, &rec->data, CXL_EVENT_RECORD_DATA_LENGTH);\n\t),\n\n\tCXL_EVT_TP_printk(\"%s\",\n\t\t__print_hex(__entry->data, CXL_EVENT_RECORD_DATA_LENGTH))\n);\n\n \n#define CXL_DPA_FLAGS_MASK\t\t\t0x3F\n#define CXL_DPA_MASK\t\t\t\t(~CXL_DPA_FLAGS_MASK)\n\n#define CXL_DPA_VOLATILE\t\t\tBIT(0)\n#define CXL_DPA_NOT_REPAIRABLE\t\t\tBIT(1)\n#define show_dpa_flags(flags)\t__print_flags(flags, \"|\",\t\t   \\\n\t{ CXL_DPA_VOLATILE,\t\t\t\"VOLATILE\"\t\t}, \\\n\t{ CXL_DPA_NOT_REPAIRABLE,\t\t\"NOT_REPAIRABLE\"\t}  \\\n)\n\n \n#define CXL_GMER_EVT_DESC_UNCORECTABLE_EVENT\t\tBIT(0)\n#define CXL_GMER_EVT_DESC_THRESHOLD_EVENT\t\tBIT(1)\n#define CXL_GMER_EVT_DESC_POISON_LIST_OVERFLOW\t\tBIT(2)\n#define show_event_desc_flags(flags)\t__print_flags(flags, \"|\",\t\t   \\\n\t{ CXL_GMER_EVT_DESC_UNCORECTABLE_EVENT,\t\t\"UNCORRECTABLE_EVENT\"\t}, \\\n\t{ CXL_GMER_EVT_DESC_THRESHOLD_EVENT,\t\t\"THRESHOLD_EVENT\"\t}, \\\n\t{ CXL_GMER_EVT_DESC_POISON_LIST_OVERFLOW,\t\"POISON_LIST_OVERFLOW\"\t}  \\\n)\n\n#define CXL_GMER_MEM_EVT_TYPE_ECC_ERROR\t\t\t0x00\n#define CXL_GMER_MEM_EVT_TYPE_INV_ADDR\t\t\t0x01\n#define CXL_GMER_MEM_EVT_TYPE_DATA_PATH_ERROR\t\t0x02\n#define show_mem_event_type(type)\t__print_symbolic(type,\t\t\t\\\n\t{ CXL_GMER_MEM_EVT_TYPE_ECC_ERROR,\t\t\"ECC Error\" },\t\t\\\n\t{ CXL_GMER_MEM_EVT_TYPE_INV_ADDR,\t\t\"Invalid Address\" },\t\\\n\t{ CXL_GMER_MEM_EVT_TYPE_DATA_PATH_ERROR,\t\"Data Path Error\" }\t\\\n)\n\n#define CXL_GMER_TRANS_UNKNOWN\t\t\t\t0x00\n#define CXL_GMER_TRANS_HOST_READ\t\t\t0x01\n#define CXL_GMER_TRANS_HOST_WRITE\t\t\t0x02\n#define CXL_GMER_TRANS_HOST_SCAN_MEDIA\t\t\t0x03\n#define CXL_GMER_TRANS_HOST_INJECT_POISON\t\t0x04\n#define CXL_GMER_TRANS_INTERNAL_MEDIA_SCRUB\t\t0x05\n#define CXL_GMER_TRANS_INTERNAL_MEDIA_MANAGEMENT\t0x06\n#define show_trans_type(type)\t__print_symbolic(type,\t\t\t\t\t\\\n\t{ CXL_GMER_TRANS_UNKNOWN,\t\t\t\"Unknown\" },\t\t\t\\\n\t{ CXL_GMER_TRANS_HOST_READ,\t\t\t\"Host Read\" },\t\t\t\\\n\t{ CXL_GMER_TRANS_HOST_WRITE,\t\t\t\"Host Write\" },\t\t\t\\\n\t{ CXL_GMER_TRANS_HOST_SCAN_MEDIA,\t\t\"Host Scan Media\" },\t\t\\\n\t{ CXL_GMER_TRANS_HOST_INJECT_POISON,\t\t\"Host Inject Poison\" },\t\t\\\n\t{ CXL_GMER_TRANS_INTERNAL_MEDIA_SCRUB,\t\t\"Internal Media Scrub\" },\t\\\n\t{ CXL_GMER_TRANS_INTERNAL_MEDIA_MANAGEMENT,\t\"Internal Media Management\" }\t\\\n)\n\n#define CXL_GMER_VALID_CHANNEL\t\t\t\tBIT(0)\n#define CXL_GMER_VALID_RANK\t\t\t\tBIT(1)\n#define CXL_GMER_VALID_DEVICE\t\t\t\tBIT(2)\n#define CXL_GMER_VALID_COMPONENT\t\t\tBIT(3)\n#define show_valid_flags(flags)\t__print_flags(flags, \"|\",\t\t   \\\n\t{ CXL_GMER_VALID_CHANNEL,\t\t\t\"CHANNEL\"\t}, \\\n\t{ CXL_GMER_VALID_RANK,\t\t\t\t\"RANK\"\t\t}, \\\n\t{ CXL_GMER_VALID_DEVICE,\t\t\t\"DEVICE\"\t}, \\\n\t{ CXL_GMER_VALID_COMPONENT,\t\t\t\"COMPONENT\"\t}  \\\n)\n\nTRACE_EVENT(cxl_general_media,\n\n\tTP_PROTO(const struct cxl_memdev *cxlmd, enum cxl_event_log_type log,\n\t\t struct cxl_event_gen_media *rec),\n\n\tTP_ARGS(cxlmd, log, rec),\n\n\tTP_STRUCT__entry(\n\t\tCXL_EVT_TP_entry\n\t\t \n\t\t__field(u64, dpa)\n\t\t__field(u8, descriptor)\n\t\t__field(u8, type)\n\t\t__field(u8, transaction_type)\n\t\t__field(u8, channel)\n\t\t__field(u32, device)\n\t\t__array(u8, comp_id, CXL_EVENT_GEN_MED_COMP_ID_SIZE)\n\t\t__field(u16, validity_flags)\n\t\t \n\t\t__field(u8, rank)\n\t\t__field(u8, dpa_flags)\n\t),\n\n\tTP_fast_assign(\n\t\tCXL_EVT_TP_fast_assign(cxlmd, log, rec->hdr);\n\n\t\t \n\t\t__entry->dpa = le64_to_cpu(rec->phys_addr);\n\t\t__entry->dpa_flags = __entry->dpa & CXL_DPA_FLAGS_MASK;\n\t\t \n\t\t__entry->dpa &= CXL_DPA_MASK;\n\t\t__entry->descriptor = rec->descriptor;\n\t\t__entry->type = rec->type;\n\t\t__entry->transaction_type = rec->transaction_type;\n\t\t__entry->channel = rec->channel;\n\t\t__entry->rank = rec->rank;\n\t\t__entry->device = get_unaligned_le24(rec->device);\n\t\tmemcpy(__entry->comp_id, &rec->component_id,\n\t\t\tCXL_EVENT_GEN_MED_COMP_ID_SIZE);\n\t\t__entry->validity_flags = get_unaligned_le16(&rec->validity_flags);\n\t),\n\n\tCXL_EVT_TP_printk(\"dpa=%llx dpa_flags='%s' \" \\\n\t\t\"descriptor='%s' type='%s' transaction_type='%s' channel=%u rank=%u \" \\\n\t\t\"device=%x comp_id=%s validity_flags='%s'\",\n\t\t__entry->dpa, show_dpa_flags(__entry->dpa_flags),\n\t\tshow_event_desc_flags(__entry->descriptor),\n\t\tshow_mem_event_type(__entry->type),\n\t\tshow_trans_type(__entry->transaction_type),\n\t\t__entry->channel, __entry->rank, __entry->device,\n\t\t__print_hex(__entry->comp_id, CXL_EVENT_GEN_MED_COMP_ID_SIZE),\n\t\tshow_valid_flags(__entry->validity_flags)\n\t)\n);\n\n \n \n#define CXL_DER_VALID_CHANNEL\t\t\t\tBIT(0)\n#define CXL_DER_VALID_RANK\t\t\t\tBIT(1)\n#define CXL_DER_VALID_NIBBLE\t\t\t\tBIT(2)\n#define CXL_DER_VALID_BANK_GROUP\t\t\tBIT(3)\n#define CXL_DER_VALID_BANK\t\t\t\tBIT(4)\n#define CXL_DER_VALID_ROW\t\t\t\tBIT(5)\n#define CXL_DER_VALID_COLUMN\t\t\t\tBIT(6)\n#define CXL_DER_VALID_CORRECTION_MASK\t\t\tBIT(7)\n#define show_dram_valid_flags(flags)\t__print_flags(flags, \"|\",\t\t\t   \\\n\t{ CXL_DER_VALID_CHANNEL,\t\t\t\"CHANNEL\"\t\t}, \\\n\t{ CXL_DER_VALID_RANK,\t\t\t\t\"RANK\"\t\t\t}, \\\n\t{ CXL_DER_VALID_NIBBLE,\t\t\t\t\"NIBBLE\"\t\t}, \\\n\t{ CXL_DER_VALID_BANK_GROUP,\t\t\t\"BANK GROUP\"\t\t}, \\\n\t{ CXL_DER_VALID_BANK,\t\t\t\t\"BANK\"\t\t\t}, \\\n\t{ CXL_DER_VALID_ROW,\t\t\t\t\"ROW\"\t\t\t}, \\\n\t{ CXL_DER_VALID_COLUMN,\t\t\t\t\"COLUMN\"\t\t}, \\\n\t{ CXL_DER_VALID_CORRECTION_MASK,\t\t\"CORRECTION MASK\"\t}  \\\n)\n\nTRACE_EVENT(cxl_dram,\n\n\tTP_PROTO(const struct cxl_memdev *cxlmd, enum cxl_event_log_type log,\n\t\t struct cxl_event_dram *rec),\n\n\tTP_ARGS(cxlmd, log, rec),\n\n\tTP_STRUCT__entry(\n\t\tCXL_EVT_TP_entry\n\t\t \n\t\t__field(u64, dpa)\n\t\t__field(u8, descriptor)\n\t\t__field(u8, type)\n\t\t__field(u8, transaction_type)\n\t\t__field(u8, channel)\n\t\t__field(u16, validity_flags)\n\t\t__field(u16, column)\t \n\t\t__field(u32, nibble_mask)\n\t\t__field(u32, row)\n\t\t__array(u8, cor_mask, CXL_EVENT_DER_CORRECTION_MASK_SIZE)\n\t\t__field(u8, rank)\t \n\t\t__field(u8, bank_group)\t \n\t\t__field(u8, bank)\t \n\t\t__field(u8, dpa_flags)\t \n\t),\n\n\tTP_fast_assign(\n\t\tCXL_EVT_TP_fast_assign(cxlmd, log, rec->hdr);\n\n\t\t \n\t\t__entry->dpa = le64_to_cpu(rec->phys_addr);\n\t\t__entry->dpa_flags = __entry->dpa & CXL_DPA_FLAGS_MASK;\n\t\t__entry->dpa &= CXL_DPA_MASK;\n\t\t__entry->descriptor = rec->descriptor;\n\t\t__entry->type = rec->type;\n\t\t__entry->transaction_type = rec->transaction_type;\n\t\t__entry->validity_flags = get_unaligned_le16(rec->validity_flags);\n\t\t__entry->channel = rec->channel;\n\t\t__entry->rank = rec->rank;\n\t\t__entry->nibble_mask = get_unaligned_le24(rec->nibble_mask);\n\t\t__entry->bank_group = rec->bank_group;\n\t\t__entry->bank = rec->bank;\n\t\t__entry->row = get_unaligned_le24(rec->row);\n\t\t__entry->column = get_unaligned_le16(rec->column);\n\t\tmemcpy(__entry->cor_mask, &rec->correction_mask,\n\t\t\tCXL_EVENT_DER_CORRECTION_MASK_SIZE);\n\t),\n\n\tCXL_EVT_TP_printk(\"dpa=%llx dpa_flags='%s' descriptor='%s' type='%s' \" \\\n\t\t\"transaction_type='%s' channel=%u rank=%u nibble_mask=%x \" \\\n\t\t\"bank_group=%u bank=%u row=%u column=%u cor_mask=%s \" \\\n\t\t\"validity_flags='%s'\",\n\t\t__entry->dpa, show_dpa_flags(__entry->dpa_flags),\n\t\tshow_event_desc_flags(__entry->descriptor),\n\t\tshow_mem_event_type(__entry->type),\n\t\tshow_trans_type(__entry->transaction_type),\n\t\t__entry->channel, __entry->rank, __entry->nibble_mask,\n\t\t__entry->bank_group, __entry->bank,\n\t\t__entry->row, __entry->column,\n\t\t__print_hex(__entry->cor_mask, CXL_EVENT_DER_CORRECTION_MASK_SIZE),\n\t\tshow_dram_valid_flags(__entry->validity_flags)\n\t)\n);\n\n \n#define CXL_MMER_HEALTH_STATUS_CHANGE\t\t0x00\n#define CXL_MMER_MEDIA_STATUS_CHANGE\t\t0x01\n#define CXL_MMER_LIFE_USED_CHANGE\t\t0x02\n#define CXL_MMER_TEMP_CHANGE\t\t\t0x03\n#define CXL_MMER_DATA_PATH_ERROR\t\t0x04\n#define CXL_MMER_LSA_ERROR\t\t\t0x05\n#define show_dev_evt_type(type)\t__print_symbolic(type,\t\t\t   \\\n\t{ CXL_MMER_HEALTH_STATUS_CHANGE,\t\"Health Status Change\"\t}, \\\n\t{ CXL_MMER_MEDIA_STATUS_CHANGE,\t\t\"Media Status Change\"\t}, \\\n\t{ CXL_MMER_LIFE_USED_CHANGE,\t\t\"Life Used Change\"\t}, \\\n\t{ CXL_MMER_TEMP_CHANGE,\t\t\t\"Temperature Change\"\t}, \\\n\t{ CXL_MMER_DATA_PATH_ERROR,\t\t\"Data Path Error\"\t}, \\\n\t{ CXL_MMER_LSA_ERROR,\t\t\t\"LSA Error\"\t\t}  \\\n)\n\n \n#define CXL_DHI_HS_MAINTENANCE_NEEDED\t\t\t\tBIT(0)\n#define CXL_DHI_HS_PERFORMANCE_DEGRADED\t\t\t\tBIT(1)\n#define CXL_DHI_HS_HW_REPLACEMENT_NEEDED\t\t\tBIT(2)\n#define show_health_status_flags(flags)\t__print_flags(flags, \"|\",\t   \\\n\t{ CXL_DHI_HS_MAINTENANCE_NEEDED,\t\"MAINTENANCE_NEEDED\"\t}, \\\n\t{ CXL_DHI_HS_PERFORMANCE_DEGRADED,\t\"PERFORMANCE_DEGRADED\"\t}, \\\n\t{ CXL_DHI_HS_HW_REPLACEMENT_NEEDED,\t\"REPLACEMENT_NEEDED\"\t}  \\\n)\n\n#define CXL_DHI_MS_NORMAL\t\t\t\t\t\t\t0x00\n#define CXL_DHI_MS_NOT_READY\t\t\t\t\t\t\t0x01\n#define CXL_DHI_MS_WRITE_PERSISTENCY_LOST\t\t\t\t\t0x02\n#define CXL_DHI_MS_ALL_DATA_LOST\t\t\t\t\t\t0x03\n#define CXL_DHI_MS_WRITE_PERSISTENCY_LOSS_EVENT_POWER_LOSS\t\t\t0x04\n#define CXL_DHI_MS_WRITE_PERSISTENCY_LOSS_EVENT_SHUTDOWN\t\t\t0x05\n#define CXL_DHI_MS_WRITE_PERSISTENCY_LOSS_IMMINENT\t\t\t\t0x06\n#define CXL_DHI_MS_WRITE_ALL_DATA_LOSS_EVENT_POWER_LOSS\t\t\t\t0x07\n#define CXL_DHI_MS_WRITE_ALL_DATA_LOSS_EVENT_SHUTDOWN\t\t\t\t0x08\n#define CXL_DHI_MS_WRITE_ALL_DATA_LOSS_IMMINENT\t\t\t\t\t0x09\n#define show_media_status(ms)\t__print_symbolic(ms,\t\t\t   \\\n\t{ CXL_DHI_MS_NORMAL,\t\t\t\t\t\t   \\\n\t\t\"Normal\"\t\t\t\t\t\t}, \\\n\t{ CXL_DHI_MS_NOT_READY,\t\t\t\t\t\t   \\\n\t\t\"Not Ready\"\t\t\t\t\t\t}, \\\n\t{ CXL_DHI_MS_WRITE_PERSISTENCY_LOST,\t\t\t\t   \\\n\t\t\"Write Persistency Lost\"\t\t\t\t}, \\\n\t{ CXL_DHI_MS_ALL_DATA_LOST,\t\t\t\t\t   \\\n\t\t\"All Data Lost\"\t\t\t\t\t\t}, \\\n\t{ CXL_DHI_MS_WRITE_PERSISTENCY_LOSS_EVENT_POWER_LOSS,\t\t   \\\n\t\t\"Write Persistency Loss in the Event of Power Loss\"\t}, \\\n\t{ CXL_DHI_MS_WRITE_PERSISTENCY_LOSS_EVENT_SHUTDOWN,\t\t   \\\n\t\t\"Write Persistency Loss in Event of Shutdown\"\t\t}, \\\n\t{ CXL_DHI_MS_WRITE_PERSISTENCY_LOSS_IMMINENT,\t\t\t   \\\n\t\t\"Write Persistency Loss Imminent\"\t\t\t}, \\\n\t{ CXL_DHI_MS_WRITE_ALL_DATA_LOSS_EVENT_POWER_LOSS,\t\t   \\\n\t\t\"All Data Loss in Event of Power Loss\"\t\t\t}, \\\n\t{ CXL_DHI_MS_WRITE_ALL_DATA_LOSS_EVENT_SHUTDOWN,\t\t   \\\n\t\t\"All Data loss in the Event of Shutdown\"\t\t}, \\\n\t{ CXL_DHI_MS_WRITE_ALL_DATA_LOSS_IMMINENT,\t\t\t   \\\n\t\t\"All Data Loss Imminent\"\t\t\t\t}  \\\n)\n\n#define CXL_DHI_AS_NORMAL\t\t0x0\n#define CXL_DHI_AS_WARNING\t\t0x1\n#define CXL_DHI_AS_CRITICAL\t\t0x2\n#define show_two_bit_status(as) __print_symbolic(as,\t   \\\n\t{ CXL_DHI_AS_NORMAL,\t\t\"Normal\"\t}, \\\n\t{ CXL_DHI_AS_WARNING,\t\t\"Warning\"\t}, \\\n\t{ CXL_DHI_AS_CRITICAL,\t\t\"Critical\"\t}  \\\n)\n#define show_one_bit_status(as) __print_symbolic(as,\t   \\\n\t{ CXL_DHI_AS_NORMAL,\t\t\"Normal\"\t}, \\\n\t{ CXL_DHI_AS_WARNING,\t\t\"Warning\"\t}  \\\n)\n\n#define CXL_DHI_AS_LIFE_USED(as)\t\t\t(as & 0x3)\n#define CXL_DHI_AS_DEV_TEMP(as)\t\t\t\t((as & 0xC) >> 2)\n#define CXL_DHI_AS_COR_VOL_ERR_CNT(as)\t\t\t((as & 0x10) >> 4)\n#define CXL_DHI_AS_COR_PER_ERR_CNT(as)\t\t\t((as & 0x20) >> 5)\n\nTRACE_EVENT(cxl_memory_module,\n\n\tTP_PROTO(const struct cxl_memdev *cxlmd, enum cxl_event_log_type log,\n\t\t struct cxl_event_mem_module *rec),\n\n\tTP_ARGS(cxlmd, log, rec),\n\n\tTP_STRUCT__entry(\n\t\tCXL_EVT_TP_entry\n\n\t\t \n\t\t__field(u8, event_type)\n\n\t\t \n\t\t__field(u8, health_status)\n\t\t__field(u8, media_status)\n\t\t__field(u8, life_used)\n\t\t__field(u32, dirty_shutdown_cnt)\n\t\t__field(u32, cor_vol_err_cnt)\n\t\t__field(u32, cor_per_err_cnt)\n\t\t__field(s16, device_temp)\n\t\t__field(u8, add_status)\n\t),\n\n\tTP_fast_assign(\n\t\tCXL_EVT_TP_fast_assign(cxlmd, log, rec->hdr);\n\n\t\t \n\t\t__entry->event_type = rec->event_type;\n\n\t\t \n\t\t__entry->health_status = rec->info.health_status;\n\t\t__entry->media_status = rec->info.media_status;\n\t\t__entry->life_used = rec->info.life_used;\n\t\t__entry->dirty_shutdown_cnt = get_unaligned_le32(rec->info.dirty_shutdown_cnt);\n\t\t__entry->cor_vol_err_cnt = get_unaligned_le32(rec->info.cor_vol_err_cnt);\n\t\t__entry->cor_per_err_cnt = get_unaligned_le32(rec->info.cor_per_err_cnt);\n\t\t__entry->device_temp = get_unaligned_le16(rec->info.device_temp);\n\t\t__entry->add_status = rec->info.add_status;\n\t),\n\n\tCXL_EVT_TP_printk(\"event_type='%s' health_status='%s' media_status='%s' \" \\\n\t\t\"as_life_used=%s as_dev_temp=%s as_cor_vol_err_cnt=%s \" \\\n\t\t\"as_cor_per_err_cnt=%s life_used=%u device_temp=%d \" \\\n\t\t\"dirty_shutdown_cnt=%u cor_vol_err_cnt=%u cor_per_err_cnt=%u\",\n\t\tshow_dev_evt_type(__entry->event_type),\n\t\tshow_health_status_flags(__entry->health_status),\n\t\tshow_media_status(__entry->media_status),\n\t\tshow_two_bit_status(CXL_DHI_AS_LIFE_USED(__entry->add_status)),\n\t\tshow_two_bit_status(CXL_DHI_AS_DEV_TEMP(__entry->add_status)),\n\t\tshow_one_bit_status(CXL_DHI_AS_COR_VOL_ERR_CNT(__entry->add_status)),\n\t\tshow_one_bit_status(CXL_DHI_AS_COR_PER_ERR_CNT(__entry->add_status)),\n\t\t__entry->life_used, __entry->device_temp,\n\t\t__entry->dirty_shutdown_cnt, __entry->cor_vol_err_cnt,\n\t\t__entry->cor_per_err_cnt\n\t)\n);\n\n#define show_poison_trace_type(type)\t\t\t\\\n\t__print_symbolic(type,\t\t\t\t\\\n\t{ CXL_POISON_TRACE_LIST,\t\"List\"   },\t\\\n\t{ CXL_POISON_TRACE_INJECT,\t\"Inject\" },\t\\\n\t{ CXL_POISON_TRACE_CLEAR,\t\"Clear\"  })\n\n#define __show_poison_source(source)                          \\\n\t__print_symbolic(source,                              \\\n\t\t{ CXL_POISON_SOURCE_UNKNOWN,   \"Unknown\"  },  \\\n\t\t{ CXL_POISON_SOURCE_EXTERNAL,  \"External\" },  \\\n\t\t{ CXL_POISON_SOURCE_INTERNAL,  \"Internal\" },  \\\n\t\t{ CXL_POISON_SOURCE_INJECTED,  \"Injected\" },  \\\n\t\t{ CXL_POISON_SOURCE_VENDOR,    \"Vendor\"   })\n\n#define show_poison_source(source)\t\t\t     \\\n\t(((source > CXL_POISON_SOURCE_INJECTED) &&\t     \\\n\t (source != CXL_POISON_SOURCE_VENDOR)) ? \"Reserved\"  \\\n\t : __show_poison_source(source))\n\n#define show_poison_flags(flags)                             \\\n\t__print_flags(flags, \"|\",                            \\\n\t\t{ CXL_POISON_FLAG_MORE,      \"More\"     },   \\\n\t\t{ CXL_POISON_FLAG_OVERFLOW,  \"Overflow\"  },  \\\n\t\t{ CXL_POISON_FLAG_SCANNING,  \"Scanning\"  })\n\n#define __cxl_poison_addr(record)\t\t\t\t\t\\\n\t(le64_to_cpu(record->address))\n#define cxl_poison_record_dpa(record)\t\t\t\t\t\\\n\t(__cxl_poison_addr(record) & CXL_POISON_START_MASK)\n#define cxl_poison_record_source(record)\t\t\t\t\\\n\t(__cxl_poison_addr(record)  & CXL_POISON_SOURCE_MASK)\n#define cxl_poison_record_dpa_length(record)\t\t\t\t\\\n\t(le32_to_cpu(record->length) * CXL_POISON_LEN_MULT)\n#define cxl_poison_overflow(flags, time)\t\t\t\t\\\n\t(flags & CXL_POISON_FLAG_OVERFLOW ? le64_to_cpu(time) : 0)\n\nu64 cxl_trace_hpa(struct cxl_region *cxlr, struct cxl_memdev *memdev, u64 dpa);\n\nTRACE_EVENT(cxl_poison,\n\n\tTP_PROTO(struct cxl_memdev *cxlmd, struct cxl_region *region,\n\t\t const struct cxl_poison_record *record, u8 flags,\n\t\t __le64 overflow_ts, enum cxl_poison_trace_type trace_type),\n\n\tTP_ARGS(cxlmd, region, record, flags, overflow_ts, trace_type),\n\n\tTP_STRUCT__entry(\n\t\t__string(memdev, dev_name(&cxlmd->dev))\n\t\t__string(host, dev_name(cxlmd->dev.parent))\n\t\t__field(u64, serial)\n\t\t__field(u8, trace_type)\n\t\t__string(region, region)\n\t\t__field(u64, overflow_ts)\n\t\t__field(u64, hpa)\n\t\t__field(u64, dpa)\n\t\t__field(u32, dpa_length)\n\t\t__array(char, uuid, 16)\n\t\t__field(u8, source)\n\t\t__field(u8, flags)\n\t    ),\n\n\tTP_fast_assign(\n\t\t__assign_str(memdev, dev_name(&cxlmd->dev));\n\t\t__assign_str(host, dev_name(cxlmd->dev.parent));\n\t\t__entry->serial = cxlmd->cxlds->serial;\n\t\t__entry->overflow_ts = cxl_poison_overflow(flags, overflow_ts);\n\t\t__entry->dpa = cxl_poison_record_dpa(record);\n\t\t__entry->dpa_length = cxl_poison_record_dpa_length(record);\n\t\t__entry->source = cxl_poison_record_source(record);\n\t\t__entry->trace_type = trace_type;\n\t\t__entry->flags = flags;\n\t\tif (region) {\n\t\t\t__assign_str(region, dev_name(&region->dev));\n\t\t\tmemcpy(__entry->uuid, &region->params.uuid, 16);\n\t\t\t__entry->hpa = cxl_trace_hpa(region, cxlmd,\n\t\t\t\t\t\t     __entry->dpa);\n\t\t} else {\n\t\t\t__assign_str(region, \"\");\n\t\t\tmemset(__entry->uuid, 0, 16);\n\t\t\t__entry->hpa = ULLONG_MAX;\n\t\t}\n\t    ),\n\n\tTP_printk(\"memdev=%s host=%s serial=%lld trace_type=%s region=%s \"  \\\n\t\t\"region_uuid=%pU hpa=0x%llx dpa=0x%llx dpa_length=0x%x \"    \\\n\t\t\"source=%s flags=%s overflow_time=%llu\",\n\t\t__get_str(memdev),\n\t\t__get_str(host),\n\t\t__entry->serial,\n\t\tshow_poison_trace_type(__entry->trace_type),\n\t\t__get_str(region),\n\t\t__entry->uuid,\n\t\t__entry->hpa,\n\t\t__entry->dpa,\n\t\t__entry->dpa_length,\n\t\tshow_poison_source(__entry->source),\n\t\tshow_poison_flags(__entry->flags),\n\t\t__entry->overflow_ts\n\t)\n);\n\n#endif  \n\n#define TRACE_INCLUDE_FILE trace\n#include <trace/define_trace.h>\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}