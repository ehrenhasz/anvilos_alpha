{
  "module_name": "hdm.c",
  "hash_id": "93f30a6bad4aca3cb6fe9c210bbb9c04cb7caa607692a5d752552227effc58af",
  "original_prompt": "Ingested from linux-6.6.14/drivers/cxl/core/hdm.c",
  "human_readable_source": "\n \n#include <linux/seq_file.h>\n#include <linux/device.h>\n#include <linux/delay.h>\n\n#include \"cxlmem.h\"\n#include \"core.h\"\n\n \n\nDECLARE_RWSEM(cxl_dpa_rwsem);\n\nstatic int add_hdm_decoder(struct cxl_port *port, struct cxl_decoder *cxld,\n\t\t\t   int *target_map)\n{\n\tint rc;\n\n\trc = cxl_decoder_add_locked(cxld, target_map);\n\tif (rc) {\n\t\tput_device(&cxld->dev);\n\t\tdev_err(&port->dev, \"Failed to add decoder\\n\");\n\t\treturn rc;\n\t}\n\n\trc = cxl_decoder_autoremove(&port->dev, cxld);\n\tif (rc)\n\t\treturn rc;\n\n\tdev_dbg(&cxld->dev, \"Added to port %s\\n\", dev_name(&port->dev));\n\n\treturn 0;\n}\n\n \nint devm_cxl_add_passthrough_decoder(struct cxl_port *port)\n{\n\tstruct cxl_switch_decoder *cxlsd;\n\tstruct cxl_dport *dport = NULL;\n\tint single_port_map[1];\n\tunsigned long index;\n\n\tcxlsd = cxl_switch_decoder_alloc(port, 1);\n\tif (IS_ERR(cxlsd))\n\t\treturn PTR_ERR(cxlsd);\n\n\tdevice_lock_assert(&port->dev);\n\n\txa_for_each(&port->dports, index, dport)\n\t\tbreak;\n\tsingle_port_map[0] = dport->port_id;\n\n\treturn add_hdm_decoder(port, &cxlsd->cxld, single_port_map);\n}\nEXPORT_SYMBOL_NS_GPL(devm_cxl_add_passthrough_decoder, CXL);\n\nstatic void parse_hdm_decoder_caps(struct cxl_hdm *cxlhdm)\n{\n\tu32 hdm_cap;\n\n\thdm_cap = readl(cxlhdm->regs.hdm_decoder + CXL_HDM_DECODER_CAP_OFFSET);\n\tcxlhdm->decoder_count = cxl_hdm_decoder_count(hdm_cap);\n\tcxlhdm->target_count =\n\t\tFIELD_GET(CXL_HDM_DECODER_TARGET_COUNT_MASK, hdm_cap);\n\tif (FIELD_GET(CXL_HDM_DECODER_INTERLEAVE_11_8, hdm_cap))\n\t\tcxlhdm->interleave_mask |= GENMASK(11, 8);\n\tif (FIELD_GET(CXL_HDM_DECODER_INTERLEAVE_14_12, hdm_cap))\n\t\tcxlhdm->interleave_mask |= GENMASK(14, 12);\n}\n\nstatic int map_hdm_decoder_regs(struct cxl_port *port, void __iomem *crb,\n\t\t\t\tstruct cxl_component_regs *regs)\n{\n\tstruct cxl_register_map map = {\n\t\t.host = &port->dev,\n\t\t.resource = port->component_reg_phys,\n\t\t.base = crb,\n\t\t.max_size = CXL_COMPONENT_REG_BLOCK_SIZE,\n\t};\n\n\tcxl_probe_component_regs(&port->dev, crb, &map.component_map);\n\tif (!map.component_map.hdm_decoder.valid) {\n\t\tdev_dbg(&port->dev, \"HDM decoder registers not implemented\\n\");\n\t\t \n\t\treturn -ENODEV;\n\t}\n\n\treturn cxl_map_component_regs(&map, regs, BIT(CXL_CM_CAP_CAP_ID_HDM));\n}\n\nstatic bool should_emulate_decoders(struct cxl_endpoint_dvsec_info *info)\n{\n\tstruct cxl_hdm *cxlhdm;\n\tvoid __iomem *hdm;\n\tu32 ctrl;\n\tint i;\n\n\tif (!info)\n\t\treturn false;\n\n\tcxlhdm = dev_get_drvdata(&info->port->dev);\n\thdm = cxlhdm->regs.hdm_decoder;\n\n\tif (!hdm)\n\t\treturn true;\n\n\t \n\tif (!info->mem_enabled)\n\t\treturn false;\n\n\t \n\tfor (i = 0; i < cxlhdm->decoder_count; i++) {\n\t\tctrl = readl(hdm + CXL_HDM_DECODER0_CTRL_OFFSET(i));\n\t\tdev_dbg(&info->port->dev,\n\t\t\t\"decoder%d.%d: committed: %ld base: %#x_%.8x size: %#x_%.8x\\n\",\n\t\t\tinfo->port->id, i,\n\t\t\tFIELD_GET(CXL_HDM_DECODER0_CTRL_COMMITTED, ctrl),\n\t\t\treadl(hdm + CXL_HDM_DECODER0_BASE_HIGH_OFFSET(i)),\n\t\t\treadl(hdm + CXL_HDM_DECODER0_BASE_LOW_OFFSET(i)),\n\t\t\treadl(hdm + CXL_HDM_DECODER0_SIZE_HIGH_OFFSET(i)),\n\t\t\treadl(hdm + CXL_HDM_DECODER0_SIZE_LOW_OFFSET(i)));\n\t\tif (FIELD_GET(CXL_HDM_DECODER0_CTRL_COMMITTED, ctrl))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n \nstruct cxl_hdm *devm_cxl_setup_hdm(struct cxl_port *port,\n\t\t\t\t   struct cxl_endpoint_dvsec_info *info)\n{\n\tstruct device *dev = &port->dev;\n\tstruct cxl_hdm *cxlhdm;\n\tvoid __iomem *crb;\n\tint rc;\n\n\tcxlhdm = devm_kzalloc(dev, sizeof(*cxlhdm), GFP_KERNEL);\n\tif (!cxlhdm)\n\t\treturn ERR_PTR(-ENOMEM);\n\tcxlhdm->port = port;\n\tdev_set_drvdata(dev, cxlhdm);\n\n\tcrb = ioremap(port->component_reg_phys, CXL_COMPONENT_REG_BLOCK_SIZE);\n\tif (!crb && info && info->mem_enabled) {\n\t\tcxlhdm->decoder_count = info->ranges;\n\t\treturn cxlhdm;\n\t} else if (!crb) {\n\t\tdev_err(dev, \"No component registers mapped\\n\");\n\t\treturn ERR_PTR(-ENXIO);\n\t}\n\n\trc = map_hdm_decoder_regs(port, crb, &cxlhdm->regs);\n\tiounmap(crb);\n\tif (rc)\n\t\treturn ERR_PTR(rc);\n\n\tparse_hdm_decoder_caps(cxlhdm);\n\tif (cxlhdm->decoder_count == 0) {\n\t\tdev_err(dev, \"Spec violation. Caps invalid\\n\");\n\t\treturn ERR_PTR(-ENXIO);\n\t}\n\n\t \n\tif (should_emulate_decoders(info)) {\n\t\tdev_dbg(dev, \"Fallback map %d range register%s\\n\", info->ranges,\n\t\t\tinfo->ranges > 1 ? \"s\" : \"\");\n\t\tcxlhdm->decoder_count = info->ranges;\n\t}\n\n\treturn cxlhdm;\n}\nEXPORT_SYMBOL_NS_GPL(devm_cxl_setup_hdm, CXL);\n\nstatic void __cxl_dpa_debug(struct seq_file *file, struct resource *r, int depth)\n{\n\tunsigned long long start = r->start, end = r->end;\n\n\tseq_printf(file, \"%*s%08llx-%08llx : %s\\n\", depth * 2, \"\", start, end,\n\t\t   r->name);\n}\n\nvoid cxl_dpa_debug(struct seq_file *file, struct cxl_dev_state *cxlds)\n{\n\tstruct resource *p1, *p2;\n\n\tdown_read(&cxl_dpa_rwsem);\n\tfor (p1 = cxlds->dpa_res.child; p1; p1 = p1->sibling) {\n\t\t__cxl_dpa_debug(file, p1, 0);\n\t\tfor (p2 = p1->child; p2; p2 = p2->sibling)\n\t\t\t__cxl_dpa_debug(file, p2, 1);\n\t}\n\tup_read(&cxl_dpa_rwsem);\n}\nEXPORT_SYMBOL_NS_GPL(cxl_dpa_debug, CXL);\n\n \nstatic void __cxl_dpa_release(struct cxl_endpoint_decoder *cxled)\n{\n\tstruct cxl_memdev *cxlmd = cxled_to_memdev(cxled);\n\tstruct cxl_port *port = cxled_to_port(cxled);\n\tstruct cxl_dev_state *cxlds = cxlmd->cxlds;\n\tstruct resource *res = cxled->dpa_res;\n\tresource_size_t skip_start;\n\n\tlockdep_assert_held_write(&cxl_dpa_rwsem);\n\n\t \n\tskip_start = res->start - cxled->skip;\n\t__release_region(&cxlds->dpa_res, res->start, resource_size(res));\n\tif (cxled->skip)\n\t\t__release_region(&cxlds->dpa_res, skip_start, cxled->skip);\n\tcxled->skip = 0;\n\tcxled->dpa_res = NULL;\n\tput_device(&cxled->cxld.dev);\n\tport->hdm_end--;\n}\n\nstatic void cxl_dpa_release(void *cxled)\n{\n\tdown_write(&cxl_dpa_rwsem);\n\t__cxl_dpa_release(cxled);\n\tup_write(&cxl_dpa_rwsem);\n}\n\n \nstatic void devm_cxl_dpa_release(struct cxl_endpoint_decoder *cxled)\n{\n\tstruct cxl_port *port = cxled_to_port(cxled);\n\n\tlockdep_assert_held_write(&cxl_dpa_rwsem);\n\tdevm_remove_action(&port->dev, cxl_dpa_release, cxled);\n\t__cxl_dpa_release(cxled);\n}\n\nstatic int __cxl_dpa_reserve(struct cxl_endpoint_decoder *cxled,\n\t\t\t     resource_size_t base, resource_size_t len,\n\t\t\t     resource_size_t skipped)\n{\n\tstruct cxl_memdev *cxlmd = cxled_to_memdev(cxled);\n\tstruct cxl_port *port = cxled_to_port(cxled);\n\tstruct cxl_dev_state *cxlds = cxlmd->cxlds;\n\tstruct device *dev = &port->dev;\n\tstruct resource *res;\n\n\tlockdep_assert_held_write(&cxl_dpa_rwsem);\n\n\tif (!len) {\n\t\tdev_warn(dev, \"decoder%d.%d: empty reservation attempted\\n\",\n\t\t\t port->id, cxled->cxld.id);\n\t\treturn -EINVAL;\n\t}\n\n\tif (cxled->dpa_res) {\n\t\tdev_dbg(dev, \"decoder%d.%d: existing allocation %pr assigned\\n\",\n\t\t\tport->id, cxled->cxld.id, cxled->dpa_res);\n\t\treturn -EBUSY;\n\t}\n\n\tif (port->hdm_end + 1 != cxled->cxld.id) {\n\t\t \n\t\tdev_dbg(dev, \"decoder%d.%d: expected decoder%d.%d\\n\", port->id,\n\t\t\tcxled->cxld.id, port->id, port->hdm_end + 1);\n\t\treturn -EBUSY;\n\t}\n\n\tif (skipped) {\n\t\tres = __request_region(&cxlds->dpa_res, base - skipped, skipped,\n\t\t\t\t       dev_name(&cxled->cxld.dev), 0);\n\t\tif (!res) {\n\t\t\tdev_dbg(dev,\n\t\t\t\t\"decoder%d.%d: failed to reserve skipped space\\n\",\n\t\t\t\tport->id, cxled->cxld.id);\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\tres = __request_region(&cxlds->dpa_res, base, len,\n\t\t\t       dev_name(&cxled->cxld.dev), 0);\n\tif (!res) {\n\t\tdev_dbg(dev, \"decoder%d.%d: failed to reserve allocation\\n\",\n\t\t\tport->id, cxled->cxld.id);\n\t\tif (skipped)\n\t\t\t__release_region(&cxlds->dpa_res, base - skipped,\n\t\t\t\t\t skipped);\n\t\treturn -EBUSY;\n\t}\n\tcxled->dpa_res = res;\n\tcxled->skip = skipped;\n\n\tif (resource_contains(&cxlds->pmem_res, res))\n\t\tcxled->mode = CXL_DECODER_PMEM;\n\telse if (resource_contains(&cxlds->ram_res, res))\n\t\tcxled->mode = CXL_DECODER_RAM;\n\telse {\n\t\tdev_dbg(dev, \"decoder%d.%d: %pr mixed\\n\", port->id,\n\t\t\tcxled->cxld.id, cxled->dpa_res);\n\t\tcxled->mode = CXL_DECODER_MIXED;\n\t}\n\n\tport->hdm_end++;\n\tget_device(&cxled->cxld.dev);\n\treturn 0;\n}\n\nint devm_cxl_dpa_reserve(struct cxl_endpoint_decoder *cxled,\n\t\t\t\tresource_size_t base, resource_size_t len,\n\t\t\t\tresource_size_t skipped)\n{\n\tstruct cxl_port *port = cxled_to_port(cxled);\n\tint rc;\n\n\tdown_write(&cxl_dpa_rwsem);\n\trc = __cxl_dpa_reserve(cxled, base, len, skipped);\n\tup_write(&cxl_dpa_rwsem);\n\n\tif (rc)\n\t\treturn rc;\n\n\treturn devm_add_action_or_reset(&port->dev, cxl_dpa_release, cxled);\n}\nEXPORT_SYMBOL_NS_GPL(devm_cxl_dpa_reserve, CXL);\n\nresource_size_t cxl_dpa_size(struct cxl_endpoint_decoder *cxled)\n{\n\tresource_size_t size = 0;\n\n\tdown_read(&cxl_dpa_rwsem);\n\tif (cxled->dpa_res)\n\t\tsize = resource_size(cxled->dpa_res);\n\tup_read(&cxl_dpa_rwsem);\n\n\treturn size;\n}\n\nresource_size_t cxl_dpa_resource_start(struct cxl_endpoint_decoder *cxled)\n{\n\tresource_size_t base = -1;\n\n\tlockdep_assert_held(&cxl_dpa_rwsem);\n\tif (cxled->dpa_res)\n\t\tbase = cxled->dpa_res->start;\n\n\treturn base;\n}\n\nint cxl_dpa_free(struct cxl_endpoint_decoder *cxled)\n{\n\tstruct cxl_port *port = cxled_to_port(cxled);\n\tstruct device *dev = &cxled->cxld.dev;\n\tint rc;\n\n\tdown_write(&cxl_dpa_rwsem);\n\tif (!cxled->dpa_res) {\n\t\trc = 0;\n\t\tgoto out;\n\t}\n\tif (cxled->cxld.region) {\n\t\tdev_dbg(dev, \"decoder assigned to: %s\\n\",\n\t\t\tdev_name(&cxled->cxld.region->dev));\n\t\trc = -EBUSY;\n\t\tgoto out;\n\t}\n\tif (cxled->cxld.flags & CXL_DECODER_F_ENABLE) {\n\t\tdev_dbg(dev, \"decoder enabled\\n\");\n\t\trc = -EBUSY;\n\t\tgoto out;\n\t}\n\tif (cxled->cxld.id != port->hdm_end) {\n\t\tdev_dbg(dev, \"expected decoder%d.%d\\n\", port->id,\n\t\t\tport->hdm_end);\n\t\trc = -EBUSY;\n\t\tgoto out;\n\t}\n\tdevm_cxl_dpa_release(cxled);\n\trc = 0;\nout:\n\tup_write(&cxl_dpa_rwsem);\n\treturn rc;\n}\n\nint cxl_dpa_set_mode(struct cxl_endpoint_decoder *cxled,\n\t\t     enum cxl_decoder_mode mode)\n{\n\tstruct cxl_memdev *cxlmd = cxled_to_memdev(cxled);\n\tstruct cxl_dev_state *cxlds = cxlmd->cxlds;\n\tstruct device *dev = &cxled->cxld.dev;\n\tint rc;\n\n\tswitch (mode) {\n\tcase CXL_DECODER_RAM:\n\tcase CXL_DECODER_PMEM:\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(dev, \"unsupported mode: %d\\n\", mode);\n\t\treturn -EINVAL;\n\t}\n\n\tdown_write(&cxl_dpa_rwsem);\n\tif (cxled->cxld.flags & CXL_DECODER_F_ENABLE) {\n\t\trc = -EBUSY;\n\t\tgoto out;\n\t}\n\n\t \n\tif (mode == CXL_DECODER_PMEM && !resource_size(&cxlds->pmem_res)) {\n\t\tdev_dbg(dev, \"no available pmem capacity\\n\");\n\t\trc = -ENXIO;\n\t\tgoto out;\n\t}\n\tif (mode == CXL_DECODER_RAM && !resource_size(&cxlds->ram_res)) {\n\t\tdev_dbg(dev, \"no available ram capacity\\n\");\n\t\trc = -ENXIO;\n\t\tgoto out;\n\t}\n\n\tcxled->mode = mode;\n\trc = 0;\nout:\n\tup_write(&cxl_dpa_rwsem);\n\n\treturn rc;\n}\n\nint cxl_dpa_alloc(struct cxl_endpoint_decoder *cxled, unsigned long long size)\n{\n\tstruct cxl_memdev *cxlmd = cxled_to_memdev(cxled);\n\tresource_size_t free_ram_start, free_pmem_start;\n\tstruct cxl_port *port = cxled_to_port(cxled);\n\tstruct cxl_dev_state *cxlds = cxlmd->cxlds;\n\tstruct device *dev = &cxled->cxld.dev;\n\tresource_size_t start, avail, skip;\n\tstruct resource *p, *last;\n\tint rc;\n\n\tdown_write(&cxl_dpa_rwsem);\n\tif (cxled->cxld.region) {\n\t\tdev_dbg(dev, \"decoder attached to %s\\n\",\n\t\t\tdev_name(&cxled->cxld.region->dev));\n\t\trc = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tif (cxled->cxld.flags & CXL_DECODER_F_ENABLE) {\n\t\tdev_dbg(dev, \"decoder enabled\\n\");\n\t\trc = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tfor (p = cxlds->ram_res.child, last = NULL; p; p = p->sibling)\n\t\tlast = p;\n\tif (last)\n\t\tfree_ram_start = last->end + 1;\n\telse\n\t\tfree_ram_start = cxlds->ram_res.start;\n\n\tfor (p = cxlds->pmem_res.child, last = NULL; p; p = p->sibling)\n\t\tlast = p;\n\tif (last)\n\t\tfree_pmem_start = last->end + 1;\n\telse\n\t\tfree_pmem_start = cxlds->pmem_res.start;\n\n\tif (cxled->mode == CXL_DECODER_RAM) {\n\t\tstart = free_ram_start;\n\t\tavail = cxlds->ram_res.end - start + 1;\n\t\tskip = 0;\n\t} else if (cxled->mode == CXL_DECODER_PMEM) {\n\t\tresource_size_t skip_start, skip_end;\n\n\t\tstart = free_pmem_start;\n\t\tavail = cxlds->pmem_res.end - start + 1;\n\t\tskip_start = free_ram_start;\n\n\t\t \n\t\tif (cxlds->pmem_res.child &&\n\t\t    skip_start == cxlds->pmem_res.child->start)\n\t\t\tskip_end = skip_start - 1;\n\t\telse\n\t\t\tskip_end = start - 1;\n\t\tskip = skip_end - skip_start + 1;\n\t} else {\n\t\tdev_dbg(dev, \"mode not set\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (size > avail) {\n\t\tdev_dbg(dev, \"%pa exceeds available %s capacity: %pa\\n\", &size,\n\t\t\tcxled->mode == CXL_DECODER_RAM ? \"ram\" : \"pmem\",\n\t\t\t&avail);\n\t\trc = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\trc = __cxl_dpa_reserve(cxled, start, size, skip);\nout:\n\tup_write(&cxl_dpa_rwsem);\n\n\tif (rc)\n\t\treturn rc;\n\n\treturn devm_add_action_or_reset(&port->dev, cxl_dpa_release, cxled);\n}\n\nstatic void cxld_set_interleave(struct cxl_decoder *cxld, u32 *ctrl)\n{\n\tu16 eig;\n\tu8 eiw;\n\n\t \n\tif (WARN_ONCE(ways_to_eiw(cxld->interleave_ways, &eiw),\n\t\t      \"invalid interleave_ways: %d\\n\", cxld->interleave_ways))\n\t\treturn;\n\tif (WARN_ONCE(granularity_to_eig(cxld->interleave_granularity, &eig),\n\t\t      \"invalid interleave_granularity: %d\\n\",\n\t\t      cxld->interleave_granularity))\n\t\treturn;\n\n\tu32p_replace_bits(ctrl, eig, CXL_HDM_DECODER0_CTRL_IG_MASK);\n\tu32p_replace_bits(ctrl, eiw, CXL_HDM_DECODER0_CTRL_IW_MASK);\n\t*ctrl |= CXL_HDM_DECODER0_CTRL_COMMIT;\n}\n\nstatic void cxld_set_type(struct cxl_decoder *cxld, u32 *ctrl)\n{\n\tu32p_replace_bits(ctrl,\n\t\t\t  !!(cxld->target_type == CXL_DECODER_HOSTONLYMEM),\n\t\t\t  CXL_HDM_DECODER0_CTRL_HOSTONLY);\n}\n\nstatic void cxlsd_set_targets(struct cxl_switch_decoder *cxlsd, u64 *tgt)\n{\n\tstruct cxl_dport **t = &cxlsd->target[0];\n\tint ways = cxlsd->cxld.interleave_ways;\n\n\t*tgt = FIELD_PREP(GENMASK(7, 0), t[0]->port_id);\n\tif (ways > 1)\n\t\t*tgt |= FIELD_PREP(GENMASK(15, 8), t[1]->port_id);\n\tif (ways > 2)\n\t\t*tgt |= FIELD_PREP(GENMASK(23, 16), t[2]->port_id);\n\tif (ways > 3)\n\t\t*tgt |= FIELD_PREP(GENMASK(31, 24), t[3]->port_id);\n\tif (ways > 4)\n\t\t*tgt |= FIELD_PREP(GENMASK_ULL(39, 32), t[4]->port_id);\n\tif (ways > 5)\n\t\t*tgt |= FIELD_PREP(GENMASK_ULL(47, 40), t[5]->port_id);\n\tif (ways > 6)\n\t\t*tgt |= FIELD_PREP(GENMASK_ULL(55, 48), t[6]->port_id);\n\tif (ways > 7)\n\t\t*tgt |= FIELD_PREP(GENMASK_ULL(63, 56), t[7]->port_id);\n}\n\n \n#define COMMIT_TIMEOUT_MS 20\nstatic int cxld_await_commit(void __iomem *hdm, int id)\n{\n\tu32 ctrl;\n\tint i;\n\n\tfor (i = 0; i < COMMIT_TIMEOUT_MS; i++) {\n\t\tctrl = readl(hdm + CXL_HDM_DECODER0_CTRL_OFFSET(id));\n\t\tif (FIELD_GET(CXL_HDM_DECODER0_CTRL_COMMIT_ERROR, ctrl)) {\n\t\t\tctrl &= ~CXL_HDM_DECODER0_CTRL_COMMIT;\n\t\t\twritel(ctrl, hdm + CXL_HDM_DECODER0_CTRL_OFFSET(id));\n\t\t\treturn -EIO;\n\t\t}\n\t\tif (FIELD_GET(CXL_HDM_DECODER0_CTRL_COMMITTED, ctrl))\n\t\t\treturn 0;\n\t\tfsleep(1000);\n\t}\n\n\treturn -ETIMEDOUT;\n}\n\nstatic int cxl_decoder_commit(struct cxl_decoder *cxld)\n{\n\tstruct cxl_port *port = to_cxl_port(cxld->dev.parent);\n\tstruct cxl_hdm *cxlhdm = dev_get_drvdata(&port->dev);\n\tvoid __iomem *hdm = cxlhdm->regs.hdm_decoder;\n\tint id = cxld->id, rc;\n\tu64 base, size;\n\tu32 ctrl;\n\n\tif (cxld->flags & CXL_DECODER_F_ENABLE)\n\t\treturn 0;\n\n\tif (cxl_num_decoders_committed(port) != id) {\n\t\tdev_dbg(&port->dev,\n\t\t\t\"%s: out of order commit, expected decoder%d.%d\\n\",\n\t\t\tdev_name(&cxld->dev), port->id,\n\t\t\tcxl_num_decoders_committed(port));\n\t\treturn -EBUSY;\n\t}\n\n\t \n\tif (is_endpoint_decoder(&cxld->dev)) {\n\t\tstruct cxl_endpoint_decoder *cxled =\n\t\t\tto_cxl_endpoint_decoder(&cxld->dev);\n\t\tstruct cxl_memdev *cxlmd = cxled_to_memdev(cxled);\n\t\tstruct cxl_memdev_state *mds =\n\t\t\tto_cxl_memdev_state(cxlmd->cxlds);\n\n\t\tif (mds && mds->security.sanitize_active) {\n\t\t\tdev_dbg(&cxlmd->dev,\n\t\t\t\t\"attempted to commit %s during sanitize\\n\",\n\t\t\t\tdev_name(&cxld->dev));\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\n\tdown_read(&cxl_dpa_rwsem);\n\t \n\tctrl = readl(hdm + CXL_HDM_DECODER0_CTRL_OFFSET(cxld->id));\n\tcxld_set_interleave(cxld, &ctrl);\n\tcxld_set_type(cxld, &ctrl);\n\tbase = cxld->hpa_range.start;\n\tsize = range_len(&cxld->hpa_range);\n\n\twritel(upper_32_bits(base), hdm + CXL_HDM_DECODER0_BASE_HIGH_OFFSET(id));\n\twritel(lower_32_bits(base), hdm + CXL_HDM_DECODER0_BASE_LOW_OFFSET(id));\n\twritel(upper_32_bits(size), hdm + CXL_HDM_DECODER0_SIZE_HIGH_OFFSET(id));\n\twritel(lower_32_bits(size), hdm + CXL_HDM_DECODER0_SIZE_LOW_OFFSET(id));\n\n\tif (is_switch_decoder(&cxld->dev)) {\n\t\tstruct cxl_switch_decoder *cxlsd =\n\t\t\tto_cxl_switch_decoder(&cxld->dev);\n\t\tvoid __iomem *tl_hi = hdm + CXL_HDM_DECODER0_TL_HIGH(id);\n\t\tvoid __iomem *tl_lo = hdm + CXL_HDM_DECODER0_TL_LOW(id);\n\t\tu64 targets;\n\n\t\tcxlsd_set_targets(cxlsd, &targets);\n\t\twritel(upper_32_bits(targets), tl_hi);\n\t\twritel(lower_32_bits(targets), tl_lo);\n\t} else {\n\t\tstruct cxl_endpoint_decoder *cxled =\n\t\t\tto_cxl_endpoint_decoder(&cxld->dev);\n\t\tvoid __iomem *sk_hi = hdm + CXL_HDM_DECODER0_SKIP_HIGH(id);\n\t\tvoid __iomem *sk_lo = hdm + CXL_HDM_DECODER0_SKIP_LOW(id);\n\n\t\twritel(upper_32_bits(cxled->skip), sk_hi);\n\t\twritel(lower_32_bits(cxled->skip), sk_lo);\n\t}\n\n\twritel(ctrl, hdm + CXL_HDM_DECODER0_CTRL_OFFSET(id));\n\tup_read(&cxl_dpa_rwsem);\n\n\tport->commit_end++;\n\trc = cxld_await_commit(hdm, cxld->id);\n\tif (rc) {\n\t\tdev_dbg(&port->dev, \"%s: error %d committing decoder\\n\",\n\t\t\tdev_name(&cxld->dev), rc);\n\t\tcxld->reset(cxld);\n\t\treturn rc;\n\t}\n\tcxld->flags |= CXL_DECODER_F_ENABLE;\n\n\treturn 0;\n}\n\nstatic int cxl_decoder_reset(struct cxl_decoder *cxld)\n{\n\tstruct cxl_port *port = to_cxl_port(cxld->dev.parent);\n\tstruct cxl_hdm *cxlhdm = dev_get_drvdata(&port->dev);\n\tvoid __iomem *hdm = cxlhdm->regs.hdm_decoder;\n\tint id = cxld->id;\n\tu32 ctrl;\n\n\tif ((cxld->flags & CXL_DECODER_F_ENABLE) == 0)\n\t\treturn 0;\n\n\tif (port->commit_end != id) {\n\t\tdev_dbg(&port->dev,\n\t\t\t\"%s: out of order reset, expected decoder%d.%d\\n\",\n\t\t\tdev_name(&cxld->dev), port->id, port->commit_end);\n\t\treturn -EBUSY;\n\t}\n\n\tdown_read(&cxl_dpa_rwsem);\n\tctrl = readl(hdm + CXL_HDM_DECODER0_CTRL_OFFSET(id));\n\tctrl &= ~CXL_HDM_DECODER0_CTRL_COMMIT;\n\twritel(ctrl, hdm + CXL_HDM_DECODER0_CTRL_OFFSET(id));\n\n\twritel(0, hdm + CXL_HDM_DECODER0_SIZE_HIGH_OFFSET(id));\n\twritel(0, hdm + CXL_HDM_DECODER0_SIZE_LOW_OFFSET(id));\n\twritel(0, hdm + CXL_HDM_DECODER0_BASE_HIGH_OFFSET(id));\n\twritel(0, hdm + CXL_HDM_DECODER0_BASE_LOW_OFFSET(id));\n\tup_read(&cxl_dpa_rwsem);\n\n\tport->commit_end--;\n\tcxld->flags &= ~CXL_DECODER_F_ENABLE;\n\n\t \n\tif (is_endpoint_decoder(&cxld->dev)) {\n\t\tstruct cxl_endpoint_decoder *cxled;\n\n\t\tcxled = to_cxl_endpoint_decoder(&cxld->dev);\n\t\tcxled->state = CXL_DECODER_STATE_MANUAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int cxl_setup_hdm_decoder_from_dvsec(\n\tstruct cxl_port *port, struct cxl_decoder *cxld, u64 *dpa_base,\n\tint which, struct cxl_endpoint_dvsec_info *info)\n{\n\tstruct cxl_endpoint_decoder *cxled;\n\tu64 len;\n\tint rc;\n\n\tif (!is_cxl_endpoint(port))\n\t\treturn -EOPNOTSUPP;\n\n\tcxled = to_cxl_endpoint_decoder(&cxld->dev);\n\tlen = range_len(&info->dvsec_range[which]);\n\tif (!len)\n\t\treturn -ENOENT;\n\n\tcxld->target_type = CXL_DECODER_HOSTONLYMEM;\n\tcxld->commit = NULL;\n\tcxld->reset = NULL;\n\tcxld->hpa_range = info->dvsec_range[which];\n\n\t \n\tcxld->flags |= CXL_DECODER_F_ENABLE | CXL_DECODER_F_LOCK;\n\tport->commit_end = cxld->id;\n\n\trc = devm_cxl_dpa_reserve(cxled, *dpa_base, len, 0);\n\tif (rc) {\n\t\tdev_err(&port->dev,\n\t\t\t\"decoder%d.%d: Failed to reserve DPA range %#llx - %#llx\\n (%d)\",\n\t\t\tport->id, cxld->id, *dpa_base, *dpa_base + len - 1, rc);\n\t\treturn rc;\n\t}\n\t*dpa_base += len;\n\tcxled->state = CXL_DECODER_STATE_AUTO;\n\n\treturn 0;\n}\n\nstatic int init_hdm_decoder(struct cxl_port *port, struct cxl_decoder *cxld,\n\t\t\t    int *target_map, void __iomem *hdm, int which,\n\t\t\t    u64 *dpa_base, struct cxl_endpoint_dvsec_info *info)\n{\n\tstruct cxl_endpoint_decoder *cxled = NULL;\n\tu64 size, base, skip, dpa_size, lo, hi;\n\tbool committed;\n\tu32 remainder;\n\tint i, rc;\n\tu32 ctrl;\n\tunion {\n\t\tu64 value;\n\t\tunsigned char target_id[8];\n\t} target_list;\n\n\tif (should_emulate_decoders(info))\n\t\treturn cxl_setup_hdm_decoder_from_dvsec(port, cxld, dpa_base,\n\t\t\t\t\t\t\twhich, info);\n\n\tctrl = readl(hdm + CXL_HDM_DECODER0_CTRL_OFFSET(which));\n\tlo = readl(hdm + CXL_HDM_DECODER0_BASE_LOW_OFFSET(which));\n\thi = readl(hdm + CXL_HDM_DECODER0_BASE_HIGH_OFFSET(which));\n\tbase = (hi << 32) + lo;\n\tlo = readl(hdm + CXL_HDM_DECODER0_SIZE_LOW_OFFSET(which));\n\thi = readl(hdm + CXL_HDM_DECODER0_SIZE_HIGH_OFFSET(which));\n\tsize = (hi << 32) + lo;\n\tcommitted = !!(ctrl & CXL_HDM_DECODER0_CTRL_COMMITTED);\n\tcxld->commit = cxl_decoder_commit;\n\tcxld->reset = cxl_decoder_reset;\n\n\tif (!committed)\n\t\tsize = 0;\n\tif (base == U64_MAX || size == U64_MAX) {\n\t\tdev_warn(&port->dev, \"decoder%d.%d: Invalid resource range\\n\",\n\t\t\t port->id, cxld->id);\n\t\treturn -ENXIO;\n\t}\n\n\tif (info)\n\t\tcxled = to_cxl_endpoint_decoder(&cxld->dev);\n\tcxld->hpa_range = (struct range) {\n\t\t.start = base,\n\t\t.end = base + size - 1,\n\t};\n\n\t \n\tif (committed) {\n\t\tcxld->flags |= CXL_DECODER_F_ENABLE;\n\t\tif (ctrl & CXL_HDM_DECODER0_CTRL_LOCK)\n\t\t\tcxld->flags |= CXL_DECODER_F_LOCK;\n\t\tif (FIELD_GET(CXL_HDM_DECODER0_CTRL_HOSTONLY, ctrl))\n\t\t\tcxld->target_type = CXL_DECODER_HOSTONLYMEM;\n\t\telse\n\t\t\tcxld->target_type = CXL_DECODER_DEVMEM;\n\n\t\tguard(rwsem_write)(&cxl_region_rwsem);\n\t\tif (cxld->id != cxl_num_decoders_committed(port)) {\n\t\t\tdev_warn(&port->dev,\n\t\t\t\t \"decoder%d.%d: Committed out of order\\n\",\n\t\t\t\t port->id, cxld->id);\n\t\t\treturn -ENXIO;\n\t\t}\n\n\t\tif (size == 0) {\n\t\t\tdev_warn(&port->dev,\n\t\t\t\t \"decoder%d.%d: Committed with zero size\\n\",\n\t\t\t\t port->id, cxld->id);\n\t\t\treturn -ENXIO;\n\t\t}\n\t\tport->commit_end = cxld->id;\n\t} else {\n\t\tif (cxled) {\n\t\t\tstruct cxl_memdev *cxlmd = cxled_to_memdev(cxled);\n\t\t\tstruct cxl_dev_state *cxlds = cxlmd->cxlds;\n\n\t\t\t \n\t\t\tif (cxlds->type == CXL_DEVTYPE_CLASSMEM)\n\t\t\t\tcxld->target_type = CXL_DECODER_HOSTONLYMEM;\n\t\t\telse\n\t\t\t\tcxld->target_type = CXL_DECODER_DEVMEM;\n\t\t} else {\n\t\t\t \n\t\t\tcxld->target_type = CXL_DECODER_HOSTONLYMEM;\n\t\t}\n\n\t\tif (!FIELD_GET(CXL_HDM_DECODER0_CTRL_HOSTONLY, ctrl) &&\n\t\t    cxld->target_type == CXL_DECODER_HOSTONLYMEM) {\n\t\t\tctrl |= CXL_HDM_DECODER0_CTRL_HOSTONLY;\n\t\t\twritel(ctrl, hdm + CXL_HDM_DECODER0_CTRL_OFFSET(which));\n\t\t}\n\t}\n\trc = eiw_to_ways(FIELD_GET(CXL_HDM_DECODER0_CTRL_IW_MASK, ctrl),\n\t\t\t  &cxld->interleave_ways);\n\tif (rc) {\n\t\tdev_warn(&port->dev,\n\t\t\t \"decoder%d.%d: Invalid interleave ways (ctrl: %#x)\\n\",\n\t\t\t port->id, cxld->id, ctrl);\n\t\treturn rc;\n\t}\n\trc = eig_to_granularity(FIELD_GET(CXL_HDM_DECODER0_CTRL_IG_MASK, ctrl),\n\t\t\t\t &cxld->interleave_granularity);\n\tif (rc)\n\t\treturn rc;\n\n\tdev_dbg(&port->dev, \"decoder%d.%d: range: %#llx-%#llx iw: %d ig: %d\\n\",\n\t\tport->id, cxld->id, cxld->hpa_range.start, cxld->hpa_range.end,\n\t\tcxld->interleave_ways, cxld->interleave_granularity);\n\n\tif (!cxled) {\n\t\tlo = readl(hdm + CXL_HDM_DECODER0_TL_LOW(which));\n\t\thi = readl(hdm + CXL_HDM_DECODER0_TL_HIGH(which));\n\t\ttarget_list.value = (hi << 32) + lo;\n\t\tfor (i = 0; i < cxld->interleave_ways; i++)\n\t\t\ttarget_map[i] = target_list.target_id[i];\n\n\t\treturn 0;\n\t}\n\n\tif (!committed)\n\t\treturn 0;\n\n\tdpa_size = div_u64_rem(size, cxld->interleave_ways, &remainder);\n\tif (remainder) {\n\t\tdev_err(&port->dev,\n\t\t\t\"decoder%d.%d: invalid committed configuration size: %#llx ways: %d\\n\",\n\t\t\tport->id, cxld->id, size, cxld->interleave_ways);\n\t\treturn -ENXIO;\n\t}\n\tlo = readl(hdm + CXL_HDM_DECODER0_SKIP_LOW(which));\n\thi = readl(hdm + CXL_HDM_DECODER0_SKIP_HIGH(which));\n\tskip = (hi << 32) + lo;\n\trc = devm_cxl_dpa_reserve(cxled, *dpa_base + skip, dpa_size, skip);\n\tif (rc) {\n\t\tdev_err(&port->dev,\n\t\t\t\"decoder%d.%d: Failed to reserve DPA range %#llx - %#llx\\n (%d)\",\n\t\t\tport->id, cxld->id, *dpa_base,\n\t\t\t*dpa_base + dpa_size + skip - 1, rc);\n\t\treturn rc;\n\t}\n\t*dpa_base += dpa_size + skip;\n\n\tcxled->state = CXL_DECODER_STATE_AUTO;\n\n\treturn 0;\n}\n\nstatic void cxl_settle_decoders(struct cxl_hdm *cxlhdm)\n{\n\tvoid __iomem *hdm = cxlhdm->regs.hdm_decoder;\n\tint committed, i;\n\tu32 ctrl;\n\n\tif (!hdm)\n\t\treturn;\n\n\t \n\tfor (i = 0, committed = 0; i < cxlhdm->decoder_count; i++) {\n\t\tctrl = readl(hdm + CXL_HDM_DECODER0_CTRL_OFFSET(i));\n\t\tif (ctrl & CXL_HDM_DECODER0_CTRL_COMMITTED)\n\t\t\tcommitted++;\n\t}\n\n\t \n\tif (committed != cxlhdm->decoder_count)\n\t\tmsleep(20);\n}\n\n \nint devm_cxl_enumerate_decoders(struct cxl_hdm *cxlhdm,\n\t\t\t\tstruct cxl_endpoint_dvsec_info *info)\n{\n\tvoid __iomem *hdm = cxlhdm->regs.hdm_decoder;\n\tstruct cxl_port *port = cxlhdm->port;\n\tint i;\n\tu64 dpa_base = 0;\n\n\tcxl_settle_decoders(cxlhdm);\n\n\tfor (i = 0; i < cxlhdm->decoder_count; i++) {\n\t\tint target_map[CXL_DECODER_MAX_INTERLEAVE] = { 0 };\n\t\tint rc, target_count = cxlhdm->target_count;\n\t\tstruct cxl_decoder *cxld;\n\n\t\tif (is_cxl_endpoint(port)) {\n\t\t\tstruct cxl_endpoint_decoder *cxled;\n\n\t\t\tcxled = cxl_endpoint_decoder_alloc(port);\n\t\t\tif (IS_ERR(cxled)) {\n\t\t\t\tdev_warn(&port->dev,\n\t\t\t\t\t \"Failed to allocate decoder%d.%d\\n\",\n\t\t\t\t\t port->id, i);\n\t\t\t\treturn PTR_ERR(cxled);\n\t\t\t}\n\t\t\tcxld = &cxled->cxld;\n\t\t} else {\n\t\t\tstruct cxl_switch_decoder *cxlsd;\n\n\t\t\tcxlsd = cxl_switch_decoder_alloc(port, target_count);\n\t\t\tif (IS_ERR(cxlsd)) {\n\t\t\t\tdev_warn(&port->dev,\n\t\t\t\t\t \"Failed to allocate decoder%d.%d\\n\",\n\t\t\t\t\t port->id, i);\n\t\t\t\treturn PTR_ERR(cxlsd);\n\t\t\t}\n\t\t\tcxld = &cxlsd->cxld;\n\t\t}\n\n\t\trc = init_hdm_decoder(port, cxld, target_map, hdm, i,\n\t\t\t\t      &dpa_base, info);\n\t\tif (rc) {\n\t\t\tdev_warn(&port->dev,\n\t\t\t\t \"Failed to initialize decoder%d.%d\\n\",\n\t\t\t\t port->id, i);\n\t\t\tput_device(&cxld->dev);\n\t\t\treturn rc;\n\t\t}\n\t\trc = add_hdm_decoder(port, cxld, target_map);\n\t\tif (rc) {\n\t\t\tdev_warn(&port->dev,\n\t\t\t\t \"Failed to add decoder%d.%d\\n\", port->id, i);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_NS_GPL(devm_cxl_enumerate_decoders, CXL);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}