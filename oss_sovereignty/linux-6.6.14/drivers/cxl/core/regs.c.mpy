{
  "module_name": "regs.c",
  "hash_id": "c2fb901c570ea7691465d4f8c7b7f3d0f0b6d93cca7df8a0ec6adbbb44dfc1cb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/cxl/core/regs.c",
  "human_readable_source": "\n \n#include <linux/io-64-nonatomic-lo-hi.h>\n#include <linux/device.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <cxlmem.h>\n#include <cxlpci.h>\n#include <pmu.h>\n\n#include \"core.h\"\n\n \n\n \nvoid cxl_probe_component_regs(struct device *dev, void __iomem *base,\n\t\t\t      struct cxl_component_reg_map *map)\n{\n\tint cap, cap_count;\n\tu32 cap_array;\n\n\t*map = (struct cxl_component_reg_map) { 0 };\n\n\t \n\tbase += CXL_CM_OFFSET;\n\n\tcap_array = readl(base + CXL_CM_CAP_HDR_OFFSET);\n\n\tif (FIELD_GET(CXL_CM_CAP_HDR_ID_MASK, cap_array) != CM_CAP_HDR_CAP_ID) {\n\t\tdev_err(dev,\n\t\t\t\"Couldn't locate the CXL.cache and CXL.mem capability array header.\\n\");\n\t\treturn;\n\t}\n\n\t \n\tcap_count = FIELD_GET(CXL_CM_CAP_HDR_ARRAY_SIZE_MASK, cap_array);\n\n\tfor (cap = 1; cap <= cap_count; cap++) {\n\t\tvoid __iomem *register_block;\n\t\tstruct cxl_reg_map *rmap;\n\t\tu16 cap_id, offset;\n\t\tu32 length, hdr;\n\n\t\thdr = readl(base + cap * 0x4);\n\n\t\tcap_id = FIELD_GET(CXL_CM_CAP_HDR_ID_MASK, hdr);\n\t\toffset = FIELD_GET(CXL_CM_CAP_PTR_MASK, hdr);\n\t\tregister_block = base + offset;\n\t\thdr = readl(register_block);\n\n\t\trmap = NULL;\n\t\tswitch (cap_id) {\n\t\tcase CXL_CM_CAP_CAP_ID_HDM: {\n\t\t\tint decoder_cnt;\n\n\t\t\tdev_dbg(dev, \"found HDM decoder capability (0x%x)\\n\",\n\t\t\t\toffset);\n\n\t\t\tdecoder_cnt = cxl_hdm_decoder_count(hdr);\n\t\t\tlength = 0x20 * decoder_cnt + 0x10;\n\t\t\trmap = &map->hdm_decoder;\n\t\t\tbreak;\n\t\t}\n\t\tcase CXL_CM_CAP_CAP_ID_RAS:\n\t\t\tdev_dbg(dev, \"found RAS capability (0x%x)\\n\",\n\t\t\t\toffset);\n\t\t\tlength = CXL_RAS_CAPABILITY_LENGTH;\n\t\t\trmap = &map->ras;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_dbg(dev, \"Unknown CM cap ID: %d (0x%x)\\n\", cap_id,\n\t\t\t\toffset);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!rmap)\n\t\t\tcontinue;\n\t\trmap->valid = true;\n\t\trmap->id = cap_id;\n\t\trmap->offset = CXL_CM_OFFSET + offset;\n\t\trmap->size = length;\n\t}\n}\nEXPORT_SYMBOL_NS_GPL(cxl_probe_component_regs, CXL);\n\n \nvoid cxl_probe_device_regs(struct device *dev, void __iomem *base,\n\t\t\t   struct cxl_device_reg_map *map)\n{\n\tint cap, cap_count;\n\tu64 cap_array;\n\n\t*map = (struct cxl_device_reg_map){ 0 };\n\n\tcap_array = readq(base + CXLDEV_CAP_ARRAY_OFFSET);\n\tif (FIELD_GET(CXLDEV_CAP_ARRAY_ID_MASK, cap_array) !=\n\t    CXLDEV_CAP_ARRAY_CAP_ID)\n\t\treturn;\n\n\tcap_count = FIELD_GET(CXLDEV_CAP_ARRAY_COUNT_MASK, cap_array);\n\n\tfor (cap = 1; cap <= cap_count; cap++) {\n\t\tstruct cxl_reg_map *rmap;\n\t\tu32 offset, length;\n\t\tu16 cap_id;\n\n\t\tcap_id = FIELD_GET(CXLDEV_CAP_HDR_CAP_ID_MASK,\n\t\t\t\t   readl(base + cap * 0x10));\n\t\toffset = readl(base + cap * 0x10 + 0x4);\n\t\tlength = readl(base + cap * 0x10 + 0x8);\n\n\t\trmap = NULL;\n\t\tswitch (cap_id) {\n\t\tcase CXLDEV_CAP_CAP_ID_DEVICE_STATUS:\n\t\t\tdev_dbg(dev, \"found Status capability (0x%x)\\n\", offset);\n\t\t\trmap = &map->status;\n\t\t\tbreak;\n\t\tcase CXLDEV_CAP_CAP_ID_PRIMARY_MAILBOX:\n\t\t\tdev_dbg(dev, \"found Mailbox capability (0x%x)\\n\", offset);\n\t\t\trmap = &map->mbox;\n\t\t\tbreak;\n\t\tcase CXLDEV_CAP_CAP_ID_SECONDARY_MAILBOX:\n\t\t\tdev_dbg(dev, \"found Secondary Mailbox capability (0x%x)\\n\", offset);\n\t\t\tbreak;\n\t\tcase CXLDEV_CAP_CAP_ID_MEMDEV:\n\t\t\tdev_dbg(dev, \"found Memory Device capability (0x%x)\\n\", offset);\n\t\t\trmap = &map->memdev;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (cap_id >= 0x8000)\n\t\t\t\tdev_dbg(dev, \"Vendor cap ID: %#x offset: %#x\\n\", cap_id, offset);\n\t\t\telse\n\t\t\t\tdev_dbg(dev, \"Unknown cap ID: %#x offset: %#x\\n\", cap_id, offset);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!rmap)\n\t\t\tcontinue;\n\t\trmap->valid = true;\n\t\trmap->id = cap_id;\n\t\trmap->offset = offset;\n\t\trmap->size = length;\n\t}\n}\nEXPORT_SYMBOL_NS_GPL(cxl_probe_device_regs, CXL);\n\nvoid __iomem *devm_cxl_iomap_block(struct device *dev, resource_size_t addr,\n\t\t\t\t   resource_size_t length)\n{\n\tvoid __iomem *ret_val;\n\tstruct resource *res;\n\n\tif (WARN_ON_ONCE(addr == CXL_RESOURCE_NONE))\n\t\treturn NULL;\n\n\tres = devm_request_mem_region(dev, addr, length, dev_name(dev));\n\tif (!res) {\n\t\tresource_size_t end = addr + length - 1;\n\n\t\tdev_err(dev, \"Failed to request region %pa-%pa\\n\", &addr, &end);\n\t\treturn NULL;\n\t}\n\n\tret_val = devm_ioremap(dev, addr, length);\n\tif (!ret_val)\n\t\tdev_err(dev, \"Failed to map region %pr\\n\", res);\n\n\treturn ret_val;\n}\n\nint cxl_map_component_regs(const struct cxl_register_map *map,\n\t\t\t   struct cxl_component_regs *regs,\n\t\t\t   unsigned long map_mask)\n{\n\tstruct device *host = map->host;\n\tstruct mapinfo {\n\t\tconst struct cxl_reg_map *rmap;\n\t\tvoid __iomem **addr;\n\t} mapinfo[] = {\n\t\t{ &map->component_map.hdm_decoder, &regs->hdm_decoder },\n\t\t{ &map->component_map.ras, &regs->ras },\n\t};\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(mapinfo); i++) {\n\t\tstruct mapinfo *mi = &mapinfo[i];\n\t\tresource_size_t phys_addr;\n\t\tresource_size_t length;\n\n\t\tif (!mi->rmap->valid)\n\t\t\tcontinue;\n\t\tif (!test_bit(mi->rmap->id, &map_mask))\n\t\t\tcontinue;\n\t\tphys_addr = map->resource + mi->rmap->offset;\n\t\tlength = mi->rmap->size;\n\t\t*(mi->addr) = devm_cxl_iomap_block(host, phys_addr, length);\n\t\tif (!*(mi->addr))\n\t\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_NS_GPL(cxl_map_component_regs, CXL);\n\nint cxl_map_device_regs(const struct cxl_register_map *map,\n\t\t\tstruct cxl_device_regs *regs)\n{\n\tstruct device *host = map->host;\n\tresource_size_t phys_addr = map->resource;\n\tstruct mapinfo {\n\t\tconst struct cxl_reg_map *rmap;\n\t\tvoid __iomem **addr;\n\t} mapinfo[] = {\n\t\t{ &map->device_map.status, &regs->status, },\n\t\t{ &map->device_map.mbox, &regs->mbox, },\n\t\t{ &map->device_map.memdev, &regs->memdev, },\n\t};\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(mapinfo); i++) {\n\t\tstruct mapinfo *mi = &mapinfo[i];\n\t\tresource_size_t length;\n\t\tresource_size_t addr;\n\n\t\tif (!mi->rmap->valid)\n\t\t\tcontinue;\n\n\t\taddr = phys_addr + mi->rmap->offset;\n\t\tlength = mi->rmap->size;\n\t\t*(mi->addr) = devm_cxl_iomap_block(host, addr, length);\n\t\tif (!*(mi->addr))\n\t\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_NS_GPL(cxl_map_device_regs, CXL);\n\nstatic bool cxl_decode_regblock(struct pci_dev *pdev, u32 reg_lo, u32 reg_hi,\n\t\t\t\tstruct cxl_register_map *map)\n{\n\tint bar = FIELD_GET(CXL_DVSEC_REG_LOCATOR_BIR_MASK, reg_lo);\n\tu64 offset = ((u64)reg_hi << 32) |\n\t\t     (reg_lo & CXL_DVSEC_REG_LOCATOR_BLOCK_OFF_LOW_MASK);\n\n\tif (offset > pci_resource_len(pdev, bar)) {\n\t\tdev_warn(&pdev->dev,\n\t\t\t \"BAR%d: %pr: too small (offset: %pa, type: %d)\\n\", bar,\n\t\t\t &pdev->resource[bar], &offset, map->reg_type);\n\t\treturn false;\n\t}\n\n\tmap->reg_type = FIELD_GET(CXL_DVSEC_REG_LOCATOR_BLOCK_ID_MASK, reg_lo);\n\tmap->resource = pci_resource_start(pdev, bar) + offset;\n\tmap->max_size = pci_resource_len(pdev, bar) - offset;\n\treturn true;\n}\n\n \nint cxl_find_regblock_instance(struct pci_dev *pdev, enum cxl_regloc_type type,\n\t\t\t       struct cxl_register_map *map, int index)\n{\n\tu32 regloc_size, regblocks;\n\tint instance = 0;\n\tint regloc, i;\n\n\t*map = (struct cxl_register_map) {\n\t\t.host = &pdev->dev,\n\t\t.resource = CXL_RESOURCE_NONE,\n\t};\n\n\tregloc = pci_find_dvsec_capability(pdev, PCI_DVSEC_VENDOR_ID_CXL,\n\t\t\t\t\t   CXL_DVSEC_REG_LOCATOR);\n\tif (!regloc)\n\t\treturn -ENXIO;\n\n\tpci_read_config_dword(pdev, regloc + PCI_DVSEC_HEADER1, &regloc_size);\n\tregloc_size = FIELD_GET(PCI_DVSEC_HEADER1_LENGTH_MASK, regloc_size);\n\n\tregloc += CXL_DVSEC_REG_LOCATOR_BLOCK1_OFFSET;\n\tregblocks = (regloc_size - CXL_DVSEC_REG_LOCATOR_BLOCK1_OFFSET) / 8;\n\n\tfor (i = 0; i < regblocks; i++, regloc += 8) {\n\t\tu32 reg_lo, reg_hi;\n\n\t\tpci_read_config_dword(pdev, regloc, &reg_lo);\n\t\tpci_read_config_dword(pdev, regloc + 4, &reg_hi);\n\n\t\tif (!cxl_decode_regblock(pdev, reg_lo, reg_hi, map))\n\t\t\tcontinue;\n\n\t\tif (map->reg_type == type) {\n\t\t\tif (index == instance)\n\t\t\t\treturn 0;\n\t\t\tinstance++;\n\t\t}\n\t}\n\n\tmap->resource = CXL_RESOURCE_NONE;\n\treturn -ENODEV;\n}\nEXPORT_SYMBOL_NS_GPL(cxl_find_regblock_instance, CXL);\n\n \nint cxl_find_regblock(struct pci_dev *pdev, enum cxl_regloc_type type,\n\t\t      struct cxl_register_map *map)\n{\n\treturn cxl_find_regblock_instance(pdev, type, map, 0);\n}\nEXPORT_SYMBOL_NS_GPL(cxl_find_regblock, CXL);\n\n \nint cxl_count_regblock(struct pci_dev *pdev, enum cxl_regloc_type type)\n{\n\tstruct cxl_register_map map;\n\tint rc, count = 0;\n\n\twhile (1) {\n\t\trc = cxl_find_regblock_instance(pdev, type, &map, count);\n\t\tif (rc)\n\t\t\treturn count;\n\t\tcount++;\n\t}\n}\nEXPORT_SYMBOL_NS_GPL(cxl_count_regblock, CXL);\n\nint cxl_map_pmu_regs(struct pci_dev *pdev, struct cxl_pmu_regs *regs,\n\t\t     struct cxl_register_map *map)\n{\n\tstruct device *dev = &pdev->dev;\n\tresource_size_t phys_addr;\n\n\tphys_addr = map->resource;\n\tregs->pmu = devm_cxl_iomap_block(dev, phys_addr, CXL_PMU_REGMAP_SIZE);\n\tif (!regs->pmu)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_NS_GPL(cxl_map_pmu_regs, CXL);\n\nstatic int cxl_map_regblock(struct cxl_register_map *map)\n{\n\tstruct device *host = map->host;\n\n\tmap->base = ioremap(map->resource, map->max_size);\n\tif (!map->base) {\n\t\tdev_err(host, \"failed to map registers\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tdev_dbg(host, \"Mapped CXL Memory Device resource %pa\\n\", &map->resource);\n\treturn 0;\n}\n\nstatic void cxl_unmap_regblock(struct cxl_register_map *map)\n{\n\tiounmap(map->base);\n\tmap->base = NULL;\n}\n\nstatic int cxl_probe_regs(struct cxl_register_map *map)\n{\n\tstruct cxl_component_reg_map *comp_map;\n\tstruct cxl_device_reg_map *dev_map;\n\tstruct device *host = map->host;\n\tvoid __iomem *base = map->base;\n\n\tswitch (map->reg_type) {\n\tcase CXL_REGLOC_RBI_COMPONENT:\n\t\tcomp_map = &map->component_map;\n\t\tcxl_probe_component_regs(host, base, comp_map);\n\t\tdev_dbg(host, \"Set up component registers\\n\");\n\t\tbreak;\n\tcase CXL_REGLOC_RBI_MEMDEV:\n\t\tdev_map = &map->device_map;\n\t\tcxl_probe_device_regs(host, base, dev_map);\n\t\tif (!dev_map->status.valid || !dev_map->mbox.valid ||\n\t\t    !dev_map->memdev.valid) {\n\t\t\tdev_err(host, \"registers not found: %s%s%s\\n\",\n\t\t\t\t!dev_map->status.valid ? \"status \" : \"\",\n\t\t\t\t!dev_map->mbox.valid ? \"mbox \" : \"\",\n\t\t\t\t!dev_map->memdev.valid ? \"memdev \" : \"\");\n\t\t\treturn -ENXIO;\n\t\t}\n\n\t\tdev_dbg(host, \"Probing device registers...\\n\");\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nint cxl_setup_regs(struct cxl_register_map *map)\n{\n\tint rc;\n\n\trc = cxl_map_regblock(map);\n\tif (rc)\n\t\treturn rc;\n\n\trc = cxl_probe_regs(map);\n\tcxl_unmap_regblock(map);\n\n\treturn rc;\n}\nEXPORT_SYMBOL_NS_GPL(cxl_setup_regs, CXL);\n\nresource_size_t __rcrb_to_component(struct device *dev, struct cxl_rcrb_info *ri,\n\t\t\t\t    enum cxl_rcrb which)\n{\n\tresource_size_t component_reg_phys;\n\tresource_size_t rcrb = ri->base;\n\tvoid __iomem *addr;\n\tu32 bar0, bar1;\n\tu16 cmd;\n\tu32 id;\n\n\tif (which == CXL_RCRB_UPSTREAM)\n\t\trcrb += SZ_4K;\n\n\t \n\tif (!request_mem_region(rcrb, SZ_4K, \"CXL RCRB\"))\n\t\treturn CXL_RESOURCE_NONE;\n\taddr = ioremap(rcrb, SZ_4K);\n\tif (!addr) {\n\t\tdev_err(dev, \"Failed to map region %pr\\n\", addr);\n\t\trelease_mem_region(rcrb, SZ_4K);\n\t\treturn CXL_RESOURCE_NONE;\n\t}\n\n\tid = readl(addr + PCI_VENDOR_ID);\n\tcmd = readw(addr + PCI_COMMAND);\n\tbar0 = readl(addr + PCI_BASE_ADDRESS_0);\n\tbar1 = readl(addr + PCI_BASE_ADDRESS_1);\n\tiounmap(addr);\n\trelease_mem_region(rcrb, SZ_4K);\n\n\t \n\tif (id == U32_MAX) {\n\t\tif (which == CXL_RCRB_DOWNSTREAM)\n\t\t\tdev_err(dev, \"Failed to access Downstream Port RCRB\\n\");\n\t\treturn CXL_RESOURCE_NONE;\n\t}\n\tif (!(cmd & PCI_COMMAND_MEMORY))\n\t\treturn CXL_RESOURCE_NONE;\n\t \n\tif (bar0 & (PCI_BASE_ADDRESS_MEM_TYPE_1M | PCI_BASE_ADDRESS_SPACE_IO))\n\t\treturn CXL_RESOURCE_NONE;\n\n\tcomponent_reg_phys = bar0 & PCI_BASE_ADDRESS_MEM_MASK;\n\tif (bar0 & PCI_BASE_ADDRESS_MEM_TYPE_64)\n\t\tcomponent_reg_phys |= ((u64)bar1) << 32;\n\n\tif (!component_reg_phys)\n\t\treturn CXL_RESOURCE_NONE;\n\n\t \n\tif (!IS_ALIGNED(component_reg_phys, CXL_COMPONENT_REG_BLOCK_SIZE))\n\t\treturn CXL_RESOURCE_NONE;\n\n\treturn component_reg_phys;\n}\n\nresource_size_t cxl_rcd_component_reg_phys(struct device *dev,\n\t\t\t\t\t   struct cxl_dport *dport)\n{\n\tif (!dport->rch)\n\t\treturn CXL_RESOURCE_NONE;\n\treturn __rcrb_to_component(dev, &dport->rcrb, CXL_RCRB_UPSTREAM);\n}\nEXPORT_SYMBOL_NS_GPL(cxl_rcd_component_reg_phys, CXL);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}