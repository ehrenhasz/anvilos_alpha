{
  "module_name": "pmem.c",
  "hash_id": "bfa7282e0b5267b6cf1761970b4c1365cb99ada781955e1e2555ce25cc1eab45",
  "original_prompt": "Ingested from linux-6.6.14/drivers/cxl/core/pmem.c",
  "human_readable_source": "\n \n#include <linux/device.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <cxlmem.h>\n#include <cxl.h>\n#include \"core.h\"\n\n \n\nstatic DEFINE_IDA(cxl_nvdimm_bridge_ida);\n\nstatic void cxl_nvdimm_bridge_release(struct device *dev)\n{\n\tstruct cxl_nvdimm_bridge *cxl_nvb = to_cxl_nvdimm_bridge(dev);\n\n\tida_free(&cxl_nvdimm_bridge_ida, cxl_nvb->id);\n\tkfree(cxl_nvb);\n}\n\nstatic const struct attribute_group *cxl_nvdimm_bridge_attribute_groups[] = {\n\t&cxl_base_attribute_group,\n\tNULL,\n};\n\nconst struct device_type cxl_nvdimm_bridge_type = {\n\t.name = \"cxl_nvdimm_bridge\",\n\t.release = cxl_nvdimm_bridge_release,\n\t.groups = cxl_nvdimm_bridge_attribute_groups,\n};\n\nstruct cxl_nvdimm_bridge *to_cxl_nvdimm_bridge(struct device *dev)\n{\n\tif (dev_WARN_ONCE(dev, dev->type != &cxl_nvdimm_bridge_type,\n\t\t\t  \"not a cxl_nvdimm_bridge device\\n\"))\n\t\treturn NULL;\n\treturn container_of(dev, struct cxl_nvdimm_bridge, dev);\n}\nEXPORT_SYMBOL_NS_GPL(to_cxl_nvdimm_bridge, CXL);\n\nbool is_cxl_nvdimm_bridge(struct device *dev)\n{\n\treturn dev->type == &cxl_nvdimm_bridge_type;\n}\nEXPORT_SYMBOL_NS_GPL(is_cxl_nvdimm_bridge, CXL);\n\nstatic int match_nvdimm_bridge(struct device *dev, void *data)\n{\n\treturn is_cxl_nvdimm_bridge(dev);\n}\n\nstruct cxl_nvdimm_bridge *cxl_find_nvdimm_bridge(struct cxl_memdev *cxlmd)\n{\n\tstruct cxl_port *port = find_cxl_root(cxlmd->endpoint);\n\tstruct device *dev;\n\n\tif (!port)\n\t\treturn NULL;\n\n\tdev = device_find_child(&port->dev, NULL, match_nvdimm_bridge);\n\tput_device(&port->dev);\n\n\tif (!dev)\n\t\treturn NULL;\n\n\treturn to_cxl_nvdimm_bridge(dev);\n}\nEXPORT_SYMBOL_NS_GPL(cxl_find_nvdimm_bridge, CXL);\n\nstatic struct lock_class_key cxl_nvdimm_bridge_key;\n\nstatic struct cxl_nvdimm_bridge *cxl_nvdimm_bridge_alloc(struct cxl_port *port)\n{\n\tstruct cxl_nvdimm_bridge *cxl_nvb;\n\tstruct device *dev;\n\tint rc;\n\n\tcxl_nvb = kzalloc(sizeof(*cxl_nvb), GFP_KERNEL);\n\tif (!cxl_nvb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\trc = ida_alloc(&cxl_nvdimm_bridge_ida, GFP_KERNEL);\n\tif (rc < 0)\n\t\tgoto err;\n\tcxl_nvb->id = rc;\n\n\tdev = &cxl_nvb->dev;\n\tcxl_nvb->port = port;\n\tdevice_initialize(dev);\n\tlockdep_set_class(&dev->mutex, &cxl_nvdimm_bridge_key);\n\tdevice_set_pm_not_required(dev);\n\tdev->parent = &port->dev;\n\tdev->bus = &cxl_bus_type;\n\tdev->type = &cxl_nvdimm_bridge_type;\n\n\treturn cxl_nvb;\n\nerr:\n\tkfree(cxl_nvb);\n\treturn ERR_PTR(rc);\n}\n\nstatic void unregister_nvb(void *_cxl_nvb)\n{\n\tstruct cxl_nvdimm_bridge *cxl_nvb = _cxl_nvb;\n\n\tdevice_unregister(&cxl_nvb->dev);\n}\n\n \nstruct cxl_nvdimm_bridge *devm_cxl_add_nvdimm_bridge(struct device *host,\n\t\t\t\t\t\t     struct cxl_port *port)\n{\n\tstruct cxl_nvdimm_bridge *cxl_nvb;\n\tstruct device *dev;\n\tint rc;\n\n\tif (!IS_ENABLED(CONFIG_CXL_PMEM))\n\t\treturn ERR_PTR(-ENXIO);\n\n\tcxl_nvb = cxl_nvdimm_bridge_alloc(port);\n\tif (IS_ERR(cxl_nvb))\n\t\treturn cxl_nvb;\n\n\tdev = &cxl_nvb->dev;\n\trc = dev_set_name(dev, \"nvdimm-bridge%d\", cxl_nvb->id);\n\tif (rc)\n\t\tgoto err;\n\n\trc = device_add(dev);\n\tif (rc)\n\t\tgoto err;\n\n\trc = devm_add_action_or_reset(host, unregister_nvb, cxl_nvb);\n\tif (rc)\n\t\treturn ERR_PTR(rc);\n\n\treturn cxl_nvb;\n\nerr:\n\tput_device(dev);\n\treturn ERR_PTR(rc);\n}\nEXPORT_SYMBOL_NS_GPL(devm_cxl_add_nvdimm_bridge, CXL);\n\nstatic void cxl_nvdimm_release(struct device *dev)\n{\n\tstruct cxl_nvdimm *cxl_nvd = to_cxl_nvdimm(dev);\n\n\tkfree(cxl_nvd);\n}\n\nstatic const struct attribute_group *cxl_nvdimm_attribute_groups[] = {\n\t&cxl_base_attribute_group,\n\tNULL,\n};\n\nconst struct device_type cxl_nvdimm_type = {\n\t.name = \"cxl_nvdimm\",\n\t.release = cxl_nvdimm_release,\n\t.groups = cxl_nvdimm_attribute_groups,\n};\n\nbool is_cxl_nvdimm(struct device *dev)\n{\n\treturn dev->type == &cxl_nvdimm_type;\n}\nEXPORT_SYMBOL_NS_GPL(is_cxl_nvdimm, CXL);\n\nstruct cxl_nvdimm *to_cxl_nvdimm(struct device *dev)\n{\n\tif (dev_WARN_ONCE(dev, !is_cxl_nvdimm(dev),\n\t\t\t  \"not a cxl_nvdimm device\\n\"))\n\t\treturn NULL;\n\treturn container_of(dev, struct cxl_nvdimm, dev);\n}\nEXPORT_SYMBOL_NS_GPL(to_cxl_nvdimm, CXL);\n\nstatic struct lock_class_key cxl_nvdimm_key;\n\nstatic struct cxl_nvdimm *cxl_nvdimm_alloc(struct cxl_nvdimm_bridge *cxl_nvb,\n\t\t\t\t\t   struct cxl_memdev *cxlmd)\n{\n\tstruct cxl_nvdimm *cxl_nvd;\n\tstruct device *dev;\n\n\tcxl_nvd = kzalloc(sizeof(*cxl_nvd), GFP_KERNEL);\n\tif (!cxl_nvd)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tdev = &cxl_nvd->dev;\n\tcxl_nvd->cxlmd = cxlmd;\n\tcxlmd->cxl_nvd = cxl_nvd;\n\tdevice_initialize(dev);\n\tlockdep_set_class(&dev->mutex, &cxl_nvdimm_key);\n\tdevice_set_pm_not_required(dev);\n\tdev->parent = &cxlmd->dev;\n\tdev->bus = &cxl_bus_type;\n\tdev->type = &cxl_nvdimm_type;\n\t \n\tBUILD_BUG_ON(sizeof(cxl_nvd->dev_id) < 17 ||\n\t\t     sizeof(cxl_nvd->dev_id) > NVDIMM_KEY_DESC_LEN);\n\tsprintf(cxl_nvd->dev_id, \"%llx\", cxlmd->cxlds->serial);\n\n\treturn cxl_nvd;\n}\n\nstatic void cxlmd_release_nvdimm(void *_cxlmd)\n{\n\tstruct cxl_memdev *cxlmd = _cxlmd;\n\tstruct cxl_nvdimm *cxl_nvd = cxlmd->cxl_nvd;\n\tstruct cxl_nvdimm_bridge *cxl_nvb = cxlmd->cxl_nvb;\n\n\tcxl_nvd->cxlmd = NULL;\n\tcxlmd->cxl_nvd = NULL;\n\tcxlmd->cxl_nvb = NULL;\n\tdevice_unregister(&cxl_nvd->dev);\n\tput_device(&cxl_nvb->dev);\n}\n\n \nint devm_cxl_add_nvdimm(struct cxl_memdev *cxlmd)\n{\n\tstruct cxl_nvdimm_bridge *cxl_nvb;\n\tstruct cxl_nvdimm *cxl_nvd;\n\tstruct device *dev;\n\tint rc;\n\n\tcxl_nvb = cxl_find_nvdimm_bridge(cxlmd);\n\tif (!cxl_nvb)\n\t\treturn -ENODEV;\n\n\tcxl_nvd = cxl_nvdimm_alloc(cxl_nvb, cxlmd);\n\tif (IS_ERR(cxl_nvd)) {\n\t\trc = PTR_ERR(cxl_nvd);\n\t\tgoto err_alloc;\n\t}\n\tcxlmd->cxl_nvb = cxl_nvb;\n\n\tdev = &cxl_nvd->dev;\n\trc = dev_set_name(dev, \"pmem%d\", cxlmd->id);\n\tif (rc)\n\t\tgoto err;\n\n\trc = device_add(dev);\n\tif (rc)\n\t\tgoto err;\n\n\tdev_dbg(&cxlmd->dev, \"register %s\\n\", dev_name(dev));\n\n\t \n\treturn devm_add_action_or_reset(&cxlmd->dev, cxlmd_release_nvdimm, cxlmd);\n\nerr:\n\tput_device(dev);\nerr_alloc:\n\tcxlmd->cxl_nvb = NULL;\n\tcxlmd->cxl_nvd = NULL;\n\tput_device(&cxl_nvb->dev);\n\n\treturn rc;\n}\nEXPORT_SYMBOL_NS_GPL(devm_cxl_add_nvdimm, CXL);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}