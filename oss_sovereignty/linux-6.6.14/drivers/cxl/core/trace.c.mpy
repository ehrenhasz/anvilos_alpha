{
  "module_name": "trace.c",
  "hash_id": "8da807cdd4837a5322c14ba8f7db89c3c5134315629bf29e9e398c0d1acb729a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/cxl/core/trace.c",
  "human_readable_source": "\n \n\n#include <cxl.h>\n#include \"core.h\"\n\n#define CREATE_TRACE_POINTS\n#include \"trace.h\"\n\nstatic bool cxl_is_hpa_in_range(u64 hpa, struct cxl_region *cxlr, int pos)\n{\n\tstruct cxl_region_params *p = &cxlr->params;\n\tint gran = p->interleave_granularity;\n\tint ways = p->interleave_ways;\n\tu64 offset;\n\n\t \n\tif (hpa < p->res->start || hpa > p->res->end) {\n\t\tdev_dbg(&cxlr->dev,\n\t\t\t\"Addr trans fail: hpa 0x%llx not in region\\n\", hpa);\n\t\treturn false;\n\t}\n\n\t \n\toffset = hpa - p->res->start;\n\toffset = do_div(offset, gran * ways);\n\tif ((offset >= pos * gran) && (offset < (pos + 1) * gran))\n\t\treturn true;\n\n\tdev_dbg(&cxlr->dev,\n\t\t\"Addr trans fail: hpa 0x%llx not in expected chunk\\n\", hpa);\n\n\treturn false;\n}\n\nstatic u64 cxl_dpa_to_hpa(u64 dpa,  struct cxl_region *cxlr,\n\t\t\t  struct cxl_endpoint_decoder *cxled)\n{\n\tu64 dpa_offset, hpa_offset, bits_upper, mask_upper, hpa;\n\tstruct cxl_region_params *p = &cxlr->params;\n\tint pos = cxled->pos;\n\tu16 eig = 0;\n\tu8 eiw = 0;\n\n\tways_to_eiw(p->interleave_ways, &eiw);\n\tgranularity_to_eig(p->interleave_granularity, &eig);\n\n\t \n\n\t \n\tdpa_offset = dpa - cxl_dpa_resource_start(cxled);\n\n\tmask_upper = GENMASK_ULL(51, eig + 8);\n\n\tif (eiw < 8) {\n\t\thpa_offset = (dpa_offset & mask_upper) << eiw;\n\t\thpa_offset |= pos << (eig + 8);\n\t} else {\n\t\tbits_upper = (dpa_offset & mask_upper) >> (eig + 8);\n\t\tbits_upper = bits_upper * 3;\n\t\thpa_offset = ((bits_upper << (eiw - 8)) + pos) << (eig + 8);\n\t}\n\n\t \n\thpa_offset |= dpa_offset & GENMASK_ULL(eig + 7, 0);\n\n\t \n\thpa = hpa_offset + p->res->start;\n\n\tif (!cxl_is_hpa_in_range(hpa, cxlr, cxled->pos))\n\t\treturn ULLONG_MAX;\n\n\treturn hpa;\n}\n\nu64 cxl_trace_hpa(struct cxl_region *cxlr, struct cxl_memdev *cxlmd,\n\t\t  u64 dpa)\n{\n\tstruct cxl_region_params *p = &cxlr->params;\n\tstruct cxl_endpoint_decoder *cxled = NULL;\n\n\tfor (int i = 0; i <  p->nr_targets; i++) {\n\t\tcxled = p->targets[i];\n\t\tif (cxlmd == cxled_to_memdev(cxled))\n\t\t\tbreak;\n\t}\n\tif (!cxled || cxlmd != cxled_to_memdev(cxled))\n\t\treturn ULLONG_MAX;\n\n\treturn cxl_dpa_to_hpa(dpa, cxlr, cxled);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}