{
  "module_name": "i2c-stub.c",
  "hash_id": "5e9c29a243cc9c0a897f86524b32a2d00d3480f3a45fe31f1c501a957119e7f2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/i2c-stub.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"i2c-stub: \" fmt\n\n#include <linux/errno.h>\n#include <linux/i2c.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\n#define MAX_CHIPS 10\n\n \n#define STUB_FUNC_DEFAULT \\\n\t\t(I2C_FUNC_SMBUS_QUICK | I2C_FUNC_SMBUS_BYTE | \\\n\t\t I2C_FUNC_SMBUS_BYTE_DATA | I2C_FUNC_SMBUS_WORD_DATA | \\\n\t\t I2C_FUNC_SMBUS_I2C_BLOCK)\n\n#define STUB_FUNC_ALL \\\n\t\t(STUB_FUNC_DEFAULT | I2C_FUNC_SMBUS_BLOCK_DATA)\n\nstatic unsigned short chip_addr[MAX_CHIPS];\nmodule_param_array(chip_addr, ushort, NULL, S_IRUGO);\nMODULE_PARM_DESC(chip_addr,\n\t\t \"Chip addresses (up to 10, between 0x03 and 0x77)\");\n\nstatic unsigned long functionality = STUB_FUNC_DEFAULT;\nmodule_param(functionality, ulong, S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(functionality, \"Override functionality bitfield\");\n\n \n\nstatic u8 bank_reg[MAX_CHIPS];\nmodule_param_array(bank_reg, byte, NULL, S_IRUGO);\nMODULE_PARM_DESC(bank_reg, \"Bank register\");\n\nstatic u8 bank_mask[MAX_CHIPS];\nmodule_param_array(bank_mask, byte, NULL, S_IRUGO);\nMODULE_PARM_DESC(bank_mask, \"Bank value mask\");\n\nstatic u8 bank_start[MAX_CHIPS];\nmodule_param_array(bank_start, byte, NULL, S_IRUGO);\nMODULE_PARM_DESC(bank_start, \"First banked register\");\n\nstatic u8 bank_end[MAX_CHIPS];\nmodule_param_array(bank_end, byte, NULL, S_IRUGO);\nMODULE_PARM_DESC(bank_end, \"Last banked register\");\n\nstruct smbus_block_data {\n\tstruct list_head node;\n\tu8 command;\n\tu8 len;\n\tu8 block[I2C_SMBUS_BLOCK_MAX];\n};\n\nstruct stub_chip {\n\tu8 pointer;\n\tu16 words[256];\t\t \n\tstruct list_head smbus_blocks;\n\n\t \n\tu8 bank_reg;\n\tu8 bank_shift;\n\tu8 bank_mask;\n\tu8 bank_sel;\t\t \n\tu8 bank_start;\n\tu8 bank_end;\n\tu16 bank_size;\n\tu16 *bank_words;\t \n};\n\nstatic struct stub_chip *stub_chips;\nstatic int stub_chips_nr;\n\nstatic struct smbus_block_data *stub_find_block(struct device *dev,\n\t\t\t\t\t\tstruct stub_chip *chip,\n\t\t\t\t\t\tu8 command, bool create)\n{\n\tstruct smbus_block_data *b, *rb = NULL;\n\n\tlist_for_each_entry(b, &chip->smbus_blocks, node) {\n\t\tif (b->command == command) {\n\t\t\trb = b;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (rb == NULL && create) {\n\t\trb = devm_kzalloc(dev, sizeof(*rb), GFP_KERNEL);\n\t\tif (rb == NULL)\n\t\t\treturn rb;\n\t\trb->command = command;\n\t\tlist_add(&rb->node, &chip->smbus_blocks);\n\t}\n\treturn rb;\n}\n\nstatic u16 *stub_get_wordp(struct stub_chip *chip, u8 offset)\n{\n\tif (chip->bank_sel &&\n\t    offset >= chip->bank_start && offset <= chip->bank_end)\n\t\treturn chip->bank_words +\n\t\t       (chip->bank_sel - 1) * chip->bank_size +\n\t\t       offset - chip->bank_start;\n\telse\n\t\treturn chip->words + offset;\n}\n\n \nstatic s32 stub_xfer(struct i2c_adapter *adap, u16 addr, unsigned short flags,\n\tchar read_write, u8 command, int size, union i2c_smbus_data *data)\n{\n\ts32 ret;\n\tint i, len;\n\tstruct stub_chip *chip = NULL;\n\tstruct smbus_block_data *b;\n\tu16 *wordp;\n\n\t \n\tfor (i = 0; i < stub_chips_nr; i++) {\n\t\tif (addr == chip_addr[i]) {\n\t\t\tchip = stub_chips + i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!chip)\n\t\treturn -ENODEV;\n\n\tswitch (size) {\n\n\tcase I2C_SMBUS_QUICK:\n\t\tdev_dbg(&adap->dev, \"smbus quick - addr 0x%02x\\n\", addr);\n\t\tret = 0;\n\t\tbreak;\n\n\tcase I2C_SMBUS_BYTE:\n\t\tif (read_write == I2C_SMBUS_WRITE) {\n\t\t\tchip->pointer = command;\n\t\t\tdev_dbg(&adap->dev,\n\t\t\t\t\"smbus byte - addr 0x%02x, wrote 0x%02x.\\n\",\n\t\t\t\taddr, command);\n\t\t} else {\n\t\t\twordp = stub_get_wordp(chip, chip->pointer++);\n\t\t\tdata->byte = *wordp & 0xff;\n\t\t\tdev_dbg(&adap->dev,\n\t\t\t\t\"smbus byte - addr 0x%02x, read  0x%02x.\\n\",\n\t\t\t\taddr, data->byte);\n\t\t}\n\n\t\tret = 0;\n\t\tbreak;\n\n\tcase I2C_SMBUS_BYTE_DATA:\n\t\twordp = stub_get_wordp(chip, command);\n\t\tif (read_write == I2C_SMBUS_WRITE) {\n\t\t\t*wordp &= 0xff00;\n\t\t\t*wordp |= data->byte;\n\t\t\tdev_dbg(&adap->dev,\n\t\t\t\t\"smbus byte data - addr 0x%02x, wrote 0x%02x at 0x%02x.\\n\",\n\t\t\t\taddr, data->byte, command);\n\n\t\t\t \n\t\t\tif (chip->bank_words && command == chip->bank_reg) {\n\t\t\t\tchip->bank_sel =\n\t\t\t\t\t(data->byte >> chip->bank_shift)\n\t\t\t\t\t& chip->bank_mask;\n\t\t\t\tdev_dbg(&adap->dev,\n\t\t\t\t\t\"switching to bank %u.\\n\",\n\t\t\t\t\tchip->bank_sel);\n\t\t\t}\n\t\t} else {\n\t\t\tdata->byte = *wordp & 0xff;\n\t\t\tdev_dbg(&adap->dev,\n\t\t\t\t\"smbus byte data - addr 0x%02x, read  0x%02x at 0x%02x.\\n\",\n\t\t\t\taddr, data->byte, command);\n\t\t}\n\t\tchip->pointer = command + 1;\n\n\t\tret = 0;\n\t\tbreak;\n\n\tcase I2C_SMBUS_WORD_DATA:\n\t\twordp = stub_get_wordp(chip, command);\n\t\tif (read_write == I2C_SMBUS_WRITE) {\n\t\t\t*wordp = data->word;\n\t\t\tdev_dbg(&adap->dev,\n\t\t\t\t\"smbus word data - addr 0x%02x, wrote 0x%04x at 0x%02x.\\n\",\n\t\t\t\taddr, data->word, command);\n\t\t} else {\n\t\t\tdata->word = *wordp;\n\t\t\tdev_dbg(&adap->dev,\n\t\t\t\t\"smbus word data - addr 0x%02x, read  0x%04x at 0x%02x.\\n\",\n\t\t\t\taddr, data->word, command);\n\t\t}\n\n\t\tret = 0;\n\t\tbreak;\n\n\tcase I2C_SMBUS_I2C_BLOCK_DATA:\n\t\t \n\t\tif (data->block[0] > 256 - command)\t \n\t\t\tdata->block[0] = 256 - command;\n\t\tlen = data->block[0];\n\t\tif (read_write == I2C_SMBUS_WRITE) {\n\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\tchip->words[command + i] &= 0xff00;\n\t\t\t\tchip->words[command + i] |= data->block[1 + i];\n\t\t\t}\n\t\t\tdev_dbg(&adap->dev,\n\t\t\t\t\"i2c block data - addr 0x%02x, wrote %d bytes at 0x%02x.\\n\",\n\t\t\t\taddr, len, command);\n\t\t} else {\n\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\tdata->block[1 + i] =\n\t\t\t\t\tchip->words[command + i] & 0xff;\n\t\t\t}\n\t\t\tdev_dbg(&adap->dev,\n\t\t\t\t\"i2c block data - addr 0x%02x, read  %d bytes at 0x%02x.\\n\",\n\t\t\t\taddr, len, command);\n\t\t}\n\n\t\tret = 0;\n\t\tbreak;\n\n\tcase I2C_SMBUS_BLOCK_DATA:\n\t\t \n\t\tb = stub_find_block(&adap->dev, chip, command, false);\n\t\tif (read_write == I2C_SMBUS_WRITE) {\n\t\t\tlen = data->block[0];\n\t\t\tif (len == 0 || len > I2C_SMBUS_BLOCK_MAX) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (b == NULL) {\n\t\t\t\tb = stub_find_block(&adap->dev, chip, command,\n\t\t\t\t\t\t    true);\n\t\t\t\tif (b == NULL) {\n\t\t\t\t\tret = -ENOMEM;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t \n\t\t\tif (len > b->len)\n\t\t\t\tb->len = len;\n\t\t\tfor (i = 0; i < len; i++)\n\t\t\t\tb->block[i] = data->block[i + 1];\n\t\t\t \n\t\t\tchip->words[command] = (b->block[0] << 8) | b->len;\n\t\t\tdev_dbg(&adap->dev,\n\t\t\t\t\"smbus block data - addr 0x%02x, wrote %d bytes at 0x%02x.\\n\",\n\t\t\t\taddr, len, command);\n\t\t} else {\n\t\t\tif (b == NULL) {\n\t\t\t\tdev_dbg(&adap->dev,\n\t\t\t\t\t\"SMBus block read command without prior block write not supported\\n\");\n\t\t\t\tret = -EOPNOTSUPP;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlen = b->len;\n\t\t\tdata->block[0] = len;\n\t\t\tfor (i = 0; i < len; i++)\n\t\t\t\tdata->block[i + 1] = b->block[i];\n\t\t\tdev_dbg(&adap->dev,\n\t\t\t\t\"smbus block data - addr 0x%02x, read  %d bytes at 0x%02x.\\n\",\n\t\t\t\taddr, len, command);\n\t\t}\n\n\t\tret = 0;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_dbg(&adap->dev, \"Unsupported I2C/SMBus command\\n\");\n\t\tret = -EOPNOTSUPP;\n\t\tbreak;\n\t}  \n\n\treturn ret;\n}\n\nstatic u32 stub_func(struct i2c_adapter *adapter)\n{\n\treturn STUB_FUNC_ALL & functionality;\n}\n\nstatic const struct i2c_algorithm smbus_algorithm = {\n\t.functionality\t= stub_func,\n\t.smbus_xfer\t= stub_xfer,\n};\n\nstatic struct i2c_adapter stub_adapter = {\n\t.owner\t\t= THIS_MODULE,\n\t.class\t\t= I2C_CLASS_HWMON | I2C_CLASS_SPD,\n\t.algo\t\t= &smbus_algorithm,\n\t.name\t\t= \"SMBus stub driver\",\n};\n\nstatic int __init i2c_stub_allocate_banks(int i)\n{\n\tstruct stub_chip *chip = stub_chips + i;\n\n\tchip->bank_reg = bank_reg[i];\n\tchip->bank_start = bank_start[i];\n\tchip->bank_end = bank_end[i];\n\tchip->bank_size = bank_end[i] - bank_start[i] + 1;\n\n\t \n\tchip->bank_mask = bank_mask[i];\n\twhile (!(chip->bank_mask & 1)) {\n\t\tchip->bank_shift++;\n\t\tchip->bank_mask >>= 1;\n\t}\n\n\tchip->bank_words = kcalloc(chip->bank_mask * chip->bank_size,\n\t\t\t\t   sizeof(u16),\n\t\t\t\t   GFP_KERNEL);\n\tif (!chip->bank_words)\n\t\treturn -ENOMEM;\n\n\tpr_debug(\"Allocated %u banks of %u words each (registers 0x%02x to 0x%02x)\\n\",\n\t\t chip->bank_mask, chip->bank_size, chip->bank_start,\n\t\t chip->bank_end);\n\n\treturn 0;\n}\n\nstatic void i2c_stub_free(void)\n{\n\tint i;\n\n\tfor (i = 0; i < stub_chips_nr; i++)\n\t\tkfree(stub_chips[i].bank_words);\n\tkfree(stub_chips);\n}\n\nstatic int __init i2c_stub_init(void)\n{\n\tint i, ret;\n\n\tif (!chip_addr[0]) {\n\t\tpr_err(\"Please specify a chip address\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tfor (i = 0; i < MAX_CHIPS && chip_addr[i]; i++) {\n\t\tif (chip_addr[i] < 0x03 || chip_addr[i] > 0x77) {\n\t\t\tpr_err(\"Invalid chip address 0x%02x\\n\",\n\t\t\t       chip_addr[i]);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tpr_info(\"Virtual chip at 0x%02x\\n\", chip_addr[i]);\n\t}\n\n\t \n\tstub_chips_nr = i;\n\tstub_chips = kcalloc(stub_chips_nr, sizeof(struct stub_chip),\n\t\t\t     GFP_KERNEL);\n\tif (!stub_chips)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < stub_chips_nr; i++) {\n\t\tINIT_LIST_HEAD(&stub_chips[i].smbus_blocks);\n\n\t\t \n\t\tif (bank_mask[i]) {\n\t\t\tret = i2c_stub_allocate_banks(i);\n\t\t\tif (ret)\n\t\t\t\tgoto fail_free;\n\t\t}\n\t}\n\n\tret = i2c_add_adapter(&stub_adapter);\n\tif (ret)\n\t\tgoto fail_free;\n\n\treturn 0;\n\n fail_free:\n\ti2c_stub_free();\n\treturn ret;\n}\n\nstatic void __exit i2c_stub_exit(void)\n{\n\ti2c_del_adapter(&stub_adapter);\n\ti2c_stub_free();\n}\n\nMODULE_AUTHOR(\"Mark M. Hoffman <mhoffman@lightlink.com>\");\nMODULE_DESCRIPTION(\"I2C stub driver\");\nMODULE_LICENSE(\"GPL\");\n\nmodule_init(i2c_stub_init);\nmodule_exit(i2c_stub_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}