{
  "module_name": "i2c-smbus.c",
  "hash_id": "d7b8d26572218752d811d29c20eae17a2ed3d987e6c2400d8782915f802a7b76",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/i2c-smbus.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/dmi.h>\n#include <linux/i2c.h>\n#include <linux/i2c-smbus.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/property.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n\nstruct i2c_smbus_alert {\n\tstruct work_struct\talert;\n\tstruct i2c_client\t*ara;\t\t \n};\n\nstruct alert_data {\n\tunsigned short\t\taddr;\n\tenum i2c_alert_protocol\ttype;\n\tunsigned int\t\tdata;\n};\n\n \nstatic int smbus_do_alert(struct device *dev, void *addrp)\n{\n\tstruct i2c_client *client = i2c_verify_client(dev);\n\tstruct alert_data *data = addrp;\n\tstruct i2c_driver *driver;\n\n\tif (!client || client->addr != data->addr)\n\t\treturn 0;\n\tif (client->flags & I2C_CLIENT_TEN)\n\t\treturn 0;\n\n\t \n\tdevice_lock(dev);\n\tif (client->dev.driver) {\n\t\tdriver = to_i2c_driver(client->dev.driver);\n\t\tif (driver->alert)\n\t\t\tdriver->alert(client, data->type, data->data);\n\t\telse\n\t\t\tdev_warn(&client->dev, \"no driver alert()!\\n\");\n\t} else\n\t\tdev_dbg(&client->dev, \"alert with no driver\\n\");\n\tdevice_unlock(dev);\n\n\t \n\treturn -EBUSY;\n}\n\n \nstatic irqreturn_t smbus_alert(int irq, void *d)\n{\n\tstruct i2c_smbus_alert *alert = d;\n\tstruct i2c_client *ara;\n\n\tara = alert->ara;\n\n\tfor (;;) {\n\t\ts32 status;\n\t\tstruct alert_data data;\n\n\t\t \n\t\tstatus = i2c_smbus_read_byte(ara);\n\t\tif (status < 0)\n\t\t\tbreak;\n\n\t\tdata.data = status & 1;\n\t\tdata.addr = status >> 1;\n\t\tdata.type = I2C_PROTOCOL_SMBUS_ALERT;\n\n\t\tdev_dbg(&ara->dev, \"SMBALERT# from dev 0x%02x, flag %d\\n\",\n\t\t\tdata.addr, data.data);\n\n\t\t \n\t\tdevice_for_each_child(&ara->adapter->dev, &data,\n\t\t\t\t      smbus_do_alert);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void smbalert_work(struct work_struct *work)\n{\n\tstruct i2c_smbus_alert *alert;\n\n\talert = container_of(work, struct i2c_smbus_alert, alert);\n\n\tsmbus_alert(0, alert);\n\n}\n\n \nstatic int smbalert_probe(struct i2c_client *ara)\n{\n\tstruct i2c_smbus_alert_setup *setup = dev_get_platdata(&ara->dev);\n\tstruct i2c_smbus_alert *alert;\n\tstruct i2c_adapter *adapter = ara->adapter;\n\tint res, irq;\n\n\talert = devm_kzalloc(&ara->dev, sizeof(struct i2c_smbus_alert),\n\t\t\t     GFP_KERNEL);\n\tif (!alert)\n\t\treturn -ENOMEM;\n\n\tif (setup) {\n\t\tirq = setup->irq;\n\t} else {\n\t\tirq = fwnode_irq_get_byname(dev_fwnode(adapter->dev.parent),\n\t\t\t\t\t    \"smbus_alert\");\n\t\tif (irq <= 0)\n\t\t\treturn irq;\n\t}\n\n\tINIT_WORK(&alert->alert, smbalert_work);\n\talert->ara = ara;\n\n\tif (irq > 0) {\n\t\tres = devm_request_threaded_irq(&ara->dev, irq,\n\t\t\t\t\t\tNULL, smbus_alert,\n\t\t\t\t\t\tIRQF_SHARED | IRQF_ONESHOT,\n\t\t\t\t\t\t\"smbus_alert\", alert);\n\t\tif (res)\n\t\t\treturn res;\n\t}\n\n\ti2c_set_clientdata(ara, alert);\n\tdev_info(&adapter->dev, \"supports SMBALERT#\\n\");\n\n\treturn 0;\n}\n\n \nstatic void smbalert_remove(struct i2c_client *ara)\n{\n\tstruct i2c_smbus_alert *alert = i2c_get_clientdata(ara);\n\n\tcancel_work_sync(&alert->alert);\n}\n\nstatic const struct i2c_device_id smbalert_ids[] = {\n\t{ \"smbus_alert\", 0 },\n\t{   }\n};\nMODULE_DEVICE_TABLE(i2c, smbalert_ids);\n\nstatic struct i2c_driver smbalert_driver = {\n\t.driver = {\n\t\t.name\t= \"smbus_alert\",\n\t},\n\t.probe\t\t= smbalert_probe,\n\t.remove\t\t= smbalert_remove,\n\t.id_table\t= smbalert_ids,\n};\n\n \nint i2c_handle_smbus_alert(struct i2c_client *ara)\n{\n\tstruct i2c_smbus_alert *alert = i2c_get_clientdata(ara);\n\n\treturn schedule_work(&alert->alert);\n}\nEXPORT_SYMBOL_GPL(i2c_handle_smbus_alert);\n\nmodule_i2c_driver(smbalert_driver);\n\n#if IS_ENABLED(CONFIG_I2C_SLAVE)\n#define SMBUS_HOST_NOTIFY_LEN\t3\nstruct i2c_slave_host_notify_status {\n\tu8 index;\n\tu8 addr;\n};\n\nstatic int i2c_slave_host_notify_cb(struct i2c_client *client,\n\t\t\t\t    enum i2c_slave_event event, u8 *val)\n{\n\tstruct i2c_slave_host_notify_status *status = client->dev.platform_data;\n\n\tswitch (event) {\n\tcase I2C_SLAVE_WRITE_RECEIVED:\n\t\t \n\t\tif (status->index == 0)\n\t\t\tstatus->addr = *val;\n\t\tif (status->index < U8_MAX)\n\t\t\tstatus->index++;\n\t\tbreak;\n\tcase I2C_SLAVE_STOP:\n\t\tif (status->index == SMBUS_HOST_NOTIFY_LEN)\n\t\t\ti2c_handle_smbus_host_notify(client->adapter,\n\t\t\t\t\t\t     status->addr);\n\t\tfallthrough;\n\tcase I2C_SLAVE_WRITE_REQUESTED:\n\t\tstatus->index = 0;\n\t\tbreak;\n\tcase I2C_SLAVE_READ_REQUESTED:\n\tcase I2C_SLAVE_READ_PROCESSED:\n\t\t*val = 0xff;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n \nstruct i2c_client *i2c_new_slave_host_notify_device(struct i2c_adapter *adapter)\n{\n\tstruct i2c_board_info host_notify_board_info = {\n\t\tI2C_BOARD_INFO(\"smbus_host_notify\", 0x08),\n\t\t.flags  = I2C_CLIENT_SLAVE,\n\t};\n\tstruct i2c_slave_host_notify_status *status;\n\tstruct i2c_client *client;\n\tint ret;\n\n\tstatus = kzalloc(sizeof(struct i2c_slave_host_notify_status),\n\t\t\t GFP_KERNEL);\n\tif (!status)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\thost_notify_board_info.platform_data = status;\n\n\tclient = i2c_new_client_device(adapter, &host_notify_board_info);\n\tif (IS_ERR(client)) {\n\t\tkfree(status);\n\t\treturn client;\n\t}\n\n\tret = i2c_slave_register(client, i2c_slave_host_notify_cb);\n\tif (ret) {\n\t\ti2c_unregister_device(client);\n\t\tkfree(status);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn client;\n}\nEXPORT_SYMBOL_GPL(i2c_new_slave_host_notify_device);\n\n \nvoid i2c_free_slave_host_notify_device(struct i2c_client *client)\n{\n\tif (IS_ERR_OR_NULL(client))\n\t\treturn;\n\n\ti2c_slave_unregister(client);\n\tkfree(client->dev.platform_data);\n\ti2c_unregister_device(client);\n}\nEXPORT_SYMBOL_GPL(i2c_free_slave_host_notify_device);\n#endif\n\n \n#if IS_ENABLED(CONFIG_DMI)\nvoid i2c_register_spd(struct i2c_adapter *adap)\n{\n\tint n, slot_count = 0, dimm_count = 0;\n\tu16 handle;\n\tu8 common_mem_type = 0x0, mem_type;\n\tu64 mem_size;\n\tconst char *name;\n\n\twhile ((handle = dmi_memdev_handle(slot_count)) != 0xffff) {\n\t\tslot_count++;\n\n\t\t \n\t\tmem_size = dmi_memdev_size(handle);\n\t\tif (!mem_size)\n\t\t\tcontinue;\n\n\t\t \n\t\tmem_type = dmi_memdev_type(handle);\n\t\tif (mem_type <= 0x02)\t\t \n\t\t\tcontinue;\n\n\t\tif (!common_mem_type) {\n\t\t\t \n\t\t\tcommon_mem_type = mem_type;\n\t\t} else {\n\t\t\t \n\t\t\tif (mem_type != common_mem_type) {\n\t\t\t\tdev_warn(&adap->dev,\n\t\t\t\t\t \"Different memory types mixed, not instantiating SPD\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tdimm_count++;\n\t}\n\n\t \n\tif (!dimm_count)\n\t\treturn;\n\n\tdev_info(&adap->dev, \"%d/%d memory slots populated (from DMI)\\n\",\n\t\t dimm_count, slot_count);\n\n\tif (slot_count > 4) {\n\t\tdev_warn(&adap->dev,\n\t\t\t \"Systems with more than 4 memory slots not supported yet, not instantiating SPD\\n\");\n\t\treturn;\n\t}\n\n\t \n\tswitch (common_mem_type) {\n\tcase 0x12:\t \n\tcase 0x13:\t \n\tcase 0x18:\t \n\tcase 0x1B:\t \n\tcase 0x1C:\t \n\tcase 0x1D:\t \n\t\tname = \"spd\";\n\t\tbreak;\n\tcase 0x1A:\t \n\tcase 0x1E:\t \n\t\tname = \"ee1004\";\n\t\tbreak;\n\tdefault:\n\t\tdev_info(&adap->dev,\n\t\t\t \"Memory type 0x%02x not supported yet, not instantiating SPD\\n\",\n\t\t\t common_mem_type);\n\t\treturn;\n\t}\n\n\t \n\tfor (n = 0; n < slot_count && dimm_count; n++) {\n\t\tstruct i2c_board_info info;\n\t\tunsigned short addr_list[2];\n\n\t\tmemset(&info, 0, sizeof(struct i2c_board_info));\n\t\tstrscpy(info.type, name, I2C_NAME_SIZE);\n\t\taddr_list[0] = 0x50 + n;\n\t\taddr_list[1] = I2C_CLIENT_END;\n\n\t\tif (!IS_ERR(i2c_new_scanned_device(adap, &info, addr_list, NULL))) {\n\t\t\tdev_info(&adap->dev,\n\t\t\t\t \"Successfully instantiated SPD at 0x%hx\\n\",\n\t\t\t\t addr_list[0]);\n\t\t\tdimm_count--;\n\t\t}\n\t}\n}\nEXPORT_SYMBOL_GPL(i2c_register_spd);\n#endif\n\nMODULE_AUTHOR(\"Jean Delvare <jdelvare@suse.de>\");\nMODULE_DESCRIPTION(\"SMBus protocol extensions support\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}