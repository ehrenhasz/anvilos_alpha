{
  "module_name": "i2c-algo-bit.c",
  "hash_id": "99d7e0e50ced9ffd815abe463e8fb0b29f2b556232a6851c851a60b27c5dabb2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/algos/i2c-algo-bit.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/errno.h>\n#include <linux/sched.h>\n#include <linux/i2c.h>\n#include <linux/i2c-algo-bit.h>\n\n\n \n\n#ifdef DEBUG\n#define bit_dbg(level, dev, format, args...) \\\n\tdo { \\\n\t\tif (i2c_debug >= level) \\\n\t\t\tdev_dbg(dev, format, ##args); \\\n\t} while (0)\n#else\n#define bit_dbg(level, dev, format, args...) \\\n\tdo {} while (0)\n#endif  \n\n \n\nstatic int bit_test;\t \nmodule_param(bit_test, int, S_IRUGO);\nMODULE_PARM_DESC(bit_test, \"lines testing - 0 off; 1 report; 2 fail if stuck\");\n\n#ifdef DEBUG\nstatic int i2c_debug = 1;\nmodule_param(i2c_debug, int, S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(i2c_debug,\n\t\t \"debug level - 0 off; 1 normal; 2 verbose; 3 very verbose\");\n#endif\n\n \n\n#define setsda(adap, val)\tadap->setsda(adap->data, val)\n#define setscl(adap, val)\tadap->setscl(adap->data, val)\n#define getsda(adap)\t\tadap->getsda(adap->data)\n#define getscl(adap)\t\tadap->getscl(adap->data)\n\nstatic inline void sdalo(struct i2c_algo_bit_data *adap)\n{\n\tsetsda(adap, 0);\n\tudelay((adap->udelay + 1) / 2);\n}\n\nstatic inline void sdahi(struct i2c_algo_bit_data *adap)\n{\n\tsetsda(adap, 1);\n\tudelay((adap->udelay + 1) / 2);\n}\n\nstatic inline void scllo(struct i2c_algo_bit_data *adap)\n{\n\tsetscl(adap, 0);\n\tudelay(adap->udelay / 2);\n}\n\n \nstatic int sclhi(struct i2c_algo_bit_data *adap)\n{\n\tunsigned long start;\n\n\tsetscl(adap, 1);\n\n\t \n\tif (!adap->getscl)\n\t\tgoto done;\n\n\tstart = jiffies;\n\twhile (!getscl(adap)) {\n\t\t \n\t\tif (time_after(jiffies, start + adap->timeout)) {\n\t\t\t \n\t\t\tif (getscl(adap))\n\t\t\t\tbreak;\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t\tcpu_relax();\n\t}\n#ifdef DEBUG\n\tif (jiffies != start && i2c_debug >= 3)\n\t\tpr_debug(\"i2c-algo-bit: needed %ld jiffies for SCL to go high\\n\",\n\t\t\t jiffies - start);\n#endif\n\ndone:\n\tudelay(adap->udelay);\n\treturn 0;\n}\n\n\n \nstatic void i2c_start(struct i2c_algo_bit_data *adap)\n{\n\t \n\tsetsda(adap, 0);\n\tudelay(adap->udelay);\n\tscllo(adap);\n}\n\nstatic void i2c_repstart(struct i2c_algo_bit_data *adap)\n{\n\t \n\tsdahi(adap);\n\tsclhi(adap);\n\tsetsda(adap, 0);\n\tudelay(adap->udelay);\n\tscllo(adap);\n}\n\n\nstatic void i2c_stop(struct i2c_algo_bit_data *adap)\n{\n\t \n\tsdalo(adap);\n\tsclhi(adap);\n\tsetsda(adap, 1);\n\tudelay(adap->udelay);\n}\n\n\n\n \n \nstatic int i2c_outb(struct i2c_adapter *i2c_adap, unsigned char c)\n{\n\tint i;\n\tint sb;\n\tint ack;\n\tstruct i2c_algo_bit_data *adap = i2c_adap->algo_data;\n\n\t \n\tfor (i = 7; i >= 0; i--) {\n\t\tsb = (c >> i) & 1;\n\t\tsetsda(adap, sb);\n\t\tudelay((adap->udelay + 1) / 2);\n\t\tif (sclhi(adap) < 0) {  \n\t\t\tbit_dbg(1, &i2c_adap->dev,\n\t\t\t\t\"i2c_outb: 0x%02x, timeout at bit #%d\\n\",\n\t\t\t\t(int)c, i);\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t\t \n\t\tscllo(adap);\n\t}\n\tsdahi(adap);\n\tif (sclhi(adap) < 0) {  \n\t\tbit_dbg(1, &i2c_adap->dev,\n\t\t\t\"i2c_outb: 0x%02x, timeout at ack\\n\", (int)c);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\t \n\tack = !adap->getsda || !getsda(adap);     \n\tbit_dbg(2, &i2c_adap->dev, \"i2c_outb: 0x%02x %s\\n\", (int)c,\n\t\tack ? \"A\" : \"NA\");\n\n\tscllo(adap);\n\treturn ack;\n\t \n}\n\n\nstatic int i2c_inb(struct i2c_adapter *i2c_adap)\n{\n\t \n\t \n\tint i;\n\tunsigned char indata = 0;\n\tstruct i2c_algo_bit_data *adap = i2c_adap->algo_data;\n\n\t \n\tsdahi(adap);\n\tfor (i = 0; i < 8; i++) {\n\t\tif (sclhi(adap) < 0) {  \n\t\t\tbit_dbg(1, &i2c_adap->dev,\n\t\t\t\t\"i2c_inb: timeout at bit #%d\\n\",\n\t\t\t\t7 - i);\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t\tindata *= 2;\n\t\tif (getsda(adap))\n\t\t\tindata |= 0x01;\n\t\tsetscl(adap, 0);\n\t\tudelay(i == 7 ? adap->udelay / 2 : adap->udelay);\n\t}\n\t \n\treturn indata;\n}\n\n \nstatic int test_bus(struct i2c_adapter *i2c_adap)\n{\n\tstruct i2c_algo_bit_data *adap = i2c_adap->algo_data;\n\tconst char *name = i2c_adap->name;\n\tint scl, sda, ret;\n\n\tif (adap->pre_xfer) {\n\t\tret = adap->pre_xfer(i2c_adap);\n\t\tif (ret < 0)\n\t\t\treturn -ENODEV;\n\t}\n\n\tif (adap->getsda == NULL)\n\t\tpr_info(\"%s: SDA is write-only, testing not possible\\n\", name);\n\tif (adap->getscl == NULL)\n\t\tpr_info(\"%s: SCL is write-only, testing not possible\\n\", name);\n\n\tsda = adap->getsda ? getsda(adap) : 1;\n\tscl = adap->getscl ? getscl(adap) : 1;\n\tif (!scl || !sda) {\n\t\tpr_warn(\"%s: bus seems to be busy (scl=%d, sda=%d)\\n\", name, scl, sda);\n\t\tgoto bailout;\n\t}\n\n\tsdalo(adap);\n\tif (adap->getsda && getsda(adap)) {\n\t\tpr_warn(\"%s: SDA stuck high!\\n\", name);\n\t\tgoto bailout;\n\t}\n\tif (adap->getscl && !getscl(adap)) {\n\t\tpr_warn(\"%s: SCL unexpected low while pulling SDA low!\\n\", name);\n\t\tgoto bailout;\n\t}\n\n\tsdahi(adap);\n\tif (adap->getsda && !getsda(adap)) {\n\t\tpr_warn(\"%s: SDA stuck low!\\n\", name);\n\t\tgoto bailout;\n\t}\n\tif (adap->getscl && !getscl(adap)) {\n\t\tpr_warn(\"%s: SCL unexpected low while pulling SDA high!\\n\", name);\n\t\tgoto bailout;\n\t}\n\n\tscllo(adap);\n\tif (adap->getscl && getscl(adap)) {\n\t\tpr_warn(\"%s: SCL stuck high!\\n\", name);\n\t\tgoto bailout;\n\t}\n\tif (adap->getsda && !getsda(adap)) {\n\t\tpr_warn(\"%s: SDA unexpected low while pulling SCL low!\\n\", name);\n\t\tgoto bailout;\n\t}\n\n\tsclhi(adap);\n\tif (adap->getscl && !getscl(adap)) {\n\t\tpr_warn(\"%s: SCL stuck low!\\n\", name);\n\t\tgoto bailout;\n\t}\n\tif (adap->getsda && !getsda(adap)) {\n\t\tpr_warn(\"%s: SDA unexpected low while pulling SCL high!\\n\", name);\n\t\tgoto bailout;\n\t}\n\n\tif (adap->post_xfer)\n\t\tadap->post_xfer(i2c_adap);\n\n\tpr_info(\"%s: Test OK\\n\", name);\n\treturn 0;\nbailout:\n\tsdahi(adap);\n\tsclhi(adap);\n\n\tif (adap->post_xfer)\n\t\tadap->post_xfer(i2c_adap);\n\n\treturn -ENODEV;\n}\n\n \n\n \nstatic int try_address(struct i2c_adapter *i2c_adap,\n\t\t       unsigned char addr, int retries)\n{\n\tstruct i2c_algo_bit_data *adap = i2c_adap->algo_data;\n\tint i, ret = 0;\n\n\tfor (i = 0; i <= retries; i++) {\n\t\tret = i2c_outb(i2c_adap, addr);\n\t\tif (ret == 1 || i == retries)\n\t\t\tbreak;\n\t\tbit_dbg(3, &i2c_adap->dev, \"emitting stop condition\\n\");\n\t\ti2c_stop(adap);\n\t\tudelay(adap->udelay);\n\t\tyield();\n\t\tbit_dbg(3, &i2c_adap->dev, \"emitting start condition\\n\");\n\t\ti2c_start(adap);\n\t}\n\tif (i && ret)\n\t\tbit_dbg(1, &i2c_adap->dev,\n\t\t\t\"Used %d tries to %s client at 0x%02x: %s\\n\", i + 1,\n\t\t\taddr & 1 ? \"read from\" : \"write to\", addr >> 1,\n\t\t\tret == 1 ? \"success\" : \"failed, timeout?\");\n\treturn ret;\n}\n\nstatic int sendbytes(struct i2c_adapter *i2c_adap, struct i2c_msg *msg)\n{\n\tconst unsigned char *temp = msg->buf;\n\tint count = msg->len;\n\tunsigned short nak_ok = msg->flags & I2C_M_IGNORE_NAK;\n\tint retval;\n\tint wrcount = 0;\n\n\twhile (count > 0) {\n\t\tretval = i2c_outb(i2c_adap, *temp);\n\n\t\t \n\t\tif ((retval > 0) || (nak_ok && (retval == 0))) {\n\t\t\tcount--;\n\t\t\ttemp++;\n\t\t\twrcount++;\n\n\t\t \n\t\t} else if (retval == 0) {\n\t\t\tdev_err(&i2c_adap->dev, \"sendbytes: NAK bailout.\\n\");\n\t\t\treturn -EIO;\n\n\t\t \n\t\t} else {\n\t\t\tdev_err(&i2c_adap->dev, \"sendbytes: error %d\\n\",\n\t\t\t\t\tretval);\n\t\t\treturn retval;\n\t\t}\n\t}\n\treturn wrcount;\n}\n\nstatic int acknak(struct i2c_adapter *i2c_adap, int is_ack)\n{\n\tstruct i2c_algo_bit_data *adap = i2c_adap->algo_data;\n\n\t \n\tif (is_ack)\t\t \n\t\tsetsda(adap, 0);\n\tudelay((adap->udelay + 1) / 2);\n\tif (sclhi(adap) < 0) {\t \n\t\tdev_err(&i2c_adap->dev, \"readbytes: ack/nak timeout\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\tscllo(adap);\n\treturn 0;\n}\n\nstatic int readbytes(struct i2c_adapter *i2c_adap, struct i2c_msg *msg)\n{\n\tint inval;\n\tint rdcount = 0;\t \n\tunsigned char *temp = msg->buf;\n\tint count = msg->len;\n\tconst unsigned flags = msg->flags;\n\tstruct i2c_algo_bit_data *adap = i2c_adap->algo_data;\n\n\tif (!adap->getsda)\n\t\treturn -EOPNOTSUPP;\n\n\twhile (count > 0) {\n\t\tinval = i2c_inb(i2c_adap);\n\t\tif (inval >= 0) {\n\t\t\t*temp = inval;\n\t\t\trdcount++;\n\t\t} else {    \n\t\t\tbreak;\n\t\t}\n\n\t\ttemp++;\n\t\tcount--;\n\n\t\t \n\t\tif (rdcount == 1 && (flags & I2C_M_RECV_LEN)) {\n\t\t\tif (inval <= 0 || inval > I2C_SMBUS_BLOCK_MAX) {\n\t\t\t\tif (!(flags & I2C_M_NO_RD_ACK))\n\t\t\t\t\tacknak(i2c_adap, 0);\n\t\t\t\tdev_err(&i2c_adap->dev,\n\t\t\t\t\t\"readbytes: invalid block length (%d)\\n\",\n\t\t\t\t\tinval);\n\t\t\t\treturn -EPROTO;\n\t\t\t}\n\t\t\t \n\t\t\tcount += inval;\n\t\t\tmsg->len += inval;\n\t\t}\n\n\t\tbit_dbg(2, &i2c_adap->dev, \"readbytes: 0x%02x %s\\n\",\n\t\t\tinval,\n\t\t\t(flags & I2C_M_NO_RD_ACK)\n\t\t\t\t? \"(no ack/nak)\"\n\t\t\t\t: (count ? \"A\" : \"NA\"));\n\n\t\tif (!(flags & I2C_M_NO_RD_ACK)) {\n\t\t\tinval = acknak(i2c_adap, count);\n\t\t\tif (inval < 0)\n\t\t\t\treturn inval;\n\t\t}\n\t}\n\treturn rdcount;\n}\n\n \nstatic int bit_doAddress(struct i2c_adapter *i2c_adap, struct i2c_msg *msg)\n{\n\tunsigned short flags = msg->flags;\n\tunsigned short nak_ok = msg->flags & I2C_M_IGNORE_NAK;\n\tstruct i2c_algo_bit_data *adap = i2c_adap->algo_data;\n\n\tunsigned char addr;\n\tint ret, retries;\n\n\tretries = nak_ok ? 0 : i2c_adap->retries;\n\n\tif (flags & I2C_M_TEN) {\n\t\t \n\t\taddr = 0xf0 | ((msg->addr >> 7) & 0x06);\n\t\tbit_dbg(2, &i2c_adap->dev, \"addr0: %d\\n\", addr);\n\t\t \n\t\tret = try_address(i2c_adap, addr, retries);\n\t\tif ((ret != 1) && !nak_ok)  {\n\t\t\tdev_err(&i2c_adap->dev,\n\t\t\t\t\"died at extended address code\\n\");\n\t\t\treturn -ENXIO;\n\t\t}\n\t\t \n\t\tret = i2c_outb(i2c_adap, msg->addr & 0xff);\n\t\tif ((ret != 1) && !nak_ok) {\n\t\t\t \n\t\t\tdev_err(&i2c_adap->dev, \"died at 2nd address code\\n\");\n\t\t\treturn -ENXIO;\n\t\t}\n\t\tif (flags & I2C_M_RD) {\n\t\t\tbit_dbg(3, &i2c_adap->dev,\n\t\t\t\t\"emitting repeated start condition\\n\");\n\t\t\ti2c_repstart(adap);\n\t\t\t \n\t\t\taddr |= 0x01;\n\t\t\tret = try_address(i2c_adap, addr, retries);\n\t\t\tif ((ret != 1) && !nak_ok) {\n\t\t\t\tdev_err(&i2c_adap->dev,\n\t\t\t\t\t\"died at repeated address code\\n\");\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t}\n\t} else {\t\t \n\t\taddr = i2c_8bit_addr_from_msg(msg);\n\t\tif (flags & I2C_M_REV_DIR_ADDR)\n\t\t\taddr ^= 1;\n\t\tret = try_address(i2c_adap, addr, retries);\n\t\tif ((ret != 1) && !nak_ok)\n\t\t\treturn -ENXIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int bit_xfer(struct i2c_adapter *i2c_adap,\n\t\t    struct i2c_msg msgs[], int num)\n{\n\tstruct i2c_msg *pmsg;\n\tstruct i2c_algo_bit_data *adap = i2c_adap->algo_data;\n\tint i, ret;\n\tunsigned short nak_ok;\n\n\tif (adap->pre_xfer) {\n\t\tret = adap->pre_xfer(i2c_adap);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tbit_dbg(3, &i2c_adap->dev, \"emitting start condition\\n\");\n\ti2c_start(adap);\n\tfor (i = 0; i < num; i++) {\n\t\tpmsg = &msgs[i];\n\t\tnak_ok = pmsg->flags & I2C_M_IGNORE_NAK;\n\t\tif (!(pmsg->flags & I2C_M_NOSTART)) {\n\t\t\tif (i) {\n\t\t\t\tif (msgs[i - 1].flags & I2C_M_STOP) {\n\t\t\t\t\tbit_dbg(3, &i2c_adap->dev,\n\t\t\t\t\t\t\"emitting enforced stop/start condition\\n\");\n\t\t\t\t\ti2c_stop(adap);\n\t\t\t\t\ti2c_start(adap);\n\t\t\t\t} else {\n\t\t\t\t\tbit_dbg(3, &i2c_adap->dev,\n\t\t\t\t\t\t\"emitting repeated start condition\\n\");\n\t\t\t\t\ti2c_repstart(adap);\n\t\t\t\t}\n\t\t\t}\n\t\t\tret = bit_doAddress(i2c_adap, pmsg);\n\t\t\tif ((ret != 0) && !nak_ok) {\n\t\t\t\tbit_dbg(1, &i2c_adap->dev,\n\t\t\t\t\t\"NAK from device addr 0x%02x msg #%d\\n\",\n\t\t\t\t\tmsgs[i].addr, i);\n\t\t\t\tgoto bailout;\n\t\t\t}\n\t\t}\n\t\tif (pmsg->flags & I2C_M_RD) {\n\t\t\t \n\t\t\tret = readbytes(i2c_adap, pmsg);\n\t\t\tif (ret >= 1)\n\t\t\t\tbit_dbg(2, &i2c_adap->dev, \"read %d byte%s\\n\",\n\t\t\t\t\tret, ret == 1 ? \"\" : \"s\");\n\t\t\tif (ret < pmsg->len) {\n\t\t\t\tif (ret >= 0)\n\t\t\t\t\tret = -EIO;\n\t\t\t\tgoto bailout;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tret = sendbytes(i2c_adap, pmsg);\n\t\t\tif (ret >= 1)\n\t\t\t\tbit_dbg(2, &i2c_adap->dev, \"wrote %d byte%s\\n\",\n\t\t\t\t\tret, ret == 1 ? \"\" : \"s\");\n\t\t\tif (ret < pmsg->len) {\n\t\t\t\tif (ret >= 0)\n\t\t\t\t\tret = -EIO;\n\t\t\t\tgoto bailout;\n\t\t\t}\n\t\t}\n\t}\n\tret = i;\n\nbailout:\n\tbit_dbg(3, &i2c_adap->dev, \"emitting stop condition\\n\");\n\ti2c_stop(adap);\n\n\tif (adap->post_xfer)\n\t\tadap->post_xfer(i2c_adap);\n\treturn ret;\n}\n\n \nstatic int bit_xfer_atomic(struct i2c_adapter *i2c_adap, struct i2c_msg msgs[],\n\t\t\t   int num)\n{\n\tstruct i2c_algo_bit_data *adap = i2c_adap->algo_data;\n\n\tif (!adap->can_do_atomic)\n\t\tdev_warn(&i2c_adap->dev, \"not flagged for atomic transfers\\n\");\n\n\treturn bit_xfer(i2c_adap, msgs, num);\n}\n\nstatic u32 bit_func(struct i2c_adapter *adap)\n{\n\treturn I2C_FUNC_I2C | I2C_FUNC_NOSTART | I2C_FUNC_SMBUS_EMUL_ALL |\n\t       I2C_FUNC_10BIT_ADDR | I2C_FUNC_PROTOCOL_MANGLING;\n}\n\n\n \n\nconst struct i2c_algorithm i2c_bit_algo = {\n\t.master_xfer = bit_xfer,\n\t.master_xfer_atomic = bit_xfer_atomic,\n\t.functionality = bit_func,\n};\nEXPORT_SYMBOL(i2c_bit_algo);\n\nstatic const struct i2c_adapter_quirks i2c_bit_quirk_no_clk_stretch = {\n\t.flags = I2C_AQ_NO_CLK_STRETCH,\n};\n\n \nstatic int __i2c_bit_add_bus(struct i2c_adapter *adap,\n\t\t\t     int (*add_adapter)(struct i2c_adapter *))\n{\n\tstruct i2c_algo_bit_data *bit_adap = adap->algo_data;\n\tint ret;\n\n\tif (bit_test) {\n\t\tret = test_bus(adap);\n\t\tif (bit_test >= 2 && ret < 0)\n\t\t\treturn -ENODEV;\n\t}\n\n\t \n\tadap->algo = &i2c_bit_algo;\n\tadap->retries = 3;\n\tif (bit_adap->getscl == NULL)\n\t\tadap->quirks = &i2c_bit_quirk_no_clk_stretch;\n\n\t \n\n\tret = add_adapter(adap);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (bit_adap->getsda == NULL)\n\t\tdev_warn(&adap->dev, \"Not I2C compliant: can't read SDA\\n\");\n\n\tif (bit_adap->getscl == NULL)\n\t\tdev_warn(&adap->dev, \"Not I2C compliant: can't read SCL\\n\");\n\n\tif (bit_adap->getsda == NULL || bit_adap->getscl == NULL)\n\t\tdev_warn(&adap->dev, \"Bus may be unreliable\\n\");\n\n\treturn 0;\n}\n\nint i2c_bit_add_bus(struct i2c_adapter *adap)\n{\n\treturn __i2c_bit_add_bus(adap, i2c_add_adapter);\n}\nEXPORT_SYMBOL(i2c_bit_add_bus);\n\nint i2c_bit_add_numbered_bus(struct i2c_adapter *adap)\n{\n\treturn __i2c_bit_add_bus(adap, i2c_add_numbered_adapter);\n}\nEXPORT_SYMBOL(i2c_bit_add_numbered_bus);\n\nMODULE_AUTHOR(\"Simon G. Vogl <simon@tk.uni-linz.ac.at>\");\nMODULE_DESCRIPTION(\"I2C-Bus bit-banging algorithm\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}