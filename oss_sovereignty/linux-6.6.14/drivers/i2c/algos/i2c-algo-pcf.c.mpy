{
  "module_name": "i2c-algo-pcf.c",
  "hash_id": "bca41a83f8cb6b075bcaa7b772a944d99e24da10a867f5e319bed220870317d8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/algos/i2c-algo-pcf.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/errno.h>\n#include <linux/i2c.h>\n#include <linux/i2c-algo-pcf.h>\n#include \"i2c-algo-pcf.h\"\n\n\n#define DEB2(x) if (i2c_debug >= 2) x\n#define DEB3(x) if (i2c_debug >= 3) x  \n#define DEBPROTO(x) if (i2c_debug >= 9) x;\n\t \n#define DEF_TIMEOUT 16\n\n \nstatic int i2c_debug;\n\n \n\n#define set_pcf(adap, ctl, val) adap->setpcf(adap->data, ctl, val)\n#define get_pcf(adap, ctl) adap->getpcf(adap->data, ctl)\n#define get_own(adap) adap->getown(adap->data)\n#define get_clock(adap) adap->getclock(adap->data)\n#define i2c_outb(adap, val) adap->setpcf(adap->data, 0, val)\n#define i2c_inb(adap) adap->getpcf(adap->data, 0)\n\n \n\nstatic void i2c_start(struct i2c_algo_pcf_data *adap)\n{\n\tDEBPROTO(printk(KERN_DEBUG \"S \"));\n\tset_pcf(adap, 1, I2C_PCF_START);\n}\n\nstatic void i2c_repstart(struct i2c_algo_pcf_data *adap)\n{\n\tDEBPROTO(printk(\" Sr \"));\n\tset_pcf(adap, 1, I2C_PCF_REPSTART);\n}\n\nstatic void i2c_stop(struct i2c_algo_pcf_data *adap)\n{\n\tDEBPROTO(printk(\"P\\n\"));\n\tset_pcf(adap, 1, I2C_PCF_STOP);\n}\n\nstatic void handle_lab(struct i2c_algo_pcf_data *adap, const int *status)\n{\n\tDEB2(printk(KERN_INFO\n\t\t\"i2c-algo-pcf.o: lost arbitration (CSR 0x%02x)\\n\",\n\t\t*status));\n\t \n\tset_pcf(adap, 1, I2C_PCF_PIN);\n\tset_pcf(adap, 1, I2C_PCF_ESO);\n\t \n\tif (adap->lab_mdelay)\n\t\tmdelay(adap->lab_mdelay);\n\n\tDEB2(printk(KERN_INFO\n\t\t\"i2c-algo-pcf.o: reset LAB condition (CSR 0x%02x)\\n\",\n\t\tget_pcf(adap, 1)));\n}\n\nstatic int wait_for_bb(struct i2c_algo_pcf_data *adap)\n{\n\n\tint timeout = DEF_TIMEOUT;\n\tint status;\n\n\tstatus = get_pcf(adap, 1);\n\n\twhile (!(status & I2C_PCF_BB) && --timeout) {\n\t\tudelay(100);  \n\t\tstatus = get_pcf(adap, 1);\n\t}\n\n\tif (timeout == 0) {\n\t\tprintk(KERN_ERR \"Timeout waiting for Bus Busy\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\n}\n\nstatic int wait_for_pin(struct i2c_algo_pcf_data *adap, int *status)\n{\n\n\tint timeout = DEF_TIMEOUT;\n\n\t*status = get_pcf(adap, 1);\n\n\twhile ((*status & I2C_PCF_PIN) && --timeout) {\n\t\tadap->waitforpin(adap->data);\n\t\t*status = get_pcf(adap, 1);\n\t}\n\tif (*status & I2C_PCF_LAB) {\n\t\thandle_lab(adap, status);\n\t\treturn -EINTR;\n\t}\n\n\tif (timeout == 0)\n\t\treturn -ETIMEDOUT;\n\n\treturn 0;\n}\n\n \nstatic int pcf_init_8584 (struct i2c_algo_pcf_data *adap)\n{\n\tunsigned char temp;\n\n\tDEB3(printk(KERN_DEBUG \"i2c-algo-pcf.o: PCF state 0x%02x\\n\",\n\t\t\t\tget_pcf(adap, 1)));\n\n\t \n\tset_pcf(adap, 1, I2C_PCF_PIN);\n\t \n\tif (((temp = get_pcf(adap, 1)) & 0x7f) != (0)) {\n\t\tDEB2(printk(KERN_ERR \"i2c-algo-pcf.o: PCF detection failed -- can't select S0 (0x%02x).\\n\", temp));\n\t\treturn -ENXIO;  \n\t}\n\n\t \n\ti2c_outb(adap, get_own(adap));\n\t \n\tif ((temp = i2c_inb(adap)) != get_own(adap)) {\n\t\tDEB2(printk(KERN_ERR \"i2c-algo-pcf.o: PCF detection failed -- can't set S0 (0x%02x).\\n\", temp));\n\t\treturn -ENXIO;\n\t}\n\n\t \n\tset_pcf(adap, 1, I2C_PCF_PIN | I2C_PCF_ES1);\n\t \n\tif (((temp = get_pcf(adap, 1)) & 0x7f) != I2C_PCF_ES1) {\n\t\tDEB2(printk(KERN_ERR \"i2c-algo-pcf.o: PCF detection failed -- can't select S2 (0x%02x).\\n\", temp));\n\t\treturn -ENXIO;\n\t}\n\n\t \n\ti2c_outb(adap, get_clock(adap));\n\t \n\tif (((temp = i2c_inb(adap)) & 0x1f) != get_clock(adap)) {\n\t\tDEB2(printk(KERN_ERR \"i2c-algo-pcf.o: PCF detection failed -- can't set S2 (0x%02x).\\n\", temp));\n\t\treturn -ENXIO;\n\t}\n\n\t \n\tset_pcf(adap, 1, I2C_PCF_IDLE);\n\n\t \n\tif ((temp = get_pcf(adap, 1)) != (I2C_PCF_PIN | I2C_PCF_BB)) {\n\t\tDEB2(printk(KERN_ERR \"i2c-algo-pcf.o: PCF detection failed -- can't select S1` (0x%02x).\\n\", temp));\n\t\treturn -ENXIO;\n\t}\n\n\tprintk(KERN_DEBUG \"i2c-algo-pcf.o: detected and initialized PCF8584.\\n\");\n\n\treturn 0;\n}\n\nstatic int pcf_sendbytes(struct i2c_adapter *i2c_adap, const char *buf,\n\t\t\t int count, int last)\n{\n\tstruct i2c_algo_pcf_data *adap = i2c_adap->algo_data;\n\tint wrcount, status, timeout;\n\n\tfor (wrcount=0; wrcount<count; ++wrcount) {\n\t\tDEB2(dev_dbg(&i2c_adap->dev, \"i2c_write: writing %2.2X\\n\",\n\t\t\t\tbuf[wrcount] & 0xff));\n\t\ti2c_outb(adap, buf[wrcount]);\n\t\ttimeout = wait_for_pin(adap, &status);\n\t\tif (timeout) {\n\t\t\tif (timeout == -EINTR)\n\t\t\t\treturn -EINTR;  \n\n\t\t\ti2c_stop(adap);\n\t\t\tdev_err(&i2c_adap->dev, \"i2c_write: error - timeout.\\n\");\n\t\t\treturn -EREMOTEIO;  \n\t\t}\n\t\tif (status & I2C_PCF_LRB) {\n\t\t\ti2c_stop(adap);\n\t\t\tdev_err(&i2c_adap->dev, \"i2c_write: error - no ack.\\n\");\n\t\t\treturn -EREMOTEIO;  \n\t\t}\n\t}\n\tif (last)\n\t\ti2c_stop(adap);\n\telse\n\t\ti2c_repstart(adap);\n\n\treturn wrcount;\n}\n\nstatic int pcf_readbytes(struct i2c_adapter *i2c_adap, char *buf,\n\t\t\t int count, int last)\n{\n\tint i, status;\n\tstruct i2c_algo_pcf_data *adap = i2c_adap->algo_data;\n\tint wfp;\n\n\t \n\tfor (i = 0; i <= count; i++) {\n\n\t\tif ((wfp = wait_for_pin(adap, &status))) {\n\t\t\tif (wfp == -EINTR)\n\t\t\t\treturn -EINTR;  \n\n\t\t\ti2c_stop(adap);\n\t\t\tdev_err(&i2c_adap->dev, \"pcf_readbytes timed out.\\n\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tif ((status & I2C_PCF_LRB) && (i != count)) {\n\t\t\ti2c_stop(adap);\n\t\t\tdev_err(&i2c_adap->dev, \"i2c_read: i2c_inb, No ack.\\n\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (i == count - 1) {\n\t\t\tset_pcf(adap, 1, I2C_PCF_ESO);\n\t\t} else if (i == count) {\n\t\t\tif (last)\n\t\t\t\ti2c_stop(adap);\n\t\t\telse\n\t\t\t\ti2c_repstart(adap);\n\t\t}\n\n\t\tif (i)\n\t\t\tbuf[i - 1] = i2c_inb(adap);\n\t\telse\n\t\t\ti2c_inb(adap);  \n\t}\n\n\treturn i - 1;\n}\n\n\nstatic int pcf_doAddress(struct i2c_algo_pcf_data *adap,\n\t\t\t struct i2c_msg *msg)\n{\n\tunsigned char addr = i2c_8bit_addr_from_msg(msg);\n\n\tif (msg->flags & I2C_M_REV_DIR_ADDR)\n\t\taddr ^= 1;\n\ti2c_outb(adap, addr);\n\n\treturn 0;\n}\n\nstatic int pcf_xfer(struct i2c_adapter *i2c_adap,\n\t\t    struct i2c_msg *msgs,\n\t\t    int num)\n{\n\tstruct i2c_algo_pcf_data *adap = i2c_adap->algo_data;\n\tstruct i2c_msg *pmsg;\n\tint i;\n\tint ret=0, timeout, status;\n\n\tif (adap->xfer_begin)\n\t\tadap->xfer_begin(adap->data);\n\n\t \n\ttimeout = wait_for_bb(adap);\n\tif (timeout) {\n\t\tDEB2(printk(KERN_ERR \"i2c-algo-pcf.o: \"\n\t\t\t    \"Timeout waiting for BB in pcf_xfer\\n\");)\n\t\ti = -EIO;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0;ret >= 0 && i < num; i++) {\n\t\tpmsg = &msgs[i];\n\n\t\tDEB2(printk(KERN_DEBUG \"i2c-algo-pcf.o: Doing %s %d bytes to 0x%02x - %d of %d messages\\n\",\n\t\t     pmsg->flags & I2C_M_RD ? \"read\" : \"write\",\n\t\t     pmsg->len, pmsg->addr, i + 1, num);)\n\n\t\tret = pcf_doAddress(adap, pmsg);\n\n\t\t \n\t\tif (i == 0)\n\t\t\ti2c_start(adap);\n\n\t\t \n\t\ttimeout = wait_for_pin(adap, &status);\n\t\tif (timeout) {\n\t\t\tif (timeout == -EINTR) {\n\t\t\t\t \n\t\t\t\ti = -EINTR;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\ti2c_stop(adap);\n\t\t\tDEB2(printk(KERN_ERR \"i2c-algo-pcf.o: Timeout waiting \"\n\t\t\t\t    \"for PIN(1) in pcf_xfer\\n\");)\n\t\t\ti = -EREMOTEIO;\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tif (status & I2C_PCF_LRB) {\n\t\t\ti2c_stop(adap);\n\t\t\tDEB2(printk(KERN_ERR \"i2c-algo-pcf.o: No LRB(1) in pcf_xfer\\n\");)\n\t\t\ti = -EREMOTEIO;\n\t\t\tgoto out;\n\t\t}\n\n\t\tDEB3(printk(KERN_DEBUG \"i2c-algo-pcf.o: Msg %d, addr=0x%x, flags=0x%x, len=%d\\n\",\n\t\t\t    i, msgs[i].addr, msgs[i].flags, msgs[i].len);)\n\n\t\tif (pmsg->flags & I2C_M_RD) {\n\t\t\tret = pcf_readbytes(i2c_adap, pmsg->buf, pmsg->len,\n\t\t\t\t\t    (i + 1 == num));\n\n\t\t\tif (ret != pmsg->len) {\n\t\t\t\tDEB2(printk(KERN_DEBUG \"i2c-algo-pcf.o: fail: \"\n\t\t\t\t\t    \"only read %d bytes.\\n\",ret));\n\t\t\t} else {\n\t\t\t\tDEB2(printk(KERN_DEBUG \"i2c-algo-pcf.o: read %d bytes.\\n\",ret));\n\t\t\t}\n\t\t} else {\n\t\t\tret = pcf_sendbytes(i2c_adap, pmsg->buf, pmsg->len,\n\t\t\t\t\t    (i + 1 == num));\n\n\t\t\tif (ret != pmsg->len) {\n\t\t\t\tDEB2(printk(KERN_DEBUG \"i2c-algo-pcf.o: fail: \"\n\t\t\t\t\t    \"only wrote %d bytes.\\n\",ret));\n\t\t\t} else {\n\t\t\t\tDEB2(printk(KERN_DEBUG \"i2c-algo-pcf.o: wrote %d bytes.\\n\",ret));\n\t\t\t}\n\t\t}\n\t}\n\nout:\n\tif (adap->xfer_end)\n\t\tadap->xfer_end(adap->data);\n\treturn i;\n}\n\nstatic u32 pcf_func(struct i2c_adapter *adap)\n{\n\treturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL |\n\t       I2C_FUNC_PROTOCOL_MANGLING;\n}\n\n \nstatic const struct i2c_algorithm pcf_algo = {\n\t.master_xfer\t= pcf_xfer,\n\t.functionality\t= pcf_func,\n};\n\n \nint i2c_pcf_add_bus(struct i2c_adapter *adap)\n{\n\tstruct i2c_algo_pcf_data *pcf_adap = adap->algo_data;\n\tint rval;\n\n\tDEB2(dev_dbg(&adap->dev, \"hw routines registered.\\n\"));\n\n\t \n\tadap->algo = &pcf_algo;\n\n\tif ((rval = pcf_init_8584(pcf_adap)))\n\t\treturn rval;\n\n\trval = i2c_add_adapter(adap);\n\n\treturn rval;\n}\nEXPORT_SYMBOL(i2c_pcf_add_bus);\n\nMODULE_AUTHOR(\"Hans Berglund <hb@spacetec.no>\");\nMODULE_DESCRIPTION(\"I2C-Bus PCF8584 algorithm\");\nMODULE_LICENSE(\"GPL\");\n\nmodule_param(i2c_debug, int, S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(i2c_debug,\n\t\"debug level - 0 off; 1 normal; 2,3 more verbose; 9 pcf-protocol\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}