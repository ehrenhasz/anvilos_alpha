{
  "module_name": "i2c-algo-pca.c",
  "hash_id": "f05bf16cba6d3defc179898506318b0fd2f9985cd44c567672fbcf36caaa42be",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/algos/i2c-algo-pca.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/errno.h>\n#include <linux/i2c.h>\n#include <linux/i2c-algo-pca.h>\n\n#define DEB1(fmt, args...) do { if (i2c_debug >= 1)\t\t\t\\\n\t\t\t\t printk(KERN_DEBUG fmt, ## args); } while (0)\n#define DEB2(fmt, args...) do { if (i2c_debug >= 2)\t\t\t\\\n\t\t\t\t printk(KERN_DEBUG fmt, ## args); } while (0)\n#define DEB3(fmt, args...) do { if (i2c_debug >= 3)\t\t\t\\\n\t\t\t\t printk(KERN_DEBUG fmt, ## args); } while (0)\n\nstatic int i2c_debug;\n\n#define pca_outw(adap, reg, val) adap->write_byte(adap->data, reg, val)\n#define pca_inw(adap, reg) adap->read_byte(adap->data, reg)\n\n#define pca_status(adap) pca_inw(adap, I2C_PCA_STA)\n#define pca_clock(adap) adap->i2c_clock\n#define pca_set_con(adap, val) pca_outw(adap, I2C_PCA_CON, val)\n#define pca_get_con(adap) pca_inw(adap, I2C_PCA_CON)\n#define pca_wait(adap) adap->wait_for_completion(adap->data)\n\nstatic void pca_reset(struct i2c_algo_pca_data *adap)\n{\n\tif (adap->chip == I2C_PCA_CHIP_9665) {\n\t\t \n\t\tpca_outw(adap, I2C_PCA_INDPTR, I2C_PCA_IPRESET);\n\t\tpca_outw(adap, I2C_PCA_IND, 0xA5);\n\t\tpca_outw(adap, I2C_PCA_IND, 0x5A);\n\n\t\t \n\t\tpca_outw(adap, I2C_PCA_INDPTR, I2C_PCA_IMODE);\n\t\tpca_outw(adap, I2C_PCA_IND, adap->bus_settings.mode);\n\t\tpca_outw(adap, I2C_PCA_INDPTR, I2C_PCA_ISCLL);\n\t\tpca_outw(adap, I2C_PCA_IND, adap->bus_settings.tlow);\n\t\tpca_outw(adap, I2C_PCA_INDPTR, I2C_PCA_ISCLH);\n\t\tpca_outw(adap, I2C_PCA_IND, adap->bus_settings.thi);\n\n\t\tpca_set_con(adap, I2C_PCA_CON_ENSIO);\n\t} else {\n\t\tadap->reset_chip(adap->data);\n\t\tpca_set_con(adap, I2C_PCA_CON_ENSIO | adap->bus_settings.clock_freq);\n\t}\n}\n\n \nstatic int pca_start(struct i2c_algo_pca_data *adap)\n{\n\tint sta = pca_get_con(adap);\n\tDEB2(\"=== START\\n\");\n\tsta |= I2C_PCA_CON_STA;\n\tsta &= ~(I2C_PCA_CON_STO|I2C_PCA_CON_SI);\n\tpca_set_con(adap, sta);\n\treturn pca_wait(adap);\n}\n\n \nstatic int pca_repeated_start(struct i2c_algo_pca_data *adap)\n{\n\tint sta = pca_get_con(adap);\n\tDEB2(\"=== REPEATED START\\n\");\n\tsta |= I2C_PCA_CON_STA;\n\tsta &= ~(I2C_PCA_CON_STO|I2C_PCA_CON_SI);\n\tpca_set_con(adap, sta);\n\treturn pca_wait(adap);\n}\n\n \nstatic void pca_stop(struct i2c_algo_pca_data *adap)\n{\n\tint sta = pca_get_con(adap);\n\tDEB2(\"=== STOP\\n\");\n\tsta |= I2C_PCA_CON_STO;\n\tsta &= ~(I2C_PCA_CON_STA|I2C_PCA_CON_SI);\n\tpca_set_con(adap, sta);\n}\n\n \nstatic int pca_address(struct i2c_algo_pca_data *adap,\n\t\t       struct i2c_msg *msg)\n{\n\tint sta = pca_get_con(adap);\n\tint addr = i2c_8bit_addr_from_msg(msg);\n\n\tDEB2(\"=== SLAVE ADDRESS %#04x+%c=%#04x\\n\",\n\t     msg->addr, msg->flags & I2C_M_RD ? 'R' : 'W', addr);\n\n\tpca_outw(adap, I2C_PCA_DAT, addr);\n\n\tsta &= ~(I2C_PCA_CON_STO|I2C_PCA_CON_STA|I2C_PCA_CON_SI);\n\tpca_set_con(adap, sta);\n\n\treturn pca_wait(adap);\n}\n\n \nstatic int pca_tx_byte(struct i2c_algo_pca_data *adap,\n\t\t       __u8 b)\n{\n\tint sta = pca_get_con(adap);\n\tDEB2(\"=== WRITE %#04x\\n\", b);\n\tpca_outw(adap, I2C_PCA_DAT, b);\n\n\tsta &= ~(I2C_PCA_CON_STO|I2C_PCA_CON_STA|I2C_PCA_CON_SI);\n\tpca_set_con(adap, sta);\n\n\treturn pca_wait(adap);\n}\n\n \nstatic void pca_rx_byte(struct i2c_algo_pca_data *adap,\n\t\t\t__u8 *b, int ack)\n{\n\t*b = pca_inw(adap, I2C_PCA_DAT);\n\tDEB2(\"=== READ %#04x %s\\n\", *b, ack ? \"ACK\" : \"NACK\");\n}\n\n \nstatic int pca_rx_ack(struct i2c_algo_pca_data *adap,\n\t\t      int ack)\n{\n\tint sta = pca_get_con(adap);\n\n\tsta &= ~(I2C_PCA_CON_STO|I2C_PCA_CON_STA|I2C_PCA_CON_SI|I2C_PCA_CON_AA);\n\n\tif (ack)\n\t\tsta |= I2C_PCA_CON_AA;\n\n\tpca_set_con(adap, sta);\n\treturn pca_wait(adap);\n}\n\nstatic int pca_xfer(struct i2c_adapter *i2c_adap,\n\t\t    struct i2c_msg *msgs,\n\t\t    int num)\n{\n\tstruct i2c_algo_pca_data *adap = i2c_adap->algo_data;\n\tstruct i2c_msg *msg = NULL;\n\tint curmsg;\n\tint numbytes = 0;\n\tint state;\n\tint ret;\n\tint completed = 1;\n\tunsigned long timeout = jiffies + i2c_adap->timeout;\n\n\twhile ((state = pca_status(adap)) != 0xf8) {\n\t\tif (time_before(jiffies, timeout)) {\n\t\t\tmsleep(10);\n\t\t} else {\n\t\t\tdev_dbg(&i2c_adap->dev, \"bus is not idle. status is \"\n\t\t\t\t\"%#04x\\n\", state);\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\n\tDEB1(\"{{{ XFER %d messages\\n\", num);\n\n\tif (i2c_debug >= 2) {\n\t\tfor (curmsg = 0; curmsg < num; curmsg++) {\n\t\t\tint addr, i;\n\t\t\tmsg = &msgs[curmsg];\n\n\t\t\taddr = (0x7f & msg->addr) ;\n\n\t\t\tif (msg->flags & I2C_M_RD)\n\t\t\t\tprintk(KERN_INFO \"    [%02d] RD %d bytes from %#02x [%#02x, ...]\\n\",\n\t\t\t\t       curmsg, msg->len, addr, (addr << 1) | 1);\n\t\t\telse {\n\t\t\t\tprintk(KERN_INFO \"    [%02d] WR %d bytes to %#02x [%#02x%s\",\n\t\t\t\t       curmsg, msg->len, addr, addr << 1,\n\t\t\t\t       msg->len == 0 ? \"\" : \", \");\n\t\t\t\tfor (i = 0; i < msg->len; i++)\n\t\t\t\t\tprintk(\"%#04x%s\", msg->buf[i], i == msg->len - 1 ? \"\" : \", \");\n\t\t\t\tprintk(\"]\\n\");\n\t\t\t}\n\t\t}\n\t}\n\n\tcurmsg = 0;\n\tret = -EIO;\n\twhile (curmsg < num) {\n\t\tstate = pca_status(adap);\n\n\t\tDEB3(\"STATE is 0x%02x\\n\", state);\n\t\tmsg = &msgs[curmsg];\n\n\t\tswitch (state) {\n\t\tcase 0xf8:  \n\t\t\tcompleted = pca_start(adap);\n\t\t\tbreak;\n\n\t\tcase 0x08:  \n\t\tcase 0x10:  \n\t\t\tcompleted = pca_address(adap, msg);\n\t\t\tbreak;\n\n\t\tcase 0x18:  \n\t\tcase 0x28:  \n\t\t\tif (numbytes < msg->len) {\n\t\t\t\tcompleted = pca_tx_byte(adap,\n\t\t\t\t\t\t\tmsg->buf[numbytes]);\n\t\t\t\tnumbytes++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcurmsg++; numbytes = 0;\n\t\t\tif (curmsg == num)\n\t\t\t\tpca_stop(adap);\n\t\t\telse\n\t\t\t\tcompleted = pca_repeated_start(adap);\n\t\t\tbreak;\n\n\t\tcase 0x20:  \n\t\t\tDEB2(\"NOT ACK received after SLA+W\\n\");\n\t\t\tpca_stop(adap);\n\t\t\tret = -ENXIO;\n\t\t\tgoto out;\n\n\t\tcase 0x40:  \n\t\t\tcompleted = pca_rx_ack(adap, msg->len > 1);\n\t\t\tbreak;\n\n\t\tcase 0x50:  \n\t\t\tif (numbytes < msg->len) {\n\t\t\t\tpca_rx_byte(adap, &msg->buf[numbytes], 1);\n\t\t\t\tnumbytes++;\n\t\t\t\tcompleted = pca_rx_ack(adap,\n\t\t\t\t\t\t       numbytes < msg->len - 1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcurmsg++; numbytes = 0;\n\t\t\tif (curmsg == num)\n\t\t\t\tpca_stop(adap);\n\t\t\telse\n\t\t\t\tcompleted = pca_repeated_start(adap);\n\t\t\tbreak;\n\n\t\tcase 0x48:  \n\t\t\tDEB2(\"NOT ACK received after SLA+R\\n\");\n\t\t\tpca_stop(adap);\n\t\t\tret = -ENXIO;\n\t\t\tgoto out;\n\n\t\tcase 0x30:  \n\t\t\tDEB2(\"NOT ACK received after data byte\\n\");\n\t\t\tpca_stop(adap);\n\t\t\tgoto out;\n\n\t\tcase 0x38:  \n\t\t\tDEB2(\"Arbitration lost\\n\");\n\t\t\t \n\t\t\tpca_start(adap);\n\t\t\tgoto out;\n\n\t\tcase 0x58:  \n\t\t\tif (numbytes == msg->len - 1) {\n\t\t\t\tpca_rx_byte(adap, &msg->buf[numbytes], 0);\n\t\t\t\tcurmsg++; numbytes = 0;\n\t\t\t\tif (curmsg == num)\n\t\t\t\t\tpca_stop(adap);\n\t\t\t\telse\n\t\t\t\t\tcompleted = pca_repeated_start(adap);\n\t\t\t} else {\n\t\t\t\tDEB2(\"NOT ACK sent after data byte received. \"\n\t\t\t\t     \"Not final byte. numbytes %d. len %d\\n\",\n\t\t\t\t     numbytes, msg->len);\n\t\t\t\tpca_stop(adap);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x70:  \n\t\t\tDEB2(\"BUS ERROR - SDA Stuck low\\n\");\n\t\t\tpca_reset(adap);\n\t\t\tgoto out;\n\t\tcase 0x78:  \n\t\tcase 0x90:  \n\t\t\tDEB2(\"BUS ERROR - SCL Stuck low\\n\");\n\t\t\tpca_reset(adap);\n\t\t\tgoto out;\n\t\tcase 0x00:  \n\t\t\tDEB2(\"BUS ERROR - Illegal START or STOP\\n\");\n\t\t\tpca_reset(adap);\n\t\t\tgoto out;\n\t\tdefault:\n\t\t\tdev_err(&i2c_adap->dev, \"unhandled SIO state 0x%02x\\n\", state);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!completed)\n\t\t\tgoto out;\n\t}\n\n\tret = curmsg;\n out:\n\tDEB1(\"}}} transferred %d/%d messages. \"\n\t     \"status is %#04x. control is %#04x\\n\",\n\t     curmsg, num, pca_status(adap),\n\t     pca_get_con(adap));\n\treturn ret;\n}\n\nstatic u32 pca_func(struct i2c_adapter *adap)\n{\n\treturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;\n}\n\nstatic const struct i2c_algorithm pca_algo = {\n\t.master_xfer\t= pca_xfer,\n\t.functionality\t= pca_func,\n};\n\nstatic unsigned int pca_probe_chip(struct i2c_adapter *adap)\n{\n\tstruct i2c_algo_pca_data *pca_data = adap->algo_data;\n\t \n\tpca_outw(pca_data, I2C_PCA_INDPTR, I2C_PCA_IADR);\n\tpca_outw(pca_data, I2C_PCA_IND, 0xAA);\n\tpca_outw(pca_data, I2C_PCA_INDPTR, I2C_PCA_ITO);\n\tpca_outw(pca_data, I2C_PCA_IND, 0x00);\n\tpca_outw(pca_data, I2C_PCA_INDPTR, I2C_PCA_IADR);\n\tif (pca_inw(pca_data, I2C_PCA_IND) == 0xAA) {\n\t\tprintk(KERN_INFO \"%s: PCA9665 detected.\\n\", adap->name);\n\t\tpca_data->chip = I2C_PCA_CHIP_9665;\n\t} else {\n\t\tprintk(KERN_INFO \"%s: PCA9564 detected.\\n\", adap->name);\n\t\tpca_data->chip = I2C_PCA_CHIP_9564;\n\t}\n\treturn pca_data->chip;\n}\n\nstatic int pca_init(struct i2c_adapter *adap)\n{\n\tstruct i2c_algo_pca_data *pca_data = adap->algo_data;\n\n\tadap->algo = &pca_algo;\n\n\tif (pca_probe_chip(adap) == I2C_PCA_CHIP_9564) {\n\t\tstatic int freqs[] = {330, 288, 217, 146, 88, 59, 44, 36};\n\t\tint clock;\n\n\t\tif (pca_data->i2c_clock > 7) {\n\t\t\tswitch (pca_data->i2c_clock) {\n\t\t\tcase 330000:\n\t\t\t\tpca_data->i2c_clock = I2C_PCA_CON_330kHz;\n\t\t\t\tbreak;\n\t\t\tcase 288000:\n\t\t\t\tpca_data->i2c_clock = I2C_PCA_CON_288kHz;\n\t\t\t\tbreak;\n\t\t\tcase 217000:\n\t\t\t\tpca_data->i2c_clock = I2C_PCA_CON_217kHz;\n\t\t\t\tbreak;\n\t\t\tcase 146000:\n\t\t\t\tpca_data->i2c_clock = I2C_PCA_CON_146kHz;\n\t\t\t\tbreak;\n\t\t\tcase 88000:\n\t\t\t\tpca_data->i2c_clock = I2C_PCA_CON_88kHz;\n\t\t\t\tbreak;\n\t\t\tcase 59000:\n\t\t\t\tpca_data->i2c_clock = I2C_PCA_CON_59kHz;\n\t\t\t\tbreak;\n\t\t\tcase 44000:\n\t\t\t\tpca_data->i2c_clock = I2C_PCA_CON_44kHz;\n\t\t\t\tbreak;\n\t\t\tcase 36000:\n\t\t\t\tpca_data->i2c_clock = I2C_PCA_CON_36kHz;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tprintk(KERN_WARNING\n\t\t\t\t\t\"%s: Invalid I2C clock speed selected.\"\n\t\t\t\t\t\" Using default 59kHz.\\n\", adap->name);\n\t\t\tpca_data->i2c_clock = I2C_PCA_CON_59kHz;\n\t\t\t}\n\t\t} else {\n\t\t\tprintk(KERN_WARNING \"%s: \"\n\t\t\t\t\"Choosing the clock frequency based on \"\n\t\t\t\t\"index is deprecated.\"\n\t\t\t\t\" Use the nominal frequency.\\n\", adap->name);\n\t\t}\n\n\t\tclock = pca_clock(pca_data);\n\t\tprintk(KERN_INFO \"%s: Clock frequency is %dkHz\\n\",\n\t\t     adap->name, freqs[clock]);\n\n\t\t \n\t\tpca_data->bus_settings.clock_freq = clock;\n\n\t\tpca_reset(pca_data);\n\t} else {\n\t\tint clock;\n\t\tint mode;\n\t\tint tlow, thi;\n\t\t \n\t\tint min_tlow, min_thi;\n\t\t \n\t\tint raise_fall_time;\n\n\t\tif (pca_data->i2c_clock > 1265800) {\n\t\t\tprintk(KERN_WARNING \"%s: I2C clock speed too high.\"\n\t\t\t\t\" Using 1265.8kHz.\\n\", adap->name);\n\t\t\tpca_data->i2c_clock = 1265800;\n\t\t}\n\n\t\tif (pca_data->i2c_clock < 60300) {\n\t\t\tprintk(KERN_WARNING \"%s: I2C clock speed too low.\"\n\t\t\t\t\" Using 60.3kHz.\\n\", adap->name);\n\t\t\tpca_data->i2c_clock = 60300;\n\t\t}\n\n\t\t \n\t\tclock = pca_clock(pca_data) / 100;\n\n\t\tif (pca_data->i2c_clock > I2C_MAX_FAST_MODE_PLUS_FREQ) {\n\t\t\tmode = I2C_PCA_MODE_TURBO;\n\t\t\tmin_tlow = 14;\n\t\t\tmin_thi  = 5;\n\t\t\traise_fall_time = 22;  \n\t\t} else if (pca_data->i2c_clock > I2C_MAX_FAST_MODE_FREQ) {\n\t\t\tmode = I2C_PCA_MODE_FASTP;\n\t\t\tmin_tlow = 17;\n\t\t\tmin_thi  = 9;\n\t\t\traise_fall_time = 22;  \n\t\t} else if (pca_data->i2c_clock > I2C_MAX_STANDARD_MODE_FREQ) {\n\t\t\tmode = I2C_PCA_MODE_FAST;\n\t\t\tmin_tlow = 44;\n\t\t\tmin_thi  = 20;\n\t\t\traise_fall_time = 58;  \n\t\t} else {\n\t\t\tmode = I2C_PCA_MODE_STD;\n\t\t\tmin_tlow = 157;\n\t\t\tmin_thi  = 134;\n\t\t\traise_fall_time = 127;  \n\t\t}\n\n\t\t \n\t\tif (clock < 648) {\n\t\t\ttlow = 255;\n\t\t\tthi = 1000000 - clock * raise_fall_time;\n\t\t\tthi /= (I2C_PCA_OSC_PER * clock) - tlow;\n\t\t} else {\n\t\t\ttlow = (1000000 - clock * raise_fall_time) * min_tlow;\n\t\t\ttlow /= I2C_PCA_OSC_PER * clock * (min_thi + min_tlow);\n\t\t\tthi = tlow * min_thi / min_tlow;\n\t\t}\n\n\t\t \n\t\tpca_data->bus_settings.mode = mode;\n\t\tpca_data->bus_settings.tlow = tlow;\n\t\tpca_data->bus_settings.thi = thi;\n\n\t\tpca_reset(pca_data);\n\n\t\tprintk(KERN_INFO\n\t\t     \"%s: Clock frequency is %dHz\\n\", adap->name, clock * 100);\n\t}\n\tudelay(500);  \n\n\treturn 0;\n}\n\n \nint i2c_pca_add_bus(struct i2c_adapter *adap)\n{\n\tint rval;\n\n\trval = pca_init(adap);\n\tif (rval)\n\t\treturn rval;\n\n\treturn i2c_add_adapter(adap);\n}\nEXPORT_SYMBOL(i2c_pca_add_bus);\n\nint i2c_pca_add_numbered_bus(struct i2c_adapter *adap)\n{\n\tint rval;\n\n\trval = pca_init(adap);\n\tif (rval)\n\t\treturn rval;\n\n\treturn i2c_add_numbered_adapter(adap);\n}\nEXPORT_SYMBOL(i2c_pca_add_numbered_bus);\n\nMODULE_AUTHOR(\"Ian Campbell <icampbell@arcom.com>\");\nMODULE_AUTHOR(\"Wolfram Sang <kernel@pengutronix.de>\");\nMODULE_DESCRIPTION(\"I2C-Bus PCA9564/PCA9665 algorithm\");\nMODULE_LICENSE(\"GPL\");\n\nmodule_param(i2c_debug, int, 0);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}