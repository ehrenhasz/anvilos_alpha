{
  "module_name": "i2c-mux-gpio.c",
  "hash_id": "e7b30af47de08a05946ea3fd8b789832abd3eab5452992dcf8f3b6cc41189035",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/muxes/i2c-mux-gpio.c",
  "human_readable_source": "\n \n\n#include <linux/i2c.h>\n#include <linux/i2c-mux.h>\n#include <linux/overflow.h>\n#include <linux/platform_data/i2c-mux-gpio.h>\n#include <linux/platform_device.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/bits.h>\n#include <linux/gpio/consumer.h>\n \n#include \"../../gpio/gpiolib.h\"\n\nstruct gpiomux {\n\tstruct i2c_mux_gpio_platform_data data;\n\tint ngpios;\n\tstruct gpio_desc **gpios;\n};\n\nstatic void i2c_mux_gpio_set(const struct gpiomux *mux, unsigned val)\n{\n\tDECLARE_BITMAP(values, BITS_PER_TYPE(val));\n\n\tvalues[0] = val;\n\n\tgpiod_set_array_value_cansleep(mux->ngpios, mux->gpios, NULL, values);\n}\n\nstatic int i2c_mux_gpio_select(struct i2c_mux_core *muxc, u32 chan)\n{\n\tstruct gpiomux *mux = i2c_mux_priv(muxc);\n\n\ti2c_mux_gpio_set(mux, chan);\n\n\treturn 0;\n}\n\nstatic int i2c_mux_gpio_deselect(struct i2c_mux_core *muxc, u32 chan)\n{\n\tstruct gpiomux *mux = i2c_mux_priv(muxc);\n\n\ti2c_mux_gpio_set(mux, mux->data.idle);\n\n\treturn 0;\n}\n\nstatic int i2c_mux_gpio_probe_fw(struct gpiomux *mux,\n\t\t\t\t struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct fwnode_handle *fwnode = dev_fwnode(dev);\n\tstruct device_node *np = dev->of_node;\n\tstruct device_node *adapter_np;\n\tstruct i2c_adapter *adapter = NULL;\n\tstruct fwnode_handle *child;\n\tunsigned *values;\n\tint rc, i = 0;\n\n\tif (is_of_node(fwnode)) {\n\t\tif (!np)\n\t\t\treturn -ENODEV;\n\n\t\tadapter_np = of_parse_phandle(np, \"i2c-parent\", 0);\n\t\tif (!adapter_np) {\n\t\t\tdev_err(&pdev->dev, \"Cannot parse i2c-parent\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t\tadapter = of_find_i2c_adapter_by_node(adapter_np);\n\t\tof_node_put(adapter_np);\n\n\t} else if (is_acpi_node(fwnode)) {\n\t\t \n\t\tacpi_handle dev_handle = ACPI_HANDLE(dev->parent);\n\n\t\tadapter = i2c_acpi_find_adapter_by_handle(dev_handle);\n\t}\n\n\tif (!adapter)\n\t\treturn -EPROBE_DEFER;\n\n\tmux->data.parent = i2c_adapter_id(adapter);\n\tput_device(&adapter->dev);\n\n\tmux->data.n_values = device_get_child_node_count(dev);\n\tvalues = devm_kcalloc(dev,\n\t\t\t      mux->data.n_values, sizeof(*mux->data.values),\n\t\t\t      GFP_KERNEL);\n\tif (!values) {\n\t\tdev_err(dev, \"Cannot allocate values array\");\n\t\treturn -ENOMEM;\n\t}\n\n\tdevice_for_each_child_node(dev, child) {\n\t\tif (is_of_node(child)) {\n\t\t\tfwnode_property_read_u32(child, \"reg\", values + i);\n\n\t\t} else if (is_acpi_node(child)) {\n\t\t\trc = acpi_get_local_address(ACPI_HANDLE_FWNODE(child), values + i);\n\t\t\tif (rc) {\n\t\t\t\tfwnode_handle_put(child);\n\t\t\t\treturn dev_err_probe(dev, rc, \"Cannot get address\\n\");\n\t\t\t}\n\t\t}\n\n\t\ti++;\n\t}\n\tmux->data.values = values;\n\n\tif (device_property_read_u32(dev, \"idle-state\", &mux->data.idle))\n\t\tmux->data.idle = I2C_MUX_GPIO_NO_IDLE;\n\n\treturn 0;\n}\n\nstatic int i2c_mux_gpio_probe(struct platform_device *pdev)\n{\n\tstruct i2c_mux_core *muxc;\n\tstruct gpiomux *mux;\n\tstruct i2c_adapter *parent;\n\tstruct i2c_adapter *root;\n\tunsigned initial_state;\n\tint i, ngpios, ret;\n\n\tmux = devm_kzalloc(&pdev->dev, sizeof(*mux), GFP_KERNEL);\n\tif (!mux)\n\t\treturn -ENOMEM;\n\n\tif (!dev_get_platdata(&pdev->dev)) {\n\t\tret = i2c_mux_gpio_probe_fw(mux, pdev);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t} else {\n\t\tmemcpy(&mux->data, dev_get_platdata(&pdev->dev),\n\t\t\tsizeof(mux->data));\n\t}\n\n\tngpios = gpiod_count(&pdev->dev, \"mux\");\n\tif (ngpios <= 0) {\n\t\tdev_err(&pdev->dev, \"no valid gpios provided\\n\");\n\t\treturn ngpios ?: -EINVAL;\n\t}\n\tmux->ngpios = ngpios;\n\n\tparent = i2c_get_adapter(mux->data.parent);\n\tif (!parent)\n\t\treturn -EPROBE_DEFER;\n\n\tmuxc = i2c_mux_alloc(parent, &pdev->dev, mux->data.n_values,\n\t\t\t     array_size(ngpios, sizeof(*mux->gpios)), 0,\n\t\t\t     i2c_mux_gpio_select, NULL);\n\tif (!muxc) {\n\t\tret = -ENOMEM;\n\t\tgoto alloc_failed;\n\t}\n\tmux->gpios = muxc->priv;\n\tmuxc->priv = mux;\n\n\tplatform_set_drvdata(pdev, muxc);\n\n\troot = i2c_root_adapter(&parent->dev);\n\n\tmuxc->mux_locked = true;\n\n\tif (mux->data.idle != I2C_MUX_GPIO_NO_IDLE) {\n\t\tinitial_state = mux->data.idle;\n\t\tmuxc->deselect = i2c_mux_gpio_deselect;\n\t} else {\n\t\tinitial_state = mux->data.values[0];\n\t}\n\n\tfor (i = 0; i < ngpios; i++) {\n\t\tstruct device *gpio_dev;\n\t\tstruct gpio_desc *gpiod;\n\t\tenum gpiod_flags flag;\n\n\t\tif (initial_state & BIT(i))\n\t\t\tflag = GPIOD_OUT_HIGH;\n\t\telse\n\t\t\tflag = GPIOD_OUT_LOW;\n\t\tgpiod = devm_gpiod_get_index(&pdev->dev, \"mux\", i, flag);\n\t\tif (IS_ERR(gpiod)) {\n\t\t\tret = PTR_ERR(gpiod);\n\t\t\tgoto alloc_failed;\n\t\t}\n\n\t\tmux->gpios[i] = gpiod;\n\n\t\tif (!muxc->mux_locked)\n\t\t\tcontinue;\n\n\t\t \n\t\tgpio_dev = &gpiod->gdev->dev;\n\t\tmuxc->mux_locked = i2c_root_adapter(gpio_dev) == root;\n\t}\n\n\tif (muxc->mux_locked)\n\t\tdev_info(&pdev->dev, \"mux-locked i2c mux\\n\");\n\n\tfor (i = 0; i < mux->data.n_values; i++) {\n\t\tu32 nr = mux->data.base_nr ? (mux->data.base_nr + i) : 0;\n\t\tunsigned int class = mux->data.classes ? mux->data.classes[i] : 0;\n\n\t\tret = i2c_mux_add_adapter(muxc, nr, mux->data.values[i], class);\n\t\tif (ret)\n\t\t\tgoto add_adapter_failed;\n\t}\n\n\tdev_info(&pdev->dev, \"%d port mux on %s adapter\\n\",\n\t\t mux->data.n_values, parent->name);\n\n\treturn 0;\n\nadd_adapter_failed:\n\ti2c_mux_del_adapters(muxc);\nalloc_failed:\n\ti2c_put_adapter(parent);\n\n\treturn ret;\n}\n\nstatic void i2c_mux_gpio_remove(struct platform_device *pdev)\n{\n\tstruct i2c_mux_core *muxc = platform_get_drvdata(pdev);\n\n\ti2c_mux_del_adapters(muxc);\n\ti2c_put_adapter(muxc->parent);\n}\n\nstatic const struct of_device_id i2c_mux_gpio_of_match[] = {\n\t{ .compatible = \"i2c-mux-gpio\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, i2c_mux_gpio_of_match);\n\nstatic struct platform_driver i2c_mux_gpio_driver = {\n\t.probe\t= i2c_mux_gpio_probe,\n\t.remove_new = i2c_mux_gpio_remove,\n\t.driver\t= {\n\t\t.name\t= \"i2c-mux-gpio\",\n\t\t.of_match_table = i2c_mux_gpio_of_match,\n\t},\n};\n\nmodule_platform_driver(i2c_mux_gpio_driver);\n\nMODULE_DESCRIPTION(\"GPIO-based I2C multiplexer driver\");\nMODULE_AUTHOR(\"Peter Korsgaard <peter.korsgaard@barco.com>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:i2c-mux-gpio\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}