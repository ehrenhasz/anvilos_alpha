{
  "module_name": "i2c-mux-reg.c",
  "hash_id": "4b7c5847559df795a04e7fb53a97ded0fe2f470511b288ddff9a80f081360ea7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/muxes/i2c-mux-reg.c",
  "human_readable_source": "\n \n\n#include <linux/i2c.h>\n#include <linux/i2c-mux.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of_address.h>\n#include <linux/platform_data/i2c-mux-reg.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n\nstruct regmux {\n\tstruct i2c_mux_reg_platform_data data;\n};\n\nstatic int i2c_mux_reg_set(const struct regmux *mux, unsigned int chan_id)\n{\n\tif (!mux->data.reg)\n\t\treturn -EINVAL;\n\n\t \n\tswitch (mux->data.reg_size) {\n\tcase 4:\n\t\tif (mux->data.little_endian)\n\t\t\tiowrite32(chan_id, mux->data.reg);\n\t\telse\n\t\t\tiowrite32be(chan_id, mux->data.reg);\n\t\tif (!mux->data.write_only)\n\t\t\tioread32(mux->data.reg);\n\t\tbreak;\n\tcase 2:\n\t\tif (mux->data.little_endian)\n\t\t\tiowrite16(chan_id, mux->data.reg);\n\t\telse\n\t\t\tiowrite16be(chan_id, mux->data.reg);\n\t\tif (!mux->data.write_only)\n\t\t\tioread16(mux->data.reg);\n\t\tbreak;\n\tcase 1:\n\t\tiowrite8(chan_id, mux->data.reg);\n\t\tif (!mux->data.write_only)\n\t\t\tioread8(mux->data.reg);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int i2c_mux_reg_select(struct i2c_mux_core *muxc, u32 chan)\n{\n\tstruct regmux *mux = i2c_mux_priv(muxc);\n\n\treturn i2c_mux_reg_set(mux, chan);\n}\n\nstatic int i2c_mux_reg_deselect(struct i2c_mux_core *muxc, u32 chan)\n{\n\tstruct regmux *mux = i2c_mux_priv(muxc);\n\n\tif (mux->data.idle_in_use)\n\t\treturn i2c_mux_reg_set(mux, mux->data.idle);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_OF\nstatic int i2c_mux_reg_probe_dt(struct regmux *mux,\n\t\t\t\tstruct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct device_node *adapter_np, *child;\n\tstruct i2c_adapter *adapter;\n\tstruct resource res;\n\tunsigned *values;\n\tint i = 0;\n\n\tif (!np)\n\t\treturn -ENODEV;\n\n\tadapter_np = of_parse_phandle(np, \"i2c-parent\", 0);\n\tif (!adapter_np) {\n\t\tdev_err(&pdev->dev, \"Cannot parse i2c-parent\\n\");\n\t\treturn -ENODEV;\n\t}\n\tadapter = of_find_i2c_adapter_by_node(adapter_np);\n\tof_node_put(adapter_np);\n\tif (!adapter)\n\t\treturn -EPROBE_DEFER;\n\n\tmux->data.parent = i2c_adapter_id(adapter);\n\tput_device(&adapter->dev);\n\n\tmux->data.n_values = of_get_child_count(np);\n\tif (of_property_read_bool(np, \"little-endian\")) {\n\t\tmux->data.little_endian = true;\n\t} else if (of_property_read_bool(np, \"big-endian\")) {\n\t\tmux->data.little_endian = false;\n\t} else {\n#if defined(__BYTE_ORDER) ? __BYTE_ORDER == __LITTLE_ENDIAN : \\\n\tdefined(__LITTLE_ENDIAN)\n\t\tmux->data.little_endian = true;\n#elif defined(__BYTE_ORDER) ? __BYTE_ORDER == __BIG_ENDIAN : \\\n\tdefined(__BIG_ENDIAN)\n\t\tmux->data.little_endian = false;\n#else\n#error Endianness not defined?\n#endif\n\t}\n\tmux->data.write_only = of_property_read_bool(np, \"write-only\");\n\n\tvalues = devm_kcalloc(&pdev->dev,\n\t\t\t      mux->data.n_values, sizeof(*mux->data.values),\n\t\t\t      GFP_KERNEL);\n\tif (!values)\n\t\treturn -ENOMEM;\n\n\tfor_each_child_of_node(np, child) {\n\t\tof_property_read_u32(child, \"reg\", values + i);\n\t\ti++;\n\t}\n\tmux->data.values = values;\n\n\tif (!of_property_read_u32(np, \"idle-state\", &mux->data.idle))\n\t\tmux->data.idle_in_use = true;\n\n\t \n\tif (of_address_to_resource(np, 0, &res) == 0) {\n\t\tmux->data.reg_size = resource_size(&res);\n\t\tmux->data.reg = devm_ioremap_resource(&pdev->dev, &res);\n\t\tif (IS_ERR(mux->data.reg))\n\t\t\treturn PTR_ERR(mux->data.reg);\n\t}\n\n\treturn 0;\n}\n#else\nstatic int i2c_mux_reg_probe_dt(struct regmux *mux,\n\t\t\t\tstruct platform_device *pdev)\n{\n\treturn 0;\n}\n#endif\n\nstatic int i2c_mux_reg_probe(struct platform_device *pdev)\n{\n\tstruct i2c_mux_core *muxc;\n\tstruct regmux *mux;\n\tstruct i2c_adapter *parent;\n\tstruct resource *res;\n\tunsigned int class;\n\tint i, ret, nr;\n\n\tmux = devm_kzalloc(&pdev->dev, sizeof(*mux), GFP_KERNEL);\n\tif (!mux)\n\t\treturn -ENOMEM;\n\n\tif (dev_get_platdata(&pdev->dev)) {\n\t\tmemcpy(&mux->data, dev_get_platdata(&pdev->dev),\n\t\t\tsizeof(mux->data));\n\t} else {\n\t\tret = i2c_mux_reg_probe_dt(mux, pdev);\n\t\tif (ret < 0)\n\t\t\treturn dev_err_probe(&pdev->dev, ret,\n\t\t\t\t\t     \"Error parsing device tree\");\n\t}\n\n\tparent = i2c_get_adapter(mux->data.parent);\n\tif (!parent)\n\t\treturn -EPROBE_DEFER;\n\n\tif (!mux->data.reg) {\n\t\tdev_info(&pdev->dev,\n\t\t\t\"Register not set, using platform resource\\n\");\n\t\tmux->data.reg = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\t\tif (IS_ERR(mux->data.reg)) {\n\t\t\tret = PTR_ERR(mux->data.reg);\n\t\t\tgoto err_put_parent;\n\t\t}\n\t\tmux->data.reg_size = resource_size(res);\n\t}\n\n\tif (mux->data.reg_size != 4 && mux->data.reg_size != 2 &&\n\t    mux->data.reg_size != 1) {\n\t\tdev_err(&pdev->dev, \"Invalid register size\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err_put_parent;\n\t}\n\n\tmuxc = i2c_mux_alloc(parent, &pdev->dev, mux->data.n_values, 0, 0,\n\t\t\t     i2c_mux_reg_select, NULL);\n\tif (!muxc) {\n\t\tret = -ENOMEM;\n\t\tgoto err_put_parent;\n\t}\n\tmuxc->priv = mux;\n\n\tplatform_set_drvdata(pdev, muxc);\n\n\tif (mux->data.idle_in_use)\n\t\tmuxc->deselect = i2c_mux_reg_deselect;\n\n\tfor (i = 0; i < mux->data.n_values; i++) {\n\t\tnr = mux->data.base_nr ? (mux->data.base_nr + i) : 0;\n\t\tclass = mux->data.classes ? mux->data.classes[i] : 0;\n\n\t\tret = i2c_mux_add_adapter(muxc, nr, mux->data.values[i], class);\n\t\tif (ret)\n\t\t\tgoto err_del_mux_adapters;\n\t}\n\n\tdev_dbg(&pdev->dev, \"%d port mux on %s adapter\\n\",\n\t\t mux->data.n_values, muxc->parent->name);\n\n\treturn 0;\n\nerr_del_mux_adapters:\n\ti2c_mux_del_adapters(muxc);\nerr_put_parent:\n\ti2c_put_adapter(parent);\n\n\treturn ret;\n}\n\nstatic void i2c_mux_reg_remove(struct platform_device *pdev)\n{\n\tstruct i2c_mux_core *muxc = platform_get_drvdata(pdev);\n\n\ti2c_mux_del_adapters(muxc);\n\ti2c_put_adapter(muxc->parent);\n}\n\nstatic const struct of_device_id i2c_mux_reg_of_match[] = {\n\t{ .compatible = \"i2c-mux-reg\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, i2c_mux_reg_of_match);\n\nstatic struct platform_driver i2c_mux_reg_driver = {\n\t.probe\t= i2c_mux_reg_probe,\n\t.remove_new = i2c_mux_reg_remove,\n\t.driver\t= {\n\t\t.name\t= \"i2c-mux-reg\",\n\t\t.of_match_table = of_match_ptr(i2c_mux_reg_of_match),\n\t},\n};\n\nmodule_platform_driver(i2c_mux_reg_driver);\n\nMODULE_DESCRIPTION(\"Register-based I2C multiplexer driver\");\nMODULE_AUTHOR(\"York Sun <yorksun@freescale.com>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:i2c-mux-reg\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}