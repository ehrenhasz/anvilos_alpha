{
  "module_name": "i2c-arb-gpio-challenge.c",
  "hash_id": "8fc962f16f8bf4eb1da4b4e7e6056386c425f016256bff2cb0fefb24ec36ec5e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/muxes/i2c-arb-gpio-challenge.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/kernel.h>\n#include <linux/i2c.h>\n#include <linux/i2c-mux.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n\n\n \n\nstruct i2c_arbitrator_data {\n\tstruct gpio_desc *our_gpio;\n\tstruct gpio_desc *their_gpio;\n\tunsigned int slew_delay_us;\n\tunsigned int wait_retry_us;\n\tunsigned int wait_free_us;\n};\n\n\n \nstatic int i2c_arbitrator_select(struct i2c_mux_core *muxc, u32 chan)\n{\n\tconst struct i2c_arbitrator_data *arb = i2c_mux_priv(muxc);\n\tunsigned long stop_retry, stop_time;\n\n\t \n\tstop_time = jiffies + usecs_to_jiffies(arb->wait_free_us) + 1;\n\tdo {\n\t\t \n\t\tgpiod_set_value(arb->our_gpio, 1);\n\t\tudelay(arb->slew_delay_us);\n\n\t\t \n\t\tstop_retry = jiffies + usecs_to_jiffies(arb->wait_retry_us) + 1;\n\t\twhile (time_before(jiffies, stop_retry)) {\n\t\t\tint gpio_val = gpiod_get_value(arb->their_gpio);\n\n\t\t\tif (!gpio_val) {\n\t\t\t\t \n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tusleep_range(50, 200);\n\t\t}\n\n\t\t \n\t\tgpiod_set_value(arb->our_gpio, 0);\n\n\t\tusleep_range(arb->wait_retry_us, arb->wait_retry_us * 2);\n\t} while (time_before(jiffies, stop_time));\n\n\t \n\tgpiod_set_value(arb->our_gpio, 0);\n\tudelay(arb->slew_delay_us);\n\tdev_err(muxc->dev, \"Could not claim bus, timeout\\n\");\n\treturn -EBUSY;\n}\n\n \nstatic int i2c_arbitrator_deselect(struct i2c_mux_core *muxc, u32 chan)\n{\n\tconst struct i2c_arbitrator_data *arb = i2c_mux_priv(muxc);\n\n\t \n\tgpiod_set_value(arb->our_gpio, 0);\n\tudelay(arb->slew_delay_us);\n\n\treturn 0;\n}\n\nstatic int i2c_arbitrator_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct device_node *parent_np;\n\tstruct i2c_mux_core *muxc;\n\tstruct i2c_arbitrator_data *arb;\n\tstruct gpio_desc *dummy;\n\tint ret;\n\n\t \n\tif (!np) {\n\t\tdev_err(dev, \"Cannot find device tree node\\n\");\n\t\treturn -ENODEV;\n\t}\n\tif (dev_get_platdata(dev)) {\n\t\tdev_err(dev, \"Platform data is not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmuxc = i2c_mux_alloc(NULL, dev, 1, sizeof(*arb), I2C_MUX_ARBITRATOR,\n\t\t\t     i2c_arbitrator_select, i2c_arbitrator_deselect);\n\tif (!muxc)\n\t\treturn -ENOMEM;\n\tarb = i2c_mux_priv(muxc);\n\n\tplatform_set_drvdata(pdev, muxc);\n\n\t \n\tarb->our_gpio = devm_gpiod_get(dev, \"our-claim\", GPIOD_OUT_LOW);\n\tif (IS_ERR(arb->our_gpio)) {\n\t\tdev_err(dev, \"could not get \\\"our-claim\\\" GPIO (%ld)\\n\",\n\t\t\tPTR_ERR(arb->our_gpio));\n\t\treturn PTR_ERR(arb->our_gpio);\n\t}\n\n\tarb->their_gpio = devm_gpiod_get(dev, \"their-claim\", GPIOD_IN);\n\tif (IS_ERR(arb->their_gpio)) {\n\t\tdev_err(dev, \"could not get \\\"their-claim\\\" GPIO (%ld)\\n\",\n\t\t\tPTR_ERR(arb->their_gpio));\n\t\treturn PTR_ERR(arb->their_gpio);\n\t}\n\n\t \n\tdummy = devm_gpiod_get_index(dev, \"their-claim\", 1, GPIOD_IN);\n\tif (!IS_ERR(dummy)) {\n\t\tdev_err(dev, \"Only one other master is supported\\n\");\n\t\treturn -EINVAL;\n\t} else if (PTR_ERR(dummy) == -EPROBE_DEFER) {\n\t\treturn -EPROBE_DEFER;\n\t}\n\n\t \n\tif (of_property_read_u32(np, \"slew-delay-us\", &arb->slew_delay_us))\n\t\tarb->slew_delay_us = 10;\n\tif (of_property_read_u32(np, \"wait-retry-us\", &arb->wait_retry_us))\n\t\tarb->wait_retry_us = 3000;\n\tif (of_property_read_u32(np, \"wait-free-us\", &arb->wait_free_us))\n\t\tarb->wait_free_us = 50000;\n\n\t \n\tparent_np = of_parse_phandle(np, \"i2c-parent\", 0);\n\tif (!parent_np) {\n\t\tdev_err(dev, \"Cannot parse i2c-parent\\n\");\n\t\treturn -EINVAL;\n\t}\n\tmuxc->parent = of_get_i2c_adapter_by_node(parent_np);\n\tof_node_put(parent_np);\n\tif (!muxc->parent) {\n\t\tdev_err(dev, \"Cannot find parent bus\\n\");\n\t\treturn -EPROBE_DEFER;\n\t}\n\n\t \n\tret = i2c_mux_add_adapter(muxc, 0, 0, 0);\n\tif (ret)\n\t\ti2c_put_adapter(muxc->parent);\n\n\treturn ret;\n}\n\nstatic void i2c_arbitrator_remove(struct platform_device *pdev)\n{\n\tstruct i2c_mux_core *muxc = platform_get_drvdata(pdev);\n\n\ti2c_mux_del_adapters(muxc);\n\ti2c_put_adapter(muxc->parent);\n}\n\nstatic const struct of_device_id i2c_arbitrator_of_match[] = {\n\t{ .compatible = \"i2c-arb-gpio-challenge\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, i2c_arbitrator_of_match);\n\nstatic struct platform_driver i2c_arbitrator_driver = {\n\t.probe\t= i2c_arbitrator_probe,\n\t.remove_new = i2c_arbitrator_remove,\n\t.driver\t= {\n\t\t.name\t= \"i2c-arb-gpio-challenge\",\n\t\t.of_match_table = i2c_arbitrator_of_match,\n\t},\n};\n\nmodule_platform_driver(i2c_arbitrator_driver);\n\nMODULE_DESCRIPTION(\"GPIO-based I2C Arbitration\");\nMODULE_AUTHOR(\"Doug Anderson <dianders@chromium.org>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:i2c-arb-gpio-challenge\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}