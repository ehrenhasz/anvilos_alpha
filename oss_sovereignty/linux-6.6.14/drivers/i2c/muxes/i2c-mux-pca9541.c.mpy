{
  "module_name": "i2c-mux-pca9541.c",
  "hash_id": "a1200899bf5fa33892330a5f0dd586774bd9b5ced9e46c8a92561f1c9549c5cb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/muxes/i2c-mux-pca9541.c",
  "human_readable_source": " \n\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/i2c.h>\n#include <linux/i2c-mux.h>\n#include <linux/jiffies.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\n \n\n#define PCA9541_CONTROL\t\t0x01\n#define PCA9541_ISTAT\t\t0x02\n\n#define PCA9541_CTL_MYBUS\tBIT(0)\n#define PCA9541_CTL_NMYBUS\tBIT(1)\n#define PCA9541_CTL_BUSON\tBIT(2)\n#define PCA9541_CTL_NBUSON\tBIT(3)\n#define PCA9541_CTL_BUSINIT\tBIT(4)\n#define PCA9541_CTL_TESTON\tBIT(6)\n#define PCA9541_CTL_NTESTON\tBIT(7)\n\n#define PCA9541_ISTAT_INTIN\tBIT(0)\n#define PCA9541_ISTAT_BUSINIT\tBIT(1)\n#define PCA9541_ISTAT_BUSOK\tBIT(2)\n#define PCA9541_ISTAT_BUSLOST\tBIT(3)\n#define PCA9541_ISTAT_MYTEST\tBIT(6)\n#define PCA9541_ISTAT_NMYTEST\tBIT(7)\n\n#define BUSON\t\t(PCA9541_CTL_BUSON | PCA9541_CTL_NBUSON)\n#define MYBUS\t\t(PCA9541_CTL_MYBUS | PCA9541_CTL_NMYBUS)\n#define mybus(x)\t(!((x) & MYBUS) || ((x) & MYBUS) == MYBUS)\n#define busoff(x)\t(!((x) & BUSON) || ((x) & BUSON) == BUSON)\n\n \n#define ARB_TIMEOUT\t(HZ / 8)\t \n#define ARB2_TIMEOUT\t(HZ / 4)\t \n\n \n#define SELECT_DELAY_SHORT\t50\n#define SELECT_DELAY_LONG\t1000\n\nstruct pca9541 {\n\tstruct i2c_client *client;\n\tunsigned long select_timeout;\n\tunsigned long arb_timeout;\n};\n\nstatic const struct i2c_device_id pca9541_id[] = {\n\t{\"pca9541\", 0},\n\t{}\n};\n\nMODULE_DEVICE_TABLE(i2c, pca9541_id);\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id pca9541_of_match[] = {\n\t{ .compatible = \"nxp,pca9541\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, pca9541_of_match);\n#endif\n\n \nstatic int pca9541_reg_write(struct i2c_client *client, u8 command, u8 val)\n{\n\tstruct i2c_adapter *adap = client->adapter;\n\tunion i2c_smbus_data data = { .byte = val };\n\n\treturn __i2c_smbus_xfer(adap, client->addr, client->flags,\n\t\t\t\tI2C_SMBUS_WRITE, command,\n\t\t\t\tI2C_SMBUS_BYTE_DATA, &data);\n}\n\n \nstatic int pca9541_reg_read(struct i2c_client *client, u8 command)\n{\n\tstruct i2c_adapter *adap = client->adapter;\n\tunion i2c_smbus_data data;\n\tint ret;\n\n\tret = __i2c_smbus_xfer(adap, client->addr, client->flags,\n\t\t\t       I2C_SMBUS_READ, command,\n\t\t\t       I2C_SMBUS_BYTE_DATA, &data);\n\n\treturn ret ?: data.byte;\n}\n\n \n\n \nstatic void pca9541_release_bus(struct i2c_client *client)\n{\n\tint reg;\n\n\treg = pca9541_reg_read(client, PCA9541_CONTROL);\n\tif (reg >= 0 && !busoff(reg) && mybus(reg))\n\t\tpca9541_reg_write(client, PCA9541_CONTROL,\n\t\t\t\t  (reg & PCA9541_CTL_NBUSON) >> 1);\n}\n\n \n\n \nstatic const u8 pca9541_control[16] = {\n\t4, 0, 1, 5, 4, 4, 5, 5, 0, 0, 1, 1, 0, 4, 5, 1\n};\n\n \nstatic int pca9541_arbitrate(struct i2c_client *client)\n{\n\tstruct i2c_mux_core *muxc = i2c_get_clientdata(client);\n\tstruct pca9541 *data = i2c_mux_priv(muxc);\n\tint reg;\n\n\treg = pca9541_reg_read(client, PCA9541_CONTROL);\n\tif (reg < 0)\n\t\treturn reg;\n\n\tif (busoff(reg)) {\n\t\tint istat;\n\t\t \n\t\tistat = pca9541_reg_read(client, PCA9541_ISTAT);\n\t\tif (!(istat & PCA9541_ISTAT_NMYTEST)\n\t\t    || time_is_before_eq_jiffies(data->arb_timeout)) {\n\t\t\t \n\t\t\tpca9541_reg_write(client,\n\t\t\t\t\t  PCA9541_CONTROL,\n\t\t\t\t\t  pca9541_control[reg & 0x0f]\n\t\t\t\t\t  | PCA9541_CTL_NTESTON);\n\t\t\tdata->select_timeout = SELECT_DELAY_SHORT;\n\t\t} else {\n\t\t\t \n\t\t\tdata->select_timeout = SELECT_DELAY_LONG * 2;\n\t\t}\n\t} else if (mybus(reg)) {\n\t\t \n\t\tif (reg & (PCA9541_CTL_NTESTON | PCA9541_CTL_BUSINIT))\n\t\t\tpca9541_reg_write(client,\n\t\t\t\t\t  PCA9541_CONTROL,\n\t\t\t\t\t  reg & ~(PCA9541_CTL_NTESTON\n\t\t\t\t\t\t  | PCA9541_CTL_BUSINIT));\n\t\treturn 1;\n\t} else {\n\t\t \n\t\tdata->select_timeout = SELECT_DELAY_LONG;\n\t\tif (time_is_before_eq_jiffies(data->arb_timeout)) {\n\t\t\t \n\t\t\tpca9541_reg_write(client,\n\t\t\t\t\t  PCA9541_CONTROL,\n\t\t\t\t\t  pca9541_control[reg & 0x0f]\n\t\t\t\t\t  | PCA9541_CTL_BUSINIT\n\t\t\t\t\t  | PCA9541_CTL_NTESTON);\n\t\t} else {\n\t\t\t \n\t\t\tif (!(reg & PCA9541_CTL_NTESTON))\n\t\t\t\tpca9541_reg_write(client,\n\t\t\t\t\t\t  PCA9541_CONTROL,\n\t\t\t\t\t\t  reg | PCA9541_CTL_NTESTON);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int pca9541_select_chan(struct i2c_mux_core *muxc, u32 chan)\n{\n\tstruct pca9541 *data = i2c_mux_priv(muxc);\n\tstruct i2c_client *client = data->client;\n\tint ret;\n\tunsigned long timeout = jiffies + ARB2_TIMEOUT;\n\t\t \n\n\tdata->arb_timeout = jiffies + ARB_TIMEOUT;\n\t\t \n\n\tdo {\n\t\tret = pca9541_arbitrate(client);\n\t\tif (ret)\n\t\t\treturn ret < 0 ? ret : 0;\n\n\t\tif (data->select_timeout == SELECT_DELAY_SHORT)\n\t\t\tudelay(data->select_timeout);\n\t\telse\n\t\t\tmsleep(data->select_timeout / 1000);\n\t} while (time_is_after_eq_jiffies(timeout));\n\n\treturn -ETIMEDOUT;\n}\n\nstatic int pca9541_release_chan(struct i2c_mux_core *muxc, u32 chan)\n{\n\tstruct pca9541 *data = i2c_mux_priv(muxc);\n\tstruct i2c_client *client = data->client;\n\n\tpca9541_release_bus(client);\n\treturn 0;\n}\n\n \nstatic int pca9541_probe(struct i2c_client *client)\n{\n\tstruct i2c_adapter *adap = client->adapter;\n\tstruct i2c_mux_core *muxc;\n\tstruct pca9541 *data;\n\tint ret;\n\n\tif (!i2c_check_functionality(adap, I2C_FUNC_SMBUS_BYTE_DATA))\n\t\treturn -ENODEV;\n\n\t \n\ti2c_lock_bus(adap, I2C_LOCK_SEGMENT);\n\tpca9541_release_bus(client);\n\ti2c_unlock_bus(adap, I2C_LOCK_SEGMENT);\n\n\t \n\n\tmuxc = i2c_mux_alloc(adap, &client->dev, 1, sizeof(*data),\n\t\t\t     I2C_MUX_ARBITRATOR,\n\t\t\t     pca9541_select_chan, pca9541_release_chan);\n\tif (!muxc)\n\t\treturn -ENOMEM;\n\n\tdata = i2c_mux_priv(muxc);\n\tdata->client = client;\n\n\ti2c_set_clientdata(client, muxc);\n\n\tret = i2c_mux_add_adapter(muxc, 0, 0, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tdev_info(&client->dev, \"registered master selector for I2C %s\\n\",\n\t\t client->name);\n\n\treturn 0;\n}\n\nstatic void pca9541_remove(struct i2c_client *client)\n{\n\tstruct i2c_mux_core *muxc = i2c_get_clientdata(client);\n\n\ti2c_mux_del_adapters(muxc);\n}\n\nstatic struct i2c_driver pca9541_driver = {\n\t.driver = {\n\t\t   .name = \"pca9541\",\n\t\t   .of_match_table = of_match_ptr(pca9541_of_match),\n\t\t   },\n\t.probe = pca9541_probe,\n\t.remove = pca9541_remove,\n\t.id_table = pca9541_id,\n};\n\nmodule_i2c_driver(pca9541_driver);\n\nMODULE_AUTHOR(\"Guenter Roeck <linux@roeck-us.net>\");\nMODULE_DESCRIPTION(\"PCA9541 I2C master selector driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}