{
  "module_name": "i2c-mux-gpmux.c",
  "hash_id": "1b42b83bd9b9328ce65c181ecc3839e324e07834ded96b3039ec705281c66e2d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/muxes/i2c-mux-gpmux.c",
  "human_readable_source": "\n \n\n#include <linux/i2c.h>\n#include <linux/i2c-mux.h>\n#include <linux/module.h>\n#include <linux/mux/consumer.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n\nstruct mux {\n\tstruct mux_control *control;\n\n\tbool do_not_deselect;\n};\n\nstatic int i2c_mux_select(struct i2c_mux_core *muxc, u32 chan)\n{\n\tstruct mux *mux = i2c_mux_priv(muxc);\n\tint ret;\n\n\tret = mux_control_select(mux->control, chan);\n\tmux->do_not_deselect = ret < 0;\n\n\treturn ret;\n}\n\nstatic int i2c_mux_deselect(struct i2c_mux_core *muxc, u32 chan)\n{\n\tstruct mux *mux = i2c_mux_priv(muxc);\n\n\tif (mux->do_not_deselect)\n\t\treturn 0;\n\n\treturn mux_control_deselect(mux->control);\n}\n\nstatic struct i2c_adapter *mux_parent_adapter(struct device *dev)\n{\n\tstruct device_node *np = dev->of_node;\n\tstruct device_node *parent_np;\n\tstruct i2c_adapter *parent;\n\n\tparent_np = of_parse_phandle(np, \"i2c-parent\", 0);\n\tif (!parent_np) {\n\t\tdev_err(dev, \"Cannot parse i2c-parent\\n\");\n\t\treturn ERR_PTR(-ENODEV);\n\t}\n\tparent = of_get_i2c_adapter_by_node(parent_np);\n\tof_node_put(parent_np);\n\tif (!parent)\n\t\treturn ERR_PTR(-EPROBE_DEFER);\n\n\treturn parent;\n}\n\nstatic const struct of_device_id i2c_mux_of_match[] = {\n\t{ .compatible = \"i2c-mux\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, i2c_mux_of_match);\n\nstatic int i2c_mux_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct device_node *child;\n\tstruct i2c_mux_core *muxc;\n\tstruct mux *mux;\n\tstruct i2c_adapter *parent;\n\tint children;\n\tint ret;\n\n\tif (!np)\n\t\treturn -ENODEV;\n\n\tmux = devm_kzalloc(dev, sizeof(*mux), GFP_KERNEL);\n\tif (!mux)\n\t\treturn -ENOMEM;\n\n\tmux->control = devm_mux_control_get(dev, NULL);\n\tif (IS_ERR(mux->control))\n\t\treturn dev_err_probe(dev, PTR_ERR(mux->control),\n\t\t\t\t     \"failed to get control-mux\\n\");\n\n\tparent = mux_parent_adapter(dev);\n\tif (IS_ERR(parent))\n\t\treturn dev_err_probe(dev, PTR_ERR(parent),\n\t\t\t\t     \"failed to get i2c-parent adapter\\n\");\n\n\tchildren = of_get_child_count(np);\n\n\tmuxc = i2c_mux_alloc(parent, dev, children, 0, 0,\n\t\t\t     i2c_mux_select, i2c_mux_deselect);\n\tif (!muxc) {\n\t\tret = -ENOMEM;\n\t\tgoto err_parent;\n\t}\n\tmuxc->priv = mux;\n\n\tplatform_set_drvdata(pdev, muxc);\n\n\tmuxc->mux_locked = of_property_read_bool(np, \"mux-locked\");\n\n\tfor_each_child_of_node(np, child) {\n\t\tu32 chan;\n\n\t\tret = of_property_read_u32(child, \"reg\", &chan);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"no reg property for node '%pOFn'\\n\",\n\t\t\t\tchild);\n\t\t\tgoto err_children;\n\t\t}\n\n\t\tif (chan >= mux_control_states(mux->control)) {\n\t\t\tdev_err(dev, \"invalid reg %u\\n\", chan);\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_children;\n\t\t}\n\n\t\tret = i2c_mux_add_adapter(muxc, 0, chan, 0);\n\t\tif (ret)\n\t\t\tgoto err_children;\n\t}\n\n\tdev_info(dev, \"%d-port mux on %s adapter\\n\", children, parent->name);\n\n\treturn 0;\n\nerr_children:\n\tof_node_put(child);\n\ti2c_mux_del_adapters(muxc);\nerr_parent:\n\ti2c_put_adapter(parent);\n\n\treturn ret;\n}\n\nstatic void i2c_mux_remove(struct platform_device *pdev)\n{\n\tstruct i2c_mux_core *muxc = platform_get_drvdata(pdev);\n\n\ti2c_mux_del_adapters(muxc);\n\ti2c_put_adapter(muxc->parent);\n}\n\nstatic struct platform_driver i2c_mux_driver = {\n\t.probe\t= i2c_mux_probe,\n\t.remove_new = i2c_mux_remove,\n\t.driver\t= {\n\t\t.name\t= \"i2c-mux-gpmux\",\n\t\t.of_match_table = i2c_mux_of_match,\n\t},\n};\nmodule_platform_driver(i2c_mux_driver);\n\nMODULE_DESCRIPTION(\"General Purpose I2C multiplexer driver\");\nMODULE_AUTHOR(\"Peter Rosin <peda@axentia.se>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}