{
  "module_name": "i2c-demux-pinctrl.c",
  "hash_id": "9c5a8cb9f88eeb3c0a1ef2c51660021c29c4b0e4bd0e7e2b66325c637f1e0361",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/muxes/i2c-demux-pinctrl.c",
  "human_readable_source": "\n \n\n#include <linux/i2c.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n\nstruct i2c_demux_pinctrl_chan {\n\tstruct device_node *parent_np;\n\tstruct i2c_adapter *parent_adap;\n\tstruct of_changeset chgset;\n};\n\nstruct i2c_demux_pinctrl_priv {\n\tint cur_chan;\n\tint num_chan;\n\tstruct device *dev;\n\tconst char *bus_name;\n\tstruct i2c_adapter cur_adap;\n\tstruct i2c_algorithm algo;\n\tstruct i2c_demux_pinctrl_chan chan[];\n};\n\nstatic int i2c_demux_master_xfer(struct i2c_adapter *adap, struct i2c_msg msgs[], int num)\n{\n\tstruct i2c_demux_pinctrl_priv *priv = adap->algo_data;\n\tstruct i2c_adapter *parent = priv->chan[priv->cur_chan].parent_adap;\n\n\treturn __i2c_transfer(parent, msgs, num);\n}\n\nstatic u32 i2c_demux_functionality(struct i2c_adapter *adap)\n{\n\tstruct i2c_demux_pinctrl_priv *priv = adap->algo_data;\n\tstruct i2c_adapter *parent = priv->chan[priv->cur_chan].parent_adap;\n\n\treturn parent->algo->functionality(parent);\n}\n\nstatic int i2c_demux_activate_master(struct i2c_demux_pinctrl_priv *priv, u32 new_chan)\n{\n\tstruct i2c_adapter *adap;\n\tstruct pinctrl *p;\n\tint ret;\n\n\tret = of_changeset_apply(&priv->chan[new_chan].chgset);\n\tif (ret)\n\t\tgoto err;\n\n\tadap = of_get_i2c_adapter_by_node(priv->chan[new_chan].parent_np);\n\tif (!adap) {\n\t\tret = -ENODEV;\n\t\tgoto err_with_revert;\n\t}\n\n\t \n\tp = devm_pinctrl_get(adap->dev.parent);\n\tif (IS_ERR(p)) {\n\t\tret = PTR_ERR(p);\n\t\t \n\t\tif (ret != -ENODEV)\n\t\t\tgoto err_with_put;\n\t} else {\n\t\t \n\t\tstruct pinctrl_state *s = pinctrl_lookup_state(p, priv->bus_name);\n\n\t\tif (IS_ERR(s)) {\n\t\t\tret = PTR_ERR(s);\n\t\t\tgoto err_with_put;\n\t\t}\n\t\tret = pinctrl_select_state(p, s);\n\t\tif (ret < 0)\n\t\t\tgoto err_with_put;\n\t}\n\n\tpriv->chan[new_chan].parent_adap = adap;\n\tpriv->cur_chan = new_chan;\n\n\t \n\tpriv->algo.master_xfer = i2c_demux_master_xfer;\n\tif (adap->algo->master_xfer_atomic)\n\t\tpriv->algo.master_xfer_atomic = i2c_demux_master_xfer;\n\tpriv->algo.functionality = i2c_demux_functionality;\n\n\tsnprintf(priv->cur_adap.name, sizeof(priv->cur_adap.name),\n\t\t \"i2c-demux (master i2c-%d)\", i2c_adapter_id(adap));\n\tpriv->cur_adap.owner = THIS_MODULE;\n\tpriv->cur_adap.algo = &priv->algo;\n\tpriv->cur_adap.algo_data = priv;\n\tpriv->cur_adap.dev.parent = &adap->dev;\n\tpriv->cur_adap.class = adap->class;\n\tpriv->cur_adap.retries = adap->retries;\n\tpriv->cur_adap.timeout = adap->timeout;\n\tpriv->cur_adap.quirks = adap->quirks;\n\tpriv->cur_adap.dev.of_node = priv->dev->of_node;\n\tret = i2c_add_adapter(&priv->cur_adap);\n\tif (ret < 0)\n\t\tgoto err_with_put;\n\n\treturn 0;\n\n err_with_put:\n\ti2c_put_adapter(adap);\n err_with_revert:\n\tof_changeset_revert(&priv->chan[new_chan].chgset);\n err:\n\tdev_err(priv->dev, \"failed to setup demux-adapter %d (%d)\\n\", new_chan, ret);\n\tpriv->cur_chan = -EINVAL;\n\treturn ret;\n}\n\nstatic int i2c_demux_deactivate_master(struct i2c_demux_pinctrl_priv *priv)\n{\n\tint ret, cur = priv->cur_chan;\n\n\tif (cur < 0)\n\t\treturn 0;\n\n\ti2c_del_adapter(&priv->cur_adap);\n\ti2c_put_adapter(priv->chan[cur].parent_adap);\n\n\tret = of_changeset_revert(&priv->chan[cur].chgset);\n\n\tpriv->chan[cur].parent_adap = NULL;\n\tpriv->cur_chan = -EINVAL;\n\n\treturn ret;\n}\n\nstatic int i2c_demux_change_master(struct i2c_demux_pinctrl_priv *priv, u32 new_chan)\n{\n\tint ret;\n\n\tif (new_chan == priv->cur_chan)\n\t\treturn 0;\n\n\tret = i2c_demux_deactivate_master(priv);\n\tif (ret)\n\t\treturn ret;\n\n\treturn i2c_demux_activate_master(priv, new_chan);\n}\n\nstatic ssize_t available_masters_show(struct device *dev,\n\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t      char *buf)\n{\n\tstruct i2c_demux_pinctrl_priv *priv = dev_get_drvdata(dev);\n\tint count = 0, i;\n\n\tfor (i = 0; i < priv->num_chan && count < PAGE_SIZE; i++)\n\t\tcount += scnprintf(buf + count, PAGE_SIZE - count, \"%d:%pOF%c\",\n\t\t\t\t   i, priv->chan[i].parent_np,\n\t\t\t\t   i == priv->num_chan - 1 ? '\\n' : ' ');\n\n\treturn count;\n}\nstatic DEVICE_ATTR_RO(available_masters);\n\nstatic ssize_t current_master_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t   char *buf)\n{\n\tstruct i2c_demux_pinctrl_priv *priv = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%d\\n\", priv->cur_chan);\n}\n\nstatic ssize_t current_master_store(struct device *dev,\n\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t    const char *buf, size_t count)\n{\n\tstruct i2c_demux_pinctrl_priv *priv = dev_get_drvdata(dev);\n\tunsigned int val;\n\tint ret;\n\n\tret = kstrtouint(buf, 0, &val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (val >= priv->num_chan)\n\t\treturn -EINVAL;\n\n\tret = i2c_demux_change_master(priv, val);\n\n\treturn ret < 0 ? ret : count;\n}\nstatic DEVICE_ATTR_RW(current_master);\n\nstatic int i2c_demux_pinctrl_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct i2c_demux_pinctrl_priv *priv;\n\tstruct property *props;\n\tint num_chan, i, j, err;\n\n\tnum_chan = of_count_phandle_with_args(np, \"i2c-parent\", NULL);\n\tif (num_chan < 2) {\n\t\tdev_err(&pdev->dev, \"Need at least two I2C masters to switch\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpriv = devm_kzalloc(&pdev->dev, struct_size(priv, chan, num_chan),\n\t\t\t    GFP_KERNEL);\n\n\tprops = devm_kcalloc(&pdev->dev, num_chan, sizeof(*props), GFP_KERNEL);\n\n\tif (!priv || !props)\n\t\treturn -ENOMEM;\n\n\terr = of_property_read_string(np, \"i2c-bus-name\", &priv->bus_name);\n\tif (err)\n\t\treturn err;\n\n\tfor (i = 0; i < num_chan; i++) {\n\t\tstruct device_node *adap_np;\n\n\t\tadap_np = of_parse_phandle(np, \"i2c-parent\", i);\n\t\tif (!adap_np) {\n\t\t\tdev_err(&pdev->dev, \"can't get phandle for parent %d\\n\", i);\n\t\t\terr = -ENOENT;\n\t\t\tgoto err_rollback;\n\t\t}\n\t\tpriv->chan[i].parent_np = adap_np;\n\n\t\tprops[i].name = devm_kstrdup(&pdev->dev, \"status\", GFP_KERNEL);\n\t\tprops[i].value = devm_kstrdup(&pdev->dev, \"ok\", GFP_KERNEL);\n\t\tif (!props[i].name || !props[i].value) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_rollback;\n\t\t}\n\t\tprops[i].length = 3;\n\n\t\tof_changeset_init(&priv->chan[i].chgset);\n\t\tof_changeset_update_property(&priv->chan[i].chgset, adap_np, &props[i]);\n\t}\n\n\tpriv->num_chan = num_chan;\n\tpriv->dev = &pdev->dev;\n\n\tplatform_set_drvdata(pdev, priv);\n\n\tpm_runtime_no_callbacks(&pdev->dev);\n\n\t \n\ti2c_demux_activate_master(priv, 0);\n\n\terr = device_create_file(&pdev->dev, &dev_attr_available_masters);\n\tif (err)\n\t\tgoto err_rollback_activation;\n\n\terr = device_create_file(&pdev->dev, &dev_attr_current_master);\n\tif (err)\n\t\tgoto err_rollback_available;\n\n\treturn 0;\n\nerr_rollback_available:\n\tdevice_remove_file(&pdev->dev, &dev_attr_available_masters);\nerr_rollback_activation:\n\ti2c_demux_deactivate_master(priv);\nerr_rollback:\n\tfor (j = 0; j < i; j++) {\n\t\tof_node_put(priv->chan[j].parent_np);\n\t\tof_changeset_destroy(&priv->chan[j].chgset);\n\t}\n\n\treturn err;\n}\n\nstatic void i2c_demux_pinctrl_remove(struct platform_device *pdev)\n{\n\tstruct i2c_demux_pinctrl_priv *priv = platform_get_drvdata(pdev);\n\tint i;\n\n\tdevice_remove_file(&pdev->dev, &dev_attr_current_master);\n\tdevice_remove_file(&pdev->dev, &dev_attr_available_masters);\n\n\ti2c_demux_deactivate_master(priv);\n\n\tfor (i = 0; i < priv->num_chan; i++) {\n\t\tof_node_put(priv->chan[i].parent_np);\n\t\tof_changeset_destroy(&priv->chan[i].chgset);\n\t}\n}\n\nstatic const struct of_device_id i2c_demux_pinctrl_of_match[] = {\n\t{ .compatible = \"i2c-demux-pinctrl\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, i2c_demux_pinctrl_of_match);\n\nstatic struct platform_driver i2c_demux_pinctrl_driver = {\n\t.driver\t= {\n\t\t.name = \"i2c-demux-pinctrl\",\n\t\t.of_match_table = i2c_demux_pinctrl_of_match,\n\t},\n\t.probe\t= i2c_demux_pinctrl_probe,\n\t.remove_new = i2c_demux_pinctrl_remove,\n};\nmodule_platform_driver(i2c_demux_pinctrl_driver);\n\nMODULE_DESCRIPTION(\"pinctrl-based I2C demux driver\");\nMODULE_AUTHOR(\"Wolfram Sang <wsa@sang-engineering.com>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:i2c-demux-pinctrl\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}