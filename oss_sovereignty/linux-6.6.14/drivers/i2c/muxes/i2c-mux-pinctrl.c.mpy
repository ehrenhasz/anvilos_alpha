{
  "module_name": "i2c-mux-pinctrl.c",
  "hash_id": "1c0ee05881e8c564a28e7192b868687249eb1c200296046d2dfe62d6d8792eab",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/muxes/i2c-mux-pinctrl.c",
  "human_readable_source": "\n \n\n#include <linux/i2c.h>\n#include <linux/i2c-mux.h>\n#include <linux/module.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/of.h>\n#include \"../../pinctrl/core.h\"\n\nstruct i2c_mux_pinctrl {\n\tstruct pinctrl *pinctrl;\n\tstruct pinctrl_state *states[];\n};\n\nstatic int i2c_mux_pinctrl_select(struct i2c_mux_core *muxc, u32 chan)\n{\n\tstruct i2c_mux_pinctrl *mux = i2c_mux_priv(muxc);\n\n\treturn pinctrl_select_state(mux->pinctrl, mux->states[chan]);\n}\n\nstatic int i2c_mux_pinctrl_deselect(struct i2c_mux_core *muxc, u32 chan)\n{\n\treturn i2c_mux_pinctrl_select(muxc, muxc->num_adapters);\n}\n\nstatic struct i2c_adapter *i2c_mux_pinctrl_root_adapter(\n\tstruct pinctrl_state *state)\n{\n\tstruct i2c_adapter *root = NULL;\n\tstruct pinctrl_setting *setting;\n\tstruct i2c_adapter *pin_root;\n\n\tlist_for_each_entry(setting, &state->settings, node) {\n\t\tpin_root = i2c_root_adapter(setting->pctldev->dev);\n\t\tif (!pin_root)\n\t\t\treturn NULL;\n\t\tif (!root)\n\t\t\troot = pin_root;\n\t\telse if (root != pin_root)\n\t\t\treturn NULL;\n\t}\n\n\treturn root;\n}\n\nstatic struct i2c_adapter *i2c_mux_pinctrl_parent_adapter(struct device *dev)\n{\n\tstruct device_node *np = dev->of_node;\n\tstruct device_node *parent_np;\n\tstruct i2c_adapter *parent;\n\n\tparent_np = of_parse_phandle(np, \"i2c-parent\", 0);\n\tif (!parent_np) {\n\t\tdev_err(dev, \"Cannot parse i2c-parent\\n\");\n\t\treturn ERR_PTR(-ENODEV);\n\t}\n\tparent = of_get_i2c_adapter_by_node(parent_np);\n\tof_node_put(parent_np);\n\tif (!parent)\n\t\treturn ERR_PTR(-EPROBE_DEFER);\n\n\treturn parent;\n}\n\nstatic int i2c_mux_pinctrl_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct i2c_mux_core *muxc;\n\tstruct i2c_mux_pinctrl *mux;\n\tstruct i2c_adapter *parent;\n\tstruct i2c_adapter *root;\n\tint num_names, i, ret;\n\tconst char *name;\n\n\tnum_names = of_property_count_strings(np, \"pinctrl-names\");\n\tif (num_names < 0) {\n\t\tdev_err(dev, \"Cannot parse pinctrl-names: %d\\n\",\n\t\t\tnum_names);\n\t\treturn num_names;\n\t}\n\n\tparent = i2c_mux_pinctrl_parent_adapter(dev);\n\tif (IS_ERR(parent))\n\t\treturn PTR_ERR(parent);\n\n\tmuxc = i2c_mux_alloc(parent, dev, num_names,\n\t\t\t     struct_size(mux, states, num_names),\n\t\t\t     0, i2c_mux_pinctrl_select, NULL);\n\tif (!muxc) {\n\t\tret = -ENOMEM;\n\t\tgoto err_put_parent;\n\t}\n\tmux = i2c_mux_priv(muxc);\n\n\tplatform_set_drvdata(pdev, muxc);\n\n\tmux->pinctrl = devm_pinctrl_get(dev);\n\tif (IS_ERR(mux->pinctrl)) {\n\t\tret = PTR_ERR(mux->pinctrl);\n\t\tdev_err(dev, \"Cannot get pinctrl: %d\\n\", ret);\n\t\tgoto err_put_parent;\n\t}\n\n\tfor (i = 0; i < num_names; i++) {\n\t\tret = of_property_read_string_index(np, \"pinctrl-names\", i,\n\t\t\t\t\t\t    &name);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"Cannot parse pinctrl-names: %d\\n\", ret);\n\t\t\tgoto err_put_parent;\n\t\t}\n\n\t\tmux->states[i] = pinctrl_lookup_state(mux->pinctrl, name);\n\t\tif (IS_ERR(mux->states[i])) {\n\t\t\tret = PTR_ERR(mux->states[i]);\n\t\t\tdev_err(dev, \"Cannot look up pinctrl state %s: %d\\n\",\n\t\t\t\tname, ret);\n\t\t\tgoto err_put_parent;\n\t\t}\n\n\t\tif (strcmp(name, \"idle\"))\n\t\t\tcontinue;\n\n\t\tif (i != num_names - 1) {\n\t\t\tdev_err(dev, \"idle state must be last\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_put_parent;\n\t\t}\n\t\tmuxc->deselect = i2c_mux_pinctrl_deselect;\n\t}\n\n\troot = i2c_root_adapter(&muxc->parent->dev);\n\n\tmuxc->mux_locked = true;\n\tfor (i = 0; i < num_names; i++) {\n\t\tif (root != i2c_mux_pinctrl_root_adapter(mux->states[i])) {\n\t\t\tmuxc->mux_locked = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (muxc->mux_locked)\n\t\tdev_info(dev, \"mux-locked i2c mux\\n\");\n\n\t \n\tfor (i = 0; i < num_names - !!muxc->deselect; i++) {\n\t\tret = i2c_mux_add_adapter(muxc, 0, i, 0);\n\t\tif (ret)\n\t\t\tgoto err_del_adapter;\n\t}\n\n\treturn 0;\n\nerr_del_adapter:\n\ti2c_mux_del_adapters(muxc);\nerr_put_parent:\n\ti2c_put_adapter(parent);\n\n\treturn ret;\n}\n\nstatic void i2c_mux_pinctrl_remove(struct platform_device *pdev)\n{\n\tstruct i2c_mux_core *muxc = platform_get_drvdata(pdev);\n\n\ti2c_mux_del_adapters(muxc);\n\ti2c_put_adapter(muxc->parent);\n}\n\nstatic const struct of_device_id i2c_mux_pinctrl_of_match[] = {\n\t{ .compatible = \"i2c-mux-pinctrl\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, i2c_mux_pinctrl_of_match);\n\nstatic struct platform_driver i2c_mux_pinctrl_driver = {\n\t.driver\t= {\n\t\t.name\t= \"i2c-mux-pinctrl\",\n\t\t.of_match_table = i2c_mux_pinctrl_of_match,\n\t},\n\t.probe\t= i2c_mux_pinctrl_probe,\n\t.remove_new = i2c_mux_pinctrl_remove,\n};\nmodule_platform_driver(i2c_mux_pinctrl_driver);\n\nMODULE_DESCRIPTION(\"pinctrl-based I2C multiplexer driver\");\nMODULE_AUTHOR(\"Stephen Warren <swarren@nvidia.com>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:i2c-mux-pinctrl\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}