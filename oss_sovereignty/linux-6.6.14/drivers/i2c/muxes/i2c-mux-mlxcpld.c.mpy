{
  "module_name": "i2c-mux-mlxcpld.c",
  "hash_id": "2fe755a1ae64d3fc27125188c6048f43546a71d88396fdde57181aa7820af8be",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/muxes/i2c-mux-mlxcpld.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/i2c.h>\n#include <linux/i2c-mux.h>\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/platform_data/mlxcpld.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n\n \nstruct mlxcpld_mux {\n\tint last_val;\n\tstruct i2c_client *client;\n\tstruct mlxcpld_mux_plat_data pdata;\n};\n\n \n\n \nstatic int mlxcpld_mux_reg_write(struct i2c_adapter *adap,\n\t\t\t\t struct mlxcpld_mux *mux, u32 val)\n{\n\tstruct i2c_client *client = mux->client;\n\tunion i2c_smbus_data data;\n\tstruct i2c_msg msg;\n\tu8 buf[3];\n\n\tswitch (mux->pdata.reg_size) {\n\tcase 1:\n\t\tdata.byte = val;\n\t\treturn __i2c_smbus_xfer(adap, client->addr, client->flags,\n\t\t\t\t\tI2C_SMBUS_WRITE, mux->pdata.sel_reg_addr,\n\t\t\t\t\tI2C_SMBUS_BYTE_DATA, &data);\n\tcase 2:\n\t\tbuf[0] = mux->pdata.sel_reg_addr >> 8;\n\t\tbuf[1] = mux->pdata.sel_reg_addr;\n\t\tbuf[2] = val;\n\t\tmsg.addr = client->addr;\n\t\tmsg.buf = buf;\n\t\tmsg.len = mux->pdata.reg_size + 1;\n\t\tmsg.flags = 0;\n\t\treturn __i2c_transfer(adap, &msg, 1);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int mlxcpld_mux_select_chan(struct i2c_mux_core *muxc, u32 chan)\n{\n\tstruct mlxcpld_mux *mux = i2c_mux_priv(muxc);\n\tu32 regval = chan;\n\tint err = 0;\n\n\tif (mux->pdata.reg_size == 1)\n\t\tregval += 1;\n\n\t \n\tif (mux->last_val != regval) {\n\t\terr = mlxcpld_mux_reg_write(muxc->parent, mux, regval);\n\t\tmux->last_val = err < 0 ? -1 : regval;\n\t}\n\n\treturn err;\n}\n\nstatic int mlxcpld_mux_deselect(struct i2c_mux_core *muxc, u32 chan)\n{\n\tstruct mlxcpld_mux *mux = i2c_mux_priv(muxc);\n\n\t \n\tmux->last_val = -1;\n\n\treturn mlxcpld_mux_reg_write(muxc->parent, mux, 0);\n}\n\n \nstatic int mlxcpld_mux_probe(struct platform_device *pdev)\n{\n\tstruct mlxcpld_mux_plat_data *pdata = dev_get_platdata(&pdev->dev);\n\tstruct i2c_client *client = to_i2c_client(pdev->dev.parent);\n\tstruct i2c_mux_core *muxc;\n\tstruct mlxcpld_mux *data;\n\tint num, err;\n\tu32 func;\n\n\tif (!pdata)\n\t\treturn -EINVAL;\n\n\tswitch (pdata->reg_size) {\n\tcase 1:\n\t\tfunc = I2C_FUNC_SMBUS_WRITE_BYTE_DATA;\n\t\tbreak;\n\tcase 2:\n\t\tfunc = I2C_FUNC_I2C;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (!i2c_check_functionality(client->adapter, func))\n\t\treturn -ENODEV;\n\n\tmuxc = i2c_mux_alloc(client->adapter, &pdev->dev, pdata->num_adaps,\n\t\t\t     sizeof(*data), 0, mlxcpld_mux_select_chan,\n\t\t\t     mlxcpld_mux_deselect);\n\tif (!muxc)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, muxc);\n\tdata = i2c_mux_priv(muxc);\n\tdata->client = client;\n\tmemcpy(&data->pdata, pdata, sizeof(*pdata));\n\tdata->last_val = -1;  \n\n\t \n\tfor (num = 0; num < pdata->num_adaps; num++) {\n\t\terr = i2c_mux_add_adapter(muxc, 0, pdata->chan_ids[num], 0);\n\t\tif (err)\n\t\t\tgoto virt_reg_failed;\n\t}\n\n\t \n\tif (pdata->completion_notify)\n\t\tpdata->completion_notify(pdata->handle, muxc->parent, muxc->adapter);\n\n\treturn 0;\n\nvirt_reg_failed:\n\ti2c_mux_del_adapters(muxc);\n\treturn err;\n}\n\nstatic void mlxcpld_mux_remove(struct platform_device *pdev)\n{\n\tstruct i2c_mux_core *muxc = platform_get_drvdata(pdev);\n\n\ti2c_mux_del_adapters(muxc);\n}\n\nstatic struct platform_driver mlxcpld_mux_driver = {\n\t.driver = {\n\t\t.name = \"i2c-mux-mlxcpld\",\n\t},\n\t.probe = mlxcpld_mux_probe,\n\t.remove_new = mlxcpld_mux_remove,\n};\n\nmodule_platform_driver(mlxcpld_mux_driver);\n\nMODULE_AUTHOR(\"Michael Shych (michaels@mellanox.com)\");\nMODULE_DESCRIPTION(\"Mellanox I2C-CPLD-MUX driver\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_ALIAS(\"platform:i2c-mux-mlxcpld\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}