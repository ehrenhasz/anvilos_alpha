{
  "module_name": "i2c-mux-pca954x.c",
  "hash_id": "0398f8725d1572b4ba0f4f72d90e4c7e8b7bd3e4d00fa33695e60f764e0b0bee",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/muxes/i2c-mux-pca954x.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/i2c-mux.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/module.h>\n#include <linux/pm.h>\n#include <linux/property.h>\n#include <linux/regulator/consumer.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <dt-bindings/mux/mux.h>\n\n#define PCA954X_MAX_NCHANS 8\n\n#define PCA954X_IRQ_OFFSET 4\n\nenum pca_type {\n\tmax_7356,\n\tmax_7357,\n\tmax_7358,\n\tmax_7367,\n\tmax_7368,\n\tmax_7369,\n\tpca_9540,\n\tpca_9542,\n\tpca_9543,\n\tpca_9544,\n\tpca_9545,\n\tpca_9546,\n\tpca_9547,\n\tpca_9548,\n\tpca_9846,\n\tpca_9847,\n\tpca_9848,\n\tpca_9849,\n};\n\nstruct chip_desc {\n\tu8 nchans;\n\tu8 enable;\t \n\tu8 has_irq;\n\tenum muxtype {\n\t\tpca954x_ismux = 0,\n\t\tpca954x_isswi\n\t} muxtype;\n\tstruct i2c_device_identity id;\n};\n\nstruct pca954x {\n\tconst struct chip_desc *chip;\n\n\tu8 last_chan;\t\t \n\t \n\ts32 idle_state;\n\n\tstruct i2c_client *client;\n\n\tstruct irq_domain *irq;\n\tunsigned int irq_mask;\n\traw_spinlock_t lock;\n\tstruct regulator *supply;\n};\n\n \nstatic const struct chip_desc chips[] = {\n\t[max_7356] = {\n\t\t.nchans = 8,\n\t\t.muxtype = pca954x_isswi,\n\t\t.id = { .manufacturer_id = I2C_DEVICE_ID_NONE },\n\t},\n\t[max_7357] = {\n\t\t.nchans = 8,\n\t\t.muxtype = pca954x_isswi,\n\t\t.id = { .manufacturer_id = I2C_DEVICE_ID_NONE },\n\t\t \n\t},\n\t[max_7358] = {\n\t\t.nchans = 8,\n\t\t.muxtype = pca954x_isswi,\n\t\t.id = { .manufacturer_id = I2C_DEVICE_ID_NONE },\n\t\t \n\t},\n\t[max_7367] = {\n\t\t.nchans = 4,\n\t\t.muxtype = pca954x_isswi,\n\t\t.has_irq = 1,\n\t\t.id = { .manufacturer_id = I2C_DEVICE_ID_NONE },\n\t},\n\t[max_7368] = {\n\t\t.nchans = 4,\n\t\t.muxtype = pca954x_isswi,\n\t\t.id = { .manufacturer_id = I2C_DEVICE_ID_NONE },\n\t},\n\t[max_7369] = {\n\t\t.nchans = 4,\n\t\t.enable = 0x4,\n\t\t.muxtype = pca954x_ismux,\n\t\t.has_irq = 1,\n\t\t.id = { .manufacturer_id = I2C_DEVICE_ID_NONE },\n\t},\n\t[pca_9540] = {\n\t\t.nchans = 2,\n\t\t.enable = 0x4,\n\t\t.muxtype = pca954x_ismux,\n\t\t.id = { .manufacturer_id = I2C_DEVICE_ID_NONE },\n\t},\n\t[pca_9542] = {\n\t\t.nchans = 2,\n\t\t.enable = 0x4,\n\t\t.has_irq = 1,\n\t\t.muxtype = pca954x_ismux,\n\t\t.id = { .manufacturer_id = I2C_DEVICE_ID_NONE },\n\t},\n\t[pca_9543] = {\n\t\t.nchans = 2,\n\t\t.has_irq = 1,\n\t\t.muxtype = pca954x_isswi,\n\t\t.id = { .manufacturer_id = I2C_DEVICE_ID_NONE },\n\t},\n\t[pca_9544] = {\n\t\t.nchans = 4,\n\t\t.enable = 0x4,\n\t\t.has_irq = 1,\n\t\t.muxtype = pca954x_ismux,\n\t\t.id = { .manufacturer_id = I2C_DEVICE_ID_NONE },\n\t},\n\t[pca_9545] = {\n\t\t.nchans = 4,\n\t\t.has_irq = 1,\n\t\t.muxtype = pca954x_isswi,\n\t\t.id = { .manufacturer_id = I2C_DEVICE_ID_NONE },\n\t},\n\t[pca_9546] = {\n\t\t.nchans = 4,\n\t\t.muxtype = pca954x_isswi,\n\t\t.id = { .manufacturer_id = I2C_DEVICE_ID_NONE },\n\t},\n\t[pca_9547] = {\n\t\t.nchans = 8,\n\t\t.enable = 0x8,\n\t\t.muxtype = pca954x_ismux,\n\t\t.id = { .manufacturer_id = I2C_DEVICE_ID_NONE },\n\t},\n\t[pca_9548] = {\n\t\t.nchans = 8,\n\t\t.muxtype = pca954x_isswi,\n\t\t.id = { .manufacturer_id = I2C_DEVICE_ID_NONE },\n\t},\n\t[pca_9846] = {\n\t\t.nchans = 4,\n\t\t.muxtype = pca954x_isswi,\n\t\t.id = {\n\t\t\t.manufacturer_id = I2C_DEVICE_ID_NXP_SEMICONDUCTORS,\n\t\t\t.part_id = 0x10b,\n\t\t},\n\t},\n\t[pca_9847] = {\n\t\t.nchans = 8,\n\t\t.enable = 0x8,\n\t\t.muxtype = pca954x_ismux,\n\t\t.id = {\n\t\t\t.manufacturer_id = I2C_DEVICE_ID_NXP_SEMICONDUCTORS,\n\t\t\t.part_id = 0x108,\n\t\t},\n\t},\n\t[pca_9848] = {\n\t\t.nchans = 8,\n\t\t.muxtype = pca954x_isswi,\n\t\t.id = {\n\t\t\t.manufacturer_id = I2C_DEVICE_ID_NXP_SEMICONDUCTORS,\n\t\t\t.part_id = 0x10a,\n\t\t},\n\t},\n\t[pca_9849] = {\n\t\t.nchans = 4,\n\t\t.enable = 0x4,\n\t\t.muxtype = pca954x_ismux,\n\t\t.id = {\n\t\t\t.manufacturer_id = I2C_DEVICE_ID_NXP_SEMICONDUCTORS,\n\t\t\t.part_id = 0x109,\n\t\t},\n\t},\n};\n\nstatic const struct i2c_device_id pca954x_id[] = {\n\t{ \"max7356\", max_7356 },\n\t{ \"max7357\", max_7357 },\n\t{ \"max7358\", max_7358 },\n\t{ \"max7367\", max_7367 },\n\t{ \"max7368\", max_7368 },\n\t{ \"max7369\", max_7369 },\n\t{ \"pca9540\", pca_9540 },\n\t{ \"pca9542\", pca_9542 },\n\t{ \"pca9543\", pca_9543 },\n\t{ \"pca9544\", pca_9544 },\n\t{ \"pca9545\", pca_9545 },\n\t{ \"pca9546\", pca_9546 },\n\t{ \"pca9547\", pca_9547 },\n\t{ \"pca9548\", pca_9548 },\n\t{ \"pca9846\", pca_9846 },\n\t{ \"pca9847\", pca_9847 },\n\t{ \"pca9848\", pca_9848 },\n\t{ \"pca9849\", pca_9849 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, pca954x_id);\n\nstatic const struct of_device_id pca954x_of_match[] = {\n\t{ .compatible = \"maxim,max7356\", .data = &chips[max_7356] },\n\t{ .compatible = \"maxim,max7357\", .data = &chips[max_7357] },\n\t{ .compatible = \"maxim,max7358\", .data = &chips[max_7358] },\n\t{ .compatible = \"maxim,max7367\", .data = &chips[max_7367] },\n\t{ .compatible = \"maxim,max7368\", .data = &chips[max_7368] },\n\t{ .compatible = \"maxim,max7369\", .data = &chips[max_7369] },\n\t{ .compatible = \"nxp,pca9540\", .data = &chips[pca_9540] },\n\t{ .compatible = \"nxp,pca9542\", .data = &chips[pca_9542] },\n\t{ .compatible = \"nxp,pca9543\", .data = &chips[pca_9543] },\n\t{ .compatible = \"nxp,pca9544\", .data = &chips[pca_9544] },\n\t{ .compatible = \"nxp,pca9545\", .data = &chips[pca_9545] },\n\t{ .compatible = \"nxp,pca9546\", .data = &chips[pca_9546] },\n\t{ .compatible = \"nxp,pca9547\", .data = &chips[pca_9547] },\n\t{ .compatible = \"nxp,pca9548\", .data = &chips[pca_9548] },\n\t{ .compatible = \"nxp,pca9846\", .data = &chips[pca_9846] },\n\t{ .compatible = \"nxp,pca9847\", .data = &chips[pca_9847] },\n\t{ .compatible = \"nxp,pca9848\", .data = &chips[pca_9848] },\n\t{ .compatible = \"nxp,pca9849\", .data = &chips[pca_9849] },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, pca954x_of_match);\n\n \nstatic int pca954x_reg_write(struct i2c_adapter *adap,\n\t\t\t     struct i2c_client *client, u8 val)\n{\n\tunion i2c_smbus_data dummy;\n\n\treturn __i2c_smbus_xfer(adap, client->addr, client->flags,\n\t\t\t\tI2C_SMBUS_WRITE, val,\n\t\t\t\tI2C_SMBUS_BYTE, &dummy);\n}\n\nstatic u8 pca954x_regval(struct pca954x *data, u8 chan)\n{\n\t \n\tif (data->chip->muxtype == pca954x_ismux)\n\t\treturn chan | data->chip->enable;\n\telse\n\t\treturn 1 << chan;\n}\n\nstatic int pca954x_select_chan(struct i2c_mux_core *muxc, u32 chan)\n{\n\tstruct pca954x *data = i2c_mux_priv(muxc);\n\tstruct i2c_client *client = data->client;\n\tu8 regval;\n\tint ret = 0;\n\n\tregval = pca954x_regval(data, chan);\n\t \n\tif (data->last_chan != regval) {\n\t\tret = pca954x_reg_write(muxc->parent, client, regval);\n\t\tdata->last_chan = ret < 0 ? 0 : regval;\n\t}\n\n\treturn ret;\n}\n\nstatic int pca954x_deselect_mux(struct i2c_mux_core *muxc, u32 chan)\n{\n\tstruct pca954x *data = i2c_mux_priv(muxc);\n\tstruct i2c_client *client = data->client;\n\ts32 idle_state;\n\n\tidle_state = READ_ONCE(data->idle_state);\n\tif (idle_state >= 0)\n\t\t \n\t\treturn pca954x_select_chan(muxc, idle_state);\n\n\tif (idle_state == MUX_IDLE_DISCONNECT) {\n\t\t \n\t\tdata->last_chan = 0;\n\t\treturn pca954x_reg_write(muxc->parent, client,\n\t\t\t\t\t data->last_chan);\n\t}\n\n\t \n\n\treturn 0;\n}\n\nstatic ssize_t idle_state_show(struct device *dev,\n\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t    char *buf)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct i2c_mux_core *muxc = i2c_get_clientdata(client);\n\tstruct pca954x *data = i2c_mux_priv(muxc);\n\n\treturn sprintf(buf, \"%d\\n\", READ_ONCE(data->idle_state));\n}\n\nstatic ssize_t idle_state_store(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct i2c_mux_core *muxc = i2c_get_clientdata(client);\n\tstruct pca954x *data = i2c_mux_priv(muxc);\n\tint val;\n\tint ret;\n\n\tret = kstrtoint(buf, 0, &val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (val != MUX_IDLE_AS_IS && val != MUX_IDLE_DISCONNECT &&\n\t    (val < 0 || val >= data->chip->nchans))\n\t\treturn -EINVAL;\n\n\ti2c_lock_bus(muxc->parent, I2C_LOCK_SEGMENT);\n\n\tWRITE_ONCE(data->idle_state, val);\n\t \n\tif (data->last_chan || val != MUX_IDLE_DISCONNECT)\n\t\tret = pca954x_deselect_mux(muxc, 0);\n\n\ti2c_unlock_bus(muxc->parent, I2C_LOCK_SEGMENT);\n\n\treturn ret < 0 ? ret : count;\n}\n\nstatic DEVICE_ATTR_RW(idle_state);\n\nstatic irqreturn_t pca954x_irq_handler(int irq, void *dev_id)\n{\n\tstruct pca954x *data = dev_id;\n\tunsigned long pending;\n\tint ret, i;\n\n\tret = i2c_smbus_read_byte(data->client);\n\tif (ret < 0)\n\t\treturn IRQ_NONE;\n\n\tpending = (ret >> PCA954X_IRQ_OFFSET) & (BIT(data->chip->nchans) - 1);\n\tfor_each_set_bit(i, &pending, data->chip->nchans)\n\t\thandle_nested_irq(irq_linear_revmap(data->irq, i));\n\n\treturn IRQ_RETVAL(pending);\n}\n\nstatic int pca954x_irq_set_type(struct irq_data *idata, unsigned int type)\n{\n\tif ((type & IRQ_TYPE_SENSE_MASK) != IRQ_TYPE_LEVEL_LOW)\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic struct irq_chip pca954x_irq_chip = {\n\t.name = \"i2c-mux-pca954x\",\n\t.irq_set_type = pca954x_irq_set_type,\n};\n\nstatic int pca954x_irq_setup(struct i2c_mux_core *muxc)\n{\n\tstruct pca954x *data = i2c_mux_priv(muxc);\n\tstruct i2c_client *client = data->client;\n\tint c, irq;\n\n\tif (!data->chip->has_irq || client->irq <= 0)\n\t\treturn 0;\n\n\traw_spin_lock_init(&data->lock);\n\n\tdata->irq = irq_domain_add_linear(client->dev.of_node,\n\t\t\t\t\t  data->chip->nchans,\n\t\t\t\t\t  &irq_domain_simple_ops, data);\n\tif (!data->irq)\n\t\treturn -ENODEV;\n\n\tfor (c = 0; c < data->chip->nchans; c++) {\n\t\tirq = irq_create_mapping(data->irq, c);\n\t\tif (!irq) {\n\t\t\tdev_err(&client->dev, \"failed irq create map\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tirq_set_chip_data(irq, data);\n\t\tirq_set_chip_and_handler(irq, &pca954x_irq_chip,\n\t\t\thandle_simple_irq);\n\t}\n\n\treturn 0;\n}\n\nstatic void pca954x_cleanup(struct i2c_mux_core *muxc)\n{\n\tstruct pca954x *data = i2c_mux_priv(muxc);\n\tint c, irq;\n\n\tregulator_disable(data->supply);\n\n\tif (data->irq) {\n\t\tfor (c = 0; c < data->chip->nchans; c++) {\n\t\t\tirq = irq_find_mapping(data->irq, c);\n\t\t\tirq_dispose_mapping(irq);\n\t\t}\n\t\tirq_domain_remove(data->irq);\n\t}\n\ti2c_mux_del_adapters(muxc);\n}\n\nstatic int pca954x_init(struct i2c_client *client, struct pca954x *data)\n{\n\tint ret;\n\n\tif (data->idle_state >= 0)\n\t\tdata->last_chan = pca954x_regval(data, data->idle_state);\n\telse\n\t\tdata->last_chan = 0;  \n\n\tret = i2c_smbus_write_byte(client, data->last_chan);\n\tif (ret < 0)\n\t\tdata->last_chan = 0;\n\n\treturn ret;\n}\n\n \nstatic int pca954x_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tstruct i2c_adapter *adap = client->adapter;\n\tstruct device *dev = &client->dev;\n\tstruct gpio_desc *gpio;\n\tstruct i2c_mux_core *muxc;\n\tstruct pca954x *data;\n\tint num;\n\tint ret;\n\n\tif (!i2c_check_functionality(adap, I2C_FUNC_SMBUS_BYTE))\n\t\treturn -ENODEV;\n\n\tmuxc = i2c_mux_alloc(adap, dev, PCA954X_MAX_NCHANS, sizeof(*data), 0,\n\t\t\t     pca954x_select_chan, pca954x_deselect_mux);\n\tif (!muxc)\n\t\treturn -ENOMEM;\n\tdata = i2c_mux_priv(muxc);\n\n\ti2c_set_clientdata(client, muxc);\n\tdata->client = client;\n\n\tdata->supply = devm_regulator_get(dev, \"vdd\");\n\tif (IS_ERR(data->supply))\n\t\treturn dev_err_probe(dev, PTR_ERR(data->supply),\n\t\t\t\t\"Failed to request regulator\\n\");\n\n\tret = regulator_enable(data->supply);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret,\n\t\t\t\t     \"Failed to enable vdd supply\\n\");\n\n\t \n\tgpio = devm_gpiod_get_optional(dev, \"reset\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(gpio)) {\n\t\tret = PTR_ERR(gpio);\n\t\tgoto fail_cleanup;\n\t}\n\tif (gpio) {\n\t\tudelay(1);\n\t\tgpiod_set_value_cansleep(gpio, 0);\n\t\t \n\t\tudelay(1);\n\t}\n\n\tdata->chip = device_get_match_data(dev);\n\tif (!data->chip)\n\t\tdata->chip = &chips[id->driver_data];\n\n\tif (data->chip->id.manufacturer_id != I2C_DEVICE_ID_NONE) {\n\t\tstruct i2c_device_identity id;\n\n\t\tret = i2c_get_device_id(client, &id);\n\t\tif (ret && ret != -EOPNOTSUPP)\n\t\t\tgoto fail_cleanup;\n\n\t\tif (!ret &&\n\t\t    (id.manufacturer_id != data->chip->id.manufacturer_id ||\n\t\t     id.part_id != data->chip->id.part_id)) {\n\t\t\tdev_warn(dev, \"unexpected device id %03x-%03x-%x\\n\",\n\t\t\t\t id.manufacturer_id, id.part_id,\n\t\t\t\t id.die_revision);\n\t\t\tret = -ENODEV;\n\t\t\tgoto fail_cleanup;\n\t\t}\n\t}\n\n\tdata->idle_state = MUX_IDLE_AS_IS;\n\tif (device_property_read_u32(dev, \"idle-state\", &data->idle_state)) {\n\t\tif (device_property_read_bool(dev, \"i2c-mux-idle-disconnect\"))\n\t\t\tdata->idle_state = MUX_IDLE_DISCONNECT;\n\t}\n\n\t \n\tret = pca954x_init(client, data);\n\tif (ret < 0) {\n\t\tdev_warn(dev, \"probe failed\\n\");\n\t\tret = -ENODEV;\n\t\tgoto fail_cleanup;\n\t}\n\n\tret = pca954x_irq_setup(muxc);\n\tif (ret)\n\t\tgoto fail_cleanup;\n\n\t \n\tfor (num = 0; num < data->chip->nchans; num++) {\n\t\tret = i2c_mux_add_adapter(muxc, 0, num, 0);\n\t\tif (ret)\n\t\t\tgoto fail_cleanup;\n\t}\n\n\tif (data->irq) {\n\t\tret = devm_request_threaded_irq(dev, data->client->irq,\n\t\t\t\t\t\tNULL, pca954x_irq_handler,\n\t\t\t\t\t\tIRQF_ONESHOT | IRQF_SHARED,\n\t\t\t\t\t\t\"pca954x\", data);\n\t\tif (ret)\n\t\t\tgoto fail_cleanup;\n\t}\n\n\t \n\tdevice_create_file(dev, &dev_attr_idle_state);\n\n\tdev_info(dev, \"registered %d multiplexed busses for I2C %s %s\\n\",\n\t\t num, data->chip->muxtype == pca954x_ismux\n\t\t\t\t? \"mux\" : \"switch\", client->name);\n\n\treturn 0;\n\nfail_cleanup:\n\tpca954x_cleanup(muxc);\n\treturn ret;\n}\n\nstatic void pca954x_remove(struct i2c_client *client)\n{\n\tstruct i2c_mux_core *muxc = i2c_get_clientdata(client);\n\n\tdevice_remove_file(&client->dev, &dev_attr_idle_state);\n\n\tpca954x_cleanup(muxc);\n}\n\nstatic int pca954x_resume(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct i2c_mux_core *muxc = i2c_get_clientdata(client);\n\tstruct pca954x *data = i2c_mux_priv(muxc);\n\tint ret;\n\n\tret = pca954x_init(client, data);\n\tif (ret < 0)\n\t\tdev_err(&client->dev, \"failed to verify mux presence\\n\");\n\n\treturn ret;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(pca954x_pm, NULL, pca954x_resume);\n\nstatic struct i2c_driver pca954x_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"pca954x\",\n\t\t.pm\t= pm_sleep_ptr(&pca954x_pm),\n\t\t.of_match_table = pca954x_of_match,\n\t},\n\t.probe\t\t= pca954x_probe,\n\t.remove\t\t= pca954x_remove,\n\t.id_table\t= pca954x_id,\n};\n\nmodule_i2c_driver(pca954x_driver);\n\nMODULE_AUTHOR(\"Rodolfo Giometti <giometti@linux.it>\");\nMODULE_DESCRIPTION(\"PCA954x I2C mux/switch driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}