{
  "module_name": "i2c-versatile.c",
  "hash_id": "f934ae60228ad0e1ccadebf0c3c63cc9b90715cf6e207448019ac6870aff2a32",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-versatile.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/i2c.h>\n#include <linux/i2c-algo-bit.h>\n#include <linux/init.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n\n#define I2C_CONTROL\t0x00\n#define I2C_CONTROLS\t0x00\n#define I2C_CONTROLC\t0x04\n#define SCL\t\t(1 << 0)\n#define SDA\t\t(1 << 1)\n\nstruct i2c_versatile {\n\tstruct i2c_adapter\t adap;\n\tstruct i2c_algo_bit_data algo;\n\tvoid __iomem\t\t *base;\n};\n\nstatic void i2c_versatile_setsda(void *data, int state)\n{\n\tstruct i2c_versatile *i2c = data;\n\n\twritel(SDA, i2c->base + (state ? I2C_CONTROLS : I2C_CONTROLC));\n}\n\nstatic void i2c_versatile_setscl(void *data, int state)\n{\n\tstruct i2c_versatile *i2c = data;\n\n\twritel(SCL, i2c->base + (state ? I2C_CONTROLS : I2C_CONTROLC));\n}\n\nstatic int i2c_versatile_getsda(void *data)\n{\n\tstruct i2c_versatile *i2c = data;\n\treturn !!(readl(i2c->base + I2C_CONTROL) & SDA);\n}\n\nstatic int i2c_versatile_getscl(void *data)\n{\n\tstruct i2c_versatile *i2c = data;\n\treturn !!(readl(i2c->base + I2C_CONTROL) & SCL);\n}\n\nstatic const struct i2c_algo_bit_data i2c_versatile_algo = {\n\t.setsda\t= i2c_versatile_setsda,\n\t.setscl = i2c_versatile_setscl,\n\t.getsda\t= i2c_versatile_getsda,\n\t.getscl = i2c_versatile_getscl,\n\t.udelay\t= 30,\n\t.timeout = HZ,\n};\n\nstatic int i2c_versatile_probe(struct platform_device *dev)\n{\n\tstruct i2c_versatile *i2c;\n\tint ret;\n\n\ti2c = devm_kzalloc(&dev->dev, sizeof(struct i2c_versatile), GFP_KERNEL);\n\tif (!i2c)\n\t\treturn -ENOMEM;\n\n\ti2c->base = devm_platform_get_and_ioremap_resource(dev, 0, NULL);\n\tif (IS_ERR(i2c->base))\n\t\treturn PTR_ERR(i2c->base);\n\n\twritel(SCL | SDA, i2c->base + I2C_CONTROLS);\n\n\ti2c->adap.owner = THIS_MODULE;\n\tstrscpy(i2c->adap.name, \"Versatile I2C adapter\", sizeof(i2c->adap.name));\n\ti2c->adap.algo_data = &i2c->algo;\n\ti2c->adap.dev.parent = &dev->dev;\n\ti2c->adap.dev.of_node = dev->dev.of_node;\n\ti2c->algo = i2c_versatile_algo;\n\ti2c->algo.data = i2c;\n\n\ti2c->adap.nr = dev->id;\n\tret = i2c_bit_add_numbered_bus(&i2c->adap);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tplatform_set_drvdata(dev, i2c);\n\n\treturn 0;\n}\n\nstatic void i2c_versatile_remove(struct platform_device *dev)\n{\n\tstruct i2c_versatile *i2c = platform_get_drvdata(dev);\n\n\ti2c_del_adapter(&i2c->adap);\n}\n\nstatic const struct of_device_id i2c_versatile_match[] = {\n\t{ .compatible = \"arm,versatile-i2c\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, i2c_versatile_match);\n\nstatic struct platform_driver i2c_versatile_driver = {\n\t.probe\t\t= i2c_versatile_probe,\n\t.remove_new\t= i2c_versatile_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"versatile-i2c\",\n\t\t.of_match_table = i2c_versatile_match,\n\t},\n};\n\nstatic int __init i2c_versatile_init(void)\n{\n\treturn platform_driver_register(&i2c_versatile_driver);\n}\n\nstatic void __exit i2c_versatile_exit(void)\n{\n\tplatform_driver_unregister(&i2c_versatile_driver);\n}\n\nsubsys_initcall(i2c_versatile_init);\nmodule_exit(i2c_versatile_exit);\n\nMODULE_DESCRIPTION(\"ARM Versatile I2C bus driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:versatile-i2c\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}