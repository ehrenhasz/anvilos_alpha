{
  "module_name": "i2c-st.c",
  "hash_id": "de5d33aa68d7cea8ad59c9c986f7f2c270199217cc099c3a59f3a2b7a1ac59f3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-st.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/of.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/platform_device.h>\n\n \n#define SSC_BRG\t\t\t\t0x000\n#define SSC_TBUF\t\t\t0x004\n#define SSC_RBUF\t\t\t0x008\n#define SSC_CTL\t\t\t\t0x00C\n#define SSC_IEN\t\t\t\t0x010\n#define SSC_STA\t\t\t\t0x014\n#define SSC_I2C\t\t\t\t0x018\n#define SSC_SLAD\t\t\t0x01C\n#define SSC_REP_START_HOLD\t\t0x020\n#define SSC_START_HOLD\t\t\t0x024\n#define SSC_REP_START_SETUP\t\t0x028\n#define SSC_DATA_SETUP\t\t\t0x02C\n#define SSC_STOP_SETUP\t\t\t0x030\n#define SSC_BUS_FREE\t\t\t0x034\n#define SSC_TX_FSTAT\t\t\t0x038\n#define SSC_RX_FSTAT\t\t\t0x03C\n#define SSC_PRE_SCALER_BRG\t\t0x040\n#define SSC_CLR\t\t\t\t0x080\n#define SSC_NOISE_SUPP_WIDTH\t\t0x100\n#define SSC_PRSCALER\t\t\t0x104\n#define SSC_NOISE_SUPP_WIDTH_DATAOUT\t0x108\n#define SSC_PRSCALER_DATAOUT\t\t0x10c\n\n \n#define SSC_CTL_DATA_WIDTH_9\t\t0x8\n#define SSC_CTL_DATA_WIDTH_MSK\t\t0xf\n#define SSC_CTL_BM\t\t\t0xf\n#define SSC_CTL_HB\t\t\tBIT(4)\n#define SSC_CTL_PH\t\t\tBIT(5)\n#define SSC_CTL_PO\t\t\tBIT(6)\n#define SSC_CTL_SR\t\t\tBIT(7)\n#define SSC_CTL_MS\t\t\tBIT(8)\n#define SSC_CTL_EN\t\t\tBIT(9)\n#define SSC_CTL_LPB\t\t\tBIT(10)\n#define SSC_CTL_EN_TX_FIFO\t\tBIT(11)\n#define SSC_CTL_EN_RX_FIFO\t\tBIT(12)\n#define SSC_CTL_EN_CLST_RX\t\tBIT(13)\n\n \n#define SSC_IEN_RIEN\t\t\tBIT(0)\n#define SSC_IEN_TIEN\t\t\tBIT(1)\n#define SSC_IEN_TEEN\t\t\tBIT(2)\n#define SSC_IEN_REEN\t\t\tBIT(3)\n#define SSC_IEN_PEEN\t\t\tBIT(4)\n#define SSC_IEN_AASEN\t\t\tBIT(6)\n#define SSC_IEN_STOPEN\t\t\tBIT(7)\n#define SSC_IEN_ARBLEN\t\t\tBIT(8)\n#define SSC_IEN_NACKEN\t\t\tBIT(10)\n#define SSC_IEN_REPSTRTEN\t\tBIT(11)\n#define SSC_IEN_TX_FIFO_HALF\t\tBIT(12)\n#define SSC_IEN_RX_FIFO_HALF_FULL\tBIT(14)\n\n \n#define SSC_STA_RIR\t\t\tBIT(0)\n#define SSC_STA_TIR\t\t\tBIT(1)\n#define SSC_STA_TE\t\t\tBIT(2)\n#define SSC_STA_RE\t\t\tBIT(3)\n#define SSC_STA_PE\t\t\tBIT(4)\n#define SSC_STA_CLST\t\t\tBIT(5)\n#define SSC_STA_AAS\t\t\tBIT(6)\n#define SSC_STA_STOP\t\t\tBIT(7)\n#define SSC_STA_ARBL\t\t\tBIT(8)\n#define SSC_STA_BUSY\t\t\tBIT(9)\n#define SSC_STA_NACK\t\t\tBIT(10)\n#define SSC_STA_REPSTRT\t\t\tBIT(11)\n#define SSC_STA_TX_FIFO_HALF\t\tBIT(12)\n#define SSC_STA_TX_FIFO_FULL\t\tBIT(13)\n#define SSC_STA_RX_FIFO_HALF\t\tBIT(14)\n\n \n#define SSC_I2C_I2CM\t\t\tBIT(0)\n#define SSC_I2C_STRTG\t\t\tBIT(1)\n#define SSC_I2C_STOPG\t\t\tBIT(2)\n#define SSC_I2C_ACKG\t\t\tBIT(3)\n#define SSC_I2C_AD10\t\t\tBIT(4)\n#define SSC_I2C_TXENB\t\t\tBIT(5)\n#define SSC_I2C_REPSTRTG\t\tBIT(11)\n#define SSC_I2C_SLAVE_DISABLE\t\tBIT(12)\n\n \n#define SSC_TX_FSTAT_STATUS\t\t0x07\n\n \n#define SSC_RX_FSTAT_STATUS\t\t0x07\n\n \n#define SSC_CLR_SSCAAS\t\t\tBIT(6)\n#define SSC_CLR_SSCSTOP\t\t\tBIT(7)\n#define SSC_CLR_SSCARBL\t\t\tBIT(8)\n#define SSC_CLR_NACK\t\t\tBIT(10)\n#define SSC_CLR_REPSTRT\t\t\tBIT(11)\n\n \n#define SSC_PRSC_VALUE\t\t\t0x0f\n\n\n#define SSC_TXFIFO_SIZE\t\t\t0x8\n#define SSC_RXFIFO_SIZE\t\t\t0x8\n\nenum st_i2c_mode {\n\tI2C_MODE_STANDARD,\n\tI2C_MODE_FAST,\n\tI2C_MODE_END,\n};\n\n \nstruct st_i2c_timings {\n\tu32 rate;\n\tu32 rep_start_hold;\n\tu32 rep_start_setup;\n\tu32 start_hold;\n\tu32 data_setup_time;\n\tu32 stop_setup_time;\n\tu32 bus_free_time;\n\tu32 sda_pulse_min_limit;\n};\n\n \nstruct st_i2c_client {\n\tu8\taddr;\n\tu32\tcount;\n\tu32\txfered;\n\tu8\t*buf;\n\tint\tresult;\n\tbool\tstop;\n};\n\n \nstruct st_i2c_dev {\n\tstruct i2c_adapter\tadap;\n\tstruct device\t\t*dev;\n\tvoid __iomem\t\t*base;\n\tstruct completion\tcomplete;\n\tint\t\t\tirq;\n\tstruct clk\t\t*clk;\n\tint\t\t\tmode;\n\tu32\t\t\tscl_min_width_us;\n\tu32\t\t\tsda_min_width_us;\n\tstruct st_i2c_client\tclient;\n\tbool\t\t\tbusy;\n};\n\nstatic inline void st_i2c_set_bits(void __iomem *reg, u32 mask)\n{\n\twritel_relaxed(readl_relaxed(reg) | mask, reg);\n}\n\nstatic inline void st_i2c_clr_bits(void __iomem *reg, u32 mask)\n{\n\twritel_relaxed(readl_relaxed(reg) & ~mask, reg);\n}\n\n \nstatic struct st_i2c_timings i2c_timings[] = {\n\t[I2C_MODE_STANDARD] = {\n\t\t.rate\t\t\t= I2C_MAX_STANDARD_MODE_FREQ,\n\t\t.rep_start_hold\t\t= 4400,\n\t\t.rep_start_setup\t= 5170,\n\t\t.start_hold\t\t= 4400,\n\t\t.data_setup_time\t= 275,\n\t\t.stop_setup_time\t= 4400,\n\t\t.bus_free_time\t\t= 5170,\n\t},\n\t[I2C_MODE_FAST] = {\n\t\t.rate\t\t\t= I2C_MAX_FAST_MODE_FREQ,\n\t\t.rep_start_hold\t\t= 660,\n\t\t.rep_start_setup\t= 660,\n\t\t.start_hold\t\t= 660,\n\t\t.data_setup_time\t= 110,\n\t\t.stop_setup_time\t= 660,\n\t\t.bus_free_time\t\t= 1430,\n\t},\n};\n\nstatic void st_i2c_flush_rx_fifo(struct st_i2c_dev *i2c_dev)\n{\n\tint count, i;\n\n\t \n\tif (readl_relaxed(i2c_dev->base + SSC_STA) & SSC_STA_RIR)\n\t\tcount = SSC_RXFIFO_SIZE;\n\telse\n\t\tcount = readl_relaxed(i2c_dev->base + SSC_RX_FSTAT) &\n\t\t\tSSC_RX_FSTAT_STATUS;\n\n\tfor (i = 0; i < count; i++)\n\t\treadl_relaxed(i2c_dev->base + SSC_RBUF);\n}\n\nstatic void st_i2c_soft_reset(struct st_i2c_dev *i2c_dev)\n{\n\t \n\tst_i2c_flush_rx_fifo(i2c_dev);\n\n\tst_i2c_set_bits(i2c_dev->base + SSC_CTL, SSC_CTL_SR);\n\tst_i2c_clr_bits(i2c_dev->base + SSC_CTL, SSC_CTL_SR);\n}\n\n \nstatic void st_i2c_hw_config(struct st_i2c_dev *i2c_dev)\n{\n\tunsigned long rate;\n\tu32 val, ns_per_clk;\n\tstruct st_i2c_timings *t = &i2c_timings[i2c_dev->mode];\n\n\tst_i2c_soft_reset(i2c_dev);\n\n\tval = SSC_CLR_REPSTRT | SSC_CLR_NACK | SSC_CLR_SSCARBL |\n\t\tSSC_CLR_SSCAAS | SSC_CLR_SSCSTOP;\n\twritel_relaxed(val, i2c_dev->base + SSC_CLR);\n\n\t \n\tval = SSC_CTL_PO | SSC_CTL_PH | SSC_CTL_HB | SSC_CTL_DATA_WIDTH_9;\n\twritel_relaxed(val, i2c_dev->base + SSC_CTL);\n\n\trate = clk_get_rate(i2c_dev->clk);\n\tns_per_clk = 1000000000 / rate;\n\n\t \n\tval = rate / (2 * t->rate);\n\twritel_relaxed(val, i2c_dev->base + SSC_BRG);\n\n\t \n\twritel_relaxed(1, i2c_dev->base + SSC_PRE_SCALER_BRG);\n\n\t \n\twritel_relaxed(SSC_I2C_I2CM, i2c_dev->base + SSC_I2C);\n\n\t \n\tval = t->rep_start_hold / ns_per_clk;\n\twritel_relaxed(val, i2c_dev->base + SSC_REP_START_HOLD);\n\n\t \n\tval = t->rep_start_setup / ns_per_clk;\n\twritel_relaxed(val, i2c_dev->base + SSC_REP_START_SETUP);\n\n\t \n\tval = t->start_hold / ns_per_clk;\n\twritel_relaxed(val, i2c_dev->base + SSC_START_HOLD);\n\n\t \n\tval = t->data_setup_time / ns_per_clk;\n\twritel_relaxed(val, i2c_dev->base + SSC_DATA_SETUP);\n\n\t \n\tval = t->stop_setup_time / ns_per_clk;\n\twritel_relaxed(val, i2c_dev->base + SSC_STOP_SETUP);\n\n\t \n\tval = t->bus_free_time / ns_per_clk;\n\twritel_relaxed(val, i2c_dev->base + SSC_BUS_FREE);\n\n\t \n\tval = rate / 10000000;\n\twritel_relaxed(val, i2c_dev->base + SSC_PRSCALER);\n\twritel_relaxed(val, i2c_dev->base + SSC_PRSCALER_DATAOUT);\n\n\t \n\tval = i2c_dev->scl_min_width_us * rate / 100000000;\n\twritel_relaxed(val, i2c_dev->base + SSC_NOISE_SUPP_WIDTH);\n\n\t \n\tval = i2c_dev->sda_min_width_us * rate / 100000000;\n\twritel_relaxed(val, i2c_dev->base + SSC_NOISE_SUPP_WIDTH_DATAOUT);\n}\n\nstatic int st_i2c_recover_bus(struct i2c_adapter *i2c_adap)\n{\n\tstruct st_i2c_dev *i2c_dev = i2c_get_adapdata(i2c_adap);\n\tu32 ctl;\n\n\tdev_dbg(i2c_dev->dev, \"Trying to recover bus\\n\");\n\n\t \n\n\t \n\twritel_relaxed(0, i2c_dev->base + SSC_IEN);\n\n\tst_i2c_hw_config(i2c_dev);\n\n\tctl = SSC_CTL_EN | SSC_CTL_MS |\tSSC_CTL_EN_RX_FIFO | SSC_CTL_EN_TX_FIFO;\n\tst_i2c_set_bits(i2c_dev->base + SSC_CTL, ctl);\n\n\tst_i2c_clr_bits(i2c_dev->base + SSC_I2C, SSC_I2C_I2CM);\n\tusleep_range(8000, 10000);\n\n\twritel_relaxed(0, i2c_dev->base + SSC_TBUF);\n\tusleep_range(2000, 4000);\n\tst_i2c_set_bits(i2c_dev->base + SSC_I2C, SSC_I2C_I2CM);\n\n\treturn 0;\n}\n\nstatic int st_i2c_wait_free_bus(struct st_i2c_dev *i2c_dev)\n{\n\tu32 sta;\n\tint i, ret;\n\n\tfor (i = 0; i < 10; i++) {\n\t\tsta = readl_relaxed(i2c_dev->base + SSC_STA);\n\t\tif (!(sta & SSC_STA_BUSY))\n\t\t\treturn 0;\n\n\t\tusleep_range(2000, 4000);\n\t}\n\n\tdev_err(i2c_dev->dev, \"bus not free (status = 0x%08x)\\n\", sta);\n\n\tret = i2c_recover_bus(&i2c_dev->adap);\n\tif (ret) {\n\t\tdev_err(i2c_dev->dev, \"Failed to recover the bus (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn -EBUSY;\n}\n\n \nstatic inline void st_i2c_write_tx_fifo(struct st_i2c_dev *i2c_dev, u8 byte)\n{\n\tu16 tbuf = byte << 1;\n\n\twritel_relaxed(tbuf | 1, i2c_dev->base + SSC_TBUF);\n}\n\n \nstatic void st_i2c_wr_fill_tx_fifo(struct st_i2c_dev *i2c_dev)\n{\n\tstruct st_i2c_client *c = &i2c_dev->client;\n\tu32 tx_fstat, sta;\n\tint i;\n\n\tsta = readl_relaxed(i2c_dev->base + SSC_STA);\n\tif (sta & SSC_STA_TX_FIFO_FULL)\n\t\treturn;\n\n\ttx_fstat = readl_relaxed(i2c_dev->base + SSC_TX_FSTAT);\n\ttx_fstat &= SSC_TX_FSTAT_STATUS;\n\n\tif (c->count < (SSC_TXFIFO_SIZE - tx_fstat))\n\t\ti = c->count;\n\telse\n\t\ti = SSC_TXFIFO_SIZE - tx_fstat;\n\n\tfor (; i > 0; i--, c->count--, c->buf++)\n\t\tst_i2c_write_tx_fifo(i2c_dev, *c->buf);\n}\n\n \nstatic void st_i2c_rd_fill_tx_fifo(struct st_i2c_dev *i2c_dev, int max)\n{\n\tstruct st_i2c_client *c = &i2c_dev->client;\n\tu32 tx_fstat, sta;\n\tint i;\n\n\tsta = readl_relaxed(i2c_dev->base + SSC_STA);\n\tif (sta & SSC_STA_TX_FIFO_FULL)\n\t\treturn;\n\n\ttx_fstat = readl_relaxed(i2c_dev->base + SSC_TX_FSTAT);\n\ttx_fstat &= SSC_TX_FSTAT_STATUS;\n\n\tif (max < (SSC_TXFIFO_SIZE - tx_fstat))\n\t\ti = max;\n\telse\n\t\ti = SSC_TXFIFO_SIZE - tx_fstat;\n\n\tfor (; i > 0; i--, c->xfered++)\n\t\tst_i2c_write_tx_fifo(i2c_dev, 0xff);\n}\n\nstatic void st_i2c_read_rx_fifo(struct st_i2c_dev *i2c_dev)\n{\n\tstruct st_i2c_client *c = &i2c_dev->client;\n\tu32 i, sta;\n\tu16 rbuf;\n\n\tsta = readl_relaxed(i2c_dev->base + SSC_STA);\n\tif (sta & SSC_STA_RIR) {\n\t\ti = SSC_RXFIFO_SIZE;\n\t} else {\n\t\ti = readl_relaxed(i2c_dev->base + SSC_RX_FSTAT);\n\t\ti &= SSC_RX_FSTAT_STATUS;\n\t}\n\n\tfor (; (i > 0) && (c->count > 0); i--, c->count--) {\n\t\trbuf = readl_relaxed(i2c_dev->base + SSC_RBUF) >> 1;\n\t\t*c->buf++ = (u8)rbuf & 0xff;\n\t}\n\n\tif (i) {\n\t\tdev_err(i2c_dev->dev, \"Unexpected %d bytes in rx fifo\\n\", i);\n\t\tst_i2c_flush_rx_fifo(i2c_dev);\n\t}\n}\n\n \nstatic void st_i2c_terminate_xfer(struct st_i2c_dev *i2c_dev)\n{\n\tstruct st_i2c_client *c = &i2c_dev->client;\n\n\tst_i2c_clr_bits(i2c_dev->base + SSC_IEN, SSC_IEN_TEEN);\n\tst_i2c_clr_bits(i2c_dev->base + SSC_I2C, SSC_I2C_STRTG);\n\n\tif (c->stop) {\n\t\tst_i2c_set_bits(i2c_dev->base + SSC_IEN, SSC_IEN_STOPEN);\n\t\tst_i2c_set_bits(i2c_dev->base + SSC_I2C, SSC_I2C_STOPG);\n\t} else {\n\t\tst_i2c_set_bits(i2c_dev->base + SSC_IEN, SSC_IEN_REPSTRTEN);\n\t\tst_i2c_set_bits(i2c_dev->base + SSC_I2C, SSC_I2C_REPSTRTG);\n\t}\n}\n\n \nstatic void st_i2c_handle_write(struct st_i2c_dev *i2c_dev)\n{\n\tstruct st_i2c_client *c = &i2c_dev->client;\n\n\tst_i2c_flush_rx_fifo(i2c_dev);\n\n\tif (!c->count)\n\t\t \n\t\tst_i2c_terminate_xfer(i2c_dev);\n\telse\n\t\tst_i2c_wr_fill_tx_fifo(i2c_dev);\n}\n\n \nstatic void st_i2c_handle_read(struct st_i2c_dev *i2c_dev)\n{\n\tstruct st_i2c_client *c = &i2c_dev->client;\n\tu32 ien;\n\n\t \n\tif (!c->xfered) {\n\t\treadl_relaxed(i2c_dev->base + SSC_RBUF);\n\t\tst_i2c_clr_bits(i2c_dev->base + SSC_I2C, SSC_I2C_TXENB);\n\t} else {\n\t\tst_i2c_read_rx_fifo(i2c_dev);\n\t}\n\n\tif (!c->count) {\n\t\t \n\t\tst_i2c_terminate_xfer(i2c_dev);\n\t} else if (c->count == 1) {\n\t\t \n\t\tst_i2c_clr_bits(i2c_dev->base + SSC_I2C, SSC_I2C_ACKG);\n\n\t\t \n\t\tien = SSC_IEN_NACKEN | SSC_IEN_ARBLEN;\n\t\twritel_relaxed(ien, i2c_dev->base + SSC_IEN);\n\n\t\tst_i2c_rd_fill_tx_fifo(i2c_dev, c->count);\n\t} else {\n\t\tst_i2c_rd_fill_tx_fifo(i2c_dev, c->count - 1);\n\t}\n}\n\n \nstatic irqreturn_t st_i2c_isr_thread(int irq, void *data)\n{\n\tstruct st_i2c_dev *i2c_dev = data;\n\tstruct st_i2c_client *c = &i2c_dev->client;\n\tu32 sta, ien;\n\tint it;\n\n\tien = readl_relaxed(i2c_dev->base + SSC_IEN);\n\tsta = readl_relaxed(i2c_dev->base + SSC_STA);\n\n\t \n\tit = __fls(sta & ien);\n\tif (it < 0) {\n\t\tdev_dbg(i2c_dev->dev, \"spurious it (sta=0x%04x, ien=0x%04x)\\n\",\n\t\t\t\tsta, ien);\n\t\treturn IRQ_NONE;\n\t}\n\n\tswitch (1 << it) {\n\tcase SSC_STA_TE:\n\t\tif (c->addr & I2C_M_RD)\n\t\t\tst_i2c_handle_read(i2c_dev);\n\t\telse\n\t\t\tst_i2c_handle_write(i2c_dev);\n\t\tbreak;\n\n\tcase SSC_STA_STOP:\n\tcase SSC_STA_REPSTRT:\n\t\twritel_relaxed(0, i2c_dev->base + SSC_IEN);\n\t\tcomplete(&i2c_dev->complete);\n\t\tbreak;\n\n\tcase SSC_STA_NACK:\n\t\twritel_relaxed(SSC_CLR_NACK, i2c_dev->base + SSC_CLR);\n\n\t\t \n\t\tif ((c->addr & I2C_M_RD) && (c->count == 1) && (c->xfered)) {\n\t\t\tst_i2c_handle_read(i2c_dev);\n\t\t\tbreak;\n\t\t}\n\n\t\tit = SSC_IEN_STOPEN | SSC_IEN_ARBLEN;\n\t\twritel_relaxed(it, i2c_dev->base + SSC_IEN);\n\n\t\tst_i2c_set_bits(i2c_dev->base + SSC_I2C, SSC_I2C_STOPG);\n\t\tc->result = -EIO;\n\t\tbreak;\n\n\tcase SSC_STA_ARBL:\n\t\twritel_relaxed(SSC_CLR_SSCARBL, i2c_dev->base + SSC_CLR);\n\n\t\tit = SSC_IEN_STOPEN | SSC_IEN_ARBLEN;\n\t\twritel_relaxed(it, i2c_dev->base + SSC_IEN);\n\n\t\tst_i2c_set_bits(i2c_dev->base + SSC_I2C, SSC_I2C_STOPG);\n\t\tc->result = -EAGAIN;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(i2c_dev->dev,\n\t\t\t\t\"it %d unhandled (sta=0x%04x)\\n\", it, sta);\n\t}\n\n\t \n\treadl(i2c_dev->base + SSC_IEN);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic int st_i2c_xfer_msg(struct st_i2c_dev *i2c_dev, struct i2c_msg *msg,\n\t\t\t    bool is_first, bool is_last)\n{\n\tstruct st_i2c_client *c = &i2c_dev->client;\n\tu32 ctl, i2c, it;\n\tunsigned long timeout;\n\tint ret;\n\n\tc->addr\t\t= i2c_8bit_addr_from_msg(msg);\n\tc->buf\t\t= msg->buf;\n\tc->count\t= msg->len;\n\tc->xfered\t= 0;\n\tc->result\t= 0;\n\tc->stop\t\t= is_last;\n\n\treinit_completion(&i2c_dev->complete);\n\n\tctl = SSC_CTL_EN | SSC_CTL_MS |\tSSC_CTL_EN_RX_FIFO | SSC_CTL_EN_TX_FIFO;\n\tst_i2c_set_bits(i2c_dev->base + SSC_CTL, ctl);\n\n\ti2c = SSC_I2C_TXENB;\n\tif (c->addr & I2C_M_RD)\n\t\ti2c |= SSC_I2C_ACKG;\n\tst_i2c_set_bits(i2c_dev->base + SSC_I2C, i2c);\n\n\t \n\tst_i2c_write_tx_fifo(i2c_dev, c->addr);\n\n\t \n\tif (!(c->addr & I2C_M_RD))\n\t\tst_i2c_wr_fill_tx_fifo(i2c_dev);\n\n\tit = SSC_IEN_NACKEN | SSC_IEN_TEEN | SSC_IEN_ARBLEN;\n\twritel_relaxed(it, i2c_dev->base + SSC_IEN);\n\n\tif (is_first) {\n\t\tret = st_i2c_wait_free_bus(i2c_dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tst_i2c_set_bits(i2c_dev->base + SSC_I2C, SSC_I2C_STRTG);\n\t}\n\n\ttimeout = wait_for_completion_timeout(&i2c_dev->complete,\n\t\t\ti2c_dev->adap.timeout);\n\tret = c->result;\n\n\tif (!timeout) {\n\t\tdev_err(i2c_dev->dev, \"Write to slave 0x%x timed out\\n\",\n\t\t\t\tc->addr);\n\t\tret = -ETIMEDOUT;\n\t}\n\n\ti2c = SSC_I2C_STOPG | SSC_I2C_REPSTRTG;\n\tst_i2c_clr_bits(i2c_dev->base + SSC_I2C, i2c);\n\n\twritel_relaxed(SSC_CLR_SSCSTOP | SSC_CLR_REPSTRT,\n\t\t\ti2c_dev->base + SSC_CLR);\n\n\treturn ret;\n}\n\n \nstatic int st_i2c_xfer(struct i2c_adapter *i2c_adap,\n\t\t\tstruct i2c_msg msgs[], int num)\n{\n\tstruct st_i2c_dev *i2c_dev = i2c_get_adapdata(i2c_adap);\n\tint ret, i;\n\n\ti2c_dev->busy = true;\n\n\tret = clk_prepare_enable(i2c_dev->clk);\n\tif (ret) {\n\t\tdev_err(i2c_dev->dev, \"Failed to prepare_enable clock\\n\");\n\t\treturn ret;\n\t}\n\n\tpinctrl_pm_select_default_state(i2c_dev->dev);\n\n\tst_i2c_hw_config(i2c_dev);\n\n\tfor (i = 0; (i < num) && !ret; i++)\n\t\tret = st_i2c_xfer_msg(i2c_dev, &msgs[i], i == 0, i == num - 1);\n\n\tpinctrl_pm_select_idle_state(i2c_dev->dev);\n\n\tclk_disable_unprepare(i2c_dev->clk);\n\n\ti2c_dev->busy = false;\n\n\treturn (ret < 0) ? ret : i;\n}\n\nstatic int st_i2c_suspend(struct device *dev)\n{\n\tstruct st_i2c_dev *i2c_dev = dev_get_drvdata(dev);\n\n\tif (i2c_dev->busy)\n\t\treturn -EBUSY;\n\n\tpinctrl_pm_select_sleep_state(dev);\n\n\treturn 0;\n}\n\nstatic int st_i2c_resume(struct device *dev)\n{\n\tpinctrl_pm_select_default_state(dev);\n\t \n\tpinctrl_pm_select_idle_state(dev);\n\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(st_i2c_pm, st_i2c_suspend, st_i2c_resume);\n\nstatic u32 st_i2c_func(struct i2c_adapter *adap)\n{\n\treturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;\n}\n\nstatic const struct i2c_algorithm st_i2c_algo = {\n\t.master_xfer = st_i2c_xfer,\n\t.functionality = st_i2c_func,\n};\n\nstatic struct i2c_bus_recovery_info st_i2c_recovery_info = {\n\t.recover_bus = st_i2c_recover_bus,\n};\n\nstatic int st_i2c_of_get_deglitch(struct device_node *np,\n\t\tstruct st_i2c_dev *i2c_dev)\n{\n\tint ret;\n\n\tret = of_property_read_u32(np, \"st,i2c-min-scl-pulse-width-us\",\n\t\t\t&i2c_dev->scl_min_width_us);\n\tif ((ret == -ENODATA) || (ret == -EOVERFLOW)) {\n\t\tdev_err(i2c_dev->dev, \"st,i2c-min-scl-pulse-width-us invalid\\n\");\n\t\treturn ret;\n\t}\n\n\tret = of_property_read_u32(np, \"st,i2c-min-sda-pulse-width-us\",\n\t\t\t&i2c_dev->sda_min_width_us);\n\tif ((ret == -ENODATA) || (ret == -EOVERFLOW)) {\n\t\tdev_err(i2c_dev->dev, \"st,i2c-min-sda-pulse-width-us invalid\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int st_i2c_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct st_i2c_dev *i2c_dev;\n\tstruct resource *res;\n\tu32 clk_rate;\n\tstruct i2c_adapter *adap;\n\tint ret;\n\n\ti2c_dev = devm_kzalloc(&pdev->dev, sizeof(*i2c_dev), GFP_KERNEL);\n\tif (!i2c_dev)\n\t\treturn -ENOMEM;\n\n\ti2c_dev->base = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(i2c_dev->base))\n\t\treturn PTR_ERR(i2c_dev->base);\n\n\ti2c_dev->irq = irq_of_parse_and_map(np, 0);\n\tif (!i2c_dev->irq) {\n\t\tdev_err(&pdev->dev, \"IRQ missing or invalid\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\ti2c_dev->clk = of_clk_get_by_name(np, \"ssc\");\n\tif (IS_ERR(i2c_dev->clk)) {\n\t\tdev_err(&pdev->dev, \"Unable to request clock\\n\");\n\t\treturn PTR_ERR(i2c_dev->clk);\n\t}\n\n\ti2c_dev->mode = I2C_MODE_STANDARD;\n\tret = of_property_read_u32(np, \"clock-frequency\", &clk_rate);\n\tif (!ret && (clk_rate == I2C_MAX_FAST_MODE_FREQ))\n\t\ti2c_dev->mode = I2C_MODE_FAST;\n\n\ti2c_dev->dev = &pdev->dev;\n\n\tret = devm_request_threaded_irq(&pdev->dev, i2c_dev->irq,\n\t\t\tNULL, st_i2c_isr_thread,\n\t\t\tIRQF_ONESHOT, pdev->name, i2c_dev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed to request irq %i\\n\", i2c_dev->irq);\n\t\treturn ret;\n\t}\n\n\tpinctrl_pm_select_default_state(i2c_dev->dev);\n\t \n\tpinctrl_pm_select_idle_state(i2c_dev->dev);\n\n\tret = st_i2c_of_get_deglitch(np, i2c_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tadap = &i2c_dev->adap;\n\ti2c_set_adapdata(adap, i2c_dev);\n\tsnprintf(adap->name, sizeof(adap->name), \"ST I2C(%pa)\", &res->start);\n\tadap->owner = THIS_MODULE;\n\tadap->timeout = 2 * HZ;\n\tadap->retries = 0;\n\tadap->algo = &st_i2c_algo;\n\tadap->bus_recovery_info = &st_i2c_recovery_info;\n\tadap->dev.parent = &pdev->dev;\n\tadap->dev.of_node = pdev->dev.of_node;\n\n\tinit_completion(&i2c_dev->complete);\n\n\tret = i2c_add_adapter(adap);\n\tif (ret)\n\t\treturn ret;\n\n\tplatform_set_drvdata(pdev, i2c_dev);\n\n\tdev_info(i2c_dev->dev, \"%s initialized\\n\", adap->name);\n\n\treturn 0;\n}\n\nstatic void st_i2c_remove(struct platform_device *pdev)\n{\n\tstruct st_i2c_dev *i2c_dev = platform_get_drvdata(pdev);\n\n\ti2c_del_adapter(&i2c_dev->adap);\n}\n\nstatic const struct of_device_id st_i2c_match[] = {\n\t{ .compatible = \"st,comms-ssc-i2c\", },\n\t{ .compatible = \"st,comms-ssc4-i2c\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, st_i2c_match);\n\nstatic struct platform_driver st_i2c_driver = {\n\t.driver = {\n\t\t.name = \"st-i2c\",\n\t\t.of_match_table = st_i2c_match,\n\t\t.pm = pm_sleep_ptr(&st_i2c_pm),\n\t},\n\t.probe = st_i2c_probe,\n\t.remove_new = st_i2c_remove,\n};\n\nmodule_platform_driver(st_i2c_driver);\n\nMODULE_AUTHOR(\"Maxime Coquelin <maxime.coquelin@st.com>\");\nMODULE_DESCRIPTION(\"STMicroelectronics I2C driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}