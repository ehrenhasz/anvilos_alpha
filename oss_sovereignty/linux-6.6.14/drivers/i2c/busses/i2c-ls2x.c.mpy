{
  "module_name": "i2c-ls2x.c",
  "hash_id": "e00d63f0ff918b9860212609df4c8ee9757c64fe6ea4c320fabc539f72234d98",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-ls2x.c",
  "human_readable_source": "\n \n\n#include <linux/bits.h>\n#include <linux/completion.h>\n#include <linux/device.h>\n#include <linux/iopoll.h>\n#include <linux/i2c.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pm_runtime.h>\n#include <linux/platform_device.h>\n#include <linux/property.h>\n#include <linux/units.h>\n\n \n#define I2C_LS2X_PRER\t\t0x0  \n#define I2C_LS2X_CTR\t\t0x2  \n#define I2C_LS2X_TXR\t\t0x3  \n#define I2C_LS2X_RXR\t\t0x3  \n#define I2C_LS2X_CR\t\t0x4  \n#define I2C_LS2X_SR\t\t0x4  \n\n \n#define LS2X_CR_START\t\tBIT(7)  \n#define LS2X_CR_STOP\t\tBIT(6)  \n#define LS2X_CR_READ\t\tBIT(5)  \n#define LS2X_CR_WRITE\t\tBIT(4)  \n#define LS2X_CR_ACK\t\tBIT(3)  \n#define LS2X_CR_IACK\t\tBIT(0)  \n\n \n#define LS2X_SR_NOACK\t\tBIT(7)  \n#define LS2X_SR_BUSY\t\tBIT(6)  \n#define LS2X_SR_AL\t\tBIT(5)  \n#define LS2X_SR_TIP\t\tBIT(1)  \n#define LS2X_SR_IF\t\tBIT(0)  \n\n \n#define LS2X_CTR_EN\t\tBIT(7)  \n#define LS2X_CTR_IEN\t\tBIT(6)  \n#define LS2X_CTR_MST\t\tBIT(5)  \n#define CTR_FREQ_MASK\t\tGENMASK(7, 6)\n#define CTR_READY_MASK\t\tGENMASK(7, 5)\n\n \n#define LS2X_I2C_PCLK_FREQ\t(50 * HZ_PER_MHZ)\n\n \n#define LS2X_I2C_FREQ_STD\t(33 * HZ_PER_KHZ)\n\nstruct ls2x_i2c_priv {\n\tstruct i2c_adapter\tadapter;\n\tvoid __iomem\t\t*base;\n\tstruct i2c_timings\ti2c_t;\n\tstruct completion\tcmd_complete;\n};\n\n \nstatic irqreturn_t ls2x_i2c_isr(int this_irq, void *dev_id)\n{\n\tstruct ls2x_i2c_priv *priv = dev_id;\n\n\tif (!(readb(priv->base + I2C_LS2X_SR) & LS2X_SR_IF))\n\t\treturn IRQ_NONE;\n\n\twriteb(LS2X_CR_IACK, priv->base + I2C_LS2X_CR);\n\tcomplete(&priv->cmd_complete);\n\treturn IRQ_HANDLED;\n}\n\n \nstatic void ls2x_i2c_adjust_bus_speed(struct ls2x_i2c_priv *priv)\n{\n\tstruct i2c_timings *t = &priv->i2c_t;\n\tstruct device *dev = priv->adapter.dev.parent;\n\tu32 acpi_speed = i2c_acpi_find_bus_speed(dev);\n\n\ti2c_parse_fw_timings(dev, t, false);\n\n\tif (acpi_speed || t->bus_freq_hz)\n\t\tt->bus_freq_hz = max(t->bus_freq_hz, acpi_speed);\n\telse\n\t\tt->bus_freq_hz = LS2X_I2C_FREQ_STD;\n\n\t \n\twritew(LS2X_I2C_PCLK_FREQ / (5 * t->bus_freq_hz) - 1,\n\t       priv->base + I2C_LS2X_PRER);\n}\n\nstatic void ls2x_i2c_init(struct ls2x_i2c_priv *priv)\n{\n\t \n\twriteb(readb(priv->base + I2C_LS2X_CTR) & ~CTR_FREQ_MASK,\n\t       priv->base + I2C_LS2X_CTR);\n\n\tls2x_i2c_adjust_bus_speed(priv);\n\n\t \n\twriteb(readb(priv->base + I2C_LS2X_CTR) | CTR_READY_MASK,\n\t       priv->base + I2C_LS2X_CTR);\n}\n\nstatic int ls2x_i2c_xfer_byte(struct ls2x_i2c_priv *priv, u8 txdata, u8 *rxdatap)\n{\n\tu8 rxdata;\n\tunsigned long time_left;\n\n\twriteb(txdata, priv->base + I2C_LS2X_CR);\n\n\ttime_left = wait_for_completion_timeout(&priv->cmd_complete,\n\t\t\t\t\t\tpriv->adapter.timeout);\n\tif (!time_left)\n\t\treturn -ETIMEDOUT;\n\n\trxdata = readb(priv->base + I2C_LS2X_SR);\n\tif (rxdatap)\n\t\t*rxdatap = rxdata;\n\n\treturn 0;\n}\n\nstatic int ls2x_i2c_send_byte(struct ls2x_i2c_priv *priv, u8 txdata)\n{\n\tint ret;\n\tu8 rxdata;\n\n\tret = ls2x_i2c_xfer_byte(priv, txdata, &rxdata);\n\tif (ret)\n\t\treturn ret;\n\n\tif (rxdata & LS2X_SR_AL)\n\t\treturn -EAGAIN;\n\n\tif (rxdata & LS2X_SR_NOACK)\n\t\treturn -ENXIO;\n\n\treturn 0;\n}\n\nstatic int ls2x_i2c_stop(struct ls2x_i2c_priv *priv)\n{\n\tu8 value;\n\n\twriteb(LS2X_CR_STOP, priv->base + I2C_LS2X_CR);\n\treturn readb_poll_timeout(priv->base + I2C_LS2X_SR, value,\n\t\t\t\t  !(value & LS2X_SR_BUSY), 100,\n\t\t\t\t  jiffies_to_usecs(priv->adapter.timeout));\n}\n\nstatic int ls2x_i2c_start(struct ls2x_i2c_priv *priv, struct i2c_msg *msgs)\n{\n\treinit_completion(&priv->cmd_complete);\n\n\twriteb(i2c_8bit_addr_from_msg(msgs), priv->base + I2C_LS2X_TXR);\n\treturn ls2x_i2c_send_byte(priv, LS2X_CR_START | LS2X_CR_WRITE);\n}\n\nstatic int ls2x_i2c_rx(struct ls2x_i2c_priv *priv, struct i2c_msg *msg)\n{\n\tint ret;\n\tu8 rxdata, *buf = msg->buf;\n\tu16 len = msg->len;\n\n\t \n\tret = ls2x_i2c_start(priv, msg);\n\tif (ret)\n\t\treturn ret;\n\n\twhile (len--) {\n\t\tret = ls2x_i2c_xfer_byte(priv,\n\t\t\t\t\t LS2X_CR_READ | (len ? 0 : LS2X_CR_ACK),\n\t\t\t\t\t &rxdata);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t*buf++ = readb(priv->base + I2C_LS2X_RXR);\n\t}\n\n\treturn 0;\n}\n\nstatic int ls2x_i2c_tx(struct ls2x_i2c_priv *priv, struct i2c_msg *msg)\n{\n\tint ret;\n\tu8 *buf = msg->buf;\n\tu16 len = msg->len;\n\n\t \n\tret = ls2x_i2c_start(priv, msg);\n\tif (ret)\n\t\treturn ret;\n\n\twhile (len--) {\n\t\twriteb(*buf++, priv->base + I2C_LS2X_TXR);\n\n\t\tret = ls2x_i2c_send_byte(priv, LS2X_CR_WRITE);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int ls2x_i2c_xfer_one(struct ls2x_i2c_priv *priv,\n\t\t\t     struct i2c_msg *msg, bool stop)\n{\n\tint ret;\n\n\tif (msg->flags & I2C_M_RD)\n\t\tret = ls2x_i2c_rx(priv, msg);\n\telse\n\t\tret = ls2x_i2c_tx(priv, msg);\n\n\tif (ret < 0) {\n\t\t \n\t\tif (ret == -ETIMEDOUT)\n\t\t\tls2x_i2c_init(priv);\n\n\t\treturn ret;\n\t}\n\n\tif (stop) {\n\t\t \n\t\tret = ls2x_i2c_stop(priv);\n\t\tif (ret)\n\t\t\tls2x_i2c_init(priv);\n\t}\n\n\treturn ret;\n}\n\nstatic int ls2x_i2c_master_xfer(struct i2c_adapter *adap,\n\t\t\t\tstruct i2c_msg *msgs, int num)\n{\n\tint ret;\n\tstruct i2c_msg *msg, *emsg = msgs + num;\n\tstruct ls2x_i2c_priv *priv = i2c_get_adapdata(adap);\n\n\tfor (msg = msgs; msg < emsg; msg++) {\n\t\tret = ls2x_i2c_xfer_one(priv, msg, msg == emsg - 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn num;\n}\n\nstatic unsigned int ls2x_i2c_func(struct i2c_adapter *adap)\n{\n\treturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;\n}\n\nstatic const struct i2c_algorithm ls2x_i2c_algo = {\n\t.master_xfer\t= ls2x_i2c_master_xfer,\n\t.functionality\t= ls2x_i2c_func,\n};\n\nstatic int ls2x_i2c_probe(struct platform_device *pdev)\n{\n\tint ret, irq;\n\tstruct i2c_adapter *adap;\n\tstruct ls2x_i2c_priv *priv;\n\tstruct device *dev = &pdev->dev;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\t \n\tpriv->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(priv->base))\n\t\treturn PTR_ERR(priv->base);\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\t \n\tadap = &priv->adapter;\n\tadap->retries = 5;\n\tadap->nr = pdev->id;\n\tadap->dev.parent = dev;\n\tadap->owner = THIS_MODULE;\n\tadap->algo = &ls2x_i2c_algo;\n\tadap->timeout = msecs_to_jiffies(100);\n\tdevice_set_node(&adap->dev, dev_fwnode(dev));\n\ti2c_set_adapdata(adap, priv);\n\tstrscpy(adap->name, pdev->name, sizeof(adap->name));\n\tinit_completion(&priv->cmd_complete);\n\tplatform_set_drvdata(pdev, priv);\n\n\tls2x_i2c_init(priv);\n\n\tret = devm_request_irq(dev, irq, ls2x_i2c_isr, IRQF_SHARED, \"ls2x-i2c\",\n\t\t\t       priv);\n\tif (ret < 0)\n\t\treturn dev_err_probe(dev, ret, \"Unable to request irq %d\\n\", irq);\n\n\treturn devm_i2c_add_adapter(dev, adap);\n}\n\nstatic int ls2x_i2c_suspend(struct device *dev)\n{\n\tstruct ls2x_i2c_priv *priv = dev_get_drvdata(dev);\n\n\t \n\twriteb(readb(priv->base + I2C_LS2X_CTR) & ~LS2X_CTR_IEN,\n\t       priv->base + I2C_LS2X_CTR);\n\n\treturn 0;\n}\n\nstatic int ls2x_i2c_resume(struct device *dev)\n{\n\tls2x_i2c_init(dev_get_drvdata(dev));\n\treturn 0;\n}\n\nstatic DEFINE_RUNTIME_DEV_PM_OPS(ls2x_i2c_pm_ops,\n\t\t\t\t ls2x_i2c_suspend, ls2x_i2c_resume, NULL);\n\nstatic const struct of_device_id ls2x_i2c_id_table[] = {\n\t{ .compatible = \"loongson,ls2k-i2c\" },\n\t{ .compatible = \"loongson,ls7a-i2c\" },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, ls2x_i2c_id_table);\n\nstatic const struct acpi_device_id ls2x_i2c_acpi_match[] = {\n\t{ \"LOON0004\" },  \n\t{ }\n};\nMODULE_DEVICE_TABLE(acpi, ls2x_i2c_acpi_match);\n\nstatic struct platform_driver ls2x_i2c_driver = {\n\t.probe\t\t= ls2x_i2c_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"ls2x-i2c\",\n\t\t.pm\t= pm_sleep_ptr(&ls2x_i2c_pm_ops),\n\t\t.of_match_table = ls2x_i2c_id_table,\n\t\t.acpi_match_table = ls2x_i2c_acpi_match,\n\t},\n};\nmodule_platform_driver(ls2x_i2c_driver);\n\nMODULE_DESCRIPTION(\"Loongson LS2X I2C Bus driver\");\nMODULE_AUTHOR(\"Loongson Technology Corporation Limited\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}