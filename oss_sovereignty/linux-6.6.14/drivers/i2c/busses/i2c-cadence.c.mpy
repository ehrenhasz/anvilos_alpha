{
  "module_name": "i2c-cadence.c",
  "hash_id": "600ae5d8b9653d1d050b06e50ea70acd90f08bf2464b9206496beb24743347e0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-cadence.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/of.h>\n#include <linux/pm_runtime.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/reset.h>\n\n \n#define CDNS_I2C_CR_OFFSET\t\t0x00  \n#define CDNS_I2C_SR_OFFSET\t\t0x04  \n#define CDNS_I2C_ADDR_OFFSET\t\t0x08  \n#define CDNS_I2C_DATA_OFFSET\t\t0x0C  \n#define CDNS_I2C_ISR_OFFSET\t\t0x10  \n#define CDNS_I2C_XFER_SIZE_OFFSET\t0x14  \n#define CDNS_I2C_TIME_OUT_OFFSET\t0x1C  \n#define CDNS_I2C_IMR_OFFSET\t\t0x20  \n#define CDNS_I2C_IER_OFFSET\t\t0x24  \n#define CDNS_I2C_IDR_OFFSET\t\t0x28  \n\n \n#define CDNS_I2C_CR_HOLD\t\tBIT(4)  \n#define CDNS_I2C_CR_ACK_EN\t\tBIT(3)\n#define CDNS_I2C_CR_NEA\t\t\tBIT(2)\n#define CDNS_I2C_CR_MS\t\t\tBIT(1)\n \n#define CDNS_I2C_CR_RW\t\t\tBIT(0)\n \n#define CDNS_I2C_CR_CLR_FIFO\t\tBIT(6)\n#define CDNS_I2C_CR_DIVA_SHIFT\t\t14\n#define CDNS_I2C_CR_DIVA_MASK\t\t(3 << CDNS_I2C_CR_DIVA_SHIFT)\n#define CDNS_I2C_CR_DIVB_SHIFT\t\t8\n#define CDNS_I2C_CR_DIVB_MASK\t\t(0x3f << CDNS_I2C_CR_DIVB_SHIFT)\n\n#define CDNS_I2C_CR_MASTER_EN_MASK\t(CDNS_I2C_CR_NEA | \\\n\t\t\t\t\t CDNS_I2C_CR_ACK_EN | \\\n\t\t\t\t\t CDNS_I2C_CR_MS)\n\n#define CDNS_I2C_CR_SLAVE_EN_MASK\t~CDNS_I2C_CR_MASTER_EN_MASK\n\n \n#define CDNS_I2C_SR_BA\t\tBIT(8)\n#define CDNS_I2C_SR_TXDV\tBIT(6)\n#define CDNS_I2C_SR_RXDV\tBIT(5)\n#define CDNS_I2C_SR_RXRW\tBIT(3)\n\n \n#define CDNS_I2C_ADDR_MASK\t0x000003FF  \n\n \n#define CDNS_I2C_IXR_ARB_LOST\t\tBIT(9)\n#define CDNS_I2C_IXR_RX_UNF\t\tBIT(7)\n#define CDNS_I2C_IXR_TX_OVF\t\tBIT(6)\n#define CDNS_I2C_IXR_RX_OVF\t\tBIT(5)\n#define CDNS_I2C_IXR_SLV_RDY\t\tBIT(4)\n#define CDNS_I2C_IXR_TO\t\t\tBIT(3)\n#define CDNS_I2C_IXR_NACK\t\tBIT(2)\n#define CDNS_I2C_IXR_DATA\t\tBIT(1)\n#define CDNS_I2C_IXR_COMP\t\tBIT(0)\n\n#define CDNS_I2C_IXR_ALL_INTR_MASK\t(CDNS_I2C_IXR_ARB_LOST | \\\n\t\t\t\t\t CDNS_I2C_IXR_RX_UNF | \\\n\t\t\t\t\t CDNS_I2C_IXR_TX_OVF | \\\n\t\t\t\t\t CDNS_I2C_IXR_RX_OVF | \\\n\t\t\t\t\t CDNS_I2C_IXR_SLV_RDY | \\\n\t\t\t\t\t CDNS_I2C_IXR_TO | \\\n\t\t\t\t\t CDNS_I2C_IXR_NACK | \\\n\t\t\t\t\t CDNS_I2C_IXR_DATA | \\\n\t\t\t\t\t CDNS_I2C_IXR_COMP)\n\n#define CDNS_I2C_IXR_ERR_INTR_MASK\t(CDNS_I2C_IXR_ARB_LOST | \\\n\t\t\t\t\t CDNS_I2C_IXR_RX_UNF | \\\n\t\t\t\t\t CDNS_I2C_IXR_TX_OVF | \\\n\t\t\t\t\t CDNS_I2C_IXR_RX_OVF | \\\n\t\t\t\t\t CDNS_I2C_IXR_NACK)\n\n#define CDNS_I2C_ENABLED_INTR_MASK\t(CDNS_I2C_IXR_ARB_LOST | \\\n\t\t\t\t\t CDNS_I2C_IXR_RX_UNF | \\\n\t\t\t\t\t CDNS_I2C_IXR_TX_OVF | \\\n\t\t\t\t\t CDNS_I2C_IXR_RX_OVF | \\\n\t\t\t\t\t CDNS_I2C_IXR_NACK | \\\n\t\t\t\t\t CDNS_I2C_IXR_DATA | \\\n\t\t\t\t\t CDNS_I2C_IXR_COMP)\n\n#define CDNS_I2C_IXR_SLAVE_INTR_MASK\t(CDNS_I2C_IXR_RX_UNF | \\\n\t\t\t\t\t CDNS_I2C_IXR_TX_OVF | \\\n\t\t\t\t\t CDNS_I2C_IXR_RX_OVF | \\\n\t\t\t\t\t CDNS_I2C_IXR_TO | \\\n\t\t\t\t\t CDNS_I2C_IXR_NACK | \\\n\t\t\t\t\t CDNS_I2C_IXR_DATA | \\\n\t\t\t\t\t CDNS_I2C_IXR_COMP)\n\n#define CDNS_I2C_TIMEOUT\t\tmsecs_to_jiffies(1000)\n \n#define CNDS_I2C_PM_TIMEOUT\t\t1000\t \n\n#define CDNS_I2C_FIFO_DEPTH_DEFAULT\t16\n#define CDNS_I2C_MAX_TRANSFER_SIZE\t255\n \n#define CDNS_I2C_TRANSFER_SIZE(max)\t((max) - 3)\n\n#define DRIVER_NAME\t\t\"cdns-i2c\"\n\n#define CDNS_I2C_DIVA_MAX\t4\n#define CDNS_I2C_DIVB_MAX\t64\n\n#define CDNS_I2C_TIMEOUT_MAX\t0xFF\n\n#define CDNS_I2C_BROKEN_HOLD_BIT\tBIT(0)\n#define CDNS_I2C_POLL_US\t100000\n#define CDNS_I2C_TIMEOUT_US\t500000\n\n#define cdns_i2c_readreg(offset)       readl_relaxed(id->membase + offset)\n#define cdns_i2c_writereg(val, offset) writel_relaxed(val, id->membase + offset)\n\n#if IS_ENABLED(CONFIG_I2C_SLAVE)\n \nenum cdns_i2c_mode {\n\tCDNS_I2C_MODE_SLAVE,\n\tCDNS_I2C_MODE_MASTER,\n};\n\n \nenum cdns_i2c_slave_state {\n\tCDNS_I2C_SLAVE_STATE_IDLE,\n\tCDNS_I2C_SLAVE_STATE_SEND,\n\tCDNS_I2C_SLAVE_STATE_RECV,\n};\n#endif\n\n \nstruct cdns_i2c {\n\tstruct device\t\t*dev;\n\tvoid __iomem *membase;\n\tstruct i2c_adapter adap;\n\tstruct i2c_msg *p_msg;\n\tint err_status;\n\tstruct completion xfer_done;\n\tunsigned char *p_send_buf;\n\tunsigned char *p_recv_buf;\n\tunsigned int send_count;\n\tunsigned int recv_count;\n\tunsigned int curr_recv_count;\n\tunsigned long input_clk;\n\tunsigned int i2c_clk;\n\tunsigned int bus_hold_flag;\n\tstruct clk *clk;\n\tstruct notifier_block clk_rate_change_nb;\n\tstruct reset_control *reset;\n\tu32 quirks;\n\tu32 ctrl_reg;\n\tstruct i2c_bus_recovery_info rinfo;\n#if IS_ENABLED(CONFIG_I2C_SLAVE)\n\tu16 ctrl_reg_diva_divb;\n\tstruct i2c_client *slave;\n\tenum cdns_i2c_mode dev_mode;\n\tenum cdns_i2c_slave_state slave_state;\n#endif\n\tu32 fifo_depth;\n\tunsigned int transfer_size;\n};\n\nstruct cdns_platform_data {\n\tu32 quirks;\n};\n\n#define to_cdns_i2c(_nb)\tcontainer_of(_nb, struct cdns_i2c, \\\n\t\t\t\t\t     clk_rate_change_nb)\n\n \nstatic void cdns_i2c_clear_bus_hold(struct cdns_i2c *id)\n{\n\tu32 reg = cdns_i2c_readreg(CDNS_I2C_CR_OFFSET);\n\tif (reg & CDNS_I2C_CR_HOLD)\n\t\tcdns_i2c_writereg(reg & ~CDNS_I2C_CR_HOLD, CDNS_I2C_CR_OFFSET);\n}\n\nstatic inline bool cdns_is_holdquirk(struct cdns_i2c *id, bool hold_wrkaround)\n{\n\treturn (hold_wrkaround &&\n\t\t(id->curr_recv_count == id->fifo_depth + 1));\n}\n\n#if IS_ENABLED(CONFIG_I2C_SLAVE)\nstatic void cdns_i2c_set_mode(enum cdns_i2c_mode mode, struct cdns_i2c *id)\n{\n\t \n\tcdns_i2c_writereg(CDNS_I2C_IXR_ALL_INTR_MASK, CDNS_I2C_IDR_OFFSET);\n\n\t \n\tcdns_i2c_writereg(CDNS_I2C_CR_CLR_FIFO, CDNS_I2C_CR_OFFSET);\n\n\t \n\tid->dev_mode = mode;\n\tid->slave_state = CDNS_I2C_SLAVE_STATE_IDLE;\n\n\tswitch (mode) {\n\tcase CDNS_I2C_MODE_MASTER:\n\t\t \n\t\tcdns_i2c_writereg(id->ctrl_reg_diva_divb |\n\t\t\t\t  CDNS_I2C_CR_MASTER_EN_MASK,\n\t\t\t\t  CDNS_I2C_CR_OFFSET);\n\t\t \n\t\tusleep_range(115, 125);\n\t\tbreak;\n\tcase CDNS_I2C_MODE_SLAVE:\n\t\t \n\t\tcdns_i2c_writereg(id->ctrl_reg_diva_divb &\n\t\t\t\t  CDNS_I2C_CR_SLAVE_EN_MASK,\n\t\t\t\t  CDNS_I2C_CR_OFFSET);\n\n\t\t \n\t\tcdns_i2c_writereg(id->slave->addr & CDNS_I2C_ADDR_MASK,\n\t\t\t\t  CDNS_I2C_ADDR_OFFSET);\n\n\t\t \n\t\tcdns_i2c_writereg(CDNS_I2C_IXR_SLAVE_INTR_MASK,\n\t\t\t\t  CDNS_I2C_IER_OFFSET);\n\t\tbreak;\n\t}\n}\n\nstatic void cdns_i2c_slave_rcv_data(struct cdns_i2c *id)\n{\n\tu8 bytes;\n\tunsigned char data;\n\n\t \n\tif (id->slave_state == CDNS_I2C_SLAVE_STATE_IDLE) {\n\t\tid->slave_state = CDNS_I2C_SLAVE_STATE_RECV;\n\t\ti2c_slave_event(id->slave, I2C_SLAVE_WRITE_REQUESTED, NULL);\n\t}\n\n\t \n\tbytes = cdns_i2c_readreg(CDNS_I2C_XFER_SIZE_OFFSET);\n\n\t \n\twhile (bytes--) {\n\t\tdata = cdns_i2c_readreg(CDNS_I2C_DATA_OFFSET);\n\t\ti2c_slave_event(id->slave, I2C_SLAVE_WRITE_RECEIVED, &data);\n\t}\n}\n\nstatic void cdns_i2c_slave_send_data(struct cdns_i2c *id)\n{\n\tu8 data;\n\n\t \n\tif (id->slave_state == CDNS_I2C_SLAVE_STATE_IDLE) {\n\t\tid->slave_state = CDNS_I2C_SLAVE_STATE_SEND;\n\t\ti2c_slave_event(id->slave, I2C_SLAVE_READ_REQUESTED, &data);\n\t} else {\n\t\ti2c_slave_event(id->slave, I2C_SLAVE_READ_PROCESSED, &data);\n\t}\n\n\t \n\tcdns_i2c_writereg(data, CDNS_I2C_DATA_OFFSET);\n}\n\n \nstatic irqreturn_t cdns_i2c_slave_isr(void *ptr)\n{\n\tstruct cdns_i2c *id = ptr;\n\tunsigned int isr_status, i2c_status;\n\n\t \n\tisr_status = cdns_i2c_readreg(CDNS_I2C_ISR_OFFSET);\n\tcdns_i2c_writereg(isr_status, CDNS_I2C_ISR_OFFSET);\n\n\t \n\tisr_status &= ~cdns_i2c_readreg(CDNS_I2C_IMR_OFFSET);\n\n\t \n\ti2c_status = cdns_i2c_readreg(CDNS_I2C_SR_OFFSET);\n\n\t \n\tif (i2c_status & CDNS_I2C_SR_RXRW) {\n\t\t \n\t\tif (isr_status & CDNS_I2C_IXR_DATA)\n\t\t\tcdns_i2c_slave_send_data(id);\n\n\t\tif (isr_status & CDNS_I2C_IXR_COMP) {\n\t\t\tid->slave_state = CDNS_I2C_SLAVE_STATE_IDLE;\n\t\t\ti2c_slave_event(id->slave, I2C_SLAVE_STOP, NULL);\n\t\t}\n\t} else {\n\t\t \n\t\tif (isr_status & CDNS_I2C_IXR_DATA)\n\t\t\tcdns_i2c_slave_rcv_data(id);\n\n\t\tif (isr_status & CDNS_I2C_IXR_COMP) {\n\t\t\tcdns_i2c_slave_rcv_data(id);\n\t\t\tid->slave_state = CDNS_I2C_SLAVE_STATE_IDLE;\n\t\t\ti2c_slave_event(id->slave, I2C_SLAVE_STOP, NULL);\n\t\t}\n\t}\n\n\t \n\tif (isr_status & (CDNS_I2C_IXR_NACK | CDNS_I2C_IXR_RX_OVF |\n\t\t\t  CDNS_I2C_IXR_RX_UNF | CDNS_I2C_IXR_TX_OVF)) {\n\t\tid->slave_state = CDNS_I2C_SLAVE_STATE_IDLE;\n\t\ti2c_slave_event(id->slave, I2C_SLAVE_STOP, NULL);\n\t\tcdns_i2c_writereg(CDNS_I2C_CR_CLR_FIFO, CDNS_I2C_CR_OFFSET);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n#endif\n\n \nstatic irqreturn_t cdns_i2c_master_isr(void *ptr)\n{\n\tunsigned int isr_status, avail_bytes;\n\tunsigned int bytes_to_send;\n\tbool updatetx;\n\tstruct cdns_i2c *id = ptr;\n\t \n\tint done_flag = 0;\n\tirqreturn_t status = IRQ_NONE;\n\n\tisr_status = cdns_i2c_readreg(CDNS_I2C_ISR_OFFSET);\n\tcdns_i2c_writereg(isr_status, CDNS_I2C_ISR_OFFSET);\n\tid->err_status = 0;\n\n\t \n\tif (isr_status & (CDNS_I2C_IXR_NACK | CDNS_I2C_IXR_ARB_LOST)) {\n\t\tdone_flag = 1;\n\t\tstatus = IRQ_HANDLED;\n\t}\n\n\t \n\tupdatetx = id->recv_count > id->curr_recv_count;\n\n\t \n\tif (id->p_recv_buf &&\n\t    ((isr_status & CDNS_I2C_IXR_COMP) ||\n\t     (isr_status & CDNS_I2C_IXR_DATA))) {\n\t\t \n\t\twhile (cdns_i2c_readreg(CDNS_I2C_SR_OFFSET) &\n\t\t       CDNS_I2C_SR_RXDV) {\n\t\t\tif (id->recv_count > 0) {\n\t\t\t\t*(id->p_recv_buf)++ =\n\t\t\t\t\tcdns_i2c_readreg(CDNS_I2C_DATA_OFFSET);\n\t\t\t\tid->recv_count--;\n\t\t\t\tid->curr_recv_count--;\n\n\t\t\t\t \n\t\t\t\tif (id->recv_count <= id->fifo_depth &&\n\t\t\t\t    !id->bus_hold_flag)\n\t\t\t\t\tcdns_i2c_clear_bus_hold(id);\n\n\t\t\t} else {\n\t\t\t\tdev_err(id->adap.dev.parent,\n\t\t\t\t\t\"xfer_size reg rollover. xfer aborted!\\n\");\n\t\t\t\tid->err_status |= CDNS_I2C_IXR_TO;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (cdns_is_holdquirk(id, updatetx))\n\t\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (cdns_is_holdquirk(id, updatetx)) {\n\t\t\t \n\t\t\twhile (cdns_i2c_readreg(CDNS_I2C_XFER_SIZE_OFFSET) !=\n\t\t\t       (id->curr_recv_count - id->fifo_depth))\n\t\t\t\t;\n\n\t\t\t \n\t\t\tif (((int)(id->recv_count) - id->fifo_depth) >\n\t\t\t    id->transfer_size) {\n\t\t\t\tcdns_i2c_writereg(id->transfer_size,\n\t\t\t\t\t\t  CDNS_I2C_XFER_SIZE_OFFSET);\n\t\t\t\tid->curr_recv_count = id->transfer_size +\n\t\t\t\t\t\t      id->fifo_depth;\n\t\t\t} else {\n\t\t\t\tcdns_i2c_writereg(id->recv_count -\n\t\t\t\t\t\t  id->fifo_depth,\n\t\t\t\t\t\t  CDNS_I2C_XFER_SIZE_OFFSET);\n\t\t\t\tid->curr_recv_count = id->recv_count;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif ((isr_status & CDNS_I2C_IXR_COMP) && !id->recv_count) {\n\t\t\tif (!id->bus_hold_flag)\n\t\t\t\tcdns_i2c_clear_bus_hold(id);\n\t\t\tdone_flag = 1;\n\t\t}\n\n\t\tstatus = IRQ_HANDLED;\n\t}\n\n\t \n\tif ((isr_status & CDNS_I2C_IXR_COMP) && !id->p_recv_buf) {\n\t\t \n\t\tif (id->send_count) {\n\t\t\tavail_bytes = id->fifo_depth -\n\t\t\t    cdns_i2c_readreg(CDNS_I2C_XFER_SIZE_OFFSET);\n\t\t\tif (id->send_count > avail_bytes)\n\t\t\t\tbytes_to_send = avail_bytes;\n\t\t\telse\n\t\t\t\tbytes_to_send = id->send_count;\n\n\t\t\twhile (bytes_to_send--) {\n\t\t\t\tcdns_i2c_writereg(\n\t\t\t\t\t(*(id->p_send_buf)++),\n\t\t\t\t\t CDNS_I2C_DATA_OFFSET);\n\t\t\t\tid->send_count--;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tdone_flag = 1;\n\t\t}\n\t\tif (!id->send_count && !id->bus_hold_flag)\n\t\t\tcdns_i2c_clear_bus_hold(id);\n\n\t\tstatus = IRQ_HANDLED;\n\t}\n\n\t \n\tid->err_status |= isr_status & CDNS_I2C_IXR_ERR_INTR_MASK;\n\tif (id->err_status)\n\t\tstatus = IRQ_HANDLED;\n\n\tif (done_flag)\n\t\tcomplete(&id->xfer_done);\n\n\treturn status;\n}\n\n \nstatic irqreturn_t cdns_i2c_isr(int irq, void *ptr)\n{\n#if IS_ENABLED(CONFIG_I2C_SLAVE)\n\tstruct cdns_i2c *id = ptr;\n\n\tif (id->dev_mode == CDNS_I2C_MODE_SLAVE)\n\t\treturn cdns_i2c_slave_isr(ptr);\n#endif\n\treturn cdns_i2c_master_isr(ptr);\n}\n\n \nstatic void cdns_i2c_mrecv(struct cdns_i2c *id)\n{\n\tunsigned int ctrl_reg;\n\tunsigned int isr_status;\n\tunsigned long flags;\n\tbool hold_clear = false;\n\tbool irq_save = false;\n\n\tu32 addr;\n\n\tid->p_recv_buf = id->p_msg->buf;\n\tid->recv_count = id->p_msg->len;\n\n\t \n\tctrl_reg = cdns_i2c_readreg(CDNS_I2C_CR_OFFSET);\n\tctrl_reg |= CDNS_I2C_CR_RW | CDNS_I2C_CR_CLR_FIFO;\n\n\t \n\tif (id->p_msg->flags & I2C_M_RECV_LEN)\n\t\tid->recv_count = I2C_SMBUS_BLOCK_MAX + id->p_msg->len;\n\n\tid->curr_recv_count = id->recv_count;\n\n\t \n\tif (id->recv_count > id->fifo_depth)\n\t\tctrl_reg |= CDNS_I2C_CR_HOLD;\n\n\tcdns_i2c_writereg(ctrl_reg, CDNS_I2C_CR_OFFSET);\n\n\t \n\tisr_status = cdns_i2c_readreg(CDNS_I2C_ISR_OFFSET);\n\tcdns_i2c_writereg(isr_status, CDNS_I2C_ISR_OFFSET);\n\n\t \n\tif (id->recv_count > id->transfer_size) {\n\t\tcdns_i2c_writereg(id->transfer_size,\n\t\t\t\t  CDNS_I2C_XFER_SIZE_OFFSET);\n\t\tid->curr_recv_count = id->transfer_size;\n\t} else {\n\t\tcdns_i2c_writereg(id->recv_count, CDNS_I2C_XFER_SIZE_OFFSET);\n\t}\n\n\t \n\tif (!id->bus_hold_flag && id->recv_count <= id->fifo_depth) {\n\t\tif (ctrl_reg & CDNS_I2C_CR_HOLD) {\n\t\t\thold_clear = true;\n\t\t\tif (id->quirks & CDNS_I2C_BROKEN_HOLD_BIT)\n\t\t\t\tirq_save = true;\n\t\t}\n\t}\n\n\taddr = id->p_msg->addr;\n\taddr &= CDNS_I2C_ADDR_MASK;\n\n\tif (hold_clear) {\n\t\tctrl_reg &= ~CDNS_I2C_CR_HOLD;\n\t\t \n\t\tif (irq_save)\n\t\t\tlocal_irq_save(flags);\n\n\t\tcdns_i2c_writereg(addr, CDNS_I2C_ADDR_OFFSET);\n\t\tcdns_i2c_writereg(ctrl_reg, CDNS_I2C_CR_OFFSET);\n\t\t \n\t\tcdns_i2c_readreg(CDNS_I2C_CR_OFFSET);\n\n\t\tif (irq_save)\n\t\t\tlocal_irq_restore(flags);\n\t} else {\n\t\tcdns_i2c_writereg(addr, CDNS_I2C_ADDR_OFFSET);\n\t}\n\n\tcdns_i2c_writereg(CDNS_I2C_ENABLED_INTR_MASK, CDNS_I2C_IER_OFFSET);\n}\n\n \nstatic void cdns_i2c_msend(struct cdns_i2c *id)\n{\n\tunsigned int avail_bytes;\n\tunsigned int bytes_to_send;\n\tunsigned int ctrl_reg;\n\tunsigned int isr_status;\n\n\tid->p_recv_buf = NULL;\n\tid->p_send_buf = id->p_msg->buf;\n\tid->send_count = id->p_msg->len;\n\n\t \n\tctrl_reg = cdns_i2c_readreg(CDNS_I2C_CR_OFFSET);\n\tctrl_reg &= ~CDNS_I2C_CR_RW;\n\tctrl_reg |= CDNS_I2C_CR_CLR_FIFO;\n\n\t \n\tif (id->send_count > id->fifo_depth)\n\t\tctrl_reg |= CDNS_I2C_CR_HOLD;\n\tcdns_i2c_writereg(ctrl_reg, CDNS_I2C_CR_OFFSET);\n\n\t \n\tisr_status = cdns_i2c_readreg(CDNS_I2C_ISR_OFFSET);\n\tcdns_i2c_writereg(isr_status, CDNS_I2C_ISR_OFFSET);\n\n\t \n\tavail_bytes = id->fifo_depth -\n\t\t\t\tcdns_i2c_readreg(CDNS_I2C_XFER_SIZE_OFFSET);\n\n\tif (id->send_count > avail_bytes)\n\t\tbytes_to_send = avail_bytes;\n\telse\n\t\tbytes_to_send = id->send_count;\n\n\twhile (bytes_to_send--) {\n\t\tcdns_i2c_writereg((*(id->p_send_buf)++), CDNS_I2C_DATA_OFFSET);\n\t\tid->send_count--;\n\t}\n\n\t \n\tif (!id->bus_hold_flag && !id->send_count)\n\t\tcdns_i2c_clear_bus_hold(id);\n\t \n\tcdns_i2c_writereg(id->p_msg->addr & CDNS_I2C_ADDR_MASK,\n\t\t\t\t\t\tCDNS_I2C_ADDR_OFFSET);\n\n\tcdns_i2c_writereg(CDNS_I2C_ENABLED_INTR_MASK, CDNS_I2C_IER_OFFSET);\n}\n\n \nstatic void cdns_i2c_master_reset(struct i2c_adapter *adap)\n{\n\tstruct cdns_i2c *id = adap->algo_data;\n\tu32 regval;\n\n\t \n\tcdns_i2c_writereg(CDNS_I2C_IXR_ALL_INTR_MASK, CDNS_I2C_IDR_OFFSET);\n\t \n\tregval = cdns_i2c_readreg(CDNS_I2C_CR_OFFSET);\n\tregval &= ~CDNS_I2C_CR_HOLD;\n\tregval |= CDNS_I2C_CR_CLR_FIFO;\n\tcdns_i2c_writereg(regval, CDNS_I2C_CR_OFFSET);\n\t \n\tcdns_i2c_writereg(0, CDNS_I2C_XFER_SIZE_OFFSET);\n\t \n\tregval = cdns_i2c_readreg(CDNS_I2C_ISR_OFFSET);\n\tcdns_i2c_writereg(regval, CDNS_I2C_ISR_OFFSET);\n\t \n\tregval = cdns_i2c_readreg(CDNS_I2C_SR_OFFSET);\n\tcdns_i2c_writereg(regval, CDNS_I2C_SR_OFFSET);\n}\n\nstatic int cdns_i2c_process_msg(struct cdns_i2c *id, struct i2c_msg *msg,\n\t\tstruct i2c_adapter *adap)\n{\n\tunsigned long time_left, msg_timeout;\n\tu32 reg;\n\n\tid->p_msg = msg;\n\tid->err_status = 0;\n\treinit_completion(&id->xfer_done);\n\n\t \n\treg = cdns_i2c_readreg(CDNS_I2C_CR_OFFSET);\n\tif (msg->flags & I2C_M_TEN) {\n\t\tif (reg & CDNS_I2C_CR_NEA)\n\t\t\tcdns_i2c_writereg(reg & ~CDNS_I2C_CR_NEA,\n\t\t\t\t\tCDNS_I2C_CR_OFFSET);\n\t} else {\n\t\tif (!(reg & CDNS_I2C_CR_NEA))\n\t\t\tcdns_i2c_writereg(reg | CDNS_I2C_CR_NEA,\n\t\t\t\t\tCDNS_I2C_CR_OFFSET);\n\t}\n\n\t \n\tif (msg->flags & I2C_M_RD)\n\t\tcdns_i2c_mrecv(id);\n\telse\n\t\tcdns_i2c_msend(id);\n\n\t \n\tmsg_timeout = msecs_to_jiffies((1000 * msg->len * BITS_PER_BYTE) / id->i2c_clk);\n\t \n\tmsg_timeout += msecs_to_jiffies(500);\n\n\tif (msg_timeout < adap->timeout)\n\t\tmsg_timeout = adap->timeout;\n\n\t \n\ttime_left = wait_for_completion_timeout(&id->xfer_done, msg_timeout);\n\tif (time_left == 0) {\n\t\tcdns_i2c_master_reset(adap);\n\t\tdev_err(id->adap.dev.parent,\n\t\t\t\t\"timeout waiting on completion\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tcdns_i2c_writereg(CDNS_I2C_IXR_ALL_INTR_MASK,\n\t\t\t  CDNS_I2C_IDR_OFFSET);\n\n\t \n\tif (id->err_status & CDNS_I2C_IXR_ARB_LOST)\n\t\treturn -EAGAIN;\n\n\tif (msg->flags & I2C_M_RECV_LEN)\n\t\tmsg->len += min_t(unsigned int, msg->buf[0], I2C_SMBUS_BLOCK_MAX);\n\n\treturn 0;\n}\n\n \nstatic int cdns_i2c_master_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs,\n\t\t\t\tint num)\n{\n\tint ret, count;\n\tu32 reg;\n\tstruct cdns_i2c *id = adap->algo_data;\n\tbool hold_quirk;\n#if IS_ENABLED(CONFIG_I2C_SLAVE)\n\tbool change_role = false;\n#endif\n\n\tret = pm_runtime_resume_and_get(id->dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n#if IS_ENABLED(CONFIG_I2C_SLAVE)\n\t \n\tif (id->dev_mode == CDNS_I2C_MODE_SLAVE) {\n\t\tif (id->slave_state != CDNS_I2C_SLAVE_STATE_IDLE) {\n\t\t\tret = -EAGAIN;\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tcdns_i2c_set_mode(CDNS_I2C_MODE_MASTER, id);\n\n\t\t \n\t\tchange_role = true;\n\t}\n#endif\n\n\t \n\n\tret = readl_relaxed_poll_timeout(id->membase + CDNS_I2C_SR_OFFSET,\n\t\t\t\t\t reg,\n\t\t\t\t\t !(reg & CDNS_I2C_SR_BA),\n\t\t\t\t\t CDNS_I2C_POLL_US, CDNS_I2C_TIMEOUT_US);\n\tif (ret) {\n\t\tret = -EAGAIN;\n\t\tif (id->adap.bus_recovery_info)\n\t\t\ti2c_recover_bus(adap);\n\t\tgoto out;\n\t}\n\n\thold_quirk = !!(id->quirks & CDNS_I2C_BROKEN_HOLD_BIT);\n\t \n\tif (num > 1) {\n\t\t \n\t\tfor (count = 0; (count < num - 1 && hold_quirk); count++) {\n\t\t\tif (msgs[count].flags & I2C_M_RD) {\n\t\t\t\tdev_warn(adap->dev.parent,\n\t\t\t\t\t \"Can't do repeated start after a receive message\\n\");\n\t\t\t\tret = -EOPNOTSUPP;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tid->bus_hold_flag = 1;\n\t\treg = cdns_i2c_readreg(CDNS_I2C_CR_OFFSET);\n\t\treg |= CDNS_I2C_CR_HOLD;\n\t\tcdns_i2c_writereg(reg, CDNS_I2C_CR_OFFSET);\n\t} else {\n\t\tid->bus_hold_flag = 0;\n\t}\n\n\t \n\tfor (count = 0; count < num; count++, msgs++) {\n\t\tif (count == (num - 1))\n\t\t\tid->bus_hold_flag = 0;\n\n\t\tret = cdns_i2c_process_msg(id, msgs, adap);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\t \n\t\tif (id->err_status) {\n\t\t\tcdns_i2c_master_reset(adap);\n\n\t\t\tif (id->err_status & CDNS_I2C_IXR_NACK) {\n\t\t\t\tret = -ENXIO;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tret = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = num;\n\nout:\n\n#if IS_ENABLED(CONFIG_I2C_SLAVE)\n\t \n\tif (change_role)\n\t\tcdns_i2c_set_mode(CDNS_I2C_MODE_SLAVE, id);\n#endif\n\n\tpm_runtime_mark_last_busy(id->dev);\n\tpm_runtime_put_autosuspend(id->dev);\n\treturn ret;\n}\n\n \nstatic u32 cdns_i2c_func(struct i2c_adapter *adap)\n{\n\tu32 func = I2C_FUNC_I2C | I2C_FUNC_10BIT_ADDR |\n\t\t\t(I2C_FUNC_SMBUS_EMUL & ~I2C_FUNC_SMBUS_QUICK) |\n\t\t\tI2C_FUNC_SMBUS_BLOCK_DATA;\n\n#if IS_ENABLED(CONFIG_I2C_SLAVE)\n\tfunc |= I2C_FUNC_SLAVE;\n#endif\n\n\treturn func;\n}\n\n#if IS_ENABLED(CONFIG_I2C_SLAVE)\nstatic int cdns_reg_slave(struct i2c_client *slave)\n{\n\tint ret;\n\tstruct cdns_i2c *id = container_of(slave->adapter, struct cdns_i2c,\n\t\t\t\t\t\t\t\t\tadap);\n\n\tif (id->slave)\n\t\treturn -EBUSY;\n\n\tif (slave->flags & I2C_CLIENT_TEN)\n\t\treturn -EAFNOSUPPORT;\n\n\tret = pm_runtime_resume_and_get(id->dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tid->slave = slave;\n\n\t \n\tcdns_i2c_set_mode(CDNS_I2C_MODE_SLAVE, id);\n\n\treturn 0;\n}\n\nstatic int cdns_unreg_slave(struct i2c_client *slave)\n{\n\tstruct cdns_i2c *id = container_of(slave->adapter, struct cdns_i2c,\n\t\t\t\t\t\t\t\t\tadap);\n\n\tpm_runtime_put(id->dev);\n\n\t \n\tid->slave = NULL;\n\n\t \n\tcdns_i2c_set_mode(CDNS_I2C_MODE_MASTER, id);\n\n\treturn 0;\n}\n#endif\n\nstatic const struct i2c_algorithm cdns_i2c_algo = {\n\t.master_xfer\t= cdns_i2c_master_xfer,\n\t.functionality\t= cdns_i2c_func,\n#if IS_ENABLED(CONFIG_I2C_SLAVE)\n\t.reg_slave\t= cdns_reg_slave,\n\t.unreg_slave\t= cdns_unreg_slave,\n#endif\n};\n\n \nstatic int cdns_i2c_calc_divs(unsigned long *f, unsigned long input_clk,\n\t\tunsigned int *a, unsigned int *b)\n{\n\tunsigned long fscl = *f, best_fscl = *f, actual_fscl, temp;\n\tunsigned int div_a, div_b, calc_div_a = 0, calc_div_b = 0;\n\tunsigned int last_error, current_error;\n\n\t \n\ttemp = input_clk / (22 * fscl);\n\n\t \n\tif (!temp || (temp > (CDNS_I2C_DIVA_MAX * CDNS_I2C_DIVB_MAX)))\n\t\treturn -EINVAL;\n\n\tlast_error = -1;\n\tfor (div_a = 0; div_a < CDNS_I2C_DIVA_MAX; div_a++) {\n\t\tdiv_b = DIV_ROUND_UP(input_clk, 22 * fscl * (div_a + 1));\n\n\t\tif ((div_b < 1) || (div_b > CDNS_I2C_DIVB_MAX))\n\t\t\tcontinue;\n\t\tdiv_b--;\n\n\t\tactual_fscl = input_clk / (22 * (div_a + 1) * (div_b + 1));\n\n\t\tif (actual_fscl > fscl)\n\t\t\tcontinue;\n\n\t\tcurrent_error = fscl - actual_fscl;\n\n\t\tif (last_error > current_error) {\n\t\t\tcalc_div_a = div_a;\n\t\t\tcalc_div_b = div_b;\n\t\t\tbest_fscl = actual_fscl;\n\t\t\tlast_error = current_error;\n\t\t}\n\t}\n\n\t*a = calc_div_a;\n\t*b = calc_div_b;\n\t*f = best_fscl;\n\n\treturn 0;\n}\n\n \nstatic int cdns_i2c_setclk(unsigned long clk_in, struct cdns_i2c *id)\n{\n\tunsigned int div_a, div_b;\n\tunsigned int ctrl_reg;\n\tint ret = 0;\n\tunsigned long fscl = id->i2c_clk;\n\n\tret = cdns_i2c_calc_divs(&fscl, clk_in, &div_a, &div_b);\n\tif (ret)\n\t\treturn ret;\n\n\tctrl_reg = id->ctrl_reg;\n\tctrl_reg &= ~(CDNS_I2C_CR_DIVA_MASK | CDNS_I2C_CR_DIVB_MASK);\n\tctrl_reg |= ((div_a << CDNS_I2C_CR_DIVA_SHIFT) |\n\t\t\t(div_b << CDNS_I2C_CR_DIVB_SHIFT));\n\tid->ctrl_reg = ctrl_reg;\n\tcdns_i2c_writereg(ctrl_reg, CDNS_I2C_CR_OFFSET);\n#if IS_ENABLED(CONFIG_I2C_SLAVE)\n\tid->ctrl_reg_diva_divb = ctrl_reg & (CDNS_I2C_CR_DIVA_MASK |\n\t\t\t\t CDNS_I2C_CR_DIVB_MASK);\n#endif\n\treturn 0;\n}\n\n \nstatic int cdns_i2c_clk_notifier_cb(struct notifier_block *nb, unsigned long\n\t\tevent, void *data)\n{\n\tstruct clk_notifier_data *ndata = data;\n\tstruct cdns_i2c *id = to_cdns_i2c(nb);\n\n\tif (pm_runtime_suspended(id->dev))\n\t\treturn NOTIFY_OK;\n\n\tswitch (event) {\n\tcase PRE_RATE_CHANGE:\n\t{\n\t\tunsigned long input_clk = ndata->new_rate;\n\t\tunsigned long fscl = id->i2c_clk;\n\t\tunsigned int div_a, div_b;\n\t\tint ret;\n\n\t\tret = cdns_i2c_calc_divs(&fscl, input_clk, &div_a, &div_b);\n\t\tif (ret) {\n\t\t\tdev_warn(id->adap.dev.parent,\n\t\t\t\t\t\"clock rate change rejected\\n\");\n\t\t\treturn NOTIFY_STOP;\n\t\t}\n\n\t\t \n\t\tif (ndata->new_rate > ndata->old_rate)\n\t\t\tcdns_i2c_setclk(ndata->new_rate, id);\n\n\t\treturn NOTIFY_OK;\n\t}\n\tcase POST_RATE_CHANGE:\n\t\tid->input_clk = ndata->new_rate;\n\t\t \n\t\tif (ndata->new_rate < ndata->old_rate)\n\t\t\tcdns_i2c_setclk(ndata->new_rate, id);\n\t\treturn NOTIFY_OK;\n\tcase ABORT_RATE_CHANGE:\n\t\t \n\t\tif (ndata->new_rate > ndata->old_rate)\n\t\t\tcdns_i2c_setclk(ndata->old_rate, id);\n\t\treturn NOTIFY_OK;\n\tdefault:\n\t\treturn NOTIFY_DONE;\n\t}\n}\n\n \nstatic int __maybe_unused cdns_i2c_runtime_suspend(struct device *dev)\n{\n\tstruct cdns_i2c *xi2c = dev_get_drvdata(dev);\n\n\tclk_disable(xi2c->clk);\n\n\treturn 0;\n}\n\n \nstatic void cdns_i2c_init(struct cdns_i2c *id)\n{\n\tcdns_i2c_writereg(id->ctrl_reg, CDNS_I2C_CR_OFFSET);\n\t \n\tcdns_i2c_writereg(CDNS_I2C_TIMEOUT_MAX, CDNS_I2C_TIME_OUT_OFFSET);\n}\n\n \nstatic int __maybe_unused cdns_i2c_runtime_resume(struct device *dev)\n{\n\tstruct cdns_i2c *xi2c = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = clk_enable(xi2c->clk);\n\tif (ret) {\n\t\tdev_err(dev, \"Cannot enable clock.\\n\");\n\t\treturn ret;\n\t}\n\tcdns_i2c_init(xi2c);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops cdns_i2c_dev_pm_ops = {\n\tSET_RUNTIME_PM_OPS(cdns_i2c_runtime_suspend,\n\t\t\t   cdns_i2c_runtime_resume, NULL)\n};\n\nstatic const struct cdns_platform_data r1p10_i2c_def = {\n\t.quirks = CDNS_I2C_BROKEN_HOLD_BIT,\n};\n\nstatic const struct of_device_id cdns_i2c_of_match[] = {\n\t{ .compatible = \"cdns,i2c-r1p10\", .data = &r1p10_i2c_def },\n\t{ .compatible = \"cdns,i2c-r1p14\",},\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, cdns_i2c_of_match);\n\n \nstatic void cdns_i2c_detect_transfer_size(struct cdns_i2c *id)\n{\n\tu32 val;\n\n\t \n\tcdns_i2c_writereg(CDNS_I2C_CR_MS | CDNS_I2C_CR_RW, CDNS_I2C_CR_OFFSET);\n\n\t \n\tcdns_i2c_writereg(CDNS_I2C_MAX_TRANSFER_SIZE, CDNS_I2C_XFER_SIZE_OFFSET);\n\tval = cdns_i2c_readreg(CDNS_I2C_XFER_SIZE_OFFSET);\n\tid->transfer_size = CDNS_I2C_TRANSFER_SIZE(val);\n\tcdns_i2c_writereg(0, CDNS_I2C_XFER_SIZE_OFFSET);\n\tcdns_i2c_writereg(0, CDNS_I2C_CR_OFFSET);\n}\n\n \nstatic int cdns_i2c_probe(struct platform_device *pdev)\n{\n\tstruct resource *r_mem;\n\tstruct cdns_i2c *id;\n\tint ret, irq;\n\tconst struct of_device_id *match;\n\n\tid = devm_kzalloc(&pdev->dev, sizeof(*id), GFP_KERNEL);\n\tif (!id)\n\t\treturn -ENOMEM;\n\n\tid->dev = &pdev->dev;\n\tplatform_set_drvdata(pdev, id);\n\n\tmatch = of_match_node(cdns_i2c_of_match, pdev->dev.of_node);\n\tif (match && match->data) {\n\t\tconst struct cdns_platform_data *data = match->data;\n\t\tid->quirks = data->quirks;\n\t}\n\n\tid->rinfo.pinctrl = devm_pinctrl_get(&pdev->dev);\n\tif (IS_ERR(id->rinfo.pinctrl)) {\n\t\tint err = PTR_ERR(id->rinfo.pinctrl);\n\n\t\tdev_info(&pdev->dev, \"can't get pinctrl, bus recovery not supported\\n\");\n\t\tif (err != -ENODEV)\n\t\t\treturn err;\n\t} else {\n\t\tid->adap.bus_recovery_info = &id->rinfo;\n\t}\n\n\tid->membase = devm_platform_get_and_ioremap_resource(pdev, 0, &r_mem);\n\tif (IS_ERR(id->membase))\n\t\treturn PTR_ERR(id->membase);\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tid->adap.owner = THIS_MODULE;\n\tid->adap.dev.of_node = pdev->dev.of_node;\n\tid->adap.algo = &cdns_i2c_algo;\n\tid->adap.timeout = CDNS_I2C_TIMEOUT;\n\tid->adap.retries = 3;\t\t \n\tid->adap.algo_data = id;\n\tid->adap.dev.parent = &pdev->dev;\n\tinit_completion(&id->xfer_done);\n\tsnprintf(id->adap.name, sizeof(id->adap.name),\n\t\t \"Cadence I2C at %08lx\", (unsigned long)r_mem->start);\n\n\tid->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(id->clk))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(id->clk),\n\t\t\t\t     \"input clock not found.\\n\");\n\n\tid->reset = devm_reset_control_get_optional_shared(&pdev->dev, NULL);\n\tif (IS_ERR(id->reset))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(id->reset),\n\t\t\t\t     \"Failed to request reset.\\n\");\n\n\tret = clk_prepare_enable(id->clk);\n\tif (ret)\n\t\tdev_err(&pdev->dev, \"Unable to enable clock.\\n\");\n\n\tret = reset_control_deassert(id->reset);\n\tif (ret) {\n\t\tdev_err_probe(&pdev->dev, ret,\n\t\t\t      \"Failed to de-assert reset.\\n\");\n\t\tgoto err_clk_dis;\n\t}\n\n\tpm_runtime_set_autosuspend_delay(id->dev, CNDS_I2C_PM_TIMEOUT);\n\tpm_runtime_use_autosuspend(id->dev);\n\tpm_runtime_set_active(id->dev);\n\tpm_runtime_enable(id->dev);\n\n\tid->clk_rate_change_nb.notifier_call = cdns_i2c_clk_notifier_cb;\n\tif (clk_notifier_register(id->clk, &id->clk_rate_change_nb))\n\t\tdev_warn(&pdev->dev, \"Unable to register clock notifier.\\n\");\n\tid->input_clk = clk_get_rate(id->clk);\n\n\tret = of_property_read_u32(pdev->dev.of_node, \"clock-frequency\",\n\t\t\t&id->i2c_clk);\n\tif (ret || (id->i2c_clk > I2C_MAX_FAST_MODE_FREQ))\n\t\tid->i2c_clk = I2C_MAX_STANDARD_MODE_FREQ;\n\n#if IS_ENABLED(CONFIG_I2C_SLAVE)\n\t \n\tid->dev_mode = CDNS_I2C_MODE_MASTER;\n\tid->slave_state = CDNS_I2C_SLAVE_STATE_IDLE;\n#endif\n\tid->ctrl_reg = CDNS_I2C_CR_ACK_EN | CDNS_I2C_CR_NEA | CDNS_I2C_CR_MS;\n\n\tid->fifo_depth = CDNS_I2C_FIFO_DEPTH_DEFAULT;\n\tof_property_read_u32(pdev->dev.of_node, \"fifo-depth\", &id->fifo_depth);\n\n\tcdns_i2c_detect_transfer_size(id);\n\n\tret = cdns_i2c_setclk(id->input_clk, id);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"invalid SCL clock: %u Hz\\n\", id->i2c_clk);\n\t\tret = -EINVAL;\n\t\tgoto err_clk_notifier_unregister;\n\t}\n\n\tret = devm_request_irq(&pdev->dev, irq, cdns_i2c_isr, 0,\n\t\t\t\t DRIVER_NAME, id);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"cannot get irq %d\\n\", irq);\n\t\tgoto err_clk_notifier_unregister;\n\t}\n\tcdns_i2c_init(id);\n\n\tret = i2c_add_adapter(&id->adap);\n\tif (ret < 0)\n\t\tgoto err_clk_notifier_unregister;\n\n\tdev_info(&pdev->dev, \"%u kHz mmio %08lx irq %d\\n\",\n\t\t id->i2c_clk / 1000, (unsigned long)r_mem->start, irq);\n\n\treturn 0;\n\nerr_clk_notifier_unregister:\n\tclk_notifier_unregister(id->clk, &id->clk_rate_change_nb);\n\treset_control_assert(id->reset);\nerr_clk_dis:\n\tclk_disable_unprepare(id->clk);\n\tpm_runtime_disable(&pdev->dev);\n\tpm_runtime_set_suspended(&pdev->dev);\n\treturn ret;\n}\n\n \nstatic void cdns_i2c_remove(struct platform_device *pdev)\n{\n\tstruct cdns_i2c *id = platform_get_drvdata(pdev);\n\n\tpm_runtime_disable(&pdev->dev);\n\tpm_runtime_set_suspended(&pdev->dev);\n\tpm_runtime_dont_use_autosuspend(&pdev->dev);\n\n\ti2c_del_adapter(&id->adap);\n\tclk_notifier_unregister(id->clk, &id->clk_rate_change_nb);\n\treset_control_assert(id->reset);\n\tclk_disable_unprepare(id->clk);\n}\n\nstatic struct platform_driver cdns_i2c_drv = {\n\t.driver = {\n\t\t.name  = DRIVER_NAME,\n\t\t.of_match_table = cdns_i2c_of_match,\n\t\t.pm = &cdns_i2c_dev_pm_ops,\n\t},\n\t.probe  = cdns_i2c_probe,\n\t.remove_new = cdns_i2c_remove,\n};\n\nmodule_platform_driver(cdns_i2c_drv);\n\nMODULE_AUTHOR(\"Xilinx Inc.\");\nMODULE_DESCRIPTION(\"Cadence I2C bus driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}