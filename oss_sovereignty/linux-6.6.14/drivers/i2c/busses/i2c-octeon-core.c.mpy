{
  "module_name": "i2c-octeon-core.c",
  "hash_id": "a0145832668ea12bdb83c6e2055127601ff0c95f38c5c9c811a3c56600f4f396",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-octeon-core.c",
  "human_readable_source": " \n\n#include <linux/delay.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\n#include \"i2c-octeon-core.h\"\n\n \nirqreturn_t octeon_i2c_isr(int irq, void *dev_id)\n{\n\tstruct octeon_i2c *i2c = dev_id;\n\n\ti2c->int_disable(i2c);\n\twake_up(&i2c->queue);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic bool octeon_i2c_test_iflg(struct octeon_i2c *i2c)\n{\n\treturn (octeon_i2c_ctl_read(i2c) & TWSI_CTL_IFLG);\n}\n\n \nstatic int octeon_i2c_wait(struct octeon_i2c *i2c)\n{\n\tlong time_left;\n\n\t \n\tif (i2c->broken_irq_mode) {\n\t\tu64 end = get_jiffies_64() + i2c->adap.timeout;\n\n\t\twhile (!octeon_i2c_test_iflg(i2c) &&\n\t\t       time_before64(get_jiffies_64(), end))\n\t\t\tusleep_range(I2C_OCTEON_EVENT_WAIT / 2, I2C_OCTEON_EVENT_WAIT);\n\n\t\treturn octeon_i2c_test_iflg(i2c) ? 0 : -ETIMEDOUT;\n\t}\n\n\ti2c->int_enable(i2c);\n\ttime_left = wait_event_timeout(i2c->queue, octeon_i2c_test_iflg(i2c),\n\t\t\t\t       i2c->adap.timeout);\n\ti2c->int_disable(i2c);\n\n\tif (i2c->broken_irq_check && !time_left &&\n\t    octeon_i2c_test_iflg(i2c)) {\n\t\tdev_err(i2c->dev, \"broken irq connection detected, switching to polling mode.\\n\");\n\t\ti2c->broken_irq_mode = true;\n\t\treturn 0;\n\t}\n\n\tif (!time_left)\n\t\treturn -ETIMEDOUT;\n\n\treturn 0;\n}\n\nstatic bool octeon_i2c_hlc_test_valid(struct octeon_i2c *i2c)\n{\n\treturn (__raw_readq(i2c->twsi_base + SW_TWSI(i2c)) & SW_TWSI_V) == 0;\n}\n\nstatic void octeon_i2c_hlc_int_clear(struct octeon_i2c *i2c)\n{\n\t \n\tocteon_i2c_write_int(i2c, TWSI_INT_ST_INT | TWSI_INT_TS_INT);\n}\n\n \nstatic void octeon_i2c_hlc_enable(struct octeon_i2c *i2c)\n{\n\tint try = 0;\n\tu64 val;\n\n\tif (i2c->hlc_enabled)\n\t\treturn;\n\ti2c->hlc_enabled = true;\n\n\twhile (1) {\n\t\tval = octeon_i2c_ctl_read(i2c);\n\t\tif (!(val & (TWSI_CTL_STA | TWSI_CTL_STP)))\n\t\t\tbreak;\n\n\t\t \n\t\tif (val & TWSI_CTL_IFLG)\n\t\t\tocteon_i2c_ctl_write(i2c, TWSI_CTL_ENAB);\n\n\t\tif (try++ > 100) {\n\t\t\tpr_err(\"%s: giving up\\n\", __func__);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tudelay(10);\n\t}\n\tocteon_i2c_ctl_write(i2c, TWSI_CTL_CE | TWSI_CTL_AAK | TWSI_CTL_ENAB);\n}\n\nstatic void octeon_i2c_hlc_disable(struct octeon_i2c *i2c)\n{\n\tif (!i2c->hlc_enabled)\n\t\treturn;\n\n\ti2c->hlc_enabled = false;\n\tocteon_i2c_ctl_write(i2c, TWSI_CTL_ENAB);\n}\n\n \nstatic int octeon_i2c_hlc_wait(struct octeon_i2c *i2c)\n{\n\tint time_left;\n\n\t \n\tif (i2c->broken_irq_mode) {\n\t\tu64 end = get_jiffies_64() + i2c->adap.timeout;\n\n\t\twhile (!octeon_i2c_hlc_test_valid(i2c) &&\n\t\t       time_before64(get_jiffies_64(), end))\n\t\t\tusleep_range(I2C_OCTEON_EVENT_WAIT / 2, I2C_OCTEON_EVENT_WAIT);\n\n\t\treturn octeon_i2c_hlc_test_valid(i2c) ? 0 : -ETIMEDOUT;\n\t}\n\n\ti2c->hlc_int_enable(i2c);\n\ttime_left = wait_event_timeout(i2c->queue,\n\t\t\t\t       octeon_i2c_hlc_test_valid(i2c),\n\t\t\t\t       i2c->adap.timeout);\n\ti2c->hlc_int_disable(i2c);\n\tif (!time_left)\n\t\tocteon_i2c_hlc_int_clear(i2c);\n\n\tif (i2c->broken_irq_check && !time_left &&\n\t    octeon_i2c_hlc_test_valid(i2c)) {\n\t\tdev_err(i2c->dev, \"broken irq connection detected, switching to polling mode.\\n\");\n\t\ti2c->broken_irq_mode = true;\n\t\treturn 0;\n\t}\n\n\tif (!time_left)\n\t\treturn -ETIMEDOUT;\n\treturn 0;\n}\n\nstatic int octeon_i2c_check_status(struct octeon_i2c *i2c, int final_read)\n{\n\tu8 stat;\n\n\t \n\tif (i2c->hlc_enabled)\n\t\tstat = __raw_readq(i2c->twsi_base + SW_TWSI(i2c));\n\telse\n\t\tstat = octeon_i2c_stat_read(i2c);\n\n\tswitch (stat) {\n\t \n\tcase STAT_IDLE:\n\tcase STAT_AD2W_ACK:\n\tcase STAT_RXADDR_ACK:\n\tcase STAT_TXADDR_ACK:\n\tcase STAT_TXDATA_ACK:\n\t\treturn 0;\n\n\t \n\tcase STAT_RXDATA_ACK:\n\t\tif (!final_read)\n\t\t\treturn 0;\n\t\treturn -EIO;\n\n\t \n\tcase STAT_RXDATA_NAK:\n\t\tif (final_read)\n\t\t\treturn 0;\n\t\treturn -EIO;\n\n\t \n\tcase STAT_LOST_ARB_38:\n\tcase STAT_LOST_ARB_68:\n\tcase STAT_LOST_ARB_78:\n\tcase STAT_LOST_ARB_B0:\n\t\treturn -EAGAIN;\n\n\t \n\tcase STAT_SLAVE_60:\n\tcase STAT_SLAVE_70:\n\tcase STAT_GENDATA_ACK:\n\tcase STAT_GENDATA_NAK:\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tcase STAT_SLAVE_80:\n\tcase STAT_SLAVE_88:\n\tcase STAT_SLAVE_A0:\n\tcase STAT_SLAVE_A8:\n\tcase STAT_SLAVE_LOST:\n\tcase STAT_SLAVE_NAK:\n\tcase STAT_SLAVE_ACK:\n\t\treturn -EOPNOTSUPP;\n\n\tcase STAT_TXDATA_NAK:\n\tcase STAT_BUS_ERROR:\n\t\treturn -EIO;\n\tcase STAT_TXADDR_NAK:\n\tcase STAT_RXADDR_NAK:\n\tcase STAT_AD2W_NAK:\n\t\treturn -ENXIO;\n\tdefault:\n\t\tdev_err(i2c->dev, \"unhandled state: %d\\n\", stat);\n\t\treturn -EIO;\n\t}\n}\n\nstatic int octeon_i2c_recovery(struct octeon_i2c *i2c)\n{\n\tint ret;\n\n\tret = i2c_recover_bus(&i2c->adap);\n\tif (ret)\n\t\t \n\t\tret = octeon_i2c_init_lowlevel(i2c);\n\treturn ret;\n}\n\n \nstatic int octeon_i2c_start(struct octeon_i2c *i2c)\n{\n\tint ret;\n\tu8 stat;\n\n\tocteon_i2c_hlc_disable(i2c);\n\n\tocteon_i2c_ctl_write(i2c, TWSI_CTL_ENAB | TWSI_CTL_STA);\n\tret = octeon_i2c_wait(i2c);\n\tif (ret)\n\t\tgoto error;\n\n\tstat = octeon_i2c_stat_read(i2c);\n\tif (stat == STAT_START || stat == STAT_REP_START)\n\t\t \n\t\treturn 0;\n\nerror:\n\t \n\tret = octeon_i2c_recovery(i2c);\n\treturn (ret) ? ret : -EAGAIN;\n}\n\n \nstatic void octeon_i2c_stop(struct octeon_i2c *i2c)\n{\n\tocteon_i2c_ctl_write(i2c, TWSI_CTL_ENAB | TWSI_CTL_STP);\n}\n\n \nstatic int octeon_i2c_read(struct octeon_i2c *i2c, int target,\n\t\t\t   u8 *data, u16 *rlength, bool recv_len)\n{\n\tint i, result, length = *rlength;\n\tbool final_read = false;\n\n\tocteon_i2c_data_write(i2c, (target << 1) | 1);\n\tocteon_i2c_ctl_write(i2c, TWSI_CTL_ENAB);\n\n\tresult = octeon_i2c_wait(i2c);\n\tif (result)\n\t\treturn result;\n\n\t \n\tresult = octeon_i2c_check_status(i2c, false);\n\tif (result)\n\t\treturn result;\n\n\tfor (i = 0; i < length; i++) {\n\t\t \n\t\tif ((i + 1 == length) && !(recv_len && i == 0))\n\t\t\tfinal_read = true;\n\n\t\t \n\t\tif (final_read)\n\t\t\tocteon_i2c_ctl_write(i2c, TWSI_CTL_ENAB);\n\t\telse\n\t\t\tocteon_i2c_ctl_write(i2c, TWSI_CTL_ENAB | TWSI_CTL_AAK);\n\n\t\tresult = octeon_i2c_wait(i2c);\n\t\tif (result)\n\t\t\treturn result;\n\n\t\tdata[i] = octeon_i2c_data_read(i2c, &result);\n\t\tif (result)\n\t\t\treturn result;\n\t\tif (recv_len && i == 0) {\n\t\t\tif (data[i] > I2C_SMBUS_BLOCK_MAX)\n\t\t\t\treturn -EPROTO;\n\t\t\tlength += data[i];\n\t\t}\n\n\t\tresult = octeon_i2c_check_status(i2c, final_read);\n\t\tif (result)\n\t\t\treturn result;\n\t}\n\t*rlength = length;\n\treturn 0;\n}\n\n \nstatic int octeon_i2c_write(struct octeon_i2c *i2c, int target,\n\t\t\t    const u8 *data, int length)\n{\n\tint i, result;\n\n\tocteon_i2c_data_write(i2c, target << 1);\n\tocteon_i2c_ctl_write(i2c, TWSI_CTL_ENAB);\n\n\tresult = octeon_i2c_wait(i2c);\n\tif (result)\n\t\treturn result;\n\n\tfor (i = 0; i < length; i++) {\n\t\tresult = octeon_i2c_check_status(i2c, false);\n\t\tif (result)\n\t\t\treturn result;\n\n\t\tocteon_i2c_data_write(i2c, data[i]);\n\t\tocteon_i2c_ctl_write(i2c, TWSI_CTL_ENAB);\n\n\t\tresult = octeon_i2c_wait(i2c);\n\t\tif (result)\n\t\t\treturn result;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int octeon_i2c_hlc_read(struct octeon_i2c *i2c, struct i2c_msg *msgs)\n{\n\tint i, j, ret = 0;\n\tu64 cmd;\n\n\tocteon_i2c_hlc_enable(i2c);\n\tocteon_i2c_hlc_int_clear(i2c);\n\n\tcmd = SW_TWSI_V | SW_TWSI_R | SW_TWSI_SOVR;\n\t \n\tcmd |= (u64)(msgs[0].len - 1) << SW_TWSI_SIZE_SHIFT;\n\t \n\tcmd |= (u64)(msgs[0].addr & 0x7full) << SW_TWSI_ADDR_SHIFT;\n\n\tif (msgs[0].flags & I2C_M_TEN)\n\t\tcmd |= SW_TWSI_OP_10;\n\telse\n\t\tcmd |= SW_TWSI_OP_7;\n\n\tocteon_i2c_writeq_flush(cmd, i2c->twsi_base + SW_TWSI(i2c));\n\tret = octeon_i2c_hlc_wait(i2c);\n\tif (ret)\n\t\tgoto err;\n\n\tcmd = __raw_readq(i2c->twsi_base + SW_TWSI(i2c));\n\tif ((cmd & SW_TWSI_R) == 0)\n\t\treturn octeon_i2c_check_status(i2c, false);\n\n\tfor (i = 0, j = msgs[0].len - 1; i  < msgs[0].len && i < 4; i++, j--)\n\t\tmsgs[0].buf[j] = (cmd >> (8 * i)) & 0xff;\n\n\tif (msgs[0].len > 4) {\n\t\tcmd = __raw_readq(i2c->twsi_base + SW_TWSI_EXT(i2c));\n\t\tfor (i = 0; i  < msgs[0].len - 4 && i < 4; i++, j--)\n\t\t\tmsgs[0].buf[j] = (cmd >> (8 * i)) & 0xff;\n\t}\n\nerr:\n\treturn ret;\n}\n\n \nstatic int octeon_i2c_hlc_write(struct octeon_i2c *i2c, struct i2c_msg *msgs)\n{\n\tint i, j, ret = 0;\n\tu64 cmd;\n\n\tocteon_i2c_hlc_enable(i2c);\n\tocteon_i2c_hlc_int_clear(i2c);\n\n\tcmd = SW_TWSI_V | SW_TWSI_SOVR;\n\t \n\tcmd |= (u64)(msgs[0].len - 1) << SW_TWSI_SIZE_SHIFT;\n\t \n\tcmd |= (u64)(msgs[0].addr & 0x7full) << SW_TWSI_ADDR_SHIFT;\n\n\tif (msgs[0].flags & I2C_M_TEN)\n\t\tcmd |= SW_TWSI_OP_10;\n\telse\n\t\tcmd |= SW_TWSI_OP_7;\n\n\tfor (i = 0, j = msgs[0].len - 1; i  < msgs[0].len && i < 4; i++, j--)\n\t\tcmd |= (u64)msgs[0].buf[j] << (8 * i);\n\n\tif (msgs[0].len > 4) {\n\t\tu64 ext = 0;\n\n\t\tfor (i = 0; i < msgs[0].len - 4 && i < 4; i++, j--)\n\t\t\text |= (u64)msgs[0].buf[j] << (8 * i);\n\t\tocteon_i2c_writeq_flush(ext, i2c->twsi_base + SW_TWSI_EXT(i2c));\n\t}\n\n\tocteon_i2c_writeq_flush(cmd, i2c->twsi_base + SW_TWSI(i2c));\n\tret = octeon_i2c_hlc_wait(i2c);\n\tif (ret)\n\t\tgoto err;\n\n\tcmd = __raw_readq(i2c->twsi_base + SW_TWSI(i2c));\n\tif ((cmd & SW_TWSI_R) == 0)\n\t\treturn octeon_i2c_check_status(i2c, false);\n\nerr:\n\treturn ret;\n}\n\n \nstatic int octeon_i2c_hlc_comp_read(struct octeon_i2c *i2c, struct i2c_msg *msgs)\n{\n\tint i, j, ret = 0;\n\tu64 cmd;\n\n\tocteon_i2c_hlc_enable(i2c);\n\n\tcmd = SW_TWSI_V | SW_TWSI_R | SW_TWSI_SOVR;\n\t \n\tcmd |= (u64)(msgs[1].len - 1) << SW_TWSI_SIZE_SHIFT;\n\t \n\tcmd |= (u64)(msgs[0].addr & 0x7full) << SW_TWSI_ADDR_SHIFT;\n\n\tif (msgs[0].flags & I2C_M_TEN)\n\t\tcmd |= SW_TWSI_OP_10_IA;\n\telse\n\t\tcmd |= SW_TWSI_OP_7_IA;\n\n\tif (msgs[0].len == 2) {\n\t\tu64 ext = 0;\n\n\t\tcmd |= SW_TWSI_EIA;\n\t\text = (u64)msgs[0].buf[0] << SW_TWSI_IA_SHIFT;\n\t\tcmd |= (u64)msgs[0].buf[1] << SW_TWSI_IA_SHIFT;\n\t\tocteon_i2c_writeq_flush(ext, i2c->twsi_base + SW_TWSI_EXT(i2c));\n\t} else {\n\t\tcmd |= (u64)msgs[0].buf[0] << SW_TWSI_IA_SHIFT;\n\t}\n\n\tocteon_i2c_hlc_int_clear(i2c);\n\tocteon_i2c_writeq_flush(cmd, i2c->twsi_base + SW_TWSI(i2c));\n\n\tret = octeon_i2c_hlc_wait(i2c);\n\tif (ret)\n\t\tgoto err;\n\n\tcmd = __raw_readq(i2c->twsi_base + SW_TWSI(i2c));\n\tif ((cmd & SW_TWSI_R) == 0)\n\t\treturn octeon_i2c_check_status(i2c, false);\n\n\tfor (i = 0, j = msgs[1].len - 1; i  < msgs[1].len && i < 4; i++, j--)\n\t\tmsgs[1].buf[j] = (cmd >> (8 * i)) & 0xff;\n\n\tif (msgs[1].len > 4) {\n\t\tcmd = __raw_readq(i2c->twsi_base + SW_TWSI_EXT(i2c));\n\t\tfor (i = 0; i  < msgs[1].len - 4 && i < 4; i++, j--)\n\t\t\tmsgs[1].buf[j] = (cmd >> (8 * i)) & 0xff;\n\t}\n\nerr:\n\treturn ret;\n}\n\n \nstatic int octeon_i2c_hlc_comp_write(struct octeon_i2c *i2c, struct i2c_msg *msgs)\n{\n\tbool set_ext = false;\n\tint i, j, ret = 0;\n\tu64 cmd, ext = 0;\n\n\tocteon_i2c_hlc_enable(i2c);\n\n\tcmd = SW_TWSI_V | SW_TWSI_SOVR;\n\t \n\tcmd |= (u64)(msgs[1].len - 1) << SW_TWSI_SIZE_SHIFT;\n\t \n\tcmd |= (u64)(msgs[0].addr & 0x7full) << SW_TWSI_ADDR_SHIFT;\n\n\tif (msgs[0].flags & I2C_M_TEN)\n\t\tcmd |= SW_TWSI_OP_10_IA;\n\telse\n\t\tcmd |= SW_TWSI_OP_7_IA;\n\n\tif (msgs[0].len == 2) {\n\t\tcmd |= SW_TWSI_EIA;\n\t\text |= (u64)msgs[0].buf[0] << SW_TWSI_IA_SHIFT;\n\t\tset_ext = true;\n\t\tcmd |= (u64)msgs[0].buf[1] << SW_TWSI_IA_SHIFT;\n\t} else {\n\t\tcmd |= (u64)msgs[0].buf[0] << SW_TWSI_IA_SHIFT;\n\t}\n\n\tfor (i = 0, j = msgs[1].len - 1; i  < msgs[1].len && i < 4; i++, j--)\n\t\tcmd |= (u64)msgs[1].buf[j] << (8 * i);\n\n\tif (msgs[1].len > 4) {\n\t\tfor (i = 0; i < msgs[1].len - 4 && i < 4; i++, j--)\n\t\t\text |= (u64)msgs[1].buf[j] << (8 * i);\n\t\tset_ext = true;\n\t}\n\tif (set_ext)\n\t\tocteon_i2c_writeq_flush(ext, i2c->twsi_base + SW_TWSI_EXT(i2c));\n\n\tocteon_i2c_hlc_int_clear(i2c);\n\tocteon_i2c_writeq_flush(cmd, i2c->twsi_base + SW_TWSI(i2c));\n\n\tret = octeon_i2c_hlc_wait(i2c);\n\tif (ret)\n\t\tgoto err;\n\n\tcmd = __raw_readq(i2c->twsi_base + SW_TWSI(i2c));\n\tif ((cmd & SW_TWSI_R) == 0)\n\t\treturn octeon_i2c_check_status(i2c, false);\n\nerr:\n\treturn ret;\n}\n\n \nint octeon_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)\n{\n\tstruct octeon_i2c *i2c = i2c_get_adapdata(adap);\n\tint i, ret = 0;\n\n\tif (num == 1) {\n\t\tif (msgs[0].len > 0 && msgs[0].len <= 8) {\n\t\t\tif (msgs[0].flags & I2C_M_RD)\n\t\t\t\tret = octeon_i2c_hlc_read(i2c, msgs);\n\t\t\telse\n\t\t\t\tret = octeon_i2c_hlc_write(i2c, msgs);\n\t\t\tgoto out;\n\t\t}\n\t} else if (num == 2) {\n\t\tif ((msgs[0].flags & I2C_M_RD) == 0 &&\n\t\t    (msgs[1].flags & I2C_M_RECV_LEN) == 0 &&\n\t\t    msgs[0].len > 0 && msgs[0].len <= 2 &&\n\t\t    msgs[1].len > 0 && msgs[1].len <= 8 &&\n\t\t    msgs[0].addr == msgs[1].addr) {\n\t\t\tif (msgs[1].flags & I2C_M_RD)\n\t\t\t\tret = octeon_i2c_hlc_comp_read(i2c, msgs);\n\t\t\telse\n\t\t\t\tret = octeon_i2c_hlc_comp_write(i2c, msgs);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tfor (i = 0; ret == 0 && i < num; i++) {\n\t\tstruct i2c_msg *pmsg = &msgs[i];\n\n\t\t \n\t\tif (!pmsg->len) {\n\t\t\tret = -EOPNOTSUPP;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = octeon_i2c_start(i2c);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (pmsg->flags & I2C_M_RD)\n\t\t\tret = octeon_i2c_read(i2c, pmsg->addr, pmsg->buf,\n\t\t\t\t\t      &pmsg->len, pmsg->flags & I2C_M_RECV_LEN);\n\t\telse\n\t\t\tret = octeon_i2c_write(i2c, pmsg->addr, pmsg->buf,\n\t\t\t\t\t       pmsg->len);\n\t}\n\tocteon_i2c_stop(i2c);\nout:\n\treturn (ret != 0) ? ret : num;\n}\n\n \nvoid octeon_i2c_set_clock(struct octeon_i2c *i2c)\n{\n\tint tclk, thp_base, inc, thp_idx, mdiv_idx, ndiv_idx, foscl, diff;\n\tint thp = 0x18, mdiv = 2, ndiv = 0, delta_hz = 1000000;\n\n\tfor (ndiv_idx = 0; ndiv_idx < 8 && delta_hz != 0; ndiv_idx++) {\n\t\t \n\t\tfor (mdiv_idx = 15; mdiv_idx >= 2 && delta_hz != 0; mdiv_idx--) {\n\t\t\t \n\t\t\ttclk = i2c->twsi_freq * (mdiv_idx + 1) * 10;\n\t\t\ttclk *= (1 << ndiv_idx);\n\t\t\tthp_base = (i2c->sys_freq / (tclk * 2)) - 1;\n\n\t\t\tfor (inc = 0; inc <= 1; inc++) {\n\t\t\t\tthp_idx = thp_base + inc;\n\t\t\t\tif (thp_idx < 5 || thp_idx > 0xff)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tfoscl = i2c->sys_freq / (2 * (thp_idx + 1));\n\t\t\t\tfoscl = foscl / (1 << ndiv_idx);\n\t\t\t\tfoscl = foscl / (mdiv_idx + 1) / 10;\n\t\t\t\tdiff = abs(foscl - i2c->twsi_freq);\n\t\t\t\tif (diff < delta_hz) {\n\t\t\t\t\tdelta_hz = diff;\n\t\t\t\t\tthp = thp_idx;\n\t\t\t\t\tmdiv = mdiv_idx;\n\t\t\t\t\tndiv = ndiv_idx;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tocteon_i2c_reg_write(i2c, SW_TWSI_OP_TWSI_CLK, thp);\n\tocteon_i2c_reg_write(i2c, SW_TWSI_EOP_TWSI_CLKCTL, (mdiv << 3) | ndiv);\n}\n\nint octeon_i2c_init_lowlevel(struct octeon_i2c *i2c)\n{\n\tu8 status = 0;\n\tint tries;\n\n\t \n\tocteon_i2c_reg_write(i2c, SW_TWSI_EOP_TWSI_RST, 0);\n\n\tfor (tries = 10; tries && status != STAT_IDLE; tries--) {\n\t\tudelay(1);\n\t\tstatus = octeon_i2c_stat_read(i2c);\n\t\tif (status == STAT_IDLE)\n\t\t\tbreak;\n\t}\n\n\tif (status != STAT_IDLE) {\n\t\tdev_err(i2c->dev, \"%s: TWSI_RST failed! (0x%x)\\n\",\n\t\t\t__func__, status);\n\t\treturn -EIO;\n\t}\n\n\t \n\tocteon_i2c_hlc_enable(i2c);\n\tocteon_i2c_hlc_disable(i2c);\n\treturn 0;\n}\n\nstatic int octeon_i2c_get_scl(struct i2c_adapter *adap)\n{\n\tstruct octeon_i2c *i2c = i2c_get_adapdata(adap);\n\tu64 state;\n\n\tstate = octeon_i2c_read_int(i2c);\n\treturn state & TWSI_INT_SCL;\n}\n\nstatic void octeon_i2c_set_scl(struct i2c_adapter *adap, int val)\n{\n\tstruct octeon_i2c *i2c = i2c_get_adapdata(adap);\n\n\tocteon_i2c_write_int(i2c, val ? 0 : TWSI_INT_SCL_OVR);\n}\n\nstatic int octeon_i2c_get_sda(struct i2c_adapter *adap)\n{\n\tstruct octeon_i2c *i2c = i2c_get_adapdata(adap);\n\tu64 state;\n\n\tstate = octeon_i2c_read_int(i2c);\n\treturn state & TWSI_INT_SDA;\n}\n\nstatic void octeon_i2c_prepare_recovery(struct i2c_adapter *adap)\n{\n\tstruct octeon_i2c *i2c = i2c_get_adapdata(adap);\n\n\tocteon_i2c_hlc_disable(i2c);\n\tocteon_i2c_reg_write(i2c, SW_TWSI_EOP_TWSI_RST, 0);\n\t \n\tudelay(5);\n\n\t \n\tocteon_i2c_ctl_write(i2c, TWSI_CTL_ENAB);\n\n\tocteon_i2c_write_int(i2c, 0);\n}\n\nstatic void octeon_i2c_unprepare_recovery(struct i2c_adapter *adap)\n{\n\tstruct octeon_i2c *i2c = i2c_get_adapdata(adap);\n\n\t \n\tocteon_i2c_write_int(i2c, TWSI_INT_SDA_OVR | TWSI_INT_SCL_OVR);\n\tudelay(5);\n\tocteon_i2c_write_int(i2c, TWSI_INT_SDA_OVR);\n\tudelay(5);\n\tocteon_i2c_write_int(i2c, 0);\n}\n\nstruct i2c_bus_recovery_info octeon_i2c_recovery_info = {\n\t.recover_bus = i2c_generic_scl_recovery,\n\t.get_scl = octeon_i2c_get_scl,\n\t.set_scl = octeon_i2c_set_scl,\n\t.get_sda = octeon_i2c_get_sda,\n\t.prepare_recovery = octeon_i2c_prepare_recovery,\n\t.unprepare_recovery = octeon_i2c_unprepare_recovery,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}