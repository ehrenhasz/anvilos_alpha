{
  "module_name": "i2c-gxp.c",
  "hash_id": "6a44ad41e07d9d1a46aa3752da55dfd0e0bf46e81a58ac456864637d4f56d9ca",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-gxp.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/i2c.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/mfd/syscon.h>\n\n#define GXP_MAX_I2C_ENGINE 10\nstatic const char * const gxp_i2c_name[] = {\n\t\"gxp-i2c0\", \"gxp-i2c1\", \"gxp-i2c2\", \"gxp-i2c3\",\n\t\"gxp-i2c4\", \"gxp-i2c5\", \"gxp-i2c6\", \"gxp-i2c7\",\n\t\"gxp-i2c8\", \"gxp-i2c9\" };\n\n \n#define GXP_I2CINTSTAT\t\t0x00\n#define GXP_I2CINTEN\t\t0x04\n\n \n#define GXP_I2CSTAT\t\t0x00\n#define MASK_STOP_EVENT\t\t0x20\n#define MASK_ACK\t\t0x08\n#define MASK_RW\t\t\t0x04\n#define GXP_I2CEVTERR\t\t0x01\n#define MASK_SLAVE_CMD_EVENT\t0x01\n#define MASK_SLAVE_DATA_EVENT\t0x02\n#define MASK_MASTER_EVENT\t0x10\n#define GXP_I2CSNPDAT\t\t0x02\n#define GXP_I2CMCMD\t\t0x04\n#define GXP_I2CSCMD\t\t0x06\n#define GXP_I2CSNPAA\t\t0x09\n#define GXP_I2CADVFEAT\t\t0x0A\n#define GXP_I2COWNADR\t\t0x0B\n#define GXP_I2CFREQDIV\t\t0x0C\n#define GXP_I2CFLTFAIR\t\t0x0D\n#define GXP_I2CTMOEDG\t\t0x0E\n#define GXP_I2CCYCTIM\t\t0x0F\n\n \n#define SNOOP_EVT_CLR\t\t0x80\n#define SLAVE_EVT_CLR\t\t0x40\n#define\tSNOOP_EVT_MASK\t\t0x20\n#define SLAVE_EVT_MASK\t\t0x10\n#define SLAVE_ACK_ENAB\t\t0x08\n#define SLAVE_EVT_STALL\t\t0x01\n\n \n#define MASTER_EVT_CLR\t\t0x80\n#define MASTER_ACK_ENAB\t\t0x08\n#define RW_CMD\t\t\t0x04\n#define STOP_CMD\t\t0x02\n#define START_CMD\t\t0x01\n\n \n#define GXP_DATA_EDGE_RST_CTRL\t0x0a  \n\n \n#define FILTER_CNT\t\t0x30\n#define FAIRNESS_CNT\t\t0x02\n\nenum {\n\tGXP_I2C_IDLE = 0,\n\tGXP_I2C_ADDR_PHASE,\n\tGXP_I2C_RDATA_PHASE,\n\tGXP_I2C_WDATA_PHASE,\n\tGXP_I2C_ADDR_NACK,\n\tGXP_I2C_DATA_NACK,\n\tGXP_I2C_ERROR,\n\tGXP_I2C_COMP\n};\n\nstruct gxp_i2c_drvdata {\n\tstruct device *dev;\n\tvoid __iomem *base;\n\tstruct i2c_timings t;\n\tu32 engine;\n\tint irq;\n\tstruct completion completion;\n\tstruct i2c_adapter adapter;\n\tstruct i2c_msg *curr_msg;\n\tint msgs_remaining;\n\tint msgs_num;\n\tu8 *buf;\n\tsize_t buf_remaining;\n\tunsigned char state;\n\tstruct i2c_client *slave;\n\tunsigned char stopped;\n};\n\nstatic struct regmap *i2cg_map;\n\nstatic void gxp_i2c_start(struct gxp_i2c_drvdata *drvdata)\n{\n\tu16 value;\n\n\tdrvdata->buf = drvdata->curr_msg->buf;\n\tdrvdata->buf_remaining = drvdata->curr_msg->len;\n\n\t \n\tvalue = drvdata->curr_msg->addr << 9;\n\n\t \n\tvalue |= drvdata->curr_msg->flags & I2C_M_RD ? RW_CMD | START_CMD : START_CMD;\n\n\tdrvdata->state = GXP_I2C_ADDR_PHASE;\n\twritew(value, drvdata->base + GXP_I2CMCMD);\n}\n\nstatic int gxp_i2c_master_xfer(struct i2c_adapter *adapter,\n\t\t\t       struct i2c_msg *msgs, int num)\n{\n\tint ret;\n\tstruct gxp_i2c_drvdata *drvdata = i2c_get_adapdata(adapter);\n\tunsigned long time_left;\n\n\tdrvdata->msgs_remaining = num;\n\tdrvdata->curr_msg = msgs;\n\tdrvdata->msgs_num = num;\n\treinit_completion(&drvdata->completion);\n\n\tgxp_i2c_start(drvdata);\n\n\ttime_left = wait_for_completion_timeout(&drvdata->completion,\n\t\t\t\t\t\tadapter->timeout);\n\tret = num - drvdata->msgs_remaining;\n\tif (time_left == 0)\n\t\treturn -ETIMEDOUT;\n\n\tif (drvdata->state == GXP_I2C_ADDR_NACK)\n\t\treturn -ENXIO;\n\n\tif (drvdata->state == GXP_I2C_DATA_NACK)\n\t\treturn -EIO;\n\n\treturn ret;\n}\n\nstatic u32 gxp_i2c_func(struct i2c_adapter *adap)\n{\n\tif (IS_ENABLED(CONFIG_I2C_SLAVE))\n\t\treturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL | I2C_FUNC_SLAVE;\n\n\treturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;\n}\n\n#if IS_ENABLED(CONFIG_I2C_SLAVE)\nstatic int gxp_i2c_reg_slave(struct i2c_client *slave)\n{\n\tstruct gxp_i2c_drvdata *drvdata = i2c_get_adapdata(slave->adapter);\n\n\tif (drvdata->slave)\n\t\treturn -EBUSY;\n\n\tif (slave->flags & I2C_CLIENT_TEN)\n\t\treturn -EAFNOSUPPORT;\n\n\tdrvdata->slave = slave;\n\n\twriteb(slave->addr << 1, drvdata->base + GXP_I2COWNADR);\n\twriteb(SLAVE_EVT_CLR | SNOOP_EVT_MASK | SLAVE_ACK_ENAB |\n\t       SLAVE_EVT_STALL, drvdata->base + GXP_I2CSCMD);\n\n\treturn 0;\n}\n\nstatic int gxp_i2c_unreg_slave(struct i2c_client *slave)\n{\n\tstruct gxp_i2c_drvdata *drvdata = i2c_get_adapdata(slave->adapter);\n\n\tWARN_ON(!drvdata->slave);\n\n\twriteb(0x00, drvdata->base + GXP_I2COWNADR);\n\twriteb(SNOOP_EVT_CLR | SLAVE_EVT_CLR | SNOOP_EVT_MASK |\n\t       SLAVE_EVT_MASK, drvdata->base + GXP_I2CSCMD);\n\n\tdrvdata->slave = NULL;\n\n\treturn 0;\n}\n#endif\n\nstatic const struct i2c_algorithm gxp_i2c_algo = {\n\t.master_xfer   = gxp_i2c_master_xfer,\n\t.functionality = gxp_i2c_func,\n#if IS_ENABLED(CONFIG_I2C_SLAVE)\n\t.reg_slave     = gxp_i2c_reg_slave,\n\t.unreg_slave   = gxp_i2c_unreg_slave,\n#endif\n};\n\nstatic void gxp_i2c_stop(struct gxp_i2c_drvdata *drvdata)\n{\n\t \n\twriteb(MASTER_EVT_CLR | STOP_CMD, drvdata->base + GXP_I2CMCMD);\n\n\tcomplete(&drvdata->completion);\n}\n\nstatic void gxp_i2c_restart(struct gxp_i2c_drvdata *drvdata)\n{\n\tu16 value;\n\n\tdrvdata->buf = drvdata->curr_msg->buf;\n\tdrvdata->buf_remaining = drvdata->curr_msg->len;\n\n\tvalue = drvdata->curr_msg->addr << 9;\n\n\tif (drvdata->curr_msg->flags & I2C_M_RD) {\n\t\t \n\t\tvalue |= MASTER_EVT_CLR | RW_CMD | START_CMD;\n\t} else {\n\t\t \n\t\tvalue |= MASTER_EVT_CLR | START_CMD;\n\t}\n\n\tdrvdata->state = GXP_I2C_ADDR_PHASE;\n\n\twritew(value, drvdata->base + GXP_I2CMCMD);\n}\n\nstatic void gxp_i2c_chk_addr_ack(struct gxp_i2c_drvdata *drvdata)\n{\n\tu16 value;\n\n\tvalue = readb(drvdata->base + GXP_I2CSTAT);\n\tif (!(value & MASK_ACK)) {\n\t\t \n\t\tdrvdata->state = GXP_I2C_ADDR_NACK;\n\t\tgxp_i2c_stop(drvdata);\n\t\treturn;\n\t}\n\n\tif (drvdata->curr_msg->flags & I2C_M_RD) {\n\t\t \n\t\tif (drvdata->buf_remaining == 0) {\n\t\t\t \n\t\t\tdrvdata->msgs_remaining--;\n\t\t\tdrvdata->state = GXP_I2C_COMP;\n\t\t\tgxp_i2c_stop(drvdata);\n\t\t\treturn;\n\t\t}\n\t\tdrvdata->state = GXP_I2C_RDATA_PHASE;\n\n\t\tif (drvdata->buf_remaining == 1) {\n\t\t\t \n\t\t\twriteb(MASTER_EVT_CLR | RW_CMD,\n\t\t\t       drvdata->base + GXP_I2CMCMD);\n\t\t} else {\n\t\t\t \n\t\t\twriteb(MASTER_EVT_CLR | MASTER_ACK_ENAB |\n\t\t\t       RW_CMD, drvdata->base + GXP_I2CMCMD);\n\t\t}\n\t} else {\n\t\t \n\t\tif (drvdata->buf_remaining == 0) {\n\t\t\t \n\t\t\tdrvdata->msgs_remaining--;\n\t\t\tdrvdata->state = GXP_I2C_COMP;\n\t\t\tgxp_i2c_stop(drvdata);\n\t\t\treturn;\n\t\t}\n\t\tvalue = *drvdata->buf;\n\t\tvalue = value << 8;\n\t\t \n\t\tvalue |= MASTER_EVT_CLR;\n\t\tdrvdata->buf++;\n\t\tdrvdata->buf_remaining--;\n\t\tdrvdata->state = GXP_I2C_WDATA_PHASE;\n\t\twritew(value, drvdata->base + GXP_I2CMCMD);\n\t}\n}\n\nstatic void gxp_i2c_ack_data(struct gxp_i2c_drvdata *drvdata)\n{\n\tu8 value;\n\n\t \n\tvalue = readb(drvdata->base + GXP_I2CSNPDAT);\n\t*drvdata->buf = value;\n\tdrvdata->buf++;\n\tdrvdata->buf_remaining--;\n\n\tif (drvdata->buf_remaining == 0) {\n\t\t \n\t\tdrvdata->msgs_remaining--;\n\n\t\tif (drvdata->msgs_remaining == 0) {\n\t\t\t \n\t\t\tdrvdata->state = GXP_I2C_COMP;\n\t\t\tgxp_i2c_stop(drvdata);\n\t\t\treturn;\n\t\t}\n\t\t \n\t\tdrvdata->curr_msg++;\n\t\tgxp_i2c_restart(drvdata);\n\t\treturn;\n\t}\n\n\t \n\tdrvdata->state = GXP_I2C_RDATA_PHASE;\n\tif (drvdata->buf_remaining == 1) {\n\t\t \n\t\twriteb(MASTER_EVT_CLR | RW_CMD,\n\t\t       drvdata->base + GXP_I2CMCMD);\n\t} else {\n\t\t \n\t\twriteb(MASTER_EVT_CLR | MASTER_ACK_ENAB |\n\t\t       RW_CMD, drvdata->base + GXP_I2CMCMD);\n\t}\n}\n\nstatic void gxp_i2c_chk_data_ack(struct gxp_i2c_drvdata *drvdata)\n{\n\tu16 value;\n\n\tvalue = readb(drvdata->base + GXP_I2CSTAT);\n\tif (!(value & MASK_ACK)) {\n\t\t \n\t\tdrvdata->state = GXP_I2C_DATA_NACK;\n\t\tgxp_i2c_stop(drvdata);\n\t\treturn;\n\t}\n\n\t \n\tif (drvdata->buf_remaining == 0) {\n\t\t \n\t\tdrvdata->msgs_remaining--;\n\n\t\tif (drvdata->msgs_remaining == 0) {\n\t\t\t \n\t\t\tdrvdata->state = GXP_I2C_COMP;\n\t\t\tgxp_i2c_stop(drvdata);\n\t\t\treturn;\n\t\t}\n\t\t \n\t\tdrvdata->curr_msg++;\n\t\tgxp_i2c_restart(drvdata);\n\t\treturn;\n\t}\n\n\t \n\tvalue = *drvdata->buf;\n\tvalue = value << 8;\n\n\t \n\tvalue |= MASTER_EVT_CLR;\n\tdrvdata->buf++;\n\tdrvdata->buf_remaining--;\n\tdrvdata->state = GXP_I2C_WDATA_PHASE;\n\twritew(value, drvdata->base + GXP_I2CMCMD);\n}\n\nstatic bool gxp_i2c_slave_irq_handler(struct gxp_i2c_drvdata *drvdata)\n{\n\tu8 value;\n\tu8 buf;\n\tint ret;\n\n\tvalue = readb(drvdata->base + GXP_I2CEVTERR);\n\n\t \n\tif (value & MASK_SLAVE_CMD_EVENT) {\n\t\tvalue = readb(drvdata->base + GXP_I2CSTAT);\n\t\t \n\t\tif (value & MASK_STOP_EVENT) {\n\t\t\tif (drvdata->stopped == 0)\n\t\t\t\ti2c_slave_event(drvdata->slave, I2C_SLAVE_STOP, &buf);\n\t\t\twriteb(SLAVE_EVT_CLR | SNOOP_EVT_MASK |\n\t\t\t       SLAVE_ACK_ENAB | SLAVE_EVT_STALL, drvdata->base + GXP_I2CSCMD);\n\t\t\tdrvdata->stopped = 1;\n\t\t} else {\n\t\t\t \n\t\t\tdrvdata->stopped = 0;\n\t\t\tif (value & MASK_RW) {\n\t\t\t\ti2c_slave_event(drvdata->slave,\n\t\t\t\t\t\tI2C_SLAVE_READ_REQUESTED, &buf);\n\t\t\t\tvalue = buf << 8 | (SLAVE_EVT_CLR | SNOOP_EVT_MASK |\n\t\t\t\t\t\t    SLAVE_EVT_STALL);\n\t\t\t\twritew(value, drvdata->base + GXP_I2CSCMD);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tret = i2c_slave_event(drvdata->slave,\n\t\t\t\t\t\t      I2C_SLAVE_WRITE_REQUESTED, &buf);\n\t\t\t\tif (!ret) {\n\t\t\t\t\t \n\t\t\t\t\twriteb(SLAVE_EVT_CLR | SNOOP_EVT_MASK |\n\t\t\t\t\t       SLAVE_ACK_ENAB | SLAVE_EVT_STALL,\n\t\t\t\t\t       drvdata->base + GXP_I2CSCMD);\n\t\t\t\t} else {\n\t\t\t\t\t \n\t\t\t\t\twriteb(SLAVE_EVT_CLR | SNOOP_EVT_MASK |\n\t\t\t\t\t       SLAVE_EVT_STALL, drvdata->base + GXP_I2CSCMD);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else if (value & MASK_SLAVE_DATA_EVENT) {\n\t\tvalue = readb(drvdata->base + GXP_I2CSTAT);\n\t\t \n\t\tif (value & MASK_RW) {\n\t\t\t \n\t\t\tif (value & MASK_ACK) {\n\t\t\t\ti2c_slave_event(drvdata->slave,\n\t\t\t\t\t\tI2C_SLAVE_READ_PROCESSED, &buf);\n\t\t\t\tvalue = buf << 8 | (SLAVE_EVT_CLR | SNOOP_EVT_MASK |\n\t\t\t\t\t\t    SLAVE_EVT_STALL);\n\t\t\t\twritew(value, drvdata->base + GXP_I2CSCMD);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\twritew(SLAVE_EVT_CLR | SNOOP_EVT_MASK |\n\t\t\t\t       SLAVE_ACK_ENAB | SLAVE_EVT_STALL,\n\t\t\t\t       drvdata->base + GXP_I2CSCMD);\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tvalue = readb(drvdata->base + GXP_I2CSNPDAT);\n\t\t\tbuf = (uint8_t)value;\n\t\t\tret = i2c_slave_event(drvdata->slave,\n\t\t\t\t\t      I2C_SLAVE_WRITE_RECEIVED, &buf);\n\t\t\tif (!ret) {\n\t\t\t\t \n\t\t\t\twriteb(SLAVE_EVT_CLR | SNOOP_EVT_MASK |\n\t\t\t\t       SLAVE_ACK_ENAB | SLAVE_EVT_STALL,\n\t\t\t\t       drvdata->base + GXP_I2CSCMD);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\twriteb(SLAVE_EVT_CLR | SNOOP_EVT_MASK |\n\t\t\t\t       SLAVE_EVT_STALL, drvdata->base + GXP_I2CSCMD);\n\t\t\t}\n\t\t}\n\t} else {\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic irqreturn_t gxp_i2c_irq_handler(int irq, void *_drvdata)\n{\n\tstruct gxp_i2c_drvdata *drvdata = (struct gxp_i2c_drvdata *)_drvdata;\n\tu32 value;\n\n\t \n\tregmap_read(i2cg_map, GXP_I2CINTSTAT, &value);\n\tif (!(value & BIT(drvdata->engine)))\n\t\treturn IRQ_NONE;\n\n\tvalue = readb(drvdata->base + GXP_I2CEVTERR);\n\n\t \n\tif (value & ~(MASK_MASTER_EVENT | MASK_SLAVE_CMD_EVENT |\n\t\t\t\tMASK_SLAVE_DATA_EVENT)) {\n\t\t \n\t\twriteb(0x00, drvdata->base + GXP_I2CEVTERR);\n\t\tdrvdata->state = GXP_I2C_ERROR;\n\t\tgxp_i2c_stop(drvdata);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tif (IS_ENABLED(CONFIG_I2C_SLAVE)) {\n\t\t \n\t\tif (value & (MASK_SLAVE_CMD_EVENT | MASK_SLAVE_DATA_EVENT)) {\n\t\t\tif (gxp_i2c_slave_irq_handler(drvdata))\n\t\t\t\treturn IRQ_HANDLED;\n\t\t\treturn IRQ_NONE;\n\t\t}\n\t}\n\n\t \n\tswitch (drvdata->state) {\n\tcase GXP_I2C_ADDR_PHASE:\n\t\tgxp_i2c_chk_addr_ack(drvdata);\n\t\tbreak;\n\n\tcase GXP_I2C_RDATA_PHASE:\n\t\tgxp_i2c_ack_data(drvdata);\n\t\tbreak;\n\n\tcase GXP_I2C_WDATA_PHASE:\n\t\tgxp_i2c_chk_data_ack(drvdata);\n\t\tbreak;\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void gxp_i2c_init(struct gxp_i2c_drvdata *drvdata)\n{\n\tdrvdata->state = GXP_I2C_IDLE;\n\twriteb(2000000 / drvdata->t.bus_freq_hz,\n\t       drvdata->base + GXP_I2CFREQDIV);\n\twriteb(FILTER_CNT | FAIRNESS_CNT,\n\t       drvdata->base + GXP_I2CFLTFAIR);\n\twriteb(GXP_DATA_EDGE_RST_CTRL, drvdata->base + GXP_I2CTMOEDG);\n\twriteb(0x00, drvdata->base + GXP_I2CCYCTIM);\n\twriteb(0x00, drvdata->base + GXP_I2CSNPAA);\n\twriteb(0x00, drvdata->base + GXP_I2CADVFEAT);\n\twriteb(SNOOP_EVT_CLR | SLAVE_EVT_CLR | SNOOP_EVT_MASK |\n\t       SLAVE_EVT_MASK, drvdata->base + GXP_I2CSCMD);\n\twriteb(MASTER_EVT_CLR, drvdata->base + GXP_I2CMCMD);\n\twriteb(0x00, drvdata->base + GXP_I2CEVTERR);\n\twriteb(0x00, drvdata->base + GXP_I2COWNADR);\n}\n\nstatic int gxp_i2c_probe(struct platform_device *pdev)\n{\n\tstruct gxp_i2c_drvdata *drvdata;\n\tint rc;\n\tstruct i2c_adapter *adapter;\n\n\tif (!i2cg_map) {\n\t\ti2cg_map = syscon_regmap_lookup_by_phandle(pdev->dev.of_node,\n\t\t\t\t\t\t\t   \"hpe,sysreg\");\n\t\tif (IS_ERR(i2cg_map)) {\n\t\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(i2cg_map),\n\t\t\t\t\t     \"failed to map i2cg_handle\\n\");\n\t\t}\n\n\t\t \n\t\tregmap_update_bits(i2cg_map, GXP_I2CINTEN, 0x00000FFF, 0);\n\t}\n\n\tdrvdata = devm_kzalloc(&pdev->dev, sizeof(*drvdata),\n\t\t\t       GFP_KERNEL);\n\tif (!drvdata)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, drvdata);\n\tdrvdata->dev = &pdev->dev;\n\tinit_completion(&drvdata->completion);\n\n\tdrvdata->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(drvdata->base))\n\t\treturn PTR_ERR(drvdata->base);\n\n\t \n\tdrvdata->engine = ((size_t)drvdata->base & 0xf00) >> 8;\n\n\tif (drvdata->engine >= GXP_MAX_I2C_ENGINE) {\n\t\treturn dev_err_probe(&pdev->dev, -EINVAL, \"i2c engine% is unsupported\\n\",\n\t\t\tdrvdata->engine);\n\t}\n\n\trc = platform_get_irq(pdev, 0);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tdrvdata->irq = rc;\n\trc = devm_request_irq(&pdev->dev, drvdata->irq, gxp_i2c_irq_handler,\n\t\t\t      IRQF_SHARED, gxp_i2c_name[drvdata->engine], drvdata);\n\tif (rc < 0)\n\t\treturn dev_err_probe(&pdev->dev, rc, \"irq request failed\\n\");\n\n\ti2c_parse_fw_timings(&pdev->dev, &drvdata->t, true);\n\n\tgxp_i2c_init(drvdata);\n\n\t \n\tregmap_update_bits(i2cg_map, GXP_I2CINTEN, BIT(drvdata->engine),\n\t\t\t   BIT(drvdata->engine));\n\n\tadapter = &drvdata->adapter;\n\ti2c_set_adapdata(adapter, drvdata);\n\n\tadapter->owner = THIS_MODULE;\n\tstrscpy(adapter->name, \"HPE GXP I2C adapter\", sizeof(adapter->name));\n\tadapter->algo = &gxp_i2c_algo;\n\tadapter->dev.parent = &pdev->dev;\n\tadapter->dev.of_node = pdev->dev.of_node;\n\n\trc = i2c_add_adapter(adapter);\n\tif (rc)\n\t\treturn dev_err_probe(&pdev->dev, rc, \"i2c add adapter failed\\n\");\n\n\treturn 0;\n}\n\nstatic void gxp_i2c_remove(struct platform_device *pdev)\n{\n\tstruct gxp_i2c_drvdata *drvdata = platform_get_drvdata(pdev);\n\n\t \n\tregmap_update_bits(i2cg_map, GXP_I2CINTEN, BIT(drvdata->engine), 0);\n\ti2c_del_adapter(&drvdata->adapter);\n}\n\nstatic const struct of_device_id gxp_i2c_of_match[] = {\n\t{ .compatible = \"hpe,gxp-i2c\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, gxp_i2c_of_match);\n\nstatic struct platform_driver gxp_i2c_driver = {\n\t.probe\t= gxp_i2c_probe,\n\t.remove_new = gxp_i2c_remove,\n\t.driver = {\n\t\t.name = \"gxp-i2c\",\n\t\t.of_match_table = gxp_i2c_of_match,\n\t},\n};\nmodule_platform_driver(gxp_i2c_driver);\n\nMODULE_AUTHOR(\"Nick Hawkins <nick.hawkins@hpe.com>\");\nMODULE_DESCRIPTION(\"HPE GXP I2C bus driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}