{
  "module_name": "i2c-axxia.c",
  "hash_id": "e19dd01f889e3424559bda905742bf8d6b33a4d8bc5f0394cc3e602cec8809cd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-axxia.c",
  "human_readable_source": "\n \n#include <linux/clk.h>\n#include <linux/clkdev.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/i2c.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/platform_device.h>\n\n#define SCL_WAIT_TIMEOUT_NS 25000000\n#define I2C_XFER_TIMEOUT    (msecs_to_jiffies(250))\n#define I2C_STOP_TIMEOUT    (msecs_to_jiffies(100))\n#define FIFO_SIZE           8\n#define SEQ_LEN             2\n\n#define GLOBAL_CONTROL\t\t0x00\n#define   GLOBAL_MST_EN         BIT(0)\n#define   GLOBAL_SLV_EN         BIT(1)\n#define   GLOBAL_IBML_EN        BIT(2)\n#define INTERRUPT_STATUS\t0x04\n#define INTERRUPT_ENABLE\t0x08\n#define   INT_SLV               BIT(1)\n#define   INT_MST               BIT(0)\n#define WAIT_TIMER_CONTROL\t0x0c\n#define   WT_EN\t\t\tBIT(15)\n#define   WT_VALUE(_x)\t\t((_x) & 0x7fff)\n#define IBML_TIMEOUT\t\t0x10\n#define IBML_LOW_MEXT\t\t0x14\n#define IBML_LOW_SEXT\t\t0x18\n#define TIMER_CLOCK_DIV\t\t0x1c\n#define I2C_BUS_MONITOR\t\t0x20\n#define   BM_SDAC\t\tBIT(3)\n#define   BM_SCLC\t\tBIT(2)\n#define   BM_SDAS\t\tBIT(1)\n#define   BM_SCLS\t\tBIT(0)\n#define SOFT_RESET\t\t0x24\n#define MST_COMMAND\t\t0x28\n#define   CMD_BUSY\t\t(1<<3)\n#define   CMD_MANUAL\t\t(0x00 | CMD_BUSY)\n#define   CMD_AUTO\t\t(0x01 | CMD_BUSY)\n#define   CMD_SEQUENCE\t\t(0x02 | CMD_BUSY)\n#define MST_RX_XFER\t\t0x2c\n#define MST_TX_XFER\t\t0x30\n#define MST_ADDR_1\t\t0x34\n#define MST_ADDR_2\t\t0x38\n#define MST_DATA\t\t0x3c\n#define MST_TX_FIFO\t\t0x40\n#define MST_RX_FIFO\t\t0x44\n#define MST_INT_ENABLE\t\t0x48\n#define MST_INT_STATUS\t\t0x4c\n#define   MST_STATUS_RFL\t(1 << 13)  \n#define   MST_STATUS_TFL\t(1 << 12)  \n#define   MST_STATUS_SNS\t(1 << 11)  \n#define   MST_STATUS_SS\t\t(1 << 10)  \n#define   MST_STATUS_SCC\t(1 << 9)   \n#define   MST_STATUS_IP\t\t(1 << 8)   \n#define   MST_STATUS_TSS\t(1 << 7)   \n#define   MST_STATUS_AL\t\t(1 << 6)   \n#define   MST_STATUS_ND\t\t(1 << 5)   \n#define   MST_STATUS_NA\t\t(1 << 4)   \n#define   MST_STATUS_NAK\t(MST_STATUS_NA | \\\n\t\t\t\t MST_STATUS_ND)\n#define   MST_STATUS_ERR\t(MST_STATUS_NAK | \\\n\t\t\t\t MST_STATUS_AL  | \\\n\t\t\t\t MST_STATUS_IP)\n#define MST_TX_BYTES_XFRD\t0x50\n#define MST_RX_BYTES_XFRD\t0x54\n#define SLV_ADDR_DEC_CTL\t0x58\n#define   SLV_ADDR_DEC_GCE\tBIT(0)   \n#define   SLV_ADDR_DEC_OGCE\tBIT(1)   \n#define   SLV_ADDR_DEC_SA1E\tBIT(2)   \n#define   SLV_ADDR_DEC_SA1M\tBIT(3)   \n#define   SLV_ADDR_DEC_SA2E\tBIT(4)   \n#define   SLV_ADDR_DEC_SA2M\tBIT(5)   \n#define SLV_ADDR_1\t\t0x5c\n#define SLV_ADDR_2\t\t0x60\n#define SLV_RX_CTL\t\t0x64\n#define   SLV_RX_ACSA1\t\tBIT(0)   \n#define   SLV_RX_ACSA2\t\tBIT(1)   \n#define   SLV_RX_ACGCA\t\tBIT(2)   \n#define SLV_DATA\t\t0x68\n#define SLV_RX_FIFO\t\t0x6c\n#define   SLV_FIFO_DV1\t\tBIT(0)   \n#define   SLV_FIFO_DV2\t\tBIT(1)   \n#define   SLV_FIFO_AS\t\tBIT(2)   \n#define   SLV_FIFO_TNAK\t\tBIT(3)   \n#define   SLV_FIFO_STRC\t\tBIT(4)   \n#define   SLV_FIFO_RSC\t\tBIT(5)   \n#define   SLV_FIFO_STPC\t\tBIT(6)   \n#define   SLV_FIFO_DV\t\t(SLV_FIFO_DV1 | SLV_FIFO_DV2)\n#define SLV_INT_ENABLE\t\t0x70\n#define SLV_INT_STATUS\t\t0x74\n#define   SLV_STATUS_RFH\tBIT(0)   \n#define   SLV_STATUS_WTC\tBIT(1)   \n#define   SLV_STATUS_SRS1\tBIT(2)   \n#define   SLV_STATUS_SRRS1\tBIT(3)   \n#define   SLV_STATUS_SRND1\tBIT(4)   \n#define   SLV_STATUS_SRC1\tBIT(5)   \n#define   SLV_STATUS_SRAT1\tBIT(6)   \n#define   SLV_STATUS_SRDRE1\tBIT(7)   \n#define SLV_READ_DUMMY\t\t0x78\n#define SCL_HIGH_PERIOD\t\t0x80\n#define SCL_LOW_PERIOD\t\t0x84\n#define SPIKE_FLTR_LEN\t\t0x88\n#define SDA_SETUP_TIME\t\t0x8c\n#define SDA_HOLD_TIME\t\t0x90\n\n \nstruct axxia_i2c_dev {\n\tvoid __iomem *base;\n\tstruct i2c_msg *msg;\n\tstruct i2c_msg *msg_r;\n\tsize_t msg_xfrd;\n\tsize_t msg_xfrd_r;\n\tint msg_err;\n\tstruct completion msg_complete;\n\tstruct device *dev;\n\tstruct i2c_adapter adapter;\n\tstruct clk *i2c_clk;\n\tu32 bus_clk_rate;\n\tbool last;\n\tstruct i2c_client *slave;\n\tint irq;\n};\n\nstatic void i2c_int_disable(struct axxia_i2c_dev *idev, u32 mask)\n{\n\tu32 int_en;\n\n\tint_en = readl(idev->base + MST_INT_ENABLE);\n\twritel(int_en & ~mask, idev->base + MST_INT_ENABLE);\n}\n\nstatic void i2c_int_enable(struct axxia_i2c_dev *idev, u32 mask)\n{\n\tu32 int_en;\n\n\tint_en = readl(idev->base + MST_INT_ENABLE);\n\twritel(int_en | mask, idev->base + MST_INT_ENABLE);\n}\n\n \nstatic u32 ns_to_clk(u64 ns, u32 clk_mhz)\n{\n\treturn div_u64(ns * clk_mhz, 1000);\n}\n\nstatic int axxia_i2c_init(struct axxia_i2c_dev *idev)\n{\n\tu32 divisor = clk_get_rate(idev->i2c_clk) / idev->bus_clk_rate;\n\tu32 clk_mhz = clk_get_rate(idev->i2c_clk) / 1000000;\n\tu32 t_setup;\n\tu32 t_high, t_low;\n\tu32 tmo_clk;\n\tu32 prescale;\n\tunsigned long timeout;\n\n\tdev_dbg(idev->dev, \"rate=%uHz per_clk=%uMHz -> ratio=1:%u\\n\",\n\t\tidev->bus_clk_rate, clk_mhz, divisor);\n\n\t \n\twritel(0x01, idev->base + SOFT_RESET);\n\ttimeout = jiffies + msecs_to_jiffies(100);\n\twhile (readl(idev->base + SOFT_RESET) & 1) {\n\t\tif (time_after(jiffies, timeout)) {\n\t\t\tdev_warn(idev->dev, \"Soft reset failed\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\twritel(0x1, idev->base + GLOBAL_CONTROL);\n\n\tif (idev->bus_clk_rate <= I2C_MAX_STANDARD_MODE_FREQ) {\n\t\t \n\t\tt_high = divisor * 1 / 2;\n\t\tt_low = divisor * 1 / 2;\n\t\tt_setup = ns_to_clk(250, clk_mhz);\n\t} else {\n\t\t \n\t\tt_high = divisor * 1 / 3;\n\t\tt_low = divisor * 2 / 3;\n\t\tt_setup = ns_to_clk(100, clk_mhz);\n\t}\n\n\t \n\twritel(t_high, idev->base + SCL_HIGH_PERIOD);\n\t \n\twritel(t_low, idev->base + SCL_LOW_PERIOD);\n\t \n\twritel(t_setup, idev->base + SDA_SETUP_TIME);\n\t \n\twritel(ns_to_clk(300, clk_mhz), idev->base + SDA_HOLD_TIME);\n\t \n\twritel(ns_to_clk(50, clk_mhz), idev->base + SPIKE_FLTR_LEN);\n\n\t \n\ttmo_clk = ns_to_clk(SCL_WAIT_TIMEOUT_NS, clk_mhz);\n\n\t \n\tfor (prescale = 0; prescale < 15; ++prescale) {\n\t\tif (tmo_clk <= 0x7fff)\n\t\t\tbreak;\n\t\ttmo_clk >>= 1;\n\t}\n\tif (tmo_clk > 0x7fff)\n\t\ttmo_clk = 0x7fff;\n\n\t \n\twritel(prescale, idev->base + TIMER_CLOCK_DIV);\n\t \n\twritel(WT_EN | WT_VALUE(tmo_clk), idev->base + WAIT_TIMER_CONTROL);\n\n\t \n\ti2c_int_disable(idev, ~0);\n\n\t \n\twritel(0x01, idev->base + INTERRUPT_ENABLE);\n\n\treturn 0;\n}\n\nstatic int i2c_m_rd(const struct i2c_msg *msg)\n{\n\treturn (msg->flags & I2C_M_RD) != 0;\n}\n\nstatic int i2c_m_ten(const struct i2c_msg *msg)\n{\n\treturn (msg->flags & I2C_M_TEN) != 0;\n}\n\nstatic int i2c_m_recv_len(const struct i2c_msg *msg)\n{\n\treturn (msg->flags & I2C_M_RECV_LEN) != 0;\n}\n\n \nstatic int axxia_i2c_empty_rx_fifo(struct axxia_i2c_dev *idev)\n{\n\tstruct i2c_msg *msg = idev->msg_r;\n\tsize_t rx_fifo_avail = readl(idev->base + MST_RX_FIFO);\n\tint bytes_to_transfer = min(rx_fifo_avail, msg->len - idev->msg_xfrd_r);\n\n\twhile (bytes_to_transfer-- > 0) {\n\t\tint c = readl(idev->base + MST_DATA);\n\n\t\tif (idev->msg_xfrd_r == 0 && i2c_m_recv_len(msg)) {\n\t\t\t \n\t\t\tif (c <= 0 || c > I2C_SMBUS_BLOCK_MAX) {\n\t\t\t\tidev->msg_err = -EPROTO;\n\t\t\t\ti2c_int_disable(idev, ~MST_STATUS_TSS);\n\t\t\t\tcomplete(&idev->msg_complete);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmsg->len = 1 + c;\n\t\t\twritel(msg->len, idev->base + MST_RX_XFER);\n\t\t}\n\t\tmsg->buf[idev->msg_xfrd_r++] = c;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int axxia_i2c_fill_tx_fifo(struct axxia_i2c_dev *idev)\n{\n\tstruct i2c_msg *msg = idev->msg;\n\tsize_t tx_fifo_avail = FIFO_SIZE - readl(idev->base + MST_TX_FIFO);\n\tint bytes_to_transfer = min(tx_fifo_avail, msg->len - idev->msg_xfrd);\n\tint ret = msg->len - idev->msg_xfrd - bytes_to_transfer;\n\n\twhile (bytes_to_transfer-- > 0)\n\t\twritel(msg->buf[idev->msg_xfrd++], idev->base + MST_DATA);\n\n\treturn ret;\n}\n\nstatic void axxia_i2c_slv_fifo_event(struct axxia_i2c_dev *idev)\n{\n\tu32 fifo_status = readl(idev->base + SLV_RX_FIFO);\n\tu8 val;\n\n\tdev_dbg(idev->dev, \"slave irq fifo_status=0x%x\\n\", fifo_status);\n\n\tif (fifo_status & SLV_FIFO_DV1) {\n\t\tif (fifo_status & SLV_FIFO_STRC)\n\t\t\ti2c_slave_event(idev->slave,\n\t\t\t\t\tI2C_SLAVE_WRITE_REQUESTED, &val);\n\n\t\tval = readl(idev->base + SLV_DATA);\n\t\ti2c_slave_event(idev->slave, I2C_SLAVE_WRITE_RECEIVED, &val);\n\t}\n\tif (fifo_status & SLV_FIFO_STPC) {\n\t\treadl(idev->base + SLV_DATA);  \n\t\ti2c_slave_event(idev->slave, I2C_SLAVE_STOP, &val);\n\t}\n\tif (fifo_status & SLV_FIFO_RSC)\n\t\treadl(idev->base + SLV_DATA);  \n}\n\nstatic irqreturn_t axxia_i2c_slv_isr(struct axxia_i2c_dev *idev)\n{\n\tu32 status = readl(idev->base + SLV_INT_STATUS);\n\tu8 val;\n\n\tdev_dbg(idev->dev, \"slave irq status=0x%x\\n\", status);\n\n\tif (status & SLV_STATUS_RFH)\n\t\taxxia_i2c_slv_fifo_event(idev);\n\tif (status & SLV_STATUS_SRS1) {\n\t\ti2c_slave_event(idev->slave, I2C_SLAVE_READ_REQUESTED, &val);\n\t\twritel(val, idev->base + SLV_DATA);\n\t}\n\tif (status & SLV_STATUS_SRND1) {\n\t\ti2c_slave_event(idev->slave, I2C_SLAVE_READ_PROCESSED, &val);\n\t\twritel(val, idev->base + SLV_DATA);\n\t}\n\tif (status & SLV_STATUS_SRC1)\n\t\ti2c_slave_event(idev->slave, I2C_SLAVE_STOP, &val);\n\n\twritel(INT_SLV, idev->base + INTERRUPT_STATUS);\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t axxia_i2c_isr(int irq, void *_dev)\n{\n\tstruct axxia_i2c_dev *idev = _dev;\n\tirqreturn_t ret = IRQ_NONE;\n\tu32 status;\n\n\tstatus = readl(idev->base + INTERRUPT_STATUS);\n\n\tif (status & INT_SLV)\n\t\tret = axxia_i2c_slv_isr(idev);\n\tif (!(status & INT_MST))\n\t\treturn ret;\n\n\t \n\tstatus = readl(idev->base + MST_INT_STATUS);\n\n\tif (!idev->msg) {\n\t\tdev_warn(idev->dev, \"unexpected interrupt\\n\");\n\t\tgoto out;\n\t}\n\n\t \n\tif (i2c_m_rd(idev->msg_r) && (status & MST_STATUS_RFL))\n\t\taxxia_i2c_empty_rx_fifo(idev);\n\n\t \n\tif (!i2c_m_rd(idev->msg) && (status & MST_STATUS_TFL)) {\n\t\tif (axxia_i2c_fill_tx_fifo(idev) == 0)\n\t\t\ti2c_int_disable(idev, MST_STATUS_TFL);\n\t}\n\n\tif (unlikely(status & MST_STATUS_ERR)) {\n\t\t \n\t\ti2c_int_disable(idev, ~0);\n\t\tif (status & MST_STATUS_AL)\n\t\t\tidev->msg_err = -EAGAIN;\n\t\telse if (status & MST_STATUS_NAK)\n\t\t\tidev->msg_err = -ENXIO;\n\t\telse\n\t\t\tidev->msg_err = -EIO;\n\t\tdev_dbg(idev->dev, \"error %#x, addr=%#x rx=%u/%u tx=%u/%u\\n\",\n\t\t\tstatus,\n\t\t\tidev->msg->addr,\n\t\t\treadl(idev->base + MST_RX_BYTES_XFRD),\n\t\t\treadl(idev->base + MST_RX_XFER),\n\t\t\treadl(idev->base + MST_TX_BYTES_XFRD),\n\t\t\treadl(idev->base + MST_TX_XFER));\n\t\tcomplete(&idev->msg_complete);\n\t} else if (status & MST_STATUS_SCC) {\n\t\t \n\t\ti2c_int_disable(idev, ~MST_STATUS_TSS);\n\t\tcomplete(&idev->msg_complete);\n\t} else if (status & (MST_STATUS_SNS | MST_STATUS_SS)) {\n\t\t \n\t\tint mask = idev->last ? ~0 : ~MST_STATUS_TSS;\n\n\t\ti2c_int_disable(idev, mask);\n\t\tif (i2c_m_rd(idev->msg_r) && idev->msg_xfrd_r < idev->msg_r->len)\n\t\t\taxxia_i2c_empty_rx_fifo(idev);\n\t\tcomplete(&idev->msg_complete);\n\t} else if (status & MST_STATUS_TSS) {\n\t\t \n\t\tidev->msg_err = -ETIMEDOUT;\n\t\ti2c_int_disable(idev, ~MST_STATUS_TSS);\n\t\tcomplete(&idev->msg_complete);\n\t}\n\nout:\n\t \n\twritel(INT_MST, idev->base + INTERRUPT_STATUS);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void axxia_i2c_set_addr(struct axxia_i2c_dev *idev, struct i2c_msg *msg)\n{\n\tu32 addr_1, addr_2;\n\n\tif (i2c_m_ten(msg)) {\n\t\t \n\t\taddr_1 = 0xF0 | ((msg->addr >> 7) & 0x06);\n\t\tif (i2c_m_rd(msg))\n\t\t\taddr_1 |= 1;\t \n\t\taddr_2 = msg->addr & 0xFF;\n\t} else {\n\t\t \n\t\taddr_1 = i2c_8bit_addr_from_msg(msg);\n\t\taddr_2 = 0;\n\t}\n\n\twritel(addr_1, idev->base + MST_ADDR_1);\n\twritel(addr_2, idev->base + MST_ADDR_2);\n}\n\n \nstatic int axxia_i2c_handle_seq_nak(struct axxia_i2c_dev *idev)\n{\n\tunsigned long timeout = jiffies + I2C_XFER_TIMEOUT;\n\n\tdo {\n\t\tif ((readl(idev->base + MST_COMMAND) & CMD_BUSY) == 0)\n\t\t\treturn 0;\n\t\tusleep_range(1, 100);\n\t} while (time_before(jiffies, timeout));\n\n\treturn -ETIMEDOUT;\n}\n\nstatic int axxia_i2c_xfer_seq(struct axxia_i2c_dev *idev, struct i2c_msg msgs[])\n{\n\tu32 int_mask = MST_STATUS_ERR | MST_STATUS_SS | MST_STATUS_RFL;\n\tu32 rlen = i2c_m_recv_len(&msgs[1]) ? I2C_SMBUS_BLOCK_MAX : msgs[1].len;\n\tunsigned long time_left;\n\n\taxxia_i2c_set_addr(idev, &msgs[0]);\n\n\twritel(msgs[0].len, idev->base + MST_TX_XFER);\n\twritel(rlen, idev->base + MST_RX_XFER);\n\n\tidev->msg = &msgs[0];\n\tidev->msg_r = &msgs[1];\n\tidev->msg_xfrd = 0;\n\tidev->msg_xfrd_r = 0;\n\tidev->last = true;\n\taxxia_i2c_fill_tx_fifo(idev);\n\n\twritel(CMD_SEQUENCE, idev->base + MST_COMMAND);\n\n\treinit_completion(&idev->msg_complete);\n\ti2c_int_enable(idev, int_mask);\n\n\ttime_left = wait_for_completion_timeout(&idev->msg_complete,\n\t\t\t\t\t\tI2C_XFER_TIMEOUT);\n\n\tif (idev->msg_err == -ENXIO) {\n\t\tif (axxia_i2c_handle_seq_nak(idev))\n\t\t\taxxia_i2c_init(idev);\n\t} else if (readl(idev->base + MST_COMMAND) & CMD_BUSY) {\n\t\tdev_warn(idev->dev, \"busy after xfer\\n\");\n\t}\n\n\tif (time_left == 0) {\n\t\tidev->msg_err = -ETIMEDOUT;\n\t\ti2c_recover_bus(&idev->adapter);\n\t\taxxia_i2c_init(idev);\n\t}\n\n\tif (unlikely(idev->msg_err) && idev->msg_err != -ENXIO)\n\t\taxxia_i2c_init(idev);\n\n\treturn idev->msg_err;\n}\n\nstatic int axxia_i2c_xfer_msg(struct axxia_i2c_dev *idev, struct i2c_msg *msg,\n\t\t\t      bool last)\n{\n\tu32 int_mask = MST_STATUS_ERR;\n\tu32 rx_xfer, tx_xfer;\n\tunsigned long time_left;\n\tunsigned int wt_value;\n\n\tidev->msg = msg;\n\tidev->msg_r = msg;\n\tidev->msg_xfrd = 0;\n\tidev->msg_xfrd_r = 0;\n\tidev->last = last;\n\treinit_completion(&idev->msg_complete);\n\n\taxxia_i2c_set_addr(idev, msg);\n\n\tif (i2c_m_rd(msg)) {\n\t\t \n\t\trx_xfer = i2c_m_recv_len(msg) ? I2C_SMBUS_BLOCK_MAX : msg->len;\n\t\ttx_xfer = 0;\n\t} else {\n\t\t \n\t\trx_xfer = 0;\n\t\ttx_xfer = msg->len;\n\t}\n\n\twritel(rx_xfer, idev->base + MST_RX_XFER);\n\twritel(tx_xfer, idev->base + MST_TX_XFER);\n\n\tif (i2c_m_rd(msg))\n\t\tint_mask |= MST_STATUS_RFL;\n\telse if (axxia_i2c_fill_tx_fifo(idev) != 0)\n\t\tint_mask |= MST_STATUS_TFL;\n\n\twt_value = WT_VALUE(readl(idev->base + WAIT_TIMER_CONTROL));\n\t \n\twritel(wt_value, idev->base + WAIT_TIMER_CONTROL);\n\t \n\tif (idev->msg_err)\n\t\tgoto out;\n\n\tif (!last) {\n\t\twritel(CMD_MANUAL, idev->base + MST_COMMAND);\n\t\tint_mask |= MST_STATUS_SNS;\n\t} else {\n\t\twritel(CMD_AUTO, idev->base + MST_COMMAND);\n\t\tint_mask |= MST_STATUS_SS;\n\t}\n\n\twritel(WT_EN | wt_value, idev->base + WAIT_TIMER_CONTROL);\n\n\ti2c_int_enable(idev, int_mask);\n\n\ttime_left = wait_for_completion_timeout(&idev->msg_complete,\n\t\t\t\t\t      I2C_XFER_TIMEOUT);\n\n\ti2c_int_disable(idev, int_mask);\n\n\tif (readl(idev->base + MST_COMMAND) & CMD_BUSY)\n\t\tdev_warn(idev->dev, \"busy after xfer\\n\");\n\n\tif (time_left == 0) {\n\t\tidev->msg_err = -ETIMEDOUT;\n\t\ti2c_recover_bus(&idev->adapter);\n\t\taxxia_i2c_init(idev);\n\t}\n\nout:\n\tif (unlikely(idev->msg_err) && idev->msg_err != -ENXIO &&\n\t\t\tidev->msg_err != -ETIMEDOUT)\n\t\taxxia_i2c_init(idev);\n\n\treturn idev->msg_err;\n}\n\n \nstatic bool axxia_i2c_sequence_ok(struct i2c_msg msgs[], int num)\n{\n\treturn num == SEQ_LEN && !i2c_m_rd(&msgs[0]) && i2c_m_rd(&msgs[1]) &&\n\t       msgs[0].len > 0 && msgs[0].len <= FIFO_SIZE &&\n\t       msgs[1].len > 0 && msgs[0].addr == msgs[1].addr;\n}\n\nstatic int\naxxia_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg msgs[], int num)\n{\n\tstruct axxia_i2c_dev *idev = i2c_get_adapdata(adap);\n\tint i;\n\tint ret = 0;\n\n\tidev->msg_err = 0;\n\n\tif (axxia_i2c_sequence_ok(msgs, num)) {\n\t\tret = axxia_i2c_xfer_seq(idev, msgs);\n\t\treturn ret ? : SEQ_LEN;\n\t}\n\n\ti2c_int_enable(idev, MST_STATUS_TSS);\n\n\tfor (i = 0; ret == 0 && i < num; ++i)\n\t\tret = axxia_i2c_xfer_msg(idev, &msgs[i], i == (num - 1));\n\n\treturn ret ? : i;\n}\n\nstatic int axxia_i2c_get_scl(struct i2c_adapter *adap)\n{\n\tstruct axxia_i2c_dev *idev = i2c_get_adapdata(adap);\n\n\treturn !!(readl(idev->base + I2C_BUS_MONITOR) & BM_SCLS);\n}\n\nstatic void axxia_i2c_set_scl(struct i2c_adapter *adap, int val)\n{\n\tstruct axxia_i2c_dev *idev = i2c_get_adapdata(adap);\n\tu32 tmp;\n\n\t \n\ttmp = readl(idev->base + I2C_BUS_MONITOR) & BM_SDAC;\n\tif (!val)\n\t\ttmp |= BM_SCLC;\n\twritel(tmp, idev->base + I2C_BUS_MONITOR);\n}\n\nstatic int axxia_i2c_get_sda(struct i2c_adapter *adap)\n{\n\tstruct axxia_i2c_dev *idev = i2c_get_adapdata(adap);\n\n\treturn !!(readl(idev->base + I2C_BUS_MONITOR) & BM_SDAS);\n}\n\nstatic struct i2c_bus_recovery_info axxia_i2c_recovery_info = {\n\t.recover_bus = i2c_generic_scl_recovery,\n\t.get_scl = axxia_i2c_get_scl,\n\t.set_scl = axxia_i2c_set_scl,\n\t.get_sda = axxia_i2c_get_sda,\n};\n\nstatic u32 axxia_i2c_func(struct i2c_adapter *adap)\n{\n\tu32 caps = (I2C_FUNC_I2C | I2C_FUNC_10BIT_ADDR |\n\t\t    I2C_FUNC_SMBUS_EMUL | I2C_FUNC_SMBUS_BLOCK_DATA);\n\treturn caps;\n}\n\nstatic int axxia_i2c_reg_slave(struct i2c_client *slave)\n{\n\tstruct axxia_i2c_dev *idev = i2c_get_adapdata(slave->adapter);\n\tu32 slv_int_mask = SLV_STATUS_RFH;\n\tu32 dec_ctl;\n\n\tif (idev->slave)\n\t\treturn -EBUSY;\n\n\tidev->slave = slave;\n\n\t \n\twritel(GLOBAL_MST_EN | GLOBAL_SLV_EN, idev->base + GLOBAL_CONTROL);\n\twritel(INT_MST | INT_SLV, idev->base + INTERRUPT_ENABLE);\n\n\t \n\tdec_ctl = SLV_ADDR_DEC_SA1E;\n\tif (slave->flags & I2C_CLIENT_TEN)\n\t\tdec_ctl |= SLV_ADDR_DEC_SA1M;\n\n\twritel(SLV_RX_ACSA1, idev->base + SLV_RX_CTL);\n\twritel(dec_ctl, idev->base + SLV_ADDR_DEC_CTL);\n\twritel(slave->addr, idev->base + SLV_ADDR_1);\n\n\t \n\tslv_int_mask |= SLV_STATUS_SRS1 | SLV_STATUS_SRRS1 | SLV_STATUS_SRND1;\n\tslv_int_mask |= SLV_STATUS_SRC1;\n\twritel(slv_int_mask, idev->base + SLV_INT_ENABLE);\n\n\treturn 0;\n}\n\nstatic int axxia_i2c_unreg_slave(struct i2c_client *slave)\n{\n\tstruct axxia_i2c_dev *idev = i2c_get_adapdata(slave->adapter);\n\n\t \n\twritel(GLOBAL_MST_EN, idev->base + GLOBAL_CONTROL);\n\twritel(INT_MST, idev->base + INTERRUPT_ENABLE);\n\n\tsynchronize_irq(idev->irq);\n\n\tidev->slave = NULL;\n\n\treturn 0;\n}\n\nstatic const struct i2c_algorithm axxia_i2c_algo = {\n\t.master_xfer = axxia_i2c_xfer,\n\t.functionality = axxia_i2c_func,\n\t.reg_slave = axxia_i2c_reg_slave,\n\t.unreg_slave = axxia_i2c_unreg_slave,\n};\n\nstatic const struct i2c_adapter_quirks axxia_i2c_quirks = {\n\t.max_read_len = 255,\n\t.max_write_len = 255,\n};\n\nstatic int axxia_i2c_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct axxia_i2c_dev *idev = NULL;\n\tvoid __iomem *base;\n\tint ret = 0;\n\n\tidev = devm_kzalloc(&pdev->dev, sizeof(*idev), GFP_KERNEL);\n\tif (!idev)\n\t\treturn -ENOMEM;\n\n\tbase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\tidev->irq = platform_get_irq(pdev, 0);\n\tif (idev->irq < 0)\n\t\treturn idev->irq;\n\n\tidev->i2c_clk = devm_clk_get(&pdev->dev, \"i2c\");\n\tif (IS_ERR(idev->i2c_clk)) {\n\t\tdev_err(&pdev->dev, \"missing clock\\n\");\n\t\treturn PTR_ERR(idev->i2c_clk);\n\t}\n\n\tidev->base = base;\n\tidev->dev = &pdev->dev;\n\tinit_completion(&idev->msg_complete);\n\n\tof_property_read_u32(np, \"clock-frequency\", &idev->bus_clk_rate);\n\tif (idev->bus_clk_rate == 0)\n\t\tidev->bus_clk_rate = I2C_MAX_STANDARD_MODE_FREQ;\t \n\n\tret = clk_prepare_enable(idev->i2c_clk);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to enable clock\\n\");\n\t\treturn ret;\n\t}\n\n\tret = axxia_i2c_init(idev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to initialize\\n\");\n\t\tgoto error_disable_clk;\n\t}\n\n\tret = devm_request_irq(&pdev->dev, idev->irq, axxia_i2c_isr, 0,\n\t\t\t       pdev->name, idev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to claim IRQ%d\\n\", idev->irq);\n\t\tgoto error_disable_clk;\n\t}\n\n\ti2c_set_adapdata(&idev->adapter, idev);\n\tstrscpy(idev->adapter.name, pdev->name, sizeof(idev->adapter.name));\n\tidev->adapter.owner = THIS_MODULE;\n\tidev->adapter.algo = &axxia_i2c_algo;\n\tidev->adapter.bus_recovery_info = &axxia_i2c_recovery_info;\n\tidev->adapter.quirks = &axxia_i2c_quirks;\n\tidev->adapter.dev.parent = &pdev->dev;\n\tidev->adapter.dev.of_node = pdev->dev.of_node;\n\n\tplatform_set_drvdata(pdev, idev);\n\n\tret = i2c_add_adapter(&idev->adapter);\n\tif (ret)\n\t\tgoto error_disable_clk;\n\n\treturn 0;\n\nerror_disable_clk:\n\tclk_disable_unprepare(idev->i2c_clk);\n\treturn ret;\n}\n\nstatic void axxia_i2c_remove(struct platform_device *pdev)\n{\n\tstruct axxia_i2c_dev *idev = platform_get_drvdata(pdev);\n\n\tclk_disable_unprepare(idev->i2c_clk);\n\ti2c_del_adapter(&idev->adapter);\n}\n\n \nstatic const struct of_device_id axxia_i2c_of_match[] = {\n\t{ .compatible = \"lsi,api2c\", },\n\t{},\n};\n\nMODULE_DEVICE_TABLE(of, axxia_i2c_of_match);\n\nstatic struct platform_driver axxia_i2c_driver = {\n\t.probe = axxia_i2c_probe,\n\t.remove_new = axxia_i2c_remove,\n\t.driver = {\n\t\t.name = \"axxia-i2c\",\n\t\t.of_match_table = axxia_i2c_of_match,\n\t},\n};\n\nmodule_platform_driver(axxia_i2c_driver);\n\nMODULE_DESCRIPTION(\"Axxia I2C Bus driver\");\nMODULE_AUTHOR(\"Anders Berg <anders.berg@lsi.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}