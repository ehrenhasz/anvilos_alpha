{
  "module_name": "i2c-tiny-usb.c",
  "hash_id": "7c484ffcbf202864a8bd34f627f2324be70cf16ccb74239af293bb856d49851a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-tiny-usb.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n \n#include <linux/usb.h>\n\n \n#include <linux/i2c.h>\n\n \n#define CMD_ECHO\t\t0\n#define CMD_GET_FUNC\t\t1\n#define CMD_SET_DELAY\t\t2\n#define CMD_GET_STATUS\t\t3\n\n#define CMD_I2C_IO\t\t4\n#define CMD_I2C_IO_BEGIN\t(1<<0)\n#define CMD_I2C_IO_END\t\t(1<<1)\n\n \nstatic unsigned short delay = 10;\nmodule_param(delay, ushort, 0);\nMODULE_PARM_DESC(delay, \"bit delay in microseconds \"\n\t\t \"(default is 10us for 100kHz max)\");\n\nstatic int usb_read(struct i2c_adapter *adapter, int cmd,\n\t\t    int value, int index, void *data, int len);\n\nstatic int usb_write(struct i2c_adapter *adapter, int cmd,\n\t\t     int value, int index, void *data, int len);\n\n \n\n#define STATUS_IDLE\t\t0\n#define STATUS_ADDRESS_ACK\t1\n#define STATUS_ADDRESS_NAK\t2\n\nstatic int usb_xfer(struct i2c_adapter *adapter, struct i2c_msg *msgs, int num)\n{\n\tunsigned char *pstatus;\n\tstruct i2c_msg *pmsg;\n\tint i, ret;\n\n\tdev_dbg(&adapter->dev, \"master xfer %d messages:\\n\", num);\n\n\tpstatus = kmalloc(sizeof(*pstatus), GFP_KERNEL);\n\tif (!pstatus)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0 ; i < num ; i++) {\n\t\tint cmd = CMD_I2C_IO;\n\n\t\tif (i == 0)\n\t\t\tcmd |= CMD_I2C_IO_BEGIN;\n\n\t\tif (i == num-1)\n\t\t\tcmd |= CMD_I2C_IO_END;\n\n\t\tpmsg = &msgs[i];\n\n\t\tdev_dbg(&adapter->dev,\n\t\t\t\"  %d: %s (flags %d) %d bytes to 0x%02x\\n\",\n\t\t\ti, pmsg->flags & I2C_M_RD ? \"read\" : \"write\",\n\t\t\tpmsg->flags, pmsg->len, pmsg->addr);\n\n\t\t \n\t\tif (pmsg->flags & I2C_M_RD) {\n\t\t\t \n\t\t\tif (usb_read(adapter, cmd,\n\t\t\t\t     pmsg->flags, pmsg->addr,\n\t\t\t\t     pmsg->buf, pmsg->len) != pmsg->len) {\n\t\t\t\tdev_err(&adapter->dev,\n\t\t\t\t\t\"failure reading data\\n\");\n\t\t\t\tret = -EIO;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tif (usb_write(adapter, cmd,\n\t\t\t\t      pmsg->flags, pmsg->addr,\n\t\t\t\t      pmsg->buf, pmsg->len) != pmsg->len) {\n\t\t\t\tdev_err(&adapter->dev,\n\t\t\t\t\t\"failure writing data\\n\");\n\t\t\t\tret = -EIO;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (usb_read(adapter, CMD_GET_STATUS, 0, 0, pstatus, 1) != 1) {\n\t\t\tdev_err(&adapter->dev, \"failure reading status\\n\");\n\t\t\tret = -EIO;\n\t\t\tgoto out;\n\t\t}\n\n\t\tdev_dbg(&adapter->dev, \"  status = %d\\n\", *pstatus);\n\t\tif (*pstatus == STATUS_ADDRESS_NAK) {\n\t\t\tret = -ENXIO;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = i;\nout:\n\tkfree(pstatus);\n\treturn ret;\n}\n\nstatic u32 usb_func(struct i2c_adapter *adapter)\n{\n\t__le32 *pfunc;\n\tu32 ret;\n\n\tpfunc = kmalloc(sizeof(*pfunc), GFP_KERNEL);\n\n\t \n\tif (!pfunc || usb_read(adapter, CMD_GET_FUNC, 0, 0, pfunc,\n\t\t\t       sizeof(*pfunc)) != sizeof(*pfunc)) {\n\t\tdev_err(&adapter->dev, \"failure reading functionality\\n\");\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tret = le32_to_cpup(pfunc);\nout:\n\tkfree(pfunc);\n\treturn ret;\n}\n\n \nstatic const struct i2c_algorithm usb_algorithm = {\n\t.master_xfer\t= usb_xfer,\n\t.functionality\t= usb_func,\n};\n\n \n\n \n\n \nstatic const struct usb_device_id i2c_tiny_usb_table[] = {\n\t{ USB_DEVICE(0x0403, 0xc631) },    \n\t{ USB_DEVICE(0x1c40, 0x0534) },    \n\t{ }                                \n};\n\nMODULE_DEVICE_TABLE(usb, i2c_tiny_usb_table);\n\n \nstruct i2c_tiny_usb {\n\tstruct usb_device *usb_dev;  \n\tstruct usb_interface *interface;  \n\tstruct i2c_adapter adapter;  \n};\n\nstatic int usb_read(struct i2c_adapter *adapter, int cmd,\n\t\t    int value, int index, void *data, int len)\n{\n\tstruct i2c_tiny_usb *dev = (struct i2c_tiny_usb *)adapter->algo_data;\n\tvoid *dmadata = kmalloc(len, GFP_KERNEL);\n\tint ret;\n\n\tif (!dmadata)\n\t\treturn -ENOMEM;\n\n\t \n\tret = usb_control_msg(dev->usb_dev, usb_rcvctrlpipe(dev->usb_dev, 0),\n\t\t\t       cmd, USB_TYPE_VENDOR | USB_RECIP_INTERFACE |\n\t\t\t       USB_DIR_IN, value, index, dmadata, len, 2000);\n\n\tmemcpy(data, dmadata, len);\n\tkfree(dmadata);\n\treturn ret;\n}\n\nstatic int usb_write(struct i2c_adapter *adapter, int cmd,\n\t\t     int value, int index, void *data, int len)\n{\n\tstruct i2c_tiny_usb *dev = (struct i2c_tiny_usb *)adapter->algo_data;\n\tvoid *dmadata = kmemdup(data, len, GFP_KERNEL);\n\tint ret;\n\n\tif (!dmadata)\n\t\treturn -ENOMEM;\n\n\t \n\tret = usb_control_msg(dev->usb_dev, usb_sndctrlpipe(dev->usb_dev, 0),\n\t\t\t       cmd, USB_TYPE_VENDOR | USB_RECIP_INTERFACE,\n\t\t\t       value, index, dmadata, len, 2000);\n\n\tkfree(dmadata);\n\treturn ret;\n}\n\nstatic void i2c_tiny_usb_free(struct i2c_tiny_usb *dev)\n{\n\tusb_put_dev(dev->usb_dev);\n\tkfree(dev);\n}\n\nstatic int i2c_tiny_usb_probe(struct usb_interface *interface,\n\t\t\t      const struct usb_device_id *id)\n{\n\tstruct i2c_tiny_usb *dev;\n\tint retval = -ENOMEM;\n\tu16 version;\n\n\tif (interface->intf_assoc &&\n\t    interface->intf_assoc->bFunctionClass != USB_CLASS_VENDOR_SPEC)\n\t\treturn -ENODEV;\n\n\tdev_dbg(&interface->dev, \"probing usb device\\n\");\n\n\t \n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\tgoto error;\n\n\tdev->usb_dev = usb_get_dev(interface_to_usbdev(interface));\n\tdev->interface = interface;\n\n\t \n\tusb_set_intfdata(interface, dev);\n\n\tversion = le16_to_cpu(dev->usb_dev->descriptor.bcdDevice);\n\tdev_info(&interface->dev,\n\t\t \"version %x.%02x found at bus %03d address %03d\\n\",\n\t\t version >> 8, version & 0xff,\n\t\t dev->usb_dev->bus->busnum, dev->usb_dev->devnum);\n\n\t \n\tdev->adapter.owner = THIS_MODULE;\n\tdev->adapter.class = I2C_CLASS_HWMON;\n\tdev->adapter.algo = &usb_algorithm;\n\tdev->adapter.algo_data = dev;\n\tsnprintf(dev->adapter.name, sizeof(dev->adapter.name),\n\t\t \"i2c-tiny-usb at bus %03d device %03d\",\n\t\t dev->usb_dev->bus->busnum, dev->usb_dev->devnum);\n\n\tif (usb_write(&dev->adapter, CMD_SET_DELAY, delay, 0, NULL, 0) != 0) {\n\t\tdev_err(&dev->adapter.dev,\n\t\t\t\"failure setting delay to %dus\\n\", delay);\n\t\tretval = -EIO;\n\t\tgoto error;\n\t}\n\n\tdev->adapter.dev.parent = &dev->interface->dev;\n\n\t \n\ti2c_add_adapter(&dev->adapter);\n\n\t \n\tdev_info(&dev->adapter.dev, \"connected i2c-tiny-usb device\\n\");\n\n\treturn 0;\n\n error:\n\tif (dev)\n\t\ti2c_tiny_usb_free(dev);\n\n\treturn retval;\n}\n\nstatic void i2c_tiny_usb_disconnect(struct usb_interface *interface)\n{\n\tstruct i2c_tiny_usb *dev = usb_get_intfdata(interface);\n\n\ti2c_del_adapter(&dev->adapter);\n\tusb_set_intfdata(interface, NULL);\n\ti2c_tiny_usb_free(dev);\n\n\tdev_dbg(&interface->dev, \"disconnected\\n\");\n}\n\nstatic struct usb_driver i2c_tiny_usb_driver = {\n\t.name\t\t= \"i2c-tiny-usb\",\n\t.probe\t\t= i2c_tiny_usb_probe,\n\t.disconnect\t= i2c_tiny_usb_disconnect,\n\t.id_table\t= i2c_tiny_usb_table,\n};\n\nmodule_usb_driver(i2c_tiny_usb_driver);\n\n \n\nMODULE_AUTHOR(\"Till Harbaum <Till@Harbaum.org>\");\nMODULE_DESCRIPTION(\"i2c-tiny-usb driver v1.0\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}