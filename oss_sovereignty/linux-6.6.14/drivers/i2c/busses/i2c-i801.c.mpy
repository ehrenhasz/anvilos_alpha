{
  "module_name": "i2c-i801.c",
  "hash_id": "cbb60c127a96f1491302e0c8071ca3a87cf98f4ef531f6f2a3089009d7d94818",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-i801.c",
  "human_readable_source": "\n \n\n \n\n#define DRV_NAME\t\"i801_smbus\"\n\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/init.h>\n#include <linux/i2c.h>\n#include <linux/i2c-smbus.h>\n#include <linux/acpi.h>\n#include <linux/io.h>\n#include <linux/dmi.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/completion.h>\n#include <linux/err.h>\n#include <linux/platform_device.h>\n#include <linux/platform_data/itco_wdt.h>\n#include <linux/platform_data/x86/p2sb.h>\n#include <linux/pm_runtime.h>\n#include <linux/mutex.h>\n\n#if IS_ENABLED(CONFIG_I2C_MUX_GPIO) && defined CONFIG_DMI\n#include <linux/gpio/machine.h>\n#include <linux/platform_data/i2c-mux-gpio.h>\n#endif\n\n \n#define SMBHSTSTS(p)\t(0 + (p)->smba)\n#define SMBHSTCNT(p)\t(2 + (p)->smba)\n#define SMBHSTCMD(p)\t(3 + (p)->smba)\n#define SMBHSTADD(p)\t(4 + (p)->smba)\n#define SMBHSTDAT0(p)\t(5 + (p)->smba)\n#define SMBHSTDAT1(p)\t(6 + (p)->smba)\n#define SMBBLKDAT(p)\t(7 + (p)->smba)\n#define SMBPEC(p)\t(8 + (p)->smba)\t\t \n#define SMBAUXSTS(p)\t(12 + (p)->smba)\t \n#define SMBAUXCTL(p)\t(13 + (p)->smba)\t \n#define SMBSLVSTS(p)\t(16 + (p)->smba)\t \n#define SMBSLVCMD(p)\t(17 + (p)->smba)\t \n#define SMBNTFDADD(p)\t(20 + (p)->smba)\t \n\n \n#define SMBBAR\t\t4\n#define SMBHSTCFG\t0x040\n#define TCOBASE\t\t0x050\n#define TCOCTL\t\t0x054\n\n#define SBREG_SMBCTRL\t\t0xc6000c\n#define SBREG_SMBCTRL_DNV\t0xcf000c\n\n \n#define SMBHSTCFG_HST_EN\tBIT(0)\n#define SMBHSTCFG_SMB_SMI_EN\tBIT(1)\n#define SMBHSTCFG_I2C_EN\tBIT(2)\n#define SMBHSTCFG_SPD_WD\tBIT(4)\n\n \n#define TCOCTL_EN\t\tBIT(8)\n\n \n#define SMBAUXSTS_CRCE\t\tBIT(0)\n#define SMBAUXSTS_STCO\t\tBIT(1)\n\n \n#define SMBAUXCTL_CRC\t\tBIT(0)\n#define SMBAUXCTL_E32B\t\tBIT(1)\n\n \n#define I801_QUICK\t\t0x00\n#define I801_BYTE\t\t0x04\n#define I801_BYTE_DATA\t\t0x08\n#define I801_WORD_DATA\t\t0x0C\n#define I801_PROC_CALL\t\t0x10\n#define I801_BLOCK_DATA\t\t0x14\n#define I801_I2C_BLOCK_DATA\t0x18\t \n#define I801_BLOCK_PROC_CALL\t0x1C\n\n \n#define SMBHSTCNT_INTREN\tBIT(0)\n#define SMBHSTCNT_KILL\t\tBIT(1)\n#define SMBHSTCNT_LAST_BYTE\tBIT(5)\n#define SMBHSTCNT_START\t\tBIT(6)\n#define SMBHSTCNT_PEC_EN\tBIT(7)\t \n\n \n#define SMBHSTSTS_BYTE_DONE\tBIT(7)\n#define SMBHSTSTS_INUSE_STS\tBIT(6)\n#define SMBHSTSTS_SMBALERT_STS\tBIT(5)\n#define SMBHSTSTS_FAILED\tBIT(4)\n#define SMBHSTSTS_BUS_ERR\tBIT(3)\n#define SMBHSTSTS_DEV_ERR\tBIT(2)\n#define SMBHSTSTS_INTR\t\tBIT(1)\n#define SMBHSTSTS_HOST_BUSY\tBIT(0)\n\n \n#define SMBSLVSTS_HST_NTFY_STS\tBIT(0)\n\n \n#define SMBSLVCMD_SMBALERT_DISABLE\tBIT(2)\n#define SMBSLVCMD_HST_NTFY_INTREN\tBIT(0)\n\n#define STATUS_ERROR_FLAGS\t(SMBHSTSTS_FAILED | SMBHSTSTS_BUS_ERR | \\\n\t\t\t\t SMBHSTSTS_DEV_ERR)\n\n#define STATUS_FLAGS\t\t(SMBHSTSTS_BYTE_DONE | SMBHSTSTS_INTR | \\\n\t\t\t\t STATUS_ERROR_FLAGS)\n\n \n#define PCI_DEVICE_ID_INTEL_COMETLAKE_SMBUS\t\t0x02a3\n#define PCI_DEVICE_ID_INTEL_COMETLAKE_H_SMBUS\t\t0x06a3\n#define PCI_DEVICE_ID_INTEL_BAYTRAIL_SMBUS\t\t0x0f12\n#define PCI_DEVICE_ID_INTEL_CDF_SMBUS\t\t\t0x18df\n#define PCI_DEVICE_ID_INTEL_DNV_SMBUS\t\t\t0x19df\n#define PCI_DEVICE_ID_INTEL_EBG_SMBUS\t\t\t0x1bc9\n#define PCI_DEVICE_ID_INTEL_COUGARPOINT_SMBUS\t\t0x1c22\n#define PCI_DEVICE_ID_INTEL_PATSBURG_SMBUS\t\t0x1d22\n \n#define PCI_DEVICE_ID_INTEL_PATSBURG_SMBUS_IDF0\t\t0x1d70\n#define PCI_DEVICE_ID_INTEL_PATSBURG_SMBUS_IDF1\t\t0x1d71\n#define PCI_DEVICE_ID_INTEL_PATSBURG_SMBUS_IDF2\t\t0x1d72\n#define PCI_DEVICE_ID_INTEL_PANTHERPOINT_SMBUS\t\t0x1e22\n#define PCI_DEVICE_ID_INTEL_AVOTON_SMBUS\t\t0x1f3c\n#define PCI_DEVICE_ID_INTEL_BRASWELL_SMBUS\t\t0x2292\n#define PCI_DEVICE_ID_INTEL_DH89XXCC_SMBUS\t\t0x2330\n#define PCI_DEVICE_ID_INTEL_COLETOCREEK_SMBUS\t\t0x23b0\n#define PCI_DEVICE_ID_INTEL_GEMINILAKE_SMBUS\t\t0x31d4\n#define PCI_DEVICE_ID_INTEL_ICELAKE_LP_SMBUS\t\t0x34a3\n#define PCI_DEVICE_ID_INTEL_ICELAKE_N_SMBUS\t\t0x38a3\n#define PCI_DEVICE_ID_INTEL_5_3400_SERIES_SMBUS\t\t0x3b30\n#define PCI_DEVICE_ID_INTEL_TIGERLAKE_H_SMBUS\t\t0x43a3\n#define PCI_DEVICE_ID_INTEL_ELKHART_LAKE_SMBUS\t\t0x4b23\n#define PCI_DEVICE_ID_INTEL_JASPER_LAKE_SMBUS\t\t0x4da3\n#define PCI_DEVICE_ID_INTEL_ALDER_LAKE_P_SMBUS\t\t0x51a3\n#define PCI_DEVICE_ID_INTEL_ALDER_LAKE_M_SMBUS\t\t0x54a3\n#define PCI_DEVICE_ID_INTEL_BIRCH_STREAM_SMBUS\t\t0x5796\n#define PCI_DEVICE_ID_INTEL_BROXTON_SMBUS\t\t0x5ad4\n#define PCI_DEVICE_ID_INTEL_RAPTOR_LAKE_S_SMBUS\t\t0x7a23\n#define PCI_DEVICE_ID_INTEL_ALDER_LAKE_S_SMBUS\t\t0x7aa3\n#define PCI_DEVICE_ID_INTEL_METEOR_LAKE_P_SMBUS\t\t0x7e22\n#define PCI_DEVICE_ID_INTEL_METEOR_LAKE_PCH_S_SMBUS\t0x7f23\n#define PCI_DEVICE_ID_INTEL_LYNXPOINT_SMBUS\t\t0x8c22\n#define PCI_DEVICE_ID_INTEL_WILDCATPOINT_SMBUS\t\t0x8ca2\n#define PCI_DEVICE_ID_INTEL_WELLSBURG_SMBUS\t\t0x8d22\n#define PCI_DEVICE_ID_INTEL_WELLSBURG_SMBUS_MS0\t\t0x8d7d\n#define PCI_DEVICE_ID_INTEL_WELLSBURG_SMBUS_MS1\t\t0x8d7e\n#define PCI_DEVICE_ID_INTEL_WELLSBURG_SMBUS_MS2\t\t0x8d7f\n#define PCI_DEVICE_ID_INTEL_LYNXPOINT_LP_SMBUS\t\t0x9c22\n#define PCI_DEVICE_ID_INTEL_WILDCATPOINT_LP_SMBUS\t0x9ca2\n#define PCI_DEVICE_ID_INTEL_SUNRISEPOINT_LP_SMBUS\t0x9d23\n#define PCI_DEVICE_ID_INTEL_CANNONLAKE_LP_SMBUS\t\t0x9da3\n#define PCI_DEVICE_ID_INTEL_TIGERLAKE_LP_SMBUS\t\t0xa0a3\n#define PCI_DEVICE_ID_INTEL_SUNRISEPOINT_H_SMBUS\t0xa123\n#define PCI_DEVICE_ID_INTEL_LEWISBURG_SMBUS\t\t0xa1a3\n#define PCI_DEVICE_ID_INTEL_LEWISBURG_SSKU_SMBUS\t0xa223\n#define PCI_DEVICE_ID_INTEL_KABYLAKE_PCH_H_SMBUS\t0xa2a3\n#define PCI_DEVICE_ID_INTEL_CANNONLAKE_H_SMBUS\t\t0xa323\n#define PCI_DEVICE_ID_INTEL_COMETLAKE_V_SMBUS\t\t0xa3a3\n#define PCI_DEVICE_ID_INTEL_METEOR_LAKE_SOC_S_SMBUS\t0xae22\n\nstruct i801_mux_config {\n\tchar *gpio_chip;\n\tunsigned values[3];\n\tint n_values;\n\tunsigned classes[3];\n\tunsigned gpios[2];\t\t \n\tint n_gpios;\n};\n\nstruct i801_priv {\n\tstruct i2c_adapter adapter;\n\tunsigned long smba;\n\tunsigned char original_hstcfg;\n\tunsigned char original_hstcnt;\n\tunsigned char original_slvcmd;\n\tstruct pci_dev *pci_dev;\n\tunsigned int features;\n\n\t \n\tstruct completion done;\n\tu8 status;\n\n\t \n\tu8 cmd;\n\tbool is_read;\n\tint count;\n\tint len;\n\tu8 *data;\n\n#if IS_ENABLED(CONFIG_I2C_MUX_GPIO) && defined CONFIG_DMI\n\tconst struct i801_mux_config *mux_drvdata;\n\tstruct platform_device *mux_pdev;\n\tstruct gpiod_lookup_table *lookup;\n#endif\n\tstruct platform_device *tco_pdev;\n\n\t \n\tbool acpi_reserved;\n\tstruct mutex acpi_lock;\n};\n\n#define FEATURE_SMBUS_PEC\tBIT(0)\n#define FEATURE_BLOCK_BUFFER\tBIT(1)\n#define FEATURE_BLOCK_PROC\tBIT(2)\n#define FEATURE_I2C_BLOCK_READ\tBIT(3)\n#define FEATURE_IRQ\t\tBIT(4)\n#define FEATURE_HOST_NOTIFY\tBIT(5)\n \n#define FEATURE_IDF\t\tBIT(15)\n#define FEATURE_TCO_SPT\t\tBIT(16)\n#define FEATURE_TCO_CNL\t\tBIT(17)\n\nstatic const char *i801_feature_names[] = {\n\t\"SMBus PEC\",\n\t\"Block buffer\",\n\t\"Block process call\",\n\t\"I2C block read\",\n\t\"Interrupt\",\n\t\"SMBus Host Notify\",\n};\n\nstatic unsigned int disable_features;\nmodule_param(disable_features, uint, S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(disable_features, \"Disable selected driver features:\\n\"\n\t\"\\t\\t  0x01  disable SMBus PEC\\n\"\n\t\"\\t\\t  0x02  disable the block buffer\\n\"\n\t\"\\t\\t  0x08  disable the I2C block read functionality\\n\"\n\t\"\\t\\t  0x10  don't use interrupts\\n\"\n\t\"\\t\\t  0x20  disable SMBus Host Notify \");\n\n \nstatic int i801_check_pre(struct i801_priv *priv)\n{\n\tint status;\n\n\tstatus = inb_p(SMBHSTSTS(priv));\n\tif (status & SMBHSTSTS_HOST_BUSY) {\n\t\tpci_err(priv->pci_dev, \"SMBus is busy, can't use it!\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tstatus &= STATUS_FLAGS;\n\tif (status) {\n\t\tpci_dbg(priv->pci_dev, \"Clearing status flags (%02x)\\n\", status);\n\t\toutb_p(status, SMBHSTSTS(priv));\n\t}\n\n\t \n\tif (priv->features & FEATURE_SMBUS_PEC) {\n\t\tstatus = inb_p(SMBAUXSTS(priv)) & SMBAUXSTS_CRCE;\n\t\tif (status) {\n\t\t\tpci_dbg(priv->pci_dev, \"Clearing aux status flags (%02x)\\n\", status);\n\t\t\toutb_p(status, SMBAUXSTS(priv));\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int i801_check_post(struct i801_priv *priv, int status)\n{\n\tint result = 0;\n\n\t \n\tif (unlikely(status < 0)) {\n\t\tdev_err(&priv->pci_dev->dev, \"Transaction timeout\\n\");\n\t\t \n\t\tdev_dbg(&priv->pci_dev->dev, \"Terminating the current operation\\n\");\n\t\toutb_p(SMBHSTCNT_KILL, SMBHSTCNT(priv));\n\t\tusleep_range(1000, 2000);\n\t\toutb_p(0, SMBHSTCNT(priv));\n\n\t\t \n\t\tstatus = inb_p(SMBHSTSTS(priv));\n\t\tif ((status & SMBHSTSTS_HOST_BUSY) ||\n\t\t    !(status & SMBHSTSTS_FAILED))\n\t\t\tdev_err(&priv->pci_dev->dev,\n\t\t\t\t\"Failed terminating the transaction\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tif (status & SMBHSTSTS_FAILED) {\n\t\tresult = -EIO;\n\t\tdev_err(&priv->pci_dev->dev, \"Transaction failed\\n\");\n\t}\n\tif (status & SMBHSTSTS_DEV_ERR) {\n\t\t \n\t\tif ((priv->features & FEATURE_SMBUS_PEC) &&\n\t\t    (inb_p(SMBAUXSTS(priv)) & SMBAUXSTS_CRCE)) {\n\t\t\toutb_p(SMBAUXSTS_CRCE, SMBAUXSTS(priv));\n\t\t\tresult = -EBADMSG;\n\t\t\tdev_dbg(&priv->pci_dev->dev, \"PEC error\\n\");\n\t\t} else {\n\t\t\tresult = -ENXIO;\n\t\t\tdev_dbg(&priv->pci_dev->dev, \"No response\\n\");\n\t\t}\n\t}\n\tif (status & SMBHSTSTS_BUS_ERR) {\n\t\tresult = -EAGAIN;\n\t\tdev_dbg(&priv->pci_dev->dev, \"Lost arbitration\\n\");\n\t}\n\n\treturn result;\n}\n\n \nstatic int i801_wait_intr(struct i801_priv *priv)\n{\n\tunsigned long timeout = jiffies + priv->adapter.timeout;\n\tint status, busy;\n\n\tdo {\n\t\tusleep_range(250, 500);\n\t\tstatus = inb_p(SMBHSTSTS(priv));\n\t\tbusy = status & SMBHSTSTS_HOST_BUSY;\n\t\tstatus &= STATUS_ERROR_FLAGS | SMBHSTSTS_INTR;\n\t\tif (!busy && status)\n\t\t\treturn status & STATUS_ERROR_FLAGS;\n\t} while (time_is_after_eq_jiffies(timeout));\n\n\treturn -ETIMEDOUT;\n}\n\n \nstatic int i801_wait_byte_done(struct i801_priv *priv)\n{\n\tunsigned long timeout = jiffies + priv->adapter.timeout;\n\tint status;\n\n\tdo {\n\t\tusleep_range(250, 500);\n\t\tstatus = inb_p(SMBHSTSTS(priv));\n\t\tif (status & (STATUS_ERROR_FLAGS | SMBHSTSTS_BYTE_DONE))\n\t\t\treturn status & STATUS_ERROR_FLAGS;\n\t} while (time_is_after_eq_jiffies(timeout));\n\n\treturn -ETIMEDOUT;\n}\n\nstatic int i801_transaction(struct i801_priv *priv, int xact)\n{\n\tunsigned long result;\n\tconst struct i2c_adapter *adap = &priv->adapter;\n\n\tif (priv->features & FEATURE_IRQ) {\n\t\treinit_completion(&priv->done);\n\t\toutb_p(xact | SMBHSTCNT_INTREN | SMBHSTCNT_START,\n\t\t       SMBHSTCNT(priv));\n\t\tresult = wait_for_completion_timeout(&priv->done, adap->timeout);\n\t\treturn result ? priv->status : -ETIMEDOUT;\n\t}\n\n\toutb_p(xact | SMBHSTCNT_START, SMBHSTCNT(priv));\n\n\treturn i801_wait_intr(priv);\n}\n\nstatic int i801_block_transaction_by_block(struct i801_priv *priv,\n\t\t\t\t\t   union i2c_smbus_data *data,\n\t\t\t\t\t   char read_write, int command)\n{\n\tint i, len, status, xact;\n\n\tswitch (command) {\n\tcase I2C_SMBUS_BLOCK_PROC_CALL:\n\t\txact = I801_BLOCK_PROC_CALL;\n\t\tbreak;\n\tcase I2C_SMBUS_BLOCK_DATA:\n\t\txact = I801_BLOCK_DATA;\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t \n\toutb_p(inb_p(SMBAUXCTL(priv)) | SMBAUXCTL_E32B, SMBAUXCTL(priv));\n\n\tinb_p(SMBHSTCNT(priv));  \n\n\tif (read_write == I2C_SMBUS_WRITE) {\n\t\tlen = data->block[0];\n\t\toutb_p(len, SMBHSTDAT0(priv));\n\t\tfor (i = 0; i < len; i++)\n\t\t\toutb_p(data->block[i+1], SMBBLKDAT(priv));\n\t}\n\n\tstatus = i801_transaction(priv, xact);\n\tif (status)\n\t\tgoto out;\n\n\tif (read_write == I2C_SMBUS_READ ||\n\t    command == I2C_SMBUS_BLOCK_PROC_CALL) {\n\t\tlen = inb_p(SMBHSTDAT0(priv));\n\t\tif (len < 1 || len > I2C_SMBUS_BLOCK_MAX) {\n\t\t\tstatus = -EPROTO;\n\t\t\tgoto out;\n\t\t}\n\n\t\tdata->block[0] = len;\n\t\tfor (i = 0; i < len; i++)\n\t\t\tdata->block[i + 1] = inb_p(SMBBLKDAT(priv));\n\t}\nout:\n\toutb_p(inb_p(SMBAUXCTL(priv)) & ~SMBAUXCTL_E32B, SMBAUXCTL(priv));\n\treturn status;\n}\n\nstatic void i801_isr_byte_done(struct i801_priv *priv)\n{\n\tif (priv->is_read) {\n\t\t \n\t\tif (((priv->cmd & 0x1c) == I801_BLOCK_DATA) &&\n\t\t    (priv->count == 0)) {\n\t\t\tpriv->len = inb_p(SMBHSTDAT0(priv));\n\t\t\tif (priv->len < 1 || priv->len > I2C_SMBUS_BLOCK_MAX) {\n\t\t\t\tdev_err(&priv->pci_dev->dev,\n\t\t\t\t\t\"Illegal SMBus block read size %d\\n\",\n\t\t\t\t\tpriv->len);\n\t\t\t\t \n\t\t\t\tpriv->len = I2C_SMBUS_BLOCK_MAX;\n\t\t\t}\n\t\t\tpriv->data[-1] = priv->len;\n\t\t}\n\n\t\t \n\t\tif (priv->count < priv->len)\n\t\t\tpriv->data[priv->count++] = inb(SMBBLKDAT(priv));\n\t\telse\n\t\t\tdev_dbg(&priv->pci_dev->dev,\n\t\t\t\t\"Discarding extra byte on block read\\n\");\n\n\t\t \n\t\tif (priv->count == priv->len - 1)\n\t\t\toutb_p(priv->cmd | SMBHSTCNT_LAST_BYTE,\n\t\t\t       SMBHSTCNT(priv));\n\t} else if (priv->count < priv->len - 1) {\n\t\t \n\t\toutb_p(priv->data[++priv->count], SMBBLKDAT(priv));\n\t}\n}\n\nstatic irqreturn_t i801_host_notify_isr(struct i801_priv *priv)\n{\n\tunsigned short addr;\n\n\taddr = inb_p(SMBNTFDADD(priv)) >> 1;\n\n\t \n\ti2c_handle_smbus_host_notify(&priv->adapter, addr);\n\n\t \n\toutb_p(SMBSLVSTS_HST_NTFY_STS, SMBSLVSTS(priv));\n\treturn IRQ_HANDLED;\n}\n\n \nstatic irqreturn_t i801_isr(int irq, void *dev_id)\n{\n\tstruct i801_priv *priv = dev_id;\n\tu16 pcists;\n\tu8 status;\n\n\t \n\tpci_read_config_word(priv->pci_dev, PCI_STATUS, &pcists);\n\tif (!(pcists & PCI_STATUS_INTERRUPT))\n\t\treturn IRQ_NONE;\n\n\tif (priv->features & FEATURE_HOST_NOTIFY) {\n\t\tstatus = inb_p(SMBSLVSTS(priv));\n\t\tif (status & SMBSLVSTS_HST_NTFY_STS)\n\t\t\treturn i801_host_notify_isr(priv);\n\t}\n\n\tstatus = inb_p(SMBHSTSTS(priv));\n\tif ((status & (SMBHSTSTS_BYTE_DONE | STATUS_ERROR_FLAGS)) == SMBHSTSTS_BYTE_DONE)\n\t\ti801_isr_byte_done(priv);\n\n\t \n\tstatus &= STATUS_FLAGS | SMBHSTSTS_SMBALERT_STS;\n\toutb_p(status, SMBHSTSTS(priv));\n\n\tstatus &= STATUS_ERROR_FLAGS | SMBHSTSTS_INTR;\n\tif (status) {\n\t\tpriv->status = status & STATUS_ERROR_FLAGS;\n\t\tcomplete(&priv->done);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic int i801_block_transaction_byte_by_byte(struct i801_priv *priv,\n\t\t\t\t\t       union i2c_smbus_data *data,\n\t\t\t\t\t       char read_write, int command)\n{\n\tint i, len;\n\tint smbcmd;\n\tint status;\n\tunsigned long result;\n\tconst struct i2c_adapter *adap = &priv->adapter;\n\n\tif (command == I2C_SMBUS_BLOCK_PROC_CALL)\n\t\treturn -EOPNOTSUPP;\n\n\tlen = data->block[0];\n\n\tif (read_write == I2C_SMBUS_WRITE) {\n\t\toutb_p(len, SMBHSTDAT0(priv));\n\t\toutb_p(data->block[1], SMBBLKDAT(priv));\n\t}\n\n\tif (command == I2C_SMBUS_I2C_BLOCK_DATA &&\n\t    read_write == I2C_SMBUS_READ)\n\t\tsmbcmd = I801_I2C_BLOCK_DATA;\n\telse\n\t\tsmbcmd = I801_BLOCK_DATA;\n\n\tif (priv->features & FEATURE_IRQ) {\n\t\tpriv->is_read = (read_write == I2C_SMBUS_READ);\n\t\tif (len == 1 && priv->is_read)\n\t\t\tsmbcmd |= SMBHSTCNT_LAST_BYTE;\n\t\tpriv->cmd = smbcmd | SMBHSTCNT_INTREN;\n\t\tpriv->len = len;\n\t\tpriv->count = 0;\n\t\tpriv->data = &data->block[1];\n\n\t\treinit_completion(&priv->done);\n\t\toutb_p(priv->cmd | SMBHSTCNT_START, SMBHSTCNT(priv));\n\t\tresult = wait_for_completion_timeout(&priv->done, adap->timeout);\n\t\treturn result ? priv->status : -ETIMEDOUT;\n\t}\n\n\tif (len == 1 && read_write == I2C_SMBUS_READ)\n\t\tsmbcmd |= SMBHSTCNT_LAST_BYTE;\n\toutb_p(smbcmd | SMBHSTCNT_START, SMBHSTCNT(priv));\n\n\tfor (i = 1; i <= len; i++) {\n\t\tstatus = i801_wait_byte_done(priv);\n\t\tif (status)\n\t\t\treturn status;\n\n\t\tif (i == 1 && read_write == I2C_SMBUS_READ\n\t\t && command != I2C_SMBUS_I2C_BLOCK_DATA) {\n\t\t\tlen = inb_p(SMBHSTDAT0(priv));\n\t\t\tif (len < 1 || len > I2C_SMBUS_BLOCK_MAX) {\n\t\t\t\tdev_err(&priv->pci_dev->dev,\n\t\t\t\t\t\"Illegal SMBus block read size %d\\n\",\n\t\t\t\t\tlen);\n\t\t\t\t \n\t\t\t\twhile (inb_p(SMBHSTSTS(priv)) &\n\t\t\t\t       SMBHSTSTS_HOST_BUSY)\n\t\t\t\t\toutb_p(SMBHSTSTS_BYTE_DONE,\n\t\t\t\t\t       SMBHSTSTS(priv));\n\t\t\t\toutb_p(SMBHSTSTS_INTR, SMBHSTSTS(priv));\n\t\t\t\treturn -EPROTO;\n\t\t\t}\n\t\t\tdata->block[0] = len;\n\t\t}\n\n\t\tif (read_write == I2C_SMBUS_READ) {\n\t\t\tdata->block[i] = inb_p(SMBBLKDAT(priv));\n\t\t\tif (i == len - 1)\n\t\t\t\toutb_p(smbcmd | SMBHSTCNT_LAST_BYTE, SMBHSTCNT(priv));\n\t\t}\n\n\t\tif (read_write == I2C_SMBUS_WRITE && i+1 <= len)\n\t\t\toutb_p(data->block[i+1], SMBBLKDAT(priv));\n\n\t\t \n\t\toutb_p(SMBHSTSTS_BYTE_DONE, SMBHSTSTS(priv));\n\t}\n\n\treturn i801_wait_intr(priv);\n}\n\nstatic void i801_set_hstadd(struct i801_priv *priv, u8 addr, char read_write)\n{\n\toutb_p((addr << 1) | (read_write & 0x01), SMBHSTADD(priv));\n}\n\n \nstatic int i801_simple_transaction(struct i801_priv *priv, union i2c_smbus_data *data,\n\t\t\t\t   u8 addr, u8 hstcmd, char read_write, int command)\n{\n\tint xact, ret;\n\n\tswitch (command) {\n\tcase I2C_SMBUS_QUICK:\n\t\ti801_set_hstadd(priv, addr, read_write);\n\t\txact = I801_QUICK;\n\t\tbreak;\n\tcase I2C_SMBUS_BYTE:\n\t\ti801_set_hstadd(priv, addr, read_write);\n\t\tif (read_write == I2C_SMBUS_WRITE)\n\t\t\toutb_p(hstcmd, SMBHSTCMD(priv));\n\t\txact = I801_BYTE;\n\t\tbreak;\n\tcase I2C_SMBUS_BYTE_DATA:\n\t\ti801_set_hstadd(priv, addr, read_write);\n\t\tif (read_write == I2C_SMBUS_WRITE)\n\t\t\toutb_p(data->byte, SMBHSTDAT0(priv));\n\t\toutb_p(hstcmd, SMBHSTCMD(priv));\n\t\txact = I801_BYTE_DATA;\n\t\tbreak;\n\tcase I2C_SMBUS_WORD_DATA:\n\t\ti801_set_hstadd(priv, addr, read_write);\n\t\tif (read_write == I2C_SMBUS_WRITE) {\n\t\t\toutb_p(data->word & 0xff, SMBHSTDAT0(priv));\n\t\t\toutb_p((data->word & 0xff00) >> 8, SMBHSTDAT1(priv));\n\t\t}\n\t\toutb_p(hstcmd, SMBHSTCMD(priv));\n\t\txact = I801_WORD_DATA;\n\t\tbreak;\n\tcase I2C_SMBUS_PROC_CALL:\n\t\ti801_set_hstadd(priv, addr, I2C_SMBUS_WRITE);\n\t\toutb_p(data->word & 0xff, SMBHSTDAT0(priv));\n\t\toutb_p((data->word & 0xff00) >> 8, SMBHSTDAT1(priv));\n\t\toutb_p(hstcmd, SMBHSTCMD(priv));\n\t\tread_write = I2C_SMBUS_READ;\n\t\txact = I801_PROC_CALL;\n\t\tbreak;\n\tdefault:\n\t\tpci_err(priv->pci_dev, \"Unsupported transaction %d\\n\", command);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tret = i801_transaction(priv, xact);\n\tif (ret || read_write == I2C_SMBUS_WRITE)\n\t\treturn ret;\n\n\tswitch (command) {\n\tcase I2C_SMBUS_BYTE:\n\tcase I2C_SMBUS_BYTE_DATA:\n\t\tdata->byte = inb_p(SMBHSTDAT0(priv));\n\t\tbreak;\n\tcase I2C_SMBUS_WORD_DATA:\n\tcase I2C_SMBUS_PROC_CALL:\n\t\tdata->word = inb_p(SMBHSTDAT0(priv)) +\n\t\t\t     (inb_p(SMBHSTDAT1(priv)) << 8);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int i801_block_transaction(struct i801_priv *priv, union i2c_smbus_data *data,\n\t\t\t\t  u8 addr, u8 hstcmd, char read_write, int command)\n{\n\tint result = 0;\n\tunsigned char hostc;\n\n\tif (read_write == I2C_SMBUS_READ && command == I2C_SMBUS_BLOCK_DATA)\n\t\tdata->block[0] = I2C_SMBUS_BLOCK_MAX;\n\telse if (data->block[0] < 1 || data->block[0] > I2C_SMBUS_BLOCK_MAX)\n\t\treturn -EPROTO;\n\n\tswitch (command) {\n\tcase I2C_SMBUS_BLOCK_DATA:\n\t\ti801_set_hstadd(priv, addr, read_write);\n\t\toutb_p(hstcmd, SMBHSTCMD(priv));\n\t\tbreak;\n\tcase I2C_SMBUS_I2C_BLOCK_DATA:\n\t\t \n\t\ti801_set_hstadd(priv, addr,\n\t\t\t\tpriv->original_hstcfg & SMBHSTCFG_SPD_WD ?\n\t\t\t\tread_write : I2C_SMBUS_WRITE);\n\t\tif (read_write == I2C_SMBUS_READ) {\n\t\t\t \n\t\t\toutb_p(hstcmd, SMBHSTDAT1(priv));\n\t\t} else\n\t\t\toutb_p(hstcmd, SMBHSTCMD(priv));\n\n\t\tif (read_write == I2C_SMBUS_WRITE) {\n\t\t\t \n\t\t\tpci_read_config_byte(priv->pci_dev, SMBHSTCFG, &hostc);\n\t\t\tpci_write_config_byte(priv->pci_dev, SMBHSTCFG,\n\t\t\t\t\t      hostc | SMBHSTCFG_I2C_EN);\n\t\t} else if (!(priv->features & FEATURE_I2C_BLOCK_READ)) {\n\t\t\tdev_err(&priv->pci_dev->dev,\n\t\t\t\t\"I2C block read is unsupported!\\n\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tbreak;\n\tcase I2C_SMBUS_BLOCK_PROC_CALL:\n\t\t \n\t\ti801_set_hstadd(priv, addr, I2C_SMBUS_WRITE);\n\t\toutb_p(hstcmd, SMBHSTCMD(priv));\n\t\tbreak;\n\t}\n\n\t \n\tif ((priv->features & FEATURE_BLOCK_BUFFER) &&\n\t    command != I2C_SMBUS_I2C_BLOCK_DATA)\n\t\tresult = i801_block_transaction_by_block(priv, data,\n\t\t\t\t\t\t\t read_write,\n\t\t\t\t\t\t\t command);\n\telse\n\t\tresult = i801_block_transaction_byte_by_byte(priv, data,\n\t\t\t\t\t\t\t     read_write,\n\t\t\t\t\t\t\t     command);\n\n\tif (command == I2C_SMBUS_I2C_BLOCK_DATA\n\t && read_write == I2C_SMBUS_WRITE) {\n\t\t \n\t\tpci_write_config_byte(priv->pci_dev, SMBHSTCFG, hostc);\n\t}\n\treturn result;\n}\n\n \nstatic s32 i801_access(struct i2c_adapter *adap, u16 addr,\n\t\t       unsigned short flags, char read_write, u8 command,\n\t\t       int size, union i2c_smbus_data *data)\n{\n\tint hwpec, ret;\n\tstruct i801_priv *priv = i2c_get_adapdata(adap);\n\n\tmutex_lock(&priv->acpi_lock);\n\tif (priv->acpi_reserved) {\n\t\tmutex_unlock(&priv->acpi_lock);\n\t\treturn -EBUSY;\n\t}\n\n\tpm_runtime_get_sync(&priv->pci_dev->dev);\n\n\tret = i801_check_pre(priv);\n\tif (ret)\n\t\tgoto out;\n\n\thwpec = (priv->features & FEATURE_SMBUS_PEC) && (flags & I2C_CLIENT_PEC)\n\t\t&& size != I2C_SMBUS_QUICK\n\t\t&& size != I2C_SMBUS_I2C_BLOCK_DATA;\n\n\tif (hwpec)\t \n\t\toutb_p(inb_p(SMBAUXCTL(priv)) | SMBAUXCTL_CRC, SMBAUXCTL(priv));\n\telse\n\t\toutb_p(inb_p(SMBAUXCTL(priv)) & (~SMBAUXCTL_CRC),\n\t\t       SMBAUXCTL(priv));\n\n\tif (size == I2C_SMBUS_BLOCK_DATA ||\n\t    size == I2C_SMBUS_I2C_BLOCK_DATA ||\n\t    size == I2C_SMBUS_BLOCK_PROC_CALL)\n\t\tret = i801_block_transaction(priv, data, addr, command, read_write, size);\n\telse\n\t\tret = i801_simple_transaction(priv, data, addr, command, read_write, size);\n\n\tret = i801_check_post(priv, ret);\n\n\t \n\tif (hwpec)\n\t\toutb_p(inb_p(SMBAUXCTL(priv)) & ~SMBAUXCTL_CRC, SMBAUXCTL(priv));\nout:\n\t \n\toutb_p(SMBHSTSTS_INUSE_STS | STATUS_FLAGS, SMBHSTSTS(priv));\n\n\tpm_runtime_mark_last_busy(&priv->pci_dev->dev);\n\tpm_runtime_put_autosuspend(&priv->pci_dev->dev);\n\tmutex_unlock(&priv->acpi_lock);\n\treturn ret;\n}\n\n\nstatic u32 i801_func(struct i2c_adapter *adapter)\n{\n\tstruct i801_priv *priv = i2c_get_adapdata(adapter);\n\n\treturn I2C_FUNC_SMBUS_QUICK | I2C_FUNC_SMBUS_BYTE |\n\t       I2C_FUNC_SMBUS_BYTE_DATA | I2C_FUNC_SMBUS_WORD_DATA |\n\t       I2C_FUNC_SMBUS_PROC_CALL |\n\t       I2C_FUNC_SMBUS_BLOCK_DATA | I2C_FUNC_SMBUS_WRITE_I2C_BLOCK |\n\t       ((priv->features & FEATURE_SMBUS_PEC) ? I2C_FUNC_SMBUS_PEC : 0) |\n\t       ((priv->features & FEATURE_BLOCK_PROC) ?\n\t\tI2C_FUNC_SMBUS_BLOCK_PROC_CALL : 0) |\n\t       ((priv->features & FEATURE_I2C_BLOCK_READ) ?\n\t\tI2C_FUNC_SMBUS_READ_I2C_BLOCK : 0) |\n\t       ((priv->features & FEATURE_HOST_NOTIFY) ?\n\t\tI2C_FUNC_SMBUS_HOST_NOTIFY : 0);\n}\n\nstatic void i801_enable_host_notify(struct i2c_adapter *adapter)\n{\n\tstruct i801_priv *priv = i2c_get_adapdata(adapter);\n\n\tif (!(priv->features & FEATURE_HOST_NOTIFY))\n\t\treturn;\n\n\t \n\toutb_p(SMBSLVCMD_HST_NTFY_INTREN | SMBSLVCMD_SMBALERT_DISABLE |\n\t       priv->original_slvcmd, SMBSLVCMD(priv));\n\n\t \n\toutb_p(SMBSLVSTS_HST_NTFY_STS, SMBSLVSTS(priv));\n}\n\nstatic void i801_disable_host_notify(struct i801_priv *priv)\n{\n\tif (!(priv->features & FEATURE_HOST_NOTIFY))\n\t\treturn;\n\n\toutb_p(priv->original_slvcmd, SMBSLVCMD(priv));\n}\n\nstatic const struct i2c_algorithm smbus_algorithm = {\n\t.smbus_xfer\t= i801_access,\n\t.functionality\t= i801_func,\n};\n\n#define FEATURES_ICH5\t(FEATURE_BLOCK_PROC | FEATURE_I2C_BLOCK_READ\t| \\\n\t\t\t FEATURE_IRQ | FEATURE_SMBUS_PEC\t\t| \\\n\t\t\t FEATURE_BLOCK_BUFFER | FEATURE_HOST_NOTIFY)\n#define FEATURES_ICH4\t(FEATURE_SMBUS_PEC | FEATURE_BLOCK_BUFFER | \\\n\t\t\t FEATURE_HOST_NOTIFY)\n\nstatic const struct pci_device_id i801_ids[] = {\n\t{ PCI_DEVICE_DATA(INTEL, 82801AA_3,\t\t\t0)\t\t\t\t },\n\t{ PCI_DEVICE_DATA(INTEL, 82801AB_3,\t\t\t0)\t\t\t\t },\n\t{ PCI_DEVICE_DATA(INTEL, 82801BA_2,\t\t\t0)\t\t\t\t },\n\t{ PCI_DEVICE_DATA(INTEL, 82801CA_3,\t\t\tFEATURE_HOST_NOTIFY)\t\t },\n\t{ PCI_DEVICE_DATA(INTEL, 82801DB_3,\t\t\tFEATURES_ICH4)\t\t\t },\n\t{ PCI_DEVICE_DATA(INTEL, 82801EB_3,\t\t\tFEATURES_ICH5)\t\t\t },\n\t{ PCI_DEVICE_DATA(INTEL, ESB_4,\t\t\t\tFEATURES_ICH5)\t\t\t },\n\t{ PCI_DEVICE_DATA(INTEL, ICH6_16,\t\t\tFEATURES_ICH5)\t\t\t },\n\t{ PCI_DEVICE_DATA(INTEL, ICH7_17,\t\t\tFEATURES_ICH5)\t\t\t },\n\t{ PCI_DEVICE_DATA(INTEL, ESB2_17,\t\t\tFEATURES_ICH5)\t\t\t },\n\t{ PCI_DEVICE_DATA(INTEL, ICH8_5,\t\t\tFEATURES_ICH5)\t\t\t },\n\t{ PCI_DEVICE_DATA(INTEL, ICH9_6,\t\t\tFEATURES_ICH5)\t\t\t },\n\t{ PCI_DEVICE_DATA(INTEL, EP80579_1,\t\t\tFEATURES_ICH5)\t\t\t },\n\t{ PCI_DEVICE_DATA(INTEL, ICH10_4,\t\t\tFEATURES_ICH5)\t\t\t },\n\t{ PCI_DEVICE_DATA(INTEL, ICH10_5,\t\t\tFEATURES_ICH5)\t\t\t },\n\t{ PCI_DEVICE_DATA(INTEL, 5_3400_SERIES_SMBUS,\t\tFEATURES_ICH5)\t\t\t },\n\t{ PCI_DEVICE_DATA(INTEL, COUGARPOINT_SMBUS,\t\tFEATURES_ICH5)\t\t\t },\n\t{ PCI_DEVICE_DATA(INTEL, PATSBURG_SMBUS,\t\tFEATURES_ICH5)\t\t\t },\n\t{ PCI_DEVICE_DATA(INTEL, PATSBURG_SMBUS_IDF0,\t\tFEATURES_ICH5 | FEATURE_IDF)\t },\n\t{ PCI_DEVICE_DATA(INTEL, PATSBURG_SMBUS_IDF1,\t\tFEATURES_ICH5 | FEATURE_IDF)\t },\n\t{ PCI_DEVICE_DATA(INTEL, PATSBURG_SMBUS_IDF2,\t\tFEATURES_ICH5 | FEATURE_IDF)\t },\n\t{ PCI_DEVICE_DATA(INTEL, DH89XXCC_SMBUS,\t\tFEATURES_ICH5)\t\t\t },\n\t{ PCI_DEVICE_DATA(INTEL, PANTHERPOINT_SMBUS,\t\tFEATURES_ICH5)\t\t\t },\n\t{ PCI_DEVICE_DATA(INTEL, LYNXPOINT_SMBUS,\t\tFEATURES_ICH5)\t\t\t },\n\t{ PCI_DEVICE_DATA(INTEL, LYNXPOINT_LP_SMBUS,\t\tFEATURES_ICH5)\t\t\t },\n\t{ PCI_DEVICE_DATA(INTEL, AVOTON_SMBUS,\t\t\tFEATURES_ICH5)\t\t\t },\n\t{ PCI_DEVICE_DATA(INTEL, WELLSBURG_SMBUS,\t\tFEATURES_ICH5)\t\t\t },\n\t{ PCI_DEVICE_DATA(INTEL, WELLSBURG_SMBUS_MS0,\t\tFEATURES_ICH5 | FEATURE_IDF)\t },\n\t{ PCI_DEVICE_DATA(INTEL, WELLSBURG_SMBUS_MS1,\t\tFEATURES_ICH5 | FEATURE_IDF)\t },\n\t{ PCI_DEVICE_DATA(INTEL, WELLSBURG_SMBUS_MS2,\t\tFEATURES_ICH5 | FEATURE_IDF)\t },\n\t{ PCI_DEVICE_DATA(INTEL, COLETOCREEK_SMBUS,\t\tFEATURES_ICH5)\t\t\t },\n\t{ PCI_DEVICE_DATA(INTEL, GEMINILAKE_SMBUS,\t\tFEATURES_ICH5)\t\t\t },\n\t{ PCI_DEVICE_DATA(INTEL, WILDCATPOINT_SMBUS,\t\tFEATURES_ICH5)\t\t\t },\n\t{ PCI_DEVICE_DATA(INTEL, WILDCATPOINT_LP_SMBUS,\t\tFEATURES_ICH5)\t\t\t },\n\t{ PCI_DEVICE_DATA(INTEL, BAYTRAIL_SMBUS,\t\tFEATURES_ICH5)\t\t\t },\n\t{ PCI_DEVICE_DATA(INTEL, BRASWELL_SMBUS,\t\tFEATURES_ICH5)\t\t\t },\n\t{ PCI_DEVICE_DATA(INTEL, SUNRISEPOINT_H_SMBUS,\t\tFEATURES_ICH5 | FEATURE_TCO_SPT) },\n\t{ PCI_DEVICE_DATA(INTEL, SUNRISEPOINT_LP_SMBUS,\t\tFEATURES_ICH5 | FEATURE_TCO_SPT) },\n\t{ PCI_DEVICE_DATA(INTEL, CDF_SMBUS,\t\t\tFEATURES_ICH5 | FEATURE_TCO_CNL) },\n\t{ PCI_DEVICE_DATA(INTEL, DNV_SMBUS,\t\t\tFEATURES_ICH5 | FEATURE_TCO_SPT) },\n\t{ PCI_DEVICE_DATA(INTEL, EBG_SMBUS,\t\t\tFEATURES_ICH5 | FEATURE_TCO_CNL) },\n\t{ PCI_DEVICE_DATA(INTEL, BROXTON_SMBUS,\t\t\tFEATURES_ICH5)\t\t\t },\n\t{ PCI_DEVICE_DATA(INTEL, LEWISBURG_SMBUS,\t\tFEATURES_ICH5 | FEATURE_TCO_SPT) },\n\t{ PCI_DEVICE_DATA(INTEL, LEWISBURG_SSKU_SMBUS,\t\tFEATURES_ICH5 | FEATURE_TCO_SPT) },\n\t{ PCI_DEVICE_DATA(INTEL, KABYLAKE_PCH_H_SMBUS,\t\tFEATURES_ICH5 | FEATURE_TCO_SPT) },\n\t{ PCI_DEVICE_DATA(INTEL, CANNONLAKE_H_SMBUS,\t\tFEATURES_ICH5 | FEATURE_TCO_CNL) },\n\t{ PCI_DEVICE_DATA(INTEL, CANNONLAKE_LP_SMBUS,\t\tFEATURES_ICH5 | FEATURE_TCO_CNL) },\n\t{ PCI_DEVICE_DATA(INTEL, ICELAKE_LP_SMBUS,\t\tFEATURES_ICH5 | FEATURE_TCO_CNL) },\n\t{ PCI_DEVICE_DATA(INTEL, ICELAKE_N_SMBUS,\t\tFEATURES_ICH5 | FEATURE_TCO_CNL) },\n\t{ PCI_DEVICE_DATA(INTEL, COMETLAKE_SMBUS,\t\tFEATURES_ICH5 | FEATURE_TCO_CNL) },\n\t{ PCI_DEVICE_DATA(INTEL, COMETLAKE_H_SMBUS,\t\tFEATURES_ICH5 | FEATURE_TCO_CNL) },\n\t{ PCI_DEVICE_DATA(INTEL, COMETLAKE_V_SMBUS,\t\tFEATURES_ICH5 | FEATURE_TCO_SPT) },\n\t{ PCI_DEVICE_DATA(INTEL, ELKHART_LAKE_SMBUS,\t\tFEATURES_ICH5 | FEATURE_TCO_CNL) },\n\t{ PCI_DEVICE_DATA(INTEL, TIGERLAKE_LP_SMBUS,\t\tFEATURES_ICH5 | FEATURE_TCO_CNL) },\n\t{ PCI_DEVICE_DATA(INTEL, TIGERLAKE_H_SMBUS,\t\tFEATURES_ICH5 | FEATURE_TCO_CNL) },\n\t{ PCI_DEVICE_DATA(INTEL, JASPER_LAKE_SMBUS,\t\tFEATURES_ICH5 | FEATURE_TCO_CNL) },\n\t{ PCI_DEVICE_DATA(INTEL, ALDER_LAKE_S_SMBUS,\t\tFEATURES_ICH5 | FEATURE_TCO_CNL) },\n\t{ PCI_DEVICE_DATA(INTEL, ALDER_LAKE_P_SMBUS,\t\tFEATURES_ICH5 | FEATURE_TCO_CNL) },\n\t{ PCI_DEVICE_DATA(INTEL, ALDER_LAKE_M_SMBUS,\t\tFEATURES_ICH5 | FEATURE_TCO_CNL) },\n\t{ PCI_DEVICE_DATA(INTEL, RAPTOR_LAKE_S_SMBUS,\t\tFEATURES_ICH5 | FEATURE_TCO_CNL) },\n\t{ PCI_DEVICE_DATA(INTEL, METEOR_LAKE_P_SMBUS,\t\tFEATURES_ICH5 | FEATURE_TCO_CNL) },\n\t{ PCI_DEVICE_DATA(INTEL, METEOR_LAKE_SOC_S_SMBUS,\tFEATURES_ICH5 | FEATURE_TCO_CNL) },\n\t{ PCI_DEVICE_DATA(INTEL, METEOR_LAKE_PCH_S_SMBUS,\tFEATURES_ICH5 | FEATURE_TCO_CNL) },\n\t{ PCI_DEVICE_DATA(INTEL, BIRCH_STREAM_SMBUS,\t\tFEATURES_ICH5 | FEATURE_TCO_CNL) },\n\t{ 0, }\n};\n\nMODULE_DEVICE_TABLE(pci, i801_ids);\n\n#if defined CONFIG_X86 && defined CONFIG_DMI\nstatic unsigned char apanel_addr;\n\n \nstatic __init const void __iomem *bios_signature(const void __iomem *bios)\n{\n\tssize_t offset;\n\tconst unsigned char signature[] = \"FJKEYINF\";\n\n\tfor (offset = 0; offset < 0x10000; offset += 0x10) {\n\t\tif (check_signature(bios + offset, signature,\n\t\t\t\t    sizeof(signature)-1))\n\t\t\treturn bios + offset;\n\t}\n\treturn NULL;\n}\n\nstatic void __init input_apanel_init(void)\n{\n\tvoid __iomem *bios;\n\tconst void __iomem *p;\n\n\tbios = ioremap(0xF0000, 0x10000);  \n\tp = bios_signature(bios);\n\tif (p) {\n\t\t \n\t\tapanel_addr = readb(p + 8 + 3) >> 1;\n\t}\n\tiounmap(bios);\n}\n\nstruct dmi_onboard_device_info {\n\tconst char *name;\n\tu8 type;\n\tunsigned short i2c_addr;\n\tconst char *i2c_type;\n};\n\nstatic const struct dmi_onboard_device_info dmi_devices[] = {\n\t{ \"Syleus\", DMI_DEV_TYPE_OTHER, 0x73, \"fscsyl\" },\n\t{ \"Hermes\", DMI_DEV_TYPE_OTHER, 0x73, \"fscher\" },\n\t{ \"Hades\",  DMI_DEV_TYPE_OTHER, 0x73, \"fschds\" },\n};\n\nstatic void dmi_check_onboard_device(u8 type, const char *name,\n\t\t\t\t     struct i2c_adapter *adap)\n{\n\tint i;\n\tstruct i2c_board_info info;\n\n\tfor (i = 0; i < ARRAY_SIZE(dmi_devices); i++) {\n\t\t \n\t\tif ((type & ~0x80) != dmi_devices[i].type)\n\t\t\tcontinue;\n\t\tif (strcasecmp(name, dmi_devices[i].name))\n\t\t\tcontinue;\n\n\t\tmemset(&info, 0, sizeof(struct i2c_board_info));\n\t\tinfo.addr = dmi_devices[i].i2c_addr;\n\t\tstrscpy(info.type, dmi_devices[i].i2c_type, I2C_NAME_SIZE);\n\t\ti2c_new_client_device(adap, &info);\n\t\tbreak;\n\t}\n}\n\n \nstatic void dmi_check_onboard_devices(const struct dmi_header *dm, void *adap)\n{\n\tint i, count;\n\n\tif (dm->type != 10)\n\t\treturn;\n\n\tcount = (dm->length - sizeof(struct dmi_header)) / 2;\n\tfor (i = 0; i < count; i++) {\n\t\tconst u8 *d = (char *)(dm + 1) + (i * 2);\n\t\tconst char *name = ((char *) dm) + dm->length;\n\t\tu8 type = d[0];\n\t\tu8 s = d[1];\n\n\t\tif (!s)\n\t\t\tcontinue;\n\t\ts--;\n\t\twhile (s > 0 && name[0]) {\n\t\t\tname += strlen(name) + 1;\n\t\t\ts--;\n\t\t}\n\t\tif (name[0] == 0)  \n\t\t\tcontinue;\n\n\t\tdmi_check_onboard_device(type, name, adap);\n\t}\n}\n\n \nstatic const char *const acpi_smo8800_ids[] = {\n\t\"SMO8800\",\n\t\"SMO8801\",\n\t\"SMO8810\",\n\t\"SMO8811\",\n\t\"SMO8820\",\n\t\"SMO8821\",\n\t\"SMO8830\",\n\t\"SMO8831\",\n};\n\nstatic acpi_status check_acpi_smo88xx_device(acpi_handle obj_handle,\n\t\t\t\t\t     u32 nesting_level,\n\t\t\t\t\t     void *context,\n\t\t\t\t\t     void **return_value)\n{\n\tstruct acpi_device_info *info;\n\tacpi_status status;\n\tchar *hid;\n\tint i;\n\n\tstatus = acpi_get_object_info(obj_handle, &info);\n\tif (ACPI_FAILURE(status))\n\t\treturn AE_OK;\n\n\tif (!(info->valid & ACPI_VALID_HID))\n\t\tgoto smo88xx_not_found;\n\n\thid = info->hardware_id.string;\n\tif (!hid)\n\t\tgoto smo88xx_not_found;\n\n\ti = match_string(acpi_smo8800_ids, ARRAY_SIZE(acpi_smo8800_ids), hid);\n\tif (i < 0)\n\t\tgoto smo88xx_not_found;\n\n\tkfree(info);\n\n\t*return_value = NULL;\n\treturn AE_CTRL_TERMINATE;\n\nsmo88xx_not_found:\n\tkfree(info);\n\treturn AE_OK;\n}\n\nstatic bool is_dell_system_with_lis3lv02d(void)\n{\n\tvoid *err = ERR_PTR(-ENOENT);\n\n\tif (!dmi_match(DMI_SYS_VENDOR, \"Dell Inc.\"))\n\t\treturn false;\n\n\t \n\tacpi_get_devices(NULL, check_acpi_smo88xx_device, NULL, &err);\n\n\treturn !IS_ERR(err);\n}\n\n \nstatic const struct {\n\tconst char *dmi_product_name;\n\tunsigned short i2c_addr;\n} dell_lis3lv02d_devices[] = {\n\t \n\t{ \"Latitude E5250\",     0x29 },\n\t{ \"Latitude E5450\",     0x29 },\n\t{ \"Latitude E5550\",     0x29 },\n\t{ \"Latitude E6440\",     0x29 },\n\t{ \"Latitude E6440 ATG\", 0x29 },\n\t{ \"Latitude E6540\",     0x29 },\n\t \n\t{ \"Latitude 5480\",      0x29 },\n\t{ \"Vostro V131\",        0x1d },\n\t{ \"Vostro 5568\",        0x29 },\n};\n\nstatic void register_dell_lis3lv02d_i2c_device(struct i801_priv *priv)\n{\n\tstruct i2c_board_info info;\n\tconst char *dmi_product_name;\n\tint i;\n\n\tdmi_product_name = dmi_get_system_info(DMI_PRODUCT_NAME);\n\tfor (i = 0; i < ARRAY_SIZE(dell_lis3lv02d_devices); ++i) {\n\t\tif (strcmp(dmi_product_name,\n\t\t\t   dell_lis3lv02d_devices[i].dmi_product_name) == 0)\n\t\t\tbreak;\n\t}\n\n\tif (i == ARRAY_SIZE(dell_lis3lv02d_devices)) {\n\t\tdev_warn(&priv->pci_dev->dev,\n\t\t\t \"Accelerometer lis3lv02d is present on SMBus but its\"\n\t\t\t \" address is unknown, skipping registration\\n\");\n\t\treturn;\n\t}\n\n\tmemset(&info, 0, sizeof(struct i2c_board_info));\n\tinfo.addr = dell_lis3lv02d_devices[i].i2c_addr;\n\tstrscpy(info.type, \"lis3lv02d\", I2C_NAME_SIZE);\n\ti2c_new_client_device(&priv->adapter, &info);\n}\n\n \nstatic void i801_probe_optional_slaves(struct i801_priv *priv)\n{\n\t \n\tif (priv->features & FEATURE_IDF)\n\t\treturn;\n\n\tif (apanel_addr) {\n\t\tstruct i2c_board_info info = {\n\t\t\t.addr = apanel_addr,\n\t\t\t.type = \"fujitsu_apanel\",\n\t\t};\n\n\t\ti2c_new_client_device(&priv->adapter, &info);\n\t}\n\n\tif (dmi_name_in_vendors(\"FUJITSU\"))\n\t\tdmi_walk(dmi_check_onboard_devices, &priv->adapter);\n\n\tif (is_dell_system_with_lis3lv02d())\n\t\tregister_dell_lis3lv02d_i2c_device(priv);\n\n\t \n#if IS_ENABLED(CONFIG_I2C_MUX_GPIO)\n\tif (!priv->mux_drvdata)\n#endif\n\t\ti2c_register_spd(&priv->adapter);\n}\n#else\nstatic void __init input_apanel_init(void) {}\nstatic void i801_probe_optional_slaves(struct i801_priv *priv) {}\n#endif\t \n\n#if IS_ENABLED(CONFIG_I2C_MUX_GPIO) && defined CONFIG_DMI\nstatic struct i801_mux_config i801_mux_config_asus_z8_d12 = {\n\t.gpio_chip = \"gpio_ich\",\n\t.values = { 0x02, 0x03 },\n\t.n_values = 2,\n\t.classes = { I2C_CLASS_SPD, I2C_CLASS_SPD },\n\t.gpios = { 52, 53 },\n\t.n_gpios = 2,\n};\n\nstatic struct i801_mux_config i801_mux_config_asus_z8_d18 = {\n\t.gpio_chip = \"gpio_ich\",\n\t.values = { 0x02, 0x03, 0x01 },\n\t.n_values = 3,\n\t.classes = { I2C_CLASS_SPD, I2C_CLASS_SPD, I2C_CLASS_SPD },\n\t.gpios = { 52, 53 },\n\t.n_gpios = 2,\n};\n\nstatic const struct dmi_system_id mux_dmi_table[] = {\n\t{\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"ASUSTeK Computer INC.\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"Z8NA-D6(C)\"),\n\t\t},\n\t\t.driver_data = &i801_mux_config_asus_z8_d12,\n\t},\n\t{\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"ASUSTeK Computer INC.\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"Z8P(N)E-D12(X)\"),\n\t\t},\n\t\t.driver_data = &i801_mux_config_asus_z8_d12,\n\t},\n\t{\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"ASUSTeK Computer INC.\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"Z8NH-D12\"),\n\t\t},\n\t\t.driver_data = &i801_mux_config_asus_z8_d12,\n\t},\n\t{\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"ASUSTeK Computer INC.\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"Z8PH-D12/IFB\"),\n\t\t},\n\t\t.driver_data = &i801_mux_config_asus_z8_d12,\n\t},\n\t{\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"ASUSTeK Computer INC.\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"Z8NR-D12\"),\n\t\t},\n\t\t.driver_data = &i801_mux_config_asus_z8_d12,\n\t},\n\t{\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"ASUSTeK Computer INC.\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"Z8P(N)H-D12\"),\n\t\t},\n\t\t.driver_data = &i801_mux_config_asus_z8_d12,\n\t},\n\t{\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"ASUSTeK Computer INC.\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"Z8PG-D18\"),\n\t\t},\n\t\t.driver_data = &i801_mux_config_asus_z8_d18,\n\t},\n\t{\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"ASUSTeK Computer INC.\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"Z8PE-D18\"),\n\t\t},\n\t\t.driver_data = &i801_mux_config_asus_z8_d18,\n\t},\n\t{\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"ASUSTeK Computer INC.\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"Z8PS-D12\"),\n\t\t},\n\t\t.driver_data = &i801_mux_config_asus_z8_d12,\n\t},\n\t{ }\n};\n\n \nstatic void i801_add_mux(struct i801_priv *priv)\n{\n\tstruct device *dev = &priv->adapter.dev;\n\tconst struct i801_mux_config *mux_config;\n\tstruct i2c_mux_gpio_platform_data gpio_data;\n\tstruct gpiod_lookup_table *lookup;\n\tint i;\n\n\tif (!priv->mux_drvdata)\n\t\treturn;\n\tmux_config = priv->mux_drvdata;\n\n\t \n\tmemset(&gpio_data, 0, sizeof(struct i2c_mux_gpio_platform_data));\n\tgpio_data.parent = priv->adapter.nr;\n\tgpio_data.values = mux_config->values;\n\tgpio_data.n_values = mux_config->n_values;\n\tgpio_data.classes = mux_config->classes;\n\tgpio_data.idle = I2C_MUX_GPIO_NO_IDLE;\n\n\t \n\tlookup = devm_kzalloc(dev,\n\t\t\t      struct_size(lookup, table, mux_config->n_gpios + 1),\n\t\t\t      GFP_KERNEL);\n\tif (!lookup)\n\t\treturn;\n\tlookup->dev_id = \"i2c-mux-gpio\";\n\tfor (i = 0; i < mux_config->n_gpios; i++)\n\t\tlookup->table[i] = GPIO_LOOKUP(mux_config->gpio_chip,\n\t\t\t\t\t       mux_config->gpios[i], \"mux\", 0);\n\tgpiod_add_lookup_table(lookup);\n\tpriv->lookup = lookup;\n\n\t \n\tpriv->mux_pdev = platform_device_register_data(dev, \"i2c-mux-gpio\",\n\t\t\t\tPLATFORM_DEVID_NONE, &gpio_data,\n\t\t\t\tsizeof(struct i2c_mux_gpio_platform_data));\n\tif (IS_ERR(priv->mux_pdev)) {\n\t\tgpiod_remove_lookup_table(lookup);\n\t\tdev_err(dev, \"Failed to register i2c-mux-gpio device\\n\");\n\t}\n}\n\nstatic void i801_del_mux(struct i801_priv *priv)\n{\n\tplatform_device_unregister(priv->mux_pdev);\n\tgpiod_remove_lookup_table(priv->lookup);\n}\n\nstatic unsigned int i801_get_adapter_class(struct i801_priv *priv)\n{\n\tconst struct dmi_system_id *id;\n\tconst struct i801_mux_config *mux_config;\n\tunsigned int class = I2C_CLASS_HWMON | I2C_CLASS_SPD;\n\tint i;\n\n\tid = dmi_first_match(mux_dmi_table);\n\tif (id) {\n\t\t \n\t\tmux_config = id->driver_data;\n\t\tfor (i = 0; i < mux_config->n_values; i++)\n\t\t\tclass &= ~mux_config->classes[i];\n\n\t\t \n\t\tpriv->mux_drvdata = mux_config;\n\t}\n\n\treturn class;\n}\n#else\nstatic inline void i801_add_mux(struct i801_priv *priv) { }\nstatic inline void i801_del_mux(struct i801_priv *priv) { }\n\nstatic inline unsigned int i801_get_adapter_class(struct i801_priv *priv)\n{\n\treturn I2C_CLASS_HWMON | I2C_CLASS_SPD;\n}\n#endif\n\nstatic struct platform_device *\ni801_add_tco_spt(struct i801_priv *priv, struct pci_dev *pci_dev,\n\t\t struct resource *tco_res)\n{\n\tstatic const struct itco_wdt_platform_data pldata = {\n\t\t.name = \"Intel PCH\",\n\t\t.version = 4,\n\t};\n\tstruct resource *res;\n\tint ret;\n\n\t \n\n\tres = &tco_res[1];\n\tret = p2sb_bar(pci_dev->bus, 0, res);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tif (pci_dev->device == PCI_DEVICE_ID_INTEL_DNV_SMBUS)\n\t\tres->start += SBREG_SMBCTRL_DNV;\n\telse\n\t\tres->start += SBREG_SMBCTRL;\n\n\tres->end = res->start + 3;\n\n\treturn platform_device_register_resndata(&pci_dev->dev, \"iTCO_wdt\", -1,\n\t\t\t\t\ttco_res, 2, &pldata, sizeof(pldata));\n}\n\nstatic struct platform_device *\ni801_add_tco_cnl(struct i801_priv *priv, struct pci_dev *pci_dev,\n\t\t struct resource *tco_res)\n{\n\tstatic const struct itco_wdt_platform_data pldata = {\n\t\t.name = \"Intel PCH\",\n\t\t.version = 6,\n\t};\n\n\treturn platform_device_register_resndata(&pci_dev->dev, \"iTCO_wdt\", -1,\n\t\t\t\t\t\t tco_res, 1, &pldata, sizeof(pldata));\n}\n\nstatic void i801_add_tco(struct i801_priv *priv)\n{\n\tstruct pci_dev *pci_dev = priv->pci_dev;\n\tstruct resource tco_res[2], *res;\n\tu32 tco_base, tco_ctl;\n\n\t \n\tif (acpi_has_watchdog())\n\t\treturn;\n\n\tif (!(priv->features & (FEATURE_TCO_SPT | FEATURE_TCO_CNL)))\n\t\treturn;\n\n\tpci_read_config_dword(pci_dev, TCOBASE, &tco_base);\n\tpci_read_config_dword(pci_dev, TCOCTL, &tco_ctl);\n\tif (!(tco_ctl & TCOCTL_EN))\n\t\treturn;\n\n\tmemset(tco_res, 0, sizeof(tco_res));\n\t \n\tres = &tco_res[0];\n\tres->start = tco_base & ~1;\n\tres->end = res->start + 32 - 1;\n\tres->flags = IORESOURCE_IO;\n\n\tif (priv->features & FEATURE_TCO_CNL)\n\t\tpriv->tco_pdev = i801_add_tco_cnl(priv, pci_dev, tco_res);\n\telse\n\t\tpriv->tco_pdev = i801_add_tco_spt(priv, pci_dev, tco_res);\n\n\tif (IS_ERR(priv->tco_pdev))\n\t\tdev_warn(&pci_dev->dev, \"failed to create iTCO device\\n\");\n}\n\n#ifdef CONFIG_ACPI\nstatic bool i801_acpi_is_smbus_ioport(const struct i801_priv *priv,\n\t\t\t\t      acpi_physical_address address)\n{\n\treturn address >= priv->smba &&\n\t       address <= pci_resource_end(priv->pci_dev, SMBBAR);\n}\n\nstatic acpi_status\ni801_acpi_io_handler(u32 function, acpi_physical_address address, u32 bits,\n\t\t     u64 *value, void *handler_context, void *region_context)\n{\n\tstruct i801_priv *priv = handler_context;\n\tstruct pci_dev *pdev = priv->pci_dev;\n\tacpi_status status;\n\n\t \n\tmutex_lock(&priv->acpi_lock);\n\n\tif (!priv->acpi_reserved && i801_acpi_is_smbus_ioport(priv, address)) {\n\t\tpriv->acpi_reserved = true;\n\n\t\tdev_warn(&pdev->dev, \"BIOS is accessing SMBus registers\\n\");\n\t\tdev_warn(&pdev->dev, \"Driver SMBus register access inhibited\\n\");\n\n\t\t \n\t\tpm_runtime_get_sync(&pdev->dev);\n\t}\n\n\tif ((function & ACPI_IO_MASK) == ACPI_READ)\n\t\tstatus = acpi_os_read_port(address, (u32 *)value, bits);\n\telse\n\t\tstatus = acpi_os_write_port(address, (u32)*value, bits);\n\n\tmutex_unlock(&priv->acpi_lock);\n\n\treturn status;\n}\n\nstatic int i801_acpi_probe(struct i801_priv *priv)\n{\n\tacpi_handle ah = ACPI_HANDLE(&priv->pci_dev->dev);\n\tacpi_status status;\n\n\tstatus = acpi_install_address_space_handler(ah, ACPI_ADR_SPACE_SYSTEM_IO,\n\t\t\t\t\t\t    i801_acpi_io_handler, NULL, priv);\n\tif (ACPI_SUCCESS(status))\n\t\treturn 0;\n\n\treturn acpi_check_resource_conflict(&priv->pci_dev->resource[SMBBAR]);\n}\n\nstatic void i801_acpi_remove(struct i801_priv *priv)\n{\n\tacpi_handle ah = ACPI_HANDLE(&priv->pci_dev->dev);\n\n\tacpi_remove_address_space_handler(ah, ACPI_ADR_SPACE_SYSTEM_IO, i801_acpi_io_handler);\n}\n#else\nstatic inline int i801_acpi_probe(struct i801_priv *priv) { return 0; }\nstatic inline void i801_acpi_remove(struct i801_priv *priv) { }\n#endif\n\nstatic void i801_setup_hstcfg(struct i801_priv *priv)\n{\n\tunsigned char hstcfg = priv->original_hstcfg;\n\n\thstcfg &= ~SMBHSTCFG_I2C_EN;\t \n\thstcfg |= SMBHSTCFG_HST_EN;\n\tpci_write_config_byte(priv->pci_dev, SMBHSTCFG, hstcfg);\n}\n\nstatic int i801_probe(struct pci_dev *dev, const struct pci_device_id *id)\n{\n\tint err, i;\n\tstruct i801_priv *priv;\n\n\tpriv = devm_kzalloc(&dev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\ti2c_set_adapdata(&priv->adapter, priv);\n\tpriv->adapter.owner = THIS_MODULE;\n\tpriv->adapter.class = i801_get_adapter_class(priv);\n\tpriv->adapter.algo = &smbus_algorithm;\n\tpriv->adapter.dev.parent = &dev->dev;\n\tACPI_COMPANION_SET(&priv->adapter.dev, ACPI_COMPANION(&dev->dev));\n\tpriv->adapter.retries = 3;\n\tmutex_init(&priv->acpi_lock);\n\n\tpriv->pci_dev = dev;\n\tpriv->features = id->driver_data;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(i801_feature_names); i++) {\n\t\tif (priv->features & disable_features & (1 << i))\n\t\t\tdev_notice(&dev->dev, \"%s disabled by user\\n\",\n\t\t\t\t   i801_feature_names[i]);\n\t}\n\tpriv->features &= ~disable_features;\n\n\t \n\tif (!(priv->features & FEATURE_BLOCK_BUFFER))\n\t\tpriv->features &= ~FEATURE_BLOCK_PROC;\n\n\terr = pcim_enable_device(dev);\n\tif (err) {\n\t\tdev_err(&dev->dev, \"Failed to enable SMBus PCI device (%d)\\n\",\n\t\t\terr);\n\t\treturn err;\n\t}\n\tpcim_pin_device(dev);\n\n\t \n\tpriv->smba = pci_resource_start(dev, SMBBAR);\n\tif (!priv->smba) {\n\t\tdev_err(&dev->dev,\n\t\t\t\"SMBus base address uninitialized, upgrade BIOS\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (i801_acpi_probe(priv))\n\t\treturn -ENODEV;\n\n\terr = pcim_iomap_regions(dev, 1 << SMBBAR, DRV_NAME);\n\tif (err) {\n\t\tdev_err(&dev->dev,\n\t\t\t\"Failed to request SMBus region 0x%lx-0x%Lx\\n\",\n\t\t\tpriv->smba,\n\t\t\t(unsigned long long)pci_resource_end(dev, SMBBAR));\n\t\ti801_acpi_remove(priv);\n\t\treturn err;\n\t}\n\n\tpci_read_config_byte(priv->pci_dev, SMBHSTCFG, &priv->original_hstcfg);\n\ti801_setup_hstcfg(priv);\n\tif (!(priv->original_hstcfg & SMBHSTCFG_HST_EN))\n\t\tdev_info(&dev->dev, \"Enabling SMBus device\\n\");\n\n\tif (priv->original_hstcfg & SMBHSTCFG_SMB_SMI_EN) {\n\t\tdev_dbg(&dev->dev, \"SMBus using interrupt SMI#\\n\");\n\t\t \n\t\tpriv->features &= ~FEATURE_IRQ;\n\t}\n\tif (priv->original_hstcfg & SMBHSTCFG_SPD_WD)\n\t\tdev_info(&dev->dev, \"SPD Write Disable is set\\n\");\n\n\t \n\tif (priv->features & (FEATURE_SMBUS_PEC | FEATURE_BLOCK_BUFFER))\n\t\toutb_p(inb_p(SMBAUXCTL(priv)) &\n\t\t       ~(SMBAUXCTL_CRC | SMBAUXCTL_E32B), SMBAUXCTL(priv));\n\n\t \n\tpriv->adapter.timeout = HZ / 5;\n\n\tif (dev->irq == IRQ_NOTCONNECTED)\n\t\tpriv->features &= ~FEATURE_IRQ;\n\n\tif (priv->features & FEATURE_IRQ) {\n\t\tu16 pcists;\n\n\t\t \n\t\tpci_read_config_word(priv->pci_dev, PCI_STATUS, &pcists);\n\t\tif (pcists & PCI_STATUS_INTERRUPT)\n\t\t\tdev_warn(&dev->dev, \"An interrupt is pending!\\n\");\n\t}\n\n\tif (priv->features & FEATURE_IRQ) {\n\t\tinit_completion(&priv->done);\n\n\t\terr = devm_request_irq(&dev->dev, dev->irq, i801_isr,\n\t\t\t\t       IRQF_SHARED, DRV_NAME, priv);\n\t\tif (err) {\n\t\t\tdev_err(&dev->dev, \"Failed to allocate irq %d: %d\\n\",\n\t\t\t\tdev->irq, err);\n\t\t\tpriv->features &= ~FEATURE_IRQ;\n\t\t}\n\t}\n\tdev_info(&dev->dev, \"SMBus using %s\\n\",\n\t\t priv->features & FEATURE_IRQ ? \"PCI interrupt\" : \"polling\");\n\n\t \n\tif (!(priv->features & FEATURE_IRQ))\n\t\tpriv->features &= ~FEATURE_HOST_NOTIFY;\n\n\t \n\tpriv->original_hstcnt = inb_p(SMBHSTCNT(priv)) & ~SMBHSTCNT_KILL;\n\tif (priv->features & FEATURE_HOST_NOTIFY)\n\t\tpriv->original_slvcmd = inb_p(SMBSLVCMD(priv));\n\n\ti801_add_tco(priv);\n\n\tsnprintf(priv->adapter.name, sizeof(priv->adapter.name),\n\t\t\"SMBus I801 adapter at %04lx\", priv->smba);\n\terr = i2c_add_adapter(&priv->adapter);\n\tif (err) {\n\t\tplatform_device_unregister(priv->tco_pdev);\n\t\ti801_acpi_remove(priv);\n\t\treturn err;\n\t}\n\n\ti801_enable_host_notify(&priv->adapter);\n\n\ti801_probe_optional_slaves(priv);\n\t \n\ti801_add_mux(priv);\n\n\tpci_set_drvdata(dev, priv);\n\n\tdev_pm_set_driver_flags(&dev->dev, DPM_FLAG_NO_DIRECT_COMPLETE);\n\tpm_runtime_set_autosuspend_delay(&dev->dev, 1000);\n\tpm_runtime_use_autosuspend(&dev->dev);\n\tpm_runtime_put_autosuspend(&dev->dev);\n\tpm_runtime_allow(&dev->dev);\n\n\treturn 0;\n}\n\nstatic void i801_remove(struct pci_dev *dev)\n{\n\tstruct i801_priv *priv = pci_get_drvdata(dev);\n\n\toutb_p(priv->original_hstcnt, SMBHSTCNT(priv));\n\ti801_disable_host_notify(priv);\n\ti801_del_mux(priv);\n\ti2c_del_adapter(&priv->adapter);\n\ti801_acpi_remove(priv);\n\tpci_write_config_byte(dev, SMBHSTCFG, priv->original_hstcfg);\n\n\tplatform_device_unregister(priv->tco_pdev);\n\n\t \n\tif (!priv->acpi_reserved)\n\t\tpm_runtime_get_noresume(&dev->dev);\n\n\t \n}\n\nstatic void i801_shutdown(struct pci_dev *dev)\n{\n\tstruct i801_priv *priv = pci_get_drvdata(dev);\n\n\t \n\toutb_p(priv->original_hstcnt, SMBHSTCNT(priv));\n\ti801_disable_host_notify(priv);\n\tpci_write_config_byte(dev, SMBHSTCFG, priv->original_hstcfg);\n}\n\nstatic int i801_suspend(struct device *dev)\n{\n\tstruct i801_priv *priv = dev_get_drvdata(dev);\n\n\toutb_p(priv->original_hstcnt, SMBHSTCNT(priv));\n\tpci_write_config_byte(priv->pci_dev, SMBHSTCFG, priv->original_hstcfg);\n\treturn 0;\n}\n\nstatic int i801_resume(struct device *dev)\n{\n\tstruct i801_priv *priv = dev_get_drvdata(dev);\n\n\ti801_setup_hstcfg(priv);\n\ti801_enable_host_notify(&priv->adapter);\n\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(i801_pm_ops, i801_suspend, i801_resume);\n\nstatic struct pci_driver i801_driver = {\n\t.name\t\t= DRV_NAME,\n\t.id_table\t= i801_ids,\n\t.probe\t\t= i801_probe,\n\t.remove\t\t= i801_remove,\n\t.shutdown\t= i801_shutdown,\n\t.driver\t\t= {\n\t\t.pm\t= pm_sleep_ptr(&i801_pm_ops),\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t},\n};\n\nstatic int __init i2c_i801_init(void)\n{\n\tif (dmi_name_in_vendors(\"FUJITSU\"))\n\t\tinput_apanel_init();\n\treturn pci_register_driver(&i801_driver);\n}\n\nstatic void __exit i2c_i801_exit(void)\n{\n\tpci_unregister_driver(&i801_driver);\n}\n\nMODULE_AUTHOR(\"Mark D. Studebaker <mdsxyz123@yahoo.com>\");\nMODULE_AUTHOR(\"Jean Delvare <jdelvare@suse.de>\");\nMODULE_DESCRIPTION(\"I801 SMBus driver\");\nMODULE_LICENSE(\"GPL\");\n\nmodule_init(i2c_i801_init);\nmodule_exit(i2c_i801_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}