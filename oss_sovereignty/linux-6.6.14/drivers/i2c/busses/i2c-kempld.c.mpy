{
  "module_name": "i2c-kempld.c",
  "hash_id": "aad155f3c33e8e770aeb4418dd385ca7ad865674e169cfddd751e84ecc3a0b94",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-kempld.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/i2c.h>\n#include <linux/delay.h>\n#include <linux/mfd/kempld.h>\n\n#define KEMPLD_I2C_PRELOW\t0x0b\n#define KEMPLD_I2C_PREHIGH\t0x0c\n#define KEMPLD_I2C_DATA\t\t0x0e\n\n#define KEMPLD_I2C_CTRL\t\t0x0d\n#define I2C_CTRL_IEN\t\t0x40\n#define I2C_CTRL_EN\t\t0x80\n\n#define KEMPLD_I2C_STAT\t\t0x0f\n#define I2C_STAT_IF\t\t0x01\n#define I2C_STAT_TIP\t\t0x02\n#define I2C_STAT_ARBLOST\t0x20\n#define I2C_STAT_BUSY\t\t0x40\n#define I2C_STAT_NACK\t\t0x80\n\n#define KEMPLD_I2C_CMD\t\t0x0f\n#define I2C_CMD_START\t\t0x91\n#define I2C_CMD_STOP\t\t0x41\n#define I2C_CMD_READ\t\t0x21\n#define I2C_CMD_WRITE\t\t0x11\n#define I2C_CMD_READ_ACK\t0x21\n#define I2C_CMD_READ_NACK\t0x29\n#define I2C_CMD_IACK\t\t0x01\n\n#define KEMPLD_I2C_FREQ_MAX\t2700\t \n#define KEMPLD_I2C_FREQ_STD\t100\t \n\nenum {\n\tSTATE_DONE = 0,\n\tSTATE_INIT,\n\tSTATE_ADDR,\n\tSTATE_ADDR10,\n\tSTATE_START,\n\tSTATE_WRITE,\n\tSTATE_READ,\n\tSTATE_ERROR,\n};\n\nstruct kempld_i2c_data {\n\tstruct device\t\t\t*dev;\n\tstruct kempld_device_data\t*pld;\n\tstruct i2c_adapter\t\tadap;\n\tstruct i2c_msg\t\t\t*msg;\n\tint\t\t\t\tpos;\n\tint\t\t\t\tnmsgs;\n\tint\t\t\t\tstate;\n\tbool\t\t\t\twas_active;\n};\n\nstatic unsigned int bus_frequency = KEMPLD_I2C_FREQ_STD;\nmodule_param(bus_frequency, uint, 0);\nMODULE_PARM_DESC(bus_frequency, \"Set I2C bus frequency in kHz (default=\"\n\t\t\t\t__MODULE_STRING(KEMPLD_I2C_FREQ_STD)\")\");\n\nstatic int i2c_bus = -1;\nmodule_param(i2c_bus, int, 0);\nMODULE_PARM_DESC(i2c_bus, \"Set I2C bus number (default=-1 for dynamic assignment)\");\n\nstatic bool i2c_gpio_mux;\nmodule_param(i2c_gpio_mux, bool, 0);\nMODULE_PARM_DESC(i2c_gpio_mux, \"Enable I2C port on GPIO out (default=false)\");\n\n \nstatic int kempld_i2c_process(struct kempld_i2c_data *i2c)\n{\n\tstruct kempld_device_data *pld = i2c->pld;\n\tu8 stat = kempld_read8(pld, KEMPLD_I2C_STAT);\n\tstruct i2c_msg *msg = i2c->msg;\n\tu8 addr;\n\n\t \n\tif (stat & I2C_STAT_TIP)\n\t\treturn -EBUSY;\n\n\tif (i2c->state == STATE_DONE || i2c->state == STATE_ERROR) {\n\t\t \n\t\tkempld_write8(pld, KEMPLD_I2C_CMD, I2C_CMD_IACK);\n\t\tif (i2c->state == STATE_ERROR)\n\t\t\treturn -EIO;\n\t\treturn 0;\n\t}\n\n\t \n\tif (stat & I2C_STAT_ARBLOST) {\n\t\ti2c->state = STATE_ERROR;\n\t\tkempld_write8(pld, KEMPLD_I2C_CMD, I2C_CMD_STOP);\n\t\treturn -EAGAIN;\n\t}\n\n\tif (i2c->state == STATE_INIT) {\n\t\tif (stat & I2C_STAT_BUSY)\n\t\t\treturn -EBUSY;\n\n\t\ti2c->state = STATE_ADDR;\n\t}\n\n\tif (i2c->state == STATE_ADDR) {\n\t\t \n\t\tif (i2c->msg->flags & I2C_M_TEN) {\n\t\t\taddr = 0xf0 | ((i2c->msg->addr >> 7) & 0x6);\n\t\t\t \n\t\t\taddr |= (i2c->msg->flags & I2C_M_RD) ? 1 : 0;\n\t\t\ti2c->state = STATE_ADDR10;\n\t\t} else {\n\t\t\taddr = i2c_8bit_addr_from_msg(i2c->msg);\n\t\t\ti2c->state = STATE_START;\n\t\t}\n\n\t\tkempld_write8(pld, KEMPLD_I2C_DATA, addr);\n\t\tkempld_write8(pld, KEMPLD_I2C_CMD, I2C_CMD_START);\n\n\t\treturn 0;\n\t}\n\n\t \n\tif (i2c->state == STATE_ADDR10) {\n\t\tkempld_write8(pld, KEMPLD_I2C_DATA, i2c->msg->addr & 0xff);\n\t\tkempld_write8(pld, KEMPLD_I2C_CMD, I2C_CMD_WRITE);\n\n\t\ti2c->state = STATE_START;\n\t\treturn 0;\n\t}\n\n\tif (i2c->state == STATE_START || i2c->state == STATE_WRITE) {\n\t\ti2c->state = (msg->flags & I2C_M_RD) ? STATE_READ : STATE_WRITE;\n\n\t\tif (stat & I2C_STAT_NACK) {\n\t\t\ti2c->state = STATE_ERROR;\n\t\t\tkempld_write8(pld, KEMPLD_I2C_CMD, I2C_CMD_STOP);\n\t\t\treturn -ENXIO;\n\t\t}\n\t} else {\n\t\tmsg->buf[i2c->pos++] = kempld_read8(pld, KEMPLD_I2C_DATA);\n\t}\n\n\tif (i2c->pos >= msg->len) {\n\t\ti2c->nmsgs--;\n\t\ti2c->msg++;\n\t\ti2c->pos = 0;\n\t\tmsg = i2c->msg;\n\n\t\tif (i2c->nmsgs) {\n\t\t\tif (!(msg->flags & I2C_M_NOSTART)) {\n\t\t\t\ti2c->state = STATE_ADDR;\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\ti2c->state = (msg->flags & I2C_M_RD)\n\t\t\t\t\t? STATE_READ : STATE_WRITE;\n\t\t\t}\n\t\t} else {\n\t\t\ti2c->state = STATE_DONE;\n\t\t\tkempld_write8(pld, KEMPLD_I2C_CMD, I2C_CMD_STOP);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (i2c->state == STATE_READ) {\n\t\tkempld_write8(pld, KEMPLD_I2C_CMD, i2c->pos == (msg->len - 1) ?\n\t\t\t      I2C_CMD_READ_NACK : I2C_CMD_READ_ACK);\n\t} else {\n\t\tkempld_write8(pld, KEMPLD_I2C_DATA, msg->buf[i2c->pos++]);\n\t\tkempld_write8(pld, KEMPLD_I2C_CMD, I2C_CMD_WRITE);\n\t}\n\n\treturn 0;\n}\n\nstatic int kempld_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs,\n\t\t\t\tint num)\n{\n\tstruct kempld_i2c_data *i2c = i2c_get_adapdata(adap);\n\tstruct kempld_device_data *pld = i2c->pld;\n\tunsigned long timeout = jiffies + HZ;\n\tint ret;\n\n\ti2c->msg = msgs;\n\ti2c->pos = 0;\n\ti2c->nmsgs = num;\n\ti2c->state = STATE_INIT;\n\n\t \n\twhile (time_before(jiffies, timeout)) {\n\t\tkempld_get_mutex(pld);\n\t\tret = kempld_i2c_process(i2c);\n\t\tkempld_release_mutex(pld);\n\n\t\tif (i2c->state == STATE_DONE || i2c->state == STATE_ERROR)\n\t\t\treturn (i2c->state == STATE_DONE) ? num : ret;\n\n\t\tif (ret == 0)\n\t\t\ttimeout = jiffies + HZ;\n\n\t\tusleep_range(5, 15);\n\t}\n\n\ti2c->state = STATE_ERROR;\n\n\treturn -ETIMEDOUT;\n}\n\n \nstatic void kempld_i2c_device_init(struct kempld_i2c_data *i2c)\n{\n\tstruct kempld_device_data *pld = i2c->pld;\n\tu16 prescale_corr;\n\tlong prescale;\n\tu8 ctrl;\n\tu8 stat;\n\tu8 cfg;\n\n\t \n\tctrl = kempld_read8(pld, KEMPLD_I2C_CTRL);\n\tctrl &= ~(I2C_CTRL_EN | I2C_CTRL_IEN);\n\tkempld_write8(pld, KEMPLD_I2C_CTRL, ctrl);\n\n\tif (bus_frequency > KEMPLD_I2C_FREQ_MAX)\n\t\tbus_frequency = KEMPLD_I2C_FREQ_MAX;\n\n\tif (pld->info.spec_major == 1)\n\t\tprescale = pld->pld_clock / (bus_frequency * 5) - 1000;\n\telse\n\t\tprescale = pld->pld_clock / (bus_frequency * 4) - 3000;\n\n\tif (prescale < 0)\n\t\tprescale = 0;\n\n\t \n\tprescale_corr = prescale / 1000;\n\tif (prescale % 1000 >= 500)\n\t\tprescale_corr++;\n\n\tkempld_write8(pld, KEMPLD_I2C_PRELOW, prescale_corr & 0xff);\n\tkempld_write8(pld, KEMPLD_I2C_PREHIGH, prescale_corr >> 8);\n\n\t \n\tcfg = kempld_read8(pld, KEMPLD_CFG);\n\tif (i2c_gpio_mux)\n\t\tcfg |= KEMPLD_CFG_GPIO_I2C_MUX;\n\telse\n\t\tcfg &= ~KEMPLD_CFG_GPIO_I2C_MUX;\n\tkempld_write8(pld, KEMPLD_CFG, cfg);\n\n\t \n\tkempld_write8(pld, KEMPLD_I2C_CMD, I2C_CMD_IACK);\n\tctrl |= I2C_CTRL_EN;\n\tkempld_write8(pld, KEMPLD_I2C_CTRL, ctrl);\n\n\tstat = kempld_read8(pld, KEMPLD_I2C_STAT);\n\tif (stat & I2C_STAT_BUSY)\n\t\tkempld_write8(pld, KEMPLD_I2C_CMD, I2C_CMD_STOP);\n}\n\nstatic u32 kempld_i2c_func(struct i2c_adapter *adap)\n{\n\treturn I2C_FUNC_I2C | I2C_FUNC_10BIT_ADDR | I2C_FUNC_SMBUS_EMUL;\n}\n\nstatic const struct i2c_algorithm kempld_i2c_algorithm = {\n\t.master_xfer\t= kempld_i2c_xfer,\n\t.functionality\t= kempld_i2c_func,\n};\n\nstatic const struct i2c_adapter kempld_i2c_adapter = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"i2c-kempld\",\n\t.class\t\t= I2C_CLASS_HWMON | I2C_CLASS_SPD |\n\t\t\t  I2C_CLASS_DEPRECATED,\n\t.algo\t\t= &kempld_i2c_algorithm,\n};\n\nstatic int kempld_i2c_probe(struct platform_device *pdev)\n{\n\tstruct kempld_device_data *pld = dev_get_drvdata(pdev->dev.parent);\n\tstruct kempld_i2c_data *i2c;\n\tint ret;\n\tu8 ctrl;\n\n\ti2c = devm_kzalloc(&pdev->dev, sizeof(*i2c), GFP_KERNEL);\n\tif (!i2c)\n\t\treturn -ENOMEM;\n\n\ti2c->pld = pld;\n\ti2c->dev = &pdev->dev;\n\ti2c->adap = kempld_i2c_adapter;\n\ti2c->adap.dev.parent = i2c->dev;\n\tACPI_COMPANION_SET(&i2c->adap.dev, ACPI_COMPANION(&pdev->dev));\n\ti2c_set_adapdata(&i2c->adap, i2c);\n\tplatform_set_drvdata(pdev, i2c);\n\n\tkempld_get_mutex(pld);\n\tctrl = kempld_read8(pld, KEMPLD_I2C_CTRL);\n\n\tif (ctrl & I2C_CTRL_EN)\n\t\ti2c->was_active = true;\n\n\tkempld_i2c_device_init(i2c);\n\tkempld_release_mutex(pld);\n\n\t \n\tif (i2c_bus >= -1)\n\t\ti2c->adap.nr = i2c_bus;\n\tret = i2c_add_numbered_adapter(&i2c->adap);\n\tif (ret)\n\t\treturn ret;\n\n\tdev_info(i2c->dev, \"I2C bus initialized at %dkHz\\n\",\n\t\t bus_frequency);\n\n\treturn 0;\n}\n\nstatic void kempld_i2c_remove(struct platform_device *pdev)\n{\n\tstruct kempld_i2c_data *i2c = platform_get_drvdata(pdev);\n\tstruct kempld_device_data *pld = i2c->pld;\n\tu8 ctrl;\n\n\tkempld_get_mutex(pld);\n\t \n\tif (!i2c->was_active) {\n\t\tctrl = kempld_read8(pld, KEMPLD_I2C_CTRL);\n\t\tctrl &= ~I2C_CTRL_EN;\n\t\tkempld_write8(pld, KEMPLD_I2C_CTRL, ctrl);\n\t}\n\tkempld_release_mutex(pld);\n\n\ti2c_del_adapter(&i2c->adap);\n}\n\nstatic int kempld_i2c_suspend(struct device *dev)\n{\n\tstruct kempld_i2c_data *i2c = dev_get_drvdata(dev);\n\tstruct kempld_device_data *pld = i2c->pld;\n\tu8 ctrl;\n\n\tkempld_get_mutex(pld);\n\tctrl = kempld_read8(pld, KEMPLD_I2C_CTRL);\n\tctrl &= ~I2C_CTRL_EN;\n\tkempld_write8(pld, KEMPLD_I2C_CTRL, ctrl);\n\tkempld_release_mutex(pld);\n\n\treturn 0;\n}\n\nstatic int kempld_i2c_resume(struct device *dev)\n{\n\tstruct kempld_i2c_data *i2c = dev_get_drvdata(dev);\n\tstruct kempld_device_data *pld = i2c->pld;\n\n\tkempld_get_mutex(pld);\n\tkempld_i2c_device_init(i2c);\n\tkempld_release_mutex(pld);\n\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(kempld_i2c_pm_ops,\n\t\t\t\tkempld_i2c_suspend, kempld_i2c_resume);\n\nstatic struct platform_driver kempld_i2c_driver = {\n\t.driver = {\n\t\t.name = \"kempld-i2c\",\n\t\t.pm = pm_sleep_ptr(&kempld_i2c_pm_ops),\n\t},\n\t.probe\t\t= kempld_i2c_probe,\n\t.remove_new\t= kempld_i2c_remove,\n};\n\nmodule_platform_driver(kempld_i2c_driver);\n\nMODULE_DESCRIPTION(\"KEM PLD I2C Driver\");\nMODULE_AUTHOR(\"Michael Brunner <michael.brunner@kontron.com>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:kempld_i2c\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}