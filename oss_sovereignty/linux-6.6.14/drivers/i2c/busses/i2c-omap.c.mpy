{
  "module_name": "i2c-omap.c",
  "hash_id": "dd24aab59367370510ca850becf30beb64b7e0cc0b41123a5683eddac3f8744f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-omap.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/i2c.h>\n#include <linux/err.h>\n#include <linux/interrupt.h>\n#include <linux/completion.h>\n#include <linux/platform_device.h>\n#include <linux/clk.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n#include <linux/slab.h>\n#include <linux/platform_data/i2c-omap.h>\n#include <linux/pm_runtime.h>\n#include <linux/pinctrl/consumer.h>\n\n \n#define OMAP_I2C_OMAP1_REV_2\t\t0x20\n\n \n#define OMAP_I2C_REV_ON_2430\t\t0x00000036\n#define OMAP_I2C_REV_ON_3430_3530\t0x0000003C\n#define OMAP_I2C_REV_ON_3630\t\t0x00000040\n#define OMAP_I2C_REV_ON_4430_PLUS\t0x50400002\n\n \n#define OMAP_I2C_TIMEOUT (msecs_to_jiffies(1000))\n\n \n#define OMAP_I2C_PM_TIMEOUT\t\t1000\t \n\n \n#define OMAP_I2C_BUS_FREE_TIMEOUT (msecs_to_jiffies(10))\n\n \nenum {\n\tOMAP_I2C_REV_REG = 0,\n\tOMAP_I2C_IE_REG,\n\tOMAP_I2C_STAT_REG,\n\tOMAP_I2C_IV_REG,\n\tOMAP_I2C_WE_REG,\n\tOMAP_I2C_SYSS_REG,\n\tOMAP_I2C_BUF_REG,\n\tOMAP_I2C_CNT_REG,\n\tOMAP_I2C_DATA_REG,\n\tOMAP_I2C_SYSC_REG,\n\tOMAP_I2C_CON_REG,\n\tOMAP_I2C_OA_REG,\n\tOMAP_I2C_SA_REG,\n\tOMAP_I2C_PSC_REG,\n\tOMAP_I2C_SCLL_REG,\n\tOMAP_I2C_SCLH_REG,\n\tOMAP_I2C_SYSTEST_REG,\n\tOMAP_I2C_BUFSTAT_REG,\n\t \n\tOMAP_I2C_IP_V2_REVNB_LO,\n\tOMAP_I2C_IP_V2_REVNB_HI,\n\tOMAP_I2C_IP_V2_IRQSTATUS_RAW,\n\tOMAP_I2C_IP_V2_IRQENABLE_SET,\n\tOMAP_I2C_IP_V2_IRQENABLE_CLR,\n};\n\n \n#define OMAP_I2C_IE_XDR\t\t(1 << 14)\t \n#define OMAP_I2C_IE_RDR\t\t(1 << 13)\t \n#define OMAP_I2C_IE_XRDY\t(1 << 4)\t \n#define OMAP_I2C_IE_RRDY\t(1 << 3)\t \n#define OMAP_I2C_IE_ARDY\t(1 << 2)\t \n#define OMAP_I2C_IE_NACK\t(1 << 1)\t \n#define OMAP_I2C_IE_AL\t\t(1 << 0)\t \n\n \n#define OMAP_I2C_STAT_XDR\t(1 << 14)\t \n#define OMAP_I2C_STAT_RDR\t(1 << 13)\t \n#define OMAP_I2C_STAT_BB\t(1 << 12)\t \n#define OMAP_I2C_STAT_ROVR\t(1 << 11)\t \n#define OMAP_I2C_STAT_XUDF\t(1 << 10)\t \n#define OMAP_I2C_STAT_AAS\t(1 << 9)\t \n#define OMAP_I2C_STAT_BF\t(1 << 8)\t \n#define OMAP_I2C_STAT_XRDY\t(1 << 4)\t \n#define OMAP_I2C_STAT_RRDY\t(1 << 3)\t \n#define OMAP_I2C_STAT_ARDY\t(1 << 2)\t \n#define OMAP_I2C_STAT_NACK\t(1 << 1)\t \n#define OMAP_I2C_STAT_AL\t(1 << 0)\t \n\n \n#define OMAP_I2C_WE_XDR_WE\t(1 << 14)\t \n#define OMAP_I2C_WE_RDR_WE\t(1 << 13)\t \n#define OMAP_I2C_WE_AAS_WE\t(1 << 9)\t \n#define OMAP_I2C_WE_BF_WE\t(1 << 8)\t \n#define OMAP_I2C_WE_STC_WE\t(1 << 6)\t \n#define OMAP_I2C_WE_GC_WE\t(1 << 5)\t \n#define OMAP_I2C_WE_DRDY_WE\t(1 << 3)\t \n#define OMAP_I2C_WE_ARDY_WE\t(1 << 2)\t \n#define OMAP_I2C_WE_NACK_WE\t(1 << 1)\t \n#define OMAP_I2C_WE_AL_WE\t(1 << 0)\t \n\n#define OMAP_I2C_WE_ALL\t\t(OMAP_I2C_WE_XDR_WE | OMAP_I2C_WE_RDR_WE | \\\n\t\t\t\tOMAP_I2C_WE_AAS_WE | OMAP_I2C_WE_BF_WE | \\\n\t\t\t\tOMAP_I2C_WE_STC_WE | OMAP_I2C_WE_GC_WE | \\\n\t\t\t\tOMAP_I2C_WE_DRDY_WE | OMAP_I2C_WE_ARDY_WE | \\\n\t\t\t\tOMAP_I2C_WE_NACK_WE | OMAP_I2C_WE_AL_WE)\n\n \n#define OMAP_I2C_BUF_RDMA_EN\t(1 << 15)\t \n#define OMAP_I2C_BUF_RXFIF_CLR\t(1 << 14)\t \n#define OMAP_I2C_BUF_XDMA_EN\t(1 << 7)\t \n#define OMAP_I2C_BUF_TXFIF_CLR\t(1 << 6)\t \n\n \n#define OMAP_I2C_CON_EN\t\t(1 << 15)\t \n#define OMAP_I2C_CON_BE\t\t(1 << 14)\t \n#define OMAP_I2C_CON_OPMODE_HS\t(1 << 12)\t \n#define OMAP_I2C_CON_STB\t(1 << 11)\t \n#define OMAP_I2C_CON_MST\t(1 << 10)\t \n#define OMAP_I2C_CON_TRX\t(1 << 9)\t \n#define OMAP_I2C_CON_XA\t\t(1 << 8)\t \n#define OMAP_I2C_CON_RM\t\t(1 << 2)\t \n#define OMAP_I2C_CON_STP\t(1 << 1)\t \n#define OMAP_I2C_CON_STT\t(1 << 0)\t \n\n \n#define OMAP_I2C_SCLL_HSSCLL\t8\n#define OMAP_I2C_SCLH_HSSCLH\t8\n\n \n#define OMAP_I2C_SYSTEST_ST_EN\t\t(1 << 15)\t \n#define OMAP_I2C_SYSTEST_FREE\t\t(1 << 14)\t \n#define OMAP_I2C_SYSTEST_TMODE_MASK\t(3 << 12)\t \n#define OMAP_I2C_SYSTEST_TMODE_SHIFT\t(12)\t\t \n \n#define OMAP_I2C_SYSTEST_SCL_I_FUNC\t(1 << 8)\t \n#define OMAP_I2C_SYSTEST_SCL_O_FUNC\t(1 << 7)\t \n#define OMAP_I2C_SYSTEST_SDA_I_FUNC\t(1 << 6)\t \n#define OMAP_I2C_SYSTEST_SDA_O_FUNC\t(1 << 5)\t \n \n#define OMAP_I2C_SYSTEST_SCL_I\t\t(1 << 3)\t \n#define OMAP_I2C_SYSTEST_SCL_O\t\t(1 << 2)\t \n#define OMAP_I2C_SYSTEST_SDA_I\t\t(1 << 1)\t \n#define OMAP_I2C_SYSTEST_SDA_O\t\t(1 << 0)\t \n\n \n#define SYSS_RESETDONE_MASK\t\t(1 << 0)\n\n \n#define SYSC_CLOCKACTIVITY_MASK\t\t(0x3 << 8)\n#define SYSC_SIDLEMODE_MASK\t\t(0x3 << 3)\n#define SYSC_ENAWAKEUP_MASK\t\t(1 << 2)\n#define SYSC_SOFTRESET_MASK\t\t(1 << 1)\n#define SYSC_AUTOIDLE_MASK\t\t(1 << 0)\n\n#define SYSC_IDLEMODE_SMART\t\t0x2\n#define SYSC_CLOCKACTIVITY_FCLK\t\t0x2\n\n \n#define I2C_OMAP_ERRATA_I207\t\t(1 << 0)\n#define I2C_OMAP_ERRATA_I462\t\t(1 << 1)\n\n#define OMAP_I2C_IP_V2_INTERRUPTS_MASK\t0x6FFF\n\nstruct omap_i2c_dev {\n\tstruct device\t\t*dev;\n\tvoid __iomem\t\t*base;\t\t \n\tint\t\t\tirq;\n\tint\t\t\treg_shift;       \n\tstruct completion\tcmd_complete;\n\tstruct resource\t\t*ioarea;\n\tu32\t\t\tlatency;\t \n\tvoid\t\t\t(*set_mpu_wkup_lat)(struct device *dev,\n\t\t\t\t\t\t    long latency);\n\tu32\t\t\tspeed;\t\t \n\tu32\t\t\tflags;\n\tu16\t\t\tscheme;\n\tu16\t\t\tcmd_err;\n\tu8\t\t\t*buf;\n\tu8\t\t\t*regs;\n\tsize_t\t\t\tbuf_len;\n\tstruct i2c_adapter\tadapter;\n\tu8\t\t\tthreshold;\n\tu8\t\t\tfifo_size;\t \n\tu32\t\t\trev;\n\tunsigned\t\tb_hw:1;\t\t \n\tunsigned\t\tbb_valid:1;\t \n\tunsigned\t\treceiver:1;\t \n\tu16\t\t\tiestate;\t \n\tu16\t\t\tpscstate;\n\tu16\t\t\tscllstate;\n\tu16\t\t\tsclhstate;\n\tu16\t\t\tsyscstate;\n\tu16\t\t\twestate;\n\tu16\t\t\terrata;\n};\n\nstatic const u8 reg_map_ip_v1[] = {\n\t[OMAP_I2C_REV_REG] = 0x00,\n\t[OMAP_I2C_IE_REG] = 0x01,\n\t[OMAP_I2C_STAT_REG] = 0x02,\n\t[OMAP_I2C_IV_REG] = 0x03,\n\t[OMAP_I2C_WE_REG] = 0x03,\n\t[OMAP_I2C_SYSS_REG] = 0x04,\n\t[OMAP_I2C_BUF_REG] = 0x05,\n\t[OMAP_I2C_CNT_REG] = 0x06,\n\t[OMAP_I2C_DATA_REG] = 0x07,\n\t[OMAP_I2C_SYSC_REG] = 0x08,\n\t[OMAP_I2C_CON_REG] = 0x09,\n\t[OMAP_I2C_OA_REG] = 0x0a,\n\t[OMAP_I2C_SA_REG] = 0x0b,\n\t[OMAP_I2C_PSC_REG] = 0x0c,\n\t[OMAP_I2C_SCLL_REG] = 0x0d,\n\t[OMAP_I2C_SCLH_REG] = 0x0e,\n\t[OMAP_I2C_SYSTEST_REG] = 0x0f,\n\t[OMAP_I2C_BUFSTAT_REG] = 0x10,\n};\n\nstatic const u8 reg_map_ip_v2[] = {\n\t[OMAP_I2C_REV_REG] = 0x04,\n\t[OMAP_I2C_IE_REG] = 0x2c,\n\t[OMAP_I2C_STAT_REG] = 0x28,\n\t[OMAP_I2C_IV_REG] = 0x34,\n\t[OMAP_I2C_WE_REG] = 0x34,\n\t[OMAP_I2C_SYSS_REG] = 0x90,\n\t[OMAP_I2C_BUF_REG] = 0x94,\n\t[OMAP_I2C_CNT_REG] = 0x98,\n\t[OMAP_I2C_DATA_REG] = 0x9c,\n\t[OMAP_I2C_SYSC_REG] = 0x10,\n\t[OMAP_I2C_CON_REG] = 0xa4,\n\t[OMAP_I2C_OA_REG] = 0xa8,\n\t[OMAP_I2C_SA_REG] = 0xac,\n\t[OMAP_I2C_PSC_REG] = 0xb0,\n\t[OMAP_I2C_SCLL_REG] = 0xb4,\n\t[OMAP_I2C_SCLH_REG] = 0xb8,\n\t[OMAP_I2C_SYSTEST_REG] = 0xbC,\n\t[OMAP_I2C_BUFSTAT_REG] = 0xc0,\n\t[OMAP_I2C_IP_V2_REVNB_LO] = 0x00,\n\t[OMAP_I2C_IP_V2_REVNB_HI] = 0x04,\n\t[OMAP_I2C_IP_V2_IRQSTATUS_RAW] = 0x24,\n\t[OMAP_I2C_IP_V2_IRQENABLE_SET] = 0x2c,\n\t[OMAP_I2C_IP_V2_IRQENABLE_CLR] = 0x30,\n};\n\nstatic int omap_i2c_xfer_data(struct omap_i2c_dev *omap);\n\nstatic inline void omap_i2c_write_reg(struct omap_i2c_dev *omap,\n\t\t\t\t      int reg, u16 val)\n{\n\twritew_relaxed(val, omap->base +\n\t\t\t(omap->regs[reg] << omap->reg_shift));\n}\n\nstatic inline u16 omap_i2c_read_reg(struct omap_i2c_dev *omap, int reg)\n{\n\treturn readw_relaxed(omap->base +\n\t\t\t\t(omap->regs[reg] << omap->reg_shift));\n}\n\nstatic void __omap_i2c_init(struct omap_i2c_dev *omap)\n{\n\n\tomap_i2c_write_reg(omap, OMAP_I2C_CON_REG, 0);\n\n\t \n\tomap_i2c_write_reg(omap, OMAP_I2C_PSC_REG, omap->pscstate);\n\n\t \n\tomap_i2c_write_reg(omap, OMAP_I2C_SCLL_REG, omap->scllstate);\n\tomap_i2c_write_reg(omap, OMAP_I2C_SCLH_REG, omap->sclhstate);\n\tif (omap->rev >= OMAP_I2C_REV_ON_3430_3530)\n\t\tomap_i2c_write_reg(omap, OMAP_I2C_WE_REG, omap->westate);\n\n\t \n\tomap_i2c_write_reg(omap, OMAP_I2C_CON_REG, OMAP_I2C_CON_EN);\n\n\t \n\n\t \n\tif (omap->iestate)\n\t\tomap_i2c_write_reg(omap, OMAP_I2C_IE_REG, omap->iestate);\n}\n\nstatic int omap_i2c_reset(struct omap_i2c_dev *omap)\n{\n\tunsigned long timeout;\n\tu16 sysc;\n\n\tif (omap->rev >= OMAP_I2C_OMAP1_REV_2) {\n\t\tsysc = omap_i2c_read_reg(omap, OMAP_I2C_SYSC_REG);\n\n\t\t \n\t\tomap_i2c_write_reg(omap, OMAP_I2C_CON_REG,\n\t\t\tomap_i2c_read_reg(omap, OMAP_I2C_CON_REG) &\n\t\t\t\t~(OMAP_I2C_CON_EN));\n\n\t\tomap_i2c_write_reg(omap, OMAP_I2C_SYSC_REG, SYSC_SOFTRESET_MASK);\n\t\t \n\t\ttimeout = jiffies + OMAP_I2C_TIMEOUT;\n\t\tomap_i2c_write_reg(omap, OMAP_I2C_CON_REG, OMAP_I2C_CON_EN);\n\t\twhile (!(omap_i2c_read_reg(omap, OMAP_I2C_SYSS_REG) &\n\t\t\t SYSS_RESETDONE_MASK)) {\n\t\t\tif (time_after(jiffies, timeout)) {\n\t\t\t\tdev_warn(omap->dev, \"timeout waiting \"\n\t\t\t\t\t\t\"for controller reset\\n\");\n\t\t\t\treturn -ETIMEDOUT;\n\t\t\t}\n\t\t\tmsleep(1);\n\t\t}\n\n\t\t \n\t\tomap_i2c_write_reg(omap, OMAP_I2C_SYSC_REG, sysc);\n\n\t\tif (omap->rev > OMAP_I2C_REV_ON_3430_3530) {\n\t\t\t \n\t\t\tomap->bb_valid = 0;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int omap_i2c_init(struct omap_i2c_dev *omap)\n{\n\tu16 psc = 0, scll = 0, sclh = 0;\n\tu16 fsscll = 0, fssclh = 0, hsscll = 0, hssclh = 0;\n\tunsigned long fclk_rate = 12000000;\n\tunsigned long internal_clk = 0;\n\tstruct clk *fclk;\n\tint error;\n\n\tif (omap->rev >= OMAP_I2C_REV_ON_3430_3530) {\n\t\t \n\t\tomap->westate = OMAP_I2C_WE_ALL;\n\t}\n\n\tif (omap->flags & OMAP_I2C_FLAG_ALWAYS_ARMXOR_CLK) {\n\t\t \n\t\tfclk = clk_get(omap->dev, \"fck\");\n\t\tif (IS_ERR(fclk)) {\n\t\t\terror = PTR_ERR(fclk);\n\t\t\tdev_err(omap->dev, \"could not get fck: %i\\n\", error);\n\n\t\t\treturn error;\n\t\t}\n\n\t\tfclk_rate = clk_get_rate(fclk);\n\t\tclk_put(fclk);\n\n\t\t \n\t\tif (fclk_rate > 12000000)\n\t\t\tpsc = fclk_rate / 12000000;\n\t}\n\n\tif (!(omap->flags & OMAP_I2C_FLAG_SIMPLE_CLOCK)) {\n\n\t\t \n\t\tif (omap->speed > 400 ||\n\t\t\t       omap->flags & OMAP_I2C_FLAG_FORCE_19200_INT_CLK)\n\t\t\tinternal_clk = 19200;\n\t\telse if (omap->speed > 100)\n\t\t\tinternal_clk = 9600;\n\t\telse\n\t\t\tinternal_clk = 4000;\n\t\tfclk = clk_get(omap->dev, \"fck\");\n\t\tif (IS_ERR(fclk)) {\n\t\t\terror = PTR_ERR(fclk);\n\t\t\tdev_err(omap->dev, \"could not get fck: %i\\n\", error);\n\n\t\t\treturn error;\n\t\t}\n\t\tfclk_rate = clk_get_rate(fclk) / 1000;\n\t\tclk_put(fclk);\n\n\t\t \n\t\tpsc = fclk_rate / internal_clk;\n\t\tpsc = psc - 1;\n\n\t\t \n\t\tif (omap->speed > 400) {\n\t\t\tunsigned long scl;\n\n\t\t\t \n\t\t\tscl = internal_clk / 400;\n\t\t\tfsscll = scl - (scl / 3) - 7;\n\t\t\tfssclh = (scl / 3) - 5;\n\n\t\t\t \n\t\t\tscl = fclk_rate / omap->speed;\n\t\t\thsscll = scl - (scl / 3) - 7;\n\t\t\thssclh = (scl / 3) - 5;\n\t\t} else if (omap->speed > 100) {\n\t\t\tunsigned long scl;\n\n\t\t\t \n\t\t\tscl = internal_clk / omap->speed;\n\t\t\tfsscll = scl - (scl / 3) - 7;\n\t\t\tfssclh = (scl / 3) - 5;\n\t\t} else {\n\t\t\t \n\t\t\tfsscll = internal_clk / (omap->speed * 2) - 7;\n\t\t\tfssclh = internal_clk / (omap->speed * 2) - 5;\n\t\t}\n\t\tscll = (hsscll << OMAP_I2C_SCLL_HSSCLL) | fsscll;\n\t\tsclh = (hssclh << OMAP_I2C_SCLH_HSSCLH) | fssclh;\n\t} else {\n\t\t \n\t\tfclk_rate /= (psc + 1) * 1000;\n\t\tif (psc > 2)\n\t\t\tpsc = 2;\n\t\tscll = fclk_rate / (omap->speed * 2) - 7 + psc;\n\t\tsclh = fclk_rate / (omap->speed * 2) - 7 + psc;\n\t}\n\n\tomap->iestate = (OMAP_I2C_IE_XRDY | OMAP_I2C_IE_RRDY |\n\t\t\tOMAP_I2C_IE_ARDY | OMAP_I2C_IE_NACK |\n\t\t\tOMAP_I2C_IE_AL)  | ((omap->fifo_size) ?\n\t\t\t\t(OMAP_I2C_IE_RDR | OMAP_I2C_IE_XDR) : 0);\n\n\tomap->pscstate = psc;\n\tomap->scllstate = scll;\n\tomap->sclhstate = sclh;\n\n\tif (omap->rev <= OMAP_I2C_REV_ON_3430_3530) {\n\t\t \n\t\tomap->bb_valid = 1;\n\t}\n\n\t__omap_i2c_init(omap);\n\n\treturn 0;\n}\n\n \nstatic int omap_i2c_recover_bus(struct omap_i2c_dev *omap)\n{\n\tu16 systest;\n\n\tsystest = omap_i2c_read_reg(omap, OMAP_I2C_SYSTEST_REG);\n\tif ((systest & OMAP_I2C_SYSTEST_SCL_I_FUNC) &&\n\t    (systest & OMAP_I2C_SYSTEST_SDA_I_FUNC))\n\t\treturn 0;  \n\tif (!(systest & OMAP_I2C_SYSTEST_SCL_I_FUNC))\n\t\treturn -EBUSY;  \n\treturn i2c_recover_bus(&omap->adapter);\n}\n\n \nstatic int omap_i2c_wait_for_bb(struct omap_i2c_dev *omap)\n{\n\tunsigned long timeout;\n\n\ttimeout = jiffies + OMAP_I2C_TIMEOUT;\n\twhile (omap_i2c_read_reg(omap, OMAP_I2C_STAT_REG) & OMAP_I2C_STAT_BB) {\n\t\tif (time_after(jiffies, timeout))\n\t\t\treturn omap_i2c_recover_bus(omap);\n\t\tmsleep(1);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int omap_i2c_wait_for_bb_valid(struct omap_i2c_dev *omap)\n{\n\tunsigned long bus_free_timeout = 0;\n\tunsigned long timeout;\n\tint bus_free = 0;\n\tu16 stat, systest;\n\n\tif (omap->bb_valid)\n\t\treturn 0;\n\n\ttimeout = jiffies + OMAP_I2C_TIMEOUT;\n\twhile (1) {\n\t\tstat = omap_i2c_read_reg(omap, OMAP_I2C_STAT_REG);\n\t\t \n\t\tif (stat & (OMAP_I2C_STAT_BB | OMAP_I2C_STAT_BF))\n\t\t\tbreak;\n\n\t\t \n\t\tsystest = omap_i2c_read_reg(omap, OMAP_I2C_SYSTEST_REG);\n\t\tif ((systest & OMAP_I2C_SYSTEST_SCL_I_FUNC) &&\n\t\t    (systest & OMAP_I2C_SYSTEST_SDA_I_FUNC)) {\n\t\t\tif (!bus_free) {\n\t\t\t\tbus_free_timeout = jiffies +\n\t\t\t\t\tOMAP_I2C_BUS_FREE_TIMEOUT;\n\t\t\t\tbus_free = 1;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (time_after(jiffies, bus_free_timeout))\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tbus_free = 0;\n\t\t}\n\n\t\tif (time_after(jiffies, timeout)) {\n\t\t\t \n\t\t\tdev_warn(omap->dev, \"timeout waiting for bus ready\\n\");\n\t\t\treturn omap_i2c_recover_bus(omap);\n\t\t}\n\n\t\tmsleep(1);\n\t}\n\n\tomap->bb_valid = 1;\n\treturn 0;\n}\n\nstatic void omap_i2c_resize_fifo(struct omap_i2c_dev *omap, u8 size, bool is_rx)\n{\n\tu16\t\tbuf;\n\n\tif (omap->flags & OMAP_I2C_FLAG_NO_FIFO)\n\t\treturn;\n\n\t \n\n\tomap->threshold = clamp(size, (u8) 1, omap->fifo_size);\n\n\tbuf = omap_i2c_read_reg(omap, OMAP_I2C_BUF_REG);\n\n\tif (is_rx) {\n\t\t \n\t\tbuf &= ~(0x3f << 8);\n\t\tbuf |= ((omap->threshold - 1) << 8) | OMAP_I2C_BUF_RXFIF_CLR;\n\t} else {\n\t\t \n\t\tbuf &= ~0x3f;\n\t\tbuf |= (omap->threshold - 1) | OMAP_I2C_BUF_TXFIF_CLR;\n\t}\n\n\tomap_i2c_write_reg(omap, OMAP_I2C_BUF_REG, buf);\n\n\tif (omap->rev < OMAP_I2C_REV_ON_3630)\n\t\tomap->b_hw = 1;  \n\n\t \n\tif (omap->set_mpu_wkup_lat != NULL)\n\t\tomap->latency = (1000000 * omap->threshold) /\n\t\t\t(1000 * omap->speed / 8);\n}\n\nstatic void omap_i2c_wait(struct omap_i2c_dev *omap)\n{\n\tu16 stat;\n\tu16 mask = omap_i2c_read_reg(omap, OMAP_I2C_IE_REG);\n\tint count = 0;\n\n\tdo {\n\t\tstat = omap_i2c_read_reg(omap, OMAP_I2C_STAT_REG);\n\t\tcount++;\n\t} while (!(stat & mask) && count < 5);\n}\n\n \nstatic int omap_i2c_xfer_msg(struct i2c_adapter *adap,\n\t\t\t     struct i2c_msg *msg, int stop, bool polling)\n{\n\tstruct omap_i2c_dev *omap = i2c_get_adapdata(adap);\n\tunsigned long timeout;\n\tu16 w;\n\tint ret;\n\n\tdev_dbg(omap->dev, \"addr: 0x%04x, len: %d, flags: 0x%x, stop: %d\\n\",\n\t\tmsg->addr, msg->len, msg->flags, stop);\n\n\tomap->receiver = !!(msg->flags & I2C_M_RD);\n\tomap_i2c_resize_fifo(omap, msg->len, omap->receiver);\n\n\tomap_i2c_write_reg(omap, OMAP_I2C_SA_REG, msg->addr);\n\n\t \n\tomap->buf = msg->buf;\n\tomap->buf_len = msg->len;\n\n\t \n\tbarrier();\n\n\tomap_i2c_write_reg(omap, OMAP_I2C_CNT_REG, omap->buf_len);\n\n\t \n\tw = omap_i2c_read_reg(omap, OMAP_I2C_BUF_REG);\n\tw |= OMAP_I2C_BUF_RXFIF_CLR | OMAP_I2C_BUF_TXFIF_CLR;\n\tomap_i2c_write_reg(omap, OMAP_I2C_BUF_REG, w);\n\n\tif (!polling)\n\t\treinit_completion(&omap->cmd_complete);\n\tomap->cmd_err = 0;\n\n\tw = OMAP_I2C_CON_EN | OMAP_I2C_CON_MST | OMAP_I2C_CON_STT;\n\n\t \n\tif (omap->speed > 400)\n\t\tw |= OMAP_I2C_CON_OPMODE_HS;\n\n\tif (msg->flags & I2C_M_STOP)\n\t\tstop = 1;\n\tif (msg->flags & I2C_M_TEN)\n\t\tw |= OMAP_I2C_CON_XA;\n\tif (!(msg->flags & I2C_M_RD))\n\t\tw |= OMAP_I2C_CON_TRX;\n\n\tif (!omap->b_hw && stop)\n\t\tw |= OMAP_I2C_CON_STP;\n\t \n\tomap_i2c_write_reg(omap, OMAP_I2C_CON_REG, w);\n\n\t \n\tif (omap->b_hw && stop) {\n\t\tunsigned long delay = jiffies + OMAP_I2C_TIMEOUT;\n\t\tu16 con = omap_i2c_read_reg(omap, OMAP_I2C_CON_REG);\n\t\twhile (con & OMAP_I2C_CON_STT) {\n\t\t\tcon = omap_i2c_read_reg(omap, OMAP_I2C_CON_REG);\n\n\t\t\t \n\t\t\tif (time_after(jiffies, delay)) {\n\t\t\t\tdev_err(omap->dev, \"controller timed out \"\n\t\t\t\t\"waiting for start condition to finish\\n\");\n\t\t\t\treturn -ETIMEDOUT;\n\t\t\t}\n\t\t\tcpu_relax();\n\t\t}\n\n\t\tw |= OMAP_I2C_CON_STP;\n\t\tw &= ~OMAP_I2C_CON_STT;\n\t\tomap_i2c_write_reg(omap, OMAP_I2C_CON_REG, w);\n\t}\n\n\t \n\tif (!polling) {\n\t\ttimeout = wait_for_completion_timeout(&omap->cmd_complete,\n\t\t\t\t\t\t      OMAP_I2C_TIMEOUT);\n\t} else {\n\t\tdo {\n\t\t\tomap_i2c_wait(omap);\n\t\t\tret = omap_i2c_xfer_data(omap);\n\t\t} while (ret == -EAGAIN);\n\n\t\ttimeout = !ret;\n\t}\n\n\tif (timeout == 0) {\n\t\tdev_err(omap->dev, \"controller timed out\\n\");\n\t\tomap_i2c_reset(omap);\n\t\t__omap_i2c_init(omap);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tif (likely(!omap->cmd_err))\n\t\treturn 0;\n\n\t \n\tif (omap->cmd_err & (OMAP_I2C_STAT_ROVR | OMAP_I2C_STAT_XUDF)) {\n\t\tomap_i2c_reset(omap);\n\t\t__omap_i2c_init(omap);\n\t\treturn -EIO;\n\t}\n\n\tif (omap->cmd_err & OMAP_I2C_STAT_AL)\n\t\treturn -EAGAIN;\n\n\tif (omap->cmd_err & OMAP_I2C_STAT_NACK) {\n\t\tif (msg->flags & I2C_M_IGNORE_NAK)\n\t\t\treturn 0;\n\n\t\tw = omap_i2c_read_reg(omap, OMAP_I2C_CON_REG);\n\t\tw |= OMAP_I2C_CON_STP;\n\t\tomap_i2c_write_reg(omap, OMAP_I2C_CON_REG, w);\n\t\treturn -EREMOTEIO;\n\t}\n\treturn -EIO;\n}\n\n\n \nstatic int\nomap_i2c_xfer_common(struct i2c_adapter *adap, struct i2c_msg msgs[], int num,\n\t\t     bool polling)\n{\n\tstruct omap_i2c_dev *omap = i2c_get_adapdata(adap);\n\tint i;\n\tint r;\n\n\tr = pm_runtime_get_sync(omap->dev);\n\tif (r < 0)\n\t\tgoto out;\n\n\tr = omap_i2c_wait_for_bb_valid(omap);\n\tif (r < 0)\n\t\tgoto out;\n\n\tr = omap_i2c_wait_for_bb(omap);\n\tif (r < 0)\n\t\tgoto out;\n\n\tif (omap->set_mpu_wkup_lat != NULL)\n\t\tomap->set_mpu_wkup_lat(omap->dev, omap->latency);\n\n\tfor (i = 0; i < num; i++) {\n\t\tr = omap_i2c_xfer_msg(adap, &msgs[i], (i == (num - 1)),\n\t\t\t\t      polling);\n\t\tif (r != 0)\n\t\t\tbreak;\n\t}\n\n\tif (r == 0)\n\t\tr = num;\n\n\tomap_i2c_wait_for_bb(omap);\n\n\tif (omap->set_mpu_wkup_lat != NULL)\n\t\tomap->set_mpu_wkup_lat(omap->dev, -1);\n\nout:\n\tpm_runtime_mark_last_busy(omap->dev);\n\tpm_runtime_put_autosuspend(omap->dev);\n\treturn r;\n}\n\nstatic int\nomap_i2c_xfer_irq(struct i2c_adapter *adap, struct i2c_msg msgs[], int num)\n{\n\treturn omap_i2c_xfer_common(adap, msgs, num, false);\n}\n\nstatic int\nomap_i2c_xfer_polling(struct i2c_adapter *adap, struct i2c_msg msgs[], int num)\n{\n\treturn omap_i2c_xfer_common(adap, msgs, num, true);\n}\n\nstatic u32\nomap_i2c_func(struct i2c_adapter *adap)\n{\n\treturn I2C_FUNC_I2C | (I2C_FUNC_SMBUS_EMUL & ~I2C_FUNC_SMBUS_QUICK) |\n\t       I2C_FUNC_PROTOCOL_MANGLING;\n}\n\nstatic inline void\nomap_i2c_complete_cmd(struct omap_i2c_dev *omap, u16 err)\n{\n\tomap->cmd_err |= err;\n\tcomplete(&omap->cmd_complete);\n}\n\nstatic inline void\nomap_i2c_ack_stat(struct omap_i2c_dev *omap, u16 stat)\n{\n\tomap_i2c_write_reg(omap, OMAP_I2C_STAT_REG, stat);\n}\n\nstatic inline void i2c_omap_errata_i207(struct omap_i2c_dev *omap, u16 stat)\n{\n\t \n\tif (stat & OMAP_I2C_STAT_RDR) {\n\t\t \n\t\tomap_i2c_ack_stat(omap, OMAP_I2C_STAT_RDR);\n\n\t\t \n\t\tif (!(omap_i2c_read_reg(omap, OMAP_I2C_STAT_REG)\n\t\t\t\t\t\t& OMAP_I2C_STAT_BB)) {\n\n\t\t\t \n\t\t\tif (omap_i2c_read_reg(omap, OMAP_I2C_STAT_REG)\n\t\t\t\t\t\t& OMAP_I2C_STAT_RDR) {\n\t\t\t\tomap_i2c_ack_stat(omap, OMAP_I2C_STAT_RDR);\n\t\t\t\tdev_dbg(omap->dev, \"RDR when bus is busy.\\n\");\n\t\t\t}\n\n\t\t}\n\t}\n}\n\n \n#ifdef CONFIG_ARCH_OMAP15XX\n\nstatic irqreturn_t\nomap_i2c_omap1_isr(int this_irq, void *dev_id)\n{\n\tstruct omap_i2c_dev *omap = dev_id;\n\tu16 iv, w;\n\n\tif (pm_runtime_suspended(omap->dev))\n\t\treturn IRQ_NONE;\n\n\tiv = omap_i2c_read_reg(omap, OMAP_I2C_IV_REG);\n\tswitch (iv) {\n\tcase 0x00:\t \n\t\tbreak;\n\tcase 0x01:\t \n\t\tdev_err(omap->dev, \"Arbitration lost\\n\");\n\t\tomap_i2c_complete_cmd(omap, OMAP_I2C_STAT_AL);\n\t\tbreak;\n\tcase 0x02:\t \n\t\tomap_i2c_complete_cmd(omap, OMAP_I2C_STAT_NACK);\n\t\tomap_i2c_write_reg(omap, OMAP_I2C_CON_REG, OMAP_I2C_CON_STP);\n\t\tbreak;\n\tcase 0x03:\t \n\t\tomap_i2c_complete_cmd(omap, 0);\n\t\tbreak;\n\tcase 0x04:\t \n\t\tif (omap->buf_len) {\n\t\t\tw = omap_i2c_read_reg(omap, OMAP_I2C_DATA_REG);\n\t\t\t*omap->buf++ = w;\n\t\t\tomap->buf_len--;\n\t\t\tif (omap->buf_len) {\n\t\t\t\t*omap->buf++ = w >> 8;\n\t\t\t\tomap->buf_len--;\n\t\t\t}\n\t\t} else\n\t\t\tdev_err(omap->dev, \"RRDY IRQ while no data requested\\n\");\n\t\tbreak;\n\tcase 0x05:\t \n\t\tif (omap->buf_len) {\n\t\t\tw = *omap->buf++;\n\t\t\tomap->buf_len--;\n\t\t\tif (omap->buf_len) {\n\t\t\t\tw |= *omap->buf++ << 8;\n\t\t\t\tomap->buf_len--;\n\t\t\t}\n\t\t\tomap_i2c_write_reg(omap, OMAP_I2C_DATA_REG, w);\n\t\t} else\n\t\t\tdev_err(omap->dev, \"XRDY IRQ while no data to send\\n\");\n\t\tbreak;\n\tdefault:\n\t\treturn IRQ_NONE;\n\t}\n\n\treturn IRQ_HANDLED;\n}\n#else\n#define omap_i2c_omap1_isr\t\tNULL\n#endif\n\n \nstatic int errata_omap3_i462(struct omap_i2c_dev *omap)\n{\n\tunsigned long timeout = 10000;\n\tu16 stat;\n\n\tdo {\n\t\tstat = omap_i2c_read_reg(omap, OMAP_I2C_STAT_REG);\n\t\tif (stat & OMAP_I2C_STAT_XUDF)\n\t\t\tbreak;\n\n\t\tif (stat & (OMAP_I2C_STAT_NACK | OMAP_I2C_STAT_AL)) {\n\t\t\tomap_i2c_ack_stat(omap, (OMAP_I2C_STAT_XRDY |\n\t\t\t\t\t\t\tOMAP_I2C_STAT_XDR));\n\t\t\tif (stat & OMAP_I2C_STAT_NACK) {\n\t\t\t\tomap->cmd_err |= OMAP_I2C_STAT_NACK;\n\t\t\t\tomap_i2c_ack_stat(omap, OMAP_I2C_STAT_NACK);\n\t\t\t}\n\n\t\t\tif (stat & OMAP_I2C_STAT_AL) {\n\t\t\t\tdev_err(omap->dev, \"Arbitration lost\\n\");\n\t\t\t\tomap->cmd_err |= OMAP_I2C_STAT_AL;\n\t\t\t\tomap_i2c_ack_stat(omap, OMAP_I2C_STAT_AL);\n\t\t\t}\n\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tcpu_relax();\n\t} while (--timeout);\n\n\tif (!timeout) {\n\t\tdev_err(omap->dev, \"timeout waiting on XUDF bit\\n\");\n\t\treturn 0;\n\t}\n\n\treturn 0;\n}\n\nstatic void omap_i2c_receive_data(struct omap_i2c_dev *omap, u8 num_bytes,\n\t\tbool is_rdr)\n{\n\tu16\t\tw;\n\n\twhile (num_bytes--) {\n\t\tw = omap_i2c_read_reg(omap, OMAP_I2C_DATA_REG);\n\t\t*omap->buf++ = w;\n\t\tomap->buf_len--;\n\n\t\t \n\t\tif (omap->flags & OMAP_I2C_FLAG_16BIT_DATA_REG) {\n\t\t\t*omap->buf++ = w >> 8;\n\t\t\tomap->buf_len--;\n\t\t}\n\t}\n}\n\nstatic int omap_i2c_transmit_data(struct omap_i2c_dev *omap, u8 num_bytes,\n\t\tbool is_xdr)\n{\n\tu16\t\tw;\n\n\twhile (num_bytes--) {\n\t\tw = *omap->buf++;\n\t\tomap->buf_len--;\n\n\t\t \n\t\tif (omap->flags & OMAP_I2C_FLAG_16BIT_DATA_REG) {\n\t\t\tw |= *omap->buf++ << 8;\n\t\t\tomap->buf_len--;\n\t\t}\n\n\t\tif (omap->errata & I2C_OMAP_ERRATA_I462) {\n\t\t\tint ret;\n\n\t\t\tret = errata_omap3_i462(omap);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\tomap_i2c_write_reg(omap, OMAP_I2C_DATA_REG, w);\n\t}\n\n\treturn 0;\n}\n\nstatic irqreturn_t\nomap_i2c_isr(int irq, void *dev_id)\n{\n\tstruct omap_i2c_dev *omap = dev_id;\n\tirqreturn_t ret = IRQ_HANDLED;\n\tu16 mask;\n\tu16 stat;\n\n\tstat = omap_i2c_read_reg(omap, OMAP_I2C_STAT_REG);\n\tmask = omap_i2c_read_reg(omap, OMAP_I2C_IE_REG) & ~OMAP_I2C_STAT_NACK;\n\n\tif (stat & mask)\n\t\tret = IRQ_WAKE_THREAD;\n\n\treturn ret;\n}\n\nstatic int omap_i2c_xfer_data(struct omap_i2c_dev *omap)\n{\n\tu16 bits;\n\tu16 stat;\n\tint err = 0, count = 0;\n\n\tdo {\n\t\tbits = omap_i2c_read_reg(omap, OMAP_I2C_IE_REG);\n\t\tstat = omap_i2c_read_reg(omap, OMAP_I2C_STAT_REG);\n\t\tstat &= bits;\n\n\t\t \n\t\tif (omap->receiver)\n\t\t\tstat &= ~(OMAP_I2C_STAT_XDR | OMAP_I2C_STAT_XRDY);\n\t\telse\n\t\t\tstat &= ~(OMAP_I2C_STAT_RDR | OMAP_I2C_STAT_RRDY);\n\n\t\tif (!stat) {\n\t\t\t \n\t\t\terr = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\n\t\tdev_dbg(omap->dev, \"IRQ (ISR = 0x%04x)\\n\", stat);\n\t\tif (count++ == 100) {\n\t\t\tdev_warn(omap->dev, \"Too much work in one IRQ\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif (stat & OMAP_I2C_STAT_NACK) {\n\t\t\terr |= OMAP_I2C_STAT_NACK;\n\t\t\tomap_i2c_ack_stat(omap, OMAP_I2C_STAT_NACK);\n\t\t}\n\n\t\tif (stat & OMAP_I2C_STAT_AL) {\n\t\t\tdev_err(omap->dev, \"Arbitration lost\\n\");\n\t\t\terr |= OMAP_I2C_STAT_AL;\n\t\t\tomap_i2c_ack_stat(omap, OMAP_I2C_STAT_AL);\n\t\t}\n\n\t\t \n\t\tif (stat & OMAP_I2C_STAT_ARDY)\n\t\t\tomap_i2c_ack_stat(omap, OMAP_I2C_STAT_ARDY);\n\n\t\tif (stat & (OMAP_I2C_STAT_ARDY | OMAP_I2C_STAT_NACK |\n\t\t\t\t\tOMAP_I2C_STAT_AL)) {\n\t\t\tomap_i2c_ack_stat(omap, (OMAP_I2C_STAT_RRDY |\n\t\t\t\t\t\tOMAP_I2C_STAT_RDR |\n\t\t\t\t\t\tOMAP_I2C_STAT_XRDY |\n\t\t\t\t\t\tOMAP_I2C_STAT_XDR |\n\t\t\t\t\t\tOMAP_I2C_STAT_ARDY));\n\t\t\tbreak;\n\t\t}\n\n\t\tif (stat & OMAP_I2C_STAT_RDR) {\n\t\t\tu8 num_bytes = 1;\n\n\t\t\tif (omap->fifo_size)\n\t\t\t\tnum_bytes = omap->buf_len;\n\n\t\t\tif (omap->errata & I2C_OMAP_ERRATA_I207) {\n\t\t\t\ti2c_omap_errata_i207(omap, stat);\n\t\t\t\tnum_bytes = (omap_i2c_read_reg(omap,\n\t\t\t\t\tOMAP_I2C_BUFSTAT_REG) >> 8) & 0x3F;\n\t\t\t}\n\n\t\t\tomap_i2c_receive_data(omap, num_bytes, true);\n\t\t\tomap_i2c_ack_stat(omap, OMAP_I2C_STAT_RDR);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (stat & OMAP_I2C_STAT_RRDY) {\n\t\t\tu8 num_bytes = 1;\n\n\t\t\tif (omap->threshold)\n\t\t\t\tnum_bytes = omap->threshold;\n\n\t\t\tomap_i2c_receive_data(omap, num_bytes, false);\n\t\t\tomap_i2c_ack_stat(omap, OMAP_I2C_STAT_RRDY);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (stat & OMAP_I2C_STAT_XDR) {\n\t\t\tu8 num_bytes = 1;\n\t\t\tint ret;\n\n\t\t\tif (omap->fifo_size)\n\t\t\t\tnum_bytes = omap->buf_len;\n\n\t\t\tret = omap_i2c_transmit_data(omap, num_bytes, true);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\n\t\t\tomap_i2c_ack_stat(omap, OMAP_I2C_STAT_XDR);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (stat & OMAP_I2C_STAT_XRDY) {\n\t\t\tu8 num_bytes = 1;\n\t\t\tint ret;\n\n\t\t\tif (omap->threshold)\n\t\t\t\tnum_bytes = omap->threshold;\n\n\t\t\tret = omap_i2c_transmit_data(omap, num_bytes, false);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\n\t\t\tomap_i2c_ack_stat(omap, OMAP_I2C_STAT_XRDY);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (stat & OMAP_I2C_STAT_ROVR) {\n\t\t\tdev_err(omap->dev, \"Receive overrun\\n\");\n\t\t\terr |= OMAP_I2C_STAT_ROVR;\n\t\t\tomap_i2c_ack_stat(omap, OMAP_I2C_STAT_ROVR);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (stat & OMAP_I2C_STAT_XUDF) {\n\t\t\tdev_err(omap->dev, \"Transmit underflow\\n\");\n\t\t\terr |= OMAP_I2C_STAT_XUDF;\n\t\t\tomap_i2c_ack_stat(omap, OMAP_I2C_STAT_XUDF);\n\t\t\tbreak;\n\t\t}\n\t} while (stat);\n\n\treturn err;\n}\n\nstatic irqreturn_t\nomap_i2c_isr_thread(int this_irq, void *dev_id)\n{\n\tint ret;\n\tstruct omap_i2c_dev *omap = dev_id;\n\n\tret = omap_i2c_xfer_data(omap);\n\tif (ret != -EAGAIN)\n\t\tomap_i2c_complete_cmd(omap, ret);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic const struct i2c_algorithm omap_i2c_algo = {\n\t.master_xfer\t= omap_i2c_xfer_irq,\n\t.master_xfer_atomic\t= omap_i2c_xfer_polling,\n\t.functionality\t= omap_i2c_func,\n};\n\nstatic const struct i2c_adapter_quirks omap_i2c_quirks = {\n\t.flags = I2C_AQ_NO_ZERO_LEN,\n};\n\n#ifdef CONFIG_OF\nstatic struct omap_i2c_bus_platform_data omap2420_pdata = {\n\t.rev = OMAP_I2C_IP_VERSION_1,\n\t.flags = OMAP_I2C_FLAG_NO_FIFO |\n\t\t\tOMAP_I2C_FLAG_SIMPLE_CLOCK |\n\t\t\tOMAP_I2C_FLAG_16BIT_DATA_REG |\n\t\t\tOMAP_I2C_FLAG_BUS_SHIFT_2,\n};\n\nstatic struct omap_i2c_bus_platform_data omap2430_pdata = {\n\t.rev = OMAP_I2C_IP_VERSION_1,\n\t.flags = OMAP_I2C_FLAG_BUS_SHIFT_2 |\n\t\t\tOMAP_I2C_FLAG_FORCE_19200_INT_CLK,\n};\n\nstatic struct omap_i2c_bus_platform_data omap3_pdata = {\n\t.rev = OMAP_I2C_IP_VERSION_1,\n\t.flags = OMAP_I2C_FLAG_BUS_SHIFT_2,\n};\n\nstatic struct omap_i2c_bus_platform_data omap4_pdata = {\n\t.rev = OMAP_I2C_IP_VERSION_2,\n};\n\nstatic const struct of_device_id omap_i2c_of_match[] = {\n\t{\n\t\t.compatible = \"ti,omap4-i2c\",\n\t\t.data = &omap4_pdata,\n\t},\n\t{\n\t\t.compatible = \"ti,omap3-i2c\",\n\t\t.data = &omap3_pdata,\n\t},\n\t{\n\t\t.compatible = \"ti,omap2430-i2c\",\n\t\t.data = &omap2430_pdata,\n\t},\n\t{\n\t\t.compatible = \"ti,omap2420-i2c\",\n\t\t.data = &omap2420_pdata,\n\t},\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, omap_i2c_of_match);\n#endif\n\n#define OMAP_I2C_SCHEME(rev)\t\t((rev & 0xc000) >> 14)\n\n#define OMAP_I2C_REV_SCHEME_0_MAJOR(rev) (rev >> 4)\n#define OMAP_I2C_REV_SCHEME_0_MINOR(rev) (rev & 0xf)\n\n#define OMAP_I2C_REV_SCHEME_1_MAJOR(rev) ((rev & 0x0700) >> 7)\n#define OMAP_I2C_REV_SCHEME_1_MINOR(rev) (rev & 0x1f)\n#define OMAP_I2C_SCHEME_0\t\t0\n#define OMAP_I2C_SCHEME_1\t\t1\n\nstatic int omap_i2c_get_scl(struct i2c_adapter *adap)\n{\n\tstruct omap_i2c_dev *dev = i2c_get_adapdata(adap);\n\tu32 reg;\n\n\treg = omap_i2c_read_reg(dev, OMAP_I2C_SYSTEST_REG);\n\n\treturn reg & OMAP_I2C_SYSTEST_SCL_I_FUNC;\n}\n\nstatic int omap_i2c_get_sda(struct i2c_adapter *adap)\n{\n\tstruct omap_i2c_dev *dev = i2c_get_adapdata(adap);\n\tu32 reg;\n\n\treg = omap_i2c_read_reg(dev, OMAP_I2C_SYSTEST_REG);\n\n\treturn reg & OMAP_I2C_SYSTEST_SDA_I_FUNC;\n}\n\nstatic void omap_i2c_set_scl(struct i2c_adapter *adap, int val)\n{\n\tstruct omap_i2c_dev *dev = i2c_get_adapdata(adap);\n\tu32 reg;\n\n\treg = omap_i2c_read_reg(dev, OMAP_I2C_SYSTEST_REG);\n\tif (val)\n\t\treg |= OMAP_I2C_SYSTEST_SCL_O;\n\telse\n\t\treg &= ~OMAP_I2C_SYSTEST_SCL_O;\n\tomap_i2c_write_reg(dev, OMAP_I2C_SYSTEST_REG, reg);\n}\n\nstatic void omap_i2c_prepare_recovery(struct i2c_adapter *adap)\n{\n\tstruct omap_i2c_dev *dev = i2c_get_adapdata(adap);\n\tu32 reg;\n\n\treg = omap_i2c_read_reg(dev, OMAP_I2C_SYSTEST_REG);\n\t \n\treg |= OMAP_I2C_SYSTEST_ST_EN;\n\t \n\treg |= 3 << OMAP_I2C_SYSTEST_TMODE_SHIFT;\n\t \n\treg |= OMAP_I2C_SYSTEST_SCL_O;\n\t \n\treg |= OMAP_I2C_SYSTEST_SDA_O;\n\tomap_i2c_write_reg(dev, OMAP_I2C_SYSTEST_REG, reg);\n}\n\nstatic void omap_i2c_unprepare_recovery(struct i2c_adapter *adap)\n{\n\tstruct omap_i2c_dev *dev = i2c_get_adapdata(adap);\n\tu32 reg;\n\n\treg = omap_i2c_read_reg(dev, OMAP_I2C_SYSTEST_REG);\n\t \n\treg &= ~OMAP_I2C_SYSTEST_ST_EN;\n\treg &= ~OMAP_I2C_SYSTEST_TMODE_MASK;\n\treg &= ~OMAP_I2C_SYSTEST_SCL_O;\n\treg &= ~OMAP_I2C_SYSTEST_SDA_O;\n\tomap_i2c_write_reg(dev, OMAP_I2C_SYSTEST_REG, reg);\n}\n\nstatic struct i2c_bus_recovery_info omap_i2c_bus_recovery_info = {\n\t.get_scl\t\t= omap_i2c_get_scl,\n\t.get_sda\t\t= omap_i2c_get_sda,\n\t.set_scl\t\t= omap_i2c_set_scl,\n\t.prepare_recovery\t= omap_i2c_prepare_recovery,\n\t.unprepare_recovery\t= omap_i2c_unprepare_recovery,\n\t.recover_bus\t\t= i2c_generic_scl_recovery,\n};\n\nstatic int\nomap_i2c_probe(struct platform_device *pdev)\n{\n\tstruct omap_i2c_dev\t*omap;\n\tstruct i2c_adapter\t*adap;\n\tconst struct omap_i2c_bus_platform_data *pdata =\n\t\tdev_get_platdata(&pdev->dev);\n\tstruct device_node\t*node = pdev->dev.of_node;\n\tconst struct of_device_id *match;\n\tint irq;\n\tint r;\n\tu32 rev;\n\tu16 minor, major;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tomap = devm_kzalloc(&pdev->dev, sizeof(struct omap_i2c_dev), GFP_KERNEL);\n\tif (!omap)\n\t\treturn -ENOMEM;\n\n\tomap->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(omap->base))\n\t\treturn PTR_ERR(omap->base);\n\n\tmatch = of_match_device(of_match_ptr(omap_i2c_of_match), &pdev->dev);\n\tif (match) {\n\t\tu32 freq = I2C_MAX_STANDARD_MODE_FREQ;\n\n\t\tpdata = match->data;\n\t\tomap->flags = pdata->flags;\n\n\t\tof_property_read_u32(node, \"clock-frequency\", &freq);\n\t\t \n\t\tomap->speed = freq / 1000;\n\t} else if (pdata != NULL) {\n\t\tomap->speed = pdata->clkrate;\n\t\tomap->flags = pdata->flags;\n\t\tomap->set_mpu_wkup_lat = pdata->set_mpu_wkup_lat;\n\t}\n\n\tomap->dev = &pdev->dev;\n\tomap->irq = irq;\n\n\tplatform_set_drvdata(pdev, omap);\n\tinit_completion(&omap->cmd_complete);\n\n\tomap->reg_shift = (omap->flags >> OMAP_I2C_FLAG_BUS_SHIFT__SHIFT) & 3;\n\n\tpm_runtime_enable(omap->dev);\n\tpm_runtime_set_autosuspend_delay(omap->dev, OMAP_I2C_PM_TIMEOUT);\n\tpm_runtime_use_autosuspend(omap->dev);\n\n\tr = pm_runtime_resume_and_get(omap->dev);\n\tif (r < 0)\n\t\tgoto err_disable_pm;\n\n\t \n\trev = readw_relaxed(omap->base + 0x04);\n\n\tomap->scheme = OMAP_I2C_SCHEME(rev);\n\tswitch (omap->scheme) {\n\tcase OMAP_I2C_SCHEME_0:\n\t\tomap->regs = (u8 *)reg_map_ip_v1;\n\t\tomap->rev = omap_i2c_read_reg(omap, OMAP_I2C_REV_REG);\n\t\tminor = OMAP_I2C_REV_SCHEME_0_MAJOR(omap->rev);\n\t\tmajor = OMAP_I2C_REV_SCHEME_0_MAJOR(omap->rev);\n\t\tbreak;\n\tcase OMAP_I2C_SCHEME_1:\n\tdefault:\n\t\tomap->regs = (u8 *)reg_map_ip_v2;\n\t\trev = (rev << 16) |\n\t\t\tomap_i2c_read_reg(omap, OMAP_I2C_IP_V2_REVNB_LO);\n\t\tminor = OMAP_I2C_REV_SCHEME_1_MINOR(rev);\n\t\tmajor = OMAP_I2C_REV_SCHEME_1_MAJOR(rev);\n\t\tomap->rev = rev;\n\t}\n\n\tomap->errata = 0;\n\n\tif (omap->rev >= OMAP_I2C_REV_ON_2430 &&\n\t\t\tomap->rev < OMAP_I2C_REV_ON_4430_PLUS)\n\t\tomap->errata |= I2C_OMAP_ERRATA_I207;\n\n\tif (omap->rev <= OMAP_I2C_REV_ON_3430_3530)\n\t\tomap->errata |= I2C_OMAP_ERRATA_I462;\n\n\tif (!(omap->flags & OMAP_I2C_FLAG_NO_FIFO)) {\n\t\tu16 s;\n\n\t\t \n\t\ts = (omap_i2c_read_reg(omap, OMAP_I2C_BUFSTAT_REG) >> 14) & 0x3;\n\t\tomap->fifo_size = 0x8 << s;\n\n\t\t \n\n\t\tomap->fifo_size = (omap->fifo_size / 2);\n\n\t\tif (omap->rev < OMAP_I2C_REV_ON_3630)\n\t\t\tomap->b_hw = 1;  \n\n\t\t \n\t\tif (omap->set_mpu_wkup_lat != NULL)\n\t\t\tomap->latency = (1000000 * omap->fifo_size) /\n\t\t\t\t       (1000 * omap->speed / 8);\n\t}\n\n\t \n\tomap_i2c_init(omap);\n\n\tif (omap->rev < OMAP_I2C_OMAP1_REV_2)\n\t\tr = devm_request_irq(&pdev->dev, omap->irq, omap_i2c_omap1_isr,\n\t\t\t\tIRQF_NO_SUSPEND, pdev->name, omap);\n\telse\n\t\tr = devm_request_threaded_irq(&pdev->dev, omap->irq,\n\t\t\t\tomap_i2c_isr, omap_i2c_isr_thread,\n\t\t\t\tIRQF_NO_SUSPEND | IRQF_ONESHOT,\n\t\t\t\tpdev->name, omap);\n\n\tif (r) {\n\t\tdev_err(omap->dev, \"failure requesting irq %i\\n\", omap->irq);\n\t\tgoto err_unuse_clocks;\n\t}\n\n\tadap = &omap->adapter;\n\ti2c_set_adapdata(adap, omap);\n\tadap->owner = THIS_MODULE;\n\tadap->class = I2C_CLASS_DEPRECATED;\n\tstrscpy(adap->name, \"OMAP I2C adapter\", sizeof(adap->name));\n\tadap->algo = &omap_i2c_algo;\n\tadap->quirks = &omap_i2c_quirks;\n\tadap->dev.parent = &pdev->dev;\n\tadap->dev.of_node = pdev->dev.of_node;\n\tadap->bus_recovery_info = &omap_i2c_bus_recovery_info;\n\n\t \n\tadap->nr = pdev->id;\n\tr = i2c_add_numbered_adapter(adap);\n\tif (r)\n\t\tgoto err_unuse_clocks;\n\n\tdev_info(omap->dev, \"bus %d rev%d.%d at %d kHz\\n\", adap->nr,\n\t\t major, minor, omap->speed);\n\n\tpm_runtime_mark_last_busy(omap->dev);\n\tpm_runtime_put_autosuspend(omap->dev);\n\n\treturn 0;\n\nerr_unuse_clocks:\n\tomap_i2c_write_reg(omap, OMAP_I2C_CON_REG, 0);\n\tpm_runtime_dont_use_autosuspend(omap->dev);\n\tpm_runtime_put_sync(omap->dev);\nerr_disable_pm:\n\tpm_runtime_disable(&pdev->dev);\n\n\treturn r;\n}\n\nstatic void omap_i2c_remove(struct platform_device *pdev)\n{\n\tstruct omap_i2c_dev\t*omap = platform_get_drvdata(pdev);\n\tint ret;\n\n\ti2c_del_adapter(&omap->adapter);\n\n\tret = pm_runtime_get_sync(&pdev->dev);\n\tif (ret < 0)\n\t\tdev_err(omap->dev, \"Failed to resume hardware, skip disable\\n\");\n\telse\n\t\tomap_i2c_write_reg(omap, OMAP_I2C_CON_REG, 0);\n\n\tpm_runtime_dont_use_autosuspend(&pdev->dev);\n\tpm_runtime_put_sync(&pdev->dev);\n\tpm_runtime_disable(&pdev->dev);\n}\n\nstatic int __maybe_unused omap_i2c_runtime_suspend(struct device *dev)\n{\n\tstruct omap_i2c_dev *omap = dev_get_drvdata(dev);\n\n\tomap->iestate = omap_i2c_read_reg(omap, OMAP_I2C_IE_REG);\n\n\tif (omap->scheme == OMAP_I2C_SCHEME_0)\n\t\tomap_i2c_write_reg(omap, OMAP_I2C_IE_REG, 0);\n\telse\n\t\tomap_i2c_write_reg(omap, OMAP_I2C_IP_V2_IRQENABLE_CLR,\n\t\t\t\t   OMAP_I2C_IP_V2_INTERRUPTS_MASK);\n\n\tif (omap->rev < OMAP_I2C_OMAP1_REV_2) {\n\t\tomap_i2c_read_reg(omap, OMAP_I2C_IV_REG);  \n\t} else {\n\t\tomap_i2c_write_reg(omap, OMAP_I2C_STAT_REG, omap->iestate);\n\n\t\t \n\t\tomap_i2c_read_reg(omap, OMAP_I2C_STAT_REG);\n\t}\n\n\tpinctrl_pm_select_sleep_state(dev);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused omap_i2c_runtime_resume(struct device *dev)\n{\n\tstruct omap_i2c_dev *omap = dev_get_drvdata(dev);\n\n\tpinctrl_pm_select_default_state(dev);\n\n\tif (!omap->regs)\n\t\treturn 0;\n\n\t__omap_i2c_init(omap);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops omap_i2c_pm_ops = {\n\tSET_NOIRQ_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,\n\t\t\t\t      pm_runtime_force_resume)\n\tSET_RUNTIME_PM_OPS(omap_i2c_runtime_suspend,\n\t\t\t   omap_i2c_runtime_resume, NULL)\n};\n\nstatic struct platform_driver omap_i2c_driver = {\n\t.probe\t\t= omap_i2c_probe,\n\t.remove_new\t= omap_i2c_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"omap_i2c\",\n\t\t.pm\t= &omap_i2c_pm_ops,\n\t\t.of_match_table = of_match_ptr(omap_i2c_of_match),\n\t},\n};\n\n \nstatic int __init\nomap_i2c_init_driver(void)\n{\n\treturn platform_driver_register(&omap_i2c_driver);\n}\nsubsys_initcall(omap_i2c_init_driver);\n\nstatic void __exit omap_i2c_exit_driver(void)\n{\n\tplatform_driver_unregister(&omap_i2c_driver);\n}\nmodule_exit(omap_i2c_exit_driver);\n\nMODULE_AUTHOR(\"MontaVista Software, Inc. (and others)\");\nMODULE_DESCRIPTION(\"TI OMAP I2C bus adapter\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:omap_i2c\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}