{
  "module_name": "i2c-octeon-platdrv.c",
  "hash_id": "60a0f06d634af3a0deb7446078517d45bd2f2ea3cb05383f7b84b5a143ab9140",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-octeon-platdrv.c",
  "human_readable_source": " \n\n#include <linux/atomic.h>\n#include <linux/delay.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\n#include <asm/octeon/octeon.h>\n#include \"i2c-octeon-core.h\"\n\n#define DRV_NAME \"i2c-octeon\"\n\n \nstatic void octeon_i2c_int_enable(struct octeon_i2c *i2c)\n{\n\tocteon_i2c_write_int(i2c, TWSI_INT_CORE_EN);\n}\n\n \nstatic void octeon_i2c_int_disable(struct octeon_i2c *i2c)\n{\n\t \n\tocteon_i2c_write_int(i2c, 0);\n}\n\n \nstatic void octeon_i2c_int_enable78(struct octeon_i2c *i2c)\n{\n\tatomic_inc_return(&i2c->int_enable_cnt);\n\tenable_irq(i2c->irq);\n}\n\nstatic void __octeon_i2c_irq_disable(atomic_t *cnt, int irq)\n{\n\tint count;\n\n\t \n\tcount = atomic_dec_if_positive(cnt);\n\tif (count >= 0)\n\t\tdisable_irq_nosync(irq);\n}\n\n \nstatic void octeon_i2c_int_disable78(struct octeon_i2c *i2c)\n{\n\t__octeon_i2c_irq_disable(&i2c->int_enable_cnt, i2c->irq);\n}\n\n \nstatic void octeon_i2c_hlc_int_enable78(struct octeon_i2c *i2c)\n{\n\tatomic_inc_return(&i2c->hlc_int_enable_cnt);\n\tenable_irq(i2c->hlc_irq);\n}\n\n \nstatic void octeon_i2c_hlc_int_disable78(struct octeon_i2c *i2c)\n{\n\t__octeon_i2c_irq_disable(&i2c->hlc_int_enable_cnt, i2c->hlc_irq);\n}\n\n \nstatic irqreturn_t octeon_i2c_hlc_isr78(int irq, void *dev_id)\n{\n\tstruct octeon_i2c *i2c = dev_id;\n\n\ti2c->hlc_int_disable(i2c);\n\twake_up(&i2c->queue);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void octeon_i2c_hlc_int_enable(struct octeon_i2c *i2c)\n{\n\tocteon_i2c_write_int(i2c, TWSI_INT_ST_EN);\n}\n\nstatic u32 octeon_i2c_functionality(struct i2c_adapter *adap)\n{\n\treturn I2C_FUNC_I2C | (I2C_FUNC_SMBUS_EMUL & ~I2C_FUNC_SMBUS_QUICK) |\n\t       I2C_FUNC_SMBUS_READ_BLOCK_DATA | I2C_SMBUS_BLOCK_PROC_CALL;\n}\n\nstatic const struct i2c_algorithm octeon_i2c_algo = {\n\t.master_xfer = octeon_i2c_xfer,\n\t.functionality = octeon_i2c_functionality,\n};\n\nstatic const struct i2c_adapter octeon_i2c_ops = {\n\t.owner = THIS_MODULE,\n\t.name = \"OCTEON adapter\",\n\t.algo = &octeon_i2c_algo,\n};\n\nstatic int octeon_i2c_probe(struct platform_device *pdev)\n{\n\tstruct device_node *node = pdev->dev.of_node;\n\tint irq, result = 0, hlc_irq = 0;\n\tstruct octeon_i2c *i2c;\n\tbool cn78xx_style;\n\n\tcn78xx_style = of_device_is_compatible(node, \"cavium,octeon-7890-twsi\");\n\tif (cn78xx_style) {\n\t\thlc_irq = platform_get_irq(pdev, 0);\n\t\tif (hlc_irq < 0)\n\t\t\treturn hlc_irq;\n\n\t\tirq = platform_get_irq(pdev, 2);\n\t\tif (irq < 0)\n\t\t\treturn irq;\n\t} else {\n\t\t \n\t\tirq = platform_get_irq(pdev, 0);\n\t\tif (irq < 0)\n\t\t\treturn irq;\n\t}\n\n\ti2c = devm_kzalloc(&pdev->dev, sizeof(*i2c), GFP_KERNEL);\n\tif (!i2c) {\n\t\tresult = -ENOMEM;\n\t\tgoto out;\n\t}\n\ti2c->dev = &pdev->dev;\n\n\ti2c->roff.sw_twsi = 0x00;\n\ti2c->roff.twsi_int = 0x10;\n\ti2c->roff.sw_twsi_ext = 0x18;\n\n\ti2c->twsi_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(i2c->twsi_base)) {\n\t\tresult = PTR_ERR(i2c->twsi_base);\n\t\tgoto out;\n\t}\n\n\t \n\tif (of_property_read_u32(node, \"clock-frequency\", &i2c->twsi_freq) &&\n\t    of_property_read_u32(node, \"clock-rate\", &i2c->twsi_freq)) {\n\t\tdev_err(i2c->dev,\n\t\t\t\"no I2C 'clock-rate' or 'clock-frequency' property\\n\");\n\t\tresult = -ENXIO;\n\t\tgoto out;\n\t}\n\n\ti2c->sys_freq = octeon_get_io_clock_rate();\n\n\tinit_waitqueue_head(&i2c->queue);\n\n\ti2c->irq = irq;\n\n\tif (cn78xx_style) {\n\t\ti2c->hlc_irq = hlc_irq;\n\n\t\ti2c->int_enable = octeon_i2c_int_enable78;\n\t\ti2c->int_disable = octeon_i2c_int_disable78;\n\t\ti2c->hlc_int_enable = octeon_i2c_hlc_int_enable78;\n\t\ti2c->hlc_int_disable = octeon_i2c_hlc_int_disable78;\n\n\t\tirq_set_status_flags(i2c->irq, IRQ_NOAUTOEN);\n\t\tirq_set_status_flags(i2c->hlc_irq, IRQ_NOAUTOEN);\n\n\t\tresult = devm_request_irq(&pdev->dev, i2c->hlc_irq,\n\t\t\t\t\t  octeon_i2c_hlc_isr78, 0,\n\t\t\t\t\t  DRV_NAME, i2c);\n\t\tif (result < 0) {\n\t\t\tdev_err(i2c->dev, \"failed to attach interrupt\\n\");\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\ti2c->int_enable = octeon_i2c_int_enable;\n\t\ti2c->int_disable = octeon_i2c_int_disable;\n\t\ti2c->hlc_int_enable = octeon_i2c_hlc_int_enable;\n\t\ti2c->hlc_int_disable = octeon_i2c_int_disable;\n\t}\n\n\tresult = devm_request_irq(&pdev->dev, i2c->irq,\n\t\t\t\t  octeon_i2c_isr, 0, DRV_NAME, i2c);\n\tif (result < 0) {\n\t\tdev_err(i2c->dev, \"failed to attach interrupt\\n\");\n\t\tgoto out;\n\t}\n\n\tif (OCTEON_IS_MODEL(OCTEON_CN38XX))\n\t\ti2c->broken_irq_check = true;\n\n\tresult = octeon_i2c_init_lowlevel(i2c);\n\tif (result) {\n\t\tdev_err(i2c->dev, \"init low level failed\\n\");\n\t\tgoto  out;\n\t}\n\n\tocteon_i2c_set_clock(i2c);\n\n\ti2c->adap = octeon_i2c_ops;\n\ti2c->adap.timeout = msecs_to_jiffies(2);\n\ti2c->adap.retries = 5;\n\ti2c->adap.bus_recovery_info = &octeon_i2c_recovery_info;\n\ti2c->adap.dev.parent = &pdev->dev;\n\ti2c->adap.dev.of_node = node;\n\ti2c_set_adapdata(&i2c->adap, i2c);\n\tplatform_set_drvdata(pdev, i2c);\n\n\tresult = i2c_add_adapter(&i2c->adap);\n\tif (result < 0)\n\t\tgoto out;\n\tdev_info(i2c->dev, \"probed\\n\");\n\treturn 0;\n\nout:\n\treturn result;\n};\n\nstatic void octeon_i2c_remove(struct platform_device *pdev)\n{\n\tstruct octeon_i2c *i2c = platform_get_drvdata(pdev);\n\n\ti2c_del_adapter(&i2c->adap);\n};\n\nstatic const struct of_device_id octeon_i2c_match[] = {\n\t{ .compatible = \"cavium,octeon-3860-twsi\", },\n\t{ .compatible = \"cavium,octeon-7890-twsi\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, octeon_i2c_match);\n\nstatic struct platform_driver octeon_i2c_driver = {\n\t.probe\t\t= octeon_i2c_probe,\n\t.remove_new\t= octeon_i2c_remove,\n\t.driver\t\t= {\n\t\t.name\t= DRV_NAME,\n\t\t.of_match_table = octeon_i2c_match,\n\t},\n};\n\nmodule_platform_driver(octeon_i2c_driver);\n\nMODULE_AUTHOR(\"Michael Lawnick <michael.lawnick.ext@nsn.com>\");\nMODULE_DESCRIPTION(\"I2C-Bus adapter for Cavium OCTEON processors\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}