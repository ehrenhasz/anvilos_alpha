{
  "module_name": "i2c-au1550.c",
  "hash_id": "86927c103a6d27292a6f047bd4fc4abf814dfec3e1d1d9ea2adeb5f4634dce9f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-au1550.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/errno.h>\n#include <linux/i2c.h>\n#include <linux/slab.h>\n\n#include <asm/mach-au1x00/au1000.h>\n#include <asm/mach-au1x00/au1xxx_psc.h>\n\n#define PSC_SEL\t\t0x00\n#define PSC_CTRL\t0x04\n#define PSC_SMBCFG\t0x08\n#define PSC_SMBMSK\t0x0C\n#define PSC_SMBPCR\t0x10\n#define PSC_SMBSTAT\t0x14\n#define PSC_SMBEVNT\t0x18\n#define PSC_SMBTXRX\t0x1C\n#define PSC_SMBTMR\t0x20\n\nstruct i2c_au1550_data {\n\tvoid __iomem *psc_base;\n\tint\txfer_timeout;\n\tstruct i2c_adapter adap;\n};\n\nstatic inline void WR(struct i2c_au1550_data *a, int r, unsigned long v)\n{\n\t__raw_writel(v, a->psc_base + r);\n\twmb();\n}\n\nstatic inline unsigned long RD(struct i2c_au1550_data *a, int r)\n{\n\treturn __raw_readl(a->psc_base + r);\n}\n\nstatic int wait_xfer_done(struct i2c_au1550_data *adap)\n{\n\tint i;\n\n\t \n\tfor (i = 0; i < adap->xfer_timeout; i++) {\n\t\tif (RD(adap, PSC_SMBSTAT) & PSC_SMBSTAT_TE)\n\t\t\treturn 0;\n\n\t\tudelay(1);\n\t}\n\n\treturn -ETIMEDOUT;\n}\n\nstatic int wait_ack(struct i2c_au1550_data *adap)\n{\n\tunsigned long stat;\n\n\tif (wait_xfer_done(adap))\n\t\treturn -ETIMEDOUT;\n\n\tstat = RD(adap, PSC_SMBEVNT);\n\tif ((stat & (PSC_SMBEVNT_DN | PSC_SMBEVNT_AN | PSC_SMBEVNT_AL)) != 0)\n\t\treturn -ETIMEDOUT;\n\n\treturn 0;\n}\n\nstatic int wait_master_done(struct i2c_au1550_data *adap)\n{\n\tint i;\n\n\t \n\tfor (i = 0; i < 2 * adap->xfer_timeout; i++) {\n\t\tif ((RD(adap, PSC_SMBEVNT) & PSC_SMBEVNT_MD) != 0)\n\t\t\treturn 0;\n\t\tudelay(1);\n\t}\n\n\treturn -ETIMEDOUT;\n}\n\nstatic int\ndo_address(struct i2c_au1550_data *adap, unsigned int addr, int rd, int q)\n{\n\tunsigned long stat;\n\n\t \n\tstat = RD(adap, PSC_SMBSTAT);\n\tWR(adap, PSC_SMBEVNT, PSC_SMBEVNT_ALLCLR);\n\n\tif (!(stat & PSC_SMBSTAT_TE) || !(stat & PSC_SMBSTAT_RE)) {\n\t\tWR(adap, PSC_SMBPCR, PSC_SMBPCR_DC);\n\t\twhile ((RD(adap, PSC_SMBPCR) & PSC_SMBPCR_DC) != 0)\n\t\t\tcpu_relax();\n\t\tudelay(50);\n\t}\n\n\t \n\taddr <<= 1;\n\tif (rd)\n\t\taddr |= 1;\n\n\t \n\tif (q)\n\t\taddr |= PSC_SMBTXRX_STP;\n\n\t \n\tWR(adap, PSC_SMBTXRX, addr);\n\tWR(adap, PSC_SMBPCR, PSC_SMBPCR_MS);\n\tif (wait_ack(adap))\n\t\treturn -EIO;\n\treturn (q) ? wait_master_done(adap) : 0;\n}\n\nstatic int wait_for_rx_byte(struct i2c_au1550_data *adap, unsigned char *out)\n{\n\tint j;\n\n\tif (wait_xfer_done(adap))\n\t\treturn -EIO;\n\n\tj =  adap->xfer_timeout * 100;\n\tdo {\n\t\tj--;\n\t\tif (j <= 0)\n\t\t\treturn -EIO;\n\n\t\tif ((RD(adap, PSC_SMBSTAT) & PSC_SMBSTAT_RE) == 0)\n\t\t\tj = 0;\n\t\telse\n\t\t\tudelay(1);\n\t} while (j > 0);\n\n\t*out = RD(adap, PSC_SMBTXRX);\n\n\treturn 0;\n}\n\nstatic int i2c_read(struct i2c_au1550_data *adap, unsigned char *buf,\n\t\t    unsigned int len)\n{\n\tint i;\n\n\tif (len == 0)\n\t\treturn 0;\n\n\t \n\ti = 0;\n\twhile (i < (len - 1)) {\n\t\tWR(adap, PSC_SMBTXRX, 0);\n\t\tif (wait_for_rx_byte(adap, &buf[i]))\n\t\t\treturn -EIO;\n\n\t\ti++;\n\t}\n\n\t \n\tWR(adap, PSC_SMBTXRX, PSC_SMBTXRX_STP);\n\tif (wait_master_done(adap))\n\t\treturn -EIO;\n\n\tbuf[i] = (unsigned char)(RD(adap, PSC_SMBTXRX) & 0xff);\n\treturn 0;\n}\n\nstatic int i2c_write(struct i2c_au1550_data *adap, unsigned char *buf,\n\t\t     unsigned int len)\n{\n\tint i;\n\tunsigned long data;\n\n\tif (len == 0)\n\t\treturn 0;\n\n\ti = 0;\n\twhile (i < (len-1)) {\n\t\tdata = buf[i];\n\t\tWR(adap, PSC_SMBTXRX, data);\n\t\tif (wait_ack(adap))\n\t\t\treturn -EIO;\n\t\ti++;\n\t}\n\n\t \n\tdata = buf[i];\n\tdata |= PSC_SMBTXRX_STP;\n\tWR(adap, PSC_SMBTXRX, data);\n\tif (wait_master_done(adap))\n\t\treturn -EIO;\n\treturn 0;\n}\n\nstatic int\nau1550_xfer(struct i2c_adapter *i2c_adap, struct i2c_msg *msgs, int num)\n{\n\tstruct i2c_au1550_data *adap = i2c_adap->algo_data;\n\tstruct i2c_msg *p;\n\tint i, err = 0;\n\n\tWR(adap, PSC_CTRL, PSC_CTRL_ENABLE);\n\n\tfor (i = 0; !err && i < num; i++) {\n\t\tp = &msgs[i];\n\t\terr = do_address(adap, p->addr, p->flags & I2C_M_RD,\n\t\t\t\t (p->len == 0));\n\t\tif (err || !p->len)\n\t\t\tcontinue;\n\t\tif (p->flags & I2C_M_RD)\n\t\t\terr = i2c_read(adap, p->buf, p->len);\n\t\telse\n\t\t\terr = i2c_write(adap, p->buf, p->len);\n\t}\n\n\t \n\tif (err == 0)\n\t\terr = num;\n\n\tWR(adap, PSC_CTRL, PSC_CTRL_SUSPEND);\n\n\treturn err;\n}\n\nstatic u32 au1550_func(struct i2c_adapter *adap)\n{\n\treturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;\n}\n\nstatic const struct i2c_algorithm au1550_algo = {\n\t.master_xfer\t= au1550_xfer,\n\t.functionality\t= au1550_func,\n};\n\nstatic void i2c_au1550_setup(struct i2c_au1550_data *priv)\n{\n\tunsigned long cfg;\n\n\tWR(priv, PSC_CTRL, PSC_CTRL_DISABLE);\n\tWR(priv, PSC_SEL, PSC_SEL_PS_SMBUSMODE);\n\tWR(priv, PSC_SMBCFG, 0);\n\tWR(priv, PSC_CTRL, PSC_CTRL_ENABLE);\n\twhile ((RD(priv, PSC_SMBSTAT) & PSC_SMBSTAT_SR) == 0)\n\t\tcpu_relax();\n\n\tcfg = PSC_SMBCFG_RT_FIFO8 | PSC_SMBCFG_TT_FIFO8 | PSC_SMBCFG_DD_DISABLE;\n\tWR(priv, PSC_SMBCFG, cfg);\n\n\t \n\tcfg |= PSC_SMBCFG_SET_DIV(PSC_SMBCFG_DIV8);\n\tWR(priv, PSC_SMBCFG, cfg);\n\tWR(priv, PSC_SMBMSK, PSC_SMBMSK_ALLMASK);\n\n\t \n\tWR(priv, PSC_SMBTMR, PSC_SMBTMR_SET_TH(0) | PSC_SMBTMR_SET_PS(20) | \\\n\t\tPSC_SMBTMR_SET_PU(20) | PSC_SMBTMR_SET_SH(20) | \\\n\t\tPSC_SMBTMR_SET_SU(20) | PSC_SMBTMR_SET_CL(20) | \\\n\t\tPSC_SMBTMR_SET_CH(20));\n\n\tcfg |= PSC_SMBCFG_DE_ENABLE;\n\tWR(priv, PSC_SMBCFG, cfg);\n\twhile ((RD(priv, PSC_SMBSTAT) & PSC_SMBSTAT_SR) == 0)\n\t\tcpu_relax();\n\n\tWR(priv, PSC_CTRL, PSC_CTRL_SUSPEND);\n}\n\nstatic void i2c_au1550_disable(struct i2c_au1550_data *priv)\n{\n\tWR(priv, PSC_SMBCFG, 0);\n\tWR(priv, PSC_CTRL, PSC_CTRL_DISABLE);\n}\n\n \nstatic int\ni2c_au1550_probe(struct platform_device *pdev)\n{\n\tstruct i2c_au1550_data *priv;\n\tint ret;\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(struct i2c_au1550_data),\n\t\t\t    GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->psc_base = devm_platform_get_and_ioremap_resource(pdev, 0, NULL);\n\tif (IS_ERR(priv->psc_base))\n\t\treturn PTR_ERR(priv->psc_base);\n\n\tpriv->xfer_timeout = 200;\n\n\tpriv->adap.nr = pdev->id;\n\tpriv->adap.algo = &au1550_algo;\n\tpriv->adap.algo_data = priv;\n\tpriv->adap.dev.parent = &pdev->dev;\n\tstrscpy(priv->adap.name, \"Au1xxx PSC I2C\", sizeof(priv->adap.name));\n\n\t \n\ti2c_au1550_setup(priv);\n\n\tret = i2c_add_numbered_adapter(&priv->adap);\n\tif (ret) {\n\t\ti2c_au1550_disable(priv);\n\t\treturn ret;\n\t}\n\n\tplatform_set_drvdata(pdev, priv);\n\treturn 0;\n}\n\nstatic void i2c_au1550_remove(struct platform_device *pdev)\n{\n\tstruct i2c_au1550_data *priv = platform_get_drvdata(pdev);\n\n\ti2c_del_adapter(&priv->adap);\n\ti2c_au1550_disable(priv);\n}\n\nstatic int i2c_au1550_suspend(struct device *dev)\n{\n\tstruct i2c_au1550_data *priv = dev_get_drvdata(dev);\n\n\ti2c_au1550_disable(priv);\n\n\treturn 0;\n}\n\nstatic int i2c_au1550_resume(struct device *dev)\n{\n\tstruct i2c_au1550_data *priv = dev_get_drvdata(dev);\n\n\ti2c_au1550_setup(priv);\n\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(i2c_au1550_pmops,\n\t\t\t\ti2c_au1550_suspend, i2c_au1550_resume);\n\nstatic struct platform_driver au1xpsc_smbus_driver = {\n\t.driver = {\n\t\t.name\t= \"au1xpsc_smbus\",\n\t\t.pm\t= pm_sleep_ptr(&i2c_au1550_pmops),\n\t},\n\t.probe\t\t= i2c_au1550_probe,\n\t.remove_new\t= i2c_au1550_remove,\n};\n\nmodule_platform_driver(au1xpsc_smbus_driver);\n\nMODULE_AUTHOR(\"Dan Malek, Embedded Edge, LLC.\");\nMODULE_DESCRIPTION(\"SMBus adapter Alchemy pb1550\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:au1xpsc_smbus\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}