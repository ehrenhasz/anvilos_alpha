{
  "module_name": "i2c-brcmstb.c",
  "hash_id": "5e64ffaa2e582ac0b2c5952060acddd0a7cf6b35a88fe654e44e7664f70091d1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-brcmstb.c",
  "human_readable_source": "\n\n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\n#define N_DATA_REGS\t\t\t\t\t8\n\n \n#define BSC_CNT_REG1_MASK(nb)\t(nb == 1 ? GENMASK(3, 0) : GENMASK(5, 0))\n#define BSC_CNT_REG1_SHIFT\t0\n\n \n#define BSC_CTL_REG_DTF_MASK\t\t\t\t0x00000003\n#define BSC_CTL_REG_SCL_SEL_MASK\t\t\t0x00000030\n#define BSC_CTL_REG_SCL_SEL_SHIFT\t\t\t4\n#define BSC_CTL_REG_INT_EN_MASK\t\t\t\t0x00000040\n#define BSC_CTL_REG_INT_EN_SHIFT\t\t\t6\n#define BSC_CTL_REG_DIV_CLK_MASK\t\t\t0x00000080\n\n \n#define BSC_IIC_EN_RESTART_MASK\t\t\t\t0x00000040\n#define BSC_IIC_EN_NOSTART_MASK\t\t\t\t0x00000020\n#define BSC_IIC_EN_NOSTOP_MASK\t\t\t\t0x00000010\n#define BSC_IIC_EN_NOACK_MASK\t\t\t\t0x00000004\n#define BSC_IIC_EN_INTRP_MASK\t\t\t\t0x00000002\n#define BSC_IIC_EN_ENABLE_MASK\t\t\t\t0x00000001\n\n \n#define BSC_CTLHI_REG_INPUT_SWITCHING_LEVEL_MASK\t0x00000080\n#define BSC_CTLHI_REG_DATAREG_SIZE_MASK\t\t\t0x00000040\n#define BSC_CTLHI_REG_IGNORE_ACK_MASK\t\t\t0x00000002\n#define BSC_CTLHI_REG_WAIT_DIS_MASK\t\t\t0x00000001\n\n#define I2C_TIMEOUT\t\t\t\t\t100  \n\n \n#define COND_RESTART\t\tBSC_IIC_EN_RESTART_MASK\n#define COND_NOSTART\t\tBSC_IIC_EN_NOSTART_MASK\n#define COND_NOSTOP\t\tBSC_IIC_EN_NOSTOP_MASK\n#define COND_START_STOP\t\t(COND_RESTART | COND_NOSTART | COND_NOSTOP)\n\n \n#define DTF_WR_MASK\t\t0x00000000\n#define DTF_RD_MASK\t\t0x00000001\n \n#define DTF_RD_WR_MASK\t\t0x00000002\n#define DTF_WR_RD_MASK\t\t0x00000003\n\n#define INT_ENABLE\t\ttrue\n#define INT_DISABLE\t\tfalse\n\n \nstruct bsc_regs {\n\tu32\tchip_address;            \n\tu32\tdata_in[N_DATA_REGS];    \n\tu32\tcnt_reg;\t\t \n\tu32\tctl_reg;\t\t \n\tu32\tiic_enable;\t\t \n\tu32\tdata_out[N_DATA_REGS];   \n\tu32\tctlhi_reg;\t\t \n\tu32\tscl_param;\t\t \n};\n\nstruct bsc_clk_param {\n\tu32 hz;\n\tu32 scl_mask;\n\tu32 div_mask;\n};\n\nenum bsc_xfer_cmd {\n\tCMD_WR,\n\tCMD_RD,\n\tCMD_WR_NOACK,\n\tCMD_RD_NOACK,\n};\n\nstatic char const *cmd_string[] = {\n\t[CMD_WR] = \"WR\",\n\t[CMD_RD] = \"RD\",\n\t[CMD_WR_NOACK] = \"WR NOACK\",\n\t[CMD_RD_NOACK] = \"RD NOACK\",\n};\n\nenum bus_speeds {\n\tSPD_375K,\n\tSPD_390K,\n\tSPD_187K,\n\tSPD_200K,\n\tSPD_93K,\n\tSPD_97K,\n\tSPD_46K,\n\tSPD_50K\n};\n\nstatic const struct bsc_clk_param bsc_clk[] = {\n\t[SPD_375K] = {\n\t\t.hz = 375000,\n\t\t.scl_mask = SPD_375K << BSC_CTL_REG_SCL_SEL_SHIFT,\n\t\t.div_mask = 0\n\t},\n\t[SPD_390K] = {\n\t\t.hz = 390000,\n\t\t.scl_mask = SPD_390K << BSC_CTL_REG_SCL_SEL_SHIFT,\n\t\t.div_mask = 0\n\t},\n\t[SPD_187K] = {\n\t\t.hz = 187500,\n\t\t.scl_mask = SPD_187K << BSC_CTL_REG_SCL_SEL_SHIFT,\n\t\t.div_mask = 0\n\t},\n\t[SPD_200K] = {\n\t\t.hz = 200000,\n\t\t.scl_mask = SPD_200K << BSC_CTL_REG_SCL_SEL_SHIFT,\n\t\t.div_mask = 0\n\t},\n\t[SPD_93K]  = {\n\t\t.hz = 93750,\n\t\t.scl_mask = SPD_375K << BSC_CTL_REG_SCL_SEL_SHIFT,\n\t\t.div_mask = BSC_CTL_REG_DIV_CLK_MASK\n\t},\n\t[SPD_97K]  = {\n\t\t.hz = 97500,\n\t\t.scl_mask = SPD_390K << BSC_CTL_REG_SCL_SEL_SHIFT,\n\t\t.div_mask = BSC_CTL_REG_DIV_CLK_MASK\n\t},\n\t[SPD_46K]  = {\n\t\t.hz = 46875,\n\t\t.scl_mask = SPD_187K << BSC_CTL_REG_SCL_SEL_SHIFT,\n\t\t.div_mask = BSC_CTL_REG_DIV_CLK_MASK\n\t},\n\t[SPD_50K]  = {\n\t\t.hz = 50000,\n\t\t.scl_mask = SPD_200K << BSC_CTL_REG_SCL_SEL_SHIFT,\n\t\t.div_mask = BSC_CTL_REG_DIV_CLK_MASK\n\t}\n};\n\nstruct brcmstb_i2c_dev {\n\tstruct device *device;\n\tvoid __iomem *base;\n\tint irq;\n\tstruct bsc_regs *bsc_regmap;\n\tstruct i2c_adapter adapter;\n\tstruct completion done;\n\tu32 clk_freq_hz;\n\tint data_regsz;\n};\n\n \n#ifdef CONFIG_CPU_BIG_ENDIAN\n#define __bsc_readl(_reg) ioread32be(_reg)\n#define __bsc_writel(_val, _reg) iowrite32be(_val, _reg)\n#else\n#define __bsc_readl(_reg) ioread32(_reg)\n#define __bsc_writel(_val, _reg) iowrite32(_val, _reg)\n#endif\n\n#define bsc_readl(_dev, _reg)\t\t\t\t\t\t\\\n\t__bsc_readl(_dev->base + offsetof(struct bsc_regs, _reg))\n\n#define bsc_writel(_dev, _val, _reg)\t\t\t\t\t\\\n\t__bsc_writel(_val, _dev->base + offsetof(struct bsc_regs, _reg))\n\nstatic inline int brcmstb_i2c_get_xfersz(struct brcmstb_i2c_dev *dev)\n{\n\treturn (N_DATA_REGS * dev->data_regsz);\n}\n\nstatic inline int brcmstb_i2c_get_data_regsz(struct brcmstb_i2c_dev *dev)\n{\n\treturn dev->data_regsz;\n}\n\nstatic void brcmstb_i2c_enable_disable_irq(struct brcmstb_i2c_dev *dev,\n\t\t\t\t\t   bool int_en)\n{\n\n\tif (int_en)\n\t\t \n\t\tdev->bsc_regmap->ctl_reg |= BSC_CTL_REG_INT_EN_MASK;\n\telse\n\t\t \n\t\tdev->bsc_regmap->ctl_reg &= ~BSC_CTL_REG_INT_EN_MASK;\n\n\tbarrier();\n\tbsc_writel(dev, dev->bsc_regmap->ctl_reg, ctl_reg);\n}\n\nstatic irqreturn_t brcmstb_i2c_isr(int irq, void *devid)\n{\n\tstruct brcmstb_i2c_dev *dev = devid;\n\tu32 status_bsc_ctl = bsc_readl(dev, ctl_reg);\n\tu32 status_iic_intrp = bsc_readl(dev, iic_enable);\n\n\tdev_dbg(dev->device, \"isr CTL_REG %x IIC_EN %x\\n\",\n\t\tstatus_bsc_ctl, status_iic_intrp);\n\n\tif (!(status_bsc_ctl & BSC_CTL_REG_INT_EN_MASK))\n\t\treturn IRQ_NONE;\n\n\tbrcmstb_i2c_enable_disable_irq(dev, INT_DISABLE);\n\tcomplete(&dev->done);\n\n\tdev_dbg(dev->device, \"isr handled\");\n\treturn IRQ_HANDLED;\n}\n\n \nstatic int brcmstb_i2c_wait_if_busy(struct brcmstb_i2c_dev *dev)\n{\n\tunsigned long timeout = jiffies + msecs_to_jiffies(I2C_TIMEOUT);\n\n\twhile ((bsc_readl(dev, iic_enable) & BSC_IIC_EN_INTRP_MASK)) {\n\t\tif (time_after(jiffies, timeout))\n\t\t\treturn -ETIMEDOUT;\n\t\tcpu_relax();\n\t}\n\treturn 0;\n}\n\n \nstatic int brcmstb_i2c_wait_for_completion(struct brcmstb_i2c_dev *dev)\n{\n\tint ret = 0;\n\tunsigned long timeout = msecs_to_jiffies(I2C_TIMEOUT);\n\n\tif (dev->irq >= 0) {\n\t\tif (!wait_for_completion_timeout(&dev->done, timeout))\n\t\t\tret = -ETIMEDOUT;\n\t} else {\n\t\t \n\t\tu32 bsc_intrp;\n\t\tunsigned long time_left = jiffies + timeout;\n\n\t\tdo {\n\t\t\tbsc_intrp = bsc_readl(dev, iic_enable) &\n\t\t\t\tBSC_IIC_EN_INTRP_MASK;\n\t\t\tif (time_after(jiffies, time_left)) {\n\t\t\t\tret = -ETIMEDOUT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcpu_relax();\n\t\t} while (!bsc_intrp);\n\t}\n\n\tif (dev->irq < 0 || ret == -ETIMEDOUT)\n\t\tbrcmstb_i2c_enable_disable_irq(dev, INT_DISABLE);\n\n\treturn ret;\n}\n\n \nstatic void brcmstb_set_i2c_start_stop(struct brcmstb_i2c_dev *dev,\n\t\t\t\t       u32 cond_flag)\n{\n\tu32 regval = dev->bsc_regmap->iic_enable;\n\n\tdev->bsc_regmap->iic_enable = (regval & ~COND_START_STOP) | cond_flag;\n}\n\n \nstatic int brcmstb_send_i2c_cmd(struct brcmstb_i2c_dev *dev,\n\t\t\t\tenum bsc_xfer_cmd cmd)\n{\n\tint rc = 0;\n\tstruct bsc_regs *pi2creg = dev->bsc_regmap;\n\n\t \n\trc = brcmstb_i2c_wait_if_busy(dev);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t \n\tif (dev->irq >= 0)\n\t\treinit_completion(&dev->done);\n\n\t \n\tbrcmstb_i2c_enable_disable_irq(dev, INT_ENABLE);\n\n\t \n\tpi2creg->iic_enable |= BSC_IIC_EN_ENABLE_MASK;\n\tbsc_writel(dev, pi2creg->iic_enable, iic_enable);\n\n\t \n\trc = brcmstb_i2c_wait_for_completion(dev);\n\tif (rc) {\n\t\tdev_dbg(dev->device, \"intr timeout for cmd %s\\n\",\n\t\t\tcmd_string[cmd]);\n\t\tgoto cmd_out;\n\t}\n\n\tif ((cmd == CMD_RD || cmd == CMD_WR) &&\n\t    bsc_readl(dev, iic_enable) & BSC_IIC_EN_NOACK_MASK) {\n\t\trc = -EREMOTEIO;\n\t\tdev_dbg(dev->device, \"controller received NOACK intr for %s\\n\",\n\t\t\tcmd_string[cmd]);\n\t}\n\ncmd_out:\n\tbsc_writel(dev, 0, cnt_reg);\n\tbsc_writel(dev, 0, iic_enable);\n\n\treturn rc;\n}\n\n \nstatic int brcmstb_i2c_xfer_bsc_data(struct brcmstb_i2c_dev *dev,\n\t\t\t\t     u8 *buf, unsigned int len,\n\t\t\t\t     struct i2c_msg *pmsg)\n{\n\tint cnt, byte, i, rc;\n\tenum bsc_xfer_cmd cmd;\n\tu32 ctl_reg;\n\tstruct bsc_regs *pi2creg = dev->bsc_regmap;\n\tint no_ack = pmsg->flags & I2C_M_IGNORE_NAK;\n\tint data_regsz = brcmstb_i2c_get_data_regsz(dev);\n\n\t \n\tif (no_ack) {\n\t\tcmd = (pmsg->flags & I2C_M_RD) ? CMD_RD_NOACK\n\t\t\t: CMD_WR_NOACK;\n\t\tpi2creg->ctlhi_reg |= BSC_CTLHI_REG_IGNORE_ACK_MASK;\n\t} else {\n\t\tcmd = (pmsg->flags & I2C_M_RD) ? CMD_RD : CMD_WR;\n\t\tpi2creg->ctlhi_reg &= ~BSC_CTLHI_REG_IGNORE_ACK_MASK;\n\t}\n\tbsc_writel(dev, pi2creg->ctlhi_reg, ctlhi_reg);\n\n\t \n\tctl_reg = pi2creg->ctl_reg & ~BSC_CTL_REG_DTF_MASK;\n\tif (cmd == CMD_WR || cmd == CMD_WR_NOACK)\n\t\tpi2creg->ctl_reg = ctl_reg | DTF_WR_MASK;\n\telse\n\t\tpi2creg->ctl_reg = ctl_reg | DTF_RD_MASK;\n\n\t \n\tbsc_writel(dev, BSC_CNT_REG1_MASK(data_regsz) &\n\t\t   (len << BSC_CNT_REG1_SHIFT), cnt_reg);\n\n\t \n\n\tif (cmd == CMD_WR || cmd == CMD_WR_NOACK) {\n\t\tfor (cnt = 0, i = 0; cnt < len; cnt += data_regsz, i++) {\n\t\t\tu32 word = 0;\n\n\t\t\tfor (byte = 0; byte < data_regsz; byte++) {\n\t\t\t\tword >>= BITS_PER_BYTE;\n\t\t\t\tif ((cnt + byte) < len)\n\t\t\t\t\tword |= buf[cnt + byte] <<\n\t\t\t\t\t(BITS_PER_BYTE * (data_regsz - 1));\n\t\t\t}\n\t\t\tbsc_writel(dev, word, data_in[i]);\n\t\t}\n\t}\n\n\t \n\trc = brcmstb_send_i2c_cmd(dev, cmd);\n\n\tif (rc != 0) {\n\t\tdev_dbg(dev->device, \"%s failure\", cmd_string[cmd]);\n\t\treturn rc;\n\t}\n\n\t \n\tif (cmd == CMD_RD || cmd == CMD_RD_NOACK) {\n\t\tfor (cnt = 0, i = 0; cnt < len; cnt += data_regsz, i++) {\n\t\t\tu32 data = bsc_readl(dev, data_out[i]);\n\n\t\t\tfor (byte = 0; byte < data_regsz &&\n\t\t\t\t     (byte + cnt) < len; byte++) {\n\t\t\t\tbuf[cnt + byte] = data & 0xff;\n\t\t\t\tdata >>= BITS_PER_BYTE;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int brcmstb_i2c_write_data_byte(struct brcmstb_i2c_dev *dev,\n\t\t\t\t       u8 *buf, unsigned int nak_expected)\n{\n\tenum bsc_xfer_cmd cmd = nak_expected ? CMD_WR : CMD_WR_NOACK;\n\n\tbsc_writel(dev, 1, cnt_reg);\n\tbsc_writel(dev, *buf, data_in);\n\n\treturn brcmstb_send_i2c_cmd(dev, cmd);\n}\n\n \nstatic int brcmstb_i2c_do_addr(struct brcmstb_i2c_dev *dev,\n\t\t\t       struct i2c_msg *msg)\n{\n\tunsigned char addr;\n\n\tif (msg->flags & I2C_M_TEN) {\n\t\t \n\t\taddr = 0xF0 | ((msg->addr & 0x300) >> 7);\n\t\tbsc_writel(dev, addr, chip_address);\n\n\t\t \n\t\taddr = msg->addr & 0xFF;\n\t\tif (brcmstb_i2c_write_data_byte(dev, &addr, 0) < 0)\n\t\t\treturn -EREMOTEIO;\n\n\t\tif (msg->flags & I2C_M_RD) {\n\t\t\t \n\t\t\tbrcmstb_set_i2c_start_stop(dev, COND_RESTART\n\t\t\t\t\t\t   | COND_NOSTOP);\n\t\t\t \n\t\t\taddr = 0xF0 | ((msg->addr & 0x300) >> 7) | 0x01;\n\t\t\tif (brcmstb_i2c_write_data_byte(dev, &addr, 0) < 0)\n\t\t\t\treturn -EREMOTEIO;\n\n\t\t}\n\t} else {\n\t\taddr = i2c_8bit_addr_from_msg(msg);\n\n\t\tbsc_writel(dev, addr, chip_address);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int brcmstb_i2c_xfer(struct i2c_adapter *adapter,\n\t\t\t    struct i2c_msg msgs[], int num)\n{\n\tstruct brcmstb_i2c_dev *dev = i2c_get_adapdata(adapter);\n\tstruct i2c_msg *pmsg;\n\tint rc = 0;\n\tint i;\n\tint bytes_to_xfer;\n\tu8 *tmp_buf;\n\tint len = 0;\n\tint xfersz = brcmstb_i2c_get_xfersz(dev);\n\tu32 cond, cond_per_msg;\n\n\t \n\tfor (i = 0; i < num; i++) {\n\t\tpmsg = &msgs[i];\n\t\tlen = pmsg->len;\n\t\ttmp_buf = pmsg->buf;\n\n\t\tdev_dbg(dev->device,\n\t\t\t\"msg# %d/%d flg %x buf %x len %d\\n\", i,\n\t\t\tnum - 1, pmsg->flags,\n\t\t\tpmsg->buf ? pmsg->buf[0] : '0', pmsg->len);\n\n\t\tif (i < (num - 1) && (msgs[i + 1].flags & I2C_M_NOSTART))\n\t\t\tcond = ~COND_START_STOP;\n\t\telse\n\t\t\tcond = COND_RESTART | COND_NOSTOP;\n\n\t\tbrcmstb_set_i2c_start_stop(dev, cond);\n\n\t\t \n\t\tif (!(pmsg->flags & I2C_M_NOSTART)) {\n\t\t\trc = brcmstb_i2c_do_addr(dev, pmsg);\n\t\t\tif (rc < 0) {\n\t\t\t\tdev_dbg(dev->device,\n\t\t\t\t\t\"NACK for addr %2.2x msg#%d rc = %d\\n\",\n\t\t\t\t\tpmsg->addr, i, rc);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tcond_per_msg = cond;\n\n\t\t \n\t\twhile (len) {\n\t\t\tbytes_to_xfer = min(len, xfersz);\n\n\t\t\tif (len <= xfersz) {\n\t\t\t\tif (i == (num - 1))\n\t\t\t\t\tcond_per_msg = cond_per_msg &\n\t\t\t\t\t\t~(COND_RESTART | COND_NOSTOP);\n\t\t\t\telse\n\t\t\t\t\tcond_per_msg = cond;\n\t\t\t} else {\n\t\t\t\tcond_per_msg = (cond_per_msg & ~COND_RESTART) |\n\t\t\t\t\tCOND_NOSTOP;\n\t\t\t}\n\n\t\t\tbrcmstb_set_i2c_start_stop(dev, cond_per_msg);\n\n\t\t\trc = brcmstb_i2c_xfer_bsc_data(dev, tmp_buf,\n\t\t\t\t\t\t       bytes_to_xfer, pmsg);\n\t\t\tif (rc < 0)\n\t\t\t\tgoto out;\n\n\t\t\tlen -=  bytes_to_xfer;\n\t\t\ttmp_buf += bytes_to_xfer;\n\n\t\t\tcond_per_msg = COND_NOSTART | COND_NOSTOP;\n\t\t}\n\t}\n\n\trc = num;\nout:\n\treturn rc;\n\n}\n\nstatic u32 brcmstb_i2c_functionality(struct i2c_adapter *adap)\n{\n\treturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL | I2C_FUNC_10BIT_ADDR\n\t\t| I2C_FUNC_NOSTART | I2C_FUNC_PROTOCOL_MANGLING;\n}\n\nstatic const struct i2c_algorithm brcmstb_i2c_algo = {\n\t.master_xfer = brcmstb_i2c_xfer,\n\t.functionality = brcmstb_i2c_functionality,\n};\n\nstatic void brcmstb_i2c_set_bus_speed(struct brcmstb_i2c_dev *dev)\n{\n\tint i = 0, num_speeds = ARRAY_SIZE(bsc_clk);\n\tu32 clk_freq_hz = dev->clk_freq_hz;\n\n\tfor (i = 0; i < num_speeds; i++) {\n\t\tif (bsc_clk[i].hz == clk_freq_hz) {\n\t\t\tdev->bsc_regmap->ctl_reg &= ~(BSC_CTL_REG_SCL_SEL_MASK\n\t\t\t\t\t\t| BSC_CTL_REG_DIV_CLK_MASK);\n\t\t\tdev->bsc_regmap->ctl_reg |= (bsc_clk[i].scl_mask |\n\t\t\t\t\t\t     bsc_clk[i].div_mask);\n\t\t\tbsc_writel(dev, dev->bsc_regmap->ctl_reg, ctl_reg);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (i == num_speeds) {\n\t\ti = (bsc_readl(dev, ctl_reg) & BSC_CTL_REG_SCL_SEL_MASK) >>\n\t\t\tBSC_CTL_REG_SCL_SEL_SHIFT;\n\t\tdev_warn(dev->device, \"leaving current clock-frequency @ %dHz\\n\",\n\t\t\tbsc_clk[i].hz);\n\t}\n}\n\nstatic void brcmstb_i2c_set_bsc_reg_defaults(struct brcmstb_i2c_dev *dev)\n{\n\tif (brcmstb_i2c_get_data_regsz(dev) == sizeof(u32))\n\t\t \n\t\tdev->bsc_regmap->ctlhi_reg = BSC_CTLHI_REG_DATAREG_SIZE_MASK;\n\telse\n\t\tdev->bsc_regmap->ctlhi_reg &= ~BSC_CTLHI_REG_DATAREG_SIZE_MASK;\n\n\tbsc_writel(dev, dev->bsc_regmap->ctlhi_reg, ctlhi_reg);\n\t \n\tbrcmstb_i2c_set_bus_speed(dev);\n}\n\n#define AUTOI2C_CTRL0\t\t0x26c\n#define AUTOI2C_CTRL0_RELEASE_BSC\tBIT(1)\n\nstatic int bcm2711_release_bsc(struct brcmstb_i2c_dev *dev)\n{\n\tstruct platform_device *pdev = to_platform_device(dev->device);\n\tvoid __iomem *autoi2c;\n\n\t \n\tautoi2c = devm_platform_ioremap_resource_byname(pdev, \"auto-i2c\");\n\tif (IS_ERR(autoi2c))\n\t\treturn PTR_ERR(autoi2c);\n\n\twritel(AUTOI2C_CTRL0_RELEASE_BSC, autoi2c + AUTOI2C_CTRL0);\n\tdevm_iounmap(&pdev->dev, autoi2c);\n\n\t \n\tdev->bsc_regmap->iic_enable = 0;\n\tbsc_writel(dev, dev->bsc_regmap->iic_enable, iic_enable);\n\n\treturn 0;\n}\n\nstatic int brcmstb_i2c_probe(struct platform_device *pdev)\n{\n\tstruct brcmstb_i2c_dev *dev;\n\tstruct i2c_adapter *adap;\n\tconst char *int_name;\n\tint rc;\n\n\t \n\tdev = devm_kzalloc(&pdev->dev, sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tdev->bsc_regmap = devm_kzalloc(&pdev->dev, sizeof(*dev->bsc_regmap), GFP_KERNEL);\n\tif (!dev->bsc_regmap)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, dev);\n\tdev->device = &pdev->dev;\n\tinit_completion(&dev->done);\n\n\t \n\tdev->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(dev->base))\n\t\treturn PTR_ERR(dev->base);\n\n\tif (of_device_is_compatible(dev->device->of_node,\n\t\t\t\t    \"brcm,bcm2711-hdmi-i2c\")) {\n\t\trc = bcm2711_release_bsc(dev);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\trc = of_property_read_string(dev->device->of_node, \"interrupt-names\",\n\t\t\t\t     &int_name);\n\tif (rc < 0)\n\t\tint_name = NULL;\n\n\t \n\tdev->irq = platform_get_irq_optional(pdev, 0);\n\n\t \n\tbrcmstb_i2c_enable_disable_irq(dev, INT_DISABLE);\n\n\t \n\tif (dev->irq >= 0) {\n\t\trc = devm_request_irq(&pdev->dev, dev->irq, brcmstb_i2c_isr,\n\t\t\t\t      IRQF_SHARED,\n\t\t\t\t      int_name ? int_name : pdev->name,\n\t\t\t\t      dev);\n\n\t\tif (rc) {\n\t\t\tdev_dbg(dev->device, \"falling back to polling mode\");\n\t\t\tdev->irq = -1;\n\t\t}\n\t}\n\n\tif (of_property_read_u32(dev->device->of_node,\n\t\t\t\t \"clock-frequency\", &dev->clk_freq_hz)) {\n\t\tdev_warn(dev->device, \"setting clock-frequency@%dHz\\n\",\n\t\t\t bsc_clk[0].hz);\n\t\tdev->clk_freq_hz = bsc_clk[0].hz;\n\t}\n\n\t \n\tif (of_device_is_compatible(dev->device->of_node,\n\t\t\t\t    \"brcm,brcmper-i2c\"))\n\t\tdev->data_regsz = sizeof(u8);\n\telse\n\t\tdev->data_regsz = sizeof(u32);\n\n\tbrcmstb_i2c_set_bsc_reg_defaults(dev);\n\n\t \n\tadap = &dev->adapter;\n\ti2c_set_adapdata(adap, dev);\n\tadap->owner = THIS_MODULE;\n\tstrscpy(adap->name, dev_name(&pdev->dev), sizeof(adap->name));\n\tadap->algo = &brcmstb_i2c_algo;\n\tadap->dev.parent = &pdev->dev;\n\tadap->dev.of_node = pdev->dev.of_node;\n\trc = i2c_add_adapter(adap);\n\tif (rc)\n\t\treturn rc;\n\n\tdev_info(dev->device, \"%s@%dhz registered in %s mode\\n\",\n\t\t int_name ? int_name : \" \", dev->clk_freq_hz,\n\t\t (dev->irq >= 0) ? \"interrupt\" : \"polling\");\n\n\treturn 0;\n}\n\nstatic void brcmstb_i2c_remove(struct platform_device *pdev)\n{\n\tstruct brcmstb_i2c_dev *dev = platform_get_drvdata(pdev);\n\n\ti2c_del_adapter(&dev->adapter);\n}\n\nstatic int brcmstb_i2c_suspend(struct device *dev)\n{\n\tstruct brcmstb_i2c_dev *i2c_dev = dev_get_drvdata(dev);\n\n\ti2c_mark_adapter_suspended(&i2c_dev->adapter);\n\treturn 0;\n}\n\nstatic int brcmstb_i2c_resume(struct device *dev)\n{\n\tstruct brcmstb_i2c_dev *i2c_dev = dev_get_drvdata(dev);\n\n\tbrcmstb_i2c_set_bsc_reg_defaults(i2c_dev);\n\ti2c_mark_adapter_resumed(&i2c_dev->adapter);\n\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(brcmstb_i2c_pm, brcmstb_i2c_suspend,\n\t\t\t\tbrcmstb_i2c_resume);\n\nstatic const struct of_device_id brcmstb_i2c_of_match[] = {\n\t{.compatible = \"brcm,brcmstb-i2c\"},\n\t{.compatible = \"brcm,brcmper-i2c\"},\n\t{.compatible = \"brcm,bcm2711-hdmi-i2c\"},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, brcmstb_i2c_of_match);\n\nstatic struct platform_driver brcmstb_i2c_driver = {\n\t.driver = {\n\t\t   .name = \"brcmstb-i2c\",\n\t\t   .of_match_table = brcmstb_i2c_of_match,\n\t\t   .pm = pm_sleep_ptr(&brcmstb_i2c_pm),\n\t\t   },\n\t.probe = brcmstb_i2c_probe,\n\t.remove_new = brcmstb_i2c_remove,\n};\nmodule_platform_driver(brcmstb_i2c_driver);\n\nMODULE_AUTHOR(\"Kamal Dasu <kdasu@broadcom.com>\");\nMODULE_DESCRIPTION(\"Broadcom Settop I2C Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}