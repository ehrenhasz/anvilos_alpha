{
  "module_name": "i2c-pxa-pci.c",
  "hash_id": "0e95aa4f9d40f2f541d55a303774061e766c307157f6fd4959f1a3ef0e4f07bc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-pxa-pci.c",
  "human_readable_source": "\n \n#include <linux/init.h>\n#include <linux/pci.h>\n#include <linux/platform_device.h>\n#include <linux/platform_data/i2c-pxa.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n\n#define CE4100_PCI_I2C_DEVS\t3\n\nstruct ce4100_devices {\n\tstruct platform_device *pdev[CE4100_PCI_I2C_DEVS];\n};\n\nstatic struct platform_device *add_i2c_device(struct pci_dev *dev, int bar)\n{\n\tstruct platform_device *pdev;\n\tstruct i2c_pxa_platform_data pdata;\n\tstruct resource res[2];\n\tstruct device_node *child;\n\tstatic int devnum;\n\tint ret;\n\n\tmemset(&pdata, 0, sizeof(struct i2c_pxa_platform_data));\n\tmemset(&res, 0, sizeof(res));\n\n\tres[0].flags = IORESOURCE_MEM;\n\tres[0].start = pci_resource_start(dev, bar);\n\tres[0].end = pci_resource_end(dev, bar);\n\n\tres[1].flags = IORESOURCE_IRQ;\n\tres[1].start = dev->irq;\n\tres[1].end = dev->irq;\n\n\tfor_each_child_of_node(dev->dev.of_node, child) {\n\t\tconst void *prop;\n\t\tstruct resource r;\n\t\tint ret;\n\n\t\tret = of_address_to_resource(child, 0, &r);\n\t\tif (ret < 0)\n\t\t\tcontinue;\n\t\tif (r.start != res[0].start)\n\t\t\tcontinue;\n\t\tif (r.end != res[0].end)\n\t\t\tcontinue;\n\t\tif (r.flags != res[0].flags)\n\t\t\tcontinue;\n\n\t\tprop = of_get_property(child, \"fast-mode\", NULL);\n\t\tif (prop)\n\t\t\tpdata.fast_mode = 1;\n\n\t\tbreak;\n\t}\n\n\tif (!child) {\n\t\tdev_err(&dev->dev, \"failed to match a DT node for bar %d.\\n\",\n\t\t\t\tbar);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tpdev = platform_device_alloc(\"ce4100-i2c\", devnum);\n\tif (!pdev) {\n\t\tof_node_put(child);\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tpdev->dev.parent = &dev->dev;\n\tpdev->dev.of_node = child;\n\n\tret = platform_device_add_resources(pdev, res, ARRAY_SIZE(res));\n\tif (ret)\n\t\tgoto err;\n\n\tret = platform_device_add_data(pdev, &pdata, sizeof(pdata));\n\tif (ret)\n\t\tgoto err;\n\n\tret = platform_device_add(pdev);\n\tif (ret)\n\t\tgoto err;\n\tdevnum++;\n\treturn pdev;\nerr:\n\tplatform_device_put(pdev);\nout:\n\treturn ERR_PTR(ret);\n}\n\nstatic int ce4100_i2c_probe(struct pci_dev *dev,\n\t\tconst struct pci_device_id *ent)\n{\n\tint ret;\n\tint i;\n\tstruct ce4100_devices *sds;\n\n\tret = pcim_enable_device(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!dev->dev.of_node) {\n\t\tdev_err(&dev->dev, \"Missing device tree node.\\n\");\n\t\treturn -EINVAL;\n\t}\n\tsds = kzalloc(sizeof(*sds), GFP_KERNEL);\n\tif (!sds)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < ARRAY_SIZE(sds->pdev); i++) {\n\t\tsds->pdev[i] = add_i2c_device(dev, i);\n\t\tif (IS_ERR(sds->pdev[i])) {\n\t\t\tret = PTR_ERR(sds->pdev[i]);\n\t\t\twhile (--i >= 0)\n\t\t\t\tplatform_device_unregister(sds->pdev[i]);\n\t\t\tgoto err_dev_add;\n\t\t}\n\t}\n\tpci_set_drvdata(dev, sds);\n\treturn 0;\n\nerr_dev_add:\n\tkfree(sds);\n\treturn ret;\n}\n\nstatic const struct pci_device_id ce4100_i2c_devices[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x2e68)},\n\t{ },\n};\n\nstatic struct pci_driver ce4100_i2c_driver = {\n\t.driver = {\n\t\t.suppress_bind_attrs = true,\n\t},\n\t.name           = \"ce4100_i2c\",\n\t.id_table       = ce4100_i2c_devices,\n\t.probe          = ce4100_i2c_probe,\n};\nbuiltin_pci_driver(ce4100_i2c_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}