{
  "module_name": "i2c-virtio.c",
  "hash_id": "1d188da97d939298a973536c35116e63715cb5dbf8150a63342db757514cf429",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-virtio.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/completion.h>\n#include <linux/err.h>\n#include <linux/i2c.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/virtio.h>\n#include <linux/virtio_ids.h>\n#include <linux/virtio_config.h>\n#include <linux/virtio_i2c.h>\n\n \nstruct virtio_i2c {\n\tstruct virtio_device *vdev;\n\tstruct i2c_adapter adap;\n\tstruct virtqueue *vq;\n};\n\n \nstruct virtio_i2c_req {\n\tstruct completion completion;\n\tstruct virtio_i2c_out_hdr out_hdr\t____cacheline_aligned;\n\tuint8_t *buf\t\t\t\t____cacheline_aligned;\n\tstruct virtio_i2c_in_hdr in_hdr\t\t____cacheline_aligned;\n};\n\nstatic void virtio_i2c_msg_done(struct virtqueue *vq)\n{\n\tstruct virtio_i2c_req *req;\n\tunsigned int len;\n\n\twhile ((req = virtqueue_get_buf(vq, &len)))\n\t\tcomplete(&req->completion);\n}\n\nstatic int virtio_i2c_prepare_reqs(struct virtqueue *vq,\n\t\t\t\t   struct virtio_i2c_req *reqs,\n\t\t\t\t   struct i2c_msg *msgs, int num)\n{\n\tstruct scatterlist *sgs[3], out_hdr, msg_buf, in_hdr;\n\tint i;\n\n\tfor (i = 0; i < num; i++) {\n\t\tint outcnt = 0, incnt = 0;\n\n\t\tinit_completion(&reqs[i].completion);\n\n\t\t \n\t\treqs[i].out_hdr.addr = cpu_to_le16(msgs[i].addr << 1);\n\n\t\tif (msgs[i].flags & I2C_M_RD)\n\t\t\treqs[i].out_hdr.flags |= cpu_to_le32(VIRTIO_I2C_FLAGS_M_RD);\n\n\t\tif (i != num - 1)\n\t\t\treqs[i].out_hdr.flags |= cpu_to_le32(VIRTIO_I2C_FLAGS_FAIL_NEXT);\n\n\t\tsg_init_one(&out_hdr, &reqs[i].out_hdr, sizeof(reqs[i].out_hdr));\n\t\tsgs[outcnt++] = &out_hdr;\n\n\t\tif (msgs[i].len) {\n\t\t\treqs[i].buf = i2c_get_dma_safe_msg_buf(&msgs[i], 1);\n\t\t\tif (!reqs[i].buf)\n\t\t\t\tbreak;\n\n\t\t\tsg_init_one(&msg_buf, reqs[i].buf, msgs[i].len);\n\n\t\t\tif (msgs[i].flags & I2C_M_RD)\n\t\t\t\tsgs[outcnt + incnt++] = &msg_buf;\n\t\t\telse\n\t\t\t\tsgs[outcnt++] = &msg_buf;\n\t\t}\n\n\t\tsg_init_one(&in_hdr, &reqs[i].in_hdr, sizeof(reqs[i].in_hdr));\n\t\tsgs[outcnt + incnt++] = &in_hdr;\n\n\t\tif (virtqueue_add_sgs(vq, sgs, outcnt, incnt, &reqs[i], GFP_KERNEL)) {\n\t\t\ti2c_put_dma_safe_msg_buf(reqs[i].buf, &msgs[i], false);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn i;\n}\n\nstatic int virtio_i2c_complete_reqs(struct virtqueue *vq,\n\t\t\t\t    struct virtio_i2c_req *reqs,\n\t\t\t\t    struct i2c_msg *msgs, int num)\n{\n\tbool failed = false;\n\tint i, j = 0;\n\n\tfor (i = 0; i < num; i++) {\n\t\tstruct virtio_i2c_req *req = &reqs[i];\n\n\t\twait_for_completion(&req->completion);\n\n\t\tif (!failed && req->in_hdr.status != VIRTIO_I2C_MSG_OK)\n\t\t\tfailed = true;\n\n\t\ti2c_put_dma_safe_msg_buf(reqs[i].buf, &msgs[i], !failed);\n\n\t\tif (!failed)\n\t\t\tj++;\n\t}\n\n\treturn j;\n}\n\nstatic int virtio_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs,\n\t\t\t   int num)\n{\n\tstruct virtio_i2c *vi = i2c_get_adapdata(adap);\n\tstruct virtqueue *vq = vi->vq;\n\tstruct virtio_i2c_req *reqs;\n\tint count;\n\n\treqs = kcalloc(num, sizeof(*reqs), GFP_KERNEL);\n\tif (!reqs)\n\t\treturn -ENOMEM;\n\n\tcount = virtio_i2c_prepare_reqs(vq, reqs, msgs, num);\n\tif (!count)\n\t\tgoto err_free;\n\n\t \n\tvirtqueue_kick(vq);\n\n\tcount = virtio_i2c_complete_reqs(vq, reqs, msgs, count);\n\nerr_free:\n\tkfree(reqs);\n\treturn count;\n}\n\nstatic void virtio_i2c_del_vqs(struct virtio_device *vdev)\n{\n\tvirtio_reset_device(vdev);\n\tvdev->config->del_vqs(vdev);\n}\n\nstatic int virtio_i2c_setup_vqs(struct virtio_i2c *vi)\n{\n\tstruct virtio_device *vdev = vi->vdev;\n\n\tvi->vq = virtio_find_single_vq(vdev, virtio_i2c_msg_done, \"msg\");\n\treturn PTR_ERR_OR_ZERO(vi->vq);\n}\n\nstatic u32 virtio_i2c_func(struct i2c_adapter *adap)\n{\n\treturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;\n}\n\nstatic struct i2c_algorithm virtio_algorithm = {\n\t.master_xfer = virtio_i2c_xfer,\n\t.functionality = virtio_i2c_func,\n};\n\nstatic int virtio_i2c_probe(struct virtio_device *vdev)\n{\n\tstruct virtio_i2c *vi;\n\tint ret;\n\n\tif (!virtio_has_feature(vdev, VIRTIO_I2C_F_ZERO_LENGTH_REQUEST)) {\n\t\tdev_err(&vdev->dev, \"Zero-length request feature is mandatory\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tvi = devm_kzalloc(&vdev->dev, sizeof(*vi), GFP_KERNEL);\n\tif (!vi)\n\t\treturn -ENOMEM;\n\n\tvdev->priv = vi;\n\tvi->vdev = vdev;\n\n\tret = virtio_i2c_setup_vqs(vi);\n\tif (ret)\n\t\treturn ret;\n\n\tvi->adap.owner = THIS_MODULE;\n\tsnprintf(vi->adap.name, sizeof(vi->adap.name),\n\t\t \"i2c_virtio at virtio bus %d\", vdev->index);\n\tvi->adap.algo = &virtio_algorithm;\n\tvi->adap.dev.parent = &vdev->dev;\n\tvi->adap.dev.of_node = vdev->dev.of_node;\n\ti2c_set_adapdata(&vi->adap, vi);\n\n\t \n\tACPI_COMPANION_SET(&vi->adap.dev, ACPI_COMPANION(vdev->dev.parent));\n\n\tret = i2c_add_adapter(&vi->adap);\n\tif (ret)\n\t\tvirtio_i2c_del_vqs(vdev);\n\n\treturn ret;\n}\n\nstatic void virtio_i2c_remove(struct virtio_device *vdev)\n{\n\tstruct virtio_i2c *vi = vdev->priv;\n\n\ti2c_del_adapter(&vi->adap);\n\tvirtio_i2c_del_vqs(vdev);\n}\n\nstatic struct virtio_device_id id_table[] = {\n\t{ VIRTIO_ID_I2C_ADAPTER, VIRTIO_DEV_ANY_ID },\n\t{}\n};\nMODULE_DEVICE_TABLE(virtio, id_table);\n\nstatic int virtio_i2c_freeze(struct virtio_device *vdev)\n{\n\tvirtio_i2c_del_vqs(vdev);\n\treturn 0;\n}\n\nstatic int virtio_i2c_restore(struct virtio_device *vdev)\n{\n\treturn virtio_i2c_setup_vqs(vdev->priv);\n}\n\nstatic const unsigned int features[] = {\n\tVIRTIO_I2C_F_ZERO_LENGTH_REQUEST,\n};\n\nstatic struct virtio_driver virtio_i2c_driver = {\n\t.feature_table\t\t= features,\n\t.feature_table_size\t= ARRAY_SIZE(features),\n\t.id_table\t\t= id_table,\n\t.probe\t\t\t= virtio_i2c_probe,\n\t.remove\t\t\t= virtio_i2c_remove,\n\t.driver\t\t\t= {\n\t\t.name\t= \"i2c_virtio\",\n\t},\n\t.freeze\t\t\t= pm_sleep_ptr(virtio_i2c_freeze),\n\t.restore\t\t= pm_sleep_ptr(virtio_i2c_restore),\n};\nmodule_virtio_driver(virtio_i2c_driver);\n\nMODULE_AUTHOR(\"Jie Deng <jie.deng@intel.com>\");\nMODULE_AUTHOR(\"Conghui Chen <conghui.chen@intel.com>\");\nMODULE_DESCRIPTION(\"Virtio i2c bus driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}