{
  "module_name": "i2c-sibyte.c",
  "hash_id": "88cc3ade4f91901ed8625137638a4b7240f7dcfe440fe4ffa2a332a5c815e457",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-sibyte.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/i2c.h>\n#include <linux/io.h>\n#include <asm/sibyte/sb1250_regs.h>\n#include <asm/sibyte/sb1250_smbus.h>\n\n\nstruct i2c_algo_sibyte_data {\n\tvoid *data;\t\t \n\tint   bus;\t\t \n\tvoid *reg_base;\t\t \n};\n\n \n#define SMB_CSR(a,r) ((long)(a->reg_base + r))\n\n\nstatic int smbus_xfer(struct i2c_adapter *i2c_adap, u16 addr,\n\t\t      unsigned short flags, char read_write,\n\t\t      u8 command, int size, union i2c_smbus_data * data)\n{\n\tstruct i2c_algo_sibyte_data *adap = i2c_adap->algo_data;\n\tint data_bytes = 0;\n\tint error;\n\n\twhile (csr_in32(SMB_CSR(adap, R_SMB_STATUS)) & M_SMB_BUSY)\n\t\t;\n\n\tswitch (size) {\n\tcase I2C_SMBUS_QUICK:\n\t\tcsr_out32((V_SMB_ADDR(addr) |\n\t\t\t   (read_write == I2C_SMBUS_READ ? M_SMB_QDATA : 0) |\n\t\t\t   V_SMB_TT_QUICKCMD), SMB_CSR(adap, R_SMB_START));\n\t\tbreak;\n\tcase I2C_SMBUS_BYTE:\n\t\tif (read_write == I2C_SMBUS_READ) {\n\t\t\tcsr_out32((V_SMB_ADDR(addr) | V_SMB_TT_RD1BYTE),\n\t\t\t\t  SMB_CSR(adap, R_SMB_START));\n\t\t\tdata_bytes = 1;\n\t\t} else {\n\t\t\tcsr_out32(V_SMB_CMD(command), SMB_CSR(adap, R_SMB_CMD));\n\t\t\tcsr_out32((V_SMB_ADDR(addr) | V_SMB_TT_WR1BYTE),\n\t\t\t\t  SMB_CSR(adap, R_SMB_START));\n\t\t}\n\t\tbreak;\n\tcase I2C_SMBUS_BYTE_DATA:\n\t\tcsr_out32(V_SMB_CMD(command), SMB_CSR(adap, R_SMB_CMD));\n\t\tif (read_write == I2C_SMBUS_READ) {\n\t\t\tcsr_out32((V_SMB_ADDR(addr) | V_SMB_TT_CMD_RD1BYTE),\n\t\t\t\t  SMB_CSR(adap, R_SMB_START));\n\t\t\tdata_bytes = 1;\n\t\t} else {\n\t\t\tcsr_out32(V_SMB_LB(data->byte),\n\t\t\t\t  SMB_CSR(adap, R_SMB_DATA));\n\t\t\tcsr_out32((V_SMB_ADDR(addr) | V_SMB_TT_WR2BYTE),\n\t\t\t\t  SMB_CSR(adap, R_SMB_START));\n\t\t}\n\t\tbreak;\n\tcase I2C_SMBUS_WORD_DATA:\n\t\tcsr_out32(V_SMB_CMD(command), SMB_CSR(adap, R_SMB_CMD));\n\t\tif (read_write == I2C_SMBUS_READ) {\n\t\t\tcsr_out32((V_SMB_ADDR(addr) | V_SMB_TT_CMD_RD2BYTE),\n\t\t\t\t  SMB_CSR(adap, R_SMB_START));\n\t\t\tdata_bytes = 2;\n\t\t} else {\n\t\t\tcsr_out32(V_SMB_LB(data->word & 0xff),\n\t\t\t\t  SMB_CSR(adap, R_SMB_DATA));\n\t\t\tcsr_out32(V_SMB_MB(data->word >> 8),\n\t\t\t\t  SMB_CSR(adap, R_SMB_DATA));\n\t\t\tcsr_out32((V_SMB_ADDR(addr) | V_SMB_TT_WR2BYTE),\n\t\t\t\t  SMB_CSR(adap, R_SMB_START));\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\twhile (csr_in32(SMB_CSR(adap, R_SMB_STATUS)) & M_SMB_BUSY)\n\t\t;\n\n\terror = csr_in32(SMB_CSR(adap, R_SMB_STATUS));\n\tif (error & M_SMB_ERROR) {\n\t\t \n\t\tcsr_out32(M_SMB_ERROR, SMB_CSR(adap, R_SMB_STATUS));\n\t\treturn (error & M_SMB_ERROR_TYPE) ? -EIO : -ENXIO;\n\t}\n\n\tif (data_bytes == 1)\n\t\tdata->byte = csr_in32(SMB_CSR(adap, R_SMB_DATA)) & 0xff;\n\tif (data_bytes == 2)\n\t\tdata->word = csr_in32(SMB_CSR(adap, R_SMB_DATA)) & 0xffff;\n\n\treturn 0;\n}\n\nstatic u32 bit_func(struct i2c_adapter *adap)\n{\n\treturn (I2C_FUNC_SMBUS_QUICK | I2C_FUNC_SMBUS_BYTE |\n\t\tI2C_FUNC_SMBUS_BYTE_DATA | I2C_FUNC_SMBUS_WORD_DATA);\n}\n\n\n \n\nstatic const struct i2c_algorithm i2c_sibyte_algo = {\n\t.smbus_xfer\t= smbus_xfer,\n\t.functionality\t= bit_func,\n};\n\n \nstatic int __init i2c_sibyte_add_bus(struct i2c_adapter *i2c_adap, int speed)\n{\n\tstruct i2c_algo_sibyte_data *adap = i2c_adap->algo_data;\n\n\t \n\ti2c_adap->algo = &i2c_sibyte_algo;\n\n\t \n\tcsr_out32(speed, SMB_CSR(adap,R_SMB_FREQ));\n\tcsr_out32(0, SMB_CSR(adap,R_SMB_CONTROL));\n\n\treturn i2c_add_numbered_adapter(i2c_adap);\n}\n\n\nstatic struct i2c_algo_sibyte_data sibyte_board_data[2] = {\n\t{ NULL, 0, (void *) (CKSEG1+A_SMB_BASE(0)) },\n\t{ NULL, 1, (void *) (CKSEG1+A_SMB_BASE(1)) }\n};\n\nstatic struct i2c_adapter sibyte_board_adapter[2] = {\n\t{\n\t\t.owner\t\t= THIS_MODULE,\n\t\t.class\t\t= I2C_CLASS_HWMON | I2C_CLASS_SPD,\n\t\t.algo\t\t= NULL,\n\t\t.algo_data\t= &sibyte_board_data[0],\n\t\t.nr\t\t= 0,\n\t\t.name\t\t= \"SiByte SMBus 0\",\n\t},\n\t{\n\t\t.owner\t\t= THIS_MODULE,\n\t\t.class\t\t= I2C_CLASS_HWMON | I2C_CLASS_SPD,\n\t\t.algo\t\t= NULL,\n\t\t.algo_data\t= &sibyte_board_data[1],\n\t\t.nr\t\t= 1,\n\t\t.name\t\t= \"SiByte SMBus 1\",\n\t},\n};\n\nstatic int __init i2c_sibyte_init(void)\n{\n\tpr_info(\"i2c-sibyte: i2c SMBus adapter module for SiByte board\\n\");\n\tif (i2c_sibyte_add_bus(&sibyte_board_adapter[0], K_SMB_FREQ_100KHZ) < 0)\n\t\treturn -ENODEV;\n\tif (i2c_sibyte_add_bus(&sibyte_board_adapter[1],\n\t\t\t       K_SMB_FREQ_400KHZ) < 0) {\n\t\ti2c_del_adapter(&sibyte_board_adapter[0]);\n\t\treturn -ENODEV;\n\t}\n\treturn 0;\n}\n\nstatic void __exit i2c_sibyte_exit(void)\n{\n\ti2c_del_adapter(&sibyte_board_adapter[0]);\n\ti2c_del_adapter(&sibyte_board_adapter[1]);\n}\n\nmodule_init(i2c_sibyte_init);\nmodule_exit(i2c_sibyte_exit);\n\nMODULE_AUTHOR(\"Kip Walker (Broadcom Corp.)\");\nMODULE_AUTHOR(\"Steven J. Hill <sjhill@realitydiluted.com>\");\nMODULE_DESCRIPTION(\"SMBus adapter routines for SiByte boards\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}