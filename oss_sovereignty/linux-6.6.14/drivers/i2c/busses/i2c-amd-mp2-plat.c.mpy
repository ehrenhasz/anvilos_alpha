{
  "module_name": "i2c-amd-mp2-plat.c",
  "hash_id": "6dc6b644091aa7f370683dff05b0fe789b19066c63601738b9a71fff5c87d5f2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-amd-mp2-plat.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#include \"i2c-amd-mp2.h\"\n\n#define AMD_MP2_I2C_MAX_RW_LENGTH ((1 << 12) - 1)\n#define AMD_I2C_TIMEOUT (msecs_to_jiffies(250))\n\n \nstruct amd_i2c_dev {\n\tstruct amd_i2c_common common;\n\tstruct platform_device *pdev;\n\tstruct i2c_adapter adap;\n\tstruct completion cmd_complete;\n};\n\n#define amd_i2c_dev_common(__common) \\\n\tcontainer_of(__common, struct amd_i2c_dev, common)\n\nstatic int i2c_amd_dma_map(struct amd_i2c_common *i2c_common)\n{\n\tstruct device *dev_pci = &i2c_common->mp2_dev->pci_dev->dev;\n\tstruct amd_i2c_dev *i2c_dev = amd_i2c_dev_common(i2c_common);\n\tenum dma_data_direction dma_direction =\n\t\t\ti2c_common->msg->flags & I2C_M_RD ?\n\t\t\tDMA_FROM_DEVICE : DMA_TO_DEVICE;\n\n\ti2c_common->dma_buf = i2c_get_dma_safe_msg_buf(i2c_common->msg, 0);\n\ti2c_common->dma_addr = dma_map_single(dev_pci, i2c_common->dma_buf,\n\t\t\t\t\t      i2c_common->msg->len,\n\t\t\t\t\t      dma_direction);\n\n\tif (unlikely(dma_mapping_error(dev_pci, i2c_common->dma_addr))) {\n\t\tdev_err(&i2c_dev->pdev->dev,\n\t\t\t\"Error while mapping dma buffer %p\\n\",\n\t\t\ti2c_common->dma_buf);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic void i2c_amd_dma_unmap(struct amd_i2c_common *i2c_common)\n{\n\tstruct device *dev_pci = &i2c_common->mp2_dev->pci_dev->dev;\n\tenum dma_data_direction dma_direction =\n\t\t\ti2c_common->msg->flags & I2C_M_RD ?\n\t\t\tDMA_FROM_DEVICE : DMA_TO_DEVICE;\n\n\tdma_unmap_single(dev_pci, i2c_common->dma_addr,\n\t\t\t i2c_common->msg->len, dma_direction);\n\n\ti2c_put_dma_safe_msg_buf(i2c_common->dma_buf, i2c_common->msg, true);\n}\n\nstatic void i2c_amd_start_cmd(struct amd_i2c_dev *i2c_dev)\n{\n\tstruct amd_i2c_common *i2c_common = &i2c_dev->common;\n\n\treinit_completion(&i2c_dev->cmd_complete);\n\ti2c_common->cmd_success = false;\n}\n\nstatic void i2c_amd_cmd_completion(struct amd_i2c_common *i2c_common)\n{\n\tstruct amd_i2c_dev *i2c_dev = amd_i2c_dev_common(i2c_common);\n\tunion i2c_event *event = &i2c_common->eventval;\n\n\tif (event->r.status == i2c_readcomplete_event)\n\t\tdev_dbg(&i2c_dev->pdev->dev, \"readdata:%*ph\\n\", event->r.length,\n\t\t\ti2c_common->msg->buf);\n\n\tcomplete(&i2c_dev->cmd_complete);\n}\n\nstatic int i2c_amd_check_cmd_completion(struct amd_i2c_dev *i2c_dev)\n{\n\tstruct amd_i2c_common *i2c_common = &i2c_dev->common;\n\tunsigned long timeout;\n\n\ttimeout = wait_for_completion_timeout(&i2c_dev->cmd_complete,\n\t\t\t\t\t      i2c_dev->adap.timeout);\n\n\tif ((i2c_common->reqcmd == i2c_read ||\n\t     i2c_common->reqcmd == i2c_write) &&\n\t    i2c_common->msg->len > 32)\n\t\ti2c_amd_dma_unmap(i2c_common);\n\n\tif (timeout == 0) {\n\t\tamd_mp2_rw_timeout(i2c_common);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tamd_mp2_process_event(i2c_common);\n\n\tif (!i2c_common->cmd_success)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic int i2c_amd_enable_set(struct amd_i2c_dev *i2c_dev, bool enable)\n{\n\tstruct amd_i2c_common *i2c_common = &i2c_dev->common;\n\n\ti2c_amd_start_cmd(i2c_dev);\n\tamd_mp2_bus_enable_set(i2c_common, enable);\n\n\treturn i2c_amd_check_cmd_completion(i2c_dev);\n}\n\nstatic int i2c_amd_xfer_msg(struct amd_i2c_dev *i2c_dev, struct i2c_msg *pmsg)\n{\n\tstruct amd_i2c_common *i2c_common = &i2c_dev->common;\n\n\ti2c_amd_start_cmd(i2c_dev);\n\ti2c_common->msg = pmsg;\n\n\tif (pmsg->len > 32)\n\t\tif (i2c_amd_dma_map(i2c_common))\n\t\t\treturn -EIO;\n\n\tif (pmsg->flags & I2C_M_RD)\n\t\tamd_mp2_rw(i2c_common, i2c_read);\n\telse\n\t\tamd_mp2_rw(i2c_common, i2c_write);\n\n\treturn i2c_amd_check_cmd_completion(i2c_dev);\n}\n\nstatic int i2c_amd_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)\n{\n\tstruct amd_i2c_dev *i2c_dev = i2c_get_adapdata(adap);\n\tint i;\n\tstruct i2c_msg *pmsg;\n\tint err = 0;\n\n\t \n\tif (unlikely(!i2c_dev->common.mp2_dev))\n\t\treturn -EINVAL;\n\n\tamd_mp2_pm_runtime_get(i2c_dev->common.mp2_dev);\n\n\tfor (i = 0; i < num; i++) {\n\t\tpmsg = &msgs[i];\n\t\terr = i2c_amd_xfer_msg(i2c_dev, pmsg);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\tamd_mp2_pm_runtime_put(i2c_dev->common.mp2_dev);\n\treturn err ? err : num;\n}\n\nstatic u32 i2c_amd_func(struct i2c_adapter *a)\n{\n\treturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;\n}\n\nstatic const struct i2c_algorithm i2c_amd_algorithm = {\n\t.master_xfer = i2c_amd_xfer,\n\t.functionality = i2c_amd_func,\n};\n\n#ifdef CONFIG_PM\nstatic int i2c_amd_suspend(struct amd_i2c_common *i2c_common)\n{\n\tstruct amd_i2c_dev *i2c_dev = amd_i2c_dev_common(i2c_common);\n\n\ti2c_amd_enable_set(i2c_dev, false);\n\treturn 0;\n}\n\nstatic int i2c_amd_resume(struct amd_i2c_common *i2c_common)\n{\n\tstruct amd_i2c_dev *i2c_dev = amd_i2c_dev_common(i2c_common);\n\n\treturn i2c_amd_enable_set(i2c_dev, true);\n}\n#endif\n\nstatic const u32 supported_speeds[] = {\n\tI2C_MAX_HIGH_SPEED_MODE_FREQ,\n\tI2C_MAX_TURBO_MODE_FREQ,\n\tI2C_MAX_FAST_MODE_PLUS_FREQ,\n\tI2C_MAX_FAST_MODE_FREQ,\n\tI2C_MAX_STANDARD_MODE_FREQ,\n};\n\nstatic enum speed_enum i2c_amd_get_bus_speed(struct platform_device *pdev)\n{\n\tu32 acpi_speed;\n\tint i;\n\n\tacpi_speed = i2c_acpi_find_bus_speed(&pdev->dev);\n\t \n\tfor (i = 0; i < ARRAY_SIZE(supported_speeds); i++) {\n\t\tif (acpi_speed >= supported_speeds[i])\n\t\t\tbreak;\n\t}\n\tacpi_speed = i < ARRAY_SIZE(supported_speeds) ? supported_speeds[i] : 0;\n\n\tswitch (acpi_speed) {\n\tcase I2C_MAX_STANDARD_MODE_FREQ:\n\t\treturn speed100k;\n\tcase I2C_MAX_FAST_MODE_FREQ:\n\t\treturn speed400k;\n\tcase I2C_MAX_FAST_MODE_PLUS_FREQ:\n\t\treturn speed1000k;\n\tcase I2C_MAX_TURBO_MODE_FREQ:\n\t\treturn speed1400k;\n\tcase I2C_MAX_HIGH_SPEED_MODE_FREQ:\n\t\treturn speed3400k;\n\tdefault:\n\t\treturn speed400k;\n\t}\n}\n\nstatic const struct i2c_adapter_quirks amd_i2c_dev_quirks = {\n\t.max_read_len = AMD_MP2_I2C_MAX_RW_LENGTH,\n\t.max_write_len = AMD_MP2_I2C_MAX_RW_LENGTH,\n};\n\nstatic int i2c_amd_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tint ret;\n\tstruct amd_i2c_dev *i2c_dev;\n\tstruct amd_mp2_dev *mp2_dev;\n\tu64 uid;\n\n\tret = acpi_dev_uid_to_integer(ACPI_COMPANION(dev), &uid);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"missing UID/bus id!\\n\");\n\tif (uid >= 2)\n\t\treturn dev_err_probe(dev, -EINVAL, \"incorrect UID/bus id \\\"%llu\\\"!\\n\", uid);\n\tdev_dbg(dev, \"bus id is %llu\\n\", uid);\n\n\t \n\tmp2_dev = amd_mp2_find_device();\n\tif (!mp2_dev || !mp2_dev->probed)\n\t\t \n\t\treturn -EPROBE_DEFER;\n\n\ti2c_dev = devm_kzalloc(&pdev->dev, sizeof(*i2c_dev), GFP_KERNEL);\n\tif (!i2c_dev)\n\t\treturn -ENOMEM;\n\n\ti2c_dev->common.bus_id = uid;\n\ti2c_dev->common.mp2_dev = mp2_dev;\n\ti2c_dev->pdev = pdev;\n\tplatform_set_drvdata(pdev, i2c_dev);\n\n\ti2c_dev->common.cmd_completion = &i2c_amd_cmd_completion;\n#ifdef CONFIG_PM\n\ti2c_dev->common.suspend = &i2c_amd_suspend;\n\ti2c_dev->common.resume = &i2c_amd_resume;\n#endif\n\n\t \n\tamd_mp2_pm_runtime_get(mp2_dev);\n\n\ti2c_dev->common.reqcmd = i2c_none;\n\tif (amd_mp2_register_cb(&i2c_dev->common))\n\t\treturn -EINVAL;\n\tdevice_link_add(&i2c_dev->pdev->dev, &mp2_dev->pci_dev->dev,\n\t\t\tDL_FLAG_AUTOREMOVE_CONSUMER);\n\n\ti2c_dev->common.i2c_speed = i2c_amd_get_bus_speed(pdev);\n\n\t \n\ti2c_dev->adap.owner = THIS_MODULE;\n\ti2c_dev->adap.algo = &i2c_amd_algorithm;\n\ti2c_dev->adap.quirks = &amd_i2c_dev_quirks;\n\ti2c_dev->adap.dev.parent = &pdev->dev;\n\ti2c_dev->adap.algo_data = i2c_dev;\n\ti2c_dev->adap.timeout = AMD_I2C_TIMEOUT;\n\tACPI_COMPANION_SET(&i2c_dev->adap.dev, ACPI_COMPANION(&pdev->dev));\n\ti2c_dev->adap.dev.of_node = pdev->dev.of_node;\n\tsnprintf(i2c_dev->adap.name, sizeof(i2c_dev->adap.name),\n\t\t \"AMD MP2 i2c bus %u\", i2c_dev->common.bus_id);\n\ti2c_set_adapdata(&i2c_dev->adap, i2c_dev);\n\n\tinit_completion(&i2c_dev->cmd_complete);\n\n\t \n\tif (i2c_amd_enable_set(i2c_dev, true))\n\t\tdev_err(&pdev->dev, \"initial bus enable failed\\n\");\n\n\t \n\tret = i2c_add_adapter(&i2c_dev->adap);\n\n\tamd_mp2_pm_runtime_put(mp2_dev);\n\n\tif (ret < 0)\n\t\tdev_err(&pdev->dev, \"i2c add adapter failed = %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic void i2c_amd_remove(struct platform_device *pdev)\n{\n\tstruct amd_i2c_dev *i2c_dev = platform_get_drvdata(pdev);\n\tstruct amd_i2c_common *i2c_common = &i2c_dev->common;\n\n\ti2c_lock_bus(&i2c_dev->adap, I2C_LOCK_ROOT_ADAPTER);\n\n\ti2c_amd_enable_set(i2c_dev, false);\n\tamd_mp2_unregister_cb(i2c_common);\n\ti2c_common->mp2_dev = NULL;\n\n\ti2c_unlock_bus(&i2c_dev->adap, I2C_LOCK_ROOT_ADAPTER);\n\n\ti2c_del_adapter(&i2c_dev->adap);\n}\n\nstatic const struct acpi_device_id i2c_amd_acpi_match[] = {\n\t{ \"AMDI0011\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(acpi, i2c_amd_acpi_match);\n\nstatic struct platform_driver i2c_amd_plat_driver = {\n\t.probe = i2c_amd_probe,\n\t.remove_new = i2c_amd_remove,\n\t.driver = {\n\t\t.name = \"i2c_amd_mp2\",\n\t\t.acpi_match_table = ACPI_PTR(i2c_amd_acpi_match),\n\t},\n};\nmodule_platform_driver(i2c_amd_plat_driver);\n\nMODULE_DESCRIPTION(\"AMD(R) MP2 I2C Platform Driver\");\nMODULE_AUTHOR(\"Nehal Shah <nehal-bakulchandra.shah@amd.com>\");\nMODULE_AUTHOR(\"Elie Morisse <syniurge@gmail.com>\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}