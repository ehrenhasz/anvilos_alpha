{
  "module_name": "i2c-amd8111.c",
  "hash_id": "3681fd3e184f4443099823036cf0ff6f4b700cdc6d0a6add1254eab05f923202",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-amd8111.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/ioport.h>\n#include <linux/i2c.h>\n#include <linux/delay.h>\n#include <linux/acpi.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR (\"Vojtech Pavlik <vojtech@suse.cz>\");\nMODULE_DESCRIPTION(\"AMD8111 SMBus 2.0 driver\");\n\nstruct amd_smbus {\n\tstruct pci_dev *dev;\n\tstruct i2c_adapter adapter;\n\tint base;\n\tint size;\n};\n\nstatic struct pci_driver amd8111_driver;\n\n \n\n#define AMD_PCI_MISC\t0x48\n\n#define AMD_PCI_MISC_SCI\t0x04\t \n#define AMD_PCI_MISC_INT\t0x02\t \n#define AMD_PCI_MISC_SPEEDUP\t0x01\t \n\n \n\n#define AMD_EC_DATA\t0x00\t \n#define AMD_EC_SC\t0x04\t \n#define AMD_EC_CMD\t0x04\t \n#define AMD_EC_ICR\t0x08\t \n\n#define AMD_EC_SC_SMI\t0x04\t \n#define AMD_EC_SC_SCI\t0x02\t \n#define AMD_EC_SC_BURST\t0x01\t \n#define AMD_EC_SC_CMD\t0x08\t \n#define AMD_EC_SC_IBF\t0x02\t \n#define AMD_EC_SC_OBF\t0x01\t \n\n#define AMD_EC_CMD_RD\t0x80\t \n#define AMD_EC_CMD_WR\t0x81\t \n#define AMD_EC_CMD_BE\t0x82\t \n#define AMD_EC_CMD_BD\t0x83\t \n#define AMD_EC_CMD_QR\t0x84\t \n\n \n\nstatic int amd_ec_wait_write(struct amd_smbus *smbus)\n{\n\tint timeout = 500;\n\n\twhile ((inb(smbus->base + AMD_EC_SC) & AMD_EC_SC_IBF) && --timeout)\n\t\tudelay(1);\n\n\tif (!timeout) {\n\t\tdev_warn(&smbus->dev->dev,\n\t\t\t \"Timeout while waiting for IBF to clear\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\n}\n\nstatic int amd_ec_wait_read(struct amd_smbus *smbus)\n{\n\tint timeout = 500;\n\n\twhile ((~inb(smbus->base + AMD_EC_SC) & AMD_EC_SC_OBF) && --timeout)\n\t\tudelay(1);\n\n\tif (!timeout) {\n\t\tdev_warn(&smbus->dev->dev,\n\t\t\t \"Timeout while waiting for OBF to set\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\n}\n\nstatic int amd_ec_read(struct amd_smbus *smbus, unsigned char address,\n\t\tunsigned char *data)\n{\n\tint status;\n\n\tstatus = amd_ec_wait_write(smbus);\n\tif (status)\n\t\treturn status;\n\toutb(AMD_EC_CMD_RD, smbus->base + AMD_EC_CMD);\n\n\tstatus = amd_ec_wait_write(smbus);\n\tif (status)\n\t\treturn status;\n\toutb(address, smbus->base + AMD_EC_DATA);\n\n\tstatus = amd_ec_wait_read(smbus);\n\tif (status)\n\t\treturn status;\n\t*data = inb(smbus->base + AMD_EC_DATA);\n\n\treturn 0;\n}\n\nstatic int amd_ec_write(struct amd_smbus *smbus, unsigned char address,\n\t\tunsigned char data)\n{\n\tint status;\n\n\tstatus = amd_ec_wait_write(smbus);\n\tif (status)\n\t\treturn status;\n\toutb(AMD_EC_CMD_WR, smbus->base + AMD_EC_CMD);\n\n\tstatus = amd_ec_wait_write(smbus);\n\tif (status)\n\t\treturn status;\n\toutb(address, smbus->base + AMD_EC_DATA);\n\n\tstatus = amd_ec_wait_write(smbus);\n\tif (status)\n\t\treturn status;\n\toutb(data, smbus->base + AMD_EC_DATA);\n\n\treturn 0;\n}\n\n \n\n#define AMD_SMB_PRTCL\t0x00\t \n#define AMD_SMB_STS\t0x01\t \n#define AMD_SMB_ADDR\t0x02\t \n#define AMD_SMB_CMD\t0x03\t \n#define AMD_SMB_DATA\t0x04\t \n#define AMD_SMB_BCNT\t0x24\t \n#define AMD_SMB_ALRM_A\t0x25\t \n#define AMD_SMB_ALRM_D\t0x26\t \n\n#define AMD_SMB_STS_DONE\t0x80\n#define AMD_SMB_STS_ALRM\t0x40\n#define AMD_SMB_STS_RES\t\t0x20\n#define AMD_SMB_STS_STATUS\t0x1f\n\n#define AMD_SMB_STATUS_OK\t0x00\n#define AMD_SMB_STATUS_FAIL\t0x07\n#define AMD_SMB_STATUS_DNAK\t0x10\n#define AMD_SMB_STATUS_DERR\t0x11\n#define AMD_SMB_STATUS_CMD_DENY\t0x12\n#define AMD_SMB_STATUS_UNKNOWN\t0x13\n#define AMD_SMB_STATUS_ACC_DENY\t0x17\n#define AMD_SMB_STATUS_TIMEOUT\t0x18\n#define AMD_SMB_STATUS_NOTSUP\t0x19\n#define AMD_SMB_STATUS_BUSY\t0x1A\n#define AMD_SMB_STATUS_PEC\t0x1F\n\n#define AMD_SMB_PRTCL_WRITE\t\t0x00\n#define AMD_SMB_PRTCL_READ\t\t0x01\n#define AMD_SMB_PRTCL_QUICK\t\t0x02\n#define AMD_SMB_PRTCL_BYTE\t\t0x04\n#define AMD_SMB_PRTCL_BYTE_DATA\t\t0x06\n#define AMD_SMB_PRTCL_WORD_DATA\t\t0x08\n#define AMD_SMB_PRTCL_BLOCK_DATA\t0x0a\n#define AMD_SMB_PRTCL_PROC_CALL\t\t0x0c\n#define AMD_SMB_PRTCL_BLOCK_PROC_CALL\t0x0d\n#define AMD_SMB_PRTCL_I2C_BLOCK_DATA\t0x4a\n#define AMD_SMB_PRTCL_PEC\t\t0x80\n\n\nstatic s32 amd8111_access(struct i2c_adapter *adap, u16 addr,\n\t\tunsigned short flags, char read_write, u8 command, int size,\n\t\tunion i2c_smbus_data *data)\n{\n\tstruct amd_smbus *smbus = adap->algo_data;\n\tunsigned char protocol, len, pec, temp[2];\n\tint i, status;\n\n\tprotocol = (read_write == I2C_SMBUS_READ) ? AMD_SMB_PRTCL_READ\n\t\t\t\t\t\t  : AMD_SMB_PRTCL_WRITE;\n\tpec = (flags & I2C_CLIENT_PEC) ? AMD_SMB_PRTCL_PEC : 0;\n\n\tswitch (size) {\n\tcase I2C_SMBUS_QUICK:\n\t\tprotocol |= AMD_SMB_PRTCL_QUICK;\n\t\tread_write = I2C_SMBUS_WRITE;\n\t\tbreak;\n\n\tcase I2C_SMBUS_BYTE:\n\t\tif (read_write == I2C_SMBUS_WRITE) {\n\t\t\tstatus = amd_ec_write(smbus, AMD_SMB_CMD,\n\t\t\t\t\t\tcommand);\n\t\t\tif (status)\n\t\t\t\treturn status;\n\t\t}\n\t\tprotocol |= AMD_SMB_PRTCL_BYTE;\n\t\tbreak;\n\n\tcase I2C_SMBUS_BYTE_DATA:\n\t\tstatus = amd_ec_write(smbus, AMD_SMB_CMD, command);\n\t\tif (status)\n\t\t\treturn status;\n\t\tif (read_write == I2C_SMBUS_WRITE) {\n\t\t\tstatus = amd_ec_write(smbus, AMD_SMB_DATA,\n\t\t\t\t\t\tdata->byte);\n\t\t\tif (status)\n\t\t\t\treturn status;\n\t\t}\n\t\tprotocol |= AMD_SMB_PRTCL_BYTE_DATA;\n\t\tbreak;\n\n\tcase I2C_SMBUS_WORD_DATA:\n\t\tstatus = amd_ec_write(smbus, AMD_SMB_CMD, command);\n\t\tif (status)\n\t\t\treturn status;\n\t\tif (read_write == I2C_SMBUS_WRITE) {\n\t\t\tstatus = amd_ec_write(smbus, AMD_SMB_DATA,\n\t\t\t\t\t\tdata->word & 0xff);\n\t\t\tif (status)\n\t\t\t\treturn status;\n\t\t\tstatus = amd_ec_write(smbus, AMD_SMB_DATA + 1,\n\t\t\t\t\t\tdata->word >> 8);\n\t\t\tif (status)\n\t\t\t\treturn status;\n\t\t}\n\t\tprotocol |= AMD_SMB_PRTCL_WORD_DATA | pec;\n\t\tbreak;\n\n\tcase I2C_SMBUS_BLOCK_DATA:\n\t\tstatus = amd_ec_write(smbus, AMD_SMB_CMD, command);\n\t\tif (status)\n\t\t\treturn status;\n\t\tif (read_write == I2C_SMBUS_WRITE) {\n\t\t\tlen = min_t(u8, data->block[0],\n\t\t\t\t\tI2C_SMBUS_BLOCK_MAX);\n\t\t\tstatus = amd_ec_write(smbus, AMD_SMB_BCNT, len);\n\t\t\tif (status)\n\t\t\t\treturn status;\n\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\tstatus =\n\t\t\t\t\tamd_ec_write(smbus, AMD_SMB_DATA + i,\n\t\t\t\t\t\tdata->block[i + 1]);\n\t\t\t\tif (status)\n\t\t\t\t\treturn status;\n\t\t\t}\n\t\t}\n\t\tprotocol |= AMD_SMB_PRTCL_BLOCK_DATA | pec;\n\t\tbreak;\n\n\tcase I2C_SMBUS_I2C_BLOCK_DATA:\n\t\tlen = min_t(u8, data->block[0],\n\t\t\t\tI2C_SMBUS_BLOCK_MAX);\n\t\tstatus = amd_ec_write(smbus, AMD_SMB_CMD, command);\n\t\tif (status)\n\t\t\treturn status;\n\t\tstatus = amd_ec_write(smbus, AMD_SMB_BCNT, len);\n\t\tif (status)\n\t\t\treturn status;\n\t\tif (read_write == I2C_SMBUS_WRITE)\n\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\tstatus =\n\t\t\t\t\tamd_ec_write(smbus, AMD_SMB_DATA + i,\n\t\t\t\t\t\tdata->block[i + 1]);\n\t\t\t\tif (status)\n\t\t\t\t\treturn status;\n\t\t\t}\n\t\tprotocol |= AMD_SMB_PRTCL_I2C_BLOCK_DATA;\n\t\tbreak;\n\n\tcase I2C_SMBUS_PROC_CALL:\n\t\tstatus = amd_ec_write(smbus, AMD_SMB_CMD, command);\n\t\tif (status)\n\t\t\treturn status;\n\t\tstatus = amd_ec_write(smbus, AMD_SMB_DATA,\n\t\t\t\t\tdata->word & 0xff);\n\t\tif (status)\n\t\t\treturn status;\n\t\tstatus = amd_ec_write(smbus, AMD_SMB_DATA + 1,\n\t\t\t\t\tdata->word >> 8);\n\t\tif (status)\n\t\t\treturn status;\n\t\tprotocol = AMD_SMB_PRTCL_PROC_CALL | pec;\n\t\tread_write = I2C_SMBUS_READ;\n\t\tbreak;\n\n\tcase I2C_SMBUS_BLOCK_PROC_CALL:\n\t\tlen = min_t(u8, data->block[0],\n\t\t\t\tI2C_SMBUS_BLOCK_MAX - 1);\n\t\tstatus = amd_ec_write(smbus, AMD_SMB_CMD, command);\n\t\tif (status)\n\t\t\treturn status;\n\t\tstatus = amd_ec_write(smbus, AMD_SMB_BCNT, len);\n\t\tif (status)\n\t\t\treturn status;\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tstatus = amd_ec_write(smbus, AMD_SMB_DATA + i,\n\t\t\t\t\t\tdata->block[i + 1]);\n\t\t\tif (status)\n\t\t\t\treturn status;\n\t\t}\n\t\tprotocol = AMD_SMB_PRTCL_BLOCK_PROC_CALL | pec;\n\t\tread_write = I2C_SMBUS_READ;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_warn(&adap->dev, \"Unsupported transaction %d\\n\", size);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tstatus = amd_ec_write(smbus, AMD_SMB_ADDR, addr << 1);\n\tif (status)\n\t\treturn status;\n\tstatus = amd_ec_write(smbus, AMD_SMB_PRTCL, protocol);\n\tif (status)\n\t\treturn status;\n\n\tstatus = amd_ec_read(smbus, AMD_SMB_STS, temp + 0);\n\tif (status)\n\t\treturn status;\n\n\tif (~temp[0] & AMD_SMB_STS_DONE) {\n\t\tudelay(500);\n\t\tstatus = amd_ec_read(smbus, AMD_SMB_STS, temp + 0);\n\t\tif (status)\n\t\t\treturn status;\n\t}\n\n\tif (~temp[0] & AMD_SMB_STS_DONE) {\n\t\tmsleep(1);\n\t\tstatus = amd_ec_read(smbus, AMD_SMB_STS, temp + 0);\n\t\tif (status)\n\t\t\treturn status;\n\t}\n\n\tif ((~temp[0] & AMD_SMB_STS_DONE) || (temp[0] & AMD_SMB_STS_STATUS))\n\t\treturn -EIO;\n\n\tif (read_write == I2C_SMBUS_WRITE)\n\t\treturn 0;\n\n\tswitch (size) {\n\tcase I2C_SMBUS_BYTE:\n\tcase I2C_SMBUS_BYTE_DATA:\n\t\tstatus = amd_ec_read(smbus, AMD_SMB_DATA, &data->byte);\n\t\tif (status)\n\t\t\treturn status;\n\t\tbreak;\n\n\tcase I2C_SMBUS_WORD_DATA:\n\tcase I2C_SMBUS_PROC_CALL:\n\t\tstatus = amd_ec_read(smbus, AMD_SMB_DATA, temp + 0);\n\t\tif (status)\n\t\t\treturn status;\n\t\tstatus = amd_ec_read(smbus, AMD_SMB_DATA + 1, temp + 1);\n\t\tif (status)\n\t\t\treturn status;\n\t\tdata->word = (temp[1] << 8) | temp[0];\n\t\tbreak;\n\n\tcase I2C_SMBUS_BLOCK_DATA:\n\tcase I2C_SMBUS_BLOCK_PROC_CALL:\n\t\tstatus = amd_ec_read(smbus, AMD_SMB_BCNT, &len);\n\t\tif (status)\n\t\t\treturn status;\n\t\tlen = min_t(u8, len, I2C_SMBUS_BLOCK_MAX);\n\t\tfallthrough;\n\tcase I2C_SMBUS_I2C_BLOCK_DATA:\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tstatus = amd_ec_read(smbus, AMD_SMB_DATA + i,\n\t\t\t\t\t\tdata->block + i + 1);\n\t\t\tif (status)\n\t\t\t\treturn status;\n\t\t}\n\t\tdata->block[0] = len;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n\nstatic u32 amd8111_func(struct i2c_adapter *adapter)\n{\n\treturn\tI2C_FUNC_SMBUS_QUICK | I2C_FUNC_SMBUS_BYTE |\n\t\tI2C_FUNC_SMBUS_BYTE_DATA |\n\t\tI2C_FUNC_SMBUS_WORD_DATA | I2C_FUNC_SMBUS_BLOCK_DATA |\n\t\tI2C_FUNC_SMBUS_PROC_CALL | I2C_FUNC_SMBUS_BLOCK_PROC_CALL |\n\t\tI2C_FUNC_SMBUS_I2C_BLOCK | I2C_FUNC_SMBUS_PEC;\n}\n\nstatic const struct i2c_algorithm smbus_algorithm = {\n\t.smbus_xfer = amd8111_access,\n\t.functionality = amd8111_func,\n};\n\n\nstatic const struct pci_device_id amd8111_ids[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_8111_SMBUS2) },\n\t{ 0, }\n};\n\nMODULE_DEVICE_TABLE (pci, amd8111_ids);\n\nstatic int amd8111_probe(struct pci_dev *dev, const struct pci_device_id *id)\n{\n\tstruct amd_smbus *smbus;\n\tint error;\n\n\tif (!(pci_resource_flags(dev, 0) & IORESOURCE_IO))\n\t\treturn -ENODEV;\n\n\tsmbus = kzalloc(sizeof(struct amd_smbus), GFP_KERNEL);\n\tif (!smbus)\n\t\treturn -ENOMEM;\n\n\tsmbus->dev = dev;\n\tsmbus->base = pci_resource_start(dev, 0);\n\tsmbus->size = pci_resource_len(dev, 0);\n\n\terror = acpi_check_resource_conflict(&dev->resource[0]);\n\tif (error) {\n\t\terror = -ENODEV;\n\t\tgoto out_kfree;\n\t}\n\n\tif (!request_region(smbus->base, smbus->size, amd8111_driver.name)) {\n\t\terror = -EBUSY;\n\t\tgoto out_kfree;\n\t}\n\n\tsmbus->adapter.owner = THIS_MODULE;\n\tsnprintf(smbus->adapter.name, sizeof(smbus->adapter.name),\n\t\t\"SMBus2 AMD8111 adapter at %04x\", smbus->base);\n\tsmbus->adapter.class = I2C_CLASS_HWMON | I2C_CLASS_SPD;\n\tsmbus->adapter.algo = &smbus_algorithm;\n\tsmbus->adapter.algo_data = smbus;\n\n\t \n\tsmbus->adapter.dev.parent = &dev->dev;\n\n\tpci_write_config_dword(smbus->dev, AMD_PCI_MISC, 0);\n\terror = i2c_add_adapter(&smbus->adapter);\n\tif (error)\n\t\tgoto out_release_region;\n\n\tpci_set_drvdata(dev, smbus);\n\treturn 0;\n\n out_release_region:\n\trelease_region(smbus->base, smbus->size);\n out_kfree:\n\tkfree(smbus);\n\treturn error;\n}\n\nstatic void amd8111_remove(struct pci_dev *dev)\n{\n\tstruct amd_smbus *smbus = pci_get_drvdata(dev);\n\n\ti2c_del_adapter(&smbus->adapter);\n\trelease_region(smbus->base, smbus->size);\n\tkfree(smbus);\n}\n\nstatic struct pci_driver amd8111_driver = {\n\t.name\t\t= \"amd8111_smbus2\",\n\t.id_table\t= amd8111_ids,\n\t.probe\t\t= amd8111_probe,\n\t.remove\t\t= amd8111_remove,\n};\n\nmodule_pci_driver(amd8111_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}