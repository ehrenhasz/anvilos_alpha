{
  "module_name": "i2c-bcm-iproc.c",
  "hash_id": "fd83d3845dc0c368cef275168c81c1f626f4a6ac549cafa2d1e09ad7d780ffe6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-bcm-iproc.c",
  "human_readable_source": "\n\n\n#include <linux/delay.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n\n#define IDM_CTRL_DIRECT_OFFSET       0x00\n#define CFG_OFFSET                   0x00\n#define CFG_RESET_SHIFT              31\n#define CFG_EN_SHIFT                 30\n#define CFG_SLAVE_ADDR_0_SHIFT       28\n#define CFG_M_RETRY_CNT_SHIFT        16\n#define CFG_M_RETRY_CNT_MASK         0x0f\n\n#define TIM_CFG_OFFSET               0x04\n#define TIM_CFG_MODE_400_SHIFT       31\n#define TIM_RAND_SLAVE_STRETCH_SHIFT      24\n#define TIM_RAND_SLAVE_STRETCH_MASK       0x7f\n#define TIM_PERIODIC_SLAVE_STRETCH_SHIFT  16\n#define TIM_PERIODIC_SLAVE_STRETCH_MASK   0x7f\n\n#define S_CFG_SMBUS_ADDR_OFFSET           0x08\n#define S_CFG_EN_NIC_SMB_ADDR3_SHIFT      31\n#define S_CFG_NIC_SMB_ADDR3_SHIFT         24\n#define S_CFG_NIC_SMB_ADDR3_MASK          0x7f\n#define S_CFG_EN_NIC_SMB_ADDR2_SHIFT      23\n#define S_CFG_NIC_SMB_ADDR2_SHIFT         16\n#define S_CFG_NIC_SMB_ADDR2_MASK          0x7f\n#define S_CFG_EN_NIC_SMB_ADDR1_SHIFT      15\n#define S_CFG_NIC_SMB_ADDR1_SHIFT         8\n#define S_CFG_NIC_SMB_ADDR1_MASK          0x7f\n#define S_CFG_EN_NIC_SMB_ADDR0_SHIFT      7\n#define S_CFG_NIC_SMB_ADDR0_SHIFT         0\n#define S_CFG_NIC_SMB_ADDR0_MASK          0x7f\n\n#define M_FIFO_CTRL_OFFSET           0x0c\n#define M_FIFO_RX_FLUSH_SHIFT        31\n#define M_FIFO_TX_FLUSH_SHIFT        30\n#define M_FIFO_RX_CNT_SHIFT          16\n#define M_FIFO_RX_CNT_MASK           0x7f\n#define M_FIFO_RX_THLD_SHIFT         8\n#define M_FIFO_RX_THLD_MASK          0x3f\n\n#define S_FIFO_CTRL_OFFSET           0x10\n#define S_FIFO_RX_FLUSH_SHIFT        31\n#define S_FIFO_TX_FLUSH_SHIFT        30\n#define S_FIFO_RX_CNT_SHIFT          16\n#define S_FIFO_RX_CNT_MASK           0x7f\n#define S_FIFO_RX_THLD_SHIFT         8\n#define S_FIFO_RX_THLD_MASK          0x3f\n\n#define M_CMD_OFFSET                 0x30\n#define M_CMD_START_BUSY_SHIFT       31\n#define M_CMD_STATUS_SHIFT           25\n#define M_CMD_STATUS_MASK            0x07\n#define M_CMD_STATUS_SUCCESS         0x0\n#define M_CMD_STATUS_LOST_ARB        0x1\n#define M_CMD_STATUS_NACK_ADDR       0x2\n#define M_CMD_STATUS_NACK_DATA       0x3\n#define M_CMD_STATUS_TIMEOUT         0x4\n#define M_CMD_STATUS_FIFO_UNDERRUN   0x5\n#define M_CMD_STATUS_RX_FIFO_FULL    0x6\n#define M_CMD_PROTOCOL_SHIFT         9\n#define M_CMD_PROTOCOL_MASK          0xf\n#define M_CMD_PROTOCOL_QUICK         0x0\n#define M_CMD_PROTOCOL_BLK_WR        0x7\n#define M_CMD_PROTOCOL_BLK_RD        0x8\n#define M_CMD_PROTOCOL_PROCESS       0xa\n#define M_CMD_PEC_SHIFT              8\n#define M_CMD_RD_CNT_SHIFT           0\n#define M_CMD_RD_CNT_MASK            0xff\n\n#define S_CMD_OFFSET                 0x34\n#define S_CMD_START_BUSY_SHIFT       31\n#define S_CMD_STATUS_SHIFT           23\n#define S_CMD_STATUS_MASK            0x07\n#define S_CMD_STATUS_SUCCESS         0x0\n#define S_CMD_STATUS_TIMEOUT         0x5\n#define S_CMD_STATUS_MASTER_ABORT    0x7\n\n#define IE_OFFSET                    0x38\n#define IE_M_RX_FIFO_FULL_SHIFT      31\n#define IE_M_RX_THLD_SHIFT           30\n#define IE_M_START_BUSY_SHIFT        28\n#define IE_M_TX_UNDERRUN_SHIFT       27\n#define IE_S_RX_FIFO_FULL_SHIFT      26\n#define IE_S_RX_THLD_SHIFT           25\n#define IE_S_RX_EVENT_SHIFT          24\n#define IE_S_START_BUSY_SHIFT        23\n#define IE_S_TX_UNDERRUN_SHIFT       22\n#define IE_S_RD_EVENT_SHIFT          21\n\n#define IS_OFFSET                    0x3c\n#define IS_M_RX_FIFO_FULL_SHIFT      31\n#define IS_M_RX_THLD_SHIFT           30\n#define IS_M_START_BUSY_SHIFT        28\n#define IS_M_TX_UNDERRUN_SHIFT       27\n#define IS_S_RX_FIFO_FULL_SHIFT      26\n#define IS_S_RX_THLD_SHIFT           25\n#define IS_S_RX_EVENT_SHIFT          24\n#define IS_S_START_BUSY_SHIFT        23\n#define IS_S_TX_UNDERRUN_SHIFT       22\n#define IS_S_RD_EVENT_SHIFT          21\n\n#define M_TX_OFFSET                  0x40\n#define M_TX_WR_STATUS_SHIFT         31\n#define M_TX_DATA_SHIFT              0\n#define M_TX_DATA_MASK               0xff\n\n#define M_RX_OFFSET                  0x44\n#define M_RX_STATUS_SHIFT            30\n#define M_RX_STATUS_MASK             0x03\n#define M_RX_PEC_ERR_SHIFT           29\n#define M_RX_DATA_SHIFT              0\n#define M_RX_DATA_MASK               0xff\n\n#define S_TX_OFFSET                  0x48\n#define S_TX_WR_STATUS_SHIFT         31\n#define S_TX_DATA_SHIFT              0\n#define S_TX_DATA_MASK               0xff\n\n#define S_RX_OFFSET                  0x4c\n#define S_RX_STATUS_SHIFT            30\n#define S_RX_STATUS_MASK             0x03\n#define S_RX_PEC_ERR_SHIFT           29\n#define S_RX_DATA_SHIFT              0\n#define S_RX_DATA_MASK               0xff\n\n#define I2C_TIMEOUT_MSEC             50000\n#define M_TX_RX_FIFO_SIZE            64\n#define M_RX_FIFO_MAX_THLD_VALUE     (M_TX_RX_FIFO_SIZE - 1)\n\n#define M_RX_MAX_READ_LEN            255\n#define M_RX_FIFO_THLD_VALUE         50\n\n#define IE_M_ALL_INTERRUPT_SHIFT     27\n#define IE_M_ALL_INTERRUPT_MASK      0x1e\n\n#define SLAVE_READ_WRITE_BIT_MASK    0x1\n#define SLAVE_READ_WRITE_BIT_SHIFT   0x1\n#define SLAVE_MAX_SIZE_TRANSACTION   64\n#define SLAVE_CLOCK_STRETCH_TIME     25\n\n#define IE_S_ALL_INTERRUPT_SHIFT     21\n#define IE_S_ALL_INTERRUPT_MASK      0x3f\n \n#define MAX_SLAVE_RX_PER_INT         10\n\nenum i2c_slave_read_status {\n\tI2C_SLAVE_RX_FIFO_EMPTY = 0,\n\tI2C_SLAVE_RX_START,\n\tI2C_SLAVE_RX_DATA,\n\tI2C_SLAVE_RX_END,\n};\n\nenum bus_speed_index {\n\tI2C_SPD_100K = 0,\n\tI2C_SPD_400K,\n};\n\nenum bcm_iproc_i2c_type {\n\tIPROC_I2C,\n\tIPROC_I2C_NIC\n};\n\nstruct bcm_iproc_i2c_dev {\n\tstruct device *device;\n\tenum bcm_iproc_i2c_type type;\n\tint irq;\n\n\tvoid __iomem *base;\n\tvoid __iomem *idm_base;\n\n\tu32 ape_addr_mask;\n\n\t \n\tspinlock_t idm_lock;\n\n\tstruct i2c_adapter adapter;\n\tunsigned int bus_speed;\n\n\tstruct completion done;\n\tint xfer_is_done;\n\n\tstruct i2c_msg *msg;\n\n\tstruct i2c_client *slave;\n\n\t \n\tunsigned int tx_bytes;\n\t \n\tunsigned int rx_bytes;\n\tunsigned int thld_bytes;\n\n\tbool slave_rx_only;\n\tbool rx_start_rcvd;\n\tbool slave_read_complete;\n\tu32 tx_underrun;\n\tu32 slave_int_mask;\n\tstruct tasklet_struct slave_rx_tasklet;\n};\n\n \nstatic void slave_rx_tasklet_fn(unsigned long);\n\n \n#define ISR_MASK (BIT(IS_M_START_BUSY_SHIFT) | BIT(IS_M_TX_UNDERRUN_SHIFT)\\\n\t\t| BIT(IS_M_RX_THLD_SHIFT))\n\n#define ISR_MASK_SLAVE (BIT(IS_S_START_BUSY_SHIFT)\\\n\t\t| BIT(IS_S_RX_EVENT_SHIFT) | BIT(IS_S_RD_EVENT_SHIFT)\\\n\t\t| BIT(IS_S_TX_UNDERRUN_SHIFT) | BIT(IS_S_RX_FIFO_FULL_SHIFT)\\\n\t\t| BIT(IS_S_RX_THLD_SHIFT))\n\nstatic int bcm_iproc_i2c_reg_slave(struct i2c_client *slave);\nstatic int bcm_iproc_i2c_unreg_slave(struct i2c_client *slave);\nstatic void bcm_iproc_i2c_enable_disable(struct bcm_iproc_i2c_dev *iproc_i2c,\n\t\t\t\t\t bool enable);\n\nstatic inline u32 iproc_i2c_rd_reg(struct bcm_iproc_i2c_dev *iproc_i2c,\n\t\t\t\t   u32 offset)\n{\n\tu32 val;\n\tunsigned long flags;\n\n\tif (iproc_i2c->idm_base) {\n\t\tspin_lock_irqsave(&iproc_i2c->idm_lock, flags);\n\t\twritel(iproc_i2c->ape_addr_mask,\n\t\t       iproc_i2c->idm_base + IDM_CTRL_DIRECT_OFFSET);\n\t\tval = readl(iproc_i2c->base + offset);\n\t\tspin_unlock_irqrestore(&iproc_i2c->idm_lock, flags);\n\t} else {\n\t\tval = readl(iproc_i2c->base + offset);\n\t}\n\n\treturn val;\n}\n\nstatic inline void iproc_i2c_wr_reg(struct bcm_iproc_i2c_dev *iproc_i2c,\n\t\t\t\t    u32 offset, u32 val)\n{\n\tunsigned long flags;\n\n\tif (iproc_i2c->idm_base) {\n\t\tspin_lock_irqsave(&iproc_i2c->idm_lock, flags);\n\t\twritel(iproc_i2c->ape_addr_mask,\n\t\t       iproc_i2c->idm_base + IDM_CTRL_DIRECT_OFFSET);\n\t\twritel(val, iproc_i2c->base + offset);\n\t\tspin_unlock_irqrestore(&iproc_i2c->idm_lock, flags);\n\t} else {\n\t\twritel(val, iproc_i2c->base + offset);\n\t}\n}\n\nstatic void bcm_iproc_i2c_slave_init(\n\tstruct bcm_iproc_i2c_dev *iproc_i2c, bool need_reset)\n{\n\tu32 val;\n\n\tiproc_i2c->tx_underrun = 0;\n\tif (need_reset) {\n\t\t \n\t\tval = iproc_i2c_rd_reg(iproc_i2c, CFG_OFFSET);\n\t\tval |= BIT(CFG_RESET_SHIFT);\n\t\tiproc_i2c_wr_reg(iproc_i2c, CFG_OFFSET, val);\n\n\t\t \n\t\tudelay(100);\n\n\t\t \n\t\tval &= ~(BIT(CFG_RESET_SHIFT));\n\t\tiproc_i2c_wr_reg(iproc_i2c, CFG_OFFSET, val);\n\t}\n\n\t \n\tval = (BIT(S_FIFO_RX_FLUSH_SHIFT) | BIT(S_FIFO_TX_FLUSH_SHIFT));\n\tiproc_i2c_wr_reg(iproc_i2c, S_FIFO_CTRL_OFFSET, val);\n\n\t \n\tval = iproc_i2c_rd_reg(iproc_i2c, TIM_CFG_OFFSET);\n\tval &= ~(TIM_RAND_SLAVE_STRETCH_MASK << TIM_RAND_SLAVE_STRETCH_SHIFT);\n\tval |= (SLAVE_CLOCK_STRETCH_TIME << TIM_RAND_SLAVE_STRETCH_SHIFT);\n\tiproc_i2c_wr_reg(iproc_i2c, TIM_CFG_OFFSET, val);\n\n\t \n\tval = iproc_i2c_rd_reg(iproc_i2c, S_CFG_SMBUS_ADDR_OFFSET);\n\tval |= BIT(S_CFG_EN_NIC_SMB_ADDR3_SHIFT);\n\tval &= ~(S_CFG_NIC_SMB_ADDR3_MASK << S_CFG_NIC_SMB_ADDR3_SHIFT);\n\tval |= (iproc_i2c->slave->addr << S_CFG_NIC_SMB_ADDR3_SHIFT);\n\tiproc_i2c_wr_reg(iproc_i2c, S_CFG_SMBUS_ADDR_OFFSET, val);\n\n\t \n\tiproc_i2c_wr_reg(iproc_i2c, IS_OFFSET, ISR_MASK_SLAVE);\n\n\t \n\tval = BIT(IE_S_RX_EVENT_SHIFT);\n\t \n\tval |= BIT(IE_S_RX_FIFO_FULL_SHIFT);\n\t \n\tval |= BIT(IE_S_RD_EVENT_SHIFT);\n\t \n\tval |= BIT(IE_S_START_BUSY_SHIFT);\n\tiproc_i2c->slave_int_mask = val;\n\tiproc_i2c_wr_reg(iproc_i2c, IE_OFFSET, val);\n}\n\nstatic bool bcm_iproc_i2c_check_slave_status\n\t(struct bcm_iproc_i2c_dev *iproc_i2c, u32 status)\n{\n\tu32 val;\n\tbool recover = false;\n\n\t \n\tif (!iproc_i2c->slave_rx_only) {\n\t\tval = iproc_i2c_rd_reg(iproc_i2c, S_CMD_OFFSET);\n\t\t \n\t\tif (!(val & BIT(S_CMD_START_BUSY_SHIFT))) {\n\t\t\tval = (val >> S_CMD_STATUS_SHIFT) & S_CMD_STATUS_MASK;\n\t\t\tif (val == S_CMD_STATUS_TIMEOUT ||\n\t\t\t    val == S_CMD_STATUS_MASTER_ABORT) {\n\t\t\t\tdev_warn(iproc_i2c->device,\n\t\t\t\t\t (val == S_CMD_STATUS_TIMEOUT) ?\n\t\t\t\t\t \"slave random stretch time timeout\\n\" :\n\t\t\t\t\t \"Master aborted read transaction\\n\");\n\t\t\t\trecover = true;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif ((status & BIT(IS_S_RX_EVENT_SHIFT)) &&\n\t    (status & BIT(IS_S_START_BUSY_SHIFT))) {\n\t\tdev_warn(iproc_i2c->device, \"Slave aborted read transaction\\n\");\n\t\trecover = true;\n\t}\n\n\tif (recover) {\n\t\t \n\t\tbcm_iproc_i2c_enable_disable(iproc_i2c, false);\n\t\tbcm_iproc_i2c_slave_init(iproc_i2c, true);\n\t\tbcm_iproc_i2c_enable_disable(iproc_i2c, true);\n\t}\n\n\treturn recover;\n}\n\nstatic void bcm_iproc_i2c_slave_read(struct bcm_iproc_i2c_dev *iproc_i2c)\n{\n\tu8 rx_data, rx_status;\n\tu32 rx_bytes = 0;\n\tu32 val;\n\n\twhile (rx_bytes < MAX_SLAVE_RX_PER_INT) {\n\t\tval = iproc_i2c_rd_reg(iproc_i2c, S_RX_OFFSET);\n\t\trx_status = (val >> S_RX_STATUS_SHIFT) & S_RX_STATUS_MASK;\n\t\trx_data = ((val >> S_RX_DATA_SHIFT) & S_RX_DATA_MASK);\n\n\t\tif (rx_status == I2C_SLAVE_RX_START) {\n\t\t\t \n\t\t\ti2c_slave_event(iproc_i2c->slave,\n\t\t\t\t\tI2C_SLAVE_WRITE_REQUESTED, &rx_data);\n\t\t\tiproc_i2c->rx_start_rcvd = true;\n\t\t\tiproc_i2c->slave_read_complete = false;\n\t\t} else if (rx_status == I2C_SLAVE_RX_DATA &&\n\t\t\t   iproc_i2c->rx_start_rcvd) {\n\t\t\t \n\t\t\ti2c_slave_event(iproc_i2c->slave,\n\t\t\t\t\tI2C_SLAVE_WRITE_RECEIVED, &rx_data);\n\t\t} else if (rx_status == I2C_SLAVE_RX_END &&\n\t\t\t   iproc_i2c->rx_start_rcvd) {\n\t\t\t \n\t\t\tif (iproc_i2c->slave_rx_only)\n\t\t\t\ti2c_slave_event(iproc_i2c->slave,\n\t\t\t\t\t\tI2C_SLAVE_WRITE_RECEIVED,\n\t\t\t\t\t\t&rx_data);\n\n\t\t\ti2c_slave_event(iproc_i2c->slave, I2C_SLAVE_STOP,\n\t\t\t\t\t&rx_data);\n\t\t} else if (rx_status == I2C_SLAVE_RX_FIFO_EMPTY) {\n\t\t\tiproc_i2c->rx_start_rcvd = false;\n\t\t\tiproc_i2c->slave_read_complete = true;\n\t\t\tbreak;\n\t\t}\n\n\t\trx_bytes++;\n\t}\n}\n\nstatic void slave_rx_tasklet_fn(unsigned long data)\n{\n\tstruct bcm_iproc_i2c_dev *iproc_i2c = (struct bcm_iproc_i2c_dev *)data;\n\tu32 int_clr;\n\n\tbcm_iproc_i2c_slave_read(iproc_i2c);\n\n\t \n\tint_clr = BIT(IS_S_RX_EVENT_SHIFT);\n\n\tif (!iproc_i2c->slave_rx_only && iproc_i2c->slave_read_complete) {\n\t\t \n\t\tiproc_i2c->tx_underrun = 0;\n\t\tiproc_i2c->slave_int_mask |= BIT(IE_S_TX_UNDERRUN_SHIFT);\n\n\t\t \n\t\tint_clr |= BIT(IS_S_RD_EVENT_SHIFT);\n\t}\n\n\t \n\tiproc_i2c_wr_reg(iproc_i2c, IS_OFFSET, int_clr);\n\t \n\tiproc_i2c_wr_reg(iproc_i2c, IE_OFFSET, iproc_i2c->slave_int_mask);\n}\n\nstatic bool bcm_iproc_i2c_slave_isr(struct bcm_iproc_i2c_dev *iproc_i2c,\n\t\t\t\t    u32 status)\n{\n\tu32 val;\n\tu8 value;\n\n\n\tif (status & BIT(IS_S_TX_UNDERRUN_SHIFT)) {\n\t\tiproc_i2c->tx_underrun++;\n\t\tif (iproc_i2c->tx_underrun == 1)\n\t\t\t \n\t\t\ti2c_slave_event(iproc_i2c->slave,\n\t\t\t\t\tI2C_SLAVE_READ_REQUESTED,\n\t\t\t\t\t&value);\n\t\telse\n\t\t\t \n\t\t\ti2c_slave_event(iproc_i2c->slave,\n\t\t\t\t\tI2C_SLAVE_READ_PROCESSED,\n\t\t\t\t\t&value);\n\n\t\tiproc_i2c_wr_reg(iproc_i2c, S_TX_OFFSET, value);\n\t\t \n\t\tval = BIT(S_CMD_START_BUSY_SHIFT);\n\t\tiproc_i2c_wr_reg(iproc_i2c, S_CMD_OFFSET, val);\n\n\t\t \n\t\tiproc_i2c_wr_reg(iproc_i2c, IS_OFFSET,\n\t\t\t\t BIT(IS_S_TX_UNDERRUN_SHIFT));\n\t}\n\n\t \n\tif (status & BIT(IS_S_START_BUSY_SHIFT)) {\n\t\t \n\t\tiproc_i2c->slave_int_mask &= ~BIT(IE_S_TX_UNDERRUN_SHIFT);\n\t\tval = iproc_i2c_rd_reg(iproc_i2c, IE_OFFSET);\n\t\tval &= ~BIT(IE_S_TX_UNDERRUN_SHIFT);\n\t\tiproc_i2c_wr_reg(iproc_i2c, IE_OFFSET, val);\n\n\t\t \n\t\tval = BIT(S_TX_WR_STATUS_SHIFT);\n\t\tiproc_i2c_wr_reg(iproc_i2c, S_TX_OFFSET, val);\n\n\t\tval = BIT(S_CMD_START_BUSY_SHIFT);\n\t\tiproc_i2c_wr_reg(iproc_i2c, S_CMD_OFFSET, val);\n\n\t\t \n\t\tval = iproc_i2c_rd_reg(iproc_i2c, S_FIFO_CTRL_OFFSET);\n\t\tval |= (BIT(S_FIFO_TX_FLUSH_SHIFT));\n\t\tiproc_i2c_wr_reg(iproc_i2c, S_FIFO_CTRL_OFFSET, val);\n\n\t\ti2c_slave_event(iproc_i2c->slave, I2C_SLAVE_STOP, &value);\n\n\t\t \n\t\tiproc_i2c_wr_reg(iproc_i2c, IS_OFFSET,\n\t\t\t\t BIT(IS_S_START_BUSY_SHIFT));\n\t}\n\n\t \n\tif (bcm_iproc_i2c_check_slave_status(iproc_i2c, status))\n\t\treturn true;\n\n\t \n\tif (status & BIT(IS_S_RX_EVENT_SHIFT) ||\n\t    status & BIT(IS_S_RD_EVENT_SHIFT) ||\n\t    status & BIT(IS_S_RX_FIFO_FULL_SHIFT)) {\n\t\t \n\t\tval = iproc_i2c_rd_reg(iproc_i2c, IE_OFFSET);\n\t\tval &= ~iproc_i2c->slave_int_mask;\n\t\tiproc_i2c_wr_reg(iproc_i2c, IE_OFFSET, val);\n\n\t\tif (status & BIT(IS_S_RD_EVENT_SHIFT))\n\t\t\t \n\t\t\tiproc_i2c->slave_rx_only = false;\n\t\telse\n\t\t\t \n\t\t\tiproc_i2c->slave_rx_only = true;\n\n\t\t \n\t\ttasklet_schedule(&iproc_i2c->slave_rx_tasklet);\n\n\t\t \n\t\tif (status & BIT(IS_S_RX_FIFO_FULL_SHIFT)) {\n\t\t\tval = BIT(IS_S_RX_FIFO_FULL_SHIFT);\n\t\t\tiproc_i2c_wr_reg(iproc_i2c, IS_OFFSET, val);\n\t\t}\n\t}\n\n\treturn true;\n}\n\nstatic void bcm_iproc_i2c_read_valid_bytes(struct bcm_iproc_i2c_dev *iproc_i2c)\n{\n\tstruct i2c_msg *msg = iproc_i2c->msg;\n\tuint32_t val;\n\n\t \n\twhile (iproc_i2c->rx_bytes < msg->len) {\n\t\tval = iproc_i2c_rd_reg(iproc_i2c, M_RX_OFFSET);\n\n\t\t \n\t\tif (!((val >> M_RX_STATUS_SHIFT) & M_RX_STATUS_MASK))\n\t\t\tbreak;\n\n\t\tmsg->buf[iproc_i2c->rx_bytes] =\n\t\t\t(val >> M_RX_DATA_SHIFT) & M_RX_DATA_MASK;\n\t\tiproc_i2c->rx_bytes++;\n\t}\n}\n\nstatic void bcm_iproc_i2c_send(struct bcm_iproc_i2c_dev *iproc_i2c)\n{\n\tstruct i2c_msg *msg = iproc_i2c->msg;\n\tunsigned int tx_bytes = msg->len - iproc_i2c->tx_bytes;\n\tunsigned int i;\n\tu32 val;\n\n\t \n\ttx_bytes = min_t(unsigned int, tx_bytes, M_TX_RX_FIFO_SIZE);\n\tfor (i = 0; i < tx_bytes; i++) {\n\t\t \n\t\tunsigned int idx = iproc_i2c->tx_bytes + i;\n\n\t\tval = msg->buf[idx];\n\n\t\t \n\t\tif (idx == msg->len - 1) {\n\t\t\tval |= BIT(M_TX_WR_STATUS_SHIFT);\n\n\t\t\tif (iproc_i2c->irq) {\n\t\t\t\tu32 tmp;\n\n\t\t\t\t \n\t\t\t\ttmp = iproc_i2c_rd_reg(iproc_i2c, IE_OFFSET);\n\t\t\t\ttmp &= ~BIT(IE_M_TX_UNDERRUN_SHIFT);\n\t\t\t\tiproc_i2c_wr_reg(iproc_i2c, IE_OFFSET,\n\t\t\t\t\t\t tmp);\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tiproc_i2c_wr_reg(iproc_i2c, M_TX_OFFSET, val);\n\t}\n\n\t \n\tiproc_i2c->tx_bytes += tx_bytes;\n}\n\nstatic void bcm_iproc_i2c_read(struct bcm_iproc_i2c_dev *iproc_i2c)\n{\n\tstruct i2c_msg *msg = iproc_i2c->msg;\n\tu32 bytes_left, val;\n\n\tbcm_iproc_i2c_read_valid_bytes(iproc_i2c);\n\tbytes_left = msg->len - iproc_i2c->rx_bytes;\n\tif (bytes_left == 0) {\n\t\tif (iproc_i2c->irq) {\n\t\t\t \n\t\t\tval = iproc_i2c_rd_reg(iproc_i2c, IE_OFFSET);\n\t\t\tval &= ~BIT(IS_M_RX_THLD_SHIFT);\n\t\t\tiproc_i2c_wr_reg(iproc_i2c, IE_OFFSET, val);\n\t\t}\n\t} else if (bytes_left < iproc_i2c->thld_bytes) {\n\t\t \n\t\tval = iproc_i2c_rd_reg(iproc_i2c, M_FIFO_CTRL_OFFSET);\n\t\tval &= ~(M_FIFO_RX_THLD_MASK << M_FIFO_RX_THLD_SHIFT);\n\t\tval |= (bytes_left << M_FIFO_RX_THLD_SHIFT);\n\t\tiproc_i2c_wr_reg(iproc_i2c, M_FIFO_CTRL_OFFSET, val);\n\t\tiproc_i2c->thld_bytes = bytes_left;\n\t}\n\t \n}\n\nstatic void bcm_iproc_i2c_process_m_event(struct bcm_iproc_i2c_dev *iproc_i2c,\n\t\t\t\t\t  u32 status)\n{\n\t \n\tif (status & BIT(IS_M_TX_UNDERRUN_SHIFT))\n\t\tbcm_iproc_i2c_send(iproc_i2c);\n\n\t \n\tif (status & BIT(IS_M_RX_THLD_SHIFT))\n\t\tbcm_iproc_i2c_read(iproc_i2c);\n\n\t \n\tif (status & BIT(IS_M_START_BUSY_SHIFT)) {\n\t\tiproc_i2c->xfer_is_done = 1;\n\t\tif (iproc_i2c->irq)\n\t\t\tcomplete(&iproc_i2c->done);\n\t}\n}\n\nstatic irqreturn_t bcm_iproc_i2c_isr(int irq, void *data)\n{\n\tstruct bcm_iproc_i2c_dev *iproc_i2c = data;\n\tu32 slave_status;\n\tu32 status;\n\tbool ret;\n\n\tstatus = iproc_i2c_rd_reg(iproc_i2c, IS_OFFSET);\n\t \n\tslave_status = status & iproc_i2c_rd_reg(iproc_i2c, IE_OFFSET) &\n\t\t       ISR_MASK_SLAVE;\n\n\tif (slave_status) {\n\t\tret = bcm_iproc_i2c_slave_isr(iproc_i2c, slave_status);\n\t\tif (ret)\n\t\t\treturn IRQ_HANDLED;\n\t\telse\n\t\t\treturn IRQ_NONE;\n\t}\n\n\tstatus &= ISR_MASK;\n\tif (!status)\n\t\treturn IRQ_NONE;\n\n\t \n\tbcm_iproc_i2c_process_m_event(iproc_i2c, status);\n\tiproc_i2c_wr_reg(iproc_i2c, IS_OFFSET, status);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int bcm_iproc_i2c_init(struct bcm_iproc_i2c_dev *iproc_i2c)\n{\n\tu32 val;\n\n\t \n\tval = iproc_i2c_rd_reg(iproc_i2c, CFG_OFFSET);\n\tval |= BIT(CFG_RESET_SHIFT);\n\tval &= ~(BIT(CFG_EN_SHIFT));\n\tiproc_i2c_wr_reg(iproc_i2c, CFG_OFFSET, val);\n\n\t \n\tudelay(100);\n\n\t \n\tval &= ~(BIT(CFG_RESET_SHIFT));\n\tiproc_i2c_wr_reg(iproc_i2c, CFG_OFFSET, val);\n\n\t \n\tval = (BIT(M_FIFO_RX_FLUSH_SHIFT) | BIT(M_FIFO_TX_FLUSH_SHIFT));\n\tiproc_i2c_wr_reg(iproc_i2c, M_FIFO_CTRL_OFFSET, val);\n\t \n\tval = iproc_i2c_rd_reg(iproc_i2c, IE_OFFSET);\n\tval &= ~(IE_M_ALL_INTERRUPT_MASK <<\n\t\t\tIE_M_ALL_INTERRUPT_SHIFT);\n\tiproc_i2c_wr_reg(iproc_i2c, IE_OFFSET, val);\n\n\t \n\tiproc_i2c_wr_reg(iproc_i2c, IS_OFFSET, 0xffffffff);\n\n\treturn 0;\n}\n\nstatic void bcm_iproc_i2c_enable_disable(struct bcm_iproc_i2c_dev *iproc_i2c,\n\t\t\t\t\t bool enable)\n{\n\tu32 val;\n\n\tval = iproc_i2c_rd_reg(iproc_i2c, CFG_OFFSET);\n\tif (enable)\n\t\tval |= BIT(CFG_EN_SHIFT);\n\telse\n\t\tval &= ~BIT(CFG_EN_SHIFT);\n\tiproc_i2c_wr_reg(iproc_i2c, CFG_OFFSET, val);\n}\n\nstatic int bcm_iproc_i2c_check_status(struct bcm_iproc_i2c_dev *iproc_i2c,\n\t\t\t\t      struct i2c_msg *msg)\n{\n\tu32 val;\n\n\tval = iproc_i2c_rd_reg(iproc_i2c, M_CMD_OFFSET);\n\tval = (val >> M_CMD_STATUS_SHIFT) & M_CMD_STATUS_MASK;\n\n\tswitch (val) {\n\tcase M_CMD_STATUS_SUCCESS:\n\t\treturn 0;\n\n\tcase M_CMD_STATUS_LOST_ARB:\n\t\tdev_dbg(iproc_i2c->device, \"lost bus arbitration\\n\");\n\t\treturn -EAGAIN;\n\n\tcase M_CMD_STATUS_NACK_ADDR:\n\t\tdev_dbg(iproc_i2c->device, \"NAK addr:0x%02x\\n\", msg->addr);\n\t\treturn -ENXIO;\n\n\tcase M_CMD_STATUS_NACK_DATA:\n\t\tdev_dbg(iproc_i2c->device, \"NAK data\\n\");\n\t\treturn -ENXIO;\n\n\tcase M_CMD_STATUS_TIMEOUT:\n\t\tdev_dbg(iproc_i2c->device, \"bus timeout\\n\");\n\t\treturn -ETIMEDOUT;\n\n\tcase M_CMD_STATUS_FIFO_UNDERRUN:\n\t\tdev_dbg(iproc_i2c->device, \"FIFO under-run\\n\");\n\t\treturn -ENXIO;\n\n\tcase M_CMD_STATUS_RX_FIFO_FULL:\n\t\tdev_dbg(iproc_i2c->device, \"RX FIFO full\\n\");\n\t\treturn -ETIMEDOUT;\n\n\tdefault:\n\t\tdev_dbg(iproc_i2c->device, \"unknown error code=%d\\n\", val);\n\n\t\t \n\t\tbcm_iproc_i2c_enable_disable(iproc_i2c, false);\n\t\tbcm_iproc_i2c_init(iproc_i2c);\n\t\tbcm_iproc_i2c_enable_disable(iproc_i2c, true);\n\n\t\treturn -EIO;\n\t}\n}\n\nstatic int bcm_iproc_i2c_xfer_wait(struct bcm_iproc_i2c_dev *iproc_i2c,\n\t\t\t\t   struct i2c_msg *msg,\n\t\t\t\t   u32 cmd)\n{\n\tunsigned long time_left = msecs_to_jiffies(I2C_TIMEOUT_MSEC);\n\tu32 val, status;\n\tint ret;\n\n\tiproc_i2c_wr_reg(iproc_i2c, M_CMD_OFFSET, cmd);\n\n\tif (iproc_i2c->irq) {\n\t\ttime_left = wait_for_completion_timeout(&iproc_i2c->done,\n\t\t\t\t\t\t\ttime_left);\n\t\t \n\t\tiproc_i2c_wr_reg(iproc_i2c, IE_OFFSET, 0);\n\t\t \n\t\tiproc_i2c_rd_reg(iproc_i2c, IE_OFFSET);\n\t\t \n\t\tsynchronize_irq(iproc_i2c->irq);\n\n\t} else {  \n\t\tunsigned long timeout = jiffies + time_left;\n\n\t\tdo {\n\t\t\tstatus = iproc_i2c_rd_reg(iproc_i2c,\n\t\t\t\t\t\t  IS_OFFSET) & ISR_MASK;\n\t\t\tbcm_iproc_i2c_process_m_event(iproc_i2c, status);\n\t\t\tiproc_i2c_wr_reg(iproc_i2c, IS_OFFSET, status);\n\n\t\t\tif (time_after(jiffies, timeout)) {\n\t\t\t\ttime_left = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcpu_relax();\n\t\t\tcond_resched();\n\t\t} while (!iproc_i2c->xfer_is_done);\n\t}\n\n\tif (!time_left && !iproc_i2c->xfer_is_done) {\n\t\tdev_err(iproc_i2c->device, \"transaction timed out\\n\");\n\n\t\t \n\t\tval = BIT(M_FIFO_RX_FLUSH_SHIFT) | BIT(M_FIFO_TX_FLUSH_SHIFT);\n\t\tiproc_i2c_wr_reg(iproc_i2c, M_FIFO_CTRL_OFFSET, val);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tret = bcm_iproc_i2c_check_status(iproc_i2c, msg);\n\tif (ret) {\n\t\t \n\t\tval = BIT(M_FIFO_RX_FLUSH_SHIFT) | BIT(M_FIFO_TX_FLUSH_SHIFT);\n\t\tiproc_i2c_wr_reg(iproc_i2c, M_FIFO_CTRL_OFFSET, val);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int bcm_iproc_i2c_xfer_internal(struct bcm_iproc_i2c_dev *iproc_i2c,\n\t\t\t\t\tstruct i2c_msg *msgs, bool process_call)\n{\n\tint i;\n\tu8 addr;\n\tu32 val, tmp, val_intr_en;\n\tunsigned int tx_bytes;\n\tstruct i2c_msg *msg = &msgs[0];\n\n\t \n\tif (!!(iproc_i2c_rd_reg(iproc_i2c,\n\t\t\t\tM_CMD_OFFSET) & BIT(M_CMD_START_BUSY_SHIFT))) {\n\t\tdev_warn(iproc_i2c->device, \"bus is busy\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tiproc_i2c->msg = msg;\n\n\t \n\taddr = i2c_8bit_addr_from_msg(msg);\n\tiproc_i2c_wr_reg(iproc_i2c, M_TX_OFFSET, addr);\n\n\t \n\ttx_bytes = min_t(unsigned int, msg->len, M_TX_RX_FIFO_SIZE - 1);\n\tif (!(msg->flags & I2C_M_RD)) {\n\t\tfor (i = 0; i < tx_bytes; i++) {\n\t\t\tval = msg->buf[i];\n\n\t\t\t \n\t\t\tif (!process_call && (i == msg->len - 1))\n\t\t\t\tval |= BIT(M_TX_WR_STATUS_SHIFT);\n\n\t\t\tiproc_i2c_wr_reg(iproc_i2c, M_TX_OFFSET, val);\n\t\t}\n\t\tiproc_i2c->tx_bytes = tx_bytes;\n\t}\n\n\t \n\tif (process_call) {\n\t\tmsg++;\n\t\tiproc_i2c->msg = msg;   \n\n\t\t \n\t\taddr = i2c_8bit_addr_from_msg(msg);\n\t\t \n\t\tval = addr | BIT(M_TX_WR_STATUS_SHIFT);\n\t\tiproc_i2c_wr_reg(iproc_i2c, M_TX_OFFSET, val);\n\t}\n\n\t \n\tif (iproc_i2c->irq)\n\t\treinit_completion(&iproc_i2c->done);\n\n\tiproc_i2c->xfer_is_done = 0;\n\n\t \n\tval_intr_en = BIT(IE_M_START_BUSY_SHIFT);\n\n\t \n\tif (!process_call && !(msg->flags & I2C_M_RD) &&\n\t    msg->len > iproc_i2c->tx_bytes)\n\t\tval_intr_en |= BIT(IE_M_TX_UNDERRUN_SHIFT);\n\n\t \n\tval = BIT(M_CMD_START_BUSY_SHIFT);\n\n\tif (msg->len == 0) {\n\t\t \n\t\tval |= (M_CMD_PROTOCOL_QUICK << M_CMD_PROTOCOL_SHIFT);\n\t} else if (msg->flags & I2C_M_RD) {\n\t\tu32 protocol;\n\n\t\tiproc_i2c->rx_bytes = 0;\n\t\tif (msg->len > M_RX_FIFO_MAX_THLD_VALUE)\n\t\t\tiproc_i2c->thld_bytes = M_RX_FIFO_THLD_VALUE;\n\t\telse\n\t\t\tiproc_i2c->thld_bytes = msg->len;\n\n\t\t \n\t\ttmp = iproc_i2c_rd_reg(iproc_i2c, M_FIFO_CTRL_OFFSET);\n\t\ttmp &= ~(M_FIFO_RX_THLD_MASK << M_FIFO_RX_THLD_SHIFT);\n\t\ttmp |= iproc_i2c->thld_bytes << M_FIFO_RX_THLD_SHIFT;\n\t\tiproc_i2c_wr_reg(iproc_i2c, M_FIFO_CTRL_OFFSET, tmp);\n\n\t\t \n\t\tval_intr_en |= BIT(IE_M_RX_THLD_SHIFT);\n\n\t\tprotocol = process_call ?\n\t\t\t\tM_CMD_PROTOCOL_PROCESS : M_CMD_PROTOCOL_BLK_RD;\n\n\t\tval |= (protocol << M_CMD_PROTOCOL_SHIFT) |\n\t\t       (msg->len << M_CMD_RD_CNT_SHIFT);\n\t} else {\n\t\tval |= (M_CMD_PROTOCOL_BLK_WR << M_CMD_PROTOCOL_SHIFT);\n\t}\n\n\tif (iproc_i2c->irq)\n\t\tiproc_i2c_wr_reg(iproc_i2c, IE_OFFSET, val_intr_en);\n\n\treturn bcm_iproc_i2c_xfer_wait(iproc_i2c, msg, val);\n}\n\nstatic int bcm_iproc_i2c_xfer(struct i2c_adapter *adapter,\n\t\t\t      struct i2c_msg msgs[], int num)\n{\n\tstruct bcm_iproc_i2c_dev *iproc_i2c = i2c_get_adapdata(adapter);\n\tbool process_call = false;\n\tint ret;\n\n\tif (num == 2) {\n\t\t \n\t\tprocess_call = true;\n\t\tif (msgs[1].flags & I2C_M_NOSTART) {\n\t\t\tdev_err(iproc_i2c->device, \"Invalid repeated start\\n\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t}\n\n\tret = bcm_iproc_i2c_xfer_internal(iproc_i2c, msgs, process_call);\n\tif (ret) {\n\t\tdev_dbg(iproc_i2c->device, \"xfer failed\\n\");\n\t\treturn ret;\n\t}\n\n\treturn num;\n}\n\nstatic uint32_t bcm_iproc_i2c_functionality(struct i2c_adapter *adap)\n{\n\tu32 val;\n\n\tval = I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;\n\n\tif (adap->algo->reg_slave)\n\t\tval |= I2C_FUNC_SLAVE;\n\n\treturn val;\n}\n\nstatic struct i2c_algorithm bcm_iproc_algo = {\n\t.master_xfer = bcm_iproc_i2c_xfer,\n\t.functionality = bcm_iproc_i2c_functionality,\n\t.reg_slave = bcm_iproc_i2c_reg_slave,\n\t.unreg_slave = bcm_iproc_i2c_unreg_slave,\n};\n\nstatic const struct i2c_adapter_quirks bcm_iproc_i2c_quirks = {\n\t.flags = I2C_AQ_COMB_WRITE_THEN_READ,\n\t.max_comb_1st_msg_len = M_TX_RX_FIFO_SIZE,\n\t.max_read_len = M_RX_MAX_READ_LEN,\n};\n\nstatic int bcm_iproc_i2c_cfg_speed(struct bcm_iproc_i2c_dev *iproc_i2c)\n{\n\tunsigned int bus_speed;\n\tu32 val;\n\tint ret = of_property_read_u32(iproc_i2c->device->of_node,\n\t\t\t\t       \"clock-frequency\", &bus_speed);\n\tif (ret < 0) {\n\t\tdev_info(iproc_i2c->device,\n\t\t\t\"unable to interpret clock-frequency DT property\\n\");\n\t\tbus_speed = I2C_MAX_STANDARD_MODE_FREQ;\n\t}\n\n\tif (bus_speed < I2C_MAX_STANDARD_MODE_FREQ) {\n\t\tdev_err(iproc_i2c->device, \"%d Hz bus speed not supported\\n\",\n\t\t\tbus_speed);\n\t\tdev_err(iproc_i2c->device,\n\t\t\t\"valid speeds are 100khz and 400khz\\n\");\n\t\treturn -EINVAL;\n\t} else if (bus_speed < I2C_MAX_FAST_MODE_FREQ) {\n\t\tbus_speed = I2C_MAX_STANDARD_MODE_FREQ;\n\t} else {\n\t\tbus_speed = I2C_MAX_FAST_MODE_FREQ;\n\t}\n\n\tiproc_i2c->bus_speed = bus_speed;\n\tval = iproc_i2c_rd_reg(iproc_i2c, TIM_CFG_OFFSET);\n\tval &= ~BIT(TIM_CFG_MODE_400_SHIFT);\n\tval |= (bus_speed == I2C_MAX_FAST_MODE_FREQ) << TIM_CFG_MODE_400_SHIFT;\n\tiproc_i2c_wr_reg(iproc_i2c, TIM_CFG_OFFSET, val);\n\n\tdev_info(iproc_i2c->device, \"bus set to %u Hz\\n\", bus_speed);\n\n\treturn 0;\n}\n\nstatic int bcm_iproc_i2c_probe(struct platform_device *pdev)\n{\n\tint irq, ret = 0;\n\tstruct bcm_iproc_i2c_dev *iproc_i2c;\n\tstruct i2c_adapter *adap;\n\n\tiproc_i2c = devm_kzalloc(&pdev->dev, sizeof(*iproc_i2c),\n\t\t\t\t GFP_KERNEL);\n\tif (!iproc_i2c)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, iproc_i2c);\n\tiproc_i2c->device = &pdev->dev;\n\tiproc_i2c->type =\n\t\t(enum bcm_iproc_i2c_type)of_device_get_match_data(&pdev->dev);\n\tinit_completion(&iproc_i2c->done);\n\n\tiproc_i2c->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(iproc_i2c->base))\n\t\treturn PTR_ERR(iproc_i2c->base);\n\n\tif (iproc_i2c->type == IPROC_I2C_NIC) {\n\t\tiproc_i2c->idm_base = devm_platform_ioremap_resource(pdev, 1);\n\t\tif (IS_ERR(iproc_i2c->idm_base))\n\t\t\treturn PTR_ERR(iproc_i2c->idm_base);\n\n\t\tret = of_property_read_u32(iproc_i2c->device->of_node,\n\t\t\t\t\t   \"brcm,ape-hsls-addr-mask\",\n\t\t\t\t\t   &iproc_i2c->ape_addr_mask);\n\t\tif (ret < 0) {\n\t\t\tdev_err(iproc_i2c->device,\n\t\t\t\t\"'brcm,ape-hsls-addr-mask' missing\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tspin_lock_init(&iproc_i2c->idm_lock);\n\n\t\t \n\t\tbcm_iproc_algo.reg_slave = NULL;\n\t\tbcm_iproc_algo.unreg_slave = NULL;\n\t}\n\n\tret = bcm_iproc_i2c_init(iproc_i2c);\n\tif (ret)\n\t\treturn ret;\n\n\tret = bcm_iproc_i2c_cfg_speed(iproc_i2c);\n\tif (ret)\n\t\treturn ret;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq > 0) {\n\t\tret = devm_request_irq(iproc_i2c->device, irq,\n\t\t\t\t       bcm_iproc_i2c_isr, 0, pdev->name,\n\t\t\t\t       iproc_i2c);\n\t\tif (ret < 0) {\n\t\t\tdev_err(iproc_i2c->device,\n\t\t\t\t\"unable to request irq %i\\n\", irq);\n\t\t\treturn ret;\n\t\t}\n\n\t\tiproc_i2c->irq = irq;\n\t} else {\n\t\tdev_warn(iproc_i2c->device,\n\t\t\t \"no irq resource, falling back to poll mode\\n\");\n\t}\n\n\tbcm_iproc_i2c_enable_disable(iproc_i2c, true);\n\n\tadap = &iproc_i2c->adapter;\n\ti2c_set_adapdata(adap, iproc_i2c);\n\tsnprintf(adap->name, sizeof(adap->name),\n\t\t\"Broadcom iProc (%s)\",\n\t\tof_node_full_name(iproc_i2c->device->of_node));\n\tadap->algo = &bcm_iproc_algo;\n\tadap->quirks = &bcm_iproc_i2c_quirks;\n\tadap->dev.parent = &pdev->dev;\n\tadap->dev.of_node = pdev->dev.of_node;\n\n\treturn i2c_add_adapter(adap);\n}\n\nstatic void bcm_iproc_i2c_remove(struct platform_device *pdev)\n{\n\tstruct bcm_iproc_i2c_dev *iproc_i2c = platform_get_drvdata(pdev);\n\n\tif (iproc_i2c->irq) {\n\t\t \n\t\tiproc_i2c_wr_reg(iproc_i2c, IE_OFFSET, 0);\n\t\tiproc_i2c_rd_reg(iproc_i2c, IE_OFFSET);\n\t\tsynchronize_irq(iproc_i2c->irq);\n\t}\n\n\ti2c_del_adapter(&iproc_i2c->adapter);\n\tbcm_iproc_i2c_enable_disable(iproc_i2c, false);\n}\n\nstatic int bcm_iproc_i2c_suspend(struct device *dev)\n{\n\tstruct bcm_iproc_i2c_dev *iproc_i2c = dev_get_drvdata(dev);\n\n\tif (iproc_i2c->irq) {\n\t\t \n\t\tiproc_i2c_wr_reg(iproc_i2c, IE_OFFSET, 0);\n\t\tiproc_i2c_rd_reg(iproc_i2c, IE_OFFSET);\n\t\tsynchronize_irq(iproc_i2c->irq);\n\t}\n\n\t \n\tbcm_iproc_i2c_enable_disable(iproc_i2c, false);\n\n\treturn 0;\n}\n\nstatic int bcm_iproc_i2c_resume(struct device *dev)\n{\n\tstruct bcm_iproc_i2c_dev *iproc_i2c = dev_get_drvdata(dev);\n\tint ret;\n\tu32 val;\n\n\t \n\tret = bcm_iproc_i2c_init(iproc_i2c);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tval = iproc_i2c_rd_reg(iproc_i2c, TIM_CFG_OFFSET);\n\tval &= ~BIT(TIM_CFG_MODE_400_SHIFT);\n\tval |= (iproc_i2c->bus_speed == I2C_MAX_FAST_MODE_FREQ) << TIM_CFG_MODE_400_SHIFT;\n\tiproc_i2c_wr_reg(iproc_i2c, TIM_CFG_OFFSET, val);\n\n\tbcm_iproc_i2c_enable_disable(iproc_i2c, true);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops bcm_iproc_i2c_pm_ops = {\n\t.suspend_late = &bcm_iproc_i2c_suspend,\n\t.resume_early = &bcm_iproc_i2c_resume\n};\n\nstatic int bcm_iproc_i2c_reg_slave(struct i2c_client *slave)\n{\n\tstruct bcm_iproc_i2c_dev *iproc_i2c = i2c_get_adapdata(slave->adapter);\n\n\tif (iproc_i2c->slave)\n\t\treturn -EBUSY;\n\n\tif (slave->flags & I2C_CLIENT_TEN)\n\t\treturn -EAFNOSUPPORT;\n\n\tiproc_i2c->slave = slave;\n\n\ttasklet_init(&iproc_i2c->slave_rx_tasklet, slave_rx_tasklet_fn,\n\t\t     (unsigned long)iproc_i2c);\n\n\tbcm_iproc_i2c_slave_init(iproc_i2c, false);\n\treturn 0;\n}\n\nstatic int bcm_iproc_i2c_unreg_slave(struct i2c_client *slave)\n{\n\tu32 tmp;\n\tstruct bcm_iproc_i2c_dev *iproc_i2c = i2c_get_adapdata(slave->adapter);\n\n\tif (!iproc_i2c->slave)\n\t\treturn -EINVAL;\n\n\tdisable_irq(iproc_i2c->irq);\n\n\ttasklet_kill(&iproc_i2c->slave_rx_tasklet);\n\n\t \n\ttmp = iproc_i2c_rd_reg(iproc_i2c, IE_OFFSET);\n\ttmp &= ~(IE_S_ALL_INTERRUPT_MASK <<\n\t\t\tIE_S_ALL_INTERRUPT_SHIFT);\n\tiproc_i2c_wr_reg(iproc_i2c, IE_OFFSET, tmp);\n\n\t \n\ttmp = iproc_i2c_rd_reg(iproc_i2c, S_CFG_SMBUS_ADDR_OFFSET);\n\ttmp &= ~BIT(S_CFG_EN_NIC_SMB_ADDR3_SHIFT);\n\tiproc_i2c_wr_reg(iproc_i2c, S_CFG_SMBUS_ADDR_OFFSET, tmp);\n\n\t \n\ttmp = (BIT(S_FIFO_RX_FLUSH_SHIFT) | BIT(S_FIFO_TX_FLUSH_SHIFT));\n\tiproc_i2c_wr_reg(iproc_i2c, S_FIFO_CTRL_OFFSET, tmp);\n\n\t \n\tiproc_i2c_wr_reg(iproc_i2c, IS_OFFSET, ISR_MASK_SLAVE);\n\n\tiproc_i2c->slave = NULL;\n\n\tenable_irq(iproc_i2c->irq);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id bcm_iproc_i2c_of_match[] = {\n\t{\n\t\t.compatible = \"brcm,iproc-i2c\",\n\t\t.data = (int *)IPROC_I2C,\n\t}, {\n\t\t.compatible = \"brcm,iproc-nic-i2c\",\n\t\t.data = (int *)IPROC_I2C_NIC,\n\t},\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, bcm_iproc_i2c_of_match);\n\nstatic struct platform_driver bcm_iproc_i2c_driver = {\n\t.driver = {\n\t\t.name = \"bcm-iproc-i2c\",\n\t\t.of_match_table = bcm_iproc_i2c_of_match,\n\t\t.pm = pm_sleep_ptr(&bcm_iproc_i2c_pm_ops),\n\t},\n\t.probe = bcm_iproc_i2c_probe,\n\t.remove_new = bcm_iproc_i2c_remove,\n};\nmodule_platform_driver(bcm_iproc_i2c_driver);\n\nMODULE_AUTHOR(\"Ray Jui <rjui@broadcom.com>\");\nMODULE_DESCRIPTION(\"Broadcom iProc I2C Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}