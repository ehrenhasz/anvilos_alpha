{
  "module_name": "i2c-simtec.c",
  "hash_id": "2ccf0c4a0f50c044147a13dc47f497e85187e1da4ed4c810c06a7d3fbecad25d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-simtec.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n\n#include <linux/i2c.h>\n#include <linux/i2c-algo-bit.h>\n\nstruct simtec_i2c_data {\n\tstruct resource\t\t*ioarea;\n\tvoid __iomem\t\t*reg;\n\tstruct i2c_adapter\t adap;\n\tstruct i2c_algo_bit_data bit;\n};\n\n#define CMD_SET_SDA\t(1<<2)\n#define CMD_SET_SCL\t(1<<3)\n\n#define STATE_SDA\t(1<<0)\n#define STATE_SCL\t(1<<1)\n\n \n\nstatic void simtec_i2c_setsda(void *pw, int state)\n{\n\tstruct simtec_i2c_data *pd = pw;\n\twriteb(CMD_SET_SDA | (state ? STATE_SDA : 0), pd->reg);\n}\n\nstatic void simtec_i2c_setscl(void *pw, int state)\n{\n\tstruct simtec_i2c_data *pd = pw;\n\twriteb(CMD_SET_SCL | (state ? STATE_SCL : 0), pd->reg);\n}\n\nstatic int simtec_i2c_getsda(void *pw)\n{\n\tstruct simtec_i2c_data *pd = pw;\n\treturn readb(pd->reg) & STATE_SDA ? 1 : 0;\n}\n\nstatic int simtec_i2c_getscl(void *pw)\n{\n\tstruct simtec_i2c_data *pd = pw;\n\treturn readb(pd->reg) & STATE_SCL ? 1 : 0;\n}\n\n \n\nstatic int simtec_i2c_probe(struct platform_device *dev)\n{\n\tstruct simtec_i2c_data *pd;\n\tstruct resource *res;\n\tint size;\n\tint ret;\n\n\tpd = kzalloc(sizeof(struct simtec_i2c_data), GFP_KERNEL);\n\tif (pd == NULL)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(dev, pd);\n\n\tres = platform_get_resource(dev, IORESOURCE_MEM, 0);\n\tif (res == NULL) {\n\t\tdev_err(&dev->dev, \"cannot find IO resource\\n\");\n\t\tret = -ENOENT;\n\t\tgoto err;\n\t}\n\n\tsize = resource_size(res);\n\n\tpd->ioarea = request_mem_region(res->start, size, dev->name);\n\tif (pd->ioarea == NULL) {\n\t\tdev_err(&dev->dev, \"cannot request IO\\n\");\n\t\tret = -ENXIO;\n\t\tgoto err;\n\t}\n\n\tpd->reg = ioremap(res->start, size);\n\tif (pd->reg == NULL) {\n\t\tdev_err(&dev->dev, \"cannot map IO\\n\");\n\t\tret = -ENXIO;\n\t\tgoto err_res;\n\t}\n\n\t \n\n\tpd->adap.owner = THIS_MODULE;\n\tpd->adap.algo_data = &pd->bit;\n\tpd->adap.dev.parent = &dev->dev;\n\n\tstrscpy(pd->adap.name, \"Simtec I2C\", sizeof(pd->adap.name));\n\n\tpd->bit.data = pd;\n\tpd->bit.setsda = simtec_i2c_setsda;\n\tpd->bit.setscl = simtec_i2c_setscl;\n\tpd->bit.getsda = simtec_i2c_getsda;\n\tpd->bit.getscl = simtec_i2c_getscl;\n\tpd->bit.timeout = HZ;\n\tpd->bit.udelay = 20;\n\n\tret = i2c_bit_add_bus(&pd->adap);\n\tif (ret)\n\t\tgoto err_all;\n\n\treturn 0;\n\n err_all:\n\tiounmap(pd->reg);\n\n err_res:\n\trelease_mem_region(pd->ioarea->start, size);\n\n err:\n\tkfree(pd);\n\treturn ret;\n}\n\nstatic void simtec_i2c_remove(struct platform_device *dev)\n{\n\tstruct simtec_i2c_data *pd = platform_get_drvdata(dev);\n\n\ti2c_del_adapter(&pd->adap);\n\n\tiounmap(pd->reg);\n\trelease_mem_region(pd->ioarea->start, resource_size(pd->ioarea));\n\tkfree(pd);\n}\n\n \n\nstatic struct platform_driver simtec_i2c_driver = {\n\t.driver\t\t= {\n\t\t.name\t\t= \"simtec-i2c\",\n\t},\n\t.probe\t\t= simtec_i2c_probe,\n\t.remove_new\t= simtec_i2c_remove,\n};\n\nmodule_platform_driver(simtec_i2c_driver);\n\nMODULE_DESCRIPTION(\"Simtec Generic I2C Bus driver\");\nMODULE_AUTHOR(\"Ben Dooks <ben@simtec.co.uk>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:simtec-i2c\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}