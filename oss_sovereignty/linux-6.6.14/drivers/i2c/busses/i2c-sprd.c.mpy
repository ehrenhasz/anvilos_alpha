{
  "module_name": "i2c-sprd.c",
  "hash_id": "0cdb2aa5f351508c20a5758ec0af3278c84b6aeb02afe549658b92c5000dd969",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-sprd.c",
  "human_readable_source": " \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/i2c.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n\n#define I2C_CTL\t\t\t0x00\n#define I2C_ADDR_CFG\t\t0x04\n#define I2C_COUNT\t\t0x08\n#define I2C_RX\t\t\t0x0c\n#define I2C_TX\t\t\t0x10\n#define I2C_STATUS\t\t0x14\n#define I2C_HSMODE_CFG\t\t0x18\n#define I2C_VERSION\t\t0x1c\n#define ADDR_DVD0\t\t0x20\n#define ADDR_DVD1\t\t0x24\n#define ADDR_STA0_DVD\t\t0x28\n#define ADDR_RST\t\t0x2c\n\n \n#define STP_EN\t\t\tBIT(20)\n#define FIFO_AF_LVL_MASK\tGENMASK(19, 16)\n#define FIFO_AF_LVL\t\t16\n#define FIFO_AE_LVL_MASK\tGENMASK(15, 12)\n#define FIFO_AE_LVL\t\t12\n#define I2C_DMA_EN\t\tBIT(11)\n#define FULL_INTEN\t\tBIT(10)\n#define EMPTY_INTEN\t\tBIT(9)\n#define I2C_DVD_OPT\t\tBIT(8)\n#define I2C_OUT_OPT\t\tBIT(7)\n#define I2C_TRIM_OPT\t\tBIT(6)\n#define I2C_HS_MODE\t\tBIT(4)\n#define I2C_MODE\t\tBIT(3)\n#define I2C_EN\t\t\tBIT(2)\n#define I2C_INT_EN\t\tBIT(1)\n#define I2C_START\t\tBIT(0)\n\n \n#define SDA_IN\t\t\tBIT(21)\n#define SCL_IN\t\t\tBIT(20)\n#define FIFO_FULL\t\tBIT(4)\n#define FIFO_EMPTY\t\tBIT(3)\n#define I2C_INT\t\t\tBIT(2)\n#define I2C_RX_ACK\t\tBIT(1)\n#define I2C_BUSY\t\tBIT(0)\n\n \n#define I2C_RST\t\t\tBIT(0)\n\n#define I2C_FIFO_DEEP\t\t12\n#define I2C_FIFO_FULL_THLD\t15\n#define I2C_FIFO_EMPTY_THLD\t4\n#define I2C_DATA_STEP\t\t8\n#define I2C_ADDR_DVD0_CALC(high, low)\t\\\n\t((((high) & GENMASK(15, 0)) << 16) | ((low) & GENMASK(15, 0)))\n#define I2C_ADDR_DVD1_CALC(high, low)\t\\\n\t(((high) & GENMASK(31, 16)) | (((low) & GENMASK(31, 16)) >> 16))\n\n \n#define SPRD_I2C_PM_TIMEOUT\t1000\n \n#define I2C_XFER_TIMEOUT\t1000\n\n \nstruct sprd_i2c {\n\tstruct i2c_adapter adap;\n\tstruct device *dev;\n\tvoid __iomem *base;\n\tstruct i2c_msg *msg;\n\tstruct clk *clk;\n\tu32 src_clk;\n\tu32 bus_freq;\n\tstruct completion complete;\n\tu8 *buf;\n\tu32 count;\n\tint irq;\n\tint err;\n};\n\nstatic void sprd_i2c_set_count(struct sprd_i2c *i2c_dev, u32 count)\n{\n\twritel(count, i2c_dev->base + I2C_COUNT);\n}\n\nstatic void sprd_i2c_send_stop(struct sprd_i2c *i2c_dev, int stop)\n{\n\tu32 tmp = readl(i2c_dev->base + I2C_CTL);\n\n\tif (stop)\n\t\twritel(tmp & ~STP_EN, i2c_dev->base + I2C_CTL);\n\telse\n\t\twritel(tmp | STP_EN, i2c_dev->base + I2C_CTL);\n}\n\nstatic void sprd_i2c_clear_start(struct sprd_i2c *i2c_dev)\n{\n\tu32 tmp = readl(i2c_dev->base + I2C_CTL);\n\n\twritel(tmp & ~I2C_START, i2c_dev->base + I2C_CTL);\n}\n\nstatic void sprd_i2c_clear_ack(struct sprd_i2c *i2c_dev)\n{\n\tu32 tmp = readl(i2c_dev->base + I2C_STATUS);\n\n\twritel(tmp & ~I2C_RX_ACK, i2c_dev->base + I2C_STATUS);\n}\n\nstatic void sprd_i2c_clear_irq(struct sprd_i2c *i2c_dev)\n{\n\tu32 tmp = readl(i2c_dev->base + I2C_STATUS);\n\n\twritel(tmp & ~I2C_INT, i2c_dev->base + I2C_STATUS);\n}\n\nstatic void sprd_i2c_reset_fifo(struct sprd_i2c *i2c_dev)\n{\n\twritel(I2C_RST, i2c_dev->base + ADDR_RST);\n}\n\nstatic void sprd_i2c_set_devaddr(struct sprd_i2c *i2c_dev, struct i2c_msg *m)\n{\n\twritel(m->addr << 1, i2c_dev->base + I2C_ADDR_CFG);\n}\n\nstatic void sprd_i2c_write_bytes(struct sprd_i2c *i2c_dev, u8 *buf, u32 len)\n{\n\tu32 i;\n\n\tfor (i = 0; i < len; i++)\n\t\twriteb(buf[i], i2c_dev->base + I2C_TX);\n}\n\nstatic void sprd_i2c_read_bytes(struct sprd_i2c *i2c_dev, u8 *buf, u32 len)\n{\n\tu32 i;\n\n\tfor (i = 0; i < len; i++)\n\t\tbuf[i] = readb(i2c_dev->base + I2C_RX);\n}\n\nstatic void sprd_i2c_set_full_thld(struct sprd_i2c *i2c_dev, u32 full_thld)\n{\n\tu32 tmp = readl(i2c_dev->base + I2C_CTL);\n\n\ttmp &= ~FIFO_AF_LVL_MASK;\n\ttmp |= full_thld << FIFO_AF_LVL;\n\twritel(tmp, i2c_dev->base + I2C_CTL);\n};\n\nstatic void sprd_i2c_set_empty_thld(struct sprd_i2c *i2c_dev, u32 empty_thld)\n{\n\tu32 tmp = readl(i2c_dev->base + I2C_CTL);\n\n\ttmp &= ~FIFO_AE_LVL_MASK;\n\ttmp |= empty_thld << FIFO_AE_LVL;\n\twritel(tmp, i2c_dev->base + I2C_CTL);\n};\n\nstatic void sprd_i2c_set_fifo_full_int(struct sprd_i2c *i2c_dev, int enable)\n{\n\tu32 tmp = readl(i2c_dev->base + I2C_CTL);\n\n\tif (enable)\n\t\ttmp |= FULL_INTEN;\n\telse\n\t\ttmp &= ~FULL_INTEN;\n\n\twritel(tmp, i2c_dev->base + I2C_CTL);\n};\n\nstatic void sprd_i2c_set_fifo_empty_int(struct sprd_i2c *i2c_dev, int enable)\n{\n\tu32 tmp = readl(i2c_dev->base + I2C_CTL);\n\n\tif (enable)\n\t\ttmp |= EMPTY_INTEN;\n\telse\n\t\ttmp &= ~EMPTY_INTEN;\n\n\twritel(tmp, i2c_dev->base + I2C_CTL);\n};\n\nstatic void sprd_i2c_opt_start(struct sprd_i2c *i2c_dev)\n{\n\tu32 tmp = readl(i2c_dev->base + I2C_CTL);\n\n\twritel(tmp | I2C_START, i2c_dev->base + I2C_CTL);\n}\n\nstatic void sprd_i2c_opt_mode(struct sprd_i2c *i2c_dev, int rw)\n{\n\tu32 cmd = readl(i2c_dev->base + I2C_CTL) & ~I2C_MODE;\n\n\twritel(cmd | rw << 3, i2c_dev->base + I2C_CTL);\n}\n\nstatic void sprd_i2c_data_transfer(struct sprd_i2c *i2c_dev)\n{\n\tu32 i2c_count = i2c_dev->count;\n\tu32 need_tran = i2c_count <= I2C_FIFO_DEEP ? i2c_count : I2C_FIFO_DEEP;\n\tstruct i2c_msg *msg = i2c_dev->msg;\n\n\tif (msg->flags & I2C_M_RD) {\n\t\tsprd_i2c_read_bytes(i2c_dev, i2c_dev->buf, I2C_FIFO_FULL_THLD);\n\t\ti2c_dev->count -= I2C_FIFO_FULL_THLD;\n\t\ti2c_dev->buf += I2C_FIFO_FULL_THLD;\n\n\t\t \n\t\tif (i2c_dev->count >= I2C_FIFO_FULL_THLD)\n\t\t\tsprd_i2c_set_fifo_full_int(i2c_dev, 1);\n\t} else {\n\t\tsprd_i2c_write_bytes(i2c_dev, i2c_dev->buf, need_tran);\n\t\ti2c_dev->buf += need_tran;\n\t\ti2c_dev->count -= need_tran;\n\n\t\t \n\t\tif (i2c_count > I2C_FIFO_DEEP)\n\t\t\tsprd_i2c_set_fifo_empty_int(i2c_dev, 1);\n\t}\n}\n\nstatic int sprd_i2c_handle_msg(struct i2c_adapter *i2c_adap,\n\t\t\t       struct i2c_msg *msg, bool is_last_msg)\n{\n\tstruct sprd_i2c *i2c_dev = i2c_adap->algo_data;\n\tunsigned long time_left;\n\n\ti2c_dev->msg = msg;\n\ti2c_dev->buf = msg->buf;\n\ti2c_dev->count = msg->len;\n\n\treinit_completion(&i2c_dev->complete);\n\tsprd_i2c_reset_fifo(i2c_dev);\n\tsprd_i2c_set_devaddr(i2c_dev, msg);\n\tsprd_i2c_set_count(i2c_dev, msg->len);\n\n\tif (msg->flags & I2C_M_RD) {\n\t\tsprd_i2c_opt_mode(i2c_dev, 1);\n\t\tsprd_i2c_send_stop(i2c_dev, 1);\n\t} else {\n\t\tsprd_i2c_opt_mode(i2c_dev, 0);\n\t\tsprd_i2c_send_stop(i2c_dev, !!is_last_msg);\n\t}\n\n\t \n\tif (msg->flags & I2C_M_RD)\n\t\tsprd_i2c_set_fifo_full_int(i2c_dev, 1);\n\telse\n\t\tsprd_i2c_data_transfer(i2c_dev);\n\n\tsprd_i2c_opt_start(i2c_dev);\n\n\ttime_left = wait_for_completion_timeout(&i2c_dev->complete,\n\t\t\t\tmsecs_to_jiffies(I2C_XFER_TIMEOUT));\n\tif (!time_left)\n\t\treturn -ETIMEDOUT;\n\n\treturn i2c_dev->err;\n}\n\nstatic int sprd_i2c_master_xfer(struct i2c_adapter *i2c_adap,\n\t\t\t\tstruct i2c_msg *msgs, int num)\n{\n\tstruct sprd_i2c *i2c_dev = i2c_adap->algo_data;\n\tint im, ret;\n\n\tret = pm_runtime_resume_and_get(i2c_dev->dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfor (im = 0; im < num - 1; im++) {\n\t\tret = sprd_i2c_handle_msg(i2c_adap, &msgs[im], 0);\n\t\tif (ret)\n\t\t\tgoto err_msg;\n\t}\n\n\tret = sprd_i2c_handle_msg(i2c_adap, &msgs[im++], 1);\n\nerr_msg:\n\tpm_runtime_mark_last_busy(i2c_dev->dev);\n\tpm_runtime_put_autosuspend(i2c_dev->dev);\n\n\treturn ret < 0 ? ret : im;\n}\n\nstatic u32 sprd_i2c_func(struct i2c_adapter *adap)\n{\n\treturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;\n}\n\nstatic const struct i2c_algorithm sprd_i2c_algo = {\n\t.master_xfer = sprd_i2c_master_xfer,\n\t.functionality = sprd_i2c_func,\n};\n\nstatic void sprd_i2c_set_clk(struct sprd_i2c *i2c_dev, u32 freq)\n{\n\tu32 apb_clk = i2c_dev->src_clk;\n\t \n\tu32 i2c_dvd = apb_clk / (4 * freq) - 1;\n\t \n\tu32 high = ((i2c_dvd << 1) * 2) / 5;\n\tu32 low = ((i2c_dvd << 1) * 3) / 5;\n\tu32 div0 = I2C_ADDR_DVD0_CALC(high, low);\n\tu32 div1 = I2C_ADDR_DVD1_CALC(high, low);\n\n\twritel(div0, i2c_dev->base + ADDR_DVD0);\n\twritel(div1, i2c_dev->base + ADDR_DVD1);\n\n\t \n\tif (freq == I2C_MAX_FAST_MODE_FREQ)\n\t\twritel((6 * apb_clk) / 10000000, i2c_dev->base + ADDR_STA0_DVD);\n\telse if (freq == I2C_MAX_STANDARD_MODE_FREQ)\n\t\twritel((4 * apb_clk) / 1000000, i2c_dev->base + ADDR_STA0_DVD);\n}\n\nstatic void sprd_i2c_enable(struct sprd_i2c *i2c_dev)\n{\n\tu32 tmp = I2C_DVD_OPT;\n\n\twritel(tmp, i2c_dev->base + I2C_CTL);\n\n\tsprd_i2c_set_full_thld(i2c_dev, I2C_FIFO_FULL_THLD);\n\tsprd_i2c_set_empty_thld(i2c_dev, I2C_FIFO_EMPTY_THLD);\n\n\tsprd_i2c_set_clk(i2c_dev, i2c_dev->bus_freq);\n\tsprd_i2c_reset_fifo(i2c_dev);\n\tsprd_i2c_clear_irq(i2c_dev);\n\n\ttmp = readl(i2c_dev->base + I2C_CTL);\n\twritel(tmp | I2C_EN | I2C_INT_EN, i2c_dev->base + I2C_CTL);\n}\n\nstatic irqreturn_t sprd_i2c_isr_thread(int irq, void *dev_id)\n{\n\tstruct sprd_i2c *i2c_dev = dev_id;\n\tstruct i2c_msg *msg = i2c_dev->msg;\n\tbool ack = !(readl(i2c_dev->base + I2C_STATUS) & I2C_RX_ACK);\n\tu32 i2c_tran;\n\n\tif (msg->flags & I2C_M_RD)\n\t\ti2c_tran = i2c_dev->count >= I2C_FIFO_FULL_THLD;\n\telse\n\t\ti2c_tran = i2c_dev->count;\n\n\t \n\tif (i2c_tran && ack) {\n\t\tsprd_i2c_data_transfer(i2c_dev);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\ti2c_dev->err = 0;\n\n\t \n\tif (!ack)\n\t\ti2c_dev->err = -EIO;\n\telse if (msg->flags & I2C_M_RD && i2c_dev->count)\n\t\tsprd_i2c_read_bytes(i2c_dev, i2c_dev->buf, i2c_dev->count);\n\n\t \n\tsprd_i2c_clear_ack(i2c_dev);\n\tsprd_i2c_clear_start(i2c_dev);\n\tcomplete(&i2c_dev->complete);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t sprd_i2c_isr(int irq, void *dev_id)\n{\n\tstruct sprd_i2c *i2c_dev = dev_id;\n\tstruct i2c_msg *msg = i2c_dev->msg;\n\tbool ack = !(readl(i2c_dev->base + I2C_STATUS) & I2C_RX_ACK);\n\tu32 i2c_tran;\n\n\tif (msg->flags & I2C_M_RD)\n\t\ti2c_tran = i2c_dev->count >= I2C_FIFO_FULL_THLD;\n\telse\n\t\ti2c_tran = i2c_dev->count;\n\n\t \n\tif (!i2c_tran || !ack) {\n\t\tsprd_i2c_clear_start(i2c_dev);\n\t\tsprd_i2c_clear_irq(i2c_dev);\n\t}\n\n\tsprd_i2c_set_fifo_empty_int(i2c_dev, 0);\n\tsprd_i2c_set_fifo_full_int(i2c_dev, 0);\n\n\treturn IRQ_WAKE_THREAD;\n}\n\nstatic int sprd_i2c_clk_init(struct sprd_i2c *i2c_dev)\n{\n\tstruct clk *clk_i2c, *clk_parent;\n\n\tclk_i2c = devm_clk_get(i2c_dev->dev, \"i2c\");\n\tif (IS_ERR(clk_i2c)) {\n\t\tdev_warn(i2c_dev->dev, \"i2c%d can't get the i2c clock\\n\",\n\t\t\t i2c_dev->adap.nr);\n\t\tclk_i2c = NULL;\n\t}\n\n\tclk_parent = devm_clk_get(i2c_dev->dev, \"source\");\n\tif (IS_ERR(clk_parent)) {\n\t\tdev_warn(i2c_dev->dev, \"i2c%d can't get the source clock\\n\",\n\t\t\t i2c_dev->adap.nr);\n\t\tclk_parent = NULL;\n\t}\n\n\tif (clk_set_parent(clk_i2c, clk_parent))\n\t\ti2c_dev->src_clk = clk_get_rate(clk_i2c);\n\telse\n\t\ti2c_dev->src_clk = 26000000;\n\n\tdev_dbg(i2c_dev->dev, \"i2c%d set source clock is %d\\n\",\n\t\ti2c_dev->adap.nr, i2c_dev->src_clk);\n\n\ti2c_dev->clk = devm_clk_get(i2c_dev->dev, \"enable\");\n\tif (IS_ERR(i2c_dev->clk)) {\n\t\tdev_err(i2c_dev->dev, \"i2c%d can't get the enable clock\\n\",\n\t\t\ti2c_dev->adap.nr);\n\t\treturn PTR_ERR(i2c_dev->clk);\n\t}\n\n\treturn 0;\n}\n\nstatic int sprd_i2c_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct sprd_i2c *i2c_dev;\n\tu32 prop;\n\tint ret;\n\n\tpdev->id = of_alias_get_id(dev->of_node, \"i2c\");\n\n\ti2c_dev = devm_kzalloc(dev, sizeof(struct sprd_i2c), GFP_KERNEL);\n\tif (!i2c_dev)\n\t\treturn -ENOMEM;\n\n\ti2c_dev->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(i2c_dev->base))\n\t\treturn PTR_ERR(i2c_dev->base);\n\n\ti2c_dev->irq = platform_get_irq(pdev, 0);\n\tif (i2c_dev->irq < 0)\n\t\treturn i2c_dev->irq;\n\n\ti2c_set_adapdata(&i2c_dev->adap, i2c_dev);\n\tinit_completion(&i2c_dev->complete);\n\tsnprintf(i2c_dev->adap.name, sizeof(i2c_dev->adap.name),\n\t\t \"%s\", \"sprd-i2c\");\n\n\ti2c_dev->bus_freq = I2C_MAX_STANDARD_MODE_FREQ;\n\ti2c_dev->adap.owner = THIS_MODULE;\n\ti2c_dev->dev = dev;\n\ti2c_dev->adap.retries = 3;\n\ti2c_dev->adap.algo = &sprd_i2c_algo;\n\ti2c_dev->adap.algo_data = i2c_dev;\n\ti2c_dev->adap.dev.parent = dev;\n\ti2c_dev->adap.nr = pdev->id;\n\ti2c_dev->adap.dev.of_node = dev->of_node;\n\n\tif (!of_property_read_u32(dev->of_node, \"clock-frequency\", &prop))\n\t\ti2c_dev->bus_freq = prop;\n\n\t \n\tif (i2c_dev->bus_freq != I2C_MAX_STANDARD_MODE_FREQ &&\n\t    i2c_dev->bus_freq != I2C_MAX_FAST_MODE_FREQ)\n\t\treturn -EINVAL;\n\n\tret = sprd_i2c_clk_init(i2c_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tplatform_set_drvdata(pdev, i2c_dev);\n\n\tret = clk_prepare_enable(i2c_dev->clk);\n\tif (ret)\n\t\treturn ret;\n\n\tsprd_i2c_enable(i2c_dev);\n\n\tpm_runtime_set_autosuspend_delay(i2c_dev->dev, SPRD_I2C_PM_TIMEOUT);\n\tpm_runtime_use_autosuspend(i2c_dev->dev);\n\tpm_runtime_set_active(i2c_dev->dev);\n\tpm_runtime_enable(i2c_dev->dev);\n\n\tret = pm_runtime_get_sync(i2c_dev->dev);\n\tif (ret < 0)\n\t\tgoto err_rpm_put;\n\n\tret = devm_request_threaded_irq(dev, i2c_dev->irq,\n\t\tsprd_i2c_isr, sprd_i2c_isr_thread,\n\t\tIRQF_NO_SUSPEND | IRQF_ONESHOT,\n\t\tpdev->name, i2c_dev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to request irq %d\\n\", i2c_dev->irq);\n\t\tgoto err_rpm_put;\n\t}\n\n\tret = i2c_add_numbered_adapter(&i2c_dev->adap);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"add adapter failed\\n\");\n\t\tgoto err_rpm_put;\n\t}\n\n\tpm_runtime_mark_last_busy(i2c_dev->dev);\n\tpm_runtime_put_autosuspend(i2c_dev->dev);\n\treturn 0;\n\nerr_rpm_put:\n\tpm_runtime_put_noidle(i2c_dev->dev);\n\tpm_runtime_disable(i2c_dev->dev);\n\tclk_disable_unprepare(i2c_dev->clk);\n\treturn ret;\n}\n\nstatic int sprd_i2c_remove(struct platform_device *pdev)\n{\n\tstruct sprd_i2c *i2c_dev = platform_get_drvdata(pdev);\n\tint ret;\n\n\tret = pm_runtime_get_sync(i2c_dev->dev);\n\tif (ret < 0)\n\t\tdev_err(&pdev->dev, \"Failed to resume device (%pe)\\n\", ERR_PTR(ret));\n\n\ti2c_del_adapter(&i2c_dev->adap);\n\n\tif (ret >= 0)\n\t\tclk_disable_unprepare(i2c_dev->clk);\n\n\tpm_runtime_put_noidle(i2c_dev->dev);\n\tpm_runtime_disable(i2c_dev->dev);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused sprd_i2c_suspend_noirq(struct device *dev)\n{\n\tstruct sprd_i2c *i2c_dev = dev_get_drvdata(dev);\n\n\ti2c_mark_adapter_suspended(&i2c_dev->adap);\n\treturn pm_runtime_force_suspend(dev);\n}\n\nstatic int __maybe_unused sprd_i2c_resume_noirq(struct device *dev)\n{\n\tstruct sprd_i2c *i2c_dev = dev_get_drvdata(dev);\n\n\ti2c_mark_adapter_resumed(&i2c_dev->adap);\n\treturn pm_runtime_force_resume(dev);\n}\n\nstatic int __maybe_unused sprd_i2c_runtime_suspend(struct device *dev)\n{\n\tstruct sprd_i2c *i2c_dev = dev_get_drvdata(dev);\n\n\tclk_disable_unprepare(i2c_dev->clk);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused sprd_i2c_runtime_resume(struct device *dev)\n{\n\tstruct sprd_i2c *i2c_dev = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = clk_prepare_enable(i2c_dev->clk);\n\tif (ret)\n\t\treturn ret;\n\n\tsprd_i2c_enable(i2c_dev);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops sprd_i2c_pm_ops = {\n\tSET_RUNTIME_PM_OPS(sprd_i2c_runtime_suspend,\n\t\t\t   sprd_i2c_runtime_resume, NULL)\n\n\tSET_NOIRQ_SYSTEM_SLEEP_PM_OPS(sprd_i2c_suspend_noirq,\n\t\t\t\t      sprd_i2c_resume_noirq)\n};\n\nstatic const struct of_device_id sprd_i2c_of_match[] = {\n\t{ .compatible = \"sprd,sc9860-i2c\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, sprd_i2c_of_match);\n\nstatic struct platform_driver sprd_i2c_driver = {\n\t.probe = sprd_i2c_probe,\n\t.remove = sprd_i2c_remove,\n\t.driver = {\n\t\t   .name = \"sprd-i2c\",\n\t\t   .of_match_table = sprd_i2c_of_match,\n\t\t   .pm = &sprd_i2c_pm_ops,\n\t},\n};\n\nmodule_platform_driver(sprd_i2c_driver);\n\nMODULE_DESCRIPTION(\"Spreadtrum I2C master controller driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}