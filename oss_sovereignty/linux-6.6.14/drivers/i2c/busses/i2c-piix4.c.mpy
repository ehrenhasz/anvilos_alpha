{
  "module_name": "i2c-piix4.c",
  "hash_id": "dc2feb5906a3b3d4a60c484d77389c1bd2314acd3ed92ece83fcb98e3e3bfdfe",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-piix4.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/delay.h>\n#include <linux/stddef.h>\n#include <linux/ioport.h>\n#include <linux/i2c.h>\n#include <linux/slab.h>\n#include <linux/dmi.h>\n#include <linux/acpi.h>\n#include <linux/io.h>\n\n\n \n#define SMBHSTSTS\t(0 + piix4_smba)\n#define SMBHSLVSTS\t(1 + piix4_smba)\n#define SMBHSTCNT\t(2 + piix4_smba)\n#define SMBHSTCMD\t(3 + piix4_smba)\n#define SMBHSTADD\t(4 + piix4_smba)\n#define SMBHSTDAT0\t(5 + piix4_smba)\n#define SMBHSTDAT1\t(6 + piix4_smba)\n#define SMBBLKDAT\t(7 + piix4_smba)\n#define SMBSLVCNT\t(8 + piix4_smba)\n#define SMBSHDWCMD\t(9 + piix4_smba)\n#define SMBSLVEVT\t(0xA + piix4_smba)\n#define SMBSLVDAT\t(0xC + piix4_smba)\n\n \n#define SMBIOSIZE\t9\n\n \n#define SMBBA\t\t0x090\n#define SMBHSTCFG\t0x0D2\n#define SMBSLVC\t\t0x0D3\n#define SMBSHDW1\t0x0D4\n#define SMBSHDW2\t0x0D5\n#define SMBREV\t\t0x0D6\n\n \n#define MAX_TIMEOUT\t500\n#define  ENABLE_INT9\t0\n\n \n#define PIIX4_QUICK\t\t0x00\n#define PIIX4_BYTE\t\t0x04\n#define PIIX4_BYTE_DATA\t\t0x08\n#define PIIX4_WORD_DATA\t\t0x0C\n#define PIIX4_BLOCK_DATA\t0x14\n\n \n#define PIIX4_MAX_ADAPTERS\t4\n#define HUDSON2_MAIN_PORTS\t2  \n\n \n#define SB800_PIIX4_SMB_IDX\t\t0xcd6\n#define SB800_PIIX4_SMB_MAP_SIZE\t2\n\n#define KERNCZ_IMC_IDX\t\t\t0x3e\n#define KERNCZ_IMC_DATA\t\t\t0x3f\n\n \n#define SB800_PIIX4_PORT_IDX\t\t0x2c\n#define SB800_PIIX4_PORT_IDX_ALT\t0x2e\n#define SB800_PIIX4_PORT_IDX_SEL\t0x2f\n#define SB800_PIIX4_PORT_IDX_MASK\t0x06\n#define SB800_PIIX4_PORT_IDX_SHIFT\t1\n\n \n#define SB800_PIIX4_PORT_IDX_KERNCZ\t\t0x02\n#define SB800_PIIX4_PORT_IDX_MASK_KERNCZ\t0x18\n#define SB800_PIIX4_PORT_IDX_SHIFT_KERNCZ\t3\n\n#define SB800_PIIX4_FCH_PM_ADDR\t\t\t0xFED80300\n#define SB800_PIIX4_FCH_PM_SIZE\t\t\t8\n\n \n\n \nstatic int force;\nmodule_param (force, int, 0);\nMODULE_PARM_DESC(force, \"Forcibly enable the PIIX4. DANGEROUS!\");\n\n \nstatic int force_addr;\nmodule_param_hw(force_addr, int, ioport, 0);\nMODULE_PARM_DESC(force_addr,\n\t\t \"Forcibly enable the PIIX4 at the given address. \"\n\t\t \"EXTREMELY DANGEROUS!\");\n\nstatic int srvrworks_csb5_delay;\nstatic struct pci_driver piix4_driver;\n\nstatic const struct dmi_system_id piix4_dmi_blacklist[] = {\n\t{\n\t\t.ident = \"Sapphire AM2RD790\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"SAPPHIRE Inc.\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"PC-AM2RD790\"),\n\t\t},\n\t},\n\t{\n\t\t.ident = \"DFI Lanparty UT 790FX\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"DFI Inc.\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"LP UT 790FX\"),\n\t\t},\n\t},\n\t{ }\n};\n\n \nstatic const struct dmi_system_id piix4_dmi_ibm[] = {\n\t{\n\t\t.ident = \"IBM\",\n\t\t.matches = { DMI_MATCH(DMI_SYS_VENDOR, \"IBM\"), },\n\t},\n\t{ },\n};\n\n \nstatic u8 piix4_port_sel_sb800;\nstatic u8 piix4_port_mask_sb800;\nstatic u8 piix4_port_shift_sb800;\nstatic const char *piix4_main_port_names_sb800[PIIX4_MAX_ADAPTERS] = {\n\t\" port 0\", \" port 2\", \" port 3\", \" port 4\"\n};\nstatic const char *piix4_aux_port_name_sb800 = \" port 1\";\n\nstruct sb800_mmio_cfg {\n\tvoid __iomem *addr;\n\tbool use_mmio;\n};\n\nstruct i2c_piix4_adapdata {\n\tunsigned short smba;\n\n\t \n\tbool sb800_main;\n\tbool notify_imc;\n\tu8 port;\t\t \n\tstruct sb800_mmio_cfg mmio_cfg;\n};\n\nstatic int piix4_sb800_region_request(struct device *dev,\n\t\t\t\t      struct sb800_mmio_cfg *mmio_cfg)\n{\n\tif (mmio_cfg->use_mmio) {\n\t\tvoid __iomem *addr;\n\n\t\tif (!request_mem_region_muxed(SB800_PIIX4_FCH_PM_ADDR,\n\t\t\t\t\t      SB800_PIIX4_FCH_PM_SIZE,\n\t\t\t\t\t      \"sb800_piix4_smb\")) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"SMBus base address memory region 0x%x already in use.\\n\",\n\t\t\t\tSB800_PIIX4_FCH_PM_ADDR);\n\t\t\treturn -EBUSY;\n\t\t}\n\n\t\taddr = ioremap(SB800_PIIX4_FCH_PM_ADDR,\n\t\t\t       SB800_PIIX4_FCH_PM_SIZE);\n\t\tif (!addr) {\n\t\t\trelease_mem_region(SB800_PIIX4_FCH_PM_ADDR,\n\t\t\t\t\t   SB800_PIIX4_FCH_PM_SIZE);\n\t\t\tdev_err(dev, \"SMBus base address mapping failed.\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tmmio_cfg->addr = addr;\n\n\t\treturn 0;\n\t}\n\n\tif (!request_muxed_region(SB800_PIIX4_SMB_IDX, SB800_PIIX4_SMB_MAP_SIZE,\n\t\t\t\t  \"sb800_piix4_smb\")) {\n\t\tdev_err(dev,\n\t\t\t\"SMBus base address index region 0x%x already in use.\\n\",\n\t\t\tSB800_PIIX4_SMB_IDX);\n\t\treturn -EBUSY;\n\t}\n\n\treturn 0;\n}\n\nstatic void piix4_sb800_region_release(struct device *dev,\n\t\t\t\t       struct sb800_mmio_cfg *mmio_cfg)\n{\n\tif (mmio_cfg->use_mmio) {\n\t\tiounmap(mmio_cfg->addr);\n\t\trelease_mem_region(SB800_PIIX4_FCH_PM_ADDR,\n\t\t\t\t   SB800_PIIX4_FCH_PM_SIZE);\n\t\treturn;\n\t}\n\n\trelease_region(SB800_PIIX4_SMB_IDX, SB800_PIIX4_SMB_MAP_SIZE);\n}\n\nstatic bool piix4_sb800_use_mmio(struct pci_dev *PIIX4_dev)\n{\n\t \n\treturn (PIIX4_dev->vendor == PCI_VENDOR_ID_AMD &&\n\t\tPIIX4_dev->device == PCI_DEVICE_ID_AMD_KERNCZ_SMBUS &&\n\t\tPIIX4_dev->revision >= 0x51);\n}\n\nstatic int piix4_setup(struct pci_dev *PIIX4_dev,\n\t\t       const struct pci_device_id *id)\n{\n\tunsigned char temp;\n\tunsigned short piix4_smba;\n\n\tif ((PIIX4_dev->vendor == PCI_VENDOR_ID_SERVERWORKS) &&\n\t    (PIIX4_dev->device == PCI_DEVICE_ID_SERVERWORKS_CSB5))\n\t\tsrvrworks_csb5_delay = 1;\n\n\t \n\tif (dmi_check_system(piix4_dmi_blacklist)) {\n\t\tdev_err(&PIIX4_dev->dev,\n\t\t\t\"Accessing the SMBus on this system is unsafe!\\n\");\n\t\treturn -EPERM;\n\t}\n\n\t \n\tif (dmi_check_system(piix4_dmi_ibm) &&\n\t\t\tPIIX4_dev->vendor == PCI_VENDOR_ID_INTEL) {\n\t\tdev_err(&PIIX4_dev->dev, \"IBM system detected; this module \"\n\t\t\t\"may corrupt your serial eeprom! Refusing to load \"\n\t\t\t\"module!\\n\");\n\t\treturn -EPERM;\n\t}\n\n\t \n\tif (force_addr) {\n\t\tpiix4_smba = force_addr & 0xfff0;\n\t\tforce = 0;\n\t} else {\n\t\tpci_read_config_word(PIIX4_dev, SMBBA, &piix4_smba);\n\t\tpiix4_smba &= 0xfff0;\n\t\tif(piix4_smba == 0) {\n\t\t\tdev_err(&PIIX4_dev->dev, \"SMBus base address \"\n\t\t\t\t\"uninitialized - upgrade BIOS or use \"\n\t\t\t\t\"force_addr=0xaddr\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\tif (acpi_check_region(piix4_smba, SMBIOSIZE, piix4_driver.name))\n\t\treturn -ENODEV;\n\n\tif (!request_region(piix4_smba, SMBIOSIZE, piix4_driver.name)) {\n\t\tdev_err(&PIIX4_dev->dev, \"SMBus region 0x%x already in use!\\n\",\n\t\t\tpiix4_smba);\n\t\treturn -EBUSY;\n\t}\n\n\tpci_read_config_byte(PIIX4_dev, SMBHSTCFG, &temp);\n\n\t \n\tif (force_addr) {\n\t\tpci_write_config_byte(PIIX4_dev, SMBHSTCFG, temp & 0xfe);\n\t\tpci_write_config_word(PIIX4_dev, SMBBA, piix4_smba);\n\t\tpci_write_config_byte(PIIX4_dev, SMBHSTCFG, temp | 0x01);\n\t\tdev_info(&PIIX4_dev->dev, \"WARNING: SMBus interface set to \"\n\t\t\t\"new address %04x!\\n\", piix4_smba);\n\t} else if ((temp & 1) == 0) {\n\t\tif (force) {\n\t\t\t \n\t\t\tpci_write_config_byte(PIIX4_dev, SMBHSTCFG,\n\t\t\t\t\t      temp | 1);\n\t\t\tdev_notice(&PIIX4_dev->dev,\n\t\t\t\t   \"WARNING: SMBus interface has been FORCEFULLY ENABLED!\\n\");\n\t\t} else {\n\t\t\tdev_err(&PIIX4_dev->dev,\n\t\t\t\t\"SMBus Host Controller not enabled!\\n\");\n\t\t\trelease_region(piix4_smba, SMBIOSIZE);\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\tif (((temp & 0x0E) == 8) || ((temp & 0x0E) == 2))\n\t\tdev_dbg(&PIIX4_dev->dev, \"Using IRQ for SMBus\\n\");\n\telse if ((temp & 0x0E) == 0)\n\t\tdev_dbg(&PIIX4_dev->dev, \"Using SMI# for SMBus\\n\");\n\telse\n\t\tdev_err(&PIIX4_dev->dev, \"Illegal Interrupt configuration \"\n\t\t\t\"(or code out of date)!\\n\");\n\n\tpci_read_config_byte(PIIX4_dev, SMBREV, &temp);\n\tdev_info(&PIIX4_dev->dev,\n\t\t \"SMBus Host Controller at 0x%x, revision %d\\n\",\n\t\t piix4_smba, temp);\n\n\treturn piix4_smba;\n}\n\nstatic int piix4_setup_sb800_smba(struct pci_dev *PIIX4_dev,\n\t\t\t\t  u8 smb_en,\n\t\t\t\t  u8 aux,\n\t\t\t\t  u8 *smb_en_status,\n\t\t\t\t  unsigned short *piix4_smba)\n{\n\tstruct sb800_mmio_cfg mmio_cfg;\n\tu8 smba_en_lo;\n\tu8 smba_en_hi;\n\tint retval;\n\n\tmmio_cfg.use_mmio = piix4_sb800_use_mmio(PIIX4_dev);\n\tretval = piix4_sb800_region_request(&PIIX4_dev->dev, &mmio_cfg);\n\tif (retval)\n\t\treturn retval;\n\n\tif (mmio_cfg.use_mmio) {\n\t\tsmba_en_lo = ioread8(mmio_cfg.addr);\n\t\tsmba_en_hi = ioread8(mmio_cfg.addr + 1);\n\t} else {\n\t\toutb_p(smb_en, SB800_PIIX4_SMB_IDX);\n\t\tsmba_en_lo = inb_p(SB800_PIIX4_SMB_IDX + 1);\n\t\toutb_p(smb_en + 1, SB800_PIIX4_SMB_IDX);\n\t\tsmba_en_hi = inb_p(SB800_PIIX4_SMB_IDX + 1);\n\t}\n\n\tpiix4_sb800_region_release(&PIIX4_dev->dev, &mmio_cfg);\n\n\tif (!smb_en) {\n\t\t*smb_en_status = smba_en_lo & 0x10;\n\t\t*piix4_smba = smba_en_hi << 8;\n\t\tif (aux)\n\t\t\t*piix4_smba |= 0x20;\n\t} else {\n\t\t*smb_en_status = smba_en_lo & 0x01;\n\t\t*piix4_smba = ((smba_en_hi << 8) | smba_en_lo) & 0xffe0;\n\t}\n\n\tif (!*smb_en_status) {\n\t\tdev_err(&PIIX4_dev->dev,\n\t\t\t\"SMBus Host Controller not enabled!\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic int piix4_setup_sb800(struct pci_dev *PIIX4_dev,\n\t\t\t     const struct pci_device_id *id, u8 aux)\n{\n\tunsigned short piix4_smba;\n\tu8 smb_en, smb_en_status, port_sel;\n\tu8 i2ccfg, i2ccfg_offset = 0x10;\n\tstruct sb800_mmio_cfg mmio_cfg;\n\tint retval;\n\n\t \n\tif (force || force_addr) {\n\t\tdev_err(&PIIX4_dev->dev, \"SMBus does not support \"\n\t\t\t\"forcing address!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif ((PIIX4_dev->vendor == PCI_VENDOR_ID_AMD &&\n\t     PIIX4_dev->device == PCI_DEVICE_ID_AMD_HUDSON2_SMBUS &&\n\t     PIIX4_dev->revision >= 0x41) ||\n\t    (PIIX4_dev->vendor == PCI_VENDOR_ID_AMD &&\n\t     PIIX4_dev->device == PCI_DEVICE_ID_AMD_KERNCZ_SMBUS &&\n\t     PIIX4_dev->revision >= 0x49) ||\n\t    (PIIX4_dev->vendor == PCI_VENDOR_ID_HYGON &&\n\t     PIIX4_dev->device == PCI_DEVICE_ID_AMD_KERNCZ_SMBUS))\n\t\tsmb_en = 0x00;\n\telse\n\t\tsmb_en = (aux) ? 0x28 : 0x2c;\n\n\tretval = piix4_setup_sb800_smba(PIIX4_dev, smb_en, aux, &smb_en_status,\n\t\t\t\t\t&piix4_smba);\n\n\tif (retval)\n\t\treturn retval;\n\n\tif (acpi_check_region(piix4_smba, SMBIOSIZE, piix4_driver.name))\n\t\treturn -ENODEV;\n\n\tif (!request_region(piix4_smba, SMBIOSIZE, piix4_driver.name)) {\n\t\tdev_err(&PIIX4_dev->dev, \"SMBus region 0x%x already in use!\\n\",\n\t\t\tpiix4_smba);\n\t\treturn -EBUSY;\n\t}\n\n\t \n\tif (aux) {\n\t\tdev_info(&PIIX4_dev->dev,\n\t\t\t \"Auxiliary SMBus Host Controller at 0x%x\\n\",\n\t\t\t piix4_smba);\n\t\treturn piix4_smba;\n\t}\n\n\t \n\tif (!request_region(piix4_smba + i2ccfg_offset, 1, \"i2ccfg\")) {\n\t\tdev_err(&PIIX4_dev->dev, \"SMBus I2C bus config region \"\n\t\t\t\"0x%x already in use!\\n\", piix4_smba + i2ccfg_offset);\n\t\trelease_region(piix4_smba, SMBIOSIZE);\n\t\treturn -EBUSY;\n\t}\n\ti2ccfg = inb_p(piix4_smba + i2ccfg_offset);\n\trelease_region(piix4_smba + i2ccfg_offset, 1);\n\n\tif (i2ccfg & 1)\n\t\tdev_dbg(&PIIX4_dev->dev, \"Using IRQ for SMBus\\n\");\n\telse\n\t\tdev_dbg(&PIIX4_dev->dev, \"Using SMI# for SMBus\\n\");\n\n\tdev_info(&PIIX4_dev->dev,\n\t\t \"SMBus Host Controller at 0x%x, revision %d\\n\",\n\t\t piix4_smba, i2ccfg >> 4);\n\n\t \n\tif (PIIX4_dev->vendor == PCI_VENDOR_ID_AMD ||\n\t    PIIX4_dev->vendor == PCI_VENDOR_ID_HYGON) {\n\t\tif (PIIX4_dev->device == PCI_DEVICE_ID_AMD_KERNCZ_SMBUS ||\n\t\t    (PIIX4_dev->device == PCI_DEVICE_ID_AMD_HUDSON2_SMBUS &&\n\t\t     PIIX4_dev->revision >= 0x1F)) {\n\t\t\tpiix4_port_sel_sb800 = SB800_PIIX4_PORT_IDX_KERNCZ;\n\t\t\tpiix4_port_mask_sb800 = SB800_PIIX4_PORT_IDX_MASK_KERNCZ;\n\t\t\tpiix4_port_shift_sb800 = SB800_PIIX4_PORT_IDX_SHIFT_KERNCZ;\n\t\t} else {\n\t\t\tpiix4_port_sel_sb800 = SB800_PIIX4_PORT_IDX_ALT;\n\t\t\tpiix4_port_mask_sb800 = SB800_PIIX4_PORT_IDX_MASK;\n\t\t\tpiix4_port_shift_sb800 = SB800_PIIX4_PORT_IDX_SHIFT;\n\t\t}\n\t} else {\n\t\tmmio_cfg.use_mmio = piix4_sb800_use_mmio(PIIX4_dev);\n\t\tretval = piix4_sb800_region_request(&PIIX4_dev->dev, &mmio_cfg);\n\t\tif (retval) {\n\t\t\trelease_region(piix4_smba, SMBIOSIZE);\n\t\t\treturn retval;\n\t\t}\n\n\t\toutb_p(SB800_PIIX4_PORT_IDX_SEL, SB800_PIIX4_SMB_IDX);\n\t\tport_sel = inb_p(SB800_PIIX4_SMB_IDX + 1);\n\t\tpiix4_port_sel_sb800 = (port_sel & 0x01) ?\n\t\t\t\t       SB800_PIIX4_PORT_IDX_ALT :\n\t\t\t\t       SB800_PIIX4_PORT_IDX;\n\t\tpiix4_port_mask_sb800 = SB800_PIIX4_PORT_IDX_MASK;\n\t\tpiix4_port_shift_sb800 = SB800_PIIX4_PORT_IDX_SHIFT;\n\t\tpiix4_sb800_region_release(&PIIX4_dev->dev, &mmio_cfg);\n\t}\n\n\tdev_info(&PIIX4_dev->dev,\n\t\t \"Using register 0x%02x for SMBus port selection\\n\",\n\t\t (unsigned int)piix4_port_sel_sb800);\n\n\treturn piix4_smba;\n}\n\nstatic int piix4_setup_aux(struct pci_dev *PIIX4_dev,\n\t\t\t   const struct pci_device_id *id,\n\t\t\t   unsigned short base_reg_addr)\n{\n\t \n\n\tunsigned short piix4_smba;\n\n\t \n\tpci_read_config_word(PIIX4_dev, base_reg_addr, &piix4_smba);\n\tif ((piix4_smba & 1) == 0) {\n\t\tdev_dbg(&PIIX4_dev->dev,\n\t\t\t\"Auxiliary SMBus controller not enabled\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tpiix4_smba &= 0xfff0;\n\tif (piix4_smba == 0) {\n\t\tdev_dbg(&PIIX4_dev->dev,\n\t\t\t\"Auxiliary SMBus base address uninitialized\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (acpi_check_region(piix4_smba, SMBIOSIZE, piix4_driver.name))\n\t\treturn -ENODEV;\n\n\tif (!request_region(piix4_smba, SMBIOSIZE, piix4_driver.name)) {\n\t\tdev_err(&PIIX4_dev->dev, \"Auxiliary SMBus region 0x%x \"\n\t\t\t\"already in use!\\n\", piix4_smba);\n\t\treturn -EBUSY;\n\t}\n\n\tdev_info(&PIIX4_dev->dev,\n\t\t \"Auxiliary SMBus Host Controller at 0x%x\\n\",\n\t\t piix4_smba);\n\n\treturn piix4_smba;\n}\n\nstatic int piix4_transaction(struct i2c_adapter *piix4_adapter)\n{\n\tstruct i2c_piix4_adapdata *adapdata = i2c_get_adapdata(piix4_adapter);\n\tunsigned short piix4_smba = adapdata->smba;\n\tint temp;\n\tint result = 0;\n\tint timeout = 0;\n\n\tdev_dbg(&piix4_adapter->dev, \"Transaction (pre): CNT=%02x, CMD=%02x, \"\n\t\t\"ADD=%02x, DAT0=%02x, DAT1=%02x\\n\", inb_p(SMBHSTCNT),\n\t\tinb_p(SMBHSTCMD), inb_p(SMBHSTADD), inb_p(SMBHSTDAT0),\n\t\tinb_p(SMBHSTDAT1));\n\n\t \n\tif ((temp = inb_p(SMBHSTSTS)) != 0x00) {\n\t\tdev_dbg(&piix4_adapter->dev, \"SMBus busy (%02x). \"\n\t\t\t\"Resetting...\\n\", temp);\n\t\toutb_p(temp, SMBHSTSTS);\n\t\tif ((temp = inb_p(SMBHSTSTS)) != 0x00) {\n\t\t\tdev_err(&piix4_adapter->dev, \"Failed! (%02x)\\n\", temp);\n\t\t\treturn -EBUSY;\n\t\t} else {\n\t\t\tdev_dbg(&piix4_adapter->dev, \"Successful!\\n\");\n\t\t}\n\t}\n\n\t \n\toutb_p(inb(SMBHSTCNT) | 0x040, SMBHSTCNT);\n\n\t \n\tif (srvrworks_csb5_delay)  \n\t\tusleep_range(2000, 2100);\n\telse\n\t\tusleep_range(250, 500);\n\n\twhile ((++timeout < MAX_TIMEOUT) &&\n\t       ((temp = inb_p(SMBHSTSTS)) & 0x01))\n\t\tusleep_range(250, 500);\n\n\t \n\tif (timeout == MAX_TIMEOUT) {\n\t\tdev_err(&piix4_adapter->dev, \"SMBus Timeout!\\n\");\n\t\tresult = -ETIMEDOUT;\n\t}\n\n\tif (temp & 0x10) {\n\t\tresult = -EIO;\n\t\tdev_err(&piix4_adapter->dev, \"Error: Failed bus transaction\\n\");\n\t}\n\n\tif (temp & 0x08) {\n\t\tresult = -EIO;\n\t\tdev_dbg(&piix4_adapter->dev, \"Bus collision! SMBus may be \"\n\t\t\t\"locked until next hard reset. (sorry!)\\n\");\n\t\t \n\t}\n\n\tif (temp & 0x04) {\n\t\tresult = -ENXIO;\n\t\tdev_dbg(&piix4_adapter->dev, \"Error: no response!\\n\");\n\t}\n\n\tif (inb_p(SMBHSTSTS) != 0x00)\n\t\toutb_p(inb(SMBHSTSTS), SMBHSTSTS);\n\n\tif ((temp = inb_p(SMBHSTSTS)) != 0x00) {\n\t\tdev_err(&piix4_adapter->dev, \"Failed reset at end of \"\n\t\t\t\"transaction (%02x)\\n\", temp);\n\t}\n\tdev_dbg(&piix4_adapter->dev, \"Transaction (post): CNT=%02x, CMD=%02x, \"\n\t\t\"ADD=%02x, DAT0=%02x, DAT1=%02x\\n\", inb_p(SMBHSTCNT),\n\t\tinb_p(SMBHSTCMD), inb_p(SMBHSTADD), inb_p(SMBHSTDAT0),\n\t\tinb_p(SMBHSTDAT1));\n\treturn result;\n}\n\n \nstatic s32 piix4_access(struct i2c_adapter * adap, u16 addr,\n\t\t unsigned short flags, char read_write,\n\t\t u8 command, int size, union i2c_smbus_data * data)\n{\n\tstruct i2c_piix4_adapdata *adapdata = i2c_get_adapdata(adap);\n\tunsigned short piix4_smba = adapdata->smba;\n\tint i, len;\n\tint status;\n\n\tswitch (size) {\n\tcase I2C_SMBUS_QUICK:\n\t\toutb_p((addr << 1) | read_write,\n\t\t       SMBHSTADD);\n\t\tsize = PIIX4_QUICK;\n\t\tbreak;\n\tcase I2C_SMBUS_BYTE:\n\t\toutb_p((addr << 1) | read_write,\n\t\t       SMBHSTADD);\n\t\tif (read_write == I2C_SMBUS_WRITE)\n\t\t\toutb_p(command, SMBHSTCMD);\n\t\tsize = PIIX4_BYTE;\n\t\tbreak;\n\tcase I2C_SMBUS_BYTE_DATA:\n\t\toutb_p((addr << 1) | read_write,\n\t\t       SMBHSTADD);\n\t\toutb_p(command, SMBHSTCMD);\n\t\tif (read_write == I2C_SMBUS_WRITE)\n\t\t\toutb_p(data->byte, SMBHSTDAT0);\n\t\tsize = PIIX4_BYTE_DATA;\n\t\tbreak;\n\tcase I2C_SMBUS_WORD_DATA:\n\t\toutb_p((addr << 1) | read_write,\n\t\t       SMBHSTADD);\n\t\toutb_p(command, SMBHSTCMD);\n\t\tif (read_write == I2C_SMBUS_WRITE) {\n\t\t\toutb_p(data->word & 0xff, SMBHSTDAT0);\n\t\t\toutb_p((data->word & 0xff00) >> 8, SMBHSTDAT1);\n\t\t}\n\t\tsize = PIIX4_WORD_DATA;\n\t\tbreak;\n\tcase I2C_SMBUS_BLOCK_DATA:\n\t\toutb_p((addr << 1) | read_write,\n\t\t       SMBHSTADD);\n\t\toutb_p(command, SMBHSTCMD);\n\t\tif (read_write == I2C_SMBUS_WRITE) {\n\t\t\tlen = data->block[0];\n\t\t\tif (len == 0 || len > I2C_SMBUS_BLOCK_MAX)\n\t\t\t\treturn -EINVAL;\n\t\t\toutb_p(len, SMBHSTDAT0);\n\t\t\tinb_p(SMBHSTCNT);\t \n\t\t\tfor (i = 1; i <= len; i++)\n\t\t\t\toutb_p(data->block[i], SMBBLKDAT);\n\t\t}\n\t\tsize = PIIX4_BLOCK_DATA;\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(&adap->dev, \"Unsupported transaction %d\\n\", size);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\toutb_p((size & 0x1C) + (ENABLE_INT9 & 1), SMBHSTCNT);\n\n\tstatus = piix4_transaction(adap);\n\tif (status)\n\t\treturn status;\n\n\tif ((read_write == I2C_SMBUS_WRITE) || (size == PIIX4_QUICK))\n\t\treturn 0;\n\n\n\tswitch (size) {\n\tcase PIIX4_BYTE:\n\tcase PIIX4_BYTE_DATA:\n\t\tdata->byte = inb_p(SMBHSTDAT0);\n\t\tbreak;\n\tcase PIIX4_WORD_DATA:\n\t\tdata->word = inb_p(SMBHSTDAT0) + (inb_p(SMBHSTDAT1) << 8);\n\t\tbreak;\n\tcase PIIX4_BLOCK_DATA:\n\t\tdata->block[0] = inb_p(SMBHSTDAT0);\n\t\tif (data->block[0] == 0 || data->block[0] > I2C_SMBUS_BLOCK_MAX)\n\t\t\treturn -EPROTO;\n\t\tinb_p(SMBHSTCNT);\t \n\t\tfor (i = 1; i <= data->block[0]; i++)\n\t\t\tdata->block[i] = inb_p(SMBBLKDAT);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic uint8_t piix4_imc_read(uint8_t idx)\n{\n\toutb_p(idx, KERNCZ_IMC_IDX);\n\treturn inb_p(KERNCZ_IMC_DATA);\n}\n\nstatic void piix4_imc_write(uint8_t idx, uint8_t value)\n{\n\toutb_p(idx, KERNCZ_IMC_IDX);\n\toutb_p(value, KERNCZ_IMC_DATA);\n}\n\nstatic int piix4_imc_sleep(void)\n{\n\tint timeout = MAX_TIMEOUT;\n\n\tif (!request_muxed_region(KERNCZ_IMC_IDX, 2, \"smbus_kerncz_imc\"))\n\t\treturn -EBUSY;\n\n\t \n\tpiix4_imc_write(0x82, 0x00);\n\t \n\tpiix4_imc_write(0x83, 0xB4);\n\t \n\tpiix4_imc_write(0x80, 0x96);\n\n\twhile (timeout--) {\n\t\tif (piix4_imc_read(0x82) == 0xfa) {\n\t\t\trelease_region(KERNCZ_IMC_IDX, 2);\n\t\t\treturn 0;\n\t\t}\n\t\tusleep_range(1000, 2000);\n\t}\n\n\trelease_region(KERNCZ_IMC_IDX, 2);\n\treturn -ETIMEDOUT;\n}\n\nstatic void piix4_imc_wakeup(void)\n{\n\tint timeout = MAX_TIMEOUT;\n\n\tif (!request_muxed_region(KERNCZ_IMC_IDX, 2, \"smbus_kerncz_imc\"))\n\t\treturn;\n\n\t \n\tpiix4_imc_write(0x82, 0x00);\n\t \n\tpiix4_imc_write(0x83, 0xB5);\n\t \n\tpiix4_imc_write(0x80, 0x96);\n\n\twhile (timeout--) {\n\t\tif (piix4_imc_read(0x82) == 0xfa)\n\t\t\tbreak;\n\t\tusleep_range(1000, 2000);\n\t}\n\n\trelease_region(KERNCZ_IMC_IDX, 2);\n}\n\nstatic int piix4_sb800_port_sel(u8 port, struct sb800_mmio_cfg *mmio_cfg)\n{\n\tu8 smba_en_lo, val;\n\n\tif (mmio_cfg->use_mmio) {\n\t\tsmba_en_lo = ioread8(mmio_cfg->addr + piix4_port_sel_sb800);\n\t\tval = (smba_en_lo & ~piix4_port_mask_sb800) | port;\n\t\tif (smba_en_lo != val)\n\t\t\tiowrite8(val, mmio_cfg->addr + piix4_port_sel_sb800);\n\n\t\treturn (smba_en_lo & piix4_port_mask_sb800);\n\t}\n\n\toutb_p(piix4_port_sel_sb800, SB800_PIIX4_SMB_IDX);\n\tsmba_en_lo = inb_p(SB800_PIIX4_SMB_IDX + 1);\n\n\tval = (smba_en_lo & ~piix4_port_mask_sb800) | port;\n\tif (smba_en_lo != val)\n\t\toutb_p(val, SB800_PIIX4_SMB_IDX + 1);\n\n\treturn (smba_en_lo & piix4_port_mask_sb800);\n}\n\n \nstatic s32 piix4_access_sb800(struct i2c_adapter *adap, u16 addr,\n\t\t unsigned short flags, char read_write,\n\t\t u8 command, int size, union i2c_smbus_data *data)\n{\n\tstruct i2c_piix4_adapdata *adapdata = i2c_get_adapdata(adap);\n\tunsigned short piix4_smba = adapdata->smba;\n\tint retries = MAX_TIMEOUT;\n\tint smbslvcnt;\n\tu8 prev_port;\n\tint retval;\n\n\tretval = piix4_sb800_region_request(&adap->dev, &adapdata->mmio_cfg);\n\tif (retval)\n\t\treturn retval;\n\n\t \n\tsmbslvcnt  = inb_p(SMBSLVCNT);\n\tdo {\n\t\toutb_p(smbslvcnt | 0x10, SMBSLVCNT);\n\n\t\t \n\t\tsmbslvcnt  = inb_p(SMBSLVCNT);\n\t\tif (smbslvcnt & 0x10)\n\t\t\tbreak;\n\n\t\tusleep_range(1000, 2000);\n\t} while (--retries);\n\t \n\tif (!retries) {\n\t\tretval = -EBUSY;\n\t\tgoto release;\n\t}\n\n\t \n\tif ((size == I2C_SMBUS_BLOCK_DATA) && adapdata->notify_imc) {\n\t\tint ret;\n\n\t\tret = piix4_imc_sleep();\n\t\tswitch (ret) {\n\t\tcase -EBUSY:\n\t\t\tdev_warn(&adap->dev,\n\t\t\t\t \"IMC base address index region 0x%x already in use.\\n\",\n\t\t\t\t KERNCZ_IMC_IDX);\n\t\t\tbreak;\n\t\tcase -ETIMEDOUT:\n\t\t\tdev_warn(&adap->dev,\n\t\t\t\t \"Failed to communicate with the IMC.\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (ret) {\n\t\t\tdev_warn(&adap->dev,\n\t\t\t\t \"Continuing without IMC notification.\\n\");\n\t\t\tadapdata->notify_imc = false;\n\t\t}\n\t}\n\n\tprev_port = piix4_sb800_port_sel(adapdata->port, &adapdata->mmio_cfg);\n\n\tretval = piix4_access(adap, addr, flags, read_write,\n\t\t\t      command, size, data);\n\n\tpiix4_sb800_port_sel(prev_port, &adapdata->mmio_cfg);\n\n\t \n\toutb_p(smbslvcnt | 0x20, SMBSLVCNT);\n\n\tif ((size == I2C_SMBUS_BLOCK_DATA) && adapdata->notify_imc)\n\t\tpiix4_imc_wakeup();\n\nrelease:\n\tpiix4_sb800_region_release(&adap->dev, &adapdata->mmio_cfg);\n\treturn retval;\n}\n\nstatic u32 piix4_func(struct i2c_adapter *adapter)\n{\n\treturn I2C_FUNC_SMBUS_QUICK | I2C_FUNC_SMBUS_BYTE |\n\t    I2C_FUNC_SMBUS_BYTE_DATA | I2C_FUNC_SMBUS_WORD_DATA |\n\t    I2C_FUNC_SMBUS_BLOCK_DATA;\n}\n\nstatic const struct i2c_algorithm smbus_algorithm = {\n\t.smbus_xfer\t= piix4_access,\n\t.functionality\t= piix4_func,\n};\n\nstatic const struct i2c_algorithm piix4_smbus_algorithm_sb800 = {\n\t.smbus_xfer\t= piix4_access_sb800,\n\t.functionality\t= piix4_func,\n};\n\nstatic const struct pci_device_id piix4_ids[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82371AB_3) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82443MX_3) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_EFAR, PCI_DEVICE_ID_EFAR_SLC90E66_3) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_IXP200_SMBUS) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_IXP300_SMBUS) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_IXP400_SMBUS) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_SBX00_SMBUS) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_HUDSON2_SMBUS) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_KERNCZ_SMBUS) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_HYGON, PCI_DEVICE_ID_AMD_KERNCZ_SMBUS) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_SERVERWORKS,\n\t\t     PCI_DEVICE_ID_SERVERWORKS_OSB4) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_SERVERWORKS,\n\t\t     PCI_DEVICE_ID_SERVERWORKS_CSB5) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_SERVERWORKS,\n\t\t     PCI_DEVICE_ID_SERVERWORKS_CSB6) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_SERVERWORKS,\n\t\t     PCI_DEVICE_ID_SERVERWORKS_HT1000SB) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_SERVERWORKS,\n\t\t     PCI_DEVICE_ID_SERVERWORKS_HT1100LD) },\n\t{ 0, }\n};\n\nMODULE_DEVICE_TABLE (pci, piix4_ids);\n\nstatic struct i2c_adapter *piix4_main_adapters[PIIX4_MAX_ADAPTERS];\nstatic struct i2c_adapter *piix4_aux_adapter;\nstatic int piix4_adapter_count;\n\nstatic int piix4_add_adapter(struct pci_dev *dev, unsigned short smba,\n\t\t\t     bool sb800_main, u8 port, bool notify_imc,\n\t\t\t     u8 hw_port_nr, const char *name,\n\t\t\t     struct i2c_adapter **padap)\n{\n\tstruct i2c_adapter *adap;\n\tstruct i2c_piix4_adapdata *adapdata;\n\tint retval;\n\n\tadap = kzalloc(sizeof(*adap), GFP_KERNEL);\n\tif (adap == NULL) {\n\t\trelease_region(smba, SMBIOSIZE);\n\t\treturn -ENOMEM;\n\t}\n\n\tadap->owner = THIS_MODULE;\n\tadap->class = I2C_CLASS_HWMON | I2C_CLASS_SPD;\n\tadap->algo = sb800_main ? &piix4_smbus_algorithm_sb800\n\t\t\t\t: &smbus_algorithm;\n\n\tadapdata = kzalloc(sizeof(*adapdata), GFP_KERNEL);\n\tif (adapdata == NULL) {\n\t\tkfree(adap);\n\t\trelease_region(smba, SMBIOSIZE);\n\t\treturn -ENOMEM;\n\t}\n\n\tadapdata->mmio_cfg.use_mmio = piix4_sb800_use_mmio(dev);\n\tadapdata->smba = smba;\n\tadapdata->sb800_main = sb800_main;\n\tadapdata->port = port << piix4_port_shift_sb800;\n\tadapdata->notify_imc = notify_imc;\n\n\t \n\tadap->dev.parent = &dev->dev;\n\n\tif (has_acpi_companion(&dev->dev)) {\n\t\tacpi_preset_companion(&adap->dev,\n\t\t\t\t      ACPI_COMPANION(&dev->dev),\n\t\t\t\t      hw_port_nr);\n\t}\n\n\tsnprintf(adap->name, sizeof(adap->name),\n\t\t\"SMBus PIIX4 adapter%s at %04x\", name, smba);\n\n\ti2c_set_adapdata(adap, adapdata);\n\n\tretval = i2c_add_adapter(adap);\n\tif (retval) {\n\t\tkfree(adapdata);\n\t\tkfree(adap);\n\t\trelease_region(smba, SMBIOSIZE);\n\t\treturn retval;\n\t}\n\n\t*padap = adap;\n\treturn 0;\n}\n\nstatic int piix4_add_adapters_sb800(struct pci_dev *dev, unsigned short smba,\n\t\t\t\t    bool notify_imc)\n{\n\tstruct i2c_piix4_adapdata *adapdata;\n\tint port;\n\tint retval;\n\n\tif (dev->device == PCI_DEVICE_ID_AMD_KERNCZ_SMBUS ||\n\t    (dev->device == PCI_DEVICE_ID_AMD_HUDSON2_SMBUS &&\n\t     dev->revision >= 0x1F)) {\n\t\tpiix4_adapter_count = HUDSON2_MAIN_PORTS;\n\t} else {\n\t\tpiix4_adapter_count = PIIX4_MAX_ADAPTERS;\n\t}\n\n\tfor (port = 0; port < piix4_adapter_count; port++) {\n\t\tu8 hw_port_nr = port == 0 ? 0 : port + 1;\n\n\t\tretval = piix4_add_adapter(dev, smba, true, port, notify_imc,\n\t\t\t\t\t   hw_port_nr,\n\t\t\t\t\t   piix4_main_port_names_sb800[port],\n\t\t\t\t\t   &piix4_main_adapters[port]);\n\t\tif (retval < 0)\n\t\t\tgoto error;\n\t}\n\n\treturn retval;\n\nerror:\n\tdev_err(&dev->dev,\n\t\t\"Error setting up SB800 adapters. Unregistering!\\n\");\n\twhile (--port >= 0) {\n\t\tadapdata = i2c_get_adapdata(piix4_main_adapters[port]);\n\t\tif (adapdata->smba) {\n\t\t\ti2c_del_adapter(piix4_main_adapters[port]);\n\t\t\tkfree(adapdata);\n\t\t\tkfree(piix4_main_adapters[port]);\n\t\t\tpiix4_main_adapters[port] = NULL;\n\t\t}\n\t}\n\n\treturn retval;\n}\n\nstatic int piix4_probe(struct pci_dev *dev, const struct pci_device_id *id)\n{\n\tint retval;\n\tbool is_sb800 = false;\n\n\tif ((dev->vendor == PCI_VENDOR_ID_ATI &&\n\t     dev->device == PCI_DEVICE_ID_ATI_SBX00_SMBUS &&\n\t     dev->revision >= 0x40) ||\n\t    dev->vendor == PCI_VENDOR_ID_AMD ||\n\t    dev->vendor == PCI_VENDOR_ID_HYGON) {\n\t\tbool notify_imc = false;\n\t\tis_sb800 = true;\n\n\t\tif ((dev->vendor == PCI_VENDOR_ID_AMD ||\n\t\t     dev->vendor == PCI_VENDOR_ID_HYGON) &&\n\t\t    dev->device == PCI_DEVICE_ID_AMD_KERNCZ_SMBUS) {\n\t\t\tu8 imc;\n\n\t\t\t \n\t\t\tpci_bus_read_config_byte(dev->bus, PCI_DEVFN(0x14, 3),\n\t\t\t\t\t\t 0x40, &imc);\n\t\t\tif (imc & 0x80)\n\t\t\t\tnotify_imc = true;\n\t\t}\n\n\t\t \n\t\tretval = piix4_setup_sb800(dev, id, 0);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\n\t\t \n\t\tretval = piix4_add_adapters_sb800(dev, retval, notify_imc);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t} else {\n\t\tretval = piix4_setup(dev, id);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\n\t\t \n\t\tretval = piix4_add_adapter(dev, retval, false, 0, false, 0,\n\t\t\t\t\t   \"\", &piix4_main_adapters[0]);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t\tpiix4_adapter_count = 1;\n\t}\n\n\t \n\tretval = -ENODEV;\n\n\tif (dev->vendor == PCI_VENDOR_ID_ATI &&\n\t    dev->device == PCI_DEVICE_ID_ATI_SBX00_SMBUS) {\n\t\tif (dev->revision < 0x40) {\n\t\t\tretval = piix4_setup_aux(dev, id, 0x58);\n\t\t} else {\n\t\t\t \n\t\t\tretval = piix4_setup_sb800(dev, id, 1);\n\t\t}\n\t}\n\n\tif (dev->vendor == PCI_VENDOR_ID_AMD &&\n\t    (dev->device == PCI_DEVICE_ID_AMD_HUDSON2_SMBUS ||\n\t     dev->device == PCI_DEVICE_ID_AMD_KERNCZ_SMBUS)) {\n\t\tretval = piix4_setup_sb800(dev, id, 1);\n\t}\n\n\tif (retval > 0) {\n\t\t \n\t\tpiix4_add_adapter(dev, retval, false, 0, false, 1,\n\t\t\t\t  is_sb800 ? piix4_aux_port_name_sb800 : \"\",\n\t\t\t\t  &piix4_aux_adapter);\n\t}\n\n\treturn 0;\n}\n\nstatic void piix4_adap_remove(struct i2c_adapter *adap)\n{\n\tstruct i2c_piix4_adapdata *adapdata = i2c_get_adapdata(adap);\n\n\tif (adapdata->smba) {\n\t\ti2c_del_adapter(adap);\n\t\tif (adapdata->port == (0 << piix4_port_shift_sb800))\n\t\t\trelease_region(adapdata->smba, SMBIOSIZE);\n\t\tkfree(adapdata);\n\t\tkfree(adap);\n\t}\n}\n\nstatic void piix4_remove(struct pci_dev *dev)\n{\n\tint port = piix4_adapter_count;\n\n\twhile (--port >= 0) {\n\t\tif (piix4_main_adapters[port]) {\n\t\t\tpiix4_adap_remove(piix4_main_adapters[port]);\n\t\t\tpiix4_main_adapters[port] = NULL;\n\t\t}\n\t}\n\n\tif (piix4_aux_adapter) {\n\t\tpiix4_adap_remove(piix4_aux_adapter);\n\t\tpiix4_aux_adapter = NULL;\n\t}\n}\n\nstatic struct pci_driver piix4_driver = {\n\t.name\t\t= \"piix4_smbus\",\n\t.id_table\t= piix4_ids,\n\t.probe\t\t= piix4_probe,\n\t.remove\t\t= piix4_remove,\n};\n\nmodule_pci_driver(piix4_driver);\n\nMODULE_AUTHOR(\"Frodo Looijaard <frodol@dds.nl>\");\nMODULE_AUTHOR(\"Philip Edelbrock <phil@netroedge.com>\");\nMODULE_DESCRIPTION(\"PIIX4 SMBus driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}