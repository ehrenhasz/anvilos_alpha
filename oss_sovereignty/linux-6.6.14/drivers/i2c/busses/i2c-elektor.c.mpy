{
  "module_name": "i2c-elektor.c",
  "hash_id": "d32c6b5b0eceea269b3baf2ce9ae129f2e4cbd2841d9af3d1aa02a2eb9624804",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-elektor.c",
  "human_readable_source": "\n \n \n \n \n \n\n \n\n \n\n#include <linux/kernel.h>\n#include <linux/ioport.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/wait.h>\n\n#include <linux/isa.h>\n#include <linux/i2c.h>\n#include <linux/i2c-algo-pcf.h>\n#include <linux/io.h>\n\n#include <asm/irq.h>\n\n#include \"../algos/i2c-algo-pcf.h\"\n\n#define DEFAULT_BASE 0x330\n\nstatic int base;\nstatic u8 __iomem *base_iomem;\n\nstatic int irq;\nstatic int clock  = 0x1c;\nstatic int own    = 0x55;\nstatic int mmapped;\n\n \n\nstatic wait_queue_head_t pcf_wait;\nstatic int pcf_pending;\nstatic DEFINE_SPINLOCK(lock);\n\nstatic struct i2c_adapter pcf_isa_ops;\n\n \n\nstatic void pcf_isa_setbyte(void *data, int ctl, int val)\n{\n\tu8 __iomem *address = ctl ? (base_iomem + 1) : base_iomem;\n\n\t \n\tif (ctl && irq && (val & I2C_PCF_ESO)) {\n\t\tval |= I2C_PCF_ENI;\n\t}\n\n\tpr_debug(\"%s: Write %p 0x%02X\\n\", pcf_isa_ops.name, address, val);\n\tiowrite8(val, address);\n#ifdef __alpha__\n\t \n\tiowrite8(val, address);\n#endif\n}\n\nstatic int pcf_isa_getbyte(void *data, int ctl)\n{\n\tu8 __iomem *address = ctl ? (base_iomem + 1) : base_iomem;\n\tint val = ioread8(address);\n\n\tpr_debug(\"%s: Read %p 0x%02X\\n\", pcf_isa_ops.name, address, val);\n\treturn (val);\n}\n\nstatic int pcf_isa_getown(void *data)\n{\n\treturn (own);\n}\n\n\nstatic int pcf_isa_getclock(void *data)\n{\n\treturn (clock);\n}\n\nstatic void pcf_isa_waitforpin(void *data)\n{\n\tDEFINE_WAIT(wait);\n\tint timeout = 2;\n\tunsigned long flags;\n\n\tif (irq > 0) {\n\t\tspin_lock_irqsave(&lock, flags);\n\t\tif (pcf_pending == 0) {\n\t\t\tspin_unlock_irqrestore(&lock, flags);\n\t\t\tprepare_to_wait(&pcf_wait, &wait, TASK_INTERRUPTIBLE);\n\t\t\tif (schedule_timeout(timeout*HZ)) {\n\t\t\t\tspin_lock_irqsave(&lock, flags);\n\t\t\t\tif (pcf_pending == 1) {\n\t\t\t\t\tpcf_pending = 0;\n\t\t\t\t}\n\t\t\t\tspin_unlock_irqrestore(&lock, flags);\n\t\t\t}\n\t\t\tfinish_wait(&pcf_wait, &wait);\n\t\t} else {\n\t\t\tpcf_pending = 0;\n\t\t\tspin_unlock_irqrestore(&lock, flags);\n\t\t}\n\t} else {\n\t\tudelay(100);\n\t}\n}\n\n\nstatic irqreturn_t pcf_isa_handler(int this_irq, void *dev_id) {\n\tspin_lock(&lock);\n\tpcf_pending = 1;\n\tspin_unlock(&lock);\n\twake_up_interruptible(&pcf_wait);\n\treturn IRQ_HANDLED;\n}\n\n\nstatic int pcf_isa_init(void)\n{\n\tif (!mmapped) {\n\t\tif (!request_region(base, 2, pcf_isa_ops.name)) {\n\t\t\tprintk(KERN_ERR \"%s: requested I/O region (%#x:2) is \"\n\t\t\t       \"in use\\n\", pcf_isa_ops.name, base);\n\t\t\treturn -ENODEV;\n\t\t}\n\t\tbase_iomem = ioport_map(base, 2);\n\t\tif (!base_iomem) {\n\t\t\tprintk(KERN_ERR \"%s: remap of I/O region %#x failed\\n\",\n\t\t\t       pcf_isa_ops.name, base);\n\t\t\trelease_region(base, 2);\n\t\t\treturn -ENODEV;\n\t\t}\n\t} else {\n\t\tif (!request_mem_region(base, 2, pcf_isa_ops.name)) {\n\t\t\tprintk(KERN_ERR \"%s: requested memory region (%#x:2) \"\n\t\t\t       \"is in use\\n\", pcf_isa_ops.name, base);\n\t\t\treturn -ENODEV;\n\t\t}\n\t\tbase_iomem = ioremap(base, 2);\n\t\tif (base_iomem == NULL) {\n\t\t\tprintk(KERN_ERR \"%s: remap of memory region %#x \"\n\t\t\t       \"failed\\n\", pcf_isa_ops.name, base);\n\t\t\trelease_mem_region(base, 2);\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\tpr_debug(\"%s: registers %#x remapped to %p\\n\", pcf_isa_ops.name, base,\n\t\t base_iomem);\n\n\tif (irq > 0) {\n\t\tif (request_irq(irq, pcf_isa_handler, 0, pcf_isa_ops.name,\n\t\t\t\tNULL) < 0) {\n\t\t\tprintk(KERN_ERR \"%s: Request irq%d failed\\n\",\n\t\t\t       pcf_isa_ops.name, irq);\n\t\t\tirq = 0;\n\t\t} else\n\t\t\tenable_irq(irq);\n\t}\n\treturn 0;\n}\n\n \nstatic struct i2c_algo_pcf_data pcf_isa_data = {\n\t.setpcf\t    = pcf_isa_setbyte,\n\t.getpcf\t    = pcf_isa_getbyte,\n\t.getown\t    = pcf_isa_getown,\n\t.getclock   = pcf_isa_getclock,\n\t.waitforpin = pcf_isa_waitforpin,\n};\n\nstatic struct i2c_adapter pcf_isa_ops = {\n\t.owner\t\t= THIS_MODULE,\n\t.class\t\t= I2C_CLASS_HWMON | I2C_CLASS_SPD,\n\t.algo_data\t= &pcf_isa_data,\n\t.name\t\t= \"i2c-elektor\",\n};\n\nstatic int elektor_match(struct device *dev, unsigned int id)\n{\n#ifdef __alpha__\n\t \n\tif (base == 0) {\n\t\tstruct pci_dev *cy693_dev;\n\n\t\tcy693_dev = pci_get_device(PCI_VENDOR_ID_CONTAQ,\n\t\t\t\t\t   PCI_DEVICE_ID_CONTAQ_82C693, NULL);\n\t\tif (cy693_dev) {\n\t\t\tunsigned char config;\n\t\t\t \n\t\t\tif (!pci_read_config_byte(cy693_dev, 0x47, &config)) {\n\n\t\t\t\tdev_dbg(dev, \"found cy82c693, config \"\n\t\t\t\t\t\"register 0x47 = 0x%02x\\n\", config);\n\n\t\t\t\t \n\n\t\t\t\t \n\t\t\t\tif ((config & 0x7f) == 0x61) {\n\t\t\t\t\t \n\t\t\t\t\tbase = 0xe0000;\n\t\t\t\t\tmmapped = 1;\n\t\t\t\t\t \n\t\t\t\t\tclock = I2C_PCF_CLK | I2C_PCF_TRNS90;\n\t\t\t\t\tdev_info(dev, \"found API UP2000 like \"\n\t\t\t\t\t\t \"board, will probe PCF8584 \"\n\t\t\t\t\t\t \"later\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tpci_dev_put(cy693_dev);\n\t\t}\n\t}\n#endif\n\n\t \n\tif (mmapped && base < 0xc8000) {\n\t\tdev_err(dev, \"incorrect base address (%#x) specified \"\n\t\t       \"for mmapped I/O\\n\", base);\n\t\treturn 0;\n\t}\n\n\tif (base == 0) {\n\t\tbase = DEFAULT_BASE;\n\t}\n\treturn 1;\n}\n\nstatic int elektor_probe(struct device *dev, unsigned int id)\n{\n\tinit_waitqueue_head(&pcf_wait);\n\tif (pcf_isa_init())\n\t\treturn -ENODEV;\n\tpcf_isa_ops.dev.parent = dev;\n\tif (i2c_pcf_add_bus(&pcf_isa_ops) < 0)\n\t\tgoto fail;\n\n\tdev_info(dev, \"found device at %#x\\n\", base);\n\n\treturn 0;\n\n fail:\n\tif (irq > 0) {\n\t\tdisable_irq(irq);\n\t\tfree_irq(irq, NULL);\n\t}\n\n\tif (!mmapped) {\n\t\tioport_unmap(base_iomem);\n\t\trelease_region(base, 2);\n\t} else {\n\t\tiounmap(base_iomem);\n\t\trelease_mem_region(base, 2);\n\t}\n\treturn -ENODEV;\n}\n\nstatic void elektor_remove(struct device *dev, unsigned int id)\n{\n\ti2c_del_adapter(&pcf_isa_ops);\n\n\tif (irq > 0) {\n\t\tdisable_irq(irq);\n\t\tfree_irq(irq, NULL);\n\t}\n\n\tif (!mmapped) {\n\t\tioport_unmap(base_iomem);\n\t\trelease_region(base, 2);\n\t} else {\n\t\tiounmap(base_iomem);\n\t\trelease_mem_region(base, 2);\n\t}\n}\n\nstatic struct isa_driver i2c_elektor_driver = {\n\t.match\t\t= elektor_match,\n\t.probe\t\t= elektor_probe,\n\t.remove\t\t= elektor_remove,\n\t.driver = {\n\t\t.owner\t= THIS_MODULE,\n\t\t.name\t= \"i2c-elektor\",\n\t},\n};\n\nMODULE_AUTHOR(\"Hans Berglund <hb@spacetec.no>\");\nMODULE_DESCRIPTION(\"I2C-Bus adapter routines for PCF8584 ISA bus adapter\");\nMODULE_LICENSE(\"GPL\");\n\nmodule_param_hw(base, int, ioport_or_iomem, 0);\nmodule_param_hw(irq, int, irq, 0);\nmodule_param(clock, int, 0);\nmodule_param(own, int, 0);\nmodule_param_hw(mmapped, int, other, 0);\nmodule_isa_driver(i2c_elektor_driver, 1);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}