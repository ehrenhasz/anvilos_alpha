{
  "module_name": "i2c-npcm7xx.c",
  "hash_id": "71240113480a9c41a8672b95d1f460e82d38bd6195214414141503f34afbfc74",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-npcm7xx.c",
  "human_readable_source": "\n \n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/debugfs.h>\n#include <linux/errno.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/iopoll.h>\n#include <linux/irq.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n\nenum i2c_mode {\n\tI2C_MASTER,\n\tI2C_SLAVE,\n};\n\n \nenum i2c_state_ind {\n\tI2C_NO_STATUS_IND = 0,\n\tI2C_SLAVE_RCV_IND,\n\tI2C_SLAVE_XMIT_IND,\n\tI2C_SLAVE_XMIT_MISSING_DATA_IND,\n\tI2C_SLAVE_RESTART_IND,\n\tI2C_SLAVE_DONE_IND,\n\tI2C_MASTER_DONE_IND,\n\tI2C_NACK_IND,\n\tI2C_BUS_ERR_IND,\n\tI2C_WAKE_UP_IND,\n\tI2C_BLOCK_BYTES_ERR_IND,\n\tI2C_SLAVE_RCV_MISSING_DATA_IND,\n};\n\n \nenum i2c_oper {\n\tI2C_NO_OPER = 0,\n\tI2C_WRITE_OPER,\n\tI2C_READ_OPER,\n};\n\n \nenum i2c_bank {\n\tI2C_BANK_0 = 0,\n\tI2C_BANK_1,\n};\n\n \nenum i2c_state {\n\tI2C_DISABLE = 0,\n\tI2C_IDLE,\n\tI2C_MASTER_START,\n\tI2C_SLAVE_MATCH,\n\tI2C_OPER_STARTED,\n\tI2C_STOP_PENDING,\n};\n\n#if IS_ENABLED(CONFIG_I2C_SLAVE)\n \nenum i2c_addr {\n\tI2C_SLAVE_ADDR1 = 0,\n\tI2C_SLAVE_ADDR2,\n\tI2C_SLAVE_ADDR3,\n\tI2C_SLAVE_ADDR4,\n\tI2C_SLAVE_ADDR5,\n\tI2C_SLAVE_ADDR6,\n\tI2C_SLAVE_ADDR7,\n\tI2C_SLAVE_ADDR8,\n\tI2C_SLAVE_ADDR9,\n\tI2C_SLAVE_ADDR10,\n\tI2C_GC_ADDR,\n\tI2C_ARP_ADDR,\n};\n#endif\n\n \n#define NPCM_I2CSEGCTL\t\t\t0xE4\n\n \n#define NPCM_I2CSDA\t\t\t0x00\n#define NPCM_I2CST\t\t\t0x02\n#define NPCM_I2CCST\t\t\t0x04\n#define NPCM_I2CCTL1\t\t\t0x06\n#define NPCM_I2CADDR1\t\t\t0x08\n#define NPCM_I2CCTL2\t\t\t0x0A\n#define NPCM_I2CADDR2\t\t\t0x0C\n#define NPCM_I2CCTL3\t\t\t0x0E\n#define NPCM_I2CCST2\t\t\t0x18\n#define NPCM_I2CCST3\t\t\t0x19\n#define I2C_VER\t\t\t\t0x1F\n\n \n#define NPCM_I2CADDR3\t\t\t0x10\n#define NPCM_I2CADDR7\t\t\t0x11\n#define NPCM_I2CADDR4\t\t\t0x12\n#define NPCM_I2CADDR8\t\t\t0x13\n#define NPCM_I2CADDR5\t\t\t0x14\n#define NPCM_I2CADDR9\t\t\t0x15\n#define NPCM_I2CADDR6\t\t\t0x16\n#define NPCM_I2CADDR10\t\t\t0x17\n#define NPCM_I2CCTL4\t\t\t0x1A\n#define NPCM_I2CCTL5\t\t\t0x1B\n#define NPCM_I2CSCLLT\t\t\t0x1C  \n#define NPCM_I2CFIF_CTL\t\t\t0x1D  \n#define NPCM_I2CSCLHT\t\t\t0x1E  \n\n \n#define NPCM_I2CFIF_CTS\t\t\t0x10  \n#define NPCM_I2CTXF_CTL\t\t\t0x12  \n#define NPCM_I2CT_OUT\t\t\t0x14  \n#define NPCM_I2CPEC\t\t\t0x16  \n#define NPCM_I2CTXF_STS\t\t\t0x1A  \n#define NPCM_I2CRXF_STS\t\t\t0x1C  \n#define NPCM_I2CRXF_CTL\t\t\t0x1E  \n\n#if IS_ENABLED(CONFIG_I2C_SLAVE)\n \n#define I2C_NUM_OWN_ADDR 2\n#define I2C_NUM_OWN_ADDR_SUPPORTED 2\n\nstatic const int npcm_i2caddr[I2C_NUM_OWN_ADDR] = {\n\tNPCM_I2CADDR1, NPCM_I2CADDR2,\n};\n#endif\n\n \n#define NPCM_I2CST_XMIT\t\t\tBIT(0)\t \n#define NPCM_I2CST_MASTER\t\tBIT(1)\t \n#define NPCM_I2CST_NMATCH\t\tBIT(2)\t \n#define NPCM_I2CST_STASTR\t\tBIT(3)\t \n#define NPCM_I2CST_NEGACK\t\tBIT(4)\t \n#define NPCM_I2CST_BER\t\t\tBIT(5)\t \n#define NPCM_I2CST_SDAST\t\tBIT(6)\t \n#define NPCM_I2CST_SLVSTP\t\tBIT(7)\t \n\n \n#define NPCM_I2CCST_BUSY\t\tBIT(0)\t \n#define NPCM_I2CCST_BB\t\t\tBIT(1)\t \n#define NPCM_I2CCST_MATCH\t\tBIT(2)\t \n#define NPCM_I2CCST_GCMATCH\t\tBIT(3)\t \n#define NPCM_I2CCST_TSDA\t\tBIT(4)\t \n#define NPCM_I2CCST_TGSCL\t\tBIT(5)\t \n#define NPCM_I2CCST_MATCHAF\t\tBIT(6)\t \n#define NPCM_I2CCST_ARPMATCH\t\tBIT(7)\t \n\n \n#define NPCM_I2CCTL1_START\t\tBIT(0)\t \n#define NPCM_I2CCTL1_STOP\t\tBIT(1)\t \n#define NPCM_I2CCTL1_INTEN\t\tBIT(2)\t \n#define NPCM_I2CCTL1_EOBINTE\t\tBIT(3)\n#define NPCM_I2CCTL1_ACK\t\tBIT(4)\n#define NPCM_I2CCTL1_GCMEN\t\tBIT(5)\t \n#define NPCM_I2CCTL1_NMINTE\t\tBIT(6)\t \n#define NPCM_I2CCTL1_STASTRE\t\tBIT(7)\t \n\n \n#define NPCM_I2CCTL1_RWS   \\\n\t(NPCM_I2CCTL1_START | NPCM_I2CCTL1_STOP | NPCM_I2CCTL1_ACK)\n\n \n#define NPCM_I2CADDR_A\t\t\tGENMASK(6, 0)\t \n#define NPCM_I2CADDR_SAEN\t\tBIT(7)\t\t \n\n \n#define I2CCTL2_ENABLE\t\t\tBIT(0)\t\t \n#define I2CCTL2_SCLFRQ6_0\t\tGENMASK(7, 1)\t \n\n \n#define I2CCTL3_SCLFRQ8_7\t\tGENMASK(1, 0)\t \n#define I2CCTL3_ARPMEN\t\t\tBIT(2)\t \n#define I2CCTL3_IDL_START\t\tBIT(3)\n#define I2CCTL3_400K_MODE\t\tBIT(4)\n#define I2CCTL3_BNK_SEL\t\t\tBIT(5)\n#define I2CCTL3_SDA_LVL\t\t\tBIT(6)\n#define I2CCTL3_SCL_LVL\t\t\tBIT(7)\n\n \n#define NPCM_I2CCST2_MATCHA1F\t\tBIT(0)\n#define NPCM_I2CCST2_MATCHA2F\t\tBIT(1)\n#define NPCM_I2CCST2_MATCHA3F\t\tBIT(2)\n#define NPCM_I2CCST2_MATCHA4F\t\tBIT(3)\n#define NPCM_I2CCST2_MATCHA5F\t\tBIT(4)\n#define NPCM_I2CCST2_MATCHA6F\t\tBIT(5)\n#define NPCM_I2CCST2_MATCHA7F\t\tBIT(5)\n#define NPCM_I2CCST2_INTSTS\t\tBIT(7)\n\n \n#define NPCM_I2CCST3_MATCHA8F\t\tBIT(0)\n#define NPCM_I2CCST3_MATCHA9F\t\tBIT(1)\n#define NPCM_I2CCST3_MATCHA10F\t\tBIT(2)\n#define NPCM_I2CCST3_EO_BUSY\t\tBIT(7)\n\n \n#define I2CCTL4_HLDT\t\t\tGENMASK(5, 0)\n#define I2CCTL4_LVL_WE\t\t\tBIT(7)\n\n \n#define I2CCTL5_DBNCT\t\t\tGENMASK(3, 0)\n\n \n#define NPCM_I2CFIF_CTS_RXF_TXE\t\tBIT(1)\n#define NPCM_I2CFIF_CTS_RFTE_IE\t\tBIT(3)\n#define NPCM_I2CFIF_CTS_CLR_FIFO\tBIT(6)\n#define NPCM_I2CFIF_CTS_SLVRSTR\t\tBIT(7)\n\n \n#define NPCM_I2CTXF_CTL_THR_TXIE\tBIT(6)\n\n \n#define NPCM_I2CT_OUT_TO_CKDIV\t\tGENMASK(5, 0)\n#define NPCM_I2CT_OUT_T_OUTIE\t\tBIT(6)\n#define NPCM_I2CT_OUT_T_OUTST\t\tBIT(7)\n\n \n#define NPCM_I2CTXF_STS_TX_THST\t\tBIT(6)\n\n \n#define NPCM_I2CRXF_STS_RX_THST\t\tBIT(6)\n\n \n#define NPCM_I2CFIF_CTL_FIFO_EN\t\tBIT(4)\n\n \n#define NPCM_I2CRXF_CTL_THR_RXIE\tBIT(6)\n\n#define MAX_I2C_HW_FIFO_SIZE\t\t32\n\n \n#define I2C_VER_VERSION\t\t\tGENMASK(6, 0)\n#define I2C_VER_FIFO_EN\t\t\tBIT(7)\n\n \n#define DEFAULT_STALL_COUNT\t\t25\n\n \n#define SCLFRQ_0_TO_6\t\t\tGENMASK(6, 0)\n#define SCLFRQ_7_TO_8\t\t\tGENMASK(8, 7)\n\n \n#define I2C_FREQ_MIN_HZ\t\t\t10000\n#define I2C_FREQ_MAX_HZ\t\t\tI2C_MAX_FAST_MODE_PLUS_FREQ\n\nstruct npcm_i2c_data {\n\tu8 fifo_size;\n\tu32 segctl_init_val;\n\tu8 txf_sts_tx_bytes;\n\tu8 rxf_sts_rx_bytes;\n\tu8 rxf_ctl_last_pec;\n};\n\nstatic const struct npcm_i2c_data npxm7xx_i2c_data = {\n\t.fifo_size = 16,\n\t.segctl_init_val = 0x0333F000,\n\t.txf_sts_tx_bytes = GENMASK(4, 0),\n\t.rxf_sts_rx_bytes = GENMASK(4, 0),\n\t.rxf_ctl_last_pec = BIT(5),\n};\n\nstatic const struct npcm_i2c_data npxm8xx_i2c_data = {\n\t.fifo_size = 32,\n\t.segctl_init_val = 0x9333F000,\n\t.txf_sts_tx_bytes = GENMASK(5, 0),\n\t.rxf_sts_rx_bytes = GENMASK(5, 0),\n\t.rxf_ctl_last_pec = BIT(7),\n};\n\n \nstruct npcm_i2c {\n\tstruct i2c_adapter adap;\n\tstruct device *dev;\n\tunsigned char __iomem *reg;\n\tconst struct npcm_i2c_data *data;\n\tspinlock_t lock;    \n\tstruct completion cmd_complete;\n\tint cmd_err;\n\tstruct i2c_msg *msgs;\n\tint msgs_num;\n\tint num;\n\tu32 apb_clk;\n\tstruct i2c_bus_recovery_info rinfo;\n\tenum i2c_state state;\n\tenum i2c_oper operation;\n\tenum i2c_mode master_or_slave;\n\tenum i2c_state_ind stop_ind;\n\tu8 dest_addr;\n\tu8 *rd_buf;\n\tu16 rd_size;\n\tu16 rd_ind;\n\tu8 *wr_buf;\n\tu16 wr_size;\n\tu16 wr_ind;\n\tbool fifo_use;\n\tu16 PEC_mask;  \n\tbool PEC_use;\n\tbool read_block_use;\n\tunsigned long int_time_stamp;\n\tunsigned long bus_freq;  \n#if IS_ENABLED(CONFIG_I2C_SLAVE)\n\tu8 own_slave_addr;\n\tstruct i2c_client *slave;\n\tint slv_rd_size;\n\tint slv_rd_ind;\n\tint slv_wr_size;\n\tint slv_wr_ind;\n\tu8 slv_rd_buf[MAX_I2C_HW_FIFO_SIZE];\n\tu8 slv_wr_buf[MAX_I2C_HW_FIFO_SIZE];\n#endif\n\tstruct dentry *debugfs;  \n\tu64 ber_cnt;\n\tu64 rec_succ_cnt;\n\tu64 rec_fail_cnt;\n\tu64 nack_cnt;\n\tu64 timeout_cnt;\n\tu64 tx_complete_cnt;\n};\n\nstatic inline void npcm_i2c_select_bank(struct npcm_i2c *bus,\n\t\t\t\t\tenum i2c_bank bank)\n{\n\tu8 i2cctl3 = ioread8(bus->reg + NPCM_I2CCTL3);\n\n\tif (bank == I2C_BANK_0)\n\t\ti2cctl3 = i2cctl3 & ~I2CCTL3_BNK_SEL;\n\telse\n\t\ti2cctl3 = i2cctl3 | I2CCTL3_BNK_SEL;\n\tiowrite8(i2cctl3, bus->reg + NPCM_I2CCTL3);\n}\n\nstatic void npcm_i2c_init_params(struct npcm_i2c *bus)\n{\n\tbus->stop_ind = I2C_NO_STATUS_IND;\n\tbus->rd_size = 0;\n\tbus->wr_size = 0;\n\tbus->rd_ind = 0;\n\tbus->wr_ind = 0;\n\tbus->read_block_use = false;\n\tbus->int_time_stamp = 0;\n\tbus->PEC_use = false;\n\tbus->PEC_mask = 0;\n#if IS_ENABLED(CONFIG_I2C_SLAVE)\n\tif (bus->slave)\n\t\tbus->master_or_slave = I2C_SLAVE;\n#endif\n}\n\nstatic inline void npcm_i2c_wr_byte(struct npcm_i2c *bus, u8 data)\n{\n\tiowrite8(data, bus->reg + NPCM_I2CSDA);\n}\n\nstatic inline u8 npcm_i2c_rd_byte(struct npcm_i2c *bus)\n{\n\treturn ioread8(bus->reg + NPCM_I2CSDA);\n}\n\nstatic int npcm_i2c_get_SCL(struct i2c_adapter *_adap)\n{\n\tstruct npcm_i2c *bus = container_of(_adap, struct npcm_i2c, adap);\n\n\treturn !!(I2CCTL3_SCL_LVL & ioread8(bus->reg + NPCM_I2CCTL3));\n}\n\nstatic int npcm_i2c_get_SDA(struct i2c_adapter *_adap)\n{\n\tstruct npcm_i2c *bus = container_of(_adap, struct npcm_i2c, adap);\n\n\treturn !!(I2CCTL3_SDA_LVL & ioread8(bus->reg + NPCM_I2CCTL3));\n}\n\nstatic inline u16 npcm_i2c_get_index(struct npcm_i2c *bus)\n{\n\tif (bus->operation == I2C_READ_OPER)\n\t\treturn bus->rd_ind;\n\tif (bus->operation == I2C_WRITE_OPER)\n\t\treturn bus->wr_ind;\n\treturn 0;\n}\n\n \nstatic inline bool npcm_i2c_is_quick(struct npcm_i2c *bus)\n{\n\treturn bus->wr_size == 0 && bus->rd_size == 0;\n}\n\nstatic void npcm_i2c_disable(struct npcm_i2c *bus)\n{\n\tu8 i2cctl2;\n\n#if IS_ENABLED(CONFIG_I2C_SLAVE)\n\tint i;\n\n\t \n\tfor (i = I2C_SLAVE_ADDR1; i < I2C_NUM_OWN_ADDR_SUPPORTED; i++)\n\t\tiowrite8(0, bus->reg + npcm_i2caddr[i]);\n\n#endif\n\t \n\ti2cctl2 = ioread8(bus->reg + NPCM_I2CCTL2);\n\ti2cctl2 = i2cctl2 & ~I2CCTL2_ENABLE;\n\tiowrite8(i2cctl2, bus->reg + NPCM_I2CCTL2);\n\n\tbus->state = I2C_DISABLE;\n}\n\nstatic void npcm_i2c_enable(struct npcm_i2c *bus)\n{\n\tu8 i2cctl2 = ioread8(bus->reg + NPCM_I2CCTL2);\n\n\ti2cctl2 = i2cctl2 | I2CCTL2_ENABLE;\n\tiowrite8(i2cctl2, bus->reg + NPCM_I2CCTL2);\n\tbus->state = I2C_IDLE;\n}\n\n \nstatic inline void npcm_i2c_eob_int(struct npcm_i2c *bus, bool enable)\n{\n\tu8 val;\n\n\t \n\tval = ioread8(bus->reg + NPCM_I2CCST3);\n\tval = val | NPCM_I2CCST3_EO_BUSY;\n\tiowrite8(val, bus->reg + NPCM_I2CCST3);\n\n\tval = ioread8(bus->reg + NPCM_I2CCTL1);\n\tval &= ~NPCM_I2CCTL1_RWS;\n\tif (enable)\n\t\tval |= NPCM_I2CCTL1_EOBINTE;\n\telse\n\t\tval &= ~NPCM_I2CCTL1_EOBINTE;\n\tiowrite8(val, bus->reg + NPCM_I2CCTL1);\n}\n\nstatic inline bool npcm_i2c_tx_fifo_empty(struct npcm_i2c *bus)\n{\n\tu8 tx_fifo_sts;\n\n\ttx_fifo_sts = ioread8(bus->reg + NPCM_I2CTXF_STS);\n\t \n\tif ((tx_fifo_sts & bus->data->txf_sts_tx_bytes) == 0)\n\t\treturn false;\n\n\t \n\treturn !!FIELD_GET(NPCM_I2CTXF_STS_TX_THST, tx_fifo_sts);\n}\n\nstatic inline bool npcm_i2c_rx_fifo_full(struct npcm_i2c *bus)\n{\n\tu8 rx_fifo_sts;\n\n\trx_fifo_sts = ioread8(bus->reg + NPCM_I2CRXF_STS);\n\t \n\tif ((rx_fifo_sts & bus->data->rxf_sts_rx_bytes) == 0)\n\t\treturn false;\n\n\t \n\treturn !!FIELD_GET(NPCM_I2CRXF_STS_RX_THST, rx_fifo_sts);\n}\n\nstatic inline void npcm_i2c_clear_fifo_int(struct npcm_i2c *bus)\n{\n\tu8 val;\n\n\tval = ioread8(bus->reg + NPCM_I2CFIF_CTS);\n\tval = (val & NPCM_I2CFIF_CTS_SLVRSTR) | NPCM_I2CFIF_CTS_RXF_TXE;\n\tiowrite8(val, bus->reg + NPCM_I2CFIF_CTS);\n}\n\nstatic inline void npcm_i2c_clear_tx_fifo(struct npcm_i2c *bus)\n{\n\tu8 val;\n\n\tval = ioread8(bus->reg + NPCM_I2CTXF_STS);\n\tval = val | NPCM_I2CTXF_STS_TX_THST;\n\tiowrite8(val, bus->reg + NPCM_I2CTXF_STS);\n}\n\nstatic inline void npcm_i2c_clear_rx_fifo(struct npcm_i2c *bus)\n{\n\tu8 val;\n\n\tval = ioread8(bus->reg + NPCM_I2CRXF_STS);\n\tval = val | NPCM_I2CRXF_STS_RX_THST;\n\tiowrite8(val, bus->reg + NPCM_I2CRXF_STS);\n}\n\nstatic void npcm_i2c_int_enable(struct npcm_i2c *bus, bool enable)\n{\n\tu8 val;\n\n\tval = ioread8(bus->reg + NPCM_I2CCTL1);\n\tval &= ~NPCM_I2CCTL1_RWS;\n\tif (enable)\n\t\tval |= NPCM_I2CCTL1_INTEN;\n\telse\n\t\tval &= ~NPCM_I2CCTL1_INTEN;\n\tiowrite8(val, bus->reg + NPCM_I2CCTL1);\n}\n\nstatic inline void npcm_i2c_master_start(struct npcm_i2c *bus)\n{\n\tu8 val;\n\n\tval = ioread8(bus->reg + NPCM_I2CCTL1);\n\tval &= ~(NPCM_I2CCTL1_STOP | NPCM_I2CCTL1_ACK);\n\tval |= NPCM_I2CCTL1_START;\n\tiowrite8(val, bus->reg + NPCM_I2CCTL1);\n}\n\nstatic inline void npcm_i2c_master_stop(struct npcm_i2c *bus)\n{\n\tu8 val;\n\n\t \n\tudelay(10);  \n\tval = ioread8(bus->reg + NPCM_I2CCTL1);\n\tval &= ~(NPCM_I2CCTL1_START | NPCM_I2CCTL1_ACK);\n\tval |= NPCM_I2CCTL1_STOP;\n\tiowrite8(val, bus->reg + NPCM_I2CCTL1);\n\n\tif (!bus->fifo_use)\n\t\treturn;\n\n\tnpcm_i2c_select_bank(bus, I2C_BANK_1);\n\n\tif (bus->operation == I2C_READ_OPER)\n\t\tnpcm_i2c_clear_rx_fifo(bus);\n\telse\n\t\tnpcm_i2c_clear_tx_fifo(bus);\n\tnpcm_i2c_clear_fifo_int(bus);\n\tiowrite8(0, bus->reg + NPCM_I2CTXF_CTL);\n}\n\nstatic inline void npcm_i2c_stall_after_start(struct npcm_i2c *bus, bool stall)\n{\n\tu8 val;\n\n\tval = ioread8(bus->reg + NPCM_I2CCTL1);\n\tval &= ~NPCM_I2CCTL1_RWS;\n\tif (stall)\n\t\tval |= NPCM_I2CCTL1_STASTRE;\n\telse\n\t\tval &= ~NPCM_I2CCTL1_STASTRE;\n\tiowrite8(val, bus->reg + NPCM_I2CCTL1);\n}\n\nstatic inline void npcm_i2c_nack(struct npcm_i2c *bus)\n{\n\tu8 val;\n\n\tval = ioread8(bus->reg + NPCM_I2CCTL1);\n\tval &= ~(NPCM_I2CCTL1_STOP | NPCM_I2CCTL1_START);\n\tval |= NPCM_I2CCTL1_ACK;\n\tiowrite8(val, bus->reg + NPCM_I2CCTL1);\n}\n\nstatic inline void npcm_i2c_clear_master_status(struct npcm_i2c *bus)\n{\n\tu8 val;\n\n\t \n\tval = NPCM_I2CST_BER | NPCM_I2CST_NEGACK | NPCM_I2CST_STASTR;\n\tiowrite8(val, bus->reg + NPCM_I2CST);\n}\n\n#if IS_ENABLED(CONFIG_I2C_SLAVE)\nstatic void npcm_i2c_slave_int_enable(struct npcm_i2c *bus, bool enable)\n{\n\tu8 i2cctl1;\n\n\t \n\ti2cctl1 = ioread8(bus->reg + NPCM_I2CCTL1);\n\ti2cctl1 &= ~NPCM_I2CCTL1_RWS;\n\tif (enable)\n\t\ti2cctl1 |= NPCM_I2CCTL1_NMINTE;\n\telse\n\t\ti2cctl1 &= ~NPCM_I2CCTL1_NMINTE;\n\tiowrite8(i2cctl1, bus->reg + NPCM_I2CCTL1);\n}\n\nstatic int npcm_i2c_slave_enable(struct npcm_i2c *bus, enum i2c_addr addr_type,\n\t\t\t\t u8 addr, bool enable)\n{\n\tu8 i2cctl1;\n\tu8 i2cctl3;\n\tu8 sa_reg;\n\n\tsa_reg = (addr & 0x7F) | FIELD_PREP(NPCM_I2CADDR_SAEN, enable);\n\tif (addr_type == I2C_GC_ADDR) {\n\t\ti2cctl1 = ioread8(bus->reg + NPCM_I2CCTL1);\n\t\tif (enable)\n\t\t\ti2cctl1 |= NPCM_I2CCTL1_GCMEN;\n\t\telse\n\t\t\ti2cctl1 &= ~NPCM_I2CCTL1_GCMEN;\n\t\tiowrite8(i2cctl1, bus->reg + NPCM_I2CCTL1);\n\t\treturn 0;\n\t} else if (addr_type == I2C_ARP_ADDR) {\n\t\ti2cctl3 = ioread8(bus->reg + NPCM_I2CCTL3);\n\t\tif (enable)\n\t\t\ti2cctl3 |= I2CCTL3_ARPMEN;\n\t\telse\n\t\t\ti2cctl3 &= ~I2CCTL3_ARPMEN;\n\t\tiowrite8(i2cctl3, bus->reg + NPCM_I2CCTL3);\n\t\treturn 0;\n\t}\n\tif (addr_type > I2C_SLAVE_ADDR2 && addr_type <= I2C_SLAVE_ADDR10)\n\t\tdev_err(bus->dev, \"try to enable more than 2 SA not supported\\n\");\n\n\tif (addr_type >= I2C_ARP_ADDR)\n\t\treturn -EFAULT;\n\n\t \n\tiowrite8(sa_reg, bus->reg + npcm_i2caddr[addr_type]);\n\tnpcm_i2c_slave_int_enable(bus, enable);\n\n\treturn 0;\n}\n#endif\n\nstatic void npcm_i2c_reset(struct npcm_i2c *bus)\n{\n\t \n\tu8 i2cctl1;\n#if IS_ENABLED(CONFIG_I2C_SLAVE)\n\tu8 addr;\n#endif\n\n\ti2cctl1 = ioread8(bus->reg + NPCM_I2CCTL1);\n\n\tnpcm_i2c_disable(bus);\n\tnpcm_i2c_enable(bus);\n\n\t \n\ti2cctl1 &= ~NPCM_I2CCTL1_RWS;\n\tiowrite8(i2cctl1, bus->reg + NPCM_I2CCTL1);\n\n\t \n\tiowrite8(NPCM_I2CCST_BB, bus->reg + NPCM_I2CCST);\n\tiowrite8(0xFF, bus->reg + NPCM_I2CST);\n\n\t \n\tnpcm_i2c_eob_int(bus, false);\n\n\t \n\tiowrite8(NPCM_I2CFIF_CTS_CLR_FIFO, bus->reg + NPCM_I2CFIF_CTS);\n\n#if IS_ENABLED(CONFIG_I2C_SLAVE)\n\tif (bus->slave) {\n\t\taddr = bus->slave->addr;\n\t\tnpcm_i2c_slave_enable(bus, I2C_SLAVE_ADDR1, addr, true);\n\t}\n#endif\n\n\t \n\tnpcm_i2c_clear_master_status(bus);\n\n\tbus->state = I2C_IDLE;\n}\n\nstatic inline bool npcm_i2c_is_master(struct npcm_i2c *bus)\n{\n\treturn !!FIELD_GET(NPCM_I2CST_MASTER, ioread8(bus->reg + NPCM_I2CST));\n}\n\nstatic void npcm_i2c_callback(struct npcm_i2c *bus,\n\t\t\t      enum i2c_state_ind op_status, u16 info)\n{\n\tstruct i2c_msg *msgs;\n\tint msgs_num;\n\tbool do_complete = false;\n\n\tmsgs = bus->msgs;\n\tmsgs_num = bus->msgs_num;\n\t \n\tif (!msgs)\n\t\treturn;\n\n\tif (completion_done(&bus->cmd_complete))\n\t\treturn;\n\n\tswitch (op_status) {\n\tcase I2C_MASTER_DONE_IND:\n\t\tbus->cmd_err = bus->msgs_num;\n\t\tif (bus->tx_complete_cnt < ULLONG_MAX)\n\t\t\tbus->tx_complete_cnt++;\n\t\tfallthrough;\n\tcase I2C_BLOCK_BYTES_ERR_IND:\n\t\t \n\t\tif (bus->msgs) {\n\t\t\tif (msgs[0].flags & I2C_M_RD)\n\t\t\t\tmsgs[0].len = info;\n\t\t\telse if (msgs_num == 2 &&\n\t\t\t\t msgs[1].flags & I2C_M_RD)\n\t\t\t\tmsgs[1].len = info;\n\t\t}\n\t\tdo_complete = true;\n\t\tbreak;\n\tcase I2C_NACK_IND:\n\t\t \n\t\tbus->cmd_err = -ENXIO;\n\t\tdo_complete = true;\n\t\tbreak;\n\tcase I2C_BUS_ERR_IND:\n\t\t \n\t\tbus->cmd_err = -EAGAIN;\n\t\tdo_complete = true;\n\t\tbreak;\n\tcase I2C_WAKE_UP_IND:\n\t\t \n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tbus->operation = I2C_NO_OPER;\n#if IS_ENABLED(CONFIG_I2C_SLAVE)\n\tif (bus->slave)\n\t\tbus->master_or_slave = I2C_SLAVE;\n#endif\n\tif (do_complete)\n\t\tcomplete(&bus->cmd_complete);\n}\n\nstatic u8 npcm_i2c_fifo_usage(struct npcm_i2c *bus)\n{\n\tif (bus->operation == I2C_WRITE_OPER)\n\t\treturn (bus->data->txf_sts_tx_bytes &\n\t\t\tioread8(bus->reg + NPCM_I2CTXF_STS));\n\tif (bus->operation == I2C_READ_OPER)\n\t\treturn (bus->data->rxf_sts_rx_bytes &\n\t\t\tioread8(bus->reg + NPCM_I2CRXF_STS));\n\treturn 0;\n}\n\nstatic void npcm_i2c_write_to_fifo_master(struct npcm_i2c *bus, u16 max_bytes)\n{\n\tu8 size_free_fifo;\n\n\t \n\tsize_free_fifo = bus->data->fifo_size - npcm_i2c_fifo_usage(bus);\n\twhile (max_bytes-- && size_free_fifo) {\n\t\tif (bus->wr_ind < bus->wr_size)\n\t\t\tnpcm_i2c_wr_byte(bus, bus->wr_buf[bus->wr_ind++]);\n\t\telse\n\t\t\tnpcm_i2c_wr_byte(bus, 0xFF);\n\t\tsize_free_fifo = bus->data->fifo_size - npcm_i2c_fifo_usage(bus);\n\t}\n}\n\n \nstatic void npcm_i2c_set_fifo(struct npcm_i2c *bus, int nread, int nwrite)\n{\n\tu8 rxf_ctl = 0;\n\n\tif (!bus->fifo_use)\n\t\treturn;\n\tnpcm_i2c_select_bank(bus, I2C_BANK_1);\n\tnpcm_i2c_clear_tx_fifo(bus);\n\tnpcm_i2c_clear_rx_fifo(bus);\n\n\t \n\tif (nread > 0) {\n\t\trxf_ctl = min_t(int, nread, bus->data->fifo_size);\n\n\t\t \n\t\tif (nread <= bus->data->fifo_size)\n\t\t\trxf_ctl |= bus->data->rxf_ctl_last_pec;\n\n\t\t \n\t\tif (bus->rd_ind == 0 && bus->read_block_use) {\n\t\t\t \n\t\t\trxf_ctl = 1;\n\t\t}\n\n\t\t \n\t\tiowrite8(rxf_ctl, bus->reg + NPCM_I2CRXF_CTL);\n\t}\n\n\t \n\tif (nwrite > 0) {\n\t\tif (nwrite > bus->data->fifo_size)\n\t\t\t \n\t\t\tiowrite8(bus->data->fifo_size, bus->reg + NPCM_I2CTXF_CTL);\n\t\telse\n\t\t\tiowrite8(nwrite, bus->reg + NPCM_I2CTXF_CTL);\n\n\t\tnpcm_i2c_clear_tx_fifo(bus);\n\t}\n}\n\nstatic void npcm_i2c_read_fifo(struct npcm_i2c *bus, u8 bytes_in_fifo)\n{\n\tu8 data;\n\n\twhile (bytes_in_fifo--) {\n\t\tdata = npcm_i2c_rd_byte(bus);\n\t\tif (bus->rd_ind < bus->rd_size)\n\t\t\tbus->rd_buf[bus->rd_ind++] = data;\n\t}\n}\n\nstatic void npcm_i2c_master_abort(struct npcm_i2c *bus)\n{\n\t \n\tif (!npcm_i2c_is_master(bus))\n\t\treturn;\n\n\tnpcm_i2c_eob_int(bus, true);\n\tnpcm_i2c_master_stop(bus);\n\tnpcm_i2c_clear_master_status(bus);\n}\n\n#if IS_ENABLED(CONFIG_I2C_SLAVE)\nstatic u8 npcm_i2c_get_slave_addr(struct npcm_i2c *bus, enum i2c_addr addr_type)\n{\n\tu8 slave_add;\n\n\tif (addr_type > I2C_SLAVE_ADDR2 && addr_type <= I2C_SLAVE_ADDR10)\n\t\tdev_err(bus->dev, \"get slave: try to use more than 2 SA not supported\\n\");\n\n\tslave_add = ioread8(bus->reg + npcm_i2caddr[(int)addr_type]);\n\n\treturn slave_add;\n}\n\nstatic int npcm_i2c_remove_slave_addr(struct npcm_i2c *bus, u8 slave_add)\n{\n\tint i;\n\n\t \n\tslave_add |= 0x80;\n\n\tfor (i = I2C_SLAVE_ADDR1; i < I2C_NUM_OWN_ADDR_SUPPORTED; i++) {\n\t\tif (ioread8(bus->reg + npcm_i2caddr[i]) == slave_add)\n\t\t\tiowrite8(0, bus->reg + npcm_i2caddr[i]);\n\t}\n\n\treturn 0;\n}\n\nstatic void npcm_i2c_write_fifo_slave(struct npcm_i2c *bus, u16 max_bytes)\n{\n\t \n\tnpcm_i2c_clear_fifo_int(bus);\n\tnpcm_i2c_clear_tx_fifo(bus);\n\tiowrite8(0, bus->reg + NPCM_I2CTXF_CTL);\n\twhile (max_bytes-- && bus->data->fifo_size != npcm_i2c_fifo_usage(bus)) {\n\t\tif (bus->slv_wr_size <= 0)\n\t\t\tbreak;\n\t\tbus->slv_wr_ind = bus->slv_wr_ind & (bus->data->fifo_size - 1);\n\t\tnpcm_i2c_wr_byte(bus, bus->slv_wr_buf[bus->slv_wr_ind]);\n\t\tbus->slv_wr_ind++;\n\t\tbus->slv_wr_ind = bus->slv_wr_ind & (bus->data->fifo_size - 1);\n\t\tbus->slv_wr_size--;\n\t}\n}\n\nstatic void npcm_i2c_read_fifo_slave(struct npcm_i2c *bus, u8 bytes_in_fifo)\n{\n\tu8 data;\n\n\tif (!bus->slave)\n\t\treturn;\n\n\twhile (bytes_in_fifo--) {\n\t\tdata = npcm_i2c_rd_byte(bus);\n\n\t\tbus->slv_rd_ind = bus->slv_rd_ind & (bus->data->fifo_size - 1);\n\t\tbus->slv_rd_buf[bus->slv_rd_ind] = data;\n\t\tbus->slv_rd_ind++;\n\n\t\t \n\t\tif (bus->slv_rd_ind == 1 && bus->read_block_use)\n\t\t\tbus->slv_rd_size = data + bus->PEC_use + 1;\n\t}\n}\n\nstatic int npcm_i2c_slave_get_wr_buf(struct npcm_i2c *bus)\n{\n\tint i;\n\tu8 value;\n\tint ind;\n\tint ret = bus->slv_wr_ind;\n\n\t \n\tfor (i = 0; i < bus->data->fifo_size; i++) {\n\t\tif (bus->slv_wr_size >= bus->data->fifo_size)\n\t\t\tbreak;\n\t\tif (bus->state == I2C_SLAVE_MATCH) {\n\t\t\ti2c_slave_event(bus->slave, I2C_SLAVE_READ_REQUESTED, &value);\n\t\t\tbus->state = I2C_OPER_STARTED;\n\t\t} else {\n\t\t\ti2c_slave_event(bus->slave, I2C_SLAVE_READ_PROCESSED, &value);\n\t\t}\n\t\tind = (bus->slv_wr_ind + bus->slv_wr_size) & (bus->data->fifo_size - 1);\n\t\tbus->slv_wr_buf[ind] = value;\n\t\tbus->slv_wr_size++;\n\t}\n\treturn bus->data->fifo_size - ret;\n}\n\nstatic void npcm_i2c_slave_send_rd_buf(struct npcm_i2c *bus)\n{\n\tint i;\n\n\tfor (i = 0; i < bus->slv_rd_ind; i++)\n\t\ti2c_slave_event(bus->slave, I2C_SLAVE_WRITE_RECEIVED,\n\t\t\t\t&bus->slv_rd_buf[i]);\n\t \n\tif (bus->slv_rd_ind) {\n\t\tbus->slv_wr_size = 0;\n\t\tbus->slv_wr_ind = 0;\n\t}\n\n\tbus->slv_rd_ind = 0;\n\tbus->slv_rd_size = bus->adap.quirks->max_read_len;\n\n\tnpcm_i2c_clear_fifo_int(bus);\n\tnpcm_i2c_clear_rx_fifo(bus);\n}\n\nstatic void npcm_i2c_slave_receive(struct npcm_i2c *bus, u16 nread,\n\t\t\t\t   u8 *read_data)\n{\n\tbus->state = I2C_OPER_STARTED;\n\tbus->operation = I2C_READ_OPER;\n\tbus->slv_rd_size = nread;\n\tbus->slv_rd_ind = 0;\n\n\tiowrite8(0, bus->reg + NPCM_I2CTXF_CTL);\n\tiowrite8(bus->data->fifo_size, bus->reg + NPCM_I2CRXF_CTL);\n\tnpcm_i2c_clear_tx_fifo(bus);\n\tnpcm_i2c_clear_rx_fifo(bus);\n}\n\nstatic void npcm_i2c_slave_xmit(struct npcm_i2c *bus, u16 nwrite,\n\t\t\t\tu8 *write_data)\n{\n\tif (nwrite == 0)\n\t\treturn;\n\n\tbus->operation = I2C_WRITE_OPER;\n\n\t \n\tnpcm_i2c_slave_get_wr_buf(bus);\n\tnpcm_i2c_write_fifo_slave(bus, nwrite);\n}\n\n \nstatic void npcm_i2c_slave_wr_buf_sync(struct npcm_i2c *bus)\n{\n\tint left_in_fifo;\n\n\tleft_in_fifo = bus->data->txf_sts_tx_bytes &\n\t\t\tioread8(bus->reg + NPCM_I2CTXF_STS);\n\n\t \n\tif (left_in_fifo >= bus->data->fifo_size ||\n\t    bus->slv_wr_size >= bus->data->fifo_size)\n\t\treturn;\n\n\t \n\tbus->slv_wr_ind = bus->slv_wr_ind - left_in_fifo;\n\tbus->slv_wr_size = bus->slv_wr_size + left_in_fifo;\n\n\tif (bus->slv_wr_ind < 0)\n\t\tbus->slv_wr_ind += bus->data->fifo_size;\n}\n\nstatic void npcm_i2c_slave_rd_wr(struct npcm_i2c *bus)\n{\n\tif (NPCM_I2CST_XMIT & ioread8(bus->reg + NPCM_I2CST)) {\n\t\t \n\t\tbus->operation = I2C_WRITE_OPER;\n\t\tnpcm_i2c_slave_xmit(bus, bus->adap.quirks->max_write_len,\n\t\t\t\t    bus->slv_wr_buf);\n\t} else {\n\t\t \n\t\tbus->operation = I2C_READ_OPER;\n\t\tnpcm_i2c_read_fifo_slave(bus, npcm_i2c_fifo_usage(bus));\n\t\tbus->stop_ind = I2C_SLAVE_RCV_IND;\n\t\tnpcm_i2c_slave_send_rd_buf(bus);\n\t\tnpcm_i2c_slave_receive(bus, bus->adap.quirks->max_read_len,\n\t\t\t\t       bus->slv_rd_buf);\n\t}\n}\n\nstatic irqreturn_t npcm_i2c_int_slave_handler(struct npcm_i2c *bus)\n{\n\tu8 val;\n\tirqreturn_t ret = IRQ_NONE;\n\tu8 i2cst = ioread8(bus->reg + NPCM_I2CST);\n\n\t \n\tif (NPCM_I2CST_NEGACK & i2cst) {\n\t\tbus->stop_ind = I2C_NACK_IND;\n\t\tnpcm_i2c_slave_wr_buf_sync(bus);\n\t\tif (bus->fifo_use)\n\t\t\t \n\t\t\tiowrite8(NPCM_I2CFIF_CTS_CLR_FIFO,\n\t\t\t\t bus->reg + NPCM_I2CFIF_CTS);\n\n\t\t \n\t\tbus->stop_ind = I2C_NO_STATUS_IND;\n\t\tbus->operation = I2C_NO_OPER;\n\t\tbus->own_slave_addr = 0xFF;\n\n\t\t \n\t\tiowrite8(NPCM_I2CST_NEGACK, bus->reg + NPCM_I2CST);\n\n\t\tret = IRQ_HANDLED;\n\t}\n\n\t \n\tif (NPCM_I2CST_BER & i2cst) {\n\t\t \n\t\tbus->stop_ind = I2C_BUS_ERR_IND;\n\n\t\t \n\t\tiowrite8(NPCM_I2CFIF_CTS_CLR_FIFO, bus->reg + NPCM_I2CFIF_CTS);\n\n\t\tbus->state = I2C_IDLE;\n\n\t\t \n\t\tif (completion_done(&bus->cmd_complete) == false) {\n\t\t\tbus->cmd_err = -EIO;\n\t\t\tcomplete(&bus->cmd_complete);\n\t\t}\n\t\tbus->own_slave_addr = 0xFF;\n\t\tiowrite8(NPCM_I2CST_BER, bus->reg + NPCM_I2CST);\n\t\tret = IRQ_HANDLED;\n\t}\n\n\t \n\tif (NPCM_I2CST_SLVSTP & i2cst) {\n\t\tu8 bytes_in_fifo = npcm_i2c_fifo_usage(bus);\n\n\t\tbus->stop_ind = I2C_SLAVE_DONE_IND;\n\n\t\tif (bus->operation == I2C_READ_OPER)\n\t\t\tnpcm_i2c_read_fifo_slave(bus, bytes_in_fifo);\n\n\t\t \n\t\tnpcm_i2c_slave_send_rd_buf(bus);\n\n\t\t \n\t\tbus->stop_ind = I2C_NO_STATUS_IND;\n\n\t\t \n\t\tbus->operation = I2C_NO_OPER;\n\t\tbus->own_slave_addr = 0xFF;\n\t\ti2c_slave_event(bus->slave, I2C_SLAVE_STOP, 0);\n\t\tiowrite8(NPCM_I2CST_SLVSTP, bus->reg + NPCM_I2CST);\n\t\tif (bus->fifo_use) {\n\t\t\tnpcm_i2c_clear_fifo_int(bus);\n\t\t\tnpcm_i2c_clear_rx_fifo(bus);\n\t\t\tnpcm_i2c_clear_tx_fifo(bus);\n\n\t\t\tiowrite8(NPCM_I2CFIF_CTS_CLR_FIFO,\n\t\t\t\t bus->reg + NPCM_I2CFIF_CTS);\n\t\t}\n\t\tbus->state = I2C_IDLE;\n\t\tret = IRQ_HANDLED;\n\t}\n\n\t \n\tif (bus->fifo_use && FIELD_GET(NPCM_I2CFIF_CTS_SLVRSTR,\n\t\t\t\t       ioread8(bus->reg + NPCM_I2CFIF_CTS))) {\n\t\tbus->stop_ind = I2C_SLAVE_RESTART_IND;\n\t\tbus->master_or_slave = I2C_SLAVE;\n\t\tif (bus->operation == I2C_READ_OPER)\n\t\t\tnpcm_i2c_read_fifo_slave(bus, npcm_i2c_fifo_usage(bus));\n\t\tbus->operation = I2C_WRITE_OPER;\n\t\tiowrite8(0, bus->reg + NPCM_I2CRXF_CTL);\n\t\tval = NPCM_I2CFIF_CTS_CLR_FIFO | NPCM_I2CFIF_CTS_SLVRSTR |\n\t\t      NPCM_I2CFIF_CTS_RXF_TXE;\n\t\tiowrite8(val, bus->reg + NPCM_I2CFIF_CTS);\n\t\tnpcm_i2c_slave_rd_wr(bus);\n\t\tret = IRQ_HANDLED;\n\t}\n\n\t \n\tif (NPCM_I2CST_NMATCH & i2cst) {\n\t\tu8 info = 0;\n\n\t\t \n\t\tbus->master_or_slave = I2C_SLAVE;\n\t\tnpcm_i2c_clear_fifo_int(bus);\n\t\tnpcm_i2c_clear_rx_fifo(bus);\n\t\tnpcm_i2c_clear_tx_fifo(bus);\n\t\tiowrite8(0, bus->reg + NPCM_I2CTXF_CTL);\n\t\tiowrite8(bus->data->fifo_size, bus->reg + NPCM_I2CRXF_CTL);\n\t\tif (NPCM_I2CST_XMIT & i2cst) {\n\t\t\tbus->operation = I2C_WRITE_OPER;\n\t\t} else {\n\t\t\ti2c_slave_event(bus->slave, I2C_SLAVE_WRITE_REQUESTED,\n\t\t\t\t\t&info);\n\t\t\tbus->operation = I2C_READ_OPER;\n\t\t}\n\t\tif (bus->own_slave_addr == 0xFF) {\n\t\t\t \n\t\t\tval = ioread8(bus->reg + NPCM_I2CCST);\n\t\t\tif (NPCM_I2CCST_MATCH & val) {\n\t\t\t\tu16 addr;\n\t\t\t\tenum i2c_addr eaddr;\n\t\t\t\tu8 i2ccst2;\n\t\t\t\tu8 i2ccst3;\n\n\t\t\t\ti2ccst3 = ioread8(bus->reg + NPCM_I2CCST3);\n\t\t\t\ti2ccst2 = ioread8(bus->reg + NPCM_I2CCST2);\n\n\t\t\t\t \n\t\t\t\taddr = ((i2ccst3 & 0x07) << 7) |\n\t\t\t\t\t(i2ccst2 & 0x7F);\n\t\t\t\tinfo = ffs(addr);\n\t\t\t\teaddr = (enum i2c_addr)info;\n\t\t\t\taddr = npcm_i2c_get_slave_addr(bus, eaddr);\n\t\t\t\taddr &= 0x7F;\n\t\t\t\tbus->own_slave_addr = addr;\n\t\t\t\tif (bus->PEC_mask & BIT(info))\n\t\t\t\t\tbus->PEC_use = true;\n\t\t\t\telse\n\t\t\t\t\tbus->PEC_use = false;\n\t\t\t} else {\n\t\t\t\tif (NPCM_I2CCST_GCMATCH & val)\n\t\t\t\t\tbus->own_slave_addr = 0;\n\t\t\t\tif (NPCM_I2CCST_ARPMATCH & val)\n\t\t\t\t\tbus->own_slave_addr = 0x61;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tif ((bus->state == I2C_OPER_STARTED &&\n\t\t\t     bus->operation == I2C_READ_OPER &&\n\t\t\t     bus->stop_ind == I2C_SLAVE_XMIT_IND) ||\n\t\t\t     bus->stop_ind == I2C_SLAVE_RCV_IND) {\n\t\t\t\t \n\t\t\t\tbus->stop_ind = I2C_SLAVE_RESTART_IND;\n\t\t\t}\n\t\t}\n\n\t\tif (NPCM_I2CST_XMIT & i2cst)\n\t\t\tbus->stop_ind = I2C_SLAVE_XMIT_IND;\n\t\telse\n\t\t\tbus->stop_ind = I2C_SLAVE_RCV_IND;\n\t\tbus->state = I2C_SLAVE_MATCH;\n\t\tnpcm_i2c_slave_rd_wr(bus);\n\t\tiowrite8(NPCM_I2CST_NMATCH, bus->reg + NPCM_I2CST);\n\t\tret = IRQ_HANDLED;\n\t}\n\n\t \n\tif ((NPCM_I2CST_SDAST & i2cst) ||\n\t    (bus->fifo_use &&\n\t    (npcm_i2c_tx_fifo_empty(bus) || npcm_i2c_rx_fifo_full(bus)))) {\n\t\tnpcm_i2c_slave_rd_wr(bus);\n\t\tiowrite8(NPCM_I2CST_SDAST, bus->reg + NPCM_I2CST);\n\t\tret = IRQ_HANDLED;\n\t}  \n\n\t \n\tif (ret == IRQ_NONE) {\n\t\tnpcm_i2c_eob_int(bus, false);\n\t\tnpcm_i2c_clear_master_status(bus);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int npcm_i2c_reg_slave(struct i2c_client *client)\n{\n\tunsigned long lock_flags;\n\tstruct npcm_i2c *bus = i2c_get_adapdata(client->adapter);\n\n\tbus->slave = client;\n\n\tif (!bus->slave)\n\t\treturn -EINVAL;\n\n\tif (client->flags & I2C_CLIENT_TEN)\n\t\treturn -EAFNOSUPPORT;\n\n\tspin_lock_irqsave(&bus->lock, lock_flags);\n\n\tnpcm_i2c_init_params(bus);\n\tbus->slv_rd_size = 0;\n\tbus->slv_wr_size = 0;\n\tbus->slv_rd_ind = 0;\n\tbus->slv_wr_ind = 0;\n\tif (client->flags & I2C_CLIENT_PEC)\n\t\tbus->PEC_use = true;\n\n\tdev_info(bus->dev, \"i2c%d register slave SA=0x%x, PEC=%d\\n\", bus->num,\n\t\t client->addr, bus->PEC_use);\n\n\tnpcm_i2c_slave_enable(bus, I2C_SLAVE_ADDR1, client->addr, true);\n\tnpcm_i2c_clear_fifo_int(bus);\n\tnpcm_i2c_clear_rx_fifo(bus);\n\tnpcm_i2c_clear_tx_fifo(bus);\n\tnpcm_i2c_slave_int_enable(bus, true);\n\n\tspin_unlock_irqrestore(&bus->lock, lock_flags);\n\treturn 0;\n}\n\nstatic int npcm_i2c_unreg_slave(struct i2c_client *client)\n{\n\tstruct npcm_i2c *bus = client->adapter->algo_data;\n\tunsigned long lock_flags;\n\n\tspin_lock_irqsave(&bus->lock, lock_flags);\n\tif (!bus->slave) {\n\t\tspin_unlock_irqrestore(&bus->lock, lock_flags);\n\t\treturn -EINVAL;\n\t}\n\tnpcm_i2c_slave_int_enable(bus, false);\n\tnpcm_i2c_remove_slave_addr(bus, client->addr);\n\tbus->slave = NULL;\n\tspin_unlock_irqrestore(&bus->lock, lock_flags);\n\treturn 0;\n}\n#endif  \n\nstatic void npcm_i2c_master_fifo_read(struct npcm_i2c *bus)\n{\n\tint rcount;\n\tint fifo_bytes;\n\tenum i2c_state_ind ind = I2C_MASTER_DONE_IND;\n\n\tfifo_bytes = npcm_i2c_fifo_usage(bus);\n\trcount = bus->rd_size - bus->rd_ind;\n\n\t \n\tif (rcount < (2 * bus->data->fifo_size) && rcount > bus->data->fifo_size)\n\t\tfifo_bytes = rcount - bus->data->fifo_size;\n\n\tif (rcount <= fifo_bytes) {\n\t\t \n\t\tbus->state = I2C_STOP_PENDING;\n\t\tbus->stop_ind = ind;\n\t\tnpcm_i2c_eob_int(bus, true);\n\t\t \n\t\tnpcm_i2c_master_stop(bus);\n\t\tnpcm_i2c_read_fifo(bus, fifo_bytes);\n\t} else {\n\t\tnpcm_i2c_read_fifo(bus, fifo_bytes);\n\t\trcount = bus->rd_size - bus->rd_ind;\n\t\tnpcm_i2c_set_fifo(bus, rcount, -1);\n\t}\n}\n\nstatic void npcm_i2c_irq_master_handler_write(struct npcm_i2c *bus)\n{\n\tu16 wcount;\n\n\tif (bus->fifo_use)\n\t\tnpcm_i2c_clear_tx_fifo(bus);  \n\n\t \n\tif (bus->wr_ind == bus->wr_size) {\n\t\tif (bus->fifo_use && npcm_i2c_fifo_usage(bus) > 0)\n\t\t\t \n\t\t\treturn;\n\n\t\tif (bus->rd_size == 0) {\n\t\t\t \n\t\t\tnpcm_i2c_eob_int(bus, true);\n\t\t\tbus->state = I2C_STOP_PENDING;\n\t\t\tbus->stop_ind = I2C_MASTER_DONE_IND;\n\t\t\tnpcm_i2c_master_stop(bus);\n\t\t\t \n\t\t\tnpcm_i2c_wr_byte(bus, 0xFF);\n\n\t\t} else {\n\t\t\t \n\t\t\tnpcm_i2c_set_fifo(bus, bus->rd_size, -1);\n\t\t\t \n\t\t\tnpcm_i2c_master_start(bus);\n\n\t\t\t \n\t\t\tif (bus->rd_size == 1)\n\t\t\t\tnpcm_i2c_stall_after_start(bus, true);\n\n\t\t\t \n\t\t\tbus->operation = I2C_READ_OPER;\n\t\t\t \n\t\t\tnpcm_i2c_wr_byte(bus, bus->dest_addr | 0x1);\n\t\t}\n\t} else {\n\t\t \n\t\tif (!bus->fifo_use || bus->wr_size == 1) {\n\t\t\tnpcm_i2c_wr_byte(bus, bus->wr_buf[bus->wr_ind++]);\n\t\t} else {\n\t\t\twcount = bus->wr_size - bus->wr_ind;\n\t\t\tnpcm_i2c_set_fifo(bus, -1, wcount);\n\t\t\tif (wcount)\n\t\t\t\tnpcm_i2c_write_to_fifo_master(bus, wcount);\n\t\t}\n\t}\n}\n\nstatic void npcm_i2c_irq_master_handler_read(struct npcm_i2c *bus)\n{\n\tu16 block_extra_bytes_size;\n\tu8 data;\n\n\t \n\tblock_extra_bytes_size = bus->read_block_use + bus->PEC_use;\n\n\t \n\tif (bus->rd_ind == 0) {  \n\t\tif (bus->read_block_use) {\n\t\t\t \n\t\t\tdata = npcm_i2c_rd_byte(bus);\n\t\t\tdata = clamp_val(data, 1, I2C_SMBUS_BLOCK_MAX);\n\t\t\tbus->rd_size = data + block_extra_bytes_size;\n\t\t\tbus->rd_buf[bus->rd_ind++] = data;\n\n\t\t\t \n\t\t\tif (bus->fifo_use) {\n\t\t\t\tdata = ioread8(bus->reg + NPCM_I2CFIF_CTS);\n\t\t\t\tdata = data | NPCM_I2CFIF_CTS_RXF_TXE;\n\t\t\t\tiowrite8(data, bus->reg + NPCM_I2CFIF_CTS);\n\t\t\t}\n\n\t\t\tnpcm_i2c_set_fifo(bus, bus->rd_size - 1, -1);\n\t\t\tnpcm_i2c_stall_after_start(bus, false);\n\t\t} else {\n\t\t\tnpcm_i2c_clear_tx_fifo(bus);\n\t\t\tnpcm_i2c_master_fifo_read(bus);\n\t\t}\n\t} else {\n\t\tif (bus->rd_size == block_extra_bytes_size &&\n\t\t    bus->read_block_use) {\n\t\t\tbus->state = I2C_STOP_PENDING;\n\t\t\tbus->stop_ind = I2C_BLOCK_BYTES_ERR_IND;\n\t\t\tbus->cmd_err = -EIO;\n\t\t\tnpcm_i2c_eob_int(bus, true);\n\t\t\tnpcm_i2c_master_stop(bus);\n\t\t\tnpcm_i2c_read_fifo(bus, npcm_i2c_fifo_usage(bus));\n\t\t} else {\n\t\t\tnpcm_i2c_master_fifo_read(bus);\n\t\t}\n\t}\n}\n\nstatic void npcm_i2c_irq_handle_nmatch(struct npcm_i2c *bus)\n{\n\tiowrite8(NPCM_I2CST_NMATCH, bus->reg + NPCM_I2CST);\n\tnpcm_i2c_nack(bus);\n\tbus->stop_ind = I2C_BUS_ERR_IND;\n\tnpcm_i2c_callback(bus, bus->stop_ind, npcm_i2c_get_index(bus));\n}\n\n \nstatic void npcm_i2c_irq_handle_nack(struct npcm_i2c *bus)\n{\n\tu8 val;\n\n\tif (bus->nack_cnt < ULLONG_MAX)\n\t\tbus->nack_cnt++;\n\n\tif (bus->fifo_use) {\n\t\t \n\t\tif (bus->operation == I2C_WRITE_OPER)\n\t\t\tbus->wr_ind -= npcm_i2c_fifo_usage(bus);\n\n\t\t \n\t\tiowrite8(NPCM_I2CFIF_CTS_CLR_FIFO, bus->reg + NPCM_I2CFIF_CTS);\n\t}\n\n\t \n\tbus->stop_ind = I2C_NACK_IND;\n\t \n\tif (npcm_i2c_is_master(bus)) {\n\t\t \n\t\tnpcm_i2c_eob_int(bus, false);\n\t\tnpcm_i2c_master_stop(bus);\n\n\t\t \n\t\tnpcm_i2c_rd_byte(bus);\n\n\t\t \n\t\tnpcm_i2c_clear_master_status(bus);\n\t\treadx_poll_timeout_atomic(ioread8, bus->reg + NPCM_I2CCST, val,\n\t\t\t\t\t  !(val & NPCM_I2CCST_BUSY), 10, 200);\n\t\t \n\t\tnpcm_i2c_clear_master_status(bus);\n\t}\n\tbus->state = I2C_IDLE;\n\n\t \n\tnpcm_i2c_callback(bus, bus->stop_ind, bus->wr_ind);\n}\n\n\t \nstatic void npcm_i2c_irq_handle_ber(struct npcm_i2c *bus)\n{\n\tif (bus->ber_cnt < ULLONG_MAX)\n\t\tbus->ber_cnt++;\n\tbus->stop_ind = I2C_BUS_ERR_IND;\n\tif (npcm_i2c_is_master(bus)) {\n\t\tnpcm_i2c_master_abort(bus);\n\t} else {\n\t\tnpcm_i2c_clear_master_status(bus);\n\n\t\t \n\t\tiowrite8(NPCM_I2CCST_BB, bus->reg + NPCM_I2CCST);\n\n\t\tbus->cmd_err = -EAGAIN;\n\t\tnpcm_i2c_callback(bus, bus->stop_ind, npcm_i2c_get_index(bus));\n\t}\n\tbus->state = I2C_IDLE;\n}\n\n\t \nstatic void npcm_i2c_irq_handle_eob(struct npcm_i2c *bus)\n{\n\tnpcm_i2c_eob_int(bus, false);\n\tbus->state = I2C_IDLE;\n\tnpcm_i2c_callback(bus, bus->stop_ind, bus->rd_ind);\n}\n\n \nstatic void npcm_i2c_irq_handle_stall_after_start(struct npcm_i2c *bus)\n{\n\tif (npcm_i2c_is_quick(bus)) {\n\t\tbus->state = I2C_STOP_PENDING;\n\t\tbus->stop_ind = I2C_MASTER_DONE_IND;\n\t\tnpcm_i2c_eob_int(bus, true);\n\t\tnpcm_i2c_master_stop(bus);\n\t} else if ((bus->rd_size == 1) && !bus->read_block_use) {\n\t\t \n\t\tnpcm_i2c_nack(bus);\n\t}\n\n\t \n\tnpcm_i2c_stall_after_start(bus, false);\n\n\t \n\tiowrite8(NPCM_I2CST_STASTR, bus->reg + NPCM_I2CST);\n}\n\n \nstatic void npcm_i2c_irq_handle_sda(struct npcm_i2c *bus, u8 i2cst)\n{\n\tu8 fif_cts;\n\n\tif (!npcm_i2c_is_master(bus))\n\t\treturn;\n\n\tif (bus->state == I2C_IDLE) {\n\t\tbus->stop_ind = I2C_WAKE_UP_IND;\n\n\t\tif (npcm_i2c_is_quick(bus) || bus->read_block_use)\n\t\t\t \n\t\t\tnpcm_i2c_stall_after_start(bus, true);\n\t\telse\n\t\t\tnpcm_i2c_stall_after_start(bus, false);\n\n\t\t \n\t\tif (bus->wr_size == 0 && bus->rd_size == 1)\n\t\t\tnpcm_i2c_stall_after_start(bus, true);\n\n\t\t \n\n\t\t \n\t\tnpcm_i2c_select_bank(bus, I2C_BANK_1);\n\n\t\tfif_cts = ioread8(bus->reg + NPCM_I2CFIF_CTS);\n\t\tfif_cts = fif_cts & ~NPCM_I2CFIF_CTS_SLVRSTR;\n\n\t\t \n\t\tfif_cts = fif_cts | NPCM_I2CFIF_CTS_CLR_FIFO;\n\t\tiowrite8(fif_cts, bus->reg + NPCM_I2CFIF_CTS);\n\n\t\t \n\t\tfif_cts = fif_cts | NPCM_I2CFIF_CTS_RXF_TXE;\n\t\tiowrite8(fif_cts, bus->reg + NPCM_I2CFIF_CTS);\n\n\t\t \n\t\tif (bus->wr_size)\n\t\t\tnpcm_i2c_set_fifo(bus, -1, bus->wr_size);\n\t\telse\n\t\t\tnpcm_i2c_set_fifo(bus, bus->rd_size, -1);\n\n\t\tbus->state = I2C_OPER_STARTED;\n\n\t\tif (npcm_i2c_is_quick(bus) || bus->wr_size)\n\t\t\tnpcm_i2c_wr_byte(bus, bus->dest_addr);\n\t\telse\n\t\t\tnpcm_i2c_wr_byte(bus, bus->dest_addr | BIT(0));\n\t \n\t} else {\n\t\tif (NPCM_I2CST_XMIT & i2cst) {\n\t\t\tbus->operation = I2C_WRITE_OPER;\n\t\t\tnpcm_i2c_irq_master_handler_write(bus);\n\t\t} else {\n\t\t\tbus->operation = I2C_READ_OPER;\n\t\t\tnpcm_i2c_irq_master_handler_read(bus);\n\t\t}\n\t}\n}\n\nstatic int npcm_i2c_int_master_handler(struct npcm_i2c *bus)\n{\n\tu8 i2cst;\n\tint ret = -EIO;\n\n\ti2cst = ioread8(bus->reg + NPCM_I2CST);\n\n\tif (FIELD_GET(NPCM_I2CST_NMATCH, i2cst)) {\n\t\tnpcm_i2c_irq_handle_nmatch(bus);\n\t\treturn 0;\n\t}\n\t \n\tif (FIELD_GET(NPCM_I2CST_NEGACK, i2cst)) {\n\t\tnpcm_i2c_irq_handle_nack(bus);\n\t\treturn 0;\n\t}\n\n\t \n\tif (FIELD_GET(NPCM_I2CST_BER, i2cst)) {\n\t\tnpcm_i2c_irq_handle_ber(bus);\n\t\treturn 0;\n\t}\n\n\t \n\tif ((FIELD_GET(NPCM_I2CCTL1_EOBINTE,\n\t\t       ioread8(bus->reg + NPCM_I2CCTL1)) == 1) &&\n\t    (FIELD_GET(NPCM_I2CCST3_EO_BUSY,\n\t\t       ioread8(bus->reg + NPCM_I2CCST3)))) {\n\t\tnpcm_i2c_irq_handle_eob(bus);\n\t\treturn 0;\n\t}\n\n\t \n\tif (FIELD_GET(NPCM_I2CST_STASTR, i2cst)) {\n\t\tnpcm_i2c_irq_handle_stall_after_start(bus);\n\t\tret = 0;\n\t}\n\n\t \n\tif (FIELD_GET(NPCM_I2CST_SDAST, i2cst) ||\n\t    (bus->fifo_use &&\n\t    (npcm_i2c_tx_fifo_empty(bus) || npcm_i2c_rx_fifo_full(bus)))) {\n\t\tnpcm_i2c_irq_handle_sda(bus, i2cst);\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}\n\n \nstatic int npcm_i2c_recovery_tgclk(struct i2c_adapter *_adap)\n{\n\tu8               val;\n\tu8               fif_cts;\n\tbool             done = false;\n\tint              status = -ENOTRECOVERABLE;\n\tstruct npcm_i2c *bus = container_of(_adap, struct npcm_i2c, adap);\n\t \n\tint              iter = 27;\n\n\tif ((npcm_i2c_get_SDA(_adap) == 1) && (npcm_i2c_get_SCL(_adap) == 1)) {\n\t\tdev_dbg(bus->dev, \"bus%d-0x%x recovery skipped, bus not stuck\",\n\t\t\tbus->num, bus->dest_addr);\n\t\tnpcm_i2c_reset(bus);\n\t\treturn 0;\n\t}\n\n\tnpcm_i2c_int_enable(bus, false);\n\tnpcm_i2c_disable(bus);\n\tnpcm_i2c_enable(bus);\n\tiowrite8(NPCM_I2CCST_BB, bus->reg + NPCM_I2CCST);\n\tnpcm_i2c_clear_tx_fifo(bus);\n\tnpcm_i2c_clear_rx_fifo(bus);\n\tiowrite8(0, bus->reg + NPCM_I2CRXF_CTL);\n\tiowrite8(0, bus->reg + NPCM_I2CTXF_CTL);\n\tnpcm_i2c_stall_after_start(bus, false);\n\n\t \n\tnpcm_i2c_select_bank(bus, I2C_BANK_1);\n\n\t \n\tfif_cts = ioread8(bus->reg + NPCM_I2CFIF_CTS);\n\tfif_cts &= ~NPCM_I2CFIF_CTS_SLVRSTR;\n\tfif_cts |= NPCM_I2CFIF_CTS_CLR_FIFO;\n\tiowrite8(fif_cts, bus->reg + NPCM_I2CFIF_CTS);\n\tnpcm_i2c_set_fifo(bus, -1, 0);\n\n\t \n\tdo {\n\t\t \n\t\tiowrite8(NPCM_I2CCST_TGSCL, bus->reg + NPCM_I2CCST);\n\t\tusleep_range(20, 30);\n\t\t \n\t\tif (npcm_i2c_get_SDA(_adap)) {\n\t\t\tdone = true;\n\t\t\tstatus = 0;\n\t\t}\n\t} while (!done && iter--);\n\n\t \n\tif (npcm_i2c_get_SDA(_adap)) {\n\t\t \n\t\tnpcm_i2c_wr_byte(bus, bus->dest_addr);\n\t\tnpcm_i2c_master_start(bus);\n\t\t \n\t\tstatus = readx_poll_timeout(npcm_i2c_get_SCL, _adap, val, !val,\n\t\t\t\t\t    20, 200);\n\t\t \n\t\tif (npcm_i2c_is_master(bus) > 0) {\n\t\t\tusleep_range(20, 30);\n\t\t\tnpcm_i2c_master_stop(bus);\n\t\t\tusleep_range(200, 500);\n\t\t}\n\t}\n\tnpcm_i2c_reset(bus);\n\tnpcm_i2c_int_enable(bus, true);\n\n\tif ((npcm_i2c_get_SDA(_adap) == 1) && (npcm_i2c_get_SCL(_adap) == 1))\n\t\tstatus = 0;\n\telse\n\t\tstatus = -ENOTRECOVERABLE;\n\tif (status) {\n\t\tif (bus->rec_fail_cnt < ULLONG_MAX)\n\t\t\tbus->rec_fail_cnt++;\n\t} else {\n\t\tif (bus->rec_succ_cnt < ULLONG_MAX)\n\t\t\tbus->rec_succ_cnt++;\n\t}\n\treturn status;\n}\n\n \nstatic void npcm_i2c_recovery_init(struct i2c_adapter *_adap)\n{\n\tstruct npcm_i2c *bus = container_of(_adap, struct npcm_i2c, adap);\n\tstruct i2c_bus_recovery_info *rinfo = &bus->rinfo;\n\n\trinfo->recover_bus = npcm_i2c_recovery_tgclk;\n\n\t \n\trinfo->get_scl = npcm_i2c_get_SCL;\n\trinfo->get_sda = npcm_i2c_get_SDA;\n\t_adap->bus_recovery_info = rinfo;\n}\n\n \n#define SCLFRQ_MIN  10\n#define SCLFRQ_MAX  511\n#define clk_coef(freq, mul)\tDIV_ROUND_UP((freq) * (mul), 1000000)\n\n \nstatic int npcm_i2c_init_clk(struct npcm_i2c *bus, u32 bus_freq_hz)\n{\n\tu32  k1 = 0;\n\tu32  k2 = 0;\n\tu8   dbnct = 0;\n\tu32  sclfrq = 0;\n\tu8   hldt = 7;\n\tu8   fast_mode = 0;\n\tu32  src_clk_khz;\n\tu32  bus_freq_khz;\n\n\tsrc_clk_khz = bus->apb_clk / 1000;\n\tbus_freq_khz = bus_freq_hz / 1000;\n\tbus->bus_freq = bus_freq_hz;\n\n\t \n\tif (bus_freq_hz <= I2C_MAX_STANDARD_MODE_FREQ) {\n\t\tsclfrq = src_clk_khz / (bus_freq_khz * 4);\n\n\t\tif (sclfrq < SCLFRQ_MIN || sclfrq > SCLFRQ_MAX)\n\t\t\treturn -EDOM;\n\n\t\tif (src_clk_khz >= 40000)\n\t\t\thldt = 17;\n\t\telse if (src_clk_khz >= 12500)\n\t\t\thldt = 15;\n\t\telse\n\t\t\thldt = 7;\n\t}\n\n\t \n\telse if (bus_freq_hz <= I2C_MAX_FAST_MODE_FREQ) {\n\t\tsclfrq = 0;\n\t\tfast_mode = I2CCTL3_400K_MODE;\n\n\t\tif (src_clk_khz < 7500)\n\t\t\t \n\t\t\treturn -EDOM;\n\n\t\telse if (src_clk_khz >= 50000) {\n\t\t\tk1 = 80;\n\t\t\tk2 = 48;\n\t\t\thldt = 12;\n\t\t\tdbnct = 7;\n\t\t}\n\n\t\t \n\t\telse if (src_clk_khz > 25000) {\n\t\t\thldt = clk_coef(src_clk_khz, 300) + 7;\n\t\t\tk1 = clk_coef(src_clk_khz, 1600);\n\t\t\tk2 = clk_coef(src_clk_khz, 900);\n\t\t}\n\t}\n\n\t \n\telse if (bus_freq_hz <= I2C_MAX_FAST_MODE_PLUS_FREQ) {\n\t\tsclfrq = 0;\n\t\tfast_mode = I2CCTL3_400K_MODE;\n\n\t\t \n\t\tif (src_clk_khz < 24000)\n\t\t\treturn -EDOM;\n\n\t\tk1 = clk_coef(src_clk_khz, 620);\n\t\tk2 = clk_coef(src_clk_khz, 380);\n\n\t\t \n\t\tif (src_clk_khz > 40000) {\n\t\t\t \n\t\t\thldt = clk_coef(src_clk_khz, 120) + 7;\n\t\t} else {\n\t\t\thldt = 7;\n\t\t\tdbnct = 2;\n\t\t}\n\t}\n\n\t \n\telse\n\t\treturn -EINVAL;\n\n\tif (bus_freq_hz >= I2C_MAX_FAST_MODE_FREQ) {\n\t\tk1 = round_up(k1, 2);\n\t\tk2 = round_up(k2 + 1, 2);\n\t\tif (k1 < SCLFRQ_MIN || k1 > SCLFRQ_MAX ||\n\t\t    k2 < SCLFRQ_MIN || k2 > SCLFRQ_MAX)\n\t\t\treturn -EDOM;\n\t}\n\n\t \n\tiowrite8(FIELD_PREP(I2CCTL2_SCLFRQ6_0, sclfrq & 0x7F),\n\t\t bus->reg + NPCM_I2CCTL2);\n\n\t \n\tiowrite8(fast_mode | FIELD_PREP(I2CCTL3_SCLFRQ8_7, (sclfrq >> 7) & 0x3),\n\t\t bus->reg + NPCM_I2CCTL3);\n\n\t \n\tnpcm_i2c_select_bank(bus, I2C_BANK_0);\n\n\tif (bus_freq_hz >= I2C_MAX_FAST_MODE_FREQ) {\n\t\t \n\t\tiowrite8(k1 / 2, bus->reg + NPCM_I2CSCLLT);\n\t\tiowrite8(k2 / 2, bus->reg + NPCM_I2CSCLHT);\n\n\t\tiowrite8(dbnct, bus->reg + NPCM_I2CCTL5);\n\t}\n\n\tiowrite8(hldt, bus->reg + NPCM_I2CCTL4);\n\n\t \n\tnpcm_i2c_select_bank(bus, I2C_BANK_1);\n\n\treturn 0;\n}\n\nstatic int npcm_i2c_init_module(struct npcm_i2c *bus, enum i2c_mode mode,\n\t\t\t\tu32 bus_freq_hz)\n{\n\tu8 val;\n\tint ret;\n\n\t \n\tif ((bus->state != I2C_DISABLE && bus->state != I2C_IDLE) ||\n\t    bus_freq_hz < I2C_FREQ_MIN_HZ || bus_freq_hz > I2C_FREQ_MAX_HZ)\n\t\treturn -EINVAL;\n\n\tnpcm_i2c_int_enable(bus, false);\n\tnpcm_i2c_disable(bus);\n\n\t \n\tif (FIELD_GET(I2C_VER_FIFO_EN, ioread8(bus->reg + I2C_VER))) {\n\t\tbus->fifo_use = true;\n\t\tnpcm_i2c_select_bank(bus, I2C_BANK_0);\n\t\tval = ioread8(bus->reg + NPCM_I2CFIF_CTL);\n\t\tval |= NPCM_I2CFIF_CTL_FIFO_EN;\n\t\tiowrite8(val, bus->reg + NPCM_I2CFIF_CTL);\n\t\tnpcm_i2c_select_bank(bus, I2C_BANK_1);\n\t} else {\n\t\tbus->fifo_use = false;\n\t}\n\n\t \n\tret = npcm_i2c_init_clk(bus, bus_freq_hz);\n\tif (ret) {\n\t\tdev_err(bus->dev, \"npcm_i2c_init_clk failed\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tnpcm_i2c_enable(bus);\n\tbus->state = I2C_IDLE;\n\tval = ioread8(bus->reg + NPCM_I2CCTL1);\n\tval = (val | NPCM_I2CCTL1_NMINTE) & ~NPCM_I2CCTL1_RWS;\n\tiowrite8(val, bus->reg + NPCM_I2CCTL1);\n\n\tnpcm_i2c_reset(bus);\n\n\t \n\tif ((npcm_i2c_get_SDA(&bus->adap) == 0) || (npcm_i2c_get_SCL(&bus->adap) == 0)) {\n\t\tdev_err(bus->dev, \"I2C%d init fail: lines are low\\n\", bus->num);\n\t\tdev_err(bus->dev, \"SDA=%d SCL=%d\\n\", npcm_i2c_get_SDA(&bus->adap),\n\t\t\tnpcm_i2c_get_SCL(&bus->adap));\n\t\treturn -ENXIO;\n\t}\n\n\tnpcm_i2c_int_enable(bus, true);\n\treturn 0;\n}\n\nstatic int __npcm_i2c_init(struct npcm_i2c *bus, struct platform_device *pdev)\n{\n\tu32 clk_freq_hz;\n\tint ret;\n\n\t \n\tbus->state = I2C_DISABLE;\n\tbus->master_or_slave = I2C_SLAVE;\n\tbus->int_time_stamp = 0;\n#if IS_ENABLED(CONFIG_I2C_SLAVE)\n\tbus->slave = NULL;\n#endif\n\n\tret = device_property_read_u32(&pdev->dev, \"clock-frequency\",\n\t\t\t\t       &clk_freq_hz);\n\tif (ret) {\n\t\tdev_info(&pdev->dev, \"Could not read clock-frequency property\");\n\t\tclk_freq_hz = I2C_MAX_STANDARD_MODE_FREQ;\n\t}\n\n\tret = npcm_i2c_init_module(bus, I2C_MASTER, clk_freq_hz);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"npcm_i2c_init_module failed\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic irqreturn_t npcm_i2c_bus_irq(int irq, void *dev_id)\n{\n\tstruct npcm_i2c *bus = dev_id;\n\n\tif (npcm_i2c_is_master(bus))\n\t\tbus->master_or_slave = I2C_MASTER;\n\n\tif (bus->master_or_slave == I2C_MASTER) {\n\t\tbus->int_time_stamp = jiffies;\n\t\tif (!npcm_i2c_int_master_handler(bus))\n\t\t\treturn IRQ_HANDLED;\n\t}\n#if IS_ENABLED(CONFIG_I2C_SLAVE)\n\tif (bus->slave) {\n\t\tbus->master_or_slave = I2C_SLAVE;\n\t\tif (npcm_i2c_int_slave_handler(bus))\n\t\t\treturn IRQ_HANDLED;\n\t}\n#endif\n\t \n\tnpcm_i2c_clear_master_status(bus);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic bool npcm_i2c_master_start_xmit(struct npcm_i2c *bus,\n\t\t\t\t       u8 slave_addr, u16 nwrite, u16 nread,\n\t\t\t\t       u8 *write_data, u8 *read_data,\n\t\t\t\t       bool use_PEC, bool use_read_block)\n{\n\tif (bus->state != I2C_IDLE) {\n\t\tbus->cmd_err = -EBUSY;\n\t\treturn false;\n\t}\n\tbus->dest_addr = slave_addr << 1;\n\tbus->wr_buf = write_data;\n\tbus->wr_size = nwrite;\n\tbus->wr_ind = 0;\n\tbus->rd_buf = read_data;\n\tbus->rd_size = nread;\n\tbus->rd_ind = 0;\n\tbus->PEC_use = 0;\n\n\t \n\tif (nread)\n\t\tbus->PEC_use = use_PEC;\n\n\tbus->read_block_use = use_read_block;\n\tif (nread && !nwrite)\n\t\tbus->operation = I2C_READ_OPER;\n\telse\n\t\tbus->operation = I2C_WRITE_OPER;\n\tif (bus->fifo_use) {\n\t\tu8 i2cfif_cts;\n\n\t\tnpcm_i2c_select_bank(bus, I2C_BANK_1);\n\t\t \n\t\ti2cfif_cts = ioread8(bus->reg + NPCM_I2CFIF_CTS);\n\t\ti2cfif_cts &= ~NPCM_I2CFIF_CTS_SLVRSTR;\n\t\ti2cfif_cts |= NPCM_I2CFIF_CTS_CLR_FIFO;\n\t\tiowrite8(i2cfif_cts, bus->reg + NPCM_I2CFIF_CTS);\n\t}\n\n\tbus->state = I2C_IDLE;\n\tnpcm_i2c_stall_after_start(bus, true);\n\tnpcm_i2c_master_start(bus);\n\treturn true;\n}\n\nstatic int npcm_i2c_master_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs,\n\t\t\t\tint num)\n{\n\tstruct npcm_i2c *bus = container_of(adap, struct npcm_i2c, adap);\n\tstruct i2c_msg *msg0, *msg1;\n\tunsigned long time_left, flags;\n\tu16 nwrite, nread;\n\tu8 *write_data, *read_data;\n\tu8 slave_addr;\n\tunsigned long timeout;\n\tbool read_block = false;\n\tbool read_PEC = false;\n\tu8 bus_busy;\n\tunsigned long timeout_usec;\n\n\tif (bus->state == I2C_DISABLE) {\n\t\tdev_err(bus->dev, \"I2C%d module is disabled\", bus->num);\n\t\treturn -EINVAL;\n\t}\n\n\tmsg0 = &msgs[0];\n\tslave_addr = msg0->addr;\n\tif (msg0->flags & I2C_M_RD) {  \n\t\tnwrite = 0;\n\t\twrite_data = NULL;\n\t\tread_data = msg0->buf;\n\t\tif (msg0->flags & I2C_M_RECV_LEN) {\n\t\t\tnread = 1;\n\t\t\tread_block = true;\n\t\t\tif (msg0->flags & I2C_CLIENT_PEC)\n\t\t\t\tread_PEC = true;\n\t\t} else {\n\t\t\tnread = msg0->len;\n\t\t}\n\t} else {  \n\t\tnwrite = msg0->len;\n\t\twrite_data = msg0->buf;\n\t\tnread = 0;\n\t\tread_data = NULL;\n\t\tif (num == 2) {\n\t\t\tmsg1 = &msgs[1];\n\t\t\tread_data = msg1->buf;\n\t\t\tif (msg1->flags & I2C_M_RECV_LEN) {\n\t\t\t\tnread = 1;\n\t\t\t\tread_block = true;\n\t\t\t\tif (msg1->flags & I2C_CLIENT_PEC)\n\t\t\t\t\tread_PEC = true;\n\t\t\t} else {\n\t\t\t\tnread = msg1->len;\n\t\t\t\tread_block = false;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\ttimeout_usec = (2 * 9 * USEC_PER_SEC / bus->bus_freq) * (2 + nread + nwrite);\n\ttimeout = max_t(unsigned long, bus->adap.timeout, usecs_to_jiffies(timeout_usec));\n\tif (nwrite >= 32 * 1024 || nread >= 32 * 1024) {\n\t\tdev_err(bus->dev, \"i2c%d buffer too big\\n\", bus->num);\n\t\treturn -EINVAL;\n\t}\n\n\ttime_left = jiffies + timeout + 1;\n\tdo {\n\t\t \n\t\tspin_lock_irqsave(&bus->lock, flags);\n\t\tbus_busy = ioread8(bus->reg + NPCM_I2CCST) & NPCM_I2CCST_BB;\n#if IS_ENABLED(CONFIG_I2C_SLAVE)\n\t\tif (!bus_busy && bus->slave)\n\t\t\tiowrite8((bus->slave->addr & 0x7F),\n\t\t\t\t bus->reg + NPCM_I2CADDR1);\n#endif\n\t\tspin_unlock_irqrestore(&bus->lock, flags);\n\n\t} while (time_is_after_jiffies(time_left) && bus_busy);\n\n\tif (bus_busy) {\n\t\tiowrite8(NPCM_I2CCST_BB, bus->reg + NPCM_I2CCST);\n\t\tnpcm_i2c_reset(bus);\n\t\ti2c_recover_bus(adap);\n\t\treturn -EAGAIN;\n\t}\n\n\tnpcm_i2c_init_params(bus);\n\tbus->dest_addr = slave_addr;\n\tbus->msgs = msgs;\n\tbus->msgs_num = num;\n\tbus->cmd_err = 0;\n\tbus->read_block_use = read_block;\n\n\treinit_completion(&bus->cmd_complete);\n\n\tnpcm_i2c_int_enable(bus, true);\n\n\tif (npcm_i2c_master_start_xmit(bus, slave_addr, nwrite, nread,\n\t\t\t\t       write_data, read_data, read_PEC,\n\t\t\t\t       read_block)) {\n\t\ttime_left = wait_for_completion_timeout(&bus->cmd_complete,\n\t\t\t\t\t\t\ttimeout);\n\n\t\tif (time_left == 0) {\n\t\t\tif (bus->timeout_cnt < ULLONG_MAX)\n\t\t\t\tbus->timeout_cnt++;\n\t\t\tif (bus->master_or_slave == I2C_MASTER) {\n\t\t\t\ti2c_recover_bus(adap);\n\t\t\t\tbus->cmd_err = -EIO;\n\t\t\t\tbus->state = I2C_IDLE;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (bus->cmd_err == -EAGAIN)\n\t\tbus->cmd_err = i2c_recover_bus(adap);\n\n\t \n\telse if (bus->cmd_err &&\n\t\t (bus->data->rxf_ctl_last_pec & ioread8(bus->reg + NPCM_I2CRXF_CTL)))\n\t\tnpcm_i2c_reset(bus);\n\n\t \n\tnpcm_i2c_stall_after_start(bus, false);\n\tnpcm_i2c_eob_int(bus, false);\n\n#if IS_ENABLED(CONFIG_I2C_SLAVE)\n\t \n\tif (bus->slave)\n\t\tiowrite8((bus->slave->addr & 0x7F) | NPCM_I2CADDR_SAEN,\n\t\t\t bus->reg + NPCM_I2CADDR1);\n#else\n\tnpcm_i2c_int_enable(bus, false);\n#endif\n\treturn bus->cmd_err;\n}\n\nstatic u32 npcm_i2c_functionality(struct i2c_adapter *adap)\n{\n\treturn I2C_FUNC_I2C |\n\t       I2C_FUNC_SMBUS_EMUL |\n\t       I2C_FUNC_SMBUS_BLOCK_DATA |\n\t       I2C_FUNC_SMBUS_PEC |\n\t       I2C_FUNC_SLAVE;\n}\n\nstatic const struct i2c_adapter_quirks npcm_i2c_quirks = {\n\t.max_read_len = 32768,\n\t.max_write_len = 32768,\n\t.flags = I2C_AQ_COMB_WRITE_THEN_READ,\n};\n\nstatic const struct i2c_algorithm npcm_i2c_algo = {\n\t.master_xfer = npcm_i2c_master_xfer,\n\t.functionality = npcm_i2c_functionality,\n#if IS_ENABLED(CONFIG_I2C_SLAVE)\n\t.reg_slave\t= npcm_i2c_reg_slave,\n\t.unreg_slave\t= npcm_i2c_unreg_slave,\n#endif\n};\n\n \nstatic struct dentry *npcm_i2c_debugfs_dir;\n\nstatic void npcm_i2c_init_debugfs(struct platform_device *pdev,\n\t\t\t\t  struct npcm_i2c *bus)\n{\n\tstruct dentry *d;\n\n\tif (!npcm_i2c_debugfs_dir)\n\t\treturn;\n\td = debugfs_create_dir(dev_name(&pdev->dev), npcm_i2c_debugfs_dir);\n\tif (IS_ERR_OR_NULL(d))\n\t\treturn;\n\tdebugfs_create_u64(\"ber_cnt\", 0444, d, &bus->ber_cnt);\n\tdebugfs_create_u64(\"nack_cnt\", 0444, d, &bus->nack_cnt);\n\tdebugfs_create_u64(\"rec_succ_cnt\", 0444, d, &bus->rec_succ_cnt);\n\tdebugfs_create_u64(\"rec_fail_cnt\", 0444, d, &bus->rec_fail_cnt);\n\tdebugfs_create_u64(\"timeout_cnt\", 0444, d, &bus->timeout_cnt);\n\tdebugfs_create_u64(\"tx_complete_cnt\", 0444, d, &bus->tx_complete_cnt);\n\n\tbus->debugfs = d;\n}\n\nstatic int npcm_i2c_probe_bus(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstatic struct regmap *gcr_regmap;\n\tstruct device *dev = &pdev->dev;\n\tstruct i2c_adapter *adap;\n\tstruct npcm_i2c *bus;\n\tstruct clk *i2c_clk;\n\tint irq;\n\tint ret;\n\n\tbus = devm_kzalloc(&pdev->dev, sizeof(*bus), GFP_KERNEL);\n\tif (!bus)\n\t\treturn -ENOMEM;\n\n\tbus->dev = &pdev->dev;\n\n\tbus->data = of_device_get_match_data(dev);\n\tif (!bus->data) {\n\t\tdev_err(dev, \"OF data missing\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tbus->num = of_alias_get_id(pdev->dev.of_node, \"i2c\");\n\t \n\ti2c_clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(i2c_clk))\n\t\treturn PTR_ERR(i2c_clk);\n\tbus->apb_clk = clk_get_rate(i2c_clk);\n\n\tgcr_regmap = syscon_regmap_lookup_by_phandle(np, \"nuvoton,sys-mgr\");\n\tif (IS_ERR(gcr_regmap))\n\t\tgcr_regmap = syscon_regmap_lookup_by_compatible(\"nuvoton,npcm750-gcr\");\n\n\tif (IS_ERR(gcr_regmap))\n\t\treturn PTR_ERR(gcr_regmap);\n\tregmap_write(gcr_regmap, NPCM_I2CSEGCTL, bus->data->segctl_init_val);\n\n\tbus->reg = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(bus->reg))\n\t\treturn PTR_ERR(bus->reg);\n\n\tspin_lock_init(&bus->lock);\n\tinit_completion(&bus->cmd_complete);\n\n\tadap = &bus->adap;\n\tadap->owner = THIS_MODULE;\n\tadap->retries = 3;\n\tadap->timeout = msecs_to_jiffies(35);\n\tadap->algo = &npcm_i2c_algo;\n\tadap->quirks = &npcm_i2c_quirks;\n\tadap->algo_data = bus;\n\tadap->dev.parent = &pdev->dev;\n\tadap->dev.of_node = pdev->dev.of_node;\n\tadap->nr = pdev->id;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tret = devm_request_irq(bus->dev, irq, npcm_i2c_bus_irq, 0,\n\t\t\t       dev_name(bus->dev), bus);\n\tif (ret)\n\t\treturn ret;\n\n\tret = __npcm_i2c_init(bus, pdev);\n\tif (ret)\n\t\treturn ret;\n\n\tnpcm_i2c_recovery_init(adap);\n\n\ti2c_set_adapdata(adap, bus);\n\n\tsnprintf(bus->adap.name, sizeof(bus->adap.name), \"npcm_i2c_%d\",\n\t\t bus->num);\n\tret = i2c_add_numbered_adapter(&bus->adap);\n\tif (ret)\n\t\treturn ret;\n\n\tplatform_set_drvdata(pdev, bus);\n\tnpcm_i2c_init_debugfs(pdev, bus);\n\treturn 0;\n}\n\nstatic void npcm_i2c_remove_bus(struct platform_device *pdev)\n{\n\tunsigned long lock_flags;\n\tstruct npcm_i2c *bus = platform_get_drvdata(pdev);\n\n\tdebugfs_remove_recursive(bus->debugfs);\n\tspin_lock_irqsave(&bus->lock, lock_flags);\n\tnpcm_i2c_disable(bus);\n\tspin_unlock_irqrestore(&bus->lock, lock_flags);\n\ti2c_del_adapter(&bus->adap);\n}\n\nstatic const struct of_device_id npcm_i2c_bus_of_table[] = {\n\t{ .compatible = \"nuvoton,npcm750-i2c\", .data = &npxm7xx_i2c_data },\n\t{ .compatible = \"nuvoton,npcm845-i2c\", .data = &npxm8xx_i2c_data },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, npcm_i2c_bus_of_table);\n\nstatic struct platform_driver npcm_i2c_bus_driver = {\n\t.probe = npcm_i2c_probe_bus,\n\t.remove_new = npcm_i2c_remove_bus,\n\t.driver = {\n\t\t.name = \"nuvoton-i2c\",\n\t\t.of_match_table = npcm_i2c_bus_of_table,\n\t}\n};\n\nstatic int __init npcm_i2c_init(void)\n{\n\tint ret;\n\n\tnpcm_i2c_debugfs_dir = debugfs_create_dir(\"npcm_i2c\", NULL);\n\n\tret = platform_driver_register(&npcm_i2c_bus_driver);\n\tif (ret) {\n\t\tdebugfs_remove_recursive(npcm_i2c_debugfs_dir);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\nmodule_init(npcm_i2c_init);\n\nstatic void __exit npcm_i2c_exit(void)\n{\n\tplatform_driver_unregister(&npcm_i2c_bus_driver);\n\tdebugfs_remove_recursive(npcm_i2c_debugfs_dir);\n}\nmodule_exit(npcm_i2c_exit);\n\nMODULE_AUTHOR(\"Avi Fishman <avi.fishman@gmail.com>\");\nMODULE_AUTHOR(\"Tali Perry <tali.perry@nuvoton.com>\");\nMODULE_AUTHOR(\"Tyrone Ting <kfting@nuvoton.com>\");\nMODULE_DESCRIPTION(\"Nuvoton I2C Bus Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}