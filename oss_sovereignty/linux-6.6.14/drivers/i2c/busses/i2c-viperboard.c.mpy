{
  "module_name": "i2c-viperboard.c",
  "hash_id": "dd274bc08cc8e63b1fca521766ea2ad0b98fbaef1754300a9afb8eb9129be234",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-viperboard.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/platform_device.h>\n\n#include <linux/usb.h>\n#include <linux/i2c.h>\n\n#include <linux/mfd/viperboard.h>\n\nstruct vprbrd_i2c {\n\tstruct i2c_adapter i2c;\n\tu8 bus_freq_param;\n};\n\n \nstatic u8 i2c_bus_param;\nstatic unsigned int i2c_bus_freq = 100;\nmodule_param(i2c_bus_freq, int, 0);\nMODULE_PARM_DESC(i2c_bus_freq,\n\t\"i2c bus frequency in khz (default is 100) valid values: 10, 100, 200, 400, 1000, 3000, 6000\");\n\nstatic int vprbrd_i2c_status(struct i2c_adapter *i2c,\n\tstruct vprbrd_i2c_status *status, bool prev_error)\n{\n\tu16 bytes_xfer;\n\tint ret;\n\tstruct vprbrd *vb = (struct vprbrd *)i2c->algo_data;\n\n\t \n\tbytes_xfer = sizeof(struct vprbrd_i2c_status);\n\n\tret = usb_control_msg(vb->usb_dev, usb_rcvctrlpipe(vb->usb_dev, 0),\n\t\tVPRBRD_USB_REQUEST_I2C, VPRBRD_USB_TYPE_IN, 0x0000, 0x0000,\n\t\tstatus, bytes_xfer, VPRBRD_USB_TIMEOUT_MS);\n\n\tif (ret != bytes_xfer)\n\t\tprev_error = true;\n\n\tif (prev_error) {\n\t\tdev_err(&i2c->dev, \"failure in usb communication\\n\");\n\t\treturn -EREMOTEIO;\n\t}\n\n\tdev_dbg(&i2c->dev, \"  status = %d\\n\", status->status);\n\tif (status->status != 0x00) {\n\t\tdev_err(&i2c->dev, \"failure: i2c protocol error\\n\");\n\t\treturn -EPROTO;\n\t}\n\treturn 0;\n}\n\nstatic int vprbrd_i2c_receive(struct usb_device *usb_dev,\n\tstruct vprbrd_i2c_read_msg *rmsg, int bytes_xfer)\n{\n\tint ret, bytes_actual;\n\tint error = 0;\n\n\t \n\tret = usb_bulk_msg(usb_dev,\n\t\tusb_sndbulkpipe(usb_dev, VPRBRD_EP_OUT), rmsg,\n\t\tsizeof(struct vprbrd_i2c_read_hdr), &bytes_actual,\n\t\tVPRBRD_USB_TIMEOUT_MS);\n\n\tif ((ret < 0)\n\t\t|| (bytes_actual != sizeof(struct vprbrd_i2c_read_hdr))) {\n\t\tdev_err(&usb_dev->dev, \"failure transmitting usb\\n\");\n\t\terror = -EREMOTEIO;\n\t}\n\n\t \n\tret = usb_bulk_msg(usb_dev,\n\t\tusb_rcvbulkpipe(usb_dev, VPRBRD_EP_IN), rmsg,\n\t\tbytes_xfer, &bytes_actual, VPRBRD_USB_TIMEOUT_MS);\n\n\tif ((ret < 0) || (bytes_xfer != bytes_actual)) {\n\t\tdev_err(&usb_dev->dev, \"failure receiving usb\\n\");\n\t\terror = -EREMOTEIO;\n\t}\n\treturn error;\n}\n\nstatic int vprbrd_i2c_addr(struct usb_device *usb_dev,\n\tstruct vprbrd_i2c_addr_msg *amsg)\n{\n\tint ret, bytes_actual;\n\n\tret = usb_bulk_msg(usb_dev,\n\t\tusb_sndbulkpipe(usb_dev, VPRBRD_EP_OUT), amsg,\n\t\tsizeof(struct vprbrd_i2c_addr_msg), &bytes_actual,\n\t\tVPRBRD_USB_TIMEOUT_MS);\n\n\tif ((ret < 0) ||\n\t\t\t(sizeof(struct vprbrd_i2c_addr_msg) != bytes_actual)) {\n\t\tdev_err(&usb_dev->dev, \"failure transmitting usb\\n\");\n\t\treturn -EREMOTEIO;\n\t}\n\treturn 0;\n}\n\nstatic int vprbrd_i2c_read(struct vprbrd *vb, struct i2c_msg *msg)\n{\n\tint ret;\n\tu16 remain_len, len1, len2, start = 0x0000;\n\tstruct vprbrd_i2c_read_msg *rmsg =\n\t\t(struct vprbrd_i2c_read_msg *)vb->buf;\n\n\tremain_len = msg->len;\n\trmsg->header.cmd = VPRBRD_I2C_CMD_READ;\n\twhile (remain_len > 0) {\n\t\trmsg->header.addr = cpu_to_le16(start + 0x4000);\n\t\tif (remain_len <= 255) {\n\t\t\tlen1 = remain_len;\n\t\t\tlen2 = 0x00;\n\t\t\trmsg->header.len0 = remain_len;\n\t\t\trmsg->header.len1 = 0x00;\n\t\t\trmsg->header.len2 = 0x00;\n\t\t\trmsg->header.len3 = 0x00;\n\t\t\trmsg->header.len4 = 0x00;\n\t\t\trmsg->header.len5 = 0x00;\n\t\t\tremain_len = 0;\n\t\t} else if (remain_len <= 510) {\n\t\t\tlen1 = remain_len;\n\t\t\tlen2 = 0x00;\n\t\t\trmsg->header.len0 = remain_len - 255;\n\t\t\trmsg->header.len1 = 0xff;\n\t\t\trmsg->header.len2 = 0x00;\n\t\t\trmsg->header.len3 = 0x00;\n\t\t\trmsg->header.len4 = 0x00;\n\t\t\trmsg->header.len5 = 0x00;\n\t\t\tremain_len = 0;\n\t\t} else if (remain_len <= 512) {\n\t\t\tlen1 = remain_len;\n\t\t\tlen2 = 0x00;\n\t\t\trmsg->header.len0 = remain_len - 510;\n\t\t\trmsg->header.len1 = 0xff;\n\t\t\trmsg->header.len2 = 0xff;\n\t\t\trmsg->header.len3 = 0x00;\n\t\t\trmsg->header.len4 = 0x00;\n\t\t\trmsg->header.len5 = 0x00;\n\t\t\tremain_len = 0;\n\t\t} else if (remain_len <= 767) {\n\t\t\tlen1 = 512;\n\t\t\tlen2 = remain_len - 512;\n\t\t\trmsg->header.len0 = 0x02;\n\t\t\trmsg->header.len1 = 0xff;\n\t\t\trmsg->header.len2 = 0xff;\n\t\t\trmsg->header.len3 = remain_len - 512;\n\t\t\trmsg->header.len4 = 0x00;\n\t\t\trmsg->header.len5 = 0x00;\n\t\t\tremain_len = 0;\n\t\t} else if (remain_len <= 1022) {\n\t\t\tlen1 = 512;\n\t\t\tlen2 = remain_len - 512;\n\t\t\trmsg->header.len0 = 0x02;\n\t\t\trmsg->header.len1 = 0xff;\n\t\t\trmsg->header.len2 = 0xff;\n\t\t\trmsg->header.len3 = remain_len - 767;\n\t\t\trmsg->header.len4 = 0xff;\n\t\t\trmsg->header.len5 = 0x00;\n\t\t\tremain_len = 0;\n\t\t} else if (remain_len <= 1024) {\n\t\t\tlen1 = 512;\n\t\t\tlen2 = remain_len - 512;\n\t\t\trmsg->header.len0 = 0x02;\n\t\t\trmsg->header.len1 = 0xff;\n\t\t\trmsg->header.len2 = 0xff;\n\t\t\trmsg->header.len3 = remain_len - 1022;\n\t\t\trmsg->header.len4 = 0xff;\n\t\t\trmsg->header.len5 = 0xff;\n\t\t\tremain_len = 0;\n\t\t} else {\n\t\t\tlen1 = 512;\n\t\t\tlen2 = 512;\n\t\t\trmsg->header.len0 = 0x02;\n\t\t\trmsg->header.len1 = 0xff;\n\t\t\trmsg->header.len2 = 0xff;\n\t\t\trmsg->header.len3 = 0x02;\n\t\t\trmsg->header.len4 = 0xff;\n\t\t\trmsg->header.len5 = 0xff;\n\t\t\tremain_len -= 1024;\n\t\t\tstart += 1024;\n\t\t}\n\t\trmsg->header.tf1 = cpu_to_le16(len1);\n\t\trmsg->header.tf2 = cpu_to_le16(len2);\n\n\t\t \n\t\tret = vprbrd_i2c_receive(vb->usb_dev, rmsg, len1);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\t \n\t\tmemcpy(msg->buf + start, rmsg, len1);\n\n\t\t \n\t\tif (len2 > 0) {\n\t\t\tret = vprbrd_i2c_receive(vb->usb_dev, rmsg, len2);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\t \n\t\t\tmemcpy(msg->buf + start + 512, rmsg, len2);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int vprbrd_i2c_write(struct vprbrd *vb, struct i2c_msg *msg)\n{\n\tint ret, bytes_actual;\n\tu16 remain_len, bytes_xfer,\n\t\tstart = 0x0000;\n\tstruct vprbrd_i2c_write_msg *wmsg =\n\t\t(struct vprbrd_i2c_write_msg *)vb->buf;\n\n\tremain_len = msg->len;\n\twmsg->header.cmd = VPRBRD_I2C_CMD_WRITE;\n\twmsg->header.last = 0x00;\n\twmsg->header.chan = 0x00;\n\twmsg->header.spi = 0x0000;\n\twhile (remain_len > 0) {\n\t\twmsg->header.addr = cpu_to_le16(start + 0x4000);\n\t\tif (remain_len > 503) {\n\t\t\twmsg->header.len1 = 0xff;\n\t\t\twmsg->header.len2 = 0xf8;\n\t\t\tremain_len -= 503;\n\t\t\tbytes_xfer = 503 + sizeof(struct vprbrd_i2c_write_hdr);\n\t\t\tstart += 503;\n\t\t} else if (remain_len > 255) {\n\t\t\twmsg->header.len1 = 0xff;\n\t\t\twmsg->header.len2 = (remain_len - 255);\n\t\t\tbytes_xfer = remain_len +\n\t\t\t\tsizeof(struct vprbrd_i2c_write_hdr);\n\t\t\tremain_len = 0;\n\t\t} else {\n\t\t\twmsg->header.len1 = remain_len;\n\t\t\twmsg->header.len2 = 0x00;\n\t\t\tbytes_xfer = remain_len +\n\t\t\t\tsizeof(struct vprbrd_i2c_write_hdr);\n\t\t\tremain_len = 0;\n\t\t}\n\t\tmemcpy(wmsg->data, msg->buf + start,\n\t\t\tbytes_xfer - sizeof(struct vprbrd_i2c_write_hdr));\n\n\t\tret = usb_bulk_msg(vb->usb_dev,\n\t\t\tusb_sndbulkpipe(vb->usb_dev,\n\t\t\tVPRBRD_EP_OUT), wmsg,\n\t\t\tbytes_xfer, &bytes_actual, VPRBRD_USB_TIMEOUT_MS);\n\t\tif ((ret < 0) || (bytes_xfer != bytes_actual))\n\t\t\treturn -EREMOTEIO;\n\t}\n\treturn 0;\n}\n\nstatic int vprbrd_i2c_xfer(struct i2c_adapter *i2c, struct i2c_msg *msgs,\n\t\tint num)\n{\n\tstruct i2c_msg *pmsg;\n\tint i, ret,\n\t\terror = 0;\n\tstruct vprbrd *vb = (struct vprbrd *)i2c->algo_data;\n\tstruct vprbrd_i2c_addr_msg *amsg =\n\t\t(struct vprbrd_i2c_addr_msg *)vb->buf;\n\tstruct vprbrd_i2c_status *smsg = (struct vprbrd_i2c_status *)vb->buf;\n\n\tdev_dbg(&i2c->dev, \"master xfer %d messages:\\n\", num);\n\n\tfor (i = 0 ; i < num ; i++) {\n\t\tpmsg = &msgs[i];\n\n\t\tdev_dbg(&i2c->dev,\n\t\t\t\"  %d: %s (flags %d) %d bytes to 0x%02x\\n\",\n\t\t\ti, pmsg->flags & I2C_M_RD ? \"read\" : \"write\",\n\t\t\tpmsg->flags, pmsg->len, pmsg->addr);\n\n\t\tmutex_lock(&vb->lock);\n\t\t \n\t\tif (pmsg->flags & I2C_M_RD) {\n\t\t\t \n\t\t\tamsg->cmd = VPRBRD_I2C_CMD_ADDR;\n\t\t\tamsg->unknown2 = 0x00;\n\t\t\tamsg->unknown3 = 0x00;\n\t\t\tamsg->addr = pmsg->addr;\n\t\t\tamsg->unknown1 = 0x01;\n\t\t\tamsg->len = cpu_to_le16(pmsg->len);\n\t\t\t \n\t\t\tret = vprbrd_i2c_addr(vb->usb_dev, amsg);\n\t\t\tif (ret < 0)\n\t\t\t\terror = ret;\n\n\t\t\tret = vprbrd_i2c_read(vb, pmsg);\n\t\t\tif (ret < 0)\n\t\t\t\terror = ret;\n\n\t\t\tret = vprbrd_i2c_status(i2c, smsg, error);\n\t\t\tif (ret < 0)\n\t\t\t\terror = ret;\n\t\t\t \n\t\t\tif (error < 0)\n\t\t\t\tgoto error;\n\t\t} else {\n\t\t\t \n\t\t\tret = vprbrd_i2c_write(vb, pmsg);\n\n\t\t\tamsg->cmd = VPRBRD_I2C_CMD_ADDR;\n\t\t\tamsg->unknown2 = 0x00;\n\t\t\tamsg->unknown3 = 0x00;\n\t\t\tamsg->addr = pmsg->addr;\n\t\t\tamsg->unknown1 = 0x00;\n\t\t\tamsg->len = cpu_to_le16(pmsg->len);\n\t\t\t \n\t\t\tret = vprbrd_i2c_addr(vb->usb_dev, amsg);\n\t\t\tif (ret < 0)\n\t\t\t\terror = ret;\n\n\t\t\tret = vprbrd_i2c_status(i2c, smsg, error);\n\t\t\tif (ret < 0)\n\t\t\t\terror = ret;\n\n\t\t\tif (error < 0)\n\t\t\t\tgoto error;\n\t\t}\n\t\tmutex_unlock(&vb->lock);\n\t}\n\treturn num;\nerror:\n\tmutex_unlock(&vb->lock);\n\treturn error;\n}\n\nstatic u32 vprbrd_i2c_func(struct i2c_adapter *i2c)\n{\n\treturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;\n}\n\n \nstatic const struct i2c_algorithm vprbrd_algorithm = {\n\t.master_xfer\t= vprbrd_i2c_xfer,\n\t.functionality\t= vprbrd_i2c_func,\n};\n\nstatic const struct i2c_adapter_quirks vprbrd_quirks = {\n\t.max_read_len = 2048,\n\t.max_write_len = 2048,\n};\n\nstatic int vprbrd_i2c_probe(struct platform_device *pdev)\n{\n\tstruct vprbrd *vb = dev_get_drvdata(pdev->dev.parent);\n\tstruct vprbrd_i2c *vb_i2c;\n\tint ret;\n\tint pipe;\n\n\tvb_i2c = devm_kzalloc(&pdev->dev, sizeof(*vb_i2c), GFP_KERNEL);\n\tif (vb_i2c == NULL)\n\t\treturn -ENOMEM;\n\n\t \n\tvb_i2c->i2c.owner = THIS_MODULE;\n\tvb_i2c->i2c.class = I2C_CLASS_HWMON;\n\tvb_i2c->i2c.algo = &vprbrd_algorithm;\n\tvb_i2c->i2c.quirks = &vprbrd_quirks;\n\tvb_i2c->i2c.algo_data = vb;\n\t \n\tvb_i2c->bus_freq_param = i2c_bus_param;\n\n\tsnprintf(vb_i2c->i2c.name, sizeof(vb_i2c->i2c.name),\n\t\t \"viperboard at bus %03d device %03d\",\n\t\t vb->usb_dev->bus->busnum, vb->usb_dev->devnum);\n\n\t \n\tif ((i2c_bus_param <= VPRBRD_I2C_FREQ_10KHZ)\n\t\t&& (i2c_bus_param >= VPRBRD_I2C_FREQ_6MHZ)) {\n\t\tpipe = usb_sndctrlpipe(vb->usb_dev, 0);\n\t\tret = usb_control_msg(vb->usb_dev, pipe,\n\t\t\tVPRBRD_USB_REQUEST_I2C_FREQ, VPRBRD_USB_TYPE_OUT,\n\t\t\t0x0000, 0x0000, &vb_i2c->bus_freq_param, 1,\n\t\t\tVPRBRD_USB_TIMEOUT_MS);\n\t\tif (ret != 1) {\n\t\t\tdev_err(&pdev->dev, \"failure setting i2c_bus_freq to %d\\n\",\n\t\t\t\ti2c_bus_freq);\n\t\t\treturn -EIO;\n\t\t}\n\t} else {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"invalid i2c_bus_freq setting:%d\\n\", i2c_bus_freq);\n\t\treturn -EIO;\n\t}\n\n\tvb_i2c->i2c.dev.parent = &pdev->dev;\n\n\t \n\ti2c_add_adapter(&vb_i2c->i2c);\n\n\tplatform_set_drvdata(pdev, vb_i2c);\n\n\treturn 0;\n}\n\nstatic void vprbrd_i2c_remove(struct platform_device *pdev)\n{\n\tstruct vprbrd_i2c *vb_i2c = platform_get_drvdata(pdev);\n\n\ti2c_del_adapter(&vb_i2c->i2c);\n}\n\nstatic struct platform_driver vprbrd_i2c_driver = {\n\t.driver.name\t= \"viperboard-i2c\",\n\t.driver.owner\t= THIS_MODULE,\n\t.probe\t\t= vprbrd_i2c_probe,\n\t.remove_new\t= vprbrd_i2c_remove,\n};\n\nstatic int __init vprbrd_i2c_init(void)\n{\n\tswitch (i2c_bus_freq) {\n\tcase 6000:\n\t\ti2c_bus_param = VPRBRD_I2C_FREQ_6MHZ;\n\t\tbreak;\n\tcase 3000:\n\t\ti2c_bus_param = VPRBRD_I2C_FREQ_3MHZ;\n\t\tbreak;\n\tcase 1000:\n\t\ti2c_bus_param = VPRBRD_I2C_FREQ_1MHZ;\n\t\tbreak;\n\tcase 400:\n\t\ti2c_bus_param = VPRBRD_I2C_FREQ_400KHZ;\n\t\tbreak;\n\tcase 200:\n\t\ti2c_bus_param = VPRBRD_I2C_FREQ_200KHZ;\n\t\tbreak;\n\tcase 100:\n\t\ti2c_bus_param = VPRBRD_I2C_FREQ_100KHZ;\n\t\tbreak;\n\tcase 10:\n\t\ti2c_bus_param = VPRBRD_I2C_FREQ_10KHZ;\n\t\tbreak;\n\tdefault:\n\t\tpr_warn(\"invalid i2c_bus_freq (%d)\\n\", i2c_bus_freq);\n\t\ti2c_bus_param = VPRBRD_I2C_FREQ_100KHZ;\n\t}\n\n\treturn platform_driver_register(&vprbrd_i2c_driver);\n}\nsubsys_initcall(vprbrd_i2c_init);\n\nstatic void __exit vprbrd_i2c_exit(void)\n{\n\tplatform_driver_unregister(&vprbrd_i2c_driver);\n}\nmodule_exit(vprbrd_i2c_exit);\n\nMODULE_AUTHOR(\"Lars Poeschel <poeschel@lemonage.de>\");\nMODULE_DESCRIPTION(\"I2C master driver for Nano River Techs Viperboard\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:viperboard-i2c\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}