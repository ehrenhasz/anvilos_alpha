{
  "module_name": "i2c-dln2.c",
  "hash_id": "24432caedcb64bcbfb88fe3eb6392bf73f804d7332818e56dfa034900b9b60d4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-dln2.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/i2c.h>\n#include <linux/platform_device.h>\n#include <linux/mfd/dln2.h>\n#include <linux/acpi.h>\n\n#define DLN2_I2C_MODULE_ID\t\t0x03\n#define DLN2_I2C_CMD(cmd)\t\tDLN2_CMD(cmd, DLN2_I2C_MODULE_ID)\n\n \n#define DLN2_I2C_GET_PORT_COUNT\t\tDLN2_I2C_CMD(0x00)\n#define DLN2_I2C_ENABLE\t\t\tDLN2_I2C_CMD(0x01)\n#define DLN2_I2C_DISABLE\t\tDLN2_I2C_CMD(0x02)\n#define DLN2_I2C_IS_ENABLED\t\tDLN2_I2C_CMD(0x03)\n#define DLN2_I2C_WRITE\t\t\tDLN2_I2C_CMD(0x06)\n#define DLN2_I2C_READ\t\t\tDLN2_I2C_CMD(0x07)\n#define DLN2_I2C_SCAN_DEVICES\t\tDLN2_I2C_CMD(0x08)\n#define DLN2_I2C_PULLUP_ENABLE\t\tDLN2_I2C_CMD(0x09)\n#define DLN2_I2C_PULLUP_DISABLE\t\tDLN2_I2C_CMD(0x0A)\n#define DLN2_I2C_PULLUP_IS_ENABLED\tDLN2_I2C_CMD(0x0B)\n#define DLN2_I2C_TRANSFER\t\tDLN2_I2C_CMD(0x0C)\n#define DLN2_I2C_SET_MAX_REPLY_COUNT\tDLN2_I2C_CMD(0x0D)\n#define DLN2_I2C_GET_MAX_REPLY_COUNT\tDLN2_I2C_CMD(0x0E)\n\n#define DLN2_I2C_MAX_XFER_SIZE\t\t256\n#define DLN2_I2C_BUF_SIZE\t\t(DLN2_I2C_MAX_XFER_SIZE + 16)\n\nstruct dln2_i2c {\n\tstruct platform_device *pdev;\n\tstruct i2c_adapter adapter;\n\tu8 port;\n\t \n\tvoid *buf;\n};\n\nstatic int dln2_i2c_enable(struct dln2_i2c *dln2, bool enable)\n{\n\tu16 cmd;\n\tstruct {\n\t\tu8 port;\n\t} tx;\n\n\ttx.port = dln2->port;\n\n\tif (enable)\n\t\tcmd = DLN2_I2C_ENABLE;\n\telse\n\t\tcmd = DLN2_I2C_DISABLE;\n\n\treturn dln2_transfer_tx(dln2->pdev, cmd, &tx, sizeof(tx));\n}\n\nstatic int dln2_i2c_write(struct dln2_i2c *dln2, u8 addr,\n\t\t\t  u8 *data, u16 data_len)\n{\n\tint ret;\n\tstruct {\n\t\tu8 port;\n\t\tu8 addr;\n\t\tu8 mem_addr_len;\n\t\t__le32 mem_addr;\n\t\t__le16 buf_len;\n\t\tu8 buf[DLN2_I2C_MAX_XFER_SIZE];\n\t} __packed *tx = dln2->buf;\n\tunsigned len;\n\n\tBUILD_BUG_ON(sizeof(*tx) > DLN2_I2C_BUF_SIZE);\n\n\ttx->port = dln2->port;\n\ttx->addr = addr;\n\ttx->mem_addr_len = 0;\n\ttx->mem_addr = 0;\n\ttx->buf_len = cpu_to_le16(data_len);\n\tmemcpy(tx->buf, data, data_len);\n\n\tlen = sizeof(*tx) + data_len - DLN2_I2C_MAX_XFER_SIZE;\n\tret = dln2_transfer_tx(dln2->pdev, DLN2_I2C_WRITE, tx, len);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn data_len;\n}\n\nstatic int dln2_i2c_read(struct dln2_i2c *dln2, u16 addr, u8 *data,\n\t\t\t u16 data_len)\n{\n\tint ret;\n\tstruct {\n\t\tu8 port;\n\t\tu8 addr;\n\t\tu8 mem_addr_len;\n\t\t__le32 mem_addr;\n\t\t__le16 buf_len;\n\t} __packed tx;\n\tstruct {\n\t\t__le16 buf_len;\n\t\tu8 buf[DLN2_I2C_MAX_XFER_SIZE];\n\t} __packed *rx = dln2->buf;\n\tunsigned rx_len = sizeof(*rx);\n\n\tBUILD_BUG_ON(sizeof(*rx) > DLN2_I2C_BUF_SIZE);\n\n\ttx.port = dln2->port;\n\ttx.addr = addr;\n\ttx.mem_addr_len = 0;\n\ttx.mem_addr = 0;\n\ttx.buf_len = cpu_to_le16(data_len);\n\n\tret = dln2_transfer(dln2->pdev, DLN2_I2C_READ, &tx, sizeof(tx),\n\t\t\t    rx, &rx_len);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (rx_len < sizeof(rx->buf_len) + data_len)\n\t\treturn -EPROTO;\n\tif (le16_to_cpu(rx->buf_len) != data_len)\n\t\treturn -EPROTO;\n\n\tmemcpy(data, rx->buf, data_len);\n\n\treturn data_len;\n}\n\nstatic int dln2_i2c_xfer(struct i2c_adapter *adapter,\n\t\t\t struct i2c_msg *msgs, int num)\n{\n\tstruct dln2_i2c *dln2 = i2c_get_adapdata(adapter);\n\tstruct i2c_msg *pmsg;\n\tint i;\n\n\tfor (i = 0; i < num; i++) {\n\t\tint ret;\n\n\t\tpmsg = &msgs[i];\n\n\t\tif (pmsg->flags & I2C_M_RD) {\n\t\t\tret = dln2_i2c_read(dln2, pmsg->addr, pmsg->buf,\n\t\t\t\t\t    pmsg->len);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\n\t\t\tpmsg->len = ret;\n\t\t} else {\n\t\t\tret = dln2_i2c_write(dln2, pmsg->addr, pmsg->buf,\n\t\t\t\t\t     pmsg->len);\n\t\t\tif (ret != pmsg->len)\n\t\t\t\treturn -EPROTO;\n\t\t}\n\t}\n\n\treturn num;\n}\n\nstatic u32 dln2_i2c_func(struct i2c_adapter *a)\n{\n\treturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_BYTE | I2C_FUNC_SMBUS_BYTE_DATA |\n\t\tI2C_FUNC_SMBUS_WORD_DATA | I2C_FUNC_SMBUS_BLOCK_PROC_CALL |\n\t\tI2C_FUNC_SMBUS_I2C_BLOCK;\n}\n\nstatic const struct i2c_algorithm dln2_i2c_usb_algorithm = {\n\t.master_xfer = dln2_i2c_xfer,\n\t.functionality = dln2_i2c_func,\n};\n\nstatic const struct i2c_adapter_quirks dln2_i2c_quirks = {\n\t.max_read_len = DLN2_I2C_MAX_XFER_SIZE,\n\t.max_write_len = DLN2_I2C_MAX_XFER_SIZE,\n};\n\nstatic int dln2_i2c_probe(struct platform_device *pdev)\n{\n\tint ret;\n\tstruct dln2_i2c *dln2;\n\tstruct device *dev = &pdev->dev;\n\tstruct dln2_platform_data *pdata = dev_get_platdata(&pdev->dev);\n\n\tdln2 = devm_kzalloc(dev, sizeof(*dln2), GFP_KERNEL);\n\tif (!dln2)\n\t\treturn -ENOMEM;\n\n\tdln2->buf = devm_kmalloc(dev, DLN2_I2C_BUF_SIZE, GFP_KERNEL);\n\tif (!dln2->buf)\n\t\treturn -ENOMEM;\n\n\tdln2->pdev = pdev;\n\tdln2->port = pdata->port;\n\n\t \n\tdln2->adapter.owner = THIS_MODULE;\n\tdln2->adapter.class = I2C_CLASS_HWMON;\n\tdln2->adapter.algo = &dln2_i2c_usb_algorithm;\n\tdln2->adapter.quirks = &dln2_i2c_quirks;\n\tdln2->adapter.dev.parent = dev;\n\tACPI_COMPANION_SET(&dln2->adapter.dev, ACPI_COMPANION(&pdev->dev));\n\tdln2->adapter.dev.of_node = dev->of_node;\n\ti2c_set_adapdata(&dln2->adapter, dln2);\n\tsnprintf(dln2->adapter.name, sizeof(dln2->adapter.name), \"%s-%s-%d\",\n\t\t \"dln2-i2c\", dev_name(pdev->dev.parent), dln2->port);\n\n\tplatform_set_drvdata(pdev, dln2);\n\n\t \n\tret = dln2_i2c_enable(dln2, true);\n\tif (ret < 0)\n\t\treturn dev_err_probe(dev, ret, \"failed to initialize adapter\\n\");\n\n\t \n\tret = i2c_add_adapter(&dln2->adapter);\n\tif (ret < 0)\n\t\tgoto out_disable;\n\n\treturn 0;\n\nout_disable:\n\tdln2_i2c_enable(dln2, false);\n\n\treturn ret;\n}\n\nstatic void dln2_i2c_remove(struct platform_device *pdev)\n{\n\tstruct dln2_i2c *dln2 = platform_get_drvdata(pdev);\n\n\ti2c_del_adapter(&dln2->adapter);\n\tdln2_i2c_enable(dln2, false);\n}\n\nstatic struct platform_driver dln2_i2c_driver = {\n\t.driver.name\t= \"dln2-i2c\",\n\t.probe\t\t= dln2_i2c_probe,\n\t.remove_new\t= dln2_i2c_remove,\n};\n\nmodule_platform_driver(dln2_i2c_driver);\n\nMODULE_AUTHOR(\"Laurentiu Palcu <laurentiu.palcu@intel.com>\");\nMODULE_DESCRIPTION(\"Driver for the Diolan DLN2 I2C master interface\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:dln2-i2c\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}