{
  "module_name": "i2c-mv64xxx.c",
  "hash_id": "9c3394f9b6b74fd03ce7ddb37a00c895f3f49aba407a86f7b86dd5f8fd8253ff",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-mv64xxx.c",
  "human_readable_source": " \n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/mv643xx_i2c.h>\n#include <linux/platform_device.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/pm_runtime.h>\n#include <linux/reset.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n#include <linux/of_irq.h>\n#include <linux/clk.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n\n#define MV64XXX_I2C_ADDR_ADDR(val)\t\t\t((val & 0x7f) << 1)\n#define MV64XXX_I2C_BAUD_DIV_N(val)\t\t\t(val & 0x7)\n#define MV64XXX_I2C_BAUD_DIV_M(val)\t\t\t((val & 0xf) << 3)\n\n#define\tMV64XXX_I2C_REG_CONTROL_ACK\t\t\tBIT(2)\n#define\tMV64XXX_I2C_REG_CONTROL_IFLG\t\t\tBIT(3)\n#define\tMV64XXX_I2C_REG_CONTROL_STOP\t\t\tBIT(4)\n#define\tMV64XXX_I2C_REG_CONTROL_START\t\t\tBIT(5)\n#define\tMV64XXX_I2C_REG_CONTROL_TWSIEN\t\t\tBIT(6)\n#define\tMV64XXX_I2C_REG_CONTROL_INTEN\t\t\tBIT(7)\n\n \n#define\tMV64XXX_I2C_STATUS_BUS_ERR\t\t\t0x00\n#define\tMV64XXX_I2C_STATUS_MAST_START\t\t\t0x08\n#define\tMV64XXX_I2C_STATUS_MAST_REPEAT_START\t\t0x10\n#define\tMV64XXX_I2C_STATUS_MAST_WR_ADDR_ACK\t\t0x18\n#define\tMV64XXX_I2C_STATUS_MAST_WR_ADDR_NO_ACK\t\t0x20\n#define\tMV64XXX_I2C_STATUS_MAST_WR_ACK\t\t\t0x28\n#define\tMV64XXX_I2C_STATUS_MAST_WR_NO_ACK\t\t0x30\n#define\tMV64XXX_I2C_STATUS_MAST_LOST_ARB\t\t0x38\n#define\tMV64XXX_I2C_STATUS_MAST_RD_ADDR_ACK\t\t0x40\n#define\tMV64XXX_I2C_STATUS_MAST_RD_ADDR_NO_ACK\t\t0x48\n#define\tMV64XXX_I2C_STATUS_MAST_RD_DATA_ACK\t\t0x50\n#define\tMV64XXX_I2C_STATUS_MAST_RD_DATA_NO_ACK\t\t0x58\n#define\tMV64XXX_I2C_STATUS_MAST_WR_ADDR_2_ACK\t\t0xd0\n#define\tMV64XXX_I2C_STATUS_MAST_WR_ADDR_2_NO_ACK\t0xd8\n#define\tMV64XXX_I2C_STATUS_MAST_RD_ADDR_2_ACK\t\t0xe0\n#define\tMV64XXX_I2C_STATUS_MAST_RD_ADDR_2_NO_ACK\t0xe8\n#define\tMV64XXX_I2C_STATUS_NO_STATUS\t\t\t0xf8\n\n \n#define\tMV64XXX_I2C_REG_TX_DATA_LO\t\t\t0xc0\n#define\tMV64XXX_I2C_REG_TX_DATA_HI\t\t\t0xc4\n#define\tMV64XXX_I2C_REG_RX_DATA_LO\t\t\t0xc8\n#define\tMV64XXX_I2C_REG_RX_DATA_HI\t\t\t0xcc\n#define\tMV64XXX_I2C_REG_BRIDGE_CONTROL\t\t\t0xd0\n#define\tMV64XXX_I2C_REG_BRIDGE_STATUS\t\t\t0xd4\n#define\tMV64XXX_I2C_REG_BRIDGE_INTR_CAUSE\t\t0xd8\n#define\tMV64XXX_I2C_REG_BRIDGE_INTR_MASK\t\t0xdC\n#define\tMV64XXX_I2C_REG_BRIDGE_TIMING\t\t\t0xe0\n\n \n#define\tMV64XXX_I2C_BRIDGE_CONTROL_WR\t\t\tBIT(0)\n#define\tMV64XXX_I2C_BRIDGE_CONTROL_RD\t\t\tBIT(1)\n#define\tMV64XXX_I2C_BRIDGE_CONTROL_ADDR_SHIFT\t\t2\n#define\tMV64XXX_I2C_BRIDGE_CONTROL_ADDR_EXT\t\tBIT(12)\n#define\tMV64XXX_I2C_BRIDGE_CONTROL_TX_SIZE_SHIFT\t13\n#define\tMV64XXX_I2C_BRIDGE_CONTROL_RX_SIZE_SHIFT\t16\n#define\tMV64XXX_I2C_BRIDGE_CONTROL_ENABLE\t\tBIT(19)\n#define\tMV64XXX_I2C_BRIDGE_CONTROL_REPEATED_START\tBIT(20)\n\n \n#define\tMV64XXX_I2C_BRIDGE_STATUS_ERROR\t\t\tBIT(0)\n\n \nenum {\n\tMV64XXX_I2C_STATE_INVALID,\n\tMV64XXX_I2C_STATE_IDLE,\n\tMV64XXX_I2C_STATE_WAITING_FOR_START_COND,\n\tMV64XXX_I2C_STATE_WAITING_FOR_RESTART,\n\tMV64XXX_I2C_STATE_WAITING_FOR_ADDR_1_ACK,\n\tMV64XXX_I2C_STATE_WAITING_FOR_ADDR_2_ACK,\n\tMV64XXX_I2C_STATE_WAITING_FOR_SLAVE_ACK,\n\tMV64XXX_I2C_STATE_WAITING_FOR_SLAVE_DATA,\n};\n\n \nenum {\n\tMV64XXX_I2C_ACTION_INVALID,\n\tMV64XXX_I2C_ACTION_CONTINUE,\n\tMV64XXX_I2C_ACTION_SEND_RESTART,\n\tMV64XXX_I2C_ACTION_SEND_ADDR_1,\n\tMV64XXX_I2C_ACTION_SEND_ADDR_2,\n\tMV64XXX_I2C_ACTION_SEND_DATA,\n\tMV64XXX_I2C_ACTION_RCV_DATA,\n\tMV64XXX_I2C_ACTION_RCV_DATA_STOP,\n\tMV64XXX_I2C_ACTION_SEND_STOP,\n};\n\nstruct mv64xxx_i2c_regs {\n\tu8\taddr;\n\tu8\text_addr;\n\tu8\tdata;\n\tu8\tcontrol;\n\tu8\tstatus;\n\tu8\tclock;\n\tu8\tsoft_reset;\n};\n\nstruct mv64xxx_i2c_data {\n\tstruct i2c_msg\t\t*msgs;\n\tint\t\t\tnum_msgs;\n\tint\t\t\tirq;\n\tu32\t\t\tstate;\n\tu32\t\t\taction;\n\tu32\t\t\taborting;\n\tu32\t\t\tcntl_bits;\n\tvoid __iomem\t\t*reg_base;\n\tstruct mv64xxx_i2c_regs\treg_offsets;\n\tu32\t\t\taddr1;\n\tu32\t\t\taddr2;\n\tu32\t\t\tbytes_left;\n\tu32\t\t\tbyte_posn;\n\tu32\t\t\tsend_stop;\n\tu32\t\t\tblock;\n\tint\t\t\trc;\n\tu32\t\t\tfreq_m;\n\tu32\t\t\tfreq_n;\n\tstruct clk              *clk;\n\tstruct clk              *reg_clk;\n\twait_queue_head_t\twaitq;\n\tspinlock_t\t\tlock;\n\tstruct i2c_msg\t\t*msg;\n\tstruct i2c_adapter\tadapter;\n\tbool\t\t\toffload_enabled;\n \n\tbool\t\t\terrata_delay;\n\tstruct reset_control\t*rstc;\n\tbool\t\t\tirq_clear_inverted;\n\t \n\tbool\t\t\tclk_n_base_0;\n\tstruct i2c_bus_recovery_info\trinfo;\n\tbool\t\t\tatomic;\n};\n\nstatic struct mv64xxx_i2c_regs mv64xxx_i2c_regs_mv64xxx = {\n\t.addr\t\t= 0x00,\n\t.ext_addr\t= 0x10,\n\t.data\t\t= 0x04,\n\t.control\t= 0x08,\n\t.status\t\t= 0x0c,\n\t.clock\t\t= 0x0c,\n\t.soft_reset\t= 0x1c,\n};\n\nstatic struct mv64xxx_i2c_regs mv64xxx_i2c_regs_sun4i = {\n\t.addr\t\t= 0x00,\n\t.ext_addr\t= 0x04,\n\t.data\t\t= 0x08,\n\t.control\t= 0x0c,\n\t.status\t\t= 0x10,\n\t.clock\t\t= 0x14,\n\t.soft_reset\t= 0x18,\n};\n\nstatic void\nmv64xxx_i2c_prepare_for_io(struct mv64xxx_i2c_data *drv_data,\n\tstruct i2c_msg *msg)\n{\n\tu32\tdir = 0;\n\n\tdrv_data->cntl_bits = MV64XXX_I2C_REG_CONTROL_ACK |\n\t\t\t      MV64XXX_I2C_REG_CONTROL_TWSIEN;\n\n\tif (!drv_data->atomic)\n\t\tdrv_data->cntl_bits |= MV64XXX_I2C_REG_CONTROL_INTEN;\n\n\tif (msg->flags & I2C_M_RD)\n\t\tdir = 1;\n\n\tif (msg->flags & I2C_M_TEN) {\n\t\tdrv_data->addr1 = 0xf0 | (((u32)msg->addr & 0x300) >> 7) | dir;\n\t\tdrv_data->addr2 = (u32)msg->addr & 0xff;\n\t} else {\n\t\tdrv_data->addr1 = MV64XXX_I2C_ADDR_ADDR((u32)msg->addr) | dir;\n\t\tdrv_data->addr2 = 0;\n\t}\n}\n\n \n\n \nstatic void\nmv64xxx_i2c_hw_init(struct mv64xxx_i2c_data *drv_data)\n{\n\tif (drv_data->offload_enabled) {\n\t\twritel(0, drv_data->reg_base + MV64XXX_I2C_REG_BRIDGE_CONTROL);\n\t\twritel(0, drv_data->reg_base + MV64XXX_I2C_REG_BRIDGE_TIMING);\n\t\twritel(0, drv_data->reg_base +\n\t\t\tMV64XXX_I2C_REG_BRIDGE_INTR_CAUSE);\n\t\twritel(0, drv_data->reg_base +\n\t\t\tMV64XXX_I2C_REG_BRIDGE_INTR_MASK);\n\t}\n\n\twritel(0, drv_data->reg_base + drv_data->reg_offsets.soft_reset);\n\twritel(MV64XXX_I2C_BAUD_DIV_M(drv_data->freq_m) | MV64XXX_I2C_BAUD_DIV_N(drv_data->freq_n),\n\t\tdrv_data->reg_base + drv_data->reg_offsets.clock);\n\twritel(0, drv_data->reg_base + drv_data->reg_offsets.addr);\n\twritel(0, drv_data->reg_base + drv_data->reg_offsets.ext_addr);\n\twritel(MV64XXX_I2C_REG_CONTROL_TWSIEN | MV64XXX_I2C_REG_CONTROL_STOP,\n\t\tdrv_data->reg_base + drv_data->reg_offsets.control);\n\n\tif (drv_data->errata_delay)\n\t\tudelay(5);\n\n\tdrv_data->state = MV64XXX_I2C_STATE_IDLE;\n}\n\nstatic void\nmv64xxx_i2c_fsm(struct mv64xxx_i2c_data *drv_data, u32 status)\n{\n\t \n\tif (drv_data->state == MV64XXX_I2C_STATE_IDLE) {\n\t\tdrv_data->action = MV64XXX_I2C_ACTION_SEND_STOP;\n\t\treturn;\n\t}\n\n\t \n\tswitch (status) {\n\t \n\tcase MV64XXX_I2C_STATUS_MAST_START:  \n\tcase MV64XXX_I2C_STATUS_MAST_REPEAT_START:  \n\t\tdrv_data->action = MV64XXX_I2C_ACTION_SEND_ADDR_1;\n\t\tdrv_data->state = MV64XXX_I2C_STATE_WAITING_FOR_ADDR_1_ACK;\n\t\tbreak;\n\n\t \n\tcase MV64XXX_I2C_STATUS_MAST_WR_ADDR_ACK:  \n\t\tif (drv_data->msg->flags & I2C_M_TEN) {\n\t\t\tdrv_data->action = MV64XXX_I2C_ACTION_SEND_ADDR_2;\n\t\t\tdrv_data->state =\n\t\t\t\tMV64XXX_I2C_STATE_WAITING_FOR_ADDR_2_ACK;\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tcase MV64XXX_I2C_STATUS_MAST_WR_ADDR_2_ACK:  \n\tcase MV64XXX_I2C_STATUS_MAST_WR_ACK:  \n\t\tif ((drv_data->bytes_left == 0)\n\t\t\t\t|| (drv_data->aborting\n\t\t\t\t\t&& (drv_data->byte_posn != 0))) {\n\t\t\tif (drv_data->send_stop || drv_data->aborting) {\n\t\t\t\tdrv_data->action = MV64XXX_I2C_ACTION_SEND_STOP;\n\t\t\t\tdrv_data->state = MV64XXX_I2C_STATE_IDLE;\n\t\t\t} else {\n\t\t\t\tdrv_data->action =\n\t\t\t\t\tMV64XXX_I2C_ACTION_SEND_RESTART;\n\t\t\t\tdrv_data->state =\n\t\t\t\t\tMV64XXX_I2C_STATE_WAITING_FOR_RESTART;\n\t\t\t}\n\t\t} else {\n\t\t\tdrv_data->action = MV64XXX_I2C_ACTION_SEND_DATA;\n\t\t\tdrv_data->state =\n\t\t\t\tMV64XXX_I2C_STATE_WAITING_FOR_SLAVE_ACK;\n\t\t\tdrv_data->bytes_left--;\n\t\t}\n\t\tbreak;\n\n\t \n\tcase MV64XXX_I2C_STATUS_MAST_RD_ADDR_ACK:  \n\t\tif (drv_data->msg->flags & I2C_M_TEN) {\n\t\t\tdrv_data->action = MV64XXX_I2C_ACTION_SEND_ADDR_2;\n\t\t\tdrv_data->state =\n\t\t\t\tMV64XXX_I2C_STATE_WAITING_FOR_ADDR_2_ACK;\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tcase MV64XXX_I2C_STATUS_MAST_RD_ADDR_2_ACK:  \n\t\tif (drv_data->bytes_left == 0) {\n\t\t\tdrv_data->action = MV64XXX_I2C_ACTION_SEND_STOP;\n\t\t\tdrv_data->state = MV64XXX_I2C_STATE_IDLE;\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tcase MV64XXX_I2C_STATUS_MAST_RD_DATA_ACK:  \n\t\tif (status != MV64XXX_I2C_STATUS_MAST_RD_DATA_ACK)\n\t\t\tdrv_data->action = MV64XXX_I2C_ACTION_CONTINUE;\n\t\telse {\n\t\t\tdrv_data->action = MV64XXX_I2C_ACTION_RCV_DATA;\n\t\t\tdrv_data->bytes_left--;\n\t\t}\n\t\tdrv_data->state = MV64XXX_I2C_STATE_WAITING_FOR_SLAVE_DATA;\n\n\t\tif ((drv_data->bytes_left == 1) || drv_data->aborting)\n\t\t\tdrv_data->cntl_bits &= ~MV64XXX_I2C_REG_CONTROL_ACK;\n\t\tbreak;\n\n\tcase MV64XXX_I2C_STATUS_MAST_RD_DATA_NO_ACK:  \n\t\tdrv_data->action = MV64XXX_I2C_ACTION_RCV_DATA_STOP;\n\t\tdrv_data->state = MV64XXX_I2C_STATE_IDLE;\n\t\tbreak;\n\n\tcase MV64XXX_I2C_STATUS_MAST_WR_ADDR_NO_ACK:  \n\tcase MV64XXX_I2C_STATUS_MAST_WR_NO_ACK:  \n\tcase MV64XXX_I2C_STATUS_MAST_RD_ADDR_NO_ACK:  \n\t\t \n\t\tdrv_data->action = MV64XXX_I2C_ACTION_SEND_STOP;\n\t\tdrv_data->state = MV64XXX_I2C_STATE_IDLE;\n\t\tdrv_data->rc = -ENXIO;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(&drv_data->adapter.dev,\n\t\t\t\"mv64xxx_i2c_fsm: Ctlr Error -- state: 0x%x, \"\n\t\t\t\"status: 0x%x, addr: 0x%x, flags: 0x%x\\n\",\n\t\t\t drv_data->state, status, drv_data->msg->addr,\n\t\t\t drv_data->msg->flags);\n\t\tdrv_data->action = MV64XXX_I2C_ACTION_SEND_STOP;\n\t\tmv64xxx_i2c_hw_init(drv_data);\n\t\ti2c_recover_bus(&drv_data->adapter);\n\t\tdrv_data->rc = -EAGAIN;\n\t}\n}\n\nstatic void mv64xxx_i2c_send_start(struct mv64xxx_i2c_data *drv_data)\n{\n\tdrv_data->msg = drv_data->msgs;\n\tdrv_data->byte_posn = 0;\n\tdrv_data->bytes_left = drv_data->msg->len;\n\tdrv_data->aborting = 0;\n\tdrv_data->rc = 0;\n\n\tmv64xxx_i2c_prepare_for_io(drv_data, drv_data->msgs);\n\twritel(drv_data->cntl_bits | MV64XXX_I2C_REG_CONTROL_START,\n\t       drv_data->reg_base + drv_data->reg_offsets.control);\n}\n\nstatic void\nmv64xxx_i2c_do_action(struct mv64xxx_i2c_data *drv_data)\n{\n\tswitch(drv_data->action) {\n\tcase MV64XXX_I2C_ACTION_SEND_RESTART:\n\t\t \n\t\tBUG_ON(drv_data->num_msgs == 0);\n\n\t\tdrv_data->msgs++;\n\t\tdrv_data->num_msgs--;\n\t\tmv64xxx_i2c_send_start(drv_data);\n\n\t\tif (drv_data->errata_delay)\n\t\t\tudelay(5);\n\n\t\t \n\t\tdrv_data->send_stop = drv_data->num_msgs == 1;\n\t\tbreak;\n\n\tcase MV64XXX_I2C_ACTION_CONTINUE:\n\t\twritel(drv_data->cntl_bits,\n\t\t\tdrv_data->reg_base + drv_data->reg_offsets.control);\n\t\tbreak;\n\n\tcase MV64XXX_I2C_ACTION_SEND_ADDR_1:\n\t\twritel(drv_data->addr1,\n\t\t\tdrv_data->reg_base + drv_data->reg_offsets.data);\n\t\twritel(drv_data->cntl_bits,\n\t\t\tdrv_data->reg_base + drv_data->reg_offsets.control);\n\t\tbreak;\n\n\tcase MV64XXX_I2C_ACTION_SEND_ADDR_2:\n\t\twritel(drv_data->addr2,\n\t\t\tdrv_data->reg_base + drv_data->reg_offsets.data);\n\t\twritel(drv_data->cntl_bits,\n\t\t\tdrv_data->reg_base + drv_data->reg_offsets.control);\n\t\tbreak;\n\n\tcase MV64XXX_I2C_ACTION_SEND_DATA:\n\t\twritel(drv_data->msg->buf[drv_data->byte_posn++],\n\t\t\tdrv_data->reg_base + drv_data->reg_offsets.data);\n\t\twritel(drv_data->cntl_bits,\n\t\t\tdrv_data->reg_base + drv_data->reg_offsets.control);\n\t\tbreak;\n\n\tcase MV64XXX_I2C_ACTION_RCV_DATA:\n\t\tdrv_data->msg->buf[drv_data->byte_posn++] =\n\t\t\treadl(drv_data->reg_base + drv_data->reg_offsets.data);\n\t\twritel(drv_data->cntl_bits,\n\t\t\tdrv_data->reg_base + drv_data->reg_offsets.control);\n\t\tbreak;\n\n\tcase MV64XXX_I2C_ACTION_RCV_DATA_STOP:\n\t\tdrv_data->msg->buf[drv_data->byte_posn++] =\n\t\t\treadl(drv_data->reg_base + drv_data->reg_offsets.data);\n\t\tif (!drv_data->atomic)\n\t\t\tdrv_data->cntl_bits &= ~MV64XXX_I2C_REG_CONTROL_INTEN;\n\t\twritel(drv_data->cntl_bits | MV64XXX_I2C_REG_CONTROL_STOP,\n\t\t\tdrv_data->reg_base + drv_data->reg_offsets.control);\n\t\tdrv_data->block = 0;\n\t\tif (drv_data->errata_delay)\n\t\t\tudelay(5);\n\n\t\twake_up(&drv_data->waitq);\n\t\tbreak;\n\n\tcase MV64XXX_I2C_ACTION_INVALID:\n\tdefault:\n\t\tdev_err(&drv_data->adapter.dev,\n\t\t\t\"mv64xxx_i2c_do_action: Invalid action: %d\\n\",\n\t\t\tdrv_data->action);\n\t\tdrv_data->rc = -EIO;\n\t\tfallthrough;\n\tcase MV64XXX_I2C_ACTION_SEND_STOP:\n\t\tif (!drv_data->atomic)\n\t\t\tdrv_data->cntl_bits &= ~MV64XXX_I2C_REG_CONTROL_INTEN;\n\t\twritel(drv_data->cntl_bits | MV64XXX_I2C_REG_CONTROL_STOP,\n\t\t\tdrv_data->reg_base + drv_data->reg_offsets.control);\n\t\tdrv_data->block = 0;\n\t\twake_up(&drv_data->waitq);\n\t\tbreak;\n\t}\n}\n\nstatic void\nmv64xxx_i2c_read_offload_rx_data(struct mv64xxx_i2c_data *drv_data,\n\t\t\t\t struct i2c_msg *msg)\n{\n\tu32 buf[2];\n\n\tbuf[0] = readl(drv_data->reg_base + MV64XXX_I2C_REG_RX_DATA_LO);\n\tbuf[1] = readl(drv_data->reg_base + MV64XXX_I2C_REG_RX_DATA_HI);\n\n\tmemcpy(msg->buf, buf, msg->len);\n}\n\nstatic int\nmv64xxx_i2c_intr_offload(struct mv64xxx_i2c_data *drv_data)\n{\n\tu32 cause, status;\n\n\tcause = readl(drv_data->reg_base +\n\t\t      MV64XXX_I2C_REG_BRIDGE_INTR_CAUSE);\n\tif (!cause)\n\t\treturn IRQ_NONE;\n\n\tstatus = readl(drv_data->reg_base +\n\t\t       MV64XXX_I2C_REG_BRIDGE_STATUS);\n\n\tif (status & MV64XXX_I2C_BRIDGE_STATUS_ERROR) {\n\t\tdrv_data->rc = -EIO;\n\t\tgoto out;\n\t}\n\n\tdrv_data->rc = 0;\n\n\t \n\tif (drv_data->num_msgs == 1 && drv_data->msgs[0].flags & I2C_M_RD) {\n\t\tmv64xxx_i2c_read_offload_rx_data(drv_data, drv_data->msgs);\n\t\tdrv_data->msgs++;\n\t\tdrv_data->num_msgs--;\n\t}\n\t \n\telse if (drv_data->num_msgs == 2 &&\n\t\t !(drv_data->msgs[0].flags & I2C_M_RD) &&\n\t\t drv_data->msgs[1].flags & I2C_M_RD) {\n\t\tmv64xxx_i2c_read_offload_rx_data(drv_data, drv_data->msgs + 1);\n\t\tdrv_data->msgs += 2;\n\t\tdrv_data->num_msgs -= 2;\n\t}\n\nout:\n\twritel(0, drv_data->reg_base +\tMV64XXX_I2C_REG_BRIDGE_CONTROL);\n\twritel(0, drv_data->reg_base +\n\t       MV64XXX_I2C_REG_BRIDGE_INTR_CAUSE);\n\tdrv_data->block = 0;\n\n\twake_up(&drv_data->waitq);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t\nmv64xxx_i2c_intr(int irq, void *dev_id)\n{\n\tstruct mv64xxx_i2c_data\t*drv_data = dev_id;\n\tu32\t\tstatus;\n\tirqreturn_t\trc = IRQ_NONE;\n\n\tspin_lock(&drv_data->lock);\n\n\tif (drv_data->offload_enabled)\n\t\trc = mv64xxx_i2c_intr_offload(drv_data);\n\n\twhile (readl(drv_data->reg_base + drv_data->reg_offsets.control) &\n\t\t\t\t\t\tMV64XXX_I2C_REG_CONTROL_IFLG) {\n\t\t \n\t\tif (drv_data->atomic)\n\t\t\tndelay(100);\n\n\t\tstatus = readl(drv_data->reg_base + drv_data->reg_offsets.status);\n\t\tmv64xxx_i2c_fsm(drv_data, status);\n\t\tmv64xxx_i2c_do_action(drv_data);\n\n\t\tif (drv_data->irq_clear_inverted)\n\t\t\twritel(drv_data->cntl_bits | MV64XXX_I2C_REG_CONTROL_IFLG,\n\t\t\t       drv_data->reg_base + drv_data->reg_offsets.control);\n\n\t\trc = IRQ_HANDLED;\n\t}\n\tspin_unlock(&drv_data->lock);\n\n\treturn rc;\n}\n\n \nstatic void\nmv64xxx_i2c_wait_for_completion(struct mv64xxx_i2c_data *drv_data)\n{\n\tlong\t\ttime_left;\n\tunsigned long\tflags;\n\tchar\t\tabort = 0;\n\n\ttime_left = wait_event_timeout(drv_data->waitq,\n\t\t!drv_data->block, drv_data->adapter.timeout);\n\n\tspin_lock_irqsave(&drv_data->lock, flags);\n\tif (!time_left) {  \n\t\tdrv_data->rc = -ETIMEDOUT;\n\t\tabort = 1;\n\t} else if (time_left < 0) {  \n\t\tdrv_data->rc = time_left;  \n\t\tabort = 1;\n\t}\n\n\tif (abort && drv_data->block) {\n\t\tdrv_data->aborting = 1;\n\t\tspin_unlock_irqrestore(&drv_data->lock, flags);\n\n\t\ttime_left = wait_event_timeout(drv_data->waitq,\n\t\t\t!drv_data->block, drv_data->adapter.timeout);\n\n\t\tif ((time_left <= 0) && drv_data->block) {\n\t\t\tdrv_data->state = MV64XXX_I2C_STATE_IDLE;\n\t\t\tdev_err(&drv_data->adapter.dev,\n\t\t\t\t\"mv64xxx: I2C bus locked, block: %d, \"\n\t\t\t\t\"time_left: %d\\n\", drv_data->block,\n\t\t\t\t(int)time_left);\n\t\t\tmv64xxx_i2c_hw_init(drv_data);\n\t\t\ti2c_recover_bus(&drv_data->adapter);\n\t\t}\n\t} else\n\t\tspin_unlock_irqrestore(&drv_data->lock, flags);\n}\n\nstatic void mv64xxx_i2c_wait_polling(struct mv64xxx_i2c_data *drv_data)\n{\n\tktime_t timeout = ktime_add_ms(ktime_get(), drv_data->adapter.timeout);\n\n\twhile (READ_ONCE(drv_data->block) &&\n\t       ktime_compare(ktime_get(), timeout) < 0) {\n\t\tudelay(5);\n\t\tmv64xxx_i2c_intr(0, drv_data);\n\t}\n}\n\nstatic int\nmv64xxx_i2c_execute_msg(struct mv64xxx_i2c_data *drv_data, struct i2c_msg *msg,\n\t\t\t\tint is_last)\n{\n\tunsigned long\tflags;\n\n\tspin_lock_irqsave(&drv_data->lock, flags);\n\n\tdrv_data->state = MV64XXX_I2C_STATE_WAITING_FOR_START_COND;\n\n\tdrv_data->send_stop = is_last;\n\tdrv_data->block = 1;\n\tmv64xxx_i2c_send_start(drv_data);\n\tspin_unlock_irqrestore(&drv_data->lock, flags);\n\n\tif (!drv_data->atomic)\n\t\tmv64xxx_i2c_wait_for_completion(drv_data);\n\telse\n\t\tmv64xxx_i2c_wait_polling(drv_data);\n\n\treturn drv_data->rc;\n}\n\nstatic void\nmv64xxx_i2c_prepare_tx(struct mv64xxx_i2c_data *drv_data)\n{\n\tstruct i2c_msg *msg = drv_data->msgs;\n\tu32 buf[2];\n\n\tmemcpy(buf, msg->buf, msg->len);\n\n\twritel(buf[0], drv_data->reg_base + MV64XXX_I2C_REG_TX_DATA_LO);\n\twritel(buf[1], drv_data->reg_base + MV64XXX_I2C_REG_TX_DATA_HI);\n}\n\nstatic int\nmv64xxx_i2c_offload_xfer(struct mv64xxx_i2c_data *drv_data)\n{\n\tstruct i2c_msg *msgs = drv_data->msgs;\n\tint num = drv_data->num_msgs;\n\tunsigned long ctrl_reg;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&drv_data->lock, flags);\n\n\t \n\tctrl_reg = MV64XXX_I2C_BRIDGE_CONTROL_ENABLE |\n\t\t(msgs[0].addr << MV64XXX_I2C_BRIDGE_CONTROL_ADDR_SHIFT);\n\n\tif (msgs[0].flags & I2C_M_TEN)\n\t\tctrl_reg |= MV64XXX_I2C_BRIDGE_CONTROL_ADDR_EXT;\n\n\t \n\tif (num == 1 && !(msgs[0].flags & I2C_M_RD)) {\n\t\tsize_t len = msgs[0].len - 1;\n\n\t\tctrl_reg |= MV64XXX_I2C_BRIDGE_CONTROL_WR |\n\t\t\t(len << MV64XXX_I2C_BRIDGE_CONTROL_TX_SIZE_SHIFT);\n\t\tmv64xxx_i2c_prepare_tx(drv_data);\n\t}\n\t \n\telse if (num == 1 && msgs[0].flags & I2C_M_RD) {\n\t\tsize_t len = msgs[0].len - 1;\n\n\t\tctrl_reg |= MV64XXX_I2C_BRIDGE_CONTROL_RD |\n\t\t\t(len << MV64XXX_I2C_BRIDGE_CONTROL_RX_SIZE_SHIFT);\n\t}\n\t \n\telse if (num == 2) {\n\t\tsize_t lentx = msgs[0].len - 1;\n\t\tsize_t lenrx = msgs[1].len - 1;\n\n\t\tctrl_reg |=\n\t\t\tMV64XXX_I2C_BRIDGE_CONTROL_RD |\n\t\t\tMV64XXX_I2C_BRIDGE_CONTROL_WR |\n\t\t\t(lentx << MV64XXX_I2C_BRIDGE_CONTROL_TX_SIZE_SHIFT) |\n\t\t\t(lenrx << MV64XXX_I2C_BRIDGE_CONTROL_RX_SIZE_SHIFT) |\n\t\t\tMV64XXX_I2C_BRIDGE_CONTROL_REPEATED_START;\n\t\tmv64xxx_i2c_prepare_tx(drv_data);\n\t}\n\n\t \n\tdrv_data->block = 1;\n\twritel(ctrl_reg, drv_data->reg_base + MV64XXX_I2C_REG_BRIDGE_CONTROL);\n\tspin_unlock_irqrestore(&drv_data->lock, flags);\n\n\tmv64xxx_i2c_wait_for_completion(drv_data);\n\n\treturn drv_data->rc;\n}\n\nstatic bool\nmv64xxx_i2c_valid_offload_sz(struct i2c_msg *msg)\n{\n\treturn msg->len <= 8 && msg->len >= 1;\n}\n\nstatic bool\nmv64xxx_i2c_can_offload(struct mv64xxx_i2c_data *drv_data)\n{\n\tstruct i2c_msg *msgs = drv_data->msgs;\n\tint num = drv_data->num_msgs;\n\n\tif (!drv_data->offload_enabled)\n\t\treturn false;\n\n\t \n\tif (num == 1 && mv64xxx_i2c_valid_offload_sz(msgs))\n\t\treturn true;\n\n\t \n\tif (num == 2 &&\n\t    mv64xxx_i2c_valid_offload_sz(msgs) &&\n\t    mv64xxx_i2c_valid_offload_sz(msgs + 1) &&\n\t    !(msgs[0].flags & I2C_M_RD) &&\n\t    msgs[1].flags & I2C_M_RD)\n\t\treturn true;\n\n\treturn false;\n}\n\n \nstatic u32\nmv64xxx_i2c_functionality(struct i2c_adapter *adap)\n{\n\treturn I2C_FUNC_I2C | I2C_FUNC_10BIT_ADDR | I2C_FUNC_SMBUS_EMUL;\n}\n\nstatic int\nmv64xxx_i2c_xfer_core(struct i2c_adapter *adap, struct i2c_msg msgs[], int num)\n{\n\tstruct mv64xxx_i2c_data *drv_data = i2c_get_adapdata(adap);\n\tint rc, ret = num;\n\n\trc = pm_runtime_resume_and_get(&adap->dev);\n\tif (rc)\n\t\treturn rc;\n\n\tBUG_ON(drv_data->msgs != NULL);\n\tdrv_data->msgs = msgs;\n\tdrv_data->num_msgs = num;\n\n\tif (mv64xxx_i2c_can_offload(drv_data) && !drv_data->atomic)\n\t\trc = mv64xxx_i2c_offload_xfer(drv_data);\n\telse\n\t\trc = mv64xxx_i2c_execute_msg(drv_data, &msgs[0], num == 1);\n\n\tif (rc < 0)\n\t\tret = rc;\n\n\tdrv_data->num_msgs = 0;\n\tdrv_data->msgs = NULL;\n\n\tpm_runtime_mark_last_busy(&adap->dev);\n\tpm_runtime_put_autosuspend(&adap->dev);\n\n\treturn ret;\n}\n\nstatic int\nmv64xxx_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg msgs[], int num)\n{\n\tstruct mv64xxx_i2c_data *drv_data = i2c_get_adapdata(adap);\n\n\tdrv_data->atomic = 0;\n\treturn mv64xxx_i2c_xfer_core(adap, msgs, num);\n}\n\nstatic int mv64xxx_i2c_xfer_atomic(struct i2c_adapter *adap,\n\t\t\t\t   struct i2c_msg msgs[], int num)\n{\n\tstruct mv64xxx_i2c_data *drv_data = i2c_get_adapdata(adap);\n\n\tdrv_data->atomic = 1;\n\treturn mv64xxx_i2c_xfer_core(adap, msgs, num);\n}\n\nstatic const struct i2c_algorithm mv64xxx_i2c_algo = {\n\t.master_xfer = mv64xxx_i2c_xfer,\n\t.master_xfer_atomic = mv64xxx_i2c_xfer_atomic,\n\t.functionality = mv64xxx_i2c_functionality,\n};\n\n \nstatic const struct of_device_id mv64xxx_i2c_of_match_table[] = {\n\t{ .compatible = \"allwinner,sun4i-a10-i2c\", .data = &mv64xxx_i2c_regs_sun4i},\n\t{ .compatible = \"allwinner,sun6i-a31-i2c\", .data = &mv64xxx_i2c_regs_sun4i},\n\t{ .compatible = \"marvell,mv64xxx-i2c\", .data = &mv64xxx_i2c_regs_mv64xxx},\n\t{ .compatible = \"marvell,mv78230-i2c\", .data = &mv64xxx_i2c_regs_mv64xxx},\n\t{ .compatible = \"marvell,mv78230-a0-i2c\", .data = &mv64xxx_i2c_regs_mv64xxx},\n\t{}\n};\nMODULE_DEVICE_TABLE(of, mv64xxx_i2c_of_match_table);\n\n#ifdef CONFIG_OF\nstatic int\nmv64xxx_calc_freq(struct mv64xxx_i2c_data *drv_data,\n\t\t  const int tclk, const int n, const int m)\n{\n\tif (drv_data->clk_n_base_0)\n\t\treturn tclk / (10 * (m + 1) * (1 << n));\n\telse\n\t\treturn tclk / (10 * (m + 1) * (2 << n));\n}\n\nstatic bool\nmv64xxx_find_baud_factors(struct mv64xxx_i2c_data *drv_data,\n\t\t\t  const u32 req_freq, const u32 tclk)\n{\n\tint freq, delta, best_delta = INT_MAX;\n\tint m, n;\n\n\tfor (n = 0; n <= 7; n++)\n\t\tfor (m = 0; m <= 15; m++) {\n\t\t\tfreq = mv64xxx_calc_freq(drv_data, tclk, n, m);\n\t\t\tdelta = req_freq - freq;\n\t\t\tif (delta >= 0 && delta < best_delta) {\n\t\t\t\tdrv_data->freq_m = m;\n\t\t\t\tdrv_data->freq_n = n;\n\t\t\t\tbest_delta = delta;\n\t\t\t}\n\t\t\tif (best_delta == 0)\n\t\t\t\treturn true;\n\t\t}\n\tif (best_delta == INT_MAX)\n\t\treturn false;\n\treturn true;\n}\n\nstatic int\nmv64xxx_of_config(struct mv64xxx_i2c_data *drv_data,\n\t\t  struct device *dev)\n{\n\tconst struct of_device_id *device;\n\tstruct device_node *np = dev->of_node;\n\tu32 bus_freq, tclk;\n\tint rc = 0;\n\n\t \n\tif (!drv_data->clk) {\n\t\trc = -ENODEV;\n\t\tgoto out;\n\t}\n\ttclk = clk_get_rate(drv_data->clk);\n\n\tif (of_property_read_u32(np, \"clock-frequency\", &bus_freq))\n\t\tbus_freq = I2C_MAX_STANDARD_MODE_FREQ;  \n\n\tif (of_device_is_compatible(np, \"allwinner,sun4i-a10-i2c\") ||\n\t    of_device_is_compatible(np, \"allwinner,sun6i-a31-i2c\"))\n\t\tdrv_data->clk_n_base_0 = true;\n\n\tif (!mv64xxx_find_baud_factors(drv_data, bus_freq, tclk)) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tdrv_data->rstc = devm_reset_control_get_optional_exclusive(dev, NULL);\n\tif (IS_ERR(drv_data->rstc)) {\n\t\trc = PTR_ERR(drv_data->rstc);\n\t\tgoto out;\n\t}\n\n\t \n\tdrv_data->adapter.timeout = HZ;\n\n\tdevice = of_match_device(mv64xxx_i2c_of_match_table, dev);\n\tif (!device)\n\t\treturn -ENODEV;\n\n\tmemcpy(&drv_data->reg_offsets, device->data, sizeof(drv_data->reg_offsets));\n\n\t \n\tif (of_device_is_compatible(np, \"marvell,mv78230-i2c\")) {\n\t\tdrv_data->offload_enabled = true;\n\t\t \n\t\tif (bus_freq <= I2C_MAX_STANDARD_MODE_FREQ)\n\t\t\tdrv_data->errata_delay = true;\n\t}\n\n\tif (of_device_is_compatible(np, \"marvell,mv78230-a0-i2c\")) {\n\t\tdrv_data->offload_enabled = false;\n\t\t \n\t\tif (bus_freq <= I2C_MAX_STANDARD_MODE_FREQ)\n\t\t\tdrv_data->errata_delay = true;\n\t}\n\n\tif (of_device_is_compatible(np, \"allwinner,sun6i-a31-i2c\"))\n\t\tdrv_data->irq_clear_inverted = true;\n\nout:\n\treturn rc;\n}\n#else  \nstatic int\nmv64xxx_of_config(struct mv64xxx_i2c_data *drv_data,\n\t\t  struct device *dev)\n{\n\treturn -ENODEV;\n}\n#endif  \n\nstatic int mv64xxx_i2c_init_recovery_info(struct mv64xxx_i2c_data *drv_data,\n\t\t\t\t\t  struct device *dev)\n{\n\tstruct i2c_bus_recovery_info *rinfo = &drv_data->rinfo;\n\n\trinfo->pinctrl = devm_pinctrl_get(dev);\n\tif (IS_ERR(rinfo->pinctrl)) {\n\t\tif (PTR_ERR(rinfo->pinctrl) == -EPROBE_DEFER)\n\t\t\treturn -EPROBE_DEFER;\n\t\tdev_info(dev, \"can't get pinctrl, bus recovery not supported\\n\");\n\t\treturn PTR_ERR(rinfo->pinctrl);\n\t} else if (!rinfo->pinctrl) {\n\t\treturn -ENODEV;\n\t}\n\n\tdrv_data->adapter.bus_recovery_info = rinfo;\n\treturn 0;\n}\n\nstatic int\nmv64xxx_i2c_runtime_suspend(struct device *dev)\n{\n\tstruct mv64xxx_i2c_data *drv_data = dev_get_drvdata(dev);\n\n\treset_control_assert(drv_data->rstc);\n\tclk_disable_unprepare(drv_data->reg_clk);\n\tclk_disable_unprepare(drv_data->clk);\n\n\treturn 0;\n}\n\nstatic int\nmv64xxx_i2c_runtime_resume(struct device *dev)\n{\n\tstruct mv64xxx_i2c_data *drv_data = dev_get_drvdata(dev);\n\n\tclk_prepare_enable(drv_data->clk);\n\tclk_prepare_enable(drv_data->reg_clk);\n\treset_control_reset(drv_data->rstc);\n\n\tmv64xxx_i2c_hw_init(drv_data);\n\n\treturn 0;\n}\n\nstatic int\nmv64xxx_i2c_probe(struct platform_device *pd)\n{\n\tstruct mv64xxx_i2c_data\t\t*drv_data;\n\tstruct mv64xxx_i2c_pdata\t*pdata = dev_get_platdata(&pd->dev);\n\tint\trc;\n\n\tif ((!pdata && !pd->dev.of_node))\n\t\treturn -ENODEV;\n\n\tdrv_data = devm_kzalloc(&pd->dev, sizeof(struct mv64xxx_i2c_data),\n\t\t\t\tGFP_KERNEL);\n\tif (!drv_data)\n\t\treturn -ENOMEM;\n\n\tdrv_data->reg_base = devm_platform_ioremap_resource(pd, 0);\n\tif (IS_ERR(drv_data->reg_base))\n\t\treturn PTR_ERR(drv_data->reg_base);\n\n\tstrscpy(drv_data->adapter.name, MV64XXX_I2C_CTLR_NAME \" adapter\",\n\t\tsizeof(drv_data->adapter.name));\n\n\tinit_waitqueue_head(&drv_data->waitq);\n\tspin_lock_init(&drv_data->lock);\n\n\t \n\tdrv_data->clk = devm_clk_get(&pd->dev, NULL);\n\tif (IS_ERR(drv_data->clk)) {\n\t\tif (PTR_ERR(drv_data->clk) == -EPROBE_DEFER)\n\t\t\treturn -EPROBE_DEFER;\n\t\tdrv_data->clk = NULL;\n\t}\n\n\tdrv_data->reg_clk = devm_clk_get(&pd->dev, \"reg\");\n\tif (IS_ERR(drv_data->reg_clk)) {\n\t\tif (PTR_ERR(drv_data->reg_clk) == -EPROBE_DEFER)\n\t\t\treturn -EPROBE_DEFER;\n\t\tdrv_data->reg_clk = NULL;\n\t}\n\n\tdrv_data->irq = platform_get_irq(pd, 0);\n\tif (drv_data->irq < 0)\n\t\treturn drv_data->irq;\n\n\tif (pdata) {\n\t\tdrv_data->freq_m = pdata->freq_m;\n\t\tdrv_data->freq_n = pdata->freq_n;\n\t\tdrv_data->adapter.timeout = msecs_to_jiffies(pdata->timeout);\n\t\tdrv_data->offload_enabled = false;\n\t\tmemcpy(&drv_data->reg_offsets, &mv64xxx_i2c_regs_mv64xxx, sizeof(drv_data->reg_offsets));\n\t} else if (pd->dev.of_node) {\n\t\trc = mv64xxx_of_config(drv_data, &pd->dev);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\trc = mv64xxx_i2c_init_recovery_info(drv_data, &pd->dev);\n\tif (rc == -EPROBE_DEFER)\n\t\treturn rc;\n\n\tdrv_data->adapter.dev.parent = &pd->dev;\n\tdrv_data->adapter.algo = &mv64xxx_i2c_algo;\n\tdrv_data->adapter.owner = THIS_MODULE;\n\tdrv_data->adapter.class = I2C_CLASS_DEPRECATED;\n\tdrv_data->adapter.nr = pd->id;\n\tdrv_data->adapter.dev.of_node = pd->dev.of_node;\n\tplatform_set_drvdata(pd, drv_data);\n\ti2c_set_adapdata(&drv_data->adapter, drv_data);\n\n\tpm_runtime_set_autosuspend_delay(&pd->dev, MSEC_PER_SEC);\n\tpm_runtime_use_autosuspend(&pd->dev);\n\tpm_runtime_enable(&pd->dev);\n\tif (!pm_runtime_enabled(&pd->dev)) {\n\t\trc = mv64xxx_i2c_runtime_resume(&pd->dev);\n\t\tif (rc)\n\t\t\tgoto exit_disable_pm;\n\t}\n\n\trc = request_irq(drv_data->irq, mv64xxx_i2c_intr, 0,\n\t\t\t MV64XXX_I2C_CTLR_NAME, drv_data);\n\tif (rc) {\n\t\tdev_err(&drv_data->adapter.dev,\n\t\t\t\"mv64xxx: Can't register intr handler irq%d: %d\\n\",\n\t\t\tdrv_data->irq, rc);\n\t\tgoto exit_disable_pm;\n\t} else if ((rc = i2c_add_numbered_adapter(&drv_data->adapter)) != 0) {\n\t\tdev_err(&drv_data->adapter.dev,\n\t\t\t\"mv64xxx: Can't add i2c adapter, rc: %d\\n\", -rc);\n\t\tgoto exit_free_irq;\n\t}\n\n\treturn 0;\n\nexit_free_irq:\n\tfree_irq(drv_data->irq, drv_data);\nexit_disable_pm:\n\tpm_runtime_disable(&pd->dev);\n\tif (!pm_runtime_status_suspended(&pd->dev))\n\t\tmv64xxx_i2c_runtime_suspend(&pd->dev);\n\n\treturn rc;\n}\n\nstatic void\nmv64xxx_i2c_remove(struct platform_device *pd)\n{\n\tstruct mv64xxx_i2c_data\t\t*drv_data = platform_get_drvdata(pd);\n\n\ti2c_del_adapter(&drv_data->adapter);\n\tfree_irq(drv_data->irq, drv_data);\n\tpm_runtime_disable(&pd->dev);\n\tif (!pm_runtime_status_suspended(&pd->dev))\n\t\tmv64xxx_i2c_runtime_suspend(&pd->dev);\n}\n\nstatic const struct dev_pm_ops mv64xxx_i2c_pm_ops = {\n\tSET_RUNTIME_PM_OPS(mv64xxx_i2c_runtime_suspend,\n\t\t\t   mv64xxx_i2c_runtime_resume, NULL)\n\tSET_NOIRQ_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,\n\t\t\t\t      pm_runtime_force_resume)\n};\n\nstatic struct platform_driver mv64xxx_i2c_driver = {\n\t.probe\t= mv64xxx_i2c_probe,\n\t.remove_new = mv64xxx_i2c_remove,\n\t.driver\t= {\n\t\t.name\t= MV64XXX_I2C_CTLR_NAME,\n\t\t.pm     = &mv64xxx_i2c_pm_ops,\n\t\t.of_match_table = mv64xxx_i2c_of_match_table,\n\t},\n};\n\nmodule_platform_driver(mv64xxx_i2c_driver);\n\nMODULE_AUTHOR(\"Mark A. Greer <mgreer@mvista.com>\");\nMODULE_DESCRIPTION(\"Marvell mv64xxx host bridge i2c ctlr driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}