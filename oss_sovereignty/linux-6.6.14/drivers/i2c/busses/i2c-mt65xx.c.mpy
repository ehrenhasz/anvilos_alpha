{
  "module_name": "i2c-mt65xx.c",
  "hash_id": "1805cbcfb75c79cae93e03b580d7eeb7588a11adf39ec9d3e1a57f1f48762adb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-mt65xx.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/dma-mapping.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/i2c.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/scatterlist.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\n#define I2C_RS_TRANSFER\t\t\t(1 << 4)\n#define I2C_ARB_LOST\t\t\t(1 << 3)\n#define I2C_HS_NACKERR\t\t\t(1 << 2)\n#define I2C_ACKERR\t\t\t(1 << 1)\n#define I2C_TRANSAC_COMP\t\t(1 << 0)\n#define I2C_TRANSAC_START\t\t(1 << 0)\n#define I2C_RS_MUL_CNFG\t\t\t(1 << 15)\n#define I2C_RS_MUL_TRIG\t\t\t(1 << 14)\n#define I2C_DCM_DISABLE\t\t\t0x0000\n#define I2C_IO_CONFIG_OPEN_DRAIN\t0x0003\n#define I2C_IO_CONFIG_PUSH_PULL\t\t0x0000\n#define I2C_SOFT_RST\t\t\t0x0001\n#define I2C_HANDSHAKE_RST\t\t0x0020\n#define I2C_FIFO_ADDR_CLR\t\t0x0001\n#define I2C_DELAY_LEN\t\t\t0x0002\n#define I2C_ST_START_CON\t\t0x8001\n#define I2C_FS_START_CON\t\t0x1800\n#define I2C_TIME_CLR_VALUE\t\t0x0000\n#define I2C_TIME_DEFAULT_VALUE\t\t0x0003\n#define I2C_WRRD_TRANAC_VALUE\t\t0x0002\n#define I2C_RD_TRANAC_VALUE\t\t0x0001\n#define I2C_SCL_MIS_COMP_VALUE\t\t0x0000\n#define I2C_CHN_CLR_FLAG\t\t0x0000\n#define I2C_RELIABILITY\t\t0x0010\n#define I2C_DMAACK_ENABLE\t\t0x0008\n\n#define I2C_DMA_CON_TX\t\t\t0x0000\n#define I2C_DMA_CON_RX\t\t\t0x0001\n#define I2C_DMA_ASYNC_MODE\t\t0x0004\n#define I2C_DMA_SKIP_CONFIG\t\t0x0010\n#define I2C_DMA_DIR_CHANGE\t\t0x0200\n#define I2C_DMA_START_EN\t\t0x0001\n#define I2C_DMA_INT_FLAG_NONE\t\t0x0000\n#define I2C_DMA_CLR_FLAG\t\t0x0000\n#define I2C_DMA_WARM_RST\t\t0x0001\n#define I2C_DMA_HARD_RST\t\t0x0002\n#define I2C_DMA_HANDSHAKE_RST\t\t0x0004\n\n#define MAX_SAMPLE_CNT_DIV\t\t8\n#define MAX_STEP_CNT_DIV\t\t64\n#define MAX_CLOCK_DIV_8BITS\t\t256\n#define MAX_CLOCK_DIV_5BITS\t\t32\n#define MAX_HS_STEP_CNT_DIV\t\t8\n#define I2C_STANDARD_MODE_BUFFER\t(1000 / 3)\n#define I2C_FAST_MODE_BUFFER\t\t(300 / 3)\n#define I2C_FAST_MODE_PLUS_BUFFER\t(20 / 3)\n\n#define I2C_CONTROL_RS                  (0x1 << 1)\n#define I2C_CONTROL_DMA_EN              (0x1 << 2)\n#define I2C_CONTROL_CLK_EXT_EN          (0x1 << 3)\n#define I2C_CONTROL_DIR_CHANGE          (0x1 << 4)\n#define I2C_CONTROL_ACKERR_DET_EN       (0x1 << 5)\n#define I2C_CONTROL_TRANSFER_LEN_CHANGE (0x1 << 6)\n#define I2C_CONTROL_DMAACK_EN           (0x1 << 8)\n#define I2C_CONTROL_ASYNC_MODE          (0x1 << 9)\n#define I2C_CONTROL_WRAPPER             (0x1 << 0)\n\n#define I2C_DRV_NAME\t\t\"i2c-mt65xx\"\n\n \nenum i2c_mt65xx_clks {\n\tI2C_MT65XX_CLK_MAIN = 0,\n\tI2C_MT65XX_CLK_DMA,\n\tI2C_MT65XX_CLK_PMIC,\n\tI2C_MT65XX_CLK_ARB,\n\tI2C_MT65XX_CLK_MAX\n};\n\nstatic const char * const i2c_mt65xx_clk_ids[I2C_MT65XX_CLK_MAX] = {\n\t\"main\", \"dma\", \"pmic\", \"arb\"\n};\n\nenum DMA_REGS_OFFSET {\n\tOFFSET_INT_FLAG = 0x0,\n\tOFFSET_INT_EN = 0x04,\n\tOFFSET_EN = 0x08,\n\tOFFSET_RST = 0x0c,\n\tOFFSET_CON = 0x18,\n\tOFFSET_TX_MEM_ADDR = 0x1c,\n\tOFFSET_RX_MEM_ADDR = 0x20,\n\tOFFSET_TX_LEN = 0x24,\n\tOFFSET_RX_LEN = 0x28,\n\tOFFSET_TX_4G_MODE = 0x54,\n\tOFFSET_RX_4G_MODE = 0x58,\n};\n\nenum i2c_trans_st_rs {\n\tI2C_TRANS_STOP = 0,\n\tI2C_TRANS_REPEATED_START,\n};\n\nenum mtk_trans_op {\n\tI2C_MASTER_WR = 1,\n\tI2C_MASTER_RD,\n\tI2C_MASTER_WRRD,\n};\n\nenum I2C_REGS_OFFSET {\n\tOFFSET_DATA_PORT,\n\tOFFSET_SLAVE_ADDR,\n\tOFFSET_INTR_MASK,\n\tOFFSET_INTR_STAT,\n\tOFFSET_CONTROL,\n\tOFFSET_TRANSFER_LEN,\n\tOFFSET_TRANSAC_LEN,\n\tOFFSET_DELAY_LEN,\n\tOFFSET_TIMING,\n\tOFFSET_START,\n\tOFFSET_EXT_CONF,\n\tOFFSET_FIFO_STAT,\n\tOFFSET_FIFO_THRESH,\n\tOFFSET_FIFO_ADDR_CLR,\n\tOFFSET_IO_CONFIG,\n\tOFFSET_RSV_DEBUG,\n\tOFFSET_HS,\n\tOFFSET_SOFTRESET,\n\tOFFSET_DCM_EN,\n\tOFFSET_MULTI_DMA,\n\tOFFSET_PATH_DIR,\n\tOFFSET_DEBUGSTAT,\n\tOFFSET_DEBUGCTRL,\n\tOFFSET_TRANSFER_LEN_AUX,\n\tOFFSET_CLOCK_DIV,\n\tOFFSET_LTIMING,\n\tOFFSET_SCL_HIGH_LOW_RATIO,\n\tOFFSET_HS_SCL_HIGH_LOW_RATIO,\n\tOFFSET_SCL_MIS_COMP_POINT,\n\tOFFSET_STA_STO_AC_TIMING,\n\tOFFSET_HS_STA_STO_AC_TIMING,\n\tOFFSET_SDA_TIMING,\n};\n\nstatic const u16 mt_i2c_regs_v1[] = {\n\t[OFFSET_DATA_PORT] = 0x0,\n\t[OFFSET_SLAVE_ADDR] = 0x4,\n\t[OFFSET_INTR_MASK] = 0x8,\n\t[OFFSET_INTR_STAT] = 0xc,\n\t[OFFSET_CONTROL] = 0x10,\n\t[OFFSET_TRANSFER_LEN] = 0x14,\n\t[OFFSET_TRANSAC_LEN] = 0x18,\n\t[OFFSET_DELAY_LEN] = 0x1c,\n\t[OFFSET_TIMING] = 0x20,\n\t[OFFSET_START] = 0x24,\n\t[OFFSET_EXT_CONF] = 0x28,\n\t[OFFSET_FIFO_STAT] = 0x30,\n\t[OFFSET_FIFO_THRESH] = 0x34,\n\t[OFFSET_FIFO_ADDR_CLR] = 0x38,\n\t[OFFSET_IO_CONFIG] = 0x40,\n\t[OFFSET_RSV_DEBUG] = 0x44,\n\t[OFFSET_HS] = 0x48,\n\t[OFFSET_SOFTRESET] = 0x50,\n\t[OFFSET_DCM_EN] = 0x54,\n\t[OFFSET_PATH_DIR] = 0x60,\n\t[OFFSET_DEBUGSTAT] = 0x64,\n\t[OFFSET_DEBUGCTRL] = 0x68,\n\t[OFFSET_TRANSFER_LEN_AUX] = 0x6c,\n\t[OFFSET_CLOCK_DIV] = 0x70,\n\t[OFFSET_SCL_HIGH_LOW_RATIO] = 0x74,\n\t[OFFSET_HS_SCL_HIGH_LOW_RATIO] = 0x78,\n\t[OFFSET_SCL_MIS_COMP_POINT] = 0x7C,\n\t[OFFSET_STA_STO_AC_TIMING] = 0x80,\n\t[OFFSET_HS_STA_STO_AC_TIMING] = 0x84,\n\t[OFFSET_SDA_TIMING] = 0x88,\n};\n\nstatic const u16 mt_i2c_regs_v2[] = {\n\t[OFFSET_DATA_PORT] = 0x0,\n\t[OFFSET_SLAVE_ADDR] = 0x4,\n\t[OFFSET_INTR_MASK] = 0x8,\n\t[OFFSET_INTR_STAT] = 0xc,\n\t[OFFSET_CONTROL] = 0x10,\n\t[OFFSET_TRANSFER_LEN] = 0x14,\n\t[OFFSET_TRANSAC_LEN] = 0x18,\n\t[OFFSET_DELAY_LEN] = 0x1c,\n\t[OFFSET_TIMING] = 0x20,\n\t[OFFSET_START] = 0x24,\n\t[OFFSET_EXT_CONF] = 0x28,\n\t[OFFSET_LTIMING] = 0x2c,\n\t[OFFSET_HS] = 0x30,\n\t[OFFSET_IO_CONFIG] = 0x34,\n\t[OFFSET_FIFO_ADDR_CLR] = 0x38,\n\t[OFFSET_SDA_TIMING] = 0x3c,\n\t[OFFSET_TRANSFER_LEN_AUX] = 0x44,\n\t[OFFSET_CLOCK_DIV] = 0x48,\n\t[OFFSET_SOFTRESET] = 0x50,\n\t[OFFSET_MULTI_DMA] = 0x8c,\n\t[OFFSET_SCL_MIS_COMP_POINT] = 0x90,\n\t[OFFSET_DEBUGSTAT] = 0xe4,\n\t[OFFSET_DEBUGCTRL] = 0xe8,\n\t[OFFSET_FIFO_STAT] = 0xf4,\n\t[OFFSET_FIFO_THRESH] = 0xf8,\n\t[OFFSET_DCM_EN] = 0xf88,\n};\n\nstatic const u16 mt_i2c_regs_v3[] = {\n\t[OFFSET_DATA_PORT] = 0x0,\n\t[OFFSET_INTR_MASK] = 0x8,\n\t[OFFSET_INTR_STAT] = 0xc,\n\t[OFFSET_CONTROL] = 0x10,\n\t[OFFSET_TRANSFER_LEN] = 0x14,\n\t[OFFSET_TRANSAC_LEN] = 0x18,\n\t[OFFSET_DELAY_LEN] = 0x1c,\n\t[OFFSET_TIMING] = 0x20,\n\t[OFFSET_START] = 0x24,\n\t[OFFSET_EXT_CONF] = 0x28,\n\t[OFFSET_LTIMING] = 0x2c,\n\t[OFFSET_HS] = 0x30,\n\t[OFFSET_IO_CONFIG] = 0x34,\n\t[OFFSET_FIFO_ADDR_CLR] = 0x38,\n\t[OFFSET_SDA_TIMING] = 0x3c,\n\t[OFFSET_TRANSFER_LEN_AUX] = 0x44,\n\t[OFFSET_CLOCK_DIV] = 0x48,\n\t[OFFSET_SOFTRESET] = 0x50,\n\t[OFFSET_MULTI_DMA] = 0x8c,\n\t[OFFSET_SCL_MIS_COMP_POINT] = 0x90,\n\t[OFFSET_SLAVE_ADDR] = 0x94,\n\t[OFFSET_DEBUGSTAT] = 0xe4,\n\t[OFFSET_DEBUGCTRL] = 0xe8,\n\t[OFFSET_FIFO_STAT] = 0xf4,\n\t[OFFSET_FIFO_THRESH] = 0xf8,\n\t[OFFSET_DCM_EN] = 0xf88,\n};\n\nstruct mtk_i2c_compatible {\n\tconst struct i2c_adapter_quirks *quirks;\n\tconst u16 *regs;\n\tunsigned char pmic_i2c: 1;\n\tunsigned char dcm: 1;\n\tunsigned char auto_restart: 1;\n\tunsigned char aux_len_reg: 1;\n\tunsigned char timing_adjust: 1;\n\tunsigned char dma_sync: 1;\n\tunsigned char ltiming_adjust: 1;\n\tunsigned char apdma_sync: 1;\n\tunsigned char max_dma_support;\n};\n\nstruct mtk_i2c_ac_timing {\n\tu16 htiming;\n\tu16 ltiming;\n\tu16 hs;\n\tu16 ext;\n\tu16 inter_clk_div;\n\tu16 scl_hl_ratio;\n\tu16 hs_scl_hl_ratio;\n\tu16 sta_stop;\n\tu16 hs_sta_stop;\n\tu16 sda_timing;\n};\n\nstruct mtk_i2c {\n\tstruct i2c_adapter adap;\t \n\tstruct device *dev;\n\tstruct completion msg_complete;\n\tstruct i2c_timings timing_info;\n\n\t \n\tvoid __iomem *base;\t\t \n\tvoid __iomem *pdmabase;\t\t \n\tstruct clk_bulk_data clocks[I2C_MT65XX_CLK_MAX];  \n\tbool have_pmic;\t\t\t \n\tbool use_push_pull;\t\t \n\n\tu16 irq_stat;\t\t\t \n\tunsigned int clk_src_div;\n\tunsigned int speed_hz;\t\t \n\tenum mtk_trans_op op;\n\tu16 timing_reg;\n\tu16 high_speed_reg;\n\tu16 ltiming_reg;\n\tunsigned char auto_restart;\n\tbool ignore_restart_irq;\n\tstruct mtk_i2c_ac_timing ac_timing;\n\tconst struct mtk_i2c_compatible *dev_comp;\n};\n\n \nstruct i2c_spec_values {\n\tunsigned int min_low_ns;\n\tunsigned int min_su_sta_ns;\n\tunsigned int max_hd_dat_ns;\n\tunsigned int min_su_dat_ns;\n};\n\nstatic const struct i2c_spec_values standard_mode_spec = {\n\t.min_low_ns = 4700 + I2C_STANDARD_MODE_BUFFER,\n\t.min_su_sta_ns = 4700 + I2C_STANDARD_MODE_BUFFER,\n\t.max_hd_dat_ns = 3450 - I2C_STANDARD_MODE_BUFFER,\n\t.min_su_dat_ns = 250 + I2C_STANDARD_MODE_BUFFER,\n};\n\nstatic const struct i2c_spec_values fast_mode_spec = {\n\t.min_low_ns = 1300 + I2C_FAST_MODE_BUFFER,\n\t.min_su_sta_ns = 600 + I2C_FAST_MODE_BUFFER,\n\t.max_hd_dat_ns = 900 - I2C_FAST_MODE_BUFFER,\n\t.min_su_dat_ns = 100 + I2C_FAST_MODE_BUFFER,\n};\n\nstatic const struct i2c_spec_values fast_mode_plus_spec = {\n\t.min_low_ns = 500 + I2C_FAST_MODE_PLUS_BUFFER,\n\t.min_su_sta_ns = 260 + I2C_FAST_MODE_PLUS_BUFFER,\n\t.max_hd_dat_ns = 400 - I2C_FAST_MODE_PLUS_BUFFER,\n\t.min_su_dat_ns = 50 + I2C_FAST_MODE_PLUS_BUFFER,\n};\n\nstatic const struct i2c_adapter_quirks mt6577_i2c_quirks = {\n\t.flags = I2C_AQ_COMB_WRITE_THEN_READ,\n\t.max_num_msgs = 1,\n\t.max_write_len = 255,\n\t.max_read_len = 255,\n\t.max_comb_1st_msg_len = 255,\n\t.max_comb_2nd_msg_len = 31,\n};\n\nstatic const struct i2c_adapter_quirks mt7622_i2c_quirks = {\n\t.max_num_msgs = 255,\n};\n\nstatic const struct i2c_adapter_quirks mt8183_i2c_quirks = {\n\t.flags = I2C_AQ_NO_ZERO_LEN,\n};\n\nstatic const struct mtk_i2c_compatible mt2712_compat = {\n\t.regs = mt_i2c_regs_v1,\n\t.pmic_i2c = 0,\n\t.dcm = 1,\n\t.auto_restart = 1,\n\t.aux_len_reg = 1,\n\t.timing_adjust = 1,\n\t.dma_sync = 0,\n\t.ltiming_adjust = 0,\n\t.apdma_sync = 0,\n\t.max_dma_support = 33,\n};\n\nstatic const struct mtk_i2c_compatible mt6577_compat = {\n\t.quirks = &mt6577_i2c_quirks,\n\t.regs = mt_i2c_regs_v1,\n\t.pmic_i2c = 0,\n\t.dcm = 1,\n\t.auto_restart = 0,\n\t.aux_len_reg = 0,\n\t.timing_adjust = 0,\n\t.dma_sync = 0,\n\t.ltiming_adjust = 0,\n\t.apdma_sync = 0,\n\t.max_dma_support = 32,\n};\n\nstatic const struct mtk_i2c_compatible mt6589_compat = {\n\t.quirks = &mt6577_i2c_quirks,\n\t.regs = mt_i2c_regs_v1,\n\t.pmic_i2c = 1,\n\t.dcm = 0,\n\t.auto_restart = 0,\n\t.aux_len_reg = 0,\n\t.timing_adjust = 0,\n\t.dma_sync = 0,\n\t.ltiming_adjust = 0,\n\t.apdma_sync = 0,\n\t.max_dma_support = 32,\n};\n\nstatic const struct mtk_i2c_compatible mt7622_compat = {\n\t.quirks = &mt7622_i2c_quirks,\n\t.regs = mt_i2c_regs_v1,\n\t.pmic_i2c = 0,\n\t.dcm = 1,\n\t.auto_restart = 1,\n\t.aux_len_reg = 1,\n\t.timing_adjust = 0,\n\t.dma_sync = 0,\n\t.ltiming_adjust = 0,\n\t.apdma_sync = 0,\n\t.max_dma_support = 32,\n};\n\nstatic const struct mtk_i2c_compatible mt8168_compat = {\n\t.regs = mt_i2c_regs_v1,\n\t.pmic_i2c = 0,\n\t.dcm = 1,\n\t.auto_restart = 1,\n\t.aux_len_reg = 1,\n\t.timing_adjust = 1,\n\t.dma_sync = 1,\n\t.ltiming_adjust = 0,\n\t.apdma_sync = 0,\n\t.max_dma_support = 33,\n};\n\nstatic const struct mtk_i2c_compatible mt7981_compat = {\n\t.regs = mt_i2c_regs_v3,\n\t.pmic_i2c = 0,\n\t.dcm = 0,\n\t.auto_restart = 1,\n\t.aux_len_reg = 1,\n\t.timing_adjust = 1,\n\t.dma_sync = 1,\n\t.ltiming_adjust = 1,\n\t.max_dma_support = 33\n};\n\nstatic const struct mtk_i2c_compatible mt7986_compat = {\n\t.quirks = &mt7622_i2c_quirks,\n\t.regs = mt_i2c_regs_v1,\n\t.pmic_i2c = 0,\n\t.dcm = 1,\n\t.auto_restart = 1,\n\t.aux_len_reg = 1,\n\t.timing_adjust = 0,\n\t.dma_sync = 1,\n\t.ltiming_adjust = 0,\n\t.max_dma_support = 32,\n};\n\nstatic const struct mtk_i2c_compatible mt8173_compat = {\n\t.regs = mt_i2c_regs_v1,\n\t.pmic_i2c = 0,\n\t.dcm = 1,\n\t.auto_restart = 1,\n\t.aux_len_reg = 1,\n\t.timing_adjust = 0,\n\t.dma_sync = 0,\n\t.ltiming_adjust = 0,\n\t.apdma_sync = 0,\n\t.max_dma_support = 33,\n};\n\nstatic const struct mtk_i2c_compatible mt8183_compat = {\n\t.quirks = &mt8183_i2c_quirks,\n\t.regs = mt_i2c_regs_v2,\n\t.pmic_i2c = 0,\n\t.dcm = 0,\n\t.auto_restart = 1,\n\t.aux_len_reg = 1,\n\t.timing_adjust = 1,\n\t.dma_sync = 1,\n\t.ltiming_adjust = 1,\n\t.apdma_sync = 0,\n\t.max_dma_support = 33,\n};\n\nstatic const struct mtk_i2c_compatible mt8186_compat = {\n\t.regs = mt_i2c_regs_v2,\n\t.pmic_i2c = 0,\n\t.dcm = 0,\n\t.auto_restart = 1,\n\t.aux_len_reg = 1,\n\t.timing_adjust = 1,\n\t.dma_sync = 0,\n\t.ltiming_adjust = 1,\n\t.apdma_sync = 0,\n\t.max_dma_support = 36,\n};\n\nstatic const struct mtk_i2c_compatible mt8188_compat = {\n\t.regs = mt_i2c_regs_v3,\n\t.pmic_i2c = 0,\n\t.dcm = 0,\n\t.auto_restart = 1,\n\t.aux_len_reg = 1,\n\t.timing_adjust = 1,\n\t.dma_sync = 0,\n\t.ltiming_adjust = 1,\n\t.apdma_sync = 1,\n\t.max_dma_support = 36,\n};\n\nstatic const struct mtk_i2c_compatible mt8192_compat = {\n\t.quirks = &mt8183_i2c_quirks,\n\t.regs = mt_i2c_regs_v2,\n\t.pmic_i2c = 0,\n\t.dcm = 0,\n\t.auto_restart = 1,\n\t.aux_len_reg = 1,\n\t.timing_adjust = 1,\n\t.dma_sync = 1,\n\t.ltiming_adjust = 1,\n\t.apdma_sync = 1,\n\t.max_dma_support = 36,\n};\n\nstatic const struct of_device_id mtk_i2c_of_match[] = {\n\t{ .compatible = \"mediatek,mt2712-i2c\", .data = &mt2712_compat },\n\t{ .compatible = \"mediatek,mt6577-i2c\", .data = &mt6577_compat },\n\t{ .compatible = \"mediatek,mt6589-i2c\", .data = &mt6589_compat },\n\t{ .compatible = \"mediatek,mt7622-i2c\", .data = &mt7622_compat },\n\t{ .compatible = \"mediatek,mt7981-i2c\", .data = &mt7981_compat },\n\t{ .compatible = \"mediatek,mt7986-i2c\", .data = &mt7986_compat },\n\t{ .compatible = \"mediatek,mt8168-i2c\", .data = &mt8168_compat },\n\t{ .compatible = \"mediatek,mt8173-i2c\", .data = &mt8173_compat },\n\t{ .compatible = \"mediatek,mt8183-i2c\", .data = &mt8183_compat },\n\t{ .compatible = \"mediatek,mt8186-i2c\", .data = &mt8186_compat },\n\t{ .compatible = \"mediatek,mt8188-i2c\", .data = &mt8188_compat },\n\t{ .compatible = \"mediatek,mt8192-i2c\", .data = &mt8192_compat },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, mtk_i2c_of_match);\n\nstatic u16 mtk_i2c_readw(struct mtk_i2c *i2c, enum I2C_REGS_OFFSET reg)\n{\n\treturn readw(i2c->base + i2c->dev_comp->regs[reg]);\n}\n\nstatic void mtk_i2c_writew(struct mtk_i2c *i2c, u16 val,\n\t\t\t   enum I2C_REGS_OFFSET reg)\n{\n\twritew(val, i2c->base + i2c->dev_comp->regs[reg]);\n}\n\nstatic void mtk_i2c_init_hw(struct mtk_i2c *i2c)\n{\n\tu16 control_reg;\n\tu16 intr_stat_reg;\n\tu16 ext_conf_val;\n\n\tmtk_i2c_writew(i2c, I2C_CHN_CLR_FLAG, OFFSET_START);\n\tintr_stat_reg = mtk_i2c_readw(i2c, OFFSET_INTR_STAT);\n\tmtk_i2c_writew(i2c, intr_stat_reg, OFFSET_INTR_STAT);\n\n\tif (i2c->dev_comp->apdma_sync) {\n\t\twritel(I2C_DMA_WARM_RST, i2c->pdmabase + OFFSET_RST);\n\t\tudelay(10);\n\t\twritel(I2C_DMA_CLR_FLAG, i2c->pdmabase + OFFSET_RST);\n\t\tudelay(10);\n\t\twritel(I2C_DMA_HANDSHAKE_RST | I2C_DMA_HARD_RST,\n\t\t       i2c->pdmabase + OFFSET_RST);\n\t\tmtk_i2c_writew(i2c, I2C_HANDSHAKE_RST | I2C_SOFT_RST,\n\t\t\t       OFFSET_SOFTRESET);\n\t\tudelay(10);\n\t\twritel(I2C_DMA_CLR_FLAG, i2c->pdmabase + OFFSET_RST);\n\t\tmtk_i2c_writew(i2c, I2C_CHN_CLR_FLAG, OFFSET_SOFTRESET);\n\t} else {\n\t\twritel(I2C_DMA_HARD_RST, i2c->pdmabase + OFFSET_RST);\n\t\tudelay(50);\n\t\twritel(I2C_DMA_CLR_FLAG, i2c->pdmabase + OFFSET_RST);\n\t\tmtk_i2c_writew(i2c, I2C_SOFT_RST, OFFSET_SOFTRESET);\n\t}\n\n\t \n\tif (i2c->use_push_pull)\n\t\tmtk_i2c_writew(i2c, I2C_IO_CONFIG_PUSH_PULL, OFFSET_IO_CONFIG);\n\telse\n\t\tmtk_i2c_writew(i2c, I2C_IO_CONFIG_OPEN_DRAIN, OFFSET_IO_CONFIG);\n\n\tif (i2c->dev_comp->dcm)\n\t\tmtk_i2c_writew(i2c, I2C_DCM_DISABLE, OFFSET_DCM_EN);\n\n\tmtk_i2c_writew(i2c, i2c->timing_reg, OFFSET_TIMING);\n\tmtk_i2c_writew(i2c, i2c->high_speed_reg, OFFSET_HS);\n\tif (i2c->dev_comp->ltiming_adjust)\n\t\tmtk_i2c_writew(i2c, i2c->ltiming_reg, OFFSET_LTIMING);\n\n\tif (i2c->speed_hz <= I2C_MAX_STANDARD_MODE_FREQ)\n\t\text_conf_val = I2C_ST_START_CON;\n\telse\n\t\text_conf_val = I2C_FS_START_CON;\n\n\tif (i2c->dev_comp->timing_adjust) {\n\t\text_conf_val = i2c->ac_timing.ext;\n\t\tmtk_i2c_writew(i2c, i2c->ac_timing.inter_clk_div,\n\t\t\t       OFFSET_CLOCK_DIV);\n\t\tmtk_i2c_writew(i2c, I2C_SCL_MIS_COMP_VALUE,\n\t\t\t       OFFSET_SCL_MIS_COMP_POINT);\n\t\tmtk_i2c_writew(i2c, i2c->ac_timing.sda_timing,\n\t\t\t       OFFSET_SDA_TIMING);\n\n\t\tif (i2c->dev_comp->ltiming_adjust) {\n\t\t\tmtk_i2c_writew(i2c, i2c->ac_timing.htiming,\n\t\t\t\t       OFFSET_TIMING);\n\t\t\tmtk_i2c_writew(i2c, i2c->ac_timing.hs, OFFSET_HS);\n\t\t\tmtk_i2c_writew(i2c, i2c->ac_timing.ltiming,\n\t\t\t\t       OFFSET_LTIMING);\n\t\t} else {\n\t\t\tmtk_i2c_writew(i2c, i2c->ac_timing.scl_hl_ratio,\n\t\t\t\t       OFFSET_SCL_HIGH_LOW_RATIO);\n\t\t\tmtk_i2c_writew(i2c, i2c->ac_timing.hs_scl_hl_ratio,\n\t\t\t\t       OFFSET_HS_SCL_HIGH_LOW_RATIO);\n\t\t\tmtk_i2c_writew(i2c, i2c->ac_timing.sta_stop,\n\t\t\t\t       OFFSET_STA_STO_AC_TIMING);\n\t\t\tmtk_i2c_writew(i2c, i2c->ac_timing.hs_sta_stop,\n\t\t\t\t       OFFSET_HS_STA_STO_AC_TIMING);\n\t\t}\n\t}\n\tmtk_i2c_writew(i2c, ext_conf_val, OFFSET_EXT_CONF);\n\n\t \n\tif (i2c->have_pmic)\n\t\tmtk_i2c_writew(i2c, I2C_CONTROL_WRAPPER, OFFSET_PATH_DIR);\n\n\tcontrol_reg = I2C_CONTROL_ACKERR_DET_EN |\n\t\t      I2C_CONTROL_CLK_EXT_EN | I2C_CONTROL_DMA_EN;\n\tif (i2c->dev_comp->dma_sync)\n\t\tcontrol_reg |= I2C_CONTROL_DMAACK_EN | I2C_CONTROL_ASYNC_MODE;\n\n\tmtk_i2c_writew(i2c, control_reg, OFFSET_CONTROL);\n\tmtk_i2c_writew(i2c, I2C_DELAY_LEN, OFFSET_DELAY_LEN);\n}\n\nstatic const struct i2c_spec_values *mtk_i2c_get_spec(unsigned int speed)\n{\n\tif (speed <= I2C_MAX_STANDARD_MODE_FREQ)\n\t\treturn &standard_mode_spec;\n\telse if (speed <= I2C_MAX_FAST_MODE_FREQ)\n\t\treturn &fast_mode_spec;\n\telse\n\t\treturn &fast_mode_plus_spec;\n}\n\nstatic int mtk_i2c_max_step_cnt(unsigned int target_speed)\n{\n\tif (target_speed > I2C_MAX_FAST_MODE_PLUS_FREQ)\n\t\treturn MAX_HS_STEP_CNT_DIV;\n\telse\n\t\treturn MAX_STEP_CNT_DIV;\n}\n\nstatic int mtk_i2c_get_clk_div_restri(struct mtk_i2c *i2c,\n\t\t\t\t      unsigned int sample_cnt)\n{\n\tint clk_div_restri = 0;\n\n\tif (i2c->dev_comp->ltiming_adjust == 0)\n\t\treturn 0;\n\n\tif (sample_cnt == 1) {\n\t\tif (i2c->ac_timing.inter_clk_div == 0)\n\t\t\tclk_div_restri = 0;\n\t\telse\n\t\t\tclk_div_restri = 1;\n\t} else {\n\t\tif (i2c->ac_timing.inter_clk_div == 0)\n\t\t\tclk_div_restri = -1;\n\t\telse if (i2c->ac_timing.inter_clk_div == 1)\n\t\t\tclk_div_restri = 0;\n\t\telse\n\t\t\tclk_div_restri = 1;\n\t}\n\n\treturn clk_div_restri;\n}\n\n \nstatic int mtk_i2c_check_ac_timing(struct mtk_i2c *i2c,\n\t\t\t\t   unsigned int clk_src,\n\t\t\t\t   unsigned int check_speed,\n\t\t\t\t   unsigned int step_cnt,\n\t\t\t\t   unsigned int sample_cnt)\n{\n\tconst struct i2c_spec_values *spec;\n\tunsigned int su_sta_cnt, low_cnt, high_cnt, max_step_cnt;\n\tunsigned int sda_max, sda_min, clk_ns, max_sta_cnt = 0x3f;\n\tunsigned int sample_ns = div_u64(1000000000ULL * (sample_cnt + 1),\n\t\t\t\t\t clk_src);\n\n\tif (!i2c->dev_comp->timing_adjust)\n\t\treturn 0;\n\n\tif (i2c->dev_comp->ltiming_adjust)\n\t\tmax_sta_cnt = 0x100;\n\n\tspec = mtk_i2c_get_spec(check_speed);\n\n\tif (i2c->dev_comp->ltiming_adjust)\n\t\tclk_ns = 1000000000 / clk_src;\n\telse\n\t\tclk_ns = sample_ns / 2;\n\n\tsu_sta_cnt = DIV_ROUND_UP(spec->min_su_sta_ns +\n\t\t\t\t  i2c->timing_info.scl_int_delay_ns, clk_ns);\n\tif (su_sta_cnt > max_sta_cnt)\n\t\treturn -1;\n\n\tlow_cnt = DIV_ROUND_UP(spec->min_low_ns, sample_ns);\n\tmax_step_cnt = mtk_i2c_max_step_cnt(check_speed);\n\tif ((2 * step_cnt) > low_cnt && low_cnt < max_step_cnt) {\n\t\tif (low_cnt > step_cnt) {\n\t\t\thigh_cnt = 2 * step_cnt - low_cnt;\n\t\t} else {\n\t\t\thigh_cnt = step_cnt;\n\t\t\tlow_cnt = step_cnt;\n\t\t}\n\t} else {\n\t\treturn -2;\n\t}\n\n\tsda_max = spec->max_hd_dat_ns / sample_ns;\n\tif (sda_max > low_cnt)\n\t\tsda_max = 0;\n\n\tsda_min = DIV_ROUND_UP(spec->min_su_dat_ns, sample_ns);\n\tif (sda_min < low_cnt)\n\t\tsda_min = 0;\n\n\tif (sda_min > sda_max)\n\t\treturn -3;\n\n\tif (check_speed > I2C_MAX_FAST_MODE_PLUS_FREQ) {\n\t\tif (i2c->dev_comp->ltiming_adjust) {\n\t\t\ti2c->ac_timing.hs = I2C_TIME_DEFAULT_VALUE |\n\t\t\t\t(sample_cnt << 12) | (high_cnt << 8);\n\t\t\ti2c->ac_timing.ltiming &= ~GENMASK(15, 9);\n\t\t\ti2c->ac_timing.ltiming |= (sample_cnt << 12) |\n\t\t\t\t(low_cnt << 9);\n\t\t\ti2c->ac_timing.ext &= ~GENMASK(7, 1);\n\t\t\ti2c->ac_timing.ext |= (su_sta_cnt << 1) | (1 << 0);\n\t\t} else {\n\t\t\ti2c->ac_timing.hs_scl_hl_ratio = (1 << 12) |\n\t\t\t\t(high_cnt << 6) | low_cnt;\n\t\t\ti2c->ac_timing.hs_sta_stop = (su_sta_cnt << 8) |\n\t\t\t\tsu_sta_cnt;\n\t\t}\n\t\ti2c->ac_timing.sda_timing &= ~GENMASK(11, 6);\n\t\ti2c->ac_timing.sda_timing |= (1 << 12) |\n\t\t\t((sda_max + sda_min) / 2) << 6;\n\t} else {\n\t\tif (i2c->dev_comp->ltiming_adjust) {\n\t\t\ti2c->ac_timing.htiming = (sample_cnt << 8) | (high_cnt);\n\t\t\ti2c->ac_timing.ltiming = (sample_cnt << 6) | (low_cnt);\n\t\t\ti2c->ac_timing.ext = (su_sta_cnt << 8) | (1 << 0);\n\t\t} else {\n\t\t\ti2c->ac_timing.scl_hl_ratio = (1 << 12) |\n\t\t\t\t(high_cnt << 6) | low_cnt;\n\t\t\ti2c->ac_timing.sta_stop = (su_sta_cnt << 8) |\n\t\t\t\tsu_sta_cnt;\n\t\t}\n\n\t\ti2c->ac_timing.sda_timing = (1 << 12) |\n\t\t\t(sda_max + sda_min) / 2;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int mtk_i2c_calculate_speed(struct mtk_i2c *i2c, unsigned int clk_src,\n\t\t\t\t   unsigned int target_speed,\n\t\t\t\t   unsigned int *timing_step_cnt,\n\t\t\t\t   unsigned int *timing_sample_cnt)\n{\n\tunsigned int step_cnt;\n\tunsigned int sample_cnt;\n\tunsigned int max_step_cnt;\n\tunsigned int base_sample_cnt = MAX_SAMPLE_CNT_DIV;\n\tunsigned int base_step_cnt;\n\tunsigned int opt_div;\n\tunsigned int best_mul;\n\tunsigned int cnt_mul;\n\tint ret = -EINVAL;\n\tint clk_div_restri = 0;\n\n\tif (target_speed > I2C_MAX_HIGH_SPEED_MODE_FREQ)\n\t\ttarget_speed = I2C_MAX_HIGH_SPEED_MODE_FREQ;\n\n\tmax_step_cnt = mtk_i2c_max_step_cnt(target_speed);\n\tbase_step_cnt = max_step_cnt;\n\t \n\topt_div = DIV_ROUND_UP(clk_src >> 1, target_speed);\n\tbest_mul = MAX_SAMPLE_CNT_DIV * max_step_cnt;\n\n\t \n\tfor (sample_cnt = 1; sample_cnt <= MAX_SAMPLE_CNT_DIV; sample_cnt++) {\n\t\tclk_div_restri = mtk_i2c_get_clk_div_restri(i2c, sample_cnt);\n\t\tstep_cnt = DIV_ROUND_UP(opt_div + clk_div_restri, sample_cnt);\n\t\tcnt_mul = step_cnt * sample_cnt;\n\t\tif (step_cnt > max_step_cnt)\n\t\t\tcontinue;\n\n\t\tif (cnt_mul < best_mul) {\n\t\t\tret = mtk_i2c_check_ac_timing(i2c, clk_src,\n\t\t\t\ttarget_speed, step_cnt - 1, sample_cnt - 1);\n\t\t\tif (ret)\n\t\t\t\tcontinue;\n\n\t\t\tbest_mul = cnt_mul;\n\t\t\tbase_sample_cnt = sample_cnt;\n\t\t\tbase_step_cnt = step_cnt;\n\t\t\tif (best_mul == (opt_div + clk_div_restri))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ret)\n\t\treturn -EINVAL;\n\n\tsample_cnt = base_sample_cnt;\n\tstep_cnt = base_step_cnt;\n\n\tif ((clk_src / (2 * (sample_cnt * step_cnt - clk_div_restri))) >\n\t\ttarget_speed) {\n\t\t \n\t\tdev_dbg(i2c->dev, \"Unsupported speed (%uhz)\\n\",\ttarget_speed);\n\t\treturn -EINVAL;\n\t}\n\n\t*timing_step_cnt = step_cnt - 1;\n\t*timing_sample_cnt = sample_cnt - 1;\n\n\treturn 0;\n}\n\nstatic int mtk_i2c_set_speed(struct mtk_i2c *i2c, unsigned int parent_clk)\n{\n\tunsigned int clk_src;\n\tunsigned int step_cnt;\n\tunsigned int sample_cnt;\n\tunsigned int l_step_cnt;\n\tunsigned int l_sample_cnt;\n\tunsigned int target_speed;\n\tunsigned int clk_div;\n\tunsigned int max_clk_div;\n\tint ret;\n\n\ttarget_speed = i2c->speed_hz;\n\tparent_clk /= i2c->clk_src_div;\n\n\tif (i2c->dev_comp->timing_adjust && i2c->dev_comp->ltiming_adjust)\n\t\tmax_clk_div = MAX_CLOCK_DIV_5BITS;\n\telse if (i2c->dev_comp->timing_adjust)\n\t\tmax_clk_div = MAX_CLOCK_DIV_8BITS;\n\telse\n\t\tmax_clk_div = 1;\n\n\tfor (clk_div = 1; clk_div <= max_clk_div; clk_div++) {\n\t\tclk_src = parent_clk / clk_div;\n\t\ti2c->ac_timing.inter_clk_div = clk_div - 1;\n\n\t\tif (target_speed > I2C_MAX_FAST_MODE_PLUS_FREQ) {\n\t\t\t \n\t\t\tret = mtk_i2c_calculate_speed(i2c, clk_src,\n\t\t\t\t\t\t      I2C_MAX_FAST_MODE_FREQ,\n\t\t\t\t\t\t      &l_step_cnt,\n\t\t\t\t\t\t      &l_sample_cnt);\n\t\t\tif (ret < 0)\n\t\t\t\tcontinue;\n\n\t\t\ti2c->timing_reg = (l_sample_cnt << 8) | l_step_cnt;\n\n\t\t\t \n\t\t\tret = mtk_i2c_calculate_speed(i2c, clk_src,\n\t\t\t\t\t\t      target_speed, &step_cnt,\n\t\t\t\t\t\t      &sample_cnt);\n\t\t\tif (ret < 0)\n\t\t\t\tcontinue;\n\n\t\t\ti2c->high_speed_reg = I2C_TIME_DEFAULT_VALUE |\n\t\t\t\t\t(sample_cnt << 12) | (step_cnt << 8);\n\n\t\t\tif (i2c->dev_comp->ltiming_adjust)\n\t\t\t\ti2c->ltiming_reg =\n\t\t\t\t\t(l_sample_cnt << 6) | l_step_cnt |\n\t\t\t\t\t(sample_cnt << 12) | (step_cnt << 9);\n\t\t} else {\n\t\t\tret = mtk_i2c_calculate_speed(i2c, clk_src,\n\t\t\t\t\t\t      target_speed, &l_step_cnt,\n\t\t\t\t\t\t      &l_sample_cnt);\n\t\t\tif (ret < 0)\n\t\t\t\tcontinue;\n\n\t\t\ti2c->timing_reg = (l_sample_cnt << 8) | l_step_cnt;\n\n\t\t\t \n\t\t\ti2c->high_speed_reg = I2C_TIME_CLR_VALUE;\n\n\t\t\tif (i2c->dev_comp->ltiming_adjust)\n\t\t\t\ti2c->ltiming_reg =\n\t\t\t\t\t(l_sample_cnt << 6) | l_step_cnt;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\n\treturn 0;\n}\n\nstatic void i2c_dump_register(struct mtk_i2c *i2c)\n{\n\tdev_dbg(i2c->dev, \"SLAVE_ADDR: 0x%x, INTR_MASK: 0x%x\\n\",\n\t\tmtk_i2c_readw(i2c, OFFSET_SLAVE_ADDR),\n\t\tmtk_i2c_readw(i2c, OFFSET_INTR_MASK));\n\tdev_dbg(i2c->dev, \"INTR_STAT: 0x%x, CONTROL: 0x%x\\n\",\n\t\tmtk_i2c_readw(i2c, OFFSET_INTR_STAT),\n\t\tmtk_i2c_readw(i2c, OFFSET_CONTROL));\n\tdev_dbg(i2c->dev, \"TRANSFER_LEN: 0x%x, TRANSAC_LEN: 0x%x\\n\",\n\t\tmtk_i2c_readw(i2c, OFFSET_TRANSFER_LEN),\n\t\tmtk_i2c_readw(i2c, OFFSET_TRANSAC_LEN));\n\tdev_dbg(i2c->dev, \"DELAY_LEN: 0x%x, HTIMING: 0x%x\\n\",\n\t\tmtk_i2c_readw(i2c, OFFSET_DELAY_LEN),\n\t\tmtk_i2c_readw(i2c, OFFSET_TIMING));\n\tdev_dbg(i2c->dev, \"START: 0x%x, EXT_CONF: 0x%x\\n\",\n\t\tmtk_i2c_readw(i2c, OFFSET_START),\n\t\tmtk_i2c_readw(i2c, OFFSET_EXT_CONF));\n\tdev_dbg(i2c->dev, \"HS: 0x%x, IO_CONFIG: 0x%x\\n\",\n\t\tmtk_i2c_readw(i2c, OFFSET_HS),\n\t\tmtk_i2c_readw(i2c, OFFSET_IO_CONFIG));\n\tdev_dbg(i2c->dev, \"DCM_EN: 0x%x, TRANSFER_LEN_AUX: 0x%x\\n\",\n\t\tmtk_i2c_readw(i2c, OFFSET_DCM_EN),\n\t\tmtk_i2c_readw(i2c, OFFSET_TRANSFER_LEN_AUX));\n\tdev_dbg(i2c->dev, \"CLOCK_DIV: 0x%x, FIFO_STAT: 0x%x\\n\",\n\t\tmtk_i2c_readw(i2c, OFFSET_CLOCK_DIV),\n\t\tmtk_i2c_readw(i2c, OFFSET_FIFO_STAT));\n\tdev_dbg(i2c->dev, \"DEBUGCTRL : 0x%x, DEBUGSTAT: 0x%x\\n\",\n\t\tmtk_i2c_readw(i2c, OFFSET_DEBUGCTRL),\n\t\tmtk_i2c_readw(i2c, OFFSET_DEBUGSTAT));\n\tif (i2c->dev_comp->regs == mt_i2c_regs_v2) {\n\t\tdev_dbg(i2c->dev, \"LTIMING: 0x%x, MULTI_DMA: 0x%x\\n\",\n\t\t\tmtk_i2c_readw(i2c, OFFSET_LTIMING),\n\t\t\tmtk_i2c_readw(i2c, OFFSET_MULTI_DMA));\n\t}\n\tdev_dbg(i2c->dev, \"\\nDMA_INT_FLAG: 0x%x, DMA_INT_EN: 0x%x\\n\",\n\t\treadl(i2c->pdmabase + OFFSET_INT_FLAG),\n\t\treadl(i2c->pdmabase + OFFSET_INT_EN));\n\tdev_dbg(i2c->dev, \"DMA_EN: 0x%x, DMA_CON: 0x%x\\n\",\n\t\treadl(i2c->pdmabase + OFFSET_EN),\n\t\treadl(i2c->pdmabase + OFFSET_CON));\n\tdev_dbg(i2c->dev, \"DMA_TX_MEM_ADDR: 0x%x, DMA_RX_MEM_ADDR: 0x%x\\n\",\n\t\treadl(i2c->pdmabase + OFFSET_TX_MEM_ADDR),\n\t\treadl(i2c->pdmabase + OFFSET_RX_MEM_ADDR));\n\tdev_dbg(i2c->dev, \"DMA_TX_LEN: 0x%x, DMA_RX_LEN: 0x%x\\n\",\n\t\treadl(i2c->pdmabase + OFFSET_TX_LEN),\n\t\treadl(i2c->pdmabase + OFFSET_RX_LEN));\n\tdev_dbg(i2c->dev, \"DMA_TX_4G_MODE: 0x%x, DMA_RX_4G_MODE: 0x%x\",\n\t\treadl(i2c->pdmabase + OFFSET_TX_4G_MODE),\n\t\treadl(i2c->pdmabase + OFFSET_RX_4G_MODE));\n}\n\nstatic int mtk_i2c_do_transfer(struct mtk_i2c *i2c, struct i2c_msg *msgs,\n\t\t\t       int num, int left_num)\n{\n\tu16 addr_reg;\n\tu16 start_reg;\n\tu16 control_reg;\n\tu16 restart_flag = 0;\n\tu16 dma_sync = 0;\n\tu32 reg_4g_mode;\n\tu32 reg_dma_reset;\n\tu8 *dma_rd_buf = NULL;\n\tu8 *dma_wr_buf = NULL;\n\tdma_addr_t rpaddr = 0;\n\tdma_addr_t wpaddr = 0;\n\tint ret;\n\n\ti2c->irq_stat = 0;\n\n\tif (i2c->auto_restart)\n\t\trestart_flag = I2C_RS_TRANSFER;\n\n\treinit_completion(&i2c->msg_complete);\n\n\tif (i2c->dev_comp->apdma_sync &&\n\t    i2c->op != I2C_MASTER_WRRD && num > 1) {\n\t\tmtk_i2c_writew(i2c, 0x00, OFFSET_DEBUGCTRL);\n\t\twritel(I2C_DMA_HANDSHAKE_RST | I2C_DMA_WARM_RST,\n\t\t       i2c->pdmabase + OFFSET_RST);\n\n\t\tret = readw_poll_timeout(i2c->pdmabase + OFFSET_RST,\n\t\t\t\t\t reg_dma_reset,\n\t\t\t\t\t !(reg_dma_reset & I2C_DMA_WARM_RST),\n\t\t\t\t\t 0, 100);\n\t\tif (ret) {\n\t\t\tdev_err(i2c->dev, \"DMA warm reset timeout\\n\");\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\n\t\twritel(I2C_DMA_CLR_FLAG, i2c->pdmabase + OFFSET_RST);\n\t\tmtk_i2c_writew(i2c, I2C_HANDSHAKE_RST, OFFSET_SOFTRESET);\n\t\tmtk_i2c_writew(i2c, I2C_CHN_CLR_FLAG, OFFSET_SOFTRESET);\n\t\tmtk_i2c_writew(i2c, I2C_RELIABILITY | I2C_DMAACK_ENABLE,\n\t\t\t       OFFSET_DEBUGCTRL);\n\t}\n\n\tcontrol_reg = mtk_i2c_readw(i2c, OFFSET_CONTROL) &\n\t\t\t~(I2C_CONTROL_DIR_CHANGE | I2C_CONTROL_RS);\n\tif ((i2c->speed_hz > I2C_MAX_FAST_MODE_PLUS_FREQ) || (left_num >= 1))\n\t\tcontrol_reg |= I2C_CONTROL_RS;\n\n\tif (i2c->op == I2C_MASTER_WRRD)\n\t\tcontrol_reg |= I2C_CONTROL_DIR_CHANGE | I2C_CONTROL_RS;\n\n\tmtk_i2c_writew(i2c, control_reg, OFFSET_CONTROL);\n\n\taddr_reg = i2c_8bit_addr_from_msg(msgs);\n\tmtk_i2c_writew(i2c, addr_reg, OFFSET_SLAVE_ADDR);\n\n\t \n\tmtk_i2c_writew(i2c, restart_flag | I2C_HS_NACKERR | I2C_ACKERR |\n\t\t\t    I2C_ARB_LOST | I2C_TRANSAC_COMP, OFFSET_INTR_STAT);\n\n\tmtk_i2c_writew(i2c, I2C_FIFO_ADDR_CLR, OFFSET_FIFO_ADDR_CLR);\n\n\t \n\tmtk_i2c_writew(i2c, restart_flag | I2C_HS_NACKERR | I2C_ACKERR |\n\t\t\t    I2C_ARB_LOST | I2C_TRANSAC_COMP, OFFSET_INTR_MASK);\n\n\t \n\tif (i2c->op == I2C_MASTER_WRRD) {\n\t\tif (i2c->dev_comp->aux_len_reg) {\n\t\t\tmtk_i2c_writew(i2c, msgs->len, OFFSET_TRANSFER_LEN);\n\t\t\tmtk_i2c_writew(i2c, (msgs + 1)->len,\n\t\t\t\t\t    OFFSET_TRANSFER_LEN_AUX);\n\t\t} else {\n\t\t\tmtk_i2c_writew(i2c, msgs->len | ((msgs + 1)->len) << 8,\n\t\t\t\t\t    OFFSET_TRANSFER_LEN);\n\t\t}\n\t\tmtk_i2c_writew(i2c, I2C_WRRD_TRANAC_VALUE, OFFSET_TRANSAC_LEN);\n\t} else {\n\t\tmtk_i2c_writew(i2c, msgs->len, OFFSET_TRANSFER_LEN);\n\t\tmtk_i2c_writew(i2c, num, OFFSET_TRANSAC_LEN);\n\t}\n\n\tif (i2c->dev_comp->apdma_sync) {\n\t\tdma_sync = I2C_DMA_SKIP_CONFIG | I2C_DMA_ASYNC_MODE;\n\t\tif (i2c->op == I2C_MASTER_WRRD)\n\t\t\tdma_sync |= I2C_DMA_DIR_CHANGE;\n\t}\n\n\t \n\tif (i2c->op == I2C_MASTER_RD) {\n\t\twritel(I2C_DMA_INT_FLAG_NONE, i2c->pdmabase + OFFSET_INT_FLAG);\n\t\twritel(I2C_DMA_CON_RX | dma_sync, i2c->pdmabase + OFFSET_CON);\n\n\t\tdma_rd_buf = i2c_get_dma_safe_msg_buf(msgs, 1);\n\t\tif (!dma_rd_buf)\n\t\t\treturn -ENOMEM;\n\n\t\trpaddr = dma_map_single(i2c->dev, dma_rd_buf,\n\t\t\t\t\tmsgs->len, DMA_FROM_DEVICE);\n\t\tif (dma_mapping_error(i2c->dev, rpaddr)) {\n\t\t\ti2c_put_dma_safe_msg_buf(dma_rd_buf, msgs, false);\n\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tif (i2c->dev_comp->max_dma_support > 32) {\n\t\t\treg_4g_mode = upper_32_bits(rpaddr);\n\t\t\twritel(reg_4g_mode, i2c->pdmabase + OFFSET_RX_4G_MODE);\n\t\t}\n\n\t\twritel((u32)rpaddr, i2c->pdmabase + OFFSET_RX_MEM_ADDR);\n\t\twritel(msgs->len, i2c->pdmabase + OFFSET_RX_LEN);\n\t} else if (i2c->op == I2C_MASTER_WR) {\n\t\twritel(I2C_DMA_INT_FLAG_NONE, i2c->pdmabase + OFFSET_INT_FLAG);\n\t\twritel(I2C_DMA_CON_TX | dma_sync, i2c->pdmabase + OFFSET_CON);\n\n\t\tdma_wr_buf = i2c_get_dma_safe_msg_buf(msgs, 1);\n\t\tif (!dma_wr_buf)\n\t\t\treturn -ENOMEM;\n\n\t\twpaddr = dma_map_single(i2c->dev, dma_wr_buf,\n\t\t\t\t\tmsgs->len, DMA_TO_DEVICE);\n\t\tif (dma_mapping_error(i2c->dev, wpaddr)) {\n\t\t\ti2c_put_dma_safe_msg_buf(dma_wr_buf, msgs, false);\n\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tif (i2c->dev_comp->max_dma_support > 32) {\n\t\t\treg_4g_mode = upper_32_bits(wpaddr);\n\t\t\twritel(reg_4g_mode, i2c->pdmabase + OFFSET_TX_4G_MODE);\n\t\t}\n\n\t\twritel((u32)wpaddr, i2c->pdmabase + OFFSET_TX_MEM_ADDR);\n\t\twritel(msgs->len, i2c->pdmabase + OFFSET_TX_LEN);\n\t} else {\n\t\twritel(I2C_DMA_CLR_FLAG, i2c->pdmabase + OFFSET_INT_FLAG);\n\t\twritel(I2C_DMA_CLR_FLAG | dma_sync, i2c->pdmabase + OFFSET_CON);\n\n\t\tdma_wr_buf = i2c_get_dma_safe_msg_buf(msgs, 1);\n\t\tif (!dma_wr_buf)\n\t\t\treturn -ENOMEM;\n\n\t\twpaddr = dma_map_single(i2c->dev, dma_wr_buf,\n\t\t\t\t\tmsgs->len, DMA_TO_DEVICE);\n\t\tif (dma_mapping_error(i2c->dev, wpaddr)) {\n\t\t\ti2c_put_dma_safe_msg_buf(dma_wr_buf, msgs, false);\n\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tdma_rd_buf = i2c_get_dma_safe_msg_buf((msgs + 1), 1);\n\t\tif (!dma_rd_buf) {\n\t\t\tdma_unmap_single(i2c->dev, wpaddr,\n\t\t\t\t\t msgs->len, DMA_TO_DEVICE);\n\n\t\t\ti2c_put_dma_safe_msg_buf(dma_wr_buf, msgs, false);\n\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\trpaddr = dma_map_single(i2c->dev, dma_rd_buf,\n\t\t\t\t\t(msgs + 1)->len,\n\t\t\t\t\tDMA_FROM_DEVICE);\n\t\tif (dma_mapping_error(i2c->dev, rpaddr)) {\n\t\t\tdma_unmap_single(i2c->dev, wpaddr,\n\t\t\t\t\t msgs->len, DMA_TO_DEVICE);\n\n\t\t\ti2c_put_dma_safe_msg_buf(dma_wr_buf, msgs, false);\n\t\t\ti2c_put_dma_safe_msg_buf(dma_rd_buf, (msgs + 1), false);\n\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tif (i2c->dev_comp->max_dma_support > 32) {\n\t\t\treg_4g_mode = upper_32_bits(wpaddr);\n\t\t\twritel(reg_4g_mode, i2c->pdmabase + OFFSET_TX_4G_MODE);\n\n\t\t\treg_4g_mode = upper_32_bits(rpaddr);\n\t\t\twritel(reg_4g_mode, i2c->pdmabase + OFFSET_RX_4G_MODE);\n\t\t}\n\n\t\twritel((u32)wpaddr, i2c->pdmabase + OFFSET_TX_MEM_ADDR);\n\t\twritel((u32)rpaddr, i2c->pdmabase + OFFSET_RX_MEM_ADDR);\n\t\twritel(msgs->len, i2c->pdmabase + OFFSET_TX_LEN);\n\t\twritel((msgs + 1)->len, i2c->pdmabase + OFFSET_RX_LEN);\n\t}\n\n\twritel(I2C_DMA_START_EN, i2c->pdmabase + OFFSET_EN);\n\n\tif (!i2c->auto_restart) {\n\t\tstart_reg = I2C_TRANSAC_START;\n\t} else {\n\t\tstart_reg = I2C_TRANSAC_START | I2C_RS_MUL_TRIG;\n\t\tif (left_num >= 1)\n\t\t\tstart_reg |= I2C_RS_MUL_CNFG;\n\t}\n\tmtk_i2c_writew(i2c, start_reg, OFFSET_START);\n\n\tret = wait_for_completion_timeout(&i2c->msg_complete,\n\t\t\t\t\t  i2c->adap.timeout);\n\n\t \n\tmtk_i2c_writew(i2c, ~(restart_flag | I2C_HS_NACKERR | I2C_ACKERR |\n\t\t\t    I2C_ARB_LOST | I2C_TRANSAC_COMP), OFFSET_INTR_MASK);\n\n\tif (i2c->op == I2C_MASTER_WR) {\n\t\tdma_unmap_single(i2c->dev, wpaddr,\n\t\t\t\t msgs->len, DMA_TO_DEVICE);\n\n\t\ti2c_put_dma_safe_msg_buf(dma_wr_buf, msgs, true);\n\t} else if (i2c->op == I2C_MASTER_RD) {\n\t\tdma_unmap_single(i2c->dev, rpaddr,\n\t\t\t\t msgs->len, DMA_FROM_DEVICE);\n\n\t\ti2c_put_dma_safe_msg_buf(dma_rd_buf, msgs, true);\n\t} else {\n\t\tdma_unmap_single(i2c->dev, wpaddr, msgs->len,\n\t\t\t\t DMA_TO_DEVICE);\n\t\tdma_unmap_single(i2c->dev, rpaddr, (msgs + 1)->len,\n\t\t\t\t DMA_FROM_DEVICE);\n\n\t\ti2c_put_dma_safe_msg_buf(dma_wr_buf, msgs, true);\n\t\ti2c_put_dma_safe_msg_buf(dma_rd_buf, (msgs + 1), true);\n\t}\n\n\tif (ret == 0) {\n\t\tdev_dbg(i2c->dev, \"addr: %x, transfer timeout\\n\", msgs->addr);\n\t\ti2c_dump_register(i2c);\n\t\tmtk_i2c_init_hw(i2c);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tif (i2c->irq_stat & (I2C_HS_NACKERR | I2C_ACKERR)) {\n\t\tdev_dbg(i2c->dev, \"addr: %x, transfer ACK error\\n\", msgs->addr);\n\t\tmtk_i2c_init_hw(i2c);\n\t\treturn -ENXIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int mtk_i2c_transfer(struct i2c_adapter *adap,\n\t\t\t    struct i2c_msg msgs[], int num)\n{\n\tint ret;\n\tint left_num = num;\n\tstruct mtk_i2c *i2c = i2c_get_adapdata(adap);\n\n\tret = clk_bulk_enable(I2C_MT65XX_CLK_MAX, i2c->clocks);\n\tif (ret)\n\t\treturn ret;\n\n\ti2c->auto_restart = i2c->dev_comp->auto_restart;\n\n\t \n\tif (i2c->auto_restart && num == 2) {\n\t\tif (!(msgs[0].flags & I2C_M_RD) && (msgs[1].flags & I2C_M_RD) &&\n\t\t    msgs[0].addr == msgs[1].addr) {\n\t\t\ti2c->auto_restart = 0;\n\t\t}\n\t}\n\n\tif (i2c->auto_restart && num >= 2 &&\n\t\ti2c->speed_hz > I2C_MAX_FAST_MODE_PLUS_FREQ)\n\t\t \n\t\ti2c->ignore_restart_irq = true;\n\telse\n\t\ti2c->ignore_restart_irq = false;\n\n\twhile (left_num--) {\n\t\tif (!msgs->buf) {\n\t\t\tdev_dbg(i2c->dev, \"data buffer is NULL.\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_exit;\n\t\t}\n\n\t\tif (msgs->flags & I2C_M_RD)\n\t\t\ti2c->op = I2C_MASTER_RD;\n\t\telse\n\t\t\ti2c->op = I2C_MASTER_WR;\n\n\t\tif (!i2c->auto_restart) {\n\t\t\tif (num > 1) {\n\t\t\t\t \n\t\t\t\ti2c->op = I2C_MASTER_WRRD;\n\t\t\t\tleft_num--;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tret = mtk_i2c_do_transfer(i2c, msgs, num, left_num);\n\t\tif (ret < 0)\n\t\t\tgoto err_exit;\n\n\t\tmsgs++;\n\t}\n\t \n\tret = num;\n\nerr_exit:\n\tclk_bulk_disable(I2C_MT65XX_CLK_MAX, i2c->clocks);\n\treturn ret;\n}\n\nstatic irqreturn_t mtk_i2c_irq(int irqno, void *dev_id)\n{\n\tstruct mtk_i2c *i2c = dev_id;\n\tu16 restart_flag = 0;\n\tu16 intr_stat;\n\n\tif (i2c->auto_restart)\n\t\trestart_flag = I2C_RS_TRANSFER;\n\n\tintr_stat = mtk_i2c_readw(i2c, OFFSET_INTR_STAT);\n\tmtk_i2c_writew(i2c, intr_stat, OFFSET_INTR_STAT);\n\n\t \n\ti2c->irq_stat |= intr_stat;\n\n\tif (i2c->ignore_restart_irq && (i2c->irq_stat & restart_flag)) {\n\t\ti2c->ignore_restart_irq = false;\n\t\ti2c->irq_stat = 0;\n\t\tmtk_i2c_writew(i2c, I2C_RS_MUL_CNFG | I2C_RS_MUL_TRIG |\n\t\t\t\t    I2C_TRANSAC_START, OFFSET_START);\n\t} else {\n\t\tif (i2c->irq_stat & (I2C_TRANSAC_COMP | restart_flag))\n\t\t\tcomplete(&i2c->msg_complete);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic u32 mtk_i2c_functionality(struct i2c_adapter *adap)\n{\n\tif (i2c_check_quirks(adap, I2C_AQ_NO_ZERO_LEN))\n\t\treturn I2C_FUNC_I2C |\n\t\t\t(I2C_FUNC_SMBUS_EMUL & ~I2C_FUNC_SMBUS_QUICK);\n\telse\n\t\treturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;\n}\n\nstatic const struct i2c_algorithm mtk_i2c_algorithm = {\n\t.master_xfer = mtk_i2c_transfer,\n\t.functionality = mtk_i2c_functionality,\n};\n\nstatic int mtk_i2c_parse_dt(struct device_node *np, struct mtk_i2c *i2c)\n{\n\tint ret;\n\n\tret = of_property_read_u32(np, \"clock-frequency\", &i2c->speed_hz);\n\tif (ret < 0)\n\t\ti2c->speed_hz = I2C_MAX_STANDARD_MODE_FREQ;\n\n\tret = of_property_read_u32(np, \"clock-div\", &i2c->clk_src_div);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (i2c->clk_src_div == 0)\n\t\treturn -EINVAL;\n\n\ti2c->have_pmic = of_property_read_bool(np, \"mediatek,have-pmic\");\n\ti2c->use_push_pull =\n\t\tof_property_read_bool(np, \"mediatek,use-push-pull\");\n\n\ti2c_parse_fw_timings(i2c->dev, &i2c->timing_info, true);\n\n\treturn 0;\n}\n\nstatic int mtk_i2c_probe(struct platform_device *pdev)\n{\n\tint ret = 0;\n\tstruct mtk_i2c *i2c;\n\tint i, irq, speed_clk;\n\n\ti2c = devm_kzalloc(&pdev->dev, sizeof(*i2c), GFP_KERNEL);\n\tif (!i2c)\n\t\treturn -ENOMEM;\n\n\ti2c->base = devm_platform_get_and_ioremap_resource(pdev, 0, NULL);\n\tif (IS_ERR(i2c->base))\n\t\treturn PTR_ERR(i2c->base);\n\n\ti2c->pdmabase = devm_platform_get_and_ioremap_resource(pdev, 1, NULL);\n\tif (IS_ERR(i2c->pdmabase))\n\t\treturn PTR_ERR(i2c->pdmabase);\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tinit_completion(&i2c->msg_complete);\n\n\ti2c->dev_comp = of_device_get_match_data(&pdev->dev);\n\ti2c->adap.dev.of_node = pdev->dev.of_node;\n\ti2c->dev = &pdev->dev;\n\ti2c->adap.dev.parent = &pdev->dev;\n\ti2c->adap.owner = THIS_MODULE;\n\ti2c->adap.algo = &mtk_i2c_algorithm;\n\ti2c->adap.quirks = i2c->dev_comp->quirks;\n\ti2c->adap.timeout = 2 * HZ;\n\ti2c->adap.retries = 1;\n\ti2c->adap.bus_regulator = devm_regulator_get_optional(&pdev->dev, \"vbus\");\n\tif (IS_ERR(i2c->adap.bus_regulator)) {\n\t\tif (PTR_ERR(i2c->adap.bus_regulator) == -ENODEV)\n\t\t\ti2c->adap.bus_regulator = NULL;\n\t\telse\n\t\t\treturn PTR_ERR(i2c->adap.bus_regulator);\n\t}\n\n\tret = mtk_i2c_parse_dt(pdev->dev.of_node, i2c);\n\tif (ret)\n\t\treturn -EINVAL;\n\n\tif (i2c->have_pmic && !i2c->dev_comp->pmic_i2c)\n\t\treturn -EINVAL;\n\n\t \n\tfor (i = 0; i < I2C_MT65XX_CLK_MAX; i++)\n\t\ti2c->clocks[i].id = i2c_mt65xx_clk_ids[i];\n\n\t \n\ti2c->clocks[I2C_MT65XX_CLK_MAIN].clk = devm_clk_get(&pdev->dev, \"main\");\n\tif (IS_ERR(i2c->clocks[I2C_MT65XX_CLK_MAIN].clk)) {\n\t\tdev_err(&pdev->dev, \"cannot get main clock\\n\");\n\t\treturn PTR_ERR(i2c->clocks[I2C_MT65XX_CLK_MAIN].clk);\n\t}\n\n\ti2c->clocks[I2C_MT65XX_CLK_DMA].clk = devm_clk_get(&pdev->dev, \"dma\");\n\tif (IS_ERR(i2c->clocks[I2C_MT65XX_CLK_DMA].clk)) {\n\t\tdev_err(&pdev->dev, \"cannot get dma clock\\n\");\n\t\treturn PTR_ERR(i2c->clocks[I2C_MT65XX_CLK_DMA].clk);\n\t}\n\n\ti2c->clocks[I2C_MT65XX_CLK_ARB].clk = devm_clk_get_optional(&pdev->dev, \"arb\");\n\tif (IS_ERR(i2c->clocks[I2C_MT65XX_CLK_ARB].clk))\n\t\treturn PTR_ERR(i2c->clocks[I2C_MT65XX_CLK_ARB].clk);\n\n\tif (i2c->have_pmic) {\n\t\ti2c->clocks[I2C_MT65XX_CLK_PMIC].clk = devm_clk_get(&pdev->dev, \"pmic\");\n\t\tif (IS_ERR(i2c->clocks[I2C_MT65XX_CLK_PMIC].clk)) {\n\t\t\tdev_err(&pdev->dev, \"cannot get pmic clock\\n\");\n\t\t\treturn PTR_ERR(i2c->clocks[I2C_MT65XX_CLK_PMIC].clk);\n\t\t}\n\t\tspeed_clk = I2C_MT65XX_CLK_PMIC;\n\t} else {\n\t\ti2c->clocks[I2C_MT65XX_CLK_PMIC].clk = NULL;\n\t\tspeed_clk = I2C_MT65XX_CLK_MAIN;\n\t}\n\n\tstrscpy(i2c->adap.name, I2C_DRV_NAME, sizeof(i2c->adap.name));\n\n\tret = mtk_i2c_set_speed(i2c, clk_get_rate(i2c->clocks[speed_clk].clk));\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed to set the speed.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (i2c->dev_comp->max_dma_support > 32) {\n\t\tret = dma_set_mask(&pdev->dev,\n\t\t\t\tDMA_BIT_MASK(i2c->dev_comp->max_dma_support));\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev, \"dma_set_mask return error.\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = clk_bulk_prepare_enable(I2C_MT65XX_CLK_MAX, i2c->clocks);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"clock enable failed!\\n\");\n\t\treturn ret;\n\t}\n\tmtk_i2c_init_hw(i2c);\n\tclk_bulk_disable(I2C_MT65XX_CLK_MAX, i2c->clocks);\n\n\tret = devm_request_irq(&pdev->dev, irq, mtk_i2c_irq,\n\t\t\t       IRQF_NO_SUSPEND | IRQF_TRIGGER_NONE,\n\t\t\t       dev_name(&pdev->dev), i2c);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Request I2C IRQ %d fail\\n\", irq);\n\t\tgoto err_bulk_unprepare;\n\t}\n\n\ti2c_set_adapdata(&i2c->adap, i2c);\n\tret = i2c_add_adapter(&i2c->adap);\n\tif (ret)\n\t\tgoto err_bulk_unprepare;\n\n\tplatform_set_drvdata(pdev, i2c);\n\n\treturn 0;\n\nerr_bulk_unprepare:\n\tclk_bulk_unprepare(I2C_MT65XX_CLK_MAX, i2c->clocks);\n\n\treturn ret;\n}\n\nstatic void mtk_i2c_remove(struct platform_device *pdev)\n{\n\tstruct mtk_i2c *i2c = platform_get_drvdata(pdev);\n\n\ti2c_del_adapter(&i2c->adap);\n\n\tclk_bulk_unprepare(I2C_MT65XX_CLK_MAX, i2c->clocks);\n}\n\nstatic int mtk_i2c_suspend_noirq(struct device *dev)\n{\n\tstruct mtk_i2c *i2c = dev_get_drvdata(dev);\n\n\ti2c_mark_adapter_suspended(&i2c->adap);\n\tclk_bulk_unprepare(I2C_MT65XX_CLK_MAX, i2c->clocks);\n\n\treturn 0;\n}\n\nstatic int mtk_i2c_resume_noirq(struct device *dev)\n{\n\tint ret;\n\tstruct mtk_i2c *i2c = dev_get_drvdata(dev);\n\n\tret = clk_bulk_prepare_enable(I2C_MT65XX_CLK_MAX, i2c->clocks);\n\tif (ret) {\n\t\tdev_err(dev, \"clock enable failed!\\n\");\n\t\treturn ret;\n\t}\n\n\tmtk_i2c_init_hw(i2c);\n\n\tclk_bulk_disable(I2C_MT65XX_CLK_MAX, i2c->clocks);\n\n\ti2c_mark_adapter_resumed(&i2c->adap);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops mtk_i2c_pm = {\n\tNOIRQ_SYSTEM_SLEEP_PM_OPS(mtk_i2c_suspend_noirq,\n\t\t\t\t  mtk_i2c_resume_noirq)\n};\n\nstatic struct platform_driver mtk_i2c_driver = {\n\t.probe = mtk_i2c_probe,\n\t.remove_new = mtk_i2c_remove,\n\t.driver = {\n\t\t.name = I2C_DRV_NAME,\n\t\t.pm = pm_sleep_ptr(&mtk_i2c_pm),\n\t\t.of_match_table = mtk_i2c_of_match,\n\t},\n};\n\nmodule_platform_driver(mtk_i2c_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"MediaTek I2C Bus Driver\");\nMODULE_AUTHOR(\"Xudong Chen <xudong.chen@mediatek.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}