{
  "module_name": "i2c-nvidia-gpu.c",
  "hash_id": "7d0a00fe05729e2e8bb610ff569c07658e55ba4fa822683960f56c9ead5fa8a3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-nvidia-gpu.c",
  "human_readable_source": "\n \n#include <linux/delay.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/iopoll.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/platform_device.h>\n#include <linux/pm.h>\n#include <linux/pm_runtime.h>\n#include <linux/power_supply.h>\n\n#include <asm/unaligned.h>\n\n#include \"i2c-ccgx-ucsi.h\"\n\n \n#define I2C_MST_CNTL\t\t\t\t0x00\n#define I2C_MST_CNTL_GEN_START\t\t\tBIT(0)\n#define I2C_MST_CNTL_GEN_STOP\t\t\tBIT(1)\n#define I2C_MST_CNTL_CMD_READ\t\t\t(1 << 2)\n#define I2C_MST_CNTL_CMD_WRITE\t\t\t(2 << 2)\n#define I2C_MST_CNTL_BURST_SIZE_SHIFT\t\t6\n#define I2C_MST_CNTL_GEN_NACK\t\t\tBIT(28)\n#define I2C_MST_CNTL_STATUS\t\t\tGENMASK(30, 29)\n#define I2C_MST_CNTL_STATUS_OKAY\t\t(0 << 29)\n#define I2C_MST_CNTL_STATUS_NO_ACK\t\t(1 << 29)\n#define I2C_MST_CNTL_STATUS_TIMEOUT\t\t(2 << 29)\n#define I2C_MST_CNTL_STATUS_BUS_BUSY\t\t(3 << 29)\n#define I2C_MST_CNTL_CYCLE_TRIGGER\t\tBIT(31)\n\n#define I2C_MST_ADDR\t\t\t\t0x04\n\n#define I2C_MST_I2C0_TIMING\t\t\t\t0x08\n#define I2C_MST_I2C0_TIMING_SCL_PERIOD_100KHZ\t\t0x10e\n#define I2C_MST_I2C0_TIMING_TIMEOUT_CLK_CNT\t\t16\n#define I2C_MST_I2C0_TIMING_TIMEOUT_CLK_CNT_MAX\t\t255\n#define I2C_MST_I2C0_TIMING_TIMEOUT_CHECK\t\tBIT(24)\n\n#define I2C_MST_DATA\t\t\t\t\t0x0c\n\n#define I2C_MST_HYBRID_PADCTL\t\t\t\t0x20\n#define I2C_MST_HYBRID_PADCTL_MODE_I2C\t\t\tBIT(0)\n#define I2C_MST_HYBRID_PADCTL_I2C_SCL_INPUT_RCV\t\tBIT(14)\n#define I2C_MST_HYBRID_PADCTL_I2C_SDA_INPUT_RCV\t\tBIT(15)\n\nstruct gpu_i2c_dev {\n\tstruct device *dev;\n\tvoid __iomem *regs;\n\tstruct i2c_adapter adapter;\n\tstruct i2c_board_info *gpu_ccgx_ucsi;\n\tstruct i2c_client *ccgx_client;\n};\n\nstatic void gpu_enable_i2c_bus(struct gpu_i2c_dev *i2cd)\n{\n\tu32 val;\n\n\t \n\tval = readl(i2cd->regs + I2C_MST_HYBRID_PADCTL);\n\tval |= I2C_MST_HYBRID_PADCTL_MODE_I2C |\n\t\tI2C_MST_HYBRID_PADCTL_I2C_SCL_INPUT_RCV |\n\t\tI2C_MST_HYBRID_PADCTL_I2C_SDA_INPUT_RCV;\n\twritel(val, i2cd->regs + I2C_MST_HYBRID_PADCTL);\n\n\t \n\tval = I2C_MST_I2C0_TIMING_SCL_PERIOD_100KHZ;\n\tval |= (I2C_MST_I2C0_TIMING_TIMEOUT_CLK_CNT_MAX\n\t    << I2C_MST_I2C0_TIMING_TIMEOUT_CLK_CNT);\n\tval |= I2C_MST_I2C0_TIMING_TIMEOUT_CHECK;\n\twritel(val, i2cd->regs + I2C_MST_I2C0_TIMING);\n}\n\nstatic int gpu_i2c_check_status(struct gpu_i2c_dev *i2cd)\n{\n\tu32 val;\n\tint ret;\n\n\tret = readl_poll_timeout(i2cd->regs + I2C_MST_CNTL, val,\n\t\t\t\t !(val & I2C_MST_CNTL_CYCLE_TRIGGER) ||\n\t\t\t\t (val & I2C_MST_CNTL_STATUS) != I2C_MST_CNTL_STATUS_BUS_BUSY,\n\t\t\t\t 500, 1000 * USEC_PER_MSEC);\n\n\tif (ret) {\n\t\tdev_err(i2cd->dev, \"i2c timeout error %x\\n\", val);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tval = readl(i2cd->regs + I2C_MST_CNTL);\n\tswitch (val & I2C_MST_CNTL_STATUS) {\n\tcase I2C_MST_CNTL_STATUS_OKAY:\n\t\treturn 0;\n\tcase I2C_MST_CNTL_STATUS_NO_ACK:\n\t\treturn -ENXIO;\n\tcase I2C_MST_CNTL_STATUS_TIMEOUT:\n\t\treturn -ETIMEDOUT;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic int gpu_i2c_read(struct gpu_i2c_dev *i2cd, u8 *data, u16 len)\n{\n\tint status;\n\tu32 val;\n\n\tval = I2C_MST_CNTL_GEN_START | I2C_MST_CNTL_CMD_READ |\n\t\t(len << I2C_MST_CNTL_BURST_SIZE_SHIFT) |\n\t\tI2C_MST_CNTL_CYCLE_TRIGGER | I2C_MST_CNTL_GEN_NACK;\n\twritel(val, i2cd->regs + I2C_MST_CNTL);\n\n\tstatus = gpu_i2c_check_status(i2cd);\n\tif (status < 0)\n\t\treturn status;\n\n\tval = readl(i2cd->regs + I2C_MST_DATA);\n\tswitch (len) {\n\tcase 1:\n\t\tdata[0] = val;\n\t\tbreak;\n\tcase 2:\n\t\tput_unaligned_be16(val, data);\n\t\tbreak;\n\tcase 3:\n\t\tput_unaligned_be24(val, data);\n\t\tbreak;\n\tcase 4:\n\t\tput_unaligned_be32(val, data);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn status;\n}\n\nstatic int gpu_i2c_start(struct gpu_i2c_dev *i2cd)\n{\n\twritel(I2C_MST_CNTL_GEN_START, i2cd->regs + I2C_MST_CNTL);\n\treturn gpu_i2c_check_status(i2cd);\n}\n\nstatic int gpu_i2c_stop(struct gpu_i2c_dev *i2cd)\n{\n\twritel(I2C_MST_CNTL_GEN_STOP, i2cd->regs + I2C_MST_CNTL);\n\treturn gpu_i2c_check_status(i2cd);\n}\n\nstatic int gpu_i2c_write(struct gpu_i2c_dev *i2cd, u8 data)\n{\n\tu32 val;\n\n\twritel(data, i2cd->regs + I2C_MST_DATA);\n\n\tval = I2C_MST_CNTL_CMD_WRITE | (1 << I2C_MST_CNTL_BURST_SIZE_SHIFT);\n\twritel(val, i2cd->regs + I2C_MST_CNTL);\n\n\treturn gpu_i2c_check_status(i2cd);\n}\n\nstatic int gpu_i2c_master_xfer(struct i2c_adapter *adap,\n\t\t\t       struct i2c_msg *msgs, int num)\n{\n\tstruct gpu_i2c_dev *i2cd = i2c_get_adapdata(adap);\n\tint status, status2;\n\tbool send_stop = true;\n\tint i, j;\n\n\t \n\tpm_runtime_get_sync(i2cd->dev);\n\tfor (i = 0; i < num; i++) {\n\t\tif (msgs[i].flags & I2C_M_RD) {\n\t\t\t \n\t\t\twritel(msgs[i].addr, i2cd->regs + I2C_MST_ADDR);\n\t\t\t \n\t\t\tstatus = gpu_i2c_read(i2cd, msgs[i].buf, msgs[i].len);\n\t\t\tif (status < 0)\n\t\t\t\tgoto exit;\n\t\t} else {\n\t\t\tu8 addr = i2c_8bit_addr_from_msg(msgs + i);\n\n\t\t\tstatus = gpu_i2c_start(i2cd);\n\t\t\tif (status < 0) {\n\t\t\t\tif (i == 0)\n\t\t\t\t\tsend_stop = false;\n\t\t\t\tgoto exit;\n\t\t\t}\n\n\t\t\tstatus = gpu_i2c_write(i2cd, addr);\n\t\t\tif (status < 0)\n\t\t\t\tgoto exit;\n\n\t\t\tfor (j = 0; j < msgs[i].len; j++) {\n\t\t\t\tstatus = gpu_i2c_write(i2cd, msgs[i].buf[j]);\n\t\t\t\tif (status < 0)\n\t\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\t}\n\tsend_stop = false;\n\tstatus = gpu_i2c_stop(i2cd);\n\tif (status < 0)\n\t\tgoto exit;\n\n\tstatus = i;\nexit:\n\tif (send_stop) {\n\t\tstatus2 = gpu_i2c_stop(i2cd);\n\t\tif (status2 < 0)\n\t\t\tdev_err(i2cd->dev, \"i2c stop failed %d\\n\", status2);\n\t}\n\tpm_runtime_mark_last_busy(i2cd->dev);\n\tpm_runtime_put_autosuspend(i2cd->dev);\n\treturn status;\n}\n\nstatic const struct i2c_adapter_quirks gpu_i2c_quirks = {\n\t.max_read_len = 4,\n\t.max_comb_2nd_msg_len = 4,\n\t.flags = I2C_AQ_COMB_WRITE_THEN_READ,\n};\n\nstatic u32 gpu_i2c_functionality(struct i2c_adapter *adap)\n{\n\treturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;\n}\n\nstatic const struct i2c_algorithm gpu_i2c_algorithm = {\n\t.master_xfer\t= gpu_i2c_master_xfer,\n\t.functionality\t= gpu_i2c_functionality,\n};\n\n \n#define PCI_CLASS_SERIAL_UNKNOWN\t0x0c80\nstatic const struct pci_device_id gpu_i2c_ids[] = {\n\t{ PCI_VENDOR_ID_NVIDIA, PCI_ANY_ID, PCI_ANY_ID, PCI_ANY_ID,\n\t\tPCI_CLASS_SERIAL_UNKNOWN << 8, 0xffffff00},\n\t{ }\n};\nMODULE_DEVICE_TABLE(pci, gpu_i2c_ids);\n\nstatic const struct property_entry ccgx_props[] = {\n\t \n\tPROPERTY_ENTRY_STRING(\"firmware-name\", \"nvidia,gpu\"),\n\t \n\tPROPERTY_ENTRY_U8(\"scope\", POWER_SUPPLY_SCOPE_DEVICE),\n\t{ }\n};\n\nstatic const struct software_node ccgx_node = {\n\t.properties = ccgx_props,\n};\n\nstatic int gpu_i2c_probe(struct pci_dev *pdev, const struct pci_device_id *id)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct gpu_i2c_dev *i2cd;\n\tint status;\n\n\ti2cd = devm_kzalloc(dev, sizeof(*i2cd), GFP_KERNEL);\n\tif (!i2cd)\n\t\treturn -ENOMEM;\n\n\ti2cd->dev = dev;\n\tdev_set_drvdata(dev, i2cd);\n\n\tstatus = pcim_enable_device(pdev);\n\tif (status < 0)\n\t\treturn dev_err_probe(dev, status, \"pcim_enable_device failed\\n\");\n\n\tpci_set_master(pdev);\n\n\ti2cd->regs = pcim_iomap(pdev, 0, 0);\n\tif (!i2cd->regs)\n\t\treturn dev_err_probe(dev, -ENOMEM, \"pcim_iomap failed\\n\");\n\n\tstatus = pci_alloc_irq_vectors(pdev, 1, 1, PCI_IRQ_MSI);\n\tif (status < 0)\n\t\treturn dev_err_probe(dev, status, \"pci_alloc_irq_vectors err\\n\");\n\n\tgpu_enable_i2c_bus(i2cd);\n\n\ti2c_set_adapdata(&i2cd->adapter, i2cd);\n\ti2cd->adapter.owner = THIS_MODULE;\n\tstrscpy(i2cd->adapter.name, \"NVIDIA GPU I2C adapter\",\n\t\tsizeof(i2cd->adapter.name));\n\ti2cd->adapter.algo = &gpu_i2c_algorithm;\n\ti2cd->adapter.quirks = &gpu_i2c_quirks;\n\ti2cd->adapter.dev.parent = dev;\n\tstatus = i2c_add_adapter(&i2cd->adapter);\n\tif (status < 0)\n\t\tgoto free_irq_vectors;\n\n\ti2cd->ccgx_client = i2c_new_ccgx_ucsi(&i2cd->adapter, pdev->irq, &ccgx_node);\n\tif (IS_ERR(i2cd->ccgx_client)) {\n\t\tstatus = dev_err_probe(dev, PTR_ERR(i2cd->ccgx_client), \"register UCSI failed\\n\");\n\t\tgoto del_adapter;\n\t}\n\n\tpm_runtime_set_autosuspend_delay(dev, 3000);\n\tpm_runtime_use_autosuspend(dev);\n\tpm_runtime_put_autosuspend(dev);\n\tpm_runtime_allow(dev);\n\n\treturn 0;\n\ndel_adapter:\n\ti2c_del_adapter(&i2cd->adapter);\nfree_irq_vectors:\n\tpci_free_irq_vectors(pdev);\n\treturn status;\n}\n\nstatic void gpu_i2c_remove(struct pci_dev *pdev)\n{\n\tstruct gpu_i2c_dev *i2cd = pci_get_drvdata(pdev);\n\n\tpm_runtime_get_noresume(i2cd->dev);\n\ti2c_del_adapter(&i2cd->adapter);\n\tpci_free_irq_vectors(pdev);\n}\n\n#define gpu_i2c_suspend NULL\n\nstatic __maybe_unused int gpu_i2c_resume(struct device *dev)\n{\n\tstruct gpu_i2c_dev *i2cd = dev_get_drvdata(dev);\n\n\tgpu_enable_i2c_bus(i2cd);\n\t \n\tpm_request_resume(&i2cd->ccgx_client->dev);\n\treturn 0;\n}\n\nstatic UNIVERSAL_DEV_PM_OPS(gpu_i2c_driver_pm, gpu_i2c_suspend, gpu_i2c_resume,\n\t\t\t    NULL);\n\nstatic struct pci_driver gpu_i2c_driver = {\n\t.name\t\t= \"nvidia-gpu\",\n\t.id_table\t= gpu_i2c_ids,\n\t.probe\t\t= gpu_i2c_probe,\n\t.remove\t\t= gpu_i2c_remove,\n\t.driver\t\t= {\n\t\t.pm\t= &gpu_i2c_driver_pm,\n\t},\n};\n\nmodule_pci_driver(gpu_i2c_driver);\n\nMODULE_AUTHOR(\"Ajay Gupta <ajayg@nvidia.com>\");\nMODULE_DESCRIPTION(\"Nvidia GPU I2C controller Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}