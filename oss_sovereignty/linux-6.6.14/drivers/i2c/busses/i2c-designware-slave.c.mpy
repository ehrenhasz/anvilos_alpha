{
  "module_name": "i2c-designware-slave.c",
  "hash_id": "781694c5d9616b3d9b1173a25aedd5f37da59e6eb18f9a564a1b49106059fb87",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-designware-slave.c",
  "human_readable_source": "\n \n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n\n#include \"i2c-designware-core.h\"\n\nstatic void i2c_dw_configure_fifo_slave(struct dw_i2c_dev *dev)\n{\n\t \n\tregmap_write(dev->map, DW_IC_TX_TL, 0);\n\tregmap_write(dev->map, DW_IC_RX_TL, 0);\n\n\t \n\tregmap_write(dev->map, DW_IC_CON, dev->slave_cfg);\n\tregmap_write(dev->map, DW_IC_INTR_MASK, DW_IC_INTR_SLAVE_MASK);\n}\n\n \nstatic int i2c_dw_init_slave(struct dw_i2c_dev *dev)\n{\n\tint ret;\n\n\tret = i2c_dw_acquire_lock(dev);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\t__i2c_dw_disable(dev);\n\n\t \n\tif (dev->sda_hold_time)\n\t\tregmap_write(dev->map, DW_IC_SDA_HOLD, dev->sda_hold_time);\n\n\ti2c_dw_configure_fifo_slave(dev);\n\ti2c_dw_release_lock(dev);\n\n\treturn 0;\n}\n\nstatic int i2c_dw_reg_slave(struct i2c_client *slave)\n{\n\tstruct dw_i2c_dev *dev = i2c_get_adapdata(slave->adapter);\n\n\tif (dev->slave)\n\t\treturn -EBUSY;\n\tif (slave->flags & I2C_CLIENT_TEN)\n\t\treturn -EAFNOSUPPORT;\n\tpm_runtime_get_sync(dev->dev);\n\n\t \n\t__i2c_dw_disable_nowait(dev);\n\tregmap_write(dev->map, DW_IC_SAR, slave->addr);\n\tdev->slave = slave;\n\n\t__i2c_dw_enable(dev);\n\n\tdev->status = 0;\n\n\treturn 0;\n}\n\nstatic int i2c_dw_unreg_slave(struct i2c_client *slave)\n{\n\tstruct dw_i2c_dev *dev = i2c_get_adapdata(slave->adapter);\n\n\tregmap_write(dev->map, DW_IC_INTR_MASK, 0);\n\tdev->disable(dev);\n\tsynchronize_irq(dev->irq);\n\tdev->slave = NULL;\n\tpm_runtime_put(dev->dev);\n\n\treturn 0;\n}\n\nstatic u32 i2c_dw_read_clear_intrbits_slave(struct dw_i2c_dev *dev)\n{\n\tunsigned int stat, dummy;\n\n\t \n\tregmap_read(dev->map, DW_IC_INTR_STAT, &stat);\n\n\t \n\tif (stat & DW_IC_INTR_TX_ABRT)\n\t\tregmap_read(dev->map, DW_IC_CLR_TX_ABRT, &dummy);\n\tif (stat & DW_IC_INTR_RX_UNDER)\n\t\tregmap_read(dev->map, DW_IC_CLR_RX_UNDER, &dummy);\n\tif (stat & DW_IC_INTR_RX_OVER)\n\t\tregmap_read(dev->map, DW_IC_CLR_RX_OVER, &dummy);\n\tif (stat & DW_IC_INTR_TX_OVER)\n\t\tregmap_read(dev->map, DW_IC_CLR_TX_OVER, &dummy);\n\tif (stat & DW_IC_INTR_RX_DONE)\n\t\tregmap_read(dev->map, DW_IC_CLR_RX_DONE, &dummy);\n\tif (stat & DW_IC_INTR_ACTIVITY)\n\t\tregmap_read(dev->map, DW_IC_CLR_ACTIVITY, &dummy);\n\tif (stat & DW_IC_INTR_STOP_DET)\n\t\tregmap_read(dev->map, DW_IC_CLR_STOP_DET, &dummy);\n\tif (stat & DW_IC_INTR_START_DET)\n\t\tregmap_read(dev->map, DW_IC_CLR_START_DET, &dummy);\n\tif (stat & DW_IC_INTR_GEN_CALL)\n\t\tregmap_read(dev->map, DW_IC_CLR_GEN_CALL, &dummy);\n\n\treturn stat;\n}\n\n \nstatic irqreturn_t i2c_dw_isr_slave(int this_irq, void *dev_id)\n{\n\tstruct dw_i2c_dev *dev = dev_id;\n\tunsigned int raw_stat, stat, enabled, tmp;\n\tu8 val = 0, slave_activity;\n\n\tregmap_read(dev->map, DW_IC_ENABLE, &enabled);\n\tregmap_read(dev->map, DW_IC_RAW_INTR_STAT, &raw_stat);\n\tregmap_read(dev->map, DW_IC_STATUS, &tmp);\n\tslave_activity = ((tmp & DW_IC_STATUS_SLAVE_ACTIVITY) >> 6);\n\n\tif (!enabled || !(raw_stat & ~DW_IC_INTR_ACTIVITY) || !dev->slave)\n\t\treturn IRQ_NONE;\n\n\tstat = i2c_dw_read_clear_intrbits_slave(dev);\n\tdev_dbg(dev->dev,\n\t\t\"%#x STATUS SLAVE_ACTIVITY=%#x : RAW_INTR_STAT=%#x : INTR_STAT=%#x\\n\",\n\t\tenabled, slave_activity, raw_stat, stat);\n\n\tif (stat & DW_IC_INTR_RX_FULL) {\n\t\tif (!(dev->status & STATUS_WRITE_IN_PROGRESS)) {\n\t\t\tdev->status |= STATUS_WRITE_IN_PROGRESS;\n\t\t\tdev->status &= ~STATUS_READ_IN_PROGRESS;\n\t\t\ti2c_slave_event(dev->slave, I2C_SLAVE_WRITE_REQUESTED,\n\t\t\t\t\t&val);\n\t\t}\n\n\t\tdo {\n\t\t\tregmap_read(dev->map, DW_IC_DATA_CMD, &tmp);\n\t\t\tif (tmp & DW_IC_DATA_CMD_FIRST_DATA_BYTE)\n\t\t\t\ti2c_slave_event(dev->slave,\n\t\t\t\t\t\tI2C_SLAVE_WRITE_REQUESTED,\n\t\t\t\t\t\t&val);\n\t\t\tval = tmp;\n\t\t\ti2c_slave_event(dev->slave, I2C_SLAVE_WRITE_RECEIVED,\n\t\t\t\t\t&val);\n\t\t\tregmap_read(dev->map, DW_IC_STATUS, &tmp);\n\t\t} while (tmp & DW_IC_STATUS_RFNE);\n\t}\n\n\tif (stat & DW_IC_INTR_RD_REQ) {\n\t\tif (slave_activity) {\n\t\t\tregmap_read(dev->map, DW_IC_CLR_RD_REQ, &tmp);\n\n\t\t\tif (!(dev->status & STATUS_READ_IN_PROGRESS)) {\n\t\t\t\ti2c_slave_event(dev->slave,\n\t\t\t\t\t\tI2C_SLAVE_READ_REQUESTED,\n\t\t\t\t\t\t&val);\n\t\t\t\tdev->status |= STATUS_READ_IN_PROGRESS;\n\t\t\t\tdev->status &= ~STATUS_WRITE_IN_PROGRESS;\n\t\t\t} else {\n\t\t\t\ti2c_slave_event(dev->slave,\n\t\t\t\t\t\tI2C_SLAVE_READ_PROCESSED,\n\t\t\t\t\t\t&val);\n\t\t\t}\n\t\t\tregmap_write(dev->map, DW_IC_DATA_CMD, val);\n\t\t}\n\t}\n\n\tif (stat & DW_IC_INTR_STOP_DET)\n\t\ti2c_slave_event(dev->slave, I2C_SLAVE_STOP, &val);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic const struct i2c_algorithm i2c_dw_algo = {\n\t.functionality = i2c_dw_func,\n\t.reg_slave = i2c_dw_reg_slave,\n\t.unreg_slave = i2c_dw_unreg_slave,\n};\n\nvoid i2c_dw_configure_slave(struct dw_i2c_dev *dev)\n{\n\tdev->functionality = I2C_FUNC_SLAVE | DW_IC_DEFAULT_FUNCTIONALITY;\n\n\tdev->slave_cfg = DW_IC_CON_RX_FIFO_FULL_HLD_CTRL |\n\t\t\t DW_IC_CON_RESTART_EN | DW_IC_CON_STOP_DET_IFADDRESSED;\n\n\tdev->mode = DW_IC_SLAVE;\n}\nEXPORT_SYMBOL_GPL(i2c_dw_configure_slave);\n\nint i2c_dw_probe_slave(struct dw_i2c_dev *dev)\n{\n\tstruct i2c_adapter *adap = &dev->adapter;\n\tint ret;\n\n\tdev->init = i2c_dw_init_slave;\n\tdev->disable = i2c_dw_disable;\n\n\tret = i2c_dw_init_regmap(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = i2c_dw_set_sda_hold(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = i2c_dw_set_fifo_size(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = dev->init(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tsnprintf(adap->name, sizeof(adap->name),\n\t\t \"Synopsys DesignWare I2C Slave adapter\");\n\tadap->retries = 3;\n\tadap->algo = &i2c_dw_algo;\n\tadap->dev.parent = dev->dev;\n\ti2c_set_adapdata(adap, dev);\n\n\tret = devm_request_irq(dev->dev, dev->irq, i2c_dw_isr_slave,\n\t\t\t       IRQF_SHARED, dev_name(dev->dev), dev);\n\tif (ret) {\n\t\tdev_err(dev->dev, \"failure requesting irq %i: %d\\n\",\n\t\t\tdev->irq, ret);\n\t\treturn ret;\n\t}\n\n\tret = i2c_add_numbered_adapter(adap);\n\tif (ret)\n\t\tdev_err(dev->dev, \"failure adding adapter: %d\\n\", ret);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(i2c_dw_probe_slave);\n\nMODULE_AUTHOR(\"Luis Oliveira <lolivei@synopsys.com>\");\nMODULE_DESCRIPTION(\"Synopsys DesignWare I2C bus slave adapter\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}