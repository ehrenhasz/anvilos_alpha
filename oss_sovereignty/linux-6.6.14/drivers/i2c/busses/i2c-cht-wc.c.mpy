{
  "module_name": "i2c-cht-wc.c",
  "hash_id": "06869074351f4c080420790a65db958a35d6f96c9289125acb307454d2737fd0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-cht-wc.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/mfd/intel_soc_pmic.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/power/bq24190_charger.h>\n#include <linux/power/bq25890_charger.h>\n#include <linux/slab.h>\n\n#define CHT_WC_I2C_CTRL\t\t\t0x5e24\n#define CHT_WC_I2C_CTRL_WR\t\tBIT(0)\n#define CHT_WC_I2C_CTRL_RD\t\tBIT(1)\n#define CHT_WC_I2C_CLIENT_ADDR\t\t0x5e25\n#define CHT_WC_I2C_REG_OFFSET\t\t0x5e26\n#define CHT_WC_I2C_WRDATA\t\t0x5e27\n#define CHT_WC_I2C_RDDATA\t\t0x5e28\n\n#define CHT_WC_EXTCHGRIRQ\t\t0x6e0a\n#define CHT_WC_EXTCHGRIRQ_CLIENT_IRQ\tBIT(0)\n#define CHT_WC_EXTCHGRIRQ_WRITE_IRQ\tBIT(1)\n#define CHT_WC_EXTCHGRIRQ_READ_IRQ\tBIT(2)\n#define CHT_WC_EXTCHGRIRQ_NACK_IRQ\tBIT(3)\n#define CHT_WC_EXTCHGRIRQ_ADAP_IRQMASK\t((u8)GENMASK(3, 1))\n#define CHT_WC_EXTCHGRIRQ_MSK\t\t0x6e17\n\nstruct cht_wc_i2c_adap {\n\tstruct i2c_adapter adapter;\n\twait_queue_head_t wait;\n\tstruct irq_chip irqchip;\n\tstruct mutex adap_lock;\n\tstruct mutex irqchip_lock;\n\tstruct regmap *regmap;\n\tstruct irq_domain *irq_domain;\n\tstruct i2c_client *client;\n\tint client_irq;\n\tu8 irq_mask;\n\tu8 old_irq_mask;\n\tint read_data;\n\tbool io_error;\n\tbool done;\n};\n\nstatic irqreturn_t cht_wc_i2c_adap_thread_handler(int id, void *data)\n{\n\tstruct cht_wc_i2c_adap *adap = data;\n\tint ret, reg;\n\n\tmutex_lock(&adap->adap_lock);\n\n\t \n\tret = regmap_read(adap->regmap, CHT_WC_EXTCHGRIRQ, &reg);\n\tif (ret) {\n\t\tdev_err(&adap->adapter.dev, \"Error reading extchgrirq reg\\n\");\n\t\tmutex_unlock(&adap->adap_lock);\n\t\treturn IRQ_NONE;\n\t}\n\n\treg &= ~adap->irq_mask;\n\n\t \n\tret = regmap_read(adap->regmap, CHT_WC_I2C_RDDATA, &adap->read_data);\n\tif (ret)\n\t\tadap->io_error = true;\n\n\t \n\tret = regmap_write(adap->regmap, CHT_WC_EXTCHGRIRQ, reg);\n\tif (ret)\n\t\tdev_err(&adap->adapter.dev, \"Error writing extchgrirq reg\\n\");\n\n\tif (reg & CHT_WC_EXTCHGRIRQ_ADAP_IRQMASK) {\n\t\tadap->io_error |= !!(reg & CHT_WC_EXTCHGRIRQ_NACK_IRQ);\n\t\tadap->done = true;\n\t}\n\n\tmutex_unlock(&adap->adap_lock);\n\n\tif (reg & CHT_WC_EXTCHGRIRQ_ADAP_IRQMASK)\n\t\twake_up(&adap->wait);\n\n\t \n\tif (reg & CHT_WC_EXTCHGRIRQ_CLIENT_IRQ)\n\t\tgeneric_handle_irq_safe(adap->client_irq);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic u32 cht_wc_i2c_adap_master_func(struct i2c_adapter *adap)\n{\n\t \n\treturn I2C_FUNC_SMBUS_BYTE_DATA;\n}\n\nstatic int cht_wc_i2c_adap_smbus_xfer(struct i2c_adapter *_adap, u16 addr,\n\t\t\t\t      unsigned short flags, char read_write,\n\t\t\t\t      u8 command, int size,\n\t\t\t\t      union i2c_smbus_data *data)\n{\n\tstruct cht_wc_i2c_adap *adap = i2c_get_adapdata(_adap);\n\tint ret;\n\n\tmutex_lock(&adap->adap_lock);\n\tadap->io_error = false;\n\tadap->done = false;\n\tmutex_unlock(&adap->adap_lock);\n\n\tret = regmap_write(adap->regmap, CHT_WC_I2C_CLIENT_ADDR, addr);\n\tif (ret)\n\t\treturn ret;\n\n\tif (read_write == I2C_SMBUS_WRITE) {\n\t\tret = regmap_write(adap->regmap, CHT_WC_I2C_WRDATA, data->byte);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = regmap_write(adap->regmap, CHT_WC_I2C_REG_OFFSET, command);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_write(adap->regmap, CHT_WC_I2C_CTRL,\n\t\t\t   (read_write == I2C_SMBUS_WRITE) ?\n\t\t\t   CHT_WC_I2C_CTRL_WR : CHT_WC_I2C_CTRL_RD);\n\tif (ret)\n\t\treturn ret;\n\n\tret = wait_event_timeout(adap->wait, adap->done, msecs_to_jiffies(30));\n\tif (ret == 0) {\n\t\t \n\t\tcht_wc_i2c_adap_thread_handler(0, adap);\n\t\tif (!adap->done)\n\t\t\treturn -ETIMEDOUT;\n\t}\n\n\tret = 0;\n\tmutex_lock(&adap->adap_lock);\n\tif (adap->io_error)\n\t\tret = -EIO;\n\telse if (read_write == I2C_SMBUS_READ)\n\t\tdata->byte = adap->read_data;\n\tmutex_unlock(&adap->adap_lock);\n\n\treturn ret;\n}\n\nstatic const struct i2c_algorithm cht_wc_i2c_adap_algo = {\n\t.functionality = cht_wc_i2c_adap_master_func,\n\t.smbus_xfer = cht_wc_i2c_adap_smbus_xfer,\n};\n\n \nstatic void cht_wc_i2c_adap_lock_bus(struct i2c_adapter *adapter,\n\t\t\t\t unsigned int flags)\n{\n\trt_mutex_lock_nested(&adapter->bus_lock, 1);\n}\n\nstatic int cht_wc_i2c_adap_trylock_bus(struct i2c_adapter *adapter,\n\t\t\t\t   unsigned int flags)\n{\n\treturn rt_mutex_trylock(&adapter->bus_lock);\n}\n\nstatic void cht_wc_i2c_adap_unlock_bus(struct i2c_adapter *adapter,\n\t\t\t\t   unsigned int flags)\n{\n\trt_mutex_unlock(&adapter->bus_lock);\n}\n\nstatic const struct i2c_lock_operations cht_wc_i2c_adap_lock_ops = {\n\t.lock_bus =    cht_wc_i2c_adap_lock_bus,\n\t.trylock_bus = cht_wc_i2c_adap_trylock_bus,\n\t.unlock_bus =  cht_wc_i2c_adap_unlock_bus,\n};\n\n \nstatic void cht_wc_i2c_irq_lock(struct irq_data *data)\n{\n\tstruct cht_wc_i2c_adap *adap = irq_data_get_irq_chip_data(data);\n\n\tmutex_lock(&adap->irqchip_lock);\n}\n\nstatic void cht_wc_i2c_irq_sync_unlock(struct irq_data *data)\n{\n\tstruct cht_wc_i2c_adap *adap = irq_data_get_irq_chip_data(data);\n\tint ret;\n\n\tif (adap->irq_mask != adap->old_irq_mask) {\n\t\tret = regmap_write(adap->regmap, CHT_WC_EXTCHGRIRQ_MSK,\n\t\t\t\t   adap->irq_mask);\n\t\tif (ret == 0)\n\t\t\tadap->old_irq_mask = adap->irq_mask;\n\t\telse\n\t\t\tdev_err(&adap->adapter.dev, \"Error writing EXTCHGRIRQ_MSK\\n\");\n\t}\n\n\tmutex_unlock(&adap->irqchip_lock);\n}\n\nstatic void cht_wc_i2c_irq_enable(struct irq_data *data)\n{\n\tstruct cht_wc_i2c_adap *adap = irq_data_get_irq_chip_data(data);\n\n\tadap->irq_mask &= ~CHT_WC_EXTCHGRIRQ_CLIENT_IRQ;\n}\n\nstatic void cht_wc_i2c_irq_disable(struct irq_data *data)\n{\n\tstruct cht_wc_i2c_adap *adap = irq_data_get_irq_chip_data(data);\n\n\tadap->irq_mask |= CHT_WC_EXTCHGRIRQ_CLIENT_IRQ;\n}\n\nstatic const struct irq_chip cht_wc_i2c_irq_chip = {\n\t.irq_bus_lock\t\t= cht_wc_i2c_irq_lock,\n\t.irq_bus_sync_unlock\t= cht_wc_i2c_irq_sync_unlock,\n\t.irq_disable\t\t= cht_wc_i2c_irq_disable,\n\t.irq_enable\t\t= cht_wc_i2c_irq_enable,\n\t.name\t\t\t= \"cht_wc_ext_chrg_irq_chip\",\n};\n\n \nstatic const char * const bq24190_suppliers[] = {\n\t\"tcpm-source-psy-i2c-fusb302\" };\n\nstatic const struct property_entry bq24190_props[] = {\n\tPROPERTY_ENTRY_STRING_ARRAY(\"supplied-from\", bq24190_suppliers),\n\tPROPERTY_ENTRY_BOOL(\"omit-battery-class\"),\n\tPROPERTY_ENTRY_BOOL(\"disable-reset\"),\n\t{ }\n};\n\nstatic const struct software_node bq24190_node = {\n\t.properties = bq24190_props,\n};\n\nstatic struct regulator_consumer_supply fusb302_consumer = {\n\t.supply = \"vbus\",\n\t \n\t.dev_name = \"i2c-fusb302\",\n};\n\nstatic const struct regulator_init_data bq24190_vbus_init_data = {\n\t.constraints = {\n\t\t \n\t\t.name = \"cht_wc_usb_typec_vbus\",\n\t\t.valid_ops_mask = REGULATOR_CHANGE_STATUS,\n\t},\n\t.consumer_supplies = &fusb302_consumer,\n\t.num_consumer_supplies = 1,\n};\n\nstatic struct bq24190_platform_data bq24190_pdata = {\n\t.regulator_init_data = &bq24190_vbus_init_data,\n};\n\nstatic struct i2c_board_info gpd_win_board_info = {\n\t.type = \"bq24190\",\n\t.addr = 0x6b,\n\t.dev_name = \"bq24190\",\n\t.swnode = &bq24190_node,\n\t.platform_data = &bq24190_pdata,\n};\n\n \nstatic struct regulator_consumer_supply bq2589x_vbus_consumer = {\n\t.supply = \"vbus\",\n\t.dev_name = \"cht_wcove_pwrsrc\",\n};\n\nstatic const struct regulator_init_data bq2589x_vbus_init_data = {\n\t.constraints = {\n\t\t.valid_ops_mask = REGULATOR_CHANGE_STATUS,\n\t},\n\t.consumer_supplies = &bq2589x_vbus_consumer,\n\t.num_consumer_supplies = 1,\n};\n\nstatic struct bq25890_platform_data bq2589x_pdata = {\n\t.regulator_init_data = &bq2589x_vbus_init_data,\n};\n\nstatic const struct property_entry xiaomi_mipad2_props[] = {\n\tPROPERTY_ENTRY_BOOL(\"linux,skip-reset\"),\n\tPROPERTY_ENTRY_BOOL(\"linux,read-back-settings\"),\n\t{ }\n};\n\nstatic const struct software_node xiaomi_mipad2_node = {\n\t.properties = xiaomi_mipad2_props,\n};\n\nstatic struct i2c_board_info xiaomi_mipad2_board_info = {\n\t.type = \"bq25890\",\n\t.addr = 0x6a,\n\t.dev_name = \"bq25890\",\n\t.swnode = &xiaomi_mipad2_node,\n\t.platform_data = &bq2589x_pdata,\n};\n\n \nstatic const char * const lenovo_yb1_bq25892_suppliers[] = { \"cht_wcove_pwrsrc\" };\n\nstatic const struct property_entry lenovo_yb1_bq25892_props[] = {\n\tPROPERTY_ENTRY_STRING_ARRAY(\"supplied-from\",\n\t\t\t\t    lenovo_yb1_bq25892_suppliers),\n\tPROPERTY_ENTRY_U32(\"linux,pump-express-vbus-max\", 12000000),\n\tPROPERTY_ENTRY_BOOL(\"linux,skip-reset\"),\n\t \n\tPROPERTY_ENTRY_U32(\"ti,charge-current\", 4224000),\n\tPROPERTY_ENTRY_U32(\"ti,battery-regulation-voltage\", 4352000),\n\tPROPERTY_ENTRY_U32(\"ti,termination-current\", 256000),\n\tPROPERTY_ENTRY_U32(\"ti,precharge-current\", 128000),\n\tPROPERTY_ENTRY_U32(\"ti,minimum-sys-voltage\", 3500000),\n\tPROPERTY_ENTRY_U32(\"ti,boost-voltage\", 4998000),\n\tPROPERTY_ENTRY_U32(\"ti,boost-max-current\", 1400000),\n\tPROPERTY_ENTRY_BOOL(\"ti,use-ilim-pin\"),\n\t{ }\n};\n\nstatic const struct software_node lenovo_yb1_bq25892_node = {\n\t.properties = lenovo_yb1_bq25892_props,\n};\n\nstatic struct i2c_board_info lenovo_yogabook1_board_info = {\n\t.type = \"bq25892\",\n\t.addr = 0x6b,\n\t.dev_name = \"bq25892\",\n\t.swnode = &lenovo_yb1_bq25892_node,\n\t.platform_data = &bq2589x_pdata,\n};\n\n \nstatic const char * const lenovo_yt3_bq25892_1_suppliers[] = { \"cht_wcove_pwrsrc\" };\n\n \nstatic const struct property_entry lenovo_yt3_bq25892_1_props[] = {\n\tPROPERTY_ENTRY_STRING_ARRAY(\"supplied-from\", lenovo_yt3_bq25892_1_suppliers),\n\tPROPERTY_ENTRY_STRING(\"linux,secondary-charger-name\", \"bq25890-charger-0\"),\n\tPROPERTY_ENTRY_U32(\"linux,iinlim-percentage\", 60),\n\tPROPERTY_ENTRY_U32(\"linux,pump-express-vbus-max\", 12000000),\n\tPROPERTY_ENTRY_BOOL(\"linux,skip-reset\"),\n\t \n\tPROPERTY_ENTRY_U32(\"ti,charge-current\", 3072000),\n\tPROPERTY_ENTRY_U32(\"ti,battery-regulation-voltage\", 4352000),\n\tPROPERTY_ENTRY_U32(\"ti,termination-current\", 128000),\n\tPROPERTY_ENTRY_U32(\"ti,precharge-current\", 128000),\n\tPROPERTY_ENTRY_U32(\"ti,minimum-sys-voltage\", 3700000),\n\tPROPERTY_ENTRY_BOOL(\"ti,use-ilim-pin\"),\n\t \n\tPROPERTY_ENTRY_U32(\"ti,boost-voltage\", 4998000),\n\tPROPERTY_ENTRY_U32(\"ti,boost-max-current\", 1200000),\n\t{ }\n};\n\nstatic const struct software_node lenovo_yt3_bq25892_1_node = {\n\t.properties = lenovo_yt3_bq25892_1_props,\n};\n\n \nstatic struct i2c_board_info lenovo_yoga_tab3_board_info = {\n\t.type = \"bq25892\",\n\t.addr = 0x6b,\n\t.dev_name = \"bq25892_1\",\n\t.swnode = &lenovo_yt3_bq25892_1_node,\n\t.platform_data = &bq2589x_pdata,\n};\n\nstatic int cht_wc_i2c_adap_i2c_probe(struct platform_device *pdev)\n{\n\tstruct intel_soc_pmic *pmic = dev_get_drvdata(pdev->dev.parent);\n\tstruct i2c_board_info *board_info = NULL;\n\tstruct cht_wc_i2c_adap *adap;\n\tint ret, reg, irq;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tadap = devm_kzalloc(&pdev->dev, sizeof(*adap), GFP_KERNEL);\n\tif (!adap)\n\t\treturn -ENOMEM;\n\n\tinit_waitqueue_head(&adap->wait);\n\tmutex_init(&adap->adap_lock);\n\tmutex_init(&adap->irqchip_lock);\n\tadap->irqchip = cht_wc_i2c_irq_chip;\n\tadap->regmap = pmic->regmap;\n\tadap->adapter.owner = THIS_MODULE;\n\tadap->adapter.class = I2C_CLASS_HWMON;\n\tadap->adapter.algo = &cht_wc_i2c_adap_algo;\n\tadap->adapter.lock_ops = &cht_wc_i2c_adap_lock_ops;\n\tstrscpy(adap->adapter.name, \"PMIC I2C Adapter\",\n\t\tsizeof(adap->adapter.name));\n\tadap->adapter.dev.parent = &pdev->dev;\n\n\t \n\tadap->old_irq_mask = adap->irq_mask = ~CHT_WC_EXTCHGRIRQ_ADAP_IRQMASK;\n\n\tret = regmap_read(adap->regmap, CHT_WC_I2C_RDDATA, &reg);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_write(adap->regmap, CHT_WC_EXTCHGRIRQ, ~adap->irq_mask);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_write(adap->regmap, CHT_WC_EXTCHGRIRQ_MSK, adap->irq_mask);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tadap->irq_domain = irq_domain_add_linear(NULL, 1, &irq_domain_simple_ops, NULL);\n\tif (!adap->irq_domain)\n\t\treturn -ENOMEM;\n\n\tadap->client_irq = irq_create_mapping(adap->irq_domain, 0);\n\tif (!adap->client_irq) {\n\t\tret = -ENOMEM;\n\t\tgoto remove_irq_domain;\n\t}\n\n\tirq_set_chip_data(adap->client_irq, adap);\n\tirq_set_chip_and_handler(adap->client_irq, &adap->irqchip,\n\t\t\t\t handle_simple_irq);\n\n\tret = devm_request_threaded_irq(&pdev->dev, irq, NULL,\n\t\t\t\t\tcht_wc_i2c_adap_thread_handler,\n\t\t\t\t\tIRQF_ONESHOT, \"PMIC I2C Adapter\", adap);\n\tif (ret)\n\t\tgoto remove_irq_domain;\n\n\ti2c_set_adapdata(&adap->adapter, adap);\n\tret = i2c_add_adapter(&adap->adapter);\n\tif (ret)\n\t\tgoto remove_irq_domain;\n\n\tswitch (pmic->cht_wc_model) {\n\tcase INTEL_CHT_WC_GPD_WIN_POCKET:\n\t\tboard_info = &gpd_win_board_info;\n\t\tbreak;\n\tcase INTEL_CHT_WC_XIAOMI_MIPAD2:\n\t\tboard_info = &xiaomi_mipad2_board_info;\n\t\tbreak;\n\tcase INTEL_CHT_WC_LENOVO_YOGABOOK1:\n\t\tboard_info = &lenovo_yogabook1_board_info;\n\t\tbreak;\n\tcase INTEL_CHT_WC_LENOVO_YT3_X90:\n\t\tboard_info = &lenovo_yoga_tab3_board_info;\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(&pdev->dev, \"Unknown model, not instantiating charger device\\n\");\n\t\tbreak;\n\t}\n\n\tif (board_info) {\n\t\tboard_info->irq = adap->client_irq;\n\t\tadap->client = i2c_new_client_device(&adap->adapter, board_info);\n\t\tif (IS_ERR(adap->client)) {\n\t\t\tret = PTR_ERR(adap->client);\n\t\t\tgoto del_adapter;\n\t\t}\n\t}\n\n\tplatform_set_drvdata(pdev, adap);\n\treturn 0;\n\ndel_adapter:\n\ti2c_del_adapter(&adap->adapter);\nremove_irq_domain:\n\tirq_domain_remove(adap->irq_domain);\n\treturn ret;\n}\n\nstatic void cht_wc_i2c_adap_i2c_remove(struct platform_device *pdev)\n{\n\tstruct cht_wc_i2c_adap *adap = platform_get_drvdata(pdev);\n\n\ti2c_unregister_device(adap->client);\n\ti2c_del_adapter(&adap->adapter);\n\tirq_domain_remove(adap->irq_domain);\n}\n\nstatic const struct platform_device_id cht_wc_i2c_adap_id_table[] = {\n\t{ .name = \"cht_wcove_ext_chgr\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(platform, cht_wc_i2c_adap_id_table);\n\nstatic struct platform_driver cht_wc_i2c_adap_driver = {\n\t.probe = cht_wc_i2c_adap_i2c_probe,\n\t.remove_new = cht_wc_i2c_adap_i2c_remove,\n\t.driver = {\n\t\t.name = \"cht_wcove_ext_chgr\",\n\t},\n\t.id_table = cht_wc_i2c_adap_id_table,\n};\nmodule_platform_driver(cht_wc_i2c_adap_driver);\n\nMODULE_DESCRIPTION(\"Intel CHT Whiskey Cove PMIC I2C Master driver\");\nMODULE_AUTHOR(\"Hans de Goede <hdegoede@redhat.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}