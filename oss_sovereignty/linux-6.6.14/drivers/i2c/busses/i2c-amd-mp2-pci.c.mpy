{
  "module_name": "i2c-amd-mp2-pci.c",
  "hash_id": "b7183403a7ef261efe362558661791fd556b668d27289246f2491a03dbd1bc31",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-amd-mp2-pci.c",
  "human_readable_source": "\n \n\n#include <linux/dma-mapping.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/slab.h>\n\n#include \"i2c-amd-mp2.h\"\n\n#include <linux/io-64-nonatomic-lo-hi.h>\n\nstatic void amd_mp2_c2p_mutex_lock(struct amd_i2c_common *i2c_common)\n{\n\tstruct amd_mp2_dev *privdata = i2c_common->mp2_dev;\n\n\t \n\tmutex_lock(&privdata->c2p_lock);\n\tprivdata->c2p_lock_busid = i2c_common->bus_id;\n}\n\nstatic void amd_mp2_c2p_mutex_unlock(struct amd_i2c_common *i2c_common)\n{\n\tstruct amd_mp2_dev *privdata = i2c_common->mp2_dev;\n\n\tif (unlikely(privdata->c2p_lock_busid != i2c_common->bus_id)) {\n\t\tpci_warn(privdata->pci_dev,\n\t\t\t \"bus %d attempting to unlock C2P locked by bus %d\\n\",\n\t\t\t i2c_common->bus_id, privdata->c2p_lock_busid);\n\t\treturn;\n\t}\n\n\tmutex_unlock(&privdata->c2p_lock);\n}\n\nstatic int amd_mp2_cmd(struct amd_i2c_common *i2c_common,\n\t\t       union i2c_cmd_base i2c_cmd_base)\n{\n\tstruct amd_mp2_dev *privdata = i2c_common->mp2_dev;\n\tvoid __iomem *reg;\n\n\ti2c_common->reqcmd = i2c_cmd_base.s.i2c_cmd;\n\n\treg = privdata->mmio + ((i2c_cmd_base.s.bus_id == 1) ?\n\t\t\t\tAMD_C2P_MSG1 : AMD_C2P_MSG0);\n\twritel(i2c_cmd_base.ul, reg);\n\n\treturn 0;\n}\n\nint amd_mp2_bus_enable_set(struct amd_i2c_common *i2c_common, bool enable)\n{\n\tstruct amd_mp2_dev *privdata = i2c_common->mp2_dev;\n\tunion i2c_cmd_base i2c_cmd_base;\n\n\tpci_dbg(privdata->pci_dev, \"id: %d\\n\", i2c_common->bus_id);\n\n\ti2c_cmd_base.ul = 0;\n\ti2c_cmd_base.s.i2c_cmd = enable ? i2c_enable : i2c_disable;\n\ti2c_cmd_base.s.bus_id = i2c_common->bus_id;\n\ti2c_cmd_base.s.i2c_speed = i2c_common->i2c_speed;\n\n\tamd_mp2_c2p_mutex_lock(i2c_common);\n\n\treturn amd_mp2_cmd(i2c_common, i2c_cmd_base);\n}\nEXPORT_SYMBOL_GPL(amd_mp2_bus_enable_set);\n\nstatic void amd_mp2_cmd_rw_fill(struct amd_i2c_common *i2c_common,\n\t\t\t\tunion i2c_cmd_base *i2c_cmd_base,\n\t\t\t\tenum i2c_cmd reqcmd)\n{\n\ti2c_cmd_base->s.i2c_cmd = reqcmd;\n\ti2c_cmd_base->s.bus_id = i2c_common->bus_id;\n\ti2c_cmd_base->s.i2c_speed = i2c_common->i2c_speed;\n\ti2c_cmd_base->s.slave_addr = i2c_common->msg->addr;\n\ti2c_cmd_base->s.length = i2c_common->msg->len;\n}\n\nint amd_mp2_rw(struct amd_i2c_common *i2c_common, enum i2c_cmd reqcmd)\n{\n\tstruct amd_mp2_dev *privdata = i2c_common->mp2_dev;\n\tunion i2c_cmd_base i2c_cmd_base;\n\n\tamd_mp2_cmd_rw_fill(i2c_common, &i2c_cmd_base, reqcmd);\n\tamd_mp2_c2p_mutex_lock(i2c_common);\n\n\tif (i2c_common->msg->len <= 32) {\n\t\ti2c_cmd_base.s.mem_type = use_c2pmsg;\n\t\tif (reqcmd == i2c_write)\n\t\t\tmemcpy_toio(privdata->mmio + AMD_C2P_MSG2,\n\t\t\t\t    i2c_common->msg->buf,\n\t\t\t\t    i2c_common->msg->len);\n\t} else {\n\t\ti2c_cmd_base.s.mem_type = use_dram;\n\t\twriteq((u64)i2c_common->dma_addr,\n\t\t       privdata->mmio + AMD_C2P_MSG2);\n\t}\n\n\treturn amd_mp2_cmd(i2c_common, i2c_cmd_base);\n}\nEXPORT_SYMBOL_GPL(amd_mp2_rw);\n\nstatic void amd_mp2_pci_check_rw_event(struct amd_i2c_common *i2c_common)\n{\n\tstruct amd_mp2_dev *privdata = i2c_common->mp2_dev;\n\tstruct pci_dev *pdev = privdata->pci_dev;\n\tint len = i2c_common->eventval.r.length;\n\tu32 slave_addr = i2c_common->eventval.r.slave_addr;\n\tbool err = false;\n\n\tif (unlikely(len != i2c_common->msg->len)) {\n\t\tpci_err(pdev, \"length %d in event doesn't match buffer length %d!\\n\",\n\t\t\tlen, i2c_common->msg->len);\n\t\terr = true;\n\t}\n\n\tif (unlikely(slave_addr != i2c_common->msg->addr)) {\n\t\tpci_err(pdev, \"unexpected slave address %x (expected: %x)!\\n\",\n\t\t\tslave_addr, i2c_common->msg->addr);\n\t\terr = true;\n\t}\n\n\tif (!err)\n\t\ti2c_common->cmd_success = true;\n}\n\nstatic void __amd_mp2_process_event(struct amd_i2c_common *i2c_common)\n{\n\tstruct amd_mp2_dev *privdata = i2c_common->mp2_dev;\n\tstruct pci_dev *pdev = privdata->pci_dev;\n\tenum status_type sts = i2c_common->eventval.r.status;\n\tenum response_type res = i2c_common->eventval.r.response;\n\tint len = i2c_common->eventval.r.length;\n\n\tif (res != command_success) {\n\t\tif (res != command_failed)\n\t\t\tpci_err(pdev, \"invalid response to i2c command!\\n\");\n\t\treturn;\n\t}\n\n\tswitch (i2c_common->reqcmd) {\n\tcase i2c_read:\n\t\tif (sts == i2c_readcomplete_event) {\n\t\t\tamd_mp2_pci_check_rw_event(i2c_common);\n\t\t\tif (len <= 32)\n\t\t\t\tmemcpy_fromio(i2c_common->msg->buf,\n\t\t\t\t\t      privdata->mmio + AMD_C2P_MSG2,\n\t\t\t\t\t      len);\n\t\t} else if (sts != i2c_readfail_event) {\n\t\t\tpci_err(pdev, \"invalid i2c status after read (%d)!\\n\", sts);\n\t\t}\n\t\tbreak;\n\tcase i2c_write:\n\t\tif (sts == i2c_writecomplete_event)\n\t\t\tamd_mp2_pci_check_rw_event(i2c_common);\n\t\telse if (sts != i2c_writefail_event)\n\t\t\tpci_err(pdev, \"invalid i2c status after write (%d)!\\n\", sts);\n\t\tbreak;\n\tcase i2c_enable:\n\t\tif (sts == i2c_busenable_complete)\n\t\t\ti2c_common->cmd_success = true;\n\t\telse if (sts != i2c_busenable_failed)\n\t\t\tpci_err(pdev, \"invalid i2c status after bus enable (%d)!\\n\", sts);\n\t\tbreak;\n\tcase i2c_disable:\n\t\tif (sts == i2c_busdisable_complete)\n\t\t\ti2c_common->cmd_success = true;\n\t\telse if (sts != i2c_busdisable_failed)\n\t\t\tpci_err(pdev, \"invalid i2c status after bus disable (%d)!\\n\", sts);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nvoid amd_mp2_process_event(struct amd_i2c_common *i2c_common)\n{\n\tstruct amd_mp2_dev *privdata = i2c_common->mp2_dev;\n\tstruct pci_dev *pdev = privdata->pci_dev;\n\n\tif (unlikely(i2c_common->reqcmd == i2c_none)) {\n\t\tpci_warn(pdev, \"received msg but no cmd was sent (bus = %d)!\\n\",\n\t\t\t i2c_common->bus_id);\n\t\treturn;\n\t}\n\n\t__amd_mp2_process_event(i2c_common);\n\n\ti2c_common->reqcmd = i2c_none;\n\tamd_mp2_c2p_mutex_unlock(i2c_common);\n}\nEXPORT_SYMBOL_GPL(amd_mp2_process_event);\n\nstatic irqreturn_t amd_mp2_irq_isr(int irq, void *dev)\n{\n\tstruct amd_mp2_dev *privdata = dev;\n\tstruct pci_dev *pdev = privdata->pci_dev;\n\tstruct amd_i2c_common *i2c_common;\n\tu32 val;\n\tunsigned int bus_id;\n\tvoid __iomem *reg;\n\tenum irqreturn ret = IRQ_NONE;\n\n\tfor (bus_id = 0; bus_id < 2; bus_id++) {\n\t\ti2c_common = privdata->busses[bus_id];\n\t\tif (!i2c_common)\n\t\t\tcontinue;\n\n\t\treg = privdata->mmio + ((bus_id == 0) ?\n\t\t\t\t\tAMD_P2C_MSG1 : AMD_P2C_MSG2);\n\t\tval = readl(reg);\n\t\tif (val != 0) {\n\t\t\twritel(0, reg);\n\t\t\twritel(0, privdata->mmio + AMD_P2C_MSG_INTEN);\n\t\t\ti2c_common->eventval.ul = val;\n\t\t\ti2c_common->cmd_completion(i2c_common);\n\n\t\t\tret = IRQ_HANDLED;\n\t\t}\n\t}\n\n\tif (ret != IRQ_HANDLED) {\n\t\tval = readl(privdata->mmio + AMD_P2C_MSG_INTEN);\n\t\tif (val != 0) {\n\t\t\twritel(0, privdata->mmio + AMD_P2C_MSG_INTEN);\n\t\t\tpci_warn(pdev, \"received irq without message\\n\");\n\t\t\tret = IRQ_HANDLED;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nvoid amd_mp2_rw_timeout(struct amd_i2c_common *i2c_common)\n{\n\ti2c_common->reqcmd = i2c_none;\n\tamd_mp2_c2p_mutex_unlock(i2c_common);\n}\nEXPORT_SYMBOL_GPL(amd_mp2_rw_timeout);\n\nint amd_mp2_register_cb(struct amd_i2c_common *i2c_common)\n{\n\tstruct amd_mp2_dev *privdata = i2c_common->mp2_dev;\n\tstruct pci_dev *pdev = privdata->pci_dev;\n\n\tif (i2c_common->bus_id > 1)\n\t\treturn -EINVAL;\n\n\tif (privdata->busses[i2c_common->bus_id]) {\n\t\tpci_err(pdev, \"Bus %d already taken!\\n\", i2c_common->bus_id);\n\t\treturn -EINVAL;\n\t}\n\n\tprivdata->busses[i2c_common->bus_id] = i2c_common;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(amd_mp2_register_cb);\n\nint amd_mp2_unregister_cb(struct amd_i2c_common *i2c_common)\n{\n\tstruct amd_mp2_dev *privdata = i2c_common->mp2_dev;\n\n\tprivdata->busses[i2c_common->bus_id] = NULL;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(amd_mp2_unregister_cb);\n\nstatic void amd_mp2_clear_reg(struct amd_mp2_dev *privdata)\n{\n\tint reg;\n\n\tfor (reg = AMD_C2P_MSG0; reg <= AMD_C2P_MSG9; reg += 4)\n\t\twritel(0, privdata->mmio + reg);\n\n\tfor (reg = AMD_P2C_MSG1; reg <= AMD_P2C_MSG2; reg += 4)\n\t\twritel(0, privdata->mmio + reg);\n}\n\nstatic int amd_mp2_pci_init(struct amd_mp2_dev *privdata,\n\t\t\t    struct pci_dev *pci_dev)\n{\n\tint irq_flag = 0, rc;\n\n\tpci_set_drvdata(pci_dev, privdata);\n\n\trc = pcim_enable_device(pci_dev);\n\tif (rc) {\n\t\tpci_err(pci_dev, \"Failed to enable MP2 PCI device\\n\");\n\t\tgoto err_pci_enable;\n\t}\n\n\trc = pcim_iomap_regions(pci_dev, 1 << 2, pci_name(pci_dev));\n\tif (rc) {\n\t\tpci_err(pci_dev, \"I/O memory remapping failed\\n\");\n\t\tgoto err_pci_enable;\n\t}\n\tprivdata->mmio = pcim_iomap_table(pci_dev)[2];\n\n\tpci_set_master(pci_dev);\n\n\trc = dma_set_mask(&pci_dev->dev, DMA_BIT_MASK(64));\n\tif (rc)\n\t\tgoto err_dma_mask;\n\n\t \n\twritel(0, privdata->mmio + AMD_P2C_MSG_INTEN);\n\trc = pci_alloc_irq_vectors(pci_dev, 1, 1, PCI_IRQ_ALL_TYPES);\n\tif (rc < 0) {\n\t\tdev_err(&pci_dev->dev, \"Failed to allocate single IRQ err=%d\\n\", rc);\n\t\tgoto err_dma_mask;\n\t}\n\n\tprivdata->dev_irq = pci_irq_vector(pci_dev, 0);\n\tif (!pci_dev->msix_enabled && !pci_dev->msi_enabled)\n\t\tirq_flag = IRQF_SHARED;\n\n\trc = devm_request_irq(&pci_dev->dev, privdata->dev_irq,\n\t\t\t      amd_mp2_irq_isr, irq_flag, dev_name(&pci_dev->dev), privdata);\n\tif (rc) {\n\t\tpci_err(pci_dev, \"Failure requesting irq %i: %d\\n\", privdata->dev_irq, rc);\n\t\tgoto free_irq_vectors;\n\t}\n\n\treturn rc;\n\nfree_irq_vectors:\n\tfree_irq(privdata->dev_irq, privdata);\nerr_dma_mask:\n\tpci_clear_master(pci_dev);\nerr_pci_enable:\n\tpci_set_drvdata(pci_dev, NULL);\n\treturn rc;\n}\n\nstatic int amd_mp2_pci_probe(struct pci_dev *pci_dev,\n\t\t\t     const struct pci_device_id *id)\n{\n\tstruct amd_mp2_dev *privdata;\n\tint rc;\n\n\tprivdata = devm_kzalloc(&pci_dev->dev, sizeof(*privdata), GFP_KERNEL);\n\tif (!privdata)\n\t\treturn -ENOMEM;\n\n\tprivdata->pci_dev = pci_dev;\n\trc = amd_mp2_pci_init(privdata, pci_dev);\n\tif (rc)\n\t\treturn rc;\n\n\tmutex_init(&privdata->c2p_lock);\n\n\tpm_runtime_set_autosuspend_delay(&pci_dev->dev, 1000);\n\tpm_runtime_use_autosuspend(&pci_dev->dev);\n\tpm_runtime_put_autosuspend(&pci_dev->dev);\n\tpm_runtime_allow(&pci_dev->dev);\n\n\tprivdata->probed = true;\n\n\tpci_info(pci_dev, \"MP2 device registered.\\n\");\n\treturn 0;\n}\n\nstatic void amd_mp2_pci_remove(struct pci_dev *pci_dev)\n{\n\tstruct amd_mp2_dev *privdata = pci_get_drvdata(pci_dev);\n\n\tpm_runtime_forbid(&pci_dev->dev);\n\tpm_runtime_get_noresume(&pci_dev->dev);\n\n\tfree_irq(privdata->dev_irq, privdata);\n\tpci_clear_master(pci_dev);\n\n\tamd_mp2_clear_reg(privdata);\n}\n\n#ifdef CONFIG_PM\nstatic int amd_mp2_pci_suspend(struct device *dev)\n{\n\tstruct pci_dev *pci_dev = to_pci_dev(dev);\n\tstruct amd_mp2_dev *privdata = pci_get_drvdata(pci_dev);\n\tstruct amd_i2c_common *i2c_common;\n\tunsigned int bus_id;\n\tint ret = 0;\n\n\tfor (bus_id = 0; bus_id < 2; bus_id++) {\n\t\ti2c_common = privdata->busses[bus_id];\n\t\tif (i2c_common)\n\t\t\ti2c_common->suspend(i2c_common);\n\t}\n\n\tret = pci_save_state(pci_dev);\n\tif (ret) {\n\t\tpci_err(pci_dev, \"pci_save_state failed = %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tpci_disable_device(pci_dev);\n\treturn ret;\n}\n\nstatic int amd_mp2_pci_resume(struct device *dev)\n{\n\tstruct pci_dev *pci_dev = to_pci_dev(dev);\n\tstruct amd_mp2_dev *privdata = pci_get_drvdata(pci_dev);\n\tstruct amd_i2c_common *i2c_common;\n\tunsigned int bus_id;\n\tint ret = 0;\n\n\tpci_restore_state(pci_dev);\n\tret = pci_enable_device(pci_dev);\n\tif (ret < 0) {\n\t\tpci_err(pci_dev, \"pci_enable_device failed = %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tfor (bus_id = 0; bus_id < 2; bus_id++) {\n\t\ti2c_common = privdata->busses[bus_id];\n\t\tif (i2c_common) {\n\t\t\tret = i2c_common->resume(i2c_common);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic UNIVERSAL_DEV_PM_OPS(amd_mp2_pci_pm_ops, amd_mp2_pci_suspend,\n\t\t\t    amd_mp2_pci_resume, NULL);\n#endif  \n\nstatic const struct pci_device_id amd_mp2_pci_tbl[] = {\n\t{PCI_VDEVICE(AMD, PCI_DEVICE_ID_AMD_MP2)},\n\t{0}\n};\nMODULE_DEVICE_TABLE(pci, amd_mp2_pci_tbl);\n\nstatic struct pci_driver amd_mp2_pci_driver = {\n\t.name\t\t= \"i2c_amd_mp2\",\n\t.id_table\t= amd_mp2_pci_tbl,\n\t.probe\t\t= amd_mp2_pci_probe,\n\t.remove\t\t= amd_mp2_pci_remove,\n#ifdef CONFIG_PM\n\t.driver = {\n\t\t.pm\t= &amd_mp2_pci_pm_ops,\n\t},\n#endif\n};\nmodule_pci_driver(amd_mp2_pci_driver);\n\nstruct amd_mp2_dev *amd_mp2_find_device(void)\n{\n\tstruct device *dev;\n\tstruct pci_dev *pci_dev;\n\n\tdev = driver_find_next_device(&amd_mp2_pci_driver.driver, NULL);\n\tif (!dev)\n\t\treturn NULL;\n\n\tpci_dev = to_pci_dev(dev);\n\treturn (struct amd_mp2_dev *)pci_get_drvdata(pci_dev);\n}\nEXPORT_SYMBOL_GPL(amd_mp2_find_device);\n\nMODULE_DESCRIPTION(\"AMD(R) PCI-E MP2 I2C Controller Driver\");\nMODULE_AUTHOR(\"Shyam Sundar S K <Shyam-sundar.S-k@amd.com>\");\nMODULE_AUTHOR(\"Elie Morisse <syniurge@gmail.com>\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}