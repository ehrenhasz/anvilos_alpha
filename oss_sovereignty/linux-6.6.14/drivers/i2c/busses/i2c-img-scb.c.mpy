{
  "module_name": "i2c-img-scb.c",
  "hash_id": "bd01b6c7915e54d5828a37969ac6f1a8715a5a5c165125875e1b8d0174b18f77",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-img-scb.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/clk.h>\n#include <linux/completion.h>\n#include <linux/err.h>\n#include <linux/i2c.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/slab.h>\n#include <linux/timer.h>\n\n \n\n#define SCB_STATUS_REG\t\t\t0x00\n#define SCB_OVERRIDE_REG\t\t0x04\n#define SCB_READ_ADDR_REG\t\t0x08\n#define SCB_READ_COUNT_REG\t\t0x0c\n#define SCB_WRITE_ADDR_REG\t\t0x10\n#define SCB_READ_DATA_REG\t\t0x14\n#define SCB_WRITE_DATA_REG\t\t0x18\n#define SCB_FIFO_STATUS_REG\t\t0x1c\n#define SCB_CONTROL_SOFT_RESET\t\t0x1f\n#define SCB_CLK_SET_REG\t\t\t0x3c\n#define SCB_INT_STATUS_REG\t\t0x40\n#define SCB_INT_CLEAR_REG\t\t0x44\n#define SCB_INT_MASK_REG\t\t0x48\n#define SCB_CONTROL_REG\t\t\t0x4c\n#define SCB_TIME_TPL_REG\t\t0x50\n#define SCB_TIME_TPH_REG\t\t0x54\n#define SCB_TIME_TP2S_REG\t\t0x58\n#define SCB_TIME_TBI_REG\t\t0x60\n#define SCB_TIME_TSL_REG\t\t0x64\n#define SCB_TIME_TDL_REG\t\t0x68\n#define SCB_TIME_TSDL_REG\t\t0x6c\n#define SCB_TIME_TSDH_REG\t\t0x70\n#define SCB_READ_XADDR_REG\t\t0x74\n#define SCB_WRITE_XADDR_REG\t\t0x78\n#define SCB_WRITE_COUNT_REG\t\t0x7c\n#define SCB_CORE_REV_REG\t\t0x80\n#define SCB_TIME_TCKH_REG\t\t0x84\n#define SCB_TIME_TCKL_REG\t\t0x88\n#define SCB_FIFO_FLUSH_REG\t\t0x8c\n#define SCB_READ_FIFO_REG\t\t0x94\n#define SCB_CLEAR_REG\t\t\t0x98\n\n \n\n#define SCB_CONTROL_CLK_ENABLE\t\t0x1e0\n#define SCB_CONTROL_TRANSACTION_HALT\t0x200\n\n#define FIFO_READ_FULL\t\t\tBIT(0)\n#define FIFO_READ_EMPTY\t\t\tBIT(1)\n#define FIFO_WRITE_FULL\t\t\tBIT(2)\n#define FIFO_WRITE_EMPTY\t\tBIT(3)\n\n \n#define SCB_FILT_DISABLE\t\tBIT(31)\n#define SCB_FILT_BYPASS\t\t\tBIT(30)\n#define SCB_FILT_INC_MASK\t\t0x7f\n#define SCB_FILT_INC_SHIFT\t\t16\n#define SCB_INC_MASK\t\t\t0x7f\n#define SCB_INC_SHIFT\t\t\t8\n\n \n\n#define INT_BUS_INACTIVE\t\tBIT(0)\n#define INT_UNEXPECTED_START\t\tBIT(1)\n#define INT_SCLK_LOW_TIMEOUT\t\tBIT(2)\n#define INT_SDAT_LOW_TIMEOUT\t\tBIT(3)\n#define INT_WRITE_ACK_ERR\t\tBIT(4)\n#define INT_ADDR_ACK_ERR\t\tBIT(5)\n#define INT_FIFO_FULL\t\t\tBIT(9)\n#define INT_FIFO_FILLING\t\tBIT(10)\n#define INT_FIFO_EMPTY\t\t\tBIT(11)\n#define INT_FIFO_EMPTYING\t\tBIT(12)\n#define INT_TRANSACTION_DONE\t\tBIT(15)\n#define INT_SLAVE_EVENT\t\t\tBIT(16)\n#define INT_MASTER_HALTED\t\tBIT(17)\n#define INT_TIMING\t\t\tBIT(18)\n#define INT_STOP_DETECTED\t\tBIT(19)\n\n#define INT_FIFO_FULL_FILLING\t(INT_FIFO_FULL  | INT_FIFO_FILLING)\n\n \n#define INT_LEVEL\t\t\t0x01e00\n\n \n#define INT_ENABLE_MASK_INACTIVE\t0x00000\n\n \n\n#define INT_ENABLE_MASK_RAW\t\tINT_TIMING\n\n#define INT_ENABLE_MASK_ATOMIC\t\t(INT_TRANSACTION_DONE | \\\n\t\t\t\t\t INT_SLAVE_EVENT      | \\\n\t\t\t\t\t INT_ADDR_ACK_ERR     | \\\n\t\t\t\t\t INT_WRITE_ACK_ERR)\n\n#define INT_ENABLE_MASK_AUTOMATIC\t(INT_SCLK_LOW_TIMEOUT | \\\n\t\t\t\t\t INT_ADDR_ACK_ERR     | \\\n\t\t\t\t\t INT_WRITE_ACK_ERR    | \\\n\t\t\t\t\t INT_FIFO_FULL        | \\\n\t\t\t\t\t INT_FIFO_FILLING     | \\\n\t\t\t\t\t INT_FIFO_EMPTY       | \\\n\t\t\t\t\t INT_MASTER_HALTED    | \\\n\t\t\t\t\t INT_STOP_DETECTED)\n\n#define INT_ENABLE_MASK_WAITSTOP\t(INT_SLAVE_EVENT      | \\\n\t\t\t\t\t INT_ADDR_ACK_ERR     | \\\n\t\t\t\t\t INT_WRITE_ACK_ERR)\n\n \n\n#define LINESTAT_SCLK_LINE_STATUS\tBIT(0)\n#define LINESTAT_SCLK_EN\t\tBIT(1)\n#define LINESTAT_SDAT_LINE_STATUS\tBIT(2)\n#define LINESTAT_SDAT_EN\t\tBIT(3)\n#define LINESTAT_DET_START_STATUS\tBIT(4)\n#define LINESTAT_DET_STOP_STATUS\tBIT(5)\n#define LINESTAT_DET_ACK_STATUS\t\tBIT(6)\n#define LINESTAT_DET_NACK_STATUS\tBIT(7)\n#define LINESTAT_BUS_IDLE\t\tBIT(8)\n#define LINESTAT_T_DONE_STATUS\t\tBIT(9)\n#define LINESTAT_SCLK_OUT_STATUS\tBIT(10)\n#define LINESTAT_SDAT_OUT_STATUS\tBIT(11)\n#define LINESTAT_GEN_LINE_MASK_STATUS\tBIT(12)\n#define LINESTAT_START_BIT_DET\t\tBIT(13)\n#define LINESTAT_STOP_BIT_DET\t\tBIT(14)\n#define LINESTAT_ACK_DET\t\tBIT(15)\n#define LINESTAT_NACK_DET\t\tBIT(16)\n#define LINESTAT_INPUT_HELD_V\t\tBIT(17)\n#define LINESTAT_ABORT_DET\t\tBIT(18)\n#define LINESTAT_ACK_OR_NACK_DET\t(LINESTAT_ACK_DET | LINESTAT_NACK_DET)\n#define LINESTAT_INPUT_DATA\t\t0xff000000\n#define LINESTAT_INPUT_DATA_SHIFT\t24\n\n#define LINESTAT_CLEAR_SHIFT\t\t13\n#define LINESTAT_LATCHED\t\t(0x3f << LINESTAT_CLEAR_SHIFT)\n\n \n\n#define OVERRIDE_SCLK_OVR\t\tBIT(0)\n#define OVERRIDE_SCLKEN_OVR\t\tBIT(1)\n#define OVERRIDE_SDAT_OVR\t\tBIT(2)\n#define OVERRIDE_SDATEN_OVR\t\tBIT(3)\n#define OVERRIDE_MASTER\t\t\tBIT(9)\n#define OVERRIDE_LINE_OVR_EN\t\tBIT(10)\n#define OVERRIDE_DIRECT\t\t\tBIT(11)\n#define OVERRIDE_CMD_SHIFT\t\t4\n#define OVERRIDE_CMD_MASK\t\t0x1f\n#define OVERRIDE_DATA_SHIFT\t\t24\n\n#define OVERRIDE_SCLK_DOWN\t\t(OVERRIDE_LINE_OVR_EN | \\\n\t\t\t\t\t OVERRIDE_SCLKEN_OVR)\n#define OVERRIDE_SCLK_UP\t\t(OVERRIDE_LINE_OVR_EN | \\\n\t\t\t\t\t OVERRIDE_SCLKEN_OVR | \\\n\t\t\t\t\t OVERRIDE_SCLK_OVR)\n#define OVERRIDE_SDAT_DOWN\t\t(OVERRIDE_LINE_OVR_EN | \\\n\t\t\t\t\t OVERRIDE_SDATEN_OVR)\n#define OVERRIDE_SDAT_UP\t\t(OVERRIDE_LINE_OVR_EN | \\\n\t\t\t\t\t OVERRIDE_SDATEN_OVR | \\\n\t\t\t\t\t OVERRIDE_SDAT_OVR)\n\n \n\n#define CMD_PAUSE\t\t\t0x00\n#define CMD_GEN_DATA\t\t\t0x01\n#define CMD_GEN_START\t\t\t0x02\n#define CMD_GEN_STOP\t\t\t0x03\n#define CMD_GEN_ACK\t\t\t0x04\n#define CMD_GEN_NACK\t\t\t0x05\n#define CMD_RET_DATA\t\t\t0x08\n#define CMD_RET_ACK\t\t\t0x09\n\n \n\n#define TIMEOUT_TBI\t\t\t0x0\n#define TIMEOUT_TSL\t\t\t0xffff\n#define TIMEOUT_TDL\t\t\t0x0\n\n \n\n#define IMG_I2C_TIMEOUT\t\t\t(msecs_to_jiffies(1000))\n\n \n#define SCB_OPT_INC\t\t64\n\n \n#define SCB_FILT_GLITCH\t\t25\n\n \n#define ISR_COMPLETE_M\t\tBIT(31)\n#define ISR_FATAL_M\t\tBIT(30)\n#define ISR_WAITSTOP\t\tBIT(29)\n#define ISR_STATUS_M\t\t0x0000ffff\t \n#define ISR_COMPLETE(err)\t(ISR_COMPLETE_M | (ISR_STATUS_M & (err)))\n#define ISR_FATAL(err)\t\t(ISR_COMPLETE(err) | ISR_FATAL_M)\n\n#define IMG_I2C_PM_TIMEOUT\t1000  \n\nenum img_i2c_mode {\n\tMODE_INACTIVE,\n\tMODE_RAW,\n\tMODE_ATOMIC,\n\tMODE_AUTOMATIC,\n\tMODE_SEQUENCE,\n\tMODE_FATAL,\n\tMODE_WAITSTOP,\n\tMODE_SUSPEND,\n};\n\n \nstruct img_i2c_timings {\n\tconst char *name;\n\tunsigned int max_bitrate;\n\tunsigned int tckh, tckl, tsdh, tsdl;\n\tunsigned int tp2s, tpl, tph;\n};\n\n \nstatic struct img_i2c_timings timings[] = {\n\t \n\t{\n\t\t.name = \"standard\",\n\t\t.max_bitrate = I2C_MAX_STANDARD_MODE_FREQ,\n\t\t.tckh = 4000,\n\t\t.tckl = 4700,\n\t\t.tsdh = 4700,\n\t\t.tsdl = 8700,\n\t\t.tp2s = 4700,\n\t\t.tpl = 4700,\n\t\t.tph = 4000,\n\t},\n\t \n\t{\n\t\t.name = \"fast\",\n\t\t.max_bitrate = I2C_MAX_FAST_MODE_FREQ,\n\t\t.tckh = 600,\n\t\t.tckl = 1300,\n\t\t.tsdh = 600,\n\t\t.tsdl = 1200,\n\t\t.tp2s = 1300,\n\t\t.tpl = 600,\n\t\t.tph = 600,\n\t},\n};\n\n \nstatic u8 img_i2c_reset_seq[] = { CMD_GEN_START,\n\t\t\t\t  CMD_GEN_DATA, 0xff,\n\t\t\t\t  CMD_RET_ACK,\n\t\t\t\t  CMD_GEN_START,\n\t\t\t\t  CMD_GEN_STOP,\n\t\t\t\t  0 };\n \nstatic u8 img_i2c_stop_seq[] = {  CMD_GEN_STOP,\n\t\t\t\t  0 };\n\n \nstatic unsigned int img_i2c_int_enable_by_mode[] = {\n\t[MODE_INACTIVE]  = INT_ENABLE_MASK_INACTIVE,\n\t[MODE_RAW]       = INT_ENABLE_MASK_RAW,\n\t[MODE_ATOMIC]    = INT_ENABLE_MASK_ATOMIC,\n\t[MODE_AUTOMATIC] = INT_ENABLE_MASK_AUTOMATIC,\n\t[MODE_SEQUENCE]  = INT_ENABLE_MASK_ATOMIC,\n\t[MODE_FATAL]     = 0,\n\t[MODE_WAITSTOP]  = INT_ENABLE_MASK_WAITSTOP,\n\t[MODE_SUSPEND]   = 0,\n};\n\n \nstatic const char * const img_i2c_atomic_cmd_names[] = {\n\t[CMD_PAUSE]\t= \"PAUSE\",\n\t[CMD_GEN_DATA]\t= \"GEN_DATA\",\n\t[CMD_GEN_START]\t= \"GEN_START\",\n\t[CMD_GEN_STOP]\t= \"GEN_STOP\",\n\t[CMD_GEN_ACK]\t= \"GEN_ACK\",\n\t[CMD_GEN_NACK]\t= \"GEN_NACK\",\n\t[CMD_RET_DATA]\t= \"RET_DATA\",\n\t[CMD_RET_ACK]\t= \"RET_ACK\",\n};\n\nstruct img_i2c {\n\tstruct i2c_adapter adap;\n\n\tvoid __iomem *base;\n\n\t \n\tstruct clk *scb_clk, *sys_clk;\n\tunsigned int bitrate;\n\tbool need_wr_rd_fence;\n\n\t \n\tstruct completion msg_complete;\n\tspinlock_t lock;\t \n\tstruct i2c_msg msg;\n\n\t \n\tbool last_msg;\n\tint msg_status;\n\n\tenum img_i2c_mode mode;\n\tu32 int_enable;\t\t \n\tu32 line_status;\t \n\n\t \n\tstruct timer_list check_timer;\n\tbool t_halt;\n\n\t \n\tbool at_t_done;\n\tbool at_slave_event;\n\tint at_cur_cmd;\n\tu8 at_cur_data;\n\n\t \n\tu8 *seq;\n\n\t \n\tunsigned int raw_timeout;\n};\n\nstatic int img_i2c_runtime_suspend(struct device *dev);\nstatic int img_i2c_runtime_resume(struct device *dev);\n\nstatic void img_i2c_writel(struct img_i2c *i2c, u32 offset, u32 value)\n{\n\twritel(value, i2c->base + offset);\n}\n\nstatic u32 img_i2c_readl(struct img_i2c *i2c, u32 offset)\n{\n\treturn readl(i2c->base + offset);\n}\n\n \nstatic void img_i2c_wr_rd_fence(struct img_i2c *i2c)\n{\n\tif (i2c->need_wr_rd_fence) {\n\t\timg_i2c_writel(i2c, SCB_CORE_REV_REG, 0);\n\t\timg_i2c_writel(i2c, SCB_CORE_REV_REG, 0);\n\t}\n}\n\nstatic void img_i2c_switch_mode(struct img_i2c *i2c, enum img_i2c_mode mode)\n{\n\ti2c->mode = mode;\n\ti2c->int_enable = img_i2c_int_enable_by_mode[mode];\n\ti2c->line_status = 0;\n}\n\nstatic void img_i2c_raw_op(struct img_i2c *i2c)\n{\n\ti2c->raw_timeout = 0;\n\timg_i2c_writel(i2c, SCB_OVERRIDE_REG,\n\t\tOVERRIDE_SCLKEN_OVR |\n\t\tOVERRIDE_SDATEN_OVR |\n\t\tOVERRIDE_MASTER |\n\t\tOVERRIDE_LINE_OVR_EN |\n\t\tOVERRIDE_DIRECT |\n\t\t((i2c->at_cur_cmd & OVERRIDE_CMD_MASK) << OVERRIDE_CMD_SHIFT) |\n\t\t(i2c->at_cur_data << OVERRIDE_DATA_SHIFT));\n}\n\nstatic const char *img_i2c_atomic_op_name(unsigned int cmd)\n{\n\tif (unlikely(cmd >= ARRAY_SIZE(img_i2c_atomic_cmd_names)))\n\t\treturn \"UNKNOWN\";\n\treturn img_i2c_atomic_cmd_names[cmd];\n}\n\n \nstatic void img_i2c_atomic_op(struct img_i2c *i2c, int cmd, u8 data)\n{\n\ti2c->at_cur_cmd = cmd;\n\ti2c->at_cur_data = data;\n\n\t \n\tif (cmd == CMD_GEN_DATA && i2c->mode == MODE_ATOMIC) {\n\t\tu32 line_status = img_i2c_readl(i2c, SCB_STATUS_REG);\n\n\t\tif (line_status & LINESTAT_SDAT_LINE_STATUS && !(data & 0x80)) {\n\t\t\t \n\t\t\timg_i2c_switch_mode(i2c, MODE_RAW);\n\t\t\timg_i2c_raw_op(i2c);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tdev_dbg(i2c->adap.dev.parent,\n\t\t\"atomic cmd=%s (%d) data=%#x\\n\",\n\t\timg_i2c_atomic_op_name(cmd), cmd, data);\n\ti2c->at_t_done = (cmd == CMD_RET_DATA || cmd == CMD_RET_ACK);\n\ti2c->at_slave_event = false;\n\ti2c->line_status = 0;\n\n\timg_i2c_writel(i2c, SCB_OVERRIDE_REG,\n\t\t((cmd & OVERRIDE_CMD_MASK) << OVERRIDE_CMD_SHIFT) |\n\t\tOVERRIDE_MASTER |\n\t\tOVERRIDE_DIRECT |\n\t\t(data << OVERRIDE_DATA_SHIFT));\n}\n\n \nstatic void img_i2c_atomic_start(struct img_i2c *i2c)\n{\n\timg_i2c_switch_mode(i2c, MODE_ATOMIC);\n\timg_i2c_writel(i2c, SCB_INT_MASK_REG, i2c->int_enable);\n\timg_i2c_atomic_op(i2c, CMD_GEN_START, 0x00);\n}\n\nstatic void img_i2c_soft_reset(struct img_i2c *i2c)\n{\n\ti2c->t_halt = false;\n\timg_i2c_writel(i2c, SCB_CONTROL_REG, 0);\n\timg_i2c_writel(i2c, SCB_CONTROL_REG,\n\t\t       SCB_CONTROL_CLK_ENABLE | SCB_CONTROL_SOFT_RESET);\n}\n\n \nstatic void img_i2c_transaction_halt(struct img_i2c *i2c, bool t_halt)\n{\n\tu32 val;\n\n\tif (i2c->t_halt == t_halt)\n\t\treturn;\n\ti2c->t_halt = t_halt;\n\tval = img_i2c_readl(i2c, SCB_CONTROL_REG);\n\tif (t_halt)\n\t\tval |= SCB_CONTROL_TRANSACTION_HALT;\n\telse\n\t\tval &= ~SCB_CONTROL_TRANSACTION_HALT;\n\timg_i2c_writel(i2c, SCB_CONTROL_REG, val);\n}\n\n \nstatic void img_i2c_read_fifo(struct img_i2c *i2c)\n{\n\twhile (i2c->msg.len) {\n\t\tu32 fifo_status;\n\t\tu8 data;\n\n\t\timg_i2c_wr_rd_fence(i2c);\n\t\tfifo_status = img_i2c_readl(i2c, SCB_FIFO_STATUS_REG);\n\t\tif (fifo_status & FIFO_READ_EMPTY)\n\t\t\tbreak;\n\n\t\tdata = img_i2c_readl(i2c, SCB_READ_DATA_REG);\n\t\t*i2c->msg.buf = data;\n\n\t\timg_i2c_writel(i2c, SCB_READ_FIFO_REG, 0xff);\n\t\ti2c->msg.len--;\n\t\ti2c->msg.buf++;\n\t}\n}\n\n \nstatic void img_i2c_write_fifo(struct img_i2c *i2c)\n{\n\twhile (i2c->msg.len) {\n\t\tu32 fifo_status;\n\n\t\timg_i2c_wr_rd_fence(i2c);\n\t\tfifo_status = img_i2c_readl(i2c, SCB_FIFO_STATUS_REG);\n\t\tif (fifo_status & FIFO_WRITE_FULL)\n\t\t\tbreak;\n\n\t\timg_i2c_writel(i2c, SCB_WRITE_DATA_REG, *i2c->msg.buf);\n\t\ti2c->msg.len--;\n\t\ti2c->msg.buf++;\n\t}\n\n\t \n\tif (!i2c->msg.len)\n\t\ti2c->int_enable &= ~INT_FIFO_EMPTYING;\n}\n\n \nstatic void img_i2c_read(struct img_i2c *i2c)\n{\n\timg_i2c_switch_mode(i2c, MODE_AUTOMATIC);\n\tif (!i2c->last_msg)\n\t\ti2c->int_enable |= INT_SLAVE_EVENT;\n\n\timg_i2c_writel(i2c, SCB_INT_MASK_REG, i2c->int_enable);\n\timg_i2c_writel(i2c, SCB_READ_ADDR_REG, i2c->msg.addr);\n\timg_i2c_writel(i2c, SCB_READ_COUNT_REG, i2c->msg.len);\n\n\tmod_timer(&i2c->check_timer, jiffies + msecs_to_jiffies(1));\n}\n\n \nstatic void img_i2c_write(struct img_i2c *i2c)\n{\n\timg_i2c_switch_mode(i2c, MODE_AUTOMATIC);\n\tif (!i2c->last_msg)\n\t\ti2c->int_enable |= INT_SLAVE_EVENT;\n\n\timg_i2c_writel(i2c, SCB_WRITE_ADDR_REG, i2c->msg.addr);\n\timg_i2c_writel(i2c, SCB_WRITE_COUNT_REG, i2c->msg.len);\n\n\tmod_timer(&i2c->check_timer, jiffies + msecs_to_jiffies(1));\n\timg_i2c_write_fifo(i2c);\n\n\t \n\timg_i2c_writel(i2c, SCB_INT_MASK_REG, i2c->int_enable);\n}\n\n \nstatic void img_i2c_complete_transaction(struct img_i2c *i2c, int status)\n{\n\timg_i2c_switch_mode(i2c, MODE_INACTIVE);\n\tif (status) {\n\t\ti2c->msg_status = status;\n\t\timg_i2c_transaction_halt(i2c, false);\n\t}\n\tcomplete(&i2c->msg_complete);\n}\n\nstatic unsigned int img_i2c_raw_atomic_delay_handler(struct img_i2c *i2c,\n\t\t\t\t\tu32 int_status, u32 line_status)\n{\n\t \n\timg_i2c_atomic_op(i2c, i2c->at_cur_cmd, i2c->at_cur_data);\n\timg_i2c_switch_mode(i2c, MODE_ATOMIC);\n\treturn 0;\n}\n\nstatic unsigned int img_i2c_raw(struct img_i2c *i2c, u32 int_status,\n\t\t\t\tu32 line_status)\n{\n\tif (int_status & INT_TIMING) {\n\t\tif (i2c->raw_timeout == 0)\n\t\t\treturn img_i2c_raw_atomic_delay_handler(i2c,\n\t\t\t\tint_status, line_status);\n\t\t--i2c->raw_timeout;\n\t}\n\treturn 0;\n}\n\nstatic unsigned int img_i2c_sequence(struct img_i2c *i2c, u32 int_status)\n{\n\tstatic const unsigned int continue_bits[] = {\n\t\t[CMD_GEN_START] = LINESTAT_START_BIT_DET,\n\t\t[CMD_GEN_DATA]  = LINESTAT_INPUT_HELD_V,\n\t\t[CMD_RET_ACK]   = LINESTAT_ACK_DET | LINESTAT_NACK_DET,\n\t\t[CMD_RET_DATA]  = LINESTAT_INPUT_HELD_V,\n\t\t[CMD_GEN_STOP]  = LINESTAT_STOP_BIT_DET,\n\t};\n\tint next_cmd = -1;\n\tu8 next_data = 0x00;\n\n\tif (int_status & INT_SLAVE_EVENT)\n\t\ti2c->at_slave_event = true;\n\tif (int_status & INT_TRANSACTION_DONE)\n\t\ti2c->at_t_done = true;\n\n\tif (!i2c->at_slave_event || !i2c->at_t_done)\n\t\treturn 0;\n\n\t \n\tif (i2c->at_cur_cmd >= 0 &&\n\t    i2c->at_cur_cmd < ARRAY_SIZE(continue_bits)) {\n\t\tunsigned int cont_bits = continue_bits[i2c->at_cur_cmd];\n\n\t\tif (cont_bits) {\n\t\t\tcont_bits |= LINESTAT_ABORT_DET;\n\t\t\tif (!(i2c->line_status & cont_bits))\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\n\t \n\tnext_cmd = *i2c->seq;\n\t \n\tif (!next_cmd) {\n\t\timg_i2c_writel(i2c, SCB_OVERRIDE_REG, 0);\n\t\treturn ISR_COMPLETE(0);\n\t}\n\t \n\tif (next_cmd == CMD_GEN_DATA) {\n\t\t++i2c->seq;\n\t\tnext_data = *i2c->seq;\n\t}\n\t++i2c->seq;\n\timg_i2c_atomic_op(i2c, next_cmd, next_data);\n\n\treturn 0;\n}\n\nstatic void img_i2c_reset_start(struct img_i2c *i2c)\n{\n\t \n\timg_i2c_switch_mode(i2c, MODE_SEQUENCE);\n\timg_i2c_writel(i2c, SCB_INT_MASK_REG, i2c->int_enable);\n\ti2c->seq = img_i2c_reset_seq;\n\ti2c->at_slave_event = true;\n\ti2c->at_t_done = true;\n\ti2c->at_cur_cmd = -1;\n\n\t \n\timg_i2c_sequence(i2c, 0);\n}\n\nstatic void img_i2c_stop_start(struct img_i2c *i2c)\n{\n\t \n\timg_i2c_switch_mode(i2c, MODE_SEQUENCE);\n\timg_i2c_writel(i2c, SCB_INT_MASK_REG, i2c->int_enable);\n\ti2c->seq = img_i2c_stop_seq;\n\ti2c->at_slave_event = true;\n\ti2c->at_t_done = true;\n\ti2c->at_cur_cmd = -1;\n\n\t \n\timg_i2c_sequence(i2c, 0);\n}\n\nstatic unsigned int img_i2c_atomic(struct img_i2c *i2c,\n\t\t\t\t   u32 int_status,\n\t\t\t\t   u32 line_status)\n{\n\tint next_cmd = -1;\n\tu8 next_data = 0x00;\n\n\tif (int_status & INT_SLAVE_EVENT)\n\t\ti2c->at_slave_event = true;\n\tif (int_status & INT_TRANSACTION_DONE)\n\t\ti2c->at_t_done = true;\n\n\tif (!i2c->at_slave_event || !i2c->at_t_done)\n\t\tgoto next_atomic_cmd;\n\tif (i2c->line_status & LINESTAT_ABORT_DET) {\n\t\tdev_dbg(i2c->adap.dev.parent, \"abort condition detected\\n\");\n\t\tnext_cmd = CMD_GEN_STOP;\n\t\ti2c->msg_status = -EIO;\n\t\tgoto next_atomic_cmd;\n\t}\n\n\t \n\tswitch (i2c->at_cur_cmd) {\n\tcase CMD_GEN_START:\n\t\tnext_cmd = CMD_GEN_DATA;\n\t\tnext_data = i2c_8bit_addr_from_msg(&i2c->msg);\n\t\tbreak;\n\tcase CMD_GEN_DATA:\n\t\tif (i2c->line_status & LINESTAT_INPUT_HELD_V)\n\t\t\tnext_cmd = CMD_RET_ACK;\n\t\tbreak;\n\tcase CMD_RET_ACK:\n\t\tif (i2c->line_status & LINESTAT_ACK_DET ||\n\t\t    (i2c->line_status & LINESTAT_NACK_DET &&\n\t\t    i2c->msg.flags & I2C_M_IGNORE_NAK)) {\n\t\t\tif (i2c->msg.len == 0) {\n\t\t\t\tnext_cmd = CMD_GEN_STOP;\n\t\t\t} else if (i2c->msg.flags & I2C_M_RD) {\n\t\t\t\tnext_cmd = CMD_RET_DATA;\n\t\t\t} else {\n\t\t\t\tnext_cmd = CMD_GEN_DATA;\n\t\t\t\tnext_data = *i2c->msg.buf;\n\t\t\t\t--i2c->msg.len;\n\t\t\t\t++i2c->msg.buf;\n\t\t\t}\n\t\t} else if (i2c->line_status & LINESTAT_NACK_DET) {\n\t\t\ti2c->msg_status = -EIO;\n\t\t\tnext_cmd = CMD_GEN_STOP;\n\t\t}\n\t\tbreak;\n\tcase CMD_RET_DATA:\n\t\tif (i2c->line_status & LINESTAT_INPUT_HELD_V) {\n\t\t\t*i2c->msg.buf = (i2c->line_status &\n\t\t\t\t\t\tLINESTAT_INPUT_DATA)\n\t\t\t\t\t>> LINESTAT_INPUT_DATA_SHIFT;\n\t\t\t--i2c->msg.len;\n\t\t\t++i2c->msg.buf;\n\t\t\tif (i2c->msg.len)\n\t\t\t\tnext_cmd = CMD_GEN_ACK;\n\t\t\telse\n\t\t\t\tnext_cmd = CMD_GEN_NACK;\n\t\t}\n\t\tbreak;\n\tcase CMD_GEN_ACK:\n\t\tif (i2c->line_status & LINESTAT_ACK_DET) {\n\t\t\tnext_cmd = CMD_RET_DATA;\n\t\t} else {\n\t\t\ti2c->msg_status = -EIO;\n\t\t\tnext_cmd = CMD_GEN_STOP;\n\t\t}\n\t\tbreak;\n\tcase CMD_GEN_NACK:\n\t\tnext_cmd = CMD_GEN_STOP;\n\t\tbreak;\n\tcase CMD_GEN_STOP:\n\t\timg_i2c_writel(i2c, SCB_OVERRIDE_REG, 0);\n\t\treturn ISR_COMPLETE(0);\n\tdefault:\n\t\tdev_err(i2c->adap.dev.parent, \"bad atomic command %d\\n\",\n\t\t\ti2c->at_cur_cmd);\n\t\ti2c->msg_status = -EIO;\n\t\tnext_cmd = CMD_GEN_STOP;\n\t\tbreak;\n\t}\n\nnext_atomic_cmd:\n\tif (next_cmd != -1) {\n\t\t \n\t\tif (next_cmd == CMD_GEN_STOP && !i2c->msg_status &&\n\t\t\t\t\t\t!i2c->last_msg)\n\t\t\treturn ISR_COMPLETE(0);\n\t\timg_i2c_atomic_op(i2c, next_cmd, next_data);\n\t}\n\treturn 0;\n}\n\n \nstatic void img_i2c_check_timer(struct timer_list *t)\n{\n\tstruct img_i2c *i2c = from_timer(i2c, t, check_timer);\n\tunsigned long flags;\n\tunsigned int line_status;\n\n\tspin_lock_irqsave(&i2c->lock, flags);\n\tline_status = img_i2c_readl(i2c, SCB_STATUS_REG);\n\n\t \n\tif (line_status & LINESTAT_ABORT_DET) {\n\t\tdev_dbg(i2c->adap.dev.parent,\n\t\t\t\"abort condition detected by check timer\\n\");\n\t\t \n\t\timg_i2c_writel(i2c, SCB_INT_MASK_REG,\n\t\t\t       i2c->int_enable | INT_SLAVE_EVENT);\n\t}\n\n\tspin_unlock_irqrestore(&i2c->lock, flags);\n}\n\nstatic unsigned int img_i2c_auto(struct img_i2c *i2c,\n\t\t\t\t unsigned int int_status,\n\t\t\t\t unsigned int line_status)\n{\n\tif (int_status & (INT_WRITE_ACK_ERR | INT_ADDR_ACK_ERR))\n\t\treturn ISR_COMPLETE(EIO);\n\n\tif (line_status & LINESTAT_ABORT_DET) {\n\t\tdev_dbg(i2c->adap.dev.parent, \"abort condition detected\\n\");\n\t\t \n\t\tif ((i2c->msg.flags & I2C_M_RD) &&\n\t\t    (int_status & INT_FIFO_FULL_FILLING))\n\t\t\timg_i2c_read_fifo(i2c);\n\t\t \n\t\ti2c->msg_status = -EIO;\n\t\timg_i2c_stop_start(i2c);\n\t\treturn 0;\n\t}\n\n\t \n\tif (!i2c->last_msg && line_status & LINESTAT_START_BIT_DET) {\n\t\timg_i2c_transaction_halt(i2c, !i2c->last_msg);\n\t\t \n\t\ti2c->int_enable &= ~INT_SLAVE_EVENT;\n\t}\n\n\tmod_timer(&i2c->check_timer, jiffies + msecs_to_jiffies(1));\n\n\tif (int_status & INT_STOP_DETECTED) {\n\t\t \n\t\tif (i2c->msg.flags & I2C_M_RD)\n\t\t\timg_i2c_read_fifo(i2c);\n\t\treturn ISR_COMPLETE(0);\n\t}\n\n\tif (i2c->msg.flags & I2C_M_RD) {\n\t\tif (int_status & (INT_FIFO_FULL_FILLING | INT_MASTER_HALTED)) {\n\t\t\timg_i2c_read_fifo(i2c);\n\t\t\tif (i2c->msg.len == 0)\n\t\t\t\treturn ISR_WAITSTOP;\n\t\t}\n\t} else {\n\t\tif (int_status & (INT_FIFO_EMPTY | INT_MASTER_HALTED)) {\n\t\t\tif ((int_status & INT_FIFO_EMPTY) &&\n\t\t\t    i2c->msg.len == 0)\n\t\t\t\treturn ISR_WAITSTOP;\n\t\t\timg_i2c_write_fifo(i2c);\n\t\t}\n\t}\n\tif (int_status & INT_MASTER_HALTED) {\n\t\t \n\t\timg_i2c_transaction_halt(i2c, false);\n\t\timg_i2c_transaction_halt(i2c, !i2c->last_msg);\n\t}\n\n\treturn 0;\n}\n\nstatic irqreturn_t img_i2c_isr(int irq, void *dev_id)\n{\n\tstruct img_i2c *i2c = dev_id;\n\tu32 int_status, line_status;\n\t \n\tunsigned int hret;\n\n\t \n\tint_status = img_i2c_readl(i2c, SCB_INT_STATUS_REG);\n\t \n\timg_i2c_writel(i2c, SCB_INT_CLEAR_REG, int_status);\n\n\t \n\tline_status = img_i2c_readl(i2c, SCB_STATUS_REG);\n\tif (line_status & LINESTAT_LATCHED) {\n\t\timg_i2c_writel(i2c, SCB_CLEAR_REG,\n\t\t\t      (line_status & LINESTAT_LATCHED)\n\t\t\t\t>> LINESTAT_CLEAR_SHIFT);\n\t\timg_i2c_wr_rd_fence(i2c);\n\t}\n\n\tspin_lock(&i2c->lock);\n\n\t \n\ti2c->line_status &= ~LINESTAT_INPUT_DATA;\n\ti2c->line_status |= line_status;\n\n\t \n\tif ((int_status & INT_SCLK_LOW_TIMEOUT) &&\n\t    !(int_status & (INT_SLAVE_EVENT |\n\t\t\t    INT_FIFO_EMPTY |\n\t\t\t    INT_FIFO_FULL))) {\n\t\tdev_crit(i2c->adap.dev.parent,\n\t\t\t \"fatal: clock low timeout occurred %s addr 0x%02x\\n\",\n\t\t\t (i2c->msg.flags & I2C_M_RD) ? \"reading\" : \"writing\",\n\t\t\t i2c->msg.addr);\n\t\thret = ISR_FATAL(EIO);\n\t\tgoto out;\n\t}\n\n\tif (i2c->mode == MODE_ATOMIC)\n\t\thret = img_i2c_atomic(i2c, int_status, line_status);\n\telse if (i2c->mode == MODE_AUTOMATIC)\n\t\thret = img_i2c_auto(i2c, int_status, line_status);\n\telse if (i2c->mode == MODE_SEQUENCE)\n\t\thret = img_i2c_sequence(i2c, int_status);\n\telse if (i2c->mode == MODE_WAITSTOP && (int_status & INT_SLAVE_EVENT) &&\n\t\t\t (line_status & LINESTAT_STOP_BIT_DET))\n\t\thret = ISR_COMPLETE(0);\n\telse if (i2c->mode == MODE_RAW)\n\t\thret = img_i2c_raw(i2c, int_status, line_status);\n\telse\n\t\thret = 0;\n\n\t \n\timg_i2c_writel(i2c, SCB_INT_CLEAR_REG, int_status & INT_LEVEL);\n\nout:\n\tif (hret & ISR_WAITSTOP) {\n\t\t \n\t\tif (!i2c->last_msg || i2c->line_status & LINESTAT_STOP_BIT_DET)\n\t\t\thret = ISR_COMPLETE(0);\n\t\telse\n\t\t\timg_i2c_switch_mode(i2c, MODE_WAITSTOP);\n\t}\n\n\t \n\tif (hret & ISR_COMPLETE_M) {\n\t\tint status = -(hret & ISR_STATUS_M);\n\n\t\timg_i2c_complete_transaction(i2c, status);\n\t\tif (hret & ISR_FATAL_M)\n\t\t\timg_i2c_switch_mode(i2c, MODE_FATAL);\n\t}\n\n\t \n\timg_i2c_writel(i2c, SCB_INT_MASK_REG, i2c->int_enable);\n\n\tspin_unlock(&i2c->lock);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic int img_i2c_reset_bus(struct img_i2c *i2c)\n{\n\tunsigned long flags;\n\tunsigned long time_left;\n\n\tspin_lock_irqsave(&i2c->lock, flags);\n\treinit_completion(&i2c->msg_complete);\n\timg_i2c_reset_start(i2c);\n\tspin_unlock_irqrestore(&i2c->lock, flags);\n\n\ttime_left = wait_for_completion_timeout(&i2c->msg_complete,\n\t\t\t\t\t      IMG_I2C_TIMEOUT);\n\tif (time_left == 0)\n\t\treturn -ETIMEDOUT;\n\treturn 0;\n}\n\nstatic int img_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs,\n\t\t\tint num)\n{\n\tstruct img_i2c *i2c = i2c_get_adapdata(adap);\n\tbool atomic = false;\n\tint i, ret;\n\tunsigned long time_left;\n\n\tif (i2c->mode == MODE_SUSPEND) {\n\t\tWARN(1, \"refusing to service transaction in suspended state\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (i2c->mode == MODE_FATAL)\n\t\treturn -EIO;\n\n\tfor (i = 0; i < num; i++) {\n\t\t \n\t\tif (!msgs[i].len && msgs[i].flags & I2C_M_RD)\n\t\t\treturn -EIO;\n\t\t \n\t\tif (!msgs[i].len ||\n\t\t    (msgs[i].flags & I2C_M_IGNORE_NAK))\n\t\t\tatomic = true;\n\t}\n\n\tret = pm_runtime_resume_and_get(adap->dev.parent);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfor (i = 0; i < num; i++) {\n\t\tstruct i2c_msg *msg = &msgs[i];\n\t\tunsigned long flags;\n\n\t\tspin_lock_irqsave(&i2c->lock, flags);\n\n\t\t \n\t\ti2c->msg = *msg;\n\t\ti2c->msg_status = 0;\n\n\t\t \n\t\ti2c->last_msg = (i == num - 1);\n\t\treinit_completion(&i2c->msg_complete);\n\n\t\t \n\t\timg_i2c_writel(i2c, SCB_INT_CLEAR_REG, ~0);\n\t\timg_i2c_writel(i2c, SCB_CLEAR_REG, ~0);\n\n\t\tif (atomic) {\n\t\t\timg_i2c_atomic_start(i2c);\n\t\t} else {\n\t\t\t \n\t\t\timg_i2c_transaction_halt(i2c, !i2c->last_msg);\n\n\t\t\tif (msg->flags & I2C_M_RD)\n\t\t\t\timg_i2c_read(i2c);\n\t\t\telse\n\t\t\t\timg_i2c_write(i2c);\n\n\t\t\t \n\t\t\timg_i2c_transaction_halt(i2c, false);\n\t\t\timg_i2c_transaction_halt(i2c, !i2c->last_msg);\n\t\t}\n\t\tspin_unlock_irqrestore(&i2c->lock, flags);\n\n\t\ttime_left = wait_for_completion_timeout(&i2c->msg_complete,\n\t\t\t\t\t\t      IMG_I2C_TIMEOUT);\n\t\tdel_timer_sync(&i2c->check_timer);\n\n\t\tif (time_left == 0) {\n\t\t\tdev_err(adap->dev.parent, \"i2c transfer timed out\\n\");\n\t\t\ti2c->msg_status = -ETIMEDOUT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (i2c->msg_status)\n\t\t\tbreak;\n\t}\n\n\tpm_runtime_mark_last_busy(adap->dev.parent);\n\tpm_runtime_put_autosuspend(adap->dev.parent);\n\n\treturn i2c->msg_status ? i2c->msg_status : num;\n}\n\nstatic u32 img_i2c_func(struct i2c_adapter *adap)\n{\n\treturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;\n}\n\nstatic const struct i2c_algorithm img_i2c_algo = {\n\t.master_xfer = img_i2c_xfer,\n\t.functionality = img_i2c_func,\n};\n\nstatic int img_i2c_init(struct img_i2c *i2c)\n{\n\tunsigned int clk_khz, bitrate_khz, clk_period, tckh, tckl, tsdh;\n\tunsigned int i, data, prescale, inc, int_bitrate, filt;\n\tstruct img_i2c_timings timing;\n\tu32 rev;\n\tint ret;\n\n\tret = pm_runtime_resume_and_get(i2c->adap.dev.parent);\n\tif (ret < 0)\n\t\treturn ret;\n\n\trev = img_i2c_readl(i2c, SCB_CORE_REV_REG);\n\tif ((rev & 0x00ffffff) < 0x00020200) {\n\t\tdev_info(i2c->adap.dev.parent,\n\t\t\t \"Unknown hardware revision (%d.%d.%d.%d)\\n\",\n\t\t\t (rev >> 24) & 0xff, (rev >> 16) & 0xff,\n\t\t\t (rev >> 8) & 0xff, rev & 0xff);\n\t\tpm_runtime_mark_last_busy(i2c->adap.dev.parent);\n\t\tpm_runtime_put_autosuspend(i2c->adap.dev.parent);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\ti2c->need_wr_rd_fence = true;\n\n\t \n\ttiming = timings[0];\n\tfor (i = 0; i < ARRAY_SIZE(timings); i++) {\n\t\tif (i2c->bitrate <= timings[i].max_bitrate) {\n\t\t\ttiming = timings[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i2c->bitrate > timings[ARRAY_SIZE(timings) - 1].max_bitrate) {\n\t\tdev_warn(i2c->adap.dev.parent,\n\t\t\t \"requested bitrate (%u) is higher than the max bitrate supported (%u)\\n\",\n\t\t\t i2c->bitrate,\n\t\t\t timings[ARRAY_SIZE(timings) - 1].max_bitrate);\n\t\ttiming = timings[ARRAY_SIZE(timings) - 1];\n\t\ti2c->bitrate = timing.max_bitrate;\n\t}\n\n\tbitrate_khz = i2c->bitrate / 1000;\n\tclk_khz = clk_get_rate(i2c->scb_clk) / 1000;\n\n\t \n\tprescale = SCB_OPT_INC * clk_khz / (256 * 16 * bitrate_khz);\n\tprescale = clamp_t(unsigned int, prescale, 1, 8);\n\tclk_khz /= prescale;\n\n\t \n\tinc = (256 * 16 * bitrate_khz) / clk_khz;\n\n\t \n\tif (clk_khz < 20000) {\n\t\tfilt = SCB_FILT_DISABLE;\n\t} else if (clk_khz < 40000) {\n\t\tfilt = SCB_FILT_BYPASS;\n\t} else {\n\t\t \n\t\tfilt = (64000 / ((clk_khz / 1000) * SCB_FILT_GLITCH));\n\n\t\t \n\t\tif (64000 % ((clk_khz / 1000) * SCB_FILT_GLITCH))\n\t\t\tinc++;\n\n\t\tif (filt > SCB_FILT_INC_MASK)\n\t\t\tfilt = SCB_FILT_INC_MASK;\n\n\t\tfilt = (filt & SCB_FILT_INC_MASK) << SCB_FILT_INC_SHIFT;\n\t}\n\tdata = filt | ((inc & SCB_INC_MASK) << SCB_INC_SHIFT) | (prescale - 1);\n\timg_i2c_writel(i2c, SCB_CLK_SET_REG, data);\n\n\t \n\tclk_period = (256 * 1000000) / (clk_khz * inc);\n\n\t \n\tint_bitrate = 1000000 / (bitrate_khz * clk_period);\n\tif ((1000000 % (bitrate_khz * clk_period)) >=\n\t    ((bitrate_khz * clk_period) / 2))\n\t\tint_bitrate++;\n\n\t \n\ttckh = int_bitrate / 2;\n\ttckl = int_bitrate - tckh;\n\n\t \n\tdata = DIV_ROUND_UP(timing.tckl, clk_period);\n\n\tif (tckl < data) {\n\t\ttckl = data;\n\t\ttckh = int_bitrate - tckl;\n\t}\n\n\tif (tckh > 0)\n\t\t--tckh;\n\n\tif (tckl > 0)\n\t\t--tckl;\n\n\timg_i2c_writel(i2c, SCB_TIME_TCKH_REG, tckh);\n\timg_i2c_writel(i2c, SCB_TIME_TCKL_REG, tckl);\n\n\t \n\ttsdh = DIV_ROUND_UP(timing.tsdh, clk_period);\n\n\tif (tsdh > 1)\n\t\tdata = tsdh - 1;\n\telse\n\t\tdata = 0x01;\n\timg_i2c_writel(i2c, SCB_TIME_TSDH_REG, data);\n\n\t \n\ttsdh = data;\n\n\t \n\tdata = timing.tpl / clk_period;\n\tif (data > 0)\n\t\t--data;\n\timg_i2c_writel(i2c, SCB_TIME_TPL_REG, data);\n\n\t \n\tdata = timing.tph / clk_period;\n\tif (data > 0)\n\t\t--data;\n\timg_i2c_writel(i2c, SCB_TIME_TPH_REG, data);\n\n\t \n\timg_i2c_writel(i2c, SCB_TIME_TSDL_REG, data + tsdh + 2);\n\n\t \n\tdata = timing.tp2s / clk_period;\n\tif (data > 0)\n\t\t--data;\n\timg_i2c_writel(i2c, SCB_TIME_TP2S_REG, data);\n\n\timg_i2c_writel(i2c, SCB_TIME_TBI_REG, TIMEOUT_TBI);\n\timg_i2c_writel(i2c, SCB_TIME_TSL_REG, TIMEOUT_TSL);\n\timg_i2c_writel(i2c, SCB_TIME_TDL_REG, TIMEOUT_TDL);\n\n\t \n\timg_i2c_soft_reset(i2c);\n\n\t \n\timg_i2c_writel(i2c, SCB_INT_MASK_REG, 0);\n\n\t \n\timg_i2c_writel(i2c, SCB_INT_CLEAR_REG, ~0);\n\n\t \n\timg_i2c_writel(i2c, SCB_CLEAR_REG, ~0);\n\n\t \n\timg_i2c_writel(i2c, SCB_INT_MASK_REG, i2c->int_enable);\n\n\t \n\tret = img_i2c_reset_bus(i2c);\n\n\tpm_runtime_mark_last_busy(i2c->adap.dev.parent);\n\tpm_runtime_put_autosuspend(i2c->adap.dev.parent);\n\n\treturn ret;\n}\n\nstatic int img_i2c_probe(struct platform_device *pdev)\n{\n\tstruct device_node *node = pdev->dev.of_node;\n\tstruct img_i2c *i2c;\n\tint irq, ret;\n\tu32 val;\n\n\ti2c = devm_kzalloc(&pdev->dev, sizeof(struct img_i2c), GFP_KERNEL);\n\tif (!i2c)\n\t\treturn -ENOMEM;\n\n\ti2c->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(i2c->base))\n\t\treturn PTR_ERR(i2c->base);\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\ti2c->sys_clk = devm_clk_get(&pdev->dev, \"sys\");\n\tif (IS_ERR(i2c->sys_clk)) {\n\t\tdev_err(&pdev->dev, \"can't get system clock\\n\");\n\t\treturn PTR_ERR(i2c->sys_clk);\n\t}\n\n\ti2c->scb_clk = devm_clk_get(&pdev->dev, \"scb\");\n\tif (IS_ERR(i2c->scb_clk)) {\n\t\tdev_err(&pdev->dev, \"can't get core clock\\n\");\n\t\treturn PTR_ERR(i2c->scb_clk);\n\t}\n\n\tret = devm_request_irq(&pdev->dev, irq, img_i2c_isr, 0,\n\t\t\t       pdev->name, i2c);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"can't request irq %d\\n\", irq);\n\t\treturn ret;\n\t}\n\n\t \n\ttimer_setup(&i2c->check_timer, img_i2c_check_timer, 0);\n\n\ti2c->bitrate = timings[0].max_bitrate;\n\tif (!of_property_read_u32(node, \"clock-frequency\", &val))\n\t\ti2c->bitrate = val;\n\n\ti2c_set_adapdata(&i2c->adap, i2c);\n\ti2c->adap.dev.parent = &pdev->dev;\n\ti2c->adap.dev.of_node = node;\n\ti2c->adap.owner = THIS_MODULE;\n\ti2c->adap.algo = &img_i2c_algo;\n\ti2c->adap.retries = 5;\n\ti2c->adap.nr = pdev->id;\n\tsnprintf(i2c->adap.name, sizeof(i2c->adap.name), \"IMG SCB I2C\");\n\n\timg_i2c_switch_mode(i2c, MODE_INACTIVE);\n\tspin_lock_init(&i2c->lock);\n\tinit_completion(&i2c->msg_complete);\n\n\tplatform_set_drvdata(pdev, i2c);\n\n\tpm_runtime_set_autosuspend_delay(&pdev->dev, IMG_I2C_PM_TIMEOUT);\n\tpm_runtime_use_autosuspend(&pdev->dev);\n\tpm_runtime_enable(&pdev->dev);\n\tif (!pm_runtime_enabled(&pdev->dev)) {\n\t\tret = img_i2c_runtime_resume(&pdev->dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = img_i2c_init(i2c);\n\tif (ret)\n\t\tgoto rpm_disable;\n\n\tret = i2c_add_numbered_adapter(&i2c->adap);\n\tif (ret < 0)\n\t\tgoto rpm_disable;\n\n\treturn 0;\n\nrpm_disable:\n\tif (!pm_runtime_enabled(&pdev->dev))\n\t\timg_i2c_runtime_suspend(&pdev->dev);\n\tpm_runtime_disable(&pdev->dev);\n\tpm_runtime_dont_use_autosuspend(&pdev->dev);\n\treturn ret;\n}\n\nstatic void img_i2c_remove(struct platform_device *dev)\n{\n\tstruct img_i2c *i2c = platform_get_drvdata(dev);\n\n\ti2c_del_adapter(&i2c->adap);\n\tpm_runtime_disable(&dev->dev);\n\tif (!pm_runtime_status_suspended(&dev->dev))\n\t\timg_i2c_runtime_suspend(&dev->dev);\n}\n\nstatic int img_i2c_runtime_suspend(struct device *dev)\n{\n\tstruct img_i2c *i2c = dev_get_drvdata(dev);\n\n\tclk_disable_unprepare(i2c->scb_clk);\n\tclk_disable_unprepare(i2c->sys_clk);\n\n\treturn 0;\n}\n\nstatic int img_i2c_runtime_resume(struct device *dev)\n{\n\tstruct img_i2c *i2c = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = clk_prepare_enable(i2c->sys_clk);\n\tif (ret) {\n\t\tdev_err(dev, \"Unable to enable sys clock\\n\");\n\t\treturn ret;\n\t}\n\n\tret = clk_prepare_enable(i2c->scb_clk);\n\tif (ret) {\n\t\tdev_err(dev, \"Unable to enable scb clock\\n\");\n\t\tclk_disable_unprepare(i2c->sys_clk);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int img_i2c_suspend(struct device *dev)\n{\n\tstruct img_i2c *i2c = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = pm_runtime_force_suspend(dev);\n\tif (ret)\n\t\treturn ret;\n\n\timg_i2c_switch_mode(i2c, MODE_SUSPEND);\n\n\treturn 0;\n}\n\nstatic int img_i2c_resume(struct device *dev)\n{\n\tstruct img_i2c *i2c = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = pm_runtime_force_resume(dev);\n\tif (ret)\n\t\treturn ret;\n\n\timg_i2c_init(i2c);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops img_i2c_pm = {\n\tRUNTIME_PM_OPS(img_i2c_runtime_suspend, img_i2c_runtime_resume, NULL)\n\tSYSTEM_SLEEP_PM_OPS(img_i2c_suspend, img_i2c_resume)\n};\n\nstatic const struct of_device_id img_scb_i2c_match[] = {\n\t{ .compatible = \"img,scb-i2c\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, img_scb_i2c_match);\n\nstatic struct platform_driver img_scb_i2c_driver = {\n\t.driver = {\n\t\t.name\t\t= \"img-i2c-scb\",\n\t\t.of_match_table\t= img_scb_i2c_match,\n\t\t.pm\t\t= pm_ptr(&img_i2c_pm),\n\t},\n\t.probe = img_i2c_probe,\n\t.remove_new = img_i2c_remove,\n};\nmodule_platform_driver(img_scb_i2c_driver);\n\nMODULE_AUTHOR(\"James Hogan <jhogan@kernel.org>\");\nMODULE_DESCRIPTION(\"IMG host I2C driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}