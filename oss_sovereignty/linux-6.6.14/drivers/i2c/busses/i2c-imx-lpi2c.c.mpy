{
  "module_name": "i2c-imx-lpi2c.c",
  "hash_id": "3683c2a999060a930097286f986e6558f2c6651abe1e5c9a4b9dfcd3599ad295",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-imx-lpi2c.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/i2c.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\n#define DRIVER_NAME \"imx-lpi2c\"\n\n#define LPI2C_PARAM\t0x04\t \n#define LPI2C_MCR\t0x10\t \n#define LPI2C_MSR\t0x14\t \n#define LPI2C_MIER\t0x18\t \n#define LPI2C_MCFGR0\t0x20\t \n#define LPI2C_MCFGR1\t0x24\t \n#define LPI2C_MCFGR2\t0x28\t \n#define LPI2C_MCFGR3\t0x2C\t \n#define LPI2C_MCCR0\t0x48\t \n#define LPI2C_MCCR1\t0x50\t \n#define LPI2C_MFCR\t0x58\t \n#define LPI2C_MFSR\t0x5C\t \n#define LPI2C_MTDR\t0x60\t \n#define LPI2C_MRDR\t0x70\t \n\n \n#define TRAN_DATA\t0X00\n#define RECV_DATA\t0X01\n#define GEN_STOP\t0X02\n#define RECV_DISCARD\t0X03\n#define GEN_START\t0X04\n#define START_NACK\t0X05\n#define START_HIGH\t0X06\n#define START_HIGH_NACK\t0X07\n\n#define MCR_MEN\t\tBIT(0)\n#define MCR_RST\t\tBIT(1)\n#define MCR_DOZEN\tBIT(2)\n#define MCR_DBGEN\tBIT(3)\n#define MCR_RTF\t\tBIT(8)\n#define MCR_RRF\t\tBIT(9)\n#define MSR_TDF\t\tBIT(0)\n#define MSR_RDF\t\tBIT(1)\n#define MSR_SDF\t\tBIT(9)\n#define MSR_NDF\t\tBIT(10)\n#define MSR_ALF\t\tBIT(11)\n#define MSR_MBF\t\tBIT(24)\n#define MSR_BBF\t\tBIT(25)\n#define MIER_TDIE\tBIT(0)\n#define MIER_RDIE\tBIT(1)\n#define MIER_SDIE\tBIT(9)\n#define MIER_NDIE\tBIT(10)\n#define MCFGR1_AUTOSTOP\tBIT(8)\n#define MCFGR1_IGNACK\tBIT(9)\n#define MRDR_RXEMPTY\tBIT(14)\n\n#define I2C_CLK_RATIO\t2\n#define CHUNK_DATA\t256\n\n#define I2C_PM_TIMEOUT\t\t10  \n\nenum lpi2c_imx_mode {\n\tSTANDARD,\t \n\tFAST,\t\t \n\tFAST_PLUS,\t \n\tHS,\t\t \n\tULTRA_FAST,\t \n};\n\nenum lpi2c_imx_pincfg {\n\tTWO_PIN_OD,\n\tTWO_PIN_OO,\n\tTWO_PIN_PP,\n\tFOUR_PIN_PP,\n};\n\nstruct lpi2c_imx_struct {\n\tstruct i2c_adapter\tadapter;\n\tint\t\t\tnum_clks;\n\tstruct clk_bulk_data\t*clks;\n\tvoid __iomem\t\t*base;\n\t__u8\t\t\t*rx_buf;\n\t__u8\t\t\t*tx_buf;\n\tstruct completion\tcomplete;\n\tunsigned int\t\tmsglen;\n\tunsigned int\t\tdelivered;\n\tunsigned int\t\tblock_data;\n\tunsigned int\t\tbitrate;\n\tunsigned int\t\ttxfifosize;\n\tunsigned int\t\trxfifosize;\n\tenum lpi2c_imx_mode\tmode;\n};\n\nstatic void lpi2c_imx_intctrl(struct lpi2c_imx_struct *lpi2c_imx,\n\t\t\t      unsigned int enable)\n{\n\twritel(enable, lpi2c_imx->base + LPI2C_MIER);\n}\n\nstatic int lpi2c_imx_bus_busy(struct lpi2c_imx_struct *lpi2c_imx)\n{\n\tunsigned long orig_jiffies = jiffies;\n\tunsigned int temp;\n\n\twhile (1) {\n\t\ttemp = readl(lpi2c_imx->base + LPI2C_MSR);\n\n\t\t \n\t\tif (temp & MSR_ALF) {\n\t\t\twritel(temp, lpi2c_imx->base + LPI2C_MSR);\n\t\t\treturn -EAGAIN;\n\t\t}\n\n\t\tif (temp & (MSR_BBF | MSR_MBF))\n\t\t\tbreak;\n\n\t\tif (time_after(jiffies, orig_jiffies + msecs_to_jiffies(500))) {\n\t\t\tdev_dbg(&lpi2c_imx->adapter.dev, \"bus not work\\n\");\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t\tschedule();\n\t}\n\n\treturn 0;\n}\n\nstatic void lpi2c_imx_set_mode(struct lpi2c_imx_struct *lpi2c_imx)\n{\n\tunsigned int bitrate = lpi2c_imx->bitrate;\n\tenum lpi2c_imx_mode mode;\n\n\tif (bitrate < I2C_MAX_FAST_MODE_FREQ)\n\t\tmode = STANDARD;\n\telse if (bitrate < I2C_MAX_FAST_MODE_PLUS_FREQ)\n\t\tmode = FAST;\n\telse if (bitrate < I2C_MAX_HIGH_SPEED_MODE_FREQ)\n\t\tmode = FAST_PLUS;\n\telse if (bitrate < I2C_MAX_ULTRA_FAST_MODE_FREQ)\n\t\tmode = HS;\n\telse\n\t\tmode = ULTRA_FAST;\n\n\tlpi2c_imx->mode = mode;\n}\n\nstatic int lpi2c_imx_start(struct lpi2c_imx_struct *lpi2c_imx,\n\t\t\t   struct i2c_msg *msgs)\n{\n\tunsigned int temp;\n\n\ttemp = readl(lpi2c_imx->base + LPI2C_MCR);\n\ttemp |= MCR_RRF | MCR_RTF;\n\twritel(temp, lpi2c_imx->base + LPI2C_MCR);\n\twritel(0x7f00, lpi2c_imx->base + LPI2C_MSR);\n\n\ttemp = i2c_8bit_addr_from_msg(msgs) | (GEN_START << 8);\n\twritel(temp, lpi2c_imx->base + LPI2C_MTDR);\n\n\treturn lpi2c_imx_bus_busy(lpi2c_imx);\n}\n\nstatic void lpi2c_imx_stop(struct lpi2c_imx_struct *lpi2c_imx)\n{\n\tunsigned long orig_jiffies = jiffies;\n\tunsigned int temp;\n\n\twritel(GEN_STOP << 8, lpi2c_imx->base + LPI2C_MTDR);\n\n\tdo {\n\t\ttemp = readl(lpi2c_imx->base + LPI2C_MSR);\n\t\tif (temp & MSR_SDF)\n\t\t\tbreak;\n\n\t\tif (time_after(jiffies, orig_jiffies + msecs_to_jiffies(500))) {\n\t\t\tdev_dbg(&lpi2c_imx->adapter.dev, \"stop timeout\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tschedule();\n\n\t} while (1);\n}\n\n \nstatic int lpi2c_imx_config(struct lpi2c_imx_struct *lpi2c_imx)\n{\n\tu8 prescale, filt, sethold, datavd;\n\tunsigned int clk_rate, clk_cycle, clkhi, clklo;\n\tenum lpi2c_imx_pincfg pincfg;\n\tunsigned int temp;\n\n\tlpi2c_imx_set_mode(lpi2c_imx);\n\n\tclk_rate = clk_get_rate(lpi2c_imx->clks[0].clk);\n\tif (!clk_rate)\n\t\treturn -EINVAL;\n\n\tif (lpi2c_imx->mode == HS || lpi2c_imx->mode == ULTRA_FAST)\n\t\tfilt = 0;\n\telse\n\t\tfilt = 2;\n\n\tfor (prescale = 0; prescale <= 7; prescale++) {\n\t\tclk_cycle = clk_rate / ((1 << prescale) * lpi2c_imx->bitrate)\n\t\t\t    - 3 - (filt >> 1);\n\t\tclkhi = DIV_ROUND_UP(clk_cycle, I2C_CLK_RATIO + 1);\n\t\tclklo = clk_cycle - clkhi;\n\t\tif (clklo < 64)\n\t\t\tbreak;\n\t}\n\n\tif (prescale > 7)\n\t\treturn -EINVAL;\n\n\t \n\tif (lpi2c_imx->mode == ULTRA_FAST)\n\t\tpincfg = TWO_PIN_OO;\n\telse\n\t\tpincfg = TWO_PIN_OD;\n\ttemp = prescale | pincfg << 24;\n\n\tif (lpi2c_imx->mode == ULTRA_FAST)\n\t\ttemp |= MCFGR1_IGNACK;\n\n\twritel(temp, lpi2c_imx->base + LPI2C_MCFGR1);\n\n\t \n\ttemp = (filt << 16) | (filt << 24);\n\twritel(temp, lpi2c_imx->base + LPI2C_MCFGR2);\n\n\t \n\tsethold = clkhi;\n\tdatavd = clkhi >> 1;\n\ttemp = datavd << 24 | sethold << 16 | clkhi << 8 | clklo;\n\n\tif (lpi2c_imx->mode == HS)\n\t\twritel(temp, lpi2c_imx->base + LPI2C_MCCR1);\n\telse\n\t\twritel(temp, lpi2c_imx->base + LPI2C_MCCR0);\n\n\treturn 0;\n}\n\nstatic int lpi2c_imx_master_enable(struct lpi2c_imx_struct *lpi2c_imx)\n{\n\tunsigned int temp;\n\tint ret;\n\n\tret = pm_runtime_resume_and_get(lpi2c_imx->adapter.dev.parent);\n\tif (ret < 0)\n\t\treturn ret;\n\n\ttemp = MCR_RST;\n\twritel(temp, lpi2c_imx->base + LPI2C_MCR);\n\twritel(0, lpi2c_imx->base + LPI2C_MCR);\n\n\tret = lpi2c_imx_config(lpi2c_imx);\n\tif (ret)\n\t\tgoto rpm_put;\n\n\ttemp = readl(lpi2c_imx->base + LPI2C_MCR);\n\ttemp |= MCR_MEN;\n\twritel(temp, lpi2c_imx->base + LPI2C_MCR);\n\n\treturn 0;\n\nrpm_put:\n\tpm_runtime_mark_last_busy(lpi2c_imx->adapter.dev.parent);\n\tpm_runtime_put_autosuspend(lpi2c_imx->adapter.dev.parent);\n\n\treturn ret;\n}\n\nstatic int lpi2c_imx_master_disable(struct lpi2c_imx_struct *lpi2c_imx)\n{\n\tu32 temp;\n\n\ttemp = readl(lpi2c_imx->base + LPI2C_MCR);\n\ttemp &= ~MCR_MEN;\n\twritel(temp, lpi2c_imx->base + LPI2C_MCR);\n\n\tpm_runtime_mark_last_busy(lpi2c_imx->adapter.dev.parent);\n\tpm_runtime_put_autosuspend(lpi2c_imx->adapter.dev.parent);\n\n\treturn 0;\n}\n\nstatic int lpi2c_imx_msg_complete(struct lpi2c_imx_struct *lpi2c_imx)\n{\n\tunsigned long timeout;\n\n\ttimeout = wait_for_completion_timeout(&lpi2c_imx->complete, HZ);\n\n\treturn timeout ? 0 : -ETIMEDOUT;\n}\n\nstatic int lpi2c_imx_txfifo_empty(struct lpi2c_imx_struct *lpi2c_imx)\n{\n\tunsigned long orig_jiffies = jiffies;\n\tu32 txcnt;\n\n\tdo {\n\t\ttxcnt = readl(lpi2c_imx->base + LPI2C_MFSR) & 0xff;\n\n\t\tif (readl(lpi2c_imx->base + LPI2C_MSR) & MSR_NDF) {\n\t\t\tdev_dbg(&lpi2c_imx->adapter.dev, \"NDF detected\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tif (time_after(jiffies, orig_jiffies + msecs_to_jiffies(500))) {\n\t\t\tdev_dbg(&lpi2c_imx->adapter.dev, \"txfifo empty timeout\\n\");\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t\tschedule();\n\n\t} while (txcnt);\n\n\treturn 0;\n}\n\nstatic void lpi2c_imx_set_tx_watermark(struct lpi2c_imx_struct *lpi2c_imx)\n{\n\twritel(lpi2c_imx->txfifosize >> 1, lpi2c_imx->base + LPI2C_MFCR);\n}\n\nstatic void lpi2c_imx_set_rx_watermark(struct lpi2c_imx_struct *lpi2c_imx)\n{\n\tunsigned int temp, remaining;\n\n\tremaining = lpi2c_imx->msglen - lpi2c_imx->delivered;\n\n\tif (remaining > (lpi2c_imx->rxfifosize >> 1))\n\t\ttemp = lpi2c_imx->rxfifosize >> 1;\n\telse\n\t\ttemp = 0;\n\n\twritel(temp << 16, lpi2c_imx->base + LPI2C_MFCR);\n}\n\nstatic void lpi2c_imx_write_txfifo(struct lpi2c_imx_struct *lpi2c_imx)\n{\n\tunsigned int data, txcnt;\n\n\ttxcnt = readl(lpi2c_imx->base + LPI2C_MFSR) & 0xff;\n\n\twhile (txcnt < lpi2c_imx->txfifosize) {\n\t\tif (lpi2c_imx->delivered == lpi2c_imx->msglen)\n\t\t\tbreak;\n\n\t\tdata = lpi2c_imx->tx_buf[lpi2c_imx->delivered++];\n\t\twritel(data, lpi2c_imx->base + LPI2C_MTDR);\n\t\ttxcnt++;\n\t}\n\n\tif (lpi2c_imx->delivered < lpi2c_imx->msglen)\n\t\tlpi2c_imx_intctrl(lpi2c_imx, MIER_TDIE | MIER_NDIE);\n\telse\n\t\tcomplete(&lpi2c_imx->complete);\n}\n\nstatic void lpi2c_imx_read_rxfifo(struct lpi2c_imx_struct *lpi2c_imx)\n{\n\tunsigned int blocklen, remaining;\n\tunsigned int temp, data;\n\n\tdo {\n\t\tdata = readl(lpi2c_imx->base + LPI2C_MRDR);\n\t\tif (data & MRDR_RXEMPTY)\n\t\t\tbreak;\n\n\t\tlpi2c_imx->rx_buf[lpi2c_imx->delivered++] = data & 0xff;\n\t} while (1);\n\n\t \n\tif (lpi2c_imx->block_data) {\n\t\tblocklen = lpi2c_imx->rx_buf[0];\n\t\tlpi2c_imx->msglen += blocklen;\n\t}\n\n\tremaining = lpi2c_imx->msglen - lpi2c_imx->delivered;\n\n\tif (!remaining) {\n\t\tcomplete(&lpi2c_imx->complete);\n\t\treturn;\n\t}\n\n\t \n\tlpi2c_imx_set_rx_watermark(lpi2c_imx);\n\n\t \n\tif (lpi2c_imx->block_data) {\n\t\tlpi2c_imx->block_data = 0;\n\t\ttemp = remaining;\n\t\ttemp |= (RECV_DATA << 8);\n\t\twritel(temp, lpi2c_imx->base + LPI2C_MTDR);\n\t} else if (!(lpi2c_imx->delivered & 0xff)) {\n\t\ttemp = (remaining > CHUNK_DATA ? CHUNK_DATA : remaining) - 1;\n\t\ttemp |= (RECV_DATA << 8);\n\t\twritel(temp, lpi2c_imx->base + LPI2C_MTDR);\n\t}\n\n\tlpi2c_imx_intctrl(lpi2c_imx, MIER_RDIE);\n}\n\nstatic void lpi2c_imx_write(struct lpi2c_imx_struct *lpi2c_imx,\n\t\t\t    struct i2c_msg *msgs)\n{\n\tlpi2c_imx->tx_buf = msgs->buf;\n\tlpi2c_imx_set_tx_watermark(lpi2c_imx);\n\tlpi2c_imx_write_txfifo(lpi2c_imx);\n}\n\nstatic void lpi2c_imx_read(struct lpi2c_imx_struct *lpi2c_imx,\n\t\t\t   struct i2c_msg *msgs)\n{\n\tunsigned int temp;\n\n\tlpi2c_imx->rx_buf = msgs->buf;\n\tlpi2c_imx->block_data = msgs->flags & I2C_M_RECV_LEN;\n\n\tlpi2c_imx_set_rx_watermark(lpi2c_imx);\n\ttemp = msgs->len > CHUNK_DATA ? CHUNK_DATA - 1 : msgs->len - 1;\n\ttemp |= (RECV_DATA << 8);\n\twritel(temp, lpi2c_imx->base + LPI2C_MTDR);\n\n\tlpi2c_imx_intctrl(lpi2c_imx, MIER_RDIE | MIER_NDIE);\n}\n\nstatic int lpi2c_imx_xfer(struct i2c_adapter *adapter,\n\t\t\t  struct i2c_msg *msgs, int num)\n{\n\tstruct lpi2c_imx_struct *lpi2c_imx = i2c_get_adapdata(adapter);\n\tunsigned int temp;\n\tint i, result;\n\n\tresult = lpi2c_imx_master_enable(lpi2c_imx);\n\tif (result)\n\t\treturn result;\n\n\tfor (i = 0; i < num; i++) {\n\t\tresult = lpi2c_imx_start(lpi2c_imx, &msgs[i]);\n\t\tif (result)\n\t\t\tgoto disable;\n\n\t\t \n\t\tif (num == 1 && msgs[0].len == 0)\n\t\t\tgoto stop;\n\n\t\tlpi2c_imx->rx_buf = NULL;\n\t\tlpi2c_imx->tx_buf = NULL;\n\t\tlpi2c_imx->delivered = 0;\n\t\tlpi2c_imx->msglen = msgs[i].len;\n\t\tinit_completion(&lpi2c_imx->complete);\n\n\t\tif (msgs[i].flags & I2C_M_RD)\n\t\t\tlpi2c_imx_read(lpi2c_imx, &msgs[i]);\n\t\telse\n\t\t\tlpi2c_imx_write(lpi2c_imx, &msgs[i]);\n\n\t\tresult = lpi2c_imx_msg_complete(lpi2c_imx);\n\t\tif (result)\n\t\t\tgoto stop;\n\n\t\tif (!(msgs[i].flags & I2C_M_RD)) {\n\t\t\tresult = lpi2c_imx_txfifo_empty(lpi2c_imx);\n\t\t\tif (result)\n\t\t\t\tgoto stop;\n\t\t}\n\t}\n\nstop:\n\tlpi2c_imx_stop(lpi2c_imx);\n\n\ttemp = readl(lpi2c_imx->base + LPI2C_MSR);\n\tif ((temp & MSR_NDF) && !result)\n\t\tresult = -EIO;\n\ndisable:\n\tlpi2c_imx_master_disable(lpi2c_imx);\n\n\tdev_dbg(&lpi2c_imx->adapter.dev, \"<%s> exit with: %s: %d\\n\", __func__,\n\t\t(result < 0) ? \"error\" : \"success msg\",\n\t\t(result < 0) ? result : num);\n\n\treturn (result < 0) ? result : num;\n}\n\nstatic irqreturn_t lpi2c_imx_isr(int irq, void *dev_id)\n{\n\tstruct lpi2c_imx_struct *lpi2c_imx = dev_id;\n\tunsigned int enabled;\n\tunsigned int temp;\n\n\tenabled = readl(lpi2c_imx->base + LPI2C_MIER);\n\n\tlpi2c_imx_intctrl(lpi2c_imx, 0);\n\ttemp = readl(lpi2c_imx->base + LPI2C_MSR);\n\ttemp &= enabled;\n\n\tif (temp & MSR_NDF)\n\t\tcomplete(&lpi2c_imx->complete);\n\telse if (temp & MSR_RDF)\n\t\tlpi2c_imx_read_rxfifo(lpi2c_imx);\n\telse if (temp & MSR_TDF)\n\t\tlpi2c_imx_write_txfifo(lpi2c_imx);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic u32 lpi2c_imx_func(struct i2c_adapter *adapter)\n{\n\treturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL |\n\t\tI2C_FUNC_SMBUS_READ_BLOCK_DATA;\n}\n\nstatic const struct i2c_algorithm lpi2c_imx_algo = {\n\t.master_xfer\t= lpi2c_imx_xfer,\n\t.functionality\t= lpi2c_imx_func,\n};\n\nstatic const struct of_device_id lpi2c_imx_of_match[] = {\n\t{ .compatible = \"fsl,imx7ulp-lpi2c\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, lpi2c_imx_of_match);\n\nstatic int lpi2c_imx_probe(struct platform_device *pdev)\n{\n\tstruct lpi2c_imx_struct *lpi2c_imx;\n\tunsigned int temp;\n\tint irq, ret;\n\n\tlpi2c_imx = devm_kzalloc(&pdev->dev, sizeof(*lpi2c_imx), GFP_KERNEL);\n\tif (!lpi2c_imx)\n\t\treturn -ENOMEM;\n\n\tlpi2c_imx->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(lpi2c_imx->base))\n\t\treturn PTR_ERR(lpi2c_imx->base);\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tlpi2c_imx->adapter.owner\t= THIS_MODULE;\n\tlpi2c_imx->adapter.algo\t\t= &lpi2c_imx_algo;\n\tlpi2c_imx->adapter.dev.parent\t= &pdev->dev;\n\tlpi2c_imx->adapter.dev.of_node\t= pdev->dev.of_node;\n\tstrscpy(lpi2c_imx->adapter.name, pdev->name,\n\t\tsizeof(lpi2c_imx->adapter.name));\n\n\tret = devm_clk_bulk_get_all(&pdev->dev, &lpi2c_imx->clks);\n\tif (ret < 0)\n\t\treturn dev_err_probe(&pdev->dev, ret, \"can't get I2C peripheral clock\\n\");\n\tlpi2c_imx->num_clks = ret;\n\n\tret = of_property_read_u32(pdev->dev.of_node,\n\t\t\t\t   \"clock-frequency\", &lpi2c_imx->bitrate);\n\tif (ret)\n\t\tlpi2c_imx->bitrate = I2C_MAX_STANDARD_MODE_FREQ;\n\n\tret = devm_request_irq(&pdev->dev, irq, lpi2c_imx_isr, 0,\n\t\t\t       pdev->name, lpi2c_imx);\n\tif (ret)\n\t\treturn dev_err_probe(&pdev->dev, ret, \"can't claim irq %d\\n\", irq);\n\n\ti2c_set_adapdata(&lpi2c_imx->adapter, lpi2c_imx);\n\tplatform_set_drvdata(pdev, lpi2c_imx);\n\n\tret = clk_bulk_prepare_enable(lpi2c_imx->num_clks, lpi2c_imx->clks);\n\tif (ret)\n\t\treturn ret;\n\n\tpm_runtime_set_autosuspend_delay(&pdev->dev, I2C_PM_TIMEOUT);\n\tpm_runtime_use_autosuspend(&pdev->dev);\n\tpm_runtime_get_noresume(&pdev->dev);\n\tpm_runtime_set_active(&pdev->dev);\n\tpm_runtime_enable(&pdev->dev);\n\n\ttemp = readl(lpi2c_imx->base + LPI2C_PARAM);\n\tlpi2c_imx->txfifosize = 1 << (temp & 0x0f);\n\tlpi2c_imx->rxfifosize = 1 << ((temp >> 8) & 0x0f);\n\n\tret = i2c_add_adapter(&lpi2c_imx->adapter);\n\tif (ret)\n\t\tgoto rpm_disable;\n\n\tpm_runtime_mark_last_busy(&pdev->dev);\n\tpm_runtime_put_autosuspend(&pdev->dev);\n\n\tdev_info(&lpi2c_imx->adapter.dev, \"LPI2C adapter registered\\n\");\n\n\treturn 0;\n\nrpm_disable:\n\tpm_runtime_put(&pdev->dev);\n\tpm_runtime_disable(&pdev->dev);\n\tpm_runtime_dont_use_autosuspend(&pdev->dev);\n\n\treturn ret;\n}\n\nstatic void lpi2c_imx_remove(struct platform_device *pdev)\n{\n\tstruct lpi2c_imx_struct *lpi2c_imx = platform_get_drvdata(pdev);\n\n\ti2c_del_adapter(&lpi2c_imx->adapter);\n\n\tpm_runtime_disable(&pdev->dev);\n\tpm_runtime_dont_use_autosuspend(&pdev->dev);\n}\n\nstatic int __maybe_unused lpi2c_runtime_suspend(struct device *dev)\n{\n\tstruct lpi2c_imx_struct *lpi2c_imx = dev_get_drvdata(dev);\n\n\tclk_bulk_disable(lpi2c_imx->num_clks, lpi2c_imx->clks);\n\tpinctrl_pm_select_sleep_state(dev);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused lpi2c_runtime_resume(struct device *dev)\n{\n\tstruct lpi2c_imx_struct *lpi2c_imx = dev_get_drvdata(dev);\n\tint ret;\n\n\tpinctrl_pm_select_default_state(dev);\n\tret = clk_bulk_enable(lpi2c_imx->num_clks, lpi2c_imx->clks);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to enable I2C clock, ret=%d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops lpi2c_pm_ops = {\n\tSET_NOIRQ_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,\n\t\t\t\t      pm_runtime_force_resume)\n\tSET_RUNTIME_PM_OPS(lpi2c_runtime_suspend,\n\t\t\t   lpi2c_runtime_resume, NULL)\n};\n\nstatic struct platform_driver lpi2c_imx_driver = {\n\t.probe = lpi2c_imx_probe,\n\t.remove_new = lpi2c_imx_remove,\n\t.driver = {\n\t\t.name = DRIVER_NAME,\n\t\t.of_match_table = lpi2c_imx_of_match,\n\t\t.pm = &lpi2c_pm_ops,\n\t},\n};\n\nmodule_platform_driver(lpi2c_imx_driver);\n\nMODULE_AUTHOR(\"Gao Pan <pandy.gao@nxp.com>\");\nMODULE_DESCRIPTION(\"I2C adapter driver for LPI2C bus\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}