{
  "module_name": "i2c-sh7760.c",
  "hash_id": "38712616a79daf79bb2bc7163a58cc123080554c00abd7101c146f84cdf6608b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-sh7760.c",
  "human_readable_source": " \n\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/module.h>\n\n#include <asm/clock.h>\n#include <asm/i2c-sh7760.h>\n\n \n#define I2CSCR\t\t0x0\t\t \n#define I2CMCR\t\t0x4\t\t \n#define I2CSSR\t\t0x8\t\t \n#define I2CMSR\t\t0xC\t\t \n#define I2CSIER\t\t0x10\t\t \n#define I2CMIER\t\t0x14\t\t \n#define I2CCCR\t\t0x18\t\t \n#define I2CSAR\t\t0x1c\t\t \n#define I2CMAR\t\t0x20\t\t \n#define I2CRXTX\t\t0x24\t\t \n#define I2CFCR\t\t0x28\t\t \n#define I2CFSR\t\t0x2C\t\t \n#define I2CFIER\t\t0x30\t\t \n#define I2CRFDR\t\t0x34\t\t \n#define I2CTFDR\t\t0x38\t\t \n\n#define REGSIZE\t\t0x3C\n\n#define MCR_MDBS\t0x80\t\t \n#define MCR_FSCL\t0x40\t\t \n#define MCR_FSDA\t0x20\t\t \n#define MCR_OBPC\t0x10\t\t \n#define MCR_MIE\t\t0x08\t\t \n#define MCR_TSBE\t0x04\n#define MCR_FSB\t\t0x02\t\t \n#define MCR_ESG\t\t0x01\t\t \n\n#define MSR_MNR\t\t0x40\t\t \n#define MSR_MAL\t\t0x20\t\t \n#define MSR_MST\t\t0x10\t\t \n#define MSR_MDE\t\t0x08\n#define MSR_MDT\t\t0x04\n#define MSR_MDR\t\t0x02\n#define MSR_MAT\t\t0x01\t\t \n\n#define MIE_MNRE\t0x40\t\t \n#define MIE_MALE\t0x20\t\t \n#define MIE_MSTE\t0x10\t\t \n#define MIE_MDEE\t0x08\n#define MIE_MDTE\t0x04\n#define MIE_MDRE\t0x02\n#define MIE_MATE\t0x01\t\t \n\n#define FCR_RFRST\t0x02\t\t \n#define FCR_TFRST\t0x01\t\t \n\n#define FSR_TEND\t0x04\t\t \n#define FSR_RDF\t\t0x02\t\t \n#define FSR_TDFE\t0x01\t\t \n\n#define FIER_TEIE\t0x04\t\t \n#define FIER_RXIE\t0x02\t\t \n#define FIER_TXIE\t0x01\t\t \n\n#define FIFO_SIZE\t16\n\nstruct cami2c {\n\tvoid __iomem *iobase;\n\tstruct i2c_adapter adap;\n\n\t \n\tstruct i2c_msg\t*msg;\n#define IDF_SEND\t1\n#define IDF_RECV\t2\n#define IDF_STOP\t4\n\tint\t\tflags;\n\n#define IDS_DONE\t1\n#define IDS_ARBLOST\t2\n#define IDS_NACK\t4\n\tint\t\tstatus;\n\tstruct completion xfer_done;\n\n\tint irq;\n\tstruct resource *ioarea;\n};\n\nstatic inline void OUT32(struct cami2c *cam, int reg, unsigned long val)\n{\n\t__raw_writel(val, (unsigned long)cam->iobase + reg);\n}\n\nstatic inline unsigned long IN32(struct cami2c *cam, int reg)\n{\n\treturn __raw_readl((unsigned long)cam->iobase + reg);\n}\n\nstatic irqreturn_t sh7760_i2c_irq(int irq, void *ptr)\n{\n\tstruct cami2c *id = ptr;\n\tstruct i2c_msg *msg = id->msg;\n\tchar *data = msg->buf;\n\tunsigned long msr, fsr, fier, len;\n\n\tmsr = IN32(id, I2CMSR);\n\tfsr = IN32(id, I2CFSR);\n\n\t \n\tif (msr & MSR_MAL) {\n\t\tOUT32(id, I2CMCR, 0);\n\t\tOUT32(id, I2CSCR, 0);\n\t\tOUT32(id, I2CSAR, 0);\n\t\tid->status |= IDS_DONE | IDS_ARBLOST;\n\t\tgoto out;\n\t}\n\n\tif (msr & MSR_MNR) {\n\t\t \n\t\tudelay(100);\t \n\t\tOUT32(id, I2CFCR, FCR_RFRST | FCR_TFRST);\n\t\tOUT32(id, I2CMCR, MCR_MIE | MCR_FSB);\n\t\tOUT32(id, I2CFIER, 0);\n\t\tOUT32(id, I2CMIER, MIE_MSTE);\n\t\tOUT32(id, I2CSCR, 0);\n\t\tOUT32(id, I2CSAR, 0);\n\t\tid->status |= IDS_NACK;\n\t\tmsr &= ~MSR_MAT;\n\t\tfsr = 0;\n\t\t \n\t}\n\n\t \n\tif (msr & MSR_MST) {\n\t\tid->status |= IDS_DONE;\n\t\tgoto out;\n\t}\n\n\t \n\tif (msr & MSR_MAT)\n\t\tOUT32(id, I2CMCR, MCR_MIE);\n\n\tfier = IN32(id, I2CFIER);\n\n\tif (fsr & FSR_RDF) {\n\t\tlen = IN32(id, I2CRFDR);\n\t\tif (msg->len <= len) {\n\t\t\tif (id->flags & IDF_STOP) {\n\t\t\t\tOUT32(id, I2CMCR, MCR_MIE | MCR_FSB);\n\t\t\t\tOUT32(id, I2CFIER, 0);\n\t\t\t\t \n\t\t\t\tudelay(5);\n\t\t\t\t \n\t\t\t} else {\n\t\t\t\tid->status |= IDS_DONE;\n\t\t\t\t \n\t\t\t\tfsr &= ~FSR_RDF;\n\t\t\t}\n\t\t}\n\t\twhile (msg->len && len) {\n\t\t\t*data++ = IN32(id, I2CRXTX);\n\t\t\tmsg->len--;\n\t\t\tlen--;\n\t\t}\n\n\t\tif (msg->len) {\n\t\t\tlen = (msg->len >= FIFO_SIZE) ? FIFO_SIZE - 1\n\t\t\t\t\t\t      : msg->len - 1;\n\n\t\t\tOUT32(id, I2CFCR, FCR_TFRST | ((len & 0xf) << 4));\n\t\t}\n\n\t} else if (id->flags & IDF_SEND) {\n\t\tif ((fsr & FSR_TEND) && (msg->len < 1)) {\n\t\t\tif (id->flags & IDF_STOP) {\n\t\t\t\tOUT32(id, I2CMCR, MCR_MIE | MCR_FSB);\n\t\t\t} else {\n\t\t\t\tid->status |= IDS_DONE;\n\t\t\t\t \n\t\t\t\tfsr &= ~FSR_TEND;\n\t\t\t}\n\t\t}\n\t\tif (fsr & FSR_TDFE) {\n\t\t\twhile (msg->len && (IN32(id, I2CTFDR) < FIFO_SIZE)) {\n\t\t\t\tOUT32(id, I2CRXTX, *data++);\n\t\t\t\tmsg->len--;\n\t\t\t}\n\n\t\t\tif (msg->len < 1) {\n\t\t\t\tfier &= ~FIER_TXIE;\n\t\t\t\tOUT32(id, I2CFIER, fier);\n\t\t\t} else {\n\t\t\t\tlen = (msg->len >= FIFO_SIZE) ? 2 : 0;\n\t\t\t\tOUT32(id, I2CFCR,\n\t\t\t\t\t  FCR_RFRST | ((len & 3) << 2));\n\t\t\t}\n\t\t}\n\t}\nout:\n\tif (id->status & IDS_DONE) {\n\t\tOUT32(id, I2CMIER, 0);\n\t\tOUT32(id, I2CFIER, 0);\n\t\tid->msg = NULL;\n\t\tcomplete(&id->xfer_done);\n\t}\n\t \n\tOUT32(id, I2CMSR, ~msr);\n\tOUT32(id, I2CFSR, ~fsr);\n\tOUT32(id, I2CSSR, 0);\n\n\treturn IRQ_HANDLED;\n}\n\n\n \nstatic void sh7760_i2c_mrecv(struct cami2c *id)\n{\n\tint len;\n\n\tid->flags |= IDF_RECV;\n\n\t \n\tOUT32(id, I2CSAR, 0xfe);\n\tOUT32(id, I2CMAR, (id->msg->addr << 1) | 1);\n\n\t \n\tif (id->msg->len >= FIFO_SIZE)\n\t\tlen = FIFO_SIZE - 1;\t \n\telse\n\t\tlen = id->msg->len - 1;\t \n\n\tOUT32(id, I2CFCR, FCR_RFRST | FCR_TFRST);\n\tOUT32(id, I2CFCR, FCR_TFRST | ((len & 0xF) << 4));\n\n\tOUT32(id, I2CMSR, 0);\n\tOUT32(id, I2CMCR, MCR_MIE | MCR_ESG);\n\tOUT32(id, I2CMIER, MIE_MNRE | MIE_MALE | MIE_MSTE | MIE_MATE);\n\tOUT32(id, I2CFIER, FIER_RXIE);\n}\n\n \nstatic void sh7760_i2c_msend(struct cami2c *id)\n{\n\tint len;\n\n\tid->flags |= IDF_SEND;\n\n\t \n\tOUT32(id, I2CSAR, 0xfe);\n\tOUT32(id, I2CMAR, (id->msg->addr << 1) | 0);\n\n\t \n\tif (id->msg->len >= FIFO_SIZE)\n\t\tlen = 2;\t \n\telse\n\t\tlen = 0;\t \n\n\tOUT32(id, I2CFCR, FCR_RFRST | FCR_TFRST);\n\tOUT32(id, I2CFCR, FCR_RFRST | ((len & 3) << 2));\n\n\twhile (id->msg->len && IN32(id, I2CTFDR) < FIFO_SIZE) {\n\t\tOUT32(id, I2CRXTX, *(id->msg->buf));\n\t\t(id->msg->len)--;\n\t\t(id->msg->buf)++;\n\t}\n\n\tOUT32(id, I2CMSR, 0);\n\tOUT32(id, I2CMCR, MCR_MIE | MCR_ESG);\n\tOUT32(id, I2CFSR, 0);\n\tOUT32(id, I2CMIER, MIE_MNRE | MIE_MALE | MIE_MSTE | MIE_MATE);\n\tOUT32(id, I2CFIER, FIER_TEIE | (id->msg->len ? FIER_TXIE : 0));\n}\n\nstatic inline int sh7760_i2c_busy_check(struct cami2c *id)\n{\n\treturn (IN32(id, I2CMCR) & MCR_FSDA);\n}\n\nstatic int sh7760_i2c_master_xfer(struct i2c_adapter *adap,\n\t\t\t\t  struct i2c_msg *msgs,\n\t\t\t\t  int num)\n{\n\tstruct cami2c *id = adap->algo_data;\n\tint i, retr;\n\n\tif (sh7760_i2c_busy_check(id)) {\n\t\tdev_err(&adap->dev, \"sh7760-i2c%d: bus busy!\\n\", adap->nr);\n\t\treturn -EBUSY;\n\t}\n\n\ti = 0;\n\twhile (i < num) {\n\t\tretr = adap->retries;\nretry:\n\t\tid->flags = ((i == (num-1)) ? IDF_STOP : 0);\n\t\tid->status = 0;\n\t\tid->msg = msgs;\n\t\tinit_completion(&id->xfer_done);\n\n\t\tif (msgs->flags & I2C_M_RD)\n\t\t\tsh7760_i2c_mrecv(id);\n\t\telse\n\t\t\tsh7760_i2c_msend(id);\n\n\t\twait_for_completion(&id->xfer_done);\n\n\t\tif (id->status == 0) {\n\t\t\tnum = -EIO;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (id->status & IDS_NACK) {\n\t\t\t \n\t\t\tmdelay(1);\n\t\t\tnum = -EREMOTEIO;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (id->status & IDS_ARBLOST) {\n\t\t\tif (retr--) {\n\t\t\t\tmdelay(2);\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t\tnum = -EREMOTEIO;\n\t\t\tbreak;\n\t\t}\n\n\t\tmsgs++;\n\t\ti++;\n\t}\n\n\tid->msg = NULL;\n\tid->flags = 0;\n\tid->status = 0;\n\n\tOUT32(id, I2CMCR, 0);\n\tOUT32(id, I2CMSR, 0);\n\tOUT32(id, I2CMIER, 0);\n\tOUT32(id, I2CFIER, 0);\n\n\t \n\tOUT32(id, I2CSCR, 0);\n\tOUT32(id, I2CSAR, 0);\n\tOUT32(id, I2CSSR, 0);\n\n\treturn num;\n}\n\nstatic u32 sh7760_i2c_func(struct i2c_adapter *adap)\n{\n\treturn I2C_FUNC_I2C | (I2C_FUNC_SMBUS_EMUL & ~I2C_FUNC_SMBUS_QUICK);\n}\n\nstatic const struct i2c_algorithm sh7760_i2c_algo = {\n\t.master_xfer\t= sh7760_i2c_master_xfer,\n\t.functionality\t= sh7760_i2c_func,\n};\n\n \nstatic int calc_CCR(unsigned long scl_hz)\n{\n\tstruct clk *mclk;\n\tunsigned long mck, m1, dff, odff, iclk;\n\tsigned char cdf, cdfm;\n\tint scgd, scgdm, scgds;\n\n\tmclk = clk_get(NULL, \"peripheral_clk\");\n\tif (IS_ERR(mclk)) {\n\t\treturn PTR_ERR(mclk);\n\t} else {\n\t\tmck = mclk->rate;\n\t\tclk_put(mclk);\n\t}\n\n\todff = scl_hz;\n\tscgdm = cdfm = m1 = 0;\n\tfor (cdf = 3; cdf >= 0; cdf--) {\n\t\ticlk = mck / (1 + cdf);\n\t\tif (iclk >= 20000000)\n\t\t\tcontinue;\n\t\tscgds = ((iclk / scl_hz) - 20) >> 3;\n\t\tfor (scgd = scgds; (scgd < 63) && scgd <= scgds + 1; scgd++) {\n\t\t\tm1 = iclk / (20 + (scgd << 3));\n\t\t\tdff = abs(scl_hz - m1);\n\t\t\tif (dff < odff) {\n\t\t\t\todff = dff;\n\t\t\t\tcdfm = cdf;\n\t\t\t\tscgdm = scgd;\n\t\t\t}\n\t\t}\n\t}\n\t \n\tif (odff > (scl_hz >> 2))\n\t\treturn -EINVAL;\n\n\t \n\treturn ((scgdm << 2) | cdfm);\n}\n\nstatic int sh7760_i2c_probe(struct platform_device *pdev)\n{\n\tstruct sh7760_i2c_platdata *pd;\n\tstruct resource *res;\n\tstruct cami2c *id;\n\tint ret;\n\n\tpd = dev_get_platdata(&pdev->dev);\n\tif (!pd) {\n\t\tdev_err(&pdev->dev, \"no platform_data!\\n\");\n\t\tret = -ENODEV;\n\t\tgoto out0;\n\t}\n\n\tid = kzalloc(sizeof(*id), GFP_KERNEL);\n\tif (!id) {\n\t\tret = -ENOMEM;\n\t\tgoto out0;\n\t}\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res) {\n\t\tdev_err(&pdev->dev, \"no mmio resources\\n\");\n\t\tret = -ENODEV;\n\t\tgoto out1;\n\t}\n\n\tid->ioarea = request_mem_region(res->start, REGSIZE, pdev->name);\n\tif (!id->ioarea) {\n\t\tdev_err(&pdev->dev, \"mmio already reserved\\n\");\n\t\tret = -EBUSY;\n\t\tgoto out1;\n\t}\n\n\tid->iobase = ioremap(res->start, REGSIZE);\n\tif (!id->iobase) {\n\t\tdev_err(&pdev->dev, \"cannot ioremap\\n\");\n\t\tret = -ENODEV;\n\t\tgoto out2;\n\t}\n\n\tret = platform_get_irq(pdev, 0);\n\tif (ret < 0)\n\t\tgoto out3;\n\tid->irq = ret;\n\n\tid->adap.nr = pdev->id;\n\tid->adap.algo = &sh7760_i2c_algo;\n\tid->adap.class = I2C_CLASS_HWMON | I2C_CLASS_SPD;\n\tid->adap.retries = 3;\n\tid->adap.algo_data = id;\n\tid->adap.dev.parent = &pdev->dev;\n\tsnprintf(id->adap.name, sizeof(id->adap.name),\n\t\t\"SH7760 I2C at %08lx\", (unsigned long)res->start);\n\n\tOUT32(id, I2CMCR, 0);\n\tOUT32(id, I2CMSR, 0);\n\tOUT32(id, I2CMIER, 0);\n\tOUT32(id, I2CMAR, 0);\n\tOUT32(id, I2CSIER, 0);\n\tOUT32(id, I2CSAR, 0);\n\tOUT32(id, I2CSCR, 0);\n\tOUT32(id, I2CSSR, 0);\n\tOUT32(id, I2CFIER, 0);\n\tOUT32(id, I2CFCR, FCR_RFRST | FCR_TFRST);\n\tOUT32(id, I2CFSR, 0);\n\n\tret = calc_CCR(pd->speed_khz * 1000);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"invalid SCL clock: %dkHz\\n\",\n\t\t\tpd->speed_khz);\n\t\tgoto out3;\n\t}\n\tOUT32(id, I2CCCR, ret);\n\n\tif (request_irq(id->irq, sh7760_i2c_irq, 0,\n\t\t\tSH7760_I2C_DEVNAME, id)) {\n\t\tdev_err(&pdev->dev, \"cannot get irq %d\\n\", id->irq);\n\t\tret = -EBUSY;\n\t\tgoto out3;\n\t}\n\n\tret = i2c_add_numbered_adapter(&id->adap);\n\tif (ret < 0)\n\t\tgoto out4;\n\n\tplatform_set_drvdata(pdev, id);\n\n\tdev_info(&pdev->dev, \"%d kHz mmio %08x irq %d\\n\",\n\t\t pd->speed_khz, res->start, id->irq);\n\n\treturn 0;\n\nout4:\n\tfree_irq(id->irq, id);\nout3:\n\tiounmap(id->iobase);\nout2:\n\trelease_resource(id->ioarea);\n\tkfree(id->ioarea);\nout1:\n\tkfree(id);\nout0:\n\treturn ret;\n}\n\nstatic void sh7760_i2c_remove(struct platform_device *pdev)\n{\n\tstruct cami2c *id = platform_get_drvdata(pdev);\n\n\ti2c_del_adapter(&id->adap);\n\tfree_irq(id->irq, id);\n\tiounmap(id->iobase);\n\trelease_resource(id->ioarea);\n\tkfree(id->ioarea);\n\tkfree(id);\n}\n\nstatic struct platform_driver sh7760_i2c_drv = {\n\t.driver\t= {\n\t\t.name\t= SH7760_I2C_DEVNAME,\n\t},\n\t.probe\t\t= sh7760_i2c_probe,\n\t.remove_new\t= sh7760_i2c_remove,\n};\n\nmodule_platform_driver(sh7760_i2c_drv);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"SH7760 I2C bus driver\");\nMODULE_AUTHOR(\"Manuel Lauss <mano@roarinelk.homelinux.net>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}