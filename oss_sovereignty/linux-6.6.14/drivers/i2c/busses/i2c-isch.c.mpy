{
  "module_name": "i2c-isch.c",
  "hash_id": "319715cc2234d0592280e0672f7986fafddcb533ae459222bc27e3ab4e944df8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-isch.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/kernel.h>\n#include <linux/delay.h>\n#include <linux/stddef.h>\n#include <linux/ioport.h>\n#include <linux/i2c.h>\n#include <linux/io.h>\n\n \n#define SMBHSTCNT\t(0 + sch_smba)\n#define SMBHSTSTS\t(1 + sch_smba)\n#define SMBHSTCLK\t(2 + sch_smba)\n#define SMBHSTADD\t(4 + sch_smba)  \n#define SMBHSTCMD\t(5 + sch_smba)\n#define SMBHSTDAT0\t(6 + sch_smba)\n#define SMBHSTDAT1\t(7 + sch_smba)\n#define SMBBLKDAT\t(0x20 + sch_smba)\n\n \n#define MAX_RETRIES\t5000\n\n \n#define SCH_QUICK\t\t0x00\n#define SCH_BYTE\t\t0x01\n#define SCH_BYTE_DATA\t\t0x02\n#define SCH_WORD_DATA\t\t0x03\n#define SCH_BLOCK_DATA\t\t0x05\n\nstatic unsigned short sch_smba;\nstatic struct i2c_adapter sch_adapter;\nstatic int backbone_speed = 33000;  \nmodule_param(backbone_speed, int, S_IRUSR | S_IWUSR);\nMODULE_PARM_DESC(backbone_speed, \"Backbone speed in kHz, (default = 33000)\");\n\n \nstatic int sch_transaction(void)\n{\n\tint temp;\n\tint result = 0;\n\tint retries = 0;\n\n\tdev_dbg(&sch_adapter.dev, \"Transaction (pre): CNT=%02x, CMD=%02x, \"\n\t\t\"ADD=%02x, DAT0=%02x, DAT1=%02x\\n\", inb(SMBHSTCNT),\n\t\tinb(SMBHSTCMD), inb(SMBHSTADD), inb(SMBHSTDAT0),\n\t\tinb(SMBHSTDAT1));\n\n\t \n\ttemp = inb(SMBHSTSTS) & 0x0f;\n\tif (temp) {\n\t\t \n\t\tif (temp & 0x01) {\n\t\t\tdev_dbg(&sch_adapter.dev, \"Completion (%02x). \"\n\t\t\t\t\"Clear...\\n\", temp);\n\t\t}\n\t\tif (temp & 0x06) {\n\t\t\tdev_dbg(&sch_adapter.dev, \"SMBus error (%02x). \"\n\t\t\t\t\"Resetting...\\n\", temp);\n\t\t}\n\t\toutb(temp, SMBHSTSTS);\n\t\ttemp = inb(SMBHSTSTS) & 0x0f;\n\t\tif (temp) {\n\t\t\tdev_err(&sch_adapter.dev,\n\t\t\t\t\"SMBus is not ready: (%02x)\\n\", temp);\n\t\t\treturn -EAGAIN;\n\t\t}\n\t}\n\n\t \n\toutb(inb(SMBHSTCNT) | 0x10, SMBHSTCNT);\n\n\tdo {\n\t\tusleep_range(100, 200);\n\t\ttemp = inb(SMBHSTSTS) & 0x0f;\n\t} while ((temp & 0x08) && (retries++ < MAX_RETRIES));\n\n\t \n\tif (retries > MAX_RETRIES) {\n\t\tdev_err(&sch_adapter.dev, \"SMBus Timeout!\\n\");\n\t\tresult = -ETIMEDOUT;\n\t}\n\tif (temp & 0x04) {\n\t\tresult = -EIO;\n\t\tdev_dbg(&sch_adapter.dev, \"Bus collision! SMBus may be \"\n\t\t\t\"locked until next hard reset. (sorry!)\\n\");\n\t\t \n\t} else if (temp & 0x02) {\n\t\tresult = -EIO;\n\t\tdev_err(&sch_adapter.dev, \"Error: no response!\\n\");\n\t} else if (temp & 0x01) {\n\t\tdev_dbg(&sch_adapter.dev, \"Post complete!\\n\");\n\t\toutb(temp, SMBHSTSTS);\n\t\ttemp = inb(SMBHSTSTS) & 0x07;\n\t\tif (temp & 0x06) {\n\t\t\t \n\t\t\tdev_dbg(&sch_adapter.dev, \"Failed reset at end of \"\n\t\t\t\t\"transaction (%02x), Bus error!\\n\", temp);\n\t\t}\n\t} else {\n\t\tresult = -ENXIO;\n\t\tdev_dbg(&sch_adapter.dev, \"No such address.\\n\");\n\t}\n\tdev_dbg(&sch_adapter.dev, \"Transaction (post): CNT=%02x, CMD=%02x, \"\n\t\t\"ADD=%02x, DAT0=%02x, DAT1=%02x\\n\", inb(SMBHSTCNT),\n\t\tinb(SMBHSTCMD), inb(SMBHSTADD), inb(SMBHSTDAT0),\n\t\tinb(SMBHSTDAT1));\n\treturn result;\n}\n\n \nstatic s32 sch_access(struct i2c_adapter *adap, u16 addr,\n\t\t unsigned short flags, char read_write,\n\t\t u8 command, int size, union i2c_smbus_data *data)\n{\n\tint i, len, temp, rc;\n\n\t \n\ttemp = inb(SMBHSTSTS) & 0x0f;\n\tif (temp & 0x08) {\n\t\tdev_dbg(&sch_adapter.dev, \"SMBus busy (%02x)\\n\", temp);\n\t\treturn -EAGAIN;\n\t}\n\ttemp = inw(SMBHSTCLK);\n\tif (!temp) {\n\t\t \n\t\tdev_notice(&sch_adapter.dev,\n\t\t\t\"Clock divider uninitialized. Setting defaults\\n\");\n\t\toutw(backbone_speed / (4 * 100), SMBHSTCLK);\n\t}\n\n\tdev_dbg(&sch_adapter.dev, \"access size: %d %s\\n\", size,\n\t\t(read_write)?\"READ\":\"WRITE\");\n\tswitch (size) {\n\tcase I2C_SMBUS_QUICK:\n\t\toutb((addr << 1) | read_write, SMBHSTADD);\n\t\tsize = SCH_QUICK;\n\t\tbreak;\n\tcase I2C_SMBUS_BYTE:\n\t\toutb((addr << 1) | read_write, SMBHSTADD);\n\t\tif (read_write == I2C_SMBUS_WRITE)\n\t\t\toutb(command, SMBHSTCMD);\n\t\tsize = SCH_BYTE;\n\t\tbreak;\n\tcase I2C_SMBUS_BYTE_DATA:\n\t\toutb((addr << 1) | read_write, SMBHSTADD);\n\t\toutb(command, SMBHSTCMD);\n\t\tif (read_write == I2C_SMBUS_WRITE)\n\t\t\toutb(data->byte, SMBHSTDAT0);\n\t\tsize = SCH_BYTE_DATA;\n\t\tbreak;\n\tcase I2C_SMBUS_WORD_DATA:\n\t\toutb((addr << 1) | read_write, SMBHSTADD);\n\t\toutb(command, SMBHSTCMD);\n\t\tif (read_write == I2C_SMBUS_WRITE) {\n\t\t\toutb(data->word & 0xff, SMBHSTDAT0);\n\t\t\toutb((data->word & 0xff00) >> 8, SMBHSTDAT1);\n\t\t}\n\t\tsize = SCH_WORD_DATA;\n\t\tbreak;\n\tcase I2C_SMBUS_BLOCK_DATA:\n\t\toutb((addr << 1) | read_write, SMBHSTADD);\n\t\toutb(command, SMBHSTCMD);\n\t\tif (read_write == I2C_SMBUS_WRITE) {\n\t\t\tlen = data->block[0];\n\t\t\tif (len == 0 || len > I2C_SMBUS_BLOCK_MAX)\n\t\t\t\treturn -EINVAL;\n\t\t\toutb(len, SMBHSTDAT0);\n\t\t\tfor (i = 1; i <= len; i++)\n\t\t\t\toutb(data->block[i], SMBBLKDAT+i-1);\n\t\t}\n\t\tsize = SCH_BLOCK_DATA;\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(&adap->dev, \"Unsupported transaction %d\\n\", size);\n\t\treturn -EOPNOTSUPP;\n\t}\n\tdev_dbg(&sch_adapter.dev, \"write size %d to 0x%04x\\n\", size, SMBHSTCNT);\n\toutb((inb(SMBHSTCNT) & 0xb0) | (size & 0x7), SMBHSTCNT);\n\n\trc = sch_transaction();\n\tif (rc)\t \n\t\treturn rc;\n\n\tif ((read_write == I2C_SMBUS_WRITE) || (size == SCH_QUICK))\n\t\treturn 0;\n\n\tswitch (size) {\n\tcase SCH_BYTE:\n\tcase SCH_BYTE_DATA:\n\t\tdata->byte = inb(SMBHSTDAT0);\n\t\tbreak;\n\tcase SCH_WORD_DATA:\n\t\tdata->word = inb(SMBHSTDAT0) + (inb(SMBHSTDAT1) << 8);\n\t\tbreak;\n\tcase SCH_BLOCK_DATA:\n\t\tdata->block[0] = inb(SMBHSTDAT0);\n\t\tif (data->block[0] == 0 || data->block[0] > I2C_SMBUS_BLOCK_MAX)\n\t\t\treturn -EPROTO;\n\t\tfor (i = 1; i <= data->block[0]; i++)\n\t\t\tdata->block[i] = inb(SMBBLKDAT+i-1);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic u32 sch_func(struct i2c_adapter *adapter)\n{\n\treturn I2C_FUNC_SMBUS_QUICK | I2C_FUNC_SMBUS_BYTE |\n\t    I2C_FUNC_SMBUS_BYTE_DATA | I2C_FUNC_SMBUS_WORD_DATA |\n\t    I2C_FUNC_SMBUS_BLOCK_DATA;\n}\n\nstatic const struct i2c_algorithm smbus_algorithm = {\n\t.smbus_xfer\t= sch_access,\n\t.functionality\t= sch_func,\n};\n\nstatic struct i2c_adapter sch_adapter = {\n\t.owner\t\t= THIS_MODULE,\n\t.class\t\t= I2C_CLASS_HWMON | I2C_CLASS_SPD,\n\t.algo\t\t= &smbus_algorithm,\n};\n\nstatic int smbus_sch_probe(struct platform_device *dev)\n{\n\tstruct resource *res;\n\tint retval;\n\n\tres = platform_get_resource(dev, IORESOURCE_IO, 0);\n\tif (!res)\n\t\treturn -EBUSY;\n\n\tif (!devm_request_region(&dev->dev, res->start, resource_size(res),\n\t\t\t\t dev->name)) {\n\t\tdev_err(&dev->dev, \"SMBus region 0x%x already in use!\\n\",\n\t\t\tsch_smba);\n\t\treturn -EBUSY;\n\t}\n\n\tsch_smba = res->start;\n\n\tdev_dbg(&dev->dev, \"SMBA = 0x%X\\n\", sch_smba);\n\n\t \n\tsch_adapter.dev.parent = &dev->dev;\n\n\tsnprintf(sch_adapter.name, sizeof(sch_adapter.name),\n\t\t\"SMBus SCH adapter at %04x\", sch_smba);\n\n\tretval = i2c_add_adapter(&sch_adapter);\n\tif (retval)\n\t\tsch_smba = 0;\n\n\treturn retval;\n}\n\nstatic void smbus_sch_remove(struct platform_device *pdev)\n{\n\tif (sch_smba) {\n\t\ti2c_del_adapter(&sch_adapter);\n\t\tsch_smba = 0;\n\t}\n}\n\nstatic struct platform_driver smbus_sch_driver = {\n\t.driver = {\n\t\t.name = \"isch_smbus\",\n\t},\n\t.probe\t\t= smbus_sch_probe,\n\t.remove_new\t= smbus_sch_remove,\n};\n\nmodule_platform_driver(smbus_sch_driver);\n\nMODULE_AUTHOR(\"Jacob Pan <jacob.jun.pan@intel.com>\");\nMODULE_DESCRIPTION(\"Intel SCH SMBus driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:isch_smbus\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}