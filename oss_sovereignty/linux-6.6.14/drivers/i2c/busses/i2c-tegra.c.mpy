{
  "module_name": "i2c-tegra.c",
  "hash_id": "cf8fa638774446cc66e2d0196be36f0c688900df9fdc534ef7ba48f7fbfb3c9e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-tegra.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/dmaengine.h>\n#include <linux/dma-mapping.h>\n#include <linux/err.h>\n#include <linux/i2c.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/irq.h>\n#include <linux/kernel.h>\n#include <linux/ktime.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/reset.h>\n\n#define BYTES_PER_FIFO_WORD 4\n\n#define I2C_CNFG\t\t\t\t0x000\n#define I2C_CNFG_DEBOUNCE_CNT\t\t\tGENMASK(14, 12)\n#define I2C_CNFG_PACKET_MODE_EN\t\t\tBIT(10)\n#define I2C_CNFG_NEW_MASTER_FSM\t\t\tBIT(11)\n#define I2C_CNFG_MULTI_MASTER_MODE\t\tBIT(17)\n#define I2C_STATUS\t\t\t\t0x01c\n#define I2C_SL_CNFG\t\t\t\t0x020\n#define I2C_SL_CNFG_NACK\t\t\tBIT(1)\n#define I2C_SL_CNFG_NEWSL\t\t\tBIT(2)\n#define I2C_SL_ADDR1\t\t\t\t0x02c\n#define I2C_SL_ADDR2\t\t\t\t0x030\n#define I2C_TLOW_SEXT\t\t\t\t0x034\n#define I2C_TX_FIFO\t\t\t\t0x050\n#define I2C_RX_FIFO\t\t\t\t0x054\n#define I2C_PACKET_TRANSFER_STATUS\t\t0x058\n#define I2C_FIFO_CONTROL\t\t\t0x05c\n#define I2C_FIFO_CONTROL_TX_FLUSH\t\tBIT(1)\n#define I2C_FIFO_CONTROL_RX_FLUSH\t\tBIT(0)\n#define I2C_FIFO_CONTROL_TX_TRIG(x)\t\t(((x) - 1) << 5)\n#define I2C_FIFO_CONTROL_RX_TRIG(x)\t\t(((x) - 1) << 2)\n#define I2C_FIFO_STATUS\t\t\t\t0x060\n#define I2C_FIFO_STATUS_TX\t\t\tGENMASK(7, 4)\n#define I2C_FIFO_STATUS_RX\t\t\tGENMASK(3, 0)\n#define I2C_INT_MASK\t\t\t\t0x064\n#define I2C_INT_STATUS\t\t\t\t0x068\n#define I2C_INT_BUS_CLR_DONE\t\t\tBIT(11)\n#define I2C_INT_PACKET_XFER_COMPLETE\t\tBIT(7)\n#define I2C_INT_NO_ACK\t\t\t\tBIT(3)\n#define I2C_INT_ARBITRATION_LOST\t\tBIT(2)\n#define I2C_INT_TX_FIFO_DATA_REQ\t\tBIT(1)\n#define I2C_INT_RX_FIFO_DATA_REQ\t\tBIT(0)\n#define I2C_CLK_DIVISOR\t\t\t\t0x06c\n#define I2C_CLK_DIVISOR_STD_FAST_MODE\t\tGENMASK(31, 16)\n#define I2C_CLK_DIVISOR_HSMODE\t\t\tGENMASK(15, 0)\n\n#define DVC_CTRL_REG1\t\t\t\t0x000\n#define DVC_CTRL_REG1_INTR_EN\t\t\tBIT(10)\n#define DVC_CTRL_REG3\t\t\t\t0x008\n#define DVC_CTRL_REG3_SW_PROG\t\t\tBIT(26)\n#define DVC_CTRL_REG3_I2C_DONE_INTR_EN\t\tBIT(30)\n#define DVC_STATUS\t\t\t\t0x00c\n#define DVC_STATUS_I2C_DONE_INTR\t\tBIT(30)\n\n#define I2C_ERR_NONE\t\t\t\t0x00\n#define I2C_ERR_NO_ACK\t\t\t\tBIT(0)\n#define I2C_ERR_ARBITRATION_LOST\t\tBIT(1)\n#define I2C_ERR_UNKNOWN_INTERRUPT\t\tBIT(2)\n#define I2C_ERR_RX_BUFFER_OVERFLOW\t\tBIT(3)\n\n#define PACKET_HEADER0_HEADER_SIZE\t\tGENMASK(29, 28)\n#define PACKET_HEADER0_PACKET_ID\t\tGENMASK(23, 16)\n#define PACKET_HEADER0_CONT_ID\t\t\tGENMASK(15, 12)\n#define PACKET_HEADER0_PROTOCOL\t\t\tGENMASK(7, 4)\n#define PACKET_HEADER0_PROTOCOL_I2C\t\t1\n\n#define I2C_HEADER_CONT_ON_NAK\t\t\tBIT(21)\n#define I2C_HEADER_READ\t\t\t\tBIT(19)\n#define I2C_HEADER_10BIT_ADDR\t\t\tBIT(18)\n#define I2C_HEADER_IE_ENABLE\t\t\tBIT(17)\n#define I2C_HEADER_REPEAT_START\t\t\tBIT(16)\n#define I2C_HEADER_CONTINUE_XFER\t\tBIT(15)\n#define I2C_HEADER_SLAVE_ADDR_SHIFT\t\t1\n\n#define I2C_BUS_CLEAR_CNFG\t\t\t0x084\n#define I2C_BC_SCLK_THRESHOLD\t\t\tGENMASK(23, 16)\n#define I2C_BC_STOP_COND\t\t\tBIT(2)\n#define I2C_BC_TERMINATE\t\t\tBIT(1)\n#define I2C_BC_ENABLE\t\t\t\tBIT(0)\n#define I2C_BUS_CLEAR_STATUS\t\t\t0x088\n#define I2C_BC_STATUS\t\t\t\tBIT(0)\n\n#define I2C_CONFIG_LOAD\t\t\t\t0x08c\n#define I2C_MSTR_CONFIG_LOAD\t\t\tBIT(0)\n\n#define I2C_CLKEN_OVERRIDE\t\t\t0x090\n#define I2C_MST_CORE_CLKEN_OVR\t\t\tBIT(0)\n\n#define I2C_INTERFACE_TIMING_0\t\t\t0x094\n#define  I2C_INTERFACE_TIMING_THIGH\t\tGENMASK(13, 8)\n#define  I2C_INTERFACE_TIMING_TLOW\t\tGENMASK(5, 0)\n#define I2C_INTERFACE_TIMING_1\t\t\t0x098\n#define  I2C_INTERFACE_TIMING_TBUF\t\tGENMASK(29, 24)\n#define  I2C_INTERFACE_TIMING_TSU_STO\t\tGENMASK(21, 16)\n#define  I2C_INTERFACE_TIMING_THD_STA\t\tGENMASK(13, 8)\n#define  I2C_INTERFACE_TIMING_TSU_STA\t\tGENMASK(5, 0)\n\n#define I2C_HS_INTERFACE_TIMING_0\t\t0x09c\n#define  I2C_HS_INTERFACE_TIMING_THIGH\t\tGENMASK(13, 8)\n#define  I2C_HS_INTERFACE_TIMING_TLOW\t\tGENMASK(5, 0)\n#define I2C_HS_INTERFACE_TIMING_1\t\t0x0a0\n#define  I2C_HS_INTERFACE_TIMING_TSU_STO\tGENMASK(21, 16)\n#define  I2C_HS_INTERFACE_TIMING_THD_STA\tGENMASK(13, 8)\n#define  I2C_HS_INTERFACE_TIMING_TSU_STA\tGENMASK(5, 0)\n\n#define I2C_MST_FIFO_CONTROL\t\t\t0x0b4\n#define I2C_MST_FIFO_CONTROL_RX_FLUSH\t\tBIT(0)\n#define I2C_MST_FIFO_CONTROL_TX_FLUSH\t\tBIT(1)\n#define I2C_MST_FIFO_CONTROL_RX_TRIG(x)\t\t(((x) - 1) <<  4)\n#define I2C_MST_FIFO_CONTROL_TX_TRIG(x)\t\t(((x) - 1) << 16)\n\n#define I2C_MST_FIFO_STATUS\t\t\t0x0b8\n#define I2C_MST_FIFO_STATUS_TX\t\t\tGENMASK(23, 16)\n#define I2C_MST_FIFO_STATUS_RX\t\t\tGENMASK(7, 0)\n\n \n#define I2C_CONFIG_LOAD_TIMEOUT\t\t\t1000000\n\n \n#define I2C_PACKET_HEADER_SIZE\t\t\t12\n\n \n#define I2C_PIO_MODE_PREFERRED_LEN\t\t32\n\n \nenum msg_end_type {\n\tMSG_END_STOP,\n\tMSG_END_REPEAT_START,\n\tMSG_END_CONTINUE,\n};\n\n \nstruct tegra_i2c_hw_feature {\n\tbool has_continue_xfer_support;\n\tbool has_per_pkt_xfer_complete_irq;\n\tbool has_config_load_reg;\n\tu32 clk_divisor_hs_mode;\n\tu32 clk_divisor_std_mode;\n\tu32 clk_divisor_fast_mode;\n\tu32 clk_divisor_fast_plus_mode;\n\tbool has_multi_master_mode;\n\tbool has_slcg_override_reg;\n\tbool has_mst_fifo;\n\tconst struct i2c_adapter_quirks *quirks;\n\tbool supports_bus_clear;\n\tbool has_apb_dma;\n\tu32 tlow_std_mode;\n\tu32 thigh_std_mode;\n\tu32 tlow_fast_fastplus_mode;\n\tu32 thigh_fast_fastplus_mode;\n\tu32 setup_hold_time_std_mode;\n\tu32 setup_hold_time_fast_fast_plus_mode;\n\tu32 setup_hold_time_hs_mode;\n\tbool has_interface_timing_reg;\n};\n\n \nstruct tegra_i2c_dev {\n\tstruct device *dev;\n\tstruct i2c_adapter adapter;\n\n\tconst struct tegra_i2c_hw_feature *hw;\n\tstruct reset_control *rst;\n\tunsigned int cont_id;\n\tunsigned int irq;\n\n\tphys_addr_t base_phys;\n\tvoid __iomem *base;\n\n\tstruct clk_bulk_data clocks[2];\n\tunsigned int nclocks;\n\n\tstruct clk *div_clk;\n\tstruct i2c_timings timings;\n\n\tstruct completion msg_complete;\n\tsize_t msg_buf_remaining;\n\tunsigned int msg_len;\n\tint msg_err;\n\tu8 *msg_buf;\n\n\tstruct completion dma_complete;\n\tstruct dma_chan *dma_chan;\n\tunsigned int dma_buf_size;\n\tstruct device *dma_dev;\n\tdma_addr_t dma_phys;\n\tvoid *dma_buf;\n\n\tbool multimaster_mode;\n\tbool atomic_mode;\n\tbool dma_mode;\n\tbool msg_read;\n\tbool is_dvc;\n\tbool is_vi;\n};\n\n#define IS_DVC(dev) (IS_ENABLED(CONFIG_ARCH_TEGRA_2x_SOC) && (dev)->is_dvc)\n#define IS_VI(dev)  (IS_ENABLED(CONFIG_ARCH_TEGRA_210_SOC) && (dev)->is_vi)\n\nstatic void dvc_writel(struct tegra_i2c_dev *i2c_dev, u32 val,\n\t\t       unsigned int reg)\n{\n\twritel_relaxed(val, i2c_dev->base + reg);\n}\n\nstatic u32 dvc_readl(struct tegra_i2c_dev *i2c_dev, unsigned int reg)\n{\n\treturn readl_relaxed(i2c_dev->base + reg);\n}\n\n \nstatic u32 tegra_i2c_reg_addr(struct tegra_i2c_dev *i2c_dev, unsigned int reg)\n{\n\tif (IS_DVC(i2c_dev))\n\t\treg += (reg >= I2C_TX_FIFO) ? 0x10 : 0x40;\n\telse if (IS_VI(i2c_dev))\n\t\treg = 0xc00 + (reg << 2);\n\n\treturn reg;\n}\n\nstatic void i2c_writel(struct tegra_i2c_dev *i2c_dev, u32 val, unsigned int reg)\n{\n\twritel_relaxed(val, i2c_dev->base + tegra_i2c_reg_addr(i2c_dev, reg));\n\n\t \n\tif (reg != I2C_TX_FIFO)\n\t\treadl_relaxed(i2c_dev->base + tegra_i2c_reg_addr(i2c_dev, reg));\n\telse if (IS_VI(i2c_dev))\n\t\treadl_relaxed(i2c_dev->base + tegra_i2c_reg_addr(i2c_dev, I2C_INT_STATUS));\n}\n\nstatic u32 i2c_readl(struct tegra_i2c_dev *i2c_dev, unsigned int reg)\n{\n\treturn readl_relaxed(i2c_dev->base + tegra_i2c_reg_addr(i2c_dev, reg));\n}\n\nstatic void i2c_writesl(struct tegra_i2c_dev *i2c_dev, void *data,\n\t\t\tunsigned int reg, unsigned int len)\n{\n\twritesl(i2c_dev->base + tegra_i2c_reg_addr(i2c_dev, reg), data, len);\n}\n\nstatic void i2c_writesl_vi(struct tegra_i2c_dev *i2c_dev, void *data,\n\t\t\t   unsigned int reg, unsigned int len)\n{\n\tu32 *data32 = data;\n\n\t \n\twhile (len--)\n\t\ti2c_writel(i2c_dev, *data32++, reg);\n}\n\nstatic void i2c_readsl(struct tegra_i2c_dev *i2c_dev, void *data,\n\t\t       unsigned int reg, unsigned int len)\n{\n\treadsl(i2c_dev->base + tegra_i2c_reg_addr(i2c_dev, reg), data, len);\n}\n\nstatic void tegra_i2c_mask_irq(struct tegra_i2c_dev *i2c_dev, u32 mask)\n{\n\tu32 int_mask;\n\n\tint_mask = i2c_readl(i2c_dev, I2C_INT_MASK) & ~mask;\n\ti2c_writel(i2c_dev, int_mask, I2C_INT_MASK);\n}\n\nstatic void tegra_i2c_unmask_irq(struct tegra_i2c_dev *i2c_dev, u32 mask)\n{\n\tu32 int_mask;\n\n\tint_mask = i2c_readl(i2c_dev, I2C_INT_MASK) | mask;\n\ti2c_writel(i2c_dev, int_mask, I2C_INT_MASK);\n}\n\nstatic void tegra_i2c_dma_complete(void *args)\n{\n\tstruct tegra_i2c_dev *i2c_dev = args;\n\n\tcomplete(&i2c_dev->dma_complete);\n}\n\nstatic int tegra_i2c_dma_submit(struct tegra_i2c_dev *i2c_dev, size_t len)\n{\n\tstruct dma_async_tx_descriptor *dma_desc;\n\tenum dma_transfer_direction dir;\n\n\tdev_dbg(i2c_dev->dev, \"starting DMA for length: %zu\\n\", len);\n\n\treinit_completion(&i2c_dev->dma_complete);\n\n\tdir = i2c_dev->msg_read ? DMA_DEV_TO_MEM : DMA_MEM_TO_DEV;\n\n\tdma_desc = dmaengine_prep_slave_single(i2c_dev->dma_chan, i2c_dev->dma_phys,\n\t\t\t\t\t       len, dir, DMA_PREP_INTERRUPT |\n\t\t\t\t\t       DMA_CTRL_ACK);\n\tif (!dma_desc) {\n\t\tdev_err(i2c_dev->dev, \"failed to get %s DMA descriptor\\n\",\n\t\t\ti2c_dev->msg_read ? \"RX\" : \"TX\");\n\t\treturn -EINVAL;\n\t}\n\n\tdma_desc->callback = tegra_i2c_dma_complete;\n\tdma_desc->callback_param = i2c_dev;\n\n\tdmaengine_submit(dma_desc);\n\tdma_async_issue_pending(i2c_dev->dma_chan);\n\n\treturn 0;\n}\n\nstatic void tegra_i2c_release_dma(struct tegra_i2c_dev *i2c_dev)\n{\n\tif (i2c_dev->dma_buf) {\n\t\tdma_free_coherent(i2c_dev->dma_dev, i2c_dev->dma_buf_size,\n\t\t\t\t  i2c_dev->dma_buf, i2c_dev->dma_phys);\n\t\ti2c_dev->dma_buf = NULL;\n\t}\n\n\tif (i2c_dev->dma_chan) {\n\t\tdma_release_channel(i2c_dev->dma_chan);\n\t\ti2c_dev->dma_chan = NULL;\n\t}\n}\n\nstatic int tegra_i2c_init_dma(struct tegra_i2c_dev *i2c_dev)\n{\n\tdma_addr_t dma_phys;\n\tu32 *dma_buf;\n\tint err;\n\n\tif (IS_VI(i2c_dev))\n\t\treturn 0;\n\n\tif (i2c_dev->hw->has_apb_dma) {\n\t\tif (!IS_ENABLED(CONFIG_TEGRA20_APB_DMA)) {\n\t\t\tdev_dbg(i2c_dev->dev, \"APB DMA support not enabled\\n\");\n\t\t\treturn 0;\n\t\t}\n\t} else if (!IS_ENABLED(CONFIG_TEGRA186_GPC_DMA)) {\n\t\tdev_dbg(i2c_dev->dev, \"GPC DMA support not enabled\\n\");\n\t\treturn 0;\n\t}\n\n\t \n\ti2c_dev->dma_chan = dma_request_chan(i2c_dev->dev, \"tx\");\n\tif (IS_ERR(i2c_dev->dma_chan)) {\n\t\terr = PTR_ERR(i2c_dev->dma_chan);\n\t\ti2c_dev->dma_chan = NULL;\n\t\tgoto err_out;\n\t}\n\n\ti2c_dev->dma_dev = i2c_dev->dma_chan->device->dev;\n\ti2c_dev->dma_buf_size = i2c_dev->hw->quirks->max_write_len +\n\t\t\t\tI2C_PACKET_HEADER_SIZE;\n\n\tdma_buf = dma_alloc_coherent(i2c_dev->dma_dev, i2c_dev->dma_buf_size,\n\t\t\t\t     &dma_phys, GFP_KERNEL | __GFP_NOWARN);\n\tif (!dma_buf) {\n\t\tdev_err(i2c_dev->dev, \"failed to allocate DMA buffer\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\n\ti2c_dev->dma_buf = dma_buf;\n\ti2c_dev->dma_phys = dma_phys;\n\n\treturn 0;\n\nerr_out:\n\ttegra_i2c_release_dma(i2c_dev);\n\tif (err != -EPROBE_DEFER) {\n\t\tdev_err(i2c_dev->dev, \"cannot use DMA: %d\\n\", err);\n\t\tdev_err(i2c_dev->dev, \"falling back to PIO\\n\");\n\t\treturn 0;\n\t}\n\n\treturn err;\n}\n\n \nstatic void tegra_dvc_init(struct tegra_i2c_dev *i2c_dev)\n{\n\tu32 val;\n\n\tval = dvc_readl(i2c_dev, DVC_CTRL_REG3);\n\tval |= DVC_CTRL_REG3_SW_PROG;\n\tval |= DVC_CTRL_REG3_I2C_DONE_INTR_EN;\n\tdvc_writel(i2c_dev, val, DVC_CTRL_REG3);\n\n\tval = dvc_readl(i2c_dev, DVC_CTRL_REG1);\n\tval |= DVC_CTRL_REG1_INTR_EN;\n\tdvc_writel(i2c_dev, val, DVC_CTRL_REG1);\n}\n\nstatic void tegra_i2c_vi_init(struct tegra_i2c_dev *i2c_dev)\n{\n\tu32 value;\n\n\tvalue = FIELD_PREP(I2C_INTERFACE_TIMING_THIGH, 2) |\n\t\tFIELD_PREP(I2C_INTERFACE_TIMING_TLOW, 4);\n\ti2c_writel(i2c_dev, value, I2C_INTERFACE_TIMING_0);\n\n\tvalue = FIELD_PREP(I2C_INTERFACE_TIMING_TBUF, 4) |\n\t\tFIELD_PREP(I2C_INTERFACE_TIMING_TSU_STO, 7) |\n\t\tFIELD_PREP(I2C_INTERFACE_TIMING_THD_STA, 4) |\n\t\tFIELD_PREP(I2C_INTERFACE_TIMING_TSU_STA, 4);\n\ti2c_writel(i2c_dev, value, I2C_INTERFACE_TIMING_1);\n\n\tvalue = FIELD_PREP(I2C_HS_INTERFACE_TIMING_THIGH, 3) |\n\t\tFIELD_PREP(I2C_HS_INTERFACE_TIMING_TLOW, 8);\n\ti2c_writel(i2c_dev, value, I2C_HS_INTERFACE_TIMING_0);\n\n\tvalue = FIELD_PREP(I2C_HS_INTERFACE_TIMING_TSU_STO, 11) |\n\t\tFIELD_PREP(I2C_HS_INTERFACE_TIMING_THD_STA, 11) |\n\t\tFIELD_PREP(I2C_HS_INTERFACE_TIMING_TSU_STA, 11);\n\ti2c_writel(i2c_dev, value, I2C_HS_INTERFACE_TIMING_1);\n\n\tvalue = FIELD_PREP(I2C_BC_SCLK_THRESHOLD, 9) | I2C_BC_STOP_COND;\n\ti2c_writel(i2c_dev, value, I2C_BUS_CLEAR_CNFG);\n\n\ti2c_writel(i2c_dev, 0x0, I2C_TLOW_SEXT);\n}\n\nstatic int tegra_i2c_poll_register(struct tegra_i2c_dev *i2c_dev,\n\t\t\t\t   u32 reg, u32 mask, u32 delay_us,\n\t\t\t\t   u32 timeout_us)\n{\n\tvoid __iomem *addr = i2c_dev->base + tegra_i2c_reg_addr(i2c_dev, reg);\n\tu32 val;\n\n\tif (!i2c_dev->atomic_mode)\n\t\treturn readl_relaxed_poll_timeout(addr, val, !(val & mask),\n\t\t\t\t\t\t  delay_us, timeout_us);\n\n\treturn readl_relaxed_poll_timeout_atomic(addr, val, !(val & mask),\n\t\t\t\t\t\t delay_us, timeout_us);\n}\n\nstatic int tegra_i2c_flush_fifos(struct tegra_i2c_dev *i2c_dev)\n{\n\tu32 mask, val, offset;\n\tint err;\n\n\tif (i2c_dev->hw->has_mst_fifo) {\n\t\tmask = I2C_MST_FIFO_CONTROL_TX_FLUSH |\n\t\t       I2C_MST_FIFO_CONTROL_RX_FLUSH;\n\t\toffset = I2C_MST_FIFO_CONTROL;\n\t} else {\n\t\tmask = I2C_FIFO_CONTROL_TX_FLUSH |\n\t\t       I2C_FIFO_CONTROL_RX_FLUSH;\n\t\toffset = I2C_FIFO_CONTROL;\n\t}\n\n\tval = i2c_readl(i2c_dev, offset);\n\tval |= mask;\n\ti2c_writel(i2c_dev, val, offset);\n\n\terr = tegra_i2c_poll_register(i2c_dev, offset, mask, 1000, 1000000);\n\tif (err) {\n\t\tdev_err(i2c_dev->dev, \"failed to flush FIFO\\n\");\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int tegra_i2c_wait_for_config_load(struct tegra_i2c_dev *i2c_dev)\n{\n\tint err;\n\n\tif (!i2c_dev->hw->has_config_load_reg)\n\t\treturn 0;\n\n\ti2c_writel(i2c_dev, I2C_MSTR_CONFIG_LOAD, I2C_CONFIG_LOAD);\n\n\terr = tegra_i2c_poll_register(i2c_dev, I2C_CONFIG_LOAD, 0xffffffff,\n\t\t\t\t      1000, I2C_CONFIG_LOAD_TIMEOUT);\n\tif (err) {\n\t\tdev_err(i2c_dev->dev, \"failed to load config\\n\");\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int tegra_i2c_init(struct tegra_i2c_dev *i2c_dev)\n{\n\tu32 val, clk_divisor, clk_multiplier, tsu_thd, tlow, thigh, non_hs_mode;\n\tacpi_handle handle = ACPI_HANDLE(i2c_dev->dev);\n\tstruct i2c_timings *t = &i2c_dev->timings;\n\tint err;\n\n\t \n\tif (handle)\n\t\terr = acpi_evaluate_object(handle, \"_RST\", NULL, NULL);\n\telse\n\t\terr = reset_control_reset(i2c_dev->rst);\n\n\tWARN_ON_ONCE(err);\n\n\tif (IS_DVC(i2c_dev))\n\t\ttegra_dvc_init(i2c_dev);\n\n\tval = I2C_CNFG_NEW_MASTER_FSM | I2C_CNFG_PACKET_MODE_EN |\n\t      FIELD_PREP(I2C_CNFG_DEBOUNCE_CNT, 2);\n\n\tif (i2c_dev->hw->has_multi_master_mode)\n\t\tval |= I2C_CNFG_MULTI_MASTER_MODE;\n\n\ti2c_writel(i2c_dev, val, I2C_CNFG);\n\ti2c_writel(i2c_dev, 0, I2C_INT_MASK);\n\n\tif (IS_VI(i2c_dev))\n\t\ttegra_i2c_vi_init(i2c_dev);\n\n\tswitch (t->bus_freq_hz) {\n\tcase I2C_MAX_STANDARD_MODE_FREQ + 1 ... I2C_MAX_FAST_MODE_PLUS_FREQ:\n\tdefault:\n\t\ttlow = i2c_dev->hw->tlow_fast_fastplus_mode;\n\t\tthigh = i2c_dev->hw->thigh_fast_fastplus_mode;\n\t\ttsu_thd = i2c_dev->hw->setup_hold_time_fast_fast_plus_mode;\n\n\t\tif (t->bus_freq_hz > I2C_MAX_FAST_MODE_FREQ)\n\t\t\tnon_hs_mode = i2c_dev->hw->clk_divisor_fast_plus_mode;\n\t\telse\n\t\t\tnon_hs_mode = i2c_dev->hw->clk_divisor_fast_mode;\n\t\tbreak;\n\n\tcase 0 ... I2C_MAX_STANDARD_MODE_FREQ:\n\t\ttlow = i2c_dev->hw->tlow_std_mode;\n\t\tthigh = i2c_dev->hw->thigh_std_mode;\n\t\ttsu_thd = i2c_dev->hw->setup_hold_time_std_mode;\n\t\tnon_hs_mode = i2c_dev->hw->clk_divisor_std_mode;\n\t\tbreak;\n\t}\n\n\t \n\tclk_divisor = FIELD_PREP(I2C_CLK_DIVISOR_HSMODE,\n\t\t\t\t i2c_dev->hw->clk_divisor_hs_mode) |\n\t\t      FIELD_PREP(I2C_CLK_DIVISOR_STD_FAST_MODE, non_hs_mode);\n\ti2c_writel(i2c_dev, clk_divisor, I2C_CLK_DIVISOR);\n\n\tif (i2c_dev->hw->has_interface_timing_reg) {\n\t\tval = FIELD_PREP(I2C_INTERFACE_TIMING_THIGH, thigh) |\n\t\t      FIELD_PREP(I2C_INTERFACE_TIMING_TLOW, tlow);\n\t\ti2c_writel(i2c_dev, val, I2C_INTERFACE_TIMING_0);\n\t}\n\n\t \n\tif (i2c_dev->hw->has_interface_timing_reg && tsu_thd)\n\t\ti2c_writel(i2c_dev, tsu_thd, I2C_INTERFACE_TIMING_1);\n\n\tclk_multiplier = (tlow + thigh + 2) * (non_hs_mode + 1);\n\n\terr = clk_set_rate(i2c_dev->div_clk,\n\t\t\t   t->bus_freq_hz * clk_multiplier);\n\tif (err) {\n\t\tdev_err(i2c_dev->dev, \"failed to set div-clk rate: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tif (!IS_DVC(i2c_dev) && !IS_VI(i2c_dev)) {\n\t\tu32 sl_cfg = i2c_readl(i2c_dev, I2C_SL_CNFG);\n\n\t\tsl_cfg |= I2C_SL_CNFG_NACK | I2C_SL_CNFG_NEWSL;\n\t\ti2c_writel(i2c_dev, sl_cfg, I2C_SL_CNFG);\n\t\ti2c_writel(i2c_dev, 0xfc, I2C_SL_ADDR1);\n\t\ti2c_writel(i2c_dev, 0x00, I2C_SL_ADDR2);\n\t}\n\n\terr = tegra_i2c_flush_fifos(i2c_dev);\n\tif (err)\n\t\treturn err;\n\n\tif (i2c_dev->multimaster_mode && i2c_dev->hw->has_slcg_override_reg)\n\t\ti2c_writel(i2c_dev, I2C_MST_CORE_CLKEN_OVR, I2C_CLKEN_OVERRIDE);\n\n\terr = tegra_i2c_wait_for_config_load(i2c_dev);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic int tegra_i2c_disable_packet_mode(struct tegra_i2c_dev *i2c_dev)\n{\n\tu32 cnfg;\n\n\t \n\tudelay(DIV_ROUND_UP(2 * 1000000, i2c_dev->timings.bus_freq_hz));\n\n\tcnfg = i2c_readl(i2c_dev, I2C_CNFG);\n\tif (cnfg & I2C_CNFG_PACKET_MODE_EN)\n\t\ti2c_writel(i2c_dev, cnfg & ~I2C_CNFG_PACKET_MODE_EN, I2C_CNFG);\n\n\treturn tegra_i2c_wait_for_config_load(i2c_dev);\n}\n\nstatic int tegra_i2c_empty_rx_fifo(struct tegra_i2c_dev *i2c_dev)\n{\n\tsize_t buf_remaining = i2c_dev->msg_buf_remaining;\n\tunsigned int words_to_transfer, rx_fifo_avail;\n\tu8 *buf = i2c_dev->msg_buf;\n\tu32 val;\n\n\t \n\tif (WARN_ON_ONCE(!(i2c_dev->msg_buf_remaining)))\n\t\treturn -EINVAL;\n\n\tif (i2c_dev->hw->has_mst_fifo) {\n\t\tval = i2c_readl(i2c_dev, I2C_MST_FIFO_STATUS);\n\t\trx_fifo_avail = FIELD_GET(I2C_MST_FIFO_STATUS_RX, val);\n\t} else {\n\t\tval = i2c_readl(i2c_dev, I2C_FIFO_STATUS);\n\t\trx_fifo_avail = FIELD_GET(I2C_FIFO_STATUS_RX, val);\n\t}\n\n\t \n\twords_to_transfer = buf_remaining / BYTES_PER_FIFO_WORD;\n\tif (words_to_transfer > rx_fifo_avail)\n\t\twords_to_transfer = rx_fifo_avail;\n\n\ti2c_readsl(i2c_dev, buf, I2C_RX_FIFO, words_to_transfer);\n\n\tbuf += words_to_transfer * BYTES_PER_FIFO_WORD;\n\tbuf_remaining -= words_to_transfer * BYTES_PER_FIFO_WORD;\n\trx_fifo_avail -= words_to_transfer;\n\n\t \n\tif (rx_fifo_avail > 0 && buf_remaining > 0) {\n\t\t \n\t\tval = i2c_readl(i2c_dev, I2C_RX_FIFO);\n\t\tval = cpu_to_le32(val);\n\t\tmemcpy(buf, &val, buf_remaining);\n\t\tbuf_remaining = 0;\n\t\trx_fifo_avail--;\n\t}\n\n\t \n\tif (WARN_ON_ONCE(rx_fifo_avail))\n\t\treturn -EINVAL;\n\n\ti2c_dev->msg_buf_remaining = buf_remaining;\n\ti2c_dev->msg_buf = buf;\n\n\treturn 0;\n}\n\nstatic int tegra_i2c_fill_tx_fifo(struct tegra_i2c_dev *i2c_dev)\n{\n\tsize_t buf_remaining = i2c_dev->msg_buf_remaining;\n\tunsigned int words_to_transfer, tx_fifo_avail;\n\tu8 *buf = i2c_dev->msg_buf;\n\tu32 val;\n\n\tif (i2c_dev->hw->has_mst_fifo) {\n\t\tval = i2c_readl(i2c_dev, I2C_MST_FIFO_STATUS);\n\t\ttx_fifo_avail = FIELD_GET(I2C_MST_FIFO_STATUS_TX, val);\n\t} else {\n\t\tval = i2c_readl(i2c_dev, I2C_FIFO_STATUS);\n\t\ttx_fifo_avail = FIELD_GET(I2C_FIFO_STATUS_TX, val);\n\t}\n\n\t \n\twords_to_transfer = buf_remaining / BYTES_PER_FIFO_WORD;\n\n\t \n\tif (words_to_transfer) {\n\t\tif (words_to_transfer > tx_fifo_avail)\n\t\t\twords_to_transfer = tx_fifo_avail;\n\n\t\t \n\t\tbuf_remaining -= words_to_transfer * BYTES_PER_FIFO_WORD;\n\t\ttx_fifo_avail -= words_to_transfer;\n\n\t\ti2c_dev->msg_buf_remaining = buf_remaining;\n\t\ti2c_dev->msg_buf = buf + words_to_transfer * BYTES_PER_FIFO_WORD;\n\n\t\tif (IS_VI(i2c_dev))\n\t\t\ti2c_writesl_vi(i2c_dev, buf, I2C_TX_FIFO, words_to_transfer);\n\t\telse\n\t\t\ti2c_writesl(i2c_dev, buf, I2C_TX_FIFO, words_to_transfer);\n\n\t\tbuf += words_to_transfer * BYTES_PER_FIFO_WORD;\n\t}\n\n\t \n\tif (tx_fifo_avail > 0 && buf_remaining > 0) {\n\t\t \n\t\tmemcpy(&val, buf, buf_remaining);\n\t\tval = le32_to_cpu(val);\n\n\t\ti2c_dev->msg_buf_remaining = 0;\n\t\ti2c_dev->msg_buf = NULL;\n\n\t\ti2c_writel(i2c_dev, val, I2C_TX_FIFO);\n\t}\n\n\treturn 0;\n}\n\nstatic irqreturn_t tegra_i2c_isr(int irq, void *dev_id)\n{\n\tconst u32 status_err = I2C_INT_NO_ACK | I2C_INT_ARBITRATION_LOST;\n\tstruct tegra_i2c_dev *i2c_dev = dev_id;\n\tu32 status;\n\n\tstatus = i2c_readl(i2c_dev, I2C_INT_STATUS);\n\n\tif (status == 0) {\n\t\tdev_warn(i2c_dev->dev, \"IRQ status 0 %08x %08x %08x\\n\",\n\t\t\t i2c_readl(i2c_dev, I2C_PACKET_TRANSFER_STATUS),\n\t\t\t i2c_readl(i2c_dev, I2C_STATUS),\n\t\t\t i2c_readl(i2c_dev, I2C_CNFG));\n\t\ti2c_dev->msg_err |= I2C_ERR_UNKNOWN_INTERRUPT;\n\t\tgoto err;\n\t}\n\n\tif (status & status_err) {\n\t\ttegra_i2c_disable_packet_mode(i2c_dev);\n\t\tif (status & I2C_INT_NO_ACK)\n\t\t\ti2c_dev->msg_err |= I2C_ERR_NO_ACK;\n\t\tif (status & I2C_INT_ARBITRATION_LOST)\n\t\t\ti2c_dev->msg_err |= I2C_ERR_ARBITRATION_LOST;\n\t\tgoto err;\n\t}\n\n\t \n\tif (i2c_dev->hw->supports_bus_clear && (status & I2C_INT_BUS_CLR_DONE))\n\t\tgoto err;\n\n\tif (!i2c_dev->dma_mode) {\n\t\tif (i2c_dev->msg_read && (status & I2C_INT_RX_FIFO_DATA_REQ)) {\n\t\t\tif (tegra_i2c_empty_rx_fifo(i2c_dev)) {\n\t\t\t\t \n\t\t\t\ti2c_dev->msg_err |= I2C_ERR_RX_BUFFER_OVERFLOW;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\n\t\tif (!i2c_dev->msg_read && (status & I2C_INT_TX_FIFO_DATA_REQ)) {\n\t\t\tif (i2c_dev->msg_buf_remaining)\n\t\t\t\ttegra_i2c_fill_tx_fifo(i2c_dev);\n\t\t\telse\n\t\t\t\ttegra_i2c_mask_irq(i2c_dev,\n\t\t\t\t\t\t   I2C_INT_TX_FIFO_DATA_REQ);\n\t\t}\n\t}\n\n\ti2c_writel(i2c_dev, status, I2C_INT_STATUS);\n\tif (IS_DVC(i2c_dev))\n\t\tdvc_writel(i2c_dev, DVC_STATUS_I2C_DONE_INTR, DVC_STATUS);\n\n\t \n\tif (status & I2C_INT_PACKET_XFER_COMPLETE) {\n\t\tif (i2c_dev->dma_mode)\n\t\t\ti2c_dev->msg_buf_remaining = 0;\n\t\t \n\t\tif (WARN_ON_ONCE(i2c_dev->msg_buf_remaining)) {\n\t\t\ti2c_dev->msg_err |= I2C_ERR_UNKNOWN_INTERRUPT;\n\t\t\tgoto err;\n\t\t}\n\t\tcomplete(&i2c_dev->msg_complete);\n\t}\n\tgoto done;\nerr:\n\t \n\ttegra_i2c_mask_irq(i2c_dev,\n\t\t\t   I2C_INT_NO_ACK |\n\t\t\t   I2C_INT_ARBITRATION_LOST |\n\t\t\t   I2C_INT_PACKET_XFER_COMPLETE |\n\t\t\t   I2C_INT_TX_FIFO_DATA_REQ |\n\t\t\t   I2C_INT_RX_FIFO_DATA_REQ);\n\n\tif (i2c_dev->hw->supports_bus_clear)\n\t\ttegra_i2c_mask_irq(i2c_dev, I2C_INT_BUS_CLR_DONE);\n\n\ti2c_writel(i2c_dev, status, I2C_INT_STATUS);\n\n\tif (IS_DVC(i2c_dev))\n\t\tdvc_writel(i2c_dev, DVC_STATUS_I2C_DONE_INTR, DVC_STATUS);\n\n\tif (i2c_dev->dma_mode) {\n\t\tdmaengine_terminate_async(i2c_dev->dma_chan);\n\t\tcomplete(&i2c_dev->dma_complete);\n\t}\n\n\tcomplete(&i2c_dev->msg_complete);\ndone:\n\treturn IRQ_HANDLED;\n}\n\nstatic void tegra_i2c_config_fifo_trig(struct tegra_i2c_dev *i2c_dev,\n\t\t\t\t       size_t len)\n{\n\tstruct dma_slave_config slv_config = {0};\n\tu32 val, reg, dma_burst, reg_offset;\n\tint err;\n\n\tif (i2c_dev->hw->has_mst_fifo)\n\t\treg = I2C_MST_FIFO_CONTROL;\n\telse\n\t\treg = I2C_FIFO_CONTROL;\n\n\tif (i2c_dev->dma_mode) {\n\t\tif (len & 0xF)\n\t\t\tdma_burst = 1;\n\t\telse if (len & 0x10)\n\t\t\tdma_burst = 4;\n\t\telse\n\t\t\tdma_burst = 8;\n\n\t\tif (i2c_dev->msg_read) {\n\t\t\treg_offset = tegra_i2c_reg_addr(i2c_dev, I2C_RX_FIFO);\n\n\t\t\tslv_config.src_addr = i2c_dev->base_phys + reg_offset;\n\t\t\tslv_config.src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\n\t\t\tslv_config.src_maxburst = dma_burst;\n\n\t\t\tif (i2c_dev->hw->has_mst_fifo)\n\t\t\t\tval = I2C_MST_FIFO_CONTROL_RX_TRIG(dma_burst);\n\t\t\telse\n\t\t\t\tval = I2C_FIFO_CONTROL_RX_TRIG(dma_burst);\n\t\t} else {\n\t\t\treg_offset = tegra_i2c_reg_addr(i2c_dev, I2C_TX_FIFO);\n\n\t\t\tslv_config.dst_addr = i2c_dev->base_phys + reg_offset;\n\t\t\tslv_config.dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\n\t\t\tslv_config.dst_maxburst = dma_burst;\n\n\t\t\tif (i2c_dev->hw->has_mst_fifo)\n\t\t\t\tval = I2C_MST_FIFO_CONTROL_TX_TRIG(dma_burst);\n\t\t\telse\n\t\t\t\tval = I2C_FIFO_CONTROL_TX_TRIG(dma_burst);\n\t\t}\n\n\t\tslv_config.device_fc = true;\n\t\terr = dmaengine_slave_config(i2c_dev->dma_chan, &slv_config);\n\t\tif (err) {\n\t\t\tdev_err(i2c_dev->dev, \"DMA config failed: %d\\n\", err);\n\t\t\tdev_err(i2c_dev->dev, \"falling back to PIO\\n\");\n\n\t\t\ttegra_i2c_release_dma(i2c_dev);\n\t\t\ti2c_dev->dma_mode = false;\n\t\t} else {\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (i2c_dev->hw->has_mst_fifo)\n\t\tval = I2C_MST_FIFO_CONTROL_TX_TRIG(8) |\n\t\t      I2C_MST_FIFO_CONTROL_RX_TRIG(1);\n\telse\n\t\tval = I2C_FIFO_CONTROL_TX_TRIG(8) |\n\t\t      I2C_FIFO_CONTROL_RX_TRIG(1);\nout:\n\ti2c_writel(i2c_dev, val, reg);\n}\n\nstatic unsigned long tegra_i2c_poll_completion(struct tegra_i2c_dev *i2c_dev,\n\t\t\t\t\t       struct completion *complete,\n\t\t\t\t\t       unsigned int timeout_ms)\n{\n\tktime_t ktime = ktime_get();\n\tktime_t ktimeout = ktime_add_ms(ktime, timeout_ms);\n\n\tdo {\n\t\tu32 status = i2c_readl(i2c_dev, I2C_INT_STATUS);\n\n\t\tif (status)\n\t\t\ttegra_i2c_isr(i2c_dev->irq, i2c_dev);\n\n\t\tif (completion_done(complete)) {\n\t\t\ts64 delta = ktime_ms_delta(ktimeout, ktime);\n\n\t\t\treturn msecs_to_jiffies(delta) ?: 1;\n\t\t}\n\n\t\tktime = ktime_get();\n\n\t} while (ktime_before(ktime, ktimeout));\n\n\treturn 0;\n}\n\nstatic unsigned long tegra_i2c_wait_completion(struct tegra_i2c_dev *i2c_dev,\n\t\t\t\t\t       struct completion *complete,\n\t\t\t\t\t       unsigned int timeout_ms)\n{\n\tunsigned long ret;\n\n\tif (i2c_dev->atomic_mode) {\n\t\tret = tegra_i2c_poll_completion(i2c_dev, complete, timeout_ms);\n\t} else {\n\t\tenable_irq(i2c_dev->irq);\n\t\tret = wait_for_completion_timeout(complete,\n\t\t\t\t\t\t  msecs_to_jiffies(timeout_ms));\n\t\tdisable_irq(i2c_dev->irq);\n\n\t\t \n\t\tif (ret == 0)\n\t\t\tret = tegra_i2c_poll_completion(i2c_dev, complete, 0);\n\t}\n\n\treturn ret;\n}\n\nstatic int tegra_i2c_issue_bus_clear(struct i2c_adapter *adap)\n{\n\tstruct tegra_i2c_dev *i2c_dev = i2c_get_adapdata(adap);\n\tu32 val, time_left;\n\tint err;\n\n\treinit_completion(&i2c_dev->msg_complete);\n\n\tval = FIELD_PREP(I2C_BC_SCLK_THRESHOLD, 9) | I2C_BC_STOP_COND |\n\t      I2C_BC_TERMINATE;\n\ti2c_writel(i2c_dev, val, I2C_BUS_CLEAR_CNFG);\n\n\terr = tegra_i2c_wait_for_config_load(i2c_dev);\n\tif (err)\n\t\treturn err;\n\n\tval |= I2C_BC_ENABLE;\n\ti2c_writel(i2c_dev, val, I2C_BUS_CLEAR_CNFG);\n\ttegra_i2c_unmask_irq(i2c_dev, I2C_INT_BUS_CLR_DONE);\n\n\ttime_left = tegra_i2c_wait_completion(i2c_dev, &i2c_dev->msg_complete, 50);\n\ttegra_i2c_mask_irq(i2c_dev, I2C_INT_BUS_CLR_DONE);\n\n\tif (time_left == 0) {\n\t\tdev_err(i2c_dev->dev, \"failed to clear bus\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tval = i2c_readl(i2c_dev, I2C_BUS_CLEAR_STATUS);\n\tif (!(val & I2C_BC_STATUS)) {\n\t\tdev_err(i2c_dev->dev, \"un-recovered arbitration lost\\n\");\n\t\treturn -EIO;\n\t}\n\n\treturn -EAGAIN;\n}\n\nstatic void tegra_i2c_push_packet_header(struct tegra_i2c_dev *i2c_dev,\n\t\t\t\t\t struct i2c_msg *msg,\n\t\t\t\t\t enum msg_end_type end_state)\n{\n\tu32 *dma_buf = i2c_dev->dma_buf;\n\tu32 packet_header;\n\n\tpacket_header = FIELD_PREP(PACKET_HEADER0_HEADER_SIZE, 0) |\n\t\t\tFIELD_PREP(PACKET_HEADER0_PROTOCOL,\n\t\t\t\t   PACKET_HEADER0_PROTOCOL_I2C) |\n\t\t\tFIELD_PREP(PACKET_HEADER0_CONT_ID, i2c_dev->cont_id) |\n\t\t\tFIELD_PREP(PACKET_HEADER0_PACKET_ID, 1);\n\n\tif (i2c_dev->dma_mode && !i2c_dev->msg_read)\n\t\t*dma_buf++ = packet_header;\n\telse\n\t\ti2c_writel(i2c_dev, packet_header, I2C_TX_FIFO);\n\n\tpacket_header = i2c_dev->msg_len - 1;\n\n\tif (i2c_dev->dma_mode && !i2c_dev->msg_read)\n\t\t*dma_buf++ = packet_header;\n\telse\n\t\ti2c_writel(i2c_dev, packet_header, I2C_TX_FIFO);\n\n\tpacket_header = I2C_HEADER_IE_ENABLE;\n\n\tif (end_state == MSG_END_CONTINUE)\n\t\tpacket_header |= I2C_HEADER_CONTINUE_XFER;\n\telse if (end_state == MSG_END_REPEAT_START)\n\t\tpacket_header |= I2C_HEADER_REPEAT_START;\n\n\tif (msg->flags & I2C_M_TEN) {\n\t\tpacket_header |= msg->addr;\n\t\tpacket_header |= I2C_HEADER_10BIT_ADDR;\n\t} else {\n\t\tpacket_header |= msg->addr << I2C_HEADER_SLAVE_ADDR_SHIFT;\n\t}\n\n\tif (msg->flags & I2C_M_IGNORE_NAK)\n\t\tpacket_header |= I2C_HEADER_CONT_ON_NAK;\n\n\tif (msg->flags & I2C_M_RD)\n\t\tpacket_header |= I2C_HEADER_READ;\n\n\tif (i2c_dev->dma_mode && !i2c_dev->msg_read)\n\t\t*dma_buf++ = packet_header;\n\telse\n\t\ti2c_writel(i2c_dev, packet_header, I2C_TX_FIFO);\n}\n\nstatic int tegra_i2c_error_recover(struct tegra_i2c_dev *i2c_dev,\n\t\t\t\t   struct i2c_msg *msg)\n{\n\tif (i2c_dev->msg_err == I2C_ERR_NONE)\n\t\treturn 0;\n\n\ttegra_i2c_init(i2c_dev);\n\n\t \n\tif (i2c_dev->msg_err == I2C_ERR_ARBITRATION_LOST) {\n\t\tif (!i2c_dev->multimaster_mode)\n\t\t\treturn i2c_recover_bus(&i2c_dev->adapter);\n\n\t\treturn -EAGAIN;\n\t}\n\n\tif (i2c_dev->msg_err == I2C_ERR_NO_ACK) {\n\t\tif (msg->flags & I2C_M_IGNORE_NAK)\n\t\t\treturn 0;\n\n\t\treturn -EREMOTEIO;\n\t}\n\n\treturn -EIO;\n}\n\nstatic int tegra_i2c_xfer_msg(struct tegra_i2c_dev *i2c_dev,\n\t\t\t      struct i2c_msg *msg,\n\t\t\t      enum msg_end_type end_state)\n{\n\tunsigned long time_left, xfer_time = 100;\n\tsize_t xfer_size;\n\tu32 int_mask;\n\tint err;\n\n\terr = tegra_i2c_flush_fifos(i2c_dev);\n\tif (err)\n\t\treturn err;\n\n\ti2c_dev->msg_buf = msg->buf;\n\ti2c_dev->msg_len = msg->len;\n\n\ti2c_dev->msg_err = I2C_ERR_NONE;\n\ti2c_dev->msg_read = !!(msg->flags & I2C_M_RD);\n\treinit_completion(&i2c_dev->msg_complete);\n\n\t \n\tif (msg->flags & I2C_M_RECV_LEN) {\n\t\tif (end_state == MSG_END_CONTINUE) {\n\t\t\ti2c_dev->msg_len = 1;\n\t\t} else {\n\t\t\ti2c_dev->msg_buf += 1;\n\t\t\ti2c_dev->msg_len -= 1;\n\t\t}\n\t}\n\n\ti2c_dev->msg_buf_remaining = i2c_dev->msg_len;\n\n\tif (i2c_dev->msg_read)\n\t\txfer_size = i2c_dev->msg_len;\n\telse\n\t\txfer_size = i2c_dev->msg_len + I2C_PACKET_HEADER_SIZE;\n\n\txfer_size = ALIGN(xfer_size, BYTES_PER_FIFO_WORD);\n\n\ti2c_dev->dma_mode = xfer_size > I2C_PIO_MODE_PREFERRED_LEN &&\n\t\t\t    i2c_dev->dma_buf && !i2c_dev->atomic_mode;\n\n\ttegra_i2c_config_fifo_trig(i2c_dev, xfer_size);\n\n\t \n\txfer_time += DIV_ROUND_CLOSEST(((xfer_size * 9) + 2) * MSEC_PER_SEC,\n\t\t\t\t       i2c_dev->timings.bus_freq_hz);\n\n\tint_mask = I2C_INT_NO_ACK | I2C_INT_ARBITRATION_LOST;\n\ttegra_i2c_unmask_irq(i2c_dev, int_mask);\n\n\tif (i2c_dev->dma_mode) {\n\t\tif (i2c_dev->msg_read) {\n\t\t\tdma_sync_single_for_device(i2c_dev->dma_dev,\n\t\t\t\t\t\t   i2c_dev->dma_phys,\n\t\t\t\t\t\t   xfer_size, DMA_FROM_DEVICE);\n\n\t\t\terr = tegra_i2c_dma_submit(i2c_dev, xfer_size);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t} else {\n\t\t\tdma_sync_single_for_cpu(i2c_dev->dma_dev,\n\t\t\t\t\t\ti2c_dev->dma_phys,\n\t\t\t\t\t\txfer_size, DMA_TO_DEVICE);\n\t\t}\n\t}\n\n\ttegra_i2c_push_packet_header(i2c_dev, msg, end_state);\n\n\tif (!i2c_dev->msg_read) {\n\t\tif (i2c_dev->dma_mode) {\n\t\t\tmemcpy(i2c_dev->dma_buf + I2C_PACKET_HEADER_SIZE,\n\t\t\t       msg->buf, i2c_dev->msg_len);\n\n\t\t\tdma_sync_single_for_device(i2c_dev->dma_dev,\n\t\t\t\t\t\t   i2c_dev->dma_phys,\n\t\t\t\t\t\t   xfer_size, DMA_TO_DEVICE);\n\n\t\t\terr = tegra_i2c_dma_submit(i2c_dev, xfer_size);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t} else {\n\t\t\ttegra_i2c_fill_tx_fifo(i2c_dev);\n\t\t}\n\t}\n\n\tif (i2c_dev->hw->has_per_pkt_xfer_complete_irq)\n\t\tint_mask |= I2C_INT_PACKET_XFER_COMPLETE;\n\n\tif (!i2c_dev->dma_mode) {\n\t\tif (msg->flags & I2C_M_RD)\n\t\t\tint_mask |= I2C_INT_RX_FIFO_DATA_REQ;\n\t\telse if (i2c_dev->msg_buf_remaining)\n\t\t\tint_mask |= I2C_INT_TX_FIFO_DATA_REQ;\n\t}\n\n\ttegra_i2c_unmask_irq(i2c_dev, int_mask);\n\tdev_dbg(i2c_dev->dev, \"unmasked IRQ: %02x\\n\",\n\t\ti2c_readl(i2c_dev, I2C_INT_MASK));\n\n\tif (i2c_dev->dma_mode) {\n\t\ttime_left = tegra_i2c_wait_completion(i2c_dev,\n\t\t\t\t\t\t      &i2c_dev->dma_complete,\n\t\t\t\t\t\t      xfer_time);\n\n\t\t \n\t\tdmaengine_synchronize(i2c_dev->dma_chan);\n\t\tdmaengine_terminate_sync(i2c_dev->dma_chan);\n\n\t\tif (!time_left && !completion_done(&i2c_dev->dma_complete)) {\n\t\t\tdev_err(i2c_dev->dev, \"DMA transfer timed out\\n\");\n\t\t\ttegra_i2c_init(i2c_dev);\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\n\t\tif (i2c_dev->msg_read && i2c_dev->msg_err == I2C_ERR_NONE) {\n\t\t\tdma_sync_single_for_cpu(i2c_dev->dma_dev,\n\t\t\t\t\t\ti2c_dev->dma_phys,\n\t\t\t\t\t\txfer_size, DMA_FROM_DEVICE);\n\n\t\t\tmemcpy(i2c_dev->msg_buf, i2c_dev->dma_buf, i2c_dev->msg_len);\n\t\t}\n\t}\n\n\ttime_left = tegra_i2c_wait_completion(i2c_dev, &i2c_dev->msg_complete,\n\t\t\t\t\t      xfer_time);\n\n\ttegra_i2c_mask_irq(i2c_dev, int_mask);\n\n\tif (time_left == 0) {\n\t\tdev_err(i2c_dev->dev, \"I2C transfer timed out\\n\");\n\t\ttegra_i2c_init(i2c_dev);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tdev_dbg(i2c_dev->dev, \"transfer complete: %lu %d %d\\n\",\n\t\ttime_left, completion_done(&i2c_dev->msg_complete),\n\t\ti2c_dev->msg_err);\n\n\ti2c_dev->dma_mode = false;\n\n\terr = tegra_i2c_error_recover(i2c_dev, msg);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic int tegra_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg msgs[],\n\t\t\t  int num)\n{\n\tstruct tegra_i2c_dev *i2c_dev = i2c_get_adapdata(adap);\n\tint i, ret;\n\n\tret = pm_runtime_get_sync(i2c_dev->dev);\n\tif (ret < 0) {\n\t\tdev_err(i2c_dev->dev, \"runtime resume failed %d\\n\", ret);\n\t\tpm_runtime_put_noidle(i2c_dev->dev);\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < num; i++) {\n\t\tenum msg_end_type end_type = MSG_END_STOP;\n\n\t\tif (i < (num - 1)) {\n\t\t\t \n\t\t\tif (msgs[i + 1].flags & I2C_M_NOSTART)\n\t\t\t\tend_type = MSG_END_CONTINUE;\n\t\t\telse\n\t\t\t\tend_type = MSG_END_REPEAT_START;\n\t\t}\n\t\t \n\t\tif (msgs[i].flags & I2C_M_RECV_LEN) {\n\t\t\tret = tegra_i2c_xfer_msg(i2c_dev, &msgs[i], MSG_END_CONTINUE);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t\t \n\t\t\tmsgs[i].len += msgs[i].buf[0];\n\t\t\tdev_dbg(i2c_dev->dev, \"reading %d bytes\\n\", msgs[i].len);\n\t\t}\n\t\tret = tegra_i2c_xfer_msg(i2c_dev, &msgs[i], end_type);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\tpm_runtime_put(i2c_dev->dev);\n\n\treturn ret ?: i;\n}\n\nstatic int tegra_i2c_xfer_atomic(struct i2c_adapter *adap,\n\t\t\t\t struct i2c_msg msgs[], int num)\n{\n\tstruct tegra_i2c_dev *i2c_dev = i2c_get_adapdata(adap);\n\tint ret;\n\n\ti2c_dev->atomic_mode = true;\n\tret = tegra_i2c_xfer(adap, msgs, num);\n\ti2c_dev->atomic_mode = false;\n\n\treturn ret;\n}\n\nstatic u32 tegra_i2c_func(struct i2c_adapter *adap)\n{\n\tstruct tegra_i2c_dev *i2c_dev = i2c_get_adapdata(adap);\n\tu32 ret = I2C_FUNC_I2C | (I2C_FUNC_SMBUS_EMUL & ~I2C_FUNC_SMBUS_QUICK) |\n\t\t  I2C_FUNC_10BIT_ADDR | I2C_FUNC_PROTOCOL_MANGLING;\n\n\tif (i2c_dev->hw->has_continue_xfer_support)\n\t\tret |= I2C_FUNC_NOSTART | I2C_FUNC_SMBUS_READ_BLOCK_DATA;\n\n\treturn ret;\n}\n\nstatic const struct i2c_algorithm tegra_i2c_algo = {\n\t.master_xfer\t\t= tegra_i2c_xfer,\n\t.master_xfer_atomic\t= tegra_i2c_xfer_atomic,\n\t.functionality\t\t= tegra_i2c_func,\n};\n\n \nstatic const struct i2c_adapter_quirks tegra_i2c_quirks = {\n\t.flags = I2C_AQ_NO_ZERO_LEN,\n\t.max_read_len = SZ_4K,\n\t.max_write_len = SZ_4K - I2C_PACKET_HEADER_SIZE,\n};\n\nstatic const struct i2c_adapter_quirks tegra194_i2c_quirks = {\n\t.flags = I2C_AQ_NO_ZERO_LEN,\n\t.max_write_len = SZ_64K - I2C_PACKET_HEADER_SIZE,\n};\n\nstatic struct i2c_bus_recovery_info tegra_i2c_recovery_info = {\n\t.recover_bus = tegra_i2c_issue_bus_clear,\n};\n\nstatic const struct tegra_i2c_hw_feature tegra20_i2c_hw = {\n\t.has_continue_xfer_support = false,\n\t.has_per_pkt_xfer_complete_irq = false,\n\t.clk_divisor_hs_mode = 3,\n\t.clk_divisor_std_mode = 0,\n\t.clk_divisor_fast_mode = 0,\n\t.clk_divisor_fast_plus_mode = 0,\n\t.has_config_load_reg = false,\n\t.has_multi_master_mode = false,\n\t.has_slcg_override_reg = false,\n\t.has_mst_fifo = false,\n\t.quirks = &tegra_i2c_quirks,\n\t.supports_bus_clear = false,\n\t.has_apb_dma = true,\n\t.tlow_std_mode = 0x4,\n\t.thigh_std_mode = 0x2,\n\t.tlow_fast_fastplus_mode = 0x4,\n\t.thigh_fast_fastplus_mode = 0x2,\n\t.setup_hold_time_std_mode = 0x0,\n\t.setup_hold_time_fast_fast_plus_mode = 0x0,\n\t.setup_hold_time_hs_mode = 0x0,\n\t.has_interface_timing_reg = false,\n};\n\nstatic const struct tegra_i2c_hw_feature tegra30_i2c_hw = {\n\t.has_continue_xfer_support = true,\n\t.has_per_pkt_xfer_complete_irq = false,\n\t.clk_divisor_hs_mode = 3,\n\t.clk_divisor_std_mode = 0,\n\t.clk_divisor_fast_mode = 0,\n\t.clk_divisor_fast_plus_mode = 0,\n\t.has_config_load_reg = false,\n\t.has_multi_master_mode = false,\n\t.has_slcg_override_reg = false,\n\t.has_mst_fifo = false,\n\t.quirks = &tegra_i2c_quirks,\n\t.supports_bus_clear = false,\n\t.has_apb_dma = true,\n\t.tlow_std_mode = 0x4,\n\t.thigh_std_mode = 0x2,\n\t.tlow_fast_fastplus_mode = 0x4,\n\t.thigh_fast_fastplus_mode = 0x2,\n\t.setup_hold_time_std_mode = 0x0,\n\t.setup_hold_time_fast_fast_plus_mode = 0x0,\n\t.setup_hold_time_hs_mode = 0x0,\n\t.has_interface_timing_reg = false,\n};\n\nstatic const struct tegra_i2c_hw_feature tegra114_i2c_hw = {\n\t.has_continue_xfer_support = true,\n\t.has_per_pkt_xfer_complete_irq = true,\n\t.clk_divisor_hs_mode = 1,\n\t.clk_divisor_std_mode = 0x19,\n\t.clk_divisor_fast_mode = 0x19,\n\t.clk_divisor_fast_plus_mode = 0x10,\n\t.has_config_load_reg = false,\n\t.has_multi_master_mode = false,\n\t.has_slcg_override_reg = false,\n\t.has_mst_fifo = false,\n\t.quirks = &tegra_i2c_quirks,\n\t.supports_bus_clear = true,\n\t.has_apb_dma = true,\n\t.tlow_std_mode = 0x4,\n\t.thigh_std_mode = 0x2,\n\t.tlow_fast_fastplus_mode = 0x4,\n\t.thigh_fast_fastplus_mode = 0x2,\n\t.setup_hold_time_std_mode = 0x0,\n\t.setup_hold_time_fast_fast_plus_mode = 0x0,\n\t.setup_hold_time_hs_mode = 0x0,\n\t.has_interface_timing_reg = false,\n};\n\nstatic const struct tegra_i2c_hw_feature tegra124_i2c_hw = {\n\t.has_continue_xfer_support = true,\n\t.has_per_pkt_xfer_complete_irq = true,\n\t.clk_divisor_hs_mode = 1,\n\t.clk_divisor_std_mode = 0x19,\n\t.clk_divisor_fast_mode = 0x19,\n\t.clk_divisor_fast_plus_mode = 0x10,\n\t.has_config_load_reg = true,\n\t.has_multi_master_mode = false,\n\t.has_slcg_override_reg = true,\n\t.has_mst_fifo = false,\n\t.quirks = &tegra_i2c_quirks,\n\t.supports_bus_clear = true,\n\t.has_apb_dma = true,\n\t.tlow_std_mode = 0x4,\n\t.thigh_std_mode = 0x2,\n\t.tlow_fast_fastplus_mode = 0x4,\n\t.thigh_fast_fastplus_mode = 0x2,\n\t.setup_hold_time_std_mode = 0x0,\n\t.setup_hold_time_fast_fast_plus_mode = 0x0,\n\t.setup_hold_time_hs_mode = 0x0,\n\t.has_interface_timing_reg = true,\n};\n\nstatic const struct tegra_i2c_hw_feature tegra210_i2c_hw = {\n\t.has_continue_xfer_support = true,\n\t.has_per_pkt_xfer_complete_irq = true,\n\t.clk_divisor_hs_mode = 1,\n\t.clk_divisor_std_mode = 0x19,\n\t.clk_divisor_fast_mode = 0x19,\n\t.clk_divisor_fast_plus_mode = 0x10,\n\t.has_config_load_reg = true,\n\t.has_multi_master_mode = false,\n\t.has_slcg_override_reg = true,\n\t.has_mst_fifo = false,\n\t.quirks = &tegra_i2c_quirks,\n\t.supports_bus_clear = true,\n\t.has_apb_dma = true,\n\t.tlow_std_mode = 0x4,\n\t.thigh_std_mode = 0x2,\n\t.tlow_fast_fastplus_mode = 0x4,\n\t.thigh_fast_fastplus_mode = 0x2,\n\t.setup_hold_time_std_mode = 0,\n\t.setup_hold_time_fast_fast_plus_mode = 0,\n\t.setup_hold_time_hs_mode = 0,\n\t.has_interface_timing_reg = true,\n};\n\nstatic const struct tegra_i2c_hw_feature tegra186_i2c_hw = {\n\t.has_continue_xfer_support = true,\n\t.has_per_pkt_xfer_complete_irq = true,\n\t.clk_divisor_hs_mode = 1,\n\t.clk_divisor_std_mode = 0x16,\n\t.clk_divisor_fast_mode = 0x19,\n\t.clk_divisor_fast_plus_mode = 0x10,\n\t.has_config_load_reg = true,\n\t.has_multi_master_mode = false,\n\t.has_slcg_override_reg = true,\n\t.has_mst_fifo = false,\n\t.quirks = &tegra_i2c_quirks,\n\t.supports_bus_clear = true,\n\t.has_apb_dma = false,\n\t.tlow_std_mode = 0x4,\n\t.thigh_std_mode = 0x3,\n\t.tlow_fast_fastplus_mode = 0x4,\n\t.thigh_fast_fastplus_mode = 0x2,\n\t.setup_hold_time_std_mode = 0,\n\t.setup_hold_time_fast_fast_plus_mode = 0,\n\t.setup_hold_time_hs_mode = 0,\n\t.has_interface_timing_reg = true,\n};\n\nstatic const struct tegra_i2c_hw_feature tegra194_i2c_hw = {\n\t.has_continue_xfer_support = true,\n\t.has_per_pkt_xfer_complete_irq = true,\n\t.clk_divisor_hs_mode = 1,\n\t.clk_divisor_std_mode = 0x4f,\n\t.clk_divisor_fast_mode = 0x3c,\n\t.clk_divisor_fast_plus_mode = 0x16,\n\t.has_config_load_reg = true,\n\t.has_multi_master_mode = true,\n\t.has_slcg_override_reg = true,\n\t.has_mst_fifo = true,\n\t.quirks = &tegra194_i2c_quirks,\n\t.supports_bus_clear = true,\n\t.has_apb_dma = false,\n\t.tlow_std_mode = 0x8,\n\t.thigh_std_mode = 0x7,\n\t.tlow_fast_fastplus_mode = 0x2,\n\t.thigh_fast_fastplus_mode = 0x2,\n\t.setup_hold_time_std_mode = 0x08080808,\n\t.setup_hold_time_fast_fast_plus_mode = 0x02020202,\n\t.setup_hold_time_hs_mode = 0x090909,\n\t.has_interface_timing_reg = true,\n};\n\nstatic const struct of_device_id tegra_i2c_of_match[] = {\n\t{ .compatible = \"nvidia,tegra194-i2c\", .data = &tegra194_i2c_hw, },\n\t{ .compatible = \"nvidia,tegra186-i2c\", .data = &tegra186_i2c_hw, },\n#if IS_ENABLED(CONFIG_ARCH_TEGRA_210_SOC)\n\t{ .compatible = \"nvidia,tegra210-i2c-vi\", .data = &tegra210_i2c_hw, },\n#endif\n\t{ .compatible = \"nvidia,tegra210-i2c\", .data = &tegra210_i2c_hw, },\n\t{ .compatible = \"nvidia,tegra124-i2c\", .data = &tegra124_i2c_hw, },\n\t{ .compatible = \"nvidia,tegra114-i2c\", .data = &tegra114_i2c_hw, },\n\t{ .compatible = \"nvidia,tegra30-i2c\", .data = &tegra30_i2c_hw, },\n\t{ .compatible = \"nvidia,tegra20-i2c\", .data = &tegra20_i2c_hw, },\n#if IS_ENABLED(CONFIG_ARCH_TEGRA_2x_SOC)\n\t{ .compatible = \"nvidia,tegra20-i2c-dvc\", .data = &tegra20_i2c_hw, },\n#endif\n\t{},\n};\nMODULE_DEVICE_TABLE(of, tegra_i2c_of_match);\n\nstatic void tegra_i2c_parse_dt(struct tegra_i2c_dev *i2c_dev)\n{\n\tstruct device_node *np = i2c_dev->dev->of_node;\n\tbool multi_mode;\n\n\ti2c_parse_fw_timings(i2c_dev->dev, &i2c_dev->timings, true);\n\n\tmulti_mode = device_property_read_bool(i2c_dev->dev, \"multi-master\");\n\ti2c_dev->multimaster_mode = multi_mode;\n\n\tif (IS_ENABLED(CONFIG_ARCH_TEGRA_2x_SOC) &&\n\t    of_device_is_compatible(np, \"nvidia,tegra20-i2c-dvc\"))\n\t\ti2c_dev->is_dvc = true;\n\n\tif (IS_ENABLED(CONFIG_ARCH_TEGRA_210_SOC) &&\n\t    of_device_is_compatible(np, \"nvidia,tegra210-i2c-vi\"))\n\t\ti2c_dev->is_vi = true;\n}\n\nstatic int tegra_i2c_init_reset(struct tegra_i2c_dev *i2c_dev)\n{\n\tif (ACPI_HANDLE(i2c_dev->dev))\n\t\treturn 0;\n\n\ti2c_dev->rst = devm_reset_control_get_exclusive(i2c_dev->dev, \"i2c\");\n\tif (IS_ERR(i2c_dev->rst))\n\t\treturn dev_err_probe(i2c_dev->dev, PTR_ERR(i2c_dev->rst),\n\t\t\t\t      \"failed to get reset control\\n\");\n\n\treturn 0;\n}\n\nstatic int tegra_i2c_init_clocks(struct tegra_i2c_dev *i2c_dev)\n{\n\tint err;\n\n\tif (ACPI_HANDLE(i2c_dev->dev))\n\t\treturn 0;\n\n\ti2c_dev->clocks[i2c_dev->nclocks++].id = \"div-clk\";\n\n\tif (i2c_dev->hw == &tegra20_i2c_hw || i2c_dev->hw == &tegra30_i2c_hw)\n\t\ti2c_dev->clocks[i2c_dev->nclocks++].id = \"fast-clk\";\n\n\tif (IS_VI(i2c_dev))\n\t\ti2c_dev->clocks[i2c_dev->nclocks++].id = \"slow\";\n\n\terr = devm_clk_bulk_get(i2c_dev->dev, i2c_dev->nclocks,\n\t\t\t\ti2c_dev->clocks);\n\tif (err)\n\t\treturn err;\n\n\terr = clk_bulk_prepare(i2c_dev->nclocks, i2c_dev->clocks);\n\tif (err)\n\t\treturn err;\n\n\ti2c_dev->div_clk = i2c_dev->clocks[0].clk;\n\n\tif (!i2c_dev->multimaster_mode)\n\t\treturn 0;\n\n\terr = clk_enable(i2c_dev->div_clk);\n\tif (err) {\n\t\tdev_err(i2c_dev->dev, \"failed to enable div-clk: %d\\n\", err);\n\t\tgoto unprepare_clocks;\n\t}\n\n\treturn 0;\n\nunprepare_clocks:\n\tclk_bulk_unprepare(i2c_dev->nclocks, i2c_dev->clocks);\n\n\treturn err;\n}\n\nstatic void tegra_i2c_release_clocks(struct tegra_i2c_dev *i2c_dev)\n{\n\tif (i2c_dev->multimaster_mode)\n\t\tclk_disable(i2c_dev->div_clk);\n\n\tclk_bulk_unprepare(i2c_dev->nclocks, i2c_dev->clocks);\n}\n\nstatic int tegra_i2c_init_hardware(struct tegra_i2c_dev *i2c_dev)\n{\n\tint ret;\n\n\tret = pm_runtime_get_sync(i2c_dev->dev);\n\tif (ret < 0)\n\t\tdev_err(i2c_dev->dev, \"runtime resume failed: %d\\n\", ret);\n\telse\n\t\tret = tegra_i2c_init(i2c_dev);\n\n\tpm_runtime_put_sync(i2c_dev->dev);\n\n\treturn ret;\n}\n\nstatic int tegra_i2c_probe(struct platform_device *pdev)\n{\n\tstruct tegra_i2c_dev *i2c_dev;\n\tstruct resource *res;\n\tint err;\n\n\ti2c_dev = devm_kzalloc(&pdev->dev, sizeof(*i2c_dev), GFP_KERNEL);\n\tif (!i2c_dev)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, i2c_dev);\n\n\tinit_completion(&i2c_dev->msg_complete);\n\tinit_completion(&i2c_dev->dma_complete);\n\n\ti2c_dev->hw = device_get_match_data(&pdev->dev);\n\ti2c_dev->cont_id = pdev->id;\n\ti2c_dev->dev = &pdev->dev;\n\n\ti2c_dev->base = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(i2c_dev->base))\n\t\treturn PTR_ERR(i2c_dev->base);\n\n\ti2c_dev->base_phys = res->start;\n\n\terr = platform_get_irq(pdev, 0);\n\tif (err < 0)\n\t\treturn err;\n\n\ti2c_dev->irq = err;\n\n\t \n\tirq_set_status_flags(i2c_dev->irq, IRQ_NOAUTOEN);\n\n\terr = devm_request_threaded_irq(i2c_dev->dev, i2c_dev->irq,\n\t\t\t\t\tNULL, tegra_i2c_isr,\n\t\t\t\t\tIRQF_NO_SUSPEND | IRQF_ONESHOT,\n\t\t\t\t\tdev_name(i2c_dev->dev), i2c_dev);\n\tif (err)\n\t\treturn err;\n\n\ttegra_i2c_parse_dt(i2c_dev);\n\n\terr = tegra_i2c_init_reset(i2c_dev);\n\tif (err)\n\t\treturn err;\n\n\terr = tegra_i2c_init_clocks(i2c_dev);\n\tif (err)\n\t\treturn err;\n\n\terr = tegra_i2c_init_dma(i2c_dev);\n\tif (err)\n\t\tgoto release_clocks;\n\n\t \n\tif (!IS_VI(i2c_dev))\n\t\tpm_runtime_irq_safe(i2c_dev->dev);\n\n\tpm_runtime_enable(i2c_dev->dev);\n\n\terr = tegra_i2c_init_hardware(i2c_dev);\n\tif (err)\n\t\tgoto release_rpm;\n\n\ti2c_set_adapdata(&i2c_dev->adapter, i2c_dev);\n\ti2c_dev->adapter.dev.of_node = i2c_dev->dev->of_node;\n\ti2c_dev->adapter.dev.parent = i2c_dev->dev;\n\ti2c_dev->adapter.retries = 1;\n\ti2c_dev->adapter.timeout = 6 * HZ;\n\ti2c_dev->adapter.quirks = i2c_dev->hw->quirks;\n\ti2c_dev->adapter.owner = THIS_MODULE;\n\ti2c_dev->adapter.class = I2C_CLASS_DEPRECATED;\n\ti2c_dev->adapter.algo = &tegra_i2c_algo;\n\ti2c_dev->adapter.nr = pdev->id;\n\tACPI_COMPANION_SET(&i2c_dev->adapter.dev, ACPI_COMPANION(&pdev->dev));\n\n\tif (i2c_dev->hw->supports_bus_clear)\n\t\ti2c_dev->adapter.bus_recovery_info = &tegra_i2c_recovery_info;\n\n\tstrscpy(i2c_dev->adapter.name, dev_name(i2c_dev->dev),\n\t\tsizeof(i2c_dev->adapter.name));\n\n\terr = i2c_add_numbered_adapter(&i2c_dev->adapter);\n\tif (err)\n\t\tgoto release_rpm;\n\n\treturn 0;\n\nrelease_rpm:\n\tpm_runtime_disable(i2c_dev->dev);\n\n\ttegra_i2c_release_dma(i2c_dev);\nrelease_clocks:\n\ttegra_i2c_release_clocks(i2c_dev);\n\n\treturn err;\n}\n\nstatic void tegra_i2c_remove(struct platform_device *pdev)\n{\n\tstruct tegra_i2c_dev *i2c_dev = platform_get_drvdata(pdev);\n\n\ti2c_del_adapter(&i2c_dev->adapter);\n\tpm_runtime_force_suspend(i2c_dev->dev);\n\n\ttegra_i2c_release_dma(i2c_dev);\n\ttegra_i2c_release_clocks(i2c_dev);\n}\n\nstatic int __maybe_unused tegra_i2c_runtime_resume(struct device *dev)\n{\n\tstruct tegra_i2c_dev *i2c_dev = dev_get_drvdata(dev);\n\tint err;\n\n\terr = pinctrl_pm_select_default_state(dev);\n\tif (err)\n\t\treturn err;\n\n\terr = clk_bulk_enable(i2c_dev->nclocks, i2c_dev->clocks);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (IS_VI(i2c_dev)) {\n\t\terr = tegra_i2c_init(i2c_dev);\n\t\tif (err)\n\t\t\tgoto disable_clocks;\n\t}\n\n\treturn 0;\n\ndisable_clocks:\n\tclk_bulk_disable(i2c_dev->nclocks, i2c_dev->clocks);\n\n\treturn err;\n}\n\nstatic int __maybe_unused tegra_i2c_runtime_suspend(struct device *dev)\n{\n\tstruct tegra_i2c_dev *i2c_dev = dev_get_drvdata(dev);\n\n\tclk_bulk_disable(i2c_dev->nclocks, i2c_dev->clocks);\n\n\treturn pinctrl_pm_select_idle_state(dev);\n}\n\nstatic int __maybe_unused tegra_i2c_suspend(struct device *dev)\n{\n\tstruct tegra_i2c_dev *i2c_dev = dev_get_drvdata(dev);\n\tint err;\n\n\ti2c_mark_adapter_suspended(&i2c_dev->adapter);\n\n\tif (!pm_runtime_status_suspended(dev)) {\n\t\terr = tegra_i2c_runtime_suspend(dev);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int __maybe_unused tegra_i2c_resume(struct device *dev)\n{\n\tstruct tegra_i2c_dev *i2c_dev = dev_get_drvdata(dev);\n\tint err;\n\n\t \n\terr = tegra_i2c_runtime_resume(dev);\n\tif (err)\n\t\treturn err;\n\n\terr = tegra_i2c_init(i2c_dev);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (pm_runtime_status_suspended(dev)) {\n\t\terr = tegra_i2c_runtime_suspend(dev);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\ti2c_mark_adapter_resumed(&i2c_dev->adapter);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops tegra_i2c_pm = {\n\tSET_NOIRQ_SYSTEM_SLEEP_PM_OPS(tegra_i2c_suspend, tegra_i2c_resume)\n\tSET_RUNTIME_PM_OPS(tegra_i2c_runtime_suspend, tegra_i2c_runtime_resume,\n\t\t\t   NULL)\n};\n\nstatic const struct acpi_device_id tegra_i2c_acpi_match[] = {\n\t{.id = \"NVDA0101\", .driver_data = (kernel_ulong_t)&tegra210_i2c_hw},\n\t{.id = \"NVDA0201\", .driver_data = (kernel_ulong_t)&tegra186_i2c_hw},\n\t{.id = \"NVDA0301\", .driver_data = (kernel_ulong_t)&tegra194_i2c_hw},\n\t{ }\n};\nMODULE_DEVICE_TABLE(acpi, tegra_i2c_acpi_match);\n\nstatic struct platform_driver tegra_i2c_driver = {\n\t.probe = tegra_i2c_probe,\n\t.remove_new = tegra_i2c_remove,\n\t.driver = {\n\t\t.name = \"tegra-i2c\",\n\t\t.of_match_table = tegra_i2c_of_match,\n\t\t.acpi_match_table = tegra_i2c_acpi_match,\n\t\t.pm = &tegra_i2c_pm,\n\t},\n};\nmodule_platform_driver(tegra_i2c_driver);\n\nMODULE_DESCRIPTION(\"NVIDIA Tegra I2C Bus Controller driver\");\nMODULE_AUTHOR(\"Colin Cross\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}