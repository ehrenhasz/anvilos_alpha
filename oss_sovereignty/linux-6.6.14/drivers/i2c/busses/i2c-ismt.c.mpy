{
  "module_name": "i2c-ismt.c",
  "hash_id": "15f4174167beccc928cc190b66384bba8d88b056f806398f1384d3d8fee30daa",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-ismt.c",
  "human_readable_source": " \n\n \n\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/completion.h>\n#include <linux/dma-mapping.h>\n#include <linux/i2c.h>\n#include <linux/acpi.h>\n#include <linux/interrupt.h>\n\n#include <linux/io-64-nonatomic-lo-hi.h>\n\n \n#define SMBBAR\t\t0\n\n \n#define PCI_DEVICE_ID_INTEL_S1200_SMT0\t0x0c59\n#define PCI_DEVICE_ID_INTEL_S1200_SMT1\t0x0c5a\n#define PCI_DEVICE_ID_INTEL_CDF_SMT\t0x18ac\n#define PCI_DEVICE_ID_INTEL_DNV_SMT\t0x19ac\n#define PCI_DEVICE_ID_INTEL_EBG_SMT\t0x1bff\n#define PCI_DEVICE_ID_INTEL_AVOTON_SMT\t0x1f15\n\n#define ISMT_DESC_ENTRIES\t2\t \n#define ISMT_MAX_RETRIES\t3\t \n#define ISMT_LOG_ENTRIES\t3\t \n\n \n#define ISMT_DESC_CWRL\t0x01\t \n#define ISMT_DESC_BLK\t0X04\t \n#define ISMT_DESC_FAIR\t0x08\t \n#define ISMT_DESC_PEC\t0x10\t \n#define ISMT_DESC_I2C\t0x20\t \n#define ISMT_DESC_INT\t0x40\t \n#define ISMT_DESC_SOE\t0x80\t \n\n \n#define ISMT_DESC_SCS\t0x01\t \n#define ISMT_DESC_DLTO\t0x04\t \n#define ISMT_DESC_NAK\t0x08\t \n#define ISMT_DESC_CRC\t0x10\t \n#define ISMT_DESC_CLTO\t0x20\t \n#define ISMT_DESC_COL\t0x40\t \n#define ISMT_DESC_LPR\t0x80\t \n\n \n#define ISMT_DESC_ADDR_RW(addr, rw) (((addr) << 1) | (rw))\n\n \n#define ISMT_GR_GCTRL\t\t0x000\t \n#define ISMT_GR_SMTICL\t\t0x008\t \n#define ISMT_GR_ERRINTMSK\t0x010\t \n#define ISMT_GR_ERRAERMSK\t0x014\t \n#define ISMT_GR_ERRSTS\t\t0x018\t \n#define ISMT_GR_ERRINFO\t\t0x01c\t \n\n \n#define ISMT_MSTR_MDBA\t\t0x100\t \n#define ISMT_MSTR_MCTRL\t\t0x108\t \n#define ISMT_MSTR_MSTS\t\t0x10c\t \n#define ISMT_MSTR_MDS\t\t0x110\t \n#define ISMT_MSTR_RPOLICY\t0x114\t \n\n \n#define ISMT_SPGT\t0x300\t \n\n \n#define ISMT_GCTRL_TRST\t0x04\t \n#define ISMT_GCTRL_KILL\t0x08\t \n#define ISMT_GCTRL_SRST\t0x40\t \n\n \n#define ISMT_MCTRL_SS\t0x01\t\t \n#define ISMT_MCTRL_MEIE\t0x10\t\t \n#define ISMT_MCTRL_FMHP\t0x00ff0000\t \n\n \n#define ISMT_MSTS_HMTP\t0xff0000\t \n#define ISMT_MSTS_MIS\t0x20\t\t \n#define ISMT_MSTS_MEIS\t0x10\t\t \n#define ISMT_MSTS_IP\t0x01\t\t \n\n \n#define ISMT_MDS_MASK\t0xff\t \n\n \n#define ISMT_SPGT_SPD_MASK\t0xc0000000\t \n#define ISMT_SPGT_SPD_80K\t0x00\t\t \n#define ISMT_SPGT_SPD_100K\t(0x1 << 30)\t \n#define ISMT_SPGT_SPD_400K\t(0x2U << 30)\t \n#define ISMT_SPGT_SPD_1M\t(0x3U << 30)\t \n\n\n \n#define ISMT_MSICTL_MSIE\t0x01\t \n\n \nstruct ismt_desc {\n\tu8 tgtaddr_rw;\t \n\tu8 wr_len_cmd;\t \n\tu8 rd_len;\t \n\tu8 control;\t \n\tu8 status;\t \n\tu8 retry;\t \n\tu8 rxbytes;\t \n\tu8 txbytes;\t \n\tu32 dptr_low;\t \n\tu32 dptr_high;\t \n} __packed;\n\nstruct ismt_priv {\n\tstruct i2c_adapter adapter;\n\tvoid __iomem *smba;\t\t\t \n\tstruct pci_dev *pci_dev;\n\tstruct ismt_desc *hw;\t\t\t \n\tdma_addr_t io_rng_dma;\t\t\t \n\tu8 head;\t\t\t\t \n\tstruct completion cmp;\t\t\t \n\tu8 buffer[I2C_SMBUS_BLOCK_MAX + 16];\t \n\tdma_addr_t log_dma;\n\tu32 *log;\n};\n\nstatic const struct pci_device_id ismt_ids[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_S1200_SMT0) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_S1200_SMT1) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_CDF_SMT) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_DNV_SMT) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_EBG_SMT) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_AVOTON_SMT) },\n\t{ 0, }\n};\n\nMODULE_DEVICE_TABLE(pci, ismt_ids);\n\n \nstatic unsigned int bus_speed;\nmodule_param(bus_speed, uint, S_IRUGO);\nMODULE_PARM_DESC(bus_speed, \"Bus Speed in kHz (0 = BIOS default)\");\n\n \nstatic void __ismt_desc_dump(struct device *dev, const struct ismt_desc *desc)\n{\n\n\tdev_dbg(dev, \"Descriptor struct:  %p\\n\", desc);\n\tdev_dbg(dev, \"\\ttgtaddr_rw=0x%02X\\n\", desc->tgtaddr_rw);\n\tdev_dbg(dev, \"\\twr_len_cmd=0x%02X\\n\", desc->wr_len_cmd);\n\tdev_dbg(dev, \"\\trd_len=    0x%02X\\n\", desc->rd_len);\n\tdev_dbg(dev, \"\\tcontrol=   0x%02X\\n\", desc->control);\n\tdev_dbg(dev, \"\\tstatus=    0x%02X\\n\", desc->status);\n\tdev_dbg(dev, \"\\tretry=     0x%02X\\n\", desc->retry);\n\tdev_dbg(dev, \"\\trxbytes=   0x%02X\\n\", desc->rxbytes);\n\tdev_dbg(dev, \"\\ttxbytes=   0x%02X\\n\", desc->txbytes);\n\tdev_dbg(dev, \"\\tdptr_low=  0x%08X\\n\", desc->dptr_low);\n\tdev_dbg(dev, \"\\tdptr_high= 0x%08X\\n\", desc->dptr_high);\n}\n \nstatic void ismt_desc_dump(struct ismt_priv *priv)\n{\n\tstruct device *dev = &priv->pci_dev->dev;\n\tstruct ismt_desc *desc = &priv->hw[priv->head];\n\n\tdev_dbg(dev, \"Dump of the descriptor struct:  0x%X\\n\", priv->head);\n\t__ismt_desc_dump(dev, desc);\n}\n\n \nstatic void ismt_gen_reg_dump(struct ismt_priv *priv)\n{\n\tstruct device *dev = &priv->pci_dev->dev;\n\n\tdev_dbg(dev, \"Dump of the iSMT General Registers\\n\");\n\tdev_dbg(dev, \"  GCTRL.... : (0x%p)=0x%X\\n\",\n\t\tpriv->smba + ISMT_GR_GCTRL,\n\t\treadl(priv->smba + ISMT_GR_GCTRL));\n\tdev_dbg(dev, \"  SMTICL... : (0x%p)=0x%016llX\\n\",\n\t\tpriv->smba + ISMT_GR_SMTICL,\n\t\t(long long unsigned int)readq(priv->smba + ISMT_GR_SMTICL));\n\tdev_dbg(dev, \"  ERRINTMSK : (0x%p)=0x%X\\n\",\n\t\tpriv->smba + ISMT_GR_ERRINTMSK,\n\t\treadl(priv->smba + ISMT_GR_ERRINTMSK));\n\tdev_dbg(dev, \"  ERRAERMSK : (0x%p)=0x%X\\n\",\n\t\tpriv->smba + ISMT_GR_ERRAERMSK,\n\t\treadl(priv->smba + ISMT_GR_ERRAERMSK));\n\tdev_dbg(dev, \"  ERRSTS... : (0x%p)=0x%X\\n\",\n\t\tpriv->smba + ISMT_GR_ERRSTS,\n\t\treadl(priv->smba + ISMT_GR_ERRSTS));\n\tdev_dbg(dev, \"  ERRINFO.. : (0x%p)=0x%X\\n\",\n\t\tpriv->smba + ISMT_GR_ERRINFO,\n\t\treadl(priv->smba + ISMT_GR_ERRINFO));\n}\n\n \nstatic void ismt_mstr_reg_dump(struct ismt_priv *priv)\n{\n\tstruct device *dev = &priv->pci_dev->dev;\n\n\tdev_dbg(dev, \"Dump of the iSMT Master Registers\\n\");\n\tdev_dbg(dev, \"  MDBA..... : (0x%p)=0x%016llX\\n\",\n\t\tpriv->smba + ISMT_MSTR_MDBA,\n\t\t(long long unsigned int)readq(priv->smba + ISMT_MSTR_MDBA));\n\tdev_dbg(dev, \"  MCTRL.... : (0x%p)=0x%X\\n\",\n\t\tpriv->smba + ISMT_MSTR_MCTRL,\n\t\treadl(priv->smba + ISMT_MSTR_MCTRL));\n\tdev_dbg(dev, \"  MSTS..... : (0x%p)=0x%X\\n\",\n\t\tpriv->smba + ISMT_MSTR_MSTS,\n\t\treadl(priv->smba + ISMT_MSTR_MSTS));\n\tdev_dbg(dev, \"  MDS...... : (0x%p)=0x%X\\n\",\n\t\tpriv->smba + ISMT_MSTR_MDS,\n\t\treadl(priv->smba + ISMT_MSTR_MDS));\n\tdev_dbg(dev, \"  RPOLICY.. : (0x%p)=0x%X\\n\",\n\t\tpriv->smba + ISMT_MSTR_RPOLICY,\n\t\treadl(priv->smba + ISMT_MSTR_RPOLICY));\n\tdev_dbg(dev, \"  SPGT..... : (0x%p)=0x%X\\n\",\n\t\tpriv->smba + ISMT_SPGT,\n\t\treadl(priv->smba + ISMT_SPGT));\n}\n\n \nstatic void ismt_submit_desc(struct ismt_priv *priv)\n{\n\tuint fmhp;\n\tuint val;\n\n\tismt_desc_dump(priv);\n\tismt_gen_reg_dump(priv);\n\tismt_mstr_reg_dump(priv);\n\n\t \n\tfmhp = ((priv->head + 1) % ISMT_DESC_ENTRIES) << 16;\n\tval = readl(priv->smba + ISMT_MSTR_MCTRL);\n\twritel((val & ~ISMT_MCTRL_FMHP) | fmhp,\n\t       priv->smba + ISMT_MSTR_MCTRL);\n\n\t \n\tval = readl(priv->smba + ISMT_MSTR_MCTRL);\n\twritel(val | ISMT_MCTRL_SS,\n\t       priv->smba + ISMT_MSTR_MCTRL);\n}\n\n \nstatic int ismt_process_desc(const struct ismt_desc *desc,\n\t\t\t     union i2c_smbus_data *data,\n\t\t\t     struct ismt_priv *priv, int size,\n\t\t\t     char read_write)\n{\n\tu8 *dma_buffer = PTR_ALIGN(&priv->buffer[0], 16);\n\n\tdev_dbg(&priv->pci_dev->dev, \"Processing completed descriptor\\n\");\n\t__ismt_desc_dump(&priv->pci_dev->dev, desc);\n\tismt_gen_reg_dump(priv);\n\tismt_mstr_reg_dump(priv);\n\n\tif (desc->status & ISMT_DESC_SCS) {\n\t\tif (read_write == I2C_SMBUS_WRITE &&\n\t\t    size != I2C_SMBUS_PROC_CALL &&\n\t\t    size != I2C_SMBUS_BLOCK_PROC_CALL)\n\t\t\treturn 0;\n\n\t\tswitch (size) {\n\t\tcase I2C_SMBUS_BYTE:\n\t\tcase I2C_SMBUS_BYTE_DATA:\n\t\t\tdata->byte = dma_buffer[0];\n\t\t\tbreak;\n\t\tcase I2C_SMBUS_WORD_DATA:\n\t\tcase I2C_SMBUS_PROC_CALL:\n\t\t\tdata->word = dma_buffer[0] | (dma_buffer[1] << 8);\n\t\t\tbreak;\n\t\tcase I2C_SMBUS_BLOCK_DATA:\n\t\tcase I2C_SMBUS_BLOCK_PROC_CALL:\n\t\t\tif (desc->rxbytes != dma_buffer[0] + 1)\n\t\t\t\treturn -EMSGSIZE;\n\n\t\t\tmemcpy(data->block, dma_buffer, desc->rxbytes);\n\t\t\tbreak;\n\t\tcase I2C_SMBUS_I2C_BLOCK_DATA:\n\t\t\tmemcpy(&data->block[1], dma_buffer, desc->rxbytes);\n\t\t\tdata->block[0] = desc->rxbytes;\n\t\t\tbreak;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (likely(desc->status & ISMT_DESC_NAK))\n\t\treturn -ENXIO;\n\n\tif (desc->status & ISMT_DESC_CRC)\n\t\treturn -EBADMSG;\n\n\tif (desc->status & ISMT_DESC_COL)\n\t\treturn -EAGAIN;\n\n\tif (desc->status & ISMT_DESC_LPR)\n\t\treturn -EPROTO;\n\n\tif (desc->status & (ISMT_DESC_DLTO | ISMT_DESC_CLTO))\n\t\treturn -ETIMEDOUT;\n\n\treturn -EIO;\n}\n\n \nstatic int ismt_access(struct i2c_adapter *adap, u16 addr,\n\t\t       unsigned short flags, char read_write, u8 command,\n\t\t       int size, union i2c_smbus_data *data)\n{\n\tint ret;\n\tunsigned long time_left;\n\tdma_addr_t dma_addr = 0;  \n\tu8 dma_size = 0;\n\tenum dma_data_direction dma_direction = 0;\n\tstruct ismt_desc *desc;\n\tstruct ismt_priv *priv = i2c_get_adapdata(adap);\n\tstruct device *dev = &priv->pci_dev->dev;\n\tu8 *dma_buffer = PTR_ALIGN(&priv->buffer[0], 16);\n\n\tdesc = &priv->hw[priv->head];\n\n\t \n\tmemset(priv->buffer, 0, sizeof(priv->buffer));\n\n\t \n\tmemset(desc, 0, sizeof(struct ismt_desc));\n\tdesc->tgtaddr_rw = ISMT_DESC_ADDR_RW(addr, read_write);\n\n\t \n\tmemset(priv->log, 0, ISMT_LOG_ENTRIES * sizeof(u32));\n\n\t \n\tif (likely(pci_dev_msi_enabled(priv->pci_dev)))\n\t\tdesc->control = ISMT_DESC_INT | ISMT_DESC_FAIR;\n\telse\n\t\tdesc->control = ISMT_DESC_FAIR;\n\n\tif ((flags & I2C_CLIENT_PEC) && (size != I2C_SMBUS_QUICK)\n\t    && (size != I2C_SMBUS_I2C_BLOCK_DATA))\n\t\tdesc->control |= ISMT_DESC_PEC;\n\n\tswitch (size) {\n\tcase I2C_SMBUS_QUICK:\n\t\tdev_dbg(dev, \"I2C_SMBUS_QUICK\\n\");\n\t\tbreak;\n\n\tcase I2C_SMBUS_BYTE:\n\t\tif (read_write == I2C_SMBUS_WRITE) {\n\t\t\t \n\t\t\tdev_dbg(dev, \"I2C_SMBUS_BYTE:  WRITE\\n\");\n\t\t\tdesc->control |= ISMT_DESC_CWRL;\n\t\t\tdesc->wr_len_cmd = command;\n\t\t} else {\n\t\t\t \n\t\t\tdev_dbg(dev, \"I2C_SMBUS_BYTE:  READ\\n\");\n\t\t\tdma_size = 1;\n\t\t\tdma_direction = DMA_FROM_DEVICE;\n\t\t\tdesc->rd_len = 1;\n\t\t}\n\t\tbreak;\n\n\tcase I2C_SMBUS_BYTE_DATA:\n\t\tif (read_write == I2C_SMBUS_WRITE) {\n\t\t\t \n\t\t\tdev_dbg(dev, \"I2C_SMBUS_BYTE_DATA:  WRITE\\n\");\n\t\t\tdesc->wr_len_cmd = 2;\n\t\t\tdma_size = 2;\n\t\t\tdma_direction = DMA_TO_DEVICE;\n\t\t\tdma_buffer[0] = command;\n\t\t\tdma_buffer[1] = data->byte;\n\t\t} else {\n\t\t\t \n\t\t\tdev_dbg(dev, \"I2C_SMBUS_BYTE_DATA:  READ\\n\");\n\t\t\tdesc->control |= ISMT_DESC_CWRL;\n\t\t\tdesc->wr_len_cmd = command;\n\t\t\tdesc->rd_len = 1;\n\t\t\tdma_size = 1;\n\t\t\tdma_direction = DMA_FROM_DEVICE;\n\t\t}\n\t\tbreak;\n\n\tcase I2C_SMBUS_WORD_DATA:\n\t\tif (read_write == I2C_SMBUS_WRITE) {\n\t\t\t \n\t\t\tdev_dbg(dev, \"I2C_SMBUS_WORD_DATA:  WRITE\\n\");\n\t\t\tdesc->wr_len_cmd = 3;\n\t\t\tdma_size = 3;\n\t\t\tdma_direction = DMA_TO_DEVICE;\n\t\t\tdma_buffer[0] = command;\n\t\t\tdma_buffer[1] = data->word & 0xff;\n\t\t\tdma_buffer[2] = data->word >> 8;\n\t\t} else {\n\t\t\t \n\t\t\tdev_dbg(dev, \"I2C_SMBUS_WORD_DATA:  READ\\n\");\n\t\t\tdesc->wr_len_cmd = command;\n\t\t\tdesc->control |= ISMT_DESC_CWRL;\n\t\t\tdesc->rd_len = 2;\n\t\t\tdma_size = 2;\n\t\t\tdma_direction = DMA_FROM_DEVICE;\n\t\t}\n\t\tbreak;\n\n\tcase I2C_SMBUS_PROC_CALL:\n\t\tdev_dbg(dev, \"I2C_SMBUS_PROC_CALL\\n\");\n\t\tdesc->wr_len_cmd = 3;\n\t\tdesc->rd_len = 2;\n\t\tdma_size = 3;\n\t\tdma_direction = DMA_BIDIRECTIONAL;\n\t\tdma_buffer[0] = command;\n\t\tdma_buffer[1] = data->word & 0xff;\n\t\tdma_buffer[2] = data->word >> 8;\n\t\tbreak;\n\n\tcase I2C_SMBUS_BLOCK_DATA:\n\t\tif (read_write == I2C_SMBUS_WRITE) {\n\t\t\t \n\t\t\tdev_dbg(dev, \"I2C_SMBUS_BLOCK_DATA:  WRITE\\n\");\n\t\t\tif (data->block[0] < 1 || data->block[0] > I2C_SMBUS_BLOCK_MAX)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tdma_size = data->block[0] + 1;\n\t\t\tdma_direction = DMA_TO_DEVICE;\n\t\t\tdesc->wr_len_cmd = dma_size;\n\t\t\tdesc->control |= ISMT_DESC_BLK;\n\t\t\tdma_buffer[0] = command;\n\t\t\tmemcpy(&dma_buffer[1], &data->block[1], dma_size - 1);\n\t\t} else {\n\t\t\t \n\t\t\tdev_dbg(dev, \"I2C_SMBUS_BLOCK_DATA:  READ\\n\");\n\t\t\tdma_size = I2C_SMBUS_BLOCK_MAX;\n\t\t\tdma_direction = DMA_FROM_DEVICE;\n\t\t\tdesc->rd_len = dma_size;\n\t\t\tdesc->wr_len_cmd = command;\n\t\t\tdesc->control |= (ISMT_DESC_BLK | ISMT_DESC_CWRL);\n\t\t}\n\t\tbreak;\n\n\tcase I2C_SMBUS_BLOCK_PROC_CALL:\n\t\tdev_dbg(dev, \"I2C_SMBUS_BLOCK_PROC_CALL\\n\");\n\t\tif (data->block[0] > I2C_SMBUS_BLOCK_MAX)\n\t\t\treturn -EINVAL;\n\n\t\tdma_size = I2C_SMBUS_BLOCK_MAX;\n\t\tdesc->tgtaddr_rw = ISMT_DESC_ADDR_RW(addr, 1);\n\t\tdesc->wr_len_cmd = data->block[0] + 1;\n\t\tdesc->rd_len = dma_size;\n\t\tdesc->control |= ISMT_DESC_BLK;\n\t\tdma_direction = DMA_BIDIRECTIONAL;\n\t\tdma_buffer[0] = command;\n\t\tmemcpy(&dma_buffer[1], &data->block[1], data->block[0]);\n\t\tbreak;\n\n\tcase I2C_SMBUS_I2C_BLOCK_DATA:\n\t\t \n\t\tif (data->block[0] < 1)\n\t\t\tdata->block[0] = 1;\n\n\t\tif (data->block[0] > I2C_SMBUS_BLOCK_MAX)\n\t\t\tdata->block[0] = I2C_SMBUS_BLOCK_MAX;\n\n\t\tif (read_write == I2C_SMBUS_WRITE) {\n\t\t\t \n\t\t\tdev_dbg(dev, \"I2C_SMBUS_I2C_BLOCK_DATA:  WRITE\\n\");\n\t\t\tdma_size = data->block[0] + 1;\n\t\t\tdma_direction = DMA_TO_DEVICE;\n\t\t\tdesc->wr_len_cmd = dma_size;\n\t\t\tdesc->control |= ISMT_DESC_I2C;\n\t\t\tdma_buffer[0] = command;\n\t\t\tmemcpy(&dma_buffer[1], &data->block[1], dma_size - 1);\n\t\t} else {\n\t\t\t \n\t\t\tdev_dbg(dev, \"I2C_SMBUS_I2C_BLOCK_DATA:  READ\\n\");\n\t\t\tdma_size = data->block[0];\n\t\t\tdma_direction = DMA_FROM_DEVICE;\n\t\t\tdesc->rd_len = dma_size;\n\t\t\tdesc->wr_len_cmd = command;\n\t\t\tdesc->control |= (ISMT_DESC_I2C | ISMT_DESC_CWRL);\n\t\t\t \n\t\t\tdesc->tgtaddr_rw = ISMT_DESC_ADDR_RW(addr, 0);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(dev, \"Unsupported transaction %d\\n\",\n\t\t\tsize);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t \n\tif (dma_size != 0) {\n\t\tdev_dbg(dev, \" dev=%p\\n\", dev);\n\t\tdev_dbg(dev, \" data=%p\\n\", data);\n\t\tdev_dbg(dev, \" dma_buffer=%p\\n\", dma_buffer);\n\t\tdev_dbg(dev, \" dma_size=%d\\n\", dma_size);\n\t\tdev_dbg(dev, \" dma_direction=%d\\n\", dma_direction);\n\n\t\tdma_addr = dma_map_single(dev,\n\t\t\t\t      dma_buffer,\n\t\t\t\t      dma_size,\n\t\t\t\t      dma_direction);\n\n\t\tif (dma_mapping_error(dev, dma_addr)) {\n\t\t\tdev_err(dev, \"Error in mapping dma buffer %p\\n\",\n\t\t\t\tdma_buffer);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tdev_dbg(dev, \" dma_addr = %pad\\n\", &dma_addr);\n\n\t\tdesc->dptr_low = lower_32_bits(dma_addr);\n\t\tdesc->dptr_high = upper_32_bits(dma_addr);\n\t}\n\n\treinit_completion(&priv->cmp);\n\n\t \n\tismt_submit_desc(priv);\n\n\t \n\ttime_left = wait_for_completion_timeout(&priv->cmp, HZ*1);\n\n\t \n\tif (dma_size != 0)\n\t\tdma_unmap_single(dev, dma_addr, dma_size, dma_direction);\n\n\tif (unlikely(!time_left)) {\n\t\tdev_err(dev, \"completion wait timed out\\n\");\n\t\tret = -ETIMEDOUT;\n\t\tgoto out;\n\t}\n\n\t \n\tret = ismt_process_desc(desc, data, priv, size, read_write);\n\nout:\n\t \n\tpriv->head++;\n\tpriv->head %= ISMT_DESC_ENTRIES;\n\n\treturn ret;\n}\n\n \nstatic u32 ismt_func(struct i2c_adapter *adap)\n{\n\treturn I2C_FUNC_SMBUS_QUICK\t\t|\n\t       I2C_FUNC_SMBUS_BYTE\t\t|\n\t       I2C_FUNC_SMBUS_BYTE_DATA\t\t|\n\t       I2C_FUNC_SMBUS_WORD_DATA\t\t|\n\t       I2C_FUNC_SMBUS_PROC_CALL\t\t|\n\t       I2C_FUNC_SMBUS_BLOCK_PROC_CALL\t|\n\t       I2C_FUNC_SMBUS_BLOCK_DATA\t|\n\t       I2C_FUNC_SMBUS_I2C_BLOCK\t\t|\n\t       I2C_FUNC_SMBUS_PEC;\n}\n\nstatic const struct i2c_algorithm smbus_algorithm = {\n\t.smbus_xfer\t= ismt_access,\n\t.functionality\t= ismt_func,\n};\n\n \nstatic irqreturn_t ismt_handle_isr(struct ismt_priv *priv)\n{\n\tcomplete(&priv->cmp);\n\n\treturn IRQ_HANDLED;\n}\n\n\n \nstatic irqreturn_t ismt_do_interrupt(int vec, void *data)\n{\n\tu32 val;\n\tstruct ismt_priv *priv = data;\n\n\t \n\tval = readl(priv->smba + ISMT_MSTR_MSTS);\n\n\tif (!(val & (ISMT_MSTS_MIS | ISMT_MSTS_MEIS)))\n\t\treturn IRQ_NONE;\n\telse\n\t\twritel(val | ISMT_MSTS_MIS | ISMT_MSTS_MEIS,\n\t\t       priv->smba + ISMT_MSTR_MSTS);\n\n\treturn ismt_handle_isr(priv);\n}\n\n \nstatic irqreturn_t ismt_do_msi_interrupt(int vec, void *data)\n{\n\treturn ismt_handle_isr(data);\n}\n\n \nstatic void ismt_hw_init(struct ismt_priv *priv)\n{\n\tu32 val;\n\tstruct device *dev = &priv->pci_dev->dev;\n\n\t \n\twriteq(priv->io_rng_dma, priv->smba + ISMT_MSTR_MDBA);\n\n\twriteq(priv->log_dma, priv->smba + ISMT_GR_SMTICL);\n\n\t \n\twritel(ISMT_MCTRL_MEIE, priv->smba + ISMT_MSTR_MCTRL);\n\n\t \n\twritel(0, priv->smba + ISMT_MSTR_MSTS);\n\n\t \n\tval = readl(priv->smba + ISMT_MSTR_MDS);\n\twritel((val & ~ISMT_MDS_MASK) | (ISMT_DESC_ENTRIES - 1),\n\t\tpriv->smba + ISMT_MSTR_MDS);\n\n\t \n\n\tval = readl(priv->smba + ISMT_SPGT);\n\n\tswitch (bus_speed) {\n\tcase 0:\n\t\tbreak;\n\n\tcase 80:\n\t\tdev_dbg(dev, \"Setting SMBus clock to 80 kHz\\n\");\n\t\twritel(((val & ~ISMT_SPGT_SPD_MASK) | ISMT_SPGT_SPD_80K),\n\t\t\tpriv->smba + ISMT_SPGT);\n\t\tbreak;\n\n\tcase 100:\n\t\tdev_dbg(dev, \"Setting SMBus clock to 100 kHz\\n\");\n\t\twritel(((val & ~ISMT_SPGT_SPD_MASK) | ISMT_SPGT_SPD_100K),\n\t\t\tpriv->smba + ISMT_SPGT);\n\t\tbreak;\n\n\tcase 400:\n\t\tdev_dbg(dev, \"Setting SMBus clock to 400 kHz\\n\");\n\t\twritel(((val & ~ISMT_SPGT_SPD_MASK) | ISMT_SPGT_SPD_400K),\n\t\t\tpriv->smba + ISMT_SPGT);\n\t\tbreak;\n\n\tcase 1000:\n\t\tdev_dbg(dev, \"Setting SMBus clock to 1000 kHz\\n\");\n\t\twritel(((val & ~ISMT_SPGT_SPD_MASK) | ISMT_SPGT_SPD_1M),\n\t\t\tpriv->smba + ISMT_SPGT);\n\t\tbreak;\n\n\tdefault:\n\t\tdev_warn(dev, \"Invalid SMBus clock speed, only 0, 80, 100, 400, and 1000 are valid\\n\");\n\t\tbreak;\n\t}\n\n\tval = readl(priv->smba + ISMT_SPGT);\n\n\tswitch (val & ISMT_SPGT_SPD_MASK) {\n\tcase ISMT_SPGT_SPD_80K:\n\t\tbus_speed = 80;\n\t\tbreak;\n\tcase ISMT_SPGT_SPD_100K:\n\t\tbus_speed = 100;\n\t\tbreak;\n\tcase ISMT_SPGT_SPD_400K:\n\t\tbus_speed = 400;\n\t\tbreak;\n\tcase ISMT_SPGT_SPD_1M:\n\t\tbus_speed = 1000;\n\t\tbreak;\n\t}\n\tdev_dbg(dev, \"SMBus clock is running at %d kHz\\n\", bus_speed);\n}\n\n \nstatic int ismt_dev_init(struct ismt_priv *priv)\n{\n\t \n\tpriv->hw = dmam_alloc_coherent(&priv->pci_dev->dev,\n\t\t\t\t       (ISMT_DESC_ENTRIES\n\t\t\t\t\t       * sizeof(struct ismt_desc)),\n\t\t\t\t       &priv->io_rng_dma,\n\t\t\t\t       GFP_KERNEL);\n\tif (!priv->hw)\n\t\treturn -ENOMEM;\n\n\tpriv->head = 0;\n\tinit_completion(&priv->cmp);\n\n\tpriv->log = dmam_alloc_coherent(&priv->pci_dev->dev,\n\t\t\t\t\tISMT_LOG_ENTRIES * sizeof(u32),\n\t\t\t\t\t&priv->log_dma, GFP_KERNEL);\n\tif (!priv->log)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\n \nstatic int ismt_int_init(struct ismt_priv *priv)\n{\n\tint err;\n\n\t \n\terr = pci_enable_msi(priv->pci_dev);\n\tif (err)\n\t\tgoto intx;\n\n\terr = devm_request_irq(&priv->pci_dev->dev,\n\t\t\t       priv->pci_dev->irq,\n\t\t\t       ismt_do_msi_interrupt,\n\t\t\t       0,\n\t\t\t       \"ismt-msi\",\n\t\t\t       priv);\n\tif (err) {\n\t\tpci_disable_msi(priv->pci_dev);\n\t\tgoto intx;\n\t}\n\n\treturn 0;\n\n\t \nintx:\n\tdev_warn(&priv->pci_dev->dev,\n\t\t \"Unable to use MSI interrupts, falling back to legacy\\n\");\n\n\terr = devm_request_irq(&priv->pci_dev->dev,\n\t\t\t       priv->pci_dev->irq,\n\t\t\t       ismt_do_interrupt,\n\t\t\t       IRQF_SHARED,\n\t\t\t       \"ismt-intx\",\n\t\t\t       priv);\n\tif (err) {\n\t\tdev_err(&priv->pci_dev->dev, \"no usable interrupts\\n\");\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic struct pci_driver ismt_driver;\n\n \nstatic int\nismt_probe(struct pci_dev *pdev, const struct pci_device_id *id)\n{\n\tint err;\n\tstruct ismt_priv *priv;\n\tunsigned long start, len;\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpci_set_drvdata(pdev, priv);\n\n\ti2c_set_adapdata(&priv->adapter, priv);\n\tpriv->adapter.owner = THIS_MODULE;\n\tpriv->adapter.class = I2C_CLASS_HWMON;\n\tpriv->adapter.algo = &smbus_algorithm;\n\tpriv->adapter.dev.parent = &pdev->dev;\n\tACPI_COMPANION_SET(&priv->adapter.dev, ACPI_COMPANION(&pdev->dev));\n\tpriv->adapter.retries = ISMT_MAX_RETRIES;\n\n\tpriv->pci_dev = pdev;\n\n\terr = pcim_enable_device(pdev);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Failed to enable SMBus PCI device (%d)\\n\",\n\t\t\terr);\n\t\treturn err;\n\t}\n\n\t \n\tpci_set_master(pdev);\n\n\t \n\tstart = pci_resource_start(pdev, SMBBAR);\n\tlen = pci_resource_len(pdev, SMBBAR);\n\tif (!start || !len) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"SMBus base address uninitialized, upgrade BIOS\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tsnprintf(priv->adapter.name, sizeof(priv->adapter.name),\n\t\t \"SMBus iSMT adapter at %lx\", start);\n\n\tdev_dbg(&priv->pci_dev->dev, \" start=0x%lX\\n\", start);\n\tdev_dbg(&priv->pci_dev->dev, \" len=0x%lX\\n\", len);\n\n\terr = acpi_check_resource_conflict(&pdev->resource[SMBBAR]);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"ACPI resource conflict!\\n\");\n\t\treturn err;\n\t}\n\n\terr = pci_request_region(pdev, SMBBAR, ismt_driver.name);\n\tif (err) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Failed to request SMBus region 0x%lx-0x%lx\\n\",\n\t\t\tstart, start + len);\n\t\treturn err;\n\t}\n\n\tpriv->smba = pcim_iomap(pdev, SMBBAR, len);\n\tif (!priv->smba) {\n\t\tdev_err(&pdev->dev, \"Unable to ioremap SMBus BAR\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\terr = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(64));\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"dma_set_mask fail\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\terr = ismt_dev_init(priv);\n\tif (err)\n\t\treturn err;\n\n\tismt_hw_init(priv);\n\n\terr = ismt_int_init(priv);\n\tif (err)\n\t\treturn err;\n\n\terr = i2c_add_adapter(&priv->adapter);\n\tif (err)\n\t\treturn -ENODEV;\n\treturn 0;\n}\n\n \nstatic void ismt_remove(struct pci_dev *pdev)\n{\n\tstruct ismt_priv *priv = pci_get_drvdata(pdev);\n\n\ti2c_del_adapter(&priv->adapter);\n}\n\nstatic struct pci_driver ismt_driver = {\n\t.name = \"ismt_smbus\",\n\t.id_table = ismt_ids,\n\t.probe = ismt_probe,\n\t.remove = ismt_remove,\n};\n\nmodule_pci_driver(ismt_driver);\n\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_AUTHOR(\"Bill E. Brown <bill.e.brown@intel.com>\");\nMODULE_DESCRIPTION(\"Intel SMBus Message Transport (iSMT) driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}