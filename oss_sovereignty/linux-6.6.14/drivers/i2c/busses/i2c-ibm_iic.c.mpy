{
  "module_name": "i2c-ibm_iic.c",
  "hash_id": "eb1d19e72be1d57ec4d8b8851597ff637cf02907a8cd2f8d846dc6f3fcded970",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-ibm_iic.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/ioport.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/sched/signal.h>\n\n#include <asm/irq.h>\n#include <linux/io.h>\n#include <linux/i2c.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/platform_device.h>\n\n#include \"i2c-ibm_iic.h\"\n\n#define DRIVER_VERSION \"2.2\"\n\nMODULE_DESCRIPTION(\"IBM IIC driver v\" DRIVER_VERSION);\nMODULE_LICENSE(\"GPL\");\n\nstatic bool iic_force_poll;\nmodule_param(iic_force_poll, bool, 0);\nMODULE_PARM_DESC(iic_force_poll, \"Force polling mode\");\n\nstatic bool iic_force_fast;\nmodule_param(iic_force_fast, bool, 0);\nMODULE_PARM_DESC(iic_force_fast, \"Force fast mode (400 kHz)\");\n\n#define DBG_LEVEL 0\n\n#ifdef DBG\n#undef DBG\n#endif\n\n#ifdef DBG2\n#undef DBG2\n#endif\n\n#if DBG_LEVEL > 0\n#  define DBG(f,x...)\tprintk(KERN_DEBUG \"ibm-iic\" f, ##x)\n#else\n#  define DBG(f,x...)\t((void)0)\n#endif\n#if DBG_LEVEL > 1\n#  define DBG2(f,x...) \tDBG(f, ##x)\n#else\n#  define DBG2(f,x...) \t((void)0)\n#endif\n#if DBG_LEVEL > 2\nstatic void dump_iic_regs(const char* header, struct ibm_iic_private* dev)\n{\n\tvolatile struct iic_regs __iomem *iic = dev->vaddr;\n\tprintk(KERN_DEBUG \"ibm-iic%d: %s\\n\", dev->idx, header);\n\tprintk(KERN_DEBUG\n\t       \"  cntl     = 0x%02x, mdcntl = 0x%02x\\n\"\n\t       \"  sts      = 0x%02x, extsts = 0x%02x\\n\"\n\t       \"  clkdiv   = 0x%02x, xfrcnt = 0x%02x\\n\"\n\t       \"  xtcntlss = 0x%02x, directcntl = 0x%02x\\n\",\n\t\tin_8(&iic->cntl), in_8(&iic->mdcntl), in_8(&iic->sts),\n\t\tin_8(&iic->extsts), in_8(&iic->clkdiv), in_8(&iic->xfrcnt),\n\t\tin_8(&iic->xtcntlss), in_8(&iic->directcntl));\n}\n#  define DUMP_REGS(h,dev)\tdump_iic_regs((h),(dev))\n#else\n#  define DUMP_REGS(h,dev)\t((void)0)\n#endif\n\n \nstatic struct ibm_iic_timings {\n\tunsigned int hd_sta;\n\tunsigned int su_sto;\n\tunsigned int low;\n\tunsigned int high;\n\tunsigned int buf;\n} timings [] = {\n \n{\n\t.hd_sta\t= 4000,\n\t.su_sto\t= 4000,\n\t.low\t= 4700,\n\t.high\t= 4000,\n\t.buf\t= 4700,\n},\n \n{\n\t.hd_sta = 600,\n\t.su_sto\t= 600,\n\t.low \t= 1300,\n\t.high \t= 600,\n\t.buf\t= 1300,\n}};\n\n \nstatic inline void iic_interrupt_mode(struct ibm_iic_private* dev, int enable)\n{\n\tout_8(&dev->vaddr->intmsk, enable ? INTRMSK_EIMTC : 0);\n}\n\n \nstatic void iic_dev_init(struct ibm_iic_private* dev)\n{\n\tvolatile struct iic_regs __iomem *iic = dev->vaddr;\n\n\tDBG(\"%d: init\\n\", dev->idx);\n\n\t \n\tout_8(&iic->lmadr, 0);\n\tout_8(&iic->hmadr, 0);\n\n\t \n\tout_8(&iic->lsadr, 0);\n\tout_8(&iic->hsadr, 0);\n\n\t \n\tout_8(&iic->sts, STS_SCMP | STS_IRQA);\n\tout_8(&iic->extsts, EXTSTS_IRQP | EXTSTS_IRQD | EXTSTS_LA\n\t\t\t    | EXTSTS_ICT | EXTSTS_XFRA);\n\n\t \n\tout_8(&iic->clkdiv, dev->clckdiv);\n\n\t \n\tout_8(&iic->xfrcnt, 0);\n\n\t \n\tout_8(&iic->xtcntlss, XTCNTLSS_SRC | XTCNTLSS_SRS | XTCNTLSS_SWC\n\t\t\t    | XTCNTLSS_SWS);\n\n\t \n\tout_8(&iic->cntl, 0);\n\n\t \n\tiic_interrupt_mode(dev, dev->irq >= 0);\n\n\t \n\tout_8(&iic->mdcntl, MDCNTL_FMDB | MDCNTL_EINT | MDCNTL_EUBS\n\t\t\t    | (dev->fast_mode ? MDCNTL_FSM : 0));\n\n\tDUMP_REGS(\"iic_init\", dev);\n}\n\n \nstatic void iic_dev_reset(struct ibm_iic_private* dev)\n{\n\tvolatile struct iic_regs __iomem *iic = dev->vaddr;\n\tint i;\n\tu8 dc;\n\n\tDBG(\"%d: soft reset\\n\", dev->idx);\n\tDUMP_REGS(\"reset\", dev);\n\n    \t \n\tout_8(&iic->xtcntlss, XTCNTLSS_SRST);\n\n\t \n\tdc = in_8(&iic->directcntl);\n\tif (!DIRCTNL_FREE(dc)){\n\t\tDBG(\"%d: trying to regain bus control\\n\", dev->idx);\n\n\t\t \n\t\tout_8(&iic->directcntl, DIRCNTL_SDAC | DIRCNTL_SCC);\n\n\t\t \n\t\tfor (i = 0; i < 100; ++i){\n\t\t\tdc = in_8(&iic->directcntl);\n\t\t\tif (DIRCTNL_FREE(dc))\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tdc ^= DIRCNTL_SCC;\n\t\t\tout_8(&iic->directcntl, dc);\n\t\t\tudelay(10);\n\t\t\tdc ^= DIRCNTL_SCC;\n\t\t\tout_8(&iic->directcntl, dc);\n\n\t\t\t \n\t\t\tcond_resched();\n\t\t}\n\t}\n\n\t \n\tout_8(&iic->xtcntlss, 0);\n\n\t \n\tiic_dev_init(dev);\n}\n\n \n\n \nstatic int iic_dc_wait(volatile struct iic_regs __iomem *iic, u8 mask)\n{\n\tunsigned long x = jiffies + HZ / 28 + 2;\n\twhile ((in_8(&iic->directcntl) & mask) != mask){\n\t\tif (unlikely(time_after(jiffies, x)))\n\t\t\treturn -1;\n\t\tcond_resched();\n\t}\n\treturn 0;\n}\n\nstatic int iic_smbus_quick(struct ibm_iic_private* dev, const struct i2c_msg* p)\n{\n\tvolatile struct iic_regs __iomem *iic = dev->vaddr;\n\tconst struct ibm_iic_timings *t = &timings[dev->fast_mode ? 1 : 0];\n\tu8 mask, v, sda;\n\tint i, res;\n\n\t \n\tif (unlikely(p->flags & I2C_M_TEN)){\n\t\tDBG(\"%d: smbus_quick - 10 bit addresses are not supported\\n\",\n\t\t\tdev->idx);\n\t\treturn -EINVAL;\n\t}\n\n\tDBG(\"%d: smbus_quick(0x%02x)\\n\", dev->idx, p->addr);\n\n\t \n\tout_8(&iic->xtcntlss, XTCNTLSS_SRST);\n\n\t \n\tout_8(&iic->directcntl, DIRCNTL_SDAC | DIRCNTL_SCC);\n\tif (unlikely(iic_dc_wait(iic, DIRCNTL_MSDA | DIRCNTL_MSC)))\n\t\tgoto err;\n\tndelay(t->buf);\n\n\t \n\tout_8(&iic->directcntl, DIRCNTL_SCC);\n\tsda = 0;\n\tndelay(t->hd_sta);\n\n\t \n\tv = i2c_8bit_addr_from_msg(p);\n\tfor (i = 0, mask = 0x80; i < 8; ++i, mask >>= 1){\n\t\tout_8(&iic->directcntl, sda);\n\t\tndelay(t->low / 2);\n\t\tsda = (v & mask) ? DIRCNTL_SDAC : 0;\n\t\tout_8(&iic->directcntl, sda);\n\t\tndelay(t->low / 2);\n\n\t\tout_8(&iic->directcntl, DIRCNTL_SCC | sda);\n\t\tif (unlikely(iic_dc_wait(iic, DIRCNTL_MSC)))\n\t\t\tgoto err;\n\t\tndelay(t->high);\n\t}\n\n\t \n\tout_8(&iic->directcntl, sda);\n\tndelay(t->low / 2);\n\tout_8(&iic->directcntl, DIRCNTL_SDAC);\n\tndelay(t->low / 2);\n\tout_8(&iic->directcntl, DIRCNTL_SDAC | DIRCNTL_SCC);\n\tif (unlikely(iic_dc_wait(iic, DIRCNTL_MSC)))\n\t\tgoto err;\n\tres = (in_8(&iic->directcntl) & DIRCNTL_MSDA) ? -EREMOTEIO : 1;\n\tndelay(t->high);\n\n\t \n\tout_8(&iic->directcntl, 0);\n\tndelay(t->low);\n\tout_8(&iic->directcntl, DIRCNTL_SCC);\n\tif (unlikely(iic_dc_wait(iic, DIRCNTL_MSC)))\n\t\tgoto err;\n\tndelay(t->su_sto);\n\tout_8(&iic->directcntl, DIRCNTL_SDAC | DIRCNTL_SCC);\n\n\tndelay(t->buf);\n\n\tDBG(\"%d: smbus_quick -> %s\\n\", dev->idx, res ? \"NACK\" : \"ACK\");\nout:\n\t \n\tout_8(&iic->xtcntlss, 0);\n\n\t \n\tiic_dev_init(dev);\n\n\treturn res;\nerr:\n\tDBG(\"%d: smbus_quick - bus is stuck\\n\", dev->idx);\n\tres = -EREMOTEIO;\n\tgoto out;\n}\n\n \nstatic irqreturn_t iic_handler(int irq, void *dev_id)\n{\n\tstruct ibm_iic_private* dev = (struct ibm_iic_private*)dev_id;\n\tvolatile struct iic_regs __iomem *iic = dev->vaddr;\n\n\tDBG2(\"%d: irq handler, STS = 0x%02x, EXTSTS = 0x%02x\\n\",\n\t     dev->idx, in_8(&iic->sts), in_8(&iic->extsts));\n\n\t \n\tout_8(&iic->sts, STS_IRQA | STS_SCMP);\n\twake_up_interruptible(&dev->wq);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic int iic_xfer_result(struct ibm_iic_private* dev)\n{\n\tvolatile struct iic_regs __iomem *iic = dev->vaddr;\n\n\tif (unlikely(in_8(&iic->sts) & STS_ERR)){\n\t\tDBG(\"%d: xfer error, EXTSTS = 0x%02x\\n\", dev->idx,\n\t\t\tin_8(&iic->extsts));\n\n\t\t \n\t\tout_8(&iic->extsts, EXTSTS_IRQP | EXTSTS_IRQD |\n\t\t\tEXTSTS_LA | EXTSTS_ICT | EXTSTS_XFRA);\n\n\t\t \n\t\tout_8(&iic->mdcntl, in_8(&iic->mdcntl) | MDCNTL_FMDB);\n\n\t\t \n\t\tif ((in_8(&iic->extsts) & EXTSTS_BCS_MASK) != EXTSTS_BCS_FREE){\n\t\t\tDBG(\"%d: bus is stuck, resetting\\n\", dev->idx);\n\t\t\tiic_dev_reset(dev);\n\t\t}\n\t\treturn -EREMOTEIO;\n\t}\n\telse\n\t\treturn in_8(&iic->xfrcnt) & XFRCNT_MTC_MASK;\n}\n\n \nstatic void iic_abort_xfer(struct ibm_iic_private* dev)\n{\n\tvolatile struct iic_regs __iomem *iic = dev->vaddr;\n\tunsigned long x;\n\n\tDBG(\"%d: iic_abort_xfer\\n\", dev->idx);\n\n\tout_8(&iic->cntl, CNTL_HMT);\n\n\t \n\tx = jiffies + 2;\n\twhile ((in_8(&iic->extsts) & EXTSTS_BCS_MASK) != EXTSTS_BCS_FREE){\n\t\tif (time_after(jiffies, x)){\n\t\t\tDBG(\"%d: abort timeout, resetting...\\n\", dev->idx);\n\t\t\tiic_dev_reset(dev);\n\t\t\treturn;\n\t\t}\n\t\tschedule();\n\t}\n\n\t \n\tiic_xfer_result(dev);\n}\n\n \nstatic int iic_wait_for_tc(struct ibm_iic_private* dev){\n\n\tvolatile struct iic_regs __iomem *iic = dev->vaddr;\n\tint ret = 0;\n\n\tif (dev->irq >= 0){\n\t\t \n\t\tret = wait_event_interruptible_timeout(dev->wq,\n\t\t\t!(in_8(&iic->sts) & STS_PT), dev->adap.timeout);\n\n\t\tif (unlikely(ret < 0))\n\t\t\tDBG(\"%d: wait interrupted\\n\", dev->idx);\n\t\telse if (unlikely(in_8(&iic->sts) & STS_PT)){\n\t\t\tDBG(\"%d: wait timeout\\n\", dev->idx);\n\t\t\tret = -ETIMEDOUT;\n\t\t}\n\t}\n\telse {\n\t\t \n\t\tunsigned long x = jiffies + dev->adap.timeout;\n\n\t\twhile (in_8(&iic->sts) & STS_PT){\n\t\t\tif (unlikely(time_after(jiffies, x))){\n\t\t\t\tDBG(\"%d: poll timeout\\n\", dev->idx);\n\t\t\t\tret = -ETIMEDOUT;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (signal_pending(current)){\n\t\t\t\tDBG(\"%d: poll interrupted\\n\", dev->idx);\n\t\t\t\tret = -ERESTARTSYS;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tschedule();\n\t\t}\n\t}\n\n\tif (unlikely(ret < 0))\n\t\tiic_abort_xfer(dev);\n\telse\n\t\tret = iic_xfer_result(dev);\n\n\tDBG2(\"%d: iic_wait_for_tc -> %d\\n\", dev->idx, ret);\n\n\treturn ret;\n}\n\n \nstatic int iic_xfer_bytes(struct ibm_iic_private* dev, struct i2c_msg* pm,\n\t\t\t  int combined_xfer)\n{\n\tvolatile struct iic_regs __iomem *iic = dev->vaddr;\n\tchar* buf = pm->buf;\n\tint i, j, loops, ret = 0;\n\tint len = pm->len;\n\n\tu8 cntl = (in_8(&iic->cntl) & CNTL_AMD) | CNTL_PT;\n\tif (pm->flags & I2C_M_RD)\n\t\tcntl |= CNTL_RW;\n\n\tloops = (len + 3) / 4;\n\tfor (i = 0; i < loops; ++i, len -= 4){\n\t\tint count = len > 4 ? 4 : len;\n\t\tu8 cmd = cntl | ((count - 1) << CNTL_TCT_SHIFT);\n\n\t\tif (!(cntl & CNTL_RW))\n\t\t\tfor (j = 0; j < count; ++j)\n\t\t\t\tout_8((void __iomem *)&iic->mdbuf, *buf++);\n\n\t\tif (i < loops - 1)\n\t\t\tcmd |= CNTL_CHT;\n\t\telse if (combined_xfer)\n\t\t\tcmd |= CNTL_RPST;\n\n\t\tDBG2(\"%d: xfer_bytes, %d, CNTL = 0x%02x\\n\", dev->idx, count, cmd);\n\n\t\t \n\t\tout_8(&iic->cntl, cmd);\n\n\t\t \n\t\tret = iic_wait_for_tc(dev);\n\n\t\tif (unlikely(ret < 0))\n\t\t\tbreak;\n\t\telse if (unlikely(ret != count)){\n\t\t\tDBG(\"%d: xfer_bytes, requested %d, transferred %d\\n\",\n\t\t\t\tdev->idx, count, ret);\n\n\t\t\t \n\t\t\tif (combined_xfer || (i < loops - 1))\n    \t\t\t\tiic_abort_xfer(dev);\n\n\t\t\tret = -EREMOTEIO;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (cntl & CNTL_RW)\n\t\t\tfor (j = 0; j < count; ++j)\n\t\t\t\t*buf++ = in_8((void __iomem *)&iic->mdbuf);\n\t}\n\n\treturn ret > 0 ? 0 : ret;\n}\n\n \nstatic inline void iic_address(struct ibm_iic_private* dev, struct i2c_msg* msg)\n{\n\tvolatile struct iic_regs __iomem *iic = dev->vaddr;\n\tu16 addr = msg->addr;\n\n\tDBG2(\"%d: iic_address, 0x%03x (%d-bit)\\n\", dev->idx,\n\t\taddr, msg->flags & I2C_M_TEN ? 10 : 7);\n\n\tif (msg->flags & I2C_M_TEN){\n\t    out_8(&iic->cntl, CNTL_AMD);\n\t    out_8(&iic->lmadr, addr);\n\t    out_8(&iic->hmadr, 0xf0 | ((addr >> 7) & 0x06));\n\t}\n\telse {\n\t    out_8(&iic->cntl, 0);\n\t    out_8(&iic->lmadr, addr << 1);\n\t}\n}\n\nstatic inline int iic_invalid_address(const struct i2c_msg* p)\n{\n\treturn (p->addr > 0x3ff) || (!(p->flags & I2C_M_TEN) && (p->addr > 0x7f));\n}\n\nstatic inline int iic_address_neq(const struct i2c_msg* p1,\n\t\t\t\t  const struct i2c_msg* p2)\n{\n\treturn (p1->addr != p2->addr)\n\t\t|| ((p1->flags & I2C_M_TEN) != (p2->flags & I2C_M_TEN));\n}\n\n \nstatic int iic_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)\n{\n    \tstruct ibm_iic_private* dev = (struct ibm_iic_private*)(i2c_get_adapdata(adap));\n\tvolatile struct iic_regs __iomem *iic = dev->vaddr;\n\tint i, ret = 0;\n\n\tDBG2(\"%d: iic_xfer, %d msg(s)\\n\", dev->idx, num);\n\n\t \n\tif (unlikely(iic_invalid_address(&msgs[0]))){\n\t\tDBG(\"%d: invalid address 0x%03x (%d-bit)\\n\", dev->idx,\n\t\t\tmsgs[0].addr, msgs[0].flags & I2C_M_TEN ? 10 : 7);\n\t\treturn -EINVAL;\n\t}\n\tfor (i = 0; i < num; ++i){\n\t\tif (unlikely(msgs[i].len <= 0)){\n\t\t\tif (num == 1 && !msgs[0].len){\n\t\t\t\t \n\t\t\t\treturn iic_smbus_quick(dev, &msgs[0]);\n\t\t\t}\n\t\t\tDBG(\"%d: invalid len %d in msg[%d]\\n\", dev->idx,\n\t\t\t\tmsgs[i].len, i);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (unlikely(iic_address_neq(&msgs[0], &msgs[i]))){\n\t\t\tDBG(\"%d: invalid addr in msg[%d]\\n\", dev->idx, i);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t \n\tif (unlikely((in_8(&iic->extsts) & EXTSTS_BCS_MASK) != EXTSTS_BCS_FREE)){\n\t\tDBG(\"%d: iic_xfer, bus is not free\\n\", dev->idx);\n\n\t\t \n\t\tiic_dev_reset(dev);\n\n\t\tif ((in_8(&iic->extsts) & EXTSTS_BCS_MASK) != EXTSTS_BCS_FREE){\n\t\t\tDBG(\"%d: iic_xfer, bus is still not free\\n\", dev->idx);\n\t\t\treturn -EREMOTEIO;\n\t\t}\n\t}\n\telse {\n\t\t \n\t\tout_8(&iic->mdcntl, in_8(&iic->mdcntl) | MDCNTL_FMDB);\n\t}\n\n\t \n\tiic_address(dev, &msgs[0]);\n\n\t \n    \tfor (i = 0; i < num && !ret; ++i)\n\t\tret = iic_xfer_bytes(dev, &msgs[i], i < num - 1);\n\n\treturn ret < 0 ? ret : num;\n}\n\nstatic u32 iic_func(struct i2c_adapter *adap)\n{\n\treturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL | I2C_FUNC_10BIT_ADDR;\n}\n\nstatic const struct i2c_algorithm iic_algo = {\n\t.master_xfer \t= iic_xfer,\n\t.functionality\t= iic_func\n};\n\n \nstatic inline u8 iic_clckdiv(unsigned int opb)\n{\n\t \n\tif (!opb){\n\t\tprintk(KERN_WARNING \"ibm-iic: using compatibility value for OPB freq,\"\n\t\t\t\" fix your board specific setup\\n\");\n\t\topb = 50000000;\n\t}\n\n\t \n\topb /= 1000000;\n\n\tif (opb < 20 || opb > 150){\n\t\tprintk(KERN_WARNING \"ibm-iic: invalid OPB clock frequency %u MHz\\n\",\n\t\t\topb);\n\t\topb = opb < 20 ? 20 : 150;\n\t}\n\treturn (u8)((opb + 9) / 10 - 1);\n}\n\nstatic int iic_request_irq(struct platform_device *ofdev,\n\t\t\t\t     struct ibm_iic_private *dev)\n{\n\tstruct device_node *np = ofdev->dev.of_node;\n\tint irq;\n\n\tif (iic_force_poll)\n\t\treturn 0;\n\n\tirq = irq_of_parse_and_map(np, 0);\n\tif (!irq) {\n\t\tdev_err(&ofdev->dev, \"irq_of_parse_and_map failed\\n\");\n\t\treturn 0;\n\t}\n\n\t \n\tiic_interrupt_mode(dev, 0);\n\tif (request_irq(irq, iic_handler, 0, \"IBM IIC\", dev)) {\n\t\tdev_err(&ofdev->dev, \"request_irq %d failed\\n\", irq);\n\t\t \n\t\treturn 0;\n\t}\n\n\treturn irq;\n}\n\n \nstatic int iic_probe(struct platform_device *ofdev)\n{\n\tstruct device_node *np = ofdev->dev.of_node;\n\tstruct ibm_iic_private *dev;\n\tstruct i2c_adapter *adap;\n\tconst u32 *freq;\n\tint ret;\n\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(ofdev, dev);\n\n\tdev->vaddr = of_iomap(np, 0);\n\tif (dev->vaddr == NULL) {\n\t\tdev_err(&ofdev->dev, \"failed to iomap device\\n\");\n\t\tret = -ENXIO;\n\t\tgoto error_cleanup;\n\t}\n\n\tinit_waitqueue_head(&dev->wq);\n\n\tdev->irq = iic_request_irq(ofdev, dev);\n\tif (!dev->irq)\n\t\tdev_warn(&ofdev->dev, \"using polling mode\\n\");\n\n\t \n\tif (iic_force_fast || of_get_property(np, \"fast-mode\", NULL))\n\t\tdev->fast_mode = 1;\n\n\tfreq = of_get_property(np, \"clock-frequency\", NULL);\n\tif (freq == NULL) {\n\t\tfreq = of_get_property(np->parent, \"clock-frequency\", NULL);\n\t\tif (freq == NULL) {\n\t\t\tdev_err(&ofdev->dev, \"Unable to get bus frequency\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto error_cleanup;\n\t\t}\n\t}\n\n\tdev->clckdiv = iic_clckdiv(*freq);\n\tdev_dbg(&ofdev->dev, \"clckdiv = %d\\n\", dev->clckdiv);\n\n\t \n\tiic_dev_init(dev);\n\n\t \n\tadap = &dev->adap;\n\tadap->dev.parent = &ofdev->dev;\n\tadap->dev.of_node = of_node_get(np);\n\tstrscpy(adap->name, \"IBM IIC\", sizeof(adap->name));\n\ti2c_set_adapdata(adap, dev);\n\tadap->class = I2C_CLASS_HWMON | I2C_CLASS_SPD;\n\tadap->algo = &iic_algo;\n\tadap->timeout = HZ;\n\n\tret = i2c_add_adapter(adap);\n\tif (ret  < 0)\n\t\tgoto error_cleanup;\n\n\tdev_info(&ofdev->dev, \"using %s mode\\n\",\n\t\t dev->fast_mode ? \"fast (400 kHz)\" : \"standard (100 kHz)\");\n\n\treturn 0;\n\nerror_cleanup:\n\tif (dev->irq) {\n\t\tiic_interrupt_mode(dev, 0);\n\t\tfree_irq(dev->irq, dev);\n\t}\n\n\tif (dev->vaddr)\n\t\tiounmap(dev->vaddr);\n\n\tkfree(dev);\n\treturn ret;\n}\n\n \nstatic void iic_remove(struct platform_device *ofdev)\n{\n\tstruct ibm_iic_private *dev = platform_get_drvdata(ofdev);\n\n\ti2c_del_adapter(&dev->adap);\n\n\tif (dev->irq) {\n\t\tiic_interrupt_mode(dev, 0);\n\t\tfree_irq(dev->irq, dev);\n\t}\n\n\tiounmap(dev->vaddr);\n\tkfree(dev);\n}\n\nstatic const struct of_device_id ibm_iic_match[] = {\n\t{ .compatible = \"ibm,iic\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, ibm_iic_match);\n\nstatic struct platform_driver ibm_iic_driver = {\n\t.driver = {\n\t\t.name = \"ibm-iic\",\n\t\t.of_match_table = ibm_iic_match,\n\t},\n\t.probe\t= iic_probe,\n\t.remove_new = iic_remove,\n};\n\nmodule_platform_driver(ibm_iic_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}