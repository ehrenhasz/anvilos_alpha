{
  "module_name": "i2c-mlxbf.c",
  "hash_id": "ded6eafa51d3fb81bd7355422d9f0b750c9b6cf9a54b61193668d4e8d0bfc347",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-mlxbf.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/bitfield.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/interrupt.h>\n#include <linux/i2c.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/string.h>\n\n \n#define MLXBF_I2C_FUNC_SMBUS_BLOCK \\\n\t(I2C_FUNC_SMBUS_BLOCK_DATA | I2C_FUNC_SMBUS_BLOCK_PROC_CALL)\n\n#define MLXBF_I2C_FUNC_SMBUS_DEFAULT \\\n\t(I2C_FUNC_SMBUS_BYTE      | I2C_FUNC_SMBUS_BYTE_DATA | \\\n\t I2C_FUNC_SMBUS_WORD_DATA | I2C_FUNC_SMBUS_I2C_BLOCK | \\\n\t I2C_FUNC_SMBUS_PROC_CALL)\n\n#define MLXBF_I2C_FUNC_ALL \\\n\t(MLXBF_I2C_FUNC_SMBUS_DEFAULT | MLXBF_I2C_FUNC_SMBUS_BLOCK | \\\n\t I2C_FUNC_SMBUS_QUICK | I2C_FUNC_SLAVE)\n\n \n\n#define MLXBF_I2C_COALESCE_TYU_ADDR    0x02801300\n#define MLXBF_I2C_COALESCE_TYU_SIZE    0x010\n\n#define MLXBF_I2C_GPIO_TYU_ADDR        0x02802000\n#define MLXBF_I2C_GPIO_TYU_SIZE        0x100\n\n#define MLXBF_I2C_COREPLL_TYU_ADDR     0x02800358\n#define MLXBF_I2C_COREPLL_TYU_SIZE     0x008\n\n#define MLXBF_I2C_COREPLL_YU_ADDR      0x02800c30\n#define MLXBF_I2C_COREPLL_YU_SIZE      0x00c\n\n#define MLXBF_I2C_COREPLL_RSH_YU_ADDR  0x13409824\n#define MLXBF_I2C_COREPLL_RSH_YU_SIZE  0x00c\n\n#define MLXBF_I2C_SHARED_RES_MAX       3\n\n \n\n \n#define MLXBF_I2C_TYU_PLL_OUT_FREQ  (400 * 1000 * 1000)\n \n#define MLXBF_I2C_PLL_IN_FREQ       156250000ULL\n\n \n#define MLNXBF_I2C_COREPLL_CONST    16384ULL\n\n#define MLXBF_I2C_FREQUENCY_1GHZ  1000000000ULL\n\n \n#define MLXBF_I2C_CORE_PLL_REG1         0x4\n#define MLXBF_I2C_CORE_PLL_REG2         0x8\n\n \n#define MLXBF_I2C_CAUSE_OR_EVTEN0    0x14\n#define MLXBF_I2C_CAUSE_OR_CLEAR     0x18\n\n \n#define MLXBF_I2C_CAUSE_ARBITER      0x1c\n\n \n\n \n#define MLXBF_I2C_CAUSE_TRANSACTION_ENDED  BIT(0)\n \n#define MLXBF_I2C_CAUSE_M_ARBITRATION_LOST BIT(1)\n \n#define MLXBF_I2C_CAUSE_UNEXPECTED_START   BIT(2)\n \n#define MLXBF_I2C_CAUSE_UNEXPECTED_STOP    BIT(3)\n \n#define MLXBF_I2C_CAUSE_WAIT_FOR_FW_DATA   BIT(4)\n \n#define MLXBF_I2C_CAUSE_PUT_STOP_FAILED    BIT(5)\n \n#define MLXBF_I2C_CAUSE_PUT_START_FAILED   BIT(6)\n \n#define MLXBF_I2C_CAUSE_CLK_TOGGLE_DONE    BIT(7)\n \n#define MLXBF_I2C_CAUSE_M_FW_TIMEOUT       BIT(8)\n \n#define MLXBF_I2C_CAUSE_M_GW_BUSY_FALL     BIT(9)\n\n#define MLXBF_I2C_CAUSE_MASTER_ARBITER_BITS_MASK     GENMASK(9, 0)\n\n#define MLXBF_I2C_CAUSE_MASTER_STATUS_ERROR \\\n\t(MLXBF_I2C_CAUSE_M_ARBITRATION_LOST | \\\n\t MLXBF_I2C_CAUSE_UNEXPECTED_START | \\\n\t MLXBF_I2C_CAUSE_UNEXPECTED_STOP | \\\n\t MLXBF_I2C_CAUSE_PUT_STOP_FAILED | \\\n\t MLXBF_I2C_CAUSE_PUT_START_FAILED | \\\n\t MLXBF_I2C_CAUSE_CLK_TOGGLE_DONE | \\\n\t MLXBF_I2C_CAUSE_M_FW_TIMEOUT)\n\n \n\n \n#define MLXBF_I2C_CAUSE_WRITE_SUCCESS         BIT(0)\n \n#define MLXBF_I2C_CAUSE_READ_WAIT_FW_RESPONSE BIT(13)\n \n#define MLXBF_I2C_CAUSE_S_GW_BUSY_FALL        BIT(18)\n\n \n#define MLXBF_I2C_CAUSE_COALESCE_0        0x00\n\n#define MLXBF_I2C_CAUSE_TYU_SLAVE_BIT   3\n#define MLXBF_I2C_CAUSE_YU_SLAVE_BIT    1\n\n \n#define MLXBF_I2C_GPIO_0_FUNC_EN_0    0x28\n \n#define MLXBF_I2C_GPIO_0_FORCE_OE_EN  0x30\n \n#define MLXBF_I2C_GPIO_SMBUS_GW_PINS(num) (25 + ((num) << 1))\n\n \n#define MLXBF_I2C_GPIO_SMBUS_GW_MASK(num) \\\n\t(0xffffffff & (~(0x3 << MLXBF_I2C_GPIO_SMBUS_GW_PINS(num))))\n\n#define MLXBF_I2C_GPIO_SMBUS_GW_RESET_PINS(num, val) \\\n\t((val) & MLXBF_I2C_GPIO_SMBUS_GW_MASK(num))\n\n#define MLXBF_I2C_GPIO_SMBUS_GW_ASSERT_PINS(num, val) \\\n\t((val) | (0x3 << MLXBF_I2C_GPIO_SMBUS_GW_PINS(num)))\n\n \n#define MLXBF_I2C_COREPLL_FREQ          MLXBF_I2C_TYU_PLL_OUT_FREQ\n\n \n#define MLXBF_I2C_COREPLL_CORE_F_TYU_MASK   GENMASK(15, 3)\n#define MLXBF_I2C_COREPLL_CORE_OD_TYU_MASK  GENMASK(19, 16)\n#define MLXBF_I2C_COREPLL_CORE_R_TYU_MASK   GENMASK(25, 20)\n\n \n#define MLXBF_I2C_COREPLL_CORE_F_YU_MASK    GENMASK(25, 0)\n#define MLXBF_I2C_COREPLL_CORE_OD_YU_MASK   GENMASK(3, 0)\n#define MLXBF_I2C_COREPLL_CORE_R_YU_MASK    GENMASK(31, 26)\n\n \n#define MLXBF_I2C_SMBUS_TIMER_SCL_LOW_SCL_HIGH    0x00\n#define MLXBF_I2C_SMBUS_TIMER_FALL_RISE_SPIKE     0x04\n#define MLXBF_I2C_SMBUS_TIMER_THOLD               0x08\n#define MLXBF_I2C_SMBUS_TIMER_TSETUP_START_STOP   0x0c\n#define MLXBF_I2C_SMBUS_TIMER_TSETUP_DATA         0x10\n#define MLXBF_I2C_SMBUS_THIGH_MAX_TBUF            0x14\n#define MLXBF_I2C_SMBUS_SCL_LOW_TIMEOUT           0x18\n\n#define MLXBF_I2C_SHIFT_0   0\n#define MLXBF_I2C_SHIFT_8   8\n#define MLXBF_I2C_SHIFT_16  16\n#define MLXBF_I2C_SHIFT_24  24\n\n#define MLXBF_I2C_MASK_8    GENMASK(7, 0)\n#define MLXBF_I2C_MASK_16   GENMASK(15, 0)\n\n#define MLXBF_I2C_MST_ADDR_OFFSET         0x200\n\n \n#define MLXBF_I2C_SMBUS_MASTER_GW         0x0\n \n#define MLXBF_I2C_YU_SMBUS_RS_BYTES       0x100\n#define MLXBF_I2C_RSH_YU_SMBUS_RS_BYTES   0x10c\n \n#define MLXBF_I2C_SMBUS_MASTER_PEC        0x104\n \n#define MLXBF_I2C_SMBUS_MASTER_STATUS     0x108\n \n#define MLXBF_I2C_YU_SMBUS_MASTER_FSM     0x110\n#define MLXBF_I2C_RSH_YU_SMBUS_MASTER_FSM 0x100\n\n \n#define MLXBF_I2C_MASTER_LOCK_BIT         BIT(31)  \n#define MLXBF_I2C_MASTER_BUSY_BIT         BIT(30)  \n#define MLXBF_I2C_MASTER_START_BIT        BIT(29)  \n#define MLXBF_I2C_MASTER_CTL_WRITE_BIT    BIT(28)  \n#define MLXBF_I2C_MASTER_CTL_READ_BIT     BIT(19)  \n#define MLXBF_I2C_MASTER_STOP_BIT         BIT(3)   \n\n#define MLXBF_I2C_MASTER_ENABLE \\\n\t(MLXBF_I2C_MASTER_LOCK_BIT | MLXBF_I2C_MASTER_BUSY_BIT | \\\n\t MLXBF_I2C_MASTER_START_BIT | MLXBF_I2C_MASTER_STOP_BIT)\n\n#define MLXBF_I2C_MASTER_ENABLE_WRITE \\\n\t(MLXBF_I2C_MASTER_ENABLE | MLXBF_I2C_MASTER_CTL_WRITE_BIT)\n\n#define MLXBF_I2C_MASTER_ENABLE_READ \\\n\t(MLXBF_I2C_MASTER_ENABLE | MLXBF_I2C_MASTER_CTL_READ_BIT)\n\n#define MLXBF_I2C_MASTER_WRITE_SHIFT      21  \n#define MLXBF_I2C_MASTER_SEND_PEC_SHIFT   20  \n#define MLXBF_I2C_MASTER_PARSE_EXP_SHIFT  11  \n#define MLXBF_I2C_MASTER_SLV_ADDR_SHIFT   12  \n#define MLXBF_I2C_MASTER_READ_SHIFT       4   \n\n \n#define MLXBF_I2C_MASTER_DATA_DESC_ADDR   0x80\n#define MLXBF_I2C_MASTER_DATA_DESC_SIZE   0x80  \n\n \n#define MLXBF_I2C_MASTER_DATA_R_LENGTH  MLXBF_I2C_MASTER_DATA_DESC_SIZE\n#define MLXBF_I2C_MASTER_DATA_W_LENGTH (MLXBF_I2C_MASTER_DATA_DESC_SIZE - 1)\n\n \n#define MLXBF_I2C_SMBUS_STATUS_BYTE_CNT_DONE      BIT(0)\n \n#define MLXBF_I2C_SMBUS_STATUS_NACK_RCV           BIT(1)\n \n#define MLXBF_I2C_SMBUS_STATUS_READ_ERR           BIT(2)\n \n#define MLXBF_I2C_SMBUS_STATUS_FW_TIMEOUT         BIT(3)\n\n#define MLXBF_I2C_SMBUS_MASTER_STATUS_MASK        GENMASK(3, 0)\n\n#define MLXBF_I2C_SMBUS_MASTER_STATUS_ERROR \\\n\t(MLXBF_I2C_SMBUS_STATUS_NACK_RCV | \\\n\t MLXBF_I2C_SMBUS_STATUS_READ_ERR | \\\n\t MLXBF_I2C_SMBUS_STATUS_FW_TIMEOUT)\n\n#define MLXBF_I2C_SMBUS_MASTER_FSM_STOP_MASK      BIT(31)\n#define MLXBF_I2C_SMBUS_MASTER_FSM_PS_STATE_MASK  BIT(15)\n\n#define MLXBF_I2C_SLV_ADDR_OFFSET             0x400\n\n \n#define MLXBF_I2C_SMBUS_SLAVE_GW              0x0\n \n#define MLXBF_I2C_SMBUS_SLAVE_RS_MASTER_BYTES 0x100\n \n#define MLXBF_I2C_SMBUS_SLAVE_PEC             0x104\n \n#define MLXBF_I2C_SMBUS_SLAVE_FSM             0x110\n \n#define MLXBF_I2C_SMBUS_SLAVE_READY           0x12c\n\n \n#define MLXBF_I2C_SLAVE_BUSY_BIT         BIT(30)  \n#define MLXBF_I2C_SLAVE_WRITE_BIT        BIT(29)  \n\n#define MLXBF_I2C_SLAVE_ENABLE \\\n\t(MLXBF_I2C_SLAVE_BUSY_BIT | MLXBF_I2C_SLAVE_WRITE_BIT)\n\n#define MLXBF_I2C_SLAVE_WRITE_BYTES_SHIFT 22  \n#define MLXBF_I2C_SLAVE_SEND_PEC_SHIFT    21  \n\n \n#define MLXBF_I2C_SLAVE_DATA_DESC_ADDR   0x80\n#define MLXBF_I2C_SLAVE_DATA_DESC_SIZE   0x80  \n\n \n#define MLXBF_I2C_SMBUS_SLAVE_ADDR_CFG        0x114\n#define MLXBF_I2C_SMBUS_SLAVE_ADDR_CNT        16\n#define MLXBF_I2C_SMBUS_SLAVE_ADDR_EN_BIT     BIT(7)\n#define MLXBF_I2C_SMBUS_SLAVE_ADDR_MASK       GENMASK(6, 0)\n\n \n#define MLXBF_I2C_SMBUS_TIMEOUT   (300 * 1000)  \n#define MLXBF_I2C_SMBUS_LOCK_POLL_TIMEOUT (300 * 1000)  \n\n \n#define MLXBF_I2C_POLL_FREQ_IN_USEC        200\n\n#define MLXBF_I2C_SMBUS_OP_CNT_1   1\n#define MLXBF_I2C_SMBUS_OP_CNT_2   2\n#define MLXBF_I2C_SMBUS_OP_CNT_3   3\n#define MLXBF_I2C_SMBUS_MAX_OP_CNT MLXBF_I2C_SMBUS_OP_CNT_3\n\n \n#define MLXBF_I2C_RES_PARAMS(addr, size, str) \\\n\t{ \\\n\t\t.start = (addr), \\\n\t\t.end = (addr) + (size) - 1, \\\n\t\t.name = (str) \\\n\t}\n\nenum {\n\tMLXBF_I2C_TIMING_100KHZ = 100000,\n\tMLXBF_I2C_TIMING_400KHZ = 400000,\n\tMLXBF_I2C_TIMING_1000KHZ = 1000000,\n};\n\nenum {\n\tMLXBF_I2C_F_READ = BIT(0),\n\tMLXBF_I2C_F_WRITE = BIT(1),\n\tMLXBF_I2C_F_NORESTART = BIT(3),\n\tMLXBF_I2C_F_SMBUS_OPERATION = BIT(4),\n\tMLXBF_I2C_F_SMBUS_BLOCK = BIT(5),\n\tMLXBF_I2C_F_SMBUS_PEC = BIT(6),\n\tMLXBF_I2C_F_SMBUS_PROCESS_CALL = BIT(7),\n};\n\n \nenum mlxbf_i2c_chip_type {\n\tMLXBF_I2C_CHIP_TYPE_1,  \n\tMLXBF_I2C_CHIP_TYPE_2,  \n\tMLXBF_I2C_CHIP_TYPE_3  \n};\n\n \nenum {\n\tMLXBF_I2C_SMBUS_RES,\n\tMLXBF_I2C_MST_CAUSE_RES,\n\tMLXBF_I2C_SLV_CAUSE_RES,\n\tMLXBF_I2C_COALESCE_RES,\n\tMLXBF_I2C_SMBUS_TIMER_RES,\n\tMLXBF_I2C_SMBUS_MST_RES,\n\tMLXBF_I2C_SMBUS_SLV_RES,\n\tMLXBF_I2C_COREPLL_RES,\n\tMLXBF_I2C_GPIO_RES,\n\tMLXBF_I2C_END_RES\n};\n\n \nstruct mlxbf_i2c_timings {\n\tu16 scl_high;\t\t \n\tu16 scl_low;\t\t \n\tu8 sda_rise;\t\t \n\tu8 sda_fall;\t\t \n\tu8 scl_rise;\t\t \n\tu8 scl_fall;\t\t \n\tu16 hold_start;\t\t \n\tu16 hold_data;\t\t \n\tu16 setup_start;\t \n\tu16 setup_stop;\t\t \n\tu16 setup_data;\t\t \n\tu16 pad;\t\t \n\tu16 buf;\t\t \n\tu16 thigh_max;\t\t \n\tu32 timeout;\t\t \n};\n\nstruct mlxbf_i2c_smbus_operation {\n\tu32 flags;\n\tu32 length;  \n\tu8 *buffer;\n};\n\nstruct mlxbf_i2c_smbus_request {\n\tu8 slave;\n\tu8 operation_cnt;\n\tstruct mlxbf_i2c_smbus_operation operation[MLXBF_I2C_SMBUS_MAX_OP_CNT];\n};\n\nstruct mlxbf_i2c_resource {\n\tvoid __iomem *io;\n\tstruct resource *params;\n\tstruct mutex *lock;  \n\tu8 type;\n};\n\nstruct mlxbf_i2c_chip_info {\n\tenum mlxbf_i2c_chip_type type;\n\t \n\tstruct mlxbf_i2c_resource *shared_res[MLXBF_I2C_SHARED_RES_MAX];\n\n\t \n\tu64 (*calculate_freq)(struct mlxbf_i2c_resource *corepll_res);\n\n\t \n\tu32 smbus_master_rs_bytes_off;\n\tu32 smbus_master_fsm_off;\n};\n\nstruct mlxbf_i2c_priv {\n\tconst struct mlxbf_i2c_chip_info *chip;\n\tstruct i2c_adapter adap;\n\tstruct mlxbf_i2c_resource *smbus;\n\tstruct mlxbf_i2c_resource *timer;\n\tstruct mlxbf_i2c_resource *mst;\n\tstruct mlxbf_i2c_resource *slv;\n\tstruct mlxbf_i2c_resource *mst_cause;\n\tstruct mlxbf_i2c_resource *slv_cause;\n\tstruct mlxbf_i2c_resource *coalesce;\n\tu64 frequency;  \n\tint bus;  \n\tint irq;\n\tstruct i2c_client *slave[MLXBF_I2C_SMBUS_SLAVE_ADDR_CNT];\n\tu32 resource_version;\n};\n\n \nstatic u64 mlxbf_i2c_corepll_frequency;\n\nstatic struct resource mlxbf_i2c_coalesce_tyu_params =\n\t\tMLXBF_I2C_RES_PARAMS(MLXBF_I2C_COALESCE_TYU_ADDR,\n\t\t\t\t     MLXBF_I2C_COALESCE_TYU_SIZE,\n\t\t\t\t     \"COALESCE_MEM\");\nstatic struct resource mlxbf_i2c_corepll_tyu_params =\n\t\tMLXBF_I2C_RES_PARAMS(MLXBF_I2C_COREPLL_TYU_ADDR,\n\t\t\t\t     MLXBF_I2C_COREPLL_TYU_SIZE,\n\t\t\t\t     \"COREPLL_MEM\");\nstatic struct resource mlxbf_i2c_corepll_yu_params =\n\t\tMLXBF_I2C_RES_PARAMS(MLXBF_I2C_COREPLL_YU_ADDR,\n\t\t\t\t     MLXBF_I2C_COREPLL_YU_SIZE,\n\t\t\t\t     \"COREPLL_MEM\");\nstatic struct resource mlxbf_i2c_corepll_rsh_yu_params =\n\t\tMLXBF_I2C_RES_PARAMS(MLXBF_I2C_COREPLL_RSH_YU_ADDR,\n\t\t\t\t     MLXBF_I2C_COREPLL_RSH_YU_SIZE,\n\t\t\t\t     \"COREPLL_MEM\");\nstatic struct resource mlxbf_i2c_gpio_tyu_params =\n\t\tMLXBF_I2C_RES_PARAMS(MLXBF_I2C_GPIO_TYU_ADDR,\n\t\t\t\t     MLXBF_I2C_GPIO_TYU_SIZE,\n\t\t\t\t     \"GPIO_MEM\");\n\nstatic struct mutex mlxbf_i2c_coalesce_lock;\nstatic struct mutex mlxbf_i2c_corepll_lock;\nstatic struct mutex mlxbf_i2c_gpio_lock;\n\nstatic struct mlxbf_i2c_resource mlxbf_i2c_coalesce_res[] = {\n\t[MLXBF_I2C_CHIP_TYPE_1] = {\n\t\t.params = &mlxbf_i2c_coalesce_tyu_params,\n\t\t.lock = &mlxbf_i2c_coalesce_lock,\n\t\t.type = MLXBF_I2C_COALESCE_RES\n\t},\n\t{}\n};\n\nstatic struct mlxbf_i2c_resource mlxbf_i2c_corepll_res[] = {\n\t[MLXBF_I2C_CHIP_TYPE_1] = {\n\t\t.params = &mlxbf_i2c_corepll_tyu_params,\n\t\t.lock = &mlxbf_i2c_corepll_lock,\n\t\t.type = MLXBF_I2C_COREPLL_RES\n\t},\n\t[MLXBF_I2C_CHIP_TYPE_2] = {\n\t\t.params = &mlxbf_i2c_corepll_yu_params,\n\t\t.lock = &mlxbf_i2c_corepll_lock,\n\t\t.type = MLXBF_I2C_COREPLL_RES,\n\t},\n\t[MLXBF_I2C_CHIP_TYPE_3] = {\n\t\t.params = &mlxbf_i2c_corepll_rsh_yu_params,\n\t\t.lock = &mlxbf_i2c_corepll_lock,\n\t\t.type = MLXBF_I2C_COREPLL_RES,\n\t}\n};\n\nstatic struct mlxbf_i2c_resource mlxbf_i2c_gpio_res[] = {\n\t[MLXBF_I2C_CHIP_TYPE_1] = {\n\t\t.params = &mlxbf_i2c_gpio_tyu_params,\n\t\t.lock = &mlxbf_i2c_gpio_lock,\n\t\t.type = MLXBF_I2C_GPIO_RES\n\t},\n\t{}\n};\n\nstatic u8 mlxbf_i2c_bus_count;\n\nstatic struct mutex mlxbf_i2c_bus_lock;\n\n \nstatic u32 mlxbf_i2c_poll(void __iomem *io, u32 addr, u32 mask,\n\t\t\t    bool eq_zero, u32  timeout)\n{\n\tu32 bits;\n\n\ttimeout = (timeout / MLXBF_I2C_POLL_FREQ_IN_USEC) + 1;\n\n\tdo {\n\t\tbits = readl(io + addr) & mask;\n\t\tif (eq_zero ? bits == 0 : bits != 0)\n\t\t\treturn eq_zero ? 1 : bits;\n\t\tudelay(MLXBF_I2C_POLL_FREQ_IN_USEC);\n\t} while (timeout-- != 0);\n\n\treturn 0;\n}\n\n \nstatic bool mlxbf_i2c_smbus_master_wait_for_idle(struct mlxbf_i2c_priv *priv)\n{\n\tu32 mask = MLXBF_I2C_SMBUS_MASTER_FSM_STOP_MASK;\n\tu32 addr = priv->chip->smbus_master_fsm_off;\n\tu32 timeout = MLXBF_I2C_SMBUS_TIMEOUT;\n\n\tif (mlxbf_i2c_poll(priv->mst->io, addr, mask, true, timeout))\n\t\treturn true;\n\n\treturn false;\n}\n\n \nstatic bool mlxbf_i2c_smbus_master_lock(struct mlxbf_i2c_priv *priv)\n{\n\tif (mlxbf_i2c_poll(priv->mst->io, MLXBF_I2C_SMBUS_MASTER_GW,\n\t\t\t   MLXBF_I2C_MASTER_LOCK_BIT, true,\n\t\t\t   MLXBF_I2C_SMBUS_LOCK_POLL_TIMEOUT))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic void mlxbf_i2c_smbus_master_unlock(struct mlxbf_i2c_priv *priv)\n{\n\t \n\twritel(0, priv->mst->io + MLXBF_I2C_SMBUS_MASTER_GW);\n}\n\nstatic bool mlxbf_i2c_smbus_transaction_success(u32 master_status,\n\t\t\t\t\t\tu32 cause_status)\n{\n\t \n\tif ((cause_status & MLXBF_I2C_CAUSE_WAIT_FOR_FW_DATA) ||\n\t    ((cause_status & MLXBF_I2C_CAUSE_TRANSACTION_ENDED) &&\n\t     (master_status & MLXBF_I2C_SMBUS_STATUS_BYTE_CNT_DONE) &&\n\t     !(master_status & MLXBF_I2C_SMBUS_STATUS_NACK_RCV)))\n\t\treturn true;\n\n\treturn false;\n}\n\n \nstatic int mlxbf_i2c_smbus_check_status(struct mlxbf_i2c_priv *priv)\n{\n\tu32 master_status_bits;\n\tu32 cause_status_bits;\n\n\t \n\tmlxbf_i2c_poll(priv->mst->io, MLXBF_I2C_SMBUS_MASTER_GW,\n\t\t\t MLXBF_I2C_MASTER_BUSY_BIT, true,\n\t\t\t MLXBF_I2C_SMBUS_TIMEOUT);\n\n\t \n\tcause_status_bits = readl(priv->mst_cause->io +\n\t\t\t\t\tMLXBF_I2C_CAUSE_ARBITER);\n\tcause_status_bits &= MLXBF_I2C_CAUSE_MASTER_ARBITER_BITS_MASK;\n\n\t \n\n\tmaster_status_bits = readl(priv->mst->io +\n\t\t\t\t\tMLXBF_I2C_SMBUS_MASTER_STATUS);\n\tmaster_status_bits &= MLXBF_I2C_SMBUS_MASTER_STATUS_MASK;\n\n\tif (mlxbf_i2c_smbus_transaction_success(master_status_bits,\n\t\t\t\t\t\tcause_status_bits))\n\t\treturn 0;\n\n\t \n\tif ((master_status_bits & MLXBF_I2C_SMBUS_MASTER_STATUS_ERROR) &&\n\t    (cause_status_bits & (MLXBF_I2C_CAUSE_TRANSACTION_ENDED |\n\t\t\t\t  MLXBF_I2C_CAUSE_M_GW_BUSY_FALL)))\n\t\treturn -EIO;\n\n\tif (cause_status_bits & MLXBF_I2C_CAUSE_MASTER_STATUS_ERROR)\n\t\treturn -EAGAIN;\n\n\treturn -ETIMEDOUT;\n}\n\nstatic void mlxbf_i2c_smbus_write_data(struct mlxbf_i2c_priv *priv,\n\t\t\t\t       const u8 *data, u8 length, u32 addr,\n\t\t\t\t       bool is_master)\n{\n\tu8 offset, aligned_length;\n\tu32 data32;\n\n\taligned_length = round_up(length, 4);\n\n\t \n\tfor (offset = 0; offset < aligned_length; offset += sizeof(u32)) {\n\t\tdata32 = *((u32 *)(data + offset));\n\t\tif (is_master)\n\t\t\tiowrite32be(data32, priv->mst->io + addr + offset);\n\t\telse\n\t\t\tiowrite32be(data32, priv->slv->io + addr + offset);\n\t}\n}\n\nstatic void mlxbf_i2c_smbus_read_data(struct mlxbf_i2c_priv *priv,\n\t\t\t\t      u8 *data, u8 length, u32 addr,\n\t\t\t\t      bool is_master)\n{\n\tu32 data32, mask;\n\tu8 byte, offset;\n\n\tmask = sizeof(u32) - 1;\n\n\t \n\n\tfor (offset = 0; offset < (length & ~mask); offset += sizeof(u32)) {\n\t\tif (is_master)\n\t\t\tdata32 = ioread32be(priv->mst->io + addr + offset);\n\t\telse\n\t\t\tdata32 = ioread32be(priv->slv->io + addr + offset);\n\t\t*((u32 *)(data + offset)) = data32;\n\t}\n\n\tif (!(length & mask))\n\t\treturn;\n\n\tif (is_master)\n\t\tdata32 = ioread32be(priv->mst->io + addr + offset);\n\telse\n\t\tdata32 = ioread32be(priv->slv->io + addr + offset);\n\n\tfor (byte = 0; byte < (length & mask); byte++) {\n\t\tdata[offset + byte] = data32 & GENMASK(7, 0);\n\t\tdata32 = ror32(data32, MLXBF_I2C_SHIFT_8);\n\t}\n}\n\nstatic int mlxbf_i2c_smbus_enable(struct mlxbf_i2c_priv *priv, u8 slave,\n\t\t\t\t  u8 len, u8 block_en, u8 pec_en, bool read)\n{\n\tu32 command;\n\n\t \n\tif (read) {\n\t\tcommand = MLXBF_I2C_MASTER_ENABLE_READ;\n\t\tcommand |= rol32(len, MLXBF_I2C_MASTER_READ_SHIFT);\n\t} else {\n\t\tcommand = MLXBF_I2C_MASTER_ENABLE_WRITE;\n\t\tcommand |= rol32(len, MLXBF_I2C_MASTER_WRITE_SHIFT);\n\t}\n\tcommand |= rol32(slave, MLXBF_I2C_MASTER_SLV_ADDR_SHIFT);\n\tcommand |= rol32(block_en, MLXBF_I2C_MASTER_PARSE_EXP_SHIFT);\n\tcommand |= rol32(pec_en, MLXBF_I2C_MASTER_SEND_PEC_SHIFT);\n\n\t \n\twritel(0x0, priv->mst->io + MLXBF_I2C_SMBUS_MASTER_STATUS);\n\t \n\twritel(~0x0, priv->mst_cause->io + MLXBF_I2C_CAUSE_OR_CLEAR);\n\t \n\twritel(0x0, priv->mst->io + MLXBF_I2C_SMBUS_MASTER_PEC);\n\t \n\twritel(0x0, priv->mst->io + priv->chip->smbus_master_rs_bytes_off);\n\n\t \n\twritel(command, priv->mst->io + MLXBF_I2C_SMBUS_MASTER_GW);\n\n\t \n\treturn mlxbf_i2c_smbus_check_status(priv);\n}\n\nstatic int\nmlxbf_i2c_smbus_start_transaction(struct mlxbf_i2c_priv *priv,\n\t\t\t\t  struct mlxbf_i2c_smbus_request *request)\n{\n\tu8 data_desc[MLXBF_I2C_MASTER_DATA_DESC_SIZE] = { 0 };\n\tu8 op_idx, data_idx, data_len, write_len, read_len;\n\tstruct mlxbf_i2c_smbus_operation *operation;\n\tu8 read_en, write_en, block_en, pec_en;\n\tu8 slave, flags, addr;\n\tu8 *read_buf;\n\tint ret = 0;\n\n\tif (request->operation_cnt > MLXBF_I2C_SMBUS_MAX_OP_CNT)\n\t\treturn -EINVAL;\n\n\tread_buf = NULL;\n\tdata_idx = 0;\n\tread_en = 0;\n\twrite_en = 0;\n\twrite_len = 0;\n\tread_len = 0;\n\tblock_en = 0;\n\tpec_en = 0;\n\tslave = request->slave & GENMASK(6, 0);\n\taddr = slave << 1;\n\n\t \n\tif (WARN_ON(!mlxbf_i2c_smbus_master_lock(priv)))\n\t\treturn -EBUSY;\n\n\t \n\tif (WARN_ON(!mlxbf_i2c_smbus_master_wait_for_idle(priv))) {\n\t\tret = -EBUSY;\n\t\tgoto out_unlock;\n\t}\n\n\t \n\tdata_desc[data_idx++] = addr;\n\n\tfor (op_idx = 0; op_idx < request->operation_cnt; op_idx++) {\n\t\toperation = &request->operation[op_idx];\n\t\tflags = operation->flags;\n\n\t\t \n\t\tif (op_idx == 0 && flags & MLXBF_I2C_F_SMBUS_OPERATION) {\n\t\t\tblock_en = flags & MLXBF_I2C_F_SMBUS_BLOCK;\n\t\t\tpec_en = flags & MLXBF_I2C_F_SMBUS_PEC;\n\t\t}\n\n\t\tif (flags & MLXBF_I2C_F_WRITE) {\n\t\t\twrite_en = 1;\n\t\t\twrite_len += operation->length;\n\t\t\tif (data_idx + operation->length >\n\t\t\t\t\tMLXBF_I2C_MASTER_DATA_DESC_SIZE) {\n\t\t\t\tret = -ENOBUFS;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t\tmemcpy(data_desc + data_idx,\n\t\t\t       operation->buffer, operation->length);\n\t\t\tdata_idx += operation->length;\n\t\t}\n\t\t \n\t\tif (flags & MLXBF_I2C_F_READ) {\n\t\t\tread_en = 1;\n\t\t\t \n\t\t\tread_len = operation->length - 1;\n\t\t\tread_buf = operation->buffer;\n\t\t}\n\t}\n\n\t \n\tdata_len = write_len + 1;  \n\t \n\tmlxbf_i2c_smbus_write_data(priv, (const u8 *)data_desc, data_len,\n\t\t\t\t   MLXBF_I2C_MASTER_DATA_DESC_ADDR, true);\n\n\tif (write_en) {\n\t\tret = mlxbf_i2c_smbus_enable(priv, slave, write_len, block_en,\n\t\t\t\t\t pec_en, 0);\n\t\tif (ret)\n\t\t\tgoto out_unlock;\n\t}\n\n\tif (read_en) {\n\t\t \n\t\tmlxbf_i2c_smbus_write_data(priv, (const u8 *)&addr, 1,\n\t\t\t\t\t   MLXBF_I2C_MASTER_DATA_DESC_ADDR, true);\n\t\tret = mlxbf_i2c_smbus_enable(priv, slave, read_len, block_en,\n\t\t\t\t\t pec_en, 1);\n\t\tif (!ret) {\n\t\t\t \n\t\t\tmlxbf_i2c_smbus_read_data(priv, data_desc, read_len + 1,\n\t\t\t\t\t     MLXBF_I2C_MASTER_DATA_DESC_ADDR, true);\n\n\t\t\t \n\t\t\tmemcpy(read_buf, data_desc, read_len + 1);\n\t\t}\n\n\t\t \n\t\twritel(MLXBF_I2C_SMBUS_MASTER_FSM_PS_STATE_MASK,\n\t\t\tpriv->mst->io + priv->chip->smbus_master_fsm_off);\n\t}\n\nout_unlock:\n\tmlxbf_i2c_smbus_master_unlock(priv);\n\n\treturn ret;\n}\n\n \n\nstatic void\nmlxbf_i2c_smbus_quick_command(struct mlxbf_i2c_smbus_request *request,\n\t\t\t      u8 read)\n{\n\trequest->operation_cnt = MLXBF_I2C_SMBUS_OP_CNT_1;\n\n\trequest->operation[0].length = 0;\n\trequest->operation[0].flags = MLXBF_I2C_F_WRITE;\n\trequest->operation[0].flags |= read ? MLXBF_I2C_F_READ : 0;\n}\n\nstatic void mlxbf_i2c_smbus_byte_func(struct mlxbf_i2c_smbus_request *request,\n\t\t\t\t      u8 *data, bool read, bool pec_check)\n{\n\trequest->operation_cnt = MLXBF_I2C_SMBUS_OP_CNT_1;\n\n\trequest->operation[0].length = 1;\n\trequest->operation[0].length += pec_check;\n\n\trequest->operation[0].flags = MLXBF_I2C_F_SMBUS_OPERATION;\n\trequest->operation[0].flags |= read ?\n\t\t\t\tMLXBF_I2C_F_READ : MLXBF_I2C_F_WRITE;\n\trequest->operation[0].flags |= pec_check ? MLXBF_I2C_F_SMBUS_PEC : 0;\n\n\trequest->operation[0].buffer = data;\n}\n\nstatic void\nmlxbf_i2c_smbus_data_byte_func(struct mlxbf_i2c_smbus_request *request,\n\t\t\t       u8 *command, u8 *data, bool read, bool pec_check)\n{\n\trequest->operation_cnt = MLXBF_I2C_SMBUS_OP_CNT_2;\n\n\trequest->operation[0].length = 1;\n\trequest->operation[0].flags =\n\t\t\tMLXBF_I2C_F_SMBUS_OPERATION | MLXBF_I2C_F_WRITE;\n\trequest->operation[0].flags |= pec_check ? MLXBF_I2C_F_SMBUS_PEC : 0;\n\trequest->operation[0].buffer = command;\n\n\trequest->operation[1].length = 1;\n\trequest->operation[1].length += pec_check;\n\trequest->operation[1].flags = read ?\n\t\t\t\tMLXBF_I2C_F_READ : MLXBF_I2C_F_WRITE;\n\trequest->operation[1].buffer = data;\n}\n\nstatic void\nmlxbf_i2c_smbus_data_word_func(struct mlxbf_i2c_smbus_request *request,\n\t\t\t       u8 *command, u8 *data, bool read, bool pec_check)\n{\n\trequest->operation_cnt = MLXBF_I2C_SMBUS_OP_CNT_2;\n\n\trequest->operation[0].length = 1;\n\trequest->operation[0].flags =\n\t\t\tMLXBF_I2C_F_SMBUS_OPERATION | MLXBF_I2C_F_WRITE;\n\trequest->operation[0].flags |= pec_check ? MLXBF_I2C_F_SMBUS_PEC : 0;\n\trequest->operation[0].buffer = command;\n\n\trequest->operation[1].length = 2;\n\trequest->operation[1].length += pec_check;\n\trequest->operation[1].flags = read ?\n\t\t\t\tMLXBF_I2C_F_READ : MLXBF_I2C_F_WRITE;\n\trequest->operation[1].buffer = data;\n}\n\nstatic void\nmlxbf_i2c_smbus_i2c_block_func(struct mlxbf_i2c_smbus_request *request,\n\t\t\t       u8 *command, u8 *data, u8 *data_len, bool read,\n\t\t\t       bool pec_check)\n{\n\trequest->operation_cnt = MLXBF_I2C_SMBUS_OP_CNT_2;\n\n\trequest->operation[0].length = 1;\n\trequest->operation[0].flags =\n\t\t\tMLXBF_I2C_F_SMBUS_OPERATION | MLXBF_I2C_F_WRITE;\n\trequest->operation[0].flags |= pec_check ? MLXBF_I2C_F_SMBUS_PEC : 0;\n\trequest->operation[0].buffer = command;\n\n\t \n\trequest->operation[1].length =\n\t    (*data_len + pec_check > I2C_SMBUS_BLOCK_MAX) ?\n\t    I2C_SMBUS_BLOCK_MAX : *data_len + pec_check;\n\trequest->operation[1].flags = read ?\n\t\t\t\tMLXBF_I2C_F_READ : MLXBF_I2C_F_WRITE;\n\t \n\trequest->operation[1].buffer = data + 1;\n\n\t*data_len = request->operation[1].length;\n\n\t \n\tif (read)\n\t\tdata[0] = *data_len;\n}\n\nstatic void mlxbf_i2c_smbus_block_func(struct mlxbf_i2c_smbus_request *request,\n\t\t\t\t       u8 *command, u8 *data, u8 *data_len,\n\t\t\t\t       bool read, bool pec_check)\n{\n\trequest->operation_cnt = MLXBF_I2C_SMBUS_OP_CNT_2;\n\n\trequest->operation[0].length = 1;\n\trequest->operation[0].flags =\n\t\t\tMLXBF_I2C_F_SMBUS_OPERATION | MLXBF_I2C_F_WRITE;\n\trequest->operation[0].flags |= MLXBF_I2C_F_SMBUS_BLOCK;\n\trequest->operation[0].flags |= pec_check ? MLXBF_I2C_F_SMBUS_PEC : 0;\n\trequest->operation[0].buffer = command;\n\n\trequest->operation[1].length =\n\t    (*data_len + pec_check > I2C_SMBUS_BLOCK_MAX) ?\n\t    I2C_SMBUS_BLOCK_MAX : *data_len + pec_check;\n\trequest->operation[1].flags = read ?\n\t\t\t\tMLXBF_I2C_F_READ : MLXBF_I2C_F_WRITE;\n\trequest->operation[1].buffer = data + 1;\n\n\t*data_len = request->operation[1].length;\n\n\t \n\tif (read)\n\t\tdata[0] = *data_len;\n}\n\nstatic void\nmlxbf_i2c_smbus_process_call_func(struct mlxbf_i2c_smbus_request *request,\n\t\t\t\t  u8 *command, u8 *data, bool pec_check)\n{\n\trequest->operation_cnt = MLXBF_I2C_SMBUS_OP_CNT_3;\n\n\trequest->operation[0].length = 1;\n\trequest->operation[0].flags =\n\t\t\tMLXBF_I2C_F_SMBUS_OPERATION | MLXBF_I2C_F_WRITE;\n\trequest->operation[0].flags |= MLXBF_I2C_F_SMBUS_BLOCK;\n\trequest->operation[0].flags |= pec_check ? MLXBF_I2C_F_SMBUS_PEC : 0;\n\trequest->operation[0].buffer = command;\n\n\trequest->operation[1].length = 2;\n\trequest->operation[1].flags = MLXBF_I2C_F_WRITE;\n\trequest->operation[1].buffer = data;\n\n\trequest->operation[2].length = 3;\n\trequest->operation[2].flags = MLXBF_I2C_F_READ;\n\trequest->operation[2].buffer = data;\n}\n\nstatic void\nmlxbf_i2c_smbus_blk_process_call_func(struct mlxbf_i2c_smbus_request *request,\n\t\t\t\t      u8 *command, u8 *data, u8 *data_len,\n\t\t\t\t      bool pec_check)\n{\n\tu32 length;\n\n\trequest->operation_cnt = MLXBF_I2C_SMBUS_OP_CNT_3;\n\n\trequest->operation[0].length = 1;\n\trequest->operation[0].flags =\n\t\t\tMLXBF_I2C_F_SMBUS_OPERATION | MLXBF_I2C_F_WRITE;\n\trequest->operation[0].flags |= MLXBF_I2C_F_SMBUS_BLOCK;\n\trequest->operation[0].flags |= (pec_check) ? MLXBF_I2C_F_SMBUS_PEC : 0;\n\trequest->operation[0].buffer = command;\n\n\tlength = (*data_len + pec_check > I2C_SMBUS_BLOCK_MAX) ?\n\t    I2C_SMBUS_BLOCK_MAX : *data_len + pec_check;\n\n\trequest->operation[1].length = length - pec_check;\n\trequest->operation[1].flags = MLXBF_I2C_F_WRITE;\n\trequest->operation[1].buffer = data;\n\n\trequest->operation[2].length = length;\n\trequest->operation[2].flags = MLXBF_I2C_F_READ;\n\trequest->operation[2].buffer = data;\n\n\t*data_len = length;  \n}\n\n \n\nstatic bool mlxbf_i2c_has_chip_type(struct mlxbf_i2c_priv *priv, u8 type)\n{\n\treturn priv->chip->type == type;\n}\n\nstatic struct mlxbf_i2c_resource *\nmlxbf_i2c_get_shared_resource(struct mlxbf_i2c_priv *priv, u8 type)\n{\n\tconst struct mlxbf_i2c_chip_info *chip = priv->chip;\n\tstruct mlxbf_i2c_resource *res;\n\tu8 res_idx = 0;\n\n\tfor (res_idx = 0; res_idx < MLXBF_I2C_SHARED_RES_MAX; res_idx++) {\n\t\tres = chip->shared_res[res_idx];\n\t\tif (res && res->type == type)\n\t\t\treturn res;\n\t}\n\n\treturn NULL;\n}\n\nstatic int mlxbf_i2c_init_resource(struct platform_device *pdev,\n\t\t\t\t   struct mlxbf_i2c_resource **res,\n\t\t\t\t   u8 type)\n{\n\tstruct mlxbf_i2c_resource *tmp_res;\n\tstruct device *dev = &pdev->dev;\n\n\tif (!res || *res || type >= MLXBF_I2C_END_RES)\n\t\treturn -EINVAL;\n\n\ttmp_res = devm_kzalloc(dev, sizeof(struct mlxbf_i2c_resource),\n\t\t\t       GFP_KERNEL);\n\tif (!tmp_res)\n\t\treturn -ENOMEM;\n\n\ttmp_res->io = devm_platform_get_and_ioremap_resource(pdev, type, &tmp_res->params);\n\tif (IS_ERR(tmp_res->io)) {\n\t\tdevm_kfree(dev, tmp_res);\n\t\treturn PTR_ERR(tmp_res->io);\n\t}\n\n\ttmp_res->type = type;\n\n\t*res = tmp_res;\n\n\treturn 0;\n}\n\nstatic u32 mlxbf_i2c_get_ticks(struct mlxbf_i2c_priv *priv, u64 nanoseconds,\n\t\t\t       bool minimum)\n{\n\tu64 frequency;\n\tu32 ticks;\n\n\t \n\tfrequency = priv->frequency;\n\tticks = (nanoseconds * frequency) / MLXBF_I2C_FREQUENCY_1GHZ;\n\t \n\tif (minimum)\n\t\tticks++;\n\n\treturn ticks;\n}\n\nstatic u32 mlxbf_i2c_set_timer(struct mlxbf_i2c_priv *priv, u64 nsec, bool opt,\n\t\t\t       u32 mask, u8 shift)\n{\n\tu32 val = (mlxbf_i2c_get_ticks(priv, nsec, opt) & mask) << shift;\n\n\treturn val;\n}\n\nstatic void mlxbf_i2c_set_timings(struct mlxbf_i2c_priv *priv,\n\t\t\t\t  const struct mlxbf_i2c_timings *timings)\n{\n\tu32 timer;\n\n\ttimer = mlxbf_i2c_set_timer(priv, timings->scl_high,\n\t\t\t\t    false, MLXBF_I2C_MASK_16,\n\t\t\t\t    MLXBF_I2C_SHIFT_0);\n\ttimer |= mlxbf_i2c_set_timer(priv, timings->scl_low,\n\t\t\t\t     false, MLXBF_I2C_MASK_16,\n\t\t\t\t     MLXBF_I2C_SHIFT_16);\n\twritel(timer, priv->timer->io +\n\t\tMLXBF_I2C_SMBUS_TIMER_SCL_LOW_SCL_HIGH);\n\n\ttimer = mlxbf_i2c_set_timer(priv, timings->sda_rise, false,\n\t\t\t\t    MLXBF_I2C_MASK_8, MLXBF_I2C_SHIFT_0);\n\ttimer |= mlxbf_i2c_set_timer(priv, timings->sda_fall, false,\n\t\t\t\t     MLXBF_I2C_MASK_8, MLXBF_I2C_SHIFT_8);\n\ttimer |= mlxbf_i2c_set_timer(priv, timings->scl_rise, false,\n\t\t\t\t     MLXBF_I2C_MASK_8, MLXBF_I2C_SHIFT_16);\n\ttimer |= mlxbf_i2c_set_timer(priv, timings->scl_fall, false,\n\t\t\t\t     MLXBF_I2C_MASK_8, MLXBF_I2C_SHIFT_24);\n\twritel(timer, priv->timer->io +\n\t\tMLXBF_I2C_SMBUS_TIMER_FALL_RISE_SPIKE);\n\n\ttimer = mlxbf_i2c_set_timer(priv, timings->hold_start, true,\n\t\t\t\t    MLXBF_I2C_MASK_16, MLXBF_I2C_SHIFT_0);\n\ttimer |= mlxbf_i2c_set_timer(priv, timings->hold_data, true,\n\t\t\t\t     MLXBF_I2C_MASK_16, MLXBF_I2C_SHIFT_16);\n\twritel(timer, priv->timer->io + MLXBF_I2C_SMBUS_TIMER_THOLD);\n\n\ttimer = mlxbf_i2c_set_timer(priv, timings->setup_start, true,\n\t\t\t\t    MLXBF_I2C_MASK_16, MLXBF_I2C_SHIFT_0);\n\ttimer |= mlxbf_i2c_set_timer(priv, timings->setup_stop, true,\n\t\t\t\t     MLXBF_I2C_MASK_16, MLXBF_I2C_SHIFT_16);\n\twritel(timer, priv->timer->io +\n\t\tMLXBF_I2C_SMBUS_TIMER_TSETUP_START_STOP);\n\n\ttimer = mlxbf_i2c_set_timer(priv, timings->setup_data, true,\n\t\t\t\t    MLXBF_I2C_MASK_16, MLXBF_I2C_SHIFT_0);\n\twritel(timer, priv->timer->io + MLXBF_I2C_SMBUS_TIMER_TSETUP_DATA);\n\n\ttimer = mlxbf_i2c_set_timer(priv, timings->buf, false,\n\t\t\t\t    MLXBF_I2C_MASK_16, MLXBF_I2C_SHIFT_0);\n\ttimer |= mlxbf_i2c_set_timer(priv, timings->thigh_max, false,\n\t\t\t\t     MLXBF_I2C_MASK_16, MLXBF_I2C_SHIFT_16);\n\twritel(timer, priv->timer->io + MLXBF_I2C_SMBUS_THIGH_MAX_TBUF);\n\n\ttimer = timings->timeout;\n\twritel(timer, priv->timer->io + MLXBF_I2C_SMBUS_SCL_LOW_TIMEOUT);\n}\n\nenum mlxbf_i2c_timings_config {\n\tMLXBF_I2C_TIMING_CONFIG_100KHZ,\n\tMLXBF_I2C_TIMING_CONFIG_400KHZ,\n\tMLXBF_I2C_TIMING_CONFIG_1000KHZ,\n};\n\n \nstatic const struct mlxbf_i2c_timings mlxbf_i2c_timings[] = {\n\t[MLXBF_I2C_TIMING_CONFIG_100KHZ] = {\n\t\t.scl_high = 4810,\n\t\t.scl_low = 5000,\n\t\t.hold_start = 4000,\n\t\t.setup_start = 4800,\n\t\t.setup_stop = 4000,\n\t\t.setup_data = 250,\n\t\t.sda_rise = 50,\n\t\t.sda_fall = 50,\n\t\t.scl_rise = 50,\n\t\t.scl_fall = 50,\n\t\t.hold_data = 300,\n\t\t.buf = 20000,\n\t\t.thigh_max = 5000,\n\t\t.timeout = 106500\n\t},\n\t[MLXBF_I2C_TIMING_CONFIG_400KHZ] = {\n\t\t.scl_high = 1011,\n\t\t.scl_low = 1300,\n\t\t.hold_start = 600,\n\t\t.setup_start = 700,\n\t\t.setup_stop = 600,\n\t\t.setup_data = 100,\n\t\t.sda_rise = 50,\n\t\t.sda_fall = 50,\n\t\t.scl_rise = 50,\n\t\t.scl_fall = 50,\n\t\t.hold_data = 300,\n\t\t.buf = 20000,\n\t\t.thigh_max = 5000,\n\t\t.timeout = 106500\n\t},\n\t[MLXBF_I2C_TIMING_CONFIG_1000KHZ] = {\n\t\t.scl_high = 600,\n\t\t.scl_low = 1300,\n\t\t.hold_start = 600,\n\t\t.setup_start = 600,\n\t\t.setup_stop = 600,\n\t\t.setup_data = 100,\n\t\t.sda_rise = 50,\n\t\t.sda_fall = 50,\n\t\t.scl_rise = 50,\n\t\t.scl_fall = 50,\n\t\t.hold_data = 300,\n\t\t.buf = 20000,\n\t\t.thigh_max = 5000,\n\t\t.timeout = 106500\n\t}\n};\n\nstatic int mlxbf_i2c_init_timings(struct platform_device *pdev,\n\t\t\t\t  struct mlxbf_i2c_priv *priv)\n{\n\tenum mlxbf_i2c_timings_config config_idx;\n\tstruct device *dev = &pdev->dev;\n\tu32 config_khz;\n\n\tint ret;\n\n\tret = device_property_read_u32(dev, \"clock-frequency\", &config_khz);\n\tif (ret < 0)\n\t\tconfig_khz = I2C_MAX_STANDARD_MODE_FREQ;\n\n\tswitch (config_khz) {\n\tdefault:\n\t\t \n\t\tpr_warn(\"Illegal value %d: defaulting to 100 KHz\\n\",\n\t\t\tconfig_khz);\n\t\tfallthrough;\n\tcase I2C_MAX_STANDARD_MODE_FREQ:\n\t\tconfig_idx = MLXBF_I2C_TIMING_CONFIG_100KHZ;\n\t\tbreak;\n\n\tcase I2C_MAX_FAST_MODE_FREQ:\n\t\tconfig_idx = MLXBF_I2C_TIMING_CONFIG_400KHZ;\n\t\tbreak;\n\n\tcase I2C_MAX_FAST_MODE_PLUS_FREQ:\n\t\tconfig_idx = MLXBF_I2C_TIMING_CONFIG_1000KHZ;\n\t\tbreak;\n\t}\n\n\tmlxbf_i2c_set_timings(priv, &mlxbf_i2c_timings[config_idx]);\n\n\treturn 0;\n}\n\nstatic int mlxbf_i2c_get_gpio(struct platform_device *pdev,\n\t\t\t      struct mlxbf_i2c_priv *priv)\n{\n\tstruct mlxbf_i2c_resource *gpio_res;\n\tstruct device *dev = &pdev->dev;\n\tstruct resource\t*params;\n\tresource_size_t size;\n\n\tgpio_res = mlxbf_i2c_get_shared_resource(priv, MLXBF_I2C_GPIO_RES);\n\tif (!gpio_res)\n\t\treturn -EPERM;\n\n\t \n\tlockdep_assert_held(gpio_res->lock);\n\n\t \n\tif (gpio_res->io)\n\t\treturn 0;\n\n\tparams = gpio_res->params;\n\tsize = resource_size(params);\n\n\tif (!devm_request_mem_region(dev, params->start, size, params->name))\n\t\treturn -EFAULT;\n\n\tgpio_res->io = devm_ioremap(dev, params->start, size);\n\tif (!gpio_res->io) {\n\t\tdevm_release_mem_region(dev, params->start, size);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic int mlxbf_i2c_release_gpio(struct platform_device *pdev,\n\t\t\t\t  struct mlxbf_i2c_priv *priv)\n{\n\tstruct mlxbf_i2c_resource *gpio_res;\n\tstruct device *dev = &pdev->dev;\n\tstruct resource\t*params;\n\n\tgpio_res = mlxbf_i2c_get_shared_resource(priv, MLXBF_I2C_GPIO_RES);\n\tif (!gpio_res)\n\t\treturn 0;\n\n\tmutex_lock(gpio_res->lock);\n\n\tif (gpio_res->io) {\n\t\t \n\t\tparams = gpio_res->params;\n\t\tdevm_iounmap(dev, gpio_res->io);\n\t\tdevm_release_mem_region(dev, params->start,\n\t\t\t\t\tresource_size(params));\n\t}\n\n\tmutex_unlock(gpio_res->lock);\n\n\treturn 0;\n}\n\nstatic int mlxbf_i2c_get_corepll(struct platform_device *pdev,\n\t\t\t\t struct mlxbf_i2c_priv *priv)\n{\n\tstruct mlxbf_i2c_resource *corepll_res;\n\tstruct device *dev = &pdev->dev;\n\tstruct resource *params;\n\tresource_size_t size;\n\n\tcorepll_res = mlxbf_i2c_get_shared_resource(priv,\n\t\t\t\t\t\t    MLXBF_I2C_COREPLL_RES);\n\tif (!corepll_res)\n\t\treturn -EPERM;\n\n\t \n\tlockdep_assert_held(corepll_res->lock);\n\n\t \n\tif (corepll_res->io)\n\t\treturn 0;\n\n\tparams = corepll_res->params;\n\tsize = resource_size(params);\n\n\tif (!devm_request_mem_region(dev, params->start, size, params->name))\n\t\treturn -EFAULT;\n\n\tcorepll_res->io = devm_ioremap(dev, params->start, size);\n\tif (!corepll_res->io) {\n\t\tdevm_release_mem_region(dev, params->start, size);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic int mlxbf_i2c_release_corepll(struct platform_device *pdev,\n\t\t\t\t     struct mlxbf_i2c_priv *priv)\n{\n\tstruct mlxbf_i2c_resource *corepll_res;\n\tstruct device *dev = &pdev->dev;\n\tstruct resource *params;\n\n\tcorepll_res = mlxbf_i2c_get_shared_resource(priv,\n\t\t\t\t\t\t    MLXBF_I2C_COREPLL_RES);\n\n\tmutex_lock(corepll_res->lock);\n\n\tif (corepll_res->io) {\n\t\t \n\t\tparams = corepll_res->params;\n\t\tdevm_iounmap(dev, corepll_res->io);\n\t\tdevm_release_mem_region(dev, params->start,\n\t\t\t\t\tresource_size(params));\n\t}\n\n\tmutex_unlock(corepll_res->lock);\n\n\treturn 0;\n}\n\nstatic int mlxbf_i2c_init_master(struct platform_device *pdev,\n\t\t\t\t struct mlxbf_i2c_priv *priv)\n{\n\tstruct mlxbf_i2c_resource *gpio_res;\n\tstruct device *dev = &pdev->dev;\n\tu32 config_reg;\n\tint ret;\n\n\t \n\tif (!mlxbf_i2c_has_chip_type(priv, MLXBF_I2C_CHIP_TYPE_1))\n\t\treturn 0;\n\n\tgpio_res = mlxbf_i2c_get_shared_resource(priv, MLXBF_I2C_GPIO_RES);\n\tif (!gpio_res)\n\t\treturn -EPERM;\n\n\t \n\n\tmutex_lock(gpio_res->lock);\n\n\tret = mlxbf_i2c_get_gpio(pdev, priv);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to get gpio resource\");\n\t\tmutex_unlock(gpio_res->lock);\n\t\treturn ret;\n\t}\n\n\t \n\tconfig_reg = readl(gpio_res->io + MLXBF_I2C_GPIO_0_FUNC_EN_0);\n\tconfig_reg = MLXBF_I2C_GPIO_SMBUS_GW_ASSERT_PINS(priv->bus,\n\t\t\t\t\t\t\t config_reg);\n\twritel(config_reg, gpio_res->io + MLXBF_I2C_GPIO_0_FUNC_EN_0);\n\n\tconfig_reg = readl(gpio_res->io + MLXBF_I2C_GPIO_0_FORCE_OE_EN);\n\tconfig_reg = MLXBF_I2C_GPIO_SMBUS_GW_RESET_PINS(priv->bus,\n\t\t\t\t\t\t\tconfig_reg);\n\twritel(config_reg, gpio_res->io + MLXBF_I2C_GPIO_0_FORCE_OE_EN);\n\n\tmutex_unlock(gpio_res->lock);\n\n\treturn 0;\n}\n\nstatic u64 mlxbf_i2c_calculate_freq_from_tyu(struct mlxbf_i2c_resource *corepll_res)\n{\n\tu64 core_frequency;\n\tu8 core_od, core_r;\n\tu32 corepll_val;\n\tu16 core_f;\n\n\tcorepll_val = readl(corepll_res->io + MLXBF_I2C_CORE_PLL_REG1);\n\n\t \n\tcore_f = FIELD_GET(MLXBF_I2C_COREPLL_CORE_F_TYU_MASK, corepll_val);\n\tcore_od = FIELD_GET(MLXBF_I2C_COREPLL_CORE_OD_TYU_MASK, corepll_val);\n\tcore_r = FIELD_GET(MLXBF_I2C_COREPLL_CORE_R_TYU_MASK, corepll_val);\n\n\t \n\tcore_frequency = MLXBF_I2C_PLL_IN_FREQ * (++core_f);\n\tcore_frequency /= (++core_r) * (++core_od);\n\n\treturn core_frequency;\n}\n\nstatic u64 mlxbf_i2c_calculate_freq_from_yu(struct mlxbf_i2c_resource *corepll_res)\n{\n\tu32 corepll_reg1_val, corepll_reg2_val;\n\tu64 corepll_frequency;\n\tu8 core_od, core_r;\n\tu32 core_f;\n\n\tcorepll_reg1_val = readl(corepll_res->io + MLXBF_I2C_CORE_PLL_REG1);\n\tcorepll_reg2_val = readl(corepll_res->io + MLXBF_I2C_CORE_PLL_REG2);\n\n\t \n\tcore_f = FIELD_GET(MLXBF_I2C_COREPLL_CORE_F_YU_MASK, corepll_reg1_val);\n\tcore_r = FIELD_GET(MLXBF_I2C_COREPLL_CORE_R_YU_MASK, corepll_reg1_val);\n\tcore_od = FIELD_GET(MLXBF_I2C_COREPLL_CORE_OD_YU_MASK, corepll_reg2_val);\n\n\t \n\tcorepll_frequency = (MLXBF_I2C_PLL_IN_FREQ * core_f) / MLNXBF_I2C_COREPLL_CONST;\n\tcorepll_frequency /= (++core_r) * (++core_od);\n\n\treturn corepll_frequency;\n}\n\nstatic int mlxbf_i2c_calculate_corepll_freq(struct platform_device *pdev,\n\t\t\t\t\t    struct mlxbf_i2c_priv *priv)\n{\n\tconst struct mlxbf_i2c_chip_info *chip = priv->chip;\n\tstruct mlxbf_i2c_resource *corepll_res;\n\tstruct device *dev = &pdev->dev;\n\tu64 *freq = &priv->frequency;\n\tint ret;\n\n\tcorepll_res = mlxbf_i2c_get_shared_resource(priv,\n\t\t\t\t\t\t    MLXBF_I2C_COREPLL_RES);\n\tif (!corepll_res)\n\t\treturn -EPERM;\n\n\t \n\tmutex_lock(corepll_res->lock);\n\tif (!mlxbf_i2c_corepll_frequency) {\n\t\tif (!chip->calculate_freq) {\n\t\t\tmutex_unlock(corepll_res->lock);\n\t\t\treturn -EPERM;\n\t\t}\n\n\t\tret = mlxbf_i2c_get_corepll(pdev, priv);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"Failed to get corePLL resource\");\n\t\t\tmutex_unlock(corepll_res->lock);\n\t\t\treturn ret;\n\t\t}\n\n\t\tmlxbf_i2c_corepll_frequency = chip->calculate_freq(corepll_res);\n\t}\n\tmutex_unlock(corepll_res->lock);\n\n\t*freq = mlxbf_i2c_corepll_frequency;\n\n\treturn 0;\n}\n\nstatic int mlxbf_i2c_slave_enable(struct mlxbf_i2c_priv *priv,\n\t\t\t      struct i2c_client *slave)\n{\n\tu8 reg, reg_cnt, byte, addr_tmp;\n\tu32 slave_reg, slave_reg_tmp;\n\n\tif (!priv)\n\t\treturn -EPERM;\n\n\treg_cnt = MLXBF_I2C_SMBUS_SLAVE_ADDR_CNT >> 2;\n\n\t \n\tfor (reg = 0; reg < reg_cnt; reg++) {\n\t\tslave_reg = readl(priv->slv->io +\n\t\t\t\tMLXBF_I2C_SMBUS_SLAVE_ADDR_CFG + reg * 0x4);\n\t\t \n\t\tslave_reg_tmp = slave_reg;\n\t\tfor (byte = 0; byte < 4; byte++) {\n\t\t\taddr_tmp = slave_reg_tmp & GENMASK(7, 0);\n\n\t\t\t \n\t\t\tif (!(addr_tmp & MLXBF_I2C_SMBUS_SLAVE_ADDR_EN_BIT)) {\n\t\t\t\tslave_reg &= ~(MLXBF_I2C_SMBUS_SLAVE_ADDR_MASK << (byte * 8));\n\t\t\t\tslave_reg |= (slave->addr << (byte * 8));\n\t\t\t\tslave_reg |= MLXBF_I2C_SMBUS_SLAVE_ADDR_EN_BIT << (byte * 8);\n\t\t\t\twritel(slave_reg, priv->slv->io +\n\t\t\t\t\tMLXBF_I2C_SMBUS_SLAVE_ADDR_CFG +\n\t\t\t\t\t(reg * 0x4));\n\n\t\t\t\t \n\t\t\t\tpriv->slave[(reg * 4) + byte] = slave;\n\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t \n\t\t\tslave_reg_tmp >>= 8;\n\t\t}\n\t}\n\n\treturn -EBUSY;\n}\n\nstatic int mlxbf_i2c_slave_disable(struct mlxbf_i2c_priv *priv, u8 addr)\n{\n\tu8 addr_tmp, reg, reg_cnt, byte;\n\tu32 slave_reg, slave_reg_tmp;\n\n\treg_cnt = MLXBF_I2C_SMBUS_SLAVE_ADDR_CNT >> 2;\n\n\t \n\tfor (reg = 0; reg < reg_cnt; reg++) {\n\t\tslave_reg = readl(priv->slv->io +\n\t\t\t\tMLXBF_I2C_SMBUS_SLAVE_ADDR_CFG + reg * 0x4);\n\n\t\t \n\t\tif (!slave_reg)\n\t\t\tcontinue;\n\n\t\t \n\t\tslave_reg_tmp = slave_reg;\n\t\tfor (byte = 0; byte < 4; byte++) {\n\t\t\taddr_tmp = slave_reg_tmp & MLXBF_I2C_SMBUS_SLAVE_ADDR_MASK;\n\t\t\t \n\t\t\tif (addr_tmp == addr) {\n\t\t\t\t \n\t\t\t\tslave_reg &= ~(GENMASK(7, 0) << (byte * 8));\n\t\t\t\twritel(slave_reg, priv->slv->io +\n\t\t\t\t\tMLXBF_I2C_SMBUS_SLAVE_ADDR_CFG +\n\t\t\t\t\t(reg * 0x4));\n\t\t\t\t \n\t\t\t\tpriv->slave[(reg * 4) + byte] = NULL;\n\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t \n\t\t\tslave_reg_tmp >>= 8;\n\t\t}\n\t}\n\n\treturn -ENXIO;\n}\n\nstatic int mlxbf_i2c_init_coalesce(struct platform_device *pdev,\n\t\t\t\t   struct mlxbf_i2c_priv *priv)\n{\n\tstruct mlxbf_i2c_resource *coalesce_res;\n\tstruct resource *params;\n\tresource_size_t size;\n\tint ret = 0;\n\n\t \n\tif (mlxbf_i2c_has_chip_type(priv, MLXBF_I2C_CHIP_TYPE_1)) {\n\t\tcoalesce_res = mlxbf_i2c_get_shared_resource(priv,\n\t\t\t\t\t\tMLXBF_I2C_COALESCE_RES);\n\t\tif (!coalesce_res)\n\t\t\treturn -EPERM;\n\n\t\t \n\t\tlockdep_assert_held(mlxbf_i2c_gpio_res->lock);\n\n\t\t \n\t\tif (coalesce_res->io) {\n\t\t\tpriv->coalesce = coalesce_res;\n\t\t\treturn 0;\n\t\t}\n\n\t\tparams = coalesce_res->params;\n\t\tsize = resource_size(params);\n\n\t\tif (!request_mem_region(params->start, size, params->name))\n\t\t\treturn -EFAULT;\n\n\t\tcoalesce_res->io = ioremap(params->start, size);\n\t\tif (!coalesce_res->io) {\n\t\t\trelease_mem_region(params->start, size);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tpriv->coalesce = coalesce_res;\n\n\t} else {\n\t\tret = mlxbf_i2c_init_resource(pdev, &priv->coalesce,\n\t\t\t\t\t      MLXBF_I2C_COALESCE_RES);\n\t}\n\n\treturn ret;\n}\n\nstatic int mlxbf_i2c_release_coalesce(struct platform_device *pdev,\n\t\t\t\t      struct mlxbf_i2c_priv *priv)\n{\n\tstruct mlxbf_i2c_resource *coalesce_res;\n\tstruct device *dev = &pdev->dev;\n\tstruct resource *params;\n\tresource_size_t size;\n\n\tcoalesce_res = priv->coalesce;\n\n\tif (coalesce_res->io) {\n\t\tparams = coalesce_res->params;\n\t\tsize = resource_size(params);\n\t\tif (mlxbf_i2c_has_chip_type(priv, MLXBF_I2C_CHIP_TYPE_1)) {\n\t\t\tmutex_lock(coalesce_res->lock);\n\t\t\tiounmap(coalesce_res->io);\n\t\t\trelease_mem_region(params->start, size);\n\t\t\tmutex_unlock(coalesce_res->lock);\n\t\t} else {\n\t\t\tdevm_release_mem_region(dev, params->start, size);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int mlxbf_i2c_init_slave(struct platform_device *pdev,\n\t\t\t\tstruct mlxbf_i2c_priv *priv)\n{\n\tstruct device *dev = &pdev->dev;\n\tu32 int_reg;\n\tint ret;\n\n\t \n\twritel(0, priv->slv->io + MLXBF_I2C_SMBUS_SLAVE_FSM);\n\n\t \n\twritel(~0, priv->slv_cause->io + MLXBF_I2C_CAUSE_OR_CLEAR);\n\tint_reg = MLXBF_I2C_CAUSE_READ_WAIT_FW_RESPONSE;\n\tint_reg |= MLXBF_I2C_CAUSE_WRITE_SUCCESS;\n\twritel(int_reg, priv->slv_cause->io + MLXBF_I2C_CAUSE_OR_EVTEN0);\n\n\t \n\twritel(0x1, priv->slv->io + MLXBF_I2C_SMBUS_SLAVE_READY);\n\n\t \n\tret = mlxbf_i2c_init_coalesce(pdev, priv);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to initialize cause coalesce\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic bool mlxbf_i2c_has_coalesce(struct mlxbf_i2c_priv *priv, bool *read,\n\t\t\t\t   bool *write)\n{\n\tconst struct mlxbf_i2c_chip_info *chip = priv->chip;\n\tu32 coalesce0_reg, cause_reg;\n\tu8 slave_shift, is_set;\n\n\t*write = false;\n\t*read = false;\n\n\tslave_shift = chip->type != MLXBF_I2C_CHIP_TYPE_1 ?\n\t\t\t\tMLXBF_I2C_CAUSE_YU_SLAVE_BIT :\n\t\t\t\tpriv->bus + MLXBF_I2C_CAUSE_TYU_SLAVE_BIT;\n\n\tcoalesce0_reg = readl(priv->coalesce->io + MLXBF_I2C_CAUSE_COALESCE_0);\n\tis_set = coalesce0_reg & (1 << slave_shift);\n\n\tif (!is_set)\n\t\treturn false;\n\n\t \n\tcause_reg = readl(priv->slv_cause->io + MLXBF_I2C_CAUSE_ARBITER);\n\tif (cause_reg & MLXBF_I2C_CAUSE_READ_WAIT_FW_RESPONSE)\n\t\t*read = true;\n\telse if (cause_reg & MLXBF_I2C_CAUSE_WRITE_SUCCESS)\n\t\t*write = true;\n\n\t \n\twritel(~0x0, priv->slv_cause->io + MLXBF_I2C_CAUSE_OR_CLEAR);\n\n\treturn true;\n}\n\nstatic bool mlxbf_i2c_slave_wait_for_idle(struct mlxbf_i2c_priv *priv,\n\t\t\t\t\t    u32 timeout)\n{\n\tu32 mask = MLXBF_I2C_CAUSE_S_GW_BUSY_FALL;\n\tu32 addr = MLXBF_I2C_CAUSE_ARBITER;\n\n\tif (mlxbf_i2c_poll(priv->slv_cause->io, addr, mask, false, timeout))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic struct i2c_client *mlxbf_i2c_get_slave_from_addr(\n\t\t\tstruct mlxbf_i2c_priv *priv, u8 addr)\n{\n\tint i;\n\n\tfor (i = 0; i < MLXBF_I2C_SMBUS_SLAVE_ADDR_CNT; i++) {\n\t\tif (!priv->slave[i])\n\t\t\tcontinue;\n\n\t\tif (priv->slave[i]->addr == addr)\n\t\t\treturn priv->slave[i];\n\t}\n\n\treturn NULL;\n}\n\n \nstatic int mlxbf_i2c_irq_send(struct mlxbf_i2c_priv *priv, u8 recv_bytes)\n{\n\tu8 data_desc[MLXBF_I2C_SLAVE_DATA_DESC_SIZE] = { 0 };\n\tu8 write_size, pec_en, addr, value, byte_cnt;\n\tstruct i2c_client *slave;\n\tu32 control32, data32;\n\tint ret = 0;\n\n\t \n\tdata32 = ioread32be(priv->slv->io +\n\t\t\t\tMLXBF_I2C_SLAVE_DATA_DESC_ADDR);\n\taddr = (data32 & GENMASK(7, 0)) >> 1;\n\n\t \n\tslave = mlxbf_i2c_get_slave_from_addr(priv, addr);\n\tif (!slave) {\n\t\tret = -ENXIO;\n\t\tgoto clear_csr;\n\t}\n\n\t \n\tif (recv_bytes > 1) {\n\t\ti2c_slave_event(slave, I2C_SLAVE_WRITE_REQUESTED, &value);\n\t\tvalue = (data32 >> 8) & GENMASK(7, 0);\n\t\tret = i2c_slave_event(slave, I2C_SLAVE_WRITE_RECEIVED,\n\t\t\t\t      &value);\n\t\ti2c_slave_event(slave, I2C_SLAVE_STOP, &value);\n\n\t\tif (ret < 0)\n\t\t\tgoto clear_csr;\n\t}\n\n\t \n\ti2c_slave_event(slave, I2C_SLAVE_READ_REQUESTED, &value);\n\n\tfor (byte_cnt = 0; byte_cnt < MLXBF_I2C_SLAVE_DATA_DESC_SIZE; byte_cnt++) {\n\t\tdata_desc[byte_cnt] = value;\n\t\ti2c_slave_event(slave, I2C_SLAVE_READ_PROCESSED, &value);\n\t}\n\n\t \n\ti2c_slave_event(slave, I2C_SLAVE_STOP, &value);\n\n\t \n\twrite_size = (byte_cnt - 1) & 0x7f;\n\n\t \n\tmlxbf_i2c_smbus_write_data(priv, data_desc, byte_cnt,\n\t\t\t\t   MLXBF_I2C_SLAVE_DATA_DESC_ADDR, false);\n\n\tpec_en = 0;  \n\n\t \n\tcontrol32 = MLXBF_I2C_SLAVE_ENABLE;\n\tcontrol32 |= rol32(write_size, MLXBF_I2C_SLAVE_WRITE_BYTES_SHIFT);\n\tcontrol32 |= rol32(pec_en, MLXBF_I2C_SLAVE_SEND_PEC_SHIFT);\n\n\twritel(control32, priv->slv->io + MLXBF_I2C_SMBUS_SLAVE_GW);\n\n\t \n\tmlxbf_i2c_slave_wait_for_idle(priv, MLXBF_I2C_SMBUS_TIMEOUT);\n\nclear_csr:\n\t \n\twritel(0x0, priv->slv->io + MLXBF_I2C_SMBUS_SLAVE_RS_MASTER_BYTES);\n\twritel(0x0, priv->slv->io + MLXBF_I2C_SMBUS_SLAVE_PEC);\n\twritel(0x1, priv->slv->io + MLXBF_I2C_SMBUS_SLAVE_READY);\n\n\treturn ret;\n}\n\n \nstatic int mlxbf_i2c_irq_recv(struct mlxbf_i2c_priv *priv, u8 recv_bytes)\n{\n\tu8 data_desc[MLXBF_I2C_SLAVE_DATA_DESC_SIZE] = { 0 };\n\tstruct i2c_client *slave;\n\tu8 value, byte, addr;\n\tint ret = 0;\n\n\t \n\tmlxbf_i2c_smbus_read_data(priv, data_desc, recv_bytes,\n\t\t\t\t  MLXBF_I2C_SLAVE_DATA_DESC_ADDR, false);\n\taddr = data_desc[0] >> 1;\n\n\t \n\tslave = mlxbf_i2c_get_slave_from_addr(priv, addr);\n\tif (!slave) {\n\t\tret = -EINVAL;\n\t\tgoto clear_csr;\n\t}\n\n\t \n\ti2c_slave_event(slave, I2C_SLAVE_WRITE_REQUESTED, &value);\n\n\t \n\tfor (byte = 1; byte < recv_bytes; byte++) {\n\t\tvalue = data_desc[byte];\n\t\tret = i2c_slave_event(slave, I2C_SLAVE_WRITE_RECEIVED,\n\t\t\t\t      &value);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\n\t \n\ti2c_slave_event(slave, I2C_SLAVE_STOP, &value);\n\nclear_csr:\n\t \n\twritel(0x0, priv->slv->io + MLXBF_I2C_SMBUS_SLAVE_RS_MASTER_BYTES);\n\twritel(0x0, priv->slv->io + MLXBF_I2C_SMBUS_SLAVE_PEC);\n\twritel(0x1, priv->slv->io + MLXBF_I2C_SMBUS_SLAVE_READY);\n\n\treturn ret;\n}\n\nstatic irqreturn_t mlxbf_i2c_irq(int irq, void *ptr)\n{\n\tstruct mlxbf_i2c_priv *priv = ptr;\n\tbool read, write, irq_is_set;\n\tu32 rw_bytes_reg;\n\tu8 recv_bytes;\n\n\t \n\tirq_is_set = mlxbf_i2c_has_coalesce(priv, &read, &write);\n\tif (!irq_is_set || (!read && !write)) {\n\t\t \n\t\treturn IRQ_NONE;\n\t}\n\n\t \n\trw_bytes_reg = readl(priv->slv->io +\n\t\t\t\tMLXBF_I2C_SMBUS_SLAVE_RS_MASTER_BYTES);\n\trecv_bytes = (rw_bytes_reg >> 8) & GENMASK(7, 0);\n\n\t \n\trecv_bytes = recv_bytes > MLXBF_I2C_SLAVE_DATA_DESC_SIZE ?\n\t\tMLXBF_I2C_SLAVE_DATA_DESC_SIZE : recv_bytes;\n\n\tif (read)\n\t\tmlxbf_i2c_irq_send(priv, recv_bytes);\n\telse\n\t\tmlxbf_i2c_irq_recv(priv, recv_bytes);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic s32 mlxbf_i2c_smbus_xfer(struct i2c_adapter *adap, u16 addr,\n\t\t\t\tunsigned short flags, char read_write,\n\t\t\t\tu8 command, int size,\n\t\t\t\tunion i2c_smbus_data *data)\n{\n\tstruct mlxbf_i2c_smbus_request request = { 0 };\n\tstruct mlxbf_i2c_priv *priv;\n\tbool read, pec;\n\tu8 byte_cnt;\n\n\trequest.slave = addr;\n\n\tread = (read_write == I2C_SMBUS_READ);\n\tpec = flags & I2C_FUNC_SMBUS_PEC;\n\n\tswitch (size) {\n\tcase I2C_SMBUS_QUICK:\n\t\tmlxbf_i2c_smbus_quick_command(&request, read);\n\t\tdev_dbg(&adap->dev, \"smbus quick, slave 0x%02x\\n\", addr);\n\t\tbreak;\n\n\tcase I2C_SMBUS_BYTE:\n\t\tmlxbf_i2c_smbus_byte_func(&request,\n\t\t\t\t\t  read ? &data->byte : &command, read,\n\t\t\t\t\t  pec);\n\t\tdev_dbg(&adap->dev, \"smbus %s byte, slave 0x%02x.\\n\",\n\t\t\tread ? \"read\" : \"write\", addr);\n\t\tbreak;\n\n\tcase I2C_SMBUS_BYTE_DATA:\n\t\tmlxbf_i2c_smbus_data_byte_func(&request, &command, &data->byte,\n\t\t\t\t\t       read, pec);\n\t\tdev_dbg(&adap->dev, \"smbus %s byte data at 0x%02x, slave 0x%02x.\\n\",\n\t\t\tread ? \"read\" : \"write\", command, addr);\n\t\tbreak;\n\n\tcase I2C_SMBUS_WORD_DATA:\n\t\tmlxbf_i2c_smbus_data_word_func(&request, &command,\n\t\t\t\t\t       (u8 *)&data->word, read, pec);\n\t\tdev_dbg(&adap->dev, \"smbus %s word data at 0x%02x, slave 0x%02x.\\n\",\n\t\t\tread ? \"read\" : \"write\", command, addr);\n\t\tbreak;\n\n\tcase I2C_SMBUS_I2C_BLOCK_DATA:\n\t\tbyte_cnt = data->block[0];\n\t\tmlxbf_i2c_smbus_i2c_block_func(&request, &command, data->block,\n\t\t\t\t\t       &byte_cnt, read, pec);\n\t\tdev_dbg(&adap->dev, \"i2c %s block data, %d bytes at 0x%02x, slave 0x%02x.\\n\",\n\t\t\tread ? \"read\" : \"write\", byte_cnt, command, addr);\n\t\tbreak;\n\n\tcase I2C_SMBUS_BLOCK_DATA:\n\t\tbyte_cnt = read ? I2C_SMBUS_BLOCK_MAX : data->block[0];\n\t\tmlxbf_i2c_smbus_block_func(&request, &command, data->block,\n\t\t\t\t\t   &byte_cnt, read, pec);\n\t\tdev_dbg(&adap->dev, \"smbus %s block data, %d bytes at 0x%02x, slave 0x%02x.\\n\",\n\t\t\tread ? \"read\" : \"write\", byte_cnt, command, addr);\n\t\tbreak;\n\n\tcase I2C_FUNC_SMBUS_PROC_CALL:\n\t\tmlxbf_i2c_smbus_process_call_func(&request, &command,\n\t\t\t\t\t\t  (u8 *)&data->word, pec);\n\t\tdev_dbg(&adap->dev, \"process call, wr/rd at 0x%02x, slave 0x%02x.\\n\",\n\t\t\tcommand, addr);\n\t\tbreak;\n\n\tcase I2C_FUNC_SMBUS_BLOCK_PROC_CALL:\n\t\tbyte_cnt = data->block[0];\n\t\tmlxbf_i2c_smbus_blk_process_call_func(&request, &command,\n\t\t\t\t\t\t      data->block, &byte_cnt,\n\t\t\t\t\t\t      pec);\n\t\tdev_dbg(&adap->dev, \"block process call, wr/rd %d bytes, slave 0x%02x.\\n\",\n\t\t\tbyte_cnt, addr);\n\t\tbreak;\n\n\tdefault:\n\t\tdev_dbg(&adap->dev, \"Unsupported I2C/SMBus command %d\\n\",\n\t\t\tsize);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tpriv = i2c_get_adapdata(adap);\n\n\treturn mlxbf_i2c_smbus_start_transaction(priv, &request);\n}\n\nstatic int mlxbf_i2c_reg_slave(struct i2c_client *slave)\n{\n\tstruct mlxbf_i2c_priv *priv = i2c_get_adapdata(slave->adapter);\n\tstruct device *dev = &slave->dev;\n\tint ret;\n\n\t \n\tif (slave->flags & (I2C_CLIENT_TEN | I2C_CLIENT_PEC)) {\n\t\tdev_err(dev, \"SMBus PEC and 10 bit address not supported\\n\");\n\t\treturn -EAFNOSUPPORT;\n\t}\n\n\tret = mlxbf_i2c_slave_enable(priv, slave);\n\tif (ret)\n\t\tdev_err(dev, \"Surpassed max number of registered slaves allowed\\n\");\n\n\treturn 0;\n}\n\nstatic int mlxbf_i2c_unreg_slave(struct i2c_client *slave)\n{\n\tstruct mlxbf_i2c_priv *priv = i2c_get_adapdata(slave->adapter);\n\tstruct device *dev = &slave->dev;\n\tint ret;\n\n\t \n\tret = mlxbf_i2c_slave_disable(priv, slave->addr);\n\tif (ret)\n\t\tdev_err(dev, \"Unable to find slave 0x%x\\n\", slave->addr);\n\n\treturn ret;\n}\n\nstatic u32 mlxbf_i2c_functionality(struct i2c_adapter *adap)\n{\n\treturn MLXBF_I2C_FUNC_ALL;\n}\n\nstatic struct mlxbf_i2c_chip_info mlxbf_i2c_chip[] = {\n\t[MLXBF_I2C_CHIP_TYPE_1] = {\n\t\t.type = MLXBF_I2C_CHIP_TYPE_1,\n\t\t.shared_res = {\n\t\t\t[0] = &mlxbf_i2c_coalesce_res[MLXBF_I2C_CHIP_TYPE_1],\n\t\t\t[1] = &mlxbf_i2c_corepll_res[MLXBF_I2C_CHIP_TYPE_1],\n\t\t\t[2] = &mlxbf_i2c_gpio_res[MLXBF_I2C_CHIP_TYPE_1]\n\t\t},\n\t\t.calculate_freq = mlxbf_i2c_calculate_freq_from_tyu,\n\t\t.smbus_master_rs_bytes_off = MLXBF_I2C_YU_SMBUS_RS_BYTES,\n\t\t.smbus_master_fsm_off = MLXBF_I2C_YU_SMBUS_MASTER_FSM\n\t},\n\t[MLXBF_I2C_CHIP_TYPE_2] = {\n\t\t.type = MLXBF_I2C_CHIP_TYPE_2,\n\t\t.shared_res = {\n\t\t\t[0] = &mlxbf_i2c_corepll_res[MLXBF_I2C_CHIP_TYPE_2]\n\t\t},\n\t\t.calculate_freq = mlxbf_i2c_calculate_freq_from_yu,\n\t\t.smbus_master_rs_bytes_off = MLXBF_I2C_YU_SMBUS_RS_BYTES,\n\t\t.smbus_master_fsm_off = MLXBF_I2C_YU_SMBUS_MASTER_FSM\n\t},\n\t[MLXBF_I2C_CHIP_TYPE_3] = {\n\t\t.type = MLXBF_I2C_CHIP_TYPE_3,\n\t\t.shared_res = {\n\t\t\t[0] = &mlxbf_i2c_corepll_res[MLXBF_I2C_CHIP_TYPE_3]\n\t\t},\n\t\t.calculate_freq = mlxbf_i2c_calculate_freq_from_yu,\n\t\t.smbus_master_rs_bytes_off = MLXBF_I2C_RSH_YU_SMBUS_RS_BYTES,\n\t\t.smbus_master_fsm_off = MLXBF_I2C_RSH_YU_SMBUS_MASTER_FSM\n\t}\n};\n\nstatic const struct i2c_algorithm mlxbf_i2c_algo = {\n\t.smbus_xfer = mlxbf_i2c_smbus_xfer,\n\t.functionality = mlxbf_i2c_functionality,\n\t.reg_slave = mlxbf_i2c_reg_slave,\n\t.unreg_slave = mlxbf_i2c_unreg_slave,\n};\n\nstatic struct i2c_adapter_quirks mlxbf_i2c_quirks = {\n\t.max_read_len = MLXBF_I2C_MASTER_DATA_R_LENGTH,\n\t.max_write_len = MLXBF_I2C_MASTER_DATA_W_LENGTH,\n};\n\nstatic const struct acpi_device_id mlxbf_i2c_acpi_ids[] = {\n\t{ \"MLNXBF03\", (kernel_ulong_t)&mlxbf_i2c_chip[MLXBF_I2C_CHIP_TYPE_1] },\n\t{ \"MLNXBF23\", (kernel_ulong_t)&mlxbf_i2c_chip[MLXBF_I2C_CHIP_TYPE_2] },\n\t{ \"MLNXBF31\", (kernel_ulong_t)&mlxbf_i2c_chip[MLXBF_I2C_CHIP_TYPE_3] },\n\t{},\n};\n\nMODULE_DEVICE_TABLE(acpi, mlxbf_i2c_acpi_ids);\n\nstatic int mlxbf_i2c_acpi_probe(struct device *dev, struct mlxbf_i2c_priv *priv)\n{\n\tconst struct acpi_device_id *aid;\n\tu64 bus_id;\n\tint ret;\n\n\tif (acpi_disabled)\n\t\treturn -ENOENT;\n\n\taid = acpi_match_device(mlxbf_i2c_acpi_ids, dev);\n\tif (!aid)\n\t\treturn -ENODEV;\n\n\tpriv->chip = (struct mlxbf_i2c_chip_info *)aid->driver_data;\n\n\tret = acpi_dev_uid_to_integer(ACPI_COMPANION(dev), &bus_id);\n\tif (ret) {\n\t\tdev_err(dev, \"Cannot retrieve UID\\n\");\n\t\treturn ret;\n\t}\n\n\tpriv->bus = bus_id;\n\n\treturn 0;\n}\n\nstatic int mlxbf_i2c_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct mlxbf_i2c_priv *priv;\n\tstruct i2c_adapter *adap;\n\tu32 resource_version;\n\tint irq, ret;\n\n\tpriv = devm_kzalloc(dev, sizeof(struct mlxbf_i2c_priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tret = mlxbf_i2c_acpi_probe(dev, priv);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tif (device_property_read_u32(dev, \"resource_version\", &resource_version))\n\t\tresource_version = 0;\n\n\tpriv->resource_version = resource_version;\n\n\tif (priv->chip->type < MLXBF_I2C_CHIP_TYPE_3 && resource_version == 0) {\n\t\tpriv->timer = devm_kzalloc(dev, sizeof(struct mlxbf_i2c_resource), GFP_KERNEL);\n\t\tif (!priv->timer)\n\t\t\treturn -ENOMEM;\n\n\t\tpriv->mst = devm_kzalloc(dev, sizeof(struct mlxbf_i2c_resource), GFP_KERNEL);\n\t\tif (!priv->mst)\n\t\t\treturn -ENOMEM;\n\n\t\tpriv->slv = devm_kzalloc(dev, sizeof(struct mlxbf_i2c_resource), GFP_KERNEL);\n\t\tif (!priv->slv)\n\t\t\treturn -ENOMEM;\n\n\t\tret = mlxbf_i2c_init_resource(pdev, &priv->smbus,\n\t\t\t\t\t      MLXBF_I2C_SMBUS_RES);\n\t\tif (ret < 0)\n\t\t\treturn dev_err_probe(dev, ret, \"Cannot fetch smbus resource info\");\n\n\t\tpriv->timer->io = priv->smbus->io;\n\t\tpriv->mst->io = priv->smbus->io + MLXBF_I2C_MST_ADDR_OFFSET;\n\t\tpriv->slv->io = priv->smbus->io + MLXBF_I2C_SLV_ADDR_OFFSET;\n\t} else {\n\t\tret = mlxbf_i2c_init_resource(pdev, &priv->timer,\n\t\t\t\t\t      MLXBF_I2C_SMBUS_TIMER_RES);\n\t\tif (ret < 0)\n\t\t\treturn dev_err_probe(dev, ret, \"Cannot fetch timer resource info\");\n\n\t\tret = mlxbf_i2c_init_resource(pdev, &priv->mst,\n\t\t\t\t\t      MLXBF_I2C_SMBUS_MST_RES);\n\t\tif (ret < 0)\n\t\t\treturn dev_err_probe(dev, ret, \"Cannot fetch master resource info\");\n\n\t\tret = mlxbf_i2c_init_resource(pdev, &priv->slv,\n\t\t\t\t\t      MLXBF_I2C_SMBUS_SLV_RES);\n\t\tif (ret < 0)\n\t\t\treturn dev_err_probe(dev, ret, \"Cannot fetch slave resource info\");\n\t}\n\n\tret = mlxbf_i2c_init_resource(pdev, &priv->mst_cause,\n\t\t\t\t      MLXBF_I2C_MST_CAUSE_RES);\n\tif (ret < 0)\n\t\treturn dev_err_probe(dev, ret, \"Cannot fetch cause master resource info\");\n\n\tret = mlxbf_i2c_init_resource(pdev, &priv->slv_cause,\n\t\t\t\t      MLXBF_I2C_SLV_CAUSE_RES);\n\tif (ret < 0)\n\t\treturn dev_err_probe(dev, ret, \"Cannot fetch cause slave resource info\");\n\n\tadap = &priv->adap;\n\tadap->owner = THIS_MODULE;\n\tadap->class = I2C_CLASS_HWMON;\n\tadap->algo = &mlxbf_i2c_algo;\n\tadap->quirks = &mlxbf_i2c_quirks;\n\tadap->dev.parent = dev;\n\tadap->dev.of_node = dev->of_node;\n\tadap->nr = priv->bus;\n\n\tsnprintf(adap->name, sizeof(adap->name), \"i2c%d\", adap->nr);\n\ti2c_set_adapdata(adap, priv);\n\n\t \n\tret = mlxbf_i2c_calculate_corepll_freq(pdev, priv);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"cannot get core clock frequency\\n\");\n\t\t \n\t\tpriv->frequency = MLXBF_I2C_COREPLL_FREQ;\n\t}\n\n\t \n\tret = mlxbf_i2c_init_master(pdev, priv);\n\tif (ret < 0)\n\t\treturn dev_err_probe(dev, ret, \"failed to initialize smbus master %d\",\n\t\t\t\t     priv->bus);\n\n\tmlxbf_i2c_init_timings(pdev, priv);\n\n\tmlxbf_i2c_init_slave(pdev, priv);\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\tret = devm_request_irq(dev, irq, mlxbf_i2c_irq,\n\t\t\t       IRQF_SHARED | IRQF_PROBE_SHARED,\n\t\t\t       dev_name(dev), priv);\n\tif (ret < 0)\n\t\treturn dev_err_probe(dev, ret, \"Cannot get irq %d\\n\", irq);\n\n\tpriv->irq = irq;\n\n\tplatform_set_drvdata(pdev, priv);\n\n\tret = i2c_add_numbered_adapter(adap);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmutex_lock(&mlxbf_i2c_bus_lock);\n\tmlxbf_i2c_bus_count++;\n\tmutex_unlock(&mlxbf_i2c_bus_lock);\n\n\treturn 0;\n}\n\nstatic void mlxbf_i2c_remove(struct platform_device *pdev)\n{\n\tstruct mlxbf_i2c_priv *priv = platform_get_drvdata(pdev);\n\tstruct device *dev = &pdev->dev;\n\tstruct resource *params;\n\n\tif (priv->chip->type < MLXBF_I2C_CHIP_TYPE_3 && priv->resource_version == 0) {\n\t\tparams = priv->smbus->params;\n\t\tdevm_release_mem_region(dev, params->start, resource_size(params));\n\t} else {\n\t\tparams = priv->timer->params;\n\t\tdevm_release_mem_region(dev, params->start, resource_size(params));\n\n\t\tparams = priv->mst->params;\n\t\tdevm_release_mem_region(dev, params->start, resource_size(params));\n\n\t\tparams = priv->slv->params;\n\t\tdevm_release_mem_region(dev, params->start, resource_size(params));\n\t}\n\n\tparams = priv->mst_cause->params;\n\tdevm_release_mem_region(dev, params->start, resource_size(params));\n\n\tparams = priv->slv_cause->params;\n\tdevm_release_mem_region(dev, params->start, resource_size(params));\n\n\t \n\tmutex_lock(&mlxbf_i2c_bus_lock);\n\tif (--mlxbf_i2c_bus_count == 0) {\n\t\tmlxbf_i2c_release_coalesce(pdev, priv);\n\t\tmlxbf_i2c_release_corepll(pdev, priv);\n\t\tmlxbf_i2c_release_gpio(pdev, priv);\n\t}\n\tmutex_unlock(&mlxbf_i2c_bus_lock);\n\n\tdevm_free_irq(dev, priv->irq, priv);\n\n\ti2c_del_adapter(&priv->adap);\n}\n\nstatic struct platform_driver mlxbf_i2c_driver = {\n\t.probe = mlxbf_i2c_probe,\n\t.remove_new = mlxbf_i2c_remove,\n\t.driver = {\n\t\t.name = \"i2c-mlxbf\",\n\t\t.acpi_match_table = ACPI_PTR(mlxbf_i2c_acpi_ids),\n\t},\n};\n\nstatic int __init mlxbf_i2c_init(void)\n{\n\tmutex_init(&mlxbf_i2c_coalesce_lock);\n\tmutex_init(&mlxbf_i2c_corepll_lock);\n\tmutex_init(&mlxbf_i2c_gpio_lock);\n\n\tmutex_init(&mlxbf_i2c_bus_lock);\n\n\treturn platform_driver_register(&mlxbf_i2c_driver);\n}\nmodule_init(mlxbf_i2c_init);\n\nstatic void __exit mlxbf_i2c_exit(void)\n{\n\tplatform_driver_unregister(&mlxbf_i2c_driver);\n\n\tmutex_destroy(&mlxbf_i2c_bus_lock);\n\n\tmutex_destroy(&mlxbf_i2c_gpio_lock);\n\tmutex_destroy(&mlxbf_i2c_corepll_lock);\n\tmutex_destroy(&mlxbf_i2c_coalesce_lock);\n}\nmodule_exit(mlxbf_i2c_exit);\n\nMODULE_DESCRIPTION(\"Mellanox BlueField I2C bus driver\");\nMODULE_AUTHOR(\"Khalil Blaiech <kblaiech@nvidia.com>\");\nMODULE_AUTHOR(\"Asmaa Mnebhi <asmaa@nvidia.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}