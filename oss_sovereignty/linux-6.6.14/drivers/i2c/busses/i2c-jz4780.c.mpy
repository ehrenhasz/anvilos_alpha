{
  "module_name": "i2c-jz4780.c",
  "hash_id": "41508e607b0236e8e3b8323bd7c5e99cad67c240549337952bf370a8c09a81ff",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-jz4780.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/clk.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/errno.h>\n#include <linux/i2c.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n\n#define JZ4780_I2C_CTRL\t\t0x00\n#define JZ4780_I2C_TAR\t\t0x04\n#define JZ4780_I2C_SAR\t\t0x08\n#define JZ4780_I2C_DC\t\t0x10\n#define JZ4780_I2C_SHCNT\t0x14\n#define JZ4780_I2C_SLCNT\t0x18\n#define JZ4780_I2C_FHCNT\t0x1C\n#define JZ4780_I2C_FLCNT\t0x20\n#define JZ4780_I2C_INTST\t0x2C\n#define JZ4780_I2C_INTM\t\t0x30\n#define JZ4780_I2C_RXTL\t\t0x38\n#define JZ4780_I2C_TXTL\t\t0x3C\n#define JZ4780_I2C_CINTR\t0x40\n#define JZ4780_I2C_CRXUF\t0x44\n#define JZ4780_I2C_CRXOF\t0x48\n#define JZ4780_I2C_CTXOF\t0x4C\n#define JZ4780_I2C_CRXREQ\t0x50\n#define JZ4780_I2C_CTXABRT\t0x54\n#define JZ4780_I2C_CRXDONE\t0x58\n#define JZ4780_I2C_CACT\t\t0x5C\n#define JZ4780_I2C_CSTP\t\t0x60\n#define JZ4780_I2C_CSTT\t\t0x64\n#define JZ4780_I2C_CGC\t\t0x68\n#define JZ4780_I2C_ENB\t\t0x6C\n#define JZ4780_I2C_STA\t\t0x70\n#define JZ4780_I2C_TXABRT\t0x80\n#define JZ4780_I2C_DMACR\t0x88\n#define JZ4780_I2C_DMATDLR\t0x8C\n#define JZ4780_I2C_DMARDLR\t0x90\n#define JZ4780_I2C_SDASU\t0x94\n#define JZ4780_I2C_ACKGC\t0x98\n#define JZ4780_I2C_ENSTA\t0x9C\n#define JZ4780_I2C_SDAHD\t0xD0\n#define X1000_I2C_SDAHD\t\t0x7C\n\n#define JZ4780_I2C_CTRL_STPHLD\t\tBIT(7)\n#define JZ4780_I2C_CTRL_SLVDIS\t\tBIT(6)\n#define JZ4780_I2C_CTRL_REST\t\tBIT(5)\n#define JZ4780_I2C_CTRL_MATP\t\tBIT(4)\n#define JZ4780_I2C_CTRL_SATP\t\tBIT(3)\n#define JZ4780_I2C_CTRL_SPDF\t\tBIT(2)\n#define JZ4780_I2C_CTRL_SPDS\t\tBIT(1)\n#define JZ4780_I2C_CTRL_MD\t\tBIT(0)\n\n#define JZ4780_I2C_STA_SLVACT\t\tBIT(6)\n#define JZ4780_I2C_STA_MSTACT\t\tBIT(5)\n#define JZ4780_I2C_STA_RFF\t\tBIT(4)\n#define JZ4780_I2C_STA_RFNE\t\tBIT(3)\n#define JZ4780_I2C_STA_TFE\t\tBIT(2)\n#define JZ4780_I2C_STA_TFNF\t\tBIT(1)\n#define JZ4780_I2C_STA_ACT\t\tBIT(0)\n\n#define X1000_I2C_DC_STOP\t\tBIT(9)\n\n#define JZ4780_I2C_INTST_IGC\t\tBIT(11)\n#define JZ4780_I2C_INTST_ISTT\t\tBIT(10)\n#define JZ4780_I2C_INTST_ISTP\t\tBIT(9)\n#define JZ4780_I2C_INTST_IACT\t\tBIT(8)\n#define JZ4780_I2C_INTST_RXDN\t\tBIT(7)\n#define JZ4780_I2C_INTST_TXABT\t\tBIT(6)\n#define JZ4780_I2C_INTST_RDREQ\t\tBIT(5)\n#define JZ4780_I2C_INTST_TXEMP\t\tBIT(4)\n#define JZ4780_I2C_INTST_TXOF\t\tBIT(3)\n#define JZ4780_I2C_INTST_RXFL\t\tBIT(2)\n#define JZ4780_I2C_INTST_RXOF\t\tBIT(1)\n#define JZ4780_I2C_INTST_RXUF\t\tBIT(0)\n\n#define JZ4780_I2C_INTM_MIGC\t\tBIT(11)\n#define JZ4780_I2C_INTM_MISTT\t\tBIT(10)\n#define JZ4780_I2C_INTM_MISTP\t\tBIT(9)\n#define JZ4780_I2C_INTM_MIACT\t\tBIT(8)\n#define JZ4780_I2C_INTM_MRXDN\t\tBIT(7)\n#define JZ4780_I2C_INTM_MTXABT\t\tBIT(6)\n#define JZ4780_I2C_INTM_MRDREQ\t\tBIT(5)\n#define JZ4780_I2C_INTM_MTXEMP\t\tBIT(4)\n#define JZ4780_I2C_INTM_MTXOF\t\tBIT(3)\n#define JZ4780_I2C_INTM_MRXFL\t\tBIT(2)\n#define JZ4780_I2C_INTM_MRXOF\t\tBIT(1)\n#define JZ4780_I2C_INTM_MRXUF\t\tBIT(0)\n\n#define JZ4780_I2C_DC_READ\t\tBIT(8)\n\n#define JZ4780_I2C_SDAHD_HDENB\t\tBIT(8)\n\n#define JZ4780_I2C_ENB_I2C\t\tBIT(0)\n\n#define JZ4780_I2CSHCNT_ADJUST(n)\t(((n) - 8) < 6 ? 6 : ((n) - 8))\n#define JZ4780_I2CSLCNT_ADJUST(n)\t(((n) - 1) < 8 ? 8 : ((n) - 1))\n#define JZ4780_I2CFHCNT_ADJUST(n)\t(((n) - 8) < 6 ? 6 : ((n) - 8))\n#define JZ4780_I2CFLCNT_ADJUST(n)\t(((n) - 1) < 8 ? 8 : ((n) - 1))\n\n#define JZ4780_I2C_FIFO_LEN\t16\n\n#define X1000_I2C_FIFO_LEN\t64\n\n#define JZ4780_I2C_TIMEOUT\t300\n\n#define BUFSIZE 200\n\nenum ingenic_i2c_version {\n\tID_JZ4780,\n\tID_X1000,\n};\n\n \nstruct ingenic_i2c_config {\n\tenum ingenic_i2c_version version;\n\n\tint fifosize;\n\tint tx_level;\n\tint rx_level;\n};\n\nstruct jz4780_i2c {\n\tvoid __iomem\t\t*iomem;\n\tint\t\t\t irq;\n\tstruct clk\t\t*clk;\n\tstruct i2c_adapter\t adap;\n\tconst struct ingenic_i2c_config *cdata;\n\n\t \n\tspinlock_t\t\tlock;\n\n\t \n\tunsigned char\t\t*rbuf;\n\tint\t\t\trd_total_len;\n\tint\t\t\trd_data_xfered;\n\tint\t\t\trd_cmd_xfered;\n\n\tunsigned char\t\t*wbuf;\n\tint\t\t\twt_len;\n\n\tint\t\t\tis_write;\n\tint\t\t\tstop_hold;\n\tint\t\t\tspeed;\n\n\tint\t\t\tdata_buf[BUFSIZE];\n\tint\t\t\tcmd_buf[BUFSIZE];\n\tint\t\t\tcmd;\n\n\t \n\tstruct completion\ttrans_waitq;\n};\n\nstatic inline unsigned short jz4780_i2c_readw(struct jz4780_i2c *i2c,\n\t\t\t\t\t      unsigned long offset)\n{\n\treturn readw(i2c->iomem + offset);\n}\n\nstatic inline void jz4780_i2c_writew(struct jz4780_i2c *i2c,\n\t\t\t\t     unsigned long offset, unsigned short val)\n{\n\twritew(val, i2c->iomem + offset);\n}\n\nstatic int jz4780_i2c_disable(struct jz4780_i2c *i2c)\n{\n\tunsigned short regval;\n\tunsigned long loops = 5;\n\n\tjz4780_i2c_writew(i2c, JZ4780_I2C_ENB, 0);\n\n\tdo {\n\t\tregval = jz4780_i2c_readw(i2c, JZ4780_I2C_ENSTA);\n\t\tif (!(regval & JZ4780_I2C_ENB_I2C))\n\t\t\treturn 0;\n\n\t\tusleep_range(5000, 15000);\n\t} while (--loops);\n\n\tdev_err(&i2c->adap.dev, \"disable failed: ENSTA=0x%04x\\n\", regval);\n\treturn -ETIMEDOUT;\n}\n\nstatic int jz4780_i2c_enable(struct jz4780_i2c *i2c)\n{\n\tunsigned short regval;\n\tunsigned long loops = 5;\n\n\tjz4780_i2c_writew(i2c, JZ4780_I2C_ENB, 1);\n\n\tdo {\n\t\tregval = jz4780_i2c_readw(i2c, JZ4780_I2C_ENSTA);\n\t\tif (regval & JZ4780_I2C_ENB_I2C)\n\t\t\treturn 0;\n\n\t\tusleep_range(5000, 15000);\n\t} while (--loops);\n\n\tdev_err(&i2c->adap.dev, \"enable failed: ENSTA=0x%04x\\n\", regval);\n\treturn -ETIMEDOUT;\n}\n\nstatic int jz4780_i2c_set_target(struct jz4780_i2c *i2c, unsigned char address)\n{\n\tunsigned short regval;\n\tunsigned long loops = 5;\n\n\tdo {\n\t\tregval = jz4780_i2c_readw(i2c, JZ4780_I2C_STA);\n\t\tif ((regval & JZ4780_I2C_STA_TFE) &&\n\t\t    !(regval & JZ4780_I2C_STA_MSTACT))\n\t\t\tbreak;\n\n\t\tusleep_range(5000, 15000);\n\t} while (--loops);\n\n\tif (loops) {\n\t\tjz4780_i2c_writew(i2c, JZ4780_I2C_TAR, address);\n\t\treturn 0;\n\t}\n\n\tdev_err(&i2c->adap.dev,\n\t\t\"set device to address 0x%02x failed, STA=0x%04x\\n\",\n\t\taddress, regval);\n\n\treturn -ENXIO;\n}\n\nstatic int jz4780_i2c_set_speed(struct jz4780_i2c *i2c)\n{\n\tint dev_clk_khz = clk_get_rate(i2c->clk) / 1000;\n\tint cnt_high = 0;\t \n\tint cnt_low = 0;\t \n\tint cnt_period = 0;\t \n\tint setup_time = 0;\n\tint hold_time = 0;\n\tunsigned short tmp = 0;\n\tint i2c_clk = i2c->speed;\n\n\tif (jz4780_i2c_disable(i2c))\n\t\tdev_dbg(&i2c->adap.dev, \"i2c not disabled\\n\");\n\n\t \n\tcnt_period = dev_clk_khz / i2c_clk;\n\n\tif (i2c_clk <= 100)\n\t\tcnt_high = (cnt_period * 4000) / (4700 + 4000);\n\telse\n\t\tcnt_high = (cnt_period * 600) / (1300 + 600);\n\n\tcnt_low = cnt_period - cnt_high;\n\n\t \n\tif (i2c_clk <= 100) {\n\t\ttmp = JZ4780_I2C_CTRL_SPDS | JZ4780_I2C_CTRL_REST\n\t\t      | JZ4780_I2C_CTRL_SLVDIS | JZ4780_I2C_CTRL_MD;\n\t\tjz4780_i2c_writew(i2c, JZ4780_I2C_CTRL, tmp);\n\n\t\tjz4780_i2c_writew(i2c, JZ4780_I2C_SHCNT,\n\t\t\t\t  JZ4780_I2CSHCNT_ADJUST(cnt_high));\n\t\tjz4780_i2c_writew(i2c, JZ4780_I2C_SLCNT,\n\t\t\t\t  JZ4780_I2CSLCNT_ADJUST(cnt_low));\n\t} else {\n\t\ttmp = JZ4780_I2C_CTRL_SPDF | JZ4780_I2C_CTRL_REST\n\t\t      | JZ4780_I2C_CTRL_SLVDIS | JZ4780_I2C_CTRL_MD;\n\t\tjz4780_i2c_writew(i2c, JZ4780_I2C_CTRL, tmp);\n\n\t\tjz4780_i2c_writew(i2c, JZ4780_I2C_FHCNT,\n\t\t\t\t  JZ4780_I2CFHCNT_ADJUST(cnt_high));\n\t\tjz4780_i2c_writew(i2c, JZ4780_I2C_FLCNT,\n\t\t\t\t  JZ4780_I2CFLCNT_ADJUST(cnt_low));\n\t}\n\n\t \n\tif (i2c_clk <= 100) {  \n\t\tsetup_time = 300;\n\t\thold_time = 400;\n\t} else {\n\t\tsetup_time = 450;\n\t\thold_time = 450;\n\t}\n\n\thold_time = ((hold_time * dev_clk_khz) / 1000000) - 1;\n\tsetup_time = ((setup_time * dev_clk_khz) / 1000000)  + 1;\n\n\tif (setup_time > 255)\n\t\tsetup_time = 255;\n\n\tif (setup_time <= 0)\n\t\tsetup_time = 1;\n\n\tjz4780_i2c_writew(i2c, JZ4780_I2C_SDASU, setup_time);\n\n\tif (hold_time > 255)\n\t\thold_time = 255;\n\n\tif (hold_time >= 0) {\n\t\t \n\t\tif (i2c->cdata->version >= ID_X1000) {\n\t\t\tjz4780_i2c_writew(i2c, X1000_I2C_SDAHD, hold_time);\n\t\t} else {\n\t\t\thold_time |= JZ4780_I2C_SDAHD_HDENB;\n\t\t\tjz4780_i2c_writew(i2c, JZ4780_I2C_SDAHD, hold_time);\n\t\t}\n\t} else {\n\t\t \n\t\tif (i2c->cdata->version >= ID_X1000)\n\t\t\tjz4780_i2c_writew(i2c, X1000_I2C_SDAHD, 0);\n\t\telse\n\t\t\tjz4780_i2c_writew(i2c, JZ4780_I2C_SDAHD, 0);\n\t}\n\n\treturn 0;\n}\n\nstatic int jz4780_i2c_cleanup(struct jz4780_i2c *i2c)\n{\n\tint ret;\n\tunsigned long flags;\n\tunsigned short tmp;\n\n\tspin_lock_irqsave(&i2c->lock, flags);\n\n\t \n\tif (i2c->cdata->version < ID_X1000) {\n\t\ttmp = jz4780_i2c_readw(i2c, JZ4780_I2C_CTRL);\n\t\ttmp &= ~JZ4780_I2C_CTRL_STPHLD;\n\t\tjz4780_i2c_writew(i2c, JZ4780_I2C_CTRL, tmp);\n\t}\n\n\t \n\tjz4780_i2c_writew(i2c, JZ4780_I2C_INTM, 0);\n\n\t \n\tjz4780_i2c_readw(i2c, JZ4780_I2C_CTXABRT);\n\tjz4780_i2c_readw(i2c, JZ4780_I2C_CINTR);\n\n\t \n\ttmp = jz4780_i2c_readw(i2c, JZ4780_I2C_CTRL);\n\ttmp &= ~JZ4780_I2C_ENB_I2C;\n\tjz4780_i2c_writew(i2c, JZ4780_I2C_CTRL, tmp);\n\tudelay(10);\n\ttmp |= JZ4780_I2C_ENB_I2C;\n\tjz4780_i2c_writew(i2c, JZ4780_I2C_CTRL, tmp);\n\n\tspin_unlock_irqrestore(&i2c->lock, flags);\n\n\tret = jz4780_i2c_disable(i2c);\n\tif (ret)\n\t\tdev_err(&i2c->adap.dev,\n\t\t\t\"unable to disable device during cleanup!\\n\");\n\n\tif (unlikely(jz4780_i2c_readw(i2c, JZ4780_I2C_INTM)\n\t\t     & jz4780_i2c_readw(i2c, JZ4780_I2C_INTST)))\n\t\tdev_err(&i2c->adap.dev,\n\t\t\t\"device has interrupts after a complete cleanup!\\n\");\n\n\treturn ret;\n}\n\nstatic int jz4780_i2c_prepare(struct jz4780_i2c *i2c)\n{\n\tjz4780_i2c_set_speed(i2c);\n\treturn jz4780_i2c_enable(i2c);\n}\n\nstatic void jz4780_i2c_send_rcmd(struct jz4780_i2c *i2c,\n\t\t\t\t\t\t\t\t int cmd_count,\n\t\t\t\t\t\t\t\t int cmd_left)\n{\n\tint i;\n\n\tfor (i = 0; i < cmd_count - 1; i++)\n\t\tjz4780_i2c_writew(i2c, JZ4780_I2C_DC, JZ4780_I2C_DC_READ);\n\n\tif ((cmd_left == 0) && (i2c->cdata->version >= ID_X1000))\n\t\tjz4780_i2c_writew(i2c, JZ4780_I2C_DC,\n\t\t\t\tJZ4780_I2C_DC_READ | X1000_I2C_DC_STOP);\n\telse\n\t\tjz4780_i2c_writew(i2c, JZ4780_I2C_DC, JZ4780_I2C_DC_READ);\n}\n\nstatic void jz4780_i2c_trans_done(struct jz4780_i2c *i2c)\n{\n\tjz4780_i2c_writew(i2c, JZ4780_I2C_INTM, 0);\n\tcomplete(&i2c->trans_waitq);\n}\n\nstatic irqreturn_t jz4780_i2c_irq(int irqno, void *dev_id)\n{\n\tunsigned short tmp;\n\tunsigned short intst;\n\tunsigned short intmsk;\n\tstruct jz4780_i2c *i2c = dev_id;\n\n\tspin_lock(&i2c->lock);\n\tintmsk = jz4780_i2c_readw(i2c, JZ4780_I2C_INTM);\n\tintst = jz4780_i2c_readw(i2c, JZ4780_I2C_INTST);\n\n\tintst &= intmsk;\n\n\tif (intst & JZ4780_I2C_INTST_TXABT) {\n\t\tjz4780_i2c_trans_done(i2c);\n\t\tgoto done;\n\t}\n\n\tif (intst & JZ4780_I2C_INTST_RXOF) {\n\t\tdev_dbg(&i2c->adap.dev, \"received fifo overflow!\\n\");\n\t\tjz4780_i2c_trans_done(i2c);\n\t\tgoto done;\n\t}\n\n\t \n\tif (i2c->is_write == 0) {\n\t\tint rd_left;\n\n\t\twhile ((jz4780_i2c_readw(i2c, JZ4780_I2C_STA)\n\t\t\t\t  & JZ4780_I2C_STA_RFNE)) {\n\t\t\t*(i2c->rbuf++) = jz4780_i2c_readw(i2c, JZ4780_I2C_DC)\n\t\t\t\t\t & 0xff;\n\t\t\ti2c->rd_data_xfered++;\n\t\t\tif (i2c->rd_data_xfered == i2c->rd_total_len) {\n\t\t\t\tjz4780_i2c_trans_done(i2c);\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\n\t\trd_left = i2c->rd_total_len - i2c->rd_data_xfered;\n\n\t\tif (rd_left <= i2c->cdata->fifosize)\n\t\t\tjz4780_i2c_writew(i2c, JZ4780_I2C_RXTL, rd_left - 1);\n\t}\n\n\tif (intst & JZ4780_I2C_INTST_TXEMP) {\n\t\tif (i2c->is_write == 0) {\n\t\t\tint cmd_left = i2c->rd_total_len - i2c->rd_cmd_xfered;\n\t\t\tint max_send = (i2c->cdata->fifosize - 1)\n\t\t\t\t\t - (i2c->rd_cmd_xfered\n\t\t\t\t\t - i2c->rd_data_xfered);\n\t\t\tint cmd_to_send = min(cmd_left, max_send);\n\n\t\t\tif (i2c->rd_cmd_xfered != 0)\n\t\t\t\tcmd_to_send = min(cmd_to_send,\n\t\t\t\t\t\t  i2c->cdata->fifosize\n\t\t\t\t\t\t  - i2c->cdata->tx_level - 1);\n\n\t\t\tif (cmd_to_send) {\n\t\t\t\ti2c->rd_cmd_xfered += cmd_to_send;\n\t\t\t\tcmd_left = i2c->rd_total_len -\n\t\t\t\t\t\ti2c->rd_cmd_xfered;\n\t\t\t\tjz4780_i2c_send_rcmd(i2c,\n\t\t\t\t\t\tcmd_to_send, cmd_left);\n\n\t\t\t}\n\n\t\t\tif (cmd_left == 0) {\n\t\t\t\tintmsk = jz4780_i2c_readw(i2c, JZ4780_I2C_INTM);\n\t\t\t\tintmsk &= ~JZ4780_I2C_INTM_MTXEMP;\n\t\t\t\tjz4780_i2c_writew(i2c, JZ4780_I2C_INTM, intmsk);\n\n\t\t\t\tif (i2c->cdata->version < ID_X1000) {\n\t\t\t\t\ttmp = jz4780_i2c_readw(i2c,\n\t\t\t\t\t\t\tJZ4780_I2C_CTRL);\n\t\t\t\t\ttmp &= ~JZ4780_I2C_CTRL_STPHLD;\n\t\t\t\t\tjz4780_i2c_writew(i2c,\n\t\t\t\t\t\t\tJZ4780_I2C_CTRL, tmp);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tunsigned short data;\n\t\t\tunsigned short i2c_sta;\n\n\t\t\ti2c_sta = jz4780_i2c_readw(i2c, JZ4780_I2C_STA);\n\n\t\t\twhile ((i2c_sta & JZ4780_I2C_STA_TFNF) &&\n\t\t\t\t\t(i2c->wt_len > 0)) {\n\t\t\t\ti2c_sta = jz4780_i2c_readw(i2c, JZ4780_I2C_STA);\n\t\t\t\tdata = *i2c->wbuf;\n\t\t\t\tdata &= ~JZ4780_I2C_DC_READ;\n\t\t\t\tif ((i2c->wt_len == 1) && (!i2c->stop_hold) &&\n\t\t\t\t\t\t(i2c->cdata->version >= ID_X1000))\n\t\t\t\t\tdata |= X1000_I2C_DC_STOP;\n\t\t\t\tjz4780_i2c_writew(i2c, JZ4780_I2C_DC, data);\n\t\t\t\ti2c->wbuf++;\n\t\t\t\ti2c->wt_len--;\n\t\t\t}\n\n\t\t\tif (i2c->wt_len == 0) {\n\t\t\t\tif ((!i2c->stop_hold) && (i2c->cdata->version <\n\t\t\t\t\t\tID_X1000)) {\n\t\t\t\t\ttmp = jz4780_i2c_readw(i2c,\n\t\t\t\t\t\t\tJZ4780_I2C_CTRL);\n\t\t\t\t\ttmp &= ~JZ4780_I2C_CTRL_STPHLD;\n\t\t\t\t\tjz4780_i2c_writew(i2c,\n\t\t\t\t\t\t\tJZ4780_I2C_CTRL, tmp);\n\t\t\t\t}\n\n\t\t\t\tjz4780_i2c_trans_done(i2c);\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t}\n\ndone:\n\tspin_unlock(&i2c->lock);\n\treturn IRQ_HANDLED;\n}\n\nstatic void jz4780_i2c_txabrt(struct jz4780_i2c *i2c, int src)\n{\n\tdev_dbg(&i2c->adap.dev, \"txabrt: 0x%08x, cmd: %d, send: %d, recv: %d\\n\",\n\t\tsrc, i2c->cmd, i2c->cmd_buf[i2c->cmd], i2c->data_buf[i2c->cmd]);\n}\n\nstatic inline int jz4780_i2c_xfer_read(struct jz4780_i2c *i2c,\n\t\t\t\t       unsigned char *buf, int len, int cnt,\n\t\t\t\t       int idx)\n{\n\tint ret = 0;\n\tlong timeout;\n\tint wait_time = JZ4780_I2C_TIMEOUT * (len + 5);\n\tunsigned short tmp;\n\tunsigned long flags;\n\n\tmemset(buf, 0, len);\n\n\tspin_lock_irqsave(&i2c->lock, flags);\n\n\ti2c->stop_hold = 0;\n\ti2c->is_write = 0;\n\ti2c->rbuf = buf;\n\ti2c->rd_total_len = len;\n\ti2c->rd_data_xfered = 0;\n\ti2c->rd_cmd_xfered = 0;\n\n\tif (len <= i2c->cdata->fifosize)\n\t\tjz4780_i2c_writew(i2c, JZ4780_I2C_RXTL, len - 1);\n\telse\n\t\tjz4780_i2c_writew(i2c, JZ4780_I2C_RXTL, i2c->cdata->rx_level);\n\n\tjz4780_i2c_writew(i2c, JZ4780_I2C_TXTL, i2c->cdata->tx_level);\n\n\tjz4780_i2c_writew(i2c, JZ4780_I2C_INTM,\n\t\t\t  JZ4780_I2C_INTM_MRXFL | JZ4780_I2C_INTM_MTXEMP\n\t\t\t  | JZ4780_I2C_INTM_MTXABT | JZ4780_I2C_INTM_MRXOF);\n\n\tif (i2c->cdata->version < ID_X1000) {\n\t\ttmp = jz4780_i2c_readw(i2c, JZ4780_I2C_CTRL);\n\t\ttmp |= JZ4780_I2C_CTRL_STPHLD;\n\t\tjz4780_i2c_writew(i2c, JZ4780_I2C_CTRL, tmp);\n\t}\n\n\tspin_unlock_irqrestore(&i2c->lock, flags);\n\n\ttimeout = wait_for_completion_timeout(&i2c->trans_waitq,\n\t\t\t\t\t      msecs_to_jiffies(wait_time));\n\n\tif (!timeout) {\n\t\tdev_err(&i2c->adap.dev, \"irq read timeout\\n\");\n\t\tdev_dbg(&i2c->adap.dev, \"send cmd count:%d  %d\\n\",\n\t\t\ti2c->cmd, i2c->cmd_buf[i2c->cmd]);\n\t\tdev_dbg(&i2c->adap.dev, \"receive data count:%d  %d\\n\",\n\t\t\ti2c->cmd, i2c->data_buf[i2c->cmd]);\n\t\tret = -EIO;\n\t}\n\n\ttmp = jz4780_i2c_readw(i2c, JZ4780_I2C_TXABRT);\n\tif (tmp) {\n\t\tjz4780_i2c_txabrt(i2c, tmp);\n\t\tret = -EIO;\n\t}\n\n\treturn ret;\n}\n\nstatic inline int jz4780_i2c_xfer_write(struct jz4780_i2c *i2c,\n\t\t\t\t\tunsigned char *buf, int len,\n\t\t\t\t\tint cnt, int idx)\n{\n\tint ret = 0;\n\tint wait_time = JZ4780_I2C_TIMEOUT * (len + 5);\n\tlong timeout;\n\tunsigned short tmp;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&i2c->lock, flags);\n\n\tif (idx < (cnt - 1))\n\t\ti2c->stop_hold = 1;\n\telse\n\t\ti2c->stop_hold = 0;\n\n\ti2c->is_write = 1;\n\ti2c->wbuf = buf;\n\ti2c->wt_len = len;\n\n\tjz4780_i2c_writew(i2c, JZ4780_I2C_TXTL, i2c->cdata->tx_level);\n\n\tjz4780_i2c_writew(i2c, JZ4780_I2C_INTM, JZ4780_I2C_INTM_MTXEMP\n\t\t\t\t\t| JZ4780_I2C_INTM_MTXABT);\n\n\tif (i2c->cdata->version < ID_X1000) {\n\t\ttmp = jz4780_i2c_readw(i2c, JZ4780_I2C_CTRL);\n\t\ttmp |= JZ4780_I2C_CTRL_STPHLD;\n\t\tjz4780_i2c_writew(i2c, JZ4780_I2C_CTRL, tmp);\n\t}\n\n\tspin_unlock_irqrestore(&i2c->lock, flags);\n\n\ttimeout = wait_for_completion_timeout(&i2c->trans_waitq,\n\t\t\t\t\t      msecs_to_jiffies(wait_time));\n\tif (timeout && !i2c->stop_hold) {\n\t\tunsigned short i2c_sta;\n\t\tint write_in_process;\n\n\t\ttimeout = JZ4780_I2C_TIMEOUT * 100;\n\t\tfor (; timeout > 0; timeout--) {\n\t\t\ti2c_sta = jz4780_i2c_readw(i2c, JZ4780_I2C_STA);\n\n\t\t\twrite_in_process = (i2c_sta & JZ4780_I2C_STA_MSTACT) ||\n\t\t\t\t!(i2c_sta & JZ4780_I2C_STA_TFE);\n\t\t\tif (!write_in_process)\n\t\t\t\tbreak;\n\t\t\tudelay(10);\n\t\t}\n\t}\n\n\tif (!timeout) {\n\t\tdev_err(&i2c->adap.dev, \"write wait timeout\\n\");\n\t\tret = -EIO;\n\t}\n\n\ttmp = jz4780_i2c_readw(i2c, JZ4780_I2C_TXABRT);\n\tif (tmp) {\n\t\tjz4780_i2c_txabrt(i2c, tmp);\n\t\tret = -EIO;\n\t}\n\n\treturn ret;\n}\n\nstatic int jz4780_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg *msg,\n\t\t\t   int count)\n{\n\tint i = -EIO;\n\tint ret = 0;\n\tstruct jz4780_i2c *i2c = adap->algo_data;\n\n\tret = jz4780_i2c_prepare(i2c);\n\tif (ret) {\n\t\tdev_err(&i2c->adap.dev, \"I2C prepare failed\\n\");\n\t\tgoto out;\n\t}\n\n\tif (msg->addr != jz4780_i2c_readw(i2c, JZ4780_I2C_TAR)) {\n\t\tret = jz4780_i2c_set_target(i2c, msg->addr);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\tfor (i = 0; i < count; i++, msg++) {\n\t\tif (msg->flags & I2C_M_RD)\n\t\t\tret = jz4780_i2c_xfer_read(i2c, msg->buf, msg->len,\n\t\t\t\t\t\t   count, i);\n\t\telse\n\t\t\tret = jz4780_i2c_xfer_write(i2c, msg->buf, msg->len,\n\t\t\t\t\t\t    count, i);\n\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tret = i;\n\nout:\n\tjz4780_i2c_cleanup(i2c);\n\treturn ret;\n}\n\nstatic u32 jz4780_i2c_functionality(struct i2c_adapter *adap)\n{\n\treturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;\n}\n\nstatic const struct i2c_algorithm jz4780_i2c_algorithm = {\n\t.master_xfer\t= jz4780_i2c_xfer,\n\t.functionality\t= jz4780_i2c_functionality,\n};\n\nstatic const struct ingenic_i2c_config jz4780_i2c_config = {\n\t.version = ID_JZ4780,\n\n\t.fifosize = JZ4780_I2C_FIFO_LEN,\n\t.tx_level = JZ4780_I2C_FIFO_LEN / 2,\n\t.rx_level = JZ4780_I2C_FIFO_LEN / 2 - 1,\n};\n\nstatic const struct ingenic_i2c_config x1000_i2c_config = {\n\t.version = ID_X1000,\n\n\t.fifosize = X1000_I2C_FIFO_LEN,\n\t.tx_level = X1000_I2C_FIFO_LEN / 2,\n\t.rx_level = X1000_I2C_FIFO_LEN / 2 - 1,\n};\n\nstatic const struct of_device_id jz4780_i2c_of_matches[] = {\n\t{ .compatible = \"ingenic,jz4770-i2c\", .data = &jz4780_i2c_config },\n\t{ .compatible = \"ingenic,jz4780-i2c\", .data = &jz4780_i2c_config },\n\t{ .compatible = \"ingenic,x1000-i2c\", .data = &x1000_i2c_config },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, jz4780_i2c_of_matches);\n\nstatic int jz4780_i2c_probe(struct platform_device *pdev)\n{\n\tint ret = 0;\n\tunsigned int clk_freq = 0;\n\tunsigned short tmp;\n\tstruct jz4780_i2c *i2c;\n\n\ti2c = devm_kzalloc(&pdev->dev, sizeof(struct jz4780_i2c), GFP_KERNEL);\n\tif (!i2c)\n\t\treturn -ENOMEM;\n\n\ti2c->cdata = device_get_match_data(&pdev->dev);\n\tif (!i2c->cdata) {\n\t\tdev_err(&pdev->dev, \"Error: No device match found\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\ti2c->adap.owner\t\t= THIS_MODULE;\n\ti2c->adap.algo\t\t= &jz4780_i2c_algorithm;\n\ti2c->adap.algo_data\t= i2c;\n\ti2c->adap.retries\t= 5;\n\ti2c->adap.dev.parent\t= &pdev->dev;\n\ti2c->adap.dev.of_node\t= pdev->dev.of_node;\n\tsprintf(i2c->adap.name, \"%s\", pdev->name);\n\n\tinit_completion(&i2c->trans_waitq);\n\tspin_lock_init(&i2c->lock);\n\n\ti2c->iomem = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(i2c->iomem))\n\t\treturn PTR_ERR(i2c->iomem);\n\n\tplatform_set_drvdata(pdev, i2c);\n\n\ti2c->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(i2c->clk))\n\t\treturn PTR_ERR(i2c->clk);\n\n\tret = clk_prepare_enable(i2c->clk);\n\tif (ret)\n\t\treturn ret;\n\n\tret = of_property_read_u32(pdev->dev.of_node, \"clock-frequency\",\n\t\t\t\t   &clk_freq);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"clock-frequency not specified in DT\\n\");\n\t\tgoto err;\n\t}\n\n\ti2c->speed = clk_freq / 1000;\n\tif (i2c->speed == 0) {\n\t\tret = -EINVAL;\n\t\tdev_err(&pdev->dev, \"clock-frequency minimum is 1000\\n\");\n\t\tgoto err;\n\t}\n\tjz4780_i2c_set_speed(i2c);\n\n\tdev_info(&pdev->dev, \"Bus frequency is %d KHz\\n\", i2c->speed);\n\n\tif (i2c->cdata->version < ID_X1000) {\n\t\ttmp = jz4780_i2c_readw(i2c, JZ4780_I2C_CTRL);\n\t\ttmp &= ~JZ4780_I2C_CTRL_STPHLD;\n\t\tjz4780_i2c_writew(i2c, JZ4780_I2C_CTRL, tmp);\n\t}\n\n\tjz4780_i2c_writew(i2c, JZ4780_I2C_INTM, 0x0);\n\n\tret = platform_get_irq(pdev, 0);\n\tif (ret < 0)\n\t\tgoto err;\n\ti2c->irq = ret;\n\tret = devm_request_irq(&pdev->dev, i2c->irq, jz4780_i2c_irq, 0,\n\t\t\t       dev_name(&pdev->dev), i2c);\n\tif (ret)\n\t\tgoto err;\n\n\tret = i2c_add_adapter(&i2c->adap);\n\tif (ret < 0)\n\t\tgoto err;\n\n\treturn 0;\n\nerr:\n\tclk_disable_unprepare(i2c->clk);\n\treturn ret;\n}\n\nstatic void jz4780_i2c_remove(struct platform_device *pdev)\n{\n\tstruct jz4780_i2c *i2c = platform_get_drvdata(pdev);\n\n\tclk_disable_unprepare(i2c->clk);\n\ti2c_del_adapter(&i2c->adap);\n}\n\nstatic struct platform_driver jz4780_i2c_driver = {\n\t.probe\t\t= jz4780_i2c_probe,\n\t.remove_new\t= jz4780_i2c_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"jz4780-i2c\",\n\t\t.of_match_table = jz4780_i2c_of_matches,\n\t},\n};\n\nmodule_platform_driver(jz4780_i2c_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"ztyan<ztyan@ingenic.cn>\");\nMODULE_DESCRIPTION(\"i2c driver for JZ4780 SoCs\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}