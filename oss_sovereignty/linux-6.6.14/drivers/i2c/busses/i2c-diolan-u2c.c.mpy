{
  "module_name": "i2c-diolan-u2c.c",
  "hash_id": "73419a2554942ecab43203d44f5a94b5b4e60d5b3be77d93b1dcb136ca1a0b7f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-diolan-u2c.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/usb.h>\n#include <linux/i2c.h>\n\n#define DRIVER_NAME\t\t\"i2c-diolan-u2c\"\n\n#define USB_VENDOR_ID_DIOLAN\t\t0x0abf\n#define USB_DEVICE_ID_DIOLAN_U2C\t0x3370\n\n\n \n#define CMD_I2C_READ\t\t0x01\n#define CMD_I2C_WRITE\t\t0x02\n#define CMD_I2C_SCAN\t\t0x03\t \n#define CMD_I2C_RELEASE_SDA\t0x04\n#define CMD_I2C_RELEASE_SCL\t0x05\n#define CMD_I2C_DROP_SDA\t0x06\n#define CMD_I2C_DROP_SCL\t0x07\n#define CMD_I2C_READ_SDA\t0x08\n#define CMD_I2C_READ_SCL\t0x09\n#define CMD_GET_FW_VERSION\t0x0a\n#define CMD_GET_SERIAL\t\t0x0b\n#define CMD_I2C_START\t\t0x0c\n#define CMD_I2C_STOP\t\t0x0d\n#define CMD_I2C_REPEATED_START\t0x0e\n#define CMD_I2C_PUT_BYTE\t0x0f\n#define CMD_I2C_GET_BYTE\t0x10\n#define CMD_I2C_PUT_ACK\t\t0x11\n#define CMD_I2C_GET_ACK\t\t0x12\n#define CMD_I2C_PUT_BYTE_ACK\t0x13\n#define CMD_I2C_GET_BYTE_ACK\t0x14\n#define CMD_I2C_SET_SPEED\t0x1b\n#define CMD_I2C_GET_SPEED\t0x1c\n#define CMD_I2C_SET_CLK_SYNC\t0x24\n#define CMD_I2C_GET_CLK_SYNC\t0x25\n#define CMD_I2C_SET_CLK_SYNC_TO\t0x26\n#define CMD_I2C_GET_CLK_SYNC_TO\t0x27\n\n#define RESP_OK\t\t\t0x00\n#define RESP_FAILED\t\t0x01\n#define RESP_BAD_MEMADDR\t0x04\n#define RESP_DATA_ERR\t\t0x05\n#define RESP_NOT_IMPLEMENTED\t0x06\n#define RESP_NACK\t\t0x07\n#define RESP_TIMEOUT\t\t0x09\n\n#define U2C_I2C_SPEED_FAST\t0\t \n#define U2C_I2C_SPEED_STD\t1\t \n#define U2C_I2C_SPEED_2KHZ\t242\t \n#define U2C_I2C_SPEED(f)\t((DIV_ROUND_UP(1000000, (f)) - 10) / 2 + 1)\n\n#define U2C_I2C_FREQ(s)\t\t(1000000 / (2 * (s - 1) + 10))\n\n#define DIOLAN_USB_TIMEOUT\t100\t \n#define DIOLAN_SYNC_TIMEOUT\t20\t \n\n#define DIOLAN_OUTBUF_LEN\t128\n#define DIOLAN_FLUSH_LEN\t(DIOLAN_OUTBUF_LEN - 4)\n#define DIOLAN_INBUF_LEN\t256\t \n\n \nstruct i2c_diolan_u2c {\n\tu8 obuffer[DIOLAN_OUTBUF_LEN];\t \n\tu8 ibuffer[DIOLAN_INBUF_LEN];\t \n\tint ep_in, ep_out;               \n\tstruct usb_device *usb_dev;\t \n\tstruct usb_interface *interface; \n\tstruct i2c_adapter adapter;\t \n\tint olen;\t\t\t \n\tint ocount;\t\t\t \n};\n\nstatic uint frequency = I2C_MAX_STANDARD_MODE_FREQ;\t \n\nmodule_param(frequency, uint, S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(frequency, \"I2C clock frequency in hertz\");\n\n \n\n \nstatic int diolan_usb_transfer(struct i2c_diolan_u2c *dev)\n{\n\tint ret = 0;\n\tint actual;\n\tint i;\n\n\tif (!dev->olen || !dev->ocount)\n\t\treturn -EINVAL;\n\n\tret = usb_bulk_msg(dev->usb_dev,\n\t\t\t   usb_sndbulkpipe(dev->usb_dev, dev->ep_out),\n\t\t\t   dev->obuffer, dev->olen, &actual,\n\t\t\t   DIOLAN_USB_TIMEOUT);\n\tif (!ret) {\n\t\tfor (i = 0; i < dev->ocount; i++) {\n\t\t\tint tmpret;\n\n\t\t\ttmpret = usb_bulk_msg(dev->usb_dev,\n\t\t\t\t\t      usb_rcvbulkpipe(dev->usb_dev,\n\t\t\t\t\t\t\t      dev->ep_in),\n\t\t\t\t\t      dev->ibuffer,\n\t\t\t\t\t      sizeof(dev->ibuffer), &actual,\n\t\t\t\t\t      DIOLAN_USB_TIMEOUT);\n\t\t\t \n\t\t\tif (ret < 0)\n\t\t\t\tcontinue;\n\t\t\tret = tmpret;\n\t\t\tif (ret == 0 && actual > 0) {\n\t\t\t\tswitch (dev->ibuffer[actual - 1]) {\n\t\t\t\tcase RESP_NACK:\n\t\t\t\t\t \n\t\t\t\t\tret = i == 1 ? -ENXIO : -EIO;\n\t\t\t\t\tbreak;\n\t\t\t\tcase RESP_TIMEOUT:\n\t\t\t\t\tret = -ETIMEDOUT;\n\t\t\t\t\tbreak;\n\t\t\t\tcase RESP_OK:\n\t\t\t\t\t \n\t\t\t\t\tret = actual - 1;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tret = -EIO;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdev->olen = 0;\n\tdev->ocount = 0;\n\treturn ret;\n}\n\nstatic int diolan_write_cmd(struct i2c_diolan_u2c *dev, bool flush)\n{\n\tif (flush || dev->olen >= DIOLAN_FLUSH_LEN)\n\t\treturn diolan_usb_transfer(dev);\n\treturn 0;\n}\n\n \nstatic int diolan_usb_cmd(struct i2c_diolan_u2c *dev, u8 command, bool flush)\n{\n\tdev->obuffer[dev->olen++] = command;\n\tdev->ocount++;\n\treturn diolan_write_cmd(dev, flush);\n}\n\n \nstatic int diolan_usb_cmd_data(struct i2c_diolan_u2c *dev, u8 command, u8 data,\n\t\t\t       bool flush)\n{\n\tdev->obuffer[dev->olen++] = command;\n\tdev->obuffer[dev->olen++] = data;\n\tdev->ocount++;\n\treturn diolan_write_cmd(dev, flush);\n}\n\n \nstatic int diolan_usb_cmd_data2(struct i2c_diolan_u2c *dev, u8 command, u8 d1,\n\t\t\t\tu8 d2, bool flush)\n{\n\tdev->obuffer[dev->olen++] = command;\n\tdev->obuffer[dev->olen++] = d1;\n\tdev->obuffer[dev->olen++] = d2;\n\tdev->ocount++;\n\treturn diolan_write_cmd(dev, flush);\n}\n\n \nstatic void diolan_flush_input(struct i2c_diolan_u2c *dev)\n{\n\tint i;\n\n\tfor (i = 0; i < 10; i++) {\n\t\tint actual = 0;\n\t\tint ret;\n\n\t\tret = usb_bulk_msg(dev->usb_dev,\n\t\t\t\t   usb_rcvbulkpipe(dev->usb_dev, dev->ep_in),\n\t\t\t\t   dev->ibuffer, sizeof(dev->ibuffer), &actual,\n\t\t\t\t   DIOLAN_USB_TIMEOUT);\n\t\tif (ret < 0 || actual == 0)\n\t\t\tbreak;\n\t}\n\tif (i == 10)\n\t\tdev_err(&dev->interface->dev, \"Failed to flush input buffer\\n\");\n}\n\nstatic int diolan_i2c_start(struct i2c_diolan_u2c *dev)\n{\n\treturn diolan_usb_cmd(dev, CMD_I2C_START, false);\n}\n\nstatic int diolan_i2c_repeated_start(struct i2c_diolan_u2c *dev)\n{\n\treturn diolan_usb_cmd(dev, CMD_I2C_REPEATED_START, false);\n}\n\nstatic int diolan_i2c_stop(struct i2c_diolan_u2c *dev)\n{\n\treturn diolan_usb_cmd(dev, CMD_I2C_STOP, true);\n}\n\nstatic int diolan_i2c_get_byte_ack(struct i2c_diolan_u2c *dev, bool ack,\n\t\t\t\t   u8 *byte)\n{\n\tint ret;\n\n\tret = diolan_usb_cmd_data(dev, CMD_I2C_GET_BYTE_ACK, ack, true);\n\tif (ret > 0)\n\t\t*byte = dev->ibuffer[0];\n\telse if (ret == 0)\n\t\tret = -EIO;\n\n\treturn ret;\n}\n\nstatic int diolan_i2c_put_byte_ack(struct i2c_diolan_u2c *dev, u8 byte)\n{\n\treturn diolan_usb_cmd_data(dev, CMD_I2C_PUT_BYTE_ACK, byte, false);\n}\n\nstatic int diolan_set_speed(struct i2c_diolan_u2c *dev, u8 speed)\n{\n\treturn diolan_usb_cmd_data(dev, CMD_I2C_SET_SPEED, speed, true);\n}\n\n \nstatic int diolan_set_clock_synch(struct i2c_diolan_u2c *dev, bool enable)\n{\n\treturn diolan_usb_cmd_data(dev, CMD_I2C_SET_CLK_SYNC, enable, true);\n}\n\n \nstatic int diolan_set_clock_synch_timeout(struct i2c_diolan_u2c *dev, int ms)\n{\n\tint to_val = ms * 10;\n\n\treturn diolan_usb_cmd_data2(dev, CMD_I2C_SET_CLK_SYNC_TO,\n\t\t\t\t    to_val & 0xff, (to_val >> 8) & 0xff, true);\n}\n\nstatic void diolan_fw_version(struct i2c_diolan_u2c *dev)\n{\n\tint ret;\n\n\tret = diolan_usb_cmd(dev, CMD_GET_FW_VERSION, true);\n\tif (ret >= 2)\n\t\tdev_info(&dev->interface->dev,\n\t\t\t \"Diolan U2C firmware version %u.%u\\n\",\n\t\t\t (unsigned int)dev->ibuffer[0],\n\t\t\t (unsigned int)dev->ibuffer[1]);\n}\n\nstatic void diolan_get_serial(struct i2c_diolan_u2c *dev)\n{\n\tint ret;\n\tu32 serial;\n\n\tret = diolan_usb_cmd(dev, CMD_GET_SERIAL, true);\n\tif (ret >= 4) {\n\t\tserial = le32_to_cpu(*(u32 *)dev->ibuffer);\n\t\tdev_info(&dev->interface->dev,\n\t\t\t \"Diolan U2C serial number %u\\n\", serial);\n\t}\n}\n\nstatic int diolan_init(struct i2c_diolan_u2c *dev)\n{\n\tint speed, ret;\n\n\tif (frequency >= 2 * I2C_MAX_STANDARD_MODE_FREQ) {\n\t\tspeed = U2C_I2C_SPEED_FAST;\n\t\tfrequency = I2C_MAX_FAST_MODE_FREQ;\n\t} else if (frequency >= I2C_MAX_STANDARD_MODE_FREQ || frequency == 0) {\n\t\tspeed = U2C_I2C_SPEED_STD;\n\t\tfrequency = I2C_MAX_STANDARD_MODE_FREQ;\n\t} else {\n\t\tspeed = U2C_I2C_SPEED(frequency);\n\t\tif (speed > U2C_I2C_SPEED_2KHZ)\n\t\t\tspeed = U2C_I2C_SPEED_2KHZ;\n\t\tfrequency = U2C_I2C_FREQ(speed);\n\t}\n\n\tdev_info(&dev->interface->dev,\n\t\t \"Diolan U2C at USB bus %03d address %03d speed %d Hz\\n\",\n\t\t dev->usb_dev->bus->busnum, dev->usb_dev->devnum, frequency);\n\n\tdiolan_flush_input(dev);\n\tdiolan_fw_version(dev);\n\tdiolan_get_serial(dev);\n\n\t \n\tret = diolan_set_speed(dev, speed);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = diolan_set_clock_synch(dev, speed != U2C_I2C_SPEED_FAST);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (speed != U2C_I2C_SPEED_FAST)\n\t\tret = diolan_set_clock_synch_timeout(dev, DIOLAN_SYNC_TIMEOUT);\n\n\treturn ret;\n}\n\n \n\nstatic int diolan_usb_xfer(struct i2c_adapter *adapter, struct i2c_msg *msgs,\n\t\t\t   int num)\n{\n\tstruct i2c_diolan_u2c *dev = i2c_get_adapdata(adapter);\n\tstruct i2c_msg *pmsg;\n\tint i, j;\n\tint ret, sret;\n\n\tret = diolan_i2c_start(dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfor (i = 0; i < num; i++) {\n\t\tpmsg = &msgs[i];\n\t\tif (i) {\n\t\t\tret = diolan_i2c_repeated_start(dev);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto abort;\n\t\t}\n\t\tret = diolan_i2c_put_byte_ack(dev,\n\t\t\t\t\t      i2c_8bit_addr_from_msg(pmsg));\n\t\tif (ret < 0)\n\t\t\tgoto abort;\n\t\tif (pmsg->flags & I2C_M_RD) {\n\t\t\tfor (j = 0; j < pmsg->len; j++) {\n\t\t\t\tu8 byte;\n\t\t\t\tbool ack = j < pmsg->len - 1;\n\n\t\t\t\t \n\t\t\t\tif (j == 0 && (pmsg->flags & I2C_M_RECV_LEN))\n\t\t\t\t\tack = true;\n\n\t\t\t\tret = diolan_i2c_get_byte_ack(dev, ack, &byte);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto abort;\n\t\t\t\t \n\t\t\t\tif (j == 0 && (pmsg->flags & I2C_M_RECV_LEN)) {\n\t\t\t\t\tif (byte == 0\n\t\t\t\t\t    || byte > I2C_SMBUS_BLOCK_MAX) {\n\t\t\t\t\t\tret = -EPROTO;\n\t\t\t\t\t\tgoto abort;\n\t\t\t\t\t}\n\t\t\t\t\tpmsg->len += byte;\n\t\t\t\t}\n\t\t\t\tpmsg->buf[j] = byte;\n\t\t\t}\n\t\t} else {\n\t\t\tfor (j = 0; j < pmsg->len; j++) {\n\t\t\t\tret = diolan_i2c_put_byte_ack(dev,\n\t\t\t\t\t\t\t      pmsg->buf[j]);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto abort;\n\t\t\t}\n\t\t}\n\t}\n\tret = num;\nabort:\n\tsret = diolan_i2c_stop(dev);\n\tif (sret < 0 && ret >= 0)\n\t\tret = sret;\n\treturn ret;\n}\n\n \nstatic u32 diolan_usb_func(struct i2c_adapter *a)\n{\n\treturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL |\n\t       I2C_FUNC_SMBUS_READ_BLOCK_DATA | I2C_FUNC_SMBUS_BLOCK_PROC_CALL;\n}\n\nstatic const struct i2c_algorithm diolan_usb_algorithm = {\n\t.master_xfer = diolan_usb_xfer,\n\t.functionality = diolan_usb_func,\n};\n\n \n\nstatic const struct usb_device_id diolan_u2c_table[] = {\n\t{ USB_DEVICE(USB_VENDOR_ID_DIOLAN, USB_DEVICE_ID_DIOLAN_U2C) },\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(usb, diolan_u2c_table);\n\nstatic void diolan_u2c_free(struct i2c_diolan_u2c *dev)\n{\n\tusb_put_dev(dev->usb_dev);\n\tkfree(dev);\n}\n\nstatic int diolan_u2c_probe(struct usb_interface *interface,\n\t\t\t    const struct usb_device_id *id)\n{\n\tstruct usb_host_interface *hostif = interface->cur_altsetting;\n\tstruct i2c_diolan_u2c *dev;\n\tint ret;\n\n\tif (hostif->desc.bInterfaceNumber != 0\n\t    || hostif->desc.bNumEndpoints < 2)\n\t\treturn -ENODEV;\n\n\t \n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (dev == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\tdev->ep_out = hostif->endpoint[0].desc.bEndpointAddress;\n\tdev->ep_in = hostif->endpoint[1].desc.bEndpointAddress;\n\n\tdev->usb_dev = usb_get_dev(interface_to_usbdev(interface));\n\tdev->interface = interface;\n\n\t \n\tusb_set_intfdata(interface, dev);\n\n\t \n\tdev->adapter.owner = THIS_MODULE;\n\tdev->adapter.class = I2C_CLASS_HWMON;\n\tdev->adapter.algo = &diolan_usb_algorithm;\n\ti2c_set_adapdata(&dev->adapter, dev);\n\tsnprintf(dev->adapter.name, sizeof(dev->adapter.name),\n\t\t DRIVER_NAME \" at bus %03d device %03d\",\n\t\t dev->usb_dev->bus->busnum, dev->usb_dev->devnum);\n\n\tdev->adapter.dev.parent = &dev->interface->dev;\n\n\t \n\tret = diolan_init(dev);\n\tif (ret < 0) {\n\t\tdev_err(&interface->dev, \"failed to initialize adapter\\n\");\n\t\tgoto error_free;\n\t}\n\n\t \n\tret = i2c_add_adapter(&dev->adapter);\n\tif (ret < 0)\n\t\tgoto error_free;\n\n\tdev_dbg(&interface->dev, \"connected \" DRIVER_NAME \"\\n\");\n\n\treturn 0;\n\nerror_free:\n\tusb_set_intfdata(interface, NULL);\n\tdiolan_u2c_free(dev);\nerror:\n\treturn ret;\n}\n\nstatic void diolan_u2c_disconnect(struct usb_interface *interface)\n{\n\tstruct i2c_diolan_u2c *dev = usb_get_intfdata(interface);\n\n\ti2c_del_adapter(&dev->adapter);\n\tusb_set_intfdata(interface, NULL);\n\tdiolan_u2c_free(dev);\n\n\tdev_dbg(&interface->dev, \"disconnected\\n\");\n}\n\nstatic struct usb_driver diolan_u2c_driver = {\n\t.name = DRIVER_NAME,\n\t.probe = diolan_u2c_probe,\n\t.disconnect = diolan_u2c_disconnect,\n\t.id_table = diolan_u2c_table,\n};\n\nmodule_usb_driver(diolan_u2c_driver);\n\nMODULE_AUTHOR(\"Guenter Roeck <linux@roeck-us.net>\");\nMODULE_DESCRIPTION(DRIVER_NAME \" driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}