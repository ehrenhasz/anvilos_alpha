{
  "module_name": "i2c-pasemi-core.c",
  "hash_id": "353f511606638f199321e1cab35a945b16bc59acc526c01e212559e5529c2cbf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-pasemi-core.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/sched.h>\n#include <linux/i2c.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n\n#include \"i2c-pasemi-core.h\"\n\n \n#define REG_MTXFIFO\t0x00\n#define REG_MRXFIFO\t0x04\n#define REG_SMSTA\t0x14\n#define REG_IMASK\t0x18\n#define REG_CTL\t\t0x1c\n#define REG_REV\t\t0x28\n\n \n#define MTXFIFO_READ\t0x00000400\n#define MTXFIFO_STOP\t0x00000200\n#define MTXFIFO_START\t0x00000100\n#define MTXFIFO_DATA_M\t0x000000ff\n\n#define MRXFIFO_EMPTY\t0x00000100\n#define MRXFIFO_DATA_M\t0x000000ff\n\n#define SMSTA_XEN\t0x08000000\n#define SMSTA_MTN\t0x00200000\n\n#define CTL_MRR\t\t0x00000400\n#define CTL_MTR\t\t0x00000200\n#define CTL_EN\t\t0x00000800\n#define CTL_CLK_M\t0x000000ff\n\nstatic inline void reg_write(struct pasemi_smbus *smbus, int reg, int val)\n{\n\tdev_dbg(smbus->dev, \"smbus write reg %x val %08x\\n\", reg, val);\n\tiowrite32(val, smbus->ioaddr + reg);\n}\n\nstatic inline int reg_read(struct pasemi_smbus *smbus, int reg)\n{\n\tint ret;\n\tret = ioread32(smbus->ioaddr + reg);\n\tdev_dbg(smbus->dev, \"smbus read reg %x val %08x\\n\", reg, ret);\n\treturn ret;\n}\n\n#define TXFIFO_WR(smbus, reg)\treg_write((smbus), REG_MTXFIFO, (reg))\n#define RXFIFO_RD(smbus)\treg_read((smbus), REG_MRXFIFO)\n\nstatic void pasemi_reset(struct pasemi_smbus *smbus)\n{\n\tu32 val = (CTL_MTR | CTL_MRR | (smbus->clk_div & CTL_CLK_M));\n\n\tif (smbus->hw_rev >= 6)\n\t\tval |= CTL_EN;\n\n\treg_write(smbus, REG_CTL, val);\n\treinit_completion(&smbus->irq_completion);\n}\n\nstatic void pasemi_smb_clear(struct pasemi_smbus *smbus)\n{\n\tunsigned int status;\n\n\tstatus = reg_read(smbus, REG_SMSTA);\n\treg_write(smbus, REG_SMSTA, status);\n}\n\nstatic int pasemi_smb_waitready(struct pasemi_smbus *smbus)\n{\n\tint timeout = 100;\n\tunsigned int status;\n\n\tif (smbus->use_irq) {\n\t\treinit_completion(&smbus->irq_completion);\n\t\treg_write(smbus, REG_IMASK, SMSTA_XEN | SMSTA_MTN);\n\t\twait_for_completion_timeout(&smbus->irq_completion, msecs_to_jiffies(100));\n\t\treg_write(smbus, REG_IMASK, 0);\n\t\tstatus = reg_read(smbus, REG_SMSTA);\n\t} else {\n\t\tstatus = reg_read(smbus, REG_SMSTA);\n\t\twhile (!(status & SMSTA_XEN) && timeout--) {\n\t\t\tmsleep(1);\n\t\t\tstatus = reg_read(smbus, REG_SMSTA);\n\t\t}\n\t}\n\n\t \n\tif (status & SMSTA_MTN)\n\t\treturn -ENXIO;\n\n\tif (timeout < 0) {\n\t\tdev_warn(smbus->dev, \"Timeout, status 0x%08x\\n\", status);\n\t\treg_write(smbus, REG_SMSTA, status);\n\t\treturn -ETIME;\n\t}\n\n\t \n\treg_write(smbus, REG_SMSTA, SMSTA_XEN);\n\n\treturn 0;\n}\n\nstatic int pasemi_i2c_xfer_msg(struct i2c_adapter *adapter,\n\t\t\t       struct i2c_msg *msg, int stop)\n{\n\tstruct pasemi_smbus *smbus = adapter->algo_data;\n\tint read, i, err;\n\tu32 rd;\n\n\tread = msg->flags & I2C_M_RD ? 1 : 0;\n\n\tTXFIFO_WR(smbus, MTXFIFO_START | i2c_8bit_addr_from_msg(msg));\n\n\tif (read) {\n\t\tTXFIFO_WR(smbus, msg->len | MTXFIFO_READ |\n\t\t\t\t (stop ? MTXFIFO_STOP : 0));\n\n\t\terr = pasemi_smb_waitready(smbus);\n\t\tif (err)\n\t\t\tgoto reset_out;\n\n\t\tfor (i = 0; i < msg->len; i++) {\n\t\t\trd = RXFIFO_RD(smbus);\n\t\t\tif (rd & MRXFIFO_EMPTY) {\n\t\t\t\terr = -ENODATA;\n\t\t\t\tgoto reset_out;\n\t\t\t}\n\t\t\tmsg->buf[i] = rd & MRXFIFO_DATA_M;\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < msg->len - 1; i++)\n\t\t\tTXFIFO_WR(smbus, msg->buf[i]);\n\n\t\tTXFIFO_WR(smbus, msg->buf[msg->len-1] |\n\t\t\t  (stop ? MTXFIFO_STOP : 0));\n\n\t\tif (stop) {\n\t\t\terr = pasemi_smb_waitready(smbus);\n\t\t\tif (err)\n\t\t\t\tgoto reset_out;\n\t\t}\n\t}\n\n\treturn 0;\n\n reset_out:\n\tpasemi_reset(smbus);\n\treturn err;\n}\n\nstatic int pasemi_i2c_xfer(struct i2c_adapter *adapter,\n\t\t\t   struct i2c_msg *msgs, int num)\n{\n\tstruct pasemi_smbus *smbus = adapter->algo_data;\n\tint ret, i;\n\n\tpasemi_smb_clear(smbus);\n\n\tret = 0;\n\n\tfor (i = 0; i < num && !ret; i++)\n\t\tret = pasemi_i2c_xfer_msg(adapter, &msgs[i], (i == (num - 1)));\n\n\treturn ret ? ret : num;\n}\n\nstatic int pasemi_smb_xfer(struct i2c_adapter *adapter,\n\t\tu16 addr, unsigned short flags, char read_write, u8 command,\n\t\tint size, union i2c_smbus_data *data)\n{\n\tstruct pasemi_smbus *smbus = adapter->algo_data;\n\tunsigned int rd;\n\tint read_flag, err;\n\tint len = 0, i;\n\n\t \n\taddr <<= 1;\n\tread_flag = read_write == I2C_SMBUS_READ;\n\n\tpasemi_smb_clear(smbus);\n\n\tswitch (size) {\n\tcase I2C_SMBUS_QUICK:\n\t\tTXFIFO_WR(smbus, addr | read_flag | MTXFIFO_START |\n\t\t\t  MTXFIFO_STOP);\n\t\tbreak;\n\tcase I2C_SMBUS_BYTE:\n\t\tTXFIFO_WR(smbus, addr | read_flag | MTXFIFO_START);\n\t\tif (read_write)\n\t\t\tTXFIFO_WR(smbus, 1 | MTXFIFO_STOP | MTXFIFO_READ);\n\t\telse\n\t\t\tTXFIFO_WR(smbus, MTXFIFO_STOP | command);\n\t\tbreak;\n\tcase I2C_SMBUS_BYTE_DATA:\n\t\tTXFIFO_WR(smbus, addr | MTXFIFO_START);\n\t\tTXFIFO_WR(smbus, command);\n\t\tif (read_write) {\n\t\t\tTXFIFO_WR(smbus, addr | I2C_SMBUS_READ | MTXFIFO_START);\n\t\t\tTXFIFO_WR(smbus, 1 | MTXFIFO_READ | MTXFIFO_STOP);\n\t\t} else {\n\t\t\tTXFIFO_WR(smbus, MTXFIFO_STOP | data->byte);\n\t\t}\n\t\tbreak;\n\tcase I2C_SMBUS_WORD_DATA:\n\t\tTXFIFO_WR(smbus, addr | MTXFIFO_START);\n\t\tTXFIFO_WR(smbus, command);\n\t\tif (read_write) {\n\t\t\tTXFIFO_WR(smbus, addr | I2C_SMBUS_READ | MTXFIFO_START);\n\t\t\tTXFIFO_WR(smbus, 2 | MTXFIFO_READ | MTXFIFO_STOP);\n\t\t} else {\n\t\t\tTXFIFO_WR(smbus, data->word & MTXFIFO_DATA_M);\n\t\t\tTXFIFO_WR(smbus, MTXFIFO_STOP | (data->word >> 8));\n\t\t}\n\t\tbreak;\n\tcase I2C_SMBUS_BLOCK_DATA:\n\t\tTXFIFO_WR(smbus, addr | MTXFIFO_START);\n\t\tTXFIFO_WR(smbus, command);\n\t\tif (read_write) {\n\t\t\tTXFIFO_WR(smbus, addr | I2C_SMBUS_READ | MTXFIFO_START);\n\t\t\tTXFIFO_WR(smbus, 1 | MTXFIFO_READ);\n\t\t\trd = RXFIFO_RD(smbus);\n\t\t\tlen = min_t(u8, (rd & MRXFIFO_DATA_M),\n\t\t\t\t    I2C_SMBUS_BLOCK_MAX);\n\t\t\tTXFIFO_WR(smbus, len | MTXFIFO_READ |\n\t\t\t\t\t MTXFIFO_STOP);\n\t\t} else {\n\t\t\tlen = min_t(u8, data->block[0], I2C_SMBUS_BLOCK_MAX);\n\t\t\tTXFIFO_WR(smbus, len);\n\t\t\tfor (i = 1; i < len; i++)\n\t\t\t\tTXFIFO_WR(smbus, data->block[i]);\n\t\t\tTXFIFO_WR(smbus, data->block[len] | MTXFIFO_STOP);\n\t\t}\n\t\tbreak;\n\tcase I2C_SMBUS_PROC_CALL:\n\t\tread_write = I2C_SMBUS_READ;\n\t\tTXFIFO_WR(smbus, addr | MTXFIFO_START);\n\t\tTXFIFO_WR(smbus, command);\n\t\tTXFIFO_WR(smbus, data->word & MTXFIFO_DATA_M);\n\t\tTXFIFO_WR(smbus, (data->word >> 8) & MTXFIFO_DATA_M);\n\t\tTXFIFO_WR(smbus, addr | I2C_SMBUS_READ | MTXFIFO_START);\n\t\tTXFIFO_WR(smbus, 2 | MTXFIFO_STOP | MTXFIFO_READ);\n\t\tbreak;\n\tcase I2C_SMBUS_BLOCK_PROC_CALL:\n\t\tlen = min_t(u8, data->block[0], I2C_SMBUS_BLOCK_MAX - 1);\n\t\tread_write = I2C_SMBUS_READ;\n\t\tTXFIFO_WR(smbus, addr | MTXFIFO_START);\n\t\tTXFIFO_WR(smbus, command);\n\t\tTXFIFO_WR(smbus, len);\n\t\tfor (i = 1; i <= len; i++)\n\t\t\tTXFIFO_WR(smbus, data->block[i]);\n\t\tTXFIFO_WR(smbus, addr | I2C_SMBUS_READ);\n\t\tTXFIFO_WR(smbus, MTXFIFO_READ | 1);\n\t\trd = RXFIFO_RD(smbus);\n\t\tlen = min_t(u8, (rd & MRXFIFO_DATA_M),\n\t\t\t    I2C_SMBUS_BLOCK_MAX - len);\n\t\tTXFIFO_WR(smbus, len | MTXFIFO_READ | MTXFIFO_STOP);\n\t\tbreak;\n\n\tdefault:\n\t\tdev_warn(&adapter->dev, \"Unsupported transaction %d\\n\", size);\n\t\treturn -EINVAL;\n\t}\n\n\terr = pasemi_smb_waitready(smbus);\n\tif (err)\n\t\tgoto reset_out;\n\n\tif (read_write == I2C_SMBUS_WRITE)\n\t\treturn 0;\n\n\tswitch (size) {\n\tcase I2C_SMBUS_BYTE:\n\tcase I2C_SMBUS_BYTE_DATA:\n\t\trd = RXFIFO_RD(smbus);\n\t\tif (rd & MRXFIFO_EMPTY) {\n\t\t\terr = -ENODATA;\n\t\t\tgoto reset_out;\n\t\t}\n\t\tdata->byte = rd & MRXFIFO_DATA_M;\n\t\tbreak;\n\tcase I2C_SMBUS_WORD_DATA:\n\tcase I2C_SMBUS_PROC_CALL:\n\t\trd = RXFIFO_RD(smbus);\n\t\tif (rd & MRXFIFO_EMPTY) {\n\t\t\terr = -ENODATA;\n\t\t\tgoto reset_out;\n\t\t}\n\t\tdata->word = rd & MRXFIFO_DATA_M;\n\t\trd = RXFIFO_RD(smbus);\n\t\tif (rd & MRXFIFO_EMPTY) {\n\t\t\terr = -ENODATA;\n\t\t\tgoto reset_out;\n\t\t}\n\t\tdata->word |= (rd & MRXFIFO_DATA_M) << 8;\n\t\tbreak;\n\tcase I2C_SMBUS_BLOCK_DATA:\n\tcase I2C_SMBUS_BLOCK_PROC_CALL:\n\t\tdata->block[0] = len;\n\t\tfor (i = 1; i <= len; i ++) {\n\t\t\trd = RXFIFO_RD(smbus);\n\t\t\tif (rd & MRXFIFO_EMPTY) {\n\t\t\t\terr = -ENODATA;\n\t\t\t\tgoto reset_out;\n\t\t\t}\n\t\t\tdata->block[i] = rd & MRXFIFO_DATA_M;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn 0;\n\n reset_out:\n\tpasemi_reset(smbus);\n\treturn err;\n}\n\nstatic u32 pasemi_smb_func(struct i2c_adapter *adapter)\n{\n\treturn I2C_FUNC_SMBUS_QUICK | I2C_FUNC_SMBUS_BYTE |\n\t       I2C_FUNC_SMBUS_BYTE_DATA | I2C_FUNC_SMBUS_WORD_DATA |\n\t       I2C_FUNC_SMBUS_BLOCK_DATA | I2C_FUNC_SMBUS_PROC_CALL |\n\t       I2C_FUNC_SMBUS_BLOCK_PROC_CALL | I2C_FUNC_I2C;\n}\n\nstatic const struct i2c_algorithm smbus_algorithm = {\n\t.master_xfer\t= pasemi_i2c_xfer,\n\t.smbus_xfer\t= pasemi_smb_xfer,\n\t.functionality\t= pasemi_smb_func,\n};\n\nint pasemi_i2c_common_probe(struct pasemi_smbus *smbus)\n{\n\tint error;\n\n\tsmbus->adapter.owner = THIS_MODULE;\n\tsnprintf(smbus->adapter.name, sizeof(smbus->adapter.name),\n\t\t \"PA Semi SMBus adapter (%s)\", dev_name(smbus->dev));\n\tsmbus->adapter.algo = &smbus_algorithm;\n\tsmbus->adapter.algo_data = smbus;\n\n\t \n\tsmbus->adapter.dev.parent = smbus->dev;\n\tsmbus->use_irq = 0;\n\tinit_completion(&smbus->irq_completion);\n\n\tif (smbus->hw_rev != PASEMI_HW_REV_PCI)\n\t\tsmbus->hw_rev = reg_read(smbus, REG_REV);\n\n\treg_write(smbus, REG_IMASK, 0);\n\n\tpasemi_reset(smbus);\n\n\terror = devm_i2c_add_adapter(smbus->dev, &smbus->adapter);\n\tif (error)\n\t\treturn error;\n\n\treturn 0;\n}\n\nirqreturn_t pasemi_irq_handler(int irq, void *dev_id)\n{\n\tstruct pasemi_smbus *smbus = dev_id;\n\n\treg_write(smbus, REG_IMASK, 0);\n\tcomplete(&smbus->irq_completion);\n\treturn IRQ_HANDLED;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}