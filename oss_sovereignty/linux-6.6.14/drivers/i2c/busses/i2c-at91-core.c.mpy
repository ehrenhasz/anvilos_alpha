{
  "module_name": "i2c-at91-core.c",
  "hash_id": "077ce80faab6bc9e41515408019429d0eb4ba334dac694bd2efa577f98d8268d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-at91-core.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/err.h>\n#include <linux/i2c.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/pinctrl/consumer.h>\n\n#include \"i2c-at91.h\"\n\nunsigned at91_twi_read(struct at91_twi_dev *dev, unsigned reg)\n{\n\treturn readl_relaxed(dev->base + reg);\n}\n\nvoid at91_twi_write(struct at91_twi_dev *dev, unsigned reg, unsigned val)\n{\n\twritel_relaxed(val, dev->base + reg);\n}\n\nvoid at91_disable_twi_interrupts(struct at91_twi_dev *dev)\n{\n\tat91_twi_write(dev, AT91_TWI_IDR, AT91_TWI_INT_MASK);\n}\n\nvoid at91_twi_irq_save(struct at91_twi_dev *dev)\n{\n\tdev->imr = at91_twi_read(dev, AT91_TWI_IMR) & AT91_TWI_INT_MASK;\n\tat91_disable_twi_interrupts(dev);\n}\n\nvoid at91_twi_irq_restore(struct at91_twi_dev *dev)\n{\n\tat91_twi_write(dev, AT91_TWI_IER, dev->imr);\n}\n\nvoid at91_init_twi_bus(struct at91_twi_dev *dev)\n{\n\tat91_disable_twi_interrupts(dev);\n\tat91_twi_write(dev, AT91_TWI_CR, AT91_TWI_SWRST);\n\tif (dev->slave_detected)\n\t\tat91_init_twi_bus_slave(dev);\n\telse\n\t\tat91_init_twi_bus_master(dev);\n}\n\nstatic struct at91_twi_pdata at91rm9200_config = {\n\t.clk_max_div = 5,\n\t.clk_offset = 3,\n\t.has_unre_flag = true,\n};\n\nstatic struct at91_twi_pdata at91sam9261_config = {\n\t.clk_max_div = 5,\n\t.clk_offset = 4,\n};\n\nstatic struct at91_twi_pdata at91sam9260_config = {\n\t.clk_max_div = 7,\n\t.clk_offset = 4,\n};\n\nstatic struct at91_twi_pdata at91sam9g20_config = {\n\t.clk_max_div = 7,\n\t.clk_offset = 4,\n};\n\nstatic struct at91_twi_pdata at91sam9g10_config = {\n\t.clk_max_div = 7,\n\t.clk_offset = 4,\n};\n\nstatic const struct platform_device_id at91_twi_devtypes[] = {\n\t{\n\t\t.name = \"i2c-at91rm9200\",\n\t\t.driver_data = (unsigned long) &at91rm9200_config,\n\t}, {\n\t\t.name = \"i2c-at91sam9261\",\n\t\t.driver_data = (unsigned long) &at91sam9261_config,\n\t}, {\n\t\t.name = \"i2c-at91sam9260\",\n\t\t.driver_data = (unsigned long) &at91sam9260_config,\n\t}, {\n\t\t.name = \"i2c-at91sam9g20\",\n\t\t.driver_data = (unsigned long) &at91sam9g20_config,\n\t}, {\n\t\t.name = \"i2c-at91sam9g10\",\n\t\t.driver_data = (unsigned long) &at91sam9g10_config,\n\t}, {\n\t\t \n\t}\n};\n\n#if defined(CONFIG_OF)\nstatic struct at91_twi_pdata at91sam9x5_config = {\n\t.clk_max_div = 7,\n\t.clk_offset = 4,\n};\n\nstatic struct at91_twi_pdata sama5d4_config = {\n\t.clk_max_div = 7,\n\t.clk_offset = 4,\n\t.has_hold_field = true,\n\t.has_dig_filtr = true,\n};\n\nstatic struct at91_twi_pdata sama5d2_config = {\n\t.clk_max_div = 7,\n\t.clk_offset = 3,\n\t.has_unre_flag = true,\n\t.has_alt_cmd = true,\n\t.has_hold_field = true,\n\t.has_dig_filtr = true,\n\t.has_adv_dig_filtr = true,\n\t.has_ana_filtr = true,\n\t.has_clear_cmd = false,\t \n};\n\nstatic struct at91_twi_pdata sam9x60_config = {\n\t.clk_max_div = 7,\n\t.clk_offset = 3,\n\t.has_unre_flag = true,\n\t.has_alt_cmd = true,\n\t.has_hold_field = true,\n\t.has_dig_filtr = true,\n\t.has_adv_dig_filtr = true,\n\t.has_ana_filtr = true,\n\t.has_clear_cmd = true,\n};\n\nstatic const struct of_device_id atmel_twi_dt_ids[] = {\n\t{\n\t\t.compatible = \"atmel,at91rm9200-i2c\",\n\t\t.data = &at91rm9200_config,\n\t}, {\n\t\t.compatible = \"atmel,at91sam9260-i2c\",\n\t\t.data = &at91sam9260_config,\n\t}, {\n\t\t.compatible = \"atmel,at91sam9261-i2c\",\n\t\t.data = &at91sam9261_config,\n\t}, {\n\t\t.compatible = \"atmel,at91sam9g20-i2c\",\n\t\t.data = &at91sam9g20_config,\n\t}, {\n\t\t.compatible = \"atmel,at91sam9g10-i2c\",\n\t\t.data = &at91sam9g10_config,\n\t}, {\n\t\t.compatible = \"atmel,at91sam9x5-i2c\",\n\t\t.data = &at91sam9x5_config,\n\t}, {\n\t\t.compatible = \"atmel,sama5d4-i2c\",\n\t\t.data = &sama5d4_config,\n\t}, {\n\t\t.compatible = \"atmel,sama5d2-i2c\",\n\t\t.data = &sama5d2_config,\n\t}, {\n\t\t.compatible = \"microchip,sam9x60-i2c\",\n\t\t.data = &sam9x60_config,\n\t}, {\n\t\t \n\t}\n};\nMODULE_DEVICE_TABLE(of, atmel_twi_dt_ids);\n#endif\n\nstatic struct at91_twi_pdata *at91_twi_get_driver_data(\n\t\t\t\t\tstruct platform_device *pdev)\n{\n\tif (pdev->dev.of_node) {\n\t\tconst struct of_device_id *match;\n\t\tmatch = of_match_node(atmel_twi_dt_ids, pdev->dev.of_node);\n\t\tif (!match)\n\t\t\treturn NULL;\n\t\treturn (struct at91_twi_pdata *)match->data;\n\t}\n\treturn (struct at91_twi_pdata *) platform_get_device_id(pdev)->driver_data;\n}\n\nstatic int at91_twi_probe(struct platform_device *pdev)\n{\n\tstruct at91_twi_dev *dev;\n\tstruct resource *mem;\n\tint rc;\n\tu32 phy_addr;\n\n\tdev = devm_kzalloc(&pdev->dev, sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tdev->dev = &pdev->dev;\n\n\tdev->base = devm_platform_get_and_ioremap_resource(pdev, 0, &mem);\n\tif (IS_ERR(dev->base))\n\t\treturn PTR_ERR(dev->base);\n\tphy_addr = mem->start;\n\n\tdev->pdata = at91_twi_get_driver_data(pdev);\n\tif (!dev->pdata)\n\t\treturn -ENODEV;\n\n\tdev->irq = platform_get_irq(pdev, 0);\n\tif (dev->irq < 0)\n\t\treturn dev->irq;\n\n\tplatform_set_drvdata(pdev, dev);\n\n\tdev->clk = devm_clk_get(dev->dev, NULL);\n\tif (IS_ERR(dev->clk))\n\t\treturn dev_err_probe(dev->dev, PTR_ERR(dev->clk), \"no clock defined\\n\");\n\n\tclk_prepare_enable(dev->clk);\n\n\tsnprintf(dev->adapter.name, sizeof(dev->adapter.name), \"AT91\");\n\ti2c_set_adapdata(&dev->adapter, dev);\n\tdev->adapter.owner = THIS_MODULE;\n\tdev->adapter.class = I2C_CLASS_DEPRECATED;\n\tdev->adapter.dev.parent = dev->dev;\n\tdev->adapter.nr = pdev->id;\n\tdev->adapter.timeout = AT91_I2C_TIMEOUT;\n\tdev->adapter.dev.of_node = pdev->dev.of_node;\n\n\tdev->slave_detected = i2c_detect_slave_mode(&pdev->dev);\n\n\tif (dev->slave_detected)\n\t\trc = at91_twi_probe_slave(pdev, phy_addr, dev);\n\telse\n\t\trc = at91_twi_probe_master(pdev, phy_addr, dev);\n\tif (rc)\n\t\treturn rc;\n\n\tat91_init_twi_bus(dev);\n\n\tpm_runtime_set_autosuspend_delay(dev->dev, AUTOSUSPEND_TIMEOUT);\n\tpm_runtime_use_autosuspend(dev->dev);\n\tpm_runtime_set_active(dev->dev);\n\tpm_runtime_enable(dev->dev);\n\n\trc = i2c_add_numbered_adapter(&dev->adapter);\n\tif (rc) {\n\t\tclk_disable_unprepare(dev->clk);\n\n\t\tpm_runtime_disable(dev->dev);\n\t\tpm_runtime_set_suspended(dev->dev);\n\n\t\treturn rc;\n\t}\n\n\tdev_info(dev->dev, \"AT91 i2c bus driver (hw version: %#x).\\n\",\n\t\t at91_twi_read(dev, AT91_TWI_VER));\n\treturn 0;\n}\n\nstatic void at91_twi_remove(struct platform_device *pdev)\n{\n\tstruct at91_twi_dev *dev = platform_get_drvdata(pdev);\n\n\ti2c_del_adapter(&dev->adapter);\n\tclk_disable_unprepare(dev->clk);\n\n\tpm_runtime_disable(dev->dev);\n\tpm_runtime_set_suspended(dev->dev);\n}\n\nstatic int __maybe_unused at91_twi_runtime_suspend(struct device *dev)\n{\n\tstruct at91_twi_dev *twi_dev = dev_get_drvdata(dev);\n\n\tclk_disable_unprepare(twi_dev->clk);\n\n\tpinctrl_pm_select_sleep_state(dev);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused at91_twi_runtime_resume(struct device *dev)\n{\n\tstruct at91_twi_dev *twi_dev = dev_get_drvdata(dev);\n\n\tpinctrl_pm_select_default_state(dev);\n\n\treturn clk_prepare_enable(twi_dev->clk);\n}\n\nstatic int __maybe_unused at91_twi_suspend_noirq(struct device *dev)\n{\n\tif (!pm_runtime_status_suspended(dev))\n\t\tat91_twi_runtime_suspend(dev);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused at91_twi_resume_noirq(struct device *dev)\n{\n\tstruct at91_twi_dev *twi_dev = dev_get_drvdata(dev);\n\tint ret;\n\n\tif (!pm_runtime_status_suspended(dev)) {\n\t\tret = at91_twi_runtime_resume(dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tpm_runtime_mark_last_busy(dev);\n\tpm_request_autosuspend(dev);\n\n\tat91_init_twi_bus(twi_dev);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops __maybe_unused at91_twi_pm = {\n\t.suspend_noirq\t= at91_twi_suspend_noirq,\n\t.resume_noirq\t= at91_twi_resume_noirq,\n\t.runtime_suspend\t= at91_twi_runtime_suspend,\n\t.runtime_resume\t\t= at91_twi_runtime_resume,\n};\n\nstatic struct platform_driver at91_twi_driver = {\n\t.probe\t\t= at91_twi_probe,\n\t.remove_new\t= at91_twi_remove,\n\t.id_table\t= at91_twi_devtypes,\n\t.driver\t\t= {\n\t\t.name\t= \"at91_i2c\",\n\t\t.of_match_table = of_match_ptr(atmel_twi_dt_ids),\n\t\t.pm\t= pm_ptr(&at91_twi_pm),\n\t},\n};\n\nstatic int __init at91_twi_init(void)\n{\n\treturn platform_driver_register(&at91_twi_driver);\n}\n\nstatic void __exit at91_twi_exit(void)\n{\n\tplatform_driver_unregister(&at91_twi_driver);\n}\n\nsubsys_initcall(at91_twi_init);\nmodule_exit(at91_twi_exit);\n\nMODULE_AUTHOR(\"Nikolaus Voss <n.voss@weinmann.de>\");\nMODULE_DESCRIPTION(\"I2C (TWI) driver for Atmel AT91\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:at91_i2c\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}