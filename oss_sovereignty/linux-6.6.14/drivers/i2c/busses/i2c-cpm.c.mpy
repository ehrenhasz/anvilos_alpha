{
  "module_name": "i2c-cpm.c",
  "hash_id": "94a218045aa5fd9a98d1d7f8f4b8d151ad6e37840fa521c1601a0c31bb81f80e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-cpm.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include <linux/i2c.h>\n#include <linux/io.h>\n#include <linux/dma-mapping.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/platform_device.h>\n#include <sysdev/fsl_soc.h>\n#include <asm/cpm.h>\n\n \n \n#undef\tI2C_CHIP_ERRATA\n\n#define CPM_MAX_READ    513\n#define CPM_MAXBD       4\n\n#define I2C_EB\t\t\t(0x10)  \n#define I2C_EB_CPM2\t\t(0x30)  \n\n#define DPRAM_BASE\t\t((u8 __iomem __force *)cpm_muram_addr(0))\n\n \nstruct i2c_ram {\n\tushort  rbase;\t\t \n\tushort  tbase;\t\t \n\tu_char  rfcr;\t\t \n\tu_char  tfcr;\t\t \n\tushort  mrblr;\t\t \n\tuint    rstate;\t\t \n\tuint    rdp;\t\t \n\tushort  rbptr;\t\t \n\tushort  rbc;\t\t \n\tuint    rxtmp;\t\t \n\tuint    tstate;\t\t \n\tuint    tdp;\t\t \n\tushort  tbptr;\t\t \n\tushort  tbc;\t\t \n\tuint    txtmp;\t\t \n\tchar    res1[4];\t \n\tushort  rpbase;\t\t \n\tchar    res2[2];\t \n\t \n\tchar    res3[4];\t \n\tuint    sdmatmp;\t \n};\n\n#define I2COM_START\t0x80\n#define I2COM_MASTER\t0x01\n#define I2CER_TXE\t0x10\n#define I2CER_BUSY\t0x04\n#define I2CER_TXB\t0x02\n#define I2CER_RXB\t0x01\n#define I2MOD_EN\t0x01\n\n \nstruct i2c_reg {\n\tu8\ti2mod;\n\tu8\tres1[3];\n\tu8\ti2add;\n\tu8\tres2[3];\n\tu8\ti2brg;\n\tu8\tres3[3];\n\tu8\ti2com;\n\tu8\tres4[3];\n\tu8\ti2cer;\n\tu8\tres5[3];\n\tu8\ti2cmr;\n};\n\nstruct cpm_i2c {\n\tchar *base;\n\tstruct platform_device *ofdev;\n\tstruct i2c_adapter adap;\n\tuint dp_addr;\n\tint version;  \n\tint irq;\n\tint cp_command;\n\tint freq;\n\tstruct i2c_reg __iomem *i2c_reg;\n\tstruct i2c_ram __iomem *i2c_ram;\n\tu16 i2c_addr;\n\twait_queue_head_t i2c_wait;\n\tcbd_t __iomem *tbase;\n\tcbd_t __iomem *rbase;\n\tu_char *txbuf[CPM_MAXBD];\n\tu_char *rxbuf[CPM_MAXBD];\n\tdma_addr_t txdma[CPM_MAXBD];\n\tdma_addr_t rxdma[CPM_MAXBD];\n};\n\nstatic irqreturn_t cpm_i2c_interrupt(int irq, void *dev_id)\n{\n\tstruct cpm_i2c *cpm;\n\tstruct i2c_reg __iomem *i2c_reg;\n\tstruct i2c_adapter *adap = dev_id;\n\tint i;\n\n\tcpm = i2c_get_adapdata(dev_id);\n\ti2c_reg = cpm->i2c_reg;\n\n\t \n\ti = in_8(&i2c_reg->i2cer);\n\tout_8(&i2c_reg->i2cer, i);\n\n\tdev_dbg(&adap->dev, \"Interrupt: %x\\n\", i);\n\n\twake_up(&cpm->i2c_wait);\n\n\treturn i ? IRQ_HANDLED : IRQ_NONE;\n}\n\nstatic void cpm_reset_i2c_params(struct cpm_i2c *cpm)\n{\n\tstruct i2c_ram __iomem *i2c_ram = cpm->i2c_ram;\n\n\t \n\tout_be16(&i2c_ram->tbase, (u8 __iomem *)cpm->tbase - DPRAM_BASE);\n\tout_be16(&i2c_ram->rbase, (u8 __iomem *)cpm->rbase - DPRAM_BASE);\n\n\tif (cpm->version == 1) {\n\t\tout_8(&i2c_ram->tfcr, I2C_EB);\n\t\tout_8(&i2c_ram->rfcr, I2C_EB);\n\t} else {\n\t\tout_8(&i2c_ram->tfcr, I2C_EB_CPM2);\n\t\tout_8(&i2c_ram->rfcr, I2C_EB_CPM2);\n\t}\n\n\tout_be16(&i2c_ram->mrblr, CPM_MAX_READ);\n\n\tout_be32(&i2c_ram->rstate, 0);\n\tout_be32(&i2c_ram->rdp, 0);\n\tout_be16(&i2c_ram->rbptr, 0);\n\tout_be16(&i2c_ram->rbc, 0);\n\tout_be32(&i2c_ram->rxtmp, 0);\n\tout_be32(&i2c_ram->tstate, 0);\n\tout_be32(&i2c_ram->tdp, 0);\n\tout_be16(&i2c_ram->tbptr, 0);\n\tout_be16(&i2c_ram->tbc, 0);\n\tout_be32(&i2c_ram->txtmp, 0);\n}\n\nstatic void cpm_i2c_force_close(struct i2c_adapter *adap)\n{\n\tstruct cpm_i2c *cpm = i2c_get_adapdata(adap);\n\tstruct i2c_reg __iomem *i2c_reg = cpm->i2c_reg;\n\n\tdev_dbg(&adap->dev, \"cpm_i2c_force_close()\\n\");\n\n\tcpm_command(cpm->cp_command, CPM_CR_CLOSE_RX_BD);\n\n\tout_8(&i2c_reg->i2cmr, 0x00);\t \n\tout_8(&i2c_reg->i2cer, 0xff);\n}\n\nstatic void cpm_i2c_parse_message(struct i2c_adapter *adap,\n\tstruct i2c_msg *pmsg, int num, int tx, int rx)\n{\n\tcbd_t __iomem *tbdf;\n\tcbd_t __iomem *rbdf;\n\tu_char addr;\n\tu_char *tb;\n\tu_char *rb;\n\tstruct cpm_i2c *cpm = i2c_get_adapdata(adap);\n\n\ttbdf = cpm->tbase + tx;\n\trbdf = cpm->rbase + rx;\n\n\taddr = i2c_8bit_addr_from_msg(pmsg);\n\n\ttb = cpm->txbuf[tx];\n\trb = cpm->rxbuf[rx];\n\n\t \n\trb = (u_char *) (((ulong) rb + 1) & ~1);\n\n\ttb[0] = addr;\t\t \n\n\tout_be16(&tbdf->cbd_datlen, pmsg->len + 1);\n\tout_be16(&tbdf->cbd_sc, 0);\n\n\tif (!(pmsg->flags & I2C_M_NOSTART))\n\t\tsetbits16(&tbdf->cbd_sc, BD_I2C_START);\n\n\tif (tx + 1 == num)\n\t\tsetbits16(&tbdf->cbd_sc, BD_SC_LAST | BD_SC_WRAP);\n\n\tif (pmsg->flags & I2C_M_RD) {\n\t\t \n\n\t\tdev_dbg(&adap->dev, \"cpm_i2c_read(abyte=0x%x)\\n\", addr);\n\n\t\tout_be16(&rbdf->cbd_datlen, 0);\n\t\tout_be16(&rbdf->cbd_sc, BD_SC_EMPTY | BD_SC_INTRPT);\n\n\t\tif (rx + 1 == CPM_MAXBD)\n\t\t\tsetbits16(&rbdf->cbd_sc, BD_SC_WRAP);\n\n\t\teieio();\n\t\tsetbits16(&tbdf->cbd_sc, BD_SC_READY);\n\t} else {\n\t\tdev_dbg(&adap->dev, \"cpm_i2c_write(abyte=0x%x)\\n\", addr);\n\n\t\tmemcpy(tb+1, pmsg->buf, pmsg->len);\n\n\t\teieio();\n\t\tsetbits16(&tbdf->cbd_sc, BD_SC_READY | BD_SC_INTRPT);\n\t}\n}\n\nstatic int cpm_i2c_check_message(struct i2c_adapter *adap,\n\tstruct i2c_msg *pmsg, int tx, int rx)\n{\n\tcbd_t __iomem *tbdf;\n\tcbd_t __iomem *rbdf;\n\tu_char *tb;\n\tu_char *rb;\n\tstruct cpm_i2c *cpm = i2c_get_adapdata(adap);\n\n\ttbdf = cpm->tbase + tx;\n\trbdf = cpm->rbase + rx;\n\n\ttb = cpm->txbuf[tx];\n\trb = cpm->rxbuf[rx];\n\n\t \n\trb = (u_char *) (((uint) rb + 1) & ~1);\n\n\teieio();\n\tif (pmsg->flags & I2C_M_RD) {\n\t\tdev_dbg(&adap->dev, \"tx sc 0x%04x, rx sc 0x%04x\\n\",\n\t\t\tin_be16(&tbdf->cbd_sc), in_be16(&rbdf->cbd_sc));\n\n\t\tif (in_be16(&tbdf->cbd_sc) & BD_SC_NAK) {\n\t\t\tdev_dbg(&adap->dev, \"I2C read; No ack\\n\");\n\t\t\treturn -ENXIO;\n\t\t}\n\t\tif (in_be16(&rbdf->cbd_sc) & BD_SC_EMPTY) {\n\t\t\tdev_err(&adap->dev,\n\t\t\t\t\"I2C read; complete but rbuf empty\\n\");\n\t\t\treturn -EREMOTEIO;\n\t\t}\n\t\tif (in_be16(&rbdf->cbd_sc) & BD_SC_OV) {\n\t\t\tdev_err(&adap->dev, \"I2C read; Overrun\\n\");\n\t\t\treturn -EREMOTEIO;\n\t\t}\n\t\tmemcpy(pmsg->buf, rb, pmsg->len);\n\t} else {\n\t\tdev_dbg(&adap->dev, \"tx sc %d 0x%04x\\n\", tx,\n\t\t\tin_be16(&tbdf->cbd_sc));\n\n\t\tif (in_be16(&tbdf->cbd_sc) & BD_SC_NAK) {\n\t\t\tdev_dbg(&adap->dev, \"I2C write; No ack\\n\");\n\t\t\treturn -ENXIO;\n\t\t}\n\t\tif (in_be16(&tbdf->cbd_sc) & BD_SC_UN) {\n\t\t\tdev_err(&adap->dev, \"I2C write; Underrun\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tif (in_be16(&tbdf->cbd_sc) & BD_SC_CL) {\n\t\t\tdev_err(&adap->dev, \"I2C write; Collision\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int cpm_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)\n{\n\tstruct cpm_i2c *cpm = i2c_get_adapdata(adap);\n\tstruct i2c_reg __iomem *i2c_reg = cpm->i2c_reg;\n\tstruct i2c_ram __iomem *i2c_ram = cpm->i2c_ram;\n\tstruct i2c_msg *pmsg;\n\tint ret;\n\tint tptr;\n\tint rptr;\n\tcbd_t __iomem *tbdf;\n\tcbd_t __iomem *rbdf;\n\n\t \n\tout_be16(&i2c_ram->rbptr, in_be16(&i2c_ram->rbase));\n\tout_be16(&i2c_ram->tbptr, in_be16(&i2c_ram->tbase));\n\n\ttbdf = cpm->tbase;\n\trbdf = cpm->rbase;\n\n\ttptr = 0;\n\trptr = 0;\n\n\t \n\tif (in_be16(&tbdf->cbd_sc) & BD_SC_CL) {\n\t\tout_8(&cpm->i2c_reg->i2com, I2COM_MASTER);\n\t}\n\n\twhile (tptr < num) {\n\t\tpmsg = &msgs[tptr];\n\t\tdev_dbg(&adap->dev, \"R: %d T: %d\\n\", rptr, tptr);\n\n\t\tcpm_i2c_parse_message(adap, pmsg, num, tptr, rptr);\n\t\tif (pmsg->flags & I2C_M_RD)\n\t\t\trptr++;\n\t\ttptr++;\n\t}\n\t \n\t \n\tout_8(&i2c_reg->i2cmr, I2CER_TXE | I2CER_TXB | I2CER_RXB);\n\tout_8(&i2c_reg->i2cer, 0xff);\t \n\t \n\tsetbits8(&i2c_reg->i2mod, I2MOD_EN);\t \n\t \n\tsetbits8(&i2c_reg->i2com, I2COM_START);\n\n\ttptr = 0;\n\trptr = 0;\n\n\twhile (tptr < num) {\n\t\t \n\t\tdev_dbg(&adap->dev, \"test ready.\\n\");\n\t\tpmsg = &msgs[tptr];\n\t\tif (pmsg->flags & I2C_M_RD)\n\t\t\tret = wait_event_timeout(cpm->i2c_wait,\n\t\t\t\t(in_be16(&tbdf[tptr].cbd_sc) & BD_SC_NAK) ||\n\t\t\t\t!(in_be16(&rbdf[rptr].cbd_sc) & BD_SC_EMPTY),\n\t\t\t\t1 * HZ);\n\t\telse\n\t\t\tret = wait_event_timeout(cpm->i2c_wait,\n\t\t\t\t!(in_be16(&tbdf[tptr].cbd_sc) & BD_SC_READY),\n\t\t\t\t1 * HZ);\n\t\tif (ret == 0) {\n\t\t\tret = -EREMOTEIO;\n\t\t\tdev_err(&adap->dev, \"I2C transfer: timeout\\n\");\n\t\t\tgoto out_err;\n\t\t}\n\t\tif (ret > 0) {\n\t\t\tdev_dbg(&adap->dev, \"ready.\\n\");\n\t\t\tret = cpm_i2c_check_message(adap, pmsg, tptr, rptr);\n\t\t\ttptr++;\n\t\t\tif (pmsg->flags & I2C_M_RD)\n\t\t\t\trptr++;\n\t\t\tif (ret)\n\t\t\t\tgoto out_err;\n\t\t}\n\t}\n#ifdef I2C_CHIP_ERRATA\n\t \n\tudelay(4);\n\tclrbits8(&i2c_reg->i2mod, I2MOD_EN);\n#endif\n\treturn (num);\n\nout_err:\n\tcpm_i2c_force_close(adap);\n#ifdef I2C_CHIP_ERRATA\n\t \n\tclrbits8(&i2c_reg->i2mod, I2MOD_EN);\n#endif\n\treturn ret;\n}\n\nstatic u32 cpm_i2c_func(struct i2c_adapter *adap)\n{\n\treturn I2C_FUNC_I2C | (I2C_FUNC_SMBUS_EMUL & ~I2C_FUNC_SMBUS_QUICK);\n}\n\n \n\nstatic const struct i2c_algorithm cpm_i2c_algo = {\n\t.master_xfer = cpm_i2c_xfer,\n\t.functionality = cpm_i2c_func,\n};\n\n \nstatic const struct i2c_adapter_quirks cpm_i2c_quirks = {\n\t.max_num_msgs = CPM_MAXBD,\n\t.max_read_len = CPM_MAX_READ,\n\t.max_write_len = CPM_MAX_READ,\n};\n\nstatic const struct i2c_adapter cpm_ops = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"i2c-cpm\",\n\t.algo\t\t= &cpm_i2c_algo,\n\t.quirks\t\t= &cpm_i2c_quirks,\n};\n\nstatic int cpm_i2c_setup(struct cpm_i2c *cpm)\n{\n\tstruct platform_device *ofdev = cpm->ofdev;\n\tconst u32 *data;\n\tint len, ret, i;\n\tvoid __iomem *i2c_base;\n\tcbd_t __iomem *tbdf;\n\tcbd_t __iomem *rbdf;\n\tunsigned char brg;\n\n\tdev_dbg(&cpm->ofdev->dev, \"cpm_i2c_setup()\\n\");\n\n\tinit_waitqueue_head(&cpm->i2c_wait);\n\n\tcpm->irq = irq_of_parse_and_map(ofdev->dev.of_node, 0);\n\tif (!cpm->irq)\n\t\treturn -EINVAL;\n\n\t \n\tret = request_irq(cpm->irq, cpm_i2c_interrupt, 0, \"cpm_i2c\",\n\t\t\t  &cpm->adap);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\ti2c_base = of_iomap(ofdev->dev.of_node, 1);\n\tif (i2c_base == NULL) {\n\t\tret = -EINVAL;\n\t\tgoto out_irq;\n\t}\n\n\tif (of_device_is_compatible(ofdev->dev.of_node, \"fsl,cpm1-i2c\")) {\n\n\t\t \n\t\tcpm->i2c_ram = i2c_base;\n\t\tcpm->i2c_addr = in_be16(&cpm->i2c_ram->rpbase);\n\n\t\t \n\t\tif (cpm->i2c_addr) {\n\t\t\tcpm->i2c_ram = cpm_muram_addr(cpm->i2c_addr);\n\t\t\tiounmap(i2c_base);\n\t\t}\n\n\t\tcpm->version = 1;\n\n\t} else if (of_device_is_compatible(ofdev->dev.of_node, \"fsl,cpm2-i2c\")) {\n\t\tcpm->i2c_addr = cpm_muram_alloc(sizeof(struct i2c_ram), 64);\n\t\tcpm->i2c_ram = cpm_muram_addr(cpm->i2c_addr);\n\t\tout_be16(i2c_base, cpm->i2c_addr);\n\t\tiounmap(i2c_base);\n\n\t\tcpm->version = 2;\n\n\t} else {\n\t\tiounmap(i2c_base);\n\t\tret = -EINVAL;\n\t\tgoto out_irq;\n\t}\n\n\t \n\tcpm->i2c_reg = of_iomap(ofdev->dev.of_node, 0);\n\tif (cpm->i2c_reg == NULL) {\n\t\tret = -EINVAL;\n\t\tgoto out_ram;\n\t}\n\n\tdata = of_get_property(ofdev->dev.of_node, \"fsl,cpm-command\", &len);\n\tif (!data || len != 4) {\n\t\tret = -EINVAL;\n\t\tgoto out_reg;\n\t}\n\tcpm->cp_command = *data;\n\n\tdata = of_get_property(ofdev->dev.of_node, \"linux,i2c-class\", &len);\n\tif (data && len == 4)\n\t\tcpm->adap.class = *data;\n\n\tdata = of_get_property(ofdev->dev.of_node, \"clock-frequency\", &len);\n\tif (data && len == 4)\n\t\tcpm->freq = *data;\n\telse\n\t\tcpm->freq = 60000;  \n\n\t \n\tcpm->dp_addr = cpm_muram_alloc(sizeof(cbd_t) * 2 * CPM_MAXBD, 8);\n\tif (!cpm->dp_addr) {\n\t\tret = -ENOMEM;\n\t\tgoto out_reg;\n\t}\n\n\tcpm->tbase = cpm_muram_addr(cpm->dp_addr);\n\tcpm->rbase = cpm_muram_addr(cpm->dp_addr + sizeof(cbd_t) * CPM_MAXBD);\n\n\t \n\n\ttbdf = cpm->tbase;\n\trbdf = cpm->rbase;\n\n\tfor (i = 0; i < CPM_MAXBD; i++) {\n\t\tcpm->rxbuf[i] = dma_alloc_coherent(&cpm->ofdev->dev,\n\t\t\t\t\t\t   CPM_MAX_READ + 1,\n\t\t\t\t\t\t   &cpm->rxdma[i], GFP_KERNEL);\n\t\tif (!cpm->rxbuf[i]) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out_muram;\n\t\t}\n\t\tout_be32(&rbdf[i].cbd_bufaddr, ((cpm->rxdma[i] + 1) & ~1));\n\n\t\tcpm->txbuf[i] = dma_alloc_coherent(&cpm->ofdev->dev,\n\t\t\t\t\t\t   CPM_MAX_READ + 1,\n\t\t\t\t\t\t   &cpm->txdma[i], GFP_KERNEL);\n\t\tif (!cpm->txbuf[i]) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out_muram;\n\t\t}\n\t\tout_be32(&tbdf[i].cbd_bufaddr, cpm->txdma[i]);\n\t}\n\n\t \n\n\tcpm_reset_i2c_params(cpm);\n\n\tdev_dbg(&cpm->ofdev->dev, \"i2c_ram 0x%p, i2c_addr 0x%04x, freq %d\\n\",\n\t\tcpm->i2c_ram, cpm->i2c_addr, cpm->freq);\n\tdev_dbg(&cpm->ofdev->dev, \"tbase 0x%04x, rbase 0x%04x\\n\",\n\t\t(u8 __iomem *)cpm->tbase - DPRAM_BASE,\n\t\t(u8 __iomem *)cpm->rbase - DPRAM_BASE);\n\n\tcpm_command(cpm->cp_command, CPM_CR_INIT_TRX);\n\n\t \n\tout_8(&cpm->i2c_reg->i2add, 0x7f << 1);\n\n\t \n\tbrg = get_brgfreq() / (32 * 2 * cpm->freq) - 3;\n\tout_8(&cpm->i2c_reg->i2brg, brg);\n\n\tout_8(&cpm->i2c_reg->i2mod, 0x00);\n\tout_8(&cpm->i2c_reg->i2com, I2COM_MASTER);\t \n\n\t \n\tout_8(&cpm->i2c_reg->i2cmr, 0);\n\tout_8(&cpm->i2c_reg->i2cer, 0xff);\n\n\treturn 0;\n\nout_muram:\n\tfor (i = 0; i < CPM_MAXBD; i++) {\n\t\tif (cpm->rxbuf[i])\n\t\t\tdma_free_coherent(&cpm->ofdev->dev, CPM_MAX_READ + 1,\n\t\t\t\tcpm->rxbuf[i], cpm->rxdma[i]);\n\t\tif (cpm->txbuf[i])\n\t\t\tdma_free_coherent(&cpm->ofdev->dev, CPM_MAX_READ + 1,\n\t\t\t\tcpm->txbuf[i], cpm->txdma[i]);\n\t}\n\tcpm_muram_free(cpm->dp_addr);\nout_reg:\n\tiounmap(cpm->i2c_reg);\nout_ram:\n\tif ((cpm->version == 1) && (!cpm->i2c_addr))\n\t\tiounmap(cpm->i2c_ram);\n\tif (cpm->version == 2)\n\t\tcpm_muram_free(cpm->i2c_addr);\nout_irq:\n\tfree_irq(cpm->irq, &cpm->adap);\n\treturn ret;\n}\n\nstatic void cpm_i2c_shutdown(struct cpm_i2c *cpm)\n{\n\tint i;\n\n\t \n\tclrbits8(&cpm->i2c_reg->i2mod, I2MOD_EN);\n\n\t \n\tout_8(&cpm->i2c_reg->i2cmr, 0);\n\tout_8(&cpm->i2c_reg->i2cer, 0xff);\n\n\tfree_irq(cpm->irq, &cpm->adap);\n\n\t \n\tfor (i = 0; i < CPM_MAXBD; i++) {\n\t\tdma_free_coherent(&cpm->ofdev->dev, CPM_MAX_READ + 1,\n\t\t\tcpm->rxbuf[i], cpm->rxdma[i]);\n\t\tdma_free_coherent(&cpm->ofdev->dev, CPM_MAX_READ + 1,\n\t\t\tcpm->txbuf[i], cpm->txdma[i]);\n\t}\n\n\tcpm_muram_free(cpm->dp_addr);\n\tiounmap(cpm->i2c_reg);\n\n\tif ((cpm->version == 1) && (!cpm->i2c_addr))\n\t\tiounmap(cpm->i2c_ram);\n\tif (cpm->version == 2)\n\t\tcpm_muram_free(cpm->i2c_addr);\n}\n\nstatic int cpm_i2c_probe(struct platform_device *ofdev)\n{\n\tint result, len;\n\tstruct cpm_i2c *cpm;\n\tconst u32 *data;\n\n\tcpm = kzalloc(sizeof(struct cpm_i2c), GFP_KERNEL);\n\tif (!cpm)\n\t\treturn -ENOMEM;\n\n\tcpm->ofdev = ofdev;\n\n\tplatform_set_drvdata(ofdev, cpm);\n\n\tcpm->adap = cpm_ops;\n\ti2c_set_adapdata(&cpm->adap, cpm);\n\tcpm->adap.dev.parent = &ofdev->dev;\n\tcpm->adap.dev.of_node = of_node_get(ofdev->dev.of_node);\n\n\tresult = cpm_i2c_setup(cpm);\n\tif (result) {\n\t\tdev_err(&ofdev->dev, \"Unable to init hardware\\n\");\n\t\tgoto out_free;\n\t}\n\n\t \n\n\tdata = of_get_property(ofdev->dev.of_node, \"linux,i2c-index\", &len);\n\tcpm->adap.nr = (data && len == 4) ? be32_to_cpup(data) : -1;\n\tresult = i2c_add_numbered_adapter(&cpm->adap);\n\n\tif (result < 0)\n\t\tgoto out_shut;\n\n\tdev_dbg(&ofdev->dev, \"hw routines for %s registered.\\n\",\n\t\tcpm->adap.name);\n\n\treturn 0;\nout_shut:\n\tcpm_i2c_shutdown(cpm);\nout_free:\n\tkfree(cpm);\n\n\treturn result;\n}\n\nstatic void cpm_i2c_remove(struct platform_device *ofdev)\n{\n\tstruct cpm_i2c *cpm = platform_get_drvdata(ofdev);\n\n\ti2c_del_adapter(&cpm->adap);\n\n\tcpm_i2c_shutdown(cpm);\n\n\tkfree(cpm);\n}\n\nstatic const struct of_device_id cpm_i2c_match[] = {\n\t{\n\t\t.compatible = \"fsl,cpm1-i2c\",\n\t},\n\t{\n\t\t.compatible = \"fsl,cpm2-i2c\",\n\t},\n\t{},\n};\n\nMODULE_DEVICE_TABLE(of, cpm_i2c_match);\n\nstatic struct platform_driver cpm_i2c_driver = {\n\t.probe\t\t= cpm_i2c_probe,\n\t.remove_new\t= cpm_i2c_remove,\n\t.driver = {\n\t\t.name = \"fsl-i2c-cpm\",\n\t\t.of_match_table = cpm_i2c_match,\n\t},\n};\n\nmodule_platform_driver(cpm_i2c_driver);\n\nMODULE_AUTHOR(\"Jochen Friedrich <jochen@scram.de>\");\nMODULE_DESCRIPTION(\"I2C-Bus adapter routines for CPM boards\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}