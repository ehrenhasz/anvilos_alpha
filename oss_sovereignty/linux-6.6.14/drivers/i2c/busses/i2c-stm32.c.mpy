{
  "module_name": "i2c-stm32.c",
  "hash_id": "04b2f758963e40db9aa0e90074cbe987127395acc7944ab94cf24f518c9d2e06",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-stm32.c",
  "human_readable_source": "\n \n\n#include \"i2c-stm32.h\"\n\n \nstruct stm32_i2c_dma *stm32_i2c_dma_request(struct device *dev,\n\t\t\t\t\t    dma_addr_t phy_addr,\n\t\t\t\t\t    u32 txdr_offset,\n\t\t\t\t\t    u32 rxdr_offset)\n{\n\tstruct stm32_i2c_dma *dma;\n\tstruct dma_slave_config dma_sconfig;\n\tint ret;\n\n\tdma = devm_kzalloc(dev, sizeof(*dma), GFP_KERNEL);\n\tif (!dma)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t \n\tdma->chan_tx = dma_request_chan(dev, \"tx\");\n\tif (IS_ERR(dma->chan_tx)) {\n\t\tret = PTR_ERR(dma->chan_tx);\n\t\tif (ret != -ENODEV)\n\t\t\tret = dev_err_probe(dev, ret,\n\t\t\t\t\t    \"can't request DMA tx channel\\n\");\n\t\tgoto fail_al;\n\t}\n\n\tmemset(&dma_sconfig, 0, sizeof(dma_sconfig));\n\tdma_sconfig.dst_addr = phy_addr + txdr_offset;\n\tdma_sconfig.dst_addr_width = DMA_SLAVE_BUSWIDTH_1_BYTE;\n\tdma_sconfig.dst_maxburst = 1;\n\tdma_sconfig.direction = DMA_MEM_TO_DEV;\n\tret = dmaengine_slave_config(dma->chan_tx, &dma_sconfig);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"can't configure tx channel\\n\");\n\t\tgoto fail_tx;\n\t}\n\n\t \n\tdma->chan_rx = dma_request_chan(dev, \"rx\");\n\tif (IS_ERR(dma->chan_rx)) {\n\t\tret = PTR_ERR(dma->chan_rx);\n\t\tif (ret != -ENODEV)\n\t\t\tret = dev_err_probe(dev, ret,\n\t\t\t\t\t    \"can't request DMA rx channel\\n\");\n\n\t\tgoto fail_tx;\n\t}\n\n\tmemset(&dma_sconfig, 0, sizeof(dma_sconfig));\n\tdma_sconfig.src_addr = phy_addr + rxdr_offset;\n\tdma_sconfig.src_addr_width = DMA_SLAVE_BUSWIDTH_1_BYTE;\n\tdma_sconfig.src_maxburst = 1;\n\tdma_sconfig.direction = DMA_DEV_TO_MEM;\n\tret = dmaengine_slave_config(dma->chan_rx, &dma_sconfig);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"can't configure rx channel\\n\");\n\t\tgoto fail_rx;\n\t}\n\n\tinit_completion(&dma->dma_complete);\n\n\tdev_info(dev, \"using %s (tx) and %s (rx) for DMA transfers\\n\",\n\t\t dma_chan_name(dma->chan_tx), dma_chan_name(dma->chan_rx));\n\n\treturn dma;\n\nfail_rx:\n\tdma_release_channel(dma->chan_rx);\nfail_tx:\n\tdma_release_channel(dma->chan_tx);\nfail_al:\n\tdevm_kfree(dev, dma);\n\n\treturn ERR_PTR(ret);\n}\n\nvoid stm32_i2c_dma_free(struct stm32_i2c_dma *dma)\n{\n\tdma->dma_buf = 0;\n\tdma->dma_len = 0;\n\n\tdma_release_channel(dma->chan_tx);\n\tdma->chan_tx = NULL;\n\n\tdma_release_channel(dma->chan_rx);\n\tdma->chan_rx = NULL;\n\n\tdma->chan_using = NULL;\n}\n\nint stm32_i2c_prep_dma_xfer(struct device *dev, struct stm32_i2c_dma *dma,\n\t\t\t    bool rd_wr, u32 len, u8 *buf,\n\t\t\t    dma_async_tx_callback callback,\n\t\t\t    void *dma_async_param)\n{\n\tstruct dma_async_tx_descriptor *txdesc;\n\tstruct device *chan_dev;\n\tint ret;\n\n\tif (rd_wr) {\n\t\tdma->chan_using = dma->chan_rx;\n\t\tdma->dma_transfer_dir = DMA_DEV_TO_MEM;\n\t\tdma->dma_data_dir = DMA_FROM_DEVICE;\n\t} else {\n\t\tdma->chan_using = dma->chan_tx;\n\t\tdma->dma_transfer_dir = DMA_MEM_TO_DEV;\n\t\tdma->dma_data_dir = DMA_TO_DEVICE;\n\t}\n\n\tdma->dma_len = len;\n\tchan_dev = dma->chan_using->device->dev;\n\n\tdma->dma_buf = dma_map_single(chan_dev, buf, dma->dma_len,\n\t\t\t\t      dma->dma_data_dir);\n\tif (dma_mapping_error(chan_dev, dma->dma_buf)) {\n\t\tdev_err(dev, \"DMA mapping failed\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\ttxdesc = dmaengine_prep_slave_single(dma->chan_using, dma->dma_buf,\n\t\t\t\t\t     dma->dma_len,\n\t\t\t\t\t     dma->dma_transfer_dir,\n\t\t\t\t\t     DMA_PREP_INTERRUPT);\n\tif (!txdesc) {\n\t\tdev_err(dev, \"Not able to get desc for DMA xfer\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\treinit_completion(&dma->dma_complete);\n\n\ttxdesc->callback = callback;\n\ttxdesc->callback_param = dma_async_param;\n\tret = dma_submit_error(dmaengine_submit(txdesc));\n\tif (ret < 0) {\n\t\tdev_err(dev, \"DMA submit failed\\n\");\n\t\tgoto err;\n\t}\n\n\tdma_async_issue_pending(dma->chan_using);\n\n\treturn 0;\n\nerr:\n\tdma_unmap_single(chan_dev, dma->dma_buf, dma->dma_len,\n\t\t\t dma->dma_data_dir);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}