{
  "module_name": "i2c-cp2615.c",
  "hash_id": "bbc2da31f6e80991ee50b60f02b0a50abd8b6362450f395342c1a4de0eae3f28",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-cp2615.c",
  "human_readable_source": "\n \n\n#include <linux/errno.h>\n#include <linux/i2c.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/usb.h>\n\n \n\n#define CP2615_VID 0x10c4\n#define CP2615_PID 0xeac1\n\n#define IOP_EP_IN  0x82\n#define IOP_EP_OUT 0x02\n#define IOP_IFN 1\n#define IOP_ALTSETTING 2\n\n#define MAX_IOP_SIZE 64\n#define MAX_IOP_PAYLOAD_SIZE (MAX_IOP_SIZE - 6)\n#define MAX_I2C_SIZE (MAX_IOP_PAYLOAD_SIZE - 4)\n\nenum cp2615_iop_msg_type {\n\tiop_GetAccessoryInfo = 0xD100,\n\tiop_AccessoryInfo = 0xA100,\n\tiop_GetPortConfiguration = 0xD203,\n\tiop_PortConfiguration = 0xA203,\n\tiop_DoI2cTransfer = 0xD400,\n\tiop_I2cTransferResult = 0xA400,\n\tiop_GetSerialState = 0xD501,\n\tiop_SerialState = 0xA501\n};\n\nstruct __packed cp2615_iop_msg {\n\t__be16 preamble, length, msg;\n\tu8 data[MAX_IOP_PAYLOAD_SIZE];\n};\n\n#define PART_ID_A01 0x1400\n#define PART_ID_A02 0x1500\n\nstruct __packed cp2615_iop_accessory_info {\n\t__be16 part_id, option_id, proto_ver;\n};\n\nstruct __packed cp2615_i2c_transfer {\n\tu8 tag, i2caddr, read_len, write_len;\n\tu8 data[MAX_I2C_SIZE];\n};\n\n \nenum cp2615_i2c_status {\n\t \n\tCP2615_CFG_LOCKED = -6,\n\t \n\tCP2615_INVALID_PARAM = -4,\n\t \n\tCP2615_TIMEOUT,\n\t \n\tCP2615_BUS_BUSY,\n\t \n\tCP2615_BUS_ERROR,\n\tCP2615_SUCCESS\n};\n\nstruct __packed cp2615_i2c_transfer_result {\n\tu8 tag, i2caddr;\n\ts8 status;\n\tu8 read_len;\n\tu8 data[MAX_I2C_SIZE];\n};\n\nstatic int cp2615_init_iop_msg(struct cp2615_iop_msg *ret, enum cp2615_iop_msg_type msg,\n\t\t\tconst void *data, size_t data_len)\n{\n\tif (data_len > MAX_IOP_PAYLOAD_SIZE)\n\t\treturn -EFBIG;\n\n\tif (!ret)\n\t\treturn -EINVAL;\n\n\tret->preamble = 0x2A2A;\n\tret->length = htons(data_len + 6);\n\tret->msg = htons(msg);\n\tif (data && data_len)\n\t\tmemcpy(&ret->data, data, data_len);\n\treturn 0;\n}\n\nstatic int cp2615_init_i2c_msg(struct cp2615_iop_msg *ret, const struct cp2615_i2c_transfer *data)\n{\n\treturn cp2615_init_iop_msg(ret, iop_DoI2cTransfer, data, 4 + data->write_len);\n}\n\n \nstatic int cp2615_check_status(enum cp2615_i2c_status status)\n{\n\tswitch (status) {\n\tcase CP2615_SUCCESS:\n\t\t\treturn 0;\n\tcase CP2615_BUS_ERROR:\n\t\treturn -ENXIO;\n\tcase CP2615_BUS_BUSY:\n\t\treturn -EAGAIN;\n\tcase CP2615_TIMEOUT:\n\t\treturn -ETIMEDOUT;\n\tcase CP2615_INVALID_PARAM:\n\t\treturn -EINVAL;\n\tcase CP2615_CFG_LOCKED:\n\t\treturn -EPERM;\n\t}\n\t \n\treturn -EPROTO;\n}\n\n \n\nstatic int\ncp2615_i2c_send(struct usb_interface *usbif, struct cp2615_i2c_transfer *i2c_w)\n{\n\tstruct cp2615_iop_msg *msg = kzalloc(sizeof(*msg), GFP_KERNEL);\n\tstruct usb_device *usbdev = interface_to_usbdev(usbif);\n\tint res = cp2615_init_i2c_msg(msg, i2c_w);\n\n\tif (!res)\n\t\tres = usb_bulk_msg(usbdev, usb_sndbulkpipe(usbdev, IOP_EP_OUT),\n\t\t\t\t   msg, ntohs(msg->length), NULL, 0);\n\tkfree(msg);\n\treturn res;\n}\n\nstatic int\ncp2615_i2c_recv(struct usb_interface *usbif, unsigned char tag, void *buf)\n{\n\tstruct usb_device *usbdev = interface_to_usbdev(usbif);\n\tstruct cp2615_iop_msg *msg;\n\tstruct cp2615_i2c_transfer_result *i2c_r;\n\tint res;\n\n\tmsg = kzalloc(sizeof(*msg), GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\tres = usb_bulk_msg(usbdev, usb_rcvbulkpipe(usbdev, IOP_EP_IN), msg,\n\t\t\t   sizeof(struct cp2615_iop_msg), NULL, 0);\n\tif (res < 0) {\n\t\tkfree(msg);\n\t\treturn res;\n\t}\n\n\ti2c_r = (struct cp2615_i2c_transfer_result *)&msg->data;\n\tif (msg->msg != htons(iop_I2cTransferResult) || i2c_r->tag != tag) {\n\t\tkfree(msg);\n\t\treturn -EIO;\n\t}\n\n\tres = cp2615_check_status(i2c_r->status);\n\tif (!res)\n\t\tmemcpy(buf, &i2c_r->data, i2c_r->read_len);\n\n\tkfree(msg);\n\treturn res;\n}\n\n \nstatic int cp2615_check_iop(struct usb_interface *usbif)\n{\n\tstruct cp2615_iop_msg *msg = kzalloc(sizeof(*msg), GFP_KERNEL);\n\tstruct cp2615_iop_accessory_info *info = (struct cp2615_iop_accessory_info *)&msg->data;\n\tstruct usb_device *usbdev = interface_to_usbdev(usbif);\n\tint res = cp2615_init_iop_msg(msg, iop_GetAccessoryInfo, NULL, 0);\n\n\tif (res)\n\t\tgoto out;\n\n\tres = usb_bulk_msg(usbdev, usb_sndbulkpipe(usbdev, IOP_EP_OUT),\n\t\t\t\t   msg, ntohs(msg->length), NULL, 0);\n\tif (res)\n\t\tgoto out;\n\n\tres = usb_bulk_msg(usbdev, usb_rcvbulkpipe(usbdev, IOP_EP_IN),\n\t\t\t       msg, sizeof(struct cp2615_iop_msg), NULL, 0);\n\tif (res)\n\t\tgoto out;\n\n\tif (msg->msg != htons(iop_AccessoryInfo)) {\n\t\tres = -EIO;\n\t\tgoto out;\n\t}\n\n\tswitch (ntohs(info->part_id)) {\n\tcase PART_ID_A01:\n\t\tdev_dbg(&usbif->dev, \"Found A01 part. (WARNING: errata exists!)\\n\");\n\t\tbreak;\n\tcase PART_ID_A02:\n\t\tdev_dbg(&usbif->dev, \"Found good A02 part.\\n\");\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(&usbif->dev, \"Unknown part ID %04X\\n\", ntohs(info->part_id));\n\t}\n\nout:\n\tkfree(msg);\n\treturn res;\n}\n\nstatic int\ncp2615_i2c_master_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)\n{\n\tstruct usb_interface *usbif = adap->algo_data;\n\tint i = 0, ret = 0;\n\tstruct i2c_msg *msg;\n\tstruct cp2615_i2c_transfer i2c_w = {0};\n\n\tdev_dbg(&usbif->dev, \"Doing %d I2C transactions\\n\", num);\n\n\tfor (; !ret && i < num; i++) {\n\t\tmsg = &msgs[i];\n\n\t\ti2c_w.tag = 0xdd;\n\t\ti2c_w.i2caddr = i2c_8bit_addr_from_msg(msg);\n\t\tif (msg->flags & I2C_M_RD) {\n\t\t\ti2c_w.read_len = msg->len;\n\t\t\ti2c_w.write_len = 0;\n\t\t} else {\n\t\t\ti2c_w.read_len = 0;\n\t\t\ti2c_w.write_len = msg->len;\n\t\t\tmemcpy(&i2c_w.data, msg->buf, i2c_w.write_len);\n\t\t}\n\t\tret = cp2615_i2c_send(usbif, &i2c_w);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tret = cp2615_i2c_recv(usbif, i2c_w.tag, msg->buf);\n\t}\n\tif (ret < 0)\n\t\treturn ret;\n\treturn i;\n}\n\nstatic u32\ncp2615_i2c_func(struct i2c_adapter *adap)\n{\n\treturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;\n}\n\nstatic const struct i2c_algorithm cp2615_i2c_algo = {\n\t.master_xfer\t= cp2615_i2c_master_xfer,\n\t.functionality\t= cp2615_i2c_func,\n};\n\n \nstatic struct i2c_adapter_quirks cp2615_i2c_quirks = {\n\t.max_write_len = MAX_I2C_SIZE,\n\t.max_read_len = MAX_I2C_SIZE,\n\t.flags = I2C_AQ_COMB_WRITE_THEN_READ | I2C_AQ_NO_ZERO_LEN | I2C_AQ_NO_REP_START,\n\t.max_comb_1st_msg_len = MAX_I2C_SIZE,\n\t.max_comb_2nd_msg_len = MAX_I2C_SIZE\n};\n\nstatic void\ncp2615_i2c_remove(struct usb_interface *usbif)\n{\n\tstruct i2c_adapter *adap = usb_get_intfdata(usbif);\n\n\tusb_set_intfdata(usbif, NULL);\n\ti2c_del_adapter(adap);\n}\n\nstatic int\ncp2615_i2c_probe(struct usb_interface *usbif, const struct usb_device_id *id)\n{\n\tint ret = 0;\n\tstruct i2c_adapter *adap;\n\tstruct usb_device *usbdev = interface_to_usbdev(usbif);\n\n\tret = usb_set_interface(usbdev, IOP_IFN, IOP_ALTSETTING);\n\tif (ret)\n\t\treturn ret;\n\n\tret = cp2615_check_iop(usbif);\n\tif (ret)\n\t\treturn ret;\n\n\tadap = devm_kzalloc(&usbif->dev, sizeof(struct i2c_adapter), GFP_KERNEL);\n\tif (!adap)\n\t\treturn -ENOMEM;\n\n\tstrncpy(adap->name, usbdev->serial, sizeof(adap->name) - 1);\n\tadap->owner = THIS_MODULE;\n\tadap->dev.parent = &usbif->dev;\n\tadap->dev.of_node = usbif->dev.of_node;\n\tadap->timeout = HZ;\n\tadap->algo = &cp2615_i2c_algo;\n\tadap->quirks = &cp2615_i2c_quirks;\n\tadap->algo_data = usbif;\n\n\tret = i2c_add_adapter(adap);\n\tif (ret)\n\t\treturn ret;\n\n\tusb_set_intfdata(usbif, adap);\n\treturn 0;\n}\n\nstatic const struct usb_device_id id_table[] = {\n\t{ USB_DEVICE_INTERFACE_NUMBER(CP2615_VID, CP2615_PID, IOP_IFN) },\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(usb, id_table);\n\nstatic struct usb_driver cp2615_i2c_driver = {\n\t.name = \"i2c-cp2615\",\n\t.probe = cp2615_i2c_probe,\n\t.disconnect = cp2615_i2c_remove,\n\t.id_table = id_table,\n};\n\nmodule_usb_driver(cp2615_i2c_driver);\n\nMODULE_AUTHOR(\"Bence Cs\u00f3k\u00e1s <bence98@sch.bme.hu>\");\nMODULE_DESCRIPTION(\"CP2615 I2C bus driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}