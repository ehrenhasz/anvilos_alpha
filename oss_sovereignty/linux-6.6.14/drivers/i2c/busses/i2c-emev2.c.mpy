{
  "module_name": "i2c-emev2.c",
  "hash_id": "8455b6ead0f0b166af88528bed1c6263fe4bfe689f1d5729f03eb67fc58080ec",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-emev2.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/completion.h>\n#include <linux/device.h>\n#include <linux/i2c.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/sched.h>\n\n \n#define I2C_OFS_IICACT0\t\t0x00\t \n#define I2C_OFS_IIC0\t\t0x04\t \n#define I2C_OFS_IICC0\t\t0x08\t \n#define I2C_OFS_SVA0\t\t0x0c\t \n#define I2C_OFS_IICCL0\t\t0x10\t \n#define I2C_OFS_IICX0\t\t0x14\t \n#define I2C_OFS_IICS0\t\t0x18\t \n#define I2C_OFS_IICSE0\t\t0x1c\t \n#define I2C_OFS_IICF0\t\t0x20\t \n\n \n#define I2C_BIT_IICE0\t\t0x0001\n\n \n#define I2C_BIT_LREL0\t\t0x0040\n#define I2C_BIT_WREL0\t\t0x0020\n#define I2C_BIT_SPIE0\t\t0x0010\n#define I2C_BIT_WTIM0\t\t0x0008\n#define I2C_BIT_ACKE0\t\t0x0004\n#define I2C_BIT_STT0\t\t0x0002\n#define I2C_BIT_SPT0\t\t0x0001\n\n \n#define I2C_BIT_SMC0\t\t0x0008\n#define I2C_BIT_DFC0\t\t0x0004\n\n \n#define I2C_BIT_MSTS0\t\t0x0080\n#define I2C_BIT_ALD0\t\t0x0040\n#define I2C_BIT_EXC0\t\t0x0020\n#define I2C_BIT_COI0\t\t0x0010\n#define I2C_BIT_TRC0\t\t0x0008\n#define I2C_BIT_ACKD0\t\t0x0004\n#define I2C_BIT_STD0\t\t0x0002\n#define I2C_BIT_SPD0\t\t0x0001\n\n \n#define I2C_BIT_STCF\t\t0x0080\n#define I2C_BIT_IICBSY\t\t0x0040\n#define I2C_BIT_STCEN\t\t0x0002\n#define I2C_BIT_IICRSV\t\t0x0001\n\nstruct em_i2c_device {\n\tvoid __iomem *base;\n\tstruct i2c_adapter adap;\n\tstruct completion msg_done;\n\tstruct clk *sclk;\n\tstruct i2c_client *slave;\n\tint irq;\n};\n\nstatic inline void em_clear_set_bit(struct em_i2c_device *priv, u8 clear, u8 set, u8 reg)\n{\n\twriteb((readb(priv->base + reg) & ~clear) | set, priv->base + reg);\n}\n\nstatic int em_i2c_wait_for_event(struct em_i2c_device *priv)\n{\n\tunsigned long time_left;\n\tint status;\n\n\treinit_completion(&priv->msg_done);\n\n\ttime_left = wait_for_completion_timeout(&priv->msg_done, priv->adap.timeout);\n\n\tif (!time_left)\n\t\treturn -ETIMEDOUT;\n\n\tstatus = readb(priv->base + I2C_OFS_IICSE0);\n\treturn status & I2C_BIT_ALD0 ? -EAGAIN : status;\n}\n\nstatic void em_i2c_stop(struct em_i2c_device *priv)\n{\n\t \n\tem_clear_set_bit(priv, 0, I2C_BIT_SPT0 | I2C_BIT_SPIE0, I2C_OFS_IICC0);\n\n\t \n\tem_i2c_wait_for_event(priv);\n}\n\nstatic void em_i2c_reset(struct i2c_adapter *adap)\n{\n\tstruct em_i2c_device *priv = i2c_get_adapdata(adap);\n\tint retr;\n\n\t \n\tif (readb(priv->base + I2C_OFS_IICACT0) & I2C_BIT_IICE0) {\n\t\t \n\t\twriteb(0, priv->base + I2C_OFS_IICACT0);\n\n\t\tretr = 1000;\n\t\twhile (readb(priv->base + I2C_OFS_IICACT0) == 1 && retr)\n\t\t\tretr--;\n\t\tWARN_ON(retr == 0);\n\t}\n\n\t \n\twriteb(I2C_BIT_DFC0, priv->base + I2C_OFS_IICCL0);\n\n\t \n\twriteb(I2C_BIT_STCEN | I2C_BIT_IICRSV, priv->base + I2C_OFS_IICF0);\n\n\t \n\twriteb(I2C_BIT_WTIM0, priv->base + I2C_OFS_IICC0);\n\n\t \n\twriteb(I2C_BIT_IICE0, priv->base + I2C_OFS_IICACT0);\n\n\tretr = 1000;\n\twhile (readb(priv->base + I2C_OFS_IICACT0) == 0 && retr)\n\t\tretr--;\n\tWARN_ON(retr == 0);\n}\n\nstatic int __em_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg *msg,\n\t\t\t\tint stop)\n{\n\tstruct em_i2c_device *priv = i2c_get_adapdata(adap);\n\tint count, status, read = !!(msg->flags & I2C_M_RD);\n\n\t \n\tem_clear_set_bit(priv, 0, I2C_BIT_ACKE0 | I2C_BIT_WTIM0, I2C_OFS_IICC0);\n\tem_clear_set_bit(priv, 0, I2C_BIT_STT0, I2C_OFS_IICC0);\n\n\t \n\twriteb(i2c_8bit_addr_from_msg(msg), priv->base + I2C_OFS_IIC0);\n\n\t \n\tstatus = em_i2c_wait_for_event(priv);\n\tif (status < 0)\n\t\tgoto out_reset;\n\n\t \n\tif (!(status & I2C_BIT_ACKD0)) {\n\t\tem_i2c_stop(priv);\n\t\tgoto out;\n\t}\n\n\t \n\tif (read) {\n\t\t \n\t\tem_clear_set_bit(priv, I2C_BIT_WTIM0, I2C_BIT_ACKE0, I2C_OFS_IICC0);\n\t\tem_clear_set_bit(priv, I2C_BIT_WTIM0, I2C_BIT_WREL0, I2C_OFS_IICC0);\n\n\t\t \n\t\tstatus = em_i2c_wait_for_event(priv);\n\t\tif (status < 0)\n\t\t\tgoto out_reset;\n\t}\n\n\t \n\tfor (count = 0; count < msg->len; count++) {\n\t\tif (read) {  \n\t\t\tmsg->buf[count] = readb(priv->base + I2C_OFS_IIC0);\n\t\t\tem_clear_set_bit(priv, 0, I2C_BIT_WREL0, I2C_OFS_IICC0);\n\n\t\t} else {  \n\t\t\t \n\t\t\tif (!(status & I2C_BIT_ACKD0)) {\n\t\t\t\tem_i2c_stop(priv);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t \n\t\t\twriteb(msg->buf[count], priv->base + I2C_OFS_IIC0);\n\t\t}\n\n\t\t \n\t\tstatus = em_i2c_wait_for_event(priv);\n\t\tif (status < 0)\n\t\t\tgoto out_reset;\n\t}\n\n\tif (stop)\n\t\tem_i2c_stop(priv);\n\n\treturn count;\n\nout_reset:\n\tem_i2c_reset(adap);\nout:\n\treturn status < 0 ? status : -ENXIO;\n}\n\nstatic int em_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs,\n\tint num)\n{\n\tstruct em_i2c_device *priv = i2c_get_adapdata(adap);\n\tint ret, i;\n\n\tif (readb(priv->base + I2C_OFS_IICF0) & I2C_BIT_IICBSY)\n\t\treturn -EAGAIN;\n\n\tfor (i = 0; i < num; i++) {\n\t\tret = __em_i2c_xfer(adap, &msgs[i], (i == (num - 1)));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\t \n\treturn num;\n}\n\nstatic bool em_i2c_slave_irq(struct em_i2c_device *priv)\n{\n\tu8 status, value;\n\tenum i2c_slave_event event;\n\tint ret;\n\n\tif (!priv->slave)\n\t\treturn false;\n\n\tstatus = readb(priv->base + I2C_OFS_IICSE0);\n\n\t \n\tif (status & I2C_BIT_EXC0) {\n\t\tem_clear_set_bit(priv, 0, I2C_BIT_LREL0, I2C_OFS_IICC0);\n\t\treturn true;\n\t}\n\n\t \n\tif (status & I2C_BIT_SPD0) {\n\t\t \n\t\ti2c_slave_event(priv->slave, I2C_SLAVE_STOP, &value);\n\t\t \n\t\treturn false;\n\t}\n\n\t \n\tif (!(status & I2C_BIT_COI0))\n\t\treturn false;\n\n\t \n\tem_clear_set_bit(priv, 0, I2C_BIT_SPIE0, I2C_OFS_IICC0);\n\n\t \n\tif (status & I2C_BIT_TRC0) {\n\t\tif (status & I2C_BIT_ACKD0) {\n\t\t\t \n\t\t\tem_clear_set_bit(priv, 0, I2C_BIT_WTIM0, I2C_OFS_IICC0);\n\n\t\t\t \n\t\t\tevent = status & I2C_BIT_STD0 ?\n\t\t\t\tI2C_SLAVE_READ_REQUESTED :\n\t\t\t\tI2C_SLAVE_READ_PROCESSED;\n\t\t\ti2c_slave_event(priv->slave, event, &value);\n\t\t\twriteb(value, priv->base + I2C_OFS_IIC0);\n\t\t} else {\n\t\t\t \n\t\t\tem_clear_set_bit(priv, 0, I2C_BIT_LREL0, I2C_OFS_IICC0);\n\t\t}\n\t} else {\n\t\t \n\t\tem_clear_set_bit(priv, I2C_BIT_WTIM0, I2C_BIT_ACKE0,\n\t\t\t\tI2C_OFS_IICC0);\n\t\tem_clear_set_bit(priv, I2C_BIT_WTIM0, I2C_BIT_WREL0,\n\t\t\t\tI2C_OFS_IICC0);\n\n\t\tif (status & I2C_BIT_STD0) {\n\t\t\ti2c_slave_event(priv->slave, I2C_SLAVE_WRITE_REQUESTED,\n\t\t\t\t\t&value);\n\t\t} else {\n\t\t\t \n\t\t\tvalue = readb(priv->base + I2C_OFS_IIC0);\n\t\t\tret = i2c_slave_event(priv->slave,\n\t\t\t\t\tI2C_SLAVE_WRITE_RECEIVED, &value);\n\t\t\tif (ret < 0)\n\t\t\t\tem_clear_set_bit(priv, I2C_BIT_ACKE0, 0,\n\t\t\t\t\t\tI2C_OFS_IICC0);\n\t\t}\n\t}\n\n\treturn true;\n}\n\nstatic irqreturn_t em_i2c_irq_handler(int this_irq, void *dev_id)\n{\n\tstruct em_i2c_device *priv = dev_id;\n\n\tif (em_i2c_slave_irq(priv))\n\t\treturn IRQ_HANDLED;\n\n\tcomplete(&priv->msg_done);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic u32 em_i2c_func(struct i2c_adapter *adap)\n{\n\treturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL | I2C_FUNC_SLAVE;\n}\n\nstatic int em_i2c_reg_slave(struct i2c_client *slave)\n{\n\tstruct em_i2c_device *priv = i2c_get_adapdata(slave->adapter);\n\n\tif (priv->slave)\n\t\treturn -EBUSY;\n\n\tif (slave->flags & I2C_CLIENT_TEN)\n\t\treturn -EAFNOSUPPORT;\n\n\tpriv->slave = slave;\n\n\t \n\twriteb(slave->addr << 1, priv->base + I2C_OFS_SVA0);\n\n\treturn 0;\n}\n\nstatic int em_i2c_unreg_slave(struct i2c_client *slave)\n{\n\tstruct em_i2c_device *priv = i2c_get_adapdata(slave->adapter);\n\n\tWARN_ON(!priv->slave);\n\n\twriteb(0, priv->base + I2C_OFS_SVA0);\n\n\t \n\tsynchronize_irq(priv->irq);\n\tpriv->slave = NULL;\n\n\treturn 0;\n}\n\nstatic const struct i2c_algorithm em_i2c_algo = {\n\t.master_xfer = em_i2c_xfer,\n\t.functionality = em_i2c_func,\n\t.reg_slave      = em_i2c_reg_slave,\n\t.unreg_slave    = em_i2c_unreg_slave,\n};\n\nstatic int em_i2c_probe(struct platform_device *pdev)\n{\n\tstruct em_i2c_device *priv;\n\tint ret;\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(priv->base))\n\t\treturn PTR_ERR(priv->base);\n\n\tstrscpy(priv->adap.name, \"EMEV2 I2C\", sizeof(priv->adap.name));\n\n\tpriv->sclk = devm_clk_get(&pdev->dev, \"sclk\");\n\tif (IS_ERR(priv->sclk))\n\t\treturn PTR_ERR(priv->sclk);\n\n\tret = clk_prepare_enable(priv->sclk);\n\tif (ret)\n\t\treturn ret;\n\n\tpriv->adap.timeout = msecs_to_jiffies(100);\n\tpriv->adap.retries = 5;\n\tpriv->adap.dev.parent = &pdev->dev;\n\tpriv->adap.algo = &em_i2c_algo;\n\tpriv->adap.owner = THIS_MODULE;\n\tpriv->adap.dev.of_node = pdev->dev.of_node;\n\n\tinit_completion(&priv->msg_done);\n\n\tplatform_set_drvdata(pdev, priv);\n\ti2c_set_adapdata(&priv->adap, priv);\n\n\tem_i2c_reset(&priv->adap);\n\n\tret = platform_get_irq(pdev, 0);\n\tif (ret < 0)\n\t\tgoto err_clk;\n\tpriv->irq = ret;\n\tret = devm_request_irq(&pdev->dev, priv->irq, em_i2c_irq_handler, 0,\n\t\t\t\t\"em_i2c\", priv);\n\tif (ret)\n\t\tgoto err_clk;\n\n\tret = i2c_add_adapter(&priv->adap);\n\n\tif (ret)\n\t\tgoto err_clk;\n\n\tdev_info(&pdev->dev, \"Added i2c controller %d, irq %d\\n\", priv->adap.nr,\n\t\t priv->irq);\n\n\treturn 0;\n\nerr_clk:\n\tclk_disable_unprepare(priv->sclk);\n\treturn ret;\n}\n\nstatic void em_i2c_remove(struct platform_device *dev)\n{\n\tstruct em_i2c_device *priv = platform_get_drvdata(dev);\n\n\ti2c_del_adapter(&priv->adap);\n\tclk_disable_unprepare(priv->sclk);\n}\n\nstatic const struct of_device_id em_i2c_ids[] = {\n\t{ .compatible = \"renesas,iic-emev2\", },\n\t{ }\n};\n\nstatic struct platform_driver em_i2c_driver = {\n\t.probe = em_i2c_probe,\n\t.remove_new = em_i2c_remove,\n\t.driver = {\n\t\t.name = \"em-i2c\",\n\t\t.of_match_table = em_i2c_ids,\n\t}\n};\nmodule_platform_driver(em_i2c_driver);\n\nMODULE_DESCRIPTION(\"EMEV2 I2C bus driver\");\nMODULE_AUTHOR(\"Ian Molton\");\nMODULE_AUTHOR(\"Wolfram Sang <wsa@sang-engineering.com>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DEVICE_TABLE(of, em_i2c_ids);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}