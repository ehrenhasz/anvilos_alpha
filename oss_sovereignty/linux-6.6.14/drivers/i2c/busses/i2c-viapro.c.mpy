{
  "module_name": "i2c-viapro.c",
  "hash_id": "66819a4071d29e1b3580a8c195922a810f5befef525054ef8aaf222fa62dfdb1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-viapro.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/ioport.h>\n#include <linux/i2c.h>\n#include <linux/init.h>\n#include <linux/acpi.h>\n#include <linux/io.h>\n\nstatic struct pci_dev *vt596_pdev;\n\n#define SMBBA1\t\t0x90\n#define SMBBA2\t\t0x80\n#define SMBBA3\t\t0xD0\n\n \nstatic unsigned short vt596_smba;\n#define SMBHSTSTS\t(vt596_smba + 0)\n#define SMBHSTCNT\t(vt596_smba + 2)\n#define SMBHSTCMD\t(vt596_smba + 3)\n#define SMBHSTADD\t(vt596_smba + 4)\n#define SMBHSTDAT0\t(vt596_smba + 5)\n#define SMBHSTDAT1\t(vt596_smba + 6)\n#define SMBBLKDAT\t(vt596_smba + 7)\n\n \n\n \n\nstatic unsigned short SMBHSTCFG = 0xD2;\n\n \n#define MAX_TIMEOUT\t500\n\n \n#define VT596_QUICK\t\t0x00\n#define VT596_BYTE\t\t0x04\n#define VT596_BYTE_DATA\t\t0x08\n#define VT596_WORD_DATA\t\t0x0C\n#define VT596_PROC_CALL\t\t0x10\n#define VT596_BLOCK_DATA\t0x14\n#define VT596_I2C_BLOCK_DATA\t0x34\n\n\n \nstatic bool force;\nmodule_param(force, bool, 0);\nMODULE_PARM_DESC(force, \"Forcibly enable the SMBus. DANGEROUS!\");\n\n \nstatic u16 force_addr;\nmodule_param_hw(force_addr, ushort, ioport, 0);\nMODULE_PARM_DESC(force_addr,\n\t\t \"Forcibly enable the SMBus at the given address. \"\n\t\t \"EXTREMELY DANGEROUS!\");\n\n\nstatic struct pci_driver vt596_driver;\nstatic struct i2c_adapter vt596_adapter;\n\n#define FEATURE_I2CBLOCK\t(1<<0)\nstatic unsigned int vt596_features;\n\n#ifdef DEBUG\nstatic void vt596_dump_regs(const char *msg, u8 size)\n{\n\tdev_dbg(&vt596_adapter.dev, \"%s: STS=%02x CNT=%02x CMD=%02x ADD=%02x \"\n\t\t\"DAT=%02x,%02x\\n\", msg, inb_p(SMBHSTSTS), inb_p(SMBHSTCNT),\n\t\tinb_p(SMBHSTCMD), inb_p(SMBHSTADD), inb_p(SMBHSTDAT0),\n\t\tinb_p(SMBHSTDAT1));\n\n\tif (size == VT596_BLOCK_DATA\n\t || size == VT596_I2C_BLOCK_DATA) {\n\t\tint i;\n\n\t\tdev_dbg(&vt596_adapter.dev, \"BLK=\");\n\t\tfor (i = 0; i < I2C_SMBUS_BLOCK_MAX / 2; i++)\n\t\t\tprintk(\"%02x,\", inb_p(SMBBLKDAT));\n\t\tprintk(\"\\n\");\n\t\tdev_dbg(&vt596_adapter.dev, \"    \");\n\t\tfor (; i < I2C_SMBUS_BLOCK_MAX - 1; i++)\n\t\t\tprintk(\"%02x,\", inb_p(SMBBLKDAT));\n\t\tprintk(\"%02x\\n\", inb_p(SMBBLKDAT));\n\t}\n}\n#else\nstatic inline void vt596_dump_regs(const char *msg, u8 size) { }\n#endif\n\n \nstatic int vt596_transaction(u8 size)\n{\n\tint temp;\n\tint result = 0;\n\tint timeout = 0;\n\n\tvt596_dump_regs(\"Transaction (pre)\", size);\n\n\t \n\tif ((temp = inb_p(SMBHSTSTS)) & 0x1F) {\n\t\tdev_dbg(&vt596_adapter.dev, \"SMBus busy (0x%02x). \"\n\t\t\t\"Resetting...\\n\", temp);\n\n\t\toutb_p(temp, SMBHSTSTS);\n\t\tif ((temp = inb_p(SMBHSTSTS)) & 0x1F) {\n\t\t\tdev_err(&vt596_adapter.dev, \"SMBus reset failed! \"\n\t\t\t\t\"(0x%02x)\\n\", temp);\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\n\t \n\toutb_p(0x40 | size, SMBHSTCNT);\n\n\t \n\tdo {\n\t\tmsleep(1);\n\t\ttemp = inb_p(SMBHSTSTS);\n\t} while ((temp & 0x01) && (++timeout < MAX_TIMEOUT));\n\n\t \n\tif (timeout == MAX_TIMEOUT) {\n\t\tresult = -ETIMEDOUT;\n\t\tdev_err(&vt596_adapter.dev, \"SMBus timeout!\\n\");\n\t}\n\n\tif (temp & 0x10) {\n\t\tresult = -EIO;\n\t\tdev_err(&vt596_adapter.dev, \"Transaction failed (0x%02x)\\n\",\n\t\t\tsize);\n\t}\n\n\tif (temp & 0x08) {\n\t\tresult = -EIO;\n\t\tdev_err(&vt596_adapter.dev, \"SMBus collision!\\n\");\n\t}\n\n\tif (temp & 0x04) {\n\t\tresult = -ENXIO;\n\t\tdev_dbg(&vt596_adapter.dev, \"No response\\n\");\n\t}\n\n\t \n\tif (temp & 0x1F)\n\t\toutb_p(temp, SMBHSTSTS);\n\n\tvt596_dump_regs(\"Transaction (post)\", size);\n\n\treturn result;\n}\n\n \nstatic s32 vt596_access(struct i2c_adapter *adap, u16 addr,\n\t\tunsigned short flags, char read_write, u8 command,\n\t\tint size, union i2c_smbus_data *data)\n{\n\tint i;\n\tint status;\n\n\tswitch (size) {\n\tcase I2C_SMBUS_QUICK:\n\t\tsize = VT596_QUICK;\n\t\tbreak;\n\tcase I2C_SMBUS_BYTE:\n\t\tif (read_write == I2C_SMBUS_WRITE)\n\t\t\toutb_p(command, SMBHSTCMD);\n\t\tsize = VT596_BYTE;\n\t\tbreak;\n\tcase I2C_SMBUS_BYTE_DATA:\n\t\toutb_p(command, SMBHSTCMD);\n\t\tif (read_write == I2C_SMBUS_WRITE)\n\t\t\toutb_p(data->byte, SMBHSTDAT0);\n\t\tsize = VT596_BYTE_DATA;\n\t\tbreak;\n\tcase I2C_SMBUS_WORD_DATA:\n\t\toutb_p(command, SMBHSTCMD);\n\t\tif (read_write == I2C_SMBUS_WRITE) {\n\t\t\toutb_p(data->word & 0xff, SMBHSTDAT0);\n\t\t\toutb_p((data->word & 0xff00) >> 8, SMBHSTDAT1);\n\t\t}\n\t\tsize = VT596_WORD_DATA;\n\t\tbreak;\n\tcase I2C_SMBUS_PROC_CALL:\n\t\toutb_p(command, SMBHSTCMD);\n\t\toutb_p(data->word & 0xff, SMBHSTDAT0);\n\t\toutb_p((data->word & 0xff00) >> 8, SMBHSTDAT1);\n\t\tsize = VT596_PROC_CALL;\n\t\tbreak;\n\tcase I2C_SMBUS_I2C_BLOCK_DATA:\n\t\tif (!(vt596_features & FEATURE_I2CBLOCK))\n\t\t\tgoto exit_unsupported;\n\t\tif (read_write == I2C_SMBUS_READ)\n\t\t\toutb_p(data->block[0], SMBHSTDAT0);\n\t\tfallthrough;\n\tcase I2C_SMBUS_BLOCK_DATA:\n\t\toutb_p(command, SMBHSTCMD);\n\t\tif (read_write == I2C_SMBUS_WRITE) {\n\t\t\tu8 len = data->block[0];\n\t\t\tif (len > I2C_SMBUS_BLOCK_MAX)\n\t\t\t\tlen = I2C_SMBUS_BLOCK_MAX;\n\t\t\toutb_p(len, SMBHSTDAT0);\n\t\t\tinb_p(SMBHSTCNT);\t \n\t\t\tfor (i = 1; i <= len; i++)\n\t\t\t\toutb_p(data->block[i], SMBBLKDAT);\n\t\t}\n\t\tsize = (size == I2C_SMBUS_I2C_BLOCK_DATA) ?\n\t\t       VT596_I2C_BLOCK_DATA : VT596_BLOCK_DATA;\n\t\tbreak;\n\tdefault:\n\t\tgoto exit_unsupported;\n\t}\n\n\toutb_p(((addr & 0x7f) << 1) | read_write, SMBHSTADD);\n\n\tstatus = vt596_transaction(size);\n\tif (status)\n\t\treturn status;\n\n\tif (size == VT596_PROC_CALL)\n\t\tread_write = I2C_SMBUS_READ;\n\n\tif ((read_write == I2C_SMBUS_WRITE) || (size == VT596_QUICK))\n\t\treturn 0;\n\n\tswitch (size) {\n\tcase VT596_BYTE:\n\tcase VT596_BYTE_DATA:\n\t\tdata->byte = inb_p(SMBHSTDAT0);\n\t\tbreak;\n\tcase VT596_WORD_DATA:\n\tcase VT596_PROC_CALL:\n\t\tdata->word = inb_p(SMBHSTDAT0) + (inb_p(SMBHSTDAT1) << 8);\n\t\tbreak;\n\tcase VT596_I2C_BLOCK_DATA:\n\tcase VT596_BLOCK_DATA:\n\t\tdata->block[0] = inb_p(SMBHSTDAT0);\n\t\tif (data->block[0] > I2C_SMBUS_BLOCK_MAX)\n\t\t\tdata->block[0] = I2C_SMBUS_BLOCK_MAX;\n\t\tinb_p(SMBHSTCNT);\t \n\t\tfor (i = 1; i <= data->block[0]; i++)\n\t\t\tdata->block[i] = inb_p(SMBBLKDAT);\n\t\tbreak;\n\t}\n\treturn 0;\n\nexit_unsupported:\n\tdev_warn(&vt596_adapter.dev, \"Unsupported transaction %d\\n\",\n\t\t size);\n\treturn -EOPNOTSUPP;\n}\n\nstatic u32 vt596_func(struct i2c_adapter *adapter)\n{\n\tu32 func = I2C_FUNC_SMBUS_QUICK | I2C_FUNC_SMBUS_BYTE |\n\t    I2C_FUNC_SMBUS_BYTE_DATA | I2C_FUNC_SMBUS_WORD_DATA |\n\t    I2C_SMBUS_PROC_CALL | I2C_FUNC_SMBUS_BLOCK_DATA;\n\n\tif (vt596_features & FEATURE_I2CBLOCK)\n\t\tfunc |= I2C_FUNC_SMBUS_I2C_BLOCK;\n\treturn func;\n}\n\nstatic const struct i2c_algorithm smbus_algorithm = {\n\t.smbus_xfer\t= vt596_access,\n\t.functionality\t= vt596_func,\n};\n\nstatic struct i2c_adapter vt596_adapter = {\n\t.owner\t\t= THIS_MODULE,\n\t.class\t\t= I2C_CLASS_HWMON | I2C_CLASS_SPD,\n\t.algo\t\t= &smbus_algorithm,\n};\n\nstatic int vt596_probe(struct pci_dev *pdev,\n\t\t       const struct pci_device_id *id)\n{\n\tunsigned char temp;\n\tint error;\n\n\t \n\tif (force_addr) {\n\t\tvt596_smba = force_addr & 0xfff0;\n\t\tforce = 0;\n\t\tgoto found;\n\t}\n\n\tif ((pci_read_config_word(pdev, id->driver_data, &vt596_smba)) ||\n\t    !(vt596_smba & 0x0001)) {\n\t\t \n\t\tif (id->device == PCI_DEVICE_ID_VIA_82C596_3 &&\n\t\t    !pci_read_config_word(pdev, SMBBA2, &vt596_smba) &&\n\t\t    (vt596_smba & 0x0001)) {\n\t\t\tSMBHSTCFG = 0x84;\n\t\t} else {\n\t\t\t \n\t\t\tdev_err(&pdev->dev, \"Cannot configure \"\n\t\t\t\t\"SMBus I/O Base address\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\tvt596_smba &= 0xfff0;\n\tif (vt596_smba == 0) {\n\t\tdev_err(&pdev->dev, \"SMBus base address \"\n\t\t\t\"uninitialized - upgrade BIOS or use \"\n\t\t\t\"force_addr=0xaddr\\n\");\n\t\treturn -ENODEV;\n\t}\n\nfound:\n\terror = acpi_check_region(vt596_smba, 8, vt596_driver.name);\n\tif (error)\n\t\treturn -ENODEV;\n\n\tif (!request_region(vt596_smba, 8, vt596_driver.name)) {\n\t\tdev_err(&pdev->dev, \"SMBus region 0x%x already in use!\\n\",\n\t\t\tvt596_smba);\n\t\treturn -ENODEV;\n\t}\n\n\tpci_read_config_byte(pdev, SMBHSTCFG, &temp);\n\t \n\tif (force_addr) {\n\t\tpci_write_config_byte(pdev, SMBHSTCFG, temp & 0xfe);\n\t\tpci_write_config_word(pdev, id->driver_data, vt596_smba);\n\t\tpci_write_config_byte(pdev, SMBHSTCFG, temp | 0x01);\n\t\tdev_warn(&pdev->dev, \"WARNING: SMBus interface set to new \"\n\t\t\t \"address 0x%04x!\\n\", vt596_smba);\n\t} else if (!(temp & 0x01)) {\n\t\tif (force) {\n\t\t\t \n\t\t\tpci_write_config_byte(pdev, SMBHSTCFG, temp | 0x01);\n\t\t\tdev_info(&pdev->dev, \"Enabling SMBus device\\n\");\n\t\t} else {\n\t\t\tdev_err(&pdev->dev, \"SMBUS: Error: Host SMBus \"\n\t\t\t\t\"controller not enabled! - upgrade BIOS or \"\n\t\t\t\t\"use force=1\\n\");\n\t\t\terror = -ENODEV;\n\t\t\tgoto release_region;\n\t\t}\n\t}\n\n\tdev_dbg(&pdev->dev, \"VT596_smba = 0x%X\\n\", vt596_smba);\n\n\tswitch (pdev->device) {\n\tcase PCI_DEVICE_ID_VIA_CX700:\n\tcase PCI_DEVICE_ID_VIA_VX800:\n\tcase PCI_DEVICE_ID_VIA_VX855:\n\tcase PCI_DEVICE_ID_VIA_VX900:\n\tcase PCI_DEVICE_ID_VIA_8251:\n\tcase PCI_DEVICE_ID_VIA_8237:\n\tcase PCI_DEVICE_ID_VIA_8237A:\n\tcase PCI_DEVICE_ID_VIA_8237S:\n\tcase PCI_DEVICE_ID_VIA_8235:\n\tcase PCI_DEVICE_ID_VIA_8233A:\n\tcase PCI_DEVICE_ID_VIA_8233_0:\n\t\tvt596_features |= FEATURE_I2CBLOCK;\n\t\tbreak;\n\tcase PCI_DEVICE_ID_VIA_82C686_4:\n\t\t \n\t\tif (pdev->revision >= 0x40)\n\t\t\tvt596_features |= FEATURE_I2CBLOCK;\n\t\tbreak;\n\t}\n\n\tvt596_adapter.dev.parent = &pdev->dev;\n\tsnprintf(vt596_adapter.name, sizeof(vt596_adapter.name),\n\t\t \"SMBus Via Pro adapter at %04x\", vt596_smba);\n\n\tvt596_pdev = pci_dev_get(pdev);\n\terror = i2c_add_adapter(&vt596_adapter);\n\tif (error) {\n\t\tpci_dev_put(vt596_pdev);\n\t\tvt596_pdev = NULL;\n\t\tgoto release_region;\n\t}\n\n\t \n\treturn -ENODEV;\n\nrelease_region:\n\trelease_region(vt596_smba, 8);\n\treturn error;\n}\n\nstatic const struct pci_device_id vt596_ids[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_VIA, PCI_DEVICE_ID_VIA_82C596_3),\n\t  .driver_data = SMBBA1 },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_VIA, PCI_DEVICE_ID_VIA_82C596B_3),\n\t  .driver_data = SMBBA1 },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_VIA, PCI_DEVICE_ID_VIA_82C686_4),\n\t  .driver_data = SMBBA1 },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_VIA, PCI_DEVICE_ID_VIA_8233_0),\n\t  .driver_data = SMBBA3 },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_VIA, PCI_DEVICE_ID_VIA_8233A),\n\t  .driver_data = SMBBA3 },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_VIA, PCI_DEVICE_ID_VIA_8235),\n\t  .driver_data = SMBBA3 },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_VIA, PCI_DEVICE_ID_VIA_8237),\n\t  .driver_data = SMBBA3 },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_VIA, PCI_DEVICE_ID_VIA_8237A),\n\t  .driver_data = SMBBA3 },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_VIA, PCI_DEVICE_ID_VIA_8237S),\n\t  .driver_data = SMBBA3 },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_VIA, PCI_DEVICE_ID_VIA_8231_4),\n\t  .driver_data = SMBBA1 },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_VIA, PCI_DEVICE_ID_VIA_8251),\n\t  .driver_data = SMBBA3 },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_VIA, PCI_DEVICE_ID_VIA_CX700),\n\t  .driver_data = SMBBA3 },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_VIA, PCI_DEVICE_ID_VIA_VX800),\n\t  .driver_data = SMBBA3 },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_VIA, PCI_DEVICE_ID_VIA_VX855),\n\t  .driver_data = SMBBA3 },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_VIA, PCI_DEVICE_ID_VIA_VX900),\n\t  .driver_data = SMBBA3 },\n\t{ 0, }\n};\n\nMODULE_DEVICE_TABLE(pci, vt596_ids);\n\nstatic struct pci_driver vt596_driver = {\n\t.name\t\t= \"vt596_smbus\",\n\t.id_table\t= vt596_ids,\n\t.probe\t\t= vt596_probe,\n};\n\nstatic int __init i2c_vt596_init(void)\n{\n\treturn pci_register_driver(&vt596_driver);\n}\n\n\nstatic void __exit i2c_vt596_exit(void)\n{\n\tpci_unregister_driver(&vt596_driver);\n\tif (vt596_pdev != NULL) {\n\t\ti2c_del_adapter(&vt596_adapter);\n\t\trelease_region(vt596_smba, 8);\n\t\tpci_dev_put(vt596_pdev);\n\t\tvt596_pdev = NULL;\n\t}\n}\n\nMODULE_AUTHOR(\"Kyosti Malkki <kmalkki@cc.hut.fi>\");\nMODULE_AUTHOR(\"Mark D. Studebaker <mdsxyz123@yahoo.com>\");\nMODULE_AUTHOR(\"Jean Delvare <jdelvare@suse.de>\");\nMODULE_DESCRIPTION(\"vt82c596 SMBus driver\");\nMODULE_LICENSE(\"GPL\");\n\nmodule_init(i2c_vt596_init);\nmodule_exit(i2c_vt596_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}