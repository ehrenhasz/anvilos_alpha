{
  "module_name": "i2c-powermac.c",
  "hash_id": "01b14a9269cb6bbe0feb227e65502d6df9a5fc19feadd6093f35cecd442a6e1d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-powermac.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/i2c.h>\n#include <linux/device.h>\n#include <linux/platform_device.h>\n#include <linux/of_irq.h>\n\n#include <asm/pmac_low_i2c.h>\n\nMODULE_AUTHOR(\"Benjamin Herrenschmidt <benh@kernel.crashing.org>\");\nMODULE_DESCRIPTION(\"I2C driver for Apple PowerMac\");\nMODULE_LICENSE(\"GPL\");\n\n \nstatic s32 i2c_powermac_smbus_xfer(\tstruct i2c_adapter*\tadap,\n\t\t\t\t\tu16\t\t\taddr,\n\t\t\t\t\tunsigned short\t\tflags,\n\t\t\t\t\tchar\t\t\tread_write,\n\t\t\t\t\tu8\t\t\tcommand,\n\t\t\t\t\tint\t\t\tsize,\n\t\t\t\t\tunion i2c_smbus_data*\tdata)\n{\n\tstruct pmac_i2c_bus\t*bus = i2c_get_adapdata(adap);\n\tint\t\t\trc = 0;\n\tint\t\t\tread = (read_write == I2C_SMBUS_READ);\n\tint\t\t\taddrdir = (addr << 1) | read;\n\tint\t\t\tmode, subsize, len;\n\tu32\t\t\tsubaddr;\n\tu8\t\t\t*buf;\n\tu8\t\t\tlocal[2];\n\n\tif (size == I2C_SMBUS_QUICK || size == I2C_SMBUS_BYTE) {\n\t\tmode = pmac_i2c_mode_std;\n\t\tsubsize = 0;\n\t\tsubaddr = 0;\n\t} else {\n\t\tmode = read ? pmac_i2c_mode_combined : pmac_i2c_mode_stdsub;\n\t\tsubsize = 1;\n\t\tsubaddr = command;\n\t}\n\n\tswitch (size) {\n        case I2C_SMBUS_QUICK:\n\t\tbuf = NULL;\n\t\tlen = 0;\n\t    \tbreak;\n        case I2C_SMBUS_BYTE:\n        case I2C_SMBUS_BYTE_DATA:\n\t\tbuf = &data->byte;\n\t\tlen = 1;\n\t    \tbreak;\n        case I2C_SMBUS_WORD_DATA:\n\t\tif (!read) {\n\t\t\tlocal[0] = data->word & 0xff;\n\t\t\tlocal[1] = (data->word >> 8) & 0xff;\n\t\t}\n\t\tbuf = local;\n\t\tlen = 2;\n\t    \tbreak;\n\n\t \n        case I2C_SMBUS_BLOCK_DATA:\n\t\tbuf = data->block;\n\t\tlen = data->block[0] + 1;\n\t\tbreak;\n\tcase I2C_SMBUS_I2C_BLOCK_DATA:\n\t\tbuf = &data->block[1];\n\t\tlen = data->block[0];\n\t\tbreak;\n\n        default:\n\t\treturn -EINVAL;\n\t}\n\n\trc = pmac_i2c_open(bus, 0);\n\tif (rc) {\n\t\tdev_err(&adap->dev, \"Failed to open I2C, err %d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\trc = pmac_i2c_setmode(bus, mode);\n\tif (rc) {\n\t\tdev_err(&adap->dev, \"Failed to set I2C mode %d, err %d\\n\",\n\t\t\tmode, rc);\n\t\tgoto bail;\n\t}\n\n\trc = pmac_i2c_xfer(bus, addrdir, subsize, subaddr, buf, len);\n\tif (rc) {\n\t\tif (rc == -ENXIO)\n\t\t\tdev_dbg(&adap->dev,\n\t\t\t\t\"I2C transfer at 0x%02x failed, size %d, \"\n\t\t\t\t\"err %d\\n\", addrdir >> 1, size, rc);\n\t\telse\n\t\t\tdev_err(&adap->dev,\n\t\t\t\t\"I2C transfer at 0x%02x failed, size %d, \"\n\t\t\t\t\"err %d\\n\", addrdir >> 1, size, rc);\n\t\tgoto bail;\n\t}\n\n\tif (size == I2C_SMBUS_WORD_DATA && read) {\n\t\tdata->word = ((u16)local[1]) << 8;\n\t\tdata->word |= local[0];\n\t}\n\n bail:\n\tpmac_i2c_close(bus);\n\treturn rc;\n}\n\n \nstatic int i2c_powermac_master_xfer(\tstruct i2c_adapter *adap,\n\t\t\t\t\tstruct i2c_msg *msgs,\n\t\t\t\t\tint num)\n{\n\tstruct pmac_i2c_bus\t*bus = i2c_get_adapdata(adap);\n\tint\t\t\trc = 0;\n\tint\t\t\taddrdir;\n\n\tif (msgs->flags & I2C_M_TEN)\n\t\treturn -EINVAL;\n\taddrdir = i2c_8bit_addr_from_msg(msgs);\n\n\trc = pmac_i2c_open(bus, 0);\n\tif (rc) {\n\t\tdev_err(&adap->dev, \"Failed to open I2C, err %d\\n\", rc);\n\t\treturn rc;\n\t}\n\trc = pmac_i2c_setmode(bus, pmac_i2c_mode_std);\n\tif (rc) {\n\t\tdev_err(&adap->dev, \"Failed to set I2C mode %d, err %d\\n\",\n\t\t\tpmac_i2c_mode_std, rc);\n\t\tgoto bail;\n\t}\n\trc = pmac_i2c_xfer(bus, addrdir, 0, 0, msgs->buf, msgs->len);\n\tif (rc < 0) {\n\t\tif (rc == -ENXIO)\n\t\t\tdev_dbg(&adap->dev, \"I2C %s 0x%02x failed, err %d\\n\",\n\t\t\t\taddrdir & 1 ? \"read from\" : \"write to\",\n\t\t\t\taddrdir >> 1, rc);\n\t\telse\n\t\t\tdev_err(&adap->dev, \"I2C %s 0x%02x failed, err %d\\n\",\n\t\t\t\taddrdir & 1 ? \"read from\" : \"write to\",\n\t\t\t\taddrdir >> 1, rc);\n\t}\n bail:\n\tpmac_i2c_close(bus);\n\treturn rc < 0 ? rc : 1;\n}\n\nstatic u32 i2c_powermac_func(struct i2c_adapter * adapter)\n{\n\treturn I2C_FUNC_SMBUS_QUICK | I2C_FUNC_SMBUS_BYTE |\n\t\tI2C_FUNC_SMBUS_BYTE_DATA | I2C_FUNC_SMBUS_WORD_DATA |\n\t\tI2C_FUNC_SMBUS_BLOCK_DATA | I2C_FUNC_I2C;\n}\n\n \nstatic const struct i2c_algorithm i2c_powermac_algorithm = {\n\t.smbus_xfer\t= i2c_powermac_smbus_xfer,\n\t.master_xfer\t= i2c_powermac_master_xfer,\n\t.functionality\t= i2c_powermac_func,\n};\n\nstatic const struct i2c_adapter_quirks i2c_powermac_quirks = {\n\t.max_num_msgs = 1,\n};\n\nstatic void i2c_powermac_remove(struct platform_device *dev)\n{\n\tstruct i2c_adapter\t*adapter = platform_get_drvdata(dev);\n\n\ti2c_del_adapter(adapter);\n\tmemset(adapter, 0, sizeof(*adapter));\n}\n\nstatic u32 i2c_powermac_get_addr(struct i2c_adapter *adap,\n\t\t\t\t\t   struct pmac_i2c_bus *bus,\n\t\t\t\t\t   struct device_node *node)\n{\n\tu32 prop;\n\tint ret;\n\n\t \n\tret = of_property_read_u32(node, \"reg\", &prop);\n\tif (ret == 0)\n\t\treturn (prop & 0xff) >> 1;\n\n\t \n\tret = of_property_read_u32(node, \"i2c-address\", &prop);\n\tif (ret == 0)\n\t\treturn (prop & 0xff) >> 1;\n\n\t \n\tif (of_node_name_eq(node, \"cereal\"))\n\t\treturn 0x60;\n\telse if (of_node_name_eq(node, \"deq\"))\n\t\treturn 0x34;\n\n\tdev_warn(&adap->dev, \"No i2c address for %pOF\\n\", node);\n\n\treturn 0xffffffff;\n}\n\nstatic void i2c_powermac_create_one(struct i2c_adapter *adap,\n\t\t\t\t\t      const char *type,\n\t\t\t\t\t      u32 addr)\n{\n\tstruct i2c_board_info info = {};\n\tstruct i2c_client *newdev;\n\n\tstrncpy(info.type, type, sizeof(info.type));\n\tinfo.addr = addr;\n\tnewdev = i2c_new_client_device(adap, &info);\n\tif (IS_ERR(newdev))\n\t\tdev_err(&adap->dev,\n\t\t\t\"i2c-powermac: Failure to register missing %s\\n\",\n\t\t\ttype);\n}\n\nstatic void i2c_powermac_add_missing(struct i2c_adapter *adap,\n\t\t\t\t\t       struct pmac_i2c_bus *bus,\n\t\t\t\t\t       bool found_onyx)\n{\n\tstruct device_node *busnode = pmac_i2c_get_bus_node(bus);\n\tint rc;\n\n\t \n#define ONYX_REG_CONTROL\t\t67\n\tif (of_device_is_compatible(busnode, \"k2-i2c\") && !found_onyx) {\n\t\tunion i2c_smbus_data data;\n\n\t\trc = i2c_smbus_xfer(adap, 0x46, 0, I2C_SMBUS_READ,\n\t\t\t\t    ONYX_REG_CONTROL, I2C_SMBUS_BYTE_DATA,\n\t\t\t\t    &data);\n\t\tif (rc >= 0)\n\t\t\ti2c_powermac_create_one(adap, \"MAC,pcm3052\", 0x46);\n\n\t\trc = i2c_smbus_xfer(adap, 0x47, 0, I2C_SMBUS_READ,\n\t\t\t\t    ONYX_REG_CONTROL, I2C_SMBUS_BYTE_DATA,\n\t\t\t\t    &data);\n\t\tif (rc >= 0)\n\t\t\ti2c_powermac_create_one(adap, \"MAC,pcm3052\", 0x47);\n\t}\n}\n\nstatic bool i2c_powermac_get_type(struct i2c_adapter *adap,\n\t\t\t\t\t    struct device_node *node,\n\t\t\t\t\t    u32 addr, char *type, int type_size)\n{\n\tchar tmp[16];\n\n\t \n\n\t \n\tif (of_alias_from_compatible(node, tmp, sizeof(tmp)) >= 0) {\n\t\tsnprintf(type, type_size, \"MAC,%s\", tmp);\n\t\treturn true;\n\t}\n\n\t \n\tif (of_node_name_eq(node, \"deq\")) {\n\t\t \n\t\tif (addr == 0x34) {\n\t\t\tsnprintf(type, type_size, \"MAC,tas3001\");\n\t\t\treturn true;\n\t\t} else if (addr == 0x35) {\n\t\t\tsnprintf(type, type_size, \"MAC,tas3004\");\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tdev_err(&adap->dev, \"i2c-powermac: modalias failure on %pOF\\n\", node);\n\treturn false;\n}\n\nstatic void i2c_powermac_register_devices(struct i2c_adapter *adap,\n\t\t\t\t\t\t    struct pmac_i2c_bus *bus)\n{\n\tstruct i2c_client *newdev;\n\tstruct device_node *node;\n\tbool found_onyx = false;\n\n\t \n\tif (of_node_name_eq(adap->dev.of_node, \"via-pmu\"))\n\t\treturn;\n\n\tfor_each_child_of_node(adap->dev.of_node, node) {\n\t\tstruct i2c_board_info info = {};\n\t\tu32 addr;\n\n\t\t \n\t\taddr = i2c_powermac_get_addr(adap, bus, node);\n\t\tif (addr == 0xffffffff)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (!pmac_i2c_match_adapter(node, adap))\n\t\t\tcontinue;\n\n\t\tdev_dbg(&adap->dev, \"i2c-powermac: register %pOF\\n\", node);\n\n\t\t \n\t\tif (of_device_is_compatible(node, \"pcm3052\"))\n\t\t\tfound_onyx = true;\n\n\t\t \n\t\tif (!i2c_powermac_get_type(adap, node, addr,\n\t\t\t\t\t   info.type, sizeof(info.type))) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tinfo.addr = addr;\n\t\tinfo.irq = irq_of_parse_and_map(node, 0);\n\t\tinfo.of_node = of_node_get(node);\n\n\t\tnewdev = i2c_new_client_device(adap, &info);\n\t\tif (IS_ERR(newdev)) {\n\t\t\tdev_err(&adap->dev, \"i2c-powermac: Failure to register\"\n\t\t\t\t\" %pOF\\n\", node);\n\t\t\tof_node_put(node);\n\t\t\t \n\t\t\tcontinue;\n\t\t}\n\t}\n\n\t \n\ti2c_powermac_add_missing(adap, bus, found_onyx);\n}\n\nstatic int i2c_powermac_probe(struct platform_device *dev)\n{\n\tstruct pmac_i2c_bus *bus = dev_get_platdata(&dev->dev);\n\tstruct device_node *parent;\n\tstruct i2c_adapter *adapter;\n\tint rc;\n\n\tif (bus == NULL)\n\t\treturn -EINVAL;\n\tadapter = pmac_i2c_get_adapter(bus);\n\n\t \n\tswitch(pmac_i2c_get_type(bus)) {\n\tcase pmac_i2c_bus_keywest:\n\t\tparent = of_get_parent(pmac_i2c_get_controller(bus));\n\t\tif (parent == NULL)\n\t\t\treturn -EINVAL;\n\t\tsnprintf(adapter->name, sizeof(adapter->name), \"%pOFn %d\",\n\t\t\t parent,\n\t\t\t pmac_i2c_get_channel(bus));\n\t\tof_node_put(parent);\n\t\tbreak;\n\tcase pmac_i2c_bus_pmu:\n\t\tsnprintf(adapter->name, sizeof(adapter->name), \"pmu %d\",\n\t\t\t pmac_i2c_get_channel(bus));\n\t\tbreak;\n\tcase pmac_i2c_bus_smu:\n\t\t \n\t\tsnprintf(adapter->name, sizeof(adapter->name), \"smu %d\",\n\t\t\t pmac_i2c_get_channel(bus));\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tplatform_set_drvdata(dev, adapter);\n\tadapter->algo = &i2c_powermac_algorithm;\n\tadapter->quirks = &i2c_powermac_quirks;\n\ti2c_set_adapdata(adapter, bus);\n\tadapter->dev.parent = &dev->dev;\n\n\t \n\tadapter->dev.of_node = NULL;\n\trc = i2c_add_adapter(adapter);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"i2c-powermac: Adapter %s registration \"\n\t\t       \"failed\\n\", adapter->name);\n\t\tmemset(adapter, 0, sizeof(*adapter));\n\t\treturn rc;\n\t}\n\n\tprintk(KERN_INFO \"PowerMac i2c bus %s registered\\n\", adapter->name);\n\n\t \n\tadapter->dev.of_node = dev->dev.of_node;\n\ti2c_powermac_register_devices(adapter, bus);\n\n\treturn 0;\n}\n\nstatic struct platform_driver i2c_powermac_driver = {\n\t.probe = i2c_powermac_probe,\n\t.remove_new = i2c_powermac_remove,\n\t.driver = {\n\t\t.name = \"i2c-powermac\",\n\t\t.bus = &platform_bus_type,\n\t},\n};\n\nmodule_platform_driver(i2c_powermac_driver);\n\nMODULE_ALIAS(\"platform:i2c-powermac\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}