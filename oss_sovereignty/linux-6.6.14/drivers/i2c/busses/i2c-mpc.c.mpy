{
  "module_name": "i2c-mpc.c",
  "hash_id": "d228219690feab0d1e4a84d3990bce9c2db7c2d89acdcadddc9e6f0370ffd1ca",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-mpc.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/sched/signal.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/platform_device.h>\n#include <linux/property.h>\n#include <linux/slab.h>\n\n#include <linux/clk.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/fsl_devices.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\n#include <asm/mpc52xx.h>\n#include <asm/mpc85xx.h>\n#include <sysdev/fsl_soc.h>\n\n#define DRV_NAME \"mpc-i2c\"\n\n#define MPC_I2C_CLOCK_LEGACY   0\n#define MPC_I2C_CLOCK_PRESERVE (~0U)\n\n#define MPC_I2C_FDR   0x04\n#define MPC_I2C_CR    0x08\n#define MPC_I2C_SR    0x0c\n#define MPC_I2C_DR    0x10\n#define MPC_I2C_DFSRR 0x14\n\n#define CCR_MEN  0x80\n#define CCR_MIEN 0x40\n#define CCR_MSTA 0x20\n#define CCR_MTX  0x10\n#define CCR_TXAK 0x08\n#define CCR_RSTA 0x04\n#define CCR_RSVD 0x02\n\n#define CSR_MCF  0x80\n#define CSR_MAAS 0x40\n#define CSR_MBB  0x20\n#define CSR_MAL  0x10\n#define CSR_SRW  0x04\n#define CSR_MIF  0x02\n#define CSR_RXAK 0x01\n\nenum mpc_i2c_action {\n\tMPC_I2C_ACTION_START = 1,\n\tMPC_I2C_ACTION_RESTART,\n\tMPC_I2C_ACTION_READ_BEGIN,\n\tMPC_I2C_ACTION_READ_BYTE,\n\tMPC_I2C_ACTION_WRITE,\n\tMPC_I2C_ACTION_STOP,\n\n\t__MPC_I2C_ACTION_CNT\n};\n\nstatic const char * const action_str[] = {\n\t\"invalid\",\n\t\"start\",\n\t\"restart\",\n\t\"read begin\",\n\t\"read\",\n\t\"write\",\n\t\"stop\",\n};\n\nstatic_assert(ARRAY_SIZE(action_str) == __MPC_I2C_ACTION_CNT);\n\nstruct mpc_i2c {\n\tstruct device *dev;\n\tvoid __iomem *base;\n\tu32 interrupt;\n\twait_queue_head_t waitq;\n\tspinlock_t lock;\n\tstruct i2c_adapter adap;\n\tint irq;\n\tu32 real_clk;\n\tu8 fdr, dfsrr;\n\tstruct clk *clk_per;\n\tu32 cntl_bits;\n\tenum mpc_i2c_action action;\n\tstruct i2c_msg *msgs;\n\tint num_msgs;\n\tint curr_msg;\n\tu32 byte_posn;\n\tu32 block;\n\tint rc;\n\tint expect_rxack;\n\tbool has_errata_A004447;\n};\n\nstruct mpc_i2c_divider {\n\tu16 divider;\n\tu16 fdr;\t \n};\n\nstruct mpc_i2c_data {\n\tvoid (*setup)(struct device_node *node, struct mpc_i2c *i2c, u32 clock);\n};\n\nstatic inline void writeccr(struct mpc_i2c *i2c, u32 x)\n{\n\twriteb(x, i2c->base + MPC_I2C_CR);\n}\n\n \nstatic void mpc_i2c_fixup(struct mpc_i2c *i2c)\n{\n\tint k;\n\tunsigned long flags;\n\n\tfor (k = 9; k; k--) {\n\t\twriteccr(i2c, 0);\n\t\twriteb(0, i2c->base + MPC_I2C_SR);  \n\t\twriteccr(i2c, CCR_MEN | CCR_MSTA);  \n\t\treadb(i2c->base + MPC_I2C_DR);  \n\t\tudelay(15);  \n\t\tlocal_irq_save(flags);  \n\t\twriteccr(i2c, CCR_MEN | CCR_MSTA | CCR_RSTA);  \n\t\treadb(i2c->base + MPC_I2C_DR);\n\t\tif (k != 1)\n\t\t\tudelay(5);\n\t\tlocal_irq_restore(flags);\n\t}\n\twriteccr(i2c, CCR_MEN);  \n\treadb(i2c->base + MPC_I2C_DR);\n\tudelay(15);  \n\twriteccr(i2c, 0);\n}\n\nstatic int i2c_mpc_wait_sr(struct mpc_i2c *i2c, int mask)\n{\n\tvoid __iomem *addr = i2c->base + MPC_I2C_SR;\n\tu8 val;\n\n\treturn readb_poll_timeout(addr, val, val & mask, 0, 100);\n}\n\n \nstatic void mpc_i2c_fixup_A004447(struct mpc_i2c *i2c)\n{\n\tint ret;\n\tu32 val;\n\n\twriteccr(i2c, CCR_MEN | CCR_MSTA);\n\tret = i2c_mpc_wait_sr(i2c, CSR_MBB);\n\tif (ret) {\n\t\tdev_err(i2c->dev, \"timeout waiting for CSR_MBB\\n\");\n\t\treturn;\n\t}\n\n\tval = readb(i2c->base + MPC_I2C_SR);\n\n\tif (val & CSR_MAL) {\n\t\twriteccr(i2c, 0x00);\n\t\twriteccr(i2c, CCR_MSTA | CCR_RSVD);\n\t\twriteccr(i2c, CCR_MEN | CCR_MSTA | CCR_RSVD);\n\t\tret = i2c_mpc_wait_sr(i2c, CSR_MBB);\n\t\tif (ret) {\n\t\t\tdev_err(i2c->dev, \"timeout waiting for CSR_MBB\\n\");\n\t\t\treturn;\n\t\t}\n\t\tval = readb(i2c->base + MPC_I2C_DR);\n\t\tret = i2c_mpc_wait_sr(i2c, CSR_MIF);\n\t\tif (ret) {\n\t\t\tdev_err(i2c->dev, \"timeout waiting for CSR_MIF\\n\");\n\t\t\treturn;\n\t\t}\n\t\twriteccr(i2c, CCR_MEN | CCR_RSVD);\n\t} else {\n\t\tval = readb(i2c->base + MPC_I2C_DR);\n\t\tret = i2c_mpc_wait_sr(i2c, CSR_MIF);\n\t\tif (ret) {\n\t\t\tdev_err(i2c->dev, \"timeout waiting for CSR_MIF\\n\");\n\t\t\treturn;\n\t\t}\n\t\twriteccr(i2c, CCR_MEN);\n\t}\n}\n\n#if defined(CONFIG_PPC_MPC52xx) || defined(CONFIG_PPC_MPC512x)\nstatic const struct mpc_i2c_divider mpc_i2c_dividers_52xx[] = {\n\t{20, 0x20}, {22, 0x21}, {24, 0x22}, {26, 0x23},\n\t{28, 0x24}, {30, 0x01}, {32, 0x25}, {34, 0x02},\n\t{36, 0x26}, {40, 0x27}, {44, 0x04}, {48, 0x28},\n\t{52, 0x63}, {56, 0x29}, {60, 0x41}, {64, 0x2a},\n\t{68, 0x07}, {72, 0x2b}, {80, 0x2c}, {88, 0x09},\n\t{96, 0x2d}, {104, 0x0a}, {112, 0x2e}, {120, 0x81},\n\t{128, 0x2f}, {136, 0x47}, {144, 0x0c}, {160, 0x30},\n\t{176, 0x49}, {192, 0x31}, {208, 0x4a}, {224, 0x32},\n\t{240, 0x0f}, {256, 0x33}, {272, 0x87}, {288, 0x10},\n\t{320, 0x34}, {352, 0x89}, {384, 0x35}, {416, 0x8a},\n\t{448, 0x36}, {480, 0x13}, {512, 0x37}, {576, 0x14},\n\t{640, 0x38}, {768, 0x39}, {896, 0x3a}, {960, 0x17},\n\t{1024, 0x3b}, {1152, 0x18}, {1280, 0x3c}, {1536, 0x3d},\n\t{1792, 0x3e}, {1920, 0x1b}, {2048, 0x3f}, {2304, 0x1c},\n\t{2560, 0x1d}, {3072, 0x1e}, {3584, 0x7e}, {3840, 0x1f},\n\t{4096, 0x7f}, {4608, 0x5c}, {5120, 0x5d}, {6144, 0x5e},\n\t{7168, 0xbe}, {7680, 0x5f}, {8192, 0xbf}, {9216, 0x9c},\n\t{10240, 0x9d}, {12288, 0x9e}, {15360, 0x9f}\n};\n\nstatic int mpc_i2c_get_fdr_52xx(struct device_node *node, u32 clock,\n\t\t\t\t\t  u32 *real_clk)\n{\n\tstruct fwnode_handle *fwnode = of_fwnode_handle(node);\n\tconst struct mpc_i2c_divider *div = NULL;\n\tunsigned int pvr = mfspr(SPRN_PVR);\n\tu32 divider;\n\tint i;\n\n\tif (clock == MPC_I2C_CLOCK_LEGACY) {\n\t\t \n\t\t*real_clk = mpc5xxx_fwnode_get_bus_frequency(fwnode) / 2048;\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tdivider = mpc5xxx_fwnode_get_bus_frequency(fwnode) / clock;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(mpc_i2c_dividers_52xx); i++) {\n\t\tdiv = &mpc_i2c_dividers_52xx[i];\n\t\t \n\t\tif (div->fdr & 0xc0 && pvr == 0x80822011)\n\t\t\tcontinue;\n\t\tif (div->divider >= divider)\n\t\t\tbreak;\n\t}\n\n\t*real_clk = mpc5xxx_fwnode_get_bus_frequency(fwnode) / div->divider;\n\treturn (int)div->fdr;\n}\n\nstatic void mpc_i2c_setup_52xx(struct device_node *node,\n\t\t\t\t\t struct mpc_i2c *i2c,\n\t\t\t\t\t u32 clock)\n{\n\tint ret, fdr;\n\n\tif (clock == MPC_I2C_CLOCK_PRESERVE) {\n\t\tdev_dbg(i2c->dev, \"using fdr %d\\n\",\n\t\t\treadb(i2c->base + MPC_I2C_FDR));\n\t\treturn;\n\t}\n\n\tret = mpc_i2c_get_fdr_52xx(node, clock, &i2c->real_clk);\n\tfdr = (ret >= 0) ? ret : 0x3f;  \n\n\twriteb(fdr & 0xff, i2c->base + MPC_I2C_FDR);\n\n\tif (ret >= 0)\n\t\tdev_info(i2c->dev, \"clock %u Hz (fdr=%d)\\n\", i2c->real_clk,\n\t\t\t fdr);\n}\n#else  \nstatic void mpc_i2c_setup_52xx(struct device_node *node,\n\t\t\t\t\t struct mpc_i2c *i2c,\n\t\t\t\t\t u32 clock)\n{\n}\n#endif  \n\n#ifdef CONFIG_PPC_MPC512x\nstatic void mpc_i2c_setup_512x(struct device_node *node,\n\t\t\t\t\t struct mpc_i2c *i2c,\n\t\t\t\t\t u32 clock)\n{\n\tstruct device_node *node_ctrl;\n\tvoid __iomem *ctrl;\n\tu32 idx;\n\n\t \n\tnode_ctrl = of_find_compatible_node(NULL, NULL,\n\t\t\t\t\t    \"fsl,mpc5121-i2c-ctrl\");\n\tif (node_ctrl) {\n\t\tctrl = of_iomap(node_ctrl, 0);\n\t\tif (ctrl) {\n\t\t\tu64 addr;\n\t\t\t \n\t\t\tof_property_read_reg(node, 0, &addr, NULL);\n\t\t\tidx = (addr & 0xff) / 0x20;\n\t\t\tsetbits32(ctrl, 1 << (24 + idx * 2));\n\t\t\tiounmap(ctrl);\n\t\t}\n\t\tof_node_put(node_ctrl);\n\t}\n\n\t \n\tmpc_i2c_setup_52xx(node, i2c, clock);\n}\n#else  \nstatic void mpc_i2c_setup_512x(struct device_node *node,\n\t\t\t\t\t struct mpc_i2c *i2c,\n\t\t\t\t\t u32 clock)\n{\n}\n#endif  \n\n#ifdef CONFIG_FSL_SOC\nstatic const struct mpc_i2c_divider mpc_i2c_dividers_8xxx[] = {\n\t{160, 0x0120}, {192, 0x0121}, {224, 0x0122}, {256, 0x0123},\n\t{288, 0x0100}, {320, 0x0101}, {352, 0x0601}, {384, 0x0102},\n\t{416, 0x0602}, {448, 0x0126}, {480, 0x0103}, {512, 0x0127},\n\t{544, 0x0b03}, {576, 0x0104}, {608, 0x1603}, {640, 0x0105},\n\t{672, 0x2003}, {704, 0x0b05}, {736, 0x2b03}, {768, 0x0106},\n\t{800, 0x3603}, {832, 0x0b06}, {896, 0x012a}, {960, 0x0107},\n\t{1024, 0x012b}, {1088, 0x1607}, {1152, 0x0108}, {1216, 0x2b07},\n\t{1280, 0x0109}, {1408, 0x1609}, {1536, 0x010a}, {1664, 0x160a},\n\t{1792, 0x012e}, {1920, 0x010b}, {2048, 0x012f}, {2176, 0x2b0b},\n\t{2304, 0x010c}, {2560, 0x010d}, {2816, 0x2b0d}, {3072, 0x010e},\n\t{3328, 0x2b0e}, {3584, 0x0132}, {3840, 0x010f}, {4096, 0x0133},\n\t{4608, 0x0110}, {5120, 0x0111}, {6144, 0x0112}, {7168, 0x0136},\n\t{7680, 0x0113}, {8192, 0x0137}, {9216, 0x0114}, {10240, 0x0115},\n\t{12288, 0x0116}, {14336, 0x013a}, {15360, 0x0117}, {16384, 0x013b},\n\t{18432, 0x0118}, {20480, 0x0119}, {24576, 0x011a}, {28672, 0x013e},\n\t{30720, 0x011b}, {32768, 0x013f}, {36864, 0x011c}, {40960, 0x011d},\n\t{49152, 0x011e}, {61440, 0x011f}\n};\n\nstatic u32 mpc_i2c_get_sec_cfg_8xxx(void)\n{\n\tstruct device_node *node;\n\tu32 __iomem *reg;\n\tu32 val = 0;\n\n\tnode = of_find_node_by_name(NULL, \"global-utilities\");\n\tif (node) {\n\t\tconst u32 *prop = of_get_property(node, \"reg\", NULL);\n\t\tif (prop) {\n\t\t\t \n\t\t\treg = ioremap(get_immrbase() + *prop + 0x14, 0x4);\n\t\t\tif (!reg)\n\t\t\t\tprintk(KERN_ERR\n\t\t\t\t       \"Error: couldn't map PORDEVSR2\\n\");\n\t\t\telse\n\t\t\t\tval = in_be32(reg) & 0x00000020;  \n\t\t\tiounmap(reg);\n\t\t}\n\t}\n\tof_node_put(node);\n\n\treturn val;\n}\n\nstatic u32 mpc_i2c_get_prescaler_8xxx(void)\n{\n\t \n\tu32 prescaler = 1;\n\n\t \n\tif (pvr_version_is(PVR_VER_E500V1) || pvr_version_is(PVR_VER_E500V2)\n\t\t|| pvr_version_is(PVR_VER_E500MC)\n\t\t|| pvr_version_is(PVR_VER_E5500)\n\t\t|| pvr_version_is(PVR_VER_E6500)) {\n\t\tunsigned int svr = mfspr(SPRN_SVR);\n\n\t\tif ((SVR_SOC_VER(svr) == SVR_8540)\n\t\t\t|| (SVR_SOC_VER(svr) == SVR_8541)\n\t\t\t|| (SVR_SOC_VER(svr) == SVR_8560)\n\t\t\t|| (SVR_SOC_VER(svr) == SVR_8555)\n\t\t\t|| (SVR_SOC_VER(svr) == SVR_8610))\n\t\t\t \n\t\t\tprescaler = 1;\n\t\telse if ((SVR_SOC_VER(svr) == SVR_8533)\n\t\t\t|| (SVR_SOC_VER(svr) == SVR_8544))\n\t\t\t \n\t\t\tprescaler = mpc_i2c_get_sec_cfg_8xxx() ? 3 : 2;\n\t\telse\n\t\t\t \n\t\t\tprescaler = 2;\n\t}\n\n\treturn prescaler;\n}\n\nstatic int mpc_i2c_get_fdr_8xxx(struct device_node *node, u32 clock,\n\t\t\t\t\t  u32 *real_clk)\n{\n\tconst struct mpc_i2c_divider *div = NULL;\n\tu32 prescaler = mpc_i2c_get_prescaler_8xxx();\n\tu32 divider;\n\tint i;\n\n\tif (clock == MPC_I2C_CLOCK_LEGACY) {\n\t\t \n\t\t*real_clk = fsl_get_sys_freq() / prescaler / (16 * 3072);\n\t\treturn -EINVAL;\n\t}\n\n\tdivider = fsl_get_sys_freq() / clock / prescaler;\n\n\tpr_debug(\"I2C: src_clock=%d clock=%d divider=%d\\n\",\n\t\t fsl_get_sys_freq(), clock, divider);\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(mpc_i2c_dividers_8xxx); i++) {\n\t\tdiv = &mpc_i2c_dividers_8xxx[i];\n\t\tif (div->divider >= divider)\n\t\t\tbreak;\n\t}\n\n\t*real_clk = fsl_get_sys_freq() / prescaler / div->divider;\n\treturn (int)div->fdr;\n}\n\nstatic void mpc_i2c_setup_8xxx(struct device_node *node,\n\t\t\t\t\t struct mpc_i2c *i2c,\n\t\t\t\t\t u32 clock)\n{\n\tint ret, fdr;\n\n\tif (clock == MPC_I2C_CLOCK_PRESERVE) {\n\t\tdev_dbg(i2c->dev, \"using dfsrr %d, fdr %d\\n\",\n\t\t\treadb(i2c->base + MPC_I2C_DFSRR),\n\t\t\treadb(i2c->base + MPC_I2C_FDR));\n\t\treturn;\n\t}\n\n\tret = mpc_i2c_get_fdr_8xxx(node, clock, &i2c->real_clk);\n\tfdr = (ret >= 0) ? ret : 0x1031;  \n\n\twriteb(fdr & 0xff, i2c->base + MPC_I2C_FDR);\n\twriteb((fdr >> 8) & 0xff, i2c->base + MPC_I2C_DFSRR);\n\n\tif (ret >= 0)\n\t\tdev_info(i2c->dev, \"clock %d Hz (dfsrr=%d fdr=%d)\\n\",\n\t\t\t i2c->real_clk, fdr >> 8, fdr & 0xff);\n}\n\n#else  \nstatic void mpc_i2c_setup_8xxx(struct device_node *node,\n\t\t\t\t\t struct mpc_i2c *i2c,\n\t\t\t\t\t u32 clock)\n{\n}\n#endif  \n\nstatic void mpc_i2c_finish(struct mpc_i2c *i2c, int rc)\n{\n\ti2c->rc = rc;\n\ti2c->block = 0;\n\ti2c->cntl_bits = CCR_MEN;\n\twriteccr(i2c, i2c->cntl_bits);\n\twake_up(&i2c->waitq);\n}\n\nstatic void mpc_i2c_do_action(struct mpc_i2c *i2c)\n{\n\tstruct i2c_msg *msg = NULL;\n\tint dir = 0;\n\tint recv_len = 0;\n\tu8 byte;\n\n\tdev_dbg(i2c->dev, \"action = %s\\n\", action_str[i2c->action]);\n\n\ti2c->cntl_bits &= ~(CCR_RSTA | CCR_MTX | CCR_TXAK);\n\n\tif (i2c->action != MPC_I2C_ACTION_STOP) {\n\t\tmsg = &i2c->msgs[i2c->curr_msg];\n\t\tif (msg->flags & I2C_M_RD)\n\t\t\tdir = 1;\n\t\tif (msg->flags & I2C_M_RECV_LEN)\n\t\t\trecv_len = 1;\n\t}\n\n\tswitch (i2c->action) {\n\tcase MPC_I2C_ACTION_RESTART:\n\t\ti2c->cntl_bits |= CCR_RSTA;\n\t\tfallthrough;\n\n\tcase MPC_I2C_ACTION_START:\n\t\ti2c->cntl_bits |= CCR_MSTA | CCR_MTX;\n\t\twriteccr(i2c, i2c->cntl_bits);\n\t\twriteb((msg->addr << 1) | dir, i2c->base + MPC_I2C_DR);\n\t\ti2c->expect_rxack = 1;\n\t\ti2c->action = dir ? MPC_I2C_ACTION_READ_BEGIN : MPC_I2C_ACTION_WRITE;\n\t\tbreak;\n\n\tcase MPC_I2C_ACTION_READ_BEGIN:\n\t\tif (msg->len) {\n\t\t\tif (msg->len == 1 && !(msg->flags & I2C_M_RECV_LEN))\n\t\t\t\ti2c->cntl_bits |= CCR_TXAK;\n\n\t\t\twriteccr(i2c, i2c->cntl_bits);\n\t\t\t \n\t\t\treadb(i2c->base + MPC_I2C_DR);\n\t\t}\n\t\ti2c->action = MPC_I2C_ACTION_READ_BYTE;\n\t\tbreak;\n\n\tcase MPC_I2C_ACTION_READ_BYTE:\n\t\tif (i2c->byte_posn || !recv_len) {\n\t\t\t \n\t\t\tif (i2c->byte_posn == msg->len - 2)\n\t\t\t\ti2c->cntl_bits |= CCR_TXAK;\n\t\t\t \n\t\t\tif (i2c->byte_posn == msg->len - 1)\n\t\t\t\ti2c->cntl_bits |= CCR_MTX;\n\n\t\t\twriteccr(i2c, i2c->cntl_bits);\n\t\t}\n\n\t\tbyte = readb(i2c->base + MPC_I2C_DR);\n\n\t\tif (i2c->byte_posn == 0 && recv_len) {\n\t\t\tif (byte == 0 || byte > I2C_SMBUS_BLOCK_MAX) {\n\t\t\t\tmpc_i2c_finish(i2c, -EPROTO);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tmsg->len += byte;\n\t\t\t \n\t\t\tif (msg->len == 2) {\n\t\t\t\ti2c->cntl_bits |= CCR_TXAK;\n\t\t\t\twriteccr(i2c, i2c->cntl_bits);\n\t\t\t}\n\t\t}\n\n\t\tdev_dbg(i2c->dev, \"%s %02x\\n\", action_str[i2c->action], byte);\n\t\tmsg->buf[i2c->byte_posn++] = byte;\n\t\tbreak;\n\n\tcase MPC_I2C_ACTION_WRITE:\n\t\tdev_dbg(i2c->dev, \"%s %02x\\n\", action_str[i2c->action],\n\t\t\tmsg->buf[i2c->byte_posn]);\n\t\twriteb(msg->buf[i2c->byte_posn++], i2c->base + MPC_I2C_DR);\n\t\ti2c->expect_rxack = 1;\n\t\tbreak;\n\n\tcase MPC_I2C_ACTION_STOP:\n\t\tmpc_i2c_finish(i2c, 0);\n\t\tbreak;\n\n\tdefault:\n\t\tWARN(1, \"Unexpected action %d\\n\", i2c->action);\n\t\tbreak;\n\t}\n\n\tif (msg && msg->len == i2c->byte_posn) {\n\t\ti2c->curr_msg++;\n\t\ti2c->byte_posn = 0;\n\n\t\tif (i2c->curr_msg == i2c->num_msgs) {\n\t\t\ti2c->action = MPC_I2C_ACTION_STOP;\n\t\t\t \n\t\t\tif (dir)\n\t\t\t\tmpc_i2c_finish(i2c, 0);\n\t\t} else {\n\t\t\ti2c->action = MPC_I2C_ACTION_RESTART;\n\t\t}\n\t}\n}\n\nstatic void mpc_i2c_do_intr(struct mpc_i2c *i2c, u8 status)\n{\n\tspin_lock(&i2c->lock);\n\n\tif (!(status & CSR_MCF)) {\n\t\tdev_dbg(i2c->dev, \"unfinished\\n\");\n\t\tmpc_i2c_finish(i2c, -EIO);\n\t\tgoto out;\n\t}\n\n\tif (status & CSR_MAL) {\n\t\tdev_dbg(i2c->dev, \"arbitration lost\\n\");\n\t\tmpc_i2c_finish(i2c, -EAGAIN);\n\t\tgoto out;\n\t}\n\n\tif (i2c->expect_rxack && (status & CSR_RXAK)) {\n\t\tdev_dbg(i2c->dev, \"no Rx ACK\\n\");\n\t\tmpc_i2c_finish(i2c, -ENXIO);\n\t\tgoto out;\n\t}\n\ti2c->expect_rxack = 0;\n\n\tmpc_i2c_do_action(i2c);\n\nout:\n\tspin_unlock(&i2c->lock);\n}\n\nstatic irqreturn_t mpc_i2c_isr(int irq, void *dev_id)\n{\n\tstruct mpc_i2c *i2c = dev_id;\n\tu8 status;\n\n\tstatus = readb(i2c->base + MPC_I2C_SR);\n\tif (status & CSR_MIF) {\n\t\t \n\t\treadb_poll_timeout_atomic(i2c->base + MPC_I2C_SR, status, status & CSR_MCF, 0, 100);\n\t\twriteb(0, i2c->base + MPC_I2C_SR);\n\t\tmpc_i2c_do_intr(i2c, status);\n\t\treturn IRQ_HANDLED;\n\t}\n\treturn IRQ_NONE;\n}\n\nstatic int mpc_i2c_wait_for_completion(struct mpc_i2c *i2c)\n{\n\tlong time_left;\n\n\ttime_left = wait_event_timeout(i2c->waitq, !i2c->block, i2c->adap.timeout);\n\tif (!time_left)\n\t\treturn -ETIMEDOUT;\n\tif (time_left < 0)\n\t\treturn time_left;\n\n\treturn 0;\n}\n\nstatic int mpc_i2c_execute_msg(struct mpc_i2c *i2c)\n{\n\tunsigned long orig_jiffies;\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&i2c->lock, flags);\n\n\ti2c->curr_msg = 0;\n\ti2c->rc = 0;\n\ti2c->byte_posn = 0;\n\ti2c->block = 1;\n\ti2c->action = MPC_I2C_ACTION_START;\n\n\ti2c->cntl_bits = CCR_MEN | CCR_MIEN;\n\twriteb(0, i2c->base + MPC_I2C_SR);\n\twriteccr(i2c, i2c->cntl_bits);\n\n\tmpc_i2c_do_action(i2c);\n\n\tspin_unlock_irqrestore(&i2c->lock, flags);\n\n\tret = mpc_i2c_wait_for_completion(i2c);\n\tif (ret)\n\t\ti2c->rc = ret;\n\n\tif (i2c->rc == -EIO || i2c->rc == -EAGAIN || i2c->rc == -ETIMEDOUT)\n\t\ti2c_recover_bus(&i2c->adap);\n\n\torig_jiffies = jiffies;\n\t \n\twhile (readb(i2c->base + MPC_I2C_SR) & CSR_MBB) {\n\t\tif (time_after(jiffies, orig_jiffies + HZ)) {\n\t\t\tu8 status = readb(i2c->base + MPC_I2C_SR);\n\n\t\t\tdev_dbg(i2c->dev, \"timeout\\n\");\n\t\t\tif ((status & (CSR_MCF | CSR_MBB | CSR_RXAK)) != 0) {\n\t\t\t\twriteb(status & ~CSR_MAL,\n\t\t\t\t       i2c->base + MPC_I2C_SR);\n\t\t\t\ti2c_recover_bus(&i2c->adap);\n\t\t\t}\n\t\t\treturn -EIO;\n\t\t}\n\t\tcond_resched();\n\t}\n\n\treturn i2c->rc;\n}\n\nstatic int mpc_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)\n{\n\tint rc, ret = num;\n\tstruct mpc_i2c *i2c = i2c_get_adapdata(adap);\n\tint i;\n\n\tdev_dbg(i2c->dev, \"num = %d\\n\", num);\n\tfor (i = 0; i < num; i++)\n\t\tdev_dbg(i2c->dev, \"  addr = %02x, flags = %02x, len = %d, %*ph\\n\",\n\t\t\tmsgs[i].addr, msgs[i].flags, msgs[i].len,\n\t\t\tmsgs[i].flags & I2C_M_RD ? 0 : msgs[i].len,\n\t\t\tmsgs[i].buf);\n\n\tWARN_ON(i2c->msgs != NULL);\n\ti2c->msgs = msgs;\n\ti2c->num_msgs = num;\n\n\trc = mpc_i2c_execute_msg(i2c);\n\tif (rc < 0)\n\t\tret = rc;\n\n\ti2c->num_msgs = 0;\n\ti2c->msgs = NULL;\n\n\treturn ret;\n}\n\nstatic u32 mpc_functionality(struct i2c_adapter *adap)\n{\n\treturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL\n\t  | I2C_FUNC_SMBUS_READ_BLOCK_DATA | I2C_FUNC_SMBUS_BLOCK_PROC_CALL;\n}\n\nstatic int fsl_i2c_bus_recovery(struct i2c_adapter *adap)\n{\n\tstruct mpc_i2c *i2c = i2c_get_adapdata(adap);\n\n\tif (i2c->has_errata_A004447)\n\t\tmpc_i2c_fixup_A004447(i2c);\n\telse\n\t\tmpc_i2c_fixup(i2c);\n\n\treturn 0;\n}\n\nstatic const struct i2c_algorithm mpc_algo = {\n\t.master_xfer = mpc_xfer,\n\t.functionality = mpc_functionality,\n};\n\nstatic struct i2c_adapter mpc_ops = {\n\t.owner = THIS_MODULE,\n\t.algo = &mpc_algo,\n};\n\nstatic struct i2c_bus_recovery_info fsl_i2c_recovery_info = {\n\t.recover_bus = fsl_i2c_bus_recovery,\n};\n\nstatic int fsl_i2c_probe(struct platform_device *op)\n{\n\tconst struct mpc_i2c_data *data;\n\tstruct mpc_i2c *i2c;\n\tstruct clk *clk;\n\tint result;\n\tu32 clock;\n\tint err;\n\n\ti2c = devm_kzalloc(&op->dev, sizeof(*i2c), GFP_KERNEL);\n\tif (!i2c)\n\t\treturn -ENOMEM;\n\n\ti2c->dev = &op->dev;  \n\n\tinit_waitqueue_head(&i2c->waitq);\n\tspin_lock_init(&i2c->lock);\n\n\ti2c->base = devm_platform_ioremap_resource(op, 0);\n\tif (IS_ERR(i2c->base))\n\t\treturn PTR_ERR(i2c->base);\n\n\ti2c->irq = platform_get_irq(op, 0);\n\tif (i2c->irq < 0)\n\t\treturn i2c->irq;\n\n\tresult = devm_request_irq(&op->dev, i2c->irq, mpc_i2c_isr,\n\t\t\tIRQF_SHARED, \"i2c-mpc\", i2c);\n\tif (result < 0) {\n\t\tdev_err(i2c->dev, \"failed to attach interrupt\\n\");\n\t\treturn result;\n\t}\n\n\t \n\tclk = devm_clk_get_optional(&op->dev, NULL);\n\tif (IS_ERR(clk))\n\t\treturn PTR_ERR(clk);\n\n\terr = clk_prepare_enable(clk);\n\tif (err) {\n\t\tdev_err(&op->dev, \"failed to enable clock\\n\");\n\t\treturn err;\n\t}\n\n\ti2c->clk_per = clk;\n\n\tif (of_property_read_bool(op->dev.of_node, \"fsl,preserve-clocking\")) {\n\t\tclock = MPC_I2C_CLOCK_PRESERVE;\n\t} else {\n\t\tresult = of_property_read_u32(op->dev.of_node,\n\t\t\t\t\t      \"clock-frequency\", &clock);\n\t\tif (result)\n\t\t\tclock = MPC_I2C_CLOCK_LEGACY;\n\t}\n\n\tdata = device_get_match_data(&op->dev);\n\tif (data) {\n\t\tdata->setup(op->dev.of_node, i2c, clock);\n\t} else {\n\t\t \n\t\tif (of_property_read_bool(op->dev.of_node, \"dfsrr\"))\n\t\t\tmpc_i2c_setup_8xxx(op->dev.of_node, i2c, clock);\n\t}\n\n\t \n\tresult = of_property_read_u32(op->dev.of_node,\n\t\t\t\t      \"i2c-scl-clk-low-timeout-us\",\n\t\t\t\t      &mpc_ops.timeout);\n\tif (result == -EINVAL)\n\t\tresult = of_property_read_u32(op->dev.of_node,\n\t\t\t\t\t      \"fsl,timeout\", &mpc_ops.timeout);\n\n\tif (!result) {\n\t\tmpc_ops.timeout *= HZ / 1000000;\n\t\tif (mpc_ops.timeout < 5)\n\t\t\tmpc_ops.timeout = 5;\n\t} else {\n\t\tmpc_ops.timeout = HZ;\n\t}\n\n\tdev_info(i2c->dev, \"timeout %u us\\n\", mpc_ops.timeout * 1000000 / HZ);\n\n\tif (of_property_read_bool(op->dev.of_node, \"fsl,i2c-erratum-a004447\"))\n\t\ti2c->has_errata_A004447 = true;\n\n\ti2c->adap = mpc_ops;\n\tscnprintf(i2c->adap.name, sizeof(i2c->adap.name),\n\t\t  \"MPC adapter (%s)\", of_node_full_name(op->dev.of_node));\n\ti2c->adap.dev.parent = &op->dev;\n\ti2c->adap.nr = op->id;\n\ti2c->adap.dev.of_node = of_node_get(op->dev.of_node);\n\ti2c->adap.bus_recovery_info = &fsl_i2c_recovery_info;\n\tplatform_set_drvdata(op, i2c);\n\ti2c_set_adapdata(&i2c->adap, i2c);\n\n\tresult = i2c_add_numbered_adapter(&i2c->adap);\n\tif (result)\n\t\tgoto fail_add;\n\n\treturn 0;\n\n fail_add:\n\tclk_disable_unprepare(i2c->clk_per);\n\n\treturn result;\n};\n\nstatic void fsl_i2c_remove(struct platform_device *op)\n{\n\tstruct mpc_i2c *i2c = platform_get_drvdata(op);\n\n\ti2c_del_adapter(&i2c->adap);\n\n\tclk_disable_unprepare(i2c->clk_per);\n};\n\nstatic int __maybe_unused mpc_i2c_suspend(struct device *dev)\n{\n\tstruct mpc_i2c *i2c = dev_get_drvdata(dev);\n\n\ti2c->fdr = readb(i2c->base + MPC_I2C_FDR);\n\ti2c->dfsrr = readb(i2c->base + MPC_I2C_DFSRR);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused mpc_i2c_resume(struct device *dev)\n{\n\tstruct mpc_i2c *i2c = dev_get_drvdata(dev);\n\n\twriteb(i2c->fdr, i2c->base + MPC_I2C_FDR);\n\twriteb(i2c->dfsrr, i2c->base + MPC_I2C_DFSRR);\n\n\treturn 0;\n}\nstatic SIMPLE_DEV_PM_OPS(mpc_i2c_pm_ops, mpc_i2c_suspend, mpc_i2c_resume);\n\nstatic const struct mpc_i2c_data mpc_i2c_data_512x = {\n\t.setup = mpc_i2c_setup_512x,\n};\n\nstatic const struct mpc_i2c_data mpc_i2c_data_52xx = {\n\t.setup = mpc_i2c_setup_52xx,\n};\n\nstatic const struct mpc_i2c_data mpc_i2c_data_8313 = {\n\t.setup = mpc_i2c_setup_8xxx,\n};\n\nstatic const struct mpc_i2c_data mpc_i2c_data_8543 = {\n\t.setup = mpc_i2c_setup_8xxx,\n};\n\nstatic const struct mpc_i2c_data mpc_i2c_data_8544 = {\n\t.setup = mpc_i2c_setup_8xxx,\n};\n\nstatic const struct of_device_id mpc_i2c_of_match[] = {\n\t{.compatible = \"mpc5200-i2c\", .data = &mpc_i2c_data_52xx, },\n\t{.compatible = \"fsl,mpc5200b-i2c\", .data = &mpc_i2c_data_52xx, },\n\t{.compatible = \"fsl,mpc5200-i2c\", .data = &mpc_i2c_data_52xx, },\n\t{.compatible = \"fsl,mpc5121-i2c\", .data = &mpc_i2c_data_512x, },\n\t{.compatible = \"fsl,mpc8313-i2c\", .data = &mpc_i2c_data_8313, },\n\t{.compatible = \"fsl,mpc8543-i2c\", .data = &mpc_i2c_data_8543, },\n\t{.compatible = \"fsl,mpc8544-i2c\", .data = &mpc_i2c_data_8544, },\n\t \n\t{.compatible = \"fsl-i2c\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, mpc_i2c_of_match);\n\n \nstatic struct platform_driver mpc_i2c_driver = {\n\t.probe\t\t= fsl_i2c_probe,\n\t.remove_new\t= fsl_i2c_remove,\n\t.driver = {\n\t\t.name = DRV_NAME,\n\t\t.of_match_table = mpc_i2c_of_match,\n\t\t.pm = &mpc_i2c_pm_ops,\n\t},\n};\n\nmodule_platform_driver(mpc_i2c_driver);\n\nMODULE_AUTHOR(\"Adrian Cox <adrian@humboldt.co.uk>\");\nMODULE_DESCRIPTION(\"I2C-Bus adapter for MPC107 bridge and \"\n\t\t   \"MPC824x/83xx/85xx/86xx/512x/52xx processors\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}