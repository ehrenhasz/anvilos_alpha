{
  "module_name": "i2c-stm32f7.c",
  "hash_id": "4699af27521c1bbdaf1fd5fa52c2f5e817af1dfb962dc16e0c464267e6adf309",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-stm32f7.c",
  "human_readable_source": "\n \n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/i2c.h>\n#include <linux/i2c-smbus.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/pm_runtime.h>\n#include <linux/pm_wakeirq.h>\n#include <linux/regmap.h>\n#include <linux/reset.h>\n#include <linux/slab.h>\n\n#include \"i2c-stm32.h\"\n\n \n#define STM32F7_I2C_CR1\t\t\t\t0x00\n#define STM32F7_I2C_CR2\t\t\t\t0x04\n#define STM32F7_I2C_OAR1\t\t\t0x08\n#define STM32F7_I2C_OAR2\t\t\t0x0C\n#define STM32F7_I2C_PECR\t\t\t0x20\n#define STM32F7_I2C_TIMINGR\t\t\t0x10\n#define STM32F7_I2C_ISR\t\t\t\t0x18\n#define STM32F7_I2C_ICR\t\t\t\t0x1C\n#define STM32F7_I2C_RXDR\t\t\t0x24\n#define STM32F7_I2C_TXDR\t\t\t0x28\n\n \n#define STM32F7_I2C_CR1_PECEN\t\t\tBIT(23)\n#define STM32F7_I2C_CR1_ALERTEN\t\t\tBIT(22)\n#define STM32F7_I2C_CR1_SMBHEN\t\t\tBIT(20)\n#define STM32F7_I2C_CR1_WUPEN\t\t\tBIT(18)\n#define STM32F7_I2C_CR1_SBC\t\t\tBIT(16)\n#define STM32F7_I2C_CR1_RXDMAEN\t\t\tBIT(15)\n#define STM32F7_I2C_CR1_TXDMAEN\t\t\tBIT(14)\n#define STM32F7_I2C_CR1_ANFOFF\t\t\tBIT(12)\n#define STM32F7_I2C_CR1_DNF_MASK\t\tGENMASK(11, 8)\n#define STM32F7_I2C_CR1_DNF(n)\t\t\t(((n) & 0xf) << 8)\n#define STM32F7_I2C_CR1_ERRIE\t\t\tBIT(7)\n#define STM32F7_I2C_CR1_TCIE\t\t\tBIT(6)\n#define STM32F7_I2C_CR1_STOPIE\t\t\tBIT(5)\n#define STM32F7_I2C_CR1_NACKIE\t\t\tBIT(4)\n#define STM32F7_I2C_CR1_ADDRIE\t\t\tBIT(3)\n#define STM32F7_I2C_CR1_RXIE\t\t\tBIT(2)\n#define STM32F7_I2C_CR1_TXIE\t\t\tBIT(1)\n#define STM32F7_I2C_CR1_PE\t\t\tBIT(0)\n#define STM32F7_I2C_ALL_IRQ_MASK\t\t(STM32F7_I2C_CR1_ERRIE \\\n\t\t\t\t\t\t| STM32F7_I2C_CR1_TCIE \\\n\t\t\t\t\t\t| STM32F7_I2C_CR1_STOPIE \\\n\t\t\t\t\t\t| STM32F7_I2C_CR1_NACKIE \\\n\t\t\t\t\t\t| STM32F7_I2C_CR1_RXIE \\\n\t\t\t\t\t\t| STM32F7_I2C_CR1_TXIE)\n#define STM32F7_I2C_XFER_IRQ_MASK\t\t(STM32F7_I2C_CR1_TCIE \\\n\t\t\t\t\t\t| STM32F7_I2C_CR1_STOPIE \\\n\t\t\t\t\t\t| STM32F7_I2C_CR1_NACKIE \\\n\t\t\t\t\t\t| STM32F7_I2C_CR1_RXIE \\\n\t\t\t\t\t\t| STM32F7_I2C_CR1_TXIE)\n\n \n#define STM32F7_I2C_CR2_PECBYTE\t\t\tBIT(26)\n#define STM32F7_I2C_CR2_RELOAD\t\t\tBIT(24)\n#define STM32F7_I2C_CR2_NBYTES_MASK\t\tGENMASK(23, 16)\n#define STM32F7_I2C_CR2_NBYTES(n)\t\t(((n) & 0xff) << 16)\n#define STM32F7_I2C_CR2_NACK\t\t\tBIT(15)\n#define STM32F7_I2C_CR2_STOP\t\t\tBIT(14)\n#define STM32F7_I2C_CR2_START\t\t\tBIT(13)\n#define STM32F7_I2C_CR2_HEAD10R\t\t\tBIT(12)\n#define STM32F7_I2C_CR2_ADD10\t\t\tBIT(11)\n#define STM32F7_I2C_CR2_RD_WRN\t\t\tBIT(10)\n#define STM32F7_I2C_CR2_SADD10_MASK\t\tGENMASK(9, 0)\n#define STM32F7_I2C_CR2_SADD10(n)\t\t(((n) & \\\n\t\t\t\t\t\tSTM32F7_I2C_CR2_SADD10_MASK))\n#define STM32F7_I2C_CR2_SADD7_MASK\t\tGENMASK(7, 1)\n#define STM32F7_I2C_CR2_SADD7(n)\t\t(((n) & 0x7f) << 1)\n\n \n#define STM32F7_I2C_OAR1_OA1EN\t\t\tBIT(15)\n#define STM32F7_I2C_OAR1_OA1MODE\t\tBIT(10)\n#define STM32F7_I2C_OAR1_OA1_10_MASK\t\tGENMASK(9, 0)\n#define STM32F7_I2C_OAR1_OA1_10(n)\t\t(((n) & \\\n\t\t\t\t\t\tSTM32F7_I2C_OAR1_OA1_10_MASK))\n#define STM32F7_I2C_OAR1_OA1_7_MASK\t\tGENMASK(7, 1)\n#define STM32F7_I2C_OAR1_OA1_7(n)\t\t(((n) & 0x7f) << 1)\n#define STM32F7_I2C_OAR1_MASK\t\t\t(STM32F7_I2C_OAR1_OA1_7_MASK \\\n\t\t\t\t\t\t| STM32F7_I2C_OAR1_OA1_10_MASK \\\n\t\t\t\t\t\t| STM32F7_I2C_OAR1_OA1EN \\\n\t\t\t\t\t\t| STM32F7_I2C_OAR1_OA1MODE)\n\n \n#define STM32F7_I2C_OAR2_OA2EN\t\t\tBIT(15)\n#define STM32F7_I2C_OAR2_OA2MSK_MASK\t\tGENMASK(10, 8)\n#define STM32F7_I2C_OAR2_OA2MSK(n)\t\t(((n) & 0x7) << 8)\n#define STM32F7_I2C_OAR2_OA2_7_MASK\t\tGENMASK(7, 1)\n#define STM32F7_I2C_OAR2_OA2_7(n)\t\t(((n) & 0x7f) << 1)\n#define STM32F7_I2C_OAR2_MASK\t\t\t(STM32F7_I2C_OAR2_OA2MSK_MASK \\\n\t\t\t\t\t\t| STM32F7_I2C_OAR2_OA2_7_MASK \\\n\t\t\t\t\t\t| STM32F7_I2C_OAR2_OA2EN)\n\n \n#define STM32F7_I2C_ISR_ADDCODE_MASK\t\tGENMASK(23, 17)\n#define STM32F7_I2C_ISR_ADDCODE_GET(n) \\\n\t\t\t\t(((n) & STM32F7_I2C_ISR_ADDCODE_MASK) >> 17)\n#define STM32F7_I2C_ISR_DIR\t\t\tBIT(16)\n#define STM32F7_I2C_ISR_BUSY\t\t\tBIT(15)\n#define STM32F7_I2C_ISR_ALERT\t\t\tBIT(13)\n#define STM32F7_I2C_ISR_PECERR\t\t\tBIT(11)\n#define STM32F7_I2C_ISR_ARLO\t\t\tBIT(9)\n#define STM32F7_I2C_ISR_BERR\t\t\tBIT(8)\n#define STM32F7_I2C_ISR_TCR\t\t\tBIT(7)\n#define STM32F7_I2C_ISR_TC\t\t\tBIT(6)\n#define STM32F7_I2C_ISR_STOPF\t\t\tBIT(5)\n#define STM32F7_I2C_ISR_NACKF\t\t\tBIT(4)\n#define STM32F7_I2C_ISR_ADDR\t\t\tBIT(3)\n#define STM32F7_I2C_ISR_RXNE\t\t\tBIT(2)\n#define STM32F7_I2C_ISR_TXIS\t\t\tBIT(1)\n#define STM32F7_I2C_ISR_TXE\t\t\tBIT(0)\n\n \n#define STM32F7_I2C_ICR_ALERTCF\t\t\tBIT(13)\n#define STM32F7_I2C_ICR_PECCF\t\t\tBIT(11)\n#define STM32F7_I2C_ICR_ARLOCF\t\t\tBIT(9)\n#define STM32F7_I2C_ICR_BERRCF\t\t\tBIT(8)\n#define STM32F7_I2C_ICR_STOPCF\t\t\tBIT(5)\n#define STM32F7_I2C_ICR_NACKCF\t\t\tBIT(4)\n#define STM32F7_I2C_ICR_ADDRCF\t\t\tBIT(3)\n\n \n#define STM32F7_I2C_TIMINGR_PRESC(n)\t\t(((n) & 0xf) << 28)\n#define STM32F7_I2C_TIMINGR_SCLDEL(n)\t\t(((n) & 0xf) << 20)\n#define STM32F7_I2C_TIMINGR_SDADEL(n)\t\t(((n) & 0xf) << 16)\n#define STM32F7_I2C_TIMINGR_SCLH(n)\t\t(((n) & 0xff) << 8)\n#define STM32F7_I2C_TIMINGR_SCLL(n)\t\t((n) & 0xff)\n\n#define STM32F7_I2C_MAX_LEN\t\t\t0xff\n#define STM32F7_I2C_DMA_LEN_MIN\t\t\t0x16\nenum {\n\tSTM32F7_SLAVE_HOSTNOTIFY,\n\tSTM32F7_SLAVE_7_10_BITS_ADDR,\n\tSTM32F7_SLAVE_7_BITS_ADDR,\n\tSTM32F7_I2C_MAX_SLAVE\n};\n\n#define STM32F7_I2C_DNF_DEFAULT\t\t\t0\n#define STM32F7_I2C_DNF_MAX\t\t\t15\n\n#define STM32F7_I2C_ANALOG_FILTER_DELAY_MIN\t50\t \n#define STM32F7_I2C_ANALOG_FILTER_DELAY_MAX\t260\t \n\n#define STM32F7_I2C_RISE_TIME_DEFAULT\t\t25\t \n#define STM32F7_I2C_FALL_TIME_DEFAULT\t\t10\t \n\n#define STM32F7_PRESC_MAX\t\t\tBIT(4)\n#define STM32F7_SCLDEL_MAX\t\t\tBIT(4)\n#define STM32F7_SDADEL_MAX\t\t\tBIT(4)\n#define STM32F7_SCLH_MAX\t\t\tBIT(8)\n#define STM32F7_SCLL_MAX\t\t\tBIT(8)\n\n#define STM32F7_AUTOSUSPEND_DELAY\t\t(HZ / 100)\n\n \nstruct stm32f7_i2c_regs {\n\tu32 cr1;\n\tu32 cr2;\n\tu32 oar1;\n\tu32 oar2;\n\tu32 tmgr;\n};\n\n \nstruct stm32f7_i2c_spec {\n\tu32 rate;\n\tu32 fall_max;\n\tu32 rise_max;\n\tu32 hddat_min;\n\tu32 vddat_max;\n\tu32 sudat_min;\n\tu32 l_min;\n\tu32 h_min;\n};\n\n \nstruct stm32f7_i2c_setup {\n\tu32 speed_freq;\n\tu32 clock_src;\n\tu32 rise_time;\n\tu32 fall_time;\n\tu32 fmp_clr_offset;\n};\n\n \nstruct stm32f7_i2c_timings {\n\tstruct list_head node;\n\tu8 presc;\n\tu8 scldel;\n\tu8 sdadel;\n\tu8 sclh;\n\tu8 scll;\n};\n\n \nstruct stm32f7_i2c_msg {\n\tu16 addr;\n\tu32 count;\n\tu8 *buf;\n\tint result;\n\tbool stop;\n\tbool smbus;\n\tint size;\n\tchar read_write;\n\tu8 smbus_buf[I2C_SMBUS_BLOCK_MAX + 3] __aligned(4);\n};\n\n \nstruct stm32f7_i2c_alert {\n\tstruct i2c_smbus_alert_setup setup;\n\tstruct i2c_client *ara;\n};\n\n \nstruct stm32f7_i2c_dev {\n\tstruct i2c_adapter adap;\n\tstruct device *dev;\n\tvoid __iomem *base;\n\tstruct completion complete;\n\tstruct clk *clk;\n\tunsigned int bus_rate;\n\tstruct i2c_msg *msg;\n\tunsigned int msg_num;\n\tunsigned int msg_id;\n\tstruct stm32f7_i2c_msg f7_msg;\n\tstruct stm32f7_i2c_setup setup;\n\tstruct stm32f7_i2c_timings timing;\n\tstruct i2c_client *slave[STM32F7_I2C_MAX_SLAVE];\n\tstruct i2c_client *slave_running;\n\tstruct stm32f7_i2c_regs backup_regs;\n\tu32 slave_dir;\n\tbool master_mode;\n\tstruct stm32_i2c_dma *dma;\n\tbool use_dma;\n\tstruct regmap *regmap;\n\tu32 fmp_sreg;\n\tu32 fmp_creg;\n\tu32 fmp_mask;\n\tbool wakeup_src;\n\tbool smbus_mode;\n\tstruct i2c_client *host_notify_client;\n\tbool analog_filter;\n\tu32 dnf_dt;\n\tu32 dnf;\n\tstruct stm32f7_i2c_alert *alert;\n};\n\n \nstatic struct stm32f7_i2c_spec stm32f7_i2c_specs[] = {\n\t{\n\t\t.rate = I2C_MAX_STANDARD_MODE_FREQ,\n\t\t.fall_max = 300,\n\t\t.rise_max = 1000,\n\t\t.hddat_min = 0,\n\t\t.vddat_max = 3450,\n\t\t.sudat_min = 250,\n\t\t.l_min = 4700,\n\t\t.h_min = 4000,\n\t},\n\t{\n\t\t.rate = I2C_MAX_FAST_MODE_FREQ,\n\t\t.fall_max = 300,\n\t\t.rise_max = 300,\n\t\t.hddat_min = 0,\n\t\t.vddat_max = 900,\n\t\t.sudat_min = 100,\n\t\t.l_min = 1300,\n\t\t.h_min = 600,\n\t},\n\t{\n\t\t.rate = I2C_MAX_FAST_MODE_PLUS_FREQ,\n\t\t.fall_max = 100,\n\t\t.rise_max = 120,\n\t\t.hddat_min = 0,\n\t\t.vddat_max = 450,\n\t\t.sudat_min = 50,\n\t\t.l_min = 500,\n\t\t.h_min = 260,\n\t},\n};\n\nstatic const struct stm32f7_i2c_setup stm32f7_setup = {\n\t.rise_time = STM32F7_I2C_RISE_TIME_DEFAULT,\n\t.fall_time = STM32F7_I2C_FALL_TIME_DEFAULT,\n};\n\nstatic const struct stm32f7_i2c_setup stm32mp15_setup = {\n\t.rise_time = STM32F7_I2C_RISE_TIME_DEFAULT,\n\t.fall_time = STM32F7_I2C_FALL_TIME_DEFAULT,\n\t.fmp_clr_offset = 0x40,\n};\n\nstatic const struct stm32f7_i2c_setup stm32mp13_setup = {\n\t.rise_time = STM32F7_I2C_RISE_TIME_DEFAULT,\n\t.fall_time = STM32F7_I2C_FALL_TIME_DEFAULT,\n\t.fmp_clr_offset = 0x4,\n};\n\nstatic inline void stm32f7_i2c_set_bits(void __iomem *reg, u32 mask)\n{\n\twritel_relaxed(readl_relaxed(reg) | mask, reg);\n}\n\nstatic inline void stm32f7_i2c_clr_bits(void __iomem *reg, u32 mask)\n{\n\twritel_relaxed(readl_relaxed(reg) & ~mask, reg);\n}\n\nstatic void stm32f7_i2c_disable_irq(struct stm32f7_i2c_dev *i2c_dev, u32 mask)\n{\n\tstm32f7_i2c_clr_bits(i2c_dev->base + STM32F7_I2C_CR1, mask);\n}\n\nstatic struct stm32f7_i2c_spec *stm32f7_get_specs(u32 rate)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(stm32f7_i2c_specs); i++)\n\t\tif (rate <= stm32f7_i2c_specs[i].rate)\n\t\t\treturn &stm32f7_i2c_specs[i];\n\n\treturn ERR_PTR(-EINVAL);\n}\n\n#define\tRATE_MIN(rate)\t((rate) * 8 / 10)\nstatic int stm32f7_i2c_compute_timing(struct stm32f7_i2c_dev *i2c_dev,\n\t\t\t\t      struct stm32f7_i2c_setup *setup,\n\t\t\t\t      struct stm32f7_i2c_timings *output)\n{\n\tstruct stm32f7_i2c_spec *specs;\n\tu32 p_prev = STM32F7_PRESC_MAX;\n\tu32 i2cclk = DIV_ROUND_CLOSEST(NSEC_PER_SEC,\n\t\t\t\t       setup->clock_src);\n\tu32 i2cbus = DIV_ROUND_CLOSEST(NSEC_PER_SEC,\n\t\t\t\t       setup->speed_freq);\n\tu32 clk_error_prev = i2cbus;\n\tu32 tsync;\n\tu32 af_delay_min, af_delay_max;\n\tu32 dnf_delay;\n\tu32 clk_min, clk_max;\n\tint sdadel_min, sdadel_max;\n\tint scldel_min;\n\tstruct stm32f7_i2c_timings *v, *_v, *s;\n\tstruct list_head solutions;\n\tu16 p, l, a, h;\n\tint ret = 0;\n\n\tspecs = stm32f7_get_specs(setup->speed_freq);\n\tif (specs == ERR_PTR(-EINVAL)) {\n\t\tdev_err(i2c_dev->dev, \"speed out of bound {%d}\\n\",\n\t\t\tsetup->speed_freq);\n\t\treturn -EINVAL;\n\t}\n\n\tif ((setup->rise_time > specs->rise_max) ||\n\t    (setup->fall_time > specs->fall_max)) {\n\t\tdev_err(i2c_dev->dev,\n\t\t\t\"timings out of bound Rise{%d>%d}/Fall{%d>%d}\\n\",\n\t\t\tsetup->rise_time, specs->rise_max,\n\t\t\tsetup->fall_time, specs->fall_max);\n\t\treturn -EINVAL;\n\t}\n\n\ti2c_dev->dnf = DIV_ROUND_CLOSEST(i2c_dev->dnf_dt, i2cclk);\n\tif (i2c_dev->dnf > STM32F7_I2C_DNF_MAX) {\n\t\tdev_err(i2c_dev->dev,\n\t\t\t\"DNF out of bound %d/%d\\n\",\n\t\t\ti2c_dev->dnf * i2cclk, STM32F7_I2C_DNF_MAX * i2cclk);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\taf_delay_min =\n\t\t(i2c_dev->analog_filter ?\n\t\t STM32F7_I2C_ANALOG_FILTER_DELAY_MIN : 0);\n\taf_delay_max =\n\t\t(i2c_dev->analog_filter ?\n\t\t STM32F7_I2C_ANALOG_FILTER_DELAY_MAX : 0);\n\tdnf_delay = i2c_dev->dnf * i2cclk;\n\n\tsdadel_min = specs->hddat_min + setup->fall_time -\n\t\taf_delay_min - (i2c_dev->dnf + 3) * i2cclk;\n\n\tsdadel_max = specs->vddat_max - setup->rise_time -\n\t\taf_delay_max - (i2c_dev->dnf + 4) * i2cclk;\n\n\tscldel_min = setup->rise_time + specs->sudat_min;\n\n\tif (sdadel_min < 0)\n\t\tsdadel_min = 0;\n\tif (sdadel_max < 0)\n\t\tsdadel_max = 0;\n\n\tdev_dbg(i2c_dev->dev, \"SDADEL(min/max): %i/%i, SCLDEL(Min): %i\\n\",\n\t\tsdadel_min, sdadel_max, scldel_min);\n\n\tINIT_LIST_HEAD(&solutions);\n\t \n\tfor (p = 0; p < STM32F7_PRESC_MAX; p++) {\n\t\tfor (l = 0; l < STM32F7_SCLDEL_MAX; l++) {\n\t\t\tu32 scldel = (l + 1) * (p + 1) * i2cclk;\n\n\t\t\tif (scldel < scldel_min)\n\t\t\t\tcontinue;\n\n\t\t\tfor (a = 0; a < STM32F7_SDADEL_MAX; a++) {\n\t\t\t\tu32 sdadel = (a * (p + 1) + 1) * i2cclk;\n\n\t\t\t\tif (((sdadel >= sdadel_min) &&\n\t\t\t\t     (sdadel <= sdadel_max)) &&\n\t\t\t\t    (p != p_prev)) {\n\t\t\t\t\tv = kmalloc(sizeof(*v), GFP_KERNEL);\n\t\t\t\t\tif (!v) {\n\t\t\t\t\t\tret = -ENOMEM;\n\t\t\t\t\t\tgoto exit;\n\t\t\t\t\t}\n\n\t\t\t\t\tv->presc = p;\n\t\t\t\t\tv->scldel = l;\n\t\t\t\t\tv->sdadel = a;\n\t\t\t\t\tp_prev = p;\n\n\t\t\t\t\tlist_add_tail(&v->node,\n\t\t\t\t\t\t      &solutions);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (p_prev == p)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (list_empty(&solutions)) {\n\t\tdev_err(i2c_dev->dev, \"no Prescaler solution\\n\");\n\t\tret = -EPERM;\n\t\tgoto exit;\n\t}\n\n\ttsync = af_delay_min + dnf_delay + (2 * i2cclk);\n\ts = NULL;\n\tclk_max = NSEC_PER_SEC / RATE_MIN(setup->speed_freq);\n\tclk_min = NSEC_PER_SEC / setup->speed_freq;\n\n\t \n\tlist_for_each_entry(v, &solutions, node) {\n\t\tu32 prescaler = (v->presc + 1) * i2cclk;\n\n\t\tfor (l = 0; l < STM32F7_SCLL_MAX; l++) {\n\t\t\tu32 tscl_l = (l + 1) * prescaler + tsync;\n\n\t\t\tif ((tscl_l < specs->l_min) ||\n\t\t\t    (i2cclk >=\n\t\t\t     ((tscl_l - af_delay_min - dnf_delay) / 4))) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor (h = 0; h < STM32F7_SCLH_MAX; h++) {\n\t\t\t\tu32 tscl_h = (h + 1) * prescaler + tsync;\n\t\t\t\tu32 tscl = tscl_l + tscl_h +\n\t\t\t\t\tsetup->rise_time + setup->fall_time;\n\n\t\t\t\tif ((tscl >= clk_min) && (tscl <= clk_max) &&\n\t\t\t\t    (tscl_h >= specs->h_min) &&\n\t\t\t\t    (i2cclk < tscl_h)) {\n\t\t\t\t\tint clk_error = tscl - i2cbus;\n\n\t\t\t\t\tif (clk_error < 0)\n\t\t\t\t\t\tclk_error = -clk_error;\n\n\t\t\t\t\tif (clk_error < clk_error_prev) {\n\t\t\t\t\t\tclk_error_prev = clk_error;\n\t\t\t\t\t\tv->scll = l;\n\t\t\t\t\t\tv->sclh = h;\n\t\t\t\t\t\ts = v;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!s) {\n\t\tdev_err(i2c_dev->dev, \"no solution at all\\n\");\n\t\tret = -EPERM;\n\t\tgoto exit;\n\t}\n\n\toutput->presc = s->presc;\n\toutput->scldel = s->scldel;\n\toutput->sdadel = s->sdadel;\n\toutput->scll = s->scll;\n\toutput->sclh = s->sclh;\n\n\tdev_dbg(i2c_dev->dev,\n\t\t\"Presc: %i, scldel: %i, sdadel: %i, scll: %i, sclh: %i\\n\",\n\t\toutput->presc,\n\t\toutput->scldel, output->sdadel,\n\t\toutput->scll, output->sclh);\n\nexit:\n\t \n\tlist_for_each_entry_safe(v, _v, &solutions, node) {\n\t\tlist_del(&v->node);\n\t\tkfree(v);\n\t}\n\n\treturn ret;\n}\n\nstatic u32 stm32f7_get_lower_rate(u32 rate)\n{\n\tint i = ARRAY_SIZE(stm32f7_i2c_specs);\n\n\twhile (--i)\n\t\tif (stm32f7_i2c_specs[i].rate < rate)\n\t\t\tbreak;\n\n\treturn stm32f7_i2c_specs[i].rate;\n}\n\nstatic int stm32f7_i2c_setup_timing(struct stm32f7_i2c_dev *i2c_dev,\n\t\t\t\t    struct stm32f7_i2c_setup *setup)\n{\n\tstruct i2c_timings timings, *t = &timings;\n\tint ret = 0;\n\n\tt->bus_freq_hz = I2C_MAX_STANDARD_MODE_FREQ;\n\tt->scl_rise_ns = i2c_dev->setup.rise_time;\n\tt->scl_fall_ns = i2c_dev->setup.fall_time;\n\n\ti2c_parse_fw_timings(i2c_dev->dev, t, false);\n\n\tif (t->bus_freq_hz > I2C_MAX_FAST_MODE_PLUS_FREQ) {\n\t\tdev_err(i2c_dev->dev, \"Invalid bus speed (%i>%i)\\n\",\n\t\t\tt->bus_freq_hz, I2C_MAX_FAST_MODE_PLUS_FREQ);\n\t\treturn -EINVAL;\n\t}\n\n\tsetup->speed_freq = t->bus_freq_hz;\n\ti2c_dev->setup.rise_time = t->scl_rise_ns;\n\ti2c_dev->setup.fall_time = t->scl_fall_ns;\n\ti2c_dev->dnf_dt = t->digital_filter_width_ns;\n\tsetup->clock_src = clk_get_rate(i2c_dev->clk);\n\n\tif (!setup->clock_src) {\n\t\tdev_err(i2c_dev->dev, \"clock rate is 0\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!of_property_read_bool(i2c_dev->dev->of_node, \"i2c-digital-filter\"))\n\t\ti2c_dev->dnf_dt = STM32F7_I2C_DNF_DEFAULT;\n\n\tdo {\n\t\tret = stm32f7_i2c_compute_timing(i2c_dev, setup,\n\t\t\t\t\t\t &i2c_dev->timing);\n\t\tif (ret) {\n\t\t\tdev_err(i2c_dev->dev,\n\t\t\t\t\"failed to compute I2C timings.\\n\");\n\t\t\tif (setup->speed_freq <= I2C_MAX_STANDARD_MODE_FREQ)\n\t\t\t\tbreak;\n\t\t\tsetup->speed_freq =\n\t\t\t\tstm32f7_get_lower_rate(setup->speed_freq);\n\t\t\tdev_warn(i2c_dev->dev,\n\t\t\t\t \"downgrade I2C Speed Freq to (%i)\\n\",\n\t\t\t\t setup->speed_freq);\n\t\t}\n\t} while (ret);\n\n\tif (ret) {\n\t\tdev_err(i2c_dev->dev, \"Impossible to compute I2C timings.\\n\");\n\t\treturn ret;\n\t}\n\n\ti2c_dev->analog_filter = of_property_read_bool(i2c_dev->dev->of_node,\n\t\t\t\t\t\t       \"i2c-analog-filter\");\n\n\tdev_dbg(i2c_dev->dev, \"I2C Speed(%i), Clk Source(%i)\\n\",\n\t\tsetup->speed_freq, setup->clock_src);\n\tdev_dbg(i2c_dev->dev, \"I2C Rise(%i) and Fall(%i) Time\\n\",\n\t\tsetup->rise_time, setup->fall_time);\n\tdev_dbg(i2c_dev->dev, \"I2C Analog Filter(%s), DNF(%i)\\n\",\n\t\t(i2c_dev->analog_filter ? \"On\" : \"Off\"), i2c_dev->dnf);\n\n\ti2c_dev->bus_rate = setup->speed_freq;\n\n\treturn 0;\n}\n\nstatic void stm32f7_i2c_disable_dma_req(struct stm32f7_i2c_dev *i2c_dev)\n{\n\tvoid __iomem *base = i2c_dev->base;\n\tu32 mask = STM32F7_I2C_CR1_RXDMAEN | STM32F7_I2C_CR1_TXDMAEN;\n\n\tstm32f7_i2c_clr_bits(base + STM32F7_I2C_CR1, mask);\n}\n\nstatic void stm32f7_i2c_dma_callback(void *arg)\n{\n\tstruct stm32f7_i2c_dev *i2c_dev = (struct stm32f7_i2c_dev *)arg;\n\tstruct stm32_i2c_dma *dma = i2c_dev->dma;\n\tstruct device *dev = dma->chan_using->device->dev;\n\n\tstm32f7_i2c_disable_dma_req(i2c_dev);\n\tdma_unmap_single(dev, dma->dma_buf, dma->dma_len, dma->dma_data_dir);\n\tcomplete(&dma->dma_complete);\n}\n\nstatic void stm32f7_i2c_hw_config(struct stm32f7_i2c_dev *i2c_dev)\n{\n\tstruct stm32f7_i2c_timings *t = &i2c_dev->timing;\n\tu32 timing = 0;\n\n\t \n\ttiming |= STM32F7_I2C_TIMINGR_PRESC(t->presc);\n\ttiming |= STM32F7_I2C_TIMINGR_SCLDEL(t->scldel);\n\ttiming |= STM32F7_I2C_TIMINGR_SDADEL(t->sdadel);\n\ttiming |= STM32F7_I2C_TIMINGR_SCLH(t->sclh);\n\ttiming |= STM32F7_I2C_TIMINGR_SCLL(t->scll);\n\twritel_relaxed(timing, i2c_dev->base + STM32F7_I2C_TIMINGR);\n\n\t \n\tif (i2c_dev->analog_filter)\n\t\tstm32f7_i2c_clr_bits(i2c_dev->base + STM32F7_I2C_CR1,\n\t\t\t\t     STM32F7_I2C_CR1_ANFOFF);\n\telse\n\t\tstm32f7_i2c_set_bits(i2c_dev->base + STM32F7_I2C_CR1,\n\t\t\t\t     STM32F7_I2C_CR1_ANFOFF);\n\n\t \n\tstm32f7_i2c_clr_bits(i2c_dev->base + STM32F7_I2C_CR1,\n\t\t\t     STM32F7_I2C_CR1_DNF_MASK);\n\tstm32f7_i2c_set_bits(i2c_dev->base + STM32F7_I2C_CR1,\n\t\t\t     STM32F7_I2C_CR1_DNF(i2c_dev->dnf));\n\n\tstm32f7_i2c_set_bits(i2c_dev->base + STM32F7_I2C_CR1,\n\t\t\t     STM32F7_I2C_CR1_PE);\n}\n\nstatic void stm32f7_i2c_write_tx_data(struct stm32f7_i2c_dev *i2c_dev)\n{\n\tstruct stm32f7_i2c_msg *f7_msg = &i2c_dev->f7_msg;\n\tvoid __iomem *base = i2c_dev->base;\n\n\tif (f7_msg->count) {\n\t\twriteb_relaxed(*f7_msg->buf++, base + STM32F7_I2C_TXDR);\n\t\tf7_msg->count--;\n\t}\n}\n\nstatic void stm32f7_i2c_read_rx_data(struct stm32f7_i2c_dev *i2c_dev)\n{\n\tstruct stm32f7_i2c_msg *f7_msg = &i2c_dev->f7_msg;\n\tvoid __iomem *base = i2c_dev->base;\n\n\tif (f7_msg->count) {\n\t\t*f7_msg->buf++ = readb_relaxed(base + STM32F7_I2C_RXDR);\n\t\tf7_msg->count--;\n\t} else {\n\t\t \n\t\treadb_relaxed(base + STM32F7_I2C_RXDR);\n\t}\n}\n\nstatic void stm32f7_i2c_reload(struct stm32f7_i2c_dev *i2c_dev)\n{\n\tstruct stm32f7_i2c_msg *f7_msg = &i2c_dev->f7_msg;\n\tu32 cr2;\n\n\tif (i2c_dev->use_dma)\n\t\tf7_msg->count -= STM32F7_I2C_MAX_LEN;\n\n\tcr2 = readl_relaxed(i2c_dev->base + STM32F7_I2C_CR2);\n\n\tcr2 &= ~STM32F7_I2C_CR2_NBYTES_MASK;\n\tif (f7_msg->count > STM32F7_I2C_MAX_LEN) {\n\t\tcr2 |= STM32F7_I2C_CR2_NBYTES(STM32F7_I2C_MAX_LEN);\n\t} else {\n\t\tcr2 &= ~STM32F7_I2C_CR2_RELOAD;\n\t\tcr2 |= STM32F7_I2C_CR2_NBYTES(f7_msg->count);\n\t}\n\n\twritel_relaxed(cr2, i2c_dev->base + STM32F7_I2C_CR2);\n}\n\nstatic void stm32f7_i2c_smbus_reload(struct stm32f7_i2c_dev *i2c_dev)\n{\n\tstruct stm32f7_i2c_msg *f7_msg = &i2c_dev->f7_msg;\n\tu32 cr2;\n\tu8 *val;\n\n\t \n\tstm32f7_i2c_read_rx_data(i2c_dev);\n\n\t \n\tval = f7_msg->buf - sizeof(u8);\n\tf7_msg->count = *val;\n\tcr2 = readl_relaxed(i2c_dev->base + STM32F7_I2C_CR2);\n\tcr2 &= ~(STM32F7_I2C_CR2_NBYTES_MASK | STM32F7_I2C_CR2_RELOAD);\n\tcr2 |= STM32F7_I2C_CR2_NBYTES(f7_msg->count);\n\twritel_relaxed(cr2, i2c_dev->base + STM32F7_I2C_CR2);\n}\n\nstatic void stm32f7_i2c_release_bus(struct i2c_adapter *i2c_adap)\n{\n\tstruct stm32f7_i2c_dev *i2c_dev = i2c_get_adapdata(i2c_adap);\n\n\tstm32f7_i2c_clr_bits(i2c_dev->base + STM32F7_I2C_CR1,\n\t\t\t     STM32F7_I2C_CR1_PE);\n\n\tstm32f7_i2c_hw_config(i2c_dev);\n}\n\nstatic int stm32f7_i2c_wait_free_bus(struct stm32f7_i2c_dev *i2c_dev)\n{\n\tu32 status;\n\tint ret;\n\n\tret = readl_relaxed_poll_timeout(i2c_dev->base + STM32F7_I2C_ISR,\n\t\t\t\t\t status,\n\t\t\t\t\t !(status & STM32F7_I2C_ISR_BUSY),\n\t\t\t\t\t 10, 1000);\n\tif (!ret)\n\t\treturn 0;\n\n\tstm32f7_i2c_release_bus(&i2c_dev->adap);\n\n\treturn -EBUSY;\n}\n\nstatic void stm32f7_i2c_xfer_msg(struct stm32f7_i2c_dev *i2c_dev,\n\t\t\t\t struct i2c_msg *msg)\n{\n\tstruct stm32f7_i2c_msg *f7_msg = &i2c_dev->f7_msg;\n\tvoid __iomem *base = i2c_dev->base;\n\tu32 cr1, cr2;\n\tint ret;\n\n\tf7_msg->addr = msg->addr;\n\tf7_msg->buf = msg->buf;\n\tf7_msg->count = msg->len;\n\tf7_msg->result = 0;\n\tf7_msg->stop = (i2c_dev->msg_id >= i2c_dev->msg_num - 1);\n\n\treinit_completion(&i2c_dev->complete);\n\n\tcr1 = readl_relaxed(base + STM32F7_I2C_CR1);\n\tcr2 = readl_relaxed(base + STM32F7_I2C_CR2);\n\n\t \n\tcr2 &= ~STM32F7_I2C_CR2_RD_WRN;\n\tif (msg->flags & I2C_M_RD)\n\t\tcr2 |= STM32F7_I2C_CR2_RD_WRN;\n\n\t \n\tcr2 &= ~(STM32F7_I2C_CR2_HEAD10R | STM32F7_I2C_CR2_ADD10);\n\tif (msg->flags & I2C_M_TEN) {\n\t\tcr2 &= ~STM32F7_I2C_CR2_SADD10_MASK;\n\t\tcr2 |= STM32F7_I2C_CR2_SADD10(f7_msg->addr);\n\t\tcr2 |= STM32F7_I2C_CR2_ADD10;\n\t} else {\n\t\tcr2 &= ~STM32F7_I2C_CR2_SADD7_MASK;\n\t\tcr2 |= STM32F7_I2C_CR2_SADD7(f7_msg->addr);\n\t}\n\n\t \n\tcr2 &= ~(STM32F7_I2C_CR2_NBYTES_MASK | STM32F7_I2C_CR2_RELOAD);\n\tif (f7_msg->count > STM32F7_I2C_MAX_LEN) {\n\t\tcr2 |= STM32F7_I2C_CR2_NBYTES(STM32F7_I2C_MAX_LEN);\n\t\tcr2 |= STM32F7_I2C_CR2_RELOAD;\n\t} else {\n\t\tcr2 |= STM32F7_I2C_CR2_NBYTES(f7_msg->count);\n\t}\n\n\t \n\tcr1 |= STM32F7_I2C_CR1_ERRIE | STM32F7_I2C_CR1_TCIE |\n\t\tSTM32F7_I2C_CR1_STOPIE | STM32F7_I2C_CR1_NACKIE;\n\n\t \n\tcr1 &= ~(STM32F7_I2C_CR1_RXIE | STM32F7_I2C_CR1_TXIE |\n\t\t\tSTM32F7_I2C_CR1_RXDMAEN | STM32F7_I2C_CR1_TXDMAEN);\n\n\t \n\ti2c_dev->use_dma = false;\n\tif (i2c_dev->dma && f7_msg->count >= STM32F7_I2C_DMA_LEN_MIN) {\n\t\tret = stm32_i2c_prep_dma_xfer(i2c_dev->dev, i2c_dev->dma,\n\t\t\t\t\t      msg->flags & I2C_M_RD,\n\t\t\t\t\t      f7_msg->count, f7_msg->buf,\n\t\t\t\t\t      stm32f7_i2c_dma_callback,\n\t\t\t\t\t      i2c_dev);\n\t\tif (!ret)\n\t\t\ti2c_dev->use_dma = true;\n\t\telse\n\t\t\tdev_warn(i2c_dev->dev, \"can't use DMA\\n\");\n\t}\n\n\tif (!i2c_dev->use_dma) {\n\t\tif (msg->flags & I2C_M_RD)\n\t\t\tcr1 |= STM32F7_I2C_CR1_RXIE;\n\t\telse\n\t\t\tcr1 |= STM32F7_I2C_CR1_TXIE;\n\t} else {\n\t\tif (msg->flags & I2C_M_RD)\n\t\t\tcr1 |= STM32F7_I2C_CR1_RXDMAEN;\n\t\telse\n\t\t\tcr1 |= STM32F7_I2C_CR1_TXDMAEN;\n\t}\n\n\t \n\tcr2 |= STM32F7_I2C_CR2_START;\n\n\ti2c_dev->master_mode = true;\n\n\t \n\twritel_relaxed(cr1, base + STM32F7_I2C_CR1);\n\twritel_relaxed(cr2, base + STM32F7_I2C_CR2);\n}\n\nstatic int stm32f7_i2c_smbus_xfer_msg(struct stm32f7_i2c_dev *i2c_dev,\n\t\t\t\t      unsigned short flags, u8 command,\n\t\t\t\t      union i2c_smbus_data *data)\n{\n\tstruct stm32f7_i2c_msg *f7_msg = &i2c_dev->f7_msg;\n\tstruct device *dev = i2c_dev->dev;\n\tvoid __iomem *base = i2c_dev->base;\n\tu32 cr1, cr2;\n\tint i, ret;\n\n\tf7_msg->result = 0;\n\treinit_completion(&i2c_dev->complete);\n\n\tcr2 = readl_relaxed(base + STM32F7_I2C_CR2);\n\tcr1 = readl_relaxed(base + STM32F7_I2C_CR1);\n\n\t \n\tcr2 &= ~STM32F7_I2C_CR2_RD_WRN;\n\tif (f7_msg->read_write)\n\t\tcr2 |= STM32F7_I2C_CR2_RD_WRN;\n\n\t \n\tcr2 &= ~(STM32F7_I2C_CR2_ADD10 | STM32F7_I2C_CR2_SADD7_MASK);\n\tcr2 |= STM32F7_I2C_CR2_SADD7(f7_msg->addr);\n\n\tf7_msg->smbus_buf[0] = command;\n\tswitch (f7_msg->size) {\n\tcase I2C_SMBUS_QUICK:\n\t\tf7_msg->stop = true;\n\t\tf7_msg->count = 0;\n\t\tbreak;\n\tcase I2C_SMBUS_BYTE:\n\t\tf7_msg->stop = true;\n\t\tf7_msg->count = 1;\n\t\tbreak;\n\tcase I2C_SMBUS_BYTE_DATA:\n\t\tif (f7_msg->read_write) {\n\t\t\tf7_msg->stop = false;\n\t\t\tf7_msg->count = 1;\n\t\t\tcr2 &= ~STM32F7_I2C_CR2_RD_WRN;\n\t\t} else {\n\t\t\tf7_msg->stop = true;\n\t\t\tf7_msg->count = 2;\n\t\t\tf7_msg->smbus_buf[1] = data->byte;\n\t\t}\n\t\tbreak;\n\tcase I2C_SMBUS_WORD_DATA:\n\t\tif (f7_msg->read_write) {\n\t\t\tf7_msg->stop = false;\n\t\t\tf7_msg->count = 1;\n\t\t\tcr2 &= ~STM32F7_I2C_CR2_RD_WRN;\n\t\t} else {\n\t\t\tf7_msg->stop = true;\n\t\t\tf7_msg->count = 3;\n\t\t\tf7_msg->smbus_buf[1] = data->word & 0xff;\n\t\t\tf7_msg->smbus_buf[2] = data->word >> 8;\n\t\t}\n\t\tbreak;\n\tcase I2C_SMBUS_BLOCK_DATA:\n\t\tif (f7_msg->read_write) {\n\t\t\tf7_msg->stop = false;\n\t\t\tf7_msg->count = 1;\n\t\t\tcr2 &= ~STM32F7_I2C_CR2_RD_WRN;\n\t\t} else {\n\t\t\tf7_msg->stop = true;\n\t\t\tif (data->block[0] > I2C_SMBUS_BLOCK_MAX ||\n\t\t\t    !data->block[0]) {\n\t\t\t\tdev_err(dev, \"Invalid block write size %d\\n\",\n\t\t\t\t\tdata->block[0]);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tf7_msg->count = data->block[0] + 2;\n\t\t\tfor (i = 1; i < f7_msg->count; i++)\n\t\t\t\tf7_msg->smbus_buf[i] = data->block[i - 1];\n\t\t}\n\t\tbreak;\n\tcase I2C_SMBUS_PROC_CALL:\n\t\tf7_msg->stop = false;\n\t\tf7_msg->count = 3;\n\t\tf7_msg->smbus_buf[1] = data->word & 0xff;\n\t\tf7_msg->smbus_buf[2] = data->word >> 8;\n\t\tcr2 &= ~STM32F7_I2C_CR2_RD_WRN;\n\t\tf7_msg->read_write = I2C_SMBUS_READ;\n\t\tbreak;\n\tcase I2C_SMBUS_BLOCK_PROC_CALL:\n\t\tf7_msg->stop = false;\n\t\tif (data->block[0] > I2C_SMBUS_BLOCK_MAX - 1) {\n\t\t\tdev_err(dev, \"Invalid block write size %d\\n\",\n\t\t\t\tdata->block[0]);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tf7_msg->count = data->block[0] + 2;\n\t\tfor (i = 1; i < f7_msg->count; i++)\n\t\t\tf7_msg->smbus_buf[i] = data->block[i - 1];\n\t\tcr2 &= ~STM32F7_I2C_CR2_RD_WRN;\n\t\tf7_msg->read_write = I2C_SMBUS_READ;\n\t\tbreak;\n\tcase I2C_SMBUS_I2C_BLOCK_DATA:\n\t\t \n\t\treturn -EOPNOTSUPP;\n\tdefault:\n\t\tdev_err(dev, \"Unsupported smbus protocol %d\\n\", f7_msg->size);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tf7_msg->buf = f7_msg->smbus_buf;\n\n\t \n\tif ((flags & I2C_CLIENT_PEC) && f7_msg->size != I2C_SMBUS_QUICK) {\n\t\tcr1 |= STM32F7_I2C_CR1_PECEN;\n\t\tif (!f7_msg->read_write) {\n\t\t\tcr2 |= STM32F7_I2C_CR2_PECBYTE;\n\t\t\tf7_msg->count++;\n\t\t}\n\t} else {\n\t\tcr1 &= ~STM32F7_I2C_CR1_PECEN;\n\t\tcr2 &= ~STM32F7_I2C_CR2_PECBYTE;\n\t}\n\n\t \n\tcr2 &= ~(STM32F7_I2C_CR2_NBYTES_MASK | STM32F7_I2C_CR2_RELOAD);\n\tcr2 |= STM32F7_I2C_CR2_NBYTES(f7_msg->count);\n\n\t \n\tcr1 |= STM32F7_I2C_CR1_ERRIE | STM32F7_I2C_CR1_TCIE |\n\t\tSTM32F7_I2C_CR1_STOPIE | STM32F7_I2C_CR1_NACKIE;\n\n\t \n\tcr1 &= ~(STM32F7_I2C_CR1_RXIE | STM32F7_I2C_CR1_TXIE |\n\t\t\tSTM32F7_I2C_CR1_RXDMAEN | STM32F7_I2C_CR1_TXDMAEN);\n\n\t \n\ti2c_dev->use_dma = false;\n\tif (i2c_dev->dma && f7_msg->count >= STM32F7_I2C_DMA_LEN_MIN) {\n\t\tret = stm32_i2c_prep_dma_xfer(i2c_dev->dev, i2c_dev->dma,\n\t\t\t\t\t      cr2 & STM32F7_I2C_CR2_RD_WRN,\n\t\t\t\t\t      f7_msg->count, f7_msg->buf,\n\t\t\t\t\t      stm32f7_i2c_dma_callback,\n\t\t\t\t\t      i2c_dev);\n\t\tif (!ret)\n\t\t\ti2c_dev->use_dma = true;\n\t\telse\n\t\t\tdev_warn(i2c_dev->dev, \"can't use DMA\\n\");\n\t}\n\n\tif (!i2c_dev->use_dma) {\n\t\tif (cr2 & STM32F7_I2C_CR2_RD_WRN)\n\t\t\tcr1 |= STM32F7_I2C_CR1_RXIE;\n\t\telse\n\t\t\tcr1 |= STM32F7_I2C_CR1_TXIE;\n\t} else {\n\t\tif (cr2 & STM32F7_I2C_CR2_RD_WRN)\n\t\t\tcr1 |= STM32F7_I2C_CR1_RXDMAEN;\n\t\telse\n\t\t\tcr1 |= STM32F7_I2C_CR1_TXDMAEN;\n\t}\n\n\t \n\tcr2 |= STM32F7_I2C_CR2_START;\n\n\ti2c_dev->master_mode = true;\n\n\t \n\twritel_relaxed(cr1, base + STM32F7_I2C_CR1);\n\twritel_relaxed(cr2, base + STM32F7_I2C_CR2);\n\n\treturn 0;\n}\n\nstatic void stm32f7_i2c_smbus_rep_start(struct stm32f7_i2c_dev *i2c_dev)\n{\n\tstruct stm32f7_i2c_msg *f7_msg = &i2c_dev->f7_msg;\n\tvoid __iomem *base = i2c_dev->base;\n\tu32 cr1, cr2;\n\tint ret;\n\n\tcr2 = readl_relaxed(base + STM32F7_I2C_CR2);\n\tcr1 = readl_relaxed(base + STM32F7_I2C_CR1);\n\n\t \n\tcr2 |= STM32F7_I2C_CR2_RD_WRN;\n\n\tswitch (f7_msg->size) {\n\tcase I2C_SMBUS_BYTE_DATA:\n\t\tf7_msg->count = 1;\n\t\tbreak;\n\tcase I2C_SMBUS_WORD_DATA:\n\tcase I2C_SMBUS_PROC_CALL:\n\t\tf7_msg->count = 2;\n\t\tbreak;\n\tcase I2C_SMBUS_BLOCK_DATA:\n\tcase I2C_SMBUS_BLOCK_PROC_CALL:\n\t\tf7_msg->count = 1;\n\t\tcr2 |= STM32F7_I2C_CR2_RELOAD;\n\t\tbreak;\n\t}\n\n\tf7_msg->buf = f7_msg->smbus_buf;\n\tf7_msg->stop = true;\n\n\t \n\tif (cr1 & STM32F7_I2C_CR1_PECEN) {\n\t\tcr2 |= STM32F7_I2C_CR2_PECBYTE;\n\t\tf7_msg->count++;\n\t}\n\n\t \n\tcr2 &= ~(STM32F7_I2C_CR2_NBYTES_MASK);\n\tcr2 |= STM32F7_I2C_CR2_NBYTES(f7_msg->count);\n\n\t \n\tcr1 &= ~(STM32F7_I2C_CR1_RXIE | STM32F7_I2C_CR1_TXIE);\n\tcr1 |= STM32F7_I2C_CR1_RXIE;\n\n\t \n\tcr1 &= ~(STM32F7_I2C_CR1_RXIE | STM32F7_I2C_CR1_TXIE |\n\t\t STM32F7_I2C_CR1_RXDMAEN | STM32F7_I2C_CR1_TXDMAEN);\n\n\ti2c_dev->use_dma = false;\n\tif (i2c_dev->dma && f7_msg->count >= STM32F7_I2C_DMA_LEN_MIN &&\n\t    f7_msg->size != I2C_SMBUS_BLOCK_DATA &&\n\t    f7_msg->size != I2C_SMBUS_BLOCK_PROC_CALL) {\n\t\tret = stm32_i2c_prep_dma_xfer(i2c_dev->dev, i2c_dev->dma,\n\t\t\t\t\t      cr2 & STM32F7_I2C_CR2_RD_WRN,\n\t\t\t\t\t      f7_msg->count, f7_msg->buf,\n\t\t\t\t\t      stm32f7_i2c_dma_callback,\n\t\t\t\t\t      i2c_dev);\n\n\t\tif (!ret)\n\t\t\ti2c_dev->use_dma = true;\n\t\telse\n\t\t\tdev_warn(i2c_dev->dev, \"can't use DMA\\n\");\n\t}\n\n\tif (!i2c_dev->use_dma)\n\t\tcr1 |= STM32F7_I2C_CR1_RXIE;\n\telse\n\t\tcr1 |= STM32F7_I2C_CR1_RXDMAEN;\n\n\t \n\tcr2 |= STM32F7_I2C_CR2_START;\n\n\t \n\twritel_relaxed(cr1, base + STM32F7_I2C_CR1);\n\twritel_relaxed(cr2, base + STM32F7_I2C_CR2);\n}\n\nstatic int stm32f7_i2c_smbus_check_pec(struct stm32f7_i2c_dev *i2c_dev)\n{\n\tstruct stm32f7_i2c_msg *f7_msg = &i2c_dev->f7_msg;\n\tu8 count, internal_pec, received_pec;\n\n\tinternal_pec = readl_relaxed(i2c_dev->base + STM32F7_I2C_PECR);\n\n\tswitch (f7_msg->size) {\n\tcase I2C_SMBUS_BYTE:\n\tcase I2C_SMBUS_BYTE_DATA:\n\t\treceived_pec = f7_msg->smbus_buf[1];\n\t\tbreak;\n\tcase I2C_SMBUS_WORD_DATA:\n\tcase I2C_SMBUS_PROC_CALL:\n\t\treceived_pec = f7_msg->smbus_buf[2];\n\t\tbreak;\n\tcase I2C_SMBUS_BLOCK_DATA:\n\tcase I2C_SMBUS_BLOCK_PROC_CALL:\n\t\tcount = f7_msg->smbus_buf[0];\n\t\treceived_pec = f7_msg->smbus_buf[count];\n\t\tbreak;\n\tdefault:\n\t\tdev_err(i2c_dev->dev, \"Unsupported smbus protocol for PEC\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (internal_pec != received_pec) {\n\t\tdev_err(i2c_dev->dev, \"Bad PEC 0x%02x vs. 0x%02x\\n\",\n\t\t\tinternal_pec, received_pec);\n\t\treturn -EBADMSG;\n\t}\n\n\treturn 0;\n}\n\nstatic bool stm32f7_i2c_is_addr_match(struct i2c_client *slave, u32 addcode)\n{\n\tu32 addr;\n\n\tif (!slave)\n\t\treturn false;\n\n\tif (slave->flags & I2C_CLIENT_TEN) {\n\t\t \n\t\taddr = slave->addr >> 8;\n\t\taddr |= 0x78;\n\t\tif (addr == addcode)\n\t\t\treturn true;\n\t} else {\n\t\taddr = slave->addr & 0x7f;\n\t\tif (addr == addcode)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic void stm32f7_i2c_slave_start(struct stm32f7_i2c_dev *i2c_dev)\n{\n\tstruct i2c_client *slave = i2c_dev->slave_running;\n\tvoid __iomem *base = i2c_dev->base;\n\tu32 mask;\n\tu8 value = 0;\n\n\tif (i2c_dev->slave_dir) {\n\t\t \n\t\ti2c_slave_event(slave, I2C_SLAVE_READ_REQUESTED, &value);\n\n\t\t \n\t\tmask = STM32F7_I2C_CR2_RELOAD;\n\t\tstm32f7_i2c_clr_bits(base + STM32F7_I2C_CR2, mask);\n\t\tmask = STM32F7_I2C_CR1_SBC | STM32F7_I2C_CR1_RXIE |\n\t\t       STM32F7_I2C_CR1_TCIE;\n\t\tstm32f7_i2c_clr_bits(base + STM32F7_I2C_CR1, mask);\n\n\t\t \n\t\tmask =  STM32F7_I2C_CR1_STOPIE | STM32F7_I2C_CR1_NACKIE |\n\t\t\tSTM32F7_I2C_CR1_TXIE;\n\t\tstm32f7_i2c_set_bits(base + STM32F7_I2C_CR1, mask);\n\n\t\t \n\t\twritel_relaxed(value, base + STM32F7_I2C_TXDR);\n\t} else {\n\t\t \n\t\ti2c_slave_event(slave, I2C_SLAVE_WRITE_REQUESTED, &value);\n\n\t\t \n\t\tmask = STM32F7_I2C_CR2_RELOAD;\n\t\tstm32f7_i2c_set_bits(base + STM32F7_I2C_CR2, mask);\n\n\t\t \n\t\tmask =  STM32F7_I2C_CR1_STOPIE | STM32F7_I2C_CR1_NACKIE |\n\t\t\tSTM32F7_I2C_CR1_SBC | STM32F7_I2C_CR1_RXIE |\n\t\t\tSTM32F7_I2C_CR1_TCIE;\n\t\tstm32f7_i2c_set_bits(base + STM32F7_I2C_CR1, mask);\n\t}\n}\n\nstatic void stm32f7_i2c_slave_addr(struct stm32f7_i2c_dev *i2c_dev)\n{\n\tvoid __iomem *base = i2c_dev->base;\n\tu32 isr, addcode, dir, mask;\n\tint i;\n\n\tisr = readl_relaxed(i2c_dev->base + STM32F7_I2C_ISR);\n\taddcode = STM32F7_I2C_ISR_ADDCODE_GET(isr);\n\tdir = isr & STM32F7_I2C_ISR_DIR;\n\n\tfor (i = 0; i < STM32F7_I2C_MAX_SLAVE; i++) {\n\t\tif (stm32f7_i2c_is_addr_match(i2c_dev->slave[i], addcode)) {\n\t\t\ti2c_dev->slave_running = i2c_dev->slave[i];\n\t\t\ti2c_dev->slave_dir = dir;\n\n\t\t\t \n\t\t\tstm32f7_i2c_slave_start(i2c_dev);\n\n\t\t\t \n\t\t\tmask = STM32F7_I2C_ICR_ADDRCF;\n\t\t\twritel_relaxed(mask, base + STM32F7_I2C_ICR);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic int stm32f7_i2c_get_slave_id(struct stm32f7_i2c_dev *i2c_dev,\n\t\t\t\t    struct i2c_client *slave, int *id)\n{\n\tint i;\n\n\tfor (i = 0; i < STM32F7_I2C_MAX_SLAVE; i++) {\n\t\tif (i2c_dev->slave[i] == slave) {\n\t\t\t*id = i;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tdev_err(i2c_dev->dev, \"Slave 0x%x not registered\\n\", slave->addr);\n\n\treturn -ENODEV;\n}\n\nstatic int stm32f7_i2c_get_free_slave_id(struct stm32f7_i2c_dev *i2c_dev,\n\t\t\t\t\t struct i2c_client *slave, int *id)\n{\n\tstruct device *dev = i2c_dev->dev;\n\tint i;\n\n\t \n\tif (i2c_dev->smbus_mode && (slave->addr == 0x08)) {\n\t\tif (i2c_dev->slave[STM32F7_SLAVE_HOSTNOTIFY])\n\t\t\tgoto fail;\n\t\t*id = STM32F7_SLAVE_HOSTNOTIFY;\n\t\treturn 0;\n\t}\n\n\tfor (i = STM32F7_I2C_MAX_SLAVE - 1; i > STM32F7_SLAVE_HOSTNOTIFY; i--) {\n\t\tif ((i == STM32F7_SLAVE_7_BITS_ADDR) &&\n\t\t    (slave->flags & I2C_CLIENT_TEN))\n\t\t\tcontinue;\n\t\tif (!i2c_dev->slave[i]) {\n\t\t\t*id = i;\n\t\t\treturn 0;\n\t\t}\n\t}\n\nfail:\n\tdev_err(dev, \"Slave 0x%x could not be registered\\n\", slave->addr);\n\n\treturn -EINVAL;\n}\n\nstatic bool stm32f7_i2c_is_slave_registered(struct stm32f7_i2c_dev *i2c_dev)\n{\n\tint i;\n\n\tfor (i = 0; i < STM32F7_I2C_MAX_SLAVE; i++) {\n\t\tif (i2c_dev->slave[i])\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic bool stm32f7_i2c_is_slave_busy(struct stm32f7_i2c_dev *i2c_dev)\n{\n\tint i, busy;\n\n\tbusy = 0;\n\tfor (i = 0; i < STM32F7_I2C_MAX_SLAVE; i++) {\n\t\tif (i2c_dev->slave[i])\n\t\t\tbusy++;\n\t}\n\n\treturn i == busy;\n}\n\nstatic irqreturn_t stm32f7_i2c_slave_isr_event(struct stm32f7_i2c_dev *i2c_dev)\n{\n\tvoid __iomem *base = i2c_dev->base;\n\tu32 cr2, status, mask;\n\tu8 val;\n\tint ret;\n\n\tstatus = readl_relaxed(i2c_dev->base + STM32F7_I2C_ISR);\n\n\t \n\tif (status & STM32F7_I2C_ISR_TXIS) {\n\t\ti2c_slave_event(i2c_dev->slave_running,\n\t\t\t\tI2C_SLAVE_READ_PROCESSED,\n\t\t\t\t&val);\n\n\t\t \n\t\twritel_relaxed(val, base + STM32F7_I2C_TXDR);\n\t}\n\n\t \n\tif (status & STM32F7_I2C_ISR_TCR || status & STM32F7_I2C_ISR_RXNE) {\n\t\t \n\t\tval = readb_relaxed(i2c_dev->base + STM32F7_I2C_RXDR);\n\t\tret = i2c_slave_event(i2c_dev->slave_running,\n\t\t\t\t      I2C_SLAVE_WRITE_RECEIVED,\n\t\t\t\t      &val);\n\t\tif (!ret) {\n\t\t\tcr2 = readl_relaxed(i2c_dev->base + STM32F7_I2C_CR2);\n\t\t\tcr2 |= STM32F7_I2C_CR2_NBYTES(1);\n\t\t\twritel_relaxed(cr2, i2c_dev->base + STM32F7_I2C_CR2);\n\t\t} else {\n\t\t\tmask = STM32F7_I2C_CR2_NACK;\n\t\t\tstm32f7_i2c_set_bits(base + STM32F7_I2C_CR2, mask);\n\t\t}\n\t}\n\n\t \n\tif (status & STM32F7_I2C_ISR_NACKF) {\n\t\tdev_dbg(i2c_dev->dev, \"<%s>: Receive NACK\\n\", __func__);\n\t\twritel_relaxed(STM32F7_I2C_ICR_NACKCF, base + STM32F7_I2C_ICR);\n\t}\n\n\t \n\tif (status & STM32F7_I2C_ISR_STOPF) {\n\t\t \n\t\tstm32f7_i2c_disable_irq(i2c_dev, STM32F7_I2C_XFER_IRQ_MASK);\n\n\t\tif (i2c_dev->slave_dir) {\n\t\t\t \n\t\t\tmask = STM32F7_I2C_ISR_TXE;\n\t\t\tstm32f7_i2c_set_bits(base + STM32F7_I2C_ISR, mask);\n\t\t}\n\n\t\t \n\t\twritel_relaxed(STM32F7_I2C_ICR_STOPCF, base + STM32F7_I2C_ICR);\n\n\t\t \n\t\ti2c_slave_event(i2c_dev->slave_running, I2C_SLAVE_STOP, &val);\n\n\t\ti2c_dev->slave_running = NULL;\n\t}\n\n\t \n\tif (status & STM32F7_I2C_ISR_ADDR)\n\t\tstm32f7_i2c_slave_addr(i2c_dev);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t stm32f7_i2c_isr_event(int irq, void *data)\n{\n\tstruct stm32f7_i2c_dev *i2c_dev = data;\n\tstruct stm32f7_i2c_msg *f7_msg = &i2c_dev->f7_msg;\n\tstruct stm32_i2c_dma *dma = i2c_dev->dma;\n\tvoid __iomem *base = i2c_dev->base;\n\tu32 status, mask;\n\tint ret = IRQ_HANDLED;\n\n\t \n\tif (!i2c_dev->master_mode) {\n\t\tret = stm32f7_i2c_slave_isr_event(i2c_dev);\n\t\treturn ret;\n\t}\n\n\tstatus = readl_relaxed(i2c_dev->base + STM32F7_I2C_ISR);\n\n\t \n\tif (status & STM32F7_I2C_ISR_TXIS)\n\t\tstm32f7_i2c_write_tx_data(i2c_dev);\n\n\t \n\tif (status & STM32F7_I2C_ISR_RXNE)\n\t\tstm32f7_i2c_read_rx_data(i2c_dev);\n\n\t \n\tif (status & STM32F7_I2C_ISR_NACKF) {\n\t\tdev_dbg(i2c_dev->dev, \"<%s>: Receive NACK (addr %x)\\n\",\n\t\t\t__func__, f7_msg->addr);\n\t\twritel_relaxed(STM32F7_I2C_ICR_NACKCF, base + STM32F7_I2C_ICR);\n\t\tif (i2c_dev->use_dma) {\n\t\t\tstm32f7_i2c_disable_dma_req(i2c_dev);\n\t\t\tdmaengine_terminate_async(dma->chan_using);\n\t\t}\n\t\tf7_msg->result = -ENXIO;\n\t}\n\n\t \n\tif (status & STM32F7_I2C_ISR_STOPF) {\n\t\t \n\t\tif (stm32f7_i2c_is_slave_registered(i2c_dev))\n\t\t\tmask = STM32F7_I2C_XFER_IRQ_MASK;\n\t\telse\n\t\t\tmask = STM32F7_I2C_ALL_IRQ_MASK;\n\t\tstm32f7_i2c_disable_irq(i2c_dev, mask);\n\n\t\t \n\t\twritel_relaxed(STM32F7_I2C_ICR_STOPCF, base + STM32F7_I2C_ICR);\n\n\t\tif (i2c_dev->use_dma && !f7_msg->result) {\n\t\t\tret = IRQ_WAKE_THREAD;\n\t\t} else {\n\t\t\ti2c_dev->master_mode = false;\n\t\t\tcomplete(&i2c_dev->complete);\n\t\t}\n\t}\n\n\t \n\tif (status & STM32F7_I2C_ISR_TC) {\n\t\tif (f7_msg->stop) {\n\t\t\tmask = STM32F7_I2C_CR2_STOP;\n\t\t\tstm32f7_i2c_set_bits(base + STM32F7_I2C_CR2, mask);\n\t\t} else if (i2c_dev->use_dma && !f7_msg->result) {\n\t\t\tret = IRQ_WAKE_THREAD;\n\t\t} else if (f7_msg->smbus) {\n\t\t\tstm32f7_i2c_smbus_rep_start(i2c_dev);\n\t\t} else {\n\t\t\ti2c_dev->msg_id++;\n\t\t\ti2c_dev->msg++;\n\t\t\tstm32f7_i2c_xfer_msg(i2c_dev, i2c_dev->msg);\n\t\t}\n\t}\n\n\tif (status & STM32F7_I2C_ISR_TCR) {\n\t\tif (f7_msg->smbus)\n\t\t\tstm32f7_i2c_smbus_reload(i2c_dev);\n\t\telse\n\t\t\tstm32f7_i2c_reload(i2c_dev);\n\t}\n\n\treturn ret;\n}\n\nstatic irqreturn_t stm32f7_i2c_isr_event_thread(int irq, void *data)\n{\n\tstruct stm32f7_i2c_dev *i2c_dev = data;\n\tstruct stm32f7_i2c_msg *f7_msg = &i2c_dev->f7_msg;\n\tstruct stm32_i2c_dma *dma = i2c_dev->dma;\n\tu32 status;\n\tint ret;\n\n\t \n\tret = wait_for_completion_timeout(&i2c_dev->dma->dma_complete, HZ);\n\tif (!ret) {\n\t\tdev_dbg(i2c_dev->dev, \"<%s>: Timed out\\n\", __func__);\n\t\tstm32f7_i2c_disable_dma_req(i2c_dev);\n\t\tdmaengine_terminate_async(dma->chan_using);\n\t\tf7_msg->result = -ETIMEDOUT;\n\t}\n\n\tstatus = readl_relaxed(i2c_dev->base + STM32F7_I2C_ISR);\n\n\tif (status & STM32F7_I2C_ISR_TC) {\n\t\tif (f7_msg->smbus) {\n\t\t\tstm32f7_i2c_smbus_rep_start(i2c_dev);\n\t\t} else {\n\t\t\ti2c_dev->msg_id++;\n\t\t\ti2c_dev->msg++;\n\t\t\tstm32f7_i2c_xfer_msg(i2c_dev, i2c_dev->msg);\n\t\t}\n\t} else {\n\t\ti2c_dev->master_mode = false;\n\t\tcomplete(&i2c_dev->complete);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t stm32f7_i2c_isr_error(int irq, void *data)\n{\n\tstruct stm32f7_i2c_dev *i2c_dev = data;\n\tstruct stm32f7_i2c_msg *f7_msg = &i2c_dev->f7_msg;\n\tvoid __iomem *base = i2c_dev->base;\n\tstruct device *dev = i2c_dev->dev;\n\tstruct stm32_i2c_dma *dma = i2c_dev->dma;\n\tu32 status;\n\n\tstatus = readl_relaxed(i2c_dev->base + STM32F7_I2C_ISR);\n\n\t \n\tif (status & STM32F7_I2C_ISR_BERR) {\n\t\tdev_err(dev, \"<%s>: Bus error accessing addr 0x%x\\n\",\n\t\t\t__func__, f7_msg->addr);\n\t\twritel_relaxed(STM32F7_I2C_ICR_BERRCF, base + STM32F7_I2C_ICR);\n\t\tstm32f7_i2c_release_bus(&i2c_dev->adap);\n\t\tf7_msg->result = -EIO;\n\t}\n\n\t \n\tif (status & STM32F7_I2C_ISR_ARLO) {\n\t\tdev_dbg(dev, \"<%s>: Arbitration loss accessing addr 0x%x\\n\",\n\t\t\t__func__, f7_msg->addr);\n\t\twritel_relaxed(STM32F7_I2C_ICR_ARLOCF, base + STM32F7_I2C_ICR);\n\t\tf7_msg->result = -EAGAIN;\n\t}\n\n\tif (status & STM32F7_I2C_ISR_PECERR) {\n\t\tdev_err(dev, \"<%s>: PEC error in reception accessing addr 0x%x\\n\",\n\t\t\t__func__, f7_msg->addr);\n\t\twritel_relaxed(STM32F7_I2C_ICR_PECCF, base + STM32F7_I2C_ICR);\n\t\tf7_msg->result = -EINVAL;\n\t}\n\n\tif (status & STM32F7_I2C_ISR_ALERT) {\n\t\tdev_dbg(dev, \"<%s>: SMBus alert received\\n\", __func__);\n\t\twritel_relaxed(STM32F7_I2C_ICR_ALERTCF, base + STM32F7_I2C_ICR);\n\t\ti2c_handle_smbus_alert(i2c_dev->alert->ara);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tif (!i2c_dev->slave_running) {\n\t\tu32 mask;\n\t\t \n\t\tif (stm32f7_i2c_is_slave_registered(i2c_dev))\n\t\t\tmask = STM32F7_I2C_XFER_IRQ_MASK;\n\t\telse\n\t\t\tmask = STM32F7_I2C_ALL_IRQ_MASK;\n\t\tstm32f7_i2c_disable_irq(i2c_dev, mask);\n\t}\n\n\t \n\tif (i2c_dev->use_dma) {\n\t\tstm32f7_i2c_disable_dma_req(i2c_dev);\n\t\tdmaengine_terminate_async(dma->chan_using);\n\t}\n\n\ti2c_dev->master_mode = false;\n\tcomplete(&i2c_dev->complete);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int stm32f7_i2c_xfer(struct i2c_adapter *i2c_adap,\n\t\t\t    struct i2c_msg msgs[], int num)\n{\n\tstruct stm32f7_i2c_dev *i2c_dev = i2c_get_adapdata(i2c_adap);\n\tstruct stm32f7_i2c_msg *f7_msg = &i2c_dev->f7_msg;\n\tstruct stm32_i2c_dma *dma = i2c_dev->dma;\n\tunsigned long time_left;\n\tint ret;\n\n\ti2c_dev->msg = msgs;\n\ti2c_dev->msg_num = num;\n\ti2c_dev->msg_id = 0;\n\tf7_msg->smbus = false;\n\n\tret = pm_runtime_resume_and_get(i2c_dev->dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = stm32f7_i2c_wait_free_bus(i2c_dev);\n\tif (ret)\n\t\tgoto pm_free;\n\n\tstm32f7_i2c_xfer_msg(i2c_dev, msgs);\n\n\ttime_left = wait_for_completion_timeout(&i2c_dev->complete,\n\t\t\t\t\t\ti2c_dev->adap.timeout);\n\tret = f7_msg->result;\n\tif (ret) {\n\t\tif (i2c_dev->use_dma)\n\t\t\tdmaengine_synchronize(dma->chan_using);\n\n\t\t \n\t\twritel_relaxed(STM32F7_I2C_ISR_TXE,\n\t\t\t       i2c_dev->base + STM32F7_I2C_ISR);\n\t\tgoto pm_free;\n\t}\n\n\tif (!time_left) {\n\t\tdev_dbg(i2c_dev->dev, \"Access to slave 0x%x timed out\\n\",\n\t\t\ti2c_dev->msg->addr);\n\t\tif (i2c_dev->use_dma)\n\t\t\tdmaengine_terminate_sync(dma->chan_using);\n\t\tstm32f7_i2c_wait_free_bus(i2c_dev);\n\t\tret = -ETIMEDOUT;\n\t}\n\npm_free:\n\tpm_runtime_mark_last_busy(i2c_dev->dev);\n\tpm_runtime_put_autosuspend(i2c_dev->dev);\n\n\treturn (ret < 0) ? ret : num;\n}\n\nstatic int stm32f7_i2c_smbus_xfer(struct i2c_adapter *adapter, u16 addr,\n\t\t\t\t  unsigned short flags, char read_write,\n\t\t\t\t  u8 command, int size,\n\t\t\t\t  union i2c_smbus_data *data)\n{\n\tstruct stm32f7_i2c_dev *i2c_dev = i2c_get_adapdata(adapter);\n\tstruct stm32f7_i2c_msg *f7_msg = &i2c_dev->f7_msg;\n\tstruct stm32_i2c_dma *dma = i2c_dev->dma;\n\tstruct device *dev = i2c_dev->dev;\n\tunsigned long timeout;\n\tint i, ret;\n\n\tf7_msg->addr = addr;\n\tf7_msg->size = size;\n\tf7_msg->read_write = read_write;\n\tf7_msg->smbus = true;\n\n\tret = pm_runtime_resume_and_get(dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = stm32f7_i2c_wait_free_bus(i2c_dev);\n\tif (ret)\n\t\tgoto pm_free;\n\n\tret = stm32f7_i2c_smbus_xfer_msg(i2c_dev, flags, command, data);\n\tif (ret)\n\t\tgoto pm_free;\n\n\ttimeout = wait_for_completion_timeout(&i2c_dev->complete,\n\t\t\t\t\t      i2c_dev->adap.timeout);\n\tret = f7_msg->result;\n\tif (ret) {\n\t\tif (i2c_dev->use_dma)\n\t\t\tdmaengine_synchronize(dma->chan_using);\n\n\t\t \n\t\twritel_relaxed(STM32F7_I2C_ISR_TXE,\n\t\t\t       i2c_dev->base + STM32F7_I2C_ISR);\n\t\tgoto pm_free;\n\t}\n\n\tif (!timeout) {\n\t\tdev_dbg(dev, \"Access to slave 0x%x timed out\\n\", f7_msg->addr);\n\t\tif (i2c_dev->use_dma)\n\t\t\tdmaengine_terminate_sync(dma->chan_using);\n\t\tstm32f7_i2c_wait_free_bus(i2c_dev);\n\t\tret = -ETIMEDOUT;\n\t\tgoto pm_free;\n\t}\n\n\t \n\tif ((flags & I2C_CLIENT_PEC) && size != I2C_SMBUS_QUICK && read_write) {\n\t\tret = stm32f7_i2c_smbus_check_pec(i2c_dev);\n\t\tif (ret)\n\t\t\tgoto pm_free;\n\t}\n\n\tif (read_write && size != I2C_SMBUS_QUICK) {\n\t\tswitch (size) {\n\t\tcase I2C_SMBUS_BYTE:\n\t\tcase I2C_SMBUS_BYTE_DATA:\n\t\t\tdata->byte = f7_msg->smbus_buf[0];\n\t\tbreak;\n\t\tcase I2C_SMBUS_WORD_DATA:\n\t\tcase I2C_SMBUS_PROC_CALL:\n\t\t\tdata->word = f7_msg->smbus_buf[0] |\n\t\t\t\t(f7_msg->smbus_buf[1] << 8);\n\t\tbreak;\n\t\tcase I2C_SMBUS_BLOCK_DATA:\n\t\tcase I2C_SMBUS_BLOCK_PROC_CALL:\n\t\tfor (i = 0; i <= f7_msg->smbus_buf[0]; i++)\n\t\t\tdata->block[i] = f7_msg->smbus_buf[i];\n\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(dev, \"Unsupported smbus transaction\\n\");\n\t\t\tret = -EINVAL;\n\t\t}\n\t}\n\npm_free:\n\tpm_runtime_mark_last_busy(dev);\n\tpm_runtime_put_autosuspend(dev);\n\treturn ret;\n}\n\nstatic void stm32f7_i2c_enable_wakeup(struct stm32f7_i2c_dev *i2c_dev,\n\t\t\t\t      bool enable)\n{\n\tvoid __iomem *base = i2c_dev->base;\n\tu32 mask = STM32F7_I2C_CR1_WUPEN;\n\n\tif (!i2c_dev->wakeup_src)\n\t\treturn;\n\n\tif (enable) {\n\t\tdevice_set_wakeup_enable(i2c_dev->dev, true);\n\t\tstm32f7_i2c_set_bits(base + STM32F7_I2C_CR1, mask);\n\t} else {\n\t\tdevice_set_wakeup_enable(i2c_dev->dev, false);\n\t\tstm32f7_i2c_clr_bits(base + STM32F7_I2C_CR1, mask);\n\t}\n}\n\nstatic int stm32f7_i2c_reg_slave(struct i2c_client *slave)\n{\n\tstruct stm32f7_i2c_dev *i2c_dev = i2c_get_adapdata(slave->adapter);\n\tvoid __iomem *base = i2c_dev->base;\n\tstruct device *dev = i2c_dev->dev;\n\tu32 oar1, oar2, mask;\n\tint id, ret;\n\n\tif (slave->flags & I2C_CLIENT_PEC) {\n\t\tdev_err(dev, \"SMBus PEC not supported in slave mode\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (stm32f7_i2c_is_slave_busy(i2c_dev)) {\n\t\tdev_err(dev, \"Too much slave registered\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tret = stm32f7_i2c_get_free_slave_id(i2c_dev, slave, &id);\n\tif (ret)\n\t\treturn ret;\n\n\tret = pm_runtime_resume_and_get(dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (!stm32f7_i2c_is_slave_registered(i2c_dev))\n\t\tstm32f7_i2c_enable_wakeup(i2c_dev, true);\n\n\tswitch (id) {\n\tcase 0:\n\t\t \n\t\ti2c_dev->slave[id] = slave;\n\t\tbreak;\n\n\tcase 1:\n\t\t \n\t\toar1 = readl_relaxed(i2c_dev->base + STM32F7_I2C_OAR1);\n\t\toar1 &= ~STM32F7_I2C_OAR1_MASK;\n\t\tif (slave->flags & I2C_CLIENT_TEN) {\n\t\t\toar1 |= STM32F7_I2C_OAR1_OA1_10(slave->addr);\n\t\t\toar1 |= STM32F7_I2C_OAR1_OA1MODE;\n\t\t} else {\n\t\t\toar1 |= STM32F7_I2C_OAR1_OA1_7(slave->addr);\n\t\t}\n\t\toar1 |= STM32F7_I2C_OAR1_OA1EN;\n\t\ti2c_dev->slave[id] = slave;\n\t\twritel_relaxed(oar1, i2c_dev->base + STM32F7_I2C_OAR1);\n\t\tbreak;\n\n\tcase 2:\n\t\t \n\t\toar2 = readl_relaxed(i2c_dev->base + STM32F7_I2C_OAR2);\n\t\toar2 &= ~STM32F7_I2C_OAR2_MASK;\n\t\tif (slave->flags & I2C_CLIENT_TEN) {\n\t\t\tret = -EOPNOTSUPP;\n\t\t\tgoto pm_free;\n\t\t}\n\n\t\toar2 |= STM32F7_I2C_OAR2_OA2_7(slave->addr);\n\t\toar2 |= STM32F7_I2C_OAR2_OA2EN;\n\t\ti2c_dev->slave[id] = slave;\n\t\twritel_relaxed(oar2, i2c_dev->base + STM32F7_I2C_OAR2);\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(dev, \"I2C slave id not supported\\n\");\n\t\tret = -ENODEV;\n\t\tgoto pm_free;\n\t}\n\n\t \n\tstm32f7_i2c_clr_bits(base + STM32F7_I2C_CR2, STM32F7_I2C_CR2_NACK);\n\n\t \n\tmask = STM32F7_I2C_CR1_ADDRIE | STM32F7_I2C_CR1_ERRIE |\n\t\tSTM32F7_I2C_CR1_PE;\n\tstm32f7_i2c_set_bits(base + STM32F7_I2C_CR1, mask);\n\n\tret = 0;\npm_free:\n\tif (!stm32f7_i2c_is_slave_registered(i2c_dev))\n\t\tstm32f7_i2c_enable_wakeup(i2c_dev, false);\n\n\tpm_runtime_mark_last_busy(dev);\n\tpm_runtime_put_autosuspend(dev);\n\n\treturn ret;\n}\n\nstatic int stm32f7_i2c_unreg_slave(struct i2c_client *slave)\n{\n\tstruct stm32f7_i2c_dev *i2c_dev = i2c_get_adapdata(slave->adapter);\n\tvoid __iomem *base = i2c_dev->base;\n\tu32 mask;\n\tint id, ret;\n\n\tret = stm32f7_i2c_get_slave_id(i2c_dev, slave, &id);\n\tif (ret)\n\t\treturn ret;\n\n\tWARN_ON(!i2c_dev->slave[id]);\n\n\tret = pm_runtime_resume_and_get(i2c_dev->dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (id == 1) {\n\t\tmask = STM32F7_I2C_OAR1_OA1EN;\n\t\tstm32f7_i2c_clr_bits(base + STM32F7_I2C_OAR1, mask);\n\t} else if (id == 2) {\n\t\tmask = STM32F7_I2C_OAR2_OA2EN;\n\t\tstm32f7_i2c_clr_bits(base + STM32F7_I2C_OAR2, mask);\n\t}\n\n\ti2c_dev->slave[id] = NULL;\n\n\tif (!stm32f7_i2c_is_slave_registered(i2c_dev)) {\n\t\tstm32f7_i2c_disable_irq(i2c_dev, STM32F7_I2C_ALL_IRQ_MASK);\n\t\tstm32f7_i2c_enable_wakeup(i2c_dev, false);\n\t}\n\n\tpm_runtime_mark_last_busy(i2c_dev->dev);\n\tpm_runtime_put_autosuspend(i2c_dev->dev);\n\n\treturn 0;\n}\n\nstatic int stm32f7_i2c_write_fm_plus_bits(struct stm32f7_i2c_dev *i2c_dev,\n\t\t\t\t\t  bool enable)\n{\n\tint ret;\n\n\tif (i2c_dev->bus_rate <= I2C_MAX_FAST_MODE_FREQ ||\n\t    IS_ERR_OR_NULL(i2c_dev->regmap))\n\t\t \n\t\treturn 0;\n\n\tif (i2c_dev->fmp_sreg == i2c_dev->fmp_creg)\n\t\tret = regmap_update_bits(i2c_dev->regmap,\n\t\t\t\t\t i2c_dev->fmp_sreg,\n\t\t\t\t\t i2c_dev->fmp_mask,\n\t\t\t\t\t enable ? i2c_dev->fmp_mask : 0);\n\telse\n\t\tret = regmap_write(i2c_dev->regmap,\n\t\t\t\t   enable ? i2c_dev->fmp_sreg :\n\t\t\t\t\t    i2c_dev->fmp_creg,\n\t\t\t\t   i2c_dev->fmp_mask);\n\n\treturn ret;\n}\n\nstatic int stm32f7_i2c_setup_fm_plus_bits(struct platform_device *pdev,\n\t\t\t\t\t  struct stm32f7_i2c_dev *i2c_dev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tint ret;\n\n\ti2c_dev->regmap = syscon_regmap_lookup_by_phandle(np, \"st,syscfg-fmp\");\n\tif (IS_ERR(i2c_dev->regmap))\n\t\t \n\t\treturn 0;\n\n\tret = of_property_read_u32_index(np, \"st,syscfg-fmp\", 1,\n\t\t\t\t\t &i2c_dev->fmp_sreg);\n\tif (ret)\n\t\treturn ret;\n\n\ti2c_dev->fmp_creg = i2c_dev->fmp_sreg +\n\t\t\t       i2c_dev->setup.fmp_clr_offset;\n\n\treturn of_property_read_u32_index(np, \"st,syscfg-fmp\", 2,\n\t\t\t\t\t  &i2c_dev->fmp_mask);\n}\n\nstatic int stm32f7_i2c_enable_smbus_host(struct stm32f7_i2c_dev *i2c_dev)\n{\n\tstruct i2c_adapter *adap = &i2c_dev->adap;\n\tvoid __iomem *base = i2c_dev->base;\n\tstruct i2c_client *client;\n\n\tclient = i2c_new_slave_host_notify_device(adap);\n\tif (IS_ERR(client))\n\t\treturn PTR_ERR(client);\n\n\ti2c_dev->host_notify_client = client;\n\n\t \n\tstm32f7_i2c_set_bits(base + STM32F7_I2C_CR1, STM32F7_I2C_CR1_SMBHEN);\n\n\treturn 0;\n}\n\nstatic void stm32f7_i2c_disable_smbus_host(struct stm32f7_i2c_dev *i2c_dev)\n{\n\tvoid __iomem *base = i2c_dev->base;\n\n\tif (i2c_dev->host_notify_client) {\n\t\t \n\t\tstm32f7_i2c_clr_bits(base + STM32F7_I2C_CR1,\n\t\t\t\t     STM32F7_I2C_CR1_SMBHEN);\n\t\ti2c_free_slave_host_notify_device(i2c_dev->host_notify_client);\n\t}\n}\n\nstatic int stm32f7_i2c_enable_smbus_alert(struct stm32f7_i2c_dev *i2c_dev)\n{\n\tstruct stm32f7_i2c_alert *alert;\n\tstruct i2c_adapter *adap = &i2c_dev->adap;\n\tstruct device *dev = i2c_dev->dev;\n\tvoid __iomem *base = i2c_dev->base;\n\n\talert = devm_kzalloc(dev, sizeof(*alert), GFP_KERNEL);\n\tif (!alert)\n\t\treturn -ENOMEM;\n\n\talert->ara = i2c_new_smbus_alert_device(adap, &alert->setup);\n\tif (IS_ERR(alert->ara))\n\t\treturn PTR_ERR(alert->ara);\n\n\ti2c_dev->alert = alert;\n\n\t \n\tstm32f7_i2c_set_bits(base + STM32F7_I2C_CR1, STM32F7_I2C_CR1_ALERTEN);\n\n\treturn 0;\n}\n\nstatic void stm32f7_i2c_disable_smbus_alert(struct stm32f7_i2c_dev *i2c_dev)\n{\n\tstruct stm32f7_i2c_alert *alert = i2c_dev->alert;\n\tvoid __iomem *base = i2c_dev->base;\n\n\tif (alert) {\n\t\t \n\t\tstm32f7_i2c_clr_bits(base + STM32F7_I2C_CR1,\n\t\t\t\t     STM32F7_I2C_CR1_ALERTEN);\n\t\ti2c_unregister_device(alert->ara);\n\t}\n}\n\nstatic u32 stm32f7_i2c_func(struct i2c_adapter *adap)\n{\n\tstruct stm32f7_i2c_dev *i2c_dev = i2c_get_adapdata(adap);\n\n\tu32 func = I2C_FUNC_I2C | I2C_FUNC_10BIT_ADDR | I2C_FUNC_SLAVE |\n\t\t   I2C_FUNC_SMBUS_QUICK | I2C_FUNC_SMBUS_BYTE |\n\t\t   I2C_FUNC_SMBUS_BYTE_DATA | I2C_FUNC_SMBUS_WORD_DATA |\n\t\t   I2C_FUNC_SMBUS_BLOCK_DATA | I2C_FUNC_SMBUS_BLOCK_PROC_CALL |\n\t\t   I2C_FUNC_SMBUS_PROC_CALL | I2C_FUNC_SMBUS_PEC |\n\t\t   I2C_FUNC_SMBUS_I2C_BLOCK;\n\n\tif (i2c_dev->smbus_mode)\n\t\tfunc |= I2C_FUNC_SMBUS_HOST_NOTIFY;\n\n\treturn func;\n}\n\nstatic const struct i2c_algorithm stm32f7_i2c_algo = {\n\t.master_xfer = stm32f7_i2c_xfer,\n\t.smbus_xfer = stm32f7_i2c_smbus_xfer,\n\t.functionality = stm32f7_i2c_func,\n\t.reg_slave = stm32f7_i2c_reg_slave,\n\t.unreg_slave = stm32f7_i2c_unreg_slave,\n};\n\nstatic int stm32f7_i2c_probe(struct platform_device *pdev)\n{\n\tstruct stm32f7_i2c_dev *i2c_dev;\n\tconst struct stm32f7_i2c_setup *setup;\n\tstruct resource *res;\n\tstruct i2c_adapter *adap;\n\tstruct reset_control *rst;\n\tdma_addr_t phy_addr;\n\tint irq_error, irq_event, ret;\n\n\ti2c_dev = devm_kzalloc(&pdev->dev, sizeof(*i2c_dev), GFP_KERNEL);\n\tif (!i2c_dev)\n\t\treturn -ENOMEM;\n\n\ti2c_dev->base = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(i2c_dev->base))\n\t\treturn PTR_ERR(i2c_dev->base);\n\tphy_addr = (dma_addr_t)res->start;\n\n\tirq_event = platform_get_irq(pdev, 0);\n\tif (irq_event < 0)\n\t\treturn irq_event;\n\n\tirq_error = platform_get_irq(pdev, 1);\n\tif (irq_error < 0)\n\t\treturn irq_error;\n\n\ti2c_dev->wakeup_src = of_property_read_bool(pdev->dev.of_node,\n\t\t\t\t\t\t    \"wakeup-source\");\n\n\ti2c_dev->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(i2c_dev->clk))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(i2c_dev->clk),\n\t\t\t\t     \"Failed to get controller clock\\n\");\n\n\tret = clk_prepare_enable(i2c_dev->clk);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed to prepare_enable clock\\n\");\n\t\treturn ret;\n\t}\n\n\trst = devm_reset_control_get(&pdev->dev, NULL);\n\tif (IS_ERR(rst)) {\n\t\tret = dev_err_probe(&pdev->dev, PTR_ERR(rst),\n\t\t\t\t    \"Error: Missing reset ctrl\\n\");\n\t\tgoto clk_free;\n\t}\n\treset_control_assert(rst);\n\tudelay(2);\n\treset_control_deassert(rst);\n\n\ti2c_dev->dev = &pdev->dev;\n\n\tret = devm_request_threaded_irq(&pdev->dev, irq_event,\n\t\t\t\t\tstm32f7_i2c_isr_event,\n\t\t\t\t\tstm32f7_i2c_isr_event_thread,\n\t\t\t\t\tIRQF_ONESHOT,\n\t\t\t\t\tpdev->name, i2c_dev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed to request irq event %i\\n\",\n\t\t\tirq_event);\n\t\tgoto clk_free;\n\t}\n\n\tret = devm_request_irq(&pdev->dev, irq_error, stm32f7_i2c_isr_error, 0,\n\t\t\t       pdev->name, i2c_dev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed to request irq error %i\\n\",\n\t\t\tirq_error);\n\t\tgoto clk_free;\n\t}\n\n\tsetup = of_device_get_match_data(&pdev->dev);\n\tif (!setup) {\n\t\tdev_err(&pdev->dev, \"Can't get device data\\n\");\n\t\tret = -ENODEV;\n\t\tgoto clk_free;\n\t}\n\ti2c_dev->setup = *setup;\n\n\tret = stm32f7_i2c_setup_timing(i2c_dev, &i2c_dev->setup);\n\tif (ret)\n\t\tgoto clk_free;\n\n\t \n\tif (i2c_dev->bus_rate > I2C_MAX_FAST_MODE_FREQ) {\n\t\tret = stm32f7_i2c_setup_fm_plus_bits(pdev, i2c_dev);\n\t\tif (ret)\n\t\t\tgoto clk_free;\n\t\tret = stm32f7_i2c_write_fm_plus_bits(i2c_dev, true);\n\t\tif (ret)\n\t\t\tgoto clk_free;\n\t}\n\n\tadap = &i2c_dev->adap;\n\ti2c_set_adapdata(adap, i2c_dev);\n\tsnprintf(adap->name, sizeof(adap->name), \"STM32F7 I2C(%pa)\",\n\t\t &res->start);\n\tadap->owner = THIS_MODULE;\n\tadap->timeout = 2 * HZ;\n\tadap->retries = 3;\n\tadap->algo = &stm32f7_i2c_algo;\n\tadap->dev.parent = &pdev->dev;\n\tadap->dev.of_node = pdev->dev.of_node;\n\n\tinit_completion(&i2c_dev->complete);\n\n\t \n\ti2c_dev->dma = stm32_i2c_dma_request(i2c_dev->dev, phy_addr,\n\t\t\t\t\t     STM32F7_I2C_TXDR,\n\t\t\t\t\t     STM32F7_I2C_RXDR);\n\tif (IS_ERR(i2c_dev->dma)) {\n\t\tret = PTR_ERR(i2c_dev->dma);\n\t\t \n\t\tif (ret != -ENODEV)\n\t\t\tgoto fmp_clear;\n\t\tdev_dbg(i2c_dev->dev, \"No DMA option: fallback using interrupts\\n\");\n\t\ti2c_dev->dma = NULL;\n\t}\n\n\tif (i2c_dev->wakeup_src) {\n\t\tdevice_set_wakeup_capable(i2c_dev->dev, true);\n\n\t\tret = dev_pm_set_wake_irq(i2c_dev->dev, irq_event);\n\t\tif (ret) {\n\t\t\tdev_err(i2c_dev->dev, \"Failed to set wake up irq\\n\");\n\t\t\tgoto clr_wakeup_capable;\n\t\t}\n\t}\n\n\tplatform_set_drvdata(pdev, i2c_dev);\n\n\tpm_runtime_set_autosuspend_delay(i2c_dev->dev,\n\t\t\t\t\t STM32F7_AUTOSUSPEND_DELAY);\n\tpm_runtime_use_autosuspend(i2c_dev->dev);\n\tpm_runtime_set_active(i2c_dev->dev);\n\tpm_runtime_enable(i2c_dev->dev);\n\n\tpm_runtime_get_noresume(&pdev->dev);\n\n\tstm32f7_i2c_hw_config(i2c_dev);\n\n\ti2c_dev->smbus_mode = of_property_read_bool(pdev->dev.of_node, \"smbus\");\n\n\tret = i2c_add_adapter(adap);\n\tif (ret)\n\t\tgoto pm_disable;\n\n\tif (i2c_dev->smbus_mode) {\n\t\tret = stm32f7_i2c_enable_smbus_host(i2c_dev);\n\t\tif (ret) {\n\t\t\tdev_err(i2c_dev->dev,\n\t\t\t\t\"failed to enable SMBus Host-Notify protocol (%d)\\n\",\n\t\t\t\tret);\n\t\t\tgoto i2c_adapter_remove;\n\t\t}\n\t}\n\n\tif (of_property_read_bool(pdev->dev.of_node, \"smbus-alert\")) {\n\t\tret = stm32f7_i2c_enable_smbus_alert(i2c_dev);\n\t\tif (ret) {\n\t\t\tdev_err(i2c_dev->dev,\n\t\t\t\t\"failed to enable SMBus alert protocol (%d)\\n\",\n\t\t\t\tret);\n\t\t\tgoto i2c_disable_smbus_host;\n\t\t}\n\t}\n\n\tdev_info(i2c_dev->dev, \"STM32F7 I2C-%d bus adapter\\n\", adap->nr);\n\n\tpm_runtime_mark_last_busy(i2c_dev->dev);\n\tpm_runtime_put_autosuspend(i2c_dev->dev);\n\n\treturn 0;\n\ni2c_disable_smbus_host:\n\tstm32f7_i2c_disable_smbus_host(i2c_dev);\n\ni2c_adapter_remove:\n\ti2c_del_adapter(adap);\n\npm_disable:\n\tpm_runtime_put_noidle(i2c_dev->dev);\n\tpm_runtime_disable(i2c_dev->dev);\n\tpm_runtime_set_suspended(i2c_dev->dev);\n\tpm_runtime_dont_use_autosuspend(i2c_dev->dev);\n\n\tif (i2c_dev->wakeup_src)\n\t\tdev_pm_clear_wake_irq(i2c_dev->dev);\n\nclr_wakeup_capable:\n\tif (i2c_dev->wakeup_src)\n\t\tdevice_set_wakeup_capable(i2c_dev->dev, false);\n\n\tif (i2c_dev->dma) {\n\t\tstm32_i2c_dma_free(i2c_dev->dma);\n\t\ti2c_dev->dma = NULL;\n\t}\n\nfmp_clear:\n\tstm32f7_i2c_write_fm_plus_bits(i2c_dev, false);\n\nclk_free:\n\tclk_disable_unprepare(i2c_dev->clk);\n\n\treturn ret;\n}\n\nstatic void stm32f7_i2c_remove(struct platform_device *pdev)\n{\n\tstruct stm32f7_i2c_dev *i2c_dev = platform_get_drvdata(pdev);\n\n\tstm32f7_i2c_disable_smbus_alert(i2c_dev);\n\tstm32f7_i2c_disable_smbus_host(i2c_dev);\n\n\ti2c_del_adapter(&i2c_dev->adap);\n\tpm_runtime_get_sync(i2c_dev->dev);\n\n\tif (i2c_dev->wakeup_src) {\n\t\tdev_pm_clear_wake_irq(i2c_dev->dev);\n\t\t \n\t\tdevice_init_wakeup(i2c_dev->dev, false);\n\t}\n\n\tpm_runtime_put_noidle(i2c_dev->dev);\n\tpm_runtime_disable(i2c_dev->dev);\n\tpm_runtime_set_suspended(i2c_dev->dev);\n\tpm_runtime_dont_use_autosuspend(i2c_dev->dev);\n\n\tif (i2c_dev->dma) {\n\t\tstm32_i2c_dma_free(i2c_dev->dma);\n\t\ti2c_dev->dma = NULL;\n\t}\n\n\tstm32f7_i2c_write_fm_plus_bits(i2c_dev, false);\n\n\tclk_disable_unprepare(i2c_dev->clk);\n}\n\nstatic int __maybe_unused stm32f7_i2c_runtime_suspend(struct device *dev)\n{\n\tstruct stm32f7_i2c_dev *i2c_dev = dev_get_drvdata(dev);\n\n\tif (!stm32f7_i2c_is_slave_registered(i2c_dev))\n\t\tclk_disable_unprepare(i2c_dev->clk);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused stm32f7_i2c_runtime_resume(struct device *dev)\n{\n\tstruct stm32f7_i2c_dev *i2c_dev = dev_get_drvdata(dev);\n\tint ret;\n\n\tif (!stm32f7_i2c_is_slave_registered(i2c_dev)) {\n\t\tret = clk_prepare_enable(i2c_dev->clk);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"failed to prepare_enable clock\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int __maybe_unused stm32f7_i2c_regs_backup(struct stm32f7_i2c_dev *i2c_dev)\n{\n\tint ret;\n\tstruct stm32f7_i2c_regs *backup_regs = &i2c_dev->backup_regs;\n\n\tret = pm_runtime_resume_and_get(i2c_dev->dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tbackup_regs->cr1 = readl_relaxed(i2c_dev->base + STM32F7_I2C_CR1);\n\tbackup_regs->cr2 = readl_relaxed(i2c_dev->base + STM32F7_I2C_CR2);\n\tbackup_regs->oar1 = readl_relaxed(i2c_dev->base + STM32F7_I2C_OAR1);\n\tbackup_regs->oar2 = readl_relaxed(i2c_dev->base + STM32F7_I2C_OAR2);\n\tbackup_regs->tmgr = readl_relaxed(i2c_dev->base + STM32F7_I2C_TIMINGR);\n\tstm32f7_i2c_write_fm_plus_bits(i2c_dev, false);\n\n\tpm_runtime_put_sync(i2c_dev->dev);\n\n\treturn ret;\n}\n\nstatic int __maybe_unused stm32f7_i2c_regs_restore(struct stm32f7_i2c_dev *i2c_dev)\n{\n\tu32 cr1;\n\tint ret;\n\tstruct stm32f7_i2c_regs *backup_regs = &i2c_dev->backup_regs;\n\n\tret = pm_runtime_resume_and_get(i2c_dev->dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tcr1 = readl_relaxed(i2c_dev->base + STM32F7_I2C_CR1);\n\tif (cr1 & STM32F7_I2C_CR1_PE)\n\t\tstm32f7_i2c_clr_bits(i2c_dev->base + STM32F7_I2C_CR1,\n\t\t\t\t     STM32F7_I2C_CR1_PE);\n\n\twritel_relaxed(backup_regs->tmgr, i2c_dev->base + STM32F7_I2C_TIMINGR);\n\twritel_relaxed(backup_regs->cr1 & ~STM32F7_I2C_CR1_PE,\n\t\t       i2c_dev->base + STM32F7_I2C_CR1);\n\tif (backup_regs->cr1 & STM32F7_I2C_CR1_PE)\n\t\tstm32f7_i2c_set_bits(i2c_dev->base + STM32F7_I2C_CR1,\n\t\t\t\t     STM32F7_I2C_CR1_PE);\n\twritel_relaxed(backup_regs->cr2, i2c_dev->base + STM32F7_I2C_CR2);\n\twritel_relaxed(backup_regs->oar1, i2c_dev->base + STM32F7_I2C_OAR1);\n\twritel_relaxed(backup_regs->oar2, i2c_dev->base + STM32F7_I2C_OAR2);\n\tstm32f7_i2c_write_fm_plus_bits(i2c_dev, true);\n\n\tpm_runtime_put_sync(i2c_dev->dev);\n\n\treturn ret;\n}\n\nstatic int __maybe_unused stm32f7_i2c_suspend(struct device *dev)\n{\n\tstruct stm32f7_i2c_dev *i2c_dev = dev_get_drvdata(dev);\n\tint ret;\n\n\ti2c_mark_adapter_suspended(&i2c_dev->adap);\n\n\tif (!device_may_wakeup(dev) && !device_wakeup_path(dev)) {\n\t\tret = stm32f7_i2c_regs_backup(i2c_dev);\n\t\tif (ret < 0) {\n\t\t\ti2c_mark_adapter_resumed(&i2c_dev->adap);\n\t\t\treturn ret;\n\t\t}\n\n\t\tpinctrl_pm_select_sleep_state(dev);\n\t\tpm_runtime_force_suspend(dev);\n\t}\n\n\treturn 0;\n}\n\nstatic int __maybe_unused stm32f7_i2c_resume(struct device *dev)\n{\n\tstruct stm32f7_i2c_dev *i2c_dev = dev_get_drvdata(dev);\n\tint ret;\n\n\tif (!device_may_wakeup(dev) && !device_wakeup_path(dev)) {\n\t\tret = pm_runtime_force_resume(dev);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tpinctrl_pm_select_default_state(dev);\n\n\t\tret = stm32f7_i2c_regs_restore(i2c_dev);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\ti2c_mark_adapter_resumed(&i2c_dev->adap);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops stm32f7_i2c_pm_ops = {\n\tSET_RUNTIME_PM_OPS(stm32f7_i2c_runtime_suspend,\n\t\t\t   stm32f7_i2c_runtime_resume, NULL)\n\tSET_SYSTEM_SLEEP_PM_OPS(stm32f7_i2c_suspend, stm32f7_i2c_resume)\n};\n\nstatic const struct of_device_id stm32f7_i2c_match[] = {\n\t{ .compatible = \"st,stm32f7-i2c\", .data = &stm32f7_setup},\n\t{ .compatible = \"st,stm32mp15-i2c\", .data = &stm32mp15_setup},\n\t{ .compatible = \"st,stm32mp13-i2c\", .data = &stm32mp13_setup},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, stm32f7_i2c_match);\n\nstatic struct platform_driver stm32f7_i2c_driver = {\n\t.driver = {\n\t\t.name = \"stm32f7-i2c\",\n\t\t.of_match_table = stm32f7_i2c_match,\n\t\t.pm = &stm32f7_i2c_pm_ops,\n\t},\n\t.probe = stm32f7_i2c_probe,\n\t.remove_new = stm32f7_i2c_remove,\n};\n\nmodule_platform_driver(stm32f7_i2c_driver);\n\nMODULE_AUTHOR(\"M'boumba Cedric Madianga <cedric.madianga@gmail.com>\");\nMODULE_DESCRIPTION(\"STMicroelectronics STM32F7 I2C driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}