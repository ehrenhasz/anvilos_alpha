{
  "module_name": "i2c-imx.c",
  "hash_id": "b4c58a8511a762608198559116aa9ec812c31e9c89978c9da48ee55845b20072",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-imx.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/clk.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/dma-mapping.h>\n#include <linux/dmaengine.h>\n#include <linux/dmapool.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/hrtimer.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_dma.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/platform_data/i2c-imx.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\n \n#define DRIVER_NAME \"imx-i2c\"\n\n#define I2C_IMX_CHECK_DELAY 30000  \n\n \n#define DMA_THRESHOLD\t16\n#define DMA_TIMEOUT\t1000\n\n \n#define IMX_I2C_IADR\t0x00\t \n#define IMX_I2C_IFDR\t0x01\t \n#define IMX_I2C_I2CR\t0x02\t \n#define IMX_I2C_I2SR\t0x03\t \n#define IMX_I2C_I2DR\t0x04\t \n\n \n#define IMX_I2C_IBIC\t0x05     \n\n#define IMX_I2C_REGSHIFT\t2\n#define VF610_I2C_REGSHIFT\t0\n\n \n#define I2SR_RXAK\t0x01\n#define I2SR_IIF\t0x02\n#define I2SR_SRW\t0x04\n#define I2SR_IAL\t0x10\n#define I2SR_IBB\t0x20\n#define I2SR_IAAS\t0x40\n#define I2SR_ICF\t0x80\n#define I2CR_DMAEN\t0x02\n#define I2CR_RSTA\t0x04\n#define I2CR_TXAK\t0x08\n#define I2CR_MTX\t0x10\n#define I2CR_MSTA\t0x20\n#define I2CR_IIEN\t0x40\n#define I2CR_IEN\t0x80\n#define IBIC_BIIE\t0x80  \n\n \n#define I2SR_CLR_OPCODE_W0C\t0x0\n#define I2SR_CLR_OPCODE_W1C\t(I2SR_IAL | I2SR_IIF)\n#define I2CR_IEN_OPCODE_0\t0x0\n#define I2CR_IEN_OPCODE_1\tI2CR_IEN\n\n#define I2C_PM_TIMEOUT\t\t10  \n\n \nstruct imx_i2c_clk_pair {\n\tu16\tdiv;\n\tu16\tval;\n};\n\nstatic struct imx_i2c_clk_pair imx_i2c_clk_div[] = {\n\t{ 22,\t0x20 }, { 24,\t0x21 }, { 26,\t0x22 }, { 28,\t0x23 },\n\t{ 30,\t0x00 },\t{ 32,\t0x24 }, { 36,\t0x25 }, { 40,\t0x26 },\n\t{ 42,\t0x03 }, { 44,\t0x27 },\t{ 48,\t0x28 }, { 52,\t0x05 },\n\t{ 56,\t0x29 }, { 60,\t0x06 }, { 64,\t0x2A },\t{ 72,\t0x2B },\n\t{ 80,\t0x2C }, { 88,\t0x09 }, { 96,\t0x2D }, { 104,\t0x0A },\n\t{ 112,\t0x2E }, { 128,\t0x2F }, { 144,\t0x0C }, { 160,\t0x30 },\n\t{ 192,\t0x31 },\t{ 224,\t0x32 }, { 240,\t0x0F }, { 256,\t0x33 },\n\t{ 288,\t0x10 }, { 320,\t0x34 },\t{ 384,\t0x35 }, { 448,\t0x36 },\n\t{ 480,\t0x13 }, { 512,\t0x37 }, { 576,\t0x14 },\t{ 640,\t0x38 },\n\t{ 768,\t0x39 }, { 896,\t0x3A }, { 960,\t0x17 }, { 1024,\t0x3B },\n\t{ 1152,\t0x18 }, { 1280,\t0x3C }, { 1536,\t0x3D }, { 1792,\t0x3E },\n\t{ 1920,\t0x1B },\t{ 2048,\t0x3F }, { 2304,\t0x1C }, { 2560,\t0x1D },\n\t{ 3072,\t0x1E }, { 3840,\t0x1F }\n};\n\n \nstatic struct imx_i2c_clk_pair vf610_i2c_clk_div[] = {\n\t{ 20,   0x00 }, { 22,   0x01 }, { 24,   0x02 }, { 26,   0x03 },\n\t{ 28,   0x04 }, { 30,   0x05 }, { 32,   0x09 }, { 34,   0x06 },\n\t{ 36,   0x0A }, { 40,   0x07 }, { 44,   0x0C }, { 48,   0x0D },\n\t{ 52,   0x43 }, { 56,   0x0E }, { 60,   0x45 }, { 64,   0x12 },\n\t{ 68,   0x0F }, { 72,   0x13 }, { 80,   0x14 }, { 88,   0x15 },\n\t{ 96,   0x19 }, { 104,  0x16 }, { 112,  0x1A }, { 128,  0x17 },\n\t{ 136,  0x4F }, { 144,  0x1C }, { 160,  0x1D }, { 176,  0x55 },\n\t{ 192,  0x1E }, { 208,  0x56 }, { 224,  0x22 }, { 228,  0x24 },\n\t{ 240,  0x1F }, { 256,  0x23 }, { 288,  0x5C }, { 320,  0x25 },\n\t{ 384,  0x26 }, { 448,  0x2A }, { 480,  0x27 }, { 512,  0x2B },\n\t{ 576,  0x2C }, { 640,  0x2D }, { 768,  0x31 }, { 896,  0x32 },\n\t{ 960,  0x2F }, { 1024, 0x33 }, { 1152, 0x34 }, { 1280, 0x35 },\n\t{ 1536, 0x36 }, { 1792, 0x3A }, { 1920, 0x37 }, { 2048, 0x3B },\n\t{ 2304, 0x3C }, { 2560, 0x3D }, { 3072, 0x3E }, { 3584, 0x7A },\n\t{ 3840, 0x3F }, { 4096, 0x7B }, { 5120, 0x7D }, { 6144, 0x7E },\n};\n\nenum imx_i2c_type {\n\tIMX1_I2C,\n\tIMX21_I2C,\n\tVF610_I2C,\n};\n\nstruct imx_i2c_hwdata {\n\tenum imx_i2c_type\tdevtype;\n\tunsigned int\t\tregshift;\n\tstruct imx_i2c_clk_pair\t*clk_div;\n\tunsigned int\t\tndivs;\n\tunsigned int\t\ti2sr_clr_opcode;\n\tunsigned int\t\ti2cr_ien_opcode;\n\t \n\tbool\t\t\thas_err007805;\n};\n\nstruct imx_i2c_dma {\n\tstruct dma_chan\t\t*chan_tx;\n\tstruct dma_chan\t\t*chan_rx;\n\tstruct dma_chan\t\t*chan_using;\n\tstruct completion\tcmd_complete;\n\tdma_addr_t\t\tdma_buf;\n\tunsigned int\t\tdma_len;\n\tenum dma_transfer_direction dma_transfer_dir;\n\tenum dma_data_direction dma_data_dir;\n};\n\nstruct imx_i2c_struct {\n\tstruct i2c_adapter\tadapter;\n\tstruct clk\t\t*clk;\n\tstruct notifier_block\tclk_change_nb;\n\tvoid __iomem\t\t*base;\n\twait_queue_head_t\tqueue;\n\tunsigned long\t\ti2csr;\n\tunsigned int\t\tdisable_delay;\n\tint\t\t\tstopped;\n\tunsigned int\t\tifdr;  \n\tunsigned int\t\tcur_clk;\n\tunsigned int\t\tbitrate;\n\tconst struct imx_i2c_hwdata\t*hwdata;\n\tstruct i2c_bus_recovery_info rinfo;\n\n\tstruct pinctrl *pinctrl;\n\tstruct pinctrl_state *pinctrl_pins_default;\n\tstruct pinctrl_state *pinctrl_pins_gpio;\n\n\tstruct imx_i2c_dma\t*dma;\n\tstruct i2c_client\t*slave;\n\tenum i2c_slave_event last_slave_event;\n\n\t \n\tspinlock_t     slave_lock;\n\tstruct hrtimer slave_timer;\n};\n\nstatic const struct imx_i2c_hwdata imx1_i2c_hwdata = {\n\t.devtype\t\t= IMX1_I2C,\n\t.regshift\t\t= IMX_I2C_REGSHIFT,\n\t.clk_div\t\t= imx_i2c_clk_div,\n\t.ndivs\t\t\t= ARRAY_SIZE(imx_i2c_clk_div),\n\t.i2sr_clr_opcode\t= I2SR_CLR_OPCODE_W0C,\n\t.i2cr_ien_opcode\t= I2CR_IEN_OPCODE_1,\n\n};\n\nstatic const struct imx_i2c_hwdata imx21_i2c_hwdata = {\n\t.devtype\t\t= IMX21_I2C,\n\t.regshift\t\t= IMX_I2C_REGSHIFT,\n\t.clk_div\t\t= imx_i2c_clk_div,\n\t.ndivs\t\t\t= ARRAY_SIZE(imx_i2c_clk_div),\n\t.i2sr_clr_opcode\t= I2SR_CLR_OPCODE_W0C,\n\t.i2cr_ien_opcode\t= I2CR_IEN_OPCODE_1,\n\n};\n\nstatic const struct imx_i2c_hwdata imx6_i2c_hwdata = {\n\t.devtype\t\t= IMX21_I2C,\n\t.regshift\t\t= IMX_I2C_REGSHIFT,\n\t.clk_div\t\t= imx_i2c_clk_div,\n\t.ndivs\t\t\t= ARRAY_SIZE(imx_i2c_clk_div),\n\t.i2sr_clr_opcode\t= I2SR_CLR_OPCODE_W0C,\n\t.i2cr_ien_opcode\t= I2CR_IEN_OPCODE_1,\n\t.has_err007805\t\t= true,\n};\n\nstatic struct imx_i2c_hwdata vf610_i2c_hwdata = {\n\t.devtype\t\t= VF610_I2C,\n\t.regshift\t\t= VF610_I2C_REGSHIFT,\n\t.clk_div\t\t= vf610_i2c_clk_div,\n\t.ndivs\t\t\t= ARRAY_SIZE(vf610_i2c_clk_div),\n\t.i2sr_clr_opcode\t= I2SR_CLR_OPCODE_W1C,\n\t.i2cr_ien_opcode\t= I2CR_IEN_OPCODE_0,\n\n};\n\nstatic const struct platform_device_id imx_i2c_devtype[] = {\n\t{\n\t\t.name = \"imx1-i2c\",\n\t\t.driver_data = (kernel_ulong_t)&imx1_i2c_hwdata,\n\t}, {\n\t\t.name = \"imx21-i2c\",\n\t\t.driver_data = (kernel_ulong_t)&imx21_i2c_hwdata,\n\t}, {\n\t\t \n\t}\n};\nMODULE_DEVICE_TABLE(platform, imx_i2c_devtype);\n\nstatic const struct of_device_id i2c_imx_dt_ids[] = {\n\t{ .compatible = \"fsl,imx1-i2c\", .data = &imx1_i2c_hwdata, },\n\t{ .compatible = \"fsl,imx21-i2c\", .data = &imx21_i2c_hwdata, },\n\t{ .compatible = \"fsl,imx6q-i2c\", .data = &imx6_i2c_hwdata, },\n\t{ .compatible = \"fsl,imx6sl-i2c\", .data = &imx6_i2c_hwdata, },\n\t{ .compatible = \"fsl,imx6sll-i2c\", .data = &imx6_i2c_hwdata, },\n\t{ .compatible = \"fsl,imx6sx-i2c\", .data = &imx6_i2c_hwdata, },\n\t{ .compatible = \"fsl,imx6ul-i2c\", .data = &imx6_i2c_hwdata, },\n\t{ .compatible = \"fsl,imx7s-i2c\", .data = &imx6_i2c_hwdata, },\n\t{ .compatible = \"fsl,imx8mm-i2c\", .data = &imx6_i2c_hwdata, },\n\t{ .compatible = \"fsl,imx8mn-i2c\", .data = &imx6_i2c_hwdata, },\n\t{ .compatible = \"fsl,imx8mp-i2c\", .data = &imx6_i2c_hwdata, },\n\t{ .compatible = \"fsl,imx8mq-i2c\", .data = &imx6_i2c_hwdata, },\n\t{ .compatible = \"fsl,vf610-i2c\", .data = &vf610_i2c_hwdata, },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, i2c_imx_dt_ids);\n\nstatic const struct acpi_device_id i2c_imx_acpi_ids[] = {\n\t{\"NXP0001\", .driver_data = (kernel_ulong_t)&vf610_i2c_hwdata},\n\t{ }\n};\nMODULE_DEVICE_TABLE(acpi, i2c_imx_acpi_ids);\n\nstatic inline int is_imx1_i2c(struct imx_i2c_struct *i2c_imx)\n{\n\treturn i2c_imx->hwdata->devtype == IMX1_I2C;\n}\n\nstatic inline int is_vf610_i2c(struct imx_i2c_struct *i2c_imx)\n{\n\treturn i2c_imx->hwdata->devtype == VF610_I2C;\n}\n\nstatic inline void imx_i2c_write_reg(unsigned int val,\n\t\tstruct imx_i2c_struct *i2c_imx, unsigned int reg)\n{\n\twriteb(val, i2c_imx->base + (reg << i2c_imx->hwdata->regshift));\n}\n\nstatic inline unsigned char imx_i2c_read_reg(struct imx_i2c_struct *i2c_imx,\n\t\tunsigned int reg)\n{\n\treturn readb(i2c_imx->base + (reg << i2c_imx->hwdata->regshift));\n}\n\nstatic void i2c_imx_clear_irq(struct imx_i2c_struct *i2c_imx, unsigned int bits)\n{\n\tunsigned int temp;\n\n\t \n\ttemp = ~i2c_imx->hwdata->i2sr_clr_opcode ^ bits;\n\timx_i2c_write_reg(temp, i2c_imx, IMX_I2C_I2SR);\n}\n\n \nstatic void i2c_imx_reset_regs(struct imx_i2c_struct *i2c_imx)\n{\n\timx_i2c_write_reg(i2c_imx->hwdata->i2cr_ien_opcode ^ I2CR_IEN,\n\t\t\t  i2c_imx, IMX_I2C_I2CR);\n\ti2c_imx_clear_irq(i2c_imx, I2SR_IIF | I2SR_IAL);\n}\n\n \nstatic void i2c_imx_dma_request(struct imx_i2c_struct *i2c_imx,\n\t\t\t\t\t\tdma_addr_t phy_addr)\n{\n\tstruct imx_i2c_dma *dma;\n\tstruct dma_slave_config dma_sconfig;\n\tstruct device *dev = &i2c_imx->adapter.dev;\n\tint ret;\n\n\tdma = devm_kzalloc(dev, sizeof(*dma), GFP_KERNEL);\n\tif (!dma)\n\t\treturn;\n\n\tdma->chan_tx = dma_request_chan(dev, \"tx\");\n\tif (IS_ERR(dma->chan_tx)) {\n\t\tret = PTR_ERR(dma->chan_tx);\n\t\tif (ret != -ENODEV && ret != -EPROBE_DEFER)\n\t\t\tdev_err(dev, \"can't request DMA tx channel (%d)\\n\", ret);\n\t\tgoto fail_al;\n\t}\n\n\tdma_sconfig.dst_addr = phy_addr +\n\t\t\t\t(IMX_I2C_I2DR << i2c_imx->hwdata->regshift);\n\tdma_sconfig.dst_addr_width = DMA_SLAVE_BUSWIDTH_1_BYTE;\n\tdma_sconfig.dst_maxburst = 1;\n\tdma_sconfig.direction = DMA_MEM_TO_DEV;\n\tret = dmaengine_slave_config(dma->chan_tx, &dma_sconfig);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"can't configure tx channel (%d)\\n\", ret);\n\t\tgoto fail_tx;\n\t}\n\n\tdma->chan_rx = dma_request_chan(dev, \"rx\");\n\tif (IS_ERR(dma->chan_rx)) {\n\t\tret = PTR_ERR(dma->chan_rx);\n\t\tif (ret != -ENODEV && ret != -EPROBE_DEFER)\n\t\t\tdev_err(dev, \"can't request DMA rx channel (%d)\\n\", ret);\n\t\tgoto fail_tx;\n\t}\n\n\tdma_sconfig.src_addr = phy_addr +\n\t\t\t\t(IMX_I2C_I2DR << i2c_imx->hwdata->regshift);\n\tdma_sconfig.src_addr_width = DMA_SLAVE_BUSWIDTH_1_BYTE;\n\tdma_sconfig.src_maxburst = 1;\n\tdma_sconfig.direction = DMA_DEV_TO_MEM;\n\tret = dmaengine_slave_config(dma->chan_rx, &dma_sconfig);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"can't configure rx channel (%d)\\n\", ret);\n\t\tgoto fail_rx;\n\t}\n\n\ti2c_imx->dma = dma;\n\tinit_completion(&dma->cmd_complete);\n\tdev_info(dev, \"using %s (tx) and %s (rx) for DMA transfers\\n\",\n\t\tdma_chan_name(dma->chan_tx), dma_chan_name(dma->chan_rx));\n\n\treturn;\n\nfail_rx:\n\tdma_release_channel(dma->chan_rx);\nfail_tx:\n\tdma_release_channel(dma->chan_tx);\nfail_al:\n\tdevm_kfree(dev, dma);\n}\n\nstatic void i2c_imx_dma_callback(void *arg)\n{\n\tstruct imx_i2c_struct *i2c_imx = (struct imx_i2c_struct *)arg;\n\tstruct imx_i2c_dma *dma = i2c_imx->dma;\n\n\tdma_unmap_single(dma->chan_using->device->dev, dma->dma_buf,\n\t\t\tdma->dma_len, dma->dma_data_dir);\n\tcomplete(&dma->cmd_complete);\n}\n\nstatic int i2c_imx_dma_xfer(struct imx_i2c_struct *i2c_imx,\n\t\t\t\t\tstruct i2c_msg *msgs)\n{\n\tstruct imx_i2c_dma *dma = i2c_imx->dma;\n\tstruct dma_async_tx_descriptor *txdesc;\n\tstruct device *dev = &i2c_imx->adapter.dev;\n\tstruct device *chan_dev = dma->chan_using->device->dev;\n\n\tdma->dma_buf = dma_map_single(chan_dev, msgs->buf,\n\t\t\t\t\tdma->dma_len, dma->dma_data_dir);\n\tif (dma_mapping_error(chan_dev, dma->dma_buf)) {\n\t\tdev_err(dev, \"DMA mapping failed\\n\");\n\t\tgoto err_map;\n\t}\n\n\ttxdesc = dmaengine_prep_slave_single(dma->chan_using, dma->dma_buf,\n\t\t\t\t\tdma->dma_len, dma->dma_transfer_dir,\n\t\t\t\t\tDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\n\tif (!txdesc) {\n\t\tdev_err(dev, \"Not able to get desc for DMA xfer\\n\");\n\t\tgoto err_desc;\n\t}\n\n\treinit_completion(&dma->cmd_complete);\n\ttxdesc->callback = i2c_imx_dma_callback;\n\ttxdesc->callback_param = i2c_imx;\n\tif (dma_submit_error(dmaengine_submit(txdesc))) {\n\t\tdev_err(dev, \"DMA submit failed\\n\");\n\t\tgoto err_submit;\n\t}\n\n\tdma_async_issue_pending(dma->chan_using);\n\treturn 0;\n\nerr_submit:\n\tdmaengine_terminate_sync(dma->chan_using);\nerr_desc:\n\tdma_unmap_single(chan_dev, dma->dma_buf,\n\t\t\tdma->dma_len, dma->dma_data_dir);\nerr_map:\n\treturn -EINVAL;\n}\n\nstatic void i2c_imx_dma_free(struct imx_i2c_struct *i2c_imx)\n{\n\tstruct imx_i2c_dma *dma = i2c_imx->dma;\n\n\tdma->dma_buf = 0;\n\tdma->dma_len = 0;\n\n\tdma_release_channel(dma->chan_tx);\n\tdma->chan_tx = NULL;\n\n\tdma_release_channel(dma->chan_rx);\n\tdma->chan_rx = NULL;\n\n\tdma->chan_using = NULL;\n}\n\nstatic int i2c_imx_bus_busy(struct imx_i2c_struct *i2c_imx, int for_busy, bool atomic)\n{\n\tunsigned long orig_jiffies = jiffies;\n\tunsigned int temp;\n\n\twhile (1) {\n\t\ttemp = imx_i2c_read_reg(i2c_imx, IMX_I2C_I2SR);\n\n\t\t \n\t\tif (temp & I2SR_IAL) {\n\t\t\ti2c_imx_clear_irq(i2c_imx, I2SR_IAL);\n\t\t\treturn -EAGAIN;\n\t\t}\n\n\t\tif (for_busy && (temp & I2SR_IBB)) {\n\t\t\ti2c_imx->stopped = 0;\n\t\t\tbreak;\n\t\t}\n\t\tif (!for_busy && !(temp & I2SR_IBB)) {\n\t\t\ti2c_imx->stopped = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (time_after(jiffies, orig_jiffies + msecs_to_jiffies(500))) {\n\t\t\tdev_dbg(&i2c_imx->adapter.dev,\n\t\t\t\t\"<%s> I2C bus is busy\\n\", __func__);\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t\tif (atomic)\n\t\t\tudelay(100);\n\t\telse\n\t\t\tschedule();\n\t}\n\n\treturn 0;\n}\n\nstatic int i2c_imx_trx_complete(struct imx_i2c_struct *i2c_imx, bool atomic)\n{\n\tif (atomic) {\n\t\tvoid __iomem *addr = i2c_imx->base + (IMX_I2C_I2SR << i2c_imx->hwdata->regshift);\n\t\tunsigned int regval;\n\n\t\t \n\t\treadb_poll_timeout_atomic(addr, regval, regval & I2SR_IIF, 5, 1000 + 100);\n\t\ti2c_imx->i2csr = regval;\n\t\ti2c_imx_clear_irq(i2c_imx, I2SR_IIF | I2SR_IAL);\n\t} else {\n\t\twait_event_timeout(i2c_imx->queue, i2c_imx->i2csr & I2SR_IIF, HZ / 10);\n\t}\n\n\tif (unlikely(!(i2c_imx->i2csr & I2SR_IIF))) {\n\t\tdev_dbg(&i2c_imx->adapter.dev, \"<%s> Timeout\\n\", __func__);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\t \n\tif (i2c_imx->i2csr & I2SR_IAL) {\n\t\tdev_dbg(&i2c_imx->adapter.dev, \"<%s> Arbitration lost\\n\", __func__);\n\t\ti2c_imx_clear_irq(i2c_imx, I2SR_IAL);\n\n\t\ti2c_imx->i2csr = 0;\n\t\treturn -EAGAIN;\n\t}\n\n\tdev_dbg(&i2c_imx->adapter.dev, \"<%s> TRX complete\\n\", __func__);\n\ti2c_imx->i2csr = 0;\n\treturn 0;\n}\n\nstatic int i2c_imx_acked(struct imx_i2c_struct *i2c_imx)\n{\n\tif (imx_i2c_read_reg(i2c_imx, IMX_I2C_I2SR) & I2SR_RXAK) {\n\t\tdev_dbg(&i2c_imx->adapter.dev, \"<%s> No ACK\\n\", __func__);\n\t\treturn -ENXIO;   \n\t}\n\n\tdev_dbg(&i2c_imx->adapter.dev, \"<%s> ACK received\\n\", __func__);\n\treturn 0;\n}\n\nstatic void i2c_imx_set_clk(struct imx_i2c_struct *i2c_imx,\n\t\t\t    unsigned int i2c_clk_rate)\n{\n\tstruct imx_i2c_clk_pair *i2c_clk_div = i2c_imx->hwdata->clk_div;\n\tunsigned int div;\n\tint i;\n\n\tif (i2c_imx->hwdata->has_err007805 && i2c_imx->bitrate > 384000) {\n\t\tdev_dbg(&i2c_imx->adapter.dev,\n\t\t\t\"SoC errata ERR007805 or e7805 applies, bus frequency limited from %d Hz to 384000 Hz.\\n\",\n\t\t\ti2c_imx->bitrate);\n\t\ti2c_imx->bitrate = 384000;\n\t}\n\n\t \n\tif (i2c_imx->cur_clk == i2c_clk_rate)\n\t\treturn;\n\n\ti2c_imx->cur_clk = i2c_clk_rate;\n\n\tdiv = DIV_ROUND_UP(i2c_clk_rate, i2c_imx->bitrate);\n\tif (div < i2c_clk_div[0].div)\n\t\ti = 0;\n\telse if (div > i2c_clk_div[i2c_imx->hwdata->ndivs - 1].div)\n\t\ti = i2c_imx->hwdata->ndivs - 1;\n\telse\n\t\tfor (i = 0; i2c_clk_div[i].div < div; i++)\n\t\t\t;\n\n\t \n\ti2c_imx->ifdr = i2c_clk_div[i].val;\n\n\t \n\ti2c_imx->disable_delay = DIV_ROUND_UP(500000U * i2c_clk_div[i].div,\n\t\t\t\t\t      i2c_clk_rate / 2);\n\n#ifdef CONFIG_I2C_DEBUG_BUS\n\tdev_dbg(&i2c_imx->adapter.dev, \"I2C_CLK=%d, REQ DIV=%d\\n\",\n\t\ti2c_clk_rate, div);\n\tdev_dbg(&i2c_imx->adapter.dev, \"IFDR[IC]=0x%x, REAL DIV=%d\\n\",\n\t\ti2c_clk_div[i].val, i2c_clk_div[i].div);\n#endif\n}\n\nstatic int i2c_imx_clk_notifier_call(struct notifier_block *nb,\n\t\t\t\t     unsigned long action, void *data)\n{\n\tstruct clk_notifier_data *ndata = data;\n\tstruct imx_i2c_struct *i2c_imx = container_of(nb,\n\t\t\t\t\t\t      struct imx_i2c_struct,\n\t\t\t\t\t\t      clk_change_nb);\n\n\tif (action & POST_RATE_CHANGE)\n\t\ti2c_imx_set_clk(i2c_imx, ndata->new_rate);\n\n\treturn NOTIFY_OK;\n}\n\nstatic int i2c_imx_start(struct imx_i2c_struct *i2c_imx, bool atomic)\n{\n\tunsigned int temp = 0;\n\tint result;\n\n\timx_i2c_write_reg(i2c_imx->ifdr, i2c_imx, IMX_I2C_IFDR);\n\t \n\timx_i2c_write_reg(i2c_imx->hwdata->i2sr_clr_opcode, i2c_imx, IMX_I2C_I2SR);\n\timx_i2c_write_reg(i2c_imx->hwdata->i2cr_ien_opcode, i2c_imx, IMX_I2C_I2CR);\n\n\t \n\tif (atomic)\n\t\tudelay(50);\n\telse\n\t\tusleep_range(50, 150);\n\n\t \n\ttemp = imx_i2c_read_reg(i2c_imx, IMX_I2C_I2CR);\n\ttemp |= I2CR_MSTA;\n\timx_i2c_write_reg(temp, i2c_imx, IMX_I2C_I2CR);\n\tresult = i2c_imx_bus_busy(i2c_imx, 1, atomic);\n\tif (result)\n\t\treturn result;\n\n\ttemp |= I2CR_IIEN | I2CR_MTX | I2CR_TXAK;\n\tif (atomic)\n\t\ttemp &= ~I2CR_IIEN;  \n\n\ttemp &= ~I2CR_DMAEN;\n\timx_i2c_write_reg(temp, i2c_imx, IMX_I2C_I2CR);\n\treturn result;\n}\n\nstatic void i2c_imx_stop(struct imx_i2c_struct *i2c_imx, bool atomic)\n{\n\tunsigned int temp = 0;\n\n\tif (!i2c_imx->stopped) {\n\t\t \n\t\ttemp = imx_i2c_read_reg(i2c_imx, IMX_I2C_I2CR);\n\t\tif (!(temp & I2CR_MSTA))\n\t\t\ti2c_imx->stopped = 1;\n\t\ttemp &= ~(I2CR_MSTA | I2CR_MTX);\n\t\tif (i2c_imx->dma)\n\t\t\ttemp &= ~I2CR_DMAEN;\n\t\timx_i2c_write_reg(temp, i2c_imx, IMX_I2C_I2CR);\n\t}\n\tif (is_imx1_i2c(i2c_imx)) {\n\t\t \n\t\tudelay(i2c_imx->disable_delay);\n\t}\n\n\tif (!i2c_imx->stopped)\n\t\ti2c_imx_bus_busy(i2c_imx, 0, atomic);\n\n\t \n\ttemp = i2c_imx->hwdata->i2cr_ien_opcode ^ I2CR_IEN,\n\timx_i2c_write_reg(temp, i2c_imx, IMX_I2C_I2CR);\n}\n\n \nstatic void i2c_imx_enable_bus_idle(struct imx_i2c_struct *i2c_imx)\n{\n\tif (is_vf610_i2c(i2c_imx)) {\n\t\tunsigned int temp;\n\n\t\ttemp = imx_i2c_read_reg(i2c_imx, IMX_I2C_IBIC);\n\t\ttemp |= IBIC_BIIE;\n\t\timx_i2c_write_reg(temp, i2c_imx, IMX_I2C_IBIC);\n\t}\n}\n\nstatic void i2c_imx_slave_event(struct imx_i2c_struct *i2c_imx,\n\t\t\t\tenum i2c_slave_event event, u8 *val)\n{\n\ti2c_slave_event(i2c_imx->slave, event, val);\n\ti2c_imx->last_slave_event = event;\n}\n\nstatic void i2c_imx_slave_finish_op(struct imx_i2c_struct *i2c_imx)\n{\n\tu8 val = 0;\n\n\twhile (i2c_imx->last_slave_event != I2C_SLAVE_STOP) {\n\t\tswitch (i2c_imx->last_slave_event) {\n\t\tcase I2C_SLAVE_READ_REQUESTED:\n\t\t\ti2c_imx_slave_event(i2c_imx, I2C_SLAVE_READ_PROCESSED,\n\t\t\t\t\t    &val);\n\t\t\tbreak;\n\n\t\tcase I2C_SLAVE_WRITE_REQUESTED:\n\t\tcase I2C_SLAVE_READ_PROCESSED:\n\t\tcase I2C_SLAVE_WRITE_RECEIVED:\n\t\t\ti2c_imx_slave_event(i2c_imx, I2C_SLAVE_STOP, &val);\n\t\t\tbreak;\n\n\t\tcase I2C_SLAVE_STOP:\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n \nstatic irqreturn_t i2c_imx_slave_handle(struct imx_i2c_struct *i2c_imx,\n\t\t\t\t\tunsigned int status, unsigned int ctl)\n{\n\tu8 value = 0;\n\n\tif (status & I2SR_IAL) {  \n\t\ti2c_imx_clear_irq(i2c_imx, I2SR_IAL);\n\t\tif (!(status & I2SR_IAAS))\n\t\t\treturn IRQ_HANDLED;\n\t}\n\n\tif (!(status & I2SR_IBB)) {\n\t\t \n\t\ti2c_imx_slave_finish_op(i2c_imx);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tif (!(status & I2SR_ICF))\n\t\t \n\t\tgoto out;\n\n\tif (status & I2SR_IAAS) {  \n\t\ti2c_imx_slave_finish_op(i2c_imx);\n\t\tif (status & I2SR_SRW) {  \n\t\t\tdev_dbg(&i2c_imx->adapter.dev, \"read requested\");\n\t\t\ti2c_imx_slave_event(i2c_imx,\n\t\t\t\t\t    I2C_SLAVE_READ_REQUESTED, &value);\n\n\t\t\t \n\t\t\tctl |= I2CR_MTX;\n\t\t\timx_i2c_write_reg(ctl, i2c_imx, IMX_I2C_I2CR);\n\n\t\t\t \n\t\t\timx_i2c_write_reg(value, i2c_imx, IMX_I2C_I2DR);\n\t\t} else {  \n\t\t\tdev_dbg(&i2c_imx->adapter.dev, \"write requested\");\n\t\t\ti2c_imx_slave_event(i2c_imx,\n\t\t\t\t\t    I2C_SLAVE_WRITE_REQUESTED, &value);\n\n\t\t\t \n\t\t\tctl &= ~I2CR_MTX;\n\t\t\timx_i2c_write_reg(ctl, i2c_imx, IMX_I2C_I2CR);\n\t\t\t \n\t\t\timx_i2c_read_reg(i2c_imx, IMX_I2C_I2DR);\n\t\t}\n\t} else if (!(ctl & I2CR_MTX)) {  \n\t\tvalue = imx_i2c_read_reg(i2c_imx, IMX_I2C_I2DR);\n\t\ti2c_imx_slave_event(i2c_imx,\n\t\t\t\t    I2C_SLAVE_WRITE_RECEIVED, &value);\n\t} else if (!(status & I2SR_RXAK)) {  \n\t\tctl |= I2CR_MTX;\n\t\timx_i2c_write_reg(ctl, i2c_imx, IMX_I2C_I2CR);\n\n\t\ti2c_imx_slave_event(i2c_imx,\n\t\t\t\t    I2C_SLAVE_READ_PROCESSED, &value);\n\n\t\timx_i2c_write_reg(value, i2c_imx, IMX_I2C_I2DR);\n\t} else {  \n\t\tctl &= ~I2CR_MTX;\n\t\timx_i2c_write_reg(ctl, i2c_imx, IMX_I2C_I2CR);\n\t\timx_i2c_read_reg(i2c_imx, IMX_I2C_I2DR);\n\t\ti2c_imx_slave_finish_op(i2c_imx);\n\t\treturn IRQ_HANDLED;\n\t}\n\nout:\n\t \n\thrtimer_try_to_cancel(&i2c_imx->slave_timer);\n\thrtimer_forward_now(&i2c_imx->slave_timer, I2C_IMX_CHECK_DELAY);\n\thrtimer_restart(&i2c_imx->slave_timer);\n\treturn IRQ_HANDLED;\n}\n\nstatic enum hrtimer_restart i2c_imx_slave_timeout(struct hrtimer *t)\n{\n\tstruct imx_i2c_struct *i2c_imx = container_of(t, struct imx_i2c_struct,\n\t\t\t\t\t\t      slave_timer);\n\tunsigned int ctl, status;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&i2c_imx->slave_lock, flags);\n\tstatus = imx_i2c_read_reg(i2c_imx, IMX_I2C_I2SR);\n\tctl = imx_i2c_read_reg(i2c_imx, IMX_I2C_I2CR);\n\ti2c_imx_slave_handle(i2c_imx, status, ctl);\n\tspin_unlock_irqrestore(&i2c_imx->slave_lock, flags);\n\treturn HRTIMER_NORESTART;\n}\n\nstatic void i2c_imx_slave_init(struct imx_i2c_struct *i2c_imx)\n{\n\tint temp;\n\n\t \n\timx_i2c_write_reg((i2c_imx->slave->addr << 1), i2c_imx, IMX_I2C_IADR);\n\n\ti2c_imx_reset_regs(i2c_imx);\n\n\t \n\ttemp = i2c_imx->hwdata->i2cr_ien_opcode;\n\timx_i2c_write_reg(temp, i2c_imx, IMX_I2C_I2CR);\n\n\t \n\ttemp |= I2CR_IIEN;\n\timx_i2c_write_reg(temp, i2c_imx, IMX_I2C_I2CR);\n\n\ti2c_imx_enable_bus_idle(i2c_imx);\n}\n\nstatic int i2c_imx_reg_slave(struct i2c_client *client)\n{\n\tstruct imx_i2c_struct *i2c_imx = i2c_get_adapdata(client->adapter);\n\tint ret;\n\n\tif (i2c_imx->slave)\n\t\treturn -EBUSY;\n\n\ti2c_imx->slave = client;\n\ti2c_imx->last_slave_event = I2C_SLAVE_STOP;\n\n\t \n\tret = pm_runtime_resume_and_get(i2c_imx->adapter.dev.parent);\n\tif (ret < 0) {\n\t\tdev_err(&i2c_imx->adapter.dev, \"failed to resume i2c controller\");\n\t\treturn ret;\n\t}\n\n\ti2c_imx_slave_init(i2c_imx);\n\n\treturn 0;\n}\n\nstatic int i2c_imx_unreg_slave(struct i2c_client *client)\n{\n\tstruct imx_i2c_struct *i2c_imx = i2c_get_adapdata(client->adapter);\n\tint ret;\n\n\tif (!i2c_imx->slave)\n\t\treturn -EINVAL;\n\n\t \n\timx_i2c_write_reg(0, i2c_imx, IMX_I2C_IADR);\n\n\ti2c_imx_reset_regs(i2c_imx);\n\n\ti2c_imx->slave = NULL;\n\n\t \n\tret = pm_runtime_put_sync(i2c_imx->adapter.dev.parent);\n\tif (ret < 0)\n\t\tdev_err(&i2c_imx->adapter.dev, \"failed to suspend i2c controller\");\n\n\treturn ret;\n}\n\nstatic irqreturn_t i2c_imx_master_isr(struct imx_i2c_struct *i2c_imx, unsigned int status)\n{\n\t \n\ti2c_imx->i2csr = status;\n\twake_up(&i2c_imx->queue);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t i2c_imx_isr(int irq, void *dev_id)\n{\n\tstruct imx_i2c_struct *i2c_imx = dev_id;\n\tunsigned int ctl, status;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&i2c_imx->slave_lock, flags);\n\tstatus = imx_i2c_read_reg(i2c_imx, IMX_I2C_I2SR);\n\tctl = imx_i2c_read_reg(i2c_imx, IMX_I2C_I2CR);\n\n\tif (status & I2SR_IIF) {\n\t\ti2c_imx_clear_irq(i2c_imx, I2SR_IIF);\n\t\tif (i2c_imx->slave) {\n\t\t\tif (!(ctl & I2CR_MSTA)) {\n\t\t\t\tirqreturn_t ret;\n\n\t\t\t\tret = i2c_imx_slave_handle(i2c_imx,\n\t\t\t\t\t\t\t   status, ctl);\n\t\t\t\tspin_unlock_irqrestore(&i2c_imx->slave_lock,\n\t\t\t\t\t\t       flags);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\ti2c_imx_slave_finish_op(i2c_imx);\n\t\t}\n\t\tspin_unlock_irqrestore(&i2c_imx->slave_lock, flags);\n\t\treturn i2c_imx_master_isr(i2c_imx, status);\n\t}\n\tspin_unlock_irqrestore(&i2c_imx->slave_lock, flags);\n\n\treturn IRQ_NONE;\n}\n\nstatic int i2c_imx_dma_write(struct imx_i2c_struct *i2c_imx,\n\t\t\t\t\tstruct i2c_msg *msgs)\n{\n\tint result;\n\tunsigned long time_left;\n\tunsigned int temp = 0;\n\tunsigned long orig_jiffies = jiffies;\n\tstruct imx_i2c_dma *dma = i2c_imx->dma;\n\tstruct device *dev = &i2c_imx->adapter.dev;\n\n\tdma->chan_using = dma->chan_tx;\n\tdma->dma_transfer_dir = DMA_MEM_TO_DEV;\n\tdma->dma_data_dir = DMA_TO_DEVICE;\n\tdma->dma_len = msgs->len - 1;\n\tresult = i2c_imx_dma_xfer(i2c_imx, msgs);\n\tif (result)\n\t\treturn result;\n\n\ttemp = imx_i2c_read_reg(i2c_imx, IMX_I2C_I2CR);\n\ttemp |= I2CR_DMAEN;\n\timx_i2c_write_reg(temp, i2c_imx, IMX_I2C_I2CR);\n\n\t \n\timx_i2c_write_reg(i2c_8bit_addr_from_msg(msgs), i2c_imx, IMX_I2C_I2DR);\n\ttime_left = wait_for_completion_timeout(\n\t\t\t\t&i2c_imx->dma->cmd_complete,\n\t\t\t\tmsecs_to_jiffies(DMA_TIMEOUT));\n\tif (time_left == 0) {\n\t\tdmaengine_terminate_sync(dma->chan_using);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\t \n\twhile (1) {\n\t\ttemp = imx_i2c_read_reg(i2c_imx, IMX_I2C_I2SR);\n\t\tif (temp & I2SR_ICF)\n\t\t\tbreak;\n\t\tif (time_after(jiffies, orig_jiffies +\n\t\t\t\tmsecs_to_jiffies(DMA_TIMEOUT))) {\n\t\t\tdev_dbg(dev, \"<%s> Timeout\\n\", __func__);\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t\tschedule();\n\t}\n\n\ttemp = imx_i2c_read_reg(i2c_imx, IMX_I2C_I2CR);\n\ttemp &= ~I2CR_DMAEN;\n\timx_i2c_write_reg(temp, i2c_imx, IMX_I2C_I2CR);\n\n\t \n\timx_i2c_write_reg(msgs->buf[msgs->len-1],\n\t\t\t\ti2c_imx, IMX_I2C_I2DR);\n\tresult = i2c_imx_trx_complete(i2c_imx, false);\n\tif (result)\n\t\treturn result;\n\n\treturn i2c_imx_acked(i2c_imx);\n}\n\nstatic int i2c_imx_dma_read(struct imx_i2c_struct *i2c_imx,\n\t\t\tstruct i2c_msg *msgs, bool is_lastmsg)\n{\n\tint result;\n\tunsigned long time_left;\n\tunsigned int temp;\n\tunsigned long orig_jiffies = jiffies;\n\tstruct imx_i2c_dma *dma = i2c_imx->dma;\n\tstruct device *dev = &i2c_imx->adapter.dev;\n\n\n\tdma->chan_using = dma->chan_rx;\n\tdma->dma_transfer_dir = DMA_DEV_TO_MEM;\n\tdma->dma_data_dir = DMA_FROM_DEVICE;\n\t \n\tdma->dma_len = msgs->len - 2;\n\tresult = i2c_imx_dma_xfer(i2c_imx, msgs);\n\tif (result)\n\t\treturn result;\n\n\ttime_left = wait_for_completion_timeout(\n\t\t\t\t&i2c_imx->dma->cmd_complete,\n\t\t\t\tmsecs_to_jiffies(DMA_TIMEOUT));\n\tif (time_left == 0) {\n\t\tdmaengine_terminate_sync(dma->chan_using);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\t \n\twhile (1) {\n\t\ttemp = imx_i2c_read_reg(i2c_imx, IMX_I2C_I2SR);\n\t\tif (temp & I2SR_ICF)\n\t\t\tbreak;\n\t\tif (time_after(jiffies, orig_jiffies +\n\t\t\t\tmsecs_to_jiffies(DMA_TIMEOUT))) {\n\t\t\tdev_dbg(dev, \"<%s> Timeout\\n\", __func__);\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t\tschedule();\n\t}\n\n\ttemp = imx_i2c_read_reg(i2c_imx, IMX_I2C_I2CR);\n\ttemp &= ~I2CR_DMAEN;\n\timx_i2c_write_reg(temp, i2c_imx, IMX_I2C_I2CR);\n\n\t \n\ttemp = imx_i2c_read_reg(i2c_imx, IMX_I2C_I2CR);\n\ttemp |= I2CR_TXAK;\n\timx_i2c_write_reg(temp, i2c_imx, IMX_I2C_I2CR);\n\n\tmsgs->buf[msgs->len-2] = imx_i2c_read_reg(i2c_imx, IMX_I2C_I2DR);\n\t \n\tresult = i2c_imx_trx_complete(i2c_imx, false);\n\tif (result)\n\t\treturn result;\n\n\tif (is_lastmsg) {\n\t\t \n\t\tdev_dbg(dev, \"<%s> clear MSTA\\n\", __func__);\n\t\ttemp = imx_i2c_read_reg(i2c_imx, IMX_I2C_I2CR);\n\t\tif (!(temp & I2CR_MSTA))\n\t\t\ti2c_imx->stopped = 1;\n\t\ttemp &= ~(I2CR_MSTA | I2CR_MTX);\n\t\timx_i2c_write_reg(temp, i2c_imx, IMX_I2C_I2CR);\n\t\tif (!i2c_imx->stopped)\n\t\t\ti2c_imx_bus_busy(i2c_imx, 0, false);\n\t} else {\n\t\t \n\t\ttemp = imx_i2c_read_reg(i2c_imx, IMX_I2C_I2CR);\n\t\ttemp |= I2CR_MTX;\n\t\timx_i2c_write_reg(temp, i2c_imx, IMX_I2C_I2CR);\n\t}\n\tmsgs->buf[msgs->len-1] = imx_i2c_read_reg(i2c_imx, IMX_I2C_I2DR);\n\n\treturn 0;\n}\n\nstatic int i2c_imx_write(struct imx_i2c_struct *i2c_imx, struct i2c_msg *msgs,\n\t\t\t bool atomic)\n{\n\tint i, result;\n\n\tdev_dbg(&i2c_imx->adapter.dev, \"<%s> write slave address: addr=0x%x\\n\",\n\t\t__func__, i2c_8bit_addr_from_msg(msgs));\n\n\t \n\timx_i2c_write_reg(i2c_8bit_addr_from_msg(msgs), i2c_imx, IMX_I2C_I2DR);\n\tresult = i2c_imx_trx_complete(i2c_imx, atomic);\n\tif (result)\n\t\treturn result;\n\tresult = i2c_imx_acked(i2c_imx);\n\tif (result)\n\t\treturn result;\n\tdev_dbg(&i2c_imx->adapter.dev, \"<%s> write data\\n\", __func__);\n\n\t \n\tfor (i = 0; i < msgs->len; i++) {\n\t\tdev_dbg(&i2c_imx->adapter.dev,\n\t\t\t\"<%s> write byte: B%d=0x%X\\n\",\n\t\t\t__func__, i, msgs->buf[i]);\n\t\timx_i2c_write_reg(msgs->buf[i], i2c_imx, IMX_I2C_I2DR);\n\t\tresult = i2c_imx_trx_complete(i2c_imx, atomic);\n\t\tif (result)\n\t\t\treturn result;\n\t\tresult = i2c_imx_acked(i2c_imx);\n\t\tif (result)\n\t\t\treturn result;\n\t}\n\treturn 0;\n}\n\nstatic int i2c_imx_read(struct imx_i2c_struct *i2c_imx, struct i2c_msg *msgs,\n\t\t\tbool is_lastmsg, bool atomic)\n{\n\tint i, result;\n\tunsigned int temp;\n\tint block_data = msgs->flags & I2C_M_RECV_LEN;\n\tint use_dma = i2c_imx->dma && msgs->flags & I2C_M_DMA_SAFE &&\n\t\tmsgs->len >= DMA_THRESHOLD && !block_data;\n\n\tdev_dbg(&i2c_imx->adapter.dev,\n\t\t\"<%s> write slave address: addr=0x%x\\n\",\n\t\t__func__, i2c_8bit_addr_from_msg(msgs));\n\n\t \n\timx_i2c_write_reg(i2c_8bit_addr_from_msg(msgs), i2c_imx, IMX_I2C_I2DR);\n\tresult = i2c_imx_trx_complete(i2c_imx, atomic);\n\tif (result)\n\t\treturn result;\n\tresult = i2c_imx_acked(i2c_imx);\n\tif (result)\n\t\treturn result;\n\n\tdev_dbg(&i2c_imx->adapter.dev, \"<%s> setup bus\\n\", __func__);\n\n\t \n\ttemp = imx_i2c_read_reg(i2c_imx, IMX_I2C_I2CR);\n\ttemp &= ~I2CR_MTX;\n\n\t \n\tif ((msgs->len - 1) || block_data)\n\t\ttemp &= ~I2CR_TXAK;\n\tif (use_dma)\n\t\ttemp |= I2CR_DMAEN;\n\timx_i2c_write_reg(temp, i2c_imx, IMX_I2C_I2CR);\n\timx_i2c_read_reg(i2c_imx, IMX_I2C_I2DR);  \n\n\tdev_dbg(&i2c_imx->adapter.dev, \"<%s> read data\\n\", __func__);\n\n\tif (use_dma)\n\t\treturn i2c_imx_dma_read(i2c_imx, msgs, is_lastmsg);\n\n\t \n\tfor (i = 0; i < msgs->len; i++) {\n\t\tu8 len = 0;\n\n\t\tresult = i2c_imx_trx_complete(i2c_imx, atomic);\n\t\tif (result)\n\t\t\treturn result;\n\t\t \n\t\tif ((!i) && block_data) {\n\t\t\tlen = imx_i2c_read_reg(i2c_imx, IMX_I2C_I2DR);\n\t\t\tif ((len == 0) || (len > I2C_SMBUS_BLOCK_MAX))\n\t\t\t\treturn -EPROTO;\n\t\t\tdev_dbg(&i2c_imx->adapter.dev,\n\t\t\t\t\"<%s> read length: 0x%X\\n\",\n\t\t\t\t__func__, len);\n\t\t\tmsgs->len += len;\n\t\t}\n\t\tif (i == (msgs->len - 1)) {\n\t\t\tif (is_lastmsg) {\n\t\t\t\t \n\t\t\t\tdev_dbg(&i2c_imx->adapter.dev,\n\t\t\t\t\t\"<%s> clear MSTA\\n\", __func__);\n\t\t\t\ttemp = imx_i2c_read_reg(i2c_imx, IMX_I2C_I2CR);\n\t\t\t\tif (!(temp & I2CR_MSTA))\n\t\t\t\t\ti2c_imx->stopped =  1;\n\t\t\t\ttemp &= ~(I2CR_MSTA | I2CR_MTX);\n\t\t\t\timx_i2c_write_reg(temp, i2c_imx, IMX_I2C_I2CR);\n\t\t\t\tif (!i2c_imx->stopped)\n\t\t\t\t\ti2c_imx_bus_busy(i2c_imx, 0, atomic);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\ttemp = imx_i2c_read_reg(i2c_imx, IMX_I2C_I2CR);\n\t\t\t\ttemp |= I2CR_MTX;\n\t\t\t\timx_i2c_write_reg(temp, i2c_imx, IMX_I2C_I2CR);\n\t\t\t}\n\t\t} else if (i == (msgs->len - 2)) {\n\t\t\tdev_dbg(&i2c_imx->adapter.dev,\n\t\t\t\t\"<%s> set TXAK\\n\", __func__);\n\t\t\ttemp = imx_i2c_read_reg(i2c_imx, IMX_I2C_I2CR);\n\t\t\ttemp |= I2CR_TXAK;\n\t\t\timx_i2c_write_reg(temp, i2c_imx, IMX_I2C_I2CR);\n\t\t}\n\t\tif ((!i) && block_data)\n\t\t\tmsgs->buf[0] = len;\n\t\telse\n\t\t\tmsgs->buf[i] = imx_i2c_read_reg(i2c_imx, IMX_I2C_I2DR);\n\t\tdev_dbg(&i2c_imx->adapter.dev,\n\t\t\t\"<%s> read byte: B%d=0x%X\\n\",\n\t\t\t__func__, i, msgs->buf[i]);\n\t}\n\treturn 0;\n}\n\nstatic int i2c_imx_xfer_common(struct i2c_adapter *adapter,\n\t\t\t       struct i2c_msg *msgs, int num, bool atomic)\n{\n\tunsigned int i, temp;\n\tint result;\n\tbool is_lastmsg = false;\n\tstruct imx_i2c_struct *i2c_imx = i2c_get_adapdata(adapter);\n\n\t \n\tresult = i2c_imx_start(i2c_imx, atomic);\n\tif (result) {\n\t\t \n\t\tif (!atomic && i2c_imx->adapter.bus_recovery_info) {\n\t\t\ti2c_recover_bus(&i2c_imx->adapter);\n\t\t\tresult = i2c_imx_start(i2c_imx, atomic);\n\t\t}\n\t}\n\n\tif (result)\n\t\tgoto fail0;\n\n\t \n\tfor (i = 0; i < num; i++) {\n\t\tif (i == num - 1)\n\t\t\tis_lastmsg = true;\n\n\t\tif (i) {\n\t\t\tdev_dbg(&i2c_imx->adapter.dev,\n\t\t\t\t\"<%s> repeated start\\n\", __func__);\n\t\t\ttemp = imx_i2c_read_reg(i2c_imx, IMX_I2C_I2CR);\n\t\t\ttemp |= I2CR_RSTA;\n\t\t\timx_i2c_write_reg(temp, i2c_imx, IMX_I2C_I2CR);\n\t\t\tresult = i2c_imx_bus_busy(i2c_imx, 1, atomic);\n\t\t\tif (result)\n\t\t\t\tgoto fail0;\n\t\t}\n\t\tdev_dbg(&i2c_imx->adapter.dev,\n\t\t\t\"<%s> transfer message: %d\\n\", __func__, i);\n\t\t \n#ifdef CONFIG_I2C_DEBUG_BUS\n\t\ttemp = imx_i2c_read_reg(i2c_imx, IMX_I2C_I2CR);\n\t\tdev_dbg(&i2c_imx->adapter.dev,\n\t\t\t\"<%s> CONTROL: IEN=%d, IIEN=%d, MSTA=%d, MTX=%d, TXAK=%d, RSTA=%d\\n\",\n\t\t\t__func__,\n\t\t\t(temp & I2CR_IEN ? 1 : 0), (temp & I2CR_IIEN ? 1 : 0),\n\t\t\t(temp & I2CR_MSTA ? 1 : 0), (temp & I2CR_MTX ? 1 : 0),\n\t\t\t(temp & I2CR_TXAK ? 1 : 0), (temp & I2CR_RSTA ? 1 : 0));\n\t\ttemp = imx_i2c_read_reg(i2c_imx, IMX_I2C_I2SR);\n\t\tdev_dbg(&i2c_imx->adapter.dev,\n\t\t\t\"<%s> STATUS: ICF=%d, IAAS=%d, IBB=%d, IAL=%d, SRW=%d, IIF=%d, RXAK=%d\\n\",\n\t\t\t__func__,\n\t\t\t(temp & I2SR_ICF ? 1 : 0), (temp & I2SR_IAAS ? 1 : 0),\n\t\t\t(temp & I2SR_IBB ? 1 : 0), (temp & I2SR_IAL ? 1 : 0),\n\t\t\t(temp & I2SR_SRW ? 1 : 0), (temp & I2SR_IIF ? 1 : 0),\n\t\t\t(temp & I2SR_RXAK ? 1 : 0));\n#endif\n\t\tif (msgs[i].flags & I2C_M_RD) {\n\t\t\tresult = i2c_imx_read(i2c_imx, &msgs[i], is_lastmsg, atomic);\n\t\t} else {\n\t\t\tif (!atomic &&\n\t\t\t    i2c_imx->dma && msgs[i].len >= DMA_THRESHOLD &&\n\t\t\t\tmsgs[i].flags & I2C_M_DMA_SAFE)\n\t\t\t\tresult = i2c_imx_dma_write(i2c_imx, &msgs[i]);\n\t\t\telse\n\t\t\t\tresult = i2c_imx_write(i2c_imx, &msgs[i], atomic);\n\t\t}\n\t\tif (result)\n\t\t\tgoto fail0;\n\t}\n\nfail0:\n\t \n\ti2c_imx_stop(i2c_imx, atomic);\n\n\tdev_dbg(&i2c_imx->adapter.dev, \"<%s> exit with: %s: %d\\n\", __func__,\n\t\t(result < 0) ? \"error\" : \"success msg\",\n\t\t\t(result < 0) ? result : num);\n\t \n\tif (i2c_imx->slave)\n\t\ti2c_imx_slave_init(i2c_imx);\n\n\treturn (result < 0) ? result : num;\n}\n\nstatic int i2c_imx_xfer(struct i2c_adapter *adapter,\n\t\t\tstruct i2c_msg *msgs, int num)\n{\n\tstruct imx_i2c_struct *i2c_imx = i2c_get_adapdata(adapter);\n\tint result;\n\n\tresult = pm_runtime_resume_and_get(i2c_imx->adapter.dev.parent);\n\tif (result < 0)\n\t\treturn result;\n\n\tresult = i2c_imx_xfer_common(adapter, msgs, num, false);\n\n\tpm_runtime_mark_last_busy(i2c_imx->adapter.dev.parent);\n\tpm_runtime_put_autosuspend(i2c_imx->adapter.dev.parent);\n\n\treturn result;\n}\n\nstatic int i2c_imx_xfer_atomic(struct i2c_adapter *adapter,\n\t\t\t       struct i2c_msg *msgs, int num)\n{\n\tstruct imx_i2c_struct *i2c_imx = i2c_get_adapdata(adapter);\n\tint result;\n\n\tresult = clk_enable(i2c_imx->clk);\n\tif (result)\n\t\treturn result;\n\n\tresult = i2c_imx_xfer_common(adapter, msgs, num, true);\n\n\tclk_disable(i2c_imx->clk);\n\n\treturn result;\n}\n\nstatic void i2c_imx_prepare_recovery(struct i2c_adapter *adap)\n{\n\tstruct imx_i2c_struct *i2c_imx;\n\n\ti2c_imx = container_of(adap, struct imx_i2c_struct, adapter);\n\n\tpinctrl_select_state(i2c_imx->pinctrl, i2c_imx->pinctrl_pins_gpio);\n}\n\nstatic void i2c_imx_unprepare_recovery(struct i2c_adapter *adap)\n{\n\tstruct imx_i2c_struct *i2c_imx;\n\n\ti2c_imx = container_of(adap, struct imx_i2c_struct, adapter);\n\n\tpinctrl_select_state(i2c_imx->pinctrl, i2c_imx->pinctrl_pins_default);\n}\n\n \nstatic int i2c_imx_init_recovery_info(struct imx_i2c_struct *i2c_imx,\n\t\tstruct platform_device *pdev)\n{\n\tstruct i2c_bus_recovery_info *rinfo = &i2c_imx->rinfo;\n\n\ti2c_imx->pinctrl = devm_pinctrl_get(&pdev->dev);\n\tif (!i2c_imx->pinctrl) {\n\t\tdev_info(&pdev->dev, \"pinctrl unavailable, bus recovery not supported\\n\");\n\t\treturn 0;\n\t}\n\tif (IS_ERR(i2c_imx->pinctrl)) {\n\t\tdev_info(&pdev->dev, \"can't get pinctrl, bus recovery not supported\\n\");\n\t\treturn PTR_ERR(i2c_imx->pinctrl);\n\t}\n\n\ti2c_imx->pinctrl_pins_default = pinctrl_lookup_state(i2c_imx->pinctrl,\n\t\t\tPINCTRL_STATE_DEFAULT);\n\ti2c_imx->pinctrl_pins_gpio = pinctrl_lookup_state(i2c_imx->pinctrl,\n\t\t\t\"gpio\");\n\trinfo->sda_gpiod = devm_gpiod_get(&pdev->dev, \"sda\", GPIOD_IN);\n\trinfo->scl_gpiod = devm_gpiod_get(&pdev->dev, \"scl\", GPIOD_OUT_HIGH_OPEN_DRAIN);\n\n\tif (PTR_ERR(rinfo->sda_gpiod) == -EPROBE_DEFER ||\n\t    PTR_ERR(rinfo->scl_gpiod) == -EPROBE_DEFER) {\n\t\treturn -EPROBE_DEFER;\n\t} else if (IS_ERR(rinfo->sda_gpiod) ||\n\t\t   IS_ERR(rinfo->scl_gpiod) ||\n\t\t   IS_ERR(i2c_imx->pinctrl_pins_default) ||\n\t\t   IS_ERR(i2c_imx->pinctrl_pins_gpio)) {\n\t\tdev_dbg(&pdev->dev, \"recovery information incomplete\\n\");\n\t\treturn 0;\n\t}\n\n\tdev_dbg(&pdev->dev, \"using scl%s for recovery\\n\",\n\t\trinfo->sda_gpiod ? \",sda\" : \"\");\n\n\trinfo->prepare_recovery = i2c_imx_prepare_recovery;\n\trinfo->unprepare_recovery = i2c_imx_unprepare_recovery;\n\trinfo->recover_bus = i2c_generic_scl_recovery;\n\ti2c_imx->adapter.bus_recovery_info = rinfo;\n\n\treturn 0;\n}\n\nstatic u32 i2c_imx_func(struct i2c_adapter *adapter)\n{\n\treturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL\n\t\t| I2C_FUNC_SMBUS_READ_BLOCK_DATA;\n}\n\nstatic const struct i2c_algorithm i2c_imx_algo = {\n\t.master_xfer = i2c_imx_xfer,\n\t.master_xfer_atomic = i2c_imx_xfer_atomic,\n\t.functionality = i2c_imx_func,\n\t.reg_slave\t= i2c_imx_reg_slave,\n\t.unreg_slave\t= i2c_imx_unreg_slave,\n};\n\nstatic int i2c_imx_probe(struct platform_device *pdev)\n{\n\tstruct imx_i2c_struct *i2c_imx;\n\tstruct resource *res;\n\tstruct imxi2c_platform_data *pdata = dev_get_platdata(&pdev->dev);\n\tvoid __iomem *base;\n\tint irq, ret;\n\tdma_addr_t phy_addr;\n\tconst struct imx_i2c_hwdata *match;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tbase = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\tphy_addr = (dma_addr_t)res->start;\n\ti2c_imx = devm_kzalloc(&pdev->dev, sizeof(*i2c_imx), GFP_KERNEL);\n\tif (!i2c_imx)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&i2c_imx->slave_lock);\n\thrtimer_init(&i2c_imx->slave_timer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS);\n\ti2c_imx->slave_timer.function = i2c_imx_slave_timeout;\n\n\tmatch = device_get_match_data(&pdev->dev);\n\tif (match)\n\t\ti2c_imx->hwdata = match;\n\telse\n\t\ti2c_imx->hwdata = (struct imx_i2c_hwdata *)\n\t\t\t\tplatform_get_device_id(pdev)->driver_data;\n\n\t \n\tstrscpy(i2c_imx->adapter.name, pdev->name, sizeof(i2c_imx->adapter.name));\n\ti2c_imx->adapter.owner\t\t= THIS_MODULE;\n\ti2c_imx->adapter.algo\t\t= &i2c_imx_algo;\n\ti2c_imx->adapter.dev.parent\t= &pdev->dev;\n\ti2c_imx->adapter.nr\t\t= pdev->id;\n\ti2c_imx->adapter.dev.of_node\t= pdev->dev.of_node;\n\ti2c_imx->base\t\t\t= base;\n\tACPI_COMPANION_SET(&i2c_imx->adapter.dev, ACPI_COMPANION(&pdev->dev));\n\n\t \n\ti2c_imx->clk = devm_clk_get_enabled(&pdev->dev, NULL);\n\tif (IS_ERR(i2c_imx->clk))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(i2c_imx->clk),\n\t\t\t\t     \"can't get I2C clock\\n\");\n\n\t \n\tinit_waitqueue_head(&i2c_imx->queue);\n\n\t \n\ti2c_set_adapdata(&i2c_imx->adapter, i2c_imx);\n\n\t \n\tplatform_set_drvdata(pdev, i2c_imx);\n\n\tpm_runtime_set_autosuspend_delay(&pdev->dev, I2C_PM_TIMEOUT);\n\tpm_runtime_use_autosuspend(&pdev->dev);\n\tpm_runtime_set_active(&pdev->dev);\n\tpm_runtime_enable(&pdev->dev);\n\n\tret = pm_runtime_get_sync(&pdev->dev);\n\tif (ret < 0)\n\t\tgoto rpm_disable;\n\n\t \n\tret = request_irq(irq, i2c_imx_isr, IRQF_SHARED, pdev->name, i2c_imx);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"can't claim irq %d\\n\", irq);\n\t\tgoto rpm_disable;\n\t}\n\n\t \n\ti2c_imx->bitrate = I2C_MAX_STANDARD_MODE_FREQ;\n\tret = of_property_read_u32(pdev->dev.of_node,\n\t\t\t\t   \"clock-frequency\", &i2c_imx->bitrate);\n\tif (ret < 0 && pdata && pdata->bitrate)\n\t\ti2c_imx->bitrate = pdata->bitrate;\n\ti2c_imx->clk_change_nb.notifier_call = i2c_imx_clk_notifier_call;\n\tclk_notifier_register(i2c_imx->clk, &i2c_imx->clk_change_nb);\n\ti2c_imx_set_clk(i2c_imx, clk_get_rate(i2c_imx->clk));\n\n\ti2c_imx_reset_regs(i2c_imx);\n\n\t \n\tret = i2c_imx_init_recovery_info(i2c_imx, pdev);\n\t \n\tif (ret == -EPROBE_DEFER)\n\t\tgoto clk_notifier_unregister;\n\n\t \n\tret = i2c_add_numbered_adapter(&i2c_imx->adapter);\n\tif (ret < 0)\n\t\tgoto clk_notifier_unregister;\n\n\tpm_runtime_mark_last_busy(&pdev->dev);\n\tpm_runtime_put_autosuspend(&pdev->dev);\n\n\tdev_dbg(&i2c_imx->adapter.dev, \"claimed irq %d\\n\", irq);\n\tdev_dbg(&i2c_imx->adapter.dev, \"device resources: %pR\\n\", res);\n\tdev_dbg(&i2c_imx->adapter.dev, \"adapter name: \\\"%s\\\"\\n\",\n\t\ti2c_imx->adapter.name);\n\tdev_info(&i2c_imx->adapter.dev, \"IMX I2C adapter registered\\n\");\n\n\t \n\ti2c_imx_dma_request(i2c_imx, phy_addr);\n\n\treturn 0;    \n\nclk_notifier_unregister:\n\tclk_notifier_unregister(i2c_imx->clk, &i2c_imx->clk_change_nb);\n\tfree_irq(irq, i2c_imx);\nrpm_disable:\n\tpm_runtime_put_noidle(&pdev->dev);\n\tpm_runtime_disable(&pdev->dev);\n\tpm_runtime_set_suspended(&pdev->dev);\n\tpm_runtime_dont_use_autosuspend(&pdev->dev);\n\treturn ret;\n}\n\nstatic void i2c_imx_remove(struct platform_device *pdev)\n{\n\tstruct imx_i2c_struct *i2c_imx = platform_get_drvdata(pdev);\n\tint irq, ret;\n\n\tret = pm_runtime_get_sync(&pdev->dev);\n\n\thrtimer_cancel(&i2c_imx->slave_timer);\n\n\t \n\tdev_dbg(&i2c_imx->adapter.dev, \"adapter removed\\n\");\n\ti2c_del_adapter(&i2c_imx->adapter);\n\n\tif (i2c_imx->dma)\n\t\ti2c_imx_dma_free(i2c_imx);\n\n\tif (ret >= 0) {\n\t\t \n\t\timx_i2c_write_reg(0, i2c_imx, IMX_I2C_IADR);\n\t\timx_i2c_write_reg(0, i2c_imx, IMX_I2C_IFDR);\n\t\timx_i2c_write_reg(0, i2c_imx, IMX_I2C_I2CR);\n\t\timx_i2c_write_reg(0, i2c_imx, IMX_I2C_I2SR);\n\t}\n\n\tclk_notifier_unregister(i2c_imx->clk, &i2c_imx->clk_change_nb);\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq >= 0)\n\t\tfree_irq(irq, i2c_imx);\n\n\tpm_runtime_put_noidle(&pdev->dev);\n\tpm_runtime_disable(&pdev->dev);\n}\n\nstatic int __maybe_unused i2c_imx_runtime_suspend(struct device *dev)\n{\n\tstruct imx_i2c_struct *i2c_imx = dev_get_drvdata(dev);\n\n\tclk_disable(i2c_imx->clk);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused i2c_imx_runtime_resume(struct device *dev)\n{\n\tstruct imx_i2c_struct *i2c_imx = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = clk_enable(i2c_imx->clk);\n\tif (ret)\n\t\tdev_err(dev, \"can't enable I2C clock, ret=%d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic const struct dev_pm_ops i2c_imx_pm_ops = {\n\tSET_RUNTIME_PM_OPS(i2c_imx_runtime_suspend,\n\t\t\t   i2c_imx_runtime_resume, NULL)\n};\n\nstatic struct platform_driver i2c_imx_driver = {\n\t.probe = i2c_imx_probe,\n\t.remove_new = i2c_imx_remove,\n\t.driver = {\n\t\t.name = DRIVER_NAME,\n\t\t.pm = &i2c_imx_pm_ops,\n\t\t.of_match_table = i2c_imx_dt_ids,\n\t\t.acpi_match_table = i2c_imx_acpi_ids,\n\t},\n\t.id_table = imx_i2c_devtype,\n};\n\nstatic int __init i2c_adap_imx_init(void)\n{\n\treturn platform_driver_register(&i2c_imx_driver);\n}\nsubsys_initcall(i2c_adap_imx_init);\n\nstatic void __exit i2c_adap_imx_exit(void)\n{\n\tplatform_driver_unregister(&i2c_imx_driver);\n}\nmodule_exit(i2c_adap_imx_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Darius Augulis\");\nMODULE_DESCRIPTION(\"I2C adapter driver for IMX I2C bus\");\nMODULE_ALIAS(\"platform:\" DRIVER_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}