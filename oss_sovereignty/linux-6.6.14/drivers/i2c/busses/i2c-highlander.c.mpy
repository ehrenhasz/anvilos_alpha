{
  "module_name": "i2c-highlander.c",
  "hash_id": "53d7cf52e504e74672c891a01ef8b4fabbd53e8bba1a4257ac86b954ec257904",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-highlander.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/i2c.h>\n#include <linux/platform_device.h>\n#include <linux/completion.h>\n#include <linux/io.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n\n#define SMCR\t\t0x00\n#define SMCR_START\t(1 << 0)\n#define SMCR_IRIC\t(1 << 1)\n#define SMCR_BBSY\t(1 << 2)\n#define SMCR_ACKE\t(1 << 3)\n#define SMCR_RST\t(1 << 4)\n#define SMCR_IEIC\t(1 << 6)\n\n#define SMSMADR\t\t0x02\n\n#define SMMR\t\t0x04\n#define SMMR_MODE0\t(1 << 0)\n#define SMMR_MODE1\t(1 << 1)\n#define SMMR_CAP\t(1 << 3)\n#define SMMR_TMMD\t(1 << 4)\n#define SMMR_SP\t\t(1 << 7)\n\n#define SMSADR\t\t0x06\n#define SMTRDR\t\t0x46\n\nstruct highlander_i2c_dev {\n\tstruct device\t\t*dev;\n\tvoid __iomem\t\t*base;\n\tstruct i2c_adapter\tadapter;\n\tstruct completion\tcmd_complete;\n\tunsigned long\t\tlast_read_time;\n\tint\t\t\tirq;\n\tu8\t\t\t*buf;\n\tsize_t\t\t\tbuf_len;\n};\n\nstatic bool iic_force_poll, iic_force_normal;\nstatic int iic_timeout = 1000, iic_read_delay;\n\nstatic inline void highlander_i2c_irq_enable(struct highlander_i2c_dev *dev)\n{\n\tiowrite16(ioread16(dev->base + SMCR) | SMCR_IEIC, dev->base + SMCR);\n}\n\nstatic inline void highlander_i2c_irq_disable(struct highlander_i2c_dev *dev)\n{\n\tiowrite16(ioread16(dev->base + SMCR) & ~SMCR_IEIC, dev->base + SMCR);\n}\n\nstatic inline void highlander_i2c_start(struct highlander_i2c_dev *dev)\n{\n\tiowrite16(ioread16(dev->base + SMCR) | SMCR_START, dev->base + SMCR);\n}\n\nstatic inline void highlander_i2c_done(struct highlander_i2c_dev *dev)\n{\n\tiowrite16(ioread16(dev->base + SMCR) | SMCR_IRIC, dev->base + SMCR);\n}\n\nstatic void highlander_i2c_setup(struct highlander_i2c_dev *dev)\n{\n\tu16 smmr;\n\n\tsmmr = ioread16(dev->base + SMMR);\n\tsmmr |= SMMR_TMMD;\n\n\tif (iic_force_normal)\n\t\tsmmr &= ~SMMR_SP;\n\telse\n\t\tsmmr |= SMMR_SP;\n\n\tiowrite16(smmr, dev->base + SMMR);\n}\n\nstatic void smbus_write_data(u8 *src, u16 *dst, int len)\n{\n\tfor (; len > 1; len -= 2) {\n\t\t*dst++ = be16_to_cpup((__be16 *)src);\n\t\tsrc += 2;\n\t}\n\n\tif (len)\n\t\t*dst = *src << 8;\n}\n\nstatic void smbus_read_data(u16 *src, u8 *dst, int len)\n{\n\tfor (; len > 1; len -= 2) {\n\t\t*(__be16 *)dst = cpu_to_be16p(src++);\n\t\tdst += 2;\n\t}\n\n\tif (len)\n\t\t*dst = *src >> 8;\n}\n\nstatic void highlander_i2c_command(struct highlander_i2c_dev *dev,\n\t\t\t\t   u8 command, int len)\n{\n\tunsigned int i;\n\tu16 cmd = (command << 8) | command;\n\n\tfor (i = 0; i < len; i += 2) {\n\t\tif (len - i == 1)\n\t\t\tcmd = command << 8;\n\t\tiowrite16(cmd, dev->base + SMSADR + i);\n\t\tdev_dbg(dev->dev, \"command data[%x] 0x%04x\\n\", i/2, cmd);\n\t}\n}\n\nstatic int highlander_i2c_wait_for_bbsy(struct highlander_i2c_dev *dev)\n{\n\tunsigned long timeout;\n\n\ttimeout = jiffies + msecs_to_jiffies(iic_timeout);\n\twhile (ioread16(dev->base + SMCR) & SMCR_BBSY) {\n\t\tif (time_after(jiffies, timeout)) {\n\t\t\tdev_warn(dev->dev, \"timeout waiting for bus ready\\n\");\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\n\t\tmsleep(1);\n\t}\n\n\treturn 0;\n}\n\nstatic int highlander_i2c_reset(struct highlander_i2c_dev *dev)\n{\n\tiowrite16(ioread16(dev->base + SMCR) | SMCR_RST, dev->base + SMCR);\n\treturn highlander_i2c_wait_for_bbsy(dev);\n}\n\nstatic int highlander_i2c_wait_for_ack(struct highlander_i2c_dev *dev)\n{\n\tu16 tmp = ioread16(dev->base + SMCR);\n\n\tif ((tmp & (SMCR_IRIC | SMCR_ACKE)) == SMCR_ACKE) {\n\t\tdev_warn(dev->dev, \"ack abnormality\\n\");\n\t\treturn highlander_i2c_reset(dev);\n\t}\n\n\treturn 0;\n}\n\nstatic irqreturn_t highlander_i2c_irq(int irq, void *dev_id)\n{\n\tstruct highlander_i2c_dev *dev = dev_id;\n\n\thighlander_i2c_done(dev);\n\tcomplete(&dev->cmd_complete);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void highlander_i2c_poll(struct highlander_i2c_dev *dev)\n{\n\tunsigned long timeout;\n\tu16 smcr;\n\n\ttimeout = jiffies + msecs_to_jiffies(iic_timeout);\n\tfor (;;) {\n\t\tsmcr = ioread16(dev->base + SMCR);\n\n\t\t \n\n\t\tif (smcr & SMCR_IRIC)\n\t\t\treturn;\n\t\tif (time_after(jiffies, timeout))\n\t\t\tbreak;\n\n\t\tcpu_relax();\n\t\tcond_resched();\n\t}\n\n\tdev_err(dev->dev, \"polling timed out\\n\");\n}\n\nstatic inline int highlander_i2c_wait_xfer_done(struct highlander_i2c_dev *dev)\n{\n\tif (dev->irq)\n\t\twait_for_completion_timeout(&dev->cmd_complete,\n\t\t\t\t\t  msecs_to_jiffies(iic_timeout));\n\telse\n\t\t \n\t\thighlander_i2c_poll(dev);\n\n\treturn highlander_i2c_wait_for_ack(dev);\n}\n\nstatic int highlander_i2c_read(struct highlander_i2c_dev *dev)\n{\n\tint i, cnt;\n\tu16 data[16];\n\n\tif (highlander_i2c_wait_for_bbsy(dev))\n\t\treturn -EAGAIN;\n\n\thighlander_i2c_start(dev);\n\n\tif (highlander_i2c_wait_xfer_done(dev)) {\n\t\tdev_err(dev->dev, \"Arbitration loss\\n\");\n\t\treturn -EAGAIN;\n\t}\n\n\t \n\tif (iic_read_delay && time_before(jiffies, dev->last_read_time +\n\t\t\t\t msecs_to_jiffies(iic_read_delay)))\n\t\tmsleep(jiffies_to_msecs((dev->last_read_time +\n\t\t\t\tmsecs_to_jiffies(iic_read_delay)) - jiffies));\n\n\tcnt = (dev->buf_len + 1) >> 1;\n\tfor (i = 0; i < cnt; i++) {\n\t\tdata[i] = ioread16(dev->base + SMTRDR + (i * sizeof(u16)));\n\t\tdev_dbg(dev->dev, \"read data[%x] 0x%04x\\n\", i, data[i]);\n\t}\n\n\tsmbus_read_data(data, dev->buf, dev->buf_len);\n\n\tdev->last_read_time = jiffies;\n\n\treturn 0;\n}\n\nstatic int highlander_i2c_write(struct highlander_i2c_dev *dev)\n{\n\tint i, cnt;\n\tu16 data[16];\n\n\tsmbus_write_data(dev->buf, data, dev->buf_len);\n\n\tcnt = (dev->buf_len + 1) >> 1;\n\tfor (i = 0; i < cnt; i++) {\n\t\tiowrite16(data[i], dev->base + SMTRDR + (i * sizeof(u16)));\n\t\tdev_dbg(dev->dev, \"write data[%x] 0x%04x\\n\", i, data[i]);\n\t}\n\n\tif (highlander_i2c_wait_for_bbsy(dev))\n\t\treturn -EAGAIN;\n\n\thighlander_i2c_start(dev);\n\n\treturn highlander_i2c_wait_xfer_done(dev);\n}\n\nstatic int highlander_i2c_smbus_xfer(struct i2c_adapter *adap, u16 addr,\n\t\t\t\t  unsigned short flags, char read_write,\n\t\t\t\t  u8 command, int size,\n\t\t\t\t  union i2c_smbus_data *data)\n{\n\tstruct highlander_i2c_dev *dev = i2c_get_adapdata(adap);\n\tu16 tmp;\n\n\tinit_completion(&dev->cmd_complete);\n\n\tdev_dbg(dev->dev, \"addr %04x, command %02x, read_write %d, size %d\\n\",\n\t\taddr, command, read_write, size);\n\n\t \n\tswitch (size) {\n\tcase I2C_SMBUS_BYTE_DATA:\n\t\tdev->buf = &data->byte;\n\t\tdev->buf_len = 1;\n\t\tbreak;\n\tcase I2C_SMBUS_I2C_BLOCK_DATA:\n\t\tdev->buf = &data->block[1];\n\t\tdev->buf_len = data->block[0];\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev->dev, \"unsupported command %d\\n\", size);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\ttmp = ioread16(dev->base + SMMR);\n\ttmp &= ~(SMMR_MODE0 | SMMR_MODE1);\n\n\tswitch (dev->buf_len) {\n\tcase 1:\n\t\t \n\t\tbreak;\n\tcase 8:\n\t\ttmp |= SMMR_MODE0;\n\t\tbreak;\n\tcase 16:\n\t\ttmp |= SMMR_MODE1;\n\t\tbreak;\n\tcase 32:\n\t\ttmp |= (SMMR_MODE0 | SMMR_MODE1);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev->dev, \"unsupported xfer size %zu\\n\", dev->buf_len);\n\t\treturn -EINVAL;\n\t}\n\n\tiowrite16(tmp, dev->base + SMMR);\n\n\t \n\thighlander_i2c_done(dev);\n\n\t \n\tiowrite16((addr << 1) | read_write, dev->base + SMSMADR);\n\n\thighlander_i2c_command(dev, command, dev->buf_len);\n\n\tif (read_write == I2C_SMBUS_READ)\n\t\treturn highlander_i2c_read(dev);\n\telse\n\t\treturn highlander_i2c_write(dev);\n}\n\nstatic u32 highlander_i2c_func(struct i2c_adapter *adapter)\n{\n\treturn I2C_FUNC_SMBUS_BYTE_DATA | I2C_FUNC_SMBUS_I2C_BLOCK;\n}\n\nstatic const struct i2c_algorithm highlander_i2c_algo = {\n\t.smbus_xfer\t= highlander_i2c_smbus_xfer,\n\t.functionality\t= highlander_i2c_func,\n};\n\nstatic int highlander_i2c_probe(struct platform_device *pdev)\n{\n\tstruct highlander_i2c_dev *dev;\n\tstruct i2c_adapter *adap;\n\tstruct resource *res;\n\tint ret;\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (unlikely(!res)) {\n\t\tdev_err(&pdev->dev, \"no mem resource\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tdev = kzalloc(sizeof(struct highlander_i2c_dev), GFP_KERNEL);\n\tif (unlikely(!dev))\n\t\treturn -ENOMEM;\n\n\tdev->base = ioremap(res->start, resource_size(res));\n\tif (unlikely(!dev->base)) {\n\t\tret = -ENXIO;\n\t\tgoto err;\n\t}\n\n\tdev->dev = &pdev->dev;\n\tplatform_set_drvdata(pdev, dev);\n\n\tdev->irq = platform_get_irq(pdev, 0);\n\tif (dev->irq < 0 || iic_force_poll)\n\t\tdev->irq = 0;\n\n\tif (dev->irq) {\n\t\tret = request_irq(dev->irq, highlander_i2c_irq, 0,\n\t\t\t\t  pdev->name, dev);\n\t\tif (unlikely(ret))\n\t\t\tgoto err_unmap;\n\n\t\thighlander_i2c_irq_enable(dev);\n\t} else {\n\t\tdev_notice(&pdev->dev, \"no IRQ, using polling mode\\n\");\n\t\thighlander_i2c_irq_disable(dev);\n\t}\n\n\tdev->last_read_time = jiffies;\t \n\n\thighlander_i2c_setup(dev);\n\n\tadap = &dev->adapter;\n\ti2c_set_adapdata(adap, dev);\n\tadap->owner = THIS_MODULE;\n\tadap->class = I2C_CLASS_HWMON;\n\tstrscpy(adap->name, \"HL FPGA I2C adapter\", sizeof(adap->name));\n\tadap->algo = &highlander_i2c_algo;\n\tadap->dev.parent = &pdev->dev;\n\tadap->nr = pdev->id;\n\n\t \n\tret = highlander_i2c_reset(dev);\n\tif (unlikely(ret)) {\n\t\tdev_err(&pdev->dev, \"controller didn't come up\\n\");\n\t\tgoto err_free_irq;\n\t}\n\n\tret = i2c_add_numbered_adapter(adap);\n\tif (unlikely(ret)) {\n\t\tdev_err(&pdev->dev, \"failure adding adapter\\n\");\n\t\tgoto err_free_irq;\n\t}\n\n\treturn 0;\n\nerr_free_irq:\n\tif (dev->irq)\n\t\tfree_irq(dev->irq, dev);\nerr_unmap:\n\tiounmap(dev->base);\nerr:\n\tkfree(dev);\n\n\treturn ret;\n}\n\nstatic void highlander_i2c_remove(struct platform_device *pdev)\n{\n\tstruct highlander_i2c_dev *dev = platform_get_drvdata(pdev);\n\n\ti2c_del_adapter(&dev->adapter);\n\n\tif (dev->irq)\n\t\tfree_irq(dev->irq, dev);\n\n\tiounmap(dev->base);\n\tkfree(dev);\n}\n\nstatic struct platform_driver highlander_i2c_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"i2c-highlander\",\n\t},\n\n\t.probe\t\t= highlander_i2c_probe,\n\t.remove_new\t= highlander_i2c_remove,\n};\n\nmodule_platform_driver(highlander_i2c_driver);\n\nMODULE_AUTHOR(\"Paul Mundt\");\nMODULE_DESCRIPTION(\"Renesas Highlander FPGA I2C/SMBus adapter\");\nMODULE_LICENSE(\"GPL v2\");\n\nmodule_param(iic_force_poll, bool, 0);\nmodule_param(iic_force_normal, bool, 0);\nmodule_param(iic_timeout, int, 0);\nmodule_param(iic_read_delay, int, 0);\n\nMODULE_PARM_DESC(iic_force_poll, \"Force polling mode\");\nMODULE_PARM_DESC(iic_force_normal,\n\t\t \"Force normal mode (100 kHz), default is fast mode (400 kHz)\");\nMODULE_PARM_DESC(iic_timeout, \"Set timeout value in msecs (default 1000 ms)\");\nMODULE_PARM_DESC(iic_read_delay,\n\t\t \"Delay between data read cycles (default 0 ms)\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}