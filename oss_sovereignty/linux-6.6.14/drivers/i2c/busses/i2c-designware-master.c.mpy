{
  "module_name": "i2c-designware-master.c",
  "hash_id": "3300202676a9fba7416311a0a7b66f036b80f0e473cd61ac9e2c76e956a0f4c2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-designware-master.c",
  "human_readable_source": "\n \n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n#include <linux/reset.h>\n\n#include \"i2c-designware-core.h\"\n\n#define AMD_TIMEOUT_MIN_US\t25\n#define AMD_TIMEOUT_MAX_US\t250\n#define AMD_MASTERCFG_MASK\tGENMASK(15, 0)\n\nstatic void i2c_dw_configure_fifo_master(struct dw_i2c_dev *dev)\n{\n\t \n\tregmap_write(dev->map, DW_IC_TX_TL, dev->tx_fifo_depth / 2);\n\tregmap_write(dev->map, DW_IC_RX_TL, 0);\n\n\t \n\tregmap_write(dev->map, DW_IC_CON, dev->master_cfg);\n}\n\nstatic int i2c_dw_set_timings_master(struct dw_i2c_dev *dev)\n{\n\tunsigned int comp_param1;\n\tu32 sda_falling_time, scl_falling_time;\n\tstruct i2c_timings *t = &dev->timings;\n\tconst char *fp_str = \"\";\n\tu32 ic_clk;\n\tint ret;\n\n\tret = i2c_dw_acquire_lock(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_read(dev->map, DW_IC_COMP_PARAM_1, &comp_param1);\n\ti2c_dw_release_lock(dev);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tsda_falling_time = t->sda_fall_ns ?: 300;  \n\tscl_falling_time = t->scl_fall_ns ?: 300;  \n\n\t \n\tif (!dev->ss_hcnt || !dev->ss_lcnt) {\n\t\tic_clk = i2c_dw_clk_rate(dev);\n\t\tdev->ss_hcnt =\n\t\t\ti2c_dw_scl_hcnt(ic_clk,\n\t\t\t\t\t4000,\t \n\t\t\t\t\tsda_falling_time,\n\t\t\t\t\t0,\t \n\t\t\t\t\t0);\t \n\t\tdev->ss_lcnt =\n\t\t\ti2c_dw_scl_lcnt(ic_clk,\n\t\t\t\t\t4700,\t \n\t\t\t\t\tscl_falling_time,\n\t\t\t\t\t0);\t \n\t}\n\tdev_dbg(dev->dev, \"Standard Mode HCNT:LCNT = %d:%d\\n\",\n\t\tdev->ss_hcnt, dev->ss_lcnt);\n\n\t \n\tif (t->bus_freq_hz == I2C_MAX_FAST_MODE_PLUS_FREQ) {\n\t\t \n\t\tif (dev->fp_hcnt && dev->fp_lcnt) {\n\t\t\tdev->fs_hcnt = dev->fp_hcnt;\n\t\t\tdev->fs_lcnt = dev->fp_lcnt;\n\t\t} else {\n\t\t\tic_clk = i2c_dw_clk_rate(dev);\n\t\t\tdev->fs_hcnt =\n\t\t\t\ti2c_dw_scl_hcnt(ic_clk,\n\t\t\t\t\t\t260,\t \n\t\t\t\t\t\tsda_falling_time,\n\t\t\t\t\t\t0,\t \n\t\t\t\t\t\t0);\t \n\t\t\tdev->fs_lcnt =\n\t\t\t\ti2c_dw_scl_lcnt(ic_clk,\n\t\t\t\t\t\t500,\t \n\t\t\t\t\t\tscl_falling_time,\n\t\t\t\t\t\t0);\t \n\t\t}\n\t\tfp_str = \" Plus\";\n\t}\n\t \n\tif (!dev->fs_hcnt || !dev->fs_lcnt) {\n\t\tic_clk = i2c_dw_clk_rate(dev);\n\t\tdev->fs_hcnt =\n\t\t\ti2c_dw_scl_hcnt(ic_clk,\n\t\t\t\t\t600,\t \n\t\t\t\t\tsda_falling_time,\n\t\t\t\t\t0,\t \n\t\t\t\t\t0);\t \n\t\tdev->fs_lcnt =\n\t\t\ti2c_dw_scl_lcnt(ic_clk,\n\t\t\t\t\t1300,\t \n\t\t\t\t\tscl_falling_time,\n\t\t\t\t\t0);\t \n\t}\n\tdev_dbg(dev->dev, \"Fast Mode%s HCNT:LCNT = %d:%d\\n\",\n\t\tfp_str, dev->fs_hcnt, dev->fs_lcnt);\n\n\t \n\tif ((dev->master_cfg & DW_IC_CON_SPEED_MASK) ==\n\t\tDW_IC_CON_SPEED_HIGH) {\n\t\tif ((comp_param1 & DW_IC_COMP_PARAM_1_SPEED_MODE_MASK)\n\t\t\t!= DW_IC_COMP_PARAM_1_SPEED_MODE_HIGH) {\n\t\t\tdev_err(dev->dev, \"High Speed not supported!\\n\");\n\t\t\tt->bus_freq_hz = I2C_MAX_FAST_MODE_FREQ;\n\t\t\tdev->master_cfg &= ~DW_IC_CON_SPEED_MASK;\n\t\t\tdev->master_cfg |= DW_IC_CON_SPEED_FAST;\n\t\t\tdev->hs_hcnt = 0;\n\t\t\tdev->hs_lcnt = 0;\n\t\t} else if (!dev->hs_hcnt || !dev->hs_lcnt) {\n\t\t\tic_clk = i2c_dw_clk_rate(dev);\n\t\t\tdev->hs_hcnt =\n\t\t\t\ti2c_dw_scl_hcnt(ic_clk,\n\t\t\t\t\t\t160,\t \n\t\t\t\t\t\tsda_falling_time,\n\t\t\t\t\t\t0,\t \n\t\t\t\t\t\t0);\t \n\t\t\tdev->hs_lcnt =\n\t\t\t\ti2c_dw_scl_lcnt(ic_clk,\n\t\t\t\t\t\t320,\t \n\t\t\t\t\t\tscl_falling_time,\n\t\t\t\t\t\t0);\t \n\t\t}\n\t\tdev_dbg(dev->dev, \"High Speed Mode HCNT:LCNT = %d:%d\\n\",\n\t\t\tdev->hs_hcnt, dev->hs_lcnt);\n\t}\n\n\tret = i2c_dw_set_sda_hold(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tdev_dbg(dev->dev, \"Bus speed: %s\\n\", i2c_freq_mode_string(t->bus_freq_hz));\n\treturn 0;\n}\n\n \nstatic int i2c_dw_init_master(struct dw_i2c_dev *dev)\n{\n\tint ret;\n\n\tret = i2c_dw_acquire_lock(dev);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\t__i2c_dw_disable(dev);\n\n\t \n\tregmap_write(dev->map, DW_IC_SS_SCL_HCNT, dev->ss_hcnt);\n\tregmap_write(dev->map, DW_IC_SS_SCL_LCNT, dev->ss_lcnt);\n\n\t \n\tregmap_write(dev->map, DW_IC_FS_SCL_HCNT, dev->fs_hcnt);\n\tregmap_write(dev->map, DW_IC_FS_SCL_LCNT, dev->fs_lcnt);\n\n\t \n\tif (dev->hs_hcnt && dev->hs_lcnt) {\n\t\tregmap_write(dev->map, DW_IC_HS_SCL_HCNT, dev->hs_hcnt);\n\t\tregmap_write(dev->map, DW_IC_HS_SCL_LCNT, dev->hs_lcnt);\n\t}\n\n\t \n\tif (dev->sda_hold_time)\n\t\tregmap_write(dev->map, DW_IC_SDA_HOLD, dev->sda_hold_time);\n\n\ti2c_dw_configure_fifo_master(dev);\n\ti2c_dw_release_lock(dev);\n\n\treturn 0;\n}\n\nstatic void i2c_dw_xfer_init(struct dw_i2c_dev *dev)\n{\n\tstruct i2c_msg *msgs = dev->msgs;\n\tu32 ic_con = 0, ic_tar = 0;\n\tunsigned int dummy;\n\n\t \n\t__i2c_dw_disable(dev);\n\n\t \n\tif (msgs[dev->msg_write_idx].flags & I2C_M_TEN) {\n\t\tic_con = DW_IC_CON_10BITADDR_MASTER;\n\t\t \n\t\tic_tar = DW_IC_TAR_10BITADDR_MASTER;\n\t}\n\n\tregmap_update_bits(dev->map, DW_IC_CON, DW_IC_CON_10BITADDR_MASTER,\n\t\t\t   ic_con);\n\n\t \n\tregmap_write(dev->map, DW_IC_TAR,\n\t\t     msgs[dev->msg_write_idx].addr | ic_tar);\n\n\t \n\tregmap_write(dev->map, DW_IC_INTR_MASK, 0);\n\n\t \n\t__i2c_dw_enable(dev);\n\n\t \n\tregmap_read(dev->map, DW_IC_ENABLE_STATUS, &dummy);\n\n\t \n\tregmap_read(dev->map, DW_IC_CLR_INTR, &dummy);\n\tregmap_write(dev->map, DW_IC_INTR_MASK, DW_IC_INTR_MASTER_MASK);\n}\n\nstatic int i2c_dw_check_stopbit(struct dw_i2c_dev *dev)\n{\n\tu32 val;\n\tint ret;\n\n\tret = regmap_read_poll_timeout(dev->map, DW_IC_INTR_STAT, val,\n\t\t\t\t       !(val & DW_IC_INTR_STOP_DET),\n\t\t\t\t\t1100, 20000);\n\tif (ret)\n\t\tdev_err(dev->dev, \"i2c timeout error %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int i2c_dw_status(struct dw_i2c_dev *dev)\n{\n\tint status;\n\n\tstatus = i2c_dw_wait_bus_not_busy(dev);\n\tif (status)\n\t\treturn status;\n\n\treturn i2c_dw_check_stopbit(dev);\n}\n\n \nstatic int amd_i2c_dw_xfer_quirk(struct i2c_adapter *adap, struct i2c_msg *msgs, int num_msgs)\n{\n\tstruct dw_i2c_dev *dev = i2c_get_adapdata(adap);\n\tint msg_wrt_idx, msg_itr_lmt, buf_len, data_idx;\n\tint cmd = 0, status;\n\tu8 *tx_buf;\n\tunsigned int val;\n\n\t \n\tregmap_write(dev->map, AMD_UCSI_INTR_REG, AMD_UCSI_INTR_EN);\n\n\tdev->msgs = msgs;\n\tdev->msgs_num = num_msgs;\n\ti2c_dw_xfer_init(dev);\n\tregmap_write(dev->map, DW_IC_INTR_MASK, 0);\n\n\t \n\tfor (msg_wrt_idx = 0; msg_wrt_idx < num_msgs; msg_wrt_idx++) {\n\t\ttx_buf = msgs[msg_wrt_idx].buf;\n\t\tbuf_len = msgs[msg_wrt_idx].len;\n\n\t\tif (!(msgs[msg_wrt_idx].flags & I2C_M_RD))\n\t\t\tregmap_write(dev->map, DW_IC_TX_TL, buf_len - 1);\n\t\t \n\t\tfor (msg_itr_lmt = buf_len; msg_itr_lmt > 0; msg_itr_lmt--) {\n\t\t\tif (msg_wrt_idx == num_msgs - 1 && msg_itr_lmt == 1)\n\t\t\t\tcmd |= BIT(9);\n\n\t\t\tif (msgs[msg_wrt_idx].flags & I2C_M_RD) {\n\t\t\t\t \n\t\t\t\tregmap_write(dev->map, DW_IC_DATA_CMD, 0x100);\n\t\t\t\tregmap_write(dev->map, DW_IC_DATA_CMD, 0x100 | cmd);\n\t\t\t\tif (cmd) {\n\t\t\t\t\tregmap_write(dev->map, DW_IC_TX_TL, 2 * (buf_len - 1));\n\t\t\t\t\tregmap_write(dev->map, DW_IC_RX_TL, 2 * (buf_len - 1));\n\t\t\t\t\t \n\t\t\t\t\tstatus = i2c_dw_status(dev);\n\t\t\t\t\tif (status)\n\t\t\t\t\t\treturn status;\n\n\t\t\t\t\tfor (data_idx = 0; data_idx < buf_len; data_idx++) {\n\t\t\t\t\t\tregmap_read(dev->map, DW_IC_DATA_CMD, &val);\n\t\t\t\t\t\ttx_buf[data_idx] = val;\n\t\t\t\t\t}\n\t\t\t\t\tstatus = i2c_dw_check_stopbit(dev);\n\t\t\t\t\tif (status)\n\t\t\t\t\t\treturn status;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tregmap_write(dev->map, DW_IC_DATA_CMD, *tx_buf++ | cmd);\n\t\t\t\tusleep_range(AMD_TIMEOUT_MIN_US, AMD_TIMEOUT_MAX_US);\n\t\t\t}\n\t\t}\n\t\tstatus = i2c_dw_check_stopbit(dev);\n\t\tif (status)\n\t\t\treturn status;\n\t}\n\n\treturn 0;\n}\n\nstatic int i2c_dw_poll_tx_empty(struct dw_i2c_dev *dev)\n{\n\tu32 val;\n\n\treturn regmap_read_poll_timeout(dev->map, DW_IC_RAW_INTR_STAT, val,\n\t\t\t\t\tval & DW_IC_INTR_TX_EMPTY,\n\t\t\t\t\t100, 1000);\n}\n\nstatic int i2c_dw_poll_rx_full(struct dw_i2c_dev *dev)\n{\n\tu32 val;\n\n\treturn regmap_read_poll_timeout(dev->map, DW_IC_RAW_INTR_STAT, val,\n\t\t\t\t\tval & DW_IC_INTR_RX_FULL,\n\t\t\t\t\t100, 1000);\n}\n\nstatic int txgbe_i2c_dw_xfer_quirk(struct i2c_adapter *adap, struct i2c_msg *msgs,\n\t\t\t\t   int num_msgs)\n{\n\tstruct dw_i2c_dev *dev = i2c_get_adapdata(adap);\n\tint msg_idx, buf_len, data_idx, ret;\n\tunsigned int val, stop = 0;\n\tu8 *buf;\n\n\tdev->msgs = msgs;\n\tdev->msgs_num = num_msgs;\n\ti2c_dw_xfer_init(dev);\n\tregmap_write(dev->map, DW_IC_INTR_MASK, 0);\n\n\tfor (msg_idx = 0; msg_idx < num_msgs; msg_idx++) {\n\t\tbuf = msgs[msg_idx].buf;\n\t\tbuf_len = msgs[msg_idx].len;\n\n\t\tfor (data_idx = 0; data_idx < buf_len; data_idx++) {\n\t\t\tif (msg_idx == num_msgs - 1 && data_idx == buf_len - 1)\n\t\t\t\tstop |= BIT(9);\n\n\t\t\tif (msgs[msg_idx].flags & I2C_M_RD) {\n\t\t\t\tregmap_write(dev->map, DW_IC_DATA_CMD, 0x100 | stop);\n\n\t\t\t\tret = i2c_dw_poll_rx_full(dev);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\n\t\t\t\tregmap_read(dev->map, DW_IC_DATA_CMD, &val);\n\t\t\t\tbuf[data_idx] = val;\n\t\t\t} else {\n\t\t\t\tret = i2c_dw_poll_tx_empty(dev);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\n\t\t\t\tregmap_write(dev->map, DW_IC_DATA_CMD,\n\t\t\t\t\t     buf[data_idx] | stop);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn num_msgs;\n}\n\n \nstatic void\ni2c_dw_xfer_msg(struct dw_i2c_dev *dev)\n{\n\tstruct i2c_msg *msgs = dev->msgs;\n\tu32 intr_mask;\n\tint tx_limit, rx_limit;\n\tu32 addr = msgs[dev->msg_write_idx].addr;\n\tu32 buf_len = dev->tx_buf_len;\n\tu8 *buf = dev->tx_buf;\n\tbool need_restart = false;\n\tunsigned int flr;\n\n\tintr_mask = DW_IC_INTR_MASTER_MASK;\n\n\tfor (; dev->msg_write_idx < dev->msgs_num; dev->msg_write_idx++) {\n\t\tu32 flags = msgs[dev->msg_write_idx].flags;\n\n\t\t \n\t\tif (msgs[dev->msg_write_idx].addr != addr) {\n\t\t\tdev_err(dev->dev,\n\t\t\t\t\"%s: invalid target address\\n\", __func__);\n\t\t\tdev->msg_err = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!(dev->status & STATUS_WRITE_IN_PROGRESS)) {\n\t\t\t \n\t\t\tbuf = msgs[dev->msg_write_idx].buf;\n\t\t\tbuf_len = msgs[dev->msg_write_idx].len;\n\n\t\t\t \n\t\t\tif ((dev->master_cfg & DW_IC_CON_RESTART_EN) &&\n\t\t\t\t\t(dev->msg_write_idx > 0))\n\t\t\t\tneed_restart = true;\n\t\t}\n\n\t\tregmap_read(dev->map, DW_IC_TXFLR, &flr);\n\t\ttx_limit = dev->tx_fifo_depth - flr;\n\n\t\tregmap_read(dev->map, DW_IC_RXFLR, &flr);\n\t\trx_limit = dev->rx_fifo_depth - flr;\n\n\t\twhile (buf_len > 0 && tx_limit > 0 && rx_limit > 0) {\n\t\t\tu32 cmd = 0;\n\n\t\t\t \n\n\t\t\t \n\t\t\tif (dev->msg_write_idx == dev->msgs_num - 1 &&\n\t\t\t    buf_len == 1 && !(flags & I2C_M_RECV_LEN))\n\t\t\t\tcmd |= BIT(9);\n\n\t\t\tif (need_restart) {\n\t\t\t\tcmd |= BIT(10);\n\t\t\t\tneed_restart = false;\n\t\t\t}\n\n\t\t\tif (msgs[dev->msg_write_idx].flags & I2C_M_RD) {\n\n\t\t\t\t \n\t\t\t\tif (dev->rx_outstanding >= dev->rx_fifo_depth)\n\t\t\t\t\tbreak;\n\n\t\t\t\tregmap_write(dev->map, DW_IC_DATA_CMD,\n\t\t\t\t\t     cmd | 0x100);\n\t\t\t\trx_limit--;\n\t\t\t\tdev->rx_outstanding++;\n\t\t\t} else {\n\t\t\t\tregmap_write(dev->map, DW_IC_DATA_CMD,\n\t\t\t\t\t     cmd | *buf++);\n\t\t\t}\n\t\t\ttx_limit--; buf_len--;\n\t\t}\n\n\t\tdev->tx_buf = buf;\n\t\tdev->tx_buf_len = buf_len;\n\n\t\t \n\t\tif (flags & I2C_M_RECV_LEN) {\n\t\t\tdev->status |= STATUS_WRITE_IN_PROGRESS;\n\t\t\tintr_mask &= ~DW_IC_INTR_TX_EMPTY;\n\t\t\tbreak;\n\t\t} else if (buf_len > 0) {\n\t\t\t \n\t\t\tdev->status |= STATUS_WRITE_IN_PROGRESS;\n\t\t\tbreak;\n\t\t} else\n\t\t\tdev->status &= ~STATUS_WRITE_IN_PROGRESS;\n\t}\n\n\t \n\tif (dev->msg_write_idx == dev->msgs_num)\n\t\tintr_mask &= ~DW_IC_INTR_TX_EMPTY;\n\n\tif (dev->msg_err)\n\t\tintr_mask = 0;\n\n\tregmap_write(dev->map,  DW_IC_INTR_MASK, intr_mask);\n}\n\nstatic u8\ni2c_dw_recv_len(struct dw_i2c_dev *dev, u8 len)\n{\n\tstruct i2c_msg *msgs = dev->msgs;\n\tu32 flags = msgs[dev->msg_read_idx].flags;\n\n\t \n\tlen += (flags & I2C_CLIENT_PEC) ? 2 : 1;\n\tdev->tx_buf_len = len - min_t(u8, len, dev->rx_outstanding);\n\tmsgs[dev->msg_read_idx].len = len;\n\tmsgs[dev->msg_read_idx].flags &= ~I2C_M_RECV_LEN;\n\n\t \n\tregmap_update_bits(dev->map, DW_IC_INTR_MASK, DW_IC_INTR_TX_EMPTY,\n\t\t\t   DW_IC_INTR_TX_EMPTY);\n\n\treturn len;\n}\n\nstatic void\ni2c_dw_read(struct dw_i2c_dev *dev)\n{\n\tstruct i2c_msg *msgs = dev->msgs;\n\tunsigned int rx_valid;\n\n\tfor (; dev->msg_read_idx < dev->msgs_num; dev->msg_read_idx++) {\n\t\tunsigned int tmp;\n\t\tu32 len;\n\t\tu8 *buf;\n\n\t\tif (!(msgs[dev->msg_read_idx].flags & I2C_M_RD))\n\t\t\tcontinue;\n\n\t\tif (!(dev->status & STATUS_READ_IN_PROGRESS)) {\n\t\t\tlen = msgs[dev->msg_read_idx].len;\n\t\t\tbuf = msgs[dev->msg_read_idx].buf;\n\t\t} else {\n\t\t\tlen = dev->rx_buf_len;\n\t\t\tbuf = dev->rx_buf;\n\t\t}\n\n\t\tregmap_read(dev->map, DW_IC_RXFLR, &rx_valid);\n\n\t\tfor (; len > 0 && rx_valid > 0; len--, rx_valid--) {\n\t\t\tu32 flags = msgs[dev->msg_read_idx].flags;\n\n\t\t\tregmap_read(dev->map, DW_IC_DATA_CMD, &tmp);\n\t\t\ttmp &= DW_IC_DATA_CMD_DAT;\n\t\t\t \n\t\t\tif (flags & I2C_M_RECV_LEN) {\n\t\t\t\t \n\t\t\t\tif (!tmp || tmp > I2C_SMBUS_BLOCK_MAX)\n\t\t\t\t\ttmp = 1;\n\n\t\t\t\tlen = i2c_dw_recv_len(dev, tmp);\n\t\t\t}\n\t\t\t*buf++ = tmp;\n\t\t\tdev->rx_outstanding--;\n\t\t}\n\n\t\tif (len > 0) {\n\t\t\tdev->status |= STATUS_READ_IN_PROGRESS;\n\t\t\tdev->rx_buf_len = len;\n\t\t\tdev->rx_buf = buf;\n\t\t\treturn;\n\t\t} else\n\t\t\tdev->status &= ~STATUS_READ_IN_PROGRESS;\n\t}\n}\n\n \nstatic int\ni2c_dw_xfer(struct i2c_adapter *adap, struct i2c_msg msgs[], int num)\n{\n\tstruct dw_i2c_dev *dev = i2c_get_adapdata(adap);\n\tint ret;\n\n\tdev_dbg(dev->dev, \"%s: msgs: %d\\n\", __func__, num);\n\n\tpm_runtime_get_sync(dev->dev);\n\n\t \n\tswitch (dev->flags & MODEL_MASK) {\n\tcase MODEL_AMD_NAVI_GPU:\n\t\tret = amd_i2c_dw_xfer_quirk(adap, msgs, num);\n\t\tgoto done_nolock;\n\tcase MODEL_WANGXUN_SP:\n\t\tret = txgbe_i2c_dw_xfer_quirk(adap, msgs, num);\n\t\tgoto done_nolock;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treinit_completion(&dev->cmd_complete);\n\tdev->msgs = msgs;\n\tdev->msgs_num = num;\n\tdev->cmd_err = 0;\n\tdev->msg_write_idx = 0;\n\tdev->msg_read_idx = 0;\n\tdev->msg_err = 0;\n\tdev->status = 0;\n\tdev->abort_source = 0;\n\tdev->rx_outstanding = 0;\n\n\tret = i2c_dw_acquire_lock(dev);\n\tif (ret)\n\t\tgoto done_nolock;\n\n\tret = i2c_dw_wait_bus_not_busy(dev);\n\tif (ret < 0)\n\t\tgoto done;\n\n\t \n\ti2c_dw_xfer_init(dev);\n\n\t \n\tif (!wait_for_completion_timeout(&dev->cmd_complete, adap->timeout)) {\n\t\tdev_err(dev->dev, \"controller timed out\\n\");\n\t\t \n\t\ti2c_recover_bus(&dev->adapter);\n\t\ti2c_dw_init_master(dev);\n\t\tret = -ETIMEDOUT;\n\t\tgoto done;\n\t}\n\n\t \n\t__i2c_dw_disable_nowait(dev);\n\n\tif (dev->msg_err) {\n\t\tret = dev->msg_err;\n\t\tgoto done;\n\t}\n\n\t \n\tif (likely(!dev->cmd_err && !dev->status)) {\n\t\tret = num;\n\t\tgoto done;\n\t}\n\n\t \n\tif (dev->cmd_err == DW_IC_ERR_TX_ABRT) {\n\t\tret = i2c_dw_handle_tx_abort(dev);\n\t\tgoto done;\n\t}\n\n\tif (dev->status)\n\t\tdev_err(dev->dev,\n\t\t\t\"transfer terminated early - interrupt latency too high?\\n\");\n\n\tret = -EIO;\n\ndone:\n\ti2c_dw_release_lock(dev);\n\ndone_nolock:\n\tpm_runtime_mark_last_busy(dev->dev);\n\tpm_runtime_put_autosuspend(dev->dev);\n\n\treturn ret;\n}\n\nstatic const struct i2c_algorithm i2c_dw_algo = {\n\t.master_xfer = i2c_dw_xfer,\n\t.functionality = i2c_dw_func,\n};\n\nstatic const struct i2c_adapter_quirks i2c_dw_quirks = {\n\t.flags = I2C_AQ_NO_ZERO_LEN,\n};\n\nstatic u32 i2c_dw_read_clear_intrbits(struct dw_i2c_dev *dev)\n{\n\tunsigned int stat, dummy;\n\n\t \n\tregmap_read(dev->map, DW_IC_INTR_STAT, &stat);\n\n\t \n\tif (stat & DW_IC_INTR_RX_UNDER)\n\t\tregmap_read(dev->map, DW_IC_CLR_RX_UNDER, &dummy);\n\tif (stat & DW_IC_INTR_RX_OVER)\n\t\tregmap_read(dev->map, DW_IC_CLR_RX_OVER, &dummy);\n\tif (stat & DW_IC_INTR_TX_OVER)\n\t\tregmap_read(dev->map, DW_IC_CLR_TX_OVER, &dummy);\n\tif (stat & DW_IC_INTR_RD_REQ)\n\t\tregmap_read(dev->map, DW_IC_CLR_RD_REQ, &dummy);\n\tif (stat & DW_IC_INTR_TX_ABRT) {\n\t\t \n\t\tregmap_read(dev->map, DW_IC_TX_ABRT_SOURCE, &dev->abort_source);\n\t\tregmap_read(dev->map, DW_IC_CLR_TX_ABRT, &dummy);\n\t}\n\tif (stat & DW_IC_INTR_RX_DONE)\n\t\tregmap_read(dev->map, DW_IC_CLR_RX_DONE, &dummy);\n\tif (stat & DW_IC_INTR_ACTIVITY)\n\t\tregmap_read(dev->map, DW_IC_CLR_ACTIVITY, &dummy);\n\tif ((stat & DW_IC_INTR_STOP_DET) &&\n\t    ((dev->rx_outstanding == 0) || (stat & DW_IC_INTR_RX_FULL)))\n\t\tregmap_read(dev->map, DW_IC_CLR_STOP_DET, &dummy);\n\tif (stat & DW_IC_INTR_START_DET)\n\t\tregmap_read(dev->map, DW_IC_CLR_START_DET, &dummy);\n\tif (stat & DW_IC_INTR_GEN_CALL)\n\t\tregmap_read(dev->map, DW_IC_CLR_GEN_CALL, &dummy);\n\n\treturn stat;\n}\n\n \nstatic irqreturn_t i2c_dw_isr(int this_irq, void *dev_id)\n{\n\tstruct dw_i2c_dev *dev = dev_id;\n\tunsigned int stat, enabled;\n\n\tregmap_read(dev->map, DW_IC_ENABLE, &enabled);\n\tregmap_read(dev->map, DW_IC_RAW_INTR_STAT, &stat);\n\tif (!enabled || !(stat & ~DW_IC_INTR_ACTIVITY))\n\t\treturn IRQ_NONE;\n\tif (pm_runtime_suspended(dev->dev) || stat == GENMASK(31, 0))\n\t\treturn IRQ_NONE;\n\tdev_dbg(dev->dev, \"enabled=%#x stat=%#x\\n\", enabled, stat);\n\n\tstat = i2c_dw_read_clear_intrbits(dev);\n\n\tif (!(dev->status & STATUS_ACTIVE)) {\n\t\t \n\t\tregmap_write(dev->map, DW_IC_INTR_MASK, 0);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tif (stat & DW_IC_INTR_TX_ABRT) {\n\t\tdev->cmd_err |= DW_IC_ERR_TX_ABRT;\n\t\tdev->status &= ~STATUS_MASK;\n\t\tdev->rx_outstanding = 0;\n\n\t\t \n\t\tregmap_write(dev->map, DW_IC_INTR_MASK, 0);\n\t\tgoto tx_aborted;\n\t}\n\n\tif (stat & DW_IC_INTR_RX_FULL)\n\t\ti2c_dw_read(dev);\n\n\tif (stat & DW_IC_INTR_TX_EMPTY)\n\t\ti2c_dw_xfer_msg(dev);\n\n\t \n\ntx_aborted:\n\tif (((stat & (DW_IC_INTR_TX_ABRT | DW_IC_INTR_STOP_DET)) || dev->msg_err) &&\n\t     (dev->rx_outstanding == 0))\n\t\tcomplete(&dev->cmd_complete);\n\telse if (unlikely(dev->flags & ACCESS_INTR_MASK)) {\n\t\t \n\t\tregmap_read(dev->map, DW_IC_INTR_MASK, &stat);\n\t\tregmap_write(dev->map, DW_IC_INTR_MASK, 0);\n\t\tregmap_write(dev->map, DW_IC_INTR_MASK, stat);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nvoid i2c_dw_configure_master(struct dw_i2c_dev *dev)\n{\n\tstruct i2c_timings *t = &dev->timings;\n\n\tdev->functionality = I2C_FUNC_10BIT_ADDR | DW_IC_DEFAULT_FUNCTIONALITY;\n\n\tdev->master_cfg = DW_IC_CON_MASTER | DW_IC_CON_SLAVE_DISABLE |\n\t\t\t  DW_IC_CON_RESTART_EN;\n\n\tdev->mode = DW_IC_MASTER;\n\n\tswitch (t->bus_freq_hz) {\n\tcase I2C_MAX_STANDARD_MODE_FREQ:\n\t\tdev->master_cfg |= DW_IC_CON_SPEED_STD;\n\t\tbreak;\n\tcase I2C_MAX_HIGH_SPEED_MODE_FREQ:\n\t\tdev->master_cfg |= DW_IC_CON_SPEED_HIGH;\n\t\tbreak;\n\tdefault:\n\t\tdev->master_cfg |= DW_IC_CON_SPEED_FAST;\n\t}\n}\nEXPORT_SYMBOL_GPL(i2c_dw_configure_master);\n\nstatic void i2c_dw_prepare_recovery(struct i2c_adapter *adap)\n{\n\tstruct dw_i2c_dev *dev = i2c_get_adapdata(adap);\n\n\ti2c_dw_disable(dev);\n\treset_control_assert(dev->rst);\n\ti2c_dw_prepare_clk(dev, false);\n}\n\nstatic void i2c_dw_unprepare_recovery(struct i2c_adapter *adap)\n{\n\tstruct dw_i2c_dev *dev = i2c_get_adapdata(adap);\n\n\ti2c_dw_prepare_clk(dev, true);\n\treset_control_deassert(dev->rst);\n\ti2c_dw_init_master(dev);\n}\n\nstatic int i2c_dw_init_recovery_info(struct dw_i2c_dev *dev)\n{\n\tstruct i2c_bus_recovery_info *rinfo = &dev->rinfo;\n\tstruct i2c_adapter *adap = &dev->adapter;\n\tstruct gpio_desc *gpio;\n\n\tgpio = devm_gpiod_get_optional(dev->dev, \"scl\", GPIOD_OUT_HIGH);\n\tif (IS_ERR_OR_NULL(gpio))\n\t\treturn PTR_ERR_OR_ZERO(gpio);\n\n\trinfo->scl_gpiod = gpio;\n\n\tgpio = devm_gpiod_get_optional(dev->dev, \"sda\", GPIOD_IN);\n\tif (IS_ERR(gpio))\n\t\treturn PTR_ERR(gpio);\n\trinfo->sda_gpiod = gpio;\n\n\trinfo->pinctrl = devm_pinctrl_get(dev->dev);\n\tif (IS_ERR(rinfo->pinctrl)) {\n\t\tif (PTR_ERR(rinfo->pinctrl) == -EPROBE_DEFER)\n\t\t\treturn PTR_ERR(rinfo->pinctrl);\n\n\t\trinfo->pinctrl = NULL;\n\t\tdev_err(dev->dev, \"getting pinctrl info failed: bus recovery might not work\\n\");\n\t} else if (!rinfo->pinctrl) {\n\t\tdev_dbg(dev->dev, \"pinctrl is disabled, bus recovery might not work\\n\");\n\t}\n\n\trinfo->recover_bus = i2c_generic_scl_recovery;\n\trinfo->prepare_recovery = i2c_dw_prepare_recovery;\n\trinfo->unprepare_recovery = i2c_dw_unprepare_recovery;\n\tadap->bus_recovery_info = rinfo;\n\n\tdev_info(dev->dev, \"running with gpio recovery mode! scl%s\",\n\t\t rinfo->sda_gpiod ? \",sda\" : \"\");\n\n\treturn 0;\n}\n\nstatic int i2c_dw_poll_adap_quirk(struct dw_i2c_dev *dev)\n{\n\tstruct i2c_adapter *adap = &dev->adapter;\n\tint ret;\n\n\tpm_runtime_get_noresume(dev->dev);\n\tret = i2c_add_numbered_adapter(adap);\n\tif (ret)\n\t\tdev_err(dev->dev, \"Failed to add adapter: %d\\n\", ret);\n\tpm_runtime_put_noidle(dev->dev);\n\n\treturn ret;\n}\n\nstatic bool i2c_dw_is_model_poll(struct dw_i2c_dev *dev)\n{\n\tswitch (dev->flags & MODEL_MASK) {\n\tcase MODEL_AMD_NAVI_GPU:\n\tcase MODEL_WANGXUN_SP:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nint i2c_dw_probe_master(struct dw_i2c_dev *dev)\n{\n\tstruct i2c_adapter *adap = &dev->adapter;\n\tunsigned long irq_flags;\n\tunsigned int ic_con;\n\tint ret;\n\n\tinit_completion(&dev->cmd_complete);\n\n\tdev->init = i2c_dw_init_master;\n\tdev->disable = i2c_dw_disable;\n\n\tret = i2c_dw_init_regmap(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = i2c_dw_set_timings_master(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = i2c_dw_set_fifo_size(dev);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = i2c_dw_acquire_lock(dev);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = regmap_read(dev->map, DW_IC_CON, &ic_con);\n\ti2c_dw_release_lock(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tif (ic_con & DW_IC_CON_BUS_CLEAR_CTRL)\n\t\tdev->master_cfg |= DW_IC_CON_BUS_CLEAR_CTRL;\n\n\tret = dev->init(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tsnprintf(adap->name, sizeof(adap->name),\n\t\t \"Synopsys DesignWare I2C adapter\");\n\tadap->retries = 3;\n\tadap->algo = &i2c_dw_algo;\n\tadap->quirks = &i2c_dw_quirks;\n\tadap->dev.parent = dev->dev;\n\ti2c_set_adapdata(adap, dev);\n\n\tif (i2c_dw_is_model_poll(dev))\n\t\treturn i2c_dw_poll_adap_quirk(dev);\n\n\tif (dev->flags & ACCESS_NO_IRQ_SUSPEND) {\n\t\tirq_flags = IRQF_NO_SUSPEND;\n\t} else {\n\t\tirq_flags = IRQF_SHARED | IRQF_COND_SUSPEND;\n\t}\n\n\tret = i2c_dw_acquire_lock(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tregmap_write(dev->map, DW_IC_INTR_MASK, 0);\n\ti2c_dw_release_lock(dev);\n\n\tret = devm_request_irq(dev->dev, dev->irq, i2c_dw_isr, irq_flags,\n\t\t\t       dev_name(dev->dev), dev);\n\tif (ret) {\n\t\tdev_err(dev->dev, \"failure requesting irq %i: %d\\n\",\n\t\t\tdev->irq, ret);\n\t\treturn ret;\n\t}\n\n\tret = i2c_dw_init_recovery_info(dev);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tpm_runtime_get_noresume(dev->dev);\n\tret = i2c_add_numbered_adapter(adap);\n\tif (ret)\n\t\tdev_err(dev->dev, \"failure adding adapter: %d\\n\", ret);\n\tpm_runtime_put_noidle(dev->dev);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(i2c_dw_probe_master);\n\nMODULE_DESCRIPTION(\"Synopsys DesignWare I2C bus master adapter\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}