{
  "module_name": "i2c-opal.c",
  "hash_id": "383d17108d7e64f832dac49199885ada4700db752315a133d4b0f087bf82eb82",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-opal.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/i2c.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n\n#include <asm/firmware.h>\n#include <asm/opal.h>\n\nstatic int i2c_opal_translate_error(int rc)\n{\n\tswitch (rc) {\n\tcase OPAL_NO_MEM:\n\t\treturn -ENOMEM;\n\tcase OPAL_PARAMETER:\n\t\treturn -EINVAL;\n\tcase OPAL_I2C_ARBT_LOST:\n\t\treturn -EAGAIN;\n\tcase OPAL_I2C_TIMEOUT:\n\t\treturn -ETIMEDOUT;\n\tcase OPAL_I2C_NACK_RCVD:\n\t\treturn -ENXIO;\n\tcase OPAL_I2C_STOP_ERR:\n\t\treturn -EBUSY;\n\tdefault:\n\t\treturn -EIO;\n\t}\n}\n\nstatic int i2c_opal_send_request(u32 bus_id, struct opal_i2c_request *req)\n{\n\tstruct opal_msg msg;\n\tint token, rc;\n\n\ttoken = opal_async_get_token_interruptible();\n\tif (token < 0) {\n\t\tif (token != -ERESTARTSYS)\n\t\t\tpr_err(\"Failed to get the async token\\n\");\n\n\t\treturn token;\n\t}\n\n\trc = opal_i2c_request(token, bus_id, req);\n\tif (rc != OPAL_ASYNC_COMPLETION) {\n\t\trc = i2c_opal_translate_error(rc);\n\t\tgoto exit;\n\t}\n\n\trc = opal_async_wait_response(token, &msg);\n\tif (rc)\n\t\tgoto exit;\n\n\trc = opal_get_async_rc(msg);\n\tif (rc != OPAL_SUCCESS) {\n\t\trc = i2c_opal_translate_error(rc);\n\t\tgoto exit;\n\t}\n\nexit:\n\topal_async_release_token(token);\n\treturn rc;\n}\n\nstatic int i2c_opal_master_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs,\n\t\t\t\tint num)\n{\n\tunsigned long opal_id = (unsigned long)adap->algo_data;\n\tstruct opal_i2c_request req;\n\tint rc, i;\n\n\t \n\tmemset(&req, 0, sizeof(req));\n\tswitch(num) {\n\tcase 1:\n\t\treq.type = (msgs[0].flags & I2C_M_RD) ?\n\t\t\tOPAL_I2C_RAW_READ : OPAL_I2C_RAW_WRITE;\n\t\treq.addr = cpu_to_be16(msgs[0].addr);\n\t\treq.size = cpu_to_be32(msgs[0].len);\n\t\treq.buffer_ra = cpu_to_be64(__pa(msgs[0].buf));\n\t\tbreak;\n\tcase 2:\n\t\treq.type = (msgs[1].flags & I2C_M_RD) ?\n\t\t\tOPAL_I2C_SM_READ : OPAL_I2C_SM_WRITE;\n\t\treq.addr = cpu_to_be16(msgs[0].addr);\n\t\treq.subaddr_sz = msgs[0].len;\n\t\tfor (i = 0; i < msgs[0].len; i++)\n\t\t\treq.subaddr = (req.subaddr << 8) | msgs[0].buf[i];\n\t\treq.subaddr = cpu_to_be32(req.subaddr);\n\t\treq.size = cpu_to_be32(msgs[1].len);\n\t\treq.buffer_ra = cpu_to_be64(__pa(msgs[1].buf));\n\t\tbreak;\n\t}\n\n\trc = i2c_opal_send_request(opal_id, &req);\n\tif (rc)\n\t\treturn rc;\n\n\treturn num;\n}\n\nstatic int i2c_opal_smbus_xfer(struct i2c_adapter *adap, u16 addr,\n\t\t\t       unsigned short flags, char read_write,\n\t\t\t       u8 command, int size, union i2c_smbus_data *data)\n{\n\tunsigned long opal_id = (unsigned long)adap->algo_data;\n\tstruct opal_i2c_request req;\n\tu8 local[2];\n\tint rc;\n\n\tmemset(&req, 0, sizeof(req));\n\n\treq.addr = cpu_to_be16(addr);\n\tswitch (size) {\n\tcase I2C_SMBUS_BYTE:\n\t\treq.buffer_ra = cpu_to_be64(__pa(&data->byte));\n\t\treq.size = cpu_to_be32(1);\n\t\tfallthrough;\n\tcase I2C_SMBUS_QUICK:\n\t\treq.type = (read_write == I2C_SMBUS_READ) ?\n\t\t\tOPAL_I2C_RAW_READ : OPAL_I2C_RAW_WRITE;\n\t\tbreak;\n\tcase I2C_SMBUS_BYTE_DATA:\n\t\treq.buffer_ra = cpu_to_be64(__pa(&data->byte));\n\t\treq.size = cpu_to_be32(1);\n\t\treq.subaddr = cpu_to_be32(command);\n\t\treq.subaddr_sz = 1;\n\t\treq.type = (read_write == I2C_SMBUS_READ) ?\n\t\t\tOPAL_I2C_SM_READ : OPAL_I2C_SM_WRITE;\n\t\tbreak;\n\tcase I2C_SMBUS_WORD_DATA:\n\t\tif (!read_write) {\n\t\t\tlocal[0] = data->word & 0xff;\n\t\t\tlocal[1] = (data->word >> 8) & 0xff;\n\t\t}\n\t\treq.buffer_ra = cpu_to_be64(__pa(local));\n\t\treq.size = cpu_to_be32(2);\n\t\treq.subaddr = cpu_to_be32(command);\n\t\treq.subaddr_sz = 1;\n\t\treq.type = (read_write == I2C_SMBUS_READ) ?\n\t\t\tOPAL_I2C_SM_READ : OPAL_I2C_SM_WRITE;\n\t\tbreak;\n\tcase I2C_SMBUS_I2C_BLOCK_DATA:\n\t\treq.buffer_ra = cpu_to_be64(__pa(&data->block[1]));\n\t\treq.size = cpu_to_be32(data->block[0]);\n\t\treq.subaddr = cpu_to_be32(command);\n\t\treq.subaddr_sz = 1;\n\t\treq.type = (read_write == I2C_SMBUS_READ) ?\n\t\t\tOPAL_I2C_SM_READ : OPAL_I2C_SM_WRITE;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\trc = i2c_opal_send_request(opal_id, &req);\n\tif (!rc && read_write && size == I2C_SMBUS_WORD_DATA) {\n\t\tdata->word = ((u16)local[1]) << 8;\n\t\tdata->word |= local[0];\n\t}\n\n\treturn rc;\n}\n\nstatic u32 i2c_opal_func(struct i2c_adapter *adapter)\n{\n\treturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_QUICK | I2C_FUNC_SMBUS_BYTE |\n\t       I2C_FUNC_SMBUS_BYTE_DATA | I2C_FUNC_SMBUS_WORD_DATA |\n\t       I2C_FUNC_SMBUS_I2C_BLOCK;\n}\n\nstatic const struct i2c_algorithm i2c_opal_algo = {\n\t.master_xfer\t= i2c_opal_master_xfer,\n\t.smbus_xfer\t= i2c_opal_smbus_xfer,\n\t.functionality\t= i2c_opal_func,\n};\n\n \nstatic const struct i2c_adapter_quirks i2c_opal_quirks = {\n\t.flags = I2C_AQ_COMB | I2C_AQ_COMB_WRITE_FIRST | I2C_AQ_COMB_SAME_ADDR,\n\t.max_comb_1st_msg_len = 4,\n};\n\nstatic int i2c_opal_probe(struct platform_device *pdev)\n{\n\tstruct i2c_adapter\t*adapter;\n\tconst char\t\t*pname;\n\tu32\t\t\topal_id;\n\tint\t\t\trc;\n\n\tif (!pdev->dev.of_node)\n\t\treturn -ENODEV;\n\n\trc = of_property_read_u32(pdev->dev.of_node, \"ibm,opal-id\", &opal_id);\n\tif (rc) {\n\t\tdev_err(&pdev->dev, \"Missing ibm,opal-id property !\\n\");\n\t\treturn -EIO;\n\t}\n\n\tadapter = devm_kzalloc(&pdev->dev, sizeof(*adapter), GFP_KERNEL);\n\tif (!adapter)\n\t\treturn -ENOMEM;\n\n\tadapter->algo = &i2c_opal_algo;\n\tadapter->algo_data = (void *)(unsigned long)opal_id;\n\tadapter->quirks = &i2c_opal_quirks;\n\tadapter->dev.parent = &pdev->dev;\n\tadapter->dev.of_node = of_node_get(pdev->dev.of_node);\n\tpname = of_get_property(pdev->dev.of_node, \"ibm,port-name\", NULL);\n\tif (pname)\n\t\tstrscpy(adapter->name, pname, sizeof(adapter->name));\n\telse\n\t\tstrscpy(adapter->name, \"opal\", sizeof(adapter->name));\n\n\tplatform_set_drvdata(pdev, adapter);\n\trc = i2c_add_adapter(adapter);\n\tif (rc)\n\t\tdev_err(&pdev->dev, \"Failed to register the i2c adapter\\n\");\n\n\treturn rc;\n}\n\nstatic void i2c_opal_remove(struct platform_device *pdev)\n{\n\tstruct i2c_adapter *adapter = platform_get_drvdata(pdev);\n\n\ti2c_del_adapter(adapter);\n}\n\nstatic const struct of_device_id i2c_opal_of_match[] = {\n\t{\n\t\t.compatible = \"ibm,opal-i2c\",\n\t},\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, i2c_opal_of_match);\n\nstatic struct platform_driver i2c_opal_driver = {\n\t.probe\t= i2c_opal_probe,\n\t.remove_new = i2c_opal_remove,\n\t.driver\t= {\n\t\t.name\t\t= \"i2c-opal\",\n\t\t.of_match_table\t= i2c_opal_of_match,\n\t},\n};\n\nstatic int __init i2c_opal_init(void)\n{\n\tif (!firmware_has_feature(FW_FEATURE_OPAL))\n\t\treturn -ENODEV;\n\n\treturn platform_driver_register(&i2c_opal_driver);\n}\nmodule_init(i2c_opal_init);\n\nstatic void __exit i2c_opal_exit(void)\n{\n\treturn platform_driver_unregister(&i2c_opal_driver);\n}\nmodule_exit(i2c_opal_exit);\n\nMODULE_AUTHOR(\"Neelesh Gupta <neelegup@linux.vnet.ibm.com>\");\nMODULE_DESCRIPTION(\"IBM OPAL I2C driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}