{
  "module_name": "i2c-synquacer.c",
  "hash_id": "09a5905706ddc9eb7804a8fd7bb8d7056321e04f6d04f02dacc092b8c6581b10",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-synquacer.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n\n#define WAIT_PCLK(n, rate)\t\\\n\tndelay(DIV_ROUND_UP(DIV_ROUND_UP(1000000000, rate), n) + 10)\n\n \n#define SYNQUACER_I2C_REG_BSR\t\t(0x00 << 2) \n#define SYNQUACER_I2C_REG_BCR\t\t(0x01 << 2) \n#define SYNQUACER_I2C_REG_CCR\t\t(0x02 << 2) \n#define SYNQUACER_I2C_REG_ADR\t\t(0x03 << 2) \n#define SYNQUACER_I2C_REG_DAR\t\t(0x04 << 2) \n#define SYNQUACER_I2C_REG_CSR\t\t(0x05 << 2) \n#define SYNQUACER_I2C_REG_FSR\t\t(0x06 << 2) \n#define SYNQUACER_I2C_REG_BC2R\t\t(0x07 << 2) \n\n \n#define SYNQUACER_I2C_BSR_FBT\t\tBIT(0)\t\n#define SYNQUACER_I2C_BSR_GCA\t\tBIT(1)\t\n#define SYNQUACER_I2C_BSR_AAS\t\tBIT(2)\t\n#define SYNQUACER_I2C_BSR_TRX\t\tBIT(3)\t\n#define SYNQUACER_I2C_BSR_LRB\t\tBIT(4)\t\n#define SYNQUACER_I2C_BSR_AL\t\tBIT(5)\t\n#define SYNQUACER_I2C_BSR_RSC\t\tBIT(6)\t\n#define SYNQUACER_I2C_BSR_BB\t\tBIT(7)\t\n\n#define SYNQUACER_I2C_BCR_INT\t\tBIT(0)\t\n#define SYNQUACER_I2C_BCR_INTE\t\tBIT(1)\t\n#define SYNQUACER_I2C_BCR_GCAA\t\tBIT(2)\t\n#define SYNQUACER_I2C_BCR_ACK\t\tBIT(3)\t\n#define SYNQUACER_I2C_BCR_MSS\t\tBIT(4)\t\n#define SYNQUACER_I2C_BCR_SCC\t\tBIT(5)\t\n#define SYNQUACER_I2C_BCR_BEIE\t\tBIT(6)\t\n#define SYNQUACER_I2C_BCR_BER\t\tBIT(7)\t\n\n#define SYNQUACER_I2C_CCR_CS_MASK\t(0x1f)\t\n#define SYNQUACER_I2C_CCR_EN\t\tBIT(5)\t\n#define SYNQUACER_I2C_CCR_FM\t\tBIT(6)\t\n\n#define SYNQUACER_I2C_CSR_CS_MASK\t(0x3f)\t\n\n#define SYNQUACER_I2C_BC2R_SCLL\t\tBIT(0)\t\n#define SYNQUACER_I2C_BC2R_SDAL\t\tBIT(1)\t\n#define SYNQUACER_I2C_BC2R_SCLS\t\tBIT(4)\t\n#define SYNQUACER_I2C_BC2R_SDAS\t\tBIT(5)\t\n\n \n#define SYNQUACER_I2C_BUS_CLK_FR(rate)\t(((rate) / 20000000) + 1)\n\n \n#define SYNQUACER_I2C_CLK_MASTER_STD(rate)\t\t\t\\\n\tDIV_ROUND_UP(DIV_ROUND_UP((rate), I2C_MAX_STANDARD_MODE_FREQ) - 2, 2)\n \n#define SYNQUACER_I2C_CLK_MASTER_FAST(rate)\t\t\t\\\n\tDIV_ROUND_UP((DIV_ROUND_UP((rate), I2C_MAX_FAST_MODE_FREQ) - 2) * 2, 3)\n\n \n \n#define SYNQUACER_I2C_CCR_CS_STD_MAX_18M(rate)\t\t\t\\\n\t   ((SYNQUACER_I2C_CLK_MASTER_STD(rate) - 65)\t\t\\\n\t\t\t\t\t& SYNQUACER_I2C_CCR_CS_MASK)\n\n \n#define SYNQUACER_I2C_CSR_CS_STD_MAX_18M(rate)\t\t0x00\n\n \n#define SYNQUACER_I2C_CCR_CS_FAST_MAX_18M(rate)\t\t\t\\\n\t   ((SYNQUACER_I2C_CLK_MASTER_FAST(rate) - 1)\t\t\\\n\t\t\t\t\t& SYNQUACER_I2C_CCR_CS_MASK)\n\n \n#define SYNQUACER_I2C_CSR_CS_FAST_MAX_18M(rate)\t\t0x00\n\n \n \n#define SYNQUACER_I2C_CCR_CS_STD_MIN_18M(rate)\t\t\t\\\n\t   ((SYNQUACER_I2C_CLK_MASTER_STD(rate) - 1)\t\t\\\n\t\t\t\t\t& SYNQUACER_I2C_CCR_CS_MASK)\n\n \n#define SYNQUACER_I2C_CSR_CS_STD_MIN_18M(rate)\t\t\t\\\n\t   (((SYNQUACER_I2C_CLK_MASTER_STD(rate) - 1) >> 5)\t\\\n\t\t\t\t\t& SYNQUACER_I2C_CSR_CS_MASK)\n\n \n#define SYNQUACER_I2C_CCR_CS_FAST_MIN_18M(rate)\t\t\t\\\n\t   ((SYNQUACER_I2C_CLK_MASTER_FAST(rate) - 1)\t\t\\\n\t\t\t\t\t& SYNQUACER_I2C_CCR_CS_MASK)\n\n \n#define SYNQUACER_I2C_CSR_CS_FAST_MIN_18M(rate)\t\t\t\\\n\t   (((SYNQUACER_I2C_CLK_MASTER_FAST(rate) - 1) >> 5)\t\\\n\t\t\t\t\t& SYNQUACER_I2C_CSR_CS_MASK)\n\n \n#define SYNQUACER_I2C_MIN_CLK_RATE\t(14 * 1000000)\n \n#define SYNQUACER_I2C_MAX_CLK_RATE\t(200 * 1000000)\n \n#define SYNQUACER_I2C_CLK_RATE_18M\t(18 * 1000000)\n\n#define SYNQUACER_I2C_SPEED_FM\t\t400\t\n#define SYNQUACER_I2C_SPEED_SM\t\t100\t\n\nenum i2c_state {\n\tSTATE_IDLE,\n\tSTATE_START,\n\tSTATE_READ,\n\tSTATE_WRITE\n};\n\nstruct synquacer_i2c {\n\tstruct completion\tcompletion;\n\n\tstruct i2c_msg\t\t*msg;\n\tu32\t\t\tmsg_num;\n\tu32\t\t\tmsg_idx;\n\tu32\t\t\tmsg_ptr;\n\n\tint\t\t\tirq;\n\tstruct device\t\t*dev;\n\tvoid __iomem\t\t*base;\n\tstruct clk\t\t*pclk;\n\tu32\t\t\tpclkrate;\n\tu32\t\t\tspeed_khz;\n\tu32\t\t\ttimeout_ms;\n\tenum i2c_state\t\tstate;\n\tstruct i2c_adapter\tadapter;\n};\n\nstatic inline int is_lastmsg(struct synquacer_i2c *i2c)\n{\n\treturn i2c->msg_idx >= (i2c->msg_num - 1);\n}\n\nstatic inline int is_msglast(struct synquacer_i2c *i2c)\n{\n\treturn i2c->msg_ptr == (i2c->msg->len - 1);\n}\n\nstatic inline int is_msgend(struct synquacer_i2c *i2c)\n{\n\treturn i2c->msg_ptr >= i2c->msg->len;\n}\n\nstatic inline unsigned long calc_timeout_ms(struct synquacer_i2c *i2c,\n\t\t\t\t\t    struct i2c_msg *msgs,\n\t\t\t\t\t    int num)\n{\n\tunsigned long bit_count = 0;\n\tint i;\n\n\tfor (i = 0; i < num; i++, msgs++)\n\t\tbit_count += msgs->len;\n\n\treturn DIV_ROUND_UP((bit_count * 9 + num * 10) * 3, 200) + 10;\n}\n\nstatic void synquacer_i2c_stop(struct synquacer_i2c *i2c, int ret)\n{\n\t \n\twriteb(0, i2c->base + SYNQUACER_I2C_REG_BCR);\n\n\ti2c->state = STATE_IDLE;\n\n\ti2c->msg_ptr = 0;\n\ti2c->msg = NULL;\n\ti2c->msg_idx++;\n\ti2c->msg_num = 0;\n\tif (ret)\n\t\ti2c->msg_idx = ret;\n\n\tcomplete(&i2c->completion);\n}\n\nstatic void synquacer_i2c_hw_init(struct synquacer_i2c *i2c)\n{\n\tunsigned char ccr_cs, csr_cs;\n\tu32 rt = i2c->pclkrate;\n\n\t \n\twriteb(0, i2c->base + SYNQUACER_I2C_REG_ADR);\n\n\t \n\twriteb(SYNQUACER_I2C_BUS_CLK_FR(i2c->pclkrate),\n\t       i2c->base + SYNQUACER_I2C_REG_FSR);\n\n\tswitch (i2c->speed_khz) {\n\tcase SYNQUACER_I2C_SPEED_FM:\n\t\tif (i2c->pclkrate <= SYNQUACER_I2C_CLK_RATE_18M) {\n\t\t\tccr_cs = SYNQUACER_I2C_CCR_CS_FAST_MAX_18M(rt);\n\t\t\tcsr_cs = SYNQUACER_I2C_CSR_CS_FAST_MAX_18M(rt);\n\t\t} else {\n\t\t\tccr_cs = SYNQUACER_I2C_CCR_CS_FAST_MIN_18M(rt);\n\t\t\tcsr_cs = SYNQUACER_I2C_CSR_CS_FAST_MIN_18M(rt);\n\t\t}\n\n\t\t \n\t\twriteb(ccr_cs | SYNQUACER_I2C_CCR_FM |\n\t\t       SYNQUACER_I2C_CCR_EN,\n\t\t       i2c->base + SYNQUACER_I2C_REG_CCR);\n\t\twriteb(csr_cs, i2c->base + SYNQUACER_I2C_REG_CSR);\n\t\tbreak;\n\tcase SYNQUACER_I2C_SPEED_SM:\n\t\tif (i2c->pclkrate <= SYNQUACER_I2C_CLK_RATE_18M) {\n\t\t\tccr_cs = SYNQUACER_I2C_CCR_CS_STD_MAX_18M(rt);\n\t\t\tcsr_cs = SYNQUACER_I2C_CSR_CS_STD_MAX_18M(rt);\n\t\t} else {\n\t\t\tccr_cs = SYNQUACER_I2C_CCR_CS_STD_MIN_18M(rt);\n\t\t\tcsr_cs = SYNQUACER_I2C_CSR_CS_STD_MIN_18M(rt);\n\t\t}\n\n\t\t \n\t\twriteb(ccr_cs | SYNQUACER_I2C_CCR_EN,\n\t\t      i2c->base + SYNQUACER_I2C_REG_CCR);\n\t\twriteb(csr_cs, i2c->base + SYNQUACER_I2C_REG_CSR);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t}\n\n\t \n\twriteb(0, i2c->base + SYNQUACER_I2C_REG_BCR);\n\twriteb(0, i2c->base + SYNQUACER_I2C_REG_BC2R);\n}\n\nstatic void synquacer_i2c_hw_reset(struct synquacer_i2c *i2c)\n{\n\t \n\twriteb(0, i2c->base + SYNQUACER_I2C_REG_CCR);\n\twriteb(0, i2c->base + SYNQUACER_I2C_REG_CSR);\n\n\tWAIT_PCLK(100, i2c->pclkrate);\n}\n\nstatic int synquacer_i2c_master_start(struct synquacer_i2c *i2c,\n\t\t\t\t      struct i2c_msg *pmsg)\n{\n\tunsigned char bsr, bcr;\n\n\twriteb(i2c_8bit_addr_from_msg(pmsg), i2c->base + SYNQUACER_I2C_REG_DAR);\n\n\tdev_dbg(i2c->dev, \"slave:0x%02x\\n\", pmsg->addr);\n\n\t \n\tbsr = readb(i2c->base + SYNQUACER_I2C_REG_BSR);\n\tbcr = readb(i2c->base + SYNQUACER_I2C_REG_BCR);\n\tdev_dbg(i2c->dev, \"bsr:0x%02x, bcr:0x%02x\\n\", bsr, bcr);\n\n\tif ((bsr & SYNQUACER_I2C_BSR_BB) &&\n\t    !(bcr & SYNQUACER_I2C_BCR_MSS)) {\n\t\tdev_dbg(i2c->dev, \"bus is busy\");\n\t\treturn -EBUSY;\n\t}\n\n\tif (bsr & SYNQUACER_I2C_BSR_BB) {  \n\t\tdev_dbg(i2c->dev, \"Continuous Start\");\n\t\twriteb(bcr | SYNQUACER_I2C_BCR_SCC,\n\t\t       i2c->base + SYNQUACER_I2C_REG_BCR);\n\t} else {\n\t\tif (bcr & SYNQUACER_I2C_BCR_MSS) {\n\t\t\tdev_dbg(i2c->dev, \"not in master mode\");\n\t\t\treturn -EAGAIN;\n\t\t}\n\t\tdev_dbg(i2c->dev, \"Start Condition\");\n\t\t \n\t\twriteb(bcr | SYNQUACER_I2C_BCR_MSS |\n\t\t       SYNQUACER_I2C_BCR_INTE | SYNQUACER_I2C_BCR_BEIE,\n\t\t       i2c->base + SYNQUACER_I2C_REG_BCR);\n\t}\n\n\tWAIT_PCLK(10, i2c->pclkrate);\n\n\t \n\tbsr = readb(i2c->base + SYNQUACER_I2C_REG_BSR);\n\tbcr = readb(i2c->base + SYNQUACER_I2C_REG_BCR);\n\tdev_dbg(i2c->dev, \"bsr:0x%02x, bcr:0x%02x\\n\", bsr, bcr);\n\n\tif ((bsr & SYNQUACER_I2C_BSR_AL) ||\n\t    !(bcr & SYNQUACER_I2C_BCR_MSS)) {\n\t\tdev_dbg(i2c->dev, \"arbitration lost\\n\");\n\t\treturn -EAGAIN;\n\t}\n\n\treturn 0;\n}\n\nstatic int synquacer_i2c_doxfer(struct synquacer_i2c *i2c,\n\t\t\t\tstruct i2c_msg *msgs, int num)\n{\n\tunsigned char bsr;\n\tunsigned long timeout;\n\tint ret;\n\n\tsynquacer_i2c_hw_init(i2c);\n\tbsr = readb(i2c->base + SYNQUACER_I2C_REG_BSR);\n\tif (bsr & SYNQUACER_I2C_BSR_BB) {\n\t\tdev_err(i2c->dev, \"cannot get bus (bus busy)\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\treinit_completion(&i2c->completion);\n\n\ti2c->msg = msgs;\n\ti2c->msg_num = num;\n\ti2c->msg_ptr = 0;\n\ti2c->msg_idx = 0;\n\ti2c->state = STATE_START;\n\n\tret = synquacer_i2c_master_start(i2c, i2c->msg);\n\tif (ret < 0) {\n\t\tdev_dbg(i2c->dev, \"Address failed: (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\ttimeout = wait_for_completion_timeout(&i2c->completion,\n\t\t\t\t\tmsecs_to_jiffies(i2c->timeout_ms));\n\tif (timeout == 0) {\n\t\tdev_dbg(i2c->dev, \"timeout\\n\");\n\t\treturn -EAGAIN;\n\t}\n\n\tret = i2c->msg_idx;\n\tif (ret != num) {\n\t\tdev_dbg(i2c->dev, \"incomplete xfer (%d)\\n\", ret);\n\t\treturn -EAGAIN;\n\t}\n\n\t \n\tudelay(DIV_ROUND_UP(2 * 1000, i2c->speed_khz));\n\n\treturn ret;\n}\n\nstatic irqreturn_t synquacer_i2c_isr(int irq, void *dev_id)\n{\n\tstruct synquacer_i2c *i2c = dev_id;\n\n\tunsigned char byte;\n\tunsigned char bsr, bcr;\n\tint ret;\n\n\tbcr = readb(i2c->base + SYNQUACER_I2C_REG_BCR);\n\tbsr = readb(i2c->base + SYNQUACER_I2C_REG_BSR);\n\tdev_dbg(i2c->dev, \"bsr:0x%02x, bcr:0x%02x\\n\", bsr, bcr);\n\n\tif (bcr & SYNQUACER_I2C_BCR_BER) {\n\t\tdev_err(i2c->dev, \"bus error\\n\");\n\t\tsynquacer_i2c_stop(i2c, -EAGAIN);\n\t\tgoto out;\n\t}\n\tif ((bsr & SYNQUACER_I2C_BSR_AL) ||\n\t    !(bcr & SYNQUACER_I2C_BCR_MSS)) {\n\t\tdev_dbg(i2c->dev, \"arbitration lost\\n\");\n\t\tsynquacer_i2c_stop(i2c, -EAGAIN);\n\t\tgoto out;\n\t}\n\n\tswitch (i2c->state) {\n\tcase STATE_START:\n\t\tif (bsr & SYNQUACER_I2C_BSR_LRB) {\n\t\t\tdev_dbg(i2c->dev, \"ack was not received\\n\");\n\t\t\tsynquacer_i2c_stop(i2c, -EAGAIN);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (i2c->msg->flags & I2C_M_RD)\n\t\t\ti2c->state = STATE_READ;\n\t\telse\n\t\t\ti2c->state = STATE_WRITE;\n\n\t\tif (is_lastmsg(i2c) && i2c->msg->len == 0) {\n\t\t\tsynquacer_i2c_stop(i2c, 0);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (i2c->state == STATE_READ)\n\t\t\tgoto prepare_read;\n\t\tfallthrough;\n\n\tcase STATE_WRITE:\n\t\tif (bsr & SYNQUACER_I2C_BSR_LRB) {\n\t\t\tdev_dbg(i2c->dev, \"WRITE: No Ack\\n\");\n\t\t\tsynquacer_i2c_stop(i2c, -EAGAIN);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!is_msgend(i2c)) {\n\t\t\twriteb(i2c->msg->buf[i2c->msg_ptr++],\n\t\t\t       i2c->base + SYNQUACER_I2C_REG_DAR);\n\n\t\t\t \n\t\t\twriteb(SYNQUACER_I2C_BCR_BEIE |\n\t\t\t       SYNQUACER_I2C_BCR_MSS |\n\t\t\t       SYNQUACER_I2C_BCR_INTE,\n\t\t\t       i2c->base + SYNQUACER_I2C_REG_BCR);\n\t\t\tbreak;\n\t\t}\n\t\tif (is_lastmsg(i2c)) {\n\t\t\tsynquacer_i2c_stop(i2c, 0);\n\t\t\tbreak;\n\t\t}\n\t\tdev_dbg(i2c->dev, \"WRITE: Next Message\\n\");\n\n\t\ti2c->msg_ptr = 0;\n\t\ti2c->msg_idx++;\n\t\ti2c->msg++;\n\n\t\t \n\t\tret = synquacer_i2c_master_start(i2c, i2c->msg);\n\t\tif (ret < 0) {\n\t\t\tdev_dbg(i2c->dev, \"restart error (%d)\\n\", ret);\n\t\t\tsynquacer_i2c_stop(i2c, -EAGAIN);\n\t\t\tbreak;\n\t\t}\n\t\ti2c->state = STATE_START;\n\t\tbreak;\n\n\tcase STATE_READ:\n\t\tbyte = readb(i2c->base + SYNQUACER_I2C_REG_DAR);\n\t\tif (!(bsr & SYNQUACER_I2C_BSR_FBT))  \n\t\t\ti2c->msg->buf[i2c->msg_ptr++] = byte;\n\t\telse  \n\t\t\tdev_dbg(i2c->dev, \"address:0x%02x. ignore it.\\n\", byte);\n\nprepare_read:\n\t\tif (is_msglast(i2c)) {\n\t\t\twriteb(SYNQUACER_I2C_BCR_MSS |\n\t\t\t       SYNQUACER_I2C_BCR_BEIE |\n\t\t\t       SYNQUACER_I2C_BCR_INTE,\n\t\t\t       i2c->base + SYNQUACER_I2C_REG_BCR);\n\t\t\tbreak;\n\t\t}\n\t\tif (!is_msgend(i2c)) {\n\t\t\twriteb(SYNQUACER_I2C_BCR_MSS |\n\t\t\t       SYNQUACER_I2C_BCR_BEIE |\n\t\t\t       SYNQUACER_I2C_BCR_INTE |\n\t\t\t       SYNQUACER_I2C_BCR_ACK,\n\t\t\t       i2c->base + SYNQUACER_I2C_REG_BCR);\n\t\t\tbreak;\n\t\t}\n\t\tif (is_lastmsg(i2c)) {\n\t\t\t \n\t\t\tdev_dbg(i2c->dev, \"READ: Send Stop\\n\");\n\t\t\tsynquacer_i2c_stop(i2c, 0);\n\t\t\tbreak;\n\t\t}\n\t\tdev_dbg(i2c->dev, \"READ: Next Transfer\\n\");\n\n\t\ti2c->msg_ptr = 0;\n\t\ti2c->msg_idx++;\n\t\ti2c->msg++;\n\n\t\tret = synquacer_i2c_master_start(i2c, i2c->msg);\n\t\tif (ret < 0) {\n\t\t\tdev_dbg(i2c->dev, \"restart error (%d)\\n\", ret);\n\t\t\tsynquacer_i2c_stop(i2c, -EAGAIN);\n\t\t} else {\n\t\t\ti2c->state = STATE_START;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tdev_err(i2c->dev, \"called in err STATE (%d)\\n\", i2c->state);\n\t\tbreak;\n\t}\n\nout:\n\tWAIT_PCLK(10, i2c->pclkrate);\n\treturn IRQ_HANDLED;\n}\n\nstatic int synquacer_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs,\n\t\t\t      int num)\n{\n\tstruct synquacer_i2c *i2c;\n\tint retry;\n\tint ret;\n\n\ti2c = i2c_get_adapdata(adap);\n\ti2c->timeout_ms = calc_timeout_ms(i2c, msgs, num);\n\n\tdev_dbg(i2c->dev, \"calculated timeout %d ms\\n\", i2c->timeout_ms);\n\n\tfor (retry = 0; retry <= adap->retries; retry++) {\n\t\tret = synquacer_i2c_doxfer(i2c, msgs, num);\n\t\tif (ret != -EAGAIN)\n\t\t\treturn ret;\n\n\t\tdev_dbg(i2c->dev, \"Retrying transmission (%d)\\n\", retry);\n\n\t\tsynquacer_i2c_hw_reset(i2c);\n\t}\n\treturn -EIO;\n}\n\nstatic u32 synquacer_i2c_functionality(struct i2c_adapter *adap)\n{\n\treturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;\n}\n\nstatic const struct i2c_algorithm synquacer_i2c_algo = {\n\t.master_xfer\t= synquacer_i2c_xfer,\n\t.functionality\t= synquacer_i2c_functionality,\n};\n\nstatic const struct i2c_adapter synquacer_i2c_ops = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"synquacer_i2c-adapter\",\n\t.algo\t\t= &synquacer_i2c_algo,\n\t.retries\t= 5,\n};\n\nstatic int synquacer_i2c_probe(struct platform_device *pdev)\n{\n\tstruct synquacer_i2c *i2c;\n\tu32 bus_speed;\n\tint ret;\n\n\ti2c = devm_kzalloc(&pdev->dev, sizeof(*i2c), GFP_KERNEL);\n\tif (!i2c)\n\t\treturn -ENOMEM;\n\n\tbus_speed = i2c_acpi_find_bus_speed(&pdev->dev);\n\tif (!bus_speed)\n\t\tdevice_property_read_u32(&pdev->dev, \"clock-frequency\",\n\t\t\t\t\t &bus_speed);\n\n\tdevice_property_read_u32(&pdev->dev, \"socionext,pclk-rate\",\n\t\t\t\t &i2c->pclkrate);\n\n\ti2c->pclk = devm_clk_get(&pdev->dev, \"pclk\");\n\tif (PTR_ERR(i2c->pclk) == -EPROBE_DEFER)\n\t\treturn -EPROBE_DEFER;\n\tif (!IS_ERR_OR_NULL(i2c->pclk)) {\n\t\tdev_dbg(&pdev->dev, \"clock source %p\\n\", i2c->pclk);\n\n\t\tret = clk_prepare_enable(i2c->pclk);\n\t\tif (ret)\n\t\t\treturn dev_err_probe(&pdev->dev, ret, \"failed to enable clock\\n\");\n\t\ti2c->pclkrate = clk_get_rate(i2c->pclk);\n\t}\n\n\tif (i2c->pclkrate < SYNQUACER_I2C_MIN_CLK_RATE ||\n\t    i2c->pclkrate > SYNQUACER_I2C_MAX_CLK_RATE)\n\t\treturn dev_err_probe(&pdev->dev, -EINVAL,\n\t\t\t\t     \"PCLK missing or out of range (%d)\\n\",\n\t\t\t\t     i2c->pclkrate);\n\n\ti2c->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(i2c->base))\n\t\treturn PTR_ERR(i2c->base);\n\n\ti2c->irq = platform_get_irq(pdev, 0);\n\tif (i2c->irq < 0)\n\t\treturn i2c->irq;\n\n\tret = devm_request_irq(&pdev->dev, i2c->irq, synquacer_i2c_isr,\n\t\t\t       0, dev_name(&pdev->dev), i2c);\n\tif (ret < 0)\n\t\treturn dev_err_probe(&pdev->dev, ret, \"cannot claim IRQ %d\\n\", i2c->irq);\n\n\ti2c->state = STATE_IDLE;\n\ti2c->dev = &pdev->dev;\n\ti2c->adapter = synquacer_i2c_ops;\n\ti2c_set_adapdata(&i2c->adapter, i2c);\n\ti2c->adapter.dev.parent = &pdev->dev;\n\ti2c->adapter.dev.of_node = pdev->dev.of_node;\n\tACPI_COMPANION_SET(&i2c->adapter.dev, ACPI_COMPANION(&pdev->dev));\n\ti2c->adapter.nr = pdev->id;\n\tinit_completion(&i2c->completion);\n\n\tif (bus_speed < I2C_MAX_FAST_MODE_FREQ)\n\t\ti2c->speed_khz = SYNQUACER_I2C_SPEED_SM;\n\telse\n\t\ti2c->speed_khz = SYNQUACER_I2C_SPEED_FM;\n\n\tsynquacer_i2c_hw_init(i2c);\n\n\tret = i2c_add_numbered_adapter(&i2c->adapter);\n\tif (ret)\n\t\treturn dev_err_probe(&pdev->dev, ret, \"failed to add bus to i2c core\\n\");\n\n\tplatform_set_drvdata(pdev, i2c);\n\n\tdev_info(&pdev->dev, \"%s: synquacer_i2c adapter\\n\",\n\t\t dev_name(&i2c->adapter.dev));\n\n\treturn 0;\n}\n\nstatic void synquacer_i2c_remove(struct platform_device *pdev)\n{\n\tstruct synquacer_i2c *i2c = platform_get_drvdata(pdev);\n\n\ti2c_del_adapter(&i2c->adapter);\n\tif (!IS_ERR(i2c->pclk))\n\t\tclk_disable_unprepare(i2c->pclk);\n};\n\nstatic const struct of_device_id synquacer_i2c_dt_ids[] __maybe_unused = {\n\t{ .compatible = \"socionext,synquacer-i2c\" },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, synquacer_i2c_dt_ids);\n\n#ifdef CONFIG_ACPI\nstatic const struct acpi_device_id synquacer_i2c_acpi_ids[] = {\n\t{ \"SCX0003\" },\n\t{   }\n};\nMODULE_DEVICE_TABLE(acpi, synquacer_i2c_acpi_ids);\n#endif\n\nstatic struct platform_driver synquacer_i2c_driver = {\n\t.probe\t= synquacer_i2c_probe,\n\t.remove_new = synquacer_i2c_remove,\n\t.driver\t= {\n\t\t.name = \"synquacer_i2c\",\n\t\t.of_match_table = of_match_ptr(synquacer_i2c_dt_ids),\n\t\t.acpi_match_table = ACPI_PTR(synquacer_i2c_acpi_ids),\n\t},\n};\nmodule_platform_driver(synquacer_i2c_driver);\n\nMODULE_AUTHOR(\"Fujitsu Semiconductor Ltd\");\nMODULE_DESCRIPTION(\"Socionext SynQuacer I2C Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}