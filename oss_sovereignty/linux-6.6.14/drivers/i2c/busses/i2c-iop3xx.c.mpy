{
  "module_name": "i2c-iop3xx.c",
  "hash_id": "f2917c9a3d72ce3e07821003e6bdf4cdf6724aa99434dd4bb6885e20a9b86176",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-iop3xx.c",
  "human_readable_source": "\n \n \n \n \n\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/platform_device.h>\n#include <linux/i2c.h>\n#include <linux/io.h>\n#include <linux/gpio/consumer.h>\n\n#include \"i2c-iop3xx.h\"\n\n \nstatic int i2c_id;\n\nstatic inline unsigned char\niic_cook_addr(struct i2c_msg *msg)\n{\n\tunsigned char addr;\n\n\taddr = i2c_8bit_addr_from_msg(msg);\n\n\treturn addr;\n}\n\nstatic void\niop3xx_i2c_reset(struct i2c_algo_iop3xx_data *iop3xx_adap)\n{\n\t \n\t__raw_writel(IOP3XX_ICR_UNIT_RESET, iop3xx_adap->ioaddr + CR_OFFSET);\n\t__raw_writel(IOP3XX_ISR_CLEARBITS, iop3xx_adap->ioaddr + SR_OFFSET);\n\t__raw_writel(0, iop3xx_adap->ioaddr + CR_OFFSET);\n}\n\nstatic void\niop3xx_i2c_enable(struct i2c_algo_iop3xx_data *iop3xx_adap)\n{\n\tu32 cr = IOP3XX_ICR_GCD | IOP3XX_ICR_SCLEN | IOP3XX_ICR_UE;\n\n\t \n\tif (iop3xx_adap->gpio_scl)\n\t\tgpiod_set_raw_value(iop3xx_adap->gpio_scl, 0);\n\tif (iop3xx_adap->gpio_sda)\n\t\tgpiod_set_raw_value(iop3xx_adap->gpio_sda, 0);\n\n\t \n\tiop3xx_adap->SR_enabled =\n\t\tIOP3XX_ISR_ALD | IOP3XX_ISR_BERRD |\n\t\tIOP3XX_ISR_RXFULL | IOP3XX_ISR_TXEMPTY;\n\n\tcr |= IOP3XX_ICR_ALD_IE | IOP3XX_ICR_BERR_IE |\n\t\tIOP3XX_ICR_RXFULL_IE | IOP3XX_ICR_TXEMPTY_IE;\n\n\t__raw_writel(cr, iop3xx_adap->ioaddr + CR_OFFSET);\n}\n\nstatic void\niop3xx_i2c_transaction_cleanup(struct i2c_algo_iop3xx_data *iop3xx_adap)\n{\n\tunsigned long cr = __raw_readl(iop3xx_adap->ioaddr + CR_OFFSET);\n\n\tcr &= ~(IOP3XX_ICR_MSTART | IOP3XX_ICR_TBYTE |\n\t\tIOP3XX_ICR_MSTOP | IOP3XX_ICR_SCLEN);\n\n\t__raw_writel(cr, iop3xx_adap->ioaddr + CR_OFFSET);\n}\n\n \nstatic irqreturn_t\niop3xx_i2c_irq_handler(int this_irq, void *dev_id)\n{\n\tstruct i2c_algo_iop3xx_data *iop3xx_adap = dev_id;\n\tu32 sr = __raw_readl(iop3xx_adap->ioaddr + SR_OFFSET);\n\n\tif ((sr &= iop3xx_adap->SR_enabled)) {\n\t\t__raw_writel(sr, iop3xx_adap->ioaddr + SR_OFFSET);\n\t\tiop3xx_adap->SR_received |= sr;\n\t\twake_up_interruptible(&iop3xx_adap->waitq);\n\t}\n\treturn IRQ_HANDLED;\n}\n\n \nstatic int\niop3xx_i2c_error(u32 sr)\n{\n\tint rc = 0;\n\n\tif ((sr & IOP3XX_ISR_BERRD)) {\n\t\tif (!rc)\n\t\t\trc = -I2C_ERR_BERR;\n\t}\n\tif ((sr & IOP3XX_ISR_ALD)) {\n\t\tif (!rc)\n\t\t\trc = -I2C_ERR_ALD;\n\t}\n\treturn rc;\n}\n\nstatic inline u32\niop3xx_i2c_get_srstat(struct i2c_algo_iop3xx_data *iop3xx_adap)\n{\n\tunsigned long flags;\n\tu32 sr;\n\n\tspin_lock_irqsave(&iop3xx_adap->lock, flags);\n\tsr = iop3xx_adap->SR_received;\n\tiop3xx_adap->SR_received = 0;\n\tspin_unlock_irqrestore(&iop3xx_adap->lock, flags);\n\n\treturn sr;\n}\n\n \ntypedef int (*compare_func)(unsigned test, unsigned mask);\n \n\nstatic int\niop3xx_i2c_wait_event(struct i2c_algo_iop3xx_data *iop3xx_adap,\n\t\t\t  unsigned flags, unsigned *status,\n\t\t\t  compare_func compare)\n{\n\tunsigned sr = 0;\n\tint interrupted;\n\tint done;\n\tint rc = 0;\n\n\tdo {\n\t\tinterrupted = wait_event_interruptible_timeout (\n\t\t\tiop3xx_adap->waitq,\n\t\t\t(done = compare(sr = iop3xx_i2c_get_srstat(iop3xx_adap), flags)),\n\t\t\t1 * HZ\n\t\t\t);\n\t\tif ((rc = iop3xx_i2c_error(sr)) < 0) {\n\t\t\t*status = sr;\n\t\t\treturn rc;\n\t\t} else if (!interrupted) {\n\t\t\t*status = sr;\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t} while (!done);\n\n\t*status = sr;\n\n\treturn 0;\n}\n\n \nstatic int\nall_bits_clear(unsigned test, unsigned mask)\n{\n\treturn (test & mask) == 0;\n}\n\nstatic int\nany_bits_set(unsigned test, unsigned mask)\n{\n\treturn (test & mask) != 0;\n}\n\nstatic int\niop3xx_i2c_wait_tx_done(struct i2c_algo_iop3xx_data *iop3xx_adap, int *status)\n{\n\treturn iop3xx_i2c_wait_event(\n\t\tiop3xx_adap,\n\t\tIOP3XX_ISR_TXEMPTY | IOP3XX_ISR_ALD | IOP3XX_ISR_BERRD,\n\t\tstatus, any_bits_set);\n}\n\nstatic int\niop3xx_i2c_wait_rx_done(struct i2c_algo_iop3xx_data *iop3xx_adap, int *status)\n{\n\treturn iop3xx_i2c_wait_event(\n\t\tiop3xx_adap,\n\t\tIOP3XX_ISR_RXFULL | IOP3XX_ISR_ALD | IOP3XX_ISR_BERRD,\n\t\tstatus,\tany_bits_set);\n}\n\nstatic int\niop3xx_i2c_wait_idle(struct i2c_algo_iop3xx_data *iop3xx_adap, int *status)\n{\n\treturn iop3xx_i2c_wait_event(\n\t\tiop3xx_adap, IOP3XX_ISR_UNITBUSY, status, all_bits_clear);\n}\n\nstatic int\niop3xx_i2c_send_target_addr(struct i2c_algo_iop3xx_data *iop3xx_adap,\n\t\t\t\tstruct i2c_msg *msg)\n{\n\tunsigned long cr = __raw_readl(iop3xx_adap->ioaddr + CR_OFFSET);\n\tint status;\n\tint rc;\n\n\t \n\tif (msg->addr == MYSAR) {\n\t\treturn -EBUSY;\n\t}\n\n\t__raw_writel(iic_cook_addr(msg), iop3xx_adap->ioaddr + DBR_OFFSET);\n\n\tcr &= ~(IOP3XX_ICR_MSTOP | IOP3XX_ICR_NACK);\n\tcr |= IOP3XX_ICR_MSTART | IOP3XX_ICR_TBYTE;\n\n\t__raw_writel(cr, iop3xx_adap->ioaddr + CR_OFFSET);\n\trc = iop3xx_i2c_wait_tx_done(iop3xx_adap, &status);\n\n\treturn rc;\n}\n\nstatic int\niop3xx_i2c_write_byte(struct i2c_algo_iop3xx_data *iop3xx_adap, char byte,\n\t\t\t\tint stop)\n{\n\tunsigned long cr = __raw_readl(iop3xx_adap->ioaddr + CR_OFFSET);\n\tint status;\n\tint rc = 0;\n\n\t__raw_writel(byte, iop3xx_adap->ioaddr + DBR_OFFSET);\n\tcr &= ~IOP3XX_ICR_MSTART;\n\tif (stop) {\n\t\tcr |= IOP3XX_ICR_MSTOP;\n\t} else {\n\t\tcr &= ~IOP3XX_ICR_MSTOP;\n\t}\n\tcr |= IOP3XX_ICR_TBYTE;\n\t__raw_writel(cr, iop3xx_adap->ioaddr + CR_OFFSET);\n\trc = iop3xx_i2c_wait_tx_done(iop3xx_adap, &status);\n\n\treturn rc;\n}\n\nstatic int\niop3xx_i2c_read_byte(struct i2c_algo_iop3xx_data *iop3xx_adap, char *byte,\n\t\t\t\tint stop)\n{\n\tunsigned long cr = __raw_readl(iop3xx_adap->ioaddr + CR_OFFSET);\n\tint status;\n\tint rc = 0;\n\n\tcr &= ~IOP3XX_ICR_MSTART;\n\n\tif (stop) {\n\t\tcr |= IOP3XX_ICR_MSTOP | IOP3XX_ICR_NACK;\n\t} else {\n\t\tcr &= ~(IOP3XX_ICR_MSTOP | IOP3XX_ICR_NACK);\n\t}\n\tcr |= IOP3XX_ICR_TBYTE;\n\t__raw_writel(cr, iop3xx_adap->ioaddr + CR_OFFSET);\n\n\trc = iop3xx_i2c_wait_rx_done(iop3xx_adap, &status);\n\n\t*byte = __raw_readl(iop3xx_adap->ioaddr + DBR_OFFSET);\n\n\treturn rc;\n}\n\nstatic int\niop3xx_i2c_writebytes(struct i2c_adapter *i2c_adap, const char *buf, int count)\n{\n\tstruct i2c_algo_iop3xx_data *iop3xx_adap = i2c_adap->algo_data;\n\tint ii;\n\tint rc = 0;\n\n\tfor (ii = 0; rc == 0 && ii != count; ++ii)\n\t\trc = iop3xx_i2c_write_byte(iop3xx_adap, buf[ii], ii == count-1);\n\treturn rc;\n}\n\nstatic int\niop3xx_i2c_readbytes(struct i2c_adapter *i2c_adap, char *buf, int count)\n{\n\tstruct i2c_algo_iop3xx_data *iop3xx_adap = i2c_adap->algo_data;\n\tint ii;\n\tint rc = 0;\n\n\tfor (ii = 0; rc == 0 && ii != count; ++ii)\n\t\trc = iop3xx_i2c_read_byte(iop3xx_adap, &buf[ii], ii == count-1);\n\n\treturn rc;\n}\n\n \nstatic int\niop3xx_i2c_handle_msg(struct i2c_adapter *i2c_adap, struct i2c_msg *pmsg)\n{\n\tstruct i2c_algo_iop3xx_data *iop3xx_adap = i2c_adap->algo_data;\n\tint rc;\n\n\trc = iop3xx_i2c_send_target_addr(iop3xx_adap, pmsg);\n\tif (rc < 0) {\n\t\treturn rc;\n\t}\n\n\tif ((pmsg->flags&I2C_M_RD)) {\n\t\treturn iop3xx_i2c_readbytes(i2c_adap, pmsg->buf, pmsg->len);\n\t} else {\n\t\treturn iop3xx_i2c_writebytes(i2c_adap, pmsg->buf, pmsg->len);\n\t}\n}\n\n \nstatic int\niop3xx_i2c_master_xfer(struct i2c_adapter *i2c_adap, struct i2c_msg *msgs,\n\t\t\t\tint num)\n{\n\tstruct i2c_algo_iop3xx_data *iop3xx_adap = i2c_adap->algo_data;\n\tint im = 0;\n\tint ret = 0;\n\tint status;\n\n\tiop3xx_i2c_wait_idle(iop3xx_adap, &status);\n\tiop3xx_i2c_reset(iop3xx_adap);\n\tiop3xx_i2c_enable(iop3xx_adap);\n\n\tfor (im = 0; ret == 0 && im != num; im++) {\n\t\tret = iop3xx_i2c_handle_msg(i2c_adap, &msgs[im]);\n\t}\n\n\tiop3xx_i2c_transaction_cleanup(iop3xx_adap);\n\n\tif (ret)\n\t\treturn ret;\n\n\treturn im;\n}\n\nstatic u32\niop3xx_i2c_func(struct i2c_adapter *adap)\n{\n\treturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;\n}\n\nstatic const struct i2c_algorithm iop3xx_i2c_algo = {\n\t.master_xfer\t= iop3xx_i2c_master_xfer,\n\t.functionality\t= iop3xx_i2c_func,\n};\n\nstatic void\niop3xx_i2c_remove(struct platform_device *pdev)\n{\n\tstruct i2c_adapter *padapter = platform_get_drvdata(pdev);\n\tstruct i2c_algo_iop3xx_data *adapter_data =\n\t\t(struct i2c_algo_iop3xx_data *)padapter->algo_data;\n\tstruct resource *res = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tunsigned long cr = __raw_readl(adapter_data->ioaddr + CR_OFFSET);\n\n\t \n\tcr &= ~(IOP3XX_ICR_ALD_IE | IOP3XX_ICR_BERR_IE |\n\t\tIOP3XX_ICR_RXFULL_IE | IOP3XX_ICR_TXEMPTY_IE);\n\t__raw_writel(cr, adapter_data->ioaddr + CR_OFFSET);\n\n\tiounmap(adapter_data->ioaddr);\n\trelease_mem_region(res->start, IOP3XX_I2C_IO_SIZE);\n\tkfree(adapter_data);\n\tkfree(padapter);\n}\n\nstatic int\niop3xx_i2c_probe(struct platform_device *pdev)\n{\n\tstruct resource *res;\n\tint ret, irq;\n\tstruct i2c_adapter *new_adapter;\n\tstruct i2c_algo_iop3xx_data *adapter_data;\n\n\tnew_adapter = kzalloc(sizeof(struct i2c_adapter), GFP_KERNEL);\n\tif (!new_adapter) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tadapter_data = kzalloc(sizeof(struct i2c_algo_iop3xx_data), GFP_KERNEL);\n\tif (!adapter_data) {\n\t\tret = -ENOMEM;\n\t\tgoto free_adapter;\n\t}\n\n\tadapter_data->gpio_scl = devm_gpiod_get_optional(&pdev->dev,\n\t\t\t\t\t\t\t \"scl\",\n\t\t\t\t\t\t\t GPIOD_ASIS);\n\tif (IS_ERR(adapter_data->gpio_scl)) {\n\t\tret = PTR_ERR(adapter_data->gpio_scl);\n\t\tgoto free_both;\n\t}\n\tadapter_data->gpio_sda = devm_gpiod_get_optional(&pdev->dev,\n\t\t\t\t\t\t\t \"sda\",\n\t\t\t\t\t\t\t GPIOD_ASIS);\n\tif (IS_ERR(adapter_data->gpio_sda)) {\n\t\tret = PTR_ERR(adapter_data->gpio_sda);\n\t\tgoto free_both;\n\t}\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res) {\n\t\tret = -ENODEV;\n\t\tgoto free_both;\n\t}\n\n\tif (!request_mem_region(res->start, IOP3XX_I2C_IO_SIZE, pdev->name)) {\n\t\tret = -EBUSY;\n\t\tgoto free_both;\n\t}\n\n\t \n\tadapter_data->id = i2c_id++;\n\n\tadapter_data->ioaddr = ioremap(res->start, IOP3XX_I2C_IO_SIZE);\n\tif (!adapter_data->ioaddr) {\n\t\tret = -ENOMEM;\n\t\tgoto release_region;\n\t}\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0) {\n\t\tret = irq;\n\t\tgoto unmap;\n\t}\n\tret = request_irq(irq, iop3xx_i2c_irq_handler, 0,\n\t\t\t\tpdev->name, adapter_data);\n\n\tif (ret)\n\t\tgoto unmap;\n\n\tmemcpy(new_adapter->name, pdev->name, strlen(pdev->name));\n\tnew_adapter->owner = THIS_MODULE;\n\tnew_adapter->class = I2C_CLASS_HWMON | I2C_CLASS_SPD;\n\tnew_adapter->dev.parent = &pdev->dev;\n\tnew_adapter->dev.of_node = pdev->dev.of_node;\n\tnew_adapter->nr = pdev->id;\n\n\t \n\tnew_adapter->timeout = HZ;\n\tnew_adapter->algo = &iop3xx_i2c_algo;\n\n\tinit_waitqueue_head(&adapter_data->waitq);\n\tspin_lock_init(&adapter_data->lock);\n\n\tiop3xx_i2c_reset(adapter_data);\n\tiop3xx_i2c_enable(adapter_data);\n\n\tplatform_set_drvdata(pdev, new_adapter);\n\tnew_adapter->algo_data = adapter_data;\n\n\ti2c_add_numbered_adapter(new_adapter);\n\n\treturn 0;\n\nunmap:\n\tiounmap(adapter_data->ioaddr);\n\nrelease_region:\n\trelease_mem_region(res->start, IOP3XX_I2C_IO_SIZE);\n\nfree_both:\n\tkfree(adapter_data);\n\nfree_adapter:\n\tkfree(new_adapter);\n\nout:\n\treturn ret;\n}\n\nstatic const struct of_device_id i2c_iop3xx_match[] = {\n\t{ .compatible = \"intel,iop3xx-i2c\", },\n\t{ .compatible = \"intel,ixp4xx-i2c\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, i2c_iop3xx_match);\n\nstatic struct platform_driver iop3xx_i2c_driver = {\n\t.probe\t\t= iop3xx_i2c_probe,\n\t.remove_new\t= iop3xx_i2c_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"IOP3xx-I2C\",\n\t\t.of_match_table = i2c_iop3xx_match,\n\t},\n};\n\nmodule_platform_driver(iop3xx_i2c_driver);\n\nMODULE_AUTHOR(\"D-TACQ Solutions Ltd <www.d-tacq.com>\");\nMODULE_DESCRIPTION(\"IOP3xx iic algorithm and driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:IOP3xx-I2C\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}