{
  "module_name": "i2c-tegra-bpmp.c",
  "hash_id": "38e7059fbb175024f3d333f7445988ee34af97f08d2bf651aa741c962daf2089",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-tegra-bpmp.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/i2c.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n\n#include <soc/tegra/bpmp-abi.h>\n#include <soc/tegra/bpmp.h>\n\n \n#define SERIALI2C_HDR_SIZE 6\n\nstruct tegra_bpmp_i2c {\n\tstruct i2c_adapter adapter;\n\tstruct device *dev;\n\n\tstruct tegra_bpmp *bpmp;\n\tunsigned int bus;\n};\n\n \nstatic void tegra_bpmp_xlate_flags(u16 flags, u16 *out)\n{\n\tif (flags & I2C_M_TEN)\n\t\t*out |= SERIALI2C_TEN;\n\n\tif (flags & I2C_M_RD)\n\t\t*out |= SERIALI2C_RD;\n\n\tif (flags & I2C_M_STOP)\n\t\t*out |= SERIALI2C_STOP;\n\n\tif (flags & I2C_M_NOSTART)\n\t\t*out |= SERIALI2C_NOSTART;\n\n\tif (flags & I2C_M_REV_DIR_ADDR)\n\t\t*out |= SERIALI2C_REV_DIR_ADDR;\n\n\tif (flags & I2C_M_IGNORE_NAK)\n\t\t*out |= SERIALI2C_IGNORE_NAK;\n\n\tif (flags & I2C_M_NO_RD_ACK)\n\t\t*out |= SERIALI2C_NO_RD_ACK;\n\n\tif (flags & I2C_M_RECV_LEN)\n\t\t*out |= SERIALI2C_RECV_LEN;\n}\n\n \nstatic void tegra_bpmp_serialize_i2c_msg(struct tegra_bpmp_i2c *i2c,\n\t\t\t\t\tstruct mrq_i2c_request *request,\n\t\t\t\t\tstruct i2c_msg *msgs,\n\t\t\t\t\tunsigned int num)\n{\n\tchar *buf = request->xfer.data_buf;\n\tunsigned int i, j, pos = 0;\n\n\tfor (i = 0; i < num; i++) {\n\t\tstruct i2c_msg *msg = &msgs[i];\n\t\tu16 flags = 0;\n\n\t\ttegra_bpmp_xlate_flags(msg->flags, &flags);\n\n\t\tbuf[pos++] = msg->addr & 0xff;\n\t\tbuf[pos++] = (msg->addr & 0xff00) >> 8;\n\t\tbuf[pos++] = flags & 0xff;\n\t\tbuf[pos++] = (flags & 0xff00) >> 8;\n\t\tbuf[pos++] = msg->len & 0xff;\n\t\tbuf[pos++] = (msg->len & 0xff00) >> 8;\n\n\t\tif ((flags & SERIALI2C_RD) == 0) {\n\t\t\tfor (j = 0; j < msg->len; j++)\n\t\t\t\tbuf[pos++] = msg->buf[j];\n\t\t}\n\t}\n\n\trequest->xfer.data_size = pos;\n}\n\n \nstatic int tegra_bpmp_i2c_deserialize(struct tegra_bpmp_i2c *i2c,\n\t\t\t\t      struct mrq_i2c_response *response,\n\t\t\t\t      struct i2c_msg *msgs,\n\t\t\t\t      unsigned int num)\n{\n\tsize_t size = response->xfer.data_size, len = 0, pos = 0;\n\tchar *buf = response->xfer.data_buf;\n\tunsigned int i;\n\n\tfor (i = 0; i < num; i++)\n\t\tif (msgs[i].flags & I2C_M_RD)\n\t\t\tlen += msgs[i].len;\n\n\tif (len != size)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < num; i++) {\n\t\tif (msgs[i].flags & I2C_M_RD) {\n\t\t\tmemcpy(msgs[i].buf, buf + pos, msgs[i].len);\n\t\t\tpos += msgs[i].len;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int tegra_bpmp_i2c_msg_len_check(struct i2c_msg *msgs, unsigned int num)\n{\n\tsize_t tx_len = 0, rx_len = 0;\n\tunsigned int i;\n\n\tfor (i = 0; i < num; i++)\n\t\tif (!(msgs[i].flags & I2C_M_RD))\n\t\t\ttx_len += SERIALI2C_HDR_SIZE + msgs[i].len;\n\n\tif (tx_len > TEGRA_I2C_IPC_MAX_IN_BUF_SIZE)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < num; i++)\n\t\tif ((msgs[i].flags & I2C_M_RD))\n\t\t\trx_len += msgs[i].len;\n\n\tif (rx_len > TEGRA_I2C_IPC_MAX_OUT_BUF_SIZE)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int tegra_bpmp_i2c_msg_xfer(struct tegra_bpmp_i2c *i2c,\n\t\t\t\t   struct mrq_i2c_request *request,\n\t\t\t\t   struct mrq_i2c_response *response,\n\t\t\t\t   bool atomic)\n{\n\tstruct tegra_bpmp_message msg;\n\tint err;\n\n\trequest->cmd = CMD_I2C_XFER;\n\trequest->xfer.bus_id = i2c->bus;\n\n\tmemset(&msg, 0, sizeof(msg));\n\tmsg.mrq = MRQ_I2C;\n\tmsg.tx.data = request;\n\tmsg.tx.size = sizeof(*request);\n\tmsg.rx.data = response;\n\tmsg.rx.size = sizeof(*response);\n\n\tif (atomic)\n\t\terr = tegra_bpmp_transfer_atomic(i2c->bpmp, &msg);\n\telse\n\t\terr = tegra_bpmp_transfer(i2c->bpmp, &msg);\n\n\tif (err < 0) {\n\t\tdev_err(i2c->dev, \"failed to transfer message: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tif (msg.rx.ret != 0) {\n\t\tif (msg.rx.ret == -BPMP_EAGAIN) {\n\t\t\tdev_dbg(i2c->dev, \"arbitration lost\\n\");\n\t\t\treturn -EAGAIN;\n\t\t}\n\n\t\tif (msg.rx.ret == -BPMP_ETIMEDOUT) {\n\t\t\tdev_dbg(i2c->dev, \"timeout\\n\");\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\n\t\tif (msg.rx.ret == -BPMP_ENXIO) {\n\t\t\tdev_dbg(i2c->dev, \"NAK\\n\");\n\t\t\treturn -ENXIO;\n\t\t}\n\n\t\tdev_err(i2c->dev, \"transaction failed: %d\\n\", msg.rx.ret);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int tegra_bpmp_i2c_xfer_common(struct i2c_adapter *adapter,\n\t\t\t\t      struct i2c_msg *msgs, int num,\n\t\t\t\t      bool atomic)\n{\n\tstruct tegra_bpmp_i2c *i2c = i2c_get_adapdata(adapter);\n\tstruct mrq_i2c_response response;\n\tstruct mrq_i2c_request request;\n\tint err;\n\n\terr = tegra_bpmp_i2c_msg_len_check(msgs, num);\n\tif (err < 0) {\n\t\tdev_err(i2c->dev, \"unsupported message length\\n\");\n\t\treturn err;\n\t}\n\n\tmemset(&request, 0, sizeof(request));\n\tmemset(&response, 0, sizeof(response));\n\n\ttegra_bpmp_serialize_i2c_msg(i2c, &request, msgs, num);\n\terr = tegra_bpmp_i2c_msg_xfer(i2c, &request, &response, atomic);\n\tif (err < 0) {\n\t\tdev_err(i2c->dev, \"failed to transfer message: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\terr = tegra_bpmp_i2c_deserialize(i2c, &response, msgs, num);\n\tif (err < 0) {\n\t\tdev_err(i2c->dev, \"failed to deserialize message: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\treturn num;\n}\n\nstatic int tegra_bpmp_i2c_xfer(struct i2c_adapter *adapter,\n\t\t\t       struct i2c_msg *msgs, int num)\n{\n\treturn tegra_bpmp_i2c_xfer_common(adapter, msgs, num, false);\n}\n\nstatic int tegra_bpmp_i2c_xfer_atomic(struct i2c_adapter *adapter,\n\t\t\t\t      struct i2c_msg *msgs, int num)\n{\n\treturn tegra_bpmp_i2c_xfer_common(adapter, msgs, num, true);\n}\n\nstatic u32 tegra_bpmp_i2c_func(struct i2c_adapter *adapter)\n{\n\treturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL | I2C_FUNC_10BIT_ADDR |\n\t       I2C_FUNC_PROTOCOL_MANGLING | I2C_FUNC_NOSTART;\n}\n\nstatic const struct i2c_algorithm tegra_bpmp_i2c_algo = {\n\t.master_xfer = tegra_bpmp_i2c_xfer,\n\t.master_xfer_atomic = tegra_bpmp_i2c_xfer_atomic,\n\t.functionality = tegra_bpmp_i2c_func,\n};\n\nstatic int tegra_bpmp_i2c_probe(struct platform_device *pdev)\n{\n\tstruct tegra_bpmp_i2c *i2c;\n\tu32 value;\n\tint err;\n\n\ti2c = devm_kzalloc(&pdev->dev, sizeof(*i2c), GFP_KERNEL);\n\tif (!i2c)\n\t\treturn -ENOMEM;\n\n\ti2c->dev = &pdev->dev;\n\n\ti2c->bpmp = dev_get_drvdata(pdev->dev.parent);\n\tif (!i2c->bpmp)\n\t\treturn -ENODEV;\n\n\terr = of_property_read_u32(pdev->dev.of_node, \"nvidia,bpmp-bus-id\",\n\t\t\t\t   &value);\n\tif (err < 0)\n\t\treturn err;\n\n\ti2c->bus = value;\n\n\ti2c_set_adapdata(&i2c->adapter, i2c);\n\ti2c->adapter.owner = THIS_MODULE;\n\tstrscpy(i2c->adapter.name, \"Tegra BPMP I2C adapter\",\n\t\tsizeof(i2c->adapter.name));\n\ti2c->adapter.algo = &tegra_bpmp_i2c_algo;\n\ti2c->adapter.dev.parent = &pdev->dev;\n\ti2c->adapter.dev.of_node = pdev->dev.of_node;\n\n\tplatform_set_drvdata(pdev, i2c);\n\n\treturn i2c_add_adapter(&i2c->adapter);\n}\n\nstatic void tegra_bpmp_i2c_remove(struct platform_device *pdev)\n{\n\tstruct tegra_bpmp_i2c *i2c = platform_get_drvdata(pdev);\n\n\ti2c_del_adapter(&i2c->adapter);\n}\n\nstatic const struct of_device_id tegra_bpmp_i2c_of_match[] = {\n\t{ .compatible = \"nvidia,tegra186-bpmp-i2c\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, tegra_bpmp_i2c_of_match);\n\nstatic struct platform_driver tegra_bpmp_i2c_driver = {\n\t.driver = {\n\t\t.name = \"tegra-bpmp-i2c\",\n\t\t.of_match_table = tegra_bpmp_i2c_of_match,\n\t},\n\t.probe = tegra_bpmp_i2c_probe,\n\t.remove_new = tegra_bpmp_i2c_remove,\n};\nmodule_platform_driver(tegra_bpmp_i2c_driver);\n\nMODULE_DESCRIPTION(\"NVIDIA Tegra BPMP I2C bus controller driver\");\nMODULE_AUTHOR(\"Shardar Shariff Md <smohammed@nvidia.com>\");\nMODULE_AUTHOR(\"Juha-Matti Tilli\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}