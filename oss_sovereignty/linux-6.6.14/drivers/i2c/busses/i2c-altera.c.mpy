{
  "module_name": "i2c-altera.c",
  "hash_id": "3962168e65c31e4cf2865351f66cb5dae60bc3f3504c5a887ac56ff10b868779",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-altera.c",
  "human_readable_source": "\n \n#include <linux/clk.h>\n#include <linux/clkdev.h>\n#include <linux/err.h>\n#include <linux/i2c.h>\n#include <linux/iopoll.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/platform_device.h>\n\n#define ALTR_I2C_TFR_CMD\t0x00\t \n#define     ALTR_I2C_TFR_CMD_STA\tBIT(9)\t \n#define     ALTR_I2C_TFR_CMD_STO\tBIT(8)\t \n#define     ALTR_I2C_TFR_CMD_RW_D\tBIT(0)\t \n#define ALTR_I2C_RX_DATA\t0x04\t \n#define ALTR_I2C_CTRL\t\t0x08\t \n#define     ALTR_I2C_CTRL_RXT_SHFT\t4\t \n#define     ALTR_I2C_CTRL_TCT_SHFT\t2\t \n#define     ALTR_I2C_CTRL_BSPEED\tBIT(1)\t \n#define     ALTR_I2C_CTRL_EN\tBIT(0)\t \n#define ALTR_I2C_ISER\t\t0x0C\t \n#define     ALTR_I2C_ISER_RXOF_EN\tBIT(4)\t \n#define     ALTR_I2C_ISER_ARB_EN\tBIT(3)\t \n#define     ALTR_I2C_ISER_NACK_EN\tBIT(2)\t \n#define     ALTR_I2C_ISER_RXRDY_EN\tBIT(1)\t \n#define     ALTR_I2C_ISER_TXRDY_EN\tBIT(0)\t \n#define ALTR_I2C_ISR\t\t0x10\t \n#define     ALTR_I2C_ISR_RXOF\t\tBIT(4)\t \n#define     ALTR_I2C_ISR_ARB\t\tBIT(3)\t \n#define     ALTR_I2C_ISR_NACK\t\tBIT(2)\t \n#define     ALTR_I2C_ISR_RXRDY\t\tBIT(1)\t \n#define     ALTR_I2C_ISR_TXRDY\t\tBIT(0)\t \n#define ALTR_I2C_STATUS\t\t0x14\t \n#define     ALTR_I2C_STAT_CORE\t\tBIT(0)\t \n#define ALTR_I2C_TC_FIFO_LVL\t0x18\t \n#define ALTR_I2C_RX_FIFO_LVL\t0x1C\t \n#define ALTR_I2C_SCL_LOW\t0x20\t \n#define ALTR_I2C_SCL_HIGH\t0x24\t \n#define ALTR_I2C_SDA_HOLD\t0x28\t \n\n#define ALTR_I2C_ALL_IRQ\t(ALTR_I2C_ISR_RXOF | ALTR_I2C_ISR_ARB | \\\n\t\t\t\t ALTR_I2C_ISR_NACK | ALTR_I2C_ISR_RXRDY | \\\n\t\t\t\t ALTR_I2C_ISR_TXRDY)\n\n#define ALTR_I2C_THRESHOLD\t0\t \n#define ALTR_I2C_DFLT_FIFO_SZ\t4\n#define ALTR_I2C_TIMEOUT\t100000\t \n#define ALTR_I2C_XFER_TIMEOUT\t(msecs_to_jiffies(250))\n\n \nstruct altr_i2c_dev {\n\tvoid __iomem *base;\n\tstruct i2c_msg *msg;\n\tsize_t msg_len;\n\tint msg_err;\n\tstruct completion msg_complete;\n\tstruct device *dev;\n\tstruct i2c_adapter adapter;\n\tstruct clk *i2c_clk;\n\tu32 bus_clk_rate;\n\tu8 *buf;\n\tu32 fifo_size;\n\tu32 isr_mask;\n\tu32 isr_status;\n\tstruct mutex isr_mutex;\n};\n\nstatic void\naltr_i2c_int_enable(struct altr_i2c_dev *idev, u32 mask, bool enable)\n{\n\tu32 int_en;\n\n\tint_en = readl(idev->base + ALTR_I2C_ISER);\n\tif (enable)\n\t\tidev->isr_mask = int_en | mask;\n\telse\n\t\tidev->isr_mask = int_en & ~mask;\n\n\twritel(idev->isr_mask, idev->base + ALTR_I2C_ISER);\n}\n\nstatic void altr_i2c_int_clear(struct altr_i2c_dev *idev, u32 mask)\n{\n\tu32 int_en = readl(idev->base + ALTR_I2C_ISR);\n\n\twritel(int_en | mask, idev->base + ALTR_I2C_ISR);\n}\n\nstatic void altr_i2c_core_disable(struct altr_i2c_dev *idev)\n{\n\tu32 tmp = readl(idev->base + ALTR_I2C_CTRL);\n\n\twritel(tmp & ~ALTR_I2C_CTRL_EN, idev->base + ALTR_I2C_CTRL);\n}\n\nstatic void altr_i2c_core_enable(struct altr_i2c_dev *idev)\n{\n\tu32 tmp = readl(idev->base + ALTR_I2C_CTRL);\n\n\twritel(tmp | ALTR_I2C_CTRL_EN, idev->base + ALTR_I2C_CTRL);\n}\n\nstatic void altr_i2c_reset(struct altr_i2c_dev *idev)\n{\n\taltr_i2c_core_disable(idev);\n\taltr_i2c_core_enable(idev);\n}\n\nstatic inline void altr_i2c_stop(struct altr_i2c_dev *idev)\n{\n\twritel(ALTR_I2C_TFR_CMD_STO, idev->base + ALTR_I2C_TFR_CMD);\n}\n\nstatic void altr_i2c_init(struct altr_i2c_dev *idev)\n{\n\tu32 divisor = clk_get_rate(idev->i2c_clk) / idev->bus_clk_rate;\n\tu32 clk_mhz = clk_get_rate(idev->i2c_clk) / 1000000;\n\tu32 tmp = (ALTR_I2C_THRESHOLD << ALTR_I2C_CTRL_RXT_SHFT) |\n\t\t  (ALTR_I2C_THRESHOLD << ALTR_I2C_CTRL_TCT_SHFT);\n\tu32 t_high, t_low;\n\n\tif (idev->bus_clk_rate <= I2C_MAX_STANDARD_MODE_FREQ) {\n\t\ttmp &= ~ALTR_I2C_CTRL_BSPEED;\n\t\t \n\t\tt_high = divisor * 1 / 2;\n\t\tt_low = divisor * 1 / 2;\n\t} else {\n\t\ttmp |= ALTR_I2C_CTRL_BSPEED;\n\t\t \n\t\tt_high = divisor * 1 / 3;\n\t\tt_low = divisor * 2 / 3;\n\t}\n\twritel(tmp, idev->base + ALTR_I2C_CTRL);\n\n\tdev_dbg(idev->dev, \"rate=%uHz per_clk=%uMHz -> ratio=1:%u\\n\",\n\t\tidev->bus_clk_rate, clk_mhz, divisor);\n\n\t \n\taltr_i2c_reset(idev);\n\n\t \n\twritel(t_high, idev->base + ALTR_I2C_SCL_HIGH);\n\t \n\twritel(t_low, idev->base + ALTR_I2C_SCL_LOW);\n\t \n\twritel(3 * clk_mhz / 10, idev->base + ALTR_I2C_SDA_HOLD);\n\n\t \n\taltr_i2c_int_enable(idev, ALTR_I2C_ALL_IRQ, false);\n}\n\n \nstatic void altr_i2c_transfer(struct altr_i2c_dev *idev, u32 data)\n{\n\t \n\tif (idev->msg_len == 1)\n\t\tdata |= ALTR_I2C_TFR_CMD_STO;\n\tif (idev->msg_len > 0)\n\t\twritel(data, idev->base + ALTR_I2C_TFR_CMD);\n}\n\n \nstatic void altr_i2c_empty_rx_fifo(struct altr_i2c_dev *idev)\n{\n\tsize_t rx_fifo_avail = readl(idev->base + ALTR_I2C_RX_FIFO_LVL);\n\tint bytes_to_transfer = min(rx_fifo_avail, idev->msg_len);\n\n\twhile (bytes_to_transfer-- > 0) {\n\t\t*idev->buf++ = readl(idev->base + ALTR_I2C_RX_DATA);\n\t\tidev->msg_len--;\n\t\taltr_i2c_transfer(idev, 0);\n\t}\n}\n\n \nstatic int altr_i2c_fill_tx_fifo(struct altr_i2c_dev *idev)\n{\n\tsize_t tx_fifo_avail = idev->fifo_size - readl(idev->base +\n\t\t\t\t\t\t       ALTR_I2C_TC_FIFO_LVL);\n\tint bytes_to_transfer = min(tx_fifo_avail, idev->msg_len);\n\tint ret = idev->msg_len - bytes_to_transfer;\n\n\twhile (bytes_to_transfer-- > 0) {\n\t\taltr_i2c_transfer(idev, *idev->buf++);\n\t\tidev->msg_len--;\n\t}\n\n\treturn ret;\n}\n\nstatic irqreturn_t altr_i2c_isr_quick(int irq, void *_dev)\n{\n\tstruct altr_i2c_dev *idev = _dev;\n\tirqreturn_t ret = IRQ_HANDLED;\n\n\t \n\tidev->isr_status = readl(idev->base + ALTR_I2C_ISR) & idev->isr_mask;\n\tif (idev->isr_status)\n\t\tret = IRQ_WAKE_THREAD;\n\n\treturn ret;\n}\n\nstatic irqreturn_t altr_i2c_isr(int irq, void *_dev)\n{\n\tint ret;\n\tbool read, finish = false;\n\tstruct altr_i2c_dev *idev = _dev;\n\tu32 status = idev->isr_status;\n\n\tmutex_lock(&idev->isr_mutex);\n\tif (!idev->msg) {\n\t\tdev_warn(idev->dev, \"unexpected interrupt\\n\");\n\t\taltr_i2c_int_clear(idev, ALTR_I2C_ALL_IRQ);\n\t\tgoto out;\n\t}\n\tread = (idev->msg->flags & I2C_M_RD) != 0;\n\n\t \n\tif (unlikely(status & ALTR_I2C_ISR_ARB)) {\n\t\taltr_i2c_int_clear(idev, ALTR_I2C_ISR_ARB);\n\t\tidev->msg_err = -EAGAIN;\n\t\tfinish = true;\n\t} else if (unlikely(status & ALTR_I2C_ISR_NACK)) {\n\t\tdev_dbg(idev->dev, \"Could not get ACK\\n\");\n\t\tidev->msg_err = -ENXIO;\n\t\taltr_i2c_int_clear(idev, ALTR_I2C_ISR_NACK);\n\t\taltr_i2c_stop(idev);\n\t\tfinish = true;\n\t} else if (read && unlikely(status & ALTR_I2C_ISR_RXOF)) {\n\t\t \n\t\taltr_i2c_empty_rx_fifo(idev);\n\t\taltr_i2c_int_clear(idev, ALTR_I2C_ISR_RXRDY);\n\t\taltr_i2c_stop(idev);\n\t\tdev_err(idev->dev, \"RX FIFO Overflow\\n\");\n\t\tfinish = true;\n\t} else if (read && (status & ALTR_I2C_ISR_RXRDY)) {\n\t\t \n\t\taltr_i2c_empty_rx_fifo(idev);\n\t\taltr_i2c_int_clear(idev, ALTR_I2C_ISR_RXRDY);\n\t\tif (!idev->msg_len)\n\t\t\tfinish = true;\n\t} else if (!read && (status & ALTR_I2C_ISR_TXRDY)) {\n\t\t \n\t\taltr_i2c_int_clear(idev, ALTR_I2C_ISR_TXRDY);\n\t\tif (idev->msg_len > 0)\n\t\t\taltr_i2c_fill_tx_fifo(idev);\n\t\telse\n\t\t\tfinish = true;\n\t} else {\n\t\tdev_warn(idev->dev, \"Unexpected interrupt: 0x%x\\n\", status);\n\t\taltr_i2c_int_clear(idev, ALTR_I2C_ALL_IRQ);\n\t}\n\n\tif (finish) {\n\t\t \n\t\tret = readl_poll_timeout_atomic(idev->base + ALTR_I2C_STATUS,\n\t\t\t\t\t\tstatus,\n\t\t\t\t\t\t!(status & ALTR_I2C_STAT_CORE),\n\t\t\t\t\t\t1, ALTR_I2C_TIMEOUT);\n\t\tif (ret)\n\t\t\tdev_err(idev->dev, \"message timeout\\n\");\n\t\taltr_i2c_int_enable(idev, ALTR_I2C_ALL_IRQ, false);\n\t\taltr_i2c_int_clear(idev, ALTR_I2C_ALL_IRQ);\n\t\tcomplete(&idev->msg_complete);\n\t\tdev_dbg(idev->dev, \"Message Complete\\n\");\n\t}\nout:\n\tmutex_unlock(&idev->isr_mutex);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int altr_i2c_xfer_msg(struct altr_i2c_dev *idev, struct i2c_msg *msg)\n{\n\tu32 imask = ALTR_I2C_ISR_RXOF | ALTR_I2C_ISR_ARB | ALTR_I2C_ISR_NACK;\n\tunsigned long time_left;\n\tu32 value;\n\tu8 addr = i2c_8bit_addr_from_msg(msg);\n\n\tmutex_lock(&idev->isr_mutex);\n\tidev->msg = msg;\n\tidev->msg_len = msg->len;\n\tidev->buf = msg->buf;\n\tidev->msg_err = 0;\n\treinit_completion(&idev->msg_complete);\n\taltr_i2c_core_enable(idev);\n\n\t \n\tdo {\n\t\treadl(idev->base + ALTR_I2C_RX_DATA);\n\t} while (readl(idev->base + ALTR_I2C_RX_FIFO_LVL));\n\n\twritel(ALTR_I2C_TFR_CMD_STA | addr, idev->base + ALTR_I2C_TFR_CMD);\n\n\tif ((msg->flags & I2C_M_RD) != 0) {\n\t\timask |= ALTR_I2C_ISER_RXOF_EN | ALTR_I2C_ISER_RXRDY_EN;\n\t\taltr_i2c_int_enable(idev, imask, true);\n\t\t \n\t\taltr_i2c_transfer(idev, 0);\n\t} else {\n\t\timask |= ALTR_I2C_ISR_TXRDY;\n\t\taltr_i2c_int_enable(idev, imask, true);\n\t\taltr_i2c_fill_tx_fifo(idev);\n\t}\n\tmutex_unlock(&idev->isr_mutex);\n\n\ttime_left = wait_for_completion_timeout(&idev->msg_complete,\n\t\t\t\t\t\tALTR_I2C_XFER_TIMEOUT);\n\tmutex_lock(&idev->isr_mutex);\n\taltr_i2c_int_enable(idev, imask, false);\n\n\tvalue = readl(idev->base + ALTR_I2C_STATUS) & ALTR_I2C_STAT_CORE;\n\tif (value)\n\t\tdev_err(idev->dev, \"Core Status not IDLE...\\n\");\n\n\tif (time_left == 0) {\n\t\tidev->msg_err = -ETIMEDOUT;\n\t\tdev_dbg(idev->dev, \"Transaction timed out.\\n\");\n\t}\n\n\taltr_i2c_core_disable(idev);\n\tmutex_unlock(&idev->isr_mutex);\n\n\treturn idev->msg_err;\n}\n\nstatic int\naltr_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)\n{\n\tstruct altr_i2c_dev *idev = i2c_get_adapdata(adap);\n\tint i, ret;\n\n\tfor (i = 0; i < num; i++) {\n\t\tret = altr_i2c_xfer_msg(idev, msgs++);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn num;\n}\n\nstatic u32 altr_i2c_func(struct i2c_adapter *adap)\n{\n\treturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;\n}\n\nstatic const struct i2c_algorithm altr_i2c_algo = {\n\t.master_xfer = altr_i2c_xfer,\n\t.functionality = altr_i2c_func,\n};\n\nstatic int altr_i2c_probe(struct platform_device *pdev)\n{\n\tstruct altr_i2c_dev *idev = NULL;\n\tint irq, ret;\n\n\tidev = devm_kzalloc(&pdev->dev, sizeof(*idev), GFP_KERNEL);\n\tif (!idev)\n\t\treturn -ENOMEM;\n\n\tidev->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(idev->base))\n\t\treturn PTR_ERR(idev->base);\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tidev->i2c_clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(idev->i2c_clk)) {\n\t\tdev_err(&pdev->dev, \"missing clock\\n\");\n\t\treturn PTR_ERR(idev->i2c_clk);\n\t}\n\n\tidev->dev = &pdev->dev;\n\tinit_completion(&idev->msg_complete);\n\tmutex_init(&idev->isr_mutex);\n\n\tret = device_property_read_u32(idev->dev, \"fifo-size\",\n\t\t\t\t       &idev->fifo_size);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"FIFO size set to default of %d\\n\",\n\t\t\tALTR_I2C_DFLT_FIFO_SZ);\n\t\tidev->fifo_size = ALTR_I2C_DFLT_FIFO_SZ;\n\t}\n\n\tret = device_property_read_u32(idev->dev, \"clock-frequency\",\n\t\t\t\t       &idev->bus_clk_rate);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Default to 100kHz\\n\");\n\t\tidev->bus_clk_rate = I2C_MAX_STANDARD_MODE_FREQ;\t \n\t}\n\n\tif (idev->bus_clk_rate > I2C_MAX_FAST_MODE_FREQ) {\n\t\tdev_err(&pdev->dev, \"invalid clock-frequency %d\\n\",\n\t\t\tidev->bus_clk_rate);\n\t\treturn -EINVAL;\n\t}\n\n\tret = devm_request_threaded_irq(&pdev->dev, irq, altr_i2c_isr_quick,\n\t\t\t\t\taltr_i2c_isr, IRQF_ONESHOT,\n\t\t\t\t\tpdev->name, idev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to claim IRQ %d\\n\", irq);\n\t\treturn ret;\n\t}\n\n\tret = clk_prepare_enable(idev->i2c_clk);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to enable clock\\n\");\n\t\treturn ret;\n\t}\n\n\tmutex_lock(&idev->isr_mutex);\n\taltr_i2c_init(idev);\n\tmutex_unlock(&idev->isr_mutex);\n\n\ti2c_set_adapdata(&idev->adapter, idev);\n\tstrscpy(idev->adapter.name, pdev->name, sizeof(idev->adapter.name));\n\tidev->adapter.owner = THIS_MODULE;\n\tidev->adapter.algo = &altr_i2c_algo;\n\tidev->adapter.dev.parent = &pdev->dev;\n\tidev->adapter.dev.of_node = pdev->dev.of_node;\n\n\tplatform_set_drvdata(pdev, idev);\n\n\tret = i2c_add_adapter(&idev->adapter);\n\tif (ret) {\n\t\tclk_disable_unprepare(idev->i2c_clk);\n\t\treturn ret;\n\t}\n\tdev_info(&pdev->dev, \"Altera SoftIP I2C Probe Complete\\n\");\n\n\treturn 0;\n}\n\nstatic void altr_i2c_remove(struct platform_device *pdev)\n{\n\tstruct altr_i2c_dev *idev = platform_get_drvdata(pdev);\n\n\tclk_disable_unprepare(idev->i2c_clk);\n\ti2c_del_adapter(&idev->adapter);\n}\n\n \nstatic const struct of_device_id altr_i2c_of_match[] = {\n\t{ .compatible = \"altr,softip-i2c-v1.0\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, altr_i2c_of_match);\n\nstatic struct platform_driver altr_i2c_driver = {\n\t.probe = altr_i2c_probe,\n\t.remove_new = altr_i2c_remove,\n\t.driver = {\n\t\t.name = \"altera-i2c\",\n\t\t.of_match_table = altr_i2c_of_match,\n\t},\n};\n\nmodule_platform_driver(altr_i2c_driver);\n\nMODULE_DESCRIPTION(\"Altera Soft IP I2C bus driver\");\nMODULE_AUTHOR(\"Thor Thayer <thor.thayer@linux.intel.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}