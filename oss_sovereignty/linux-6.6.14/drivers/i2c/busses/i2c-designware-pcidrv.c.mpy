{
  "module_name": "i2c-designware-pcidrv.c",
  "hash_id": "83220980ade78b5f8ab2785d7579ad9bf97d01cb74809bde0ddb389cc46ae4dd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-designware-pcidrv.c",
  "human_readable_source": "\n \n#include <linux/acpi.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/pm_runtime.h>\n#include <linux/power_supply.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\n#include \"i2c-designware-core.h\"\n#include \"i2c-ccgx-ucsi.h\"\n\n#define DRIVER_NAME \"i2c-designware-pci\"\n\nenum dw_pci_ctl_id_t {\n\tmedfield,\n\tmerrifield,\n\tbaytrail,\n\tcherrytrail,\n\thaswell,\n\telkhartlake,\n\tnavi_amd,\n};\n\n \nstruct dw_scl_sda_cfg {\n\tu16 ss_hcnt;\n\tu16 fs_hcnt;\n\tu16 ss_lcnt;\n\tu16 fs_lcnt;\n\tu32 sda_hold;\n};\n\nstruct dw_pci_controller {\n\tu32 bus_num;\n\tu32 flags;\n\tstruct dw_scl_sda_cfg *scl_sda_cfg;\n\tint (*setup)(struct pci_dev *pdev, struct dw_pci_controller *c);\n\tu32 (*get_clk_rate_khz)(struct dw_i2c_dev *dev);\n};\n\n \nstatic struct dw_scl_sda_cfg mrfld_config = {\n\t.ss_hcnt = 0x2f8,\n\t.fs_hcnt = 0x87,\n\t.ss_lcnt = 0x37b,\n\t.fs_lcnt = 0x10a,\n};\n\n \nstatic struct dw_scl_sda_cfg byt_config = {\n\t.ss_hcnt = 0x200,\n\t.fs_hcnt = 0x55,\n\t.ss_lcnt = 0x200,\n\t.fs_lcnt = 0x99,\n\t.sda_hold = 0x6,\n};\n\n \nstatic struct dw_scl_sda_cfg hsw_config = {\n\t.ss_hcnt = 0x01b0,\n\t.fs_hcnt = 0x48,\n\t.ss_lcnt = 0x01fb,\n\t.fs_lcnt = 0xa0,\n\t.sda_hold = 0x9,\n};\n\n \nstatic struct dw_scl_sda_cfg navi_amd_config = {\n\t.ss_hcnt = 0x1ae,\n\t.ss_lcnt = 0x23a,\n\t.sda_hold = 0x9,\n};\n\nstatic u32 mfld_get_clk_rate_khz(struct dw_i2c_dev *dev)\n{\n\treturn 25000;\n}\n\nstatic int mfld_setup(struct pci_dev *pdev, struct dw_pci_controller *c)\n{\n\tstruct dw_i2c_dev *dev = dev_get_drvdata(&pdev->dev);\n\n\tswitch (pdev->device) {\n\tcase 0x0817:\n\t\tdev->timings.bus_freq_hz = I2C_MAX_STANDARD_MODE_FREQ;\n\t\tfallthrough;\n\tcase 0x0818:\n\tcase 0x0819:\n\t\tc->bus_num = pdev->device - 0x817 + 3;\n\t\treturn 0;\n\tcase 0x082C:\n\tcase 0x082D:\n\tcase 0x082E:\n\t\tc->bus_num = pdev->device - 0x82C + 0;\n\t\treturn 0;\n\t}\n\treturn -ENODEV;\n}\n\nstatic int mrfld_setup(struct pci_dev *pdev, struct dw_pci_controller *c)\n{\n\t \n\tswitch (PCI_SLOT(pdev->devfn)) {\n\tcase 8:\n\t\tc->bus_num = PCI_FUNC(pdev->devfn) + 0 + 1;\n\t\treturn 0;\n\tcase 9:\n\t\tc->bus_num = PCI_FUNC(pdev->devfn) + 4 + 1;\n\t\treturn 0;\n\t}\n\treturn -ENODEV;\n}\n\nstatic u32 ehl_get_clk_rate_khz(struct dw_i2c_dev *dev)\n{\n\treturn 100000;\n}\n\nstatic u32 navi_amd_get_clk_rate_khz(struct dw_i2c_dev *dev)\n{\n\treturn 100000;\n}\n\nstatic int navi_amd_setup(struct pci_dev *pdev, struct dw_pci_controller *c)\n{\n\tstruct dw_i2c_dev *dev = dev_get_drvdata(&pdev->dev);\n\n\tdev->flags |= MODEL_AMD_NAVI_GPU;\n\tdev->timings.bus_freq_hz = I2C_MAX_STANDARD_MODE_FREQ;\n\treturn 0;\n}\n\nstatic struct dw_pci_controller dw_pci_controllers[] = {\n\t[medfield] = {\n\t\t.bus_num = -1,\n\t\t.setup = mfld_setup,\n\t\t.get_clk_rate_khz = mfld_get_clk_rate_khz,\n\t},\n\t[merrifield] = {\n\t\t.bus_num = -1,\n\t\t.scl_sda_cfg = &mrfld_config,\n\t\t.setup = mrfld_setup,\n\t},\n\t[baytrail] = {\n\t\t.bus_num = -1,\n\t\t.scl_sda_cfg = &byt_config,\n\t},\n\t[haswell] = {\n\t\t.bus_num = -1,\n\t\t.scl_sda_cfg = &hsw_config,\n\t},\n\t[cherrytrail] = {\n\t\t.bus_num = -1,\n\t\t.scl_sda_cfg = &byt_config,\n\t},\n\t[elkhartlake] = {\n\t\t.bus_num = -1,\n\t\t.get_clk_rate_khz = ehl_get_clk_rate_khz,\n\t},\n\t[navi_amd] = {\n\t\t.bus_num = -1,\n\t\t.scl_sda_cfg = &navi_amd_config,\n\t\t.setup =  navi_amd_setup,\n\t\t.get_clk_rate_khz = navi_amd_get_clk_rate_khz,\n\t},\n};\n\nstatic int __maybe_unused i2c_dw_pci_runtime_suspend(struct device *dev)\n{\n\tstruct dw_i2c_dev *i_dev = dev_get_drvdata(dev);\n\n\ti_dev->disable(i_dev);\n\treturn 0;\n}\n\nstatic int __maybe_unused i2c_dw_pci_suspend(struct device *dev)\n{\n\tstruct dw_i2c_dev *i_dev = dev_get_drvdata(dev);\n\n\ti2c_mark_adapter_suspended(&i_dev->adapter);\n\n\treturn i2c_dw_pci_runtime_suspend(dev);\n}\n\nstatic int __maybe_unused i2c_dw_pci_runtime_resume(struct device *dev)\n{\n\tstruct dw_i2c_dev *i_dev = dev_get_drvdata(dev);\n\n\treturn i_dev->init(i_dev);\n}\n\nstatic int __maybe_unused i2c_dw_pci_resume(struct device *dev)\n{\n\tstruct dw_i2c_dev *i_dev = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = i2c_dw_pci_runtime_resume(dev);\n\n\ti2c_mark_adapter_resumed(&i_dev->adapter);\n\n\treturn ret;\n}\n\nstatic const struct dev_pm_ops i2c_dw_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(i2c_dw_pci_suspend, i2c_dw_pci_resume)\n\tSET_RUNTIME_PM_OPS(i2c_dw_pci_runtime_suspend, i2c_dw_pci_runtime_resume, NULL)\n};\n\nstatic const struct property_entry dgpu_properties[] = {\n\t \n\tPROPERTY_ENTRY_U8(\"scope\", POWER_SUPPLY_SCOPE_DEVICE),\n\t{}\n};\n\nstatic const struct software_node dgpu_node = {\n\t.properties = dgpu_properties,\n};\n\nstatic int i2c_dw_pci_probe(struct pci_dev *pdev,\n\t\t\t    const struct pci_device_id *id)\n{\n\tstruct dw_i2c_dev *dev;\n\tstruct i2c_adapter *adap;\n\tint r;\n\tstruct dw_pci_controller *controller;\n\tstruct dw_scl_sda_cfg *cfg;\n\tstruct i2c_timings *t;\n\n\tif (id->driver_data >= ARRAY_SIZE(dw_pci_controllers))\n\t\treturn dev_err_probe(&pdev->dev, -EINVAL,\n\t\t\t\t     \"Invalid driver data %ld\\n\",\n\t\t\t\t     id->driver_data);\n\n\tcontroller = &dw_pci_controllers[id->driver_data];\n\n\tr = pcim_enable_device(pdev);\n\tif (r)\n\t\treturn dev_err_probe(&pdev->dev, r,\n\t\t\t\t     \"Failed to enable I2C PCI device\\n\");\n\n\tpci_set_master(pdev);\n\n\tr = pcim_iomap_regions(pdev, 1 << 0, pci_name(pdev));\n\tif (r)\n\t\treturn dev_err_probe(&pdev->dev, r,\n\t\t\t\t     \"I/O memory remapping failed\\n\");\n\n\tdev = devm_kzalloc(&pdev->dev, sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tr = pci_alloc_irq_vectors(pdev, 1, 1, PCI_IRQ_ALL_TYPES);\n\tif (r < 0)\n\t\treturn r;\n\n\tdev->get_clk_rate_khz = controller->get_clk_rate_khz;\n\tdev->base = pcim_iomap_table(pdev)[0];\n\tdev->dev = &pdev->dev;\n\tdev->irq = pci_irq_vector(pdev, 0);\n\tdev->flags |= controller->flags;\n\n\tt = &dev->timings;\n\ti2c_parse_fw_timings(&pdev->dev, t, false);\n\n\tpci_set_drvdata(pdev, dev);\n\n\tif (controller->setup) {\n\t\tr = controller->setup(pdev, controller);\n\t\tif (r) {\n\t\t\tpci_free_irq_vectors(pdev);\n\t\t\treturn r;\n\t\t}\n\t}\n\n\ti2c_dw_adjust_bus_speed(dev);\n\n\tif (has_acpi_companion(&pdev->dev))\n\t\ti2c_dw_acpi_configure(&pdev->dev);\n\n\tr = i2c_dw_validate_speed(dev);\n\tif (r) {\n\t\tpci_free_irq_vectors(pdev);\n\t\treturn r;\n\t}\n\n\ti2c_dw_configure(dev);\n\n\tif (controller->scl_sda_cfg) {\n\t\tcfg = controller->scl_sda_cfg;\n\t\tdev->ss_hcnt = cfg->ss_hcnt;\n\t\tdev->fs_hcnt = cfg->fs_hcnt;\n\t\tdev->ss_lcnt = cfg->ss_lcnt;\n\t\tdev->fs_lcnt = cfg->fs_lcnt;\n\t\tdev->sda_hold_time = cfg->sda_hold;\n\t}\n\n\tadap = &dev->adapter;\n\tadap->owner = THIS_MODULE;\n\tadap->class = 0;\n\tACPI_COMPANION_SET(&adap->dev, ACPI_COMPANION(&pdev->dev));\n\tadap->nr = controller->bus_num;\n\n\tr = i2c_dw_probe(dev);\n\tif (r) {\n\t\tpci_free_irq_vectors(pdev);\n\t\treturn r;\n\t}\n\n\tif ((dev->flags & MODEL_MASK) == MODEL_AMD_NAVI_GPU) {\n\t\tdev->slave = i2c_new_ccgx_ucsi(&dev->adapter, dev->irq, &dgpu_node);\n\t\tif (IS_ERR(dev->slave))\n\t\t\treturn dev_err_probe(dev->dev, PTR_ERR(dev->slave),\n\t\t\t\t\t     \"register UCSI failed\\n\");\n\t}\n\n\tpm_runtime_set_autosuspend_delay(&pdev->dev, 1000);\n\tpm_runtime_use_autosuspend(&pdev->dev);\n\tpm_runtime_put_autosuspend(&pdev->dev);\n\tpm_runtime_allow(&pdev->dev);\n\n\treturn 0;\n}\n\nstatic void i2c_dw_pci_remove(struct pci_dev *pdev)\n{\n\tstruct dw_i2c_dev *dev = pci_get_drvdata(pdev);\n\n\tdev->disable(dev);\n\tpm_runtime_forbid(&pdev->dev);\n\tpm_runtime_get_noresume(&pdev->dev);\n\n\ti2c_del_adapter(&dev->adapter);\n\tdevm_free_irq(&pdev->dev, dev->irq, dev);\n\tpci_free_irq_vectors(pdev);\n}\n\nstatic const struct pci_device_id i2_designware_pci_ids[] = {\n\t \n\t{ PCI_VDEVICE(INTEL, 0x0817), medfield },\n\t{ PCI_VDEVICE(INTEL, 0x0818), medfield },\n\t{ PCI_VDEVICE(INTEL, 0x0819), medfield },\n\t{ PCI_VDEVICE(INTEL, 0x082C), medfield },\n\t{ PCI_VDEVICE(INTEL, 0x082D), medfield },\n\t{ PCI_VDEVICE(INTEL, 0x082E), medfield },\n\t \n\t{ PCI_VDEVICE(INTEL, 0x1195), merrifield },\n\t{ PCI_VDEVICE(INTEL, 0x1196), merrifield },\n\t \n\t{ PCI_VDEVICE(INTEL, 0x0F41), baytrail },\n\t{ PCI_VDEVICE(INTEL, 0x0F42), baytrail },\n\t{ PCI_VDEVICE(INTEL, 0x0F43), baytrail },\n\t{ PCI_VDEVICE(INTEL, 0x0F44), baytrail },\n\t{ PCI_VDEVICE(INTEL, 0x0F45), baytrail },\n\t{ PCI_VDEVICE(INTEL, 0x0F46), baytrail },\n\t{ PCI_VDEVICE(INTEL, 0x0F47), baytrail },\n\t \n\t{ PCI_VDEVICE(INTEL, 0x9c61), haswell },\n\t{ PCI_VDEVICE(INTEL, 0x9c62), haswell },\n\t \n\t{ PCI_VDEVICE(INTEL, 0x22C1), cherrytrail },\n\t{ PCI_VDEVICE(INTEL, 0x22C2), cherrytrail },\n\t{ PCI_VDEVICE(INTEL, 0x22C3), cherrytrail },\n\t{ PCI_VDEVICE(INTEL, 0x22C4), cherrytrail },\n\t{ PCI_VDEVICE(INTEL, 0x22C5), cherrytrail },\n\t{ PCI_VDEVICE(INTEL, 0x22C6), cherrytrail },\n\t{ PCI_VDEVICE(INTEL, 0x22C7), cherrytrail },\n\t \n\t{ PCI_VDEVICE(INTEL, 0x4bb9), elkhartlake },\n\t{ PCI_VDEVICE(INTEL, 0x4bba), elkhartlake },\n\t{ PCI_VDEVICE(INTEL, 0x4bbb), elkhartlake },\n\t{ PCI_VDEVICE(INTEL, 0x4bbc), elkhartlake },\n\t{ PCI_VDEVICE(INTEL, 0x4bbd), elkhartlake },\n\t{ PCI_VDEVICE(INTEL, 0x4bbe), elkhartlake },\n\t{ PCI_VDEVICE(INTEL, 0x4bbf), elkhartlake },\n\t{ PCI_VDEVICE(INTEL, 0x4bc0), elkhartlake },\n\t \n\t{ PCI_VDEVICE(ATI,  0x7314), navi_amd },\n\t{ PCI_VDEVICE(ATI,  0x73a4), navi_amd },\n\t{ PCI_VDEVICE(ATI,  0x73e4), navi_amd },\n\t{ PCI_VDEVICE(ATI,  0x73c4), navi_amd },\n\t{ PCI_VDEVICE(ATI,  0x7444), navi_amd },\n\t{ PCI_VDEVICE(ATI,  0x7464), navi_amd },\n\t{ 0,}\n};\nMODULE_DEVICE_TABLE(pci, i2_designware_pci_ids);\n\nstatic struct pci_driver dw_i2c_driver = {\n\t.name\t\t= DRIVER_NAME,\n\t.id_table\t= i2_designware_pci_ids,\n\t.probe\t\t= i2c_dw_pci_probe,\n\t.remove\t\t= i2c_dw_pci_remove,\n\t.driver         = {\n\t\t.pm     = &i2c_dw_pm_ops,\n\t},\n};\nmodule_pci_driver(dw_i2c_driver);\n\n \nMODULE_ALIAS(\"i2c_designware-pci\");\nMODULE_AUTHOR(\"Baruch Siach <baruch@tkos.co.il>\");\nMODULE_DESCRIPTION(\"Synopsys DesignWare PCI I2C bus adapter\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}