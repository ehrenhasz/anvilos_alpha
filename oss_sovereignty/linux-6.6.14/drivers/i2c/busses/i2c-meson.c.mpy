{
  "module_name": "i2c-meson.c",
  "hash_id": "13045fc73abd53a4b0e2eb469f8d87c9666bceb02b2ab5ae801ce7649edbbcea",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-meson.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/completion.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/types.h>\n\n \n#define REG_CTRL\t\t0x00\n#define REG_SLAVE_ADDR\t\t0x04\n#define REG_TOK_LIST0\t\t0x08\n#define REG_TOK_LIST1\t\t0x0c\n#define REG_TOK_WDATA0\t\t0x10\n#define REG_TOK_WDATA1\t\t0x14\n#define REG_TOK_RDATA0\t\t0x18\n#define REG_TOK_RDATA1\t\t0x1c\n\n \n#define REG_CTRL_START\t\t\tBIT(0)\n#define REG_CTRL_ACK_IGNORE\t\tBIT(1)\n#define REG_CTRL_STATUS\t\t\tBIT(2)\n#define REG_CTRL_ERROR\t\t\tBIT(3)\n#define REG_CTRL_CLKDIV_SHIFT\t\t12\n#define REG_CTRL_CLKDIV_MASK\t\tGENMASK(21, REG_CTRL_CLKDIV_SHIFT)\n#define REG_CTRL_CLKDIVEXT_SHIFT\t28\n#define REG_CTRL_CLKDIVEXT_MASK\t\tGENMASK(29, REG_CTRL_CLKDIVEXT_SHIFT)\n\n#define REG_SLV_ADDR_MASK\t\tGENMASK(7, 0)\n#define REG_SLV_SDA_FILTER_MASK\t\tGENMASK(10, 8)\n#define REG_SLV_SCL_FILTER_MASK\t\tGENMASK(13, 11)\n#define REG_SLV_SCL_LOW_SHIFT\t\t16\n#define REG_SLV_SCL_LOW_MASK\t\tGENMASK(27, REG_SLV_SCL_LOW_SHIFT)\n#define REG_SLV_SCL_LOW_EN\t\tBIT(28)\n\n#define I2C_TIMEOUT_MS\t\t500\n#define FILTER_DELAY\t\t15\n\nenum {\n\tTOKEN_END = 0,\n\tTOKEN_START,\n\tTOKEN_SLAVE_ADDR_WRITE,\n\tTOKEN_SLAVE_ADDR_READ,\n\tTOKEN_DATA,\n\tTOKEN_DATA_LAST,\n\tTOKEN_STOP,\n};\n\nenum {\n\tSTATE_IDLE,\n\tSTATE_READ,\n\tSTATE_WRITE,\n};\n\n \nstruct meson_i2c {\n\tstruct i2c_adapter\tadap;\n\tstruct device\t\t*dev;\n\tvoid __iomem\t\t*regs;\n\tstruct clk\t\t*clk;\n\n\tstruct i2c_msg\t\t*msg;\n\tint\t\t\tstate;\n\tbool\t\t\tlast;\n\tint\t\t\tcount;\n\tint\t\t\tpos;\n\tint\t\t\terror;\n\n\tspinlock_t\t\tlock;\n\tstruct completion\tdone;\n\tu32\t\t\ttokens[2];\n\tint\t\t\tnum_tokens;\n\n\tconst struct meson_i2c_data *data;\n};\n\nstruct meson_i2c_data {\n\tvoid (*set_clk_div)(struct meson_i2c *i2c, unsigned int freq);\n};\n\nstatic void meson_i2c_set_mask(struct meson_i2c *i2c, int reg, u32 mask,\n\t\t\t       u32 val)\n{\n\tu32 data;\n\n\tdata = readl(i2c->regs + reg);\n\tdata &= ~mask;\n\tdata |= val & mask;\n\twritel(data, i2c->regs + reg);\n}\n\nstatic void meson_i2c_reset_tokens(struct meson_i2c *i2c)\n{\n\ti2c->tokens[0] = 0;\n\ti2c->tokens[1] = 0;\n\ti2c->num_tokens = 0;\n}\n\nstatic void meson_i2c_add_token(struct meson_i2c *i2c, int token)\n{\n\tif (i2c->num_tokens < 8)\n\t\ti2c->tokens[0] |= (token & 0xf) << (i2c->num_tokens * 4);\n\telse\n\t\ti2c->tokens[1] |= (token & 0xf) << ((i2c->num_tokens % 8) * 4);\n\n\ti2c->num_tokens++;\n}\n\nstatic void meson_gxbb_axg_i2c_set_clk_div(struct meson_i2c *i2c, unsigned int freq)\n{\n\tunsigned long clk_rate = clk_get_rate(i2c->clk);\n\tunsigned int div_h, div_l;\n\n\t \n\tif (freq <= I2C_MAX_STANDARD_MODE_FREQ) {\n\t\tdiv_h = DIV_ROUND_UP(clk_rate, freq);\n\t\tdiv_l = DIV_ROUND_UP(div_h, 4);\n\t\tdiv_h = DIV_ROUND_UP(div_h, 2) - FILTER_DELAY;\n\t} else {\n\t\tdiv_h = DIV_ROUND_UP(clk_rate * 2, freq * 5) - FILTER_DELAY;\n\t\tdiv_l = DIV_ROUND_UP(clk_rate * 3, freq * 5 * 2);\n\t}\n\n\t \n\tif (div_h > GENMASK(11, 0)) {\n\t\tdev_err(i2c->dev, \"requested bus frequency too low\\n\");\n\t\tdiv_h = GENMASK(11, 0);\n\t}\n\tif (div_l > GENMASK(11, 0)) {\n\t\tdev_err(i2c->dev, \"requested bus frequency too low\\n\");\n\t\tdiv_l = GENMASK(11, 0);\n\t}\n\n\tmeson_i2c_set_mask(i2c, REG_CTRL, REG_CTRL_CLKDIV_MASK,\n\t\t\t   FIELD_PREP(REG_CTRL_CLKDIV_MASK, div_h & GENMASK(9, 0)));\n\n\tmeson_i2c_set_mask(i2c, REG_CTRL, REG_CTRL_CLKDIVEXT_MASK,\n\t\t\t   FIELD_PREP(REG_CTRL_CLKDIVEXT_MASK, div_h >> 10));\n\n\t \n\tmeson_i2c_set_mask(i2c, REG_SLAVE_ADDR, REG_SLV_SCL_LOW_MASK,\n\t\t\t   FIELD_PREP(REG_SLV_SCL_LOW_MASK, div_l));\n\n\t \n\tmeson_i2c_set_mask(i2c, REG_SLAVE_ADDR, REG_SLV_SCL_LOW_EN, REG_SLV_SCL_LOW_EN);\n\n\tdev_dbg(i2c->dev, \"%s: clk %lu, freq %u, divh %u, divl %u\\n\", __func__,\n\t\tclk_rate, freq, div_h, div_l);\n}\n\nstatic void meson6_i2c_set_clk_div(struct meson_i2c *i2c, unsigned int freq)\n{\n\tunsigned long clk_rate = clk_get_rate(i2c->clk);\n\tunsigned int div;\n\n\tdiv = DIV_ROUND_UP(clk_rate, freq);\n\tdiv -= FILTER_DELAY;\n\tdiv = DIV_ROUND_UP(div, 4);\n\n\t \n\tif (div > GENMASK(11, 0)) {\n\t\tdev_err(i2c->dev, \"requested bus frequency too low\\n\");\n\t\tdiv = GENMASK(11, 0);\n\t}\n\n\tmeson_i2c_set_mask(i2c, REG_CTRL, REG_CTRL_CLKDIV_MASK,\n\t\t\t   FIELD_PREP(REG_CTRL_CLKDIV_MASK, div & GENMASK(9, 0)));\n\n\tmeson_i2c_set_mask(i2c, REG_CTRL, REG_CTRL_CLKDIVEXT_MASK,\n\t\t\t   FIELD_PREP(REG_CTRL_CLKDIVEXT_MASK, div >> 10));\n\n\t \n\tmeson_i2c_set_mask(i2c, REG_SLAVE_ADDR, REG_SLV_SCL_LOW_EN, 0);\n\n\tdev_dbg(i2c->dev, \"%s: clk %lu, freq %u, div %u\\n\", __func__,\n\t\tclk_rate, freq, div);\n}\n\nstatic void meson_i2c_get_data(struct meson_i2c *i2c, char *buf, int len)\n{\n\tu32 rdata0, rdata1;\n\tint i;\n\n\trdata0 = readl(i2c->regs + REG_TOK_RDATA0);\n\trdata1 = readl(i2c->regs + REG_TOK_RDATA1);\n\n\tdev_dbg(i2c->dev, \"%s: data %08x %08x len %d\\n\", __func__,\n\t\trdata0, rdata1, len);\n\n\tfor (i = 0; i < min(4, len); i++)\n\t\t*buf++ = (rdata0 >> i * 8) & 0xff;\n\n\tfor (i = 4; i < min(8, len); i++)\n\t\t*buf++ = (rdata1 >> (i - 4) * 8) & 0xff;\n}\n\nstatic void meson_i2c_put_data(struct meson_i2c *i2c, char *buf, int len)\n{\n\tu32 wdata0 = 0, wdata1 = 0;\n\tint i;\n\n\tfor (i = 0; i < min(4, len); i++)\n\t\twdata0 |= *buf++ << (i * 8);\n\n\tfor (i = 4; i < min(8, len); i++)\n\t\twdata1 |= *buf++ << ((i - 4) * 8);\n\n\twritel(wdata0, i2c->regs + REG_TOK_WDATA0);\n\twritel(wdata1, i2c->regs + REG_TOK_WDATA1);\n\n\tdev_dbg(i2c->dev, \"%s: data %08x %08x len %d\\n\", __func__,\n\t\twdata0, wdata1, len);\n}\n\nstatic void meson_i2c_prepare_xfer(struct meson_i2c *i2c)\n{\n\tbool write = !(i2c->msg->flags & I2C_M_RD);\n\tint i;\n\n\ti2c->count = min(i2c->msg->len - i2c->pos, 8);\n\n\tfor (i = 0; i < i2c->count - 1; i++)\n\t\tmeson_i2c_add_token(i2c, TOKEN_DATA);\n\n\tif (i2c->count) {\n\t\tif (write || i2c->pos + i2c->count < i2c->msg->len)\n\t\t\tmeson_i2c_add_token(i2c, TOKEN_DATA);\n\t\telse\n\t\t\tmeson_i2c_add_token(i2c, TOKEN_DATA_LAST);\n\t}\n\n\tif (write)\n\t\tmeson_i2c_put_data(i2c, i2c->msg->buf + i2c->pos, i2c->count);\n\n\tif (i2c->last && i2c->pos + i2c->count >= i2c->msg->len)\n\t\tmeson_i2c_add_token(i2c, TOKEN_STOP);\n\n\twritel(i2c->tokens[0], i2c->regs + REG_TOK_LIST0);\n\twritel(i2c->tokens[1], i2c->regs + REG_TOK_LIST1);\n}\n\nstatic void meson_i2c_transfer_complete(struct meson_i2c *i2c, u32 ctrl)\n{\n\tif (ctrl & REG_CTRL_ERROR) {\n\t\t \n\t\tdev_dbg(i2c->dev, \"error bit set\\n\");\n\t\ti2c->error = -ENXIO;\n\t\ti2c->state = STATE_IDLE;\n\t} else {\n\t\tif (i2c->state == STATE_READ && i2c->count)\n\t\t\tmeson_i2c_get_data(i2c, i2c->msg->buf + i2c->pos,\n\t\t\t\t\t   i2c->count);\n\n\t\ti2c->pos += i2c->count;\n\n\t\tif (i2c->pos >= i2c->msg->len)\n\t\t\ti2c->state = STATE_IDLE;\n\t}\n}\n\nstatic irqreturn_t meson_i2c_irq(int irqno, void *dev_id)\n{\n\tstruct meson_i2c *i2c = dev_id;\n\tunsigned int ctrl;\n\n\tspin_lock(&i2c->lock);\n\n\tmeson_i2c_reset_tokens(i2c);\n\tmeson_i2c_set_mask(i2c, REG_CTRL, REG_CTRL_START, 0);\n\tctrl = readl(i2c->regs + REG_CTRL);\n\n\tdev_dbg(i2c->dev, \"irq: state %d, pos %d, count %d, ctrl %08x\\n\",\n\t\ti2c->state, i2c->pos, i2c->count, ctrl);\n\n\tif (i2c->state == STATE_IDLE) {\n\t\tspin_unlock(&i2c->lock);\n\t\treturn IRQ_NONE;\n\t}\n\n\tmeson_i2c_transfer_complete(i2c, ctrl);\n\n\tif (i2c->state == STATE_IDLE) {\n\t\tcomplete(&i2c->done);\n\t\tgoto out;\n\t}\n\n\t \n\tmeson_i2c_prepare_xfer(i2c);\n\tmeson_i2c_set_mask(i2c, REG_CTRL, REG_CTRL_START, REG_CTRL_START);\nout:\n\tspin_unlock(&i2c->lock);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void meson_i2c_do_start(struct meson_i2c *i2c, struct i2c_msg *msg)\n{\n\tint token;\n\n\ttoken = (msg->flags & I2C_M_RD) ? TOKEN_SLAVE_ADDR_READ :\n\t\tTOKEN_SLAVE_ADDR_WRITE;\n\n\n\tmeson_i2c_set_mask(i2c, REG_SLAVE_ADDR, REG_SLV_ADDR_MASK,\n\t\t\t   FIELD_PREP(REG_SLV_ADDR_MASK, msg->addr << 1));\n\n\tmeson_i2c_add_token(i2c, TOKEN_START);\n\tmeson_i2c_add_token(i2c, token);\n}\n\nstatic int meson_i2c_xfer_msg(struct meson_i2c *i2c, struct i2c_msg *msg,\n\t\t\t      int last, bool atomic)\n{\n\tunsigned long time_left, flags;\n\tint ret = 0;\n\tu32 ctrl;\n\n\ti2c->msg = msg;\n\ti2c->last = last;\n\ti2c->pos = 0;\n\ti2c->count = 0;\n\ti2c->error = 0;\n\n\tmeson_i2c_reset_tokens(i2c);\n\n\tflags = (msg->flags & I2C_M_IGNORE_NAK) ? REG_CTRL_ACK_IGNORE : 0;\n\tmeson_i2c_set_mask(i2c, REG_CTRL, REG_CTRL_ACK_IGNORE, flags);\n\n\tif (!(msg->flags & I2C_M_NOSTART))\n\t\tmeson_i2c_do_start(i2c, msg);\n\n\ti2c->state = (msg->flags & I2C_M_RD) ? STATE_READ : STATE_WRITE;\n\tmeson_i2c_prepare_xfer(i2c);\n\n\tif (!atomic)\n\t\treinit_completion(&i2c->done);\n\n\t \n\tmeson_i2c_set_mask(i2c, REG_CTRL, REG_CTRL_START, REG_CTRL_START);\n\n\tif (atomic) {\n\t\tret = readl_poll_timeout_atomic(i2c->regs + REG_CTRL, ctrl,\n\t\t\t\t\t\t!(ctrl & REG_CTRL_STATUS),\n\t\t\t\t\t\t10, I2C_TIMEOUT_MS * 1000);\n\t} else {\n\t\ttime_left = msecs_to_jiffies(I2C_TIMEOUT_MS);\n\t\ttime_left = wait_for_completion_timeout(&i2c->done, time_left);\n\n\t\tif (!time_left)\n\t\t\tret = -ETIMEDOUT;\n\t}\n\n\t \n\tspin_lock_irqsave(&i2c->lock, flags);\n\n\tif (atomic && !ret)\n\t\tmeson_i2c_transfer_complete(i2c, ctrl);\n\n\t \n\tmeson_i2c_set_mask(i2c, REG_CTRL, REG_CTRL_START, 0);\n\n\tif (ret)\n\t\ti2c->state = STATE_IDLE;\n\n\tif (i2c->error)\n\t\tret = i2c->error;\n\n\tspin_unlock_irqrestore(&i2c->lock, flags);\n\n\treturn ret;\n}\n\nstatic int meson_i2c_xfer_messages(struct i2c_adapter *adap,\n\t\t\t\t   struct i2c_msg *msgs, int num, bool atomic)\n{\n\tstruct meson_i2c *i2c = adap->algo_data;\n\tint i, ret = 0;\n\n\tfor (i = 0; i < num; i++) {\n\t\tret = meson_i2c_xfer_msg(i2c, msgs + i, i == num - 1, atomic);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret ?: i;\n}\n\nstatic int meson_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs,\n\t\t\t  int num)\n{\n\treturn meson_i2c_xfer_messages(adap, msgs, num, false);\n}\n\nstatic int meson_i2c_xfer_atomic(struct i2c_adapter *adap,\n\t\t\t\t struct i2c_msg *msgs, int num)\n{\n\treturn meson_i2c_xfer_messages(adap, msgs, num, true);\n}\n\nstatic u32 meson_i2c_func(struct i2c_adapter *adap)\n{\n\treturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;\n}\n\nstatic const struct i2c_algorithm meson_i2c_algorithm = {\n\t.master_xfer = meson_i2c_xfer,\n\t.master_xfer_atomic = meson_i2c_xfer_atomic,\n\t.functionality = meson_i2c_func,\n};\n\nstatic int meson_i2c_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct meson_i2c *i2c;\n\tstruct i2c_timings timings;\n\tint irq, ret = 0;\n\n\ti2c = devm_kzalloc(&pdev->dev, sizeof(struct meson_i2c), GFP_KERNEL);\n\tif (!i2c)\n\t\treturn -ENOMEM;\n\n\ti2c_parse_fw_timings(&pdev->dev, &timings, true);\n\n\ti2c->dev = &pdev->dev;\n\tplatform_set_drvdata(pdev, i2c);\n\n\tspin_lock_init(&i2c->lock);\n\tinit_completion(&i2c->done);\n\n\ti2c->data = (const struct meson_i2c_data *)\n\t\tof_device_get_match_data(&pdev->dev);\n\n\ti2c->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(i2c->clk)) {\n\t\tdev_err(&pdev->dev, \"can't get device clock\\n\");\n\t\treturn PTR_ERR(i2c->clk);\n\t}\n\n\ti2c->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(i2c->regs))\n\t\treturn PTR_ERR(i2c->regs);\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tret = devm_request_irq(&pdev->dev, irq, meson_i2c_irq, 0, NULL, i2c);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"can't request IRQ\\n\");\n\t\treturn ret;\n\t}\n\n\tret = clk_prepare_enable(i2c->clk);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"can't prepare clock\\n\");\n\t\treturn ret;\n\t}\n\n\tstrscpy(i2c->adap.name, \"Meson I2C adapter\",\n\t\tsizeof(i2c->adap.name));\n\ti2c->adap.owner = THIS_MODULE;\n\ti2c->adap.algo = &meson_i2c_algorithm;\n\ti2c->adap.dev.parent = &pdev->dev;\n\ti2c->adap.dev.of_node = np;\n\ti2c->adap.algo_data = i2c;\n\n\t \n\tmeson_i2c_set_mask(i2c, REG_CTRL, REG_CTRL_START, 0);\n\n\t \n\tmeson_i2c_set_mask(i2c, REG_SLAVE_ADDR,\n\t\t\t   REG_SLV_SDA_FILTER_MASK | REG_SLV_SCL_FILTER_MASK, 0);\n\n\tif (!i2c->data->set_clk_div) {\n\t\tclk_disable_unprepare(i2c->clk);\n\t\treturn -EINVAL;\n\t}\n\ti2c->data->set_clk_div(i2c, timings.bus_freq_hz);\n\n\tret = i2c_add_adapter(&i2c->adap);\n\tif (ret < 0) {\n\t\tclk_disable_unprepare(i2c->clk);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void meson_i2c_remove(struct platform_device *pdev)\n{\n\tstruct meson_i2c *i2c = platform_get_drvdata(pdev);\n\n\ti2c_del_adapter(&i2c->adap);\n\tclk_disable_unprepare(i2c->clk);\n}\n\nstatic const struct meson_i2c_data i2c_meson6_data = {\n\t.set_clk_div = meson6_i2c_set_clk_div,\n};\n\nstatic const struct meson_i2c_data i2c_gxbb_data = {\n\t.set_clk_div = meson_gxbb_axg_i2c_set_clk_div,\n};\n\nstatic const struct meson_i2c_data i2c_axg_data = {\n\t.set_clk_div = meson_gxbb_axg_i2c_set_clk_div,\n};\n\nstatic const struct of_device_id meson_i2c_match[] = {\n\t{ .compatible = \"amlogic,meson6-i2c\", .data = &i2c_meson6_data },\n\t{ .compatible = \"amlogic,meson-gxbb-i2c\", .data = &i2c_gxbb_data },\n\t{ .compatible = \"amlogic,meson-axg-i2c\", .data = &i2c_axg_data },\n\t{},\n};\n\nMODULE_DEVICE_TABLE(of, meson_i2c_match);\n\nstatic struct platform_driver meson_i2c_driver = {\n\t.probe   = meson_i2c_probe,\n\t.remove_new = meson_i2c_remove,\n\t.driver  = {\n\t\t.name  = \"meson-i2c\",\n\t\t.of_match_table = meson_i2c_match,\n\t},\n};\n\nmodule_platform_driver(meson_i2c_driver);\n\nMODULE_DESCRIPTION(\"Amlogic Meson I2C Bus driver\");\nMODULE_AUTHOR(\"Beniamino Galvani <b.galvani@gmail.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}