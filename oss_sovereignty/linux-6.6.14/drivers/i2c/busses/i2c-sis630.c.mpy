{
  "module_name": "i2c-sis630.c",
  "hash_id": "b7efa184cecd968ac6542ededbcd32354ef05ac686981afd4f846eea8aeab330",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-sis630.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/pci.h>\n#include <linux/ioport.h>\n#include <linux/i2c.h>\n#include <linux/acpi.h>\n#include <linux/io.h>\n\n \n#define PCI_DEVICE_ID_SI_964\t0x0964\n\n \n#define SMB_STS\t\t\t0x00\t \n#define SMB_CNT\t\t\t0x02\t \n#define SMBHOST_CNT\t\t0x03\t \n#define SMB_ADDR\t\t0x04\t \n#define SMB_CMD\t\t\t0x05\t \n#define SMB_COUNT\t\t0x07\t \n#define SMB_BYTE\t\t0x08\t \n\n \n#define BYTE_DONE_STS\t\t0x10\t \n#define SMBCOL_STS\t\t0x04\t \n#define SMBERR_STS\t\t0x02\t \n\n \n#define MSTO_EN\t\t\t0x40\t \n#define SMBCLK_SEL\t\t0x20\t \n#define SMB_PROBE\t\t0x02\t \n#define SMB_HOSTBUSY\t\t0x01\t \n\n \n#define SMB_KILL\t\t0x20\t \n#define SMB_START\t\t0x10\t \n\n \n#define SIS630_SMB_IOREGION\t20\n\n \n \n#define SIS630_ACPI_BASE_REG\t0x74\n \n#define SIS630_BIOS_CTL_REG\t0x40\n\n \n#define MAX_TIMEOUT\t\t500\n\n \n#define SIS630_QUICK\t\t0x00\n#define SIS630_BYTE\t\t0x01\n#define SIS630_BYTE_DATA\t0x02\n#define SIS630_WORD_DATA\t0x03\n#define SIS630_PCALL\t\t0x04\n#define SIS630_BLOCK_DATA\t0x05\n\nstatic struct pci_driver sis630_driver;\n\n \nstatic bool high_clock;\nstatic bool force;\nmodule_param(high_clock, bool, 0);\nMODULE_PARM_DESC(high_clock,\n\t\"Set Host Master Clock to 56KHz (default 14KHz) (SIS630/730 only).\");\nmodule_param(force, bool, 0);\nMODULE_PARM_DESC(force, \"Forcibly enable the SIS630. DANGEROUS!\");\n\n \nstatic unsigned short smbus_base;\n\n \nstatic int supported[] = {\n\tPCI_DEVICE_ID_SI_630,\n\tPCI_DEVICE_ID_SI_730,\n\tPCI_DEVICE_ID_SI_760,\n\t0  \n};\n\nstatic inline u8 sis630_read(u8 reg)\n{\n\treturn inb(smbus_base + reg);\n}\n\nstatic inline void sis630_write(u8 reg, u8 data)\n{\n\toutb(data, smbus_base + reg);\n}\n\nstatic int sis630_transaction_start(struct i2c_adapter *adap, int size,\n\t\t\t\t    u8 *oldclock)\n{\n\tint temp;\n\n\t \n\ttemp = sis630_read(SMB_CNT);\n\tif ((temp & (SMB_PROBE | SMB_HOSTBUSY)) != 0x00) {\n\t\tdev_dbg(&adap->dev, \"SMBus busy (%02x). Resetting...\\n\", temp);\n\t\t \n\t\tsis630_write(SMBHOST_CNT, SMB_KILL);\n\n\t\ttemp = sis630_read(SMB_CNT);\n\t\tif (temp & (SMB_PROBE | SMB_HOSTBUSY)) {\n\t\t\tdev_dbg(&adap->dev, \"Failed! (%02x)\\n\", temp);\n\t\t\treturn -EBUSY;\n\t\t} else {\n\t\t\tdev_dbg(&adap->dev, \"Successful!\\n\");\n\t\t}\n\t}\n\n\t \n\t*oldclock = sis630_read(SMB_CNT);\n\n\tdev_dbg(&adap->dev, \"saved clock 0x%02x\\n\", *oldclock);\n\n\t \n\tif (high_clock)\n\t\tsis630_write(SMB_CNT, SMBCLK_SEL);\n\telse\n\t\tsis630_write(SMB_CNT, (*oldclock & ~MSTO_EN));\n\n\t \n\ttemp = sis630_read(SMB_STS);\n\tsis630_write(SMB_STS, temp & 0x1e);\n\n\t \n\tsis630_write(SMBHOST_CNT, SMB_START | (size & 0x07));\n\n\treturn 0;\n}\n\nstatic int sis630_transaction_wait(struct i2c_adapter *adap, int size)\n{\n\tint temp, result = 0, timeout = 0;\n\n\t \n\tdo {\n\t\tmsleep(1);\n\t\ttemp = sis630_read(SMB_STS);\n\t\t \n\t\tif (size == SIS630_BLOCK_DATA && (temp & BYTE_DONE_STS))\n\t\t\tbreak;\n\t} while (!(temp & 0x0e) && (timeout++ < MAX_TIMEOUT));\n\n\t \n\tif (timeout > MAX_TIMEOUT) {\n\t\tdev_dbg(&adap->dev, \"SMBus Timeout!\\n\");\n\t\tresult = -ETIMEDOUT;\n\t}\n\n\tif (temp & SMBERR_STS) {\n\t\tdev_dbg(&adap->dev, \"Error: Failed bus transaction\\n\");\n\t\tresult = -ENXIO;\n\t}\n\n\tif (temp & SMBCOL_STS) {\n\t\tdev_err(&adap->dev, \"Bus collision!\\n\");\n\t\tresult = -EAGAIN;\n\t}\n\n\treturn result;\n}\n\nstatic void sis630_transaction_end(struct i2c_adapter *adap, u8 oldclock)\n{\n\t \n\tsis630_write(SMB_STS, 0xFF);\n\n\tdev_dbg(&adap->dev,\n\t\t\"SMB_CNT before clock restore 0x%02x\\n\", sis630_read(SMB_CNT));\n\n\t \n\tif (high_clock && !(oldclock & SMBCLK_SEL))\n\t\tsis630_write(SMB_CNT, sis630_read(SMB_CNT) & ~SMBCLK_SEL);\n\n\tdev_dbg(&adap->dev,\n\t\t\"SMB_CNT after clock restore 0x%02x\\n\", sis630_read(SMB_CNT));\n}\n\nstatic int sis630_transaction(struct i2c_adapter *adap, int size)\n{\n\tint result = 0;\n\tu8 oldclock = 0;\n\n\tresult = sis630_transaction_start(adap, size, &oldclock);\n\tif (!result) {\n\t\tresult = sis630_transaction_wait(adap, size);\n\t\tsis630_transaction_end(adap, oldclock);\n\t}\n\n\treturn result;\n}\n\nstatic int sis630_block_data(struct i2c_adapter *adap,\n\t\t\t     union i2c_smbus_data *data, int read_write)\n{\n\tint i, len = 0, rc = 0;\n\tu8 oldclock = 0;\n\n\tif (read_write == I2C_SMBUS_WRITE) {\n\t\tlen = data->block[0];\n\t\tif (len < 0)\n\t\t\tlen = 0;\n\t\telse if (len > 32)\n\t\t\tlen = 32;\n\t\tsis630_write(SMB_COUNT, len);\n\t\tfor (i = 1; i <= len; i++) {\n\t\t\tdev_dbg(&adap->dev,\n\t\t\t\t\"set data 0x%02x\\n\", data->block[i]);\n\t\t\t \n\t\t\tsis630_write(SMB_BYTE + (i - 1) % 8, data->block[i]);\n\t\t\tif (i == 8 || (len < 8 && i == len)) {\n\t\t\t\tdev_dbg(&adap->dev,\n\t\t\t\t\t\"start trans len=%d i=%d\\n\", len, i);\n\t\t\t\t \n\t\t\t\trc = sis630_transaction_start(adap,\n\t\t\t\t\t\tSIS630_BLOCK_DATA, &oldclock);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t} else if ((i - 1) % 8 == 7 || i == len) {\n\t\t\t\tdev_dbg(&adap->dev,\n\t\t\t\t\t\"trans_wait len=%d i=%d\\n\", len, i);\n\t\t\t\tif (i > 8) {\n\t\t\t\t\tdev_dbg(&adap->dev,\n\t\t\t\t\t\t\"clear smbary_sts\"\n\t\t\t\t\t\t\" len=%d i=%d\\n\", len, i);\n\t\t\t\t\t \n\t\t\t\t\tsis630_write(SMB_STS, BYTE_DONE_STS);\n\t\t\t\t}\n\t\t\t\trc = sis630_transaction_wait(adap,\n\t\t\t\t\t\tSIS630_BLOCK_DATA);\n\t\t\t\tif (rc) {\n\t\t\t\t\tdev_dbg(&adap->dev,\n\t\t\t\t\t\t\"trans_wait failed\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\t \n\t\tdata->block[0] = len = 0;\n\t\trc = sis630_transaction_start(adap,\n\t\t\t\tSIS630_BLOCK_DATA, &oldclock);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tdo {\n\t\t\trc = sis630_transaction_wait(adap, SIS630_BLOCK_DATA);\n\t\t\tif (rc) {\n\t\t\t\tdev_dbg(&adap->dev, \"trans_wait failed\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t \n\t\t\tif (len == 0)\n\t\t\t\tdata->block[0] = sis630_read(SMB_COUNT);\n\n\t\t\t \n\t\t\tif (data->block[0] > 32)\n\t\t\t\tdata->block[0] = 32;\n\n\t\t\tdev_dbg(&adap->dev,\n\t\t\t\t\"block data read len=0x%x\\n\", data->block[0]);\n\n\t\t\tfor (i = 0; i < 8 && len < data->block[0]; i++, len++) {\n\t\t\t\tdev_dbg(&adap->dev,\n\t\t\t\t\t\"read i=%d len=%d\\n\", i, len);\n\t\t\t\tdata->block[len + 1] = sis630_read(SMB_BYTE +\n\t\t\t\t\t\t\t\t   i);\n\t\t\t}\n\n\t\t\tdev_dbg(&adap->dev,\n\t\t\t\t\"clear smbary_sts len=%d i=%d\\n\", len, i);\n\n\t\t\t \n\t\t\tsis630_write(SMB_STS, BYTE_DONE_STS);\n\t\t} while (len < data->block[0]);\n\t}\n\n\tsis630_transaction_end(adap, oldclock);\n\n\treturn rc;\n}\n\n \nstatic s32 sis630_access(struct i2c_adapter *adap, u16 addr,\n\t\t\t unsigned short flags, char read_write,\n\t\t\t u8 command, int size, union i2c_smbus_data *data)\n{\n\tint status;\n\n\tswitch (size) {\n\tcase I2C_SMBUS_QUICK:\n\t\tsis630_write(SMB_ADDR,\n\t\t\t     ((addr & 0x7f) << 1) | (read_write & 0x01));\n\t\tsize = SIS630_QUICK;\n\t\tbreak;\n\tcase I2C_SMBUS_BYTE:\n\t\tsis630_write(SMB_ADDR,\n\t\t\t     ((addr & 0x7f) << 1) | (read_write & 0x01));\n\t\tif (read_write == I2C_SMBUS_WRITE)\n\t\t\tsis630_write(SMB_CMD, command);\n\t\tsize = SIS630_BYTE;\n\t\tbreak;\n\tcase I2C_SMBUS_BYTE_DATA:\n\t\tsis630_write(SMB_ADDR,\n\t\t\t     ((addr & 0x7f) << 1) | (read_write & 0x01));\n\t\tsis630_write(SMB_CMD, command);\n\t\tif (read_write == I2C_SMBUS_WRITE)\n\t\t\tsis630_write(SMB_BYTE, data->byte);\n\t\tsize = SIS630_BYTE_DATA;\n\t\tbreak;\n\tcase I2C_SMBUS_PROC_CALL:\n\tcase I2C_SMBUS_WORD_DATA:\n\t\tsis630_write(SMB_ADDR,\n\t\t\t     ((addr & 0x7f) << 1) | (read_write & 0x01));\n\t\tsis630_write(SMB_CMD, command);\n\t\tif (read_write == I2C_SMBUS_WRITE) {\n\t\t\tsis630_write(SMB_BYTE, data->word & 0xff);\n\t\t\tsis630_write(SMB_BYTE + 1, (data->word & 0xff00) >> 8);\n\t\t}\n\t\tsize = (size == I2C_SMBUS_PROC_CALL ?\n\t\t\tSIS630_PCALL : SIS630_WORD_DATA);\n\t\tbreak;\n\tcase I2C_SMBUS_BLOCK_DATA:\n\t\tsis630_write(SMB_ADDR,\n\t\t\t     ((addr & 0x7f) << 1) | (read_write & 0x01));\n\t\tsis630_write(SMB_CMD, command);\n\t\tsize = SIS630_BLOCK_DATA;\n\t\treturn sis630_block_data(adap, data, read_write);\n\tdefault:\n\t\tdev_warn(&adap->dev, \"Unsupported transaction %d\\n\", size);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tstatus = sis630_transaction(adap, size);\n\tif (status)\n\t\treturn status;\n\n\tif ((size != SIS630_PCALL) &&\n\t\t((read_write == I2C_SMBUS_WRITE) || (size == SIS630_QUICK))) {\n\t\treturn 0;\n\t}\n\n\tswitch (size) {\n\tcase SIS630_BYTE:\n\tcase SIS630_BYTE_DATA:\n\t\tdata->byte = sis630_read(SMB_BYTE);\n\t\tbreak;\n\tcase SIS630_PCALL:\n\tcase SIS630_WORD_DATA:\n\t\tdata->word = sis630_read(SMB_BYTE) +\n\t\t\t     (sis630_read(SMB_BYTE + 1) << 8);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic u32 sis630_func(struct i2c_adapter *adapter)\n{\n\treturn I2C_FUNC_SMBUS_QUICK | I2C_FUNC_SMBUS_BYTE |\n\t\tI2C_FUNC_SMBUS_BYTE_DATA | I2C_FUNC_SMBUS_WORD_DATA |\n\t\tI2C_FUNC_SMBUS_PROC_CALL | I2C_FUNC_SMBUS_BLOCK_DATA;\n}\n\nstatic int sis630_setup(struct pci_dev *sis630_dev)\n{\n\tunsigned char b;\n\tstruct pci_dev *dummy = NULL;\n\tint retval, i;\n\t \n\tunsigned short acpi_base;\n\n\t \n\tfor (i = 0; supported[i] > 0; i++) {\n\t\tdummy = pci_get_device(PCI_VENDOR_ID_SI, supported[i], dummy);\n\t\tif (dummy)\n\t\t\tbreak;  \n\t}\n\n\tif (dummy) {\n\t\tpci_dev_put(dummy);\n\t} else if (force) {\n\t\tdev_err(&sis630_dev->dev,\n\t\t\t\"WARNING: Can't detect SIS630 compatible device, but \"\n\t\t\t\"loading because of force option enabled\\n\");\n\t} else {\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tif (pci_read_config_byte(sis630_dev, SIS630_BIOS_CTL_REG, &b)) {\n\t\tdev_err(&sis630_dev->dev, \"Error: Can't read bios ctl reg\\n\");\n\t\tretval = -ENODEV;\n\t\tgoto exit;\n\t}\n\t \n\tif (!(b & 0x80) &&\n\t    pci_write_config_byte(sis630_dev, SIS630_BIOS_CTL_REG, b | 0x80)) {\n\t\tdev_err(&sis630_dev->dev, \"Error: Can't enable ACPI\\n\");\n\t\tretval = -ENODEV;\n\t\tgoto exit;\n\t}\n\n\t \n\tif (pci_read_config_word(sis630_dev,\n\t\t\t\t SIS630_ACPI_BASE_REG, &acpi_base)) {\n\t\tdev_err(&sis630_dev->dev,\n\t\t\t\"Error: Can't determine ACPI base address\\n\");\n\t\tretval = -ENODEV;\n\t\tgoto exit;\n\t}\n\n\tdev_dbg(&sis630_dev->dev, \"ACPI base at 0x%04hx\\n\", acpi_base);\n\n\tif (supported[i] == PCI_DEVICE_ID_SI_760)\n\t\tsmbus_base = acpi_base + 0xE0;\n\telse\n\t\tsmbus_base = acpi_base + 0x80;\n\n\tdev_dbg(&sis630_dev->dev, \"SMBus base at 0x%04hx\\n\", smbus_base);\n\n\tretval = acpi_check_region(smbus_base + SMB_STS, SIS630_SMB_IOREGION,\n\t\t\t\t   sis630_driver.name);\n\tif (retval)\n\t\tgoto exit;\n\n\t \n\tif (!request_region(smbus_base + SMB_STS, SIS630_SMB_IOREGION,\n\t\t\t    sis630_driver.name)) {\n\t\tdev_err(&sis630_dev->dev,\n\t\t\t\"I/O Region 0x%04x-0x%04x for SMBus already in use.\\n\",\n\t\t\tsmbus_base + SMB_STS,\n\t\t\tsmbus_base + SMB_STS + SIS630_SMB_IOREGION - 1);\n\t\tretval = -EBUSY;\n\t\tgoto exit;\n\t}\n\n\tretval = 0;\n\nexit:\n\tif (retval)\n\t\tsmbus_base = 0;\n\treturn retval;\n}\n\n\nstatic const struct i2c_algorithm smbus_algorithm = {\n\t.smbus_xfer\t= sis630_access,\n\t.functionality\t= sis630_func,\n};\n\nstatic struct i2c_adapter sis630_adapter = {\n\t.owner\t\t= THIS_MODULE,\n\t.class\t\t= I2C_CLASS_HWMON | I2C_CLASS_SPD,\n\t.algo\t\t= &smbus_algorithm,\n\t.retries\t= 3\n};\n\nstatic const struct pci_device_id sis630_ids[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_SI, PCI_DEVICE_ID_SI_503) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_SI, PCI_DEVICE_ID_SI_LPC) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_SI, PCI_DEVICE_ID_SI_964) },\n\t{ 0, }\n};\n\nMODULE_DEVICE_TABLE(pci, sis630_ids);\n\nstatic int sis630_probe(struct pci_dev *dev, const struct pci_device_id *id)\n{\n\tif (sis630_setup(dev)) {\n\t\tdev_err(&dev->dev,\n\t\t\t\"SIS630 compatible bus not detected, \"\n\t\t\t\"module not inserted.\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tsis630_adapter.dev.parent = &dev->dev;\n\n\tsnprintf(sis630_adapter.name, sizeof(sis630_adapter.name),\n\t\t \"SMBus SIS630 adapter at %04x\", smbus_base + SMB_STS);\n\n\treturn i2c_add_adapter(&sis630_adapter);\n}\n\nstatic void sis630_remove(struct pci_dev *dev)\n{\n\tif (smbus_base) {\n\t\ti2c_del_adapter(&sis630_adapter);\n\t\trelease_region(smbus_base + SMB_STS, SIS630_SMB_IOREGION);\n\t\tsmbus_base = 0;\n\t}\n}\n\n\nstatic struct pci_driver sis630_driver = {\n\t.name\t\t= \"sis630_smbus\",\n\t.id_table\t= sis630_ids,\n\t.probe\t\t= sis630_probe,\n\t.remove\t\t= sis630_remove,\n};\n\nmodule_pci_driver(sis630_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Alexander Malysh <amalysh@web.de>\");\nMODULE_DESCRIPTION(\"SIS630 SMBus driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}