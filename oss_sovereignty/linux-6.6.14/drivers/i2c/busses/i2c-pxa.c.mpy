{
  "module_name": "i2c-pxa.c",
  "hash_id": "eed08d45964040992e19e565d909e2458c4d537fa41309a7ef65733d6b9f9d40",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-pxa.c",
  "human_readable_source": "\n \n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/platform_device.h>\n#include <linux/platform_data/i2c-pxa.h>\n#include <linux/slab.h>\n\n \n#define IBMR_SDAS\t(1 << 0)\n#define IBMR_SCLS\t(1 << 1)\n\n#define ICR_START\t(1 << 0)\t    \n#define ICR_STOP\t(1 << 1)\t    \n#define ICR_ACKNAK\t(1 << 2)\t    \n#define ICR_TB\t\t(1 << 3)\t    \n#define ICR_MA\t\t(1 << 4)\t    \n#define ICR_SCLE\t(1 << 5)\t    \n#define ICR_IUE\t\t(1 << 6)\t    \n#define ICR_GCD\t\t(1 << 7)\t    \n#define ICR_ITEIE\t(1 << 8)\t    \n#define ICR_IRFIE\t(1 << 9)\t    \n#define ICR_BEIE\t(1 << 10)\t    \n#define ICR_SSDIE\t(1 << 11)\t    \n#define ICR_ALDIE\t(1 << 12)\t    \n#define ICR_SADIE\t(1 << 13)\t    \n#define ICR_UR\t\t(1 << 14)\t    \n#define ICR_FM\t\t(1 << 15)\t    \n#define ICR_HS\t\t(1 << 16)\t    \n#define ICR_A3700_FM\t(1 << 16)\t    \n#define ICR_A3700_HS\t(1 << 17)\t    \n#define ICR_GPIOEN\t(1 << 19)\t    \n\n#define ISR_RWM\t\t(1 << 0)\t    \n#define ISR_ACKNAK\t(1 << 1)\t    \n#define ISR_UB\t\t(1 << 2)\t    \n#define ISR_IBB\t\t(1 << 3)\t    \n#define ISR_SSD\t\t(1 << 4)\t    \n#define ISR_ALD\t\t(1 << 5)\t    \n#define ISR_ITE\t\t(1 << 6)\t    \n#define ISR_IRF\t\t(1 << 7)\t    \n#define ISR_GCAD\t(1 << 8)\t    \n#define ISR_SAD\t\t(1 << 9)\t    \n#define ISR_BED\t\t(1 << 10)\t    \n\n#define ILCR_SLV_SHIFT\t\t0\n#define ILCR_SLV_MASK\t\t(0x1FF << ILCR_SLV_SHIFT)\n#define ILCR_FLV_SHIFT\t\t9\n#define ILCR_FLV_MASK\t\t(0x1FF << ILCR_FLV_SHIFT)\n#define ILCR_HLVL_SHIFT\t\t18\n#define ILCR_HLVL_MASK\t\t(0x1FF << ILCR_HLVL_SHIFT)\n#define ILCR_HLVH_SHIFT\t\t27\n#define ILCR_HLVH_MASK\t\t(0x1F << ILCR_HLVH_SHIFT)\n\n#define IWCR_CNT_SHIFT\t\t0\n#define IWCR_CNT_MASK\t\t(0x1F << IWCR_CNT_SHIFT)\n#define IWCR_HS_CNT1_SHIFT\t5\n#define IWCR_HS_CNT1_MASK\t(0x1F << IWCR_HS_CNT1_SHIFT)\n#define IWCR_HS_CNT2_SHIFT\t10\n#define IWCR_HS_CNT2_MASK\t(0x1F << IWCR_HS_CNT2_SHIFT)\n\n \n#define DEF_TIMEOUT             32\n\n#define NO_SLAVE\t\t(-ENXIO)\n#define BUS_ERROR               (-EREMOTEIO)\n#define XFER_NAKED              (-ECONNREFUSED)\n#define I2C_RETRY               (-2000)  \n\n \n#define I2C_ICR_INIT\t(ICR_BEIE | ICR_IRFIE | ICR_ITEIE | ICR_GCD | ICR_SCLE)\n\n \n#define I2C_ISR_INIT\t0x7FF   \n\nstruct pxa_reg_layout {\n\tu32 ibmr;\n\tu32 idbr;\n\tu32 icr;\n\tu32 isr;\n\tu32 isar;\n\tu32 ilcr;\n\tu32 iwcr;\n\tu32 fm;\n\tu32 hs;\n};\n\nenum pxa_i2c_types {\n\tREGS_PXA2XX,\n\tREGS_PXA3XX,\n\tREGS_CE4100,\n\tREGS_PXA910,\n\tREGS_A3700,\n};\n\n \nstatic struct pxa_reg_layout pxa_reg_layout[] = {\n\t[REGS_PXA2XX] = {\n\t\t.ibmr =\t0x00,\n\t\t.idbr =\t0x08,\n\t\t.icr =\t0x10,\n\t\t.isr =\t0x18,\n\t\t.isar =\t0x20,\n\t\t.fm = ICR_FM,\n\t\t.hs = ICR_HS,\n\t},\n\t[REGS_PXA3XX] = {\n\t\t.ibmr =\t0x00,\n\t\t.idbr =\t0x04,\n\t\t.icr =\t0x08,\n\t\t.isr =\t0x0c,\n\t\t.isar =\t0x10,\n\t\t.fm = ICR_FM,\n\t\t.hs = ICR_HS,\n\t},\n\t[REGS_CE4100] = {\n\t\t.ibmr =\t0x14,\n\t\t.idbr =\t0x0c,\n\t\t.icr =\t0x00,\n\t\t.isr =\t0x04,\n\t\t \n\t\t.fm = ICR_FM,\n\t\t.hs = ICR_HS,\n\t},\n\t[REGS_PXA910] = {\n\t\t.ibmr = 0x00,\n\t\t.idbr = 0x08,\n\t\t.icr =\t0x10,\n\t\t.isr =\t0x18,\n\t\t.isar = 0x20,\n\t\t.ilcr = 0x28,\n\t\t.iwcr = 0x30,\n\t\t.fm = ICR_FM,\n\t\t.hs = ICR_HS,\n\t},\n\t[REGS_A3700] = {\n\t\t.ibmr =\t0x00,\n\t\t.idbr =\t0x04,\n\t\t.icr =\t0x08,\n\t\t.isr =\t0x0c,\n\t\t.isar =\t0x10,\n\t\t.fm = ICR_A3700_FM,\n\t\t.hs = ICR_A3700_HS,\n\t},\n};\n\nstatic const struct of_device_id i2c_pxa_dt_ids[] = {\n\t{ .compatible = \"mrvl,pxa-i2c\", .data = (void *)REGS_PXA2XX },\n\t{ .compatible = \"mrvl,pwri2c\", .data = (void *)REGS_PXA3XX },\n\t{ .compatible = \"mrvl,mmp-twsi\", .data = (void *)REGS_PXA910 },\n\t{ .compatible = \"marvell,armada-3700-i2c\", .data = (void *)REGS_A3700 },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, i2c_pxa_dt_ids);\n\nstatic const struct platform_device_id i2c_pxa_id_table[] = {\n\t{ \"pxa2xx-i2c\",\t\tREGS_PXA2XX },\n\t{ \"pxa3xx-pwri2c\",\tREGS_PXA3XX },\n\t{ \"ce4100-i2c\",\t\tREGS_CE4100 },\n\t{ \"pxa910-i2c\",\t\tREGS_PXA910 },\n\t{ \"armada-3700-i2c\",\tREGS_A3700  },\n\t{ },\n};\nMODULE_DEVICE_TABLE(platform, i2c_pxa_id_table);\n\nstruct pxa_i2c {\n\tspinlock_t\t\tlock;\n\twait_queue_head_t\twait;\n\tstruct i2c_msg\t\t*msg;\n\tunsigned int\t\tmsg_num;\n\tunsigned int\t\tmsg_idx;\n\tunsigned int\t\tmsg_ptr;\n\tunsigned int\t\tslave_addr;\n\tunsigned int\t\treq_slave_addr;\n\n\tstruct i2c_adapter\tadap;\n\tstruct clk\t\t*clk;\n#ifdef CONFIG_I2C_PXA_SLAVE\n\tstruct i2c_client\t*slave;\n#endif\n\n\tunsigned int\t\tirqlogidx;\n\tu32\t\t\tisrlog[32];\n\tu32\t\t\ticrlog[32];\n\n\tvoid __iomem\t\t*reg_base;\n\tvoid __iomem\t\t*reg_ibmr;\n\tvoid __iomem\t\t*reg_idbr;\n\tvoid __iomem\t\t*reg_icr;\n\tvoid __iomem\t\t*reg_isr;\n\tvoid __iomem\t\t*reg_isar;\n\tvoid __iomem\t\t*reg_ilcr;\n\tvoid __iomem\t\t*reg_iwcr;\n\n\tunsigned long\t\tiobase;\n\tunsigned long\t\tiosize;\n\n\tint\t\t\tirq;\n\tunsigned int\t\tuse_pio :1;\n\tunsigned int\t\tfast_mode :1;\n\tunsigned int\t\thigh_mode:1;\n\tunsigned char\t\tmaster_code;\n\tunsigned long\t\trate;\n\tbool\t\t\thighmode_enter;\n\tu32\t\t\tfm_mask;\n\tu32\t\t\ths_mask;\n\n\tstruct i2c_bus_recovery_info recovery;\n\tstruct pinctrl\t\t*pinctrl;\n\tstruct pinctrl_state\t*pinctrl_default;\n\tstruct pinctrl_state\t*pinctrl_recovery;\n};\n\n#define _IBMR(i2c)\t((i2c)->reg_ibmr)\n#define _IDBR(i2c)\t((i2c)->reg_idbr)\n#define _ICR(i2c)\t((i2c)->reg_icr)\n#define _ISR(i2c)\t((i2c)->reg_isr)\n#define _ISAR(i2c)\t((i2c)->reg_isar)\n#define _ILCR(i2c)\t((i2c)->reg_ilcr)\n#define _IWCR(i2c)\t((i2c)->reg_iwcr)\n\n \n#define I2C_PXA_SLAVE_ADDR      0x1\n\n#ifdef DEBUG\n\nstruct bits {\n\tu32\tmask;\n\tconst char *set;\n\tconst char *unset;\n};\n#define PXA_BIT(m, s, u)\t{ .mask = m, .set = s, .unset = u }\n\nstatic inline void\ndecode_bits(const char *prefix, const struct bits *bits, int num, u32 val)\n{\n\tprintk(\"%s %08x:\", prefix, val);\n\twhile (num--) {\n\t\tconst char *str = val & bits->mask ? bits->set : bits->unset;\n\t\tif (str)\n\t\t\tpr_cont(\" %s\", str);\n\t\tbits++;\n\t}\n\tpr_cont(\"\\n\");\n}\n\nstatic const struct bits isr_bits[] = {\n\tPXA_BIT(ISR_RWM,\t\"RX\",\t\t\"TX\"),\n\tPXA_BIT(ISR_ACKNAK,\t\"NAK\",\t\t\"ACK\"),\n\tPXA_BIT(ISR_UB,\t\t\"Bsy\",\t\t\"Rdy\"),\n\tPXA_BIT(ISR_IBB,\t\"BusBsy\",\t\"BusRdy\"),\n\tPXA_BIT(ISR_SSD,\t\"SlaveStop\",\tNULL),\n\tPXA_BIT(ISR_ALD,\t\"ALD\",\t\tNULL),\n\tPXA_BIT(ISR_ITE,\t\"TxEmpty\",\tNULL),\n\tPXA_BIT(ISR_IRF,\t\"RxFull\",\tNULL),\n\tPXA_BIT(ISR_GCAD,\t\"GenCall\",\tNULL),\n\tPXA_BIT(ISR_SAD,\t\"SlaveAddr\",\tNULL),\n\tPXA_BIT(ISR_BED,\t\"BusErr\",\tNULL),\n};\n\nstatic void decode_ISR(unsigned int val)\n{\n\tdecode_bits(KERN_DEBUG \"ISR\", isr_bits, ARRAY_SIZE(isr_bits), val);\n}\n\nstatic const struct bits icr_bits[] = {\n\tPXA_BIT(ICR_START,  \"START\",\tNULL),\n\tPXA_BIT(ICR_STOP,   \"STOP\",\tNULL),\n\tPXA_BIT(ICR_ACKNAK, \"ACKNAK\",\tNULL),\n\tPXA_BIT(ICR_TB,     \"TB\",\tNULL),\n\tPXA_BIT(ICR_MA,     \"MA\",\tNULL),\n\tPXA_BIT(ICR_SCLE,   \"SCLE\",\t\"scle\"),\n\tPXA_BIT(ICR_IUE,    \"IUE\",\t\"iue\"),\n\tPXA_BIT(ICR_GCD,    \"GCD\",\tNULL),\n\tPXA_BIT(ICR_ITEIE,  \"ITEIE\",\tNULL),\n\tPXA_BIT(ICR_IRFIE,  \"IRFIE\",\tNULL),\n\tPXA_BIT(ICR_BEIE,   \"BEIE\",\tNULL),\n\tPXA_BIT(ICR_SSDIE,  \"SSDIE\",\tNULL),\n\tPXA_BIT(ICR_ALDIE,  \"ALDIE\",\tNULL),\n\tPXA_BIT(ICR_SADIE,  \"SADIE\",\tNULL),\n\tPXA_BIT(ICR_UR,     \"UR\",\t\t\"ur\"),\n};\n\n#ifdef CONFIG_I2C_PXA_SLAVE\nstatic void decode_ICR(unsigned int val)\n{\n\tdecode_bits(KERN_DEBUG \"ICR\", icr_bits, ARRAY_SIZE(icr_bits), val);\n}\n#endif\n\nstatic unsigned int i2c_debug = DEBUG;\n\nstatic void i2c_pxa_show_state(struct pxa_i2c *i2c, int lno, const char *fname)\n{\n\tdev_dbg(&i2c->adap.dev, \"state:%s:%d: ISR=%08x, ICR=%08x, IBMR=%02x\\n\", fname, lno,\n\t\treadl(_ISR(i2c)), readl(_ICR(i2c)), readl(_IBMR(i2c)));\n}\n\n#define show_state(i2c) i2c_pxa_show_state(i2c, __LINE__, __func__)\n\nstatic void i2c_pxa_scream_blue_murder(struct pxa_i2c *i2c, const char *why)\n{\n\tunsigned int i;\n\tstruct device *dev = &i2c->adap.dev;\n\n\tdev_err(dev, \"slave_0x%x error: %s\\n\",\n\t\ti2c->req_slave_addr >> 1, why);\n\tdev_err(dev, \"msg_num: %d msg_idx: %d msg_ptr: %d\\n\",\n\t\ti2c->msg_num, i2c->msg_idx, i2c->msg_ptr);\n\tdev_err(dev, \"IBMR: %08x IDBR: %08x ICR: %08x ISR: %08x\\n\",\n\t\treadl(_IBMR(i2c)), readl(_IDBR(i2c)), readl(_ICR(i2c)),\n\t\treadl(_ISR(i2c)));\n\tdev_err(dev, \"log:\");\n\tfor (i = 0; i < i2c->irqlogidx; i++)\n\t\tpr_cont(\" [%03x:%05x]\", i2c->isrlog[i], i2c->icrlog[i]);\n\tpr_cont(\"\\n\");\n}\n\n#else  \n\n#define i2c_debug\t0\n\n#define show_state(i2c) do { } while (0)\n#define decode_ISR(val) do { } while (0)\n#define decode_ICR(val) do { } while (0)\n#define i2c_pxa_scream_blue_murder(i2c, why) do { } while (0)\n\n#endif  \n\nstatic void i2c_pxa_master_complete(struct pxa_i2c *i2c, int ret);\n\nstatic inline int i2c_pxa_is_slavemode(struct pxa_i2c *i2c)\n{\n\treturn !(readl(_ICR(i2c)) & ICR_SCLE);\n}\n\nstatic void i2c_pxa_abort(struct pxa_i2c *i2c)\n{\n\tint i = 250;\n\n\tif (i2c_pxa_is_slavemode(i2c)) {\n\t\tdev_dbg(&i2c->adap.dev, \"%s: called in slave mode\\n\", __func__);\n\t\treturn;\n\t}\n\n\twhile ((i > 0) && (readl(_IBMR(i2c)) & IBMR_SDAS) == 0) {\n\t\tunsigned long icr = readl(_ICR(i2c));\n\n\t\ticr &= ~ICR_START;\n\t\ticr |= ICR_ACKNAK | ICR_STOP | ICR_TB;\n\n\t\twritel(icr, _ICR(i2c));\n\n\t\tshow_state(i2c);\n\n\t\tmdelay(1);\n\t\ti --;\n\t}\n\n\twritel(readl(_ICR(i2c)) & ~(ICR_MA | ICR_START | ICR_STOP),\n\t       _ICR(i2c));\n}\n\nstatic int i2c_pxa_wait_bus_not_busy(struct pxa_i2c *i2c)\n{\n\tint timeout = DEF_TIMEOUT;\n\tu32 isr;\n\n\twhile (1) {\n\t\tisr = readl(_ISR(i2c));\n\t\tif (!(isr & (ISR_IBB | ISR_UB)))\n\t\t\treturn 0;\n\n\t\tif (isr & ISR_SAD)\n\t\t\ttimeout += 4;\n\n\t\tif (!timeout--)\n\t\t\tbreak;\n\n\t\tmsleep(2);\n\t\tshow_state(i2c);\n\t}\n\n\tshow_state(i2c);\n\n\treturn I2C_RETRY;\n}\n\nstatic int i2c_pxa_wait_master(struct pxa_i2c *i2c)\n{\n\tunsigned long timeout = jiffies + HZ*4;\n\n\twhile (time_before(jiffies, timeout)) {\n\t\tif (i2c_debug > 1)\n\t\t\tdev_dbg(&i2c->adap.dev, \"%s: %ld: ISR=%08x, ICR=%08x, IBMR=%02x\\n\",\n\t\t\t\t__func__, (long)jiffies, readl(_ISR(i2c)), readl(_ICR(i2c)), readl(_IBMR(i2c)));\n\n\t\tif (readl(_ISR(i2c)) & ISR_SAD) {\n\t\t\tif (i2c_debug > 0)\n\t\t\t\tdev_dbg(&i2c->adap.dev, \"%s: Slave detected\\n\", __func__);\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tif ((readl(_ISR(i2c)) & (ISR_UB | ISR_IBB)) == 0 &&\n\t\t    readl(_IBMR(i2c)) == (IBMR_SCLS | IBMR_SDAS)) {\n\t\t\tif (i2c_debug > 0)\n\t\t\t\tdev_dbg(&i2c->adap.dev, \"%s: done\\n\", __func__);\n\t\t\treturn 1;\n\t\t}\n\n\t\tmsleep(1);\n\t}\n\n\tif (i2c_debug > 0)\n\t\tdev_dbg(&i2c->adap.dev, \"%s: did not free\\n\", __func__);\n out:\n\treturn 0;\n}\n\nstatic int i2c_pxa_set_master(struct pxa_i2c *i2c)\n{\n\tif (i2c_debug)\n\t\tdev_dbg(&i2c->adap.dev, \"setting to bus master\\n\");\n\n\tif ((readl(_ISR(i2c)) & (ISR_UB | ISR_IBB)) != 0) {\n\t\tdev_dbg(&i2c->adap.dev, \"%s: unit is busy\\n\", __func__);\n\t\tif (!i2c_pxa_wait_master(i2c)) {\n\t\t\tdev_dbg(&i2c->adap.dev, \"%s: error: unit busy\\n\", __func__);\n\t\t\treturn I2C_RETRY;\n\t\t}\n\t}\n\n\twritel(readl(_ICR(i2c)) | ICR_SCLE, _ICR(i2c));\n\treturn 0;\n}\n\n#ifdef CONFIG_I2C_PXA_SLAVE\nstatic int i2c_pxa_wait_slave(struct pxa_i2c *i2c)\n{\n\tunsigned long timeout = jiffies + HZ*1;\n\n\t \n\n\tshow_state(i2c);\n\n\twhile (time_before(jiffies, timeout)) {\n\t\tif (i2c_debug > 1)\n\t\t\tdev_dbg(&i2c->adap.dev, \"%s: %ld: ISR=%08x, ICR=%08x, IBMR=%02x\\n\",\n\t\t\t\t__func__, (long)jiffies, readl(_ISR(i2c)), readl(_ICR(i2c)), readl(_IBMR(i2c)));\n\n\t\tif ((readl(_ISR(i2c)) & (ISR_UB|ISR_IBB)) == 0 ||\n\t\t    (readl(_ISR(i2c)) & ISR_SAD) != 0 ||\n\t\t    (readl(_ICR(i2c)) & ICR_SCLE) == 0) {\n\t\t\tif (i2c_debug > 1)\n\t\t\t\tdev_dbg(&i2c->adap.dev, \"%s: done\\n\", __func__);\n\t\t\treturn 1;\n\t\t}\n\n\t\tmsleep(1);\n\t}\n\n\tif (i2c_debug > 0)\n\t\tdev_dbg(&i2c->adap.dev, \"%s: did not free\\n\", __func__);\n\treturn 0;\n}\n\n \nstatic void i2c_pxa_set_slave(struct pxa_i2c *i2c, int errcode)\n{\n\tshow_state(i2c);\n\n\tif (errcode < 0) {\n\t\tudelay(100);    \n\t} else {\n\t\t \n\n\t\t \n\t\tif (readl(_ICR(i2c)) & ICR_STOP) {\n\t\t\tudelay(100);\n\t\t\twritel(readl(_ICR(i2c)) & ~ICR_STOP, _ICR(i2c));\n\t\t}\n\n\t\tif (!i2c_pxa_wait_slave(i2c)) {\n\t\t\tdev_err(&i2c->adap.dev, \"%s: wait timedout\\n\",\n\t\t\t\t__func__);\n\t\t\treturn;\n\t\t}\n\t}\n\n\twritel(readl(_ICR(i2c)) & ~(ICR_STOP|ICR_ACKNAK|ICR_MA), _ICR(i2c));\n\twritel(readl(_ICR(i2c)) & ~ICR_SCLE, _ICR(i2c));\n\n\tif (i2c_debug) {\n\t\tdev_dbg(&i2c->adap.dev, \"ICR now %08x, ISR %08x\\n\", readl(_ICR(i2c)), readl(_ISR(i2c)));\n\t\tdecode_ICR(readl(_ICR(i2c)));\n\t}\n}\n#else\n#define i2c_pxa_set_slave(i2c, err)\tdo { } while (0)\n#endif\n\nstatic void i2c_pxa_do_reset(struct pxa_i2c *i2c)\n{\n\t \n\twritel(ICR_UR, _ICR(i2c));\n\twritel(I2C_ISR_INIT, _ISR(i2c));\n\twritel(readl(_ICR(i2c)) & ~ICR_UR, _ICR(i2c));\n\n\tif (i2c->reg_isar && IS_ENABLED(CONFIG_I2C_PXA_SLAVE))\n\t\twritel(i2c->slave_addr, _ISAR(i2c));\n\n\t \n\twritel(I2C_ICR_INIT | (i2c->fast_mode ? i2c->fm_mask : 0), _ICR(i2c));\n\twritel(readl(_ICR(i2c)) | (i2c->high_mode ? i2c->hs_mask : 0), _ICR(i2c));\n\n#ifdef CONFIG_I2C_PXA_SLAVE\n\tdev_info(&i2c->adap.dev, \"Enabling slave mode\\n\");\n\twritel(readl(_ICR(i2c)) | ICR_SADIE | ICR_ALDIE | ICR_SSDIE, _ICR(i2c));\n#endif\n\n\ti2c_pxa_set_slave(i2c, 0);\n}\n\nstatic void i2c_pxa_enable(struct pxa_i2c *i2c)\n{\n\t \n\twritel(readl(_ICR(i2c)) | ICR_IUE, _ICR(i2c));\n\tudelay(100);\n}\n\nstatic void i2c_pxa_reset(struct pxa_i2c *i2c)\n{\n\tpr_debug(\"Resetting I2C Controller Unit\\n\");\n\n\t \n\ti2c_pxa_abort(i2c);\n\ti2c_pxa_do_reset(i2c);\n\ti2c_pxa_enable(i2c);\n}\n\n\n#ifdef CONFIG_I2C_PXA_SLAVE\n \n\nstatic void i2c_pxa_slave_txempty(struct pxa_i2c *i2c, u32 isr)\n{\n\tif (isr & ISR_BED) {\n\t\t \n\t} else {\n\t\tu8 byte = 0;\n\n\t\tif (i2c->slave != NULL)\n\t\t\ti2c_slave_event(i2c->slave, I2C_SLAVE_READ_PROCESSED,\n\t\t\t\t\t&byte);\n\n\t\twritel(byte, _IDBR(i2c));\n\t\twritel(readl(_ICR(i2c)) | ICR_TB, _ICR(i2c));    \n\t}\n}\n\nstatic void i2c_pxa_slave_rxfull(struct pxa_i2c *i2c, u32 isr)\n{\n\tu8 byte = readl(_IDBR(i2c));\n\n\tif (i2c->slave != NULL)\n\t\ti2c_slave_event(i2c->slave, I2C_SLAVE_WRITE_RECEIVED, &byte);\n\n\twritel(readl(_ICR(i2c)) | ICR_TB, _ICR(i2c));\n}\n\nstatic void i2c_pxa_slave_start(struct pxa_i2c *i2c, u32 isr)\n{\n\tint timeout;\n\n\tif (i2c_debug > 0)\n\t\tdev_dbg(&i2c->adap.dev, \"SAD, mode is slave-%cx\\n\",\n\t\t       (isr & ISR_RWM) ? 'r' : 't');\n\n\tif (i2c->slave != NULL) {\n\t\tif (isr & ISR_RWM) {\n\t\t\tu8 byte = 0;\n\n\t\t\ti2c_slave_event(i2c->slave, I2C_SLAVE_READ_REQUESTED,\n\t\t\t\t\t&byte);\n\t\t\twritel(byte, _IDBR(i2c));\n\t\t} else {\n\t\t\ti2c_slave_event(i2c->slave, I2C_SLAVE_WRITE_REQUESTED,\n\t\t\t\t\tNULL);\n\t\t}\n\t}\n\n\t \n\twritel(readl(_ICR(i2c)) & ~(ICR_START|ICR_STOP), _ICR(i2c));\n\twritel(readl(_ICR(i2c)) | ICR_TB, _ICR(i2c));\n\n\ttimeout = 0x10000;\n\n\twhile (1) {\n\t\tif ((readl(_IBMR(i2c)) & IBMR_SCLS) == IBMR_SCLS)\n\t\t\tbreak;\n\n\t\ttimeout--;\n\n\t\tif (timeout <= 0) {\n\t\t\tdev_err(&i2c->adap.dev, \"timeout waiting for SCL high\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\n\twritel(readl(_ICR(i2c)) & ~ICR_SCLE, _ICR(i2c));\n}\n\nstatic void i2c_pxa_slave_stop(struct pxa_i2c *i2c)\n{\n\tif (i2c_debug > 2)\n\t\tdev_dbg(&i2c->adap.dev, \"ISR: SSD (Slave Stop)\\n\");\n\n\tif (i2c->slave != NULL)\n\t\ti2c_slave_event(i2c->slave, I2C_SLAVE_STOP, NULL);\n\n\tif (i2c_debug > 2)\n\t\tdev_dbg(&i2c->adap.dev, \"ISR: SSD (Slave Stop) acked\\n\");\n\n\t \n\tif (i2c->msg)\n\t\ti2c_pxa_master_complete(i2c, I2C_RETRY);\n}\n\nstatic int i2c_pxa_slave_reg(struct i2c_client *slave)\n{\n\tstruct pxa_i2c *i2c = slave->adapter->algo_data;\n\n\tif (i2c->slave)\n\t\treturn -EBUSY;\n\n\tif (!i2c->reg_isar)\n\t\treturn -EAFNOSUPPORT;\n\n\ti2c->slave = slave;\n\ti2c->slave_addr = slave->addr;\n\n\twritel(i2c->slave_addr, _ISAR(i2c));\n\n\treturn 0;\n}\n\nstatic int i2c_pxa_slave_unreg(struct i2c_client *slave)\n{\n\tstruct pxa_i2c *i2c = slave->adapter->algo_data;\n\n\tWARN_ON(!i2c->slave);\n\n\ti2c->slave_addr = I2C_PXA_SLAVE_ADDR;\n\twritel(i2c->slave_addr, _ISAR(i2c));\n\n\ti2c->slave = NULL;\n\n\treturn 0;\n}\n#else\nstatic void i2c_pxa_slave_txempty(struct pxa_i2c *i2c, u32 isr)\n{\n\tif (isr & ISR_BED) {\n\t\t \n\t} else {\n\t\twritel(0, _IDBR(i2c));\n\t\twritel(readl(_ICR(i2c)) | ICR_TB, _ICR(i2c));\n\t}\n}\n\nstatic void i2c_pxa_slave_rxfull(struct pxa_i2c *i2c, u32 isr)\n{\n\twritel(readl(_ICR(i2c)) | ICR_TB | ICR_ACKNAK, _ICR(i2c));\n}\n\nstatic void i2c_pxa_slave_start(struct pxa_i2c *i2c, u32 isr)\n{\n\tint timeout;\n\n\t \n\twritel(readl(_ICR(i2c)) & ~(ICR_START|ICR_STOP), _ICR(i2c));\n\twritel(readl(_ICR(i2c)) | ICR_TB | ICR_ACKNAK, _ICR(i2c));\n\n\ttimeout = 0x10000;\n\n\twhile (1) {\n\t\tif ((readl(_IBMR(i2c)) & IBMR_SCLS) == IBMR_SCLS)\n\t\t\tbreak;\n\n\t\ttimeout--;\n\n\t\tif (timeout <= 0) {\n\t\t\tdev_err(&i2c->adap.dev, \"timeout waiting for SCL high\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\n\twritel(readl(_ICR(i2c)) & ~ICR_SCLE, _ICR(i2c));\n}\n\nstatic void i2c_pxa_slave_stop(struct pxa_i2c *i2c)\n{\n\tif (i2c->msg)\n\t\ti2c_pxa_master_complete(i2c, I2C_RETRY);\n}\n#endif\n\n \n\nstatic inline void i2c_pxa_start_message(struct pxa_i2c *i2c)\n{\n\tu32 icr;\n\n\t \n\ti2c->req_slave_addr = i2c_8bit_addr_from_msg(i2c->msg);\n\twritel(i2c->req_slave_addr, _IDBR(i2c));\n\n\t \n\ticr = readl(_ICR(i2c)) & ~(ICR_STOP | ICR_ALDIE);\n\twritel(icr | ICR_START | ICR_TB, _ICR(i2c));\n}\n\nstatic inline void i2c_pxa_stop_message(struct pxa_i2c *i2c)\n{\n\tu32 icr;\n\n\t \n\ticr = readl(_ICR(i2c));\n\ticr &= ~(ICR_START | ICR_STOP | ICR_ACKNAK | ICR_TB | ICR_MA);\n\twritel(icr, _ICR(i2c));\n}\n\n \nstatic int i2c_pxa_send_mastercode(struct pxa_i2c *i2c)\n{\n\tu32 icr;\n\tlong timeout;\n\n\tspin_lock_irq(&i2c->lock);\n\ti2c->highmode_enter = true;\n\twritel(i2c->master_code, _IDBR(i2c));\n\n\ticr = readl(_ICR(i2c)) & ~(ICR_STOP | ICR_ALDIE);\n\ticr |= ICR_GPIOEN | ICR_START | ICR_TB | ICR_ITEIE;\n\twritel(icr, _ICR(i2c));\n\n\tspin_unlock_irq(&i2c->lock);\n\ttimeout = wait_event_timeout(i2c->wait,\n\t\t\ti2c->highmode_enter == false, HZ * 1);\n\n\ti2c->highmode_enter = false;\n\n\treturn (timeout == 0) ? I2C_RETRY : 0;\n}\n\n \nstatic void i2c_pxa_master_complete(struct pxa_i2c *i2c, int ret)\n{\n\ti2c->msg_ptr = 0;\n\ti2c->msg = NULL;\n\ti2c->msg_idx ++;\n\ti2c->msg_num = 0;\n\tif (ret)\n\t\ti2c->msg_idx = ret;\n\tif (!i2c->use_pio)\n\t\twake_up(&i2c->wait);\n}\n\nstatic void i2c_pxa_irq_txempty(struct pxa_i2c *i2c, u32 isr)\n{\n\tu32 icr = readl(_ICR(i2c)) & ~(ICR_START|ICR_STOP|ICR_ACKNAK|ICR_TB);\n\n again:\n\t \n\tif (isr & ISR_ALD) {\n\t\t \n\t\ti2c_pxa_scream_blue_murder(i2c, \"ALD set\");\n\n\t\t \n\t\treturn;  \n\t}\n\n\tif ((isr & ISR_BED) &&\n\t\t(!((i2c->msg->flags & I2C_M_IGNORE_NAK) &&\n\t\t\t(isr & ISR_ACKNAK)))) {\n\t\tint ret = BUS_ERROR;\n\n\t\t \n\t\tif (isr & ISR_ACKNAK) {\n\t\t\tif (i2c->msg_ptr == 0 && i2c->msg_idx == 0)\n\t\t\t\tret = NO_SLAVE;\n\t\t\telse\n\t\t\t\tret = XFER_NAKED;\n\t\t}\n\t\ti2c_pxa_master_complete(i2c, ret);\n\t} else if (isr & ISR_RWM) {\n\t\t \n\t\tif (i2c->msg_ptr == i2c->msg->len - 1 &&\n\t\t    i2c->msg_idx == i2c->msg_num - 1)\n\t\t\ticr |= ICR_STOP | ICR_ACKNAK;\n\n\t\ticr |= ICR_ALDIE | ICR_TB;\n\t} else if (i2c->msg_ptr < i2c->msg->len) {\n\t\t \n\t\twritel(i2c->msg->buf[i2c->msg_ptr++], _IDBR(i2c));\n\n\t\ticr |= ICR_ALDIE | ICR_TB;\n\n\t\t \n\t\tif ((i2c->msg_ptr == i2c->msg->len) &&\n\t\t\t((i2c->msg->flags & I2C_M_STOP) ||\n\t\t\t(i2c->msg_idx == i2c->msg_num - 1)))\n\t\t\t\ticr |= ICR_STOP;\n\n\t} else if (i2c->msg_idx < i2c->msg_num - 1) {\n\t\t \n\t\ti2c->msg_ptr = 0;\n\t\ti2c->msg_idx ++;\n\t\ti2c->msg++;\n\n\t\t \n\t\tif (i2c->msg->flags & I2C_M_NOSTART)\n\t\t\tgoto again;\n\n\t\t \n\t\ti2c->req_slave_addr = i2c_8bit_addr_from_msg(i2c->msg);\n\t\twritel(i2c->req_slave_addr, _IDBR(i2c));\n\n\t\t \n\t\ticr &= ~ICR_ALDIE;\n\t\ticr |= ICR_START | ICR_TB;\n\t} else {\n\t\tif (i2c->msg->len == 0)\n\t\t\ticr |= ICR_MA;\n\t\ti2c_pxa_master_complete(i2c, 0);\n\t}\n\n\ti2c->icrlog[i2c->irqlogidx-1] = icr;\n\n\twritel(icr, _ICR(i2c));\n\tshow_state(i2c);\n}\n\nstatic void i2c_pxa_irq_rxfull(struct pxa_i2c *i2c, u32 isr)\n{\n\tu32 icr = readl(_ICR(i2c)) & ~(ICR_START|ICR_STOP|ICR_ACKNAK|ICR_TB);\n\n\t \n\ti2c->msg->buf[i2c->msg_ptr++] = readl(_IDBR(i2c));\n\n\tif (i2c->msg_ptr < i2c->msg->len) {\n\t\t \n\t\tif (i2c->msg_ptr == i2c->msg->len - 1)\n\t\t\ticr |= ICR_STOP | ICR_ACKNAK;\n\n\t\ticr |= ICR_ALDIE | ICR_TB;\n\t} else {\n\t\ti2c_pxa_master_complete(i2c, 0);\n\t}\n\n\ti2c->icrlog[i2c->irqlogidx-1] = icr;\n\n\twritel(icr, _ICR(i2c));\n}\n\n#define VALID_INT_SOURCE\t(ISR_SSD | ISR_ALD | ISR_ITE | ISR_IRF | \\\n\t\t\t\tISR_SAD | ISR_BED)\nstatic irqreturn_t i2c_pxa_handler(int this_irq, void *dev_id)\n{\n\tstruct pxa_i2c *i2c = dev_id;\n\tu32 isr = readl(_ISR(i2c));\n\n\tif (!(isr & VALID_INT_SOURCE))\n\t\treturn IRQ_NONE;\n\n\tif (i2c_debug > 2 && 0) {\n\t\tdev_dbg(&i2c->adap.dev, \"%s: ISR=%08x, ICR=%08x, IBMR=%02x\\n\",\n\t\t\t__func__, isr, readl(_ICR(i2c)), readl(_IBMR(i2c)));\n\t\tdecode_ISR(isr);\n\t}\n\n\tif (i2c->irqlogidx < ARRAY_SIZE(i2c->isrlog))\n\t\ti2c->isrlog[i2c->irqlogidx++] = isr;\n\n\tshow_state(i2c);\n\n\t \n\twritel(isr & VALID_INT_SOURCE, _ISR(i2c));\n\n\tif (isr & ISR_SAD)\n\t\ti2c_pxa_slave_start(i2c, isr);\n\tif (isr & ISR_SSD)\n\t\ti2c_pxa_slave_stop(i2c);\n\n\tif (i2c_pxa_is_slavemode(i2c)) {\n\t\tif (isr & ISR_ITE)\n\t\t\ti2c_pxa_slave_txempty(i2c, isr);\n\t\tif (isr & ISR_IRF)\n\t\t\ti2c_pxa_slave_rxfull(i2c, isr);\n\t} else if (i2c->msg && (!i2c->highmode_enter)) {\n\t\tif (isr & ISR_ITE)\n\t\t\ti2c_pxa_irq_txempty(i2c, isr);\n\t\tif (isr & ISR_IRF)\n\t\t\ti2c_pxa_irq_rxfull(i2c, isr);\n\t} else if ((isr & ISR_ITE) && i2c->highmode_enter) {\n\t\ti2c->highmode_enter = false;\n\t\twake_up(&i2c->wait);\n\t} else {\n\t\ti2c_pxa_scream_blue_murder(i2c, \"spurious irq\");\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic int i2c_pxa_do_xfer(struct pxa_i2c *i2c, struct i2c_msg *msg, int num)\n{\n\tlong timeout;\n\tint ret;\n\n\t \n\tret = i2c_pxa_wait_bus_not_busy(i2c);\n\tif (ret) {\n\t\tdev_err(&i2c->adap.dev, \"i2c_pxa: timeout waiting for bus free\\n\");\n\t\ti2c_recover_bus(&i2c->adap);\n\t\tgoto out;\n\t}\n\n\t \n\tret = i2c_pxa_set_master(i2c);\n\tif (ret) {\n\t\tdev_err(&i2c->adap.dev, \"i2c_pxa_set_master: error %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tif (i2c->high_mode) {\n\t\tret = i2c_pxa_send_mastercode(i2c);\n\t\tif (ret) {\n\t\t\tdev_err(&i2c->adap.dev, \"i2c_pxa_send_mastercode timeout\\n\");\n\t\t\tgoto out;\n\t\t\t}\n\t}\n\n\tspin_lock_irq(&i2c->lock);\n\n\ti2c->msg = msg;\n\ti2c->msg_num = num;\n\ti2c->msg_idx = 0;\n\ti2c->msg_ptr = 0;\n\ti2c->irqlogidx = 0;\n\n\ti2c_pxa_start_message(i2c);\n\n\tspin_unlock_irq(&i2c->lock);\n\n\t \n\ttimeout = wait_event_timeout(i2c->wait, i2c->msg_num == 0, HZ * 5);\n\ti2c_pxa_stop_message(i2c);\n\n\t \n\tret = i2c->msg_idx;\n\n\tif (!timeout && i2c->msg_num) {\n\t\ti2c_pxa_scream_blue_murder(i2c, \"timeout with active message\");\n\t\ti2c_recover_bus(&i2c->adap);\n\t\tret = I2C_RETRY;\n\t}\n\n out:\n\treturn ret;\n}\n\nstatic int i2c_pxa_internal_xfer(struct pxa_i2c *i2c,\n\t\t\t\t struct i2c_msg *msgs, int num,\n\t\t\t\t int (*xfer)(struct pxa_i2c *,\n\t\t\t\t\t     struct i2c_msg *, int num))\n{\n\tint ret, i;\n\n\tfor (i = 0; ; ) {\n\t\tret = xfer(i2c, msgs, num);\n\t\tif (ret != I2C_RETRY && ret != NO_SLAVE)\n\t\t\tgoto out;\n\t\tif (++i >= i2c->adap.retries)\n\t\t\tbreak;\n\n\t\tif (i2c_debug)\n\t\t\tdev_dbg(&i2c->adap.dev, \"Retrying transmission\\n\");\n\t\tudelay(100);\n\t}\n\tif (ret != NO_SLAVE)\n\t\ti2c_pxa_scream_blue_murder(i2c, \"exhausted retries\");\n\tret = -EREMOTEIO;\n out:\n\ti2c_pxa_set_slave(i2c, ret);\n\treturn ret;\n}\n\nstatic int i2c_pxa_xfer(struct i2c_adapter *adap,\n\t\t\tstruct i2c_msg msgs[], int num)\n{\n\tstruct pxa_i2c *i2c = adap->algo_data;\n\n\treturn i2c_pxa_internal_xfer(i2c, msgs, num, i2c_pxa_do_xfer);\n}\n\nstatic u32 i2c_pxa_functionality(struct i2c_adapter *adap)\n{\n\treturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL |\n\t\tI2C_FUNC_PROTOCOL_MANGLING | I2C_FUNC_NOSTART;\n}\n\nstatic const struct i2c_algorithm i2c_pxa_algorithm = {\n\t.master_xfer\t= i2c_pxa_xfer,\n\t.functionality\t= i2c_pxa_functionality,\n#ifdef CONFIG_I2C_PXA_SLAVE\n\t.reg_slave\t= i2c_pxa_slave_reg,\n\t.unreg_slave\t= i2c_pxa_slave_unreg,\n#endif\n};\n\n \nstatic int i2c_pxa_pio_set_master(struct pxa_i2c *i2c)\n{\n\t \n\tlong timeout = 2 * DEF_TIMEOUT;\n\n\t \n\twhile (timeout-- && readl(_ISR(i2c)) & (ISR_IBB | ISR_UB))\n\t\tudelay(1000);\n\n\tif (timeout < 0) {\n\t\tshow_state(i2c);\n\t\tdev_err(&i2c->adap.dev,\n\t\t\t\"i2c_pxa: timeout waiting for bus free (set_master)\\n\");\n\t\treturn I2C_RETRY;\n\t}\n\n\t \n\twritel(readl(_ICR(i2c)) | ICR_SCLE, _ICR(i2c));\n\n\treturn 0;\n}\n\nstatic int i2c_pxa_do_pio_xfer(struct pxa_i2c *i2c,\n\t\t\t       struct i2c_msg *msg, int num)\n{\n\tunsigned long timeout = 500000;  \n\tint ret = 0;\n\n\tret = i2c_pxa_pio_set_master(i2c);\n\tif (ret)\n\t\tgoto out;\n\n\ti2c->msg = msg;\n\ti2c->msg_num = num;\n\ti2c->msg_idx = 0;\n\ti2c->msg_ptr = 0;\n\ti2c->irqlogidx = 0;\n\n\ti2c_pxa_start_message(i2c);\n\n\twhile (i2c->msg_num > 0 && --timeout) {\n\t\ti2c_pxa_handler(0, i2c);\n\t\tudelay(10);\n\t}\n\n\ti2c_pxa_stop_message(i2c);\n\n\t \n\tret = i2c->msg_idx;\n\nout:\n\tif (timeout == 0) {\n\t\ti2c_pxa_scream_blue_murder(i2c, \"timeout (do_pio_xfer)\");\n\t\tret = I2C_RETRY;\n\t}\n\n\treturn ret;\n}\n\nstatic int i2c_pxa_pio_xfer(struct i2c_adapter *adap,\n\t\t\t    struct i2c_msg msgs[], int num)\n{\n\tstruct pxa_i2c *i2c = adap->algo_data;\n\n\t \n\tif (!(readl(_ICR(i2c)) & ICR_IUE))\n\t\ti2c_pxa_reset(i2c);\n\n\treturn i2c_pxa_internal_xfer(i2c, msgs, num, i2c_pxa_do_pio_xfer);\n}\n\nstatic const struct i2c_algorithm i2c_pxa_pio_algorithm = {\n\t.master_xfer\t= i2c_pxa_pio_xfer,\n\t.functionality\t= i2c_pxa_functionality,\n#ifdef CONFIG_I2C_PXA_SLAVE\n\t.reg_slave\t= i2c_pxa_slave_reg,\n\t.unreg_slave\t= i2c_pxa_slave_unreg,\n#endif\n};\n\nstatic int i2c_pxa_probe_dt(struct platform_device *pdev, struct pxa_i2c *i2c,\n\t\t\t    enum pxa_i2c_types *i2c_types)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tconst struct of_device_id *of_id =\n\t\t\tof_match_device(i2c_pxa_dt_ids, &pdev->dev);\n\n\tif (!of_id)\n\t\treturn 1;\n\n\t \n\ti2c->adap.nr = -1;\n\n\ti2c->use_pio = of_property_read_bool(np, \"mrvl,i2c-polling\");\n\ti2c->fast_mode = of_property_read_bool(np, \"mrvl,i2c-fast-mode\");\n\n\t*i2c_types = (enum pxa_i2c_types)(of_id->data);\n\n\treturn 0;\n}\n\nstatic int i2c_pxa_probe_pdata(struct platform_device *pdev,\n\t\t\t       struct pxa_i2c *i2c,\n\t\t\t       enum pxa_i2c_types *i2c_types)\n{\n\tstruct i2c_pxa_platform_data *plat = dev_get_platdata(&pdev->dev);\n\tconst struct platform_device_id *id = platform_get_device_id(pdev);\n\n\t*i2c_types = id->driver_data;\n\tif (plat) {\n\t\ti2c->use_pio = plat->use_pio;\n\t\ti2c->fast_mode = plat->fast_mode;\n\t\ti2c->high_mode = plat->high_mode;\n\t\ti2c->master_code = plat->master_code;\n\t\tif (!i2c->master_code)\n\t\t\ti2c->master_code = 0xe;\n\t\ti2c->rate = plat->rate;\n\t}\n\treturn 0;\n}\n\nstatic void i2c_pxa_prepare_recovery(struct i2c_adapter *adap)\n{\n\tstruct pxa_i2c *i2c = adap->algo_data;\n\tu32 ibmr = readl(_IBMR(i2c));\n\n\t \n\tgpiod_set_value(i2c->recovery.scl_gpiod, ibmr & IBMR_SCLS);\n\tgpiod_set_value(i2c->recovery.sda_gpiod, ibmr & IBMR_SDAS);\n\n\tWARN_ON(pinctrl_select_state(i2c->pinctrl, i2c->pinctrl_recovery));\n}\n\nstatic void i2c_pxa_unprepare_recovery(struct i2c_adapter *adap)\n{\n\tstruct pxa_i2c *i2c = adap->algo_data;\n\tu32 isr;\n\n\t \n\tisr = readl(_ISR(i2c));\n\tif (isr & (ISR_UB | ISR_IBB)) {\n\t\tdev_dbg(&i2c->adap.dev,\n\t\t\t\"recovery: resetting controller, ISR=0x%08x\\n\", isr);\n\t\ti2c_pxa_do_reset(i2c);\n\t}\n\n\tWARN_ON(pinctrl_select_state(i2c->pinctrl, i2c->pinctrl_default));\n\n\tdev_dbg(&i2c->adap.dev, \"recovery: IBMR 0x%08x ISR 0x%08x\\n\",\n\t        readl(_IBMR(i2c)), readl(_ISR(i2c)));\n\n\ti2c_pxa_enable(i2c);\n}\n\nstatic int i2c_pxa_init_recovery(struct pxa_i2c *i2c)\n{\n\tstruct i2c_bus_recovery_info *bri = &i2c->recovery;\n\tstruct device *dev = i2c->adap.dev.parent;\n\n\t \n\tif (IS_ENABLED(CONFIG_I2C_PXA_SLAVE))\n\t\treturn 0;\n\n\ti2c->pinctrl = devm_pinctrl_get(dev);\n\tif (PTR_ERR(i2c->pinctrl) == -ENODEV)\n\t\ti2c->pinctrl = NULL;\n\tif (IS_ERR(i2c->pinctrl))\n\t\treturn PTR_ERR(i2c->pinctrl);\n\n\tif (!i2c->pinctrl)\n\t\treturn 0;\n\n\ti2c->pinctrl_default = pinctrl_lookup_state(i2c->pinctrl,\n\t\t\t\t\t\t    PINCTRL_STATE_DEFAULT);\n\ti2c->pinctrl_recovery = pinctrl_lookup_state(i2c->pinctrl, \"recovery\");\n\n\tif (IS_ERR(i2c->pinctrl_default) || IS_ERR(i2c->pinctrl_recovery)) {\n\t\tdev_info(dev, \"missing pinmux recovery information: %ld %ld\\n\",\n\t\t\t PTR_ERR(i2c->pinctrl_default),\n\t\t\t PTR_ERR(i2c->pinctrl_recovery));\n\t\treturn 0;\n\t}\n\n\t \n\tbri->scl_gpiod = devm_gpiod_get(dev, \"scl\", GPIOD_OUT_HIGH_OPEN_DRAIN);\n\tif (bri->scl_gpiod == ERR_PTR(-EPROBE_DEFER))\n\t\treturn -EPROBE_DEFER;\n\tif (IS_ERR(bri->scl_gpiod)) {\n\t\tdev_info(dev, \"missing scl gpio recovery information: %pe\\n\",\n\t\t\t bri->scl_gpiod);\n\t\treturn 0;\n\t}\n\n\t \n\tgpiod_direction_output(bri->scl_gpiod, 0);\n\tudelay(10);\n\tbri->sda_gpiod = devm_gpiod_get(dev, \"sda\", GPIOD_OUT_HIGH_OPEN_DRAIN);\n\n\t \n\tudelay(10);\n\tgpiod_direction_output(bri->scl_gpiod, 1);\n\n\tif (bri->sda_gpiod == ERR_PTR(-EPROBE_DEFER))\n\t\treturn -EPROBE_DEFER;\n\n\tif (IS_ERR(bri->sda_gpiod)) {\n\t\tdev_info(dev, \"missing sda gpio recovery information: %pe\\n\",\n\t\t\t bri->sda_gpiod);\n\t\treturn 0;\n\t}\n\n\tbri->prepare_recovery = i2c_pxa_prepare_recovery;\n\tbri->unprepare_recovery = i2c_pxa_unprepare_recovery;\n\tbri->recover_bus = i2c_generic_scl_recovery;\n\n\ti2c->adap.bus_recovery_info = bri;\n\n\t \n\tpinctrl_select_state(i2c->pinctrl, i2c->pinctrl_recovery);\n\n\treturn pinctrl_select_state(i2c->pinctrl, i2c->pinctrl_default);\n}\n\nstatic int i2c_pxa_probe(struct platform_device *dev)\n{\n\tstruct i2c_pxa_platform_data *plat = dev_get_platdata(&dev->dev);\n\tenum pxa_i2c_types i2c_type;\n\tstruct pxa_i2c *i2c;\n\tstruct resource *res;\n\tint ret, irq;\n\n\ti2c = devm_kzalloc(&dev->dev, sizeof(struct pxa_i2c), GFP_KERNEL);\n\tif (!i2c)\n\t\treturn -ENOMEM;\n\n\t \n\ti2c->adap.nr = dev->id;\n\ti2c->adap.owner   = THIS_MODULE;\n\ti2c->adap.retries = 5;\n\ti2c->adap.algo_data = i2c;\n\ti2c->adap.dev.parent = &dev->dev;\n#ifdef CONFIG_OF\n\ti2c->adap.dev.of_node = dev->dev.of_node;\n#endif\n\n\ti2c->reg_base = devm_platform_get_and_ioremap_resource(dev, 0, &res);\n\tif (IS_ERR(i2c->reg_base))\n\t\treturn PTR_ERR(i2c->reg_base);\n\n\tirq = platform_get_irq(dev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tret = i2c_pxa_init_recovery(i2c);\n\tif (ret)\n\t\treturn ret;\n\n\tret = i2c_pxa_probe_dt(dev, i2c, &i2c_type);\n\tif (ret > 0)\n\t\tret = i2c_pxa_probe_pdata(dev, i2c, &i2c_type);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tspin_lock_init(&i2c->lock);\n\tinit_waitqueue_head(&i2c->wait);\n\n\tstrscpy(i2c->adap.name, \"pxa_i2c-i2c\", sizeof(i2c->adap.name));\n\n\ti2c->clk = devm_clk_get(&dev->dev, NULL);\n\tif (IS_ERR(i2c->clk))\n\t\treturn dev_err_probe(&dev->dev, PTR_ERR(i2c->clk),\n\t\t\t\t     \"failed to get the clk\\n\");\n\n\ti2c->reg_ibmr = i2c->reg_base + pxa_reg_layout[i2c_type].ibmr;\n\ti2c->reg_idbr = i2c->reg_base + pxa_reg_layout[i2c_type].idbr;\n\ti2c->reg_icr = i2c->reg_base + pxa_reg_layout[i2c_type].icr;\n\ti2c->reg_isr = i2c->reg_base + pxa_reg_layout[i2c_type].isr;\n\ti2c->fm_mask = pxa_reg_layout[i2c_type].fm;\n\ti2c->hs_mask = pxa_reg_layout[i2c_type].hs;\n\n\tif (i2c_type != REGS_CE4100)\n\t\ti2c->reg_isar = i2c->reg_base + pxa_reg_layout[i2c_type].isar;\n\n\tif (i2c_type == REGS_PXA910) {\n\t\ti2c->reg_ilcr = i2c->reg_base + pxa_reg_layout[i2c_type].ilcr;\n\t\ti2c->reg_iwcr = i2c->reg_base + pxa_reg_layout[i2c_type].iwcr;\n\t}\n\n\ti2c->iobase = res->start;\n\ti2c->iosize = resource_size(res);\n\n\ti2c->irq = irq;\n\n\ti2c->slave_addr = I2C_PXA_SLAVE_ADDR;\n\ti2c->highmode_enter = false;\n\n\tif (plat) {\n\t\ti2c->adap.class = plat->class;\n\t}\n\n\tif (i2c->high_mode) {\n\t\tif (i2c->rate) {\n\t\t\tclk_set_rate(i2c->clk, i2c->rate);\n\t\t\tpr_info(\"i2c: <%s> set rate to %ld\\n\",\n\t\t\t\ti2c->adap.name, clk_get_rate(i2c->clk));\n\t\t} else\n\t\t\tpr_warn(\"i2c: <%s> clock rate not set\\n\",\n\t\t\t\ti2c->adap.name);\n\t}\n\n\tclk_prepare_enable(i2c->clk);\n\n\tif (i2c->use_pio) {\n\t\ti2c->adap.algo = &i2c_pxa_pio_algorithm;\n\t} else {\n\t\ti2c->adap.algo = &i2c_pxa_algorithm;\n\t\tret = devm_request_irq(&dev->dev, irq, i2c_pxa_handler,\n\t\t\t\tIRQF_SHARED | IRQF_NO_SUSPEND,\n\t\t\t\tdev_name(&dev->dev), i2c);\n\t\tif (ret) {\n\t\t\tdev_err(&dev->dev, \"failed to request irq: %d\\n\", ret);\n\t\t\tgoto ereqirq;\n\t\t}\n\t}\n\n\ti2c_pxa_reset(i2c);\n\n\tret = i2c_add_numbered_adapter(&i2c->adap);\n\tif (ret < 0)\n\t\tgoto ereqirq;\n\n\tplatform_set_drvdata(dev, i2c);\n\n#ifdef CONFIG_I2C_PXA_SLAVE\n\tdev_info(&i2c->adap.dev, \" PXA I2C adapter, slave address %d\\n\",\n\t\ti2c->slave_addr);\n#else\n\tdev_info(&i2c->adap.dev, \" PXA I2C adapter\\n\");\n#endif\n\treturn 0;\n\nereqirq:\n\tclk_disable_unprepare(i2c->clk);\n\treturn ret;\n}\n\nstatic void i2c_pxa_remove(struct platform_device *dev)\n{\n\tstruct pxa_i2c *i2c = platform_get_drvdata(dev);\n\n\ti2c_del_adapter(&i2c->adap);\n\n\tclk_disable_unprepare(i2c->clk);\n}\n\nstatic int i2c_pxa_suspend_noirq(struct device *dev)\n{\n\tstruct pxa_i2c *i2c = dev_get_drvdata(dev);\n\n\tclk_disable(i2c->clk);\n\n\treturn 0;\n}\n\nstatic int i2c_pxa_resume_noirq(struct device *dev)\n{\n\tstruct pxa_i2c *i2c = dev_get_drvdata(dev);\n\n\tclk_enable(i2c->clk);\n\ti2c_pxa_reset(i2c);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops i2c_pxa_dev_pm_ops = {\n\t.suspend_noirq = i2c_pxa_suspend_noirq,\n\t.resume_noirq = i2c_pxa_resume_noirq,\n};\n\nstatic struct platform_driver i2c_pxa_driver = {\n\t.probe\t\t= i2c_pxa_probe,\n\t.remove_new\t= i2c_pxa_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"pxa2xx-i2c\",\n\t\t.pm\t= pm_sleep_ptr(&i2c_pxa_dev_pm_ops),\n\t\t.of_match_table = i2c_pxa_dt_ids,\n\t},\n\t.id_table\t= i2c_pxa_id_table,\n};\n\nstatic int __init i2c_adap_pxa_init(void)\n{\n\treturn platform_driver_register(&i2c_pxa_driver);\n}\n\nstatic void __exit i2c_adap_pxa_exit(void)\n{\n\tplatform_driver_unregister(&i2c_pxa_driver);\n}\n\nMODULE_LICENSE(\"GPL\");\n\nsubsys_initcall(i2c_adap_pxa_init);\nmodule_exit(i2c_adap_pxa_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}