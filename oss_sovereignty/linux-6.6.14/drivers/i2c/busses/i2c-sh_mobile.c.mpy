{
  "module_name": "i2c-sh_mobile.c",
  "hash_id": "2ba8ffa0cb71a2c1797dc3f167b5e6103b763599fa911b515e6ae3b238eb9b7c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-sh_mobile.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/dmaengine.h>\n#include <linux/dma-mapping.h>\n#include <linux/err.h>\n#include <linux/i2c.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/slab.h>\n\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\nenum sh_mobile_i2c_op {\n\tOP_START = 0,\n\tOP_TX_FIRST,\n\tOP_TX,\n\tOP_TX_STOP,\n\tOP_TX_TO_RX,\n\tOP_RX,\n\tOP_RX_STOP,\n\tOP_RX_STOP_DATA,\n};\n\nstruct sh_mobile_i2c_data {\n\tstruct device *dev;\n\tvoid __iomem *reg;\n\tstruct i2c_adapter adap;\n\tunsigned long bus_speed;\n\tunsigned int clks_per_count;\n\tstruct clk *clk;\n\tu_int8_t icic;\n\tu_int8_t flags;\n\tu_int16_t iccl;\n\tu_int16_t icch;\n\n\tspinlock_t lock;\n\twait_queue_head_t wait;\n\tstruct i2c_msg *msg;\n\tint pos;\n\tint sr;\n\tbool send_stop;\n\tbool stop_after_dma;\n\tbool atomic_xfer;\n\n\tstruct resource *res;\n\tstruct dma_chan *dma_tx;\n\tstruct dma_chan *dma_rx;\n\tstruct scatterlist sg;\n\tenum dma_data_direction dma_direction;\n\tu8 *dma_buf;\n};\n\nstruct sh_mobile_dt_config {\n\tint clks_per_count;\n\tint (*setup)(struct sh_mobile_i2c_data *pd);\n};\n\n#define IIC_FLAG_HAS_ICIC67\t(1 << 0)\n\n \n#define ICDR\t\t\t0x00\n#define ICCR\t\t\t0x04\n#define ICSR\t\t\t0x08\n#define ICIC\t\t\t0x0c\n#define ICCL\t\t\t0x10\n#define ICCH\t\t\t0x14\n#define ICSTART\t\t\t0x70\n\n \n#define ICCR_ICE\t\t0x80\n#define ICCR_RACK\t\t0x40\n#define ICCR_TRS\t\t0x10\n#define ICCR_BBSY\t\t0x04\n#define ICCR_SCP\t\t0x01\n\n#define ICSR_SCLM\t\t0x80\n#define ICSR_SDAM\t\t0x40\n#define SW_DONE\t\t\t0x20\n#define ICSR_BUSY\t\t0x10\n#define ICSR_AL\t\t\t0x08\n#define ICSR_TACK\t\t0x04\n#define ICSR_WAIT\t\t0x02\n#define ICSR_DTE\t\t0x01\n\n#define ICIC_ICCLB8\t\t0x80\n#define ICIC_ICCHB8\t\t0x40\n#define ICIC_TDMAE\t\t0x20\n#define ICIC_RDMAE\t\t0x10\n#define ICIC_ALE\t\t0x08\n#define ICIC_TACKE\t\t0x04\n#define ICIC_WAITE\t\t0x02\n#define ICIC_DTEE\t\t0x01\n\n#define ICSTART_ICSTART\t\t0x10\n\nstatic void iic_wr(struct sh_mobile_i2c_data *pd, int offs, unsigned char data)\n{\n\tif (offs == ICIC)\n\t\tdata |= pd->icic;\n\n\tiowrite8(data, pd->reg + offs);\n}\n\nstatic unsigned char iic_rd(struct sh_mobile_i2c_data *pd, int offs)\n{\n\treturn ioread8(pd->reg + offs);\n}\n\nstatic void iic_set_clr(struct sh_mobile_i2c_data *pd, int offs,\n\t\t\tunsigned char set, unsigned char clr)\n{\n\tiic_wr(pd, offs, (iic_rd(pd, offs) | set) & ~clr);\n}\n\nstatic u32 sh_mobile_i2c_iccl(unsigned long count_khz, u32 tLOW, u32 tf)\n{\n\t \n\treturn (((count_khz * (tLOW + tf)) + 5000) / 10000);\n}\n\nstatic u32 sh_mobile_i2c_icch(unsigned long count_khz, u32 tHIGH, u32 tf)\n{\n\t \n\treturn (((count_khz * (tHIGH + tf)) + 5000) / 10000);\n}\n\nstatic int sh_mobile_i2c_check_timing(struct sh_mobile_i2c_data *pd)\n{\n\tu16 max_val = pd->flags & IIC_FLAG_HAS_ICIC67 ? 0x1ff : 0xff;\n\n\tif (pd->iccl > max_val || pd->icch > max_val) {\n\t\tdev_err(pd->dev, \"timing values out of range: L/H=0x%x/0x%x\\n\",\n\t\t\tpd->iccl, pd->icch);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (pd->iccl & 0x100)\n\t\tpd->icic |= ICIC_ICCLB8;\n\telse\n\t\tpd->icic &= ~ICIC_ICCLB8;\n\n\t \n\tif (pd->icch & 0x100)\n\t\tpd->icic |= ICIC_ICCHB8;\n\telse\n\t\tpd->icic &= ~ICIC_ICCHB8;\n\n\tdev_dbg(pd->dev, \"timing values: L/H=0x%x/0x%x\\n\", pd->iccl, pd->icch);\n\treturn 0;\n}\n\nstatic int sh_mobile_i2c_init(struct sh_mobile_i2c_data *pd)\n{\n\tunsigned long i2c_clk_khz;\n\tu32 tHIGH, tLOW, tf;\n\n\ti2c_clk_khz = clk_get_rate(pd->clk) / 1000 / pd->clks_per_count;\n\n\tif (pd->bus_speed == I2C_MAX_STANDARD_MODE_FREQ) {\n\t\ttLOW\t= 47;\t \n\t\ttHIGH\t= 40;\t \n\t\ttf\t= 3;\t \n\t} else if (pd->bus_speed == I2C_MAX_FAST_MODE_FREQ) {\n\t\ttLOW\t= 13;\t \n\t\ttHIGH\t= 6;\t \n\t\ttf\t= 3;\t \n\t} else {\n\t\tdev_err(pd->dev, \"unrecognized bus speed %lu Hz\\n\",\n\t\t\tpd->bus_speed);\n\t\treturn -EINVAL;\n\t}\n\n\tpd->iccl = sh_mobile_i2c_iccl(i2c_clk_khz, tLOW, tf);\n\tpd->icch = sh_mobile_i2c_icch(i2c_clk_khz, tHIGH, tf);\n\n\treturn sh_mobile_i2c_check_timing(pd);\n}\n\nstatic int sh_mobile_i2c_v2_init(struct sh_mobile_i2c_data *pd)\n{\n\tunsigned long clks_per_cycle;\n\n\t \n\tclks_per_cycle = clk_get_rate(pd->clk) / pd->bus_speed;\n\tpd->iccl = DIV_ROUND_UP(clks_per_cycle * 5 / 9 - 1, pd->clks_per_count);\n\tpd->icch = DIV_ROUND_UP(clks_per_cycle * 4 / 9 - 5, pd->clks_per_count);\n\n\treturn sh_mobile_i2c_check_timing(pd);\n}\n\nstatic unsigned char i2c_op(struct sh_mobile_i2c_data *pd, enum sh_mobile_i2c_op op)\n{\n\tunsigned char ret = 0;\n\tunsigned long flags;\n\n\tdev_dbg(pd->dev, \"op %d\\n\", op);\n\n\tspin_lock_irqsave(&pd->lock, flags);\n\n\tswitch (op) {\n\tcase OP_START:  \n\t\tiic_wr(pd, ICCR, ICCR_ICE | ICCR_TRS | ICCR_BBSY);\n\t\tbreak;\n\tcase OP_TX_FIRST:  \n\t\tiic_wr(pd, ICIC, ICIC_WAITE | ICIC_ALE | ICIC_TACKE);\n\t\tiic_wr(pd, ICDR, i2c_8bit_addr_from_msg(pd->msg));\n\t\tbreak;\n\tcase OP_TX:  \n\t\tiic_wr(pd, ICDR, pd->msg->buf[pd->pos]);\n\t\tbreak;\n\tcase OP_TX_STOP:  \n\t\tiic_wr(pd, ICCR, pd->send_stop ? ICCR_ICE | ICCR_TRS\n\t\t\t\t\t       : ICCR_ICE | ICCR_TRS | ICCR_BBSY);\n\t\tbreak;\n\tcase OP_TX_TO_RX:  \n\t\tiic_wr(pd, ICCR, ICCR_ICE | ICCR_SCP);\n\t\tbreak;\n\tcase OP_RX:  \n\t\tret = iic_rd(pd, ICDR);\n\t\tbreak;\n\tcase OP_RX_STOP:  \n\t\tif (!pd->atomic_xfer)\n\t\t\tiic_wr(pd, ICIC,\n\t\t\t       ICIC_DTEE | ICIC_WAITE | ICIC_ALE | ICIC_TACKE);\n\t\tiic_wr(pd, ICCR, ICCR_ICE | ICCR_RACK);\n\t\tbreak;\n\tcase OP_RX_STOP_DATA:  \n\t\tif (!pd->atomic_xfer)\n\t\t\tiic_wr(pd, ICIC,\n\t\t\t       ICIC_DTEE | ICIC_WAITE | ICIC_ALE | ICIC_TACKE);\n\t\tret = iic_rd(pd, ICDR);\n\t\tiic_wr(pd, ICCR, ICCR_ICE | ICCR_RACK);\n\t\tbreak;\n\t}\n\n\tspin_unlock_irqrestore(&pd->lock, flags);\n\n\tdev_dbg(pd->dev, \"op %d, data out 0x%02x\\n\", op, ret);\n\treturn ret;\n}\n\nstatic int sh_mobile_i2c_isr_tx(struct sh_mobile_i2c_data *pd)\n{\n\tif (pd->pos == pd->msg->len) {\n\t\ti2c_op(pd, OP_TX_STOP);\n\t\treturn 1;\n\t}\n\n\tif (pd->pos == -1)\n\t\ti2c_op(pd, OP_TX_FIRST);\n\telse\n\t\ti2c_op(pd, OP_TX);\n\n\tpd->pos++;\n\treturn 0;\n}\n\nstatic int sh_mobile_i2c_isr_rx(struct sh_mobile_i2c_data *pd)\n{\n\tint real_pos;\n\n\t \n\treal_pos = pd->pos - 2;\n\n\tif (pd->pos == -1) {\n\t\ti2c_op(pd, OP_TX_FIRST);\n\t} else if (pd->pos == 0) {\n\t\ti2c_op(pd, OP_TX_TO_RX);\n\t} else if (pd->pos == pd->msg->len) {\n\t\tif (pd->stop_after_dma) {\n\t\t\t \n\t\t\ti2c_op(pd, OP_RX_STOP);\n\t\t\tpd->pos++;\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (real_pos < 0)\n\t\t\ti2c_op(pd, OP_RX_STOP);\n\t\telse\n\t\t\tpd->msg->buf[real_pos] = i2c_op(pd, OP_RX_STOP_DATA);\n\t} else if (real_pos >= 0) {\n\t\tpd->msg->buf[real_pos] = i2c_op(pd, OP_RX);\n\t}\n\n done:\n\tpd->pos++;\n\treturn pd->pos == (pd->msg->len + 2);\n}\n\nstatic irqreturn_t sh_mobile_i2c_isr(int irq, void *dev_id)\n{\n\tstruct sh_mobile_i2c_data *pd = dev_id;\n\tunsigned char sr;\n\tint wakeup = 0;\n\n\tsr = iic_rd(pd, ICSR);\n\tpd->sr |= sr;  \n\n\tdev_dbg(pd->dev, \"i2c_isr 0x%02x 0x%02x %s %d %d!\\n\", sr, pd->sr,\n\t       (pd->msg->flags & I2C_M_RD) ? \"read\" : \"write\",\n\t       pd->pos, pd->msg->len);\n\n\t \n\tif (pd->dma_direction == DMA_TO_DEVICE && pd->pos == 0)\n\t\tiic_set_clr(pd, ICIC, ICIC_TDMAE, 0);\n\telse if (sr & (ICSR_AL | ICSR_TACK))\n\t\t \n\t\tiic_wr(pd, ICSR, sr & ~(ICSR_AL | ICSR_TACK));\n\telse if (pd->msg->flags & I2C_M_RD)\n\t\twakeup = sh_mobile_i2c_isr_rx(pd);\n\telse\n\t\twakeup = sh_mobile_i2c_isr_tx(pd);\n\n\t \n\tif (pd->dma_direction == DMA_FROM_DEVICE && pd->pos == 1)\n\t\tiic_set_clr(pd, ICIC, ICIC_RDMAE, 0);\n\n\tif (sr & ICSR_WAIT)  \n\t\tiic_wr(pd, ICSR, sr & ~ICSR_WAIT);\n\n\tif (wakeup) {\n\t\tpd->sr |= SW_DONE;\n\t\tif (!pd->atomic_xfer)\n\t\t\twake_up(&pd->wait);\n\t}\n\n\t \n\tiic_rd(pd, ICSR);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void sh_mobile_i2c_cleanup_dma(struct sh_mobile_i2c_data *pd, bool terminate)\n{\n\tstruct dma_chan *chan = pd->dma_direction == DMA_FROM_DEVICE\n\t\t\t\t? pd->dma_rx : pd->dma_tx;\n\n\t \n\tif (terminate)\n\t\tdmaengine_terminate_sync(chan);\n\n\tdma_unmap_single(chan->device->dev, sg_dma_address(&pd->sg),\n\t\t\t pd->msg->len, pd->dma_direction);\n\n\tpd->dma_direction = DMA_NONE;\n}\n\nstatic void sh_mobile_i2c_dma_callback(void *data)\n{\n\tstruct sh_mobile_i2c_data *pd = data;\n\n\tsh_mobile_i2c_cleanup_dma(pd, false);\n\tpd->pos = pd->msg->len;\n\tpd->stop_after_dma = true;\n\n\tiic_set_clr(pd, ICIC, 0, ICIC_TDMAE | ICIC_RDMAE);\n}\n\nstatic struct dma_chan *sh_mobile_i2c_request_dma_chan(struct device *dev,\n\t\t\t\tenum dma_transfer_direction dir, dma_addr_t port_addr)\n{\n\tstruct dma_chan *chan;\n\tstruct dma_slave_config cfg;\n\tchar *chan_name = dir == DMA_MEM_TO_DEV ? \"tx\" : \"rx\";\n\tint ret;\n\n\tchan = dma_request_chan(dev, chan_name);\n\tif (IS_ERR(chan)) {\n\t\tdev_dbg(dev, \"request_channel failed for %s (%ld)\\n\", chan_name,\n\t\t\tPTR_ERR(chan));\n\t\treturn chan;\n\t}\n\n\tmemset(&cfg, 0, sizeof(cfg));\n\tcfg.direction = dir;\n\tif (dir == DMA_MEM_TO_DEV) {\n\t\tcfg.dst_addr = port_addr;\n\t\tcfg.dst_addr_width = DMA_SLAVE_BUSWIDTH_1_BYTE;\n\t} else {\n\t\tcfg.src_addr = port_addr;\n\t\tcfg.src_addr_width = DMA_SLAVE_BUSWIDTH_1_BYTE;\n\t}\n\n\tret = dmaengine_slave_config(chan, &cfg);\n\tif (ret) {\n\t\tdev_dbg(dev, \"slave_config failed for %s (%d)\\n\", chan_name, ret);\n\t\tdma_release_channel(chan);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tdev_dbg(dev, \"got DMA channel for %s\\n\", chan_name);\n\treturn chan;\n}\n\nstatic void sh_mobile_i2c_xfer_dma(struct sh_mobile_i2c_data *pd)\n{\n\tbool read = pd->msg->flags & I2C_M_RD;\n\tenum dma_data_direction dir = read ? DMA_FROM_DEVICE : DMA_TO_DEVICE;\n\tstruct dma_chan *chan = read ? pd->dma_rx : pd->dma_tx;\n\tstruct dma_async_tx_descriptor *txdesc;\n\tdma_addr_t dma_addr;\n\tdma_cookie_t cookie;\n\n\tif (PTR_ERR(chan) == -EPROBE_DEFER) {\n\t\tif (read)\n\t\t\tchan = pd->dma_rx = sh_mobile_i2c_request_dma_chan(pd->dev, DMA_DEV_TO_MEM,\n\t\t\t\t\t\t\t\t\t   pd->res->start + ICDR);\n\t\telse\n\t\t\tchan = pd->dma_tx = sh_mobile_i2c_request_dma_chan(pd->dev, DMA_MEM_TO_DEV,\n\t\t\t\t\t\t\t\t\t   pd->res->start + ICDR);\n\t}\n\n\tif (IS_ERR(chan))\n\t\treturn;\n\n\tdma_addr = dma_map_single(chan->device->dev, pd->dma_buf, pd->msg->len, dir);\n\tif (dma_mapping_error(chan->device->dev, dma_addr)) {\n\t\tdev_dbg(pd->dev, \"dma map failed, using PIO\\n\");\n\t\treturn;\n\t}\n\n\tsg_dma_len(&pd->sg) = pd->msg->len;\n\tsg_dma_address(&pd->sg) = dma_addr;\n\n\tpd->dma_direction = dir;\n\n\ttxdesc = dmaengine_prep_slave_sg(chan, &pd->sg, 1,\n\t\t\t\t\t read ? DMA_DEV_TO_MEM : DMA_MEM_TO_DEV,\n\t\t\t\t\t DMA_PREP_INTERRUPT | DMA_CTRL_ACK);\n\tif (!txdesc) {\n\t\tdev_dbg(pd->dev, \"dma prep slave sg failed, using PIO\\n\");\n\t\tsh_mobile_i2c_cleanup_dma(pd, false);\n\t\treturn;\n\t}\n\n\ttxdesc->callback = sh_mobile_i2c_dma_callback;\n\ttxdesc->callback_param = pd;\n\n\tcookie = dmaengine_submit(txdesc);\n\tif (dma_submit_error(cookie)) {\n\t\tdev_dbg(pd->dev, \"submitting dma failed, using PIO\\n\");\n\t\tsh_mobile_i2c_cleanup_dma(pd, false);\n\t\treturn;\n\t}\n\n\tdma_async_issue_pending(chan);\n}\n\nstatic void start_ch(struct sh_mobile_i2c_data *pd, struct i2c_msg *usr_msg,\n\t\t     bool do_init)\n{\n\tif (do_init) {\n\t\t \n\t\tiic_wr(pd, ICCR, ICCR_SCP);\n\n\t\t \n\t\tiic_wr(pd, ICCR, ICCR_ICE | ICCR_SCP);\n\n\t\t \n\t\tiic_wr(pd, ICCL, pd->iccl & 0xff);\n\t\tiic_wr(pd, ICCH, pd->icch & 0xff);\n\t}\n\n\tpd->msg = usr_msg;\n\tpd->pos = -1;\n\tpd->sr = 0;\n\n\tif (pd->atomic_xfer)\n\t\treturn;\n\n\tpd->dma_buf = i2c_get_dma_safe_msg_buf(pd->msg, 8);\n\tif (pd->dma_buf)\n\t\tsh_mobile_i2c_xfer_dma(pd);\n\n\t \n\tiic_wr(pd, ICIC, ICIC_DTEE | ICIC_WAITE | ICIC_ALE | ICIC_TACKE);\n}\n\nstatic int poll_dte(struct sh_mobile_i2c_data *pd)\n{\n\tint i;\n\n\tfor (i = 1000; i; i--) {\n\t\tu_int8_t val = iic_rd(pd, ICSR);\n\n\t\tif (val & ICSR_DTE)\n\t\t\tbreak;\n\n\t\tif (val & ICSR_TACK)\n\t\t\treturn -ENXIO;\n\n\t\tudelay(10);\n\t}\n\n\treturn i ? 0 : -ETIMEDOUT;\n}\n\nstatic int poll_busy(struct sh_mobile_i2c_data *pd)\n{\n\tint i;\n\n\tfor (i = 1000; i; i--) {\n\t\tu_int8_t val = iic_rd(pd, ICSR);\n\n\t\tdev_dbg(pd->dev, \"val 0x%02x pd->sr 0x%02x\\n\", val, pd->sr);\n\n\t\t \n\t\tif (!(val & ICSR_BUSY)) {\n\t\t\t \n\t\t\tval |= pd->sr;\n\t\t\tif (val & ICSR_TACK)\n\t\t\t\treturn -ENXIO;\n\t\t\tif (val & ICSR_AL)\n\t\t\t\treturn -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\n\t\tudelay(10);\n\t}\n\n\treturn i ? 0 : -ETIMEDOUT;\n}\n\nstatic int sh_mobile_xfer(struct sh_mobile_i2c_data *pd,\n\t\t\t struct i2c_msg *msgs, int num)\n{\n\tstruct i2c_msg\t*msg;\n\tint err = 0;\n\tint i;\n\tlong time_left;\n\n\t \n\tpm_runtime_get_sync(pd->dev);\n\n\t \n\tfor (i = 0; i < num; i++) {\n\t\tbool do_start = pd->send_stop || !i;\n\t\tmsg = &msgs[i];\n\t\tpd->send_stop = i == num - 1 || msg->flags & I2C_M_STOP;\n\t\tpd->stop_after_dma = false;\n\n\t\tstart_ch(pd, msg, do_start);\n\n\t\tif (do_start)\n\t\t\ti2c_op(pd, OP_START);\n\n\t\tif (pd->atomic_xfer) {\n\t\t\tunsigned long j = jiffies + pd->adap.timeout;\n\n\t\t\ttime_left = time_before_eq(jiffies, j);\n\t\t\twhile (time_left &&\n\t\t\t       !(pd->sr & (ICSR_TACK | SW_DONE))) {\n\t\t\t\tunsigned char sr = iic_rd(pd, ICSR);\n\n\t\t\t\tif (sr & (ICSR_AL   | ICSR_TACK |\n\t\t\t\t\t  ICSR_WAIT | ICSR_DTE)) {\n\t\t\t\t\tsh_mobile_i2c_isr(0, pd);\n\t\t\t\t\tudelay(150);\n\t\t\t\t} else {\n\t\t\t\t\tcpu_relax();\n\t\t\t\t}\n\t\t\t\ttime_left = time_before_eq(jiffies, j);\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\ttime_left = wait_event_timeout(pd->wait,\n\t\t\t\t\tpd->sr & (ICSR_TACK | SW_DONE),\n\t\t\t\t\tpd->adap.timeout);\n\n\t\t\t \n\t\t\ti2c_put_dma_safe_msg_buf(pd->dma_buf, pd->msg,\n\t\t\t\t\t\t pd->stop_after_dma);\n\t\t}\n\n\t\tif (!time_left) {\n\t\t\tdev_err(pd->dev, \"Transfer request timed out\\n\");\n\t\t\tif (pd->dma_direction != DMA_NONE)\n\t\t\t\tsh_mobile_i2c_cleanup_dma(pd, true);\n\n\t\t\terr = -ETIMEDOUT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (pd->send_stop)\n\t\t\terr = poll_busy(pd);\n\t\telse\n\t\t\terr = poll_dte(pd);\n\t\tif (err < 0)\n\t\t\tbreak;\n\t}\n\n\t \n\tiic_wr(pd, ICCR, ICCR_SCP);\n\n\t \n\tpm_runtime_put_sync(pd->dev);\n\n\treturn err ?: num;\n}\n\nstatic int sh_mobile_i2c_xfer(struct i2c_adapter *adapter,\n\t\t\t      struct i2c_msg *msgs,\n\t\t\t      int num)\n{\n\tstruct sh_mobile_i2c_data *pd = i2c_get_adapdata(adapter);\n\n\tpd->atomic_xfer = false;\n\treturn sh_mobile_xfer(pd, msgs, num);\n}\n\nstatic int sh_mobile_i2c_xfer_atomic(struct i2c_adapter *adapter,\n\t\t\t\t     struct i2c_msg *msgs,\n\t\t\t\t     int num)\n{\n\tstruct sh_mobile_i2c_data *pd = i2c_get_adapdata(adapter);\n\n\tpd->atomic_xfer = true;\n\treturn sh_mobile_xfer(pd, msgs, num);\n}\n\nstatic u32 sh_mobile_i2c_func(struct i2c_adapter *adapter)\n{\n\treturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL | I2C_FUNC_PROTOCOL_MANGLING;\n}\n\nstatic const struct i2c_algorithm sh_mobile_i2c_algorithm = {\n\t.functionality = sh_mobile_i2c_func,\n\t.master_xfer = sh_mobile_i2c_xfer,\n\t.master_xfer_atomic = sh_mobile_i2c_xfer_atomic,\n};\n\nstatic const struct i2c_adapter_quirks sh_mobile_i2c_quirks = {\n\t.flags = I2C_AQ_NO_ZERO_LEN_READ,\n};\n\n \nstatic int sh_mobile_i2c_r8a7740_workaround(struct sh_mobile_i2c_data *pd)\n{\n\tiic_set_clr(pd, ICCR, ICCR_ICE, 0);\n\tiic_rd(pd, ICCR);  \n\n\tiic_set_clr(pd, ICSTART, ICSTART_ICSTART, 0);\n\tiic_rd(pd, ICSTART);  \n\n\tudelay(10);\n\n\tiic_wr(pd, ICCR, ICCR_SCP);\n\tiic_wr(pd, ICSTART, 0);\n\n\tudelay(10);\n\n\tiic_wr(pd, ICCR, ICCR_TRS);\n\tudelay(10);\n\tiic_wr(pd, ICCR, 0);\n\tudelay(10);\n\tiic_wr(pd, ICCR, ICCR_TRS);\n\tudelay(10);\n\n\treturn sh_mobile_i2c_init(pd);\n}\n\nstatic const struct sh_mobile_dt_config default_dt_config = {\n\t.clks_per_count = 1,\n\t.setup = sh_mobile_i2c_init,\n};\n\nstatic const struct sh_mobile_dt_config fast_clock_dt_config = {\n\t.clks_per_count = 2,\n\t.setup = sh_mobile_i2c_init,\n};\n\nstatic const struct sh_mobile_dt_config v2_freq_calc_dt_config = {\n\t.clks_per_count = 2,\n\t.setup = sh_mobile_i2c_v2_init,\n};\n\nstatic const struct sh_mobile_dt_config r8a7740_dt_config = {\n\t.clks_per_count = 1,\n\t.setup = sh_mobile_i2c_r8a7740_workaround,\n};\n\nstatic const struct of_device_id sh_mobile_i2c_dt_ids[] = {\n\t{ .compatible = \"renesas,iic-r8a73a4\", .data = &fast_clock_dt_config },\n\t{ .compatible = \"renesas,iic-r8a7740\", .data = &r8a7740_dt_config },\n\t{ .compatible = \"renesas,iic-r8a774c0\", .data = &v2_freq_calc_dt_config },\n\t{ .compatible = \"renesas,iic-r8a7790\", .data = &v2_freq_calc_dt_config },\n\t{ .compatible = \"renesas,iic-r8a7791\", .data = &v2_freq_calc_dt_config },\n\t{ .compatible = \"renesas,iic-r8a7792\", .data = &v2_freq_calc_dt_config },\n\t{ .compatible = \"renesas,iic-r8a7793\", .data = &v2_freq_calc_dt_config },\n\t{ .compatible = \"renesas,iic-r8a7794\", .data = &v2_freq_calc_dt_config },\n\t{ .compatible = \"renesas,iic-r8a7795\", .data = &v2_freq_calc_dt_config },\n\t{ .compatible = \"renesas,iic-r8a77990\", .data = &v2_freq_calc_dt_config },\n\t{ .compatible = \"renesas,iic-sh73a0\", .data = &fast_clock_dt_config },\n\t{ .compatible = \"renesas,rcar-gen2-iic\", .data = &v2_freq_calc_dt_config },\n\t{ .compatible = \"renesas,rcar-gen3-iic\", .data = &v2_freq_calc_dt_config },\n\t{ .compatible = \"renesas,rmobile-iic\", .data = &default_dt_config },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, sh_mobile_i2c_dt_ids);\n\nstatic void sh_mobile_i2c_release_dma(struct sh_mobile_i2c_data *pd)\n{\n\tif (!IS_ERR(pd->dma_tx)) {\n\t\tdma_release_channel(pd->dma_tx);\n\t\tpd->dma_tx = ERR_PTR(-EPROBE_DEFER);\n\t}\n\n\tif (!IS_ERR(pd->dma_rx)) {\n\t\tdma_release_channel(pd->dma_rx);\n\t\tpd->dma_rx = ERR_PTR(-EPROBE_DEFER);\n\t}\n}\n\nstatic int sh_mobile_i2c_hook_irqs(struct platform_device *dev, struct sh_mobile_i2c_data *pd)\n{\n\tstruct device_node *np = dev_of_node(&dev->dev);\n\tint k = 0, ret;\n\n\tif (np) {\n\t\tint irq;\n\n\t\twhile ((irq = platform_get_irq_optional(dev, k)) != -ENXIO) {\n\t\t\tif (irq < 0)\n\t\t\t\treturn irq;\n\t\t\tret = devm_request_irq(&dev->dev, irq, sh_mobile_i2c_isr,\n\t\t\t\t\t       0, dev_name(&dev->dev), pd);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(&dev->dev, \"cannot request IRQ %d\\n\", irq);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tk++;\n\t\t}\n\t} else {\n\t\tstruct resource *res;\n\t\tresource_size_t n;\n\n\t\twhile ((res = platform_get_resource(dev, IORESOURCE_IRQ, k))) {\n\t\t\tfor (n = res->start; n <= res->end; n++) {\n\t\t\t\tret = devm_request_irq(&dev->dev, n, sh_mobile_i2c_isr,\n\t\t\t\t\t\t       0, dev_name(&dev->dev), pd);\n\t\t\t\tif (ret) {\n\t\t\t\t\tdev_err(&dev->dev, \"cannot request IRQ %pa\\n\", &n);\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t}\n\t\t\tk++;\n\t\t}\n\t}\n\n\treturn k > 0 ? 0 : -ENOENT;\n}\n\nstatic int sh_mobile_i2c_probe(struct platform_device *dev)\n{\n\tstruct sh_mobile_i2c_data *pd;\n\tstruct i2c_adapter *adap;\n\tconst struct sh_mobile_dt_config *config;\n\tint ret;\n\tu32 bus_speed;\n\n\tpd = devm_kzalloc(&dev->dev, sizeof(struct sh_mobile_i2c_data), GFP_KERNEL);\n\tif (!pd)\n\t\treturn -ENOMEM;\n\n\tpd->clk = devm_clk_get(&dev->dev, NULL);\n\tif (IS_ERR(pd->clk)) {\n\t\tdev_err(&dev->dev, \"cannot get clock\\n\");\n\t\treturn PTR_ERR(pd->clk);\n\t}\n\n\tret = sh_mobile_i2c_hook_irqs(dev, pd);\n\tif (ret)\n\t\treturn ret;\n\n\tpd->dev = &dev->dev;\n\tplatform_set_drvdata(dev, pd);\n\n\tpd->reg = devm_platform_get_and_ioremap_resource(dev, 0, &pd->res);\n\tif (IS_ERR(pd->reg))\n\t\treturn PTR_ERR(pd->reg);\n\n\tret = of_property_read_u32(dev->dev.of_node, \"clock-frequency\", &bus_speed);\n\tpd->bus_speed = (ret || !bus_speed) ? I2C_MAX_STANDARD_MODE_FREQ : bus_speed;\n\tpd->clks_per_count = 1;\n\n\t \n\tif (resource_size(pd->res) > 0x17)\n\t\tpd->flags |= IIC_FLAG_HAS_ICIC67;\n\n\tpm_runtime_enable(&dev->dev);\n\tpm_runtime_get_sync(&dev->dev);\n\n\tconfig = of_device_get_match_data(&dev->dev);\n\tif (config) {\n\t\tpd->clks_per_count = config->clks_per_count;\n\t\tret = config->setup(pd);\n\t} else {\n\t\tret = sh_mobile_i2c_init(pd);\n\t}\n\n\tpm_runtime_put_sync(&dev->dev);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tsg_init_table(&pd->sg, 1);\n\tpd->dma_direction = DMA_NONE;\n\tpd->dma_rx = pd->dma_tx = ERR_PTR(-EPROBE_DEFER);\n\n\t \n\tadap = &pd->adap;\n\ti2c_set_adapdata(adap, pd);\n\n\tadap->owner = THIS_MODULE;\n\tadap->algo = &sh_mobile_i2c_algorithm;\n\tadap->quirks = &sh_mobile_i2c_quirks;\n\tadap->dev.parent = &dev->dev;\n\tadap->retries = 5;\n\tadap->nr = dev->id;\n\tadap->dev.of_node = dev->dev.of_node;\n\n\tstrscpy(adap->name, dev->name, sizeof(adap->name));\n\n\tspin_lock_init(&pd->lock);\n\tinit_waitqueue_head(&pd->wait);\n\n\tret = i2c_add_numbered_adapter(adap);\n\tif (ret < 0) {\n\t\tsh_mobile_i2c_release_dma(pd);\n\t\treturn ret;\n\t}\n\n\tdev_info(&dev->dev, \"I2C adapter %d, bus speed %lu Hz\\n\", adap->nr, pd->bus_speed);\n\n\treturn 0;\n}\n\nstatic void sh_mobile_i2c_remove(struct platform_device *dev)\n{\n\tstruct sh_mobile_i2c_data *pd = platform_get_drvdata(dev);\n\n\ti2c_del_adapter(&pd->adap);\n\tsh_mobile_i2c_release_dma(pd);\n\tpm_runtime_disable(&dev->dev);\n}\n\nstatic int sh_mobile_i2c_suspend(struct device *dev)\n{\n\tstruct sh_mobile_i2c_data *pd = dev_get_drvdata(dev);\n\n\ti2c_mark_adapter_suspended(&pd->adap);\n\treturn 0;\n}\n\nstatic int sh_mobile_i2c_resume(struct device *dev)\n{\n\tstruct sh_mobile_i2c_data *pd = dev_get_drvdata(dev);\n\n\ti2c_mark_adapter_resumed(&pd->adap);\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops sh_mobile_i2c_pm_ops = {\n\tNOIRQ_SYSTEM_SLEEP_PM_OPS(sh_mobile_i2c_suspend,\n\t\t\t\t  sh_mobile_i2c_resume)\n};\n\nstatic struct platform_driver sh_mobile_i2c_driver = {\n\t.driver\t\t= {\n\t\t.name\t\t= \"i2c-sh_mobile\",\n\t\t.of_match_table = sh_mobile_i2c_dt_ids,\n\t\t.pm\t= pm_sleep_ptr(&sh_mobile_i2c_pm_ops),\n\t},\n\t.probe\t\t= sh_mobile_i2c_probe,\n\t.remove_new\t= sh_mobile_i2c_remove,\n};\n\nstatic int __init sh_mobile_i2c_adap_init(void)\n{\n\treturn platform_driver_register(&sh_mobile_i2c_driver);\n}\nsubsys_initcall(sh_mobile_i2c_adap_init);\n\nstatic void __exit sh_mobile_i2c_adap_exit(void)\n{\n\tplatform_driver_unregister(&sh_mobile_i2c_driver);\n}\nmodule_exit(sh_mobile_i2c_adap_exit);\n\nMODULE_DESCRIPTION(\"SuperH Mobile I2C Bus Controller driver\");\nMODULE_AUTHOR(\"Magnus Damm\");\nMODULE_AUTHOR(\"Wolfram Sang\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:i2c-sh_mobile\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}