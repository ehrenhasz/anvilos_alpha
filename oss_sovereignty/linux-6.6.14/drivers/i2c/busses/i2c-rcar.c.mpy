{
  "module_name": "i2c-rcar.c",
  "hash_id": "1e4a5f5caf0403743c668b3252f05d87b1be822698020e52dd4e3d31996496ac",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-rcar.c",
  "human_readable_source": "\n \n#include <linux/bitops.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/dmaengine.h>\n#include <linux/dma-mapping.h>\n#include <linux/err.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/i2c.h>\n#include <linux/i2c-smbus.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/reset.h>\n#include <linux/slab.h>\n\n \n#define ICSCR\t0x00\t \n#define ICMCR\t0x04\t \n#define ICSSR\t0x08\t \n#define ICMSR\t0x0C\t \n#define ICSIER\t0x10\t \n#define ICMIER\t0x14\t \n#define ICCCR\t0x18\t \n#define ICSAR\t0x1C\t \n#define ICMAR\t0x20\t \n#define ICRXTX\t0x24\t \n#define ICFBSCR\t0x38\t \n#define ICDMAER\t0x3c\t \n\n \n#define SDBS\tBIT(3)\t \n#define SIE\tBIT(2)\t \n#define GCAE\tBIT(1)\t \n#define FNA\tBIT(0)\t \n\n \n#define MDBS\tBIT(7)\t \n#define FSCL\tBIT(6)\t \n#define FSDA\tBIT(5)\t \n#define OBPC\tBIT(4)\t \n#define MIE\tBIT(3)\t \n#define TSBE\tBIT(2)\n#define FSB\tBIT(1)\t \n#define ESG\tBIT(0)\t \n\n \n#define GCAR\tBIT(6)\t \n#define STM\tBIT(5)\t \n#define SSR\tBIT(4)\t \n#define SDE\tBIT(3)\t \n#define SDT\tBIT(2)\t \n#define SDR\tBIT(1)\t \n#define SAR\tBIT(0)\t \n\n \n#define MNR\tBIT(6)\t \n#define MAL\tBIT(5)\t \n#define MST\tBIT(4)\t \n#define MDE\tBIT(3)\n#define MDT\tBIT(2)\n#define MDR\tBIT(1)\n#define MAT\tBIT(0)\t \n\n \n#define RSDMAE\tBIT(3)\t \n#define TSDMAE\tBIT(2)\t \n#define RMDMAE\tBIT(1)\t \n#define TMDMAE\tBIT(0)\t \n\n \n#define TCYC17\t0x0f\t\t \n\n#define RCAR_MIN_DMA_LEN\t8\n\n#define RCAR_BUS_PHASE_START\t(MDBS | MIE | ESG)\n#define RCAR_BUS_PHASE_DATA\t(MDBS | MIE)\n#define RCAR_BUS_PHASE_STOP\t(MDBS | MIE | FSB)\n\n#define RCAR_IRQ_SEND\t(MNR | MAL | MST | MAT | MDE)\n#define RCAR_IRQ_RECV\t(MNR | MAL | MST | MAT | MDR)\n#define RCAR_IRQ_STOP\t(MST)\n\n#define ID_LAST_MSG\t\tBIT(0)\n#define ID_REP_AFTER_RD\t\tBIT(1)\n#define ID_DONE\t\t\tBIT(2)\n#define ID_ARBLOST\t\tBIT(3)\n#define ID_NACK\t\t\tBIT(4)\n#define ID_EPROTO\t\tBIT(5)\n \n#define ID_P_NOT_ATOMIC\t\tBIT(28)\n#define ID_P_HOST_NOTIFY\tBIT(29)\n#define ID_P_NO_RXDMA\t\tBIT(30)  \n#define ID_P_PM_BLOCKED\t\tBIT(31)\n#define ID_P_MASK\t\tGENMASK(31, 28)\n\nenum rcar_i2c_type {\n\tI2C_RCAR_GEN1,\n\tI2C_RCAR_GEN2,\n\tI2C_RCAR_GEN3,\n};\n\nstruct rcar_i2c_priv {\n\tu32 flags;\n\tvoid __iomem *io;\n\tstruct i2c_adapter adap;\n\tstruct i2c_msg *msg;\n\tint msgs_left;\n\tstruct clk *clk;\n\n\twait_queue_head_t wait;\n\n\tint pos;\n\tu32 icccr;\n\tu8 recovery_icmcr;\t \n\tenum rcar_i2c_type devtype;\n\tstruct i2c_client *slave;\n\n\tstruct resource *res;\n\tstruct dma_chan *dma_tx;\n\tstruct dma_chan *dma_rx;\n\tstruct scatterlist sg;\n\tenum dma_data_direction dma_direction;\n\n\tstruct reset_control *rstc;\n\tint irq;\n\n\tstruct i2c_client *host_notify_client;\n};\n\n#define rcar_i2c_priv_to_dev(p)\t\t((p)->adap.dev.parent)\n#define rcar_i2c_is_recv(p)\t\t((p)->msg->flags & I2C_M_RD)\n\nstatic void rcar_i2c_write(struct rcar_i2c_priv *priv, int reg, u32 val)\n{\n\twritel(val, priv->io + reg);\n}\n\nstatic u32 rcar_i2c_read(struct rcar_i2c_priv *priv, int reg)\n{\n\treturn readl(priv->io + reg);\n}\n\nstatic void rcar_i2c_clear_irq(struct rcar_i2c_priv *priv, u32 val)\n{\n\twritel(~val & 0x7f, priv->io + ICMSR);\n}\n\nstatic int rcar_i2c_get_scl(struct i2c_adapter *adap)\n{\n\tstruct rcar_i2c_priv *priv = i2c_get_adapdata(adap);\n\n\treturn !!(rcar_i2c_read(priv, ICMCR) & FSCL);\n\n};\n\nstatic void rcar_i2c_set_scl(struct i2c_adapter *adap, int val)\n{\n\tstruct rcar_i2c_priv *priv = i2c_get_adapdata(adap);\n\n\tif (val)\n\t\tpriv->recovery_icmcr |= FSCL;\n\telse\n\t\tpriv->recovery_icmcr &= ~FSCL;\n\n\trcar_i2c_write(priv, ICMCR, priv->recovery_icmcr);\n};\n\nstatic void rcar_i2c_set_sda(struct i2c_adapter *adap, int val)\n{\n\tstruct rcar_i2c_priv *priv = i2c_get_adapdata(adap);\n\n\tif (val)\n\t\tpriv->recovery_icmcr |= FSDA;\n\telse\n\t\tpriv->recovery_icmcr &= ~FSDA;\n\n\trcar_i2c_write(priv, ICMCR, priv->recovery_icmcr);\n};\n\nstatic int rcar_i2c_get_bus_free(struct i2c_adapter *adap)\n{\n\tstruct rcar_i2c_priv *priv = i2c_get_adapdata(adap);\n\n\treturn !(rcar_i2c_read(priv, ICMCR) & FSDA);\n\n};\n\nstatic struct i2c_bus_recovery_info rcar_i2c_bri = {\n\t.get_scl = rcar_i2c_get_scl,\n\t.set_scl = rcar_i2c_set_scl,\n\t.set_sda = rcar_i2c_set_sda,\n\t.get_bus_free = rcar_i2c_get_bus_free,\n\t.recover_bus = i2c_generic_scl_recovery,\n};\nstatic void rcar_i2c_init(struct rcar_i2c_priv *priv)\n{\n\t \n\trcar_i2c_write(priv, ICMIER, 0);\n\trcar_i2c_write(priv, ICMCR, MDBS);\n\trcar_i2c_write(priv, ICMSR, 0);\n\t \n\trcar_i2c_write(priv, ICCCR, priv->icccr);\n\n\tif (priv->devtype == I2C_RCAR_GEN3)\n\t\trcar_i2c_write(priv, ICFBSCR, TCYC17);\n\n}\n\nstatic int rcar_i2c_bus_barrier(struct rcar_i2c_priv *priv)\n{\n\tint ret;\n\tu32 val;\n\n\tret = readl_poll_timeout(priv->io + ICMCR, val, !(val & FSDA), 10,\n\t\t\t\t priv->adap.timeout);\n\tif (ret) {\n\t\t \n\t\tpriv->recovery_icmcr = MDBS | OBPC | FSDA | FSCL;\n\t\tret = i2c_recover_bus(&priv->adap);\n\t}\n\n\treturn ret;\n}\n\nstatic int rcar_i2c_clock_calculate(struct rcar_i2c_priv *priv)\n{\n\tu32 scgd, cdf, round, ick, sum, scl, cdf_width;\n\tunsigned long rate;\n\tstruct device *dev = rcar_i2c_priv_to_dev(priv);\n\tstruct i2c_timings t = {\n\t\t.bus_freq_hz\t\t= I2C_MAX_STANDARD_MODE_FREQ,\n\t\t.scl_fall_ns\t\t= 35,\n\t\t.scl_rise_ns\t\t= 200,\n\t\t.scl_int_delay_ns\t= 50,\n\t};\n\n\t \n\ti2c_parse_fw_timings(dev, &t, false);\n\n\tswitch (priv->devtype) {\n\tcase I2C_RCAR_GEN1:\n\t\tcdf_width = 2;\n\t\tbreak;\n\tcase I2C_RCAR_GEN2:\n\tcase I2C_RCAR_GEN3:\n\t\tcdf_width = 3;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"device type error\\n\");\n\t\treturn -EIO;\n\t}\n\n\t \n\trate = clk_get_rate(priv->clk);\n\tcdf = rate / 20000000;\n\tif (cdf >= 1U << cdf_width) {\n\t\tdev_err(dev, \"Input clock %lu too high\\n\", rate);\n\t\treturn -EIO;\n\t}\n\tick = rate / (cdf + 1);\n\n\t \n\tsum = t.scl_fall_ns + t.scl_rise_ns + t.scl_int_delay_ns;\n\tround = (ick + 500000) / 1000000 * sum;\n\tround = (round + 500) / 1000;\n\n\t \n\tfor (scgd = 0; scgd < 0x40; scgd++) {\n\t\tscl = ick / (20 + (scgd * 8) + round);\n\t\tif (scl <= t.bus_freq_hz)\n\t\t\tgoto scgd_find;\n\t}\n\tdev_err(dev, \"it is impossible to calculate best SCL\\n\");\n\treturn -EIO;\n\nscgd_find:\n\tdev_dbg(dev, \"clk %d/%d(%lu), round %u, CDF:0x%x, SCGD: 0x%x\\n\",\n\t\tscl, t.bus_freq_hz, rate, round, cdf, scgd);\n\n\t \n\tpriv->icccr = scgd << cdf_width | cdf;\n\n\treturn 0;\n}\n\n \nstatic void rcar_i2c_prepare_msg(struct rcar_i2c_priv *priv)\n{\n\tint read = !!rcar_i2c_is_recv(priv);\n\tbool rep_start = !(priv->flags & ID_REP_AFTER_RD);\n\n\tpriv->pos = 0;\n\tpriv->flags &= ID_P_MASK;\n\n\tif (priv->msgs_left == 1)\n\t\tpriv->flags |= ID_LAST_MSG;\n\n\trcar_i2c_write(priv, ICMAR, i2c_8bit_addr_from_msg(priv->msg));\n\tif (priv->flags & ID_P_NOT_ATOMIC)\n\t\trcar_i2c_write(priv, ICMIER, read ? RCAR_IRQ_RECV : RCAR_IRQ_SEND);\n\n\tif (rep_start)\n\t\trcar_i2c_write(priv, ICMCR, RCAR_BUS_PHASE_START);\n}\n\nstatic void rcar_i2c_first_msg(struct rcar_i2c_priv *priv,\n\t\t\t       struct i2c_msg *msgs, int num)\n{\n\tpriv->msg = msgs;\n\tpriv->msgs_left = num;\n\trcar_i2c_write(priv, ICMSR, 0);  \n\trcar_i2c_prepare_msg(priv);\n}\n\nstatic void rcar_i2c_next_msg(struct rcar_i2c_priv *priv)\n{\n\tpriv->msg++;\n\tpriv->msgs_left--;\n\trcar_i2c_prepare_msg(priv);\n\t \n}\n\nstatic void rcar_i2c_cleanup_dma(struct rcar_i2c_priv *priv, bool terminate)\n{\n\tstruct dma_chan *chan = priv->dma_direction == DMA_FROM_DEVICE\n\t\t? priv->dma_rx : priv->dma_tx;\n\n\t \n\tif (terminate)\n\t\tdmaengine_terminate_sync(chan);\n\n\tdma_unmap_single(chan->device->dev, sg_dma_address(&priv->sg),\n\t\t\t sg_dma_len(&priv->sg), priv->dma_direction);\n\n\t \n\tif (priv->devtype == I2C_RCAR_GEN3 &&\n\t    priv->dma_direction == DMA_FROM_DEVICE)\n\t\tpriv->flags |= ID_P_NO_RXDMA;\n\n\tpriv->dma_direction = DMA_NONE;\n\n\t \n\trcar_i2c_write(priv, ICDMAER, 0);\n}\n\nstatic void rcar_i2c_dma_callback(void *data)\n{\n\tstruct rcar_i2c_priv *priv = data;\n\n\tpriv->pos += sg_dma_len(&priv->sg);\n\n\trcar_i2c_cleanup_dma(priv, false);\n}\n\nstatic bool rcar_i2c_dma(struct rcar_i2c_priv *priv)\n{\n\tstruct device *dev = rcar_i2c_priv_to_dev(priv);\n\tstruct i2c_msg *msg = priv->msg;\n\tbool read = msg->flags & I2C_M_RD;\n\tenum dma_data_direction dir = read ? DMA_FROM_DEVICE : DMA_TO_DEVICE;\n\tstruct dma_chan *chan = read ? priv->dma_rx : priv->dma_tx;\n\tstruct dma_async_tx_descriptor *txdesc;\n\tdma_addr_t dma_addr;\n\tdma_cookie_t cookie;\n\tunsigned char *buf;\n\tint len;\n\n\t \n\tif (!(priv->flags & ID_P_NOT_ATOMIC) || IS_ERR(chan) || msg->len < RCAR_MIN_DMA_LEN ||\n\t    !(msg->flags & I2C_M_DMA_SAFE) || (read && priv->flags & ID_P_NO_RXDMA))\n\t\treturn false;\n\n\tif (read) {\n\t\t \n\t\tbuf = priv->msg->buf;\n\t\tlen = priv->msg->len - 2;\n\t} else {\n\t\t \n\t\tbuf = priv->msg->buf + 1;\n\t\tlen = priv->msg->len - 1;\n\t}\n\n\tdma_addr = dma_map_single(chan->device->dev, buf, len, dir);\n\tif (dma_mapping_error(chan->device->dev, dma_addr)) {\n\t\tdev_dbg(dev, \"dma map failed, using PIO\\n\");\n\t\treturn false;\n\t}\n\n\tsg_dma_len(&priv->sg) = len;\n\tsg_dma_address(&priv->sg) = dma_addr;\n\n\tpriv->dma_direction = dir;\n\n\ttxdesc = dmaengine_prep_slave_sg(chan, &priv->sg, 1,\n\t\t\t\t\t read ? DMA_DEV_TO_MEM : DMA_MEM_TO_DEV,\n\t\t\t\t\t DMA_PREP_INTERRUPT | DMA_CTRL_ACK);\n\tif (!txdesc) {\n\t\tdev_dbg(dev, \"dma prep slave sg failed, using PIO\\n\");\n\t\trcar_i2c_cleanup_dma(priv, false);\n\t\treturn false;\n\t}\n\n\ttxdesc->callback = rcar_i2c_dma_callback;\n\ttxdesc->callback_param = priv;\n\n\tcookie = dmaengine_submit(txdesc);\n\tif (dma_submit_error(cookie)) {\n\t\tdev_dbg(dev, \"submitting dma failed, using PIO\\n\");\n\t\trcar_i2c_cleanup_dma(priv, false);\n\t\treturn false;\n\t}\n\n\t \n\tif (read)\n\t\trcar_i2c_write(priv, ICDMAER, RMDMAE);\n\telse\n\t\trcar_i2c_write(priv, ICDMAER, TMDMAE);\n\n\tdma_async_issue_pending(chan);\n\treturn true;\n}\n\nstatic void rcar_i2c_irq_send(struct rcar_i2c_priv *priv, u32 msr)\n{\n\tstruct i2c_msg *msg = priv->msg;\n\tu32 irqs_to_clear = MDE;\n\n\t \n\tif (!(msr & MDE))\n\t\treturn;\n\n\tif (msr & MAT)\n\t\tirqs_to_clear |= MAT;\n\n\t \n\tif (priv->pos == 1 && rcar_i2c_dma(priv))\n\t\treturn;\n\n\tif (priv->pos < msg->len) {\n\t\t \n\t\trcar_i2c_write(priv, ICRXTX, msg->buf[priv->pos]);\n\t\tpriv->pos++;\n\t} else {\n\t\t \n\n\t\tif (priv->flags & ID_LAST_MSG)\n\t\t\t \n\t\t\trcar_i2c_write(priv, ICMCR, RCAR_BUS_PHASE_STOP);\n\t\telse\n\t\t\trcar_i2c_next_msg(priv);\n\t}\n\n\trcar_i2c_clear_irq(priv, irqs_to_clear);\n}\n\nstatic void rcar_i2c_irq_recv(struct rcar_i2c_priv *priv, u32 msr)\n{\n\tstruct i2c_msg *msg = priv->msg;\n\tbool recv_len_init = priv->pos == 0 && msg->flags & I2C_M_RECV_LEN;\n\tu32 irqs_to_clear = MDR;\n\n\t \n\tif (!(msr & MDR))\n\t\treturn;\n\n\tif (msr & MAT) {\n\t\tirqs_to_clear |= MAT;\n\t\t \n\t\trcar_i2c_dma(priv);\n\t} else if (priv->pos < msg->len) {\n\t\t \n\t\tu8 data = rcar_i2c_read(priv, ICRXTX);\n\n\t\tmsg->buf[priv->pos] = data;\n\t\tif (recv_len_init) {\n\t\t\tif (data == 0 || data > I2C_SMBUS_BLOCK_MAX) {\n\t\t\t\tpriv->flags |= ID_DONE | ID_EPROTO;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tmsg->len += msg->buf[0];\n\t\t\t \n\t\t\tif (rcar_i2c_dma(priv))\n\t\t\t\treturn;\n\t\t\t \n\t\t\trecv_len_init = false;\n\t\t}\n\t\tpriv->pos++;\n\t}\n\n\t \n\tif (priv->pos + 1 == msg->len && !recv_len_init) {\n\t\tif (priv->flags & ID_LAST_MSG) {\n\t\t\trcar_i2c_write(priv, ICMCR, RCAR_BUS_PHASE_STOP);\n\t\t} else {\n\t\t\trcar_i2c_write(priv, ICMCR, RCAR_BUS_PHASE_START);\n\t\t\tpriv->flags |= ID_REP_AFTER_RD;\n\t\t}\n\t}\n\n\tif (priv->pos == msg->len && !(priv->flags & ID_LAST_MSG))\n\t\trcar_i2c_next_msg(priv);\n\n\trcar_i2c_clear_irq(priv, irqs_to_clear);\n}\n\nstatic bool rcar_i2c_slave_irq(struct rcar_i2c_priv *priv)\n{\n\tu32 ssr_raw, ssr_filtered;\n\tu8 value;\n\n\tssr_raw = rcar_i2c_read(priv, ICSSR) & 0xff;\n\tssr_filtered = ssr_raw & rcar_i2c_read(priv, ICSIER);\n\n\tif (!ssr_filtered)\n\t\treturn false;\n\n\t \n\tif (ssr_filtered & SAR) {\n\t\t \n\t\tif (ssr_raw & STM) {\n\t\t\ti2c_slave_event(priv->slave, I2C_SLAVE_READ_REQUESTED, &value);\n\t\t\trcar_i2c_write(priv, ICRXTX, value);\n\t\t\trcar_i2c_write(priv, ICSIER, SDE | SSR | SAR);\n\t\t} else {\n\t\t\ti2c_slave_event(priv->slave, I2C_SLAVE_WRITE_REQUESTED, &value);\n\t\t\trcar_i2c_read(priv, ICRXTX);\t \n\t\t\trcar_i2c_write(priv, ICSIER, SDR | SSR | SAR);\n\t\t}\n\n\t\t \n\t\trcar_i2c_write(priv, ICSSR, ~(SAR | SSR) & 0xff);\n\t}\n\n\t \n\tif (ssr_filtered & SSR) {\n\t\ti2c_slave_event(priv->slave, I2C_SLAVE_STOP, &value);\n\t\trcar_i2c_write(priv, ICSCR, SIE | SDBS);  \n\t\trcar_i2c_write(priv, ICSIER, SAR);\n\t\trcar_i2c_write(priv, ICSSR, ~SSR & 0xff);\n\t}\n\n\t \n\tif (ssr_filtered & SDR) {\n\t\tint ret;\n\n\t\tvalue = rcar_i2c_read(priv, ICRXTX);\n\t\tret = i2c_slave_event(priv->slave, I2C_SLAVE_WRITE_RECEIVED, &value);\n\t\t \n\t\trcar_i2c_write(priv, ICSCR, SIE | SDBS | (ret < 0 ? FNA : 0));\n\t\trcar_i2c_write(priv, ICSSR, ~SDR & 0xff);\n\t}\n\n\t \n\tif (ssr_filtered & SDE) {\n\t\ti2c_slave_event(priv->slave, I2C_SLAVE_READ_PROCESSED, &value);\n\t\trcar_i2c_write(priv, ICRXTX, value);\n\t\trcar_i2c_write(priv, ICSSR, ~SDE & 0xff);\n\t}\n\n\treturn true;\n}\n\n \nstatic irqreturn_t rcar_i2c_irq(int irq, struct rcar_i2c_priv *priv, u32 msr)\n{\n\tif (!msr) {\n\t\tif (rcar_i2c_slave_irq(priv))\n\t\t\treturn IRQ_HANDLED;\n\n\t\treturn IRQ_NONE;\n\t}\n\n\t \n\tif (msr & MAL) {\n\t\tpriv->flags |= ID_DONE | ID_ARBLOST;\n\t\tgoto out;\n\t}\n\n\t \n\tif (msr & MNR) {\n\t\t \n\t\tif (priv->flags & ID_P_NOT_ATOMIC)\n\t\t\trcar_i2c_write(priv, ICMIER, RCAR_IRQ_STOP);\n\t\tpriv->flags |= ID_NACK;\n\t\tgoto out;\n\t}\n\n\t \n\tif (msr & MST) {\n\t\tpriv->msgs_left--;  \n\t\tpriv->flags |= ID_DONE;\n\t\tgoto out;\n\t}\n\n\tif (rcar_i2c_is_recv(priv))\n\t\trcar_i2c_irq_recv(priv, msr);\n\telse\n\t\trcar_i2c_irq_send(priv, msr);\n\nout:\n\tif (priv->flags & ID_DONE) {\n\t\trcar_i2c_write(priv, ICMIER, 0);\n\t\trcar_i2c_write(priv, ICMSR, 0);\n\t\tif (priv->flags & ID_P_NOT_ATOMIC)\n\t\t\twake_up(&priv->wait);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t rcar_i2c_gen2_irq(int irq, void *ptr)\n{\n\tstruct rcar_i2c_priv *priv = ptr;\n\tu32 msr;\n\n\t \n\tif (likely(!(priv->flags & ID_REP_AFTER_RD)))\n\t\trcar_i2c_write(priv, ICMCR, RCAR_BUS_PHASE_DATA);\n\n\t \n\tmsr = rcar_i2c_read(priv, ICMSR);\n\tif (priv->flags & ID_P_NOT_ATOMIC)\n\t\tmsr &= rcar_i2c_read(priv, ICMIER);\n\n\treturn rcar_i2c_irq(irq, priv, msr);\n}\n\nstatic irqreturn_t rcar_i2c_gen3_irq(int irq, void *ptr)\n{\n\tstruct rcar_i2c_priv *priv = ptr;\n\tu32 msr;\n\n\t \n\tmsr = rcar_i2c_read(priv, ICMSR);\n\tif (priv->flags & ID_P_NOT_ATOMIC)\n\t\tmsr &= rcar_i2c_read(priv, ICMIER);\n\n\t \n\tif (likely(!(priv->flags & ID_REP_AFTER_RD) && msr))\n\t\trcar_i2c_write(priv, ICMCR, RCAR_BUS_PHASE_DATA);\n\n\treturn rcar_i2c_irq(irq, priv, msr);\n}\n\nstatic struct dma_chan *rcar_i2c_request_dma_chan(struct device *dev,\n\t\t\t\t\tenum dma_transfer_direction dir,\n\t\t\t\t\tdma_addr_t port_addr)\n{\n\tstruct dma_chan *chan;\n\tstruct dma_slave_config cfg;\n\tchar *chan_name = dir == DMA_MEM_TO_DEV ? \"tx\" : \"rx\";\n\tint ret;\n\n\tchan = dma_request_chan(dev, chan_name);\n\tif (IS_ERR(chan)) {\n\t\tdev_dbg(dev, \"request_channel failed for %s (%ld)\\n\",\n\t\t\tchan_name, PTR_ERR(chan));\n\t\treturn chan;\n\t}\n\n\tmemset(&cfg, 0, sizeof(cfg));\n\tcfg.direction = dir;\n\tif (dir == DMA_MEM_TO_DEV) {\n\t\tcfg.dst_addr = port_addr;\n\t\tcfg.dst_addr_width = DMA_SLAVE_BUSWIDTH_1_BYTE;\n\t} else {\n\t\tcfg.src_addr = port_addr;\n\t\tcfg.src_addr_width = DMA_SLAVE_BUSWIDTH_1_BYTE;\n\t}\n\n\tret = dmaengine_slave_config(chan, &cfg);\n\tif (ret) {\n\t\tdev_dbg(dev, \"slave_config failed for %s (%d)\\n\",\n\t\t\tchan_name, ret);\n\t\tdma_release_channel(chan);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tdev_dbg(dev, \"got DMA channel for %s\\n\", chan_name);\n\treturn chan;\n}\n\nstatic void rcar_i2c_request_dma(struct rcar_i2c_priv *priv,\n\t\t\t\t struct i2c_msg *msg)\n{\n\tstruct device *dev = rcar_i2c_priv_to_dev(priv);\n\tbool read;\n\tstruct dma_chan *chan;\n\tenum dma_transfer_direction dir;\n\n\tread = msg->flags & I2C_M_RD;\n\n\tchan = read ? priv->dma_rx : priv->dma_tx;\n\tif (PTR_ERR(chan) != -EPROBE_DEFER)\n\t\treturn;\n\n\tdir = read ? DMA_DEV_TO_MEM : DMA_MEM_TO_DEV;\n\tchan = rcar_i2c_request_dma_chan(dev, dir, priv->res->start + ICRXTX);\n\n\tif (read)\n\t\tpriv->dma_rx = chan;\n\telse\n\t\tpriv->dma_tx = chan;\n}\n\nstatic void rcar_i2c_release_dma(struct rcar_i2c_priv *priv)\n{\n\tif (!IS_ERR(priv->dma_tx)) {\n\t\tdma_release_channel(priv->dma_tx);\n\t\tpriv->dma_tx = ERR_PTR(-EPROBE_DEFER);\n\t}\n\n\tif (!IS_ERR(priv->dma_rx)) {\n\t\tdma_release_channel(priv->dma_rx);\n\t\tpriv->dma_rx = ERR_PTR(-EPROBE_DEFER);\n\t}\n}\n\n \nstatic int rcar_i2c_do_reset(struct rcar_i2c_priv *priv)\n{\n\tint ret;\n\n\tret = reset_control_reset(priv->rstc);\n\tif (ret)\n\t\treturn ret;\n\n\treturn read_poll_timeout_atomic(reset_control_status, ret, ret == 0, 1,\n\t\t\t\t\t100, false, priv->rstc);\n}\n\nstatic int rcar_i2c_master_xfer(struct i2c_adapter *adap,\n\t\t\t\tstruct i2c_msg *msgs,\n\t\t\t\tint num)\n{\n\tstruct rcar_i2c_priv *priv = i2c_get_adapdata(adap);\n\tstruct device *dev = rcar_i2c_priv_to_dev(priv);\n\tint i, ret;\n\tlong time_left;\n\n\tpriv->flags |= ID_P_NOT_ATOMIC;\n\n\tpm_runtime_get_sync(dev);\n\n\t \n\tret = rcar_i2c_bus_barrier(priv);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t \n\tif (priv->devtype == I2C_RCAR_GEN3) {\n\t\tpriv->flags |= ID_P_NO_RXDMA;\n\t\tif (!IS_ERR(priv->rstc)) {\n\t\t\tret = rcar_i2c_do_reset(priv);\n\t\t\tif (ret == 0)\n\t\t\t\tpriv->flags &= ~ID_P_NO_RXDMA;\n\t\t}\n\t}\n\n\trcar_i2c_init(priv);\n\n\tfor (i = 0; i < num; i++)\n\t\trcar_i2c_request_dma(priv, msgs + i);\n\n\trcar_i2c_first_msg(priv, msgs, num);\n\n\ttime_left = wait_event_timeout(priv->wait, priv->flags & ID_DONE,\n\t\t\t\t     num * adap->timeout);\n\n\t \n\tif (priv->dma_direction != DMA_NONE)\n\t\trcar_i2c_cleanup_dma(priv, true);\n\n\tif (!time_left) {\n\t\trcar_i2c_init(priv);\n\t\tret = -ETIMEDOUT;\n\t} else if (priv->flags & ID_NACK) {\n\t\tret = -ENXIO;\n\t} else if (priv->flags & ID_ARBLOST) {\n\t\tret = -EAGAIN;\n\t} else if (priv->flags & ID_EPROTO) {\n\t\tret = -EPROTO;\n\t} else {\n\t\tret = num - priv->msgs_left;  \n\t}\nout:\n\tpm_runtime_put(dev);\n\n\tif (ret < 0 && ret != -ENXIO)\n\t\tdev_err(dev, \"error %d : %x\\n\", ret, priv->flags);\n\n\treturn ret;\n}\n\nstatic int rcar_i2c_master_xfer_atomic(struct i2c_adapter *adap,\n\t\t\t\tstruct i2c_msg *msgs,\n\t\t\t\tint num)\n{\n\tstruct rcar_i2c_priv *priv = i2c_get_adapdata(adap);\n\tstruct device *dev = rcar_i2c_priv_to_dev(priv);\n\tunsigned long j;\n\tbool time_left;\n\tint ret;\n\n\tpriv->flags &= ~ID_P_NOT_ATOMIC;\n\n\tpm_runtime_get_sync(dev);\n\n\t \n\tret = rcar_i2c_bus_barrier(priv);\n\tif (ret < 0)\n\t\tgoto out;\n\n\trcar_i2c_init(priv);\n\trcar_i2c_first_msg(priv, msgs, num);\n\n\tj = jiffies + num * adap->timeout;\n\tdo {\n\t\tu32 msr = rcar_i2c_read(priv, ICMSR);\n\n\t\tmsr &= (rcar_i2c_is_recv(priv) ? RCAR_IRQ_RECV : RCAR_IRQ_SEND) | RCAR_IRQ_STOP;\n\n\t\tif (msr) {\n\t\t\tif (priv->devtype < I2C_RCAR_GEN3)\n\t\t\t\trcar_i2c_gen2_irq(0, priv);\n\t\t\telse\n\t\t\t\trcar_i2c_gen3_irq(0, priv);\n\t\t}\n\n\t\ttime_left = time_before_eq(jiffies, j);\n\t} while (!(priv->flags & ID_DONE) && time_left);\n\n\tif (!time_left) {\n\t\trcar_i2c_init(priv);\n\t\tret = -ETIMEDOUT;\n\t} else if (priv->flags & ID_NACK) {\n\t\tret = -ENXIO;\n\t} else if (priv->flags & ID_ARBLOST) {\n\t\tret = -EAGAIN;\n\t} else if (priv->flags & ID_EPROTO) {\n\t\tret = -EPROTO;\n\t} else {\n\t\tret = num - priv->msgs_left;  \n\t}\nout:\n\tpm_runtime_put(dev);\n\n\tif (ret < 0 && ret != -ENXIO)\n\t\tdev_err(dev, \"error %d : %x\\n\", ret, priv->flags);\n\n\treturn ret;\n}\n\nstatic int rcar_reg_slave(struct i2c_client *slave)\n{\n\tstruct rcar_i2c_priv *priv = i2c_get_adapdata(slave->adapter);\n\n\tif (priv->slave)\n\t\treturn -EBUSY;\n\n\tif (slave->flags & I2C_CLIENT_TEN)\n\t\treturn -EAFNOSUPPORT;\n\n\t \n\tpm_runtime_get_sync(rcar_i2c_priv_to_dev(priv));\n\n\tpriv->slave = slave;\n\trcar_i2c_write(priv, ICSAR, slave->addr);\n\trcar_i2c_write(priv, ICSSR, 0);\n\trcar_i2c_write(priv, ICSIER, SAR);\n\trcar_i2c_write(priv, ICSCR, SIE | SDBS);\n\n\treturn 0;\n}\n\nstatic int rcar_unreg_slave(struct i2c_client *slave)\n{\n\tstruct rcar_i2c_priv *priv = i2c_get_adapdata(slave->adapter);\n\n\tWARN_ON(!priv->slave);\n\n\t \n\tdisable_irq(priv->irq);\n\trcar_i2c_write(priv, ICSIER, 0);\n\trcar_i2c_write(priv, ICSSR, 0);\n\tenable_irq(priv->irq);\n\trcar_i2c_write(priv, ICSCR, SDBS);\n\trcar_i2c_write(priv, ICSAR, 0);  \n\n\tpriv->slave = NULL;\n\n\tpm_runtime_put(rcar_i2c_priv_to_dev(priv));\n\n\treturn 0;\n}\n\nstatic u32 rcar_i2c_func(struct i2c_adapter *adap)\n{\n\tstruct rcar_i2c_priv *priv = i2c_get_adapdata(adap);\n\n\t \n\tu32 func = I2C_FUNC_I2C | I2C_FUNC_SLAVE |\n\t\t   (I2C_FUNC_SMBUS_EMUL_ALL & ~I2C_FUNC_SMBUS_QUICK);\n\n\tif (priv->flags & ID_P_HOST_NOTIFY)\n\t\tfunc |= I2C_FUNC_SMBUS_HOST_NOTIFY;\n\n\treturn func;\n}\n\nstatic const struct i2c_algorithm rcar_i2c_algo = {\n\t.master_xfer\t= rcar_i2c_master_xfer,\n\t.master_xfer_atomic = rcar_i2c_master_xfer_atomic,\n\t.functionality\t= rcar_i2c_func,\n\t.reg_slave\t= rcar_reg_slave,\n\t.unreg_slave\t= rcar_unreg_slave,\n};\n\nstatic const struct i2c_adapter_quirks rcar_i2c_quirks = {\n\t.flags = I2C_AQ_NO_ZERO_LEN,\n};\n\nstatic const struct of_device_id rcar_i2c_dt_ids[] = {\n\t{ .compatible = \"renesas,i2c-r8a7778\", .data = (void *)I2C_RCAR_GEN1 },\n\t{ .compatible = \"renesas,i2c-r8a7779\", .data = (void *)I2C_RCAR_GEN1 },\n\t{ .compatible = \"renesas,i2c-r8a7790\", .data = (void *)I2C_RCAR_GEN2 },\n\t{ .compatible = \"renesas,i2c-r8a7791\", .data = (void *)I2C_RCAR_GEN2 },\n\t{ .compatible = \"renesas,i2c-r8a7792\", .data = (void *)I2C_RCAR_GEN2 },\n\t{ .compatible = \"renesas,i2c-r8a7793\", .data = (void *)I2C_RCAR_GEN2 },\n\t{ .compatible = \"renesas,i2c-r8a7794\", .data = (void *)I2C_RCAR_GEN2 },\n\t{ .compatible = \"renesas,i2c-r8a7795\", .data = (void *)I2C_RCAR_GEN3 },\n\t{ .compatible = \"renesas,i2c-r8a7796\", .data = (void *)I2C_RCAR_GEN3 },\n\t{ .compatible = \"renesas,rcar-gen1-i2c\", .data = (void *)I2C_RCAR_GEN1 },\n\t{ .compatible = \"renesas,rcar-gen2-i2c\", .data = (void *)I2C_RCAR_GEN2 },\n\t{ .compatible = \"renesas,rcar-gen3-i2c\", .data = (void *)I2C_RCAR_GEN3 },\n\t{ .compatible = \"renesas,rcar-gen4-i2c\", .data = (void *)I2C_RCAR_GEN3 },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, rcar_i2c_dt_ids);\n\nstatic int rcar_i2c_probe(struct platform_device *pdev)\n{\n\tstruct rcar_i2c_priv *priv;\n\tstruct i2c_adapter *adap;\n\tstruct device *dev = &pdev->dev;\n\tunsigned long irqflags = 0;\n\tirqreturn_t (*irqhandler)(int irq, void *ptr) = rcar_i2c_gen3_irq;\n\tint ret;\n\n\t \n\tBUILD_BUG_ON_MSG(RCAR_MIN_DMA_LEN < 3, \"Invalid min DMA length\");\n\n\tpriv = devm_kzalloc(dev, sizeof(struct rcar_i2c_priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->clk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(priv->clk)) {\n\t\tdev_err(dev, \"cannot get clock\\n\");\n\t\treturn PTR_ERR(priv->clk);\n\t}\n\n\tpriv->io = devm_platform_get_and_ioremap_resource(pdev, 0, &priv->res);\n\tif (IS_ERR(priv->io))\n\t\treturn PTR_ERR(priv->io);\n\n\tpriv->devtype = (enum rcar_i2c_type)of_device_get_match_data(dev);\n\tinit_waitqueue_head(&priv->wait);\n\n\tadap = &priv->adap;\n\tadap->nr = pdev->id;\n\tadap->algo = &rcar_i2c_algo;\n\tadap->class = I2C_CLASS_DEPRECATED;\n\tadap->retries = 3;\n\tadap->dev.parent = dev;\n\tadap->dev.of_node = dev->of_node;\n\tadap->bus_recovery_info = &rcar_i2c_bri;\n\tadap->quirks = &rcar_i2c_quirks;\n\ti2c_set_adapdata(adap, priv);\n\tstrscpy(adap->name, pdev->name, sizeof(adap->name));\n\n\t \n\tsg_init_table(&priv->sg, 1);\n\tpriv->dma_direction = DMA_NONE;\n\tpriv->dma_rx = priv->dma_tx = ERR_PTR(-EPROBE_DEFER);\n\n\t \n\tpm_runtime_enable(dev);\n\tpm_runtime_get_sync(dev);\n\tret = rcar_i2c_clock_calculate(priv);\n\tif (ret < 0) {\n\t\tpm_runtime_put(dev);\n\t\tgoto out_pm_disable;\n\t}\n\n\trcar_i2c_write(priv, ICSAR, 0);  \n\n\tif (priv->devtype < I2C_RCAR_GEN3) {\n\t\tirqflags |= IRQF_NO_THREAD;\n\t\tirqhandler = rcar_i2c_gen2_irq;\n\t}\n\n\tif (priv->devtype == I2C_RCAR_GEN3) {\n\t\tpriv->rstc = devm_reset_control_get_exclusive(&pdev->dev, NULL);\n\t\tif (!IS_ERR(priv->rstc)) {\n\t\t\tret = reset_control_status(priv->rstc);\n\t\t\tif (ret < 0)\n\t\t\t\tpriv->rstc = ERR_PTR(-ENOTSUPP);\n\t\t}\n\t}\n\n\t \n\tif (of_property_read_bool(dev->of_node, \"multi-master\"))\n\t\tpriv->flags |= ID_P_PM_BLOCKED;\n\telse\n\t\tpm_runtime_put(dev);\n\n\tif (of_property_read_bool(dev->of_node, \"smbus\"))\n\t\tpriv->flags |= ID_P_HOST_NOTIFY;\n\n\tret = platform_get_irq(pdev, 0);\n\tif (ret < 0)\n\t\tgoto out_pm_put;\n\tpriv->irq = ret;\n\tret = devm_request_irq(dev, priv->irq, irqhandler, irqflags, dev_name(dev), priv);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"cannot get irq %d\\n\", priv->irq);\n\t\tgoto out_pm_put;\n\t}\n\n\tplatform_set_drvdata(pdev, priv);\n\n\tret = i2c_add_numbered_adapter(adap);\n\tif (ret < 0)\n\t\tgoto out_pm_put;\n\n\tif (priv->flags & ID_P_HOST_NOTIFY) {\n\t\tpriv->host_notify_client = i2c_new_slave_host_notify_device(adap);\n\t\tif (IS_ERR(priv->host_notify_client)) {\n\t\t\tret = PTR_ERR(priv->host_notify_client);\n\t\t\tgoto out_del_device;\n\t\t}\n\t}\n\n\tdev_info(dev, \"probed\\n\");\n\n\treturn 0;\n\n out_del_device:\n\ti2c_del_adapter(&priv->adap);\n out_pm_put:\n\tif (priv->flags & ID_P_PM_BLOCKED)\n\t\tpm_runtime_put(dev);\n out_pm_disable:\n\tpm_runtime_disable(dev);\n\treturn ret;\n}\n\nstatic void rcar_i2c_remove(struct platform_device *pdev)\n{\n\tstruct rcar_i2c_priv *priv = platform_get_drvdata(pdev);\n\tstruct device *dev = &pdev->dev;\n\n\tif (priv->host_notify_client)\n\t\ti2c_free_slave_host_notify_device(priv->host_notify_client);\n\ti2c_del_adapter(&priv->adap);\n\trcar_i2c_release_dma(priv);\n\tif (priv->flags & ID_P_PM_BLOCKED)\n\t\tpm_runtime_put(dev);\n\tpm_runtime_disable(dev);\n}\n\nstatic int rcar_i2c_suspend(struct device *dev)\n{\n\tstruct rcar_i2c_priv *priv = dev_get_drvdata(dev);\n\n\ti2c_mark_adapter_suspended(&priv->adap);\n\treturn 0;\n}\n\nstatic int rcar_i2c_resume(struct device *dev)\n{\n\tstruct rcar_i2c_priv *priv = dev_get_drvdata(dev);\n\n\ti2c_mark_adapter_resumed(&priv->adap);\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops rcar_i2c_pm_ops = {\n\tNOIRQ_SYSTEM_SLEEP_PM_OPS(rcar_i2c_suspend, rcar_i2c_resume)\n};\n\nstatic struct platform_driver rcar_i2c_driver = {\n\t.driver\t= {\n\t\t.name\t= \"i2c-rcar\",\n\t\t.of_match_table = rcar_i2c_dt_ids,\n\t\t.pm\t= pm_sleep_ptr(&rcar_i2c_pm_ops),\n\t},\n\t.probe\t\t= rcar_i2c_probe,\n\t.remove_new\t= rcar_i2c_remove,\n};\n\nmodule_platform_driver(rcar_i2c_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"Renesas R-Car I2C bus driver\");\nMODULE_AUTHOR(\"Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}