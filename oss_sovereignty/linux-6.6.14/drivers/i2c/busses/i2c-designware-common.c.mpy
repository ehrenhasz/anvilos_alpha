{
  "module_name": "i2c-designware-common.c",
  "hash_id": "371c856e930d7bf8df45e22e79f533a2868285ab83b3c0cc18062c97154170df",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-designware-common.c",
  "human_readable_source": "\n \n#include <linux/acpi.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n#include <linux/swab.h>\n#include <linux/types.h>\n#include <linux/units.h>\n\n#include \"i2c-designware-core.h\"\n\nstatic char *abort_sources[] = {\n\t[ABRT_7B_ADDR_NOACK] =\n\t\t\"slave address not acknowledged (7bit mode)\",\n\t[ABRT_10ADDR1_NOACK] =\n\t\t\"first address byte not acknowledged (10bit mode)\",\n\t[ABRT_10ADDR2_NOACK] =\n\t\t\"second address byte not acknowledged (10bit mode)\",\n\t[ABRT_TXDATA_NOACK] =\n\t\t\"data not acknowledged\",\n\t[ABRT_GCALL_NOACK] =\n\t\t\"no acknowledgement for a general call\",\n\t[ABRT_GCALL_READ] =\n\t\t\"read after general call\",\n\t[ABRT_SBYTE_ACKDET] =\n\t\t\"start byte acknowledged\",\n\t[ABRT_SBYTE_NORSTRT] =\n\t\t\"trying to send start byte when restart is disabled\",\n\t[ABRT_10B_RD_NORSTRT] =\n\t\t\"trying to read when restart is disabled (10bit mode)\",\n\t[ABRT_MASTER_DIS] =\n\t\t\"trying to use disabled adapter\",\n\t[ARB_LOST] =\n\t\t\"lost arbitration\",\n\t[ABRT_SLAVE_FLUSH_TXFIFO] =\n\t\t\"read command so flush old data in the TX FIFO\",\n\t[ABRT_SLAVE_ARBLOST] =\n\t\t\"slave lost the bus while transmitting data to a remote master\",\n\t[ABRT_SLAVE_RD_INTX] =\n\t\t\"incorrect slave-transmitter mode configuration\",\n};\n\nstatic int dw_reg_read(void *context, unsigned int reg, unsigned int *val)\n{\n\tstruct dw_i2c_dev *dev = context;\n\n\t*val = readl(dev->base + reg);\n\n\treturn 0;\n}\n\nstatic int dw_reg_write(void *context, unsigned int reg, unsigned int val)\n{\n\tstruct dw_i2c_dev *dev = context;\n\n\twritel(val, dev->base + reg);\n\n\treturn 0;\n}\n\nstatic int dw_reg_read_swab(void *context, unsigned int reg, unsigned int *val)\n{\n\tstruct dw_i2c_dev *dev = context;\n\n\t*val = swab32(readl(dev->base + reg));\n\n\treturn 0;\n}\n\nstatic int dw_reg_write_swab(void *context, unsigned int reg, unsigned int val)\n{\n\tstruct dw_i2c_dev *dev = context;\n\n\twritel(swab32(val), dev->base + reg);\n\n\treturn 0;\n}\n\nstatic int dw_reg_read_word(void *context, unsigned int reg, unsigned int *val)\n{\n\tstruct dw_i2c_dev *dev = context;\n\n\t*val = readw(dev->base + reg) |\n\t\t(readw(dev->base + reg + 2) << 16);\n\n\treturn 0;\n}\n\nstatic int dw_reg_write_word(void *context, unsigned int reg, unsigned int val)\n{\n\tstruct dw_i2c_dev *dev = context;\n\n\twritew(val, dev->base + reg);\n\twritew(val >> 16, dev->base + reg + 2);\n\n\treturn 0;\n}\n\n \nint i2c_dw_init_regmap(struct dw_i2c_dev *dev)\n{\n\tstruct regmap_config map_cfg = {\n\t\t.reg_bits = 32,\n\t\t.val_bits = 32,\n\t\t.reg_stride = 4,\n\t\t.disable_locking = true,\n\t\t.reg_read = dw_reg_read,\n\t\t.reg_write = dw_reg_write,\n\t\t.max_register = DW_IC_COMP_TYPE,\n\t};\n\tu32 reg;\n\tint ret;\n\n\t \n\tif (dev->map)\n\t\treturn 0;\n\n\tret = i2c_dw_acquire_lock(dev);\n\tif (ret)\n\t\treturn ret;\n\n\treg = readl(dev->base + DW_IC_COMP_TYPE);\n\ti2c_dw_release_lock(dev);\n\n\tif ((dev->flags & MODEL_MASK) == MODEL_AMD_NAVI_GPU)\n\t\tmap_cfg.max_register = AMD_UCSI_INTR_REG;\n\n\tif (reg == swab32(DW_IC_COMP_TYPE_VALUE)) {\n\t\tmap_cfg.reg_read = dw_reg_read_swab;\n\t\tmap_cfg.reg_write = dw_reg_write_swab;\n\t} else if (reg == (DW_IC_COMP_TYPE_VALUE & 0x0000ffff)) {\n\t\tmap_cfg.reg_read = dw_reg_read_word;\n\t\tmap_cfg.reg_write = dw_reg_write_word;\n\t} else if (reg != DW_IC_COMP_TYPE_VALUE) {\n\t\tdev_err(dev->dev,\n\t\t\t\"Unknown Synopsys component type: 0x%08x\\n\", reg);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tdev->map = devm_regmap_init(dev->dev, NULL, dev, &map_cfg);\n\tif (IS_ERR(dev->map)) {\n\t\tdev_err(dev->dev, \"Failed to init the registers map\\n\");\n\t\treturn PTR_ERR(dev->map);\n\t}\n\n\treturn 0;\n}\n\nstatic const u32 supported_speeds[] = {\n\tI2C_MAX_HIGH_SPEED_MODE_FREQ,\n\tI2C_MAX_FAST_MODE_PLUS_FREQ,\n\tI2C_MAX_FAST_MODE_FREQ,\n\tI2C_MAX_STANDARD_MODE_FREQ,\n};\n\nint i2c_dw_validate_speed(struct dw_i2c_dev *dev)\n{\n\tstruct i2c_timings *t = &dev->timings;\n\tunsigned int i;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(supported_speeds); i++) {\n\t\tif (t->bus_freq_hz == supported_speeds[i])\n\t\t\treturn 0;\n\t}\n\n\tdev_err(dev->dev,\n\t\t\"%d Hz is unsupported, only 100kHz, 400kHz, 1MHz and 3.4MHz are supported\\n\",\n\t\tt->bus_freq_hz);\n\n\treturn -EINVAL;\n}\nEXPORT_SYMBOL_GPL(i2c_dw_validate_speed);\n\n#ifdef CONFIG_ACPI\n\n#include <linux/dmi.h>\n\n \nstatic const struct dmi_system_id i2c_dw_no_acpi_params[] = {\n\t{\n\t\t.ident = \"Dell Inspiron 7348\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Inc.\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Inspiron 7348\"),\n\t\t},\n\t},\n\t{}\n};\n\nstatic void i2c_dw_acpi_params(struct device *device, char method[],\n\t\t\t       u16 *hcnt, u16 *lcnt, u32 *sda_hold)\n{\n\tstruct acpi_buffer buf = { ACPI_ALLOCATE_BUFFER };\n\tacpi_handle handle = ACPI_HANDLE(device);\n\tunion acpi_object *obj;\n\n\tif (dmi_check_system(i2c_dw_no_acpi_params))\n\t\treturn;\n\n\tif (ACPI_FAILURE(acpi_evaluate_object(handle, method, NULL, &buf)))\n\t\treturn;\n\n\tobj = (union acpi_object *)buf.pointer;\n\tif (obj->type == ACPI_TYPE_PACKAGE && obj->package.count == 3) {\n\t\tconst union acpi_object *objs = obj->package.elements;\n\n\t\t*hcnt = (u16)objs[0].integer.value;\n\t\t*lcnt = (u16)objs[1].integer.value;\n\t\t*sda_hold = (u32)objs[2].integer.value;\n\t}\n\n\tkfree(buf.pointer);\n}\n\nint i2c_dw_acpi_configure(struct device *device)\n{\n\tstruct dw_i2c_dev *dev = dev_get_drvdata(device);\n\tstruct i2c_timings *t = &dev->timings;\n\tu32 ss_ht = 0, fp_ht = 0, hs_ht = 0, fs_ht = 0;\n\n\t \n\ti2c_dw_acpi_params(device, \"SSCN\", &dev->ss_hcnt, &dev->ss_lcnt, &ss_ht);\n\ti2c_dw_acpi_params(device, \"FMCN\", &dev->fs_hcnt, &dev->fs_lcnt, &fs_ht);\n\ti2c_dw_acpi_params(device, \"FPCN\", &dev->fp_hcnt, &dev->fp_lcnt, &fp_ht);\n\ti2c_dw_acpi_params(device, \"HSCN\", &dev->hs_hcnt, &dev->hs_lcnt, &hs_ht);\n\n\tswitch (t->bus_freq_hz) {\n\tcase I2C_MAX_STANDARD_MODE_FREQ:\n\t\tdev->sda_hold_time = ss_ht;\n\t\tbreak;\n\tcase I2C_MAX_FAST_MODE_PLUS_FREQ:\n\t\tdev->sda_hold_time = fp_ht;\n\t\tbreak;\n\tcase I2C_MAX_HIGH_SPEED_MODE_FREQ:\n\t\tdev->sda_hold_time = hs_ht;\n\t\tbreak;\n\tcase I2C_MAX_FAST_MODE_FREQ:\n\tdefault:\n\t\tdev->sda_hold_time = fs_ht;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(i2c_dw_acpi_configure);\n\nstatic u32 i2c_dw_acpi_round_bus_speed(struct device *device)\n{\n\tu32 acpi_speed;\n\tint i;\n\n\tacpi_speed = i2c_acpi_find_bus_speed(device);\n\t \n\tfor (i = 0; i < ARRAY_SIZE(supported_speeds); i++) {\n\t\tif (acpi_speed >= supported_speeds[i])\n\t\t\treturn supported_speeds[i];\n\t}\n\n\treturn 0;\n}\n\n#else\t \n\nstatic inline u32 i2c_dw_acpi_round_bus_speed(struct device *device) { return 0; }\n\n#endif\t \n\nvoid i2c_dw_adjust_bus_speed(struct dw_i2c_dev *dev)\n{\n\tu32 acpi_speed = i2c_dw_acpi_round_bus_speed(dev->dev);\n\tstruct i2c_timings *t = &dev->timings;\n\n\t \n\tif (acpi_speed && t->bus_freq_hz)\n\t\tt->bus_freq_hz = min(t->bus_freq_hz, acpi_speed);\n\telse if (acpi_speed || t->bus_freq_hz)\n\t\tt->bus_freq_hz = max(t->bus_freq_hz, acpi_speed);\n\telse\n\t\tt->bus_freq_hz = I2C_MAX_FAST_MODE_FREQ;\n}\nEXPORT_SYMBOL_GPL(i2c_dw_adjust_bus_speed);\n\nu32 i2c_dw_scl_hcnt(u32 ic_clk, u32 tSYMBOL, u32 tf, int cond, int offset)\n{\n\t \n\tif (cond)\n\t\t \n\t\treturn DIV_ROUND_CLOSEST_ULL((u64)ic_clk * tSYMBOL, MICRO) -\n\t\t       8 + offset;\n\telse\n\t\t \n\t\treturn DIV_ROUND_CLOSEST_ULL((u64)ic_clk * (tSYMBOL + tf), MICRO) -\n\t\t       3 + offset;\n}\n\nu32 i2c_dw_scl_lcnt(u32 ic_clk, u32 tLOW, u32 tf, int offset)\n{\n\t \n\treturn DIV_ROUND_CLOSEST_ULL((u64)ic_clk * (tLOW + tf), MICRO) -\n\t       1 + offset;\n}\n\nint i2c_dw_set_sda_hold(struct dw_i2c_dev *dev)\n{\n\tunsigned int reg;\n\tint ret;\n\n\tret = i2c_dw_acquire_lock(dev);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = regmap_read(dev->map, DW_IC_COMP_VERSION, &reg);\n\tif (ret)\n\t\tgoto err_release_lock;\n\n\tif (reg >= DW_IC_SDA_HOLD_MIN_VERS) {\n\t\tif (!dev->sda_hold_time) {\n\t\t\t \n\t\t\tret = regmap_read(dev->map, DW_IC_SDA_HOLD,\n\t\t\t\t\t  &dev->sda_hold_time);\n\t\t\tif (ret)\n\t\t\t\tgoto err_release_lock;\n\t\t}\n\n\t\t \n\t\tif (!(dev->sda_hold_time & DW_IC_SDA_HOLD_RX_MASK))\n\t\t\tdev->sda_hold_time |= 1 << DW_IC_SDA_HOLD_RX_SHIFT;\n\n\t\tdev_dbg(dev->dev, \"SDA Hold Time TX:RX = %d:%d\\n\",\n\t\t\tdev->sda_hold_time & ~(u32)DW_IC_SDA_HOLD_RX_MASK,\n\t\t\tdev->sda_hold_time >> DW_IC_SDA_HOLD_RX_SHIFT);\n\t} else if (dev->set_sda_hold_time) {\n\t\tdev->set_sda_hold_time(dev);\n\t} else if (dev->sda_hold_time) {\n\t\tdev_warn(dev->dev,\n\t\t\t\"Hardware too old to adjust SDA hold time.\\n\");\n\t\tdev->sda_hold_time = 0;\n\t}\n\nerr_release_lock:\n\ti2c_dw_release_lock(dev);\n\n\treturn ret;\n}\n\nvoid __i2c_dw_disable(struct dw_i2c_dev *dev)\n{\n\tunsigned int raw_intr_stats;\n\tunsigned int enable;\n\tint timeout = 100;\n\tbool abort_needed;\n\tunsigned int status;\n\tint ret;\n\n\tregmap_read(dev->map, DW_IC_RAW_INTR_STAT, &raw_intr_stats);\n\tregmap_read(dev->map, DW_IC_ENABLE, &enable);\n\n\tabort_needed = raw_intr_stats & DW_IC_INTR_MST_ON_HOLD;\n\tif (abort_needed) {\n\t\tregmap_write(dev->map, DW_IC_ENABLE, enable | DW_IC_ENABLE_ABORT);\n\t\tret = regmap_read_poll_timeout(dev->map, DW_IC_ENABLE, enable,\n\t\t\t\t\t       !(enable & DW_IC_ENABLE_ABORT), 10,\n\t\t\t\t\t       100);\n\t\tif (ret)\n\t\t\tdev_err(dev->dev, \"timeout while trying to abort current transfer\\n\");\n\t}\n\n\tdo {\n\t\t__i2c_dw_disable_nowait(dev);\n\t\t \n\t\tregmap_read(dev->map, DW_IC_ENABLE_STATUS, &status);\n\t\tif ((status & 1) == 0)\n\t\t\treturn;\n\n\t\t \n\t\tusleep_range(25, 250);\n\t} while (timeout--);\n\n\tdev_warn(dev->dev, \"timeout in disabling adapter\\n\");\n}\n\nu32 i2c_dw_clk_rate(struct dw_i2c_dev *dev)\n{\n\t \n\tif (WARN_ON_ONCE(!dev->get_clk_rate_khz))\n\t\treturn 0;\n\treturn dev->get_clk_rate_khz(dev);\n}\n\nint i2c_dw_prepare_clk(struct dw_i2c_dev *dev, bool prepare)\n{\n\tint ret;\n\n\tif (prepare) {\n\t\t \n\t\tret = clk_prepare_enable(dev->pclk);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = clk_prepare_enable(dev->clk);\n\t\tif (ret)\n\t\t\tclk_disable_unprepare(dev->pclk);\n\n\t\treturn ret;\n\t}\n\n\tclk_disable_unprepare(dev->clk);\n\tclk_disable_unprepare(dev->pclk);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(i2c_dw_prepare_clk);\n\nint i2c_dw_acquire_lock(struct dw_i2c_dev *dev)\n{\n\tint ret;\n\n\tif (!dev->acquire_lock)\n\t\treturn 0;\n\n\tret = dev->acquire_lock();\n\tif (!ret)\n\t\treturn 0;\n\n\tdev_err(dev->dev, \"couldn't acquire bus ownership\\n\");\n\n\treturn ret;\n}\n\nvoid i2c_dw_release_lock(struct dw_i2c_dev *dev)\n{\n\tif (dev->release_lock)\n\t\tdev->release_lock();\n}\n\n \nint i2c_dw_wait_bus_not_busy(struct dw_i2c_dev *dev)\n{\n\tunsigned int status;\n\tint ret;\n\n\tret = regmap_read_poll_timeout(dev->map, DW_IC_STATUS, status,\n\t\t\t\t       !(status & DW_IC_STATUS_ACTIVITY),\n\t\t\t\t       1100, 20000);\n\tif (ret) {\n\t\tdev_warn(dev->dev, \"timeout waiting for bus ready\\n\");\n\n\t\ti2c_recover_bus(&dev->adapter);\n\n\t\tregmap_read(dev->map, DW_IC_STATUS, &status);\n\t\tif (!(status & DW_IC_STATUS_ACTIVITY))\n\t\t\tret = 0;\n\t}\n\n\treturn ret;\n}\n\nint i2c_dw_handle_tx_abort(struct dw_i2c_dev *dev)\n{\n\tunsigned long abort_source = dev->abort_source;\n\tint i;\n\n\tif (abort_source & DW_IC_TX_ABRT_NOACK) {\n\t\tfor_each_set_bit(i, &abort_source, ARRAY_SIZE(abort_sources))\n\t\t\tdev_dbg(dev->dev,\n\t\t\t\t\"%s: %s\\n\", __func__, abort_sources[i]);\n\t\treturn -EREMOTEIO;\n\t}\n\n\tfor_each_set_bit(i, &abort_source, ARRAY_SIZE(abort_sources))\n\t\tdev_err(dev->dev, \"%s: %s\\n\", __func__, abort_sources[i]);\n\n\tif (abort_source & DW_IC_TX_ARB_LOST)\n\t\treturn -EAGAIN;\n\telse if (abort_source & DW_IC_TX_ABRT_GCALL_READ)\n\t\treturn -EINVAL;  \n\telse\n\t\treturn -EIO;\n}\n\nint i2c_dw_set_fifo_size(struct dw_i2c_dev *dev)\n{\n\tu32 tx_fifo_depth, rx_fifo_depth;\n\tunsigned int param;\n\tint ret;\n\n\t \n\tif ((dev->flags & MODEL_MASK) == MODEL_WANGXUN_SP) {\n\t\tdev->tx_fifo_depth = TXGBE_TX_FIFO_DEPTH;\n\t\tdev->rx_fifo_depth = TXGBE_RX_FIFO_DEPTH;\n\n\t\treturn 0;\n\t}\n\n\t \n\tret = i2c_dw_acquire_lock(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_read(dev->map, DW_IC_COMP_PARAM_1, &param);\n\ti2c_dw_release_lock(dev);\n\tif (ret)\n\t\treturn ret;\n\n\ttx_fifo_depth = ((param >> 16) & 0xff) + 1;\n\trx_fifo_depth = ((param >> 8)  & 0xff) + 1;\n\tif (!dev->tx_fifo_depth) {\n\t\tdev->tx_fifo_depth = tx_fifo_depth;\n\t\tdev->rx_fifo_depth = rx_fifo_depth;\n\t} else if (tx_fifo_depth >= 2) {\n\t\tdev->tx_fifo_depth = min_t(u32, dev->tx_fifo_depth,\n\t\t\t\ttx_fifo_depth);\n\t\tdev->rx_fifo_depth = min_t(u32, dev->rx_fifo_depth,\n\t\t\t\trx_fifo_depth);\n\t}\n\n\treturn 0;\n}\n\nu32 i2c_dw_func(struct i2c_adapter *adap)\n{\n\tstruct dw_i2c_dev *dev = i2c_get_adapdata(adap);\n\n\treturn dev->functionality;\n}\n\nvoid i2c_dw_disable(struct dw_i2c_dev *dev)\n{\n\tunsigned int dummy;\n\tint ret;\n\n\tret = i2c_dw_acquire_lock(dev);\n\tif (ret)\n\t\treturn;\n\n\t \n\t__i2c_dw_disable(dev);\n\n\t \n\tregmap_write(dev->map, DW_IC_INTR_MASK, 0);\n\tregmap_read(dev->map, DW_IC_CLR_INTR, &dummy);\n\n\ti2c_dw_release_lock(dev);\n}\n\nMODULE_DESCRIPTION(\"Synopsys DesignWare I2C bus adapter core\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}