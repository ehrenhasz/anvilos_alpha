{
  "module_name": "i2c-bcm-kona.c",
  "hash_id": "d86eb9afd37c769e962b0c34a9881f37f0350cd2b0ea16636ec48a9aa0c88f01",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-bcm-kona.c",
  "human_readable_source": "\n\n\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/platform_device.h>\n#include <linux/clk.h>\n#include <linux/io.h>\n#include <linux/slab.h>\n\n \n#define CS_OFFSET\t\t\t\t0x00000020\n#define CS_ACK_SHIFT\t\t\t\t3\n#define CS_ACK_MASK\t\t\t\t0x00000008\n#define CS_ACK_CMD_GEN_START\t\t\t0x00000000\n#define CS_ACK_CMD_GEN_RESTART\t\t\t0x00000001\n#define CS_CMD_SHIFT\t\t\t\t1\n#define CS_CMD_CMD_NO_ACTION\t\t\t0x00000000\n#define CS_CMD_CMD_START_RESTART\t\t0x00000001\n#define CS_CMD_CMD_STOP\t\t\t\t0x00000002\n#define CS_EN_SHIFT\t\t\t\t0\n#define CS_EN_CMD_ENABLE_BSC\t\t\t0x00000001\n\n#define TIM_OFFSET\t\t\t\t0x00000024\n#define TIM_PRESCALE_SHIFT\t\t\t6\n#define TIM_P_SHIFT\t\t\t\t3\n#define TIM_NO_DIV_SHIFT\t\t\t2\n#define TIM_DIV_SHIFT\t\t\t\t0\n\n#define DAT_OFFSET\t\t\t\t0x00000028\n\n#define TOUT_OFFSET\t\t\t\t0x0000002c\n\n#define TXFCR_OFFSET\t\t\t\t0x0000003c\n#define TXFCR_FIFO_FLUSH_MASK\t\t\t0x00000080\n#define TXFCR_FIFO_EN_MASK\t\t\t0x00000040\n\n#define IER_OFFSET\t\t\t\t0x00000044\n#define IER_READ_COMPLETE_INT_MASK\t\t0x00000010\n#define IER_I2C_INT_EN_MASK\t\t\t0x00000008\n#define IER_FIFO_INT_EN_MASK\t\t\t0x00000002\n#define IER_NOACK_EN_MASK\t\t\t0x00000001\n\n#define ISR_OFFSET\t\t\t\t0x00000048\n#define ISR_RESERVED_MASK\t\t\t0xffffff60\n#define ISR_CMDBUSY_MASK\t\t\t0x00000080\n#define ISR_READ_COMPLETE_MASK\t\t\t0x00000010\n#define ISR_SES_DONE_MASK\t\t\t0x00000008\n#define ISR_ERR_MASK\t\t\t\t0x00000004\n#define ISR_TXFIFOEMPTY_MASK\t\t\t0x00000002\n#define ISR_NOACK_MASK\t\t\t\t0x00000001\n\n#define CLKEN_OFFSET\t\t\t\t0x0000004C\n#define CLKEN_AUTOSENSE_OFF_MASK\t\t0x00000080\n#define CLKEN_M_SHIFT\t\t\t\t4\n#define CLKEN_N_SHIFT\t\t\t\t1\n#define CLKEN_CLKEN_MASK\t\t\t0x00000001\n\n#define FIFO_STATUS_OFFSET\t\t\t0x00000054\n#define FIFO_STATUS_RXFIFO_EMPTY_MASK\t\t0x00000004\n#define FIFO_STATUS_TXFIFO_EMPTY_MASK\t\t0x00000010\n\n#define HSTIM_OFFSET\t\t\t\t0x00000058\n#define HSTIM_HS_MODE_MASK\t\t\t0x00008000\n#define HSTIM_HS_HOLD_SHIFT\t\t\t10\n#define HSTIM_HS_HIGH_PHASE_SHIFT\t\t5\n#define HSTIM_HS_SETUP_SHIFT\t\t\t0\n\n#define PADCTL_OFFSET\t\t\t\t0x0000005c\n#define PADCTL_PAD_OUT_EN_MASK\t\t\t0x00000004\n\n#define RXFCR_OFFSET\t\t\t\t0x00000068\n#define RXFCR_NACK_EN_SHIFT\t\t\t7\n#define RXFCR_READ_COUNT_SHIFT\t\t\t0\n#define RXFIFORDOUT_OFFSET\t\t\t0x0000006c\n\n \n#define MAX_RX_FIFO_SIZE\t\t64U  \n#define MAX_TX_FIFO_SIZE\t\t64U  \n\n#define STD_EXT_CLK_FREQ\t\t13000000UL\n#define HS_EXT_CLK_FREQ\t\t\t104000000UL\n\n#define MASTERCODE\t\t\t0x08  \n\n#define I2C_TIMEOUT\t\t\t100  \n\n \nenum bcm_kona_cmd_t {\n\tBCM_CMD_NOACTION = 0,\n\tBCM_CMD_START,\n\tBCM_CMD_RESTART,\n\tBCM_CMD_STOP,\n};\n\nenum bus_speed_index {\n\tBCM_SPD_100K = 0,\n\tBCM_SPD_400K,\n\tBCM_SPD_1MHZ,\n};\n\nenum hs_bus_speed_index {\n\tBCM_SPD_3P4MHZ = 0,\n};\n\n \nstruct bus_speed_cfg {\n\tuint8_t time_m;\t\t \n\tuint8_t time_n;\t\t \n\tuint8_t prescale;\t \n\tuint8_t time_p;\t\t \n\tuint8_t no_div;\t\t \n\tuint8_t time_div;\t \n};\n\n \nstruct hs_bus_speed_cfg {\n\tuint8_t hs_hold;\t \n\tuint8_t hs_high_phase;\t \n\tuint8_t hs_setup;\t \n\tuint8_t prescale;\t \n\tuint8_t time_p;\t\t \n\tuint8_t no_div;\t\t \n\tuint8_t time_div;\t \n};\n\nstatic const struct bus_speed_cfg std_cfg_table[] = {\n\t[BCM_SPD_100K] = {0x01, 0x01, 0x03, 0x06, 0x00, 0x02},\n\t[BCM_SPD_400K] = {0x05, 0x01, 0x03, 0x05, 0x01, 0x02},\n\t[BCM_SPD_1MHZ] = {0x01, 0x01, 0x03, 0x01, 0x01, 0x03},\n};\n\nstatic const struct hs_bus_speed_cfg hs_cfg_table[] = {\n\t[BCM_SPD_3P4MHZ] = {0x01, 0x08, 0x14, 0x00, 0x06, 0x01, 0x00},\n};\n\nstruct bcm_kona_i2c_dev {\n\tstruct device *device;\n\n\tvoid __iomem *base;\n\tint irq;\n\tstruct clk *external_clk;\n\n\tstruct i2c_adapter adapter;\n\n\tstruct completion done;\n\n\tconst struct bus_speed_cfg *std_cfg;\n\tconst struct hs_bus_speed_cfg *hs_cfg;\n};\n\nstatic void bcm_kona_i2c_send_cmd_to_ctrl(struct bcm_kona_i2c_dev *dev,\n\t\t\t\t\t  enum bcm_kona_cmd_t cmd)\n{\n\tdev_dbg(dev->device, \"%s, %d\\n\", __func__, cmd);\n\n\tswitch (cmd) {\n\tcase BCM_CMD_NOACTION:\n\t\twritel((CS_CMD_CMD_NO_ACTION << CS_CMD_SHIFT) |\n\t\t       (CS_EN_CMD_ENABLE_BSC << CS_EN_SHIFT),\n\t\t       dev->base + CS_OFFSET);\n\t\tbreak;\n\n\tcase BCM_CMD_START:\n\t\twritel((CS_ACK_CMD_GEN_START << CS_ACK_SHIFT) |\n\t\t       (CS_CMD_CMD_START_RESTART << CS_CMD_SHIFT) |\n\t\t       (CS_EN_CMD_ENABLE_BSC << CS_EN_SHIFT),\n\t\t       dev->base + CS_OFFSET);\n\t\tbreak;\n\n\tcase BCM_CMD_RESTART:\n\t\twritel((CS_ACK_CMD_GEN_RESTART << CS_ACK_SHIFT) |\n\t\t       (CS_CMD_CMD_START_RESTART << CS_CMD_SHIFT) |\n\t\t       (CS_EN_CMD_ENABLE_BSC << CS_EN_SHIFT),\n\t\t       dev->base + CS_OFFSET);\n\t\tbreak;\n\n\tcase BCM_CMD_STOP:\n\t\twritel((CS_CMD_CMD_STOP << CS_CMD_SHIFT) |\n\t\t       (CS_EN_CMD_ENABLE_BSC << CS_EN_SHIFT),\n\t\t       dev->base + CS_OFFSET);\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(dev->device, \"Unknown command %d\\n\", cmd);\n\t}\n}\n\nstatic void bcm_kona_i2c_enable_clock(struct bcm_kona_i2c_dev *dev)\n{\n\twritel(readl(dev->base + CLKEN_OFFSET) | CLKEN_CLKEN_MASK,\n\t       dev->base + CLKEN_OFFSET);\n}\n\nstatic void bcm_kona_i2c_disable_clock(struct bcm_kona_i2c_dev *dev)\n{\n\twritel(readl(dev->base + CLKEN_OFFSET) & ~CLKEN_CLKEN_MASK,\n\t       dev->base + CLKEN_OFFSET);\n}\n\nstatic irqreturn_t bcm_kona_i2c_isr(int irq, void *devid)\n{\n\tstruct bcm_kona_i2c_dev *dev = devid;\n\tuint32_t status = readl(dev->base + ISR_OFFSET);\n\n\tif ((status & ~ISR_RESERVED_MASK) == 0)\n\t\treturn IRQ_NONE;\n\n\t \n\tif (status & ISR_NOACK_MASK)\n\t\twritel(TXFCR_FIFO_FLUSH_MASK | TXFCR_FIFO_EN_MASK,\n\t\t       dev->base + TXFCR_OFFSET);\n\n\twritel(status & ~ISR_RESERVED_MASK, dev->base + ISR_OFFSET);\n\tcomplete(&dev->done);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic int bcm_kona_i2c_wait_if_busy(struct bcm_kona_i2c_dev *dev)\n{\n\tunsigned long timeout = jiffies + msecs_to_jiffies(I2C_TIMEOUT);\n\n\twhile (readl(dev->base + ISR_OFFSET) & ISR_CMDBUSY_MASK)\n\t\tif (time_after(jiffies, timeout)) {\n\t\t\tdev_err(dev->device, \"CMDBUSY timeout\\n\");\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\n\treturn 0;\n}\n\n \nstatic int bcm_kona_send_i2c_cmd(struct bcm_kona_i2c_dev *dev,\n\t\t\t\t enum bcm_kona_cmd_t cmd)\n{\n\tint rc;\n\tunsigned long time_left = msecs_to_jiffies(I2C_TIMEOUT);\n\n\t \n\trc = bcm_kona_i2c_wait_if_busy(dev);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t \n\twritel(IER_I2C_INT_EN_MASK, dev->base + IER_OFFSET);\n\n\t \n\treinit_completion(&dev->done);\n\n\t \n\tbcm_kona_i2c_send_cmd_to_ctrl(dev, cmd);\n\n\t \n\ttime_left = wait_for_completion_timeout(&dev->done, time_left);\n\n\t \n\twritel(0, dev->base + IER_OFFSET);\n\n\tif (!time_left) {\n\t\tdev_err(dev->device, \"controller timed out\\n\");\n\t\trc = -ETIMEDOUT;\n\t}\n\n\t \n\tbcm_kona_i2c_send_cmd_to_ctrl(dev, BCM_CMD_NOACTION);\n\n\treturn rc;\n}\n\n \nstatic int bcm_kona_i2c_read_fifo_single(struct bcm_kona_i2c_dev *dev,\n\t\t\t\t\t uint8_t *buf, unsigned int len,\n\t\t\t\t\t unsigned int last_byte_nak)\n{\n\tunsigned long time_left = msecs_to_jiffies(I2C_TIMEOUT);\n\n\t \n\treinit_completion(&dev->done);\n\n\t \n\twritel(IER_READ_COMPLETE_INT_MASK, dev->base + IER_OFFSET);\n\n\t \n\twritel((last_byte_nak << RXFCR_NACK_EN_SHIFT) |\n\t       (len << RXFCR_READ_COUNT_SHIFT),\n\t\tdev->base + RXFCR_OFFSET);\n\n\t \n\ttime_left = wait_for_completion_timeout(&dev->done, time_left);\n\n\t \n\twritel(0, dev->base + IER_OFFSET);\n\n\tif (!time_left) {\n\t\tdev_err(dev->device, \"RX FIFO time out\\n\");\n\t\treturn -EREMOTEIO;\n\t}\n\n\t \n\tfor (; len > 0; len--, buf++)\n\t\t*buf = readl(dev->base + RXFIFORDOUT_OFFSET);\n\n\treturn 0;\n}\n\n \nstatic int bcm_kona_i2c_read_fifo(struct bcm_kona_i2c_dev *dev,\n\t\t\t\t  struct i2c_msg *msg)\n{\n\tunsigned int bytes_to_read = MAX_RX_FIFO_SIZE;\n\tunsigned int last_byte_nak = 0;\n\tunsigned int bytes_read = 0;\n\tint rc;\n\n\tuint8_t *tmp_buf = msg->buf;\n\n\twhile (bytes_read < msg->len) {\n\t\tif (msg->len - bytes_read <= MAX_RX_FIFO_SIZE) {\n\t\t\tlast_byte_nak = 1;  \n\t\t\tbytes_to_read = msg->len - bytes_read;\n\t\t}\n\n\t\trc = bcm_kona_i2c_read_fifo_single(dev, tmp_buf, bytes_to_read,\n\t\t\t\t\t\t   last_byte_nak);\n\t\tif (rc < 0)\n\t\t\treturn -EREMOTEIO;\n\n\t\tbytes_read += bytes_to_read;\n\t\ttmp_buf += bytes_to_read;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int bcm_kona_i2c_write_byte(struct bcm_kona_i2c_dev *dev, uint8_t data,\n\t\t\t\t   unsigned int nak_expected)\n{\n\tint rc;\n\tunsigned long time_left = msecs_to_jiffies(I2C_TIMEOUT);\n\tunsigned int nak_received;\n\n\t \n\trc = bcm_kona_i2c_wait_if_busy(dev);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t \n\twritel(ISR_SES_DONE_MASK, dev->base + ISR_OFFSET);\n\n\t \n\twritel(IER_I2C_INT_EN_MASK, dev->base + IER_OFFSET);\n\n\t \n\treinit_completion(&dev->done);\n\n\t \n\twritel(data, dev->base + DAT_OFFSET);\n\n\t \n\ttime_left = wait_for_completion_timeout(&dev->done, time_left);\n\n\t \n\twritel(0, dev->base + IER_OFFSET);\n\n\tif (!time_left) {\n\t\tdev_dbg(dev->device, \"controller timed out\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tnak_received = readl(dev->base + CS_OFFSET) & CS_ACK_MASK ? 1 : 0;\n\n\tif (nak_received ^ nak_expected) {\n\t\tdev_dbg(dev->device, \"unexpected NAK/ACK\\n\");\n\t\treturn -EREMOTEIO;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int bcm_kona_i2c_write_fifo_single(struct bcm_kona_i2c_dev *dev,\n\t\t\t\t\t  uint8_t *buf, unsigned int len)\n{\n\tint k;\n\tunsigned long time_left = msecs_to_jiffies(I2C_TIMEOUT);\n\tunsigned int fifo_status;\n\n\t \n\treinit_completion(&dev->done);\n\n\t \n\twritel(IER_FIFO_INT_EN_MASK | IER_NOACK_EN_MASK,\n\t       dev->base + IER_OFFSET);\n\n\t \n\tdisable_irq(dev->irq);\n\n\t \n\tfor (k = 0; k < len; k++)\n\t\twritel(buf[k], (dev->base + DAT_OFFSET));\n\n\t \n\tenable_irq(dev->irq);\n\n\t \n\tdo {\n\t\ttime_left = wait_for_completion_timeout(&dev->done, time_left);\n\t\tfifo_status = readl(dev->base + FIFO_STATUS_OFFSET);\n\t} while (time_left && !(fifo_status & FIFO_STATUS_TXFIFO_EMPTY_MASK));\n\n\t \n\twritel(0, dev->base + IER_OFFSET);\n\n\t \n\tif (readl(dev->base + CS_OFFSET) & CS_ACK_MASK) {\n\t\tdev_err(dev->device, \"unexpected NAK\\n\");\n\t\treturn -EREMOTEIO;\n\t}\n\n\t \n\tif (!time_left) {\n\t\tdev_err(dev->device, \"completion timed out\\n\");\n\t\treturn -EREMOTEIO;\n\t}\n\n\treturn 0;\n}\n\n\n \nstatic int bcm_kona_i2c_write_fifo(struct bcm_kona_i2c_dev *dev,\n\t\t\t\t   struct i2c_msg *msg)\n{\n\tunsigned int bytes_to_write = MAX_TX_FIFO_SIZE;\n\tunsigned int bytes_written = 0;\n\tint rc;\n\n\tuint8_t *tmp_buf = msg->buf;\n\n\twhile (bytes_written < msg->len) {\n\t\tif (msg->len - bytes_written <= MAX_TX_FIFO_SIZE)\n\t\t\tbytes_to_write = msg->len - bytes_written;\n\n\t\trc = bcm_kona_i2c_write_fifo_single(dev, tmp_buf,\n\t\t\t\t\t\t    bytes_to_write);\n\t\tif (rc < 0)\n\t\t\treturn -EREMOTEIO;\n\n\t\tbytes_written += bytes_to_write;\n\t\ttmp_buf += bytes_to_write;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int bcm_kona_i2c_do_addr(struct bcm_kona_i2c_dev *dev,\n\t\t\t\t     struct i2c_msg *msg)\n{\n\tunsigned char addr;\n\n\tif (msg->flags & I2C_M_TEN) {\n\t\t \n\t\taddr = 0xF0 | ((msg->addr & 0x300) >> 7);\n\t\tif (bcm_kona_i2c_write_byte(dev, addr, 0) < 0)\n\t\t\treturn -EREMOTEIO;\n\n\t\t \n\t\taddr = msg->addr & 0xFF;\n\t\tif (bcm_kona_i2c_write_byte(dev, addr, 0) < 0)\n\t\t\treturn -EREMOTEIO;\n\n\t\tif (msg->flags & I2C_M_RD) {\n\t\t\t \n\t\t\tif (bcm_kona_send_i2c_cmd(dev, BCM_CMD_RESTART) < 0)\n\t\t\t\treturn -EREMOTEIO;\n\n\t\t\t \n\t\t\taddr = 0xF0 | ((msg->addr & 0x300) >> 7) | 0x01;\n\t\t\tif (bcm_kona_i2c_write_byte(dev, addr, 0) < 0)\n\t\t\t\treturn -EREMOTEIO;\n\t\t}\n\t} else {\n\t\taddr = i2c_8bit_addr_from_msg(msg);\n\n\t\tif (bcm_kona_i2c_write_byte(dev, addr, 0) < 0)\n\t\t\treturn -EREMOTEIO;\n\t}\n\n\treturn 0;\n}\n\nstatic void bcm_kona_i2c_enable_autosense(struct bcm_kona_i2c_dev *dev)\n{\n\twritel(readl(dev->base + CLKEN_OFFSET) & ~CLKEN_AUTOSENSE_OFF_MASK,\n\t       dev->base + CLKEN_OFFSET);\n}\n\nstatic void bcm_kona_i2c_config_timing(struct bcm_kona_i2c_dev *dev)\n{\n\twritel(readl(dev->base + HSTIM_OFFSET) & ~HSTIM_HS_MODE_MASK,\n\t       dev->base + HSTIM_OFFSET);\n\n\twritel((dev->std_cfg->prescale << TIM_PRESCALE_SHIFT) |\n\t       (dev->std_cfg->time_p << TIM_P_SHIFT) |\n\t       (dev->std_cfg->no_div << TIM_NO_DIV_SHIFT) |\n\t       (dev->std_cfg->time_div\t<< TIM_DIV_SHIFT),\n\t       dev->base + TIM_OFFSET);\n\n\twritel((dev->std_cfg->time_m << CLKEN_M_SHIFT) |\n\t       (dev->std_cfg->time_n << CLKEN_N_SHIFT) |\n\t       CLKEN_CLKEN_MASK,\n\t       dev->base + CLKEN_OFFSET);\n}\n\nstatic void bcm_kona_i2c_config_timing_hs(struct bcm_kona_i2c_dev *dev)\n{\n\twritel((dev->hs_cfg->prescale << TIM_PRESCALE_SHIFT) |\n\t       (dev->hs_cfg->time_p << TIM_P_SHIFT) |\n\t       (dev->hs_cfg->no_div << TIM_NO_DIV_SHIFT) |\n\t       (dev->hs_cfg->time_div << TIM_DIV_SHIFT),\n\t       dev->base + TIM_OFFSET);\n\n\twritel((dev->hs_cfg->hs_hold << HSTIM_HS_HOLD_SHIFT) |\n\t       (dev->hs_cfg->hs_high_phase << HSTIM_HS_HIGH_PHASE_SHIFT) |\n\t       (dev->hs_cfg->hs_setup << HSTIM_HS_SETUP_SHIFT),\n\t       dev->base + HSTIM_OFFSET);\n\n\twritel(readl(dev->base + HSTIM_OFFSET) | HSTIM_HS_MODE_MASK,\n\t       dev->base + HSTIM_OFFSET);\n}\n\nstatic int bcm_kona_i2c_switch_to_hs(struct bcm_kona_i2c_dev *dev)\n{\n\tint rc;\n\n\t \n\trc = bcm_kona_i2c_write_byte(dev, MASTERCODE, 1);\n\tif (rc < 0) {\n\t\tpr_err(\"High speed handshake failed\\n\");\n\t\treturn rc;\n\t}\n\n\t \n\trc = clk_set_rate(dev->external_clk, HS_EXT_CLK_FREQ);\n\tif (rc) {\n\t\tdev_err(dev->device, \"%s: clk_set_rate returned %d\\n\",\n\t\t\t__func__, rc);\n\t\treturn rc;\n\t}\n\n\t \n\tbcm_kona_i2c_config_timing_hs(dev);\n\n\t \n\trc = bcm_kona_send_i2c_cmd(dev, BCM_CMD_RESTART);\n\tif (rc < 0)\n\t\tdev_err(dev->device, \"High speed restart command failed\\n\");\n\n\treturn rc;\n}\n\nstatic int bcm_kona_i2c_switch_to_std(struct bcm_kona_i2c_dev *dev)\n{\n\tint rc;\n\n\t \n\tbcm_kona_i2c_config_timing(dev);\n\n\t \n\trc = clk_set_rate(dev->external_clk, STD_EXT_CLK_FREQ);\n\tif (rc) {\n\t\tdev_err(dev->device, \"%s: clk_set_rate returned %d\\n\",\n\t\t\t__func__, rc);\n\t}\n\n\treturn rc;\n}\n\n \nstatic int bcm_kona_i2c_xfer(struct i2c_adapter *adapter,\n\t\t\t     struct i2c_msg msgs[], int num)\n{\n\tstruct bcm_kona_i2c_dev *dev = i2c_get_adapdata(adapter);\n\tstruct i2c_msg *pmsg;\n\tint rc = 0;\n\tint i;\n\n\trc = clk_prepare_enable(dev->external_clk);\n\tif (rc) {\n\t\tdev_err(dev->device, \"%s: peri clock enable failed. err %d\\n\",\n\t\t\t__func__, rc);\n\t\treturn rc;\n\t}\n\n\t \n\twritel(0, dev->base + PADCTL_OFFSET);\n\n\t \n\tbcm_kona_i2c_enable_clock(dev);\n\n\t \n\trc = bcm_kona_send_i2c_cmd(dev, BCM_CMD_START);\n\tif (rc < 0) {\n\t\tdev_err(dev->device, \"Start command failed rc = %d\\n\", rc);\n\t\tgoto xfer_disable_pad;\n\t}\n\n\t \n\tif (dev->hs_cfg) {\n\t\trc = bcm_kona_i2c_switch_to_hs(dev);\n\t\tif (rc < 0)\n\t\t\tgoto xfer_send_stop;\n\t}\n\n\t \n\tfor (i = 0; i < num; i++) {\n\t\tpmsg = &msgs[i];\n\n\t\t \n\t\tif ((i != 0) && ((pmsg->flags & I2C_M_NOSTART) == 0)) {\n\t\t\trc = bcm_kona_send_i2c_cmd(dev, BCM_CMD_RESTART);\n\t\t\tif (rc < 0) {\n\t\t\t\tdev_err(dev->device,\n\t\t\t\t\t\"restart cmd failed rc = %d\\n\", rc);\n\t\t\t\tgoto xfer_send_stop;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (!(pmsg->flags & I2C_M_NOSTART)) {\n\t\t\trc = bcm_kona_i2c_do_addr(dev, pmsg);\n\t\t\tif (rc < 0) {\n\t\t\t\tdev_err(dev->device,\n\t\t\t\t\t\"NAK from addr %2.2x msg#%d rc = %d\\n\",\n\t\t\t\t\tpmsg->addr, i, rc);\n\t\t\t\tgoto xfer_send_stop;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (pmsg->flags & I2C_M_RD) {\n\t\t\trc = bcm_kona_i2c_read_fifo(dev, pmsg);\n\t\t\tif (rc < 0) {\n\t\t\t\tdev_err(dev->device, \"read failure\\n\");\n\t\t\t\tgoto xfer_send_stop;\n\t\t\t}\n\t\t} else {\n\t\t\trc = bcm_kona_i2c_write_fifo(dev, pmsg);\n\t\t\tif (rc < 0) {\n\t\t\t\tdev_err(dev->device, \"write failure\");\n\t\t\t\tgoto xfer_send_stop;\n\t\t\t}\n\t\t}\n\t}\n\n\trc = num;\n\nxfer_send_stop:\n\t \n\tbcm_kona_send_i2c_cmd(dev, BCM_CMD_STOP);\n\n\t \n\tif (dev->hs_cfg) {\n\t\tint hs_rc = bcm_kona_i2c_switch_to_std(dev);\n\n\t\tif (hs_rc)\n\t\t\trc = hs_rc;\n\t}\n\nxfer_disable_pad:\n\t \n\twritel(PADCTL_PAD_OUT_EN_MASK, dev->base + PADCTL_OFFSET);\n\n\t \n\tbcm_kona_i2c_disable_clock(dev);\n\n\tclk_disable_unprepare(dev->external_clk);\n\n\treturn rc;\n}\n\nstatic uint32_t bcm_kona_i2c_functionality(struct i2c_adapter *adap)\n{\n\treturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL | I2C_FUNC_10BIT_ADDR |\n\t    I2C_FUNC_NOSTART;\n}\n\nstatic const struct i2c_algorithm bcm_algo = {\n\t.master_xfer = bcm_kona_i2c_xfer,\n\t.functionality = bcm_kona_i2c_functionality,\n};\n\nstatic int bcm_kona_i2c_assign_bus_speed(struct bcm_kona_i2c_dev *dev)\n{\n\tunsigned int bus_speed;\n\tint ret = of_property_read_u32(dev->device->of_node, \"clock-frequency\",\n\t\t\t\t       &bus_speed);\n\tif (ret < 0) {\n\t\tdev_err(dev->device, \"missing clock-frequency property\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tswitch (bus_speed) {\n\tcase I2C_MAX_STANDARD_MODE_FREQ:\n\t\tdev->std_cfg = &std_cfg_table[BCM_SPD_100K];\n\t\tbreak;\n\tcase I2C_MAX_FAST_MODE_FREQ:\n\t\tdev->std_cfg = &std_cfg_table[BCM_SPD_400K];\n\t\tbreak;\n\tcase I2C_MAX_FAST_MODE_PLUS_FREQ:\n\t\tdev->std_cfg = &std_cfg_table[BCM_SPD_1MHZ];\n\t\tbreak;\n\tcase I2C_MAX_HIGH_SPEED_MODE_FREQ:\n\t\t \n\t\tdev->std_cfg = &std_cfg_table[BCM_SPD_100K];\n\t\tdev->hs_cfg = &hs_cfg_table[BCM_SPD_3P4MHZ];\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"%d hz bus speed not supported\\n\", bus_speed);\n\t\tpr_err(\"Valid speeds are 100khz, 400khz, 1mhz, and 3.4mhz\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int bcm_kona_i2c_probe(struct platform_device *pdev)\n{\n\tint rc = 0;\n\tstruct bcm_kona_i2c_dev *dev;\n\tstruct i2c_adapter *adap;\n\n\t \n\tdev = devm_kzalloc(&pdev->dev, sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, dev);\n\tdev->device = &pdev->dev;\n\tinit_completion(&dev->done);\n\n\t \n\tdev->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(dev->base))\n\t\treturn PTR_ERR(dev->base);\n\n\t \n\tdev->external_clk = devm_clk_get(dev->device, NULL);\n\tif (IS_ERR(dev->external_clk)) {\n\t\tdev_err(dev->device, \"couldn't get clock\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\trc = clk_set_rate(dev->external_clk, STD_EXT_CLK_FREQ);\n\tif (rc) {\n\t\tdev_err(dev->device, \"%s: clk_set_rate returned %d\\n\",\n\t\t\t__func__, rc);\n\t\treturn rc;\n\t}\n\n\trc = clk_prepare_enable(dev->external_clk);\n\tif (rc) {\n\t\tdev_err(dev->device, \"couldn't enable clock\\n\");\n\t\treturn rc;\n\t}\n\n\t \n\trc = bcm_kona_i2c_assign_bus_speed(dev);\n\tif (rc)\n\t\tgoto probe_disable_clk;\n\n\t \n\tbcm_kona_i2c_enable_clock(dev);\n\n\t \n\tbcm_kona_i2c_config_timing(dev);\n\n\t \n\twritel(0, dev->base + TOUT_OFFSET);\n\n\t \n\tbcm_kona_i2c_enable_autosense(dev);\n\n\t \n\twritel(TXFCR_FIFO_FLUSH_MASK | TXFCR_FIFO_EN_MASK,\n\t       dev->base + TXFCR_OFFSET);\n\n\t \n\twritel(0, dev->base + IER_OFFSET);\n\n\t \n\twritel(ISR_CMDBUSY_MASK |\n\t       ISR_READ_COMPLETE_MASK |\n\t       ISR_SES_DONE_MASK |\n\t       ISR_ERR_MASK |\n\t       ISR_TXFIFOEMPTY_MASK |\n\t       ISR_NOACK_MASK,\n\t       dev->base + ISR_OFFSET);\n\n\t \n\tdev->irq = platform_get_irq(pdev, 0);\n\tif (dev->irq < 0) {\n\t\trc = dev->irq;\n\t\tgoto probe_disable_clk;\n\t}\n\n\t \n\trc = devm_request_irq(&pdev->dev, dev->irq, bcm_kona_i2c_isr,\n\t\t\t      IRQF_SHARED, pdev->name, dev);\n\tif (rc) {\n\t\tdev_err(dev->device, \"failed to request irq %i\\n\", dev->irq);\n\t\tgoto probe_disable_clk;\n\t}\n\n\t \n\tbcm_kona_i2c_send_cmd_to_ctrl(dev, BCM_CMD_NOACTION);\n\n\t \n\twritel(PADCTL_PAD_OUT_EN_MASK, dev->base + PADCTL_OFFSET);\n\n\t \n\tbcm_kona_i2c_disable_clock(dev);\n\n\t \n\tclk_disable_unprepare(dev->external_clk);\n\n\t \n\tadap = &dev->adapter;\n\ti2c_set_adapdata(adap, dev);\n\tadap->owner = THIS_MODULE;\n\tstrscpy(adap->name, \"Broadcom I2C adapter\", sizeof(adap->name));\n\tadap->algo = &bcm_algo;\n\tadap->dev.parent = &pdev->dev;\n\tadap->dev.of_node = pdev->dev.of_node;\n\n\trc = i2c_add_adapter(adap);\n\tif (rc)\n\t\treturn rc;\n\n\tdev_info(dev->device, \"device registered successfully\\n\");\n\n\treturn 0;\n\nprobe_disable_clk:\n\tbcm_kona_i2c_disable_clock(dev);\n\tclk_disable_unprepare(dev->external_clk);\n\n\treturn rc;\n}\n\nstatic void bcm_kona_i2c_remove(struct platform_device *pdev)\n{\n\tstruct bcm_kona_i2c_dev *dev = platform_get_drvdata(pdev);\n\n\ti2c_del_adapter(&dev->adapter);\n}\n\nstatic const struct of_device_id bcm_kona_i2c_of_match[] = {\n\t{.compatible = \"brcm,kona-i2c\",},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, bcm_kona_i2c_of_match);\n\nstatic struct platform_driver bcm_kona_i2c_driver = {\n\t.driver = {\n\t\t   .name = \"bcm-kona-i2c\",\n\t\t   .of_match_table = bcm_kona_i2c_of_match,\n\t\t   },\n\t.probe = bcm_kona_i2c_probe,\n\t.remove_new = bcm_kona_i2c_remove,\n};\nmodule_platform_driver(bcm_kona_i2c_driver);\n\nMODULE_AUTHOR(\"Tim Kryger <tkryger@broadcom.com>\");\nMODULE_DESCRIPTION(\"Broadcom Kona I2C Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}