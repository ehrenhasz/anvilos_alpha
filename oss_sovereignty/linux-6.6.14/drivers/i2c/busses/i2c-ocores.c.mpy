{
  "module_name": "i2c-ocores.c",
  "hash_id": "cfc600020006449507129e773e18c7f9f773ba7c124353de90ebfefdb75933d1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-ocores.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/platform_device.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/wait.h>\n#include <linux/platform_data/i2c-ocores.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/log2.h>\n#include <linux/spinlock.h>\n#include <linux/jiffies.h>\n\n \nstruct ocores_i2c {\n\tvoid __iomem *base;\n\tint iobase;\n\tu32 reg_shift;\n\tu32 reg_io_width;\n\tunsigned long flags;\n\twait_queue_head_t wait;\n\tstruct i2c_adapter adap;\n\tstruct i2c_msg *msg;\n\tint pos;\n\tint nmsgs;\n\tint state;  \n\tspinlock_t process_lock;\n\tstruct clk *clk;\n\tint ip_clock_khz;\n\tint bus_clock_khz;\n\tvoid (*setreg)(struct ocores_i2c *i2c, int reg, u8 value);\n\tu8 (*getreg)(struct ocores_i2c *i2c, int reg);\n};\n\n \n#define OCI2C_PRELOW\t\t0\n#define OCI2C_PREHIGH\t\t1\n#define OCI2C_CONTROL\t\t2\n#define OCI2C_DATA\t\t3\n#define OCI2C_CMD\t\t4  \n#define OCI2C_STATUS\t\t4  \n\n#define OCI2C_CTRL_IEN\t\t0x40\n#define OCI2C_CTRL_EN\t\t0x80\n\n#define OCI2C_CMD_START\t\t0x91\n#define OCI2C_CMD_STOP\t\t0x41\n#define OCI2C_CMD_READ\t\t0x21\n#define OCI2C_CMD_WRITE\t\t0x11\n#define OCI2C_CMD_READ_ACK\t0x21\n#define OCI2C_CMD_READ_NACK\t0x29\n#define OCI2C_CMD_IACK\t\t0x01\n\n#define OCI2C_STAT_IF\t\t0x01\n#define OCI2C_STAT_TIP\t\t0x02\n#define OCI2C_STAT_ARBLOST\t0x20\n#define OCI2C_STAT_BUSY\t\t0x40\n#define OCI2C_STAT_NACK\t\t0x80\n\n#define STATE_DONE\t\t0\n#define STATE_START\t\t1\n#define STATE_WRITE\t\t2\n#define STATE_READ\t\t3\n#define STATE_ERROR\t\t4\n\n#define TYPE_OCORES\t\t0\n#define TYPE_GRLIB\t\t1\n\n#define OCORES_FLAG_BROKEN_IRQ BIT(1)  \n\nstatic void oc_setreg_8(struct ocores_i2c *i2c, int reg, u8 value)\n{\n\tiowrite8(value, i2c->base + (reg << i2c->reg_shift));\n}\n\nstatic void oc_setreg_16(struct ocores_i2c *i2c, int reg, u8 value)\n{\n\tiowrite16(value, i2c->base + (reg << i2c->reg_shift));\n}\n\nstatic void oc_setreg_32(struct ocores_i2c *i2c, int reg, u8 value)\n{\n\tiowrite32(value, i2c->base + (reg << i2c->reg_shift));\n}\n\nstatic void oc_setreg_16be(struct ocores_i2c *i2c, int reg, u8 value)\n{\n\tiowrite16be(value, i2c->base + (reg << i2c->reg_shift));\n}\n\nstatic void oc_setreg_32be(struct ocores_i2c *i2c, int reg, u8 value)\n{\n\tiowrite32be(value, i2c->base + (reg << i2c->reg_shift));\n}\n\nstatic inline u8 oc_getreg_8(struct ocores_i2c *i2c, int reg)\n{\n\treturn ioread8(i2c->base + (reg << i2c->reg_shift));\n}\n\nstatic inline u8 oc_getreg_16(struct ocores_i2c *i2c, int reg)\n{\n\treturn ioread16(i2c->base + (reg << i2c->reg_shift));\n}\n\nstatic inline u8 oc_getreg_32(struct ocores_i2c *i2c, int reg)\n{\n\treturn ioread32(i2c->base + (reg << i2c->reg_shift));\n}\n\nstatic inline u8 oc_getreg_16be(struct ocores_i2c *i2c, int reg)\n{\n\treturn ioread16be(i2c->base + (reg << i2c->reg_shift));\n}\n\nstatic inline u8 oc_getreg_32be(struct ocores_i2c *i2c, int reg)\n{\n\treturn ioread32be(i2c->base + (reg << i2c->reg_shift));\n}\n\nstatic void oc_setreg_io_8(struct ocores_i2c *i2c, int reg, u8 value)\n{\n\toutb(value, i2c->iobase + reg);\n}\n\nstatic inline u8 oc_getreg_io_8(struct ocores_i2c *i2c, int reg)\n{\n\treturn inb(i2c->iobase + reg);\n}\n\nstatic inline void oc_setreg(struct ocores_i2c *i2c, int reg, u8 value)\n{\n\ti2c->setreg(i2c, reg, value);\n}\n\nstatic inline u8 oc_getreg(struct ocores_i2c *i2c, int reg)\n{\n\treturn i2c->getreg(i2c, reg);\n}\n\nstatic void ocores_process(struct ocores_i2c *i2c, u8 stat)\n{\n\tstruct i2c_msg *msg = i2c->msg;\n\tunsigned long flags;\n\n\t \n\tspin_lock_irqsave(&i2c->process_lock, flags);\n\n\tif ((i2c->state == STATE_DONE) || (i2c->state == STATE_ERROR)) {\n\t\t \n\t\toc_setreg(i2c, OCI2C_CMD, OCI2C_CMD_IACK);\n\t\twake_up(&i2c->wait);\n\t\tgoto out;\n\t}\n\n\t \n\tif (stat & OCI2C_STAT_ARBLOST) {\n\t\ti2c->state = STATE_ERROR;\n\t\toc_setreg(i2c, OCI2C_CMD, OCI2C_CMD_STOP);\n\t\tgoto out;\n\t}\n\n\tif ((i2c->state == STATE_START) || (i2c->state == STATE_WRITE)) {\n\t\ti2c->state =\n\t\t\t(msg->flags & I2C_M_RD) ? STATE_READ : STATE_WRITE;\n\n\t\tif (stat & OCI2C_STAT_NACK) {\n\t\t\ti2c->state = STATE_ERROR;\n\t\t\toc_setreg(i2c, OCI2C_CMD, OCI2C_CMD_STOP);\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tmsg->buf[i2c->pos++] = oc_getreg(i2c, OCI2C_DATA);\n\t}\n\n\t \n\tif (i2c->pos == msg->len) {\n\t\ti2c->nmsgs--;\n\t\ti2c->msg++;\n\t\ti2c->pos = 0;\n\t\tmsg = i2c->msg;\n\n\t\tif (i2c->nmsgs) {\t \n\t\t\t \n\t\t\tif (!(msg->flags & I2C_M_NOSTART)) {\n\t\t\t\tu8 addr = i2c_8bit_addr_from_msg(msg);\n\n\t\t\t\ti2c->state = STATE_START;\n\n\t\t\t\toc_setreg(i2c, OCI2C_DATA, addr);\n\t\t\t\toc_setreg(i2c, OCI2C_CMD, OCI2C_CMD_START);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\ti2c->state = (msg->flags & I2C_M_RD)\n\t\t\t\t? STATE_READ : STATE_WRITE;\n\t\t} else {\n\t\t\ti2c->state = STATE_DONE;\n\t\t\toc_setreg(i2c, OCI2C_CMD, OCI2C_CMD_STOP);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (i2c->state == STATE_READ) {\n\t\toc_setreg(i2c, OCI2C_CMD, i2c->pos == (msg->len-1) ?\n\t\t\t  OCI2C_CMD_READ_NACK : OCI2C_CMD_READ_ACK);\n\t} else {\n\t\toc_setreg(i2c, OCI2C_DATA, msg->buf[i2c->pos++]);\n\t\toc_setreg(i2c, OCI2C_CMD, OCI2C_CMD_WRITE);\n\t}\n\nout:\n\tspin_unlock_irqrestore(&i2c->process_lock, flags);\n}\n\nstatic irqreturn_t ocores_isr(int irq, void *dev_id)\n{\n\tstruct ocores_i2c *i2c = dev_id;\n\tu8 stat = oc_getreg(i2c, OCI2C_STATUS);\n\n\tif (i2c->flags & OCORES_FLAG_BROKEN_IRQ) {\n\t\tif ((stat & OCI2C_STAT_IF) && !(stat & OCI2C_STAT_BUSY))\n\t\t\treturn IRQ_NONE;\n\t} else if (!(stat & OCI2C_STAT_IF)) {\n\t\treturn IRQ_NONE;\n\t}\n\tocores_process(i2c, stat);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic void ocores_process_timeout(struct ocores_i2c *i2c)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&i2c->process_lock, flags);\n\ti2c->state = STATE_ERROR;\n\toc_setreg(i2c, OCI2C_CMD, OCI2C_CMD_STOP);\n\tspin_unlock_irqrestore(&i2c->process_lock, flags);\n}\n\n \nstatic int ocores_wait(struct ocores_i2c *i2c,\n\t\t       int reg, u8 mask, u8 val,\n\t\t       const unsigned long timeout)\n{\n\tunsigned long j;\n\n\tj = jiffies + timeout;\n\twhile (1) {\n\t\tu8 status = oc_getreg(i2c, reg);\n\n\t\tif ((status & mask) == val)\n\t\t\tbreak;\n\n\t\tif (time_after(jiffies, j))\n\t\t\treturn -ETIMEDOUT;\n\t}\n\treturn 0;\n}\n\n \nstatic int ocores_poll_wait(struct ocores_i2c *i2c)\n{\n\tu8 mask;\n\tint err;\n\n\tif (i2c->state == STATE_DONE || i2c->state == STATE_ERROR) {\n\t\t \n\t\tmask = OCI2C_STAT_BUSY;\n\t} else {\n\t\t \n\t\tmask = OCI2C_STAT_TIP;\n\t\t \n\t\tudelay((8 * 1000) / i2c->bus_clock_khz);\n\t}\n\n\t \n\terr = ocores_wait(i2c, OCI2C_STATUS, mask, 0, msecs_to_jiffies(1));\n\tif (err)\n\t\tdev_warn(i2c->adap.dev.parent,\n\t\t\t \"%s: STATUS timeout, bit 0x%x did not clear in 1ms\\n\",\n\t\t\t __func__, mask);\n\treturn err;\n}\n\n \nstatic int ocores_process_polling(struct ocores_i2c *i2c)\n{\n\tirqreturn_t ret;\n\tint err = 0;\n\n\twhile (1) {\n\t\terr = ocores_poll_wait(i2c);\n\t\tif (err)\n\t\t\tbreak;  \n\n\t\tret = ocores_isr(-1, i2c);\n\t\tif (ret == IRQ_NONE)\n\t\t\tbreak;  \n\t\telse {\n\t\t\tif (i2c->flags & OCORES_FLAG_BROKEN_IRQ)\n\t\t\t\tif (i2c->state == STATE_DONE)\n\t\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn err;\n}\n\nstatic int ocores_xfer_core(struct ocores_i2c *i2c,\n\t\t\t    struct i2c_msg *msgs, int num,\n\t\t\t    bool polling)\n{\n\tint ret = 0;\n\tu8 ctrl;\n\n\tctrl = oc_getreg(i2c, OCI2C_CONTROL);\n\tif (polling)\n\t\toc_setreg(i2c, OCI2C_CONTROL, ctrl & ~OCI2C_CTRL_IEN);\n\telse\n\t\toc_setreg(i2c, OCI2C_CONTROL, ctrl | OCI2C_CTRL_IEN);\n\n\ti2c->msg = msgs;\n\ti2c->pos = 0;\n\ti2c->nmsgs = num;\n\ti2c->state = STATE_START;\n\n\toc_setreg(i2c, OCI2C_DATA, i2c_8bit_addr_from_msg(i2c->msg));\n\toc_setreg(i2c, OCI2C_CMD, OCI2C_CMD_START);\n\n\tif (polling) {\n\t\tret = ocores_process_polling(i2c);\n\t} else {\n\t\tif (wait_event_timeout(i2c->wait,\n\t\t\t\t       (i2c->state == STATE_ERROR) ||\n\t\t\t\t       (i2c->state == STATE_DONE), HZ) == 0)\n\t\t\tret = -ETIMEDOUT;\n\t}\n\tif (ret) {\n\t\tocores_process_timeout(i2c);\n\t\treturn ret;\n\t}\n\n\treturn (i2c->state == STATE_DONE) ? num : -EIO;\n}\n\nstatic int ocores_xfer_polling(struct i2c_adapter *adap,\n\t\t\t       struct i2c_msg *msgs, int num)\n{\n\treturn ocores_xfer_core(i2c_get_adapdata(adap), msgs, num, true);\n}\n\nstatic int ocores_xfer(struct i2c_adapter *adap,\n\t\t       struct i2c_msg *msgs, int num)\n{\n\treturn ocores_xfer_core(i2c_get_adapdata(adap), msgs, num, false);\n}\n\nstatic int ocores_init(struct device *dev, struct ocores_i2c *i2c)\n{\n\tint prescale;\n\tint diff;\n\tu8 ctrl = oc_getreg(i2c, OCI2C_CONTROL);\n\n\t \n\tctrl &= ~(OCI2C_CTRL_EN | OCI2C_CTRL_IEN);\n\toc_setreg(i2c, OCI2C_CONTROL, ctrl);\n\n\tprescale = (i2c->ip_clock_khz / (5 * i2c->bus_clock_khz)) - 1;\n\tprescale = clamp(prescale, 0, 0xffff);\n\n\tdiff = i2c->ip_clock_khz / (5 * (prescale + 1)) - i2c->bus_clock_khz;\n\tif (abs(diff) > i2c->bus_clock_khz / 10) {\n\t\tdev_err(dev,\n\t\t\t\"Unsupported clock settings: core: %d KHz, bus: %d KHz\\n\",\n\t\t\ti2c->ip_clock_khz, i2c->bus_clock_khz);\n\t\treturn -EINVAL;\n\t}\n\n\toc_setreg(i2c, OCI2C_PRELOW, prescale & 0xff);\n\toc_setreg(i2c, OCI2C_PREHIGH, prescale >> 8);\n\n\t \n\toc_setreg(i2c, OCI2C_CMD, OCI2C_CMD_IACK);\n\toc_setreg(i2c, OCI2C_CONTROL, ctrl | OCI2C_CTRL_EN);\n\n\treturn 0;\n}\n\n\nstatic u32 ocores_func(struct i2c_adapter *adap)\n{\n\treturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;\n}\n\nstatic struct i2c_algorithm ocores_algorithm = {\n\t.master_xfer = ocores_xfer,\n\t.master_xfer_atomic = ocores_xfer_polling,\n\t.functionality = ocores_func,\n};\n\nstatic const struct i2c_adapter ocores_adapter = {\n\t.owner = THIS_MODULE,\n\t.name = \"i2c-ocores\",\n\t.class = I2C_CLASS_DEPRECATED,\n\t.algo = &ocores_algorithm,\n};\n\nstatic const struct of_device_id ocores_i2c_match[] = {\n\t{\n\t\t.compatible = \"opencores,i2c-ocores\",\n\t\t.data = (void *)TYPE_OCORES,\n\t},\n\t{\n\t\t.compatible = \"aeroflexgaisler,i2cmst\",\n\t\t.data = (void *)TYPE_GRLIB,\n\t},\n\t{\n\t\t.compatible = \"sifive,fu540-c000-i2c\",\n\t},\n\t{\n\t\t.compatible = \"sifive,i2c0\",\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, ocores_i2c_match);\n\n#ifdef CONFIG_OF\n \nstatic u8 oc_getreg_grlib(struct ocores_i2c *i2c, int reg)\n{\n\tu32 rd;\n\tint rreg = reg;\n\n\tif (reg != OCI2C_PRELOW)\n\t\trreg--;\n\trd = ioread32be(i2c->base + (rreg << i2c->reg_shift));\n\tif (reg == OCI2C_PREHIGH)\n\t\treturn (u8)(rd >> 8);\n\telse\n\t\treturn (u8)rd;\n}\n\nstatic void oc_setreg_grlib(struct ocores_i2c *i2c, int reg, u8 value)\n{\n\tu32 curr, wr;\n\tint rreg = reg;\n\n\tif (reg != OCI2C_PRELOW)\n\t\trreg--;\n\tif (reg == OCI2C_PRELOW || reg == OCI2C_PREHIGH) {\n\t\tcurr = ioread32be(i2c->base + (rreg << i2c->reg_shift));\n\t\tif (reg == OCI2C_PRELOW)\n\t\t\twr = (curr & 0xff00) | value;\n\t\telse\n\t\t\twr = (((u32)value) << 8) | (curr & 0xff);\n\t} else {\n\t\twr = value;\n\t}\n\tiowrite32be(wr, i2c->base + (rreg << i2c->reg_shift));\n}\n\nstatic int ocores_i2c_of_probe(struct platform_device *pdev,\n\t\t\t\tstruct ocores_i2c *i2c)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tconst struct of_device_id *match;\n\tu32 val;\n\tu32 clock_frequency;\n\tbool clock_frequency_present;\n\n\tif (of_property_read_u32(np, \"reg-shift\", &i2c->reg_shift)) {\n\t\t \n\t\tif (!of_property_read_u32(np, \"regstep\", &val)) {\n\t\t\tif (!is_power_of_2(val)) {\n\t\t\t\tdev_err(&pdev->dev, \"invalid regstep %d\\n\",\n\t\t\t\t\tval);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\ti2c->reg_shift = ilog2(val);\n\t\t\tdev_warn(&pdev->dev,\n\t\t\t\t\"regstep property deprecated, use reg-shift\\n\");\n\t\t}\n\t}\n\n\tclock_frequency_present = !of_property_read_u32(np, \"clock-frequency\",\n\t\t\t\t\t\t\t&clock_frequency);\n\ti2c->bus_clock_khz = 100;\n\n\ti2c->clk = devm_clk_get_optional_enabled(&pdev->dev, NULL);\n\tif (IS_ERR(i2c->clk))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(i2c->clk),\n\t\t\t\t     \"devm_clk_get_optional_enabled failed\\n\");\n\n\ti2c->ip_clock_khz = clk_get_rate(i2c->clk) / 1000;\n\tif (clock_frequency_present)\n\t\ti2c->bus_clock_khz = clock_frequency / 1000;\n\tif (i2c->ip_clock_khz == 0) {\n\t\tif (of_property_read_u32(np, \"opencores,ip-clock-frequency\",\n\t\t\t\t\t\t&val)) {\n\t\t\tif (!clock_frequency_present) {\n\t\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\t\"Missing required parameter 'opencores,ip-clock-frequency'\\n\");\n\t\t\t\treturn -ENODEV;\n\t\t\t}\n\t\t\ti2c->ip_clock_khz = clock_frequency / 1000;\n\t\t\tdev_warn(&pdev->dev,\n\t\t\t\t \"Deprecated usage of the 'clock-frequency' property, please update to 'opencores,ip-clock-frequency'\\n\");\n\t\t} else {\n\t\t\ti2c->ip_clock_khz = val / 1000;\n\t\t\tif (clock_frequency_present)\n\t\t\t\ti2c->bus_clock_khz = clock_frequency / 1000;\n\t\t}\n\t}\n\n\tof_property_read_u32(pdev->dev.of_node, \"reg-io-width\",\n\t\t\t\t&i2c->reg_io_width);\n\n\tmatch = of_match_node(ocores_i2c_match, pdev->dev.of_node);\n\tif (match && (long)match->data == TYPE_GRLIB) {\n\t\tdev_dbg(&pdev->dev, \"GRLIB variant of i2c-ocores\\n\");\n\t\ti2c->setreg = oc_setreg_grlib;\n\t\ti2c->getreg = oc_getreg_grlib;\n\t}\n\n\treturn 0;\n}\n#else\n#define ocores_i2c_of_probe(pdev, i2c) -ENODEV\n#endif\n\nstatic int ocores_i2c_probe(struct platform_device *pdev)\n{\n\tstruct ocores_i2c *i2c;\n\tstruct ocores_i2c_platform_data *pdata;\n\tstruct resource *res;\n\tint irq;\n\tint ret;\n\tint i;\n\n\ti2c = devm_kzalloc(&pdev->dev, sizeof(*i2c), GFP_KERNEL);\n\tif (!i2c)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&i2c->process_lock);\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (res) {\n\t\ti2c->base = devm_ioremap_resource(&pdev->dev, res);\n\t\tif (IS_ERR(i2c->base))\n\t\t\treturn PTR_ERR(i2c->base);\n\t} else {\n\t\tres = platform_get_resource(pdev, IORESOURCE_IO, 0);\n\t\tif (!res)\n\t\t\treturn -EINVAL;\n\t\ti2c->iobase = res->start;\n\t\tif (!devm_request_region(&pdev->dev, res->start,\n\t\t\t\t\t resource_size(res),\n\t\t\t\t\t pdev->name)) {\n\t\t\tdev_err(&pdev->dev, \"Can't get I/O resource.\\n\");\n\t\t\treturn -EBUSY;\n\t\t}\n\t\ti2c->setreg = oc_setreg_io_8;\n\t\ti2c->getreg = oc_getreg_io_8;\n\t}\n\n\tpdata = dev_get_platdata(&pdev->dev);\n\tif (pdata) {\n\t\ti2c->reg_shift = pdata->reg_shift;\n\t\ti2c->reg_io_width = pdata->reg_io_width;\n\t\ti2c->ip_clock_khz = pdata->clock_khz;\n\t\tif (pdata->bus_khz)\n\t\t\ti2c->bus_clock_khz = pdata->bus_khz;\n\t\telse\n\t\t\ti2c->bus_clock_khz = 100;\n\t} else {\n\t\tret = ocores_i2c_of_probe(pdev, i2c);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (i2c->reg_io_width == 0)\n\t\ti2c->reg_io_width = 1;  \n\n\tif (!i2c->setreg || !i2c->getreg) {\n\t\tbool be = pdata ? pdata->big_endian :\n\t\t\tof_device_is_big_endian(pdev->dev.of_node);\n\n\t\tswitch (i2c->reg_io_width) {\n\t\tcase 1:\n\t\t\ti2c->setreg = oc_setreg_8;\n\t\t\ti2c->getreg = oc_getreg_8;\n\t\t\tbreak;\n\n\t\tcase 2:\n\t\t\ti2c->setreg = be ? oc_setreg_16be : oc_setreg_16;\n\t\t\ti2c->getreg = be ? oc_getreg_16be : oc_getreg_16;\n\t\t\tbreak;\n\n\t\tcase 4:\n\t\t\ti2c->setreg = be ? oc_setreg_32be : oc_setreg_32;\n\t\t\ti2c->getreg = be ? oc_getreg_32be : oc_getreg_32;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tdev_err(&pdev->dev, \"Unsupported I/O width (%d)\\n\",\n\t\t\t\ti2c->reg_io_width);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tinit_waitqueue_head(&i2c->wait);\n\n\tirq = platform_get_irq_optional(pdev, 0);\n\t \n\tif (of_device_is_compatible(pdev->dev.of_node,\n\t\t\t\t    \"sifive,fu540-c000-i2c\")) {\n\t\ti2c->flags |= OCORES_FLAG_BROKEN_IRQ;\n\t\tirq = -ENXIO;\n\t}\n\n\tif (irq == -ENXIO) {\n\t\tocores_algorithm.master_xfer = ocores_xfer_polling;\n\t} else {\n\t\tif (irq < 0)\n\t\t\treturn irq;\n\t}\n\n\tif (ocores_algorithm.master_xfer != ocores_xfer_polling) {\n\t\tret = devm_request_any_context_irq(&pdev->dev, irq,\n\t\t\t\t\t\t   ocores_isr, 0,\n\t\t\t\t\t\t   pdev->name, i2c);\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev, \"Cannot claim IRQ\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = ocores_init(&pdev->dev, i2c);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tplatform_set_drvdata(pdev, i2c);\n\ti2c->adap = ocores_adapter;\n\ti2c_set_adapdata(&i2c->adap, i2c);\n\ti2c->adap.dev.parent = &pdev->dev;\n\ti2c->adap.dev.of_node = pdev->dev.of_node;\n\n\t \n\tret = i2c_add_adapter(&i2c->adap);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (pdata) {\n\t\tfor (i = 0; i < pdata->num_devices; i++)\n\t\t\ti2c_new_client_device(&i2c->adap, pdata->devices + i);\n\t}\n\n\treturn 0;\n}\n\nstatic void ocores_i2c_remove(struct platform_device *pdev)\n{\n\tstruct ocores_i2c *i2c = platform_get_drvdata(pdev);\n\tu8 ctrl = oc_getreg(i2c, OCI2C_CONTROL);\n\n\t \n\tctrl &= ~(OCI2C_CTRL_EN | OCI2C_CTRL_IEN);\n\toc_setreg(i2c, OCI2C_CONTROL, ctrl);\n\n\t \n\ti2c_del_adapter(&i2c->adap);\n}\n\nstatic int ocores_i2c_suspend(struct device *dev)\n{\n\tstruct ocores_i2c *i2c = dev_get_drvdata(dev);\n\tu8 ctrl = oc_getreg(i2c, OCI2C_CONTROL);\n\n\t \n\tctrl &= ~(OCI2C_CTRL_EN | OCI2C_CTRL_IEN);\n\toc_setreg(i2c, OCI2C_CONTROL, ctrl);\n\n\tclk_disable_unprepare(i2c->clk);\n\treturn 0;\n}\n\nstatic int ocores_i2c_resume(struct device *dev)\n{\n\tstruct ocores_i2c *i2c = dev_get_drvdata(dev);\n\tunsigned long rate;\n\tint ret;\n\n\tret = clk_prepare_enable(i2c->clk);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"clk_prepare_enable failed\\n\");\n\trate = clk_get_rate(i2c->clk) / 1000;\n\tif (rate)\n\t\ti2c->ip_clock_khz = rate;\n\treturn ocores_init(dev, i2c);\n}\n\nstatic DEFINE_NOIRQ_DEV_PM_OPS(ocores_i2c_pm,\n\t\t\t       ocores_i2c_suspend, ocores_i2c_resume);\n\nstatic struct platform_driver ocores_i2c_driver = {\n\t.probe   = ocores_i2c_probe,\n\t.remove_new = ocores_i2c_remove,\n\t.driver  = {\n\t\t.name = \"ocores-i2c\",\n\t\t.of_match_table = ocores_i2c_match,\n\t\t.pm = pm_sleep_ptr(&ocores_i2c_pm),\n\t},\n};\n\nmodule_platform_driver(ocores_i2c_driver);\n\nMODULE_AUTHOR(\"Peter Korsgaard <peter@korsgaard.com>\");\nMODULE_DESCRIPTION(\"OpenCores I2C bus driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:ocores-i2c\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}