{
  "module_name": "i2c-xlp9xx.c",
  "hash_id": "fbafc973324060da5003d94bdf13e0346b912eb924bf634b8113bb154eaee5fa",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-xlp9xx.c",
  "human_readable_source": " \n\n#include <linux/acpi.h>\n#include <linux/clk.h>\n#include <linux/completion.h>\n#include <linux/i2c.h>\n#include <linux/i2c-smbus.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/delay.h>\n\n#define XLP9XX_I2C_DIV\t\t\t0x0\n#define XLP9XX_I2C_CTRL\t\t\t0x1\n#define XLP9XX_I2C_CMD\t\t\t0x2\n#define XLP9XX_I2C_STATUS\t\t0x3\n#define XLP9XX_I2C_MTXFIFO\t\t0x4\n#define XLP9XX_I2C_MRXFIFO\t\t0x5\n#define XLP9XX_I2C_MFIFOCTRL\t\t0x6\n#define XLP9XX_I2C_STXFIFO\t\t0x7\n#define XLP9XX_I2C_SRXFIFO\t\t0x8\n#define XLP9XX_I2C_SFIFOCTRL\t\t0x9\n#define XLP9XX_I2C_SLAVEADDR\t\t0xA\n#define XLP9XX_I2C_OWNADDR\t\t0xB\n#define XLP9XX_I2C_FIFOWCNT\t\t0xC\n#define XLP9XX_I2C_INTEN\t\t0xD\n#define XLP9XX_I2C_INTST\t\t0xE\n#define XLP9XX_I2C_WAITCNT\t\t0xF\n#define XLP9XX_I2C_TIMEOUT\t\t0X10\n#define XLP9XX_I2C_GENCALLADDR\t\t0x11\n\n#define XLP9XX_I2C_STATUS_BUSY\t\tBIT(0)\n\n#define XLP9XX_I2C_CMD_START\t\tBIT(7)\n#define XLP9XX_I2C_CMD_STOP\t\tBIT(6)\n#define XLP9XX_I2C_CMD_READ\t\tBIT(5)\n#define XLP9XX_I2C_CMD_WRITE\t\tBIT(4)\n#define XLP9XX_I2C_CMD_ACK\t\tBIT(3)\n\n#define XLP9XX_I2C_CTRL_MCTLEN_SHIFT\t16\n#define XLP9XX_I2C_CTRL_MCTLEN_MASK\t0xffff0000\n#define XLP9XX_I2C_CTRL_RST\t\tBIT(8)\n#define XLP9XX_I2C_CTRL_EN\t\tBIT(6)\n#define XLP9XX_I2C_CTRL_MASTER\t\tBIT(4)\n#define XLP9XX_I2C_CTRL_FIFORD\t\tBIT(1)\n#define XLP9XX_I2C_CTRL_ADDMODE\t\tBIT(0)\n\n#define XLP9XX_I2C_INTEN_NACKADDR\tBIT(25)\n#define XLP9XX_I2C_INTEN_SADDR\t\tBIT(13)\n#define XLP9XX_I2C_INTEN_DATADONE\tBIT(12)\n#define XLP9XX_I2C_INTEN_ARLOST\t\tBIT(11)\n#define XLP9XX_I2C_INTEN_MFIFOFULL\tBIT(4)\n#define XLP9XX_I2C_INTEN_MFIFOEMTY\tBIT(3)\n#define XLP9XX_I2C_INTEN_MFIFOHI\tBIT(2)\n#define XLP9XX_I2C_INTEN_BUSERR\t\tBIT(0)\n\n#define XLP9XX_I2C_MFIFOCTRL_HITH_SHIFT\t\t8\n#define XLP9XX_I2C_MFIFOCTRL_LOTH_SHIFT\t\t0\n#define XLP9XX_I2C_MFIFOCTRL_RST\t\tBIT(16)\n\n#define XLP9XX_I2C_SLAVEADDR_RW\t\t\tBIT(0)\n#define XLP9XX_I2C_SLAVEADDR_ADDR_SHIFT\t\t1\n\n#define XLP9XX_I2C_IP_CLK_FREQ\t\t133000000UL\n#define XLP9XX_I2C_FIFO_SIZE\t\t0x80U\n#define XLP9XX_I2C_TIMEOUT_MS\t\t1000\n#define XLP9XX_I2C_BUSY_TIMEOUT\t\t50\n\n#define XLP9XX_I2C_FIFO_WCNT_MASK\t0xff\n#define XLP9XX_I2C_STATUS_ERRMASK\t(XLP9XX_I2C_INTEN_ARLOST | \\\n\t\t\tXLP9XX_I2C_INTEN_NACKADDR | XLP9XX_I2C_INTEN_BUSERR)\n\nstruct xlp9xx_i2c_dev {\n\tstruct device *dev;\n\tstruct i2c_adapter adapter;\n\tstruct completion msg_complete;\n\tstruct i2c_smbus_alert_setup alert_data;\n\tstruct i2c_client *ara;\n\tint irq;\n\tbool msg_read;\n\tbool len_recv;\n\tbool client_pec;\n\tu32 __iomem *base;\n\tu32 msg_buf_remaining;\n\tu32 msg_len;\n\tu32 ip_clk_hz;\n\tu32 clk_hz;\n\tu32 msg_err;\n\tu8 *msg_buf;\n};\n\nstatic inline void xlp9xx_write_i2c_reg(struct xlp9xx_i2c_dev *priv,\n\t\t\t\t\tunsigned long reg, u32 val)\n{\n\twritel(val, priv->base + reg);\n}\n\nstatic inline u32 xlp9xx_read_i2c_reg(struct xlp9xx_i2c_dev *priv,\n\t\t\t\t      unsigned long reg)\n{\n\treturn readl(priv->base + reg);\n}\n\nstatic void xlp9xx_i2c_mask_irq(struct xlp9xx_i2c_dev *priv, u32 mask)\n{\n\tu32 inten;\n\n\tinten = xlp9xx_read_i2c_reg(priv, XLP9XX_I2C_INTEN) & ~mask;\n\txlp9xx_write_i2c_reg(priv, XLP9XX_I2C_INTEN, inten);\n}\n\nstatic void xlp9xx_i2c_unmask_irq(struct xlp9xx_i2c_dev *priv, u32 mask)\n{\n\tu32 inten;\n\n\tinten = xlp9xx_read_i2c_reg(priv, XLP9XX_I2C_INTEN) | mask;\n\txlp9xx_write_i2c_reg(priv, XLP9XX_I2C_INTEN, inten);\n}\n\nstatic void xlp9xx_i2c_update_rx_fifo_thres(struct xlp9xx_i2c_dev *priv)\n{\n\tu32 thres;\n\n\tif (priv->len_recv)\n\t\t \n\t\tthres = 1;\n\telse if (priv->msg_buf_remaining > XLP9XX_I2C_FIFO_SIZE)\n\t\tthres = XLP9XX_I2C_FIFO_SIZE;\n\telse\n\t\tthres = priv->msg_buf_remaining;\n\n\txlp9xx_write_i2c_reg(priv, XLP9XX_I2C_MFIFOCTRL,\n\t\t\t     thres << XLP9XX_I2C_MFIFOCTRL_HITH_SHIFT);\n}\n\nstatic void xlp9xx_i2c_fill_tx_fifo(struct xlp9xx_i2c_dev *priv)\n{\n\tu32 len, i;\n\tu8 *buf = priv->msg_buf;\n\n\tlen = min(priv->msg_buf_remaining, XLP9XX_I2C_FIFO_SIZE);\n\tfor (i = 0; i < len; i++)\n\t\txlp9xx_write_i2c_reg(priv, XLP9XX_I2C_MTXFIFO, buf[i]);\n\tpriv->msg_buf_remaining -= len;\n\tpriv->msg_buf += len;\n}\n\nstatic void xlp9xx_i2c_update_rlen(struct xlp9xx_i2c_dev *priv)\n{\n\tu32 val, len;\n\n\t \n\tval = xlp9xx_read_i2c_reg(priv, XLP9XX_I2C_CTRL);\n\tlen = xlp9xx_read_i2c_reg(priv, XLP9XX_I2C_FIFOWCNT) &\n\t\t\t\t  XLP9XX_I2C_FIFO_WCNT_MASK;\n\tlen = max_t(u32, priv->msg_len, len + 4);\n\tif (len >= I2C_SMBUS_BLOCK_MAX + 2)\n\t\treturn;\n\tval = (val & ~XLP9XX_I2C_CTRL_MCTLEN_MASK) |\n\t\t\t(len << XLP9XX_I2C_CTRL_MCTLEN_SHIFT);\n\txlp9xx_write_i2c_reg(priv, XLP9XX_I2C_CTRL, val);\n}\n\nstatic void xlp9xx_i2c_drain_rx_fifo(struct xlp9xx_i2c_dev *priv)\n{\n\tu32 len, i;\n\tu8 rlen, *buf = priv->msg_buf;\n\n\tlen = xlp9xx_read_i2c_reg(priv, XLP9XX_I2C_FIFOWCNT) &\n\t\t\t\t  XLP9XX_I2C_FIFO_WCNT_MASK;\n\tif (!len)\n\t\treturn;\n\tif (priv->len_recv) {\n\t\t \n\t\trlen = xlp9xx_read_i2c_reg(priv, XLP9XX_I2C_MRXFIFO);\n\n\t\t \n\n\t\tlen--;\n\t\tif (rlen > I2C_SMBUS_BLOCK_MAX || rlen == 0) {\n\t\t\trlen = 0;\t \n\t\t\tpriv->msg_buf_remaining = 0;\n\t\t\tpriv->msg_len = 0;\n\t\t\txlp9xx_i2c_update_rlen(priv);\n\t\t\treturn;\n\t\t}\n\n\t\t*buf++ = rlen;\n\t\tif (priv->client_pec)\n\t\t\t++rlen;  \n\t\t \n\t\tpriv->msg_buf_remaining = rlen;\n\t\tpriv->msg_len = rlen + 1;\n\t\txlp9xx_i2c_update_rlen(priv);\n\t\tpriv->len_recv = false;\n\t}\n\n\tlen = min(priv->msg_buf_remaining, len);\n\tfor (i = 0; i < len; i++, buf++)\n\t\t*buf = xlp9xx_read_i2c_reg(priv, XLP9XX_I2C_MRXFIFO);\n\n\tpriv->msg_buf_remaining -= len;\n\tpriv->msg_buf = buf;\n\n\tif (priv->msg_buf_remaining)\n\t\txlp9xx_i2c_update_rx_fifo_thres(priv);\n}\n\nstatic irqreturn_t xlp9xx_i2c_isr(int irq, void *dev_id)\n{\n\tstruct xlp9xx_i2c_dev *priv = dev_id;\n\tu32 status;\n\n\tstatus = xlp9xx_read_i2c_reg(priv, XLP9XX_I2C_INTST);\n\tif (status == 0)\n\t\treturn IRQ_NONE;\n\n\txlp9xx_write_i2c_reg(priv, XLP9XX_I2C_INTST, status);\n\tif (status & XLP9XX_I2C_STATUS_ERRMASK) {\n\t\tpriv->msg_err = status;\n\t\tgoto xfer_done;\n\t}\n\n\t \n\tif ((status & XLP9XX_I2C_INTEN_SADDR) && (priv->msg_len == 0))\n\t\tgoto xfer_done;\n\n\tif (!priv->msg_read) {\n\t\tif (status & XLP9XX_I2C_INTEN_MFIFOEMTY) {\n\t\t\t \n\t\t\tif (priv->msg_buf_remaining)\n\t\t\t\txlp9xx_i2c_fill_tx_fifo(priv);\n\t\t\telse\n\t\t\t\txlp9xx_i2c_mask_irq(priv,\n\t\t\t\t\t\t    XLP9XX_I2C_INTEN_MFIFOEMTY);\n\t\t}\n\t} else {\n\t\tif (status & (XLP9XX_I2C_INTEN_DATADONE |\n\t\t\t      XLP9XX_I2C_INTEN_MFIFOHI)) {\n\t\t\t \n\t\t\tif (priv->msg_buf_remaining)\n\t\t\t\txlp9xx_i2c_drain_rx_fifo(priv);\n\t\t}\n\t}\n\n\t \n\tif (status & XLP9XX_I2C_INTEN_DATADONE)\n\t\tgoto xfer_done;\n\n\treturn IRQ_HANDLED;\n\nxfer_done:\n\txlp9xx_write_i2c_reg(priv, XLP9XX_I2C_INTEN, 0);\n\tcomplete(&priv->msg_complete);\n\treturn IRQ_HANDLED;\n}\n\nstatic int xlp9xx_i2c_check_bus_status(struct xlp9xx_i2c_dev *priv)\n{\n\tu32 status;\n\tu32 busy_timeout = XLP9XX_I2C_BUSY_TIMEOUT;\n\n\twhile (busy_timeout) {\n\t\tstatus = xlp9xx_read_i2c_reg(priv, XLP9XX_I2C_STATUS);\n\t\tif ((status & XLP9XX_I2C_STATUS_BUSY) == 0)\n\t\t\tbreak;\n\n\t\tbusy_timeout--;\n\t\tusleep_range(1000, 1100);\n\t}\n\n\tif (!busy_timeout)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic int xlp9xx_i2c_init(struct xlp9xx_i2c_dev *priv)\n{\n\tu32 prescale;\n\n\t \n\tprescale = DIV_ROUND_UP(priv->ip_clk_hz, priv->clk_hz);\n\tprescale = ((prescale - 8) / 5) - 1;\n\txlp9xx_write_i2c_reg(priv, XLP9XX_I2C_CTRL, XLP9XX_I2C_CTRL_RST);\n\txlp9xx_write_i2c_reg(priv, XLP9XX_I2C_CTRL, XLP9XX_I2C_CTRL_EN |\n\t\t\t     XLP9XX_I2C_CTRL_MASTER);\n\txlp9xx_write_i2c_reg(priv, XLP9XX_I2C_DIV, prescale);\n\txlp9xx_write_i2c_reg(priv, XLP9XX_I2C_INTEN, 0);\n\n\treturn 0;\n}\n\nstatic int xlp9xx_i2c_xfer_msg(struct xlp9xx_i2c_dev *priv, struct i2c_msg *msg,\n\t\t\t       int last_msg)\n{\n\tunsigned long timeleft;\n\tu32 intr_mask, cmd, val, len;\n\n\tpriv->msg_buf = msg->buf;\n\tpriv->msg_buf_remaining = priv->msg_len = msg->len;\n\tpriv->msg_err = 0;\n\tpriv->msg_read = (msg->flags & I2C_M_RD);\n\treinit_completion(&priv->msg_complete);\n\n\t \n\txlp9xx_write_i2c_reg(priv, XLP9XX_I2C_MFIFOCTRL,\n\t\t\t     XLP9XX_I2C_MFIFOCTRL_RST);\n\n\t \n\txlp9xx_write_i2c_reg(priv, XLP9XX_I2C_SLAVEADDR,\n\t\t\t     (msg->addr << XLP9XX_I2C_SLAVEADDR_ADDR_SHIFT) |\n\t\t\t     (priv->msg_read ? XLP9XX_I2C_SLAVEADDR_RW : 0));\n\n\t \n\tval = xlp9xx_read_i2c_reg(priv, XLP9XX_I2C_CTRL);\n\tif (!priv->msg_read)\n\t\tval &= ~XLP9XX_I2C_CTRL_FIFORD;\n\telse\n\t\tval |= XLP9XX_I2C_CTRL_FIFORD;\t \n\n\tif (msg->flags & I2C_M_TEN)\n\t\tval |= XLP9XX_I2C_CTRL_ADDMODE;\t \n\telse\n\t\tval &= ~XLP9XX_I2C_CTRL_ADDMODE;\n\n\tpriv->len_recv = msg->flags & I2C_M_RECV_LEN;\n\tlen = priv->len_recv ? I2C_SMBUS_BLOCK_MAX + 2 : msg->len;\n\tpriv->client_pec = msg->flags & I2C_CLIENT_PEC;\n\n\t \n\tif (priv->msg_read)\n\t\txlp9xx_i2c_update_rx_fifo_thres(priv);\n\n\t \n\tval = (val & ~XLP9XX_I2C_CTRL_MCTLEN_MASK) |\n\t      (len << XLP9XX_I2C_CTRL_MCTLEN_SHIFT);\n\txlp9xx_write_i2c_reg(priv, XLP9XX_I2C_CTRL, val);\n\n\t \n\tif (!priv->msg_read)\n\t\txlp9xx_i2c_fill_tx_fifo(priv);\n\n\t \n\tintr_mask = (XLP9XX_I2C_INTEN_ARLOST | XLP9XX_I2C_INTEN_BUSERR |\n\t\t     XLP9XX_I2C_INTEN_NACKADDR | XLP9XX_I2C_INTEN_DATADONE);\n\n\tif (priv->msg_read) {\n\t\tintr_mask |= XLP9XX_I2C_INTEN_MFIFOHI;\n\t\tif (msg->len == 0)\n\t\t\tintr_mask |= XLP9XX_I2C_INTEN_SADDR;\n\t} else {\n\t\tif (msg->len == 0)\n\t\t\tintr_mask |= XLP9XX_I2C_INTEN_SADDR;\n\t\telse\n\t\t\tintr_mask |= XLP9XX_I2C_INTEN_MFIFOEMTY;\n\t}\n\txlp9xx_i2c_unmask_irq(priv, intr_mask);\n\n\t \n\tcmd = XLP9XX_I2C_CMD_START;\n\tif (msg->len)\n\t\tcmd |= (priv->msg_read ?\n\t\t\tXLP9XX_I2C_CMD_READ : XLP9XX_I2C_CMD_WRITE);\n\tif (last_msg)\n\t\tcmd |= XLP9XX_I2C_CMD_STOP;\n\n\txlp9xx_write_i2c_reg(priv, XLP9XX_I2C_CMD, cmd);\n\n\ttimeleft = msecs_to_jiffies(XLP9XX_I2C_TIMEOUT_MS);\n\ttimeleft = wait_for_completion_timeout(&priv->msg_complete, timeleft);\n\n\tif (priv->msg_err & XLP9XX_I2C_INTEN_BUSERR) {\n\t\tdev_dbg(priv->dev, \"transfer error %x!\\n\", priv->msg_err);\n\t\txlp9xx_write_i2c_reg(priv, XLP9XX_I2C_CMD, XLP9XX_I2C_CMD_STOP);\n\t\treturn -EIO;\n\t} else if (priv->msg_err & XLP9XX_I2C_INTEN_NACKADDR) {\n\t\treturn -ENXIO;\n\t}\n\n\tif (timeleft == 0) {\n\t\tdev_dbg(priv->dev, \"i2c transfer timed out!\\n\");\n\t\txlp9xx_i2c_init(priv);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\t \n\tif (msg->flags & I2C_M_RECV_LEN) {\n\t\tif (!priv->msg_len)\n\t\t\treturn -EPROTO;\n\t\tmsg->len = priv->msg_len;\n\t}\n\treturn 0;\n}\n\nstatic int xlp9xx_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs,\n\t\t\t   int num)\n{\n\tint i, ret;\n\tstruct xlp9xx_i2c_dev *priv = i2c_get_adapdata(adap);\n\n\tret = xlp9xx_i2c_check_bus_status(priv);\n\tif (ret) {\n\t\txlp9xx_i2c_init(priv);\n\t\tret = xlp9xx_i2c_check_bus_status(priv);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < num; i++) {\n\t\tret = xlp9xx_i2c_xfer_msg(priv, &msgs[i], i == num - 1);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t}\n\n\treturn num;\n}\n\nstatic u32 xlp9xx_i2c_functionality(struct i2c_adapter *adapter)\n{\n\treturn I2C_FUNC_SMBUS_EMUL | I2C_FUNC_SMBUS_READ_BLOCK_DATA |\n\t\t\tI2C_FUNC_I2C | I2C_FUNC_10BIT_ADDR;\n}\n\nstatic const struct i2c_algorithm xlp9xx_i2c_algo = {\n\t.master_xfer = xlp9xx_i2c_xfer,\n\t.functionality = xlp9xx_i2c_functionality,\n};\n\nstatic int xlp9xx_i2c_get_frequency(struct platform_device *pdev,\n\t\t\t\t    struct xlp9xx_i2c_dev *priv)\n{\n\tstruct clk *clk;\n\tu32 freq;\n\tint err;\n\n\tclk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(clk)) {\n\t\tpriv->ip_clk_hz = XLP9XX_I2C_IP_CLK_FREQ;\n\t\tdev_dbg(&pdev->dev, \"using default input frequency %u\\n\",\n\t\t\tpriv->ip_clk_hz);\n\t} else {\n\t\tpriv->ip_clk_hz = clk_get_rate(clk);\n\t}\n\n\terr = device_property_read_u32(&pdev->dev, \"clock-frequency\", &freq);\n\tif (err) {\n\t\tfreq = I2C_MAX_STANDARD_MODE_FREQ;\n\t\tdev_dbg(&pdev->dev, \"using default frequency %u\\n\", freq);\n\t} else if (freq == 0 || freq > I2C_MAX_FAST_MODE_FREQ) {\n\t\tdev_warn(&pdev->dev, \"invalid frequency %u, using default\\n\",\n\t\t\t freq);\n\t\tfreq = I2C_MAX_STANDARD_MODE_FREQ;\n\t}\n\tpriv->clk_hz = freq;\n\n\treturn 0;\n}\n\nstatic int xlp9xx_i2c_smbus_setup(struct xlp9xx_i2c_dev *priv,\n\t\t\t\t  struct platform_device *pdev)\n{\n\tstruct i2c_client *ara;\n\n\tif (!priv->alert_data.irq)\n\t\treturn -EINVAL;\n\n\tara = i2c_new_smbus_alert_device(&priv->adapter, &priv->alert_data);\n\tif (IS_ERR(ara))\n\t\treturn PTR_ERR(ara);\n\n\tpriv->ara = ara;\n\n\treturn 0;\n}\n\nstatic int xlp9xx_i2c_probe(struct platform_device *pdev)\n{\n\tstruct xlp9xx_i2c_dev *priv;\n\tint err = 0;\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(priv->base))\n\t\treturn PTR_ERR(priv->base);\n\n\tpriv->irq = platform_get_irq(pdev, 0);\n\tif (priv->irq < 0)\n\t\treturn priv->irq;\n\t \n\tpriv->alert_data.irq = platform_get_irq(pdev, 1);\n\tif (priv->alert_data.irq <= 0)\n\t\tpriv->alert_data.irq = 0;\n\n\txlp9xx_i2c_get_frequency(pdev, priv);\n\txlp9xx_i2c_init(priv);\n\n\terr = devm_request_irq(&pdev->dev, priv->irq, xlp9xx_i2c_isr, 0,\n\t\t\t       pdev->name, priv);\n\tif (err)\n\t\treturn dev_err_probe(&pdev->dev, err, \"IRQ request failed!\\n\");\n\n\tinit_completion(&priv->msg_complete);\n\tpriv->adapter.dev.parent = &pdev->dev;\n\tpriv->adapter.algo = &xlp9xx_i2c_algo;\n\tpriv->adapter.class = I2C_CLASS_HWMON;\n\tACPI_COMPANION_SET(&priv->adapter.dev, ACPI_COMPANION(&pdev->dev));\n\tpriv->adapter.dev.of_node = pdev->dev.of_node;\n\tpriv->dev = &pdev->dev;\n\n\tsnprintf(priv->adapter.name, sizeof(priv->adapter.name), \"xlp9xx-i2c\");\n\ti2c_set_adapdata(&priv->adapter, priv);\n\n\terr = i2c_add_adapter(&priv->adapter);\n\tif (err)\n\t\treturn err;\n\n\terr = xlp9xx_i2c_smbus_setup(priv, pdev);\n\tif (err)\n\t\tdev_dbg(&pdev->dev, \"No active SMBus alert %d\\n\", err);\n\n\tplatform_set_drvdata(pdev, priv);\n\tdev_dbg(&pdev->dev, \"I2C bus:%d added\\n\", priv->adapter.nr);\n\n\treturn 0;\n}\n\nstatic void xlp9xx_i2c_remove(struct platform_device *pdev)\n{\n\tstruct xlp9xx_i2c_dev *priv;\n\n\tpriv = platform_get_drvdata(pdev);\n\txlp9xx_write_i2c_reg(priv, XLP9XX_I2C_INTEN, 0);\n\tsynchronize_irq(priv->irq);\n\ti2c_del_adapter(&priv->adapter);\n\txlp9xx_write_i2c_reg(priv, XLP9XX_I2C_CTRL, 0);\n}\n\n#ifdef CONFIG_ACPI\nstatic const struct acpi_device_id xlp9xx_i2c_acpi_ids[] = {\n\t{\"BRCM9007\", 0},\n\t{\"CAV9007\",  0},\n\t{}\n};\nMODULE_DEVICE_TABLE(acpi, xlp9xx_i2c_acpi_ids);\n#endif\n\nstatic struct platform_driver xlp9xx_i2c_driver = {\n\t.probe = xlp9xx_i2c_probe,\n\t.remove_new = xlp9xx_i2c_remove,\n\t.driver = {\n\t\t.name = \"xlp9xx-i2c\",\n\t\t.acpi_match_table = ACPI_PTR(xlp9xx_i2c_acpi_ids),\n\t},\n};\n\nmodule_platform_driver(xlp9xx_i2c_driver);\n\nMODULE_AUTHOR(\"Subhendu Sekhar Behera <sbehera@broadcom.com>\");\nMODULE_DESCRIPTION(\"XLP9XX/5XX I2C Bus Controller Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}