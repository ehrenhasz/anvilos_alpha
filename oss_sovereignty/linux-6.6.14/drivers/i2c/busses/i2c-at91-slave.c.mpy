{
  "module_name": "i2c-at91-slave.c",
  "hash_id": "041153873dbf09ac685b12d1bcc0155941400d0bce6a20aa5d4a32d559b7470e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-at91-slave.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/pm_runtime.h>\n\n#include \"i2c-at91.h\"\n\nstatic irqreturn_t atmel_twi_interrupt_slave(int irq, void *dev_id)\n{\n\tstruct at91_twi_dev *dev = dev_id;\n\tconst unsigned status = at91_twi_read(dev, AT91_TWI_SR);\n\tconst unsigned irqstatus = status & at91_twi_read(dev, AT91_TWI_IMR);\n\tu8 value;\n\n\tif (!irqstatus)\n\t\treturn IRQ_NONE;\n\n\t \n\tif (irqstatus & AT91_TWI_SVACC) {\n\t\tif (status & AT91_TWI_SVREAD) {\n\t\t\ti2c_slave_event(dev->slave,\n\t\t\t\t\tI2C_SLAVE_READ_REQUESTED, &value);\n\t\t\twriteb_relaxed(value, dev->base + AT91_TWI_THR);\n\t\t\tat91_twi_write(dev, AT91_TWI_IER,\n\t\t\t\t       AT91_TWI_TXRDY | AT91_TWI_EOSACC);\n\t\t} else {\n\t\t\ti2c_slave_event(dev->slave,\n\t\t\t\t\tI2C_SLAVE_WRITE_REQUESTED, &value);\n\t\t\tat91_twi_write(dev, AT91_TWI_IER,\n\t\t\t\t       AT91_TWI_RXRDY | AT91_TWI_EOSACC);\n\t\t}\n\t\tat91_twi_write(dev, AT91_TWI_IDR, AT91_TWI_SVACC);\n\t}\n\n\t \n\tif (irqstatus & AT91_TWI_TXRDY) {\n\t\ti2c_slave_event(dev->slave, I2C_SLAVE_READ_PROCESSED, &value);\n\t\twriteb_relaxed(value, dev->base + AT91_TWI_THR);\n\t}\n\n\t \n\tif (irqstatus & AT91_TWI_RXRDY) {\n\t\tvalue = readb_relaxed(dev->base + AT91_TWI_RHR);\n\t\ti2c_slave_event(dev->slave, I2C_SLAVE_WRITE_RECEIVED, &value);\n\t}\n\n\t \n\tif (irqstatus & AT91_TWI_EOSACC) {\n\t\tat91_twi_write(dev, AT91_TWI_IDR,\n\t\t\t       AT91_TWI_TXRDY | AT91_TWI_RXRDY | AT91_TWI_EOSACC);\n\t\tat91_twi_write(dev, AT91_TWI_IER, AT91_TWI_SVACC);\n\t\ti2c_slave_event(dev->slave, I2C_SLAVE_STOP, &value);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int at91_reg_slave(struct i2c_client *slave)\n{\n\tstruct at91_twi_dev *dev = i2c_get_adapdata(slave->adapter);\n\n\tif (dev->slave)\n\t\treturn -EBUSY;\n\n\tif (slave->flags & I2C_CLIENT_TEN)\n\t\treturn -EAFNOSUPPORT;\n\n\t \n\tpm_runtime_get_sync(dev->dev);\n\n\tdev->slave = slave;\n\tdev->smr = AT91_TWI_SMR_SADR(slave->addr);\n\n\tat91_init_twi_bus(dev);\n\tat91_twi_write(dev, AT91_TWI_IER, AT91_TWI_SVACC);\n\n\tdev_info(dev->dev, \"entered slave mode (ADR=%d)\\n\", slave->addr);\n\n\treturn 0;\n}\n\nstatic int at91_unreg_slave(struct i2c_client *slave)\n{\n\tstruct at91_twi_dev *dev = i2c_get_adapdata(slave->adapter);\n\n\tWARN_ON(!dev->slave);\n\n\tdev_info(dev->dev, \"leaving slave mode\\n\");\n\n\tdev->slave = NULL;\n\tdev->smr = 0;\n\n\tat91_init_twi_bus(dev);\n\n\tpm_runtime_put(dev->dev);\n\n\treturn 0;\n}\n\nstatic u32 at91_twi_func(struct i2c_adapter *adapter)\n{\n\treturn I2C_FUNC_SLAVE | I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL\n\t\t| I2C_FUNC_SMBUS_READ_BLOCK_DATA;\n}\n\nstatic const struct i2c_algorithm at91_twi_algorithm_slave = {\n\t.reg_slave\t= at91_reg_slave,\n\t.unreg_slave\t= at91_unreg_slave,\n\t.functionality\t= at91_twi_func,\n};\n\nint at91_twi_probe_slave(struct platform_device *pdev,\n\t\t\t u32 phy_addr, struct at91_twi_dev *dev)\n{\n\tint rc;\n\n\trc = devm_request_irq(&pdev->dev, dev->irq, atmel_twi_interrupt_slave,\n\t\t\t      0, dev_name(dev->dev), dev);\n\tif (rc) {\n\t\tdev_err(dev->dev, \"Cannot get irq %d: %d\\n\", dev->irq, rc);\n\t\treturn rc;\n\t}\n\n\tdev->adapter.algo = &at91_twi_algorithm_slave;\n\n\treturn 0;\n}\n\nvoid at91_init_twi_bus_slave(struct at91_twi_dev *dev)\n{\n\tat91_twi_write(dev, AT91_TWI_CR, AT91_TWI_MSDIS);\n\tif (dev->slave_detected && dev->smr) {\n\t\tat91_twi_write(dev, AT91_TWI_SMR, dev->smr);\n\t\tat91_twi_write(dev, AT91_TWI_CR, AT91_TWI_SVEN);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}