{
  "module_name": "i2c-stm32f4.c",
  "hash_id": "b91a999c79a731036f273eba411cfceb8d476c9219072f0a8b857495a60dece6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-stm32f4.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/module.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/reset.h>\n\n#include \"i2c-stm32.h\"\n\n \n#define STM32F4_I2C_CR1\t\t\t0x00\n#define STM32F4_I2C_CR2\t\t\t0x04\n#define STM32F4_I2C_DR\t\t\t0x10\n#define STM32F4_I2C_SR1\t\t\t0x14\n#define STM32F4_I2C_SR2\t\t\t0x18\n#define STM32F4_I2C_CCR\t\t\t0x1C\n#define STM32F4_I2C_TRISE\t\t0x20\n#define STM32F4_I2C_FLTR\t\t0x24\n\n \n#define STM32F4_I2C_CR1_POS\t\tBIT(11)\n#define STM32F4_I2C_CR1_ACK\t\tBIT(10)\n#define STM32F4_I2C_CR1_STOP\t\tBIT(9)\n#define STM32F4_I2C_CR1_START\t\tBIT(8)\n#define STM32F4_I2C_CR1_PE\t\tBIT(0)\n\n \n#define STM32F4_I2C_CR2_FREQ_MASK\tGENMASK(5, 0)\n#define STM32F4_I2C_CR2_FREQ(n)\t\t((n) & STM32F4_I2C_CR2_FREQ_MASK)\n#define STM32F4_I2C_CR2_ITBUFEN\t\tBIT(10)\n#define STM32F4_I2C_CR2_ITEVTEN\t\tBIT(9)\n#define STM32F4_I2C_CR2_ITERREN\t\tBIT(8)\n#define STM32F4_I2C_CR2_IRQ_MASK\t(STM32F4_I2C_CR2_ITBUFEN | \\\n\t\t\t\t\t STM32F4_I2C_CR2_ITEVTEN | \\\n\t\t\t\t\t STM32F4_I2C_CR2_ITERREN)\n\n \n#define STM32F4_I2C_SR1_AF\t\tBIT(10)\n#define STM32F4_I2C_SR1_ARLO\t\tBIT(9)\n#define STM32F4_I2C_SR1_BERR\t\tBIT(8)\n#define STM32F4_I2C_SR1_TXE\t\tBIT(7)\n#define STM32F4_I2C_SR1_RXNE\t\tBIT(6)\n#define STM32F4_I2C_SR1_BTF\t\tBIT(2)\n#define STM32F4_I2C_SR1_ADDR\t\tBIT(1)\n#define STM32F4_I2C_SR1_SB\t\tBIT(0)\n#define STM32F4_I2C_SR1_ITEVTEN_MASK\t(STM32F4_I2C_SR1_BTF | \\\n\t\t\t\t\t STM32F4_I2C_SR1_ADDR | \\\n\t\t\t\t\t STM32F4_I2C_SR1_SB)\n#define STM32F4_I2C_SR1_ITBUFEN_MASK\t(STM32F4_I2C_SR1_TXE | \\\n\t\t\t\t\t STM32F4_I2C_SR1_RXNE)\n#define STM32F4_I2C_SR1_ITERREN_MASK\t(STM32F4_I2C_SR1_AF | \\\n\t\t\t\t\t STM32F4_I2C_SR1_ARLO | \\\n\t\t\t\t\t STM32F4_I2C_SR1_BERR)\n\n \n#define STM32F4_I2C_SR2_BUSY\t\tBIT(1)\n\n \n#define STM32F4_I2C_CCR_CCR_MASK\tGENMASK(11, 0)\n#define STM32F4_I2C_CCR_CCR(n)\t\t((n) & STM32F4_I2C_CCR_CCR_MASK)\n#define STM32F4_I2C_CCR_FS\t\tBIT(15)\n#define STM32F4_I2C_CCR_DUTY\t\tBIT(14)\n\n \n#define STM32F4_I2C_TRISE_VALUE_MASK\tGENMASK(5, 0)\n#define STM32F4_I2C_TRISE_VALUE(n)\t((n) & STM32F4_I2C_TRISE_VALUE_MASK)\n\n#define STM32F4_I2C_MIN_STANDARD_FREQ\t2U\n#define STM32F4_I2C_MIN_FAST_FREQ\t6U\n#define STM32F4_I2C_MAX_FREQ\t\t46U\n#define HZ_TO_MHZ\t\t\t1000000\n\n \nstruct stm32f4_i2c_msg {\n\tu8 addr;\n\tu32 count;\n\tu8 *buf;\n\tint result;\n\tbool stop;\n};\n\n \nstruct stm32f4_i2c_dev {\n\tstruct i2c_adapter adap;\n\tstruct device *dev;\n\tvoid __iomem *base;\n\tstruct completion complete;\n\tstruct clk *clk;\n\tint speed;\n\tint parent_rate;\n\tstruct stm32f4_i2c_msg msg;\n};\n\nstatic inline void stm32f4_i2c_set_bits(void __iomem *reg, u32 mask)\n{\n\twritel_relaxed(readl_relaxed(reg) | mask, reg);\n}\n\nstatic inline void stm32f4_i2c_clr_bits(void __iomem *reg, u32 mask)\n{\n\twritel_relaxed(readl_relaxed(reg) & ~mask, reg);\n}\n\nstatic void stm32f4_i2c_disable_irq(struct stm32f4_i2c_dev *i2c_dev)\n{\n\tvoid __iomem *reg = i2c_dev->base + STM32F4_I2C_CR2;\n\n\tstm32f4_i2c_clr_bits(reg, STM32F4_I2C_CR2_IRQ_MASK);\n}\n\nstatic int stm32f4_i2c_set_periph_clk_freq(struct stm32f4_i2c_dev *i2c_dev)\n{\n\tu32 freq;\n\tu32 cr2 = 0;\n\n\ti2c_dev->parent_rate = clk_get_rate(i2c_dev->clk);\n\tfreq = DIV_ROUND_UP(i2c_dev->parent_rate, HZ_TO_MHZ);\n\n\tif (i2c_dev->speed == STM32_I2C_SPEED_STANDARD) {\n\t\t \n\t\tif (freq < STM32F4_I2C_MIN_STANDARD_FREQ ||\n\t\t    freq > STM32F4_I2C_MAX_FREQ) {\n\t\t\tdev_err(i2c_dev->dev,\n\t\t\t\t\"bad parent clk freq for standard mode\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\t \n\t\tif (freq < STM32F4_I2C_MIN_FAST_FREQ ||\n\t\t    freq > STM32F4_I2C_MAX_FREQ) {\n\t\t\tdev_err(i2c_dev->dev,\n\t\t\t\t\"bad parent clk freq for fast mode\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tcr2 |= STM32F4_I2C_CR2_FREQ(freq);\n\twritel_relaxed(cr2, i2c_dev->base + STM32F4_I2C_CR2);\n\n\treturn 0;\n}\n\nstatic void stm32f4_i2c_set_rise_time(struct stm32f4_i2c_dev *i2c_dev)\n{\n\tu32 freq = DIV_ROUND_UP(i2c_dev->parent_rate, HZ_TO_MHZ);\n\tu32 trise;\n\n\t \n\tif (i2c_dev->speed == STM32_I2C_SPEED_STANDARD)\n\t\ttrise = freq + 1;\n\telse\n\t\ttrise = freq * 3 / 10 + 1;\n\n\twritel_relaxed(STM32F4_I2C_TRISE_VALUE(trise),\n\t\t       i2c_dev->base + STM32F4_I2C_TRISE);\n}\n\nstatic void stm32f4_i2c_set_speed_mode(struct stm32f4_i2c_dev *i2c_dev)\n{\n\tu32 val;\n\tu32 ccr = 0;\n\n\tif (i2c_dev->speed == STM32_I2C_SPEED_STANDARD) {\n\t\t \n\t\tval = i2c_dev->parent_rate / (I2C_MAX_STANDARD_MODE_FREQ * 2);\n\t} else {\n\t\t \n\t\tval = DIV_ROUND_UP(i2c_dev->parent_rate, I2C_MAX_FAST_MODE_FREQ * 3);\n\n\t\t \n\t\tccr |= STM32F4_I2C_CCR_FS;\n\t}\n\n\tccr |= STM32F4_I2C_CCR_CCR(val);\n\twritel_relaxed(ccr, i2c_dev->base + STM32F4_I2C_CCR);\n}\n\n \nstatic int stm32f4_i2c_hw_config(struct stm32f4_i2c_dev *i2c_dev)\n{\n\tint ret;\n\n\tret = stm32f4_i2c_set_periph_clk_freq(i2c_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tstm32f4_i2c_set_rise_time(i2c_dev);\n\n\tstm32f4_i2c_set_speed_mode(i2c_dev);\n\n\t \n\twritel_relaxed(STM32F4_I2C_CR1_PE, i2c_dev->base + STM32F4_I2C_CR1);\n\n\treturn 0;\n}\n\nstatic int stm32f4_i2c_wait_free_bus(struct stm32f4_i2c_dev *i2c_dev)\n{\n\tu32 status;\n\tint ret;\n\n\tret = readl_relaxed_poll_timeout(i2c_dev->base + STM32F4_I2C_SR2,\n\t\t\t\t\t status,\n\t\t\t\t\t !(status & STM32F4_I2C_SR2_BUSY),\n\t\t\t\t\t 10, 1000);\n\tif (ret) {\n\t\tdev_dbg(i2c_dev->dev, \"bus not free\\n\");\n\t\tret = -EBUSY;\n\t}\n\n\treturn ret;\n}\n\n \nstatic void stm32f4_i2c_write_byte(struct stm32f4_i2c_dev *i2c_dev, u8 byte)\n{\n\twritel_relaxed(byte, i2c_dev->base + STM32F4_I2C_DR);\n}\n\n \nstatic void stm32f4_i2c_write_msg(struct stm32f4_i2c_dev *i2c_dev)\n{\n\tstruct stm32f4_i2c_msg *msg = &i2c_dev->msg;\n\n\tstm32f4_i2c_write_byte(i2c_dev, *msg->buf++);\n\tmsg->count--;\n}\n\nstatic void stm32f4_i2c_read_msg(struct stm32f4_i2c_dev *i2c_dev)\n{\n\tstruct stm32f4_i2c_msg *msg = &i2c_dev->msg;\n\tu32 rbuf;\n\n\trbuf = readl_relaxed(i2c_dev->base + STM32F4_I2C_DR);\n\t*msg->buf++ = rbuf;\n\tmsg->count--;\n}\n\nstatic void stm32f4_i2c_terminate_xfer(struct stm32f4_i2c_dev *i2c_dev)\n{\n\tstruct stm32f4_i2c_msg *msg = &i2c_dev->msg;\n\tvoid __iomem *reg;\n\n\tstm32f4_i2c_disable_irq(i2c_dev);\n\n\treg = i2c_dev->base + STM32F4_I2C_CR1;\n\tif (msg->stop)\n\t\tstm32f4_i2c_set_bits(reg, STM32F4_I2C_CR1_STOP);\n\telse\n\t\tstm32f4_i2c_set_bits(reg, STM32F4_I2C_CR1_START);\n\n\tcomplete(&i2c_dev->complete);\n}\n\n \nstatic void stm32f4_i2c_handle_write(struct stm32f4_i2c_dev *i2c_dev)\n{\n\tstruct stm32f4_i2c_msg *msg = &i2c_dev->msg;\n\tvoid __iomem *reg = i2c_dev->base + STM32F4_I2C_CR2;\n\n\tif (msg->count) {\n\t\tstm32f4_i2c_write_msg(i2c_dev);\n\t\tif (!msg->count) {\n\t\t\t \n\t\t\tstm32f4_i2c_clr_bits(reg, STM32F4_I2C_CR2_ITBUFEN);\n\t\t}\n\t} else {\n\t\tstm32f4_i2c_terminate_xfer(i2c_dev);\n\t}\n}\n\n \nstatic void stm32f4_i2c_handle_read(struct stm32f4_i2c_dev *i2c_dev)\n{\n\tstruct stm32f4_i2c_msg *msg = &i2c_dev->msg;\n\tvoid __iomem *reg = i2c_dev->base + STM32F4_I2C_CR2;\n\n\tswitch (msg->count) {\n\tcase 1:\n\t\tstm32f4_i2c_disable_irq(i2c_dev);\n\t\tstm32f4_i2c_read_msg(i2c_dev);\n\t\tcomplete(&i2c_dev->complete);\n\t\tbreak;\n\t \n\tcase 2:\n\tcase 3:\n\t\tstm32f4_i2c_clr_bits(reg, STM32F4_I2C_CR2_ITBUFEN);\n\t\tbreak;\n\t \n\tdefault:\n\t\tstm32f4_i2c_read_msg(i2c_dev);\n\t}\n}\n\n \nstatic void stm32f4_i2c_handle_rx_done(struct stm32f4_i2c_dev *i2c_dev)\n{\n\tstruct stm32f4_i2c_msg *msg = &i2c_dev->msg;\n\tvoid __iomem *reg;\n\tu32 mask;\n\tint i;\n\n\tswitch (msg->count) {\n\tcase 2:\n\t\t \n\t\treg = i2c_dev->base + STM32F4_I2C_CR1;\n\t\tif (msg->stop)\n\t\t\tstm32f4_i2c_set_bits(reg, STM32F4_I2C_CR1_STOP);\n\t\telse\n\t\t\tstm32f4_i2c_set_bits(reg, STM32F4_I2C_CR1_START);\n\n\t\tfor (i = 2; i > 0; i--)\n\t\t\tstm32f4_i2c_read_msg(i2c_dev);\n\n\t\treg = i2c_dev->base + STM32F4_I2C_CR2;\n\t\tmask = STM32F4_I2C_CR2_ITEVTEN | STM32F4_I2C_CR2_ITERREN;\n\t\tstm32f4_i2c_clr_bits(reg, mask);\n\n\t\tcomplete(&i2c_dev->complete);\n\t\tbreak;\n\tcase 3:\n\t\t \n\t\treg = i2c_dev->base + STM32F4_I2C_CR1;\n\t\tstm32f4_i2c_clr_bits(reg, STM32F4_I2C_CR1_ACK);\n\t\tstm32f4_i2c_read_msg(i2c_dev);\n\t\tbreak;\n\tdefault:\n\t\tstm32f4_i2c_read_msg(i2c_dev);\n\t}\n}\n\n \nstatic void stm32f4_i2c_handle_rx_addr(struct stm32f4_i2c_dev *i2c_dev)\n{\n\tstruct stm32f4_i2c_msg *msg = &i2c_dev->msg;\n\tu32 cr1;\n\n\tswitch (msg->count) {\n\tcase 0:\n\t\tstm32f4_i2c_terminate_xfer(i2c_dev);\n\n\t\t \n\t\treadl_relaxed(i2c_dev->base + STM32F4_I2C_SR2);\n\t\tbreak;\n\tcase 1:\n\t\t \n\t\tcr1 = readl_relaxed(i2c_dev->base + STM32F4_I2C_CR1);\n\t\tcr1 &= ~(STM32F4_I2C_CR1_ACK | STM32F4_I2C_CR1_POS);\n\t\twritel_relaxed(cr1, i2c_dev->base + STM32F4_I2C_CR1);\n\n\t\treadl_relaxed(i2c_dev->base + STM32F4_I2C_SR2);\n\n\t\tif (msg->stop)\n\t\t\tcr1 |= STM32F4_I2C_CR1_STOP;\n\t\telse\n\t\t\tcr1 |= STM32F4_I2C_CR1_START;\n\t\twritel_relaxed(cr1, i2c_dev->base + STM32F4_I2C_CR1);\n\t\tbreak;\n\tcase 2:\n\t\t \n\t\tcr1 = readl_relaxed(i2c_dev->base + STM32F4_I2C_CR1);\n\t\tcr1 &= ~STM32F4_I2C_CR1_ACK;\n\t\tcr1 |= STM32F4_I2C_CR1_POS;\n\t\twritel_relaxed(cr1, i2c_dev->base + STM32F4_I2C_CR1);\n\n\t\treadl_relaxed(i2c_dev->base + STM32F4_I2C_SR2);\n\t\tbreak;\n\n\tdefault:\n\t\t \n\t\tcr1 = readl_relaxed(i2c_dev->base + STM32F4_I2C_CR1);\n\t\tcr1 |= STM32F4_I2C_CR1_ACK;\n\t\tcr1 &= ~STM32F4_I2C_CR1_POS;\n\t\twritel_relaxed(cr1, i2c_dev->base + STM32F4_I2C_CR1);\n\n\t\treadl_relaxed(i2c_dev->base + STM32F4_I2C_SR2);\n\t\tbreak;\n\t}\n}\n\n \nstatic irqreturn_t stm32f4_i2c_isr_event(int irq, void *data)\n{\n\tstruct stm32f4_i2c_dev *i2c_dev = data;\n\tstruct stm32f4_i2c_msg *msg = &i2c_dev->msg;\n\tu32 possible_status = STM32F4_I2C_SR1_ITEVTEN_MASK;\n\tu32 status, ien, event, cr2;\n\n\tcr2 = readl_relaxed(i2c_dev->base + STM32F4_I2C_CR2);\n\tien = cr2 & STM32F4_I2C_CR2_IRQ_MASK;\n\n\t \n\tif (ien & STM32F4_I2C_CR2_ITBUFEN)\n\t\tpossible_status |= STM32F4_I2C_SR1_ITBUFEN_MASK;\n\n\tstatus = readl_relaxed(i2c_dev->base + STM32F4_I2C_SR1);\n\tevent = status & possible_status;\n\tif (!event) {\n\t\tdev_dbg(i2c_dev->dev,\n\t\t\t\"spurious evt irq (status=0x%08x, ien=0x%08x)\\n\",\n\t\t\tstatus, ien);\n\t\treturn IRQ_NONE;\n\t}\n\n\t \n\tif (event & STM32F4_I2C_SR1_SB)\n\t\tstm32f4_i2c_write_byte(i2c_dev, msg->addr);\n\n\t \n\tif (event & STM32F4_I2C_SR1_ADDR) {\n\t\tif (msg->addr & I2C_M_RD)\n\t\t\tstm32f4_i2c_handle_rx_addr(i2c_dev);\n\t\telse\n\t\t\treadl_relaxed(i2c_dev->base + STM32F4_I2C_SR2);\n\n\t\t \n\t\tcr2 |= STM32F4_I2C_CR2_ITBUFEN;\n\t\twritel_relaxed(cr2, i2c_dev->base + STM32F4_I2C_CR2);\n\t}\n\n\t \n\tif ((event & STM32F4_I2C_SR1_TXE) && !(msg->addr & I2C_M_RD))\n\t\tstm32f4_i2c_handle_write(i2c_dev);\n\n\t \n\tif ((event & STM32F4_I2C_SR1_RXNE) && (msg->addr & I2C_M_RD))\n\t\tstm32f4_i2c_handle_read(i2c_dev);\n\n\t \n\tif (event & STM32F4_I2C_SR1_BTF) {\n\t\tif (msg->addr & I2C_M_RD)\n\t\t\tstm32f4_i2c_handle_rx_done(i2c_dev);\n\t\telse\n\t\t\tstm32f4_i2c_handle_write(i2c_dev);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic irqreturn_t stm32f4_i2c_isr_error(int irq, void *data)\n{\n\tstruct stm32f4_i2c_dev *i2c_dev = data;\n\tstruct stm32f4_i2c_msg *msg = &i2c_dev->msg;\n\tvoid __iomem *reg;\n\tu32 status;\n\n\tstatus = readl_relaxed(i2c_dev->base + STM32F4_I2C_SR1);\n\n\t \n\tif (status & STM32F4_I2C_SR1_ARLO) {\n\t\tstatus &= ~STM32F4_I2C_SR1_ARLO;\n\t\twritel_relaxed(status, i2c_dev->base + STM32F4_I2C_SR1);\n\t\tmsg->result = -EAGAIN;\n\t}\n\n\t \n\tif (status & STM32F4_I2C_SR1_AF) {\n\t\tif (!(msg->addr & I2C_M_RD)) {\n\t\t\treg = i2c_dev->base + STM32F4_I2C_CR1;\n\t\t\tstm32f4_i2c_set_bits(reg, STM32F4_I2C_CR1_STOP);\n\t\t}\n\t\tstatus &= ~STM32F4_I2C_SR1_AF;\n\t\twritel_relaxed(status, i2c_dev->base + STM32F4_I2C_SR1);\n\t\tmsg->result = -EIO;\n\t}\n\n\t \n\tif (status & STM32F4_I2C_SR1_BERR) {\n\t\tstatus &= ~STM32F4_I2C_SR1_BERR;\n\t\twritel_relaxed(status, i2c_dev->base + STM32F4_I2C_SR1);\n\t\tmsg->result = -EIO;\n\t}\n\n\tstm32f4_i2c_disable_irq(i2c_dev);\n\tcomplete(&i2c_dev->complete);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic int stm32f4_i2c_xfer_msg(struct stm32f4_i2c_dev *i2c_dev,\n\t\t\t\tstruct i2c_msg *msg, bool is_first,\n\t\t\t\tbool is_last)\n{\n\tstruct stm32f4_i2c_msg *f4_msg = &i2c_dev->msg;\n\tvoid __iomem *reg = i2c_dev->base + STM32F4_I2C_CR1;\n\tunsigned long timeout;\n\tu32 mask;\n\tint ret;\n\n\tf4_msg->addr = i2c_8bit_addr_from_msg(msg);\n\tf4_msg->buf = msg->buf;\n\tf4_msg->count = msg->len;\n\tf4_msg->result = 0;\n\tf4_msg->stop = is_last;\n\n\treinit_completion(&i2c_dev->complete);\n\n\t \n\tmask = STM32F4_I2C_CR2_ITEVTEN | STM32F4_I2C_CR2_ITERREN;\n\tstm32f4_i2c_set_bits(i2c_dev->base + STM32F4_I2C_CR2, mask);\n\n\tif (is_first) {\n\t\tret = stm32f4_i2c_wait_free_bus(i2c_dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tstm32f4_i2c_set_bits(reg, STM32F4_I2C_CR1_START);\n\t}\n\n\ttimeout = wait_for_completion_timeout(&i2c_dev->complete,\n\t\t\t\t\t      i2c_dev->adap.timeout);\n\tret = f4_msg->result;\n\n\tif (!timeout)\n\t\tret = -ETIMEDOUT;\n\n\treturn ret;\n}\n\n \nstatic int stm32f4_i2c_xfer(struct i2c_adapter *i2c_adap, struct i2c_msg msgs[],\n\t\t\t    int num)\n{\n\tstruct stm32f4_i2c_dev *i2c_dev = i2c_get_adapdata(i2c_adap);\n\tint ret, i;\n\n\tret = clk_enable(i2c_dev->clk);\n\tif (ret) {\n\t\tdev_err(i2c_dev->dev, \"Failed to enable clock\\n\");\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < num && !ret; i++)\n\t\tret = stm32f4_i2c_xfer_msg(i2c_dev, &msgs[i], i == 0,\n\t\t\t\t\t   i == num - 1);\n\n\tclk_disable(i2c_dev->clk);\n\n\treturn (ret < 0) ? ret : num;\n}\n\nstatic u32 stm32f4_i2c_func(struct i2c_adapter *adap)\n{\n\treturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;\n}\n\nstatic const struct i2c_algorithm stm32f4_i2c_algo = {\n\t.master_xfer = stm32f4_i2c_xfer,\n\t.functionality = stm32f4_i2c_func,\n};\n\nstatic int stm32f4_i2c_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct stm32f4_i2c_dev *i2c_dev;\n\tstruct resource *res;\n\tu32 irq_event, irq_error, clk_rate;\n\tstruct i2c_adapter *adap;\n\tstruct reset_control *rst;\n\tint ret;\n\n\ti2c_dev = devm_kzalloc(&pdev->dev, sizeof(*i2c_dev), GFP_KERNEL);\n\tif (!i2c_dev)\n\t\treturn -ENOMEM;\n\n\ti2c_dev->base = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(i2c_dev->base))\n\t\treturn PTR_ERR(i2c_dev->base);\n\n\tirq_event = irq_of_parse_and_map(np, 0);\n\tif (!irq_event) {\n\t\tdev_err(&pdev->dev, \"IRQ event missing or invalid\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tirq_error = irq_of_parse_and_map(np, 1);\n\tif (!irq_error) {\n\t\tdev_err(&pdev->dev, \"IRQ error missing or invalid\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\ti2c_dev->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(i2c_dev->clk)) {\n\t\tdev_err(&pdev->dev, \"Error: Missing controller clock\\n\");\n\t\treturn PTR_ERR(i2c_dev->clk);\n\t}\n\tret = clk_prepare_enable(i2c_dev->clk);\n\tif (ret) {\n\t\tdev_err(i2c_dev->dev, \"Failed to prepare_enable clock\\n\");\n\t\treturn ret;\n\t}\n\n\trst = devm_reset_control_get_exclusive(&pdev->dev, NULL);\n\tif (IS_ERR(rst)) {\n\t\tret = dev_err_probe(&pdev->dev, PTR_ERR(rst),\n\t\t\t\t    \"Error: Missing reset ctrl\\n\");\n\t\tgoto clk_free;\n\t}\n\treset_control_assert(rst);\n\tudelay(2);\n\treset_control_deassert(rst);\n\n\ti2c_dev->speed = STM32_I2C_SPEED_STANDARD;\n\tret = of_property_read_u32(np, \"clock-frequency\", &clk_rate);\n\tif (!ret && clk_rate >= I2C_MAX_FAST_MODE_FREQ)\n\t\ti2c_dev->speed = STM32_I2C_SPEED_FAST;\n\n\ti2c_dev->dev = &pdev->dev;\n\n\tret = devm_request_irq(&pdev->dev, irq_event, stm32f4_i2c_isr_event, 0,\n\t\t\t       pdev->name, i2c_dev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed to request irq event %i\\n\",\n\t\t\tirq_event);\n\t\tgoto clk_free;\n\t}\n\n\tret = devm_request_irq(&pdev->dev, irq_error, stm32f4_i2c_isr_error, 0,\n\t\t\t       pdev->name, i2c_dev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed to request irq error %i\\n\",\n\t\t\tirq_error);\n\t\tgoto clk_free;\n\t}\n\n\tret = stm32f4_i2c_hw_config(i2c_dev);\n\tif (ret)\n\t\tgoto clk_free;\n\n\tadap = &i2c_dev->adap;\n\ti2c_set_adapdata(adap, i2c_dev);\n\tsnprintf(adap->name, sizeof(adap->name), \"STM32 I2C(%pa)\", &res->start);\n\tadap->owner = THIS_MODULE;\n\tadap->timeout = 2 * HZ;\n\tadap->retries = 0;\n\tadap->algo = &stm32f4_i2c_algo;\n\tadap->dev.parent = &pdev->dev;\n\tadap->dev.of_node = pdev->dev.of_node;\n\n\tinit_completion(&i2c_dev->complete);\n\n\tret = i2c_add_adapter(adap);\n\tif (ret)\n\t\tgoto clk_free;\n\n\tplatform_set_drvdata(pdev, i2c_dev);\n\n\tclk_disable(i2c_dev->clk);\n\n\tdev_info(i2c_dev->dev, \"STM32F4 I2C driver registered\\n\");\n\n\treturn 0;\n\nclk_free:\n\tclk_disable_unprepare(i2c_dev->clk);\n\treturn ret;\n}\n\nstatic void stm32f4_i2c_remove(struct platform_device *pdev)\n{\n\tstruct stm32f4_i2c_dev *i2c_dev = platform_get_drvdata(pdev);\n\n\ti2c_del_adapter(&i2c_dev->adap);\n\n\tclk_unprepare(i2c_dev->clk);\n}\n\nstatic const struct of_device_id stm32f4_i2c_match[] = {\n\t{ .compatible = \"st,stm32f4-i2c\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, stm32f4_i2c_match);\n\nstatic struct platform_driver stm32f4_i2c_driver = {\n\t.driver = {\n\t\t.name = \"stm32f4-i2c\",\n\t\t.of_match_table = stm32f4_i2c_match,\n\t},\n\t.probe = stm32f4_i2c_probe,\n\t.remove_new = stm32f4_i2c_remove,\n};\n\nmodule_platform_driver(stm32f4_i2c_driver);\n\nMODULE_AUTHOR(\"M'boumba Cedric Madianga <cedric.madianga@gmail.com>\");\nMODULE_DESCRIPTION(\"STMicroelectronics STM32F4 I2C driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}