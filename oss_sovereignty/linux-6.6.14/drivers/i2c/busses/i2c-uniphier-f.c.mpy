{
  "module_name": "i2c-uniphier-f.c",
  "hash_id": "5915fe951c2bae26fec195de54d67032bfcce9ecd16997ecf6712e4c3f0991ce",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-uniphier-f.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/i2c.h>\n#include <linux/iopoll.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n\n#define UNIPHIER_FI2C_CR\t0x00\t \n#define     UNIPHIER_FI2C_CR_MST\tBIT(3)\t \n#define     UNIPHIER_FI2C_CR_STA\tBIT(2)\t \n#define     UNIPHIER_FI2C_CR_STO\tBIT(1)\t \n#define     UNIPHIER_FI2C_CR_NACK\tBIT(0)\t \n#define UNIPHIER_FI2C_DTTX\t0x04\t \n#define     UNIPHIER_FI2C_DTTX_CMD\tBIT(8)\t \n#define     UNIPHIER_FI2C_DTTX_RD\tBIT(0)\t \n#define UNIPHIER_FI2C_DTRX\t0x04\t \n#define UNIPHIER_FI2C_SLAD\t0x0c\t \n#define UNIPHIER_FI2C_CYC\t0x10\t \n#define UNIPHIER_FI2C_LCTL\t0x14\t \n#define UNIPHIER_FI2C_SSUT\t0x18\t \n#define UNIPHIER_FI2C_DSUT\t0x1c\t \n#define UNIPHIER_FI2C_INT\t0x20\t \n#define UNIPHIER_FI2C_IE\t0x24\t \n#define UNIPHIER_FI2C_IC\t0x28\t \n#define     UNIPHIER_FI2C_INT_TE\tBIT(9)\t \n#define     UNIPHIER_FI2C_INT_RF\tBIT(8)\t \n#define     UNIPHIER_FI2C_INT_TC\tBIT(7)\t \n#define     UNIPHIER_FI2C_INT_RC\tBIT(6)\t \n#define     UNIPHIER_FI2C_INT_TB\tBIT(5)\t \n#define     UNIPHIER_FI2C_INT_RB\tBIT(4)\t \n#define     UNIPHIER_FI2C_INT_NA\tBIT(2)\t \n#define     UNIPHIER_FI2C_INT_AL\tBIT(1)\t \n#define UNIPHIER_FI2C_SR\t0x2c\t \n#define     UNIPHIER_FI2C_SR_DB\t\tBIT(12)\t \n#define     UNIPHIER_FI2C_SR_STS\tBIT(11)\t \n#define     UNIPHIER_FI2C_SR_BB\t\tBIT(8)\t \n#define     UNIPHIER_FI2C_SR_RFF\tBIT(3)\t \n#define     UNIPHIER_FI2C_SR_RNE\tBIT(2)\t \n#define     UNIPHIER_FI2C_SR_TNF\tBIT(1)\t \n#define     UNIPHIER_FI2C_SR_TFE\tBIT(0)\t \n#define UNIPHIER_FI2C_RST\t0x34\t \n#define     UNIPHIER_FI2C_RST_TBRST\tBIT(2)\t \n#define     UNIPHIER_FI2C_RST_RBRST\tBIT(1)\t \n#define     UNIPHIER_FI2C_RST_RST\tBIT(0)\t \n#define UNIPHIER_FI2C_BM\t0x38\t \n#define     UNIPHIER_FI2C_BM_SDAO\tBIT(3)\t \n#define     UNIPHIER_FI2C_BM_SDAS\tBIT(2)\t \n#define     UNIPHIER_FI2C_BM_SCLO\tBIT(1)\t \n#define     UNIPHIER_FI2C_BM_SCLS\tBIT(0)\t \n#define UNIPHIER_FI2C_NOISE\t0x3c\t \n#define UNIPHIER_FI2C_TBC\t0x40\t \n#define UNIPHIER_FI2C_RBC\t0x44\t \n#define UNIPHIER_FI2C_TBCM\t0x48\t \n#define UNIPHIER_FI2C_RBCM\t0x4c\t \n#define UNIPHIER_FI2C_BRST\t0x50\t \n#define     UNIPHIER_FI2C_BRST_FOEN\tBIT(1)\t \n#define     UNIPHIER_FI2C_BRST_RSCL\tBIT(0)\t \n\n#define UNIPHIER_FI2C_INT_FAULTS\t\\\n\t\t\t\t(UNIPHIER_FI2C_INT_NA | UNIPHIER_FI2C_INT_AL)\n#define UNIPHIER_FI2C_INT_STOP\t\t\\\n\t\t\t\t(UNIPHIER_FI2C_INT_TC | UNIPHIER_FI2C_INT_RC)\n\n#define UNIPHIER_FI2C_RD\t\tBIT(0)\n#define UNIPHIER_FI2C_STOP\t\tBIT(1)\n#define UNIPHIER_FI2C_MANUAL_NACK\tBIT(2)\n#define UNIPHIER_FI2C_BYTE_WISE\t\tBIT(3)\n#define UNIPHIER_FI2C_DEFER_STOP_COMP\tBIT(4)\n\n#define UNIPHIER_FI2C_FIFO_SIZE\t\t8\n\nstruct uniphier_fi2c_priv {\n\tstruct completion comp;\n\tstruct i2c_adapter adap;\n\tvoid __iomem *membase;\n\tstruct clk *clk;\n\tunsigned int len;\n\tu8 *buf;\n\tu32 enabled_irqs;\n\tint error;\n\tunsigned int flags;\n\tunsigned int busy_cnt;\n\tunsigned int clk_cycle;\n\tspinlock_t lock;\t \n};\n\nstatic void uniphier_fi2c_fill_txfifo(struct uniphier_fi2c_priv *priv,\n\t\t\t\t      bool first)\n{\n\tint fifo_space = UNIPHIER_FI2C_FIFO_SIZE;\n\n\t \n\tif (first)\n\t\tfifo_space--;\n\n\twhile (priv->len) {\n\t\tif (fifo_space-- <= 0)\n\t\t\tbreak;\n\n\t\twritel(*priv->buf++, priv->membase + UNIPHIER_FI2C_DTTX);\n\t\tpriv->len--;\n\t}\n}\n\nstatic void uniphier_fi2c_drain_rxfifo(struct uniphier_fi2c_priv *priv)\n{\n\tint fifo_left = priv->flags & UNIPHIER_FI2C_BYTE_WISE ?\n\t\t\t\t\t\t1 : UNIPHIER_FI2C_FIFO_SIZE;\n\n\twhile (priv->len) {\n\t\tif (fifo_left-- <= 0)\n\t\t\tbreak;\n\n\t\t*priv->buf++ = readl(priv->membase + UNIPHIER_FI2C_DTRX);\n\t\tpriv->len--;\n\t}\n}\n\nstatic void uniphier_fi2c_set_irqs(struct uniphier_fi2c_priv *priv)\n{\n\twritel(priv->enabled_irqs, priv->membase + UNIPHIER_FI2C_IE);\n}\n\nstatic void uniphier_fi2c_clear_irqs(struct uniphier_fi2c_priv *priv,\n\t\t\t\t     u32 mask)\n{\n\twritel(mask, priv->membase + UNIPHIER_FI2C_IC);\n}\n\nstatic void uniphier_fi2c_stop(struct uniphier_fi2c_priv *priv)\n{\n\tpriv->enabled_irqs |= UNIPHIER_FI2C_INT_STOP;\n\tuniphier_fi2c_set_irqs(priv);\n\twritel(UNIPHIER_FI2C_CR_MST | UNIPHIER_FI2C_CR_STO,\n\t       priv->membase + UNIPHIER_FI2C_CR);\n}\n\nstatic irqreturn_t uniphier_fi2c_interrupt(int irq, void *dev_id)\n{\n\tstruct uniphier_fi2c_priv *priv = dev_id;\n\tu32 irq_status;\n\n\tspin_lock(&priv->lock);\n\n\tirq_status = readl(priv->membase + UNIPHIER_FI2C_INT);\n\tirq_status &= priv->enabled_irqs;\n\n\tif (irq_status & UNIPHIER_FI2C_INT_STOP)\n\t\tgoto complete;\n\n\tif (unlikely(irq_status & UNIPHIER_FI2C_INT_AL)) {\n\t\tpriv->error = -EAGAIN;\n\t\tgoto complete;\n\t}\n\n\tif (unlikely(irq_status & UNIPHIER_FI2C_INT_NA)) {\n\t\tpriv->error = -ENXIO;\n\t\tif (priv->flags & UNIPHIER_FI2C_RD) {\n\t\t\t \n\t\t\tuniphier_fi2c_stop(priv);\n\t\t\tpriv->flags |= UNIPHIER_FI2C_DEFER_STOP_COMP;\n\t\t\tgoto complete;\n\t\t}\n\t\tgoto stop;\n\t}\n\n\tif (irq_status & UNIPHIER_FI2C_INT_TE) {\n\t\tif (!priv->len)\n\t\t\tgoto data_done;\n\n\t\tuniphier_fi2c_fill_txfifo(priv, false);\n\t\tgoto handled;\n\t}\n\n\tif (irq_status & (UNIPHIER_FI2C_INT_RF | UNIPHIER_FI2C_INT_RB)) {\n\t\tuniphier_fi2c_drain_rxfifo(priv);\n\t\t \n\t\tif (!priv->len && (irq_status & UNIPHIER_FI2C_INT_RB))\n\t\t\tgoto data_done;\n\n\t\tif (unlikely(priv->flags & UNIPHIER_FI2C_MANUAL_NACK)) {\n\t\t\tif (priv->len <= UNIPHIER_FI2C_FIFO_SIZE &&\n\t\t\t    !(priv->flags & UNIPHIER_FI2C_BYTE_WISE)) {\n\t\t\t\tpriv->enabled_irqs |= UNIPHIER_FI2C_INT_RB;\n\t\t\t\tuniphier_fi2c_set_irqs(priv);\n\t\t\t\tpriv->flags |= UNIPHIER_FI2C_BYTE_WISE;\n\t\t\t}\n\t\t\tif (priv->len <= 1)\n\t\t\t\twritel(UNIPHIER_FI2C_CR_MST |\n\t\t\t\t       UNIPHIER_FI2C_CR_NACK,\n\t\t\t\t       priv->membase + UNIPHIER_FI2C_CR);\n\t\t}\n\n\t\tgoto handled;\n\t}\n\n\tspin_unlock(&priv->lock);\n\n\treturn IRQ_NONE;\n\ndata_done:\n\tif (priv->flags & UNIPHIER_FI2C_STOP) {\nstop:\n\t\tuniphier_fi2c_stop(priv);\n\t} else {\ncomplete:\n\t\tpriv->enabled_irqs = 0;\n\t\tuniphier_fi2c_set_irqs(priv);\n\t\tcomplete(&priv->comp);\n\t}\n\nhandled:\n\t \n\tuniphier_fi2c_clear_irqs(priv, irq_status);\n\n\tspin_unlock(&priv->lock);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void uniphier_fi2c_tx_init(struct uniphier_fi2c_priv *priv, u16 addr,\n\t\t\t\t  bool repeat)\n{\n\tpriv->enabled_irqs |= UNIPHIER_FI2C_INT_TE;\n\tuniphier_fi2c_set_irqs(priv);\n\n\t \n\twritel(0, priv->membase + UNIPHIER_FI2C_TBC);\n\t \n\twritel(UNIPHIER_FI2C_DTTX_CMD | addr << 1,\n\t       priv->membase + UNIPHIER_FI2C_DTTX);\n\t \n\tif (!repeat)\n\t\tuniphier_fi2c_fill_txfifo(priv, true);\n}\n\nstatic void uniphier_fi2c_rx_init(struct uniphier_fi2c_priv *priv, u16 addr)\n{\n\tpriv->flags |= UNIPHIER_FI2C_RD;\n\n\tif (likely(priv->len < 256)) {\n\t\t \n\t\twritel(priv->len, priv->membase + UNIPHIER_FI2C_RBC);\n\t\tpriv->enabled_irqs |= UNIPHIER_FI2C_INT_RF |\n\t\t\t\t      UNIPHIER_FI2C_INT_RB;\n\t} else {\n\t\t \n\t\twritel(0, priv->membase + UNIPHIER_FI2C_RBC);\n\t\tpriv->flags |= UNIPHIER_FI2C_MANUAL_NACK;\n\t\tpriv->enabled_irqs |= UNIPHIER_FI2C_INT_RF;\n\t}\n\n\tuniphier_fi2c_set_irqs(priv);\n\n\t \n\twritel(UNIPHIER_FI2C_DTTX_CMD | UNIPHIER_FI2C_DTTX_RD | addr << 1,\n\t       priv->membase + UNIPHIER_FI2C_DTTX);\n}\n\nstatic void uniphier_fi2c_reset(struct uniphier_fi2c_priv *priv)\n{\n\twritel(UNIPHIER_FI2C_RST_RST, priv->membase + UNIPHIER_FI2C_RST);\n}\n\nstatic void uniphier_fi2c_prepare_operation(struct uniphier_fi2c_priv *priv)\n{\n\twritel(UNIPHIER_FI2C_BRST_FOEN | UNIPHIER_FI2C_BRST_RSCL,\n\t       priv->membase + UNIPHIER_FI2C_BRST);\n}\n\nstatic void uniphier_fi2c_recover(struct uniphier_fi2c_priv *priv)\n{\n\tuniphier_fi2c_reset(priv);\n\ti2c_recover_bus(&priv->adap);\n}\n\nstatic int uniphier_fi2c_master_xfer_one(struct i2c_adapter *adap,\n\t\t\t\t\t struct i2c_msg *msg, bool repeat,\n\t\t\t\t\t bool stop)\n{\n\tstruct uniphier_fi2c_priv *priv = i2c_get_adapdata(adap);\n\tbool is_read = msg->flags & I2C_M_RD;\n\tunsigned long time_left, flags;\n\n\tpriv->len = msg->len;\n\tpriv->buf = msg->buf;\n\tpriv->enabled_irqs = UNIPHIER_FI2C_INT_FAULTS;\n\tpriv->error = 0;\n\tpriv->flags = 0;\n\n\tif (stop)\n\t\tpriv->flags |= UNIPHIER_FI2C_STOP;\n\n\treinit_completion(&priv->comp);\n\tuniphier_fi2c_clear_irqs(priv, U32_MAX);\n\twritel(UNIPHIER_FI2C_RST_TBRST | UNIPHIER_FI2C_RST_RBRST,\n\t       priv->membase + UNIPHIER_FI2C_RST);\t \n\n\tspin_lock_irqsave(&priv->lock, flags);\n\n\tif (is_read)\n\t\tuniphier_fi2c_rx_init(priv, msg->addr);\n\telse\n\t\tuniphier_fi2c_tx_init(priv, msg->addr, repeat);\n\n\t \n\tif (!repeat)\n\t\twritel(UNIPHIER_FI2C_CR_MST | UNIPHIER_FI2C_CR_STA,\n\t\t       priv->membase + UNIPHIER_FI2C_CR);\n\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\ttime_left = wait_for_completion_timeout(&priv->comp, adap->timeout);\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\tpriv->enabled_irqs = 0;\n\tuniphier_fi2c_set_irqs(priv);\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\tif (!time_left) {\n\t\tdev_err(&adap->dev, \"transaction timeout.\\n\");\n\t\tuniphier_fi2c_recover(priv);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tif (unlikely(priv->flags & UNIPHIER_FI2C_DEFER_STOP_COMP)) {\n\t\tu32 status;\n\t\tint ret;\n\n\t\tret = readl_poll_timeout(priv->membase + UNIPHIER_FI2C_SR,\n\t\t\t\t\t status,\n\t\t\t\t\t (status & UNIPHIER_FI2C_SR_STS) &&\n\t\t\t\t\t !(status & UNIPHIER_FI2C_SR_BB),\n\t\t\t\t\t 1, 20);\n\t\tif (ret) {\n\t\t\tdev_err(&adap->dev,\n\t\t\t\t\"stop condition was not completed.\\n\");\n\t\t\tuniphier_fi2c_recover(priv);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn priv->error;\n}\n\nstatic int uniphier_fi2c_check_bus_busy(struct i2c_adapter *adap)\n{\n\tstruct uniphier_fi2c_priv *priv = i2c_get_adapdata(adap);\n\n\tif (readl(priv->membase + UNIPHIER_FI2C_SR) & UNIPHIER_FI2C_SR_DB) {\n\t\tif (priv->busy_cnt++ > 3) {\n\t\t\t \n\t\t\tuniphier_fi2c_recover(priv);\n\t\t\tpriv->busy_cnt = 0;\n\t\t}\n\n\t\treturn -EAGAIN;\n\t}\n\n\tpriv->busy_cnt = 0;\n\treturn 0;\n}\n\nstatic int uniphier_fi2c_master_xfer(struct i2c_adapter *adap,\n\t\t\t\t     struct i2c_msg *msgs, int num)\n{\n\tstruct i2c_msg *msg, *emsg = msgs + num;\n\tbool repeat = false;\n\tint ret;\n\n\tret = uniphier_fi2c_check_bus_busy(adap);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (msg = msgs; msg < emsg; msg++) {\n\t\t \n\t\tbool stop = (msg + 1 == emsg) || (msg->flags & I2C_M_STOP);\n\n\t\tret = uniphier_fi2c_master_xfer_one(adap, msg, repeat, stop);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\trepeat = !stop;\n\t}\n\n\treturn num;\n}\n\nstatic u32 uniphier_fi2c_functionality(struct i2c_adapter *adap)\n{\n\treturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;\n}\n\nstatic const struct i2c_algorithm uniphier_fi2c_algo = {\n\t.master_xfer = uniphier_fi2c_master_xfer,\n\t.functionality = uniphier_fi2c_functionality,\n};\n\nstatic int uniphier_fi2c_get_scl(struct i2c_adapter *adap)\n{\n\tstruct uniphier_fi2c_priv *priv = i2c_get_adapdata(adap);\n\n\treturn !!(readl(priv->membase + UNIPHIER_FI2C_BM) &\n\t\t\t\t\t\t\tUNIPHIER_FI2C_BM_SCLS);\n}\n\nstatic void uniphier_fi2c_set_scl(struct i2c_adapter *adap, int val)\n{\n\tstruct uniphier_fi2c_priv *priv = i2c_get_adapdata(adap);\n\n\twritel(val ? UNIPHIER_FI2C_BRST_RSCL : 0,\n\t       priv->membase + UNIPHIER_FI2C_BRST);\n}\n\nstatic int uniphier_fi2c_get_sda(struct i2c_adapter *adap)\n{\n\tstruct uniphier_fi2c_priv *priv = i2c_get_adapdata(adap);\n\n\treturn !!(readl(priv->membase + UNIPHIER_FI2C_BM) &\n\t\t\t\t\t\t\tUNIPHIER_FI2C_BM_SDAS);\n}\n\nstatic void uniphier_fi2c_unprepare_recovery(struct i2c_adapter *adap)\n{\n\tuniphier_fi2c_prepare_operation(i2c_get_adapdata(adap));\n}\n\nstatic struct i2c_bus_recovery_info uniphier_fi2c_bus_recovery_info = {\n\t.recover_bus = i2c_generic_scl_recovery,\n\t.get_scl = uniphier_fi2c_get_scl,\n\t.set_scl = uniphier_fi2c_set_scl,\n\t.get_sda = uniphier_fi2c_get_sda,\n\t.unprepare_recovery = uniphier_fi2c_unprepare_recovery,\n};\n\nstatic void uniphier_fi2c_hw_init(struct uniphier_fi2c_priv *priv)\n{\n\tunsigned int cyc = priv->clk_cycle;\n\tu32 tmp;\n\n\ttmp = readl(priv->membase + UNIPHIER_FI2C_CR);\n\ttmp |= UNIPHIER_FI2C_CR_MST;\n\twritel(tmp, priv->membase + UNIPHIER_FI2C_CR);\n\n\tuniphier_fi2c_reset(priv);\n\n\t \n\twritel(cyc, priv->membase + UNIPHIER_FI2C_CYC);\n\t \n\twritel(cyc * 5 / 9, priv->membase + UNIPHIER_FI2C_LCTL);\n\t \n\twritel(cyc / 2, priv->membase + UNIPHIER_FI2C_SSUT);\n\t \n\twritel(cyc / 16, priv->membase + UNIPHIER_FI2C_DSUT);\n\n\tuniphier_fi2c_prepare_operation(priv);\n}\n\nstatic int uniphier_fi2c_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct uniphier_fi2c_priv *priv;\n\tu32 bus_speed;\n\tunsigned long clk_rate;\n\tint irq, ret;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->membase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(priv->membase))\n\t\treturn PTR_ERR(priv->membase);\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tif (of_property_read_u32(dev->of_node, \"clock-frequency\", &bus_speed))\n\t\tbus_speed = I2C_MAX_STANDARD_MODE_FREQ;\n\n\tif (!bus_speed || bus_speed > I2C_MAX_FAST_MODE_FREQ) {\n\t\tdev_err(dev, \"invalid clock-frequency %d\\n\", bus_speed);\n\t\treturn -EINVAL;\n\t}\n\n\tpriv->clk = devm_clk_get_enabled(dev, NULL);\n\tif (IS_ERR(priv->clk)) {\n\t\tdev_err(dev, \"failed to enable clock\\n\");\n\t\treturn PTR_ERR(priv->clk);\n\t}\n\n\tclk_rate = clk_get_rate(priv->clk);\n\tif (!clk_rate) {\n\t\tdev_err(dev, \"input clock rate should not be zero\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpriv->clk_cycle = clk_rate / bus_speed;\n\tinit_completion(&priv->comp);\n\tspin_lock_init(&priv->lock);\n\tpriv->adap.owner = THIS_MODULE;\n\tpriv->adap.algo = &uniphier_fi2c_algo;\n\tpriv->adap.dev.parent = dev;\n\tpriv->adap.dev.of_node = dev->of_node;\n\tstrscpy(priv->adap.name, \"UniPhier FI2C\", sizeof(priv->adap.name));\n\tpriv->adap.bus_recovery_info = &uniphier_fi2c_bus_recovery_info;\n\ti2c_set_adapdata(&priv->adap, priv);\n\tplatform_set_drvdata(pdev, priv);\n\n\tuniphier_fi2c_hw_init(priv);\n\n\tret = devm_request_irq(dev, irq, uniphier_fi2c_interrupt, 0,\n\t\t\t       pdev->name, priv);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to request irq %d\\n\", irq);\n\t\treturn ret;\n\t}\n\n\treturn i2c_add_adapter(&priv->adap);\n}\n\nstatic void uniphier_fi2c_remove(struct platform_device *pdev)\n{\n\tstruct uniphier_fi2c_priv *priv = platform_get_drvdata(pdev);\n\n\ti2c_del_adapter(&priv->adap);\n}\n\nstatic int __maybe_unused uniphier_fi2c_suspend(struct device *dev)\n{\n\tstruct uniphier_fi2c_priv *priv = dev_get_drvdata(dev);\n\n\tclk_disable_unprepare(priv->clk);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused uniphier_fi2c_resume(struct device *dev)\n{\n\tstruct uniphier_fi2c_priv *priv = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = clk_prepare_enable(priv->clk);\n\tif (ret)\n\t\treturn ret;\n\n\tuniphier_fi2c_hw_init(priv);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops uniphier_fi2c_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(uniphier_fi2c_suspend, uniphier_fi2c_resume)\n};\n\nstatic const struct of_device_id uniphier_fi2c_match[] = {\n\t{ .compatible = \"socionext,uniphier-fi2c\" },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, uniphier_fi2c_match);\n\nstatic struct platform_driver uniphier_fi2c_drv = {\n\t.probe  = uniphier_fi2c_probe,\n\t.remove_new = uniphier_fi2c_remove,\n\t.driver = {\n\t\t.name  = \"uniphier-fi2c\",\n\t\t.of_match_table = uniphier_fi2c_match,\n\t\t.pm = &uniphier_fi2c_pm_ops,\n\t},\n};\nmodule_platform_driver(uniphier_fi2c_drv);\n\nMODULE_AUTHOR(\"Masahiro Yamada <yamada.masahiro@socionext.com>\");\nMODULE_DESCRIPTION(\"UniPhier FIFO-builtin I2C bus driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}