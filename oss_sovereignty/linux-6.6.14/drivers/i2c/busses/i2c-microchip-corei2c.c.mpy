{
  "module_name": "i2c-microchip-corei2c.c",
  "hash_id": "62a8c8486303c267b0db7625192ccd6062cbd5950aeecee3009418a8d71d3b1a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-microchip-corei2c.c",
  "human_readable_source": "\n \n#include <linux/clk.h>\n#include <linux/clkdev.h>\n#include <linux/err.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n\n#define CORE_I2C_CTRL\t(0x00)\n#define  CTRL_CR0\tBIT(0)\n#define  CTRL_CR1\tBIT(1)\n#define  CTRL_AA\tBIT(2)\n#define  CTRL_SI\tBIT(3)\n#define  CTRL_STO\tBIT(4)\n#define  CTRL_STA\tBIT(5)\n#define  CTRL_ENS1\tBIT(6)\n#define  CTRL_CR2\tBIT(7)\n\n#define STATUS_BUS_ERROR\t\t\t(0x00)\n#define STATUS_M_START_SENT\t\t\t(0x08)\n#define STATUS_M_REPEATED_START_SENT\t\t(0x10)\n#define STATUS_M_SLAW_ACK\t\t\t(0x18)\n#define STATUS_M_SLAW_NACK\t\t\t(0x20)\n#define STATUS_M_TX_DATA_ACK\t\t\t(0x28)\n#define STATUS_M_TX_DATA_NACK\t\t\t(0x30)\n#define STATUS_M_ARB_LOST\t\t\t(0x38)\n#define STATUS_M_SLAR_ACK\t\t\t(0x40)\n#define STATUS_M_SLAR_NACK\t\t\t(0x48)\n#define STATUS_M_RX_DATA_ACKED\t\t\t(0x50)\n#define STATUS_M_RX_DATA_NACKED\t\t\t(0x58)\n#define STATUS_S_SLAW_ACKED\t\t\t(0x60)\n#define STATUS_S_ARB_LOST_SLAW_ACKED\t\t(0x68)\n#define STATUS_S_GENERAL_CALL_ACKED\t\t(0x70)\n#define STATUS_S_ARB_LOST_GENERAL_CALL_ACKED\t(0x78)\n#define STATUS_S_RX_DATA_ACKED\t\t\t(0x80)\n#define STATUS_S_RX_DATA_NACKED\t\t\t(0x88)\n#define STATUS_S_GENERAL_CALL_RX_DATA_ACKED\t(0x90)\n#define STATUS_S_GENERAL_CALL_RX_DATA_NACKED\t(0x98)\n#define STATUS_S_RX_STOP\t\t\t(0xA0)\n#define STATUS_S_SLAR_ACKED\t\t\t(0xA8)\n#define STATUS_S_ARB_LOST_SLAR_ACKED\t\t(0xB0)\n#define STATUS_S_TX_DATA_ACK\t\t\t(0xB8)\n#define STATUS_S_TX_DATA_NACK\t\t\t(0xC0)\n#define STATUS_LAST_DATA_ACK\t\t\t(0xC8)\n#define STATUS_M_SMB_MASTER_RESET\t\t(0xD0)\n#define STATUS_S_SCL_LOW_TIMEOUT\t\t(0xD8)  \n#define STATUS_NO_STATE_INFO\t\t\t(0xF8)\n\n#define CORE_I2C_STATUS\t\t(0x04)\n#define CORE_I2C_DATA\t\t(0x08)\n#define WRITE_BIT\t\t(0x0)\n#define READ_BIT\t\t(0x1)\n#define SLAVE_ADDR_SHIFT\t(1)\n#define CORE_I2C_SLAVE0_ADDR\t(0x0c)\n#define GENERAL_CALL_BIT\t(0x0)\n#define CORE_I2C_SMBUS\t\t(0x10)\n#define SMBALERT_INT_ENB\t(0x0)\n#define SMBSUS_INT_ENB\t\t(0x1)\n#define SMBUS_ENB\t\t(0x2)\n#define SMBALERT_NI_STATUS\t(0x3)\n#define SMBALERT_NO_CTRL\t(0x4)\n#define SMBSUS_NI_STATUS\t(0x5)\n#define SMBSUS_NO_CTRL\t\t(0x6)\n#define SMBUS_RESET\t\t(0x7)\n#define CORE_I2C_FREQ\t\t(0x14)\n#define CORE_I2C_GLITCHREG\t(0x18)\n#define CORE_I2C_SLAVE1_ADDR\t(0x1c)\n\n#define PCLK_DIV_960\t(CTRL_CR2)\n#define PCLK_DIV_256\t(0)\n#define PCLK_DIV_224\t(CTRL_CR0)\n#define PCLK_DIV_192\t(CTRL_CR1)\n#define PCLK_DIV_160\t(CTRL_CR0 | CTRL_CR1)\n#define PCLK_DIV_120\t(CTRL_CR0 | CTRL_CR2)\n#define PCLK_DIV_60\t(CTRL_CR1 | CTRL_CR2)\n#define BCLK_DIV_8\t(CTRL_CR0 | CTRL_CR1 | CTRL_CR2)\n#define CLK_MASK\t(CTRL_CR0 | CTRL_CR1 | CTRL_CR2)\n\n \nstruct mchp_corei2c_dev {\n\tvoid __iomem *base;\n\tstruct device *dev;\n\tstruct clk *i2c_clk;\n\tu8 *buf;\n\tstruct completion msg_complete;\n\tstruct i2c_adapter adapter;\n\tint msg_err;\n\tu32 bus_clk_rate;\n\tu32 isr_status;\n\tu16 msg_len;\n\tu8 addr;\n};\n\nstatic void mchp_corei2c_core_disable(struct mchp_corei2c_dev *idev)\n{\n\tu8 ctrl = readb(idev->base + CORE_I2C_CTRL);\n\n\tctrl &= ~CTRL_ENS1;\n\twriteb(ctrl, idev->base + CORE_I2C_CTRL);\n}\n\nstatic void mchp_corei2c_core_enable(struct mchp_corei2c_dev *idev)\n{\n\tu8 ctrl = readb(idev->base + CORE_I2C_CTRL);\n\n\tctrl |= CTRL_ENS1;\n\twriteb(ctrl, idev->base + CORE_I2C_CTRL);\n}\n\nstatic void mchp_corei2c_reset(struct mchp_corei2c_dev *idev)\n{\n\tmchp_corei2c_core_disable(idev);\n\tmchp_corei2c_core_enable(idev);\n}\n\nstatic inline void mchp_corei2c_stop(struct mchp_corei2c_dev *idev)\n{\n\tu8 ctrl = readb(idev->base + CORE_I2C_CTRL);\n\n\tctrl |= CTRL_STO;\n\twriteb(ctrl, idev->base + CORE_I2C_CTRL);\n}\n\nstatic inline int mchp_corei2c_set_divisor(u32 rate,\n\t\t\t\t\t   struct mchp_corei2c_dev *idev)\n{\n\tu8 clkval, ctrl;\n\n\tif (rate >= 960)\n\t\tclkval = PCLK_DIV_960;\n\telse if (rate >= 256)\n\t\tclkval = PCLK_DIV_256;\n\telse if (rate >= 224)\n\t\tclkval = PCLK_DIV_224;\n\telse if (rate >= 192)\n\t\tclkval = PCLK_DIV_192;\n\telse if (rate >= 160)\n\t\tclkval = PCLK_DIV_160;\n\telse if (rate >= 120)\n\t\tclkval = PCLK_DIV_120;\n\telse if (rate >= 60)\n\t\tclkval = PCLK_DIV_60;\n\telse if (rate >= 8)\n\t\tclkval = BCLK_DIV_8;\n\telse\n\t\treturn -EINVAL;\n\n\tctrl = readb(idev->base + CORE_I2C_CTRL);\n\tctrl &= ~CLK_MASK;\n\tctrl |= clkval;\n\twriteb(ctrl, idev->base + CORE_I2C_CTRL);\n\n\tctrl = readb(idev->base + CORE_I2C_CTRL);\n\tif ((ctrl & CLK_MASK) != clkval)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic int mchp_corei2c_init(struct mchp_corei2c_dev *idev)\n{\n\tu32 clk_rate = clk_get_rate(idev->i2c_clk);\n\tu32 divisor = clk_rate / idev->bus_clk_rate;\n\tint ret;\n\n\tret = mchp_corei2c_set_divisor(divisor, idev);\n\tif (ret)\n\t\treturn ret;\n\n\tmchp_corei2c_reset(idev);\n\n\treturn 0;\n}\n\nstatic void mchp_corei2c_empty_rx(struct mchp_corei2c_dev *idev)\n{\n\tu8 ctrl;\n\n\tif (idev->msg_len > 0) {\n\t\t*idev->buf++ = readb(idev->base + CORE_I2C_DATA);\n\t\tidev->msg_len--;\n\t}\n\n\tif (idev->msg_len <= 1) {\n\t\tctrl = readb(idev->base + CORE_I2C_CTRL);\n\t\tctrl &= ~CTRL_AA;\n\t\twriteb(ctrl, idev->base + CORE_I2C_CTRL);\n\t}\n}\n\nstatic int mchp_corei2c_fill_tx(struct mchp_corei2c_dev *idev)\n{\n\tif (idev->msg_len > 0)\n\t\twriteb(*idev->buf++, idev->base + CORE_I2C_DATA);\n\tidev->msg_len--;\n\n\treturn 0;\n}\n\nstatic irqreturn_t mchp_corei2c_handle_isr(struct mchp_corei2c_dev *idev)\n{\n\tu32 status = idev->isr_status;\n\tu8 ctrl;\n\tbool last_byte = false, finished = false;\n\n\tif (!idev->buf)\n\t\treturn IRQ_NONE;\n\n\tswitch (status) {\n\tcase STATUS_M_START_SENT:\n\tcase STATUS_M_REPEATED_START_SENT:\n\t\tctrl = readb(idev->base + CORE_I2C_CTRL);\n\t\tctrl &= ~CTRL_STA;\n\t\twriteb(idev->addr, idev->base + CORE_I2C_DATA);\n\t\twriteb(ctrl, idev->base + CORE_I2C_CTRL);\n\t\tif (idev->msg_len == 0)\n\t\t\tfinished = true;\n\t\tbreak;\n\tcase STATUS_M_ARB_LOST:\n\t\tidev->msg_err = -EAGAIN;\n\t\tfinished = true;\n\t\tbreak;\n\tcase STATUS_M_SLAW_ACK:\n\tcase STATUS_M_TX_DATA_ACK:\n\t\tif (idev->msg_len > 0)\n\t\t\tmchp_corei2c_fill_tx(idev);\n\t\telse\n\t\t\tlast_byte = true;\n\t\tbreak;\n\tcase STATUS_M_TX_DATA_NACK:\n\tcase STATUS_M_SLAR_NACK:\n\tcase STATUS_M_SLAW_NACK:\n\t\tidev->msg_err = -ENXIO;\n\t\tlast_byte = true;\n\t\tbreak;\n\tcase STATUS_M_SLAR_ACK:\n\t\tctrl = readb(idev->base + CORE_I2C_CTRL);\n\t\tif (idev->msg_len == 1u) {\n\t\t\tctrl &= ~CTRL_AA;\n\t\t\twriteb(ctrl, idev->base + CORE_I2C_CTRL);\n\t\t} else {\n\t\t\tctrl |= CTRL_AA;\n\t\t\twriteb(ctrl, idev->base + CORE_I2C_CTRL);\n\t\t}\n\t\tif (idev->msg_len < 1u)\n\t\t\tlast_byte = true;\n\t\tbreak;\n\tcase STATUS_M_RX_DATA_ACKED:\n\t\tmchp_corei2c_empty_rx(idev);\n\t\tbreak;\n\tcase STATUS_M_RX_DATA_NACKED:\n\t\tmchp_corei2c_empty_rx(idev);\n\t\tif (idev->msg_len == 0)\n\t\t\tlast_byte = true;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tif (last_byte)\n\t\tmchp_corei2c_stop(idev);\n\n\tif (last_byte || finished)\n\t\tcomplete(&idev->msg_complete);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t mchp_corei2c_isr(int irq, void *_dev)\n{\n\tstruct mchp_corei2c_dev *idev = _dev;\n\tirqreturn_t ret = IRQ_NONE;\n\tu8 ctrl;\n\n\tctrl = readb(idev->base + CORE_I2C_CTRL);\n\tif (ctrl & CTRL_SI) {\n\t\tidev->isr_status = readb(idev->base + CORE_I2C_STATUS);\n\t\tret = mchp_corei2c_handle_isr(idev);\n\t}\n\n\tctrl = readb(idev->base + CORE_I2C_CTRL);\n\tctrl &= ~CTRL_SI;\n\twriteb(ctrl, idev->base + CORE_I2C_CTRL);\n\n\treturn ret;\n}\n\nstatic int mchp_corei2c_xfer_msg(struct mchp_corei2c_dev *idev,\n\t\t\t\t struct i2c_msg *msg)\n{\n\tu8 ctrl;\n\tunsigned long time_left;\n\n\tidev->addr = i2c_8bit_addr_from_msg(msg);\n\tidev->msg_len = msg->len;\n\tidev->buf = msg->buf;\n\tidev->msg_err = 0;\n\n\treinit_completion(&idev->msg_complete);\n\n\tmchp_corei2c_core_enable(idev);\n\n\tctrl = readb(idev->base + CORE_I2C_CTRL);\n\tctrl |= CTRL_STA;\n\twriteb(ctrl, idev->base + CORE_I2C_CTRL);\n\n\ttime_left = wait_for_completion_timeout(&idev->msg_complete,\n\t\t\t\t\t\tidev->adapter.timeout);\n\tif (!time_left)\n\t\treturn -ETIMEDOUT;\n\n\treturn idev->msg_err;\n}\n\nstatic int mchp_corei2c_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs,\n\t\t\t     int num)\n{\n\tstruct mchp_corei2c_dev *idev = i2c_get_adapdata(adap);\n\tint i, ret;\n\n\tfor (i = 0; i < num; i++) {\n\t\tret = mchp_corei2c_xfer_msg(idev, msgs++);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn num;\n}\n\nstatic u32 mchp_corei2c_func(struct i2c_adapter *adap)\n{\n\treturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;\n}\n\nstatic const struct i2c_algorithm mchp_corei2c_algo = {\n\t.master_xfer = mchp_corei2c_xfer,\n\t.functionality = mchp_corei2c_func,\n};\n\nstatic int mchp_corei2c_probe(struct platform_device *pdev)\n{\n\tstruct mchp_corei2c_dev *idev;\n\tstruct resource *res;\n\tint irq, ret;\n\n\tidev = devm_kzalloc(&pdev->dev, sizeof(*idev), GFP_KERNEL);\n\tif (!idev)\n\t\treturn -ENOMEM;\n\n\tidev->base = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(idev->base))\n\t\treturn PTR_ERR(idev->base);\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tidev->i2c_clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(idev->i2c_clk))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(idev->i2c_clk),\n\t\t\t\t     \"missing clock\\n\");\n\n\tidev->dev = &pdev->dev;\n\tinit_completion(&idev->msg_complete);\n\n\tret = device_property_read_u32(idev->dev, \"clock-frequency\",\n\t\t\t\t       &idev->bus_clk_rate);\n\tif (ret || !idev->bus_clk_rate) {\n\t\tdev_info(&pdev->dev, \"default to 100kHz\\n\");\n\t\tidev->bus_clk_rate = 100000;\n\t}\n\n\tif (idev->bus_clk_rate > 400000)\n\t\treturn dev_err_probe(&pdev->dev, -EINVAL,\n\t\t\t\t     \"clock-frequency too high: %d\\n\",\n\t\t\t\t     idev->bus_clk_rate);\n\n\t \n\tret = devm_request_irq(&pdev->dev, irq, mchp_corei2c_isr, IRQF_SHARED,\n\t\t\t       pdev->name, idev);\n\tif (ret)\n\t\treturn dev_err_probe(&pdev->dev, ret,\n\t\t\t\t     \"failed to claim irq %d\\n\", irq);\n\n\tret = clk_prepare_enable(idev->i2c_clk);\n\tif (ret)\n\t\treturn dev_err_probe(&pdev->dev, ret,\n\t\t\t\t     \"failed to enable clock\\n\");\n\n\tret = mchp_corei2c_init(idev);\n\tif (ret) {\n\t\tclk_disable_unprepare(idev->i2c_clk);\n\t\treturn dev_err_probe(&pdev->dev, ret, \"failed to program clock divider\\n\");\n\t}\n\n\ti2c_set_adapdata(&idev->adapter, idev);\n\tsnprintf(idev->adapter.name, sizeof(idev->adapter.name),\n\t\t \"Microchip I2C hw bus at %08lx\", (unsigned long)res->start);\n\tidev->adapter.owner = THIS_MODULE;\n\tidev->adapter.algo = &mchp_corei2c_algo;\n\tidev->adapter.dev.parent = &pdev->dev;\n\tidev->adapter.dev.of_node = pdev->dev.of_node;\n\tidev->adapter.timeout = HZ;\n\n\tplatform_set_drvdata(pdev, idev);\n\n\tret = i2c_add_adapter(&idev->adapter);\n\tif (ret) {\n\t\tclk_disable_unprepare(idev->i2c_clk);\n\t\treturn ret;\n\t}\n\n\tdev_info(&pdev->dev, \"registered CoreI2C bus driver\\n\");\n\n\treturn 0;\n}\n\nstatic void mchp_corei2c_remove(struct platform_device *pdev)\n{\n\tstruct mchp_corei2c_dev *idev = platform_get_drvdata(pdev);\n\n\tclk_disable_unprepare(idev->i2c_clk);\n\ti2c_del_adapter(&idev->adapter);\n}\n\nstatic const struct of_device_id mchp_corei2c_of_match[] = {\n\t{ .compatible = \"microchip,mpfs-i2c\" },\n\t{ .compatible = \"microchip,corei2c-rtl-v7\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, mchp_corei2c_of_match);\n\nstatic struct platform_driver mchp_corei2c_driver = {\n\t.probe = mchp_corei2c_probe,\n\t.remove_new = mchp_corei2c_remove,\n\t.driver = {\n\t\t.name = \"microchip-corei2c\",\n\t\t.of_match_table = mchp_corei2c_of_match,\n\t},\n};\n\nmodule_platform_driver(mchp_corei2c_driver);\n\nMODULE_DESCRIPTION(\"Microchip CoreI2C bus driver\");\nMODULE_AUTHOR(\"Daire McNamara <daire.mcnamara@microchip.com>\");\nMODULE_AUTHOR(\"Conor Dooley <conor.dooley@microchip.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}