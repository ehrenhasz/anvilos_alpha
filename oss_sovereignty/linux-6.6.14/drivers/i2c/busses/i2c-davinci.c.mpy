{
  "module_name": "i2c-davinci.c",
  "hash_id": "dedc365c9984623d00cab586b1781c85c0d9f005ddfa5b0cfb648d5955cbbef0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-davinci.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/i2c.h>\n#include <linux/clk.h>\n#include <linux/errno.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/interrupt.h>\n#include <linux/platform_device.h>\n#include <linux/io.h>\n#include <linux/slab.h>\n#include <linux/cpufreq.h>\n#include <linux/gpio/consumer.h>\n#include <linux/of.h>\n#include <linux/platform_data/i2c-davinci.h>\n#include <linux/pm_runtime.h>\n\n \n\n#define DAVINCI_I2C_TIMEOUT\t(1*HZ)\n#define DAVINCI_I2C_MAX_TRIES\t2\n#define DAVINCI_I2C_OWN_ADDRESS\t0x08\n#define I2C_DAVINCI_INTR_ALL    (DAVINCI_I2C_IMR_SCD | \\\n\t\t\t\t DAVINCI_I2C_IMR_ARDY | \\\n\t\t\t\t DAVINCI_I2C_IMR_NACK | \\\n\t\t\t\t DAVINCI_I2C_IMR_AL)\n\n#define DAVINCI_I2C_OAR_REG\t0x00\n#define DAVINCI_I2C_IMR_REG\t0x04\n#define DAVINCI_I2C_STR_REG\t0x08\n#define DAVINCI_I2C_CLKL_REG\t0x0c\n#define DAVINCI_I2C_CLKH_REG\t0x10\n#define DAVINCI_I2C_CNT_REG\t0x14\n#define DAVINCI_I2C_DRR_REG\t0x18\n#define DAVINCI_I2C_SAR_REG\t0x1c\n#define DAVINCI_I2C_DXR_REG\t0x20\n#define DAVINCI_I2C_MDR_REG\t0x24\n#define DAVINCI_I2C_IVR_REG\t0x28\n#define DAVINCI_I2C_EMDR_REG\t0x2c\n#define DAVINCI_I2C_PSC_REG\t0x30\n#define DAVINCI_I2C_FUNC_REG\t0x48\n#define DAVINCI_I2C_DIR_REG\t0x4c\n#define DAVINCI_I2C_DIN_REG\t0x50\n#define DAVINCI_I2C_DOUT_REG\t0x54\n#define DAVINCI_I2C_DSET_REG\t0x58\n#define DAVINCI_I2C_DCLR_REG\t0x5c\n\n#define DAVINCI_I2C_IVR_AAS\t0x07\n#define DAVINCI_I2C_IVR_SCD\t0x06\n#define DAVINCI_I2C_IVR_XRDY\t0x05\n#define DAVINCI_I2C_IVR_RDR\t0x04\n#define DAVINCI_I2C_IVR_ARDY\t0x03\n#define DAVINCI_I2C_IVR_NACK\t0x02\n#define DAVINCI_I2C_IVR_AL\t0x01\n\n#define DAVINCI_I2C_STR_BB\tBIT(12)\n#define DAVINCI_I2C_STR_RSFULL\tBIT(11)\n#define DAVINCI_I2C_STR_SCD\tBIT(5)\n#define DAVINCI_I2C_STR_ARDY\tBIT(2)\n#define DAVINCI_I2C_STR_NACK\tBIT(1)\n#define DAVINCI_I2C_STR_AL\tBIT(0)\n\n#define DAVINCI_I2C_MDR_NACK\tBIT(15)\n#define DAVINCI_I2C_MDR_STT\tBIT(13)\n#define DAVINCI_I2C_MDR_STP\tBIT(11)\n#define DAVINCI_I2C_MDR_MST\tBIT(10)\n#define DAVINCI_I2C_MDR_TRX\tBIT(9)\n#define DAVINCI_I2C_MDR_XA\tBIT(8)\n#define DAVINCI_I2C_MDR_RM\tBIT(7)\n#define DAVINCI_I2C_MDR_IRS\tBIT(5)\n\n#define DAVINCI_I2C_IMR_AAS\tBIT(6)\n#define DAVINCI_I2C_IMR_SCD\tBIT(5)\n#define DAVINCI_I2C_IMR_XRDY\tBIT(4)\n#define DAVINCI_I2C_IMR_RRDY\tBIT(3)\n#define DAVINCI_I2C_IMR_ARDY\tBIT(2)\n#define DAVINCI_I2C_IMR_NACK\tBIT(1)\n#define DAVINCI_I2C_IMR_AL\tBIT(0)\n\n \n#define DAVINCI_I2C_FUNC_PFUNC0\tBIT(0)\n\n \n#define DAVINCI_I2C_DIR_PDIR0\tBIT(0)\n \n#define DAVINCI_I2C_DIR_PDIR1\tBIT(1)\n\n \n#define DAVINCI_I2C_DIN_PDIN0 BIT(0)\n \n#define DAVINCI_I2C_DIN_PDIN1 BIT(1)\n\n \n#define DAVINCI_I2C_DSET_PDSET0\tBIT(0)\n \n#define DAVINCI_I2C_DSET_PDSET1\tBIT(1)\n\n \n#define DAVINCI_I2C_DCLR_PDCLR0\tBIT(0)\n \n#define DAVINCI_I2C_DCLR_PDCLR1\tBIT(1)\n\n \n#define DAVINCI_I2C_PM_TIMEOUT\t1000\t \n\nstruct davinci_i2c_dev {\n\tstruct device           *dev;\n\tvoid __iomem\t\t*base;\n\tstruct completion\tcmd_complete;\n\tstruct clk              *clk;\n\tint\t\t\tcmd_err;\n\tu8\t\t\t*buf;\n\tsize_t\t\t\tbuf_len;\n\tint\t\t\tirq;\n\tint\t\t\tstop;\n\tu8\t\t\tterminate;\n\tstruct i2c_adapter\tadapter;\n#ifdef CONFIG_CPU_FREQ\n\tstruct notifier_block\tfreq_transition;\n#endif\n\tstruct davinci_i2c_platform_data *pdata;\n};\n\n \nstatic struct davinci_i2c_platform_data davinci_i2c_platform_data_default = {\n\t.bus_freq\t= 100,\n\t.bus_delay\t= 0,\n};\n\nstatic inline void davinci_i2c_write_reg(struct davinci_i2c_dev *i2c_dev,\n\t\t\t\t\t int reg, u16 val)\n{\n\twritew_relaxed(val, i2c_dev->base + reg);\n}\n\nstatic inline u16 davinci_i2c_read_reg(struct davinci_i2c_dev *i2c_dev, int reg)\n{\n\treturn readw_relaxed(i2c_dev->base + reg);\n}\n\nstatic inline void davinci_i2c_reset_ctrl(struct davinci_i2c_dev *i2c_dev,\n\t\t\t\t\t\t\t\tint val)\n{\n\tu16 w;\n\n\tw = davinci_i2c_read_reg(i2c_dev, DAVINCI_I2C_MDR_REG);\n\tif (!val)\t \n\t\tw &= ~DAVINCI_I2C_MDR_IRS;\n\telse\t\t \n\t\tw |= DAVINCI_I2C_MDR_IRS;\n\n\tdavinci_i2c_write_reg(i2c_dev, DAVINCI_I2C_MDR_REG, w);\n}\n\nstatic void i2c_davinci_calc_clk_dividers(struct davinci_i2c_dev *dev)\n{\n\tstruct davinci_i2c_platform_data *pdata = dev->pdata;\n\tu16 psc;\n\tu32 clk;\n\tu32 d;\n\tu32 clkh;\n\tu32 clkl;\n\tu32 input_clock = clk_get_rate(dev->clk);\n\tstruct device_node *of_node = dev->dev->of_node;\n\n\t \n\n\t \n\tpsc = (input_clock / 12000000) - 1;\n\tif ((input_clock / (psc + 1)) > 12000000)\n\t\tpsc++;\t \n\td = (psc >= 2) ? 5 : 7 - psc;\n\n\tif (of_node && of_device_is_compatible(of_node, \"ti,keystone-i2c\"))\n\t\td = 6;\n\n\tclk = ((input_clock / (psc + 1)) / (pdata->bus_freq * 1000));\n\t \n\tif (input_clock / (psc + 1) / clk > pdata->bus_freq * 1000)\n\t\tclk++;\n\t \n\tif (pdata->bus_freq > 100)\n\t\tclkl = (clk << 1) / 3;\n\telse\n\t\tclkl = (clk >> 1);\n\t \n\tif (clk > clkl + d) {\n\t\tclkh = clk - clkl - d;\n\t\tclkl -= d;\n\t} else {\n\t\tclkh = 1;\n\t\tclkl = clk - (d << 1);\n\t}\n\n\tdavinci_i2c_write_reg(dev, DAVINCI_I2C_PSC_REG, psc);\n\tdavinci_i2c_write_reg(dev, DAVINCI_I2C_CLKH_REG, clkh);\n\tdavinci_i2c_write_reg(dev, DAVINCI_I2C_CLKL_REG, clkl);\n\n\tdev_dbg(dev->dev, \"input_clock = %d, CLK = %d\\n\", input_clock, clk);\n}\n\n \nstatic int i2c_davinci_init(struct davinci_i2c_dev *dev)\n{\n\tstruct davinci_i2c_platform_data *pdata = dev->pdata;\n\n\t \n\tdavinci_i2c_reset_ctrl(dev, 0);\n\n\t \n\ti2c_davinci_calc_clk_dividers(dev);\n\n\t \n\tdavinci_i2c_write_reg(dev, DAVINCI_I2C_OAR_REG, DAVINCI_I2C_OWN_ADDRESS);\n\n\tdev_dbg(dev->dev, \"PSC  = %d\\n\",\n\t\tdavinci_i2c_read_reg(dev, DAVINCI_I2C_PSC_REG));\n\tdev_dbg(dev->dev, \"CLKL = %d\\n\",\n\t\tdavinci_i2c_read_reg(dev, DAVINCI_I2C_CLKL_REG));\n\tdev_dbg(dev->dev, \"CLKH = %d\\n\",\n\t\tdavinci_i2c_read_reg(dev, DAVINCI_I2C_CLKH_REG));\n\tdev_dbg(dev->dev, \"bus_freq = %dkHz, bus_delay = %d\\n\",\n\t\tpdata->bus_freq, pdata->bus_delay);\n\n\n\t \n\tdavinci_i2c_reset_ctrl(dev, 1);\n\n\t \n\tdavinci_i2c_write_reg(dev, DAVINCI_I2C_IMR_REG, I2C_DAVINCI_INTR_ALL);\n\n\treturn 0;\n}\n\n \nstatic void davinci_i2c_prepare_recovery(struct i2c_adapter *adap)\n{\n\tstruct davinci_i2c_dev *dev = i2c_get_adapdata(adap);\n\n\t \n\tdavinci_i2c_write_reg(dev, DAVINCI_I2C_IMR_REG, 0);\n\n\t \n\tdavinci_i2c_reset_ctrl(dev, 0);\n}\n\nstatic void davinci_i2c_unprepare_recovery(struct i2c_adapter *adap)\n{\n\tstruct davinci_i2c_dev *dev = i2c_get_adapdata(adap);\n\n\ti2c_davinci_init(dev);\n}\n\nstatic struct i2c_bus_recovery_info davinci_i2c_gpio_recovery_info = {\n\t.recover_bus = i2c_generic_scl_recovery,\n\t.prepare_recovery = davinci_i2c_prepare_recovery,\n\t.unprepare_recovery = davinci_i2c_unprepare_recovery,\n};\n\nstatic void davinci_i2c_set_scl(struct i2c_adapter *adap, int val)\n{\n\tstruct davinci_i2c_dev *dev = i2c_get_adapdata(adap);\n\n\tif (val)\n\t\tdavinci_i2c_write_reg(dev, DAVINCI_I2C_DSET_REG,\n\t\t\t\t      DAVINCI_I2C_DSET_PDSET0);\n\telse\n\t\tdavinci_i2c_write_reg(dev, DAVINCI_I2C_DCLR_REG,\n\t\t\t\t      DAVINCI_I2C_DCLR_PDCLR0);\n}\n\nstatic int davinci_i2c_get_scl(struct i2c_adapter *adap)\n{\n\tstruct davinci_i2c_dev *dev = i2c_get_adapdata(adap);\n\tint val;\n\n\t \n\tval = davinci_i2c_read_reg(dev, DAVINCI_I2C_DIN_REG);\n\treturn val & DAVINCI_I2C_DIN_PDIN0;\n}\n\nstatic int davinci_i2c_get_sda(struct i2c_adapter *adap)\n{\n\tstruct davinci_i2c_dev *dev = i2c_get_adapdata(adap);\n\tint val;\n\n\t \n\tval = davinci_i2c_read_reg(dev, DAVINCI_I2C_DIN_REG);\n\treturn val & DAVINCI_I2C_DIN_PDIN1;\n}\n\nstatic void davinci_i2c_scl_prepare_recovery(struct i2c_adapter *adap)\n{\n\tstruct davinci_i2c_dev *dev = i2c_get_adapdata(adap);\n\n\tdavinci_i2c_prepare_recovery(adap);\n\n\t \n\tdavinci_i2c_write_reg(dev, DAVINCI_I2C_DIR_REG, DAVINCI_I2C_DIR_PDIR0);\n\n\t \n\tdavinci_i2c_write_reg(dev, DAVINCI_I2C_FUNC_REG,\n\t\t\t      DAVINCI_I2C_FUNC_PFUNC0);\n}\n\nstatic void davinci_i2c_scl_unprepare_recovery(struct i2c_adapter *adap)\n{\n\tstruct davinci_i2c_dev *dev = i2c_get_adapdata(adap);\n\n\t \n\tdavinci_i2c_write_reg(dev, DAVINCI_I2C_FUNC_REG, 0);\n\n\tdavinci_i2c_unprepare_recovery(adap);\n}\n\nstatic struct i2c_bus_recovery_info davinci_i2c_scl_recovery_info = {\n\t.recover_bus = i2c_generic_scl_recovery,\n\t.set_scl = davinci_i2c_set_scl,\n\t.get_scl = davinci_i2c_get_scl,\n\t.get_sda = davinci_i2c_get_sda,\n\t.prepare_recovery = davinci_i2c_scl_prepare_recovery,\n\t.unprepare_recovery = davinci_i2c_scl_unprepare_recovery,\n};\n\n \nstatic int i2c_davinci_wait_bus_not_busy(struct davinci_i2c_dev *dev)\n{\n\tunsigned long timeout = jiffies + dev->adapter.timeout;\n\n\tdo {\n\t\tif (!(davinci_i2c_read_reg(dev, DAVINCI_I2C_STR_REG) & DAVINCI_I2C_STR_BB))\n\t\t\treturn 0;\n\t\tschedule_timeout_uninterruptible(1);\n\t} while (time_before_eq(jiffies, timeout));\n\n\tdev_warn(dev->dev, \"timeout waiting for bus ready\\n\");\n\ti2c_recover_bus(&dev->adapter);\n\n\t \n\tif (davinci_i2c_read_reg(dev, DAVINCI_I2C_STR_REG) & DAVINCI_I2C_STR_BB)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\n \nstatic int\ni2c_davinci_xfer_msg(struct i2c_adapter *adap, struct i2c_msg *msg, int stop)\n{\n\tstruct davinci_i2c_dev *dev = i2c_get_adapdata(adap);\n\tstruct davinci_i2c_platform_data *pdata = dev->pdata;\n\tu32 flag;\n\tu16 w;\n\tunsigned long time_left;\n\n\tif (msg->addr == DAVINCI_I2C_OWN_ADDRESS) {\n\t\tdev_warn(dev->dev, \"transfer to own address aborted\\n\");\n\t\treturn -EADDRNOTAVAIL;\n\t}\n\n\t \n\tif (pdata->bus_delay)\n\t\tudelay(pdata->bus_delay);\n\n\t \n\tdavinci_i2c_write_reg(dev, DAVINCI_I2C_SAR_REG, msg->addr);\n\n\tdev->buf = msg->buf;\n\tdev->buf_len = msg->len;\n\tdev->stop = stop;\n\n\tdavinci_i2c_write_reg(dev, DAVINCI_I2C_CNT_REG, dev->buf_len);\n\n\treinit_completion(&dev->cmd_complete);\n\tdev->cmd_err = 0;\n\n\t \n\tflag = DAVINCI_I2C_MDR_IRS | DAVINCI_I2C_MDR_MST;\n\n\t \n\tif (msg->flags & I2C_M_TEN)\n\t\tflag |= DAVINCI_I2C_MDR_XA;\n\tif (!(msg->flags & I2C_M_RD))\n\t\tflag |= DAVINCI_I2C_MDR_TRX;\n\tif (msg->len == 0)\n\t\tflag |= DAVINCI_I2C_MDR_RM;\n\n\t \n\tw = davinci_i2c_read_reg(dev, DAVINCI_I2C_IMR_REG);\n\tif (msg->flags & I2C_M_RD)\n\t\tw |= DAVINCI_I2C_IMR_RRDY;\n\telse\n\t\tw |= DAVINCI_I2C_IMR_XRDY;\n\tdavinci_i2c_write_reg(dev, DAVINCI_I2C_IMR_REG, w);\n\n\tdev->terminate = 0;\n\n\t \n\tdavinci_i2c_write_reg(dev, DAVINCI_I2C_MDR_REG, flag);\n\n\t \n\tif ((!(msg->flags & I2C_M_RD)) && dev->buf_len) {\n\t\tdavinci_i2c_write_reg(dev, DAVINCI_I2C_DXR_REG, *dev->buf++);\n\t\tdev->buf_len--;\n\t}\n\n\t \n\tflag |= DAVINCI_I2C_MDR_STT;\n\tif (stop && msg->len != 0)\n\t\tflag |= DAVINCI_I2C_MDR_STP;\n\tdavinci_i2c_write_reg(dev, DAVINCI_I2C_MDR_REG, flag);\n\n\ttime_left = wait_for_completion_timeout(&dev->cmd_complete,\n\t\t\t\t\t\tdev->adapter.timeout);\n\tif (!time_left) {\n\t\tdev_err(dev->dev, \"controller timed out\\n\");\n\t\ti2c_recover_bus(adap);\n\t\tdev->buf_len = 0;\n\t\treturn -ETIMEDOUT;\n\t}\n\tif (dev->buf_len) {\n\t\t \n\t\tdev_err(dev->dev, \"abnormal termination buf_len=%zu\\n\",\n\t\t\tdev->buf_len);\n\t\tdev->terminate = 1;\n\t\twmb();\n\t\tdev->buf_len = 0;\n\t\treturn -EREMOTEIO;\n\t}\n\n\t \n\tif (likely(!dev->cmd_err))\n\t\treturn msg->len;\n\n\t \n\tif (dev->cmd_err & DAVINCI_I2C_STR_AL) {\n\t\ti2c_davinci_init(dev);\n\t\treturn -EIO;\n\t}\n\n\tif (dev->cmd_err & DAVINCI_I2C_STR_NACK) {\n\t\tif (msg->flags & I2C_M_IGNORE_NAK)\n\t\t\treturn msg->len;\n\t\tw = davinci_i2c_read_reg(dev, DAVINCI_I2C_MDR_REG);\n\t\tw |= DAVINCI_I2C_MDR_STP;\n\t\tdavinci_i2c_write_reg(dev, DAVINCI_I2C_MDR_REG, w);\n\t\treturn -EREMOTEIO;\n\t}\n\treturn -EIO;\n}\n\n \nstatic int\ni2c_davinci_xfer(struct i2c_adapter *adap, struct i2c_msg msgs[], int num)\n{\n\tstruct davinci_i2c_dev *dev = i2c_get_adapdata(adap);\n\tint i;\n\tint ret;\n\n\tdev_dbg(dev->dev, \"%s: msgs: %d\\n\", __func__, num);\n\n\tret = pm_runtime_resume_and_get(dev->dev);\n\tif (ret < 0) {\n\t\tdev_err(dev->dev, \"Failed to runtime_get device: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = i2c_davinci_wait_bus_not_busy(dev);\n\tif (ret < 0) {\n\t\tdev_warn(dev->dev, \"timeout waiting for bus ready\\n\");\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < num; i++) {\n\t\tret = i2c_davinci_xfer_msg(adap, &msgs[i], (i == (num - 1)));\n\t\tdev_dbg(dev->dev, \"%s [%d/%d] ret: %d\\n\", __func__, i + 1, num,\n\t\t\tret);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tret = num;\n\nout:\n\tpm_runtime_mark_last_busy(dev->dev);\n\tpm_runtime_put_autosuspend(dev->dev);\n\n\treturn ret;\n}\n\nstatic u32 i2c_davinci_func(struct i2c_adapter *adap)\n{\n\treturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;\n}\n\nstatic void terminate_read(struct davinci_i2c_dev *dev)\n{\n\tu16 w = davinci_i2c_read_reg(dev, DAVINCI_I2C_MDR_REG);\n\tw |= DAVINCI_I2C_MDR_NACK;\n\tdavinci_i2c_write_reg(dev, DAVINCI_I2C_MDR_REG, w);\n\n\t \n\tdavinci_i2c_read_reg(dev, DAVINCI_I2C_DRR_REG);\n\tif (!dev->terminate)\n\t\tdev_err(dev->dev, \"RDR IRQ while no data requested\\n\");\n}\nstatic void terminate_write(struct davinci_i2c_dev *dev)\n{\n\tu16 w = davinci_i2c_read_reg(dev, DAVINCI_I2C_MDR_REG);\n\tw |= DAVINCI_I2C_MDR_RM | DAVINCI_I2C_MDR_STP;\n\tdavinci_i2c_write_reg(dev, DAVINCI_I2C_MDR_REG, w);\n\n\tif (!dev->terminate)\n\t\tdev_dbg(dev->dev, \"TDR IRQ while no data to send\\n\");\n}\n\n \nstatic irqreturn_t i2c_davinci_isr(int this_irq, void *dev_id)\n{\n\tstruct davinci_i2c_dev *dev = dev_id;\n\tu32 stat;\n\tint count = 0;\n\tu16 w;\n\n\tif (pm_runtime_suspended(dev->dev))\n\t\treturn IRQ_NONE;\n\n\twhile ((stat = davinci_i2c_read_reg(dev, DAVINCI_I2C_IVR_REG))) {\n\t\tdev_dbg(dev->dev, \"%s: stat=0x%x\\n\", __func__, stat);\n\t\tif (count++ == 100) {\n\t\t\tdev_warn(dev->dev, \"Too much work in one IRQ\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (stat) {\n\t\tcase DAVINCI_I2C_IVR_AL:\n\t\t\t \n\t\t\tdev->cmd_err |= DAVINCI_I2C_STR_AL;\n\t\t\tdev->buf_len = 0;\n\t\t\tcomplete(&dev->cmd_complete);\n\t\t\tbreak;\n\n\t\tcase DAVINCI_I2C_IVR_NACK:\n\t\t\tdev->cmd_err |= DAVINCI_I2C_STR_NACK;\n\t\t\tdev->buf_len = 0;\n\t\t\tcomplete(&dev->cmd_complete);\n\t\t\tbreak;\n\n\t\tcase DAVINCI_I2C_IVR_ARDY:\n\t\t\tdavinci_i2c_write_reg(dev,\n\t\t\t\tDAVINCI_I2C_STR_REG, DAVINCI_I2C_STR_ARDY);\n\t\t\tif (((dev->buf_len == 0) && (dev->stop != 0)) ||\n\t\t\t    (dev->cmd_err & DAVINCI_I2C_STR_NACK)) {\n\t\t\t\tw = davinci_i2c_read_reg(dev,\n\t\t\t\t\t\t\t DAVINCI_I2C_MDR_REG);\n\t\t\t\tw |= DAVINCI_I2C_MDR_STP;\n\t\t\t\tdavinci_i2c_write_reg(dev,\n\t\t\t\t\t\t      DAVINCI_I2C_MDR_REG, w);\n\t\t\t}\n\t\t\tcomplete(&dev->cmd_complete);\n\t\t\tbreak;\n\n\t\tcase DAVINCI_I2C_IVR_RDR:\n\t\t\tif (dev->buf_len) {\n\t\t\t\t*dev->buf++ =\n\t\t\t\t    davinci_i2c_read_reg(dev,\n\t\t\t\t\t\t\t DAVINCI_I2C_DRR_REG);\n\t\t\t\tdev->buf_len--;\n\t\t\t\tif (dev->buf_len)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tdavinci_i2c_write_reg(dev,\n\t\t\t\t\tDAVINCI_I2C_STR_REG,\n\t\t\t\t\tDAVINCI_I2C_IMR_RRDY);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tterminate_read(dev);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase DAVINCI_I2C_IVR_XRDY:\n\t\t\tif (dev->buf_len) {\n\t\t\t\tdavinci_i2c_write_reg(dev, DAVINCI_I2C_DXR_REG,\n\t\t\t\t\t\t      *dev->buf++);\n\t\t\t\tdev->buf_len--;\n\t\t\t\tif (dev->buf_len)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tw = davinci_i2c_read_reg(dev,\n\t\t\t\t\t\t\t DAVINCI_I2C_IMR_REG);\n\t\t\t\tw &= ~DAVINCI_I2C_IMR_XRDY;\n\t\t\t\tdavinci_i2c_write_reg(dev,\n\t\t\t\t\t\t      DAVINCI_I2C_IMR_REG,\n\t\t\t\t\t\t      w);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tterminate_write(dev);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase DAVINCI_I2C_IVR_SCD:\n\t\t\tdavinci_i2c_write_reg(dev,\n\t\t\t\tDAVINCI_I2C_STR_REG, DAVINCI_I2C_STR_SCD);\n\t\t\tcomplete(&dev->cmd_complete);\n\t\t\tbreak;\n\n\t\tcase DAVINCI_I2C_IVR_AAS:\n\t\t\tdev_dbg(dev->dev, \"Address as slave interrupt\\n\");\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tdev_warn(dev->dev, \"Unrecognized irq stat %d\\n\", stat);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn count ? IRQ_HANDLED : IRQ_NONE;\n}\n\n#ifdef CONFIG_CPU_FREQ\nstatic int i2c_davinci_cpufreq_transition(struct notifier_block *nb,\n\t\t\t\t     unsigned long val, void *data)\n{\n\tstruct davinci_i2c_dev *dev;\n\n\tdev = container_of(nb, struct davinci_i2c_dev, freq_transition);\n\n\ti2c_lock_bus(&dev->adapter, I2C_LOCK_ROOT_ADAPTER);\n\tif (val == CPUFREQ_PRECHANGE) {\n\t\tdavinci_i2c_reset_ctrl(dev, 0);\n\t} else if (val == CPUFREQ_POSTCHANGE) {\n\t\ti2c_davinci_calc_clk_dividers(dev);\n\t\tdavinci_i2c_reset_ctrl(dev, 1);\n\t}\n\ti2c_unlock_bus(&dev->adapter, I2C_LOCK_ROOT_ADAPTER);\n\n\treturn 0;\n}\n\nstatic inline int i2c_davinci_cpufreq_register(struct davinci_i2c_dev *dev)\n{\n\tdev->freq_transition.notifier_call = i2c_davinci_cpufreq_transition;\n\n\treturn cpufreq_register_notifier(&dev->freq_transition,\n\t\t\t\t\t CPUFREQ_TRANSITION_NOTIFIER);\n}\n\nstatic inline void i2c_davinci_cpufreq_deregister(struct davinci_i2c_dev *dev)\n{\n\tcpufreq_unregister_notifier(&dev->freq_transition,\n\t\t\t\t    CPUFREQ_TRANSITION_NOTIFIER);\n}\n#else\nstatic inline int i2c_davinci_cpufreq_register(struct davinci_i2c_dev *dev)\n{\n\treturn 0;\n}\n\nstatic inline void i2c_davinci_cpufreq_deregister(struct davinci_i2c_dev *dev)\n{\n}\n#endif\n\nstatic const struct i2c_algorithm i2c_davinci_algo = {\n\t.master_xfer\t= i2c_davinci_xfer,\n\t.functionality\t= i2c_davinci_func,\n};\n\nstatic const struct of_device_id davinci_i2c_of_match[] = {\n\t{.compatible = \"ti,davinci-i2c\", },\n\t{.compatible = \"ti,keystone-i2c\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, davinci_i2c_of_match);\n\nstatic int davinci_i2c_probe(struct platform_device *pdev)\n{\n\tstruct davinci_i2c_dev *dev;\n\tstruct i2c_adapter *adap;\n\tstruct i2c_bus_recovery_info *rinfo;\n\tint r, irq;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tdev = devm_kzalloc(&pdev->dev, sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tinit_completion(&dev->cmd_complete);\n\n\tdev->dev = &pdev->dev;\n\tdev->irq = irq;\n\tdev->pdata = dev_get_platdata(&pdev->dev);\n\tplatform_set_drvdata(pdev, dev);\n\n\tif (!dev->pdata && pdev->dev.of_node) {\n\t\tu32 prop;\n\n\t\tdev->pdata = devm_kzalloc(&pdev->dev,\n\t\t\tsizeof(struct davinci_i2c_platform_data), GFP_KERNEL);\n\t\tif (!dev->pdata)\n\t\t\treturn -ENOMEM;\n\n\t\tmemcpy(dev->pdata, &davinci_i2c_platform_data_default,\n\t\t\tsizeof(struct davinci_i2c_platform_data));\n\t\tif (!of_property_read_u32(pdev->dev.of_node, \"clock-frequency\",\n\t\t\t&prop))\n\t\t\tdev->pdata->bus_freq = prop / 1000;\n\n\t\tdev->pdata->has_pfunc =\n\t\t\tof_property_read_bool(pdev->dev.of_node,\n\t\t\t\t\t      \"ti,has-pfunc\");\n\t} else if (!dev->pdata) {\n\t\tdev->pdata = &davinci_i2c_platform_data_default;\n\t}\n\n\tdev->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(dev->clk))\n\t\treturn PTR_ERR(dev->clk);\n\n\tdev->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(dev->base)) {\n\t\treturn PTR_ERR(dev->base);\n\t}\n\n\tpm_runtime_set_autosuspend_delay(dev->dev,\n\t\t\t\t\t DAVINCI_I2C_PM_TIMEOUT);\n\tpm_runtime_use_autosuspend(dev->dev);\n\n\tpm_runtime_enable(dev->dev);\n\n\tr = pm_runtime_resume_and_get(dev->dev);\n\tif (r < 0) {\n\t\tdev_err(dev->dev, \"failed to runtime_get device: %d\\n\", r);\n\t\tgoto err_pm;\n\t}\n\n\ti2c_davinci_init(dev);\n\n\tr = devm_request_irq(&pdev->dev, dev->irq, i2c_davinci_isr, 0,\n\t\t\tpdev->name, dev);\n\tif (r) {\n\t\tdev_err(&pdev->dev, \"failure requesting irq %i\\n\", dev->irq);\n\t\tgoto err_unuse_clocks;\n\t}\n\n\tr = i2c_davinci_cpufreq_register(dev);\n\tif (r) {\n\t\tdev_err(&pdev->dev, \"failed to register cpufreq\\n\");\n\t\tgoto err_unuse_clocks;\n\t}\n\n\tadap = &dev->adapter;\n\ti2c_set_adapdata(adap, dev);\n\tadap->owner = THIS_MODULE;\n\tadap->class = I2C_CLASS_DEPRECATED;\n\tstrscpy(adap->name, \"DaVinci I2C adapter\", sizeof(adap->name));\n\tadap->algo = &i2c_davinci_algo;\n\tadap->dev.parent = &pdev->dev;\n\tadap->timeout = DAVINCI_I2C_TIMEOUT;\n\tadap->dev.of_node = pdev->dev.of_node;\n\n\tif (dev->pdata->has_pfunc)\n\t\tadap->bus_recovery_info = &davinci_i2c_scl_recovery_info;\n\telse if (dev->pdata->gpio_recovery) {\n\t\trinfo =  &davinci_i2c_gpio_recovery_info;\n\t\tadap->bus_recovery_info = rinfo;\n\t\trinfo->scl_gpiod = devm_gpiod_get(&pdev->dev, \"scl\",\n\t\t\t\t\t\t  GPIOD_OUT_HIGH_OPEN_DRAIN);\n\t\tif (IS_ERR(rinfo->scl_gpiod)) {\n\t\t\tr = PTR_ERR(rinfo->scl_gpiod);\n\t\t\tgoto err_unuse_clocks;\n\t\t}\n\t\trinfo->sda_gpiod = devm_gpiod_get(&pdev->dev, \"sda\", GPIOD_IN);\n\t\tif (IS_ERR(rinfo->sda_gpiod)) {\n\t\t\tr = PTR_ERR(rinfo->sda_gpiod);\n\t\t\tgoto err_unuse_clocks;\n\t\t}\n\t}\n\n\tadap->nr = pdev->id;\n\tr = i2c_add_numbered_adapter(adap);\n\tif (r)\n\t\tgoto err_unuse_clocks;\n\n\tpm_runtime_mark_last_busy(dev->dev);\n\tpm_runtime_put_autosuspend(dev->dev);\n\n\treturn 0;\n\nerr_unuse_clocks:\n\tpm_runtime_dont_use_autosuspend(dev->dev);\n\tpm_runtime_put_sync(dev->dev);\nerr_pm:\n\tpm_runtime_disable(dev->dev);\n\n\treturn r;\n}\n\nstatic void davinci_i2c_remove(struct platform_device *pdev)\n{\n\tstruct davinci_i2c_dev *dev = platform_get_drvdata(pdev);\n\tint ret;\n\n\ti2c_davinci_cpufreq_deregister(dev);\n\n\ti2c_del_adapter(&dev->adapter);\n\n\tret = pm_runtime_get_sync(&pdev->dev);\n\tif (ret < 0)\n\t\tdev_err(&pdev->dev, \"Failed to resume device\\n\");\n\telse\n\t\tdavinci_i2c_write_reg(dev, DAVINCI_I2C_MDR_REG, 0);\n\n\tpm_runtime_dont_use_autosuspend(dev->dev);\n\tpm_runtime_put_sync(dev->dev);\n\tpm_runtime_disable(dev->dev);\n}\n\nstatic int davinci_i2c_suspend(struct device *dev)\n{\n\tstruct davinci_i2c_dev *i2c_dev = dev_get_drvdata(dev);\n\n\t \n\tdavinci_i2c_reset_ctrl(i2c_dev, 0);\n\n\treturn 0;\n}\n\nstatic int davinci_i2c_resume(struct device *dev)\n{\n\tstruct davinci_i2c_dev *i2c_dev = dev_get_drvdata(dev);\n\n\t \n\tdavinci_i2c_reset_ctrl(i2c_dev, 1);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops davinci_i2c_pm = {\n\t.suspend        = davinci_i2c_suspend,\n\t.resume         = davinci_i2c_resume,\n\tNOIRQ_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,\n\t\t\t\t  pm_runtime_force_resume)\n};\n\nstatic const struct platform_device_id davinci_i2c_driver_ids[] = {\n\t{ .name = \"i2c_davinci\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(platform, davinci_i2c_driver_ids);\n\nstatic struct platform_driver davinci_i2c_driver = {\n\t.probe\t\t= davinci_i2c_probe,\n\t.remove_new\t= davinci_i2c_remove,\n\t.id_table\t= davinci_i2c_driver_ids,\n\t.driver\t\t= {\n\t\t.name\t= \"i2c_davinci\",\n\t\t.pm\t= pm_sleep_ptr(&davinci_i2c_pm),\n\t\t.of_match_table = davinci_i2c_of_match,\n\t},\n};\n\n \nstatic int __init davinci_i2c_init_driver(void)\n{\n\treturn platform_driver_register(&davinci_i2c_driver);\n}\nsubsys_initcall(davinci_i2c_init_driver);\n\nstatic void __exit davinci_i2c_exit_driver(void)\n{\n\tplatform_driver_unregister(&davinci_i2c_driver);\n}\nmodule_exit(davinci_i2c_exit_driver);\n\nMODULE_AUTHOR(\"Texas Instruments India\");\nMODULE_DESCRIPTION(\"TI DaVinci I2C bus adapter\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}