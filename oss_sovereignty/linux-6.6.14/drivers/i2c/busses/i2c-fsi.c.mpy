{
  "module_name": "i2c-fsi.c",
  "hash_id": "893a9afc068dcc32abdf97a401c4551f00fe85925e2da1f3cb6c71a7d86e2a92",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-fsi.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/errno.h>\n#include <linux/fsi.h>\n#include <linux/i2c.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n\n#define FSI_ENGID_I2C\t\t0x7\n\n#define I2C_DEFAULT_CLK_DIV\t6\n\n \n#define I2C_FSI_FIFO\t\t0x00\n#define I2C_FSI_CMD\t\t0x04\n#define I2C_FSI_MODE\t\t0x08\n#define I2C_FSI_WATER_MARK\t0x0C\n#define I2C_FSI_INT_MASK\t0x10\n#define I2C_FSI_INT_COND\t0x14\n#define I2C_FSI_OR_INT_MASK\t0x14\n#define I2C_FSI_INTS\t\t0x18\n#define I2C_FSI_AND_INT_MASK\t0x18\n#define I2C_FSI_STAT\t\t0x1C\n#define I2C_FSI_RESET_I2C\t0x1C\n#define I2C_FSI_ESTAT\t\t0x20\n#define I2C_FSI_RESET_ERR\t0x20\n#define I2C_FSI_RESID_LEN\t0x24\n#define I2C_FSI_SET_SCL\t\t0x24\n#define I2C_FSI_PORT_BUSY\t0x28\n#define I2C_FSI_RESET_SCL\t0x2C\n#define I2C_FSI_SET_SDA\t\t0x30\n#define I2C_FSI_RESET_SDA\t0x34\n\n \n#define I2C_CMD_WITH_START\tBIT(31)\n#define I2C_CMD_WITH_ADDR\tBIT(30)\n#define I2C_CMD_RD_CONT\t\tBIT(29)\n#define I2C_CMD_WITH_STOP\tBIT(28)\n#define I2C_CMD_FORCELAUNCH\tBIT(27)\n#define I2C_CMD_ADDR\t\tGENMASK(23, 17)\n#define I2C_CMD_READ\t\tBIT(16)\n#define I2C_CMD_LEN\t\tGENMASK(15, 0)\n\n \n#define I2C_MODE_CLKDIV\t\tGENMASK(31, 16)\n#define I2C_MODE_PORT\t\tGENMASK(15, 10)\n#define I2C_MODE_ENHANCED\tBIT(3)\n#define I2C_MODE_DIAG\t\tBIT(2)\n#define I2C_MODE_PACE_ALLOW\tBIT(1)\n#define I2C_MODE_WRAP\t\tBIT(0)\n\n \n#define I2C_WATERMARK_HI\tGENMASK(15, 12)\n#define I2C_WATERMARK_LO\tGENMASK(7, 4)\n\n#define I2C_FIFO_HI_LVL\t\t4\n#define I2C_FIFO_LO_LVL\t\t4\n\n \n#define I2C_INT_INV_CMD\t\tBIT(15)\n#define I2C_INT_PARITY\t\tBIT(14)\n#define I2C_INT_BE_OVERRUN\tBIT(13)\n#define I2C_INT_BE_ACCESS\tBIT(12)\n#define I2C_INT_LOST_ARB\tBIT(11)\n#define I2C_INT_NACK\t\tBIT(10)\n#define I2C_INT_DAT_REQ\t\tBIT(9)\n#define I2C_INT_CMD_COMP\tBIT(8)\n#define I2C_INT_STOP_ERR\tBIT(7)\n#define I2C_INT_BUSY\t\tBIT(6)\n#define I2C_INT_IDLE\t\tBIT(5)\n\n \n#define I2C_STAT_INV_CMD\tBIT(31)\n#define I2C_STAT_PARITY\t\tBIT(30)\n#define I2C_STAT_BE_OVERRUN\tBIT(29)\n#define I2C_STAT_BE_ACCESS\tBIT(28)\n#define I2C_STAT_LOST_ARB\tBIT(27)\n#define I2C_STAT_NACK\t\tBIT(26)\n#define I2C_STAT_DAT_REQ\tBIT(25)\n#define I2C_STAT_CMD_COMP\tBIT(24)\n#define I2C_STAT_STOP_ERR\tBIT(23)\n#define I2C_STAT_MAX_PORT\tGENMASK(22, 16)\n#define I2C_STAT_ANY_INT\tBIT(15)\n#define I2C_STAT_SCL_IN\t\tBIT(11)\n#define I2C_STAT_SDA_IN\t\tBIT(10)\n#define I2C_STAT_PORT_BUSY\tBIT(9)\n#define I2C_STAT_SELF_BUSY\tBIT(8)\n#define I2C_STAT_FIFO_COUNT\tGENMASK(7, 0)\n\n#define I2C_STAT_ERR\t\t(I2C_STAT_INV_CMD |\t\t\t\\\n\t\t\t\t I2C_STAT_PARITY |\t\t\t\\\n\t\t\t\t I2C_STAT_BE_OVERRUN |\t\t\t\\\n\t\t\t\t I2C_STAT_BE_ACCESS |\t\t\t\\\n\t\t\t\t I2C_STAT_LOST_ARB |\t\t\t\\\n\t\t\t\t I2C_STAT_NACK |\t\t\t\\\n\t\t\t\t I2C_STAT_STOP_ERR)\n#define I2C_STAT_ANY_RESP\t(I2C_STAT_ERR |\t\t\t\t\\\n\t\t\t\t I2C_STAT_DAT_REQ |\t\t\t\\\n\t\t\t\t I2C_STAT_CMD_COMP)\n\n \n#define I2C_ESTAT_FIFO_SZ\tGENMASK(31, 24)\n#define I2C_ESTAT_SCL_IN_SY\tBIT(15)\n#define I2C_ESTAT_SDA_IN_SY\tBIT(14)\n#define I2C_ESTAT_S_SCL\t\tBIT(13)\n#define I2C_ESTAT_S_SDA\t\tBIT(12)\n#define I2C_ESTAT_M_SCL\t\tBIT(11)\n#define I2C_ESTAT_M_SDA\t\tBIT(10)\n#define I2C_ESTAT_HI_WATER\tBIT(9)\n#define I2C_ESTAT_LO_WATER\tBIT(8)\n#define I2C_ESTAT_PORT_BUSY\tBIT(7)\n#define I2C_ESTAT_SELF_BUSY\tBIT(6)\n#define I2C_ESTAT_VERSION\tGENMASK(4, 0)\n\n \n#define I2C_PORT_BUSY_RESET\tBIT(31)\n\n \n#define I2C_CMD_SLEEP_MAX_US\t500\n#define I2C_CMD_SLEEP_MIN_US\t50\n\n \n#define I2C_RESET_SLEEP_MAX_US\t2000\n#define I2C_RESET_SLEEP_MIN_US\t1000\n\n \n#define I2C_ABORT_TIMEOUT\tmsecs_to_jiffies(100)\n\nstruct fsi_i2c_master {\n\tstruct fsi_device\t*fsi;\n\tu8\t\t\tfifo_size;\n\tstruct list_head\tports;\n\tstruct mutex\t\tlock;\n};\n\nstruct fsi_i2c_port {\n\tstruct list_head\tlist;\n\tstruct i2c_adapter\tadapter;\n\tstruct fsi_i2c_master\t*master;\n\tu16\t\t\tport;\n\tu16\t\t\txfrd;\n};\n\nstatic int fsi_i2c_read_reg(struct fsi_device *fsi, unsigned int reg,\n\t\t\t    u32 *data)\n{\n\tint rc;\n\t__be32 data_be;\n\n\trc = fsi_device_read(fsi, reg, &data_be, sizeof(data_be));\n\tif (rc)\n\t\treturn rc;\n\n\t*data = be32_to_cpu(data_be);\n\n\treturn 0;\n}\n\nstatic int fsi_i2c_write_reg(struct fsi_device *fsi, unsigned int reg,\n\t\t\t     u32 *data)\n{\n\t__be32 data_be = cpu_to_be32p(data);\n\n\treturn fsi_device_write(fsi, reg, &data_be, sizeof(data_be));\n}\n\nstatic int fsi_i2c_dev_init(struct fsi_i2c_master *i2c)\n{\n\tint rc;\n\tu32 mode = I2C_MODE_ENHANCED, extended_status, watermark;\n\tu32 interrupt = 0;\n\n\t \n\trc = fsi_i2c_write_reg(i2c->fsi, I2C_FSI_INT_MASK, &interrupt);\n\tif (rc)\n\t\treturn rc;\n\n\tmode |= FIELD_PREP(I2C_MODE_CLKDIV, I2C_DEFAULT_CLK_DIV);\n\trc = fsi_i2c_write_reg(i2c->fsi, I2C_FSI_MODE, &mode);\n\tif (rc)\n\t\treturn rc;\n\n\trc = fsi_i2c_read_reg(i2c->fsi, I2C_FSI_ESTAT, &extended_status);\n\tif (rc)\n\t\treturn rc;\n\n\ti2c->fifo_size = FIELD_GET(I2C_ESTAT_FIFO_SZ, extended_status);\n\twatermark = FIELD_PREP(I2C_WATERMARK_HI,\n\t\t\t       i2c->fifo_size - I2C_FIFO_HI_LVL);\n\twatermark |= FIELD_PREP(I2C_WATERMARK_LO, I2C_FIFO_LO_LVL);\n\n\treturn fsi_i2c_write_reg(i2c->fsi, I2C_FSI_WATER_MARK, &watermark);\n}\n\nstatic int fsi_i2c_set_port(struct fsi_i2c_port *port)\n{\n\tint rc;\n\tstruct fsi_device *fsi = port->master->fsi;\n\tu32 mode, dummy = 0;\n\n\trc = fsi_i2c_read_reg(fsi, I2C_FSI_MODE, &mode);\n\tif (rc)\n\t\treturn rc;\n\n\tif (FIELD_GET(I2C_MODE_PORT, mode) == port->port)\n\t\treturn 0;\n\n\tmode = (mode & ~I2C_MODE_PORT) | FIELD_PREP(I2C_MODE_PORT, port->port);\n\trc = fsi_i2c_write_reg(fsi, I2C_FSI_MODE, &mode);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\treturn fsi_i2c_write_reg(fsi, I2C_FSI_RESET_ERR, &dummy);\n}\n\nstatic int fsi_i2c_start(struct fsi_i2c_port *port, struct i2c_msg *msg,\n\t\t\t bool stop)\n{\n\tstruct fsi_i2c_master *i2c = port->master;\n\tu32 cmd = I2C_CMD_WITH_START | I2C_CMD_WITH_ADDR;\n\n\tport->xfrd = 0;\n\n\tif (msg->flags & I2C_M_RD)\n\t\tcmd |= I2C_CMD_READ;\n\n\tif (stop || msg->flags & I2C_M_STOP)\n\t\tcmd |= I2C_CMD_WITH_STOP;\n\n\tcmd |= FIELD_PREP(I2C_CMD_ADDR, msg->addr);\n\tcmd |= FIELD_PREP(I2C_CMD_LEN, msg->len);\n\n\treturn fsi_i2c_write_reg(i2c->fsi, I2C_FSI_CMD, &cmd);\n}\n\nstatic int fsi_i2c_get_op_bytes(int op_bytes)\n{\n\t \n\tif (op_bytes > 4)\n\t\treturn 4;\n\telse if (op_bytes == 3)\n\t\treturn 2;\n\treturn op_bytes;\n}\n\nstatic int fsi_i2c_write_fifo(struct fsi_i2c_port *port, struct i2c_msg *msg,\n\t\t\t      u8 fifo_count)\n{\n\tint write;\n\tint rc;\n\tstruct fsi_i2c_master *i2c = port->master;\n\tint bytes_to_write = i2c->fifo_size - fifo_count;\n\tint bytes_remaining = msg->len - port->xfrd;\n\n\tbytes_to_write = min(bytes_to_write, bytes_remaining);\n\n\twhile (bytes_to_write) {\n\t\twrite = fsi_i2c_get_op_bytes(bytes_to_write);\n\n\t\trc = fsi_device_write(i2c->fsi, I2C_FSI_FIFO,\n\t\t\t\t      &msg->buf[port->xfrd], write);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\tport->xfrd += write;\n\t\tbytes_to_write -= write;\n\t}\n\n\treturn 0;\n}\n\nstatic int fsi_i2c_read_fifo(struct fsi_i2c_port *port, struct i2c_msg *msg,\n\t\t\t     u8 fifo_count)\n{\n\tint read;\n\tint rc;\n\tstruct fsi_i2c_master *i2c = port->master;\n\tint bytes_to_read;\n\tint xfr_remaining = msg->len - port->xfrd;\n\tu32 dummy;\n\n\tbytes_to_read = min_t(int, fifo_count, xfr_remaining);\n\n\twhile (bytes_to_read) {\n\t\tread = fsi_i2c_get_op_bytes(bytes_to_read);\n\n\t\tif (xfr_remaining) {\n\t\t\trc = fsi_device_read(i2c->fsi, I2C_FSI_FIFO,\n\t\t\t\t\t     &msg->buf[port->xfrd], read);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\n\t\t\tport->xfrd += read;\n\t\t\txfr_remaining -= read;\n\t\t} else {\n\t\t\t \n\t\t\trc = fsi_device_read(i2c->fsi, I2C_FSI_FIFO, &dummy,\n\t\t\t\t\t     read);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t}\n\n\t\tbytes_to_read -= read;\n\t}\n\n\treturn 0;\n}\n\nstatic int fsi_i2c_get_scl(struct i2c_adapter *adap)\n{\n\tu32 stat = 0;\n\tstruct fsi_i2c_port *port = adap->algo_data;\n\tstruct fsi_i2c_master *i2c = port->master;\n\n\tfsi_i2c_read_reg(i2c->fsi, I2C_FSI_STAT, &stat);\n\n\treturn !!(stat & I2C_STAT_SCL_IN);\n}\n\nstatic void fsi_i2c_set_scl(struct i2c_adapter *adap, int val)\n{\n\tu32 dummy = 0;\n\tstruct fsi_i2c_port *port = adap->algo_data;\n\tstruct fsi_i2c_master *i2c = port->master;\n\n\tif (val)\n\t\tfsi_i2c_write_reg(i2c->fsi, I2C_FSI_SET_SCL, &dummy);\n\telse\n\t\tfsi_i2c_write_reg(i2c->fsi, I2C_FSI_RESET_SCL, &dummy);\n}\n\nstatic int fsi_i2c_get_sda(struct i2c_adapter *adap)\n{\n\tu32 stat = 0;\n\tstruct fsi_i2c_port *port = adap->algo_data;\n\tstruct fsi_i2c_master *i2c = port->master;\n\n\tfsi_i2c_read_reg(i2c->fsi, I2C_FSI_STAT, &stat);\n\n\treturn !!(stat & I2C_STAT_SDA_IN);\n}\n\nstatic void fsi_i2c_set_sda(struct i2c_adapter *adap, int val)\n{\n\tu32 dummy = 0;\n\tstruct fsi_i2c_port *port = adap->algo_data;\n\tstruct fsi_i2c_master *i2c = port->master;\n\n\tif (val)\n\t\tfsi_i2c_write_reg(i2c->fsi, I2C_FSI_SET_SDA, &dummy);\n\telse\n\t\tfsi_i2c_write_reg(i2c->fsi, I2C_FSI_RESET_SDA, &dummy);\n}\n\nstatic void fsi_i2c_prepare_recovery(struct i2c_adapter *adap)\n{\n\tint rc;\n\tu32 mode;\n\tstruct fsi_i2c_port *port = adap->algo_data;\n\tstruct fsi_i2c_master *i2c = port->master;\n\n\trc = fsi_i2c_read_reg(i2c->fsi, I2C_FSI_MODE, &mode);\n\tif (rc)\n\t\treturn;\n\n\tmode |= I2C_MODE_DIAG;\n\tfsi_i2c_write_reg(i2c->fsi, I2C_FSI_MODE, &mode);\n}\n\nstatic void fsi_i2c_unprepare_recovery(struct i2c_adapter *adap)\n{\n\tint rc;\n\tu32 mode;\n\tstruct fsi_i2c_port *port = adap->algo_data;\n\tstruct fsi_i2c_master *i2c = port->master;\n\n\trc = fsi_i2c_read_reg(i2c->fsi, I2C_FSI_MODE, &mode);\n\tif (rc)\n\t\treturn;\n\n\tmode &= ~I2C_MODE_DIAG;\n\tfsi_i2c_write_reg(i2c->fsi, I2C_FSI_MODE, &mode);\n}\n\nstatic int fsi_i2c_reset_bus(struct fsi_i2c_master *i2c,\n\t\t\t     struct fsi_i2c_port *port)\n{\n\tint rc;\n\tu32 stat, dummy = 0;\n\n\t \n\ti2c_recover_bus(&port->adapter);\n\n\t \n\trc = fsi_i2c_write_reg(i2c->fsi, I2C_FSI_RESET_ERR, &dummy);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tusleep_range(I2C_RESET_SLEEP_MIN_US, I2C_RESET_SLEEP_MAX_US);\n\n\trc = fsi_i2c_read_reg(i2c->fsi, I2C_FSI_STAT, &stat);\n\tif (rc)\n\t\treturn rc;\n\n\tif (stat & I2C_STAT_CMD_COMP)\n\t\treturn 0;\n\n\t \n\trc = fsi_i2c_write_reg(i2c->fsi, I2C_FSI_RESET_I2C, &dummy);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\treturn fsi_i2c_dev_init(i2c);\n}\n\nstatic int fsi_i2c_reset_engine(struct fsi_i2c_master *i2c, u16 port)\n{\n\tint rc;\n\tu32 mode, dummy = 0;\n\n\t \n\trc = fsi_i2c_write_reg(i2c->fsi, I2C_FSI_RESET_I2C, &dummy);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\trc = fsi_i2c_dev_init(i2c);\n\tif (rc)\n\t\treturn rc;\n\n\trc = fsi_i2c_read_reg(i2c->fsi, I2C_FSI_MODE, &mode);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tif (port) {\n\t\tmode &= ~I2C_MODE_PORT;\n\t\tmode |= FIELD_PREP(I2C_MODE_PORT, port);\n\t\trc = fsi_i2c_write_reg(i2c->fsi, I2C_FSI_MODE, &mode);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\t \n\tdummy = I2C_PORT_BUSY_RESET;\n\trc = fsi_i2c_write_reg(i2c->fsi, I2C_FSI_PORT_BUSY, &dummy);\n\tif (rc)\n\t\treturn rc;\n\n\treturn 0;\n}\n\nstatic int fsi_i2c_abort(struct fsi_i2c_port *port, u32 status)\n{\n\tint rc;\n\tunsigned long start;\n\tu32 cmd = I2C_CMD_WITH_STOP;\n\tu32 stat;\n\tstruct fsi_i2c_master *i2c = port->master;\n\tstruct fsi_device *fsi = i2c->fsi;\n\n\trc = fsi_i2c_reset_engine(i2c, port->port);\n\tif (rc)\n\t\treturn rc;\n\n\trc = fsi_i2c_read_reg(fsi, I2C_FSI_STAT, &stat);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tif (!(stat & I2C_STAT_SDA_IN)) {\n\t\trc = fsi_i2c_reset_bus(i2c, port);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\t \n\tif (status & (I2C_STAT_PARITY | I2C_STAT_LOST_ARB | I2C_STAT_STOP_ERR))\n\t\treturn 0;\n\n\t \n\trc = fsi_i2c_write_reg(fsi, I2C_FSI_CMD, &cmd);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tstart = jiffies;\n\n\tdo {\n\t\trc = fsi_i2c_read_reg(fsi, I2C_FSI_STAT, &status);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\tif (status & I2C_STAT_CMD_COMP)\n\t\t\treturn 0;\n\n\t\tusleep_range(I2C_CMD_SLEEP_MIN_US, I2C_CMD_SLEEP_MAX_US);\n\t} while (time_after(start + I2C_ABORT_TIMEOUT, jiffies));\n\n\treturn -ETIMEDOUT;\n}\n\nstatic int fsi_i2c_handle_status(struct fsi_i2c_port *port,\n\t\t\t\t struct i2c_msg *msg, u32 status)\n{\n\tint rc;\n\tu8 fifo_count;\n\n\tif (status & I2C_STAT_ERR) {\n\t\trc = fsi_i2c_abort(port, status);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\tif (status & I2C_STAT_INV_CMD)\n\t\t\treturn -EINVAL;\n\n\t\tif (status & (I2C_STAT_PARITY | I2C_STAT_BE_OVERRUN |\n\t\t    I2C_STAT_BE_ACCESS))\n\t\t\treturn -EPROTO;\n\n\t\tif (status & I2C_STAT_NACK)\n\t\t\treturn -ENXIO;\n\n\t\tif (status & I2C_STAT_LOST_ARB)\n\t\t\treturn -EAGAIN;\n\n\t\tif (status & I2C_STAT_STOP_ERR)\n\t\t\treturn -EBADMSG;\n\n\t\treturn -EIO;\n\t}\n\n\tif (status & I2C_STAT_DAT_REQ) {\n\t\tfifo_count = FIELD_GET(I2C_STAT_FIFO_COUNT, status);\n\n\t\tif (msg->flags & I2C_M_RD)\n\t\t\treturn fsi_i2c_read_fifo(port, msg, fifo_count);\n\n\t\treturn fsi_i2c_write_fifo(port, msg, fifo_count);\n\t}\n\n\tif (status & I2C_STAT_CMD_COMP) {\n\t\tif (port->xfrd < msg->len)\n\t\t\treturn -ENODATA;\n\n\t\treturn msg->len;\n\t}\n\n\treturn 0;\n}\n\nstatic int fsi_i2c_wait(struct fsi_i2c_port *port, struct i2c_msg *msg,\n\t\t\tunsigned long timeout)\n{\n\tu32 status = 0;\n\tint rc;\n\tunsigned long start = jiffies;\n\n\tdo {\n\t\trc = fsi_i2c_read_reg(port->master->fsi, I2C_FSI_STAT,\n\t\t\t\t      &status);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\tif (status & I2C_STAT_ANY_RESP) {\n\t\t\trc = fsi_i2c_handle_status(port, msg, status);\n\t\t\tif (rc < 0)\n\t\t\t\treturn rc;\n\n\t\t\t \n\t\t\tif (rc == msg->len)\n\t\t\t\treturn 0;\n\n\t\t\t \n\t\t\tcontinue;\n\t\t}\n\n\t\tusleep_range(I2C_CMD_SLEEP_MIN_US, I2C_CMD_SLEEP_MAX_US);\n\t} while (time_after(start + timeout, jiffies));\n\n\treturn -ETIMEDOUT;\n}\n\nstatic int fsi_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs,\n\t\t\tint num)\n{\n\tint i, rc;\n\tunsigned long start_time;\n\tstruct fsi_i2c_port *port = adap->algo_data;\n\tstruct fsi_i2c_master *master = port->master;\n\tstruct i2c_msg *msg;\n\n\tmutex_lock(&master->lock);\n\n\trc = fsi_i2c_set_port(port);\n\tif (rc)\n\t\tgoto unlock;\n\n\tfor (i = 0; i < num; i++) {\n\t\tmsg = msgs + i;\n\t\tstart_time = jiffies;\n\n\t\trc = fsi_i2c_start(port, msg, i == num - 1);\n\t\tif (rc)\n\t\t\tgoto unlock;\n\n\t\trc = fsi_i2c_wait(port, msg,\n\t\t\t\t  adap->timeout - (jiffies - start_time));\n\t\tif (rc)\n\t\t\tgoto unlock;\n\t}\n\nunlock:\n\tmutex_unlock(&master->lock);\n\treturn rc ? : num;\n}\n\nstatic u32 fsi_i2c_functionality(struct i2c_adapter *adap)\n{\n\treturn I2C_FUNC_I2C | I2C_FUNC_PROTOCOL_MANGLING |\n\t\tI2C_FUNC_SMBUS_EMUL | I2C_FUNC_SMBUS_BLOCK_DATA;\n}\n\nstatic struct i2c_bus_recovery_info fsi_i2c_bus_recovery_info = {\n\t.recover_bus = i2c_generic_scl_recovery,\n\t.get_scl = fsi_i2c_get_scl,\n\t.set_scl = fsi_i2c_set_scl,\n\t.get_sda = fsi_i2c_get_sda,\n\t.set_sda = fsi_i2c_set_sda,\n\t.prepare_recovery = fsi_i2c_prepare_recovery,\n\t.unprepare_recovery = fsi_i2c_unprepare_recovery,\n};\n\nstatic const struct i2c_algorithm fsi_i2c_algorithm = {\n\t.master_xfer = fsi_i2c_xfer,\n\t.functionality = fsi_i2c_functionality,\n};\n\nstatic struct device_node *fsi_i2c_find_port_of_node(struct device_node *fsi,\n\t\t\t\t\t\t     int port)\n{\n\tstruct device_node *np;\n\tu32 port_no;\n\tint rc;\n\n\tfor_each_child_of_node(fsi, np) {\n\t\trc = of_property_read_u32(np, \"reg\", &port_no);\n\t\tif (!rc && port_no == port)\n\t\t\treturn np;\n\t}\n\n\treturn NULL;\n}\n\nstatic int fsi_i2c_probe(struct device *dev)\n{\n\tstruct fsi_i2c_master *i2c;\n\tstruct fsi_i2c_port *port;\n\tstruct device_node *np;\n\tu32 port_no, ports, stat;\n\tint rc;\n\n\ti2c = devm_kzalloc(dev, sizeof(*i2c), GFP_KERNEL);\n\tif (!i2c)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&i2c->lock);\n\ti2c->fsi = to_fsi_dev(dev);\n\tINIT_LIST_HEAD(&i2c->ports);\n\n\trc = fsi_i2c_dev_init(i2c);\n\tif (rc)\n\t\treturn rc;\n\n\trc = fsi_i2c_read_reg(i2c->fsi, I2C_FSI_STAT, &stat);\n\tif (rc)\n\t\treturn rc;\n\n\tports = FIELD_GET(I2C_STAT_MAX_PORT, stat) + 1;\n\tdev_dbg(dev, \"I2C master has %d ports\\n\", ports);\n\n\tfor (port_no = 0; port_no < ports; port_no++) {\n\t\tnp = fsi_i2c_find_port_of_node(dev->of_node, port_no);\n\t\tif (!of_device_is_available(np))\n\t\t\tcontinue;\n\n\t\tport = kzalloc(sizeof(*port), GFP_KERNEL);\n\t\tif (!port) {\n\t\t\tof_node_put(np);\n\t\t\tbreak;\n\t\t}\n\n\t\tport->master = i2c;\n\t\tport->port = port_no;\n\n\t\tport->adapter.owner = THIS_MODULE;\n\t\tport->adapter.dev.of_node = np;\n\t\tport->adapter.dev.parent = dev;\n\t\tport->adapter.algo = &fsi_i2c_algorithm;\n\t\tport->adapter.bus_recovery_info = &fsi_i2c_bus_recovery_info;\n\t\tport->adapter.algo_data = port;\n\n\t\tsnprintf(port->adapter.name, sizeof(port->adapter.name),\n\t\t\t \"i2c_bus-%u\", port_no);\n\n\t\trc = i2c_add_adapter(&port->adapter);\n\t\tif (rc < 0) {\n\t\t\tdev_err(dev, \"Failed to register adapter: %d\\n\", rc);\n\t\t\tkfree(port);\n\t\t\tcontinue;\n\t\t}\n\n\t\tlist_add(&port->list, &i2c->ports);\n\t}\n\n\tdev_set_drvdata(dev, i2c);\n\n\treturn 0;\n}\n\nstatic int fsi_i2c_remove(struct device *dev)\n{\n\tstruct fsi_i2c_master *i2c = dev_get_drvdata(dev);\n\tstruct fsi_i2c_port *port, *tmp;\n\n\tlist_for_each_entry_safe(port, tmp, &i2c->ports, list) {\n\t\tlist_del(&port->list);\n\t\ti2c_del_adapter(&port->adapter);\n\t\tkfree(port);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct fsi_device_id fsi_i2c_ids[] = {\n\t{ FSI_ENGID_I2C, FSI_VERSION_ANY },\n\t{ }\n};\n\nstatic struct fsi_driver fsi_i2c_driver = {\n\t.id_table = fsi_i2c_ids,\n\t.drv = {\n\t\t.name = \"i2c-fsi\",\n\t\t.bus = &fsi_bus_type,\n\t\t.probe = fsi_i2c_probe,\n\t\t.remove = fsi_i2c_remove,\n\t},\n};\n\nmodule_fsi_driver(fsi_i2c_driver);\n\nMODULE_AUTHOR(\"Eddie James <eajames@us.ibm.com>\");\nMODULE_DESCRIPTION(\"FSI attached I2C master\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}