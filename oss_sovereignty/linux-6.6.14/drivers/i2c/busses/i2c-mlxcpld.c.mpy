{
  "module_name": "i2c-mlxcpld.c",
  "hash_id": "09a7948a5932859646ae586c4e305ca57bb838f65451f7505ad0004c0d811a0b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-mlxcpld.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/i2c.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/platform_data/mlxreg.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n\n \n#define MLXPLAT_CPLD_LPC_I2C_BASE_ADDR\t0x2000\n#define MLXCPLD_I2C_DEVICE_NAME\t\t\"i2c_mlxcpld\"\n#define MLXCPLD_I2C_VALID_FLAG\t\t(I2C_M_RECV_LEN | I2C_M_RD)\n#define MLXCPLD_I2C_BUS_NUM\t\t1\n#define MLXCPLD_I2C_DATA_REG_SZ\t\t36\n#define MLXCPLD_I2C_DATA_SZ_BIT\t\tBIT(5)\n#define MLXCPLD_I2C_DATA_EXT2_SZ_BIT\tBIT(6)\n#define MLXCPLD_I2C_DATA_SZ_MASK\tGENMASK(6, 5)\n#define MLXCPLD_I2C_SMBUS_BLK_BIT\tBIT(7)\n#define MLXCPLD_I2C_MAX_ADDR_LEN\t4\n#define MLXCPLD_I2C_RETR_NUM\t\t2\n#define MLXCPLD_I2C_XFER_TO\t\t500000  \n#define MLXCPLD_I2C_POLL_TIME\t\t200    \n\n \n#define MLXCPLD_LPCI2C_CPBLTY_REG\t0x0\n#define MLXCPLD_LPCI2C_CTRL_REG\t\t0x1\n#define MLXCPLD_LPCI2C_HALF_CYC_REG\t0x4\n#define MLXCPLD_LPCI2C_I2C_HOLD_REG\t0x5\n#define MLXCPLD_LPCI2C_CMD_REG\t\t0x6\n#define MLXCPLD_LPCI2C_NUM_DAT_REG\t0x7\n#define MLXCPLD_LPCI2C_NUM_ADDR_REG\t0x8\n#define MLXCPLD_LPCI2C_STATUS_REG\t0x9\n#define MLXCPLD_LPCI2C_DATA_REG\t\t0xa\n\n \n#define MLXCPLD_LPCI2C_RST_SEL_MASK\t0x1\n#define MLXCPLD_LPCI2C_TRANS_END\t0x1\n#define MLXCPLD_LPCI2C_STATUS_NACK\t0x10\n#define MLXCPLD_LPCI2C_NO_IND\t\t0\n#define MLXCPLD_LPCI2C_ACK_IND\t\t1\n#define MLXCPLD_LPCI2C_NACK_IND\t\t2\n\n#define MLXCPLD_I2C_FREQ_1000KHZ_SET\t0x04\n#define MLXCPLD_I2C_FREQ_400KHZ_SET\t0x0e\n#define MLXCPLD_I2C_FREQ_100KHZ_SET\t0x42\n\nenum mlxcpld_i2c_frequency {\n\tMLXCPLD_I2C_FREQ_1000KHZ = 1,\n\tMLXCPLD_I2C_FREQ_400KHZ = 2,\n\tMLXCPLD_I2C_FREQ_100KHZ = 3,\n};\n\nstruct  mlxcpld_i2c_curr_xfer {\n\tu8 cmd;\n\tu8 addr_width;\n\tu8 data_len;\n\tu8 msg_num;\n\tstruct i2c_msg *msg;\n};\n\nstruct mlxcpld_i2c_priv {\n\tstruct i2c_adapter adap;\n\tu32 base_addr;\n\tstruct mutex lock;\n\tstruct  mlxcpld_i2c_curr_xfer xfer;\n\tstruct device *dev;\n\tbool smbus_block;\n\tint polling_time;\n};\n\nstatic void mlxcpld_i2c_lpc_write_buf(u8 *data, u8 len, u32 addr)\n{\n\tint i;\n\n\tfor (i = 0; i < len - len % 4; i += 4)\n\t\toutl(*(u32 *)(data + i), addr + i);\n\tfor (; i < len; ++i)\n\t\toutb(*(data + i), addr + i);\n}\n\nstatic void mlxcpld_i2c_lpc_read_buf(u8 *data, u8 len, u32 addr)\n{\n\tint i;\n\n\tfor (i = 0; i < len - len % 4; i += 4)\n\t\t*(u32 *)(data + i) = inl(addr + i);\n\tfor (; i < len; ++i)\n\t\t*(data + i) = inb(addr + i);\n}\n\nstatic void mlxcpld_i2c_read_comm(struct mlxcpld_i2c_priv *priv, u8 offs,\n\t\t\t\t  u8 *data, u8 datalen)\n{\n\tu32 addr = priv->base_addr + offs;\n\n\tswitch (datalen) {\n\tcase 1:\n\t\t*(data) = inb(addr);\n\t\tbreak;\n\tcase 2:\n\t\t*((u16 *)data) = inw(addr);\n\t\tbreak;\n\tcase 3:\n\t\t*((u16 *)data) = inw(addr);\n\t\t*(data + 2) = inb(addr + 2);\n\t\tbreak;\n\tcase 4:\n\t\t*((u32 *)data) = inl(addr);\n\t\tbreak;\n\tdefault:\n\t\tmlxcpld_i2c_lpc_read_buf(data, datalen, addr);\n\t\tbreak;\n\t}\n}\n\nstatic void mlxcpld_i2c_write_comm(struct mlxcpld_i2c_priv *priv, u8 offs,\n\t\t\t\t   u8 *data, u8 datalen)\n{\n\tu32 addr = priv->base_addr + offs;\n\n\tswitch (datalen) {\n\tcase 1:\n\t\toutb(*(data), addr);\n\t\tbreak;\n\tcase 2:\n\t\toutw(*((u16 *)data), addr);\n\t\tbreak;\n\tcase 3:\n\t\toutw(*((u16 *)data), addr);\n\t\toutb(*(data + 2), addr + 2);\n\t\tbreak;\n\tcase 4:\n\t\toutl(*((u32 *)data), addr);\n\t\tbreak;\n\tdefault:\n\t\tmlxcpld_i2c_lpc_write_buf(data, datalen, addr);\n\t\tbreak;\n\t}\n}\n\n \nstatic int mlxcpld_i2c_check_msg_params(struct mlxcpld_i2c_priv *priv,\n\t\t\t\t\tstruct i2c_msg *msgs, int num)\n{\n\tint i;\n\n\tif (!num) {\n\t\tdev_err(priv->dev, \"Incorrect 0 num of messages\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (unlikely(msgs[0].addr > 0x7f)) {\n\t\tdev_err(priv->dev, \"Invalid address 0x%03x\\n\",\n\t\t\tmsgs[0].addr);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < num; ++i) {\n\t\tif (unlikely(!msgs[i].buf)) {\n\t\t\tdev_err(priv->dev, \"Invalid buf in msg[%d]\\n\",\n\t\t\t\ti);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (unlikely(msgs[0].addr != msgs[i].addr)) {\n\t\t\tdev_err(priv->dev, \"Invalid addr in msg[%d]\\n\",\n\t\t\t\ti);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int mlxcpld_i2c_check_status(struct mlxcpld_i2c_priv *priv, int *status)\n{\n\tu8 val;\n\n\tmlxcpld_i2c_read_comm(priv, MLXCPLD_LPCI2C_STATUS_REG, &val, 1);\n\n\tif (val & MLXCPLD_LPCI2C_TRANS_END) {\n\t\tif (val & MLXCPLD_LPCI2C_STATUS_NACK)\n\t\t\t \n\t\t\t*status = MLXCPLD_LPCI2C_NACK_IND;\n\t\telse\n\t\t\t*status = MLXCPLD_LPCI2C_ACK_IND;\n\t\treturn 0;\n\t}\n\t*status = MLXCPLD_LPCI2C_NO_IND;\n\n\treturn -EIO;\n}\n\nstatic void mlxcpld_i2c_set_transf_data(struct mlxcpld_i2c_priv *priv,\n\t\t\t\t\tstruct i2c_msg *msgs, int num,\n\t\t\t\t\tu8 comm_len)\n{\n\tpriv->xfer.msg = msgs;\n\tpriv->xfer.msg_num = num;\n\n\t \n\tpriv->xfer.cmd = msgs[num - 1].flags & I2C_M_RD;\n\n\tif (priv->xfer.cmd == I2C_M_RD && comm_len != msgs[0].len) {\n\t\tpriv->xfer.addr_width = msgs[0].len;\n\t\tpriv->xfer.data_len = comm_len - priv->xfer.addr_width;\n\t} else {\n\t\tpriv->xfer.addr_width = 0;\n\t\tpriv->xfer.data_len = comm_len;\n\t}\n}\n\n \nstatic void mlxcpld_i2c_reset(struct mlxcpld_i2c_priv *priv)\n{\n\tu8 val;\n\n\tmutex_lock(&priv->lock);\n\n\tmlxcpld_i2c_read_comm(priv, MLXCPLD_LPCI2C_CTRL_REG, &val, 1);\n\tval &= ~MLXCPLD_LPCI2C_RST_SEL_MASK;\n\tmlxcpld_i2c_write_comm(priv, MLXCPLD_LPCI2C_CTRL_REG, &val, 1);\n\n\tmutex_unlock(&priv->lock);\n}\n\n \nstatic int mlxcpld_i2c_check_busy(struct mlxcpld_i2c_priv *priv)\n{\n\tu8 val;\n\n\tmlxcpld_i2c_read_comm(priv, MLXCPLD_LPCI2C_STATUS_REG, &val, 1);\n\n\tif (val & MLXCPLD_LPCI2C_TRANS_END)\n\t\treturn 0;\n\n\treturn -EIO;\n}\n\nstatic int mlxcpld_i2c_wait_for_free(struct mlxcpld_i2c_priv *priv)\n{\n\tint timeout = 0;\n\n\tdo {\n\t\tif (!mlxcpld_i2c_check_busy(priv))\n\t\t\tbreak;\n\t\tusleep_range(priv->polling_time / 2, priv->polling_time);\n\t\ttimeout += priv->polling_time;\n\t} while (timeout <= MLXCPLD_I2C_XFER_TO);\n\n\tif (timeout > MLXCPLD_I2C_XFER_TO)\n\t\treturn -ETIMEDOUT;\n\n\treturn 0;\n}\n\n \nstatic int mlxcpld_i2c_wait_for_tc(struct mlxcpld_i2c_priv *priv)\n{\n\tint status, i, timeout = 0;\n\tu8 datalen, val;\n\n\tdo {\n\t\tusleep_range(priv->polling_time / 2, priv->polling_time);\n\t\tif (!mlxcpld_i2c_check_status(priv, &status))\n\t\t\tbreak;\n\t\ttimeout += priv->polling_time;\n\t} while (status == 0 && timeout < MLXCPLD_I2C_XFER_TO);\n\n\tswitch (status) {\n\tcase MLXCPLD_LPCI2C_NO_IND:\n\t\treturn -ETIMEDOUT;\n\n\tcase MLXCPLD_LPCI2C_ACK_IND:\n\t\tif (priv->xfer.cmd != I2C_M_RD)\n\t\t\treturn (priv->xfer.addr_width + priv->xfer.data_len);\n\n\t\tif (priv->xfer.msg_num == 1)\n\t\t\ti = 0;\n\t\telse\n\t\t\ti = 1;\n\n\t\tif (!priv->xfer.msg[i].buf)\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tmlxcpld_i2c_read_comm(priv, MLXCPLD_LPCI2C_NUM_ADDR_REG, &val,\n\t\t\t\t      1);\n\t\tif (priv->smbus_block && (val & MLXCPLD_I2C_SMBUS_BLK_BIT)) {\n\t\t\tmlxcpld_i2c_read_comm(priv, MLXCPLD_LPCI2C_NUM_DAT_REG,\n\t\t\t\t\t      &datalen, 1);\n\t\t\tif (unlikely(datalen > I2C_SMBUS_BLOCK_MAX)) {\n\t\t\t\tdev_err(priv->dev, \"Incorrect smbus block read message len\\n\");\n\t\t\t\treturn -EPROTO;\n\t\t\t}\n\t\t} else {\n\t\t\tdatalen = priv->xfer.data_len;\n\t\t}\n\n\t\tmlxcpld_i2c_read_comm(priv, MLXCPLD_LPCI2C_DATA_REG,\n\t\t\t\t      priv->xfer.msg[i].buf, datalen);\n\n\t\treturn datalen;\n\n\tcase MLXCPLD_LPCI2C_NACK_IND:\n\t\treturn -ENXIO;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic void mlxcpld_i2c_xfer_msg(struct mlxcpld_i2c_priv *priv)\n{\n\tint i, len = 0;\n\tu8 cmd, val;\n\n\tmlxcpld_i2c_write_comm(priv, MLXCPLD_LPCI2C_NUM_DAT_REG,\n\t\t\t       &priv->xfer.data_len, 1);\n\n\tval = priv->xfer.addr_width;\n\t \n\tif (priv->smbus_block && priv->xfer.msg_num >= 2 &&\n\t    priv->xfer.msg[1].len == 1 &&\n\t    (priv->xfer.msg[1].flags & I2C_M_RECV_LEN) &&\n\t    (priv->xfer.msg[1].flags & I2C_M_RD))\n\t\tval |= MLXCPLD_I2C_SMBUS_BLK_BIT;\n\n\tmlxcpld_i2c_write_comm(priv, MLXCPLD_LPCI2C_NUM_ADDR_REG, &val, 1);\n\n\tfor (i = 0; i < priv->xfer.msg_num; i++) {\n\t\tif ((priv->xfer.msg[i].flags & I2C_M_RD) != I2C_M_RD) {\n\t\t\t \n\t\t\tmlxcpld_i2c_write_comm(priv, MLXCPLD_LPCI2C_DATA_REG +\n\t\t\t\t\t       len, priv->xfer.msg[i].buf,\n\t\t\t\t\t       priv->xfer.msg[i].len);\n\t\t\tlen += priv->xfer.msg[i].len;\n\t\t}\n\t}\n\n\t \n\tcmd = (priv->xfer.msg[0].addr << 1) | priv->xfer.cmd;\n\tmlxcpld_i2c_write_comm(priv, MLXCPLD_LPCI2C_CMD_REG, &cmd, 1);\n}\n\n \nstatic int mlxcpld_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs,\n\t\t\t    int num)\n{\n\tstruct mlxcpld_i2c_priv *priv = i2c_get_adapdata(adap);\n\tu8 comm_len = 0;\n\tint i, err;\n\n\terr = mlxcpld_i2c_check_msg_params(priv, msgs, num);\n\tif (err) {\n\t\tdev_err(priv->dev, \"Incorrect message\\n\");\n\t\treturn err;\n\t}\n\n\tfor (i = 0; i < num; ++i)\n\t\tcomm_len += msgs[i].len;\n\n\t \n\tif (mlxcpld_i2c_wait_for_free(priv)) {\n\t\tdev_err(priv->dev, \"LPCI2C bridge is busy\\n\");\n\n\t\t \n\t\tmlxcpld_i2c_reset(priv);\n\t\tif (mlxcpld_i2c_check_busy(priv)) {\n\t\t\tdev_err(priv->dev, \"LPCI2C bridge is busy after reset\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\tmlxcpld_i2c_set_transf_data(priv, msgs, num, comm_len);\n\n\tmutex_lock(&priv->lock);\n\n\t \n\tmlxcpld_i2c_xfer_msg(priv);\n\n\t \n\terr = mlxcpld_i2c_wait_for_tc(priv);\n\n\tmutex_unlock(&priv->lock);\n\n\treturn err < 0 ? err : num;\n}\n\nstatic u32 mlxcpld_i2c_func(struct i2c_adapter *adap)\n{\n\tstruct mlxcpld_i2c_priv *priv = i2c_get_adapdata(adap);\n\n\tif (priv->smbus_block)\n\t\treturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL |\n\t\t\tI2C_FUNC_SMBUS_I2C_BLOCK | I2C_FUNC_SMBUS_BLOCK_DATA;\n\telse\n\t\treturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL |\n\t\t\tI2C_FUNC_SMBUS_I2C_BLOCK;\n}\n\nstatic const struct i2c_algorithm mlxcpld_i2c_algo = {\n\t.master_xfer\t= mlxcpld_i2c_xfer,\n\t.functionality\t= mlxcpld_i2c_func\n};\n\nstatic const struct i2c_adapter_quirks mlxcpld_i2c_quirks = {\n\t.flags = I2C_AQ_COMB_WRITE_THEN_READ,\n\t.max_read_len = MLXCPLD_I2C_DATA_REG_SZ - MLXCPLD_I2C_MAX_ADDR_LEN,\n\t.max_write_len = MLXCPLD_I2C_DATA_REG_SZ,\n\t.max_comb_1st_msg_len = 4,\n};\n\nstatic const struct i2c_adapter_quirks mlxcpld_i2c_quirks_ext = {\n\t.flags = I2C_AQ_COMB_WRITE_THEN_READ,\n\t.max_read_len = MLXCPLD_I2C_DATA_REG_SZ * 2 - MLXCPLD_I2C_MAX_ADDR_LEN,\n\t.max_write_len = MLXCPLD_I2C_DATA_REG_SZ * 2,\n\t.max_comb_1st_msg_len = 4,\n};\n\nstatic const struct i2c_adapter_quirks mlxcpld_i2c_quirks_ext2 = {\n\t.flags = I2C_AQ_COMB_WRITE_THEN_READ,\n\t.max_read_len = (MLXCPLD_I2C_DATA_REG_SZ - 4) * 4,\n\t.max_write_len = (MLXCPLD_I2C_DATA_REG_SZ - 4) * 4 + MLXCPLD_I2C_MAX_ADDR_LEN,\n\t.max_comb_1st_msg_len = 4,\n};\n\nstatic struct i2c_adapter mlxcpld_i2c_adapter = {\n\t.owner          = THIS_MODULE,\n\t.name           = \"i2c-mlxcpld\",\n\t.class          = I2C_CLASS_HWMON | I2C_CLASS_SPD,\n\t.algo           = &mlxcpld_i2c_algo,\n\t.quirks\t\t= &mlxcpld_i2c_quirks,\n\t.retries\t= MLXCPLD_I2C_RETR_NUM,\n\t.nr\t\t= MLXCPLD_I2C_BUS_NUM,\n};\n\nstatic int\nmlxcpld_i2c_set_frequency(struct mlxcpld_i2c_priv *priv,\n\t\t\t  struct mlxreg_core_hotplug_platform_data *pdata)\n{\n\tstruct mlxreg_core_item *item = pdata->items;\n\tstruct mlxreg_core_data *data;\n\tu32 regval;\n\tu8 freq;\n\tint err;\n\n\tif (!item)\n\t\treturn 0;\n\n\t \n\tdata = item->data;\n\terr = regmap_read(pdata->regmap, data->reg, &regval);\n\tif (err)\n\t\treturn err;\n\n\t \n\tswitch ((regval & data->mask) >> data->bit) {\n\tcase MLXCPLD_I2C_FREQ_1000KHZ:\n\t\tfreq = MLXCPLD_I2C_FREQ_1000KHZ_SET;\n\t\tpriv->polling_time /= 4;\n\t\tbreak;\n\tcase MLXCPLD_I2C_FREQ_400KHZ:\n\t\tfreq = MLXCPLD_I2C_FREQ_400KHZ_SET;\n\t\tpriv->polling_time /= 4;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\tmlxcpld_i2c_write_comm(priv, MLXCPLD_LPCI2C_HALF_CYC_REG, &freq, 1);\n\n\treturn 0;\n}\n\nstatic int mlxcpld_i2c_probe(struct platform_device *pdev)\n{\n\tstruct mlxreg_core_hotplug_platform_data *pdata;\n\tstruct mlxcpld_i2c_priv *priv;\n\tint err;\n\tu8 val;\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&priv->lock);\n\tplatform_set_drvdata(pdev, priv);\n\n\tpriv->dev = &pdev->dev;\n\tpriv->base_addr = MLXPLAT_CPLD_LPC_I2C_BASE_ADDR;\n\tpriv->polling_time = MLXCPLD_I2C_POLL_TIME;\n\n\t \n\tpdata = dev_get_platdata(&pdev->dev);\n\tif (pdata) {\n\t\terr = mlxcpld_i2c_set_frequency(priv, pdata);\n\t\tif (err)\n\t\t\tgoto mlxcpld_i2_probe_failed;\n\t}\n\n\t \n\tmlxcpld_i2c_adapter.timeout = usecs_to_jiffies(MLXCPLD_I2C_XFER_TO);\n\t \n\tmlxcpld_i2c_read_comm(priv, MLXCPLD_LPCI2C_CPBLTY_REG, &val, 1);\n\t \n\tif ((val & MLXCPLD_I2C_DATA_SZ_MASK) == MLXCPLD_I2C_DATA_SZ_BIT)\n\t\tmlxcpld_i2c_adapter.quirks = &mlxcpld_i2c_quirks_ext;\n\telse if ((val & MLXCPLD_I2C_DATA_SZ_MASK) == MLXCPLD_I2C_DATA_EXT2_SZ_BIT)\n\t\tmlxcpld_i2c_adapter.quirks = &mlxcpld_i2c_quirks_ext2;\n\t \n\tif (val & MLXCPLD_I2C_SMBUS_BLK_BIT)\n\t\tpriv->smbus_block = true;\n\tif (pdev->id >= -1)\n\t\tmlxcpld_i2c_adapter.nr = pdev->id;\n\tpriv->adap = mlxcpld_i2c_adapter;\n\tpriv->adap.dev.parent = &pdev->dev;\n\ti2c_set_adapdata(&priv->adap, priv);\n\n\terr = i2c_add_numbered_adapter(&priv->adap);\n\tif (err)\n\t\tgoto mlxcpld_i2_probe_failed;\n\n\t \n\tif (pdata && pdata->completion_notify)\n\t\tpdata->completion_notify(pdata->handle, mlxcpld_i2c_adapter.nr);\n\n\treturn 0;\n\nmlxcpld_i2_probe_failed:\n\tmutex_destroy(&priv->lock);\n\treturn err;\n}\n\nstatic void mlxcpld_i2c_remove(struct platform_device *pdev)\n{\n\tstruct mlxcpld_i2c_priv *priv = platform_get_drvdata(pdev);\n\n\ti2c_del_adapter(&priv->adap);\n\tmutex_destroy(&priv->lock);\n}\n\nstatic struct platform_driver mlxcpld_i2c_driver = {\n\t.probe\t\t= mlxcpld_i2c_probe,\n\t.remove_new\t= mlxcpld_i2c_remove,\n\t.driver = {\n\t\t.name = MLXCPLD_I2C_DEVICE_NAME,\n\t},\n};\n\nmodule_platform_driver(mlxcpld_i2c_driver);\n\nMODULE_AUTHOR(\"Michael Shych <michaels@mellanox.com>\");\nMODULE_DESCRIPTION(\"Mellanox I2C-CPLD controller driver\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_ALIAS(\"platform:i2c-mlxcpld\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}