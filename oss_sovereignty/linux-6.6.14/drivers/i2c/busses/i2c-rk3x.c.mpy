{
  "module_name": "i2c-rk3x.c",
  "hash_id": "ddf38281e29ad18e7bf6a20245987c45a141c7c3dbd1f916791fb959c68d2234",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-rk3x.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/iopoll.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/platform_device.h>\n#include <linux/io.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/spinlock.h>\n#include <linux/clk.h>\n#include <linux/wait.h>\n#include <linux/mfd/syscon.h>\n#include <linux/regmap.h>\n#include <linux/math64.h>\n\n\n \n#define REG_CON        0x00  \n#define REG_CLKDIV     0x04  \n#define REG_MRXADDR    0x08  \n#define REG_MRXRADDR   0x0c  \n#define REG_MTXCNT     0x10  \n#define REG_MRXCNT     0x14  \n#define REG_IEN        0x18  \n#define REG_IPD        0x1c  \n#define REG_FCNT       0x20  \n\n \n#define TXBUFFER_BASE 0x100\n#define RXBUFFER_BASE 0x200\n\n \n#define REG_CON_EN        BIT(0)\nenum {\n\tREG_CON_MOD_TX = 0,       \n\tREG_CON_MOD_REGISTER_TX,  \n\tREG_CON_MOD_RX,           \n\tREG_CON_MOD_REGISTER_RX,  \n};\n#define REG_CON_MOD(mod)  ((mod) << 1)\n#define REG_CON_MOD_MASK  (BIT(1) | BIT(2))\n#define REG_CON_START     BIT(3)\n#define REG_CON_STOP      BIT(4)\n#define REG_CON_LASTACK   BIT(5)  \n#define REG_CON_ACTACK    BIT(6)  \n\n#define REG_CON_TUNING_MASK GENMASK_ULL(15, 8)\n\n#define REG_CON_SDA_CFG(cfg) ((cfg) << 8)\n#define REG_CON_STA_CFG(cfg) ((cfg) << 12)\n#define REG_CON_STO_CFG(cfg) ((cfg) << 14)\n\n \n#define REG_MRXADDR_VALID(x) BIT(24 + (x))  \n\n \n#define REG_INT_BTF       BIT(0)  \n#define REG_INT_BRF       BIT(1)  \n#define REG_INT_MBTF      BIT(2)  \n#define REG_INT_MBRF      BIT(3)  \n#define REG_INT_START     BIT(4)  \n#define REG_INT_STOP      BIT(5)  \n#define REG_INT_NAKRCV    BIT(6)  \n#define REG_INT_ALL       0x7f\n\n \n#define WAIT_TIMEOUT      1000  \n#define DEFAULT_SCL_RATE  (100 * 1000)  \n\n \nstruct i2c_spec_values {\n\tunsigned long min_hold_start_ns;\n\tunsigned long min_low_ns;\n\tunsigned long min_high_ns;\n\tunsigned long min_setup_start_ns;\n\tunsigned long max_data_hold_ns;\n\tunsigned long min_data_setup_ns;\n\tunsigned long min_setup_stop_ns;\n\tunsigned long min_hold_buffer_ns;\n};\n\nstatic const struct i2c_spec_values standard_mode_spec = {\n\t.min_hold_start_ns = 4000,\n\t.min_low_ns = 4700,\n\t.min_high_ns = 4000,\n\t.min_setup_start_ns = 4700,\n\t.max_data_hold_ns = 3450,\n\t.min_data_setup_ns = 250,\n\t.min_setup_stop_ns = 4000,\n\t.min_hold_buffer_ns = 4700,\n};\n\nstatic const struct i2c_spec_values fast_mode_spec = {\n\t.min_hold_start_ns = 600,\n\t.min_low_ns = 1300,\n\t.min_high_ns = 600,\n\t.min_setup_start_ns = 600,\n\t.max_data_hold_ns = 900,\n\t.min_data_setup_ns = 100,\n\t.min_setup_stop_ns = 600,\n\t.min_hold_buffer_ns = 1300,\n};\n\nstatic const struct i2c_spec_values fast_mode_plus_spec = {\n\t.min_hold_start_ns = 260,\n\t.min_low_ns = 500,\n\t.min_high_ns = 260,\n\t.min_setup_start_ns = 260,\n\t.max_data_hold_ns = 400,\n\t.min_data_setup_ns = 50,\n\t.min_setup_stop_ns = 260,\n\t.min_hold_buffer_ns = 500,\n};\n\n \nstruct rk3x_i2c_calced_timings {\n\tunsigned long div_low;\n\tunsigned long div_high;\n\tunsigned int tuning;\n};\n\nenum rk3x_i2c_state {\n\tSTATE_IDLE,\n\tSTATE_START,\n\tSTATE_READ,\n\tSTATE_WRITE,\n\tSTATE_STOP\n};\n\n \nstruct rk3x_i2c_soc_data {\n\tint grf_offset;\n\tint (*calc_timings)(unsigned long, struct i2c_timings *,\n\t\t\t    struct rk3x_i2c_calced_timings *);\n};\n\n \nstruct rk3x_i2c {\n\tstruct i2c_adapter adap;\n\tstruct device *dev;\n\tconst struct rk3x_i2c_soc_data *soc_data;\n\n\t \n\tvoid __iomem *regs;\n\tstruct clk *clk;\n\tstruct clk *pclk;\n\tstruct notifier_block clk_rate_nb;\n\tint irq;\n\n\t \n\tstruct i2c_timings t;\n\n\t \n\tspinlock_t lock;\n\twait_queue_head_t wait;\n\tbool busy;\n\n\t \n\tstruct i2c_msg *msg;\n\tu8 addr;\n\tunsigned int mode;\n\tbool is_last_msg;\n\n\t \n\tenum rk3x_i2c_state state;\n\tunsigned int processed;\n\tint error;\n};\n\nstatic inline void i2c_writel(struct rk3x_i2c *i2c, u32 value,\n\t\t\t      unsigned int offset)\n{\n\twritel(value, i2c->regs + offset);\n}\n\nstatic inline u32 i2c_readl(struct rk3x_i2c *i2c, unsigned int offset)\n{\n\treturn readl(i2c->regs + offset);\n}\n\n \nstatic inline void rk3x_i2c_clean_ipd(struct rk3x_i2c *i2c)\n{\n\ti2c_writel(i2c, REG_INT_ALL, REG_IPD);\n}\n\n \nstatic void rk3x_i2c_start(struct rk3x_i2c *i2c)\n{\n\tu32 val = i2c_readl(i2c, REG_CON) & REG_CON_TUNING_MASK;\n\n\ti2c_writel(i2c, REG_INT_START, REG_IEN);\n\n\t \n\tval |= REG_CON_EN | REG_CON_MOD(i2c->mode) | REG_CON_START;\n\n\t \n\tif (!(i2c->msg->flags & I2C_M_IGNORE_NAK))\n\t\tval |= REG_CON_ACTACK;\n\n\ti2c_writel(i2c, val, REG_CON);\n}\n\n \nstatic void rk3x_i2c_stop(struct rk3x_i2c *i2c, int error)\n{\n\tunsigned int ctrl;\n\n\ti2c->processed = 0;\n\ti2c->msg = NULL;\n\ti2c->error = error;\n\n\tif (i2c->is_last_msg) {\n\t\t \n\t\ti2c_writel(i2c, REG_INT_STOP, REG_IEN);\n\n\t\ti2c->state = STATE_STOP;\n\n\t\tctrl = i2c_readl(i2c, REG_CON);\n\t\tctrl |= REG_CON_STOP;\n\t\ti2c_writel(i2c, ctrl, REG_CON);\n\t} else {\n\t\t \n\t\ti2c->busy = false;\n\t\ti2c->state = STATE_IDLE;\n\n\t\t \n\t\tctrl = i2c_readl(i2c, REG_CON) & REG_CON_TUNING_MASK;\n\t\ti2c_writel(i2c, ctrl, REG_CON);\n\n\t\t \n\t\twake_up(&i2c->wait);\n\t}\n}\n\n \nstatic void rk3x_i2c_prepare_read(struct rk3x_i2c *i2c)\n{\n\tunsigned int len = i2c->msg->len - i2c->processed;\n\tu32 con;\n\n\tcon = i2c_readl(i2c, REG_CON);\n\n\t \n\tif (len > 32) {\n\t\tlen = 32;\n\t\tcon &= ~REG_CON_LASTACK;\n\t} else {\n\t\tcon |= REG_CON_LASTACK;\n\t}\n\n\t \n\tif (i2c->processed != 0) {\n\t\tcon &= ~REG_CON_MOD_MASK;\n\t\tcon |= REG_CON_MOD(REG_CON_MOD_RX);\n\t}\n\n\ti2c_writel(i2c, con, REG_CON);\n\ti2c_writel(i2c, len, REG_MRXCNT);\n}\n\n \nstatic void rk3x_i2c_fill_transmit_buf(struct rk3x_i2c *i2c)\n{\n\tunsigned int i, j;\n\tu32 cnt = 0;\n\tu32 val;\n\tu8 byte;\n\n\tfor (i = 0; i < 8; ++i) {\n\t\tval = 0;\n\t\tfor (j = 0; j < 4; ++j) {\n\t\t\tif ((i2c->processed == i2c->msg->len) && (cnt != 0))\n\t\t\t\tbreak;\n\n\t\t\tif (i2c->processed == 0 && cnt == 0)\n\t\t\t\tbyte = (i2c->addr & 0x7f) << 1;\n\t\t\telse\n\t\t\t\tbyte = i2c->msg->buf[i2c->processed++];\n\n\t\t\tval |= byte << (j * 8);\n\t\t\tcnt++;\n\t\t}\n\n\t\ti2c_writel(i2c, val, TXBUFFER_BASE + 4 * i);\n\n\t\tif (i2c->processed == i2c->msg->len)\n\t\t\tbreak;\n\t}\n\n\ti2c_writel(i2c, cnt, REG_MTXCNT);\n}\n\n\n \n\nstatic void rk3x_i2c_handle_start(struct rk3x_i2c *i2c, unsigned int ipd)\n{\n\tif (!(ipd & REG_INT_START)) {\n\t\trk3x_i2c_stop(i2c, -EIO);\n\t\tdev_warn(i2c->dev, \"unexpected irq in START: 0x%x\\n\", ipd);\n\t\trk3x_i2c_clean_ipd(i2c);\n\t\treturn;\n\t}\n\n\t \n\ti2c_writel(i2c, REG_INT_START, REG_IPD);\n\n\t \n\ti2c_writel(i2c, i2c_readl(i2c, REG_CON) & ~REG_CON_START, REG_CON);\n\n\t \n\tif (i2c->mode == REG_CON_MOD_TX) {\n\t\ti2c_writel(i2c, REG_INT_MBTF | REG_INT_NAKRCV, REG_IEN);\n\t\ti2c->state = STATE_WRITE;\n\t\trk3x_i2c_fill_transmit_buf(i2c);\n\t} else {\n\t\t \n\t\ti2c_writel(i2c, REG_INT_MBRF | REG_INT_NAKRCV, REG_IEN);\n\t\ti2c->state = STATE_READ;\n\t\trk3x_i2c_prepare_read(i2c);\n\t}\n}\n\nstatic void rk3x_i2c_handle_write(struct rk3x_i2c *i2c, unsigned int ipd)\n{\n\tif (!(ipd & REG_INT_MBTF)) {\n\t\trk3x_i2c_stop(i2c, -EIO);\n\t\tdev_err(i2c->dev, \"unexpected irq in WRITE: 0x%x\\n\", ipd);\n\t\trk3x_i2c_clean_ipd(i2c);\n\t\treturn;\n\t}\n\n\t \n\ti2c_writel(i2c, REG_INT_MBTF, REG_IPD);\n\n\t \n\tif (i2c->processed == i2c->msg->len)\n\t\trk3x_i2c_stop(i2c, i2c->error);\n\telse\n\t\trk3x_i2c_fill_transmit_buf(i2c);\n}\n\nstatic void rk3x_i2c_handle_read(struct rk3x_i2c *i2c, unsigned int ipd)\n{\n\tunsigned int i;\n\tunsigned int len = i2c->msg->len - i2c->processed;\n\tu32 val;\n\tu8 byte;\n\n\t \n\tif (!(ipd & REG_INT_MBRF))\n\t\treturn;\n\n\t \n\ti2c_writel(i2c, REG_INT_MBRF | REG_INT_START, REG_IPD);\n\n\t \n\tif (len > 32)\n\t\tlen = 32;\n\n\t \n\tfor (i = 0; i < len; ++i) {\n\t\tif (i % 4 == 0)\n\t\t\tval = i2c_readl(i2c, RXBUFFER_BASE + (i / 4) * 4);\n\n\t\tbyte = (val >> ((i % 4) * 8)) & 0xff;\n\t\ti2c->msg->buf[i2c->processed++] = byte;\n\t}\n\n\t \n\tif (i2c->processed == i2c->msg->len)\n\t\trk3x_i2c_stop(i2c, i2c->error);\n\telse\n\t\trk3x_i2c_prepare_read(i2c);\n}\n\nstatic void rk3x_i2c_handle_stop(struct rk3x_i2c *i2c, unsigned int ipd)\n{\n\tunsigned int con;\n\n\tif (!(ipd & REG_INT_STOP)) {\n\t\trk3x_i2c_stop(i2c, -EIO);\n\t\tdev_err(i2c->dev, \"unexpected irq in STOP: 0x%x\\n\", ipd);\n\t\trk3x_i2c_clean_ipd(i2c);\n\t\treturn;\n\t}\n\n\t \n\ti2c_writel(i2c, REG_INT_STOP, REG_IPD);\n\n\t \n\tcon = i2c_readl(i2c, REG_CON);\n\tcon &= ~REG_CON_STOP;\n\ti2c_writel(i2c, con, REG_CON);\n\n\ti2c->busy = false;\n\ti2c->state = STATE_IDLE;\n\n\t \n\twake_up(&i2c->wait);\n}\n\nstatic irqreturn_t rk3x_i2c_irq(int irqno, void *dev_id)\n{\n\tstruct rk3x_i2c *i2c = dev_id;\n\tunsigned int ipd;\n\n\tspin_lock(&i2c->lock);\n\n\tipd = i2c_readl(i2c, REG_IPD);\n\tif (i2c->state == STATE_IDLE) {\n\t\tdev_warn(i2c->dev, \"irq in STATE_IDLE, ipd = 0x%x\\n\", ipd);\n\t\trk3x_i2c_clean_ipd(i2c);\n\t\tgoto out;\n\t}\n\n\tdev_dbg(i2c->dev, \"IRQ: state %d, ipd: %x\\n\", i2c->state, ipd);\n\n\t \n\tipd &= ~(REG_INT_BRF | REG_INT_BTF);\n\n\tif (ipd & REG_INT_NAKRCV) {\n\t\t \n\t\ti2c_writel(i2c, REG_INT_NAKRCV, REG_IPD);\n\n\t\tipd &= ~REG_INT_NAKRCV;\n\n\t\tif (!(i2c->msg->flags & I2C_M_IGNORE_NAK))\n\t\t\trk3x_i2c_stop(i2c, -ENXIO);\n\t}\n\n\t \n\tif ((ipd & REG_INT_ALL) == 0)\n\t\tgoto out;\n\n\tswitch (i2c->state) {\n\tcase STATE_START:\n\t\trk3x_i2c_handle_start(i2c, ipd);\n\t\tbreak;\n\tcase STATE_WRITE:\n\t\trk3x_i2c_handle_write(i2c, ipd);\n\t\tbreak;\n\tcase STATE_READ:\n\t\trk3x_i2c_handle_read(i2c, ipd);\n\t\tbreak;\n\tcase STATE_STOP:\n\t\trk3x_i2c_handle_stop(i2c, ipd);\n\t\tbreak;\n\tcase STATE_IDLE:\n\t\tbreak;\n\t}\n\nout:\n\tspin_unlock(&i2c->lock);\n\treturn IRQ_HANDLED;\n}\n\n \nstatic const struct i2c_spec_values *rk3x_i2c_get_spec(unsigned int speed)\n{\n\tif (speed <= I2C_MAX_STANDARD_MODE_FREQ)\n\t\treturn &standard_mode_spec;\n\telse if (speed <= I2C_MAX_FAST_MODE_FREQ)\n\t\treturn &fast_mode_spec;\n\telse\n\t\treturn &fast_mode_plus_spec;\n}\n\n \nstatic int rk3x_i2c_v0_calc_timings(unsigned long clk_rate,\n\t\t\t\t    struct i2c_timings *t,\n\t\t\t\t    struct rk3x_i2c_calced_timings *t_calc)\n{\n\tunsigned long min_low_ns, min_high_ns;\n\tunsigned long max_low_ns, min_total_ns;\n\n\tunsigned long clk_rate_khz, scl_rate_khz;\n\n\tunsigned long min_low_div, min_high_div;\n\tunsigned long max_low_div;\n\n\tunsigned long min_div_for_hold, min_total_div;\n\tunsigned long extra_div, extra_low_div, ideal_low_div;\n\n\tunsigned long data_hold_buffer_ns = 50;\n\tconst struct i2c_spec_values *spec;\n\tint ret = 0;\n\n\t \n\tif (WARN_ON(t->bus_freq_hz > I2C_MAX_FAST_MODE_FREQ))\n\t\tt->bus_freq_hz = I2C_MAX_FAST_MODE_FREQ;\n\n\t \n\tif (WARN_ON(t->bus_freq_hz < 1000))\n\t\tt->bus_freq_hz = 1000;\n\n\t \n\tspec = rk3x_i2c_get_spec(t->bus_freq_hz);\n\tmin_high_ns = t->scl_rise_ns + spec->min_high_ns;\n\n\t \n\tmin_high_ns = max(min_high_ns, DIV_ROUND_UP(\n\t\t(t->scl_rise_ns + spec->min_setup_start_ns) * 1000, 875));\n\tmin_high_ns = max(min_high_ns, DIV_ROUND_UP(\n\t\t(t->scl_rise_ns + spec->min_setup_start_ns + t->sda_fall_ns +\n\t\tspec->min_high_ns), 2));\n\n\tmin_low_ns = t->scl_fall_ns + spec->min_low_ns;\n\tmax_low_ns =  spec->max_data_hold_ns * 2 - data_hold_buffer_ns;\n\tmin_total_ns = min_low_ns + min_high_ns;\n\n\t \n\tclk_rate_khz = DIV_ROUND_UP(clk_rate, 1000);\n\tscl_rate_khz = t->bus_freq_hz / 1000;\n\n\t \n\tmin_total_div = DIV_ROUND_UP(clk_rate_khz, scl_rate_khz * 8);\n\n\t \n\tmin_low_div = DIV_ROUND_UP(clk_rate_khz * min_low_ns, 8 * 1000000);\n\tmin_high_div = DIV_ROUND_UP(clk_rate_khz * min_high_ns, 8 * 1000000);\n\tmin_div_for_hold = (min_low_div + min_high_div);\n\n\t \n\tmax_low_div = clk_rate_khz * max_low_ns / (8 * 1000000);\n\n\tif (min_low_div > max_low_div) {\n\t\tWARN_ONCE(true,\n\t\t\t  \"Conflicting, min_low_div %lu, max_low_div %lu\\n\",\n\t\t\t  min_low_div, max_low_div);\n\t\tmax_low_div = min_low_div;\n\t}\n\n\tif (min_div_for_hold > min_total_div) {\n\t\t \n\t\tt_calc->div_low = min_low_div;\n\t\tt_calc->div_high = min_high_div;\n\t} else {\n\t\t \n\t\textra_div = min_total_div - min_div_for_hold;\n\n\t\t \n\t\tideal_low_div = DIV_ROUND_UP(clk_rate_khz * min_low_ns,\n\t\t\t\t\t     scl_rate_khz * 8 * min_total_ns);\n\n\t\t \n\t\tif (ideal_low_div > max_low_div)\n\t\t\tideal_low_div = max_low_div;\n\n\t\t \n\t\tif (ideal_low_div > min_low_div + extra_div)\n\t\t\tideal_low_div = min_low_div + extra_div;\n\n\t\t \n\t\textra_low_div = ideal_low_div - min_low_div;\n\t\tt_calc->div_low = ideal_low_div;\n\t\tt_calc->div_high = min_high_div + (extra_div - extra_low_div);\n\t}\n\n\t \n\tt_calc->div_low--;\n\tt_calc->div_high--;\n\n\t \n\tt_calc->tuning = 0;\n\t \n\tif (t_calc->div_low > 0xffff) {\n\t\tt_calc->div_low = 0xffff;\n\t\tret = -EINVAL;\n\t}\n\n\tif (t_calc->div_high > 0xffff) {\n\t\tt_calc->div_high = 0xffff;\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\n \nstatic int rk3x_i2c_v1_calc_timings(unsigned long clk_rate,\n\t\t\t\t    struct i2c_timings *t,\n\t\t\t\t    struct rk3x_i2c_calced_timings *t_calc)\n{\n\tunsigned long min_low_ns, min_high_ns;\n\tunsigned long min_setup_start_ns, min_setup_data_ns;\n\tunsigned long min_setup_stop_ns, max_hold_data_ns;\n\n\tunsigned long clk_rate_khz, scl_rate_khz;\n\n\tunsigned long min_low_div, min_high_div;\n\n\tunsigned long min_div_for_hold, min_total_div;\n\tunsigned long extra_div, extra_low_div;\n\tunsigned long sda_update_cfg, stp_sta_cfg, stp_sto_cfg;\n\n\tconst struct i2c_spec_values *spec;\n\tint ret = 0;\n\n\t \n\tif (WARN_ON(t->bus_freq_hz > I2C_MAX_FAST_MODE_PLUS_FREQ))\n\t\tt->bus_freq_hz = I2C_MAX_FAST_MODE_PLUS_FREQ;\n\n\t \n\tif (WARN_ON(t->bus_freq_hz < 1000))\n\t\tt->bus_freq_hz = 1000;\n\n\t \n\tspec = rk3x_i2c_get_spec(t->bus_freq_hz);\n\n\t \n\tclk_rate_khz = DIV_ROUND_UP(clk_rate, 1000);\n\tscl_rate_khz = t->bus_freq_hz / 1000;\n\tmin_total_div = DIV_ROUND_UP(clk_rate_khz, scl_rate_khz * 8);\n\n\tmin_high_ns = t->scl_rise_ns + spec->min_high_ns;\n\tmin_high_div = DIV_ROUND_UP(clk_rate_khz * min_high_ns, 8 * 1000000);\n\n\tmin_low_ns = t->scl_fall_ns + spec->min_low_ns;\n\tmin_low_div = DIV_ROUND_UP(clk_rate_khz * min_low_ns, 8 * 1000000);\n\n\t \n\tmin_high_div = (min_high_div < 1) ? 2 : min_high_div;\n\tmin_low_div = (min_low_div < 1) ? 2 : min_low_div;\n\n\t \n\tmin_div_for_hold = (min_low_div + min_high_div);\n\n\t \n\tif (min_div_for_hold >= min_total_div) {\n\t\t \n\t\tt_calc->div_low = min_low_div;\n\t\tt_calc->div_high = min_high_div;\n\t} else {\n\t\t \n\t\textra_div = min_total_div - min_div_for_hold;\n\t\textra_low_div = DIV_ROUND_UP(min_low_div * extra_div,\n\t\t\t\t\t     min_div_for_hold);\n\n\t\tt_calc->div_low = min_low_div + extra_low_div;\n\t\tt_calc->div_high = min_high_div + (extra_div - extra_low_div);\n\t}\n\n\t \n\tfor (sda_update_cfg = 3; sda_update_cfg > 0; sda_update_cfg--) {\n\t\tmax_hold_data_ns =  DIV_ROUND_UP((sda_update_cfg\n\t\t\t\t\t\t * (t_calc->div_low) + 1)\n\t\t\t\t\t\t * 1000000, clk_rate_khz);\n\t\tmin_setup_data_ns =  DIV_ROUND_UP(((8 - sda_update_cfg)\n\t\t\t\t\t\t * (t_calc->div_low) + 1)\n\t\t\t\t\t\t * 1000000, clk_rate_khz);\n\t\tif ((max_hold_data_ns < spec->max_data_hold_ns) &&\n\t\t    (min_setup_data_ns > spec->min_data_setup_ns))\n\t\t\tbreak;\n\t}\n\n\t \n\tmin_setup_start_ns = t->scl_rise_ns + spec->min_setup_start_ns;\n\tstp_sta_cfg = DIV_ROUND_UP(clk_rate_khz * min_setup_start_ns\n\t\t\t   - 1000000, 8 * 1000000 * (t_calc->div_high));\n\n\t \n\tmin_setup_stop_ns = t->scl_rise_ns + spec->min_setup_stop_ns;\n\tstp_sto_cfg = DIV_ROUND_UP(clk_rate_khz * min_setup_stop_ns\n\t\t\t   - 1000000, 8 * 1000000 * (t_calc->div_high));\n\n\tt_calc->tuning = REG_CON_SDA_CFG(--sda_update_cfg) |\n\t\t\t REG_CON_STA_CFG(--stp_sta_cfg) |\n\t\t\t REG_CON_STO_CFG(--stp_sto_cfg);\n\n\tt_calc->div_low--;\n\tt_calc->div_high--;\n\n\t \n\tif (t_calc->div_low > 0xffff) {\n\t\tt_calc->div_low = 0xffff;\n\t\tret = -EINVAL;\n\t}\n\n\tif (t_calc->div_high > 0xffff) {\n\t\tt_calc->div_high = 0xffff;\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic void rk3x_i2c_adapt_div(struct rk3x_i2c *i2c, unsigned long clk_rate)\n{\n\tstruct i2c_timings *t = &i2c->t;\n\tstruct rk3x_i2c_calced_timings calc;\n\tu64 t_low_ns, t_high_ns;\n\tunsigned long flags;\n\tu32 val;\n\tint ret;\n\n\tret = i2c->soc_data->calc_timings(clk_rate, t, &calc);\n\tWARN_ONCE(ret != 0, \"Could not reach SCL freq %u\", t->bus_freq_hz);\n\n\tclk_enable(i2c->pclk);\n\n\tspin_lock_irqsave(&i2c->lock, flags);\n\tval = i2c_readl(i2c, REG_CON);\n\tval &= ~REG_CON_TUNING_MASK;\n\tval |= calc.tuning;\n\ti2c_writel(i2c, val, REG_CON);\n\ti2c_writel(i2c, (calc.div_high << 16) | (calc.div_low & 0xffff),\n\t\t   REG_CLKDIV);\n\tspin_unlock_irqrestore(&i2c->lock, flags);\n\n\tclk_disable(i2c->pclk);\n\n\tt_low_ns = div_u64(((u64)calc.div_low + 1) * 8 * 1000000000, clk_rate);\n\tt_high_ns = div_u64(((u64)calc.div_high + 1) * 8 * 1000000000,\n\t\t\t    clk_rate);\n\tdev_dbg(i2c->dev,\n\t\t\"CLK %lukhz, Req %uns, Act low %lluns high %lluns\\n\",\n\t\tclk_rate / 1000,\n\t\t1000000000 / t->bus_freq_hz,\n\t\tt_low_ns, t_high_ns);\n}\n\n \nstatic int rk3x_i2c_clk_notifier_cb(struct notifier_block *nb, unsigned long\n\t\t\t\t    event, void *data)\n{\n\tstruct clk_notifier_data *ndata = data;\n\tstruct rk3x_i2c *i2c = container_of(nb, struct rk3x_i2c, clk_rate_nb);\n\tstruct rk3x_i2c_calced_timings calc;\n\n\tswitch (event) {\n\tcase PRE_RATE_CHANGE:\n\t\t \n\t\tif (i2c->soc_data->calc_timings(ndata->new_rate, &i2c->t,\n\t\t\t\t\t\t&calc) != 0)\n\t\t\treturn NOTIFY_STOP;\n\n\t\t \n\t\tif (ndata->new_rate > ndata->old_rate)\n\t\t\trk3x_i2c_adapt_div(i2c, ndata->new_rate);\n\n\t\treturn NOTIFY_OK;\n\tcase POST_RATE_CHANGE:\n\t\t \n\t\tif (ndata->new_rate < ndata->old_rate)\n\t\t\trk3x_i2c_adapt_div(i2c, ndata->new_rate);\n\t\treturn NOTIFY_OK;\n\tcase ABORT_RATE_CHANGE:\n\t\t \n\t\tif (ndata->new_rate > ndata->old_rate)\n\t\t\trk3x_i2c_adapt_div(i2c, ndata->old_rate);\n\t\treturn NOTIFY_OK;\n\tdefault:\n\t\treturn NOTIFY_DONE;\n\t}\n}\n\n \nstatic int rk3x_i2c_setup(struct rk3x_i2c *i2c, struct i2c_msg *msgs, int num)\n{\n\tu32 addr = (msgs[0].addr & 0x7f) << 1;\n\tint ret = 0;\n\n\t \n\n\tif (num >= 2 && msgs[0].len < 4 &&\n\t    !(msgs[0].flags & I2C_M_RD) && (msgs[1].flags & I2C_M_RD)) {\n\t\tu32 reg_addr = 0;\n\t\tint i;\n\n\t\tdev_dbg(i2c->dev, \"Combined write/read from addr 0x%x\\n\",\n\t\t\taddr >> 1);\n\n\t\t \n\t\tfor (i = 0; i < msgs[0].len; ++i) {\n\t\t\treg_addr |= msgs[0].buf[i] << (i * 8);\n\t\t\treg_addr |= REG_MRXADDR_VALID(i);\n\t\t}\n\n\t\t \n\t\ti2c->msg = &msgs[1];\n\n\t\ti2c->mode = REG_CON_MOD_REGISTER_TX;\n\n\t\ti2c_writel(i2c, addr | REG_MRXADDR_VALID(0), REG_MRXADDR);\n\t\ti2c_writel(i2c, reg_addr, REG_MRXRADDR);\n\n\t\tret = 2;\n\t} else {\n\t\t \n\n\t\tif (msgs[0].flags & I2C_M_RD) {\n\t\t\taddr |= 1;  \n\n\t\t\t \n\t\t\ti2c->mode = REG_CON_MOD_REGISTER_TX;\n\t\t\ti2c_writel(i2c, addr | REG_MRXADDR_VALID(0),\n\t\t\t\t   REG_MRXADDR);\n\t\t\ti2c_writel(i2c, 0, REG_MRXRADDR);\n\t\t} else {\n\t\t\ti2c->mode = REG_CON_MOD_TX;\n\t\t}\n\n\t\ti2c->msg = &msgs[0];\n\n\t\tret = 1;\n\t}\n\n\ti2c->addr = msgs[0].addr;\n\ti2c->busy = true;\n\ti2c->state = STATE_START;\n\ti2c->processed = 0;\n\ti2c->error = 0;\n\n\trk3x_i2c_clean_ipd(i2c);\n\n\treturn ret;\n}\n\nstatic int rk3x_i2c_wait_xfer_poll(struct rk3x_i2c *i2c)\n{\n\tktime_t timeout = ktime_add_ms(ktime_get(), WAIT_TIMEOUT);\n\n\twhile (READ_ONCE(i2c->busy) &&\n\t       ktime_compare(ktime_get(), timeout) < 0) {\n\t\tudelay(5);\n\t\trk3x_i2c_irq(0, i2c);\n\t}\n\n\treturn !i2c->busy;\n}\n\nstatic int rk3x_i2c_xfer_common(struct i2c_adapter *adap,\n\t\t\t\tstruct i2c_msg *msgs, int num, bool polling)\n{\n\tstruct rk3x_i2c *i2c = (struct rk3x_i2c *)adap->algo_data;\n\tunsigned long timeout, flags;\n\tu32 val;\n\tint ret = 0;\n\tint i;\n\n\tspin_lock_irqsave(&i2c->lock, flags);\n\n\tclk_enable(i2c->clk);\n\tclk_enable(i2c->pclk);\n\n\ti2c->is_last_msg = false;\n\n\t \n\tfor (i = 0; i < num; i += ret) {\n\t\tret = rk3x_i2c_setup(i2c, msgs + i, num - i);\n\n\t\tif (ret < 0) {\n\t\t\tdev_err(i2c->dev, \"rk3x_i2c_setup() failed\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif (i + ret >= num)\n\t\t\ti2c->is_last_msg = true;\n\n\t\tspin_unlock_irqrestore(&i2c->lock, flags);\n\n\t\tif (!polling) {\n\t\t\trk3x_i2c_start(i2c);\n\n\t\t\ttimeout = wait_event_timeout(i2c->wait, !i2c->busy,\n\t\t\t\t\t\t     msecs_to_jiffies(WAIT_TIMEOUT));\n\t\t} else {\n\t\t\tdisable_irq(i2c->irq);\n\t\t\trk3x_i2c_start(i2c);\n\n\t\t\ttimeout = rk3x_i2c_wait_xfer_poll(i2c);\n\n\t\t\tenable_irq(i2c->irq);\n\t\t}\n\n\t\tspin_lock_irqsave(&i2c->lock, flags);\n\n\t\tif (timeout == 0) {\n\t\t\tdev_err(i2c->dev, \"timeout, ipd: 0x%02x, state: %d\\n\",\n\t\t\t\ti2c_readl(i2c, REG_IPD), i2c->state);\n\n\t\t\t \n\t\t\ti2c_writel(i2c, 0, REG_IEN);\n\t\t\tval = i2c_readl(i2c, REG_CON) & REG_CON_TUNING_MASK;\n\t\t\tval |= REG_CON_EN | REG_CON_STOP;\n\t\t\ti2c_writel(i2c, val, REG_CON);\n\n\t\t\ti2c->state = STATE_IDLE;\n\n\t\t\tret = -ETIMEDOUT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (i2c->error) {\n\t\t\tret = i2c->error;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tclk_disable(i2c->pclk);\n\tclk_disable(i2c->clk);\n\n\tspin_unlock_irqrestore(&i2c->lock, flags);\n\n\treturn ret < 0 ? ret : num;\n}\n\nstatic int rk3x_i2c_xfer(struct i2c_adapter *adap,\n\t\t\t struct i2c_msg *msgs, int num)\n{\n\treturn rk3x_i2c_xfer_common(adap, msgs, num, false);\n}\n\nstatic int rk3x_i2c_xfer_polling(struct i2c_adapter *adap,\n\t\t\t\t struct i2c_msg *msgs, int num)\n{\n\treturn rk3x_i2c_xfer_common(adap, msgs, num, true);\n}\n\nstatic __maybe_unused int rk3x_i2c_resume(struct device *dev)\n{\n\tstruct rk3x_i2c *i2c = dev_get_drvdata(dev);\n\n\trk3x_i2c_adapt_div(i2c, clk_get_rate(i2c->clk));\n\n\treturn 0;\n}\n\nstatic u32 rk3x_i2c_func(struct i2c_adapter *adap)\n{\n\treturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL | I2C_FUNC_PROTOCOL_MANGLING;\n}\n\nstatic const struct i2c_algorithm rk3x_i2c_algorithm = {\n\t.master_xfer\t\t= rk3x_i2c_xfer,\n\t.master_xfer_atomic\t= rk3x_i2c_xfer_polling,\n\t.functionality\t\t= rk3x_i2c_func,\n};\n\nstatic const struct rk3x_i2c_soc_data rv1108_soc_data = {\n\t.grf_offset = -1,\n\t.calc_timings = rk3x_i2c_v1_calc_timings,\n};\n\nstatic const struct rk3x_i2c_soc_data rv1126_soc_data = {\n\t.grf_offset = 0x118,\n\t.calc_timings = rk3x_i2c_v1_calc_timings,\n};\n\nstatic const struct rk3x_i2c_soc_data rk3066_soc_data = {\n\t.grf_offset = 0x154,\n\t.calc_timings = rk3x_i2c_v0_calc_timings,\n};\n\nstatic const struct rk3x_i2c_soc_data rk3188_soc_data = {\n\t.grf_offset = 0x0a4,\n\t.calc_timings = rk3x_i2c_v0_calc_timings,\n};\n\nstatic const struct rk3x_i2c_soc_data rk3228_soc_data = {\n\t.grf_offset = -1,\n\t.calc_timings = rk3x_i2c_v0_calc_timings,\n};\n\nstatic const struct rk3x_i2c_soc_data rk3288_soc_data = {\n\t.grf_offset = -1,\n\t.calc_timings = rk3x_i2c_v0_calc_timings,\n};\n\nstatic const struct rk3x_i2c_soc_data rk3399_soc_data = {\n\t.grf_offset = -1,\n\t.calc_timings = rk3x_i2c_v1_calc_timings,\n};\n\nstatic const struct of_device_id rk3x_i2c_match[] = {\n\t{\n\t\t.compatible = \"rockchip,rv1108-i2c\",\n\t\t.data = &rv1108_soc_data\n\t},\n\t{\n\t\t.compatible = \"rockchip,rv1126-i2c\",\n\t\t.data = &rv1126_soc_data\n\t},\n\t{\n\t\t.compatible = \"rockchip,rk3066-i2c\",\n\t\t.data = &rk3066_soc_data\n\t},\n\t{\n\t\t.compatible = \"rockchip,rk3188-i2c\",\n\t\t.data = &rk3188_soc_data\n\t},\n\t{\n\t\t.compatible = \"rockchip,rk3228-i2c\",\n\t\t.data = &rk3228_soc_data\n\t},\n\t{\n\t\t.compatible = \"rockchip,rk3288-i2c\",\n\t\t.data = &rk3288_soc_data\n\t},\n\t{\n\t\t.compatible = \"rockchip,rk3399-i2c\",\n\t\t.data = &rk3399_soc_data\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, rk3x_i2c_match);\n\nstatic int rk3x_i2c_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tconst struct of_device_id *match;\n\tstruct rk3x_i2c *i2c;\n\tint ret = 0;\n\tint bus_nr;\n\tu32 value;\n\tint irq;\n\tunsigned long clk_rate;\n\n\ti2c = devm_kzalloc(&pdev->dev, sizeof(struct rk3x_i2c), GFP_KERNEL);\n\tif (!i2c)\n\t\treturn -ENOMEM;\n\n\tmatch = of_match_node(rk3x_i2c_match, np);\n\ti2c->soc_data = match->data;\n\n\t \n\ti2c_parse_fw_timings(&pdev->dev, &i2c->t, true);\n\n\tstrscpy(i2c->adap.name, \"rk3x-i2c\", sizeof(i2c->adap.name));\n\ti2c->adap.owner = THIS_MODULE;\n\ti2c->adap.algo = &rk3x_i2c_algorithm;\n\ti2c->adap.retries = 3;\n\ti2c->adap.dev.of_node = np;\n\ti2c->adap.algo_data = i2c;\n\ti2c->adap.dev.parent = &pdev->dev;\n\n\ti2c->dev = &pdev->dev;\n\n\tspin_lock_init(&i2c->lock);\n\tinit_waitqueue_head(&i2c->wait);\n\n\ti2c->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(i2c->regs))\n\t\treturn PTR_ERR(i2c->regs);\n\n\t \n\tbus_nr = of_alias_get_id(np, \"i2c\");\n\n\t \n\tif (i2c->soc_data->grf_offset >= 0) {\n\t\tstruct regmap *grf;\n\n\t\tgrf = syscon_regmap_lookup_by_phandle(np, \"rockchip,grf\");\n\t\tif (IS_ERR(grf)) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"rk3x-i2c needs 'rockchip,grf' property\\n\");\n\t\t\treturn PTR_ERR(grf);\n\t\t}\n\n\t\tif (bus_nr < 0) {\n\t\t\tdev_err(&pdev->dev, \"rk3x-i2c needs i2cX alias\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tvalue = BIT(27 + bus_nr) | BIT(11 + bus_nr);\n\n\t\tret = regmap_write(grf, i2c->soc_data->grf_offset, value);\n\t\tif (ret != 0) {\n\t\t\tdev_err(i2c->dev, \"Could not write to GRF: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tret = devm_request_irq(&pdev->dev, irq, rk3x_i2c_irq,\n\t\t\t       0, dev_name(&pdev->dev), i2c);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"cannot request IRQ\\n\");\n\t\treturn ret;\n\t}\n\n\ti2c->irq = irq;\n\n\tplatform_set_drvdata(pdev, i2c);\n\n\tif (i2c->soc_data->calc_timings == rk3x_i2c_v0_calc_timings) {\n\t\t \n\t\ti2c->clk = devm_clk_get(&pdev->dev, NULL);\n\t\ti2c->pclk = i2c->clk;\n\t} else {\n\t\ti2c->clk = devm_clk_get(&pdev->dev, \"i2c\");\n\t\ti2c->pclk = devm_clk_get(&pdev->dev, \"pclk\");\n\t}\n\n\tif (IS_ERR(i2c->clk))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(i2c->clk),\n\t\t\t\t     \"Can't get bus clk\\n\");\n\n\tif (IS_ERR(i2c->pclk))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(i2c->pclk),\n\t\t\t\t     \"Can't get periph clk\\n\");\n\n\tret = clk_prepare(i2c->clk);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"Can't prepare bus clk: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tret = clk_prepare(i2c->pclk);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"Can't prepare periph clock: %d\\n\", ret);\n\t\tgoto err_clk;\n\t}\n\n\ti2c->clk_rate_nb.notifier_call = rk3x_i2c_clk_notifier_cb;\n\tret = clk_notifier_register(i2c->clk, &i2c->clk_rate_nb);\n\tif (ret != 0) {\n\t\tdev_err(&pdev->dev, \"Unable to register clock notifier\\n\");\n\t\tgoto err_pclk;\n\t}\n\n\tret = clk_enable(i2c->clk);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"Can't enable bus clk: %d\\n\", ret);\n\t\tgoto err_clk_notifier;\n\t}\n\n\tclk_rate = clk_get_rate(i2c->clk);\n\trk3x_i2c_adapt_div(i2c, clk_rate);\n\tclk_disable(i2c->clk);\n\n\tret = i2c_add_adapter(&i2c->adap);\n\tif (ret < 0)\n\t\tgoto err_clk_notifier;\n\n\treturn 0;\n\nerr_clk_notifier:\n\tclk_notifier_unregister(i2c->clk, &i2c->clk_rate_nb);\nerr_pclk:\n\tclk_unprepare(i2c->pclk);\nerr_clk:\n\tclk_unprepare(i2c->clk);\n\treturn ret;\n}\n\nstatic void rk3x_i2c_remove(struct platform_device *pdev)\n{\n\tstruct rk3x_i2c *i2c = platform_get_drvdata(pdev);\n\n\ti2c_del_adapter(&i2c->adap);\n\n\tclk_notifier_unregister(i2c->clk, &i2c->clk_rate_nb);\n\tclk_unprepare(i2c->pclk);\n\tclk_unprepare(i2c->clk);\n}\n\nstatic SIMPLE_DEV_PM_OPS(rk3x_i2c_pm_ops, NULL, rk3x_i2c_resume);\n\nstatic struct platform_driver rk3x_i2c_driver = {\n\t.probe   = rk3x_i2c_probe,\n\t.remove_new = rk3x_i2c_remove,\n\t.driver  = {\n\t\t.name  = \"rk3x-i2c\",\n\t\t.of_match_table = rk3x_i2c_match,\n\t\t.pm = &rk3x_i2c_pm_ops,\n\t},\n};\n\nmodule_platform_driver(rk3x_i2c_driver);\n\nMODULE_DESCRIPTION(\"Rockchip RK3xxx I2C Bus driver\");\nMODULE_AUTHOR(\"Max Schwarz <max.schwarz@online.de>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}