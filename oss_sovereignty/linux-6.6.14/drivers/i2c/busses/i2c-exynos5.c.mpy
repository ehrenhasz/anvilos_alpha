{
  "module_name": "i2c-exynos5.c",
  "hash_id": "c0a6a98994c9ce128229794206f78ade4270b870e125f667aef07e18f4816535",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-exynos5.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n\n#include <linux/i2c.h>\n#include <linux/time.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/platform_device.h>\n#include <linux/clk.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/spinlock.h>\n\n \n\n \n#define HSI2C_CTL\t\t0x00\n#define HSI2C_FIFO_CTL\t\t0x04\n#define HSI2C_TRAILIG_CTL\t0x08\n#define HSI2C_CLK_CTL\t\t0x0C\n#define HSI2C_CLK_SLOT\t\t0x10\n#define HSI2C_INT_ENABLE\t0x20\n#define HSI2C_INT_STATUS\t0x24\n#define HSI2C_ERR_STATUS\t0x2C\n#define HSI2C_FIFO_STATUS\t0x30\n#define HSI2C_TX_DATA\t\t0x34\n#define HSI2C_RX_DATA\t\t0x38\n#define HSI2C_CONF\t\t0x40\n#define HSI2C_AUTO_CONF\t\t0x44\n#define HSI2C_TIMEOUT\t\t0x48\n#define HSI2C_MANUAL_CMD\t0x4C\n#define HSI2C_TRANS_STATUS\t0x50\n#define HSI2C_TIMING_HS1\t0x54\n#define HSI2C_TIMING_HS2\t0x58\n#define HSI2C_TIMING_HS3\t0x5C\n#define HSI2C_TIMING_FS1\t0x60\n#define HSI2C_TIMING_FS2\t0x64\n#define HSI2C_TIMING_FS3\t0x68\n#define HSI2C_TIMING_SLA\t0x6C\n#define HSI2C_ADDR\t\t0x70\n\n \n#define HSI2C_FUNC_MODE_I2C\t\t\t(1u << 0)\n#define HSI2C_MASTER\t\t\t\t(1u << 3)\n#define HSI2C_RXCHON\t\t\t\t(1u << 6)\n#define HSI2C_TXCHON\t\t\t\t(1u << 7)\n#define HSI2C_SW_RST\t\t\t\t(1u << 31)\n\n \n#define HSI2C_RXFIFO_EN\t\t\t\t(1u << 0)\n#define HSI2C_TXFIFO_EN\t\t\t\t(1u << 1)\n#define HSI2C_RXFIFO_TRIGGER_LEVEL(x)\t\t((x) << 4)\n#define HSI2C_TXFIFO_TRIGGER_LEVEL(x)\t\t((x) << 16)\n\n \n#define HSI2C_TRAILING_COUNT\t\t\t(0xf)\n\n \n#define HSI2C_INT_TX_ALMOSTEMPTY_EN\t\t(1u << 0)\n#define HSI2C_INT_RX_ALMOSTFULL_EN\t\t(1u << 1)\n#define HSI2C_INT_TRAILING_EN\t\t\t(1u << 6)\n\n \n#define HSI2C_INT_TX_ALMOSTEMPTY\t\t(1u << 0)\n#define HSI2C_INT_RX_ALMOSTFULL\t\t\t(1u << 1)\n#define HSI2C_INT_TX_UNDERRUN\t\t\t(1u << 2)\n#define HSI2C_INT_TX_OVERRUN\t\t\t(1u << 3)\n#define HSI2C_INT_RX_UNDERRUN\t\t\t(1u << 4)\n#define HSI2C_INT_RX_OVERRUN\t\t\t(1u << 5)\n#define HSI2C_INT_TRAILING\t\t\t(1u << 6)\n#define HSI2C_INT_I2C\t\t\t\t(1u << 9)\n\n#define HSI2C_INT_TRANS_DONE\t\t\t(1u << 7)\n#define HSI2C_INT_TRANS_ABORT\t\t\t(1u << 8)\n#define HSI2C_INT_NO_DEV_ACK\t\t\t(1u << 9)\n#define HSI2C_INT_NO_DEV\t\t\t(1u << 10)\n#define HSI2C_INT_TIMEOUT\t\t\t(1u << 11)\n#define HSI2C_INT_I2C_TRANS\t\t\t(HSI2C_INT_TRANS_DONE |\t\\\n\t\t\t\t\t\tHSI2C_INT_TRANS_ABORT |\t\\\n\t\t\t\t\t\tHSI2C_INT_NO_DEV_ACK |\t\\\n\t\t\t\t\t\tHSI2C_INT_NO_DEV |\t\\\n\t\t\t\t\t\tHSI2C_INT_TIMEOUT)\n\n \n#define HSI2C_RX_FIFO_EMPTY\t\t\t(1u << 24)\n#define HSI2C_RX_FIFO_FULL\t\t\t(1u << 23)\n#define HSI2C_RX_FIFO_LVL(x)\t\t\t((x >> 16) & 0x7f)\n#define HSI2C_TX_FIFO_EMPTY\t\t\t(1u << 8)\n#define HSI2C_TX_FIFO_FULL\t\t\t(1u << 7)\n#define HSI2C_TX_FIFO_LVL(x)\t\t\t((x >> 0) & 0x7f)\n\n \n#define HSI2C_AUTO_MODE\t\t\t\t(1u << 31)\n#define HSI2C_10BIT_ADDR_MODE\t\t\t(1u << 30)\n#define HSI2C_HS_MODE\t\t\t\t(1u << 29)\n\n \n#define HSI2C_READ_WRITE\t\t\t(1u << 16)\n#define HSI2C_STOP_AFTER_TRANS\t\t\t(1u << 17)\n#define HSI2C_MASTER_RUN\t\t\t(1u << 31)\n\n \n#define HSI2C_TIMEOUT_EN\t\t\t(1u << 31)\n#define HSI2C_TIMEOUT_MASK\t\t\t0xff\n\n \n#define HSI2C_CMD_READ_DATA\t\t\t(1u << 4)\n#define HSI2C_CMD_SEND_STOP\t\t\t(1u << 2)\n\n \n#define HSI2C_MASTER_BUSY\t\t\t(1u << 17)\n#define HSI2C_SLAVE_BUSY\t\t\t(1u << 16)\n\n \n#define HSI2C_TIMEOUT_AUTO\t\t\t(1u << 4)\n#define HSI2C_NO_DEV\t\t\t\t(1u << 3)\n#define HSI2C_NO_DEV_ACK\t\t\t(1u << 2)\n#define HSI2C_TRANS_ABORT\t\t\t(1u << 1)\n#define HSI2C_TRANS_DONE\t\t\t(1u << 0)\n\n \n#define HSI2C_MASTER_ST_MASK\t\t\t0xf\n#define HSI2C_MASTER_ST_IDLE\t\t\t0x0\n#define HSI2C_MASTER_ST_START\t\t\t0x1\n#define HSI2C_MASTER_ST_RESTART\t\t\t0x2\n#define HSI2C_MASTER_ST_STOP\t\t\t0x3\n#define HSI2C_MASTER_ST_MASTER_ID\t\t0x4\n#define HSI2C_MASTER_ST_ADDR0\t\t\t0x5\n#define HSI2C_MASTER_ST_ADDR1\t\t\t0x6\n#define HSI2C_MASTER_ST_ADDR2\t\t\t0x7\n#define HSI2C_MASTER_ST_ADDR_SR\t\t\t0x8\n#define HSI2C_MASTER_ST_READ\t\t\t0x9\n#define HSI2C_MASTER_ST_WRITE\t\t\t0xa\n#define HSI2C_MASTER_ST_NO_ACK\t\t\t0xb\n#define HSI2C_MASTER_ST_LOSE\t\t\t0xc\n#define HSI2C_MASTER_ST_WAIT\t\t\t0xd\n#define HSI2C_MASTER_ST_WAIT_CMD\t\t0xe\n\n \n#define HSI2C_SLV_ADDR_SLV(x)\t\t\t((x & 0x3ff) << 0)\n#define HSI2C_SLV_ADDR_MAS(x)\t\t\t((x & 0x3ff) << 10)\n#define HSI2C_MASTER_ID(x)\t\t\t((x & 0xff) << 24)\n#define MASTER_ID(x)\t\t\t\t((x & 0x7) + 0x08)\n\n#define EXYNOS5_I2C_TIMEOUT (msecs_to_jiffies(100))\n\nenum i2c_type_exynos {\n\tI2C_TYPE_EXYNOS5,\n\tI2C_TYPE_EXYNOS7,\n\tI2C_TYPE_EXYNOSAUTOV9,\n};\n\nstruct exynos5_i2c {\n\tstruct i2c_adapter\tadap;\n\n\tstruct i2c_msg\t\t*msg;\n\tstruct completion\tmsg_complete;\n\tunsigned int\t\tmsg_ptr;\n\n\tunsigned int\t\tirq;\n\n\tvoid __iomem\t\t*regs;\n\tstruct clk\t\t*clk;\t\t \n\tstruct clk\t\t*pclk;\t\t \n\tstruct device\t\t*dev;\n\tint\t\t\tstate;\n\n\tspinlock_t\t\tlock;\t\t \n\n\t \n\tint\t\t\ttrans_done;\n\n\t \n\tunsigned int\t\top_clock;\n\n\t \n\tconst struct exynos_hsi2c_variant *variant;\n};\n\n \nstruct exynos_hsi2c_variant {\n\tunsigned int\t\tfifo_depth;\n\tenum i2c_type_exynos\thw;\n};\n\nstatic const struct exynos_hsi2c_variant exynos5250_hsi2c_data = {\n\t.fifo_depth\t= 64,\n\t.hw\t\t= I2C_TYPE_EXYNOS5,\n};\n\nstatic const struct exynos_hsi2c_variant exynos5260_hsi2c_data = {\n\t.fifo_depth\t= 16,\n\t.hw\t\t= I2C_TYPE_EXYNOS5,\n};\n\nstatic const struct exynos_hsi2c_variant exynos7_hsi2c_data = {\n\t.fifo_depth\t= 16,\n\t.hw\t\t= I2C_TYPE_EXYNOS7,\n};\n\nstatic const struct exynos_hsi2c_variant exynosautov9_hsi2c_data = {\n\t.fifo_depth\t= 64,\n\t.hw\t\t= I2C_TYPE_EXYNOSAUTOV9,\n};\n\nstatic const struct of_device_id exynos5_i2c_match[] = {\n\t{\n\t\t.compatible = \"samsung,exynos5-hsi2c\",\n\t\t.data = &exynos5250_hsi2c_data\n\t}, {\n\t\t.compatible = \"samsung,exynos5250-hsi2c\",\n\t\t.data = &exynos5250_hsi2c_data\n\t}, {\n\t\t.compatible = \"samsung,exynos5260-hsi2c\",\n\t\t.data = &exynos5260_hsi2c_data\n\t}, {\n\t\t.compatible = \"samsung,exynos7-hsi2c\",\n\t\t.data = &exynos7_hsi2c_data\n\t}, {\n\t\t.compatible = \"samsung,exynosautov9-hsi2c\",\n\t\t.data = &exynosautov9_hsi2c_data\n\t}, {},\n};\nMODULE_DEVICE_TABLE(of, exynos5_i2c_match);\n\nstatic void exynos5_i2c_clr_pend_irq(struct exynos5_i2c *i2c)\n{\n\twritel(readl(i2c->regs + HSI2C_INT_STATUS),\n\t\t\t\ti2c->regs + HSI2C_INT_STATUS);\n}\n\n \nstatic int exynos5_i2c_set_timing(struct exynos5_i2c *i2c, bool hs_timings)\n{\n\tu32 i2c_timing_s1;\n\tu32 i2c_timing_s2;\n\tu32 i2c_timing_s3;\n\tu32 i2c_timing_sla;\n\tunsigned int t_start_su, t_start_hd;\n\tunsigned int t_stop_su;\n\tunsigned int t_data_su, t_data_hd;\n\tunsigned int t_scl_l, t_scl_h;\n\tunsigned int t_sr_release;\n\tunsigned int t_ftl_cycle;\n\tunsigned int clkin = clk_get_rate(i2c->clk);\n\tunsigned int op_clk = hs_timings ? i2c->op_clock :\n\t\t(i2c->op_clock >= I2C_MAX_FAST_MODE_PLUS_FREQ) ? I2C_MAX_STANDARD_MODE_FREQ :\n\t\ti2c->op_clock;\n\tint div, clk_cycle, temp;\n\n\t \n\tif (i2c->variant->hw == I2C_TYPE_EXYNOSAUTOV9) {\n\t\tdiv = ((clkin / (16 * i2c->op_clock)) - 1);\n\t\ti2c_timing_s3 = div << 16;\n\t\tif (hs_timings)\n\t\t\twritel(i2c_timing_s3, i2c->regs + HSI2C_TIMING_HS3);\n\t\telse\n\t\t\twritel(i2c_timing_s3, i2c->regs + HSI2C_TIMING_FS3);\n\n\t\treturn 0;\n\t}\n\n\t \n\tt_ftl_cycle = (readl(i2c->regs + HSI2C_CONF) >> 16) & 0x7;\n\ttemp = clkin / op_clk - 8 - t_ftl_cycle;\n\tif (i2c->variant->hw != I2C_TYPE_EXYNOS7)\n\t\ttemp -= t_ftl_cycle;\n\tdiv = temp / 512;\n\tclk_cycle = temp / (div + 1) - 2;\n\tif (temp < 4 || div >= 256 || clk_cycle < 2) {\n\t\tdev_err(i2c->dev, \"%s clock set-up failed\\n\",\n\t\t\ths_timings ? \"HS\" : \"FS\");\n\t\treturn -EINVAL;\n\t}\n\n\tt_scl_l = clk_cycle / 2;\n\tt_scl_h = clk_cycle / 2;\n\tt_start_su = t_scl_l;\n\tt_start_hd = t_scl_l;\n\tt_stop_su = t_scl_l;\n\tt_data_su = t_scl_l / 2;\n\tt_data_hd = t_scl_l / 2;\n\tt_sr_release = clk_cycle;\n\n\ti2c_timing_s1 = t_start_su << 24 | t_start_hd << 16 | t_stop_su << 8;\n\ti2c_timing_s2 = t_data_su << 24 | t_scl_l << 8 | t_scl_h << 0;\n\ti2c_timing_s3 = div << 16 | t_sr_release << 0;\n\ti2c_timing_sla = t_data_hd << 0;\n\n\tdev_dbg(i2c->dev, \"tSTART_SU: %X, tSTART_HD: %X, tSTOP_SU: %X\\n\",\n\t\tt_start_su, t_start_hd, t_stop_su);\n\tdev_dbg(i2c->dev, \"tDATA_SU: %X, tSCL_L: %X, tSCL_H: %X\\n\",\n\t\tt_data_su, t_scl_l, t_scl_h);\n\tdev_dbg(i2c->dev, \"nClkDiv: %X, tSR_RELEASE: %X\\n\",\n\t\tdiv, t_sr_release);\n\tdev_dbg(i2c->dev, \"tDATA_HD: %X\\n\", t_data_hd);\n\n\tif (hs_timings) {\n\t\twritel(i2c_timing_s1, i2c->regs + HSI2C_TIMING_HS1);\n\t\twritel(i2c_timing_s2, i2c->regs + HSI2C_TIMING_HS2);\n\t\twritel(i2c_timing_s3, i2c->regs + HSI2C_TIMING_HS3);\n\t} else {\n\t\twritel(i2c_timing_s1, i2c->regs + HSI2C_TIMING_FS1);\n\t\twritel(i2c_timing_s2, i2c->regs + HSI2C_TIMING_FS2);\n\t\twritel(i2c_timing_s3, i2c->regs + HSI2C_TIMING_FS3);\n\t}\n\twritel(i2c_timing_sla, i2c->regs + HSI2C_TIMING_SLA);\n\n\treturn 0;\n}\n\nstatic int exynos5_hsi2c_clock_setup(struct exynos5_i2c *i2c)\n{\n\t \n\tint ret = exynos5_i2c_set_timing(i2c, false);\n\n\tif (ret < 0 || i2c->op_clock < I2C_MAX_FAST_MODE_PLUS_FREQ)\n\t\treturn ret;\n\n\treturn exynos5_i2c_set_timing(i2c, true);\n}\n\n \nstatic void exynos5_i2c_init(struct exynos5_i2c *i2c)\n{\n\tu32 i2c_conf = readl(i2c->regs + HSI2C_CONF);\n\tu32 i2c_timeout = readl(i2c->regs + HSI2C_TIMEOUT);\n\n\t \n\ti2c_timeout &= ~HSI2C_TIMEOUT_EN;\n\twritel(i2c_timeout, i2c->regs + HSI2C_TIMEOUT);\n\n\twritel((HSI2C_FUNC_MODE_I2C | HSI2C_MASTER),\n\t\t\t\t\ti2c->regs + HSI2C_CTL);\n\twritel(HSI2C_TRAILING_COUNT, i2c->regs + HSI2C_TRAILIG_CTL);\n\n\tif (i2c->op_clock >= I2C_MAX_FAST_MODE_PLUS_FREQ) {\n\t\twritel(HSI2C_MASTER_ID(MASTER_ID(i2c->adap.nr)),\n\t\t\t\t\ti2c->regs + HSI2C_ADDR);\n\t\ti2c_conf |= HSI2C_HS_MODE;\n\t}\n\n\twritel(i2c_conf | HSI2C_AUTO_MODE, i2c->regs + HSI2C_CONF);\n}\n\nstatic void exynos5_i2c_reset(struct exynos5_i2c *i2c)\n{\n\tu32 i2c_ctl;\n\n\t \n\ti2c_ctl = readl(i2c->regs + HSI2C_CTL);\n\ti2c_ctl |= HSI2C_SW_RST;\n\twritel(i2c_ctl, i2c->regs + HSI2C_CTL);\n\n\ti2c_ctl = readl(i2c->regs + HSI2C_CTL);\n\ti2c_ctl &= ~HSI2C_SW_RST;\n\twritel(i2c_ctl, i2c->regs + HSI2C_CTL);\n\n\t \n\texynos5_hsi2c_clock_setup(i2c);\n\t \n\texynos5_i2c_init(i2c);\n}\n\n \nstatic irqreturn_t exynos5_i2c_irq(int irqno, void *dev_id)\n{\n\tstruct exynos5_i2c *i2c = dev_id;\n\tu32 fifo_level, int_status, fifo_status, trans_status;\n\tunsigned char byte;\n\tint len = 0;\n\n\ti2c->state = -EINVAL;\n\n\tspin_lock(&i2c->lock);\n\n\tint_status = readl(i2c->regs + HSI2C_INT_STATUS);\n\twritel(int_status, i2c->regs + HSI2C_INT_STATUS);\n\n\t \n\tswitch (i2c->variant->hw) {\n\tcase I2C_TYPE_EXYNOSAUTOV9:\n\t\tfallthrough;\n\tcase I2C_TYPE_EXYNOS7:\n\t\tif (int_status & HSI2C_INT_TRANS_DONE) {\n\t\t\ti2c->trans_done = 1;\n\t\t\ti2c->state = 0;\n\t\t} else if (int_status & HSI2C_INT_TRANS_ABORT) {\n\t\t\tdev_dbg(i2c->dev, \"Deal with arbitration lose\\n\");\n\t\t\ti2c->state = -EAGAIN;\n\t\t\tgoto stop;\n\t\t} else if (int_status & HSI2C_INT_NO_DEV_ACK) {\n\t\t\tdev_dbg(i2c->dev, \"No ACK from device\\n\");\n\t\t\ti2c->state = -ENXIO;\n\t\t\tgoto stop;\n\t\t} else if (int_status & HSI2C_INT_NO_DEV) {\n\t\t\tdev_dbg(i2c->dev, \"No device\\n\");\n\t\t\ti2c->state = -ENXIO;\n\t\t\tgoto stop;\n\t\t} else if (int_status & HSI2C_INT_TIMEOUT) {\n\t\t\tdev_dbg(i2c->dev, \"Accessing device timed out\\n\");\n\t\t\ti2c->state = -ETIMEDOUT;\n\t\t\tgoto stop;\n\t\t}\n\n\t\tbreak;\n\tcase I2C_TYPE_EXYNOS5:\n\t\tif (!(int_status & HSI2C_INT_I2C))\n\t\t\tbreak;\n\n\t\ttrans_status = readl(i2c->regs + HSI2C_TRANS_STATUS);\n\t\tif (trans_status & HSI2C_NO_DEV_ACK) {\n\t\t\tdev_dbg(i2c->dev, \"No ACK from device\\n\");\n\t\t\ti2c->state = -ENXIO;\n\t\t\tgoto stop;\n\t\t} else if (trans_status & HSI2C_NO_DEV) {\n\t\t\tdev_dbg(i2c->dev, \"No device\\n\");\n\t\t\ti2c->state = -ENXIO;\n\t\t\tgoto stop;\n\t\t} else if (trans_status & HSI2C_TRANS_ABORT) {\n\t\t\tdev_dbg(i2c->dev, \"Deal with arbitration lose\\n\");\n\t\t\ti2c->state = -EAGAIN;\n\t\t\tgoto stop;\n\t\t} else if (trans_status & HSI2C_TIMEOUT_AUTO) {\n\t\t\tdev_dbg(i2c->dev, \"Accessing device timed out\\n\");\n\t\t\ti2c->state = -ETIMEDOUT;\n\t\t\tgoto stop;\n\t\t} else if (trans_status & HSI2C_TRANS_DONE) {\n\t\t\ti2c->trans_done = 1;\n\t\t\ti2c->state = 0;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tif ((i2c->msg->flags & I2C_M_RD) && (int_status &\n\t\t\t(HSI2C_INT_TRAILING | HSI2C_INT_RX_ALMOSTFULL))) {\n\t\tfifo_status = readl(i2c->regs + HSI2C_FIFO_STATUS);\n\t\tfifo_level = HSI2C_RX_FIFO_LVL(fifo_status);\n\t\tlen = min(fifo_level, i2c->msg->len - i2c->msg_ptr);\n\n\t\twhile (len > 0) {\n\t\t\tbyte = (unsigned char)\n\t\t\t\treadl(i2c->regs + HSI2C_RX_DATA);\n\t\t\ti2c->msg->buf[i2c->msg_ptr++] = byte;\n\t\t\tlen--;\n\t\t}\n\t\ti2c->state = 0;\n\t} else if (int_status & HSI2C_INT_TX_ALMOSTEMPTY) {\n\t\tfifo_status = readl(i2c->regs + HSI2C_FIFO_STATUS);\n\t\tfifo_level = HSI2C_TX_FIFO_LVL(fifo_status);\n\n\t\tlen = i2c->variant->fifo_depth - fifo_level;\n\t\tif (len > (i2c->msg->len - i2c->msg_ptr)) {\n\t\t\tu32 int_en = readl(i2c->regs + HSI2C_INT_ENABLE);\n\n\t\t\tint_en &= ~HSI2C_INT_TX_ALMOSTEMPTY_EN;\n\t\t\twritel(int_en, i2c->regs + HSI2C_INT_ENABLE);\n\t\t\tlen = i2c->msg->len - i2c->msg_ptr;\n\t\t}\n\n\t\twhile (len > 0) {\n\t\t\tbyte = i2c->msg->buf[i2c->msg_ptr++];\n\t\t\twritel(byte, i2c->regs + HSI2C_TX_DATA);\n\t\t\tlen--;\n\t\t}\n\t\ti2c->state = 0;\n\t}\n\n stop:\n\tif ((i2c->trans_done && (i2c->msg->len == i2c->msg_ptr)) ||\n\t    (i2c->state < 0)) {\n\t\twritel(0, i2c->regs + HSI2C_INT_ENABLE);\n\t\texynos5_i2c_clr_pend_irq(i2c);\n\t\tcomplete(&i2c->msg_complete);\n\t}\n\n\tspin_unlock(&i2c->lock);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic int exynos5_i2c_wait_bus_idle(struct exynos5_i2c *i2c)\n{\n\tunsigned long stop_time;\n\tu32 trans_status;\n\n\t \n\tstop_time = jiffies + msecs_to_jiffies(100) + 1;\n\tdo {\n\t\ttrans_status = readl(i2c->regs + HSI2C_TRANS_STATUS);\n\t\tif (!(trans_status & HSI2C_MASTER_BUSY))\n\t\t\treturn 0;\n\n\t\tusleep_range(50, 200);\n\t} while (time_before(jiffies, stop_time));\n\n\treturn -EBUSY;\n}\n\nstatic void exynos5_i2c_bus_recover(struct exynos5_i2c *i2c)\n{\n\tu32 val;\n\n\tval = readl(i2c->regs + HSI2C_CTL) | HSI2C_RXCHON;\n\twritel(val, i2c->regs + HSI2C_CTL);\n\tval = readl(i2c->regs + HSI2C_CONF) & ~HSI2C_AUTO_MODE;\n\twritel(val, i2c->regs + HSI2C_CONF);\n\n\t \n\twritel(HSI2C_CMD_READ_DATA, i2c->regs + HSI2C_MANUAL_CMD);\n\texynos5_i2c_wait_bus_idle(i2c);\n\twritel(HSI2C_CMD_SEND_STOP, i2c->regs + HSI2C_MANUAL_CMD);\n\texynos5_i2c_wait_bus_idle(i2c);\n\n\tval = readl(i2c->regs + HSI2C_CTL) & ~HSI2C_RXCHON;\n\twritel(val, i2c->regs + HSI2C_CTL);\n\tval = readl(i2c->regs + HSI2C_CONF) | HSI2C_AUTO_MODE;\n\twritel(val, i2c->regs + HSI2C_CONF);\n}\n\nstatic void exynos5_i2c_bus_check(struct exynos5_i2c *i2c)\n{\n\tunsigned long timeout;\n\n\tif (i2c->variant->hw == I2C_TYPE_EXYNOS5)\n\t\treturn;\n\n\t \n\ttimeout = jiffies + msecs_to_jiffies(100);\n\tfor (;;) {\n\t\tu32 st = readl(i2c->regs + HSI2C_TRANS_STATUS);\n\n\t\tif ((st & HSI2C_MASTER_ST_MASK) != HSI2C_MASTER_ST_LOSE)\n\t\t\treturn;\n\n\t\tif (time_is_before_jiffies(timeout))\n\t\t\treturn;\n\n\t\texynos5_i2c_bus_recover(i2c);\n\t}\n}\n\n \nstatic void exynos5_i2c_message_start(struct exynos5_i2c *i2c, int stop)\n{\n\tu32 i2c_ctl;\n\tu32 int_en = 0;\n\tu32 i2c_auto_conf = 0;\n\tu32 i2c_addr = 0;\n\tu32 fifo_ctl;\n\tunsigned long flags;\n\tunsigned short trig_lvl;\n\n\tif (i2c->variant->hw == I2C_TYPE_EXYNOS5)\n\t\tint_en |= HSI2C_INT_I2C;\n\telse\n\t\tint_en |= HSI2C_INT_I2C_TRANS;\n\n\ti2c_ctl = readl(i2c->regs + HSI2C_CTL);\n\ti2c_ctl &= ~(HSI2C_TXCHON | HSI2C_RXCHON);\n\tfifo_ctl = HSI2C_RXFIFO_EN | HSI2C_TXFIFO_EN;\n\n\tif (i2c->msg->flags & I2C_M_RD) {\n\t\ti2c_ctl |= HSI2C_RXCHON;\n\n\t\ti2c_auto_conf |= HSI2C_READ_WRITE;\n\n\t\ttrig_lvl = (i2c->msg->len > i2c->variant->fifo_depth) ?\n\t\t\t(i2c->variant->fifo_depth * 3 / 4) : i2c->msg->len;\n\t\tfifo_ctl |= HSI2C_RXFIFO_TRIGGER_LEVEL(trig_lvl);\n\n\t\tint_en |= (HSI2C_INT_RX_ALMOSTFULL_EN |\n\t\t\tHSI2C_INT_TRAILING_EN);\n\t} else {\n\t\ti2c_ctl |= HSI2C_TXCHON;\n\n\t\ttrig_lvl = (i2c->msg->len > i2c->variant->fifo_depth) ?\n\t\t\t(i2c->variant->fifo_depth * 1 / 4) : i2c->msg->len;\n\t\tfifo_ctl |= HSI2C_TXFIFO_TRIGGER_LEVEL(trig_lvl);\n\n\t\tint_en |= HSI2C_INT_TX_ALMOSTEMPTY_EN;\n\t}\n\n\ti2c_addr = HSI2C_SLV_ADDR_MAS(i2c->msg->addr);\n\n\tif (i2c->op_clock >= I2C_MAX_FAST_MODE_PLUS_FREQ)\n\t\ti2c_addr |= HSI2C_MASTER_ID(MASTER_ID(i2c->adap.nr));\n\n\twritel(i2c_addr, i2c->regs + HSI2C_ADDR);\n\n\twritel(fifo_ctl, i2c->regs + HSI2C_FIFO_CTL);\n\twritel(i2c_ctl, i2c->regs + HSI2C_CTL);\n\n\texynos5_i2c_bus_check(i2c);\n\n\t \n\tspin_lock_irqsave(&i2c->lock, flags);\n\twritel(int_en, i2c->regs + HSI2C_INT_ENABLE);\n\n\tif (stop == 1)\n\t\ti2c_auto_conf |= HSI2C_STOP_AFTER_TRANS;\n\ti2c_auto_conf |= i2c->msg->len;\n\ti2c_auto_conf |= HSI2C_MASTER_RUN;\n\twritel(i2c_auto_conf, i2c->regs + HSI2C_AUTO_CONF);\n\tspin_unlock_irqrestore(&i2c->lock, flags);\n}\n\nstatic int exynos5_i2c_xfer_msg(struct exynos5_i2c *i2c,\n\t\t\t      struct i2c_msg *msgs, int stop)\n{\n\tunsigned long timeout;\n\tint ret;\n\n\ti2c->msg = msgs;\n\ti2c->msg_ptr = 0;\n\ti2c->trans_done = 0;\n\n\treinit_completion(&i2c->msg_complete);\n\n\texynos5_i2c_message_start(i2c, stop);\n\n\ttimeout = wait_for_completion_timeout(&i2c->msg_complete,\n\t\t\t\t\t      EXYNOS5_I2C_TIMEOUT);\n\tif (timeout == 0)\n\t\tret = -ETIMEDOUT;\n\telse\n\t\tret = i2c->state;\n\n\t \n\tif (ret == 0 && stop)\n\t\tret = exynos5_i2c_wait_bus_idle(i2c);\n\n\tif (ret < 0) {\n\t\texynos5_i2c_reset(i2c);\n\t\tif (ret == -ETIMEDOUT)\n\t\t\tdev_warn(i2c->dev, \"%s timeout\\n\",\n\t\t\t\t (msgs->flags & I2C_M_RD) ? \"rx\" : \"tx\");\n\t}\n\n\t \n\treturn ret;\n}\n\nstatic int exynos5_i2c_xfer(struct i2c_adapter *adap,\n\t\t\tstruct i2c_msg *msgs, int num)\n{\n\tstruct exynos5_i2c *i2c = adap->algo_data;\n\tint i, ret;\n\n\tret = clk_enable(i2c->pclk);\n\tif (ret)\n\t\treturn ret;\n\n\tret = clk_enable(i2c->clk);\n\tif (ret)\n\t\tgoto err_pclk;\n\n\tfor (i = 0; i < num; ++i) {\n\t\tret = exynos5_i2c_xfer_msg(i2c, msgs + i, i + 1 == num);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\tclk_disable(i2c->clk);\nerr_pclk:\n\tclk_disable(i2c->pclk);\n\n\treturn ret ?: num;\n}\n\nstatic u32 exynos5_i2c_func(struct i2c_adapter *adap)\n{\n\treturn I2C_FUNC_I2C | (I2C_FUNC_SMBUS_EMUL & ~I2C_FUNC_SMBUS_QUICK);\n}\n\nstatic const struct i2c_algorithm exynos5_i2c_algorithm = {\n\t.master_xfer\t\t= exynos5_i2c_xfer,\n\t.functionality\t\t= exynos5_i2c_func,\n};\n\nstatic int exynos5_i2c_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct exynos5_i2c *i2c;\n\tint ret;\n\n\ti2c = devm_kzalloc(&pdev->dev, sizeof(struct exynos5_i2c), GFP_KERNEL);\n\tif (!i2c)\n\t\treturn -ENOMEM;\n\n\tif (of_property_read_u32(np, \"clock-frequency\", &i2c->op_clock))\n\t\ti2c->op_clock = I2C_MAX_STANDARD_MODE_FREQ;\n\n\tstrscpy(i2c->adap.name, \"exynos5-i2c\", sizeof(i2c->adap.name));\n\ti2c->adap.owner   = THIS_MODULE;\n\ti2c->adap.algo    = &exynos5_i2c_algorithm;\n\ti2c->adap.retries = 3;\n\n\ti2c->dev = &pdev->dev;\n\ti2c->clk = devm_clk_get(&pdev->dev, \"hsi2c\");\n\tif (IS_ERR(i2c->clk)) {\n\t\tdev_err(&pdev->dev, \"cannot get clock\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\ti2c->pclk = devm_clk_get_optional(&pdev->dev, \"hsi2c_pclk\");\n\tif (IS_ERR(i2c->pclk)) {\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(i2c->pclk),\n\t\t\t\t     \"cannot get pclk\");\n\t}\n\n\tret = clk_prepare_enable(i2c->pclk);\n\tif (ret)\n\t\treturn ret;\n\n\tret = clk_prepare_enable(i2c->clk);\n\tif (ret)\n\t\tgoto err_pclk;\n\n\ti2c->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(i2c->regs)) {\n\t\tret = PTR_ERR(i2c->regs);\n\t\tgoto err_clk;\n\t}\n\n\ti2c->adap.dev.of_node = np;\n\ti2c->adap.algo_data = i2c;\n\ti2c->adap.dev.parent = &pdev->dev;\n\n\t \n\texynos5_i2c_clr_pend_irq(i2c);\n\n\tspin_lock_init(&i2c->lock);\n\tinit_completion(&i2c->msg_complete);\n\n\ti2c->irq = ret = platform_get_irq(pdev, 0);\n\tif (ret < 0)\n\t\tgoto err_clk;\n\n\tret = devm_request_irq(&pdev->dev, i2c->irq, exynos5_i2c_irq,\n\t\t\t       IRQF_NO_SUSPEND, dev_name(&pdev->dev), i2c);\n\tif (ret != 0) {\n\t\tdev_err(&pdev->dev, \"cannot request HS-I2C IRQ %d\\n\", i2c->irq);\n\t\tgoto err_clk;\n\t}\n\n\ti2c->variant = of_device_get_match_data(&pdev->dev);\n\n\tret = exynos5_hsi2c_clock_setup(i2c);\n\tif (ret)\n\t\tgoto err_clk;\n\n\texynos5_i2c_reset(i2c);\n\n\tret = i2c_add_adapter(&i2c->adap);\n\tif (ret < 0)\n\t\tgoto err_clk;\n\n\tplatform_set_drvdata(pdev, i2c);\n\n\tclk_disable(i2c->clk);\n\tclk_disable(i2c->pclk);\n\n\treturn 0;\n\n err_clk:\n\tclk_disable_unprepare(i2c->clk);\n\n err_pclk:\n\tclk_disable_unprepare(i2c->pclk);\n\treturn ret;\n}\n\nstatic void exynos5_i2c_remove(struct platform_device *pdev)\n{\n\tstruct exynos5_i2c *i2c = platform_get_drvdata(pdev);\n\n\ti2c_del_adapter(&i2c->adap);\n\n\tclk_unprepare(i2c->clk);\n\tclk_unprepare(i2c->pclk);\n}\n\nstatic int exynos5_i2c_suspend_noirq(struct device *dev)\n{\n\tstruct exynos5_i2c *i2c = dev_get_drvdata(dev);\n\n\ti2c_mark_adapter_suspended(&i2c->adap);\n\tclk_unprepare(i2c->clk);\n\tclk_unprepare(i2c->pclk);\n\n\treturn 0;\n}\n\nstatic int exynos5_i2c_resume_noirq(struct device *dev)\n{\n\tstruct exynos5_i2c *i2c = dev_get_drvdata(dev);\n\tint ret = 0;\n\n\tret = clk_prepare_enable(i2c->pclk);\n\tif (ret)\n\t\treturn ret;\n\n\tret = clk_prepare_enable(i2c->clk);\n\tif (ret)\n\t\tgoto err_pclk;\n\n\tret = exynos5_hsi2c_clock_setup(i2c);\n\tif (ret)\n\t\tgoto err_clk;\n\n\texynos5_i2c_init(i2c);\n\tclk_disable(i2c->clk);\n\tclk_disable(i2c->pclk);\n\ti2c_mark_adapter_resumed(&i2c->adap);\n\n\treturn 0;\n\nerr_clk:\n\tclk_disable_unprepare(i2c->clk);\nerr_pclk:\n\tclk_disable_unprepare(i2c->pclk);\n\treturn ret;\n}\n\nstatic const struct dev_pm_ops exynos5_i2c_dev_pm_ops = {\n\tNOIRQ_SYSTEM_SLEEP_PM_OPS(exynos5_i2c_suspend_noirq,\n\t\t\t\t  exynos5_i2c_resume_noirq)\n};\n\nstatic struct platform_driver exynos5_i2c_driver = {\n\t.probe\t\t= exynos5_i2c_probe,\n\t.remove_new\t= exynos5_i2c_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"exynos5-hsi2c\",\n\t\t.pm\t= pm_sleep_ptr(&exynos5_i2c_dev_pm_ops),\n\t\t.of_match_table = exynos5_i2c_match,\n\t},\n};\n\nmodule_platform_driver(exynos5_i2c_driver);\n\nMODULE_DESCRIPTION(\"Exynos5 HS-I2C Bus driver\");\nMODULE_AUTHOR(\"Naveen Krishna Chatradhi <ch.naveen@samsung.com>\");\nMODULE_AUTHOR(\"Taekgyun Ko <taeggyun.ko@samsung.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}