{
  "module_name": "i2c-xgene-slimpro.c",
  "hash_id": "05fab5ad07923c0e8c36dca703e6ff7f6fb650394dce1cfe8d683a5120c0c7f7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-xgene-slimpro.c",
  "human_readable_source": "\n \n#include <acpi/pcc.h>\n#include <linux/acpi.h>\n#include <linux/dma-mapping.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/mailbox_client.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n\n#define MAILBOX_OP_TIMEOUT\t\t1000\t \n#define MAILBOX_I2C_INDEX\t\t0\n#define SLIMPRO_IIC_BUS\t\t\t1\t \n\n#define SMBUS_CMD_LEN\t\t\t1\n#define BYTE_DATA\t\t\t1\n#define WORD_DATA\t\t\t2\n#define BLOCK_DATA\t\t\t3\n\n#define SLIMPRO_IIC_I2C_PROTOCOL\t0\n#define SLIMPRO_IIC_SMB_PROTOCOL\t1\n\n#define SLIMPRO_IIC_READ\t\t0\n#define SLIMPRO_IIC_WRITE\t\t1\n\n#define IIC_SMB_WITHOUT_DATA_LEN\t0\n#define IIC_SMB_WITH_DATA_LEN\t\t1\n\n#define SLIMPRO_DEBUG_MSG\t\t0\n#define SLIMPRO_MSG_TYPE_SHIFT\t\t28\n#define SLIMPRO_DBG_SUBTYPE_I2C1READ\t4\n#define SLIMPRO_DBGMSG_TYPE_SHIFT\t24\n#define SLIMPRO_DBGMSG_TYPE_MASK\t0x0F000000U\n#define SLIMPRO_IIC_DEV_SHIFT\t\t23\n#define SLIMPRO_IIC_DEV_MASK\t\t0x00800000U\n#define SLIMPRO_IIC_DEVID_SHIFT\t\t13\n#define SLIMPRO_IIC_DEVID_MASK\t\t0x007FE000U\n#define SLIMPRO_IIC_RW_SHIFT\t\t12\n#define SLIMPRO_IIC_RW_MASK\t\t0x00001000U\n#define SLIMPRO_IIC_PROTO_SHIFT\t\t11\n#define SLIMPRO_IIC_PROTO_MASK\t\t0x00000800U\n#define SLIMPRO_IIC_ADDRLEN_SHIFT\t8\n#define SLIMPRO_IIC_ADDRLEN_MASK\t0x00000700U\n#define SLIMPRO_IIC_DATALEN_SHIFT\t0\n#define SLIMPRO_IIC_DATALEN_MASK\t0x000000FFU\n\n \n#define SLIMPRO_IIC_ENCODE_MSG(dev, chip, op, proto, addrlen, datalen) \\\n\t((SLIMPRO_DEBUG_MSG << SLIMPRO_MSG_TYPE_SHIFT) | \\\n\t((SLIMPRO_DBG_SUBTYPE_I2C1READ << SLIMPRO_DBGMSG_TYPE_SHIFT) & \\\n\tSLIMPRO_DBGMSG_TYPE_MASK) | \\\n\t((dev << SLIMPRO_IIC_DEV_SHIFT) & SLIMPRO_IIC_DEV_MASK) | \\\n\t((chip << SLIMPRO_IIC_DEVID_SHIFT) & SLIMPRO_IIC_DEVID_MASK) | \\\n\t((op << SLIMPRO_IIC_RW_SHIFT) & SLIMPRO_IIC_RW_MASK) | \\\n\t((proto << SLIMPRO_IIC_PROTO_SHIFT) & SLIMPRO_IIC_PROTO_MASK) | \\\n\t((addrlen << SLIMPRO_IIC_ADDRLEN_SHIFT) & SLIMPRO_IIC_ADDRLEN_MASK) | \\\n\t((datalen << SLIMPRO_IIC_DATALEN_SHIFT) & SLIMPRO_IIC_DATALEN_MASK))\n\n#define SLIMPRO_MSG_TYPE(v)             (((v) & 0xF0000000) >> 28)\n\n \n#define SLIMPRO_IIC_ENCODE_FLAG_BUFADDR\t\t\t0x80000000\n#define SLIMPRO_IIC_ENCODE_FLAG_WITH_DATA_LEN(a)\t((u32) (((a) << 30) \\\n\t\t\t\t\t\t\t\t& 0x40000000))\n#define SLIMPRO_IIC_ENCODE_UPPER_BUFADDR(a)\t\t((u32) (((a) >> 12) \\\n\t\t\t\t\t\t\t\t& 0x3FF00000))\n#define SLIMPRO_IIC_ENCODE_ADDR(a)\t\t\t((a) & 0x000FFFFF)\n\n#define SLIMPRO_IIC_MSG_DWORD_COUNT\t\t\t3\n\n \n#define PCC_SIGNATURE\t\t\t0x50424300\n#define PCC_STS_CMD_COMPLETE\t\tBIT(0)\n#define PCC_STS_SCI_DOORBELL\t\tBIT(1)\n#define PCC_STS_ERR\t\t\tBIT(2)\n#define PCC_STS_PLAT_NOTIFY\t\tBIT(3)\n#define PCC_CMD_GENERATE_DB_INT\t\tBIT(15)\n\nstruct slimpro_i2c_dev {\n\tstruct i2c_adapter adapter;\n\tstruct device *dev;\n\tstruct mbox_chan *mbox_chan;\n\tstruct pcc_mbox_chan *pcc_chan;\n\tstruct mbox_client mbox_client;\n\tint mbox_idx;\n\tstruct completion rd_complete;\n\tu8 dma_buffer[I2C_SMBUS_BLOCK_MAX + 1];  \n\tu32 *resp_msg;\n\tphys_addr_t comm_base_addr;\n\tvoid *pcc_comm_addr;\n};\n\n#define to_slimpro_i2c_dev(cl)\t\\\n\t\tcontainer_of(cl, struct slimpro_i2c_dev, mbox_client)\n\nenum slimpro_i2c_version {\n\tXGENE_SLIMPRO_I2C_V1 = 0,\n\tXGENE_SLIMPRO_I2C_V2 = 1,\n};\n\n \nstatic u16 xgene_word_tst_and_clr(u16 *addr, u16 mask)\n{\n\tu16 ret, val;\n\n\tval = le16_to_cpu(READ_ONCE(*addr));\n\tret = val & mask;\n\tval &= ~mask;\n\tWRITE_ONCE(*addr, cpu_to_le16(val));\n\n\treturn ret;\n}\n\nstatic void slimpro_i2c_rx_cb(struct mbox_client *cl, void *mssg)\n{\n\tstruct slimpro_i2c_dev *ctx = to_slimpro_i2c_dev(cl);\n\n\t \n\tif (ctx->resp_msg)\n\t\t*ctx->resp_msg = ((u32 *)mssg)[1];\n\n\tif (ctx->mbox_client.tx_block)\n\t\tcomplete(&ctx->rd_complete);\n}\n\nstatic void slimpro_i2c_pcc_rx_cb(struct mbox_client *cl, void *msg)\n{\n\tstruct slimpro_i2c_dev *ctx = to_slimpro_i2c_dev(cl);\n\tstruct acpi_pcct_shared_memory *generic_comm_base = ctx->pcc_comm_addr;\n\n\t \n\tif (!xgene_word_tst_and_clr(&generic_comm_base->status,\n\t\t\t\t    PCC_STS_SCI_DOORBELL))\n\t\treturn;\n\n\tif (xgene_word_tst_and_clr(&generic_comm_base->status,\n\t\t\t\t   PCC_STS_CMD_COMPLETE)) {\n\t\tmsg = generic_comm_base + 1;\n\n\t\t \n\t\tif (ctx->resp_msg)\n\t\t\t*ctx->resp_msg = ((u32 *)msg)[1];\n\n\t\tcomplete(&ctx->rd_complete);\n\t}\n}\n\nstatic void slimpro_i2c_pcc_tx_prepare(struct slimpro_i2c_dev *ctx, u32 *msg)\n{\n\tstruct acpi_pcct_shared_memory *generic_comm_base = ctx->pcc_comm_addr;\n\tu32 *ptr = (void *)(generic_comm_base + 1);\n\tu16 status;\n\tint i;\n\n\tWRITE_ONCE(generic_comm_base->signature,\n\t\t   cpu_to_le32(PCC_SIGNATURE | ctx->mbox_idx));\n\n\tWRITE_ONCE(generic_comm_base->command,\n\t\t   cpu_to_le16(SLIMPRO_MSG_TYPE(msg[0]) | PCC_CMD_GENERATE_DB_INT));\n\n\tstatus = le16_to_cpu(READ_ONCE(generic_comm_base->status));\n\tstatus &= ~PCC_STS_CMD_COMPLETE;\n\tWRITE_ONCE(generic_comm_base->status, cpu_to_le16(status));\n\n\t \n\tfor (i = 0; i < SLIMPRO_IIC_MSG_DWORD_COUNT; i++)\n\t\tWRITE_ONCE(ptr[i], cpu_to_le32(msg[i]));\n}\n\nstatic int start_i2c_msg_xfer(struct slimpro_i2c_dev *ctx)\n{\n\tif (ctx->mbox_client.tx_block || !acpi_disabled) {\n\t\tif (!wait_for_completion_timeout(&ctx->rd_complete,\n\t\t\t\t\t\t msecs_to_jiffies(MAILBOX_OP_TIMEOUT)))\n\t\t\treturn -ETIMEDOUT;\n\t}\n\n\t \n\tif (*ctx->resp_msg == 0xffffffff)\n\t\treturn -ENODEV;\n\n\treturn 0;\n}\n\nstatic int slimpro_i2c_send_msg(struct slimpro_i2c_dev *ctx,\n\t\t\t\tu32 *msg,\n\t\t\t\tu32 *data)\n{\n\tint rc;\n\n\tctx->resp_msg = data;\n\n\tif (!acpi_disabled) {\n\t\treinit_completion(&ctx->rd_complete);\n\t\tslimpro_i2c_pcc_tx_prepare(ctx, msg);\n\t}\n\n\trc = mbox_send_message(ctx->mbox_chan, msg);\n\tif (rc < 0)\n\t\tgoto err;\n\n\trc = start_i2c_msg_xfer(ctx);\n\nerr:\n\tif (!acpi_disabled)\n\t\tmbox_chan_txdone(ctx->mbox_chan, 0);\n\n\tctx->resp_msg = NULL;\n\n\treturn rc;\n}\n\nstatic int slimpro_i2c_rd(struct slimpro_i2c_dev *ctx, u32 chip,\n\t\t\t  u32 addr, u32 addrlen, u32 protocol,\n\t\t\t  u32 readlen, u32 *data)\n{\n\tu32 msg[3];\n\n\tmsg[0] = SLIMPRO_IIC_ENCODE_MSG(SLIMPRO_IIC_BUS, chip,\n\t\t\t\t\tSLIMPRO_IIC_READ, protocol, addrlen, readlen);\n\tmsg[1] = SLIMPRO_IIC_ENCODE_ADDR(addr);\n\tmsg[2] = 0;\n\n\treturn slimpro_i2c_send_msg(ctx, msg, data);\n}\n\nstatic int slimpro_i2c_wr(struct slimpro_i2c_dev *ctx, u32 chip,\n\t\t\t  u32 addr, u32 addrlen, u32 protocol, u32 writelen,\n\t\t\t  u32 data)\n{\n\tu32 msg[3];\n\n\tmsg[0] = SLIMPRO_IIC_ENCODE_MSG(SLIMPRO_IIC_BUS, chip,\n\t\t\t\t\tSLIMPRO_IIC_WRITE, protocol, addrlen, writelen);\n\tmsg[1] = SLIMPRO_IIC_ENCODE_ADDR(addr);\n\tmsg[2] = data;\n\n\treturn slimpro_i2c_send_msg(ctx, msg, msg);\n}\n\nstatic int slimpro_i2c_blkrd(struct slimpro_i2c_dev *ctx, u32 chip, u32 addr,\n\t\t\t     u32 addrlen, u32 protocol, u32 readlen,\n\t\t\t     u32 with_data_len, void *data)\n{\n\tdma_addr_t paddr;\n\tu32 msg[3];\n\tint rc;\n\n\tpaddr = dma_map_single(ctx->dev, ctx->dma_buffer, readlen, DMA_FROM_DEVICE);\n\tif (dma_mapping_error(ctx->dev, paddr)) {\n\t\tdev_err(&ctx->adapter.dev, \"Error in mapping dma buffer %p\\n\",\n\t\t\tctx->dma_buffer);\n\t\treturn -ENOMEM;\n\t}\n\n\tmsg[0] = SLIMPRO_IIC_ENCODE_MSG(SLIMPRO_IIC_BUS, chip, SLIMPRO_IIC_READ,\n\t\t\t\t\tprotocol, addrlen, readlen);\n\tmsg[1] = SLIMPRO_IIC_ENCODE_FLAG_BUFADDR |\n\t\t SLIMPRO_IIC_ENCODE_FLAG_WITH_DATA_LEN(with_data_len) |\n\t\t SLIMPRO_IIC_ENCODE_UPPER_BUFADDR(paddr) |\n\t\t SLIMPRO_IIC_ENCODE_ADDR(addr);\n\tmsg[2] = (u32)paddr;\n\n\trc = slimpro_i2c_send_msg(ctx, msg, msg);\n\n\t \n\tmemcpy(data, ctx->dma_buffer, readlen);\n\n\tdma_unmap_single(ctx->dev, paddr, readlen, DMA_FROM_DEVICE);\n\treturn rc;\n}\n\nstatic int slimpro_i2c_blkwr(struct slimpro_i2c_dev *ctx, u32 chip,\n\t\t\t     u32 addr, u32 addrlen, u32 protocol, u32 writelen,\n\t\t\t     void *data)\n{\n\tdma_addr_t paddr;\n\tu32 msg[3];\n\tint rc;\n\n\tif (writelen > I2C_SMBUS_BLOCK_MAX)\n\t\treturn -EINVAL;\n\n\tmemcpy(ctx->dma_buffer, data, writelen);\n\tpaddr = dma_map_single(ctx->dev, ctx->dma_buffer, writelen,\n\t\t\t       DMA_TO_DEVICE);\n\tif (dma_mapping_error(ctx->dev, paddr)) {\n\t\tdev_err(&ctx->adapter.dev, \"Error in mapping dma buffer %p\\n\",\n\t\t\tctx->dma_buffer);\n\t\treturn -ENOMEM;\n\t}\n\n\tmsg[0] = SLIMPRO_IIC_ENCODE_MSG(SLIMPRO_IIC_BUS, chip, SLIMPRO_IIC_WRITE,\n\t\t\t\t\tprotocol, addrlen, writelen);\n\tmsg[1] = SLIMPRO_IIC_ENCODE_FLAG_BUFADDR |\n\t\t SLIMPRO_IIC_ENCODE_UPPER_BUFADDR(paddr) |\n\t\t SLIMPRO_IIC_ENCODE_ADDR(addr);\n\tmsg[2] = (u32)paddr;\n\n\tif (ctx->mbox_client.tx_block)\n\t\treinit_completion(&ctx->rd_complete);\n\n\trc = slimpro_i2c_send_msg(ctx, msg, msg);\n\n\tdma_unmap_single(ctx->dev, paddr, writelen, DMA_TO_DEVICE);\n\treturn rc;\n}\n\nstatic int xgene_slimpro_i2c_xfer(struct i2c_adapter *adap, u16 addr,\n\t\t\t\t  unsigned short flags, char read_write,\n\t\t\t\t  u8 command, int size,\n\t\t\t\t  union i2c_smbus_data *data)\n{\n\tstruct slimpro_i2c_dev *ctx = i2c_get_adapdata(adap);\n\tint ret = -EOPNOTSUPP;\n\tu32 val;\n\n\tswitch (size) {\n\tcase I2C_SMBUS_BYTE:\n\t\tif (read_write == I2C_SMBUS_READ) {\n\t\t\tret = slimpro_i2c_rd(ctx, addr, 0, 0,\n\t\t\t\t\t     SLIMPRO_IIC_SMB_PROTOCOL,\n\t\t\t\t\t     BYTE_DATA, &val);\n\t\t\tdata->byte = val;\n\t\t} else {\n\t\t\tret = slimpro_i2c_wr(ctx, addr, command, SMBUS_CMD_LEN,\n\t\t\t\t\t     SLIMPRO_IIC_SMB_PROTOCOL,\n\t\t\t\t\t     0, 0);\n\t\t}\n\t\tbreak;\n\tcase I2C_SMBUS_BYTE_DATA:\n\t\tif (read_write == I2C_SMBUS_READ) {\n\t\t\tret = slimpro_i2c_rd(ctx, addr, command, SMBUS_CMD_LEN,\n\t\t\t\t\t     SLIMPRO_IIC_SMB_PROTOCOL,\n\t\t\t\t\t     BYTE_DATA, &val);\n\t\t\tdata->byte = val;\n\t\t} else {\n\t\t\tval = data->byte;\n\t\t\tret = slimpro_i2c_wr(ctx, addr, command, SMBUS_CMD_LEN,\n\t\t\t\t\t     SLIMPRO_IIC_SMB_PROTOCOL,\n\t\t\t\t\t     BYTE_DATA, val);\n\t\t}\n\t\tbreak;\n\tcase I2C_SMBUS_WORD_DATA:\n\t\tif (read_write == I2C_SMBUS_READ) {\n\t\t\tret = slimpro_i2c_rd(ctx, addr, command, SMBUS_CMD_LEN,\n\t\t\t\t\t     SLIMPRO_IIC_SMB_PROTOCOL,\n\t\t\t\t\t     WORD_DATA, &val);\n\t\t\tdata->word = val;\n\t\t} else {\n\t\t\tval = data->word;\n\t\t\tret = slimpro_i2c_wr(ctx, addr, command, SMBUS_CMD_LEN,\n\t\t\t\t\t     SLIMPRO_IIC_SMB_PROTOCOL,\n\t\t\t\t\t     WORD_DATA, val);\n\t\t}\n\t\tbreak;\n\tcase I2C_SMBUS_BLOCK_DATA:\n\t\tif (read_write == I2C_SMBUS_READ) {\n\t\t\tret = slimpro_i2c_blkrd(ctx, addr, command,\n\t\t\t\t\t\tSMBUS_CMD_LEN,\n\t\t\t\t\t\tSLIMPRO_IIC_SMB_PROTOCOL,\n\t\t\t\t\t\tI2C_SMBUS_BLOCK_MAX + 1,\n\t\t\t\t\t\tIIC_SMB_WITH_DATA_LEN,\n\t\t\t\t\t\t&data->block[0]);\n\n\t\t} else {\n\t\t\tret = slimpro_i2c_blkwr(ctx, addr, command,\n\t\t\t\t\t\tSMBUS_CMD_LEN,\n\t\t\t\t\t\tSLIMPRO_IIC_SMB_PROTOCOL,\n\t\t\t\t\t\tdata->block[0] + 1,\n\t\t\t\t\t\t&data->block[0]);\n\t\t}\n\t\tbreak;\n\tcase I2C_SMBUS_I2C_BLOCK_DATA:\n\t\tif (read_write == I2C_SMBUS_READ) {\n\t\t\tret = slimpro_i2c_blkrd(ctx, addr,\n\t\t\t\t\t\tcommand,\n\t\t\t\t\t\tSMBUS_CMD_LEN,\n\t\t\t\t\t\tSLIMPRO_IIC_I2C_PROTOCOL,\n\t\t\t\t\t\tI2C_SMBUS_BLOCK_MAX,\n\t\t\t\t\t\tIIC_SMB_WITHOUT_DATA_LEN,\n\t\t\t\t\t\t&data->block[1]);\n\t\t} else {\n\t\t\tret = slimpro_i2c_blkwr(ctx, addr, command,\n\t\t\t\t\t\tSMBUS_CMD_LEN,\n\t\t\t\t\t\tSLIMPRO_IIC_I2C_PROTOCOL,\n\t\t\t\t\t\tdata->block[0],\n\t\t\t\t\t\t&data->block[1]);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\n \nstatic u32 xgene_slimpro_i2c_func(struct i2c_adapter *adapter)\n{\n\treturn I2C_FUNC_SMBUS_BYTE |\n\t\tI2C_FUNC_SMBUS_BYTE_DATA |\n\t\tI2C_FUNC_SMBUS_WORD_DATA |\n\t\tI2C_FUNC_SMBUS_BLOCK_DATA |\n\t\tI2C_FUNC_SMBUS_I2C_BLOCK;\n}\n\nstatic const struct i2c_algorithm xgene_slimpro_i2c_algorithm = {\n\t.smbus_xfer = xgene_slimpro_i2c_xfer,\n\t.functionality = xgene_slimpro_i2c_func,\n};\n\nstatic int xgene_slimpro_i2c_probe(struct platform_device *pdev)\n{\n\tstruct slimpro_i2c_dev *ctx;\n\tstruct i2c_adapter *adapter;\n\tstruct mbox_client *cl;\n\tint rc;\n\n\tctx = devm_kzalloc(&pdev->dev, sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tctx->dev = &pdev->dev;\n\tplatform_set_drvdata(pdev, ctx);\n\tcl = &ctx->mbox_client;\n\n\t \n\tcl->dev = &pdev->dev;\n\tinit_completion(&ctx->rd_complete);\n\tcl->tx_tout = MAILBOX_OP_TIMEOUT;\n\tcl->knows_txdone = false;\n\tif (acpi_disabled) {\n\t\tcl->tx_block = true;\n\t\tcl->rx_callback = slimpro_i2c_rx_cb;\n\t\tctx->mbox_chan = mbox_request_channel(cl, MAILBOX_I2C_INDEX);\n\t\tif (IS_ERR(ctx->mbox_chan)) {\n\t\t\tdev_err(&pdev->dev, \"i2c mailbox channel request failed\\n\");\n\t\t\treturn PTR_ERR(ctx->mbox_chan);\n\t\t}\n\t} else {\n\t\tstruct pcc_mbox_chan *pcc_chan;\n\t\tconst struct acpi_device_id *acpi_id;\n\t\tint version = XGENE_SLIMPRO_I2C_V1;\n\n\t\tacpi_id = acpi_match_device(pdev->dev.driver->acpi_match_table,\n\t\t\t\t\t    &pdev->dev);\n\t\tif (!acpi_id)\n\t\t\treturn -EINVAL;\n\n\t\tversion = (int)acpi_id->driver_data;\n\n\t\tif (device_property_read_u32(&pdev->dev, \"pcc-channel\",\n\t\t\t\t\t     &ctx->mbox_idx))\n\t\t\tctx->mbox_idx = MAILBOX_I2C_INDEX;\n\n\t\tcl->tx_block = false;\n\t\tcl->rx_callback = slimpro_i2c_pcc_rx_cb;\n\t\tpcc_chan = pcc_mbox_request_channel(cl, ctx->mbox_idx);\n\t\tif (IS_ERR(pcc_chan)) {\n\t\t\tdev_err(&pdev->dev, \"PCC mailbox channel request failed\\n\");\n\t\t\treturn PTR_ERR(pcc_chan);\n\t\t}\n\n\t\tctx->pcc_chan = pcc_chan;\n\t\tctx->mbox_chan = pcc_chan->mchan;\n\n\t\tif (!ctx->mbox_chan->mbox->txdone_irq) {\n\t\t\tdev_err(&pdev->dev, \"PCC IRQ not supported\\n\");\n\t\t\trc = -ENOENT;\n\t\t\tgoto mbox_err;\n\t\t}\n\n\t\t \n\t\tctx->comm_base_addr = pcc_chan->shmem_base_addr;\n\t\tif (ctx->comm_base_addr) {\n\t\t\tif (version == XGENE_SLIMPRO_I2C_V2)\n\t\t\t\tctx->pcc_comm_addr = memremap(\n\t\t\t\t\t\t\tctx->comm_base_addr,\n\t\t\t\t\t\t\tpcc_chan->shmem_size,\n\t\t\t\t\t\t\tMEMREMAP_WT);\n\t\t\telse\n\t\t\t\tctx->pcc_comm_addr = memremap(\n\t\t\t\t\t\t\tctx->comm_base_addr,\n\t\t\t\t\t\t\tpcc_chan->shmem_size,\n\t\t\t\t\t\t\tMEMREMAP_WB);\n\t\t} else {\n\t\t\tdev_err(&pdev->dev, \"Failed to get PCC comm region\\n\");\n\t\t\trc = -ENOENT;\n\t\t\tgoto mbox_err;\n\t\t}\n\n\t\tif (!ctx->pcc_comm_addr) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"Failed to ioremap PCC comm region\\n\");\n\t\t\trc = -ENOMEM;\n\t\t\tgoto mbox_err;\n\t\t}\n\t}\n\trc = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(64));\n\tif (rc)\n\t\tdev_warn(&pdev->dev, \"Unable to set dma mask\\n\");\n\n\t \n\tadapter = &ctx->adapter;\n\tsnprintf(adapter->name, sizeof(adapter->name), \"MAILBOX I2C\");\n\tadapter->algo = &xgene_slimpro_i2c_algorithm;\n\tadapter->class = I2C_CLASS_HWMON;\n\tadapter->dev.parent = &pdev->dev;\n\tadapter->dev.of_node = pdev->dev.of_node;\n\tACPI_COMPANION_SET(&adapter->dev, ACPI_COMPANION(&pdev->dev));\n\ti2c_set_adapdata(adapter, ctx);\n\trc = i2c_add_adapter(adapter);\n\tif (rc)\n\t\tgoto mbox_err;\n\n\tdev_info(&pdev->dev, \"Mailbox I2C Adapter registered\\n\");\n\treturn 0;\n\nmbox_err:\n\tif (acpi_disabled)\n\t\tmbox_free_channel(ctx->mbox_chan);\n\telse\n\t\tpcc_mbox_free_channel(ctx->pcc_chan);\n\n\treturn rc;\n}\n\nstatic void xgene_slimpro_i2c_remove(struct platform_device *pdev)\n{\n\tstruct slimpro_i2c_dev *ctx = platform_get_drvdata(pdev);\n\n\ti2c_del_adapter(&ctx->adapter);\n\n\tif (acpi_disabled)\n\t\tmbox_free_channel(ctx->mbox_chan);\n\telse\n\t\tpcc_mbox_free_channel(ctx->pcc_chan);\n}\n\nstatic const struct of_device_id xgene_slimpro_i2c_dt_ids[] = {\n\t{.compatible = \"apm,xgene-slimpro-i2c\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, xgene_slimpro_i2c_dt_ids);\n\n#ifdef CONFIG_ACPI\nstatic const struct acpi_device_id xgene_slimpro_i2c_acpi_ids[] = {\n\t{\"APMC0D40\", XGENE_SLIMPRO_I2C_V1},\n\t{\"APMC0D8B\", XGENE_SLIMPRO_I2C_V2},\n\t{}\n};\nMODULE_DEVICE_TABLE(acpi, xgene_slimpro_i2c_acpi_ids);\n#endif\n\nstatic struct platform_driver xgene_slimpro_i2c_driver = {\n\t.probe\t= xgene_slimpro_i2c_probe,\n\t.remove_new = xgene_slimpro_i2c_remove,\n\t.driver\t= {\n\t\t.name\t= \"xgene-slimpro-i2c\",\n\t\t.of_match_table = of_match_ptr(xgene_slimpro_i2c_dt_ids),\n\t\t.acpi_match_table = ACPI_PTR(xgene_slimpro_i2c_acpi_ids)\n\t},\n};\n\nmodule_platform_driver(xgene_slimpro_i2c_driver);\n\nMODULE_DESCRIPTION(\"APM X-Gene SLIMpro I2C driver\");\nMODULE_AUTHOR(\"Feng Kan <fkan@apm.com>\");\nMODULE_AUTHOR(\"Hieu Le <hnle@apm.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}