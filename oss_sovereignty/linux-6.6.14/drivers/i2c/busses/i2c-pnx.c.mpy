{
  "module_name": "i2c-pnx.c",
  "hash_id": "52eb77d86d7ea0bebb6f6bae82d9e543be67ccd2ce215b196af73f52ecef525a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-pnx.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/delay.h>\n#include <linux/i2c.h>\n#include <linux/timer.h>\n#include <linux/completion.h>\n#include <linux/platform_device.h>\n#include <linux/io.h>\n#include <linux/err.h>\n#include <linux/clk.h>\n#include <linux/slab.h>\n#include <linux/of.h>\n\n#define I2C_PNX_TIMEOUT_DEFAULT\t\t10  \n#define I2C_PNX_SPEED_KHZ_DEFAULT\t100\n#define I2C_PNX_REGION_SIZE\t\t0x100\n\nstruct i2c_pnx_mif {\n\tint\t\t\tret;\t\t \n\tint\t\t\tmode;\t\t \n\tstruct completion\tcomplete;\t \n\tstruct timer_list\ttimer;\t\t \n\tu8 *\t\t\tbuf;\t\t \n\tint\t\t\tlen;\t\t \n\tint\t\t\torder;\t\t \n};\n\nstruct i2c_pnx_algo_data {\n\tvoid __iomem\t\t*ioaddr;\n\tstruct i2c_pnx_mif\tmif;\n\tint\t\t\tlast;\n\tstruct clk\t\t*clk;\n\tstruct i2c_adapter\tadapter;\n\tint\t\t\tirq;\n\tu32\t\t\ttimeout;\n};\n\nenum {\n\tmstatus_tdi = 0x00000001,\n\tmstatus_afi = 0x00000002,\n\tmstatus_nai = 0x00000004,\n\tmstatus_drmi = 0x00000008,\n\tmstatus_active = 0x00000020,\n\tmstatus_scl = 0x00000040,\n\tmstatus_sda = 0x00000080,\n\tmstatus_rff = 0x00000100,\n\tmstatus_rfe = 0x00000200,\n\tmstatus_tff = 0x00000400,\n\tmstatus_tfe = 0x00000800,\n};\n\nenum {\n\tmcntrl_tdie = 0x00000001,\n\tmcntrl_afie = 0x00000002,\n\tmcntrl_naie = 0x00000004,\n\tmcntrl_drmie = 0x00000008,\n\tmcntrl_drsie = 0x00000010,\n\tmcntrl_rffie = 0x00000020,\n\tmcntrl_daie = 0x00000040,\n\tmcntrl_tffie = 0x00000080,\n\tmcntrl_reset = 0x00000100,\n\tmcntrl_cdbmode = 0x00000400,\n};\n\nenum {\n\trw_bit = 1 << 0,\n\tstart_bit = 1 << 8,\n\tstop_bit = 1 << 9,\n};\n\n#define I2C_REG_RX(a)\t((a)->ioaddr)\t\t \n#define I2C_REG_TX(a)\t((a)->ioaddr)\t\t \n#define I2C_REG_STS(a)\t((a)->ioaddr + 0x04)\t \n#define I2C_REG_CTL(a)\t((a)->ioaddr + 0x08)\t \n#define I2C_REG_CKL(a)\t((a)->ioaddr + 0x0c)\t \n#define I2C_REG_CKH(a)\t((a)->ioaddr + 0x10)\t \n#define I2C_REG_ADR(a)\t((a)->ioaddr + 0x14)\t \n#define I2C_REG_RFL(a)\t((a)->ioaddr + 0x18)\t \n#define I2C_REG_TFL(a)\t((a)->ioaddr + 0x1c)\t \n#define I2C_REG_RXB(a)\t((a)->ioaddr + 0x20)\t \n#define I2C_REG_TXB(a)\t((a)->ioaddr + 0x24)\t \n#define I2C_REG_TXS(a)\t((a)->ioaddr + 0x28)\t \n#define I2C_REG_STFL(a)\t((a)->ioaddr + 0x2c)\t \n\nstatic inline int wait_timeout(struct i2c_pnx_algo_data *data)\n{\n\tlong timeout = data->timeout;\n\twhile (timeout > 0 &&\n\t\t\t(ioread32(I2C_REG_STS(data)) & mstatus_active)) {\n\t\tmdelay(1);\n\t\ttimeout--;\n\t}\n\treturn (timeout <= 0);\n}\n\nstatic inline int wait_reset(struct i2c_pnx_algo_data *data)\n{\n\tlong timeout = data->timeout;\n\twhile (timeout > 0 &&\n\t\t\t(ioread32(I2C_REG_CTL(data)) & mcntrl_reset)) {\n\t\tmdelay(1);\n\t\ttimeout--;\n\t}\n\treturn (timeout <= 0);\n}\n\nstatic inline void i2c_pnx_arm_timer(struct i2c_pnx_algo_data *alg_data)\n{\n\tstruct timer_list *timer = &alg_data->mif.timer;\n\tunsigned long expires = msecs_to_jiffies(alg_data->timeout);\n\n\tif (expires <= 1)\n\t\texpires = 2;\n\n\tdel_timer_sync(timer);\n\n\tdev_dbg(&alg_data->adapter.dev, \"Timer armed at %lu plus %lu jiffies.\\n\",\n\t\tjiffies, expires);\n\n\ttimer->expires = jiffies + expires;\n\n\tadd_timer(timer);\n}\n\n \nstatic int i2c_pnx_start(unsigned char slave_addr,\n\tstruct i2c_pnx_algo_data *alg_data)\n{\n\tdev_dbg(&alg_data->adapter.dev, \"%s(): addr 0x%x mode %d\\n\", __func__,\n\t\tslave_addr, alg_data->mif.mode);\n\n\t \n\tif (slave_addr & ~0x7f) {\n\t\tdev_err(&alg_data->adapter.dev,\n\t\t\t\"%s: Invalid slave address %x. Only 7-bit addresses are supported\\n\",\n\t\t\talg_data->adapter.name, slave_addr);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (wait_timeout(alg_data)) {\n\t\t \n\t\tdev_err(&alg_data->adapter.dev,\n\t\t\t\"%s: Bus busy. Slave addr = %02x, cntrl = %x, stat = %x\\n\",\n\t\t\talg_data->adapter.name, slave_addr,\n\t\t\tioread32(I2C_REG_CTL(alg_data)),\n\t\t\tioread32(I2C_REG_STS(alg_data)));\n\t\treturn -EBUSY;\n\t} else if (ioread32(I2C_REG_STS(alg_data)) & mstatus_afi) {\n\t\t \n\t\tdev_err(&alg_data->adapter.dev,\n\t\t        \"%s: Arbitration failure. Slave addr = %02x\\n\",\n\t\t\talg_data->adapter.name, slave_addr);\n\t\treturn -EIO;\n\t}\n\n\t \n\tiowrite32(ioread32(I2C_REG_STS(alg_data)) | mstatus_tdi | mstatus_afi,\n\t\t  I2C_REG_STS(alg_data));\n\n\tdev_dbg(&alg_data->adapter.dev, \"%s(): sending %#x\\n\", __func__,\n\t\t(slave_addr << 1) | start_bit | alg_data->mif.mode);\n\n\t \n\tiowrite32((slave_addr << 1) | start_bit | alg_data->mif.mode,\n\t\t  I2C_REG_TX(alg_data));\n\n\tdev_dbg(&alg_data->adapter.dev, \"%s(): exit\\n\", __func__);\n\n\treturn 0;\n}\n\n \nstatic void i2c_pnx_stop(struct i2c_pnx_algo_data *alg_data)\n{\n\t \n\tlong timeout = 1000;\n\n\tdev_dbg(&alg_data->adapter.dev, \"%s(): entering: stat = %04x.\\n\",\n\t\t__func__, ioread32(I2C_REG_STS(alg_data)));\n\n\t \n\tiowrite32(0xff | stop_bit, I2C_REG_TX(alg_data));\n\n\t \n\twhile (timeout > 0 &&\n\t       (ioread32(I2C_REG_STS(alg_data)) & mstatus_active)) {\n\t\t \n\t\tudelay(1);\n\t\ttimeout--;\n\t}\n\n\tdev_dbg(&alg_data->adapter.dev, \"%s(): exiting: stat = %04x.\\n\",\n\t\t__func__, ioread32(I2C_REG_STS(alg_data)));\n}\n\n \nstatic int i2c_pnx_master_xmit(struct i2c_pnx_algo_data *alg_data)\n{\n\tu32 val;\n\n\tdev_dbg(&alg_data->adapter.dev, \"%s(): entering: stat = %04x.\\n\",\n\t\t__func__, ioread32(I2C_REG_STS(alg_data)));\n\n\tif (alg_data->mif.len > 0) {\n\t\t \n\t\tval = *alg_data->mif.buf++;\n\n\t\tif (alg_data->mif.len == 1)\n\t\t\tval |= stop_bit;\n\n\t\talg_data->mif.len--;\n\t\tiowrite32(val, I2C_REG_TX(alg_data));\n\n\t\tdev_dbg(&alg_data->adapter.dev, \"%s(): xmit %#x [%d]\\n\",\n\t\t\t__func__, val, alg_data->mif.len + 1);\n\n\t\tif (alg_data->mif.len == 0) {\n\t\t\tif (alg_data->last) {\n\t\t\t\t \n\t\t\t\tif (wait_timeout(alg_data))\n\t\t\t\t\tdev_err(&alg_data->adapter.dev,\n\t\t\t\t\t\t\"The bus is still active after timeout\\n\");\n\t\t\t}\n\t\t\t \n\t\t\tiowrite32(ioread32(I2C_REG_CTL(alg_data)) &\n\t\t\t\t~(mcntrl_afie | mcntrl_naie | mcntrl_drmie),\n\t\t\t\t  I2C_REG_CTL(alg_data));\n\n\t\t\tdel_timer_sync(&alg_data->mif.timer);\n\n\t\t\tdev_dbg(&alg_data->adapter.dev,\n\t\t\t\t\"%s(): Waking up xfer routine.\\n\",\n\t\t\t\t__func__);\n\n\t\t\tcomplete(&alg_data->mif.complete);\n\t\t}\n\t} else if (alg_data->mif.len == 0) {\n\t\t \n\t\ti2c_pnx_stop(alg_data);\n\n\t\t \n\t\tiowrite32(ioread32(I2C_REG_CTL(alg_data)) &\n\t\t\t~(mcntrl_afie | mcntrl_naie | mcntrl_drmie),\n\t\t\t  I2C_REG_CTL(alg_data));\n\n\t\t \n\t\tdel_timer_sync(&alg_data->mif.timer);\n\t\tdev_dbg(&alg_data->adapter.dev,\n\t\t\t\"%s(): Waking up xfer routine after zero-xfer.\\n\",\n\t\t\t__func__);\n\n\t\tcomplete(&alg_data->mif.complete);\n\t}\n\n\tdev_dbg(&alg_data->adapter.dev, \"%s(): exiting: stat = %04x.\\n\",\n\t\t__func__, ioread32(I2C_REG_STS(alg_data)));\n\n\treturn 0;\n}\n\n \nstatic int i2c_pnx_master_rcv(struct i2c_pnx_algo_data *alg_data)\n{\n\tunsigned int val = 0;\n\tu32 ctl = 0;\n\n\tdev_dbg(&alg_data->adapter.dev, \"%s(): entering: stat = %04x.\\n\",\n\t\t__func__, ioread32(I2C_REG_STS(alg_data)));\n\n\t \n\tif (ioread32(I2C_REG_STS(alg_data)) & mstatus_rfe) {\n\t\t \n\t\tif (alg_data->mif.order) {\n\t\t\tdev_dbg(&alg_data->adapter.dev,\n\t\t\t\t\"%s(): Write dummy data to fill Rx-fifo...\\n\",\n\t\t\t\t__func__);\n\n\t\t\tif (alg_data->mif.order == 1) {\n\t\t\t\t \n\t\t\t\tval |= stop_bit;\n\n\t\t\t\t \n\t\t\t\tctl = ioread32(I2C_REG_CTL(alg_data));\n\t\t\t\tctl |= mcntrl_rffie | mcntrl_daie;\n\t\t\t\tctl &= ~mcntrl_drmie;\n\t\t\t\tiowrite32(ctl, I2C_REG_CTL(alg_data));\n\t\t\t}\n\n\t\t\t \n\t\t\tiowrite32(val, I2C_REG_TX(alg_data));\n\t\t\talg_data->mif.order--;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t \n\tif (alg_data->mif.len > 0) {\n\t\tval = ioread32(I2C_REG_RX(alg_data));\n\t\t*alg_data->mif.buf++ = (u8) (val & 0xff);\n\t\tdev_dbg(&alg_data->adapter.dev, \"%s(): rcv 0x%x [%d]\\n\",\n\t\t\t__func__, val, alg_data->mif.len);\n\n\t\talg_data->mif.len--;\n\t\tif (alg_data->mif.len == 0) {\n\t\t\tif (alg_data->last)\n\t\t\t\t \n\t\t\t\tif (wait_timeout(alg_data))\n\t\t\t\t\tdev_err(&alg_data->adapter.dev,\n\t\t\t\t\t\t\"The bus is still active after timeout\\n\");\n\n\t\t\t \n\t\t\tctl = ioread32(I2C_REG_CTL(alg_data));\n\t\t\tctl &= ~(mcntrl_afie | mcntrl_naie | mcntrl_rffie |\n\t\t\t\t mcntrl_drmie | mcntrl_daie);\n\t\t\tiowrite32(ctl, I2C_REG_CTL(alg_data));\n\n\t\t\t \n\t\t\tdel_timer_sync(&alg_data->mif.timer);\n\t\t\tcomplete(&alg_data->mif.complete);\n\t\t}\n\t}\n\n\tdev_dbg(&alg_data->adapter.dev, \"%s(): exiting: stat = %04x.\\n\",\n\t\t__func__, ioread32(I2C_REG_STS(alg_data)));\n\n\treturn 0;\n}\n\nstatic irqreturn_t i2c_pnx_interrupt(int irq, void *dev_id)\n{\n\tstruct i2c_pnx_algo_data *alg_data = dev_id;\n\tu32 stat, ctl;\n\n\tdev_dbg(&alg_data->adapter.dev,\n\t\t\"%s(): mstat = %x mctrl = %x, mode = %d\\n\",\n\t\t__func__,\n\t\tioread32(I2C_REG_STS(alg_data)),\n\t\tioread32(I2C_REG_CTL(alg_data)),\n\t\talg_data->mif.mode);\n\tstat = ioread32(I2C_REG_STS(alg_data));\n\n\t \n\tif (stat & mstatus_afi) {\n\t\t \n\t\talg_data->mif.ret = -EIO;\n\n\t\t \n\t\tctl = ioread32(I2C_REG_CTL(alg_data));\n\t\tctl &= ~(mcntrl_afie | mcntrl_naie | mcntrl_rffie |\n\t\t\t mcntrl_drmie);\n\t\tiowrite32(ctl, I2C_REG_CTL(alg_data));\n\n\t\t \n\t\tdel_timer_sync(&alg_data->mif.timer);\n\t\tcomplete(&alg_data->mif.complete);\n\t} else if (stat & mstatus_nai) {\n\t\t \n\t\tdev_dbg(&alg_data->adapter.dev,\n\t\t\t\"%s(): Slave did not acknowledge, generating a STOP.\\n\",\n\t\t\t__func__);\n\t\ti2c_pnx_stop(alg_data);\n\n\t\t \n\t\tctl = ioread32(I2C_REG_CTL(alg_data));\n\t\tctl &= ~(mcntrl_afie | mcntrl_naie | mcntrl_rffie |\n\t\t\t mcntrl_drmie);\n\t\tiowrite32(ctl, I2C_REG_CTL(alg_data));\n\n\t\t \n\t\talg_data->mif.ret = -EIO;\n\n\t\t \n\t\tdel_timer_sync(&alg_data->mif.timer);\n\t\tcomplete(&alg_data->mif.complete);\n\t} else {\n\t\t \n\t\tif ((stat & mstatus_drmi) || !(stat & mstatus_rfe)) {\n\t\t\tif (alg_data->mif.mode == I2C_SMBUS_WRITE) {\n\t\t\t\ti2c_pnx_master_xmit(alg_data);\n\t\t\t} else if (alg_data->mif.mode == I2C_SMBUS_READ) {\n\t\t\t\ti2c_pnx_master_rcv(alg_data);\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tstat = ioread32(I2C_REG_STS(alg_data));\n\tiowrite32(stat | mstatus_tdi | mstatus_afi, I2C_REG_STS(alg_data));\n\n\tdev_dbg(&alg_data->adapter.dev,\n\t\t\"%s(): exiting, stat = %x ctrl = %x.\\n\",\n\t\t __func__, ioread32(I2C_REG_STS(alg_data)),\n\t\t ioread32(I2C_REG_CTL(alg_data)));\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void i2c_pnx_timeout(struct timer_list *t)\n{\n\tstruct i2c_pnx_algo_data *alg_data = from_timer(alg_data, t, mif.timer);\n\tu32 ctl;\n\n\tdev_err(&alg_data->adapter.dev,\n\t\t\"Master timed out. stat = %04x, cntrl = %04x. Resetting master...\\n\",\n\t\tioread32(I2C_REG_STS(alg_data)),\n\t\tioread32(I2C_REG_CTL(alg_data)));\n\n\t \n\tctl = ioread32(I2C_REG_CTL(alg_data));\n\tctl &= ~(mcntrl_afie | mcntrl_naie | mcntrl_rffie | mcntrl_drmie);\n\tiowrite32(ctl, I2C_REG_CTL(alg_data));\n\n\tctl |= mcntrl_reset;\n\tiowrite32(ctl, I2C_REG_CTL(alg_data));\n\twait_reset(alg_data);\n\talg_data->mif.ret = -EIO;\n\tcomplete(&alg_data->mif.complete);\n}\n\nstatic inline void bus_reset_if_active(struct i2c_pnx_algo_data *alg_data)\n{\n\tu32 stat;\n\n\tif ((stat = ioread32(I2C_REG_STS(alg_data))) & mstatus_active) {\n\t\tdev_err(&alg_data->adapter.dev,\n\t\t\t\"%s: Bus is still active after xfer. Reset it...\\n\",\n\t\t\talg_data->adapter.name);\n\t\tiowrite32(ioread32(I2C_REG_CTL(alg_data)) | mcntrl_reset,\n\t\t\t  I2C_REG_CTL(alg_data));\n\t\twait_reset(alg_data);\n\t} else if (!(stat & mstatus_rfe) || !(stat & mstatus_tfe)) {\n\t\t \n\t\tiowrite32(ioread32(I2C_REG_CTL(alg_data)) | mcntrl_reset,\n\t\t\t  I2C_REG_CTL(alg_data));\n\t\twait_reset(alg_data);\n\t} else if (stat & mstatus_nai) {\n\t\tiowrite32(ioread32(I2C_REG_CTL(alg_data)) | mcntrl_reset,\n\t\t\t  I2C_REG_CTL(alg_data));\n\t\twait_reset(alg_data);\n\t}\n}\n\n \nstatic int\ni2c_pnx_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)\n{\n\tstruct i2c_msg *pmsg;\n\tint rc = 0, completed = 0, i;\n\tstruct i2c_pnx_algo_data *alg_data = adap->algo_data;\n\tu32 stat;\n\n\tdev_dbg(&alg_data->adapter.dev,\n\t\t\"%s(): entering: %d messages, stat = %04x.\\n\",\n\t\t__func__, num, ioread32(I2C_REG_STS(alg_data)));\n\n\tbus_reset_if_active(alg_data);\n\n\t \n\tfor (i = 0; rc >= 0 && i < num; i++) {\n\t\tu8 addr;\n\n\t\tpmsg = &msgs[i];\n\t\taddr = pmsg->addr;\n\n\t\tif (pmsg->flags & I2C_M_TEN) {\n\t\t\tdev_err(&alg_data->adapter.dev,\n\t\t\t\t\"%s: 10 bits addr not supported!\\n\",\n\t\t\t\talg_data->adapter.name);\n\t\t\trc = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\talg_data->mif.buf = pmsg->buf;\n\t\talg_data->mif.len = pmsg->len;\n\t\talg_data->mif.order = pmsg->len;\n\t\talg_data->mif.mode = (pmsg->flags & I2C_M_RD) ?\n\t\t\tI2C_SMBUS_READ : I2C_SMBUS_WRITE;\n\t\talg_data->mif.ret = 0;\n\t\talg_data->last = (i == num - 1);\n\n\t\tdev_dbg(&alg_data->adapter.dev, \"%s(): mode %d, %d bytes\\n\",\n\t\t\t__func__, alg_data->mif.mode, alg_data->mif.len);\n\n\t\ti2c_pnx_arm_timer(alg_data);\n\n\t\t \n\t\tinit_completion(&alg_data->mif.complete);\n\n\t\t \n\t\tiowrite32(ioread32(I2C_REG_CTL(alg_data)) | mcntrl_afie |\n\t\t\t\tmcntrl_naie | mcntrl_drmie,\n\t\t\t  I2C_REG_CTL(alg_data));\n\n\t\t \n\t\trc = i2c_pnx_start(addr, alg_data);\n\t\tif (rc < 0)\n\t\t\tbreak;\n\n\t\t \n\t\twait_for_completion(&alg_data->mif.complete);\n\n\t\tif (!(rc = alg_data->mif.ret))\n\t\t\tcompleted++;\n\t\tdev_dbg(&alg_data->adapter.dev,\n\t\t\t\"%s(): Complete, return code = %d.\\n\",\n\t\t\t__func__, rc);\n\n\t\t \n\t\tif ((stat = ioread32(I2C_REG_STS(alg_data))) & mstatus_tdi) {\n\t\t\tdev_dbg(&alg_data->adapter.dev,\n\t\t\t\t\"%s: TDI still set... clearing now.\\n\",\n\t\t\t\talg_data->adapter.name);\n\t\t\tiowrite32(stat, I2C_REG_STS(alg_data));\n\t\t}\n\t\tif ((stat = ioread32(I2C_REG_STS(alg_data))) & mstatus_afi) {\n\t\t\tdev_dbg(&alg_data->adapter.dev,\n\t\t\t\t\"%s: AFI still set... clearing now.\\n\",\n\t\t\t\talg_data->adapter.name);\n\t\t\tiowrite32(stat, I2C_REG_STS(alg_data));\n\t\t}\n\t}\n\n\tbus_reset_if_active(alg_data);\n\n\t \n\talg_data->mif.buf = NULL;\n\talg_data->mif.len = 0;\n\talg_data->mif.order = 0;\n\n\tdev_dbg(&alg_data->adapter.dev, \"%s(): exiting, stat = %x\\n\",\n\t\t__func__, ioread32(I2C_REG_STS(alg_data)));\n\n\tif (completed != num)\n\t\treturn ((rc < 0) ? rc : -EREMOTEIO);\n\n\treturn num;\n}\n\nstatic u32 i2c_pnx_func(struct i2c_adapter *adapter)\n{\n\treturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;\n}\n\nstatic const struct i2c_algorithm pnx_algorithm = {\n\t.master_xfer = i2c_pnx_xfer,\n\t.functionality = i2c_pnx_func,\n};\n\nstatic int i2c_pnx_controller_suspend(struct device *dev)\n{\n\tstruct i2c_pnx_algo_data *alg_data = dev_get_drvdata(dev);\n\n\tclk_disable_unprepare(alg_data->clk);\n\n\treturn 0;\n}\n\nstatic int i2c_pnx_controller_resume(struct device *dev)\n{\n\tstruct i2c_pnx_algo_data *alg_data = dev_get_drvdata(dev);\n\n\treturn clk_prepare_enable(alg_data->clk);\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(i2c_pnx_pm,\n\t\t\t\ti2c_pnx_controller_suspend,\n\t\t\t\ti2c_pnx_controller_resume);\n\nstatic int i2c_pnx_probe(struct platform_device *pdev)\n{\n\tunsigned long tmp;\n\tint ret = 0;\n\tstruct i2c_pnx_algo_data *alg_data;\n\tunsigned long freq;\n\tstruct resource *res;\n\tu32 speed = I2C_PNX_SPEED_KHZ_DEFAULT * 1000;\n\n\talg_data = devm_kzalloc(&pdev->dev, sizeof(*alg_data), GFP_KERNEL);\n\tif (!alg_data)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, alg_data);\n\n\talg_data->adapter.dev.parent = &pdev->dev;\n\talg_data->adapter.algo = &pnx_algorithm;\n\talg_data->adapter.algo_data = alg_data;\n\talg_data->adapter.nr = pdev->id;\n\n\talg_data->timeout = I2C_PNX_TIMEOUT_DEFAULT;\n#ifdef CONFIG_OF\n\talg_data->adapter.dev.of_node = of_node_get(pdev->dev.of_node);\n\tif (pdev->dev.of_node) {\n\t\tof_property_read_u32(pdev->dev.of_node, \"clock-frequency\",\n\t\t\t\t     &speed);\n\t\t \n\t}\n#endif\n\talg_data->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(alg_data->clk))\n\t\treturn PTR_ERR(alg_data->clk);\n\n\ttimer_setup(&alg_data->mif.timer, i2c_pnx_timeout, 0);\n\n\tsnprintf(alg_data->adapter.name, sizeof(alg_data->adapter.name),\n\t\t \"%s\", pdev->name);\n\n\t \n\talg_data->ioaddr = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(alg_data->ioaddr))\n\t\treturn PTR_ERR(alg_data->ioaddr);\n\n\tret = clk_prepare_enable(alg_data->clk);\n\tif (ret)\n\t\treturn ret;\n\n\tfreq = clk_get_rate(alg_data->clk);\n\n\t \n\n\ttmp = (freq / speed) / 2 - 2;\n\tif (tmp > 0x3FF)\n\t\ttmp = 0x3FF;\n\tiowrite32(tmp, I2C_REG_CKH(alg_data));\n\tiowrite32(tmp, I2C_REG_CKL(alg_data));\n\n\tiowrite32(mcntrl_reset, I2C_REG_CTL(alg_data));\n\tif (wait_reset(alg_data)) {\n\t\tret = -ENODEV;\n\t\tgoto out_clock;\n\t}\n\tinit_completion(&alg_data->mif.complete);\n\n\talg_data->irq = platform_get_irq(pdev, 0);\n\tif (alg_data->irq < 0) {\n\t\tret = alg_data->irq;\n\t\tgoto out_clock;\n\t}\n\tret = devm_request_irq(&pdev->dev, alg_data->irq, i2c_pnx_interrupt,\n\t\t\t       0, pdev->name, alg_data);\n\tif (ret)\n\t\tgoto out_clock;\n\n\t \n\tret = i2c_add_numbered_adapter(&alg_data->adapter);\n\tif (ret < 0)\n\t\tgoto out_clock;\n\n\tdev_dbg(&pdev->dev, \"%s: Master at %pap, irq %d.\\n\",\n\t\talg_data->adapter.name, &res->start, alg_data->irq);\n\n\treturn 0;\n\nout_clock:\n\tclk_disable_unprepare(alg_data->clk);\n\treturn ret;\n}\n\nstatic void i2c_pnx_remove(struct platform_device *pdev)\n{\n\tstruct i2c_pnx_algo_data *alg_data = platform_get_drvdata(pdev);\n\n\ti2c_del_adapter(&alg_data->adapter);\n\tclk_disable_unprepare(alg_data->clk);\n}\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id i2c_pnx_of_match[] = {\n\t{ .compatible = \"nxp,pnx-i2c\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, i2c_pnx_of_match);\n#endif\n\nstatic struct platform_driver i2c_pnx_driver = {\n\t.driver = {\n\t\t.name = \"pnx-i2c\",\n\t\t.of_match_table = of_match_ptr(i2c_pnx_of_match),\n\t\t.pm = pm_sleep_ptr(&i2c_pnx_pm),\n\t},\n\t.probe = i2c_pnx_probe,\n\t.remove_new = i2c_pnx_remove,\n};\n\nstatic int __init i2c_adap_pnx_init(void)\n{\n\treturn platform_driver_register(&i2c_pnx_driver);\n}\n\nstatic void __exit i2c_adap_pnx_exit(void)\n{\n\tplatform_driver_unregister(&i2c_pnx_driver);\n}\n\nMODULE_AUTHOR(\"Vitaly Wool\");\nMODULE_AUTHOR(\"Dennis Kovalev <source@mvista.com>\");\nMODULE_DESCRIPTION(\"I2C driver for Philips IP3204-based I2C busses\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:pnx-i2c\");\n\n \nsubsys_initcall(i2c_adap_pnx_init);\nmodule_exit(i2c_adap_pnx_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}