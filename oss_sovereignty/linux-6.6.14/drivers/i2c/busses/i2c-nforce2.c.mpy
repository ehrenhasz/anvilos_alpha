{
  "module_name": "i2c-nforce2.c",
  "hash_id": "d46fac9dfd90de193aa712f76520186cc674a5dd70789849b72676ba54ab46e2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-nforce2.c",
  "human_readable_source": "\n \n\n \n\n \n\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/ioport.h>\n#include <linux/i2c.h>\n#include <linux/delay.h>\n#include <linux/dmi.h>\n#include <linux/acpi.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Hans-Frieder Vogt <hfvogt@gmx.net>\");\nMODULE_DESCRIPTION(\"nForce2/3/4/5xx SMBus driver\");\n\n\nstruct nforce2_smbus {\n\tstruct i2c_adapter adapter;\n\tint base;\n\tint size;\n\tint blockops;\n\tint can_abort;\n};\n\n\n \n#define NFORCE_PCI_SMB1\t0x50\n#define NFORCE_PCI_SMB2\t0x54\n\n\n \n#define NVIDIA_SMB_PRTCL\t(smbus->base + 0x00)\t \n#define NVIDIA_SMB_STS\t\t(smbus->base + 0x01)\t \n#define NVIDIA_SMB_ADDR\t\t(smbus->base + 0x02)\t \n#define NVIDIA_SMB_CMD\t\t(smbus->base + 0x03)\t \n#define NVIDIA_SMB_DATA\t\t(smbus->base + 0x04)\t \n#define NVIDIA_SMB_BCNT\t\t(smbus->base + 0x24)\t \n#define NVIDIA_SMB_STATUS_ABRT\t(smbus->base + 0x3c)\t \n#define NVIDIA_SMB_CTRL\t\t(smbus->base + 0x3e)\t \n\n#define NVIDIA_SMB_STATUS_ABRT_STS\t0x01\t\t \n#define NVIDIA_SMB_CTRL_ABORT\t0x20\n#define NVIDIA_SMB_STS_DONE\t0x80\n#define NVIDIA_SMB_STS_ALRM\t0x40\n#define NVIDIA_SMB_STS_RES\t0x20\n#define NVIDIA_SMB_STS_STATUS\t0x1f\n\n#define NVIDIA_SMB_PRTCL_WRITE\t\t\t0x00\n#define NVIDIA_SMB_PRTCL_READ\t\t\t0x01\n#define NVIDIA_SMB_PRTCL_QUICK\t\t\t0x02\n#define NVIDIA_SMB_PRTCL_BYTE\t\t\t0x04\n#define NVIDIA_SMB_PRTCL_BYTE_DATA\t\t0x06\n#define NVIDIA_SMB_PRTCL_WORD_DATA\t\t0x08\n#define NVIDIA_SMB_PRTCL_BLOCK_DATA\t\t0x0a\n#define NVIDIA_SMB_PRTCL_PEC\t\t\t0x80\n\n \n#define MAX_TIMEOUT\t100\n\n \nstatic const struct dmi_system_id nforce2_dmi_blacklist2[] = {\n\t{\n\t\t.ident = \"DFI Lanparty NF4 Expert\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"DFI Corp,LTD\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"LP UT NF4 Expert\"),\n\t\t},\n\t},\n\t{ }\n};\n\nstatic struct pci_driver nforce2_driver;\n\n \n#if IS_ENABLED(CONFIG_I2C_NFORCE2_S4985)\nstruct i2c_adapter *nforce2_smbus;\nEXPORT_SYMBOL_GPL(nforce2_smbus);\n\nstatic void nforce2_set_reference(struct i2c_adapter *adap)\n{\n\tnforce2_smbus = adap;\n}\n#else\nstatic inline void nforce2_set_reference(struct i2c_adapter *adap) { }\n#endif\n\nstatic void nforce2_abort(struct i2c_adapter *adap)\n{\n\tstruct nforce2_smbus *smbus = adap->algo_data;\n\tint timeout = 0;\n\tunsigned char temp;\n\n\tdev_dbg(&adap->dev, \"Aborting current transaction\\n\");\n\n\toutb_p(NVIDIA_SMB_CTRL_ABORT, NVIDIA_SMB_CTRL);\n\tdo {\n\t\tmsleep(1);\n\t\ttemp = inb_p(NVIDIA_SMB_STATUS_ABRT);\n\t} while (!(temp & NVIDIA_SMB_STATUS_ABRT_STS) &&\n\t\t\t(timeout++ < MAX_TIMEOUT));\n\tif (!(temp & NVIDIA_SMB_STATUS_ABRT_STS))\n\t\tdev_err(&adap->dev, \"Can't reset the smbus\\n\");\n\toutb_p(NVIDIA_SMB_STATUS_ABRT_STS, NVIDIA_SMB_STATUS_ABRT);\n}\n\nstatic int nforce2_check_status(struct i2c_adapter *adap)\n{\n\tstruct nforce2_smbus *smbus = adap->algo_data;\n\tint timeout = 0;\n\tunsigned char temp;\n\n\tdo {\n\t\tmsleep(1);\n\t\ttemp = inb_p(NVIDIA_SMB_STS);\n\t} while ((!temp) && (timeout++ < MAX_TIMEOUT));\n\n\tif (timeout > MAX_TIMEOUT) {\n\t\tdev_dbg(&adap->dev, \"SMBus Timeout!\\n\");\n\t\tif (smbus->can_abort)\n\t\t\tnforce2_abort(adap);\n\t\treturn -ETIMEDOUT;\n\t}\n\tif (!(temp & NVIDIA_SMB_STS_DONE) || (temp & NVIDIA_SMB_STS_STATUS)) {\n\t\tdev_dbg(&adap->dev, \"Transaction failed (0x%02x)!\\n\", temp);\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}\n\n \nstatic s32 nforce2_access(struct i2c_adapter *adap, u16 addr,\n\t\tunsigned short flags, char read_write,\n\t\tu8 command, int size, union i2c_smbus_data *data)\n{\n\tstruct nforce2_smbus *smbus = adap->algo_data;\n\tunsigned char protocol, pec;\n\tu8 len;\n\tint i, status;\n\n\tprotocol = (read_write == I2C_SMBUS_READ) ? NVIDIA_SMB_PRTCL_READ :\n\t\tNVIDIA_SMB_PRTCL_WRITE;\n\tpec = (flags & I2C_CLIENT_PEC) ? NVIDIA_SMB_PRTCL_PEC : 0;\n\n\tswitch (size) {\n\tcase I2C_SMBUS_QUICK:\n\t\tprotocol |= NVIDIA_SMB_PRTCL_QUICK;\n\t\tread_write = I2C_SMBUS_WRITE;\n\t\tbreak;\n\n\tcase I2C_SMBUS_BYTE:\n\t\tif (read_write == I2C_SMBUS_WRITE)\n\t\t\toutb_p(command, NVIDIA_SMB_CMD);\n\t\tprotocol |= NVIDIA_SMB_PRTCL_BYTE;\n\t\tbreak;\n\n\tcase I2C_SMBUS_BYTE_DATA:\n\t\toutb_p(command, NVIDIA_SMB_CMD);\n\t\tif (read_write == I2C_SMBUS_WRITE)\n\t\t\toutb_p(data->byte, NVIDIA_SMB_DATA);\n\t\tprotocol |= NVIDIA_SMB_PRTCL_BYTE_DATA;\n\t\tbreak;\n\n\tcase I2C_SMBUS_WORD_DATA:\n\t\toutb_p(command, NVIDIA_SMB_CMD);\n\t\tif (read_write == I2C_SMBUS_WRITE) {\n\t\t\toutb_p(data->word, NVIDIA_SMB_DATA);\n\t\t\toutb_p(data->word >> 8, NVIDIA_SMB_DATA + 1);\n\t\t}\n\t\tprotocol |= NVIDIA_SMB_PRTCL_WORD_DATA | pec;\n\t\tbreak;\n\n\tcase I2C_SMBUS_BLOCK_DATA:\n\t\toutb_p(command, NVIDIA_SMB_CMD);\n\t\tif (read_write == I2C_SMBUS_WRITE) {\n\t\t\tlen = data->block[0];\n\t\t\tif ((len == 0) || (len > I2C_SMBUS_BLOCK_MAX)) {\n\t\t\t\tdev_err(&adap->dev,\n\t\t\t\t\t\"Transaction failed (requested block size: %d)\\n\",\n\t\t\t\t\tlen);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\toutb_p(len, NVIDIA_SMB_BCNT);\n\t\t\tfor (i = 0; i < I2C_SMBUS_BLOCK_MAX; i++)\n\t\t\t\toutb_p(data->block[i + 1],\n\t\t\t\t       NVIDIA_SMB_DATA + i);\n\t\t}\n\t\tprotocol |= NVIDIA_SMB_PRTCL_BLOCK_DATA | pec;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(&adap->dev, \"Unsupported transaction %d\\n\", size);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\toutb_p((addr & 0x7f) << 1, NVIDIA_SMB_ADDR);\n\toutb_p(protocol, NVIDIA_SMB_PRTCL);\n\n\tstatus = nforce2_check_status(adap);\n\tif (status)\n\t\treturn status;\n\n\tif (read_write == I2C_SMBUS_WRITE)\n\t\treturn 0;\n\n\tswitch (size) {\n\tcase I2C_SMBUS_BYTE:\n\tcase I2C_SMBUS_BYTE_DATA:\n\t\tdata->byte = inb_p(NVIDIA_SMB_DATA);\n\t\tbreak;\n\n\tcase I2C_SMBUS_WORD_DATA:\n\t\tdata->word = inb_p(NVIDIA_SMB_DATA) |\n\t\t\t     (inb_p(NVIDIA_SMB_DATA + 1) << 8);\n\t\tbreak;\n\n\tcase I2C_SMBUS_BLOCK_DATA:\n\t\tlen = inb_p(NVIDIA_SMB_BCNT);\n\t\tif ((len <= 0) || (len > I2C_SMBUS_BLOCK_MAX)) {\n\t\t\tdev_err(&adap->dev,\n\t\t\t\t\"Transaction failed (received block size: 0x%02x)\\n\",\n\t\t\t\tlen);\n\t\t\treturn -EPROTO;\n\t\t}\n\t\tfor (i = 0; i < len; i++)\n\t\t\tdata->block[i + 1] = inb_p(NVIDIA_SMB_DATA + i);\n\t\tdata->block[0] = len;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n\nstatic u32 nforce2_func(struct i2c_adapter *adapter)\n{\n\t \n\treturn I2C_FUNC_SMBUS_QUICK | I2C_FUNC_SMBUS_BYTE |\n\t       I2C_FUNC_SMBUS_BYTE_DATA | I2C_FUNC_SMBUS_WORD_DATA |\n\t       I2C_FUNC_SMBUS_PEC |\n\t       (((struct nforce2_smbus *)adapter->algo_data)->blockops ?\n\t\tI2C_FUNC_SMBUS_BLOCK_DATA : 0);\n}\n\nstatic const struct i2c_algorithm smbus_algorithm = {\n\t.smbus_xfer\t= nforce2_access,\n\t.functionality\t= nforce2_func,\n};\n\n\nstatic const struct pci_device_id nforce2_ids[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_NVIDIA, PCI_DEVICE_ID_NVIDIA_NFORCE2_SMBUS) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_NVIDIA, PCI_DEVICE_ID_NVIDIA_NFORCE2S_SMBUS) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_NVIDIA, PCI_DEVICE_ID_NVIDIA_NFORCE3_SMBUS) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_NVIDIA, PCI_DEVICE_ID_NVIDIA_NFORCE3S_SMBUS) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_NVIDIA, PCI_DEVICE_ID_NVIDIA_NFORCE4_SMBUS) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_NVIDIA, PCI_DEVICE_ID_NVIDIA_NFORCE_MCP04_SMBUS) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_NVIDIA, PCI_DEVICE_ID_NVIDIA_NFORCE_MCP51_SMBUS) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_NVIDIA, PCI_DEVICE_ID_NVIDIA_NFORCE_MCP55_SMBUS) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_NVIDIA, PCI_DEVICE_ID_NVIDIA_NFORCE_MCP61_SMBUS) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_NVIDIA, PCI_DEVICE_ID_NVIDIA_NFORCE_MCP65_SMBUS) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_NVIDIA, PCI_DEVICE_ID_NVIDIA_NFORCE_MCP67_SMBUS) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_NVIDIA, PCI_DEVICE_ID_NVIDIA_NFORCE_MCP73_SMBUS) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_NVIDIA, PCI_DEVICE_ID_NVIDIA_NFORCE_MCP78S_SMBUS) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_NVIDIA, PCI_DEVICE_ID_NVIDIA_NFORCE_MCP79_SMBUS) },\n\t{ 0 }\n};\n\nMODULE_DEVICE_TABLE(pci, nforce2_ids);\n\n\nstatic int nforce2_probe_smb(struct pci_dev *dev, int bar, int alt_reg,\n\t\t\t     struct nforce2_smbus *smbus, const char *name)\n{\n\tint error;\n\n\tsmbus->base = pci_resource_start(dev, bar);\n\tif (smbus->base) {\n\t\tsmbus->size = pci_resource_len(dev, bar);\n\t} else {\n\t\t \n\t\tu16 iobase;\n\n\t\terror = pci_read_config_word(dev, alt_reg, &iobase);\n\t\tif (error != PCIBIOS_SUCCESSFUL) {\n\t\t\tdev_err(&dev->dev, \"Error reading PCI config for %s\\n\",\n\t\t\t\tname);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tsmbus->base = iobase & PCI_BASE_ADDRESS_IO_MASK;\n\t\tsmbus->size = 64;\n\t}\n\n\terror = acpi_check_region(smbus->base, smbus->size,\n\t\t\t\t  nforce2_driver.name);\n\tif (error)\n\t\treturn error;\n\n\tif (!request_region(smbus->base, smbus->size, nforce2_driver.name)) {\n\t\tdev_err(&smbus->adapter.dev, \"Error requesting region %02x .. %02X for %s\\n\",\n\t\t\tsmbus->base, smbus->base+smbus->size-1, name);\n\t\treturn -EBUSY;\n\t}\n\tsmbus->adapter.owner = THIS_MODULE;\n\tsmbus->adapter.class = I2C_CLASS_HWMON | I2C_CLASS_SPD;\n\tsmbus->adapter.algo = &smbus_algorithm;\n\tsmbus->adapter.algo_data = smbus;\n\tsmbus->adapter.dev.parent = &dev->dev;\n\tsnprintf(smbus->adapter.name, sizeof(smbus->adapter.name),\n\t\t\"SMBus nForce2 adapter at %04x\", smbus->base);\n\n\terror = i2c_add_adapter(&smbus->adapter);\n\tif (error) {\n\t\trelease_region(smbus->base, smbus->size);\n\t\treturn error;\n\t}\n\tdev_info(&smbus->adapter.dev, \"nForce2 SMBus adapter at %#x\\n\",\n\t\tsmbus->base);\n\treturn 0;\n}\n\n\nstatic int nforce2_probe(struct pci_dev *dev, const struct pci_device_id *id)\n{\n\tstruct nforce2_smbus *smbuses;\n\tint res1, res2;\n\n\t \n\tsmbuses = kcalloc(2, sizeof(struct nforce2_smbus), GFP_KERNEL);\n\tif (!smbuses)\n\t\treturn -ENOMEM;\n\tpci_set_drvdata(dev, smbuses);\n\n\tswitch (dev->device) {\n\tcase PCI_DEVICE_ID_NVIDIA_NFORCE2_SMBUS:\n\tcase PCI_DEVICE_ID_NVIDIA_NFORCE_MCP51_SMBUS:\n\tcase PCI_DEVICE_ID_NVIDIA_NFORCE_MCP55_SMBUS:\n\t\tsmbuses[0].blockops = 1;\n\t\tsmbuses[1].blockops = 1;\n\t\tsmbuses[0].can_abort = 1;\n\t\tsmbuses[1].can_abort = 1;\n\t}\n\n\t \n\tres1 = nforce2_probe_smb(dev, 4, NFORCE_PCI_SMB1, &smbuses[0], \"SMB1\");\n\tif (res1 < 0)\n\t\tsmbuses[0].base = 0;\t \n\n\t \n\tif (dmi_check_system(nforce2_dmi_blacklist2)) {\n\t\tdev_err(&dev->dev, \"Disabling SMB2 for safety reasons.\\n\");\n\t\tres2 = -EPERM;\n\t\tsmbuses[1].base = 0;\n\t} else {\n\t\tres2 = nforce2_probe_smb(dev, 5, NFORCE_PCI_SMB2, &smbuses[1],\n\t\t\t\t\t \"SMB2\");\n\t\tif (res2 < 0)\n\t\t\tsmbuses[1].base = 0;\t \n\t}\n\n\tif ((res1 < 0) && (res2 < 0)) {\n\t\t \n\t\tkfree(smbuses);\n\t\treturn -ENODEV;\n\t}\n\n\tnforce2_set_reference(&smbuses[0].adapter);\n\treturn 0;\n}\n\n\nstatic void nforce2_remove(struct pci_dev *dev)\n{\n\tstruct nforce2_smbus *smbuses = pci_get_drvdata(dev);\n\n\tnforce2_set_reference(NULL);\n\tif (smbuses[0].base) {\n\t\ti2c_del_adapter(&smbuses[0].adapter);\n\t\trelease_region(smbuses[0].base, smbuses[0].size);\n\t}\n\tif (smbuses[1].base) {\n\t\ti2c_del_adapter(&smbuses[1].adapter);\n\t\trelease_region(smbuses[1].base, smbuses[1].size);\n\t}\n\tkfree(smbuses);\n}\n\nstatic struct pci_driver nforce2_driver = {\n\t.name\t\t= \"nForce2_smbus\",\n\t.id_table\t= nforce2_ids,\n\t.probe\t\t= nforce2_probe,\n\t.remove\t\t= nforce2_remove,\n};\n\nmodule_pci_driver(nforce2_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}