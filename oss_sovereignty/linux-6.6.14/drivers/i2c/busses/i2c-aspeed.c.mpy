{
  "module_name": "i2c-aspeed.c",
  "hash_id": "8a3516e496ca238a44794e9812f853a464222c54372b89c338a408581bcccff2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-aspeed.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/completion.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/i2c.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/irq.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/reset.h>\n#include <linux/slab.h>\n\n \n#define ASPEED_I2C_FUN_CTRL_REG\t\t\t\t0x00\n#define ASPEED_I2C_AC_TIMING_REG1\t\t\t0x04\n#define ASPEED_I2C_AC_TIMING_REG2\t\t\t0x08\n#define ASPEED_I2C_INTR_CTRL_REG\t\t\t0x0c\n#define ASPEED_I2C_INTR_STS_REG\t\t\t\t0x10\n#define ASPEED_I2C_CMD_REG\t\t\t\t0x14\n#define ASPEED_I2C_DEV_ADDR_REG\t\t\t\t0x18\n#define ASPEED_I2C_BYTE_BUF_REG\t\t\t\t0x20\n\n \n \n \n\n \n \n#define ASPEED_I2CD_MULTI_MASTER_DIS\t\t\tBIT(15)\n#define ASPEED_I2CD_SDA_DRIVE_1T_EN\t\t\tBIT(8)\n#define ASPEED_I2CD_M_SDA_DRIVE_1T_EN\t\t\tBIT(7)\n#define ASPEED_I2CD_M_HIGH_SPEED_EN\t\t\tBIT(6)\n#define ASPEED_I2CD_SLAVE_EN\t\t\t\tBIT(1)\n#define ASPEED_I2CD_MASTER_EN\t\t\t\tBIT(0)\n\n \n#define ASPEED_I2CD_TIME_TBUF_MASK\t\t\tGENMASK(31, 28)\n#define ASPEED_I2CD_TIME_THDSTA_MASK\t\t\tGENMASK(27, 24)\n#define ASPEED_I2CD_TIME_TACST_MASK\t\t\tGENMASK(23, 20)\n#define ASPEED_I2CD_TIME_SCL_HIGH_SHIFT\t\t\t16\n#define ASPEED_I2CD_TIME_SCL_HIGH_MASK\t\t\tGENMASK(19, 16)\n#define ASPEED_I2CD_TIME_SCL_LOW_SHIFT\t\t\t12\n#define ASPEED_I2CD_TIME_SCL_LOW_MASK\t\t\tGENMASK(15, 12)\n#define ASPEED_I2CD_TIME_BASE_DIVISOR_MASK\t\tGENMASK(3, 0)\n#define ASPEED_I2CD_TIME_SCL_REG_MAX\t\t\tGENMASK(3, 0)\n \n#define ASPEED_NO_TIMEOUT_CTRL\t\t\t\t0\n\n \n#define ASPEED_I2CD_INTR_RECV_MASK\t\t\t0xf000ffff\n#define ASPEED_I2CD_INTR_SDA_DL_TIMEOUT\t\t\tBIT(14)\n#define ASPEED_I2CD_INTR_BUS_RECOVER_DONE\t\tBIT(13)\n#define ASPEED_I2CD_INTR_SLAVE_MATCH\t\t\tBIT(7)\n#define ASPEED_I2CD_INTR_SCL_TIMEOUT\t\t\tBIT(6)\n#define ASPEED_I2CD_INTR_ABNORMAL\t\t\tBIT(5)\n#define ASPEED_I2CD_INTR_NORMAL_STOP\t\t\tBIT(4)\n#define ASPEED_I2CD_INTR_ARBIT_LOSS\t\t\tBIT(3)\n#define ASPEED_I2CD_INTR_RX_DONE\t\t\tBIT(2)\n#define ASPEED_I2CD_INTR_TX_NAK\t\t\t\tBIT(1)\n#define ASPEED_I2CD_INTR_TX_ACK\t\t\t\tBIT(0)\n#define ASPEED_I2CD_INTR_MASTER_ERRORS\t\t\t\t\t       \\\n\t\t(ASPEED_I2CD_INTR_SDA_DL_TIMEOUT |\t\t\t       \\\n\t\t ASPEED_I2CD_INTR_SCL_TIMEOUT |\t\t\t\t       \\\n\t\t ASPEED_I2CD_INTR_ABNORMAL |\t\t\t\t       \\\n\t\t ASPEED_I2CD_INTR_ARBIT_LOSS)\n#define ASPEED_I2CD_INTR_ALL\t\t\t\t\t\t       \\\n\t\t(ASPEED_I2CD_INTR_SDA_DL_TIMEOUT |\t\t\t       \\\n\t\t ASPEED_I2CD_INTR_BUS_RECOVER_DONE |\t\t\t       \\\n\t\t ASPEED_I2CD_INTR_SCL_TIMEOUT |\t\t\t\t       \\\n\t\t ASPEED_I2CD_INTR_ABNORMAL |\t\t\t\t       \\\n\t\t ASPEED_I2CD_INTR_NORMAL_STOP |\t\t\t\t       \\\n\t\t ASPEED_I2CD_INTR_ARBIT_LOSS |\t\t\t\t       \\\n\t\t ASPEED_I2CD_INTR_RX_DONE |\t\t\t\t       \\\n\t\t ASPEED_I2CD_INTR_TX_NAK |\t\t\t\t       \\\n\t\t ASPEED_I2CD_INTR_TX_ACK)\n\n \n#define ASPEED_I2CD_SCL_LINE_STS\t\t\tBIT(18)\n#define ASPEED_I2CD_SDA_LINE_STS\t\t\tBIT(17)\n#define ASPEED_I2CD_BUS_BUSY_STS\t\t\tBIT(16)\n#define ASPEED_I2CD_BUS_RECOVER_CMD\t\t\tBIT(11)\n\n \n#define ASPEED_I2CD_M_STOP_CMD\t\t\t\tBIT(5)\n#define ASPEED_I2CD_M_S_RX_CMD_LAST\t\t\tBIT(4)\n#define ASPEED_I2CD_M_RX_CMD\t\t\t\tBIT(3)\n#define ASPEED_I2CD_S_TX_CMD\t\t\t\tBIT(2)\n#define ASPEED_I2CD_M_TX_CMD\t\t\t\tBIT(1)\n#define ASPEED_I2CD_M_START_CMD\t\t\t\tBIT(0)\n#define ASPEED_I2CD_MASTER_CMDS_MASK\t\t\t\t\t       \\\n\t\t(ASPEED_I2CD_M_STOP_CMD |\t\t\t\t       \\\n\t\t ASPEED_I2CD_M_S_RX_CMD_LAST |\t\t\t\t       \\\n\t\t ASPEED_I2CD_M_RX_CMD |\t\t\t\t\t       \\\n\t\t ASPEED_I2CD_M_TX_CMD |\t\t\t\t\t       \\\n\t\t ASPEED_I2CD_M_START_CMD)\n\n \n#define ASPEED_I2CD_DEV_ADDR_MASK\t\t\tGENMASK(6, 0)\n\nenum aspeed_i2c_master_state {\n\tASPEED_I2C_MASTER_INACTIVE,\n\tASPEED_I2C_MASTER_PENDING,\n\tASPEED_I2C_MASTER_START,\n\tASPEED_I2C_MASTER_TX_FIRST,\n\tASPEED_I2C_MASTER_TX,\n\tASPEED_I2C_MASTER_RX_FIRST,\n\tASPEED_I2C_MASTER_RX,\n\tASPEED_I2C_MASTER_STOP,\n};\n\nenum aspeed_i2c_slave_state {\n\tASPEED_I2C_SLAVE_INACTIVE,\n\tASPEED_I2C_SLAVE_START,\n\tASPEED_I2C_SLAVE_READ_REQUESTED,\n\tASPEED_I2C_SLAVE_READ_PROCESSED,\n\tASPEED_I2C_SLAVE_WRITE_REQUESTED,\n\tASPEED_I2C_SLAVE_WRITE_RECEIVED,\n\tASPEED_I2C_SLAVE_STOP,\n};\n\nstruct aspeed_i2c_bus {\n\tstruct i2c_adapter\t\tadap;\n\tstruct device\t\t\t*dev;\n\tvoid __iomem\t\t\t*base;\n\tstruct reset_control\t\t*rst;\n\t \n\tspinlock_t\t\t\tlock;\n\tstruct completion\t\tcmd_complete;\n\tu32\t\t\t\t(*get_clk_reg_val)(struct device *dev,\n\t\t\t\t\t\t\t   u32 divisor);\n\tunsigned long\t\t\tparent_clk_frequency;\n\tu32\t\t\t\tbus_frequency;\n\t \n\tenum aspeed_i2c_master_state\tmaster_state;\n\tstruct i2c_msg\t\t\t*msgs;\n\tsize_t\t\t\t\tbuf_index;\n\tsize_t\t\t\t\tmsgs_index;\n\tsize_t\t\t\t\tmsgs_count;\n\tbool\t\t\t\tsend_stop;\n\tint\t\t\t\tcmd_err;\n\t \n\tint\t\t\t\tmaster_xfer_result;\n\t \n\tbool\t\t\t\tmulti_master;\n#if IS_ENABLED(CONFIG_I2C_SLAVE)\n\tstruct i2c_client\t\t*slave;\n\tenum aspeed_i2c_slave_state\tslave_state;\n#endif  \n};\n\nstatic int aspeed_i2c_reset(struct aspeed_i2c_bus *bus);\n\nstatic int aspeed_i2c_recover_bus(struct aspeed_i2c_bus *bus)\n{\n\tunsigned long time_left, flags;\n\tint ret = 0;\n\tu32 command;\n\n\tspin_lock_irqsave(&bus->lock, flags);\n\tcommand = readl(bus->base + ASPEED_I2C_CMD_REG);\n\n\tif (command & ASPEED_I2CD_SDA_LINE_STS) {\n\t\t \n\t\tif (command & ASPEED_I2CD_SCL_LINE_STS)\n\t\t\tgoto out;\n\t\tdev_dbg(bus->dev, \"SCL hung (state %x), attempting recovery\\n\",\n\t\t\tcommand);\n\n\t\treinit_completion(&bus->cmd_complete);\n\t\twritel(ASPEED_I2CD_M_STOP_CMD, bus->base + ASPEED_I2C_CMD_REG);\n\t\tspin_unlock_irqrestore(&bus->lock, flags);\n\n\t\ttime_left = wait_for_completion_timeout(\n\t\t\t\t&bus->cmd_complete, bus->adap.timeout);\n\n\t\tspin_lock_irqsave(&bus->lock, flags);\n\t\tif (time_left == 0)\n\t\t\tgoto reset_out;\n\t\telse if (bus->cmd_err)\n\t\t\tgoto reset_out;\n\t\t \n\t\telse if (!(readl(bus->base + ASPEED_I2C_CMD_REG) &\n\t\t\t   ASPEED_I2CD_SCL_LINE_STS))\n\t\t\tgoto reset_out;\n\t \n\t} else {\n\t\tdev_dbg(bus->dev, \"SDA hung (state %x), attempting recovery\\n\",\n\t\t\tcommand);\n\n\t\treinit_completion(&bus->cmd_complete);\n\t\t \n\t\twritel(ASPEED_I2CD_BUS_RECOVER_CMD,\n\t\t       bus->base + ASPEED_I2C_CMD_REG);\n\t\tspin_unlock_irqrestore(&bus->lock, flags);\n\n\t\ttime_left = wait_for_completion_timeout(\n\t\t\t\t&bus->cmd_complete, bus->adap.timeout);\n\n\t\tspin_lock_irqsave(&bus->lock, flags);\n\t\tif (time_left == 0)\n\t\t\tgoto reset_out;\n\t\telse if (bus->cmd_err)\n\t\t\tgoto reset_out;\n\t\t \n\t\telse if (!(readl(bus->base + ASPEED_I2C_CMD_REG) &\n\t\t\t   ASPEED_I2CD_SDA_LINE_STS))\n\t\t\tgoto reset_out;\n\t}\n\nout:\n\tspin_unlock_irqrestore(&bus->lock, flags);\n\n\treturn ret;\n\nreset_out:\n\tspin_unlock_irqrestore(&bus->lock, flags);\n\n\treturn aspeed_i2c_reset(bus);\n}\n\n#if IS_ENABLED(CONFIG_I2C_SLAVE)\nstatic u32 aspeed_i2c_slave_irq(struct aspeed_i2c_bus *bus, u32 irq_status)\n{\n\tu32 command, irq_handled = 0;\n\tstruct i2c_client *slave = bus->slave;\n\tu8 value;\n\tint ret;\n\n\tif (!slave)\n\t\treturn 0;\n\n\t \n\tif (irq_status & ASPEED_I2CD_INTR_NORMAL_STOP) {\n\t\tirq_handled |= ASPEED_I2CD_INTR_NORMAL_STOP;\n\t\tbus->slave_state = ASPEED_I2C_SLAVE_STOP;\n\t}\n\n\tif (irq_status & ASPEED_I2CD_INTR_TX_NAK &&\n\t    bus->slave_state == ASPEED_I2C_SLAVE_READ_PROCESSED) {\n\t\tirq_handled |= ASPEED_I2CD_INTR_TX_NAK;\n\t\tbus->slave_state = ASPEED_I2C_SLAVE_STOP;\n\t}\n\n\t \n\tif (bus->slave_state == ASPEED_I2C_SLAVE_STOP) {\n\t\ti2c_slave_event(slave, I2C_SLAVE_STOP, &value);\n\t\tbus->slave_state = ASPEED_I2C_SLAVE_INACTIVE;\n\t}\n\n\t \n\tif (irq_status & ASPEED_I2CD_INTR_SLAVE_MATCH) {\n\t\tirq_handled |= ASPEED_I2CD_INTR_SLAVE_MATCH;\n\t\tbus->slave_state = ASPEED_I2C_SLAVE_START;\n\t}\n\n\t \n\tif (bus->slave_state == ASPEED_I2C_SLAVE_INACTIVE)\n\t\treturn irq_handled;\n\n\tcommand = readl(bus->base + ASPEED_I2C_CMD_REG);\n\tdev_dbg(bus->dev, \"slave irq status 0x%08x, cmd 0x%08x\\n\",\n\t\tirq_status, command);\n\n\t \n\tif (irq_status & ASPEED_I2CD_INTR_RX_DONE) {\n\t\tvalue = readl(bus->base + ASPEED_I2C_BYTE_BUF_REG) >> 8;\n\t\t \n\t\tif (bus->slave_state == ASPEED_I2C_SLAVE_START) {\n\t\t\tif (value & 0x1)\n\t\t\t\tbus->slave_state =\n\t\t\t\t\t\tASPEED_I2C_SLAVE_READ_REQUESTED;\n\t\t\telse\n\t\t\t\tbus->slave_state =\n\t\t\t\t\t\tASPEED_I2C_SLAVE_WRITE_REQUESTED;\n\t\t}\n\t\tirq_handled |= ASPEED_I2CD_INTR_RX_DONE;\n\t}\n\n\tswitch (bus->slave_state) {\n\tcase ASPEED_I2C_SLAVE_READ_REQUESTED:\n\t\tif (unlikely(irq_status & ASPEED_I2CD_INTR_TX_ACK))\n\t\t\tdev_err(bus->dev, \"Unexpected ACK on read request.\\n\");\n\t\tbus->slave_state = ASPEED_I2C_SLAVE_READ_PROCESSED;\n\t\ti2c_slave_event(slave, I2C_SLAVE_READ_REQUESTED, &value);\n\t\twritel(value, bus->base + ASPEED_I2C_BYTE_BUF_REG);\n\t\twritel(ASPEED_I2CD_S_TX_CMD, bus->base + ASPEED_I2C_CMD_REG);\n\t\tbreak;\n\tcase ASPEED_I2C_SLAVE_READ_PROCESSED:\n\t\tif (unlikely(!(irq_status & ASPEED_I2CD_INTR_TX_ACK))) {\n\t\t\tdev_err(bus->dev,\n\t\t\t\t\"Expected ACK after processed read.\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tirq_handled |= ASPEED_I2CD_INTR_TX_ACK;\n\t\ti2c_slave_event(slave, I2C_SLAVE_READ_PROCESSED, &value);\n\t\twritel(value, bus->base + ASPEED_I2C_BYTE_BUF_REG);\n\t\twritel(ASPEED_I2CD_S_TX_CMD, bus->base + ASPEED_I2C_CMD_REG);\n\t\tbreak;\n\tcase ASPEED_I2C_SLAVE_WRITE_REQUESTED:\n\t\tbus->slave_state = ASPEED_I2C_SLAVE_WRITE_RECEIVED;\n\t\tret = i2c_slave_event(slave, I2C_SLAVE_WRITE_REQUESTED, &value);\n\t\t \n\t\tif (ret < 0)\n\t\t\twritel(ASPEED_I2CD_M_S_RX_CMD_LAST, bus->base + ASPEED_I2C_CMD_REG);\n\t\tbreak;\n\tcase ASPEED_I2C_SLAVE_WRITE_RECEIVED:\n\t\ti2c_slave_event(slave, I2C_SLAVE_WRITE_RECEIVED, &value);\n\t\tbreak;\n\tcase ASPEED_I2C_SLAVE_STOP:\n\t\t \n\t\tbreak;\n\tcase ASPEED_I2C_SLAVE_START:\n\t\t ;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(bus->dev, \"unknown slave_state: %d\\n\",\n\t\t\tbus->slave_state);\n\t\tbus->slave_state = ASPEED_I2C_SLAVE_INACTIVE;\n\t\tbreak;\n\t}\n\n\treturn irq_handled;\n}\n#endif  \n\n \nstatic void aspeed_i2c_do_start(struct aspeed_i2c_bus *bus)\n{\n\tu32 command = ASPEED_I2CD_M_START_CMD | ASPEED_I2CD_M_TX_CMD;\n\tstruct i2c_msg *msg = &bus->msgs[bus->msgs_index];\n\tu8 slave_addr = i2c_8bit_addr_from_msg(msg);\n\n#if IS_ENABLED(CONFIG_I2C_SLAVE)\n\t \n\tif (bus->slave_state != ASPEED_I2C_SLAVE_INACTIVE) {\n\t\tbus->master_state = ASPEED_I2C_MASTER_PENDING;\n\t\treturn;\n\t}\n#endif  \n\n\tbus->master_state = ASPEED_I2C_MASTER_START;\n\tbus->buf_index = 0;\n\n\tif (msg->flags & I2C_M_RD) {\n\t\tcommand |= ASPEED_I2CD_M_RX_CMD;\n\t\t \n\t\tif (msg->len == 1 && !(msg->flags & I2C_M_RECV_LEN))\n\t\t\tcommand |= ASPEED_I2CD_M_S_RX_CMD_LAST;\n\t}\n\n\twritel(slave_addr, bus->base + ASPEED_I2C_BYTE_BUF_REG);\n\twritel(command, bus->base + ASPEED_I2C_CMD_REG);\n}\n\n \nstatic void aspeed_i2c_do_stop(struct aspeed_i2c_bus *bus)\n{\n\tbus->master_state = ASPEED_I2C_MASTER_STOP;\n\twritel(ASPEED_I2CD_M_STOP_CMD, bus->base + ASPEED_I2C_CMD_REG);\n}\n\n \nstatic void aspeed_i2c_next_msg_or_stop(struct aspeed_i2c_bus *bus)\n{\n\tif (bus->msgs_index + 1 < bus->msgs_count) {\n\t\tbus->msgs_index++;\n\t\taspeed_i2c_do_start(bus);\n\t} else {\n\t\taspeed_i2c_do_stop(bus);\n\t}\n}\n\nstatic int aspeed_i2c_is_irq_error(u32 irq_status)\n{\n\tif (irq_status & ASPEED_I2CD_INTR_ARBIT_LOSS)\n\t\treturn -EAGAIN;\n\tif (irq_status & (ASPEED_I2CD_INTR_SDA_DL_TIMEOUT |\n\t\t\t  ASPEED_I2CD_INTR_SCL_TIMEOUT))\n\t\treturn -EBUSY;\n\tif (irq_status & (ASPEED_I2CD_INTR_ABNORMAL))\n\t\treturn -EPROTO;\n\n\treturn 0;\n}\n\nstatic u32 aspeed_i2c_master_irq(struct aspeed_i2c_bus *bus, u32 irq_status)\n{\n\tu32 irq_handled = 0, command = 0;\n\tstruct i2c_msg *msg;\n\tu8 recv_byte;\n\tint ret;\n\n\tif (irq_status & ASPEED_I2CD_INTR_BUS_RECOVER_DONE) {\n\t\tbus->master_state = ASPEED_I2C_MASTER_INACTIVE;\n\t\tirq_handled |= ASPEED_I2CD_INTR_BUS_RECOVER_DONE;\n\t\tgoto out_complete;\n\t}\n\n\t \n\tret = aspeed_i2c_is_irq_error(irq_status);\n\tif (ret) {\n\t\tdev_dbg(bus->dev, \"received error interrupt: 0x%08x\\n\",\n\t\t\tirq_status);\n\t\tirq_handled |= (irq_status & ASPEED_I2CD_INTR_MASTER_ERRORS);\n\t\tif (bus->master_state != ASPEED_I2C_MASTER_INACTIVE) {\n\t\t\tbus->cmd_err = ret;\n\t\t\tbus->master_state = ASPEED_I2C_MASTER_INACTIVE;\n\t\t\tgoto out_complete;\n\t\t}\n\t}\n\n\t \n\tif (bus->master_state == ASPEED_I2C_MASTER_INACTIVE ||\n\t    bus->master_state == ASPEED_I2C_MASTER_PENDING)\n\t\tgoto out_no_complete;\n\n\t \n\tif (!bus->msgs) {\n\t\tdev_err(bus->dev, \"bus in unknown state. irq_status: 0x%x\\n\",\n\t\t\tirq_status);\n\t\tbus->cmd_err = -EIO;\n\t\tif (bus->master_state != ASPEED_I2C_MASTER_STOP &&\n\t\t    bus->master_state != ASPEED_I2C_MASTER_INACTIVE)\n\t\t\taspeed_i2c_do_stop(bus);\n\t\tgoto out_no_complete;\n\t}\n\tmsg = &bus->msgs[bus->msgs_index];\n\n\t \n\tif (bus->master_state == ASPEED_I2C_MASTER_START) {\n#if IS_ENABLED(CONFIG_I2C_SLAVE)\n\t\t \n\t\tif (unlikely(irq_status & ASPEED_I2CD_INTR_SLAVE_MATCH)) {\n\t\t\twritel(readl(bus->base + ASPEED_I2C_CMD_REG) &\n\t\t\t\t~ASPEED_I2CD_MASTER_CMDS_MASK,\n\t\t\t       bus->base + ASPEED_I2C_CMD_REG);\n\t\t\tbus->master_state = ASPEED_I2C_MASTER_PENDING;\n\t\t\tdev_dbg(bus->dev,\n\t\t\t\t\"master goes pending due to a slave start\\n\");\n\t\t\tgoto out_no_complete;\n\t\t}\n#endif  \n\t\tif (unlikely(!(irq_status & ASPEED_I2CD_INTR_TX_ACK))) {\n\t\t\tif (unlikely(!(irq_status & ASPEED_I2CD_INTR_TX_NAK))) {\n\t\t\t\tbus->cmd_err = -ENXIO;\n\t\t\t\tbus->master_state = ASPEED_I2C_MASTER_INACTIVE;\n\t\t\t\tgoto out_complete;\n\t\t\t}\n\t\t\tpr_devel(\"no slave present at %02x\\n\", msg->addr);\n\t\t\tirq_handled |= ASPEED_I2CD_INTR_TX_NAK;\n\t\t\tbus->cmd_err = -ENXIO;\n\t\t\taspeed_i2c_do_stop(bus);\n\t\t\tgoto out_no_complete;\n\t\t}\n\t\tirq_handled |= ASPEED_I2CD_INTR_TX_ACK;\n\t\tif (msg->len == 0) {  \n\t\t\taspeed_i2c_do_stop(bus);\n\t\t\tgoto out_no_complete;\n\t\t}\n\t\tif (msg->flags & I2C_M_RD)\n\t\t\tbus->master_state = ASPEED_I2C_MASTER_RX_FIRST;\n\t\telse\n\t\t\tbus->master_state = ASPEED_I2C_MASTER_TX_FIRST;\n\t}\n\n\tswitch (bus->master_state) {\n\tcase ASPEED_I2C_MASTER_TX:\n\t\tif (unlikely(irq_status & ASPEED_I2CD_INTR_TX_NAK)) {\n\t\t\tdev_dbg(bus->dev, \"slave NACKed TX\\n\");\n\t\t\tirq_handled |= ASPEED_I2CD_INTR_TX_NAK;\n\t\t\tgoto error_and_stop;\n\t\t} else if (unlikely(!(irq_status & ASPEED_I2CD_INTR_TX_ACK))) {\n\t\t\tdev_err(bus->dev, \"slave failed to ACK TX\\n\");\n\t\t\tgoto error_and_stop;\n\t\t}\n\t\tirq_handled |= ASPEED_I2CD_INTR_TX_ACK;\n\t\tfallthrough;\n\tcase ASPEED_I2C_MASTER_TX_FIRST:\n\t\tif (bus->buf_index < msg->len) {\n\t\t\tbus->master_state = ASPEED_I2C_MASTER_TX;\n\t\t\twritel(msg->buf[bus->buf_index++],\n\t\t\t       bus->base + ASPEED_I2C_BYTE_BUF_REG);\n\t\t\twritel(ASPEED_I2CD_M_TX_CMD,\n\t\t\t       bus->base + ASPEED_I2C_CMD_REG);\n\t\t} else {\n\t\t\taspeed_i2c_next_msg_or_stop(bus);\n\t\t}\n\t\tgoto out_no_complete;\n\tcase ASPEED_I2C_MASTER_RX_FIRST:\n\t\t \n\t\tif (!(irq_status & ASPEED_I2CD_INTR_RX_DONE))\n\t\t\tgoto out_no_complete;\n\t\tfallthrough;\n\tcase ASPEED_I2C_MASTER_RX:\n\t\tif (unlikely(!(irq_status & ASPEED_I2CD_INTR_RX_DONE))) {\n\t\t\tdev_err(bus->dev, \"master failed to RX\\n\");\n\t\t\tgoto error_and_stop;\n\t\t}\n\t\tirq_handled |= ASPEED_I2CD_INTR_RX_DONE;\n\n\t\trecv_byte = readl(bus->base + ASPEED_I2C_BYTE_BUF_REG) >> 8;\n\t\tmsg->buf[bus->buf_index++] = recv_byte;\n\n\t\tif (msg->flags & I2C_M_RECV_LEN) {\n\t\t\tif (unlikely(recv_byte > I2C_SMBUS_BLOCK_MAX)) {\n\t\t\t\tbus->cmd_err = -EPROTO;\n\t\t\t\taspeed_i2c_do_stop(bus);\n\t\t\t\tgoto out_no_complete;\n\t\t\t}\n\t\t\tmsg->len = recv_byte +\n\t\t\t\t\t((msg->flags & I2C_CLIENT_PEC) ? 2 : 1);\n\t\t\tmsg->flags &= ~I2C_M_RECV_LEN;\n\t\t}\n\n\t\tif (bus->buf_index < msg->len) {\n\t\t\tbus->master_state = ASPEED_I2C_MASTER_RX;\n\t\t\tcommand = ASPEED_I2CD_M_RX_CMD;\n\t\t\tif (bus->buf_index + 1 == msg->len)\n\t\t\t\tcommand |= ASPEED_I2CD_M_S_RX_CMD_LAST;\n\t\t\twritel(command, bus->base + ASPEED_I2C_CMD_REG);\n\t\t} else {\n\t\t\taspeed_i2c_next_msg_or_stop(bus);\n\t\t}\n\t\tgoto out_no_complete;\n\tcase ASPEED_I2C_MASTER_STOP:\n\t\tif (unlikely(!(irq_status & ASPEED_I2CD_INTR_NORMAL_STOP))) {\n\t\t\tdev_err(bus->dev,\n\t\t\t\t\"master failed to STOP. irq_status:0x%x\\n\",\n\t\t\t\tirq_status);\n\t\t\tbus->cmd_err = -EIO;\n\t\t\t \n\t\t} else {\n\t\t\tirq_handled |= ASPEED_I2CD_INTR_NORMAL_STOP;\n\t\t}\n\n\t\tbus->master_state = ASPEED_I2C_MASTER_INACTIVE;\n\t\tgoto out_complete;\n\tcase ASPEED_I2C_MASTER_INACTIVE:\n\t\tdev_err(bus->dev,\n\t\t\t\"master received interrupt 0x%08x, but is inactive\\n\",\n\t\t\tirq_status);\n\t\tbus->cmd_err = -EIO;\n\t\t \n\t\tgoto out_complete;\n\tdefault:\n\t\tWARN(1, \"unknown master state\\n\");\n\t\tbus->master_state = ASPEED_I2C_MASTER_INACTIVE;\n\t\tbus->cmd_err = -EINVAL;\n\t\tgoto out_complete;\n\t}\nerror_and_stop:\n\tbus->cmd_err = -EIO;\n\taspeed_i2c_do_stop(bus);\n\tgoto out_no_complete;\nout_complete:\n\tbus->msgs = NULL;\n\tif (bus->cmd_err)\n\t\tbus->master_xfer_result = bus->cmd_err;\n\telse\n\t\tbus->master_xfer_result = bus->msgs_index + 1;\n\tcomplete(&bus->cmd_complete);\nout_no_complete:\n\treturn irq_handled;\n}\n\nstatic irqreturn_t aspeed_i2c_bus_irq(int irq, void *dev_id)\n{\n\tstruct aspeed_i2c_bus *bus = dev_id;\n\tu32 irq_received, irq_remaining, irq_handled;\n\n\tspin_lock(&bus->lock);\n\tirq_received = readl(bus->base + ASPEED_I2C_INTR_STS_REG);\n\t \n\twritel(irq_received & ~ASPEED_I2CD_INTR_RX_DONE,\n\t       bus->base + ASPEED_I2C_INTR_STS_REG);\n\treadl(bus->base + ASPEED_I2C_INTR_STS_REG);\n\tirq_received &= ASPEED_I2CD_INTR_RECV_MASK;\n\tirq_remaining = irq_received;\n\n#if IS_ENABLED(CONFIG_I2C_SLAVE)\n\t \n\tif (bus->master_state != ASPEED_I2C_MASTER_INACTIVE &&\n\t    bus->master_state != ASPEED_I2C_MASTER_PENDING) {\n\t\tirq_handled = aspeed_i2c_master_irq(bus, irq_remaining);\n\t\tirq_remaining &= ~irq_handled;\n\t\tif (irq_remaining)\n\t\t\tirq_handled |= aspeed_i2c_slave_irq(bus, irq_remaining);\n\t} else {\n\t\tirq_handled = aspeed_i2c_slave_irq(bus, irq_remaining);\n\t\tirq_remaining &= ~irq_handled;\n\t\tif (irq_remaining)\n\t\t\tirq_handled |= aspeed_i2c_master_irq(bus,\n\t\t\t\t\t\t\t     irq_remaining);\n\t}\n\n\t \n\tif (bus->master_state == ASPEED_I2C_MASTER_PENDING &&\n\t    bus->slave_state == ASPEED_I2C_SLAVE_INACTIVE)\n\t\taspeed_i2c_do_start(bus);\n#else\n\tirq_handled = aspeed_i2c_master_irq(bus, irq_remaining);\n#endif  \n\n\tirq_remaining &= ~irq_handled;\n\tif (irq_remaining)\n\t\tdev_err(bus->dev,\n\t\t\t\"irq handled != irq. expected 0x%08x, but was 0x%08x\\n\",\n\t\t\tirq_received, irq_handled);\n\n\t \n\tif (irq_received & ASPEED_I2CD_INTR_RX_DONE) {\n\t\twritel(ASPEED_I2CD_INTR_RX_DONE,\n\t\t       bus->base + ASPEED_I2C_INTR_STS_REG);\n\t\treadl(bus->base + ASPEED_I2C_INTR_STS_REG);\n\t}\n\tspin_unlock(&bus->lock);\n\treturn irq_remaining ? IRQ_NONE : IRQ_HANDLED;\n}\n\nstatic int aspeed_i2c_master_xfer(struct i2c_adapter *adap,\n\t\t\t\t  struct i2c_msg *msgs, int num)\n{\n\tstruct aspeed_i2c_bus *bus = i2c_get_adapdata(adap);\n\tunsigned long time_left, flags;\n\n\tspin_lock_irqsave(&bus->lock, flags);\n\tbus->cmd_err = 0;\n\n\t \n\tif (!bus->multi_master &&\n\t    (readl(bus->base + ASPEED_I2C_CMD_REG) &\n\t     ASPEED_I2CD_BUS_BUSY_STS)) {\n\t\tint ret;\n\n\t\tspin_unlock_irqrestore(&bus->lock, flags);\n\t\tret = aspeed_i2c_recover_bus(bus);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tspin_lock_irqsave(&bus->lock, flags);\n\t}\n\n\tbus->cmd_err = 0;\n\tbus->msgs = msgs;\n\tbus->msgs_index = 0;\n\tbus->msgs_count = num;\n\n\treinit_completion(&bus->cmd_complete);\n\taspeed_i2c_do_start(bus);\n\tspin_unlock_irqrestore(&bus->lock, flags);\n\n\ttime_left = wait_for_completion_timeout(&bus->cmd_complete,\n\t\t\t\t\t\tbus->adap.timeout);\n\n\tif (time_left == 0) {\n\t\t \n\t\tif (bus->multi_master &&\n\t\t    (readl(bus->base + ASPEED_I2C_CMD_REG) &\n\t\t     ASPEED_I2CD_BUS_BUSY_STS))\n\t\t\taspeed_i2c_recover_bus(bus);\n\t\telse\n\t\t\taspeed_i2c_reset(bus);\n\n\t\t \n\t\tspin_lock_irqsave(&bus->lock, flags);\n\t\tif (bus->master_state == ASPEED_I2C_MASTER_PENDING)\n\t\t\tbus->master_state = ASPEED_I2C_MASTER_INACTIVE;\n\t\tspin_unlock_irqrestore(&bus->lock, flags);\n\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn bus->master_xfer_result;\n}\n\nstatic u32 aspeed_i2c_functionality(struct i2c_adapter *adap)\n{\n\treturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL | I2C_FUNC_SMBUS_BLOCK_DATA;\n}\n\n#if IS_ENABLED(CONFIG_I2C_SLAVE)\n \nstatic void __aspeed_i2c_reg_slave(struct aspeed_i2c_bus *bus, u16 slave_addr)\n{\n\tu32 addr_reg_val, func_ctrl_reg_val;\n\n\t \n\taddr_reg_val = slave_addr & ASPEED_I2CD_DEV_ADDR_MASK;\n\twritel(addr_reg_val, bus->base + ASPEED_I2C_DEV_ADDR_REG);\n\n\t \n\tfunc_ctrl_reg_val = readl(bus->base + ASPEED_I2C_FUN_CTRL_REG);\n\tfunc_ctrl_reg_val |= ASPEED_I2CD_SLAVE_EN;\n\twritel(func_ctrl_reg_val, bus->base + ASPEED_I2C_FUN_CTRL_REG);\n\n\tbus->slave_state = ASPEED_I2C_SLAVE_INACTIVE;\n}\n\nstatic int aspeed_i2c_reg_slave(struct i2c_client *client)\n{\n\tstruct aspeed_i2c_bus *bus = i2c_get_adapdata(client->adapter);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&bus->lock, flags);\n\tif (bus->slave) {\n\t\tspin_unlock_irqrestore(&bus->lock, flags);\n\t\treturn -EINVAL;\n\t}\n\n\t__aspeed_i2c_reg_slave(bus, client->addr);\n\n\tbus->slave = client;\n\tspin_unlock_irqrestore(&bus->lock, flags);\n\n\treturn 0;\n}\n\nstatic int aspeed_i2c_unreg_slave(struct i2c_client *client)\n{\n\tstruct aspeed_i2c_bus *bus = i2c_get_adapdata(client->adapter);\n\tu32 func_ctrl_reg_val;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&bus->lock, flags);\n\tif (!bus->slave) {\n\t\tspin_unlock_irqrestore(&bus->lock, flags);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tfunc_ctrl_reg_val = readl(bus->base + ASPEED_I2C_FUN_CTRL_REG);\n\tfunc_ctrl_reg_val &= ~ASPEED_I2CD_SLAVE_EN;\n\twritel(func_ctrl_reg_val, bus->base + ASPEED_I2C_FUN_CTRL_REG);\n\n\tbus->slave = NULL;\n\tspin_unlock_irqrestore(&bus->lock, flags);\n\n\treturn 0;\n}\n#endif  \n\nstatic const struct i2c_algorithm aspeed_i2c_algo = {\n\t.master_xfer\t= aspeed_i2c_master_xfer,\n\t.functionality\t= aspeed_i2c_functionality,\n#if IS_ENABLED(CONFIG_I2C_SLAVE)\n\t.reg_slave\t= aspeed_i2c_reg_slave,\n\t.unreg_slave\t= aspeed_i2c_unreg_slave,\n#endif  \n};\n\nstatic u32 aspeed_i2c_get_clk_reg_val(struct device *dev,\n\t\t\t\t      u32 clk_high_low_mask,\n\t\t\t\t      u32 divisor)\n{\n\tu32 base_clk_divisor, clk_high_low_max, clk_high, clk_low, tmp;\n\n\t \n\tclk_high_low_max = (clk_high_low_mask + 1) * 2;\n\n\t \n\tbase_clk_divisor = divisor > clk_high_low_max ?\n\t\t\tilog2((divisor - 1) / clk_high_low_max) + 1 : 0;\n\n\tif (base_clk_divisor > ASPEED_I2CD_TIME_BASE_DIVISOR_MASK) {\n\t\tbase_clk_divisor = ASPEED_I2CD_TIME_BASE_DIVISOR_MASK;\n\t\tclk_low = clk_high_low_mask;\n\t\tclk_high = clk_high_low_mask;\n\t\tdev_err(dev,\n\t\t\t\"clamping clock divider: divider requested, %u, is greater than largest possible divider, %u.\\n\",\n\t\t\tdivisor, (1 << base_clk_divisor) * clk_high_low_max);\n\t} else {\n\t\ttmp = (divisor + (1 << base_clk_divisor) - 1)\n\t\t\t\t>> base_clk_divisor;\n\t\tclk_low = tmp / 2;\n\t\tclk_high = tmp - clk_low;\n\n\t\tif (clk_high)\n\t\t\tclk_high--;\n\n\t\tif (clk_low)\n\t\t\tclk_low--;\n\t}\n\n\n\treturn ((clk_high << ASPEED_I2CD_TIME_SCL_HIGH_SHIFT)\n\t\t& ASPEED_I2CD_TIME_SCL_HIGH_MASK)\n\t\t\t| ((clk_low << ASPEED_I2CD_TIME_SCL_LOW_SHIFT)\n\t\t\t   & ASPEED_I2CD_TIME_SCL_LOW_MASK)\n\t\t\t| (base_clk_divisor\n\t\t\t   & ASPEED_I2CD_TIME_BASE_DIVISOR_MASK);\n}\n\nstatic u32 aspeed_i2c_24xx_get_clk_reg_val(struct device *dev, u32 divisor)\n{\n\t \n\treturn aspeed_i2c_get_clk_reg_val(dev, GENMASK(2, 0), divisor);\n}\n\nstatic u32 aspeed_i2c_25xx_get_clk_reg_val(struct device *dev, u32 divisor)\n{\n\t \n\treturn aspeed_i2c_get_clk_reg_val(dev, GENMASK(3, 0), divisor);\n}\n\n \nstatic int aspeed_i2c_init_clk(struct aspeed_i2c_bus *bus)\n{\n\tu32 divisor, clk_reg_val;\n\n\tdivisor = DIV_ROUND_UP(bus->parent_clk_frequency, bus->bus_frequency);\n\tclk_reg_val = readl(bus->base + ASPEED_I2C_AC_TIMING_REG1);\n\tclk_reg_val &= (ASPEED_I2CD_TIME_TBUF_MASK |\n\t\t\tASPEED_I2CD_TIME_THDSTA_MASK |\n\t\t\tASPEED_I2CD_TIME_TACST_MASK);\n\tclk_reg_val |= bus->get_clk_reg_val(bus->dev, divisor);\n\twritel(clk_reg_val, bus->base + ASPEED_I2C_AC_TIMING_REG1);\n\twritel(ASPEED_NO_TIMEOUT_CTRL, bus->base + ASPEED_I2C_AC_TIMING_REG2);\n\n\treturn 0;\n}\n\n \nstatic int aspeed_i2c_init(struct aspeed_i2c_bus *bus,\n\t\t\t     struct platform_device *pdev)\n{\n\tu32 fun_ctrl_reg = ASPEED_I2CD_MASTER_EN;\n\tint ret;\n\n\t \n\twritel(0, bus->base + ASPEED_I2C_FUN_CTRL_REG);\n\n\tret = aspeed_i2c_init_clk(bus);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (of_property_read_bool(pdev->dev.of_node, \"multi-master\"))\n\t\tbus->multi_master = true;\n\telse\n\t\tfun_ctrl_reg |= ASPEED_I2CD_MULTI_MASTER_DIS;\n\n\t \n\twritel(readl(bus->base + ASPEED_I2C_FUN_CTRL_REG) | fun_ctrl_reg,\n\t       bus->base + ASPEED_I2C_FUN_CTRL_REG);\n\n#if IS_ENABLED(CONFIG_I2C_SLAVE)\n\t \n\tif (bus->slave)\n\t\t__aspeed_i2c_reg_slave(bus, bus->slave->addr);\n#endif  \n\n\t \n\twritel(ASPEED_I2CD_INTR_ALL, bus->base + ASPEED_I2C_INTR_CTRL_REG);\n\n\treturn 0;\n}\n\nstatic int aspeed_i2c_reset(struct aspeed_i2c_bus *bus)\n{\n\tstruct platform_device *pdev = to_platform_device(bus->dev);\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&bus->lock, flags);\n\n\t \n\twritel(0, bus->base + ASPEED_I2C_INTR_CTRL_REG);\n\twritel(0xffffffff, bus->base + ASPEED_I2C_INTR_STS_REG);\n\n\tret = aspeed_i2c_init(bus, pdev);\n\n\tspin_unlock_irqrestore(&bus->lock, flags);\n\n\treturn ret;\n}\n\nstatic const struct of_device_id aspeed_i2c_bus_of_table[] = {\n\t{\n\t\t.compatible = \"aspeed,ast2400-i2c-bus\",\n\t\t.data = aspeed_i2c_24xx_get_clk_reg_val,\n\t},\n\t{\n\t\t.compatible = \"aspeed,ast2500-i2c-bus\",\n\t\t.data = aspeed_i2c_25xx_get_clk_reg_val,\n\t},\n\t{\n\t\t.compatible = \"aspeed,ast2600-i2c-bus\",\n\t\t.data = aspeed_i2c_25xx_get_clk_reg_val,\n\t},\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, aspeed_i2c_bus_of_table);\n\nstatic int aspeed_i2c_probe_bus(struct platform_device *pdev)\n{\n\tconst struct of_device_id *match;\n\tstruct aspeed_i2c_bus *bus;\n\tstruct clk *parent_clk;\n\tint irq, ret;\n\n\tbus = devm_kzalloc(&pdev->dev, sizeof(*bus), GFP_KERNEL);\n\tif (!bus)\n\t\treturn -ENOMEM;\n\n\tbus->base = devm_platform_get_and_ioremap_resource(pdev, 0, NULL);\n\tif (IS_ERR(bus->base))\n\t\treturn PTR_ERR(bus->base);\n\n\tparent_clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(parent_clk))\n\t\treturn PTR_ERR(parent_clk);\n\tbus->parent_clk_frequency = clk_get_rate(parent_clk);\n\t \n\tdevm_clk_put(&pdev->dev, parent_clk);\n\n\tbus->rst = devm_reset_control_get_shared(&pdev->dev, NULL);\n\tif (IS_ERR(bus->rst)) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"missing or invalid reset controller device tree entry\\n\");\n\t\treturn PTR_ERR(bus->rst);\n\t}\n\treset_control_deassert(bus->rst);\n\n\tret = of_property_read_u32(pdev->dev.of_node,\n\t\t\t\t   \"bus-frequency\", &bus->bus_frequency);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Could not read bus-frequency property\\n\");\n\t\tbus->bus_frequency = I2C_MAX_STANDARD_MODE_FREQ;\n\t}\n\n\tmatch = of_match_node(aspeed_i2c_bus_of_table, pdev->dev.of_node);\n\tif (!match)\n\t\tbus->get_clk_reg_val = aspeed_i2c_24xx_get_clk_reg_val;\n\telse\n\t\tbus->get_clk_reg_val = (u32 (*)(struct device *, u32))\n\t\t\t\tmatch->data;\n\n\t \n\tspin_lock_init(&bus->lock);\n\tinit_completion(&bus->cmd_complete);\n\tbus->adap.owner = THIS_MODULE;\n\tbus->adap.retries = 0;\n\tbus->adap.algo = &aspeed_i2c_algo;\n\tbus->adap.dev.parent = &pdev->dev;\n\tbus->adap.dev.of_node = pdev->dev.of_node;\n\tstrscpy(bus->adap.name, pdev->name, sizeof(bus->adap.name));\n\ti2c_set_adapdata(&bus->adap, bus);\n\n\tbus->dev = &pdev->dev;\n\n\t \n\twritel(0, bus->base + ASPEED_I2C_INTR_CTRL_REG);\n\twritel(0xffffffff, bus->base + ASPEED_I2C_INTR_STS_REG);\n\t \n\tret = aspeed_i2c_init(bus, pdev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tirq = irq_of_parse_and_map(pdev->dev.of_node, 0);\n\tret = devm_request_irq(&pdev->dev, irq, aspeed_i2c_bus_irq,\n\t\t\t       0, dev_name(&pdev->dev), bus);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = i2c_add_adapter(&bus->adap);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tplatform_set_drvdata(pdev, bus);\n\n\tdev_info(bus->dev, \"i2c bus %d registered, irq %d\\n\",\n\t\t bus->adap.nr, irq);\n\n\treturn 0;\n}\n\nstatic void aspeed_i2c_remove_bus(struct platform_device *pdev)\n{\n\tstruct aspeed_i2c_bus *bus = platform_get_drvdata(pdev);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&bus->lock, flags);\n\n\t \n\twritel(0, bus->base + ASPEED_I2C_FUN_CTRL_REG);\n\twritel(0, bus->base + ASPEED_I2C_INTR_CTRL_REG);\n\n\tspin_unlock_irqrestore(&bus->lock, flags);\n\n\treset_control_assert(bus->rst);\n\n\ti2c_del_adapter(&bus->adap);\n}\n\nstatic struct platform_driver aspeed_i2c_bus_driver = {\n\t.probe\t\t= aspeed_i2c_probe_bus,\n\t.remove_new\t= aspeed_i2c_remove_bus,\n\t.driver\t\t= {\n\t\t.name\t\t= \"aspeed-i2c-bus\",\n\t\t.of_match_table\t= aspeed_i2c_bus_of_table,\n\t},\n};\nmodule_platform_driver(aspeed_i2c_bus_driver);\n\nMODULE_AUTHOR(\"Brendan Higgins <brendanhiggins@google.com>\");\nMODULE_DESCRIPTION(\"Aspeed I2C Bus Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}