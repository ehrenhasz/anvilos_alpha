{
  "module_name": "i2c-pca-isa.c",
  "hash_id": "29816d8a20a72500c071b067ad375bbad5c56b038647d13febd50353c59c1f0b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-pca-isa.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/ioport.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/wait.h>\n#include <linux/isa.h>\n#include <linux/i2c.h>\n#include <linux/i2c-algo-pca.h>\n#include <linux/io.h>\n\n#include <asm/irq.h>\n\n#define DRIVER \"i2c-pca-isa\"\n#define IO_SIZE 4\n\nstatic unsigned long base;\nstatic int irq = -1;\n\n \nstatic int clock  = 59000;\n\nstatic struct i2c_adapter pca_isa_ops;\nstatic wait_queue_head_t pca_wait;\n\nstatic void pca_isa_writebyte(void *pd, int reg, int val)\n{\n#ifdef DEBUG_IO\n\tstatic char *names[] = { \"T/O\", \"DAT\", \"ADR\", \"CON\" };\n\tprintk(KERN_DEBUG \"*** write %s at %#lx <= %#04x\\n\", names[reg],\n\t       base+reg, val);\n#endif\n\toutb(val, base+reg);\n}\n\nstatic int pca_isa_readbyte(void *pd, int reg)\n{\n\tint res = inb(base+reg);\n#ifdef DEBUG_IO\n\t{\n\t\tstatic char *names[] = { \"STA\", \"DAT\", \"ADR\", \"CON\" };\n\t\tprintk(KERN_DEBUG \"*** read  %s => %#04x\\n\", names[reg], res);\n\t}\n#endif\n\treturn res;\n}\n\nstatic int pca_isa_waitforcompletion(void *pd)\n{\n\tunsigned long timeout;\n\tlong ret;\n\n\tif (irq > -1) {\n\t\tret = wait_event_timeout(pca_wait,\n\t\t\t\tpca_isa_readbyte(pd, I2C_PCA_CON)\n\t\t\t\t& I2C_PCA_CON_SI, pca_isa_ops.timeout);\n\t} else {\n\t\t \n\t\ttimeout = jiffies + pca_isa_ops.timeout;\n\t\tdo {\n\t\t\tret = time_before(jiffies, timeout);\n\t\t\tif (pca_isa_readbyte(pd, I2C_PCA_CON)\n\t\t\t\t\t& I2C_PCA_CON_SI)\n\t\t\t\tbreak;\n\t\t\tudelay(100);\n\t\t} while (ret);\n\t}\n\n\treturn ret > 0;\n}\n\nstatic void pca_isa_resetchip(void *pd)\n{\n\t \n\tprintk(KERN_WARNING DRIVER \": Haven't figured out how to do a reset yet\\n\");\n}\n\nstatic irqreturn_t pca_handler(int this_irq, void *dev_id) {\n\twake_up(&pca_wait);\n\treturn IRQ_HANDLED;\n}\n\nstatic struct i2c_algo_pca_data pca_isa_data = {\n\t \n\t.write_byte\t\t= pca_isa_writebyte,\n\t.read_byte\t\t= pca_isa_readbyte,\n\t.wait_for_completion\t= pca_isa_waitforcompletion,\n\t.reset_chip\t\t= pca_isa_resetchip,\n};\n\nstatic struct i2c_adapter pca_isa_ops = {\n\t.owner          = THIS_MODULE,\n\t.algo_data\t= &pca_isa_data,\n\t.name\t\t= \"PCA9564/PCA9665 ISA Adapter\",\n\t.timeout\t= HZ,\n};\n\nstatic int pca_isa_match(struct device *dev, unsigned int id)\n{\n\tint match = base != 0;\n\n\tif (match) {\n\t\tif (irq <= -1)\n\t\t\tdev_warn(dev, \"Using polling mode (specify irq)\\n\");\n\t} else\n\t\tdev_err(dev, \"Please specify I/O base\\n\");\n\n\treturn match;\n}\n\nstatic int pca_isa_probe(struct device *dev, unsigned int id)\n{\n\tinit_waitqueue_head(&pca_wait);\n\n\tdev_info(dev, \"i/o base %#08lx. irq %d\\n\", base, irq);\n\n#ifdef CONFIG_PPC\n\tif (check_legacy_ioport(base)) {\n\t\tdev_err(dev, \"I/O address %#08lx is not available\\n\", base);\n\t\tgoto out;\n\t}\n#endif\n\n\tif (!request_region(base, IO_SIZE, \"i2c-pca-isa\")) {\n\t\tdev_err(dev, \"I/O address %#08lx is in use\\n\", base);\n\t\tgoto out;\n\t}\n\n\tif (irq > -1) {\n\t\tif (request_irq(irq, pca_handler, 0, \"i2c-pca-isa\", &pca_isa_ops) < 0) {\n\t\t\tdev_err(dev, \"Request irq%d failed\\n\", irq);\n\t\t\tgoto out_region;\n\t\t}\n\t}\n\n\tpca_isa_data.i2c_clock = clock;\n\tif (i2c_pca_add_bus(&pca_isa_ops) < 0) {\n\t\tdev_err(dev, \"Failed to add i2c bus\\n\");\n\t\tgoto out_irq;\n\t}\n\n\treturn 0;\n\n out_irq:\n\tif (irq > -1)\n\t\tfree_irq(irq, &pca_isa_ops);\n out_region:\n\trelease_region(base, IO_SIZE);\n out:\n\treturn -ENODEV;\n}\n\nstatic void pca_isa_remove(struct device *dev, unsigned int id)\n{\n\ti2c_del_adapter(&pca_isa_ops);\n\n\tif (irq > -1) {\n\t\tdisable_irq(irq);\n\t\tfree_irq(irq, &pca_isa_ops);\n\t}\n\trelease_region(base, IO_SIZE);\n}\n\nstatic struct isa_driver pca_isa_driver = {\n\t.match\t\t= pca_isa_match,\n\t.probe\t\t= pca_isa_probe,\n\t.remove\t\t= pca_isa_remove,\n\t.driver = {\n\t\t.owner\t= THIS_MODULE,\n\t\t.name\t= DRIVER,\n\t}\n};\n\nMODULE_AUTHOR(\"Ian Campbell <icampbell@arcom.com>\");\nMODULE_DESCRIPTION(\"ISA base PCA9564/PCA9665 driver\");\nMODULE_LICENSE(\"GPL\");\n\nmodule_param_hw(base, ulong, ioport, 0);\nMODULE_PARM_DESC(base, \"I/O base address\");\nmodule_param_hw(irq, int, irq, 0);\nMODULE_PARM_DESC(irq, \"IRQ\");\nmodule_param(clock, int, 0);\nMODULE_PARM_DESC(clock, \"Clock rate in hertz.\\n\\t\\t\"\n\t\t\"For PCA9564: 330000,288000,217000,146000,\"\n\t\t\"88000,59000,44000,36000\\n\"\n\t\t\"\\t\\tFor PCA9665:\\tStandard: 60300 - 100099\\n\"\n\t\t\"\\t\\t\\t\\tFast: 100100 - 400099\\n\"\n\t\t\"\\t\\t\\t\\tFast+: 400100 - 10000099\\n\"\n\t\t\"\\t\\t\\t\\tTurbo: Up to 1265800\");\nmodule_isa_driver(pca_isa_driver, 1);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}