{
  "module_name": "i2c-at91-master.c",
  "hash_id": "1d6184372544525865b74eb363e05d064d4cbfa6b50579df6b3ef147fc862331",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-at91-master.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/completion.h>\n#include <linux/dma-mapping.h>\n#include <linux/dmaengine.h>\n#include <linux/err.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n\n#include \"i2c-at91.h\"\n\nvoid at91_init_twi_bus_master(struct at91_twi_dev *dev)\n{\n\tstruct at91_twi_pdata *pdata = dev->pdata;\n\tu32 filtr = 0;\n\n\t \n\tif (dev->fifo_size)\n\t\tat91_twi_write(dev, AT91_TWI_CR, AT91_TWI_FIFOEN);\n\tat91_twi_write(dev, AT91_TWI_CR, AT91_TWI_MSEN);\n\tat91_twi_write(dev, AT91_TWI_CR, AT91_TWI_SVDIS);\n\tat91_twi_write(dev, AT91_TWI_CWGR, dev->twi_cwgr_reg);\n\n\t \n\tif (pdata->has_dig_filtr && dev->enable_dig_filt)\n\t\tfiltr |= AT91_TWI_FILTR_FILT;\n\n\t \n\tif (pdata->has_adv_dig_filtr && dev->enable_dig_filt)\n\t\tfiltr |= AT91_TWI_FILTR_FILT |\n\t\t\t (AT91_TWI_FILTR_THRES(dev->filter_width) &\n\t\t\t AT91_TWI_FILTR_THRES_MASK);\n\n\t \n\tif (pdata->has_ana_filtr && dev->enable_ana_filt)\n\t\tfiltr |= AT91_TWI_FILTR_PADFEN;\n\n\tif (filtr)\n\t\tat91_twi_write(dev, AT91_TWI_FILTR, filtr);\n}\n\n \nstatic void at91_calc_twi_clock(struct at91_twi_dev *dev)\n{\n\tint ckdiv, cdiv, div, hold = 0, filter_width = 0;\n\tstruct at91_twi_pdata *pdata = dev->pdata;\n\tint offset = pdata->clk_offset;\n\tint max_ckdiv = pdata->clk_max_div;\n\tstruct i2c_timings timings, *t = &timings;\n\n\ti2c_parse_fw_timings(dev->dev, t, true);\n\n\tdiv = max(0, (int)DIV_ROUND_UP(clk_get_rate(dev->clk),\n\t\t\t\t       2 * t->bus_freq_hz) - offset);\n\tckdiv = fls(div >> 8);\n\tcdiv = div >> ckdiv;\n\n\tif (ckdiv > max_ckdiv) {\n\t\tdev_warn(dev->dev, \"%d exceeds ckdiv max value which is %d.\\n\",\n\t\t\t ckdiv, max_ckdiv);\n\t\tckdiv = max_ckdiv;\n\t\tcdiv = 255;\n\t}\n\n\tif (pdata->has_hold_field) {\n\t\t \n\t\thold = DIV_ROUND_UP(t->sda_hold_ns\n\t\t\t\t    * (clk_get_rate(dev->clk) / 1000), 1000000);\n\t\thold -= 3;\n\t\tif (hold < 0)\n\t\t\thold = 0;\n\t\tif (hold > AT91_TWI_CWGR_HOLD_MAX) {\n\t\t\tdev_warn(dev->dev,\n\t\t\t\t \"HOLD field set to its maximum value (%d instead of %d)\\n\",\n\t\t\t\t AT91_TWI_CWGR_HOLD_MAX, hold);\n\t\t\thold = AT91_TWI_CWGR_HOLD_MAX;\n\t\t}\n\t}\n\n\tif (pdata->has_adv_dig_filtr) {\n\t\t \n\t\tfilter_width = DIV_ROUND_UP(t->digital_filter_width_ns\n\t\t\t\t* (clk_get_rate(dev->clk) / 1000), 1000000);\n\t\tif (filter_width > AT91_TWI_FILTR_THRES_MAX) {\n\t\t\tdev_warn(dev->dev,\n\t\t\t\t\"Filter threshold set to its maximum value (%d instead of %d)\\n\",\n\t\t\t\tAT91_TWI_FILTR_THRES_MAX, filter_width);\n\t\t\tfilter_width = AT91_TWI_FILTR_THRES_MAX;\n\t\t}\n\t}\n\n\tdev->twi_cwgr_reg = (ckdiv << 16) | (cdiv << 8) | cdiv\n\t\t\t    | AT91_TWI_CWGR_HOLD(hold);\n\n\tdev->filter_width = filter_width;\n\n\tdev_dbg(dev->dev, \"cdiv %d ckdiv %d hold %d (%d ns), filter_width %d (%d ns)\\n\",\n\t\tcdiv, ckdiv, hold, t->sda_hold_ns, filter_width,\n\t\tt->digital_filter_width_ns);\n}\n\nstatic void at91_twi_dma_cleanup(struct at91_twi_dev *dev)\n{\n\tstruct at91_twi_dma *dma = &dev->dma;\n\n\tat91_twi_irq_save(dev);\n\n\tif (dma->xfer_in_progress) {\n\t\tif (dma->direction == DMA_FROM_DEVICE)\n\t\t\tdmaengine_terminate_sync(dma->chan_rx);\n\t\telse\n\t\t\tdmaengine_terminate_sync(dma->chan_tx);\n\t\tdma->xfer_in_progress = false;\n\t}\n\tif (dma->buf_mapped) {\n\t\tdma_unmap_single(dev->dev, sg_dma_address(&dma->sg[0]),\n\t\t\t\t dev->buf_len, dma->direction);\n\t\tdma->buf_mapped = false;\n\t}\n\n\tat91_twi_irq_restore(dev);\n}\n\nstatic void at91_twi_write_next_byte(struct at91_twi_dev *dev)\n{\n\tif (!dev->buf_len)\n\t\treturn;\n\n\t \n\twriteb_relaxed(*dev->buf, dev->base + AT91_TWI_THR);\n\n\t \n\tif (--dev->buf_len == 0) {\n\t\tif (!dev->use_alt_cmd)\n\t\t\tat91_twi_write(dev, AT91_TWI_CR, AT91_TWI_STOP);\n\t\tat91_twi_write(dev, AT91_TWI_IDR, AT91_TWI_TXRDY);\n\t}\n\n\tdev_dbg(dev->dev, \"wrote 0x%x, to go %zu\\n\", *dev->buf, dev->buf_len);\n\n\t++dev->buf;\n}\n\nstatic void at91_twi_write_data_dma_callback(void *data)\n{\n\tstruct at91_twi_dev *dev = (struct at91_twi_dev *)data;\n\n\tdma_unmap_single(dev->dev, sg_dma_address(&dev->dma.sg[0]),\n\t\t\t dev->buf_len, DMA_TO_DEVICE);\n\n\t \n\tat91_twi_write(dev, AT91_TWI_IER, AT91_TWI_TXCOMP);\n\tif (!dev->use_alt_cmd)\n\t\tat91_twi_write(dev, AT91_TWI_CR, AT91_TWI_STOP);\n}\n\nstatic void at91_twi_write_data_dma(struct at91_twi_dev *dev)\n{\n\tdma_addr_t dma_addr;\n\tstruct dma_async_tx_descriptor *txdesc;\n\tstruct at91_twi_dma *dma = &dev->dma;\n\tstruct dma_chan *chan_tx = dma->chan_tx;\n\tunsigned int sg_len = 1;\n\n\tif (!dev->buf_len)\n\t\treturn;\n\n\tdma->direction = DMA_TO_DEVICE;\n\n\tat91_twi_irq_save(dev);\n\tdma_addr = dma_map_single(dev->dev, dev->buf, dev->buf_len,\n\t\t\t\t  DMA_TO_DEVICE);\n\tif (dma_mapping_error(dev->dev, dma_addr)) {\n\t\tdev_err(dev->dev, \"dma map failed\\n\");\n\t\treturn;\n\t}\n\tdma->buf_mapped = true;\n\tat91_twi_irq_restore(dev);\n\n\tif (dev->fifo_size) {\n\t\tsize_t part1_len, part2_len;\n\t\tstruct scatterlist *sg;\n\t\tunsigned fifo_mr;\n\n\t\tsg_len = 0;\n\n\t\tpart1_len = dev->buf_len & ~0x3;\n\t\tif (part1_len) {\n\t\t\tsg = &dma->sg[sg_len++];\n\t\t\tsg_dma_len(sg) = part1_len;\n\t\t\tsg_dma_address(sg) = dma_addr;\n\t\t}\n\n\t\tpart2_len = dev->buf_len & 0x3;\n\t\tif (part2_len) {\n\t\t\tsg = &dma->sg[sg_len++];\n\t\t\tsg_dma_len(sg) = part2_len;\n\t\t\tsg_dma_address(sg) = dma_addr + part1_len;\n\t\t}\n\n\t\t \n\t\tfifo_mr = at91_twi_read(dev, AT91_TWI_FMR);\n\t\tfifo_mr &= ~AT91_TWI_FMR_TXRDYM_MASK;\n\t\tfifo_mr |= AT91_TWI_FMR_TXRDYM(AT91_TWI_FOUR_DATA);\n\t\tat91_twi_write(dev, AT91_TWI_FMR, fifo_mr);\n\t} else {\n\t\tsg_dma_len(&dma->sg[0]) = dev->buf_len;\n\t\tsg_dma_address(&dma->sg[0]) = dma_addr;\n\t}\n\n\ttxdesc = dmaengine_prep_slave_sg(chan_tx, dma->sg, sg_len,\n\t\t\t\t\t DMA_MEM_TO_DEV,\n\t\t\t\t\t DMA_PREP_INTERRUPT | DMA_CTRL_ACK);\n\tif (!txdesc) {\n\t\tdev_err(dev->dev, \"dma prep slave sg failed\\n\");\n\t\tgoto error;\n\t}\n\n\ttxdesc->callback = at91_twi_write_data_dma_callback;\n\ttxdesc->callback_param = dev;\n\n\tdma->xfer_in_progress = true;\n\tdmaengine_submit(txdesc);\n\tdma_async_issue_pending(chan_tx);\n\n\treturn;\n\nerror:\n\tat91_twi_dma_cleanup(dev);\n}\n\nstatic void at91_twi_read_next_byte(struct at91_twi_dev *dev)\n{\n\t \n\tif (!dev->buf_len) {\n\t\tat91_twi_read(dev, AT91_TWI_RHR);\n\t\treturn;\n\t}\n\n\t \n\t*dev->buf = readb_relaxed(dev->base + AT91_TWI_RHR);\n\t--dev->buf_len;\n\n\t \n\tif (dev->recv_len_abort)\n\t\treturn;\n\n\t \n\tif (unlikely(dev->msg->flags & I2C_M_RECV_LEN)) {\n\t\t \n\t\tif (*dev->buf <= I2C_SMBUS_BLOCK_MAX && *dev->buf > 0) {\n\t\t\tdev->msg->flags &= ~I2C_M_RECV_LEN;\n\t\t\tdev->buf_len += *dev->buf;\n\t\t\tdev->msg->len = dev->buf_len + 1;\n\t\t\tdev_dbg(dev->dev, \"received block length %zu\\n\",\n\t\t\t\t\t dev->buf_len);\n\t\t} else {\n\t\t\t \n\t\t\tdev->recv_len_abort = true;\n\t\t\tdev->buf_len = 1;\n\t\t}\n\t}\n\n\t \n\tif (!dev->use_alt_cmd && dev->buf_len == 1)\n\t\tat91_twi_write(dev, AT91_TWI_CR, AT91_TWI_STOP);\n\n\tdev_dbg(dev->dev, \"read 0x%x, to go %zu\\n\", *dev->buf, dev->buf_len);\n\n\t++dev->buf;\n}\n\nstatic void at91_twi_read_data_dma_callback(void *data)\n{\n\tstruct at91_twi_dev *dev = (struct at91_twi_dev *)data;\n\tunsigned ier = AT91_TWI_TXCOMP;\n\n\tdma_unmap_single(dev->dev, sg_dma_address(&dev->dma.sg[0]),\n\t\t\t dev->buf_len, DMA_FROM_DEVICE);\n\n\tif (!dev->use_alt_cmd) {\n\t\t \n\t\tdev->buf += dev->buf_len - 2;\n\t\tdev->buf_len = 2;\n\t\tier |= AT91_TWI_RXRDY;\n\t}\n\tat91_twi_write(dev, AT91_TWI_IER, ier);\n}\n\nstatic void at91_twi_read_data_dma(struct at91_twi_dev *dev)\n{\n\tdma_addr_t dma_addr;\n\tstruct dma_async_tx_descriptor *rxdesc;\n\tstruct at91_twi_dma *dma = &dev->dma;\n\tstruct dma_chan *chan_rx = dma->chan_rx;\n\tsize_t buf_len;\n\n\tbuf_len = (dev->use_alt_cmd) ? dev->buf_len : dev->buf_len - 2;\n\tdma->direction = DMA_FROM_DEVICE;\n\n\t \n\tat91_twi_irq_save(dev);\n\tdma_addr = dma_map_single(dev->dev, dev->buf, buf_len, DMA_FROM_DEVICE);\n\tif (dma_mapping_error(dev->dev, dma_addr)) {\n\t\tdev_err(dev->dev, \"dma map failed\\n\");\n\t\treturn;\n\t}\n\tdma->buf_mapped = true;\n\tat91_twi_irq_restore(dev);\n\n\tif (dev->fifo_size && IS_ALIGNED(buf_len, 4)) {\n\t\tunsigned fifo_mr;\n\n\t\t \n\t\tfifo_mr = at91_twi_read(dev, AT91_TWI_FMR);\n\t\tfifo_mr &= ~AT91_TWI_FMR_RXRDYM_MASK;\n\t\tfifo_mr |= AT91_TWI_FMR_RXRDYM(AT91_TWI_FOUR_DATA);\n\t\tat91_twi_write(dev, AT91_TWI_FMR, fifo_mr);\n\t}\n\n\tsg_dma_len(&dma->sg[0]) = buf_len;\n\tsg_dma_address(&dma->sg[0]) = dma_addr;\n\n\trxdesc = dmaengine_prep_slave_sg(chan_rx, dma->sg, 1, DMA_DEV_TO_MEM,\n\t\t\t\t\t DMA_PREP_INTERRUPT | DMA_CTRL_ACK);\n\tif (!rxdesc) {\n\t\tdev_err(dev->dev, \"dma prep slave sg failed\\n\");\n\t\tgoto error;\n\t}\n\n\trxdesc->callback = at91_twi_read_data_dma_callback;\n\trxdesc->callback_param = dev;\n\n\tdma->xfer_in_progress = true;\n\tdmaengine_submit(rxdesc);\n\tdma_async_issue_pending(dma->chan_rx);\n\n\treturn;\n\nerror:\n\tat91_twi_dma_cleanup(dev);\n}\n\nstatic irqreturn_t atmel_twi_interrupt(int irq, void *dev_id)\n{\n\tstruct at91_twi_dev *dev = dev_id;\n\tconst unsigned status = at91_twi_read(dev, AT91_TWI_SR);\n\tconst unsigned irqstatus = status & at91_twi_read(dev, AT91_TWI_IMR);\n\n\tif (!irqstatus)\n\t\treturn IRQ_NONE;\n\t \n\tif (irqstatus & AT91_TWI_RXRDY) {\n\t\t \n\t\tdo {\n\t\t\tat91_twi_read_next_byte(dev);\n\t\t} while (at91_twi_read(dev, AT91_TWI_SR) & AT91_TWI_RXRDY);\n\t}\n\n\t \n\tif (irqstatus & (AT91_TWI_TXCOMP | AT91_TWI_NACK)) {\n\t\tat91_disable_twi_interrupts(dev);\n\t\tcomplete(&dev->cmd_complete);\n\t} else if (irqstatus & AT91_TWI_TXRDY) {\n\t\tat91_twi_write_next_byte(dev);\n\t}\n\n\t \n\tdev->transfer_status |= status;\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int at91_do_twi_transfer(struct at91_twi_dev *dev)\n{\n\tint ret;\n\tunsigned long time_left;\n\tbool has_unre_flag = dev->pdata->has_unre_flag;\n\tbool has_alt_cmd = dev->pdata->has_alt_cmd;\n\n\t \n\n\tdev_dbg(dev->dev, \"transfer: %s %zu bytes.\\n\",\n\t\t(dev->msg->flags & I2C_M_RD) ? \"read\" : \"write\", dev->buf_len);\n\n\treinit_completion(&dev->cmd_complete);\n\tdev->transfer_status = 0;\n\n\t \n\tat91_twi_read(dev, AT91_TWI_SR);\n\n\tif (dev->fifo_size) {\n\t\tunsigned fifo_mr = at91_twi_read(dev, AT91_TWI_FMR);\n\n\t\t \n\t\tfifo_mr &= ~(AT91_TWI_FMR_TXRDYM_MASK |\n\t\t\t     AT91_TWI_FMR_RXRDYM_MASK);\n\t\tfifo_mr |= AT91_TWI_FMR_TXRDYM(AT91_TWI_ONE_DATA);\n\t\tfifo_mr |= AT91_TWI_FMR_RXRDYM(AT91_TWI_ONE_DATA);\n\t\tat91_twi_write(dev, AT91_TWI_FMR, fifo_mr);\n\n\t\t \n\t\tat91_twi_write(dev, AT91_TWI_CR,\n\t\t\t       AT91_TWI_THRCLR | AT91_TWI_RHRCLR);\n\t}\n\n\tif (!dev->buf_len) {\n\t\tat91_twi_write(dev, AT91_TWI_CR, AT91_TWI_QUICK);\n\t\tat91_twi_write(dev, AT91_TWI_IER, AT91_TWI_TXCOMP);\n\t} else if (dev->msg->flags & I2C_M_RD) {\n\t\tunsigned start_flags = AT91_TWI_START;\n\n\t\t \n\t\tif (!dev->use_alt_cmd && dev->buf_len <= 1 &&\n\t\t    !(dev->msg->flags & I2C_M_RECV_LEN))\n\t\t\tstart_flags |= AT91_TWI_STOP;\n\t\tat91_twi_write(dev, AT91_TWI_CR, start_flags);\n\t\t \n\t\tif (dev->use_dma && (dev->buf_len > AT91_I2C_DMA_THRESHOLD)) {\n\t\t\tat91_twi_write(dev, AT91_TWI_IER, AT91_TWI_NACK);\n\t\t\tat91_twi_read_data_dma(dev);\n\t\t} else {\n\t\t\tat91_twi_write(dev, AT91_TWI_IER,\n\t\t\t\t       AT91_TWI_TXCOMP |\n\t\t\t\t       AT91_TWI_NACK |\n\t\t\t\t       AT91_TWI_RXRDY);\n\t\t}\n\t} else {\n\t\tif (dev->use_dma && (dev->buf_len > AT91_I2C_DMA_THRESHOLD)) {\n\t\t\tat91_twi_write(dev, AT91_TWI_IER, AT91_TWI_NACK);\n\t\t\tat91_twi_write_data_dma(dev);\n\t\t} else {\n\t\t\tat91_twi_write_next_byte(dev);\n\t\t\tat91_twi_write(dev, AT91_TWI_IER,\n\t\t\t\t       AT91_TWI_TXCOMP | AT91_TWI_NACK |\n\t\t\t\t       (dev->buf_len ? AT91_TWI_TXRDY : 0));\n\t\t}\n\t}\n\n\ttime_left = wait_for_completion_timeout(&dev->cmd_complete,\n\t\t\t\t\t      dev->adapter.timeout);\n\tif (time_left == 0) {\n\t\tdev->transfer_status |= at91_twi_read(dev, AT91_TWI_SR);\n\t\tdev_err(dev->dev, \"controller timed out\\n\");\n\t\tat91_init_twi_bus(dev);\n\t\tret = -ETIMEDOUT;\n\t\tgoto error;\n\t}\n\tif (dev->transfer_status & AT91_TWI_NACK) {\n\t\tdev_dbg(dev->dev, \"received nack\\n\");\n\t\tret = -EREMOTEIO;\n\t\tgoto error;\n\t}\n\tif (dev->transfer_status & AT91_TWI_OVRE) {\n\t\tdev_err(dev->dev, \"overrun while reading\\n\");\n\t\tret = -EIO;\n\t\tgoto error;\n\t}\n\tif (has_unre_flag && dev->transfer_status & AT91_TWI_UNRE) {\n\t\tdev_err(dev->dev, \"underrun while writing\\n\");\n\t\tret = -EIO;\n\t\tgoto error;\n\t}\n\tif ((has_alt_cmd || dev->fifo_size) &&\n\t    (dev->transfer_status & AT91_TWI_LOCK)) {\n\t\tdev_err(dev->dev, \"tx locked\\n\");\n\t\tret = -EIO;\n\t\tgoto error;\n\t}\n\tif (dev->recv_len_abort) {\n\t\tdev_err(dev->dev, \"invalid smbus block length recvd\\n\");\n\t\tret = -EPROTO;\n\t\tgoto error;\n\t}\n\n\tdev_dbg(dev->dev, \"transfer complete\\n\");\n\n\treturn 0;\n\nerror:\n\t \n\tat91_twi_dma_cleanup(dev);\n\t \n\tif ((has_alt_cmd || dev->fifo_size) &&\n\t    (dev->transfer_status & AT91_TWI_LOCK)) {\n\t\tdev_dbg(dev->dev, \"unlock tx\\n\");\n\t\tat91_twi_write(dev, AT91_TWI_CR,\n\t\t\t       AT91_TWI_THRCLR | AT91_TWI_LOCKCLR);\n\t}\n\n\t \n\ti2c_recover_bus(&dev->adapter);\n\n\treturn ret;\n}\n\nstatic int at91_twi_xfer(struct i2c_adapter *adap, struct i2c_msg *msg, int num)\n{\n\tstruct at91_twi_dev *dev = i2c_get_adapdata(adap);\n\tint ret;\n\tunsigned int_addr_flag = 0;\n\tstruct i2c_msg *m_start = msg;\n\tbool is_read;\n\tu8 *dma_buf = NULL;\n\n\tdev_dbg(&adap->dev, \"at91_xfer: processing %d messages:\\n\", num);\n\n\tret = pm_runtime_get_sync(dev->dev);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (num == 2) {\n\t\tint internal_address = 0;\n\t\tint i;\n\n\t\t \n\t\tm_start = &msg[1];\n\t\tfor (i = 0; i < msg->len; ++i) {\n\t\t\tconst unsigned addr = msg->buf[msg->len - 1 - i];\n\n\t\t\tinternal_address |= addr << (8 * i);\n\t\t\tint_addr_flag += AT91_TWI_IADRSZ_1;\n\t\t}\n\t\tat91_twi_write(dev, AT91_TWI_IADR, internal_address);\n\t}\n\n\tdev->use_alt_cmd = false;\n\tis_read = (m_start->flags & I2C_M_RD);\n\tif (dev->pdata->has_alt_cmd) {\n\t\tif (m_start->len > 0 &&\n\t\t    m_start->len < AT91_I2C_MAX_ALT_CMD_DATA_SIZE) {\n\t\t\tat91_twi_write(dev, AT91_TWI_CR, AT91_TWI_ACMEN);\n\t\t\tat91_twi_write(dev, AT91_TWI_ACR,\n\t\t\t\t       AT91_TWI_ACR_DATAL(m_start->len) |\n\t\t\t\t       ((is_read) ? AT91_TWI_ACR_DIR : 0));\n\t\t\tdev->use_alt_cmd = true;\n\t\t} else {\n\t\t\tat91_twi_write(dev, AT91_TWI_CR, AT91_TWI_ACMDIS);\n\t\t}\n\t}\n\n\tat91_twi_write(dev, AT91_TWI_MMR,\n\t\t       (m_start->addr << 16) |\n\t\t       int_addr_flag |\n\t\t       ((!dev->use_alt_cmd && is_read) ? AT91_TWI_MREAD : 0));\n\n\tdev->buf_len = m_start->len;\n\tdev->buf = m_start->buf;\n\tdev->msg = m_start;\n\tdev->recv_len_abort = false;\n\n\tif (dev->use_dma) {\n\t\tdma_buf = i2c_get_dma_safe_msg_buf(m_start, 1);\n\t\tif (!dma_buf) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tdev->buf = dma_buf;\n\t}\n\n\tret = at91_do_twi_transfer(dev);\n\ti2c_put_dma_safe_msg_buf(dma_buf, m_start, !ret);\n\n\tret = (ret < 0) ? ret : num;\nout:\n\tpm_runtime_mark_last_busy(dev->dev);\n\tpm_runtime_put_autosuspend(dev->dev);\n\n\treturn ret;\n}\n\n \nstatic const struct i2c_adapter_quirks at91_twi_quirks = {\n\t.flags = I2C_AQ_COMB | I2C_AQ_COMB_WRITE_FIRST | I2C_AQ_COMB_SAME_ADDR,\n\t.max_comb_1st_msg_len = 3,\n};\n\nstatic u32 at91_twi_func(struct i2c_adapter *adapter)\n{\n\treturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL\n\t\t| I2C_FUNC_SMBUS_READ_BLOCK_DATA;\n}\n\nstatic const struct i2c_algorithm at91_twi_algorithm = {\n\t.master_xfer\t= at91_twi_xfer,\n\t.functionality\t= at91_twi_func,\n};\n\nstatic int at91_twi_configure_dma(struct at91_twi_dev *dev, u32 phy_addr)\n{\n\tint ret = 0;\n\tstruct dma_slave_config slave_config;\n\tstruct at91_twi_dma *dma = &dev->dma;\n\tenum dma_slave_buswidth addr_width = DMA_SLAVE_BUSWIDTH_1_BYTE;\n\n\t \n\tif (dev->fifo_size)\n\t\taddr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\n\n\tmemset(&slave_config, 0, sizeof(slave_config));\n\tslave_config.src_addr = (dma_addr_t)phy_addr + AT91_TWI_RHR;\n\tslave_config.src_addr_width = addr_width;\n\tslave_config.src_maxburst = 1;\n\tslave_config.dst_addr = (dma_addr_t)phy_addr + AT91_TWI_THR;\n\tslave_config.dst_addr_width = addr_width;\n\tslave_config.dst_maxburst = 1;\n\tslave_config.device_fc = false;\n\n\tdma->chan_tx = dma_request_chan(dev->dev, \"tx\");\n\tif (IS_ERR(dma->chan_tx)) {\n\t\tret = PTR_ERR(dma->chan_tx);\n\t\tdma->chan_tx = NULL;\n\t\tgoto error;\n\t}\n\n\tdma->chan_rx = dma_request_chan(dev->dev, \"rx\");\n\tif (IS_ERR(dma->chan_rx)) {\n\t\tret = PTR_ERR(dma->chan_rx);\n\t\tdma->chan_rx = NULL;\n\t\tgoto error;\n\t}\n\n\tslave_config.direction = DMA_MEM_TO_DEV;\n\tif (dmaengine_slave_config(dma->chan_tx, &slave_config)) {\n\t\tdev_err(dev->dev, \"failed to configure tx channel\\n\");\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\n\tslave_config.direction = DMA_DEV_TO_MEM;\n\tif (dmaengine_slave_config(dma->chan_rx, &slave_config)) {\n\t\tdev_err(dev->dev, \"failed to configure rx channel\\n\");\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\n\tsg_init_table(dma->sg, 2);\n\tdma->buf_mapped = false;\n\tdma->xfer_in_progress = false;\n\tdev->use_dma = true;\n\n\tdev_info(dev->dev, \"using %s (tx) and %s (rx) for DMA transfers\\n\",\n\t\t dma_chan_name(dma->chan_tx), dma_chan_name(dma->chan_rx));\n\n\treturn ret;\n\nerror:\n\tif (ret != -EPROBE_DEFER)\n\t\tdev_info(dev->dev, \"can't get DMA channel, continue without DMA support\\n\");\n\tif (dma->chan_rx)\n\t\tdma_release_channel(dma->chan_rx);\n\tif (dma->chan_tx)\n\t\tdma_release_channel(dma->chan_tx);\n\treturn ret;\n}\n\nstatic int at91_init_twi_recovery_gpio(struct platform_device *pdev,\n\t\t\t\t       struct at91_twi_dev *dev)\n{\n\tstruct i2c_bus_recovery_info *rinfo = &dev->rinfo;\n\n\trinfo->pinctrl = devm_pinctrl_get(&pdev->dev);\n\tif (!rinfo->pinctrl) {\n\t\tdev_info(dev->dev, \"pinctrl unavailable, bus recovery not supported\\n\");\n\t\treturn 0;\n\t}\n\tif (IS_ERR(rinfo->pinctrl)) {\n\t\tdev_info(dev->dev, \"can't get pinctrl, bus recovery not supported\\n\");\n\t\treturn PTR_ERR(rinfo->pinctrl);\n\t}\n\tdev->adapter.bus_recovery_info = rinfo;\n\n\treturn 0;\n}\n\nstatic int at91_twi_recover_bus_cmd(struct i2c_adapter *adap)\n{\n\tstruct at91_twi_dev *dev = i2c_get_adapdata(adap);\n\n\tdev->transfer_status |= at91_twi_read(dev, AT91_TWI_SR);\n\tif (!(dev->transfer_status & AT91_TWI_SDA)) {\n\t\tdev_dbg(dev->dev, \"SDA is down; sending bus clear command\\n\");\n\t\tif (dev->use_alt_cmd) {\n\t\t\tunsigned int acr;\n\n\t\t\tacr = at91_twi_read(dev, AT91_TWI_ACR);\n\t\t\tacr &= ~AT91_TWI_ACR_DATAL_MASK;\n\t\t\tat91_twi_write(dev, AT91_TWI_ACR, acr);\n\t\t}\n\t\tat91_twi_write(dev, AT91_TWI_CR, AT91_TWI_CLEAR);\n\t}\n\n\treturn 0;\n}\n\nstatic int at91_init_twi_recovery_info(struct platform_device *pdev,\n\t\t\t\t       struct at91_twi_dev *dev)\n{\n\tstruct i2c_bus_recovery_info *rinfo = &dev->rinfo;\n\tbool has_clear_cmd = dev->pdata->has_clear_cmd;\n\n\tif (!has_clear_cmd)\n\t\treturn at91_init_twi_recovery_gpio(pdev, dev);\n\n\trinfo->recover_bus = at91_twi_recover_bus_cmd;\n\tdev->adapter.bus_recovery_info = rinfo;\n\n\treturn 0;\n}\n\nint at91_twi_probe_master(struct platform_device *pdev,\n\t\t\t  u32 phy_addr, struct at91_twi_dev *dev)\n{\n\tint rc;\n\n\tinit_completion(&dev->cmd_complete);\n\n\trc = devm_request_irq(&pdev->dev, dev->irq, atmel_twi_interrupt, 0,\n\t\t\t      dev_name(dev->dev), dev);\n\tif (rc) {\n\t\tdev_err(dev->dev, \"Cannot get irq %d: %d\\n\", dev->irq, rc);\n\t\treturn rc;\n\t}\n\n\tif (dev->dev->of_node) {\n\t\trc = at91_twi_configure_dma(dev, phy_addr);\n\t\tif (rc == -EPROBE_DEFER)\n\t\t\treturn rc;\n\t}\n\n\tif (!of_property_read_u32(pdev->dev.of_node, \"atmel,fifo-size\",\n\t\t\t\t  &dev->fifo_size)) {\n\t\tdev_info(dev->dev, \"Using FIFO (%u data)\\n\", dev->fifo_size);\n\t}\n\n\tdev->enable_dig_filt = of_property_read_bool(pdev->dev.of_node,\n\t\t\t\t\t\t     \"i2c-digital-filter\");\n\n\tdev->enable_ana_filt = of_property_read_bool(pdev->dev.of_node,\n\t\t\t\t\t\t     \"i2c-analog-filter\");\n\tat91_calc_twi_clock(dev);\n\n\trc = at91_init_twi_recovery_info(pdev, dev);\n\tif (rc == -EPROBE_DEFER)\n\t\treturn rc;\n\n\tdev->adapter.algo = &at91_twi_algorithm;\n\tdev->adapter.quirks = &at91_twi_quirks;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}