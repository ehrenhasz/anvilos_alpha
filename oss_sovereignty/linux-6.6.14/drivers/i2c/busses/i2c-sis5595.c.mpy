{
  "module_name": "i2c-sis5595.c",
  "hash_id": "4e5a9f429648cc327518debf426100339dc6f8f8aeb4325a42c93787f19e7b60",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-sis5595.c",
  "human_readable_source": "\n \n\n \n\n \n\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/pci.h>\n#include <linux/ioport.h>\n#include <linux/init.h>\n#include <linux/i2c.h>\n#include <linux/acpi.h>\n#include <linux/io.h>\n\nstatic int blacklist[] = {\n\tPCI_DEVICE_ID_SI_540,\n\tPCI_DEVICE_ID_SI_550,\n\tPCI_DEVICE_ID_SI_630,\n\tPCI_DEVICE_ID_SI_645,\n\tPCI_DEVICE_ID_SI_646,\n\tPCI_DEVICE_ID_SI_648,\n\tPCI_DEVICE_ID_SI_650,\n\tPCI_DEVICE_ID_SI_651,\n\tPCI_DEVICE_ID_SI_730,\n\tPCI_DEVICE_ID_SI_735,\n\tPCI_DEVICE_ID_SI_745,\n\tPCI_DEVICE_ID_SI_746,\n\tPCI_DEVICE_ID_SI_5511,\t \n\tPCI_DEVICE_ID_SI_5597,\n\tPCI_DEVICE_ID_SI_5598,\n\t0,\t\t\t \n};\n\n \n#define SIS5595_EXTENT\t\t8\n \n#define SMB_STS_LO\t\t0x00\n#define SMB_STS_HI\t\t0x01\n#define SMB_CTL_LO\t\t0x02\n#define SMB_CTL_HI\t\t0x03\n#define SMB_ADDR\t\t0x04\n#define SMB_CMD\t\t\t0x05\n#define SMB_PCNT\t\t0x06\n#define SMB_CNT\t\t\t0x07\n#define SMB_BYTE\t\t0x08\n#define SMB_DEV\t\t\t0x10\n#define SMB_DB0\t\t\t0x11\n#define SMB_DB1\t\t\t0x12\n#define SMB_HAA\t\t\t0x13\n\n \n#define SMB_INDEX\t\t0x38\n#define SMB_DAT\t\t\t0x39\n#define SIS5595_ENABLE_REG\t0x40\n#define ACPI_BASE\t\t0x90\n\n \n#define MAX_TIMEOUT\t\t500\n\n \n#define SIS5595_QUICK\t\t0x00\n#define SIS5595_BYTE\t\t0x02\n#define SIS5595_BYTE_DATA\t0x04\n#define SIS5595_WORD_DATA\t0x06\n#define SIS5595_PROC_CALL\t0x08\n#define SIS5595_BLOCK_DATA\t0x0A\n\n \n\n \nstatic u16 force_addr;\nmodule_param_hw(force_addr, ushort, ioport, 0);\nMODULE_PARM_DESC(force_addr, \"Initialize the base address of the i2c controller\");\n\nstatic struct pci_driver sis5595_driver;\nstatic unsigned short sis5595_base;\nstatic struct pci_dev *sis5595_pdev;\n\nstatic u8 sis5595_read(u8 reg)\n{\n\toutb(reg, sis5595_base + SMB_INDEX);\n\treturn inb(sis5595_base + SMB_DAT);\n}\n\nstatic void sis5595_write(u8 reg, u8 data)\n{\n\toutb(reg, sis5595_base + SMB_INDEX);\n\toutb(data, sis5595_base + SMB_DAT);\n}\n\nstatic int sis5595_setup(struct pci_dev *SIS5595_dev)\n{\n\tu16 a;\n\tu8 val;\n\tint *i;\n\tint retval;\n\n\t \n\tfor (i = blacklist; *i != 0; i++) {\n\t\tstruct pci_dev *dev;\n\t\tdev = pci_get_device(PCI_VENDOR_ID_SI, *i, NULL);\n\t\tif (dev) {\n\t\t\tdev_err(&SIS5595_dev->dev, \"Looked for SIS5595 but found unsupported device %.4x\\n\", *i);\n\t\t\tpci_dev_put(dev);\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\t \n\tpci_read_config_word(SIS5595_dev, ACPI_BASE, &sis5595_base);\n\tif (sis5595_base == 0 && force_addr == 0) {\n\t\tdev_err(&SIS5595_dev->dev, \"ACPI base address uninitialized - upgrade BIOS or use force_addr=0xaddr\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (force_addr)\n\t\tsis5595_base = force_addr & ~(SIS5595_EXTENT - 1);\n\tdev_dbg(&SIS5595_dev->dev, \"ACPI Base address: %04x\\n\", sis5595_base);\n\n\t \n\tretval = acpi_check_region(sis5595_base + SMB_INDEX, 2,\n\t\t\t\t   sis5595_driver.name);\n\tif (retval)\n\t\treturn retval;\n\n\tif (!request_region(sis5595_base + SMB_INDEX, 2,\n\t\t\t    sis5595_driver.name)) {\n\t\tdev_err(&SIS5595_dev->dev, \"SMBus registers 0x%04x-0x%04x already in use!\\n\",\n\t\t\tsis5595_base + SMB_INDEX, sis5595_base + SMB_INDEX + 1);\n\t\treturn -ENODEV;\n\t}\n\n\tif (force_addr) {\n\t\tdev_info(&SIS5595_dev->dev, \"forcing ISA address 0x%04X\\n\", sis5595_base);\n\t\tretval = pci_write_config_word(SIS5595_dev, ACPI_BASE, sis5595_base);\n\t\tif (retval != PCIBIOS_SUCCESSFUL)\n\t\t\tgoto error;\n\t\tretval = pci_read_config_word(SIS5595_dev, ACPI_BASE, &a);\n\t\tif (retval != PCIBIOS_SUCCESSFUL)\n\t\t\tgoto error;\n\t\tif ((a & ~(SIS5595_EXTENT - 1)) != sis5595_base) {\n\t\t\t \n\t\t\tdev_err(&SIS5595_dev->dev, \"force address failed - not supported?\\n\");\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tretval = pci_read_config_byte(SIS5595_dev, SIS5595_ENABLE_REG, &val);\n\tif (retval != PCIBIOS_SUCCESSFUL)\n\t\tgoto error;\n\tif ((val & 0x80) == 0) {\n\t\tdev_info(&SIS5595_dev->dev, \"enabling ACPI\\n\");\n\t\tretval = pci_write_config_byte(SIS5595_dev, SIS5595_ENABLE_REG, val | 0x80);\n\t\tif (retval != PCIBIOS_SUCCESSFUL)\n\t\t\tgoto error;\n\t\tretval = pci_read_config_byte(SIS5595_dev, SIS5595_ENABLE_REG, &val);\n\t\tif (retval != PCIBIOS_SUCCESSFUL)\n\t\t\tgoto error;\n\t\tif ((val & 0x80) == 0) {\n\t\t\t \n\t\t\tdev_err(&SIS5595_dev->dev, \"ACPI enable failed - not supported?\\n\");\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\t \n\treturn 0;\n\nerror:\n\trelease_region(sis5595_base + SMB_INDEX, 2);\n\treturn -ENODEV;\n}\n\nstatic int sis5595_transaction(struct i2c_adapter *adap)\n{\n\tint temp;\n\tint result = 0;\n\tint timeout = 0;\n\n\t \n\ttemp = sis5595_read(SMB_STS_LO) + (sis5595_read(SMB_STS_HI) << 8);\n\tif (temp != 0x00) {\n\t\tdev_dbg(&adap->dev, \"SMBus busy (%04x). Resetting...\\n\", temp);\n\t\tsis5595_write(SMB_STS_LO, temp & 0xff);\n\t\tsis5595_write(SMB_STS_HI, temp >> 8);\n\t\tif ((temp = sis5595_read(SMB_STS_LO) + (sis5595_read(SMB_STS_HI) << 8)) != 0x00) {\n\t\t\tdev_dbg(&adap->dev, \"Failed! (%02x)\\n\", temp);\n\t\t\treturn -EBUSY;\n\t\t} else {\n\t\t\tdev_dbg(&adap->dev, \"Successful!\\n\");\n\t\t}\n\t}\n\n\t \n\tsis5595_write(SMB_CTL_LO, sis5595_read(SMB_CTL_LO) | 0x10);\n\n\t \n\tdo {\n\t\tmsleep(1);\n\t\ttemp = sis5595_read(SMB_STS_LO);\n\t} while (!(temp & 0x40) && (timeout++ < MAX_TIMEOUT));\n\n\t \n\tif (timeout > MAX_TIMEOUT) {\n\t\tdev_dbg(&adap->dev, \"SMBus Timeout!\\n\");\n\t\tresult = -ETIMEDOUT;\n\t}\n\n\tif (temp & 0x10) {\n\t\tdev_dbg(&adap->dev, \"Error: Failed bus transaction\\n\");\n\t\tresult = -ENXIO;\n\t}\n\n\tif (temp & 0x20) {\n\t\tdev_err(&adap->dev, \"Bus collision! SMBus may be locked until \"\n\t\t\t\"next hard reset (or not...)\\n\");\n\t\t \n\t\tresult = -EIO;\n\t}\n\n\ttemp = sis5595_read(SMB_STS_LO) + (sis5595_read(SMB_STS_HI) << 8);\n\tif (temp != 0x00) {\n\t\tsis5595_write(SMB_STS_LO, temp & 0xff);\n\t\tsis5595_write(SMB_STS_HI, temp >> 8);\n\t}\n\n\ttemp = sis5595_read(SMB_STS_LO) + (sis5595_read(SMB_STS_HI) << 8);\n\tif (temp != 0x00)\n\t\tdev_dbg(&adap->dev, \"Failed reset at end of transaction (%02x)\\n\", temp);\n\n\treturn result;\n}\n\n \nstatic s32 sis5595_access(struct i2c_adapter *adap, u16 addr,\n\t\t\t  unsigned short flags, char read_write,\n\t\t\t  u8 command, int size, union i2c_smbus_data *data)\n{\n\tint status;\n\n\tswitch (size) {\n\tcase I2C_SMBUS_QUICK:\n\t\tsis5595_write(SMB_ADDR, ((addr & 0x7f) << 1) | (read_write & 0x01));\n\t\tsize = SIS5595_QUICK;\n\t\tbreak;\n\tcase I2C_SMBUS_BYTE:\n\t\tsis5595_write(SMB_ADDR, ((addr & 0x7f) << 1) | (read_write & 0x01));\n\t\tif (read_write == I2C_SMBUS_WRITE)\n\t\t\tsis5595_write(SMB_CMD, command);\n\t\tsize = SIS5595_BYTE;\n\t\tbreak;\n\tcase I2C_SMBUS_BYTE_DATA:\n\t\tsis5595_write(SMB_ADDR, ((addr & 0x7f) << 1) | (read_write & 0x01));\n\t\tsis5595_write(SMB_CMD, command);\n\t\tif (read_write == I2C_SMBUS_WRITE)\n\t\t\tsis5595_write(SMB_BYTE, data->byte);\n\t\tsize = SIS5595_BYTE_DATA;\n\t\tbreak;\n\tcase I2C_SMBUS_PROC_CALL:\n\tcase I2C_SMBUS_WORD_DATA:\n\t\tsis5595_write(SMB_ADDR, ((addr & 0x7f) << 1) | (read_write & 0x01));\n\t\tsis5595_write(SMB_CMD, command);\n\t\tif (read_write == I2C_SMBUS_WRITE) {\n\t\t\tsis5595_write(SMB_BYTE, data->word & 0xff);\n\t\t\tsis5595_write(SMB_BYTE + 1,\n\t\t\t\t      (data->word & 0xff00) >> 8);\n\t\t}\n\t\tsize = (size == I2C_SMBUS_PROC_CALL) ? SIS5595_PROC_CALL : SIS5595_WORD_DATA;\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(&adap->dev, \"Unsupported transaction %d\\n\", size);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tsis5595_write(SMB_CTL_LO, ((size & 0x0E)));\n\n\tstatus = sis5595_transaction(adap);\n\tif (status)\n\t\treturn status;\n\n\tif ((size != SIS5595_PROC_CALL) &&\n\t    ((read_write == I2C_SMBUS_WRITE) || (size == SIS5595_QUICK)))\n\t\treturn 0;\n\n\n\tswitch (size) {\n\tcase SIS5595_BYTE:\n\tcase SIS5595_BYTE_DATA:\n\t\tdata->byte = sis5595_read(SMB_BYTE);\n\t\tbreak;\n\tcase SIS5595_WORD_DATA:\n\tcase SIS5595_PROC_CALL:\n\t\tdata->word = sis5595_read(SMB_BYTE) + (sis5595_read(SMB_BYTE + 1) << 8);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic u32 sis5595_func(struct i2c_adapter *adapter)\n{\n\treturn I2C_FUNC_SMBUS_QUICK | I2C_FUNC_SMBUS_BYTE |\n\t    I2C_FUNC_SMBUS_BYTE_DATA | I2C_FUNC_SMBUS_WORD_DATA |\n\t    I2C_FUNC_SMBUS_PROC_CALL;\n}\n\nstatic const struct i2c_algorithm smbus_algorithm = {\n\t.smbus_xfer\t= sis5595_access,\n\t.functionality\t= sis5595_func,\n};\n\nstatic struct i2c_adapter sis5595_adapter = {\n\t.owner\t\t= THIS_MODULE,\n\t.class          = I2C_CLASS_HWMON | I2C_CLASS_SPD,\n\t.algo\t\t= &smbus_algorithm,\n};\n\nstatic const struct pci_device_id sis5595_ids[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_SI, PCI_DEVICE_ID_SI_503) }, \n\t{ 0, }\n};\n\nMODULE_DEVICE_TABLE (pci, sis5595_ids);\n\nstatic int sis5595_probe(struct pci_dev *dev, const struct pci_device_id *id)\n{\n\tint err;\n\n\tif (sis5595_setup(dev)) {\n\t\tdev_err(&dev->dev, \"SIS5595 not detected, module not inserted.\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tsis5595_adapter.dev.parent = &dev->dev;\n\n\tsnprintf(sis5595_adapter.name, sizeof(sis5595_adapter.name),\n\t\t \"SMBus SIS5595 adapter at %04x\", sis5595_base + SMB_INDEX);\n\terr = i2c_add_adapter(&sis5595_adapter);\n\tif (err) {\n\t\trelease_region(sis5595_base + SMB_INDEX, 2);\n\t\treturn err;\n\t}\n\n\t \n\tsis5595_pdev =  pci_dev_get(dev);\n\treturn -ENODEV;\n}\n\nstatic struct pci_driver sis5595_driver = {\n\t.name\t\t= \"sis5595_smbus\",\n\t.id_table\t= sis5595_ids,\n\t.probe\t\t= sis5595_probe,\n};\n\nstatic int __init i2c_sis5595_init(void)\n{\n\treturn pci_register_driver(&sis5595_driver);\n}\n\nstatic void __exit i2c_sis5595_exit(void)\n{\n\tpci_unregister_driver(&sis5595_driver);\n\tif (sis5595_pdev) {\n\t\ti2c_del_adapter(&sis5595_adapter);\n\t\trelease_region(sis5595_base + SMB_INDEX, 2);\n\t\tpci_dev_put(sis5595_pdev);\n\t\tsis5595_pdev = NULL;\n\t}\n}\n\nMODULE_AUTHOR(\"Frodo Looijaard <frodol@dds.nl>\");\nMODULE_DESCRIPTION(\"SIS5595 SMBus driver\");\nMODULE_LICENSE(\"GPL\");\n\nmodule_init(i2c_sis5595_init);\nmodule_exit(i2c_sis5595_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}