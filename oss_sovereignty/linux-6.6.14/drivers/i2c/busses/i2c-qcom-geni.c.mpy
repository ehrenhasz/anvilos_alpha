{
  "module_name": "i2c-qcom-geni.c",
  "hash_id": "ef5df5b95d0620f3b9303d62a3012a347619f04f5ede822fbd4eaac36cd3f50f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-qcom-geni.c",
  "human_readable_source": "\n\n\n#include <linux/acpi.h>\n#include <linux/clk.h>\n#include <linux/dmaengine.h>\n#include <linux/dma-mapping.h>\n#include <linux/dma/qcom-gpi-dma.h>\n#include <linux/err.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/soc/qcom/geni-se.h>\n#include <linux/spinlock.h>\n\n#define SE_I2C_TX_TRANS_LEN\t\t0x26c\n#define SE_I2C_RX_TRANS_LEN\t\t0x270\n#define SE_I2C_SCL_COUNTERS\t\t0x278\n\n#define SE_I2C_ERR  (M_CMD_OVERRUN_EN | M_ILLEGAL_CMD_EN | M_CMD_FAILURE_EN |\\\n\t\t\tM_GP_IRQ_1_EN | M_GP_IRQ_3_EN | M_GP_IRQ_4_EN)\n#define SE_I2C_ABORT\t\tBIT(1)\n\n \n#define I2C_WRITE\t\t0x1\n#define I2C_READ\t\t0x2\n#define I2C_WRITE_READ\t\t0x3\n#define I2C_ADDR_ONLY\t\t0x4\n#define I2C_BUS_CLEAR\t\t0x6\n#define I2C_STOP_ON_BUS\t\t0x7\n \n#define PRE_CMD_DELAY\t\tBIT(0)\n#define TIMESTAMP_BEFORE\tBIT(1)\n#define STOP_STRETCH\t\tBIT(2)\n#define TIMESTAMP_AFTER\t\tBIT(3)\n#define POST_COMMAND_DELAY\tBIT(4)\n#define IGNORE_ADD_NACK\t\tBIT(6)\n#define READ_FINISHED_WITH_ACK\tBIT(7)\n#define BYPASS_ADDR_PHASE\tBIT(8)\n#define SLV_ADDR_MSK\t\tGENMASK(15, 9)\n#define SLV_ADDR_SHFT\t\t9\n \n#define HIGH_COUNTER_MSK\tGENMASK(29, 20)\n#define HIGH_COUNTER_SHFT\t20\n#define LOW_COUNTER_MSK\t\tGENMASK(19, 10)\n#define LOW_COUNTER_SHFT\t10\n#define CYCLE_COUNTER_MSK\tGENMASK(9, 0)\n\n#define I2C_PACK_TX\t\tBIT(0)\n#define I2C_PACK_RX\t\tBIT(1)\n\nenum geni_i2c_err_code {\n\tGP_IRQ0,\n\tNACK,\n\tGP_IRQ2,\n\tBUS_PROTO,\n\tARB_LOST,\n\tGP_IRQ5,\n\tGENI_OVERRUN,\n\tGENI_ILLEGAL_CMD,\n\tGENI_ABORT_DONE,\n\tGENI_TIMEOUT,\n};\n\n#define DM_I2C_CB_ERR\t\t((BIT(NACK) | BIT(BUS_PROTO) | BIT(ARB_LOST)) \\\n\t\t\t\t\t\t\t\t\t<< 5)\n\n#define I2C_AUTO_SUSPEND_DELAY\t250\n#define KHZ(freq)\t\t(1000 * freq)\n#define PACKING_BYTES_PW\t4\n\n#define ABORT_TIMEOUT\t\tHZ\n#define XFER_TIMEOUT\t\tHZ\n#define RST_TIMEOUT\t\tHZ\n\nstruct geni_i2c_dev {\n\tstruct geni_se se;\n\tu32 tx_wm;\n\tint irq;\n\tint err;\n\tstruct i2c_adapter adap;\n\tstruct completion done;\n\tstruct i2c_msg *cur;\n\tint cur_wr;\n\tint cur_rd;\n\tspinlock_t lock;\n\tstruct clk *core_clk;\n\tu32 clk_freq_out;\n\tconst struct geni_i2c_clk_fld *clk_fld;\n\tint suspended;\n\tvoid *dma_buf;\n\tsize_t xfer_len;\n\tdma_addr_t dma_addr;\n\tstruct dma_chan *tx_c;\n\tstruct dma_chan *rx_c;\n\tbool gpi_mode;\n\tbool abort_done;\n};\n\nstruct geni_i2c_desc {\n\tbool has_core_clk;\n\tchar *icc_ddr;\n\tbool no_dma_support;\n\tunsigned int tx_fifo_depth;\n};\n\nstruct geni_i2c_err_log {\n\tint err;\n\tconst char *msg;\n};\n\nstatic const struct geni_i2c_err_log gi2c_log[] = {\n\t[GP_IRQ0] = {-EIO, \"Unknown I2C err GP_IRQ0\"},\n\t[NACK] = {-ENXIO, \"NACK: slv unresponsive, check its power/reset-ln\"},\n\t[GP_IRQ2] = {-EIO, \"Unknown I2C err GP IRQ2\"},\n\t[BUS_PROTO] = {-EPROTO, \"Bus proto err, noisy/unexpected start/stop\"},\n\t[ARB_LOST] = {-EAGAIN, \"Bus arbitration lost, clock line undriveable\"},\n\t[GP_IRQ5] = {-EIO, \"Unknown I2C err GP IRQ5\"},\n\t[GENI_OVERRUN] = {-EIO, \"Cmd overrun, check GENI cmd-state machine\"},\n\t[GENI_ILLEGAL_CMD] = {-EIO, \"Illegal cmd, check GENI cmd-state machine\"},\n\t[GENI_ABORT_DONE] = {-ETIMEDOUT, \"Abort after timeout successful\"},\n\t[GENI_TIMEOUT] = {-ETIMEDOUT, \"I2C TXN timed out\"},\n};\n\nstruct geni_i2c_clk_fld {\n\tu32\tclk_freq_out;\n\tu8\tclk_div;\n\tu8\tt_high_cnt;\n\tu8\tt_low_cnt;\n\tu8\tt_cycle_cnt;\n};\n\n \nstatic const struct geni_i2c_clk_fld geni_i2c_clk_map[] = {\n\t{KHZ(100), 7, 10, 11, 26},\n\t{KHZ(400), 2,  5, 12, 24},\n\t{KHZ(1000), 1, 3,  9, 18},\n};\n\nstatic int geni_i2c_clk_map_idx(struct geni_i2c_dev *gi2c)\n{\n\tint i;\n\tconst struct geni_i2c_clk_fld *itr = geni_i2c_clk_map;\n\n\tfor (i = 0; i < ARRAY_SIZE(geni_i2c_clk_map); i++, itr++) {\n\t\tif (itr->clk_freq_out == gi2c->clk_freq_out) {\n\t\t\tgi2c->clk_fld = itr;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -EINVAL;\n}\n\nstatic void qcom_geni_i2c_conf(struct geni_i2c_dev *gi2c)\n{\n\tconst struct geni_i2c_clk_fld *itr = gi2c->clk_fld;\n\tu32 val;\n\n\twritel_relaxed(0, gi2c->se.base + SE_GENI_CLK_SEL);\n\n\tval = (itr->clk_div << CLK_DIV_SHFT) | SER_CLK_EN;\n\twritel_relaxed(val, gi2c->se.base + GENI_SER_M_CLK_CFG);\n\n\tval = itr->t_high_cnt << HIGH_COUNTER_SHFT;\n\tval |= itr->t_low_cnt << LOW_COUNTER_SHFT;\n\tval |= itr->t_cycle_cnt;\n\twritel_relaxed(val, gi2c->se.base + SE_I2C_SCL_COUNTERS);\n}\n\nstatic void geni_i2c_err_misc(struct geni_i2c_dev *gi2c)\n{\n\tu32 m_cmd = readl_relaxed(gi2c->se.base + SE_GENI_M_CMD0);\n\tu32 m_stat = readl_relaxed(gi2c->se.base + SE_GENI_M_IRQ_STATUS);\n\tu32 geni_s = readl_relaxed(gi2c->se.base + SE_GENI_STATUS);\n\tu32 geni_ios = readl_relaxed(gi2c->se.base + SE_GENI_IOS);\n\tu32 dma = readl_relaxed(gi2c->se.base + SE_GENI_DMA_MODE_EN);\n\tu32 rx_st, tx_st;\n\n\tif (dma) {\n\t\trx_st = readl_relaxed(gi2c->se.base + SE_DMA_RX_IRQ_STAT);\n\t\ttx_st = readl_relaxed(gi2c->se.base + SE_DMA_TX_IRQ_STAT);\n\t} else {\n\t\trx_st = readl_relaxed(gi2c->se.base + SE_GENI_RX_FIFO_STATUS);\n\t\ttx_st = readl_relaxed(gi2c->se.base + SE_GENI_TX_FIFO_STATUS);\n\t}\n\tdev_dbg(gi2c->se.dev, \"DMA:%d tx_stat:0x%x, rx_stat:0x%x, irq-stat:0x%x\\n\",\n\t\tdma, tx_st, rx_st, m_stat);\n\tdev_dbg(gi2c->se.dev, \"m_cmd:0x%x, geni_status:0x%x, geni_ios:0x%x\\n\",\n\t\tm_cmd, geni_s, geni_ios);\n}\n\nstatic void geni_i2c_err(struct geni_i2c_dev *gi2c, int err)\n{\n\tif (!gi2c->err)\n\t\tgi2c->err = gi2c_log[err].err;\n\tif (gi2c->cur)\n\t\tdev_dbg(gi2c->se.dev, \"len:%d, slv-addr:0x%x, RD/WR:%d\\n\",\n\t\t\tgi2c->cur->len, gi2c->cur->addr, gi2c->cur->flags);\n\n\tswitch (err) {\n\tcase GENI_ABORT_DONE:\n\t\tgi2c->abort_done = true;\n\t\tbreak;\n\tcase NACK:\n\tcase GENI_TIMEOUT:\n\t\tdev_dbg(gi2c->se.dev, \"%s\\n\", gi2c_log[err].msg);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(gi2c->se.dev, \"%s\\n\", gi2c_log[err].msg);\n\t\tgeni_i2c_err_misc(gi2c);\n\t\tbreak;\n\t}\n}\n\nstatic irqreturn_t geni_i2c_irq(int irq, void *dev)\n{\n\tstruct geni_i2c_dev *gi2c = dev;\n\tvoid __iomem *base = gi2c->se.base;\n\tint j, p;\n\tu32 m_stat;\n\tu32 rx_st;\n\tu32 dm_tx_st;\n\tu32 dm_rx_st;\n\tu32 dma;\n\tu32 val;\n\tstruct i2c_msg *cur;\n\n\tspin_lock(&gi2c->lock);\n\tm_stat = readl_relaxed(base + SE_GENI_M_IRQ_STATUS);\n\trx_st = readl_relaxed(base + SE_GENI_RX_FIFO_STATUS);\n\tdm_tx_st = readl_relaxed(base + SE_DMA_TX_IRQ_STAT);\n\tdm_rx_st = readl_relaxed(base + SE_DMA_RX_IRQ_STAT);\n\tdma = readl_relaxed(base + SE_GENI_DMA_MODE_EN);\n\tcur = gi2c->cur;\n\n\tif (!cur ||\n\t    m_stat & (M_CMD_FAILURE_EN | M_CMD_ABORT_EN) ||\n\t    dm_rx_st & (DM_I2C_CB_ERR)) {\n\t\tif (m_stat & M_GP_IRQ_1_EN)\n\t\t\tgeni_i2c_err(gi2c, NACK);\n\t\tif (m_stat & M_GP_IRQ_3_EN)\n\t\t\tgeni_i2c_err(gi2c, BUS_PROTO);\n\t\tif (m_stat & M_GP_IRQ_4_EN)\n\t\t\tgeni_i2c_err(gi2c, ARB_LOST);\n\t\tif (m_stat & M_CMD_OVERRUN_EN)\n\t\t\tgeni_i2c_err(gi2c, GENI_OVERRUN);\n\t\tif (m_stat & M_ILLEGAL_CMD_EN)\n\t\t\tgeni_i2c_err(gi2c, GENI_ILLEGAL_CMD);\n\t\tif (m_stat & M_CMD_ABORT_EN)\n\t\t\tgeni_i2c_err(gi2c, GENI_ABORT_DONE);\n\t\tif (m_stat & M_GP_IRQ_0_EN)\n\t\t\tgeni_i2c_err(gi2c, GP_IRQ0);\n\n\t\t \n\t\tif (!dma)\n\t\t\twritel_relaxed(0, base + SE_GENI_TX_WATERMARK_REG);\n\t} else if (dma) {\n\t\tdev_dbg(gi2c->se.dev, \"i2c dma tx:0x%x, dma rx:0x%x\\n\",\n\t\t\tdm_tx_st, dm_rx_st);\n\t} else if (cur->flags & I2C_M_RD &&\n\t\t   m_stat & (M_RX_FIFO_WATERMARK_EN | M_RX_FIFO_LAST_EN)) {\n\t\tu32 rxcnt = rx_st & RX_FIFO_WC_MSK;\n\n\t\tfor (j = 0; j < rxcnt; j++) {\n\t\t\tp = 0;\n\t\t\tval = readl_relaxed(base + SE_GENI_RX_FIFOn);\n\t\t\twhile (gi2c->cur_rd < cur->len && p < sizeof(val)) {\n\t\t\t\tcur->buf[gi2c->cur_rd++] = val & 0xff;\n\t\t\t\tval >>= 8;\n\t\t\t\tp++;\n\t\t\t}\n\t\t\tif (gi2c->cur_rd == cur->len)\n\t\t\t\tbreak;\n\t\t}\n\t} else if (!(cur->flags & I2C_M_RD) &&\n\t\t   m_stat & M_TX_FIFO_WATERMARK_EN) {\n\t\tfor (j = 0; j < gi2c->tx_wm; j++) {\n\t\t\tu32 temp;\n\n\t\t\tval = 0;\n\t\t\tp = 0;\n\t\t\twhile (gi2c->cur_wr < cur->len && p < sizeof(val)) {\n\t\t\t\ttemp = cur->buf[gi2c->cur_wr++];\n\t\t\t\tval |= temp << (p * 8);\n\t\t\t\tp++;\n\t\t\t}\n\t\t\twritel_relaxed(val, base + SE_GENI_TX_FIFOn);\n\t\t\t \n\t\t\tif (gi2c->cur_wr == cur->len) {\n\t\t\t\twritel_relaxed(0, base + SE_GENI_TX_WATERMARK_REG);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (m_stat)\n\t\twritel_relaxed(m_stat, base + SE_GENI_M_IRQ_CLEAR);\n\n\tif (dma && dm_tx_st)\n\t\twritel_relaxed(dm_tx_st, base + SE_DMA_TX_IRQ_CLR);\n\tif (dma && dm_rx_st)\n\t\twritel_relaxed(dm_rx_st, base + SE_DMA_RX_IRQ_CLR);\n\n\t \n\tif (m_stat & M_CMD_DONE_EN || m_stat & M_CMD_ABORT_EN ||\n\t    dm_tx_st & TX_DMA_DONE || dm_tx_st & TX_RESET_DONE ||\n\t    dm_rx_st & RX_DMA_DONE || dm_rx_st & RX_RESET_DONE)\n\t\tcomplete(&gi2c->done);\n\n\tspin_unlock(&gi2c->lock);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void geni_i2c_abort_xfer(struct geni_i2c_dev *gi2c)\n{\n\tunsigned long time_left = ABORT_TIMEOUT;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&gi2c->lock, flags);\n\tgeni_i2c_err(gi2c, GENI_TIMEOUT);\n\tgi2c->cur = NULL;\n\tgi2c->abort_done = false;\n\tgeni_se_abort_m_cmd(&gi2c->se);\n\tspin_unlock_irqrestore(&gi2c->lock, flags);\n\n\tdo {\n\t\ttime_left = wait_for_completion_timeout(&gi2c->done, time_left);\n\t} while (!gi2c->abort_done && time_left);\n\n\tif (!time_left)\n\t\tdev_err(gi2c->se.dev, \"Timeout abort_m_cmd\\n\");\n}\n\nstatic void geni_i2c_rx_fsm_rst(struct geni_i2c_dev *gi2c)\n{\n\tu32 val;\n\tunsigned long time_left = RST_TIMEOUT;\n\n\twritel_relaxed(1, gi2c->se.base + SE_DMA_RX_FSM_RST);\n\tdo {\n\t\ttime_left = wait_for_completion_timeout(&gi2c->done, time_left);\n\t\tval = readl_relaxed(gi2c->se.base + SE_DMA_RX_IRQ_STAT);\n\t} while (!(val & RX_RESET_DONE) && time_left);\n\n\tif (!(val & RX_RESET_DONE))\n\t\tdev_err(gi2c->se.dev, \"Timeout resetting RX_FSM\\n\");\n}\n\nstatic void geni_i2c_tx_fsm_rst(struct geni_i2c_dev *gi2c)\n{\n\tu32 val;\n\tunsigned long time_left = RST_TIMEOUT;\n\n\twritel_relaxed(1, gi2c->se.base + SE_DMA_TX_FSM_RST);\n\tdo {\n\t\ttime_left = wait_for_completion_timeout(&gi2c->done, time_left);\n\t\tval = readl_relaxed(gi2c->se.base + SE_DMA_TX_IRQ_STAT);\n\t} while (!(val & TX_RESET_DONE) && time_left);\n\n\tif (!(val & TX_RESET_DONE))\n\t\tdev_err(gi2c->se.dev, \"Timeout resetting TX_FSM\\n\");\n}\n\nstatic void geni_i2c_rx_msg_cleanup(struct geni_i2c_dev *gi2c,\n\t\t\t\t     struct i2c_msg *cur)\n{\n\tgi2c->cur_rd = 0;\n\tif (gi2c->dma_buf) {\n\t\tif (gi2c->err)\n\t\t\tgeni_i2c_rx_fsm_rst(gi2c);\n\t\tgeni_se_rx_dma_unprep(&gi2c->se, gi2c->dma_addr, gi2c->xfer_len);\n\t\ti2c_put_dma_safe_msg_buf(gi2c->dma_buf, cur, !gi2c->err);\n\t}\n}\n\nstatic void geni_i2c_tx_msg_cleanup(struct geni_i2c_dev *gi2c,\n\t\t\t\t     struct i2c_msg *cur)\n{\n\tgi2c->cur_wr = 0;\n\tif (gi2c->dma_buf) {\n\t\tif (gi2c->err)\n\t\t\tgeni_i2c_tx_fsm_rst(gi2c);\n\t\tgeni_se_tx_dma_unprep(&gi2c->se, gi2c->dma_addr, gi2c->xfer_len);\n\t\ti2c_put_dma_safe_msg_buf(gi2c->dma_buf, cur, !gi2c->err);\n\t}\n}\n\nstatic int geni_i2c_rx_one_msg(struct geni_i2c_dev *gi2c, struct i2c_msg *msg,\n\t\t\t\tu32 m_param)\n{\n\tdma_addr_t rx_dma = 0;\n\tunsigned long time_left;\n\tvoid *dma_buf;\n\tstruct geni_se *se = &gi2c->se;\n\tsize_t len = msg->len;\n\tstruct i2c_msg *cur;\n\n\tdma_buf = i2c_get_dma_safe_msg_buf(msg, 32);\n\tif (dma_buf)\n\t\tgeni_se_select_mode(se, GENI_SE_DMA);\n\telse\n\t\tgeni_se_select_mode(se, GENI_SE_FIFO);\n\n\twritel_relaxed(len, se->base + SE_I2C_RX_TRANS_LEN);\n\tgeni_se_setup_m_cmd(se, I2C_READ, m_param);\n\n\tif (dma_buf && geni_se_rx_dma_prep(se, dma_buf, len, &rx_dma)) {\n\t\tgeni_se_select_mode(se, GENI_SE_FIFO);\n\t\ti2c_put_dma_safe_msg_buf(dma_buf, msg, false);\n\t\tdma_buf = NULL;\n\t} else {\n\t\tgi2c->xfer_len = len;\n\t\tgi2c->dma_addr = rx_dma;\n\t\tgi2c->dma_buf = dma_buf;\n\t}\n\n\tcur = gi2c->cur;\n\ttime_left = wait_for_completion_timeout(&gi2c->done, XFER_TIMEOUT);\n\tif (!time_left)\n\t\tgeni_i2c_abort_xfer(gi2c);\n\n\tgeni_i2c_rx_msg_cleanup(gi2c, cur);\n\n\treturn gi2c->err;\n}\n\nstatic int geni_i2c_tx_one_msg(struct geni_i2c_dev *gi2c, struct i2c_msg *msg,\n\t\t\t\tu32 m_param)\n{\n\tdma_addr_t tx_dma = 0;\n\tunsigned long time_left;\n\tvoid *dma_buf;\n\tstruct geni_se *se = &gi2c->se;\n\tsize_t len = msg->len;\n\tstruct i2c_msg *cur;\n\n\tdma_buf = i2c_get_dma_safe_msg_buf(msg, 32);\n\tif (dma_buf)\n\t\tgeni_se_select_mode(se, GENI_SE_DMA);\n\telse\n\t\tgeni_se_select_mode(se, GENI_SE_FIFO);\n\n\twritel_relaxed(len, se->base + SE_I2C_TX_TRANS_LEN);\n\tgeni_se_setup_m_cmd(se, I2C_WRITE, m_param);\n\n\tif (dma_buf && geni_se_tx_dma_prep(se, dma_buf, len, &tx_dma)) {\n\t\tgeni_se_select_mode(se, GENI_SE_FIFO);\n\t\ti2c_put_dma_safe_msg_buf(dma_buf, msg, false);\n\t\tdma_buf = NULL;\n\t} else {\n\t\tgi2c->xfer_len = len;\n\t\tgi2c->dma_addr = tx_dma;\n\t\tgi2c->dma_buf = dma_buf;\n\t}\n\n\tif (!dma_buf)  \n\t\twritel_relaxed(1, se->base + SE_GENI_TX_WATERMARK_REG);\n\n\tcur = gi2c->cur;\n\ttime_left = wait_for_completion_timeout(&gi2c->done, XFER_TIMEOUT);\n\tif (!time_left)\n\t\tgeni_i2c_abort_xfer(gi2c);\n\n\tgeni_i2c_tx_msg_cleanup(gi2c, cur);\n\n\treturn gi2c->err;\n}\n\nstatic void i2c_gpi_cb_result(void *cb, const struct dmaengine_result *result)\n{\n\tstruct geni_i2c_dev *gi2c = cb;\n\n\tif (result->result != DMA_TRANS_NOERROR) {\n\t\tdev_err(gi2c->se.dev, \"DMA txn failed:%d\\n\", result->result);\n\t\tgi2c->err = -EIO;\n\t} else if (result->residue) {\n\t\tdev_dbg(gi2c->se.dev, \"DMA xfer has pending: %d\\n\", result->residue);\n\t}\n\n\tcomplete(&gi2c->done);\n}\n\nstatic void geni_i2c_gpi_unmap(struct geni_i2c_dev *gi2c, struct i2c_msg *msg,\n\t\t\t       void *tx_buf, dma_addr_t tx_addr,\n\t\t\t       void *rx_buf, dma_addr_t rx_addr)\n{\n\tif (tx_buf) {\n\t\tdma_unmap_single(gi2c->se.dev->parent, tx_addr, msg->len, DMA_TO_DEVICE);\n\t\ti2c_put_dma_safe_msg_buf(tx_buf, msg, !gi2c->err);\n\t}\n\n\tif (rx_buf) {\n\t\tdma_unmap_single(gi2c->se.dev->parent, rx_addr, msg->len, DMA_FROM_DEVICE);\n\t\ti2c_put_dma_safe_msg_buf(rx_buf, msg, !gi2c->err);\n\t}\n}\n\nstatic int geni_i2c_gpi(struct geni_i2c_dev *gi2c, struct i2c_msg *msg,\n\t\t\tstruct dma_slave_config *config, dma_addr_t *dma_addr_p,\n\t\t\tvoid **buf, unsigned int op, struct dma_chan *dma_chan)\n{\n\tstruct gpi_i2c_config *peripheral;\n\tunsigned int flags;\n\tvoid *dma_buf;\n\tdma_addr_t addr;\n\tenum dma_data_direction map_dirn;\n\tenum dma_transfer_direction dma_dirn;\n\tstruct dma_async_tx_descriptor *desc;\n\tint ret;\n\n\tperipheral = config->peripheral_config;\n\n\tdma_buf = i2c_get_dma_safe_msg_buf(msg, 1);\n\tif (!dma_buf)\n\t\treturn -ENOMEM;\n\n\tif (op == I2C_WRITE)\n\t\tmap_dirn = DMA_TO_DEVICE;\n\telse\n\t\tmap_dirn = DMA_FROM_DEVICE;\n\n\taddr = dma_map_single(gi2c->se.dev->parent, dma_buf, msg->len, map_dirn);\n\tif (dma_mapping_error(gi2c->se.dev->parent, addr)) {\n\t\ti2c_put_dma_safe_msg_buf(dma_buf, msg, false);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tperipheral->rx_len = msg->len;\n\tperipheral->op = op;\n\n\tret = dmaengine_slave_config(dma_chan, config);\n\tif (ret) {\n\t\tdev_err(gi2c->se.dev, \"dma config error: %d for op:%d\\n\", ret, op);\n\t\tgoto err_config;\n\t}\n\n\tperipheral->set_config = 0;\n\tperipheral->multi_msg = true;\n\tflags = DMA_PREP_INTERRUPT | DMA_CTRL_ACK;\n\n\tif (op == I2C_WRITE)\n\t\tdma_dirn = DMA_MEM_TO_DEV;\n\telse\n\t\tdma_dirn = DMA_DEV_TO_MEM;\n\n\tdesc = dmaengine_prep_slave_single(dma_chan, addr, msg->len, dma_dirn, flags);\n\tif (!desc) {\n\t\tdev_err(gi2c->se.dev, \"prep_slave_sg failed\\n\");\n\t\tret = -EIO;\n\t\tgoto err_config;\n\t}\n\n\tdesc->callback_result = i2c_gpi_cb_result;\n\tdesc->callback_param = gi2c;\n\n\tdmaengine_submit(desc);\n\t*buf = dma_buf;\n\t*dma_addr_p = addr;\n\n\treturn 0;\n\nerr_config:\n\tdma_unmap_single(gi2c->se.dev->parent, addr, msg->len, map_dirn);\n\ti2c_put_dma_safe_msg_buf(dma_buf, msg, false);\n\treturn ret;\n}\n\nstatic int geni_i2c_gpi_xfer(struct geni_i2c_dev *gi2c, struct i2c_msg msgs[], int num)\n{\n\tstruct dma_slave_config config = {};\n\tstruct gpi_i2c_config peripheral = {};\n\tint i, ret = 0, timeout;\n\tdma_addr_t tx_addr, rx_addr;\n\tvoid *tx_buf = NULL, *rx_buf = NULL;\n\tconst struct geni_i2c_clk_fld *itr = gi2c->clk_fld;\n\n\tconfig.peripheral_config = &peripheral;\n\tconfig.peripheral_size = sizeof(peripheral);\n\n\tperipheral.pack_enable = I2C_PACK_TX | I2C_PACK_RX;\n\tperipheral.cycle_count = itr->t_cycle_cnt;\n\tperipheral.high_count = itr->t_high_cnt;\n\tperipheral.low_count = itr->t_low_cnt;\n\tperipheral.clk_div = itr->clk_div;\n\tperipheral.set_config = 1;\n\tperipheral.multi_msg = false;\n\n\tfor (i = 0; i < num; i++) {\n\t\tgi2c->cur = &msgs[i];\n\t\tgi2c->err = 0;\n\t\tdev_dbg(gi2c->se.dev, \"msg[%d].len:%d\\n\", i, gi2c->cur->len);\n\n\t\tperipheral.stretch = 0;\n\t\tif (i < num - 1)\n\t\t\tperipheral.stretch = 1;\n\n\t\tperipheral.addr = msgs[i].addr;\n\n\t\tif (msgs[i].flags & I2C_M_RD) {\n\t\t\tret =  geni_i2c_gpi(gi2c, &msgs[i], &config,\n\t\t\t\t\t    &rx_addr, &rx_buf, I2C_READ, gi2c->rx_c);\n\t\t\tif (ret)\n\t\t\t\tgoto err;\n\t\t}\n\n\t\tret =  geni_i2c_gpi(gi2c, &msgs[i], &config,\n\t\t\t\t    &tx_addr, &tx_buf, I2C_WRITE, gi2c->tx_c);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tif (msgs[i].flags & I2C_M_RD)\n\t\t\tdma_async_issue_pending(gi2c->rx_c);\n\t\tdma_async_issue_pending(gi2c->tx_c);\n\n\t\ttimeout = wait_for_completion_timeout(&gi2c->done, XFER_TIMEOUT);\n\t\tif (!timeout) {\n\t\t\tdev_err(gi2c->se.dev, \"I2C timeout gpi flags:%d addr:0x%x\\n\",\n\t\t\t\tgi2c->cur->flags, gi2c->cur->addr);\n\t\t\tgi2c->err = -ETIMEDOUT;\n\t\t}\n\n\t\tif (gi2c->err) {\n\t\t\tret = gi2c->err;\n\t\t\tgoto err;\n\t\t}\n\n\t\tgeni_i2c_gpi_unmap(gi2c, &msgs[i], tx_buf, tx_addr, rx_buf, rx_addr);\n\t}\n\n\treturn num;\n\nerr:\n\tdev_err(gi2c->se.dev, \"GPI transfer failed: %d\\n\", ret);\n\tdmaengine_terminate_sync(gi2c->rx_c);\n\tdmaengine_terminate_sync(gi2c->tx_c);\n\tgeni_i2c_gpi_unmap(gi2c, &msgs[i], tx_buf, tx_addr, rx_buf, rx_addr);\n\treturn ret;\n}\n\nstatic int geni_i2c_fifo_xfer(struct geni_i2c_dev *gi2c,\n\t\t\t      struct i2c_msg msgs[], int num)\n{\n\tint i, ret = 0;\n\n\tfor (i = 0; i < num; i++) {\n\t\tu32 m_param = i < (num - 1) ? STOP_STRETCH : 0;\n\n\t\tm_param |= ((msgs[i].addr << SLV_ADDR_SHFT) & SLV_ADDR_MSK);\n\n\t\tgi2c->cur = &msgs[i];\n\t\tif (msgs[i].flags & I2C_M_RD)\n\t\t\tret = geni_i2c_rx_one_msg(gi2c, &msgs[i], m_param);\n\t\telse\n\t\t\tret = geni_i2c_tx_one_msg(gi2c, &msgs[i], m_param);\n\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn num;\n}\n\nstatic int geni_i2c_xfer(struct i2c_adapter *adap,\n\t\t\t struct i2c_msg msgs[],\n\t\t\t int num)\n{\n\tstruct geni_i2c_dev *gi2c = i2c_get_adapdata(adap);\n\tint ret;\n\n\tgi2c->err = 0;\n\treinit_completion(&gi2c->done);\n\tret = pm_runtime_get_sync(gi2c->se.dev);\n\tif (ret < 0) {\n\t\tdev_err(gi2c->se.dev, \"error turning SE resources:%d\\n\", ret);\n\t\tpm_runtime_put_noidle(gi2c->se.dev);\n\t\t \n\t\tpm_runtime_set_suspended(gi2c->se.dev);\n\t\treturn ret;\n\t}\n\n\tqcom_geni_i2c_conf(gi2c);\n\n\tif (gi2c->gpi_mode)\n\t\tret = geni_i2c_gpi_xfer(gi2c, msgs, num);\n\telse\n\t\tret = geni_i2c_fifo_xfer(gi2c, msgs, num);\n\n\tpm_runtime_mark_last_busy(gi2c->se.dev);\n\tpm_runtime_put_autosuspend(gi2c->se.dev);\n\tgi2c->cur = NULL;\n\tgi2c->err = 0;\n\treturn ret;\n}\n\nstatic u32 geni_i2c_func(struct i2c_adapter *adap)\n{\n\treturn I2C_FUNC_I2C | (I2C_FUNC_SMBUS_EMUL & ~I2C_FUNC_SMBUS_QUICK);\n}\n\nstatic const struct i2c_algorithm geni_i2c_algo = {\n\t.master_xfer\t= geni_i2c_xfer,\n\t.functionality\t= geni_i2c_func,\n};\n\n#ifdef CONFIG_ACPI\nstatic const struct acpi_device_id geni_i2c_acpi_match[] = {\n\t{ \"QCOM0220\"},\n\t{ },\n};\nMODULE_DEVICE_TABLE(acpi, geni_i2c_acpi_match);\n#endif\n\nstatic void release_gpi_dma(struct geni_i2c_dev *gi2c)\n{\n\tif (gi2c->rx_c)\n\t\tdma_release_channel(gi2c->rx_c);\n\n\tif (gi2c->tx_c)\n\t\tdma_release_channel(gi2c->tx_c);\n}\n\nstatic int setup_gpi_dma(struct geni_i2c_dev *gi2c)\n{\n\tint ret;\n\n\tgeni_se_select_mode(&gi2c->se, GENI_GPI_DMA);\n\tgi2c->tx_c = dma_request_chan(gi2c->se.dev, \"tx\");\n\tif (IS_ERR(gi2c->tx_c)) {\n\t\tret = dev_err_probe(gi2c->se.dev, PTR_ERR(gi2c->tx_c),\n\t\t\t\t    \"Failed to get tx DMA ch\\n\");\n\t\tgoto err_tx;\n\t}\n\n\tgi2c->rx_c = dma_request_chan(gi2c->se.dev, \"rx\");\n\tif (IS_ERR(gi2c->rx_c)) {\n\t\tret = dev_err_probe(gi2c->se.dev, PTR_ERR(gi2c->rx_c),\n\t\t\t\t    \"Failed to get rx DMA ch\\n\");\n\t\tgoto err_rx;\n\t}\n\n\tdev_dbg(gi2c->se.dev, \"Grabbed GPI dma channels\\n\");\n\treturn 0;\n\nerr_rx:\n\tdma_release_channel(gi2c->tx_c);\nerr_tx:\n\treturn ret;\n}\n\nstatic int geni_i2c_probe(struct platform_device *pdev)\n{\n\tstruct geni_i2c_dev *gi2c;\n\tu32 proto, tx_depth, fifo_disable;\n\tint ret;\n\tstruct device *dev = &pdev->dev;\n\tconst struct geni_i2c_desc *desc = NULL;\n\n\tgi2c = devm_kzalloc(dev, sizeof(*gi2c), GFP_KERNEL);\n\tif (!gi2c)\n\t\treturn -ENOMEM;\n\n\tgi2c->se.dev = dev;\n\tgi2c->se.wrapper = dev_get_drvdata(dev->parent);\n\tgi2c->se.base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(gi2c->se.base))\n\t\treturn PTR_ERR(gi2c->se.base);\n\n\tdesc = device_get_match_data(&pdev->dev);\n\n\tif (desc && desc->has_core_clk) {\n\t\tgi2c->core_clk = devm_clk_get(dev, \"core\");\n\t\tif (IS_ERR(gi2c->core_clk))\n\t\t\treturn PTR_ERR(gi2c->core_clk);\n\t}\n\n\tgi2c->se.clk = devm_clk_get(dev, \"se\");\n\tif (IS_ERR(gi2c->se.clk) && !has_acpi_companion(dev))\n\t\treturn PTR_ERR(gi2c->se.clk);\n\n\tret = device_property_read_u32(dev, \"clock-frequency\",\n\t\t\t\t       &gi2c->clk_freq_out);\n\tif (ret) {\n\t\tdev_info(dev, \"Bus frequency not specified, default to 100kHz.\\n\");\n\t\tgi2c->clk_freq_out = KHZ(100);\n\t}\n\n\tif (has_acpi_companion(dev))\n\t\tACPI_COMPANION_SET(&gi2c->adap.dev, ACPI_COMPANION(dev));\n\n\tgi2c->irq = platform_get_irq(pdev, 0);\n\tif (gi2c->irq < 0)\n\t\treturn gi2c->irq;\n\n\tret = geni_i2c_clk_map_idx(gi2c);\n\tif (ret) {\n\t\tdev_err(dev, \"Invalid clk frequency %d Hz: %d\\n\",\n\t\t\tgi2c->clk_freq_out, ret);\n\t\treturn ret;\n\t}\n\n\tgi2c->adap.algo = &geni_i2c_algo;\n\tinit_completion(&gi2c->done);\n\tspin_lock_init(&gi2c->lock);\n\tplatform_set_drvdata(pdev, gi2c);\n\tret = devm_request_irq(dev, gi2c->irq, geni_i2c_irq, 0,\n\t\t\t       dev_name(dev), gi2c);\n\tif (ret) {\n\t\tdev_err(dev, \"Request_irq failed:%d: err:%d\\n\",\n\t\t\tgi2c->irq, ret);\n\t\treturn ret;\n\t}\n\t \n\tdisable_irq(gi2c->irq);\n\ti2c_set_adapdata(&gi2c->adap, gi2c);\n\tgi2c->adap.dev.parent = dev;\n\tgi2c->adap.dev.of_node = dev->of_node;\n\tstrscpy(gi2c->adap.name, \"Geni-I2C\", sizeof(gi2c->adap.name));\n\n\tret = geni_icc_get(&gi2c->se, desc ? desc->icc_ddr : \"qup-memory\");\n\tif (ret)\n\t\treturn ret;\n\t \n\tgi2c->se.icc_paths[GENI_TO_CORE].avg_bw = GENI_DEFAULT_BW;\n\tgi2c->se.icc_paths[CPU_TO_GENI].avg_bw = GENI_DEFAULT_BW;\n\tif (!desc || desc->icc_ddr)\n\t\tgi2c->se.icc_paths[GENI_TO_DDR].avg_bw = Bps_to_icc(gi2c->clk_freq_out);\n\n\tret = geni_icc_set_bw(&gi2c->se);\n\tif (ret)\n\t\treturn ret;\n\n\tret = clk_prepare_enable(gi2c->core_clk);\n\tif (ret)\n\t\treturn ret;\n\n\tret = geni_se_resources_on(&gi2c->se);\n\tif (ret) {\n\t\tdev_err(dev, \"Error turning on resources %d\\n\", ret);\n\t\tclk_disable_unprepare(gi2c->core_clk);\n\t\treturn ret;\n\t}\n\tproto = geni_se_read_proto(&gi2c->se);\n\tif (proto != GENI_SE_I2C) {\n\t\tdev_err(dev, \"Invalid proto %d\\n\", proto);\n\t\tgeni_se_resources_off(&gi2c->se);\n\t\tclk_disable_unprepare(gi2c->core_clk);\n\t\treturn -ENXIO;\n\t}\n\n\tif (desc && desc->no_dma_support)\n\t\tfifo_disable = false;\n\telse\n\t\tfifo_disable = readl_relaxed(gi2c->se.base + GENI_IF_DISABLE_RO) & FIFO_IF_DISABLE;\n\n\tif (fifo_disable) {\n\t\t \n\t\tgi2c->gpi_mode = true;\n\t\tret = setup_gpi_dma(gi2c);\n\t\tif (ret) {\n\t\t\tgeni_se_resources_off(&gi2c->se);\n\t\t\tclk_disable_unprepare(gi2c->core_clk);\n\t\t\treturn dev_err_probe(dev, ret, \"Failed to setup GPI DMA mode\\n\");\n\t\t}\n\n\t\tdev_dbg(dev, \"Using GPI DMA mode for I2C\\n\");\n\t} else {\n\t\tgi2c->gpi_mode = false;\n\t\ttx_depth = geni_se_get_tx_fifo_depth(&gi2c->se);\n\n\t\t \n\t\tif (!tx_depth && desc)\n\t\t\ttx_depth = desc->tx_fifo_depth;\n\n\t\tif (!tx_depth) {\n\t\t\tdev_err(dev, \"Invalid TX FIFO depth\\n\");\n\t\t\tgeni_se_resources_off(&gi2c->se);\n\t\t\tclk_disable_unprepare(gi2c->core_clk);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tgi2c->tx_wm = tx_depth - 1;\n\t\tgeni_se_init(&gi2c->se, gi2c->tx_wm, tx_depth);\n\t\tgeni_se_config_packing(&gi2c->se, BITS_PER_BYTE,\n\t\t\t\t       PACKING_BYTES_PW, true, true, true);\n\n\t\tdev_dbg(dev, \"i2c fifo/se-dma mode. fifo depth:%d\\n\", tx_depth);\n\t}\n\n\tclk_disable_unprepare(gi2c->core_clk);\n\tret = geni_se_resources_off(&gi2c->se);\n\tif (ret) {\n\t\tdev_err(dev, \"Error turning off resources %d\\n\", ret);\n\t\tgoto err_dma;\n\t}\n\n\tret = geni_icc_disable(&gi2c->se);\n\tif (ret)\n\t\tgoto err_dma;\n\n\tgi2c->suspended = 1;\n\tpm_runtime_set_suspended(gi2c->se.dev);\n\tpm_runtime_set_autosuspend_delay(gi2c->se.dev, I2C_AUTO_SUSPEND_DELAY);\n\tpm_runtime_use_autosuspend(gi2c->se.dev);\n\tpm_runtime_enable(gi2c->se.dev);\n\n\tret = i2c_add_adapter(&gi2c->adap);\n\tif (ret) {\n\t\tdev_err(dev, \"Error adding i2c adapter %d\\n\", ret);\n\t\tpm_runtime_disable(gi2c->se.dev);\n\t\tgoto err_dma;\n\t}\n\n\tdev_dbg(dev, \"Geni-I2C adaptor successfully added\\n\");\n\n\treturn 0;\n\nerr_dma:\n\trelease_gpi_dma(gi2c);\n\treturn ret;\n}\n\nstatic void geni_i2c_remove(struct platform_device *pdev)\n{\n\tstruct geni_i2c_dev *gi2c = platform_get_drvdata(pdev);\n\n\ti2c_del_adapter(&gi2c->adap);\n\trelease_gpi_dma(gi2c);\n\tpm_runtime_disable(gi2c->se.dev);\n}\n\nstatic void geni_i2c_shutdown(struct platform_device *pdev)\n{\n\tstruct geni_i2c_dev *gi2c = platform_get_drvdata(pdev);\n\n\t \n\ti2c_mark_adapter_suspended(&gi2c->adap);\n}\n\nstatic int __maybe_unused geni_i2c_runtime_suspend(struct device *dev)\n{\n\tint ret;\n\tstruct geni_i2c_dev *gi2c = dev_get_drvdata(dev);\n\n\tdisable_irq(gi2c->irq);\n\tret = geni_se_resources_off(&gi2c->se);\n\tif (ret) {\n\t\tenable_irq(gi2c->irq);\n\t\treturn ret;\n\n\t} else {\n\t\tgi2c->suspended = 1;\n\t}\n\n\tclk_disable_unprepare(gi2c->core_clk);\n\n\treturn geni_icc_disable(&gi2c->se);\n}\n\nstatic int __maybe_unused geni_i2c_runtime_resume(struct device *dev)\n{\n\tint ret;\n\tstruct geni_i2c_dev *gi2c = dev_get_drvdata(dev);\n\n\tret = geni_icc_enable(&gi2c->se);\n\tif (ret)\n\t\treturn ret;\n\n\tret = clk_prepare_enable(gi2c->core_clk);\n\tif (ret)\n\t\treturn ret;\n\n\tret = geni_se_resources_on(&gi2c->se);\n\tif (ret)\n\t\treturn ret;\n\n\tenable_irq(gi2c->irq);\n\tgi2c->suspended = 0;\n\treturn 0;\n}\n\nstatic int __maybe_unused geni_i2c_suspend_noirq(struct device *dev)\n{\n\tstruct geni_i2c_dev *gi2c = dev_get_drvdata(dev);\n\n\ti2c_mark_adapter_suspended(&gi2c->adap);\n\n\tif (!gi2c->suspended) {\n\t\tgeni_i2c_runtime_suspend(dev);\n\t\tpm_runtime_disable(dev);\n\t\tpm_runtime_set_suspended(dev);\n\t\tpm_runtime_enable(dev);\n\t}\n\treturn 0;\n}\n\nstatic int __maybe_unused geni_i2c_resume_noirq(struct device *dev)\n{\n\tstruct geni_i2c_dev *gi2c = dev_get_drvdata(dev);\n\n\ti2c_mark_adapter_resumed(&gi2c->adap);\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops geni_i2c_pm_ops = {\n\tSET_NOIRQ_SYSTEM_SLEEP_PM_OPS(geni_i2c_suspend_noirq, geni_i2c_resume_noirq)\n\tSET_RUNTIME_PM_OPS(geni_i2c_runtime_suspend, geni_i2c_runtime_resume,\n\t\t\t\t\t\t\t\t\tNULL)\n};\n\nstatic const struct geni_i2c_desc i2c_master_hub = {\n\t.has_core_clk = true,\n\t.icc_ddr = NULL,\n\t.no_dma_support = true,\n\t.tx_fifo_depth = 16,\n};\n\nstatic const struct of_device_id geni_i2c_dt_match[] = {\n\t{ .compatible = \"qcom,geni-i2c\" },\n\t{ .compatible = \"qcom,geni-i2c-master-hub\", .data = &i2c_master_hub },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, geni_i2c_dt_match);\n\nstatic struct platform_driver geni_i2c_driver = {\n\t.probe  = geni_i2c_probe,\n\t.remove_new = geni_i2c_remove,\n\t.shutdown = geni_i2c_shutdown,\n\t.driver = {\n\t\t.name = \"geni_i2c\",\n\t\t.pm = &geni_i2c_pm_ops,\n\t\t.of_match_table = geni_i2c_dt_match,\n\t\t.acpi_match_table = ACPI_PTR(geni_i2c_acpi_match),\n\t},\n};\n\nmodule_platform_driver(geni_i2c_driver);\n\nMODULE_DESCRIPTION(\"I2C Controller Driver for GENI based QUP cores\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}