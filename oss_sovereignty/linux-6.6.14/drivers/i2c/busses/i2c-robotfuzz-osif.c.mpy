{
  "module_name": "i2c-robotfuzz-osif.c",
  "hash_id": "a64245be0856bdf6876e4a3b36d264a44a6136981e6a087ecc0a38467896e398",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-robotfuzz-osif.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/i2c.h>\n#include <linux/slab.h>\n#include <linux/usb.h>\n\n#define OSIFI2C_READ\t\t20\n#define OSIFI2C_WRITE\t\t21\n#define OSIFI2C_STOP\t\t22\n#define OSIFI2C_STATUS\t\t23\n#define OSIFI2C_SET_BIT_RATE\t24\n\n#define STATUS_ADDRESS_ACK\t0\n#define STATUS_ADDRESS_NAK\t2\n\nstruct osif_priv {\n\tstruct usb_device *usb_dev;\n\tstruct usb_interface *interface;\n\tstruct i2c_adapter adapter;\n\tunsigned char status;\n};\n\nstatic int osif_usb_read(struct i2c_adapter *adapter, int cmd,\n\t\t\t int value, int index, void *data, int len)\n{\n\tstruct osif_priv *priv = adapter->algo_data;\n\n\treturn usb_control_msg(priv->usb_dev, usb_rcvctrlpipe(priv->usb_dev, 0),\n\t\t\t       cmd, USB_TYPE_VENDOR | USB_RECIP_INTERFACE |\n\t\t\t       USB_DIR_IN, value, index, data, len, 2000);\n}\n\nstatic int osif_usb_write(struct i2c_adapter *adapter, int cmd,\n\t\t\t  int value, int index, void *data, int len)\n{\n\n\tstruct osif_priv *priv = adapter->algo_data;\n\n\treturn usb_control_msg(priv->usb_dev, usb_sndctrlpipe(priv->usb_dev, 0),\n\t\t\t       cmd, USB_TYPE_VENDOR | USB_RECIP_INTERFACE,\n\t\t\t       value, index, data, len, 2000);\n}\n\nstatic int osif_xfer(struct i2c_adapter *adapter, struct i2c_msg *msgs,\n\t\t\t int num)\n{\n\tstruct osif_priv *priv = adapter->algo_data;\n\tstruct i2c_msg *pmsg;\n\tint ret;\n\tint i;\n\n\tfor (i = 0; i < num; i++) {\n\t\tpmsg = &msgs[i];\n\n\t\tif (pmsg->flags & I2C_M_RD) {\n\t\t\tret = osif_usb_read(adapter, OSIFI2C_READ,\n\t\t\t\t\t    pmsg->flags, pmsg->addr,\n\t\t\t\t\t    pmsg->buf, pmsg->len);\n\t\t\tif (ret != pmsg->len) {\n\t\t\t\tdev_err(&adapter->dev, \"failure reading data\\n\");\n\t\t\t\treturn -EREMOTEIO;\n\t\t\t}\n\t\t} else {\n\t\t\tret = osif_usb_write(adapter, OSIFI2C_WRITE,\n\t\t\t\t\t     pmsg->flags, pmsg->addr,\n\t\t\t\t\t     pmsg->buf, pmsg->len);\n\t\t\tif (ret != pmsg->len) {\n\t\t\t\tdev_err(&adapter->dev, \"failure writing data\\n\");\n\t\t\t\treturn -EREMOTEIO;\n\t\t\t}\n\t\t}\n\n\t\tret = osif_usb_write(adapter, OSIFI2C_STOP, 0, 0, NULL, 0);\n\t\tif (ret) {\n\t\t\tdev_err(&adapter->dev, \"failure sending STOP\\n\");\n\t\t\treturn -EREMOTEIO;\n\t\t}\n\n\t\t \n\t\tret = osif_usb_read(adapter, OSIFI2C_STATUS, 0, 0,\n\t\t\t\t    &priv->status, 1);\n\t\tif (ret != 1) {\n\t\t\tdev_err(&adapter->dev, \"failure reading status\\n\");\n\t\t\treturn -EREMOTEIO;\n\t\t}\n\n\t\tif (priv->status != STATUS_ADDRESS_ACK) {\n\t\t\tdev_dbg(&adapter->dev, \"status = %d\\n\", priv->status);\n\t\t\treturn -EREMOTEIO;\n\t\t}\n\t}\n\n\treturn i;\n}\n\nstatic u32 osif_func(struct i2c_adapter *adapter)\n{\n\treturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;\n}\n\nstatic const struct i2c_algorithm osif_algorithm = {\n\t.master_xfer\t= osif_xfer,\n\t.functionality\t= osif_func,\n};\n\n#define USB_OSIF_VENDOR_ID\t0x1964\n#define USB_OSIF_PRODUCT_ID\t0x0001\n\nstatic const struct usb_device_id osif_table[] = {\n\t{ USB_DEVICE(USB_OSIF_VENDOR_ID, USB_OSIF_PRODUCT_ID) },\n\t{ }\n};\nMODULE_DEVICE_TABLE(usb, osif_table);\n\nstatic int osif_probe(struct usb_interface *interface,\n\t\t\t     const struct usb_device_id *id)\n{\n\tint ret;\n\tstruct osif_priv *priv;\n\tu16 version;\n\n\tpriv = devm_kzalloc(&interface->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->usb_dev = usb_get_dev(interface_to_usbdev(interface));\n\tpriv->interface = interface;\n\n\tusb_set_intfdata(interface, priv);\n\n\tpriv->adapter.owner = THIS_MODULE;\n\tpriv->adapter.class = I2C_CLASS_HWMON;\n\tpriv->adapter.algo = &osif_algorithm;\n\tpriv->adapter.algo_data = priv;\n\tsnprintf(priv->adapter.name, sizeof(priv->adapter.name),\n\t\t \"OSIF at bus %03d device %03d\",\n\t\t priv->usb_dev->bus->busnum, priv->usb_dev->devnum);\n\n\t \n\tret = osif_usb_write(&priv->adapter, OSIFI2C_SET_BIT_RATE, 52, 0,\n\t\t\t    NULL, 0);\n\tif (ret) {\n\t\tdev_err(&interface->dev, \"failure sending bit rate\");\n\t\tusb_put_dev(priv->usb_dev);\n\t\treturn ret;\n\t}\n\n\ti2c_add_adapter(&(priv->adapter));\n\n\tversion = le16_to_cpu(priv->usb_dev->descriptor.bcdDevice);\n\tdev_info(&interface->dev,\n\t\t \"version %x.%02x found at bus %03d address %03d\",\n\t\t version >> 8, version & 0xff,\n\t\t priv->usb_dev->bus->busnum, priv->usb_dev->devnum);\n\n\treturn 0;\n}\n\nstatic void osif_disconnect(struct usb_interface *interface)\n{\n\tstruct osif_priv *priv = usb_get_intfdata(interface);\n\n\ti2c_del_adapter(&(priv->adapter));\n\tusb_set_intfdata(interface, NULL);\n\tusb_put_dev(priv->usb_dev);\n}\n\nstatic struct usb_driver osif_driver = {\n\t.name\t\t= \"RobotFuzz Open Source InterFace, OSIF\",\n\t.probe\t\t= osif_probe,\n\t.disconnect\t= osif_disconnect,\n\t.id_table\t= osif_table,\n};\n\nmodule_usb_driver(osif_driver);\n\nMODULE_AUTHOR(\"Andrew Lunn <andrew@lunn.ch>\");\nMODULE_AUTHOR(\"Barry Carter <barry.carter@robotfuzz.com>\");\nMODULE_DESCRIPTION(\"RobotFuzz OSIF driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}