{
  "module_name": "i2c-ali1535.c",
  "hash_id": "9b7efdd3c55b7ee3c6c9ec6d3bb423bea2152d67dd055bc57c8aab22d7f0782f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-ali1535.c",
  "human_readable_source": "\n \n\n \n\n\n \n\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/i2c.h>\n#include <linux/acpi.h>\n#include <linux/io.h>\n\n\n \n#define SMBHSTSTS\t(0 + ali1535_smba)\n#define SMBHSTTYP\t(1 + ali1535_smba)\n#define SMBHSTPORT\t(2 + ali1535_smba)\n#define SMBHSTCMD\t(7 + ali1535_smba)\n#define SMBHSTADD\t(3 + ali1535_smba)\n#define SMBHSTDAT0\t(4 + ali1535_smba)\n#define SMBHSTDAT1\t(5 + ali1535_smba)\n#define SMBBLKDAT\t(6 + ali1535_smba)\n\n \n#define SMBCOM\t\t0x004\n#define SMBREV\t\t0x008\n#define SMBCFG\t\t0x0D1\n#define SMBBA\t\t0x0E2\n#define SMBHSTCFG\t0x0F0\n#define SMBCLK\t\t0x0F2\n\n \n#define MAX_TIMEOUT\t\t500\t \n#define ALI1535_SMB_IOSIZE\t32\n\n#define ALI1535_SMB_DEFAULTBASE\t0x8040\n\n \n#define ALI1535_LOCK\t\t0x06\t \n\n \n#define ALI1535_QUICK\t\t0x00\n#define ALI1535_BYTE\t\t0x10\n#define ALI1535_BYTE_DATA\t0x20\n#define ALI1535_WORD_DATA\t0x30\n#define ALI1535_BLOCK_DATA\t0x40\n#define ALI1535_I2C_READ\t0x60\n\n#define\tALI1535_DEV10B_EN\t0x80\t \n\t\t\t\t\t \n#define\tALI1535_T_OUT\t\t0x08\t \n#define\tALI1535_A_HIGH_BIT9\t0x08\t \n\t\t\t\t\t \n\t\t\t\t\t \n#define\tALI1535_KILL\t\t0x04\t \n#define\tALI1535_A_HIGH_BIT8\t0x04\t \n\t\t\t\t\t \n\t\t\t\t\t \n\n#define\tALI1535_D_HI_MASK\t0x03\t \n\t\t\t\t\t \n\t\t\t\t\t \n\n \n#define ALI1535_STS_IDLE\t0x04\n#define ALI1535_STS_BUSY\t0x08\t \n#define ALI1535_STS_DONE\t0x10\t \n#define ALI1535_STS_DEV\t\t0x20\t \n#define ALI1535_STS_BUSERR\t0x40\t \n#define ALI1535_STS_FAIL\t0x80\t \n#define ALI1535_STS_ERR\t\t0xE0\t \n\n#define ALI1535_BLOCK_CLR\t0x04\t \n\n \n#define\tALI1535_RD_ADDR\t\t0x01\t \n\t\t\t\t\t \n\t\t\t\t\t \n\t\t\t\t\t \n#define\tALI1535_SMBIO_EN\t0x04\t \n\nstatic struct pci_driver ali1535_driver;\nstatic unsigned long ali1535_smba;\nstatic unsigned short ali1535_offset;\n\n \nstatic int ali1535_setup(struct pci_dev *dev)\n{\n\tint retval;\n\tunsigned char temp;\n\n\t \n\n\tretval = pci_enable_device(dev);\n\tif (retval) {\n\t\tdev_err(&dev->dev, \"ALI1535_smb can't enable device\\n\");\n\t\tgoto exit;\n\t}\n\n\t \n\tpci_read_config_word(dev, SMBBA, &ali1535_offset);\n\tdev_dbg(&dev->dev, \"ALI1535_smb is at offset 0x%04x\\n\", ali1535_offset);\n\tali1535_offset &= (0xffff & ~(ALI1535_SMB_IOSIZE - 1));\n\tif (ali1535_offset == 0) {\n\t\tdev_warn(&dev->dev,\n\t\t\t\"ALI1535_smb region uninitialized - upgrade BIOS?\\n\");\n\t\tretval = -ENODEV;\n\t\tgoto exit;\n\t}\n\n\tif (pci_resource_flags(dev, 0) & IORESOURCE_IO)\n\t\tali1535_smba = pci_resource_start(dev, 0) + ali1535_offset;\n\telse\n\t\tali1535_smba = ali1535_offset;\n\n\tretval = acpi_check_region(ali1535_smba, ALI1535_SMB_IOSIZE,\n\t\t\t\t   ali1535_driver.name);\n\tif (retval)\n\t\tgoto exit;\n\n\tif (!request_region(ali1535_smba, ALI1535_SMB_IOSIZE,\n\t\t\t    ali1535_driver.name)) {\n\t\tdev_err(&dev->dev, \"ALI1535_smb region 0x%lx already in use!\\n\",\n\t\t\tali1535_smba);\n\t\tretval = -EBUSY;\n\t\tgoto exit;\n\t}\n\n\t \n\tpci_read_config_byte(dev, SMBCFG, &temp);\n\tif ((temp & ALI1535_SMBIO_EN) == 0) {\n\t\tdev_err(&dev->dev, \"SMB device not enabled - upgrade BIOS?\\n\");\n\t\tretval = -ENODEV;\n\t\tgoto exit_free;\n\t}\n\n\t \n\tpci_read_config_byte(dev, SMBHSTCFG, &temp);\n\tif ((temp & 1) == 0) {\n\t\tdev_err(&dev->dev, \"SMBus controller not enabled - upgrade BIOS?\\n\");\n\t\tretval = -ENODEV;\n\t\tgoto exit_free;\n\t}\n\n\t \n\tpci_write_config_byte(dev, SMBCLK, 0x20);\n\n\t \n\tpci_read_config_byte(dev, SMBREV, &temp);\n\tdev_dbg(&dev->dev, \"SMBREV = 0x%X\\n\", temp);\n\tdev_dbg(&dev->dev, \"ALI1535_smba = 0x%lx\\n\", ali1535_smba);\n\n\treturn 0;\n\nexit_free:\n\trelease_region(ali1535_smba, ALI1535_SMB_IOSIZE);\nexit:\n\treturn retval;\n}\n\nstatic int ali1535_transaction(struct i2c_adapter *adap)\n{\n\tint temp;\n\tint result = 0;\n\tint timeout = 0;\n\n\tdev_dbg(&adap->dev, \"Transaction (pre): STS=%02x, TYP=%02x, \"\n\t\t\"CMD=%02x, ADD=%02x, DAT0=%02x, DAT1=%02x\\n\",\n\t\tinb_p(SMBHSTSTS), inb_p(SMBHSTTYP), inb_p(SMBHSTCMD),\n\t\tinb_p(SMBHSTADD), inb_p(SMBHSTDAT0), inb_p(SMBHSTDAT1));\n\n\t \n\ttemp = inb_p(SMBHSTSTS);\n\n\t \n\t \n\tif (temp & ALI1535_STS_BUSY) {\n\t\t \n\n\t\t \n\t\tdev_info(&adap->dev,\n\t\t\t\"Resetting entire SMB Bus to clear busy condition (%02x)\\n\",\n\t\t\ttemp);\n\t\toutb_p(ALI1535_T_OUT, SMBHSTTYP);\n\t\ttemp = inb_p(SMBHSTSTS);\n\t}\n\n\t \n\tif (temp & (ALI1535_STS_ERR | ALI1535_STS_BUSY)) {\n\t\t \n\t\toutb_p(0xFF, SMBHSTSTS);\n\t\ttemp = inb_p(SMBHSTSTS);\n\t\tif (temp & (ALI1535_STS_ERR | ALI1535_STS_BUSY)) {\n\t\t\t \n\t\t\t \n\t\t\tdev_err(&adap->dev,\n\t\t\t\t\"SMBus reset failed! (0x%02x) - controller or \"\n\t\t\t\t\"device on bus is probably hung\\n\", temp);\n\t\t\treturn -EBUSY;\n\t\t}\n\t} else {\n\t\t \n\t\tif (temp & ALI1535_STS_DONE)\n\t\t\toutb_p(temp, SMBHSTSTS);\n\t}\n\n\t \n\toutb_p(0xFF, SMBHSTPORT);\n\n\t \n\ttimeout = 0;\n\tdo {\n\t\tusleep_range(1000, 2000);\n\t\ttemp = inb_p(SMBHSTSTS);\n\t} while (((temp & ALI1535_STS_BUSY) && !(temp & ALI1535_STS_IDLE))\n\t\t && (timeout++ < MAX_TIMEOUT));\n\n\t \n\tif (timeout > MAX_TIMEOUT) {\n\t\tresult = -ETIMEDOUT;\n\t\tdev_err(&adap->dev, \"SMBus Timeout!\\n\");\n\t}\n\n\tif (temp & ALI1535_STS_FAIL) {\n\t\tresult = -EIO;\n\t\tdev_dbg(&adap->dev, \"Error: Failed bus transaction\\n\");\n\t}\n\n\t \n\tif (temp & ALI1535_STS_BUSERR) {\n\t\tresult = -ENXIO;\n\t\tdev_dbg(&adap->dev,\n\t\t\t\"Error: no response or bus collision ADD=%02x\\n\",\n\t\t\tinb_p(SMBHSTADD));\n\t}\n\n\t \n\tif (temp & ALI1535_STS_DEV) {\n\t\tresult = -EIO;\n\t\tdev_err(&adap->dev, \"Error: device error\\n\");\n\t}\n\n\t \n\tif (!(temp & ALI1535_STS_DONE)) {\n\t\tresult = -ETIMEDOUT;\n\t\tdev_err(&adap->dev, \"Error: command never completed\\n\");\n\t}\n\n\tdev_dbg(&adap->dev, \"Transaction (post): STS=%02x, TYP=%02x, \"\n\t\t\"CMD=%02x, ADD=%02x, DAT0=%02x, DAT1=%02x\\n\",\n\t\tinb_p(SMBHSTSTS), inb_p(SMBHSTTYP), inb_p(SMBHSTCMD),\n\t\tinb_p(SMBHSTADD), inb_p(SMBHSTDAT0), inb_p(SMBHSTDAT1));\n\n\t \n\tif (!(temp & ALI1535_STS_DONE)) {\n\t\t \n\t\toutb_p(ALI1535_KILL, SMBHSTTYP);\n\t\toutb_p(0xFF, SMBHSTSTS);\n\t} else if (temp & ALI1535_STS_ERR) {\n\t\t \n\t\toutb_p(ALI1535_T_OUT, SMBHSTTYP);\n\t\toutb_p(0xFF, SMBHSTSTS);\n\t}\n\n\treturn result;\n}\n\n \nstatic s32 ali1535_access(struct i2c_adapter *adap, u16 addr,\n\t\t\t  unsigned short flags, char read_write, u8 command,\n\t\t\t  int size, union i2c_smbus_data *data)\n{\n\tint i, len;\n\tint temp;\n\tint timeout;\n\ts32 result = 0;\n\n\t \n\ttemp = inb_p(SMBHSTSTS);\n\tfor (timeout = 0;\n\t     (timeout < MAX_TIMEOUT) && !(temp & ALI1535_STS_IDLE);\n\t     timeout++) {\n\t\tusleep_range(1000, 2000);\n\t\ttemp = inb_p(SMBHSTSTS);\n\t}\n\tif (timeout >= MAX_TIMEOUT)\n\t\tdev_warn(&adap->dev, \"Idle wait Timeout! STS=0x%02x\\n\", temp);\n\n\t \n\toutb_p(0xFF, SMBHSTSTS);\n\n\tswitch (size) {\n\tcase I2C_SMBUS_QUICK:\n\t\toutb_p(((addr & 0x7f) << 1) | (read_write & 0x01),\n\t\t       SMBHSTADD);\n\t\tsize = ALI1535_QUICK;\n\t\toutb_p(size, SMBHSTTYP);\t \n\t\tbreak;\n\tcase I2C_SMBUS_BYTE:\n\t\toutb_p(((addr & 0x7f) << 1) | (read_write & 0x01),\n\t\t       SMBHSTADD);\n\t\tsize = ALI1535_BYTE;\n\t\toutb_p(size, SMBHSTTYP);\t \n\t\tif (read_write == I2C_SMBUS_WRITE)\n\t\t\toutb_p(command, SMBHSTCMD);\n\t\tbreak;\n\tcase I2C_SMBUS_BYTE_DATA:\n\t\toutb_p(((addr & 0x7f) << 1) | (read_write & 0x01),\n\t\t       SMBHSTADD);\n\t\tsize = ALI1535_BYTE_DATA;\n\t\toutb_p(size, SMBHSTTYP);\t \n\t\toutb_p(command, SMBHSTCMD);\n\t\tif (read_write == I2C_SMBUS_WRITE)\n\t\t\toutb_p(data->byte, SMBHSTDAT0);\n\t\tbreak;\n\tcase I2C_SMBUS_WORD_DATA:\n\t\toutb_p(((addr & 0x7f) << 1) | (read_write & 0x01),\n\t\t       SMBHSTADD);\n\t\tsize = ALI1535_WORD_DATA;\n\t\toutb_p(size, SMBHSTTYP);\t \n\t\toutb_p(command, SMBHSTCMD);\n\t\tif (read_write == I2C_SMBUS_WRITE) {\n\t\t\toutb_p(data->word & 0xff, SMBHSTDAT0);\n\t\t\toutb_p((data->word & 0xff00) >> 8, SMBHSTDAT1);\n\t\t}\n\t\tbreak;\n\tcase I2C_SMBUS_BLOCK_DATA:\n\t\toutb_p(((addr & 0x7f) << 1) | (read_write & 0x01),\n\t\t       SMBHSTADD);\n\t\tsize = ALI1535_BLOCK_DATA;\n\t\toutb_p(size, SMBHSTTYP);\t \n\t\toutb_p(command, SMBHSTCMD);\n\t\tif (read_write == I2C_SMBUS_WRITE) {\n\t\t\tlen = data->block[0];\n\t\t\tif (len < 0) {\n\t\t\t\tlen = 0;\n\t\t\t\tdata->block[0] = len;\n\t\t\t}\n\t\t\tif (len > 32) {\n\t\t\t\tlen = 32;\n\t\t\t\tdata->block[0] = len;\n\t\t\t}\n\t\t\toutb_p(len, SMBHSTDAT0);\n\t\t\t \n\t\t\toutb_p(inb_p(SMBHSTTYP) | ALI1535_BLOCK_CLR, SMBHSTTYP);\n\t\t\tfor (i = 1; i <= len; i++)\n\t\t\t\toutb_p(data->block[i], SMBBLKDAT);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(&adap->dev, \"Unsupported transaction %d\\n\", size);\n\t\tresult = -EOPNOTSUPP;\n\t\tgoto EXIT;\n\t}\n\n\tresult = ali1535_transaction(adap);\n\tif (result)\n\t\tgoto EXIT;\n\n\tif ((read_write == I2C_SMBUS_WRITE) || (size == ALI1535_QUICK)) {\n\t\tresult = 0;\n\t\tgoto EXIT;\n\t}\n\n\tswitch (size) {\n\tcase ALI1535_BYTE:\t \n\t\tdata->byte = inb_p(SMBHSTDAT0);\n\t\tbreak;\n\tcase ALI1535_BYTE_DATA:\n\t\tdata->byte = inb_p(SMBHSTDAT0);\n\t\tbreak;\n\tcase ALI1535_WORD_DATA:\n\t\tdata->word = inb_p(SMBHSTDAT0) + (inb_p(SMBHSTDAT1) << 8);\n\t\tbreak;\n\tcase ALI1535_BLOCK_DATA:\n\t\tlen = inb_p(SMBHSTDAT0);\n\t\tif (len > 32)\n\t\t\tlen = 32;\n\t\tdata->block[0] = len;\n\t\t \n\t\toutb_p(inb_p(SMBHSTTYP) | ALI1535_BLOCK_CLR, SMBHSTTYP);\n\t\tfor (i = 1; i <= data->block[0]; i++) {\n\t\t\tdata->block[i] = inb_p(SMBBLKDAT);\n\t\t\tdev_dbg(&adap->dev, \"Blk: len=%d, i=%d, data=%02x\\n\",\n\t\t\t\tlen, i, data->block[i]);\n\t\t}\n\t\tbreak;\n\t}\nEXIT:\n\treturn result;\n}\n\n\nstatic u32 ali1535_func(struct i2c_adapter *adapter)\n{\n\treturn I2C_FUNC_SMBUS_QUICK | I2C_FUNC_SMBUS_BYTE |\n\t    I2C_FUNC_SMBUS_BYTE_DATA | I2C_FUNC_SMBUS_WORD_DATA |\n\t    I2C_FUNC_SMBUS_BLOCK_DATA;\n}\n\nstatic const struct i2c_algorithm smbus_algorithm = {\n\t.smbus_xfer\t= ali1535_access,\n\t.functionality\t= ali1535_func,\n};\n\nstatic struct i2c_adapter ali1535_adapter = {\n\t.owner\t\t= THIS_MODULE,\n\t.class          = I2C_CLASS_HWMON | I2C_CLASS_SPD,\n\t.algo\t\t= &smbus_algorithm,\n};\n\nstatic const struct pci_device_id ali1535_ids[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_AL, PCI_DEVICE_ID_AL_M7101) },\n\t{ },\n};\n\nMODULE_DEVICE_TABLE(pci, ali1535_ids);\n\nstatic int ali1535_probe(struct pci_dev *dev, const struct pci_device_id *id)\n{\n\tif (ali1535_setup(dev)) {\n\t\tdev_warn(&dev->dev,\n\t\t\t\"ALI1535 not detected, module not inserted.\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tali1535_adapter.dev.parent = &dev->dev;\n\n\tsnprintf(ali1535_adapter.name, sizeof(ali1535_adapter.name),\n\t\t\"SMBus ALI1535 adapter at %04x\", ali1535_offset);\n\treturn i2c_add_adapter(&ali1535_adapter);\n}\n\nstatic void ali1535_remove(struct pci_dev *dev)\n{\n\ti2c_del_adapter(&ali1535_adapter);\n\trelease_region(ali1535_smba, ALI1535_SMB_IOSIZE);\n\n\t \n}\n\nstatic struct pci_driver ali1535_driver = {\n\t.name\t\t= \"ali1535_smbus\",\n\t.id_table\t= ali1535_ids,\n\t.probe\t\t= ali1535_probe,\n\t.remove\t\t= ali1535_remove,\n};\n\nmodule_pci_driver(ali1535_driver);\n\nMODULE_AUTHOR(\"Frodo Looijaard <frodol@dds.nl>\");\nMODULE_AUTHOR(\"Philip Edelbrock <phil@netroedge.com>\");\nMODULE_AUTHOR(\"Mark D. Studebaker <mdsxyz123@yahoo.com>\");\nMODULE_AUTHOR(\"Dan Eaton <dan.eaton@rocketlogix.com>\");\nMODULE_DESCRIPTION(\"ALI1535 SMBus driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}