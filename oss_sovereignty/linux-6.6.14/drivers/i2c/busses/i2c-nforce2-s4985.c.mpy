{
  "module_name": "i2c-nforce2-s4985.c",
  "hash_id": "058874592341d2b3ef4743ca37c4288f82f4f560647bb2af42c0bc5782861591",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-nforce2-s4985.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/i2c.h>\n#include <linux/mutex.h>\n\nextern struct i2c_adapter *nforce2_smbus;\n\nstatic struct i2c_adapter *s4985_adapter;\nstatic struct i2c_algorithm *s4985_algo;\n\n \nstatic DEFINE_MUTEX(nforce2_lock);\n\nstatic s32 nforce2_access_virt0(struct i2c_adapter *adap, u16 addr,\n\t\t\t\tunsigned short flags, char read_write,\n\t\t\t\tu8 command, int size,\n\t\t\t\tunion i2c_smbus_data *data)\n{\n\tint error;\n\n\t \n\tif ((addr & 0xfc) == 0x50 || (addr & 0xfc) == 0x30\n\t || addr == 0x18)\n\t\treturn -ENXIO;\n\n\tmutex_lock(&nforce2_lock);\n\terror = nforce2_smbus->algo->smbus_xfer(adap, addr, flags, read_write,\n\t\t\t\t\t\tcommand, size, data);\n\tmutex_unlock(&nforce2_lock);\n\n\treturn error;\n}\n\n \nstatic u8 last_channels;\n\nstatic inline s32 nforce2_access_channel(struct i2c_adapter *adap, u16 addr,\n\t\t\t\t\t unsigned short flags, char read_write,\n\t\t\t\t\t u8 command, int size,\n\t\t\t\t\t union i2c_smbus_data *data,\n\t\t\t\t\t u8 channels)\n{\n\tint error;\n\n\t \n\tif ((addr & 0xfc) != 0x50 && (addr & 0xfc) != 0x30)\n\t\treturn -ENXIO;\n\n\tmutex_lock(&nforce2_lock);\n\tif (last_channels != channels) {\n\t\tunion i2c_smbus_data mplxdata;\n\t\tmplxdata.byte = channels;\n\n\t\terror = nforce2_smbus->algo->smbus_xfer(adap, 0x18, 0,\n\t\t\t\t\t\t\tI2C_SMBUS_WRITE, 0x01,\n\t\t\t\t\t\t\tI2C_SMBUS_BYTE_DATA,\n\t\t\t\t\t\t\t&mplxdata);\n\t\tif (error)\n\t\t\tgoto UNLOCK;\n\t\tlast_channels = channels;\n\t}\n\terror = nforce2_smbus->algo->smbus_xfer(adap, addr, flags, read_write,\n\t\t\t\t\t\tcommand, size, data);\n\nUNLOCK:\n\tmutex_unlock(&nforce2_lock);\n\treturn error;\n}\n\nstatic s32 nforce2_access_virt1(struct i2c_adapter *adap, u16 addr,\n\t\t\t\tunsigned short flags, char read_write,\n\t\t\t\tu8 command, int size,\n\t\t\t\tunion i2c_smbus_data *data)\n{\n\t \n\treturn nforce2_access_channel(adap, addr, flags, read_write, command,\n\t\t\t\t      size, data, 0x02);\n}\n\nstatic s32 nforce2_access_virt2(struct i2c_adapter *adap, u16 addr,\n\t\t\t\tunsigned short flags, char read_write,\n\t\t\t\tu8 command, int size,\n\t\t\t\tunion i2c_smbus_data *data)\n{\n\t \n\treturn nforce2_access_channel(adap, addr, flags, read_write, command,\n\t\t\t\t      size, data, 0x04);\n}\n\nstatic s32 nforce2_access_virt3(struct i2c_adapter *adap, u16 addr,\n\t\t\t\tunsigned short flags, char read_write,\n\t\t\t\tu8 command, int size,\n\t\t\t\tunion i2c_smbus_data *data)\n{\n\t \n\treturn nforce2_access_channel(adap, addr, flags, read_write, command,\n\t\t\t\t      size, data, 0x08);\n}\n\nstatic s32 nforce2_access_virt4(struct i2c_adapter *adap, u16 addr,\n\t\t\t\tunsigned short flags, char read_write,\n\t\t\t\tu8 command, int size,\n\t\t\t\tunion i2c_smbus_data *data)\n{\n\t \n\treturn nforce2_access_channel(adap, addr, flags, read_write, command,\n\t\t\t\t      size, data, 0x10);\n}\n\nstatic int __init nforce2_s4985_init(void)\n{\n\tint i, error;\n\tunion i2c_smbus_data ioconfig;\n\n\tif (!nforce2_smbus)\n\t\treturn -ENODEV;\n\n\t \n\tioconfig.byte = 0x00;  \n\terror = i2c_smbus_xfer(nforce2_smbus, 0x18, 0, I2C_SMBUS_WRITE, 0x03,\n\t\t\t       I2C_SMBUS_BYTE_DATA, &ioconfig);\n\tif (error) {\n\t\tdev_err(&nforce2_smbus->dev, \"PCA9556 configuration failed\\n\");\n\t\terror = -EIO;\n\t\tgoto ERROR0;\n\t}\n\n\t \n\ti2c_del_adapter(nforce2_smbus);\n\n\tprintk(KERN_INFO \"Enabling SMBus multiplexing for Tyan S4985\\n\");\n\t \n\ts4985_adapter = kcalloc(5, sizeof(struct i2c_adapter), GFP_KERNEL);\n\tif (!s4985_adapter) {\n\t\terror = -ENOMEM;\n\t\tgoto ERROR1;\n\t}\n\ts4985_algo = kcalloc(5, sizeof(struct i2c_algorithm), GFP_KERNEL);\n\tif (!s4985_algo) {\n\t\terror = -ENOMEM;\n\t\tgoto ERROR2;\n\t}\n\n\t \n\ts4985_algo[0] = *(nforce2_smbus->algo);\n\ts4985_algo[0].smbus_xfer = nforce2_access_virt0;\n\ts4985_adapter[0] = *nforce2_smbus;\n\ts4985_adapter[0].algo = s4985_algo;\n\ts4985_adapter[0].dev.parent = nforce2_smbus->dev.parent;\n\tfor (i = 1; i < 5; i++) {\n\t\ts4985_algo[i] = *(nforce2_smbus->algo);\n\t\ts4985_adapter[i] = *nforce2_smbus;\n\t\tsnprintf(s4985_adapter[i].name, sizeof(s4985_adapter[i].name),\n\t\t\t \"SMBus nForce2 adapter (CPU%d)\", i - 1);\n\t\ts4985_adapter[i].algo = s4985_algo + i;\n\t\ts4985_adapter[i].dev.parent = nforce2_smbus->dev.parent;\n\t}\n\ts4985_algo[1].smbus_xfer = nforce2_access_virt1;\n\ts4985_algo[2].smbus_xfer = nforce2_access_virt2;\n\ts4985_algo[3].smbus_xfer = nforce2_access_virt3;\n\ts4985_algo[4].smbus_xfer = nforce2_access_virt4;\n\n\t \n\tfor (i = 0; i < 5; i++) {\n\t\terror = i2c_add_adapter(s4985_adapter + i);\n\t\tif (error) {\n\t\t\tprintk(KERN_ERR \"i2c-nforce2-s4985: \"\n\t\t\t       \"Virtual adapter %d registration \"\n\t\t\t       \"failed, module not inserted\\n\", i);\n\t\t\tfor (i--; i >= 0; i--)\n\t\t\t\ti2c_del_adapter(s4985_adapter + i);\n\t\t\tgoto ERROR3;\n\t\t}\n\t}\n\n\treturn 0;\n\nERROR3:\n\tkfree(s4985_algo);\n\ts4985_algo = NULL;\nERROR2:\n\tkfree(s4985_adapter);\n\ts4985_adapter = NULL;\nERROR1:\n\t \n\ti2c_add_adapter(nforce2_smbus);\nERROR0:\n\treturn error;\n}\n\nstatic void __exit nforce2_s4985_exit(void)\n{\n\tif (s4985_adapter) {\n\t\tint i;\n\n\t\tfor (i = 0; i < 5; i++)\n\t\t\ti2c_del_adapter(s4985_adapter+i);\n\t\tkfree(s4985_adapter);\n\t\ts4985_adapter = NULL;\n\t}\n\tkfree(s4985_algo);\n\ts4985_algo = NULL;\n\n\t \n\tif (i2c_add_adapter(nforce2_smbus))\n\t\tprintk(KERN_ERR \"i2c-nforce2-s4985: \"\n\t\t       \"Physical bus restoration failed\\n\");\n}\n\nMODULE_AUTHOR(\"Jean Delvare <jdelvare@suse.de>\");\nMODULE_DESCRIPTION(\"S4985 SMBus multiplexing\");\nMODULE_LICENSE(\"GPL\");\n\nmodule_init(nforce2_s4985_init);\nmodule_exit(nforce2_s4985_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}