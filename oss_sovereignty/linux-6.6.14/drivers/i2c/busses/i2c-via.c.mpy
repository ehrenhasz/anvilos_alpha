{
  "module_name": "i2c-via.c",
  "hash_id": "961556f1b33effcc428357340b4ddbe01744b87fded41720028f31b12f7d3056",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-via.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/ioport.h>\n#include <linux/i2c.h>\n#include <linux/i2c-algo-bit.h>\n#include <linux/io.h>\n\n \n#define PM_CFG_REVID\t0x08\t \n#define PM_CFG_IOBASE0\t0x20\n#define PM_CFG_IOBASE1\t0x48\n\n#define I2C_DIR\t\t(pm_io_base+0x40)\n#define I2C_OUT\t\t(pm_io_base+0x42)\n#define I2C_IN\t\t(pm_io_base+0x44)\n#define I2C_SCL\t\t0x02\t \n#define I2C_SDA\t\t0x04\n\n \n#define IOSPACE\t\t0x06\n\nstatic struct pci_driver vt586b_driver;\nstatic u16 pm_io_base;\n\n \nstatic void bit_via_setscl(void *data, int state)\n{\n\toutb(state ? inb(I2C_DIR) & ~I2C_SCL : inb(I2C_DIR) | I2C_SCL, I2C_DIR);\n}\n\nstatic void bit_via_setsda(void *data, int state)\n{\n\toutb(state ? inb(I2C_DIR) & ~I2C_SDA : inb(I2C_DIR) | I2C_SDA, I2C_DIR);\n}\n\nstatic int bit_via_getscl(void *data)\n{\n\treturn (0 != (inb(I2C_IN) & I2C_SCL));\n}\n\nstatic int bit_via_getsda(void *data)\n{\n\treturn (0 != (inb(I2C_IN) & I2C_SDA));\n}\n\n\nstatic struct i2c_algo_bit_data bit_data = {\n\t.setsda\t\t= bit_via_setsda,\n\t.setscl\t\t= bit_via_setscl,\n\t.getsda\t\t= bit_via_getsda,\n\t.getscl\t\t= bit_via_getscl,\n\t.udelay\t\t= 5,\n\t.timeout\t= HZ\n};\n\nstatic struct i2c_adapter vt586b_adapter = {\n\t.owner\t\t= THIS_MODULE,\n\t.class          = I2C_CLASS_HWMON | I2C_CLASS_SPD,\n\t.name\t\t= \"VIA i2c\",\n\t.algo_data\t= &bit_data,\n};\n\n\nstatic const struct pci_device_id vt586b_ids[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_VIA, PCI_DEVICE_ID_VIA_82C586_3) },\n\t{ 0, }\n};\n\nMODULE_DEVICE_TABLE (pci, vt586b_ids);\n\nstatic int vt586b_probe(struct pci_dev *dev, const struct pci_device_id *id)\n{\n\tu16 base;\n\tu8 rev;\n\tint res;\n\n\tif (pm_io_base) {\n\t\tdev_err(&dev->dev, \"i2c-via: Will only support one host\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tpci_read_config_byte(dev, PM_CFG_REVID, &rev);\n\n\tswitch (rev) {\n\tcase 0x00:\n\t\tbase = PM_CFG_IOBASE0;\n\t\tbreak;\n\tcase 0x01:\n\tcase 0x10:\n\t\tbase = PM_CFG_IOBASE1;\n\t\tbreak;\n\n\tdefault:\n\t\tbase = PM_CFG_IOBASE1;\n\t\t \n\t}\n\n\tpci_read_config_word(dev, base, &pm_io_base);\n\tpm_io_base &= (0xff << 8);\n\n\tif (!request_region(I2C_DIR, IOSPACE, vt586b_driver.name)) {\n\t\tdev_err(&dev->dev, \"IO 0x%x-0x%x already in use\\n\", I2C_DIR, I2C_DIR + IOSPACE);\n\t\treturn -ENODEV;\n\t}\n\n\toutb(inb(I2C_DIR) & ~(I2C_SDA | I2C_SCL), I2C_DIR);\n\toutb(inb(I2C_OUT) & ~(I2C_SDA | I2C_SCL), I2C_OUT);\n\n\t \n\tvt586b_adapter.dev.parent = &dev->dev;\n\n\tres = i2c_bit_add_bus(&vt586b_adapter);\n\tif ( res < 0 ) {\n\t\trelease_region(I2C_DIR, IOSPACE);\n\t\tpm_io_base = 0;\n\t\treturn res;\n\t}\n\treturn 0;\n}\n\nstatic void vt586b_remove(struct pci_dev *dev)\n{\n\ti2c_del_adapter(&vt586b_adapter);\n\trelease_region(I2C_DIR, IOSPACE);\n\tpm_io_base = 0;\n}\n\n\nstatic struct pci_driver vt586b_driver = {\n\t.name\t\t= \"vt586b_smbus\",\n\t.id_table\t= vt586b_ids,\n\t.probe\t\t= vt586b_probe,\n\t.remove\t\t= vt586b_remove,\n};\n\nmodule_pci_driver(vt586b_driver);\n\nMODULE_AUTHOR(\"Ky\u00f6sti M\u00e4lkki <kmalkki@cc.hut.fi>\");\nMODULE_DESCRIPTION(\"i2c for Via vt82c586b southbridge\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}