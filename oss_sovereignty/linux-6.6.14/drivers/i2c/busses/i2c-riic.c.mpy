{
  "module_name": "i2c-riic.c",
  "hash_id": "91ba4aaac556c4cb1a9a66ef0b110fc0044af1db56150a0abfb54eb3c3a81506",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-riic.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/clk.h>\n#include <linux/completion.h>\n#include <linux/err.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/reset.h>\n\n#define RIIC_ICCR1\t0x00\n#define RIIC_ICCR2\t0x04\n#define RIIC_ICMR1\t0x08\n#define RIIC_ICMR3\t0x10\n#define RIIC_ICSER\t0x18\n#define RIIC_ICIER\t0x1c\n#define RIIC_ICSR2\t0x24\n#define RIIC_ICBRL\t0x34\n#define RIIC_ICBRH\t0x38\n#define RIIC_ICDRT\t0x3c\n#define RIIC_ICDRR\t0x40\n\n#define ICCR1_ICE\t0x80\n#define ICCR1_IICRST\t0x40\n#define ICCR1_SOWP\t0x10\n\n#define ICCR2_BBSY\t0x80\n#define ICCR2_SP\t0x08\n#define ICCR2_RS\t0x04\n#define ICCR2_ST\t0x02\n\n#define ICMR1_CKS_MASK\t0x70\n#define ICMR1_BCWP\t0x08\n#define ICMR1_CKS(_x)\t((((_x) << 4) & ICMR1_CKS_MASK) | ICMR1_BCWP)\n\n#define ICMR3_RDRFS\t0x20\n#define ICMR3_ACKWP\t0x10\n#define ICMR3_ACKBT\t0x08\n\n#define ICIER_TIE\t0x80\n#define ICIER_TEIE\t0x40\n#define ICIER_RIE\t0x20\n#define ICIER_NAKIE\t0x10\n#define ICIER_SPIE\t0x08\n\n#define ICSR2_NACKF\t0x10\n\n#define ICBR_RESERVED\t0xe0  \n\n#define RIIC_INIT_MSG\t-1\n\nstruct riic_dev {\n\tvoid __iomem *base;\n\tu8 *buf;\n\tstruct i2c_msg *msg;\n\tint bytes_left;\n\tint err;\n\tint is_last;\n\tstruct completion msg_done;\n\tstruct i2c_adapter adapter;\n\tstruct clk *clk;\n};\n\nstruct riic_irq_desc {\n\tint res_num;\n\tirq_handler_t isr;\n\tchar *name;\n};\n\nstatic inline void riic_clear_set_bit(struct riic_dev *riic, u8 clear, u8 set, u8 reg)\n{\n\twriteb((readb(riic->base + reg) & ~clear) | set, riic->base + reg);\n}\n\nstatic int riic_xfer(struct i2c_adapter *adap, struct i2c_msg msgs[], int num)\n{\n\tstruct riic_dev *riic = i2c_get_adapdata(adap);\n\tunsigned long time_left;\n\tint i;\n\tu8 start_bit;\n\n\tpm_runtime_get_sync(adap->dev.parent);\n\n\tif (readb(riic->base + RIIC_ICCR2) & ICCR2_BBSY) {\n\t\triic->err = -EBUSY;\n\t\tgoto out;\n\t}\n\n\treinit_completion(&riic->msg_done);\n\triic->err = 0;\n\n\twriteb(0, riic->base + RIIC_ICSR2);\n\n\tfor (i = 0, start_bit = ICCR2_ST; i < num; i++) {\n\t\triic->bytes_left = RIIC_INIT_MSG;\n\t\triic->buf = msgs[i].buf;\n\t\triic->msg = &msgs[i];\n\t\triic->is_last = (i == num - 1);\n\n\t\twriteb(ICIER_NAKIE | ICIER_TIE, riic->base + RIIC_ICIER);\n\n\t\twriteb(start_bit, riic->base + RIIC_ICCR2);\n\n\t\ttime_left = wait_for_completion_timeout(&riic->msg_done, riic->adapter.timeout);\n\t\tif (time_left == 0)\n\t\t\triic->err = -ETIMEDOUT;\n\n\t\tif (riic->err)\n\t\t\tbreak;\n\n\t\tstart_bit = ICCR2_RS;\n\t}\n\n out:\n\tpm_runtime_put(adap->dev.parent);\n\n\treturn riic->err ?: num;\n}\n\nstatic irqreturn_t riic_tdre_isr(int irq, void *data)\n{\n\tstruct riic_dev *riic = data;\n\tu8 val;\n\n\tif (!riic->bytes_left)\n\t\treturn IRQ_NONE;\n\n\tif (riic->bytes_left == RIIC_INIT_MSG) {\n\t\tif (riic->msg->flags & I2C_M_RD)\n\t\t\t \n\t\t\triic_clear_set_bit(riic, ICIER_TIE, ICIER_RIE, RIIC_ICIER);\n\t\telse\n\t\t\t \n\t\t\triic->bytes_left = riic->msg->len;\n\n\t\tval = i2c_8bit_addr_from_msg(riic->msg);\n\t} else {\n\t\tval = *riic->buf;\n\t\triic->buf++;\n\t\triic->bytes_left--;\n\t}\n\n\t \n\tif (riic->bytes_left == 0)\n\t\triic_clear_set_bit(riic, ICIER_TIE, ICIER_TEIE, RIIC_ICIER);\n\n\t \n\twriteb(val, riic->base + RIIC_ICDRT);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t riic_tend_isr(int irq, void *data)\n{\n\tstruct riic_dev *riic = data;\n\n\tif (readb(riic->base + RIIC_ICSR2) & ICSR2_NACKF) {\n\t\t \n\t\treadb(riic->base + RIIC_ICDRR);\t \n\t\triic_clear_set_bit(riic, ICSR2_NACKF, 0, RIIC_ICSR2);\n\t\triic->err = -ENXIO;\n\t} else if (riic->bytes_left) {\n\t\treturn IRQ_NONE;\n\t}\n\n\tif (riic->is_last || riic->err) {\n\t\triic_clear_set_bit(riic, ICIER_TEIE, ICIER_SPIE, RIIC_ICIER);\n\t\twriteb(ICCR2_SP, riic->base + RIIC_ICCR2);\n\t} else {\n\t\t \n\t\triic_clear_set_bit(riic, ICIER_TEIE, 0, RIIC_ICIER);\n\t\tcomplete(&riic->msg_done);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t riic_rdrf_isr(int irq, void *data)\n{\n\tstruct riic_dev *riic = data;\n\n\tif (!riic->bytes_left)\n\t\treturn IRQ_NONE;\n\n\tif (riic->bytes_left == RIIC_INIT_MSG) {\n\t\triic->bytes_left = riic->msg->len;\n\t\treadb(riic->base + RIIC_ICDRR);\t \n\t\treturn IRQ_HANDLED;\n\t}\n\n\tif (riic->bytes_left == 1) {\n\t\t \n\t\tif (riic->is_last) {\n\t\t\triic_clear_set_bit(riic, 0, ICIER_SPIE, RIIC_ICIER);\n\t\t\twriteb(ICCR2_SP, riic->base + RIIC_ICCR2);\n\t\t}\n\n\t\triic_clear_set_bit(riic, 0, ICMR3_ACKBT, RIIC_ICMR3);\n\n\t} else {\n\t\triic_clear_set_bit(riic, ICMR3_ACKBT, 0, RIIC_ICMR3);\n\t}\n\n\t \n\t*riic->buf = readb(riic->base + RIIC_ICDRR);\n\triic->buf++;\n\triic->bytes_left--;\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t riic_stop_isr(int irq, void *data)\n{\n\tstruct riic_dev *riic = data;\n\n\t \n\twriteb(0, riic->base + RIIC_ICSR2);\n\treadb(riic->base + RIIC_ICSR2);\n\twriteb(0, riic->base + RIIC_ICIER);\n\treadb(riic->base + RIIC_ICIER);\n\n\tcomplete(&riic->msg_done);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic u32 riic_func(struct i2c_adapter *adap)\n{\n\treturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;\n}\n\nstatic const struct i2c_algorithm riic_algo = {\n\t.master_xfer\t= riic_xfer,\n\t.functionality\t= riic_func,\n};\n\nstatic int riic_init_hw(struct riic_dev *riic, struct i2c_timings *t)\n{\n\tint ret = 0;\n\tunsigned long rate;\n\tint total_ticks, cks, brl, brh;\n\n\tpm_runtime_get_sync(riic->adapter.dev.parent);\n\n\tif (t->bus_freq_hz > I2C_MAX_FAST_MODE_FREQ) {\n\t\tdev_err(&riic->adapter.dev,\n\t\t\t\"unsupported bus speed (%dHz). %d max\\n\",\n\t\t\tt->bus_freq_hz, I2C_MAX_FAST_MODE_FREQ);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\trate = clk_get_rate(riic->clk);\n\n\t \n\n\t \n\ttotal_ticks = DIV_ROUND_UP(rate, t->bus_freq_hz);\n\n\tfor (cks = 0; cks < 7; cks++) {\n\t\t \n\t\tbrl = ((total_ticks * 6) / 10);\n\t\tif (brl <= (0x1F + 3))\n\t\t\tbreak;\n\n\t\ttotal_ticks /= 2;\n\t\trate /= 2;\n\t}\n\n\tif (brl > (0x1F + 3)) {\n\t\tdev_err(&riic->adapter.dev, \"invalid speed (%lu). Too slow.\\n\",\n\t\t\t(unsigned long)t->bus_freq_hz);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tbrh = total_ticks - brl;\n\n\t \n\tif (cks == 0) {\n\t\tbrl -= 4;\n\t\tbrh -= 4;\n\t} else {\n\t\tbrl -= 3;\n\t\tbrh -= 3;\n\t}\n\n\t \n\tbrl -= t->scl_fall_ns / (1000000000 / rate);\n\tbrh -= t->scl_rise_ns / (1000000000 / rate);\n\n\t \n\tif (brl < 1)\n\t\tbrl = 1;\n\tif (brh < 1)\n\t\tbrh = 1;\n\n\tpr_debug(\"i2c-riic: freq=%lu, duty=%d, fall=%lu, rise=%lu, cks=%d, brl=%d, brh=%d\\n\",\n\t\t rate / total_ticks, ((brl + 3) * 100) / (brl + brh + 6),\n\t\t t->scl_fall_ns / (1000000000 / rate),\n\t\t t->scl_rise_ns / (1000000000 / rate), cks, brl, brh);\n\n\t \n\twriteb(ICCR1_IICRST | ICCR1_SOWP, riic->base + RIIC_ICCR1);\n\triic_clear_set_bit(riic, 0, ICCR1_ICE, RIIC_ICCR1);\n\n\twriteb(ICMR1_CKS(cks), riic->base + RIIC_ICMR1);\n\twriteb(brh | ICBR_RESERVED, riic->base + RIIC_ICBRH);\n\twriteb(brl | ICBR_RESERVED, riic->base + RIIC_ICBRL);\n\n\twriteb(0, riic->base + RIIC_ICSER);\n\twriteb(ICMR3_ACKWP | ICMR3_RDRFS, riic->base + RIIC_ICMR3);\n\n\triic_clear_set_bit(riic, ICCR1_IICRST, 0, RIIC_ICCR1);\n\nout:\n\tpm_runtime_put(riic->adapter.dev.parent);\n\treturn ret;\n}\n\nstatic struct riic_irq_desc riic_irqs[] = {\n\t{ .res_num = 0, .isr = riic_tend_isr, .name = \"riic-tend\" },\n\t{ .res_num = 1, .isr = riic_rdrf_isr, .name = \"riic-rdrf\" },\n\t{ .res_num = 2, .isr = riic_tdre_isr, .name = \"riic-tdre\" },\n\t{ .res_num = 3, .isr = riic_stop_isr, .name = \"riic-stop\" },\n\t{ .res_num = 5, .isr = riic_tend_isr, .name = \"riic-nack\" },\n};\n\nstatic void riic_reset_control_assert(void *data)\n{\n\treset_control_assert(data);\n}\n\nstatic int riic_i2c_probe(struct platform_device *pdev)\n{\n\tstruct riic_dev *riic;\n\tstruct i2c_adapter *adap;\n\tstruct i2c_timings i2c_t;\n\tstruct reset_control *rstc;\n\tint i, ret;\n\n\triic = devm_kzalloc(&pdev->dev, sizeof(*riic), GFP_KERNEL);\n\tif (!riic)\n\t\treturn -ENOMEM;\n\n\triic->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(riic->base))\n\t\treturn PTR_ERR(riic->base);\n\n\triic->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(riic->clk)) {\n\t\tdev_err(&pdev->dev, \"missing controller clock\");\n\t\treturn PTR_ERR(riic->clk);\n\t}\n\n\trstc = devm_reset_control_get_optional_exclusive(&pdev->dev, NULL);\n\tif (IS_ERR(rstc))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(rstc),\n\t\t\t\t     \"Error: missing reset ctrl\\n\");\n\n\tret = reset_control_deassert(rstc);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_add_action_or_reset(&pdev->dev, riic_reset_control_assert, rstc);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < ARRAY_SIZE(riic_irqs); i++) {\n\t\tret = platform_get_irq(pdev, riic_irqs[i].res_num);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = devm_request_irq(&pdev->dev, ret, riic_irqs[i].isr,\n\t\t\t\t       0, riic_irqs[i].name, riic);\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev, \"failed to request irq %s\\n\", riic_irqs[i].name);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tadap = &riic->adapter;\n\ti2c_set_adapdata(adap, riic);\n\tstrscpy(adap->name, \"Renesas RIIC adapter\", sizeof(adap->name));\n\tadap->owner = THIS_MODULE;\n\tadap->algo = &riic_algo;\n\tadap->dev.parent = &pdev->dev;\n\tadap->dev.of_node = pdev->dev.of_node;\n\n\tinit_completion(&riic->msg_done);\n\n\ti2c_parse_fw_timings(&pdev->dev, &i2c_t, true);\n\n\tpm_runtime_enable(&pdev->dev);\n\n\tret = riic_init_hw(riic, &i2c_t);\n\tif (ret)\n\t\tgoto out;\n\n\tret = i2c_add_adapter(adap);\n\tif (ret)\n\t\tgoto out;\n\n\tplatform_set_drvdata(pdev, riic);\n\n\tdev_info(&pdev->dev, \"registered with %dHz bus speed\\n\",\n\t\t i2c_t.bus_freq_hz);\n\treturn 0;\n\nout:\n\tpm_runtime_disable(&pdev->dev);\n\treturn ret;\n}\n\nstatic void riic_i2c_remove(struct platform_device *pdev)\n{\n\tstruct riic_dev *riic = platform_get_drvdata(pdev);\n\n\tpm_runtime_get_sync(&pdev->dev);\n\twriteb(0, riic->base + RIIC_ICIER);\n\tpm_runtime_put(&pdev->dev);\n\ti2c_del_adapter(&riic->adapter);\n\tpm_runtime_disable(&pdev->dev);\n}\n\nstatic const struct of_device_id riic_i2c_dt_ids[] = {\n\t{ .compatible = \"renesas,riic-rz\", },\n\t{   },\n};\n\nstatic struct platform_driver riic_i2c_driver = {\n\t.probe\t\t= riic_i2c_probe,\n\t.remove_new\t= riic_i2c_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"i2c-riic\",\n\t\t.of_match_table = riic_i2c_dt_ids,\n\t},\n};\n\nmodule_platform_driver(riic_i2c_driver);\n\nMODULE_DESCRIPTION(\"Renesas RIIC adapter\");\nMODULE_AUTHOR(\"Wolfram Sang <wsa@sang-engineering.com>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DEVICE_TABLE(of, riic_i2c_dt_ids);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}