{
  "module_name": "i2c-xiic.c",
  "hash_id": "7d3891f2e5f740891dbe2846b09f593619bf7098f24f653f2b21d52a971baa32",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-xiic.c",
  "human_readable_source": "\n \n\n \n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/platform_device.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/completion.h>\n#include <linux/platform_data/i2c-xiic.h>\n#include <linux/io.h>\n#include <linux/slab.h>\n#include <linux/of.h>\n#include <linux/clk.h>\n#include <linux/pm_runtime.h>\n\n#define DRIVER_NAME \"xiic-i2c\"\n#define DYNAMIC_MODE_READ_BROKEN_BIT\tBIT(0)\n#define SMBUS_BLOCK_READ_MIN_LEN\t3\n\nenum xilinx_i2c_state {\n\tSTATE_DONE,\n\tSTATE_ERROR,\n\tSTATE_START\n};\n\nenum xiic_endian {\n\tLITTLE,\n\tBIG\n};\n\nenum i2c_scl_freq {\n\tREG_VALUES_100KHZ = 0,\n\tREG_VALUES_400KHZ = 1,\n\tREG_VALUES_1MHZ = 2\n};\n\n \nstruct xiic_i2c {\n\tstruct device *dev;\n\tvoid __iomem *base;\n\tstruct completion completion;\n\tstruct i2c_adapter adap;\n\tstruct i2c_msg *tx_msg;\n\tstruct mutex lock;\n\tunsigned int tx_pos;\n\tunsigned int nmsgs;\n\tstruct i2c_msg *rx_msg;\n\tint rx_pos;\n\tenum xiic_endian endianness;\n\tstruct clk *clk;\n\tenum xilinx_i2c_state state;\n\tbool singlemaster;\n\tbool dynamic;\n\tbool prev_msg_tx;\n\tu32 quirks;\n\tbool smbus_block_read;\n\tunsigned long input_clk;\n\tunsigned int i2c_clk;\n};\n\nstruct xiic_version_data {\n\tu32 quirks;\n};\n\n \nstruct timing_regs {\n\tunsigned int tsusta;\n\tunsigned int tsusto;\n\tunsigned int thdsta;\n\tunsigned int tsudat;\n\tunsigned int tbuf;\n};\n\n \nstatic const struct timing_regs timing_reg_values[] = {\n\t{ 5700, 5000, 4300, 550, 5000 },  \n\t{ 900, 900, 900, 400, 1600 },     \n\t{ 380, 380, 380, 170, 620 },      \n};\n\n#define XIIC_MSB_OFFSET 0\n#define XIIC_REG_OFFSET (0x100 + XIIC_MSB_OFFSET)\n\n \n#define XIIC_CR_REG_OFFSET   (0x00 + XIIC_REG_OFFSET)\t \n#define XIIC_SR_REG_OFFSET   (0x04 + XIIC_REG_OFFSET)\t \n#define XIIC_DTR_REG_OFFSET  (0x08 + XIIC_REG_OFFSET)\t \n#define XIIC_DRR_REG_OFFSET  (0x0C + XIIC_REG_OFFSET)\t \n#define XIIC_ADR_REG_OFFSET  (0x10 + XIIC_REG_OFFSET)\t \n#define XIIC_TFO_REG_OFFSET  (0x14 + XIIC_REG_OFFSET)\t \n#define XIIC_RFO_REG_OFFSET  (0x18 + XIIC_REG_OFFSET)\t \n#define XIIC_TBA_REG_OFFSET  (0x1C + XIIC_REG_OFFSET)\t \n#define XIIC_RFD_REG_OFFSET  (0x20 + XIIC_REG_OFFSET)\t \n#define XIIC_GPO_REG_OFFSET  (0x24 + XIIC_REG_OFFSET)\t \n\n \n#define XIIC_TSUSTA_REG_OFFSET (0x28 + XIIC_REG_OFFSET)  \n#define XIIC_TSUSTO_REG_OFFSET (0x2C + XIIC_REG_OFFSET)  \n#define XIIC_THDSTA_REG_OFFSET (0x30 + XIIC_REG_OFFSET)  \n#define XIIC_TSUDAT_REG_OFFSET (0x34 + XIIC_REG_OFFSET)  \n#define XIIC_TBUF_REG_OFFSET   (0x38 + XIIC_REG_OFFSET)  \n#define XIIC_THIGH_REG_OFFSET  (0x3C + XIIC_REG_OFFSET)  \n#define XIIC_TLOW_REG_OFFSET   (0x40 + XIIC_REG_OFFSET)  \n#define XIIC_THDDAT_REG_OFFSET (0x44 + XIIC_REG_OFFSET)  \n\n \n#define XIIC_CR_ENABLE_DEVICE_MASK        0x01\t \n#define XIIC_CR_TX_FIFO_RESET_MASK        0x02\t \n#define XIIC_CR_MSMS_MASK                 0x04\t \n#define XIIC_CR_DIR_IS_TX_MASK            0x08\t \n#define XIIC_CR_NO_ACK_MASK               0x10\t \n#define XIIC_CR_REPEATED_START_MASK       0x20\t \n#define XIIC_CR_GENERAL_CALL_MASK         0x40\t \n\n \n#define XIIC_SR_GEN_CALL_MASK             0x01\t \n#define XIIC_SR_ADDR_AS_SLAVE_MASK        0x02\t \n#define XIIC_SR_BUS_BUSY_MASK             0x04\t \n#define XIIC_SR_MSTR_RDING_SLAVE_MASK     0x08\t \n#define XIIC_SR_TX_FIFO_FULL_MASK         0x10\t \n#define XIIC_SR_RX_FIFO_FULL_MASK         0x20\t \n#define XIIC_SR_RX_FIFO_EMPTY_MASK        0x40\t \n#define XIIC_SR_TX_FIFO_EMPTY_MASK        0x80\t \n\n \n#define XIIC_INTR_ARB_LOST_MASK           0x01\t \n#define XIIC_INTR_TX_ERROR_MASK           0x02\t \n#define XIIC_INTR_TX_EMPTY_MASK           0x04\t \n#define XIIC_INTR_RX_FULL_MASK            0x08\t \n#define XIIC_INTR_BNB_MASK                0x10\t \n#define XIIC_INTR_AAS_MASK                0x20\t \n#define XIIC_INTR_NAAS_MASK               0x40\t \n#define XIIC_INTR_TX_HALF_MASK            0x80\t \n\n \n#define IIC_RX_FIFO_DEPTH         16\t \n#define IIC_TX_FIFO_DEPTH         16\t \n\n \n#define XIIC_TX_INTERRUPTS                           \\\n(XIIC_INTR_TX_ERROR_MASK | XIIC_INTR_TX_EMPTY_MASK | XIIC_INTR_TX_HALF_MASK)\n\n#define XIIC_TX_RX_INTERRUPTS (XIIC_INTR_RX_FULL_MASK | XIIC_TX_INTERRUPTS)\n\n \n#define XIIC_TX_DYN_START_MASK            0x0100  \n#define XIIC_TX_DYN_STOP_MASK             0x0200  \n\n \n#define MAX_READ_LENGTH_DYNAMIC                255  \n\n \n#define XIIC_DGIER_OFFSET    0x1C  \n#define XIIC_IISR_OFFSET     0x20  \n#define XIIC_IIER_OFFSET     0x28  \n#define XIIC_RESETR_OFFSET   0x40  \n\n#define XIIC_RESET_MASK             0xAUL\n\n#define XIIC_PM_TIMEOUT\t\t1000\t \n \n#define XIIC_I2C_TIMEOUT\t(msecs_to_jiffies(1000))\n \n#define XIIC_XFER_TIMEOUT\t(msecs_to_jiffies(10000))\n\n \n#define XIIC_GINTR_ENABLE_MASK      0x80000000UL\n\n#define xiic_tx_space(i2c) ((i2c)->tx_msg->len - (i2c)->tx_pos)\n#define xiic_rx_space(i2c) ((i2c)->rx_msg->len - (i2c)->rx_pos)\n\nstatic int xiic_start_xfer(struct xiic_i2c *i2c, struct i2c_msg *msgs, int num);\nstatic void __xiic_start_xfer(struct xiic_i2c *i2c);\n\n \n\nstatic inline void xiic_setreg8(struct xiic_i2c *i2c, int reg, u8 value)\n{\n\tif (i2c->endianness == LITTLE)\n\t\tiowrite8(value, i2c->base + reg);\n\telse\n\t\tiowrite8(value, i2c->base + reg + 3);\n}\n\nstatic inline u8 xiic_getreg8(struct xiic_i2c *i2c, int reg)\n{\n\tu8 ret;\n\n\tif (i2c->endianness == LITTLE)\n\t\tret = ioread8(i2c->base + reg);\n\telse\n\t\tret = ioread8(i2c->base + reg + 3);\n\treturn ret;\n}\n\nstatic inline void xiic_setreg16(struct xiic_i2c *i2c, int reg, u16 value)\n{\n\tif (i2c->endianness == LITTLE)\n\t\tiowrite16(value, i2c->base + reg);\n\telse\n\t\tiowrite16be(value, i2c->base + reg + 2);\n}\n\nstatic inline void xiic_setreg32(struct xiic_i2c *i2c, int reg, int value)\n{\n\tif (i2c->endianness == LITTLE)\n\t\tiowrite32(value, i2c->base + reg);\n\telse\n\t\tiowrite32be(value, i2c->base + reg);\n}\n\nstatic inline int xiic_getreg32(struct xiic_i2c *i2c, int reg)\n{\n\tu32 ret;\n\n\tif (i2c->endianness == LITTLE)\n\t\tret = ioread32(i2c->base + reg);\n\telse\n\t\tret = ioread32be(i2c->base + reg);\n\treturn ret;\n}\n\nstatic inline void xiic_irq_dis(struct xiic_i2c *i2c, u32 mask)\n{\n\tu32 ier = xiic_getreg32(i2c, XIIC_IIER_OFFSET);\n\n\txiic_setreg32(i2c, XIIC_IIER_OFFSET, ier & ~mask);\n}\n\nstatic inline void xiic_irq_en(struct xiic_i2c *i2c, u32 mask)\n{\n\tu32 ier = xiic_getreg32(i2c, XIIC_IIER_OFFSET);\n\n\txiic_setreg32(i2c, XIIC_IIER_OFFSET, ier | mask);\n}\n\nstatic inline void xiic_irq_clr(struct xiic_i2c *i2c, u32 mask)\n{\n\tu32 isr = xiic_getreg32(i2c, XIIC_IISR_OFFSET);\n\n\txiic_setreg32(i2c, XIIC_IISR_OFFSET, isr & mask);\n}\n\nstatic inline void xiic_irq_clr_en(struct xiic_i2c *i2c, u32 mask)\n{\n\txiic_irq_clr(i2c, mask);\n\txiic_irq_en(i2c, mask);\n}\n\nstatic int xiic_clear_rx_fifo(struct xiic_i2c *i2c)\n{\n\tu8 sr;\n\tunsigned long timeout;\n\n\ttimeout = jiffies + XIIC_I2C_TIMEOUT;\n\tfor (sr = xiic_getreg8(i2c, XIIC_SR_REG_OFFSET);\n\t\t!(sr & XIIC_SR_RX_FIFO_EMPTY_MASK);\n\t\tsr = xiic_getreg8(i2c, XIIC_SR_REG_OFFSET)) {\n\t\txiic_getreg8(i2c, XIIC_DRR_REG_OFFSET);\n\t\tif (time_after(jiffies, timeout)) {\n\t\t\tdev_err(i2c->dev, \"Failed to clear rx fifo\\n\");\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int xiic_wait_tx_empty(struct xiic_i2c *i2c)\n{\n\tu8 isr;\n\tunsigned long timeout;\n\n\ttimeout = jiffies + XIIC_I2C_TIMEOUT;\n\tfor (isr = xiic_getreg32(i2c, XIIC_IISR_OFFSET);\n\t\t!(isr & XIIC_INTR_TX_EMPTY_MASK);\n\t\t\tisr = xiic_getreg32(i2c, XIIC_IISR_OFFSET)) {\n\t\tif (time_after(jiffies, timeout)) {\n\t\t\tdev_err(i2c->dev, \"Timeout waiting at Tx empty\\n\");\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int xiic_setclk(struct xiic_i2c *i2c)\n{\n\tunsigned int clk_in_mhz;\n\tunsigned int index = 0;\n\tu32 reg_val;\n\n\tdev_dbg(i2c->adap.dev.parent,\n\t\t\"%s entry, i2c->input_clk: %ld, i2c->i2c_clk: %d\\n\",\n\t\t__func__, i2c->input_clk, i2c->i2c_clk);\n\n\t \n\tif (!i2c->i2c_clk || !i2c->input_clk)\n\t\treturn 0;\n\n\tclk_in_mhz = DIV_ROUND_UP(i2c->input_clk, 1000000);\n\n\tswitch (i2c->i2c_clk) {\n\tcase I2C_MAX_FAST_MODE_PLUS_FREQ:\n\t\tindex = REG_VALUES_1MHZ;\n\t\tbreak;\n\tcase I2C_MAX_FAST_MODE_FREQ:\n\t\tindex = REG_VALUES_400KHZ;\n\t\tbreak;\n\tcase I2C_MAX_STANDARD_MODE_FREQ:\n\t\tindex = REG_VALUES_100KHZ;\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(i2c->adap.dev.parent, \"Unsupported scl frequency\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\n\t \n\treg_val = (DIV_ROUND_UP(i2c->input_clk, 2 * i2c->i2c_clk)) - 7;\n\tif (reg_val == 0)\n\t\treturn -EINVAL;\n\n\txiic_setreg32(i2c, XIIC_THIGH_REG_OFFSET, reg_val - 1);\n\n\t \n\txiic_setreg32(i2c, XIIC_TLOW_REG_OFFSET, reg_val - 1);\n\n\t \n\treg_val = (timing_reg_values[index].tsusta * clk_in_mhz) / 1000;\n\txiic_setreg32(i2c, XIIC_TSUSTA_REG_OFFSET, reg_val - 1);\n\n\t \n\treg_val = (timing_reg_values[index].tsusto * clk_in_mhz) / 1000;\n\txiic_setreg32(i2c, XIIC_TSUSTO_REG_OFFSET, reg_val - 1);\n\n\t \n\treg_val = (timing_reg_values[index].thdsta * clk_in_mhz) / 1000;\n\txiic_setreg32(i2c, XIIC_THDSTA_REG_OFFSET, reg_val - 1);\n\n\t \n\treg_val = (timing_reg_values[index].tsudat * clk_in_mhz) / 1000;\n\txiic_setreg32(i2c, XIIC_TSUDAT_REG_OFFSET, reg_val - 1);\n\n\t \n\treg_val = (timing_reg_values[index].tbuf * clk_in_mhz) / 1000;\n\txiic_setreg32(i2c, XIIC_TBUF_REG_OFFSET, reg_val - 1);\n\n\t \n\txiic_setreg32(i2c, XIIC_THDDAT_REG_OFFSET, 1);\n\n\treturn 0;\n}\n\nstatic int xiic_reinit(struct xiic_i2c *i2c)\n{\n\tint ret;\n\n\txiic_setreg32(i2c, XIIC_RESETR_OFFSET, XIIC_RESET_MASK);\n\n\tret = xiic_setclk(i2c);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\txiic_setreg8(i2c, XIIC_RFD_REG_OFFSET, IIC_RX_FIFO_DEPTH - 1);\n\n\t \n\txiic_setreg8(i2c, XIIC_CR_REG_OFFSET, XIIC_CR_TX_FIFO_RESET_MASK);\n\n\t \n\txiic_setreg8(i2c, XIIC_CR_REG_OFFSET, XIIC_CR_ENABLE_DEVICE_MASK);\n\n\t \n\tret = xiic_clear_rx_fifo(i2c);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\txiic_setreg32(i2c, XIIC_DGIER_OFFSET, XIIC_GINTR_ENABLE_MASK);\n\n\txiic_irq_clr_en(i2c, XIIC_INTR_ARB_LOST_MASK);\n\n\treturn 0;\n}\n\nstatic void xiic_deinit(struct xiic_i2c *i2c)\n{\n\tu8 cr;\n\n\txiic_setreg32(i2c, XIIC_RESETR_OFFSET, XIIC_RESET_MASK);\n\n\t \n\tcr = xiic_getreg8(i2c, XIIC_CR_REG_OFFSET);\n\txiic_setreg8(i2c, XIIC_CR_REG_OFFSET, cr & ~XIIC_CR_ENABLE_DEVICE_MASK);\n}\n\nstatic void xiic_smbus_block_read_setup(struct xiic_i2c *i2c)\n{\n\tu8 rxmsg_len, rfd_set = 0;\n\n\t \n\ti2c->rx_msg->flags &= ~I2C_M_RECV_LEN;\n\n\t \n\ti2c->smbus_block_read = true;\n\n\t \n\trxmsg_len = xiic_getreg8(i2c, XIIC_DRR_REG_OFFSET);\n\n\ti2c->rx_msg->buf[i2c->rx_pos++] = rxmsg_len;\n\n\t \n\tif (rxmsg_len <= I2C_SMBUS_BLOCK_MAX) {\n\t\t \n\t\tif (rxmsg_len > IIC_RX_FIFO_DEPTH) {\n\t\t\t \n\t\t\trfd_set = IIC_RX_FIFO_DEPTH - 1;\n\t\t\ti2c->rx_msg->len = rxmsg_len + 1;\n\t\t} else if ((rxmsg_len == 1) ||\n\t\t\t(rxmsg_len == 0)) {\n\t\t\t \n\t\t\trfd_set = 0;\n\t\t\ti2c->rx_msg->len = SMBUS_BLOCK_READ_MIN_LEN;\n\t\t} else {\n\t\t\t \n\t\t\trfd_set = rxmsg_len - 2;\n\t\t\ti2c->rx_msg->len = rxmsg_len + 1;\n\t\t}\n\t\txiic_setreg8(i2c, XIIC_RFD_REG_OFFSET, rfd_set);\n\n\t\treturn;\n\t}\n\n\t \n\ti2c->tx_msg->len = 3;\n\ti2c->smbus_block_read = false;\n\tdev_err(i2c->adap.dev.parent, \"smbus_block_read Invalid msg length\\n\");\n}\n\nstatic void xiic_read_rx(struct xiic_i2c *i2c)\n{\n\tu8 bytes_in_fifo, cr = 0, bytes_to_read = 0;\n\tu32 bytes_rem = 0;\n\tint i;\n\n\tbytes_in_fifo = xiic_getreg8(i2c, XIIC_RFO_REG_OFFSET) + 1;\n\n\tdev_dbg(i2c->adap.dev.parent,\n\t\t\"%s entry, bytes in fifo: %d, rem: %d, SR: 0x%x, CR: 0x%x\\n\",\n\t\t__func__, bytes_in_fifo, xiic_rx_space(i2c),\n\t\txiic_getreg8(i2c, XIIC_SR_REG_OFFSET),\n\t\txiic_getreg8(i2c, XIIC_CR_REG_OFFSET));\n\n\tif (bytes_in_fifo > xiic_rx_space(i2c))\n\t\tbytes_in_fifo = xiic_rx_space(i2c);\n\n\tbytes_to_read = bytes_in_fifo;\n\n\tif (!i2c->dynamic) {\n\t\tbytes_rem = xiic_rx_space(i2c) - bytes_in_fifo;\n\n\t\t \n\t\tif (i2c->rx_msg->flags & I2C_M_RECV_LEN) {\n\t\t\txiic_smbus_block_read_setup(i2c);\n\t\t\treturn;\n\t\t}\n\n\t\tif (bytes_rem > IIC_RX_FIFO_DEPTH) {\n\t\t\tbytes_to_read = bytes_in_fifo;\n\t\t} else if (bytes_rem > 1) {\n\t\t\tbytes_to_read = bytes_rem - 1;\n\t\t} else if (bytes_rem == 1) {\n\t\t\tbytes_to_read = 1;\n\t\t\t \n\t\t\tcr = xiic_getreg8(i2c, XIIC_CR_REG_OFFSET);\n\t\t\txiic_setreg8(i2c, XIIC_CR_REG_OFFSET, cr |\n\t\t\t\t\tXIIC_CR_NO_ACK_MASK);\n\t\t} else if (bytes_rem == 0) {\n\t\t\tbytes_to_read = bytes_in_fifo;\n\n\t\t\t \n\t\t\tif (i2c->nmsgs == 1) {\n\t\t\t\tcr = xiic_getreg8(i2c, XIIC_CR_REG_OFFSET);\n\t\t\t\txiic_setreg8(i2c, XIIC_CR_REG_OFFSET, cr &\n\t\t\t\t\t\t~XIIC_CR_MSMS_MASK);\n\t\t\t}\n\n\t\t\t \n\t\t\tcr = xiic_getreg8(i2c, XIIC_CR_REG_OFFSET);\n\t\t\txiic_setreg8(i2c, XIIC_CR_REG_OFFSET, cr &\n\t\t\t\t\t~XIIC_CR_NO_ACK_MASK);\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < bytes_to_read; i++) {\n\t\ti2c->rx_msg->buf[i2c->rx_pos++] =\n\t\t\txiic_getreg8(i2c, XIIC_DRR_REG_OFFSET);\n\t}\n\n\tif (i2c->dynamic) {\n\t\tu8 bytes;\n\n\t\t \n\t\tbytes = min_t(u8, xiic_rx_space(i2c), IIC_RX_FIFO_DEPTH);\n\t\tbytes--;\n\t\txiic_setreg8(i2c, XIIC_RFD_REG_OFFSET, bytes);\n\t}\n}\n\nstatic int xiic_tx_fifo_space(struct xiic_i2c *i2c)\n{\n\t \n\treturn IIC_TX_FIFO_DEPTH - xiic_getreg8(i2c, XIIC_TFO_REG_OFFSET) - 1;\n}\n\nstatic void xiic_fill_tx_fifo(struct xiic_i2c *i2c)\n{\n\tu8 fifo_space = xiic_tx_fifo_space(i2c);\n\tint len = xiic_tx_space(i2c);\n\n\tlen = (len > fifo_space) ? fifo_space : len;\n\n\tdev_dbg(i2c->adap.dev.parent, \"%s entry, len: %d, fifo space: %d\\n\",\n\t\t__func__, len, fifo_space);\n\n\twhile (len--) {\n\t\tu16 data = i2c->tx_msg->buf[i2c->tx_pos++];\n\n\t\tif (!xiic_tx_space(i2c) && i2c->nmsgs == 1) {\n\t\t\t \n\t\t\tif (i2c->dynamic) {\n\t\t\t\tdata |= XIIC_TX_DYN_STOP_MASK;\n\t\t\t} else {\n\t\t\t\tu8 cr;\n\t\t\t\tint status;\n\n\t\t\t\t \n\t\t\t\tstatus = xiic_wait_tx_empty(i2c);\n\t\t\t\tif (status)\n\t\t\t\t\treturn;\n\n\t\t\t\t \n\t\t\t\tcr = xiic_getreg8(i2c, XIIC_CR_REG_OFFSET);\n\t\t\t\txiic_setreg8(i2c, XIIC_CR_REG_OFFSET, cr &\n\t\t\t\t\t     ~XIIC_CR_MSMS_MASK);\n\t\t\t}\n\t\t\tdev_dbg(i2c->adap.dev.parent, \"%s TX STOP\\n\", __func__);\n\t\t}\n\t\txiic_setreg16(i2c, XIIC_DTR_REG_OFFSET, data);\n\t}\n}\n\nstatic void xiic_wakeup(struct xiic_i2c *i2c, enum xilinx_i2c_state code)\n{\n\ti2c->tx_msg = NULL;\n\ti2c->rx_msg = NULL;\n\ti2c->nmsgs = 0;\n\ti2c->state = code;\n\tcomplete(&i2c->completion);\n}\n\nstatic irqreturn_t xiic_process(int irq, void *dev_id)\n{\n\tstruct xiic_i2c *i2c = dev_id;\n\tu32 pend, isr, ier;\n\tu32 clr = 0;\n\tint xfer_more = 0;\n\tint wakeup_req = 0;\n\tenum xilinx_i2c_state wakeup_code = STATE_DONE;\n\tint ret;\n\n\t \n\tmutex_lock(&i2c->lock);\n\tisr = xiic_getreg32(i2c, XIIC_IISR_OFFSET);\n\tier = xiic_getreg32(i2c, XIIC_IIER_OFFSET);\n\tpend = isr & ier;\n\n\tdev_dbg(i2c->adap.dev.parent, \"%s: IER: 0x%x, ISR: 0x%x, pend: 0x%x\\n\",\n\t\t__func__, ier, isr, pend);\n\tdev_dbg(i2c->adap.dev.parent, \"%s: SR: 0x%x, msg: %p, nmsgs: %d\\n\",\n\t\t__func__, xiic_getreg8(i2c, XIIC_SR_REG_OFFSET),\n\t\ti2c->tx_msg, i2c->nmsgs);\n\tdev_dbg(i2c->adap.dev.parent, \"%s, ISR: 0x%x, CR: 0x%x\\n\",\n\t\t__func__, xiic_getreg32(i2c, XIIC_IISR_OFFSET),\n\t\txiic_getreg8(i2c, XIIC_CR_REG_OFFSET));\n\n\t \n\tif ((pend & XIIC_INTR_ARB_LOST_MASK) ||\n\t    ((pend & XIIC_INTR_TX_ERROR_MASK) &&\n\t    !(pend & XIIC_INTR_RX_FULL_MASK))) {\n\t\t \n\n\t\tdev_dbg(i2c->adap.dev.parent, \"%s error\\n\", __func__);\n\n\t\t \n\t\tret = xiic_reinit(i2c);\n\t\tif (ret < 0)\n\t\t\tdev_dbg(i2c->adap.dev.parent, \"reinit failed\\n\");\n\n\t\tif (i2c->rx_msg) {\n\t\t\twakeup_req = 1;\n\t\t\twakeup_code = STATE_ERROR;\n\t\t}\n\t\tif (i2c->tx_msg) {\n\t\t\twakeup_req = 1;\n\t\t\twakeup_code = STATE_ERROR;\n\t\t}\n\t\t \n\t\tgoto out;\n\t}\n\tif (pend & XIIC_INTR_RX_FULL_MASK) {\n\t\t \n\n\t\tclr |= XIIC_INTR_RX_FULL_MASK;\n\t\tif (!i2c->rx_msg) {\n\t\t\tdev_dbg(i2c->adap.dev.parent,\n\t\t\t\t\"%s unexpected RX IRQ\\n\", __func__);\n\t\t\txiic_clear_rx_fifo(i2c);\n\t\t\tgoto out;\n\t\t}\n\n\t\txiic_read_rx(i2c);\n\t\tif (xiic_rx_space(i2c) == 0) {\n\t\t\t \n\t\t\ti2c->rx_msg = NULL;\n\n\t\t\t \n\t\t\tclr |= (isr & XIIC_INTR_TX_ERROR_MASK);\n\n\t\t\tdev_dbg(i2c->adap.dev.parent,\n\t\t\t\t\"%s end of message, nmsgs: %d\\n\",\n\t\t\t\t__func__, i2c->nmsgs);\n\n\t\t\t \n\t\t\tif (i2c->nmsgs > 1) {\n\t\t\t\ti2c->nmsgs--;\n\t\t\t\ti2c->tx_msg++;\n\t\t\t\tdev_dbg(i2c->adap.dev.parent,\n\t\t\t\t\t\"%s will start next...\\n\", __func__);\n\t\t\t\txfer_more = 1;\n\t\t\t}\n\t\t}\n\t}\n\tif (pend & (XIIC_INTR_TX_EMPTY_MASK | XIIC_INTR_TX_HALF_MASK)) {\n\t\t \n\n\t\tclr |= (pend &\n\t\t\t(XIIC_INTR_TX_EMPTY_MASK | XIIC_INTR_TX_HALF_MASK));\n\n\t\tif (!i2c->tx_msg) {\n\t\t\tdev_dbg(i2c->adap.dev.parent,\n\t\t\t\t\"%s unexpected TX IRQ\\n\", __func__);\n\t\t\tgoto out;\n\t\t}\n\n\t\txiic_fill_tx_fifo(i2c);\n\n\t\t \n\t\tif (!xiic_tx_space(i2c) && xiic_tx_fifo_space(i2c) >= 2) {\n\t\t\tdev_dbg(i2c->adap.dev.parent,\n\t\t\t\t\"%s end of message sent, nmsgs: %d\\n\",\n\t\t\t\t__func__, i2c->nmsgs);\n\t\t\tif (i2c->nmsgs > 1) {\n\t\t\t\ti2c->nmsgs--;\n\t\t\t\ti2c->tx_msg++;\n\t\t\t\txfer_more = 1;\n\t\t\t} else {\n\t\t\t\txiic_irq_dis(i2c, XIIC_INTR_TX_HALF_MASK);\n\n\t\t\t\tdev_dbg(i2c->adap.dev.parent,\n\t\t\t\t\t\"%s Got TX IRQ but no more to do...\\n\",\n\t\t\t\t\t__func__);\n\t\t\t}\n\t\t} else if (!xiic_tx_space(i2c) && (i2c->nmsgs == 1))\n\t\t\t \n\t\t\txiic_irq_dis(i2c, XIIC_INTR_TX_HALF_MASK);\n\t}\n\n\tif (pend & XIIC_INTR_BNB_MASK) {\n\t\t \n\t\tclr |= XIIC_INTR_BNB_MASK;\n\n\t\t \n\t\txiic_irq_dis(i2c, XIIC_INTR_BNB_MASK);\n\n\t\tif (i2c->tx_msg && i2c->smbus_block_read) {\n\t\t\ti2c->smbus_block_read = false;\n\t\t\t \n\t\t\ti2c->tx_msg->len = 1;\n\t\t}\n\n\t\tif (!i2c->tx_msg)\n\t\t\tgoto out;\n\n\t\twakeup_req = 1;\n\n\t\tif (i2c->nmsgs == 1 && !i2c->rx_msg &&\n\t\t    xiic_tx_space(i2c) == 0)\n\t\t\twakeup_code = STATE_DONE;\n\t\telse\n\t\t\twakeup_code = STATE_ERROR;\n\t}\n\nout:\n\tdev_dbg(i2c->adap.dev.parent, \"%s clr: 0x%x\\n\", __func__, clr);\n\n\txiic_setreg32(i2c, XIIC_IISR_OFFSET, clr);\n\tif (xfer_more)\n\t\t__xiic_start_xfer(i2c);\n\tif (wakeup_req)\n\t\txiic_wakeup(i2c, wakeup_code);\n\n\tWARN_ON(xfer_more && wakeup_req);\n\n\tmutex_unlock(&i2c->lock);\n\treturn IRQ_HANDLED;\n}\n\nstatic int xiic_bus_busy(struct xiic_i2c *i2c)\n{\n\tu8 sr = xiic_getreg8(i2c, XIIC_SR_REG_OFFSET);\n\n\treturn (sr & XIIC_SR_BUS_BUSY_MASK) ? -EBUSY : 0;\n}\n\nstatic int xiic_busy(struct xiic_i2c *i2c)\n{\n\tint tries = 3;\n\tint err;\n\n\tif (i2c->tx_msg || i2c->rx_msg)\n\t\treturn -EBUSY;\n\n\t \n\tif (i2c->singlemaster) {\n\t\treturn 0;\n\t}\n\n\t \n\terr = xiic_bus_busy(i2c);\n\twhile (err && tries--) {\n\t\tmsleep(1);\n\t\terr = xiic_bus_busy(i2c);\n\t}\n\n\treturn err;\n}\n\nstatic void xiic_start_recv(struct xiic_i2c *i2c)\n{\n\tu16 rx_watermark;\n\tu8 cr = 0, rfd_set = 0;\n\tstruct i2c_msg *msg = i2c->rx_msg = i2c->tx_msg;\n\n\tdev_dbg(i2c->adap.dev.parent, \"%s entry, ISR: 0x%x, CR: 0x%x\\n\",\n\t\t__func__, xiic_getreg32(i2c, XIIC_IISR_OFFSET),\n\t\txiic_getreg8(i2c, XIIC_CR_REG_OFFSET));\n\n\t \n\txiic_irq_dis(i2c, XIIC_INTR_TX_HALF_MASK | XIIC_INTR_TX_EMPTY_MASK);\n\n\tif (i2c->dynamic) {\n\t\tu8 bytes;\n\t\tu16 val;\n\n\t\t \n\t\txiic_irq_clr_en(i2c, XIIC_INTR_RX_FULL_MASK |\n\t\t\t\tXIIC_INTR_TX_ERROR_MASK);\n\n\t\t \n\t\trx_watermark = msg->len;\n\t\tbytes = min_t(u8, rx_watermark, IIC_RX_FIFO_DEPTH);\n\n\t\tif (rx_watermark > 0)\n\t\t\tbytes--;\n\t\txiic_setreg8(i2c, XIIC_RFD_REG_OFFSET, bytes);\n\n\t\t \n\t\txiic_setreg16(i2c, XIIC_DTR_REG_OFFSET,\n\t\t\t      i2c_8bit_addr_from_msg(msg) |\n\t\t\t      XIIC_TX_DYN_START_MASK);\n\n\t\t \n\t\tval = (i2c->nmsgs == 1) ? XIIC_TX_DYN_STOP_MASK : 0;\n\t\tval |= msg->len;\n\n\t\txiic_setreg16(i2c, XIIC_DTR_REG_OFFSET, val);\n\n\t\txiic_irq_clr_en(i2c, XIIC_INTR_BNB_MASK);\n\t} else {\n\t\t \n\t\tif (i2c->prev_msg_tx) {\n\t\t\tint status;\n\n\t\t\tstatus = xiic_wait_tx_empty(i2c);\n\t\t\tif (status)\n\t\t\t\treturn;\n\t\t}\n\n\t\tcr = xiic_getreg8(i2c, XIIC_CR_REG_OFFSET);\n\n\t\t \n\t\trx_watermark = msg->len;\n\t\tif (rx_watermark > IIC_RX_FIFO_DEPTH) {\n\t\t\trfd_set = IIC_RX_FIFO_DEPTH - 1;\n\t\t} else if (rx_watermark == 1) {\n\t\t\trfd_set = rx_watermark - 1;\n\n\t\t\t \n\t\t\tif (!(i2c->rx_msg->flags & I2C_M_RECV_LEN)) {\n\t\t\t\t \n\t\t\t\tcr |= XIIC_CR_NO_ACK_MASK;\n\t\t\t}\n\t\t} else if (rx_watermark == 0) {\n\t\t\trfd_set = rx_watermark;\n\t\t} else {\n\t\t\trfd_set = rx_watermark - 2;\n\t\t}\n\t\t \n\t\tif (cr & XIIC_CR_MSMS_MASK) {\n\t\t\t \n\t\t\txiic_setreg8(i2c, XIIC_CR_REG_OFFSET, (cr |\n\t\t\t\t\tXIIC_CR_REPEATED_START_MASK) &\n\t\t\t\t\t~(XIIC_CR_DIR_IS_TX_MASK));\n\t\t}\n\n\t\txiic_setreg8(i2c, XIIC_RFD_REG_OFFSET, rfd_set);\n\n\t\t \n\t\txiic_irq_clr_en(i2c, XIIC_INTR_RX_FULL_MASK |\n\t\t\t\tXIIC_INTR_TX_ERROR_MASK);\n\n\t\t \n\t\txiic_setreg16(i2c, XIIC_DTR_REG_OFFSET,\n\t\t\t      i2c_8bit_addr_from_msg(msg));\n\n\t\t \n\t\tif ((cr & XIIC_CR_MSMS_MASK) == 0) {\n\t\t\txiic_setreg8(i2c, XIIC_CR_REG_OFFSET, (cr |\n\t\t\t\t\tXIIC_CR_MSMS_MASK)\n\t\t\t\t\t& ~(XIIC_CR_DIR_IS_TX_MASK));\n\t\t}\n\t\tdev_dbg(i2c->adap.dev.parent, \"%s end, ISR: 0x%x, CR: 0x%x\\n\",\n\t\t\t__func__, xiic_getreg32(i2c, XIIC_IISR_OFFSET),\n\t\t\txiic_getreg8(i2c, XIIC_CR_REG_OFFSET));\n\t}\n\n\tif (i2c->nmsgs == 1)\n\t\t \n\t\txiic_irq_clr_en(i2c, XIIC_INTR_BNB_MASK);\n\n\t \n\ti2c->tx_pos = msg->len;\n\n\t \n\txiic_setreg32(i2c, XIIC_DGIER_OFFSET, XIIC_GINTR_ENABLE_MASK);\n\n\ti2c->prev_msg_tx = false;\n}\n\nstatic void xiic_start_send(struct xiic_i2c *i2c)\n{\n\tu8 cr = 0;\n\tu16 data;\n\tstruct i2c_msg *msg = i2c->tx_msg;\n\n\tdev_dbg(i2c->adap.dev.parent, \"%s entry, msg: %p, len: %d\",\n\t\t__func__, msg, msg->len);\n\tdev_dbg(i2c->adap.dev.parent, \"%s entry, ISR: 0x%x, CR: 0x%x\\n\",\n\t\t__func__, xiic_getreg32(i2c, XIIC_IISR_OFFSET),\n\t\txiic_getreg8(i2c, XIIC_CR_REG_OFFSET));\n\n\tif (i2c->dynamic) {\n\t\t \n\t\tdata = i2c_8bit_addr_from_msg(msg) |\n\t\t\t\tXIIC_TX_DYN_START_MASK;\n\n\t\tif (i2c->nmsgs == 1 && msg->len == 0)\n\t\t\t \n\t\t\tdata |= XIIC_TX_DYN_STOP_MASK;\n\n\t\txiic_setreg16(i2c, XIIC_DTR_REG_OFFSET, data);\n\n\t\t \n\t\txiic_irq_clr_en(i2c, XIIC_INTR_TX_EMPTY_MASK |\n\t\t\t\tXIIC_INTR_TX_ERROR_MASK |\n\t\t\t\tXIIC_INTR_BNB_MASK |\n\t\t\t\t((i2c->nmsgs > 1 || xiic_tx_space(i2c)) ?\n\t\t\t\tXIIC_INTR_TX_HALF_MASK : 0));\n\n\t\txiic_fill_tx_fifo(i2c);\n\t} else {\n\t\t \n\t\tif (i2c->prev_msg_tx) {\n\t\t\tint status;\n\n\t\t\tstatus = xiic_wait_tx_empty(i2c);\n\t\t\tif (status)\n\t\t\t\treturn;\n\t\t}\n\t\t \n\t\tcr = xiic_getreg8(i2c, XIIC_CR_REG_OFFSET);\n\t\tif (cr & XIIC_CR_MSMS_MASK) {\n\t\t\t \n\t\t\txiic_setreg8(i2c, XIIC_CR_REG_OFFSET, (cr |\n\t\t\t\t\tXIIC_CR_REPEATED_START_MASK |\n\t\t\t\t\tXIIC_CR_DIR_IS_TX_MASK) &\n\t\t\t\t\t~(XIIC_CR_NO_ACK_MASK));\n\t\t}\n\n\t\t \n\t\tdata = i2c_8bit_addr_from_msg(msg);\n\t\txiic_setreg16(i2c, XIIC_DTR_REG_OFFSET, data);\n\n\t\t \n\t\txiic_fill_tx_fifo(i2c);\n\n\t\tif ((cr & XIIC_CR_MSMS_MASK) == 0) {\n\t\t\t \n\t\t\tcr = xiic_getreg8(i2c, XIIC_CR_REG_OFFSET);\n\t\t\txiic_setreg8(i2c, XIIC_CR_REG_OFFSET, cr |\n\t\t\t\t\tXIIC_CR_MSMS_MASK |\n\t\t\t\t\tXIIC_CR_DIR_IS_TX_MASK);\n\t\t}\n\n\t\t \n\t\txiic_irq_clr_en(i2c, XIIC_INTR_TX_EMPTY_MASK |\n\t\t\t\tXIIC_INTR_TX_ERROR_MASK |\n\t\t\t\tXIIC_INTR_BNB_MASK);\n\t}\n\ti2c->prev_msg_tx = true;\n}\n\nstatic void __xiic_start_xfer(struct xiic_i2c *i2c)\n{\n\tint fifo_space = xiic_tx_fifo_space(i2c);\n\n\tdev_dbg(i2c->adap.dev.parent, \"%s entry, msg: %p, fifos space: %d\\n\",\n\t\t__func__, i2c->tx_msg, fifo_space);\n\n\tif (!i2c->tx_msg)\n\t\treturn;\n\n\ti2c->rx_pos = 0;\n\ti2c->tx_pos = 0;\n\ti2c->state = STATE_START;\n\tif (i2c->tx_msg->flags & I2C_M_RD) {\n\t\t \n\t\txiic_start_recv(i2c);\n\t} else {\n\t\txiic_start_send(i2c);\n\t}\n}\n\nstatic int xiic_start_xfer(struct xiic_i2c *i2c, struct i2c_msg *msgs, int num)\n{\n\tbool broken_read, max_read_len, smbus_blk_read;\n\tint ret, count;\n\n\tmutex_lock(&i2c->lock);\n\n\tret = xiic_busy(i2c);\n\tif (ret)\n\t\tgoto out;\n\n\ti2c->tx_msg = msgs;\n\ti2c->rx_msg = NULL;\n\ti2c->nmsgs = num;\n\tinit_completion(&i2c->completion);\n\n\t \n\ti2c->dynamic = true;\n\n\t \n\ti2c->prev_msg_tx = false;\n\n\t \n\tfor (count = 0; count < i2c->nmsgs; count++) {\n\t\tbroken_read = (i2c->quirks & DYNAMIC_MODE_READ_BROKEN_BIT) &&\n\t\t\t\t(i2c->tx_msg[count].flags & I2C_M_RD);\n\t\tmax_read_len = (i2c->tx_msg[count].flags & I2C_M_RD) &&\n\t\t\t\t(i2c->tx_msg[count].len > MAX_READ_LENGTH_DYNAMIC);\n\t\tsmbus_blk_read = (i2c->tx_msg[count].flags & I2C_M_RECV_LEN);\n\n\t\tif (broken_read || max_read_len || smbus_blk_read) {\n\t\t\ti2c->dynamic = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tret = xiic_reinit(i2c);\n\tif (!ret)\n\t\t__xiic_start_xfer(i2c);\n\nout:\n\tmutex_unlock(&i2c->lock);\n\n\treturn ret;\n}\n\nstatic int xiic_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)\n{\n\tstruct xiic_i2c *i2c = i2c_get_adapdata(adap);\n\tint err;\n\n\tdev_dbg(adap->dev.parent, \"%s entry SR: 0x%x\\n\", __func__,\n\t\txiic_getreg8(i2c, XIIC_SR_REG_OFFSET));\n\n\terr = pm_runtime_resume_and_get(i2c->dev);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = xiic_start_xfer(i2c, msgs, num);\n\tif (err < 0) {\n\t\tdev_err(adap->dev.parent, \"Error xiic_start_xfer\\n\");\n\t\tgoto out;\n\t}\n\n\terr = wait_for_completion_timeout(&i2c->completion, XIIC_XFER_TIMEOUT);\n\tmutex_lock(&i2c->lock);\n\tif (err == 0) {\t \n\t\ti2c->tx_msg = NULL;\n\t\ti2c->rx_msg = NULL;\n\t\ti2c->nmsgs = 0;\n\t\terr = -ETIMEDOUT;\n\t} else {\n\t\terr = (i2c->state == STATE_DONE) ? num : -EIO;\n\t}\n\tmutex_unlock(&i2c->lock);\n\nout:\n\tpm_runtime_mark_last_busy(i2c->dev);\n\tpm_runtime_put_autosuspend(i2c->dev);\n\treturn err;\n}\n\nstatic u32 xiic_func(struct i2c_adapter *adap)\n{\n\treturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL | I2C_FUNC_SMBUS_BLOCK_DATA;\n}\n\nstatic const struct i2c_algorithm xiic_algorithm = {\n\t.master_xfer = xiic_xfer,\n\t.functionality = xiic_func,\n};\n\nstatic const struct i2c_adapter xiic_adapter = {\n\t.owner = THIS_MODULE,\n\t.class = I2C_CLASS_DEPRECATED,\n\t.algo = &xiic_algorithm,\n};\n\n#if defined(CONFIG_OF)\nstatic const struct xiic_version_data xiic_2_00 = {\n\t.quirks = DYNAMIC_MODE_READ_BROKEN_BIT,\n};\n\nstatic const struct of_device_id xiic_of_match[] = {\n\t{ .compatible = \"xlnx,xps-iic-2.00.a\", .data = &xiic_2_00 },\n\t{ .compatible = \"xlnx,axi-iic-2.1\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, xiic_of_match);\n#endif\n\nstatic int xiic_i2c_probe(struct platform_device *pdev)\n{\n\tstruct xiic_i2c *i2c;\n\tstruct xiic_i2c_platform_data *pdata;\n\tconst struct of_device_id *match;\n\tstruct resource *res;\n\tint ret, irq;\n\tu8 i;\n\tu32 sr;\n\n\ti2c = devm_kzalloc(&pdev->dev, sizeof(*i2c), GFP_KERNEL);\n\tif (!i2c)\n\t\treturn -ENOMEM;\n\n\tmatch = of_match_node(xiic_of_match, pdev->dev.of_node);\n\tif (match && match->data) {\n\t\tconst struct xiic_version_data *data = match->data;\n\n\t\ti2c->quirks = data->quirks;\n\t}\n\n\ti2c->base = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(i2c->base))\n\t\treturn PTR_ERR(i2c->base);\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tpdata = dev_get_platdata(&pdev->dev);\n\n\t \n\tplatform_set_drvdata(pdev, i2c);\n\ti2c->adap = xiic_adapter;\n\ti2c_set_adapdata(&i2c->adap, i2c);\n\ti2c->adap.dev.parent = &pdev->dev;\n\ti2c->adap.dev.of_node = pdev->dev.of_node;\n\tsnprintf(i2c->adap.name, sizeof(i2c->adap.name),\n\t\t DRIVER_NAME \" %s\", pdev->name);\n\n\tmutex_init(&i2c->lock);\n\n\ti2c->clk = devm_clk_get_enabled(&pdev->dev, NULL);\n\tif (IS_ERR(i2c->clk))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(i2c->clk),\n\t\t\t\t     \"failed to enable input clock.\\n\");\n\n\ti2c->dev = &pdev->dev;\n\tpm_runtime_set_autosuspend_delay(i2c->dev, XIIC_PM_TIMEOUT);\n\tpm_runtime_use_autosuspend(i2c->dev);\n\tpm_runtime_set_active(i2c->dev);\n\tpm_runtime_enable(i2c->dev);\n\n\t \n\ti2c->input_clk = clk_get_rate(i2c->clk);\n\tret = of_property_read_u32(pdev->dev.of_node, \"clock-frequency\",\n\t\t\t\t   &i2c->i2c_clk);\n\t \n\tif (ret || i2c->i2c_clk > I2C_MAX_FAST_MODE_PLUS_FREQ)\n\t\ti2c->i2c_clk = 0;\n\n\tret = devm_request_threaded_irq(&pdev->dev, irq, NULL,\n\t\t\t\t\txiic_process, IRQF_ONESHOT,\n\t\t\t\t\tpdev->name, i2c);\n\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"Cannot claim IRQ\\n\");\n\t\tgoto err_pm_disable;\n\t}\n\n\ti2c->singlemaster =\n\t\tof_property_read_bool(pdev->dev.of_node, \"single-master\");\n\n\t \n\ti2c->endianness = LITTLE;\n\txiic_setreg32(i2c, XIIC_CR_REG_OFFSET, XIIC_CR_TX_FIFO_RESET_MASK);\n\t \n\tsr = xiic_getreg32(i2c, XIIC_SR_REG_OFFSET);\n\tif (!(sr & XIIC_SR_TX_FIFO_EMPTY_MASK))\n\t\ti2c->endianness = BIG;\n\n\tret = xiic_reinit(i2c);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"Cannot xiic_reinit\\n\");\n\t\tgoto err_pm_disable;\n\t}\n\n\t \n\tret = i2c_add_adapter(&i2c->adap);\n\tif (ret) {\n\t\txiic_deinit(i2c);\n\t\tgoto err_pm_disable;\n\t}\n\n\tif (pdata) {\n\t\t \n\t\tfor (i = 0; i < pdata->num_devices; i++)\n\t\t\ti2c_new_client_device(&i2c->adap, pdata->devices + i);\n\t}\n\n\tdev_dbg(&pdev->dev, \"mmio %08lx irq %d scl clock frequency %d\\n\",\n\t\t(unsigned long)res->start, irq, i2c->i2c_clk);\n\n\treturn 0;\n\nerr_pm_disable:\n\tpm_runtime_set_suspended(&pdev->dev);\n\tpm_runtime_disable(&pdev->dev);\n\n\treturn ret;\n}\n\nstatic void xiic_i2c_remove(struct platform_device *pdev)\n{\n\tstruct xiic_i2c *i2c = platform_get_drvdata(pdev);\n\tint ret;\n\n\t \n\ti2c_del_adapter(&i2c->adap);\n\n\tret = pm_runtime_get_sync(i2c->dev);\n\n\tif (ret < 0)\n\t\tdev_warn(&pdev->dev, \"Failed to activate device for removal (%pe)\\n\",\n\t\t\t ERR_PTR(ret));\n\telse\n\t\txiic_deinit(i2c);\n\n\tpm_runtime_put_sync(i2c->dev);\n\tpm_runtime_disable(&pdev->dev);\n\tpm_runtime_set_suspended(&pdev->dev);\n\tpm_runtime_dont_use_autosuspend(&pdev->dev);\n}\n\nstatic int __maybe_unused xiic_i2c_runtime_suspend(struct device *dev)\n{\n\tstruct xiic_i2c *i2c = dev_get_drvdata(dev);\n\n\tclk_disable(i2c->clk);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused xiic_i2c_runtime_resume(struct device *dev)\n{\n\tstruct xiic_i2c *i2c = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = clk_enable(i2c->clk);\n\tif (ret) {\n\t\tdev_err(dev, \"Cannot enable clock.\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops xiic_dev_pm_ops = {\n\tSET_RUNTIME_PM_OPS(xiic_i2c_runtime_suspend,\n\t\t\t   xiic_i2c_runtime_resume, NULL)\n};\n\nstatic struct platform_driver xiic_i2c_driver = {\n\t.probe   = xiic_i2c_probe,\n\t.remove_new = xiic_i2c_remove,\n\t.driver  = {\n\t\t.name = DRIVER_NAME,\n\t\t.of_match_table = of_match_ptr(xiic_of_match),\n\t\t.pm = &xiic_dev_pm_ops,\n\t},\n};\n\nmodule_platform_driver(xiic_i2c_driver);\n\nMODULE_ALIAS(\"platform:\" DRIVER_NAME);\nMODULE_AUTHOR(\"info@mocean-labs.com\");\nMODULE_DESCRIPTION(\"Xilinx I2C bus driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}