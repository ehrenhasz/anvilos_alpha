{
  "module_name": "i2c-eg20t.c",
  "hash_id": "018153b1f5cb4d127835877892186374d6412f6ec0f8ae1bbe1dc218a3bd1166",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-eg20t.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/delay.h>\n#include <linux/errno.h>\n#include <linux/i2c.h>\n#include <linux/fs.h>\n#include <linux/io.h>\n#include <linux/types.h>\n#include <linux/interrupt.h>\n#include <linux/jiffies.h>\n#include <linux/pci.h>\n#include <linux/mutex.h>\n#include <linux/ktime.h>\n#include <linux/slab.h>\n\n#define PCH_EVENT_SET\t0\t \n#define PCH_EVENT_NONE\t1\t \n#define PCH_MAX_CLK\t\t100000\t \n#define PCH_BUFFER_MODE_ENABLE\t0x0002\t \n#define PCH_EEPROM_SW_RST_MODE_ENABLE\t0x0008\t \n\n#define PCH_I2CSADR\t0x00\t \n#define PCH_I2CCTL\t0x04\t \n#define PCH_I2CSR\t0x08\t \n#define PCH_I2CDR\t0x0C\t \n#define PCH_I2CMON\t0x10\t \n#define PCH_I2CBC\t0x14\t \n#define PCH_I2CMOD\t0x18\t \n#define PCH_I2CBUFSLV\t0x1C\t \n#define PCH_I2CBUFSUB\t0x20\t \n#define PCH_I2CBUFFOR\t0x24\t \n#define PCH_I2CBUFCTL\t0x28\t \n#define PCH_I2CBUFMSK\t0x2C\t \n#define PCH_I2CBUFSTA\t0x30\t \n#define PCH_I2CBUFLEV\t0x34\t \n#define PCH_I2CESRFOR\t0x38\t \n#define PCH_I2CESRCTL\t0x3C\t \n#define PCH_I2CESRMSK\t0x40\t \n#define PCH_I2CESRSTA\t0x44\t \n#define PCH_I2CTMR\t0x48\t \n#define PCH_I2CSRST\t0xFC\t \n#define PCH_I2CNF\t0xF8\t \n\n#define BUS_IDLE_TIMEOUT\t20\n#define PCH_I2CCTL_I2CMEN\t0x0080\n#define TEN_BIT_ADDR_DEFAULT\t0xF000\n#define TEN_BIT_ADDR_MASK\t0xF0\n#define PCH_START\t\t0x0020\n#define PCH_RESTART\t\t0x0004\n#define PCH_ESR_START\t\t0x0001\n#define PCH_BUFF_START\t\t0x1\n#define PCH_REPSTART\t\t0x0004\n#define PCH_ACK\t\t\t0x0008\n#define PCH_GETACK\t\t0x0001\n#define CLR_REG\t\t\t0x0\n#define I2C_RD\t\t\t0x1\n#define I2CMCF_BIT\t\t0x0080\n#define I2CMIF_BIT\t\t0x0002\n#define I2CMAL_BIT\t\t0x0010\n#define I2CBMFI_BIT\t\t0x0001\n#define I2CBMAL_BIT\t\t0x0002\n#define I2CBMNA_BIT\t\t0x0004\n#define I2CBMTO_BIT\t\t0x0008\n#define I2CBMIS_BIT\t\t0x0010\n#define I2CESRFI_BIT\t\t0X0001\n#define I2CESRTO_BIT\t\t0x0002\n#define I2CESRFIIE_BIT\t\t0x1\n#define I2CESRTOIE_BIT\t\t0x2\n#define I2CBMDZ_BIT\t\t0x0040\n#define I2CBMAG_BIT\t\t0x0020\n#define I2CMBB_BIT\t\t0x0020\n#define BUFFER_MODE_MASK\t(I2CBMFI_BIT | I2CBMAL_BIT | I2CBMNA_BIT | \\\n\t\t\t\tI2CBMTO_BIT | I2CBMIS_BIT)\n#define I2C_ADDR_MSK\t\t0xFF\n#define I2C_MSB_2B_MSK\t\t0x300\n#define FAST_MODE_CLK\t\t400\n#define FAST_MODE_EN\t\t0x0001\n#define SUB_ADDR_LEN_MAX\t4\n#define BUF_LEN_MAX\t\t32\n#define PCH_BUFFER_MODE\t\t0x1\n#define EEPROM_SW_RST_MODE\t0x0002\n#define NORMAL_INTR_ENBL\t0x0300\n#define EEPROM_RST_INTR_ENBL\t(I2CESRFIIE_BIT | I2CESRTOIE_BIT)\n#define EEPROM_RST_INTR_DISBL\t0x0\n#define BUFFER_MODE_INTR_ENBL\t0x001F\n#define BUFFER_MODE_INTR_DISBL\t0x0\n#define NORMAL_MODE\t\t0x0\n#define BUFFER_MODE\t\t0x1\n#define EEPROM_SR_MODE\t\t0x2\n#define I2C_TX_MODE\t\t0x0010\n#define PCH_BUF_TX\t\t0xFFF7\n#define PCH_BUF_RD\t\t0x0008\n#define I2C_ERROR_MASK\t(I2CESRTO_EVENT | I2CBMIS_EVENT | I2CBMTO_EVENT | \\\n\t\t\tI2CBMNA_EVENT | I2CBMAL_EVENT | I2CMAL_EVENT)\n#define I2CMAL_EVENT\t\t0x0001\n#define I2CMCF_EVENT\t\t0x0002\n#define I2CBMFI_EVENT\t\t0x0004\n#define I2CBMAL_EVENT\t\t0x0008\n#define I2CBMNA_EVENT\t\t0x0010\n#define I2CBMTO_EVENT\t\t0x0020\n#define I2CBMIS_EVENT\t\t0x0040\n#define I2CESRFI_EVENT\t\t0x0080\n#define I2CESRTO_EVENT\t\t0x0100\n#define PCI_DEVICE_ID_PCH_I2C\t0x8817\n\n#define pch_dbg(adap, fmt, arg...)  \\\n\tdev_dbg(adap->pch_adapter.dev.parent, \"%s :\" fmt, __func__, ##arg)\n\n#define pch_err(adap, fmt, arg...)  \\\n\tdev_err(adap->pch_adapter.dev.parent, \"%s :\" fmt, __func__, ##arg)\n\n#define pch_pci_err(pdev, fmt, arg...)  \\\n\tdev_err(&pdev->dev, \"%s :\" fmt, __func__, ##arg)\n\n#define pch_pci_dbg(pdev, fmt, arg...)  \\\n\tdev_dbg(&pdev->dev, \"%s :\" fmt, __func__, ##arg)\n\n \n#define PCH_I2C_MAX_DEV\t\t\t2\n\n \nstruct i2c_algo_pch_data {\n\tstruct i2c_adapter pch_adapter;\n\tstruct adapter_info *p_adapter_info;\n\tvoid __iomem *pch_base_address;\n\tint pch_buff_mode_en;\n\tu32 pch_event_flag;\n\tbool pch_i2c_xfer_in_progress;\n};\n\n \nstruct adapter_info {\n\tstruct i2c_algo_pch_data pch_data[PCH_I2C_MAX_DEV];\n\tbool pch_i2c_suspended;\n\tint ch_num;\n};\n\n\nstatic int pch_i2c_speed = 100;  \nstatic int pch_clk = 50000;\t \nstatic wait_queue_head_t pch_event;\nstatic DEFINE_MUTEX(pch_mutex);\n\n \n#define PCI_DEVICE_ID_ML7213_I2C\t0x802D\n#define PCI_DEVICE_ID_ML7223_I2C\t0x8010\n#define PCI_DEVICE_ID_ML7831_I2C\t0x8817\n\nstatic const struct pci_device_id pch_pcidev_id[] = {\n\t{ PCI_VDEVICE(INTEL, PCI_DEVICE_ID_PCH_I2C),   1, },\n\t{ PCI_VDEVICE(ROHM, PCI_DEVICE_ID_ML7213_I2C), 2, },\n\t{ PCI_VDEVICE(ROHM, PCI_DEVICE_ID_ML7223_I2C), 1, },\n\t{ PCI_VDEVICE(ROHM, PCI_DEVICE_ID_ML7831_I2C), 1, },\n\t{0,}\n};\nMODULE_DEVICE_TABLE(pci, pch_pcidev_id);\n\nstatic irqreturn_t pch_i2c_handler(int irq, void *pData);\n\nstatic inline void pch_setbit(void __iomem *addr, u32 offset, u32 bitmask)\n{\n\tu32 val;\n\tval = ioread32(addr + offset);\n\tval |= bitmask;\n\tiowrite32(val, addr + offset);\n}\n\nstatic inline void pch_clrbit(void __iomem *addr, u32 offset, u32 bitmask)\n{\n\tu32 val;\n\tval = ioread32(addr + offset);\n\tval &= (~bitmask);\n\tiowrite32(val, addr + offset);\n}\n\n \nstatic void pch_i2c_init(struct i2c_algo_pch_data *adap)\n{\n\tvoid __iomem *p = adap->pch_base_address;\n\tu32 pch_i2cbc;\n\tu32 pch_i2ctmr;\n\tu32 reg_value;\n\n\t \n\tiowrite32(0x01, p + PCH_I2CSRST);\n\tmsleep(20);\n\tiowrite32(0x0, p + PCH_I2CSRST);\n\n\t \n\tiowrite32(0x21, p + PCH_I2CNF);\n\n\tpch_setbit(adap->pch_base_address, PCH_I2CCTL, PCH_I2CCTL_I2CMEN);\n\n\tif (pch_i2c_speed != 400)\n\t\tpch_i2c_speed = 100;\n\n\treg_value = PCH_I2CCTL_I2CMEN;\n\tif (pch_i2c_speed == FAST_MODE_CLK) {\n\t\treg_value |= FAST_MODE_EN;\n\t\tpch_dbg(adap, \"Fast mode enabled\\n\");\n\t}\n\n\tif (pch_clk > PCH_MAX_CLK)\n\t\tpch_clk = 62500;\n\n\tpch_i2cbc = (pch_clk + (pch_i2c_speed * 4)) / (pch_i2c_speed * 8);\n\t \n\tiowrite32(pch_i2cbc, p + PCH_I2CBC);\n\n\tpch_i2ctmr = (pch_clk) / 8;\n\tiowrite32(pch_i2ctmr, p + PCH_I2CTMR);\n\n\treg_value |= NORMAL_INTR_ENBL;\t \n\tiowrite32(reg_value, p + PCH_I2CCTL);\n\n\tpch_dbg(adap,\n\t\t\"I2CCTL=%x pch_i2cbc=%x pch_i2ctmr=%x Enable interrupts\\n\",\n\t\tioread32(p + PCH_I2CCTL), pch_i2cbc, pch_i2ctmr);\n\n\tinit_waitqueue_head(&pch_event);\n}\n\n \nstatic s32 pch_i2c_wait_for_bus_idle(struct i2c_algo_pch_data *adap,\n\t\t\t\t     s32 timeout)\n{\n\tvoid __iomem *p = adap->pch_base_address;\n\tint schedule = 0;\n\tunsigned long end = jiffies + msecs_to_jiffies(timeout);\n\n\twhile (ioread32(p + PCH_I2CSR) & I2CMBB_BIT) {\n\t\tif (time_after(jiffies, end)) {\n\t\t\tpch_dbg(adap, \"I2CSR = %x\\n\", ioread32(p + PCH_I2CSR));\n\t\t\tpch_err(adap, \"%s: Timeout Error.return%d\\n\",\n\t\t\t\t\t__func__, -ETIME);\n\t\t\tpch_i2c_init(adap);\n\n\t\t\treturn -ETIME;\n\t\t}\n\n\t\tif (!schedule)\n\t\t\t \n\t\t\tudelay(5);\n\t\telse\n\t\t\t \n\t\t\tusleep_range(20, 1000);\n\n\t\tschedule = 1;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void pch_i2c_start(struct i2c_algo_pch_data *adap)\n{\n\tvoid __iomem *p = adap->pch_base_address;\n\tpch_dbg(adap, \"I2CCTL = %x\\n\", ioread32(p + PCH_I2CCTL));\n\tpch_setbit(adap->pch_base_address, PCH_I2CCTL, PCH_START);\n}\n\n \nstatic void pch_i2c_stop(struct i2c_algo_pch_data *adap)\n{\n\tvoid __iomem *p = adap->pch_base_address;\n\tpch_dbg(adap, \"I2CCTL = %x\\n\", ioread32(p + PCH_I2CCTL));\n\t \n\tpch_clrbit(adap->pch_base_address, PCH_I2CCTL, PCH_START);\n}\n\nstatic int pch_i2c_wait_for_check_xfer(struct i2c_algo_pch_data *adap)\n{\n\tlong ret;\n\tvoid __iomem *p = adap->pch_base_address;\n\n\tret = wait_event_timeout(pch_event,\n\t\t\t(adap->pch_event_flag != 0), msecs_to_jiffies(1000));\n\tif (!ret) {\n\t\tpch_err(adap, \"%s:wait-event timeout\\n\", __func__);\n\t\tadap->pch_event_flag = 0;\n\t\tpch_i2c_stop(adap);\n\t\tpch_i2c_init(adap);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tif (adap->pch_event_flag & I2C_ERROR_MASK) {\n\t\tpch_err(adap, \"Lost Arbitration\\n\");\n\t\tadap->pch_event_flag = 0;\n\t\tpch_clrbit(adap->pch_base_address, PCH_I2CSR, I2CMAL_BIT);\n\t\tpch_clrbit(adap->pch_base_address, PCH_I2CSR, I2CMIF_BIT);\n\t\tpch_i2c_init(adap);\n\t\treturn -EAGAIN;\n\t}\n\n\tadap->pch_event_flag = 0;\n\n\tif (ioread32(p + PCH_I2CSR) & PCH_GETACK) {\n\t\tpch_dbg(adap, \"Receive NACK for slave address setting\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void pch_i2c_repstart(struct i2c_algo_pch_data *adap)\n{\n\tvoid __iomem *p = adap->pch_base_address;\n\tpch_dbg(adap, \"I2CCTL = %x\\n\", ioread32(p + PCH_I2CCTL));\n\tpch_setbit(adap->pch_base_address, PCH_I2CCTL, PCH_REPSTART);\n}\n\n \nstatic s32 pch_i2c_writebytes(struct i2c_adapter *i2c_adap,\n\t\t\t      struct i2c_msg *msgs, u32 last, u32 first)\n{\n\tstruct i2c_algo_pch_data *adap = i2c_adap->algo_data;\n\tu8 *buf;\n\tu32 length;\n\tu32 addr;\n\tu32 addr_2_msb;\n\tu32 addr_8_lsb;\n\ts32 wrcount;\n\ts32 rtn;\n\tvoid __iomem *p = adap->pch_base_address;\n\n\tlength = msgs->len;\n\tbuf = msgs->buf;\n\taddr = msgs->addr;\n\n\t \n\tpch_setbit(adap->pch_base_address, PCH_I2CCTL, I2C_TX_MODE);\n\n\tpch_dbg(adap, \"I2CCTL = %x msgs->len = %d\\n\", ioread32(p + PCH_I2CCTL),\n\t\tlength);\n\n\tif (first) {\n\t\tif (pch_i2c_wait_for_bus_idle(adap, BUS_IDLE_TIMEOUT) == -ETIME)\n\t\t\treturn -ETIME;\n\t}\n\n\tif (msgs->flags & I2C_M_TEN) {\n\t\taddr_2_msb = ((addr & I2C_MSB_2B_MSK) >> 7) & 0x06;\n\t\tiowrite32(addr_2_msb | TEN_BIT_ADDR_MASK, p + PCH_I2CDR);\n\t\tif (first)\n\t\t\tpch_i2c_start(adap);\n\n\t\trtn = pch_i2c_wait_for_check_xfer(adap);\n\t\tif (rtn)\n\t\t\treturn rtn;\n\n\t\taddr_8_lsb = (addr & I2C_ADDR_MSK);\n\t\tiowrite32(addr_8_lsb, p + PCH_I2CDR);\n\t} else {\n\t\t \n\t\tiowrite32(i2c_8bit_addr_from_msg(msgs), p + PCH_I2CDR);\n\t\tif (first)\n\t\t\tpch_i2c_start(adap);\n\t}\n\n\trtn = pch_i2c_wait_for_check_xfer(adap);\n\tif (rtn)\n\t\treturn rtn;\n\n\tfor (wrcount = 0; wrcount < length; ++wrcount) {\n\t\t \n\t\tiowrite32(buf[wrcount], p + PCH_I2CDR);\n\t\tpch_dbg(adap, \"writing %x to Data register\\n\", buf[wrcount]);\n\n\t\trtn = pch_i2c_wait_for_check_xfer(adap);\n\t\tif (rtn)\n\t\t\treturn rtn;\n\n\t\tpch_clrbit(adap->pch_base_address, PCH_I2CSR, I2CMCF_BIT);\n\t\tpch_clrbit(adap->pch_base_address, PCH_I2CSR, I2CMIF_BIT);\n\t}\n\n\t \n\tif (last)\n\t\tpch_i2c_stop(adap);\n\telse\n\t\tpch_i2c_repstart(adap);\n\n\tpch_dbg(adap, \"return=%d\\n\", wrcount);\n\n\treturn wrcount;\n}\n\n \nstatic void pch_i2c_sendack(struct i2c_algo_pch_data *adap)\n{\n\tvoid __iomem *p = adap->pch_base_address;\n\tpch_dbg(adap, \"I2CCTL = %x\\n\", ioread32(p + PCH_I2CCTL));\n\tpch_clrbit(adap->pch_base_address, PCH_I2CCTL, PCH_ACK);\n}\n\n \nstatic void pch_i2c_sendnack(struct i2c_algo_pch_data *adap)\n{\n\tvoid __iomem *p = adap->pch_base_address;\n\tpch_dbg(adap, \"I2CCTL = %x\\n\", ioread32(p + PCH_I2CCTL));\n\tpch_setbit(adap->pch_base_address, PCH_I2CCTL, PCH_ACK);\n}\n\n \nstatic void pch_i2c_restart(struct i2c_algo_pch_data *adap)\n{\n\tvoid __iomem *p = adap->pch_base_address;\n\tpch_dbg(adap, \"I2CCTL = %x\\n\", ioread32(p + PCH_I2CCTL));\n\tpch_setbit(adap->pch_base_address, PCH_I2CCTL, PCH_RESTART);\n}\n\n \nstatic s32 pch_i2c_readbytes(struct i2c_adapter *i2c_adap, struct i2c_msg *msgs,\n\t\t\t     u32 last, u32 first)\n{\n\tstruct i2c_algo_pch_data *adap = i2c_adap->algo_data;\n\n\tu8 *buf;\n\tu32 count;\n\tu32 length;\n\tu32 addr;\n\tu32 addr_2_msb;\n\tu32 addr_8_lsb;\n\tvoid __iomem *p = adap->pch_base_address;\n\ts32 rtn;\n\n\tlength = msgs->len;\n\tbuf = msgs->buf;\n\taddr = msgs->addr;\n\n\t \n\tpch_clrbit(adap->pch_base_address, PCH_I2CCTL, I2C_TX_MODE);\n\n\tif (first) {\n\t\tif (pch_i2c_wait_for_bus_idle(adap, BUS_IDLE_TIMEOUT) == -ETIME)\n\t\t\treturn -ETIME;\n\t}\n\n\tif (msgs->flags & I2C_M_TEN) {\n\t\taddr_2_msb = ((addr & I2C_MSB_2B_MSK) >> 7);\n\t\tiowrite32(addr_2_msb | TEN_BIT_ADDR_MASK, p + PCH_I2CDR);\n\t\tif (first)\n\t\t\tpch_i2c_start(adap);\n\n\t\trtn = pch_i2c_wait_for_check_xfer(adap);\n\t\tif (rtn)\n\t\t\treturn rtn;\n\n\t\taddr_8_lsb = (addr & I2C_ADDR_MSK);\n\t\tiowrite32(addr_8_lsb, p + PCH_I2CDR);\n\n\t\tpch_i2c_restart(adap);\n\n\t\trtn = pch_i2c_wait_for_check_xfer(adap);\n\t\tif (rtn)\n\t\t\treturn rtn;\n\n\t\taddr_2_msb |= I2C_RD;\n\t\tiowrite32(addr_2_msb | TEN_BIT_ADDR_MASK, p + PCH_I2CDR);\n\t} else {\n\t\t \n\t\tiowrite32(i2c_8bit_addr_from_msg(msgs), p + PCH_I2CDR);\n\t}\n\n\t \n\tif (first)\n\t\tpch_i2c_start(adap);\n\n\trtn = pch_i2c_wait_for_check_xfer(adap);\n\tif (rtn)\n\t\treturn rtn;\n\n\tif (length == 0) {\n\t\tpch_i2c_stop(adap);\n\t\tioread32(p + PCH_I2CDR);  \n\n\t\tcount = length;\n\t} else {\n\t\tint read_index;\n\t\tint loop;\n\t\tpch_i2c_sendack(adap);\n\n\t\t \n\t\tfor (loop = 1, read_index = 0; loop < length; loop++) {\n\t\t\tbuf[read_index] = ioread32(p + PCH_I2CDR);\n\n\t\t\tif (loop != 1)\n\t\t\t\tread_index++;\n\n\t\t\trtn = pch_i2c_wait_for_check_xfer(adap);\n\t\t\tif (rtn)\n\t\t\t\treturn rtn;\n\t\t}\t \n\n\t\tpch_i2c_sendnack(adap);\n\n\t\tbuf[read_index] = ioread32(p + PCH_I2CDR);  \n\n\t\tif (length != 1)\n\t\t\tread_index++;\n\n\t\trtn = pch_i2c_wait_for_check_xfer(adap);\n\t\tif (rtn)\n\t\t\treturn rtn;\n\n\t\tif (last)\n\t\t\tpch_i2c_stop(adap);\n\t\telse\n\t\t\tpch_i2c_repstart(adap);\n\n\t\tbuf[read_index++] = ioread32(p + PCH_I2CDR);  \n\t\tcount = read_index;\n\t}\n\n\treturn count;\n}\n\n \nstatic void pch_i2c_cb(struct i2c_algo_pch_data *adap)\n{\n\tu32 sts;\n\tvoid __iomem *p = adap->pch_base_address;\n\n\tsts = ioread32(p + PCH_I2CSR);\n\tsts &= (I2CMAL_BIT | I2CMCF_BIT | I2CMIF_BIT);\n\tif (sts & I2CMAL_BIT)\n\t\tadap->pch_event_flag |= I2CMAL_EVENT;\n\n\tif (sts & I2CMCF_BIT)\n\t\tadap->pch_event_flag |= I2CMCF_EVENT;\n\n\t \n\tpch_clrbit(adap->pch_base_address, PCH_I2CSR, sts);\n\n\tpch_dbg(adap, \"PCH_I2CSR = %x\\n\", ioread32(p + PCH_I2CSR));\n\n\twake_up(&pch_event);\n}\n\n \nstatic irqreturn_t pch_i2c_handler(int irq, void *pData)\n{\n\tu32 reg_val;\n\tint flag;\n\tint i;\n\tstruct adapter_info *adap_info = pData;\n\tvoid __iomem *p;\n\tu32 mode;\n\n\tfor (i = 0, flag = 0; i < adap_info->ch_num; i++) {\n\t\tp = adap_info->pch_data[i].pch_base_address;\n\t\tmode = ioread32(p + PCH_I2CMOD);\n\t\tmode &= BUFFER_MODE | EEPROM_SR_MODE;\n\t\tif (mode != NORMAL_MODE) {\n\t\t\tpch_err(adap_info->pch_data,\n\t\t\t\t\"I2C-%d mode(%d) is not supported\\n\", mode, i);\n\t\t\tcontinue;\n\t\t}\n\t\treg_val = ioread32(p + PCH_I2CSR);\n\t\tif (reg_val & (I2CMAL_BIT | I2CMCF_BIT | I2CMIF_BIT)) {\n\t\t\tpch_i2c_cb(&adap_info->pch_data[i]);\n\t\t\tflag = 1;\n\t\t}\n\t}\n\n\treturn flag ? IRQ_HANDLED : IRQ_NONE;\n}\n\n \nstatic s32 pch_i2c_xfer(struct i2c_adapter *i2c_adap,\n\t\t\tstruct i2c_msg *msgs, s32 num)\n{\n\tstruct i2c_msg *pmsg;\n\tu32 i = 0;\n\tu32 status;\n\ts32 ret;\n\n\tstruct i2c_algo_pch_data *adap = i2c_adap->algo_data;\n\n\tret = mutex_lock_interruptible(&pch_mutex);\n\tif (ret)\n\t\treturn ret;\n\n\tif (adap->p_adapter_info->pch_i2c_suspended) {\n\t\tmutex_unlock(&pch_mutex);\n\t\treturn -EBUSY;\n\t}\n\n\tpch_dbg(adap, \"adap->p_adapter_info->pch_i2c_suspended is %d\\n\",\n\t\tadap->p_adapter_info->pch_i2c_suspended);\n\t \n\tadap->pch_i2c_xfer_in_progress = true;\n\n\tfor (i = 0; i < num && ret >= 0; i++) {\n\t\tpmsg = &msgs[i];\n\t\tpmsg->flags |= adap->pch_buff_mode_en;\n\t\tstatus = pmsg->flags;\n\t\tpch_dbg(adap,\n\t\t\t\"After invoking I2C_MODE_SEL :flag= 0x%x\\n\", status);\n\n\t\tif ((status & (I2C_M_RD)) != false) {\n\t\t\tret = pch_i2c_readbytes(i2c_adap, pmsg, (i + 1 == num),\n\t\t\t\t\t\t(i == 0));\n\t\t} else {\n\t\t\tret = pch_i2c_writebytes(i2c_adap, pmsg, (i + 1 == num),\n\t\t\t\t\t\t (i == 0));\n\t\t}\n\t}\n\n\tadap->pch_i2c_xfer_in_progress = false;\t \n\n\tmutex_unlock(&pch_mutex);\n\n\treturn (ret < 0) ? ret : num;\n}\n\n \nstatic u32 pch_i2c_func(struct i2c_adapter *adap)\n{\n\treturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL | I2C_FUNC_10BIT_ADDR;\n}\n\nstatic const struct i2c_algorithm pch_algorithm = {\n\t.master_xfer = pch_i2c_xfer,\n\t.functionality = pch_i2c_func\n};\n\n \nstatic void pch_i2c_disbl_int(struct i2c_algo_pch_data *adap)\n{\n\tvoid __iomem *p = adap->pch_base_address;\n\n\tpch_clrbit(adap->pch_base_address, PCH_I2CCTL, NORMAL_INTR_ENBL);\n\n\tiowrite32(EEPROM_RST_INTR_DISBL, p + PCH_I2CESRMSK);\n\n\tiowrite32(BUFFER_MODE_INTR_DISBL, p + PCH_I2CBUFMSK);\n}\n\nstatic int pch_i2c_probe(struct pci_dev *pdev,\n\t\t\t\t   const struct pci_device_id *id)\n{\n\tvoid __iomem *base_addr;\n\tint ret;\n\tint i, j;\n\tstruct adapter_info *adap_info;\n\tstruct i2c_adapter *pch_adap;\n\n\tpch_pci_dbg(pdev, \"Entered.\\n\");\n\n\tadap_info = kzalloc((sizeof(struct adapter_info)), GFP_KERNEL);\n\tif (adap_info == NULL)\n\t\treturn -ENOMEM;\n\n\tret = pci_enable_device(pdev);\n\tif (ret) {\n\t\tpch_pci_err(pdev, \"pci_enable_device FAILED\\n\");\n\t\tgoto err_pci_enable;\n\t}\n\n\tret = pci_request_regions(pdev, KBUILD_MODNAME);\n\tif (ret) {\n\t\tpch_pci_err(pdev, \"pci_request_regions FAILED\\n\");\n\t\tgoto err_pci_req;\n\t}\n\n\tbase_addr = pci_iomap(pdev, 1, 0);\n\n\tif (base_addr == NULL) {\n\t\tpch_pci_err(pdev, \"pci_iomap FAILED\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto err_pci_iomap;\n\t}\n\n\t \n\tadap_info->ch_num = id->driver_data;\n\n\tfor (i = 0; i < adap_info->ch_num; i++) {\n\t\tpch_adap = &adap_info->pch_data[i].pch_adapter;\n\t\tadap_info->pch_i2c_suspended = false;\n\n\t\tadap_info->pch_data[i].p_adapter_info = adap_info;\n\n\t\tpch_adap->owner = THIS_MODULE;\n\t\tpch_adap->class = I2C_CLASS_HWMON;\n\t\tstrscpy(pch_adap->name, KBUILD_MODNAME, sizeof(pch_adap->name));\n\t\tpch_adap->algo = &pch_algorithm;\n\t\tpch_adap->algo_data = &adap_info->pch_data[i];\n\n\t\t \n\t\tadap_info->pch_data[i].pch_base_address = base_addr + 0x100 * i;\n\n\t\tpch_adap->dev.of_node = pdev->dev.of_node;\n\t\tpch_adap->dev.parent = &pdev->dev;\n\t}\n\n\tret = request_irq(pdev->irq, pch_i2c_handler, IRQF_SHARED,\n\t\t  KBUILD_MODNAME, adap_info);\n\tif (ret) {\n\t\tpch_pci_err(pdev, \"request_irq FAILED\\n\");\n\t\tgoto err_request_irq;\n\t}\n\n\tfor (i = 0; i < adap_info->ch_num; i++) {\n\t\tpch_adap = &adap_info->pch_data[i].pch_adapter;\n\n\t\tpch_i2c_init(&adap_info->pch_data[i]);\n\n\t\tpch_adap->nr = i;\n\t\tret = i2c_add_numbered_adapter(pch_adap);\n\t\tif (ret) {\n\t\t\tpch_pci_err(pdev, \"i2c_add_adapter[ch:%d] FAILED\\n\", i);\n\t\t\tgoto err_add_adapter;\n\t\t}\n\t}\n\n\tpci_set_drvdata(pdev, adap_info);\n\tpch_pci_dbg(pdev, \"returns %d.\\n\", ret);\n\treturn 0;\n\nerr_add_adapter:\n\tfor (j = 0; j < i; j++)\n\t\ti2c_del_adapter(&adap_info->pch_data[j].pch_adapter);\n\tfree_irq(pdev->irq, adap_info);\nerr_request_irq:\n\tpci_iounmap(pdev, base_addr);\nerr_pci_iomap:\n\tpci_release_regions(pdev);\nerr_pci_req:\n\tpci_disable_device(pdev);\nerr_pci_enable:\n\tkfree(adap_info);\n\treturn ret;\n}\n\nstatic void pch_i2c_remove(struct pci_dev *pdev)\n{\n\tint i;\n\tstruct adapter_info *adap_info = pci_get_drvdata(pdev);\n\n\tfree_irq(pdev->irq, adap_info);\n\n\tfor (i = 0; i < adap_info->ch_num; i++) {\n\t\tpch_i2c_disbl_int(&adap_info->pch_data[i]);\n\t\ti2c_del_adapter(&adap_info->pch_data[i].pch_adapter);\n\t}\n\n\tif (adap_info->pch_data[0].pch_base_address)\n\t\tpci_iounmap(pdev, adap_info->pch_data[0].pch_base_address);\n\n\tfor (i = 0; i < adap_info->ch_num; i++)\n\t\tadap_info->pch_data[i].pch_base_address = NULL;\n\n\tpci_release_regions(pdev);\n\n\tpci_disable_device(pdev);\n\tkfree(adap_info);\n}\n\nstatic int __maybe_unused pch_i2c_suspend(struct device *dev)\n{\n\tint i;\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tstruct adapter_info *adap_info = pci_get_drvdata(pdev);\n\tvoid __iomem *p = adap_info->pch_data[0].pch_base_address;\n\n\tadap_info->pch_i2c_suspended = true;\n\n\tfor (i = 0; i < adap_info->ch_num; i++) {\n\t\twhile ((adap_info->pch_data[i].pch_i2c_xfer_in_progress)) {\n\t\t\t \n\t\t\tmsleep(20);\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < adap_info->ch_num; i++)\n\t\tpch_i2c_disbl_int(&adap_info->pch_data[i]);\n\n\tpch_pci_dbg(pdev, \"I2CSR = %x I2CBUFSTA = %x I2CESRSTA = %x \"\n\t\t\"invoked function pch_i2c_disbl_int successfully\\n\",\n\t\tioread32(p + PCH_I2CSR), ioread32(p + PCH_I2CBUFSTA),\n\t\tioread32(p + PCH_I2CESRSTA));\n\n\treturn 0;\n}\n\nstatic int __maybe_unused pch_i2c_resume(struct device *dev)\n{\n\tint i;\n\tstruct adapter_info *adap_info = dev_get_drvdata(dev);\n\n\tfor (i = 0; i < adap_info->ch_num; i++)\n\t\tpch_i2c_init(&adap_info->pch_data[i]);\n\n\tadap_info->pch_i2c_suspended = false;\n\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(pch_i2c_pm_ops, pch_i2c_suspend, pch_i2c_resume);\n\nstatic struct pci_driver pch_pcidriver = {\n\t.name = KBUILD_MODNAME,\n\t.id_table = pch_pcidev_id,\n\t.probe = pch_i2c_probe,\n\t.remove = pch_i2c_remove,\n\t.driver.pm = &pch_i2c_pm_ops,\n};\n\nmodule_pci_driver(pch_pcidriver);\n\nMODULE_DESCRIPTION(\"Intel EG20T PCH/LAPIS Semico ML7213/ML7223/ML7831 IOH I2C\");\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Tomoya MORINAGA. <tomoya.rohm@gmail.com>\");\nmodule_param(pch_i2c_speed, int, (S_IRUSR | S_IWUSR));\nmodule_param(pch_clk, int, (S_IRUSR | S_IWUSR));\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}