{
  "module_name": "i2c-designware-amdpsp.c",
  "hash_id": "29a809ceffb0e07a879c5303ec860b3a94a83c9888db24afeb1f7b84275a2a05",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-designware-amdpsp.c",
  "human_readable_source": "\n\n#include <linux/i2c.h>\n#include <linux/pci.h>\n#include <linux/psp-platform-access.h>\n#include <linux/psp.h>\n#include <linux/workqueue.h>\n\n#include \"i2c-designware-core.h\"\n\n#define PSP_I2C_RESERVATION_TIME_MS 100\n\n#define PSP_I2C_REQ_RETRY_CNT\t\t400\n#define PSP_I2C_REQ_RETRY_DELAY_US\t(25 * USEC_PER_MSEC)\n#define PSP_I2C_REQ_STS_OK\t\t0x0\n#define PSP_I2C_REQ_STS_BUS_BUSY\t0x1\n#define PSP_I2C_REQ_STS_INV_PARAM\t0x3\n\nenum psp_i2c_req_type {\n\tPSP_I2C_REQ_ACQUIRE,\n\tPSP_I2C_REQ_RELEASE,\n\tPSP_I2C_REQ_MAX\n};\n\nstruct psp_i2c_req {\n\tstruct psp_req_buffer_hdr hdr;\n\tenum psp_i2c_req_type type;\n};\n\nstatic DEFINE_MUTEX(psp_i2c_access_mutex);\nstatic unsigned long psp_i2c_sem_acquired;\nstatic u32 psp_i2c_access_count;\nstatic bool psp_i2c_mbox_fail;\nstatic struct device *psp_i2c_dev;\n\nstatic int (*_psp_send_i2c_req)(struct psp_i2c_req *req);\n\n \nstatic int check_i2c_req_sts(struct psp_i2c_req *req)\n{\n\tu32 status;\n\n\t \n\tstatus = READ_ONCE(req->hdr.status);\n\n\tswitch (status) {\n\tcase PSP_I2C_REQ_STS_OK:\n\t\treturn 0;\n\tcase PSP_I2C_REQ_STS_BUS_BUSY:\n\t\treturn -EBUSY;\n\tcase PSP_I2C_REQ_STS_INV_PARAM:\n\tdefault:\n\t\treturn -EIO;\n\t}\n}\n\n \nstatic int psp_send_i2c_req_cezanne(struct psp_i2c_req *req)\n{\n\tint ret;\n\n\tret = psp_send_platform_access_msg(PSP_I2C_REQ_BUS_CMD, (struct psp_request *)req);\n\tif (ret == -EIO)\n\t\treturn check_i2c_req_sts(req);\n\n\treturn ret;\n}\n\nstatic int psp_send_i2c_req_doorbell(struct psp_i2c_req *req)\n{\n\tint ret;\n\n\tret = psp_ring_platform_doorbell(req->type, &req->hdr.status);\n\tif (ret == -EIO)\n\t\treturn check_i2c_req_sts(req);\n\n\treturn ret;\n}\n\nstatic int psp_send_i2c_req(enum psp_i2c_req_type i2c_req_type)\n{\n\tstruct psp_i2c_req *req;\n\tunsigned long start;\n\tint status, ret;\n\n\t \n\treq = kzalloc(sizeof(*req), GFP_KERNEL);\n\tif (!req)\n\t\treturn -ENOMEM;\n\n\treq->hdr.payload_size = sizeof(*req);\n\treq->type = i2c_req_type;\n\n\tstart = jiffies;\n\tret = read_poll_timeout(_psp_send_i2c_req, status,\n\t\t\t\t(status != -EBUSY),\n\t\t\t\tPSP_I2C_REQ_RETRY_DELAY_US,\n\t\t\t\tPSP_I2C_REQ_RETRY_CNT * PSP_I2C_REQ_RETRY_DELAY_US,\n\t\t\t\t0, req);\n\tif (ret) {\n\t\tdev_err(psp_i2c_dev, \"Timed out waiting for PSP to %s I2C bus\\n\",\n\t\t\t(i2c_req_type == PSP_I2C_REQ_ACQUIRE) ?\n\t\t\t\"release\" : \"acquire\");\n\t\tgoto cleanup;\n\t}\n\n\tret = status;\n\tif (ret) {\n\t\tdev_err(psp_i2c_dev, \"PSP communication error\\n\");\n\t\tgoto cleanup;\n\t}\n\n\tdev_dbg(psp_i2c_dev, \"Request accepted by PSP after %ums\\n\",\n\t\tjiffies_to_msecs(jiffies - start));\n\ncleanup:\n\tif (ret) {\n\t\tdev_err(psp_i2c_dev, \"Assume i2c bus is for exclusive host usage\\n\");\n\t\tpsp_i2c_mbox_fail = true;\n\t}\n\n\tkfree(req);\n\treturn ret;\n}\n\nstatic void release_bus(void)\n{\n\tint status;\n\n\tif (!psp_i2c_sem_acquired)\n\t\treturn;\n\n\tstatus = psp_send_i2c_req(PSP_I2C_REQ_RELEASE);\n\tif (status)\n\t\treturn;\n\n\tdev_dbg(psp_i2c_dev, \"PSP semaphore held for %ums\\n\",\n\t\tjiffies_to_msecs(jiffies - psp_i2c_sem_acquired));\n\n\tpsp_i2c_sem_acquired = 0;\n}\n\nstatic void psp_release_i2c_bus_deferred(struct work_struct *work)\n{\n\tmutex_lock(&psp_i2c_access_mutex);\n\n\t \n\tif (psp_i2c_access_count)\n\t\tgoto cleanup;\n\n\trelease_bus();\n\ncleanup:\n\tmutex_unlock(&psp_i2c_access_mutex);\n}\nstatic DECLARE_DELAYED_WORK(release_queue, psp_release_i2c_bus_deferred);\n\nstatic int psp_acquire_i2c_bus(void)\n{\n\tint status;\n\n\tmutex_lock(&psp_i2c_access_mutex);\n\n\t \n\tif (psp_i2c_mbox_fail)\n\t\tgoto cleanup;\n\n\tpsp_i2c_access_count++;\n\n\t \n\tif (psp_i2c_sem_acquired)\n\t\tgoto cleanup;\n\n\tstatus = psp_send_i2c_req(PSP_I2C_REQ_ACQUIRE);\n\tif (status)\n\t\tgoto cleanup;\n\n\tpsp_i2c_sem_acquired = jiffies;\n\n\tschedule_delayed_work(&release_queue,\n\t\t\t      msecs_to_jiffies(PSP_I2C_RESERVATION_TIME_MS));\n\n\t \ncleanup:\n\tmutex_unlock(&psp_i2c_access_mutex);\n\treturn 0;\n}\n\nstatic void psp_release_i2c_bus(void)\n{\n\tmutex_lock(&psp_i2c_access_mutex);\n\n\t \n\tif (psp_i2c_mbox_fail)\n\t\tgoto cleanup;\n\n\t \n\tpsp_i2c_access_count--;\n\tif (psp_i2c_access_count)\n\t\tgoto cleanup;\n\n\t \n\tif (!delayed_work_pending(&release_queue))\n\t\trelease_bus();\n\ncleanup:\n\tmutex_unlock(&psp_i2c_access_mutex);\n}\n\n \nstatic void i2c_adapter_dw_psp_lock_bus(struct i2c_adapter *adapter,\n\t\t\t\t\tunsigned int flags)\n{\n\tpsp_acquire_i2c_bus();\n\trt_mutex_lock_nested(&adapter->bus_lock, i2c_adapter_depth(adapter));\n}\n\nstatic int i2c_adapter_dw_psp_trylock_bus(struct i2c_adapter *adapter,\n\t\t\t\t\t  unsigned int flags)\n{\n\tint ret;\n\n\tret = rt_mutex_trylock(&adapter->bus_lock);\n\tif (ret)\n\t\treturn ret;\n\n\tpsp_acquire_i2c_bus();\n\n\treturn ret;\n}\n\nstatic void i2c_adapter_dw_psp_unlock_bus(struct i2c_adapter *adapter,\n\t\t\t\t\t  unsigned int flags)\n{\n\tpsp_release_i2c_bus();\n\trt_mutex_unlock(&adapter->bus_lock);\n}\n\nstatic const struct i2c_lock_operations i2c_dw_psp_lock_ops = {\n\t.lock_bus = i2c_adapter_dw_psp_lock_bus,\n\t.trylock_bus = i2c_adapter_dw_psp_trylock_bus,\n\t.unlock_bus = i2c_adapter_dw_psp_unlock_bus,\n};\n\nint i2c_dw_amdpsp_probe_lock_support(struct dw_i2c_dev *dev)\n{\n\tstruct pci_dev *rdev;\n\n\tif (!IS_REACHABLE(CONFIG_CRYPTO_DEV_CCP_DD))\n\t\treturn -ENODEV;\n\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tif (!(dev->flags & ARBITRATION_SEMAPHORE))\n\t\treturn -ENODEV;\n\n\t \n\tif (psp_i2c_dev)\n\t\treturn -EEXIST;\n\n\t \n\trdev = pci_get_domain_bus_and_slot(0, 0, PCI_DEVFN(0, 0));\n\tif (rdev->device == 0x1630)\n\t\t_psp_send_i2c_req = psp_send_i2c_req_cezanne;\n\telse\n\t\t_psp_send_i2c_req = psp_send_i2c_req_doorbell;\n\tpci_dev_put(rdev);\n\n\tif (psp_check_platform_access_status())\n\t\treturn -EPROBE_DEFER;\n\n\tpsp_i2c_dev = dev->dev;\n\n\tdev_info(psp_i2c_dev, \"I2C bus managed by AMD PSP\\n\");\n\n\t \n\tdev->adapter.lock_ops = &i2c_dw_psp_lock_ops;\n\tdev->acquire_lock = psp_acquire_i2c_bus;\n\tdev->release_lock = psp_release_i2c_bus;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}