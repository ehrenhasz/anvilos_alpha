{
  "module_name": "i2c-hydra.c",
  "hash_id": "6c977737a84f7bd0af21d0f491aeeef18f5a0415b6eb63c9fb2dafce07419eba",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-hydra.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/types.h>\n#include <linux/i2c.h>\n#include <linux/i2c-algo-bit.h>\n#include <linux/io.h>\n#include <asm/hydra.h>\n\n\n#define HYDRA_CPD_PD0\t0x00000001\t \n#define HYDRA_CPD_PD1\t0x00000002\n#define HYDRA_CPD_PD2\t0x00000004\n#define HYDRA_CPD_PD3\t0x00000008\n\n#define HYDRA_SCLK\tHYDRA_CPD_PD0\n#define HYDRA_SDAT\tHYDRA_CPD_PD1\n#define HYDRA_SCLK_OE\t0x00000010\n#define HYDRA_SDAT_OE\t0x00000020\n\nstatic inline void pdregw(void *data, u32 val)\n{\n\tstruct Hydra *hydra = (struct Hydra *)data;\n\twritel(val, &hydra->CachePD);\n}\n\nstatic inline u32 pdregr(void *data)\n{\n\tstruct Hydra *hydra = (struct Hydra *)data;\n\treturn readl(&hydra->CachePD);\n}\n\nstatic void hydra_bit_setscl(void *data, int state)\n{\n\tu32 val = pdregr(data);\n\tif (state)\n\t\tval &= ~HYDRA_SCLK_OE;\n\telse {\n\t\tval &= ~HYDRA_SCLK;\n\t\tval |= HYDRA_SCLK_OE;\n\t}\n\tpdregw(data, val);\n}\n\nstatic void hydra_bit_setsda(void *data, int state)\n{\n\tu32 val = pdregr(data);\n\tif (state)\n\t\tval &= ~HYDRA_SDAT_OE;\n\telse {\n\t\tval &= ~HYDRA_SDAT;\n\t\tval |= HYDRA_SDAT_OE;\n\t}\n\tpdregw(data, val);\n}\n\nstatic int hydra_bit_getscl(void *data)\n{\n\treturn (pdregr(data) & HYDRA_SCLK) != 0;\n}\n\nstatic int hydra_bit_getsda(void *data)\n{\n\treturn (pdregr(data) & HYDRA_SDAT) != 0;\n}\n\n \n\nstatic struct i2c_algo_bit_data hydra_bit_data = {\n\t.setsda\t\t= hydra_bit_setsda,\n\t.setscl\t\t= hydra_bit_setscl,\n\t.getsda\t\t= hydra_bit_getsda,\n\t.getscl\t\t= hydra_bit_getscl,\n\t.udelay\t\t= 5,\n\t.timeout\t= HZ\n};\n\nstatic struct i2c_adapter hydra_adap = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"Hydra i2c\",\n\t.algo_data\t= &hydra_bit_data,\n};\n\nstatic const struct pci_device_id hydra_ids[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_APPLE, PCI_DEVICE_ID_APPLE_HYDRA) },\n\t{ 0, }\n};\n\nMODULE_DEVICE_TABLE (pci, hydra_ids);\n\nstatic int hydra_probe(struct pci_dev *dev,\n\t\t\t\t const struct pci_device_id *id)\n{\n\tunsigned long base = pci_resource_start(dev, 0);\n\tint res;\n\n\tif (!request_mem_region(base+offsetof(struct Hydra, CachePD), 4,\n\t\t\t\thydra_adap.name))\n\t\treturn -EBUSY;\n\n\thydra_bit_data.data = pci_ioremap_bar(dev, 0);\n\tif (hydra_bit_data.data == NULL) {\n\t\trelease_mem_region(base+offsetof(struct Hydra, CachePD), 4);\n\t\treturn -ENODEV;\n\t}\n\n\tpdregw(hydra_bit_data.data, 0);\t\t \n\thydra_adap.dev.parent = &dev->dev;\n\tres = i2c_bit_add_bus(&hydra_adap);\n\tif (res < 0) {\n\t\tiounmap(hydra_bit_data.data);\n\t\trelease_mem_region(base+offsetof(struct Hydra, CachePD), 4);\n\t\treturn res;\n\t}\n\treturn 0;\n}\n\nstatic void hydra_remove(struct pci_dev *dev)\n{\n\tpdregw(hydra_bit_data.data, 0);\t\t \n\ti2c_del_adapter(&hydra_adap);\n\tiounmap(hydra_bit_data.data);\n\trelease_mem_region(pci_resource_start(dev, 0)+\n\t\t\t   offsetof(struct Hydra, CachePD), 4);\n}\n\n\nstatic struct pci_driver hydra_driver = {\n\t.name\t\t= \"hydra_smbus\",\n\t.id_table\t= hydra_ids,\n\t.probe\t\t= hydra_probe,\n\t.remove\t\t= hydra_remove,\n};\n\nmodule_pci_driver(hydra_driver);\n\nMODULE_AUTHOR(\"Geert Uytterhoeven <geert@linux-m68k.org>\");\nMODULE_DESCRIPTION(\"i2c for Apple Hydra Mac I/O\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}