{
  "module_name": "i2c-taos-evm.c",
  "hash_id": "be525bd2b6c475f3c5fb0b3cbb1c666512434a689e19bf5da7360b70d9024d3b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-taos-evm.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/input.h>\n#include <linux/serio.h>\n#include <linux/init.h>\n#include <linux/i2c.h>\n\n#define TAOS_BUFFER_SIZE\t63\n\n#define TAOS_STATE_INIT\t\t0\n#define TAOS_STATE_IDLE\t\t1\n#define TAOS_STATE_EOFF\t\t2\n#define TAOS_STATE_RECV\t\t3\n\n#define TAOS_CMD_RESET\t\t0x12\n#define TAOS_CMD_ECHO_ON\t'+'\n#define TAOS_CMD_ECHO_OFF\t'-'\n\nstatic DECLARE_WAIT_QUEUE_HEAD(wq);\n\nstruct taos_data {\n\tstruct i2c_adapter adapter;\n\tstruct i2c_client *client;\n\tint state;\n\tu8 addr;\t\t \n\tunsigned char buffer[TAOS_BUFFER_SIZE];\n\tunsigned int pos;\t \n};\n\n \nstatic const struct i2c_board_info tsl2550_info = {\n\tI2C_BOARD_INFO(\"tsl2550\", 0x39),\n};\n\n \nstatic struct i2c_client *taos_instantiate_device(struct i2c_adapter *adapter)\n{\n\tif (!strncmp(adapter->name, \"TAOS TSL2550 EVM\", 16)) {\n\t\tdev_info(&adapter->dev, \"Instantiating device %s at 0x%02x\\n\",\n\t\t\ttsl2550_info.type, tsl2550_info.addr);\n\t\treturn i2c_new_client_device(adapter, &tsl2550_info);\n\t}\n\n\treturn ERR_PTR(-ENODEV);\n}\n\nstatic int taos_smbus_xfer(struct i2c_adapter *adapter, u16 addr,\n\t\t\t   unsigned short flags, char read_write, u8 command,\n\t\t\t   int size, union i2c_smbus_data *data)\n{\n\tstruct serio *serio = adapter->algo_data;\n\tstruct taos_data *taos = serio_get_drvdata(serio);\n\tchar *p;\n\n\t \n\tp = taos->buffer;\n\n\t \n\tif (addr != taos->addr)\n\t\tp += sprintf(p, \"@%02X\", addr);\n\n\tswitch (size) {\n\tcase I2C_SMBUS_BYTE:\n\t\tif (read_write == I2C_SMBUS_WRITE)\n\t\t\tsprintf(p, \"$#%02X\", command);\n\t\telse\n\t\t\tsprintf(p, \"$\");\n\t\tbreak;\n\tcase I2C_SMBUS_BYTE_DATA:\n\t\tif (read_write == I2C_SMBUS_WRITE)\n\t\t\tsprintf(p, \"$%02X#%02X\", command, data->byte);\n\t\telse\n\t\t\tsprintf(p, \"$%02X\", command);\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(&adapter->dev, \"Unsupported transaction %d\\n\", size);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t \n\tdev_dbg(&adapter->dev, \"Command buffer: %s\\n\", taos->buffer);\n\tfor (p = taos->buffer; *p; p++)\n\t\tserio_write(serio, *p);\n\n\ttaos->addr = addr;\n\n\t \n\ttaos->pos = 0;\n\ttaos->state = TAOS_STATE_RECV;\n\tserio_write(serio, read_write == I2C_SMBUS_WRITE ? '>' : '<');\n\twait_event_interruptible_timeout(wq, taos->state == TAOS_STATE_IDLE,\n\t\t\t\t\t msecs_to_jiffies(150));\n\tif (taos->state != TAOS_STATE_IDLE\n\t || taos->pos != 5) {\n\t\tdev_err(&adapter->dev, \"Transaction timeout (pos=%d)\\n\",\n\t\t\ttaos->pos);\n\t\treturn -EIO;\n\t}\n\tdev_dbg(&adapter->dev, \"Answer buffer: %s\\n\", taos->buffer);\n\n\t \n\tp = taos->buffer + 1;\n\tp[3] = '\\0';\n\tif (!strcmp(p, \"NAK\"))\n\t\treturn -ENODEV;\n\n\tif (read_write == I2C_SMBUS_WRITE) {\n\t\tif (!strcmp(p, \"ACK\"))\n\t\t\treturn 0;\n\t} else {\n\t\tif (p[0] == 'x') {\n\t\t\t \n\t\t\tif (kstrtou8(p + 1, 16, &data->byte))\n\t\t\t\treturn -EPROTO;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -EIO;\n}\n\nstatic u32 taos_smbus_func(struct i2c_adapter *adapter)\n{\n\treturn I2C_FUNC_SMBUS_BYTE | I2C_FUNC_SMBUS_BYTE_DATA;\n}\n\nstatic const struct i2c_algorithm taos_algorithm = {\n\t.smbus_xfer\t= taos_smbus_xfer,\n\t.functionality\t= taos_smbus_func,\n};\n\nstatic irqreturn_t taos_interrupt(struct serio *serio, unsigned char data,\n\t\t\t\t  unsigned int flags)\n{\n\tstruct taos_data *taos = serio_get_drvdata(serio);\n\n\tswitch (taos->state) {\n\tcase TAOS_STATE_INIT:\n\t\ttaos->buffer[taos->pos++] = data;\n\t\tif (data == ':'\n\t\t || taos->pos == TAOS_BUFFER_SIZE - 1) {\n\t\t\ttaos->buffer[taos->pos] = '\\0';\n\t\t\ttaos->state = TAOS_STATE_IDLE;\n\t\t\twake_up_interruptible(&wq);\n\t\t}\n\t\tbreak;\n\tcase TAOS_STATE_EOFF:\n\t\ttaos->state = TAOS_STATE_IDLE;\n\t\twake_up_interruptible(&wq);\n\t\tbreak;\n\tcase TAOS_STATE_RECV:\n\t\ttaos->buffer[taos->pos++] = data;\n\t\tif (data == ']') {\n\t\t\ttaos->buffer[taos->pos] = '\\0';\n\t\t\ttaos->state = TAOS_STATE_IDLE;\n\t\t\twake_up_interruptible(&wq);\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic char *taos_adapter_name(char *buffer)\n{\n\tchar *start, *end;\n\n\tstart = strstr(buffer, \"TAOS \");\n\tif (!start)\n\t\treturn NULL;\n\n\tend = strchr(start, '\\r');\n\tif (!end)\n\t\treturn NULL;\n\t*end = '\\0';\n\n\treturn start;\n}\n\nstatic int taos_connect(struct serio *serio, struct serio_driver *drv)\n{\n\tstruct taos_data *taos;\n\tstruct i2c_adapter *adapter;\n\tchar *name;\n\tint err;\n\n\ttaos = kzalloc(sizeof(struct taos_data), GFP_KERNEL);\n\tif (!taos) {\n\t\terr = -ENOMEM;\n\t\tgoto exit;\n\t}\n\ttaos->state = TAOS_STATE_INIT;\n\tserio_set_drvdata(serio, taos);\n\n\terr = serio_open(serio, drv);\n\tif (err)\n\t\tgoto exit_kfree;\n\n\tadapter = &taos->adapter;\n\tadapter->owner = THIS_MODULE;\n\tadapter->algo = &taos_algorithm;\n\tadapter->algo_data = serio;\n\tadapter->dev.parent = &serio->dev;\n\n\t \n\tserio_write(serio, TAOS_CMD_RESET);\n\twait_event_interruptible_timeout(wq, taos->state == TAOS_STATE_IDLE,\n\t\t\t\t\t msecs_to_jiffies(2000));\n\n\tif (taos->state != TAOS_STATE_IDLE) {\n\t\terr = -ENODEV;\n\t\tdev_err(&serio->dev, \"TAOS EVM reset failed (state=%d, \"\n\t\t\t\"pos=%d)\\n\", taos->state, taos->pos);\n\t\tgoto exit_close;\n\t}\n\n\tname = taos_adapter_name(taos->buffer);\n\tif (!name) {\n\t\terr = -ENODEV;\n\t\tdev_err(&serio->dev, \"TAOS EVM identification failed\\n\");\n\t\tgoto exit_close;\n\t}\n\tstrscpy(adapter->name, name, sizeof(adapter->name));\n\n\t \n\ttaos->state = TAOS_STATE_EOFF;\n\tserio_write(serio, TAOS_CMD_ECHO_OFF);\n\n\twait_event_interruptible_timeout(wq, taos->state == TAOS_STATE_IDLE,\n\t\t\t\t\t msecs_to_jiffies(250));\n\tif (taos->state != TAOS_STATE_IDLE) {\n\t\terr = -ENODEV;\n\t\tdev_err(&serio->dev, \"TAOS EVM echo off failed \"\n\t\t\t\"(state=%d)\\n\", taos->state);\n\t\tgoto exit_close;\n\t}\n\n\terr = i2c_add_adapter(adapter);\n\tif (err)\n\t\tgoto exit_close;\n\tdev_info(&serio->dev, \"Connected to TAOS EVM\\n\");\n\n\ttaos->client = taos_instantiate_device(adapter);\n\treturn 0;\n\n exit_close:\n\tserio_close(serio);\n exit_kfree:\n\tkfree(taos);\n exit:\n\treturn err;\n}\n\nstatic void taos_disconnect(struct serio *serio)\n{\n\tstruct taos_data *taos = serio_get_drvdata(serio);\n\n\ti2c_unregister_device(taos->client);\n\ti2c_del_adapter(&taos->adapter);\n\tserio_close(serio);\n\tkfree(taos);\n\n\tdev_info(&serio->dev, \"Disconnected from TAOS EVM\\n\");\n}\n\nstatic const struct serio_device_id taos_serio_ids[] = {\n\t{\n\t\t.type\t= SERIO_RS232,\n\t\t.proto\t= SERIO_TAOSEVM,\n\t\t.id\t= SERIO_ANY,\n\t\t.extra\t= SERIO_ANY,\n\t},\n\t{ 0 }\n};\nMODULE_DEVICE_TABLE(serio, taos_serio_ids);\n\nstatic struct serio_driver taos_drv = {\n\t.driver\t\t= {\n\t\t.name\t= \"taos-evm\",\n\t},\n\t.description\t= \"TAOS evaluation module driver\",\n\t.id_table\t= taos_serio_ids,\n\t.connect\t= taos_connect,\n\t.disconnect\t= taos_disconnect,\n\t.interrupt\t= taos_interrupt,\n};\n\nmodule_serio_driver(taos_drv);\n\nMODULE_AUTHOR(\"Jean Delvare <jdelvare@suse.de>\");\nMODULE_DESCRIPTION(\"TAOS evaluation module driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}