{
  "module_name": "i2c-pca-platform.c",
  "hash_id": "ffc1e1692e5b959f98cf9a29c5d5f2846e41344d4de122924ee7350e109195e4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-pca-platform.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/errno.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/platform_device.h>\n#include <linux/i2c-algo-pca.h>\n#include <linux/platform_data/i2c-pca-platform.h>\n#include <linux/gpio/consumer.h>\n#include <linux/io.h>\n#include <linux/of.h>\n\n#include <asm/irq.h>\n\nstruct i2c_pca_pf_data {\n\tvoid __iomem\t\t\t*reg_base;\n\tint\t\t\t\tirq;\t \n\tstruct gpio_desc\t\t*gpio;\n\twait_queue_head_t\t\twait;\n\tstruct i2c_adapter\t\tadap;\n\tstruct i2c_algo_pca_data\talgo_data;\n};\n\n \n\nstatic int i2c_pca_pf_readbyte8(void *pd, int reg)\n{\n\tstruct i2c_pca_pf_data *i2c = pd;\n\treturn ioread8(i2c->reg_base + reg);\n}\n\nstatic int i2c_pca_pf_readbyte16(void *pd, int reg)\n{\n\tstruct i2c_pca_pf_data *i2c = pd;\n\treturn ioread8(i2c->reg_base + reg * 2);\n}\n\nstatic int i2c_pca_pf_readbyte32(void *pd, int reg)\n{\n\tstruct i2c_pca_pf_data *i2c = pd;\n\treturn ioread8(i2c->reg_base + reg * 4);\n}\n\nstatic void i2c_pca_pf_writebyte8(void *pd, int reg, int val)\n{\n\tstruct i2c_pca_pf_data *i2c = pd;\n\tiowrite8(val, i2c->reg_base + reg);\n}\n\nstatic void i2c_pca_pf_writebyte16(void *pd, int reg, int val)\n{\n\tstruct i2c_pca_pf_data *i2c = pd;\n\tiowrite8(val, i2c->reg_base + reg * 2);\n}\n\nstatic void i2c_pca_pf_writebyte32(void *pd, int reg, int val)\n{\n\tstruct i2c_pca_pf_data *i2c = pd;\n\tiowrite8(val, i2c->reg_base + reg * 4);\n}\n\n\nstatic int i2c_pca_pf_waitforcompletion(void *pd)\n{\n\tstruct i2c_pca_pf_data *i2c = pd;\n\tunsigned long timeout;\n\tlong ret;\n\n\tif (i2c->irq) {\n\t\tret = wait_event_timeout(i2c->wait,\n\t\t\ti2c->algo_data.read_byte(i2c, I2C_PCA_CON)\n\t\t\t& I2C_PCA_CON_SI, i2c->adap.timeout);\n\t} else {\n\t\t \n\t\ttimeout = jiffies + i2c->adap.timeout;\n\t\tdo {\n\t\t\tret = time_before(jiffies, timeout);\n\t\t\tif (i2c->algo_data.read_byte(i2c, I2C_PCA_CON)\n\t\t\t\t\t& I2C_PCA_CON_SI)\n\t\t\t\tbreak;\n\t\t\tudelay(100);\n\t\t} while (ret);\n\t}\n\n\treturn ret > 0;\n}\n\nstatic void i2c_pca_pf_dummyreset(void *pd)\n{\n\tstruct i2c_pca_pf_data *i2c = pd;\n\n\tdev_warn(&i2c->adap.dev, \"No reset-pin found. Chip may get stuck!\\n\");\n}\n\nstatic void i2c_pca_pf_resetchip(void *pd)\n{\n\tstruct i2c_pca_pf_data *i2c = pd;\n\n\tgpiod_set_value(i2c->gpio, 1);\n\tndelay(100);\n\tgpiod_set_value(i2c->gpio, 0);\n}\n\nstatic irqreturn_t i2c_pca_pf_handler(int this_irq, void *dev_id)\n{\n\tstruct i2c_pca_pf_data *i2c = dev_id;\n\n\tif ((i2c->algo_data.read_byte(i2c, I2C_PCA_CON) & I2C_PCA_CON_SI) == 0)\n\t\treturn IRQ_NONE;\n\n\twake_up(&i2c->wait);\n\n\treturn IRQ_HANDLED;\n}\n\n\nstatic int i2c_pca_pf_probe(struct platform_device *pdev)\n{\n\tstruct i2c_pca_pf_data *i2c;\n\tstruct resource *res;\n\tstruct i2c_pca9564_pf_platform_data *platform_data =\n\t\t\t\tdev_get_platdata(&pdev->dev);\n\tstruct device_node *np = pdev->dev.of_node;\n\tint ret = 0;\n\tint irq;\n\n\tirq = platform_get_irq_optional(pdev, 0);\n\t \n\tif (irq < 0)\n\t\tirq = 0;\n\n\ti2c = devm_kzalloc(&pdev->dev, sizeof(*i2c), GFP_KERNEL);\n\tif (!i2c)\n\t\treturn -ENOMEM;\n\n\ti2c->reg_base = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(i2c->reg_base))\n\t\treturn PTR_ERR(i2c->reg_base);\n\n\n\tinit_waitqueue_head(&i2c->wait);\n\n\ti2c->irq = irq;\n\n\ti2c->adap.nr = pdev->id;\n\ti2c->adap.owner = THIS_MODULE;\n\tsnprintf(i2c->adap.name, sizeof(i2c->adap.name),\n\t\t \"PCA9564/PCA9665 at 0x%08lx\",\n\t\t (unsigned long) res->start);\n\ti2c->adap.algo_data = &i2c->algo_data;\n\ti2c->adap.dev.parent = &pdev->dev;\n\ti2c->adap.dev.of_node = np;\n\n\ti2c->gpio = devm_gpiod_get_optional(&pdev->dev, \"reset\", GPIOD_OUT_LOW);\n\tif (IS_ERR(i2c->gpio))\n\t\treturn PTR_ERR(i2c->gpio);\n\n\ti2c->adap.timeout = HZ;\n\tret = device_property_read_u32(&pdev->dev, \"clock-frequency\",\n\t\t\t\t       &i2c->algo_data.i2c_clock);\n\tif (ret)\n\t\ti2c->algo_data.i2c_clock = 59000;\n\n\tif (platform_data) {\n\t\ti2c->adap.timeout = platform_data->timeout;\n\t\ti2c->algo_data.i2c_clock = platform_data->i2c_clock_speed;\n\t}\n\n\ti2c->algo_data.data = i2c;\n\ti2c->algo_data.wait_for_completion = i2c_pca_pf_waitforcompletion;\n\tif (i2c->gpio)\n\t\ti2c->algo_data.reset_chip = i2c_pca_pf_resetchip;\n\telse\n\t\ti2c->algo_data.reset_chip = i2c_pca_pf_dummyreset;\n\n\tswitch (res->flags & IORESOURCE_MEM_TYPE_MASK) {\n\tcase IORESOURCE_MEM_32BIT:\n\t\ti2c->algo_data.write_byte = i2c_pca_pf_writebyte32;\n\t\ti2c->algo_data.read_byte = i2c_pca_pf_readbyte32;\n\t\tbreak;\n\tcase IORESOURCE_MEM_16BIT:\n\t\ti2c->algo_data.write_byte = i2c_pca_pf_writebyte16;\n\t\ti2c->algo_data.read_byte = i2c_pca_pf_readbyte16;\n\t\tbreak;\n\tcase IORESOURCE_MEM_8BIT:\n\tdefault:\n\t\ti2c->algo_data.write_byte = i2c_pca_pf_writebyte8;\n\t\ti2c->algo_data.read_byte = i2c_pca_pf_readbyte8;\n\t\tbreak;\n\t}\n\n\tif (irq) {\n\t\tret = devm_request_irq(&pdev->dev, irq, i2c_pca_pf_handler,\n\t\t\tIRQF_TRIGGER_FALLING, pdev->name, i2c);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = i2c_pca_add_numbered_bus(&i2c->adap);\n\tif (ret)\n\t\treturn ret;\n\n\tplatform_set_drvdata(pdev, i2c);\n\n\tdev_info(&pdev->dev, \"registered.\\n\");\n\n\treturn 0;\n}\n\nstatic void i2c_pca_pf_remove(struct platform_device *pdev)\n{\n\tstruct i2c_pca_pf_data *i2c = platform_get_drvdata(pdev);\n\n\ti2c_del_adapter(&i2c->adap);\n}\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id i2c_pca_of_match_table[] = {\n\t{ .compatible = \"nxp,pca9564\" },\n\t{ .compatible = \"nxp,pca9665\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, i2c_pca_of_match_table);\n#endif\n\nstatic struct platform_driver i2c_pca_pf_driver = {\n\t.probe = i2c_pca_pf_probe,\n\t.remove_new = i2c_pca_pf_remove,\n\t.driver = {\n\t\t.name = \"i2c-pca-platform\",\n\t\t.of_match_table = of_match_ptr(i2c_pca_of_match_table),\n\t},\n};\n\nmodule_platform_driver(i2c_pca_pf_driver);\n\nMODULE_AUTHOR(\"Wolfram Sang <kernel@pengutronix.de>\");\nMODULE_DESCRIPTION(\"I2C-PCA9564/PCA9665 platform driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}