{
  "module_name": "i2c-bcm2835.c",
  "hash_id": "7aae52a1a46f58dbe8ce0e1e5056d02e7a0e67d67bdf15a443184334872cdf25",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-bcm2835.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/clkdev.h>\n#include <linux/clk-provider.h>\n#include <linux/completion.h>\n#include <linux/err.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n\n#define BCM2835_I2C_C\t\t0x0\n#define BCM2835_I2C_S\t\t0x4\n#define BCM2835_I2C_DLEN\t0x8\n#define BCM2835_I2C_A\t\t0xc\n#define BCM2835_I2C_FIFO\t0x10\n#define BCM2835_I2C_DIV\t\t0x14\n#define BCM2835_I2C_DEL\t\t0x18\n \n#define BCM2835_I2C_CLKT\t0x1c\n\n#define BCM2835_I2C_C_READ\tBIT(0)\n#define BCM2835_I2C_C_CLEAR\tBIT(4)  \n#define BCM2835_I2C_C_ST\tBIT(7)\n#define BCM2835_I2C_C_INTD\tBIT(8)\n#define BCM2835_I2C_C_INTT\tBIT(9)\n#define BCM2835_I2C_C_INTR\tBIT(10)\n#define BCM2835_I2C_C_I2CEN\tBIT(15)\n\n#define BCM2835_I2C_S_TA\tBIT(0)\n#define BCM2835_I2C_S_DONE\tBIT(1)\n#define BCM2835_I2C_S_TXW\tBIT(2)\n#define BCM2835_I2C_S_RXR\tBIT(3)\n#define BCM2835_I2C_S_TXD\tBIT(4)\n#define BCM2835_I2C_S_RXD\tBIT(5)\n#define BCM2835_I2C_S_TXE\tBIT(6)\n#define BCM2835_I2C_S_RXF\tBIT(7)\n#define BCM2835_I2C_S_ERR\tBIT(8)\n#define BCM2835_I2C_S_CLKT\tBIT(9)\n#define BCM2835_I2C_S_LEN\tBIT(10)  \n\n#define BCM2835_I2C_FEDL_SHIFT\t16\n#define BCM2835_I2C_REDL_SHIFT\t0\n\n#define BCM2835_I2C_CDIV_MIN\t0x0002\n#define BCM2835_I2C_CDIV_MAX\t0xFFFE\n\nstruct bcm2835_i2c_dev {\n\tstruct device *dev;\n\tvoid __iomem *regs;\n\tint irq;\n\tstruct i2c_adapter adapter;\n\tstruct completion completion;\n\tstruct i2c_msg *curr_msg;\n\tstruct clk *bus_clk;\n\tint num_msgs;\n\tu32 msg_err;\n\tu8 *msg_buf;\n\tsize_t msg_buf_remaining;\n};\n\nstatic inline void bcm2835_i2c_writel(struct bcm2835_i2c_dev *i2c_dev,\n\t\t\t\t      u32 reg, u32 val)\n{\n\twritel(val, i2c_dev->regs + reg);\n}\n\nstatic inline u32 bcm2835_i2c_readl(struct bcm2835_i2c_dev *i2c_dev, u32 reg)\n{\n\treturn readl(i2c_dev->regs + reg);\n}\n\n#define to_clk_bcm2835_i2c(_hw) container_of(_hw, struct clk_bcm2835_i2c, hw)\nstruct clk_bcm2835_i2c {\n\tstruct clk_hw hw;\n\tstruct bcm2835_i2c_dev *i2c_dev;\n};\n\nstatic int clk_bcm2835_i2c_calc_divider(unsigned long rate,\n\t\t\t\tunsigned long parent_rate)\n{\n\tu32 divider = DIV_ROUND_UP(parent_rate, rate);\n\n\t \n\tif (divider & 1)\n\t\tdivider++;\n\tif ((divider < BCM2835_I2C_CDIV_MIN) ||\n\t    (divider > BCM2835_I2C_CDIV_MAX))\n\t\treturn -EINVAL;\n\n\treturn divider;\n}\n\nstatic int clk_bcm2835_i2c_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\tunsigned long parent_rate)\n{\n\tstruct clk_bcm2835_i2c *div = to_clk_bcm2835_i2c(hw);\n\tu32 redl, fedl;\n\tu32 divider = clk_bcm2835_i2c_calc_divider(rate, parent_rate);\n\n\tif (divider == -EINVAL)\n\t\treturn -EINVAL;\n\n\tbcm2835_i2c_writel(div->i2c_dev, BCM2835_I2C_DIV, divider);\n\n\t \n\tfedl = max(divider / 16, 1u);\n\n\t \n\tredl = max(divider / 4, 1u);\n\n\tbcm2835_i2c_writel(div->i2c_dev, BCM2835_I2C_DEL,\n\t\t\t   (fedl << BCM2835_I2C_FEDL_SHIFT) |\n\t\t\t   (redl << BCM2835_I2C_REDL_SHIFT));\n\treturn 0;\n}\n\nstatic long clk_bcm2835_i2c_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\tunsigned long *parent_rate)\n{\n\tu32 divider = clk_bcm2835_i2c_calc_divider(rate, *parent_rate);\n\n\treturn DIV_ROUND_UP(*parent_rate, divider);\n}\n\nstatic unsigned long clk_bcm2835_i2c_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t\tunsigned long parent_rate)\n{\n\tstruct clk_bcm2835_i2c *div = to_clk_bcm2835_i2c(hw);\n\tu32 divider = bcm2835_i2c_readl(div->i2c_dev, BCM2835_I2C_DIV);\n\n\treturn DIV_ROUND_UP(parent_rate, divider);\n}\n\nstatic const struct clk_ops clk_bcm2835_i2c_ops = {\n\t.set_rate = clk_bcm2835_i2c_set_rate,\n\t.round_rate = clk_bcm2835_i2c_round_rate,\n\t.recalc_rate = clk_bcm2835_i2c_recalc_rate,\n};\n\nstatic struct clk *bcm2835_i2c_register_div(struct device *dev,\n\t\t\t\t\tstruct clk *mclk,\n\t\t\t\t\tstruct bcm2835_i2c_dev *i2c_dev)\n{\n\tstruct clk_init_data init;\n\tstruct clk_bcm2835_i2c *priv;\n\tchar name[32];\n\tconst char *mclk_name;\n\n\tsnprintf(name, sizeof(name), \"%s_div\", dev_name(dev));\n\n\tmclk_name = __clk_get_name(mclk);\n\n\tinit.ops = &clk_bcm2835_i2c_ops;\n\tinit.name = name;\n\tinit.parent_names = (const char* []) { mclk_name };\n\tinit.num_parents = 1;\n\tinit.flags = 0;\n\n\tpriv = devm_kzalloc(dev, sizeof(struct clk_bcm2835_i2c), GFP_KERNEL);\n\tif (priv == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tpriv->hw.init = &init;\n\tpriv->i2c_dev = i2c_dev;\n\n\tclk_hw_register_clkdev(&priv->hw, \"div\", dev_name(dev));\n\treturn devm_clk_register(dev, &priv->hw);\n}\n\nstatic void bcm2835_fill_txfifo(struct bcm2835_i2c_dev *i2c_dev)\n{\n\tu32 val;\n\n\twhile (i2c_dev->msg_buf_remaining) {\n\t\tval = bcm2835_i2c_readl(i2c_dev, BCM2835_I2C_S);\n\t\tif (!(val & BCM2835_I2C_S_TXD))\n\t\t\tbreak;\n\t\tbcm2835_i2c_writel(i2c_dev, BCM2835_I2C_FIFO,\n\t\t\t\t   *i2c_dev->msg_buf);\n\t\ti2c_dev->msg_buf++;\n\t\ti2c_dev->msg_buf_remaining--;\n\t}\n}\n\nstatic void bcm2835_drain_rxfifo(struct bcm2835_i2c_dev *i2c_dev)\n{\n\tu32 val;\n\n\twhile (i2c_dev->msg_buf_remaining) {\n\t\tval = bcm2835_i2c_readl(i2c_dev, BCM2835_I2C_S);\n\t\tif (!(val & BCM2835_I2C_S_RXD))\n\t\t\tbreak;\n\t\t*i2c_dev->msg_buf = bcm2835_i2c_readl(i2c_dev,\n\t\t\t\t\t\t      BCM2835_I2C_FIFO);\n\t\ti2c_dev->msg_buf++;\n\t\ti2c_dev->msg_buf_remaining--;\n\t}\n}\n\n \n\nstatic void bcm2835_i2c_start_transfer(struct bcm2835_i2c_dev *i2c_dev)\n{\n\tu32 c = BCM2835_I2C_C_ST | BCM2835_I2C_C_I2CEN;\n\tstruct i2c_msg *msg = i2c_dev->curr_msg;\n\tbool last_msg = (i2c_dev->num_msgs == 1);\n\n\tif (!i2c_dev->num_msgs)\n\t\treturn;\n\n\ti2c_dev->num_msgs--;\n\ti2c_dev->msg_buf = msg->buf;\n\ti2c_dev->msg_buf_remaining = msg->len;\n\n\tif (msg->flags & I2C_M_RD)\n\t\tc |= BCM2835_I2C_C_READ | BCM2835_I2C_C_INTR;\n\telse\n\t\tc |= BCM2835_I2C_C_INTT;\n\n\tif (last_msg)\n\t\tc |= BCM2835_I2C_C_INTD;\n\n\tbcm2835_i2c_writel(i2c_dev, BCM2835_I2C_A, msg->addr);\n\tbcm2835_i2c_writel(i2c_dev, BCM2835_I2C_DLEN, msg->len);\n\tbcm2835_i2c_writel(i2c_dev, BCM2835_I2C_C, c);\n}\n\nstatic void bcm2835_i2c_finish_transfer(struct bcm2835_i2c_dev *i2c_dev)\n{\n\ti2c_dev->curr_msg = NULL;\n\ti2c_dev->num_msgs = 0;\n\n\ti2c_dev->msg_buf = NULL;\n\ti2c_dev->msg_buf_remaining = 0;\n}\n\n \n\nstatic irqreturn_t bcm2835_i2c_isr(int this_irq, void *data)\n{\n\tstruct bcm2835_i2c_dev *i2c_dev = data;\n\tu32 val, err;\n\n\tval = bcm2835_i2c_readl(i2c_dev, BCM2835_I2C_S);\n\n\terr = val & (BCM2835_I2C_S_CLKT | BCM2835_I2C_S_ERR);\n\tif (err) {\n\t\ti2c_dev->msg_err = err;\n\t\tgoto complete;\n\t}\n\n\tif (val & BCM2835_I2C_S_DONE) {\n\t\tif (!i2c_dev->curr_msg) {\n\t\t\tdev_err(i2c_dev->dev, \"Got unexpected interrupt (from firmware?)\\n\");\n\t\t} else if (i2c_dev->curr_msg->flags & I2C_M_RD) {\n\t\t\tbcm2835_drain_rxfifo(i2c_dev);\n\t\t\tval = bcm2835_i2c_readl(i2c_dev, BCM2835_I2C_S);\n\t\t}\n\n\t\tif ((val & BCM2835_I2C_S_RXD) || i2c_dev->msg_buf_remaining)\n\t\t\ti2c_dev->msg_err = BCM2835_I2C_S_LEN;\n\t\telse\n\t\t\ti2c_dev->msg_err = 0;\n\t\tgoto complete;\n\t}\n\n\tif (val & BCM2835_I2C_S_TXW) {\n\t\tif (!i2c_dev->msg_buf_remaining) {\n\t\t\ti2c_dev->msg_err = val | BCM2835_I2C_S_LEN;\n\t\t\tgoto complete;\n\t\t}\n\n\t\tbcm2835_fill_txfifo(i2c_dev);\n\n\t\tif (i2c_dev->num_msgs && !i2c_dev->msg_buf_remaining) {\n\t\t\ti2c_dev->curr_msg++;\n\t\t\tbcm2835_i2c_start_transfer(i2c_dev);\n\t\t}\n\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tif (val & BCM2835_I2C_S_RXR) {\n\t\tif (!i2c_dev->msg_buf_remaining) {\n\t\t\ti2c_dev->msg_err = val | BCM2835_I2C_S_LEN;\n\t\t\tgoto complete;\n\t\t}\n\n\t\tbcm2835_drain_rxfifo(i2c_dev);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\treturn IRQ_NONE;\n\ncomplete:\n\tbcm2835_i2c_writel(i2c_dev, BCM2835_I2C_C, BCM2835_I2C_C_CLEAR);\n\tbcm2835_i2c_writel(i2c_dev, BCM2835_I2C_S, BCM2835_I2C_S_CLKT |\n\t\t\t   BCM2835_I2C_S_ERR | BCM2835_I2C_S_DONE);\n\tcomplete(&i2c_dev->completion);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int bcm2835_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg msgs[],\n\t\t\t    int num)\n{\n\tstruct bcm2835_i2c_dev *i2c_dev = i2c_get_adapdata(adap);\n\tunsigned long time_left;\n\tint i;\n\n\tfor (i = 0; i < (num - 1); i++)\n\t\tif (msgs[i].flags & I2C_M_RD) {\n\t\t\tdev_warn_once(i2c_dev->dev,\n\t\t\t\t      \"only one read message supported, has to be last\\n\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\n\ti2c_dev->curr_msg = msgs;\n\ti2c_dev->num_msgs = num;\n\treinit_completion(&i2c_dev->completion);\n\n\tbcm2835_i2c_start_transfer(i2c_dev);\n\n\ttime_left = wait_for_completion_timeout(&i2c_dev->completion,\n\t\t\t\t\t\tadap->timeout);\n\n\tbcm2835_i2c_finish_transfer(i2c_dev);\n\n\tif (!time_left) {\n\t\tbcm2835_i2c_writel(i2c_dev, BCM2835_I2C_C,\n\t\t\t\t   BCM2835_I2C_C_CLEAR);\n\t\tdev_err(i2c_dev->dev, \"i2c transfer timed out\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tif (!i2c_dev->msg_err)\n\t\treturn num;\n\n\tdev_dbg(i2c_dev->dev, \"i2c transfer failed: %x\\n\", i2c_dev->msg_err);\n\n\tif (i2c_dev->msg_err & BCM2835_I2C_S_ERR)\n\t\treturn -EREMOTEIO;\n\n\treturn -EIO;\n}\n\nstatic u32 bcm2835_i2c_func(struct i2c_adapter *adap)\n{\n\treturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;\n}\n\nstatic const struct i2c_algorithm bcm2835_i2c_algo = {\n\t.master_xfer\t= bcm2835_i2c_xfer,\n\t.functionality\t= bcm2835_i2c_func,\n};\n\n \nstatic const struct i2c_adapter_quirks bcm2835_i2c_quirks = {\n\t.flags = I2C_AQ_NO_CLK_STRETCH,\n};\n\nstatic int bcm2835_i2c_probe(struct platform_device *pdev)\n{\n\tstruct bcm2835_i2c_dev *i2c_dev;\n\tint ret;\n\tstruct i2c_adapter *adap;\n\tstruct clk *mclk;\n\tu32 bus_clk_rate;\n\n\ti2c_dev = devm_kzalloc(&pdev->dev, sizeof(*i2c_dev), GFP_KERNEL);\n\tif (!i2c_dev)\n\t\treturn -ENOMEM;\n\tplatform_set_drvdata(pdev, i2c_dev);\n\ti2c_dev->dev = &pdev->dev;\n\tinit_completion(&i2c_dev->completion);\n\n\ti2c_dev->regs = devm_platform_get_and_ioremap_resource(pdev, 0, NULL);\n\tif (IS_ERR(i2c_dev->regs))\n\t\treturn PTR_ERR(i2c_dev->regs);\n\n\tmclk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(mclk))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(mclk),\n\t\t\t\t     \"Could not get clock\\n\");\n\n\ti2c_dev->bus_clk = bcm2835_i2c_register_div(&pdev->dev, mclk, i2c_dev);\n\n\tif (IS_ERR(i2c_dev->bus_clk))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(i2c_dev->bus_clk),\n\t\t\t\t     \"Could not register clock\\n\");\n\n\tret = of_property_read_u32(pdev->dev.of_node, \"clock-frequency\",\n\t\t\t\t   &bus_clk_rate);\n\tif (ret < 0) {\n\t\tdev_warn(&pdev->dev,\n\t\t\t \"Could not read clock-frequency property\\n\");\n\t\tbus_clk_rate = I2C_MAX_STANDARD_MODE_FREQ;\n\t}\n\n\tret = clk_set_rate_exclusive(i2c_dev->bus_clk, bus_clk_rate);\n\tif (ret < 0)\n\t\treturn dev_err_probe(&pdev->dev, ret,\n\t\t\t\t     \"Could not set clock frequency\\n\");\n\n\tret = clk_prepare_enable(i2c_dev->bus_clk);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Couldn't prepare clock\");\n\t\tgoto err_put_exclusive_rate;\n\t}\n\n\ti2c_dev->irq = platform_get_irq(pdev, 0);\n\tif (i2c_dev->irq < 0) {\n\t\tret = i2c_dev->irq;\n\t\tgoto err_disable_unprepare_clk;\n\t}\n\n\tret = request_irq(i2c_dev->irq, bcm2835_i2c_isr, IRQF_SHARED,\n\t\t\t  dev_name(&pdev->dev), i2c_dev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Could not request IRQ\\n\");\n\t\tgoto err_disable_unprepare_clk;\n\t}\n\n\tadap = &i2c_dev->adapter;\n\ti2c_set_adapdata(adap, i2c_dev);\n\tadap->owner = THIS_MODULE;\n\tadap->class = I2C_CLASS_DEPRECATED;\n\tsnprintf(adap->name, sizeof(adap->name), \"bcm2835 (%s)\",\n\t\t of_node_full_name(pdev->dev.of_node));\n\tadap->algo = &bcm2835_i2c_algo;\n\tadap->dev.parent = &pdev->dev;\n\tadap->dev.of_node = pdev->dev.of_node;\n\tadap->quirks = of_device_get_match_data(&pdev->dev);\n\n\t \n\tbcm2835_i2c_writel(i2c_dev, BCM2835_I2C_CLKT, 0);\n\tbcm2835_i2c_writel(i2c_dev, BCM2835_I2C_C, 0);\n\n\tret = i2c_add_adapter(adap);\n\tif (ret)\n\t\tgoto err_free_irq;\n\n\treturn 0;\n\nerr_free_irq:\n\tfree_irq(i2c_dev->irq, i2c_dev);\nerr_disable_unprepare_clk:\n\tclk_disable_unprepare(i2c_dev->bus_clk);\nerr_put_exclusive_rate:\n\tclk_rate_exclusive_put(i2c_dev->bus_clk);\n\n\treturn ret;\n}\n\nstatic void bcm2835_i2c_remove(struct platform_device *pdev)\n{\n\tstruct bcm2835_i2c_dev *i2c_dev = platform_get_drvdata(pdev);\n\n\tclk_rate_exclusive_put(i2c_dev->bus_clk);\n\tclk_disable_unprepare(i2c_dev->bus_clk);\n\n\tfree_irq(i2c_dev->irq, i2c_dev);\n\ti2c_del_adapter(&i2c_dev->adapter);\n}\n\nstatic const struct of_device_id bcm2835_i2c_of_match[] = {\n\t{ .compatible = \"brcm,bcm2711-i2c\" },\n\t{ .compatible = \"brcm,bcm2835-i2c\", .data = &bcm2835_i2c_quirks },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, bcm2835_i2c_of_match);\n\nstatic struct platform_driver bcm2835_i2c_driver = {\n\t.probe\t\t= bcm2835_i2c_probe,\n\t.remove_new\t= bcm2835_i2c_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"i2c-bcm2835\",\n\t\t.of_match_table = bcm2835_i2c_of_match,\n\t},\n};\nmodule_platform_driver(bcm2835_i2c_driver);\n\nMODULE_AUTHOR(\"Stephen Warren <swarren@wwwdotorg.org>\");\nMODULE_DESCRIPTION(\"BCM2835 I2C bus adapter\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:i2c-bcm2835\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}