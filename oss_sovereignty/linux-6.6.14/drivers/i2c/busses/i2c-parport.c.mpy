{
  "module_name": "i2c-parport.c",
  "hash_id": "d347bba230047d96277f02e085bf96bdb6a68a151ec55cd95316c25ad11574d1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-parport.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"i2c-parport: \" fmt\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/parport.h>\n#include <linux/i2c.h>\n#include <linux/i2c-algo-bit.h>\n#include <linux/i2c-smbus.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n\n#define PORT_DATA\t0\n#define PORT_STAT\t1\n#define PORT_CTRL\t2\n\nstruct lineop {\n\tu8 val;\n\tu8 port;\n\tu8 inverted;\n};\n\nstruct adapter_parm {\n\tstruct lineop setsda;\n\tstruct lineop setscl;\n\tstruct lineop getsda;\n\tstruct lineop getscl;\n\tstruct lineop init;\n\tunsigned int smbus_alert:1;\n};\n\nstatic const struct adapter_parm adapter_parm[] = {\n\t \n\t{\n\t\t.setsda\t= { 0x80, PORT_DATA, 1 },\n\t\t.setscl\t= { 0x08, PORT_CTRL, 0 },\n\t\t.getsda\t= { 0x80, PORT_STAT, 0 },\n\t\t.getscl\t= { 0x08, PORT_STAT, 0 },\n\t},\n\t \n\t{\n\t\t.setsda\t= { 0x02, PORT_DATA, 0 },\n\t\t.setscl\t= { 0x01, PORT_DATA, 0 },\n\t\t.getsda\t= { 0x80, PORT_STAT, 1 },\n\t},\n\t \n\t{\n\t\t.setsda\t= { 0x02, PORT_CTRL, 1 },\n\t\t.setscl\t= { 0x08, PORT_CTRL, 1 },\n\t\t.getsda\t= { 0x10, PORT_STAT, 0 },\n\t},\n\t \n\t{\n\t\t.setsda\t= { 0x02, PORT_DATA, 1 },\n\t\t.setscl\t= { 0x01, PORT_DATA, 1 },\n\t\t.getsda\t= { 0x40, PORT_STAT, 1 },\n\t\t.getscl\t= { 0x08, PORT_STAT, 1 },\n\t},\n\t \n\t{\n\t\t.setsda\t= { 0x02, PORT_DATA, 1 },\n\t\t.setscl\t= { 0x01, PORT_DATA, 1 },\n\t\t.getsda\t= { 0x10, PORT_STAT, 1 },\n\t\t.init\t= { 0xf0, PORT_DATA, 0 },\n\t\t.smbus_alert = 1,\n\t},\n\t \n\t{\n\t\t.setsda\t= { 0x02, PORT_DATA, 1 },\n\t\t.setscl\t= { 0x01, PORT_DATA, 1 },\n\t\t.getsda\t= { 0x10, PORT_STAT, 1 },\n\t},\n\t \n\t{\n\t\t.setsda\t= { 0x02, PORT_DATA, 1 },\n\t\t.setscl\t= { 0x01, PORT_DATA, 1 },\n\t\t.getsda\t= { 0x20, PORT_STAT, 0 },\n\t\t.getscl\t= { 0x40, PORT_STAT, 0 },\n\t\t.init\t= { 0xfc, PORT_DATA, 0 },\n\t},\n\t \n\t{\n\t\t.setsda\t= { 0x01, PORT_DATA, 0 },\n\t\t.setscl\t= { 0x02, PORT_DATA, 0 },\n\t\t.getsda\t= { 0x80, PORT_STAT, 1 },\n\t\t.init\t= { 0x04, PORT_DATA, 1 },\n\t},\n\t \n\t{\n\t\t.setsda\t= { 0x04, PORT_DATA, 1 },\n\t\t.setscl\t= { 0x01, PORT_DATA, 1 },\n\t\t.getsda\t= { 0x40, PORT_STAT, 0 },\n\t\t.getscl\t= { 0x80, PORT_STAT, 1 },\n\t},\n};\n\n \n\nstruct i2c_par {\n\tstruct pardevice *pdev;\n\tstruct i2c_adapter adapter;\n\tstruct i2c_algo_bit_data algo_data;\n\tstruct i2c_smbus_alert_setup alert_data;\n\tstruct i2c_client *ara;\n\tstruct list_head node;\n};\n\nstatic LIST_HEAD(adapter_list);\nstatic DEFINE_MUTEX(adapter_list_lock);\n\n#define MAX_DEVICE 4\nstatic int parport[MAX_DEVICE] = {0, -1, -1, -1};\nmodule_param_array(parport, int, NULL, 0);\nMODULE_PARM_DESC(parport,\n\t\t \"List of parallel ports to bind to, by index.\\n\"\n\t\t \" At most \" __stringify(MAX_DEVICE) \" devices are supported.\\n\"\n\t\t \" Default is one device connected to parport0.\\n\"\n);\n\nstatic int type = -1;\nmodule_param(type, int, 0);\nMODULE_PARM_DESC(type,\n\t\"Type of adapter:\\n\"\n\t\" 0 = Philips adapter\\n\"\n\t\" 1 = home brew teletext adapter\\n\"\n\t\" 2 = Velleman K8000 adapter\\n\"\n\t\" 3 = ELV adapter\\n\"\n\t\" 4 = ADM1032 evaluation board\\n\"\n\t\" 5 = ADM1025, ADM1030 and ADM1031 evaluation boards\\n\"\n\t\" 6 = Barco LPT->DVI (K5800236) adapter\\n\"\n\t\" 7 = One For All JP1 parallel port adapter\\n\"\n\t\" 8 = VCT-jig\\n\"\n);\n\n \n\nstatic void port_write_data(struct parport *p, unsigned char d)\n{\n\tparport_write_data(p, d);\n}\n\nstatic void port_write_control(struct parport *p, unsigned char d)\n{\n\tparport_write_control(p, d);\n}\n\nstatic unsigned char port_read_data(struct parport *p)\n{\n\treturn parport_read_data(p);\n}\n\nstatic unsigned char port_read_status(struct parport *p)\n{\n\treturn parport_read_status(p);\n}\n\nstatic unsigned char port_read_control(struct parport *p)\n{\n\treturn parport_read_control(p);\n}\n\nstatic void (* const port_write[])(struct parport *, unsigned char) = {\n\tport_write_data,\n\tNULL,\n\tport_write_control,\n};\n\nstatic unsigned char (* const port_read[])(struct parport *) = {\n\tport_read_data,\n\tport_read_status,\n\tport_read_control,\n};\n\n \n\nstatic inline void line_set(struct parport *data, int state,\n\tconst struct lineop *op)\n{\n\tu8 oldval = port_read[op->port](data);\n\n\t \n\tif ((op->inverted && !state) || (!op->inverted && state))\n\t\tport_write[op->port](data, oldval | op->val);\n\telse\n\t\tport_write[op->port](data, oldval & ~op->val);\n}\n\nstatic inline int line_get(struct parport *data,\n\tconst struct lineop *op)\n{\n\tu8 oldval = port_read[op->port](data);\n\n\treturn ((op->inverted && (oldval & op->val) != op->val)\n\t    || (!op->inverted && (oldval & op->val) == op->val));\n}\n\n \n\nstatic void parport_setscl(void *data, int state)\n{\n\tline_set((struct parport *) data, state, &adapter_parm[type].setscl);\n}\n\nstatic void parport_setsda(void *data, int state)\n{\n\tline_set((struct parport *) data, state, &adapter_parm[type].setsda);\n}\n\nstatic int parport_getscl(void *data)\n{\n\treturn line_get((struct parport *) data, &adapter_parm[type].getscl);\n}\n\nstatic int parport_getsda(void *data)\n{\n\treturn line_get((struct parport *) data, &adapter_parm[type].getsda);\n}\n\n \nstatic const struct i2c_algo_bit_data parport_algo_data = {\n\t.setsda\t\t= parport_setsda,\n\t.setscl\t\t= parport_setscl,\n\t.getsda\t\t= parport_getsda,\n\t.getscl\t\t= parport_getscl,\n\t.udelay\t\t= 10,  \n\t.timeout\t= HZ,\n};\n\n \n\nstatic void i2c_parport_irq(void *data)\n{\n\tstruct i2c_par *adapter = data;\n\tstruct i2c_client *ara = adapter->ara;\n\n\tif (ara) {\n\t\tdev_dbg(&ara->dev, \"SMBus alert received\\n\");\n\t\ti2c_handle_smbus_alert(ara);\n\t} else\n\t\tdev_dbg(&adapter->adapter.dev,\n\t\t\t\"SMBus alert received but no ARA client!\\n\");\n}\n\nstatic void i2c_parport_attach(struct parport *port)\n{\n\tstruct i2c_par *adapter;\n\tint i;\n\tstruct pardev_cb i2c_parport_cb;\n\n\tif (type < 0) {\n\t\tpr_warn(\"adapter type unspecified\\n\");\n\t\treturn;\n\t}\n\n\tif (type >= ARRAY_SIZE(adapter_parm)) {\n\t\tpr_warn(\"invalid type (%d)\\n\", type);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < MAX_DEVICE; i++) {\n\t\tif (parport[i] == -1)\n\t\t\tcontinue;\n\t\tif (port->number == parport[i])\n\t\t\tbreak;\n\t}\n\tif (i == MAX_DEVICE) {\n\t\tpr_debug(\"Not using parport%d.\\n\", port->number);\n\t\treturn;\n\t}\n\n\tadapter = kzalloc(sizeof(struct i2c_par), GFP_KERNEL);\n\tif (!adapter)\n\t\treturn;\n\tmemset(&i2c_parport_cb, 0, sizeof(i2c_parport_cb));\n\ti2c_parport_cb.flags = PARPORT_FLAG_EXCL;\n\ti2c_parport_cb.irq_func = i2c_parport_irq;\n\ti2c_parport_cb.private = adapter;\n\n\tpr_debug(\"attaching to %s\\n\", port->name);\n\tparport_disable_irq(port);\n\tadapter->pdev = parport_register_dev_model(port, \"i2c-parport\",\n\t\t\t\t\t\t   &i2c_parport_cb, i);\n\tif (!adapter->pdev) {\n\t\tpr_err(\"Unable to register with parport\\n\");\n\t\tgoto err_free;\n\t}\n\n\t \n\tadapter->adapter.owner = THIS_MODULE;\n\tadapter->adapter.class = I2C_CLASS_HWMON;\n\tstrscpy(adapter->adapter.name, \"Parallel port adapter\",\n\t\tsizeof(adapter->adapter.name));\n\tadapter->algo_data = parport_algo_data;\n\t \n\tif (!adapter_parm[type].getscl.val) {\n\t\tadapter->algo_data.getscl = NULL;\n\t\tadapter->algo_data.udelay = 50;  \n\t}\n\tadapter->algo_data.data = port;\n\tadapter->adapter.algo_data = &adapter->algo_data;\n\tadapter->adapter.dev.parent = port->physport->dev;\n\n\tif (parport_claim_or_block(adapter->pdev) < 0) {\n\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\"Could not claim parallel port\\n\");\n\t\tgoto err_unregister;\n\t}\n\n\t \n\tparport_setsda(port, 1);\n\tparport_setscl(port, 1);\n\t \n\tif (adapter_parm[type].init.val) {\n\t\tline_set(port, 1, &adapter_parm[type].init);\n\t\t \n\t\tmsleep(100);\n\t}\n\n\tif (i2c_bit_add_bus(&adapter->adapter) < 0) {\n\t\tdev_err(&adapter->pdev->dev, \"Unable to register with I2C\\n\");\n\t\tgoto err_unregister;\n\t}\n\n\t \n\tif (adapter_parm[type].smbus_alert) {\n\t\tstruct i2c_client *ara;\n\n\t\tara = i2c_new_smbus_alert_device(&adapter->adapter,\n\t\t\t\t\t\t &adapter->alert_data);\n\t\tif (!IS_ERR(ara)) {\n\t\t\tadapter->ara = ara;\n\t\t\tparport_enable_irq(port);\n\t\t} else {\n\t\t\tdev_warn(&adapter->pdev->dev,\n\t\t\t\t \"Failed to register ARA client\\n\");\n\t\t}\n\t}\n\n\t \n\tmutex_lock(&adapter_list_lock);\n\tlist_add_tail(&adapter->node, &adapter_list);\n\tmutex_unlock(&adapter_list_lock);\n\treturn;\n\n err_unregister:\n\tparport_release(adapter->pdev);\n\tparport_unregister_device(adapter->pdev);\n err_free:\n\tkfree(adapter);\n}\n\nstatic void i2c_parport_detach(struct parport *port)\n{\n\tstruct i2c_par *adapter, *_n;\n\n\t \n\tmutex_lock(&adapter_list_lock);\n\tlist_for_each_entry_safe(adapter, _n, &adapter_list, node) {\n\t\tif (adapter->pdev->port == port) {\n\t\t\tif (adapter->ara) {\n\t\t\t\tparport_disable_irq(port);\n\t\t\t\ti2c_unregister_device(adapter->ara);\n\t\t\t}\n\t\t\ti2c_del_adapter(&adapter->adapter);\n\n\t\t\t \n\t\t\tif (adapter_parm[type].init.val)\n\t\t\t\tline_set(port, 0, &adapter_parm[type].init);\n\n\t\t\tparport_release(adapter->pdev);\n\t\t\tparport_unregister_device(adapter->pdev);\n\t\t\tlist_del(&adapter->node);\n\t\t\tkfree(adapter);\n\t\t}\n\t}\n\tmutex_unlock(&adapter_list_lock);\n}\n\nstatic struct parport_driver i2c_parport_driver = {\n\t.name = \"i2c-parport\",\n\t.match_port = i2c_parport_attach,\n\t.detach = i2c_parport_detach,\n\t.devmodel = true,\n};\nmodule_parport_driver(i2c_parport_driver);\n\nMODULE_AUTHOR(\"Jean Delvare <jdelvare@suse.de>\");\nMODULE_DESCRIPTION(\"I2C bus over parallel port\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}