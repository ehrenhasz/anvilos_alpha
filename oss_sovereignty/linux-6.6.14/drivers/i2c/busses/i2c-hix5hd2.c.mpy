{
  "module_name": "i2c-hix5hd2.c",
  "hash_id": "6afd1bc4d7f0754dced68eda2cbb168223a11cd576ee7db8c8298b96b0b3996c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-hix5hd2.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/i2c.h>\n#include <linux/io.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n\n \n#define HIX5I2C_CTRL\t\t0x00\n#define HIX5I2C_COM\t\t0x04\n#define HIX5I2C_ICR\t\t0x08\n#define HIX5I2C_SR\t\t0x0c\n#define HIX5I2C_SCL_H\t\t0x10\n#define HIX5I2C_SCL_L\t\t0x14\n#define HIX5I2C_TXR\t\t0x18\n#define HIX5I2C_RXR\t\t0x1c\n\n \n#define I2C_ENABLE\t\tBIT(8)\n#define I2C_UNMASK_TOTAL\tBIT(7)\n#define I2C_UNMASK_START\tBIT(6)\n#define I2C_UNMASK_END\t\tBIT(5)\n#define I2C_UNMASK_SEND\t\tBIT(4)\n#define I2C_UNMASK_RECEIVE\tBIT(3)\n#define I2C_UNMASK_ACK\t\tBIT(2)\n#define I2C_UNMASK_ARBITRATE\tBIT(1)\n#define I2C_UNMASK_OVER\t\tBIT(0)\n#define I2C_UNMASK_ALL\t\t(I2C_UNMASK_ACK | I2C_UNMASK_OVER)\n\n \n#define I2C_NO_ACK\t\tBIT(4)\n#define I2C_START\t\tBIT(3)\n#define I2C_READ\t\tBIT(2)\n#define I2C_WRITE\t\tBIT(1)\n#define I2C_STOP\t\tBIT(0)\n\n \n#define I2C_CLEAR_START\t\tBIT(6)\n#define I2C_CLEAR_END\t\tBIT(5)\n#define I2C_CLEAR_SEND\t\tBIT(4)\n#define I2C_CLEAR_RECEIVE\tBIT(3)\n#define I2C_CLEAR_ACK\t\tBIT(2)\n#define I2C_CLEAR_ARBITRATE\tBIT(1)\n#define I2C_CLEAR_OVER\t\tBIT(0)\n#define I2C_CLEAR_ALL\t\t(I2C_CLEAR_START | I2C_CLEAR_END | \\\n\t\t\t\tI2C_CLEAR_SEND | I2C_CLEAR_RECEIVE | \\\n\t\t\t\tI2C_CLEAR_ACK | I2C_CLEAR_ARBITRATE | \\\n\t\t\t\tI2C_CLEAR_OVER)\n\n \n#define I2C_BUSY\t\tBIT(7)\n#define I2C_START_INTR\t\tBIT(6)\n#define I2C_END_INTR\t\tBIT(5)\n#define I2C_SEND_INTR\t\tBIT(4)\n#define I2C_RECEIVE_INTR\tBIT(3)\n#define I2C_ACK_INTR\t\tBIT(2)\n#define I2C_ARBITRATE_INTR\tBIT(1)\n#define I2C_OVER_INTR\t\tBIT(0)\n\nenum hix5hd2_i2c_state {\n\tHIX5I2C_STAT_RW_ERR = -1,\n\tHIX5I2C_STAT_INIT,\n\tHIX5I2C_STAT_RW,\n\tHIX5I2C_STAT_SND_STOP,\n\tHIX5I2C_STAT_RW_SUCCESS,\n};\n\nstruct hix5hd2_i2c_priv {\n\tstruct i2c_adapter adap;\n\tstruct i2c_msg *msg;\n\tstruct completion msg_complete;\n\tunsigned int msg_idx;\n\tunsigned int msg_len;\n\tint stop;\n\tvoid __iomem *regs;\n\tstruct clk *clk;\n\tstruct device *dev;\n\tspinlock_t lock;\t \n\tint err;\n\tunsigned int freq;\n\tenum hix5hd2_i2c_state state;\n};\n\nstatic u32 hix5hd2_i2c_clr_pend_irq(struct hix5hd2_i2c_priv *priv)\n{\n\tu32 val = readl_relaxed(priv->regs + HIX5I2C_SR);\n\n\twritel_relaxed(val, priv->regs + HIX5I2C_ICR);\n\n\treturn val;\n}\n\nstatic void hix5hd2_i2c_clr_all_irq(struct hix5hd2_i2c_priv *priv)\n{\n\twritel_relaxed(I2C_CLEAR_ALL, priv->regs + HIX5I2C_ICR);\n}\n\nstatic void hix5hd2_i2c_disable_irq(struct hix5hd2_i2c_priv *priv)\n{\n\twritel_relaxed(0, priv->regs + HIX5I2C_CTRL);\n}\n\nstatic void hix5hd2_i2c_enable_irq(struct hix5hd2_i2c_priv *priv)\n{\n\twritel_relaxed(I2C_ENABLE | I2C_UNMASK_TOTAL | I2C_UNMASK_ALL,\n\t\t       priv->regs + HIX5I2C_CTRL);\n}\n\nstatic void hix5hd2_i2c_drv_setrate(struct hix5hd2_i2c_priv *priv)\n{\n\tu32 rate, val;\n\tu32 scl, sysclock;\n\n\t \n\tval = readl_relaxed(priv->regs + HIX5I2C_CTRL);\n\twritel_relaxed(val & (~I2C_UNMASK_TOTAL), priv->regs + HIX5I2C_CTRL);\n\n\trate = priv->freq;\n\tsysclock = clk_get_rate(priv->clk);\n\tscl = (sysclock / (rate * 2)) / 2 - 1;\n\twritel_relaxed(scl, priv->regs + HIX5I2C_SCL_H);\n\twritel_relaxed(scl, priv->regs + HIX5I2C_SCL_L);\n\n\t \n\twritel_relaxed(val, priv->regs + HIX5I2C_CTRL);\n\n\tdev_dbg(priv->dev, \"%s: sysclock=%d, rate=%d, scl=%d\\n\",\n\t\t__func__, sysclock, rate, scl);\n}\n\nstatic void hix5hd2_i2c_init(struct hix5hd2_i2c_priv *priv)\n{\n\thix5hd2_i2c_disable_irq(priv);\n\thix5hd2_i2c_drv_setrate(priv);\n\thix5hd2_i2c_clr_all_irq(priv);\n\thix5hd2_i2c_enable_irq(priv);\n}\n\nstatic void hix5hd2_i2c_reset(struct hix5hd2_i2c_priv *priv)\n{\n\tclk_disable_unprepare(priv->clk);\n\tmsleep(20);\n\tclk_prepare_enable(priv->clk);\n\thix5hd2_i2c_init(priv);\n}\n\nstatic int hix5hd2_i2c_wait_bus_idle(struct hix5hd2_i2c_priv *priv)\n{\n\tunsigned long stop_time;\n\tu32 int_status;\n\n\t \n\tstop_time = jiffies + msecs_to_jiffies(100);\n\tdo {\n\t\tint_status = hix5hd2_i2c_clr_pend_irq(priv);\n\t\tif (!(int_status & I2C_BUSY))\n\t\t\treturn 0;\n\n\t\tusleep_range(50, 200);\n\t} while (time_before(jiffies, stop_time));\n\n\treturn -EBUSY;\n}\n\nstatic void hix5hd2_rw_over(struct hix5hd2_i2c_priv *priv)\n{\n\tif (priv->state == HIX5I2C_STAT_SND_STOP)\n\t\tdev_dbg(priv->dev, \"%s: rw and send stop over\\n\", __func__);\n\telse\n\t\tdev_dbg(priv->dev, \"%s: have not data to send\\n\", __func__);\n\n\tpriv->state = HIX5I2C_STAT_RW_SUCCESS;\n\tpriv->err = 0;\n}\n\nstatic void hix5hd2_rw_handle_stop(struct hix5hd2_i2c_priv *priv)\n{\n\tif (priv->stop) {\n\t\tpriv->state = HIX5I2C_STAT_SND_STOP;\n\t\twritel_relaxed(I2C_STOP, priv->regs + HIX5I2C_COM);\n\t} else {\n\t\thix5hd2_rw_over(priv);\n\t}\n}\n\nstatic void hix5hd2_read_handle(struct hix5hd2_i2c_priv *priv)\n{\n\tif (priv->msg_len == 1) {\n\t\t \n\t\twritel_relaxed(I2C_READ | I2C_NO_ACK, priv->regs + HIX5I2C_COM);\n\t} else if (priv->msg_len > 1) {\n\t\t \n\t\twritel_relaxed(I2C_READ, priv->regs + HIX5I2C_COM);\n\t} else {\n\t\thix5hd2_rw_handle_stop(priv);\n\t}\n}\n\nstatic void hix5hd2_write_handle(struct hix5hd2_i2c_priv *priv)\n{\n\tu8 data;\n\n\tif (priv->msg_len > 0) {\n\t\tdata = priv->msg->buf[priv->msg_idx++];\n\t\twritel_relaxed(data, priv->regs + HIX5I2C_TXR);\n\t\twritel_relaxed(I2C_WRITE, priv->regs + HIX5I2C_COM);\n\t} else {\n\t\thix5hd2_rw_handle_stop(priv);\n\t}\n}\n\nstatic int hix5hd2_rw_preprocess(struct hix5hd2_i2c_priv *priv)\n{\n\tu8 data;\n\n\tif (priv->state == HIX5I2C_STAT_INIT) {\n\t\tpriv->state = HIX5I2C_STAT_RW;\n\t} else if (priv->state == HIX5I2C_STAT_RW) {\n\t\tif (priv->msg->flags & I2C_M_RD) {\n\t\t\tdata = readl_relaxed(priv->regs + HIX5I2C_RXR);\n\t\t\tpriv->msg->buf[priv->msg_idx++] = data;\n\t\t}\n\t\tpriv->msg_len--;\n\t} else {\n\t\tdev_dbg(priv->dev, \"%s: error: priv->state = %d, msg_len = %d\\n\",\n\t\t\t__func__, priv->state, priv->msg_len);\n\t\treturn -EAGAIN;\n\t}\n\treturn 0;\n}\n\nstatic irqreturn_t hix5hd2_i2c_irq(int irqno, void *dev_id)\n{\n\tstruct hix5hd2_i2c_priv *priv = dev_id;\n\tu32 int_status;\n\tint ret;\n\n\tspin_lock(&priv->lock);\n\n\tint_status = hix5hd2_i2c_clr_pend_irq(priv);\n\n\t \n\tif (int_status & I2C_ARBITRATE_INTR) {\n\t\t \n\t\tdev_dbg(priv->dev, \"ARB bus loss\\n\");\n\t\tpriv->err = -EAGAIN;\n\t\tpriv->state = HIX5I2C_STAT_RW_ERR;\n\t\tgoto stop;\n\t} else if (int_status & I2C_ACK_INTR) {\n\t\t \n\t\tdev_dbg(priv->dev, \"No ACK from device\\n\");\n\t\tpriv->err = -ENXIO;\n\t\tpriv->state = HIX5I2C_STAT_RW_ERR;\n\t\tgoto stop;\n\t}\n\n\tif (int_status & I2C_OVER_INTR) {\n\t\tif (priv->msg_len > 0) {\n\t\t\tret = hix5hd2_rw_preprocess(priv);\n\t\t\tif (ret) {\n\t\t\t\tpriv->err = ret;\n\t\t\t\tpriv->state = HIX5I2C_STAT_RW_ERR;\n\t\t\t\tgoto stop;\n\t\t\t}\n\t\t\tif (priv->msg->flags & I2C_M_RD)\n\t\t\t\thix5hd2_read_handle(priv);\n\t\t\telse\n\t\t\t\thix5hd2_write_handle(priv);\n\t\t} else {\n\t\t\thix5hd2_rw_over(priv);\n\t\t}\n\t}\n\nstop:\n\tif ((priv->state == HIX5I2C_STAT_RW_SUCCESS &&\n\t     priv->msg->len == priv->msg_idx) ||\n\t    (priv->state == HIX5I2C_STAT_RW_ERR)) {\n\t\thix5hd2_i2c_disable_irq(priv);\n\t\thix5hd2_i2c_clr_pend_irq(priv);\n\t\tcomplete(&priv->msg_complete);\n\t}\n\n\tspin_unlock(&priv->lock);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void hix5hd2_i2c_message_start(struct hix5hd2_i2c_priv *priv, int stop)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\thix5hd2_i2c_clr_all_irq(priv);\n\thix5hd2_i2c_enable_irq(priv);\n\n\twritel_relaxed(i2c_8bit_addr_from_msg(priv->msg),\n\t\t       priv->regs + HIX5I2C_TXR);\n\n\twritel_relaxed(I2C_WRITE | I2C_START, priv->regs + HIX5I2C_COM);\n\tspin_unlock_irqrestore(&priv->lock, flags);\n}\n\nstatic int hix5hd2_i2c_xfer_msg(struct hix5hd2_i2c_priv *priv,\n\t\t\t\tstruct i2c_msg *msgs, int stop)\n{\n\tunsigned long timeout;\n\tint ret;\n\n\tpriv->msg = msgs;\n\tpriv->msg_idx = 0;\n\tpriv->msg_len = priv->msg->len;\n\tpriv->stop = stop;\n\tpriv->err = 0;\n\tpriv->state = HIX5I2C_STAT_INIT;\n\n\treinit_completion(&priv->msg_complete);\n\thix5hd2_i2c_message_start(priv, stop);\n\n\ttimeout = wait_for_completion_timeout(&priv->msg_complete,\n\t\t\t\t\t      priv->adap.timeout);\n\tif (timeout == 0) {\n\t\tpriv->state = HIX5I2C_STAT_RW_ERR;\n\t\tpriv->err = -ETIMEDOUT;\n\t\tdev_warn(priv->dev, \"%s timeout=%d\\n\",\n\t\t\t msgs->flags & I2C_M_RD ? \"rx\" : \"tx\",\n\t\t\t priv->adap.timeout);\n\t}\n\tret = priv->state;\n\n\t \n\tif (priv->state == HIX5I2C_STAT_RW_SUCCESS && stop)\n\t\tret = hix5hd2_i2c_wait_bus_idle(priv);\n\n\tif (ret < 0)\n\t\thix5hd2_i2c_reset(priv);\n\n\treturn priv->err;\n}\n\nstatic int hix5hd2_i2c_xfer(struct i2c_adapter *adap,\n\t\t\t    struct i2c_msg *msgs, int num)\n{\n\tstruct hix5hd2_i2c_priv *priv = i2c_get_adapdata(adap);\n\tint i, ret, stop;\n\n\tpm_runtime_get_sync(priv->dev);\n\n\tfor (i = 0; i < num; i++, msgs++) {\n\t\tif ((i == num - 1) || (msgs->flags & I2C_M_STOP))\n\t\t\tstop = 1;\n\t\telse\n\t\t\tstop = 0;\n\n\t\tret = hix5hd2_i2c_xfer_msg(priv, msgs, stop);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tret = num;\n\nout:\n\tpm_runtime_mark_last_busy(priv->dev);\n\tpm_runtime_put_autosuspend(priv->dev);\n\treturn ret;\n}\n\nstatic u32 hix5hd2_i2c_func(struct i2c_adapter *adap)\n{\n\treturn I2C_FUNC_I2C | (I2C_FUNC_SMBUS_EMUL & ~I2C_FUNC_SMBUS_QUICK);\n}\n\nstatic const struct i2c_algorithm hix5hd2_i2c_algorithm = {\n\t.master_xfer\t\t= hix5hd2_i2c_xfer,\n\t.functionality\t\t= hix5hd2_i2c_func,\n};\n\nstatic int hix5hd2_i2c_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct hix5hd2_i2c_priv *priv;\n\tunsigned int freq;\n\tint irq, ret;\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tif (of_property_read_u32(np, \"clock-frequency\", &freq)) {\n\t\t \n\t\tpriv->freq = I2C_MAX_STANDARD_MODE_FREQ;\n\t} else {\n\t\tif (freq > I2C_MAX_FAST_MODE_FREQ) {\n\t\t\tpriv->freq = I2C_MAX_FAST_MODE_FREQ;\n\t\t\tdev_warn(priv->dev, \"use max freq %d instead\\n\",\n\t\t\t\t I2C_MAX_FAST_MODE_FREQ);\n\t\t} else {\n\t\t\tpriv->freq = freq;\n\t\t}\n\t}\n\n\tpriv->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(priv->regs))\n\t\treturn PTR_ERR(priv->regs);\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tpriv->clk = devm_clk_get_enabled(&pdev->dev, NULL);\n\tif (IS_ERR(priv->clk)) {\n\t\tdev_err(&pdev->dev, \"cannot enable clock\\n\");\n\t\treturn PTR_ERR(priv->clk);\n\t}\n\n\tstrscpy(priv->adap.name, \"hix5hd2-i2c\", sizeof(priv->adap.name));\n\tpriv->dev = &pdev->dev;\n\tpriv->adap.owner = THIS_MODULE;\n\tpriv->adap.algo = &hix5hd2_i2c_algorithm;\n\tpriv->adap.retries = 3;\n\tpriv->adap.dev.of_node = np;\n\tpriv->adap.algo_data = priv;\n\tpriv->adap.dev.parent = &pdev->dev;\n\ti2c_set_adapdata(&priv->adap, priv);\n\tplatform_set_drvdata(pdev, priv);\n\tspin_lock_init(&priv->lock);\n\tinit_completion(&priv->msg_complete);\n\n\thix5hd2_i2c_init(priv);\n\n\tret = devm_request_irq(&pdev->dev, irq, hix5hd2_i2c_irq,\n\t\t\t       IRQF_NO_SUSPEND, dev_name(&pdev->dev), priv);\n\tif (ret != 0) {\n\t\tdev_err(&pdev->dev, \"cannot request HS-I2C IRQ %d\\n\", irq);\n\t\treturn ret;\n\t}\n\n\tpm_runtime_set_autosuspend_delay(priv->dev, MSEC_PER_SEC);\n\tpm_runtime_use_autosuspend(priv->dev);\n\tpm_runtime_set_active(priv->dev);\n\tpm_runtime_enable(priv->dev);\n\n\tret = i2c_add_adapter(&priv->adap);\n\tif (ret < 0)\n\t\tgoto err_runtime;\n\n\treturn ret;\n\nerr_runtime:\n\tpm_runtime_disable(priv->dev);\n\tpm_runtime_set_suspended(priv->dev);\n\n\treturn ret;\n}\n\nstatic void hix5hd2_i2c_remove(struct platform_device *pdev)\n{\n\tstruct hix5hd2_i2c_priv *priv = platform_get_drvdata(pdev);\n\n\ti2c_del_adapter(&priv->adap);\n\tpm_runtime_disable(priv->dev);\n\tpm_runtime_set_suspended(priv->dev);\n}\n\nstatic int hix5hd2_i2c_runtime_suspend(struct device *dev)\n{\n\tstruct hix5hd2_i2c_priv *priv = dev_get_drvdata(dev);\n\n\tclk_disable_unprepare(priv->clk);\n\n\treturn 0;\n}\n\nstatic int hix5hd2_i2c_runtime_resume(struct device *dev)\n{\n\tstruct hix5hd2_i2c_priv *priv = dev_get_drvdata(dev);\n\n\tclk_prepare_enable(priv->clk);\n\thix5hd2_i2c_init(priv);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops hix5hd2_i2c_pm_ops = {\n\tRUNTIME_PM_OPS(hix5hd2_i2c_runtime_suspend,\n\t\t       hix5hd2_i2c_runtime_resume,\n\t\t       NULL)\n};\n\nstatic const struct of_device_id hix5hd2_i2c_match[] = {\n\t{ .compatible = \"hisilicon,hix5hd2-i2c\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, hix5hd2_i2c_match);\n\nstatic struct platform_driver hix5hd2_i2c_driver = {\n\t.probe\t\t= hix5hd2_i2c_probe,\n\t.remove_new\t= hix5hd2_i2c_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"hix5hd2-i2c\",\n\t\t.pm\t= pm_ptr(&hix5hd2_i2c_pm_ops),\n\t\t.of_match_table = hix5hd2_i2c_match,\n\t},\n};\n\nmodule_platform_driver(hix5hd2_i2c_driver);\n\nMODULE_DESCRIPTION(\"Hix5hd2 I2C Bus driver\");\nMODULE_AUTHOR(\"Wei Yan <sledge.yanwei@huawei.com>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:hix5hd2-i2c\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}