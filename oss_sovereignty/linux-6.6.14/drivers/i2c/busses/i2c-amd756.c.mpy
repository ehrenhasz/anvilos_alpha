{
  "module_name": "i2c-amd756.c",
  "hash_id": "16745b9eb83e6acfaa716ee4bc3f8a5e657c175b25cad38a87248f4b04b2153b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-amd756.c",
  "human_readable_source": "\n \n\n \n\n \n\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/delay.h>\n#include <linux/stddef.h>\n#include <linux/ioport.h>\n#include <linux/i2c.h>\n#include <linux/acpi.h>\n#include <linux/io.h>\n\n \n#define SMB_ADDR_OFFSET\t\t0xE0\n#define SMB_IOSIZE\t\t16\n#define SMB_GLOBAL_STATUS\t(0x0 + amd756_ioport)\n#define SMB_GLOBAL_ENABLE\t(0x2 + amd756_ioport)\n#define SMB_HOST_ADDRESS\t(0x4 + amd756_ioport)\n#define SMB_HOST_DATA\t\t(0x6 + amd756_ioport)\n#define SMB_HOST_COMMAND\t(0x8 + amd756_ioport)\n#define SMB_HOST_BLOCK_DATA\t(0x9 + amd756_ioport)\n#define SMB_HAS_DATA\t\t(0xA + amd756_ioport)\n#define SMB_HAS_DEVICE_ADDRESS\t(0xC + amd756_ioport)\n#define SMB_HAS_HOST_ADDRESS\t(0xE + amd756_ioport)\n#define SMB_SNOOP_ADDRESS\t(0xF + amd756_ioport)\n\n \n\n \n#define SMBBA\t\t0x058\t\t \n#define SMBBANFORCE\t0x014\n\n \n#define SMBGCFG\t\t0x041\t\t \n\n \n#define SMBREV\t\t0x008\n\n \n#define MAX_TIMEOUT\t500\n\n \n#define AMD756_QUICK\t\t0x00\n#define AMD756_BYTE\t\t0x01\n#define AMD756_BYTE_DATA\t0x02\n#define AMD756_WORD_DATA\t0x03\n#define AMD756_PROCESS_CALL\t0x04\n#define AMD756_BLOCK_DATA\t0x05\n\nstatic struct pci_driver amd756_driver;\nstatic unsigned short amd756_ioport;\n\n \n#define GS_ABRT_STS\t(1 << 0)\n#define GS_COL_STS\t(1 << 1)\n#define GS_PRERR_STS\t(1 << 2)\n#define GS_HST_STS\t(1 << 3)\n#define GS_HCYC_STS\t(1 << 4)\n#define GS_TO_STS\t(1 << 5)\n#define GS_SMB_STS\t(1 << 11)\n\n#define GS_CLEAR_STS\t(GS_ABRT_STS | GS_COL_STS | GS_PRERR_STS | \\\n\t\t\t GS_HCYC_STS | GS_TO_STS )\n\n#define GE_CYC_TYPE_MASK\t(7)\n#define GE_HOST_STC\t\t(1 << 3)\n#define GE_ABORT\t\t(1 << 5)\n\n\nstatic int amd756_transaction(struct i2c_adapter *adap)\n{\n\tint temp;\n\tint result = 0;\n\tint timeout = 0;\n\n\tdev_dbg(&adap->dev, \"Transaction (pre): GS=%04x, GE=%04x, ADD=%04x, \"\n\t\t\"DAT=%04x\\n\", inw_p(SMB_GLOBAL_STATUS),\n\t\tinw_p(SMB_GLOBAL_ENABLE), inw_p(SMB_HOST_ADDRESS),\n\t\tinb_p(SMB_HOST_DATA));\n\n\t \n\tif ((temp = inw_p(SMB_GLOBAL_STATUS)) & (GS_HST_STS | GS_SMB_STS)) {\n\t\tdev_dbg(&adap->dev, \"SMBus busy (%04x). Waiting...\\n\", temp);\n\t\tdo {\n\t\t\tmsleep(1);\n\t\t\ttemp = inw_p(SMB_GLOBAL_STATUS);\n\t\t} while ((temp & (GS_HST_STS | GS_SMB_STS)) &&\n\t\t         (timeout++ < MAX_TIMEOUT));\n\t\t \n\t\tif (timeout > MAX_TIMEOUT) {\n\t\t\tdev_dbg(&adap->dev, \"Busy wait timeout (%04x)\\n\", temp);\n\t\t\tgoto abort;\n\t\t}\n\t\ttimeout = 0;\n\t}\n\n\t \n\toutw_p(inw(SMB_GLOBAL_ENABLE) | GE_HOST_STC, SMB_GLOBAL_ENABLE);\n\n\t \n\tdo {\n\t\tmsleep(1);\n\t\ttemp = inw_p(SMB_GLOBAL_STATUS);\n\t} while ((temp & GS_HST_STS) && (timeout++ < MAX_TIMEOUT));\n\n\t \n\tif (timeout > MAX_TIMEOUT) {\n\t\tdev_dbg(&adap->dev, \"Completion timeout!\\n\");\n\t\tgoto abort;\n\t}\n\n\tif (temp & GS_PRERR_STS) {\n\t\tresult = -ENXIO;\n\t\tdev_dbg(&adap->dev, \"SMBus Protocol error (no response)!\\n\");\n\t}\n\n\tif (temp & GS_COL_STS) {\n\t\tresult = -EIO;\n\t\tdev_warn(&adap->dev, \"SMBus collision!\\n\");\n\t}\n\n\tif (temp & GS_TO_STS) {\n\t\tresult = -ETIMEDOUT;\n\t\tdev_dbg(&adap->dev, \"SMBus protocol timeout!\\n\");\n\t}\n\n\tif (temp & GS_HCYC_STS)\n\t\tdev_dbg(&adap->dev, \"SMBus protocol success!\\n\");\n\n\toutw_p(GS_CLEAR_STS, SMB_GLOBAL_STATUS);\n\n#ifdef DEBUG\n\tif (((temp = inw_p(SMB_GLOBAL_STATUS)) & GS_CLEAR_STS) != 0x00) {\n\t\tdev_dbg(&adap->dev,\n\t\t\t\"Failed reset at end of transaction (%04x)\\n\", temp);\n\t}\n#endif\n\n\tdev_dbg(&adap->dev,\n\t\t\"Transaction (post): GS=%04x, GE=%04x, ADD=%04x, DAT=%04x\\n\",\n\t\tinw_p(SMB_GLOBAL_STATUS), inw_p(SMB_GLOBAL_ENABLE),\n\t\tinw_p(SMB_HOST_ADDRESS), inb_p(SMB_HOST_DATA));\n\n\treturn result;\n\n abort:\n\tdev_warn(&adap->dev, \"Sending abort\\n\");\n\toutw_p(inw(SMB_GLOBAL_ENABLE) | GE_ABORT, SMB_GLOBAL_ENABLE);\n\tmsleep(100);\n\toutw_p(GS_CLEAR_STS, SMB_GLOBAL_STATUS);\n\treturn -EIO;\n}\n\n \nstatic s32 amd756_access(struct i2c_adapter * adap, u16 addr,\n\t\t  unsigned short flags, char read_write,\n\t\t  u8 command, int size, union i2c_smbus_data * data)\n{\n\tint i, len;\n\tint status;\n\n\tswitch (size) {\n\tcase I2C_SMBUS_QUICK:\n\t\toutw_p(((addr & 0x7f) << 1) | (read_write & 0x01),\n\t\t       SMB_HOST_ADDRESS);\n\t\tsize = AMD756_QUICK;\n\t\tbreak;\n\tcase I2C_SMBUS_BYTE:\n\t\toutw_p(((addr & 0x7f) << 1) | (read_write & 0x01),\n\t\t       SMB_HOST_ADDRESS);\n\t\tif (read_write == I2C_SMBUS_WRITE)\n\t\t\toutb_p(command, SMB_HOST_DATA);\n\t\tsize = AMD756_BYTE;\n\t\tbreak;\n\tcase I2C_SMBUS_BYTE_DATA:\n\t\toutw_p(((addr & 0x7f) << 1) | (read_write & 0x01),\n\t\t       SMB_HOST_ADDRESS);\n\t\toutb_p(command, SMB_HOST_COMMAND);\n\t\tif (read_write == I2C_SMBUS_WRITE)\n\t\t\toutw_p(data->byte, SMB_HOST_DATA);\n\t\tsize = AMD756_BYTE_DATA;\n\t\tbreak;\n\tcase I2C_SMBUS_WORD_DATA:\n\t\toutw_p(((addr & 0x7f) << 1) | (read_write & 0x01),\n\t\t       SMB_HOST_ADDRESS);\n\t\toutb_p(command, SMB_HOST_COMMAND);\n\t\tif (read_write == I2C_SMBUS_WRITE)\n\t\t\toutw_p(data->word, SMB_HOST_DATA);\t \n\t\tsize = AMD756_WORD_DATA;\n\t\tbreak;\n\tcase I2C_SMBUS_BLOCK_DATA:\n\t\toutw_p(((addr & 0x7f) << 1) | (read_write & 0x01),\n\t\t       SMB_HOST_ADDRESS);\n\t\toutb_p(command, SMB_HOST_COMMAND);\n\t\tif (read_write == I2C_SMBUS_WRITE) {\n\t\t\tlen = data->block[0];\n\t\t\tif (len < 0)\n\t\t\t\tlen = 0;\n\t\t\tif (len > 32)\n\t\t\t\tlen = 32;\n\t\t\toutw_p(len, SMB_HOST_DATA);\n\t\t\t \n\t\t\tfor (i = 1; i <= len; i++)\n\t\t\t\toutb_p(data->block[i],\n\t\t\t\t       SMB_HOST_BLOCK_DATA);\n\t\t}\n\t\tsize = AMD756_BLOCK_DATA;\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(&adap->dev, \"Unsupported transaction %d\\n\", size);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t \n\toutw_p(size & GE_CYC_TYPE_MASK, SMB_GLOBAL_ENABLE);\n\n\tstatus = amd756_transaction(adap);\n\tif (status)\n\t\treturn status;\n\n\tif ((read_write == I2C_SMBUS_WRITE) || (size == AMD756_QUICK))\n\t\treturn 0;\n\n\n\tswitch (size) {\n\tcase AMD756_BYTE:\n\t\tdata->byte = inw_p(SMB_HOST_DATA);\n\t\tbreak;\n\tcase AMD756_BYTE_DATA:\n\t\tdata->byte = inw_p(SMB_HOST_DATA);\n\t\tbreak;\n\tcase AMD756_WORD_DATA:\n\t\tdata->word = inw_p(SMB_HOST_DATA);\t \n\t\tbreak;\n\tcase AMD756_BLOCK_DATA:\n\t\tdata->block[0] = inw_p(SMB_HOST_DATA) & 0x3f;\n\t\tif(data->block[0] > 32)\n\t\t\tdata->block[0] = 32;\n\t\t \n\t\tfor (i = 1; i <= data->block[0]; i++)\n\t\t\tdata->block[i] = inb_p(SMB_HOST_BLOCK_DATA);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic u32 amd756_func(struct i2c_adapter *adapter)\n{\n\treturn I2C_FUNC_SMBUS_QUICK | I2C_FUNC_SMBUS_BYTE |\n\t    I2C_FUNC_SMBUS_BYTE_DATA | I2C_FUNC_SMBUS_WORD_DATA |\n\t    I2C_FUNC_SMBUS_BLOCK_DATA;\n}\n\nstatic const struct i2c_algorithm smbus_algorithm = {\n\t.smbus_xfer\t= amd756_access,\n\t.functionality\t= amd756_func,\n};\n\nstruct i2c_adapter amd756_smbus = {\n\t.owner\t\t= THIS_MODULE,\n\t.class          = I2C_CLASS_HWMON | I2C_CLASS_SPD,\n\t.algo\t\t= &smbus_algorithm,\n};\n\nenum chiptype { AMD756, AMD766, AMD768, NFORCE, AMD8111 };\nstatic const char* chipname[] = {\n\t\"AMD756\", \"AMD766\", \"AMD768\",\n\t\"nVidia nForce\", \"AMD8111\",\n};\n\nstatic const struct pci_device_id amd756_ids[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_VIPER_740B),\n\t  .driver_data = AMD756 },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_VIPER_7413),\n\t  .driver_data = AMD766 },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_OPUS_7443),\n\t  .driver_data = AMD768 },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_8111_SMBUS),\n\t  .driver_data = AMD8111 },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_NVIDIA, PCI_DEVICE_ID_NVIDIA_NFORCE_SMBUS),\n\t  .driver_data = NFORCE },\n\t{ 0, }\n};\n\nMODULE_DEVICE_TABLE (pci, amd756_ids);\n\nstatic int amd756_probe(struct pci_dev *pdev, const struct pci_device_id *id)\n{\n\tint nforce = (id->driver_data == NFORCE);\n\tint error;\n\tu8 temp;\n\t\n\tif (amd756_ioport) {\n\t\tdev_err(&pdev->dev, \"Only one device supported \"\n\t\t       \"(you have a strange motherboard, btw)\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (nforce) {\n\t\tif (PCI_FUNC(pdev->devfn) != 1)\n\t\t\treturn -ENODEV;\n\n\t\tpci_read_config_word(pdev, SMBBANFORCE, &amd756_ioport);\n\t\tamd756_ioport &= 0xfffc;\n\t} else {  \n\t\tif (PCI_FUNC(pdev->devfn) != 3)\n\t\t\treturn -ENODEV;\n\n\t\tpci_read_config_byte(pdev, SMBGCFG, &temp);\n\t\tif ((temp & 128) == 0) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"Error: SMBus controller I/O not enabled!\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\t \n\t\t \n\t\tpci_read_config_word(pdev, SMBBA, &amd756_ioport);\n\t\tamd756_ioport &= 0xff00;\n\t\tamd756_ioport += SMB_ADDR_OFFSET;\n\t}\n\n\terror = acpi_check_region(amd756_ioport, SMB_IOSIZE,\n\t\t\t\t  amd756_driver.name);\n\tif (error)\n\t\treturn -ENODEV;\n\n\tif (!request_region(amd756_ioport, SMB_IOSIZE, amd756_driver.name)) {\n\t\tdev_err(&pdev->dev, \"SMB region 0x%x already in use!\\n\",\n\t\t\tamd756_ioport);\n\t\treturn -ENODEV;\n\t}\n\n\tpci_read_config_byte(pdev, SMBREV, &temp);\n\tdev_dbg(&pdev->dev, \"SMBREV = 0x%X\\n\", temp);\n\tdev_dbg(&pdev->dev, \"AMD756_smba = 0x%X\\n\", amd756_ioport);\n\n\t \n\tamd756_smbus.dev.parent = &pdev->dev;\n\n\tsnprintf(amd756_smbus.name, sizeof(amd756_smbus.name),\n\t\t \"SMBus %s adapter at %04x\", chipname[id->driver_data],\n\t\t amd756_ioport);\n\n\terror = i2c_add_adapter(&amd756_smbus);\n\tif (error)\n\t\tgoto out_err;\n\n\treturn 0;\n\n out_err:\n\trelease_region(amd756_ioport, SMB_IOSIZE);\n\treturn error;\n}\n\nstatic void amd756_remove(struct pci_dev *dev)\n{\n\ti2c_del_adapter(&amd756_smbus);\n\trelease_region(amd756_ioport, SMB_IOSIZE);\n}\n\nstatic struct pci_driver amd756_driver = {\n\t.name\t\t= \"amd756_smbus\",\n\t.id_table\t= amd756_ids,\n\t.probe\t\t= amd756_probe,\n\t.remove\t\t= amd756_remove,\n};\n\nmodule_pci_driver(amd756_driver);\n\nMODULE_AUTHOR(\"Merlin Hughes <merlin@merlin.org>\");\nMODULE_DESCRIPTION(\"AMD756/766/768/8111 and nVidia nForce SMBus driver\");\nMODULE_LICENSE(\"GPL\");\n\nEXPORT_SYMBOL(amd756_smbus);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}