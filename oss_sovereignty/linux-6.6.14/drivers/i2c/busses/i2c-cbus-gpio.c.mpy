{
  "module_name": "i2c-cbus-gpio.c",
  "hash_id": "d5c28b96e80e12ec0a0811ab8e3edde91d707c32cd2f023cd2e50cadf9ddc40f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-cbus-gpio.c",
  "human_readable_source": " \n\n#include <linux/io.h>\n#include <linux/i2c.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/gpio/consumer.h>\n#include <linux/interrupt.h>\n#include <linux/platform_device.h>\n\n \n#define CBUS_ADDR_BITS\t3\n#define CBUS_REG_BITS\t5\n\nstruct cbus_host {\n\tspinlock_t\tlock;\t\t \n\tstruct device\t*dev;\n\tstruct gpio_desc *clk;\n\tstruct gpio_desc *dat;\n\tstruct gpio_desc *sel;\n};\n\n \nstatic void cbus_send_bit(struct cbus_host *host, unsigned bit)\n{\n\tgpiod_set_value(host->dat, bit ? 1 : 0);\n\tgpiod_set_value(host->clk, 1);\n\tgpiod_set_value(host->clk, 0);\n}\n\n \nstatic void cbus_send_data(struct cbus_host *host, unsigned data, unsigned len)\n{\n\tint i;\n\n\tfor (i = len; i > 0; i--)\n\t\tcbus_send_bit(host, data & (1 << (i - 1)));\n}\n\n \nstatic int cbus_receive_bit(struct cbus_host *host)\n{\n\tint ret;\n\n\tgpiod_set_value(host->clk, 1);\n\tret = gpiod_get_value(host->dat);\n\tgpiod_set_value(host->clk, 0);\n\treturn ret;\n}\n\n \nstatic int cbus_receive_word(struct cbus_host *host)\n{\n\tint ret = 0;\n\tint i;\n\n\tfor (i = 16; i > 0; i--) {\n\t\tint bit = cbus_receive_bit(host);\n\n\t\tif (bit < 0)\n\t\t\treturn bit;\n\n\t\tif (bit)\n\t\t\tret |= 1 << (i - 1);\n\t}\n\treturn ret;\n}\n\n \nstatic int cbus_transfer(struct cbus_host *host, char rw, unsigned dev,\n\t\t\t unsigned reg, unsigned data)\n{\n\tunsigned long flags;\n\tint ret;\n\n\t \n\tspin_lock_irqsave(&host->lock, flags);\n\n\t \n\tgpiod_set_value(host->sel, 0);\n\n\t \n\tgpiod_direction_output(host->dat, 1);\n\n\t \n\tcbus_send_data(host, dev, CBUS_ADDR_BITS);\n\n\t \n\tcbus_send_bit(host, rw == I2C_SMBUS_READ);\n\n\t \n\tcbus_send_data(host, reg, CBUS_REG_BITS);\n\n\tif (rw == I2C_SMBUS_WRITE) {\n\t\tcbus_send_data(host, data, 16);\n\t\tret = 0;\n\t} else {\n\t\tret = gpiod_direction_input(host->dat);\n\t\tif (ret) {\n\t\t\tdev_dbg(host->dev, \"failed setting direction\\n\");\n\t\t\tgoto out;\n\t\t}\n\t\tgpiod_set_value(host->clk, 1);\n\n\t\tret = cbus_receive_word(host);\n\t\tif (ret < 0) {\n\t\t\tdev_dbg(host->dev, \"failed receiving data\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tgpiod_set_value(host->sel, 1);\n\tgpiod_set_value(host->clk, 1);\n\tgpiod_set_value(host->clk, 0);\n\nout:\n\tspin_unlock_irqrestore(&host->lock, flags);\n\n\treturn ret;\n}\n\nstatic int cbus_i2c_smbus_xfer(struct i2c_adapter\t*adapter,\n\t\t\t       u16\t\t\taddr,\n\t\t\t       unsigned short\t\tflags,\n\t\t\t       char\t\t\tread_write,\n\t\t\t       u8\t\t\tcommand,\n\t\t\t       int\t\t\tsize,\n\t\t\t       union i2c_smbus_data\t*data)\n{\n\tstruct cbus_host *chost = i2c_get_adapdata(adapter);\n\tint ret;\n\n\tif (size != I2C_SMBUS_WORD_DATA)\n\t\treturn -EINVAL;\n\n\tret = cbus_transfer(chost, read_write == I2C_SMBUS_READ, addr,\n\t\t\t    command, data->word);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (read_write == I2C_SMBUS_READ)\n\t\tdata->word = ret;\n\n\treturn 0;\n}\n\nstatic u32 cbus_i2c_func(struct i2c_adapter *adapter)\n{\n\treturn I2C_FUNC_SMBUS_READ_WORD_DATA | I2C_FUNC_SMBUS_WRITE_WORD_DATA;\n}\n\nstatic const struct i2c_algorithm cbus_i2c_algo = {\n\t.smbus_xfer\t\t= cbus_i2c_smbus_xfer,\n\t.smbus_xfer_atomic\t= cbus_i2c_smbus_xfer,\n\t.functionality\t\t= cbus_i2c_func,\n};\n\nstatic void cbus_i2c_remove(struct platform_device *pdev)\n{\n\tstruct i2c_adapter *adapter = platform_get_drvdata(pdev);\n\n\ti2c_del_adapter(adapter);\n}\n\nstatic int cbus_i2c_probe(struct platform_device *pdev)\n{\n\tstruct i2c_adapter *adapter;\n\tstruct cbus_host *chost;\n\n\tadapter = devm_kzalloc(&pdev->dev, sizeof(struct i2c_adapter),\n\t\t\t       GFP_KERNEL);\n\tif (!adapter)\n\t\treturn -ENOMEM;\n\n\tchost = devm_kzalloc(&pdev->dev, sizeof(*chost), GFP_KERNEL);\n\tif (!chost)\n\t\treturn -ENOMEM;\n\n\tif (gpiod_count(&pdev->dev, NULL) != 3)\n\t\treturn -ENODEV;\n\tchost->clk = devm_gpiod_get_index(&pdev->dev, NULL, 0, GPIOD_OUT_LOW);\n\tif (IS_ERR(chost->clk))\n\t\treturn PTR_ERR(chost->clk);\n\tchost->dat = devm_gpiod_get_index(&pdev->dev, NULL, 1, GPIOD_IN);\n\tif (IS_ERR(chost->dat))\n\t\treturn PTR_ERR(chost->dat);\n\tchost->sel = devm_gpiod_get_index(&pdev->dev, NULL, 2, GPIOD_OUT_HIGH);\n\tif (IS_ERR(chost->sel))\n\t\treturn PTR_ERR(chost->sel);\n\tgpiod_set_consumer_name(chost->clk, \"CBUS clk\");\n\tgpiod_set_consumer_name(chost->dat, \"CBUS dat\");\n\tgpiod_set_consumer_name(chost->sel, \"CBUS sel\");\n\n\tadapter->owner\t\t= THIS_MODULE;\n\tadapter->class\t\t= I2C_CLASS_HWMON;\n\tadapter->dev.parent\t= &pdev->dev;\n\tadapter->dev.of_node\t= pdev->dev.of_node;\n\tadapter->nr\t\t= pdev->id;\n\tadapter->timeout\t= HZ;\n\tadapter->algo\t\t= &cbus_i2c_algo;\n\tstrscpy(adapter->name, \"CBUS I2C adapter\", sizeof(adapter->name));\n\n\tspin_lock_init(&chost->lock);\n\tchost->dev = &pdev->dev;\n\n\ti2c_set_adapdata(adapter, chost);\n\tplatform_set_drvdata(pdev, adapter);\n\n\treturn i2c_add_numbered_adapter(adapter);\n}\n\n#if defined(CONFIG_OF)\nstatic const struct of_device_id i2c_cbus_dt_ids[] = {\n\t{ .compatible = \"i2c-cbus-gpio\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, i2c_cbus_dt_ids);\n#endif\n\nstatic struct platform_driver cbus_i2c_driver = {\n\t.probe\t= cbus_i2c_probe,\n\t.remove_new = cbus_i2c_remove,\n\t.driver\t= {\n\t\t.name\t= \"i2c-cbus-gpio\",\n\t\t.of_match_table = of_match_ptr(i2c_cbus_dt_ids),\n\t},\n};\nmodule_platform_driver(cbus_i2c_driver);\n\nMODULE_ALIAS(\"platform:i2c-cbus-gpio\");\nMODULE_DESCRIPTION(\"CBUS I2C driver\");\nMODULE_AUTHOR(\"Juha Yrj\u00f6l\u00e4\");\nMODULE_AUTHOR(\"David Weinehall\");\nMODULE_AUTHOR(\"Mikko Ylinen\");\nMODULE_AUTHOR(\"Felipe Balbi\");\nMODULE_AUTHOR(\"Aaro Koskinen <aaro.koskinen@iki.fi>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}