{
  "module_name": "i2c-scmi.c",
  "hash_id": "968dd5e9edc32b0acde6f44c696cd4919e1af2adee7bc7553c525d0dc965ecf3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-scmi.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/i2c.h>\n#include <linux/acpi.h>\n\nstruct smbus_methods_t {\n\tchar *mt_info;\n\tchar *mt_sbr;\n\tchar *mt_sbw;\n};\n\nstruct acpi_smbus_cmi {\n\tacpi_handle handle;\n\tstruct i2c_adapter adapter;\n\tu8 cap_info:1;\n\tu8 cap_read:1;\n\tu8 cap_write:1;\n\tconst struct smbus_methods_t *methods;\n};\n\nstatic const struct smbus_methods_t smbus_methods = {\n\t.mt_info = \"_SBI\",\n\t.mt_sbr  = \"_SBR\",\n\t.mt_sbw  = \"_SBW\",\n};\n\n \nstatic const struct smbus_methods_t ibm_smbus_methods = {\n\t.mt_info = \"SBI_\",\n\t.mt_sbr  = \"SBR_\",\n\t.mt_sbw  = \"SBW_\",\n};\n\nstatic const struct acpi_device_id acpi_smbus_cmi_ids[] = {\n\t{\"SMBUS01\", (kernel_ulong_t)&smbus_methods},\n\t{ACPI_SMBUS_IBM_HID, (kernel_ulong_t)&ibm_smbus_methods},\n\t{ACPI_SMBUS_MS_HID, (kernel_ulong_t)&smbus_methods},\n\t{\"\", 0}\n};\nMODULE_DEVICE_TABLE(acpi, acpi_smbus_cmi_ids);\n\n#define ACPI_SMBUS_STATUS_OK\t\t\t0x00\n#define ACPI_SMBUS_STATUS_FAIL\t\t\t0x07\n#define ACPI_SMBUS_STATUS_DNAK\t\t\t0x10\n#define ACPI_SMBUS_STATUS_DERR\t\t\t0x11\n#define ACPI_SMBUS_STATUS_CMD_DENY\t\t0x12\n#define ACPI_SMBUS_STATUS_UNKNOWN\t\t0x13\n#define ACPI_SMBUS_STATUS_ACC_DENY\t\t0x17\n#define ACPI_SMBUS_STATUS_TIMEOUT\t\t0x18\n#define ACPI_SMBUS_STATUS_NOTSUP\t\t0x19\n#define ACPI_SMBUS_STATUS_BUSY\t\t\t0x1a\n#define ACPI_SMBUS_STATUS_PEC\t\t\t0x1f\n\n#define ACPI_SMBUS_PRTCL_WRITE\t\t\t0x00\n#define ACPI_SMBUS_PRTCL_READ\t\t\t0x01\n#define ACPI_SMBUS_PRTCL_QUICK\t\t\t0x02\n#define ACPI_SMBUS_PRTCL_BYTE\t\t\t0x04\n#define ACPI_SMBUS_PRTCL_BYTE_DATA\t\t0x06\n#define ACPI_SMBUS_PRTCL_WORD_DATA\t\t0x08\n#define ACPI_SMBUS_PRTCL_BLOCK_DATA\t\t0x0a\n\n\nstatic int\nacpi_smbus_cmi_access(struct i2c_adapter *adap, u16 addr, unsigned short flags,\n\t\t   char read_write, u8 command, int size,\n\t\t   union i2c_smbus_data *data)\n{\n\tint result = 0;\n\tstruct acpi_smbus_cmi *smbus_cmi = adap->algo_data;\n\tunsigned char protocol;\n\tacpi_status status = 0;\n\tstruct acpi_object_list input;\n\tunion acpi_object mt_params[5];\n\tstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };\n\tunion acpi_object *obj;\n\tunion acpi_object *pkg;\n\tchar *method;\n\tint len = 0;\n\n\tdev_dbg(&adap->dev, \"access size: %d %s\\n\", size,\n\t\t(read_write) ? \"READ\" : \"WRITE\");\n\tswitch (size) {\n\tcase I2C_SMBUS_QUICK:\n\t\tprotocol = ACPI_SMBUS_PRTCL_QUICK;\n\t\tcommand = 0;\n\t\tif (read_write == I2C_SMBUS_WRITE) {\n\t\t\tmt_params[3].type = ACPI_TYPE_INTEGER;\n\t\t\tmt_params[3].integer.value = 0;\n\t\t\tmt_params[4].type = ACPI_TYPE_INTEGER;\n\t\t\tmt_params[4].integer.value = 0;\n\t\t}\n\t\tbreak;\n\n\tcase I2C_SMBUS_BYTE:\n\t\tprotocol = ACPI_SMBUS_PRTCL_BYTE;\n\t\tif (read_write == I2C_SMBUS_WRITE) {\n\t\t\tmt_params[3].type = ACPI_TYPE_INTEGER;\n\t\t\tmt_params[3].integer.value = 0;\n\t\t\tmt_params[4].type = ACPI_TYPE_INTEGER;\n\t\t\tmt_params[4].integer.value = 0;\n\t\t} else {\n\t\t\tcommand = 0;\n\t\t}\n\t\tbreak;\n\n\tcase I2C_SMBUS_BYTE_DATA:\n\t\tprotocol = ACPI_SMBUS_PRTCL_BYTE_DATA;\n\t\tif (read_write == I2C_SMBUS_WRITE) {\n\t\t\tmt_params[3].type = ACPI_TYPE_INTEGER;\n\t\t\tmt_params[3].integer.value = 1;\n\t\t\tmt_params[4].type = ACPI_TYPE_INTEGER;\n\t\t\tmt_params[4].integer.value = data->byte;\n\t\t}\n\t\tbreak;\n\n\tcase I2C_SMBUS_WORD_DATA:\n\t\tprotocol = ACPI_SMBUS_PRTCL_WORD_DATA;\n\t\tif (read_write == I2C_SMBUS_WRITE) {\n\t\t\tmt_params[3].type = ACPI_TYPE_INTEGER;\n\t\t\tmt_params[3].integer.value = 2;\n\t\t\tmt_params[4].type = ACPI_TYPE_INTEGER;\n\t\t\tmt_params[4].integer.value = data->word;\n\t\t}\n\t\tbreak;\n\n\tcase I2C_SMBUS_BLOCK_DATA:\n\t\tprotocol = ACPI_SMBUS_PRTCL_BLOCK_DATA;\n\t\tif (read_write == I2C_SMBUS_WRITE) {\n\t\t\tlen = data->block[0];\n\t\t\tif (len == 0 || len > I2C_SMBUS_BLOCK_MAX)\n\t\t\t\treturn -EINVAL;\n\t\t\tmt_params[3].type = ACPI_TYPE_INTEGER;\n\t\t\tmt_params[3].integer.value = len;\n\t\t\tmt_params[4].type = ACPI_TYPE_BUFFER;\n\t\t\tmt_params[4].buffer.length = len;\n\t\t\tmt_params[4].buffer.pointer = data->block + 1;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tdev_warn(&adap->dev, \"Unsupported transaction %d\\n\", size);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (read_write == I2C_SMBUS_READ) {\n\t\tprotocol |= ACPI_SMBUS_PRTCL_READ;\n\t\tmethod = smbus_cmi->methods->mt_sbr;\n\t\tinput.count = 3;\n\t} else {\n\t\tprotocol |= ACPI_SMBUS_PRTCL_WRITE;\n\t\tmethod = smbus_cmi->methods->mt_sbw;\n\t\tinput.count = 5;\n\t}\n\n\tinput.pointer = mt_params;\n\tmt_params[0].type = ACPI_TYPE_INTEGER;\n\tmt_params[0].integer.value = protocol;\n\tmt_params[1].type = ACPI_TYPE_INTEGER;\n\tmt_params[1].integer.value = addr;\n\tmt_params[2].type = ACPI_TYPE_INTEGER;\n\tmt_params[2].integer.value = command;\n\n\tstatus = acpi_evaluate_object(smbus_cmi->handle, method, &input,\n\t\t\t\t      &buffer);\n\tif (ACPI_FAILURE(status)) {\n\t\tacpi_handle_err(smbus_cmi->handle,\n\t\t\t\t\"Failed to evaluate %s: %i\\n\", method, status);\n\t\treturn -EIO;\n\t}\n\n\tpkg = buffer.pointer;\n\tif (pkg && pkg->type == ACPI_TYPE_PACKAGE)\n\t\tobj = pkg->package.elements;\n\telse {\n\t\tacpi_handle_err(smbus_cmi->handle, \"Invalid argument type\\n\");\n\t\tresult = -EIO;\n\t\tgoto out;\n\t}\n\tif (obj == NULL || obj->type != ACPI_TYPE_INTEGER) {\n\t\tacpi_handle_err(smbus_cmi->handle, \"Invalid argument type\\n\");\n\t\tresult = -EIO;\n\t\tgoto out;\n\t}\n\n\tresult = obj->integer.value;\n\tacpi_handle_debug(smbus_cmi->handle,  \"%s return status: %i\\n\", method,\n\t\t\t  result);\n\n\tswitch (result) {\n\tcase ACPI_SMBUS_STATUS_OK:\n\t\tresult = 0;\n\t\tbreak;\n\tcase ACPI_SMBUS_STATUS_BUSY:\n\t\tresult = -EBUSY;\n\t\tgoto out;\n\tcase ACPI_SMBUS_STATUS_TIMEOUT:\n\t\tresult = -ETIMEDOUT;\n\t\tgoto out;\n\tcase ACPI_SMBUS_STATUS_DNAK:\n\t\tresult = -ENXIO;\n\t\tgoto out;\n\tdefault:\n\t\tresult = -EIO;\n\t\tgoto out;\n\t}\n\n\tif (read_write == I2C_SMBUS_WRITE || size == I2C_SMBUS_QUICK)\n\t\tgoto out;\n\n\tobj = pkg->package.elements + 1;\n\tif (obj->type != ACPI_TYPE_INTEGER) {\n\t\tacpi_handle_err(smbus_cmi->handle, \"Invalid argument type\\n\");\n\t\tresult = -EIO;\n\t\tgoto out;\n\t}\n\n\tlen = obj->integer.value;\n\tobj = pkg->package.elements + 2;\n\tswitch (size) {\n\tcase I2C_SMBUS_BYTE:\n\tcase I2C_SMBUS_BYTE_DATA:\n\tcase I2C_SMBUS_WORD_DATA:\n\t\tif (obj->type != ACPI_TYPE_INTEGER) {\n\t\t\tacpi_handle_err(smbus_cmi->handle,\n\t\t\t\t\t\"Invalid argument type\\n\");\n\t\t\tresult = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tif (len == 2)\n\t\t\tdata->word = obj->integer.value;\n\t\telse\n\t\t\tdata->byte = obj->integer.value;\n\t\tbreak;\n\tcase I2C_SMBUS_BLOCK_DATA:\n\t\tif (obj->type != ACPI_TYPE_BUFFER) {\n\t\t\tacpi_handle_err(smbus_cmi->handle,\n\t\t\t\t\t\"Invalid argument type\\n\");\n\t\t\tresult = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tif (len == 0 || len > I2C_SMBUS_BLOCK_MAX)\n\t\t\treturn -EPROTO;\n\t\tdata->block[0] = len;\n\t\tmemcpy(data->block + 1, obj->buffer.pointer, len);\n\t\tbreak;\n\t}\n\nout:\n\tkfree(buffer.pointer);\n\tdev_dbg(&adap->dev, \"Transaction status: %i\\n\", result);\n\treturn result;\n}\n\nstatic u32 acpi_smbus_cmi_func(struct i2c_adapter *adapter)\n{\n\tstruct acpi_smbus_cmi *smbus_cmi = adapter->algo_data;\n\tu32 ret;\n\n\tret = smbus_cmi->cap_read | smbus_cmi->cap_write ?\n\t\tI2C_FUNC_SMBUS_QUICK : 0;\n\n\tret |= smbus_cmi->cap_read ?\n\t\t(I2C_FUNC_SMBUS_READ_BYTE |\n\t\tI2C_FUNC_SMBUS_READ_BYTE_DATA |\n\t\tI2C_FUNC_SMBUS_READ_WORD_DATA |\n\t\tI2C_FUNC_SMBUS_READ_BLOCK_DATA) : 0;\n\n\tret |= smbus_cmi->cap_write ?\n\t\t(I2C_FUNC_SMBUS_WRITE_BYTE |\n\t\tI2C_FUNC_SMBUS_WRITE_BYTE_DATA |\n\t\tI2C_FUNC_SMBUS_WRITE_WORD_DATA |\n\t\tI2C_FUNC_SMBUS_WRITE_BLOCK_DATA) : 0;\n\n\treturn ret;\n}\n\nstatic const struct i2c_algorithm acpi_smbus_cmi_algorithm = {\n\t.smbus_xfer = acpi_smbus_cmi_access,\n\t.functionality = acpi_smbus_cmi_func,\n};\n\n\nstatic int acpi_smbus_cmi_add_cap(struct acpi_smbus_cmi *smbus_cmi,\n\t\t\t\t  const char *name)\n{\n\tstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };\n\tstruct acpi_handle *handle = smbus_cmi->handle;\n\tunion acpi_object *obj;\n\tacpi_status status;\n\n\tif (!strcmp(name, smbus_cmi->methods->mt_info)) {\n\t\tstatus = acpi_evaluate_object(smbus_cmi->handle,\n\t\t\t\t\tsmbus_cmi->methods->mt_info,\n\t\t\t\t\tNULL, &buffer);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tacpi_handle_err(handle, \"Failed to evaluate %s: %i\\n\",\n\t\t\t\t\tsmbus_cmi->methods->mt_info, status);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tobj = buffer.pointer;\n\t\tif (obj && obj->type == ACPI_TYPE_PACKAGE)\n\t\t\tobj = obj->package.elements;\n\t\telse {\n\t\t\tacpi_handle_err(handle, \"Invalid argument type\\n\");\n\t\t\tkfree(buffer.pointer);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tif (obj->type != ACPI_TYPE_INTEGER) {\n\t\t\tacpi_handle_err(handle, \"Invalid argument type\\n\");\n\t\t\tkfree(buffer.pointer);\n\t\t\treturn -EIO;\n\t\t} else\n\t\t\tacpi_handle_debug(handle, \"SMBus CMI Version %x\\n\",\n\t\t\t\t\t  (int)obj->integer.value);\n\n\t\tkfree(buffer.pointer);\n\t\tsmbus_cmi->cap_info = 1;\n\t} else if (!strcmp(name, smbus_cmi->methods->mt_sbr))\n\t\tsmbus_cmi->cap_read = 1;\n\telse if (!strcmp(name, smbus_cmi->methods->mt_sbw))\n\t\tsmbus_cmi->cap_write = 1;\n\telse\n\t\tacpi_handle_debug(handle, \"Unsupported CMI method: %s\\n\", name);\n\n\treturn 0;\n}\n\nstatic acpi_status acpi_smbus_cmi_query_methods(acpi_handle handle, u32 level,\n\t\t\tvoid *context, void **return_value)\n{\n\tchar node_name[5];\n\tstruct acpi_buffer buffer = { sizeof(node_name), node_name };\n\tstruct acpi_smbus_cmi *smbus_cmi = context;\n\tacpi_status status;\n\n\tstatus = acpi_get_name(handle, ACPI_SINGLE_NAME, &buffer);\n\n\tif (ACPI_SUCCESS(status))\n\t\tacpi_smbus_cmi_add_cap(smbus_cmi, node_name);\n\n\treturn AE_OK;\n}\n\nstatic int smbus_cmi_probe(struct platform_device *device)\n{\n\tstruct device *dev = &device->dev;\n\tstruct acpi_smbus_cmi *smbus_cmi;\n\tint ret;\n\n\tsmbus_cmi = kzalloc(sizeof(struct acpi_smbus_cmi), GFP_KERNEL);\n\tif (!smbus_cmi)\n\t\treturn -ENOMEM;\n\n\tsmbus_cmi->handle = ACPI_HANDLE(dev);\n\tsmbus_cmi->methods = device_get_match_data(dev);\n\n\tplatform_set_drvdata(device, smbus_cmi);\n\n\tsmbus_cmi->cap_info = 0;\n\tsmbus_cmi->cap_read = 0;\n\tsmbus_cmi->cap_write = 0;\n\n\tacpi_walk_namespace(ACPI_TYPE_METHOD, smbus_cmi->handle, 1,\n\t\t\t    acpi_smbus_cmi_query_methods, NULL, smbus_cmi, NULL);\n\n\tif (smbus_cmi->cap_info == 0) {\n\t\tret = -ENODEV;\n\t\tgoto err;\n\t}\n\n\tsnprintf(smbus_cmi->adapter.name, sizeof(smbus_cmi->adapter.name),\n\t\t \"SMBus CMI adapter %s\", dev_name(dev));\n\tsmbus_cmi->adapter.owner = THIS_MODULE;\n\tsmbus_cmi->adapter.algo = &acpi_smbus_cmi_algorithm;\n\tsmbus_cmi->adapter.algo_data = smbus_cmi;\n\tsmbus_cmi->adapter.class = I2C_CLASS_HWMON | I2C_CLASS_SPD;\n\tsmbus_cmi->adapter.dev.parent = &device->dev;\n\n\tret = i2c_add_adapter(&smbus_cmi->adapter);\n\tif (ret) {\n\t\tdev_err(&device->dev, \"Couldn't register adapter!\\n\");\n\t\tgoto err;\n\t}\n\n\treturn 0;\n\nerr:\n\tkfree(smbus_cmi);\n\treturn ret;\n}\n\nstatic void smbus_cmi_remove(struct platform_device *device)\n{\n\tstruct acpi_smbus_cmi *smbus_cmi = platform_get_drvdata(device);\n\n\ti2c_del_adapter(&smbus_cmi->adapter);\n\tkfree(smbus_cmi);\n}\n\nstatic struct platform_driver smbus_cmi_driver = {\n\t.probe = smbus_cmi_probe,\n\t.remove_new = smbus_cmi_remove,\n\t.driver = {\n\t\t.name   = \"smbus_cmi\",\n\t\t.acpi_match_table = acpi_smbus_cmi_ids,\n\t},\n};\nmodule_platform_driver(smbus_cmi_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Crane Cai <crane.cai@amd.com>\");\nMODULE_DESCRIPTION(\"ACPI SMBus CMI driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}