{
  "module_name": "i2c-qup.c",
  "hash_id": "d402d47ab261202df237c868ee324b25b9bb5f5c5ba5fe8d40dc1f644c3b9596",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-qup.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/atomic.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/dmaengine.h>\n#include <linux/dmapool.h>\n#include <linux/dma-mapping.h>\n#include <linux/err.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/scatterlist.h>\n\n \n#define QUP_CONFIG\t\t0x000\n#define QUP_STATE\t\t0x004\n#define QUP_IO_MODE\t\t0x008\n#define QUP_SW_RESET\t\t0x00c\n#define QUP_OPERATIONAL\t\t0x018\n#define QUP_ERROR_FLAGS\t\t0x01c\n#define QUP_ERROR_FLAGS_EN\t0x020\n#define QUP_OPERATIONAL_MASK\t0x028\n#define QUP_HW_VERSION\t\t0x030\n#define QUP_MX_OUTPUT_CNT\t0x100\n#define QUP_OUT_FIFO_BASE\t0x110\n#define QUP_MX_WRITE_CNT\t0x150\n#define QUP_MX_INPUT_CNT\t0x200\n#define QUP_MX_READ_CNT\t\t0x208\n#define QUP_IN_FIFO_BASE\t0x218\n#define QUP_I2C_CLK_CTL\t\t0x400\n#define QUP_I2C_STATUS\t\t0x404\n#define QUP_I2C_MASTER_GEN\t0x408\n\n \n#define QUP_RESET_STATE\t\t0\n#define QUP_RUN_STATE\t\t1\n#define QUP_PAUSE_STATE\t\t3\n#define QUP_STATE_MASK\t\t3\n\n#define QUP_STATE_VALID\t\tBIT(2)\n#define QUP_I2C_MAST_GEN\tBIT(4)\n#define QUP_I2C_FLUSH\t\tBIT(6)\n\n#define QUP_OPERATIONAL_RESET\t0x000ff0\n#define QUP_I2C_STATUS_RESET\t0xfffffc\n\n \n#define QUP_I2C_NACK_FLAG\tBIT(3)\n#define QUP_OUT_NOT_EMPTY\tBIT(4)\n#define QUP_IN_NOT_EMPTY\tBIT(5)\n#define QUP_OUT_FULL\t\tBIT(6)\n#define QUP_OUT_SVC_FLAG\tBIT(8)\n#define QUP_IN_SVC_FLAG\t\tBIT(9)\n#define QUP_MX_OUTPUT_DONE\tBIT(10)\n#define QUP_MX_INPUT_DONE\tBIT(11)\n#define OUT_BLOCK_WRITE_REQ\tBIT(12)\n#define IN_BLOCK_READ_REQ\tBIT(13)\n\n \n#define QUP_NO_INPUT\t\tBIT(7)\n#define QUP_CLOCK_AUTO_GATE\tBIT(13)\n#define I2C_MINI_CORE\t\t(2 << 8)\n#define I2C_N_VAL\t\t15\n#define I2C_N_VAL_V2\t\t7\n\n \n#define QUP_MSW_SHIFT\t\t(I2C_N_VAL + 1)\n\n \n#define QUP_OUTPUT_BLK_MODE\t(1 << 10)\n#define QUP_OUTPUT_BAM_MODE\t(3 << 10)\n#define QUP_INPUT_BLK_MODE\t(1 << 12)\n#define QUP_INPUT_BAM_MODE\t(3 << 12)\n#define QUP_BAM_MODE\t\t(QUP_OUTPUT_BAM_MODE | QUP_INPUT_BAM_MODE)\n#define QUP_UNPACK_EN\t\tBIT(14)\n#define QUP_PACK_EN\t\tBIT(15)\n\n#define QUP_REPACK_EN\t\t(QUP_UNPACK_EN | QUP_PACK_EN)\n#define QUP_V2_TAGS_EN\t\t1\n\n#define QUP_OUTPUT_BLOCK_SIZE(x)(((x) >> 0) & 0x03)\n#define QUP_OUTPUT_FIFO_SIZE(x)\t(((x) >> 2) & 0x07)\n#define QUP_INPUT_BLOCK_SIZE(x)\t(((x) >> 5) & 0x03)\n#define QUP_INPUT_FIFO_SIZE(x)\t(((x) >> 7) & 0x07)\n\n \n#define QUP_TAG_START\t\t(1 << 8)\n#define QUP_TAG_DATA\t\t(2 << 8)\n#define QUP_TAG_STOP\t\t(3 << 8)\n#define QUP_TAG_REC\t\t(4 << 8)\n#define QUP_BAM_INPUT_EOT\t\t0x93\n#define QUP_BAM_FLUSH_STOP\t\t0x96\n\n \n#define QUP_TAG_V2_START               0x81\n#define QUP_TAG_V2_DATAWR              0x82\n#define QUP_TAG_V2_DATAWR_STOP         0x83\n#define QUP_TAG_V2_DATARD              0x85\n#define QUP_TAG_V2_DATARD_NACK         0x86\n#define QUP_TAG_V2_DATARD_STOP         0x87\n\n \n#define I2C_STATUS_WR_BUFFER_FULL\tBIT(0)\n#define I2C_STATUS_BUS_ACTIVE\t\tBIT(8)\n#define I2C_STATUS_ERROR_MASK\t\t0x38000fc\n#define QUP_STATUS_ERROR_FLAGS\t\t0x7c\n\n#define QUP_READ_LIMIT\t\t\t256\n#define SET_BIT\t\t\t\t0x1\n#define RESET_BIT\t\t\t0x0\n#define ONE_BYTE\t\t\t0x1\n#define QUP_I2C_MX_CONFIG_DURING_RUN   BIT(31)\n\n \n#define MX_TX_RX_LEN\t\t\tSZ_64K\n#define MX_BLOCKS\t\t\t(MX_TX_RX_LEN / QUP_READ_LIMIT)\n \n#define MX_DMA_TX_RX_LEN\t\t(2 * MX_TX_RX_LEN)\n#define MX_DMA_BLOCKS\t\t\t(MX_DMA_TX_RX_LEN / QUP_READ_LIMIT)\n\n \n#define TOUT_MIN\t\t\t2\n\n \n#define DEFAULT_CLK_FREQ I2C_MAX_STANDARD_MODE_FREQ\n#define DEFAULT_SRC_CLK 20000000\n\n \n#define QUP_MAX_TAGS_LEN\t\t4\n \n#define RECV_MAX_DATA_LEN\t\t254\n \n#define READ_RX_TAGS_LEN\t\t2\n\nstatic unsigned int scl_freq;\nmodule_param_named(scl_freq, scl_freq, uint, 0444);\nMODULE_PARM_DESC(scl_freq, \"SCL frequency override\");\n\n \nstruct qup_i2c_block {\n\tint\t\tcount;\n\tint\t\tpos;\n\tint\t\ttx_tag_len;\n\tint\t\trx_tag_len;\n\tint\t\tdata_len;\n\tint\t\tcur_blk_len;\n\tint\t\ttotal_tx_len;\n\tint\t\ttotal_rx_len;\n\tint\t\ttx_fifo_data_pos;\n\tint\t\ttx_fifo_free;\n\tint\t\trx_fifo_data_pos;\n\tint\t\tfifo_available;\n\tu32\t\ttx_fifo_data;\n\tu32\t\trx_fifo_data;\n\tu8\t\t*cur_data;\n\tu8\t\t*cur_tx_tags;\n\tbool\t\ttx_tags_sent;\n\tbool\t\tsend_last_word;\n\tbool\t\trx_tags_fetched;\n\tbool\t\trx_bytes_read;\n\tbool\t\tis_tx_blk_mode;\n\tbool\t\tis_rx_blk_mode;\n\tu8\t\ttags[6];\n};\n\nstruct qup_i2c_tag {\n\tu8 *start;\n\tdma_addr_t addr;\n};\n\nstruct qup_i2c_bam {\n\tstruct\tqup_i2c_tag tag;\n\tstruct\tdma_chan *dma;\n\tstruct\tscatterlist *sg;\n\tunsigned int sg_cnt;\n};\n\nstruct qup_i2c_dev {\n\tstruct device\t\t*dev;\n\tvoid __iomem\t\t*base;\n\tint\t\t\tirq;\n\tstruct clk\t\t*clk;\n\tstruct clk\t\t*pclk;\n\tstruct i2c_adapter\tadap;\n\n\tint\t\t\tclk_ctl;\n\tint\t\t\tout_fifo_sz;\n\tint\t\t\tin_fifo_sz;\n\tint\t\t\tout_blk_sz;\n\tint\t\t\tin_blk_sz;\n\n\tint\t\t\tblk_xfer_limit;\n\tunsigned long\t\tone_byte_t;\n\tunsigned long\t\txfer_timeout;\n\tstruct qup_i2c_block\tblk;\n\n\tstruct i2c_msg\t\t*msg;\n\t \n\tint\t\t\tpos;\n\t \n\tu32\t\t\tbus_err;\n\t \n\tu32\t\t\tqup_err;\n\n\t \n\tbool\t\t\tis_last;\n\tbool\t\t\tis_smbus_read;\n\n\t \n\tu32\t\t\tconfig_run;\n\n\t \n\tbool\t\t\tis_dma;\n\t \n\tbool\t\t\tuse_dma;\n\tunsigned int\t\tmax_xfer_sg_len;\n\tunsigned int\t\ttag_buf_pos;\n\t \n\tunsigned int\t\tblk_mode_threshold;\n\tstruct\t\t\tdma_pool *dpool;\n\tstruct\t\t\tqup_i2c_tag start_tag;\n\tstruct\t\t\tqup_i2c_bam brx;\n\tstruct\t\t\tqup_i2c_bam btx;\n\n\tstruct completion\txfer;\n\t \n\tvoid (*write_tx_fifo)(struct qup_i2c_dev *qup);\n\t \n\tvoid (*read_rx_fifo)(struct qup_i2c_dev *qup);\n\t \n\tvoid (*write_rx_tags)(struct qup_i2c_dev *qup);\n};\n\nstatic irqreturn_t qup_i2c_interrupt(int irq, void *dev)\n{\n\tstruct qup_i2c_dev *qup = dev;\n\tstruct qup_i2c_block *blk = &qup->blk;\n\tu32 bus_err;\n\tu32 qup_err;\n\tu32 opflags;\n\n\tbus_err = readl(qup->base + QUP_I2C_STATUS);\n\tqup_err = readl(qup->base + QUP_ERROR_FLAGS);\n\topflags = readl(qup->base + QUP_OPERATIONAL);\n\n\tif (!qup->msg) {\n\t\t \n\t\twritel(QUP_RESET_STATE, qup->base + QUP_STATE);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tbus_err &= I2C_STATUS_ERROR_MASK;\n\tqup_err &= QUP_STATUS_ERROR_FLAGS;\n\n\t \n\tif (qup_err)\n\t\twritel(qup_err, qup->base + QUP_ERROR_FLAGS);\n\n\t \n\tif (bus_err)\n\t\twritel(bus_err, qup->base + QUP_I2C_STATUS);\n\n\t \n\tif (qup->use_dma && (qup->qup_err || qup->bus_err))\n\t\treturn IRQ_HANDLED;\n\n\t \n\tif (qup_err || bus_err) {\n\t\t \n\t\tif (!qup->use_dma)\n\t\t\twritel(QUP_RESET_STATE, qup->base + QUP_STATE);\n\t\tgoto done;\n\t}\n\n\tif (opflags & QUP_OUT_SVC_FLAG) {\n\t\twritel(QUP_OUT_SVC_FLAG, qup->base + QUP_OPERATIONAL);\n\n\t\tif (opflags & OUT_BLOCK_WRITE_REQ) {\n\t\t\tblk->tx_fifo_free += qup->out_blk_sz;\n\t\t\tif (qup->msg->flags & I2C_M_RD)\n\t\t\t\tqup->write_rx_tags(qup);\n\t\t\telse\n\t\t\t\tqup->write_tx_fifo(qup);\n\t\t}\n\t}\n\n\tif (opflags & QUP_IN_SVC_FLAG) {\n\t\twritel(QUP_IN_SVC_FLAG, qup->base + QUP_OPERATIONAL);\n\n\t\tif (!blk->is_rx_blk_mode) {\n\t\t\tblk->fifo_available += qup->in_fifo_sz;\n\t\t\tqup->read_rx_fifo(qup);\n\t\t} else if (opflags & IN_BLOCK_READ_REQ) {\n\t\t\tblk->fifo_available += qup->in_blk_sz;\n\t\t\tqup->read_rx_fifo(qup);\n\t\t}\n\t}\n\n\tif (qup->msg->flags & I2C_M_RD) {\n\t\tif (!blk->rx_bytes_read)\n\t\t\treturn IRQ_HANDLED;\n\t} else {\n\t\t \n\t\tif (blk->is_tx_blk_mode && !(opflags & QUP_MX_OUTPUT_DONE))\n\t\t\treturn IRQ_HANDLED;\n\t}\n\ndone:\n\tqup->qup_err = qup_err;\n\tqup->bus_err = bus_err;\n\tcomplete(&qup->xfer);\n\treturn IRQ_HANDLED;\n}\n\nstatic int qup_i2c_poll_state_mask(struct qup_i2c_dev *qup,\n\t\t\t\t   u32 req_state, u32 req_mask)\n{\n\tint retries = 1;\n\tu32 state;\n\n\t \n\tdo {\n\t\tstate = readl(qup->base + QUP_STATE);\n\n\t\tif (state & QUP_STATE_VALID &&\n\t\t    (state & req_mask) == req_state)\n\t\t\treturn 0;\n\n\t\tudelay(1);\n\t} while (retries--);\n\n\treturn -ETIMEDOUT;\n}\n\nstatic int qup_i2c_poll_state(struct qup_i2c_dev *qup, u32 req_state)\n{\n\treturn qup_i2c_poll_state_mask(qup, req_state, QUP_STATE_MASK);\n}\n\nstatic void qup_i2c_flush(struct qup_i2c_dev *qup)\n{\n\tu32 val = readl(qup->base + QUP_STATE);\n\n\tval |= QUP_I2C_FLUSH;\n\twritel(val, qup->base + QUP_STATE);\n}\n\nstatic int qup_i2c_poll_state_valid(struct qup_i2c_dev *qup)\n{\n\treturn qup_i2c_poll_state_mask(qup, 0, 0);\n}\n\nstatic int qup_i2c_poll_state_i2c_master(struct qup_i2c_dev *qup)\n{\n\treturn qup_i2c_poll_state_mask(qup, QUP_I2C_MAST_GEN, QUP_I2C_MAST_GEN);\n}\n\nstatic int qup_i2c_change_state(struct qup_i2c_dev *qup, u32 state)\n{\n\tif (qup_i2c_poll_state_valid(qup) != 0)\n\t\treturn -EIO;\n\n\twritel(state, qup->base + QUP_STATE);\n\n\tif (qup_i2c_poll_state(qup, state) != 0)\n\t\treturn -EIO;\n\treturn 0;\n}\n\n \nstatic int qup_i2c_bus_active(struct qup_i2c_dev *qup, int len)\n{\n\tunsigned long timeout;\n\tu32 status;\n\tint ret = 0;\n\n\ttimeout = jiffies + len * 4;\n\tfor (;;) {\n\t\tstatus = readl(qup->base + QUP_I2C_STATUS);\n\t\tif (!(status & I2C_STATUS_BUS_ACTIVE))\n\t\t\tbreak;\n\n\t\tif (time_after(jiffies, timeout))\n\t\t\tret = -ETIMEDOUT;\n\n\t\tusleep_range(len, len * 2);\n\t}\n\n\treturn ret;\n}\n\nstatic void qup_i2c_write_tx_fifo_v1(struct qup_i2c_dev *qup)\n{\n\tstruct qup_i2c_block *blk = &qup->blk;\n\tstruct i2c_msg *msg = qup->msg;\n\tu32 addr = i2c_8bit_addr_from_msg(msg);\n\tu32 qup_tag;\n\tint idx;\n\tu32 val;\n\n\tif (qup->pos == 0) {\n\t\tval = QUP_TAG_START | addr;\n\t\tidx = 1;\n\t\tblk->tx_fifo_free--;\n\t} else {\n\t\tval = 0;\n\t\tidx = 0;\n\t}\n\n\twhile (blk->tx_fifo_free && qup->pos < msg->len) {\n\t\tif (qup->pos == msg->len - 1)\n\t\t\tqup_tag = QUP_TAG_STOP;\n\t\telse\n\t\t\tqup_tag = QUP_TAG_DATA;\n\n\t\tif (idx & 1)\n\t\t\tval |= (qup_tag | msg->buf[qup->pos]) << QUP_MSW_SHIFT;\n\t\telse\n\t\t\tval = qup_tag | msg->buf[qup->pos];\n\n\t\t \n\t\tif (idx & 1 || qup->pos == msg->len - 1)\n\t\t\twritel(val, qup->base + QUP_OUT_FIFO_BASE);\n\n\t\tqup->pos++;\n\t\tidx++;\n\t\tblk->tx_fifo_free--;\n\t}\n}\n\nstatic void qup_i2c_set_blk_data(struct qup_i2c_dev *qup,\n\t\t\t\t struct i2c_msg *msg)\n{\n\tqup->blk.pos = 0;\n\tqup->blk.data_len = msg->len;\n\tqup->blk.count = DIV_ROUND_UP(msg->len, qup->blk_xfer_limit);\n}\n\nstatic int qup_i2c_get_data_len(struct qup_i2c_dev *qup)\n{\n\tint data_len;\n\n\tif (qup->blk.data_len > qup->blk_xfer_limit)\n\t\tdata_len = qup->blk_xfer_limit;\n\telse\n\t\tdata_len = qup->blk.data_len;\n\n\treturn data_len;\n}\n\nstatic bool qup_i2c_check_msg_len(struct i2c_msg *msg)\n{\n\treturn ((msg->flags & I2C_M_RD) && (msg->flags & I2C_M_RECV_LEN));\n}\n\nstatic int qup_i2c_set_tags_smb(u16 addr, u8 *tags, struct qup_i2c_dev *qup,\n\t\t\tstruct i2c_msg *msg)\n{\n\tint len = 0;\n\n\tif (qup->is_smbus_read) {\n\t\ttags[len++] = QUP_TAG_V2_DATARD_STOP;\n\t\ttags[len++] = qup_i2c_get_data_len(qup);\n\t} else {\n\t\ttags[len++] = QUP_TAG_V2_START;\n\t\ttags[len++] = addr & 0xff;\n\n\t\tif (msg->flags & I2C_M_TEN)\n\t\t\ttags[len++] = addr >> 8;\n\n\t\ttags[len++] = QUP_TAG_V2_DATARD;\n\t\t \n\t\ttags[len++] = 1;\n\t}\n\treturn len;\n}\n\nstatic int qup_i2c_set_tags(u8 *tags, struct qup_i2c_dev *qup,\n\t\t\t    struct i2c_msg *msg)\n{\n\tu16 addr = i2c_8bit_addr_from_msg(msg);\n\tint len = 0;\n\tint data_len;\n\n\tint last = (qup->blk.pos == (qup->blk.count - 1)) && (qup->is_last);\n\n\t \n\tif (qup_i2c_check_msg_len(msg))\n\t\treturn qup_i2c_set_tags_smb(addr, tags, qup, msg);\n\n\tif (qup->blk.pos == 0) {\n\t\ttags[len++] = QUP_TAG_V2_START;\n\t\ttags[len++] = addr & 0xff;\n\n\t\tif (msg->flags & I2C_M_TEN)\n\t\t\ttags[len++] = addr >> 8;\n\t}\n\n\t \n\tif (last) {\n\t\tif (msg->flags & I2C_M_RD)\n\t\t\ttags[len++] = QUP_TAG_V2_DATARD_STOP;\n\t\telse\n\t\t\ttags[len++] = QUP_TAG_V2_DATAWR_STOP;\n\t} else {\n\t\tif (msg->flags & I2C_M_RD)\n\t\t\ttags[len++] = qup->blk.pos == (qup->blk.count - 1) ?\n\t\t\t\t      QUP_TAG_V2_DATARD_NACK :\n\t\t\t\t      QUP_TAG_V2_DATARD;\n\t\telse\n\t\t\ttags[len++] = QUP_TAG_V2_DATAWR;\n\t}\n\n\tdata_len = qup_i2c_get_data_len(qup);\n\n\t \n\tif (data_len == QUP_READ_LIMIT)\n\t\ttags[len++] = 0;\n\telse\n\t\ttags[len++] = data_len;\n\n\treturn len;\n}\n\n\nstatic void qup_i2c_bam_cb(void *data)\n{\n\tstruct qup_i2c_dev *qup = data;\n\n\tcomplete(&qup->xfer);\n}\n\nstatic int qup_sg_set_buf(struct scatterlist *sg, void *buf,\n\t\t\t  unsigned int buflen, struct qup_i2c_dev *qup,\n\t\t\t  int dir)\n{\n\tint ret;\n\n\tsg_set_buf(sg, buf, buflen);\n\tret = dma_map_sg(qup->dev, sg, 1, dir);\n\tif (!ret)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic void qup_i2c_rel_dma(struct qup_i2c_dev *qup)\n{\n\tif (qup->btx.dma)\n\t\tdma_release_channel(qup->btx.dma);\n\tif (qup->brx.dma)\n\t\tdma_release_channel(qup->brx.dma);\n\tqup->btx.dma = NULL;\n\tqup->brx.dma = NULL;\n}\n\nstatic int qup_i2c_req_dma(struct qup_i2c_dev *qup)\n{\n\tint err;\n\n\tif (!qup->btx.dma) {\n\t\tqup->btx.dma = dma_request_chan(qup->dev, \"tx\");\n\t\tif (IS_ERR(qup->btx.dma)) {\n\t\t\terr = PTR_ERR(qup->btx.dma);\n\t\t\tqup->btx.dma = NULL;\n\t\t\tdev_err(qup->dev, \"\\n tx channel not available\");\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tif (!qup->brx.dma) {\n\t\tqup->brx.dma = dma_request_chan(qup->dev, \"rx\");\n\t\tif (IS_ERR(qup->brx.dma)) {\n\t\t\tdev_err(qup->dev, \"\\n rx channel not available\");\n\t\t\terr = PTR_ERR(qup->brx.dma);\n\t\t\tqup->brx.dma = NULL;\n\t\t\tqup_i2c_rel_dma(qup);\n\t\t\treturn err;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int qup_i2c_bam_make_desc(struct qup_i2c_dev *qup, struct i2c_msg *msg)\n{\n\tint ret = 0, limit = QUP_READ_LIMIT;\n\tu32 len = 0, blocks, rem;\n\tu32 i = 0, tlen, tx_len = 0;\n\tu8 *tags;\n\n\tqup->blk_xfer_limit = QUP_READ_LIMIT;\n\tqup_i2c_set_blk_data(qup, msg);\n\n\tblocks = qup->blk.count;\n\trem = msg->len - (blocks - 1) * limit;\n\n\tif (msg->flags & I2C_M_RD) {\n\t\twhile (qup->blk.pos < blocks) {\n\t\t\ttlen = (i == (blocks - 1)) ? rem : limit;\n\t\t\ttags = &qup->start_tag.start[qup->tag_buf_pos + len];\n\t\t\tlen += qup_i2c_set_tags(tags, qup, msg);\n\t\t\tqup->blk.data_len -= tlen;\n\n\t\t\t \n\t\t\tret = qup_sg_set_buf(&qup->brx.sg[qup->brx.sg_cnt++],\n\t\t\t\t\t     &qup->brx.tag.start[0],\n\t\t\t\t\t     2, qup, DMA_FROM_DEVICE);\n\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tret = qup_sg_set_buf(&qup->brx.sg[qup->brx.sg_cnt++],\n\t\t\t\t\t     &msg->buf[limit * i],\n\t\t\t\t\t     tlen, qup,\n\t\t\t\t\t     DMA_FROM_DEVICE);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\ti++;\n\t\t\tqup->blk.pos = i;\n\t\t}\n\t\tret = qup_sg_set_buf(&qup->btx.sg[qup->btx.sg_cnt++],\n\t\t\t\t     &qup->start_tag.start[qup->tag_buf_pos],\n\t\t\t\t     len, qup, DMA_TO_DEVICE);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tqup->tag_buf_pos += len;\n\t} else {\n\t\twhile (qup->blk.pos < blocks) {\n\t\t\ttlen = (i == (blocks - 1)) ? rem : limit;\n\t\t\ttags = &qup->start_tag.start[qup->tag_buf_pos + tx_len];\n\t\t\tlen = qup_i2c_set_tags(tags, qup, msg);\n\t\t\tqup->blk.data_len -= tlen;\n\n\t\t\tret = qup_sg_set_buf(&qup->btx.sg[qup->btx.sg_cnt++],\n\t\t\t\t\t     tags, len,\n\t\t\t\t\t     qup, DMA_TO_DEVICE);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\ttx_len += len;\n\t\t\tret = qup_sg_set_buf(&qup->btx.sg[qup->btx.sg_cnt++],\n\t\t\t\t\t     &msg->buf[limit * i],\n\t\t\t\t\t     tlen, qup, DMA_TO_DEVICE);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\ti++;\n\t\t\tqup->blk.pos = i;\n\t\t}\n\n\t\tqup->tag_buf_pos += tx_len;\n\t}\n\n\treturn 0;\n}\n\nstatic int qup_i2c_bam_schedule_desc(struct qup_i2c_dev *qup)\n{\n\tstruct dma_async_tx_descriptor *txd, *rxd = NULL;\n\tint ret = 0;\n\tdma_cookie_t cookie_rx, cookie_tx;\n\tu32 len = 0;\n\tu32 tx_cnt = qup->btx.sg_cnt, rx_cnt = qup->brx.sg_cnt;\n\n\t \n\tlen = 1;\n\tif (rx_cnt) {\n\t\tqup->btx.tag.start[0] = QUP_BAM_INPUT_EOT;\n\t\tlen++;\n\n\t\t \n\t\tret = qup_sg_set_buf(&qup->brx.sg[rx_cnt++],\n\t\t\t\t     &qup->brx.tag.start[0],\n\t\t\t\t     1, qup, DMA_FROM_DEVICE);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tqup->btx.tag.start[len - 1] = QUP_BAM_FLUSH_STOP;\n\tret = qup_sg_set_buf(&qup->btx.sg[tx_cnt++], &qup->btx.tag.start[0],\n\t\t\t     len, qup, DMA_TO_DEVICE);\n\tif (ret)\n\t\treturn ret;\n\n\ttxd = dmaengine_prep_slave_sg(qup->btx.dma, qup->btx.sg, tx_cnt,\n\t\t\t\t      DMA_MEM_TO_DEV,\n\t\t\t\t      DMA_PREP_INTERRUPT | DMA_PREP_FENCE);\n\tif (!txd) {\n\t\tdev_err(qup->dev, \"failed to get tx desc\\n\");\n\t\tret = -EINVAL;\n\t\tgoto desc_err;\n\t}\n\n\tif (!rx_cnt) {\n\t\ttxd->callback = qup_i2c_bam_cb;\n\t\ttxd->callback_param = qup;\n\t}\n\n\tcookie_tx = dmaengine_submit(txd);\n\tif (dma_submit_error(cookie_tx)) {\n\t\tret = -EINVAL;\n\t\tgoto desc_err;\n\t}\n\n\tdma_async_issue_pending(qup->btx.dma);\n\n\tif (rx_cnt) {\n\t\trxd = dmaengine_prep_slave_sg(qup->brx.dma, qup->brx.sg,\n\t\t\t\t\t      rx_cnt, DMA_DEV_TO_MEM,\n\t\t\t\t\t      DMA_PREP_INTERRUPT);\n\t\tif (!rxd) {\n\t\t\tdev_err(qup->dev, \"failed to get rx desc\\n\");\n\t\t\tret = -EINVAL;\n\n\t\t\t \n\t\t\tdmaengine_terminate_sync(qup->btx.dma);\n\t\t\tgoto desc_err;\n\t\t}\n\n\t\trxd->callback = qup_i2c_bam_cb;\n\t\trxd->callback_param = qup;\n\t\tcookie_rx = dmaengine_submit(rxd);\n\t\tif (dma_submit_error(cookie_rx)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto desc_err;\n\t\t}\n\n\t\tdma_async_issue_pending(qup->brx.dma);\n\t}\n\n\tif (!wait_for_completion_timeout(&qup->xfer, qup->xfer_timeout)) {\n\t\tdev_err(qup->dev, \"normal trans timed out\\n\");\n\t\tret = -ETIMEDOUT;\n\t}\n\n\tif (ret || qup->bus_err || qup->qup_err) {\n\t\treinit_completion(&qup->xfer);\n\n\t\tret = qup_i2c_change_state(qup, QUP_RUN_STATE);\n\t\tif (ret) {\n\t\t\tdev_err(qup->dev, \"change to run state timed out\");\n\t\t\tgoto desc_err;\n\t\t}\n\n\t\tqup_i2c_flush(qup);\n\n\t\t \n\t\tif (!wait_for_completion_timeout(&qup->xfer, HZ))\n\t\t\tdev_err(qup->dev, \"flush timed out\\n\");\n\n\t\tret =  (qup->bus_err & QUP_I2C_NACK_FLAG) ? -ENXIO : -EIO;\n\t}\n\ndesc_err:\n\tdma_unmap_sg(qup->dev, qup->btx.sg, tx_cnt, DMA_TO_DEVICE);\n\n\tif (rx_cnt)\n\t\tdma_unmap_sg(qup->dev, qup->brx.sg, rx_cnt,\n\t\t\t     DMA_FROM_DEVICE);\n\n\treturn ret;\n}\n\nstatic void qup_i2c_bam_clear_tag_buffers(struct qup_i2c_dev *qup)\n{\n\tqup->btx.sg_cnt = 0;\n\tqup->brx.sg_cnt = 0;\n\tqup->tag_buf_pos = 0;\n}\n\nstatic int qup_i2c_bam_xfer(struct i2c_adapter *adap, struct i2c_msg *msg,\n\t\t\t    int num)\n{\n\tstruct qup_i2c_dev *qup = i2c_get_adapdata(adap);\n\tint ret = 0;\n\tint idx = 0;\n\n\tenable_irq(qup->irq);\n\tret = qup_i2c_req_dma(qup);\n\n\tif (ret)\n\t\tgoto out;\n\n\twritel(0, qup->base + QUP_MX_INPUT_CNT);\n\twritel(0, qup->base + QUP_MX_OUTPUT_CNT);\n\n\t \n\twritel(QUP_REPACK_EN | QUP_BAM_MODE, qup->base + QUP_IO_MODE);\n\n\t \n\twritel((0x3 << 8), qup->base + QUP_OPERATIONAL_MASK);\n\n\t \n\tret = qup_i2c_change_state(qup, QUP_RUN_STATE);\n\tif (ret)\n\t\tgoto out;\n\n\twritel(qup->clk_ctl, qup->base + QUP_I2C_CLK_CTL);\n\tqup_i2c_bam_clear_tag_buffers(qup);\n\n\tfor (idx = 0; idx < num; idx++) {\n\t\tqup->msg = msg + idx;\n\t\tqup->is_last = idx == (num - 1);\n\n\t\tret = qup_i2c_bam_make_desc(qup, qup->msg);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\t \n\t\tif (qup->btx.sg_cnt > qup->max_xfer_sg_len ||\n\t\t    qup->brx.sg_cnt > qup->max_xfer_sg_len ||\n\t\t    qup->is_last) {\n\t\t\tret = qup_i2c_bam_schedule_desc(qup);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\n\t\t\tqup_i2c_bam_clear_tag_buffers(qup);\n\t\t}\n\t}\n\nout:\n\tdisable_irq(qup->irq);\n\n\tqup->msg = NULL;\n\treturn ret;\n}\n\nstatic int qup_i2c_wait_for_complete(struct qup_i2c_dev *qup,\n\t\t\t\t     struct i2c_msg *msg)\n{\n\tunsigned long left;\n\tint ret = 0;\n\n\tleft = wait_for_completion_timeout(&qup->xfer, qup->xfer_timeout);\n\tif (!left) {\n\t\twritel(1, qup->base + QUP_SW_RESET);\n\t\tret = -ETIMEDOUT;\n\t}\n\n\tif (qup->bus_err || qup->qup_err)\n\t\tret =  (qup->bus_err & QUP_I2C_NACK_FLAG) ? -ENXIO : -EIO;\n\n\treturn ret;\n}\n\nstatic void qup_i2c_read_rx_fifo_v1(struct qup_i2c_dev *qup)\n{\n\tstruct qup_i2c_block *blk = &qup->blk;\n\tstruct i2c_msg *msg = qup->msg;\n\tu32 val = 0;\n\tint idx = 0;\n\n\twhile (blk->fifo_available && qup->pos < msg->len) {\n\t\tif ((idx & 1) == 0) {\n\t\t\t \n\t\t\tval = readl(qup->base + QUP_IN_FIFO_BASE);\n\t\t\tmsg->buf[qup->pos++] = val & 0xFF;\n\t\t} else {\n\t\t\tmsg->buf[qup->pos++] = val >> QUP_MSW_SHIFT;\n\t\t}\n\t\tidx++;\n\t\tblk->fifo_available--;\n\t}\n\n\tif (qup->pos == msg->len)\n\t\tblk->rx_bytes_read = true;\n}\n\nstatic void qup_i2c_write_rx_tags_v1(struct qup_i2c_dev *qup)\n{\n\tstruct i2c_msg *msg = qup->msg;\n\tu32 addr, len, val;\n\n\taddr = i2c_8bit_addr_from_msg(msg);\n\n\t \n\tlen = (msg->len == QUP_READ_LIMIT) ? 0 : msg->len;\n\n\tval = ((QUP_TAG_REC | len) << QUP_MSW_SHIFT) | QUP_TAG_START | addr;\n\twritel(val, qup->base + QUP_OUT_FIFO_BASE);\n}\n\nstatic void qup_i2c_conf_v1(struct qup_i2c_dev *qup)\n{\n\tstruct qup_i2c_block *blk = &qup->blk;\n\tu32 qup_config = I2C_MINI_CORE | I2C_N_VAL;\n\tu32 io_mode = QUP_REPACK_EN;\n\n\tblk->is_tx_blk_mode = blk->total_tx_len > qup->out_fifo_sz;\n\tblk->is_rx_blk_mode = blk->total_rx_len > qup->in_fifo_sz;\n\n\tif (blk->is_tx_blk_mode) {\n\t\tio_mode |= QUP_OUTPUT_BLK_MODE;\n\t\twritel(0, qup->base + QUP_MX_WRITE_CNT);\n\t\twritel(blk->total_tx_len, qup->base + QUP_MX_OUTPUT_CNT);\n\t} else {\n\t\twritel(0, qup->base + QUP_MX_OUTPUT_CNT);\n\t\twritel(blk->total_tx_len, qup->base + QUP_MX_WRITE_CNT);\n\t}\n\n\tif (blk->total_rx_len) {\n\t\tif (blk->is_rx_blk_mode) {\n\t\t\tio_mode |= QUP_INPUT_BLK_MODE;\n\t\t\twritel(0, qup->base + QUP_MX_READ_CNT);\n\t\t\twritel(blk->total_rx_len, qup->base + QUP_MX_INPUT_CNT);\n\t\t} else {\n\t\t\twritel(0, qup->base + QUP_MX_INPUT_CNT);\n\t\t\twritel(blk->total_rx_len, qup->base + QUP_MX_READ_CNT);\n\t\t}\n\t} else {\n\t\tqup_config |= QUP_NO_INPUT;\n\t}\n\n\twritel(qup_config, qup->base + QUP_CONFIG);\n\twritel(io_mode, qup->base + QUP_IO_MODE);\n}\n\nstatic void qup_i2c_clear_blk_v1(struct qup_i2c_block *blk)\n{\n\tblk->tx_fifo_free = 0;\n\tblk->fifo_available = 0;\n\tblk->rx_bytes_read = false;\n}\n\nstatic int qup_i2c_conf_xfer_v1(struct qup_i2c_dev *qup, bool is_rx)\n{\n\tstruct qup_i2c_block *blk = &qup->blk;\n\tint ret;\n\n\tqup_i2c_clear_blk_v1(blk);\n\tqup_i2c_conf_v1(qup);\n\tret = qup_i2c_change_state(qup, QUP_RUN_STATE);\n\tif (ret)\n\t\treturn ret;\n\n\twritel(qup->clk_ctl, qup->base + QUP_I2C_CLK_CTL);\n\n\tret = qup_i2c_change_state(qup, QUP_PAUSE_STATE);\n\tif (ret)\n\t\treturn ret;\n\n\treinit_completion(&qup->xfer);\n\tenable_irq(qup->irq);\n\tif (!blk->is_tx_blk_mode) {\n\t\tblk->tx_fifo_free = qup->out_fifo_sz;\n\n\t\tif (is_rx)\n\t\t\tqup_i2c_write_rx_tags_v1(qup);\n\t\telse\n\t\t\tqup_i2c_write_tx_fifo_v1(qup);\n\t}\n\n\tret = qup_i2c_change_state(qup, QUP_RUN_STATE);\n\tif (ret)\n\t\tgoto err;\n\n\tret = qup_i2c_wait_for_complete(qup, qup->msg);\n\tif (ret)\n\t\tgoto err;\n\n\tret = qup_i2c_bus_active(qup, ONE_BYTE);\n\nerr:\n\tdisable_irq(qup->irq);\n\treturn ret;\n}\n\nstatic int qup_i2c_write_one(struct qup_i2c_dev *qup)\n{\n\tstruct i2c_msg *msg = qup->msg;\n\tstruct qup_i2c_block *blk = &qup->blk;\n\n\tqup->pos = 0;\n\tblk->total_tx_len = msg->len + 1;\n\tblk->total_rx_len = 0;\n\n\treturn qup_i2c_conf_xfer_v1(qup, false);\n}\n\nstatic int qup_i2c_read_one(struct qup_i2c_dev *qup)\n{\n\tstruct qup_i2c_block *blk = &qup->blk;\n\n\tqup->pos = 0;\n\tblk->total_tx_len = 2;\n\tblk->total_rx_len = qup->msg->len;\n\n\treturn qup_i2c_conf_xfer_v1(qup, true);\n}\n\nstatic int qup_i2c_xfer(struct i2c_adapter *adap,\n\t\t\tstruct i2c_msg msgs[],\n\t\t\tint num)\n{\n\tstruct qup_i2c_dev *qup = i2c_get_adapdata(adap);\n\tint ret, idx;\n\n\tret = pm_runtime_get_sync(qup->dev);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tqup->bus_err = 0;\n\tqup->qup_err = 0;\n\n\twritel(1, qup->base + QUP_SW_RESET);\n\tret = qup_i2c_poll_state(qup, QUP_RESET_STATE);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\twritel(I2C_MINI_CORE | I2C_N_VAL, qup->base + QUP_CONFIG);\n\n\tfor (idx = 0; idx < num; idx++) {\n\t\tif (qup_i2c_poll_state_i2c_master(qup)) {\n\t\t\tret = -EIO;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (qup_i2c_check_msg_len(&msgs[idx])) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tqup->msg = &msgs[idx];\n\t\tif (msgs[idx].flags & I2C_M_RD)\n\t\t\tret = qup_i2c_read_one(qup);\n\t\telse\n\t\t\tret = qup_i2c_write_one(qup);\n\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tret = qup_i2c_change_state(qup, QUP_RESET_STATE);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\tif (ret == 0)\n\t\tret = num;\nout:\n\n\tpm_runtime_mark_last_busy(qup->dev);\n\tpm_runtime_put_autosuspend(qup->dev);\n\n\treturn ret;\n}\n\n \nstatic void qup_i2c_conf_count_v2(struct qup_i2c_dev *qup)\n{\n\tstruct qup_i2c_block *blk = &qup->blk;\n\tu32 qup_config = I2C_MINI_CORE | I2C_N_VAL_V2;\n\n\tif (blk->is_tx_blk_mode)\n\t\twritel(qup->config_run | blk->total_tx_len,\n\t\t       qup->base + QUP_MX_OUTPUT_CNT);\n\telse\n\t\twritel(qup->config_run | blk->total_tx_len,\n\t\t       qup->base + QUP_MX_WRITE_CNT);\n\n\tif (blk->total_rx_len) {\n\t\tif (blk->is_rx_blk_mode)\n\t\t\twritel(qup->config_run | blk->total_rx_len,\n\t\t\t       qup->base + QUP_MX_INPUT_CNT);\n\t\telse\n\t\t\twritel(qup->config_run | blk->total_rx_len,\n\t\t\t       qup->base + QUP_MX_READ_CNT);\n\t} else {\n\t\tqup_config |= QUP_NO_INPUT;\n\t}\n\n\twritel(qup_config, qup->base + QUP_CONFIG);\n}\n\n \nstatic void qup_i2c_conf_mode_v2(struct qup_i2c_dev *qup)\n{\n\tstruct qup_i2c_block *blk = &qup->blk;\n\tu32 io_mode = QUP_REPACK_EN;\n\n\tif (blk->is_tx_blk_mode) {\n\t\tio_mode |= QUP_OUTPUT_BLK_MODE;\n\t\twritel(0, qup->base + QUP_MX_WRITE_CNT);\n\t} else {\n\t\twritel(0, qup->base + QUP_MX_OUTPUT_CNT);\n\t}\n\n\tif (blk->is_rx_blk_mode) {\n\t\tio_mode |= QUP_INPUT_BLK_MODE;\n\t\twritel(0, qup->base + QUP_MX_READ_CNT);\n\t} else {\n\t\twritel(0, qup->base + QUP_MX_INPUT_CNT);\n\t}\n\n\twritel(io_mode, qup->base + QUP_IO_MODE);\n}\n\n \nstatic void qup_i2c_clear_blk_v2(struct qup_i2c_block *blk)\n{\n\tblk->send_last_word = false;\n\tblk->tx_tags_sent = false;\n\tblk->tx_fifo_data = 0;\n\tblk->tx_fifo_data_pos = 0;\n\tblk->tx_fifo_free = 0;\n\n\tblk->rx_tags_fetched = false;\n\tblk->rx_bytes_read = false;\n\tblk->rx_fifo_data = 0;\n\tblk->rx_fifo_data_pos = 0;\n\tblk->fifo_available = 0;\n}\n\n \nstatic void qup_i2c_recv_data(struct qup_i2c_dev *qup)\n{\n\tstruct qup_i2c_block *blk = &qup->blk;\n\tint j;\n\n\tfor (j = blk->rx_fifo_data_pos;\n\t     blk->cur_blk_len && blk->fifo_available;\n\t     blk->cur_blk_len--, blk->fifo_available--) {\n\t\tif (j == 0)\n\t\t\tblk->rx_fifo_data = readl(qup->base + QUP_IN_FIFO_BASE);\n\n\t\t*(blk->cur_data++) = blk->rx_fifo_data;\n\t\tblk->rx_fifo_data >>= 8;\n\n\t\tif (j == 3)\n\t\t\tj = 0;\n\t\telse\n\t\t\tj++;\n\t}\n\n\tblk->rx_fifo_data_pos = j;\n}\n\n \nstatic void qup_i2c_recv_tags(struct qup_i2c_dev *qup)\n{\n\tstruct qup_i2c_block *blk = &qup->blk;\n\n\tblk->rx_fifo_data = readl(qup->base + QUP_IN_FIFO_BASE);\n\tblk->rx_fifo_data >>= blk->rx_tag_len  * 8;\n\tblk->rx_fifo_data_pos = blk->rx_tag_len;\n\tblk->fifo_available -= blk->rx_tag_len;\n}\n\n \nstatic void qup_i2c_read_rx_fifo_v2(struct qup_i2c_dev *qup)\n{\n\tstruct qup_i2c_block *blk = &qup->blk;\n\n\tif (!blk->rx_tags_fetched) {\n\t\tqup_i2c_recv_tags(qup);\n\t\tblk->rx_tags_fetched = true;\n\t}\n\n\tqup_i2c_recv_data(qup);\n\tif (!blk->cur_blk_len)\n\t\tblk->rx_bytes_read = true;\n}\n\n \nstatic void\nqup_i2c_write_blk_data(struct qup_i2c_dev *qup, u8 **data, unsigned int *len)\n{\n\tstruct qup_i2c_block *blk = &qup->blk;\n\tunsigned int j;\n\n\tfor (j = blk->tx_fifo_data_pos; *len && blk->tx_fifo_free;\n\t     (*len)--, blk->tx_fifo_free--) {\n\t\tblk->tx_fifo_data |= *(*data)++ << (j * 8);\n\t\tif (j == 3) {\n\t\t\twritel(blk->tx_fifo_data,\n\t\t\t       qup->base + QUP_OUT_FIFO_BASE);\n\t\t\tblk->tx_fifo_data = 0x0;\n\t\t\tj = 0;\n\t\t} else {\n\t\t\tj++;\n\t\t}\n\t}\n\n\tblk->tx_fifo_data_pos = j;\n}\n\n \nstatic void qup_i2c_write_rx_tags_v2(struct qup_i2c_dev *qup)\n{\n\tstruct qup_i2c_block *blk = &qup->blk;\n\n\tqup_i2c_write_blk_data(qup, &blk->cur_tx_tags, &blk->tx_tag_len);\n\tif (blk->tx_fifo_data_pos)\n\t\twritel(blk->tx_fifo_data, qup->base + QUP_OUT_FIFO_BASE);\n}\n\n \nstatic void qup_i2c_write_tx_fifo_v2(struct qup_i2c_dev *qup)\n{\n\tstruct qup_i2c_block *blk = &qup->blk;\n\n\tif (!blk->tx_tags_sent) {\n\t\tqup_i2c_write_blk_data(qup, &blk->cur_tx_tags,\n\t\t\t\t       &blk->tx_tag_len);\n\t\tblk->tx_tags_sent = true;\n\t}\n\n\tif (blk->send_last_word)\n\t\tgoto send_last_word;\n\n\tqup_i2c_write_blk_data(qup, &blk->cur_data, &blk->cur_blk_len);\n\tif (!blk->cur_blk_len) {\n\t\tif (!blk->tx_fifo_data_pos)\n\t\t\treturn;\n\n\t\tif (blk->tx_fifo_free)\n\t\t\tgoto send_last_word;\n\n\t\tblk->send_last_word = true;\n\t}\n\n\treturn;\n\nsend_last_word:\n\twritel(blk->tx_fifo_data, qup->base + QUP_OUT_FIFO_BASE);\n}\n\n \nstatic int\nqup_i2c_conf_xfer_v2(struct qup_i2c_dev *qup, bool is_rx, bool is_first,\n\t\t     bool change_pause_state)\n{\n\tstruct qup_i2c_block *blk = &qup->blk;\n\tstruct i2c_msg *msg = qup->msg;\n\tint ret;\n\n\t \n\tif (qup_i2c_check_msg_len(msg)) {\n\t\tif (qup->is_smbus_read) {\n\t\t\t \n\t\t\tblk->cur_data += 1;\n\t\t\tis_first = false;\n\t\t} else {\n\t\t\tchange_pause_state = false;\n\t\t}\n\t}\n\n\tqup->config_run = is_first ? 0 : QUP_I2C_MX_CONFIG_DURING_RUN;\n\n\tqup_i2c_clear_blk_v2(blk);\n\tqup_i2c_conf_count_v2(qup);\n\n\t \n\tif (is_first) {\n\t\tret = qup_i2c_change_state(qup, QUP_RUN_STATE);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\twritel(qup->clk_ctl, qup->base + QUP_I2C_CLK_CTL);\n\n\t\tret = qup_i2c_change_state(qup, QUP_PAUSE_STATE);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treinit_completion(&qup->xfer);\n\tenable_irq(qup->irq);\n\t \n\tif (!blk->is_tx_blk_mode) {\n\t\tblk->tx_fifo_free = qup->out_fifo_sz;\n\n\t\tif (is_rx)\n\t\t\tqup_i2c_write_rx_tags_v2(qup);\n\t\telse\n\t\t\tqup_i2c_write_tx_fifo_v2(qup);\n\t}\n\n\tret = qup_i2c_change_state(qup, QUP_RUN_STATE);\n\tif (ret)\n\t\tgoto err;\n\n\tret = qup_i2c_wait_for_complete(qup, msg);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tif (change_pause_state) {\n\t\tret = qup_i2c_change_state(qup, QUP_PAUSE_STATE);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\nerr:\n\tdisable_irq(qup->irq);\n\treturn ret;\n}\n\n \nstatic int qup_i2c_xfer_v2_msg(struct qup_i2c_dev *qup, int msg_id, bool is_rx)\n{\n\tint ret = 0;\n\tunsigned int data_len, i;\n\tstruct i2c_msg *msg = qup->msg;\n\tstruct qup_i2c_block *blk = &qup->blk;\n\tu8 *msg_buf = msg->buf;\n\n\tqup->blk_xfer_limit = is_rx ? RECV_MAX_DATA_LEN : QUP_READ_LIMIT;\n\tqup_i2c_set_blk_data(qup, msg);\n\n\tfor (i = 0; i < blk->count; i++) {\n\t\tdata_len =  qup_i2c_get_data_len(qup);\n\t\tblk->pos = i;\n\t\tblk->cur_tx_tags = blk->tags;\n\t\tblk->cur_blk_len = data_len;\n\t\tblk->tx_tag_len =\n\t\t\tqup_i2c_set_tags(blk->cur_tx_tags, qup, qup->msg);\n\n\t\tblk->cur_data = msg_buf;\n\n\t\tif (is_rx) {\n\t\t\tblk->total_tx_len = blk->tx_tag_len;\n\t\t\tblk->rx_tag_len = 2;\n\t\t\tblk->total_rx_len = blk->rx_tag_len + data_len;\n\t\t} else {\n\t\t\tblk->total_tx_len = blk->tx_tag_len + data_len;\n\t\t\tblk->total_rx_len = 0;\n\t\t}\n\n\t\tret = qup_i2c_conf_xfer_v2(qup, is_rx, !msg_id && !i,\n\t\t\t\t\t   !qup->is_last || i < blk->count - 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tif (qup_i2c_check_msg_len(msg) && msg->len == 1 &&\n\t\t    !qup->is_smbus_read) {\n\t\t\tif (msg->buf[0] > I2C_SMBUS_BLOCK_MAX)\n\t\t\t\treturn -EPROTO;\n\n\t\t\tmsg->len = msg->buf[0];\n\t\t\tqup->is_smbus_read = true;\n\t\t\tret = qup_i2c_xfer_v2_msg(qup, msg_id, true);\n\t\t\tqup->is_smbus_read = false;\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tmsg->len += 1;\n\t\t}\n\n\t\tmsg_buf += data_len;\n\t\tblk->data_len -= qup->blk_xfer_limit;\n\t}\n\n\treturn ret;\n}\n\n \nstatic int\nqup_i2c_determine_mode_v2(struct qup_i2c_dev *qup,\n\t\t\t  struct i2c_msg msgs[], int num)\n{\n\tint idx;\n\tbool no_dma = false;\n\tunsigned int max_tx_len = 0, max_rx_len = 0, total_len = 0;\n\n\t \n\tfor (idx = 0; idx < num; idx++) {\n\t\tif (msgs[idx].flags & I2C_M_RD)\n\t\t\tmax_rx_len = max_t(unsigned int, max_rx_len,\n\t\t\t\t\t   msgs[idx].len);\n\t\telse\n\t\t\tmax_tx_len = max_t(unsigned int, max_tx_len,\n\t\t\t\t\t   msgs[idx].len);\n\n\t\tif (is_vmalloc_addr(msgs[idx].buf))\n\t\t\tno_dma = true;\n\n\t\ttotal_len += msgs[idx].len;\n\t}\n\n\tif (!no_dma && qup->is_dma &&\n\t    (total_len > qup->out_fifo_sz || total_len > qup->in_fifo_sz)) {\n\t\tqup->use_dma = true;\n\t} else {\n\t\tqup->blk.is_tx_blk_mode = max_tx_len > qup->out_fifo_sz -\n\t\t\tQUP_MAX_TAGS_LEN;\n\t\tqup->blk.is_rx_blk_mode = max_rx_len > qup->in_fifo_sz -\n\t\t\tREAD_RX_TAGS_LEN;\n\t}\n\n\treturn 0;\n}\n\nstatic int qup_i2c_xfer_v2(struct i2c_adapter *adap,\n\t\t\t   struct i2c_msg msgs[],\n\t\t\t   int num)\n{\n\tstruct qup_i2c_dev *qup = i2c_get_adapdata(adap);\n\tint ret, idx = 0;\n\n\tqup->bus_err = 0;\n\tqup->qup_err = 0;\n\n\tret = pm_runtime_get_sync(qup->dev);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = qup_i2c_determine_mode_v2(qup, msgs, num);\n\tif (ret)\n\t\tgoto out;\n\n\twritel(1, qup->base + QUP_SW_RESET);\n\tret = qup_i2c_poll_state(qup, QUP_RESET_STATE);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\twritel(I2C_MINI_CORE | I2C_N_VAL_V2, qup->base + QUP_CONFIG);\n\twritel(QUP_V2_TAGS_EN, qup->base + QUP_I2C_MASTER_GEN);\n\n\tif (qup_i2c_poll_state_i2c_master(qup)) {\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\tif (qup->use_dma) {\n\t\treinit_completion(&qup->xfer);\n\t\tret = qup_i2c_bam_xfer(adap, &msgs[0], num);\n\t\tqup->use_dma = false;\n\t} else {\n\t\tqup_i2c_conf_mode_v2(qup);\n\n\t\tfor (idx = 0; idx < num; idx++) {\n\t\t\tqup->msg = &msgs[idx];\n\t\t\tqup->is_last = idx == (num - 1);\n\n\t\t\tret = qup_i2c_xfer_v2_msg(qup, idx,\n\t\t\t\t\t!!(msgs[idx].flags & I2C_M_RD));\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t\tqup->msg = NULL;\n\t}\n\n\tif (!ret)\n\t\tret = qup_i2c_bus_active(qup, ONE_BYTE);\n\n\tif (!ret)\n\t\tqup_i2c_change_state(qup, QUP_RESET_STATE);\n\n\tif (ret == 0)\n\t\tret = num;\nout:\n\tpm_runtime_mark_last_busy(qup->dev);\n\tpm_runtime_put_autosuspend(qup->dev);\n\n\treturn ret;\n}\n\nstatic u32 qup_i2c_func(struct i2c_adapter *adap)\n{\n\treturn I2C_FUNC_I2C | (I2C_FUNC_SMBUS_EMUL_ALL & ~I2C_FUNC_SMBUS_QUICK);\n}\n\nstatic const struct i2c_algorithm qup_i2c_algo = {\n\t.master_xfer\t= qup_i2c_xfer,\n\t.functionality\t= qup_i2c_func,\n};\n\nstatic const struct i2c_algorithm qup_i2c_algo_v2 = {\n\t.master_xfer\t= qup_i2c_xfer_v2,\n\t.functionality\t= qup_i2c_func,\n};\n\n \nstatic const struct i2c_adapter_quirks qup_i2c_quirks = {\n\t.flags = I2C_AQ_NO_ZERO_LEN,\n\t.max_read_len = QUP_READ_LIMIT,\n};\n\nstatic const struct i2c_adapter_quirks qup_i2c_quirks_v2 = {\n\t.flags = I2C_AQ_NO_ZERO_LEN,\n};\n\nstatic void qup_i2c_enable_clocks(struct qup_i2c_dev *qup)\n{\n\tclk_prepare_enable(qup->clk);\n\tclk_prepare_enable(qup->pclk);\n}\n\nstatic void qup_i2c_disable_clocks(struct qup_i2c_dev *qup)\n{\n\tu32 config;\n\n\tqup_i2c_change_state(qup, QUP_RESET_STATE);\n\tclk_disable_unprepare(qup->clk);\n\tconfig = readl(qup->base + QUP_CONFIG);\n\tconfig |= QUP_CLOCK_AUTO_GATE;\n\twritel(config, qup->base + QUP_CONFIG);\n\tclk_disable_unprepare(qup->pclk);\n}\n\nstatic const struct acpi_device_id qup_i2c_acpi_match[] = {\n\t{ \"QCOM8010\"},\n\t{ },\n};\nMODULE_DEVICE_TABLE(acpi, qup_i2c_acpi_match);\n\nstatic int qup_i2c_probe(struct platform_device *pdev)\n{\n\tstatic const int blk_sizes[] = {4, 16, 32};\n\tstruct qup_i2c_dev *qup;\n\tunsigned long one_bit_t;\n\tu32 io_mode, hw_ver, size;\n\tint ret, fs_div, hs_div;\n\tu32 src_clk_freq = DEFAULT_SRC_CLK;\n\tu32 clk_freq = DEFAULT_CLK_FREQ;\n\tint blocks;\n\tbool is_qup_v1;\n\n\tqup = devm_kzalloc(&pdev->dev, sizeof(*qup), GFP_KERNEL);\n\tif (!qup)\n\t\treturn -ENOMEM;\n\n\tqup->dev = &pdev->dev;\n\tinit_completion(&qup->xfer);\n\tplatform_set_drvdata(pdev, qup);\n\n\tif (scl_freq) {\n\t\tdev_notice(qup->dev, \"Using override frequency of %u\\n\", scl_freq);\n\t\tclk_freq = scl_freq;\n\t} else {\n\t\tret = device_property_read_u32(qup->dev, \"clock-frequency\", &clk_freq);\n\t\tif (ret) {\n\t\t\tdev_notice(qup->dev, \"using default clock-frequency %d\",\n\t\t\t\tDEFAULT_CLK_FREQ);\n\t\t}\n\t}\n\n\tif (of_device_is_compatible(pdev->dev.of_node, \"qcom,i2c-qup-v1.1.1\")) {\n\t\tqup->adap.algo = &qup_i2c_algo;\n\t\tqup->adap.quirks = &qup_i2c_quirks;\n\t\tis_qup_v1 = true;\n\t} else {\n\t\tqup->adap.algo = &qup_i2c_algo_v2;\n\t\tqup->adap.quirks = &qup_i2c_quirks_v2;\n\t\tis_qup_v1 = false;\n\t\tif (acpi_match_device(qup_i2c_acpi_match, qup->dev))\n\t\t\tgoto nodma;\n\t\telse\n\t\t\tret = qup_i2c_req_dma(qup);\n\n\t\tif (ret == -EPROBE_DEFER)\n\t\t\tgoto fail_dma;\n\t\telse if (ret != 0)\n\t\t\tgoto nodma;\n\n\t\tqup->max_xfer_sg_len = (MX_BLOCKS << 1);\n\t\tblocks = (MX_DMA_BLOCKS << 1) + 1;\n\t\tqup->btx.sg = devm_kcalloc(&pdev->dev,\n\t\t\t\t\t   blocks, sizeof(*qup->btx.sg),\n\t\t\t\t\t   GFP_KERNEL);\n\t\tif (!qup->btx.sg) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto fail_dma;\n\t\t}\n\t\tsg_init_table(qup->btx.sg, blocks);\n\n\t\tqup->brx.sg = devm_kcalloc(&pdev->dev,\n\t\t\t\t\t   blocks, sizeof(*qup->brx.sg),\n\t\t\t\t\t   GFP_KERNEL);\n\t\tif (!qup->brx.sg) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto fail_dma;\n\t\t}\n\t\tsg_init_table(qup->brx.sg, blocks);\n\n\t\t \n\t\tsize = blocks * 2 + 5;\n\n\t\tqup->start_tag.start = devm_kzalloc(&pdev->dev,\n\t\t\t\t\t\t    size, GFP_KERNEL);\n\t\tif (!qup->start_tag.start) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto fail_dma;\n\t\t}\n\n\t\tqup->brx.tag.start = devm_kzalloc(&pdev->dev, 2, GFP_KERNEL);\n\t\tif (!qup->brx.tag.start) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto fail_dma;\n\t\t}\n\n\t\tqup->btx.tag.start = devm_kzalloc(&pdev->dev, 2, GFP_KERNEL);\n\t\tif (!qup->btx.tag.start) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto fail_dma;\n\t\t}\n\t\tqup->is_dma = true;\n\t}\n\nnodma:\n\t \n\tif (!clk_freq || clk_freq > I2C_MAX_FAST_MODE_PLUS_FREQ) {\n\t\tdev_err(qup->dev, \"clock frequency not supported %d\\n\",\n\t\t\tclk_freq);\n\t\tret = -EINVAL;\n\t\tgoto fail_dma;\n\t}\n\n\tqup->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(qup->base)) {\n\t\tret = PTR_ERR(qup->base);\n\t\tgoto fail_dma;\n\t}\n\n\tqup->irq = platform_get_irq(pdev, 0);\n\tif (qup->irq < 0) {\n\t\tret = qup->irq;\n\t\tgoto fail_dma;\n\t}\n\n\tif (has_acpi_companion(qup->dev)) {\n\t\tret = device_property_read_u32(qup->dev,\n\t\t\t\t\"src-clock-hz\", &src_clk_freq);\n\t\tif (ret) {\n\t\t\tdev_notice(qup->dev, \"using default src-clock-hz %d\",\n\t\t\t\tDEFAULT_SRC_CLK);\n\t\t}\n\t\tACPI_COMPANION_SET(&qup->adap.dev, ACPI_COMPANION(qup->dev));\n\t} else {\n\t\tqup->clk = devm_clk_get(qup->dev, \"core\");\n\t\tif (IS_ERR(qup->clk)) {\n\t\t\tdev_err(qup->dev, \"Could not get core clock\\n\");\n\t\t\tret = PTR_ERR(qup->clk);\n\t\t\tgoto fail_dma;\n\t\t}\n\n\t\tqup->pclk = devm_clk_get(qup->dev, \"iface\");\n\t\tif (IS_ERR(qup->pclk)) {\n\t\t\tdev_err(qup->dev, \"Could not get iface clock\\n\");\n\t\t\tret = PTR_ERR(qup->pclk);\n\t\t\tgoto fail_dma;\n\t\t}\n\t\tqup_i2c_enable_clocks(qup);\n\t\tsrc_clk_freq = clk_get_rate(qup->clk);\n\t}\n\n\t \n\twritel(1, qup->base + QUP_SW_RESET);\n\tret = qup_i2c_poll_state_valid(qup);\n\tif (ret)\n\t\tgoto fail;\n\n\tret = devm_request_irq(qup->dev, qup->irq, qup_i2c_interrupt,\n\t\t\t       IRQF_TRIGGER_HIGH | IRQF_NO_AUTOEN,\n\t\t\t       \"i2c_qup\", qup);\n\tif (ret) {\n\t\tdev_err(qup->dev, \"Request %d IRQ failed\\n\", qup->irq);\n\t\tgoto fail;\n\t}\n\n\thw_ver = readl(qup->base + QUP_HW_VERSION);\n\tdev_dbg(qup->dev, \"Revision %x\\n\", hw_ver);\n\n\tio_mode = readl(qup->base + QUP_IO_MODE);\n\n\t \n\tsize = QUP_OUTPUT_BLOCK_SIZE(io_mode);\n\tif (size >= ARRAY_SIZE(blk_sizes)) {\n\t\tret = -EIO;\n\t\tgoto fail;\n\t}\n\tqup->out_blk_sz = blk_sizes[size];\n\n\tsize = QUP_INPUT_BLOCK_SIZE(io_mode);\n\tif (size >= ARRAY_SIZE(blk_sizes)) {\n\t\tret = -EIO;\n\t\tgoto fail;\n\t}\n\tqup->in_blk_sz = blk_sizes[size];\n\n\tif (is_qup_v1) {\n\t\t \n\t\tqup->in_blk_sz /= 2;\n\t\tqup->out_blk_sz /= 2;\n\t\tqup->write_tx_fifo = qup_i2c_write_tx_fifo_v1;\n\t\tqup->read_rx_fifo = qup_i2c_read_rx_fifo_v1;\n\t\tqup->write_rx_tags = qup_i2c_write_rx_tags_v1;\n\t} else {\n\t\tqup->write_tx_fifo = qup_i2c_write_tx_fifo_v2;\n\t\tqup->read_rx_fifo = qup_i2c_read_rx_fifo_v2;\n\t\tqup->write_rx_tags = qup_i2c_write_rx_tags_v2;\n\t}\n\n\tsize = QUP_OUTPUT_FIFO_SIZE(io_mode);\n\tqup->out_fifo_sz = qup->out_blk_sz * (2 << size);\n\n\tsize = QUP_INPUT_FIFO_SIZE(io_mode);\n\tqup->in_fifo_sz = qup->in_blk_sz * (2 << size);\n\n\ths_div = 3;\n\tif (clk_freq <= I2C_MAX_STANDARD_MODE_FREQ) {\n\t\tfs_div = ((src_clk_freq / clk_freq) / 2) - 3;\n\t\tqup->clk_ctl = (hs_div << 8) | (fs_div & 0xff);\n\t} else {\n\t\t \n\t\tfs_div = ((src_clk_freq / clk_freq) - 6) * 2 / 3;\n\t\tqup->clk_ctl = ((fs_div / 2) << 16) | (hs_div << 8) | (fs_div & 0xff);\n\t}\n\n\t \n\tone_bit_t = (USEC_PER_SEC / clk_freq) + 1;\n\tqup->one_byte_t = one_bit_t * 9;\n\tqup->xfer_timeout = TOUT_MIN * HZ +\n\t\tusecs_to_jiffies(MX_DMA_TX_RX_LEN * qup->one_byte_t);\n\n\tdev_dbg(qup->dev, \"IN:block:%d, fifo:%d, OUT:block:%d, fifo:%d\\n\",\n\t\tqup->in_blk_sz, qup->in_fifo_sz,\n\t\tqup->out_blk_sz, qup->out_fifo_sz);\n\n\ti2c_set_adapdata(&qup->adap, qup);\n\tqup->adap.dev.parent = qup->dev;\n\tqup->adap.dev.of_node = pdev->dev.of_node;\n\tqup->is_last = true;\n\n\tstrscpy(qup->adap.name, \"QUP I2C adapter\", sizeof(qup->adap.name));\n\n\tpm_runtime_set_autosuspend_delay(qup->dev, MSEC_PER_SEC);\n\tpm_runtime_use_autosuspend(qup->dev);\n\tpm_runtime_set_active(qup->dev);\n\tpm_runtime_enable(qup->dev);\n\n\tret = i2c_add_adapter(&qup->adap);\n\tif (ret)\n\t\tgoto fail_runtime;\n\n\treturn 0;\n\nfail_runtime:\n\tpm_runtime_disable(qup->dev);\n\tpm_runtime_set_suspended(qup->dev);\nfail:\n\tqup_i2c_disable_clocks(qup);\nfail_dma:\n\tif (qup->btx.dma)\n\t\tdma_release_channel(qup->btx.dma);\n\tif (qup->brx.dma)\n\t\tdma_release_channel(qup->brx.dma);\n\treturn ret;\n}\n\nstatic void qup_i2c_remove(struct platform_device *pdev)\n{\n\tstruct qup_i2c_dev *qup = platform_get_drvdata(pdev);\n\n\tif (qup->is_dma) {\n\t\tdma_release_channel(qup->btx.dma);\n\t\tdma_release_channel(qup->brx.dma);\n\t}\n\n\tdisable_irq(qup->irq);\n\tqup_i2c_disable_clocks(qup);\n\ti2c_del_adapter(&qup->adap);\n\tpm_runtime_disable(qup->dev);\n\tpm_runtime_set_suspended(qup->dev);\n}\n\nstatic int qup_i2c_pm_suspend_runtime(struct device *device)\n{\n\tstruct qup_i2c_dev *qup = dev_get_drvdata(device);\n\n\tdev_dbg(device, \"pm_runtime: suspending...\\n\");\n\tqup_i2c_disable_clocks(qup);\n\treturn 0;\n}\n\nstatic int qup_i2c_pm_resume_runtime(struct device *device)\n{\n\tstruct qup_i2c_dev *qup = dev_get_drvdata(device);\n\n\tdev_dbg(device, \"pm_runtime: resuming...\\n\");\n\tqup_i2c_enable_clocks(qup);\n\treturn 0;\n}\n\nstatic int qup_i2c_suspend(struct device *device)\n{\n\tif (!pm_runtime_suspended(device))\n\t\treturn qup_i2c_pm_suspend_runtime(device);\n\treturn 0;\n}\n\nstatic int qup_i2c_resume(struct device *device)\n{\n\tqup_i2c_pm_resume_runtime(device);\n\tpm_runtime_mark_last_busy(device);\n\tpm_request_autosuspend(device);\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops qup_i2c_qup_pm_ops = {\n\tSYSTEM_SLEEP_PM_OPS(qup_i2c_suspend, qup_i2c_resume)\n\tRUNTIME_PM_OPS(qup_i2c_pm_suspend_runtime,\n\t\t       qup_i2c_pm_resume_runtime, NULL)\n};\n\nstatic const struct of_device_id qup_i2c_dt_match[] = {\n\t{ .compatible = \"qcom,i2c-qup-v1.1.1\" },\n\t{ .compatible = \"qcom,i2c-qup-v2.1.1\" },\n\t{ .compatible = \"qcom,i2c-qup-v2.2.1\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, qup_i2c_dt_match);\n\nstatic struct platform_driver qup_i2c_driver = {\n\t.probe  = qup_i2c_probe,\n\t.remove_new = qup_i2c_remove,\n\t.driver = {\n\t\t.name = \"i2c_qup\",\n\t\t.pm = pm_ptr(&qup_i2c_qup_pm_ops),\n\t\t.of_match_table = qup_i2c_dt_match,\n\t\t.acpi_match_table = ACPI_PTR(qup_i2c_acpi_match),\n\t},\n};\n\nmodule_platform_driver(qup_i2c_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:i2c_qup\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}