{
  "module_name": "i2c-digicolor.c",
  "hash_id": "68ec461c9a4d37757e47809e910fdf77be3aef43b03fc60b3b75e23d50b7b8a7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-digicolor.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n\n#define TIMEOUT_MS\t\t100\n\n#define II_CONTROL\t\t0x0\n#define II_CONTROL_LOCAL_RESET\tBIT(0)\n\n#define II_CLOCKTIME\t\t0x1\n\n#define II_COMMAND\t\t0x2\n#define II_CMD_START\t\t1\n#define II_CMD_RESTART\t\t2\n#define II_CMD_SEND_ACK\t\t3\n#define II_CMD_GET_ACK\t\t6\n#define II_CMD_GET_NOACK\t7\n#define II_CMD_STOP\t\t10\n#define II_COMMAND_GO\t\tBIT(7)\n#define II_COMMAND_COMPLETION_STATUS(r)\t(((r) >> 5) & 3)\n#define II_CMD_STATUS_NORMAL\t0\n#define II_CMD_STATUS_ACK_GOOD\t1\n#define II_CMD_STATUS_ACK_BAD\t2\n#define II_CMD_STATUS_ABORT\t3\n\n#define II_DATA\t\t\t0x3\n#define II_INTFLAG_CLEAR\t0x8\n#define II_INTENABLE\t\t0xa\n\nstruct dc_i2c {\n\tstruct i2c_adapter\tadap;\n\tstruct device\t\t*dev;\n\tvoid __iomem\t\t*regs;\n\tstruct clk\t\t*clk;\n\tunsigned int\t\tfrequency;\n\n\tstruct i2c_msg\t\t*msg;\n\tunsigned int\t\tmsgbuf_ptr;\n\tint\t\t\tlast;\n\tspinlock_t\t\tlock;\n\tstruct completion\tdone;\n\tint\t\t\tstate;\n\tint\t\t\terror;\n};\n\nenum {\n\tSTATE_IDLE,\n\tSTATE_START,\n\tSTATE_ADDR,\n\tSTATE_WRITE,\n\tSTATE_READ,\n\tSTATE_STOP,\n};\n\nstatic void dc_i2c_cmd(struct dc_i2c *i2c, u8 cmd)\n{\n\twriteb_relaxed(cmd | II_COMMAND_GO, i2c->regs + II_COMMAND);\n}\n\nstatic u8 dc_i2c_addr_cmd(struct i2c_msg *msg)\n{\n\tu8 addr = (msg->addr & 0x7f) << 1;\n\n\tif (msg->flags & I2C_M_RD)\n\t\taddr |= 1;\n\n\treturn addr;\n}\n\nstatic void dc_i2c_data(struct dc_i2c *i2c, u8 data)\n{\n\twriteb_relaxed(data, i2c->regs + II_DATA);\n}\n\nstatic void dc_i2c_write_byte(struct dc_i2c *i2c, u8 byte)\n{\n\tdc_i2c_data(i2c, byte);\n\tdc_i2c_cmd(i2c, II_CMD_SEND_ACK);\n}\n\nstatic void dc_i2c_write_buf(struct dc_i2c *i2c)\n{\n\tdc_i2c_write_byte(i2c, i2c->msg->buf[i2c->msgbuf_ptr++]);\n}\n\nstatic void dc_i2c_next_read(struct dc_i2c *i2c)\n{\n\tbool last = (i2c->msgbuf_ptr + 1 == i2c->msg->len);\n\n\tdc_i2c_cmd(i2c, last ? II_CMD_GET_NOACK : II_CMD_GET_ACK);\n}\n\nstatic void dc_i2c_stop(struct dc_i2c *i2c)\n{\n\ti2c->state = STATE_STOP;\n\tif (i2c->last)\n\t\tdc_i2c_cmd(i2c, II_CMD_STOP);\n\telse\n\t\tcomplete(&i2c->done);\n}\n\nstatic u8 dc_i2c_read_byte(struct dc_i2c *i2c)\n{\n\treturn readb_relaxed(i2c->regs + II_DATA);\n}\n\nstatic void dc_i2c_read_buf(struct dc_i2c *i2c)\n{\n\ti2c->msg->buf[i2c->msgbuf_ptr++] = dc_i2c_read_byte(i2c);\n\tdc_i2c_next_read(i2c);\n}\n\nstatic void dc_i2c_set_irq(struct dc_i2c *i2c, int enable)\n{\n\tif (enable)\n\t\twriteb_relaxed(1, i2c->regs + II_INTFLAG_CLEAR);\n\twriteb_relaxed(!!enable, i2c->regs + II_INTENABLE);\n}\n\nstatic int dc_i2c_cmd_status(struct dc_i2c *i2c)\n{\n\tu8 cmd = readb_relaxed(i2c->regs + II_COMMAND);\n\n\treturn II_COMMAND_COMPLETION_STATUS(cmd);\n}\n\nstatic void dc_i2c_start_msg(struct dc_i2c *i2c, int first)\n{\n\tstruct i2c_msg *msg = i2c->msg;\n\n\tif (!(msg->flags & I2C_M_NOSTART)) {\n\t\ti2c->state = STATE_START;\n\t\tdc_i2c_cmd(i2c, first ? II_CMD_START : II_CMD_RESTART);\n\t} else if (msg->flags & I2C_M_RD) {\n\t\ti2c->state = STATE_READ;\n\t\tdc_i2c_next_read(i2c);\n\t} else {\n\t\ti2c->state = STATE_WRITE;\n\t\tdc_i2c_write_buf(i2c);\n\t}\n}\n\nstatic irqreturn_t dc_i2c_irq(int irq, void *dev_id)\n{\n\tstruct dc_i2c *i2c = dev_id;\n\tint cmd_status = dc_i2c_cmd_status(i2c);\n\tu8 addr_cmd;\n\n\twriteb_relaxed(1, i2c->regs + II_INTFLAG_CLEAR);\n\n\tspin_lock(&i2c->lock);\n\n\tif (cmd_status == II_CMD_STATUS_ACK_BAD\n\t    || cmd_status == II_CMD_STATUS_ABORT) {\n\t\ti2c->error = -EIO;\n\t\tcomplete(&i2c->done);\n\t\tgoto out;\n\t}\n\n\tswitch (i2c->state) {\n\tcase STATE_START:\n\t\taddr_cmd = dc_i2c_addr_cmd(i2c->msg);\n\t\tdc_i2c_write_byte(i2c, addr_cmd);\n\t\ti2c->state = STATE_ADDR;\n\t\tbreak;\n\tcase STATE_ADDR:\n\t\tif (i2c->msg->flags & I2C_M_RD) {\n\t\t\tdc_i2c_next_read(i2c);\n\t\t\ti2c->state = STATE_READ;\n\t\t\tbreak;\n\t\t}\n\t\ti2c->state = STATE_WRITE;\n\t\tfallthrough;\n\tcase STATE_WRITE:\n\t\tif (i2c->msgbuf_ptr < i2c->msg->len)\n\t\t\tdc_i2c_write_buf(i2c);\n\t\telse\n\t\t\tdc_i2c_stop(i2c);\n\t\tbreak;\n\tcase STATE_READ:\n\t\tif (i2c->msgbuf_ptr < i2c->msg->len)\n\t\t\tdc_i2c_read_buf(i2c);\n\t\telse\n\t\t\tdc_i2c_stop(i2c);\n\t\tbreak;\n\tcase STATE_STOP:\n\t\ti2c->state = STATE_IDLE;\n\t\tcomplete(&i2c->done);\n\t\tbreak;\n\t}\n\nout:\n\tspin_unlock(&i2c->lock);\n\treturn IRQ_HANDLED;\n}\n\nstatic int dc_i2c_xfer_msg(struct dc_i2c *i2c, struct i2c_msg *msg, int first,\n\t\t\t   int last)\n{\n\tunsigned long timeout = msecs_to_jiffies(TIMEOUT_MS);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&i2c->lock, flags);\n\ti2c->msg = msg;\n\ti2c->msgbuf_ptr = 0;\n\ti2c->last = last;\n\ti2c->error = 0;\n\n\treinit_completion(&i2c->done);\n\tdc_i2c_set_irq(i2c, 1);\n\tdc_i2c_start_msg(i2c, first);\n\tspin_unlock_irqrestore(&i2c->lock, flags);\n\n\ttimeout = wait_for_completion_timeout(&i2c->done, timeout);\n\tdc_i2c_set_irq(i2c, 0);\n\tif (timeout == 0) {\n\t\ti2c->state = STATE_IDLE;\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tif (i2c->error)\n\t\treturn i2c->error;\n\n\treturn 0;\n}\n\nstatic int dc_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)\n{\n\tstruct dc_i2c *i2c = adap->algo_data;\n\tint i, ret;\n\n\tfor (i = 0; i < num; i++) {\n\t\tret = dc_i2c_xfer_msg(i2c, &msgs[i], i == 0, i == num - 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn num;\n}\n\nstatic int dc_i2c_init_hw(struct dc_i2c *i2c)\n{\n\tunsigned long clk_rate = clk_get_rate(i2c->clk);\n\tunsigned int clocktime;\n\n\twriteb_relaxed(II_CONTROL_LOCAL_RESET, i2c->regs + II_CONTROL);\n\tudelay(100);\n\twriteb_relaxed(0, i2c->regs + II_CONTROL);\n\tudelay(100);\n\n\tclocktime = DIV_ROUND_UP(clk_rate, 64 * i2c->frequency);\n\tif (clocktime < 1 || clocktime > 0xff) {\n\t\tdev_err(i2c->dev, \"can't set bus speed of %u Hz\\n\",\n\t\t\ti2c->frequency);\n\t\treturn -EINVAL;\n\t}\n\twriteb_relaxed(clocktime - 1, i2c->regs + II_CLOCKTIME);\n\n\treturn 0;\n}\n\nstatic u32 dc_i2c_func(struct i2c_adapter *adap)\n{\n\treturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL | I2C_FUNC_NOSTART;\n}\n\nstatic const struct i2c_algorithm dc_i2c_algorithm = {\n\t.master_xfer\t= dc_i2c_xfer,\n\t.functionality\t= dc_i2c_func,\n};\n\nstatic int dc_i2c_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct dc_i2c *i2c;\n\tint ret = 0, irq;\n\n\ti2c = devm_kzalloc(&pdev->dev, sizeof(struct dc_i2c), GFP_KERNEL);\n\tif (!i2c)\n\t\treturn -ENOMEM;\n\n\tif (of_property_read_u32(pdev->dev.of_node, \"clock-frequency\",\n\t\t\t\t &i2c->frequency))\n\t\ti2c->frequency = I2C_MAX_STANDARD_MODE_FREQ;\n\n\ti2c->dev = &pdev->dev;\n\tplatform_set_drvdata(pdev, i2c);\n\n\tspin_lock_init(&i2c->lock);\n\tinit_completion(&i2c->done);\n\n\ti2c->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(i2c->clk))\n\t\treturn PTR_ERR(i2c->clk);\n\n\ti2c->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(i2c->regs))\n\t\treturn PTR_ERR(i2c->regs);\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tret = devm_request_irq(&pdev->dev, irq, dc_i2c_irq, 0,\n\t\t\t       dev_name(&pdev->dev), i2c);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tstrscpy(i2c->adap.name, \"Conexant Digicolor I2C adapter\",\n\t\tsizeof(i2c->adap.name));\n\ti2c->adap.owner = THIS_MODULE;\n\ti2c->adap.algo = &dc_i2c_algorithm;\n\ti2c->adap.dev.parent = &pdev->dev;\n\ti2c->adap.dev.of_node = np;\n\ti2c->adap.algo_data = i2c;\n\n\tret = dc_i2c_init_hw(i2c);\n\tif (ret)\n\t\treturn ret;\n\n\tret = clk_prepare_enable(i2c->clk);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = i2c_add_adapter(&i2c->adap);\n\tif (ret < 0) {\n\t\tclk_disable_unprepare(i2c->clk);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void dc_i2c_remove(struct platform_device *pdev)\n{\n\tstruct dc_i2c *i2c = platform_get_drvdata(pdev);\n\n\ti2c_del_adapter(&i2c->adap);\n\tclk_disable_unprepare(i2c->clk);\n}\n\nstatic const struct of_device_id dc_i2c_match[] = {\n\t{ .compatible = \"cnxt,cx92755-i2c\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, dc_i2c_match);\n\nstatic struct platform_driver dc_i2c_driver = {\n\t.probe   = dc_i2c_probe,\n\t.remove_new = dc_i2c_remove,\n\t.driver  = {\n\t\t.name  = \"digicolor-i2c\",\n\t\t.of_match_table = dc_i2c_match,\n\t},\n};\nmodule_platform_driver(dc_i2c_driver);\n\nMODULE_AUTHOR(\"Baruch Siach <baruch@tkos.co.il>\");\nMODULE_DESCRIPTION(\"Conexant Digicolor I2C master driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}