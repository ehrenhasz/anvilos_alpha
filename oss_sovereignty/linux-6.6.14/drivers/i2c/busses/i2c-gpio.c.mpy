{
  "module_name": "i2c-gpio.c",
  "hash_id": "143430e42f7063d0bb052b26116f31bf962463cacf72fe50d23c14fc86f98ca5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-gpio.c",
  "human_readable_source": "\n \n#include <linux/completion.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c-algo-bit.h>\n#include <linux/i2c.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/platform_data/i2c-gpio.h>\n#include <linux/platform_device.h>\n#include <linux/property.h>\n#include <linux/slab.h>\n\nstruct i2c_gpio_private_data {\n\tstruct gpio_desc *sda;\n\tstruct gpio_desc *scl;\n\tstruct i2c_adapter adap;\n\tstruct i2c_algo_bit_data bit_data;\n\tstruct i2c_gpio_platform_data pdata;\n#ifdef CONFIG_I2C_GPIO_FAULT_INJECTOR\n\tstruct dentry *debug_dir;\n\t \n\tstruct completion scl_irq_completion;\n\tu64 scl_irq_data;\n#endif\n};\n\n \nstatic void i2c_gpio_setsda_val(void *data, int state)\n{\n\tstruct i2c_gpio_private_data *priv = data;\n\n\tgpiod_set_value_cansleep(priv->sda, state);\n}\n\n \nstatic void i2c_gpio_setscl_val(void *data, int state)\n{\n\tstruct i2c_gpio_private_data *priv = data;\n\n\tgpiod_set_value_cansleep(priv->scl, state);\n}\n\nstatic int i2c_gpio_getsda(void *data)\n{\n\tstruct i2c_gpio_private_data *priv = data;\n\n\treturn gpiod_get_value_cansleep(priv->sda);\n}\n\nstatic int i2c_gpio_getscl(void *data)\n{\n\tstruct i2c_gpio_private_data *priv = data;\n\n\treturn gpiod_get_value_cansleep(priv->scl);\n}\n\n#ifdef CONFIG_I2C_GPIO_FAULT_INJECTOR\nstatic struct dentry *i2c_gpio_debug_dir;\n\n#define setsda(bd, val)\t((bd)->setsda((bd)->data, val))\n#define setscl(bd, val)\t((bd)->setscl((bd)->data, val))\n#define getsda(bd)\t((bd)->getsda((bd)->data))\n#define getscl(bd)\t((bd)->getscl((bd)->data))\n\n#define WIRE_ATTRIBUTE(wire) \\\nstatic int fops_##wire##_get(void *data, u64 *val)\t\t\\\n{\t\t\t\t\t\t\t\t\\\n\tstruct i2c_gpio_private_data *priv = data;\t\t\\\n\t\t\t\t\t\t\t\t\\\n\ti2c_lock_bus(&priv->adap, I2C_LOCK_ROOT_ADAPTER);\t\\\n\t*val = get##wire(&priv->bit_data);\t\t\t\\\n\ti2c_unlock_bus(&priv->adap, I2C_LOCK_ROOT_ADAPTER);\t\\\n\treturn 0;\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\\\nstatic int fops_##wire##_set(void *data, u64 val)\t\t\\\n{\t\t\t\t\t\t\t\t\\\n\tstruct i2c_gpio_private_data *priv = data;\t\t\\\n\t\t\t\t\t\t\t\t\\\n\ti2c_lock_bus(&priv->adap, I2C_LOCK_ROOT_ADAPTER);\t\\\n\tset##wire(&priv->bit_data, val);\t\t\t\\\n\ti2c_unlock_bus(&priv->adap, I2C_LOCK_ROOT_ADAPTER);\t\\\n\treturn 0;\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\\\nDEFINE_DEBUGFS_ATTRIBUTE(fops_##wire, fops_##wire##_get, fops_##wire##_set, \"%llu\\n\")\n\nWIRE_ATTRIBUTE(scl);\nWIRE_ATTRIBUTE(sda);\n\nstatic void i2c_gpio_incomplete_transfer(struct i2c_gpio_private_data *priv,\n\t\t\t\t\tu32 pattern, u8 pattern_size)\n{\n\tstruct i2c_algo_bit_data *bit_data = &priv->bit_data;\n\tint i;\n\n\ti2c_lock_bus(&priv->adap, I2C_LOCK_ROOT_ADAPTER);\n\n\t \n\tsetsda(bit_data, 0);\n\tudelay(bit_data->udelay);\n\n\t \n\tfor (i = pattern_size - 1; i >= 0; i--) {\n\t\tsetscl(bit_data, 0);\n\t\tudelay(bit_data->udelay / 2);\n\t\tsetsda(bit_data, (pattern >> i) & 1);\n\t\tudelay((bit_data->udelay + 1) / 2);\n\t\tsetscl(bit_data, 1);\n\t\tudelay(bit_data->udelay);\n\t}\n\n\ti2c_unlock_bus(&priv->adap, I2C_LOCK_ROOT_ADAPTER);\n}\n\nstatic int fops_incomplete_addr_phase_set(void *data, u64 addr)\n{\n\tstruct i2c_gpio_private_data *priv = data;\n\tu32 pattern;\n\n\tif (addr > 0x7f)\n\t\treturn -EINVAL;\n\n\t \n\tpattern = (addr << 2) | 3;\n\n\ti2c_gpio_incomplete_transfer(priv, pattern, 9);\n\n\treturn 0;\n}\nDEFINE_DEBUGFS_ATTRIBUTE(fops_incomplete_addr_phase, NULL, fops_incomplete_addr_phase_set, \"%llu\\n\");\n\nstatic int fops_incomplete_write_byte_set(void *data, u64 addr)\n{\n\tstruct i2c_gpio_private_data *priv = data;\n\tu32 pattern;\n\n\tif (addr > 0x7f)\n\t\treturn -EINVAL;\n\n\t \n\tpattern = (addr << 2) | 1;\n\t \n\tpattern = (pattern << 9) | 1;\n\n\ti2c_gpio_incomplete_transfer(priv, pattern, 18);\n\n\treturn 0;\n}\nDEFINE_DEBUGFS_ATTRIBUTE(fops_incomplete_write_byte, NULL, fops_incomplete_write_byte_set, \"%llu\\n\");\n\nstatic int i2c_gpio_fi_act_on_scl_irq(struct i2c_gpio_private_data *priv,\n\t\t\t\t       irqreturn_t handler(int, void*))\n{\n\tint ret, irq = gpiod_to_irq(priv->scl);\n\n\tif (irq < 0)\n\t\treturn irq;\n\n\ti2c_lock_bus(&priv->adap, I2C_LOCK_ROOT_ADAPTER);\n\n\tret = gpiod_direction_input(priv->scl);\n\tif (ret)\n\t\tgoto unlock;\n\n\treinit_completion(&priv->scl_irq_completion);\n\n\tret = request_irq(irq, handler, IRQF_TRIGGER_FALLING,\n\t\t\t  \"i2c_gpio_fault_injector_scl_irq\", priv);\n\tif (ret)\n\t\tgoto output;\n\n\twait_for_completion_interruptible(&priv->scl_irq_completion);\n\n\tfree_irq(irq, priv);\n output:\n\tret = gpiod_direction_output(priv->scl, 1) ?: ret;\n unlock:\n\ti2c_unlock_bus(&priv->adap, I2C_LOCK_ROOT_ADAPTER);\n\n\treturn ret;\n}\n\nstatic irqreturn_t lose_arbitration_irq(int irq, void *dev_id)\n{\n\tstruct i2c_gpio_private_data *priv = dev_id;\n\n\tsetsda(&priv->bit_data, 0);\n\tudelay(priv->scl_irq_data);\n\tsetsda(&priv->bit_data, 1);\n\n\tcomplete(&priv->scl_irq_completion);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int fops_lose_arbitration_set(void *data, u64 duration)\n{\n\tstruct i2c_gpio_private_data *priv = data;\n\n\tif (duration > 100 * 1000)\n\t\treturn -EINVAL;\n\n\tpriv->scl_irq_data = duration;\n\t \n\treturn i2c_gpio_fi_act_on_scl_irq(priv, lose_arbitration_irq);\n}\nDEFINE_DEBUGFS_ATTRIBUTE(fops_lose_arbitration, NULL, fops_lose_arbitration_set, \"%llu\\n\");\n\nstatic irqreturn_t inject_panic_irq(int irq, void *dev_id)\n{\n\tstruct i2c_gpio_private_data *priv = dev_id;\n\n\tudelay(priv->scl_irq_data);\n\tpanic(\"I2C fault injector induced panic\");\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int fops_inject_panic_set(void *data, u64 duration)\n{\n\tstruct i2c_gpio_private_data *priv = data;\n\n\tif (duration > 100 * 1000)\n\t\treturn -EINVAL;\n\n\tpriv->scl_irq_data = duration;\n\t \n\treturn i2c_gpio_fi_act_on_scl_irq(priv, inject_panic_irq);\n}\nDEFINE_DEBUGFS_ATTRIBUTE(fops_inject_panic, NULL, fops_inject_panic_set, \"%llu\\n\");\n\nstatic void i2c_gpio_fault_injector_init(struct platform_device *pdev)\n{\n\tstruct i2c_gpio_private_data *priv = platform_get_drvdata(pdev);\n\n\t \n\tif (!i2c_gpio_debug_dir) {\n\t\ti2c_gpio_debug_dir = debugfs_create_dir(\"i2c-fault-injector\", NULL);\n\t\tif (!i2c_gpio_debug_dir)\n\t\t\treturn;\n\t}\n\n\tpriv->debug_dir = debugfs_create_dir(pdev->name, i2c_gpio_debug_dir);\n\tif (!priv->debug_dir)\n\t\treturn;\n\n\tinit_completion(&priv->scl_irq_completion);\n\n\tdebugfs_create_file_unsafe(\"incomplete_address_phase\", 0200, priv->debug_dir,\n\t\t\t\t   priv, &fops_incomplete_addr_phase);\n\tdebugfs_create_file_unsafe(\"incomplete_write_byte\", 0200, priv->debug_dir,\n\t\t\t\t   priv, &fops_incomplete_write_byte);\n\tif (priv->bit_data.getscl) {\n\t\tdebugfs_create_file_unsafe(\"inject_panic\", 0200, priv->debug_dir,\n\t\t\t\t\t   priv, &fops_inject_panic);\n\t\tdebugfs_create_file_unsafe(\"lose_arbitration\", 0200, priv->debug_dir,\n\t\t\t\t\t   priv, &fops_lose_arbitration);\n\t}\n\tdebugfs_create_file_unsafe(\"scl\", 0600, priv->debug_dir, priv, &fops_scl);\n\tdebugfs_create_file_unsafe(\"sda\", 0600, priv->debug_dir, priv, &fops_sda);\n}\n\nstatic void i2c_gpio_fault_injector_exit(struct platform_device *pdev)\n{\n\tstruct i2c_gpio_private_data *priv = platform_get_drvdata(pdev);\n\n\tdebugfs_remove_recursive(priv->debug_dir);\n}\n#else\nstatic inline void i2c_gpio_fault_injector_init(struct platform_device *pdev) {}\nstatic inline void i2c_gpio_fault_injector_exit(struct platform_device *pdev) {}\n#endif  \n\n \nstatic void i2c_gpio_get_properties(struct device *dev,\n\t\t\t\t    struct i2c_gpio_platform_data *pdata)\n{\n\tu32 reg;\n\n\tdevice_property_read_u32(dev, \"i2c-gpio,delay-us\", &pdata->udelay);\n\n\tif (!device_property_read_u32(dev, \"i2c-gpio,timeout-ms\", &reg))\n\t\tpdata->timeout = msecs_to_jiffies(reg);\n\n\tpdata->sda_is_open_drain =\n\t\tdevice_property_read_bool(dev, \"i2c-gpio,sda-open-drain\");\n\tpdata->scl_is_open_drain =\n\t\tdevice_property_read_bool(dev, \"i2c-gpio,scl-open-drain\");\n\tpdata->scl_is_output_only =\n\t\tdevice_property_read_bool(dev, \"i2c-gpio,scl-output-only\");\n\tpdata->sda_is_output_only =\n\t\tdevice_property_read_bool(dev, \"i2c-gpio,sda-output-only\");\n\tpdata->sda_has_no_pullup =\n\t\tdevice_property_read_bool(dev, \"i2c-gpio,sda-has-no-pullup\");\n\tpdata->scl_has_no_pullup =\n\t\tdevice_property_read_bool(dev, \"i2c-gpio,scl-has-no-pullup\");\n}\n\nstatic struct gpio_desc *i2c_gpio_get_desc(struct device *dev,\n\t\t\t\t\t   const char *con_id,\n\t\t\t\t\t   unsigned int index,\n\t\t\t\t\t   enum gpiod_flags gflags)\n{\n\tstruct gpio_desc *retdesc;\n\tint ret;\n\n\tretdesc = devm_gpiod_get(dev, con_id, gflags);\n\tif (!IS_ERR(retdesc)) {\n\t\tdev_dbg(dev, \"got GPIO from name %s\\n\", con_id);\n\t\treturn retdesc;\n\t}\n\n\tretdesc = devm_gpiod_get_index(dev, NULL, index, gflags);\n\tif (!IS_ERR(retdesc)) {\n\t\tdev_dbg(dev, \"got GPIO from index %u\\n\", index);\n\t\treturn retdesc;\n\t}\n\n\tret = PTR_ERR(retdesc);\n\n\t \n\tif (ret == -EINVAL)\n\t\tretdesc = ERR_PTR(-EPROBE_DEFER);\n\n\t \n\tif (ret == -ENOENT)\n\t\tretdesc = ERR_PTR(-EPROBE_DEFER);\n\n\tif (PTR_ERR(retdesc) != -EPROBE_DEFER)\n\t\tdev_err(dev, \"error trying to get descriptor: %d\\n\", ret);\n\n\treturn retdesc;\n}\n\nstatic int i2c_gpio_probe(struct platform_device *pdev)\n{\n\tstruct i2c_gpio_private_data *priv;\n\tstruct i2c_gpio_platform_data *pdata;\n\tstruct i2c_algo_bit_data *bit_data;\n\tstruct i2c_adapter *adap;\n\tstruct device *dev = &pdev->dev;\n\tstruct fwnode_handle *fwnode = dev_fwnode(dev);\n\tenum gpiod_flags gflags;\n\tint ret;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tadap = &priv->adap;\n\tbit_data = &priv->bit_data;\n\tpdata = &priv->pdata;\n\n\tif (fwnode) {\n\t\ti2c_gpio_get_properties(dev, pdata);\n\t} else {\n\t\t \n\t\tif (dev_get_platdata(dev))\n\t\t\tmemcpy(pdata, dev_get_platdata(dev), sizeof(*pdata));\n\t}\n\n\t \n\tif (pdata->sda_is_open_drain || pdata->sda_has_no_pullup)\n\t\tgflags = GPIOD_OUT_HIGH;\n\telse\n\t\tgflags = GPIOD_OUT_HIGH_OPEN_DRAIN;\n\tpriv->sda = i2c_gpio_get_desc(dev, \"sda\", 0, gflags);\n\tif (IS_ERR(priv->sda))\n\t\treturn PTR_ERR(priv->sda);\n\n\tif (pdata->scl_is_open_drain || pdata->scl_has_no_pullup)\n\t\tgflags = GPIOD_OUT_HIGH;\n\telse\n\t\tgflags = GPIOD_OUT_HIGH_OPEN_DRAIN;\n\tpriv->scl = i2c_gpio_get_desc(dev, \"scl\", 1, gflags);\n\tif (IS_ERR(priv->scl))\n\t\treturn PTR_ERR(priv->scl);\n\n\tif (gpiod_cansleep(priv->sda) || gpiod_cansleep(priv->scl))\n\t\tdev_warn(dev, \"Slow GPIO pins might wreak havoc into I2C/SMBus bus timing\");\n\telse\n\t\tbit_data->can_do_atomic = true;\n\n\tbit_data->setsda = i2c_gpio_setsda_val;\n\tbit_data->setscl = i2c_gpio_setscl_val;\n\n\tif (!pdata->scl_is_output_only)\n\t\tbit_data->getscl = i2c_gpio_getscl;\n\tif (!pdata->sda_is_output_only)\n\t\tbit_data->getsda = i2c_gpio_getsda;\n\n\tif (pdata->udelay)\n\t\tbit_data->udelay = pdata->udelay;\n\telse if (pdata->scl_is_output_only)\n\t\tbit_data->udelay = 50;\t\t\t \n\telse\n\t\tbit_data->udelay = 5;\t\t\t \n\n\tif (pdata->timeout)\n\t\tbit_data->timeout = pdata->timeout;\n\telse\n\t\tbit_data->timeout = HZ / 10;\t\t \n\n\tbit_data->data = priv;\n\n\tadap->owner = THIS_MODULE;\n\tif (fwnode)\n\t\tstrscpy(adap->name, dev_name(dev), sizeof(adap->name));\n\telse\n\t\tsnprintf(adap->name, sizeof(adap->name), \"i2c-gpio%d\", pdev->id);\n\n\tadap->algo_data = bit_data;\n\tadap->class = I2C_CLASS_HWMON | I2C_CLASS_SPD;\n\tadap->dev.parent = dev;\n\tdevice_set_node(&adap->dev, fwnode);\n\n\tadap->nr = pdev->id;\n\tret = i2c_bit_add_numbered_bus(adap);\n\tif (ret)\n\t\treturn ret;\n\n\tplatform_set_drvdata(pdev, priv);\n\n\t \n\tdev_info(dev, \"using lines %u (SDA) and %u (SCL%s)\\n\",\n\t\t desc_to_gpio(priv->sda), desc_to_gpio(priv->scl),\n\t\t pdata->scl_is_output_only\n\t\t ? \", no clock stretching\" : \"\");\n\n\ti2c_gpio_fault_injector_init(pdev);\n\n\treturn 0;\n}\n\nstatic void i2c_gpio_remove(struct platform_device *pdev)\n{\n\tstruct i2c_gpio_private_data *priv;\n\tstruct i2c_adapter *adap;\n\n\ti2c_gpio_fault_injector_exit(pdev);\n\n\tpriv = platform_get_drvdata(pdev);\n\tadap = &priv->adap;\n\n\ti2c_del_adapter(adap);\n}\n\nstatic const struct of_device_id i2c_gpio_dt_ids[] = {\n\t{ .compatible = \"i2c-gpio\", },\n\t{   }\n};\n\nMODULE_DEVICE_TABLE(of, i2c_gpio_dt_ids);\n\nstatic const struct acpi_device_id i2c_gpio_acpi_match[] = {\n\t{ \"LOON0005\" },  \n\t{ }\n};\nMODULE_DEVICE_TABLE(acpi, i2c_gpio_acpi_match);\n\nstatic struct platform_driver i2c_gpio_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"i2c-gpio\",\n\t\t.of_match_table\t= i2c_gpio_dt_ids,\n\t\t.acpi_match_table = i2c_gpio_acpi_match,\n\t},\n\t.probe\t\t= i2c_gpio_probe,\n\t.remove_new\t= i2c_gpio_remove,\n};\n\nstatic int __init i2c_gpio_init(void)\n{\n\tint ret;\n\n\tret = platform_driver_register(&i2c_gpio_driver);\n\tif (ret)\n\t\tprintk(KERN_ERR \"i2c-gpio: probe failed: %d\\n\", ret);\n\n\treturn ret;\n}\nsubsys_initcall(i2c_gpio_init);\n\nstatic void __exit i2c_gpio_exit(void)\n{\n\tplatform_driver_unregister(&i2c_gpio_driver);\n}\nmodule_exit(i2c_gpio_exit);\n\nMODULE_AUTHOR(\"Haavard Skinnemoen (Atmel)\");\nMODULE_DESCRIPTION(\"Platform-independent bitbanging I2C driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:i2c-gpio\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}