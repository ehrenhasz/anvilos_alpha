{
  "module_name": "i2c-hisi.c",
  "hash_id": "8b78cb53d06293e963f5b87bbc72531e33539ab1f24c5a826cdd21055e8e3e76",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-hisi.c",
  "human_readable_source": "\n \n\n#include <linux/bits.h>\n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/completion.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/platform_device.h>\n#include <linux/property.h>\n#include <linux/units.h>\n\n#define HISI_I2C_FRAME_CTRL\t\t0x0000\n#define   HISI_I2C_FRAME_CTRL_SPEED_MODE\tGENMASK(1, 0)\n#define   HISI_I2C_FRAME_CTRL_ADDR_TEN\tBIT(2)\n#define HISI_I2C_SLV_ADDR\t\t0x0004\n#define   HISI_I2C_SLV_ADDR_VAL\t\tGENMASK(9, 0)\n#define   HISI_I2C_SLV_ADDR_GC_S_MODE\tBIT(10)\n#define   HISI_I2C_SLV_ADDR_GC_S_EN\tBIT(11)\n#define HISI_I2C_CMD_TXDATA\t\t0x0008\n#define   HISI_I2C_CMD_TXDATA_DATA\tGENMASK(7, 0)\n#define   HISI_I2C_CMD_TXDATA_RW\tBIT(8)\n#define   HISI_I2C_CMD_TXDATA_P_EN\tBIT(9)\n#define   HISI_I2C_CMD_TXDATA_SR_EN\tBIT(10)\n#define HISI_I2C_RXDATA\t\t\t0x000c\n#define   HISI_I2C_RXDATA_DATA\t\tGENMASK(7, 0)\n#define HISI_I2C_SS_SCL_HCNT\t\t0x0010\n#define HISI_I2C_SS_SCL_LCNT\t\t0x0014\n#define HISI_I2C_FS_SCL_HCNT\t\t0x0018\n#define HISI_I2C_FS_SCL_LCNT\t\t0x001c\n#define HISI_I2C_HS_SCL_HCNT\t\t0x0020\n#define HISI_I2C_HS_SCL_LCNT\t\t0x0024\n#define HISI_I2C_FIFO_CTRL\t\t0x0028\n#define   HISI_I2C_FIFO_RX_CLR\t\tBIT(0)\n#define   HISI_I2C_FIFO_TX_CLR\t\tBIT(1)\n#define   HISI_I2C_FIFO_RX_AF_THRESH\tGENMASK(7, 2)\n#define   HISI_I2C_FIFO_TX_AE_THRESH\tGENMASK(13, 8)\n#define HISI_I2C_FIFO_STATE\t\t0x002c\n#define   HISI_I2C_FIFO_STATE_RX_RERR\tBIT(0)\n#define   HISI_I2C_FIFO_STATE_RX_WERR\tBIT(1)\n#define   HISI_I2C_FIFO_STATE_RX_EMPTY\tBIT(3)\n#define   HISI_I2C_FIFO_STATE_TX_RERR\tBIT(6)\n#define   HISI_I2C_FIFO_STATE_TX_WERR\tBIT(7)\n#define   HISI_I2C_FIFO_STATE_TX_FULL\tBIT(11)\n#define HISI_I2C_SDA_HOLD\t\t0x0030\n#define   HISI_I2C_SDA_HOLD_TX\t\tGENMASK(15, 0)\n#define   HISI_I2C_SDA_HOLD_RX\t\tGENMASK(23, 16)\n#define HISI_I2C_FS_SPK_LEN\t\t0x0038\n#define   HISI_I2C_FS_SPK_LEN_CNT\tGENMASK(7, 0)\n#define HISI_I2C_HS_SPK_LEN\t\t0x003c\n#define   HISI_I2C_HS_SPK_LEN_CNT\tGENMASK(7, 0)\n#define HISI_I2C_INT_MSTAT\t\t0x0044\n#define HISI_I2C_INT_CLR\t\t0x0048\n#define HISI_I2C_INT_MASK\t\t0x004C\n#define HISI_I2C_TRANS_STATE\t\t0x0050\n#define HISI_I2C_TRANS_ERR\t\t0x0054\n#define HISI_I2C_VERSION\t\t0x0058\n\n#define HISI_I2C_INT_ALL\tGENMASK(4, 0)\n#define HISI_I2C_INT_TRANS_CPLT\tBIT(0)\n#define HISI_I2C_INT_TRANS_ERR\tBIT(1)\n#define HISI_I2C_INT_FIFO_ERR\tBIT(2)\n#define HISI_I2C_INT_RX_FULL\tBIT(3)\n#define HISI_I2C_INT_TX_EMPTY\tBIT(4)\n#define HISI_I2C_INT_ERR \\\n\t(HISI_I2C_INT_TRANS_ERR | HISI_I2C_INT_FIFO_ERR)\n\n#define HISI_I2C_STD_SPEED_MODE\t\t0\n#define HISI_I2C_FAST_SPEED_MODE\t1\n#define HISI_I2C_HIGH_SPEED_MODE\t2\n\n#define HISI_I2C_TX_FIFO_DEPTH\t\t64\n#define HISI_I2C_RX_FIFO_DEPTH\t\t64\n#define HISI_I2C_TX_F_AE_THRESH\t\t1\n#define HISI_I2C_RX_F_AF_THRESH\t\t60\n\n#define NSEC_TO_CYCLES(ns, clk_rate_khz) \\\n\tDIV_ROUND_UP_ULL((clk_rate_khz) * (ns), NSEC_PER_MSEC)\n\nstruct hisi_i2c_controller {\n\tstruct i2c_adapter adapter;\n\tvoid __iomem *iobase;\n\tstruct device *dev;\n\tstruct clk *clk;\n\tint irq;\n\n\t \n\tstruct completion *completion;\n\tstruct i2c_msg *msgs;\n\tint msg_num;\n\tint msg_tx_idx;\n\tint buf_tx_idx;\n\tint msg_rx_idx;\n\tint buf_rx_idx;\n\tu16 tar_addr;\n\tu32 xfer_err;\n\n\t \n\tstruct i2c_timings t;\n\tu32 clk_rate_khz;\n\tu32 spk_len;\n};\n\nstatic void hisi_i2c_enable_int(struct hisi_i2c_controller *ctlr, u32 mask)\n{\n\twritel_relaxed(mask, ctlr->iobase + HISI_I2C_INT_MASK);\n}\n\nstatic void hisi_i2c_disable_int(struct hisi_i2c_controller *ctlr, u32 mask)\n{\n\twritel_relaxed((~mask) & HISI_I2C_INT_ALL, ctlr->iobase + HISI_I2C_INT_MASK);\n}\n\nstatic void hisi_i2c_clear_int(struct hisi_i2c_controller *ctlr, u32 mask)\n{\n\twritel_relaxed(mask, ctlr->iobase + HISI_I2C_INT_CLR);\n}\n\nstatic void hisi_i2c_handle_errors(struct hisi_i2c_controller *ctlr)\n{\n\tu32 int_err = ctlr->xfer_err, reg;\n\n\tif (int_err & HISI_I2C_INT_FIFO_ERR) {\n\t\treg = readl(ctlr->iobase + HISI_I2C_FIFO_STATE);\n\n\t\tif (reg & HISI_I2C_FIFO_STATE_RX_RERR)\n\t\t\tdev_err(ctlr->dev, \"rx fifo error read\\n\");\n\n\t\tif (reg & HISI_I2C_FIFO_STATE_RX_WERR)\n\t\t\tdev_err(ctlr->dev, \"rx fifo error write\\n\");\n\n\t\tif (reg & HISI_I2C_FIFO_STATE_TX_RERR)\n\t\t\tdev_err(ctlr->dev, \"tx fifo error read\\n\");\n\n\t\tif (reg & HISI_I2C_FIFO_STATE_TX_WERR)\n\t\t\tdev_err(ctlr->dev, \"tx fifo error write\\n\");\n\t}\n}\n\nstatic int hisi_i2c_start_xfer(struct hisi_i2c_controller *ctlr)\n{\n\tstruct i2c_msg *msg = ctlr->msgs;\n\tu32 reg;\n\n\treg = readl(ctlr->iobase + HISI_I2C_FRAME_CTRL);\n\treg &= ~HISI_I2C_FRAME_CTRL_ADDR_TEN;\n\tif (msg->flags & I2C_M_TEN)\n\t\treg |= HISI_I2C_FRAME_CTRL_ADDR_TEN;\n\twritel(reg, ctlr->iobase + HISI_I2C_FRAME_CTRL);\n\n\treg = readl(ctlr->iobase + HISI_I2C_SLV_ADDR);\n\treg &= ~HISI_I2C_SLV_ADDR_VAL;\n\treg |= FIELD_PREP(HISI_I2C_SLV_ADDR_VAL, msg->addr);\n\twritel(reg, ctlr->iobase + HISI_I2C_SLV_ADDR);\n\n\treg = readl(ctlr->iobase + HISI_I2C_FIFO_CTRL);\n\treg |= HISI_I2C_FIFO_RX_CLR | HISI_I2C_FIFO_TX_CLR;\n\twritel(reg, ctlr->iobase + HISI_I2C_FIFO_CTRL);\n\treg &= ~(HISI_I2C_FIFO_RX_CLR | HISI_I2C_FIFO_TX_CLR);\n\twritel(reg, ctlr->iobase + HISI_I2C_FIFO_CTRL);\n\n\thisi_i2c_clear_int(ctlr, HISI_I2C_INT_ALL);\n\thisi_i2c_enable_int(ctlr, HISI_I2C_INT_ALL);\n\n\treturn 0;\n}\n\nstatic void hisi_i2c_reset_xfer(struct hisi_i2c_controller *ctlr)\n{\n\tctlr->msg_num = 0;\n\tctlr->xfer_err = 0;\n\tctlr->msg_tx_idx = 0;\n\tctlr->msg_rx_idx = 0;\n\tctlr->buf_tx_idx = 0;\n\tctlr->buf_rx_idx = 0;\n}\n\n \nstatic int hisi_i2c_master_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs,\n\t\t\t\tint num)\n{\n\tstruct hisi_i2c_controller *ctlr = i2c_get_adapdata(adap);\n\tDECLARE_COMPLETION_ONSTACK(done);\n\tint ret = num;\n\n\thisi_i2c_reset_xfer(ctlr);\n\tctlr->completion = &done;\n\tctlr->msg_num = num;\n\tctlr->msgs = msgs;\n\n\thisi_i2c_start_xfer(ctlr);\n\n\tif (!wait_for_completion_timeout(ctlr->completion, adap->timeout)) {\n\t\thisi_i2c_disable_int(ctlr, HISI_I2C_INT_ALL);\n\t\tsynchronize_irq(ctlr->irq);\n\t\ti2c_recover_bus(&ctlr->adapter);\n\t\tdev_err(ctlr->dev, \"bus transfer timeout\\n\");\n\t\tret = -EIO;\n\t}\n\n\tif (ctlr->xfer_err) {\n\t\thisi_i2c_handle_errors(ctlr);\n\t\tret = -EIO;\n\t}\n\n\thisi_i2c_reset_xfer(ctlr);\n\tctlr->completion = NULL;\n\n\treturn ret;\n}\n\nstatic u32 hisi_i2c_functionality(struct i2c_adapter *adap)\n{\n\treturn I2C_FUNC_I2C | I2C_FUNC_10BIT_ADDR | I2C_FUNC_SMBUS_EMUL;\n}\n\nstatic const struct i2c_algorithm hisi_i2c_algo = {\n\t.master_xfer\t= hisi_i2c_master_xfer,\n\t.functionality\t= hisi_i2c_functionality,\n};\n\nstatic int hisi_i2c_read_rx_fifo(struct hisi_i2c_controller *ctlr)\n{\n\tstruct i2c_msg *cur_msg;\n\tu32 fifo_state;\n\n\twhile (ctlr->msg_rx_idx < ctlr->msg_num) {\n\t\tcur_msg = ctlr->msgs + ctlr->msg_rx_idx;\n\n\t\tif (!(cur_msg->flags & I2C_M_RD)) {\n\t\t\tctlr->msg_rx_idx++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tfifo_state = readl(ctlr->iobase + HISI_I2C_FIFO_STATE);\n\t\twhile (!(fifo_state & HISI_I2C_FIFO_STATE_RX_EMPTY) &&\n\t\t       ctlr->buf_rx_idx < cur_msg->len) {\n\t\t\tcur_msg->buf[ctlr->buf_rx_idx++] = readl(ctlr->iobase + HISI_I2C_RXDATA);\n\t\t\tfifo_state = readl(ctlr->iobase + HISI_I2C_FIFO_STATE);\n\t\t}\n\n\t\tif (ctlr->buf_rx_idx == cur_msg->len) {\n\t\t\tctlr->buf_rx_idx = 0;\n\t\t\tctlr->msg_rx_idx++;\n\t\t}\n\n\t\tif (fifo_state & HISI_I2C_FIFO_STATE_RX_EMPTY)\n\t\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic void hisi_i2c_xfer_msg(struct hisi_i2c_controller *ctlr)\n{\n\tint max_write = HISI_I2C_TX_FIFO_DEPTH;\n\tbool need_restart = false, last_msg;\n\tstruct i2c_msg *cur_msg;\n\tu32 cmd, fifo_state;\n\n\twhile (ctlr->msg_tx_idx < ctlr->msg_num) {\n\t\tcur_msg = ctlr->msgs + ctlr->msg_tx_idx;\n\t\tlast_msg = (ctlr->msg_tx_idx == ctlr->msg_num - 1);\n\n\t\t \n\t\tif (ctlr->msg_tx_idx && !ctlr->buf_tx_idx)\n\t\t\tneed_restart = true;\n\n\t\tfifo_state = readl(ctlr->iobase + HISI_I2C_FIFO_STATE);\n\t\twhile (!(fifo_state & HISI_I2C_FIFO_STATE_TX_FULL) &&\n\t\t       ctlr->buf_tx_idx < cur_msg->len && max_write) {\n\t\t\tcmd = 0;\n\n\t\t\tif (need_restart) {\n\t\t\t\tcmd |= HISI_I2C_CMD_TXDATA_SR_EN;\n\t\t\t\tneed_restart = false;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (ctlr->buf_tx_idx == cur_msg->len - 1 && last_msg)\n\t\t\t\tcmd |= HISI_I2C_CMD_TXDATA_P_EN;\n\n\t\t\tif (cur_msg->flags & I2C_M_RD)\n\t\t\t\tcmd |= HISI_I2C_CMD_TXDATA_RW;\n\t\t\telse\n\t\t\t\tcmd |= FIELD_PREP(HISI_I2C_CMD_TXDATA_DATA,\n\t\t\t\t\t\t  cur_msg->buf[ctlr->buf_tx_idx]);\n\n\t\t\twritel(cmd, ctlr->iobase + HISI_I2C_CMD_TXDATA);\n\t\t\tctlr->buf_tx_idx++;\n\t\t\tmax_write--;\n\n\t\t\tfifo_state = readl(ctlr->iobase + HISI_I2C_FIFO_STATE);\n\t\t}\n\n\t\t \n\t\tif (ctlr->buf_tx_idx == cur_msg->len) {\n\t\t\tctlr->buf_tx_idx = 0;\n\t\t\tctlr->msg_tx_idx++;\n\t\t}\n\n\t\tif ((fifo_state & HISI_I2C_FIFO_STATE_TX_FULL) ||\n\t\t    max_write == 0)\n\t\t\tbreak;\n\t}\n\n\t \n\tif (ctlr->msg_tx_idx == ctlr->msg_num)\n\t\thisi_i2c_disable_int(ctlr, HISI_I2C_INT_TX_EMPTY);\n}\n\nstatic irqreturn_t hisi_i2c_irq(int irq, void *context)\n{\n\tstruct hisi_i2c_controller *ctlr = context;\n\tu32 int_stat;\n\n\t \n\tif (!ctlr->completion)\n\t\treturn IRQ_NONE;\n\n\tint_stat = readl(ctlr->iobase + HISI_I2C_INT_MSTAT);\n\thisi_i2c_clear_int(ctlr, int_stat);\n\tif (!(int_stat & HISI_I2C_INT_ALL))\n\t\treturn IRQ_NONE;\n\n\tif (int_stat & HISI_I2C_INT_TX_EMPTY)\n\t\thisi_i2c_xfer_msg(ctlr);\n\n\tif (int_stat & HISI_I2C_INT_ERR) {\n\t\tctlr->xfer_err = int_stat;\n\t\tgoto out;\n\t}\n\n\t \n\tif (int_stat & (HISI_I2C_INT_TRANS_CPLT | HISI_I2C_INT_RX_FULL))\n\t\thisi_i2c_read_rx_fifo(ctlr);\n\nout:\n\t \n\tif (int_stat & HISI_I2C_INT_TRANS_CPLT) {\n\t\thisi_i2c_disable_int(ctlr, HISI_I2C_INT_ALL);\n\t\thisi_i2c_clear_int(ctlr, HISI_I2C_INT_ALL);\n\t\tcomplete(ctlr->completion);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic void hisi_i2c_set_scl(struct hisi_i2c_controller *ctlr,\n\t\t\t     u32 divide, u32 divisor,\n\t\t\t     u32 reg_hcnt, u32 reg_lcnt)\n{\n\tu32 total_cnt, t_scl_hcnt, t_scl_lcnt, scl_fall_cnt, scl_rise_cnt;\n\tu32 scl_hcnt, scl_lcnt;\n\n\t \n\ttotal_cnt = DIV_ROUND_UP_ULL(ctlr->clk_rate_khz * HZ_PER_KHZ, ctlr->t.bus_freq_hz);\n\t \n\tt_scl_hcnt = DIV_ROUND_UP_ULL(total_cnt * divide, divisor);\n\t \n\tt_scl_lcnt = total_cnt - t_scl_hcnt;\n\t \n\tscl_fall_cnt = NSEC_TO_CYCLES(ctlr->t.scl_fall_ns, ctlr->clk_rate_khz);\n\t \n\tscl_rise_cnt = NSEC_TO_CYCLES(ctlr->t.scl_rise_ns, ctlr->clk_rate_khz);\n\n\t \n\tscl_hcnt = t_scl_hcnt - ctlr->spk_len - 7 - scl_fall_cnt;\n\tscl_lcnt = t_scl_lcnt - 1 - scl_rise_cnt;\n\n\twritel(scl_hcnt, ctlr->iobase + reg_hcnt);\n\twritel(scl_lcnt, ctlr->iobase + reg_lcnt);\n}\n\nstatic void hisi_i2c_configure_bus(struct hisi_i2c_controller *ctlr)\n{\n\tu32 reg, sda_hold_cnt, speed_mode;\n\n\ti2c_parse_fw_timings(ctlr->dev, &ctlr->t, true);\n\tctlr->spk_len = NSEC_TO_CYCLES(ctlr->t.digital_filter_width_ns, ctlr->clk_rate_khz);\n\n\tswitch (ctlr->t.bus_freq_hz) {\n\tcase I2C_MAX_FAST_MODE_FREQ:\n\t\tspeed_mode = HISI_I2C_FAST_SPEED_MODE;\n\t\thisi_i2c_set_scl(ctlr, 26, 76, HISI_I2C_FS_SCL_HCNT, HISI_I2C_FS_SCL_LCNT);\n\t\tbreak;\n\tcase I2C_MAX_HIGH_SPEED_MODE_FREQ:\n\t\tspeed_mode = HISI_I2C_HIGH_SPEED_MODE;\n\t\thisi_i2c_set_scl(ctlr, 6, 22, HISI_I2C_HS_SCL_HCNT, HISI_I2C_HS_SCL_LCNT);\n\t\tbreak;\n\tcase I2C_MAX_STANDARD_MODE_FREQ:\n\tdefault:\n\t\tspeed_mode = HISI_I2C_STD_SPEED_MODE;\n\n\t\t \n\t\tctlr->t.bus_freq_hz = I2C_MAX_STANDARD_MODE_FREQ;\n\t\thisi_i2c_set_scl(ctlr, 40, 87, HISI_I2C_SS_SCL_HCNT, HISI_I2C_SS_SCL_LCNT);\n\t\tbreak;\n\t}\n\n\treg = readl(ctlr->iobase + HISI_I2C_FRAME_CTRL);\n\treg &= ~HISI_I2C_FRAME_CTRL_SPEED_MODE;\n\treg |= FIELD_PREP(HISI_I2C_FRAME_CTRL_SPEED_MODE, speed_mode);\n\twritel(reg, ctlr->iobase + HISI_I2C_FRAME_CTRL);\n\n\tsda_hold_cnt = NSEC_TO_CYCLES(ctlr->t.sda_hold_ns, ctlr->clk_rate_khz);\n\n\treg = FIELD_PREP(HISI_I2C_SDA_HOLD_TX, sda_hold_cnt);\n\twritel(reg, ctlr->iobase + HISI_I2C_SDA_HOLD);\n\n\twritel(ctlr->spk_len, ctlr->iobase + HISI_I2C_FS_SPK_LEN);\n\n\treg = FIELD_PREP(HISI_I2C_FIFO_RX_AF_THRESH, HISI_I2C_RX_F_AF_THRESH);\n\treg |= FIELD_PREP(HISI_I2C_FIFO_TX_AE_THRESH, HISI_I2C_TX_F_AE_THRESH);\n\twritel(reg, ctlr->iobase + HISI_I2C_FIFO_CTRL);\n}\n\nstatic int hisi_i2c_probe(struct platform_device *pdev)\n{\n\tstruct hisi_i2c_controller *ctlr;\n\tstruct device *dev = &pdev->dev;\n\tstruct i2c_adapter *adapter;\n\tu64 clk_rate_hz;\n\tu32 hw_version;\n\tint ret;\n\n\tctlr = devm_kzalloc(dev, sizeof(*ctlr), GFP_KERNEL);\n\tif (!ctlr)\n\t\treturn -ENOMEM;\n\n\tctlr->iobase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(ctlr->iobase))\n\t\treturn PTR_ERR(ctlr->iobase);\n\n\tctlr->irq = platform_get_irq(pdev, 0);\n\tif (ctlr->irq < 0)\n\t\treturn ctlr->irq;\n\n\tctlr->dev = dev;\n\n\thisi_i2c_disable_int(ctlr, HISI_I2C_INT_ALL);\n\n\tret = devm_request_irq(dev, ctlr->irq, hisi_i2c_irq, 0, \"hisi-i2c\", ctlr);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"failed to request irq handler\\n\");\n\n\tctlr->clk = devm_clk_get_optional_enabled(&pdev->dev, NULL);\n\tif (IS_ERR_OR_NULL(ctlr->clk)) {\n\t\tret = device_property_read_u64(dev, \"clk_rate\", &clk_rate_hz);\n\t\tif (ret)\n\t\t\treturn dev_err_probe(dev, ret, \"failed to get clock frequency\\n\");\n\t} else {\n\t\tclk_rate_hz = clk_get_rate(ctlr->clk);\n\t}\n\n\tctlr->clk_rate_khz = DIV_ROUND_UP_ULL(clk_rate_hz, HZ_PER_KHZ);\n\n\thisi_i2c_configure_bus(ctlr);\n\n\tadapter = &ctlr->adapter;\n\tsnprintf(adapter->name, sizeof(adapter->name),\n\t\t \"HiSilicon I2C Controller %s\", dev_name(dev));\n\tadapter->owner = THIS_MODULE;\n\tadapter->algo = &hisi_i2c_algo;\n\tadapter->dev.parent = dev;\n\ti2c_set_adapdata(adapter, ctlr);\n\n\tret = devm_i2c_add_adapter(dev, adapter);\n\tif (ret)\n\t\treturn ret;\n\n\thw_version = readl(ctlr->iobase + HISI_I2C_VERSION);\n\tdev_info(ctlr->dev, \"speed mode is %s. hw version 0x%x\\n\",\n\t\t i2c_freq_mode_string(ctlr->t.bus_freq_hz), hw_version);\n\n\treturn 0;\n}\n\nstatic const struct acpi_device_id hisi_i2c_acpi_ids[] = {\n\t{ \"HISI03D1\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(acpi, hisi_i2c_acpi_ids);\n\nstatic const struct of_device_id hisi_i2c_dts_ids[] = {\n\t{ .compatible = \"hisilicon,ascend910-i2c\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, hisi_i2c_dts_ids);\n\nstatic struct platform_driver hisi_i2c_driver = {\n\t.probe\t\t= hisi_i2c_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"hisi-i2c\",\n\t\t.acpi_match_table = hisi_i2c_acpi_ids,\n\t\t.of_match_table = hisi_i2c_dts_ids,\n\t},\n};\nmodule_platform_driver(hisi_i2c_driver);\n\nMODULE_AUTHOR(\"Yicong Yang <yangyicong@hisilicon.com>\");\nMODULE_DESCRIPTION(\"HiSilicon I2C Controller Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}