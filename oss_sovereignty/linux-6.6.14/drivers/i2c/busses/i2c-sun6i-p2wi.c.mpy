{
  "module_name": "i2c-sun6i-p2wi.c",
  "hash_id": "7297713fca9c47115983f761c70f31e83c24a6a7362fe4d2dc594a49c3dd7b93",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-sun6i-p2wi.c",
  "human_readable_source": " \n#include <linux/clk.h>\n#include <linux/i2c.h>\n#include <linux/io.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/reset.h>\n\n\n \n#define P2WI_CTRL\t\t0x0\n#define P2WI_CCR\t\t0x4\n#define P2WI_INTE\t\t0x8\n#define P2WI_INTS\t\t0xc\n#define P2WI_DADDR0\t\t0x10\n#define P2WI_DADDR1\t\t0x14\n#define P2WI_DLEN\t\t0x18\n#define P2WI_DATA0\t\t0x1c\n#define P2WI_DATA1\t\t0x20\n#define P2WI_LCR\t\t0x24\n#define P2WI_PMCR\t\t0x28\n\n \n#define P2WI_CTRL_START_TRANS\t\tBIT(7)\n#define P2WI_CTRL_ABORT_TRANS\t\tBIT(6)\n#define P2WI_CTRL_GLOBAL_INT_ENB\tBIT(1)\n#define P2WI_CTRL_SOFT_RST\t\tBIT(0)\n\n \n#define P2WI_CCR_SDA_OUT_DELAY(v)\t(((v) & 0x7) << 8)\n#define P2WI_CCR_MAX_CLK_DIV\t\t0xff\n#define P2WI_CCR_CLK_DIV(v)\t\t((v) & P2WI_CCR_MAX_CLK_DIV)\n\n \n#define P2WI_INTS_TRANS_ERR_ID(v)\t(((v) >> 8) & 0xff)\n#define P2WI_INTS_LOAD_BSY\t\tBIT(2)\n#define P2WI_INTS_TRANS_ERR\t\tBIT(1)\n#define P2WI_INTS_TRANS_OVER\t\tBIT(0)\n\n \n#define P2WI_DLEN_READ\t\t\tBIT(4)\n#define P2WI_DLEN_DATA_LENGTH(v)\t((v - 1) & 0x7)\n\n \n#define P2WI_LCR_SCL_STATE\t\tBIT(5)\n#define P2WI_LCR_SDA_STATE\t\tBIT(4)\n#define P2WI_LCR_SCL_CTL\t\tBIT(3)\n#define P2WI_LCR_SCL_CTL_EN\t\tBIT(2)\n#define P2WI_LCR_SDA_CTL\t\tBIT(1)\n#define P2WI_LCR_SDA_CTL_EN\t\tBIT(0)\n\n \n#define P2WI_PMCR_PMU_INIT_SEND\t\tBIT(31)\n#define P2WI_PMCR_PMU_INIT_DATA(v)\t(((v) & 0xff) << 16)\n#define P2WI_PMCR_PMU_MODE_REG(v)\t(((v) & 0xff) << 8)\n#define P2WI_PMCR_PMU_DEV_ADDR(v)\t((v) & 0xff)\n\n#define P2WI_MAX_FREQ\t\t\t6000000\n\nstruct p2wi {\n\tstruct i2c_adapter adapter;\n\tstruct completion complete;\n\tunsigned int status;\n\tvoid __iomem *regs;\n\tstruct clk *clk;\n\tstruct reset_control *rstc;\n\tint slave_addr;\n};\n\nstatic irqreturn_t p2wi_interrupt(int irq, void *dev_id)\n{\n\tstruct p2wi *p2wi = dev_id;\n\tunsigned long status;\n\n\tstatus = readl(p2wi->regs + P2WI_INTS);\n\tp2wi->status = status;\n\n\t \n\tstatus &= (P2WI_INTS_LOAD_BSY | P2WI_INTS_TRANS_ERR |\n\t\t   P2WI_INTS_TRANS_OVER);\n\twritel(status, p2wi->regs + P2WI_INTS);\n\n\tcomplete(&p2wi->complete);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic u32 p2wi_functionality(struct i2c_adapter *adap)\n{\n\treturn I2C_FUNC_SMBUS_BYTE_DATA;\n}\n\nstatic int p2wi_smbus_xfer(struct i2c_adapter *adap, u16 addr,\n\t\t\t   unsigned short flags, char read_write,\n\t\t\t   u8 command, int size, union i2c_smbus_data *data)\n{\n\tstruct p2wi *p2wi = i2c_get_adapdata(adap);\n\tunsigned long dlen = P2WI_DLEN_DATA_LENGTH(1);\n\n\tif (p2wi->slave_addr >= 0 && addr != p2wi->slave_addr) {\n\t\tdev_err(&adap->dev, \"invalid P2WI address\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!data)\n\t\treturn -EINVAL;\n\n\twritel(command, p2wi->regs + P2WI_DADDR0);\n\n\tif (read_write == I2C_SMBUS_READ)\n\t\tdlen |= P2WI_DLEN_READ;\n\telse\n\t\twritel(data->byte, p2wi->regs + P2WI_DATA0);\n\n\twritel(dlen, p2wi->regs + P2WI_DLEN);\n\n\tif (readl(p2wi->regs + P2WI_CTRL) & P2WI_CTRL_START_TRANS) {\n\t\tdev_err(&adap->dev, \"P2WI bus busy\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\treinit_completion(&p2wi->complete);\n\n\twritel(P2WI_INTS_LOAD_BSY | P2WI_INTS_TRANS_ERR | P2WI_INTS_TRANS_OVER,\n\t       p2wi->regs + P2WI_INTE);\n\n\twritel(P2WI_CTRL_START_TRANS | P2WI_CTRL_GLOBAL_INT_ENB,\n\t       p2wi->regs + P2WI_CTRL);\n\n\twait_for_completion(&p2wi->complete);\n\n\tif (p2wi->status & P2WI_INTS_LOAD_BSY) {\n\t\tdev_err(&adap->dev, \"P2WI bus busy\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tif (p2wi->status & P2WI_INTS_TRANS_ERR) {\n\t\tdev_err(&adap->dev, \"P2WI bus xfer error\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tif (read_write == I2C_SMBUS_READ)\n\t\tdata->byte = readl(p2wi->regs + P2WI_DATA0);\n\n\treturn 0;\n}\n\nstatic const struct i2c_algorithm p2wi_algo = {\n\t.smbus_xfer = p2wi_smbus_xfer,\n\t.functionality = p2wi_functionality,\n};\n\nstatic const struct of_device_id p2wi_of_match_table[] = {\n\t{ .compatible = \"allwinner,sun6i-a31-p2wi\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, p2wi_of_match_table);\n\nstatic int p2wi_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct device_node *childnp;\n\tunsigned long parent_clk_freq;\n\tu32 clk_freq = I2C_MAX_STANDARD_MODE_FREQ;\n\tstruct p2wi *p2wi;\n\tu32 slave_addr;\n\tint clk_div;\n\tint irq;\n\tint ret;\n\n\tof_property_read_u32(np, \"clock-frequency\", &clk_freq);\n\tif (clk_freq > P2WI_MAX_FREQ) {\n\t\tdev_err(dev,\n\t\t\t\"required clock-frequency (%u Hz) is too high (max = 6MHz)\",\n\t\t\tclk_freq);\n\t\treturn -EINVAL;\n\t}\n\n\tif (clk_freq == 0) {\n\t\tdev_err(dev, \"clock-frequency is set to 0 in DT\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (of_get_child_count(np) > 1) {\n\t\tdev_err(dev, \"P2WI only supports one slave device\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tp2wi = devm_kzalloc(dev, sizeof(struct p2wi), GFP_KERNEL);\n\tif (!p2wi)\n\t\treturn -ENOMEM;\n\n\tp2wi->slave_addr = -1;\n\n\t \n\tchildnp = of_get_next_available_child(np, NULL);\n\tif (childnp) {\n\t\tret = of_property_read_u32(childnp, \"reg\", &slave_addr);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"invalid slave address on node %pOF\\n\",\n\t\t\t\tchildnp);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tp2wi->slave_addr = slave_addr;\n\t}\n\n\tp2wi->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(p2wi->regs))\n\t\treturn PTR_ERR(p2wi->regs);\n\n\tstrscpy(p2wi->adapter.name, pdev->name, sizeof(p2wi->adapter.name));\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tp2wi->clk = devm_clk_get_enabled(dev, NULL);\n\tif (IS_ERR(p2wi->clk)) {\n\t\tret = PTR_ERR(p2wi->clk);\n\t\tdev_err(dev, \"failed to enable clk: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tparent_clk_freq = clk_get_rate(p2wi->clk);\n\n\tp2wi->rstc = devm_reset_control_get_exclusive(dev, NULL);\n\tif (IS_ERR(p2wi->rstc)) {\n\t\tdev_err(dev, \"failed to retrieve reset controller: %pe\\n\",\n\t\t\tp2wi->rstc);\n\t\treturn PTR_ERR(p2wi->rstc);\n\t}\n\n\tret = reset_control_deassert(p2wi->rstc);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to deassert reset line: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tinit_completion(&p2wi->complete);\n\tp2wi->adapter.dev.parent = dev;\n\tp2wi->adapter.algo = &p2wi_algo;\n\tp2wi->adapter.owner = THIS_MODULE;\n\tp2wi->adapter.dev.of_node = pdev->dev.of_node;\n\tplatform_set_drvdata(pdev, p2wi);\n\ti2c_set_adapdata(&p2wi->adapter, p2wi);\n\n\tret = devm_request_irq(dev, irq, p2wi_interrupt, 0, pdev->name, p2wi);\n\tif (ret) {\n\t\tdev_err(dev, \"can't register interrupt handler irq%d: %d\\n\",\n\t\t\tirq, ret);\n\t\tgoto err_reset_assert;\n\t}\n\n\twritel(P2WI_CTRL_SOFT_RST, p2wi->regs + P2WI_CTRL);\n\n\tclk_div = parent_clk_freq / clk_freq;\n\tif (!clk_div) {\n\t\tdev_warn(dev,\n\t\t\t \"clock-frequency is too high, setting it to %lu Hz\\n\",\n\t\t\t parent_clk_freq);\n\t\tclk_div = 1;\n\t} else if (clk_div > P2WI_CCR_MAX_CLK_DIV) {\n\t\tdev_warn(dev,\n\t\t\t \"clock-frequency is too low, setting it to %lu Hz\\n\",\n\t\t\t parent_clk_freq / P2WI_CCR_MAX_CLK_DIV);\n\t\tclk_div = P2WI_CCR_MAX_CLK_DIV;\n\t}\n\n\twritel(P2WI_CCR_SDA_OUT_DELAY(1) | P2WI_CCR_CLK_DIV(clk_div),\n\t       p2wi->regs + P2WI_CCR);\n\n\tret = i2c_add_adapter(&p2wi->adapter);\n\tif (!ret)\n\t\treturn 0;\n\nerr_reset_assert:\n\treset_control_assert(p2wi->rstc);\n\n\treturn ret;\n}\n\nstatic void p2wi_remove(struct platform_device *dev)\n{\n\tstruct p2wi *p2wi = platform_get_drvdata(dev);\n\n\treset_control_assert(p2wi->rstc);\n\ti2c_del_adapter(&p2wi->adapter);\n}\n\nstatic struct platform_driver p2wi_driver = {\n\t.probe\t= p2wi_probe,\n\t.remove_new = p2wi_remove,\n\t.driver\t= {\n\t\t.name = \"i2c-sunxi-p2wi\",\n\t\t.of_match_table = p2wi_of_match_table,\n\t},\n};\nmodule_platform_driver(p2wi_driver);\n\nMODULE_AUTHOR(\"Boris BREZILLON <boris.brezillon@free-electrons.com>\");\nMODULE_DESCRIPTION(\"Allwinner P2WI driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}