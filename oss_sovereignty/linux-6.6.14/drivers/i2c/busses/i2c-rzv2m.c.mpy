{
  "module_name": "i2c-rzv2m.c",
  "hash_id": "cdb277ba9c785b01248e38e3b1eb692bb81bba22fc939e855948e526baa17eb6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-rzv2m.c",
  "human_readable_source": "\n \n\n#include <linux/bits.h>\n#include <linux/clk.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/i2c.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/reset.h>\n\n \n#define IICB0DAT\t0x00\t\t \n#define IICB0CTL0\t0x08\t\t \n#define IICB0TRG\t0x0C\t\t \n#define IICB0STR0\t0x10\t\t \n#define IICB0CTL1\t0x20\t\t \n#define IICB0WL\t\t0x24\t\t \n#define IICB0WH\t\t0x28\t\t \n\n \n#define IICB0IICE\tBIT(7)\t\t \n#define IICB0SLWT\tBIT(1)\t\t \n#define IICB0SLAC\tBIT(0)\t\t \n\n \n#define IICB0WRET\tBIT(2)\t\t \n#define IICB0STT\tBIT(1)\t\t \n#define IICB0SPT\tBIT(0)\t\t \n\n \n#define IICB0SSAC\tBIT(8)\t\t \n#define IICB0SSBS\tBIT(6)\t\t \n#define IICB0SSSP\tBIT(4)\t\t \n\n \n#define IICB0MDSC\tBIT(7)\t\t \n#define IICB0SLSE\tBIT(1)\t\t \n\nstruct rzv2m_i2c_priv {\n\tvoid __iomem *base;\n\tstruct i2c_adapter adap;\n\tstruct clk *clk;\n\tint bus_mode;\n\tstruct completion msg_tia_done;\n\tu32 iicb0wl;\n\tu32 iicb0wh;\n};\n\nenum bcr_index {\n\tRZV2M_I2C_100K = 0,\n\tRZV2M_I2C_400K,\n};\n\nstruct bitrate_config {\n\tunsigned int percent_low;\n\tunsigned int min_hold_time_ns;\n};\n\nstatic const struct bitrate_config bitrate_configs[] = {\n\t[RZV2M_I2C_100K] = { 47, 3450 },\n\t[RZV2M_I2C_400K] = { 52, 900 },\n};\n\nstatic inline void bit_setl(void __iomem *addr, u32 val)\n{\n\twritel(readl(addr) | val, addr);\n}\n\nstatic inline void bit_clrl(void __iomem *addr, u32 val)\n{\n\twritel(readl(addr) & ~val, addr);\n}\n\nstatic irqreturn_t rzv2m_i2c_tia_irq_handler(int this_irq, void *dev_id)\n{\n\tstruct rzv2m_i2c_priv *priv = dev_id;\n\n\tcomplete(&priv->msg_tia_done);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic int rzv2m_i2c_clock_calculate(struct device *dev,\n\t\t\t\t     struct rzv2m_i2c_priv *priv)\n{\n\tconst struct bitrate_config *config;\n\tunsigned int hold_time_ns;\n\tunsigned int total_pclks;\n\tunsigned int trf_pclks;\n\tunsigned long pclk_hz;\n\tstruct i2c_timings t;\n\tu32 trf_ns;\n\n\ti2c_parse_fw_timings(dev, &t, true);\n\n\tpclk_hz = clk_get_rate(priv->clk);\n\ttotal_pclks = pclk_hz / t.bus_freq_hz;\n\n\ttrf_ns = t.scl_rise_ns + t.scl_fall_ns;\n\ttrf_pclks = mul_u64_u32_div(pclk_hz, trf_ns, NSEC_PER_SEC);\n\n\t \n\tswitch (t.bus_freq_hz) {\n\tcase I2C_MAX_FAST_MODE_FREQ:\n\t\tpriv->bus_mode = RZV2M_I2C_400K;\n\t\tbreak;\n\tcase I2C_MAX_STANDARD_MODE_FREQ:\n\t\tpriv->bus_mode = RZV2M_I2C_100K;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"transfer speed is invalid\\n\");\n\t\treturn -EINVAL;\n\t}\n\tconfig = &bitrate_configs[priv->bus_mode];\n\n\t \n\tpriv->iicb0wl = total_pclks * config->percent_low / 100;\n\tif (priv->iicb0wl > (BIT(10) - 1))\n\t\treturn -EINVAL;\n\n\t \n\tpriv->iicb0wh = total_pclks - priv->iicb0wl - trf_pclks;\n\tif (priv->iicb0wh > (BIT(10) - 1))\n\t\treturn -EINVAL;\n\n\t \n\thold_time_ns = div64_ul((u64)(priv->iicb0wl >> 2) * NSEC_PER_SEC, pclk_hz);\n\tif (hold_time_ns > config->min_hold_time_ns) {\n\t\tdev_err(dev, \"data hold time %dns is over %dns\\n\",\n\t\t\thold_time_ns, config->min_hold_time_ns);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void rzv2m_i2c_init(struct rzv2m_i2c_priv *priv)\n{\n\tu32 i2c_ctl0;\n\tu32 i2c_ctl1;\n\n\t \n\twritel(0, priv->base + IICB0CTL0);\n\n\t \n\ti2c_ctl1 = IICB0SLSE;\n\tif (priv->bus_mode == RZV2M_I2C_400K)\n\t\ti2c_ctl1 |= IICB0MDSC;\n\twritel(i2c_ctl1, priv->base + IICB0CTL1);\n\n\t \n\twritel(priv->iicb0wl, priv->base + IICB0WL);\n\twritel(priv->iicb0wh, priv->base + IICB0WH);\n\n\t \n\ti2c_ctl0 = IICB0SLWT | IICB0SLAC | IICB0IICE;\n\twritel(i2c_ctl0, priv->base + IICB0CTL0);\n}\n\nstatic int rzv2m_i2c_write_with_ack(struct rzv2m_i2c_priv *priv, u32 data)\n{\n\tunsigned long time_left;\n\n\treinit_completion(&priv->msg_tia_done);\n\n\twritel(data, priv->base + IICB0DAT);\n\n\ttime_left = wait_for_completion_timeout(&priv->msg_tia_done,\n\t\t\t\t\t\tpriv->adap.timeout);\n\tif (!time_left)\n\t\treturn -ETIMEDOUT;\n\n\t \n\tif ((readl(priv->base + IICB0STR0) & IICB0SSAC) != IICB0SSAC)\n\t\treturn -ENXIO;\n\n\treturn 0;\n}\n\nstatic int rzv2m_i2c_read_with_ack(struct rzv2m_i2c_priv *priv, u8 *data,\n\t\t\t\t   bool last)\n{\n\tunsigned long time_left;\n\tu32 data_tmp;\n\n\treinit_completion(&priv->msg_tia_done);\n\n\t \n\tbit_clrl(priv->base + IICB0CTL0, IICB0SLWT);\n\n\t \n\twritel(IICB0WRET, priv->base + IICB0TRG);\n\n\t \n\ttime_left = wait_for_completion_timeout(&priv->msg_tia_done,\n\t\t\t\t\t\tpriv->adap.timeout);\n\tif (!time_left)\n\t\treturn -ETIMEDOUT;\n\n\tif (last) {\n\t\t \n\t\tbit_clrl(priv->base + IICB0CTL0, IICB0SLAC);\n\n\t\t \n\t\tdata_tmp = readl(priv->base + IICB0DAT);\n\n\t\t \n\t\tbit_setl(priv->base + IICB0CTL0, IICB0SLWT);\n\n\t\t \n\t\twritel(IICB0WRET, priv->base + IICB0TRG);\n\n\t\t \n\t\ttime_left = wait_for_completion_timeout(&priv->msg_tia_done,\n\t\t\t\t\t\t\tpriv->adap.timeout);\n\t\tif (!time_left)\n\t\t\treturn -ETIMEDOUT;\n\n\t\t \n\t\tbit_setl(priv->base + IICB0CTL0, IICB0SLAC);\n\t} else {\n\t\t \n\t\tdata_tmp = readl(priv->base + IICB0DAT);\n\t}\n\n\t*data = data_tmp;\n\n\treturn 0;\n}\n\nstatic int rzv2m_i2c_send(struct rzv2m_i2c_priv *priv, struct i2c_msg *msg,\n\t\t\t  unsigned int *count)\n{\n\tunsigned int i;\n\tint ret;\n\n\tfor (i = 0; i < msg->len; i++) {\n\t\tret = rzv2m_i2c_write_with_ack(priv, msg->buf[i]);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\t*count = i;\n\n\treturn 0;\n}\n\nstatic int rzv2m_i2c_receive(struct rzv2m_i2c_priv *priv, struct i2c_msg *msg,\n\t\t\t     unsigned int *count)\n{\n\tunsigned int i;\n\tint ret;\n\n\tfor (i = 0; i < msg->len; i++) {\n\t\tret = rzv2m_i2c_read_with_ack(priv, &msg->buf[i],\n\t\t\t\t\t      (msg->len - 1) == i);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\t*count = i;\n\n\treturn 0;\n}\n\nstatic int rzv2m_i2c_send_address(struct rzv2m_i2c_priv *priv,\n\t\t\t\t  struct i2c_msg *msg)\n{\n\tu32 addr;\n\tint ret;\n\n\tif (msg->flags & I2C_M_TEN) {\n\t\t \n\t\taddr = 0xf0 | ((msg->addr & GENMASK(9, 8)) >> 7);\n\t\taddr |= !!(msg->flags & I2C_M_RD);\n\t\t \n\t\tret = rzv2m_i2c_write_with_ack(priv, addr);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tret = rzv2m_i2c_write_with_ack(priv, msg->addr & 0xff);\n\t} else {\n\t\t \n\t\taddr = i2c_8bit_addr_from_msg(msg);\n\t\tret = rzv2m_i2c_write_with_ack(priv, addr);\n\t}\n\n\treturn ret;\n}\n\nstatic int rzv2m_i2c_stop_condition(struct rzv2m_i2c_priv *priv)\n{\n\tu32 value;\n\n\t \n\twritel(IICB0SPT, priv->base + IICB0TRG);\n\treturn readl_poll_timeout(priv->base + IICB0STR0,\n\t\t\t\t  value, value & IICB0SSSP,\n\t\t\t\t  100, jiffies_to_usecs(priv->adap.timeout));\n}\n\nstatic int rzv2m_i2c_master_xfer_msg(struct rzv2m_i2c_priv *priv,\n\t\t\t\t  struct i2c_msg *msg, int stop)\n{\n\tunsigned int count = 0;\n\tint ret, read = !!(msg->flags & I2C_M_RD);\n\n\t \n\twritel(IICB0STT, priv->base + IICB0TRG);\n\n\tret = rzv2m_i2c_send_address(priv, msg);\n\tif (!ret) {\n\t\tif (read)\n\t\t\tret = rzv2m_i2c_receive(priv, msg, &count);\n\t\telse\n\t\t\tret = rzv2m_i2c_send(priv, msg, &count);\n\n\t\tif (!ret && stop)\n\t\t\tret = rzv2m_i2c_stop_condition(priv);\n\t}\n\n\tif (ret == -ENXIO)\n\t\trzv2m_i2c_stop_condition(priv);\n\telse if (ret < 0)\n\t\trzv2m_i2c_init(priv);\n\telse\n\t\tret = count;\n\n\treturn ret;\n}\n\nstatic int rzv2m_i2c_master_xfer(struct i2c_adapter *adap,\n\t\t\t\t struct i2c_msg *msgs, int num)\n{\n\tstruct rzv2m_i2c_priv *priv = i2c_get_adapdata(adap);\n\tstruct device *dev = priv->adap.dev.parent;\n\tunsigned int i;\n\tint ret;\n\n\tret = pm_runtime_resume_and_get(dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (readl(priv->base + IICB0STR0) & IICB0SSBS) {\n\t\tret = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\t \n\tfor (i = 0; i < num; i++) {\n\t\tret = rzv2m_i2c_master_xfer_msg(priv, &msgs[i], i == (num - 1));\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\tret = num;\n\nout:\n\tpm_runtime_mark_last_busy(dev);\n\tpm_runtime_put_autosuspend(dev);\n\n\treturn ret;\n}\n\nstatic u32 rzv2m_i2c_func(struct i2c_adapter *adap)\n{\n\treturn I2C_FUNC_I2C | (I2C_FUNC_SMBUS_EMUL & ~I2C_FUNC_SMBUS_QUICK) |\n\t       I2C_FUNC_10BIT_ADDR;\n}\n\nstatic int rzv2m_i2c_disable(struct device *dev, struct rzv2m_i2c_priv *priv)\n{\n\tint ret;\n\n\tret = pm_runtime_resume_and_get(dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tbit_clrl(priv->base + IICB0CTL0, IICB0IICE);\n\tpm_runtime_put(dev);\n\n\treturn 0;\n}\n\nstatic const struct i2c_adapter_quirks rzv2m_i2c_quirks = {\n\t.flags = I2C_AQ_NO_ZERO_LEN,\n};\n\nstatic struct i2c_algorithm rzv2m_i2c_algo = {\n\t.master_xfer = rzv2m_i2c_master_xfer,\n\t.functionality = rzv2m_i2c_func,\n};\n\nstatic int rzv2m_i2c_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct rzv2m_i2c_priv *priv;\n\tstruct reset_control *rstc;\n\tstruct i2c_adapter *adap;\n\tstruct resource *res;\n\tint irq, ret;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->base = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(priv->base))\n\t\treturn PTR_ERR(priv->base);\n\n\tpriv->clk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(priv->clk))\n\t\treturn dev_err_probe(dev, PTR_ERR(priv->clk), \"Can't get clock\\n\");\n\n\trstc = devm_reset_control_get_shared(dev, NULL);\n\tif (IS_ERR(rstc))\n\t\treturn dev_err_probe(dev, PTR_ERR(rstc), \"Missing reset ctrl\\n\");\n\t \n\treset_control_deassert(rstc);\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tret = devm_request_irq(dev, irq, rzv2m_i2c_tia_irq_handler, 0,\n\t\t\t       dev_name(dev), priv);\n\tif (ret < 0)\n\t\treturn dev_err_probe(dev, ret, \"Unable to request irq %d\\n\", irq);\n\n\tadap = &priv->adap;\n\tadap->nr = pdev->id;\n\tadap->algo = &rzv2m_i2c_algo;\n\tadap->quirks = &rzv2m_i2c_quirks;\n\tadap->dev.parent = dev;\n\tadap->owner = THIS_MODULE;\n\tdevice_set_node(&adap->dev, dev_fwnode(dev));\n\ti2c_set_adapdata(adap, priv);\n\tstrscpy(adap->name, pdev->name, sizeof(adap->name));\n\tinit_completion(&priv->msg_tia_done);\n\n\tret = rzv2m_i2c_clock_calculate(dev, priv);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tpm_runtime_enable(dev);\n\n\tpm_runtime_get_sync(dev);\n\trzv2m_i2c_init(priv);\n\tpm_runtime_put(dev);\n\n\tplatform_set_drvdata(pdev, priv);\n\n\tret = i2c_add_numbered_adapter(adap);\n\tif (ret < 0) {\n\t\trzv2m_i2c_disable(dev, priv);\n\t\tpm_runtime_disable(dev);\n\t}\n\n\treturn ret;\n}\n\nstatic void rzv2m_i2c_remove(struct platform_device *pdev)\n{\n\tstruct rzv2m_i2c_priv *priv = platform_get_drvdata(pdev);\n\tstruct device *dev = priv->adap.dev.parent;\n\n\ti2c_del_adapter(&priv->adap);\n\trzv2m_i2c_disable(dev, priv);\n\tpm_runtime_disable(dev);\n}\n\nstatic int rzv2m_i2c_suspend(struct device *dev)\n{\n\tstruct rzv2m_i2c_priv *priv = dev_get_drvdata(dev);\n\n\treturn rzv2m_i2c_disable(dev, priv);\n}\n\nstatic int rzv2m_i2c_resume(struct device *dev)\n{\n\tstruct rzv2m_i2c_priv *priv = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = rzv2m_i2c_clock_calculate(dev, priv);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = pm_runtime_resume_and_get(dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\trzv2m_i2c_init(priv);\n\tpm_runtime_put(dev);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id rzv2m_i2c_ids[] = {\n\t{ .compatible = \"renesas,rzv2m-i2c\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, rzv2m_i2c_ids);\n\nstatic const struct dev_pm_ops rzv2m_i2c_pm_ops = {\n\tSYSTEM_SLEEP_PM_OPS(rzv2m_i2c_suspend, rzv2m_i2c_resume)\n};\n\nstatic struct platform_driver rzv2m_i2c_driver = {\n\t.driver = {\n\t\t.name = \"rzv2m-i2c\",\n\t\t.of_match_table = rzv2m_i2c_ids,\n\t\t.pm = pm_sleep_ptr(&rzv2m_i2c_pm_ops),\n\t},\n\t.probe\t= rzv2m_i2c_probe,\n\t.remove_new = rzv2m_i2c_remove,\n};\nmodule_platform_driver(rzv2m_i2c_driver);\n\nMODULE_DESCRIPTION(\"RZ/V2M I2C bus driver\");\nMODULE_AUTHOR(\"Renesas Electronics Corporation\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}