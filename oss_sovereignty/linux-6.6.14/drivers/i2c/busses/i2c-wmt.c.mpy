{
  "module_name": "i2c-wmt.c",
  "hash_id": "4af9b5f7ad6ef42ee5924a4c9087a6a2bebbcd5036851782d17983592f82b6e1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-wmt.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/platform_device.h>\n\n#define REG_CR\t\t0x00\n#define REG_TCR\t\t0x02\n#define REG_CSR\t\t0x04\n#define REG_ISR\t\t0x06\n#define REG_IMR\t\t0x08\n#define REG_CDR\t\t0x0A\n#define REG_TR\t\t0x0C\n#define REG_MCR\t\t0x0E\n#define REG_SLAVE_CR\t0x10\n#define REG_SLAVE_SR\t0x12\n#define REG_SLAVE_ISR\t0x14\n#define REG_SLAVE_IMR\t0x16\n#define REG_SLAVE_DR\t0x18\n#define REG_SLAVE_TR\t0x1A\n\n \n#define CR_TX_NEXT_ACK\t\t0x0000\n#define CR_ENABLE\t\t0x0001\n#define CR_TX_NEXT_NO_ACK\t0x0002\n#define CR_TX_END\t\t0x0004\n#define CR_CPU_RDY\t\t0x0008\n#define SLAV_MODE_SEL\t\t0x8000\n\n \n#define TCR_STANDARD_MODE\t0x0000\n#define TCR_MASTER_WRITE\t0x0000\n#define TCR_HS_MODE\t\t0x2000\n#define TCR_MASTER_READ\t\t0x4000\n#define TCR_FAST_MODE\t\t0x8000\n#define TCR_SLAVE_ADDR_MASK\t0x007F\n\n \n#define ISR_NACK_ADDR\t\t0x0001\n#define ISR_BYTE_END\t\t0x0002\n#define ISR_SCL_TIMEOUT\t\t0x0004\n#define ISR_WRITE_ALL\t\t0x0007\n\n \n#define IMR_ENABLE_ALL\t\t0x0007\n\n \n#define CSR_RCV_NOT_ACK\t\t0x0001\n#define CSR_RCV_ACK_MASK\t0x0001\n#define CSR_READY_MASK\t\t0x0002\n\n \n#define SCL_TIMEOUT(x)\t\t(((x) & 0xFF) << 8)\n#define TR_STD\t\t\t0x0064\n#define TR_HS\t\t\t0x0019\n\n \n#define MCR_APB_96M\t\t7\n#define MCR_APB_166M\t\t12\n\n#define I2C_MODE_STANDARD\t0\n#define I2C_MODE_FAST\t\t1\n\n#define WMT_I2C_TIMEOUT\t\t(msecs_to_jiffies(1000))\n\nstruct wmt_i2c_dev {\n\tstruct i2c_adapter\tadapter;\n\tstruct completion\tcomplete;\n\tstruct device\t\t*dev;\n\tvoid __iomem\t\t*base;\n\tstruct clk\t\t*clk;\n\tint\t\t\tmode;\n\tint\t\t\tirq;\n\tu16\t\t\tcmd_status;\n};\n\nstatic int wmt_i2c_wait_bus_not_busy(struct wmt_i2c_dev *i2c_dev)\n{\n\tunsigned long timeout;\n\n\ttimeout = jiffies + WMT_I2C_TIMEOUT;\n\twhile (!(readw(i2c_dev->base + REG_CSR) & CSR_READY_MASK)) {\n\t\tif (time_after(jiffies, timeout)) {\n\t\t\tdev_warn(i2c_dev->dev, \"timeout waiting for bus ready\\n\");\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tmsleep(20);\n\t}\n\n\treturn 0;\n}\n\nstatic int wmt_check_status(struct wmt_i2c_dev *i2c_dev)\n{\n\tint ret = 0;\n\n\tif (i2c_dev->cmd_status & ISR_NACK_ADDR)\n\t\tret = -EIO;\n\n\tif (i2c_dev->cmd_status & ISR_SCL_TIMEOUT)\n\t\tret = -ETIMEDOUT;\n\n\treturn ret;\n}\n\nstatic int wmt_i2c_write(struct i2c_adapter *adap, struct i2c_msg *pmsg,\n\t\t\t int last)\n{\n\tstruct wmt_i2c_dev *i2c_dev = i2c_get_adapdata(adap);\n\tu16 val, tcr_val;\n\tint ret;\n\tunsigned long wait_result;\n\tint xfer_len = 0;\n\n\tif (!(pmsg->flags & I2C_M_NOSTART)) {\n\t\tret = wmt_i2c_wait_bus_not_busy(i2c_dev);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tif (pmsg->len == 0) {\n\t\t \n\t\txfer_len = -1;\n\t\twritew(0, i2c_dev->base + REG_CDR);\n\t} else {\n\t\twritew(pmsg->buf[0] & 0xFF, i2c_dev->base + REG_CDR);\n\t}\n\n\tif (!(pmsg->flags & I2C_M_NOSTART)) {\n\t\tval = readw(i2c_dev->base + REG_CR);\n\t\tval &= ~CR_TX_END;\n\t\twritew(val, i2c_dev->base + REG_CR);\n\n\t\tval = readw(i2c_dev->base + REG_CR);\n\t\tval |= CR_CPU_RDY;\n\t\twritew(val, i2c_dev->base + REG_CR);\n\t}\n\n\treinit_completion(&i2c_dev->complete);\n\n\tif (i2c_dev->mode == I2C_MODE_STANDARD)\n\t\ttcr_val = TCR_STANDARD_MODE;\n\telse\n\t\ttcr_val = TCR_FAST_MODE;\n\n\ttcr_val |= (TCR_MASTER_WRITE | (pmsg->addr & TCR_SLAVE_ADDR_MASK));\n\n\twritew(tcr_val, i2c_dev->base + REG_TCR);\n\n\tif (pmsg->flags & I2C_M_NOSTART) {\n\t\tval = readw(i2c_dev->base + REG_CR);\n\t\tval |= CR_CPU_RDY;\n\t\twritew(val, i2c_dev->base + REG_CR);\n\t}\n\n\twhile (xfer_len < pmsg->len) {\n\t\twait_result = wait_for_completion_timeout(&i2c_dev->complete,\n\t\t\t\t\t\t\tmsecs_to_jiffies(500));\n\n\t\tif (wait_result == 0)\n\t\t\treturn -ETIMEDOUT;\n\n\t\tret = wmt_check_status(i2c_dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\txfer_len++;\n\n\t\tval = readw(i2c_dev->base + REG_CSR);\n\t\tif ((val & CSR_RCV_ACK_MASK) == CSR_RCV_NOT_ACK) {\n\t\t\tdev_dbg(i2c_dev->dev, \"write RCV NACK error\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tif (pmsg->len == 0) {\n\t\t\tval = CR_TX_END | CR_CPU_RDY | CR_ENABLE;\n\t\t\twritew(val, i2c_dev->base + REG_CR);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (xfer_len == pmsg->len) {\n\t\t\tif (last != 1)\n\t\t\t\twritew(CR_ENABLE, i2c_dev->base + REG_CR);\n\t\t} else {\n\t\t\twritew(pmsg->buf[xfer_len] & 0xFF, i2c_dev->base +\n\t\t\t\t\t\t\t\tREG_CDR);\n\t\t\twritew(CR_CPU_RDY | CR_ENABLE, i2c_dev->base + REG_CR);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int wmt_i2c_read(struct i2c_adapter *adap, struct i2c_msg *pmsg,\n\t\t\tint last)\n{\n\tstruct wmt_i2c_dev *i2c_dev = i2c_get_adapdata(adap);\n\tu16 val, tcr_val;\n\tint ret;\n\tunsigned long wait_result;\n\tu32 xfer_len = 0;\n\n\tif (!(pmsg->flags & I2C_M_NOSTART)) {\n\t\tret = wmt_i2c_wait_bus_not_busy(i2c_dev);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tval = readw(i2c_dev->base + REG_CR);\n\tval &= ~CR_TX_END;\n\twritew(val, i2c_dev->base + REG_CR);\n\n\tval = readw(i2c_dev->base + REG_CR);\n\tval &= ~CR_TX_NEXT_NO_ACK;\n\twritew(val, i2c_dev->base + REG_CR);\n\n\tif (!(pmsg->flags & I2C_M_NOSTART)) {\n\t\tval = readw(i2c_dev->base + REG_CR);\n\t\tval |= CR_CPU_RDY;\n\t\twritew(val, i2c_dev->base + REG_CR);\n\t}\n\n\tif (pmsg->len == 1) {\n\t\tval = readw(i2c_dev->base + REG_CR);\n\t\tval |= CR_TX_NEXT_NO_ACK;\n\t\twritew(val, i2c_dev->base + REG_CR);\n\t}\n\n\treinit_completion(&i2c_dev->complete);\n\n\tif (i2c_dev->mode == I2C_MODE_STANDARD)\n\t\ttcr_val = TCR_STANDARD_MODE;\n\telse\n\t\ttcr_val = TCR_FAST_MODE;\n\n\ttcr_val |= TCR_MASTER_READ | (pmsg->addr & TCR_SLAVE_ADDR_MASK);\n\n\twritew(tcr_val, i2c_dev->base + REG_TCR);\n\n\tif (pmsg->flags & I2C_M_NOSTART) {\n\t\tval = readw(i2c_dev->base + REG_CR);\n\t\tval |= CR_CPU_RDY;\n\t\twritew(val, i2c_dev->base + REG_CR);\n\t}\n\n\twhile (xfer_len < pmsg->len) {\n\t\twait_result = wait_for_completion_timeout(&i2c_dev->complete,\n\t\t\t\t\t\t\tmsecs_to_jiffies(500));\n\n\t\tif (!wait_result)\n\t\t\treturn -ETIMEDOUT;\n\n\t\tret = wmt_check_status(i2c_dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tpmsg->buf[xfer_len] = readw(i2c_dev->base + REG_CDR) >> 8;\n\t\txfer_len++;\n\n\t\tif (xfer_len == pmsg->len - 1) {\n\t\t\tval = readw(i2c_dev->base + REG_CR);\n\t\t\tval |= (CR_TX_NEXT_NO_ACK | CR_CPU_RDY);\n\t\t\twritew(val, i2c_dev->base + REG_CR);\n\t\t} else {\n\t\t\tval = readw(i2c_dev->base + REG_CR);\n\t\t\tval |= CR_CPU_RDY;\n\t\t\twritew(val, i2c_dev->base + REG_CR);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int wmt_i2c_xfer(struct i2c_adapter *adap,\n\t\t\tstruct i2c_msg msgs[],\n\t\t\tint num)\n{\n\tstruct i2c_msg *pmsg;\n\tint i, is_last;\n\tint ret = 0;\n\n\tfor (i = 0; ret >= 0 && i < num; i++) {\n\t\tis_last = ((i + 1) == num);\n\n\t\tpmsg = &msgs[i];\n\t\tif (pmsg->flags & I2C_M_RD)\n\t\t\tret = wmt_i2c_read(adap, pmsg, is_last);\n\t\telse\n\t\t\tret = wmt_i2c_write(adap, pmsg, is_last);\n\t}\n\n\treturn (ret < 0) ? ret : i;\n}\n\nstatic u32 wmt_i2c_func(struct i2c_adapter *adap)\n{\n\treturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL | I2C_FUNC_NOSTART;\n}\n\nstatic const struct i2c_algorithm wmt_i2c_algo = {\n\t.master_xfer\t= wmt_i2c_xfer,\n\t.functionality\t= wmt_i2c_func,\n};\n\nstatic irqreturn_t wmt_i2c_isr(int irq, void *data)\n{\n\tstruct wmt_i2c_dev *i2c_dev = data;\n\n\t \n\ti2c_dev->cmd_status = readw(i2c_dev->base + REG_ISR);\n\twritew(i2c_dev->cmd_status, i2c_dev->base + REG_ISR);\n\n\tcomplete(&i2c_dev->complete);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int wmt_i2c_reset_hardware(struct wmt_i2c_dev *i2c_dev)\n{\n\tint err;\n\n\terr = clk_prepare_enable(i2c_dev->clk);\n\tif (err) {\n\t\tdev_err(i2c_dev->dev, \"failed to enable clock\\n\");\n\t\treturn err;\n\t}\n\n\terr = clk_set_rate(i2c_dev->clk, 20000000);\n\tif (err) {\n\t\tdev_err(i2c_dev->dev, \"failed to set clock = 20Mhz\\n\");\n\t\tclk_disable_unprepare(i2c_dev->clk);\n\t\treturn err;\n\t}\n\n\twritew(0, i2c_dev->base + REG_CR);\n\twritew(MCR_APB_166M, i2c_dev->base + REG_MCR);\n\twritew(ISR_WRITE_ALL, i2c_dev->base + REG_ISR);\n\twritew(IMR_ENABLE_ALL, i2c_dev->base + REG_IMR);\n\twritew(CR_ENABLE, i2c_dev->base + REG_CR);\n\treadw(i2c_dev->base + REG_CSR);\t\t \n\twritew(ISR_WRITE_ALL, i2c_dev->base + REG_ISR);\n\n\tif (i2c_dev->mode == I2C_MODE_STANDARD)\n\t\twritew(SCL_TIMEOUT(128) | TR_STD, i2c_dev->base + REG_TR);\n\telse\n\t\twritew(SCL_TIMEOUT(128) | TR_HS, i2c_dev->base + REG_TR);\n\n\treturn 0;\n}\n\nstatic int wmt_i2c_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct wmt_i2c_dev *i2c_dev;\n\tstruct i2c_adapter *adap;\n\tint err;\n\tu32 clk_rate;\n\n\ti2c_dev = devm_kzalloc(&pdev->dev, sizeof(*i2c_dev), GFP_KERNEL);\n\tif (!i2c_dev)\n\t\treturn -ENOMEM;\n\n\ti2c_dev->base = devm_platform_get_and_ioremap_resource(pdev, 0, NULL);\n\tif (IS_ERR(i2c_dev->base))\n\t\treturn PTR_ERR(i2c_dev->base);\n\n\ti2c_dev->irq = irq_of_parse_and_map(np, 0);\n\tif (!i2c_dev->irq) {\n\t\tdev_err(&pdev->dev, \"irq missing or invalid\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\ti2c_dev->clk = of_clk_get(np, 0);\n\tif (IS_ERR(i2c_dev->clk)) {\n\t\tdev_err(&pdev->dev, \"unable to request clock\\n\");\n\t\treturn PTR_ERR(i2c_dev->clk);\n\t}\n\n\ti2c_dev->mode = I2C_MODE_STANDARD;\n\terr = of_property_read_u32(np, \"clock-frequency\", &clk_rate);\n\tif (!err && (clk_rate == I2C_MAX_FAST_MODE_FREQ))\n\t\ti2c_dev->mode = I2C_MODE_FAST;\n\n\ti2c_dev->dev = &pdev->dev;\n\n\terr = devm_request_irq(&pdev->dev, i2c_dev->irq, wmt_i2c_isr, 0,\n\t\t\t\t\t\t\t\"i2c\", i2c_dev);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"failed to request irq %i\\n\", i2c_dev->irq);\n\t\treturn err;\n\t}\n\n\tadap = &i2c_dev->adapter;\n\ti2c_set_adapdata(adap, i2c_dev);\n\tstrscpy(adap->name, \"WMT I2C adapter\", sizeof(adap->name));\n\tadap->owner = THIS_MODULE;\n\tadap->algo = &wmt_i2c_algo;\n\tadap->dev.parent = &pdev->dev;\n\tadap->dev.of_node = pdev->dev.of_node;\n\n\tinit_completion(&i2c_dev->complete);\n\n\terr = wmt_i2c_reset_hardware(i2c_dev);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"error initializing hardware\\n\");\n\t\treturn err;\n\t}\n\n\terr = i2c_add_adapter(adap);\n\tif (err)\n\t\treturn err;\n\n\tplatform_set_drvdata(pdev, i2c_dev);\n\n\treturn 0;\n}\n\nstatic void wmt_i2c_remove(struct platform_device *pdev)\n{\n\tstruct wmt_i2c_dev *i2c_dev = platform_get_drvdata(pdev);\n\n\t \n\twritew(0, i2c_dev->base + REG_IMR);\n\tclk_disable_unprepare(i2c_dev->clk);\n\ti2c_del_adapter(&i2c_dev->adapter);\n}\n\nstatic const struct of_device_id wmt_i2c_dt_ids[] = {\n\t{ .compatible = \"wm,wm8505-i2c\" },\n\t{   },\n};\n\nstatic struct platform_driver wmt_i2c_driver = {\n\t.probe\t\t= wmt_i2c_probe,\n\t.remove_new\t= wmt_i2c_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"wmt-i2c\",\n\t\t.of_match_table = wmt_i2c_dt_ids,\n\t},\n};\n\nmodule_platform_driver(wmt_i2c_driver);\n\nMODULE_DESCRIPTION(\"Wondermedia I2C master-mode bus adapter\");\nMODULE_AUTHOR(\"Tony Prisk <linux@prisktech.co.nz>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DEVICE_TABLE(of, wmt_i2c_dt_ids);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}