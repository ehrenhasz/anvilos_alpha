{
  "module_name": "i2c-mt7621.c",
  "hash_id": "f2c7ad8ae493999f1a70398ea353316f422f0a723354b6cbdc839124069be868",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-mt7621.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/i2c.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/reset.h>\n\n#define REG_SM0CFG2_REG\t\t0x28\n#define REG_SM0CTL0_REG\t\t0x40\n#define REG_SM0CTL1_REG\t\t0x44\n#define REG_SM0D0_REG\t\t0x50\n#define REG_SM0D1_REG\t\t0x54\n#define REG_PINTEN_REG\t\t0x5c\n#define REG_PINTST_REG\t\t0x60\n#define REG_PINTCL_REG\t\t0x64\n\n \n#define SM0CFG2_IS_AUTOMODE\tBIT(0)\n\n \n#define SM0CTL0_ODRAIN\t\tBIT(31)\n#define SM0CTL0_CLK_DIV_MASK\t(0x7ff << 16)\n#define SM0CTL0_CLK_DIV_MAX\t0x7ff\n#define SM0CTL0_CS_STATUS       BIT(4)\n#define SM0CTL0_SCL_STATE       BIT(3)\n#define SM0CTL0_SDA_STATE       BIT(2)\n#define SM0CTL0_EN              BIT(1)\n#define SM0CTL0_SCL_STRETCH     BIT(0)\n\n \n#define SM0CTL1_ACK_MASK\t(0xff << 16)\n#define SM0CTL1_PGLEN_MASK\t(0x7 << 8)\n#define SM0CTL1_PGLEN(x)\t((((x) - 1) << 8) & SM0CTL1_PGLEN_MASK)\n#define SM0CTL1_READ\t\t(5 << 4)\n#define SM0CTL1_READ_LAST\t(4 << 4)\n#define SM0CTL1_STOP\t\t(3 << 4)\n#define SM0CTL1_WRITE\t\t(2 << 4)\n#define SM0CTL1_START\t\t(1 << 4)\n#define SM0CTL1_MODE_MASK\t(0x7 << 4)\n#define SM0CTL1_TRI\t\tBIT(0)\n\n \n#define TIMEOUT_MS\t\t1000\n\nstruct mtk_i2c {\n\tvoid __iomem *base;\n\tstruct device *dev;\n\tstruct i2c_adapter adap;\n\tu32 bus_freq;\n\tu32 clk_div;\n\tu32 flags;\n\tstruct clk *clk;\n};\n\nstatic int mtk_i2c_wait_idle(struct mtk_i2c *i2c)\n{\n\tint ret;\n\tu32 val;\n\n\tret = readl_relaxed_poll_timeout(i2c->base + REG_SM0CTL1_REG,\n\t\t\t\t\t val, !(val & SM0CTL1_TRI),\n\t\t\t\t\t 10, TIMEOUT_MS * 1000);\n\tif (ret)\n\t\tdev_dbg(i2c->dev, \"idle err(%d)\\n\", ret);\n\n\treturn ret;\n}\n\nstatic void mtk_i2c_reset(struct mtk_i2c *i2c)\n{\n\tint ret;\n\n\tret = device_reset(i2c->adap.dev.parent);\n\tif (ret)\n\t\tdev_err(i2c->dev, \"I2C reset failed!\\n\");\n\n\t \n\tiowrite32(((i2c->clk_div << 16) & SM0CTL0_CLK_DIV_MASK) | SM0CTL0_EN |\n\t\t  SM0CTL0_SCL_STRETCH, i2c->base + REG_SM0CTL0_REG);\n\tiowrite32(0, i2c->base + REG_SM0CFG2_REG);\n}\n\nstatic void mtk_i2c_dump_reg(struct mtk_i2c *i2c)\n{\n\tdev_dbg(i2c->dev,\n\t\t\"SM0CFG2 %08x, SM0CTL0 %08x, SM0CTL1 %08x, SM0D0 %08x, SM0D1 %08x\\n\",\n\t\tioread32(i2c->base + REG_SM0CFG2_REG),\n\t\tioread32(i2c->base + REG_SM0CTL0_REG),\n\t\tioread32(i2c->base + REG_SM0CTL1_REG),\n\t\tioread32(i2c->base + REG_SM0D0_REG),\n\t\tioread32(i2c->base + REG_SM0D1_REG));\n}\n\nstatic int mtk_i2c_check_ack(struct mtk_i2c *i2c, u32 expected)\n{\n\tu32 ack = readl_relaxed(i2c->base + REG_SM0CTL1_REG);\n\tu32 ack_expected = (expected << 16) & SM0CTL1_ACK_MASK;\n\n\treturn ((ack & ack_expected) == ack_expected) ? 0 : -ENXIO;\n}\n\nstatic int mtk_i2c_master_start(struct mtk_i2c *i2c)\n{\n\tiowrite32(SM0CTL1_START | SM0CTL1_TRI, i2c->base + REG_SM0CTL1_REG);\n\treturn mtk_i2c_wait_idle(i2c);\n}\n\nstatic int mtk_i2c_master_stop(struct mtk_i2c *i2c)\n{\n\tiowrite32(SM0CTL1_STOP | SM0CTL1_TRI, i2c->base + REG_SM0CTL1_REG);\n\treturn mtk_i2c_wait_idle(i2c);\n}\n\nstatic int mtk_i2c_master_cmd(struct mtk_i2c *i2c, u32 cmd, int page_len)\n{\n\tiowrite32(cmd | SM0CTL1_TRI | SM0CTL1_PGLEN(page_len),\n\t\t  i2c->base + REG_SM0CTL1_REG);\n\treturn mtk_i2c_wait_idle(i2c);\n}\n\nstatic int mtk_i2c_master_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs,\n\t\t\t       int num)\n{\n\tstruct mtk_i2c *i2c;\n\tstruct i2c_msg *pmsg;\n\tu16 addr;\n\tint i, j, ret, len, page_len;\n\tu32 cmd;\n\tu32 data[2];\n\n\ti2c = i2c_get_adapdata(adap);\n\n\tfor (i = 0; i < num; i++) {\n\t\tpmsg = &msgs[i];\n\n\t\t \n\t\tret = mtk_i2c_wait_idle(i2c);\n\t\tif (ret)\n\t\t\tgoto err_timeout;\n\n\t\t \n\t\tret = mtk_i2c_master_start(i2c);\n\t\tif (ret)\n\t\t\tgoto err_timeout;\n\n\t\t \n\t\tif (pmsg->flags & I2C_M_TEN) {\n\t\t\t \n\t\t\taddr = 0xf0 | ((pmsg->addr >> 7) & 0x06);\n\t\t\taddr |= (pmsg->addr & 0xff) << 8;\n\t\t\tif (pmsg->flags & I2C_M_RD)\n\t\t\t\taddr |= 1;\n\t\t\tiowrite32(addr, i2c->base + REG_SM0D0_REG);\n\t\t\tret = mtk_i2c_master_cmd(i2c, SM0CTL1_WRITE, 2);\n\t\t\tif (ret)\n\t\t\t\tgoto err_timeout;\n\t\t} else {\n\t\t\t \n\t\t\taddr = i2c_8bit_addr_from_msg(pmsg);\n\t\t\tiowrite32(addr, i2c->base + REG_SM0D0_REG);\n\t\t\tret = mtk_i2c_master_cmd(i2c, SM0CTL1_WRITE, 1);\n\t\t\tif (ret)\n\t\t\t\tgoto err_timeout;\n\t\t}\n\n\t\t \n\t\tif (!(pmsg->flags & I2C_M_IGNORE_NAK)) {\n\t\t\tret = mtk_i2c_check_ack(i2c, BIT(0));\n\t\t\tif (ret)\n\t\t\t\tgoto err_ack;\n\t\t}\n\n\t\t \n\t\tfor (len = pmsg->len, j = 0; len > 0; len -= 8, j += 8) {\n\t\t\tpage_len = (len >= 8) ? 8 : len;\n\n\t\t\tif (pmsg->flags & I2C_M_RD) {\n\t\t\t\tcmd = (len > 8) ?\n\t\t\t\t\tSM0CTL1_READ : SM0CTL1_READ_LAST;\n\t\t\t} else {\n\t\t\t\tmemcpy(data, &pmsg->buf[j], page_len);\n\t\t\t\tiowrite32(data[0], i2c->base + REG_SM0D0_REG);\n\t\t\t\tiowrite32(data[1], i2c->base + REG_SM0D1_REG);\n\t\t\t\tcmd = SM0CTL1_WRITE;\n\t\t\t}\n\n\t\t\tret = mtk_i2c_master_cmd(i2c, cmd, page_len);\n\t\t\tif (ret)\n\t\t\t\tgoto err_timeout;\n\n\t\t\tif (pmsg->flags & I2C_M_RD) {\n\t\t\t\tdata[0] = ioread32(i2c->base + REG_SM0D0_REG);\n\t\t\t\tdata[1] = ioread32(i2c->base + REG_SM0D1_REG);\n\t\t\t\tmemcpy(&pmsg->buf[j], data, page_len);\n\t\t\t} else {\n\t\t\t\tif (!(pmsg->flags & I2C_M_IGNORE_NAK)) {\n\t\t\t\t\tret = mtk_i2c_check_ack(i2c,\n\t\t\t\t\t\t\t\t(1 << page_len)\n\t\t\t\t\t\t\t\t- 1);\n\t\t\t\t\tif (ret)\n\t\t\t\t\t\tgoto err_ack;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tret = mtk_i2c_master_stop(i2c);\n\tif (ret)\n\t\tgoto err_timeout;\n\n\t \n\treturn i;\n\nerr_ack:\n\tret = mtk_i2c_master_stop(i2c);\n\tif (ret)\n\t\tgoto err_timeout;\n\treturn -ENXIO;\n\nerr_timeout:\n\tmtk_i2c_dump_reg(i2c);\n\tmtk_i2c_reset(i2c);\n\treturn ret;\n}\n\nstatic u32 mtk_i2c_func(struct i2c_adapter *a)\n{\n\treturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL | I2C_FUNC_PROTOCOL_MANGLING;\n}\n\nstatic const struct i2c_algorithm mtk_i2c_algo = {\n\t.master_xfer\t= mtk_i2c_master_xfer,\n\t.functionality\t= mtk_i2c_func,\n};\n\nstatic const struct of_device_id i2c_mtk_dt_ids[] = {\n\t{ .compatible = \"mediatek,mt7621-i2c\" },\n\t{   }\n};\n\nMODULE_DEVICE_TABLE(of, i2c_mtk_dt_ids);\n\nstatic void mtk_i2c_init(struct mtk_i2c *i2c)\n{\n\ti2c->clk_div = clk_get_rate(i2c->clk) / i2c->bus_freq - 1;\n\tif (i2c->clk_div < 99)\n\t\ti2c->clk_div = 99;\n\tif (i2c->clk_div > SM0CTL0_CLK_DIV_MAX)\n\t\ti2c->clk_div = SM0CTL0_CLK_DIV_MAX;\n\n\tmtk_i2c_reset(i2c);\n}\n\nstatic int mtk_i2c_probe(struct platform_device *pdev)\n{\n\tstruct mtk_i2c *i2c;\n\tstruct i2c_adapter *adap;\n\tint ret;\n\n\ti2c = devm_kzalloc(&pdev->dev, sizeof(struct mtk_i2c), GFP_KERNEL);\n\tif (!i2c)\n\t\treturn -ENOMEM;\n\n\ti2c->base = devm_platform_get_and_ioremap_resource(pdev, 0, NULL);\n\tif (IS_ERR(i2c->base))\n\t\treturn PTR_ERR(i2c->base);\n\n\ti2c->clk = devm_clk_get_enabled(&pdev->dev, NULL);\n\tif (IS_ERR(i2c->clk)) {\n\t\tdev_err(&pdev->dev, \"Failed to enable clock\\n\");\n\t\treturn PTR_ERR(i2c->clk);\n\t}\n\n\ti2c->dev = &pdev->dev;\n\n\tif (of_property_read_u32(pdev->dev.of_node, \"clock-frequency\",\n\t\t\t\t &i2c->bus_freq))\n\t\ti2c->bus_freq = I2C_MAX_STANDARD_MODE_FREQ;\n\n\tif (i2c->bus_freq == 0) {\n\t\tdev_warn(i2c->dev, \"clock-frequency 0 not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tadap = &i2c->adap;\n\tadap->owner = THIS_MODULE;\n\tadap->algo = &mtk_i2c_algo;\n\tadap->retries = 3;\n\tadap->dev.parent = &pdev->dev;\n\ti2c_set_adapdata(adap, i2c);\n\tadap->dev.of_node = pdev->dev.of_node;\n\tstrscpy(adap->name, dev_name(&pdev->dev), sizeof(adap->name));\n\n\tplatform_set_drvdata(pdev, i2c);\n\n\tmtk_i2c_init(i2c);\n\n\tret = i2c_add_adapter(adap);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdev_info(&pdev->dev, \"clock %u kHz\\n\", i2c->bus_freq / 1000);\n\n\treturn 0;\n}\n\nstatic void mtk_i2c_remove(struct platform_device *pdev)\n{\n\tstruct mtk_i2c *i2c = platform_get_drvdata(pdev);\n\n\ti2c_del_adapter(&i2c->adap);\n}\n\nstatic struct platform_driver mtk_i2c_driver = {\n\t.probe\t\t= mtk_i2c_probe,\n\t.remove_new\t= mtk_i2c_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"i2c-mt7621\",\n\t\t.of_match_table = i2c_mtk_dt_ids,\n\t},\n};\n\nmodule_platform_driver(mtk_i2c_driver);\n\nMODULE_AUTHOR(\"Steven Liu\");\nMODULE_DESCRIPTION(\"MT7621 I2C host driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:MT7621-I2C\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}