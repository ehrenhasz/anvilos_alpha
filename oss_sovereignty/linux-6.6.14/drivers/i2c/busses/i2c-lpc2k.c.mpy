{
  "module_name": "i2c-lpc2k.c",
  "hash_id": "8f9b733964d24d4494c139de00caf68a6be3095ab064d404af1983bfc6ff8a3e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-lpc2k.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/errno.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n\n \n#define LPC24XX_I2CONSET\t0x00\n#define LPC24XX_I2STAT\t\t0x04\n#define LPC24XX_I2DAT\t\t0x08\n#define LPC24XX_I2ADDR\t\t0x0c\n#define LPC24XX_I2SCLH\t\t0x10\n#define LPC24XX_I2SCLL\t\t0x14\n#define LPC24XX_I2CONCLR\t0x18\n\n#define LPC24XX_AA\t\tBIT(2)\n#define LPC24XX_SI\t\tBIT(3)\n#define LPC24XX_STO\t\tBIT(4)\n#define LPC24XX_STA\t\tBIT(5)\n#define LPC24XX_I2EN\t\tBIT(6)\n\n#define LPC24XX_STO_AA\t\t(LPC24XX_STO | LPC24XX_AA)\n#define LPC24XX_CLEAR_ALL\t(LPC24XX_AA | LPC24XX_SI | LPC24XX_STO | \\\n\t\t\t\t LPC24XX_STA | LPC24XX_I2EN)\n\n \n#define I2C_STD_MODE_DUTY\t\t46\n#define I2C_FAST_MODE_DUTY\t\t36\n#define I2C_FAST_MODE_PLUS_DUTY\t\t38\n\n \nenum {\n\tM_BUS_ERROR\t\t= 0x00,\n\tM_START\t\t\t= 0x08,\n\tM_REPSTART\t\t= 0x10,\n\tMX_ADDR_W_ACK\t\t= 0x18,\n\tMX_ADDR_W_NACK\t\t= 0x20,\n\tMX_DATA_W_ACK\t\t= 0x28,\n\tMX_DATA_W_NACK\t\t= 0x30,\n\tM_DATA_ARB_LOST\t\t= 0x38,\n\tMR_ADDR_R_ACK\t\t= 0x40,\n\tMR_ADDR_R_NACK\t\t= 0x48,\n\tMR_DATA_R_ACK\t\t= 0x50,\n\tMR_DATA_R_NACK\t\t= 0x58,\n\tM_I2C_IDLE\t\t= 0xf8,\n};\n\nstruct lpc2k_i2c {\n\tvoid __iomem\t\t*base;\n\tstruct clk\t\t*clk;\n\tint\t\t\tirq;\n\twait_queue_head_t\twait;\n\tstruct i2c_adapter\tadap;\n\tstruct i2c_msg\t\t*msg;\n\tint\t\t\tmsg_idx;\n\tint\t\t\tmsg_status;\n\tint\t\t\tis_last;\n};\n\nstatic void i2c_lpc2k_reset(struct lpc2k_i2c *i2c)\n{\n\t \n\twritel(LPC24XX_CLEAR_ALL, i2c->base + LPC24XX_I2CONCLR);\n\twritel(0, i2c->base + LPC24XX_I2ADDR);\n\twritel(LPC24XX_I2EN, i2c->base + LPC24XX_I2CONSET);\n}\n\nstatic int i2c_lpc2k_clear_arb(struct lpc2k_i2c *i2c)\n{\n\tunsigned long timeout = jiffies + msecs_to_jiffies(1000);\n\n\t \n\twritel(LPC24XX_STO, i2c->base + LPC24XX_I2CONSET);\n\n\t \n\twhile (readl(i2c->base + LPC24XX_I2STAT) != M_I2C_IDLE) {\n\t\tif (time_after(jiffies, timeout)) {\n\t\t\t \n\t\t\ti2c_lpc2k_reset(i2c);\n\t\t\treturn -EBUSY;\n\t\t}\n\n\t\tcpu_relax();\n\t}\n\n\treturn 0;\n}\n\nstatic void i2c_lpc2k_pump_msg(struct lpc2k_i2c *i2c)\n{\n\tunsigned char data;\n\tu32 status;\n\n\t \n\tstatus = readl(i2c->base + LPC24XX_I2STAT);\n\n\tswitch (status) {\n\tcase M_START:\n\tcase M_REPSTART:\n\t\t \n\t\tdata = i2c_8bit_addr_from_msg(i2c->msg);\n\n\t\twritel(data, i2c->base + LPC24XX_I2DAT);\n\t\twritel(LPC24XX_STA, i2c->base + LPC24XX_I2CONCLR);\n\t\tbreak;\n\n\tcase MX_ADDR_W_ACK:\n\tcase MX_DATA_W_ACK:\n\t\t \n\t\tif (i2c->msg_idx < i2c->msg->len) {\n\t\t\twritel(i2c->msg->buf[i2c->msg_idx],\n\t\t\t       i2c->base + LPC24XX_I2DAT);\n\t\t} else if (i2c->is_last) {\n\t\t\t \n\t\t\twritel(LPC24XX_STO_AA, i2c->base + LPC24XX_I2CONSET);\n\t\t\twritel(LPC24XX_SI, i2c->base + LPC24XX_I2CONCLR);\n\t\t\ti2c->msg_status = 0;\n\t\t\tdisable_irq_nosync(i2c->irq);\n\t\t} else {\n\t\t\ti2c->msg_status = 0;\n\t\t\tdisable_irq_nosync(i2c->irq);\n\t\t}\n\n\t\ti2c->msg_idx++;\n\t\tbreak;\n\n\tcase MR_ADDR_R_ACK:\n\t\t \n\t\tif (i2c->msg->len == 1) {\n\t\t\t \n\t\t\twritel(LPC24XX_AA, i2c->base + LPC24XX_I2CONCLR);\n\t\t} else {\n\t\t\t \n\t\t\twritel(LPC24XX_AA, i2c->base + LPC24XX_I2CONSET);\n\t\t}\n\n\t\twritel(LPC24XX_STA, i2c->base + LPC24XX_I2CONCLR);\n\t\tbreak;\n\n\tcase MR_DATA_R_NACK:\n\t\t \n\tcase MR_DATA_R_ACK:\n\t\t \n\t\tif (i2c->msg_idx < i2c->msg->len) {\n\t\t\ti2c->msg->buf[i2c->msg_idx] =\n\t\t\t\t\treadl(i2c->base + LPC24XX_I2DAT);\n\t\t}\n\n\t\t \n\t\tif (i2c->msg_idx >= i2c->msg->len - 1 && i2c->is_last) {\n\t\t\twritel(LPC24XX_STO_AA, i2c->base + LPC24XX_I2CONSET);\n\t\t\twritel(LPC24XX_SI, i2c->base + LPC24XX_I2CONCLR);\n\t\t\ti2c->msg_status = 0;\n\t\t}\n\n\t\t \n\t\tif (i2c->msg_idx >= i2c->msg->len - 1) {\n\t\t\ti2c->msg_status = 0;\n\t\t\tdisable_irq_nosync(i2c->irq);\n\t\t}\n\n\t\t \n\t\tif (i2c->msg_idx >= i2c->msg->len - 2) {\n\t\t\t \n\t\t\twritel(LPC24XX_AA, i2c->base + LPC24XX_I2CONCLR);\n\t\t} else {\n\t\t\t \n\t\t\twritel(LPC24XX_AA, i2c->base + LPC24XX_I2CONSET);\n\t\t}\n\n\t\twritel(LPC24XX_STA, i2c->base + LPC24XX_I2CONCLR);\n\t\ti2c->msg_idx++;\n\t\tbreak;\n\n\tcase MX_ADDR_W_NACK:\n\tcase MX_DATA_W_NACK:\n\tcase MR_ADDR_R_NACK:\n\t\t \n\t\twritel(LPC24XX_STO_AA, i2c->base + LPC24XX_I2CONSET);\n\t\ti2c->msg_status = -ENXIO;\n\t\tdisable_irq_nosync(i2c->irq);\n\t\tbreak;\n\n\tcase M_DATA_ARB_LOST:\n\t\t \n\t\ti2c->msg_status = -EAGAIN;\n\n\t\t \n\t\twritel(LPC24XX_STA | LPC24XX_STO, i2c->base + LPC24XX_I2CONCLR);\n\t\tdisable_irq_nosync(i2c->irq);\n\t\tbreak;\n\n\tdefault:\n\t\t \n\t\ti2c->msg_status = -EIO;\n\t\tdisable_irq_nosync(i2c->irq);\n\t\tbreak;\n\t}\n\n\t \n\tif (i2c->msg_status != -EBUSY)\n\t\twake_up(&i2c->wait);\n\n\t \n\tif (i2c->msg_status != 0)\n\t\twritel(LPC24XX_SI, i2c->base + LPC24XX_I2CONCLR);\n}\n\nstatic int lpc2k_process_msg(struct lpc2k_i2c *i2c, int msgidx)\n{\n\t \n\tif (!msgidx) {\n\t\twritel(LPC24XX_STA, i2c->base + LPC24XX_I2CONSET);\n\t} else {\n\t\t \n\t\tif (unlikely(i2c->msg->flags & I2C_M_NOSTART)) {\n\t\t\tWARN_ON(i2c->msg->len == 0);\n\n\t\t\tif (!(i2c->msg->flags & I2C_M_RD)) {\n\t\t\t\t \n\t\t\t\twritel(i2c->msg->buf[0],\n\t\t\t\t       i2c->base + LPC24XX_I2DAT);\n\t\t\t\ti2c->msg_idx++;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\twritel(LPC24XX_STA, i2c->base + LPC24XX_I2CONSET);\n\t\t}\n\n\t\twritel(LPC24XX_SI, i2c->base + LPC24XX_I2CONCLR);\n\t}\n\n\tenable_irq(i2c->irq);\n\n\t \n\tif (wait_event_timeout(i2c->wait, i2c->msg_status != -EBUSY,\n\t\t\t       msecs_to_jiffies(1000)) == 0) {\n\t\tdisable_irq_nosync(i2c->irq);\n\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn i2c->msg_status;\n}\n\nstatic int i2c_lpc2k_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs,\n\t\t\t  int msg_num)\n{\n\tstruct lpc2k_i2c *i2c = i2c_get_adapdata(adap);\n\tint ret, i;\n\tu32 stat;\n\n\t \n\tstat = readl(i2c->base + LPC24XX_I2STAT);\n\tif (stat != M_I2C_IDLE) {\n\t\t \n\t\treturn i2c_lpc2k_clear_arb(i2c);\n\t}\n\n\t \n\tfor (i = 0; i < msg_num; i++) {\n\t\t \n\t\ti2c->msg = &msgs[i];\n\t\ti2c->msg_idx = 0;\n\t\ti2c->msg_status = -EBUSY;\n\t\ti2c->is_last = (i == (msg_num - 1));\n\n\t\tret = lpc2k_process_msg(i2c, i);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn msg_num;\n}\n\nstatic irqreturn_t i2c_lpc2k_handler(int irq, void *dev_id)\n{\n\tstruct lpc2k_i2c *i2c = dev_id;\n\n\tif (readl(i2c->base + LPC24XX_I2CONSET) & LPC24XX_SI) {\n\t\ti2c_lpc2k_pump_msg(i2c);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\treturn IRQ_NONE;\n}\n\nstatic u32 i2c_lpc2k_functionality(struct i2c_adapter *adap)\n{\n\t \n\treturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;\n}\n\nstatic const struct i2c_algorithm i2c_lpc2k_algorithm = {\n\t.master_xfer\t= i2c_lpc2k_xfer,\n\t.functionality\t= i2c_lpc2k_functionality,\n};\n\nstatic int i2c_lpc2k_probe(struct platform_device *pdev)\n{\n\tstruct lpc2k_i2c *i2c;\n\tu32 bus_clk_rate;\n\tu32 scl_high;\n\tu32 clkrate;\n\tint ret;\n\n\ti2c = devm_kzalloc(&pdev->dev, sizeof(*i2c), GFP_KERNEL);\n\tif (!i2c)\n\t\treturn -ENOMEM;\n\n\ti2c->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(i2c->base))\n\t\treturn PTR_ERR(i2c->base);\n\n\ti2c->irq = platform_get_irq(pdev, 0);\n\tif (i2c->irq < 0)\n\t\treturn i2c->irq;\n\n\tinit_waitqueue_head(&i2c->wait);\n\n\ti2c->clk = devm_clk_get_enabled(&pdev->dev, NULL);\n\tif (IS_ERR(i2c->clk)) {\n\t\tdev_err(&pdev->dev, \"failed to enable clock.\\n\");\n\t\treturn PTR_ERR(i2c->clk);\n\t}\n\n\tret = devm_request_irq(&pdev->dev, i2c->irq, i2c_lpc2k_handler, 0,\n\t\t\t       dev_name(&pdev->dev), i2c);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"can't request interrupt.\\n\");\n\t\treturn ret;\n\t}\n\n\tdisable_irq_nosync(i2c->irq);\n\n\t \n\ti2c_lpc2k_reset(i2c);\n\n\tret = of_property_read_u32(pdev->dev.of_node, \"clock-frequency\",\n\t\t\t\t   &bus_clk_rate);\n\tif (ret)\n\t\tbus_clk_rate = I2C_MAX_STANDARD_MODE_FREQ;\n\n\tclkrate = clk_get_rate(i2c->clk);\n\tif (clkrate == 0) {\n\t\tdev_err(&pdev->dev, \"can't get I2C base clock\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tclkrate = clkrate / bus_clk_rate;\n\tif (bus_clk_rate <= I2C_MAX_STANDARD_MODE_FREQ)\n\t\tscl_high = (clkrate * I2C_STD_MODE_DUTY) / 100;\n\telse if (bus_clk_rate <= I2C_MAX_FAST_MODE_FREQ)\n\t\tscl_high = (clkrate * I2C_FAST_MODE_DUTY) / 100;\n\telse\n\t\tscl_high = (clkrate * I2C_FAST_MODE_PLUS_DUTY) / 100;\n\n\twritel(scl_high, i2c->base + LPC24XX_I2SCLH);\n\twritel(clkrate - scl_high, i2c->base + LPC24XX_I2SCLL);\n\n\tplatform_set_drvdata(pdev, i2c);\n\n\ti2c_set_adapdata(&i2c->adap, i2c);\n\ti2c->adap.owner = THIS_MODULE;\n\tstrscpy(i2c->adap.name, \"LPC2K I2C adapter\", sizeof(i2c->adap.name));\n\ti2c->adap.algo = &i2c_lpc2k_algorithm;\n\ti2c->adap.dev.parent = &pdev->dev;\n\ti2c->adap.dev.of_node = pdev->dev.of_node;\n\n\tret = i2c_add_adapter(&i2c->adap);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdev_info(&pdev->dev, \"LPC2K I2C adapter\\n\");\n\n\treturn 0;\n}\n\nstatic void i2c_lpc2k_remove(struct platform_device *dev)\n{\n\tstruct lpc2k_i2c *i2c = platform_get_drvdata(dev);\n\n\ti2c_del_adapter(&i2c->adap);\n}\n\nstatic int i2c_lpc2k_suspend(struct device *dev)\n{\n\tstruct lpc2k_i2c *i2c = dev_get_drvdata(dev);\n\n\tclk_disable(i2c->clk);\n\n\treturn 0;\n}\n\nstatic int i2c_lpc2k_resume(struct device *dev)\n{\n\tstruct lpc2k_i2c *i2c = dev_get_drvdata(dev);\n\n\tclk_enable(i2c->clk);\n\ti2c_lpc2k_reset(i2c);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops i2c_lpc2k_dev_pm_ops = {\n\t.suspend_noirq = i2c_lpc2k_suspend,\n\t.resume_noirq = i2c_lpc2k_resume,\n};\n\nstatic const struct of_device_id lpc2k_i2c_match[] = {\n\t{ .compatible = \"nxp,lpc1788-i2c\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, lpc2k_i2c_match);\n\nstatic struct platform_driver i2c_lpc2k_driver = {\n\t.probe\t= i2c_lpc2k_probe,\n\t.remove_new = i2c_lpc2k_remove,\n\t.driver\t= {\n\t\t.name\t\t= \"lpc2k-i2c\",\n\t\t.pm\t\t= pm_sleep_ptr(&i2c_lpc2k_dev_pm_ops),\n\t\t.of_match_table\t= lpc2k_i2c_match,\n\t},\n};\nmodule_platform_driver(i2c_lpc2k_driver);\n\nMODULE_AUTHOR(\"Kevin Wells <kevin.wells@nxp.com>\");\nMODULE_DESCRIPTION(\"I2C driver for LPC2xxx devices\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:lpc2k-i2c\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}