{
  "module_name": "i2c-owl.c",
  "hash_id": "c1caa868275a26d0dbba1258f1ad1b8bb5e88c328d4ea5007f92a60889cca2c4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-owl.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n\n \n#define OWL_I2C_REG_CTL\t\t0x0000\n#define OWL_I2C_REG_CLKDIV\t0x0004\n#define OWL_I2C_REG_STAT\t0x0008\n#define OWL_I2C_REG_ADDR\t0x000C\n#define OWL_I2C_REG_TXDAT\t0x0010\n#define OWL_I2C_REG_RXDAT\t0x0014\n#define OWL_I2C_REG_CMD\t\t0x0018\n#define OWL_I2C_REG_FIFOCTL\t0x001C\n#define OWL_I2C_REG_FIFOSTAT\t0x0020\n#define OWL_I2C_REG_DATCNT\t0x0024\n#define OWL_I2C_REG_RCNT\t0x0028\n\n \n#define OWL_I2C_CTL_RB\t\tBIT(1)\n#define OWL_I2C_CTL_GBCC(x)\t(((x) & 0x3) << 2)\n#define\tOWL_I2C_CTL_GBCC_NONE\tOWL_I2C_CTL_GBCC(0)\n#define\tOWL_I2C_CTL_GBCC_START\tOWL_I2C_CTL_GBCC(1)\n#define\tOWL_I2C_CTL_GBCC_STOP\tOWL_I2C_CTL_GBCC(2)\n#define\tOWL_I2C_CTL_GBCC_RSTART\tOWL_I2C_CTL_GBCC(3)\n#define OWL_I2C_CTL_IRQE\tBIT(5)\n#define OWL_I2C_CTL_EN\t\tBIT(7)\n#define OWL_I2C_CTL_AE\t\tBIT(8)\n#define OWL_I2C_CTL_SHSM\tBIT(10)\n\n#define OWL_I2C_DIV_FACTOR(x)\t((x) & 0xff)\n\n \n#define OWL_I2C_STAT_RACK\tBIT(0)\n#define OWL_I2C_STAT_BEB\tBIT(1)\n#define OWL_I2C_STAT_IRQP\tBIT(2)\n#define OWL_I2C_STAT_LAB\tBIT(3)\n#define OWL_I2C_STAT_STPD\tBIT(4)\n#define OWL_I2C_STAT_STAD\tBIT(5)\n#define OWL_I2C_STAT_BBB\tBIT(6)\n#define OWL_I2C_STAT_TCB\tBIT(7)\n#define OWL_I2C_STAT_LBST\tBIT(8)\n#define OWL_I2C_STAT_SAMB\tBIT(9)\n#define OWL_I2C_STAT_SRGC\tBIT(10)\n\n \n#define OWL_I2C_CMD_SBE\t\tBIT(0)\n#define OWL_I2C_CMD_RBE\t\tBIT(4)\n#define OWL_I2C_CMD_DE\t\tBIT(8)\n#define OWL_I2C_CMD_NS\t\tBIT(9)\n#define OWL_I2C_CMD_SE\t\tBIT(10)\n#define OWL_I2C_CMD_MSS\t\tBIT(11)\n#define OWL_I2C_CMD_WRS\t\tBIT(12)\n#define OWL_I2C_CMD_SECL\tBIT(15)\n\n#define OWL_I2C_CMD_AS(x)\t(((x) & 0x7) << 1)\n#define OWL_I2C_CMD_SAS(x)\t(((x) & 0x7) << 5)\n\n \n#define OWL_I2C_FIFOCTL_NIB\tBIT(0)\n#define OWL_I2C_FIFOCTL_RFR\tBIT(1)\n#define OWL_I2C_FIFOCTL_TFR\tBIT(2)\n\n \n#define OWL_I2C_FIFOSTAT_CECB\tBIT(0)\n#define OWL_I2C_FIFOSTAT_RNB\tBIT(1)\n#define OWL_I2C_FIFOSTAT_RFE\tBIT(2)\n#define OWL_I2C_FIFOSTAT_TFF\tBIT(5)\n#define OWL_I2C_FIFOSTAT_TFD\tGENMASK(23, 16)\n#define OWL_I2C_FIFOSTAT_RFD\tGENMASK(15, 8)\n\n \n#define OWL_I2C_TIMEOUT_MS\t(4 * 1000)\n#define OWL_I2C_TIMEOUT\t\tmsecs_to_jiffies(OWL_I2C_TIMEOUT_MS)\n\n#define OWL_I2C_MAX_RETRIES\t50\n\nstruct owl_i2c_dev {\n\tstruct i2c_adapter\tadap;\n\tstruct i2c_msg\t\t*msg;\n\tstruct completion\tmsg_complete;\n\tstruct clk\t\t*clk;\n\tspinlock_t\t\tlock;\n\tvoid __iomem\t\t*base;\n\tunsigned long\t\tclk_rate;\n\tu32\t\t\tbus_freq;\n\tu32\t\t\tmsg_ptr;\n\tint\t\t\terr;\n};\n\nstatic void owl_i2c_update_reg(void __iomem *reg, unsigned int val, bool state)\n{\n\tunsigned int regval;\n\n\tregval = readl(reg);\n\n\tif (state)\n\t\tregval |= val;\n\telse\n\t\tregval &= ~val;\n\n\twritel(regval, reg);\n}\n\nstatic void owl_i2c_reset(struct owl_i2c_dev *i2c_dev)\n{\n\towl_i2c_update_reg(i2c_dev->base + OWL_I2C_REG_CTL,\n\t\t\t   OWL_I2C_CTL_EN, false);\n\tmdelay(1);\n\towl_i2c_update_reg(i2c_dev->base + OWL_I2C_REG_CTL,\n\t\t\t   OWL_I2C_CTL_EN, true);\n\n\t \n\twritel(0, i2c_dev->base + OWL_I2C_REG_STAT);\n}\n\nstatic int owl_i2c_reset_fifo(struct owl_i2c_dev *i2c_dev)\n{\n\tunsigned int val, timeout = 0;\n\n\t \n\towl_i2c_update_reg(i2c_dev->base + OWL_I2C_REG_FIFOCTL,\n\t\t\t   OWL_I2C_FIFOCTL_RFR | OWL_I2C_FIFOCTL_TFR,\n\t\t\t   true);\n\n\t \n\tdo {\n\t\tval = readl(i2c_dev->base + OWL_I2C_REG_FIFOCTL);\n\t\tif (!(val & (OWL_I2C_FIFOCTL_RFR | OWL_I2C_FIFOCTL_TFR)))\n\t\t\tbreak;\n\t\tusleep_range(500, 1000);\n\t} while (timeout++ < OWL_I2C_MAX_RETRIES);\n\n\tif (timeout > OWL_I2C_MAX_RETRIES) {\n\t\tdev_err(&i2c_dev->adap.dev, \"FIFO reset timeout\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\n}\n\nstatic void owl_i2c_set_freq(struct owl_i2c_dev *i2c_dev)\n{\n\tunsigned int val;\n\n\tval = DIV_ROUND_UP(i2c_dev->clk_rate, i2c_dev->bus_freq * 16);\n\n\t \n\twritel(OWL_I2C_DIV_FACTOR(val), i2c_dev->base + OWL_I2C_REG_CLKDIV);\n}\n\nstatic void owl_i2c_xfer_data(struct owl_i2c_dev *i2c_dev)\n{\n\tstruct i2c_msg *msg = i2c_dev->msg;\n\tunsigned int stat, fifostat;\n\n\ti2c_dev->err = 0;\n\n\t \n\tfifostat = readl(i2c_dev->base + OWL_I2C_REG_FIFOSTAT);\n\tif (fifostat & OWL_I2C_FIFOSTAT_RNB) {\n\t\ti2c_dev->err = -ENXIO;\n\t\t \n\t\towl_i2c_update_reg(i2c_dev->base + OWL_I2C_REG_FIFOSTAT,\n\t\t\t\t   OWL_I2C_FIFOSTAT_RNB, true);\n\t\treturn;\n\t}\n\n\t \n\tstat = readl(i2c_dev->base + OWL_I2C_REG_STAT);\n\tif (stat & OWL_I2C_STAT_BEB) {\n\t\ti2c_dev->err = -EIO;\n\t\t \n\t\towl_i2c_update_reg(i2c_dev->base + OWL_I2C_REG_STAT,\n\t\t\t\t   OWL_I2C_STAT_BEB, true);\n\t\treturn;\n\t}\n\n\t \n\tif (msg->flags & I2C_M_RD) {\n\t\twhile ((readl(i2c_dev->base + OWL_I2C_REG_FIFOSTAT) &\n\t\t\tOWL_I2C_FIFOSTAT_RFE) && i2c_dev->msg_ptr < msg->len) {\n\t\t\tmsg->buf[i2c_dev->msg_ptr++] = readl(i2c_dev->base +\n\t\t\t\t\t\t\t     OWL_I2C_REG_RXDAT);\n\t\t}\n\t} else {\n\t\t \n\t\twhile (!(readl(i2c_dev->base + OWL_I2C_REG_FIFOSTAT) &\n\t\t\t OWL_I2C_FIFOSTAT_TFF) && i2c_dev->msg_ptr < msg->len) {\n\t\t\twritel(msg->buf[i2c_dev->msg_ptr++],\n\t\t\t       i2c_dev->base + OWL_I2C_REG_TXDAT);\n\t\t}\n\t}\n}\n\nstatic irqreturn_t owl_i2c_interrupt(int irq, void *_dev)\n{\n\tstruct owl_i2c_dev *i2c_dev = _dev;\n\n\tspin_lock(&i2c_dev->lock);\n\n\towl_i2c_xfer_data(i2c_dev);\n\n\t \n\towl_i2c_update_reg(i2c_dev->base + OWL_I2C_REG_STAT,\n\t\t\t   OWL_I2C_STAT_IRQP, true);\n\n\tcomplete_all(&i2c_dev->msg_complete);\n\tspin_unlock(&i2c_dev->lock);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic u32 owl_i2c_func(struct i2c_adapter *adap)\n{\n\treturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;\n}\n\nstatic int owl_i2c_check_bus_busy(struct i2c_adapter *adap)\n{\n\tstruct owl_i2c_dev *i2c_dev = i2c_get_adapdata(adap);\n\tunsigned long timeout;\n\n\t \n\ttimeout = jiffies + OWL_I2C_TIMEOUT;\n\twhile (readl(i2c_dev->base + OWL_I2C_REG_STAT) & OWL_I2C_STAT_BBB) {\n\t\tif (time_after(jiffies, timeout)) {\n\t\t\tdev_err(&adap->dev, \"Bus busy timeout\\n\");\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int owl_i2c_xfer_common(struct i2c_adapter *adap, struct i2c_msg *msgs,\n\t\t\t       int num, bool atomic)\n{\n\tstruct owl_i2c_dev *i2c_dev = i2c_get_adapdata(adap);\n\tstruct i2c_msg *msg;\n\tunsigned long time_left, flags;\n\tunsigned int i2c_cmd, val;\n\tunsigned int addr;\n\tint ret, idx;\n\n\tspin_lock_irqsave(&i2c_dev->lock, flags);\n\n\t \n\towl_i2c_reset(i2c_dev);\n\n\t \n\towl_i2c_set_freq(i2c_dev);\n\n\t \n\tspin_unlock_irqrestore(&i2c_dev->lock, flags);\n\n\t \n\tret = owl_i2c_reset_fifo(i2c_dev);\n\tif (ret)\n\t\tgoto unlocked_err_exit;\n\n\t \n\tret = owl_i2c_check_bus_busy(adap);\n\tif (ret)\n\t\tgoto unlocked_err_exit;\n\n\tspin_lock_irqsave(&i2c_dev->lock, flags);\n\n\t \n\tval = readl(i2c_dev->base + OWL_I2C_REG_STAT);\n\tif (val & OWL_I2C_STAT_LAB) {\n\t\tval &= ~OWL_I2C_STAT_LAB;\n\t\twritel(val, i2c_dev->base + OWL_I2C_REG_STAT);\n\t\tret = -EAGAIN;\n\t\tgoto err_exit;\n\t}\n\n\tif (!atomic)\n\t\treinit_completion(&i2c_dev->msg_complete);\n\n\t \n\towl_i2c_update_reg(i2c_dev->base + OWL_I2C_REG_CTL,\n\t\t\t   OWL_I2C_CTL_IRQE, !atomic);\n\n\t \n\ti2c_cmd = OWL_I2C_CMD_SECL | OWL_I2C_CMD_MSS | OWL_I2C_CMD_SE |\n\t\t  OWL_I2C_CMD_NS | OWL_I2C_CMD_DE | OWL_I2C_CMD_SBE;\n\n\t \n\tif (num > 1) {\n\t\t \n\t\ti2c_cmd |= OWL_I2C_CMD_AS(msgs[0].len + 1) |\n\t\t\t   OWL_I2C_CMD_SAS(1) | OWL_I2C_CMD_RBE;\n\n\t\t \n\t\taddr = i2c_8bit_addr_from_msg(&msgs[0]);\n\t\twritel(addr, i2c_dev->base + OWL_I2C_REG_TXDAT);\n\n\t\t \n\t\tfor (idx = 0; idx < msgs[0].len; idx++)\n\t\t\twritel(msgs[0].buf[idx],\n\t\t\t       i2c_dev->base + OWL_I2C_REG_TXDAT);\n\n\t\tmsg = &msgs[1];\n\t} else {\n\t\t \n\t\ti2c_cmd |= OWL_I2C_CMD_AS(1);\n\t\tmsg = &msgs[0];\n\t}\n\n\ti2c_dev->msg = msg;\n\ti2c_dev->msg_ptr = 0;\n\n\t \n\twritel(msg->len, i2c_dev->base + OWL_I2C_REG_DATCNT);\n\n\taddr = i2c_8bit_addr_from_msg(msg);\n\twritel(addr, i2c_dev->base + OWL_I2C_REG_TXDAT);\n\n\tif (!(msg->flags & I2C_M_RD)) {\n\t\t \n\t\tfor (idx = 0; idx < msg->len; idx++) {\n\t\t\t \n\t\t\tif (readl(i2c_dev->base + OWL_I2C_REG_FIFOSTAT) &\n\t\t\t    OWL_I2C_FIFOSTAT_TFF)\n\t\t\t\tbreak;\n\n\t\t\twritel(msg->buf[idx],\n\t\t\t       i2c_dev->base + OWL_I2C_REG_TXDAT);\n\t\t}\n\n\t\ti2c_dev->msg_ptr = idx;\n\t}\n\n\t \n\tif (msg->flags & I2C_M_IGNORE_NAK)\n\t\towl_i2c_update_reg(i2c_dev->base + OWL_I2C_REG_FIFOCTL,\n\t\t\t\t   OWL_I2C_FIFOCTL_NIB, true);\n\telse\n\t\towl_i2c_update_reg(i2c_dev->base + OWL_I2C_REG_FIFOCTL,\n\t\t\t\t   OWL_I2C_FIFOCTL_NIB, false);\n\n\t \n\twritel(i2c_cmd, i2c_dev->base + OWL_I2C_REG_CMD);\n\n\tspin_unlock_irqrestore(&i2c_dev->lock, flags);\n\n\tif (atomic) {\n\t\t \n\t\tret = readl_poll_timeout_atomic(i2c_dev->base + OWL_I2C_REG_FIFOSTAT,\n\t\t\t\t\t\tval, val & (OWL_I2C_FIFOSTAT_CECB |\n\t\t\t\t\t\t\t    OWL_I2C_FIFOSTAT_RNB),\n\t\t\t\t\t\t10, OWL_I2C_TIMEOUT_MS * 1000);\n\t} else {\n\t\ttime_left = wait_for_completion_timeout(&i2c_dev->msg_complete,\n\t\t\t\t\t\t\tadap->timeout);\n\t\tif (!time_left)\n\t\t\tret = -ETIMEDOUT;\n\t}\n\n\tspin_lock_irqsave(&i2c_dev->lock, flags);\n\n\tif (ret) {\n\t\tdev_err(&adap->dev, \"Transaction timed out\\n\");\n\t\t \n\t\towl_i2c_update_reg(i2c_dev->base + OWL_I2C_REG_CTL,\n\t\t\t\t   OWL_I2C_CTL_GBCC_STOP | OWL_I2C_CTL_RB,\n\t\t\t\t   true);\n\t\tgoto err_exit;\n\t}\n\n\tif (atomic)\n\t\towl_i2c_xfer_data(i2c_dev);\n\n\tret = i2c_dev->err < 0 ? i2c_dev->err : num;\n\nerr_exit:\n\tspin_unlock_irqrestore(&i2c_dev->lock, flags);\n\nunlocked_err_exit:\n\t \n\towl_i2c_update_reg(i2c_dev->base + OWL_I2C_REG_CTL,\n\t\t\t   OWL_I2C_CTL_EN, false);\n\n\treturn ret;\n}\n\nstatic int owl_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs,\n\t\t\tint num)\n{\n\treturn owl_i2c_xfer_common(adap, msgs, num, false);\n}\n\nstatic int owl_i2c_xfer_atomic(struct i2c_adapter *adap,\n\t\t\t       struct i2c_msg *msgs, int num)\n{\n\treturn owl_i2c_xfer_common(adap, msgs, num, true);\n}\n\nstatic const struct i2c_algorithm owl_i2c_algorithm = {\n\t.master_xfer\t     = owl_i2c_xfer,\n\t.master_xfer_atomic  = owl_i2c_xfer_atomic,\n\t.functionality\t     = owl_i2c_func,\n};\n\nstatic const struct i2c_adapter_quirks owl_i2c_quirks = {\n\t.flags\t\t= I2C_AQ_COMB | I2C_AQ_COMB_WRITE_FIRST,\n\t.max_read_len   = 240,\n\t.max_write_len  = 240,\n\t.max_comb_1st_msg_len = 6,\n\t.max_comb_2nd_msg_len = 240,\n};\n\nstatic int owl_i2c_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct owl_i2c_dev *i2c_dev;\n\tint ret, irq;\n\n\ti2c_dev = devm_kzalloc(dev, sizeof(*i2c_dev), GFP_KERNEL);\n\tif (!i2c_dev)\n\t\treturn -ENOMEM;\n\n\ti2c_dev->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(i2c_dev->base))\n\t\treturn PTR_ERR(i2c_dev->base);\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tif (of_property_read_u32(dev->of_node, \"clock-frequency\",\n\t\t\t\t &i2c_dev->bus_freq))\n\t\ti2c_dev->bus_freq = I2C_MAX_STANDARD_MODE_FREQ;\n\n\t \n\tif (i2c_dev->bus_freq != I2C_MAX_STANDARD_MODE_FREQ &&\n\t    i2c_dev->bus_freq != I2C_MAX_FAST_MODE_FREQ) {\n\t\tdev_err(dev, \"invalid clock-frequency %d\\n\", i2c_dev->bus_freq);\n\t\treturn -EINVAL;\n\t}\n\n\ti2c_dev->clk = devm_clk_get_enabled(dev, NULL);\n\tif (IS_ERR(i2c_dev->clk)) {\n\t\tdev_err(dev, \"failed to enable clock\\n\");\n\t\treturn PTR_ERR(i2c_dev->clk);\n\t}\n\n\ti2c_dev->clk_rate = clk_get_rate(i2c_dev->clk);\n\tif (!i2c_dev->clk_rate) {\n\t\tdev_err(dev, \"input clock rate should not be zero\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tinit_completion(&i2c_dev->msg_complete);\n\tspin_lock_init(&i2c_dev->lock);\n\ti2c_dev->adap.owner = THIS_MODULE;\n\ti2c_dev->adap.algo = &owl_i2c_algorithm;\n\ti2c_dev->adap.timeout = OWL_I2C_TIMEOUT;\n\ti2c_dev->adap.quirks = &owl_i2c_quirks;\n\ti2c_dev->adap.dev.parent = dev;\n\ti2c_dev->adap.dev.of_node = dev->of_node;\n\tsnprintf(i2c_dev->adap.name, sizeof(i2c_dev->adap.name),\n\t\t \"%s\", \"OWL I2C adapter\");\n\ti2c_set_adapdata(&i2c_dev->adap, i2c_dev);\n\n\tplatform_set_drvdata(pdev, i2c_dev);\n\n\tret = devm_request_irq(dev, irq, owl_i2c_interrupt, 0, pdev->name,\n\t\t\t       i2c_dev);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to request irq %d\\n\", irq);\n\t\treturn ret;\n\t}\n\n\treturn i2c_add_adapter(&i2c_dev->adap);\n}\n\nstatic const struct of_device_id owl_i2c_of_match[] = {\n\t{ .compatible = \"actions,s500-i2c\" },\n\t{ .compatible = \"actions,s700-i2c\" },\n\t{ .compatible = \"actions,s900-i2c\" },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, owl_i2c_of_match);\n\nstatic struct platform_driver owl_i2c_driver = {\n\t.probe\t\t= owl_i2c_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"owl-i2c\",\n\t\t.of_match_table = owl_i2c_of_match,\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t},\n};\nmodule_platform_driver(owl_i2c_driver);\n\nMODULE_AUTHOR(\"David Liu <liuwei@actions-semi.com>\");\nMODULE_AUTHOR(\"Manivannan Sadhasivam <manivannan.sadhasivam@linaro.org>\");\nMODULE_DESCRIPTION(\"Actions Semiconductor Owl SoC's I2C driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}