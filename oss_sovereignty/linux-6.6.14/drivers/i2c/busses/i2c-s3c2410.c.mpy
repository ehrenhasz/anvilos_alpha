{
  "module_name": "i2c-s3c2410.c",
  "hash_id": "c2f0fc6f8d638bd3bfb31a21cf66ca8f3715c187b4b6434edf9740489d0fbfcb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-s3c2410.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n\n#include <linux/i2c.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/clk.h>\n#include <linux/cpufreq.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/gpio/consumer.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/mfd/syscon.h>\n#include <linux/regmap.h>\n\n#include <asm/irq.h>\n\n#include <linux/platform_data/i2c-s3c2410.h>\n\n \n\n#define S3C2410_IICCON\t\t\t0x00\n#define S3C2410_IICSTAT\t\t\t0x04\n#define S3C2410_IICADD\t\t\t0x08\n#define S3C2410_IICDS\t\t\t0x0C\n#define S3C2440_IICLC\t\t\t0x10\n\n#define S3C2410_IICCON_ACKEN\t\t(1 << 7)\n#define S3C2410_IICCON_TXDIV_16\t\t(0 << 6)\n#define S3C2410_IICCON_TXDIV_512\t(1 << 6)\n#define S3C2410_IICCON_IRQEN\t\t(1 << 5)\n#define S3C2410_IICCON_IRQPEND\t\t(1 << 4)\n#define S3C2410_IICCON_SCALE(x)\t\t((x) & 0xf)\n#define S3C2410_IICCON_SCALEMASK\t(0xf)\n\n#define S3C2410_IICSTAT_MASTER_RX\t(2 << 6)\n#define S3C2410_IICSTAT_MASTER_TX\t(3 << 6)\n#define S3C2410_IICSTAT_SLAVE_RX\t(0 << 6)\n#define S3C2410_IICSTAT_SLAVE_TX\t(1 << 6)\n#define S3C2410_IICSTAT_MODEMASK\t(3 << 6)\n\n#define S3C2410_IICSTAT_START\t\t(1 << 5)\n#define S3C2410_IICSTAT_BUSBUSY\t\t(1 << 5)\n#define S3C2410_IICSTAT_TXRXEN\t\t(1 << 4)\n#define S3C2410_IICSTAT_ARBITR\t\t(1 << 3)\n#define S3C2410_IICSTAT_ASSLAVE\t\t(1 << 2)\n#define S3C2410_IICSTAT_ADDR0\t\t(1 << 1)\n#define S3C2410_IICSTAT_LASTBIT\t\t(1 << 0)\n\n#define S3C2410_IICLC_SDA_DELAY0\t(0 << 0)\n#define S3C2410_IICLC_SDA_DELAY5\t(1 << 0)\n#define S3C2410_IICLC_SDA_DELAY10\t(2 << 0)\n#define S3C2410_IICLC_SDA_DELAY15\t(3 << 0)\n#define S3C2410_IICLC_SDA_DELAY_MASK\t(3 << 0)\n\n#define S3C2410_IICLC_FILTER_ON\t\t(1 << 2)\n\n \n#define QUIRK_S3C2440\t\t(1 << 0)\n#define QUIRK_HDMIPHY\t\t(1 << 1)\n#define QUIRK_NO_GPIO\t\t(1 << 2)\n#define QUIRK_POLL\t\t(1 << 3)\n\n \n#define S3C2410_IDLE_TIMEOUT\t5000\n\n \n#define EXYNOS5_SYS_I2C_CFG\t0x0234\n\n \nenum s3c24xx_i2c_state {\n\tSTATE_IDLE,\n\tSTATE_START,\n\tSTATE_READ,\n\tSTATE_WRITE,\n\tSTATE_STOP\n};\n\nstruct s3c24xx_i2c {\n\twait_queue_head_t\twait;\n\tkernel_ulong_t\t\tquirks;\n\n\tstruct i2c_msg\t\t*msg;\n\tunsigned int\t\tmsg_num;\n\tunsigned int\t\tmsg_idx;\n\tunsigned int\t\tmsg_ptr;\n\n\tunsigned int\t\ttx_setup;\n\tunsigned int\t\tirq;\n\n\tenum s3c24xx_i2c_state\tstate;\n\tunsigned long\t\tclkrate;\n\n\tvoid __iomem\t\t*regs;\n\tstruct clk\t\t*clk;\n\tstruct device\t\t*dev;\n\tstruct i2c_adapter\tadap;\n\n\tstruct s3c2410_platform_i2c\t*pdata;\n\tstruct gpio_desc\t*gpios[2];\n\tstruct pinctrl          *pctrl;\n\tstruct regmap\t\t*sysreg;\n\tunsigned int\t\tsys_i2c_cfg;\n};\n\nstatic const struct platform_device_id s3c24xx_driver_ids[] = {\n\t{\n\t\t.name\t\t= \"s3c2410-i2c\",\n\t\t.driver_data\t= 0,\n\t}, {\n\t\t.name\t\t= \"s3c2440-i2c\",\n\t\t.driver_data\t= QUIRK_S3C2440,\n\t}, {\n\t\t.name\t\t= \"s3c2440-hdmiphy-i2c\",\n\t\t.driver_data\t= QUIRK_S3C2440 | QUIRK_HDMIPHY | QUIRK_NO_GPIO,\n\t}, { },\n};\nMODULE_DEVICE_TABLE(platform, s3c24xx_driver_ids);\n\nstatic int i2c_s3c_irq_nextbyte(struct s3c24xx_i2c *i2c, unsigned long iicstat);\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id s3c24xx_i2c_match[] = {\n\t{ .compatible = \"samsung,s3c2410-i2c\", .data = (void *)0 },\n\t{ .compatible = \"samsung,s3c2440-i2c\", .data = (void *)QUIRK_S3C2440 },\n\t{ .compatible = \"samsung,s3c2440-hdmiphy-i2c\",\n\t  .data = (void *)(QUIRK_S3C2440 | QUIRK_HDMIPHY | QUIRK_NO_GPIO) },\n\t{ .compatible = \"samsung,exynos5-sata-phy-i2c\",\n\t  .data = (void *)(QUIRK_S3C2440 | QUIRK_POLL | QUIRK_NO_GPIO) },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, s3c24xx_i2c_match);\n#endif\n\n \nstatic inline kernel_ulong_t s3c24xx_get_device_quirks(struct platform_device *pdev)\n{\n\tif (pdev->dev.of_node)\n\t\treturn (kernel_ulong_t)of_device_get_match_data(&pdev->dev);\n\n\treturn platform_get_device_id(pdev)->driver_data;\n}\n\n \nstatic inline void s3c24xx_i2c_master_complete(struct s3c24xx_i2c *i2c, int ret)\n{\n\tdev_dbg(i2c->dev, \"master_complete %d\\n\", ret);\n\n\ti2c->msg_ptr = 0;\n\ti2c->msg = NULL;\n\ti2c->msg_idx++;\n\ti2c->msg_num = 0;\n\tif (ret)\n\t\ti2c->msg_idx = ret;\n\n\tif (!(i2c->quirks & QUIRK_POLL))\n\t\twake_up(&i2c->wait);\n}\n\nstatic inline void s3c24xx_i2c_disable_ack(struct s3c24xx_i2c *i2c)\n{\n\tunsigned long tmp;\n\n\ttmp = readl(i2c->regs + S3C2410_IICCON);\n\twritel(tmp & ~S3C2410_IICCON_ACKEN, i2c->regs + S3C2410_IICCON);\n}\n\nstatic inline void s3c24xx_i2c_enable_ack(struct s3c24xx_i2c *i2c)\n{\n\tunsigned long tmp;\n\n\ttmp = readl(i2c->regs + S3C2410_IICCON);\n\twritel(tmp | S3C2410_IICCON_ACKEN, i2c->regs + S3C2410_IICCON);\n}\n\n \nstatic inline void s3c24xx_i2c_disable_irq(struct s3c24xx_i2c *i2c)\n{\n\tunsigned long tmp;\n\n\ttmp = readl(i2c->regs + S3C2410_IICCON);\n\twritel(tmp & ~S3C2410_IICCON_IRQEN, i2c->regs + S3C2410_IICCON);\n}\n\nstatic inline void s3c24xx_i2c_enable_irq(struct s3c24xx_i2c *i2c)\n{\n\tunsigned long tmp;\n\n\ttmp = readl(i2c->regs + S3C2410_IICCON);\n\twritel(tmp | S3C2410_IICCON_IRQEN, i2c->regs + S3C2410_IICCON);\n}\n\nstatic bool is_ack(struct s3c24xx_i2c *i2c)\n{\n\tint tries;\n\n\tfor (tries = 50; tries; --tries) {\n\t\tunsigned long tmp = readl(i2c->regs + S3C2410_IICCON);\n\n\t\tif (!(tmp & S3C2410_IICCON_ACKEN)) {\n\t\t\t \n\t\t\tusleep_range(100, 200);\n\t\t\treturn true;\n\t\t}\n\t\tif (tmp & S3C2410_IICCON_IRQPEND) {\n\t\t\tif (!(readl(i2c->regs + S3C2410_IICSTAT)\n\t\t\t\t& S3C2410_IICSTAT_LASTBIT))\n\t\t\t\treturn true;\n\t\t}\n\t\tusleep_range(1000, 2000);\n\t}\n\tdev_err(i2c->dev, \"ack was not received\\n\");\n\treturn false;\n}\n\n \nstatic void s3c24xx_i2c_message_start(struct s3c24xx_i2c *i2c,\n\t\t\t\t      struct i2c_msg *msg)\n{\n\tunsigned int addr = (msg->addr & 0x7f) << 1;\n\tunsigned long stat;\n\tunsigned long iiccon;\n\n\tstat = 0;\n\tstat |=  S3C2410_IICSTAT_TXRXEN;\n\n\tif (msg->flags & I2C_M_RD) {\n\t\tstat |= S3C2410_IICSTAT_MASTER_RX;\n\t\taddr |= 1;\n\t} else\n\t\tstat |= S3C2410_IICSTAT_MASTER_TX;\n\n\tif (msg->flags & I2C_M_REV_DIR_ADDR)\n\t\taddr ^= 1;\n\n\t \n\ts3c24xx_i2c_enable_ack(i2c);\n\n\tiiccon = readl(i2c->regs + S3C2410_IICCON);\n\twritel(stat, i2c->regs + S3C2410_IICSTAT);\n\n\tdev_dbg(i2c->dev, \"START: %08lx to IICSTAT, %02x to DS\\n\", stat, addr);\n\twriteb(addr, i2c->regs + S3C2410_IICDS);\n\n\t \n\tndelay(i2c->tx_setup);\n\n\tdev_dbg(i2c->dev, \"iiccon, %08lx\\n\", iiccon);\n\twritel(iiccon, i2c->regs + S3C2410_IICCON);\n\n\tstat |= S3C2410_IICSTAT_START;\n\twritel(stat, i2c->regs + S3C2410_IICSTAT);\n}\n\nstatic inline void s3c24xx_i2c_stop(struct s3c24xx_i2c *i2c, int ret)\n{\n\tunsigned long iicstat = readl(i2c->regs + S3C2410_IICSTAT);\n\n\tdev_dbg(i2c->dev, \"STOP\\n\");\n\n\t \n\tif (i2c->quirks & QUIRK_HDMIPHY) {\n\t\t \n\t\tiicstat &= ~S3C2410_IICSTAT_TXRXEN;\n\t} else {\n\t\t \n\t\tiicstat &= ~S3C2410_IICSTAT_START;\n\t}\n\twritel(iicstat, i2c->regs + S3C2410_IICSTAT);\n\n\ti2c->state = STATE_STOP;\n\n\ts3c24xx_i2c_master_complete(i2c, ret);\n\ts3c24xx_i2c_disable_irq(i2c);\n}\n\n \n\n \nstatic inline int is_lastmsg(struct s3c24xx_i2c *i2c)\n{\n\treturn i2c->msg_idx >= (i2c->msg_num - 1);\n}\n\n \nstatic inline int is_msglast(struct s3c24xx_i2c *i2c)\n{\n\t \n\tif (i2c->msg->flags & I2C_M_RECV_LEN && i2c->msg->len == 1)\n\t\treturn 0;\n\n\treturn i2c->msg_ptr == i2c->msg->len-1;\n}\n\n \nstatic inline int is_msgend(struct s3c24xx_i2c *i2c)\n{\n\treturn i2c->msg_ptr >= i2c->msg->len;\n}\n\n \nstatic int i2c_s3c_irq_nextbyte(struct s3c24xx_i2c *i2c, unsigned long iicstat)\n{\n\tunsigned long tmp;\n\tunsigned char byte;\n\tint ret = 0;\n\n\tswitch (i2c->state) {\n\n\tcase STATE_IDLE:\n\t\tdev_err(i2c->dev, \"%s: called in STATE_IDLE\\n\", __func__);\n\t\tgoto out;\n\n\tcase STATE_STOP:\n\t\tdev_err(i2c->dev, \"%s: called in STATE_STOP\\n\", __func__);\n\t\ts3c24xx_i2c_disable_irq(i2c);\n\t\tgoto out_ack;\n\n\tcase STATE_START:\n\t\t \n\t\tif (iicstat & S3C2410_IICSTAT_LASTBIT &&\n\t\t    !(i2c->msg->flags & I2C_M_IGNORE_NAK)) {\n\t\t\t \n\t\t\tdev_dbg(i2c->dev, \"ack was not received\\n\");\n\t\t\ts3c24xx_i2c_stop(i2c, -ENXIO);\n\t\t\tgoto out_ack;\n\t\t}\n\n\t\tif (i2c->msg->flags & I2C_M_RD)\n\t\t\ti2c->state = STATE_READ;\n\t\telse\n\t\t\ti2c->state = STATE_WRITE;\n\n\t\t \n\t\tif (is_lastmsg(i2c) && i2c->msg->len == 0) {\n\t\t\ts3c24xx_i2c_stop(i2c, 0);\n\t\t\tgoto out_ack;\n\t\t}\n\n\t\tif (i2c->state == STATE_READ)\n\t\t\tgoto prepare_read;\n\n\t\t \n\t\tfallthrough;\n\tcase STATE_WRITE:\n\t\t \n\t\tif (!(i2c->msg->flags & I2C_M_IGNORE_NAK)) {\n\t\t\tif (iicstat & S3C2410_IICSTAT_LASTBIT) {\n\t\t\t\tdev_dbg(i2c->dev, \"WRITE: No Ack\\n\");\n\n\t\t\t\ts3c24xx_i2c_stop(i2c, -ECONNREFUSED);\n\t\t\t\tgoto out_ack;\n\t\t\t}\n\t\t}\n\n retry_write:\n\n\t\tif (!is_msgend(i2c)) {\n\t\t\tbyte = i2c->msg->buf[i2c->msg_ptr++];\n\t\t\twriteb(byte, i2c->regs + S3C2410_IICDS);\n\n\t\t\t \n\t\t\tndelay(i2c->tx_setup);\n\n\t\t} else if (!is_lastmsg(i2c)) {\n\t\t\t \n\n\t\t\tdev_dbg(i2c->dev, \"WRITE: Next Message\\n\");\n\n\t\t\ti2c->msg_ptr = 0;\n\t\t\ti2c->msg_idx++;\n\t\t\ti2c->msg++;\n\n\t\t\t \n\t\t\tif (i2c->msg->flags & I2C_M_NOSTART) {\n\n\t\t\t\tif (i2c->msg->flags & I2C_M_RD) {\n\t\t\t\t\t \n\t\t\t\t\tdev_dbg(i2c->dev,\n\t\t\t\t\t\t\"missing START before write->read\\n\");\n\t\t\t\t\ts3c24xx_i2c_stop(i2c, -EINVAL);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tgoto retry_write;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\ts3c24xx_i2c_message_start(i2c, i2c->msg);\n\t\t\t\ti2c->state = STATE_START;\n\t\t\t}\n\n\t\t} else {\n\t\t\t \n\t\t\ts3c24xx_i2c_stop(i2c, 0);\n\t\t}\n\t\tbreak;\n\n\tcase STATE_READ:\n\t\t \n\t\tbyte = readb(i2c->regs + S3C2410_IICDS);\n\t\ti2c->msg->buf[i2c->msg_ptr++] = byte;\n\n\t\t \n\t\tif (i2c->msg->flags & I2C_M_RECV_LEN && i2c->msg->len == 1)\n\t\t\ti2c->msg->len += byte;\n prepare_read:\n\t\tif (is_msglast(i2c)) {\n\t\t\t \n\n\t\t\tif (is_lastmsg(i2c))\n\t\t\t\ts3c24xx_i2c_disable_ack(i2c);\n\n\t\t} else if (is_msgend(i2c)) {\n\t\t\t \n\t\t\tif (is_lastmsg(i2c)) {\n\t\t\t\t \n\t\t\t\tdev_dbg(i2c->dev, \"READ: Send Stop\\n\");\n\n\t\t\t\ts3c24xx_i2c_stop(i2c, 0);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tdev_dbg(i2c->dev, \"READ: Next Transfer\\n\");\n\n\t\t\t\ti2c->msg_ptr = 0;\n\t\t\t\ti2c->msg_idx++;\n\t\t\t\ti2c->msg++;\n\t\t\t}\n\t\t}\n\n\t\tbreak;\n\t}\n\n\t \n\n out_ack:\n\ttmp = readl(i2c->regs + S3C2410_IICCON);\n\ttmp &= ~S3C2410_IICCON_IRQPEND;\n\twritel(tmp, i2c->regs + S3C2410_IICCON);\n out:\n\treturn ret;\n}\n\n \nstatic irqreturn_t s3c24xx_i2c_irq(int irqno, void *dev_id)\n{\n\tstruct s3c24xx_i2c *i2c = dev_id;\n\tunsigned long status;\n\tunsigned long tmp;\n\n\tstatus = readl(i2c->regs + S3C2410_IICSTAT);\n\n\tif (status & S3C2410_IICSTAT_ARBITR) {\n\t\t \n\t\tdev_err(i2c->dev, \"deal with arbitration loss\\n\");\n\t}\n\n\tif (i2c->state == STATE_IDLE) {\n\t\tdev_dbg(i2c->dev, \"IRQ: error i2c->state == IDLE\\n\");\n\n\t\ttmp = readl(i2c->regs + S3C2410_IICCON);\n\t\ttmp &= ~S3C2410_IICCON_IRQPEND;\n\t\twritel(tmp, i2c->regs +  S3C2410_IICCON);\n\t\tgoto out;\n\t}\n\n\t \n\ti2c_s3c_irq_nextbyte(i2c, status);\n\n out:\n\treturn IRQ_HANDLED;\n}\n\n \nstatic inline void s3c24xx_i2c_disable_bus(struct s3c24xx_i2c *i2c)\n{\n\tunsigned long tmp;\n\n\t \n\ttmp = readl(i2c->regs + S3C2410_IICSTAT);\n\ttmp &= ~S3C2410_IICSTAT_TXRXEN;\n\twritel(tmp, i2c->regs + S3C2410_IICSTAT);\n\n\t \n\ttmp = readl(i2c->regs + S3C2410_IICCON);\n\ttmp &= ~(S3C2410_IICCON_IRQEN | S3C2410_IICCON_IRQPEND |\n\t\tS3C2410_IICCON_ACKEN);\n\twritel(tmp, i2c->regs + S3C2410_IICCON);\n}\n\n\n \nstatic int s3c24xx_i2c_set_master(struct s3c24xx_i2c *i2c)\n{\n\tunsigned long iicstat;\n\tint timeout = 400;\n\n\twhile (timeout-- > 0) {\n\t\tiicstat = readl(i2c->regs + S3C2410_IICSTAT);\n\n\t\tif (!(iicstat & S3C2410_IICSTAT_BUSBUSY))\n\t\t\treturn 0;\n\n\t\tmsleep(1);\n\t}\n\n\treturn -ETIMEDOUT;\n}\n\n \nstatic void s3c24xx_i2c_wait_idle(struct s3c24xx_i2c *i2c)\n{\n\tunsigned long iicstat;\n\tktime_t start, now;\n\tunsigned long delay;\n\tint spins;\n\n\t \n\n\tdev_dbg(i2c->dev, \"waiting for bus idle\\n\");\n\n\tstart = now = ktime_get();\n\n\t \n\tspins = 3;\n\tiicstat = readl(i2c->regs + S3C2410_IICSTAT);\n\twhile ((iicstat & S3C2410_IICSTAT_START) && --spins) {\n\t\tcpu_relax();\n\t\tiicstat = readl(i2c->regs + S3C2410_IICSTAT);\n\t}\n\n\t \n\tdelay = 1;\n\twhile ((iicstat & S3C2410_IICSTAT_START) &&\n\t       ktime_us_delta(now, start) < S3C2410_IDLE_TIMEOUT) {\n\t\tusleep_range(delay, 2 * delay);\n\t\tif (delay < S3C2410_IDLE_TIMEOUT / 10)\n\t\t\tdelay <<= 1;\n\t\tnow = ktime_get();\n\t\tiicstat = readl(i2c->regs + S3C2410_IICSTAT);\n\t}\n\n\tif (iicstat & S3C2410_IICSTAT_START)\n\t\tdev_warn(i2c->dev, \"timeout waiting for bus idle\\n\");\n}\n\n \nstatic int s3c24xx_i2c_doxfer(struct s3c24xx_i2c *i2c,\n\t\t\t      struct i2c_msg *msgs, int num)\n{\n\tunsigned long timeout = 0;\n\tint ret;\n\n\tret = s3c24xx_i2c_set_master(i2c);\n\tif (ret != 0) {\n\t\tdev_err(i2c->dev, \"cannot get bus (error %d)\\n\", ret);\n\t\tret = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\ti2c->msg     = msgs;\n\ti2c->msg_num = num;\n\ti2c->msg_ptr = 0;\n\ti2c->msg_idx = 0;\n\ti2c->state   = STATE_START;\n\n\ts3c24xx_i2c_enable_irq(i2c);\n\ts3c24xx_i2c_message_start(i2c, msgs);\n\n\tif (i2c->quirks & QUIRK_POLL) {\n\t\twhile ((i2c->msg_num != 0) && is_ack(i2c)) {\n\t\t\tunsigned long stat = readl(i2c->regs + S3C2410_IICSTAT);\n\n\t\t\ti2c_s3c_irq_nextbyte(i2c, stat);\n\n\t\t\tstat = readl(i2c->regs + S3C2410_IICSTAT);\n\t\t\tif (stat & S3C2410_IICSTAT_ARBITR)\n\t\t\t\tdev_err(i2c->dev, \"deal with arbitration loss\\n\");\n\t\t}\n\t} else {\n\t\ttimeout = wait_event_timeout(i2c->wait, i2c->msg_num == 0, HZ * 5);\n\t}\n\n\tret = i2c->msg_idx;\n\n\t \n\tif (timeout == 0)\n\t\tdev_dbg(i2c->dev, \"timeout\\n\");\n\telse if (ret != num)\n\t\tdev_dbg(i2c->dev, \"incomplete xfer (%d)\\n\", ret);\n\n\t \n\tif (i2c->quirks & QUIRK_HDMIPHY)\n\t\tgoto out;\n\n\ts3c24xx_i2c_wait_idle(i2c);\n\n\ts3c24xx_i2c_disable_bus(i2c);\n\n out:\n\ti2c->state = STATE_IDLE;\n\n\treturn ret;\n}\n\n \nstatic int s3c24xx_i2c_xfer(struct i2c_adapter *adap,\n\t\t\tstruct i2c_msg *msgs, int num)\n{\n\tstruct s3c24xx_i2c *i2c = (struct s3c24xx_i2c *)adap->algo_data;\n\tint retry;\n\tint ret;\n\n\tret = clk_enable(i2c->clk);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (retry = 0; retry < adap->retries; retry++) {\n\n\t\tret = s3c24xx_i2c_doxfer(i2c, msgs, num);\n\n\t\tif (ret != -EAGAIN) {\n\t\t\tclk_disable(i2c->clk);\n\t\t\treturn ret;\n\t\t}\n\n\t\tdev_dbg(i2c->dev, \"Retrying transmission (%d)\\n\", retry);\n\n\t\tudelay(100);\n\t}\n\n\tclk_disable(i2c->clk);\n\treturn -EREMOTEIO;\n}\n\n \nstatic u32 s3c24xx_i2c_func(struct i2c_adapter *adap)\n{\n\treturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL_ALL | I2C_FUNC_NOSTART |\n\t\tI2C_FUNC_PROTOCOL_MANGLING;\n}\n\n \nstatic const struct i2c_algorithm s3c24xx_i2c_algorithm = {\n\t.master_xfer\t\t= s3c24xx_i2c_xfer,\n\t.functionality\t\t= s3c24xx_i2c_func,\n};\n\n \nstatic int s3c24xx_i2c_calcdivisor(unsigned long clkin, unsigned int wanted,\n\t\t\t\t   unsigned int *div1, unsigned int *divs)\n{\n\tunsigned int calc_divs = clkin / wanted;\n\tunsigned int calc_div1;\n\n\tif (calc_divs > (16*16))\n\t\tcalc_div1 = 512;\n\telse\n\t\tcalc_div1 = 16;\n\n\tcalc_divs += calc_div1-1;\n\tcalc_divs /= calc_div1;\n\n\tif (calc_divs == 0)\n\t\tcalc_divs = 1;\n\tif (calc_divs > 17)\n\t\tcalc_divs = 17;\n\n\t*divs = calc_divs;\n\t*div1 = calc_div1;\n\n\treturn clkin / (calc_divs * calc_div1);\n}\n\n \nstatic int s3c24xx_i2c_clockrate(struct s3c24xx_i2c *i2c, unsigned int *got)\n{\n\tstruct s3c2410_platform_i2c *pdata = i2c->pdata;\n\tunsigned long clkin = clk_get_rate(i2c->clk);\n\tunsigned int divs, div1;\n\tunsigned long target_frequency;\n\tu32 iiccon;\n\tint freq;\n\n\ti2c->clkrate = clkin;\n\tclkin /= 1000;\t \n\n\tdev_dbg(i2c->dev, \"pdata desired frequency %lu\\n\", pdata->frequency);\n\n\ttarget_frequency = pdata->frequency ?: I2C_MAX_STANDARD_MODE_FREQ;\n\n\ttarget_frequency /= 1000;  \n\n\tfreq = s3c24xx_i2c_calcdivisor(clkin, target_frequency, &div1, &divs);\n\n\tif (freq > target_frequency) {\n\t\tdev_err(i2c->dev,\n\t\t\t\"Unable to achieve desired frequency %luKHz.\"\t\\\n\t\t\t\" Lowest achievable %dKHz\\n\", target_frequency, freq);\n\t\treturn -EINVAL;\n\t}\n\n\t*got = freq;\n\n\tiiccon = readl(i2c->regs + S3C2410_IICCON);\n\tiiccon &= ~(S3C2410_IICCON_SCALEMASK | S3C2410_IICCON_TXDIV_512);\n\tiiccon |= (divs-1);\n\n\tif (div1 == 512)\n\t\tiiccon |= S3C2410_IICCON_TXDIV_512;\n\n\tif (i2c->quirks & QUIRK_POLL)\n\t\tiiccon |= S3C2410_IICCON_SCALE(2);\n\n\twritel(iiccon, i2c->regs + S3C2410_IICCON);\n\n\tif (i2c->quirks & QUIRK_S3C2440) {\n\t\tunsigned long sda_delay;\n\n\t\tif (pdata->sda_delay) {\n\t\t\tsda_delay = clkin * pdata->sda_delay;\n\t\t\tsda_delay = DIV_ROUND_UP(sda_delay, 1000000);\n\t\t\tsda_delay = DIV_ROUND_UP(sda_delay, 5);\n\t\t\tif (sda_delay > 3)\n\t\t\t\tsda_delay = 3;\n\t\t\tsda_delay |= S3C2410_IICLC_FILTER_ON;\n\t\t} else\n\t\t\tsda_delay = 0;\n\n\t\tdev_dbg(i2c->dev, \"IICLC=%08lx\\n\", sda_delay);\n\t\twritel(sda_delay, i2c->regs + S3C2440_IICLC);\n\t}\n\n\treturn 0;\n}\n\n#ifdef CONFIG_OF\nstatic int s3c24xx_i2c_parse_dt_gpio(struct s3c24xx_i2c *i2c)\n{\n\tint i;\n\n\tif (i2c->quirks & QUIRK_NO_GPIO)\n\t\treturn 0;\n\n\tfor (i = 0; i < 2; i++) {\n\t\ti2c->gpios[i] = devm_gpiod_get_index(i2c->dev, NULL,\n\t\t\t\t\t\t     i, GPIOD_ASIS);\n\t\tif (IS_ERR(i2c->gpios[i])) {\n\t\t\tdev_err(i2c->dev, \"i2c gpio invalid at index %d\\n\", i);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\treturn 0;\n}\n\n#else\nstatic int s3c24xx_i2c_parse_dt_gpio(struct s3c24xx_i2c *i2c)\n{\n\treturn 0;\n}\n#endif\n\n \nstatic int s3c24xx_i2c_init(struct s3c24xx_i2c *i2c)\n{\n\tstruct s3c2410_platform_i2c *pdata;\n\tunsigned int freq;\n\n\t \n\n\tpdata = i2c->pdata;\n\n\t \n\n\twriteb(pdata->slave_addr, i2c->regs + S3C2410_IICADD);\n\n\tdev_info(i2c->dev, \"slave address 0x%02x\\n\", pdata->slave_addr);\n\n\twritel(0, i2c->regs + S3C2410_IICCON);\n\twritel(0, i2c->regs + S3C2410_IICSTAT);\n\n\t \n\n\tif (s3c24xx_i2c_clockrate(i2c, &freq) != 0) {\n\t\tdev_err(i2c->dev, \"cannot meet bus frequency required\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\n\tdev_info(i2c->dev, \"bus frequency set to %d KHz\\n\", freq);\n\tdev_dbg(i2c->dev, \"S3C2410_IICCON=0x%02x\\n\",\n\t\treadl(i2c->regs + S3C2410_IICCON));\n\n\treturn 0;\n}\n\n#ifdef CONFIG_OF\n \nstatic void\ns3c24xx_i2c_parse_dt(struct device_node *np, struct s3c24xx_i2c *i2c)\n{\n\tstruct s3c2410_platform_i2c *pdata = i2c->pdata;\n\tint id;\n\n\tif (!np)\n\t\treturn;\n\n\tpdata->bus_num = -1;  \n\tof_property_read_u32(np, \"samsung,i2c-sda-delay\", &pdata->sda_delay);\n\tof_property_read_u32(np, \"samsung,i2c-slave-addr\", &pdata->slave_addr);\n\tof_property_read_u32(np, \"samsung,i2c-max-bus-freq\",\n\t\t\t\t(u32 *)&pdata->frequency);\n\t \n\tid = of_alias_get_id(np, \"i2c\");\n\ti2c->sysreg = syscon_regmap_lookup_by_phandle(np,\n\t\t\t\"samsung,sysreg-phandle\");\n\tif (IS_ERR(i2c->sysreg))\n\t\treturn;\n\n\tregmap_update_bits(i2c->sysreg, EXYNOS5_SYS_I2C_CFG, BIT(id), 0);\n}\n#else\nstatic void\ns3c24xx_i2c_parse_dt(struct device_node *np, struct s3c24xx_i2c *i2c) { }\n#endif\n\nstatic int s3c24xx_i2c_probe(struct platform_device *pdev)\n{\n\tstruct s3c24xx_i2c *i2c;\n\tstruct s3c2410_platform_i2c *pdata = NULL;\n\tstruct resource *res;\n\tint ret;\n\n\tif (!pdev->dev.of_node) {\n\t\tpdata = dev_get_platdata(&pdev->dev);\n\t\tif (!pdata) {\n\t\t\tdev_err(&pdev->dev, \"no platform data\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\ti2c = devm_kzalloc(&pdev->dev, sizeof(struct s3c24xx_i2c), GFP_KERNEL);\n\tif (!i2c)\n\t\treturn -ENOMEM;\n\n\ti2c->pdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);\n\tif (!i2c->pdata)\n\t\treturn -ENOMEM;\n\n\ti2c->quirks = s3c24xx_get_device_quirks(pdev);\n\ti2c->sysreg = ERR_PTR(-ENOENT);\n\tif (pdata)\n\t\tmemcpy(i2c->pdata, pdata, sizeof(*pdata));\n\telse\n\t\ts3c24xx_i2c_parse_dt(pdev->dev.of_node, i2c);\n\n\tstrscpy(i2c->adap.name, \"s3c2410-i2c\", sizeof(i2c->adap.name));\n\ti2c->adap.owner = THIS_MODULE;\n\ti2c->adap.algo = &s3c24xx_i2c_algorithm;\n\ti2c->adap.retries = 2;\n\ti2c->adap.class = I2C_CLASS_DEPRECATED;\n\ti2c->tx_setup = 50;\n\n\tinit_waitqueue_head(&i2c->wait);\n\n\t \n\ti2c->dev = &pdev->dev;\n\ti2c->clk = devm_clk_get(&pdev->dev, \"i2c\");\n\tif (IS_ERR(i2c->clk)) {\n\t\tdev_err(&pdev->dev, \"cannot get clock\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\tdev_dbg(&pdev->dev, \"clock source %p\\n\", i2c->clk);\n\n\t \n\ti2c->regs = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(i2c->regs))\n\t\treturn PTR_ERR(i2c->regs);\n\n\tdev_dbg(&pdev->dev, \"registers %p (%p)\\n\",\n\t\ti2c->regs, res);\n\n\t \n\ti2c->adap.algo_data = i2c;\n\ti2c->adap.dev.parent = &pdev->dev;\n\ti2c->pctrl = devm_pinctrl_get_select_default(i2c->dev);\n\n\t \n\tif (i2c->pdata->cfg_gpio)\n\t\ti2c->pdata->cfg_gpio(to_platform_device(i2c->dev));\n\telse if (IS_ERR(i2c->pctrl) && s3c24xx_i2c_parse_dt_gpio(i2c))\n\t\treturn -EINVAL;\n\n\t \n\tret = clk_prepare_enable(i2c->clk);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"I2C clock enable failed\\n\");\n\t\treturn ret;\n\t}\n\n\tret = s3c24xx_i2c_init(i2c);\n\tclk_disable(i2c->clk);\n\tif (ret != 0) {\n\t\tdev_err(&pdev->dev, \"I2C controller init failed\\n\");\n\t\tclk_unprepare(i2c->clk);\n\t\treturn ret;\n\t}\n\n\t \n\tif (!(i2c->quirks & QUIRK_POLL)) {\n\t\ti2c->irq = ret = platform_get_irq(pdev, 0);\n\t\tif (ret < 0) {\n\t\t\tclk_unprepare(i2c->clk);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = devm_request_irq(&pdev->dev, i2c->irq, s3c24xx_i2c_irq,\n\t\t\t\t       0, dev_name(&pdev->dev), i2c);\n\t\tif (ret != 0) {\n\t\t\tdev_err(&pdev->dev, \"cannot claim IRQ %d\\n\", i2c->irq);\n\t\t\tclk_unprepare(i2c->clk);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\ti2c->adap.nr = i2c->pdata->bus_num;\n\ti2c->adap.dev.of_node = pdev->dev.of_node;\n\n\tplatform_set_drvdata(pdev, i2c);\n\n\tpm_runtime_enable(&pdev->dev);\n\n\tret = i2c_add_numbered_adapter(&i2c->adap);\n\tif (ret < 0) {\n\t\tpm_runtime_disable(&pdev->dev);\n\t\tclk_unprepare(i2c->clk);\n\t\treturn ret;\n\t}\n\n\tdev_info(&pdev->dev, \"%s: S3C I2C adapter\\n\", dev_name(&i2c->adap.dev));\n\treturn 0;\n}\n\nstatic void s3c24xx_i2c_remove(struct platform_device *pdev)\n{\n\tstruct s3c24xx_i2c *i2c = platform_get_drvdata(pdev);\n\n\tclk_unprepare(i2c->clk);\n\n\tpm_runtime_disable(&pdev->dev);\n\n\ti2c_del_adapter(&i2c->adap);\n}\n\nstatic int s3c24xx_i2c_suspend_noirq(struct device *dev)\n{\n\tstruct s3c24xx_i2c *i2c = dev_get_drvdata(dev);\n\n\ti2c_mark_adapter_suspended(&i2c->adap);\n\n\tif (!IS_ERR(i2c->sysreg))\n\t\tregmap_read(i2c->sysreg, EXYNOS5_SYS_I2C_CFG, &i2c->sys_i2c_cfg);\n\n\treturn 0;\n}\n\nstatic int s3c24xx_i2c_resume_noirq(struct device *dev)\n{\n\tstruct s3c24xx_i2c *i2c = dev_get_drvdata(dev);\n\tint ret;\n\n\tif (!IS_ERR(i2c->sysreg))\n\t\tregmap_write(i2c->sysreg, EXYNOS5_SYS_I2C_CFG, i2c->sys_i2c_cfg);\n\n\tret = clk_enable(i2c->clk);\n\tif (ret)\n\t\treturn ret;\n\ts3c24xx_i2c_init(i2c);\n\tclk_disable(i2c->clk);\n\ti2c_mark_adapter_resumed(&i2c->adap);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops s3c24xx_i2c_dev_pm_ops = {\n\tNOIRQ_SYSTEM_SLEEP_PM_OPS(s3c24xx_i2c_suspend_noirq,\n\t\t\t\t  s3c24xx_i2c_resume_noirq)\n};\n\nstatic struct platform_driver s3c24xx_i2c_driver = {\n\t.probe\t\t= s3c24xx_i2c_probe,\n\t.remove_new\t= s3c24xx_i2c_remove,\n\t.id_table\t= s3c24xx_driver_ids,\n\t.driver\t\t= {\n\t\t.name\t= \"s3c-i2c\",\n\t\t.pm\t= pm_sleep_ptr(&s3c24xx_i2c_dev_pm_ops),\n\t\t.of_match_table = of_match_ptr(s3c24xx_i2c_match),\n\t},\n};\n\nstatic int __init i2c_adap_s3c_init(void)\n{\n\treturn platform_driver_register(&s3c24xx_i2c_driver);\n}\nsubsys_initcall(i2c_adap_s3c_init);\n\nstatic void __exit i2c_adap_s3c_exit(void)\n{\n\tplatform_driver_unregister(&s3c24xx_i2c_driver);\n}\nmodule_exit(i2c_adap_s3c_exit);\n\nMODULE_DESCRIPTION(\"S3C24XX I2C Bus driver\");\nMODULE_AUTHOR(\"Ben Dooks <ben@simtec.co.uk>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}