{
  "module_name": "i2c-thunderx-pcidrv.c",
  "hash_id": "3690a0d39bed41d87fabd9a949bd607c0e5b666915e36e31b1316352841e2506",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-thunderx-pcidrv.c",
  "human_readable_source": " \n\n#include <linux/acpi.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/i2c.h>\n#include <linux/i2c-smbus.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of_irq.h>\n#include <linux/pci.h>\n\n#include \"i2c-octeon-core.h\"\n\n#define DRV_NAME \"i2c-thunderx\"\n\n#define PCI_DEVICE_ID_THUNDER_TWSI\t0xa012\n\n#define SYS_FREQ_DEFAULT\t\t700000000\n\n#define TWSI_INT_ENA_W1C\t\t0x1028\n#define TWSI_INT_ENA_W1S\t\t0x1030\n\n \nstatic void thunder_i2c_int_enable(struct octeon_i2c *i2c)\n{\n\tocteon_i2c_writeq_flush(TWSI_INT_CORE_INT,\n\t\t\t\ti2c->twsi_base + TWSI_INT_ENA_W1S);\n}\n\n \nstatic void thunder_i2c_int_disable(struct octeon_i2c *i2c)\n{\n\tocteon_i2c_writeq_flush(TWSI_INT_CORE_INT,\n\t\t\t\ti2c->twsi_base + TWSI_INT_ENA_W1C);\n}\n\nstatic void thunder_i2c_hlc_int_enable(struct octeon_i2c *i2c)\n{\n\tocteon_i2c_writeq_flush(TWSI_INT_ST_INT | TWSI_INT_TS_INT,\n\t\t\t\ti2c->twsi_base + TWSI_INT_ENA_W1S);\n}\n\nstatic void thunder_i2c_hlc_int_disable(struct octeon_i2c *i2c)\n{\n\tocteon_i2c_writeq_flush(TWSI_INT_ST_INT | TWSI_INT_TS_INT,\n\t\t\t\ti2c->twsi_base + TWSI_INT_ENA_W1C);\n}\n\nstatic u32 thunderx_i2c_functionality(struct i2c_adapter *adap)\n{\n\treturn I2C_FUNC_I2C | (I2C_FUNC_SMBUS_EMUL & ~I2C_FUNC_SMBUS_QUICK) |\n\t       I2C_FUNC_SMBUS_READ_BLOCK_DATA | I2C_SMBUS_BLOCK_PROC_CALL;\n}\n\nstatic const struct i2c_algorithm thunderx_i2c_algo = {\n\t.master_xfer = octeon_i2c_xfer,\n\t.functionality = thunderx_i2c_functionality,\n};\n\nstatic const struct i2c_adapter thunderx_i2c_ops = {\n\t.owner\t= THIS_MODULE,\n\t.name\t= \"ThunderX adapter\",\n\t.algo\t= &thunderx_i2c_algo,\n};\n\nstatic void thunder_i2c_clock_enable(struct device *dev, struct octeon_i2c *i2c)\n{\n\tint ret;\n\n\tif (acpi_disabled) {\n\t\t \n\t\ti2c->clk = clk_get(dev, NULL);\n\t\tif (IS_ERR(i2c->clk)) {\n\t\t\ti2c->clk = NULL;\n\t\t\tgoto skip;\n\t\t}\n\n\t\tret = clk_prepare_enable(i2c->clk);\n\t\tif (ret)\n\t\t\tgoto skip;\n\t\ti2c->sys_freq = clk_get_rate(i2c->clk);\n\t} else {\n\t\t \n\t\tdevice_property_read_u32(dev, \"sclk\", &i2c->sys_freq);\n\t}\n\nskip:\n\tif (!i2c->sys_freq)\n\t\ti2c->sys_freq = SYS_FREQ_DEFAULT;\n}\n\nstatic void thunder_i2c_clock_disable(struct device *dev, struct clk *clk)\n{\n\tif (!clk)\n\t\treturn;\n\tclk_disable_unprepare(clk);\n\tclk_put(clk);\n}\n\nstatic int thunder_i2c_smbus_setup_of(struct octeon_i2c *i2c,\n\t\t\t\t      struct device_node *node)\n{\n\tstruct i2c_client *ara;\n\n\tif (!node)\n\t\treturn -EINVAL;\n\n\ti2c->alert_data.irq = irq_of_parse_and_map(node, 0);\n\tif (!i2c->alert_data.irq)\n\t\treturn -EINVAL;\n\n\tara = i2c_new_smbus_alert_device(&i2c->adap, &i2c->alert_data);\n\tif (IS_ERR(ara))\n\t\treturn PTR_ERR(ara);\n\n\ti2c->ara = ara;\n\n\treturn 0;\n}\n\nstatic int thunder_i2c_smbus_setup(struct octeon_i2c *i2c,\n\t\t\t\t   struct device_node *node)\n{\n\t \n\tif (!acpi_disabled)\n\t\treturn -EOPNOTSUPP;\n\n\treturn thunder_i2c_smbus_setup_of(i2c, node);\n}\n\nstatic void thunder_i2c_smbus_remove(struct octeon_i2c *i2c)\n{\n\ti2c_unregister_device(i2c->ara);\n}\n\nstatic int thunder_i2c_probe_pci(struct pci_dev *pdev,\n\t\t\t\t const struct pci_device_id *ent)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct octeon_i2c *i2c;\n\tint ret;\n\n\ti2c = devm_kzalloc(dev, sizeof(*i2c), GFP_KERNEL);\n\tif (!i2c)\n\t\treturn -ENOMEM;\n\n\ti2c->roff.sw_twsi = 0x1000;\n\ti2c->roff.twsi_int = 0x1010;\n\ti2c->roff.sw_twsi_ext = 0x1018;\n\n\ti2c->dev = dev;\n\tpci_set_drvdata(pdev, i2c);\n\tret = pcim_enable_device(pdev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = pci_request_regions(pdev, DRV_NAME);\n\tif (ret)\n\t\treturn ret;\n\n\ti2c->twsi_base = pcim_iomap(pdev, 0, pci_resource_len(pdev, 0));\n\tif (!i2c->twsi_base)\n\t\treturn -EINVAL;\n\n\tthunder_i2c_clock_enable(dev, i2c);\n\tret = device_property_read_u32(dev, \"clock-frequency\", &i2c->twsi_freq);\n\tif (ret)\n\t\ti2c->twsi_freq = I2C_MAX_STANDARD_MODE_FREQ;\n\n\tinit_waitqueue_head(&i2c->queue);\n\n\ti2c->int_enable = thunder_i2c_int_enable;\n\ti2c->int_disable = thunder_i2c_int_disable;\n\ti2c->hlc_int_enable = thunder_i2c_hlc_int_enable;\n\ti2c->hlc_int_disable = thunder_i2c_hlc_int_disable;\n\n\tret = pci_alloc_irq_vectors(pdev, 1, 1, PCI_IRQ_MSIX);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tret = devm_request_irq(dev, pci_irq_vector(pdev, 0), octeon_i2c_isr, 0,\n\t\t\t       DRV_NAME, i2c);\n\tif (ret)\n\t\tgoto error;\n\n\tret = octeon_i2c_init_lowlevel(i2c);\n\tif (ret)\n\t\tgoto error;\n\n\tocteon_i2c_set_clock(i2c);\n\n\ti2c->adap = thunderx_i2c_ops;\n\ti2c->adap.retries = 5;\n\ti2c->adap.class = I2C_CLASS_HWMON;\n\ti2c->adap.bus_recovery_info = &octeon_i2c_recovery_info;\n\ti2c->adap.dev.parent = dev;\n\ti2c->adap.dev.of_node = pdev->dev.of_node;\n\ti2c->adap.dev.fwnode = dev->fwnode;\n\tsnprintf(i2c->adap.name, sizeof(i2c->adap.name),\n\t\t \"Cavium ThunderX i2c adapter at %s\", dev_name(dev));\n\ti2c_set_adapdata(&i2c->adap, i2c);\n\n\tret = i2c_add_adapter(&i2c->adap);\n\tif (ret)\n\t\tgoto error;\n\n\tdev_info(i2c->dev, \"Probed. Set system clock to %u\\n\", i2c->sys_freq);\n\n\tret = thunder_i2c_smbus_setup(i2c, pdev->dev.of_node);\n\tif (ret)\n\t\tdev_info(dev, \"SMBUS alert not active on this bus\\n\");\n\n\treturn 0;\n\nerror:\n\tthunder_i2c_clock_disable(dev, i2c->clk);\n\treturn ret;\n}\n\nstatic void thunder_i2c_remove_pci(struct pci_dev *pdev)\n{\n\tstruct octeon_i2c *i2c = pci_get_drvdata(pdev);\n\n\tthunder_i2c_smbus_remove(i2c);\n\tthunder_i2c_clock_disable(&pdev->dev, i2c->clk);\n\ti2c_del_adapter(&i2c->adap);\n}\n\nstatic const struct pci_device_id thunder_i2c_pci_id_table[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_CAVIUM, PCI_DEVICE_ID_THUNDER_TWSI) },\n\t{ 0, }\n};\n\nMODULE_DEVICE_TABLE(pci, thunder_i2c_pci_id_table);\n\nstatic struct pci_driver thunder_i2c_pci_driver = {\n\t.name\t\t= DRV_NAME,\n\t.id_table\t= thunder_i2c_pci_id_table,\n\t.probe\t\t= thunder_i2c_probe_pci,\n\t.remove\t\t= thunder_i2c_remove_pci,\n};\n\nmodule_pci_driver(thunder_i2c_pci_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Fred Martin <fmartin@caviumnetworks.com>\");\nMODULE_DESCRIPTION(\"I2C-Bus adapter for Cavium ThunderX SOC\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}