{
  "module_name": "scx200_acb.c",
  "hash_id": "76e455bc9bb890578cfe366a16b9911fdf31b5de62dcb4328a9fd186bb26163c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/scx200_acb.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/i2c.h>\n#include <linux/pci.h>\n#include <linux/platform_device.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n\n#include <linux/scx200.h>\n\nMODULE_AUTHOR(\"Christer Weinigel <wingel@nano-system.com>\");\nMODULE_DESCRIPTION(\"NatSemi SCx200 ACCESS.bus Driver\");\nMODULE_ALIAS(\"platform:cs5535-smb\");\nMODULE_LICENSE(\"GPL\");\n\n#define MAX_DEVICES 4\nstatic int base[MAX_DEVICES] = { 0x820, 0x840 };\nmodule_param_hw_array(base, int, ioport, NULL, 0);\nMODULE_PARM_DESC(base, \"Base addresses for the ACCESS.bus controllers\");\n\n#define POLL_TIMEOUT\t(HZ/5)\n\nenum scx200_acb_state {\n\tstate_idle,\n\tstate_address,\n\tstate_command,\n\tstate_repeat_start,\n\tstate_quick,\n\tstate_read,\n\tstate_write,\n};\n\nstatic const char *scx200_acb_state_name[] = {\n\t\"idle\",\n\t\"address\",\n\t\"command\",\n\t\"repeat_start\",\n\t\"quick\",\n\t\"read\",\n\t\"write\",\n};\n\n \nstruct scx200_acb_iface {\n\tstruct scx200_acb_iface *next;\n\tstruct i2c_adapter adapter;\n\tunsigned base;\n\tstruct mutex mutex;\n\n\t \n\tenum scx200_acb_state state;\n\tint result;\n\tu8 address_byte;\n\tu8 command;\n\tu8 *ptr;\n\tchar needs_reset;\n\tunsigned len;\n};\n\n \n#define ACBSDA\t\t(iface->base + 0)\n#define ACBST\t\t(iface->base + 1)\n#define    ACBST_SDAST\t\t0x40  \n#define    ACBST_BER\t\t0x20\n#define    ACBST_NEGACK\t\t0x10  \n#define    ACBST_STASTR\t\t0x08  \n#define    ACBST_MASTER\t\t0x02\n#define ACBCST\t\t(iface->base + 2)\n#define    ACBCST_BB\t\t0x02\n#define ACBCTL1\t\t(iface->base + 3)\n#define    ACBCTL1_STASTRE\t0x80\n#define    ACBCTL1_NMINTE\t0x40\n#define    ACBCTL1_ACK\t\t0x10\n#define    ACBCTL1_STOP\t\t0x02\n#define    ACBCTL1_START\t0x01\n#define ACBADDR\t\t(iface->base + 4)\n#define ACBCTL2\t\t(iface->base + 5)\n#define    ACBCTL2_ENABLE\t0x01\n\n \n\nstatic void scx200_acb_machine(struct scx200_acb_iface *iface, u8 status)\n{\n\tconst char *errmsg;\n\n\tdev_dbg(&iface->adapter.dev, \"state %s, status = 0x%02x\\n\",\n\t\tscx200_acb_state_name[iface->state], status);\n\n\tif (status & ACBST_BER) {\n\t\terrmsg = \"bus error\";\n\t\tgoto error;\n\t}\n\tif (!(status & ACBST_MASTER)) {\n\t\terrmsg = \"not master\";\n\t\tgoto error;\n\t}\n\tif (status & ACBST_NEGACK) {\n\t\tdev_dbg(&iface->adapter.dev, \"negative ack in state %s\\n\",\n\t\t\tscx200_acb_state_name[iface->state]);\n\n\t\tiface->state = state_idle;\n\t\tiface->result = -ENXIO;\n\n\t\toutb(inb(ACBCTL1) | ACBCTL1_STOP, ACBCTL1);\n\t\toutb(ACBST_STASTR | ACBST_NEGACK, ACBST);\n\n\t\t \n\t\toutb(0, ACBST);\n\t\treturn;\n\t}\n\n\tswitch (iface->state) {\n\tcase state_idle:\n\t\tdev_warn(&iface->adapter.dev, \"interrupt in idle state\\n\");\n\t\tbreak;\n\n\tcase state_address:\n\t\t \n\t\toutb(iface->address_byte & ~1, ACBSDA);\n\n\t\tiface->state = state_command;\n\t\tbreak;\n\n\tcase state_command:\n\t\toutb(iface->command, ACBSDA);\n\n\t\tif (iface->address_byte & 1)\n\t\t\tiface->state = state_repeat_start;\n\t\telse\n\t\t\tiface->state = state_write;\n\t\tbreak;\n\n\tcase state_repeat_start:\n\t\toutb(inb(ACBCTL1) | ACBCTL1_START, ACBCTL1);\n\t\tfallthrough;\n\n\tcase state_quick:\n\t\tif (iface->address_byte & 1) {\n\t\t\tif (iface->len == 1)\n\t\t\t\toutb(inb(ACBCTL1) | ACBCTL1_ACK, ACBCTL1);\n\t\t\telse\n\t\t\t\toutb(inb(ACBCTL1) & ~ACBCTL1_ACK, ACBCTL1);\n\t\t\toutb(iface->address_byte, ACBSDA);\n\n\t\t\tiface->state = state_read;\n\t\t} else {\n\t\t\toutb(iface->address_byte, ACBSDA);\n\n\t\t\tiface->state = state_write;\n\t\t}\n\t\tbreak;\n\n\tcase state_read:\n\t\t \n\t\tif (iface->len == 2)\n\t\t\toutb(inb(ACBCTL1) | ACBCTL1_ACK, ACBCTL1);\n\t\telse\n\t\t\toutb(inb(ACBCTL1) & ~ACBCTL1_ACK, ACBCTL1);\n\n\t\tif (iface->len == 1) {\n\t\t\tiface->result = 0;\n\t\t\tiface->state = state_idle;\n\t\t\toutb(inb(ACBCTL1) | ACBCTL1_STOP, ACBCTL1);\n\t\t}\n\n\t\t*iface->ptr++ = inb(ACBSDA);\n\t\t--iface->len;\n\n\t\tbreak;\n\n\tcase state_write:\n\t\tif (iface->len == 0) {\n\t\t\tiface->result = 0;\n\t\t\tiface->state = state_idle;\n\t\t\toutb(inb(ACBCTL1) | ACBCTL1_STOP, ACBCTL1);\n\t\t\tbreak;\n\t\t}\n\n\t\toutb(*iface->ptr++, ACBSDA);\n\t\t--iface->len;\n\n\t\tbreak;\n\t}\n\n\treturn;\n\n error:\n\tdev_err(&iface->adapter.dev,\n\t\t\"%s in state %s (addr=0x%02x, len=%d, status=0x%02x)\\n\", errmsg,\n\t\tscx200_acb_state_name[iface->state], iface->address_byte,\n\t\tiface->len, status);\n\n\tiface->state = state_idle;\n\tiface->result = -EIO;\n\tiface->needs_reset = 1;\n}\n\nstatic void scx200_acb_poll(struct scx200_acb_iface *iface)\n{\n\tu8 status;\n\tunsigned long timeout;\n\n\ttimeout = jiffies + POLL_TIMEOUT;\n\twhile (1) {\n\t\tstatus = inb(ACBST);\n\n\t\t \n\t\toutb(0, ACBST);\n\n\t\tif ((status & (ACBST_SDAST|ACBST_BER|ACBST_NEGACK)) != 0) {\n\t\t\tscx200_acb_machine(iface, status);\n\t\t\treturn;\n\t\t}\n\t\tif (time_after(jiffies, timeout))\n\t\t\tbreak;\n\t\tcpu_relax();\n\t\tcond_resched();\n\t}\n\n\tdev_err(&iface->adapter.dev, \"timeout in state %s\\n\",\n\t\tscx200_acb_state_name[iface->state]);\n\n\tiface->state = state_idle;\n\tiface->result = -EIO;\n\tiface->needs_reset = 1;\n}\n\nstatic void scx200_acb_reset(struct scx200_acb_iface *iface)\n{\n\t \n\toutb(0x70, ACBCTL2);\n\t \n\toutb(0, ACBCTL1);\n\t \n\toutb(0, ACBADDR);\n\t \n\toutb(inb(ACBCTL2) | ACBCTL2_ENABLE, ACBCTL2);\n\t \n\toutb(inb(ACBCTL1) & ~(ACBCTL1_STASTRE | ACBCTL1_NMINTE), ACBCTL1);\n\t \n\toutb(inb(ACBCTL1) | ACBCTL1_STOP, ACBCTL1);\n\t \n\toutb(ACBST_BER | ACBST_NEGACK | ACBST_STASTR, ACBST);\n\t \n\toutb(inb(ACBCST) | ACBCST_BB, ACBCST);\n}\n\nstatic s32 scx200_acb_smbus_xfer(struct i2c_adapter *adapter,\n\t\t\t\t u16 address, unsigned short flags,\n\t\t\t\t char rw, u8 command, int size,\n\t\t\t\t union i2c_smbus_data *data)\n{\n\tstruct scx200_acb_iface *iface = i2c_get_adapdata(adapter);\n\tint len;\n\tu8 *buffer;\n\tu16 cur_word;\n\tint rc;\n\n\tswitch (size) {\n\tcase I2C_SMBUS_QUICK:\n\t\tlen = 0;\n\t\tbuffer = NULL;\n\t\tbreak;\n\n\tcase I2C_SMBUS_BYTE:\n\t\tlen = 1;\n\t\tbuffer = rw ? &data->byte : &command;\n\t\tbreak;\n\n\tcase I2C_SMBUS_BYTE_DATA:\n\t\tlen = 1;\n\t\tbuffer = &data->byte;\n\t\tbreak;\n\n\tcase I2C_SMBUS_WORD_DATA:\n\t\tlen = 2;\n\t\tcur_word = cpu_to_le16(data->word);\n\t\tbuffer = (u8 *)&cur_word;\n\t\tbreak;\n\n\tcase I2C_SMBUS_I2C_BLOCK_DATA:\n\t\tlen = data->block[0];\n\t\tif (len == 0 || len > I2C_SMBUS_BLOCK_MAX)\n\t\t\treturn -EINVAL;\n\t\tbuffer = &data->block[1];\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tdev_dbg(&adapter->dev,\n\t\t\"size=%d, address=0x%x, command=0x%x, len=%d, read=%d\\n\",\n\t\tsize, address, command, len, rw);\n\n\tif (!len && rw == I2C_SMBUS_READ) {\n\t\tdev_dbg(&adapter->dev, \"zero length read\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&iface->mutex);\n\n\tiface->address_byte = (address << 1) | rw;\n\tiface->command = command;\n\tiface->ptr = buffer;\n\tiface->len = len;\n\tiface->result = -EINVAL;\n\tiface->needs_reset = 0;\n\n\toutb(inb(ACBCTL1) | ACBCTL1_START, ACBCTL1);\n\n\tif (size == I2C_SMBUS_QUICK || size == I2C_SMBUS_BYTE)\n\t\tiface->state = state_quick;\n\telse\n\t\tiface->state = state_address;\n\n\twhile (iface->state != state_idle)\n\t\tscx200_acb_poll(iface);\n\n\tif (iface->needs_reset)\n\t\tscx200_acb_reset(iface);\n\n\trc = iface->result;\n\n\tmutex_unlock(&iface->mutex);\n\n\tif (rc == 0 && size == I2C_SMBUS_WORD_DATA && rw == I2C_SMBUS_READ)\n\t\tdata->word = le16_to_cpu(cur_word);\n\n#ifdef DEBUG\n\tdev_dbg(&adapter->dev, \"transfer done, result: %d\", rc);\n\tif (buffer) {\n\t\tint i;\n\t\tprintk(\" data:\");\n\t\tfor (i = 0; i < len; ++i)\n\t\t\tprintk(\" %02x\", buffer[i]);\n\t}\n\tprintk(\"\\n\");\n#endif\n\n\treturn rc;\n}\n\nstatic u32 scx200_acb_func(struct i2c_adapter *adapter)\n{\n\treturn I2C_FUNC_SMBUS_QUICK | I2C_FUNC_SMBUS_BYTE |\n\t       I2C_FUNC_SMBUS_BYTE_DATA | I2C_FUNC_SMBUS_WORD_DATA |\n\t       I2C_FUNC_SMBUS_I2C_BLOCK;\n}\n\n \nstatic const struct i2c_algorithm scx200_acb_algorithm = {\n\t.smbus_xfer\t= scx200_acb_smbus_xfer,\n\t.functionality\t= scx200_acb_func,\n};\n\nstatic struct scx200_acb_iface *scx200_acb_list;\nstatic DEFINE_MUTEX(scx200_acb_list_mutex);\n\nstatic int scx200_acb_probe(struct scx200_acb_iface *iface)\n{\n\tu8 val;\n\n\t \n\toutb(0x70, ACBCTL2);\n\n\tif (inb(ACBCTL2) != 0x70) {\n\t\tpr_debug(\"ACBCTL2 readback failed\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\toutb(inb(ACBCTL1) | ACBCTL1_NMINTE, ACBCTL1);\n\n\tval = inb(ACBCTL1);\n\tif (val) {\n\t\tpr_debug(\"disabled, but ACBCTL1=0x%02x\\n\", val);\n\t\treturn -ENXIO;\n\t}\n\n\toutb(inb(ACBCTL2) | ACBCTL2_ENABLE, ACBCTL2);\n\n\toutb(inb(ACBCTL1) | ACBCTL1_NMINTE, ACBCTL1);\n\n\tval = inb(ACBCTL1);\n\tif ((val & ACBCTL1_NMINTE) != ACBCTL1_NMINTE) {\n\t\tpr_debug(\"enabled, but NMINTE won't be set, ACBCTL1=0x%02x\\n\",\n\t\t\t val);\n\t\treturn -ENXIO;\n\t}\n\n\treturn 0;\n}\n\nstatic struct scx200_acb_iface *scx200_create_iface(const char *text,\n\t\tstruct device *dev, int index)\n{\n\tstruct scx200_acb_iface *iface;\n\tstruct i2c_adapter *adapter;\n\n\tiface = kzalloc(sizeof(*iface), GFP_KERNEL);\n\tif (!iface)\n\t\treturn NULL;\n\n\tadapter = &iface->adapter;\n\ti2c_set_adapdata(adapter, iface);\n\tsnprintf(adapter->name, sizeof(adapter->name), \"%s ACB%d\", text, index);\n\tadapter->owner = THIS_MODULE;\n\tadapter->algo = &scx200_acb_algorithm;\n\tadapter->class = I2C_CLASS_HWMON | I2C_CLASS_SPD;\n\tadapter->dev.parent = dev;\n\n\tmutex_init(&iface->mutex);\n\n\treturn iface;\n}\n\nstatic int scx200_acb_create(struct scx200_acb_iface *iface)\n{\n\tstruct i2c_adapter *adapter;\n\tint rc;\n\n\tadapter = &iface->adapter;\n\n\trc = scx200_acb_probe(iface);\n\tif (rc) {\n\t\tpr_warn(\"probe failed\\n\");\n\t\treturn rc;\n\t}\n\n\tscx200_acb_reset(iface);\n\n\tif (i2c_add_adapter(adapter) < 0) {\n\t\tpr_err(\"failed to register\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (!adapter->dev.parent) {\n\t\t \n\t\tmutex_lock(&scx200_acb_list_mutex);\n\t\tiface->next = scx200_acb_list;\n\t\tscx200_acb_list = iface;\n\t\tmutex_unlock(&scx200_acb_list_mutex);\n\t}\n\n\treturn 0;\n}\n\nstatic struct scx200_acb_iface *scx200_create_dev(const char *text,\n\t\tunsigned long base, int index, struct device *dev)\n{\n\tstruct scx200_acb_iface *iface;\n\tint rc;\n\n\tiface = scx200_create_iface(text, dev, index);\n\n\tif (iface == NULL)\n\t\treturn NULL;\n\n\tif (!request_region(base, 8, iface->adapter.name)) {\n\t\tpr_err(\"can't allocate io 0x%lx-0x%lx\\n\", base, base + 8 - 1);\n\t\tgoto errout_free;\n\t}\n\n\tiface->base = base;\n\trc = scx200_acb_create(iface);\n\n\tif (rc == 0)\n\t\treturn iface;\n\n\trelease_region(base, 8);\n errout_free:\n\tkfree(iface);\n\treturn NULL;\n}\n\nstatic int scx200_probe(struct platform_device *pdev)\n{\n\tstruct scx200_acb_iface *iface;\n\tstruct resource *res;\n\n\tres = platform_get_resource(pdev, IORESOURCE_IO, 0);\n\tif (!res) {\n\t\tdev_err(&pdev->dev, \"can't fetch device resource info\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tiface = scx200_create_dev(\"CS5535\", res->start, 0, &pdev->dev);\n\tif (!iface)\n\t\treturn -EIO;\n\n\tdev_info(&pdev->dev, \"SCx200 device '%s' registered\\n\",\n\t\t\tiface->adapter.name);\n\tplatform_set_drvdata(pdev, iface);\n\n\treturn 0;\n}\n\nstatic void scx200_cleanup_iface(struct scx200_acb_iface *iface)\n{\n\ti2c_del_adapter(&iface->adapter);\n\trelease_region(iface->base, 8);\n\tkfree(iface);\n}\n\nstatic void scx200_remove(struct platform_device *pdev)\n{\n\tstruct scx200_acb_iface *iface;\n\n\tiface = platform_get_drvdata(pdev);\n\tscx200_cleanup_iface(iface);\n}\n\nstatic struct platform_driver scx200_pci_driver = {\n\t.driver = {\n\t\t.name = \"cs5535-smb\",\n\t},\n\t.probe = scx200_probe,\n\t.remove_new = scx200_remove,\n};\n\nstatic const struct pci_device_id scx200_isa[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_NS, PCI_DEVICE_ID_NS_SCx200_BRIDGE) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_NS, PCI_DEVICE_ID_NS_SC1100_BRIDGE) },\n\t{ 0, }\n};\n\nstatic __init void scx200_scan_isa(void)\n{\n\tint i;\n\n\tif (!pci_dev_present(scx200_isa))\n\t\treturn;\n\n\tfor (i = 0; i < MAX_DEVICES; ++i) {\n\t\tif (base[i] == 0)\n\t\t\tcontinue;\n\n\t\t \n\t\tscx200_create_dev(\"SCx200\", base[i], i, NULL);\n\t}\n}\n\nstatic int __init scx200_acb_init(void)\n{\n\tpr_debug(\"NatSemi SCx200 ACCESS.bus Driver\\n\");\n\n\t \n\tscx200_scan_isa();\t \n\n\t \n\tif (scx200_acb_list)\n\t\treturn 0;\n\n\t \n\treturn platform_driver_register(&scx200_pci_driver);\n}\n\nstatic void __exit scx200_acb_cleanup(void)\n{\n\tstruct scx200_acb_iface *iface;\n\n\tplatform_driver_unregister(&scx200_pci_driver);\n\n\tmutex_lock(&scx200_acb_list_mutex);\n\twhile ((iface = scx200_acb_list) != NULL) {\n\t\tscx200_acb_list = iface->next;\n\t\tmutex_unlock(&scx200_acb_list_mutex);\n\n\t\tscx200_cleanup_iface(iface);\n\n\t\tmutex_lock(&scx200_acb_list_mutex);\n\t}\n\tmutex_unlock(&scx200_acb_list_mutex);\n}\n\nmodule_init(scx200_acb_init);\nmodule_exit(scx200_acb_cleanup);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}