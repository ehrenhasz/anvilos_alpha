{
  "module_name": "i2c-mxs.c",
  "hash_id": "1db06c89db65f57993055c7214751cabd5bc9f0ae6a153b4b6f657795e83f8bb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-mxs.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/device.h>\n#include <linux/module.h>\n#include <linux/i2c.h>\n#include <linux/err.h>\n#include <linux/interrupt.h>\n#include <linux/completion.h>\n#include <linux/platform_device.h>\n#include <linux/jiffies.h>\n#include <linux/io.h>\n#include <linux/stmp_device.h>\n#include <linux/of.h>\n#include <linux/dma-mapping.h>\n#include <linux/dmaengine.h>\n#include <linux/dma/mxs-dma.h>\n\n#define DRIVER_NAME \"mxs-i2c\"\n\n#define MXS_I2C_CTRL0\t\t(0x00)\n#define MXS_I2C_CTRL0_SET\t(0x04)\n#define MXS_I2C_CTRL0_CLR\t(0x08)\n\n#define MXS_I2C_CTRL0_SFTRST\t\t\t0x80000000\n#define MXS_I2C_CTRL0_RUN\t\t\t0x20000000\n#define MXS_I2C_CTRL0_SEND_NAK_ON_LAST\t\t0x02000000\n#define MXS_I2C_CTRL0_PIO_MODE\t\t\t0x01000000\n#define MXS_I2C_CTRL0_RETAIN_CLOCK\t\t0x00200000\n#define MXS_I2C_CTRL0_POST_SEND_STOP\t\t0x00100000\n#define MXS_I2C_CTRL0_PRE_SEND_START\t\t0x00080000\n#define MXS_I2C_CTRL0_MASTER_MODE\t\t0x00020000\n#define MXS_I2C_CTRL0_DIRECTION\t\t\t0x00010000\n#define MXS_I2C_CTRL0_XFER_COUNT(v)\t\t((v) & 0x0000FFFF)\n\n#define MXS_I2C_TIMING0\t\t(0x10)\n#define MXS_I2C_TIMING1\t\t(0x20)\n#define MXS_I2C_TIMING2\t\t(0x30)\n\n#define MXS_I2C_CTRL1\t\t(0x40)\n#define MXS_I2C_CTRL1_SET\t(0x44)\n#define MXS_I2C_CTRL1_CLR\t(0x48)\n\n#define MXS_I2C_CTRL1_CLR_GOT_A_NAK\t\t0x10000000\n#define MXS_I2C_CTRL1_BUS_FREE_IRQ\t\t0x80\n#define MXS_I2C_CTRL1_DATA_ENGINE_CMPLT_IRQ\t0x40\n#define MXS_I2C_CTRL1_NO_SLAVE_ACK_IRQ\t\t0x20\n#define MXS_I2C_CTRL1_OVERSIZE_XFER_TERM_IRQ\t0x10\n#define MXS_I2C_CTRL1_EARLY_TERM_IRQ\t\t0x08\n#define MXS_I2C_CTRL1_MASTER_LOSS_IRQ\t\t0x04\n#define MXS_I2C_CTRL1_SLAVE_STOP_IRQ\t\t0x02\n#define MXS_I2C_CTRL1_SLAVE_IRQ\t\t\t0x01\n\n#define MXS_I2C_STAT\t\t(0x50)\n#define MXS_I2C_STAT_GOT_A_NAK\t\t\t0x10000000\n#define MXS_I2C_STAT_BUS_BUSY\t\t\t0x00000800\n#define MXS_I2C_STAT_CLK_GEN_BUSY\t\t0x00000400\n\n#define MXS_I2C_DATA(i2c)\t((i2c->dev_type == MXS_I2C_V1) ? 0x60 : 0xa0)\n\n#define MXS_I2C_DEBUG0_CLR(i2c)\t((i2c->dev_type == MXS_I2C_V1) ? 0x78 : 0xb8)\n\n#define MXS_I2C_DEBUG0_DMAREQ\t0x80000000\n\n#define MXS_I2C_IRQ_MASK\t(MXS_I2C_CTRL1_DATA_ENGINE_CMPLT_IRQ | \\\n\t\t\t\t MXS_I2C_CTRL1_NO_SLAVE_ACK_IRQ | \\\n\t\t\t\t MXS_I2C_CTRL1_EARLY_TERM_IRQ | \\\n\t\t\t\t MXS_I2C_CTRL1_MASTER_LOSS_IRQ | \\\n\t\t\t\t MXS_I2C_CTRL1_SLAVE_STOP_IRQ | \\\n\t\t\t\t MXS_I2C_CTRL1_SLAVE_IRQ)\n\n\n#define MXS_CMD_I2C_SELECT\t(MXS_I2C_CTRL0_RETAIN_CLOCK |\t\\\n\t\t\t\t MXS_I2C_CTRL0_PRE_SEND_START |\t\\\n\t\t\t\t MXS_I2C_CTRL0_MASTER_MODE |\t\\\n\t\t\t\t MXS_I2C_CTRL0_DIRECTION |\t\\\n\t\t\t\t MXS_I2C_CTRL0_XFER_COUNT(1))\n\n#define MXS_CMD_I2C_WRITE\t(MXS_I2C_CTRL0_PRE_SEND_START |\t\\\n\t\t\t\t MXS_I2C_CTRL0_MASTER_MODE |\t\\\n\t\t\t\t MXS_I2C_CTRL0_DIRECTION)\n\n#define MXS_CMD_I2C_READ\t(MXS_I2C_CTRL0_SEND_NAK_ON_LAST | \\\n\t\t\t\t MXS_I2C_CTRL0_MASTER_MODE)\n\nenum mxs_i2c_devtype {\n\tMXS_I2C_UNKNOWN = 0,\n\tMXS_I2C_V1,\n\tMXS_I2C_V2,\n};\n\n \nstruct mxs_i2c_dev {\n\tstruct device *dev;\n\tenum mxs_i2c_devtype dev_type;\n\tvoid __iomem *regs;\n\tstruct completion cmd_complete;\n\tint cmd_err;\n\tstruct i2c_adapter adapter;\n\n\tuint32_t timing0;\n\tuint32_t timing1;\n\tuint32_t timing2;\n\n\t \n\tstruct dma_chan\t\t\t*dmach;\n\tuint32_t\t\t\tpio_data[2];\n\tuint32_t\t\t\taddr_data;\n\tstruct scatterlist\t\tsg_io[2];\n\tbool\t\t\t\tdma_read;\n};\n\nstatic int mxs_i2c_reset(struct mxs_i2c_dev *i2c)\n{\n\tint ret = stmp_reset_block(i2c->regs);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\twritel(i2c->timing0, i2c->regs + MXS_I2C_TIMING0);\n\twritel(i2c->timing1, i2c->regs + MXS_I2C_TIMING1);\n\twritel(i2c->timing2, i2c->regs + MXS_I2C_TIMING2);\n\n\twritel(MXS_I2C_IRQ_MASK << 8, i2c->regs + MXS_I2C_CTRL1_SET);\n\n\treturn 0;\n}\n\nstatic void mxs_i2c_dma_finish(struct mxs_i2c_dev *i2c)\n{\n\tif (i2c->dma_read) {\n\t\tdma_unmap_sg(i2c->dev, &i2c->sg_io[0], 1, DMA_TO_DEVICE);\n\t\tdma_unmap_sg(i2c->dev, &i2c->sg_io[1], 1, DMA_FROM_DEVICE);\n\t} else {\n\t\tdma_unmap_sg(i2c->dev, i2c->sg_io, 2, DMA_TO_DEVICE);\n\t}\n}\n\nstatic void mxs_i2c_dma_irq_callback(void *param)\n{\n\tstruct mxs_i2c_dev *i2c = param;\n\n\tcomplete(&i2c->cmd_complete);\n\tmxs_i2c_dma_finish(i2c);\n}\n\nstatic int mxs_i2c_dma_setup_xfer(struct i2c_adapter *adap,\n\t\t\tstruct i2c_msg *msg, u8 *buf, uint32_t flags)\n{\n\tstruct dma_async_tx_descriptor *desc;\n\tstruct mxs_i2c_dev *i2c = i2c_get_adapdata(adap);\n\n\ti2c->addr_data = i2c_8bit_addr_from_msg(msg);\n\n\tif (msg->flags & I2C_M_RD) {\n\t\ti2c->dma_read = true;\n\n\t\t \n\n\t\t \n\t\ti2c->pio_data[0] = MXS_CMD_I2C_SELECT;\n\t\tdesc = dmaengine_prep_slave_sg(i2c->dmach,\n\t\t\t\t\t(struct scatterlist *)&i2c->pio_data[0],\n\t\t\t\t\t1, DMA_TRANS_NONE, 0);\n\t\tif (!desc) {\n\t\t\tdev_err(i2c->dev,\n\t\t\t\t\"Failed to get PIO reg. write descriptor.\\n\");\n\t\t\tgoto select_init_pio_fail;\n\t\t}\n\n\t\t \n\t\tsg_init_one(&i2c->sg_io[0], &i2c->addr_data, 1);\n\t\tdma_map_sg(i2c->dev, &i2c->sg_io[0], 1, DMA_TO_DEVICE);\n\t\tdesc = dmaengine_prep_slave_sg(i2c->dmach, &i2c->sg_io[0], 1,\n\t\t\t\t\tDMA_MEM_TO_DEV,\n\t\t\t\t\tDMA_PREP_INTERRUPT |\n\t\t\t\t\tMXS_DMA_CTRL_WAIT4END);\n\t\tif (!desc) {\n\t\t\tdev_err(i2c->dev,\n\t\t\t\t\"Failed to get DMA data write descriptor.\\n\");\n\t\t\tgoto select_init_dma_fail;\n\t\t}\n\n\t\t \n\n\t\t \n\t\ti2c->pio_data[1] = flags | MXS_CMD_I2C_READ |\n\t\t\t\tMXS_I2C_CTRL0_XFER_COUNT(msg->len);\n\t\tdesc = dmaengine_prep_slave_sg(i2c->dmach,\n\t\t\t\t\t(struct scatterlist *)&i2c->pio_data[1],\n\t\t\t\t\t1, DMA_TRANS_NONE, DMA_PREP_INTERRUPT);\n\t\tif (!desc) {\n\t\t\tdev_err(i2c->dev,\n\t\t\t\t\"Failed to get PIO reg. write descriptor.\\n\");\n\t\t\tgoto select_init_dma_fail;\n\t\t}\n\n\t\t \n\t\tsg_init_one(&i2c->sg_io[1], buf, msg->len);\n\t\tdma_map_sg(i2c->dev, &i2c->sg_io[1], 1, DMA_FROM_DEVICE);\n\t\tdesc = dmaengine_prep_slave_sg(i2c->dmach, &i2c->sg_io[1], 1,\n\t\t\t\t\tDMA_DEV_TO_MEM,\n\t\t\t\t\tDMA_PREP_INTERRUPT |\n\t\t\t\t\tMXS_DMA_CTRL_WAIT4END);\n\t\tif (!desc) {\n\t\t\tdev_err(i2c->dev,\n\t\t\t\t\"Failed to get DMA data write descriptor.\\n\");\n\t\t\tgoto read_init_dma_fail;\n\t\t}\n\t} else {\n\t\ti2c->dma_read = false;\n\n\t\t \n\n\t\t \n\t\ti2c->pio_data[0] = flags | MXS_CMD_I2C_WRITE |\n\t\t\t\tMXS_I2C_CTRL0_XFER_COUNT(msg->len + 1);\n\t\tdesc = dmaengine_prep_slave_sg(i2c->dmach,\n\t\t\t\t\t(struct scatterlist *)&i2c->pio_data[0],\n\t\t\t\t\t1, DMA_TRANS_NONE, 0);\n\t\tif (!desc) {\n\t\t\tdev_err(i2c->dev,\n\t\t\t\t\"Failed to get PIO reg. write descriptor.\\n\");\n\t\t\tgoto write_init_pio_fail;\n\t\t}\n\n\t\t \n\t\tsg_init_table(i2c->sg_io, 2);\n\t\tsg_set_buf(&i2c->sg_io[0], &i2c->addr_data, 1);\n\t\tsg_set_buf(&i2c->sg_io[1], buf, msg->len);\n\t\tdma_map_sg(i2c->dev, i2c->sg_io, 2, DMA_TO_DEVICE);\n\t\tdesc = dmaengine_prep_slave_sg(i2c->dmach, i2c->sg_io, 2,\n\t\t\t\t\tDMA_MEM_TO_DEV,\n\t\t\t\t\tDMA_PREP_INTERRUPT |\n\t\t\t\t\tMXS_DMA_CTRL_WAIT4END);\n\t\tif (!desc) {\n\t\t\tdev_err(i2c->dev,\n\t\t\t\t\"Failed to get DMA data write descriptor.\\n\");\n\t\t\tgoto write_init_dma_fail;\n\t\t}\n\t}\n\n\t \n\tdesc->callback = mxs_i2c_dma_irq_callback;\n\tdesc->callback_param = i2c;\n\n\t \n\tdmaengine_submit(desc);\n\tdma_async_issue_pending(i2c->dmach);\n\treturn 0;\n\n \nread_init_dma_fail:\n\tdma_unmap_sg(i2c->dev, &i2c->sg_io[1], 1, DMA_FROM_DEVICE);\nselect_init_dma_fail:\n\tdma_unmap_sg(i2c->dev, &i2c->sg_io[0], 1, DMA_TO_DEVICE);\nselect_init_pio_fail:\n\tdmaengine_terminate_sync(i2c->dmach);\n\treturn -EINVAL;\n\n \nwrite_init_dma_fail:\n\tdma_unmap_sg(i2c->dev, i2c->sg_io, 2, DMA_TO_DEVICE);\nwrite_init_pio_fail:\n\tdmaengine_terminate_sync(i2c->dmach);\n\treturn -EINVAL;\n}\n\nstatic int mxs_i2c_pio_wait_xfer_end(struct mxs_i2c_dev *i2c)\n{\n\tunsigned long timeout = jiffies + msecs_to_jiffies(1000);\n\n\twhile (readl(i2c->regs + MXS_I2C_CTRL0) & MXS_I2C_CTRL0_RUN) {\n\t\tif (readl(i2c->regs + MXS_I2C_CTRL1) &\n\t\t\t\tMXS_I2C_CTRL1_NO_SLAVE_ACK_IRQ)\n\t\t\treturn -ENXIO;\n\t\tif (time_after(jiffies, timeout))\n\t\t\treturn -ETIMEDOUT;\n\t\tcond_resched();\n\t}\n\n\treturn 0;\n}\n\nstatic int mxs_i2c_pio_check_error_state(struct mxs_i2c_dev *i2c)\n{\n\tu32 state;\n\n\tstate = readl(i2c->regs + MXS_I2C_CTRL1_CLR) & MXS_I2C_IRQ_MASK;\n\n\tif (state & MXS_I2C_CTRL1_NO_SLAVE_ACK_IRQ)\n\t\ti2c->cmd_err = -ENXIO;\n\telse if (state & (MXS_I2C_CTRL1_EARLY_TERM_IRQ |\n\t\t\t  MXS_I2C_CTRL1_MASTER_LOSS_IRQ |\n\t\t\t  MXS_I2C_CTRL1_SLAVE_STOP_IRQ |\n\t\t\t  MXS_I2C_CTRL1_SLAVE_IRQ))\n\t\ti2c->cmd_err = -EIO;\n\n\treturn i2c->cmd_err;\n}\n\nstatic void mxs_i2c_pio_trigger_cmd(struct mxs_i2c_dev *i2c, u32 cmd)\n{\n\tu32 reg;\n\n\twritel(cmd, i2c->regs + MXS_I2C_CTRL0);\n\n\t \n\treg = readl(i2c->regs + MXS_I2C_CTRL0);\n\treg |= MXS_I2C_CTRL0_RUN;\n\twritel(reg, i2c->regs + MXS_I2C_CTRL0);\n}\n\n \nstatic void mxs_i2c_pio_trigger_write_cmd(struct mxs_i2c_dev *i2c, u32 cmd,\n\t\t\t\t\t  u32 data)\n{\n\twritel(cmd, i2c->regs + MXS_I2C_CTRL0);\n\n\tif (i2c->dev_type == MXS_I2C_V1)\n\t\twritel(MXS_I2C_CTRL0_PIO_MODE, i2c->regs + MXS_I2C_CTRL0_SET);\n\n\twritel(data, i2c->regs + MXS_I2C_DATA(i2c));\n\twritel(MXS_I2C_CTRL0_RUN, i2c->regs + MXS_I2C_CTRL0_SET);\n}\n\nstatic int mxs_i2c_pio_setup_xfer(struct i2c_adapter *adap,\n\t\t\tstruct i2c_msg *msg, uint32_t flags)\n{\n\tstruct mxs_i2c_dev *i2c = i2c_get_adapdata(adap);\n\tuint32_t addr_data = i2c_8bit_addr_from_msg(msg);\n\tuint32_t data = 0;\n\tint i, ret, xlen = 0, xmit = 0;\n\tuint32_t start;\n\n\t \n\twritel(MXS_I2C_IRQ_MASK << 8, i2c->regs + MXS_I2C_CTRL1_CLR);\n\n\t \n\tif (msg->flags & I2C_M_RD) {\n\t\t \n\t\tBUG_ON(msg->len > 4);\n\n\t\t \n\t\tmxs_i2c_pio_trigger_write_cmd(i2c, MXS_CMD_I2C_SELECT,\n\t\t\t\t\t      addr_data);\n\n\t\tret = mxs_i2c_pio_wait_xfer_end(i2c);\n\t\tif (ret) {\n\t\t\tdev_dbg(i2c->dev,\n\t\t\t\t\"PIO: Failed to send SELECT command!\\n\");\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t \n\t\tmxs_i2c_pio_trigger_cmd(i2c,\n\t\t\t\t\tMXS_CMD_I2C_READ | flags |\n\t\t\t\t\tMXS_I2C_CTRL0_XFER_COUNT(msg->len));\n\n\t\tret = mxs_i2c_pio_wait_xfer_end(i2c);\n\t\tif (ret) {\n\t\t\tdev_dbg(i2c->dev,\n\t\t\t\t\"PIO: Failed to send READ command!\\n\");\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tdata = readl(i2c->regs + MXS_I2C_DATA(i2c));\n\t\tfor (i = 0; i < msg->len; i++) {\n\t\t\tmsg->buf[i] = data & 0xff;\n\t\t\tdata >>= 8;\n\t\t}\n\t} else {\n\t\t \n\n\t\t \n\n\t\tdata = addr_data << 24;\n\n\t\t \n\t\tstart = MXS_I2C_CTRL0_PRE_SEND_START;\n\n\t\t \n\t\tif (msg->len > 3)\n\t\t\tstart |= MXS_I2C_CTRL0_RETAIN_CLOCK;\n\n\t\tfor (i = 0; i < msg->len; i++) {\n\t\t\tdata >>= 8;\n\t\t\tdata |= (msg->buf[i] << 24);\n\n\t\t\txmit = 0;\n\n\t\t\t \n\t\t\tif (i + 1 == msg->len) {\n\t\t\t\t \n\t\t\t\tstart |= flags;\n\t\t\t\t \n\t\t\t\tstart &= ~MXS_I2C_CTRL0_RETAIN_CLOCK;\n\t\t\t\txmit = 1;\n\t\t\t}\n\n\t\t\t \n\t\t\tif ((i & 3) == 2)\n\t\t\t\txmit = 1;\n\n\t\t\t \n\t\t\tif (!xmit)\n\t\t\t\tcontinue;\n\n\t\t\t \n\n\t\t\tif ((i % 4) == 3)\n\t\t\t\txlen = 1;\n\t\t\telse\n\t\t\t\txlen = (i % 4) + 2;\n\n\t\t\tdata >>= (4 - xlen) * 8;\n\n\t\t\tdev_dbg(i2c->dev,\n\t\t\t\t\"PIO: len=%i pos=%i total=%i [W%s%s%s]\\n\",\n\t\t\t\txlen, i, msg->len,\n\t\t\t\tstart & MXS_I2C_CTRL0_PRE_SEND_START ? \"S\" : \"\",\n\t\t\t\tstart & MXS_I2C_CTRL0_POST_SEND_STOP ? \"E\" : \"\",\n\t\t\t\tstart & MXS_I2C_CTRL0_RETAIN_CLOCK ? \"C\" : \"\");\n\n\t\t\twritel(MXS_I2C_DEBUG0_DMAREQ,\n\t\t\t       i2c->regs + MXS_I2C_DEBUG0_CLR(i2c));\n\n\t\t\tmxs_i2c_pio_trigger_write_cmd(i2c,\n\t\t\t\tstart | MXS_I2C_CTRL0_MASTER_MODE |\n\t\t\t\tMXS_I2C_CTRL0_DIRECTION |\n\t\t\t\tMXS_I2C_CTRL0_XFER_COUNT(xlen), data);\n\n\t\t\t \n\t\t\tstart &= ~MXS_I2C_CTRL0_PRE_SEND_START;\n\n\t\t\t \n\t\t\tret = mxs_i2c_pio_wait_xfer_end(i2c);\n\t\t\tif (ret) {\n\t\t\t\tdev_dbg(i2c->dev,\n\t\t\t\t\t\"PIO: Failed to finish WRITE cmd!\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\t\tret = readl(i2c->regs + MXS_I2C_STAT) &\n\t\t\t\t    MXS_I2C_STAT_GOT_A_NAK;\n\t\t\tif (ret) {\n\t\t\t\tret = -ENXIO;\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tret = mxs_i2c_pio_check_error_state(i2c);\n\ncleanup:\n\t \n\twritel(MXS_I2C_IRQ_MASK, i2c->regs + MXS_I2C_CTRL1_CLR);\n\twritel(MXS_I2C_IRQ_MASK << 8, i2c->regs + MXS_I2C_CTRL1_SET);\n\n\t \n\tif (i2c->dev_type == MXS_I2C_V1)\n\t\twritel(MXS_I2C_CTRL0_PIO_MODE, i2c->regs + MXS_I2C_CTRL0_CLR);\n\n\treturn ret;\n}\n\n \nstatic int mxs_i2c_xfer_msg(struct i2c_adapter *adap, struct i2c_msg *msg,\n\t\t\t\tint stop)\n{\n\tstruct mxs_i2c_dev *i2c = i2c_get_adapdata(adap);\n\tint ret;\n\tint flags;\n\tu8 *dma_buf;\n\tint use_pio = 0;\n\tunsigned long time_left;\n\n\tflags = stop ? MXS_I2C_CTRL0_POST_SEND_STOP : 0;\n\n\tdev_dbg(i2c->dev, \"addr: 0x%04x, len: %d, flags: 0x%x, stop: %d\\n\",\n\t\tmsg->addr, msg->len, msg->flags, stop);\n\n\t \n\tif ((msg->flags & I2C_M_RD) && (msg->len <= 4))\n\t\tuse_pio = 1;\n\tif (!(msg->flags & I2C_M_RD) && (msg->len < 7))\n\t\tuse_pio = 1;\n\n\ti2c->cmd_err = 0;\n\tif (use_pio) {\n\t\tret = mxs_i2c_pio_setup_xfer(adap, msg, flags);\n\t\t \n\t\tif (ret && (ret != -ENXIO))\n\t\t\tmxs_i2c_reset(i2c);\n\t} else {\n\t\tdma_buf = i2c_get_dma_safe_msg_buf(msg, 1);\n\t\tif (!dma_buf)\n\t\t\treturn -ENOMEM;\n\n\t\treinit_completion(&i2c->cmd_complete);\n\t\tret = mxs_i2c_dma_setup_xfer(adap, msg, dma_buf, flags);\n\t\tif (ret) {\n\t\t\ti2c_put_dma_safe_msg_buf(dma_buf, msg, false);\n\t\t\treturn ret;\n\t\t}\n\n\t\ttime_left = wait_for_completion_timeout(&i2c->cmd_complete,\n\t\t\t\t\t\tmsecs_to_jiffies(1000));\n\t\ti2c_put_dma_safe_msg_buf(dma_buf, msg, true);\n\t\tif (!time_left)\n\t\t\tgoto timeout;\n\n\t\tret = i2c->cmd_err;\n\t}\n\n\tif (ret == -ENXIO) {\n\t\t \n\t\twritel(MXS_I2C_CTRL1_CLR_GOT_A_NAK,\n\t\t       i2c->regs + MXS_I2C_CTRL1_SET);\n\t}\n\n\t \n\tif (i2c->dev_type == MXS_I2C_V1)\n\t\tmxs_i2c_reset(i2c);\n\n\tdev_dbg(i2c->dev, \"Done with err=%d\\n\", ret);\n\n\treturn ret;\n\ntimeout:\n\tdev_dbg(i2c->dev, \"Timeout!\\n\");\n\tmxs_i2c_dma_finish(i2c);\n\tret = mxs_i2c_reset(i2c);\n\tif (ret)\n\t\treturn ret;\n\n\treturn -ETIMEDOUT;\n}\n\nstatic int mxs_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg msgs[],\n\t\t\tint num)\n{\n\tint i;\n\tint err;\n\n\tfor (i = 0; i < num; i++) {\n\t\terr = mxs_i2c_xfer_msg(adap, &msgs[i], i == (num - 1));\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn num;\n}\n\nstatic u32 mxs_i2c_func(struct i2c_adapter *adap)\n{\n\treturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;\n}\n\nstatic irqreturn_t mxs_i2c_isr(int this_irq, void *dev_id)\n{\n\tstruct mxs_i2c_dev *i2c = dev_id;\n\tu32 stat = readl(i2c->regs + MXS_I2C_CTRL1) & MXS_I2C_IRQ_MASK;\n\n\tif (!stat)\n\t\treturn IRQ_NONE;\n\n\tif (stat & MXS_I2C_CTRL1_NO_SLAVE_ACK_IRQ)\n\t\ti2c->cmd_err = -ENXIO;\n\telse if (stat & (MXS_I2C_CTRL1_EARLY_TERM_IRQ |\n\t\t    MXS_I2C_CTRL1_MASTER_LOSS_IRQ |\n\t\t    MXS_I2C_CTRL1_SLAVE_STOP_IRQ | MXS_I2C_CTRL1_SLAVE_IRQ))\n\t\t \n\t\ti2c->cmd_err = -EIO;\n\n\twritel(stat, i2c->regs + MXS_I2C_CTRL1_CLR);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic const struct i2c_algorithm mxs_i2c_algo = {\n\t.master_xfer = mxs_i2c_xfer,\n\t.functionality = mxs_i2c_func,\n};\n\nstatic const struct i2c_adapter_quirks mxs_i2c_quirks = {\n\t.flags = I2C_AQ_NO_ZERO_LEN,\n};\n\nstatic void mxs_i2c_derive_timing(struct mxs_i2c_dev *i2c, uint32_t speed)\n{\n\t \n\tconst uint32_t clk = 24000000;\n\tuint32_t divider;\n\tuint16_t high_count, low_count, rcv_count, xmit_count;\n\tuint32_t bus_free, leadin;\n\tstruct device *dev = i2c->dev;\n\n\tdivider = DIV_ROUND_UP(clk, speed);\n\n\tif (divider < 25) {\n\t\t \n\t\tdivider = 25;\n\t\tdev_warn(dev,\n\t\t\t\"Speed too high (%u.%03u kHz), using %u.%03u kHz\\n\",\n\t\t\tspeed / 1000, speed % 1000,\n\t\t\tclk / divider / 1000, clk / divider % 1000);\n\t} else if (divider > 1897) {\n\t\t \n\t\tdivider = 1897;\n\t\tdev_warn(dev,\n\t\t\t\"Speed too low (%u.%03u kHz), using %u.%03u kHz\\n\",\n\t\t\tspeed / 1000, speed % 1000,\n\t\t\tclk / divider / 1000, clk / divider % 1000);\n\t}\n\n\t \n\tif (speed > I2C_MAX_STANDARD_MODE_FREQ) {\n\t\t \n\t\tlow_count = DIV_ROUND_CLOSEST(divider * 13, (13 + 6));\n\t\thigh_count = DIV_ROUND_CLOSEST(divider * 6, (13 + 6));\n\t\tleadin = DIV_ROUND_UP(600 * (clk / 1000000), 1000);\n\t\tbus_free = DIV_ROUND_UP(1300 * (clk / 1000000), 1000);\n\t} else {\n\t\t \n\t\tlow_count = DIV_ROUND_CLOSEST(divider * 47, (47 + 40));\n\t\thigh_count = DIV_ROUND_CLOSEST(divider * 40, (47 + 40));\n\t\tleadin = DIV_ROUND_UP(4700 * (clk / 1000000), 1000);\n\t\tbus_free = DIV_ROUND_UP(4700 * (clk / 1000000), 1000);\n\t}\n\trcv_count = high_count * 3 / 8;\n\txmit_count = low_count * 3 / 8;\n\n\tdev_dbg(dev,\n\t\t\"speed=%u(actual %u) divider=%u low=%u high=%u xmit=%u rcv=%u leadin=%u bus_free=%u\\n\",\n\t\tspeed, clk / divider, divider, low_count, high_count,\n\t\txmit_count, rcv_count, leadin, bus_free);\n\n\tlow_count -= 2;\n\thigh_count -= 7;\n\ti2c->timing0 = (high_count << 16) | rcv_count;\n\ti2c->timing1 = (low_count << 16) | xmit_count;\n\ti2c->timing2 = (bus_free << 16 | leadin);\n}\n\nstatic int mxs_i2c_get_ofdata(struct mxs_i2c_dev *i2c)\n{\n\tuint32_t speed;\n\tstruct device *dev = i2c->dev;\n\tstruct device_node *node = dev->of_node;\n\tint ret;\n\n\tret = of_property_read_u32(node, \"clock-frequency\", &speed);\n\tif (ret) {\n\t\tdev_warn(dev, \"No I2C speed selected, using 100kHz\\n\");\n\t\tspeed = I2C_MAX_STANDARD_MODE_FREQ;\n\t}\n\n\tmxs_i2c_derive_timing(i2c, speed);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id mxs_i2c_dt_ids[] = {\n\t{ .compatible = \"fsl,imx23-i2c\", .data = (void *)MXS_I2C_V1, },\n\t{ .compatible = \"fsl,imx28-i2c\", .data = (void *)MXS_I2C_V2, },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, mxs_i2c_dt_ids);\n\nstatic int mxs_i2c_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct mxs_i2c_dev *i2c;\n\tstruct i2c_adapter *adap;\n\tint err, irq;\n\n\ti2c = devm_kzalloc(dev, sizeof(*i2c), GFP_KERNEL);\n\tif (!i2c)\n\t\treturn -ENOMEM;\n\n\ti2c->dev_type = (uintptr_t)of_device_get_match_data(&pdev->dev);\n\n\ti2c->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(i2c->regs))\n\t\treturn PTR_ERR(i2c->regs);\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\terr = devm_request_irq(dev, irq, mxs_i2c_isr, 0, dev_name(dev), i2c);\n\tif (err)\n\t\treturn err;\n\n\ti2c->dev = dev;\n\n\tinit_completion(&i2c->cmd_complete);\n\n\tif (dev->of_node) {\n\t\terr = mxs_i2c_get_ofdata(i2c);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t \n\ti2c->dmach = dma_request_chan(dev, \"rx-tx\");\n\tif (IS_ERR(i2c->dmach)) {\n\t\treturn dev_err_probe(dev, PTR_ERR(i2c->dmach),\n\t\t\t\t     \"Failed to request dma\\n\");\n\t}\n\n\tplatform_set_drvdata(pdev, i2c);\n\n\t \n\terr = mxs_i2c_reset(i2c);\n\tif (err)\n\t\treturn err;\n\n\tadap = &i2c->adapter;\n\tstrscpy(adap->name, \"MXS I2C adapter\", sizeof(adap->name));\n\tadap->owner = THIS_MODULE;\n\tadap->algo = &mxs_i2c_algo;\n\tadap->quirks = &mxs_i2c_quirks;\n\tadap->dev.parent = dev;\n\tadap->nr = pdev->id;\n\tadap->dev.of_node = pdev->dev.of_node;\n\ti2c_set_adapdata(adap, i2c);\n\terr = i2c_add_numbered_adapter(adap);\n\tif (err) {\n\t\twritel(MXS_I2C_CTRL0_SFTRST,\n\t\t\t\ti2c->regs + MXS_I2C_CTRL0_SET);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic void mxs_i2c_remove(struct platform_device *pdev)\n{\n\tstruct mxs_i2c_dev *i2c = platform_get_drvdata(pdev);\n\n\ti2c_del_adapter(&i2c->adapter);\n\n\tif (i2c->dmach)\n\t\tdma_release_channel(i2c->dmach);\n\n\twritel(MXS_I2C_CTRL0_SFTRST, i2c->regs + MXS_I2C_CTRL0_SET);\n}\n\nstatic struct platform_driver mxs_i2c_driver = {\n\t.driver = {\n\t\t   .name = DRIVER_NAME,\n\t\t   .of_match_table = mxs_i2c_dt_ids,\n\t\t   },\n\t.probe = mxs_i2c_probe,\n\t.remove_new = mxs_i2c_remove,\n};\n\nstatic int __init mxs_i2c_init(void)\n{\n\treturn platform_driver_register(&mxs_i2c_driver);\n}\nsubsys_initcall(mxs_i2c_init);\n\nstatic void __exit mxs_i2c_exit(void)\n{\n\tplatform_driver_unregister(&mxs_i2c_driver);\n}\nmodule_exit(mxs_i2c_exit);\n\nMODULE_AUTHOR(\"Marek Vasut <marex@denx.de>\");\nMODULE_AUTHOR(\"Wolfram Sang <kernel@pengutronix.de>\");\nMODULE_DESCRIPTION(\"MXS I2C Bus Driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:\" DRIVER_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}