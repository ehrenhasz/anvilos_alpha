{
  "module_name": "i2c-mchp-pci1xxxx.c",
  "hash_id": "5fded2992a23389ff380bde4b48393dd6949eafff9fd5c46077a10b9914e79af",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-mchp-pci1xxxx.c",
  "human_readable_source": "\n \n\n#include <linux/bits.h>\n#include <linux/delay.h>\n#include <linux/i2c.h>\n#include <linux/i2c-smbus.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/types.h>\n\n#define SMBUS_MAST_CORE_ADDR_BASE\t\t0x00000\n#define SMBUS_MAST_SYS_REG_ADDR_BASE\t\t0x01000\n\n \n#define SMB_CORE_CTRL_REG_OFF\t(SMBUS_MAST_CORE_ADDR_BASE + 0x00)\n\n#define SMB_CORE_CTRL_ESO\t\tBIT(6)\n#define SMB_CORE_CTRL_FW_ACK\t\tBIT(4)\n#define SMB_CORE_CTRL_ACK\t\tBIT(0)\n\n#define SMB_CORE_CMD_REG_OFF3\t(SMBUS_MAST_CORE_ADDR_BASE + 0x0F)\n#define SMB_CORE_CMD_REG_OFF2\t(SMBUS_MAST_CORE_ADDR_BASE + 0x0E)\n#define SMB_CORE_CMD_REG_OFF1\t(SMBUS_MAST_CORE_ADDR_BASE + 0x0D)\n\n#define SMB_CORE_CMD_READM\t\tBIT(4)\n#define SMB_CORE_CMD_STOP\t\tBIT(2)\n#define SMB_CORE_CMD_START\t\tBIT(0)\n\n#define SMB_CORE_CMD_REG_OFF0\t(SMBUS_MAST_CORE_ADDR_BASE + 0x0C)\n\n#define SMB_CORE_CMD_M_PROCEED\t\tBIT(1)\n#define SMB_CORE_CMD_M_RUN\t\tBIT(0)\n\n#define SMB_CORE_SR_HOLD_TIME_REG_OFF\t(SMBUS_MAST_CORE_ADDR_BASE + 0x18)\n\n \n#define SR_HOLD_TIME_100K_TICKS\t\t150\n#define SR_HOLD_TIME_400K_TICKS\t\t20\n#define SR_HOLD_TIME_1000K_TICKS\t12\n\n#define SMB_CORE_COMPLETION_REG_OFF3\t(SMBUS_MAST_CORE_ADDR_BASE + 0x23)\n\n#define COMPLETION_MDONE\t\tBIT(6)\n#define COMPLETION_IDLE\t\t\tBIT(5)\n#define COMPLETION_MNAKX\t\tBIT(0)\n\n#define SMB_CORE_IDLE_SCALING_REG_OFF\t(SMBUS_MAST_CORE_ADDR_BASE + 0x24)\n\n \n#define FAIR_BUS_IDLE_MIN_100K_TICKS\t\t992\n#define FAIR_BUS_IDLE_MIN_400K_TICKS\t\t500\n#define FAIR_BUS_IDLE_MIN_1000K_TICKS\t\t500\n\n \n#define FAIR_IDLE_DELAY_100K_TICKS\t963\n#define FAIR_IDLE_DELAY_400K_TICKS\t156\n#define FAIR_IDLE_DELAY_1000K_TICKS\t156\n\n#define SMB_IDLE_SCALING_100K\t\t\\\n\t((FAIR_IDLE_DELAY_100K_TICKS << 16) | FAIR_BUS_IDLE_MIN_100K_TICKS)\n#define SMB_IDLE_SCALING_400K\t\t\\\n\t((FAIR_IDLE_DELAY_400K_TICKS << 16) | FAIR_BUS_IDLE_MIN_400K_TICKS)\n#define SMB_IDLE_SCALING_1000K\t\\\n\t((FAIR_IDLE_DELAY_1000K_TICKS << 16) | FAIR_BUS_IDLE_MIN_1000K_TICKS)\n\n#define SMB_CORE_CONFIG_REG3\t\t(SMBUS_MAST_CORE_ADDR_BASE + 0x2B)\n\n#define SMB_CONFIG3_ENMI\t\tBIT(6)\n#define SMB_CONFIG3_ENIDI\t\tBIT(5)\n\n#define SMB_CORE_CONFIG_REG2\t\t(SMBUS_MAST_CORE_ADDR_BASE + 0x2A)\n#define SMB_CORE_CONFIG_REG1\t\t(SMBUS_MAST_CORE_ADDR_BASE + 0x29)\n\n#define SMB_CONFIG1_ASR\t\t\tBIT(7)\n#define SMB_CONFIG1_ENAB\t\tBIT(2)\n#define SMB_CONFIG1_RESET\t\tBIT(1)\n#define SMB_CONFIG1_FEN\t\t\tBIT(0)\n\n#define SMB_CORE_BUS_CLK_REG_OFF\t(SMBUS_MAST_CORE_ADDR_BASE + 0x2C)\n\n \n#define BUS_CLK_100K_LOW_PERIOD_TICKS\t\t156\n#define BUS_CLK_400K_LOW_PERIOD_TICKS\t\t41\n#define BUS_CLK_1000K_LOW_PERIOD_TICKS\t\t15\n\n \n#define BUS_CLK_100K_HIGH_PERIOD_TICKS\t154\n#define BUS_CLK_400K_HIGH_PERIOD_TICKS\t35\n#define BUS_CLK_1000K_HIGH_PERIOD_TICKS\t14\n\n#define BUS_CLK_100K\t\t\t\\\n\t((BUS_CLK_100K_HIGH_PERIOD_TICKS << 8) | BUS_CLK_100K_LOW_PERIOD_TICKS)\n#define BUS_CLK_400K\t\t\t\\\n\t((BUS_CLK_400K_HIGH_PERIOD_TICKS << 8) | BUS_CLK_400K_LOW_PERIOD_TICKS)\n#define BUS_CLK_1000K\t\t\t\\\n\t((BUS_CLK_1000K_HIGH_PERIOD_TICKS << 8) | BUS_CLK_1000K_LOW_PERIOD_TICKS)\n\n#define SMB_CORE_CLK_SYNC_REG_OFF\t(SMBUS_MAST_CORE_ADDR_BASE + 0x3C)\n\n \n#define CLK_SYNC_100K\t\t\t4\n#define CLK_SYNC_400K\t\t\t4\n#define CLK_SYNC_1000K\t\t\t4\n\n#define SMB_CORE_DATA_TIMING_REG_OFF\t(SMBUS_MAST_CORE_ADDR_BASE + 0x40)\n\n \n#define FIRST_START_HOLD_100K_TICKS\t23\n#define FIRST_START_HOLD_400K_TICKS\t8\n#define FIRST_START_HOLD_1000K_TICKS\t12\n\n \n#define STOP_SETUP_100K_TICKS\t\t150\n#define STOP_SETUP_400K_TICKS\t\t20\n#define STOP_SETUP_1000K_TICKS\t\t12\n\n \n#define RESTART_SETUP_100K_TICKS\t156\n#define RESTART_SETUP_400K_TICKS\t20\n#define RESTART_SETUP_1000K_TICKS\t12\n\n \n#define DATA_HOLD_100K_TICKS\t\t12\n#define DATA_HOLD_400K_TICKS\t\t2\n#define DATA_HOLD_1000K_TICKS\t\t2\n\n#define DATA_TIMING_100K\t\t\\\n\t((FIRST_START_HOLD_100K_TICKS << 24) | (STOP_SETUP_100K_TICKS << 16) | \\\n\t(RESTART_SETUP_100K_TICKS << 8) | DATA_HOLD_100K_TICKS)\n#define DATA_TIMING_400K\t\t\\\n\t((FIRST_START_HOLD_400K_TICKS << 24) | (STOP_SETUP_400K_TICKS << 16) | \\\n\t(RESTART_SETUP_400K_TICKS << 8) | DATA_HOLD_400K_TICKS)\n#define DATA_TIMING_1000K\t\t\\\n\t((FIRST_START_HOLD_1000K_TICKS << 24) | (STOP_SETUP_1000K_TICKS << 16) | \\\n\t(RESTART_SETUP_1000K_TICKS << 8) | DATA_HOLD_1000K_TICKS)\n\n#define SMB_CORE_TO_SCALING_REG_OFF\t(SMBUS_MAST_CORE_ADDR_BASE + 0x44)\n\n \n#define BUS_IDLE_MIN_100K_TICKS\t\t36UL\n#define BUS_IDLE_MIN_400K_TICKS\t\t10UL\n#define BUS_IDLE_MIN_1000K_TICKS\t4UL\n\n \n#define CTRL_CUM_TIME_OUT_100K_TICKS\t\t76\n#define CTRL_CUM_TIME_OUT_400K_TICKS\t\t76\n#define CTRL_CUM_TIME_OUT_1000K_TICKS\t\t76\n\n \n#define TARGET_CUM_TIME_OUT_100K_TICKS\t95\n#define TARGET_CUM_TIME_OUT_400K_TICKS\t95\n#define TARGET_CUM_TIME_OUT_1000K_TICKS\t95\n\n \n#define CLOCK_HIGH_TIME_OUT_100K_TICKS\t97\n#define CLOCK_HIGH_TIME_OUT_400K_TICKS\t97\n#define CLOCK_HIGH_TIME_OUT_1000K_TICKS\t97\n\n#define TO_SCALING_100K\t\t\\\n\t((BUS_IDLE_MIN_100K_TICKS << 24) | (CTRL_CUM_TIME_OUT_100K_TICKS << 16) | \\\n\t(TARGET_CUM_TIME_OUT_100K_TICKS << 8) | CLOCK_HIGH_TIME_OUT_100K_TICKS)\n#define TO_SCALING_400K\t\t\\\n\t((BUS_IDLE_MIN_400K_TICKS << 24) | (CTRL_CUM_TIME_OUT_400K_TICKS << 16) | \\\n\t(TARGET_CUM_TIME_OUT_400K_TICKS << 8) | CLOCK_HIGH_TIME_OUT_400K_TICKS)\n#define TO_SCALING_1000K\t\t\\\n\t((BUS_IDLE_MIN_1000K_TICKS << 24) | (CTRL_CUM_TIME_OUT_1000K_TICKS << 16) | \\\n\t(TARGET_CUM_TIME_OUT_1000K_TICKS << 8) | CLOCK_HIGH_TIME_OUT_1000K_TICKS)\n\n#define I2C_SCL_PAD_CTRL_REG_OFF\t(SMBUS_MAST_CORE_ADDR_BASE + 0x100)\n#define I2C_SDA_PAD_CTRL_REG_OFF\t(SMBUS_MAST_CORE_ADDR_BASE + 0x101)\n\n#define I2C_FOD_EN\t\t\tBIT(4)\n#define I2C_PULL_UP_EN\t\t\tBIT(3)\n#define I2C_PULL_DOWN_EN\t\tBIT(2)\n#define I2C_INPUT_EN\t\t\tBIT(1)\n#define I2C_OUTPUT_EN\t\t\tBIT(0)\n\n#define SMBUS_CONTROL_REG_OFF\t(SMBUS_MAST_CORE_ADDR_BASE + 0x200)\n\n#define CTL_RESET_COUNTERS\t\tBIT(3)\n#define CTL_TRANSFER_DIR\t\tBIT(2)\n#define CTL_HOST_FIFO_ENTRY\t\tBIT(1)\n#define CTL_RUN\t\t\t\tBIT(0)\n\n#define I2C_DIRN_WRITE\t\t\t0\n#define I2C_DIRN_READ\t\t\t1\n\n#define SMBUS_STATUS_REG_OFF\t(SMBUS_MAST_CORE_ADDR_BASE + 0x204)\n\n#define STA_DMA_TERM\t\t\tBIT(7)\n#define STA_DMA_REQ\t\t\tBIT(6)\n#define STA_THRESHOLD\t\t\tBIT(2)\n#define STA_BUF_FULL\t\t\tBIT(1)\n#define STA_BUF_EMPTY\t\t\tBIT(0)\n\n#define SMBUS_INTR_STAT_REG_OFF\t(SMBUS_MAST_CORE_ADDR_BASE + 0x208)\n\n#define INTR_STAT_DMA_TERM\t\tBIT(7)\n#define INTR_STAT_THRESHOLD\t\tBIT(2)\n#define INTR_STAT_BUF_FULL\t\tBIT(1)\n#define INTR_STAT_BUF_EMPTY\t\tBIT(0)\n\n#define SMBUS_INTR_MSK_REG_OFF\t(SMBUS_MAST_CORE_ADDR_BASE + 0x20C)\n\n#define INTR_MSK_DMA_TERM\t\tBIT(7)\n#define INTR_MSK_THRESHOLD\t\tBIT(2)\n#define INTR_MSK_BUF_FULL\t\tBIT(1)\n#define INTR_MSK_BUF_EMPTY\t\tBIT(0)\n\n#define ALL_NW_LAYER_INTERRUPTS  \\\n\t(INTR_MSK_DMA_TERM | INTR_MSK_THRESHOLD | INTR_MSK_BUF_FULL | \\\n\t INTR_MSK_BUF_EMPTY)\n\n#define SMBUS_MCU_COUNTER_REG_OFF\t(SMBUS_MAST_CORE_ADDR_BASE + 0x214)\n\n#define SMBALERT_MST_PAD_CTRL_REG_OFF\t(SMBUS_MAST_CORE_ADDR_BASE + 0x230)\n\n#define SMBALERT_MST_PU\t\t\tBIT(0)\n\n#define SMBUS_GEN_INT_STAT_REG_OFF\t(SMBUS_MAST_CORE_ADDR_BASE + 0x23C)\n\n#define SMBUS_GEN_INT_MASK_REG_OFF\t(SMBUS_MAST_CORE_ADDR_BASE + 0x240)\n\n#define SMBALERT_INTR_MASK\t\tBIT(10)\n#define I2C_BUF_MSTR_INTR_MASK\t\tBIT(9)\n#define I2C_INTR_MASK\t\t\tBIT(8)\n#define SMBALERT_WAKE_INTR_MASK\t\tBIT(2)\n#define I2C_BUF_MSTR_WAKE_INTR_MASK\tBIT(1)\n#define I2C_WAKE_INTR_MASK\t\tBIT(0)\n\n#define ALL_HIGH_LAYER_INTR     \\\n\t(SMBALERT_INTR_MASK | I2C_BUF_MSTR_INTR_MASK | I2C_INTR_MASK | \\\n\tSMBALERT_WAKE_INTR_MASK | I2C_BUF_MSTR_WAKE_INTR_MASK | \\\n\tI2C_WAKE_INTR_MASK)\n\n#define SMBUS_RESET_REG\t\t(SMBUS_MAST_CORE_ADDR_BASE + 0x248)\n\n#define PERI_SMBUS_D3_RESET_DIS\t\tBIT(16)\n\n#define SMBUS_MST_BUF\t\t(SMBUS_MAST_CORE_ADDR_BASE + 0x280)\n\n#define SMBUS_BUF_MAX_SIZE\t\t0x80\n\n#define I2C_FLAGS_DIRECT_MODE\t\tBIT(7)\n#define I2C_FLAGS_POLLING_MODE\t\tBIT(6)\n#define I2C_FLAGS_STOP\t\t\tBIT(5)\n#define I2C_FLAGS_SMB_BLK_READ\t\tBIT(4)\n\n#define PCI1XXXX_I2C_TIMEOUT_MS\t\t1000\n\n \n#define SMB_GPR_REG\t\t(SMBUS_MAST_CORE_ADDR_BASE + 0x1000 + 0x0c00 + \\\n\t\t\t\t0x00)\n\n \n#define SMB_GPR_LOCK_REG\t(SMBUS_MAST_CORE_ADDR_BASE + 0x1000 + 0x0000 + \\\n\t\t\t\t0x00A0)\n\n#define SMBUS_PERI_LOCK\t\tBIT(3)\n\nstruct pci1xxxx_i2c {\n\tstruct completion i2c_xfer_done;\n\tbool i2c_xfer_in_progress;\n\tstruct i2c_adapter adap;\n\tvoid __iomem *i2c_base;\n\tu32 freq;\n\tu32 flags;\n};\n\nstatic int set_sys_lock(struct pci1xxxx_i2c *i2c)\n{\n\tvoid __iomem *p = i2c->i2c_base + SMB_GPR_LOCK_REG;\n\tu8 data;\n\n\twritel(SMBUS_PERI_LOCK, p);\n\tdata = readl(p);\n\tif (data != SMBUS_PERI_LOCK)\n\t\treturn -EPERM;\n\n\treturn 0;\n}\n\nstatic int release_sys_lock(struct pci1xxxx_i2c *i2c)\n{\n\tvoid __iomem *p = i2c->i2c_base + SMB_GPR_LOCK_REG;\n\tu8 data;\n\n\tdata = readl(p);\n\tif (data != SMBUS_PERI_LOCK)\n\t\treturn 0;\n\n\twritel(0, p);\n\tdata = readl(p);\n\tif (data & SMBUS_PERI_LOCK)\n\t\treturn -EPERM;\n\n\treturn 0;\n}\n\nstatic void pci1xxxx_ack_high_level_intr(struct pci1xxxx_i2c *i2c, u16 intr_msk)\n{\n\twritew(intr_msk, i2c->i2c_base + SMBUS_GEN_INT_STAT_REG_OFF);\n}\n\nstatic void pci1xxxx_i2c_configure_smbalert_pin(struct pci1xxxx_i2c *i2c,\n\t\t\t\t\t\tbool enable)\n{\n\tvoid __iomem *p = i2c->i2c_base + SMBALERT_MST_PAD_CTRL_REG_OFF;\n\tu8 regval;\n\n\tregval = readb(p);\n\n\tif (enable)\n\t\tregval |= SMBALERT_MST_PU;\n\telse\n\t\tregval &= ~SMBALERT_MST_PU;\n\n\twriteb(regval, p);\n}\n\nstatic void pci1xxxx_i2c_send_start_stop(struct pci1xxxx_i2c *i2c, bool start)\n{\n\tvoid __iomem *p = i2c->i2c_base + SMB_CORE_CMD_REG_OFF1;\n\tu8 regval;\n\n\tregval = readb(p);\n\n\tif (start)\n\t\tregval |= SMB_CORE_CMD_START;\n\telse\n\t\tregval |= SMB_CORE_CMD_STOP;\n\n\twriteb(regval, p);\n}\n\n \nstatic void pci1xxxx_i2c_set_clear_FW_ACK(struct pci1xxxx_i2c *i2c, bool set)\n{\n\tu8 regval;\n\n\tif (set)\n\t\tregval = SMB_CORE_CTRL_FW_ACK | SMB_CORE_CTRL_ESO | SMB_CORE_CTRL_ACK;\n\telse\n\t\tregval = SMB_CORE_CTRL_ESO | SMB_CORE_CTRL_ACK;\n\n\twriteb(regval, i2c->i2c_base + SMB_CORE_CTRL_REG_OFF);\n}\n\nstatic void pci1xxxx_i2c_buffer_write(struct pci1xxxx_i2c *i2c, u8 slaveaddr,\n\t\t\t\t      u8 transferlen, unsigned char *buf)\n{\n\tvoid __iomem *p = i2c->i2c_base + SMBUS_MST_BUF;\n\n\tif (slaveaddr)\n\t\twriteb(slaveaddr, p++);\n\n\tif (buf)\n\t\tmemcpy_toio(p, buf, transferlen);\n}\n\n \nstatic void pci1xxxx_i2c_enable_ESO(struct pci1xxxx_i2c *i2c)\n{\n\twriteb(SMB_CORE_CTRL_ESO, i2c->i2c_base + SMB_CORE_CTRL_REG_OFF);\n}\n\nstatic void pci1xxxx_i2c_reset_counters(struct pci1xxxx_i2c *i2c)\n{\n\tvoid __iomem *p = i2c->i2c_base + SMBUS_CONTROL_REG_OFF;\n\tu8 regval;\n\n\tregval = readb(p);\n\tregval |= CTL_RESET_COUNTERS;\n\twriteb(regval, p);\n}\n\nstatic void pci1xxxx_i2c_set_transfer_dir(struct pci1xxxx_i2c *i2c, u8 direction)\n{\n\tvoid __iomem *p = i2c->i2c_base + SMBUS_CONTROL_REG_OFF;\n\tu8 regval;\n\n\tregval = readb(p);\n\tif (direction == I2C_DIRN_WRITE)\n\t\tregval &= ~CTL_TRANSFER_DIR;\n\telse\n\t\tregval |= CTL_TRANSFER_DIR;\n\n\twriteb(regval, p);\n}\n\nstatic void pci1xxxx_i2c_set_mcu_count(struct pci1xxxx_i2c *i2c, u8 count)\n{\n\twriteb(count, i2c->i2c_base + SMBUS_MCU_COUNTER_REG_OFF);\n}\n\nstatic void pci1xxxx_i2c_set_read_count(struct pci1xxxx_i2c *i2c, u8 readcount)\n{\n\twriteb(readcount, i2c->i2c_base + SMB_CORE_CMD_REG_OFF3);\n}\n\nstatic void pci1xxxx_i2c_set_write_count(struct pci1xxxx_i2c *i2c, u8 writecount)\n{\n\twriteb(writecount, i2c->i2c_base + SMB_CORE_CMD_REG_OFF2);\n}\n\nstatic void pci1xxxx_i2c_set_DMA_run(struct pci1xxxx_i2c *i2c)\n{\n\tvoid __iomem *p = i2c->i2c_base + SMBUS_CONTROL_REG_OFF;\n\tu8 regval;\n\n\tregval = readb(p);\n\tregval |= CTL_RUN;\n\twriteb(regval, p);\n}\n\nstatic void pci1xxxx_i2c_set_mrun_proceed(struct pci1xxxx_i2c *i2c)\n{\n\tvoid __iomem *p = i2c->i2c_base + SMB_CORE_CMD_REG_OFF0;\n\tu8 regval;\n\n\tregval = readb(p);\n\tregval |= SMB_CORE_CMD_M_RUN;\n\tregval |= SMB_CORE_CMD_M_PROCEED;\n\twriteb(regval, p);\n}\n\nstatic void pci1xxxx_i2c_start_DMA(struct pci1xxxx_i2c *i2c)\n{\n\tpci1xxxx_i2c_set_DMA_run(i2c);\n\tpci1xxxx_i2c_set_mrun_proceed(i2c);\n}\n\nstatic void pci1xxxx_i2c_config_asr(struct pci1xxxx_i2c *i2c, bool enable)\n{\n\tvoid __iomem *p = i2c->i2c_base + SMB_CORE_CONFIG_REG1;\n\tu8 regval;\n\n\tregval = readb(p);\n\tif (enable)\n\t\tregval |= SMB_CONFIG1_ASR;\n\telse\n\t\tregval &= ~SMB_CONFIG1_ASR;\n\twriteb(regval, p);\n}\n\nstatic irqreturn_t pci1xxxx_i2c_isr(int irq, void *dev)\n{\n\tstruct pci1xxxx_i2c *i2c = dev;\n\tvoid __iomem *p1 = i2c->i2c_base + SMBUS_GEN_INT_STAT_REG_OFF;\n\tvoid __iomem *p2 = i2c->i2c_base + SMBUS_INTR_STAT_REG_OFF;\n\tirqreturn_t intr_handled = IRQ_NONE;\n\tu16 reg1;\n\tu8 reg3;\n\n\t \n\treg1 = readw(p1);\n\n\tif (reg1 & I2C_BUF_MSTR_INTR_MASK) {\n\t\treg3 = readb(p2);\n\t\tif (reg3 & INTR_STAT_DMA_TERM) {\n\t\t\tcomplete(&i2c->i2c_xfer_done);\n\t\t\tintr_handled = IRQ_HANDLED;\n\t\t\twriteb(INTR_STAT_DMA_TERM, p2);\n\t\t}\n\t\tpci1xxxx_ack_high_level_intr(i2c, I2C_BUF_MSTR_INTR_MASK);\n\t}\n\n\tif (reg1 & SMBALERT_INTR_MASK) {\n\t\tintr_handled = IRQ_HANDLED;\n\t\tpci1xxxx_ack_high_level_intr(i2c, SMBALERT_INTR_MASK);\n\t}\n\n\treturn intr_handled;\n}\n\nstatic void pci1xxxx_i2c_set_count(struct pci1xxxx_i2c *i2c, u8 mcucount,\n\t\t\t\t   u8 writecount, u8 readcount)\n{\n\tpci1xxxx_i2c_set_mcu_count(i2c, mcucount);\n\tpci1xxxx_i2c_set_write_count(i2c, writecount);\n\tpci1xxxx_i2c_set_read_count(i2c, readcount);\n}\n\nstatic void pci1xxxx_i2c_set_readm(struct pci1xxxx_i2c *i2c, bool enable)\n{\n\tvoid __iomem *p = i2c->i2c_base + SMB_CORE_CMD_REG_OFF1;\n\tu8 regval;\n\n\tregval = readb(p);\n\tif (enable)\n\t\tregval |= SMB_CORE_CMD_READM;\n\telse\n\t\tregval &= ~SMB_CORE_CMD_READM;\n\n\twriteb(regval, p);\n}\n\nstatic void pci1xxxx_ack_nw_layer_intr(struct pci1xxxx_i2c *i2c, u8 ack_intr_msk)\n{\n\twriteb(ack_intr_msk, i2c->i2c_base + SMBUS_INTR_STAT_REG_OFF);\n}\n\nstatic void pci1xxxx_config_nw_layer_intr(struct pci1xxxx_i2c *i2c,\n\t\t\t\t\t  u8 intr_msk, bool enable)\n{\n\tvoid __iomem *p = i2c->i2c_base + SMBUS_INTR_MSK_REG_OFF;\n\tu8 regval;\n\n\tregval = readb(p);\n\tif (enable)\n\t\tregval &= ~intr_msk;\n\telse\n\t\tregval |= intr_msk;\n\n\twriteb(regval, p);\n}\n\nstatic void pci1xxxx_i2c_config_padctrl(struct pci1xxxx_i2c *i2c, bool enable)\n{\n\tvoid __iomem *p1 = i2c->i2c_base + I2C_SCL_PAD_CTRL_REG_OFF;\n\tvoid __iomem *p2 = i2c->i2c_base + I2C_SDA_PAD_CTRL_REG_OFF;\n\tu8 regval;\n\n\tregval = readb(p1);\n\tif (enable)\n\t\tregval |= I2C_INPUT_EN | I2C_OUTPUT_EN;\n\telse\n\t\tregval &= ~(I2C_INPUT_EN | I2C_OUTPUT_EN);\n\n\twriteb(regval, p1);\n\n\tregval = readb(p2);\n\tif (enable)\n\t\tregval |= I2C_INPUT_EN | I2C_OUTPUT_EN;\n\telse\n\t\tregval &= ~(I2C_INPUT_EN | I2C_OUTPUT_EN);\n\n\twriteb(regval, p2);\n}\n\nstatic void pci1xxxx_i2c_set_mode(struct pci1xxxx_i2c *i2c)\n{\n\tvoid __iomem *p = i2c->i2c_base + SMBUS_CONTROL_REG_OFF;\n\tu8 regval;\n\n\tregval = readb(p);\n\tif (i2c->flags & I2C_FLAGS_DIRECT_MODE)\n\t\tregval &= ~CTL_HOST_FIFO_ENTRY;\n\telse\n\t\tregval |= CTL_HOST_FIFO_ENTRY;\n\n\twriteb(regval, p);\n}\n\nstatic void pci1xxxx_i2c_config_high_level_intr(struct pci1xxxx_i2c *i2c,\n\t\t\t\t\t\tu16 intr_msk, bool enable)\n{\n\tvoid __iomem *p = i2c->i2c_base + SMBUS_GEN_INT_MASK_REG_OFF;\n\tu16 regval;\n\n\tregval = readw(p);\n\tif (enable)\n\t\tregval &= ~intr_msk;\n\telse\n\t\tregval |= intr_msk;\n\twritew(regval, p);\n}\n\nstatic void pci1xxxx_i2c_configure_core_reg(struct pci1xxxx_i2c *i2c, bool enable)\n{\n\tvoid __iomem *p1 = i2c->i2c_base + SMB_CORE_CONFIG_REG1;\n\tvoid __iomem *p3 = i2c->i2c_base + SMB_CORE_CONFIG_REG3;\n\tu8 reg1;\n\tu8 reg3;\n\n\treg1 = readb(p1);\n\treg3 = readb(p3);\n\tif (enable) {\n\t\treg1 |= SMB_CONFIG1_ENAB | SMB_CONFIG1_FEN;\n\t\treg3 |= SMB_CONFIG3_ENMI | SMB_CONFIG3_ENIDI;\n\t} else {\n\t\treg1 &= ~(SMB_CONFIG1_ENAB | SMB_CONFIG1_FEN);\n\t\treg3 &= ~(SMB_CONFIG3_ENMI | SMB_CONFIG3_ENIDI);\n\t}\n\n\twriteb(reg1, p1);\n\twriteb(reg3, p3);\n}\n\nstatic void pci1xxxx_i2c_set_freq(struct pci1xxxx_i2c *i2c)\n{\n\tvoid __iomem *bp = i2c->i2c_base;\n\tvoid __iomem *p_idle_scaling = bp + SMB_CORE_IDLE_SCALING_REG_OFF;\n\tvoid __iomem *p_data_timing = bp + SMB_CORE_DATA_TIMING_REG_OFF;\n\tvoid __iomem *p_hold_time = bp + SMB_CORE_SR_HOLD_TIME_REG_OFF;\n\tvoid __iomem *p_to_scaling = bp + SMB_CORE_TO_SCALING_REG_OFF;\n\tvoid __iomem *p_clk_sync = bp + SMB_CORE_CLK_SYNC_REG_OFF;\n\tvoid __iomem *p_clk_reg = bp + SMB_CORE_BUS_CLK_REG_OFF;\n\n\tswitch (i2c->freq) {\n\tcase I2C_MAX_STANDARD_MODE_FREQ:\n\t\twriteb(SR_HOLD_TIME_100K_TICKS, p_hold_time);\n\t\twritel(SMB_IDLE_SCALING_100K, p_idle_scaling);\n\t\twritew(BUS_CLK_100K, p_clk_reg);\n\t\twritel(CLK_SYNC_100K, p_clk_sync);\n\t\twritel(DATA_TIMING_100K, p_data_timing);\n\t\twritel(TO_SCALING_100K, p_to_scaling);\n\t\tbreak;\n\n\tcase I2C_MAX_FAST_MODE_PLUS_FREQ:\n\t\twriteb(SR_HOLD_TIME_1000K_TICKS, p_hold_time);\n\t\twritel(SMB_IDLE_SCALING_1000K, p_idle_scaling);\n\t\twritew(BUS_CLK_1000K, p_clk_reg);\n\t\twritel(CLK_SYNC_1000K, p_clk_sync);\n\t\twritel(DATA_TIMING_1000K, p_data_timing);\n\t\twritel(TO_SCALING_1000K, p_to_scaling);\n\t\tbreak;\n\n\tcase I2C_MAX_FAST_MODE_FREQ:\n\tdefault:\n\t\twriteb(SR_HOLD_TIME_400K_TICKS, p_hold_time);\n\t\twritel(SMB_IDLE_SCALING_400K, p_idle_scaling);\n\t\twritew(BUS_CLK_400K, p_clk_reg);\n\t\twritel(CLK_SYNC_400K, p_clk_sync);\n\t\twritel(DATA_TIMING_400K, p_data_timing);\n\t\twritel(TO_SCALING_400K, p_to_scaling);\n\t\tbreak;\n\t}\n}\n\nstatic void pci1xxxx_i2c_init(struct pci1xxxx_i2c *i2c)\n{\n\tvoid __iomem *p2 = i2c->i2c_base + SMBUS_STATUS_REG_OFF;\n\tvoid __iomem *p1 = i2c->i2c_base + SMB_GPR_REG;\n\tu8 regval;\n\tint ret;\n\n\tret = set_sys_lock(i2c);\n\tif (ret == -EPERM) {\n\t\t \n\t\tregval = 0;\n\t} else {\n\t\tregval = readl(p1);\n\t\trelease_sys_lock(i2c);\n\t}\n\n\tswitch (regval) {\n\tcase 0:\n\t\ti2c->freq = I2C_MAX_FAST_MODE_FREQ;\n\t\tpci1xxxx_i2c_set_freq(i2c);\n\t\tbreak;\n\tcase 1:\n\t\ti2c->freq = I2C_MAX_STANDARD_MODE_FREQ;\n\t\tpci1xxxx_i2c_set_freq(i2c);\n\t\tbreak;\n\tcase 2:\n\t\ti2c->freq = I2C_MAX_FAST_MODE_PLUS_FREQ;\n\t\tpci1xxxx_i2c_set_freq(i2c);\n\t\tbreak;\n\tcase 3:\n\tdefault:\n\t\tbreak;\n\t}\n\n\tpci1xxxx_i2c_config_padctrl(i2c, true);\n\ti2c->flags |= I2C_FLAGS_DIRECT_MODE;\n\tpci1xxxx_i2c_set_mode(i2c);\n\n\t \n\twriteb(STA_BUF_EMPTY, p2);\n\n\t \n\tpci1xxxx_i2c_configure_core_reg(i2c, true);\n\n\t \n\tpci1xxxx_i2c_configure_smbalert_pin(i2c, true);\n}\n\nstatic void pci1xxxx_i2c_clear_flags(struct pci1xxxx_i2c *i2c)\n{\n\tu8 regval;\n\n\t \n\tpci1xxxx_i2c_reset_counters(i2c);\n\n\t \n\tregval = COMPLETION_MNAKX | COMPLETION_IDLE | COMPLETION_MDONE;\n\twriteb(regval, i2c->i2c_base + SMB_CORE_COMPLETION_REG_OFF3);\n\treinit_completion(&i2c->i2c_xfer_done);\n\tpci1xxxx_ack_nw_layer_intr(i2c, ALL_NW_LAYER_INTERRUPTS);\n\tpci1xxxx_ack_high_level_intr(i2c, ALL_HIGH_LAYER_INTR);\n}\n\nstatic int pci1xxxx_i2c_read(struct pci1xxxx_i2c *i2c, u8 slaveaddr,\n\t\t\t     unsigned char *buf, u16 total_len)\n{\n\tvoid __iomem *p2 = i2c->i2c_base + SMB_CORE_COMPLETION_REG_OFF3;\n\tvoid __iomem *p1 = i2c->i2c_base + SMB_CORE_CMD_REG_OFF1;\n\tvoid __iomem *p3 = i2c->i2c_base + SMBUS_MST_BUF;\n\tunsigned long time_left;\n\tu16 remainingbytes;\n\tu8 transferlen;\n\tint retval = 0;\n\tu8 read_count;\n\tu32 regval;\n\tu16 count;\n\n\t \n\tpci1xxxx_i2c_enable_ESO(i2c);\n\tpci1xxxx_i2c_clear_flags(i2c);\n\tpci1xxxx_config_nw_layer_intr(i2c, INTR_MSK_DMA_TERM, true);\n\tpci1xxxx_i2c_config_high_level_intr(i2c, I2C_BUF_MSTR_INTR_MASK, true);\n\n\t \n\tfor (count = 0; count < total_len; count += transferlen) {\n\n\t\t \n\t\twriteb(0, p1);\n\t\tremainingbytes = total_len - count;\n\t\ttransferlen = min_t(u16, remainingbytes, SMBUS_BUF_MAX_SIZE);\n\n\t\t \n\t\tif ((count + transferlen >= total_len) &&\n\t\t    (i2c->flags & I2C_FLAGS_STOP)) {\n\t\t\tpci1xxxx_i2c_set_clear_FW_ACK(i2c, false);\n\t\t\tpci1xxxx_i2c_send_start_stop(i2c, 0);\n\t\t} else {\n\t\t\tpci1xxxx_i2c_set_clear_FW_ACK(i2c, true);\n\t\t}\n\n\t\t \n\t\tif (count == 0) {\n\t\t\tpci1xxxx_i2c_set_transfer_dir(i2c, I2C_DIRN_WRITE);\n\t\t\tpci1xxxx_i2c_send_start_stop(i2c, 1);\n\n\t\t\t \n\t\t\tpci1xxxx_i2c_buffer_write(i2c, slaveaddr, 0, NULL);\n\n\t\t\t \n\t\t\tpci1xxxx_i2c_set_count(i2c, 1, 1, transferlen);\n\n\t\t\t \n\t\t\tpci1xxxx_i2c_config_asr(i2c, true);\n\t\t\tif (i2c->flags & I2C_FLAGS_SMB_BLK_READ)\n\t\t\t\tpci1xxxx_i2c_set_readm(i2c, true);\n\t\t} else {\n\t\t\tpci1xxxx_i2c_set_count(i2c, 0, 0, transferlen);\n\t\t\tpci1xxxx_i2c_config_asr(i2c, false);\n\t\t\tpci1xxxx_i2c_clear_flags(i2c);\n\t\t\tpci1xxxx_i2c_set_transfer_dir(i2c, I2C_DIRN_READ);\n\t\t}\n\n\t\t \n\t\tpci1xxxx_i2c_start_DMA(i2c);\n\n\t\t \n\t\ttime_left = wait_for_completion_timeout(&i2c->i2c_xfer_done,\n\t\t\t    msecs_to_jiffies(PCI1XXXX_I2C_TIMEOUT_MS));\n\t\tif (time_left == 0) {\n\t\t\t \n\t\t\tpci1xxxx_i2c_init(i2c);\n\t\t\tretval = -ETIMEDOUT;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t \n\t\tregval = readb(p2);\n\n\t\t \n\t\tif (regval & COMPLETION_MNAKX) {\n\t\t\twriteb(COMPLETION_MNAKX, p2);\n\t\t\tretval = -ETIMEDOUT;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tif (i2c->flags & I2C_FLAGS_SMB_BLK_READ) {\n\t\t\tbuf[0] = readb(p3);\n\t\t\tread_count = buf[0];\n\t\t\tmemcpy_fromio(&buf[1], p3 + 1, read_count);\n\t\t} else {\n\t\t\tmemcpy_fromio(&buf[count], p3, transferlen);\n\t\t}\n\t}\n\ncleanup:\n\t \n\tpci1xxxx_config_nw_layer_intr(i2c, INTR_MSK_DMA_TERM, false);\n\tpci1xxxx_i2c_config_high_level_intr(i2c, I2C_BUF_MSTR_INTR_MASK, false);\n\tpci1xxxx_i2c_config_asr(i2c, false);\n\treturn retval;\n}\n\nstatic int pci1xxxx_i2c_write(struct pci1xxxx_i2c *i2c, u8 slaveaddr,\n\t\t\t      unsigned char *buf, u16 total_len)\n{\n\tvoid __iomem *p2 = i2c->i2c_base + SMB_CORE_COMPLETION_REG_OFF3;\n\tvoid __iomem *p1 = i2c->i2c_base + SMB_CORE_CMD_REG_OFF1;\n\tunsigned long time_left;\n\tu16 remainingbytes;\n\tu8 actualwritelen;\n\tu8 transferlen;\n\tint retval = 0;\n\tu32 regval;\n\tu16 count;\n\n\t \n\tpci1xxxx_i2c_enable_ESO(i2c);\n\n\t \n\tpci1xxxx_i2c_set_transfer_dir(i2c, I2C_DIRN_WRITE);\n\tpci1xxxx_config_nw_layer_intr(i2c, INTR_MSK_DMA_TERM, true);\n\tpci1xxxx_i2c_config_high_level_intr(i2c, I2C_BUF_MSTR_INTR_MASK, true);\n\n\t \n\tfor (count = 0; count < total_len; count += transferlen) {\n\t\t \n\t\twriteb(0, p1);\n\t\tpci1xxxx_i2c_clear_flags(i2c);\n\t\tremainingbytes = total_len - count;\n\n\t\t \n\t\tif (count == 0) {\n\t\t\tpci1xxxx_i2c_send_start_stop(i2c, 1);\n\n\t\t\t \n\t\t\ttransferlen = min_t(u16, SMBUS_BUF_MAX_SIZE - 1,\n\t\t\t\t\t    remainingbytes);\n\t\t\tpci1xxxx_i2c_buffer_write(i2c, slaveaddr,\n\t\t\t\t\t\t  transferlen, &buf[count]);\n\t\t\t \n\t\t\tactualwritelen = transferlen + 1;\n\t\t} else {\n\t\t\ttransferlen = min_t(u16, SMBUS_BUF_MAX_SIZE, remainingbytes);\n\t\t\tpci1xxxx_i2c_buffer_write(i2c, 0, transferlen, &buf[count]);\n\t\t\tactualwritelen = transferlen;\n\t\t}\n\n\t\tpci1xxxx_i2c_set_count(i2c, actualwritelen, actualwritelen, 0);\n\n\t\t \n\t\tif (remainingbytes <= transferlen &&\n\t\t   (i2c->flags & I2C_FLAGS_STOP))\n\t\t\tpci1xxxx_i2c_send_start_stop(i2c, 0);\n\n\t\tpci1xxxx_i2c_start_DMA(i2c);\n\n\t\t \n\t\ttime_left = wait_for_completion_timeout(&i2c->i2c_xfer_done,\n\t\t\t    msecs_to_jiffies(PCI1XXXX_I2C_TIMEOUT_MS));\n\t\tif (time_left == 0) {\n\t\t\t \n\t\t\tpci1xxxx_i2c_init(i2c);\n\t\t\tretval = -ETIMEDOUT;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tregval = readb(p2);\n\t\tif (regval & COMPLETION_MNAKX) {\n\t\t\twriteb(COMPLETION_MNAKX, p2);\n\t\t\tretval = -ETIMEDOUT;\n\t\t\tgoto cleanup;\n\t\t}\n\t}\ncleanup:\n\t \n\tpci1xxxx_config_nw_layer_intr(i2c, INTR_MSK_DMA_TERM, false);\n\tpci1xxxx_i2c_config_high_level_intr(i2c, I2C_BUF_MSTR_INTR_MASK, false);\n\n\treturn retval;\n}\n\nstatic int pci1xxxx_i2c_xfer(struct i2c_adapter *adap,\n\t\t\t     struct i2c_msg *msgs, int num)\n{\n\tstruct pci1xxxx_i2c *i2c = i2c_get_adapdata(adap);\n\tu8 slaveaddr;\n\tint retval;\n\tu32 i;\n\n\ti2c->i2c_xfer_in_progress = true;\n\tfor (i = 0; i < num; i++) {\n\t\tslaveaddr = i2c_8bit_addr_from_msg(&msgs[i]);\n\n\t\t \n\t\tif ((i == num - 1) || (msgs[i].flags & I2C_M_STOP))\n\t\t\ti2c->flags |= I2C_FLAGS_STOP;\n\t\telse\n\t\t\ti2c->flags &= ~I2C_FLAGS_STOP;\n\n\t\tif (msgs[i].flags & I2C_M_RECV_LEN)\n\t\t\ti2c->flags |= I2C_FLAGS_SMB_BLK_READ;\n\t\telse\n\t\t\ti2c->flags &= ~I2C_FLAGS_SMB_BLK_READ;\n\n\t\tif (msgs[i].flags & I2C_M_RD)\n\t\t\tretval = pci1xxxx_i2c_read(i2c, slaveaddr,\n\t\t\t\t\t\t   msgs[i].buf, msgs[i].len);\n\t\telse\n\t\t\tretval = pci1xxxx_i2c_write(i2c, slaveaddr,\n\t\t\t\t\t\t    msgs[i].buf, msgs[i].len);\n\n\t\tif (retval < 0)\n\t\t\tbreak;\n\t}\n\ti2c->i2c_xfer_in_progress = false;\n\n\tif (retval < 0)\n\t\treturn retval;\n\n\treturn num;\n}\n\n \nstatic u32 pci1xxxx_i2c_get_funcs(struct i2c_adapter *adap)\n{\n\treturn I2C_FUNC_I2C | I2C_FUNC_PROTOCOL_MANGLING |\n\t\tI2C_FUNC_SMBUS_BLOCK_PROC_CALL |\n\t\tI2C_FUNC_SMBUS_BYTE |\n\t\tI2C_FUNC_SMBUS_BYTE_DATA |\n\t\tI2C_FUNC_SMBUS_WORD_DATA |\n\t\tI2C_FUNC_SMBUS_PROC_CALL |\n\t\tI2C_FUNC_SMBUS_BLOCK_DATA;\n}\n\nstatic const struct i2c_algorithm pci1xxxx_i2c_algo = {\n\t.master_xfer = pci1xxxx_i2c_xfer,\n\t.functionality = pci1xxxx_i2c_get_funcs,\n};\n\nstatic const struct i2c_adapter_quirks pci1xxxx_i2c_quirks = {\n\t.flags = I2C_AQ_NO_ZERO_LEN,\n};\n\nstatic const struct i2c_adapter pci1xxxx_i2c_ops = {\n\t.owner\t= THIS_MODULE,\n\t.name\t= \"PCI1xxxx I2C Adapter\",\n\t.algo\t= &pci1xxxx_i2c_algo,\n\t.quirks = &pci1xxxx_i2c_quirks,\n};\n\nstatic int pci1xxxx_i2c_suspend(struct device *dev)\n{\n\tstruct pci1xxxx_i2c *i2c = dev_get_drvdata(dev);\n\tvoid __iomem *p = i2c->i2c_base + SMBUS_RESET_REG;\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tu32 regval;\n\n\ti2c_mark_adapter_suspended(&i2c->adap);\n\n\t \n\twhile (i2c->i2c_xfer_in_progress)\n\t\tmsleep(20);\n\n\tpci1xxxx_i2c_config_high_level_intr(i2c, SMBALERT_WAKE_INTR_MASK, true);\n\n\t \n\tregval = readl(p);\n\tregval |= PERI_SMBUS_D3_RESET_DIS;\n\twritel(regval, p);\n\n\t \n\tdevice_set_wakeup_enable(dev, true);\n\tpci_wake_from_d3(pdev, true);\n\n\treturn 0;\n}\n\nstatic int pci1xxxx_i2c_resume(struct device *dev)\n{\n\tstruct pci1xxxx_i2c *i2c = dev_get_drvdata(dev);\n\tvoid __iomem *p1 = i2c->i2c_base + SMBUS_GEN_INT_STAT_REG_OFF;\n\tvoid __iomem *p2 = i2c->i2c_base + SMBUS_RESET_REG;\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tu32 regval;\n\n\tregval = readw(p1);\n\twritew(regval, p1);\n\tpci1xxxx_i2c_config_high_level_intr(i2c, SMBALERT_WAKE_INTR_MASK, false);\n\tregval = readl(p2);\n\tregval &= ~PERI_SMBUS_D3_RESET_DIS;\n\twritel(regval, p2);\n\ti2c_mark_adapter_resumed(&i2c->adap);\n\tpci_wake_from_d3(pdev, false);\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(pci1xxxx_i2c_pm_ops, pci1xxxx_i2c_suspend,\n\t\t\t pci1xxxx_i2c_resume);\n\nstatic void pci1xxxx_i2c_shutdown(void *data)\n{\n\tstruct pci1xxxx_i2c *i2c = data;\n\n\tpci1xxxx_i2c_config_padctrl(i2c, false);\n\tpci1xxxx_i2c_configure_core_reg(i2c, false);\n}\n\nstatic int pci1xxxx_i2c_probe_pci(struct pci_dev *pdev,\n\t\t\t\t  const struct pci_device_id *ent)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct pci1xxxx_i2c *i2c;\n\tint ret;\n\n\ti2c = devm_kzalloc(dev, sizeof(*i2c), GFP_KERNEL);\n\tif (!i2c)\n\t\treturn -ENOMEM;\n\n\tpci_set_drvdata(pdev, i2c);\n\ti2c->i2c_xfer_in_progress = false;\n\n\tret = pcim_enable_device(pdev);\n\tif (ret)\n\t\treturn ret;\n\n\tpci_set_master(pdev);\n\n\t \n\tret = pcim_iomap_regions(pdev, BIT(0), pci_name(pdev));\n\tif (ret < 0)\n\t\treturn ret;\n\n\ti2c->i2c_base =\tpcim_iomap_table(pdev)[0];\n\tinit_completion(&i2c->i2c_xfer_done);\n\tpci1xxxx_i2c_init(i2c);\n\n\tret = devm_add_action(dev, pci1xxxx_i2c_shutdown, i2c);\n\tif (ret)\n\t\treturn ret;\n\n\tret = pci_alloc_irq_vectors(pdev, 1, 1, PCI_IRQ_ALL_TYPES);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = devm_request_irq(dev, pci_irq_vector(pdev, 0), pci1xxxx_i2c_isr,\n\t\t\t       0, pci_name(pdev), i2c);\n\tif (ret)\n\t\treturn ret;\n\n\ti2c->adap = pci1xxxx_i2c_ops;\n\ti2c->adap.dev.parent = dev;\n\n\tsnprintf(i2c->adap.name, sizeof(i2c->adap.name),\n\t\t \"MCHP PCI1xxxx i2c adapter at %s\", pci_name(pdev));\n\n\ti2c_set_adapdata(&i2c->adap, i2c);\n\n\tret = devm_i2c_add_adapter(dev, &i2c->adap);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"i2c add adapter failed\\n\");\n\n\treturn 0;\n}\n\nstatic const struct pci_device_id pci1xxxx_i2c_pci_id_table[] = {\n\t{ PCI_VDEVICE(EFAR, 0xA003) },\n\t{ PCI_VDEVICE(EFAR, 0xA013) },\n\t{ PCI_VDEVICE(EFAR, 0xA023) },\n\t{ PCI_VDEVICE(EFAR, 0xA033) },\n\t{ PCI_VDEVICE(EFAR, 0xA043) },\n\t{ }\n};\nMODULE_DEVICE_TABLE(pci, pci1xxxx_i2c_pci_id_table);\n\nstatic struct pci_driver pci1xxxx_i2c_pci_driver = {\n\t.name\t\t= \"i2c-mchp-pci1xxxx\",\n\t.id_table\t= pci1xxxx_i2c_pci_id_table,\n\t.probe\t\t= pci1xxxx_i2c_probe_pci,\n\t.driver = {\n\t\t.pm = pm_sleep_ptr(&pci1xxxx_i2c_pm_ops),\n\t},\n};\nmodule_pci_driver(pci1xxxx_i2c_pci_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Tharun Kumar P<tharunkumar.pasumarthi@microchip.com>\");\nMODULE_AUTHOR(\"Kumaravel Thiagarajan <kumaravel.thiagarajan@microchip.com>\");\nMODULE_DESCRIPTION(\"Microchip Technology Inc. pci1xxxx I2C bus driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}