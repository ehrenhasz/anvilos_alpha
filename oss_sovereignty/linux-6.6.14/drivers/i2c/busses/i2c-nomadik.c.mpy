{
  "module_name": "i2c-nomadik.c",
  "hash_id": "0e7216f8a1ece81adb8d40cc4862398a611bc88b077afa405a5672d14c93a617",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-nomadik.c",
  "human_readable_source": "\n \n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/amba/bus.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/i2c.h>\n#include <linux/err.h>\n#include <linux/clk.h>\n#include <linux/io.h>\n#include <linux/pm_runtime.h>\n#include <linux/of.h>\n#include <linux/pinctrl/consumer.h>\n\n#define DRIVER_NAME \"nmk-i2c\"\n\n \n#define I2C_CR\t\t(0x000)\n#define I2C_SCR\t\t(0x004)\n#define I2C_HSMCR\t(0x008)\n#define I2C_MCR\t\t(0x00C)\n#define I2C_TFR\t\t(0x010)\n#define I2C_SR\t\t(0x014)\n#define I2C_RFR\t\t(0x018)\n#define I2C_TFTR\t(0x01C)\n#define I2C_RFTR\t(0x020)\n#define I2C_DMAR\t(0x024)\n#define I2C_BRCR\t(0x028)\n#define I2C_IMSCR\t(0x02C)\n#define I2C_RISR\t(0x030)\n#define I2C_MISR\t(0x034)\n#define I2C_ICR\t\t(0x038)\n\n \n#define I2C_CR_PE\t\t(0x1 << 0)\t \n#define I2C_CR_OM\t\t(0x3 << 1)\t \n#define I2C_CR_SAM\t\t(0x1 << 3)\t \n#define I2C_CR_SM\t\t(0x3 << 4)\t \n#define I2C_CR_SGCM\t\t(0x1 << 6)\t \n#define I2C_CR_FTX\t\t(0x1 << 7)\t \n#define I2C_CR_FRX\t\t(0x1 << 8)\t \n#define I2C_CR_DMA_TX_EN\t(0x1 << 9)\t \n#define I2C_CR_DMA_RX_EN\t(0x1 << 10)\t \n#define I2C_CR_DMA_SLE\t\t(0x1 << 11)\t \n#define I2C_CR_LM\t\t(0x1 << 12)\t \n#define I2C_CR_FON\t\t(0x3 << 13)\t \n#define I2C_CR_FS\t\t(0x3 << 15)\t \n\n \n#define I2C_MCR_OP\t\t(0x1 << 0)\t \n#define I2C_MCR_A7\t\t(0x7f << 1)\t \n#define I2C_MCR_EA10\t\t(0x7 << 8)\t \n#define I2C_MCR_SB\t\t(0x1 << 11)\t \n#define I2C_MCR_AM\t\t(0x3 << 12)\t \n#define I2C_MCR_STOP\t\t(0x1 << 14)\t \n#define I2C_MCR_LENGTH\t\t(0x7ff << 15)\t \n\n \n#define I2C_SR_OP\t\t(0x3 << 0)\t \n#define I2C_SR_STATUS\t\t(0x3 << 2)\t \n#define I2C_SR_CAUSE\t\t(0x7 << 4)\t \n#define I2C_SR_TYPE\t\t(0x3 << 7)\t \n#define I2C_SR_LENGTH\t\t(0x7ff << 9)\t \n\n \n#define I2C_IT_TXFE\t\t(0x1 << 0)\n#define I2C_IT_TXFNE\t\t(0x1 << 1)\n#define I2C_IT_TXFF\t\t(0x1 << 2)\n#define I2C_IT_TXFOVR\t\t(0x1 << 3)\n#define I2C_IT_RXFE\t\t(0x1 << 4)\n#define I2C_IT_RXFNF\t\t(0x1 << 5)\n#define I2C_IT_RXFF\t\t(0x1 << 6)\n#define I2C_IT_RFSR\t\t(0x1 << 16)\n#define I2C_IT_RFSE\t\t(0x1 << 17)\n#define I2C_IT_WTSR\t\t(0x1 << 18)\n#define I2C_IT_MTD\t\t(0x1 << 19)\n#define I2C_IT_STD\t\t(0x1 << 20)\n#define I2C_IT_MAL\t\t(0x1 << 24)\n#define I2C_IT_BERR\t\t(0x1 << 25)\n#define I2C_IT_MTDWS\t\t(0x1 << 28)\n\n#define GEN_MASK(val, mask, sb)  (((val) << (sb)) & (mask))\n\n \n#define I2C_CLEAR_ALL_INTS\t0x131f007f\n\n \n#define IRQ_MASK(mask)\t\t(mask & 0x1fffffff)\n\n \n#define MAX_I2C_FIFO_THRESHOLD\t15\n\nenum i2c_freq_mode {\n\tI2C_FREQ_MODE_STANDARD,\t\t \n\tI2C_FREQ_MODE_FAST,\t\t \n\tI2C_FREQ_MODE_HIGH_SPEED,\t \n\tI2C_FREQ_MODE_FAST_PLUS,\t \n};\n\n \nstruct i2c_vendor_data {\n\tbool has_mtdws;\n\tu32 fifodepth;\n};\n\nenum i2c_status {\n\tI2C_NOP,\n\tI2C_ON_GOING,\n\tI2C_OK,\n\tI2C_ABORT\n};\n\n \nenum i2c_operation {\n\tI2C_NO_OPERATION = 0xff,\n\tI2C_WRITE = 0x00,\n\tI2C_READ = 0x01\n};\n\n \nstruct i2c_nmk_client {\n\tunsigned short\t\tslave_adr;\n\tunsigned long\t\tcount;\n\tunsigned char\t\t*buffer;\n\tunsigned long\t\txfer_bytes;\n\tenum i2c_operation\toperation;\n};\n\n \nstruct nmk_i2c_dev {\n\tstruct i2c_vendor_data\t\t*vendor;\n\tstruct amba_device\t\t*adev;\n\tstruct i2c_adapter\t\tadap;\n\tint\t\t\t\tirq;\n\tvoid __iomem\t\t\t*virtbase;\n\tstruct clk\t\t\t*clk;\n\tstruct i2c_nmk_client\t\tcli;\n\tu32\t\t\t\tclk_freq;\n\tunsigned char\t\t\ttft;\n\tunsigned char\t\t\trft;\n\tint\t\t\t\ttimeout;\n\tenum i2c_freq_mode\t\tsm;\n\tint\t\t\t\tstop;\n\tstruct completion\t\txfer_complete;\n\tint\t\t\t\tresult;\n};\n\n \nstatic const char *abort_causes[] = {\n\t\"no ack received after address transmission\",\n\t\"no ack received during data phase\",\n\t\"ack received after xmission of master code\",\n\t\"master lost arbitration\",\n\t\"slave restarts\",\n\t\"slave reset\",\n\t\"overflow, maxsize is 2047 bytes\",\n};\n\nstatic inline void i2c_set_bit(void __iomem *reg, u32 mask)\n{\n\twritel(readl(reg) | mask, reg);\n}\n\nstatic inline void i2c_clr_bit(void __iomem *reg, u32 mask)\n{\n\twritel(readl(reg) & ~mask, reg);\n}\n\n \nstatic int flush_i2c_fifo(struct nmk_i2c_dev *dev)\n{\n#define LOOP_ATTEMPTS 10\n\tint i;\n\tunsigned long timeout;\n\n\t \n\twritel((I2C_CR_FTX | I2C_CR_FRX), dev->virtbase + I2C_CR);\n\n\tfor (i = 0; i < LOOP_ATTEMPTS; i++) {\n\t\ttimeout = jiffies + dev->adap.timeout;\n\n\t\twhile (!time_after(jiffies, timeout)) {\n\t\t\tif ((readl(dev->virtbase + I2C_CR) &\n\t\t\t\t(I2C_CR_FTX | I2C_CR_FRX)) == 0)\n\t\t\t\t\treturn 0;\n\t\t}\n\t}\n\n\tdev_err(&dev->adev->dev,\n\t\t\"flushing operation timed out giving up after %d attempts\",\n\t\tLOOP_ATTEMPTS);\n\n\treturn -ETIMEDOUT;\n}\n\n \nstatic void disable_all_interrupts(struct nmk_i2c_dev *dev)\n{\n\tu32 mask = IRQ_MASK(0);\n\twritel(mask, dev->virtbase + I2C_IMSCR);\n}\n\n \nstatic void clear_all_interrupts(struct nmk_i2c_dev *dev)\n{\n\tu32 mask;\n\tmask = IRQ_MASK(I2C_CLEAR_ALL_INTS);\n\twritel(mask, dev->virtbase + I2C_ICR);\n}\n\n \nstatic int init_hw(struct nmk_i2c_dev *dev)\n{\n\tint stat;\n\n\tstat = flush_i2c_fifo(dev);\n\tif (stat)\n\t\tgoto exit;\n\n\t \n\ti2c_clr_bit(dev->virtbase + I2C_CR, I2C_CR_PE);\n\n\tdisable_all_interrupts(dev);\n\n\tclear_all_interrupts(dev);\n\n\tdev->cli.operation = I2C_NO_OPERATION;\n\nexit:\n\treturn stat;\n}\n\n \n#define DEFAULT_I2C_REG_CR\t((1 << 1) | I2C_CR_PE)\n\n \nstatic u32 load_i2c_mcr_reg(struct nmk_i2c_dev *dev, u16 flags)\n{\n\tu32 mcr = 0;\n\tunsigned short slave_adr_3msb_bits;\n\n\tmcr |= GEN_MASK(dev->cli.slave_adr, I2C_MCR_A7, 1);\n\n\tif (unlikely(flags & I2C_M_TEN)) {\n\t\t \n\t\tmcr |= GEN_MASK(2, I2C_MCR_AM, 12);\n\t\t \n\t\tslave_adr_3msb_bits = (dev->cli.slave_adr >> 7) & 0x7;\n\n\t\tmcr |= GEN_MASK(slave_adr_3msb_bits, I2C_MCR_EA10, 8);\n\t} else {\n\t\t \n\t\tmcr |= GEN_MASK(1, I2C_MCR_AM, 12);\n\t}\n\n\t \n\tmcr |= GEN_MASK(0, I2C_MCR_SB, 11);\n\n\t \n\tif (dev->cli.operation == I2C_WRITE)\n\t\tmcr |= GEN_MASK(I2C_WRITE, I2C_MCR_OP, 0);\n\telse\n\t\tmcr |= GEN_MASK(I2C_READ, I2C_MCR_OP, 0);\n\n\t \n\tif (dev->stop)\n\t\tmcr |= GEN_MASK(1, I2C_MCR_STOP, 14);\n\telse\n\t\tmcr &= ~(GEN_MASK(1, I2C_MCR_STOP, 14));\n\n\tmcr |= GEN_MASK(dev->cli.count, I2C_MCR_LENGTH, 15);\n\n\treturn mcr;\n}\n\n \nstatic void setup_i2c_controller(struct nmk_i2c_dev *dev)\n{\n\tu32 brcr1, brcr2;\n\tu32 i2c_clk, div;\n\tu32 ns;\n\tu16 slsu;\n\n\twritel(0x0, dev->virtbase + I2C_CR);\n\twritel(0x0, dev->virtbase + I2C_HSMCR);\n\twritel(0x0, dev->virtbase + I2C_TFTR);\n\twritel(0x0, dev->virtbase + I2C_RFTR);\n\twritel(0x0, dev->virtbase + I2C_DMAR);\n\n\ti2c_clk = clk_get_rate(dev->clk);\n\n\t \n\tns = DIV_ROUND_UP_ULL(1000000000ULL, i2c_clk);\n\tswitch (dev->sm) {\n\tcase I2C_FREQ_MODE_FAST:\n\tcase I2C_FREQ_MODE_FAST_PLUS:\n\t\tslsu = DIV_ROUND_UP(100, ns);  \n\t\tbreak;\n\tcase I2C_FREQ_MODE_HIGH_SPEED:\n\t\tslsu = DIV_ROUND_UP(10, ns);  \n\t\tbreak;\n\tcase I2C_FREQ_MODE_STANDARD:\n\tdefault:\n\t\tslsu = DIV_ROUND_UP(250, ns);  \n\t\tbreak;\n\t}\n\tslsu += 1;\n\n\tdev_dbg(&dev->adev->dev, \"calculated SLSU = %04x\\n\", slsu);\n\twritel(slsu << 16, dev->virtbase + I2C_SCR);\n\n\t \n\tdiv = (dev->clk_freq > I2C_MAX_STANDARD_MODE_FREQ) ? 3 : 2;\n\n\t \n\tbrcr1 = 0 << 16;\n\tbrcr2 = (i2c_clk/(dev->clk_freq * div)) & 0xffff;\n\n\t \n\twritel((brcr1 | brcr2), dev->virtbase + I2C_BRCR);\n\n\t \n\tif (dev->sm > I2C_FREQ_MODE_FAST) {\n\t\tdev_err(&dev->adev->dev,\n\t\t\t\"do not support this mode defaulting to std. mode\\n\");\n\t\tbrcr2 = i2c_clk / (I2C_MAX_STANDARD_MODE_FREQ * 2) & 0xffff;\n\t\twritel((brcr1 | brcr2), dev->virtbase + I2C_BRCR);\n\t\twritel(I2C_FREQ_MODE_STANDARD << 4,\n\t\t\t\tdev->virtbase + I2C_CR);\n\t}\n\twritel(dev->sm << 4, dev->virtbase + I2C_CR);\n\n\t \n\twritel(dev->tft, dev->virtbase + I2C_TFTR);\n\twritel(dev->rft, dev->virtbase + I2C_RFTR);\n}\n\n \nstatic int read_i2c(struct nmk_i2c_dev *dev, u16 flags)\n{\n\tint status = 0;\n\tu32 mcr, irq_mask;\n\tunsigned long timeout;\n\n\tmcr = load_i2c_mcr_reg(dev, flags);\n\twritel(mcr, dev->virtbase + I2C_MCR);\n\n\t \n\twritel(readl(dev->virtbase + I2C_CR) | DEFAULT_I2C_REG_CR,\n\t\t\tdev->virtbase + I2C_CR);\n\n\t \n\ti2c_set_bit(dev->virtbase + I2C_CR, I2C_CR_PE);\n\n\tinit_completion(&dev->xfer_complete);\n\n\t \n\tirq_mask = (I2C_IT_RXFNF | I2C_IT_RXFF |\n\t\t\tI2C_IT_MAL | I2C_IT_BERR);\n\n\tif (dev->stop || !dev->vendor->has_mtdws)\n\t\tirq_mask |= I2C_IT_MTD;\n\telse\n\t\tirq_mask |= I2C_IT_MTDWS;\n\n\tirq_mask = I2C_CLEAR_ALL_INTS & IRQ_MASK(irq_mask);\n\n\twritel(readl(dev->virtbase + I2C_IMSCR) | irq_mask,\n\t\t\tdev->virtbase + I2C_IMSCR);\n\n\ttimeout = wait_for_completion_timeout(\n\t\t&dev->xfer_complete, dev->adap.timeout);\n\n\tif (timeout == 0) {\n\t\t \n\t\tdev_err(&dev->adev->dev, \"read from slave 0x%x timed out\\n\",\n\t\t\t\tdev->cli.slave_adr);\n\t\tstatus = -ETIMEDOUT;\n\t}\n\treturn status;\n}\n\nstatic void fill_tx_fifo(struct nmk_i2c_dev *dev, int no_bytes)\n{\n\tint count;\n\n\tfor (count = (no_bytes - 2);\n\t\t\t(count > 0) &&\n\t\t\t(dev->cli.count != 0);\n\t\t\tcount--) {\n\t\t \n\t\twriteb(*dev->cli.buffer,\n\t\t\tdev->virtbase + I2C_TFR);\n\t\tdev->cli.buffer++;\n\t\tdev->cli.count--;\n\t\tdev->cli.xfer_bytes++;\n\t}\n\n}\n\n \nstatic int write_i2c(struct nmk_i2c_dev *dev, u16 flags)\n{\n\tu32 status = 0;\n\tu32 mcr, irq_mask;\n\tunsigned long timeout;\n\n\tmcr = load_i2c_mcr_reg(dev, flags);\n\n\twritel(mcr, dev->virtbase + I2C_MCR);\n\n\t \n\twritel(readl(dev->virtbase + I2C_CR) | DEFAULT_I2C_REG_CR,\n\t\t\tdev->virtbase + I2C_CR);\n\n\t \n\ti2c_set_bit(dev->virtbase + I2C_CR, I2C_CR_PE);\n\n\tinit_completion(&dev->xfer_complete);\n\n\t \n\tirq_mask = (I2C_IT_TXFOVR | I2C_IT_MAL | I2C_IT_BERR);\n\n\t \n\tfill_tx_fifo(dev, MAX_I2C_FIFO_THRESHOLD);\n\n\tif (dev->cli.count != 0)\n\t\tirq_mask |= I2C_IT_TXFNE;\n\n\t \n\tif (dev->stop || !dev->vendor->has_mtdws)\n\t\tirq_mask |= I2C_IT_MTD;\n\telse\n\t\tirq_mask |= I2C_IT_MTDWS;\n\n\tirq_mask = I2C_CLEAR_ALL_INTS & IRQ_MASK(irq_mask);\n\n\twritel(readl(dev->virtbase + I2C_IMSCR) | irq_mask,\n\t\t\tdev->virtbase + I2C_IMSCR);\n\n\ttimeout = wait_for_completion_timeout(\n\t\t&dev->xfer_complete, dev->adap.timeout);\n\n\tif (timeout == 0) {\n\t\t \n\t\tdev_err(&dev->adev->dev, \"write to slave 0x%x timed out\\n\",\n\t\t\t\tdev->cli.slave_adr);\n\t\tstatus = -ETIMEDOUT;\n\t}\n\n\treturn status;\n}\n\n \nstatic int nmk_i2c_xfer_one(struct nmk_i2c_dev *dev, u16 flags)\n{\n\tint status;\n\n\tif (flags & I2C_M_RD) {\n\t\t \n\t\tdev->cli.operation = I2C_READ;\n\t\tstatus = read_i2c(dev, flags);\n\t} else {\n\t\t \n\t\tdev->cli.operation = I2C_WRITE;\n\t\tstatus = write_i2c(dev, flags);\n\t}\n\n\tif (status || (dev->result)) {\n\t\tu32 i2c_sr;\n\t\tu32 cause;\n\n\t\ti2c_sr = readl(dev->virtbase + I2C_SR);\n\t\t \n\t\tif (((i2c_sr >> 2) & 0x3) == 0x3) {\n\t\t\t \n\t\t\tcause =\t(i2c_sr >> 4) & 0x7;\n\t\t\tdev_err(&dev->adev->dev, \"%s\\n\",\n\t\t\t\tcause >= ARRAY_SIZE(abort_causes) ?\n\t\t\t\t\"unknown reason\" :\n\t\t\t\tabort_causes[cause]);\n\t\t}\n\n\t\t(void) init_hw(dev);\n\n\t\tstatus = status ? status : dev->result;\n\t}\n\n\treturn status;\n}\n\n \nstatic int nmk_i2c_xfer(struct i2c_adapter *i2c_adap,\n\t\tstruct i2c_msg msgs[], int num_msgs)\n{\n\tint status = 0;\n\tint i;\n\tstruct nmk_i2c_dev *dev = i2c_get_adapdata(i2c_adap);\n\tint j;\n\n\tpm_runtime_get_sync(&dev->adev->dev);\n\n\t \n\tfor (j = 0; j < 3; j++) {\n\t\t \n\t\tsetup_i2c_controller(dev);\n\n\t\tfor (i = 0; i < num_msgs; i++) {\n\t\t\tdev->cli.slave_adr\t= msgs[i].addr;\n\t\t\tdev->cli.buffer\t\t= msgs[i].buf;\n\t\t\tdev->cli.count\t\t= msgs[i].len;\n\t\t\tdev->stop = (i < (num_msgs - 1)) ? 0 : 1;\n\t\t\tdev->result = 0;\n\n\t\t\tstatus = nmk_i2c_xfer_one(dev, msgs[i].flags);\n\t\t\tif (status != 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (status == 0)\n\t\t\tbreak;\n\t}\n\n\tpm_runtime_put_sync(&dev->adev->dev);\n\n\t \n\tif (status)\n\t\treturn status;\n\telse\n\t\treturn num_msgs;\n}\n\n \nstatic int disable_interrupts(struct nmk_i2c_dev *dev, u32 irq)\n{\n\tirq = IRQ_MASK(irq);\n\twritel(readl(dev->virtbase + I2C_IMSCR) & ~(I2C_CLEAR_ALL_INTS & irq),\n\t\t\tdev->virtbase + I2C_IMSCR);\n\treturn 0;\n}\n\n \nstatic irqreturn_t i2c_irq_handler(int irq, void *arg)\n{\n\tstruct nmk_i2c_dev *dev = arg;\n\tu32 tft, rft;\n\tu32 count;\n\tu32 misr, src;\n\n\t \n\ttft = readl(dev->virtbase + I2C_TFTR);\n\trft = readl(dev->virtbase + I2C_RFTR);\n\n\t \n\tmisr = readl(dev->virtbase + I2C_MISR);\n\n\tsrc = __ffs(misr);\n\tswitch ((1 << src)) {\n\n\t \n\tcase I2C_IT_TXFNE:\n\t{\n\t\tif (dev->cli.operation == I2C_READ) {\n\t\t\t \n\t\t\tdisable_interrupts(dev, I2C_IT_TXFNE);\n\t\t} else {\n\t\t\tfill_tx_fifo(dev, (MAX_I2C_FIFO_THRESHOLD - tft));\n\t\t\t \n\t\t\tif (dev->cli.count == 0)\n\t\t\t\tdisable_interrupts(dev,\tI2C_IT_TXFNE);\n\t\t}\n\t}\n\tbreak;\n\n\t \n\tcase I2C_IT_RXFNF:\n\t\tfor (count = rft; count > 0; count--) {\n\t\t\t \n\t\t\t*dev->cli.buffer = readb(dev->virtbase + I2C_RFR);\n\t\t\tdev->cli.buffer++;\n\t\t}\n\t\tdev->cli.count -= rft;\n\t\tdev->cli.xfer_bytes += rft;\n\t\tbreak;\n\n\t \n\tcase I2C_IT_RXFF:\n\t\tfor (count = MAX_I2C_FIFO_THRESHOLD; count > 0; count--) {\n\t\t\t*dev->cli.buffer = readb(dev->virtbase + I2C_RFR);\n\t\t\tdev->cli.buffer++;\n\t\t}\n\t\tdev->cli.count -= MAX_I2C_FIFO_THRESHOLD;\n\t\tdev->cli.xfer_bytes += MAX_I2C_FIFO_THRESHOLD;\n\t\tbreak;\n\n\t \n\tcase I2C_IT_MTD:\n\tcase I2C_IT_MTDWS:\n\t\tif (dev->cli.operation == I2C_READ) {\n\t\t\twhile (!(readl(dev->virtbase + I2C_RISR)\n\t\t\t\t & I2C_IT_RXFE)) {\n\t\t\t\tif (dev->cli.count == 0)\n\t\t\t\t\tbreak;\n\t\t\t\t*dev->cli.buffer =\n\t\t\t\t\treadb(dev->virtbase + I2C_RFR);\n\t\t\t\tdev->cli.buffer++;\n\t\t\t\tdev->cli.count--;\n\t\t\t\tdev->cli.xfer_bytes++;\n\t\t\t}\n\t\t}\n\n\t\tdisable_all_interrupts(dev);\n\t\tclear_all_interrupts(dev);\n\n\t\tif (dev->cli.count) {\n\t\t\tdev->result = -EIO;\n\t\t\tdev_err(&dev->adev->dev,\n\t\t\t\t\"%lu bytes still remain to be xfered\\n\",\n\t\t\t\tdev->cli.count);\n\t\t\t(void) init_hw(dev);\n\t\t}\n\t\tcomplete(&dev->xfer_complete);\n\n\t\tbreak;\n\n\t \n\tcase I2C_IT_MAL:\n\t\tdev->result = -EIO;\n\t\t(void) init_hw(dev);\n\n\t\ti2c_set_bit(dev->virtbase + I2C_ICR, I2C_IT_MAL);\n\t\tcomplete(&dev->xfer_complete);\n\n\t\tbreak;\n\n\t \n\tcase I2C_IT_BERR:\n\t\tdev->result = -EIO;\n\t\t \n\t\tif (((readl(dev->virtbase + I2C_SR) >> 2) & 0x3) == I2C_ABORT)\n\t\t\t(void) init_hw(dev);\n\n\t\ti2c_set_bit(dev->virtbase + I2C_ICR, I2C_IT_BERR);\n\t\tcomplete(&dev->xfer_complete);\n\n\t\tbreak;\n\n\t \n\tcase I2C_IT_TXFOVR:\n\t\tdev->result = -EIO;\n\t\t(void) init_hw(dev);\n\n\t\tdev_err(&dev->adev->dev, \"Tx Fifo Over run\\n\");\n\t\tcomplete(&dev->xfer_complete);\n\n\t\tbreak;\n\n\t \n\tcase I2C_IT_TXFE:\n\tcase I2C_IT_TXFF:\n\tcase I2C_IT_RXFE:\n\tcase I2C_IT_RFSR:\n\tcase I2C_IT_RFSE:\n\tcase I2C_IT_WTSR:\n\tcase I2C_IT_STD:\n\t\tdev_err(&dev->adev->dev, \"unhandled Interrupt\\n\");\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&dev->adev->dev, \"spurious Interrupt..\\n\");\n\t\tbreak;\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int nmk_i2c_suspend_late(struct device *dev)\n{\n\tint ret;\n\n\tret = pm_runtime_force_suspend(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tpinctrl_pm_select_sleep_state(dev);\n\treturn 0;\n}\n\nstatic int nmk_i2c_resume_early(struct device *dev)\n{\n\treturn pm_runtime_force_resume(dev);\n}\n\nstatic int nmk_i2c_runtime_suspend(struct device *dev)\n{\n\tstruct amba_device *adev = to_amba_device(dev);\n\tstruct nmk_i2c_dev *nmk_i2c = amba_get_drvdata(adev);\n\n\tclk_disable_unprepare(nmk_i2c->clk);\n\tpinctrl_pm_select_idle_state(dev);\n\treturn 0;\n}\n\nstatic int nmk_i2c_runtime_resume(struct device *dev)\n{\n\tstruct amba_device *adev = to_amba_device(dev);\n\tstruct nmk_i2c_dev *nmk_i2c = amba_get_drvdata(adev);\n\tint ret;\n\n\tret = clk_prepare_enable(nmk_i2c->clk);\n\tif (ret) {\n\t\tdev_err(dev, \"can't prepare_enable clock\\n\");\n\t\treturn ret;\n\t}\n\n\tpinctrl_pm_select_default_state(dev);\n\n\tret = init_hw(nmk_i2c);\n\tif (ret) {\n\t\tclk_disable_unprepare(nmk_i2c->clk);\n\t\tpinctrl_pm_select_idle_state(dev);\n\t}\n\n\treturn ret;\n}\n\nstatic const struct dev_pm_ops nmk_i2c_pm = {\n\tLATE_SYSTEM_SLEEP_PM_OPS(nmk_i2c_suspend_late, nmk_i2c_resume_early)\n\tRUNTIME_PM_OPS(nmk_i2c_runtime_suspend, nmk_i2c_runtime_resume, NULL)\n};\n\nstatic unsigned int nmk_i2c_functionality(struct i2c_adapter *adap)\n{\n\treturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL | I2C_FUNC_10BIT_ADDR;\n}\n\nstatic const struct i2c_algorithm nmk_i2c_algo = {\n\t.master_xfer\t= nmk_i2c_xfer,\n\t.functionality\t= nmk_i2c_functionality\n};\n\nstatic void nmk_i2c_of_probe(struct device_node *np,\n\t\t\t     struct nmk_i2c_dev *nmk)\n{\n\t \n\tif (of_property_read_u32(np, \"clock-frequency\", &nmk->clk_freq))\n\t\tnmk->clk_freq = I2C_MAX_STANDARD_MODE_FREQ;\n\n\t \n\tif (nmk->clk_freq <= I2C_MAX_STANDARD_MODE_FREQ)\n\t\tnmk->sm = I2C_FREQ_MODE_STANDARD;\n\telse\n\t\tnmk->sm = I2C_FREQ_MODE_FAST;\n\tnmk->tft = 1;  \n\tnmk->rft = 8;  \n\tnmk->timeout = 200;  \n}\n\nstatic int nmk_i2c_probe(struct amba_device *adev, const struct amba_id *id)\n{\n\tint ret = 0;\n\tstruct device_node *np = adev->dev.of_node;\n\tstruct nmk_i2c_dev\t*dev;\n\tstruct i2c_adapter *adap;\n\tstruct i2c_vendor_data *vendor = id->data;\n\tu32 max_fifo_threshold = (vendor->fifodepth / 2) - 1;\n\n\tdev = devm_kzalloc(&adev->dev, sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tdev->vendor = vendor;\n\tdev->adev = adev;\n\tnmk_i2c_of_probe(np, dev);\n\n\tif (dev->tft > max_fifo_threshold) {\n\t\tdev_warn(&adev->dev, \"requested TX FIFO threshold %u, adjusted down to %u\\n\",\n\t\t\t dev->tft, max_fifo_threshold);\n\t\tdev->tft = max_fifo_threshold;\n\t}\n\n\tif (dev->rft > max_fifo_threshold) {\n\t\tdev_warn(&adev->dev, \"requested RX FIFO threshold %u, adjusted down to %u\\n\",\n\t\t\tdev->rft, max_fifo_threshold);\n\t\tdev->rft = max_fifo_threshold;\n\t}\n\n\tamba_set_drvdata(adev, dev);\n\n\tdev->virtbase = devm_ioremap(&adev->dev, adev->res.start,\n\t\t\t\tresource_size(&adev->res));\n\tif (!dev->virtbase)\n\t\treturn -ENOMEM;\n\n\tdev->irq = adev->irq[0];\n\tret = devm_request_irq(&adev->dev, dev->irq, i2c_irq_handler, 0,\n\t\t\t\tDRIVER_NAME, dev);\n\tif (ret)\n\t\treturn dev_err_probe(&adev->dev, ret,\n\t\t\t\t     \"cannot claim the irq %d\\n\", dev->irq);\n\n\tdev->clk = devm_clk_get_enabled(&adev->dev, NULL);\n\tif (IS_ERR(dev->clk))\n\t\treturn dev_err_probe(&adev->dev, PTR_ERR(dev->clk),\n\t\t\t\t     \"could enable i2c clock\\n\");\n\n\tinit_hw(dev);\n\n\tadap = &dev->adap;\n\tadap->dev.of_node = np;\n\tadap->dev.parent = &adev->dev;\n\tadap->owner = THIS_MODULE;\n\tadap->class = I2C_CLASS_DEPRECATED;\n\tadap->algo = &nmk_i2c_algo;\n\tadap->timeout = msecs_to_jiffies(dev->timeout);\n\tsnprintf(adap->name, sizeof(adap->name),\n\t\t \"Nomadik I2C at %pR\", &adev->res);\n\n\ti2c_set_adapdata(adap, dev);\n\n\tdev_info(&adev->dev,\n\t\t \"initialize %s on virtual base %p\\n\",\n\t\t adap->name, dev->virtbase);\n\n\tret = i2c_add_adapter(adap);\n\tif (ret)\n\t\treturn ret;\n\n\tpm_runtime_put(&adev->dev);\n\n\treturn 0;\n}\n\nstatic void nmk_i2c_remove(struct amba_device *adev)\n{\n\tstruct nmk_i2c_dev *dev = amba_get_drvdata(adev);\n\n\ti2c_del_adapter(&dev->adap);\n\tflush_i2c_fifo(dev);\n\tdisable_all_interrupts(dev);\n\tclear_all_interrupts(dev);\n\t \n\ti2c_clr_bit(dev->virtbase + I2C_CR, I2C_CR_PE);\n}\n\nstatic struct i2c_vendor_data vendor_stn8815 = {\n\t.has_mtdws = false,\n\t.fifodepth = 16,  \n};\n\nstatic struct i2c_vendor_data vendor_db8500 = {\n\t.has_mtdws = true,\n\t.fifodepth = 32,  \n};\n\nstatic const struct amba_id nmk_i2c_ids[] = {\n\t{\n\t\t.id\t= 0x00180024,\n\t\t.mask\t= 0x00ffffff,\n\t\t.data\t= &vendor_stn8815,\n\t},\n\t{\n\t\t.id\t= 0x00380024,\n\t\t.mask\t= 0x00ffffff,\n\t\t.data\t= &vendor_db8500,\n\t},\n\t{},\n};\n\nMODULE_DEVICE_TABLE(amba, nmk_i2c_ids);\n\nstatic struct amba_driver nmk_i2c_driver = {\n\t.drv = {\n\t\t.owner = THIS_MODULE,\n\t\t.name = DRIVER_NAME,\n\t\t.pm = pm_ptr(&nmk_i2c_pm),\n\t},\n\t.id_table = nmk_i2c_ids,\n\t.probe = nmk_i2c_probe,\n\t.remove = nmk_i2c_remove,\n};\n\nstatic int __init nmk_i2c_init(void)\n{\n\treturn amba_driver_register(&nmk_i2c_driver);\n}\n\nstatic void __exit nmk_i2c_exit(void)\n{\n\tamba_driver_unregister(&nmk_i2c_driver);\n}\n\nsubsys_initcall(nmk_i2c_init);\nmodule_exit(nmk_i2c_exit);\n\nMODULE_AUTHOR(\"Sachin Verma\");\nMODULE_AUTHOR(\"Srinidhi KASAGAR\");\nMODULE_DESCRIPTION(\"Nomadik/Ux500 I2C driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}