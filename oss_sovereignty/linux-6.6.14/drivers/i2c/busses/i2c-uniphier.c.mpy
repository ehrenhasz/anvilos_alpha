{
  "module_name": "i2c-uniphier.c",
  "hash_id": "2a36f47ab7ca2870eeac96a0bc26b2c5a82e2fafa6e7e3eb39898271dcabaa2e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-uniphier.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n\n#define UNIPHIER_I2C_DTRM\t0x00\t \n#define     UNIPHIER_I2C_DTRM_IRQEN\tBIT(11)\t \n#define     UNIPHIER_I2C_DTRM_STA\tBIT(10)\t \n#define     UNIPHIER_I2C_DTRM_STO\tBIT(9)\t \n#define     UNIPHIER_I2C_DTRM_NACK\tBIT(8)\t \n#define     UNIPHIER_I2C_DTRM_RD\tBIT(0)\t \n#define UNIPHIER_I2C_DREC\t0x04\t \n#define     UNIPHIER_I2C_DREC_MST\tBIT(14)\t \n#define     UNIPHIER_I2C_DREC_TX\tBIT(13)\t \n#define     UNIPHIER_I2C_DREC_STS\tBIT(12)\t \n#define     UNIPHIER_I2C_DREC_LRB\tBIT(11)\t \n#define     UNIPHIER_I2C_DREC_LAB\tBIT(9)\t \n#define     UNIPHIER_I2C_DREC_BBN\tBIT(8)\t \n#define UNIPHIER_I2C_MYAD\t0x08\t \n#define UNIPHIER_I2C_CLK\t0x0c\t \n#define UNIPHIER_I2C_BRST\t0x10\t \n#define     UNIPHIER_I2C_BRST_FOEN\tBIT(1)\t \n#define     UNIPHIER_I2C_BRST_RSCL\tBIT(0)\t \n#define UNIPHIER_I2C_HOLD\t0x14\t \n#define UNIPHIER_I2C_BSTS\t0x18\t \n#define     UNIPHIER_I2C_BSTS_SDA\tBIT(1)\t \n#define     UNIPHIER_I2C_BSTS_SCL\tBIT(0)\t \n#define UNIPHIER_I2C_NOISE\t0x1c\t \n#define UNIPHIER_I2C_SETUP\t0x20\t \n\nstruct uniphier_i2c_priv {\n\tstruct completion comp;\n\tstruct i2c_adapter adap;\n\tvoid __iomem *membase;\n\tstruct clk *clk;\n\tunsigned int busy_cnt;\n\tunsigned int clk_cycle;\n};\n\nstatic irqreturn_t uniphier_i2c_interrupt(int irq, void *dev_id)\n{\n\tstruct uniphier_i2c_priv *priv = dev_id;\n\n\t \n\tcomplete(&priv->comp);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int uniphier_i2c_xfer_byte(struct i2c_adapter *adap, u32 txdata,\n\t\t\t\t  u32 *rxdatap)\n{\n\tstruct uniphier_i2c_priv *priv = i2c_get_adapdata(adap);\n\tunsigned long time_left;\n\tu32 rxdata;\n\n\treinit_completion(&priv->comp);\n\n\ttxdata |= UNIPHIER_I2C_DTRM_IRQEN;\n\twritel(txdata, priv->membase + UNIPHIER_I2C_DTRM);\n\n\ttime_left = wait_for_completion_timeout(&priv->comp, adap->timeout);\n\tif (unlikely(!time_left)) {\n\t\tdev_err(&adap->dev, \"transaction timeout\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\trxdata = readl(priv->membase + UNIPHIER_I2C_DREC);\n\tif (rxdatap)\n\t\t*rxdatap = rxdata;\n\n\treturn 0;\n}\n\nstatic int uniphier_i2c_send_byte(struct i2c_adapter *adap, u32 txdata)\n{\n\tu32 rxdata;\n\tint ret;\n\n\tret = uniphier_i2c_xfer_byte(adap, txdata, &rxdata);\n\tif (ret)\n\t\treturn ret;\n\n\tif (unlikely(rxdata & UNIPHIER_I2C_DREC_LAB))\n\t\treturn -EAGAIN;\n\n\tif (unlikely(rxdata & UNIPHIER_I2C_DREC_LRB))\n\t\treturn -ENXIO;\n\n\treturn 0;\n}\n\nstatic int uniphier_i2c_tx(struct i2c_adapter *adap, u16 addr, u16 len,\n\t\t\t   const u8 *buf)\n{\n\tint ret;\n\n\tret = uniphier_i2c_send_byte(adap, addr << 1 |\n\t\t\t\t     UNIPHIER_I2C_DTRM_STA |\n\t\t\t\t     UNIPHIER_I2C_DTRM_NACK);\n\tif (ret)\n\t\treturn ret;\n\n\twhile (len--) {\n\t\tret = uniphier_i2c_send_byte(adap,\n\t\t\t\t\t     UNIPHIER_I2C_DTRM_NACK | *buf++);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int uniphier_i2c_rx(struct i2c_adapter *adap, u16 addr, u16 len,\n\t\t\t   u8 *buf)\n{\n\tint ret;\n\n\tret = uniphier_i2c_send_byte(adap, addr << 1 |\n\t\t\t\t     UNIPHIER_I2C_DTRM_STA |\n\t\t\t\t     UNIPHIER_I2C_DTRM_NACK |\n\t\t\t\t     UNIPHIER_I2C_DTRM_RD);\n\tif (ret)\n\t\treturn ret;\n\n\twhile (len--) {\n\t\tu32 rxdata;\n\n\t\tret = uniphier_i2c_xfer_byte(adap,\n\t\t\t\t\t     len ? 0 : UNIPHIER_I2C_DTRM_NACK,\n\t\t\t\t\t     &rxdata);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\t*buf++ = rxdata;\n\t}\n\n\treturn 0;\n}\n\nstatic int uniphier_i2c_stop(struct i2c_adapter *adap)\n{\n\treturn uniphier_i2c_send_byte(adap, UNIPHIER_I2C_DTRM_STO |\n\t\t\t\t      UNIPHIER_I2C_DTRM_NACK);\n}\n\nstatic int uniphier_i2c_master_xfer_one(struct i2c_adapter *adap,\n\t\t\t\t\tstruct i2c_msg *msg, bool stop)\n{\n\tbool is_read = msg->flags & I2C_M_RD;\n\tbool recovery = false;\n\tint ret;\n\n\tif (is_read)\n\t\tret = uniphier_i2c_rx(adap, msg->addr, msg->len, msg->buf);\n\telse\n\t\tret = uniphier_i2c_tx(adap, msg->addr, msg->len, msg->buf);\n\n\tif (ret == -EAGAIN)  \n\t\treturn ret;\n\n\tif (ret == -ETIMEDOUT) {\n\t\t \n\t\tstop = false;\n\t\trecovery = true;\n\t}\n\n\tif (stop) {\n\t\tint ret2 = uniphier_i2c_stop(adap);\n\n\t\tif (ret2) {\n\t\t\t \n\t\t\trecovery = true;\n\t\t\tret = ret ?: ret2;\n\t\t}\n\t}\n\n\tif (recovery)\n\t\ti2c_recover_bus(adap);\n\n\treturn ret;\n}\n\nstatic int uniphier_i2c_check_bus_busy(struct i2c_adapter *adap)\n{\n\tstruct uniphier_i2c_priv *priv = i2c_get_adapdata(adap);\n\n\tif (!(readl(priv->membase + UNIPHIER_I2C_DREC) &\n\t\t\t\t\t\tUNIPHIER_I2C_DREC_BBN)) {\n\t\tif (priv->busy_cnt++ > 3) {\n\t\t\t \n\t\t\ti2c_recover_bus(adap);\n\t\t\tpriv->busy_cnt = 0;\n\t\t}\n\n\t\treturn -EAGAIN;\n\t}\n\n\tpriv->busy_cnt = 0;\n\treturn 0;\n}\n\nstatic int uniphier_i2c_master_xfer(struct i2c_adapter *adap,\n\t\t\t\t    struct i2c_msg *msgs, int num)\n{\n\tstruct i2c_msg *msg, *emsg = msgs + num;\n\tint ret;\n\n\tret = uniphier_i2c_check_bus_busy(adap);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (msg = msgs; msg < emsg; msg++) {\n\t\t \n\t\tbool stop = (msg + 1 == emsg) || (msg->flags & I2C_M_STOP);\n\n\t\tret = uniphier_i2c_master_xfer_one(adap, msg, stop);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn num;\n}\n\nstatic u32 uniphier_i2c_functionality(struct i2c_adapter *adap)\n{\n\treturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;\n}\n\nstatic const struct i2c_algorithm uniphier_i2c_algo = {\n\t.master_xfer = uniphier_i2c_master_xfer,\n\t.functionality = uniphier_i2c_functionality,\n};\n\nstatic void uniphier_i2c_reset(struct uniphier_i2c_priv *priv, bool reset_on)\n{\n\tu32 val = UNIPHIER_I2C_BRST_RSCL;\n\n\tval |= reset_on ? 0 : UNIPHIER_I2C_BRST_FOEN;\n\twritel(val, priv->membase + UNIPHIER_I2C_BRST);\n}\n\nstatic int uniphier_i2c_get_scl(struct i2c_adapter *adap)\n{\n\tstruct uniphier_i2c_priv *priv = i2c_get_adapdata(adap);\n\n\treturn !!(readl(priv->membase + UNIPHIER_I2C_BSTS) &\n\t\t\t\t\t\t\tUNIPHIER_I2C_BSTS_SCL);\n}\n\nstatic void uniphier_i2c_set_scl(struct i2c_adapter *adap, int val)\n{\n\tstruct uniphier_i2c_priv *priv = i2c_get_adapdata(adap);\n\n\twritel(val ? UNIPHIER_I2C_BRST_RSCL : 0,\n\t       priv->membase + UNIPHIER_I2C_BRST);\n}\n\nstatic int uniphier_i2c_get_sda(struct i2c_adapter *adap)\n{\n\tstruct uniphier_i2c_priv *priv = i2c_get_adapdata(adap);\n\n\treturn !!(readl(priv->membase + UNIPHIER_I2C_BSTS) &\n\t\t\t\t\t\t\tUNIPHIER_I2C_BSTS_SDA);\n}\n\nstatic void uniphier_i2c_unprepare_recovery(struct i2c_adapter *adap)\n{\n\tuniphier_i2c_reset(i2c_get_adapdata(adap), false);\n}\n\nstatic struct i2c_bus_recovery_info uniphier_i2c_bus_recovery_info = {\n\t.recover_bus = i2c_generic_scl_recovery,\n\t.get_scl = uniphier_i2c_get_scl,\n\t.set_scl = uniphier_i2c_set_scl,\n\t.get_sda = uniphier_i2c_get_sda,\n\t.unprepare_recovery = uniphier_i2c_unprepare_recovery,\n};\n\nstatic void uniphier_i2c_hw_init(struct uniphier_i2c_priv *priv)\n{\n\tunsigned int cyc = priv->clk_cycle;\n\n\tuniphier_i2c_reset(priv, true);\n\n\t \n\twritel((cyc * 5 / 9 << 16) | cyc, priv->membase + UNIPHIER_I2C_CLK);\n\n\tuniphier_i2c_reset(priv, false);\n}\n\nstatic int uniphier_i2c_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct uniphier_i2c_priv *priv;\n\tu32 bus_speed;\n\tunsigned long clk_rate;\n\tint irq, ret;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->membase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(priv->membase))\n\t\treturn PTR_ERR(priv->membase);\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tif (of_property_read_u32(dev->of_node, \"clock-frequency\", &bus_speed))\n\t\tbus_speed = I2C_MAX_STANDARD_MODE_FREQ;\n\n\tif (!bus_speed || bus_speed > I2C_MAX_FAST_MODE_FREQ) {\n\t\tdev_err(dev, \"invalid clock-frequency %d\\n\", bus_speed);\n\t\treturn -EINVAL;\n\t}\n\n\tpriv->clk = devm_clk_get_enabled(dev, NULL);\n\tif (IS_ERR(priv->clk)) {\n\t\tdev_err(dev, \"failed to enable clock\\n\");\n\t\treturn PTR_ERR(priv->clk);\n\t}\n\n\tclk_rate = clk_get_rate(priv->clk);\n\tif (!clk_rate) {\n\t\tdev_err(dev, \"input clock rate should not be zero\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpriv->clk_cycle = clk_rate / bus_speed;\n\tinit_completion(&priv->comp);\n\tpriv->adap.owner = THIS_MODULE;\n\tpriv->adap.algo = &uniphier_i2c_algo;\n\tpriv->adap.dev.parent = dev;\n\tpriv->adap.dev.of_node = dev->of_node;\n\tstrscpy(priv->adap.name, \"UniPhier I2C\", sizeof(priv->adap.name));\n\tpriv->adap.bus_recovery_info = &uniphier_i2c_bus_recovery_info;\n\ti2c_set_adapdata(&priv->adap, priv);\n\tplatform_set_drvdata(pdev, priv);\n\n\tuniphier_i2c_hw_init(priv);\n\n\tret = devm_request_irq(dev, irq, uniphier_i2c_interrupt, 0, pdev->name,\n\t\t\t       priv);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to request irq %d\\n\", irq);\n\t\treturn ret;\n\t}\n\n\treturn i2c_add_adapter(&priv->adap);\n}\n\nstatic void uniphier_i2c_remove(struct platform_device *pdev)\n{\n\tstruct uniphier_i2c_priv *priv = platform_get_drvdata(pdev);\n\n\ti2c_del_adapter(&priv->adap);\n}\n\nstatic int __maybe_unused uniphier_i2c_suspend(struct device *dev)\n{\n\tstruct uniphier_i2c_priv *priv = dev_get_drvdata(dev);\n\n\tclk_disable_unprepare(priv->clk);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused uniphier_i2c_resume(struct device *dev)\n{\n\tstruct uniphier_i2c_priv *priv = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = clk_prepare_enable(priv->clk);\n\tif (ret)\n\t\treturn ret;\n\n\tuniphier_i2c_hw_init(priv);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops uniphier_i2c_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(uniphier_i2c_suspend, uniphier_i2c_resume)\n};\n\nstatic const struct of_device_id uniphier_i2c_match[] = {\n\t{ .compatible = \"socionext,uniphier-i2c\" },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, uniphier_i2c_match);\n\nstatic struct platform_driver uniphier_i2c_drv = {\n\t.probe  = uniphier_i2c_probe,\n\t.remove_new = uniphier_i2c_remove,\n\t.driver = {\n\t\t.name  = \"uniphier-i2c\",\n\t\t.of_match_table = uniphier_i2c_match,\n\t\t.pm = &uniphier_i2c_pm_ops,\n\t},\n};\nmodule_platform_driver(uniphier_i2c_drv);\n\nMODULE_AUTHOR(\"Masahiro Yamada <yamada.masahiro@socionext.com>\");\nMODULE_DESCRIPTION(\"UniPhier I2C bus driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}