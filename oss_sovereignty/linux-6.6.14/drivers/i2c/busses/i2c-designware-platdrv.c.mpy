{
  "module_name": "i2c-designware-platdrv.c",
  "hash_id": "f897567127a0fb8439c9bb1a3ca0a0672edafd2bbf16a9632762591c400272cc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-designware-platdrv.c",
  "human_readable_source": "\n \n#include <linux/acpi.h>\n#include <linux/clk-provider.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/dmi.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm.h>\n#include <linux/pm_runtime.h>\n#include <linux/property.h>\n#include <linux/regmap.h>\n#include <linux/reset.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/units.h>\n\n#include \"i2c-designware-core.h\"\n\nstatic u32 i2c_dw_get_clk_rate_khz(struct dw_i2c_dev *dev)\n{\n\treturn clk_get_rate(dev->clk) / KILO;\n}\n\n#ifdef CONFIG_ACPI\nstatic const struct acpi_device_id dw_i2c_acpi_match[] = {\n\t{ \"INT33C2\", 0 },\n\t{ \"INT33C3\", 0 },\n\t{ \"INT3432\", 0 },\n\t{ \"INT3433\", 0 },\n\t{ \"80860F41\", ACCESS_NO_IRQ_SUSPEND },\n\t{ \"808622C1\", ACCESS_NO_IRQ_SUSPEND },\n\t{ \"AMD0010\", ACCESS_INTR_MASK },\n\t{ \"AMDI0010\", ACCESS_INTR_MASK },\n\t{ \"AMDI0019\", ACCESS_INTR_MASK | ARBITRATION_SEMAPHORE },\n\t{ \"AMDI0510\", 0 },\n\t{ \"APMC0D0F\", 0 },\n\t{ \"HISI02A1\", 0 },\n\t{ \"HISI02A2\", 0 },\n\t{ \"HISI02A3\", 0 },\n\t{ \"HYGO0010\", ACCESS_INTR_MASK },\n\t{ }\n};\nMODULE_DEVICE_TABLE(acpi, dw_i2c_acpi_match);\n#endif\n\n#ifdef CONFIG_OF\n#define BT1_I2C_CTL\t\t\t0x100\n#define BT1_I2C_CTL_ADDR_MASK\t\tGENMASK(7, 0)\n#define BT1_I2C_CTL_WR\t\t\tBIT(8)\n#define BT1_I2C_CTL_GO\t\t\tBIT(31)\n#define BT1_I2C_DI\t\t\t0x104\n#define BT1_I2C_DO\t\t\t0x108\n\nstatic int bt1_i2c_read(void *context, unsigned int reg, unsigned int *val)\n{\n\tstruct dw_i2c_dev *dev = context;\n\tint ret;\n\n\t \n\tret = regmap_write(dev->sysmap, BT1_I2C_CTL,\n\t\t\t   BT1_I2C_CTL_GO | (reg & BT1_I2C_CTL_ADDR_MASK));\n\tif (ret)\n\t\treturn ret;\n\n\treturn regmap_read(dev->sysmap, BT1_I2C_DO, val);\n}\n\nstatic int bt1_i2c_write(void *context, unsigned int reg, unsigned int val)\n{\n\tstruct dw_i2c_dev *dev = context;\n\tint ret;\n\n\tret = regmap_write(dev->sysmap, BT1_I2C_DI, val);\n\tif (ret)\n\t\treturn ret;\n\n\treturn regmap_write(dev->sysmap, BT1_I2C_CTL,\n\t\tBT1_I2C_CTL_GO | BT1_I2C_CTL_WR | (reg & BT1_I2C_CTL_ADDR_MASK));\n}\n\nstatic struct regmap_config bt1_i2c_cfg = {\n\t.reg_bits = 32,\n\t.val_bits = 32,\n\t.reg_stride = 4,\n\t.fast_io = true,\n\t.reg_read = bt1_i2c_read,\n\t.reg_write = bt1_i2c_write,\n\t.max_register = DW_IC_COMP_TYPE,\n};\n\nstatic int bt1_i2c_request_regs(struct dw_i2c_dev *dev)\n{\n\tdev->sysmap = syscon_node_to_regmap(dev->dev->of_node->parent);\n\tif (IS_ERR(dev->sysmap))\n\t\treturn PTR_ERR(dev->sysmap);\n\n\tdev->map = devm_regmap_init(dev->dev, NULL, dev, &bt1_i2c_cfg);\n\treturn PTR_ERR_OR_ZERO(dev->map);\n}\n\n#define MSCC_ICPU_CFG_TWI_DELAY\t\t0x0\n#define MSCC_ICPU_CFG_TWI_DELAY_ENABLE\tBIT(0)\n#define MSCC_ICPU_CFG_TWI_SPIKE_FILTER\t0x4\n\nstatic int mscc_twi_set_sda_hold_time(struct dw_i2c_dev *dev)\n{\n\twritel((dev->sda_hold_time << 1) | MSCC_ICPU_CFG_TWI_DELAY_ENABLE,\n\t       dev->ext + MSCC_ICPU_CFG_TWI_DELAY);\n\n\treturn 0;\n}\n\nstatic int dw_i2c_of_configure(struct platform_device *pdev)\n{\n\tstruct dw_i2c_dev *dev = platform_get_drvdata(pdev);\n\n\tswitch (dev->flags & MODEL_MASK) {\n\tcase MODEL_MSCC_OCELOT:\n\t\tdev->ext = devm_platform_ioremap_resource(pdev, 1);\n\t\tif (!IS_ERR(dev->ext))\n\t\t\tdev->set_sda_hold_time = mscc_twi_set_sda_hold_time;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct of_device_id dw_i2c_of_match[] = {\n\t{ .compatible = \"snps,designware-i2c\", },\n\t{ .compatible = \"mscc,ocelot-i2c\", .data = (void *)MODEL_MSCC_OCELOT },\n\t{ .compatible = \"baikal,bt1-sys-i2c\", .data = (void *)MODEL_BAIKAL_BT1 },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, dw_i2c_of_match);\n#else\nstatic int bt1_i2c_request_regs(struct dw_i2c_dev *dev)\n{\n\treturn -ENODEV;\n}\n\nstatic inline int dw_i2c_of_configure(struct platform_device *pdev)\n{\n\treturn -ENODEV;\n}\n#endif\n\nstatic int txgbe_i2c_request_regs(struct dw_i2c_dev *dev)\n{\n\tdev->map = dev_get_regmap(dev->dev->parent, NULL);\n\tif (!dev->map)\n\t\treturn -ENODEV;\n\n\treturn 0;\n}\n\nstatic void dw_i2c_plat_pm_cleanup(struct dw_i2c_dev *dev)\n{\n\tpm_runtime_disable(dev->dev);\n\n\tif (dev->shared_with_punit)\n\t\tpm_runtime_put_noidle(dev->dev);\n}\n\nstatic int dw_i2c_plat_request_regs(struct dw_i2c_dev *dev)\n{\n\tstruct platform_device *pdev = to_platform_device(dev->dev);\n\tint ret;\n\n\tswitch (dev->flags & MODEL_MASK) {\n\tcase MODEL_BAIKAL_BT1:\n\t\tret = bt1_i2c_request_regs(dev);\n\t\tbreak;\n\tcase MODEL_WANGXUN_SP:\n\t\tret = txgbe_i2c_request_regs(dev);\n\t\tbreak;\n\tdefault:\n\t\tdev->base = devm_platform_ioremap_resource(pdev, 0);\n\t\tret = PTR_ERR_OR_ZERO(dev->base);\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic const struct dmi_system_id dw_i2c_hwmon_class_dmi[] = {\n\t{\n\t\t.ident = \"Qtechnology QT5222\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Qtechnology\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"QT5222\"),\n\t\t},\n\t},\n\t{ }  \n};\n\nstatic const struct i2c_dw_semaphore_callbacks i2c_dw_semaphore_cb_table[] = {\n#ifdef CONFIG_I2C_DESIGNWARE_BAYTRAIL\n\t{\n\t\t.probe = i2c_dw_baytrail_probe_lock_support,\n\t},\n#endif\n#ifdef CONFIG_I2C_DESIGNWARE_AMDPSP\n\t{\n\t\t.probe = i2c_dw_amdpsp_probe_lock_support,\n\t},\n#endif\n\t{}\n};\n\nstatic int i2c_dw_probe_lock_support(struct dw_i2c_dev *dev)\n{\n\tconst struct i2c_dw_semaphore_callbacks *ptr;\n\tint i = 0;\n\tint ret;\n\n\tptr = i2c_dw_semaphore_cb_table;\n\n\tdev->semaphore_idx = -1;\n\n\twhile (ptr->probe) {\n\t\tret = ptr->probe(dev);\n\t\tif (ret) {\n\t\t\t \n\t\t\tif (ret != -ENODEV)\n\t\t\t\treturn ret;\n\n\t\t\ti++;\n\t\t\tptr++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tdev->semaphore_idx = i;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic void i2c_dw_remove_lock_support(struct dw_i2c_dev *dev)\n{\n\tif (dev->semaphore_idx < 0)\n\t\treturn;\n\n\tif (i2c_dw_semaphore_cb_table[dev->semaphore_idx].remove)\n\t\ti2c_dw_semaphore_cb_table[dev->semaphore_idx].remove(dev);\n}\n\nstatic int dw_i2c_plat_probe(struct platform_device *pdev)\n{\n\tstruct i2c_adapter *adap;\n\tstruct dw_i2c_dev *dev;\n\tstruct i2c_timings *t;\n\tint irq, ret;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tdev = devm_kzalloc(&pdev->dev, sizeof(struct dw_i2c_dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tdev->flags = (uintptr_t)device_get_match_data(&pdev->dev);\n\tif (device_property_present(&pdev->dev, \"wx,i2c-snps-model\"))\n\t\tdev->flags = MODEL_WANGXUN_SP;\n\n\tdev->dev = &pdev->dev;\n\tdev->irq = irq;\n\tplatform_set_drvdata(pdev, dev);\n\n\tret = dw_i2c_plat_request_regs(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tdev->rst = devm_reset_control_get_optional_exclusive(&pdev->dev, NULL);\n\tif (IS_ERR(dev->rst))\n\t\treturn PTR_ERR(dev->rst);\n\n\treset_control_deassert(dev->rst);\n\n\tt = &dev->timings;\n\ti2c_parse_fw_timings(&pdev->dev, t, false);\n\n\ti2c_dw_adjust_bus_speed(dev);\n\n\tif (pdev->dev.of_node)\n\t\tdw_i2c_of_configure(pdev);\n\n\tif (has_acpi_companion(&pdev->dev))\n\t\ti2c_dw_acpi_configure(&pdev->dev);\n\n\tret = i2c_dw_validate_speed(dev);\n\tif (ret)\n\t\tgoto exit_reset;\n\n\tret = i2c_dw_probe_lock_support(dev);\n\tif (ret)\n\t\tgoto exit_reset;\n\n\ti2c_dw_configure(dev);\n\n\t \n\tdev->pclk = devm_clk_get_optional(&pdev->dev, \"pclk\");\n\tif (IS_ERR(dev->pclk)) {\n\t\tret = PTR_ERR(dev->pclk);\n\t\tgoto exit_reset;\n\t}\n\n\tdev->clk = devm_clk_get_optional(&pdev->dev, NULL);\n\tif (IS_ERR(dev->clk)) {\n\t\tret = PTR_ERR(dev->clk);\n\t\tgoto exit_reset;\n\t}\n\n\tret = i2c_dw_prepare_clk(dev, true);\n\tif (ret)\n\t\tgoto exit_reset;\n\n\tif (dev->clk) {\n\t\tu64 clk_khz;\n\n\t\tdev->get_clk_rate_khz = i2c_dw_get_clk_rate_khz;\n\t\tclk_khz = dev->get_clk_rate_khz(dev);\n\n\t\tif (!dev->sda_hold_time && t->sda_hold_ns)\n\t\t\tdev->sda_hold_time =\n\t\t\t\tDIV_S64_ROUND_CLOSEST(clk_khz * t->sda_hold_ns, MICRO);\n\t}\n\n\tadap = &dev->adapter;\n\tadap->owner = THIS_MODULE;\n\tadap->class = dmi_check_system(dw_i2c_hwmon_class_dmi) ?\n\t\t\t\t\tI2C_CLASS_HWMON : I2C_CLASS_DEPRECATED;\n\tACPI_COMPANION_SET(&adap->dev, ACPI_COMPANION(&pdev->dev));\n\tadap->dev.of_node = pdev->dev.of_node;\n\tadap->nr = -1;\n\n\tif (dev->flags & ACCESS_NO_IRQ_SUSPEND) {\n\t\tdev_pm_set_driver_flags(&pdev->dev,\n\t\t\t\t\tDPM_FLAG_SMART_PREPARE);\n\t} else {\n\t\tdev_pm_set_driver_flags(&pdev->dev,\n\t\t\t\t\tDPM_FLAG_SMART_PREPARE |\n\t\t\t\t\tDPM_FLAG_SMART_SUSPEND);\n\t}\n\n\tdevice_enable_async_suspend(&pdev->dev);\n\n\t \n\tWARN_ON(pm_runtime_enabled(&pdev->dev));\n\n\tpm_runtime_set_autosuspend_delay(&pdev->dev, 1000);\n\tpm_runtime_use_autosuspend(&pdev->dev);\n\tpm_runtime_set_active(&pdev->dev);\n\n\tif (dev->shared_with_punit)\n\t\tpm_runtime_get_noresume(&pdev->dev);\n\n\tpm_runtime_enable(&pdev->dev);\n\n\tret = i2c_dw_probe(dev);\n\tif (ret)\n\t\tgoto exit_probe;\n\n\treturn ret;\n\nexit_probe:\n\tdw_i2c_plat_pm_cleanup(dev);\nexit_reset:\n\treset_control_assert(dev->rst);\n\treturn ret;\n}\n\nstatic void dw_i2c_plat_remove(struct platform_device *pdev)\n{\n\tstruct dw_i2c_dev *dev = platform_get_drvdata(pdev);\n\n\tpm_runtime_get_sync(&pdev->dev);\n\n\ti2c_del_adapter(&dev->adapter);\n\n\tdev->disable(dev);\n\n\tpm_runtime_dont_use_autosuspend(&pdev->dev);\n\tpm_runtime_put_sync(&pdev->dev);\n\tdw_i2c_plat_pm_cleanup(dev);\n\n\ti2c_dw_remove_lock_support(dev);\n\n\treset_control_assert(dev->rst);\n}\n\nstatic int dw_i2c_plat_prepare(struct device *dev)\n{\n\t \n\treturn !has_acpi_companion(dev);\n}\n\nstatic int dw_i2c_plat_runtime_suspend(struct device *dev)\n{\n\tstruct dw_i2c_dev *i_dev = dev_get_drvdata(dev);\n\n\tif (i_dev->shared_with_punit)\n\t\treturn 0;\n\n\ti_dev->disable(i_dev);\n\ti2c_dw_prepare_clk(i_dev, false);\n\n\treturn 0;\n}\n\nstatic int dw_i2c_plat_suspend(struct device *dev)\n{\n\tstruct dw_i2c_dev *i_dev = dev_get_drvdata(dev);\n\n\ti2c_mark_adapter_suspended(&i_dev->adapter);\n\n\treturn dw_i2c_plat_runtime_suspend(dev);\n}\n\nstatic int dw_i2c_plat_runtime_resume(struct device *dev)\n{\n\tstruct dw_i2c_dev *i_dev = dev_get_drvdata(dev);\n\n\tif (!i_dev->shared_with_punit)\n\t\ti2c_dw_prepare_clk(i_dev, true);\n\n\ti_dev->init(i_dev);\n\n\treturn 0;\n}\n\nstatic int dw_i2c_plat_resume(struct device *dev)\n{\n\tstruct dw_i2c_dev *i_dev = dev_get_drvdata(dev);\n\n\tdw_i2c_plat_runtime_resume(dev);\n\ti2c_mark_adapter_resumed(&i_dev->adapter);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops dw_i2c_dev_pm_ops = {\n\t.prepare = pm_sleep_ptr(dw_i2c_plat_prepare),\n\tLATE_SYSTEM_SLEEP_PM_OPS(dw_i2c_plat_suspend, dw_i2c_plat_resume)\n\tRUNTIME_PM_OPS(dw_i2c_plat_runtime_suspend, dw_i2c_plat_runtime_resume, NULL)\n};\n\n \nMODULE_ALIAS(\"platform:i2c_designware\");\n\nstatic struct platform_driver dw_i2c_driver = {\n\t.probe = dw_i2c_plat_probe,\n\t.remove_new = dw_i2c_plat_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"i2c_designware\",\n\t\t.of_match_table = of_match_ptr(dw_i2c_of_match),\n\t\t.acpi_match_table = ACPI_PTR(dw_i2c_acpi_match),\n\t\t.pm\t= pm_ptr(&dw_i2c_dev_pm_ops),\n\t},\n};\n\nstatic int __init dw_i2c_init_driver(void)\n{\n\treturn platform_driver_register(&dw_i2c_driver);\n}\nsubsys_initcall(dw_i2c_init_driver);\n\nstatic void __exit dw_i2c_exit_driver(void)\n{\n\tplatform_driver_unregister(&dw_i2c_driver);\n}\nmodule_exit(dw_i2c_exit_driver);\n\nMODULE_AUTHOR(\"Baruch Siach <baruch@tkos.co.il>\");\nMODULE_DESCRIPTION(\"Synopsys DesignWare I2C bus adapter\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}