{
  "module_name": "i2c-sis96x.c",
  "hash_id": "5e830995862724be5fabe0482528ca7e331c4a8c15ca779c6333c6637e09c377",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/busses/i2c-sis96x.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/delay.h>\n#include <linux/stddef.h>\n#include <linux/ioport.h>\n#include <linux/i2c.h>\n#include <linux/acpi.h>\n#include <linux/io.h>\n\n \n#define SIS96x_BAR 0x04\n\n \n#define SMB_STS      0x00\n#define SMB_EN       0x01\n#define SMB_CNT      0x02\n#define SMB_HOST_CNT 0x03\n#define SMB_ADDR     0x04\n#define SMB_CMD      0x05\n#define SMB_PCOUNT   0x06\n#define SMB_COUNT    0x07\n#define SMB_BYTE     0x08\n#define SMB_DEV_ADDR 0x10\n#define SMB_DB0      0x11\n#define SMB_DB1      0x12\n#define SMB_SAA      0x13\n\n \n#define SMB_IOSIZE 0x20\n\n \n#define MAX_TIMEOUT 500\n\n \n#define SIS96x_QUICK      0x00\n#define SIS96x_BYTE       0x01\n#define SIS96x_BYTE_DATA  0x02\n#define SIS96x_WORD_DATA  0x03\n#define SIS96x_PROC_CALL  0x04\n#define SIS96x_BLOCK_DATA 0x05\n\nstatic struct pci_driver sis96x_driver;\nstatic struct i2c_adapter sis96x_adapter;\nstatic u16 sis96x_smbus_base;\n\nstatic inline u8 sis96x_read(u8 reg)\n{\n\treturn inb(sis96x_smbus_base + reg) ;\n}\n\nstatic inline void sis96x_write(u8 reg, u8 data)\n{\n\toutb(data, sis96x_smbus_base + reg) ;\n}\n\n \nstatic int sis96x_transaction(int size)\n{\n\tint temp;\n\tint result = 0;\n\tint timeout = 0;\n\n\tdev_dbg(&sis96x_adapter.dev, \"SMBus transaction %d\\n\", size);\n\n\t \n\tif (((temp = sis96x_read(SMB_CNT)) & 0x03) != 0x00) {\n\n\t\tdev_dbg(&sis96x_adapter.dev, \"SMBus busy (0x%02x). \"\n\t\t\t\"Resetting...\\n\", temp);\n\n\t\t \n\t\tsis96x_write(SMB_HOST_CNT, 0x20);\n\n\t\t \n\t\tif (((temp = sis96x_read(SMB_CNT)) & 0x03) != 0x00) {\n\t\t\tdev_dbg(&sis96x_adapter.dev, \"Failed (0x%02x)\\n\", temp);\n\t\t\treturn -EBUSY;\n\t\t} else {\n\t\t\tdev_dbg(&sis96x_adapter.dev, \"Successful\\n\");\n\t\t}\n\t}\n\n\t \n\tsis96x_write(SMB_CNT, 0x20);\n\n\t \n\ttemp = sis96x_read(SMB_STS);\n\tsis96x_write(SMB_STS, temp & 0x1e);\n\n\t \n\tsis96x_write(SMB_HOST_CNT, 0x10 | (size & 0x07));\n\n\t \n\tdo {\n\t\tmsleep(1);\n\t\ttemp = sis96x_read(SMB_STS);\n\t} while (!(temp & 0x0e) && (timeout++ < MAX_TIMEOUT));\n\n\t \n\tif (timeout > MAX_TIMEOUT) {\n\t\tdev_dbg(&sis96x_adapter.dev, \"SMBus Timeout! (0x%02x)\\n\", temp);\n\t\tresult = -ETIMEDOUT;\n\t}\n\n\t \n\tif (temp & 0x02) {\n\t\tdev_dbg(&sis96x_adapter.dev, \"Failed bus transaction!\\n\");\n\t\tresult = -ENXIO;\n\t}\n\n\t \n\tif (temp & 0x04) {\n\t\tdev_dbg(&sis96x_adapter.dev, \"Bus collision!\\n\");\n\t\tresult = -EIO;\n\t}\n\n\t \n\tsis96x_write(SMB_STS, temp);\n\tif ((temp = sis96x_read(SMB_STS))) {\n\t\tdev_dbg(&sis96x_adapter.dev, \"Failed reset at \"\n\t\t\t\"end of transaction! (0x%02x)\\n\", temp);\n\t}\n\n\treturn result;\n}\n\n \nstatic s32 sis96x_access(struct i2c_adapter * adap, u16 addr,\n\t\t\t unsigned short flags, char read_write,\n\t\t\t u8 command, int size, union i2c_smbus_data * data)\n{\n\tint status;\n\n\tswitch (size) {\n\tcase I2C_SMBUS_QUICK:\n\t\tsis96x_write(SMB_ADDR, ((addr & 0x7f) << 1) | (read_write & 0x01));\n\t\tsize = SIS96x_QUICK;\n\t\tbreak;\n\n\tcase I2C_SMBUS_BYTE:\n\t\tsis96x_write(SMB_ADDR, ((addr & 0x7f) << 1) | (read_write & 0x01));\n\t\tif (read_write == I2C_SMBUS_WRITE)\n\t\t\tsis96x_write(SMB_CMD, command);\n\t\tsize = SIS96x_BYTE;\n\t\tbreak;\n\n\tcase I2C_SMBUS_BYTE_DATA:\n\t\tsis96x_write(SMB_ADDR, ((addr & 0x7f) << 1) | (read_write & 0x01));\n\t\tsis96x_write(SMB_CMD, command);\n\t\tif (read_write == I2C_SMBUS_WRITE)\n\t\t\tsis96x_write(SMB_BYTE, data->byte);\n\t\tsize = SIS96x_BYTE_DATA;\n\t\tbreak;\n\n\tcase I2C_SMBUS_PROC_CALL:\n\tcase I2C_SMBUS_WORD_DATA:\n\t\tsis96x_write(SMB_ADDR, ((addr & 0x7f) << 1) | (read_write & 0x01));\n\t\tsis96x_write(SMB_CMD, command);\n\t\tif (read_write == I2C_SMBUS_WRITE) {\n\t\t\tsis96x_write(SMB_BYTE, data->word & 0xff);\n\t\t\tsis96x_write(SMB_BYTE + 1, (data->word & 0xff00) >> 8);\n\t\t}\n\t\tsize = (size == I2C_SMBUS_PROC_CALL ? \n\t\t\tSIS96x_PROC_CALL : SIS96x_WORD_DATA);\n\t\tbreak;\n\n\tdefault:\n\t\tdev_warn(&adap->dev, \"Unsupported transaction %d\\n\", size);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tstatus = sis96x_transaction(size);\n\tif (status)\n\t\treturn status;\n\n\tif ((size != SIS96x_PROC_CALL) &&\n\t\t((read_write == I2C_SMBUS_WRITE) || (size == SIS96x_QUICK)))\n\t\treturn 0;\n\n\tswitch (size) {\n\tcase SIS96x_BYTE:\n\tcase SIS96x_BYTE_DATA:\n\t\tdata->byte = sis96x_read(SMB_BYTE);\n\t\tbreak;\n\n\tcase SIS96x_WORD_DATA:\n\tcase SIS96x_PROC_CALL:\n\t\tdata->word = sis96x_read(SMB_BYTE) +\n\t\t\t\t(sis96x_read(SMB_BYTE + 1) << 8);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic u32 sis96x_func(struct i2c_adapter *adapter)\n{\n\treturn I2C_FUNC_SMBUS_QUICK | I2C_FUNC_SMBUS_BYTE |\n\t    I2C_FUNC_SMBUS_BYTE_DATA | I2C_FUNC_SMBUS_WORD_DATA |\n\t    I2C_FUNC_SMBUS_PROC_CALL;\n}\n\nstatic const struct i2c_algorithm smbus_algorithm = {\n\t.smbus_xfer\t= sis96x_access,\n\t.functionality\t= sis96x_func,\n};\n\nstatic struct i2c_adapter sis96x_adapter = {\n\t.owner\t\t= THIS_MODULE,\n\t.class\t\t= I2C_CLASS_HWMON | I2C_CLASS_SPD,\n\t.algo\t\t= &smbus_algorithm,\n};\n\nstatic const struct pci_device_id sis96x_ids[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_SI, PCI_DEVICE_ID_SI_SMBUS) },\n\t{ 0, }\n};\n\nMODULE_DEVICE_TABLE (pci, sis96x_ids);\n\nstatic int sis96x_probe(struct pci_dev *dev,\n\t\t\t\tconst struct pci_device_id *id)\n{\n\tu16 ww = 0;\n\tint retval;\n\n\tif (sis96x_smbus_base) {\n\t\tdev_err(&dev->dev, \"Only one device supported.\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tpci_read_config_word(dev, PCI_CLASS_DEVICE, &ww);\n\tif (PCI_CLASS_SERIAL_SMBUS != ww) {\n\t\tdev_err(&dev->dev, \"Unsupported device class 0x%04x!\\n\", ww);\n\t\treturn -ENODEV;\n\t}\n\n\tsis96x_smbus_base = pci_resource_start(dev, SIS96x_BAR);\n\tif (!sis96x_smbus_base) {\n\t\tdev_err(&dev->dev, \"SiS96x SMBus base address \"\n\t\t\t\"not initialized!\\n\");\n\t\treturn -EINVAL;\n\t}\n\tdev_info(&dev->dev, \"SiS96x SMBus base address: 0x%04x\\n\",\n\t\t\tsis96x_smbus_base);\n\n\tretval = acpi_check_resource_conflict(&dev->resource[SIS96x_BAR]);\n\tif (retval)\n\t\treturn -ENODEV;\n\n\t \n\tif (!request_region(sis96x_smbus_base, SMB_IOSIZE,\n\t\t\t    sis96x_driver.name)) {\n\t\tdev_err(&dev->dev, \"SMBus registers 0x%04x-0x%04x \"\n\t\t\t\"already in use!\\n\", sis96x_smbus_base,\n\t\t\tsis96x_smbus_base + SMB_IOSIZE - 1);\n\n\t\tsis96x_smbus_base = 0;\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tsis96x_adapter.dev.parent = &dev->dev;\n\n\tsnprintf(sis96x_adapter.name, sizeof(sis96x_adapter.name),\n\t\t\"SiS96x SMBus adapter at 0x%04x\", sis96x_smbus_base);\n\n\tif ((retval = i2c_add_adapter(&sis96x_adapter))) {\n\t\tdev_err(&dev->dev, \"Couldn't register adapter!\\n\");\n\t\trelease_region(sis96x_smbus_base, SMB_IOSIZE);\n\t\tsis96x_smbus_base = 0;\n\t}\n\n\treturn retval;\n}\n\nstatic void sis96x_remove(struct pci_dev *dev)\n{\n\tif (sis96x_smbus_base) {\n\t\ti2c_del_adapter(&sis96x_adapter);\n\t\trelease_region(sis96x_smbus_base, SMB_IOSIZE);\n\t\tsis96x_smbus_base = 0;\n\t}\n}\n\nstatic struct pci_driver sis96x_driver = {\n\t.name\t\t= \"sis96x_smbus\",\n\t.id_table\t= sis96x_ids,\n\t.probe\t\t= sis96x_probe,\n\t.remove\t\t= sis96x_remove,\n};\n\nmodule_pci_driver(sis96x_driver);\n\nMODULE_AUTHOR(\"Mark M. Hoffman <mhoffman@lightlink.com>\");\nMODULE_DESCRIPTION(\"SiS96x SMBus driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}