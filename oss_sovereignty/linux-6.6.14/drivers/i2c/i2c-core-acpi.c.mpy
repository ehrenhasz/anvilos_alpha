{
  "module_name": "i2c-core-acpi.c",
  "hash_id": "8ba39dcda4482c975e47dd725eb1d50506838bb4ce8ca3b2ab0cd8dd3243e042",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/i2c-core-acpi.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/i2c.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\n#include \"i2c-core.h\"\n\nstruct i2c_acpi_handler_data {\n\tstruct acpi_connection_info info;\n\tstruct i2c_adapter *adapter;\n};\n\nstruct gsb_buffer {\n\tu8\tstatus;\n\tu8\tlen;\n\tunion {\n\t\tu16\twdata;\n\t\tu8\tbdata;\n\t\tDECLARE_FLEX_ARRAY(u8, data);\n\t};\n} __packed;\n\nstruct i2c_acpi_lookup {\n\tstruct i2c_board_info *info;\n\tacpi_handle adapter_handle;\n\tacpi_handle device_handle;\n\tacpi_handle search_handle;\n\tint n;\n\tint index;\n\tu32 speed;\n\tu32 min_speed;\n\tu32 force_speed;\n};\n\n \nbool i2c_acpi_get_i2c_resource(struct acpi_resource *ares,\n\t\t\t       struct acpi_resource_i2c_serialbus **i2c)\n{\n\tstruct acpi_resource_i2c_serialbus *sb;\n\n\tif (ares->type != ACPI_RESOURCE_TYPE_SERIAL_BUS)\n\t\treturn false;\n\n\tsb = &ares->data.i2c_serial_bus;\n\tif (sb->type != ACPI_RESOURCE_SERIAL_TYPE_I2C)\n\t\treturn false;\n\n\t*i2c = sb;\n\treturn true;\n}\nEXPORT_SYMBOL_GPL(i2c_acpi_get_i2c_resource);\n\nstatic int i2c_acpi_resource_count(struct acpi_resource *ares, void *data)\n{\n\tstruct acpi_resource_i2c_serialbus *sb;\n\tint *count = data;\n\n\tif (i2c_acpi_get_i2c_resource(ares, &sb))\n\t\t*count = *count + 1;\n\n\treturn 1;\n}\n\n \nint i2c_acpi_client_count(struct acpi_device *adev)\n{\n\tint ret, count = 0;\n\tLIST_HEAD(r);\n\n\tret = acpi_dev_get_resources(adev, &r, i2c_acpi_resource_count, &count);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tacpi_dev_free_resource_list(&r);\n\treturn count;\n}\nEXPORT_SYMBOL_GPL(i2c_acpi_client_count);\n\nstatic int i2c_acpi_fill_info(struct acpi_resource *ares, void *data)\n{\n\tstruct i2c_acpi_lookup *lookup = data;\n\tstruct i2c_board_info *info = lookup->info;\n\tstruct acpi_resource_i2c_serialbus *sb;\n\tacpi_status status;\n\n\tif (info->addr || !i2c_acpi_get_i2c_resource(ares, &sb))\n\t\treturn 1;\n\n\tif (lookup->index != -1 && lookup->n++ != lookup->index)\n\t\treturn 1;\n\n\tstatus = acpi_get_handle(lookup->device_handle,\n\t\t\t\t sb->resource_source.string_ptr,\n\t\t\t\t &lookup->adapter_handle);\n\tif (ACPI_FAILURE(status))\n\t\treturn 1;\n\n\tinfo->addr = sb->slave_address;\n\tlookup->speed = sb->connection_speed;\n\tif (sb->access_mode == ACPI_I2C_10BIT_MODE)\n\t\tinfo->flags |= I2C_CLIENT_TEN;\n\n\treturn 1;\n}\n\nstatic const struct acpi_device_id i2c_acpi_ignored_device_ids[] = {\n\t \n\t{ ACPI_VIDEO_HID, 0 },\n\t{}\n};\n\nstruct i2c_acpi_irq_context {\n\tint irq;\n\tbool wake_capable;\n};\n\nstatic int i2c_acpi_do_lookup(struct acpi_device *adev,\n\t\t\t      struct i2c_acpi_lookup *lookup)\n{\n\tstruct i2c_board_info *info = lookup->info;\n\tstruct list_head resource_list;\n\tint ret;\n\n\tif (acpi_bus_get_status(adev))\n\t\treturn -EINVAL;\n\n\tif (!acpi_dev_ready_for_enumeration(adev))\n\t\treturn -ENODEV;\n\n\tif (acpi_match_device_ids(adev, i2c_acpi_ignored_device_ids) == 0)\n\t\treturn -ENODEV;\n\n\tmemset(info, 0, sizeof(*info));\n\tlookup->device_handle = acpi_device_handle(adev);\n\n\t \n\tINIT_LIST_HEAD(&resource_list);\n\tret = acpi_dev_get_resources(adev, &resource_list,\n\t\t\t\t     i2c_acpi_fill_info, lookup);\n\tacpi_dev_free_resource_list(&resource_list);\n\n\tif (ret < 0 || !info->addr)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int i2c_acpi_add_irq_resource(struct acpi_resource *ares, void *data)\n{\n\tstruct i2c_acpi_irq_context *irq_ctx = data;\n\tstruct resource r;\n\n\tif (irq_ctx->irq > 0)\n\t\treturn 1;\n\n\tif (!acpi_dev_resource_interrupt(ares, 0, &r))\n\t\treturn 1;\n\n\tirq_ctx->irq = i2c_dev_irq_from_resources(&r, 1);\n\tirq_ctx->wake_capable = r.flags & IORESOURCE_IRQ_WAKECAPABLE;\n\n\treturn 1;  \n}\n\n \nint i2c_acpi_get_irq(struct i2c_client *client, bool *wake_capable)\n{\n\tstruct acpi_device *adev = ACPI_COMPANION(&client->dev);\n\tstruct list_head resource_list;\n\tstruct i2c_acpi_irq_context irq_ctx = {\n\t\t.irq = -ENOENT,\n\t};\n\tint ret;\n\n\tINIT_LIST_HEAD(&resource_list);\n\n\tret = acpi_dev_get_resources(adev, &resource_list,\n\t\t\t\t     i2c_acpi_add_irq_resource, &irq_ctx);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tacpi_dev_free_resource_list(&resource_list);\n\n\tif (irq_ctx.irq == -ENOENT)\n\t\tirq_ctx.irq = acpi_dev_gpio_irq_wake_get(adev, 0, &irq_ctx.wake_capable);\n\n\tif (irq_ctx.irq < 0)\n\t\treturn irq_ctx.irq;\n\n\tif (wake_capable)\n\t\t*wake_capable = irq_ctx.wake_capable;\n\n\treturn irq_ctx.irq;\n}\n\nstatic int i2c_acpi_get_info(struct acpi_device *adev,\n\t\t\t     struct i2c_board_info *info,\n\t\t\t     struct i2c_adapter *adapter,\n\t\t\t     acpi_handle *adapter_handle)\n{\n\tstruct i2c_acpi_lookup lookup;\n\tint ret;\n\n\tmemset(&lookup, 0, sizeof(lookup));\n\tlookup.info = info;\n\tlookup.index = -1;\n\n\tif (acpi_device_enumerated(adev))\n\t\treturn -EINVAL;\n\n\tret = i2c_acpi_do_lookup(adev, &lookup);\n\tif (ret)\n\t\treturn ret;\n\n\tif (adapter) {\n\t\t \n\t\tif (ACPI_HANDLE(&adapter->dev) != lookup.adapter_handle)\n\t\t\treturn -ENODEV;\n\t} else {\n\t\tstruct acpi_device *adapter_adev;\n\n\t\t \n\t\tadapter_adev = acpi_fetch_acpi_dev(lookup.adapter_handle);\n\t\tif (!adapter_adev)\n\t\t\treturn -ENODEV;\n\t\tif (acpi_bus_get_status(adapter_adev) ||\n\t\t    !adapter_adev->status.present)\n\t\t\treturn -ENODEV;\n\t}\n\n\tinfo->fwnode = acpi_fwnode_handle(adev);\n\tif (adapter_handle)\n\t\t*adapter_handle = lookup.adapter_handle;\n\n\tacpi_set_modalias(adev, dev_name(&adev->dev), info->type,\n\t\t\t  sizeof(info->type));\n\n\treturn 0;\n}\n\nstatic void i2c_acpi_register_device(struct i2c_adapter *adapter,\n\t\t\t\t     struct acpi_device *adev,\n\t\t\t\t     struct i2c_board_info *info)\n{\n\t \n\tif (acpi_quirk_skip_i2c_client_enumeration(adev))\n\t\treturn;\n\n\tadev->power.flags.ignore_parent = true;\n\tacpi_device_set_enumerated(adev);\n\n\tif (IS_ERR(i2c_new_client_device(adapter, info)))\n\t\tadev->power.flags.ignore_parent = false;\n}\n\nstatic acpi_status i2c_acpi_add_device(acpi_handle handle, u32 level,\n\t\t\t\t       void *data, void **return_value)\n{\n\tstruct i2c_adapter *adapter = data;\n\tstruct acpi_device *adev = acpi_fetch_acpi_dev(handle);\n\tstruct i2c_board_info info;\n\n\tif (!adev || i2c_acpi_get_info(adev, &info, adapter, NULL))\n\t\treturn AE_OK;\n\n\ti2c_acpi_register_device(adapter, adev, &info);\n\n\treturn AE_OK;\n}\n\n#define I2C_ACPI_MAX_SCAN_DEPTH 32\n\n \nvoid i2c_acpi_register_devices(struct i2c_adapter *adap)\n{\n\tstruct acpi_device *adev;\n\tacpi_status status;\n\n\tif (!has_acpi_companion(&adap->dev))\n\t\treturn;\n\n\tstatus = acpi_walk_namespace(ACPI_TYPE_DEVICE, ACPI_ROOT_OBJECT,\n\t\t\t\t     I2C_ACPI_MAX_SCAN_DEPTH,\n\t\t\t\t     i2c_acpi_add_device, NULL,\n\t\t\t\t     adap, NULL);\n\tif (ACPI_FAILURE(status))\n\t\tdev_warn(&adap->dev, \"failed to enumerate I2C slaves\\n\");\n\n\tif (!adap->dev.parent)\n\t\treturn;\n\n\tadev = ACPI_COMPANION(adap->dev.parent);\n\tif (!adev)\n\t\treturn;\n\n\tacpi_dev_clear_dependencies(adev);\n}\n\nstatic const struct acpi_device_id i2c_acpi_force_400khz_device_ids[] = {\n\t \n\t{ \"MSSL1680\", 0 },\n\t{}\n};\n\nstatic acpi_status i2c_acpi_lookup_speed(acpi_handle handle, u32 level,\n\t\t\t\t\t   void *data, void **return_value)\n{\n\tstruct i2c_acpi_lookup *lookup = data;\n\tstruct acpi_device *adev = acpi_fetch_acpi_dev(handle);\n\n\tif (!adev || i2c_acpi_do_lookup(adev, lookup))\n\t\treturn AE_OK;\n\n\tif (lookup->search_handle != lookup->adapter_handle)\n\t\treturn AE_OK;\n\n\tif (lookup->speed <= lookup->min_speed)\n\t\tlookup->min_speed = lookup->speed;\n\n\tif (acpi_match_device_ids(adev, i2c_acpi_force_400khz_device_ids) == 0)\n\t\tlookup->force_speed = I2C_MAX_FAST_MODE_FREQ;\n\n\treturn AE_OK;\n}\n\n \nu32 i2c_acpi_find_bus_speed(struct device *dev)\n{\n\tstruct i2c_acpi_lookup lookup;\n\tstruct i2c_board_info dummy;\n\tacpi_status status;\n\n\tif (!has_acpi_companion(dev))\n\t\treturn 0;\n\n\tmemset(&lookup, 0, sizeof(lookup));\n\tlookup.search_handle = ACPI_HANDLE(dev);\n\tlookup.min_speed = UINT_MAX;\n\tlookup.info = &dummy;\n\tlookup.index = -1;\n\n\tstatus = acpi_walk_namespace(ACPI_TYPE_DEVICE, ACPI_ROOT_OBJECT,\n\t\t\t\t     I2C_ACPI_MAX_SCAN_DEPTH,\n\t\t\t\t     i2c_acpi_lookup_speed, NULL,\n\t\t\t\t     &lookup, NULL);\n\n\tif (ACPI_FAILURE(status)) {\n\t\tdev_warn(dev, \"unable to find I2C bus speed from ACPI\\n\");\n\t\treturn 0;\n\t}\n\n\tif (lookup.force_speed) {\n\t\tif (lookup.force_speed != lookup.min_speed)\n\t\t\tdev_warn(dev, FW_BUG \"DSDT uses known not-working I2C bus speed %d, forcing it to %d\\n\",\n\t\t\t\t lookup.min_speed, lookup.force_speed);\n\t\treturn lookup.force_speed;\n\t} else if (lookup.min_speed != UINT_MAX) {\n\t\treturn lookup.min_speed;\n\t} else {\n\t\treturn 0;\n\t}\n}\nEXPORT_SYMBOL_GPL(i2c_acpi_find_bus_speed);\n\nstruct i2c_adapter *i2c_acpi_find_adapter_by_handle(acpi_handle handle)\n{\n\tstruct i2c_adapter *adapter;\n\tstruct device *dev;\n\n\tdev = bus_find_device(&i2c_bus_type, NULL, handle, device_match_acpi_handle);\n\tif (!dev)\n\t\treturn NULL;\n\n\tadapter = i2c_verify_adapter(dev);\n\tif (!adapter)\n\t\tput_device(dev);\n\n\treturn adapter;\n}\nEXPORT_SYMBOL_GPL(i2c_acpi_find_adapter_by_handle);\n\nstatic struct i2c_client *i2c_acpi_find_client_by_adev(struct acpi_device *adev)\n{\n\treturn i2c_find_device_by_fwnode(acpi_fwnode_handle(adev));\n}\n\nstatic int i2c_acpi_notify(struct notifier_block *nb, unsigned long value,\n\t\t\t   void *arg)\n{\n\tstruct acpi_device *adev = arg;\n\tstruct i2c_board_info info;\n\tacpi_handle adapter_handle;\n\tstruct i2c_adapter *adapter;\n\tstruct i2c_client *client;\n\n\tswitch (value) {\n\tcase ACPI_RECONFIG_DEVICE_ADD:\n\t\tif (i2c_acpi_get_info(adev, &info, NULL, &adapter_handle))\n\t\t\tbreak;\n\n\t\tadapter = i2c_acpi_find_adapter_by_handle(adapter_handle);\n\t\tif (!adapter)\n\t\t\tbreak;\n\n\t\ti2c_acpi_register_device(adapter, adev, &info);\n\t\tput_device(&adapter->dev);\n\t\tbreak;\n\tcase ACPI_RECONFIG_DEVICE_REMOVE:\n\t\tif (!acpi_device_enumerated(adev))\n\t\t\tbreak;\n\n\t\tclient = i2c_acpi_find_client_by_adev(adev);\n\t\tif (!client)\n\t\t\tbreak;\n\n\t\ti2c_unregister_device(client);\n\t\tput_device(&client->dev);\n\t\tbreak;\n\t}\n\n\treturn NOTIFY_OK;\n}\n\nstruct notifier_block i2c_acpi_notifier = {\n\t.notifier_call = i2c_acpi_notify,\n};\n\n \nstruct i2c_client *i2c_acpi_new_device_by_fwnode(struct fwnode_handle *fwnode,\n\t\t\t\t\t\t int index,\n\t\t\t\t\t\t struct i2c_board_info *info)\n{\n\tstruct i2c_acpi_lookup lookup;\n\tstruct i2c_adapter *adapter;\n\tstruct acpi_device *adev;\n\tLIST_HEAD(resource_list);\n\tint ret;\n\n\tadev = to_acpi_device_node(fwnode);\n\tif (!adev)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tmemset(&lookup, 0, sizeof(lookup));\n\tlookup.info = info;\n\tlookup.device_handle = acpi_device_handle(adev);\n\tlookup.index = index;\n\n\tret = acpi_dev_get_resources(adev, &resource_list,\n\t\t\t\t     i2c_acpi_fill_info, &lookup);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\n\tacpi_dev_free_resource_list(&resource_list);\n\n\tif (!info->addr)\n\t\treturn ERR_PTR(-EADDRNOTAVAIL);\n\n\tadapter = i2c_acpi_find_adapter_by_handle(lookup.adapter_handle);\n\tif (!adapter)\n\t\treturn ERR_PTR(-EPROBE_DEFER);\n\n\treturn i2c_new_client_device(adapter, info);\n}\nEXPORT_SYMBOL_GPL(i2c_acpi_new_device_by_fwnode);\n\nbool i2c_acpi_waive_d0_probe(struct device *dev)\n{\n\tstruct i2c_driver *driver = to_i2c_driver(dev->driver);\n\tstruct acpi_device *adev = ACPI_COMPANION(dev);\n\n\treturn driver->flags & I2C_DRV_ACPI_WAIVE_D0_PROBE &&\n\t\tadev && adev->power.state_for_enumeration >= adev->power.state;\n}\nEXPORT_SYMBOL_GPL(i2c_acpi_waive_d0_probe);\n\n#ifdef CONFIG_ACPI_I2C_OPREGION\nstatic int acpi_gsb_i2c_read_bytes(struct i2c_client *client,\n\t\tu8 cmd, u8 *data, u8 data_len)\n{\n\n\tstruct i2c_msg msgs[2];\n\tint ret;\n\tu8 *buffer;\n\n\tbuffer = kzalloc(data_len, GFP_KERNEL);\n\tif (!buffer)\n\t\treturn AE_NO_MEMORY;\n\n\tmsgs[0].addr = client->addr;\n\tmsgs[0].flags = client->flags;\n\tmsgs[0].len = 1;\n\tmsgs[0].buf = &cmd;\n\n\tmsgs[1].addr = client->addr;\n\tmsgs[1].flags = client->flags | I2C_M_RD;\n\tmsgs[1].len = data_len;\n\tmsgs[1].buf = buffer;\n\n\tret = i2c_transfer(client->adapter, msgs, ARRAY_SIZE(msgs));\n\tif (ret < 0) {\n\t\t \n\t\tif (ret == -EREMOTEIO)\n\t\t\tdev_dbg(&client->adapter->dev, \"i2c read %d bytes from client@%#x starting at reg %#x failed, error: %d\\n\",\n\t\t\t\tdata_len, client->addr, cmd, ret);\n\t\telse\n\t\t\tdev_err(&client->adapter->dev, \"i2c read %d bytes from client@%#x starting at reg %#x failed, error: %d\\n\",\n\t\t\t\tdata_len, client->addr, cmd, ret);\n\t \n\t} else if (ret == 2) {\n\t\tmemcpy(data, buffer, data_len);\n\t\tret = 0;\n\t} else {\n\t\tret = -EIO;\n\t}\n\n\tkfree(buffer);\n\treturn ret;\n}\n\nstatic int acpi_gsb_i2c_write_bytes(struct i2c_client *client,\n\t\tu8 cmd, u8 *data, u8 data_len)\n{\n\n\tstruct i2c_msg msgs[1];\n\tu8 *buffer;\n\tint ret = AE_OK;\n\n\tbuffer = kzalloc(data_len + 1, GFP_KERNEL);\n\tif (!buffer)\n\t\treturn AE_NO_MEMORY;\n\n\tbuffer[0] = cmd;\n\tmemcpy(buffer + 1, data, data_len);\n\n\tmsgs[0].addr = client->addr;\n\tmsgs[0].flags = client->flags;\n\tmsgs[0].len = data_len + 1;\n\tmsgs[0].buf = buffer;\n\n\tret = i2c_transfer(client->adapter, msgs, ARRAY_SIZE(msgs));\n\n\tkfree(buffer);\n\n\tif (ret < 0) {\n\t\tdev_err(&client->adapter->dev, \"i2c write failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\treturn (ret == 1) ? 0 : -EIO;\n}\n\nstatic acpi_status\ni2c_acpi_space_handler(u32 function, acpi_physical_address command,\n\t\t\tu32 bits, u64 *value64,\n\t\t\tvoid *handler_context, void *region_context)\n{\n\tstruct gsb_buffer *gsb = (struct gsb_buffer *)value64;\n\tstruct i2c_acpi_handler_data *data = handler_context;\n\tstruct acpi_connection_info *info = &data->info;\n\tstruct acpi_resource_i2c_serialbus *sb;\n\tstruct i2c_adapter *adapter = data->adapter;\n\tstruct i2c_client *client;\n\tstruct acpi_resource *ares;\n\tu32 accessor_type = function >> 16;\n\tu8 action = function & ACPI_IO_MASK;\n\tacpi_status ret;\n\tint status;\n\n\tret = acpi_buffer_to_resource(info->connection, info->length, &ares);\n\tif (ACPI_FAILURE(ret))\n\t\treturn ret;\n\n\tclient = kzalloc(sizeof(*client), GFP_KERNEL);\n\tif (!client) {\n\t\tret = AE_NO_MEMORY;\n\t\tgoto err;\n\t}\n\n\tif (!value64 || !i2c_acpi_get_i2c_resource(ares, &sb)) {\n\t\tret = AE_BAD_PARAMETER;\n\t\tgoto err;\n\t}\n\n\tclient->adapter = adapter;\n\tclient->addr = sb->slave_address;\n\n\tif (sb->access_mode == ACPI_I2C_10BIT_MODE)\n\t\tclient->flags |= I2C_CLIENT_TEN;\n\n\tswitch (accessor_type) {\n\tcase ACPI_GSB_ACCESS_ATTRIB_SEND_RCV:\n\t\tif (action == ACPI_READ) {\n\t\t\tstatus = i2c_smbus_read_byte(client);\n\t\t\tif (status >= 0) {\n\t\t\t\tgsb->bdata = status;\n\t\t\t\tstatus = 0;\n\t\t\t}\n\t\t} else {\n\t\t\tstatus = i2c_smbus_write_byte(client, gsb->bdata);\n\t\t}\n\t\tbreak;\n\n\tcase ACPI_GSB_ACCESS_ATTRIB_BYTE:\n\t\tif (action == ACPI_READ) {\n\t\t\tstatus = i2c_smbus_read_byte_data(client, command);\n\t\t\tif (status >= 0) {\n\t\t\t\tgsb->bdata = status;\n\t\t\t\tstatus = 0;\n\t\t\t}\n\t\t} else {\n\t\t\tstatus = i2c_smbus_write_byte_data(client, command,\n\t\t\t\t\tgsb->bdata);\n\t\t}\n\t\tbreak;\n\n\tcase ACPI_GSB_ACCESS_ATTRIB_WORD:\n\t\tif (action == ACPI_READ) {\n\t\t\tstatus = i2c_smbus_read_word_data(client, command);\n\t\t\tif (status >= 0) {\n\t\t\t\tgsb->wdata = status;\n\t\t\t\tstatus = 0;\n\t\t\t}\n\t\t} else {\n\t\t\tstatus = i2c_smbus_write_word_data(client, command,\n\t\t\t\t\tgsb->wdata);\n\t\t}\n\t\tbreak;\n\n\tcase ACPI_GSB_ACCESS_ATTRIB_BLOCK:\n\t\tif (action == ACPI_READ) {\n\t\t\tstatus = i2c_smbus_read_block_data(client, command,\n\t\t\t\t\tgsb->data);\n\t\t\tif (status >= 0) {\n\t\t\t\tgsb->len = status;\n\t\t\t\tstatus = 0;\n\t\t\t}\n\t\t} else {\n\t\t\tstatus = i2c_smbus_write_block_data(client, command,\n\t\t\t\t\tgsb->len, gsb->data);\n\t\t}\n\t\tbreak;\n\n\tcase ACPI_GSB_ACCESS_ATTRIB_MULTIBYTE:\n\t\tif (action == ACPI_READ) {\n\t\t\tstatus = acpi_gsb_i2c_read_bytes(client, command,\n\t\t\t\t\tgsb->data, info->access_length);\n\t\t} else {\n\t\t\tstatus = acpi_gsb_i2c_write_bytes(client, command,\n\t\t\t\t\tgsb->data, info->access_length);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tdev_warn(&adapter->dev, \"protocol 0x%02x not supported for client 0x%02x\\n\",\n\t\t\t accessor_type, client->addr);\n\t\tret = AE_BAD_PARAMETER;\n\t\tgoto err;\n\t}\n\n\tgsb->status = status;\n\n err:\n\tkfree(client);\n\tACPI_FREE(ares);\n\treturn ret;\n}\n\n\nint i2c_acpi_install_space_handler(struct i2c_adapter *adapter)\n{\n\tacpi_handle handle;\n\tstruct i2c_acpi_handler_data *data;\n\tacpi_status status;\n\n\tif (!adapter->dev.parent)\n\t\treturn -ENODEV;\n\n\thandle = ACPI_HANDLE(adapter->dev.parent);\n\n\tif (!handle)\n\t\treturn -ENODEV;\n\n\tdata = kzalloc(sizeof(struct i2c_acpi_handler_data),\n\t\t\t    GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->adapter = adapter;\n\tstatus = acpi_bus_attach_private_data(handle, (void *)data);\n\tif (ACPI_FAILURE(status)) {\n\t\tkfree(data);\n\t\treturn -ENOMEM;\n\t}\n\n\tstatus = acpi_install_address_space_handler(handle,\n\t\t\t\tACPI_ADR_SPACE_GSBUS,\n\t\t\t\t&i2c_acpi_space_handler,\n\t\t\t\tNULL,\n\t\t\t\tdata);\n\tif (ACPI_FAILURE(status)) {\n\t\tdev_err(&adapter->dev, \"Error installing i2c space handler\\n\");\n\t\tacpi_bus_detach_private_data(handle);\n\t\tkfree(data);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nvoid i2c_acpi_remove_space_handler(struct i2c_adapter *adapter)\n{\n\tacpi_handle handle;\n\tstruct i2c_acpi_handler_data *data;\n\tacpi_status status;\n\n\tif (!adapter->dev.parent)\n\t\treturn;\n\n\thandle = ACPI_HANDLE(adapter->dev.parent);\n\n\tif (!handle)\n\t\treturn;\n\n\tacpi_remove_address_space_handler(handle,\n\t\t\t\tACPI_ADR_SPACE_GSBUS,\n\t\t\t\t&i2c_acpi_space_handler);\n\n\tstatus = acpi_bus_get_private_data(handle, (void **)&data);\n\tif (ACPI_SUCCESS(status))\n\t\tkfree(data);\n\n\tacpi_bus_detach_private_data(handle);\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}