{
  "module_name": "i2c-atr.c",
  "hash_id": "1ade777b795ab96cc5496a1b2ce1ac69726dcb045bfaa42d7a2be77daa8f21e8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/i2c-atr.c",
  "human_readable_source": "\n \n\n#include <linux/fwnode.h>\n#include <linux/i2c-atr.h>\n#include <linux/i2c.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n\n#define ATR_MAX_ADAPTERS 100\t \n#define ATR_MAX_SYMLINK_LEN 11\t \n\n \nstruct i2c_atr_alias_pair {\n\tstruct list_head node;\n\tconst struct i2c_client *client;\n\tu16 alias;\n};\n\n \nstruct i2c_atr_chan {\n\tstruct i2c_adapter adap;\n\tstruct i2c_atr *atr;\n\tu32 chan_id;\n\n\tstruct list_head alias_list;\n\n\t \n\tstruct mutex orig_addrs_lock;\n\tu16 *orig_addrs;\n\tunsigned int orig_addrs_size;\n};\n\n \nstruct i2c_atr {\n\tstruct i2c_adapter *parent;\n\tstruct device *dev;\n\tconst struct i2c_atr_ops *ops;\n\n\tvoid *priv;\n\n\tstruct i2c_algorithm algo;\n\t \n\tstruct mutex lock;\n\tint max_adapters;\n\n\tsize_t num_aliases;\n\tconst u16 *aliases;\n\t \n\tspinlock_t alias_mask_lock;\n\tunsigned long *alias_use_mask;\n\n\tstruct notifier_block i2c_nb;\n\n\tstruct i2c_adapter *adapter[];\n};\n\nstatic struct i2c_atr_alias_pair *\ni2c_atr_find_mapping_by_client(const struct list_head *list,\n\t\t\t       const struct i2c_client *client)\n{\n\tstruct i2c_atr_alias_pair *c2a;\n\n\tlist_for_each_entry(c2a, list, node) {\n\t\tif (c2a->client == client)\n\t\t\treturn c2a;\n\t}\n\n\treturn NULL;\n}\n\nstatic struct i2c_atr_alias_pair *\ni2c_atr_find_mapping_by_addr(const struct list_head *list, u16 phys_addr)\n{\n\tstruct i2c_atr_alias_pair *c2a;\n\n\tlist_for_each_entry(c2a, list, node) {\n\t\tif (c2a->client->addr == phys_addr)\n\t\t\treturn c2a;\n\t}\n\n\treturn NULL;\n}\n\n \nstatic int i2c_atr_map_msgs(struct i2c_atr_chan *chan, struct i2c_msg *msgs,\n\t\t\t    int num)\n{\n\tstruct i2c_atr *atr = chan->atr;\n\tstatic struct i2c_atr_alias_pair *c2a;\n\tint i;\n\n\t \n\tif (unlikely(chan->orig_addrs_size < num)) {\n\t\tu16 *new_buf;\n\n\t\t \n\t\tnew_buf = kmalloc_array(num, sizeof(*new_buf), GFP_KERNEL);\n\t\tif (!new_buf)\n\t\t\treturn -ENOMEM;\n\n\t\tkfree(chan->orig_addrs);\n\t\tchan->orig_addrs = new_buf;\n\t\tchan->orig_addrs_size = num;\n\t}\n\n\tfor (i = 0; i < num; i++) {\n\t\tchan->orig_addrs[i] = msgs[i].addr;\n\n\t\tc2a = i2c_atr_find_mapping_by_addr(&chan->alias_list,\n\t\t\t\t\t\t   msgs[i].addr);\n\t\tif (!c2a) {\n\t\t\tdev_err(atr->dev, \"client 0x%02x not mapped!\\n\",\n\t\t\t\tmsgs[i].addr);\n\n\t\t\twhile (i--)\n\t\t\t\tmsgs[i].addr = chan->orig_addrs[i];\n\n\t\t\treturn -ENXIO;\n\t\t}\n\n\t\tmsgs[i].addr = c2a->alias;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void i2c_atr_unmap_msgs(struct i2c_atr_chan *chan, struct i2c_msg *msgs,\n\t\t\t       int num)\n{\n\tint i;\n\n\tfor (i = 0; i < num; i++)\n\t\tmsgs[i].addr = chan->orig_addrs[i];\n}\n\nstatic int i2c_atr_master_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs,\n\t\t\t       int num)\n{\n\tstruct i2c_atr_chan *chan = adap->algo_data;\n\tstruct i2c_atr *atr = chan->atr;\n\tstruct i2c_adapter *parent = atr->parent;\n\tint ret;\n\n\t \n\tmutex_lock(&chan->orig_addrs_lock);\n\n\tret = i2c_atr_map_msgs(chan, msgs, num);\n\tif (ret < 0)\n\t\tgoto err_unlock;\n\n\t \n\tret = i2c_transfer(parent, msgs, num);\n\n\t \n\ti2c_atr_unmap_msgs(chan, msgs, num);\n\nerr_unlock:\n\tmutex_unlock(&chan->orig_addrs_lock);\n\n\treturn ret;\n}\n\nstatic int i2c_atr_smbus_xfer(struct i2c_adapter *adap, u16 addr,\n\t\t\t      unsigned short flags, char read_write, u8 command,\n\t\t\t      int size, union i2c_smbus_data *data)\n{\n\tstruct i2c_atr_chan *chan = adap->algo_data;\n\tstruct i2c_atr *atr = chan->atr;\n\tstruct i2c_adapter *parent = atr->parent;\n\tstruct i2c_atr_alias_pair *c2a;\n\n\tc2a = i2c_atr_find_mapping_by_addr(&chan->alias_list, addr);\n\tif (!c2a) {\n\t\tdev_err(atr->dev, \"client 0x%02x not mapped!\\n\", addr);\n\t\treturn -ENXIO;\n\t}\n\n\treturn i2c_smbus_xfer(parent, c2a->alias, flags, read_write, command,\n\t\t\t      size, data);\n}\n\nstatic u32 i2c_atr_functionality(struct i2c_adapter *adap)\n{\n\tstruct i2c_atr_chan *chan = adap->algo_data;\n\tstruct i2c_adapter *parent = chan->atr->parent;\n\n\treturn parent->algo->functionality(parent);\n}\n\nstatic void i2c_atr_lock_bus(struct i2c_adapter *adapter, unsigned int flags)\n{\n\tstruct i2c_atr_chan *chan = adapter->algo_data;\n\tstruct i2c_atr *atr = chan->atr;\n\n\tmutex_lock(&atr->lock);\n}\n\nstatic int i2c_atr_trylock_bus(struct i2c_adapter *adapter, unsigned int flags)\n{\n\tstruct i2c_atr_chan *chan = adapter->algo_data;\n\tstruct i2c_atr *atr = chan->atr;\n\n\treturn mutex_trylock(&atr->lock);\n}\n\nstatic void i2c_atr_unlock_bus(struct i2c_adapter *adapter, unsigned int flags)\n{\n\tstruct i2c_atr_chan *chan = adapter->algo_data;\n\tstruct i2c_atr *atr = chan->atr;\n\n\tmutex_unlock(&atr->lock);\n}\n\nstatic const struct i2c_lock_operations i2c_atr_lock_ops = {\n\t.lock_bus =    i2c_atr_lock_bus,\n\t.trylock_bus = i2c_atr_trylock_bus,\n\t.unlock_bus =  i2c_atr_unlock_bus,\n};\n\nstatic int i2c_atr_reserve_alias(struct i2c_atr *atr)\n{\n\tunsigned long idx;\n\n\tspin_lock(&atr->alias_mask_lock);\n\n\tidx = find_first_zero_bit(atr->alias_use_mask, atr->num_aliases);\n\tif (idx >= atr->num_aliases) {\n\t\tspin_unlock(&atr->alias_mask_lock);\n\t\tdev_err(atr->dev, \"failed to find a free alias\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tset_bit(idx, atr->alias_use_mask);\n\n\tspin_unlock(&atr->alias_mask_lock);\n\n\treturn atr->aliases[idx];\n}\n\nstatic void i2c_atr_release_alias(struct i2c_atr *atr, u16 alias)\n{\n\tunsigned int idx;\n\n\tspin_lock(&atr->alias_mask_lock);\n\n\tfor (idx = 0; idx < atr->num_aliases; ++idx) {\n\t\tif (atr->aliases[idx] == alias) {\n\t\t\tclear_bit(idx, atr->alias_use_mask);\n\t\t\tspin_unlock(&atr->alias_mask_lock);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tspin_unlock(&atr->alias_mask_lock);\n\n\t  \n\tdev_warn(atr->dev, \"Unable to find mapped alias\\n\");\n}\n\nstatic int i2c_atr_attach_client(struct i2c_adapter *adapter,\n\t\t\t\t const struct i2c_client *client)\n{\n\tstruct i2c_atr_chan *chan = adapter->algo_data;\n\tstruct i2c_atr *atr = chan->atr;\n\tstruct i2c_atr_alias_pair *c2a;\n\tu16 alias;\n\tint ret;\n\n\tret = i2c_atr_reserve_alias(atr);\n\tif (ret < 0)\n\t\treturn ret;\n\n\talias = ret;\n\n\tc2a = kzalloc(sizeof(*c2a), GFP_KERNEL);\n\tif (!c2a) {\n\t\tret = -ENOMEM;\n\t\tgoto err_release_alias;\n\t}\n\n\tret = atr->ops->attach_client(atr, chan->chan_id, client, alias);\n\tif (ret)\n\t\tgoto err_free;\n\n\tdev_dbg(atr->dev, \"chan%u: client 0x%02x mapped at alias 0x%02x (%s)\\n\",\n\t\tchan->chan_id, client->addr, alias, client->name);\n\n\tc2a->client = client;\n\tc2a->alias = alias;\n\tlist_add(&c2a->node, &chan->alias_list);\n\n\treturn 0;\n\nerr_free:\n\tkfree(c2a);\nerr_release_alias:\n\ti2c_atr_release_alias(atr, alias);\n\n\treturn ret;\n}\n\nstatic void i2c_atr_detach_client(struct i2c_adapter *adapter,\n\t\t\t\t  const struct i2c_client *client)\n{\n\tstruct i2c_atr_chan *chan = adapter->algo_data;\n\tstruct i2c_atr *atr = chan->atr;\n\tstruct i2c_atr_alias_pair *c2a;\n\n\tatr->ops->detach_client(atr, chan->chan_id, client);\n\n\tc2a = i2c_atr_find_mapping_by_client(&chan->alias_list, client);\n\tif (!c2a) {\n\t\t  \n\t\tdev_warn(atr->dev, \"Unable to find address mapping\\n\");\n\t\treturn;\n\t}\n\n\ti2c_atr_release_alias(atr, c2a->alias);\n\n\tdev_dbg(atr->dev,\n\t\t\"chan%u: client 0x%02x unmapped from alias 0x%02x (%s)\\n\",\n\t\tchan->chan_id, client->addr, c2a->alias, client->name);\n\n\tlist_del(&c2a->node);\n\tkfree(c2a);\n}\n\nstatic int i2c_atr_bus_notifier_call(struct notifier_block *nb,\n\t\t\t\t     unsigned long event, void *device)\n{\n\tstruct i2c_atr *atr = container_of(nb, struct i2c_atr, i2c_nb);\n\tstruct device *dev = device;\n\tstruct i2c_client *client;\n\tu32 chan_id;\n\tint ret;\n\n\tclient = i2c_verify_client(dev);\n\tif (!client)\n\t\treturn NOTIFY_DONE;\n\n\t \n\tfor (chan_id = 0; chan_id < atr->max_adapters; ++chan_id) {\n\t\tif (client->adapter == atr->adapter[chan_id])\n\t\t\tbreak;\n\t}\n\n\tif (chan_id == atr->max_adapters)\n\t\treturn NOTIFY_DONE;\n\n\tswitch (event) {\n\tcase BUS_NOTIFY_ADD_DEVICE:\n\t\tret = i2c_atr_attach_client(client->adapter, client);\n\t\tif (ret)\n\t\t\tdev_err(atr->dev,\n\t\t\t\t\"Failed to attach remote client '%s': %d\\n\",\n\t\t\t\tdev_name(dev), ret);\n\t\tbreak;\n\n\tcase BUS_NOTIFY_DEL_DEVICE:\n\t\ti2c_atr_detach_client(client->adapter, client);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn NOTIFY_DONE;\n}\n\nstatic int i2c_atr_parse_alias_pool(struct i2c_atr *atr)\n{\n\tstruct device *dev = atr->dev;\n\tunsigned long *alias_use_mask;\n\tsize_t num_aliases;\n\tunsigned int i;\n\tu32 *aliases32;\n\tu16 *aliases16;\n\tint ret;\n\n\tret = fwnode_property_count_u32(dev_fwnode(dev), \"i2c-alias-pool\");\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to count 'i2c-alias-pool' property: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tnum_aliases = ret;\n\n\tif (!num_aliases)\n\t\treturn 0;\n\n\taliases32 = kcalloc(num_aliases, sizeof(*aliases32), GFP_KERNEL);\n\tif (!aliases32)\n\t\treturn -ENOMEM;\n\n\tret = fwnode_property_read_u32_array(dev_fwnode(dev), \"i2c-alias-pool\",\n\t\t\t\t\t     aliases32, num_aliases);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to read 'i2c-alias-pool' property: %d\\n\",\n\t\t\tret);\n\t\tgoto err_free_aliases32;\n\t}\n\n\taliases16 = kcalloc(num_aliases, sizeof(*aliases16), GFP_KERNEL);\n\tif (!aliases16) {\n\t\tret = -ENOMEM;\n\t\tgoto err_free_aliases32;\n\t}\n\n\tfor (i = 0; i < num_aliases; i++) {\n\t\tif (!(aliases32[i] & 0xffff0000)) {\n\t\t\taliases16[i] = aliases32[i];\n\t\t\tcontinue;\n\t\t}\n\n\t\tdev_err(dev, \"Failed to parse 'i2c-alias-pool' property: I2C flags are not supported\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err_free_aliases16;\n\t}\n\n\talias_use_mask = bitmap_zalloc(num_aliases, GFP_KERNEL);\n\tif (!alias_use_mask) {\n\t\tret = -ENOMEM;\n\t\tgoto err_free_aliases16;\n\t}\n\n\tkfree(aliases32);\n\n\tatr->num_aliases = num_aliases;\n\tatr->aliases = aliases16;\n\tatr->alias_use_mask = alias_use_mask;\n\n\tdev_dbg(dev, \"i2c-alias-pool has %zu aliases\", atr->num_aliases);\n\n\treturn 0;\n\nerr_free_aliases16:\n\tkfree(aliases16);\nerr_free_aliases32:\n\tkfree(aliases32);\n\treturn ret;\n}\n\nstruct i2c_atr *i2c_atr_new(struct i2c_adapter *parent, struct device *dev,\n\t\t\t    const struct i2c_atr_ops *ops, int max_adapters)\n{\n\tstruct i2c_atr *atr;\n\tint ret;\n\n\tif (max_adapters > ATR_MAX_ADAPTERS)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (!ops || !ops->attach_client || !ops->detach_client)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tatr = kzalloc(struct_size(atr, adapter, max_adapters), GFP_KERNEL);\n\tif (!atr)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmutex_init(&atr->lock);\n\tspin_lock_init(&atr->alias_mask_lock);\n\n\tatr->parent = parent;\n\tatr->dev = dev;\n\tatr->ops = ops;\n\tatr->max_adapters = max_adapters;\n\n\tif (parent->algo->master_xfer)\n\t\tatr->algo.master_xfer = i2c_atr_master_xfer;\n\tif (parent->algo->smbus_xfer)\n\t\tatr->algo.smbus_xfer = i2c_atr_smbus_xfer;\n\tatr->algo.functionality = i2c_atr_functionality;\n\n\tret = i2c_atr_parse_alias_pool(atr);\n\tif (ret)\n\t\tgoto err_destroy_mutex;\n\n\tatr->i2c_nb.notifier_call = i2c_atr_bus_notifier_call;\n\tret = bus_register_notifier(&i2c_bus_type, &atr->i2c_nb);\n\tif (ret)\n\t\tgoto err_free_aliases;\n\n\treturn atr;\n\nerr_free_aliases:\n\tbitmap_free(atr->alias_use_mask);\n\tkfree(atr->aliases);\nerr_destroy_mutex:\n\tmutex_destroy(&atr->lock);\n\tkfree(atr);\n\n\treturn ERR_PTR(ret);\n}\nEXPORT_SYMBOL_NS_GPL(i2c_atr_new, I2C_ATR);\n\nvoid i2c_atr_delete(struct i2c_atr *atr)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < atr->max_adapters; ++i)\n\t\tWARN_ON(atr->adapter[i]);\n\n\tbus_unregister_notifier(&i2c_bus_type, &atr->i2c_nb);\n\tbitmap_free(atr->alias_use_mask);\n\tkfree(atr->aliases);\n\tmutex_destroy(&atr->lock);\n\tkfree(atr);\n}\nEXPORT_SYMBOL_NS_GPL(i2c_atr_delete, I2C_ATR);\n\nint i2c_atr_add_adapter(struct i2c_atr *atr, u32 chan_id,\n\t\t\tstruct device *adapter_parent,\n\t\t\tstruct fwnode_handle *bus_handle)\n{\n\tstruct i2c_adapter *parent = atr->parent;\n\tstruct device *dev = atr->dev;\n\tstruct i2c_atr_chan *chan;\n\tchar symlink_name[ATR_MAX_SYMLINK_LEN];\n\tint ret;\n\n\tif (chan_id >= atr->max_adapters) {\n\t\tdev_err(dev, \"No room for more i2c-atr adapters\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (atr->adapter[chan_id]) {\n\t\tdev_err(dev, \"Adapter %d already present\\n\", chan_id);\n\t\treturn -EEXIST;\n\t}\n\n\tchan = kzalloc(sizeof(*chan), GFP_KERNEL);\n\tif (!chan)\n\t\treturn -ENOMEM;\n\n\tif (!adapter_parent)\n\t\tadapter_parent = dev;\n\n\tchan->atr = atr;\n\tchan->chan_id = chan_id;\n\tINIT_LIST_HEAD(&chan->alias_list);\n\tmutex_init(&chan->orig_addrs_lock);\n\n\tsnprintf(chan->adap.name, sizeof(chan->adap.name), \"i2c-%d-atr-%d\",\n\t\t i2c_adapter_id(parent), chan_id);\n\tchan->adap.owner = THIS_MODULE;\n\tchan->adap.algo = &atr->algo;\n\tchan->adap.algo_data = chan;\n\tchan->adap.dev.parent = adapter_parent;\n\tchan->adap.retries = parent->retries;\n\tchan->adap.timeout = parent->timeout;\n\tchan->adap.quirks = parent->quirks;\n\tchan->adap.lock_ops = &i2c_atr_lock_ops;\n\n\tif (bus_handle) {\n\t\tdevice_set_node(&chan->adap.dev, fwnode_handle_get(bus_handle));\n\t} else {\n\t\tstruct fwnode_handle *atr_node;\n\t\tstruct fwnode_handle *child;\n\t\tu32 reg;\n\n\t\tatr_node = device_get_named_child_node(dev, \"i2c-atr\");\n\n\t\tfwnode_for_each_child_node(atr_node, child) {\n\t\t\tret = fwnode_property_read_u32(child, \"reg\", &reg);\n\t\t\tif (ret)\n\t\t\t\tcontinue;\n\t\t\tif (chan_id == reg)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tdevice_set_node(&chan->adap.dev, child);\n\t\tfwnode_handle_put(atr_node);\n\t}\n\n\tatr->adapter[chan_id] = &chan->adap;\n\n\tret = i2c_add_adapter(&chan->adap);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to add atr-adapter %u (error=%d)\\n\",\n\t\t\tchan_id, ret);\n\t\tgoto err_fwnode_put;\n\t}\n\n\tsnprintf(symlink_name, sizeof(symlink_name), \"channel-%u\",\n\t\t chan->chan_id);\n\n\tret = sysfs_create_link(&chan->adap.dev.kobj, &dev->kobj, \"atr_device\");\n\tif (ret)\n\t\tdev_warn(dev, \"can't create symlink to atr device\\n\");\n\tret = sysfs_create_link(&dev->kobj, &chan->adap.dev.kobj, symlink_name);\n\tif (ret)\n\t\tdev_warn(dev, \"can't create symlink for channel %u\\n\", chan_id);\n\n\tdev_dbg(dev, \"Added ATR child bus %d\\n\", i2c_adapter_id(&chan->adap));\n\n\treturn 0;\n\nerr_fwnode_put:\n\tfwnode_handle_put(dev_fwnode(&chan->adap.dev));\n\tmutex_destroy(&chan->orig_addrs_lock);\n\tkfree(chan);\n\treturn ret;\n}\nEXPORT_SYMBOL_NS_GPL(i2c_atr_add_adapter, I2C_ATR);\n\nvoid i2c_atr_del_adapter(struct i2c_atr *atr, u32 chan_id)\n{\n\tchar symlink_name[ATR_MAX_SYMLINK_LEN];\n\tstruct i2c_adapter *adap;\n\tstruct i2c_atr_chan *chan;\n\tstruct fwnode_handle *fwnode;\n\tstruct device *dev = atr->dev;\n\n\tadap = atr->adapter[chan_id];\n\tif (!adap)\n\t\treturn;\n\n\tchan = adap->algo_data;\n\tfwnode = dev_fwnode(&adap->dev);\n\n\tdev_dbg(dev, \"Removing ATR child bus %d\\n\", i2c_adapter_id(adap));\n\n\tsnprintf(symlink_name, sizeof(symlink_name), \"channel-%u\",\n\t\t chan->chan_id);\n\tsysfs_remove_link(&dev->kobj, symlink_name);\n\tsysfs_remove_link(&chan->adap.dev.kobj, \"atr_device\");\n\n\ti2c_del_adapter(adap);\n\n\tatr->adapter[chan_id] = NULL;\n\n\tfwnode_handle_put(fwnode);\n\tmutex_destroy(&chan->orig_addrs_lock);\n\tkfree(chan->orig_addrs);\n\tkfree(chan);\n}\nEXPORT_SYMBOL_NS_GPL(i2c_atr_del_adapter, I2C_ATR);\n\nvoid i2c_atr_set_driver_data(struct i2c_atr *atr, void *data)\n{\n\tatr->priv = data;\n}\nEXPORT_SYMBOL_NS_GPL(i2c_atr_set_driver_data, I2C_ATR);\n\nvoid *i2c_atr_get_driver_data(struct i2c_atr *atr)\n{\n\treturn atr->priv;\n}\nEXPORT_SYMBOL_NS_GPL(i2c_atr_get_driver_data, I2C_ATR);\n\nMODULE_AUTHOR(\"Luca Ceresoli <luca.ceresoli@bootlin.com>\");\nMODULE_AUTHOR(\"Tomi Valkeinen <tomi.valkeinen@ideasonboard.com>\");\nMODULE_DESCRIPTION(\"I2C Address Translator\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}