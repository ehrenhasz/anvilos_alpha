{
  "module_name": "i2c-core-of.c",
  "hash_id": "008ac5d82b58beca9899232633f4d2f17a1b159359a2b4361cbc41f534e303a9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/i2c-core-of.c",
  "human_readable_source": "\n \n\n#include <dt-bindings/i2c/i2c.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/i2c.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n#include <linux/sysfs.h>\n\n#include \"i2c-core.h\"\n\nint of_i2c_get_board_info(struct device *dev, struct device_node *node,\n\t\t\t  struct i2c_board_info *info)\n{\n\tu32 addr;\n\tint ret;\n\n\tmemset(info, 0, sizeof(*info));\n\n\tif (of_alias_from_compatible(node, info->type, sizeof(info->type)) < 0) {\n\t\tdev_err(dev, \"of_i2c: modalias failure on %pOF\\n\", node);\n\t\treturn -EINVAL;\n\t}\n\n\tret = of_property_read_u32(node, \"reg\", &addr);\n\tif (ret) {\n\t\tdev_err(dev, \"of_i2c: invalid reg on %pOF\\n\", node);\n\t\treturn ret;\n\t}\n\n\tif (addr & I2C_TEN_BIT_ADDRESS) {\n\t\taddr &= ~I2C_TEN_BIT_ADDRESS;\n\t\tinfo->flags |= I2C_CLIENT_TEN;\n\t}\n\n\tif (addr & I2C_OWN_SLAVE_ADDRESS) {\n\t\taddr &= ~I2C_OWN_SLAVE_ADDRESS;\n\t\tinfo->flags |= I2C_CLIENT_SLAVE;\n\t}\n\n\tinfo->addr = addr;\n\tinfo->of_node = node;\n\tinfo->fwnode = of_fwnode_handle(node);\n\n\tif (of_property_read_bool(node, \"host-notify\"))\n\t\tinfo->flags |= I2C_CLIENT_HOST_NOTIFY;\n\n\tif (of_property_read_bool(node, \"wakeup-source\"))\n\t\tinfo->flags |= I2C_CLIENT_WAKE;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(of_i2c_get_board_info);\n\nstatic struct i2c_client *of_i2c_register_device(struct i2c_adapter *adap,\n\t\t\t\t\t\t struct device_node *node)\n{\n\tstruct i2c_client *client;\n\tstruct i2c_board_info info;\n\tint ret;\n\n\tdev_dbg(&adap->dev, \"of_i2c: register %pOF\\n\", node);\n\n\tret = of_i2c_get_board_info(&adap->dev, node, &info);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tclient = i2c_new_client_device(adap, &info);\n\tif (IS_ERR(client))\n\t\tdev_err(&adap->dev, \"of_i2c: Failure registering %pOF\\n\", node);\n\n\treturn client;\n}\n\nvoid of_i2c_register_devices(struct i2c_adapter *adap)\n{\n\tstruct device_node *bus, *node;\n\tstruct i2c_client *client;\n\n\t \n\tif (!adap->dev.of_node)\n\t\treturn;\n\n\tdev_dbg(&adap->dev, \"of_i2c: walking child nodes\\n\");\n\n\tbus = of_get_child_by_name(adap->dev.of_node, \"i2c-bus\");\n\tif (!bus)\n\t\tbus = of_node_get(adap->dev.of_node);\n\n\tfor_each_available_child_of_node(bus, node) {\n\t\tif (of_node_test_and_set_flag(node, OF_POPULATED))\n\t\t\tcontinue;\n\n\t\tclient = of_i2c_register_device(adap, node);\n\t\tif (IS_ERR(client)) {\n\t\t\tdev_err(&adap->dev,\n\t\t\t\t \"Failed to create I2C device for %pOF\\n\",\n\t\t\t\t node);\n\t\t\tof_node_clear_flag(node, OF_POPULATED);\n\t\t}\n\t}\n\n\tof_node_put(bus);\n}\n\nstatic const struct of_device_id*\ni2c_of_match_device_sysfs(const struct of_device_id *matches,\n\t\t\t\t  struct i2c_client *client)\n{\n\tconst char *name;\n\n\tfor (; matches->compatible[0]; matches++) {\n\t\t \n\t\tif (sysfs_streq(client->name, matches->compatible))\n\t\t\treturn matches;\n\n\t\tname = strchr(matches->compatible, ',');\n\t\tif (!name)\n\t\t\tname = matches->compatible;\n\t\telse\n\t\t\tname++;\n\n\t\tif (sysfs_streq(client->name, name))\n\t\t\treturn matches;\n\t}\n\n\treturn NULL;\n}\n\nconst struct of_device_id\n*i2c_of_match_device(const struct of_device_id *matches,\n\t\t     struct i2c_client *client)\n{\n\tconst struct of_device_id *match;\n\n\tif (!(client && matches))\n\t\treturn NULL;\n\n\tmatch = of_match_device(matches, &client->dev);\n\tif (match)\n\t\treturn match;\n\n\treturn i2c_of_match_device_sysfs(matches, client);\n}\nEXPORT_SYMBOL_GPL(i2c_of_match_device);\n\n#if IS_ENABLED(CONFIG_OF_DYNAMIC)\nstatic int of_i2c_notify(struct notifier_block *nb, unsigned long action,\n\t\t\t void *arg)\n{\n\tstruct of_reconfig_data *rd = arg;\n\tstruct i2c_adapter *adap;\n\tstruct i2c_client *client;\n\n\tswitch (of_reconfig_get_state_change(action, rd)) {\n\tcase OF_RECONFIG_CHANGE_ADD:\n\t\tadap = of_find_i2c_adapter_by_node(rd->dn->parent);\n\t\tif (adap == NULL)\n\t\t\treturn NOTIFY_OK;\t \n\n\t\tif (of_node_test_and_set_flag(rd->dn, OF_POPULATED)) {\n\t\t\tput_device(&adap->dev);\n\t\t\treturn NOTIFY_OK;\n\t\t}\n\n\t\t \n\t\trd->dn->fwnode.flags &= ~FWNODE_FLAG_NOT_DEVICE;\n\t\tclient = of_i2c_register_device(adap, rd->dn);\n\t\tif (IS_ERR(client)) {\n\t\t\tdev_err(&adap->dev, \"failed to create client for '%pOF'\\n\",\n\t\t\t\t rd->dn);\n\t\t\tput_device(&adap->dev);\n\t\t\tof_node_clear_flag(rd->dn, OF_POPULATED);\n\t\t\treturn notifier_from_errno(PTR_ERR(client));\n\t\t}\n\t\tput_device(&adap->dev);\n\t\tbreak;\n\tcase OF_RECONFIG_CHANGE_REMOVE:\n\t\t \n\t\tif (!of_node_check_flag(rd->dn, OF_POPULATED))\n\t\t\treturn NOTIFY_OK;\n\n\t\t \n\t\tclient = of_find_i2c_device_by_node(rd->dn);\n\t\tif (client == NULL)\n\t\t\treturn NOTIFY_OK;\t \n\n\t\t \n\t\ti2c_unregister_device(client);\n\n\t\t \n\t\tput_device(&client->dev);\n\t\tbreak;\n\t}\n\n\treturn NOTIFY_OK;\n}\n\nstruct notifier_block i2c_of_notifier = {\n\t.notifier_call = of_i2c_notify,\n};\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}