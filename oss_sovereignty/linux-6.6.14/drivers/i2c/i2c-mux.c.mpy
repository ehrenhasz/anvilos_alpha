{
  "module_name": "i2c-mux.c",
  "hash_id": "5bc8a8d0d2b79f3ae24f2ea3136a4002c1a9a72c18c42d09763eef2c6d643960",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/i2c-mux.c",
  "human_readable_source": " \n\n#include <linux/acpi.h>\n#include <linux/i2c.h>\n#include <linux/i2c-mux.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n\n \nstruct i2c_mux_priv {\n\tstruct i2c_adapter adap;\n\tstruct i2c_algorithm algo;\n\tstruct i2c_mux_core *muxc;\n\tu32 chan_id;\n};\n\nstatic int __i2c_mux_master_xfer(struct i2c_adapter *adap,\n\t\t\t\t struct i2c_msg msgs[], int num)\n{\n\tstruct i2c_mux_priv *priv = adap->algo_data;\n\tstruct i2c_mux_core *muxc = priv->muxc;\n\tstruct i2c_adapter *parent = muxc->parent;\n\tint ret;\n\n\t \n\n\tret = muxc->select(muxc, priv->chan_id);\n\tif (ret >= 0)\n\t\tret = __i2c_transfer(parent, msgs, num);\n\tif (muxc->deselect)\n\t\tmuxc->deselect(muxc, priv->chan_id);\n\n\treturn ret;\n}\n\nstatic int i2c_mux_master_xfer(struct i2c_adapter *adap,\n\t\t\t       struct i2c_msg msgs[], int num)\n{\n\tstruct i2c_mux_priv *priv = adap->algo_data;\n\tstruct i2c_mux_core *muxc = priv->muxc;\n\tstruct i2c_adapter *parent = muxc->parent;\n\tint ret;\n\n\t \n\n\tret = muxc->select(muxc, priv->chan_id);\n\tif (ret >= 0)\n\t\tret = i2c_transfer(parent, msgs, num);\n\tif (muxc->deselect)\n\t\tmuxc->deselect(muxc, priv->chan_id);\n\n\treturn ret;\n}\n\nstatic int __i2c_mux_smbus_xfer(struct i2c_adapter *adap,\n\t\t\t\tu16 addr, unsigned short flags,\n\t\t\t\tchar read_write, u8 command,\n\t\t\t\tint size, union i2c_smbus_data *data)\n{\n\tstruct i2c_mux_priv *priv = adap->algo_data;\n\tstruct i2c_mux_core *muxc = priv->muxc;\n\tstruct i2c_adapter *parent = muxc->parent;\n\tint ret;\n\n\t \n\n\tret = muxc->select(muxc, priv->chan_id);\n\tif (ret >= 0)\n\t\tret = __i2c_smbus_xfer(parent, addr, flags,\n\t\t\t\t       read_write, command, size, data);\n\tif (muxc->deselect)\n\t\tmuxc->deselect(muxc, priv->chan_id);\n\n\treturn ret;\n}\n\nstatic int i2c_mux_smbus_xfer(struct i2c_adapter *adap,\n\t\t\t      u16 addr, unsigned short flags,\n\t\t\t      char read_write, u8 command,\n\t\t\t      int size, union i2c_smbus_data *data)\n{\n\tstruct i2c_mux_priv *priv = adap->algo_data;\n\tstruct i2c_mux_core *muxc = priv->muxc;\n\tstruct i2c_adapter *parent = muxc->parent;\n\tint ret;\n\n\t \n\n\tret = muxc->select(muxc, priv->chan_id);\n\tif (ret >= 0)\n\t\tret = i2c_smbus_xfer(parent, addr, flags,\n\t\t\t\t     read_write, command, size, data);\n\tif (muxc->deselect)\n\t\tmuxc->deselect(muxc, priv->chan_id);\n\n\treturn ret;\n}\n\n \nstatic u32 i2c_mux_functionality(struct i2c_adapter *adap)\n{\n\tstruct i2c_mux_priv *priv = adap->algo_data;\n\tstruct i2c_adapter *parent = priv->muxc->parent;\n\n\treturn parent->algo->functionality(parent);\n}\n\n \nstatic unsigned int i2c_mux_parent_classes(struct i2c_adapter *parent)\n{\n\tunsigned int class = 0;\n\n\tdo {\n\t\tclass |= parent->class;\n\t\tparent = i2c_parent_is_i2c_adapter(parent);\n\t} while (parent);\n\n\treturn class;\n}\n\nstatic void i2c_mux_lock_bus(struct i2c_adapter *adapter, unsigned int flags)\n{\n\tstruct i2c_mux_priv *priv = adapter->algo_data;\n\tstruct i2c_adapter *parent = priv->muxc->parent;\n\n\trt_mutex_lock_nested(&parent->mux_lock, i2c_adapter_depth(adapter));\n\tif (!(flags & I2C_LOCK_ROOT_ADAPTER))\n\t\treturn;\n\ti2c_lock_bus(parent, flags);\n}\n\nstatic int i2c_mux_trylock_bus(struct i2c_adapter *adapter, unsigned int flags)\n{\n\tstruct i2c_mux_priv *priv = adapter->algo_data;\n\tstruct i2c_adapter *parent = priv->muxc->parent;\n\n\tif (!rt_mutex_trylock(&parent->mux_lock))\n\t\treturn 0;\t \n\tif (!(flags & I2C_LOCK_ROOT_ADAPTER))\n\t\treturn 1;\t \n\tif (i2c_trylock_bus(parent, flags))\n\t\treturn 1;\t \n\trt_mutex_unlock(&parent->mux_lock);\n\treturn 0;\t\t \n}\n\nstatic void i2c_mux_unlock_bus(struct i2c_adapter *adapter, unsigned int flags)\n{\n\tstruct i2c_mux_priv *priv = adapter->algo_data;\n\tstruct i2c_adapter *parent = priv->muxc->parent;\n\n\tif (flags & I2C_LOCK_ROOT_ADAPTER)\n\t\ti2c_unlock_bus(parent, flags);\n\trt_mutex_unlock(&parent->mux_lock);\n}\n\nstatic void i2c_parent_lock_bus(struct i2c_adapter *adapter,\n\t\t\t\tunsigned int flags)\n{\n\tstruct i2c_mux_priv *priv = adapter->algo_data;\n\tstruct i2c_adapter *parent = priv->muxc->parent;\n\n\trt_mutex_lock_nested(&parent->mux_lock, i2c_adapter_depth(adapter));\n\ti2c_lock_bus(parent, flags);\n}\n\nstatic int i2c_parent_trylock_bus(struct i2c_adapter *adapter,\n\t\t\t\t  unsigned int flags)\n{\n\tstruct i2c_mux_priv *priv = adapter->algo_data;\n\tstruct i2c_adapter *parent = priv->muxc->parent;\n\n\tif (!rt_mutex_trylock(&parent->mux_lock))\n\t\treturn 0;\t \n\tif (i2c_trylock_bus(parent, flags))\n\t\treturn 1;\t \n\trt_mutex_unlock(&parent->mux_lock);\n\treturn 0;\t\t \n}\n\nstatic void i2c_parent_unlock_bus(struct i2c_adapter *adapter,\n\t\t\t\t  unsigned int flags)\n{\n\tstruct i2c_mux_priv *priv = adapter->algo_data;\n\tstruct i2c_adapter *parent = priv->muxc->parent;\n\n\ti2c_unlock_bus(parent, flags);\n\trt_mutex_unlock(&parent->mux_lock);\n}\n\nstruct i2c_adapter *i2c_root_adapter(struct device *dev)\n{\n\tstruct device *i2c;\n\tstruct i2c_adapter *i2c_root;\n\n\t \n\tfor (i2c = dev; i2c; i2c = i2c->parent) {\n\t\tif (i2c->type == &i2c_adapter_type)\n\t\t\tbreak;\n\t}\n\tif (!i2c)\n\t\treturn NULL;\n\n\t \n\ti2c_root = to_i2c_adapter(i2c);\n\twhile (i2c_parent_is_i2c_adapter(i2c_root))\n\t\ti2c_root = i2c_parent_is_i2c_adapter(i2c_root);\n\n\treturn i2c_root;\n}\nEXPORT_SYMBOL_GPL(i2c_root_adapter);\n\nstruct i2c_mux_core *i2c_mux_alloc(struct i2c_adapter *parent,\n\t\t\t\t   struct device *dev, int max_adapters,\n\t\t\t\t   int sizeof_priv, u32 flags,\n\t\t\t\t   int (*select)(struct i2c_mux_core *, u32),\n\t\t\t\t   int (*deselect)(struct i2c_mux_core *, u32))\n{\n\tstruct i2c_mux_core *muxc;\n\tsize_t mux_size;\n\n\tmux_size = struct_size(muxc, adapter, max_adapters);\n\tmuxc = devm_kzalloc(dev, size_add(mux_size, sizeof_priv), GFP_KERNEL);\n\tif (!muxc)\n\t\treturn NULL;\n\tif (sizeof_priv)\n\t\tmuxc->priv = &muxc->adapter[max_adapters];\n\n\tmuxc->parent = parent;\n\tmuxc->dev = dev;\n\tif (flags & I2C_MUX_LOCKED)\n\t\tmuxc->mux_locked = true;\n\tif (flags & I2C_MUX_ARBITRATOR)\n\t\tmuxc->arbitrator = true;\n\tif (flags & I2C_MUX_GATE)\n\t\tmuxc->gate = true;\n\tmuxc->select = select;\n\tmuxc->deselect = deselect;\n\tmuxc->max_adapters = max_adapters;\n\n\treturn muxc;\n}\nEXPORT_SYMBOL_GPL(i2c_mux_alloc);\n\nstatic const struct i2c_lock_operations i2c_mux_lock_ops = {\n\t.lock_bus =    i2c_mux_lock_bus,\n\t.trylock_bus = i2c_mux_trylock_bus,\n\t.unlock_bus =  i2c_mux_unlock_bus,\n};\n\nstatic const struct i2c_lock_operations i2c_parent_lock_ops = {\n\t.lock_bus =    i2c_parent_lock_bus,\n\t.trylock_bus = i2c_parent_trylock_bus,\n\t.unlock_bus =  i2c_parent_unlock_bus,\n};\n\nint i2c_mux_add_adapter(struct i2c_mux_core *muxc,\n\t\t\tu32 force_nr, u32 chan_id,\n\t\t\tunsigned int class)\n{\n\tstruct i2c_adapter *parent = muxc->parent;\n\tstruct i2c_mux_priv *priv;\n\tchar symlink_name[20];\n\tint ret;\n\n\tif (muxc->num_adapters >= muxc->max_adapters) {\n\t\tdev_err(muxc->dev, \"No room for more i2c-mux adapters\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpriv = kzalloc(sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\t \n\tpriv->muxc = muxc;\n\tpriv->chan_id = chan_id;\n\n\t \n\tif (parent->algo->master_xfer) {\n\t\tif (muxc->mux_locked)\n\t\t\tpriv->algo.master_xfer = i2c_mux_master_xfer;\n\t\telse\n\t\t\tpriv->algo.master_xfer = __i2c_mux_master_xfer;\n\t}\n\tif (parent->algo->master_xfer_atomic)\n\t\tpriv->algo.master_xfer_atomic = priv->algo.master_xfer;\n\n\tif (parent->algo->smbus_xfer) {\n\t\tif (muxc->mux_locked)\n\t\t\tpriv->algo.smbus_xfer = i2c_mux_smbus_xfer;\n\t\telse\n\t\t\tpriv->algo.smbus_xfer = __i2c_mux_smbus_xfer;\n\t}\n\tif (parent->algo->smbus_xfer_atomic)\n\t\tpriv->algo.smbus_xfer_atomic = priv->algo.smbus_xfer;\n\n\tpriv->algo.functionality = i2c_mux_functionality;\n\n\t \n\tsnprintf(priv->adap.name, sizeof(priv->adap.name),\n\t\t \"i2c-%d-mux (chan_id %d)\", i2c_adapter_id(parent), chan_id);\n\tpriv->adap.owner = THIS_MODULE;\n\tpriv->adap.algo = &priv->algo;\n\tpriv->adap.algo_data = priv;\n\tpriv->adap.dev.parent = &parent->dev;\n\tpriv->adap.retries = parent->retries;\n\tpriv->adap.timeout = parent->timeout;\n\tpriv->adap.quirks = parent->quirks;\n\tif (muxc->mux_locked)\n\t\tpriv->adap.lock_ops = &i2c_mux_lock_ops;\n\telse\n\t\tpriv->adap.lock_ops = &i2c_parent_lock_ops;\n\n\t \n\tif (i2c_mux_parent_classes(parent) & class & ~I2C_CLASS_DEPRECATED)\n\t\tdev_err(&parent->dev,\n\t\t\t\"Segment %d behind mux can't share classes with ancestors\\n\",\n\t\t\tchan_id);\n\telse\n\t\tpriv->adap.class = class;\n\n\t \n\tif (muxc->dev->of_node) {\n\t\tstruct device_node *dev_node = muxc->dev->of_node;\n\t\tstruct device_node *mux_node, *child = NULL;\n\t\tu32 reg;\n\n\t\tif (muxc->arbitrator)\n\t\t\tmux_node = of_get_child_by_name(dev_node, \"i2c-arb\");\n\t\telse if (muxc->gate)\n\t\t\tmux_node = of_get_child_by_name(dev_node, \"i2c-gate\");\n\t\telse\n\t\t\tmux_node = of_get_child_by_name(dev_node, \"i2c-mux\");\n\n\t\tif (mux_node) {\n\t\t\t \n\t\t\tif (!of_property_read_u32(mux_node, \"reg\", &reg)) {\n\t\t\t\tof_node_put(mux_node);\n\t\t\t\tmux_node = NULL;\n\t\t\t}\n\t\t}\n\n\t\tif (!mux_node)\n\t\t\tmux_node = of_node_get(dev_node);\n\t\telse if (muxc->arbitrator || muxc->gate)\n\t\t\tchild = of_node_get(mux_node);\n\n\t\tif (!child) {\n\t\t\tfor_each_child_of_node(mux_node, child) {\n\t\t\t\tret = of_property_read_u32(child, \"reg\", &reg);\n\t\t\t\tif (ret)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (chan_id == reg)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tpriv->adap.dev.of_node = child;\n\t\tof_node_put(mux_node);\n\t}\n\n\t \n\tif (has_acpi_companion(muxc->dev))\n\t\tacpi_preset_companion(&priv->adap.dev,\n\t\t\t\t      ACPI_COMPANION(muxc->dev),\n\t\t\t\t      chan_id);\n\n\tif (force_nr) {\n\t\tpriv->adap.nr = force_nr;\n\t\tret = i2c_add_numbered_adapter(&priv->adap);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&parent->dev,\n\t\t\t\t\"failed to add mux-adapter %u as bus %u (error=%d)\\n\",\n\t\t\t\tchan_id, force_nr, ret);\n\t\t\tgoto err_free_priv;\n\t\t}\n\t} else {\n\t\tret = i2c_add_adapter(&priv->adap);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&parent->dev,\n\t\t\t\t\"failed to add mux-adapter %u (error=%d)\\n\",\n\t\t\t\tchan_id, ret);\n\t\t\tgoto err_free_priv;\n\t\t}\n\t}\n\n\tWARN(sysfs_create_link(&priv->adap.dev.kobj, &muxc->dev->kobj,\n\t\t\t       \"mux_device\"),\n\t     \"can't create symlink to mux device\\n\");\n\n\tsnprintf(symlink_name, sizeof(symlink_name), \"channel-%u\", chan_id);\n\tWARN(sysfs_create_link(&muxc->dev->kobj, &priv->adap.dev.kobj,\n\t\t\t       symlink_name),\n\t     \"can't create symlink to channel %u\\n\", chan_id);\n\tdev_info(&parent->dev, \"Added multiplexed i2c bus %d\\n\",\n\t\t i2c_adapter_id(&priv->adap));\n\n\tmuxc->adapter[muxc->num_adapters++] = &priv->adap;\n\treturn 0;\n\nerr_free_priv:\n\tkfree(priv);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(i2c_mux_add_adapter);\n\nvoid i2c_mux_del_adapters(struct i2c_mux_core *muxc)\n{\n\tchar symlink_name[20];\n\n\twhile (muxc->num_adapters) {\n\t\tstruct i2c_adapter *adap = muxc->adapter[--muxc->num_adapters];\n\t\tstruct i2c_mux_priv *priv = adap->algo_data;\n\t\tstruct device_node *np = adap->dev.of_node;\n\n\t\tmuxc->adapter[muxc->num_adapters] = NULL;\n\n\t\tsnprintf(symlink_name, sizeof(symlink_name),\n\t\t\t \"channel-%u\", priv->chan_id);\n\t\tsysfs_remove_link(&muxc->dev->kobj, symlink_name);\n\n\t\tsysfs_remove_link(&priv->adap.dev.kobj, \"mux_device\");\n\t\ti2c_del_adapter(adap);\n\t\tof_node_put(np);\n\t\tkfree(priv);\n\t}\n}\nEXPORT_SYMBOL_GPL(i2c_mux_del_adapters);\n\nMODULE_AUTHOR(\"Rodolfo Giometti <giometti@linux.it>\");\nMODULE_DESCRIPTION(\"I2C driver for multiplexed I2C busses\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}