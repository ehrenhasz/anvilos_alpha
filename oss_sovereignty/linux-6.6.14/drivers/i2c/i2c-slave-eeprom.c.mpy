{
  "module_name": "i2c-slave-eeprom.c",
  "hash_id": "2467dd010dbe20fcfb8f7e4737ca88fb2004750d790aa7501ae832e6f05d8535",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/i2c-slave-eeprom.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/bitfield.h>\n#include <linux/firmware.h>\n#include <linux/i2c.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/sysfs.h>\n\nstruct eeprom_data {\n\tstruct bin_attribute bin;\n\tspinlock_t buffer_lock;\n\tu16 buffer_idx;\n\tu16 address_mask;\n\tu8 num_address_bytes;\n\tu8 idx_write_cnt;\n\tbool read_only;\n\tu8 buffer[];\n};\n\n#define I2C_SLAVE_BYTELEN GENMASK(15, 0)\n#define I2C_SLAVE_FLAG_ADDR16 BIT(16)\n#define I2C_SLAVE_FLAG_RO BIT(17)\n#define I2C_SLAVE_DEVICE_MAGIC(_len, _flags) ((_flags) | ((_len) - 1))\n\nstatic int i2c_slave_eeprom_slave_cb(struct i2c_client *client,\n\t\t\t\t     enum i2c_slave_event event, u8 *val)\n{\n\tstruct eeprom_data *eeprom = i2c_get_clientdata(client);\n\n\tswitch (event) {\n\tcase I2C_SLAVE_WRITE_RECEIVED:\n\t\tif (eeprom->idx_write_cnt < eeprom->num_address_bytes) {\n\t\t\tif (eeprom->idx_write_cnt == 0)\n\t\t\t\teeprom->buffer_idx = 0;\n\t\t\teeprom->buffer_idx = *val | (eeprom->buffer_idx << 8);\n\t\t\teeprom->idx_write_cnt++;\n\t\t} else {\n\t\t\tif (!eeprom->read_only) {\n\t\t\t\tspin_lock(&eeprom->buffer_lock);\n\t\t\t\teeprom->buffer[eeprom->buffer_idx++ & eeprom->address_mask] = *val;\n\t\t\t\tspin_unlock(&eeprom->buffer_lock);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase I2C_SLAVE_READ_PROCESSED:\n\t\t \n\t\teeprom->buffer_idx++;\n\t\tfallthrough;\n\tcase I2C_SLAVE_READ_REQUESTED:\n\t\tspin_lock(&eeprom->buffer_lock);\n\t\t*val = eeprom->buffer[eeprom->buffer_idx & eeprom->address_mask];\n\t\tspin_unlock(&eeprom->buffer_lock);\n\t\t \n\t\tbreak;\n\n\tcase I2C_SLAVE_STOP:\n\tcase I2C_SLAVE_WRITE_REQUESTED:\n\t\teeprom->idx_write_cnt = 0;\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic ssize_t i2c_slave_eeprom_bin_read(struct file *filp, struct kobject *kobj,\n\t\tstruct bin_attribute *attr, char *buf, loff_t off, size_t count)\n{\n\tstruct eeprom_data *eeprom;\n\tunsigned long flags;\n\n\teeprom = dev_get_drvdata(kobj_to_dev(kobj));\n\n\tspin_lock_irqsave(&eeprom->buffer_lock, flags);\n\tmemcpy(buf, &eeprom->buffer[off], count);\n\tspin_unlock_irqrestore(&eeprom->buffer_lock, flags);\n\n\treturn count;\n}\n\nstatic ssize_t i2c_slave_eeprom_bin_write(struct file *filp, struct kobject *kobj,\n\t\tstruct bin_attribute *attr, char *buf, loff_t off, size_t count)\n{\n\tstruct eeprom_data *eeprom;\n\tunsigned long flags;\n\n\teeprom = dev_get_drvdata(kobj_to_dev(kobj));\n\n\tspin_lock_irqsave(&eeprom->buffer_lock, flags);\n\tmemcpy(&eeprom->buffer[off], buf, count);\n\tspin_unlock_irqrestore(&eeprom->buffer_lock, flags);\n\n\treturn count;\n}\n\nstatic int i2c_slave_init_eeprom_data(struct eeprom_data *eeprom, struct i2c_client *client,\n\t\t\t\t      unsigned int size)\n{\n\tconst struct firmware *fw;\n\tconst char *eeprom_data;\n\tint ret = device_property_read_string(&client->dev, \"firmware-name\", &eeprom_data);\n\n\tif (!ret) {\n\t\tret = request_firmware_into_buf(&fw, eeprom_data, &client->dev,\n\t\t\t\t\t\teeprom->buffer, size);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\trelease_firmware(fw);\n\t} else {\n\t\t \n\t\tmemset(eeprom->buffer, 0xff, size);\n\t}\n\treturn 0;\n}\n\nstatic int i2c_slave_eeprom_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tstruct eeprom_data *eeprom;\n\tint ret;\n\tunsigned int size = FIELD_GET(I2C_SLAVE_BYTELEN, id->driver_data) + 1;\n\tunsigned int flag_addr16 = FIELD_GET(I2C_SLAVE_FLAG_ADDR16, id->driver_data);\n\n\teeprom = devm_kzalloc(&client->dev, sizeof(struct eeprom_data) + size, GFP_KERNEL);\n\tif (!eeprom)\n\t\treturn -ENOMEM;\n\n\teeprom->num_address_bytes = flag_addr16 ? 2 : 1;\n\teeprom->address_mask = size - 1;\n\teeprom->read_only = FIELD_GET(I2C_SLAVE_FLAG_RO, id->driver_data);\n\tspin_lock_init(&eeprom->buffer_lock);\n\ti2c_set_clientdata(client, eeprom);\n\n\tret = i2c_slave_init_eeprom_data(eeprom, client, size);\n\tif (ret)\n\t\treturn ret;\n\n\tsysfs_bin_attr_init(&eeprom->bin);\n\teeprom->bin.attr.name = \"slave-eeprom\";\n\teeprom->bin.attr.mode = S_IRUSR | S_IWUSR;\n\teeprom->bin.read = i2c_slave_eeprom_bin_read;\n\teeprom->bin.write = i2c_slave_eeprom_bin_write;\n\teeprom->bin.size = size;\n\n\tret = sysfs_create_bin_file(&client->dev.kobj, &eeprom->bin);\n\tif (ret)\n\t\treturn ret;\n\n\tret = i2c_slave_register(client, i2c_slave_eeprom_slave_cb);\n\tif (ret) {\n\t\tsysfs_remove_bin_file(&client->dev.kobj, &eeprom->bin);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n};\n\nstatic void i2c_slave_eeprom_remove(struct i2c_client *client)\n{\n\tstruct eeprom_data *eeprom = i2c_get_clientdata(client);\n\n\ti2c_slave_unregister(client);\n\tsysfs_remove_bin_file(&client->dev.kobj, &eeprom->bin);\n}\n\nstatic const struct i2c_device_id i2c_slave_eeprom_id[] = {\n\t{ \"slave-24c02\", I2C_SLAVE_DEVICE_MAGIC(2048 / 8,  0) },\n\t{ \"slave-24c02ro\", I2C_SLAVE_DEVICE_MAGIC(2048 / 8,  I2C_SLAVE_FLAG_RO) },\n\t{ \"slave-24c32\", I2C_SLAVE_DEVICE_MAGIC(32768 / 8, I2C_SLAVE_FLAG_ADDR16) },\n\t{ \"slave-24c32ro\", I2C_SLAVE_DEVICE_MAGIC(32768 / 8, I2C_SLAVE_FLAG_ADDR16 | I2C_SLAVE_FLAG_RO) },\n\t{ \"slave-24c64\", I2C_SLAVE_DEVICE_MAGIC(65536 / 8, I2C_SLAVE_FLAG_ADDR16) },\n\t{ \"slave-24c64ro\", I2C_SLAVE_DEVICE_MAGIC(65536 / 8, I2C_SLAVE_FLAG_ADDR16 | I2C_SLAVE_FLAG_RO) },\n\t{ \"slave-24c512\", I2C_SLAVE_DEVICE_MAGIC(524288 / 8, I2C_SLAVE_FLAG_ADDR16) },\n\t{ \"slave-24c512ro\", I2C_SLAVE_DEVICE_MAGIC(524288 / 8, I2C_SLAVE_FLAG_ADDR16 | I2C_SLAVE_FLAG_RO) },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, i2c_slave_eeprom_id);\n\nstatic struct i2c_driver i2c_slave_eeprom_driver = {\n\t.driver = {\n\t\t.name = \"i2c-slave-eeprom\",\n\t},\n\t.probe = i2c_slave_eeprom_probe,\n\t.remove = i2c_slave_eeprom_remove,\n\t.id_table = i2c_slave_eeprom_id,\n};\nmodule_i2c_driver(i2c_slave_eeprom_driver);\n\nMODULE_AUTHOR(\"Wolfram Sang <wsa@sang-engineering.com>\");\nMODULE_DESCRIPTION(\"I2C slave mode EEPROM simulator\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}