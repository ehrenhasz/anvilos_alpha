{
  "module_name": "i2c-slave-testunit.c",
  "hash_id": "218e3d3bfa9c73b1120f80a6e44df3626dbe23f05c01a20aedc71a9248bc1cba",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/i2c-slave-testunit.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/i2c.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>  \n\n#define TU_CUR_VERSION 0x01\n\nenum testunit_cmds {\n\tTU_CMD_READ_BYTES = 1,\t \n\tTU_CMD_HOST_NOTIFY,\n\tTU_CMD_SMBUS_BLOCK_PROC_CALL,\n\tTU_NUM_CMDS\n};\n\nenum testunit_regs {\n\tTU_REG_CMD,\n\tTU_REG_DATAL,\n\tTU_REG_DATAH,\n\tTU_REG_DELAY,\n\tTU_NUM_REGS\n};\n\nenum testunit_flags {\n\tTU_FLAG_IN_PROCESS,\n};\n\nstruct testunit_data {\n\tunsigned long flags;\n\tu8 regs[TU_NUM_REGS];\n\tu8 reg_idx;\n\tstruct i2c_client *client;\n\tstruct delayed_work worker;\n};\n\nstatic void i2c_slave_testunit_work(struct work_struct *work)\n{\n\tstruct testunit_data *tu = container_of(work, struct testunit_data, worker.work);\n\tstruct i2c_msg msg;\n\tu8 msgbuf[256];\n\tint ret = 0;\n\n\tmsg.addr = I2C_CLIENT_END;\n\tmsg.buf = msgbuf;\n\n\tswitch (tu->regs[TU_REG_CMD]) {\n\tcase TU_CMD_READ_BYTES:\n\t\tmsg.addr = tu->regs[TU_REG_DATAL];\n\t\tmsg.flags = I2C_M_RD;\n\t\tmsg.len = tu->regs[TU_REG_DATAH];\n\t\tbreak;\n\n\tcase TU_CMD_HOST_NOTIFY:\n\t\tmsg.addr = 0x08;\n\t\tmsg.flags = 0;\n\t\tmsg.len = 3;\n\t\tmsgbuf[0] = tu->client->addr;\n\t\tmsgbuf[1] = tu->regs[TU_REG_DATAL];\n\t\tmsgbuf[2] = tu->regs[TU_REG_DATAH];\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (msg.addr != I2C_CLIENT_END) {\n\t\tret = i2c_transfer(tu->client->adapter, &msg, 1);\n\t\t \n\t\tret = (ret == 0) ? -EIO : ret;\n\t}\n\n\tif (ret < 0)\n\t\tdev_err(&tu->client->dev, \"CMD%02X failed (%d)\\n\", tu->regs[TU_REG_CMD], ret);\n\n\tclear_bit(TU_FLAG_IN_PROCESS, &tu->flags);\n}\n\nstatic int i2c_slave_testunit_slave_cb(struct i2c_client *client,\n\t\t\t\t     enum i2c_slave_event event, u8 *val)\n{\n\tstruct testunit_data *tu = i2c_get_clientdata(client);\n\tbool is_proc_call = tu->reg_idx == 3 && tu->regs[TU_REG_DATAL] == 1 &&\n\t\t\t    tu->regs[TU_REG_CMD] == TU_CMD_SMBUS_BLOCK_PROC_CALL;\n\tint ret = 0;\n\n\tswitch (event) {\n\tcase I2C_SLAVE_WRITE_RECEIVED:\n\t\tif (test_bit(TU_FLAG_IN_PROCESS, &tu->flags))\n\t\t\treturn -EBUSY;\n\n\t\tif (tu->reg_idx < TU_NUM_REGS)\n\t\t\ttu->regs[tu->reg_idx] = *val;\n\t\telse\n\t\t\tret = -EMSGSIZE;\n\n\t\tif (tu->reg_idx <= TU_NUM_REGS)\n\t\t\ttu->reg_idx++;\n\n\t\t \n\t\tif (tu->regs[TU_REG_CMD] >= TU_NUM_CMDS)\n\t\t\tret = -EINVAL;\n\n\t\tbreak;\n\n\tcase I2C_SLAVE_STOP:\n\t\tif (tu->reg_idx == TU_NUM_REGS) {\n\t\t\tset_bit(TU_FLAG_IN_PROCESS, &tu->flags);\n\t\t\tqueue_delayed_work(system_long_wq, &tu->worker,\n\t\t\t\t\t   msecs_to_jiffies(10 * tu->regs[TU_REG_DELAY]));\n\t\t}\n\t\tfallthrough;\n\n\tcase I2C_SLAVE_WRITE_REQUESTED:\n\t\tmemset(tu->regs, 0, TU_NUM_REGS);\n\t\ttu->reg_idx = 0;\n\t\tbreak;\n\n\tcase I2C_SLAVE_READ_PROCESSED:\n\t\tif (is_proc_call && tu->regs[TU_REG_DATAH])\n\t\t\ttu->regs[TU_REG_DATAH]--;\n\t\tfallthrough;\n\n\tcase I2C_SLAVE_READ_REQUESTED:\n\t\t*val = is_proc_call ? tu->regs[TU_REG_DATAH] : TU_CUR_VERSION;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int i2c_slave_testunit_probe(struct i2c_client *client)\n{\n\tstruct testunit_data *tu;\n\n\ttu = devm_kzalloc(&client->dev, sizeof(struct testunit_data), GFP_KERNEL);\n\tif (!tu)\n\t\treturn -ENOMEM;\n\n\ttu->client = client;\n\ti2c_set_clientdata(client, tu);\n\tINIT_DELAYED_WORK(&tu->worker, i2c_slave_testunit_work);\n\n\treturn i2c_slave_register(client, i2c_slave_testunit_slave_cb);\n};\n\nstatic void i2c_slave_testunit_remove(struct i2c_client *client)\n{\n\tstruct testunit_data *tu = i2c_get_clientdata(client);\n\n\tcancel_delayed_work_sync(&tu->worker);\n\ti2c_slave_unregister(client);\n}\n\nstatic const struct i2c_device_id i2c_slave_testunit_id[] = {\n\t{ \"slave-testunit\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, i2c_slave_testunit_id);\n\nstatic struct i2c_driver i2c_slave_testunit_driver = {\n\t.driver = {\n\t\t.name = \"i2c-slave-testunit\",\n\t},\n\t.probe = i2c_slave_testunit_probe,\n\t.remove = i2c_slave_testunit_remove,\n\t.id_table = i2c_slave_testunit_id,\n};\nmodule_i2c_driver(i2c_slave_testunit_driver);\n\nMODULE_AUTHOR(\"Wolfram Sang <wsa@sang-engineering.com>\");\nMODULE_DESCRIPTION(\"I2C slave mode test unit\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}