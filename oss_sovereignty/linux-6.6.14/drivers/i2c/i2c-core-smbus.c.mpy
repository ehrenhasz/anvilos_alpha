{
  "module_name": "i2c-core-smbus.c",
  "hash_id": "ce9e72b3c76f0a22f0344a841f1dde4101e3f5e59ff192a7e09176c0724221c8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/i2c-core-smbus.c",
  "human_readable_source": "\n \n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/i2c.h>\n#include <linux/i2c-smbus.h>\n#include <linux/property.h>\n#include <linux/slab.h>\n\n#include \"i2c-core.h\"\n\n#define CREATE_TRACE_POINTS\n#include <trace/events/smbus.h>\n\n\n \n\n#define POLY    (0x1070U << 3)\nstatic u8 crc8(u16 data)\n{\n\tint i;\n\n\tfor (i = 0; i < 8; i++) {\n\t\tif (data & 0x8000)\n\t\t\tdata = data ^ POLY;\n\t\tdata = data << 1;\n\t}\n\treturn (u8)(data >> 8);\n}\n\n \nu8 i2c_smbus_pec(u8 crc, u8 *p, size_t count)\n{\n\tint i;\n\n\tfor (i = 0; i < count; i++)\n\t\tcrc = crc8((crc ^ p[i]) << 8);\n\treturn crc;\n}\nEXPORT_SYMBOL(i2c_smbus_pec);\n\n \nstatic u8 i2c_smbus_msg_pec(u8 pec, struct i2c_msg *msg)\n{\n\t \n\tu8 addr = i2c_8bit_addr_from_msg(msg);\n\tpec = i2c_smbus_pec(pec, &addr, 1);\n\n\t \n\treturn i2c_smbus_pec(pec, msg->buf, msg->len);\n}\n\n \nstatic inline void i2c_smbus_add_pec(struct i2c_msg *msg)\n{\n\tmsg->buf[msg->len] = i2c_smbus_msg_pec(0, msg);\n\tmsg->len++;\n}\n\n \nstatic int i2c_smbus_check_pec(u8 cpec, struct i2c_msg *msg)\n{\n\tu8 rpec = msg->buf[--msg->len];\n\tcpec = i2c_smbus_msg_pec(cpec, msg);\n\n\tif (rpec != cpec) {\n\t\tpr_debug(\"Bad PEC 0x%02x vs. 0x%02x\\n\",\n\t\t\trpec, cpec);\n\t\treturn -EBADMSG;\n\t}\n\treturn 0;\n}\n\n \ns32 i2c_smbus_read_byte(const struct i2c_client *client)\n{\n\tunion i2c_smbus_data data;\n\tint status;\n\n\tstatus = i2c_smbus_xfer(client->adapter, client->addr, client->flags,\n\t\t\t\tI2C_SMBUS_READ, 0,\n\t\t\t\tI2C_SMBUS_BYTE, &data);\n\treturn (status < 0) ? status : data.byte;\n}\nEXPORT_SYMBOL(i2c_smbus_read_byte);\n\n \ns32 i2c_smbus_write_byte(const struct i2c_client *client, u8 value)\n{\n\treturn i2c_smbus_xfer(client->adapter, client->addr, client->flags,\n\t                      I2C_SMBUS_WRITE, value, I2C_SMBUS_BYTE, NULL);\n}\nEXPORT_SYMBOL(i2c_smbus_write_byte);\n\n \ns32 i2c_smbus_read_byte_data(const struct i2c_client *client, u8 command)\n{\n\tunion i2c_smbus_data data;\n\tint status;\n\n\tstatus = i2c_smbus_xfer(client->adapter, client->addr, client->flags,\n\t\t\t\tI2C_SMBUS_READ, command,\n\t\t\t\tI2C_SMBUS_BYTE_DATA, &data);\n\treturn (status < 0) ? status : data.byte;\n}\nEXPORT_SYMBOL(i2c_smbus_read_byte_data);\n\n \ns32 i2c_smbus_write_byte_data(const struct i2c_client *client, u8 command,\n\t\t\t      u8 value)\n{\n\tunion i2c_smbus_data data;\n\tdata.byte = value;\n\treturn i2c_smbus_xfer(client->adapter, client->addr, client->flags,\n\t\t\t      I2C_SMBUS_WRITE, command,\n\t\t\t      I2C_SMBUS_BYTE_DATA, &data);\n}\nEXPORT_SYMBOL(i2c_smbus_write_byte_data);\n\n \ns32 i2c_smbus_read_word_data(const struct i2c_client *client, u8 command)\n{\n\tunion i2c_smbus_data data;\n\tint status;\n\n\tstatus = i2c_smbus_xfer(client->adapter, client->addr, client->flags,\n\t\t\t\tI2C_SMBUS_READ, command,\n\t\t\t\tI2C_SMBUS_WORD_DATA, &data);\n\treturn (status < 0) ? status : data.word;\n}\nEXPORT_SYMBOL(i2c_smbus_read_word_data);\n\n \ns32 i2c_smbus_write_word_data(const struct i2c_client *client, u8 command,\n\t\t\t      u16 value)\n{\n\tunion i2c_smbus_data data;\n\tdata.word = value;\n\treturn i2c_smbus_xfer(client->adapter, client->addr, client->flags,\n\t\t\t      I2C_SMBUS_WRITE, command,\n\t\t\t      I2C_SMBUS_WORD_DATA, &data);\n}\nEXPORT_SYMBOL(i2c_smbus_write_word_data);\n\n \ns32 i2c_smbus_read_block_data(const struct i2c_client *client, u8 command,\n\t\t\t      u8 *values)\n{\n\tunion i2c_smbus_data data;\n\tint status;\n\n\tstatus = i2c_smbus_xfer(client->adapter, client->addr, client->flags,\n\t\t\t\tI2C_SMBUS_READ, command,\n\t\t\t\tI2C_SMBUS_BLOCK_DATA, &data);\n\tif (status)\n\t\treturn status;\n\n\tmemcpy(values, &data.block[1], data.block[0]);\n\treturn data.block[0];\n}\nEXPORT_SYMBOL(i2c_smbus_read_block_data);\n\n \ns32 i2c_smbus_write_block_data(const struct i2c_client *client, u8 command,\n\t\t\t       u8 length, const u8 *values)\n{\n\tunion i2c_smbus_data data;\n\n\tif (length > I2C_SMBUS_BLOCK_MAX)\n\t\tlength = I2C_SMBUS_BLOCK_MAX;\n\tdata.block[0] = length;\n\tmemcpy(&data.block[1], values, length);\n\treturn i2c_smbus_xfer(client->adapter, client->addr, client->flags,\n\t\t\t      I2C_SMBUS_WRITE, command,\n\t\t\t      I2C_SMBUS_BLOCK_DATA, &data);\n}\nEXPORT_SYMBOL(i2c_smbus_write_block_data);\n\n \ns32 i2c_smbus_read_i2c_block_data(const struct i2c_client *client, u8 command,\n\t\t\t\t  u8 length, u8 *values)\n{\n\tunion i2c_smbus_data data;\n\tint status;\n\n\tif (length > I2C_SMBUS_BLOCK_MAX)\n\t\tlength = I2C_SMBUS_BLOCK_MAX;\n\tdata.block[0] = length;\n\tstatus = i2c_smbus_xfer(client->adapter, client->addr, client->flags,\n\t\t\t\tI2C_SMBUS_READ, command,\n\t\t\t\tI2C_SMBUS_I2C_BLOCK_DATA, &data);\n\tif (status < 0)\n\t\treturn status;\n\n\tmemcpy(values, &data.block[1], data.block[0]);\n\treturn data.block[0];\n}\nEXPORT_SYMBOL(i2c_smbus_read_i2c_block_data);\n\ns32 i2c_smbus_write_i2c_block_data(const struct i2c_client *client, u8 command,\n\t\t\t\t   u8 length, const u8 *values)\n{\n\tunion i2c_smbus_data data;\n\n\tif (length > I2C_SMBUS_BLOCK_MAX)\n\t\tlength = I2C_SMBUS_BLOCK_MAX;\n\tdata.block[0] = length;\n\tmemcpy(data.block + 1, values, length);\n\treturn i2c_smbus_xfer(client->adapter, client->addr, client->flags,\n\t\t\t      I2C_SMBUS_WRITE, command,\n\t\t\t      I2C_SMBUS_I2C_BLOCK_DATA, &data);\n}\nEXPORT_SYMBOL(i2c_smbus_write_i2c_block_data);\n\nstatic void i2c_smbus_try_get_dmabuf(struct i2c_msg *msg, u8 init_val)\n{\n\tbool is_read = msg->flags & I2C_M_RD;\n\tunsigned char *dma_buf;\n\n\tdma_buf = kzalloc(I2C_SMBUS_BLOCK_MAX + (is_read ? 2 : 3), GFP_KERNEL);\n\tif (!dma_buf)\n\t\treturn;\n\n\tmsg->buf = dma_buf;\n\tmsg->flags |= I2C_M_DMA_SAFE;\n\n\tif (init_val)\n\t\tmsg->buf[0] = init_val;\n}\n\n \nstatic s32 i2c_smbus_xfer_emulated(struct i2c_adapter *adapter, u16 addr,\n\t\t\t\t   unsigned short flags,\n\t\t\t\t   char read_write, u8 command, int size,\n\t\t\t\t   union i2c_smbus_data *data)\n{\n\t \n\tunsigned char msgbuf0[I2C_SMBUS_BLOCK_MAX+3];\n\tunsigned char msgbuf1[I2C_SMBUS_BLOCK_MAX+2];\n\tint nmsgs = read_write == I2C_SMBUS_READ ? 2 : 1;\n\tu8 partial_pec = 0;\n\tint status;\n\tstruct i2c_msg msg[2] = {\n\t\t{\n\t\t\t.addr = addr,\n\t\t\t.flags = flags,\n\t\t\t.len = 1,\n\t\t\t.buf = msgbuf0,\n\t\t}, {\n\t\t\t.addr = addr,\n\t\t\t.flags = flags | I2C_M_RD,\n\t\t\t.len = 0,\n\t\t\t.buf = msgbuf1,\n\t\t},\n\t};\n\tbool wants_pec = ((flags & I2C_CLIENT_PEC) && size != I2C_SMBUS_QUICK\n\t\t\t  && size != I2C_SMBUS_I2C_BLOCK_DATA);\n\n\tmsgbuf0[0] = command;\n\tswitch (size) {\n\tcase I2C_SMBUS_QUICK:\n\t\tmsg[0].len = 0;\n\t\t \n\t\tmsg[0].flags = flags | (read_write == I2C_SMBUS_READ ?\n\t\t\t\t\tI2C_M_RD : 0);\n\t\tnmsgs = 1;\n\t\tbreak;\n\tcase I2C_SMBUS_BYTE:\n\t\tif (read_write == I2C_SMBUS_READ) {\n\t\t\t \n\t\t\tmsg[0].flags = I2C_M_RD | flags;\n\t\t\tnmsgs = 1;\n\t\t}\n\t\tbreak;\n\tcase I2C_SMBUS_BYTE_DATA:\n\t\tif (read_write == I2C_SMBUS_READ)\n\t\t\tmsg[1].len = 1;\n\t\telse {\n\t\t\tmsg[0].len = 2;\n\t\t\tmsgbuf0[1] = data->byte;\n\t\t}\n\t\tbreak;\n\tcase I2C_SMBUS_WORD_DATA:\n\t\tif (read_write == I2C_SMBUS_READ)\n\t\t\tmsg[1].len = 2;\n\t\telse {\n\t\t\tmsg[0].len = 3;\n\t\t\tmsgbuf0[1] = data->word & 0xff;\n\t\t\tmsgbuf0[2] = data->word >> 8;\n\t\t}\n\t\tbreak;\n\tcase I2C_SMBUS_PROC_CALL:\n\t\tnmsgs = 2;  \n\t\tread_write = I2C_SMBUS_READ;\n\t\tmsg[0].len = 3;\n\t\tmsg[1].len = 2;\n\t\tmsgbuf0[1] = data->word & 0xff;\n\t\tmsgbuf0[2] = data->word >> 8;\n\t\tbreak;\n\tcase I2C_SMBUS_BLOCK_DATA:\n\t\tif (read_write == I2C_SMBUS_READ) {\n\t\t\tmsg[1].flags |= I2C_M_RECV_LEN;\n\t\t\tmsg[1].len = 1;  \n\t\t\ti2c_smbus_try_get_dmabuf(&msg[1], 0);\n\t\t} else {\n\t\t\tmsg[0].len = data->block[0] + 2;\n\t\t\tif (msg[0].len > I2C_SMBUS_BLOCK_MAX + 2) {\n\t\t\t\tdev_err(&adapter->dev,\n\t\t\t\t\t\"Invalid block write size %d\\n\",\n\t\t\t\t\tdata->block[0]);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\ti2c_smbus_try_get_dmabuf(&msg[0], command);\n\t\t\tmemcpy(msg[0].buf + 1, data->block, msg[0].len - 1);\n\t\t}\n\t\tbreak;\n\tcase I2C_SMBUS_BLOCK_PROC_CALL:\n\t\tnmsgs = 2;  \n\t\tread_write = I2C_SMBUS_READ;\n\t\tif (data->block[0] > I2C_SMBUS_BLOCK_MAX) {\n\t\t\tdev_err(&adapter->dev,\n\t\t\t\t\"Invalid block write size %d\\n\",\n\t\t\t\tdata->block[0]);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tmsg[0].len = data->block[0] + 2;\n\t\ti2c_smbus_try_get_dmabuf(&msg[0], command);\n\t\tmemcpy(msg[0].buf + 1, data->block, msg[0].len - 1);\n\n\t\tmsg[1].flags |= I2C_M_RECV_LEN;\n\t\tmsg[1].len = 1;  \n\t\ti2c_smbus_try_get_dmabuf(&msg[1], 0);\n\t\tbreak;\n\tcase I2C_SMBUS_I2C_BLOCK_DATA:\n\t\tif (data->block[0] > I2C_SMBUS_BLOCK_MAX) {\n\t\t\tdev_err(&adapter->dev, \"Invalid block %s size %d\\n\",\n\t\t\t\tread_write == I2C_SMBUS_READ ? \"read\" : \"write\",\n\t\t\t\tdata->block[0]);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (read_write == I2C_SMBUS_READ) {\n\t\t\tmsg[1].len = data->block[0];\n\t\t\ti2c_smbus_try_get_dmabuf(&msg[1], 0);\n\t\t} else {\n\t\t\tmsg[0].len = data->block[0] + 1;\n\n\t\t\ti2c_smbus_try_get_dmabuf(&msg[0], command);\n\t\t\tmemcpy(msg[0].buf + 1, data->block + 1, data->block[0]);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&adapter->dev, \"Unsupported transaction %d\\n\", size);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (wants_pec) {\n\t\t \n\t\tif (!(msg[0].flags & I2C_M_RD)) {\n\t\t\tif (nmsgs == 1)  \n\t\t\t\ti2c_smbus_add_pec(&msg[0]);\n\t\t\telse  \n\t\t\t\tpartial_pec = i2c_smbus_msg_pec(0, &msg[0]);\n\t\t}\n\t\t \n\t\tif (msg[nmsgs - 1].flags & I2C_M_RD)\n\t\t\tmsg[nmsgs - 1].len++;\n\t}\n\n\tstatus = __i2c_transfer(adapter, msg, nmsgs);\n\tif (status < 0)\n\t\tgoto cleanup;\n\tif (status != nmsgs) {\n\t\tstatus = -EIO;\n\t\tgoto cleanup;\n\t}\n\tstatus = 0;\n\n\t \n\tif (wants_pec && (msg[nmsgs - 1].flags & I2C_M_RD)) {\n\t\tstatus = i2c_smbus_check_pec(partial_pec, &msg[nmsgs - 1]);\n\t\tif (status < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\tif (read_write == I2C_SMBUS_READ)\n\t\tswitch (size) {\n\t\tcase I2C_SMBUS_BYTE:\n\t\t\tdata->byte = msgbuf0[0];\n\t\t\tbreak;\n\t\tcase I2C_SMBUS_BYTE_DATA:\n\t\t\tdata->byte = msgbuf1[0];\n\t\t\tbreak;\n\t\tcase I2C_SMBUS_WORD_DATA:\n\t\tcase I2C_SMBUS_PROC_CALL:\n\t\t\tdata->word = msgbuf1[0] | (msgbuf1[1] << 8);\n\t\t\tbreak;\n\t\tcase I2C_SMBUS_I2C_BLOCK_DATA:\n\t\t\tmemcpy(data->block + 1, msg[1].buf, data->block[0]);\n\t\t\tbreak;\n\t\tcase I2C_SMBUS_BLOCK_DATA:\n\t\tcase I2C_SMBUS_BLOCK_PROC_CALL:\n\t\t\tif (msg[1].buf[0] > I2C_SMBUS_BLOCK_MAX) {\n\t\t\t\tdev_err(&adapter->dev,\n\t\t\t\t\t\"Invalid block size returned: %d\\n\",\n\t\t\t\t\tmsg[1].buf[0]);\n\t\t\t\tstatus = -EPROTO;\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\tmemcpy(data->block, msg[1].buf, msg[1].buf[0] + 1);\n\t\t\tbreak;\n\t\t}\n\ncleanup:\n\tif (msg[0].flags & I2C_M_DMA_SAFE)\n\t\tkfree(msg[0].buf);\n\tif (msg[1].flags & I2C_M_DMA_SAFE)\n\t\tkfree(msg[1].buf);\n\n\treturn status;\n}\n\n \ns32 i2c_smbus_xfer(struct i2c_adapter *adapter, u16 addr,\n\t\t   unsigned short flags, char read_write,\n\t\t   u8 command, int protocol, union i2c_smbus_data *data)\n{\n\ts32 res;\n\n\tres = __i2c_lock_bus_helper(adapter);\n\tif (res)\n\t\treturn res;\n\n\tres = __i2c_smbus_xfer(adapter, addr, flags, read_write,\n\t\t\t       command, protocol, data);\n\ti2c_unlock_bus(adapter, I2C_LOCK_SEGMENT);\n\n\treturn res;\n}\nEXPORT_SYMBOL(i2c_smbus_xfer);\n\ns32 __i2c_smbus_xfer(struct i2c_adapter *adapter, u16 addr,\n\t\t     unsigned short flags, char read_write,\n\t\t     u8 command, int protocol, union i2c_smbus_data *data)\n{\n\tint (*xfer_func)(struct i2c_adapter *adap, u16 addr,\n\t\t\t unsigned short flags, char read_write,\n\t\t\t u8 command, int size, union i2c_smbus_data *data);\n\tunsigned long orig_jiffies;\n\tint try;\n\ts32 res;\n\n\tres = __i2c_check_suspended(adapter);\n\tif (res)\n\t\treturn res;\n\n\t \n\ttrace_smbus_write(adapter, addr, flags, read_write,\n\t\t\t  command, protocol, data);\n\ttrace_smbus_read(adapter, addr, flags, read_write,\n\t\t\t command, protocol);\n\n\tflags &= I2C_M_TEN | I2C_CLIENT_PEC | I2C_CLIENT_SCCB;\n\n\txfer_func = adapter->algo->smbus_xfer;\n\tif (i2c_in_atomic_xfer_mode()) {\n\t\tif (adapter->algo->smbus_xfer_atomic)\n\t\t\txfer_func = adapter->algo->smbus_xfer_atomic;\n\t\telse if (adapter->algo->master_xfer_atomic)\n\t\t\txfer_func = NULL;  \n\t}\n\n\tif (xfer_func) {\n\t\t \n\t\torig_jiffies = jiffies;\n\t\tfor (res = 0, try = 0; try <= adapter->retries; try++) {\n\t\t\tres = xfer_func(adapter, addr, flags, read_write,\n\t\t\t\t\tcommand, protocol, data);\n\t\t\tif (res != -EAGAIN)\n\t\t\t\tbreak;\n\t\t\tif (time_after(jiffies,\n\t\t\t\t       orig_jiffies + adapter->timeout))\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (res != -EOPNOTSUPP || !adapter->algo->master_xfer)\n\t\t\tgoto trace;\n\t\t \n\t}\n\n\tres = i2c_smbus_xfer_emulated(adapter, addr, flags, read_write,\n\t\t\t\t      command, protocol, data);\n\ntrace:\n\t \n\ttrace_smbus_reply(adapter, addr, flags, read_write,\n\t\t\t  command, protocol, data, res);\n\ttrace_smbus_result(adapter, addr, flags, read_write,\n\t\t\t   command, protocol, res);\n\n\treturn res;\n}\nEXPORT_SYMBOL(__i2c_smbus_xfer);\n\n \ns32 i2c_smbus_read_i2c_block_data_or_emulated(const struct i2c_client *client,\n\t\t\t\t\t      u8 command, u8 length, u8 *values)\n{\n\tu8 i = 0;\n\tint status;\n\n\tif (length > I2C_SMBUS_BLOCK_MAX)\n\t\tlength = I2C_SMBUS_BLOCK_MAX;\n\n\tif (i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_READ_I2C_BLOCK))\n\t\treturn i2c_smbus_read_i2c_block_data(client, command, length, values);\n\n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_READ_BYTE_DATA))\n\t\treturn -EOPNOTSUPP;\n\n\tif (i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_READ_WORD_DATA)) {\n\t\twhile ((i + 2) <= length) {\n\t\t\tstatus = i2c_smbus_read_word_data(client, command + i);\n\t\t\tif (status < 0)\n\t\t\t\treturn status;\n\t\t\tvalues[i] = status & 0xff;\n\t\t\tvalues[i + 1] = status >> 8;\n\t\t\ti += 2;\n\t\t}\n\t}\n\n\twhile (i < length) {\n\t\tstatus = i2c_smbus_read_byte_data(client, command + i);\n\t\tif (status < 0)\n\t\t\treturn status;\n\t\tvalues[i] = status;\n\t\ti++;\n\t}\n\n\treturn i;\n}\nEXPORT_SYMBOL(i2c_smbus_read_i2c_block_data_or_emulated);\n\n \nstruct i2c_client *i2c_new_smbus_alert_device(struct i2c_adapter *adapter,\n\t\t\t\t\t      struct i2c_smbus_alert_setup *setup)\n{\n\tstruct i2c_board_info ara_board_info = {\n\t\tI2C_BOARD_INFO(\"smbus_alert\", 0x0c),\n\t\t.platform_data = setup,\n\t};\n\n\treturn i2c_new_client_device(adapter, &ara_board_info);\n}\nEXPORT_SYMBOL_GPL(i2c_new_smbus_alert_device);\n\n#if IS_ENABLED(CONFIG_I2C_SMBUS)\nint i2c_setup_smbus_alert(struct i2c_adapter *adapter)\n{\n\tstruct device *parent = adapter->dev.parent;\n\tint irq;\n\n\t \n\tif (!parent)\n\t\treturn 0;\n\n\tirq = device_property_match_string(parent, \"interrupt-names\", \"smbus_alert\");\n\tif (irq == -EINVAL || irq == -ENODATA)\n\t\treturn 0;\n\telse if (irq < 0)\n\t\treturn irq;\n\n\treturn PTR_ERR_OR_ZERO(i2c_new_smbus_alert_device(adapter, NULL));\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}