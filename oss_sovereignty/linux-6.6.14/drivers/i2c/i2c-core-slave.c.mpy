{
  "module_name": "i2c-core-slave.c",
  "hash_id": "19741eedaf3db37909692521749f3f9f6274a022c8be1af658a751d630c9a60a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/i2c-core-slave.c",
  "human_readable_source": "\n \n\n#include <dt-bindings/i2c/i2c.h>\n#include <linux/acpi.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/i2c.h>\n#include <linux/of.h>\n\n#include \"i2c-core.h\"\n\n#define CREATE_TRACE_POINTS\n#include <trace/events/i2c_slave.h>\n\nint i2c_slave_register(struct i2c_client *client, i2c_slave_cb_t slave_cb)\n{\n\tint ret;\n\n\tif (WARN(IS_ERR_OR_NULL(client) || !slave_cb, \"insufficient data\\n\"))\n\t\treturn -EINVAL;\n\n\tif (!(client->flags & I2C_CLIENT_SLAVE))\n\t\tdev_warn(&client->dev, \"%s: client slave flag not set. You might see address collisions\\n\",\n\t\t\t __func__);\n\n\tif (!(client->flags & I2C_CLIENT_TEN)) {\n\t\t \n\t\tret = i2c_check_7bit_addr_validity_strict(client->addr);\n\t\tif (ret) {\n\t\t\tdev_err(&client->dev, \"%s: invalid address\\n\", __func__);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (!client->adapter->algo->reg_slave) {\n\t\tdev_err(&client->dev, \"%s: not supported by adapter\\n\", __func__);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tclient->slave_cb = slave_cb;\n\n\ti2c_lock_bus(client->adapter, I2C_LOCK_ROOT_ADAPTER);\n\tret = client->adapter->algo->reg_slave(client);\n\ti2c_unlock_bus(client->adapter, I2C_LOCK_ROOT_ADAPTER);\n\n\tif (ret) {\n\t\tclient->slave_cb = NULL;\n\t\tdev_err(&client->dev, \"%s: adapter returned error %d\\n\", __func__, ret);\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(i2c_slave_register);\n\nint i2c_slave_unregister(struct i2c_client *client)\n{\n\tint ret;\n\n\tif (IS_ERR_OR_NULL(client))\n\t\treturn -EINVAL;\n\n\tif (!client->adapter->algo->unreg_slave) {\n\t\tdev_err(&client->dev, \"%s: not supported by adapter\\n\", __func__);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\ti2c_lock_bus(client->adapter, I2C_LOCK_ROOT_ADAPTER);\n\tret = client->adapter->algo->unreg_slave(client);\n\ti2c_unlock_bus(client->adapter, I2C_LOCK_ROOT_ADAPTER);\n\n\tif (ret == 0)\n\t\tclient->slave_cb = NULL;\n\telse\n\t\tdev_err(&client->dev, \"%s: adapter returned error %d\\n\", __func__, ret);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(i2c_slave_unregister);\n\nint i2c_slave_event(struct i2c_client *client,\n\t\t    enum i2c_slave_event event, u8 *val)\n{\n\tint ret = client->slave_cb(client, event, val);\n\n\tif (trace_i2c_slave_enabled())\n\t\ttrace_i2c_slave(client, event, val, ret);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(i2c_slave_event);\n\n \nbool i2c_detect_slave_mode(struct device *dev)\n{\n\tif (IS_BUILTIN(CONFIG_OF) && dev->of_node) {\n\t\tstruct device_node *child;\n\t\tu32 reg;\n\n\t\tfor_each_child_of_node(dev->of_node, child) {\n\t\t\tof_property_read_u32(child, \"reg\", &reg);\n\t\t\tif (reg & I2C_OWN_SLAVE_ADDRESS) {\n\t\t\t\tof_node_put(child);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t} else if (IS_BUILTIN(CONFIG_ACPI) && ACPI_HANDLE(dev)) {\n\t\tdev_dbg(dev, \"ACPI slave is not supported yet\\n\");\n\t}\n\treturn false;\n}\nEXPORT_SYMBOL_GPL(i2c_detect_slave_mode);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}