{
  "module_name": "i2c-core-base.c",
  "hash_id": "428a1b1b8658002d46cd2605c7ed1cd170e8a2ea1a07690f1f0c5481608dc63b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/i2c-core-base.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"i2c-core: \" fmt\n\n#include <dt-bindings/i2c/i2c.h>\n#include <linux/acpi.h>\n#include <linux/clk/clk-conf.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/i2c-smbus.h>\n#include <linux/idr.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/irqflags.h>\n#include <linux/jump_label.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/of_device.h>\n#include <linux/of.h>\n#include <linux/of_irq.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/pinctrl/devinfo.h>\n#include <linux/pm_domain.h>\n#include <linux/pm_runtime.h>\n#include <linux/pm_wakeirq.h>\n#include <linux/property.h>\n#include <linux/rwsem.h>\n#include <linux/slab.h>\n\n#include \"i2c-core.h\"\n\n#define CREATE_TRACE_POINTS\n#include <trace/events/i2c.h>\n\n#define I2C_ADDR_OFFSET_TEN_BIT\t0xa000\n#define I2C_ADDR_OFFSET_SLAVE\t0x1000\n\n#define I2C_ADDR_7BITS_MAX\t0x77\n#define I2C_ADDR_7BITS_COUNT\t(I2C_ADDR_7BITS_MAX + 1)\n\n#define I2C_ADDR_DEVICE_ID\t0x7c\n\n \nstatic DEFINE_MUTEX(core_lock);\nstatic DEFINE_IDR(i2c_adapter_idr);\n\nstatic int i2c_detect(struct i2c_adapter *adapter, struct i2c_driver *driver);\n\nstatic DEFINE_STATIC_KEY_FALSE(i2c_trace_msg_key);\nstatic bool is_registered;\n\nint i2c_transfer_trace_reg(void)\n{\n\tstatic_branch_inc(&i2c_trace_msg_key);\n\treturn 0;\n}\n\nvoid i2c_transfer_trace_unreg(void)\n{\n\tstatic_branch_dec(&i2c_trace_msg_key);\n}\n\nconst char *i2c_freq_mode_string(u32 bus_freq_hz)\n{\n\tswitch (bus_freq_hz) {\n\tcase I2C_MAX_STANDARD_MODE_FREQ:\n\t\treturn \"Standard Mode (100 kHz)\";\n\tcase I2C_MAX_FAST_MODE_FREQ:\n\t\treturn \"Fast Mode (400 kHz)\";\n\tcase I2C_MAX_FAST_MODE_PLUS_FREQ:\n\t\treturn \"Fast Mode Plus (1.0 MHz)\";\n\tcase I2C_MAX_TURBO_MODE_FREQ:\n\t\treturn \"Turbo Mode (1.4 MHz)\";\n\tcase I2C_MAX_HIGH_SPEED_MODE_FREQ:\n\t\treturn \"High Speed Mode (3.4 MHz)\";\n\tcase I2C_MAX_ULTRA_FAST_MODE_FREQ:\n\t\treturn \"Ultra Fast Mode (5.0 MHz)\";\n\tdefault:\n\t\treturn \"Unknown Mode\";\n\t}\n}\nEXPORT_SYMBOL_GPL(i2c_freq_mode_string);\n\nconst struct i2c_device_id *i2c_match_id(const struct i2c_device_id *id,\n\t\t\t\t\t\tconst struct i2c_client *client)\n{\n\tif (!(id && client))\n\t\treturn NULL;\n\n\twhile (id->name[0]) {\n\t\tif (strcmp(client->name, id->name) == 0)\n\t\t\treturn id;\n\t\tid++;\n\t}\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(i2c_match_id);\n\nconst void *i2c_get_match_data(const struct i2c_client *client)\n{\n\tstruct i2c_driver *driver = to_i2c_driver(client->dev.driver);\n\tconst struct i2c_device_id *match;\n\tconst void *data;\n\n\tdata = device_get_match_data(&client->dev);\n\tif (!data) {\n\t\tmatch = i2c_match_id(driver->id_table, client);\n\t\tif (!match)\n\t\t\treturn NULL;\n\n\t\tdata = (const void *)match->driver_data;\n\t}\n\n\treturn data;\n}\nEXPORT_SYMBOL(i2c_get_match_data);\n\nstatic int i2c_device_match(struct device *dev, struct device_driver *drv)\n{\n\tstruct i2c_client\t*client = i2c_verify_client(dev);\n\tstruct i2c_driver\t*driver;\n\n\n\t \n\tif (i2c_of_match_device(drv->of_match_table, client))\n\t\treturn 1;\n\n\t \n\tif (acpi_driver_match_device(dev, drv))\n\t\treturn 1;\n\n\tdriver = to_i2c_driver(drv);\n\n\t \n\tif (i2c_match_id(driver->id_table, client))\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic int i2c_device_uevent(const struct device *dev, struct kobj_uevent_env *env)\n{\n\tconst struct i2c_client *client = to_i2c_client(dev);\n\tint rc;\n\n\trc = of_device_uevent_modalias(dev, env);\n\tif (rc != -ENODEV)\n\t\treturn rc;\n\n\trc = acpi_device_uevent_modalias(dev, env);\n\tif (rc != -ENODEV)\n\t\treturn rc;\n\n\treturn add_uevent_var(env, \"MODALIAS=%s%s\", I2C_MODULE_PREFIX, client->name);\n}\n\n \nstatic int get_scl_gpio_value(struct i2c_adapter *adap)\n{\n\treturn gpiod_get_value_cansleep(adap->bus_recovery_info->scl_gpiod);\n}\n\nstatic void set_scl_gpio_value(struct i2c_adapter *adap, int val)\n{\n\tgpiod_set_value_cansleep(adap->bus_recovery_info->scl_gpiod, val);\n}\n\nstatic int get_sda_gpio_value(struct i2c_adapter *adap)\n{\n\treturn gpiod_get_value_cansleep(adap->bus_recovery_info->sda_gpiod);\n}\n\nstatic void set_sda_gpio_value(struct i2c_adapter *adap, int val)\n{\n\tgpiod_set_value_cansleep(adap->bus_recovery_info->sda_gpiod, val);\n}\n\nstatic int i2c_generic_bus_free(struct i2c_adapter *adap)\n{\n\tstruct i2c_bus_recovery_info *bri = adap->bus_recovery_info;\n\tint ret = -EOPNOTSUPP;\n\n\tif (bri->get_bus_free)\n\t\tret = bri->get_bus_free(adap);\n\telse if (bri->get_sda)\n\t\tret = bri->get_sda(adap);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn ret ? 0 : -EBUSY;\n}\n\n \n#define RECOVERY_NDELAY\t\t5000\n#define RECOVERY_CLK_CNT\t9\n\nint i2c_generic_scl_recovery(struct i2c_adapter *adap)\n{\n\tstruct i2c_bus_recovery_info *bri = adap->bus_recovery_info;\n\tint i = 0, scl = 1, ret = 0;\n\n\tif (bri->prepare_recovery)\n\t\tbri->prepare_recovery(adap);\n\tif (bri->pinctrl)\n\t\tpinctrl_select_state(bri->pinctrl, bri->pins_gpio);\n\n\t \n\tbri->set_scl(adap, scl);\n\tndelay(RECOVERY_NDELAY);\n\tif (bri->set_sda)\n\t\tbri->set_sda(adap, scl);\n\tndelay(RECOVERY_NDELAY / 2);\n\n\t \n\twhile (i++ < RECOVERY_CLK_CNT * 2) {\n\t\tif (scl) {\n\t\t\t \n\t\t\tif (!bri->get_scl(adap)) {\n\t\t\t\tdev_err(&adap->dev,\n\t\t\t\t\t\"SCL is stuck low, exit recovery\\n\");\n\t\t\t\tret = -EBUSY;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tscl = !scl;\n\t\tbri->set_scl(adap, scl);\n\t\t \n\t\tif (scl)  {\n\t\t\t \n\t\t\tndelay(RECOVERY_NDELAY);\n\t\t} else {\n\t\t\t \n\t\t\tndelay(RECOVERY_NDELAY / 2);\n\t\t}\n\t\tif (bri->set_sda)\n\t\t\tbri->set_sda(adap, scl);\n\t\tndelay(RECOVERY_NDELAY / 2);\n\n\t\tif (scl) {\n\t\t\tret = i2c_generic_bus_free(adap);\n\t\t\tif (ret == 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (ret == -EOPNOTSUPP)\n\t\tret = 0;\n\n\tif (bri->unprepare_recovery)\n\t\tbri->unprepare_recovery(adap);\n\tif (bri->pinctrl)\n\t\tpinctrl_select_state(bri->pinctrl, bri->pins_default);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(i2c_generic_scl_recovery);\n\nint i2c_recover_bus(struct i2c_adapter *adap)\n{\n\tif (!adap->bus_recovery_info)\n\t\treturn -EBUSY;\n\n\tdev_dbg(&adap->dev, \"Trying i2c bus recovery\\n\");\n\treturn adap->bus_recovery_info->recover_bus(adap);\n}\nEXPORT_SYMBOL_GPL(i2c_recover_bus);\n\nstatic void i2c_gpio_init_pinctrl_recovery(struct i2c_adapter *adap)\n{\n\tstruct i2c_bus_recovery_info *bri = adap->bus_recovery_info;\n\tstruct device *dev = &adap->dev;\n\tstruct pinctrl *p = bri->pinctrl ?: dev_pinctrl(dev->parent);\n\n\tbri->pinctrl = p;\n\n\t \n\tif (!p) {\n\t\tbri->pins_default = NULL;\n\t\tbri->pins_gpio = NULL;\n\t\treturn;\n\t}\n\n\tif (!bri->pins_default) {\n\t\tbri->pins_default = pinctrl_lookup_state(p,\n\t\t\t\t\t\t\t PINCTRL_STATE_DEFAULT);\n\t\tif (IS_ERR(bri->pins_default)) {\n\t\t\tdev_dbg(dev, PINCTRL_STATE_DEFAULT \" state not found for GPIO recovery\\n\");\n\t\t\tbri->pins_default = NULL;\n\t\t}\n\t}\n\tif (!bri->pins_gpio) {\n\t\tbri->pins_gpio = pinctrl_lookup_state(p, \"gpio\");\n\t\tif (IS_ERR(bri->pins_gpio))\n\t\t\tbri->pins_gpio = pinctrl_lookup_state(p, \"recovery\");\n\n\t\tif (IS_ERR(bri->pins_gpio)) {\n\t\t\tdev_dbg(dev, \"no gpio or recovery state found for GPIO recovery\\n\");\n\t\t\tbri->pins_gpio = NULL;\n\t\t}\n\t}\n\n\t \n\tif (bri->pins_default && bri->pins_gpio) {\n\t\tdev_info(dev, \"using pinctrl states for GPIO recovery\");\n\t} else {\n\t\tbri->pinctrl = NULL;\n\t\tbri->pins_default = NULL;\n\t\tbri->pins_gpio = NULL;\n\t}\n}\n\nstatic int i2c_gpio_init_generic_recovery(struct i2c_adapter *adap)\n{\n\tstruct i2c_bus_recovery_info *bri = adap->bus_recovery_info;\n\tstruct device *dev = &adap->dev;\n\tstruct gpio_desc *gpiod;\n\tint ret = 0;\n\n\t \n\tif (bri->recover_bus && bri->recover_bus != i2c_generic_scl_recovery)\n\t\treturn 0;\n\n\t \n\tif (bri->pinctrl)\n\t\tpinctrl_select_state(bri->pinctrl, bri->pins_gpio);\n\n\t \n\tif (!bri->scl_gpiod) {\n\t\tgpiod = devm_gpiod_get(dev, \"scl\", GPIOD_OUT_HIGH_OPEN_DRAIN);\n\t\tif (PTR_ERR(gpiod) == -EPROBE_DEFER) {\n\t\t\tret  = -EPROBE_DEFER;\n\t\t\tgoto cleanup_pinctrl_state;\n\t\t}\n\t\tif (!IS_ERR(gpiod)) {\n\t\t\tbri->scl_gpiod = gpiod;\n\t\t\tbri->recover_bus = i2c_generic_scl_recovery;\n\t\t\tdev_info(dev, \"using generic GPIOs for recovery\\n\");\n\t\t}\n\t}\n\n\t \n\tif (!bri->sda_gpiod) {\n\t\t \n\t\tgpiod_direction_output(bri->scl_gpiod, 0);\n\t\tudelay(10);\n\t\tgpiod = devm_gpiod_get(dev, \"sda\", GPIOD_IN);\n\n\t\t \n\t\tudelay(10);\n\t\tgpiod_direction_output(bri->scl_gpiod, 1);\n\n\t\tif (PTR_ERR(gpiod) == -EPROBE_DEFER) {\n\t\t\tret = -EPROBE_DEFER;\n\t\t\tgoto cleanup_pinctrl_state;\n\t\t}\n\t\tif (!IS_ERR(gpiod))\n\t\t\tbri->sda_gpiod = gpiod;\n\t}\n\ncleanup_pinctrl_state:\n\t \n\tif (bri->pinctrl)\n\t\tpinctrl_select_state(bri->pinctrl, bri->pins_default);\n\n\treturn ret;\n}\n\nstatic int i2c_gpio_init_recovery(struct i2c_adapter *adap)\n{\n\ti2c_gpio_init_pinctrl_recovery(adap);\n\treturn i2c_gpio_init_generic_recovery(adap);\n}\n\nstatic int i2c_init_recovery(struct i2c_adapter *adap)\n{\n\tstruct i2c_bus_recovery_info *bri = adap->bus_recovery_info;\n\tbool is_error_level = true;\n\tchar *err_str;\n\n\tif (!bri)\n\t\treturn 0;\n\n\tif (i2c_gpio_init_recovery(adap) == -EPROBE_DEFER)\n\t\treturn -EPROBE_DEFER;\n\n\tif (!bri->recover_bus) {\n\t\terr_str = \"no suitable method provided\";\n\t\tis_error_level = false;\n\t\tgoto err;\n\t}\n\n\tif (bri->scl_gpiod && bri->recover_bus == i2c_generic_scl_recovery) {\n\t\tbri->get_scl = get_scl_gpio_value;\n\t\tbri->set_scl = set_scl_gpio_value;\n\t\tif (bri->sda_gpiod) {\n\t\t\tbri->get_sda = get_sda_gpio_value;\n\t\t\t \n\t\t\tif (gpiod_get_direction(bri->sda_gpiod) == 0)\n\t\t\t\tbri->set_sda = set_sda_gpio_value;\n\t\t}\n\t} else if (bri->recover_bus == i2c_generic_scl_recovery) {\n\t\t \n\t\tif (!bri->set_scl || !bri->get_scl) {\n\t\t\terr_str = \"no {get|set}_scl() found\";\n\t\t\tgoto err;\n\t\t}\n\t\tif (!bri->set_sda && !bri->get_sda) {\n\t\t\terr_str = \"either get_sda() or set_sda() needed\";\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\treturn 0;\n err:\n\tif (is_error_level)\n\t\tdev_err(&adap->dev, \"Not using recovery: %s\\n\", err_str);\n\telse\n\t\tdev_dbg(&adap->dev, \"Not using recovery: %s\\n\", err_str);\n\tadap->bus_recovery_info = NULL;\n\n\treturn -EINVAL;\n}\n\nstatic int i2c_smbus_host_notify_to_irq(const struct i2c_client *client)\n{\n\tstruct i2c_adapter *adap = client->adapter;\n\tunsigned int irq;\n\n\tif (!adap->host_notify_domain)\n\t\treturn -ENXIO;\n\n\tif (client->flags & I2C_CLIENT_TEN)\n\t\treturn -EINVAL;\n\n\tirq = irq_create_mapping(adap->host_notify_domain, client->addr);\n\n\treturn irq > 0 ? irq : -ENXIO;\n}\n\nstatic int i2c_device_probe(struct device *dev)\n{\n\tstruct i2c_client\t*client = i2c_verify_client(dev);\n\tstruct i2c_driver\t*driver;\n\tbool do_power_on;\n\tint status;\n\n\tif (!client)\n\t\treturn 0;\n\n\tclient->irq = client->init_irq;\n\n\tif (!client->irq) {\n\t\tint irq = -ENOENT;\n\n\t\tif (client->flags & I2C_CLIENT_HOST_NOTIFY) {\n\t\t\tdev_dbg(dev, \"Using Host Notify IRQ\\n\");\n\t\t\t \n\t\t\tpm_runtime_get_sync(&client->adapter->dev);\n\t\t\tirq = i2c_smbus_host_notify_to_irq(client);\n\t\t} else if (dev->of_node) {\n\t\t\tirq = of_irq_get_byname(dev->of_node, \"irq\");\n\t\t\tif (irq == -EINVAL || irq == -ENODATA)\n\t\t\t\tirq = of_irq_get(dev->of_node, 0);\n\t\t} else if (ACPI_COMPANION(dev)) {\n\t\t\tbool wake_capable;\n\n\t\t\tirq = i2c_acpi_get_irq(client, &wake_capable);\n\t\t\tif (irq > 0 && wake_capable)\n\t\t\t\tclient->flags |= I2C_CLIENT_WAKE;\n\t\t}\n\t\tif (irq == -EPROBE_DEFER) {\n\t\t\tstatus = irq;\n\t\t\tgoto put_sync_adapter;\n\t\t}\n\n\t\tif (irq < 0)\n\t\t\tirq = 0;\n\n\t\tclient->irq = irq;\n\t}\n\n\tdriver = to_i2c_driver(dev->driver);\n\n\t \n\tif (!driver->id_table &&\n\t    !acpi_driver_match_device(dev, dev->driver) &&\n\t    !i2c_of_match_device(dev->driver->of_match_table, client)) {\n\t\tstatus = -ENODEV;\n\t\tgoto put_sync_adapter;\n\t}\n\n\tif (client->flags & I2C_CLIENT_WAKE) {\n\t\tint wakeirq;\n\n\t\twakeirq = of_irq_get_byname(dev->of_node, \"wakeup\");\n\t\tif (wakeirq == -EPROBE_DEFER) {\n\t\t\tstatus = wakeirq;\n\t\t\tgoto put_sync_adapter;\n\t\t}\n\n\t\tdevice_init_wakeup(&client->dev, true);\n\n\t\tif (wakeirq > 0 && wakeirq != client->irq)\n\t\t\tstatus = dev_pm_set_dedicated_wake_irq(dev, wakeirq);\n\t\telse if (client->irq > 0)\n\t\t\tstatus = dev_pm_set_wake_irq(dev, client->irq);\n\t\telse\n\t\t\tstatus = 0;\n\n\t\tif (status)\n\t\t\tdev_warn(&client->dev, \"failed to set up wakeup irq\\n\");\n\t}\n\n\tdev_dbg(dev, \"probe\\n\");\n\n\tstatus = of_clk_set_defaults(dev->of_node, false);\n\tif (status < 0)\n\t\tgoto err_clear_wakeup_irq;\n\n\tdo_power_on = !i2c_acpi_waive_d0_probe(dev);\n\tstatus = dev_pm_domain_attach(&client->dev, do_power_on);\n\tif (status)\n\t\tgoto err_clear_wakeup_irq;\n\n\tclient->devres_group_id = devres_open_group(&client->dev, NULL,\n\t\t\t\t\t\t    GFP_KERNEL);\n\tif (!client->devres_group_id) {\n\t\tstatus = -ENOMEM;\n\t\tgoto err_detach_pm_domain;\n\t}\n\n\tif (driver->probe)\n\t\tstatus = driver->probe(client);\n\telse\n\t\tstatus = -EINVAL;\n\n\t \n\n\tif (status)\n\t\tgoto err_release_driver_resources;\n\n\treturn 0;\n\nerr_release_driver_resources:\n\tdevres_release_group(&client->dev, client->devres_group_id);\nerr_detach_pm_domain:\n\tdev_pm_domain_detach(&client->dev, do_power_on);\nerr_clear_wakeup_irq:\n\tdev_pm_clear_wake_irq(&client->dev);\n\tdevice_init_wakeup(&client->dev, false);\nput_sync_adapter:\n\tif (client->flags & I2C_CLIENT_HOST_NOTIFY)\n\t\tpm_runtime_put_sync(&client->adapter->dev);\n\n\treturn status;\n}\n\nstatic void i2c_device_remove(struct device *dev)\n{\n\tstruct i2c_client\t*client = to_i2c_client(dev);\n\tstruct i2c_driver\t*driver;\n\n\tdriver = to_i2c_driver(dev->driver);\n\tif (driver->remove) {\n\t\tdev_dbg(dev, \"remove\\n\");\n\n\t\tdriver->remove(client);\n\t}\n\n\tdevres_release_group(&client->dev, client->devres_group_id);\n\n\tdev_pm_domain_detach(&client->dev, true);\n\n\tdev_pm_clear_wake_irq(&client->dev);\n\tdevice_init_wakeup(&client->dev, false);\n\n\tclient->irq = 0;\n\tif (client->flags & I2C_CLIENT_HOST_NOTIFY)\n\t\tpm_runtime_put(&client->adapter->dev);\n}\n\nstatic void i2c_device_shutdown(struct device *dev)\n{\n\tstruct i2c_client *client = i2c_verify_client(dev);\n\tstruct i2c_driver *driver;\n\n\tif (!client || !dev->driver)\n\t\treturn;\n\tdriver = to_i2c_driver(dev->driver);\n\tif (driver->shutdown)\n\t\tdriver->shutdown(client);\n\telse if (client->irq > 0)\n\t\tdisable_irq(client->irq);\n}\n\nstatic void i2c_client_dev_release(struct device *dev)\n{\n\tkfree(to_i2c_client(dev));\n}\n\nstatic ssize_t\nname_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%s\\n\", dev->type == &i2c_client_type ?\n\t\t       to_i2c_client(dev)->name : to_i2c_adapter(dev)->name);\n}\nstatic DEVICE_ATTR_RO(name);\n\nstatic ssize_t\nmodalias_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tint len;\n\n\tlen = of_device_modalias(dev, buf, PAGE_SIZE);\n\tif (len != -ENODEV)\n\t\treturn len;\n\n\tlen = acpi_device_modalias(dev, buf, PAGE_SIZE - 1);\n\tif (len != -ENODEV)\n\t\treturn len;\n\n\treturn sprintf(buf, \"%s%s\\n\", I2C_MODULE_PREFIX, client->name);\n}\nstatic DEVICE_ATTR_RO(modalias);\n\nstatic struct attribute *i2c_dev_attrs[] = {\n\t&dev_attr_name.attr,\n\t \n\t&dev_attr_modalias.attr,\n\tNULL\n};\nATTRIBUTE_GROUPS(i2c_dev);\n\nstruct bus_type i2c_bus_type = {\n\t.name\t\t= \"i2c\",\n\t.match\t\t= i2c_device_match,\n\t.probe\t\t= i2c_device_probe,\n\t.remove\t\t= i2c_device_remove,\n\t.shutdown\t= i2c_device_shutdown,\n};\nEXPORT_SYMBOL_GPL(i2c_bus_type);\n\nstruct device_type i2c_client_type = {\n\t.groups\t\t= i2c_dev_groups,\n\t.uevent\t\t= i2c_device_uevent,\n\t.release\t= i2c_client_dev_release,\n};\nEXPORT_SYMBOL_GPL(i2c_client_type);\n\n\n \nstruct i2c_client *i2c_verify_client(struct device *dev)\n{\n\treturn (dev->type == &i2c_client_type)\n\t\t\t? to_i2c_client(dev)\n\t\t\t: NULL;\n}\nEXPORT_SYMBOL(i2c_verify_client);\n\n\n \nstatic unsigned short i2c_encode_flags_to_addr(struct i2c_client *client)\n{\n\tunsigned short addr = client->addr;\n\n\t \n\tif (client->flags & I2C_CLIENT_TEN)\n\t\taddr |= I2C_ADDR_OFFSET_TEN_BIT;\n\n\tif (client->flags & I2C_CLIENT_SLAVE)\n\t\taddr |= I2C_ADDR_OFFSET_SLAVE;\n\n\treturn addr;\n}\n\n \nstatic int i2c_check_addr_validity(unsigned int addr, unsigned short flags)\n{\n\tif (flags & I2C_CLIENT_TEN) {\n\t\t \n\t\tif (addr > 0x3ff)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\t \n\t\tif (addr == 0x00 || addr > 0x7f)\n\t\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n \nint i2c_check_7bit_addr_validity_strict(unsigned short addr)\n{\n\t \n\tif (addr < 0x08 || addr > 0x77)\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic int __i2c_check_addr_busy(struct device *dev, void *addrp)\n{\n\tstruct i2c_client\t*client = i2c_verify_client(dev);\n\tint\t\t\taddr = *(int *)addrp;\n\n\tif (client && i2c_encode_flags_to_addr(client) == addr)\n\t\treturn -EBUSY;\n\treturn 0;\n}\n\n \nstatic int i2c_check_mux_parents(struct i2c_adapter *adapter, int addr)\n{\n\tstruct i2c_adapter *parent = i2c_parent_is_i2c_adapter(adapter);\n\tint result;\n\n\tresult = device_for_each_child(&adapter->dev, &addr,\n\t\t\t\t\t__i2c_check_addr_busy);\n\n\tif (!result && parent)\n\t\tresult = i2c_check_mux_parents(parent, addr);\n\n\treturn result;\n}\n\n \nstatic int i2c_check_mux_children(struct device *dev, void *addrp)\n{\n\tint result;\n\n\tif (dev->type == &i2c_adapter_type)\n\t\tresult = device_for_each_child(dev, addrp,\n\t\t\t\t\t\ti2c_check_mux_children);\n\telse\n\t\tresult = __i2c_check_addr_busy(dev, addrp);\n\n\treturn result;\n}\n\nstatic int i2c_check_addr_busy(struct i2c_adapter *adapter, int addr)\n{\n\tstruct i2c_adapter *parent = i2c_parent_is_i2c_adapter(adapter);\n\tint result = 0;\n\n\tif (parent)\n\t\tresult = i2c_check_mux_parents(parent, addr);\n\n\tif (!result)\n\t\tresult = device_for_each_child(&adapter->dev, &addr,\n\t\t\t\t\t\ti2c_check_mux_children);\n\n\treturn result;\n}\n\n \nstatic void i2c_adapter_lock_bus(struct i2c_adapter *adapter,\n\t\t\t\t unsigned int flags)\n{\n\trt_mutex_lock_nested(&adapter->bus_lock, i2c_adapter_depth(adapter));\n}\n\n \nstatic int i2c_adapter_trylock_bus(struct i2c_adapter *adapter,\n\t\t\t\t   unsigned int flags)\n{\n\treturn rt_mutex_trylock(&adapter->bus_lock);\n}\n\n \nstatic void i2c_adapter_unlock_bus(struct i2c_adapter *adapter,\n\t\t\t\t   unsigned int flags)\n{\n\trt_mutex_unlock(&adapter->bus_lock);\n}\n\nstatic void i2c_dev_set_name(struct i2c_adapter *adap,\n\t\t\t     struct i2c_client *client,\n\t\t\t     struct i2c_board_info const *info)\n{\n\tstruct acpi_device *adev = ACPI_COMPANION(&client->dev);\n\n\tif (info && info->dev_name) {\n\t\tdev_set_name(&client->dev, \"i2c-%s\", info->dev_name);\n\t\treturn;\n\t}\n\n\tif (adev) {\n\t\tdev_set_name(&client->dev, \"i2c-%s\", acpi_dev_name(adev));\n\t\treturn;\n\t}\n\n\tdev_set_name(&client->dev, \"%d-%04x\", i2c_adapter_id(adap),\n\t\t     i2c_encode_flags_to_addr(client));\n}\n\nint i2c_dev_irq_from_resources(const struct resource *resources,\n\t\t\t       unsigned int num_resources)\n{\n\tstruct irq_data *irqd;\n\tint i;\n\n\tfor (i = 0; i < num_resources; i++) {\n\t\tconst struct resource *r = &resources[i];\n\n\t\tif (resource_type(r) != IORESOURCE_IRQ)\n\t\t\tcontinue;\n\n\t\tif (r->flags & IORESOURCE_BITS) {\n\t\t\tirqd = irq_get_irq_data(r->start);\n\t\t\tif (!irqd)\n\t\t\t\tbreak;\n\n\t\t\tirqd_set_trigger_type(irqd, r->flags & IORESOURCE_BITS);\n\t\t}\n\n\t\treturn r->start;\n\t}\n\n\treturn 0;\n}\n\n \nstruct i2c_client *\ni2c_new_client_device(struct i2c_adapter *adap, struct i2c_board_info const *info)\n{\n\tstruct i2c_client *client;\n\tbool need_put = false;\n\tint status;\n\n\tclient = kzalloc(sizeof *client, GFP_KERNEL);\n\tif (!client)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tclient->adapter = adap;\n\n\tclient->dev.platform_data = info->platform_data;\n\tclient->flags = info->flags;\n\tclient->addr = info->addr;\n\n\tclient->init_irq = info->irq;\n\tif (!client->init_irq)\n\t\tclient->init_irq = i2c_dev_irq_from_resources(info->resources,\n\t\t\t\t\t\t\t info->num_resources);\n\n\tstrscpy(client->name, info->type, sizeof(client->name));\n\n\tstatus = i2c_check_addr_validity(client->addr, client->flags);\n\tif (status) {\n\t\tdev_err(&adap->dev, \"Invalid %d-bit I2C address 0x%02hx\\n\",\n\t\t\tclient->flags & I2C_CLIENT_TEN ? 10 : 7, client->addr);\n\t\tgoto out_err_silent;\n\t}\n\n\t \n\tstatus = i2c_check_addr_busy(adap, i2c_encode_flags_to_addr(client));\n\tif (status)\n\t\tgoto out_err;\n\n\tclient->dev.parent = &client->adapter->dev;\n\tclient->dev.bus = &i2c_bus_type;\n\tclient->dev.type = &i2c_client_type;\n\tclient->dev.of_node = of_node_get(info->of_node);\n\tclient->dev.fwnode = info->fwnode;\n\n\tdevice_enable_async_suspend(&client->dev);\n\n\tif (info->swnode) {\n\t\tstatus = device_add_software_node(&client->dev, info->swnode);\n\t\tif (status) {\n\t\t\tdev_err(&adap->dev,\n\t\t\t\t\"Failed to add software node to client %s: %d\\n\",\n\t\t\t\tclient->name, status);\n\t\t\tgoto out_err_put_of_node;\n\t\t}\n\t}\n\n\ti2c_dev_set_name(adap, client, info);\n\tstatus = device_register(&client->dev);\n\tif (status)\n\t\tgoto out_remove_swnode;\n\n\tdev_dbg(&adap->dev, \"client [%s] registered with bus id %s\\n\",\n\t\tclient->name, dev_name(&client->dev));\n\n\treturn client;\n\nout_remove_swnode:\n\tdevice_remove_software_node(&client->dev);\n\tneed_put = true;\nout_err_put_of_node:\n\tof_node_put(info->of_node);\nout_err:\n\tdev_err(&adap->dev,\n\t\t\"Failed to register i2c client %s at 0x%02x (%d)\\n\",\n\t\tclient->name, client->addr, status);\nout_err_silent:\n\tif (need_put)\n\t\tput_device(&client->dev);\n\telse\n\t\tkfree(client);\n\treturn ERR_PTR(status);\n}\nEXPORT_SYMBOL_GPL(i2c_new_client_device);\n\n \nvoid i2c_unregister_device(struct i2c_client *client)\n{\n\tif (IS_ERR_OR_NULL(client))\n\t\treturn;\n\n\tif (client->dev.of_node) {\n\t\tof_node_clear_flag(client->dev.of_node, OF_POPULATED);\n\t\tof_node_put(client->dev.of_node);\n\t}\n\n\tif (ACPI_COMPANION(&client->dev))\n\t\tacpi_device_clear_enumerated(ACPI_COMPANION(&client->dev));\n\tdevice_remove_software_node(&client->dev);\n\tdevice_unregister(&client->dev);\n}\nEXPORT_SYMBOL_GPL(i2c_unregister_device);\n\n \nstruct i2c_client *i2c_find_device_by_fwnode(struct fwnode_handle *fwnode)\n{\n\tstruct i2c_client *client;\n\tstruct device *dev;\n\n\tif (!fwnode)\n\t\treturn NULL;\n\n\tdev = bus_find_device_by_fwnode(&i2c_bus_type, fwnode);\n\tif (!dev)\n\t\treturn NULL;\n\n\tclient = i2c_verify_client(dev);\n\tif (!client)\n\t\tput_device(dev);\n\n\treturn client;\n}\nEXPORT_SYMBOL(i2c_find_device_by_fwnode);\n\n\nstatic const struct i2c_device_id dummy_id[] = {\n\t{ \"dummy\", 0 },\n\t{ },\n};\n\nstatic int dummy_probe(struct i2c_client *client)\n{\n\treturn 0;\n}\n\nstatic struct i2c_driver dummy_driver = {\n\t.driver.name\t= \"dummy\",\n\t.probe\t\t= dummy_probe,\n\t.id_table\t= dummy_id,\n};\n\n \nstruct i2c_client *i2c_new_dummy_device(struct i2c_adapter *adapter, u16 address)\n{\n\tstruct i2c_board_info info = {\n\t\tI2C_BOARD_INFO(\"dummy\", address),\n\t};\n\n\treturn i2c_new_client_device(adapter, &info);\n}\nEXPORT_SYMBOL_GPL(i2c_new_dummy_device);\n\nstatic void devm_i2c_release_dummy(void *client)\n{\n\ti2c_unregister_device(client);\n}\n\n \nstruct i2c_client *devm_i2c_new_dummy_device(struct device *dev,\n\t\t\t\t\t     struct i2c_adapter *adapter,\n\t\t\t\t\t     u16 address)\n{\n\tstruct i2c_client *client;\n\tint ret;\n\n\tclient = i2c_new_dummy_device(adapter, address);\n\tif (IS_ERR(client))\n\t\treturn client;\n\n\tret = devm_add_action_or_reset(dev, devm_i2c_release_dummy, client);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\treturn client;\n}\nEXPORT_SYMBOL_GPL(devm_i2c_new_dummy_device);\n\n \nstruct i2c_client *i2c_new_ancillary_device(struct i2c_client *client,\n\t\t\t\t\t\tconst char *name,\n\t\t\t\t\t\tu16 default_addr)\n{\n\tstruct device_node *np = client->dev.of_node;\n\tu32 addr = default_addr;\n\tint i;\n\n\tif (np) {\n\t\ti = of_property_match_string(np, \"reg-names\", name);\n\t\tif (i >= 0)\n\t\t\tof_property_read_u32_index(np, \"reg\", i, &addr);\n\t}\n\n\tdev_dbg(&client->adapter->dev, \"Address for %s : 0x%x\\n\", name, addr);\n\treturn i2c_new_dummy_device(client->adapter, addr);\n}\nEXPORT_SYMBOL_GPL(i2c_new_ancillary_device);\n\n \n\n \n\nstatic void i2c_adapter_dev_release(struct device *dev)\n{\n\tstruct i2c_adapter *adap = to_i2c_adapter(dev);\n\tcomplete(&adap->dev_released);\n}\n\nunsigned int i2c_adapter_depth(struct i2c_adapter *adapter)\n{\n\tunsigned int depth = 0;\n\n\twhile ((adapter = i2c_parent_is_i2c_adapter(adapter)))\n\t\tdepth++;\n\n\tWARN_ONCE(depth >= MAX_LOCKDEP_SUBCLASSES,\n\t\t  \"adapter depth exceeds lockdep subclass limit\\n\");\n\n\treturn depth;\n}\nEXPORT_SYMBOL_GPL(i2c_adapter_depth);\n\n \nstatic ssize_t\nnew_device_store(struct device *dev, struct device_attribute *attr,\n\t\t const char *buf, size_t count)\n{\n\tstruct i2c_adapter *adap = to_i2c_adapter(dev);\n\tstruct i2c_board_info info;\n\tstruct i2c_client *client;\n\tchar *blank, end;\n\tint res;\n\n\tmemset(&info, 0, sizeof(struct i2c_board_info));\n\n\tblank = strchr(buf, ' ');\n\tif (!blank) {\n\t\tdev_err(dev, \"%s: Missing parameters\\n\", \"new_device\");\n\t\treturn -EINVAL;\n\t}\n\tif (blank - buf > I2C_NAME_SIZE - 1) {\n\t\tdev_err(dev, \"%s: Invalid device name\\n\", \"new_device\");\n\t\treturn -EINVAL;\n\t}\n\tmemcpy(info.type, buf, blank - buf);\n\n\t \n\tres = sscanf(++blank, \"%hi%c\", &info.addr, &end);\n\tif (res < 1) {\n\t\tdev_err(dev, \"%s: Can't parse I2C address\\n\", \"new_device\");\n\t\treturn -EINVAL;\n\t}\n\tif (res > 1  && end != '\\n') {\n\t\tdev_err(dev, \"%s: Extra parameters\\n\", \"new_device\");\n\t\treturn -EINVAL;\n\t}\n\n\tif ((info.addr & I2C_ADDR_OFFSET_TEN_BIT) == I2C_ADDR_OFFSET_TEN_BIT) {\n\t\tinfo.addr &= ~I2C_ADDR_OFFSET_TEN_BIT;\n\t\tinfo.flags |= I2C_CLIENT_TEN;\n\t}\n\n\tif (info.addr & I2C_ADDR_OFFSET_SLAVE) {\n\t\tinfo.addr &= ~I2C_ADDR_OFFSET_SLAVE;\n\t\tinfo.flags |= I2C_CLIENT_SLAVE;\n\t}\n\n\tclient = i2c_new_client_device(adap, &info);\n\tif (IS_ERR(client))\n\t\treturn PTR_ERR(client);\n\n\t \n\tmutex_lock(&adap->userspace_clients_lock);\n\tlist_add_tail(&client->detected, &adap->userspace_clients);\n\tmutex_unlock(&adap->userspace_clients_lock);\n\tdev_info(dev, \"%s: Instantiated device %s at 0x%02hx\\n\", \"new_device\",\n\t\t info.type, info.addr);\n\n\treturn count;\n}\nstatic DEVICE_ATTR_WO(new_device);\n\n \nstatic ssize_t\ndelete_device_store(struct device *dev, struct device_attribute *attr,\n\t\t    const char *buf, size_t count)\n{\n\tstruct i2c_adapter *adap = to_i2c_adapter(dev);\n\tstruct i2c_client *client, *next;\n\tunsigned short addr;\n\tchar end;\n\tint res;\n\n\t \n\tres = sscanf(buf, \"%hi%c\", &addr, &end);\n\tif (res < 1) {\n\t\tdev_err(dev, \"%s: Can't parse I2C address\\n\", \"delete_device\");\n\t\treturn -EINVAL;\n\t}\n\tif (res > 1  && end != '\\n') {\n\t\tdev_err(dev, \"%s: Extra parameters\\n\", \"delete_device\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tres = -ENOENT;\n\tmutex_lock_nested(&adap->userspace_clients_lock,\n\t\t\t  i2c_adapter_depth(adap));\n\tlist_for_each_entry_safe(client, next, &adap->userspace_clients,\n\t\t\t\t detected) {\n\t\tif (i2c_encode_flags_to_addr(client) == addr) {\n\t\t\tdev_info(dev, \"%s: Deleting device %s at 0x%02hx\\n\",\n\t\t\t\t \"delete_device\", client->name, client->addr);\n\n\t\t\tlist_del(&client->detected);\n\t\t\ti2c_unregister_device(client);\n\t\t\tres = count;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&adap->userspace_clients_lock);\n\n\tif (res < 0)\n\t\tdev_err(dev, \"%s: Can't find device in list\\n\",\n\t\t\t\"delete_device\");\n\treturn res;\n}\nstatic DEVICE_ATTR_IGNORE_LOCKDEP(delete_device, S_IWUSR, NULL,\n\t\t\t\t  delete_device_store);\n\nstatic struct attribute *i2c_adapter_attrs[] = {\n\t&dev_attr_name.attr,\n\t&dev_attr_new_device.attr,\n\t&dev_attr_delete_device.attr,\n\tNULL\n};\nATTRIBUTE_GROUPS(i2c_adapter);\n\nstruct device_type i2c_adapter_type = {\n\t.groups\t\t= i2c_adapter_groups,\n\t.release\t= i2c_adapter_dev_release,\n};\nEXPORT_SYMBOL_GPL(i2c_adapter_type);\n\n \nstruct i2c_adapter *i2c_verify_adapter(struct device *dev)\n{\n\treturn (dev->type == &i2c_adapter_type)\n\t\t\t? to_i2c_adapter(dev)\n\t\t\t: NULL;\n}\nEXPORT_SYMBOL(i2c_verify_adapter);\n\n#ifdef CONFIG_I2C_COMPAT\nstatic struct class_compat *i2c_adapter_compat_class;\n#endif\n\nstatic void i2c_scan_static_board_info(struct i2c_adapter *adapter)\n{\n\tstruct i2c_devinfo\t*devinfo;\n\n\tdown_read(&__i2c_board_lock);\n\tlist_for_each_entry(devinfo, &__i2c_board_list, list) {\n\t\tif (devinfo->busnum == adapter->nr &&\n\t\t    IS_ERR(i2c_new_client_device(adapter, &devinfo->board_info)))\n\t\t\tdev_err(&adapter->dev,\n\t\t\t\t\"Can't create device at 0x%02x\\n\",\n\t\t\t\tdevinfo->board_info.addr);\n\t}\n\tup_read(&__i2c_board_lock);\n}\n\nstatic int i2c_do_add_adapter(struct i2c_driver *driver,\n\t\t\t      struct i2c_adapter *adap)\n{\n\t \n\ti2c_detect(adap, driver);\n\n\treturn 0;\n}\n\nstatic int __process_new_adapter(struct device_driver *d, void *data)\n{\n\treturn i2c_do_add_adapter(to_i2c_driver(d), data);\n}\n\nstatic const struct i2c_lock_operations i2c_adapter_lock_ops = {\n\t.lock_bus =    i2c_adapter_lock_bus,\n\t.trylock_bus = i2c_adapter_trylock_bus,\n\t.unlock_bus =  i2c_adapter_unlock_bus,\n};\n\nstatic void i2c_host_notify_irq_teardown(struct i2c_adapter *adap)\n{\n\tstruct irq_domain *domain = adap->host_notify_domain;\n\tirq_hw_number_t hwirq;\n\n\tif (!domain)\n\t\treturn;\n\n\tfor (hwirq = 0 ; hwirq < I2C_ADDR_7BITS_COUNT ; hwirq++)\n\t\tirq_dispose_mapping(irq_find_mapping(domain, hwirq));\n\n\tirq_domain_remove(domain);\n\tadap->host_notify_domain = NULL;\n}\n\nstatic int i2c_host_notify_irq_map(struct irq_domain *h,\n\t\t\t\t\t  unsigned int virq,\n\t\t\t\t\t  irq_hw_number_t hw_irq_num)\n{\n\tirq_set_chip_and_handler(virq, &dummy_irq_chip, handle_simple_irq);\n\n\treturn 0;\n}\n\nstatic const struct irq_domain_ops i2c_host_notify_irq_ops = {\n\t.map = i2c_host_notify_irq_map,\n};\n\nstatic int i2c_setup_host_notify_irq_domain(struct i2c_adapter *adap)\n{\n\tstruct irq_domain *domain;\n\n\tif (!i2c_check_functionality(adap, I2C_FUNC_SMBUS_HOST_NOTIFY))\n\t\treturn 0;\n\n\tdomain = irq_domain_create_linear(adap->dev.parent->fwnode,\n\t\t\t\t\t  I2C_ADDR_7BITS_COUNT,\n\t\t\t\t\t  &i2c_host_notify_irq_ops, adap);\n\tif (!domain)\n\t\treturn -ENOMEM;\n\n\tadap->host_notify_domain = domain;\n\n\treturn 0;\n}\n\n \nint i2c_handle_smbus_host_notify(struct i2c_adapter *adap, unsigned short addr)\n{\n\tint irq;\n\n\tif (!adap)\n\t\treturn -EINVAL;\n\n\tirq = irq_find_mapping(adap->host_notify_domain, addr);\n\tif (irq <= 0)\n\t\treturn -ENXIO;\n\n\tgeneric_handle_irq_safe(irq);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(i2c_handle_smbus_host_notify);\n\nstatic int i2c_register_adapter(struct i2c_adapter *adap)\n{\n\tint res = -EINVAL;\n\n\t \n\tif (WARN_ON(!is_registered)) {\n\t\tres = -EAGAIN;\n\t\tgoto out_list;\n\t}\n\n\t \n\tif (WARN(!adap->name[0], \"i2c adapter has no name\"))\n\t\tgoto out_list;\n\n\tif (!adap->algo) {\n\t\tpr_err(\"adapter '%s': no algo supplied!\\n\", adap->name);\n\t\tgoto out_list;\n\t}\n\n\tif (!adap->lock_ops)\n\t\tadap->lock_ops = &i2c_adapter_lock_ops;\n\n\tadap->locked_flags = 0;\n\trt_mutex_init(&adap->bus_lock);\n\trt_mutex_init(&adap->mux_lock);\n\tmutex_init(&adap->userspace_clients_lock);\n\tINIT_LIST_HEAD(&adap->userspace_clients);\n\n\t \n\tif (adap->timeout == 0)\n\t\tadap->timeout = HZ;\n\n\t \n\tres = i2c_setup_host_notify_irq_domain(adap);\n\tif (res) {\n\t\tpr_err(\"adapter '%s': can't create Host Notify IRQs (%d)\\n\",\n\t\t       adap->name, res);\n\t\tgoto out_list;\n\t}\n\n\tdev_set_name(&adap->dev, \"i2c-%d\", adap->nr);\n\tadap->dev.bus = &i2c_bus_type;\n\tadap->dev.type = &i2c_adapter_type;\n\tres = device_register(&adap->dev);\n\tif (res) {\n\t\tpr_err(\"adapter '%s': can't register device (%d)\\n\", adap->name, res);\n\t\tgoto out_list;\n\t}\n\n\tres = i2c_setup_smbus_alert(adap);\n\tif (res)\n\t\tgoto out_reg;\n\n\tdevice_enable_async_suspend(&adap->dev);\n\tpm_runtime_no_callbacks(&adap->dev);\n\tpm_suspend_ignore_children(&adap->dev, true);\n\tpm_runtime_enable(&adap->dev);\n\n\tres = i2c_init_recovery(adap);\n\tif (res == -EPROBE_DEFER)\n\t\tgoto out_reg;\n\n\tdev_dbg(&adap->dev, \"adapter [%s] registered\\n\", adap->name);\n\n#ifdef CONFIG_I2C_COMPAT\n\tres = class_compat_create_link(i2c_adapter_compat_class, &adap->dev,\n\t\t\t\t       adap->dev.parent);\n\tif (res)\n\t\tdev_warn(&adap->dev,\n\t\t\t \"Failed to create compatibility class link\\n\");\n#endif\n\n\t \n\tof_i2c_register_devices(adap);\n\ti2c_acpi_install_space_handler(adap);\n\ti2c_acpi_register_devices(adap);\n\n\tif (adap->nr < __i2c_first_dynamic_bus_num)\n\t\ti2c_scan_static_board_info(adap);\n\n\t \n\tmutex_lock(&core_lock);\n\tbus_for_each_drv(&i2c_bus_type, NULL, adap, __process_new_adapter);\n\tmutex_unlock(&core_lock);\n\n\treturn 0;\n\nout_reg:\n\tinit_completion(&adap->dev_released);\n\tdevice_unregister(&adap->dev);\n\twait_for_completion(&adap->dev_released);\nout_list:\n\tmutex_lock(&core_lock);\n\tidr_remove(&i2c_adapter_idr, adap->nr);\n\tmutex_unlock(&core_lock);\n\treturn res;\n}\n\n \nstatic int __i2c_add_numbered_adapter(struct i2c_adapter *adap)\n{\n\tint id;\n\n\tmutex_lock(&core_lock);\n\tid = idr_alloc(&i2c_adapter_idr, adap, adap->nr, adap->nr + 1, GFP_KERNEL);\n\tmutex_unlock(&core_lock);\n\tif (WARN(id < 0, \"couldn't get idr\"))\n\t\treturn id == -ENOSPC ? -EBUSY : id;\n\n\treturn i2c_register_adapter(adap);\n}\n\n \nint i2c_add_adapter(struct i2c_adapter *adapter)\n{\n\tstruct device *dev = &adapter->dev;\n\tint id;\n\n\tif (dev->of_node) {\n\t\tid = of_alias_get_id(dev->of_node, \"i2c\");\n\t\tif (id >= 0) {\n\t\t\tadapter->nr = id;\n\t\t\treturn __i2c_add_numbered_adapter(adapter);\n\t\t}\n\t}\n\n\tmutex_lock(&core_lock);\n\tid = idr_alloc(&i2c_adapter_idr, adapter,\n\t\t       __i2c_first_dynamic_bus_num, 0, GFP_KERNEL);\n\tmutex_unlock(&core_lock);\n\tif (WARN(id < 0, \"couldn't get idr\"))\n\t\treturn id;\n\n\tadapter->nr = id;\n\n\treturn i2c_register_adapter(adapter);\n}\nEXPORT_SYMBOL(i2c_add_adapter);\n\n \nint i2c_add_numbered_adapter(struct i2c_adapter *adap)\n{\n\tif (adap->nr == -1)  \n\t\treturn i2c_add_adapter(adap);\n\n\treturn __i2c_add_numbered_adapter(adap);\n}\nEXPORT_SYMBOL_GPL(i2c_add_numbered_adapter);\n\nstatic void i2c_do_del_adapter(struct i2c_driver *driver,\n\t\t\t      struct i2c_adapter *adapter)\n{\n\tstruct i2c_client *client, *_n;\n\n\t \n\tlist_for_each_entry_safe(client, _n, &driver->clients, detected) {\n\t\tif (client->adapter == adapter) {\n\t\t\tdev_dbg(&adapter->dev, \"Removing %s at 0x%x\\n\",\n\t\t\t\tclient->name, client->addr);\n\t\t\tlist_del(&client->detected);\n\t\t\ti2c_unregister_device(client);\n\t\t}\n\t}\n}\n\nstatic int __unregister_client(struct device *dev, void *dummy)\n{\n\tstruct i2c_client *client = i2c_verify_client(dev);\n\tif (client && strcmp(client->name, \"dummy\"))\n\t\ti2c_unregister_device(client);\n\treturn 0;\n}\n\nstatic int __unregister_dummy(struct device *dev, void *dummy)\n{\n\tstruct i2c_client *client = i2c_verify_client(dev);\n\ti2c_unregister_device(client);\n\treturn 0;\n}\n\nstatic int __process_removed_adapter(struct device_driver *d, void *data)\n{\n\ti2c_do_del_adapter(to_i2c_driver(d), data);\n\treturn 0;\n}\n\n \nvoid i2c_del_adapter(struct i2c_adapter *adap)\n{\n\tstruct i2c_adapter *found;\n\tstruct i2c_client *client, *next;\n\n\t \n\tmutex_lock(&core_lock);\n\tfound = idr_find(&i2c_adapter_idr, adap->nr);\n\tmutex_unlock(&core_lock);\n\tif (found != adap) {\n\t\tpr_debug(\"attempting to delete unregistered adapter [%s]\\n\", adap->name);\n\t\treturn;\n\t}\n\n\ti2c_acpi_remove_space_handler(adap);\n\t \n\tmutex_lock(&core_lock);\n\tbus_for_each_drv(&i2c_bus_type, NULL, adap,\n\t\t\t       __process_removed_adapter);\n\tmutex_unlock(&core_lock);\n\n\t \n\tmutex_lock_nested(&adap->userspace_clients_lock,\n\t\t\t  i2c_adapter_depth(adap));\n\tlist_for_each_entry_safe(client, next, &adap->userspace_clients,\n\t\t\t\t detected) {\n\t\tdev_dbg(&adap->dev, \"Removing %s at 0x%x\\n\", client->name,\n\t\t\tclient->addr);\n\t\tlist_del(&client->detected);\n\t\ti2c_unregister_device(client);\n\t}\n\tmutex_unlock(&adap->userspace_clients_lock);\n\n\t \n\tdevice_for_each_child(&adap->dev, NULL, __unregister_client);\n\tdevice_for_each_child(&adap->dev, NULL, __unregister_dummy);\n\n#ifdef CONFIG_I2C_COMPAT\n\tclass_compat_remove_link(i2c_adapter_compat_class, &adap->dev,\n\t\t\t\t adap->dev.parent);\n#endif\n\n\t \n\tdev_dbg(&adap->dev, \"adapter [%s] unregistered\\n\", adap->name);\n\n\tpm_runtime_disable(&adap->dev);\n\n\ti2c_host_notify_irq_teardown(adap);\n\n\t \n\tinit_completion(&adap->dev_released);\n\tdevice_unregister(&adap->dev);\n\twait_for_completion(&adap->dev_released);\n\n\t \n\tmutex_lock(&core_lock);\n\tidr_remove(&i2c_adapter_idr, adap->nr);\n\tmutex_unlock(&core_lock);\n\n\t \n\tmemset(&adap->dev, 0, sizeof(adap->dev));\n}\nEXPORT_SYMBOL(i2c_del_adapter);\n\nstatic void devm_i2c_del_adapter(void *adapter)\n{\n\ti2c_del_adapter(adapter);\n}\n\n \nint devm_i2c_add_adapter(struct device *dev, struct i2c_adapter *adapter)\n{\n\tint ret;\n\n\tret = i2c_add_adapter(adapter);\n\tif (ret)\n\t\treturn ret;\n\n\treturn devm_add_action_or_reset(dev, devm_i2c_del_adapter, adapter);\n}\nEXPORT_SYMBOL_GPL(devm_i2c_add_adapter);\n\nstatic int i2c_dev_or_parent_fwnode_match(struct device *dev, const void *data)\n{\n\tif (dev_fwnode(dev) == data)\n\t\treturn 1;\n\n\tif (dev->parent && dev_fwnode(dev->parent) == data)\n\t\treturn 1;\n\n\treturn 0;\n}\n\n \nstruct i2c_adapter *i2c_find_adapter_by_fwnode(struct fwnode_handle *fwnode)\n{\n\tstruct i2c_adapter *adapter;\n\tstruct device *dev;\n\n\tif (!fwnode)\n\t\treturn NULL;\n\n\tdev = bus_find_device(&i2c_bus_type, NULL, fwnode,\n\t\t\t      i2c_dev_or_parent_fwnode_match);\n\tif (!dev)\n\t\treturn NULL;\n\n\tadapter = i2c_verify_adapter(dev);\n\tif (!adapter)\n\t\tput_device(dev);\n\n\treturn adapter;\n}\nEXPORT_SYMBOL(i2c_find_adapter_by_fwnode);\n\n \nstruct i2c_adapter *i2c_get_adapter_by_fwnode(struct fwnode_handle *fwnode)\n{\n\tstruct i2c_adapter *adapter;\n\n\tadapter = i2c_find_adapter_by_fwnode(fwnode);\n\tif (!adapter)\n\t\treturn NULL;\n\n\tif (!try_module_get(adapter->owner)) {\n\t\tput_device(&adapter->dev);\n\t\tadapter = NULL;\n\t}\n\n\treturn adapter;\n}\nEXPORT_SYMBOL(i2c_get_adapter_by_fwnode);\n\nstatic void i2c_parse_timing(struct device *dev, char *prop_name, u32 *cur_val_p,\n\t\t\t    u32 def_val, bool use_def)\n{\n\tint ret;\n\n\tret = device_property_read_u32(dev, prop_name, cur_val_p);\n\tif (ret && use_def)\n\t\t*cur_val_p = def_val;\n\n\tdev_dbg(dev, \"%s: %u\\n\", prop_name, *cur_val_p);\n}\n\n \nvoid i2c_parse_fw_timings(struct device *dev, struct i2c_timings *t, bool use_defaults)\n{\n\tbool u = use_defaults;\n\tu32 d;\n\n\ti2c_parse_timing(dev, \"clock-frequency\", &t->bus_freq_hz,\n\t\t\t I2C_MAX_STANDARD_MODE_FREQ, u);\n\n\td = t->bus_freq_hz <= I2C_MAX_STANDARD_MODE_FREQ ? 1000 :\n\t    t->bus_freq_hz <= I2C_MAX_FAST_MODE_FREQ ? 300 : 120;\n\ti2c_parse_timing(dev, \"i2c-scl-rising-time-ns\", &t->scl_rise_ns, d, u);\n\n\td = t->bus_freq_hz <= I2C_MAX_FAST_MODE_FREQ ? 300 : 120;\n\ti2c_parse_timing(dev, \"i2c-scl-falling-time-ns\", &t->scl_fall_ns, d, u);\n\n\ti2c_parse_timing(dev, \"i2c-scl-internal-delay-ns\",\n\t\t\t &t->scl_int_delay_ns, 0, u);\n\ti2c_parse_timing(dev, \"i2c-sda-falling-time-ns\", &t->sda_fall_ns,\n\t\t\t t->scl_fall_ns, u);\n\ti2c_parse_timing(dev, \"i2c-sda-hold-time-ns\", &t->sda_hold_ns, 0, u);\n\ti2c_parse_timing(dev, \"i2c-digital-filter-width-ns\",\n\t\t\t &t->digital_filter_width_ns, 0, u);\n\ti2c_parse_timing(dev, \"i2c-analog-filter-cutoff-frequency\",\n\t\t\t &t->analog_filter_cutoff_freq_hz, 0, u);\n}\nEXPORT_SYMBOL_GPL(i2c_parse_fw_timings);\n\n \n\nint i2c_for_each_dev(void *data, int (*fn)(struct device *dev, void *data))\n{\n\tint res;\n\n\tmutex_lock(&core_lock);\n\tres = bus_for_each_dev(&i2c_bus_type, NULL, data, fn);\n\tmutex_unlock(&core_lock);\n\n\treturn res;\n}\nEXPORT_SYMBOL_GPL(i2c_for_each_dev);\n\nstatic int __process_new_driver(struct device *dev, void *data)\n{\n\tif (dev->type != &i2c_adapter_type)\n\t\treturn 0;\n\treturn i2c_do_add_adapter(data, to_i2c_adapter(dev));\n}\n\n \n\nint i2c_register_driver(struct module *owner, struct i2c_driver *driver)\n{\n\tint res;\n\n\t \n\tif (WARN_ON(!is_registered))\n\t\treturn -EAGAIN;\n\n\t \n\tdriver->driver.owner = owner;\n\tdriver->driver.bus = &i2c_bus_type;\n\tINIT_LIST_HEAD(&driver->clients);\n\n\t \n\tres = driver_register(&driver->driver);\n\tif (res)\n\t\treturn res;\n\n\tpr_debug(\"driver [%s] registered\\n\", driver->driver.name);\n\n\t \n\ti2c_for_each_dev(driver, __process_new_driver);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(i2c_register_driver);\n\nstatic int __process_removed_driver(struct device *dev, void *data)\n{\n\tif (dev->type == &i2c_adapter_type)\n\t\ti2c_do_del_adapter(data, to_i2c_adapter(dev));\n\treturn 0;\n}\n\n \nvoid i2c_del_driver(struct i2c_driver *driver)\n{\n\ti2c_for_each_dev(driver, __process_removed_driver);\n\n\tdriver_unregister(&driver->driver);\n\tpr_debug(\"driver [%s] unregistered\\n\", driver->driver.name);\n}\nEXPORT_SYMBOL(i2c_del_driver);\n\n \n\nstruct i2c_cmd_arg {\n\tunsigned\tcmd;\n\tvoid\t\t*arg;\n};\n\nstatic int i2c_cmd(struct device *dev, void *_arg)\n{\n\tstruct i2c_client\t*client = i2c_verify_client(dev);\n\tstruct i2c_cmd_arg\t*arg = _arg;\n\tstruct i2c_driver\t*driver;\n\n\tif (!client || !client->dev.driver)\n\t\treturn 0;\n\n\tdriver = to_i2c_driver(client->dev.driver);\n\tif (driver->command)\n\t\tdriver->command(client, arg->cmd, arg->arg);\n\treturn 0;\n}\n\nvoid i2c_clients_command(struct i2c_adapter *adap, unsigned int cmd, void *arg)\n{\n\tstruct i2c_cmd_arg\tcmd_arg;\n\n\tcmd_arg.cmd = cmd;\n\tcmd_arg.arg = arg;\n\tdevice_for_each_child(&adap->dev, &cmd_arg, i2c_cmd);\n}\nEXPORT_SYMBOL(i2c_clients_command);\n\nstatic int __init i2c_init(void)\n{\n\tint retval;\n\n\tretval = of_alias_get_highest_id(\"i2c\");\n\n\tdown_write(&__i2c_board_lock);\n\tif (retval >= __i2c_first_dynamic_bus_num)\n\t\t__i2c_first_dynamic_bus_num = retval + 1;\n\tup_write(&__i2c_board_lock);\n\n\tretval = bus_register(&i2c_bus_type);\n\tif (retval)\n\t\treturn retval;\n\n\tis_registered = true;\n\n#ifdef CONFIG_I2C_COMPAT\n\ti2c_adapter_compat_class = class_compat_register(\"i2c-adapter\");\n\tif (!i2c_adapter_compat_class) {\n\t\tretval = -ENOMEM;\n\t\tgoto bus_err;\n\t}\n#endif\n\tretval = i2c_add_driver(&dummy_driver);\n\tif (retval)\n\t\tgoto class_err;\n\n\tif (IS_ENABLED(CONFIG_OF_DYNAMIC))\n\t\tWARN_ON(of_reconfig_notifier_register(&i2c_of_notifier));\n\tif (IS_ENABLED(CONFIG_ACPI))\n\t\tWARN_ON(acpi_reconfig_notifier_register(&i2c_acpi_notifier));\n\n\treturn 0;\n\nclass_err:\n#ifdef CONFIG_I2C_COMPAT\n\tclass_compat_unregister(i2c_adapter_compat_class);\nbus_err:\n#endif\n\tis_registered = false;\n\tbus_unregister(&i2c_bus_type);\n\treturn retval;\n}\n\nstatic void __exit i2c_exit(void)\n{\n\tif (IS_ENABLED(CONFIG_ACPI))\n\t\tWARN_ON(acpi_reconfig_notifier_unregister(&i2c_acpi_notifier));\n\tif (IS_ENABLED(CONFIG_OF_DYNAMIC))\n\t\tWARN_ON(of_reconfig_notifier_unregister(&i2c_of_notifier));\n\ti2c_del_driver(&dummy_driver);\n#ifdef CONFIG_I2C_COMPAT\n\tclass_compat_unregister(i2c_adapter_compat_class);\n#endif\n\tbus_unregister(&i2c_bus_type);\n\ttracepoint_synchronize_unregister();\n}\n\n \npostcore_initcall(i2c_init);\nmodule_exit(i2c_exit);\n\n \n\n \n#define i2c_quirk_exceeded(val, quirk) ((quirk) && ((val) > (quirk)))\n\nstatic int i2c_quirk_error(struct i2c_adapter *adap, struct i2c_msg *msg, char *err_msg)\n{\n\tdev_err_ratelimited(&adap->dev, \"adapter quirk: %s (addr 0x%04x, size %u, %s)\\n\",\n\t\t\t    err_msg, msg->addr, msg->len,\n\t\t\t    msg->flags & I2C_M_RD ? \"read\" : \"write\");\n\treturn -EOPNOTSUPP;\n}\n\nstatic int i2c_check_for_quirks(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)\n{\n\tconst struct i2c_adapter_quirks *q = adap->quirks;\n\tint max_num = q->max_num_msgs, i;\n\tbool do_len_check = true;\n\n\tif (q->flags & I2C_AQ_COMB) {\n\t\tmax_num = 2;\n\n\t\t \n\t\tif (num == 2) {\n\t\t\tif (q->flags & I2C_AQ_COMB_WRITE_FIRST && msgs[0].flags & I2C_M_RD)\n\t\t\t\treturn i2c_quirk_error(adap, &msgs[0], \"1st comb msg must be write\");\n\n\t\t\tif (q->flags & I2C_AQ_COMB_READ_SECOND && !(msgs[1].flags & I2C_M_RD))\n\t\t\t\treturn i2c_quirk_error(adap, &msgs[1], \"2nd comb msg must be read\");\n\n\t\t\tif (q->flags & I2C_AQ_COMB_SAME_ADDR && msgs[0].addr != msgs[1].addr)\n\t\t\t\treturn i2c_quirk_error(adap, &msgs[0], \"comb msg only to same addr\");\n\n\t\t\tif (i2c_quirk_exceeded(msgs[0].len, q->max_comb_1st_msg_len))\n\t\t\t\treturn i2c_quirk_error(adap, &msgs[0], \"msg too long\");\n\n\t\t\tif (i2c_quirk_exceeded(msgs[1].len, q->max_comb_2nd_msg_len))\n\t\t\t\treturn i2c_quirk_error(adap, &msgs[1], \"msg too long\");\n\n\t\t\tdo_len_check = false;\n\t\t}\n\t}\n\n\tif (i2c_quirk_exceeded(num, max_num))\n\t\treturn i2c_quirk_error(adap, &msgs[0], \"too many messages\");\n\n\tfor (i = 0; i < num; i++) {\n\t\tu16 len = msgs[i].len;\n\n\t\tif (msgs[i].flags & I2C_M_RD) {\n\t\t\tif (do_len_check && i2c_quirk_exceeded(len, q->max_read_len))\n\t\t\t\treturn i2c_quirk_error(adap, &msgs[i], \"msg too long\");\n\n\t\t\tif (q->flags & I2C_AQ_NO_ZERO_LEN_READ && len == 0)\n\t\t\t\treturn i2c_quirk_error(adap, &msgs[i], \"no zero length\");\n\t\t} else {\n\t\t\tif (do_len_check && i2c_quirk_exceeded(len, q->max_write_len))\n\t\t\t\treturn i2c_quirk_error(adap, &msgs[i], \"msg too long\");\n\n\t\t\tif (q->flags & I2C_AQ_NO_ZERO_LEN_WRITE && len == 0)\n\t\t\t\treturn i2c_quirk_error(adap, &msgs[i], \"no zero length\");\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nint __i2c_transfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)\n{\n\tunsigned long orig_jiffies;\n\tint ret, try;\n\n\tif (WARN_ON(!msgs || num < 1))\n\t\treturn -EINVAL;\n\n\tret = __i2c_check_suspended(adap);\n\tif (ret)\n\t\treturn ret;\n\n\tif (adap->quirks && i2c_check_for_quirks(adap, msgs, num))\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif (static_branch_unlikely(&i2c_trace_msg_key)) {\n\t\tint i;\n\t\tfor (i = 0; i < num; i++)\n\t\t\tif (msgs[i].flags & I2C_M_RD)\n\t\t\t\ttrace_i2c_read(adap, &msgs[i], i);\n\t\t\telse\n\t\t\t\ttrace_i2c_write(adap, &msgs[i], i);\n\t}\n\n\t \n\torig_jiffies = jiffies;\n\tfor (ret = 0, try = 0; try <= adap->retries; try++) {\n\t\tif (i2c_in_atomic_xfer_mode() && adap->algo->master_xfer_atomic)\n\t\t\tret = adap->algo->master_xfer_atomic(adap, msgs, num);\n\t\telse\n\t\t\tret = adap->algo->master_xfer(adap, msgs, num);\n\n\t\tif (ret != -EAGAIN)\n\t\t\tbreak;\n\t\tif (time_after(jiffies, orig_jiffies + adap->timeout))\n\t\t\tbreak;\n\t}\n\n\tif (static_branch_unlikely(&i2c_trace_msg_key)) {\n\t\tint i;\n\t\tfor (i = 0; i < ret; i++)\n\t\t\tif (msgs[i].flags & I2C_M_RD)\n\t\t\t\ttrace_i2c_reply(adap, &msgs[i], i);\n\t\ttrace_i2c_result(adap, num, ret);\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL(__i2c_transfer);\n\n \nint i2c_transfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)\n{\n\tint ret;\n\n\tif (!adap->algo->master_xfer) {\n\t\tdev_dbg(&adap->dev, \"I2C level transfers not supported\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t \n\tret = __i2c_lock_bus_helper(adap);\n\tif (ret)\n\t\treturn ret;\n\n\tret = __i2c_transfer(adap, msgs, num);\n\ti2c_unlock_bus(adap, I2C_LOCK_SEGMENT);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(i2c_transfer);\n\n \nint i2c_transfer_buffer_flags(const struct i2c_client *client, char *buf,\n\t\t\t      int count, u16 flags)\n{\n\tint ret;\n\tstruct i2c_msg msg = {\n\t\t.addr = client->addr,\n\t\t.flags = flags | (client->flags & I2C_M_TEN),\n\t\t.len = count,\n\t\t.buf = buf,\n\t};\n\n\tret = i2c_transfer(client->adapter, &msg, 1);\n\n\t \n\treturn (ret == 1) ? count : ret;\n}\nEXPORT_SYMBOL(i2c_transfer_buffer_flags);\n\n \nint i2c_get_device_id(const struct i2c_client *client,\n\t\t      struct i2c_device_identity *id)\n{\n\tstruct i2c_adapter *adap = client->adapter;\n\tunion i2c_smbus_data raw_id;\n\tint ret;\n\n\tif (!i2c_check_functionality(adap, I2C_FUNC_SMBUS_READ_I2C_BLOCK))\n\t\treturn -EOPNOTSUPP;\n\n\traw_id.block[0] = 3;\n\tret = i2c_smbus_xfer(adap, I2C_ADDR_DEVICE_ID, 0,\n\t\t\t     I2C_SMBUS_READ, client->addr << 1,\n\t\t\t     I2C_SMBUS_I2C_BLOCK_DATA, &raw_id);\n\tif (ret)\n\t\treturn ret;\n\n\tid->manufacturer_id = (raw_id.block[1] << 4) | (raw_id.block[2] >> 4);\n\tid->part_id = ((raw_id.block[2] & 0xf) << 5) | (raw_id.block[3] >> 3);\n\tid->die_revision = raw_id.block[3] & 0x7;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(i2c_get_device_id);\n\n \nconst struct i2c_device_id *i2c_client_get_device_id(const struct i2c_client *client)\n{\n\tconst struct i2c_driver *drv = to_i2c_driver(client->dev.driver);\n\n\treturn i2c_match_id(drv->id_table, client);\n}\nEXPORT_SYMBOL_GPL(i2c_client_get_device_id);\n\n \n\n \nstatic int i2c_default_probe(struct i2c_adapter *adap, unsigned short addr)\n{\n\tint err;\n\tunion i2c_smbus_data dummy;\n\n#ifdef CONFIG_X86\n\tif (addr == 0x73 && (adap->class & I2C_CLASS_HWMON)\n\t && i2c_check_functionality(adap, I2C_FUNC_SMBUS_READ_BYTE_DATA))\n\t\terr = i2c_smbus_xfer(adap, addr, 0, I2C_SMBUS_READ, 0,\n\t\t\t\t     I2C_SMBUS_BYTE_DATA, &dummy);\n\telse\n#endif\n\tif (!((addr & ~0x07) == 0x30 || (addr & ~0x0f) == 0x50)\n\t && i2c_check_functionality(adap, I2C_FUNC_SMBUS_QUICK))\n\t\terr = i2c_smbus_xfer(adap, addr, 0, I2C_SMBUS_WRITE, 0,\n\t\t\t\t     I2C_SMBUS_QUICK, NULL);\n\telse if (i2c_check_functionality(adap, I2C_FUNC_SMBUS_READ_BYTE))\n\t\terr = i2c_smbus_xfer(adap, addr, 0, I2C_SMBUS_READ, 0,\n\t\t\t\t     I2C_SMBUS_BYTE, &dummy);\n\telse {\n\t\tdev_warn(&adap->dev, \"No suitable probing method supported for address 0x%02X\\n\",\n\t\t\t addr);\n\t\terr = -EOPNOTSUPP;\n\t}\n\n\treturn err >= 0;\n}\n\nstatic int i2c_detect_address(struct i2c_client *temp_client,\n\t\t\t      struct i2c_driver *driver)\n{\n\tstruct i2c_board_info info;\n\tstruct i2c_adapter *adapter = temp_client->adapter;\n\tint addr = temp_client->addr;\n\tint err;\n\n\t \n\terr = i2c_check_7bit_addr_validity_strict(addr);\n\tif (err) {\n\t\tdev_warn(&adapter->dev, \"Invalid probe address 0x%02x\\n\",\n\t\t\t addr);\n\t\treturn err;\n\t}\n\n\t \n\tif (i2c_check_addr_busy(adapter, addr))\n\t\treturn 0;\n\n\t \n\tif (!i2c_default_probe(adapter, addr))\n\t\treturn 0;\n\n\t \n\tmemset(&info, 0, sizeof(struct i2c_board_info));\n\tinfo.addr = addr;\n\terr = driver->detect(temp_client, &info);\n\tif (err) {\n\t\t \n\t\treturn err == -ENODEV ? 0 : err;\n\t}\n\n\t \n\tif (info.type[0] == '\\0') {\n\t\tdev_err(&adapter->dev,\n\t\t\t\"%s detection function provided no name for 0x%x\\n\",\n\t\t\tdriver->driver.name, addr);\n\t} else {\n\t\tstruct i2c_client *client;\n\n\t\t \n\t\tif (adapter->class & I2C_CLASS_DEPRECATED)\n\t\t\tdev_warn(&adapter->dev,\n\t\t\t\t\"This adapter will soon drop class based instantiation of devices. \"\n\t\t\t\t\"Please make sure client 0x%02x gets instantiated by other means. \"\n\t\t\t\t\"Check 'Documentation/i2c/instantiating-devices.rst' for details.\\n\",\n\t\t\t\tinfo.addr);\n\n\t\tdev_dbg(&adapter->dev, \"Creating %s at 0x%02x\\n\",\n\t\t\tinfo.type, info.addr);\n\t\tclient = i2c_new_client_device(adapter, &info);\n\t\tif (!IS_ERR(client))\n\t\t\tlist_add_tail(&client->detected, &driver->clients);\n\t\telse\n\t\t\tdev_err(&adapter->dev, \"Failed creating %s at 0x%02x\\n\",\n\t\t\t\tinfo.type, info.addr);\n\t}\n\treturn 0;\n}\n\nstatic int i2c_detect(struct i2c_adapter *adapter, struct i2c_driver *driver)\n{\n\tconst unsigned short *address_list;\n\tstruct i2c_client *temp_client;\n\tint i, err = 0;\n\n\taddress_list = driver->address_list;\n\tif (!driver->detect || !address_list)\n\t\treturn 0;\n\n\t \n\tif (adapter->class == I2C_CLASS_DEPRECATED) {\n\t\tdev_dbg(&adapter->dev,\n\t\t\t\"This adapter dropped support for I2C classes and won't auto-detect %s devices anymore. \"\n\t\t\t\"If you need it, check 'Documentation/i2c/instantiating-devices.rst' for alternatives.\\n\",\n\t\t\tdriver->driver.name);\n\t\treturn 0;\n\t}\n\n\t \n\tif (!(adapter->class & driver->class))\n\t\treturn 0;\n\n\t \n\ttemp_client = kzalloc(sizeof(struct i2c_client), GFP_KERNEL);\n\tif (!temp_client)\n\t\treturn -ENOMEM;\n\ttemp_client->adapter = adapter;\n\n\tfor (i = 0; address_list[i] != I2C_CLIENT_END; i += 1) {\n\t\tdev_dbg(&adapter->dev,\n\t\t\t\"found normal entry for adapter %d, addr 0x%02x\\n\",\n\t\t\ti2c_adapter_id(adapter), address_list[i]);\n\t\ttemp_client->addr = address_list[i];\n\t\terr = i2c_detect_address(temp_client, driver);\n\t\tif (unlikely(err))\n\t\t\tbreak;\n\t}\n\n\tkfree(temp_client);\n\treturn err;\n}\n\nint i2c_probe_func_quick_read(struct i2c_adapter *adap, unsigned short addr)\n{\n\treturn i2c_smbus_xfer(adap, addr, 0, I2C_SMBUS_READ, 0,\n\t\t\t      I2C_SMBUS_QUICK, NULL) >= 0;\n}\nEXPORT_SYMBOL_GPL(i2c_probe_func_quick_read);\n\nstruct i2c_client *\ni2c_new_scanned_device(struct i2c_adapter *adap,\n\t\t       struct i2c_board_info *info,\n\t\t       unsigned short const *addr_list,\n\t\t       int (*probe)(struct i2c_adapter *adap, unsigned short addr))\n{\n\tint i;\n\n\tif (!probe)\n\t\tprobe = i2c_default_probe;\n\n\tfor (i = 0; addr_list[i] != I2C_CLIENT_END; i++) {\n\t\t \n\t\tif (i2c_check_7bit_addr_validity_strict(addr_list[i]) < 0) {\n\t\t\tdev_warn(&adap->dev, \"Invalid 7-bit address 0x%02x\\n\",\n\t\t\t\t addr_list[i]);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (i2c_check_addr_busy(adap, addr_list[i])) {\n\t\t\tdev_dbg(&adap->dev,\n\t\t\t\t\"Address 0x%02x already in use, not probing\\n\",\n\t\t\t\taddr_list[i]);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (probe(adap, addr_list[i]))\n\t\t\tbreak;\n\t}\n\n\tif (addr_list[i] == I2C_CLIENT_END) {\n\t\tdev_dbg(&adap->dev, \"Probing failed, no device found\\n\");\n\t\treturn ERR_PTR(-ENODEV);\n\t}\n\n\tinfo->addr = addr_list[i];\n\treturn i2c_new_client_device(adap, info);\n}\nEXPORT_SYMBOL_GPL(i2c_new_scanned_device);\n\nstruct i2c_adapter *i2c_get_adapter(int nr)\n{\n\tstruct i2c_adapter *adapter;\n\n\tmutex_lock(&core_lock);\n\tadapter = idr_find(&i2c_adapter_idr, nr);\n\tif (!adapter)\n\t\tgoto exit;\n\n\tif (try_module_get(adapter->owner))\n\t\tget_device(&adapter->dev);\n\telse\n\t\tadapter = NULL;\n\n exit:\n\tmutex_unlock(&core_lock);\n\treturn adapter;\n}\nEXPORT_SYMBOL(i2c_get_adapter);\n\nvoid i2c_put_adapter(struct i2c_adapter *adap)\n{\n\tif (!adap)\n\t\treturn;\n\n\tmodule_put(adap->owner);\n\t \n\tput_device(&adap->dev);\n}\nEXPORT_SYMBOL(i2c_put_adapter);\n\n \nu8 *i2c_get_dma_safe_msg_buf(struct i2c_msg *msg, unsigned int threshold)\n{\n\t \n\tif (!threshold)\n\t\tpr_debug(\"DMA buffer for addr=0x%02x with length 0 is bogus\\n\",\n\t\t\t msg->addr);\n\tif (msg->len < threshold || msg->len == 0)\n\t\treturn NULL;\n\n\tif (msg->flags & I2C_M_DMA_SAFE)\n\t\treturn msg->buf;\n\n\tpr_debug(\"using bounce buffer for addr=0x%02x, len=%d\\n\",\n\t\t msg->addr, msg->len);\n\n\tif (msg->flags & I2C_M_RD)\n\t\treturn kzalloc(msg->len, GFP_KERNEL);\n\telse\n\t\treturn kmemdup(msg->buf, msg->len, GFP_KERNEL);\n}\nEXPORT_SYMBOL_GPL(i2c_get_dma_safe_msg_buf);\n\n \nvoid i2c_put_dma_safe_msg_buf(u8 *buf, struct i2c_msg *msg, bool xferred)\n{\n\tif (!buf || buf == msg->buf)\n\t\treturn;\n\n\tif (xferred && msg->flags & I2C_M_RD)\n\t\tmemcpy(msg->buf, buf, msg->len);\n\n\tkfree(buf);\n}\nEXPORT_SYMBOL_GPL(i2c_put_dma_safe_msg_buf);\n\nMODULE_AUTHOR(\"Simon G. Vogl <simon@tk.uni-linz.ac.at>\");\nMODULE_DESCRIPTION(\"I2C-Bus main module\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}