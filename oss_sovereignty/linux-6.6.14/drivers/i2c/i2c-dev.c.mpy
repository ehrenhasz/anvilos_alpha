{
  "module_name": "i2c-dev.c",
  "hash_id": "0c39e9d399b3c3a6f062d9ca0ee44662c8e2b5f1fe1af0cb91df2e05561ff9a2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i2c/i2c-dev.c",
  "human_readable_source": "\n \n\n \n\n \n\n#define pr_fmt(fmt)\tKBUILD_MODNAME \": \" fmt\n\n#include <linux/cdev.h>\n#include <linux/compat.h>\n#include <linux/device.h>\n#include <linux/fs.h>\n#include <linux/i2c-dev.h>\n#include <linux/i2c.h>\n#include <linux/init.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/notifier.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\n \nstruct i2c_dev {\n\tstruct list_head list;\n\tstruct i2c_adapter *adap;\n\tstruct device dev;\n\tstruct cdev cdev;\n};\n\n#define I2C_MINORS\t(MINORMASK + 1)\nstatic LIST_HEAD(i2c_dev_list);\nstatic DEFINE_SPINLOCK(i2c_dev_list_lock);\n\nstatic struct i2c_dev *i2c_dev_get_by_minor(unsigned index)\n{\n\tstruct i2c_dev *i2c_dev;\n\n\tspin_lock(&i2c_dev_list_lock);\n\tlist_for_each_entry(i2c_dev, &i2c_dev_list, list) {\n\t\tif (i2c_dev->adap->nr == index)\n\t\t\tgoto found;\n\t}\n\ti2c_dev = NULL;\nfound:\n\tspin_unlock(&i2c_dev_list_lock);\n\treturn i2c_dev;\n}\n\nstatic struct i2c_dev *get_free_i2c_dev(struct i2c_adapter *adap)\n{\n\tstruct i2c_dev *i2c_dev;\n\n\tif (adap->nr >= I2C_MINORS) {\n\t\tpr_err(\"Out of device minors (%d)\\n\", adap->nr);\n\t\treturn ERR_PTR(-ENODEV);\n\t}\n\n\ti2c_dev = kzalloc(sizeof(*i2c_dev), GFP_KERNEL);\n\tif (!i2c_dev)\n\t\treturn ERR_PTR(-ENOMEM);\n\ti2c_dev->adap = adap;\n\n\tspin_lock(&i2c_dev_list_lock);\n\tlist_add_tail(&i2c_dev->list, &i2c_dev_list);\n\tspin_unlock(&i2c_dev_list_lock);\n\treturn i2c_dev;\n}\n\nstatic void put_i2c_dev(struct i2c_dev *i2c_dev, bool del_cdev)\n{\n\tspin_lock(&i2c_dev_list_lock);\n\tlist_del(&i2c_dev->list);\n\tspin_unlock(&i2c_dev_list_lock);\n\tif (del_cdev)\n\t\tcdev_device_del(&i2c_dev->cdev, &i2c_dev->dev);\n\tput_device(&i2c_dev->dev);\n}\n\nstatic ssize_t name_show(struct device *dev,\n\t\t\t struct device_attribute *attr, char *buf)\n{\n\tstruct i2c_dev *i2c_dev = i2c_dev_get_by_minor(MINOR(dev->devt));\n\n\tif (!i2c_dev)\n\t\treturn -ENODEV;\n\treturn sysfs_emit(buf, \"%s\\n\", i2c_dev->adap->name);\n}\nstatic DEVICE_ATTR_RO(name);\n\nstatic struct attribute *i2c_attrs[] = {\n\t&dev_attr_name.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(i2c);\n\n \n\n \n\nstatic ssize_t i2cdev_read(struct file *file, char __user *buf, size_t count,\n\t\tloff_t *offset)\n{\n\tchar *tmp;\n\tint ret;\n\n\tstruct i2c_client *client = file->private_data;\n\n\tif (count > 8192)\n\t\tcount = 8192;\n\n\ttmp = kzalloc(count, GFP_KERNEL);\n\tif (tmp == NULL)\n\t\treturn -ENOMEM;\n\n\tpr_debug(\"i2c-%d reading %zu bytes.\\n\", iminor(file_inode(file)), count);\n\n\tret = i2c_master_recv(client, tmp, count);\n\tif (ret >= 0)\n\t\tif (copy_to_user(buf, tmp, ret))\n\t\t\tret = -EFAULT;\n\tkfree(tmp);\n\treturn ret;\n}\n\nstatic ssize_t i2cdev_write(struct file *file, const char __user *buf,\n\t\tsize_t count, loff_t *offset)\n{\n\tint ret;\n\tchar *tmp;\n\tstruct i2c_client *client = file->private_data;\n\n\tif (count > 8192)\n\t\tcount = 8192;\n\n\ttmp = memdup_user(buf, count);\n\tif (IS_ERR(tmp))\n\t\treturn PTR_ERR(tmp);\n\n\tpr_debug(\"i2c-%d writing %zu bytes.\\n\", iminor(file_inode(file)), count);\n\n\tret = i2c_master_send(client, tmp, count);\n\tkfree(tmp);\n\treturn ret;\n}\n\nstatic int i2cdev_check(struct device *dev, void *addrp)\n{\n\tstruct i2c_client *client = i2c_verify_client(dev);\n\n\tif (!client || client->addr != *(unsigned int *)addrp)\n\t\treturn 0;\n\n\treturn dev->driver ? -EBUSY : 0;\n}\n\n \nstatic int i2cdev_check_mux_parents(struct i2c_adapter *adapter, int addr)\n{\n\tstruct i2c_adapter *parent = i2c_parent_is_i2c_adapter(adapter);\n\tint result;\n\n\tresult = device_for_each_child(&adapter->dev, &addr, i2cdev_check);\n\tif (!result && parent)\n\t\tresult = i2cdev_check_mux_parents(parent, addr);\n\n\treturn result;\n}\n\n \nstatic int i2cdev_check_mux_children(struct device *dev, void *addrp)\n{\n\tint result;\n\n\tif (dev->type == &i2c_adapter_type)\n\t\tresult = device_for_each_child(dev, addrp,\n\t\t\t\t\t\ti2cdev_check_mux_children);\n\telse\n\t\tresult = i2cdev_check(dev, addrp);\n\n\treturn result;\n}\n\n \nstatic int i2cdev_check_addr(struct i2c_adapter *adapter, unsigned int addr)\n{\n\tstruct i2c_adapter *parent = i2c_parent_is_i2c_adapter(adapter);\n\tint result = 0;\n\n\tif (parent)\n\t\tresult = i2cdev_check_mux_parents(parent, addr);\n\n\tif (!result)\n\t\tresult = device_for_each_child(&adapter->dev, &addr,\n\t\t\t\t\t\ti2cdev_check_mux_children);\n\n\treturn result;\n}\n\nstatic noinline int i2cdev_ioctl_rdwr(struct i2c_client *client,\n\t\tunsigned nmsgs, struct i2c_msg *msgs)\n{\n\tu8 __user **data_ptrs;\n\tint i, res;\n\n\tdata_ptrs = kmalloc_array(nmsgs, sizeof(u8 __user *), GFP_KERNEL);\n\tif (data_ptrs == NULL) {\n\t\tkfree(msgs);\n\t\treturn -ENOMEM;\n\t}\n\n\tres = 0;\n\tfor (i = 0; i < nmsgs; i++) {\n\t\t \n\t\tif (msgs[i].len > 8192) {\n\t\t\tres = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tdata_ptrs[i] = (u8 __user *)msgs[i].buf;\n\t\tmsgs[i].buf = memdup_user(data_ptrs[i], msgs[i].len);\n\t\tif (IS_ERR(msgs[i].buf)) {\n\t\t\tres = PTR_ERR(msgs[i].buf);\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tmsgs[i].flags |= I2C_M_DMA_SAFE;\n\n\t\t \n\t\tif (msgs[i].flags & I2C_M_RECV_LEN) {\n\t\t\tif (!(msgs[i].flags & I2C_M_RD) ||\n\t\t\t    msgs[i].len < 1 || msgs[i].buf[0] < 1 ||\n\t\t\t    msgs[i].len < msgs[i].buf[0] +\n\t\t\t\t\t     I2C_SMBUS_BLOCK_MAX) {\n\t\t\t\ti++;\n\t\t\t\tres = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tmsgs[i].len = msgs[i].buf[0];\n\t\t}\n\t}\n\tif (res < 0) {\n\t\tint j;\n\t\tfor (j = 0; j < i; ++j)\n\t\t\tkfree(msgs[j].buf);\n\t\tkfree(data_ptrs);\n\t\tkfree(msgs);\n\t\treturn res;\n\t}\n\n\tres = i2c_transfer(client->adapter, msgs, nmsgs);\n\twhile (i-- > 0) {\n\t\tif (res >= 0 && (msgs[i].flags & I2C_M_RD)) {\n\t\t\tif (copy_to_user(data_ptrs[i], msgs[i].buf,\n\t\t\t\t\t msgs[i].len))\n\t\t\t\tres = -EFAULT;\n\t\t}\n\t\tkfree(msgs[i].buf);\n\t}\n\tkfree(data_ptrs);\n\tkfree(msgs);\n\treturn res;\n}\n\nstatic noinline int i2cdev_ioctl_smbus(struct i2c_client *client,\n\t\tu8 read_write, u8 command, u32 size,\n\t\tunion i2c_smbus_data __user *data)\n{\n\tunion i2c_smbus_data temp = {};\n\tint datasize, res;\n\n\tif ((size != I2C_SMBUS_BYTE) &&\n\t    (size != I2C_SMBUS_QUICK) &&\n\t    (size != I2C_SMBUS_BYTE_DATA) &&\n\t    (size != I2C_SMBUS_WORD_DATA) &&\n\t    (size != I2C_SMBUS_PROC_CALL) &&\n\t    (size != I2C_SMBUS_BLOCK_DATA) &&\n\t    (size != I2C_SMBUS_I2C_BLOCK_BROKEN) &&\n\t    (size != I2C_SMBUS_I2C_BLOCK_DATA) &&\n\t    (size != I2C_SMBUS_BLOCK_PROC_CALL)) {\n\t\tdev_dbg(&client->adapter->dev,\n\t\t\t\"size out of range (%x) in ioctl I2C_SMBUS.\\n\",\n\t\t\tsize);\n\t\treturn -EINVAL;\n\t}\n\t \n\tif ((read_write != I2C_SMBUS_READ) &&\n\t    (read_write != I2C_SMBUS_WRITE)) {\n\t\tdev_dbg(&client->adapter->dev,\n\t\t\t\"read_write out of range (%x) in ioctl I2C_SMBUS.\\n\",\n\t\t\tread_write);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\n\tif ((size == I2C_SMBUS_QUICK) ||\n\t    ((size == I2C_SMBUS_BYTE) &&\n\t    (read_write == I2C_SMBUS_WRITE)))\n\t\t \n\t\treturn i2c_smbus_xfer(client->adapter, client->addr,\n\t\t\t\t      client->flags, read_write,\n\t\t\t\t      command, size, NULL);\n\n\tif (data == NULL) {\n\t\tdev_dbg(&client->adapter->dev,\n\t\t\t\"data is NULL pointer in ioctl I2C_SMBUS.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif ((size == I2C_SMBUS_BYTE_DATA) ||\n\t    (size == I2C_SMBUS_BYTE))\n\t\tdatasize = sizeof(data->byte);\n\telse if ((size == I2C_SMBUS_WORD_DATA) ||\n\t\t (size == I2C_SMBUS_PROC_CALL))\n\t\tdatasize = sizeof(data->word);\n\telse  \n\t\tdatasize = sizeof(data->block);\n\n\tif ((size == I2C_SMBUS_PROC_CALL) ||\n\t    (size == I2C_SMBUS_BLOCK_PROC_CALL) ||\n\t    (size == I2C_SMBUS_I2C_BLOCK_DATA) ||\n\t    (read_write == I2C_SMBUS_WRITE)) {\n\t\tif (copy_from_user(&temp, data, datasize))\n\t\t\treturn -EFAULT;\n\t}\n\tif (size == I2C_SMBUS_I2C_BLOCK_BROKEN) {\n\t\t \n\t\tsize = I2C_SMBUS_I2C_BLOCK_DATA;\n\t\tif (read_write == I2C_SMBUS_READ)\n\t\t\ttemp.block[0] = I2C_SMBUS_BLOCK_MAX;\n\t}\n\tres = i2c_smbus_xfer(client->adapter, client->addr, client->flags,\n\t      read_write, command, size, &temp);\n\tif (!res && ((size == I2C_SMBUS_PROC_CALL) ||\n\t\t     (size == I2C_SMBUS_BLOCK_PROC_CALL) ||\n\t\t     (read_write == I2C_SMBUS_READ))) {\n\t\tif (copy_to_user(data, &temp, datasize))\n\t\t\treturn -EFAULT;\n\t}\n\treturn res;\n}\n\nstatic long i2cdev_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tstruct i2c_client *client = file->private_data;\n\tunsigned long funcs;\n\n\tdev_dbg(&client->adapter->dev, \"ioctl, cmd=0x%02x, arg=0x%02lx\\n\",\n\t\tcmd, arg);\n\n\tswitch (cmd) {\n\tcase I2C_SLAVE:\n\tcase I2C_SLAVE_FORCE:\n\t\tif ((arg > 0x3ff) ||\n\t\t    (((client->flags & I2C_M_TEN) == 0) && arg > 0x7f))\n\t\t\treturn -EINVAL;\n\t\tif (cmd == I2C_SLAVE && i2cdev_check_addr(client->adapter, arg))\n\t\t\treturn -EBUSY;\n\t\t \n\t\tclient->addr = arg;\n\t\treturn 0;\n\tcase I2C_TENBIT:\n\t\tif (arg)\n\t\t\tclient->flags |= I2C_M_TEN;\n\t\telse\n\t\t\tclient->flags &= ~I2C_M_TEN;\n\t\treturn 0;\n\tcase I2C_PEC:\n\t\t \n\t\tif (arg)\n\t\t\tclient->flags |= I2C_CLIENT_PEC;\n\t\telse\n\t\t\tclient->flags &= ~I2C_CLIENT_PEC;\n\t\treturn 0;\n\tcase I2C_FUNCS:\n\t\tfuncs = i2c_get_functionality(client->adapter);\n\t\treturn put_user(funcs, (unsigned long __user *)arg);\n\n\tcase I2C_RDWR: {\n\t\tstruct i2c_rdwr_ioctl_data rdwr_arg;\n\t\tstruct i2c_msg *rdwr_pa;\n\n\t\tif (copy_from_user(&rdwr_arg,\n\t\t\t\t   (struct i2c_rdwr_ioctl_data __user *)arg,\n\t\t\t\t   sizeof(rdwr_arg)))\n\t\t\treturn -EFAULT;\n\n\t\tif (!rdwr_arg.msgs || rdwr_arg.nmsgs == 0)\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tif (rdwr_arg.nmsgs > I2C_RDWR_IOCTL_MAX_MSGS)\n\t\t\treturn -EINVAL;\n\n\t\trdwr_pa = memdup_array_user(rdwr_arg.msgs,\n\t\t\t\t\t    rdwr_arg.nmsgs, sizeof(struct i2c_msg));\n\t\tif (IS_ERR(rdwr_pa))\n\t\t\treturn PTR_ERR(rdwr_pa);\n\n\t\treturn i2cdev_ioctl_rdwr(client, rdwr_arg.nmsgs, rdwr_pa);\n\t}\n\n\tcase I2C_SMBUS: {\n\t\tstruct i2c_smbus_ioctl_data data_arg;\n\t\tif (copy_from_user(&data_arg,\n\t\t\t\t   (struct i2c_smbus_ioctl_data __user *) arg,\n\t\t\t\t   sizeof(struct i2c_smbus_ioctl_data)))\n\t\t\treturn -EFAULT;\n\t\treturn i2cdev_ioctl_smbus(client, data_arg.read_write,\n\t\t\t\t\t  data_arg.command,\n\t\t\t\t\t  data_arg.size,\n\t\t\t\t\t  data_arg.data);\n\t}\n\tcase I2C_RETRIES:\n\t\tif (arg > INT_MAX)\n\t\t\treturn -EINVAL;\n\n\t\tclient->adapter->retries = arg;\n\t\tbreak;\n\tcase I2C_TIMEOUT:\n\t\tif (arg > INT_MAX)\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tclient->adapter->timeout = msecs_to_jiffies(arg * 10);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\treturn -ENOTTY;\n\t}\n\treturn 0;\n}\n\n#ifdef CONFIG_COMPAT\n\nstruct i2c_smbus_ioctl_data32 {\n\tu8 read_write;\n\tu8 command;\n\tu32 size;\n\tcompat_caddr_t data;  \n};\n\nstruct i2c_msg32 {\n\tu16 addr;\n\tu16 flags;\n\tu16 len;\n\tcompat_caddr_t buf;\n};\n\nstruct i2c_rdwr_ioctl_data32 {\n\tcompat_caddr_t msgs;  \n\tu32 nmsgs;\n};\n\nstatic long compat_i2cdev_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tstruct i2c_client *client = file->private_data;\n\tunsigned long funcs;\n\tswitch (cmd) {\n\tcase I2C_FUNCS:\n\t\tfuncs = i2c_get_functionality(client->adapter);\n\t\treturn put_user(funcs, (compat_ulong_t __user *)arg);\n\tcase I2C_RDWR: {\n\t\tstruct i2c_rdwr_ioctl_data32 rdwr_arg;\n\t\tstruct i2c_msg32 __user *p;\n\t\tstruct i2c_msg *rdwr_pa;\n\t\tint i;\n\n\t\tif (copy_from_user(&rdwr_arg,\n\t\t\t\t   (struct i2c_rdwr_ioctl_data32 __user *)arg,\n\t\t\t\t   sizeof(rdwr_arg)))\n\t\t\treturn -EFAULT;\n\n\t\tif (!rdwr_arg.msgs || rdwr_arg.nmsgs == 0)\n\t\t\treturn -EINVAL;\n\n\t\tif (rdwr_arg.nmsgs > I2C_RDWR_IOCTL_MAX_MSGS)\n\t\t\treturn -EINVAL;\n\n\t\trdwr_pa = kmalloc_array(rdwr_arg.nmsgs, sizeof(struct i2c_msg),\n\t\t\t\t      GFP_KERNEL);\n\t\tif (!rdwr_pa)\n\t\t\treturn -ENOMEM;\n\n\t\tp = compat_ptr(rdwr_arg.msgs);\n\t\tfor (i = 0; i < rdwr_arg.nmsgs; i++) {\n\t\t\tstruct i2c_msg32 umsg;\n\t\t\tif (copy_from_user(&umsg, p + i, sizeof(umsg))) {\n\t\t\t\tkfree(rdwr_pa);\n\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t\t\trdwr_pa[i] = (struct i2c_msg) {\n\t\t\t\t.addr = umsg.addr,\n\t\t\t\t.flags = umsg.flags,\n\t\t\t\t.len = umsg.len,\n\t\t\t\t.buf = (__force __u8 *)compat_ptr(umsg.buf),\n\t\t\t};\n\t\t}\n\n\t\treturn i2cdev_ioctl_rdwr(client, rdwr_arg.nmsgs, rdwr_pa);\n\t}\n\tcase I2C_SMBUS: {\n\t\tstruct i2c_smbus_ioctl_data32\tdata32;\n\t\tif (copy_from_user(&data32,\n\t\t\t\t   (void __user *) arg,\n\t\t\t\t   sizeof(data32)))\n\t\t\treturn -EFAULT;\n\t\treturn i2cdev_ioctl_smbus(client, data32.read_write,\n\t\t\t\t\t  data32.command,\n\t\t\t\t\t  data32.size,\n\t\t\t\t\t  compat_ptr(data32.data));\n\t}\n\tdefault:\n\t\treturn i2cdev_ioctl(file, cmd, arg);\n\t}\n}\n#else\n#define compat_i2cdev_ioctl NULL\n#endif\n\nstatic int i2cdev_open(struct inode *inode, struct file *file)\n{\n\tunsigned int minor = iminor(inode);\n\tstruct i2c_client *client;\n\tstruct i2c_adapter *adap;\n\n\tadap = i2c_get_adapter(minor);\n\tif (!adap)\n\t\treturn -ENODEV;\n\n\t \n\tclient = kzalloc(sizeof(*client), GFP_KERNEL);\n\tif (!client) {\n\t\ti2c_put_adapter(adap);\n\t\treturn -ENOMEM;\n\t}\n\tsnprintf(client->name, I2C_NAME_SIZE, \"i2c-dev %d\", adap->nr);\n\n\tclient->adapter = adap;\n\tfile->private_data = client;\n\n\treturn 0;\n}\n\nstatic int i2cdev_release(struct inode *inode, struct file *file)\n{\n\tstruct i2c_client *client = file->private_data;\n\n\ti2c_put_adapter(client->adapter);\n\tkfree(client);\n\tfile->private_data = NULL;\n\n\treturn 0;\n}\n\nstatic const struct file_operations i2cdev_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.llseek\t\t= no_llseek,\n\t.read\t\t= i2cdev_read,\n\t.write\t\t= i2cdev_write,\n\t.unlocked_ioctl\t= i2cdev_ioctl,\n\t.compat_ioctl\t= compat_i2cdev_ioctl,\n\t.open\t\t= i2cdev_open,\n\t.release\t= i2cdev_release,\n};\n\n \n\nstatic struct class *i2c_dev_class;\n\nstatic void i2cdev_dev_release(struct device *dev)\n{\n\tstruct i2c_dev *i2c_dev;\n\n\ti2c_dev = container_of(dev, struct i2c_dev, dev);\n\tkfree(i2c_dev);\n}\n\nstatic int i2cdev_attach_adapter(struct device *dev)\n{\n\tstruct i2c_adapter *adap;\n\tstruct i2c_dev *i2c_dev;\n\tint res;\n\n\tif (dev->type != &i2c_adapter_type)\n\t\treturn NOTIFY_DONE;\n\tadap = to_i2c_adapter(dev);\n\n\ti2c_dev = get_free_i2c_dev(adap);\n\tif (IS_ERR(i2c_dev))\n\t\treturn NOTIFY_DONE;\n\n\tcdev_init(&i2c_dev->cdev, &i2cdev_fops);\n\ti2c_dev->cdev.owner = THIS_MODULE;\n\n\tdevice_initialize(&i2c_dev->dev);\n\ti2c_dev->dev.devt = MKDEV(I2C_MAJOR, adap->nr);\n\ti2c_dev->dev.class = i2c_dev_class;\n\ti2c_dev->dev.parent = &adap->dev;\n\ti2c_dev->dev.release = i2cdev_dev_release;\n\n\tres = dev_set_name(&i2c_dev->dev, \"i2c-%d\", adap->nr);\n\tif (res)\n\t\tgoto err_put_i2c_dev;\n\n\tres = cdev_device_add(&i2c_dev->cdev, &i2c_dev->dev);\n\tif (res)\n\t\tgoto err_put_i2c_dev;\n\n\tpr_debug(\"adapter [%s] registered as minor %d\\n\", adap->name, adap->nr);\n\treturn NOTIFY_OK;\n\nerr_put_i2c_dev:\n\tput_i2c_dev(i2c_dev, false);\n\treturn NOTIFY_DONE;\n}\n\nstatic int i2cdev_detach_adapter(struct device *dev)\n{\n\tstruct i2c_adapter *adap;\n\tstruct i2c_dev *i2c_dev;\n\n\tif (dev->type != &i2c_adapter_type)\n\t\treturn NOTIFY_DONE;\n\tadap = to_i2c_adapter(dev);\n\n\ti2c_dev = i2c_dev_get_by_minor(adap->nr);\n\tif (!i2c_dev)  \n\t\treturn NOTIFY_DONE;\n\n\tput_i2c_dev(i2c_dev, true);\n\n\tpr_debug(\"adapter [%s] unregistered\\n\", adap->name);\n\treturn NOTIFY_OK;\n}\n\nstatic int i2cdev_notifier_call(struct notifier_block *nb, unsigned long action,\n\t\t\t void *data)\n{\n\tstruct device *dev = data;\n\n\tswitch (action) {\n\tcase BUS_NOTIFY_ADD_DEVICE:\n\t\treturn i2cdev_attach_adapter(dev);\n\tcase BUS_NOTIFY_DEL_DEVICE:\n\t\treturn i2cdev_detach_adapter(dev);\n\t}\n\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block i2cdev_notifier = {\n\t.notifier_call = i2cdev_notifier_call,\n};\n\n \n\nstatic int __init i2c_dev_attach_adapter(struct device *dev, void *dummy)\n{\n\ti2cdev_attach_adapter(dev);\n\treturn 0;\n}\n\nstatic int __exit i2c_dev_detach_adapter(struct device *dev, void *dummy)\n{\n\ti2cdev_detach_adapter(dev);\n\treturn 0;\n}\n\n \n\nstatic int __init i2c_dev_init(void)\n{\n\tint res;\n\n\tpr_info(\"i2c /dev entries driver\\n\");\n\n\tres = register_chrdev_region(MKDEV(I2C_MAJOR, 0), I2C_MINORS, \"i2c\");\n\tif (res)\n\t\tgoto out;\n\n\ti2c_dev_class = class_create(\"i2c-dev\");\n\tif (IS_ERR(i2c_dev_class)) {\n\t\tres = PTR_ERR(i2c_dev_class);\n\t\tgoto out_unreg_chrdev;\n\t}\n\ti2c_dev_class->dev_groups = i2c_groups;\n\n\t \n\tres = bus_register_notifier(&i2c_bus_type, &i2cdev_notifier);\n\tif (res)\n\t\tgoto out_unreg_class;\n\n\t \n\ti2c_for_each_dev(NULL, i2c_dev_attach_adapter);\n\n\treturn 0;\n\nout_unreg_class:\n\tclass_destroy(i2c_dev_class);\nout_unreg_chrdev:\n\tunregister_chrdev_region(MKDEV(I2C_MAJOR, 0), I2C_MINORS);\nout:\n\tpr_err(\"Driver Initialisation failed\\n\");\n\treturn res;\n}\n\nstatic void __exit i2c_dev_exit(void)\n{\n\tbus_unregister_notifier(&i2c_bus_type, &i2cdev_notifier);\n\ti2c_for_each_dev(NULL, i2c_dev_detach_adapter);\n\tclass_destroy(i2c_dev_class);\n\tunregister_chrdev_region(MKDEV(I2C_MAJOR, 0), I2C_MINORS);\n}\n\nMODULE_AUTHOR(\"Frodo Looijaard <frodol@dds.nl>\");\nMODULE_AUTHOR(\"Simon G. Vogl <simon@tk.uni-linz.ac.at>\");\nMODULE_DESCRIPTION(\"I2C /dev entries driver\");\nMODULE_LICENSE(\"GPL\");\n\nmodule_init(i2c_dev_init);\nmodule_exit(i2c_dev_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}