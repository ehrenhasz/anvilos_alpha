{
  "module_name": "loongson-laptop.c",
  "hash_id": "d90dffe677b643856186f48899a7f561d73dace3652f4424433212c6dba03bd8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/loongarch/loongson-laptop.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/acpi.h>\n#include <linux/backlight.h>\n#include <linux/device.h>\n#include <linux/input.h>\n#include <linux/input/sparse-keymap.h>\n#include <linux/platform_device.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <acpi/video.h>\n\n \n\n \n#define LOONGSON_ACPI_EC_HID\t\"PNP0C09\"\n#define LOONGSON_ACPI_HKEY_HID\t\"LOON0000\"\n\n#define ACPI_LAPTOP_NAME \"loongson-laptop\"\n#define ACPI_LAPTOP_ACPI_EVENT_PREFIX \"loongson\"\n\n#define MAX_ACPI_ARGS\t\t\t3\n#define GENERIC_HOTKEY_MAP_MAX\t\t64\n\n#define GENERIC_EVENT_TYPE_OFF\t\t12\n#define GENERIC_EVENT_TYPE_MASK\t\t0xF000\n#define GENERIC_EVENT_CODE_MASK\t\t0x0FFF\n\nstruct generic_sub_driver {\n\tu32 type;\n\tchar *name;\n\tacpi_handle *handle;\n\tstruct acpi_device *device;\n\tstruct platform_driver *driver;\n\tint (*init)(struct generic_sub_driver *sub_driver);\n\tvoid (*notify)(struct generic_sub_driver *sub_driver, u32 event);\n\tu8 acpi_notify_installed;\n};\n\nstatic u32 input_device_registered;\nstatic struct input_dev *generic_inputdev;\n\nstatic acpi_handle hotkey_handle;\nstatic struct key_entry hotkey_keycode_map[GENERIC_HOTKEY_MAP_MAX];\n\nint loongson_laptop_turn_on_backlight(void);\nint loongson_laptop_turn_off_backlight(void);\nstatic int loongson_laptop_backlight_update(struct backlight_device *bd);\n\n \n\nstatic int acpi_evalf(acpi_handle handle, int *res, char *method, char *fmt, ...)\n{\n\tchar res_type;\n\tchar *fmt0 = fmt;\n\tva_list ap;\n\tint success, quiet;\n\tacpi_status status;\n\tstruct acpi_object_list params;\n\tstruct acpi_buffer result, *resultp;\n\tunion acpi_object in_objs[MAX_ACPI_ARGS], out_obj;\n\n\tif (!*fmt) {\n\t\tpr_err(\"acpi_evalf() called with empty format\\n\");\n\t\treturn 0;\n\t}\n\n\tif (*fmt == 'q') {\n\t\tquiet = 1;\n\t\tfmt++;\n\t} else\n\t\tquiet = 0;\n\n\tres_type = *(fmt++);\n\n\tparams.count = 0;\n\tparams.pointer = &in_objs[0];\n\n\tva_start(ap, fmt);\n\twhile (*fmt) {\n\t\tchar c = *(fmt++);\n\t\tswitch (c) {\n\t\tcase 'd':\t \n\t\t\tin_objs[params.count].integer.value = va_arg(ap, int);\n\t\t\tin_objs[params.count++].type = ACPI_TYPE_INTEGER;\n\t\t\tbreak;\n\t\t\t \n\t\tdefault:\n\t\t\tpr_err(\"acpi_evalf() called with invalid format character '%c'\\n\", c);\n\t\t\tva_end(ap);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tva_end(ap);\n\n\tif (res_type != 'v') {\n\t\tresult.length = sizeof(out_obj);\n\t\tresult.pointer = &out_obj;\n\t\tresultp = &result;\n\t} else\n\t\tresultp = NULL;\n\n\tstatus = acpi_evaluate_object(handle, method, &params, resultp);\n\n\tswitch (res_type) {\n\tcase 'd':\t\t \n\t\tsuccess = (status == AE_OK && out_obj.type == ACPI_TYPE_INTEGER);\n\t\tif (success && res)\n\t\t\t*res = out_obj.integer.value;\n\t\tbreak;\n\tcase 'v':\t\t \n\t\tsuccess = status == AE_OK;\n\t\tbreak;\n\t\t \n\tdefault:\n\t\tpr_err(\"acpi_evalf() called with invalid format character '%c'\\n\", res_type);\n\t\treturn 0;\n\t}\n\n\tif (!success && !quiet)\n\t\tpr_err(\"acpi_evalf(%s, %s, ...) failed: %s\\n\",\n\t\t       method, fmt0, acpi_format_exception(status));\n\n\treturn success;\n}\n\nstatic int hotkey_status_get(int *status)\n{\n\tif (!acpi_evalf(hotkey_handle, status, \"GSWS\", \"d\"))\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic void dispatch_acpi_notify(acpi_handle handle, u32 event, void *data)\n{\n\tstruct generic_sub_driver *sub_driver = data;\n\n\tif (!sub_driver || !sub_driver->notify)\n\t\treturn;\n\tsub_driver->notify(sub_driver, event);\n}\n\nstatic int __init setup_acpi_notify(struct generic_sub_driver *sub_driver)\n{\n\tacpi_status status;\n\n\tif (!*sub_driver->handle)\n\t\treturn 0;\n\n\tsub_driver->device = acpi_fetch_acpi_dev(*sub_driver->handle);\n\tif (!sub_driver->device) {\n\t\tpr_err(\"acpi_fetch_acpi_dev(%s) failed\\n\", sub_driver->name);\n\t\treturn -ENODEV;\n\t}\n\n\tsub_driver->device->driver_data = sub_driver;\n\tsprintf(acpi_device_class(sub_driver->device), \"%s/%s\",\n\t\tACPI_LAPTOP_ACPI_EVENT_PREFIX, sub_driver->name);\n\n\tstatus = acpi_install_notify_handler(*sub_driver->handle,\n\t\t\tsub_driver->type, dispatch_acpi_notify, sub_driver);\n\tif (ACPI_FAILURE(status)) {\n\t\tif (status == AE_ALREADY_EXISTS) {\n\t\t\tpr_notice(\"Another device driver is already \"\n\t\t\t\t  \"handling %s events\\n\", sub_driver->name);\n\t\t} else {\n\t\t\tpr_err(\"acpi_install_notify_handler(%s) failed: %s\\n\",\n\t\t\t       sub_driver->name, acpi_format_exception(status));\n\t\t}\n\t\treturn -ENODEV;\n\t}\n\tsub_driver->acpi_notify_installed = 1;\n\n\treturn 0;\n}\n\nstatic int loongson_hotkey_suspend(struct device *dev)\n{\n\treturn 0;\n}\n\nstatic int loongson_hotkey_resume(struct device *dev)\n{\n\tint status = 0;\n\tstruct key_entry ke;\n\tstruct backlight_device *bd;\n\n\tbd = backlight_device_get_by_type(BACKLIGHT_PLATFORM);\n\tif (bd) {\n\t\tloongson_laptop_backlight_update(bd) ?\n\t\tpr_warn(\"Loongson_backlight: resume brightness failed\") :\n\t\tpr_info(\"Loongson_backlight: resume brightness %d\\n\", bd->props.brightness);\n\t}\n\n\t \n\tif (test_bit(SW_LID, generic_inputdev->swbit)) {\n\t\tif (hotkey_status_get(&status) < 0)\n\t\t\treturn -EIO;\n\t\t \n\t\tif (test_bit(SW_LID, generic_inputdev->sw) && !(status & (1 << SW_LID))) {\n\t\t\tke.type = KE_SW;\n\t\t\tke.sw.value = (u8)status;\n\t\t\tke.sw.code = SW_LID;\n\t\t\tsparse_keymap_report_entry(generic_inputdev, &ke, 1, true);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(loongson_hotkey_pm,\n\t\tloongson_hotkey_suspend, loongson_hotkey_resume);\n\nstatic int loongson_hotkey_probe(struct platform_device *pdev)\n{\n\thotkey_handle = ACPI_HANDLE(&pdev->dev);\n\n\tif (!hotkey_handle)\n\t\treturn -ENODEV;\n\n\treturn 0;\n}\n\nstatic const struct acpi_device_id loongson_device_ids[] = {\n\t{LOONGSON_ACPI_HKEY_HID, 0},\n\t{\"\", 0},\n};\nMODULE_DEVICE_TABLE(acpi, loongson_device_ids);\n\nstatic struct platform_driver loongson_hotkey_driver = {\n\t.probe\t\t= loongson_hotkey_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"loongson-hotkey\",\n\t\t.owner\t= THIS_MODULE,\n\t\t.pm\t= pm_ptr(&loongson_hotkey_pm),\n\t\t.acpi_match_table = loongson_device_ids,\n\t},\n};\n\nstatic int hotkey_map(void)\n{\n\tu32 index;\n\tacpi_status status;\n\tstruct acpi_buffer buf;\n\tunion acpi_object *pack;\n\n\tbuf.length = ACPI_ALLOCATE_BUFFER;\n\tstatus = acpi_evaluate_object_typed(hotkey_handle, \"KMAP\", NULL, &buf, ACPI_TYPE_PACKAGE);\n\tif (status != AE_OK) {\n\t\tpr_err(\"ACPI exception: %s\\n\", acpi_format_exception(status));\n\t\treturn -1;\n\t}\n\tpack = buf.pointer;\n\tfor (index = 0; index < pack->package.count; index++) {\n\t\tunion acpi_object *element, *sub_pack;\n\n\t\tsub_pack = &pack->package.elements[index];\n\n\t\telement = &sub_pack->package.elements[0];\n\t\thotkey_keycode_map[index].type = element->integer.value;\n\t\telement = &sub_pack->package.elements[1];\n\t\thotkey_keycode_map[index].code = element->integer.value;\n\t\telement = &sub_pack->package.elements[2];\n\t\thotkey_keycode_map[index].keycode = element->integer.value;\n\t}\n\n\treturn 0;\n}\n\nstatic int hotkey_backlight_set(bool enable)\n{\n\tif (!acpi_evalf(hotkey_handle, NULL, \"VCBL\", \"vd\", enable ? 1 : 0))\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic int ec_get_brightness(void)\n{\n\tint status = 0;\n\n\tif (!hotkey_handle)\n\t\treturn -ENXIO;\n\n\tif (!acpi_evalf(hotkey_handle, &status, \"ECBG\", \"d\"))\n\t\treturn -EIO;\n\n\treturn status;\n}\n\nstatic int ec_set_brightness(int level)\n{\n\n\tint ret = 0;\n\n\tif (!hotkey_handle)\n\t\treturn -ENXIO;\n\n\tif (!acpi_evalf(hotkey_handle, NULL, \"ECBS\", \"vd\", level))\n\t\tret = -EIO;\n\n\treturn ret;\n}\n\nstatic int ec_backlight_level(u8 level)\n{\n\tint status = 0;\n\n\tif (!hotkey_handle)\n\t\treturn -ENXIO;\n\n\tif (!acpi_evalf(hotkey_handle, &status, \"ECLL\", \"d\"))\n\t\treturn -EIO;\n\n\tif ((status < 0) || (level > status))\n\t\treturn status;\n\n\tif (!acpi_evalf(hotkey_handle, &status, \"ECSL\", \"d\"))\n\t\treturn -EIO;\n\n\tif ((status < 0) || (level < status))\n\t\treturn status;\n\n\treturn level;\n}\n\nstatic int loongson_laptop_backlight_update(struct backlight_device *bd)\n{\n\tint lvl = ec_backlight_level(bd->props.brightness);\n\n\tif (lvl < 0)\n\t\treturn -EIO;\n\tif (ec_set_brightness(lvl))\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic int loongson_laptop_get_brightness(struct backlight_device *bd)\n{\n\tint level;\n\n\tlevel = ec_get_brightness();\n\tif (level < 0)\n\t\treturn -EIO;\n\n\treturn level;\n}\n\nstatic const struct backlight_ops backlight_laptop_ops = {\n\t.update_status = loongson_laptop_backlight_update,\n\t.get_brightness = loongson_laptop_get_brightness,\n};\n\nstatic int laptop_backlight_register(void)\n{\n\tint status = 0;\n\tstruct backlight_properties props;\n\n\tmemset(&props, 0, sizeof(props));\n\n\tif (!acpi_evalf(hotkey_handle, &status, \"ECLL\", \"d\"))\n\t\treturn -EIO;\n\n\tprops.brightness = 1;\n\tprops.max_brightness = status;\n\tprops.type = BACKLIGHT_PLATFORM;\n\n\tbacklight_device_register(\"loongson_laptop\",\n\t\t\t\tNULL, NULL, &backlight_laptop_ops, &props);\n\n\treturn 0;\n}\n\nint loongson_laptop_turn_on_backlight(void)\n{\n\tint status;\n\tunion acpi_object arg0 = { ACPI_TYPE_INTEGER };\n\tstruct acpi_object_list args = { 1, &arg0 };\n\n\targ0.integer.value = 1;\n\tstatus = acpi_evaluate_object(NULL, \"\\\\BLSW\", &args, NULL);\n\tif (ACPI_FAILURE(status)) {\n\t\tpr_info(\"Loongson lvds error: 0x%x\\n\", status);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nint loongson_laptop_turn_off_backlight(void)\n{\n\tint status;\n\tunion acpi_object arg0 = { ACPI_TYPE_INTEGER };\n\tstruct acpi_object_list args = { 1, &arg0 };\n\n\targ0.integer.value = 0;\n\tstatus = acpi_evaluate_object(NULL, \"\\\\BLSW\", &args, NULL);\n\tif (ACPI_FAILURE(status)) {\n\t\tpr_info(\"Loongson lvds error: 0x%x\\n\", status);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic int __init event_init(struct generic_sub_driver *sub_driver)\n{\n\tint ret;\n\n\tret = hotkey_map();\n\tif (ret < 0) {\n\t\tpr_err(\"Failed to parse keymap from DSDT\\n\");\n\t\treturn ret;\n\t}\n\n\tret = sparse_keymap_setup(generic_inputdev, hotkey_keycode_map, NULL);\n\tif (ret < 0) {\n\t\tpr_err(\"Failed to setup input device keymap\\n\");\n\t\tinput_free_device(generic_inputdev);\n\t\tgeneric_inputdev = NULL;\n\n\t\treturn ret;\n\t}\n\n\t \n\tif (acpi_video_get_backlight_type() == acpi_backlight_vendor)\n\t\thotkey_backlight_set(true);\n\telse\n\t\thotkey_backlight_set(false);\n\n\tpr_info(\"ACPI: enabling firmware HKEY event interface...\\n\");\n\n\treturn ret;\n}\n\nstatic void event_notify(struct generic_sub_driver *sub_driver, u32 event)\n{\n\tint type, scan_code;\n\tstruct key_entry *ke = NULL;\n\n\tscan_code = event & GENERIC_EVENT_CODE_MASK;\n\ttype = (event & GENERIC_EVENT_TYPE_MASK) >> GENERIC_EVENT_TYPE_OFF;\n\tke = sparse_keymap_entry_from_scancode(generic_inputdev, scan_code);\n\tif (ke) {\n\t\tif (type == KE_SW) {\n\t\t\tint status = 0;\n\n\t\t\tif (hotkey_status_get(&status) < 0)\n\t\t\t\treturn;\n\n\t\t\tke->sw.value = !!(status & (1 << ke->sw.code));\n\t\t}\n\t\tsparse_keymap_report_entry(generic_inputdev, ke, 1, true);\n\t}\n}\n\n \n\nstatic void generic_subdriver_exit(struct generic_sub_driver *sub_driver);\n\nstatic int __init generic_subdriver_init(struct generic_sub_driver *sub_driver)\n{\n\tint ret;\n\n\tif (!sub_driver || !sub_driver->driver)\n\t\treturn -EINVAL;\n\n\tret = platform_driver_register(sub_driver->driver);\n\tif (ret)\n\t\treturn -EINVAL;\n\n\tif (sub_driver->init) {\n\t\tret = sub_driver->init(sub_driver);\n\t\tif (ret)\n\t\t\tgoto err_out;\n\t}\n\n\tif (sub_driver->notify) {\n\t\tret = setup_acpi_notify(sub_driver);\n\t\tif (ret == -ENODEV) {\n\t\t\tret = 0;\n\t\t\tgoto err_out;\n\t\t}\n\t\tif (ret < 0)\n\t\t\tgoto err_out;\n\t}\n\n\treturn 0;\n\nerr_out:\n\tgeneric_subdriver_exit(sub_driver);\n\treturn ret;\n}\n\nstatic void generic_subdriver_exit(struct generic_sub_driver *sub_driver)\n{\n\n\tif (sub_driver->acpi_notify_installed) {\n\t\tacpi_remove_notify_handler(*sub_driver->handle,\n\t\t\t\t\t   sub_driver->type, dispatch_acpi_notify);\n\t\tsub_driver->acpi_notify_installed = 0;\n\t}\n\tplatform_driver_unregister(sub_driver->driver);\n}\n\nstatic struct generic_sub_driver generic_sub_drivers[] __refdata = {\n\t{\n\t\t.name = \"hotkey\",\n\t\t.init = event_init,\n\t\t.notify = event_notify,\n\t\t.handle = &hotkey_handle,\n\t\t.type = ACPI_DEVICE_NOTIFY,\n\t\t.driver = &loongson_hotkey_driver,\n\t},\n};\n\nstatic int __init generic_acpi_laptop_init(void)\n{\n\tbool ec_found;\n\tint i, ret, status;\n\n\tif (acpi_disabled)\n\t\treturn -ENODEV;\n\n\t \n\tec_found = acpi_dev_found(LOONGSON_ACPI_EC_HID);\n\tif (!ec_found)\n\t\treturn -ENODEV;\n\n\t \n\tacpi_write_bit_register(ACPI_BITREG_SCI_ENABLE, 1);\n\n\tgeneric_inputdev = input_allocate_device();\n\tif (!generic_inputdev) {\n\t\tpr_err(\"Unable to allocate input device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tgeneric_inputdev->name =\n\t\t\"Loongson Generic Laptop/All-in-One Extra Buttons\";\n\tgeneric_inputdev->phys = ACPI_LAPTOP_NAME \"/input0\";\n\tgeneric_inputdev->id.bustype = BUS_HOST;\n\tgeneric_inputdev->dev.parent = NULL;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(generic_sub_drivers); i++) {\n\t\tret = generic_subdriver_init(&generic_sub_drivers[i]);\n\t\tif (ret < 0) {\n\t\t\tinput_free_device(generic_inputdev);\n\t\t\twhile (--i >= 0)\n\t\t\t\tgeneric_subdriver_exit(&generic_sub_drivers[i]);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = input_register_device(generic_inputdev);\n\tif (ret < 0) {\n\t\tinput_free_device(generic_inputdev);\n\t\twhile (--i >= 0)\n\t\t\tgeneric_subdriver_exit(&generic_sub_drivers[i]);\n\t\tpr_err(\"Unable to register input device\\n\");\n\t\treturn ret;\n\t}\n\n\tinput_device_registered = 1;\n\n\tif (acpi_evalf(hotkey_handle, &status, \"ECBG\", \"d\")) {\n\t\tpr_info(\"Loongson Laptop used, init brightness is 0x%x\\n\", status);\n\t\tret = laptop_backlight_register();\n\t\tif (ret < 0)\n\t\t\tpr_err(\"Loongson Laptop: laptop-backlight device register failed\\n\");\n\t}\n\n\treturn 0;\n}\n\nstatic void __exit generic_acpi_laptop_exit(void)\n{\n\tif (generic_inputdev) {\n\t\tif (input_device_registered)\n\t\t\tinput_unregister_device(generic_inputdev);\n\t\telse\n\t\t\tinput_free_device(generic_inputdev);\n\t}\n}\n\nmodule_init(generic_acpi_laptop_init);\nmodule_exit(generic_acpi_laptop_exit);\n\nMODULE_AUTHOR(\"Jianmin Lv <lvjianmin@loongson.cn>\");\nMODULE_AUTHOR(\"Huacai Chen <chenhuacai@loongson.cn>\");\nMODULE_DESCRIPTION(\"Loongson Laptop/All-in-One ACPI Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}