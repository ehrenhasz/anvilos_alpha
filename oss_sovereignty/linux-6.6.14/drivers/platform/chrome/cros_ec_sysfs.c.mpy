{
  "module_name": "cros_ec_sysfs.c",
  "hash_id": "17ce5b3ea3285bf1b6288aaedcac1c81c0332fbcc145b440bd596a935858c43c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/chrome/cros_ec_sysfs.c",
  "human_readable_source": "\n\n\n\n\n#include <linux/ctype.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/fs.h>\n#include <linux/kobject.h>\n#include <linux/module.h>\n#include <linux/platform_data/cros_ec_commands.h>\n#include <linux/platform_data/cros_ec_proto.h>\n#include <linux/platform_device.h>\n#include <linux/printk.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/types.h>\n#include <linux/uaccess.h>\n\n#define DRV_NAME \"cros-ec-sysfs\"\n\n \n\nstatic ssize_t reboot_show(struct device *dev,\n\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tint count = 0;\n\n\tcount += sysfs_emit_at(buf, count,\n\t\t\t       \"ro|rw|cancel|cold|disable-jump|hibernate|cold-ap-off\");\n\tcount += sysfs_emit_at(buf, count, \" [at-shutdown]\\n\");\n\treturn count;\n}\n\nstatic ssize_t reboot_store(struct device *dev,\n\t\t\t    struct device_attribute *attr,\n\t\t\t    const char *buf, size_t count)\n{\n\tstatic const struct {\n\t\tconst char * const str;\n\t\tuint8_t cmd;\n\t\tuint8_t flags;\n\t} words[] = {\n\t\t{\"cancel\",       EC_REBOOT_CANCEL, 0},\n\t\t{\"ro\",           EC_REBOOT_JUMP_RO, 0},\n\t\t{\"rw\",           EC_REBOOT_JUMP_RW, 0},\n\t\t{\"cold-ap-off\",  EC_REBOOT_COLD_AP_OFF, 0},\n\t\t{\"cold\",         EC_REBOOT_COLD, 0},\n\t\t{\"disable-jump\", EC_REBOOT_DISABLE_JUMP, 0},\n\t\t{\"hibernate\",    EC_REBOOT_HIBERNATE, 0},\n\t\t{\"at-shutdown\",  -1, EC_REBOOT_FLAG_ON_AP_SHUTDOWN},\n\t};\n\tstruct cros_ec_command *msg;\n\tstruct ec_params_reboot_ec *param;\n\tint got_cmd = 0, offset = 0;\n\tint i;\n\tint ret;\n\tstruct cros_ec_dev *ec = to_cros_ec_dev(dev);\n\n\tmsg = kmalloc(sizeof(*msg) + sizeof(*param), GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\tparam = (struct ec_params_reboot_ec *)msg->data;\n\n\tparam->flags = 0;\n\twhile (1) {\n\t\t \n\t\twhile (buf[offset] && isspace(buf[offset]))\n\t\t\toffset++;\n\t\tif (!buf[offset])\n\t\t\tbreak;\n\n\t\tfor (i = 0; i < ARRAY_SIZE(words); i++) {\n\t\t\tif (!strncasecmp(words[i].str, buf+offset,\n\t\t\t\t\t strlen(words[i].str))) {\n\t\t\t\tif (words[i].flags) {\n\t\t\t\t\tparam->flags |= words[i].flags;\n\t\t\t\t} else {\n\t\t\t\t\tparam->cmd = words[i].cmd;\n\t\t\t\t\tgot_cmd = 1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\twhile (buf[offset] && !isspace(buf[offset]))\n\t\t\toffset++;\n\t}\n\n\tif (!got_cmd) {\n\t\tcount = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\tmsg->version = 0;\n\tmsg->command = EC_CMD_REBOOT_EC + ec->cmd_offset;\n\tmsg->outsize = sizeof(*param);\n\tmsg->insize = 0;\n\tret = cros_ec_cmd_xfer_status(ec->ec_dev, msg);\n\tif (ret < 0)\n\t\tcount = ret;\nexit:\n\tkfree(msg);\n\treturn count;\n}\n\nstatic ssize_t version_show(struct device *dev,\n\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstatic const char * const image_names[] = {\"unknown\", \"RO\", \"RW\"};\n\tstruct ec_response_get_version *r_ver;\n\tstruct ec_response_get_chip_info *r_chip;\n\tstruct ec_response_board_version *r_board;\n\tstruct cros_ec_command *msg;\n\tint ret;\n\tint count = 0;\n\tstruct cros_ec_dev *ec = to_cros_ec_dev(dev);\n\n\tmsg = kmalloc(sizeof(*msg) + EC_HOST_PARAM_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\t \n\tmsg->version = 0;\n\tmsg->command = EC_CMD_GET_VERSION + ec->cmd_offset;\n\tmsg->insize = sizeof(*r_ver);\n\tmsg->outsize = 0;\n\tret = cros_ec_cmd_xfer_status(ec->ec_dev, msg);\n\tif (ret < 0) {\n\t\tcount = ret;\n\t\tgoto exit;\n\t}\n\tr_ver = (struct ec_response_get_version *)msg->data;\n\t \n\tr_ver->version_string_ro[sizeof(r_ver->version_string_ro) - 1] = '\\0';\n\tr_ver->version_string_rw[sizeof(r_ver->version_string_rw) - 1] = '\\0';\n\tcount += sysfs_emit_at(buf, count, \"RO version:    %s\\n\", r_ver->version_string_ro);\n\tcount += sysfs_emit_at(buf, count, \"RW version:    %s\\n\", r_ver->version_string_rw);\n\tcount += sysfs_emit_at(buf, count, \"Firmware copy: %s\\n\",\n\t\t\t   (r_ver->current_image < ARRAY_SIZE(image_names) ?\n\t\t\t    image_names[r_ver->current_image] : \"?\"));\n\n\t \n\tmsg->command = EC_CMD_GET_BUILD_INFO + ec->cmd_offset;\n\tmsg->insize = EC_HOST_PARAM_SIZE;\n\tret = cros_ec_cmd_xfer_status(ec->ec_dev, msg);\n\tif (ret < 0) {\n\t\tcount += sysfs_emit_at(buf, count,\n\t\t\t\t   \"Build info:    XFER / EC ERROR %d / %d\\n\",\n\t\t\t\t   ret, msg->result);\n\t} else {\n\t\tmsg->data[EC_HOST_PARAM_SIZE - 1] = '\\0';\n\t\tcount += sysfs_emit_at(buf, count, \"Build info:    %s\\n\", msg->data);\n\t}\n\n\t \n\tmsg->command = EC_CMD_GET_CHIP_INFO + ec->cmd_offset;\n\tmsg->insize = sizeof(*r_chip);\n\tret = cros_ec_cmd_xfer_status(ec->ec_dev, msg);\n\tif (ret < 0) {\n\t\tcount += sysfs_emit_at(buf, count,\n\t\t\t\t   \"Chip info:     XFER / EC ERROR %d / %d\\n\",\n\t\t\t\t   ret, msg->result);\n\t} else {\n\t\tr_chip = (struct ec_response_get_chip_info *)msg->data;\n\n\t\tr_chip->vendor[sizeof(r_chip->vendor) - 1] = '\\0';\n\t\tr_chip->name[sizeof(r_chip->name) - 1] = '\\0';\n\t\tr_chip->revision[sizeof(r_chip->revision) - 1] = '\\0';\n\t\tcount += sysfs_emit_at(buf, count, \"Chip vendor:   %s\\n\", r_chip->vendor);\n\t\tcount += sysfs_emit_at(buf, count, \"Chip name:     %s\\n\", r_chip->name);\n\t\tcount += sysfs_emit_at(buf, count, \"Chip revision: %s\\n\", r_chip->revision);\n\t}\n\n\t \n\tmsg->command = EC_CMD_GET_BOARD_VERSION + ec->cmd_offset;\n\tmsg->insize = sizeof(*r_board);\n\tret = cros_ec_cmd_xfer_status(ec->ec_dev, msg);\n\tif (ret < 0) {\n\t\tcount += sysfs_emit_at(buf, count,\n\t\t\t\t   \"Board version: XFER / EC ERROR %d / %d\\n\",\n\t\t\t\t   ret, msg->result);\n\t} else {\n\t\tr_board = (struct ec_response_board_version *)msg->data;\n\n\t\tcount += sysfs_emit_at(buf, count,\n\t\t\t\t   \"Board version: %d\\n\",\n\t\t\t\t   r_board->board_version);\n\t}\n\nexit:\n\tkfree(msg);\n\treturn count;\n}\n\nstatic ssize_t flashinfo_show(struct device *dev,\n\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tstruct ec_response_flash_info *resp;\n\tstruct cros_ec_command *msg;\n\tint ret;\n\tstruct cros_ec_dev *ec = to_cros_ec_dev(dev);\n\n\tmsg = kmalloc(sizeof(*msg) + sizeof(*resp), GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\t \n\tmsg->version = 0;\n\tmsg->command = EC_CMD_FLASH_INFO + ec->cmd_offset;\n\tmsg->insize = sizeof(*resp);\n\tmsg->outsize = 0;\n\tret = cros_ec_cmd_xfer_status(ec->ec_dev, msg);\n\tif (ret < 0)\n\t\tgoto exit;\n\n\tresp = (struct ec_response_flash_info *)msg->data;\n\n\tret = sysfs_emit(buf,\n\t\t\t\"FlashSize %d\\nWriteSize %d\\n\"\n\t\t\t\"EraseSize %d\\nProtectSize %d\\n\",\n\t\t\tresp->flash_size, resp->write_block_size,\n\t\t\tresp->erase_block_size, resp->protect_block_size);\nexit:\n\tkfree(msg);\n\treturn ret;\n}\n\n \nstatic ssize_t kb_wake_angle_show(struct device *dev,\n\t\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tstruct cros_ec_dev *ec = to_cros_ec_dev(dev);\n\tstruct ec_response_motion_sense *resp;\n\tstruct ec_params_motion_sense *param;\n\tstruct cros_ec_command *msg;\n\tint ret;\n\n\tmsg = kmalloc(sizeof(*msg) + EC_HOST_PARAM_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\tparam = (struct ec_params_motion_sense *)msg->data;\n\tmsg->command = EC_CMD_MOTION_SENSE_CMD + ec->cmd_offset;\n\tmsg->version = 2;\n\tparam->cmd = MOTIONSENSE_CMD_KB_WAKE_ANGLE;\n\tparam->kb_wake_angle.data = EC_MOTION_SENSE_NO_VALUE;\n\tmsg->outsize = sizeof(*param);\n\tmsg->insize = sizeof(*resp);\n\n\tret = cros_ec_cmd_xfer_status(ec->ec_dev, msg);\n\tif (ret < 0)\n\t\tgoto exit;\n\n\tresp = (struct ec_response_motion_sense *)msg->data;\n\tret = sysfs_emit(buf, \"%d\\n\", resp->kb_wake_angle.ret);\nexit:\n\tkfree(msg);\n\treturn ret;\n}\n\nstatic ssize_t kb_wake_angle_store(struct device *dev,\n\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t   const char *buf, size_t count)\n{\n\tstruct cros_ec_dev *ec = to_cros_ec_dev(dev);\n\tstruct ec_params_motion_sense *param;\n\tstruct cros_ec_command *msg;\n\tu16 angle;\n\tint ret;\n\n\tret = kstrtou16(buf, 0, &angle);\n\tif (ret)\n\t\treturn ret;\n\n\tmsg = kmalloc(sizeof(*msg) + EC_HOST_PARAM_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\tparam = (struct ec_params_motion_sense *)msg->data;\n\tmsg->command = EC_CMD_MOTION_SENSE_CMD + ec->cmd_offset;\n\tmsg->version = 2;\n\tparam->cmd = MOTIONSENSE_CMD_KB_WAKE_ANGLE;\n\tparam->kb_wake_angle.data = angle;\n\tmsg->outsize = sizeof(*param);\n\tmsg->insize = sizeof(struct ec_response_motion_sense);\n\n\tret = cros_ec_cmd_xfer_status(ec->ec_dev, msg);\n\tkfree(msg);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn count;\n}\n\n \n\nstatic DEVICE_ATTR_RW(reboot);\nstatic DEVICE_ATTR_RO(version);\nstatic DEVICE_ATTR_RO(flashinfo);\nstatic DEVICE_ATTR_RW(kb_wake_angle);\n\nstatic struct attribute *__ec_attrs[] = {\n\t&dev_attr_kb_wake_angle.attr,\n\t&dev_attr_reboot.attr,\n\t&dev_attr_version.attr,\n\t&dev_attr_flashinfo.attr,\n\tNULL,\n};\n\nstatic umode_t cros_ec_ctrl_visible(struct kobject *kobj,\n\t\t\t\t    struct attribute *a, int n)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct cros_ec_dev *ec = to_cros_ec_dev(dev);\n\n\tif (a == &dev_attr_kb_wake_angle.attr && !ec->has_kb_wake_angle)\n\t\treturn 0;\n\n\treturn a->mode;\n}\n\nstatic const struct attribute_group cros_ec_attr_group = {\n\t.attrs = __ec_attrs,\n\t.is_visible = cros_ec_ctrl_visible,\n};\n\nstatic int cros_ec_sysfs_probe(struct platform_device *pd)\n{\n\tstruct cros_ec_dev *ec_dev = dev_get_drvdata(pd->dev.parent);\n\tstruct device *dev = &pd->dev;\n\tint ret;\n\n\tret = sysfs_create_group(&ec_dev->class_dev.kobj, &cros_ec_attr_group);\n\tif (ret < 0)\n\t\tdev_err(dev, \"failed to create attributes. err=%d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int cros_ec_sysfs_remove(struct platform_device *pd)\n{\n\tstruct cros_ec_dev *ec_dev = dev_get_drvdata(pd->dev.parent);\n\n\tsysfs_remove_group(&ec_dev->class_dev.kobj, &cros_ec_attr_group);\n\n\treturn 0;\n}\n\nstatic struct platform_driver cros_ec_sysfs_driver = {\n\t.driver = {\n\t\t.name = DRV_NAME,\n\t},\n\t.probe = cros_ec_sysfs_probe,\n\t.remove = cros_ec_sysfs_remove,\n};\n\nmodule_platform_driver(cros_ec_sysfs_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Expose the ChromeOS EC through sysfs\");\nMODULE_ALIAS(\"platform:\" DRV_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}