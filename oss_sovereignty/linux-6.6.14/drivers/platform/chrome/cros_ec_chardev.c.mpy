{
  "module_name": "cros_ec_chardev.c",
  "hash_id": "fe934391af7e5a6629218d07bd9e4227753c09d8cd670ae98d48d5f6b6470aa4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/chrome/cros_ec_chardev.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/fs.h>\n#include <linux/miscdevice.h>\n#include <linux/module.h>\n#include <linux/notifier.h>\n#include <linux/platform_data/cros_ec_chardev.h>\n#include <linux/platform_data/cros_ec_commands.h>\n#include <linux/platform_data/cros_ec_proto.h>\n#include <linux/platform_device.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/uaccess.h>\n\n#define DRV_NAME\t\t\"cros-ec-chardev\"\n\n \n#define CROS_MAX_EVENT_LEN\tPAGE_SIZE\n\nstruct chardev_data {\n\tstruct cros_ec_dev *ec_dev;\n\tstruct miscdevice misc;\n};\n\nstruct chardev_priv {\n\tstruct cros_ec_dev *ec_dev;\n\tstruct notifier_block notifier;\n\twait_queue_head_t wait_event;\n\tunsigned long event_mask;\n\tstruct list_head events;\n\tsize_t event_len;\n};\n\nstruct ec_event {\n\tstruct list_head node;\n\tsize_t size;\n\tu8 event_type;\n\tu8 data[];\n};\n\nstatic int ec_get_version(struct cros_ec_dev *ec, char *str, int maxlen)\n{\n\tstatic const char * const current_image_name[] = {\n\t\t\"unknown\", \"read-only\", \"read-write\", \"invalid\",\n\t};\n\tstruct ec_response_get_version *resp;\n\tstruct cros_ec_command *msg;\n\tint ret;\n\n\tmsg = kzalloc(sizeof(*msg) + sizeof(*resp), GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\tmsg->command = EC_CMD_GET_VERSION + ec->cmd_offset;\n\tmsg->insize = sizeof(*resp);\n\n\tret = cros_ec_cmd_xfer_status(ec->ec_dev, msg);\n\tif (ret < 0) {\n\t\tsnprintf(str, maxlen,\n\t\t\t \"Unknown EC version, returned error: %d\\n\",\n\t\t\t msg->result);\n\t\tgoto exit;\n\t}\n\n\tresp = (struct ec_response_get_version *)msg->data;\n\tif (resp->current_image >= ARRAY_SIZE(current_image_name))\n\t\tresp->current_image = 3;  \n\n\tsnprintf(str, maxlen, \"%s\\n%s\\n%s\\n%s\\n\", CROS_EC_DEV_VERSION,\n\t\t resp->version_string_ro, resp->version_string_rw,\n\t\t current_image_name[resp->current_image]);\n\n\tret = 0;\nexit:\n\tkfree(msg);\n\treturn ret;\n}\n\nstatic int cros_ec_chardev_mkbp_event(struct notifier_block *nb,\n\t\t\t\t      unsigned long queued_during_suspend,\n\t\t\t\t      void *_notify)\n{\n\tstruct chardev_priv *priv = container_of(nb, struct chardev_priv,\n\t\t\t\t\t\t notifier);\n\tstruct cros_ec_device *ec_dev = priv->ec_dev->ec_dev;\n\tstruct ec_event *event;\n\tunsigned long event_bit = 1 << ec_dev->event_data.event_type;\n\tint total_size = sizeof(*event) + ec_dev->event_size;\n\n\tif (!(event_bit & priv->event_mask) ||\n\t    (priv->event_len + total_size) > CROS_MAX_EVENT_LEN)\n\t\treturn NOTIFY_DONE;\n\n\tevent = kzalloc(total_size, GFP_KERNEL);\n\tif (!event)\n\t\treturn NOTIFY_DONE;\n\n\tevent->size = ec_dev->event_size;\n\tevent->event_type = ec_dev->event_data.event_type;\n\tmemcpy(event->data, &ec_dev->event_data.data, ec_dev->event_size);\n\n\tspin_lock(&priv->wait_event.lock);\n\tlist_add_tail(&event->node, &priv->events);\n\tpriv->event_len += total_size;\n\twake_up_locked(&priv->wait_event);\n\tspin_unlock(&priv->wait_event.lock);\n\n\treturn NOTIFY_OK;\n}\n\nstatic struct ec_event *cros_ec_chardev_fetch_event(struct chardev_priv *priv,\n\t\t\t\t\t\t    bool fetch, bool block)\n{\n\tstruct ec_event *event;\n\tint err;\n\n\tspin_lock(&priv->wait_event.lock);\n\tif (!block && list_empty(&priv->events)) {\n\t\tevent = ERR_PTR(-EWOULDBLOCK);\n\t\tgoto out;\n\t}\n\n\tif (!fetch) {\n\t\tevent = NULL;\n\t\tgoto out;\n\t}\n\n\terr = wait_event_interruptible_locked(priv->wait_event,\n\t\t\t\t\t      !list_empty(&priv->events));\n\tif (err) {\n\t\tevent = ERR_PTR(err);\n\t\tgoto out;\n\t}\n\n\tevent = list_first_entry(&priv->events, struct ec_event, node);\n\tlist_del(&event->node);\n\tpriv->event_len -= sizeof(*event) + event->size;\n\nout:\n\tspin_unlock(&priv->wait_event.lock);\n\treturn event;\n}\n\n \nstatic int cros_ec_chardev_open(struct inode *inode, struct file *filp)\n{\n\tstruct miscdevice *mdev = filp->private_data;\n\tstruct cros_ec_dev *ec_dev = dev_get_drvdata(mdev->parent);\n\tstruct chardev_priv *priv;\n\tint ret;\n\n\tpriv = kzalloc(sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->ec_dev = ec_dev;\n\tfilp->private_data = priv;\n\tINIT_LIST_HEAD(&priv->events);\n\tinit_waitqueue_head(&priv->wait_event);\n\tnonseekable_open(inode, filp);\n\n\tpriv->notifier.notifier_call = cros_ec_chardev_mkbp_event;\n\tret = blocking_notifier_chain_register(&ec_dev->ec_dev->event_notifier,\n\t\t\t\t\t       &priv->notifier);\n\tif (ret) {\n\t\tdev_err(ec_dev->dev, \"failed to register event notifier\\n\");\n\t\tkfree(priv);\n\t}\n\n\treturn ret;\n}\n\nstatic __poll_t cros_ec_chardev_poll(struct file *filp, poll_table *wait)\n{\n\tstruct chardev_priv *priv = filp->private_data;\n\n\tpoll_wait(filp, &priv->wait_event, wait);\n\n\tif (list_empty(&priv->events))\n\t\treturn 0;\n\n\treturn EPOLLIN | EPOLLRDNORM;\n}\n\nstatic ssize_t cros_ec_chardev_read(struct file *filp, char __user *buffer,\n\t\t\t\t     size_t length, loff_t *offset)\n{\n\tchar msg[sizeof(struct ec_response_get_version) +\n\t\t sizeof(CROS_EC_DEV_VERSION)];\n\tstruct chardev_priv *priv = filp->private_data;\n\tstruct cros_ec_dev *ec_dev = priv->ec_dev;\n\tsize_t count;\n\tint ret;\n\n\tif (priv->event_mask) {  \n\t\tstruct ec_event *event;\n\n\t\tevent = cros_ec_chardev_fetch_event(priv, length != 0,\n\t\t\t\t\t\t!(filp->f_flags & O_NONBLOCK));\n\t\tif (IS_ERR(event))\n\t\t\treturn PTR_ERR(event);\n\t\t \n\t\tif (length == 0)\n\t\t\treturn 0;\n\n\t\t \n\t\tcount = min(length, event->size + 1);\n\t\tret = copy_to_user(buffer, &event->event_type, count);\n\t\tkfree(event);\n\t\tif (ret)  \n\t\t\treturn -EFAULT;\n\t\t*offset = count;\n\t\treturn count;\n\t}\n\n\t \n\tif (*offset != 0)\n\t\treturn 0;\n\n\tret = ec_get_version(ec_dev, msg, sizeof(msg));\n\tif (ret)\n\t\treturn ret;\n\n\tcount = min(length, strlen(msg));\n\n\tif (copy_to_user(buffer, msg, count))\n\t\treturn -EFAULT;\n\n\t*offset = count;\n\treturn count;\n}\n\nstatic int cros_ec_chardev_release(struct inode *inode, struct file *filp)\n{\n\tstruct chardev_priv *priv = filp->private_data;\n\tstruct cros_ec_dev *ec_dev = priv->ec_dev;\n\tstruct ec_event *event, *e;\n\n\tblocking_notifier_chain_unregister(&ec_dev->ec_dev->event_notifier,\n\t\t\t\t\t   &priv->notifier);\n\n\tlist_for_each_entry_safe(event, e, &priv->events, node) {\n\t\tlist_del(&event->node);\n\t\tkfree(event);\n\t}\n\tkfree(priv);\n\n\treturn 0;\n}\n\n \nstatic long cros_ec_chardev_ioctl_xcmd(struct cros_ec_dev *ec, void __user *arg)\n{\n\tstruct cros_ec_command *s_cmd;\n\tstruct cros_ec_command u_cmd;\n\tlong ret;\n\n\tif (copy_from_user(&u_cmd, arg, sizeof(u_cmd)))\n\t\treturn -EFAULT;\n\n\tif (u_cmd.outsize > EC_MAX_MSG_BYTES ||\n\t    u_cmd.insize > EC_MAX_MSG_BYTES)\n\t\treturn -EINVAL;\n\n\ts_cmd = kzalloc(sizeof(*s_cmd) + max(u_cmd.outsize, u_cmd.insize),\n\t\t\tGFP_KERNEL);\n\tif (!s_cmd)\n\t\treturn -ENOMEM;\n\n\tif (copy_from_user(s_cmd, arg, sizeof(*s_cmd) + u_cmd.outsize)) {\n\t\tret = -EFAULT;\n\t\tgoto exit;\n\t}\n\n\tif (u_cmd.outsize != s_cmd->outsize ||\n\t    u_cmd.insize != s_cmd->insize) {\n\t\tret = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\ts_cmd->command += ec->cmd_offset;\n\tret = cros_ec_cmd_xfer(ec->ec_dev, s_cmd);\n\t \n\tif (ret < 0)\n\t\tgoto exit;\n\n\tif (copy_to_user(arg, s_cmd, sizeof(*s_cmd) + s_cmd->insize))\n\t\tret = -EFAULT;\nexit:\n\tkfree(s_cmd);\n\treturn ret;\n}\n\nstatic long cros_ec_chardev_ioctl_readmem(struct cros_ec_dev *ec,\n\t\t\t\t\t   void __user *arg)\n{\n\tstruct cros_ec_device *ec_dev = ec->ec_dev;\n\tstruct cros_ec_readmem s_mem = { };\n\tlong num;\n\n\t \n\tif (!ec_dev->cmd_readmem)\n\t\treturn -ENOTTY;\n\n\tif (copy_from_user(&s_mem, arg, sizeof(s_mem)))\n\t\treturn -EFAULT;\n\n\tif (s_mem.bytes > sizeof(s_mem.buffer))\n\t\treturn -EINVAL;\n\n\tnum = ec_dev->cmd_readmem(ec_dev, s_mem.offset, s_mem.bytes,\n\t\t\t\t  s_mem.buffer);\n\tif (num <= 0)\n\t\treturn num;\n\n\tif (copy_to_user((void __user *)arg, &s_mem, sizeof(s_mem)))\n\t\treturn -EFAULT;\n\n\treturn num;\n}\n\nstatic long cros_ec_chardev_ioctl(struct file *filp, unsigned int cmd,\n\t\t\t\t   unsigned long arg)\n{\n\tstruct chardev_priv *priv = filp->private_data;\n\tstruct cros_ec_dev *ec = priv->ec_dev;\n\n\tif (_IOC_TYPE(cmd) != CROS_EC_DEV_IOC)\n\t\treturn -ENOTTY;\n\n\tswitch (cmd) {\n\tcase CROS_EC_DEV_IOCXCMD:\n\t\treturn cros_ec_chardev_ioctl_xcmd(ec, (void __user *)arg);\n\tcase CROS_EC_DEV_IOCRDMEM:\n\t\treturn cros_ec_chardev_ioctl_readmem(ec, (void __user *)arg);\n\tcase CROS_EC_DEV_IOCEVENTMASK:\n\t\tpriv->event_mask = arg;\n\t\treturn 0;\n\t}\n\n\treturn -ENOTTY;\n}\n\nstatic const struct file_operations chardev_fops = {\n\t.open\t\t= cros_ec_chardev_open,\n\t.poll\t\t= cros_ec_chardev_poll,\n\t.read\t\t= cros_ec_chardev_read,\n\t.release\t= cros_ec_chardev_release,\n\t.unlocked_ioctl\t= cros_ec_chardev_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl\t= cros_ec_chardev_ioctl,\n#endif\n};\n\nstatic int cros_ec_chardev_probe(struct platform_device *pdev)\n{\n\tstruct cros_ec_dev *ec_dev = dev_get_drvdata(pdev->dev.parent);\n\tstruct cros_ec_platform *ec_platform = dev_get_platdata(ec_dev->dev);\n\tstruct chardev_data *data;\n\n\t \n\tdata = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->ec_dev = ec_dev;\n\tdata->misc.minor = MISC_DYNAMIC_MINOR;\n\tdata->misc.fops = &chardev_fops;\n\tdata->misc.name = ec_platform->ec_name;\n\tdata->misc.parent = pdev->dev.parent;\n\n\tdev_set_drvdata(&pdev->dev, data);\n\n\treturn misc_register(&data->misc);\n}\n\nstatic int cros_ec_chardev_remove(struct platform_device *pdev)\n{\n\tstruct chardev_data *data = dev_get_drvdata(&pdev->dev);\n\n\tmisc_deregister(&data->misc);\n\n\treturn 0;\n}\n\nstatic struct platform_driver cros_ec_chardev_driver = {\n\t.driver = {\n\t\t.name = DRV_NAME,\n\t},\n\t.probe = cros_ec_chardev_probe,\n\t.remove = cros_ec_chardev_remove,\n};\n\nmodule_platform_driver(cros_ec_chardev_driver);\n\nMODULE_ALIAS(\"platform:\" DRV_NAME);\nMODULE_AUTHOR(\"Enric Balletbo i Serra <enric.balletbo@collabora.com>\");\nMODULE_DESCRIPTION(\"ChromeOS EC Miscellaneous Character Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}