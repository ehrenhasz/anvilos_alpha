{
  "module_name": "cros_ec_typec.c",
  "hash_id": "09971f6b96edd6eeb13f95b4607e83e1d99e245655fed260f75e50f5865f9937",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/chrome/cros_ec_typec.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_data/cros_ec_commands.h>\n#include <linux/platform_data/cros_usbpd_notify.h>\n#include <linux/platform_device.h>\n#include <linux/usb/pd_vdo.h>\n#include <linux/usb/typec_dp.h>\n#include <linux/usb/typec_tbt.h>\n\n#include \"cros_ec_typec.h\"\n#include \"cros_typec_vdm.h\"\n\n#define DRV_NAME \"cros-ec-typec\"\n\n#define DP_PORT_VDO\t(DP_CONF_SET_PIN_ASSIGN(BIT(DP_PIN_ASSIGN_C) | BIT(DP_PIN_ASSIGN_D)) | \\\n\t\t\t\tDP_CAP_DFP_D | DP_CAP_RECEPTACLE)\n\nstatic int cros_typec_parse_port_props(struct typec_capability *cap,\n\t\t\t\t       struct fwnode_handle *fwnode,\n\t\t\t\t       struct device *dev)\n{\n\tconst char *buf;\n\tint ret;\n\n\tmemset(cap, 0, sizeof(*cap));\n\tret = fwnode_property_read_string(fwnode, \"power-role\", &buf);\n\tif (ret) {\n\t\tdev_err(dev, \"power-role not found: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = typec_find_port_power_role(buf);\n\tif (ret < 0)\n\t\treturn ret;\n\tcap->type = ret;\n\n\tret = fwnode_property_read_string(fwnode, \"data-role\", &buf);\n\tif (ret) {\n\t\tdev_err(dev, \"data-role not found: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = typec_find_port_data_role(buf);\n\tif (ret < 0)\n\t\treturn ret;\n\tcap->data = ret;\n\n\t \n\tret = fwnode_property_read_string(fwnode, \"try-power-role\", &buf);\n\tif (ret) {\n\t\tdev_warn(dev, \"try-power-role not found: %d\\n\", ret);\n\t\tcap->prefer_role = TYPEC_NO_PREFERRED_ROLE;\n\t} else {\n\t\tret = typec_find_power_role(buf);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tcap->prefer_role = ret;\n\t}\n\n\tcap->fwnode = fwnode;\n\n\treturn 0;\n}\n\nstatic int cros_typec_get_switch_handles(struct cros_typec_port *port,\n\t\t\t\t\t struct fwnode_handle *fwnode,\n\t\t\t\t\t struct device *dev)\n{\n\tint ret = 0;\n\n\tport->mux = fwnode_typec_mux_get(fwnode);\n\tif (IS_ERR(port->mux)) {\n\t\tret = PTR_ERR(port->mux);\n\t\tdev_dbg(dev, \"Mux handle not found: %d.\\n\", ret);\n\t\tgoto mux_err;\n\t}\n\n\tport->retimer = fwnode_typec_retimer_get(fwnode);\n\tif (IS_ERR(port->retimer)) {\n\t\tret = PTR_ERR(port->retimer);\n\t\tdev_dbg(dev, \"Retimer handle not found: %d.\\n\", ret);\n\t\tgoto retimer_sw_err;\n\t}\n\n\tport->ori_sw = fwnode_typec_switch_get(fwnode);\n\tif (IS_ERR(port->ori_sw)) {\n\t\tret = PTR_ERR(port->ori_sw);\n\t\tdev_dbg(dev, \"Orientation switch handle not found: %d\\n\", ret);\n\t\tgoto ori_sw_err;\n\t}\n\n\tport->role_sw = fwnode_usb_role_switch_get(fwnode);\n\tif (IS_ERR(port->role_sw)) {\n\t\tret = PTR_ERR(port->role_sw);\n\t\tdev_dbg(dev, \"USB role switch handle not found: %d\\n\", ret);\n\t\tgoto role_sw_err;\n\t}\n\n\treturn 0;\n\nrole_sw_err:\n\ttypec_switch_put(port->ori_sw);\n\tport->ori_sw = NULL;\nori_sw_err:\n\ttypec_retimer_put(port->retimer);\n\tport->retimer = NULL;\nretimer_sw_err:\n\ttypec_mux_put(port->mux);\n\tport->mux = NULL;\nmux_err:\n\treturn ret;\n}\n\nstatic int cros_typec_add_partner(struct cros_typec_data *typec, int port_num,\n\t\t\t\t  bool pd_en)\n{\n\tstruct cros_typec_port *port = typec->ports[port_num];\n\tstruct typec_partner_desc p_desc = {\n\t\t.usb_pd = pd_en,\n\t};\n\tint ret = 0;\n\n\t \n\tp_desc.identity = &port->p_identity;\n\n\tport->partner = typec_register_partner(port->port, &p_desc);\n\tif (IS_ERR(port->partner)) {\n\t\tret = PTR_ERR(port->partner);\n\t\tport->partner = NULL;\n\t}\n\n\treturn ret;\n}\n\nstatic void cros_typec_unregister_altmodes(struct cros_typec_data *typec, int port_num,\n\t\t\t\t\t   bool is_partner)\n{\n\tstruct cros_typec_port *port = typec->ports[port_num];\n\tstruct cros_typec_altmode_node *node, *tmp;\n\tstruct list_head *head;\n\n\thead = is_partner ? &port->partner_mode_list : &port->plug_mode_list;\n\tlist_for_each_entry_safe(node, tmp, head, list) {\n\t\tlist_del(&node->list);\n\t\ttypec_unregister_altmode(node->amode);\n\t\tdevm_kfree(typec->dev, node);\n\t}\n}\n\n \nstatic int cros_typec_retimer_set(struct typec_retimer *retimer, struct typec_mux_state state)\n{\n\tstruct typec_retimer_state rstate = {\n\t\t.alt = state.alt,\n\t\t.mode = state.mode,\n\t\t.data = state.data,\n\t};\n\n\treturn typec_retimer_set(retimer, &rstate);\n}\n\nstatic int cros_typec_usb_disconnect_state(struct cros_typec_port *port)\n{\n\tport->state.alt = NULL;\n\tport->state.mode = TYPEC_STATE_USB;\n\tport->state.data = NULL;\n\n\tusb_role_switch_set_role(port->role_sw, USB_ROLE_NONE);\n\ttypec_switch_set(port->ori_sw, TYPEC_ORIENTATION_NONE);\n\tcros_typec_retimer_set(port->retimer, port->state);\n\n\treturn typec_mux_set(port->mux, &port->state);\n}\n\nstatic void cros_typec_remove_partner(struct cros_typec_data *typec,\n\t\t\t\t      int port_num)\n{\n\tstruct cros_typec_port *port = typec->ports[port_num];\n\n\tif (!port->partner)\n\t\treturn;\n\n\tcros_typec_unregister_altmodes(typec, port_num, true);\n\n\ttypec_partner_set_usb_power_delivery(port->partner, NULL);\n\tusb_power_delivery_unregister_capabilities(port->partner_sink_caps);\n\tport->partner_sink_caps = NULL;\n\tusb_power_delivery_unregister_capabilities(port->partner_src_caps);\n\tport->partner_src_caps = NULL;\n\tusb_power_delivery_unregister(port->partner_pd);\n\tport->partner_pd = NULL;\n\n\tcros_typec_usb_disconnect_state(port);\n\tport->mux_flags = USB_PD_MUX_NONE;\n\n\ttypec_unregister_partner(port->partner);\n\tport->partner = NULL;\n\tmemset(&port->p_identity, 0, sizeof(port->p_identity));\n\tport->sop_disc_done = false;\n}\n\nstatic void cros_typec_remove_cable(struct cros_typec_data *typec,\n\t\t\t\t    int port_num)\n{\n\tstruct cros_typec_port *port = typec->ports[port_num];\n\n\tif (!port->cable)\n\t\treturn;\n\n\tcros_typec_unregister_altmodes(typec, port_num, false);\n\n\ttypec_unregister_plug(port->plug);\n\tport->plug = NULL;\n\ttypec_unregister_cable(port->cable);\n\tport->cable = NULL;\n\tmemset(&port->c_identity, 0, sizeof(port->c_identity));\n\tport->sop_prime_disc_done = false;\n}\n\nstatic void cros_typec_unregister_port_altmodes(struct cros_typec_port *port)\n{\n\tint i;\n\n\tfor (i = 0; i < CROS_EC_ALTMODE_MAX; i++)\n\t\ttypec_unregister_altmode(port->port_altmode[i]);\n}\n\nstatic void cros_unregister_ports(struct cros_typec_data *typec)\n{\n\tint i;\n\n\tfor (i = 0; i < typec->num_ports; i++) {\n\t\tif (!typec->ports[i])\n\t\t\tcontinue;\n\n\t\tcros_typec_remove_partner(typec, i);\n\t\tcros_typec_remove_cable(typec, i);\n\n\t\tusb_role_switch_put(typec->ports[i]->role_sw);\n\t\ttypec_switch_put(typec->ports[i]->ori_sw);\n\t\ttypec_mux_put(typec->ports[i]->mux);\n\t\tcros_typec_unregister_port_altmodes(typec->ports[i]);\n\t\ttypec_unregister_port(typec->ports[i]->port);\n\t}\n}\n\n \nstatic int cros_typec_register_port_altmodes(struct cros_typec_data *typec,\n\t\t\t\t\t      int port_num)\n{\n\tstruct cros_typec_port *port = typec->ports[port_num];\n\tstruct typec_altmode_desc desc;\n\tstruct typec_altmode *amode;\n\n\t \n\tdesc.svid = USB_TYPEC_DP_SID,\n\tdesc.mode = USB_TYPEC_DP_MODE,\n\tdesc.vdo = DP_PORT_VDO,\n\tamode = typec_port_register_altmode(port->port, &desc);\n\tif (IS_ERR(amode))\n\t\treturn PTR_ERR(amode);\n\tport->port_altmode[CROS_EC_ALTMODE_DP] = amode;\n\ttypec_altmode_set_drvdata(amode, port);\n\tamode->ops = &port_amode_ops;\n\n\t \n\tmemset(&desc, 0, sizeof(desc));\n\tdesc.svid = USB_TYPEC_TBT_SID,\n\tdesc.mode = TYPEC_ANY_MODE,\n\tamode = typec_port_register_altmode(port->port, &desc);\n\tif (IS_ERR(amode))\n\t\treturn PTR_ERR(amode);\n\tport->port_altmode[CROS_EC_ALTMODE_TBT] = amode;\n\ttypec_altmode_set_drvdata(amode, port);\n\tamode->ops = &port_amode_ops;\n\n\tport->state.alt = NULL;\n\tport->state.mode = TYPEC_STATE_USB;\n\tport->state.data = NULL;\n\n\treturn 0;\n}\n\nstatic int cros_typec_init_ports(struct cros_typec_data *typec)\n{\n\tstruct device *dev = typec->dev;\n\tstruct typec_capability *cap;\n\tstruct fwnode_handle *fwnode;\n\tstruct cros_typec_port *cros_port;\n\tconst char *port_prop;\n\tint ret;\n\tint nports;\n\tu32 port_num = 0;\n\n\tnports = device_get_child_node_count(dev);\n\tif (nports == 0) {\n\t\tdev_err(dev, \"No port entries found.\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (nports > typec->num_ports) {\n\t\tdev_err(dev, \"More ports listed than can be supported.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tport_prop = dev->of_node ? \"reg\" : \"port-number\";\n\tdevice_for_each_child_node(dev, fwnode) {\n\t\tif (fwnode_property_read_u32(fwnode, port_prop, &port_num)) {\n\t\t\tret = -EINVAL;\n\t\t\tdev_err(dev, \"No port-number for port, aborting.\\n\");\n\t\t\tgoto unregister_ports;\n\t\t}\n\n\t\tif (port_num >= typec->num_ports) {\n\t\t\tdev_err(dev, \"Invalid port number.\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto unregister_ports;\n\t\t}\n\n\t\tdev_dbg(dev, \"Registering port %d\\n\", port_num);\n\n\t\tcros_port = devm_kzalloc(dev, sizeof(*cros_port), GFP_KERNEL);\n\t\tif (!cros_port) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto unregister_ports;\n\t\t}\n\n\t\tcros_port->port_num = port_num;\n\t\tcros_port->typec_data = typec;\n\t\ttypec->ports[port_num] = cros_port;\n\t\tcap = &cros_port->caps;\n\n\t\tret = cros_typec_parse_port_props(cap, fwnode, dev);\n\t\tif (ret < 0)\n\t\t\tgoto unregister_ports;\n\n\t\tcros_port->port = typec_register_port(dev, cap);\n\t\tif (IS_ERR(cros_port->port)) {\n\t\t\tret = PTR_ERR(cros_port->port);\n\t\t\tdev_err_probe(dev, ret, \"Failed to register port %d\\n\", port_num);\n\t\t\tgoto unregister_ports;\n\t\t}\n\n\t\tret = cros_typec_get_switch_handles(cros_port, fwnode, dev);\n\t\tif (ret) {\n\t\t\tdev_dbg(dev, \"No switch control for port %d, err: %d\\n\", port_num, ret);\n\t\t\tif (ret == -EPROBE_DEFER)\n\t\t\t\tgoto unregister_ports;\n\t\t}\n\n\t\tret = cros_typec_register_port_altmodes(typec, port_num);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Failed to register port altmodes\\n\");\n\t\t\tgoto unregister_ports;\n\t\t}\n\n\t\tcros_port->disc_data = devm_kzalloc(dev, EC_PROTO2_MAX_RESPONSE_SIZE, GFP_KERNEL);\n\t\tif (!cros_port->disc_data) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto unregister_ports;\n\t\t}\n\n\t\tINIT_LIST_HEAD(&cros_port->partner_mode_list);\n\t\tINIT_LIST_HEAD(&cros_port->plug_mode_list);\n\t}\n\n\treturn 0;\n\nunregister_ports:\n\tcros_unregister_ports(typec);\n\treturn ret;\n}\n\nstatic int cros_typec_usb_safe_state(struct cros_typec_port *port)\n{\n\tint ret;\n\tport->state.mode = TYPEC_STATE_SAFE;\n\n\tret = cros_typec_retimer_set(port->retimer, port->state);\n\tif (!ret)\n\t\tret = typec_mux_set(port->mux, &port->state);\n\n\treturn ret;\n}\n\n \nstatic int cros_typec_get_cable_vdo(struct cros_typec_port *port, u16 svid)\n{\n\tstruct list_head *head = &port->plug_mode_list;\n\tstruct cros_typec_altmode_node *node;\n\tu32 ret = 0;\n\n\tlist_for_each_entry(node, head, list) {\n\t\tif (node->amode->svid == svid)\n\t\t\treturn node->amode->vdo;\n\t}\n\n\treturn ret;\n}\n\n \nstatic int cros_typec_enable_tbt(struct cros_typec_data *typec,\n\t\t\t\t int port_num,\n\t\t\t\t struct ec_response_usb_pd_control_v2 *pd_ctrl)\n{\n\tstruct cros_typec_port *port = typec->ports[port_num];\n\tstruct typec_thunderbolt_data data;\n\tint ret;\n\n\tif (typec->pd_ctrl_ver < 2) {\n\t\tdev_err(typec->dev,\n\t\t\t\"PD_CTRL version too old: %d\\n\", typec->pd_ctrl_ver);\n\t\treturn -ENOTSUPP;\n\t}\n\n\t \n\tdata.device_mode = TBT_MODE;\n\n\tif (pd_ctrl->control_flags & USB_PD_CTRL_TBT_LEGACY_ADAPTER)\n\t\tdata.device_mode = TBT_SET_ADAPTER(TBT_ADAPTER_TBT3);\n\n\t \n\tdata.cable_mode = TBT_MODE;\n\n\tdata.cable_mode |= cros_typec_get_cable_vdo(port, USB_TYPEC_TBT_SID);\n\n\tdata.cable_mode |= TBT_SET_CABLE_SPEED(pd_ctrl->cable_speed);\n\n\tif (pd_ctrl->control_flags & USB_PD_CTRL_OPTICAL_CABLE)\n\t\tdata.cable_mode |= TBT_CABLE_OPTICAL;\n\n\tif (pd_ctrl->control_flags & USB_PD_CTRL_ACTIVE_LINK_UNIDIR)\n\t\tdata.cable_mode |= TBT_CABLE_LINK_TRAINING;\n\n\tdata.cable_mode |= TBT_SET_CABLE_ROUNDED(pd_ctrl->cable_gen);\n\n\t \n\tdata.enter_vdo = TBT_SET_CABLE_SPEED(pd_ctrl->cable_speed);\n\n\tif (pd_ctrl->control_flags & USB_PD_CTRL_ACTIVE_CABLE)\n\t\tdata.enter_vdo |= TBT_ENTER_MODE_ACTIVE_CABLE;\n\n\tif (!port->state.alt) {\n\t\tport->state.alt = port->port_altmode[CROS_EC_ALTMODE_TBT];\n\t\tret = cros_typec_usb_safe_state(port);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tport->state.data = &data;\n\tport->state.mode = TYPEC_TBT_MODE;\n\n\treturn typec_mux_set(port->mux, &port->state);\n}\n\n \nstatic int cros_typec_enable_dp(struct cros_typec_data *typec,\n\t\t\t\tint port_num,\n\t\t\t\tstruct ec_response_usb_pd_control_v2 *pd_ctrl)\n{\n\tstruct cros_typec_port *port = typec->ports[port_num];\n\tstruct typec_displayport_data dp_data;\n\tint ret;\n\n\tif (typec->pd_ctrl_ver < 2) {\n\t\tdev_err(typec->dev,\n\t\t\t\"PD_CTRL version too old: %d\\n\", typec->pd_ctrl_ver);\n\t\treturn -ENOTSUPP;\n\t}\n\n\tif (!pd_ctrl->dp_mode) {\n\t\tdev_err(typec->dev, \"No valid DP mode provided.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tdp_data.status = DP_STATUS_ENABLED;\n\tif (port->mux_flags & USB_PD_MUX_HPD_IRQ)\n\t\tdp_data.status |= DP_STATUS_IRQ_HPD;\n\tif (port->mux_flags & USB_PD_MUX_HPD_LVL)\n\t\tdp_data.status |= DP_STATUS_HPD_STATE;\n\n\t \n\tdp_data.conf = DP_CONF_SET_PIN_ASSIGN(pd_ctrl->dp_mode);\n\tif (!port->state.alt) {\n\t\tport->state.alt = port->port_altmode[CROS_EC_ALTMODE_DP];\n\t\tret = cros_typec_usb_safe_state(port);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tport->state.data = &dp_data;\n\tport->state.mode = TYPEC_MODAL_STATE(ffs(pd_ctrl->dp_mode));\n\n\tret = cros_typec_retimer_set(port->retimer, port->state);\n\tif (!ret)\n\t\tret = typec_mux_set(port->mux, &port->state);\n\n\treturn ret;\n}\n\nstatic int cros_typec_enable_usb4(struct cros_typec_data *typec,\n\t\t\t\t  int port_num,\n\t\t\t\t  struct ec_response_usb_pd_control_v2 *pd_ctrl)\n{\n\tstruct cros_typec_port *port = typec->ports[port_num];\n\tstruct enter_usb_data data;\n\n\tdata.eudo = EUDO_USB_MODE_USB4 << EUDO_USB_MODE_SHIFT;\n\n\t \n\tdata.eudo |= pd_ctrl->cable_speed << EUDO_CABLE_SPEED_SHIFT;\n\n\t \n\tif (pd_ctrl->control_flags & USB_PD_CTRL_OPTICAL_CABLE)\n\t\tdata.eudo |= EUDO_CABLE_TYPE_OPTICAL << EUDO_CABLE_TYPE_SHIFT;\n\telse if (cros_typec_get_cable_vdo(port, USB_TYPEC_TBT_SID) & TBT_CABLE_RETIMER)\n\t\tdata.eudo |= EUDO_CABLE_TYPE_RE_TIMER << EUDO_CABLE_TYPE_SHIFT;\n\telse if (pd_ctrl->control_flags & USB_PD_CTRL_ACTIVE_CABLE)\n\t\tdata.eudo |= EUDO_CABLE_TYPE_RE_DRIVER << EUDO_CABLE_TYPE_SHIFT;\n\n\tdata.active_link_training = !!(pd_ctrl->control_flags &\n\t\t\t\t       USB_PD_CTRL_ACTIVE_LINK_UNIDIR);\n\n\tport->state.alt = NULL;\n\tport->state.data = &data;\n\tport->state.mode = TYPEC_MODE_USB4;\n\n\treturn typec_mux_set(port->mux, &port->state);\n}\n\nstatic int cros_typec_configure_mux(struct cros_typec_data *typec, int port_num,\n\t\t\t\tstruct ec_response_usb_pd_control_v2 *pd_ctrl)\n{\n\tstruct cros_typec_port *port = typec->ports[port_num];\n\tstruct ec_response_usb_pd_mux_info resp;\n\tstruct ec_params_usb_pd_mux_info req = {\n\t\t.port = port_num,\n\t};\n\tstruct ec_params_usb_pd_mux_ack mux_ack;\n\tenum typec_orientation orientation;\n\tint ret;\n\n\tret = cros_ec_cmd(typec->ec, 0, EC_CMD_USB_PD_MUX_INFO,\n\t\t\t  &req, sizeof(req), &resp, sizeof(resp));\n\tif (ret < 0) {\n\t\tdev_warn(typec->dev, \"Failed to get mux info for port: %d, err = %d\\n\",\n\t\t\t port_num, ret);\n\t\treturn ret;\n\t}\n\n\t \n\tif (port->mux_flags == resp.flags && port->role == pd_ctrl->role)\n\t\treturn 0;\n\n\tport->mux_flags = resp.flags;\n\tport->role = pd_ctrl->role;\n\n\tif (port->mux_flags == USB_PD_MUX_NONE) {\n\t\tret = cros_typec_usb_disconnect_state(port);\n\t\tgoto mux_ack;\n\t}\n\n\tif (port->mux_flags & USB_PD_MUX_POLARITY_INVERTED)\n\t\torientation = TYPEC_ORIENTATION_REVERSE;\n\telse\n\t\torientation = TYPEC_ORIENTATION_NORMAL;\n\n\tret = typec_switch_set(port->ori_sw, orientation);\n\tif (ret)\n\t\treturn ret;\n\n\tret = usb_role_switch_set_role(typec->ports[port_num]->role_sw,\n\t\t\t\t\tpd_ctrl->role & PD_CTRL_RESP_ROLE_DATA\n\t\t\t\t\t? USB_ROLE_HOST : USB_ROLE_DEVICE);\n\tif (ret)\n\t\treturn ret;\n\n\tif (port->mux_flags & USB_PD_MUX_USB4_ENABLED) {\n\t\tret = cros_typec_enable_usb4(typec, port_num, pd_ctrl);\n\t} else if (port->mux_flags & USB_PD_MUX_TBT_COMPAT_ENABLED) {\n\t\tret = cros_typec_enable_tbt(typec, port_num, pd_ctrl);\n\t} else if (port->mux_flags & USB_PD_MUX_DP_ENABLED) {\n\t\tret = cros_typec_enable_dp(typec, port_num, pd_ctrl);\n\t} else if (port->mux_flags & USB_PD_MUX_SAFE_MODE) {\n\t\tret = cros_typec_usb_safe_state(port);\n\t} else if (port->mux_flags & USB_PD_MUX_USB_ENABLED) {\n\t\tport->state.alt = NULL;\n\t\tport->state.mode = TYPEC_STATE_USB;\n\n\t\tret = cros_typec_retimer_set(port->retimer, port->state);\n\t\tif (!ret)\n\t\t\tret = typec_mux_set(port->mux, &port->state);\n\t} else {\n\t\tdev_dbg(typec->dev,\n\t\t\t\"Unrecognized mode requested, mux flags: %x\\n\",\n\t\t\tport->mux_flags);\n\t}\n\nmux_ack:\n\tif (!typec->needs_mux_ack)\n\t\treturn ret;\n\n\t \n\tmux_ack.port = port_num;\n\n\tif (cros_ec_cmd(typec->ec, 0, EC_CMD_USB_PD_MUX_ACK, &mux_ack,\n\t\t\tsizeof(mux_ack), NULL, 0) < 0)\n\t\tdev_warn(typec->dev,\n\t\t\t \"Failed to send Mux ACK to EC for port: %d\\n\",\n\t\t\t port_num);\n\n\treturn ret;\n}\n\nstatic void cros_typec_set_port_params_v0(struct cros_typec_data *typec,\n\t\tint port_num, struct ec_response_usb_pd_control *resp)\n{\n\tstruct typec_port *port = typec->ports[port_num]->port;\n\tenum typec_orientation polarity;\n\n\tif (!resp->enabled)\n\t\tpolarity = TYPEC_ORIENTATION_NONE;\n\telse if (!resp->polarity)\n\t\tpolarity = TYPEC_ORIENTATION_NORMAL;\n\telse\n\t\tpolarity = TYPEC_ORIENTATION_REVERSE;\n\n\ttypec_set_pwr_role(port, resp->role ? TYPEC_SOURCE : TYPEC_SINK);\n\ttypec_set_orientation(port, polarity);\n}\n\nstatic void cros_typec_set_port_params_v1(struct cros_typec_data *typec,\n\t\tint port_num, struct ec_response_usb_pd_control_v1 *resp)\n{\n\tstruct typec_port *port = typec->ports[port_num]->port;\n\tenum typec_orientation polarity;\n\tbool pd_en;\n\tint ret;\n\n\tif (!(resp->enabled & PD_CTRL_RESP_ENABLED_CONNECTED))\n\t\tpolarity = TYPEC_ORIENTATION_NONE;\n\telse if (!resp->polarity)\n\t\tpolarity = TYPEC_ORIENTATION_NORMAL;\n\telse\n\t\tpolarity = TYPEC_ORIENTATION_REVERSE;\n\ttypec_set_orientation(port, polarity);\n\ttypec_set_data_role(port, resp->role & PD_CTRL_RESP_ROLE_DATA ?\n\t\t\tTYPEC_HOST : TYPEC_DEVICE);\n\ttypec_set_pwr_role(port, resp->role & PD_CTRL_RESP_ROLE_POWER ?\n\t\t\tTYPEC_SOURCE : TYPEC_SINK);\n\ttypec_set_vconn_role(port, resp->role & PD_CTRL_RESP_ROLE_VCONN ?\n\t\t\tTYPEC_SOURCE : TYPEC_SINK);\n\n\t \n\tif (resp->enabled & PD_CTRL_RESP_ENABLED_CONNECTED) {\n\t\tif (typec->ports[port_num]->partner)\n\t\t\treturn;\n\n\t\tpd_en = resp->enabled & PD_CTRL_RESP_ENABLED_PD_CAPABLE;\n\t\tret = cros_typec_add_partner(typec, port_num, pd_en);\n\t\tif (ret)\n\t\t\tdev_warn(typec->dev,\n\t\t\t\t \"Failed to register partner on port: %d\\n\",\n\t\t\t\t port_num);\n\t} else {\n\t\tcros_typec_remove_partner(typec, port_num);\n\t\tcros_typec_remove_cable(typec, port_num);\n\t}\n}\n\n \nstatic int cros_typec_register_altmodes(struct cros_typec_data *typec, int port_num,\n\t\t\t\t\tbool is_partner)\n{\n\tstruct cros_typec_port *port = typec->ports[port_num];\n\tstruct ec_response_typec_discovery *sop_disc = port->disc_data;\n\tstruct cros_typec_altmode_node *node;\n\tstruct typec_altmode_desc desc;\n\tstruct typec_altmode *amode;\n\tint num_altmodes = 0;\n\tint ret = 0;\n\tint i, j;\n\n\tfor (i = 0; i < sop_disc->svid_count; i++) {\n\t\tfor (j = 0; j < sop_disc->svids[i].mode_count; j++) {\n\t\t\tmemset(&desc, 0, sizeof(desc));\n\t\t\tdesc.svid = sop_disc->svids[i].svid;\n\t\t\tdesc.mode = j + 1;\n\t\t\tdesc.vdo = sop_disc->svids[i].mode_vdo[j];\n\n\t\t\tif (is_partner)\n\t\t\t\tamode = typec_partner_register_altmode(port->partner, &desc);\n\t\t\telse\n\t\t\t\tamode = typec_plug_register_altmode(port->plug, &desc);\n\n\t\t\tif (IS_ERR(amode)) {\n\t\t\t\tret = PTR_ERR(amode);\n\t\t\t\tgoto err_cleanup;\n\t\t\t}\n\n\t\t\t \n\t\t\tnode = devm_kzalloc(typec->dev, sizeof(*node), GFP_KERNEL);\n\t\t\tif (!node) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\ttypec_unregister_altmode(amode);\n\t\t\t\tgoto err_cleanup;\n\t\t\t}\n\n\t\t\tnode->amode = amode;\n\n\t\t\tif (is_partner)\n\t\t\t\tlist_add_tail(&node->list, &port->partner_mode_list);\n\t\t\telse\n\t\t\t\tlist_add_tail(&node->list, &port->plug_mode_list);\n\t\t\tnum_altmodes++;\n\t\t}\n\t}\n\n\tif (is_partner)\n\t\tret = typec_partner_set_num_altmodes(port->partner, num_altmodes);\n\telse\n\t\tret = typec_plug_set_num_altmodes(port->plug, num_altmodes);\n\n\tif (ret < 0) {\n\t\tdev_err(typec->dev, \"Unable to set %s num_altmodes for port: %d\\n\",\n\t\t\tis_partner ? \"partner\" : \"plug\", port_num);\n\t\tgoto err_cleanup;\n\t}\n\n\treturn 0;\n\nerr_cleanup:\n\tcros_typec_unregister_altmodes(typec, port_num, is_partner);\n\treturn ret;\n}\n\n \nstatic void cros_typec_parse_pd_identity(struct usb_pd_identity *id,\n\t\t\t\t\t struct ec_response_typec_discovery *disc)\n{\n\tint i;\n\n\t \n\tif (disc->identity_count > 0)\n\t\tid->id_header = disc->discovery_vdo[0];\n\tif (disc->identity_count > 1)\n\t\tid->cert_stat = disc->discovery_vdo[1];\n\tif (disc->identity_count > 2)\n\t\tid->product = disc->discovery_vdo[2];\n\n\t \n\tfor (i = 3; i < disc->identity_count && i < VDO_MAX_OBJECTS; i++)\n\t\tid->vdo[i - 3] = disc->discovery_vdo[i];\n}\n\nstatic int cros_typec_handle_sop_prime_disc(struct cros_typec_data *typec, int port_num, u16 pd_revision)\n{\n\tstruct cros_typec_port *port = typec->ports[port_num];\n\tstruct ec_response_typec_discovery *disc = port->disc_data;\n\tstruct typec_cable_desc c_desc = {};\n\tstruct typec_plug_desc p_desc;\n\tstruct ec_params_typec_discovery req = {\n\t\t.port = port_num,\n\t\t.partner_type = TYPEC_PARTNER_SOP_PRIME,\n\t};\n\tu32 cable_plug_type;\n\tint ret = 0;\n\n\tmemset(disc, 0, EC_PROTO2_MAX_RESPONSE_SIZE);\n\tret = cros_ec_cmd(typec->ec, 0, EC_CMD_TYPEC_DISCOVERY, &req, sizeof(req),\n\t\t\t  disc, EC_PROTO2_MAX_RESPONSE_SIZE);\n\tif (ret < 0) {\n\t\tdev_err(typec->dev, \"Failed to get SOP' discovery data for port: %d\\n\", port_num);\n\t\tgoto sop_prime_disc_exit;\n\t}\n\n\t \n\tcros_typec_parse_pd_identity(&port->c_identity, disc);\n\n\tif (disc->identity_count != 0) {\n\t\tcable_plug_type = VDO_TYPEC_CABLE_TYPE(port->c_identity.vdo[0]);\n\t\tswitch (cable_plug_type) {\n\t\tcase CABLE_ATYPE:\n\t\t\tc_desc.type = USB_PLUG_TYPE_A;\n\t\t\tbreak;\n\t\tcase CABLE_BTYPE:\n\t\t\tc_desc.type = USB_PLUG_TYPE_B;\n\t\t\tbreak;\n\t\tcase CABLE_CTYPE:\n\t\t\tc_desc.type = USB_PLUG_TYPE_C;\n\t\t\tbreak;\n\t\tcase CABLE_CAPTIVE:\n\t\t\tc_desc.type = USB_PLUG_CAPTIVE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tc_desc.type = USB_PLUG_NONE;\n\t\t}\n\t\tc_desc.active = PD_IDH_PTYPE(port->c_identity.id_header) == IDH_PTYPE_ACABLE;\n\t}\n\n\tc_desc.identity = &port->c_identity;\n\tc_desc.pd_revision = pd_revision;\n\n\tport->cable = typec_register_cable(port->port, &c_desc);\n\tif (IS_ERR(port->cable)) {\n\t\tret = PTR_ERR(port->cable);\n\t\tport->cable = NULL;\n\t\tgoto sop_prime_disc_exit;\n\t}\n\n\tp_desc.index = TYPEC_PLUG_SOP_P;\n\tport->plug = typec_register_plug(port->cable, &p_desc);\n\tif (IS_ERR(port->plug)) {\n\t\tret = PTR_ERR(port->plug);\n\t\tport->plug = NULL;\n\t\tgoto sop_prime_disc_exit;\n\t}\n\n\tret = cros_typec_register_altmodes(typec, port_num, false);\n\tif (ret < 0) {\n\t\tdev_err(typec->dev, \"Failed to register plug altmodes, port: %d\\n\", port_num);\n\t\tgoto sop_prime_disc_exit;\n\t}\n\n\treturn 0;\n\nsop_prime_disc_exit:\n\tcros_typec_remove_cable(typec, port_num);\n\treturn ret;\n}\n\nstatic int cros_typec_handle_sop_disc(struct cros_typec_data *typec, int port_num, u16 pd_revision)\n{\n\tstruct cros_typec_port *port = typec->ports[port_num];\n\tstruct ec_response_typec_discovery *sop_disc = port->disc_data;\n\tstruct ec_params_typec_discovery req = {\n\t\t.port = port_num,\n\t\t.partner_type = TYPEC_PARTNER_SOP,\n\t};\n\tint ret = 0;\n\n\tif (!port->partner) {\n\t\tdev_err(typec->dev,\n\t\t\t\"SOP Discovery received without partner registered, port: %d\\n\",\n\t\t\tport_num);\n\t\tret = -EINVAL;\n\t\tgoto disc_exit;\n\t}\n\n\ttypec_partner_set_pd_revision(port->partner, pd_revision);\n\n\tmemset(sop_disc, 0, EC_PROTO2_MAX_RESPONSE_SIZE);\n\tret = cros_ec_cmd(typec->ec, 0, EC_CMD_TYPEC_DISCOVERY, &req, sizeof(req),\n\t\t\t  sop_disc, EC_PROTO2_MAX_RESPONSE_SIZE);\n\tif (ret < 0) {\n\t\tdev_err(typec->dev, \"Failed to get SOP discovery data for port: %d\\n\", port_num);\n\t\tgoto disc_exit;\n\t}\n\n\tcros_typec_parse_pd_identity(&port->p_identity, sop_disc);\n\n\tret = typec_partner_set_identity(port->partner);\n\tif (ret < 0) {\n\t\tdev_err(typec->dev, \"Failed to update partner PD identity, port: %d\\n\", port_num);\n\t\tgoto disc_exit;\n\t}\n\n\tret = cros_typec_register_altmodes(typec, port_num, true);\n\tif (ret < 0) {\n\t\tdev_err(typec->dev, \"Failed to register partner altmodes, port: %d\\n\", port_num);\n\t\tgoto disc_exit;\n\t}\n\ndisc_exit:\n\treturn ret;\n}\n\nstatic int cros_typec_send_clear_event(struct cros_typec_data *typec, int port_num, u32 events_mask)\n{\n\tstruct ec_params_typec_control req = {\n\t\t.port = port_num,\n\t\t.command = TYPEC_CONTROL_COMMAND_CLEAR_EVENTS,\n\t\t.clear_events_mask = events_mask,\n\t};\n\n\treturn cros_ec_cmd(typec->ec, 0, EC_CMD_TYPEC_CONTROL, &req,\n\t\t\t   sizeof(req), NULL, 0);\n}\n\nstatic void cros_typec_register_partner_pdos(struct cros_typec_data *typec,\n\t\t\t\t\t     struct ec_response_typec_status *resp, int port_num)\n{\n\tstruct usb_power_delivery_capabilities_desc caps_desc = {};\n\tstruct usb_power_delivery_desc desc = {\n\t\t.revision = (le16_to_cpu(resp->sop_revision) & 0xff00) >> 4,\n\t};\n\tstruct cros_typec_port *port = typec->ports[port_num];\n\n\tif (!port->partner || port->partner_pd)\n\t\treturn;\n\n\t \n\tif (!resp->source_cap_count && !resp->sink_cap_count)\n\t\treturn;\n\n\tport->partner_pd = typec_partner_usb_power_delivery_register(port->partner, &desc);\n\tif (IS_ERR(port->partner_pd)) {\n\t\tdev_warn(typec->dev, \"Failed to register partner PD device, port: %d\\n\", port_num);\n\t\treturn;\n\t}\n\n\ttypec_partner_set_usb_power_delivery(port->partner, port->partner_pd);\n\n\tmemcpy(caps_desc.pdo, resp->source_cap_pdos, sizeof(u32) * resp->source_cap_count);\n\tcaps_desc.role = TYPEC_SOURCE;\n\tport->partner_src_caps = usb_power_delivery_register_capabilities(port->partner_pd,\n\t\t\t\t\t\t\t\t\t  &caps_desc);\n\tif (IS_ERR(port->partner_src_caps))\n\t\tdev_warn(typec->dev, \"Failed to register source caps, port: %d\\n\", port_num);\n\n\tmemset(&caps_desc, 0, sizeof(caps_desc));\n\tmemcpy(caps_desc.pdo, resp->sink_cap_pdos, sizeof(u32) * resp->sink_cap_count);\n\tcaps_desc.role = TYPEC_SINK;\n\tport->partner_sink_caps = usb_power_delivery_register_capabilities(port->partner_pd,\n\t\t\t\t\t\t\t\t\t   &caps_desc);\n\tif (IS_ERR(port->partner_sink_caps))\n\t\tdev_warn(typec->dev, \"Failed to register sink caps, port: %d\\n\", port_num);\n}\n\nstatic void cros_typec_handle_status(struct cros_typec_data *typec, int port_num)\n{\n\tstruct ec_response_typec_status resp;\n\tstruct ec_params_typec_status req = {\n\t\t.port = port_num,\n\t};\n\tint ret;\n\n\tret = cros_ec_cmd(typec->ec, 0, EC_CMD_TYPEC_STATUS, &req, sizeof(req),\n\t\t\t  &resp, sizeof(resp));\n\tif (ret < 0) {\n\t\tdev_warn(typec->dev, \"EC_CMD_TYPEC_STATUS failed for port: %d\\n\", port_num);\n\t\treturn;\n\t}\n\n\t \n\tif (resp.events & PD_STATUS_EVENT_HARD_RESET) {\n\t\tcros_typec_remove_partner(typec, port_num);\n\t\tcros_typec_remove_cable(typec, port_num);\n\n\t\tret = cros_typec_send_clear_event(typec, port_num,\n\t\t\t\t\t\t  PD_STATUS_EVENT_HARD_RESET);\n\t\tif (ret < 0)\n\t\t\tdev_warn(typec->dev,\n\t\t\t\t \"Failed hard reset event clear, port: %d\\n\", port_num);\n\t\treturn;\n\t}\n\n\t \n\tif (resp.events & PD_STATUS_EVENT_SOP_DISC_DONE && !typec->ports[port_num]->sop_disc_done) {\n\t\tu16 sop_revision;\n\n\t\t \n\t\tsop_revision = (le16_to_cpu(resp.sop_revision) & 0xff00) >> 4;\n\t\tret = cros_typec_handle_sop_disc(typec, port_num, sop_revision);\n\t\tif (ret < 0)\n\t\t\tdev_err(typec->dev, \"Couldn't parse SOP Disc data, port: %d\\n\", port_num);\n\t\telse {\n\t\t\ttypec->ports[port_num]->sop_disc_done = true;\n\t\t\tret = cros_typec_send_clear_event(typec, port_num,\n\t\t\t\t\t\t\t  PD_STATUS_EVENT_SOP_DISC_DONE);\n\t\t\tif (ret < 0)\n\t\t\t\tdev_warn(typec->dev,\n\t\t\t\t\t \"Failed SOP Disc event clear, port: %d\\n\", port_num);\n\t\t}\n\t\tif (resp.sop_connected)\n\t\t\ttypec_set_pwr_opmode(typec->ports[port_num]->port, TYPEC_PWR_MODE_PD);\n\n\t\tcros_typec_register_partner_pdos(typec, &resp, port_num);\n\t}\n\n\tif (resp.events & PD_STATUS_EVENT_SOP_PRIME_DISC_DONE &&\n\t    !typec->ports[port_num]->sop_prime_disc_done) {\n\t\tu16 sop_prime_revision;\n\n\t\t \n\t\tsop_prime_revision = (le16_to_cpu(resp.sop_prime_revision) & 0xff00) >> 4;\n\t\tret = cros_typec_handle_sop_prime_disc(typec, port_num, sop_prime_revision);\n\t\tif (ret < 0)\n\t\t\tdev_err(typec->dev, \"Couldn't parse SOP' Disc data, port: %d\\n\", port_num);\n\t\telse {\n\t\t\ttypec->ports[port_num]->sop_prime_disc_done = true;\n\t\t\tret = cros_typec_send_clear_event(typec, port_num,\n\t\t\t\t\t\t\t  PD_STATUS_EVENT_SOP_PRIME_DISC_DONE);\n\t\t\tif (ret < 0)\n\t\t\t\tdev_warn(typec->dev,\n\t\t\t\t\t \"Failed SOP Disc event clear, port: %d\\n\", port_num);\n\t\t}\n\t}\n\n\tif (resp.events & PD_STATUS_EVENT_VDM_REQ_REPLY) {\n\t\tcros_typec_handle_vdm_response(typec, port_num);\n\t\tret = cros_typec_send_clear_event(typec, port_num, PD_STATUS_EVENT_VDM_REQ_REPLY);\n\t\tif (ret < 0)\n\t\t\tdev_warn(typec->dev, \"Failed VDM Reply event clear, port: %d\\n\", port_num);\n\t}\n\n\tif (resp.events & PD_STATUS_EVENT_VDM_ATTENTION) {\n\t\tcros_typec_handle_vdm_attention(typec, port_num);\n\t\tret = cros_typec_send_clear_event(typec, port_num, PD_STATUS_EVENT_VDM_ATTENTION);\n\t\tif (ret < 0)\n\t\t\tdev_warn(typec->dev, \"Failed VDM attention event clear, port: %d\\n\",\n\t\t\t\t port_num);\n\t}\n}\n\nstatic int cros_typec_port_update(struct cros_typec_data *typec, int port_num)\n{\n\tstruct ec_params_usb_pd_control req;\n\tstruct ec_response_usb_pd_control_v2 resp;\n\tint ret;\n\n\tif (port_num < 0 || port_num >= typec->num_ports) {\n\t\tdev_err(typec->dev, \"cannot get status for invalid port %d\\n\",\n\t\t\tport_num);\n\t\treturn -EINVAL;\n\t}\n\n\treq.port = port_num;\n\treq.role = USB_PD_CTRL_ROLE_NO_CHANGE;\n\treq.mux = USB_PD_CTRL_MUX_NO_CHANGE;\n\treq.swap = USB_PD_CTRL_SWAP_NONE;\n\n\tret = cros_ec_cmd(typec->ec, typec->pd_ctrl_ver,\n\t\t\t  EC_CMD_USB_PD_CONTROL, &req, sizeof(req),\n\t\t\t  &resp, sizeof(resp));\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = cros_typec_configure_mux(typec, port_num, &resp);\n\tif (ret)\n\t\tdev_warn(typec->dev, \"Configure muxes failed, err = %d\\n\", ret);\n\n\tdev_dbg(typec->dev, \"Enabled %d: 0x%hhx\\n\", port_num, resp.enabled);\n\tdev_dbg(typec->dev, \"Role %d: 0x%hhx\\n\", port_num, resp.role);\n\tdev_dbg(typec->dev, \"Polarity %d: 0x%hhx\\n\", port_num, resp.polarity);\n\tdev_dbg(typec->dev, \"State %d: %s\\n\", port_num, resp.state);\n\n\tif (typec->pd_ctrl_ver != 0)\n\t\tcros_typec_set_port_params_v1(typec, port_num,\n\t\t\t(struct ec_response_usb_pd_control_v1 *)&resp);\n\telse\n\t\tcros_typec_set_port_params_v0(typec, port_num,\n\t\t\t(struct ec_response_usb_pd_control *) &resp);\n\n\tif (typec->typec_cmd_supported)\n\t\tcros_typec_handle_status(typec, port_num);\n\n\treturn 0;\n}\n\nstatic int cros_typec_get_cmd_version(struct cros_typec_data *typec)\n{\n\tstruct ec_params_get_cmd_versions_v1 req_v1;\n\tstruct ec_response_get_cmd_versions resp;\n\tint ret;\n\n\t \n\treq_v1.cmd = EC_CMD_USB_PD_CONTROL;\n\tret = cros_ec_cmd(typec->ec, 1, EC_CMD_GET_CMD_VERSIONS,\n\t\t\t  &req_v1, sizeof(req_v1), &resp, sizeof(resp));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (resp.version_mask & EC_VER_MASK(2))\n\t\ttypec->pd_ctrl_ver = 2;\n\telse if (resp.version_mask & EC_VER_MASK(1))\n\t\ttypec->pd_ctrl_ver = 1;\n\telse\n\t\ttypec->pd_ctrl_ver = 0;\n\n\tdev_dbg(typec->dev, \"PD Control has version mask 0x%02x\\n\",\n\t\ttypec->pd_ctrl_ver & 0xff);\n\n\treturn 0;\n}\n\nstatic void cros_typec_port_work(struct work_struct *work)\n{\n\tstruct cros_typec_data *typec = container_of(work, struct cros_typec_data, port_work);\n\tint ret, i;\n\n\tfor (i = 0; i < typec->num_ports; i++) {\n\t\tret = cros_typec_port_update(typec, i);\n\t\tif (ret < 0)\n\t\t\tdev_warn(typec->dev, \"Update failed for port: %d\\n\", i);\n\t}\n}\n\nstatic int cros_ec_typec_event(struct notifier_block *nb,\n\t\t\t       unsigned long host_event, void *_notify)\n{\n\tstruct cros_typec_data *typec = container_of(nb, struct cros_typec_data, nb);\n\n\tflush_work(&typec->port_work);\n\tschedule_work(&typec->port_work);\n\n\treturn NOTIFY_OK;\n}\n\n#ifdef CONFIG_ACPI\nstatic const struct acpi_device_id cros_typec_acpi_id[] = {\n\t{ \"GOOG0014\", 0 },\n\t{}\n};\nMODULE_DEVICE_TABLE(acpi, cros_typec_acpi_id);\n#endif\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id cros_typec_of_match[] = {\n\t{ .compatible = \"google,cros-ec-typec\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, cros_typec_of_match);\n#endif\n\nstatic int cros_typec_probe(struct platform_device *pdev)\n{\n\tstruct cros_ec_dev *ec_dev = NULL;\n\tstruct device *dev = &pdev->dev;\n\tstruct cros_typec_data *typec;\n\tstruct ec_response_usb_pd_ports resp;\n\tint ret, i;\n\n\ttypec = devm_kzalloc(dev, sizeof(*typec), GFP_KERNEL);\n\tif (!typec)\n\t\treturn -ENOMEM;\n\n\ttypec->dev = dev;\n\n\ttypec->ec = dev_get_drvdata(pdev->dev.parent);\n\tif (!typec->ec) {\n\t\tdev_err(dev, \"couldn't find parent EC device\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tplatform_set_drvdata(pdev, typec);\n\n\tret = cros_typec_get_cmd_version(typec);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to get PD command version info\\n\");\n\t\treturn ret;\n\t}\n\n\tec_dev = dev_get_drvdata(&typec->ec->ec->dev);\n\tif (!ec_dev)\n\t\treturn -EPROBE_DEFER;\n\n\ttypec->typec_cmd_supported = cros_ec_check_features(ec_dev, EC_FEATURE_TYPEC_CMD);\n\ttypec->needs_mux_ack = cros_ec_check_features(ec_dev, EC_FEATURE_TYPEC_MUX_REQUIRE_AP_ACK);\n\n\tret = cros_ec_cmd(typec->ec, 0, EC_CMD_USB_PD_PORTS, NULL, 0,\n\t\t\t  &resp, sizeof(resp));\n\tif (ret < 0)\n\t\treturn ret;\n\n\ttypec->num_ports = resp.num_ports;\n\tif (typec->num_ports > EC_USB_PD_MAX_PORTS) {\n\t\tdev_warn(typec->dev,\n\t\t\t \"Too many ports reported: %d, limiting to max: %d\\n\",\n\t\t\t typec->num_ports, EC_USB_PD_MAX_PORTS);\n\t\ttypec->num_ports = EC_USB_PD_MAX_PORTS;\n\t}\n\n\tret = cros_typec_init_ports(typec);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tINIT_WORK(&typec->port_work, cros_typec_port_work);\n\n\t \n\tfor (i = 0; i < typec->num_ports; i++) {\n\t\tret = cros_typec_port_update(typec, i);\n\t\tif (ret < 0)\n\t\t\tgoto unregister_ports;\n\t}\n\n\ttypec->nb.notifier_call = cros_ec_typec_event;\n\tret = cros_usbpd_register_notify(&typec->nb);\n\tif (ret < 0)\n\t\tgoto unregister_ports;\n\n\treturn 0;\n\nunregister_ports:\n\tcros_unregister_ports(typec);\n\treturn ret;\n}\n\nstatic int __maybe_unused cros_typec_suspend(struct device *dev)\n{\n\tstruct cros_typec_data *typec = dev_get_drvdata(dev);\n\n\tcancel_work_sync(&typec->port_work);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused cros_typec_resume(struct device *dev)\n{\n\tstruct cros_typec_data *typec = dev_get_drvdata(dev);\n\n\t \n\tschedule_work(&typec->port_work);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops cros_typec_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(cros_typec_suspend, cros_typec_resume)\n};\n\nstatic struct platform_driver cros_typec_driver = {\n\t.driver\t= {\n\t\t.name = DRV_NAME,\n\t\t.acpi_match_table = ACPI_PTR(cros_typec_acpi_id),\n\t\t.of_match_table = of_match_ptr(cros_typec_of_match),\n\t\t.pm = &cros_typec_pm_ops,\n\t},\n\t.probe = cros_typec_probe,\n};\n\nmodule_platform_driver(cros_typec_driver);\n\nMODULE_AUTHOR(\"Prashant Malani <pmalani@chromium.org>\");\nMODULE_DESCRIPTION(\"Chrome OS EC Type C control\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}