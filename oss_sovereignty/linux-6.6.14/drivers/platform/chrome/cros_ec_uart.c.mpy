{
  "module_name": "cros_ec_uart.c",
  "hash_id": "2b99e8c943197981eefcf5e2c2c77be1743ec6d796c6705e0682047507259bec",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/chrome/cros_ec_uart.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/delay.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_data/cros_ec_proto.h>\n#include <linux/serdev.h>\n#include <linux/slab.h>\n#include <uapi/linux/sched/types.h>\n\n#include \"cros_ec.h\"\n\n \n#define EC_MSG_DEADLINE_MS\t\t500\n\n \nstruct response_info {\n\tvoid *data;\n\tsize_t max_size;\n\tsize_t size;\n\tsize_t exp_len;\n\tint status;\n\twait_queue_head_t wait_queue;\n};\n\n \nstruct cros_ec_uart {\n\tstruct serdev_device *serdev;\n\tu32 baudrate;\n\tu8 flowcontrol;\n\tu32 irq;\n\tstruct response_info response;\n};\n\nstatic int cros_ec_uart_rx_bytes(struct serdev_device *serdev,\n\t\t\t\t const u8 *data,\n\t\t\t\t size_t count)\n{\n\tstruct ec_host_response *host_response;\n\tstruct cros_ec_device *ec_dev = serdev_device_get_drvdata(serdev);\n\tstruct cros_ec_uart *ec_uart = ec_dev->priv;\n\tstruct response_info *resp = &ec_uart->response;\n\n\t \n\tif (!resp->data) {\n\t\t \n\t\tdev_warn(ec_dev->dev, \"Bytes received out of band, dropping them.\\n\");\n\t\treturn count;\n\t}\n\n\t \n\tif (resp->size + count > resp->max_size) {\n\t\tresp->status = -EMSGSIZE;\n\t\twake_up(&resp->wait_queue);\n\t\treturn count;\n\t}\n\n\tmemcpy(resp->data + resp->size, data, count);\n\n\tresp->size += count;\n\n\t \n\tif (resp->size >= sizeof(*host_response) && resp->exp_len == 0) {\n\t\thost_response = (struct ec_host_response *)resp->data;\n\t\tresp->exp_len = host_response->data_len + sizeof(*host_response);\n\t}\n\n\t \n\tif (resp->size >= sizeof(*host_response) && resp->size == resp->exp_len) {\n\t\tresp->status = 1;\n\t\twake_up(&resp->wait_queue);\n\t}\n\n\treturn count;\n}\n\nstatic int cros_ec_uart_pkt_xfer(struct cros_ec_device *ec_dev,\n\t\t\t\t struct cros_ec_command *ec_msg)\n{\n\tstruct cros_ec_uart *ec_uart = ec_dev->priv;\n\tstruct serdev_device *serdev = ec_uart->serdev;\n\tstruct response_info *resp = &ec_uart->response;\n\tstruct ec_host_response *host_response;\n\tunsigned int len;\n\tint ret, i;\n\tu8 sum;\n\n\tlen = cros_ec_prepare_tx(ec_dev, ec_msg);\n\tdev_dbg(ec_dev->dev, \"Prepared len=%d\\n\", len);\n\n\t \n\tresp->data = ec_dev->din;\n\tresp->max_size = ec_dev->din_size;\n\tresp->size = 0;\n\tresp->exp_len = 0;\n\tresp->status = 0;\n\n\tret = serdev_device_write_buf(serdev, ec_dev->dout, len);\n\tif (ret < 0 || ret < len) {\n\t\tdev_err(ec_dev->dev, \"Unable to write data\\n\");\n\t\tif (ret >= 0)\n\t\t\tret = -EIO;\n\t\tgoto exit;\n\t}\n\n\tret = wait_event_timeout(resp->wait_queue, resp->status,\n\t\t\t\t msecs_to_jiffies(EC_MSG_DEADLINE_MS));\n\tif (ret == 0) {\n\t\tdev_warn(ec_dev->dev, \"Timed out waiting for response.\\n\");\n\t\tret = -ETIMEDOUT;\n\t\tgoto exit;\n\t}\n\n\tif (resp->status < 0) {\n\t\tret = resp->status;\n\t\tdev_warn(ec_dev->dev, \"Error response received: %d\\n\", ret);\n\t\tgoto exit;\n\t}\n\n\thost_response = (struct ec_host_response *)ec_dev->din;\n\tec_msg->result = host_response->result;\n\n\tif (host_response->data_len > ec_msg->insize) {\n\t\tdev_err(ec_dev->dev, \"Resp too long (%d bytes, expected %d)\\n\",\n\t\t\thost_response->data_len, ec_msg->insize);\n\t\tret = -ENOSPC;\n\t\tgoto exit;\n\t}\n\n\t \n\tsum = 0;\n\tfor (i = 0; i < sizeof(*host_response) + host_response->data_len; i++)\n\t\tsum += ec_dev->din[i];\n\n\tif (sum) {\n\t\tdev_err(ec_dev->dev, \"Bad packet checksum calculated %x\\n\", sum);\n\t\tret = -EBADMSG;\n\t\tgoto exit;\n\t}\n\n\tmemcpy(ec_msg->data, ec_dev->din + sizeof(*host_response), host_response->data_len);\n\n\tret = host_response->data_len;\n\nexit:\n\t \n\tresp->data = NULL;\n\n\tif (ec_msg->command == EC_CMD_REBOOT_EC)\n\t\tmsleep(EC_REBOOT_DELAY_MS);\n\n\treturn ret;\n}\n\nstatic int cros_ec_uart_resource(struct acpi_resource *ares, void *data)\n{\n\tstruct cros_ec_uart *ec_uart = data;\n\tstruct acpi_resource_uart_serialbus *sb = &ares->data.uart_serial_bus;\n\n\tif (ares->type == ACPI_RESOURCE_TYPE_SERIAL_BUS &&\n\t    sb->type == ACPI_RESOURCE_SERIAL_TYPE_UART) {\n\t\tec_uart->baudrate = sb->default_baud_rate;\n\t\tdev_dbg(&ec_uart->serdev->dev, \"Baudrate %d\\n\", ec_uart->baudrate);\n\n\t\tec_uart->flowcontrol = sb->flow_control;\n\t\tdev_dbg(&ec_uart->serdev->dev, \"Flow control %d\\n\", ec_uart->flowcontrol);\n\t}\n\n\treturn 0;\n}\n\nstatic int cros_ec_uart_acpi_probe(struct cros_ec_uart *ec_uart)\n{\n\tint ret;\n\tLIST_HEAD(resources);\n\tstruct acpi_device *adev = ACPI_COMPANION(&ec_uart->serdev->dev);\n\n\tret = acpi_dev_get_resources(adev, &resources, cros_ec_uart_resource, ec_uart);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tacpi_dev_free_resource_list(&resources);\n\n\t \n\tret = acpi_dev_gpio_irq_get(adev, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tec_uart->irq = ret;\n\tdev_dbg(&ec_uart->serdev->dev, \"IRQ number %d\\n\", ec_uart->irq);\n\n\treturn 0;\n}\n\nstatic const struct serdev_device_ops cros_ec_uart_client_ops = {\n\t.receive_buf = cros_ec_uart_rx_bytes,\n};\n\nstatic int cros_ec_uart_probe(struct serdev_device *serdev)\n{\n\tstruct device *dev = &serdev->dev;\n\tstruct cros_ec_device *ec_dev;\n\tstruct cros_ec_uart *ec_uart;\n\tint ret;\n\n\tec_uart = devm_kzalloc(dev, sizeof(*ec_uart), GFP_KERNEL);\n\tif (!ec_uart)\n\t\treturn -ENOMEM;\n\n\tec_dev = devm_kzalloc(dev, sizeof(*ec_dev), GFP_KERNEL);\n\tif (!ec_dev)\n\t\treturn -ENOMEM;\n\n\tret = devm_serdev_device_open(dev, serdev);\n\tif (ret) {\n\t\tdev_err(dev, \"Unable to open UART device\");\n\t\treturn ret;\n\t}\n\n\tserdev_device_set_drvdata(serdev, ec_dev);\n\tinit_waitqueue_head(&ec_uart->response.wait_queue);\n\n\tec_uart->serdev = serdev;\n\n\tret = cros_ec_uart_acpi_probe(ec_uart);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to get ACPI info (%d)\", ret);\n\t\treturn ret;\n\t}\n\n\tret = serdev_device_set_baudrate(serdev, ec_uart->baudrate);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to set up host baud rate (%d)\", ret);\n\t\treturn ret;\n\t}\n\n\tserdev_device_set_flow_control(serdev, ec_uart->flowcontrol);\n\n\t \n\tec_dev->phys_name = dev_name(dev);\n\tec_dev->dev = dev;\n\tec_dev->priv = ec_uart;\n\tec_dev->irq = ec_uart->irq;\n\tec_dev->cmd_xfer = NULL;\n\tec_dev->pkt_xfer = cros_ec_uart_pkt_xfer;\n\tec_dev->din_size = sizeof(struct ec_host_response) +\n\t\t\t   sizeof(struct ec_response_get_protocol_info);\n\tec_dev->dout_size = sizeof(struct ec_host_request);\n\n\tserdev_device_set_client_ops(serdev, &cros_ec_uart_client_ops);\n\n\treturn cros_ec_register(ec_dev);\n}\n\nstatic void cros_ec_uart_remove(struct serdev_device *serdev)\n{\n\tstruct cros_ec_device *ec_dev = serdev_device_get_drvdata(serdev);\n\n\tcros_ec_unregister(ec_dev);\n};\n\nstatic int __maybe_unused cros_ec_uart_suspend(struct device *dev)\n{\n\tstruct cros_ec_device *ec_dev = dev_get_drvdata(dev);\n\n\treturn cros_ec_suspend(ec_dev);\n}\n\nstatic int __maybe_unused cros_ec_uart_resume(struct device *dev)\n{\n\tstruct cros_ec_device *ec_dev = dev_get_drvdata(dev);\n\n\treturn cros_ec_resume(ec_dev);\n}\n\nstatic SIMPLE_DEV_PM_OPS(cros_ec_uart_pm_ops, cros_ec_uart_suspend,\n\t\t\t cros_ec_uart_resume);\n\nstatic const struct of_device_id cros_ec_uart_of_match[] = {\n\t{ .compatible = \"google,cros-ec-uart\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, cros_ec_uart_of_match);\n\n#ifdef CONFIG_ACPI\nstatic const struct acpi_device_id cros_ec_uart_acpi_id[] = {\n\t{ \"GOOG0019\", 0 },\n\t{}\n};\n\nMODULE_DEVICE_TABLE(acpi, cros_ec_uart_acpi_id);\n#endif\n\nstatic struct serdev_device_driver cros_ec_uart_driver = {\n\t.driver\t= {\n\t\t.name\t= \"cros-ec-uart\",\n\t\t.acpi_match_table = ACPI_PTR(cros_ec_uart_acpi_id),\n\t\t.of_match_table = cros_ec_uart_of_match,\n\t\t.pm\t= &cros_ec_uart_pm_ops,\n\t},\n\t.probe\t\t= cros_ec_uart_probe,\n\t.remove\t\t= cros_ec_uart_remove,\n};\n\nmodule_serdev_device_driver(cros_ec_uart_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"UART interface for ChromeOS Embedded Controller\");\nMODULE_AUTHOR(\"Bhanu Prakash Maiya <bhanumaiya@chromium.org>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}