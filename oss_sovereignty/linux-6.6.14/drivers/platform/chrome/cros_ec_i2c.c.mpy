{
  "module_name": "cros_ec_i2c.c",
  "hash_id": "d5f4430bbf82fc5c65dd22c5546f84ad8cbc4543525ea4a9bb86219107e202ab",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/chrome/cros_ec_i2c.c",
  "human_readable_source": "\n\n\n\n\n#include <linux/acpi.h>\n#include <linux/delay.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/platform_data/cros_ec_commands.h>\n#include <linux/platform_data/cros_ec_proto.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n\n#include \"cros_ec.h\"\n\n \nstruct ec_host_request_i2c {\n\t \n\tuint8_t  command_protocol;\n\tstruct ec_host_request ec_request;\n} __packed;\n\n\n \nstruct ec_host_response_i2c {\n\tuint8_t result;\n\tuint8_t packet_length;\n\tstruct ec_host_response ec_response;\n} __packed;\n\nstatic inline struct cros_ec_device *to_ec_dev(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\n\treturn i2c_get_clientdata(client);\n}\n\nstatic int cros_ec_pkt_xfer_i2c(struct cros_ec_device *ec_dev,\n\t\t\t\tstruct cros_ec_command *msg)\n{\n\tstruct i2c_client *client = ec_dev->priv;\n\tint ret = -ENOMEM;\n\tint i;\n\tint packet_len;\n\tu8 *out_buf = NULL;\n\tu8 *in_buf = NULL;\n\tu8 sum;\n\tstruct i2c_msg i2c_msg[2];\n\tstruct ec_host_response *ec_response;\n\tstruct ec_host_request_i2c *ec_request_i2c;\n\tstruct ec_host_response_i2c *ec_response_i2c;\n\tint request_header_size = sizeof(struct ec_host_request_i2c);\n\tint response_header_size = sizeof(struct ec_host_response_i2c);\n\n\ti2c_msg[0].addr = client->addr;\n\ti2c_msg[0].flags = 0;\n\ti2c_msg[1].addr = client->addr;\n\ti2c_msg[1].flags = I2C_M_RD;\n\n\tpacket_len = msg->insize + response_header_size;\n\tif (packet_len > ec_dev->din_size) {\n\t\tret = -EINVAL;\n\t\tgoto done;\n\t}\n\tin_buf = ec_dev->din;\n\ti2c_msg[1].len = packet_len;\n\ti2c_msg[1].buf = (char *) in_buf;\n\n\tpacket_len = msg->outsize + request_header_size;\n\tif (packet_len > ec_dev->dout_size) {\n\t\tret = -EINVAL;\n\t\tgoto done;\n\t}\n\tout_buf = ec_dev->dout;\n\ti2c_msg[0].len = packet_len;\n\ti2c_msg[0].buf = (char *) out_buf;\n\n\t \n\tec_request_i2c = (struct ec_host_request_i2c *) out_buf;\n\tec_request_i2c->command_protocol = EC_COMMAND_PROTOCOL_3;\n\n\tec_dev->dout++;\n\tret = cros_ec_prepare_tx(ec_dev, msg);\n\tif (ret < 0)\n\t\tgoto done;\n\tec_dev->dout--;\n\n\t \n\tret = i2c_transfer(client->adapter, i2c_msg, 2);\n\tif (ret < 0) {\n\t\tdev_dbg(ec_dev->dev, \"i2c transfer failed: %d\\n\", ret);\n\t\tgoto done;\n\t} else if (ret != 2) {\n\t\tdev_err(ec_dev->dev, \"failed to get response: %d\\n\", ret);\n\t\tret = -EIO;\n\t\tgoto done;\n\t}\n\n\tec_response_i2c = (struct ec_host_response_i2c *) in_buf;\n\tmsg->result = ec_response_i2c->result;\n\tec_response = &ec_response_i2c->ec_response;\n\n\tswitch (msg->result) {\n\tcase EC_RES_SUCCESS:\n\t\tbreak;\n\tcase EC_RES_IN_PROGRESS:\n\t\tret = -EAGAIN;\n\t\tdev_dbg(ec_dev->dev, \"command 0x%02x in progress\\n\",\n\t\t\tmsg->command);\n\t\tgoto done;\n\n\tdefault:\n\t\tdev_dbg(ec_dev->dev, \"command 0x%02x returned %d\\n\",\n\t\t\tmsg->command, msg->result);\n\t\t \n\t\tif (ec_response_i2c->result == EC_RES_INVALID_COMMAND &&\n\t\t    ec_response_i2c->packet_length == 0) {\n\t\t\tret = -EPROTONOSUPPORT;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tif (ec_response_i2c->packet_length < sizeof(struct ec_host_response)) {\n\t\tdev_err(ec_dev->dev,\n\t\t\t\"response of %u bytes too short; not a full header\\n\",\n\t\t\tec_response_i2c->packet_length);\n\t\tret = -EBADMSG;\n\t\tgoto done;\n\t}\n\n\tif (msg->insize < ec_response->data_len) {\n\t\tdev_err(ec_dev->dev,\n\t\t\t\"response data size is too large: expected %u, got %u\\n\",\n\t\t\tmsg->insize,\n\t\t\tec_response->data_len);\n\t\tret = -EMSGSIZE;\n\t\tgoto done;\n\t}\n\n\t \n\tsum = 0;\n\tfor (i = 0; i < sizeof(struct ec_host_response); i++)\n\t\tsum += ((u8 *)ec_response)[i];\n\n\tmemcpy(msg->data,\n\t       in_buf + response_header_size,\n\t       ec_response->data_len);\n\tfor (i = 0; i < ec_response->data_len; i++)\n\t\tsum += msg->data[i];\n\n\t \n\tif (sum) {\n\t\tdev_err(ec_dev->dev, \"bad packet checksum\\n\");\n\t\tret = -EBADMSG;\n\t\tgoto done;\n\t}\n\n\tret = ec_response->data_len;\n\ndone:\n\tif (msg->command == EC_CMD_REBOOT_EC)\n\t\tmsleep(EC_REBOOT_DELAY_MS);\n\n\treturn ret;\n}\n\nstatic int cros_ec_cmd_xfer_i2c(struct cros_ec_device *ec_dev,\n\t\t\t\tstruct cros_ec_command *msg)\n{\n\tstruct i2c_client *client = ec_dev->priv;\n\tint ret = -ENOMEM;\n\tint i;\n\tint len;\n\tint packet_len;\n\tu8 *out_buf = NULL;\n\tu8 *in_buf = NULL;\n\tu8 sum;\n\tstruct i2c_msg i2c_msg[2];\n\n\ti2c_msg[0].addr = client->addr;\n\ti2c_msg[0].flags = 0;\n\ti2c_msg[1].addr = client->addr;\n\ti2c_msg[1].flags = I2C_M_RD;\n\n\t \n\tpacket_len = msg->insize + 3;\n\tin_buf = kzalloc(packet_len, GFP_KERNEL);\n\tif (!in_buf)\n\t\tgoto done;\n\ti2c_msg[1].len = packet_len;\n\ti2c_msg[1].buf = (char *)in_buf;\n\n\t \n\tpacket_len = msg->outsize + 4;\n\tout_buf = kzalloc(packet_len, GFP_KERNEL);\n\tif (!out_buf)\n\t\tgoto done;\n\ti2c_msg[0].len = packet_len;\n\ti2c_msg[0].buf = (char *)out_buf;\n\n\tout_buf[0] = EC_CMD_VERSION0 + msg->version;\n\tout_buf[1] = msg->command;\n\tout_buf[2] = msg->outsize;\n\n\t \n\tsum = out_buf[0] + out_buf[1] + out_buf[2];\n\tfor (i = 0; i < msg->outsize; i++) {\n\t\tout_buf[3 + i] = msg->data[i];\n\t\tsum += out_buf[3 + i];\n\t}\n\tout_buf[3 + msg->outsize] = sum;\n\n\t \n\tret = i2c_transfer(client->adapter, i2c_msg, 2);\n\tif (ret < 0) {\n\t\tdev_err(ec_dev->dev, \"i2c transfer failed: %d\\n\", ret);\n\t\tgoto done;\n\t} else if (ret != 2) {\n\t\tdev_err(ec_dev->dev, \"failed to get response: %d\\n\", ret);\n\t\tret = -EIO;\n\t\tgoto done;\n\t}\n\n\t \n\tmsg->result = i2c_msg[1].buf[0];\n\tret = cros_ec_check_result(ec_dev, msg);\n\tif (ret)\n\t\tgoto done;\n\n\tlen = in_buf[1];\n\tif (len > msg->insize) {\n\t\tdev_err(ec_dev->dev, \"packet too long (%d bytes, expected %d)\",\n\t\t\tlen, msg->insize);\n\t\tret = -ENOSPC;\n\t\tgoto done;\n\t}\n\n\t \n\tsum = in_buf[0] + in_buf[1];\n\tfor (i = 0; i < len; i++) {\n\t\tmsg->data[i] = in_buf[2 + i];\n\t\tsum += in_buf[2 + i];\n\t}\n\tdev_dbg(ec_dev->dev, \"packet: %*ph, sum = %02x\\n\",\n\t\ti2c_msg[1].len, in_buf, sum);\n\tif (sum != in_buf[2 + len]) {\n\t\tdev_err(ec_dev->dev, \"bad packet checksum\\n\");\n\t\tret = -EBADMSG;\n\t\tgoto done;\n\t}\n\n\tret = len;\ndone:\n\tkfree(in_buf);\n\tkfree(out_buf);\n\tif (msg->command == EC_CMD_REBOOT_EC)\n\t\tmsleep(EC_REBOOT_DELAY_MS);\n\n\treturn ret;\n}\n\nstatic int cros_ec_i2c_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct cros_ec_device *ec_dev = NULL;\n\tint err;\n\n\tec_dev = devm_kzalloc(dev, sizeof(*ec_dev), GFP_KERNEL);\n\tif (!ec_dev)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(client, ec_dev);\n\tec_dev->dev = dev;\n\tec_dev->priv = client;\n\tec_dev->irq = client->irq;\n\tec_dev->cmd_xfer = cros_ec_cmd_xfer_i2c;\n\tec_dev->pkt_xfer = cros_ec_pkt_xfer_i2c;\n\tec_dev->phys_name = client->adapter->name;\n\tec_dev->din_size = sizeof(struct ec_host_response_i2c) +\n\t\t\t   sizeof(struct ec_response_get_protocol_info);\n\tec_dev->dout_size = sizeof(struct ec_host_request_i2c);\n\n\terr = cros_ec_register(ec_dev);\n\tif (err) {\n\t\tdev_err(dev, \"cannot register EC\\n\");\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic void cros_ec_i2c_remove(struct i2c_client *client)\n{\n\tstruct cros_ec_device *ec_dev = i2c_get_clientdata(client);\n\n\tcros_ec_unregister(ec_dev);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int cros_ec_i2c_suspend(struct device *dev)\n{\n\tstruct cros_ec_device *ec_dev = to_ec_dev(dev);\n\n\treturn cros_ec_suspend(ec_dev);\n}\n\nstatic int cros_ec_i2c_resume(struct device *dev)\n{\n\tstruct cros_ec_device *ec_dev = to_ec_dev(dev);\n\n\treturn cros_ec_resume(ec_dev);\n}\n#endif\n\nstatic const struct dev_pm_ops cros_ec_i2c_pm_ops = {\n\tSET_LATE_SYSTEM_SLEEP_PM_OPS(cros_ec_i2c_suspend, cros_ec_i2c_resume)\n};\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id cros_ec_i2c_of_match[] = {\n\t{ .compatible = \"google,cros-ec-i2c\", },\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, cros_ec_i2c_of_match);\n#endif\n\nstatic const struct i2c_device_id cros_ec_i2c_id[] = {\n\t{ \"cros-ec-i2c\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, cros_ec_i2c_id);\n\n#ifdef CONFIG_ACPI\nstatic const struct acpi_device_id cros_ec_i2c_acpi_id[] = {\n\t{ \"GOOG0008\", 0 },\n\t{   }\n};\nMODULE_DEVICE_TABLE(acpi, cros_ec_i2c_acpi_id);\n#endif\n\nstatic struct i2c_driver cros_ec_driver = {\n\t.driver\t= {\n\t\t.name\t= \"cros-ec-i2c\",\n\t\t.acpi_match_table = ACPI_PTR(cros_ec_i2c_acpi_id),\n\t\t.of_match_table = of_match_ptr(cros_ec_i2c_of_match),\n\t\t.pm\t= &cros_ec_i2c_pm_ops,\n\t},\n\t.probe\t\t= cros_ec_i2c_probe,\n\t.remove\t\t= cros_ec_i2c_remove,\n\t.id_table\t= cros_ec_i2c_id,\n};\n\nmodule_i2c_driver(cros_ec_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"I2C interface for ChromeOS Embedded Controller\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}