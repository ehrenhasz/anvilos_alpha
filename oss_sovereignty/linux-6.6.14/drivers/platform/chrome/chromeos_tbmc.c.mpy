{
  "module_name": "chromeos_tbmc.c",
  "hash_id": "d80c23116f0cdf5cdee2ad3dfc5027a7732095f1aafd2bd6e15894ce9c4ac8d6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/chrome/chromeos_tbmc.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n#include <linux/acpi.h>\n#include <linux/input.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/printk.h>\n\n#define DRV_NAME \"chromeos_tbmc\"\n#define ACPI_DRV_NAME \"GOOG0006\"\n\nstatic int chromeos_tbmc_query_switch(struct acpi_device *adev,\n\t\t\t\t     struct input_dev *idev)\n{\n\tunsigned long long state;\n\tacpi_status status;\n\n\tstatus = acpi_evaluate_integer(adev->handle, \"TBMC\", NULL, &state);\n\tif (ACPI_FAILURE(status))\n\t\treturn -ENODEV;\n\n\t \n\tinput_report_switch(idev, SW_TABLET_MODE, state);\n\tinput_sync(idev);\n\n\treturn 0;\n}\n\nstatic __maybe_unused int chromeos_tbmc_resume(struct device *dev)\n{\n\tstruct acpi_device *adev = to_acpi_device(dev);\n\n\treturn chromeos_tbmc_query_switch(adev, adev->driver_data);\n}\n\nstatic void chromeos_tbmc_notify(struct acpi_device *adev, u32 event)\n{\n\tacpi_pm_wakeup_event(&adev->dev);\n\tswitch (event) {\n\tcase 0x80:\n\t\tchromeos_tbmc_query_switch(adev, adev->driver_data);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&adev->dev, \"Unexpected event: 0x%08X\\n\", event);\n\t}\n}\n\nstatic int chromeos_tbmc_open(struct input_dev *idev)\n{\n\tstruct acpi_device *adev = input_get_drvdata(idev);\n\n\treturn chromeos_tbmc_query_switch(adev, idev);\n}\n\nstatic int chromeos_tbmc_add(struct acpi_device *adev)\n{\n\tstruct input_dev *idev;\n\tstruct device *dev = &adev->dev;\n\tint ret;\n\n\tidev = devm_input_allocate_device(dev);\n\tif (!idev)\n\t\treturn -ENOMEM;\n\n\tidev->name = \"Tablet Mode Switch\";\n\tidev->phys = acpi_device_hid(adev);\n\n\tidev->id.bustype = BUS_HOST;\n\tidev->id.version = 1;\n\tidev->id.product = 0;\n\tidev->open = chromeos_tbmc_open;\n\n\tinput_set_drvdata(idev, adev);\n\tadev->driver_data = idev;\n\n\tinput_set_capability(idev, EV_SW, SW_TABLET_MODE);\n\tret = input_register_device(idev);\n\tif (ret) {\n\t\tdev_err(dev, \"cannot register input device\\n\");\n\t\treturn ret;\n\t}\n\tdevice_init_wakeup(dev, true);\n\treturn 0;\n}\n\nstatic const struct acpi_device_id chromeos_tbmc_acpi_device_ids[] = {\n\t{ ACPI_DRV_NAME, 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(acpi, chromeos_tbmc_acpi_device_ids);\n\nstatic SIMPLE_DEV_PM_OPS(chromeos_tbmc_pm_ops, NULL,\n\t\tchromeos_tbmc_resume);\n\nstatic struct acpi_driver chromeos_tbmc_driver = {\n\t.name = DRV_NAME,\n\t.class = DRV_NAME,\n\t.ids = chromeos_tbmc_acpi_device_ids,\n\t.ops = {\n\t\t.add = chromeos_tbmc_add,\n\t\t.notify = chromeos_tbmc_notify,\n\t},\n\t.drv.pm = &chromeos_tbmc_pm_ops,\n};\n\nmodule_acpi_driver(chromeos_tbmc_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"ChromeOS ACPI tablet switch driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}