{
  "module_name": "cros_ec_proto.c",
  "hash_id": "9b5925913d8ff881099f7836eb7262417c41fefd2479e8321a4bae722c3265f0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/chrome/cros_ec_proto.c",
  "human_readable_source": "\n\n\n\n\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/module.h>\n#include <linux/platform_data/cros_ec_commands.h>\n#include <linux/platform_data/cros_ec_proto.h>\n#include <linux/slab.h>\n#include <asm/unaligned.h>\n\n#include \"cros_ec_trace.h\"\n\n#define EC_COMMAND_RETRIES\t50\n\nstatic const int cros_ec_error_map[] = {\n\t[EC_RES_INVALID_COMMAND] = -EOPNOTSUPP,\n\t[EC_RES_ERROR] = -EIO,\n\t[EC_RES_INVALID_PARAM] = -EINVAL,\n\t[EC_RES_ACCESS_DENIED] = -EACCES,\n\t[EC_RES_INVALID_RESPONSE] = -EPROTO,\n\t[EC_RES_INVALID_VERSION] = -ENOPROTOOPT,\n\t[EC_RES_INVALID_CHECKSUM] = -EBADMSG,\n\t[EC_RES_IN_PROGRESS] = -EINPROGRESS,\n\t[EC_RES_UNAVAILABLE] = -ENODATA,\n\t[EC_RES_TIMEOUT] = -ETIMEDOUT,\n\t[EC_RES_OVERFLOW] = -EOVERFLOW,\n\t[EC_RES_INVALID_HEADER] = -EBADR,\n\t[EC_RES_REQUEST_TRUNCATED] = -EBADR,\n\t[EC_RES_RESPONSE_TOO_BIG] = -EFBIG,\n\t[EC_RES_BUS_ERROR] = -EFAULT,\n\t[EC_RES_BUSY] = -EBUSY,\n\t[EC_RES_INVALID_HEADER_VERSION] = -EBADMSG,\n\t[EC_RES_INVALID_HEADER_CRC] = -EBADMSG,\n\t[EC_RES_INVALID_DATA_CRC] = -EBADMSG,\n\t[EC_RES_DUP_UNAVAILABLE] = -ENODATA,\n};\n\nstatic int cros_ec_map_error(uint32_t result)\n{\n\tint ret = 0;\n\n\tif (result != EC_RES_SUCCESS) {\n\t\tif (result < ARRAY_SIZE(cros_ec_error_map) && cros_ec_error_map[result])\n\t\t\tret = cros_ec_error_map[result];\n\t\telse\n\t\t\tret = -EPROTO;\n\t}\n\n\treturn ret;\n}\n\nstatic int prepare_tx(struct cros_ec_device *ec_dev,\n\t\t      struct cros_ec_command *msg)\n{\n\tstruct ec_host_request *request;\n\tu8 *out;\n\tint i;\n\tu8 csum = 0;\n\n\tif (msg->outsize + sizeof(*request) > ec_dev->dout_size)\n\t\treturn -EINVAL;\n\n\tout = ec_dev->dout;\n\trequest = (struct ec_host_request *)out;\n\trequest->struct_version = EC_HOST_REQUEST_VERSION;\n\trequest->checksum = 0;\n\trequest->command = msg->command;\n\trequest->command_version = msg->version;\n\trequest->reserved = 0;\n\trequest->data_len = msg->outsize;\n\n\tfor (i = 0; i < sizeof(*request); i++)\n\t\tcsum += out[i];\n\n\t \n\tmemcpy(out + sizeof(*request), msg->data, msg->outsize);\n\tfor (i = 0; i < msg->outsize; i++)\n\t\tcsum += msg->data[i];\n\n\trequest->checksum = -csum;\n\n\treturn sizeof(*request) + msg->outsize;\n}\n\nstatic int prepare_tx_legacy(struct cros_ec_device *ec_dev,\n\t\t\t     struct cros_ec_command *msg)\n{\n\tu8 *out;\n\tu8 csum;\n\tint i;\n\n\tif (msg->outsize > EC_PROTO2_MAX_PARAM_SIZE)\n\t\treturn -EINVAL;\n\n\tout = ec_dev->dout;\n\tout[0] = EC_CMD_VERSION0 + msg->version;\n\tout[1] = msg->command;\n\tout[2] = msg->outsize;\n\tcsum = out[0] + out[1] + out[2];\n\tfor (i = 0; i < msg->outsize; i++)\n\t\tcsum += out[EC_MSG_TX_HEADER_BYTES + i] = msg->data[i];\n\tout[EC_MSG_TX_HEADER_BYTES + msg->outsize] = csum;\n\n\treturn EC_MSG_TX_PROTO_BYTES + msg->outsize;\n}\n\nstatic int cros_ec_xfer_command(struct cros_ec_device *ec_dev, struct cros_ec_command *msg)\n{\n\tint ret;\n\tint (*xfer_fxn)(struct cros_ec_device *ec, struct cros_ec_command *msg);\n\n\tif (ec_dev->proto_version > 2)\n\t\txfer_fxn = ec_dev->pkt_xfer;\n\telse\n\t\txfer_fxn = ec_dev->cmd_xfer;\n\n\tif (!xfer_fxn) {\n\t\t \n\t\tdev_err_once(ec_dev->dev, \"missing EC transfer API, cannot send command\\n\");\n\t\treturn -EIO;\n\t}\n\n\ttrace_cros_ec_request_start(msg);\n\tret = (*xfer_fxn)(ec_dev, msg);\n\ttrace_cros_ec_request_done(msg, ret);\n\n\treturn ret;\n}\n\nstatic int cros_ec_wait_until_complete(struct cros_ec_device *ec_dev, uint32_t *result)\n{\n\tstruct {\n\t\tstruct cros_ec_command msg;\n\t\tstruct ec_response_get_comms_status status;\n\t} __packed buf;\n\tstruct cros_ec_command *msg = &buf.msg;\n\tstruct ec_response_get_comms_status *status = &buf.status;\n\tint ret = 0, i;\n\n\tmsg->version = 0;\n\tmsg->command = EC_CMD_GET_COMMS_STATUS;\n\tmsg->insize = sizeof(*status);\n\tmsg->outsize = 0;\n\n\t \n\tfor (i = 0; i < EC_COMMAND_RETRIES; ++i) {\n\t\tusleep_range(10000, 11000);\n\n\t\tret = cros_ec_xfer_command(ec_dev, msg);\n\t\tif (ret == -EAGAIN)\n\t\t\tcontinue;\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t*result = msg->result;\n\t\tif (msg->result != EC_RES_SUCCESS)\n\t\t\treturn ret;\n\n\t\tif (ret == 0) {\n\t\t\tret = -EPROTO;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!(status->flags & EC_COMMS_STATUS_PROCESSING))\n\t\t\treturn ret;\n\t}\n\n\tif (i >= EC_COMMAND_RETRIES)\n\t\tret = -EAGAIN;\n\n\treturn ret;\n}\n\nstatic int cros_ec_send_command(struct cros_ec_device *ec_dev, struct cros_ec_command *msg)\n{\n\tint ret = cros_ec_xfer_command(ec_dev, msg);\n\n\tif (msg->result == EC_RES_IN_PROGRESS)\n\t\tret = cros_ec_wait_until_complete(ec_dev, &msg->result);\n\n\treturn ret;\n}\n\n \nint cros_ec_prepare_tx(struct cros_ec_device *ec_dev,\n\t\t       struct cros_ec_command *msg)\n{\n\tif (ec_dev->proto_version > 2)\n\t\treturn prepare_tx(ec_dev, msg);\n\n\treturn prepare_tx_legacy(ec_dev, msg);\n}\nEXPORT_SYMBOL(cros_ec_prepare_tx);\n\n \nint cros_ec_check_result(struct cros_ec_device *ec_dev,\n\t\t\t struct cros_ec_command *msg)\n{\n\tswitch (msg->result) {\n\tcase EC_RES_SUCCESS:\n\t\treturn 0;\n\tcase EC_RES_IN_PROGRESS:\n\t\tdev_dbg(ec_dev->dev, \"command 0x%02x in progress\\n\",\n\t\t\tmsg->command);\n\t\treturn -EAGAIN;\n\tdefault:\n\t\tdev_dbg(ec_dev->dev, \"command 0x%02x returned %d\\n\",\n\t\t\tmsg->command, msg->result);\n\t\treturn 0;\n\t}\n}\nEXPORT_SYMBOL(cros_ec_check_result);\n\n \nstatic int cros_ec_get_host_event_wake_mask(struct cros_ec_device *ec_dev, uint32_t *mask)\n{\n\tstruct cros_ec_command *msg;\n\tstruct ec_response_host_event_mask *r;\n\tint ret, mapped;\n\n\tmsg = kzalloc(sizeof(*msg) + sizeof(*r), GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\tmsg->command = EC_CMD_HOST_EVENT_GET_WAKE_MASK;\n\tmsg->insize = sizeof(*r);\n\n\tret = cros_ec_send_command(ec_dev, msg);\n\tif (ret < 0)\n\t\tgoto exit;\n\n\tmapped = cros_ec_map_error(msg->result);\n\tif (mapped) {\n\t\tret = mapped;\n\t\tgoto exit;\n\t}\n\n\tif (ret == 0) {\n\t\tret = -EPROTO;\n\t\tgoto exit;\n\t}\n\n\tr = (struct ec_response_host_event_mask *)msg->data;\n\t*mask = r->mask;\n\tret = 0;\nexit:\n\tkfree(msg);\n\treturn ret;\n}\n\nstatic int cros_ec_get_proto_info(struct cros_ec_device *ec_dev, int devidx)\n{\n\tstruct cros_ec_command *msg;\n\tstruct ec_response_get_protocol_info *info;\n\tint ret, mapped;\n\n\tec_dev->proto_version = 3;\n\tif (devidx > 0)\n\t\tec_dev->max_passthru = 0;\n\n\tmsg = kzalloc(sizeof(*msg) + sizeof(*info), GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\tmsg->command = EC_CMD_PASSTHRU_OFFSET(devidx) | EC_CMD_GET_PROTOCOL_INFO;\n\tmsg->insize = sizeof(*info);\n\n\tret = cros_ec_send_command(ec_dev, msg);\n\t \n\tif (ret == -ETIMEDOUT)\n\t\tret = cros_ec_send_command(ec_dev, msg);\n\n\tif (ret < 0) {\n\t\tdev_dbg(ec_dev->dev,\n\t\t\t\"failed to check for EC[%d] protocol version: %d\\n\",\n\t\t\tdevidx, ret);\n\t\tgoto exit;\n\t}\n\n\tmapped = cros_ec_map_error(msg->result);\n\tif (mapped) {\n\t\tret = mapped;\n\t\tgoto exit;\n\t}\n\n\tif (ret == 0) {\n\t\tret = -EPROTO;\n\t\tgoto exit;\n\t}\n\n\tinfo = (struct ec_response_get_protocol_info *)msg->data;\n\n\tswitch (devidx) {\n\tcase CROS_EC_DEV_EC_INDEX:\n\t\tec_dev->max_request = info->max_request_packet_size -\n\t\t\t\t\t\tsizeof(struct ec_host_request);\n\t\tec_dev->max_response = info->max_response_packet_size -\n\t\t\t\t\t\tsizeof(struct ec_host_response);\n\t\tec_dev->proto_version = min(EC_HOST_REQUEST_VERSION,\n\t\t\t\t\t    fls(info->protocol_versions) - 1);\n\t\tec_dev->din_size = info->max_response_packet_size + EC_MAX_RESPONSE_OVERHEAD;\n\t\tec_dev->dout_size = info->max_request_packet_size + EC_MAX_REQUEST_OVERHEAD;\n\n\t\tdev_dbg(ec_dev->dev, \"using proto v%u\\n\", ec_dev->proto_version);\n\t\tbreak;\n\tcase CROS_EC_DEV_PD_INDEX:\n\t\tec_dev->max_passthru = info->max_request_packet_size -\n\t\t\t\t\t\tsizeof(struct ec_host_request);\n\n\t\tdev_dbg(ec_dev->dev, \"found PD chip\\n\");\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(ec_dev->dev, \"unknown passthru index: %d\\n\", devidx);\n\t\tbreak;\n\t}\n\n\tret = 0;\nexit:\n\tkfree(msg);\n\treturn ret;\n}\n\nstatic int cros_ec_get_proto_info_legacy(struct cros_ec_device *ec_dev)\n{\n\tstruct cros_ec_command *msg;\n\tstruct ec_params_hello *params;\n\tstruct ec_response_hello *response;\n\tint ret, mapped;\n\n\tec_dev->proto_version = 2;\n\n\tmsg = kzalloc(sizeof(*msg) + max(sizeof(*params), sizeof(*response)), GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\tmsg->command = EC_CMD_HELLO;\n\tmsg->insize = sizeof(*response);\n\tmsg->outsize = sizeof(*params);\n\n\tparams = (struct ec_params_hello *)msg->data;\n\tparams->in_data = 0xa0b0c0d0;\n\n\tret = cros_ec_send_command(ec_dev, msg);\n\tif (ret < 0) {\n\t\tdev_dbg(ec_dev->dev, \"EC failed to respond to v2 hello: %d\\n\", ret);\n\t\tgoto exit;\n\t}\n\n\tmapped = cros_ec_map_error(msg->result);\n\tif (mapped) {\n\t\tret = mapped;\n\t\tdev_err(ec_dev->dev, \"EC responded to v2 hello with error: %d\\n\", msg->result);\n\t\tgoto exit;\n\t}\n\n\tif (ret == 0) {\n\t\tret = -EPROTO;\n\t\tgoto exit;\n\t}\n\n\tresponse = (struct ec_response_hello *)msg->data;\n\tif (response->out_data != 0xa1b2c3d4) {\n\t\tdev_err(ec_dev->dev,\n\t\t\t\"EC responded to v2 hello with bad result: %u\\n\",\n\t\t\tresponse->out_data);\n\t\tret = -EBADMSG;\n\t\tgoto exit;\n\t}\n\n\tec_dev->max_request = EC_PROTO2_MAX_PARAM_SIZE;\n\tec_dev->max_response = EC_PROTO2_MAX_PARAM_SIZE;\n\tec_dev->max_passthru = 0;\n\tec_dev->pkt_xfer = NULL;\n\tec_dev->din_size = EC_PROTO2_MSG_BYTES;\n\tec_dev->dout_size = EC_PROTO2_MSG_BYTES;\n\n\tdev_dbg(ec_dev->dev, \"falling back to proto v2\\n\");\n\tret = 0;\nexit:\n\tkfree(msg);\n\treturn ret;\n}\n\n \nstatic int cros_ec_get_host_command_version_mask(struct cros_ec_device *ec_dev, u16 cmd, u32 *mask)\n{\n\tstruct ec_params_get_cmd_versions *pver;\n\tstruct ec_response_get_cmd_versions *rver;\n\tstruct cros_ec_command *msg;\n\tint ret, mapped;\n\n\tmsg = kmalloc(sizeof(*msg) + max(sizeof(*rver), sizeof(*pver)),\n\t\t      GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\tmsg->version = 0;\n\tmsg->command = EC_CMD_GET_CMD_VERSIONS;\n\tmsg->insize = sizeof(*rver);\n\tmsg->outsize = sizeof(*pver);\n\n\tpver = (struct ec_params_get_cmd_versions *)msg->data;\n\tpver->cmd = cmd;\n\n\tret = cros_ec_send_command(ec_dev, msg);\n\tif (ret < 0)\n\t\tgoto exit;\n\n\tmapped = cros_ec_map_error(msg->result);\n\tif (mapped) {\n\t\tret = mapped;\n\t\tgoto exit;\n\t}\n\n\tif (ret == 0) {\n\t\tret = -EPROTO;\n\t\tgoto exit;\n\t}\n\n\trver = (struct ec_response_get_cmd_versions *)msg->data;\n\t*mask = rver->version_mask;\n\tret = 0;\nexit:\n\tkfree(msg);\n\treturn ret;\n}\n\n \nint cros_ec_query_all(struct cros_ec_device *ec_dev)\n{\n\tstruct device *dev = ec_dev->dev;\n\tu32 ver_mask;\n\tint ret;\n\n\t \n\tif (!cros_ec_get_proto_info(ec_dev, CROS_EC_DEV_EC_INDEX)) {\n\t\t \n\t\tcros_ec_get_proto_info(ec_dev, CROS_EC_DEV_PD_INDEX);\n\t} else {\n\t\t \n\t\tret = cros_ec_get_proto_info_legacy(ec_dev);\n\t\tif (ret) {\n\t\t\t \n\t\t\tec_dev->proto_version = EC_PROTO_VERSION_UNKNOWN;\n\t\t\tdev_dbg(ec_dev->dev, \"EC query failed: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tdevm_kfree(dev, ec_dev->din);\n\tdevm_kfree(dev, ec_dev->dout);\n\n\tec_dev->din = devm_kzalloc(dev, ec_dev->din_size, GFP_KERNEL);\n\tif (!ec_dev->din) {\n\t\tret = -ENOMEM;\n\t\tgoto exit;\n\t}\n\n\tec_dev->dout = devm_kzalloc(dev, ec_dev->dout_size, GFP_KERNEL);\n\tif (!ec_dev->dout) {\n\t\tdevm_kfree(dev, ec_dev->din);\n\t\tret = -ENOMEM;\n\t\tgoto exit;\n\t}\n\n\t \n\tret = cros_ec_get_host_command_version_mask(ec_dev, EC_CMD_GET_NEXT_EVENT, &ver_mask);\n\tif (ret < 0 || ver_mask == 0) {\n\t\tec_dev->mkbp_event_supported = 0;\n\t} else {\n\t\tec_dev->mkbp_event_supported = fls(ver_mask);\n\n\t\tdev_dbg(ec_dev->dev, \"MKBP support version %u\\n\", ec_dev->mkbp_event_supported - 1);\n\t}\n\n\t \n\tret = cros_ec_get_host_command_version_mask(ec_dev, EC_CMD_HOST_SLEEP_EVENT, &ver_mask);\n\tec_dev->host_sleep_v1 = (ret == 0 && (ver_mask & EC_VER_MASK(1)));\n\n\t \n\tret = cros_ec_get_host_event_wake_mask(ec_dev, &ec_dev->host_event_wake_mask);\n\tif (ret < 0) {\n\t\t \n\t\tec_dev->host_event_wake_mask = U32_MAX &\n\t\t\t~(EC_HOST_EVENT_MASK(EC_HOST_EVENT_LID_CLOSED) |\n\t\t\t  EC_HOST_EVENT_MASK(EC_HOST_EVENT_AC_DISCONNECTED) |\n\t\t\t  EC_HOST_EVENT_MASK(EC_HOST_EVENT_BATTERY_LOW) |\n\t\t\t  EC_HOST_EVENT_MASK(EC_HOST_EVENT_BATTERY_CRITICAL) |\n\t\t\t  EC_HOST_EVENT_MASK(EC_HOST_EVENT_BATTERY) |\n\t\t\t  EC_HOST_EVENT_MASK(EC_HOST_EVENT_PD_MCU) |\n\t\t\t  EC_HOST_EVENT_MASK(EC_HOST_EVENT_BATTERY_STATUS));\n\t\t \n\t\tif (ret != -EOPNOTSUPP)\n\t\t\tdev_err(ec_dev->dev,\n\t\t\t\t\"failed to retrieve wake mask: %d\\n\", ret);\n\t}\n\n\tret = 0;\n\nexit:\n\treturn ret;\n}\nEXPORT_SYMBOL(cros_ec_query_all);\n\n \nint cros_ec_cmd_xfer(struct cros_ec_device *ec_dev, struct cros_ec_command *msg)\n{\n\tint ret;\n\n\tmutex_lock(&ec_dev->lock);\n\tif (ec_dev->proto_version == EC_PROTO_VERSION_UNKNOWN) {\n\t\tret = cros_ec_query_all(ec_dev);\n\t\tif (ret) {\n\t\t\tdev_err(ec_dev->dev,\n\t\t\t\t\"EC version unknown and query failed; aborting command\\n\");\n\t\t\tmutex_unlock(&ec_dev->lock);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (msg->insize > ec_dev->max_response) {\n\t\tdev_dbg(ec_dev->dev, \"clamping message receive buffer\\n\");\n\t\tmsg->insize = ec_dev->max_response;\n\t}\n\n\tif (msg->command < EC_CMD_PASSTHRU_OFFSET(CROS_EC_DEV_PD_INDEX)) {\n\t\tif (msg->outsize > ec_dev->max_request) {\n\t\t\tdev_err(ec_dev->dev,\n\t\t\t\t\"request of size %u is too big (max: %u)\\n\",\n\t\t\t\tmsg->outsize,\n\t\t\t\tec_dev->max_request);\n\t\t\tmutex_unlock(&ec_dev->lock);\n\t\t\treturn -EMSGSIZE;\n\t\t}\n\t} else {\n\t\tif (msg->outsize > ec_dev->max_passthru) {\n\t\t\tdev_err(ec_dev->dev,\n\t\t\t\t\"passthru rq of size %u is too big (max: %u)\\n\",\n\t\t\t\tmsg->outsize,\n\t\t\t\tec_dev->max_passthru);\n\t\t\tmutex_unlock(&ec_dev->lock);\n\t\t\treturn -EMSGSIZE;\n\t\t}\n\t}\n\n\tret = cros_ec_send_command(ec_dev, msg);\n\tmutex_unlock(&ec_dev->lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(cros_ec_cmd_xfer);\n\n \nint cros_ec_cmd_xfer_status(struct cros_ec_device *ec_dev,\n\t\t\t    struct cros_ec_command *msg)\n{\n\tint ret, mapped;\n\n\tret = cros_ec_cmd_xfer(ec_dev, msg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmapped = cros_ec_map_error(msg->result);\n\tif (mapped) {\n\t\tdev_dbg(ec_dev->dev, \"Command result (err: %d [%d])\\n\",\n\t\t\tmsg->result, mapped);\n\t\tret = mapped;\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL(cros_ec_cmd_xfer_status);\n\nstatic int get_next_event_xfer(struct cros_ec_device *ec_dev,\n\t\t\t       struct cros_ec_command *msg,\n\t\t\t       struct ec_response_get_next_event_v1 *event,\n\t\t\t       int version, uint32_t size)\n{\n\tint ret;\n\n\tmsg->version = version;\n\tmsg->command = EC_CMD_GET_NEXT_EVENT;\n\tmsg->insize = size;\n\tmsg->outsize = 0;\n\n\tret = cros_ec_cmd_xfer_status(ec_dev, msg);\n\tif (ret > 0) {\n\t\tec_dev->event_size = ret - 1;\n\t\tec_dev->event_data = *event;\n\t}\n\n\treturn ret;\n}\n\nstatic int get_next_event(struct cros_ec_device *ec_dev)\n{\n\tstruct {\n\t\tstruct cros_ec_command msg;\n\t\tstruct ec_response_get_next_event_v1 event;\n\t} __packed buf;\n\tstruct cros_ec_command *msg = &buf.msg;\n\tstruct ec_response_get_next_event_v1 *event = &buf.event;\n\tconst int cmd_version = ec_dev->mkbp_event_supported - 1;\n\n\tmemset(msg, 0, sizeof(*msg));\n\tif (ec_dev->suspended) {\n\t\tdev_dbg(ec_dev->dev, \"Device suspended.\\n\");\n\t\treturn -EHOSTDOWN;\n\t}\n\n\tif (cmd_version == 0)\n\t\treturn get_next_event_xfer(ec_dev, msg, event, 0,\n\t\t\t\t  sizeof(struct ec_response_get_next_event));\n\n\treturn get_next_event_xfer(ec_dev, msg, event, cmd_version,\n\t\t\t\tsizeof(struct ec_response_get_next_event_v1));\n}\n\nstatic int get_keyboard_state_event(struct cros_ec_device *ec_dev)\n{\n\tu8 buffer[sizeof(struct cros_ec_command) +\n\t\t  sizeof(ec_dev->event_data.data)];\n\tstruct cros_ec_command *msg = (struct cros_ec_command *)&buffer;\n\n\tmsg->version = 0;\n\tmsg->command = EC_CMD_MKBP_STATE;\n\tmsg->insize = sizeof(ec_dev->event_data.data);\n\tmsg->outsize = 0;\n\n\tec_dev->event_size = cros_ec_cmd_xfer_status(ec_dev, msg);\n\tec_dev->event_data.event_type = EC_MKBP_EVENT_KEY_MATRIX;\n\tmemcpy(&ec_dev->event_data.data, msg->data,\n\t       sizeof(ec_dev->event_data.data));\n\n\treturn ec_dev->event_size;\n}\n\n \nint cros_ec_get_next_event(struct cros_ec_device *ec_dev,\n\t\t\t   bool *wake_event,\n\t\t\t   bool *has_more_events)\n{\n\tu8 event_type;\n\tu32 host_event;\n\tint ret;\n\tu32 ver_mask;\n\n\t \n\tif (wake_event)\n\t\t*wake_event = true;\n\n\t \n\tif (has_more_events)\n\t\t*has_more_events = false;\n\n\tif (!ec_dev->mkbp_event_supported)\n\t\treturn get_keyboard_state_event(ec_dev);\n\n\tret = get_next_event(ec_dev);\n\t \n\tif (ret == -ENOPROTOOPT) {\n\t\tdev_dbg(ec_dev->dev,\n\t\t\t\"GET_NEXT_EVENT returned invalid version error.\\n\");\n\t\tret = cros_ec_get_host_command_version_mask(ec_dev,\n\t\t\t\t\t\t\tEC_CMD_GET_NEXT_EVENT,\n\t\t\t\t\t\t\t&ver_mask);\n\t\tif (ret < 0 || ver_mask == 0)\n\t\t\t \n\t\t\treturn -ENOPROTOOPT;\n\n\t\tec_dev->mkbp_event_supported = fls(ver_mask);\n\t\tdev_dbg(ec_dev->dev, \"MKBP support version changed to %u\\n\",\n\t\t\tec_dev->mkbp_event_supported - 1);\n\n\t\t \n\t\tret = get_next_event(ec_dev);\n\t}\n\n\tif (ret <= 0)\n\t\treturn ret;\n\n\tif (has_more_events)\n\t\t*has_more_events = ec_dev->event_data.event_type &\n\t\t\tEC_MKBP_HAS_MORE_EVENTS;\n\tec_dev->event_data.event_type &= EC_MKBP_EVENT_TYPE_MASK;\n\n\tif (wake_event) {\n\t\tevent_type = ec_dev->event_data.event_type;\n\t\thost_event = cros_ec_get_host_event(ec_dev);\n\n\t\t \n\t\tif (event_type == EC_MKBP_EVENT_SENSOR_FIFO) {\n\t\t\t*wake_event = false;\n\t\t} else if (host_event) {\n\t\t\t \n\t\t\tif (host_event & EC_HOST_EVENT_MASK(EC_HOST_EVENT_RTC))\n\t\t\t\t*wake_event = false;\n\t\t\t \n\t\t\tif (!(host_event & ec_dev->host_event_wake_mask))\n\t\t\t\t*wake_event = false;\n\t\t}\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL(cros_ec_get_next_event);\n\n \nu32 cros_ec_get_host_event(struct cros_ec_device *ec_dev)\n{\n\tu32 host_event;\n\n\tif (!ec_dev->mkbp_event_supported)\n\t\treturn 0;\n\n\tif (ec_dev->event_data.event_type != EC_MKBP_EVENT_HOST_EVENT)\n\t\treturn 0;\n\n\tif (ec_dev->event_size != sizeof(host_event)) {\n\t\tdev_warn(ec_dev->dev, \"Invalid host event size\\n\");\n\t\treturn 0;\n\t}\n\n\thost_event = get_unaligned_le32(&ec_dev->event_data.data.host_event);\n\n\treturn host_event;\n}\nEXPORT_SYMBOL(cros_ec_get_host_event);\n\n \nbool cros_ec_check_features(struct cros_ec_dev *ec, int feature)\n{\n\tstruct ec_response_get_features *features = &ec->features;\n\tint ret;\n\n\tif (features->flags[0] == -1U && features->flags[1] == -1U) {\n\t\t \n\t\tret = cros_ec_cmd(ec->ec_dev, 0, EC_CMD_GET_FEATURES + ec->cmd_offset,\n\t\t\t\t  NULL, 0, features, sizeof(*features));\n\t\tif (ret < 0) {\n\t\t\tdev_warn(ec->dev, \"cannot get EC features: %d\\n\", ret);\n\t\t\tmemset(features, 0, sizeof(*features));\n\t\t}\n\n\t\tdev_dbg(ec->dev, \"EC features %08x %08x\\n\",\n\t\t\tfeatures->flags[0], features->flags[1]);\n\t}\n\n\treturn !!(features->flags[feature / 32] & EC_FEATURE_MASK_0(feature));\n}\nEXPORT_SYMBOL_GPL(cros_ec_check_features);\n\n \nint cros_ec_get_sensor_count(struct cros_ec_dev *ec)\n{\n\t \n\tint ret, sensor_count;\n\tstruct ec_params_motion_sense *params;\n\tstruct ec_response_motion_sense *resp;\n\tstruct cros_ec_command *msg;\n\tstruct cros_ec_device *ec_dev = ec->ec_dev;\n\tu8 status;\n\n\tmsg = kzalloc(sizeof(*msg) + max(sizeof(*params), sizeof(*resp)),\n\t\t      GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\tmsg->version = 1;\n\tmsg->command = EC_CMD_MOTION_SENSE_CMD + ec->cmd_offset;\n\tmsg->outsize = sizeof(*params);\n\tmsg->insize = sizeof(*resp);\n\n\tparams = (struct ec_params_motion_sense *)msg->data;\n\tparams->cmd = MOTIONSENSE_CMD_DUMP;\n\n\tret = cros_ec_cmd_xfer_status(ec->ec_dev, msg);\n\tif (ret < 0) {\n\t\tsensor_count = ret;\n\t} else {\n\t\tresp = (struct ec_response_motion_sense *)msg->data;\n\t\tsensor_count = resp->dump.sensor_count;\n\t}\n\tkfree(msg);\n\n\t \n\tif (sensor_count < 0 && ec->cmd_offset == 0 && ec_dev->cmd_readmem) {\n\t\tret = ec_dev->cmd_readmem(ec_dev, EC_MEMMAP_ACC_STATUS,\n\t\t\t\t1, &status);\n\t\tif (ret >= 0 &&\n\t\t    (status & EC_MEMMAP_ACC_STATUS_PRESENCE_BIT)) {\n\t\t\t \n\t\t\tsensor_count = 2;\n\t\t} else {\n\t\t\t \n\t\t\tsensor_count = 0;\n\t\t}\n\t}\n\treturn sensor_count;\n}\nEXPORT_SYMBOL_GPL(cros_ec_get_sensor_count);\n\n \nint cros_ec_cmd(struct cros_ec_device *ec_dev,\n\t\tunsigned int version,\n\t\tint command,\n\t\tvoid *outdata,\n\t\tsize_t outsize,\n\t\tvoid *indata,\n\t\tsize_t insize)\n{\n\tstruct cros_ec_command *msg;\n\tint ret;\n\n\tmsg = kzalloc(sizeof(*msg) + max(insize, outsize), GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\tmsg->version = version;\n\tmsg->command = command;\n\tmsg->outsize = outsize;\n\tmsg->insize = insize;\n\n\tif (outsize)\n\t\tmemcpy(msg->data, outdata, outsize);\n\n\tret = cros_ec_cmd_xfer_status(ec_dev, msg);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tif (insize)\n\t\tmemcpy(indata, msg->data, insize);\nerror:\n\tkfree(msg);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(cros_ec_cmd);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}