{
  "module_name": "cros_ec_ishtp.c",
  "hash_id": "69d85eb40aa8093280c2129ea65a348ff21243d1649e65898242fc079ebd66a7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/chrome/cros_ec_ishtp.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n#include <linux/delay.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/platform_data/cros_ec_commands.h>\n#include <linux/platform_data/cros_ec_proto.h>\n#include <linux/intel-ish-client-if.h>\n\n#include \"cros_ec.h\"\n\n \n#define CROS_ISH_CL_TX_RING_SIZE\t\t8\n#define CROS_ISH_CL_RX_RING_SIZE\t\t8\n\n \nenum cros_ec_ish_channel {\n\tCROS_EC_COMMAND = 1,\t\t\t \n\tCROS_MKBP_EVENT = 2,\t\t\t \n};\n\n \n#define ISHTP_SEND_TIMEOUT\t\t\t(3 * HZ)\n\n \nstatic const struct ishtp_device_id cros_ec_ishtp_id_table[] = {\n\t{ .guid = GUID_INIT(0x7b7154d0, 0x56f4, 0x4bdc,\n\t\t  0xb0, 0xd8, 0x9e, 0x7c, 0xda,\t0xe0, 0xd6, 0xa0), },\n\t{ }\n};\nMODULE_DEVICE_TABLE(ishtp, cros_ec_ishtp_id_table);\n\nstruct header {\n\tu8 channel;\n\tu8 status;\n\tu8 token;\n\tu8 reserved;\n} __packed;\n\nstruct cros_ish_out_msg {\n\tstruct header hdr;\n\tstruct ec_host_request ec_request;\n} __packed;\n\nstruct cros_ish_in_msg {\n\tstruct header hdr;\n\tstruct ec_host_response ec_response;\n} __packed;\n\n#define IN_MSG_EC_RESPONSE_PREAMBLE\t\t\t\t\t\\\n\toffsetof(struct cros_ish_in_msg, ec_response)\n\n#define OUT_MSG_EC_REQUEST_PREAMBLE\t\t\t\t\t\\\n\toffsetof(struct cros_ish_out_msg, ec_request)\n\n#define cl_data_to_dev(client_data) ishtp_device((client_data)->cl_device)\n\n \nstatic DECLARE_RWSEM(init_lock);\n\n \nstruct response_info {\n\tvoid *data;\n\tsize_t max_size;\n\tsize_t size;\n\tint error;\n\tu8 token;\n\tbool received;\n\twait_queue_head_t wait_queue;\n};\n\n \nstruct ishtp_cl_data {\n\tstruct ishtp_cl *cros_ish_cl;\n\tstruct ishtp_cl_device *cl_device;\n\n\t \n\tstruct response_info response;\n\n\tstruct work_struct work_ishtp_reset;\n\tstruct work_struct work_ec_evt;\n\tstruct cros_ec_device *ec_dev;\n};\n\n \nstatic void ish_evt_handler(struct work_struct *work)\n{\n\tstruct ishtp_cl_data *client_data =\n\t\tcontainer_of(work, struct ishtp_cl_data, work_ec_evt);\n\n\tcros_ec_irq_thread(0, client_data->ec_dev);\n}\n\n \nstatic int ish_send(struct ishtp_cl_data *client_data,\n\t\t    u8 *out_msg, size_t out_size,\n\t\t    u8 *in_msg, size_t in_size)\n{\n\tstatic u8 next_token;\n\tint rv;\n\tstruct header *out_hdr = (struct header *)out_msg;\n\tstruct ishtp_cl *cros_ish_cl = client_data->cros_ish_cl;\n\n\tdev_dbg(cl_data_to_dev(client_data),\n\t\t\"%s: channel=%02u status=%02u\\n\",\n\t\t__func__, out_hdr->channel, out_hdr->status);\n\n\t \n\tclient_data->response.data = in_msg;\n\tclient_data->response.max_size = in_size;\n\tclient_data->response.error = 0;\n\tclient_data->response.token = next_token++;\n\tclient_data->response.received = false;\n\n\tout_hdr->token = client_data->response.token;\n\n\trv = ishtp_cl_send(cros_ish_cl, out_msg, out_size);\n\tif (rv) {\n\t\tdev_err(cl_data_to_dev(client_data),\n\t\t\t\"ishtp_cl_send error %d\\n\", rv);\n\t\treturn rv;\n\t}\n\n\twait_event_interruptible_timeout(client_data->response.wait_queue,\n\t\t\t\t\t client_data->response.received,\n\t\t\t\t\t ISHTP_SEND_TIMEOUT);\n\tif (!client_data->response.received) {\n\t\tdev_err(cl_data_to_dev(client_data),\n\t\t\t\"Timed out for response to host message\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tif (client_data->response.error < 0)\n\t\treturn client_data->response.error;\n\n\treturn client_data->response.size;\n}\n\n \nstatic void process_recv(struct ishtp_cl *cros_ish_cl,\n\t\t\t struct ishtp_cl_rb *rb_in_proc, ktime_t timestamp)\n{\n\tsize_t data_len = rb_in_proc->buf_idx;\n\tstruct ishtp_cl_data *client_data =\n\t\tishtp_get_client_data(cros_ish_cl);\n\tstruct device *dev = cl_data_to_dev(client_data);\n\tstruct cros_ish_in_msg *in_msg =\n\t\t(struct cros_ish_in_msg *)rb_in_proc->buffer.data;\n\n\t \n\tif (!down_read_trylock(&init_lock)) {\n\t\t \n\t\tishtp_cl_io_rb_recycle(rb_in_proc);\n\t\tdev_warn(dev,\n\t\t\t \"Host is not ready to receive incoming messages\\n\");\n\t\treturn;\n\t}\n\n\t \n\tif (!rb_in_proc->buffer.data) {\n\t\tdev_warn(dev, \"rb_in_proc->buffer.data returned null\");\n\t\tclient_data->response.error = -EBADMSG;\n\t\tgoto end_error;\n\t}\n\n\tif (data_len < sizeof(struct header)) {\n\t\tdev_err(dev, \"data size %zu is less than header %zu\\n\",\n\t\t\tdata_len, sizeof(struct header));\n\t\tclient_data->response.error = -EMSGSIZE;\n\t\tgoto end_error;\n\t}\n\n\tdev_dbg(dev, \"channel=%02u status=%02u\\n\",\n\t\tin_msg->hdr.channel, in_msg->hdr.status);\n\n\tswitch (in_msg->hdr.channel) {\n\tcase CROS_EC_COMMAND:\n\t\tif (client_data->response.received) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"Previous firmware message not yet processed\\n\");\n\t\t\tgoto end_error;\n\t\t}\n\n\t\tif (client_data->response.token != in_msg->hdr.token) {\n\t\t\tdev_err_ratelimited(dev,\n\t\t\t\t\t    \"Dropping old response token %d\\n\",\n\t\t\t\t\t    in_msg->hdr.token);\n\t\t\tgoto end_error;\n\t\t}\n\n\t\t \n\t\tif (!client_data->response.data) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"Receiving buffer is null. Should be allocated by calling function\\n\");\n\t\t\tclient_data->response.error = -EINVAL;\n\t\t\tgoto error_wake_up;\n\t\t}\n\n\t\tif (data_len > client_data->response.max_size) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"Received buffer size %zu is larger than allocated buffer %zu\\n\",\n\t\t\t\tdata_len, client_data->response.max_size);\n\t\t\tclient_data->response.error = -EMSGSIZE;\n\t\t\tgoto error_wake_up;\n\t\t}\n\n\t\tif (in_msg->hdr.status) {\n\t\t\tdev_err(dev, \"firmware returned status %d\\n\",\n\t\t\t\tin_msg->hdr.status);\n\t\t\tclient_data->response.error = -EIO;\n\t\t\tgoto error_wake_up;\n\t\t}\n\n\t\t \n\t\tclient_data->response.size = data_len;\n\n\t\t \n\t\tmemcpy(client_data->response.data,\n\t\t       rb_in_proc->buffer.data, data_len);\n\nerror_wake_up:\n\t\t \n\t\tishtp_cl_io_rb_recycle(rb_in_proc);\n\t\trb_in_proc = NULL;\n\n\t\t \n\t\tclient_data->response.received = true;\n\n\t\t \n\t\twake_up_interruptible(&client_data->response.wait_queue);\n\n\t\tbreak;\n\n\tcase CROS_MKBP_EVENT:\n\t\t \n\t\tishtp_cl_io_rb_recycle(rb_in_proc);\n\t\trb_in_proc = NULL;\n\t\t \n\t\tclient_data->ec_dev->last_event_time = timestamp;\n\t\tschedule_work(&client_data->work_ec_evt);\n\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(dev, \"Invalid channel=%02d\\n\", in_msg->hdr.channel);\n\t}\n\nend_error:\n\t \n\tif (rb_in_proc)\n\t\tishtp_cl_io_rb_recycle(rb_in_proc);\n\n\tup_read(&init_lock);\n}\n\n \nstatic void ish_event_cb(struct ishtp_cl_device *cl_device)\n{\n\tstruct ishtp_cl_rb *rb_in_proc;\n\tstruct ishtp_cl\t*cros_ish_cl = ishtp_get_drvdata(cl_device);\n\tktime_t timestamp;\n\n\t \n\ttimestamp = cros_ec_get_time_ns();\n\n\twhile ((rb_in_proc = ishtp_cl_rx_get_rb(cros_ish_cl)) != NULL) {\n\t\t \n\t\tprocess_recv(cros_ish_cl, rb_in_proc, timestamp);\n\t}\n}\n\n \nstatic int cros_ish_init(struct ishtp_cl *cros_ish_cl)\n{\n\tint rv;\n\tstruct ishtp_device *dev;\n\tstruct ishtp_fw_client *fw_client;\n\tstruct ishtp_cl_data *client_data = ishtp_get_client_data(cros_ish_cl);\n\n\trv = ishtp_cl_link(cros_ish_cl);\n\tif (rv) {\n\t\tdev_err(cl_data_to_dev(client_data),\n\t\t\t\"ishtp_cl_link failed\\n\");\n\t\treturn rv;\n\t}\n\n\tdev = ishtp_get_ishtp_device(cros_ish_cl);\n\n\t \n\tishtp_set_tx_ring_size(cros_ish_cl, CROS_ISH_CL_TX_RING_SIZE);\n\tishtp_set_rx_ring_size(cros_ish_cl, CROS_ISH_CL_RX_RING_SIZE);\n\n\tfw_client = ishtp_fw_cl_get_client(dev, &cros_ec_ishtp_id_table[0].guid);\n\tif (!fw_client) {\n\t\tdev_err(cl_data_to_dev(client_data),\n\t\t\t\"ish client uuid not found\\n\");\n\t\trv = -ENOENT;\n\t\tgoto err_cl_unlink;\n\t}\n\n\tishtp_cl_set_fw_client_id(cros_ish_cl,\n\t\t\t\t  ishtp_get_fw_client_id(fw_client));\n\tishtp_set_connection_state(cros_ish_cl, ISHTP_CL_CONNECTING);\n\n\trv = ishtp_cl_connect(cros_ish_cl);\n\tif (rv) {\n\t\tdev_err(cl_data_to_dev(client_data),\n\t\t\t\"client connect fail\\n\");\n\t\tgoto err_cl_unlink;\n\t}\n\n\tishtp_register_event_cb(client_data->cl_device, ish_event_cb);\n\treturn 0;\n\nerr_cl_unlink:\n\tishtp_cl_unlink(cros_ish_cl);\n\treturn rv;\n}\n\n \nstatic void cros_ish_deinit(struct ishtp_cl *cros_ish_cl)\n{\n\tishtp_set_connection_state(cros_ish_cl, ISHTP_CL_DISCONNECTING);\n\tishtp_cl_disconnect(cros_ish_cl);\n\tishtp_cl_unlink(cros_ish_cl);\n\tishtp_cl_flush_queues(cros_ish_cl);\n\n\t \n\tishtp_cl_free(cros_ish_cl);\n}\n\n \nstatic int prepare_cros_ec_rx(struct cros_ec_device *ec_dev,\n\t\t\t      const struct cros_ish_in_msg *in_msg,\n\t\t\t      struct cros_ec_command *msg)\n{\n\tu8 sum = 0;\n\tint i, rv, offset;\n\n\t \n\tmsg->result = in_msg->ec_response.result;\n\trv = cros_ec_check_result(ec_dev, msg);\n\tif (rv < 0)\n\t\treturn rv;\n\n\tif (in_msg->ec_response.data_len > msg->insize) {\n\t\tdev_err(ec_dev->dev, \"Packet too long (%d bytes, expected %d)\",\n\t\t\tin_msg->ec_response.data_len, msg->insize);\n\t\treturn -ENOSPC;\n\t}\n\n\t \n\tfor (i = 0; i < sizeof(struct ec_host_response); i++)\n\t\tsum += ((u8 *)in_msg)[IN_MSG_EC_RESPONSE_PREAMBLE + i];\n\n\toffset = sizeof(struct cros_ish_in_msg);\n\tfor (i = 0; i < in_msg->ec_response.data_len; i++)\n\t\tsum += msg->data[i] = ((u8 *)in_msg)[offset + i];\n\n\tif (sum) {\n\t\tdev_dbg(ec_dev->dev, \"Bad received packet checksum %d\\n\", sum);\n\t\treturn -EBADMSG;\n\t}\n\n\treturn 0;\n}\n\nstatic int cros_ec_pkt_xfer_ish(struct cros_ec_device *ec_dev,\n\t\t\t\tstruct cros_ec_command *msg)\n{\n\tint rv;\n\tstruct ishtp_cl *cros_ish_cl = ec_dev->priv;\n\tstruct ishtp_cl_data *client_data = ishtp_get_client_data(cros_ish_cl);\n\tstruct device *dev = cl_data_to_dev(client_data);\n\tstruct cros_ish_in_msg *in_msg = (struct cros_ish_in_msg *)ec_dev->din;\n\tstruct cros_ish_out_msg *out_msg =\n\t\t(struct cros_ish_out_msg *)ec_dev->dout;\n\tsize_t in_size = sizeof(struct cros_ish_in_msg) + msg->insize;\n\tsize_t out_size = sizeof(struct cros_ish_out_msg) + msg->outsize;\n\n\t \n\tif (in_size > ec_dev->din_size) {\n\t\tdev_err(dev,\n\t\t\t\"Incoming payload size %zu is too large for ec_dev->din_size %d\\n\",\n\t\t\tin_size, ec_dev->din_size);\n\t\treturn -EMSGSIZE;\n\t}\n\n\tif (out_size > ec_dev->dout_size) {\n\t\tdev_err(dev,\n\t\t\t\"Outgoing payload size %zu is too large for ec_dev->dout_size %d\\n\",\n\t\t\tout_size, ec_dev->dout_size);\n\t\treturn -EMSGSIZE;\n\t}\n\n\t \n\tif (!down_read_trylock(&init_lock)) {\n\t\tdev_warn(dev,\n\t\t\t \"Host is not ready to send messages to ISH. Try again\\n\");\n\t\treturn -EAGAIN;\n\t}\n\n\t \n\tout_msg->hdr.channel = CROS_EC_COMMAND;\n\tout_msg->hdr.status = 0;\n\n\tec_dev->dout += OUT_MSG_EC_REQUEST_PREAMBLE;\n\trv = cros_ec_prepare_tx(ec_dev, msg);\n\tif (rv < 0)\n\t\tgoto end_error;\n\tec_dev->dout -= OUT_MSG_EC_REQUEST_PREAMBLE;\n\n\tdev_dbg(dev,\n\t\t\"out_msg: struct_ver=0x%x checksum=0x%x command=0x%x command_ver=0x%x data_len=0x%x\\n\",\n\t\tout_msg->ec_request.struct_version,\n\t\tout_msg->ec_request.checksum,\n\t\tout_msg->ec_request.command,\n\t\tout_msg->ec_request.command_version,\n\t\tout_msg->ec_request.data_len);\n\n\t \n\trv = ish_send(client_data,\n\t\t      (u8 *)out_msg, out_size,\n\t\t      (u8 *)in_msg, in_size);\n\tif (rv < 0)\n\t\tgoto end_error;\n\n\trv = prepare_cros_ec_rx(ec_dev, in_msg, msg);\n\tif (rv)\n\t\tgoto end_error;\n\n\trv = in_msg->ec_response.data_len;\n\n\tdev_dbg(dev,\n\t\t\"in_msg: struct_ver=0x%x checksum=0x%x result=0x%x data_len=0x%x\\n\",\n\t\tin_msg->ec_response.struct_version,\n\t\tin_msg->ec_response.checksum,\n\t\tin_msg->ec_response.result,\n\t\tin_msg->ec_response.data_len);\n\nend_error:\n\tif (msg->command == EC_CMD_REBOOT_EC)\n\t\tmsleep(EC_REBOOT_DELAY_MS);\n\n\tup_read(&init_lock);\n\n\treturn rv;\n}\n\nstatic int cros_ec_dev_init(struct ishtp_cl_data *client_data)\n{\n\tstruct cros_ec_device *ec_dev;\n\tstruct device *dev = cl_data_to_dev(client_data);\n\n\tec_dev = devm_kzalloc(dev, sizeof(*ec_dev), GFP_KERNEL);\n\tif (!ec_dev)\n\t\treturn -ENOMEM;\n\n\tclient_data->ec_dev = ec_dev;\n\tdev->driver_data = ec_dev;\n\n\tec_dev->dev = dev;\n\tec_dev->priv = client_data->cros_ish_cl;\n\tec_dev->cmd_xfer = NULL;\n\tec_dev->pkt_xfer = cros_ec_pkt_xfer_ish;\n\tec_dev->phys_name = dev_name(dev);\n\tec_dev->din_size = sizeof(struct cros_ish_in_msg) +\n\t\t\t   sizeof(struct ec_response_get_protocol_info);\n\tec_dev->dout_size = sizeof(struct cros_ish_out_msg);\n\n\treturn cros_ec_register(ec_dev);\n}\n\nstatic void reset_handler(struct work_struct *work)\n{\n\tint rv;\n\tstruct device *dev;\n\tstruct ishtp_cl *cros_ish_cl;\n\tstruct ishtp_cl_device *cl_device;\n\tstruct ishtp_cl_data *client_data =\n\t\tcontainer_of(work, struct ishtp_cl_data, work_ishtp_reset);\n\n\t \n\tdown_write(&init_lock);\n\n\tcros_ish_cl = client_data->cros_ish_cl;\n\tcl_device = client_data->cl_device;\n\n\t \n\tishtp_cl_unlink(cros_ish_cl);\n\tishtp_cl_flush_queues(cros_ish_cl);\n\tishtp_cl_free(cros_ish_cl);\n\n\tcros_ish_cl = ishtp_cl_allocate(cl_device);\n\tif (!cros_ish_cl) {\n\t\tup_write(&init_lock);\n\t\treturn;\n\t}\n\n\tishtp_set_drvdata(cl_device, cros_ish_cl);\n\tishtp_set_client_data(cros_ish_cl, client_data);\n\tclient_data->cros_ish_cl = cros_ish_cl;\n\n\trv = cros_ish_init(cros_ish_cl);\n\tif (rv) {\n\t\tishtp_cl_free(cros_ish_cl);\n\t\tdev_err(cl_data_to_dev(client_data), \"Reset Failed\\n\");\n\t\tup_write(&init_lock);\n\t\treturn;\n\t}\n\n\t \n\tclient_data->ec_dev->priv = client_data->cros_ish_cl;\n\tdev = cl_data_to_dev(client_data);\n\tdev->driver_data = client_data->ec_dev;\n\n\tdev_info(cl_data_to_dev(client_data), \"Chrome EC ISH reset done\\n\");\n\n\tup_write(&init_lock);\n}\n\n \nstatic int cros_ec_ishtp_probe(struct ishtp_cl_device *cl_device)\n{\n\tint rv;\n\tstruct ishtp_cl *cros_ish_cl;\n\tstruct ishtp_cl_data *client_data =\n\t\tdevm_kzalloc(ishtp_device(cl_device),\n\t\t\t     sizeof(*client_data), GFP_KERNEL);\n\tif (!client_data)\n\t\treturn -ENOMEM;\n\n\t \n\tdown_write(&init_lock);\n\n\tcros_ish_cl = ishtp_cl_allocate(cl_device);\n\tif (!cros_ish_cl) {\n\t\trv = -ENOMEM;\n\t\tgoto end_ishtp_cl_alloc_error;\n\t}\n\n\tishtp_set_drvdata(cl_device, cros_ish_cl);\n\tishtp_set_client_data(cros_ish_cl, client_data);\n\tclient_data->cros_ish_cl = cros_ish_cl;\n\tclient_data->cl_device = cl_device;\n\n\tinit_waitqueue_head(&client_data->response.wait_queue);\n\n\tINIT_WORK(&client_data->work_ishtp_reset,\n\t\t  reset_handler);\n\tINIT_WORK(&client_data->work_ec_evt,\n\t\t  ish_evt_handler);\n\n\trv = cros_ish_init(cros_ish_cl);\n\tif (rv)\n\t\tgoto end_ishtp_cl_init_error;\n\n\tishtp_get_device(cl_device);\n\n\tup_write(&init_lock);\n\n\t \n\trv = cros_ec_dev_init(client_data);\n\tif (rv) {\n\t\tdown_write(&init_lock);\n\t\tgoto end_cros_ec_dev_init_error;\n\t}\n\n\treturn 0;\n\nend_cros_ec_dev_init_error:\n\tishtp_set_connection_state(cros_ish_cl, ISHTP_CL_DISCONNECTING);\n\tishtp_cl_disconnect(cros_ish_cl);\n\tishtp_cl_unlink(cros_ish_cl);\n\tishtp_cl_flush_queues(cros_ish_cl);\n\tishtp_put_device(cl_device);\nend_ishtp_cl_init_error:\n\tishtp_cl_free(cros_ish_cl);\nend_ishtp_cl_alloc_error:\n\tup_write(&init_lock);\n\treturn rv;\n}\n\n \nstatic void cros_ec_ishtp_remove(struct ishtp_cl_device *cl_device)\n{\n\tstruct ishtp_cl\t*cros_ish_cl = ishtp_get_drvdata(cl_device);\n\tstruct ishtp_cl_data *client_data = ishtp_get_client_data(cros_ish_cl);\n\n\tcancel_work_sync(&client_data->work_ishtp_reset);\n\tcancel_work_sync(&client_data->work_ec_evt);\n\tcros_ish_deinit(cros_ish_cl);\n\tishtp_put_device(cl_device);\n}\n\n \nstatic int cros_ec_ishtp_reset(struct ishtp_cl_device *cl_device)\n{\n\tstruct ishtp_cl\t*cros_ish_cl = ishtp_get_drvdata(cl_device);\n\tstruct ishtp_cl_data *client_data = ishtp_get_client_data(cros_ish_cl);\n\n\tschedule_work(&client_data->work_ishtp_reset);\n\n\treturn 0;\n}\n\n \nstatic int __maybe_unused cros_ec_ishtp_suspend(struct device *device)\n{\n\tstruct ishtp_cl_device *cl_device = ishtp_dev_to_cl_device(device);\n\tstruct ishtp_cl\t*cros_ish_cl = ishtp_get_drvdata(cl_device);\n\tstruct ishtp_cl_data *client_data = ishtp_get_client_data(cros_ish_cl);\n\n\treturn cros_ec_suspend(client_data->ec_dev);\n}\n\n \nstatic int __maybe_unused cros_ec_ishtp_resume(struct device *device)\n{\n\tstruct ishtp_cl_device *cl_device = ishtp_dev_to_cl_device(device);\n\tstruct ishtp_cl\t*cros_ish_cl = ishtp_get_drvdata(cl_device);\n\tstruct ishtp_cl_data *client_data = ishtp_get_client_data(cros_ish_cl);\n\n\treturn cros_ec_resume(client_data->ec_dev);\n}\n\nstatic SIMPLE_DEV_PM_OPS(cros_ec_ishtp_pm_ops, cros_ec_ishtp_suspend,\n\t\t\t cros_ec_ishtp_resume);\n\nstatic struct ishtp_cl_driver\tcros_ec_ishtp_driver = {\n\t.name = \"cros_ec_ishtp\",\n\t.id = cros_ec_ishtp_id_table,\n\t.probe = cros_ec_ishtp_probe,\n\t.remove = cros_ec_ishtp_remove,\n\t.reset = cros_ec_ishtp_reset,\n\t.driver = {\n\t\t.pm = &cros_ec_ishtp_pm_ops,\n\t},\n};\n\nstatic int __init cros_ec_ishtp_mod_init(void)\n{\n\treturn ishtp_cl_driver_register(&cros_ec_ishtp_driver, THIS_MODULE);\n}\n\nstatic void __exit cros_ec_ishtp_mod_exit(void)\n{\n\tishtp_cl_driver_unregister(&cros_ec_ishtp_driver);\n}\n\nmodule_init(cros_ec_ishtp_mod_init);\nmodule_exit(cros_ec_ishtp_mod_exit);\n\nMODULE_DESCRIPTION(\"ChromeOS EC ISHTP Client Driver\");\nMODULE_AUTHOR(\"Rushikesh S Kadam <rushikesh.s.kadam@intel.com>\");\n\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}