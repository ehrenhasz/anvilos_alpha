{
  "module_name": "cros_usbpd_logger.c",
  "hash_id": "1804cee16ada0d309caf37682d442eb3daec138d77e374eb2792b65a0af54178",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/chrome/cros_usbpd_logger.c",
  "human_readable_source": "\n \n\n#include <linux/ktime.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/platform_data/cros_ec_commands.h>\n#include <linux/platform_data/cros_ec_proto.h>\n#include <linux/platform_device.h>\n#include <linux/rtc.h>\n\n#define DRV_NAME \"cros-usbpd-logger\"\n\n#define CROS_USBPD_MAX_LOG_ENTRIES\t30\n#define CROS_USBPD_LOG_UPDATE_DELAY\tmsecs_to_jiffies(60000)\n#define CROS_USBPD_DATA_SIZE\t\t16\n#define CROS_USBPD_LOG_RESP_SIZE\t(sizeof(struct ec_response_pd_log) + \\\n\t\t\t\t\t CROS_USBPD_DATA_SIZE)\n#define CROS_USBPD_BUFFER_SIZE\t\t(sizeof(struct cros_ec_command) + \\\n\t\t\t\t\t CROS_USBPD_LOG_RESP_SIZE)\n \n#define BUF_SIZE\t80\n\nstruct logger_data {\n\tstruct device *dev;\n\tstruct cros_ec_dev *ec_dev;\n\tu8 ec_buffer[CROS_USBPD_BUFFER_SIZE];\n\tstruct delayed_work log_work;\n\tstruct workqueue_struct *log_workqueue;\n};\n\nstatic const char * const chg_type_names[] = {\n\t\"None\", \"PD\", \"Type-C\", \"Proprietary\", \"DCP\", \"CDP\", \"SDP\",\n\t\"Other\", \"VBUS\"\n};\n\nstatic const char * const role_names[] = {\n\t\"Disconnected\", \"SRC\", \"SNK\", \"SNK (not charging)\"\n};\n\nstatic const char * const fault_names[] = {\n\t\"---\", \"OCP\", \"fast OCP\", \"OVP\", \"Discharge\"\n};\n\n__printf(3, 4)\nstatic int append_str(char *buf, int pos, const char *fmt, ...)\n{\n\tva_list args;\n\tint i;\n\n\tva_start(args, fmt);\n\ti = vsnprintf(buf + pos, BUF_SIZE - pos, fmt, args);\n\tva_end(args);\n\n\treturn i;\n}\n\nstatic struct ec_response_pd_log *ec_get_log_entry(struct logger_data *logger)\n{\n\tstruct cros_ec_dev *ec_dev = logger->ec_dev;\n\tstruct cros_ec_command *msg;\n\tint ret;\n\n\tmsg = (struct cros_ec_command *)logger->ec_buffer;\n\n\tmsg->command = ec_dev->cmd_offset + EC_CMD_PD_GET_LOG_ENTRY;\n\tmsg->insize = CROS_USBPD_LOG_RESP_SIZE;\n\n\tret = cros_ec_cmd_xfer_status(ec_dev->ec_dev, msg);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\n\treturn (struct ec_response_pd_log *)msg->data;\n}\n\nstatic void cros_usbpd_print_log_entry(struct ec_response_pd_log *r,\n\t\t\t\t       ktime_t tstamp)\n{\n\tconst char *fault, *role, *chg_type;\n\tstruct usb_chg_measures *meas;\n\tstruct mcdp_info *minfo;\n\tint role_idx, type_idx;\n\tchar buf[BUF_SIZE + 1];\n\tstruct rtc_time rt;\n\tint len = 0;\n\ts32 rem;\n\tint i;\n\n\t \n\ttstamp = ktime_sub_us(tstamp, r->timestamp << PD_LOG_TIMESTAMP_SHIFT);\n\trt = rtc_ktime_to_tm(tstamp);\n\n\tswitch (r->type) {\n\tcase PD_EVENT_MCU_CHARGE:\n\t\tif (r->data & CHARGE_FLAGS_OVERRIDE)\n\t\t\tlen += append_str(buf, len, \"override \");\n\n\t\tif (r->data & CHARGE_FLAGS_DELAYED_OVERRIDE)\n\t\t\tlen += append_str(buf, len, \"pending_override \");\n\n\t\trole_idx = r->data & CHARGE_FLAGS_ROLE_MASK;\n\t\trole = role_idx < ARRAY_SIZE(role_names) ?\n\t\t\trole_names[role_idx] : \"Unknown\";\n\n\t\ttype_idx = (r->data & CHARGE_FLAGS_TYPE_MASK)\n\t\t\t >> CHARGE_FLAGS_TYPE_SHIFT;\n\n\t\tchg_type = type_idx < ARRAY_SIZE(chg_type_names) ?\n\t\t\tchg_type_names[type_idx] : \"???\";\n\n\t\tif (role_idx == USB_PD_PORT_POWER_DISCONNECTED ||\n\t\t    role_idx == USB_PD_PORT_POWER_SOURCE) {\n\t\t\tlen += append_str(buf, len, \"%s\", role);\n\t\t\tbreak;\n\t\t}\n\n\t\tmeas = (struct usb_chg_measures *)r->payload;\n\t\tlen += append_str(buf, len, \"%s %s %s %dmV max %dmV / %dmA\",\n\t\t\t\t  role,\tr->data & CHARGE_FLAGS_DUAL_ROLE ?\n\t\t\t\t  \"DRP\" : \"Charger\",\n\t\t\t\t  chg_type, meas->voltage_now,\n\t\t\t\t  meas->voltage_max, meas->current_max);\n\t\tbreak;\n\tcase PD_EVENT_ACC_RW_FAIL:\n\t\tlen += append_str(buf, len, \"RW signature check failed\");\n\t\tbreak;\n\tcase PD_EVENT_PS_FAULT:\n\t\tfault = r->data < ARRAY_SIZE(fault_names) ? fault_names[r->data]\n\t\t\t\t\t\t\t  : \"???\";\n\t\tlen += append_str(buf, len, \"Power supply fault: %s\", fault);\n\t\tbreak;\n\tcase PD_EVENT_VIDEO_DP_MODE:\n\t\tlen += append_str(buf, len, \"DP mode %sabled\", r->data == 1 ?\n\t\t\t\t  \"en\" : \"dis\");\n\t\tbreak;\n\tcase PD_EVENT_VIDEO_CODEC:\n\t\tminfo = (struct mcdp_info *)r->payload;\n\t\tlen += append_str(buf, len, \"HDMI info: family:%04x chipid:%04x \",\n\t\t\t\t  MCDP_FAMILY(minfo->family),\n\t\t\t\t  MCDP_CHIPID(minfo->chipid));\n\t\tlen += append_str(buf, len, \"irom:%d.%d.%d fw:%d.%d.%d\",\n\t\t\t\t  minfo->irom.major, minfo->irom.minor,\n\t\t\t\t  minfo->irom.build, minfo->fw.major,\n\t\t\t\t  minfo->fw.minor, minfo->fw.build);\n\t\tbreak;\n\tdefault:\n\t\tlen += append_str(buf, len, \"Event %02x (%04x) [\", r->type,\n\t\t\t\t  r->data);\n\n\t\tfor (i = 0; i < PD_LOG_SIZE(r->size_port); i++)\n\t\t\tlen += append_str(buf, len, \"%02x \", r->payload[i]);\n\n\t\tlen += append_str(buf, len, \"]\");\n\t\tbreak;\n\t}\n\n\tdiv_s64_rem(ktime_to_ms(tstamp), MSEC_PER_SEC, &rem);\n\tpr_info(\"PDLOG %d/%02d/%02d %02d:%02d:%02d.%03d P%d %s\\n\",\n\t\trt.tm_year + 1900, rt.tm_mon + 1, rt.tm_mday,\n\t\trt.tm_hour, rt.tm_min, rt.tm_sec, rem,\n\t\tPD_LOG_PORT(r->size_port), buf);\n}\n\nstatic void cros_usbpd_log_check(struct work_struct *work)\n{\n\tstruct logger_data *logger = container_of(to_delayed_work(work),\n\t\t\t\t\t\t  struct logger_data,\n\t\t\t\t\t\t  log_work);\n\tstruct device *dev = logger->dev;\n\tstruct ec_response_pd_log *r;\n\tint entries = 0;\n\tktime_t now;\n\n\twhile (entries++ < CROS_USBPD_MAX_LOG_ENTRIES) {\n\t\tr = ec_get_log_entry(logger);\n\t\tnow = ktime_get_real();\n\t\tif (IS_ERR(r)) {\n\t\t\tdev_dbg(dev, \"Cannot get PD log %ld\\n\", PTR_ERR(r));\n\t\t\tbreak;\n\t\t}\n\t\tif (r->type == PD_EVENT_NO_ENTRY)\n\t\t\tbreak;\n\n\t\tcros_usbpd_print_log_entry(r, now);\n\t}\n\n\tqueue_delayed_work(logger->log_workqueue, &logger->log_work,\n\t\t\t   CROS_USBPD_LOG_UPDATE_DELAY);\n}\n\nstatic int cros_usbpd_logger_probe(struct platform_device *pd)\n{\n\tstruct cros_ec_dev *ec_dev = dev_get_drvdata(pd->dev.parent);\n\tstruct device *dev = &pd->dev;\n\tstruct logger_data *logger;\n\n\tlogger = devm_kzalloc(dev, sizeof(*logger), GFP_KERNEL);\n\tif (!logger)\n\t\treturn -ENOMEM;\n\n\tlogger->dev = dev;\n\tlogger->ec_dev = ec_dev;\n\n\tplatform_set_drvdata(pd, logger);\n\n\t \n\tINIT_DELAYED_WORK(&logger->log_work, cros_usbpd_log_check);\n\tlogger->log_workqueue =\tcreate_singlethread_workqueue(\"cros_usbpd_log\");\n\tif (!logger->log_workqueue)\n\t\treturn -ENOMEM;\n\n\tqueue_delayed_work(logger->log_workqueue, &logger->log_work,\n\t\t\t   CROS_USBPD_LOG_UPDATE_DELAY);\n\n\treturn 0;\n}\n\nstatic int cros_usbpd_logger_remove(struct platform_device *pd)\n{\n\tstruct logger_data *logger = platform_get_drvdata(pd);\n\n\tcancel_delayed_work_sync(&logger->log_work);\n\tdestroy_workqueue(logger->log_workqueue);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused cros_usbpd_logger_resume(struct device *dev)\n{\n\tstruct logger_data *logger = dev_get_drvdata(dev);\n\n\tqueue_delayed_work(logger->log_workqueue, &logger->log_work,\n\t\t\t   CROS_USBPD_LOG_UPDATE_DELAY);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused cros_usbpd_logger_suspend(struct device *dev)\n{\n\tstruct logger_data *logger = dev_get_drvdata(dev);\n\n\tcancel_delayed_work_sync(&logger->log_work);\n\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(cros_usbpd_logger_pm_ops, cros_usbpd_logger_suspend,\n\t\t\t cros_usbpd_logger_resume);\n\nstatic struct platform_driver cros_usbpd_logger_driver = {\n\t.driver = {\n\t\t.name = DRV_NAME,\n\t\t.pm = &cros_usbpd_logger_pm_ops,\n\t},\n\t.probe = cros_usbpd_logger_probe,\n\t.remove = cros_usbpd_logger_remove,\n};\n\nmodule_platform_driver(cros_usbpd_logger_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"Logging driver for ChromeOS EC USBPD Charger.\");\nMODULE_ALIAS(\"platform:\" DRV_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}