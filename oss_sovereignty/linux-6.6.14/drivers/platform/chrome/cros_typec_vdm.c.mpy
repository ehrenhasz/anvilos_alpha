{
  "module_name": "cros_typec_vdm.c",
  "hash_id": "3e4327a27ee25ad44960d9f5e07581dd12e80a88ecbcdc7f8f953e4828cceeb7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/chrome/cros_typec_vdm.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/platform_data/cros_ec_commands.h>\n#include <linux/usb/pd_vdo.h>\n\n#include \"cros_ec_typec.h\"\n#include \"cros_typec_vdm.h\"\n\n \nvoid cros_typec_handle_vdm_attention(struct cros_typec_data *typec, int port_num)\n{\n\tstruct ec_response_typec_vdm_response resp;\n\tstruct ec_params_typec_vdm_response req = {\n\t\t.port = port_num,\n\t};\n\tstruct typec_altmode *amode;\n\tu16 svid;\n\tu32 hdr;\n\tint ret;\n\n\tdo {\n\t\tret = cros_ec_cmd(typec->ec, 0, EC_CMD_TYPEC_VDM_RESPONSE, &req,\n\t\t\t\tsizeof(req), &resp, sizeof(resp));\n\t\tif (ret < 0) {\n\t\t\tdev_warn(typec->dev, \"Failed VDM response fetch, port: %d\\n\", port_num);\n\t\t\treturn;\n\t\t}\n\n\t\thdr = resp.vdm_response[0];\n\t\tsvid = PD_VDO_VID(hdr);\n\t\tdev_dbg(typec->dev, \"Received VDM Attention header: %x, port: %d\\n\", hdr, port_num);\n\n\t\tamode = typec_match_altmode(typec->ports[port_num]->port_altmode,\n\t\t\t\t\t    CROS_EC_ALTMODE_MAX, svid, PD_VDO_OPOS(hdr));\n\t\tif (!amode) {\n\t\t\tdev_err(typec->dev,\n\t\t\t\t\"Received VDM for unregistered altmode (SVID:%x), port: %d\\n\",\n\t\t\t\tsvid, port_num);\n\t\t\treturn;\n\t\t}\n\n\t\ttypec_altmode_attention(amode, resp.vdm_attention[1]);\n\t} while (resp.vdm_attention_left);\n}\n\n \nvoid cros_typec_handle_vdm_response(struct cros_typec_data *typec, int port_num)\n{\n\tstruct ec_response_typec_vdm_response resp;\n\tstruct ec_params_typec_vdm_response req = {\n\t\t.port = port_num,\n\t};\n\tstruct typec_altmode *amode;\n\tu16 svid;\n\tu32 hdr;\n\tint ret;\n\n\tret = cros_ec_cmd(typec->ec, 0, EC_CMD_TYPEC_VDM_RESPONSE, &req,\n\t\t\t  sizeof(req), &resp, sizeof(resp));\n\tif (ret < 0) {\n\t\tdev_warn(typec->dev, \"Failed VDM response fetch, port: %d\\n\", port_num);\n\t\treturn;\n\t}\n\n\thdr = resp.vdm_response[0];\n\tsvid = PD_VDO_VID(hdr);\n\tdev_dbg(typec->dev, \"Received VDM header: %x, port: %d\\n\", hdr, port_num);\n\n\tamode = typec_match_altmode(typec->ports[port_num]->port_altmode, CROS_EC_ALTMODE_MAX,\n\t\t\t\t    svid, PD_VDO_OPOS(hdr));\n\tif (!amode) {\n\t\tdev_err(typec->dev, \"Received VDM for unregistered altmode (SVID:%x), port: %d\\n\",\n\t\t\tsvid, port_num);\n\t\treturn;\n\t}\n\n\tret = typec_altmode_vdm(amode, hdr, &resp.vdm_response[1], resp.vdm_data_objects);\n\tif (ret)\n\t\tdev_err(typec->dev, \"Failed to forward VDM to altmode (SVID:%x), port: %d\\n\",\n\t\t\tsvid, port_num);\n}\n\nstatic int cros_typec_port_amode_enter(struct typec_altmode *amode, u32 *vdo)\n{\n\tstruct cros_typec_port *port = typec_altmode_get_drvdata(amode);\n\tstruct ec_params_typec_control req = {\n\t\t.port = port->port_num,\n\t\t.command = TYPEC_CONTROL_COMMAND_SEND_VDM_REQ,\n\t};\n\tstruct typec_vdm_req vdm_req = {};\n\tu32 hdr;\n\n\thdr = VDO(amode->svid, 1, SVDM_VER_2_0, CMD_ENTER_MODE);\n\thdr |= VDO_OPOS(amode->mode);\n\n\tvdm_req.vdm_data[0] = hdr;\n\tvdm_req.vdm_data_objects = 1;\n\tvdm_req.partner_type = TYPEC_PARTNER_SOP;\n\treq.vdm_req_params = vdm_req;\n\n\tdev_dbg(port->typec_data->dev, \"Sending EnterMode VDM, hdr: %x, port: %d\\n\",\n\t\thdr, port->port_num);\n\n\treturn cros_ec_cmd(port->typec_data->ec, 0, EC_CMD_TYPEC_CONTROL, &req,\n\t\t\t   sizeof(req), NULL, 0);\n}\n\nstatic int cros_typec_port_amode_vdm(struct typec_altmode *amode, const u32 hdr,\n\t\t\t\t     const u32 *vdo, int cnt)\n{\n\tstruct cros_typec_port *port = typec_altmode_get_drvdata(amode);\n\tstruct ec_params_typec_control req = {\n\t\t.port = port->port_num,\n\t\t.command = TYPEC_CONTROL_COMMAND_SEND_VDM_REQ,\n\t};\n\tstruct typec_vdm_req vdm_req = {};\n\tint i;\n\n\tvdm_req.vdm_data[0] = hdr;\n\tvdm_req.vdm_data_objects = cnt;\n\tfor (i = 1; i < cnt; i++)\n\t\tvdm_req.vdm_data[i] = vdo[i-1];\n\tvdm_req.partner_type = TYPEC_PARTNER_SOP;\n\treq.vdm_req_params = vdm_req;\n\n\tdev_dbg(port->typec_data->dev, \"Sending VDM, hdr: %x, num_objects: %d, port: %d\\n\",\n\t\thdr, cnt, port->port_num);\n\n\treturn cros_ec_cmd(port->typec_data->ec, 0, EC_CMD_TYPEC_CONTROL, &req,\n\t\t\t   sizeof(req), NULL, 0);\n}\n\nstruct typec_altmode_ops port_amode_ops = {\n\t.enter = cros_typec_port_amode_enter,\n\t.vdm = cros_typec_port_amode_vdm,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}