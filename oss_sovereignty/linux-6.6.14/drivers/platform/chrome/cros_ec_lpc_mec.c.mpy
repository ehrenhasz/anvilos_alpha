{
  "module_name": "cros_ec_lpc_mec.c",
  "hash_id": "00dd243f92f8018b4fae87532d96b756e325a6a46cff1e58e20aee9e23d00d5e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/chrome/cros_ec_lpc_mec.c",
  "human_readable_source": "\n\n\n\n\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/mutex.h>\n#include <linux/types.h>\n\n#include \"cros_ec_lpc_mec.h\"\n\n \nstatic DEFINE_MUTEX(io_mutex);\nstatic u16 mec_emi_base, mec_emi_end;\n\n \nstatic void cros_ec_lpc_mec_emi_write_address(u16 addr,\n\t\t\tenum cros_ec_lpc_mec_emi_access_mode access_type)\n{\n\toutb((addr & 0xfc) | access_type, MEC_EMI_EC_ADDRESS_B0(mec_emi_base));\n\toutb((addr >> 8) & 0x7f, MEC_EMI_EC_ADDRESS_B1(mec_emi_base));\n}\n\n \nint cros_ec_lpc_mec_in_range(unsigned int offset, unsigned int length)\n{\n\tif (length == 0)\n\t\treturn -EINVAL;\n\n\tif (WARN_ON(mec_emi_base == 0 || mec_emi_end == 0))\n\t\treturn -EINVAL;\n\n\tif (offset >= mec_emi_base && offset < mec_emi_end) {\n\t\tif (WARN_ON(offset + length - 1 >= mec_emi_end))\n\t\t\treturn -EINVAL;\n\t\treturn 1;\n\t}\n\n\tif (WARN_ON(offset + length > mec_emi_base && offset < mec_emi_end))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n \nu8 cros_ec_lpc_io_bytes_mec(enum cros_ec_lpc_mec_io_type io_type,\n\t\t\t    unsigned int offset, unsigned int length,\n\t\t\t    u8 *buf)\n{\n\tint i = 0;\n\tint io_addr;\n\tu8 sum = 0;\n\tenum cros_ec_lpc_mec_emi_access_mode access, new_access;\n\n\t \n\tWARN_ON(mec_emi_base == 0 || mec_emi_end == 0);\n\tif (mec_emi_base == 0 || mec_emi_end == 0)\n\t\treturn 0;\n\n\t \n\tif (offset & 0x3 || length < 4)\n\t\taccess = ACCESS_TYPE_BYTE;\n\telse\n\t\taccess = ACCESS_TYPE_LONG_AUTO_INCREMENT;\n\n\tmutex_lock(&io_mutex);\n\n\t \n\tcros_ec_lpc_mec_emi_write_address(offset, access);\n\n\t \n\tio_addr = MEC_EMI_EC_DATA_B0(mec_emi_base) + (offset & 0x3);\n\twhile (i < length) {\n\t\twhile (io_addr <= MEC_EMI_EC_DATA_B3(mec_emi_base)) {\n\t\t\tif (io_type == MEC_IO_READ)\n\t\t\t\tbuf[i] = inb(io_addr++);\n\t\t\telse\n\t\t\t\toutb(buf[i], io_addr++);\n\n\t\t\tsum += buf[i++];\n\t\t\toffset++;\n\n\t\t\t \n\t\t\tif (i == length)\n\t\t\t\tgoto done;\n\t\t}\n\n\t\t \n\t\tif (length - i < 4 && io_type == MEC_IO_WRITE)\n\t\t\tnew_access = ACCESS_TYPE_BYTE;\n\t\telse\n\t\t\tnew_access = ACCESS_TYPE_LONG_AUTO_INCREMENT;\n\n\t\tif (new_access != access ||\n\t\t    access != ACCESS_TYPE_LONG_AUTO_INCREMENT) {\n\t\t\taccess = new_access;\n\t\t\tcros_ec_lpc_mec_emi_write_address(offset, access);\n\t\t}\n\n\t\t \n\t\tio_addr = MEC_EMI_EC_DATA_B0(mec_emi_base);\n\t}\n\ndone:\n\tmutex_unlock(&io_mutex);\n\n\treturn sum;\n}\nEXPORT_SYMBOL(cros_ec_lpc_io_bytes_mec);\n\nvoid cros_ec_lpc_mec_init(unsigned int base, unsigned int end)\n{\n\tmec_emi_base = base;\n\tmec_emi_end = end;\n}\nEXPORT_SYMBOL(cros_ec_lpc_mec_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}