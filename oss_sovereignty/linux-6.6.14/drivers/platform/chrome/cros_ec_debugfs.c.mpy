{
  "module_name": "cros_ec_debugfs.c",
  "hash_id": "2cd62504460d7525f7c7c7386adbdf582543ee96cf03897c57555b1a91188893",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/chrome/cros_ec_debugfs.c",
  "human_readable_source": "\n\n\n\n\n#include <linux/circ_buf.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/platform_data/cros_ec_commands.h>\n#include <linux/platform_data/cros_ec_proto.h>\n#include <linux/platform_device.h>\n#include <linux/poll.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n\n#define DRV_NAME \"cros-ec-debugfs\"\n\n#define LOG_SHIFT\t\t14\n#define LOG_SIZE\t\t(1 << LOG_SHIFT)\n#define LOG_POLL_SEC\t\t10\n\n#define CIRC_ADD(idx, size, value)\t(((idx) + (value)) & ((size) - 1))\n\n \nstatic DECLARE_WAIT_QUEUE_HEAD(cros_ec_debugfs_log_wq);\n\n \nstruct cros_ec_debugfs {\n\tstruct cros_ec_dev *ec;\n\tstruct dentry *dir;\n\t \n\tstruct circ_buf log_buffer;\n\tstruct cros_ec_command *read_msg;\n\tstruct mutex log_mutex;\n\tstruct delayed_work log_poll_work;\n\t \n\tstruct debugfs_blob_wrapper panicinfo_blob;\n\tstruct notifier_block notifier_panic;\n};\n\n \nstatic void cros_ec_console_log_work(struct work_struct *__work)\n{\n\tstruct cros_ec_debugfs *debug_info =\n\t\tcontainer_of(to_delayed_work(__work),\n\t\t\t     struct cros_ec_debugfs,\n\t\t\t     log_poll_work);\n\tstruct cros_ec_dev *ec = debug_info->ec;\n\tstruct circ_buf *cb = &debug_info->log_buffer;\n\tstruct cros_ec_command snapshot_msg = {\n\t\t.command = EC_CMD_CONSOLE_SNAPSHOT + ec->cmd_offset,\n\t};\n\n\tstruct ec_params_console_read_v1 *read_params =\n\t\t(struct ec_params_console_read_v1 *)debug_info->read_msg->data;\n\tuint8_t *ec_buffer = (uint8_t *)debug_info->read_msg->data;\n\tint idx;\n\tint buf_space;\n\tint ret;\n\n\tret = cros_ec_cmd_xfer_status(ec->ec_dev, &snapshot_msg);\n\tif (ret < 0)\n\t\tgoto resched;\n\n\t \n\tmutex_lock(&debug_info->log_mutex);\n\tbuf_space = CIRC_SPACE(cb->head, cb->tail, LOG_SIZE);\n\n\twhile (1) {\n\t\tif (!buf_space) {\n\t\t\tdev_info_once(ec->dev,\n\t\t\t\t      \"Some logs may have been dropped...\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tmemset(read_params, '\\0', sizeof(*read_params));\n\t\tread_params->subcmd = CONSOLE_READ_RECENT;\n\t\tret = cros_ec_cmd_xfer_status(ec->ec_dev,\n\t\t\t\t\t      debug_info->read_msg);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\n\t\t \n\t\tif (ret == 0 || ec_buffer[0] == '\\0')\n\t\t\tbreak;\n\n\t\tidx = 0;\n\t\twhile (idx < ret && ec_buffer[idx] != '\\0' && buf_space > 0) {\n\t\t\tcb->buf[cb->head] = ec_buffer[idx];\n\t\t\tcb->head = CIRC_ADD(cb->head, LOG_SIZE, 1);\n\t\t\tidx++;\n\t\t\tbuf_space--;\n\t\t}\n\n\t\twake_up(&cros_ec_debugfs_log_wq);\n\t}\n\n\tmutex_unlock(&debug_info->log_mutex);\n\nresched:\n\tschedule_delayed_work(&debug_info->log_poll_work,\n\t\t\t      msecs_to_jiffies(LOG_POLL_SEC * 1000));\n}\n\nstatic int cros_ec_console_log_open(struct inode *inode, struct file *file)\n{\n\tfile->private_data = inode->i_private;\n\n\treturn stream_open(inode, file);\n}\n\nstatic ssize_t cros_ec_console_log_read(struct file *file, char __user *buf,\n\t\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct cros_ec_debugfs *debug_info = file->private_data;\n\tstruct circ_buf *cb = &debug_info->log_buffer;\n\tssize_t ret;\n\n\tmutex_lock(&debug_info->log_mutex);\n\n\twhile (!CIRC_CNT(cb->head, cb->tail, LOG_SIZE)) {\n\t\tif (file->f_flags & O_NONBLOCK) {\n\t\t\tret = -EAGAIN;\n\t\t\tgoto error;\n\t\t}\n\n\t\tmutex_unlock(&debug_info->log_mutex);\n\n\t\tret = wait_event_interruptible(cros_ec_debugfs_log_wq,\n\t\t\t\t\tCIRC_CNT(cb->head, cb->tail, LOG_SIZE));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tmutex_lock(&debug_info->log_mutex);\n\t}\n\n\t \n\tret = min_t(size_t, CIRC_CNT_TO_END(cb->head, cb->tail, LOG_SIZE),\n\t\t    count);\n\n\tif (copy_to_user(buf, cb->buf + cb->tail, ret)) {\n\t\tret = -EFAULT;\n\t\tgoto error;\n\t}\n\n\tcb->tail = CIRC_ADD(cb->tail, LOG_SIZE, ret);\n\nerror:\n\tmutex_unlock(&debug_info->log_mutex);\n\treturn ret;\n}\n\nstatic __poll_t cros_ec_console_log_poll(struct file *file,\n\t\t\t\t\t     poll_table *wait)\n{\n\tstruct cros_ec_debugfs *debug_info = file->private_data;\n\t__poll_t mask = 0;\n\n\tpoll_wait(file, &cros_ec_debugfs_log_wq, wait);\n\n\tmutex_lock(&debug_info->log_mutex);\n\tif (CIRC_CNT(debug_info->log_buffer.head,\n\t\t     debug_info->log_buffer.tail,\n\t\t     LOG_SIZE))\n\t\tmask |= EPOLLIN | EPOLLRDNORM;\n\tmutex_unlock(&debug_info->log_mutex);\n\n\treturn mask;\n}\n\nstatic int cros_ec_console_log_release(struct inode *inode, struct file *file)\n{\n\treturn 0;\n}\n\nstatic ssize_t cros_ec_pdinfo_read(struct file *file,\n\t\t\t\t   char __user *user_buf,\n\t\t\t\t   size_t count,\n\t\t\t\t   loff_t *ppos)\n{\n\tchar read_buf[EC_USB_PD_MAX_PORTS * 40], *p = read_buf;\n\tstruct cros_ec_debugfs *debug_info = file->private_data;\n\tstruct cros_ec_device *ec_dev = debug_info->ec->ec_dev;\n\tstruct {\n\t\tstruct cros_ec_command msg;\n\t\tunion {\n\t\t\tstruct ec_response_usb_pd_control_v1 resp;\n\t\t\tstruct ec_params_usb_pd_control params;\n\t\t};\n\t} __packed ec_buf;\n\tstruct cros_ec_command *msg;\n\tstruct ec_response_usb_pd_control_v1 *resp;\n\tstruct ec_params_usb_pd_control *params;\n\tint i;\n\n\tmsg = &ec_buf.msg;\n\tparams = (struct ec_params_usb_pd_control *)msg->data;\n\tresp = (struct ec_response_usb_pd_control_v1 *)msg->data;\n\n\tmsg->command = EC_CMD_USB_PD_CONTROL;\n\tmsg->version = 1;\n\tmsg->insize = sizeof(*resp);\n\tmsg->outsize = sizeof(*params);\n\n\t \n\tfor (i = 0; i < EC_USB_PD_MAX_PORTS; ++i) {\n\t\tparams->port = i;\n\t\tparams->role = 0;\n\t\tparams->mux = 0;\n\t\tparams->swap = 0;\n\n\t\tif (cros_ec_cmd_xfer_status(ec_dev, msg) < 0)\n\t\t\tbreak;\n\n\t\tp += scnprintf(p, sizeof(read_buf) + read_buf - p,\n\t\t\t       \"p%d: %s en:%.2x role:%.2x pol:%.2x\\n\", i,\n\t\t\t       resp->state, resp->enabled, resp->role,\n\t\t\t       resp->polarity);\n\t}\n\n\treturn simple_read_from_buffer(user_buf, count, ppos,\n\t\t\t\t       read_buf, p - read_buf);\n}\n\nstatic bool cros_ec_uptime_is_supported(struct cros_ec_device *ec_dev)\n{\n\tstruct {\n\t\tstruct cros_ec_command cmd;\n\t\tstruct ec_response_uptime_info resp;\n\t} __packed msg = {};\n\tint ret;\n\n\tmsg.cmd.command = EC_CMD_GET_UPTIME_INFO;\n\tmsg.cmd.insize = sizeof(msg.resp);\n\n\tret = cros_ec_cmd_xfer_status(ec_dev, &msg.cmd);\n\tif (ret == -EPROTO && msg.cmd.result == EC_RES_INVALID_COMMAND)\n\t\treturn false;\n\n\t \n\treturn true;\n}\n\nstatic ssize_t cros_ec_uptime_read(struct file *file, char __user *user_buf,\n\t\t\t\t   size_t count, loff_t *ppos)\n{\n\tstruct cros_ec_debugfs *debug_info = file->private_data;\n\tstruct cros_ec_device *ec_dev = debug_info->ec->ec_dev;\n\tstruct {\n\t\tstruct cros_ec_command cmd;\n\t\tstruct ec_response_uptime_info resp;\n\t} __packed msg = {};\n\tstruct ec_response_uptime_info *resp;\n\tchar read_buf[32];\n\tint ret;\n\n\tresp = (struct ec_response_uptime_info *)&msg.resp;\n\n\tmsg.cmd.command = EC_CMD_GET_UPTIME_INFO;\n\tmsg.cmd.insize = sizeof(*resp);\n\n\tret = cros_ec_cmd_xfer_status(ec_dev, &msg.cmd);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = scnprintf(read_buf, sizeof(read_buf), \"%u\\n\",\n\t\t\tresp->time_since_ec_boot_ms);\n\n\treturn simple_read_from_buffer(user_buf, count, ppos, read_buf, ret);\n}\n\nstatic const struct file_operations cros_ec_console_log_fops = {\n\t.owner = THIS_MODULE,\n\t.open = cros_ec_console_log_open,\n\t.read = cros_ec_console_log_read,\n\t.llseek = no_llseek,\n\t.poll = cros_ec_console_log_poll,\n\t.release = cros_ec_console_log_release,\n};\n\nstatic const struct file_operations cros_ec_pdinfo_fops = {\n\t.owner = THIS_MODULE,\n\t.open = simple_open,\n\t.read = cros_ec_pdinfo_read,\n\t.llseek = default_llseek,\n};\n\nstatic const struct file_operations cros_ec_uptime_fops = {\n\t.owner = THIS_MODULE,\n\t.open = simple_open,\n\t.read = cros_ec_uptime_read,\n\t.llseek = default_llseek,\n};\n\nstatic int ec_read_version_supported(struct cros_ec_dev *ec)\n{\n\tstruct ec_params_get_cmd_versions_v1 *params;\n\tstruct ec_response_get_cmd_versions *response;\n\tint ret;\n\n\tstruct cros_ec_command *msg;\n\n\tmsg = kzalloc(sizeof(*msg) + max(sizeof(*params), sizeof(*response)),\n\t\tGFP_KERNEL);\n\tif (!msg)\n\t\treturn 0;\n\n\tmsg->command = EC_CMD_GET_CMD_VERSIONS + ec->cmd_offset;\n\tmsg->outsize = sizeof(*params);\n\tmsg->insize = sizeof(*response);\n\n\tparams = (struct ec_params_get_cmd_versions_v1 *)msg->data;\n\tparams->cmd = EC_CMD_CONSOLE_READ;\n\tresponse = (struct ec_response_get_cmd_versions *)msg->data;\n\n\tret = cros_ec_cmd_xfer_status(ec->ec_dev, msg) >= 0 &&\n\t      response->version_mask & EC_VER_MASK(1);\n\n\tkfree(msg);\n\n\treturn ret;\n}\n\nstatic int cros_ec_create_console_log(struct cros_ec_debugfs *debug_info)\n{\n\tstruct cros_ec_dev *ec = debug_info->ec;\n\tchar *buf;\n\tint read_params_size;\n\tint read_response_size;\n\n\t \n\tif (!ec_read_version_supported(ec))\n\t\treturn 0;\n\n\tbuf = devm_kzalloc(ec->dev, LOG_SIZE, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tread_params_size = sizeof(struct ec_params_console_read_v1);\n\tread_response_size = ec->ec_dev->max_response;\n\tdebug_info->read_msg = devm_kzalloc(ec->dev,\n\t\tsizeof(*debug_info->read_msg) +\n\t\t\tmax(read_params_size, read_response_size), GFP_KERNEL);\n\tif (!debug_info->read_msg)\n\t\treturn -ENOMEM;\n\n\tdebug_info->read_msg->version = 1;\n\tdebug_info->read_msg->command = EC_CMD_CONSOLE_READ + ec->cmd_offset;\n\tdebug_info->read_msg->outsize = read_params_size;\n\tdebug_info->read_msg->insize = read_response_size;\n\n\tdebug_info->log_buffer.buf = buf;\n\tdebug_info->log_buffer.head = 0;\n\tdebug_info->log_buffer.tail = 0;\n\n\tmutex_init(&debug_info->log_mutex);\n\n\tdebugfs_create_file(\"console_log\", S_IFREG | 0444, debug_info->dir,\n\t\t\t    debug_info, &cros_ec_console_log_fops);\n\n\tINIT_DELAYED_WORK(&debug_info->log_poll_work,\n\t\t\t  cros_ec_console_log_work);\n\tschedule_delayed_work(&debug_info->log_poll_work, 0);\n\n\treturn 0;\n}\n\nstatic void cros_ec_cleanup_console_log(struct cros_ec_debugfs *debug_info)\n{\n\tif (debug_info->log_buffer.buf) {\n\t\tcancel_delayed_work_sync(&debug_info->log_poll_work);\n\t\tmutex_destroy(&debug_info->log_mutex);\n\t}\n}\n\n \nstatic int cros_ec_get_panicinfo(struct cros_ec_device *ec_dev, uint8_t *data,\n\t\t\t\t int data_size)\n{\n\tint ret;\n\tstruct cros_ec_command *msg;\n\n\tif (!data || data_size <= 0 || data_size > ec_dev->max_response)\n\t\treturn -EINVAL;\n\n\tmsg = kzalloc(sizeof(*msg) + data_size, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\tmsg->command = EC_CMD_GET_PANIC_INFO;\n\tmsg->insize = data_size;\n\n\tret = cros_ec_cmd_xfer_status(ec_dev, msg);\n\tif (ret < 0)\n\t\tgoto free;\n\n\tmemcpy(data, msg->data, data_size);\n\nfree:\n\tkfree(msg);\n\treturn ret;\n}\n\nstatic int cros_ec_create_panicinfo(struct cros_ec_debugfs *debug_info)\n{\n\tstruct cros_ec_device *ec_dev = debug_info->ec->ec_dev;\n\tint ret;\n\tvoid *data;\n\n\tdata = devm_kzalloc(debug_info->ec->dev, ec_dev->max_response,\n\t\t\t    GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tret = cros_ec_get_panicinfo(ec_dev, data, ec_dev->max_response);\n\tif (ret < 0) {\n\t\tret = 0;\n\t\tgoto free;\n\t}\n\n\t \n\tif (ret == 0)\n\t\tgoto free;\n\n\tdebug_info->panicinfo_blob.data = data;\n\tdebug_info->panicinfo_blob.size = ret;\n\n\tdebugfs_create_blob(\"panicinfo\", S_IFREG | 0444, debug_info->dir,\n\t\t\t    &debug_info->panicinfo_blob);\n\n\treturn 0;\n\nfree:\n\tdevm_kfree(debug_info->ec->dev, data);\n\treturn ret;\n}\n\nstatic int cros_ec_debugfs_panic_event(struct notifier_block *nb,\n\t\t\t\t       unsigned long queued_during_suspend, void *_notify)\n{\n\tstruct cros_ec_debugfs *debug_info =\n\t\tcontainer_of(nb, struct cros_ec_debugfs, notifier_panic);\n\n\tif (debug_info->log_buffer.buf) {\n\t\t \n\t\tmod_delayed_work(debug_info->log_poll_work.wq, &debug_info->log_poll_work, 0);\n\t\t \n\t\tflush_delayed_work(&debug_info->log_poll_work);\n\t}\n\n\treturn NOTIFY_DONE;\n}\n\nstatic int cros_ec_debugfs_probe(struct platform_device *pd)\n{\n\tstruct cros_ec_dev *ec = dev_get_drvdata(pd->dev.parent);\n\tstruct cros_ec_platform *ec_platform = dev_get_platdata(ec->dev);\n\tconst char *name = ec_platform->ec_name;\n\tstruct cros_ec_debugfs *debug_info;\n\tint ret;\n\n\tdebug_info = devm_kzalloc(ec->dev, sizeof(*debug_info), GFP_KERNEL);\n\tif (!debug_info)\n\t\treturn -ENOMEM;\n\n\tdebug_info->ec = ec;\n\tdebug_info->dir = debugfs_create_dir(name, NULL);\n\n\tret = cros_ec_create_panicinfo(debug_info);\n\tif (ret)\n\t\tgoto remove_debugfs;\n\n\tret = cros_ec_create_console_log(debug_info);\n\tif (ret)\n\t\tgoto remove_debugfs;\n\n\tdebugfs_create_file(\"pdinfo\", 0444, debug_info->dir, debug_info,\n\t\t\t    &cros_ec_pdinfo_fops);\n\n\tif (cros_ec_uptime_is_supported(ec->ec_dev))\n\t\tdebugfs_create_file(\"uptime\", 0444, debug_info->dir, debug_info,\n\t\t\t\t    &cros_ec_uptime_fops);\n\n\tdebugfs_create_x32(\"last_resume_result\", 0444, debug_info->dir,\n\t\t\t   &ec->ec_dev->last_resume_result);\n\n\tdebugfs_create_u16(\"suspend_timeout_ms\", 0664, debug_info->dir,\n\t\t\t   &ec->ec_dev->suspend_timeout_ms);\n\n\tdebug_info->notifier_panic.notifier_call = cros_ec_debugfs_panic_event;\n\tret = blocking_notifier_chain_register(&ec->ec_dev->panic_notifier,\n\t\t\t\t\t       &debug_info->notifier_panic);\n\tif (ret)\n\t\tgoto remove_debugfs;\n\n\tec->debug_info = debug_info;\n\n\tdev_set_drvdata(&pd->dev, ec);\n\n\treturn 0;\n\nremove_debugfs:\n\tdebugfs_remove_recursive(debug_info->dir);\n\treturn ret;\n}\n\nstatic int cros_ec_debugfs_remove(struct platform_device *pd)\n{\n\tstruct cros_ec_dev *ec = dev_get_drvdata(pd->dev.parent);\n\n\tdebugfs_remove_recursive(ec->debug_info->dir);\n\tcros_ec_cleanup_console_log(ec->debug_info);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused cros_ec_debugfs_suspend(struct device *dev)\n{\n\tstruct cros_ec_dev *ec = dev_get_drvdata(dev);\n\n\tif (ec->debug_info->log_buffer.buf)\n\t\tcancel_delayed_work_sync(&ec->debug_info->log_poll_work);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused cros_ec_debugfs_resume(struct device *dev)\n{\n\tstruct cros_ec_dev *ec = dev_get_drvdata(dev);\n\n\tif (ec->debug_info->log_buffer.buf)\n\t\tschedule_delayed_work(&ec->debug_info->log_poll_work, 0);\n\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(cros_ec_debugfs_pm_ops,\n\t\t\t cros_ec_debugfs_suspend, cros_ec_debugfs_resume);\n\nstatic struct platform_driver cros_ec_debugfs_driver = {\n\t.driver = {\n\t\t.name = DRV_NAME,\n\t\t.pm = &cros_ec_debugfs_pm_ops,\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t},\n\t.probe = cros_ec_debugfs_probe,\n\t.remove = cros_ec_debugfs_remove,\n};\n\nmodule_platform_driver(cros_ec_debugfs_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Debug logs for ChromeOS EC\");\nMODULE_ALIAS(\"platform:\" DRV_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}