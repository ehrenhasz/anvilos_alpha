{
  "module_name": "cros_ec.c",
  "hash_id": "9665a9dfc231b4efe017dccc68312232d84f7e20de31d8dcd3f115943118c509",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/chrome/cros_ec.c",
  "human_readable_source": "\n \n\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/platform_data/cros_ec_commands.h>\n#include <linux/platform_data/cros_ec_proto.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n\n#include \"cros_ec.h\"\n\nstatic struct cros_ec_platform ec_p = {\n\t.ec_name = CROS_EC_DEV_NAME,\n\t.cmd_offset = EC_CMD_PASSTHRU_OFFSET(CROS_EC_DEV_EC_INDEX),\n};\n\nstatic struct cros_ec_platform pd_p = {\n\t.ec_name = CROS_EC_DEV_PD_NAME,\n\t.cmd_offset = EC_CMD_PASSTHRU_OFFSET(CROS_EC_DEV_PD_INDEX),\n};\n\n \nstatic irqreturn_t cros_ec_irq_handler(int irq, void *data)\n{\n\tstruct cros_ec_device *ec_dev = data;\n\n\tec_dev->last_event_time = cros_ec_get_time_ns();\n\n\treturn IRQ_WAKE_THREAD;\n}\n\n \nstatic bool cros_ec_handle_event(struct cros_ec_device *ec_dev)\n{\n\tbool wake_event;\n\tbool ec_has_more_events;\n\tint ret;\n\n\tret = cros_ec_get_next_event(ec_dev, &wake_event, &ec_has_more_events);\n\n\t \n\tif (wake_event && device_may_wakeup(ec_dev->dev))\n\t\tpm_wakeup_event(ec_dev->dev, 0);\n\n\tif (ret > 0)\n\t\tblocking_notifier_call_chain(&ec_dev->event_notifier,\n\t\t\t\t\t     0, ec_dev);\n\n\treturn ec_has_more_events;\n}\n\n \nirqreturn_t cros_ec_irq_thread(int irq, void *data)\n{\n\tstruct cros_ec_device *ec_dev = data;\n\tbool ec_has_more_events;\n\n\tdo {\n\t\tec_has_more_events = cros_ec_handle_event(ec_dev);\n\t} while (ec_has_more_events);\n\n\treturn IRQ_HANDLED;\n}\nEXPORT_SYMBOL(cros_ec_irq_thread);\n\nstatic int cros_ec_sleep_event(struct cros_ec_device *ec_dev, u8 sleep_event)\n{\n\tint ret;\n\tstruct {\n\t\tstruct cros_ec_command msg;\n\t\tunion {\n\t\t\tstruct ec_params_host_sleep_event req0;\n\t\t\tstruct ec_params_host_sleep_event_v1 req1;\n\t\t\tstruct ec_response_host_sleep_event_v1 resp1;\n\t\t} u;\n\t} __packed buf;\n\n\tmemset(&buf, 0, sizeof(buf));\n\n\tif (ec_dev->host_sleep_v1) {\n\t\tbuf.u.req1.sleep_event = sleep_event;\n\t\tbuf.u.req1.suspend_params.sleep_timeout_ms =\n\t\t\t\tec_dev->suspend_timeout_ms;\n\n\t\tbuf.msg.outsize = sizeof(buf.u.req1);\n\t\tif ((sleep_event == HOST_SLEEP_EVENT_S3_RESUME) ||\n\t\t    (sleep_event == HOST_SLEEP_EVENT_S0IX_RESUME))\n\t\t\tbuf.msg.insize = sizeof(buf.u.resp1);\n\n\t\tbuf.msg.version = 1;\n\n\t} else {\n\t\tbuf.u.req0.sleep_event = sleep_event;\n\t\tbuf.msg.outsize = sizeof(buf.u.req0);\n\t}\n\n\tbuf.msg.command = EC_CMD_HOST_SLEEP_EVENT;\n\n\tret = cros_ec_cmd_xfer_status(ec_dev, &buf.msg);\n\t \n\tif (ret >= 0 && ec_dev->host_sleep_v1 &&\n\t    (sleep_event == HOST_SLEEP_EVENT_S0IX_RESUME ||\n\t     sleep_event == HOST_SLEEP_EVENT_S3_RESUME)) {\n\t\tec_dev->last_resume_result =\n\t\t\tbuf.u.resp1.resume_response.sleep_transitions;\n\n\t\tWARN_ONCE(buf.u.resp1.resume_response.sleep_transitions &\n\t\t\t  EC_HOST_RESUME_SLEEP_TIMEOUT,\n\t\t\t  \"EC detected sleep transition timeout. Total sleep transitions: %d\",\n\t\t\t  buf.u.resp1.resume_response.sleep_transitions &\n\t\t\t  EC_HOST_RESUME_SLEEP_TRANSITIONS_MASK);\n\t}\n\n\treturn ret;\n}\n\nstatic int cros_ec_ready_event(struct notifier_block *nb,\n\t\t\t       unsigned long queued_during_suspend,\n\t\t\t       void *_notify)\n{\n\tstruct cros_ec_device *ec_dev = container_of(nb, struct cros_ec_device,\n\t\t\t\t\t\t     notifier_ready);\n\tu32 host_event = cros_ec_get_host_event(ec_dev);\n\n\tif (host_event & EC_HOST_EVENT_MASK(EC_HOST_EVENT_INTERFACE_READY)) {\n\t\tmutex_lock(&ec_dev->lock);\n\t\tcros_ec_query_all(ec_dev);\n\t\tmutex_unlock(&ec_dev->lock);\n\t\treturn NOTIFY_OK;\n\t}\n\n\treturn NOTIFY_DONE;\n}\n\n \nint cros_ec_register(struct cros_ec_device *ec_dev)\n{\n\tstruct device *dev = ec_dev->dev;\n\tint err = 0;\n\n\tBLOCKING_INIT_NOTIFIER_HEAD(&ec_dev->event_notifier);\n\tBLOCKING_INIT_NOTIFIER_HEAD(&ec_dev->panic_notifier);\n\n\tec_dev->max_request = sizeof(struct ec_params_hello);\n\tec_dev->max_response = sizeof(struct ec_response_get_protocol_info);\n\tec_dev->max_passthru = 0;\n\tec_dev->ec = NULL;\n\tec_dev->pd = NULL;\n\tec_dev->suspend_timeout_ms = EC_HOST_SLEEP_TIMEOUT_DEFAULT;\n\n\tec_dev->din = devm_kzalloc(dev, ec_dev->din_size, GFP_KERNEL);\n\tif (!ec_dev->din)\n\t\treturn -ENOMEM;\n\n\tec_dev->dout = devm_kzalloc(dev, ec_dev->dout_size, GFP_KERNEL);\n\tif (!ec_dev->dout)\n\t\treturn -ENOMEM;\n\n\tlockdep_register_key(&ec_dev->lockdep_key);\n\tmutex_init(&ec_dev->lock);\n\tlockdep_set_class(&ec_dev->lock, &ec_dev->lockdep_key);\n\n\terr = cros_ec_query_all(ec_dev);\n\tif (err) {\n\t\tdev_err(dev, \"Cannot identify the EC: error %d\\n\", err);\n\t\tgoto exit;\n\t}\n\n\tif (ec_dev->irq > 0) {\n\t\terr = devm_request_threaded_irq(dev, ec_dev->irq,\n\t\t\t\t\t\tcros_ec_irq_handler,\n\t\t\t\t\t\tcros_ec_irq_thread,\n\t\t\t\t\t\tIRQF_TRIGGER_LOW | IRQF_ONESHOT,\n\t\t\t\t\t\t\"chromeos-ec\", ec_dev);\n\t\tif (err) {\n\t\t\tdev_err(dev, \"Failed to request IRQ %d: %d\\n\",\n\t\t\t\tec_dev->irq, err);\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\t \n\tec_dev->ec = platform_device_register_data(ec_dev->dev, \"cros-ec-dev\",\n\t\t\t\t\tPLATFORM_DEVID_AUTO, &ec_p,\n\t\t\t\t\tsizeof(struct cros_ec_platform));\n\tif (IS_ERR(ec_dev->ec)) {\n\t\tdev_err(ec_dev->dev,\n\t\t\t\"Failed to create CrOS EC platform device\\n\");\n\t\terr = PTR_ERR(ec_dev->ec);\n\t\tgoto exit;\n\t}\n\n\tif (ec_dev->max_passthru) {\n\t\t \n\t\tec_dev->pd = platform_device_register_data(ec_dev->dev,\n\t\t\t\t\t\"cros-ec-dev\",\n\t\t\t\t\tPLATFORM_DEVID_AUTO, &pd_p,\n\t\t\t\t\tsizeof(struct cros_ec_platform));\n\t\tif (IS_ERR(ec_dev->pd)) {\n\t\t\tdev_err(ec_dev->dev,\n\t\t\t\t\"Failed to create CrOS PD platform device\\n\");\n\t\t\terr = PTR_ERR(ec_dev->pd);\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tif (IS_ENABLED(CONFIG_OF) && dev->of_node) {\n\t\terr = devm_of_platform_populate(dev);\n\t\tif (err) {\n\t\t\tdev_err(dev, \"Failed to register sub-devices\\n\");\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\t \n\terr = cros_ec_sleep_event(ec_dev, 0);\n\tif (err < 0)\n\t\tdev_dbg(ec_dev->dev, \"Error %d clearing sleep event to ec\\n\",\n\t\t\terr);\n\n\tif (ec_dev->mkbp_event_supported) {\n\t\t \n\t\tec_dev->notifier_ready.notifier_call = cros_ec_ready_event;\n\t\terr = blocking_notifier_chain_register(&ec_dev->event_notifier,\n\t\t\t\t\t\t      &ec_dev->notifier_ready);\n\t\tif (err)\n\t\t\tgoto exit;\n\t}\n\n\tdev_info(dev, \"Chrome EC device registered\\n\");\n\n\t \n\tif (ec_dev->mkbp_event_supported)\n\t\tcros_ec_irq_thread(0, ec_dev);\n\n\treturn 0;\nexit:\n\tplatform_device_unregister(ec_dev->ec);\n\tplatform_device_unregister(ec_dev->pd);\n\tmutex_destroy(&ec_dev->lock);\n\tlockdep_unregister_key(&ec_dev->lockdep_key);\n\treturn err;\n}\nEXPORT_SYMBOL(cros_ec_register);\n\n \nvoid cros_ec_unregister(struct cros_ec_device *ec_dev)\n{\n\tplatform_device_unregister(ec_dev->pd);\n\tplatform_device_unregister(ec_dev->ec);\n\tmutex_destroy(&ec_dev->lock);\n\tlockdep_unregister_key(&ec_dev->lockdep_key);\n}\nEXPORT_SYMBOL(cros_ec_unregister);\n\n#ifdef CONFIG_PM_SLEEP\nstatic void cros_ec_send_suspend_event(struct cros_ec_device *ec_dev)\n{\n\tint ret;\n\tu8 sleep_event;\n\n\tsleep_event = (!IS_ENABLED(CONFIG_ACPI) || pm_suspend_via_firmware()) ?\n\t\t      HOST_SLEEP_EVENT_S3_SUSPEND :\n\t\t      HOST_SLEEP_EVENT_S0IX_SUSPEND;\n\n\tret = cros_ec_sleep_event(ec_dev, sleep_event);\n\tif (ret < 0)\n\t\tdev_dbg(ec_dev->dev, \"Error %d sending suspend event to ec\\n\",\n\t\t\tret);\n}\n\n \nint cros_ec_suspend_prepare(struct cros_ec_device *ec_dev)\n{\n\tcros_ec_send_suspend_event(ec_dev);\n\treturn 0;\n}\nEXPORT_SYMBOL(cros_ec_suspend_prepare);\n\nstatic void cros_ec_disable_irq(struct cros_ec_device *ec_dev)\n{\n\tstruct device *dev = ec_dev->dev;\n\tif (device_may_wakeup(dev))\n\t\tec_dev->wake_enabled = !enable_irq_wake(ec_dev->irq);\n\telse\n\t\tec_dev->wake_enabled = false;\n\n\tdisable_irq(ec_dev->irq);\n\tec_dev->suspended = true;\n}\n\n \nint cros_ec_suspend_late(struct cros_ec_device *ec_dev)\n{\n\tcros_ec_disable_irq(ec_dev);\n\treturn 0;\n}\nEXPORT_SYMBOL(cros_ec_suspend_late);\n\n \nint cros_ec_suspend(struct cros_ec_device *ec_dev)\n{\n\tcros_ec_send_suspend_event(ec_dev);\n\tcros_ec_disable_irq(ec_dev);\n\treturn 0;\n}\nEXPORT_SYMBOL(cros_ec_suspend);\n\nstatic void cros_ec_report_events_during_suspend(struct cros_ec_device *ec_dev)\n{\n\tbool wake_event;\n\n\twhile (ec_dev->mkbp_event_supported &&\n\t       cros_ec_get_next_event(ec_dev, &wake_event, NULL) > 0) {\n\t\tblocking_notifier_call_chain(&ec_dev->event_notifier,\n\t\t\t\t\t     1, ec_dev);\n\n\t\tif (wake_event && device_may_wakeup(ec_dev->dev))\n\t\t\tpm_wakeup_event(ec_dev->dev, 0);\n\t}\n}\n\nstatic void cros_ec_send_resume_event(struct cros_ec_device *ec_dev)\n{\n\tint ret;\n\tu8 sleep_event;\n\n\tsleep_event = (!IS_ENABLED(CONFIG_ACPI) || pm_suspend_via_firmware()) ?\n\t\t      HOST_SLEEP_EVENT_S3_RESUME :\n\t\t      HOST_SLEEP_EVENT_S0IX_RESUME;\n\n\tret = cros_ec_sleep_event(ec_dev, sleep_event);\n\tif (ret < 0)\n\t\tdev_dbg(ec_dev->dev, \"Error %d sending resume event to ec\\n\",\n\t\t\tret);\n}\n\n \nvoid cros_ec_resume_complete(struct cros_ec_device *ec_dev)\n{\n\tcros_ec_send_resume_event(ec_dev);\n}\nEXPORT_SYMBOL(cros_ec_resume_complete);\n\nstatic void cros_ec_enable_irq(struct cros_ec_device *ec_dev)\n{\n\tec_dev->suspended = false;\n\tenable_irq(ec_dev->irq);\n\n\tif (ec_dev->wake_enabled)\n\t\tdisable_irq_wake(ec_dev->irq);\n\n\t \n\tcros_ec_report_events_during_suspend(ec_dev);\n}\n\n \nint cros_ec_resume_early(struct cros_ec_device *ec_dev)\n{\n\tcros_ec_enable_irq(ec_dev);\n\treturn 0;\n}\nEXPORT_SYMBOL(cros_ec_resume_early);\n\n \nint cros_ec_resume(struct cros_ec_device *ec_dev)\n{\n\tcros_ec_enable_irq(ec_dev);\n\tcros_ec_send_resume_event(ec_dev);\n\treturn 0;\n}\nEXPORT_SYMBOL(cros_ec_resume);\n\n#endif\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"ChromeOS EC core driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}