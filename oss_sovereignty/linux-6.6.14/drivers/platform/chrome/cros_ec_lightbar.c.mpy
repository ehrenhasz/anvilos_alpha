{
  "module_name": "cros_ec_lightbar.c",
  "hash_id": "efe19105ca8d03c455b63124904663783c6851ff91cbd5749b19ed076fd303a7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/chrome/cros_ec_lightbar.c",
  "human_readable_source": "\n\n\n\n\n#include <linux/ctype.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/fs.h>\n#include <linux/kobject.h>\n#include <linux/kstrtox.h>\n#include <linux/module.h>\n#include <linux/platform_data/cros_ec_commands.h>\n#include <linux/platform_data/cros_ec_proto.h>\n#include <linux/platform_device.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n\n#define DRV_NAME \"cros-ec-lightbar\"\n\n \nstatic unsigned long lb_interval_jiffies = 50 * HZ / 1000;\n\n \nstatic bool userspace_control;\n\nstatic ssize_t interval_msec_show(struct device *dev,\n\t\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tunsigned long msec = lb_interval_jiffies * 1000 / HZ;\n\n\treturn sysfs_emit(buf, \"%lu\\n\", msec);\n}\n\nstatic ssize_t interval_msec_store(struct device *dev,\n\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t   const char *buf, size_t count)\n{\n\tunsigned long msec;\n\n\tif (kstrtoul(buf, 0, &msec))\n\t\treturn -EINVAL;\n\n\tlb_interval_jiffies = msec * HZ / 1000;\n\n\treturn count;\n}\n\nstatic DEFINE_MUTEX(lb_mutex);\n \nstatic int lb_throttle(void)\n{\n\tstatic unsigned long last_access;\n\tunsigned long now, next_timeslot;\n\tlong delay;\n\tint ret = 0;\n\n\tmutex_lock(&lb_mutex);\n\n\tnow = jiffies;\n\tnext_timeslot = last_access + lb_interval_jiffies;\n\n\tif (time_before(now, next_timeslot)) {\n\t\tdelay = (long)(next_timeslot) - (long)now;\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tif (schedule_timeout(delay) > 0) {\n\t\t\t \n\t\t\tret = -EINTR;\n\t\t\tgoto out;\n\t\t}\n\t\tnow = jiffies;\n\t}\n\n\tlast_access = now;\nout:\n\tmutex_unlock(&lb_mutex);\n\n\treturn ret;\n}\n\nstatic struct cros_ec_command *alloc_lightbar_cmd_msg(struct cros_ec_dev *ec)\n{\n\tstruct cros_ec_command *msg;\n\tint len;\n\n\tlen = max(sizeof(struct ec_params_lightbar),\n\t\t  sizeof(struct ec_response_lightbar));\n\n\tmsg = kmalloc(sizeof(*msg) + len, GFP_KERNEL);\n\tif (!msg)\n\t\treturn NULL;\n\n\tmsg->version = 0;\n\tmsg->command = EC_CMD_LIGHTBAR_CMD + ec->cmd_offset;\n\tmsg->outsize = sizeof(struct ec_params_lightbar);\n\tmsg->insize = sizeof(struct ec_response_lightbar);\n\n\treturn msg;\n}\n\nstatic int get_lightbar_version(struct cros_ec_dev *ec,\n\t\t\t\tuint32_t *ver_ptr, uint32_t *flg_ptr)\n{\n\tstruct ec_params_lightbar *param;\n\tstruct ec_response_lightbar *resp;\n\tstruct cros_ec_command *msg;\n\tint ret;\n\n\tmsg = alloc_lightbar_cmd_msg(ec);\n\tif (!msg)\n\t\treturn 0;\n\n\tparam = (struct ec_params_lightbar *)msg->data;\n\tparam->cmd = LIGHTBAR_CMD_VERSION;\n\tmsg->outsize = sizeof(param->cmd);\n\tmsg->result = sizeof(resp->version);\n\tret = cros_ec_cmd_xfer_status(ec->ec_dev, msg);\n\tif (ret < 0 && ret != -EINVAL) {\n\t\tret = 0;\n\t\tgoto exit;\n\t}\n\n\tswitch (msg->result) {\n\tcase EC_RES_INVALID_PARAM:\n\t\t \n\t\tif (ver_ptr)\n\t\t\t*ver_ptr = 0;\n\t\tif (flg_ptr)\n\t\t\t*flg_ptr = 0;\n\t\tret = 1;\n\t\tgoto exit;\n\n\tcase EC_RES_SUCCESS:\n\t\tresp = (struct ec_response_lightbar *)msg->data;\n\n\t\t \n\t\tif (ver_ptr)\n\t\t\t*ver_ptr = resp->version.num;\n\t\tif (flg_ptr)\n\t\t\t*flg_ptr = resp->version.flags;\n\t\tret = 1;\n\t\tgoto exit;\n\t}\n\n\t \n\tret = 0;\nexit:\n\tkfree(msg);\n\treturn ret;\n}\n\nstatic ssize_t version_show(struct device *dev,\n\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tuint32_t version = 0, flags = 0;\n\tstruct cros_ec_dev *ec = to_cros_ec_dev(dev);\n\tint ret;\n\n\tret = lb_throttle();\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (!get_lightbar_version(ec, &version, &flags))\n\t\treturn -EIO;\n\n\treturn sysfs_emit(buf, \"%d %d\\n\", version, flags);\n}\n\nstatic ssize_t brightness_store(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct ec_params_lightbar *param;\n\tstruct cros_ec_command *msg;\n\tint ret;\n\tunsigned int val;\n\tstruct cros_ec_dev *ec = to_cros_ec_dev(dev);\n\n\tif (kstrtouint(buf, 0, &val))\n\t\treturn -EINVAL;\n\n\tmsg = alloc_lightbar_cmd_msg(ec);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\tparam = (struct ec_params_lightbar *)msg->data;\n\tparam->cmd = LIGHTBAR_CMD_SET_BRIGHTNESS;\n\tparam->set_brightness.num = val;\n\tret = lb_throttle();\n\tif (ret)\n\t\tgoto exit;\n\n\tret = cros_ec_cmd_xfer_status(ec->ec_dev, msg);\n\tif (ret < 0)\n\t\tgoto exit;\n\n\tret = count;\nexit:\n\tkfree(msg);\n\treturn ret;\n}\n\n\n \nstatic ssize_t led_rgb_store(struct device *dev, struct device_attribute *attr,\n\t\t\t     const char *buf, size_t count)\n{\n\tstruct ec_params_lightbar *param;\n\tstruct cros_ec_command *msg;\n\tstruct cros_ec_dev *ec = to_cros_ec_dev(dev);\n\tunsigned int val[4];\n\tint ret, i = 0, j = 0, ok = 0;\n\n\tmsg = alloc_lightbar_cmd_msg(ec);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\tdo {\n\t\t \n\t\twhile (*buf && isspace(*buf))\n\t\t\tbuf++;\n\n\t\tif (!*buf)\n\t\t\tbreak;\n\n\t\tret = sscanf(buf, \"%i\", &val[i++]);\n\t\tif (ret == 0)\n\t\t\tgoto exit;\n\n\t\tif (i == 4) {\n\t\t\tparam = (struct ec_params_lightbar *)msg->data;\n\t\t\tparam->cmd = LIGHTBAR_CMD_SET_RGB;\n\t\t\tparam->set_rgb.led = val[0];\n\t\t\tparam->set_rgb.red = val[1];\n\t\t\tparam->set_rgb.green = val[2];\n\t\t\tparam->set_rgb.blue = val[3];\n\t\t\t \n\t\t\tif ((j++ % 4) == 0) {\n\t\t\t\tret = lb_throttle();\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto exit;\n\t\t\t}\n\n\t\t\tret = cros_ec_cmd_xfer_status(ec->ec_dev, msg);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto exit;\n\n\t\t\ti = 0;\n\t\t\tok = 1;\n\t\t}\n\n\t\t \n\t\twhile (*buf && !isspace(*buf))\n\t\t\tbuf++;\n\n\t} while (*buf);\n\nexit:\n\tkfree(msg);\n\treturn (ok && i == 0) ? count : -EINVAL;\n}\n\nstatic char const *seqname[] = {\n\t\"ERROR\", \"S5\", \"S3\", \"S0\", \"S5S3\", \"S3S0\",\n\t\"S0S3\", \"S3S5\", \"STOP\", \"RUN\", \"KONAMI\",\n\t\"TAP\", \"PROGRAM\",\n};\n\nstatic ssize_t sequence_show(struct device *dev,\n\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct ec_params_lightbar *param;\n\tstruct ec_response_lightbar *resp;\n\tstruct cros_ec_command *msg;\n\tint ret;\n\tstruct cros_ec_dev *ec = to_cros_ec_dev(dev);\n\n\tmsg = alloc_lightbar_cmd_msg(ec);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\tparam = (struct ec_params_lightbar *)msg->data;\n\tparam->cmd = LIGHTBAR_CMD_GET_SEQ;\n\tret = lb_throttle();\n\tif (ret)\n\t\tgoto exit;\n\n\tret = cros_ec_cmd_xfer_status(ec->ec_dev, msg);\n\tif (ret < 0) {\n\t\tret = sysfs_emit(buf, \"XFER / EC ERROR %d / %d\\n\", ret, msg->result);\n\t\tgoto exit;\n\t}\n\n\tresp = (struct ec_response_lightbar *)msg->data;\n\tif (resp->get_seq.num >= ARRAY_SIZE(seqname))\n\t\tret = sysfs_emit(buf, \"%d\\n\", resp->get_seq.num);\n\telse\n\t\tret = sysfs_emit(buf, \"%s\\n\", seqname[resp->get_seq.num]);\n\nexit:\n\tkfree(msg);\n\treturn ret;\n}\n\nstatic int lb_send_empty_cmd(struct cros_ec_dev *ec, uint8_t cmd)\n{\n\tstruct ec_params_lightbar *param;\n\tstruct cros_ec_command *msg;\n\tint ret;\n\n\tmsg = alloc_lightbar_cmd_msg(ec);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\tparam = (struct ec_params_lightbar *)msg->data;\n\tparam->cmd = cmd;\n\n\tret = lb_throttle();\n\tif (ret)\n\t\tgoto error;\n\n\tret = cros_ec_cmd_xfer_status(ec->ec_dev, msg);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tret = 0;\nerror:\n\tkfree(msg);\n\n\treturn ret;\n}\n\nstatic int lb_manual_suspend_ctrl(struct cros_ec_dev *ec, uint8_t enable)\n{\n\tstruct ec_params_lightbar *param;\n\tstruct cros_ec_command *msg;\n\tint ret;\n\n\tmsg = alloc_lightbar_cmd_msg(ec);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\tparam = (struct ec_params_lightbar *)msg->data;\n\n\tparam->cmd = LIGHTBAR_CMD_MANUAL_SUSPEND_CTRL;\n\tparam->manual_suspend_ctrl.enable = enable;\n\n\tret = lb_throttle();\n\tif (ret)\n\t\tgoto error;\n\n\tret = cros_ec_cmd_xfer_status(ec->ec_dev, msg);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tret = 0;\nerror:\n\tkfree(msg);\n\n\treturn ret;\n}\n\nstatic ssize_t sequence_store(struct device *dev, struct device_attribute *attr,\n\t\t\t      const char *buf, size_t count)\n{\n\tstruct ec_params_lightbar *param;\n\tstruct cros_ec_command *msg;\n\tunsigned int num;\n\tint ret, len;\n\tstruct cros_ec_dev *ec = to_cros_ec_dev(dev);\n\n\tfor (len = 0; len < count; len++)\n\t\tif (!isalnum(buf[len]))\n\t\t\tbreak;\n\n\tfor (num = 0; num < ARRAY_SIZE(seqname); num++)\n\t\tif (!strncasecmp(seqname[num], buf, len))\n\t\t\tbreak;\n\n\tif (num >= ARRAY_SIZE(seqname)) {\n\t\tret = kstrtouint(buf, 0, &num);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tmsg = alloc_lightbar_cmd_msg(ec);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\tparam = (struct ec_params_lightbar *)msg->data;\n\tparam->cmd = LIGHTBAR_CMD_SEQ;\n\tparam->seq.num = num;\n\tret = lb_throttle();\n\tif (ret)\n\t\tgoto exit;\n\n\tret = cros_ec_cmd_xfer_status(ec->ec_dev, msg);\n\tif (ret < 0)\n\t\tgoto exit;\n\n\tret = count;\nexit:\n\tkfree(msg);\n\treturn ret;\n}\n\nstatic ssize_t program_store(struct device *dev, struct device_attribute *attr,\n\t\t\t     const char *buf, size_t count)\n{\n\tint extra_bytes, max_size, ret;\n\tstruct ec_params_lightbar *param;\n\tstruct cros_ec_command *msg;\n\tstruct cros_ec_dev *ec = to_cros_ec_dev(dev);\n\n\t \n\textra_bytes = sizeof(*param) - sizeof(param->set_program.data);\n\tmax_size = min(EC_LB_PROG_LEN, ec->ec_dev->max_request - extra_bytes);\n\tif (count > max_size) {\n\t\tdev_err(dev, \"Program is %u bytes, too long to send (max: %u)\",\n\t\t\t(unsigned int)count, max_size);\n\n\t\treturn -EINVAL;\n\t}\n\n\tmsg = alloc_lightbar_cmd_msg(ec);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\tret = lb_throttle();\n\tif (ret)\n\t\tgoto exit;\n\n\tdev_info(dev, \"Copying %zu byte program to EC\", count);\n\n\tparam = (struct ec_params_lightbar *)msg->data;\n\tparam->cmd = LIGHTBAR_CMD_SET_PROGRAM;\n\n\tparam->set_program.size = count;\n\tmemcpy(param->set_program.data, buf, count);\n\n\t \n\tmsg->outsize = count + extra_bytes;\n\n\tret = cros_ec_cmd_xfer_status(ec->ec_dev, msg);\n\tif (ret < 0)\n\t\tgoto exit;\n\n\tret = count;\nexit:\n\tkfree(msg);\n\n\treturn ret;\n}\n\nstatic ssize_t userspace_control_show(struct device *dev,\n\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t      char *buf)\n{\n\treturn sysfs_emit(buf, \"%d\\n\", userspace_control);\n}\n\nstatic ssize_t userspace_control_store(struct device *dev,\n\t\t\t\t       struct device_attribute *attr,\n\t\t\t\t       const char *buf,\n\t\t\t\t       size_t count)\n{\n\tbool enable;\n\tint ret;\n\n\tret = kstrtobool(buf, &enable);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tuserspace_control = enable;\n\n\treturn count;\n}\n\n \n\nstatic DEVICE_ATTR_RW(interval_msec);\nstatic DEVICE_ATTR_RO(version);\nstatic DEVICE_ATTR_WO(brightness);\nstatic DEVICE_ATTR_WO(led_rgb);\nstatic DEVICE_ATTR_RW(sequence);\nstatic DEVICE_ATTR_WO(program);\nstatic DEVICE_ATTR_RW(userspace_control);\n\nstatic struct attribute *__lb_cmds_attrs[] = {\n\t&dev_attr_interval_msec.attr,\n\t&dev_attr_version.attr,\n\t&dev_attr_brightness.attr,\n\t&dev_attr_led_rgb.attr,\n\t&dev_attr_sequence.attr,\n\t&dev_attr_program.attr,\n\t&dev_attr_userspace_control.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group cros_ec_lightbar_attr_group = {\n\t.name = \"lightbar\",\n\t.attrs = __lb_cmds_attrs,\n};\n\nstatic int cros_ec_lightbar_probe(struct platform_device *pd)\n{\n\tstruct cros_ec_dev *ec_dev = dev_get_drvdata(pd->dev.parent);\n\tstruct cros_ec_platform *pdata = dev_get_platdata(ec_dev->dev);\n\tstruct device *dev = &pd->dev;\n\tint ret;\n\n\t \n\tif (strcmp(pdata->ec_name, CROS_EC_DEV_NAME) != 0)\n\t\treturn -ENODEV;\n\n\t \n\tif (!get_lightbar_version(ec_dev, NULL, NULL))\n\t\treturn -ENODEV;\n\n\t \n\tlb_manual_suspend_ctrl(ec_dev, 1);\n\n\tret = sysfs_create_group(&ec_dev->class_dev.kobj,\n\t\t\t\t &cros_ec_lightbar_attr_group);\n\tif (ret < 0)\n\t\tdev_err(dev, \"failed to create %s attributes. err=%d\\n\",\n\t\t\tcros_ec_lightbar_attr_group.name, ret);\n\n\treturn ret;\n}\n\nstatic int cros_ec_lightbar_remove(struct platform_device *pd)\n{\n\tstruct cros_ec_dev *ec_dev = dev_get_drvdata(pd->dev.parent);\n\n\tsysfs_remove_group(&ec_dev->class_dev.kobj,\n\t\t\t   &cros_ec_lightbar_attr_group);\n\n\t \n\tlb_manual_suspend_ctrl(ec_dev, 0);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused cros_ec_lightbar_resume(struct device *dev)\n{\n\tstruct cros_ec_dev *ec_dev = dev_get_drvdata(dev->parent);\n\n\tif (userspace_control)\n\t\treturn 0;\n\n\treturn lb_send_empty_cmd(ec_dev, LIGHTBAR_CMD_RESUME);\n}\n\nstatic int __maybe_unused cros_ec_lightbar_suspend(struct device *dev)\n{\n\tstruct cros_ec_dev *ec_dev = dev_get_drvdata(dev->parent);\n\n\tif (userspace_control)\n\t\treturn 0;\n\n\treturn lb_send_empty_cmd(ec_dev, LIGHTBAR_CMD_SUSPEND);\n}\n\nstatic SIMPLE_DEV_PM_OPS(cros_ec_lightbar_pm_ops,\n\t\t\t cros_ec_lightbar_suspend, cros_ec_lightbar_resume);\n\nstatic struct platform_driver cros_ec_lightbar_driver = {\n\t.driver = {\n\t\t.name = DRV_NAME,\n\t\t.pm = &cros_ec_lightbar_pm_ops,\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t},\n\t.probe = cros_ec_lightbar_probe,\n\t.remove = cros_ec_lightbar_remove,\n};\n\nmodule_platform_driver(cros_ec_lightbar_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Expose the Chromebook Pixel's lightbar to userspace\");\nMODULE_ALIAS(\"platform:\" DRV_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}