{
  "module_name": "cros_ec_lpc.c",
  "hash_id": "abfea979328557d7de0c8f6a15a2b75c676fc1c2219a07b54e5ada121d8f1592",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/chrome/cros_ec_lpc.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n\n\n\n#include <linux/acpi.h>\n#include <linux/dmi.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/interrupt.h>\n#include <linux/kobject.h>\n#include <linux/module.h>\n#include <linux/platform_data/cros_ec_commands.h>\n#include <linux/platform_data/cros_ec_proto.h>\n#include <linux/platform_device.h>\n#include <linux/printk.h>\n#include <linux/reboot.h>\n#include <linux/suspend.h>\n\n#include \"cros_ec.h\"\n#include \"cros_ec_lpc_mec.h\"\n\n#define DRV_NAME \"cros_ec_lpcs\"\n#define ACPI_DRV_NAME \"GOOG0004\"\n\n \nstatic bool cros_ec_lpc_acpi_device_found;\n\n \nstruct lpc_driver_ops {\n\tu8 (*read)(unsigned int offset, unsigned int length, u8 *dest);\n\tu8 (*write)(unsigned int offset, unsigned int length, const u8 *msg);\n};\n\nstatic struct lpc_driver_ops cros_ec_lpc_ops = { };\n\n \nstatic u8 cros_ec_lpc_read_bytes(unsigned int offset, unsigned int length,\n\t\t\t\t u8 *dest)\n{\n\tint sum = 0;\n\tint i;\n\n\tfor (i = 0; i < length; ++i) {\n\t\tdest[i] = inb(offset + i);\n\t\tsum += dest[i];\n\t}\n\n\t \n\treturn sum;\n}\n\n \nstatic u8 cros_ec_lpc_write_bytes(unsigned int offset, unsigned int length,\n\t\t\t\t  const u8 *msg)\n{\n\tint sum = 0;\n\tint i;\n\n\tfor (i = 0; i < length; ++i) {\n\t\toutb(msg[i], offset + i);\n\t\tsum += msg[i];\n\t}\n\n\t \n\treturn sum;\n}\n\n \nstatic u8 cros_ec_lpc_mec_read_bytes(unsigned int offset, unsigned int length,\n\t\t\t\t     u8 *dest)\n{\n\tint in_range = cros_ec_lpc_mec_in_range(offset, length);\n\n\tif (in_range < 0)\n\t\treturn 0;\n\n\treturn in_range ?\n\t\tcros_ec_lpc_io_bytes_mec(MEC_IO_READ,\n\t\t\t\t\t offset - EC_HOST_CMD_REGION0,\n\t\t\t\t\t length, dest) :\n\t\tcros_ec_lpc_read_bytes(offset, length, dest);\n}\n\n \nstatic u8 cros_ec_lpc_mec_write_bytes(unsigned int offset, unsigned int length,\n\t\t\t\t      const u8 *msg)\n{\n\tint in_range = cros_ec_lpc_mec_in_range(offset, length);\n\n\tif (in_range < 0)\n\t\treturn 0;\n\n\treturn in_range ?\n\t\tcros_ec_lpc_io_bytes_mec(MEC_IO_WRITE,\n\t\t\t\t\t offset - EC_HOST_CMD_REGION0,\n\t\t\t\t\t length, (u8 *)msg) :\n\t\tcros_ec_lpc_write_bytes(offset, length, msg);\n}\n\nstatic int ec_response_timed_out(void)\n{\n\tunsigned long one_second = jiffies + HZ;\n\tu8 data;\n\n\tusleep_range(200, 300);\n\tdo {\n\t\tif (!(cros_ec_lpc_ops.read(EC_LPC_ADDR_HOST_CMD, 1, &data) &\n\t\t    EC_LPC_STATUS_BUSY_MASK))\n\t\t\treturn 0;\n\t\tusleep_range(100, 200);\n\t} while (time_before(jiffies, one_second));\n\n\treturn 1;\n}\n\nstatic int cros_ec_pkt_xfer_lpc(struct cros_ec_device *ec,\n\t\t\t\tstruct cros_ec_command *msg)\n{\n\tstruct ec_host_response response;\n\tu8 sum;\n\tint ret = 0;\n\tu8 *dout;\n\n\tret = cros_ec_prepare_tx(ec, msg);\n\tif (ret < 0)\n\t\tgoto done;\n\n\t \n\tcros_ec_lpc_ops.write(EC_LPC_ADDR_HOST_PACKET, ret, ec->dout);\n\n\t \n\tsum = EC_COMMAND_PROTOCOL_3;\n\tcros_ec_lpc_ops.write(EC_LPC_ADDR_HOST_CMD, 1, &sum);\n\n\tif (ec_response_timed_out()) {\n\t\tdev_warn(ec->dev, \"EC response timed out\\n\");\n\t\tret = -EIO;\n\t\tgoto done;\n\t}\n\n\t \n\tmsg->result = cros_ec_lpc_ops.read(EC_LPC_ADDR_HOST_DATA, 1, &sum);\n\tret = cros_ec_check_result(ec, msg);\n\tif (ret)\n\t\tgoto done;\n\n\t \n\tdout = (u8 *)&response;\n\tsum = cros_ec_lpc_ops.read(EC_LPC_ADDR_HOST_PACKET, sizeof(response),\n\t\t\t\t   dout);\n\n\tmsg->result = response.result;\n\n\tif (response.data_len > msg->insize) {\n\t\tdev_err(ec->dev,\n\t\t\t\"packet too long (%d bytes, expected %d)\",\n\t\t\tresponse.data_len, msg->insize);\n\t\tret = -EMSGSIZE;\n\t\tgoto done;\n\t}\n\n\t \n\tsum += cros_ec_lpc_ops.read(EC_LPC_ADDR_HOST_PACKET +\n\t\t\t\t    sizeof(response), response.data_len,\n\t\t\t\t    msg->data);\n\n\tif (sum) {\n\t\tdev_err(ec->dev,\n\t\t\t\"bad packet checksum %02x\\n\",\n\t\t\tresponse.checksum);\n\t\tret = -EBADMSG;\n\t\tgoto done;\n\t}\n\n\t \n\tret = response.data_len;\ndone:\n\treturn ret;\n}\n\nstatic int cros_ec_cmd_xfer_lpc(struct cros_ec_device *ec,\n\t\t\t\tstruct cros_ec_command *msg)\n{\n\tstruct ec_lpc_host_args args;\n\tu8 sum;\n\tint ret = 0;\n\n\tif (msg->outsize > EC_PROTO2_MAX_PARAM_SIZE ||\n\t    msg->insize > EC_PROTO2_MAX_PARAM_SIZE) {\n\t\tdev_err(ec->dev,\n\t\t\t\"invalid buffer sizes (out %d, in %d)\\n\",\n\t\t\tmsg->outsize, msg->insize);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\targs.flags = EC_HOST_ARGS_FLAG_FROM_HOST;\n\targs.command_version = msg->version;\n\targs.data_size = msg->outsize;\n\n\t \n\tsum = msg->command + args.flags + args.command_version + args.data_size;\n\n\t \n\tsum += cros_ec_lpc_ops.write(EC_LPC_ADDR_HOST_PARAM, msg->outsize,\n\t\t\t\t     msg->data);\n\n\t \n\targs.checksum = sum;\n\tcros_ec_lpc_ops.write(EC_LPC_ADDR_HOST_ARGS, sizeof(args),\n\t\t\t      (u8 *)&args);\n\n\t \n\tsum = msg->command;\n\tcros_ec_lpc_ops.write(EC_LPC_ADDR_HOST_CMD, 1, &sum);\n\n\tif (ec_response_timed_out()) {\n\t\tdev_warn(ec->dev, \"EC response timed out\\n\");\n\t\tret = -EIO;\n\t\tgoto done;\n\t}\n\n\t \n\tmsg->result = cros_ec_lpc_ops.read(EC_LPC_ADDR_HOST_DATA, 1, &sum);\n\tret = cros_ec_check_result(ec, msg);\n\tif (ret)\n\t\tgoto done;\n\n\t \n\tcros_ec_lpc_ops.read(EC_LPC_ADDR_HOST_ARGS, sizeof(args), (u8 *)&args);\n\n\tif (args.data_size > msg->insize) {\n\t\tdev_err(ec->dev,\n\t\t\t\"packet too long (%d bytes, expected %d)\",\n\t\t\targs.data_size, msg->insize);\n\t\tret = -ENOSPC;\n\t\tgoto done;\n\t}\n\n\t \n\tsum = msg->command + args.flags + args.command_version + args.data_size;\n\n\t \n\tsum += cros_ec_lpc_ops.read(EC_LPC_ADDR_HOST_PARAM, args.data_size,\n\t\t\t\t    msg->data);\n\n\t \n\tif (args.checksum != sum) {\n\t\tdev_err(ec->dev,\n\t\t\t\"bad packet checksum, expected %02x, got %02x\\n\",\n\t\t\targs.checksum, sum);\n\t\tret = -EBADMSG;\n\t\tgoto done;\n\t}\n\n\t \n\tret = args.data_size;\ndone:\n\treturn ret;\n}\n\n \nstatic int cros_ec_lpc_readmem(struct cros_ec_device *ec, unsigned int offset,\n\t\t\t       unsigned int bytes, void *dest)\n{\n\tint i = offset;\n\tchar *s = dest;\n\tint cnt = 0;\n\n\tif (offset >= EC_MEMMAP_SIZE - bytes)\n\t\treturn -EINVAL;\n\n\t \n\tif (bytes) {\n\t\tcros_ec_lpc_ops.read(EC_LPC_ADDR_MEMMAP + offset, bytes, s);\n\t\treturn bytes;\n\t}\n\n\t \n\tfor (; i < EC_MEMMAP_SIZE; i++, s++) {\n\t\tcros_ec_lpc_ops.read(EC_LPC_ADDR_MEMMAP + i, 1, s);\n\t\tcnt++;\n\t\tif (!*s)\n\t\t\tbreak;\n\t}\n\n\treturn cnt;\n}\n\nstatic void cros_ec_lpc_acpi_notify(acpi_handle device, u32 value, void *data)\n{\n\tstatic const char *env[] = { \"ERROR=PANIC\", NULL };\n\tstruct cros_ec_device *ec_dev = data;\n\tbool ec_has_more_events;\n\tint ret;\n\n\tec_dev->last_event_time = cros_ec_get_time_ns();\n\n\tif (value == ACPI_NOTIFY_CROS_EC_PANIC) {\n\t\tdev_emerg(ec_dev->dev, \"CrOS EC Panic Reported. Shutdown is imminent!\");\n\t\tblocking_notifier_call_chain(&ec_dev->panic_notifier, 0, ec_dev);\n\t\tkobject_uevent_env(&ec_dev->dev->kobj, KOBJ_CHANGE, (char **)env);\n\t\t \n\t\thw_protection_shutdown(\"CrOS EC Panic\", -1);\n\t\t \n\t\treturn;\n\t}\n\n\tif (ec_dev->mkbp_event_supported)\n\t\tdo {\n\t\t\tret = cros_ec_get_next_event(ec_dev, NULL,\n\t\t\t\t\t\t     &ec_has_more_events);\n\t\t\tif (ret > 0)\n\t\t\t\tblocking_notifier_call_chain(\n\t\t\t\t\t\t&ec_dev->event_notifier, 0,\n\t\t\t\t\t\tec_dev);\n\t\t} while (ec_has_more_events);\n\n\tif (value == ACPI_NOTIFY_DEVICE_WAKE)\n\t\tpm_system_wakeup();\n}\n\nstatic int cros_ec_lpc_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct acpi_device *adev;\n\tacpi_status status;\n\tstruct cros_ec_device *ec_dev;\n\tu8 buf[2] = {};\n\tint irq, ret;\n\n\t \n\tif (!devm_request_region(dev, EC_HOST_CMD_REGION0,\n\t\t\t\t EC_HOST_CMD_MEC_REGION_SIZE, dev_name(dev))) {\n\t\tdev_err(dev, \"couldn't reserve MEC region\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tcros_ec_lpc_mec_init(EC_HOST_CMD_REGION0,\n\t\t\t     EC_LPC_ADDR_MEMMAP + EC_MEMMAP_SIZE);\n\n\t \n\tcros_ec_lpc_ops.read = cros_ec_lpc_mec_read_bytes;\n\tcros_ec_lpc_ops.write = cros_ec_lpc_mec_write_bytes;\n\tcros_ec_lpc_ops.read(EC_LPC_ADDR_MEMMAP + EC_MEMMAP_ID, 2, buf);\n\tif (buf[0] != 'E' || buf[1] != 'C') {\n\t\tif (!devm_request_region(dev, EC_LPC_ADDR_MEMMAP, EC_MEMMAP_SIZE,\n\t\t\t\t\t dev_name(dev))) {\n\t\t\tdev_err(dev, \"couldn't reserve memmap region\\n\");\n\t\t\treturn -EBUSY;\n\t\t}\n\n\t\t \n\t\tcros_ec_lpc_ops.read = cros_ec_lpc_read_bytes;\n\t\tcros_ec_lpc_ops.write = cros_ec_lpc_write_bytes;\n\t\tcros_ec_lpc_ops.read(EC_LPC_ADDR_MEMMAP + EC_MEMMAP_ID, 2,\n\t\t\t\t     buf);\n\t\tif (buf[0] != 'E' || buf[1] != 'C') {\n\t\t\tdev_err(dev, \"EC ID not detected\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\t \n\t\tif (!devm_request_region(dev, EC_HOST_CMD_REGION0 + EC_HOST_CMD_MEC_REGION_SIZE,\n\t\t\t\t\t EC_HOST_CMD_REGION_SIZE - EC_HOST_CMD_MEC_REGION_SIZE,\n\t\t\t\t\t dev_name(dev))) {\n\t\t\tdev_err(dev, \"couldn't reserve remainder of region0\\n\");\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tif (!devm_request_region(dev, EC_HOST_CMD_REGION1,\n\t\t\t\t\t EC_HOST_CMD_REGION_SIZE, dev_name(dev))) {\n\t\t\tdev_err(dev, \"couldn't reserve region1\\n\");\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\n\tec_dev = devm_kzalloc(dev, sizeof(*ec_dev), GFP_KERNEL);\n\tif (!ec_dev)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, ec_dev);\n\tec_dev->dev = dev;\n\tec_dev->phys_name = dev_name(dev);\n\tec_dev->cmd_xfer = cros_ec_cmd_xfer_lpc;\n\tec_dev->pkt_xfer = cros_ec_pkt_xfer_lpc;\n\tec_dev->cmd_readmem = cros_ec_lpc_readmem;\n\tec_dev->din_size = sizeof(struct ec_host_response) +\n\t\t\t   sizeof(struct ec_response_get_protocol_info);\n\tec_dev->dout_size = sizeof(struct ec_host_request);\n\n\t \n\tirq = platform_get_irq_optional(pdev, 0);\n\tif (irq > 0)\n\t\tec_dev->irq = irq;\n\telse if (irq != -ENXIO) {\n\t\tdev_err(dev, \"couldn't retrieve IRQ number (%d)\\n\", irq);\n\t\treturn irq;\n\t}\n\n\tret = cros_ec_register(ec_dev);\n\tif (ret) {\n\t\tdev_err(dev, \"couldn't register ec_dev (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tadev = ACPI_COMPANION(dev);\n\tif (adev) {\n\t\tstatus = acpi_install_notify_handler(adev->handle,\n\t\t\t\t\t\t     ACPI_ALL_NOTIFY,\n\t\t\t\t\t\t     cros_ec_lpc_acpi_notify,\n\t\t\t\t\t\t     ec_dev);\n\t\tif (ACPI_FAILURE(status))\n\t\t\tdev_warn(dev, \"Failed to register notifier %08x\\n\",\n\t\t\t\t status);\n\t}\n\n\treturn 0;\n}\n\nstatic int cros_ec_lpc_remove(struct platform_device *pdev)\n{\n\tstruct cros_ec_device *ec_dev = platform_get_drvdata(pdev);\n\tstruct acpi_device *adev;\n\n\tadev = ACPI_COMPANION(&pdev->dev);\n\tif (adev)\n\t\tacpi_remove_notify_handler(adev->handle, ACPI_ALL_NOTIFY,\n\t\t\t\t\t   cros_ec_lpc_acpi_notify);\n\n\tcros_ec_unregister(ec_dev);\n\n\treturn 0;\n}\n\nstatic const struct acpi_device_id cros_ec_lpc_acpi_device_ids[] = {\n\t{ ACPI_DRV_NAME, 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(acpi, cros_ec_lpc_acpi_device_ids);\n\nstatic const struct dmi_system_id cros_ec_lpc_dmi_table[] __initconst = {\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BIOS_VENDOR, \"coreboot\"),\n\t\t\tDMI_MATCH(DMI_BIOS_VERSION, \"Google_\"),\n\t\t},\n\t},\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BIOS_VENDOR, \"coreboot\"),\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"GOOGLE\"),\n\t\t},\n\t},\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"GOOGLE\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Link\"),\n\t\t},\n\t},\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"GOOGLE\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Samus\"),\n\t\t},\n\t},\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Acer\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Peppy\"),\n\t\t},\n\t},\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"GOOGLE\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Glimmer\"),\n\t\t},\n\t},\n\t \n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Framework\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Laptop\"),\n\t\t},\n\t},\n\t{   }\n};\nMODULE_DEVICE_TABLE(dmi, cros_ec_lpc_dmi_table);\n\n#ifdef CONFIG_PM_SLEEP\nstatic int cros_ec_lpc_prepare(struct device *dev)\n{\n\tstruct cros_ec_device *ec_dev = dev_get_drvdata(dev);\n\treturn cros_ec_suspend_prepare(ec_dev);\n}\n\nstatic void cros_ec_lpc_complete(struct device *dev)\n{\n\tstruct cros_ec_device *ec_dev = dev_get_drvdata(dev);\n\tcros_ec_resume_complete(ec_dev);\n}\n\nstatic int cros_ec_lpc_suspend_late(struct device *dev)\n{\n\tstruct cros_ec_device *ec_dev = dev_get_drvdata(dev);\n\n\treturn cros_ec_suspend_late(ec_dev);\n}\n\nstatic int cros_ec_lpc_resume_early(struct device *dev)\n{\n\tstruct cros_ec_device *ec_dev = dev_get_drvdata(dev);\n\n\treturn cros_ec_resume_early(ec_dev);\n}\n#endif\n\nstatic const struct dev_pm_ops cros_ec_lpc_pm_ops = {\n#ifdef CONFIG_PM_SLEEP\n\t.prepare = cros_ec_lpc_prepare,\n\t.complete = cros_ec_lpc_complete,\n#endif\n\tSET_LATE_SYSTEM_SLEEP_PM_OPS(cros_ec_lpc_suspend_late, cros_ec_lpc_resume_early)\n};\n\nstatic struct platform_driver cros_ec_lpc_driver = {\n\t.driver = {\n\t\t.name = DRV_NAME,\n\t\t.acpi_match_table = cros_ec_lpc_acpi_device_ids,\n\t\t.pm = &cros_ec_lpc_pm_ops,\n\t\t \n\t\t.probe_type = PROBE_FORCE_SYNCHRONOUS,\n\t},\n\t.probe = cros_ec_lpc_probe,\n\t.remove = cros_ec_lpc_remove,\n};\n\nstatic struct platform_device cros_ec_lpc_device = {\n\t.name = DRV_NAME\n};\n\nstatic acpi_status cros_ec_lpc_parse_device(acpi_handle handle, u32 level,\n\t\t\t\t\t    void *context, void **retval)\n{\n\t*(bool *)context = true;\n\treturn AE_CTRL_TERMINATE;\n}\n\nstatic int __init cros_ec_lpc_init(void)\n{\n\tint ret;\n\tacpi_status status;\n\n\tstatus = acpi_get_devices(ACPI_DRV_NAME, cros_ec_lpc_parse_device,\n\t\t\t\t  &cros_ec_lpc_acpi_device_found, NULL);\n\tif (ACPI_FAILURE(status))\n\t\tpr_warn(DRV_NAME \": Looking for %s failed\\n\", ACPI_DRV_NAME);\n\n\tif (!cros_ec_lpc_acpi_device_found &&\n\t    !dmi_check_system(cros_ec_lpc_dmi_table)) {\n\t\tpr_err(DRV_NAME \": unsupported system.\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tret = platform_driver_register(&cros_ec_lpc_driver);\n\tif (ret) {\n\t\tpr_err(DRV_NAME \": can't register driver: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (!cros_ec_lpc_acpi_device_found) {\n\t\t \n\t\tret = platform_device_register(&cros_ec_lpc_device);\n\t\tif (ret) {\n\t\t\tpr_err(DRV_NAME \": can't register device: %d\\n\", ret);\n\t\t\tplatform_driver_unregister(&cros_ec_lpc_driver);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic void __exit cros_ec_lpc_exit(void)\n{\n\tif (!cros_ec_lpc_acpi_device_found)\n\t\tplatform_device_unregister(&cros_ec_lpc_device);\n\tplatform_driver_unregister(&cros_ec_lpc_driver);\n}\n\nmodule_init(cros_ec_lpc_init);\nmodule_exit(cros_ec_lpc_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"ChromeOS EC LPC driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}