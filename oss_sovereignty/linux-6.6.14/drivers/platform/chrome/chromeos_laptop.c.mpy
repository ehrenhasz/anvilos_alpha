{
  "module_name": "chromeos_laptop.c",
  "hash_id": "28e73b2352f99d02ca351f43b66512f4006eb1394d9265c7a0159226eb227d9c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/chrome/chromeos_laptop.c",
  "human_readable_source": "\n\n\n\n\n\n#define pr_fmt(fmt)\t\tKBUILD_MODNAME \": \" fmt\n\n#include <linux/acpi.h>\n#include <linux/dmi.h>\n#include <linux/i2c.h>\n#include <linux/input.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/platform_device.h>\n#include <linux/property.h>\n\n#define ATMEL_TP_I2C_ADDR\t0x4b\n#define ATMEL_TP_I2C_BL_ADDR\t0x25\n#define ATMEL_TS_I2C_ADDR\t0x4a\n#define ATMEL_TS_I2C_BL_ADDR\t0x26\n#define CYAPA_TP_I2C_ADDR\t0x67\n#define ELAN_TP_I2C_ADDR\t0x15\n#define ISL_ALS_I2C_ADDR\t0x44\n#define TAOS_ALS_I2C_ADDR\t0x29\n\nstatic const char *i2c_adapter_names[] = {\n\t\"SMBus I801 adapter\",\n\t\"i915 gmbus vga\",\n\t\"i915 gmbus panel\",\n\t\"Synopsys DesignWare I2C adapter\",\n};\n\n \nenum i2c_adapter_type {\n\tI2C_ADAPTER_SMBUS = 0,\n\tI2C_ADAPTER_VGADDC,\n\tI2C_ADAPTER_PANEL,\n\tI2C_ADAPTER_DESIGNWARE,\n};\n\nstruct i2c_peripheral {\n\tstruct i2c_board_info board_info;\n\tunsigned short alt_addr;\n\n\tconst char *dmi_name;\n\tunsigned long irqflags;\n\tstruct resource irq_resource;\n\n\tenum i2c_adapter_type type;\n\tu32 pci_devid;\n\n\tconst struct property_entry *properties;\n\n\tstruct i2c_client *client;\n};\n\nstruct acpi_peripheral {\n\tchar hid[ACPI_ID_LEN];\n\tstruct software_node swnode;\n\tstruct i2c_client *client;\n};\n\nstruct chromeos_laptop {\n\t \n\tstruct i2c_peripheral *i2c_peripherals;\n\tunsigned int num_i2c_peripherals;\n\n\tstruct acpi_peripheral *acpi_peripherals;\n\tunsigned int num_acpi_peripherals;\n};\n\nstatic const struct chromeos_laptop *cros_laptop;\n\nstatic struct i2c_client *\nchromes_laptop_instantiate_i2c_device(struct i2c_adapter *adapter,\n\t\t\t\t      struct i2c_board_info *info,\n\t\t\t\t      unsigned short alt_addr)\n{\n\tconst unsigned short addr_list[] = { info->addr, I2C_CLIENT_END };\n\tstruct i2c_client *client;\n\n\t \n\tclient = i2c_new_scanned_device(adapter, info, addr_list, NULL);\n\tif (IS_ERR(client) && alt_addr) {\n\t\tstruct i2c_board_info dummy_info = {\n\t\t\tI2C_BOARD_INFO(\"dummy\", info->addr),\n\t\t};\n\t\tconst unsigned short alt_addr_list[] = {\n\t\t\talt_addr, I2C_CLIENT_END\n\t\t};\n\t\tstruct i2c_client *dummy;\n\n\t\tdummy = i2c_new_scanned_device(adapter, &dummy_info,\n\t\t\t\t\t       alt_addr_list, NULL);\n\t\tif (!IS_ERR(dummy)) {\n\t\t\tpr_debug(\"%d-%02x is probed at %02x\\n\",\n\t\t\t\t adapter->nr, info->addr, dummy->addr);\n\t\t\ti2c_unregister_device(dummy);\n\t\t\tclient = i2c_new_client_device(adapter, info);\n\t\t}\n\t}\n\n\tif (IS_ERR(client)) {\n\t\tclient = NULL;\n\t\tpr_debug(\"failed to register device %d-%02x\\n\",\n\t\t\t adapter->nr, info->addr);\n\t} else {\n\t\tpr_debug(\"added i2c device %d-%02x\\n\",\n\t\t\t adapter->nr, info->addr);\n\t}\n\n\treturn client;\n}\n\nstatic bool chromeos_laptop_match_adapter_devid(struct device *dev, u32 devid)\n{\n\tstruct pci_dev *pdev;\n\n\tif (!dev_is_pci(dev))\n\t\treturn false;\n\n\tpdev = to_pci_dev(dev);\n\treturn devid == pci_dev_id(pdev);\n}\n\nstatic void chromeos_laptop_check_adapter(struct i2c_adapter *adapter)\n{\n\tstruct i2c_peripheral *i2c_dev;\n\tint i;\n\n\tfor (i = 0; i < cros_laptop->num_i2c_peripherals; i++) {\n\t\ti2c_dev = &cros_laptop->i2c_peripherals[i];\n\n\t\t \n\t\tif (i2c_dev->client)\n\t\t\tcontinue;\n\n\t\tif (strncmp(adapter->name, i2c_adapter_names[i2c_dev->type],\n\t\t\t    strlen(i2c_adapter_names[i2c_dev->type])))\n\t\t\tcontinue;\n\n\t\tif (i2c_dev->pci_devid &&\n\t\t    !chromeos_laptop_match_adapter_devid(adapter->dev.parent,\n\t\t\t\t\t\t\t i2c_dev->pci_devid)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\ti2c_dev->client =\n\t\t\tchromes_laptop_instantiate_i2c_device(adapter,\n\t\t\t\t\t\t\t&i2c_dev->board_info,\n\t\t\t\t\t\t\ti2c_dev->alt_addr);\n\t}\n}\n\nstatic bool chromeos_laptop_adjust_client(struct i2c_client *client)\n{\n\tstruct acpi_peripheral *acpi_dev;\n\tstruct acpi_device_id acpi_ids[2] = { };\n\tint i;\n\tint error;\n\n\tif (!has_acpi_companion(&client->dev))\n\t\treturn false;\n\n\tfor (i = 0; i < cros_laptop->num_acpi_peripherals; i++) {\n\t\tacpi_dev = &cros_laptop->acpi_peripherals[i];\n\n\t\tmemcpy(acpi_ids[0].id, acpi_dev->hid, ACPI_ID_LEN);\n\n\t\tif (acpi_match_device(acpi_ids, &client->dev)) {\n\t\t\terror = device_add_software_node(&client->dev, &acpi_dev->swnode);\n\t\t\tif (error) {\n\t\t\t\tdev_err(&client->dev,\n\t\t\t\t\t\"failed to add properties: %d\\n\",\n\t\t\t\t\terror);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tacpi_dev->client = client;\n\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nstatic void chromeos_laptop_detach_i2c_client(struct i2c_client *client)\n{\n\tstruct acpi_peripheral *acpi_dev;\n\tstruct i2c_peripheral *i2c_dev;\n\tint i;\n\n\tif (has_acpi_companion(&client->dev))\n\t\tfor (i = 0; i < cros_laptop->num_acpi_peripherals; i++) {\n\t\t\tacpi_dev = &cros_laptop->acpi_peripherals[i];\n\n\t\t\tif (acpi_dev->client == client) {\n\t\t\t\tacpi_dev->client = NULL;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\telse\n\t\tfor (i = 0; i < cros_laptop->num_i2c_peripherals; i++) {\n\t\t\ti2c_dev = &cros_laptop->i2c_peripherals[i];\n\n\t\t\tif (i2c_dev->client == client) {\n\t\t\t\ti2c_dev->client = NULL;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n}\n\nstatic int chromeos_laptop_i2c_notifier_call(struct notifier_block *nb,\n\t\t\t\t\t     unsigned long action, void *data)\n{\n\tstruct device *dev = data;\n\n\tswitch (action) {\n\tcase BUS_NOTIFY_ADD_DEVICE:\n\t\tif (dev->type == &i2c_adapter_type)\n\t\t\tchromeos_laptop_check_adapter(to_i2c_adapter(dev));\n\t\telse if (dev->type == &i2c_client_type)\n\t\t\tchromeos_laptop_adjust_client(to_i2c_client(dev));\n\t\tbreak;\n\n\tcase BUS_NOTIFY_REMOVED_DEVICE:\n\t\tif (dev->type == &i2c_client_type)\n\t\t\tchromeos_laptop_detach_i2c_client(to_i2c_client(dev));\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic struct notifier_block chromeos_laptop_i2c_notifier = {\n\t.notifier_call = chromeos_laptop_i2c_notifier_call,\n};\n\n#define DECLARE_CROS_LAPTOP(_name)\t\t\t\t\t\\\nstatic const struct chromeos_laptop _name __initconst = {\t\t\\\n\t.i2c_peripherals\t= _name##_peripherals,\t\t\t\\\n\t.num_i2c_peripherals\t= ARRAY_SIZE(_name##_peripherals),\t\\\n}\n\n#define DECLARE_ACPI_CROS_LAPTOP(_name)\t\t\t\t\t\\\nstatic const struct chromeos_laptop _name __initconst = {\t\t\\\n\t.acpi_peripherals\t= _name##_peripherals,\t\t\t\\\n\t.num_acpi_peripherals\t= ARRAY_SIZE(_name##_peripherals),\t\\\n}\n\nstatic struct i2c_peripheral samsung_series_5_550_peripherals[] __initdata = {\n\t \n\t{\n\t\t.board_info\t= {\n\t\t\tI2C_BOARD_INFO(\"cyapa\", CYAPA_TP_I2C_ADDR),\n\t\t\t.flags\t\t= I2C_CLIENT_WAKE,\n\t\t},\n\t\t.dmi_name\t= \"trackpad\",\n\t\t.type\t\t= I2C_ADAPTER_SMBUS,\n\t},\n\t \n\t{\n\t\t.board_info\t= {\n\t\t\tI2C_BOARD_INFO(\"isl29018\", ISL_ALS_I2C_ADDR),\n\t\t},\n\t\t.dmi_name\t= \"lightsensor\",\n\t\t.type\t\t= I2C_ADAPTER_SMBUS,\n\t},\n};\nDECLARE_CROS_LAPTOP(samsung_series_5_550);\n\nstatic struct i2c_peripheral samsung_series_5_peripherals[] __initdata = {\n\t \n\t{\n\t\t.board_info\t= {\n\t\t\tI2C_BOARD_INFO(\"tsl2583\", TAOS_ALS_I2C_ADDR),\n\t\t},\n\t\t.type\t\t= I2C_ADAPTER_SMBUS,\n\t},\n};\nDECLARE_CROS_LAPTOP(samsung_series_5);\n\nstatic const int chromebook_pixel_tp_keys[] __initconst = {\n\tKEY_RESERVED,\n\tKEY_RESERVED,\n\tKEY_RESERVED,\n\tKEY_RESERVED,\n\tKEY_RESERVED,\n\tBTN_LEFT\n};\n\nstatic const struct property_entry\nchromebook_pixel_trackpad_props[] __initconst = {\n\tPROPERTY_ENTRY_STRING(\"compatible\", \"atmel,maxtouch\"),\n\tPROPERTY_ENTRY_U32_ARRAY(\"linux,gpio-keymap\", chromebook_pixel_tp_keys),\n\t{ }\n};\n\nstatic const struct property_entry\nchromebook_atmel_touchscreen_props[] __initconst = {\n\tPROPERTY_ENTRY_STRING(\"compatible\", \"atmel,maxtouch\"),\n\t{ }\n};\n\nstatic struct i2c_peripheral chromebook_pixel_peripherals[] __initdata = {\n\t \n\t{\n\t\t.board_info\t= {\n\t\t\tI2C_BOARD_INFO(\"atmel_mxt_ts\",\n\t\t\t\t\tATMEL_TS_I2C_ADDR),\n\t\t\t.flags\t\t= I2C_CLIENT_WAKE,\n\t\t},\n\t\t.dmi_name\t= \"touchscreen\",\n\t\t.irqflags\t= IRQF_TRIGGER_FALLING,\n\t\t.type\t\t= I2C_ADAPTER_PANEL,\n\t\t.alt_addr\t= ATMEL_TS_I2C_BL_ADDR,\n\t\t.properties\t= chromebook_atmel_touchscreen_props,\n\t},\n\t \n\t{\n\t\t.board_info\t= {\n\t\t\tI2C_BOARD_INFO(\"atmel_mxt_tp\",\n\t\t\t\t\tATMEL_TP_I2C_ADDR),\n\t\t\t.flags\t\t= I2C_CLIENT_WAKE,\n\t\t},\n\t\t.dmi_name\t= \"trackpad\",\n\t\t.irqflags\t= IRQF_TRIGGER_FALLING,\n\t\t.type\t\t= I2C_ADAPTER_VGADDC,\n\t\t.alt_addr\t= ATMEL_TP_I2C_BL_ADDR,\n\t\t.properties\t= chromebook_pixel_trackpad_props,\n\t},\n\t \n\t{\n\t\t.board_info\t= {\n\t\t\tI2C_BOARD_INFO(\"isl29018\", ISL_ALS_I2C_ADDR),\n\t\t},\n\t\t.dmi_name\t= \"lightsensor\",\n\t\t.type\t\t= I2C_ADAPTER_PANEL,\n\t},\n};\nDECLARE_CROS_LAPTOP(chromebook_pixel);\n\nstatic struct i2c_peripheral hp_chromebook_14_peripherals[] __initdata = {\n\t \n\t{\n\t\t.board_info\t= {\n\t\t\tI2C_BOARD_INFO(\"cyapa\", CYAPA_TP_I2C_ADDR),\n\t\t\t.flags\t\t= I2C_CLIENT_WAKE,\n\t\t},\n\t\t.dmi_name\t= \"trackpad\",\n\t\t.type\t\t= I2C_ADAPTER_DESIGNWARE,\n\t},\n};\nDECLARE_CROS_LAPTOP(hp_chromebook_14);\n\nstatic struct i2c_peripheral dell_chromebook_11_peripherals[] __initdata = {\n\t \n\t{\n\t\t.board_info\t= {\n\t\t\tI2C_BOARD_INFO(\"cyapa\", CYAPA_TP_I2C_ADDR),\n\t\t\t.flags\t\t= I2C_CLIENT_WAKE,\n\t\t},\n\t\t.dmi_name\t= \"trackpad\",\n\t\t.type\t\t= I2C_ADAPTER_DESIGNWARE,\n\t},\n\t \n\t{\n\t\t.board_info\t= {\n\t\t\tI2C_BOARD_INFO(\"elan_i2c\", ELAN_TP_I2C_ADDR),\n\t\t\t.flags\t\t= I2C_CLIENT_WAKE,\n\t\t},\n\t\t.dmi_name\t= \"trackpad\",\n\t\t.type\t\t= I2C_ADAPTER_DESIGNWARE,\n\t},\n};\nDECLARE_CROS_LAPTOP(dell_chromebook_11);\n\nstatic struct i2c_peripheral toshiba_cb35_peripherals[] __initdata = {\n\t \n\t{\n\t\t.board_info\t= {\n\t\t\tI2C_BOARD_INFO(\"cyapa\", CYAPA_TP_I2C_ADDR),\n\t\t\t.flags\t\t= I2C_CLIENT_WAKE,\n\t\t},\n\t\t.dmi_name\t= \"trackpad\",\n\t\t.type\t\t= I2C_ADAPTER_DESIGNWARE,\n\t},\n};\nDECLARE_CROS_LAPTOP(toshiba_cb35);\n\nstatic struct i2c_peripheral acer_c7_chromebook_peripherals[] __initdata = {\n\t \n\t{\n\t\t.board_info\t= {\n\t\t\tI2C_BOARD_INFO(\"cyapa\", CYAPA_TP_I2C_ADDR),\n\t\t\t.flags\t\t= I2C_CLIENT_WAKE,\n\t\t},\n\t\t.dmi_name\t= \"trackpad\",\n\t\t.type\t\t= I2C_ADAPTER_SMBUS,\n\t},\n};\nDECLARE_CROS_LAPTOP(acer_c7_chromebook);\n\nstatic struct i2c_peripheral acer_ac700_peripherals[] __initdata = {\n\t \n\t{\n\t\t.board_info\t= {\n\t\t\tI2C_BOARD_INFO(\"tsl2583\", TAOS_ALS_I2C_ADDR),\n\t\t},\n\t\t.type\t\t= I2C_ADAPTER_SMBUS,\n\t},\n};\nDECLARE_CROS_LAPTOP(acer_ac700);\n\nstatic struct i2c_peripheral acer_c720_peripherals[] __initdata = {\n\t \n\t{\n\t\t.board_info\t= {\n\t\t\tI2C_BOARD_INFO(\"atmel_mxt_ts\",\n\t\t\t\t\tATMEL_TS_I2C_ADDR),\n\t\t\t.flags\t\t= I2C_CLIENT_WAKE,\n\t\t},\n\t\t.dmi_name\t= \"touchscreen\",\n\t\t.irqflags\t= IRQF_TRIGGER_FALLING,\n\t\t.type\t\t= I2C_ADAPTER_DESIGNWARE,\n\t\t.pci_devid\t= PCI_DEVID(0, PCI_DEVFN(0x15, 0x2)),\n\t\t.alt_addr\t= ATMEL_TS_I2C_BL_ADDR,\n\t\t.properties\t= chromebook_atmel_touchscreen_props,\n\t},\n\t \n\t{\n\t\t.board_info\t= {\n\t\t\tI2C_BOARD_INFO(\"cyapa\", CYAPA_TP_I2C_ADDR),\n\t\t\t.flags\t\t= I2C_CLIENT_WAKE,\n\t\t},\n\t\t.dmi_name\t= \"trackpad\",\n\t\t.type\t\t= I2C_ADAPTER_DESIGNWARE,\n\t\t.pci_devid\t= PCI_DEVID(0, PCI_DEVFN(0x15, 0x1)),\n\t},\n\t \n\t{\n\t\t.board_info\t= {\n\t\t\tI2C_BOARD_INFO(\"elan_i2c\", ELAN_TP_I2C_ADDR),\n\t\t\t.flags\t\t= I2C_CLIENT_WAKE,\n\t\t},\n\t\t.dmi_name\t= \"trackpad\",\n\t\t.type\t\t= I2C_ADAPTER_DESIGNWARE,\n\t\t.pci_devid\t= PCI_DEVID(0, PCI_DEVFN(0x15, 0x1)),\n\t},\n\t \n\t{\n\t\t.board_info\t= {\n\t\t\tI2C_BOARD_INFO(\"isl29018\", ISL_ALS_I2C_ADDR),\n\t\t},\n\t\t.dmi_name\t= \"lightsensor\",\n\t\t.type\t\t= I2C_ADAPTER_DESIGNWARE,\n\t\t.pci_devid\t= PCI_DEVID(0, PCI_DEVFN(0x15, 0x2)),\n\t},\n};\nDECLARE_CROS_LAPTOP(acer_c720);\n\nstatic struct i2c_peripheral\nhp_pavilion_14_chromebook_peripherals[] __initdata = {\n\t \n\t{\n\t\t.board_info\t= {\n\t\t\tI2C_BOARD_INFO(\"cyapa\", CYAPA_TP_I2C_ADDR),\n\t\t\t.flags\t\t= I2C_CLIENT_WAKE,\n\t\t},\n\t\t.dmi_name\t= \"trackpad\",\n\t\t.type\t\t= I2C_ADAPTER_SMBUS,\n\t},\n};\nDECLARE_CROS_LAPTOP(hp_pavilion_14_chromebook);\n\nstatic struct i2c_peripheral cr48_peripherals[] __initdata = {\n\t \n\t{\n\t\t.board_info\t= {\n\t\t\tI2C_BOARD_INFO(\"tsl2563\", TAOS_ALS_I2C_ADDR),\n\t\t},\n\t\t.type\t\t= I2C_ADAPTER_SMBUS,\n\t},\n};\nDECLARE_CROS_LAPTOP(cr48);\n\nstatic const u32 samus_touchpad_buttons[] __initconst = {\n\tKEY_RESERVED,\n\tKEY_RESERVED,\n\tKEY_RESERVED,\n\tBTN_LEFT\n};\n\nstatic const struct property_entry samus_trackpad_props[] __initconst = {\n\tPROPERTY_ENTRY_STRING(\"compatible\", \"atmel,maxtouch\"),\n\tPROPERTY_ENTRY_U32_ARRAY(\"linux,gpio-keymap\", samus_touchpad_buttons),\n\t{ }\n};\n\nstatic struct acpi_peripheral samus_peripherals[] __initdata = {\n\t \n\t{\n\t\t.hid\t\t= \"ATML0000\",\n\t\t.swnode\t\t= {\n\t\t\t.properties = samus_trackpad_props,\n\t\t},\n\t},\n\t \n\t{\n\t\t.hid\t\t= \"ATML0001\",\n\t\t.swnode\t\t= {\n\t\t\t.properties = chromebook_atmel_touchscreen_props,\n\t\t},\n\t},\n};\nDECLARE_ACPI_CROS_LAPTOP(samus);\n\nstatic struct acpi_peripheral generic_atmel_peripherals[] __initdata = {\n\t \n\t{\n\t\t.hid\t\t= \"ATML0000\",\n\t\t.swnode\t\t= {\n\t\t\t.properties = chromebook_pixel_trackpad_props,\n\t\t},\n\t},\n\t \n\t{\n\t\t.hid\t\t= \"ATML0001\",\n\t\t.swnode\t\t= {\n\t\t\t.properties = chromebook_atmel_touchscreen_props,\n\t\t},\n\t},\n};\nDECLARE_ACPI_CROS_LAPTOP(generic_atmel);\n\nstatic const struct dmi_system_id chromeos_laptop_dmi_table[] __initconst = {\n\t{\n\t\t.ident = \"Samsung Series 5 550\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"SAMSUNG\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Lumpy\"),\n\t\t},\n\t\t.driver_data = (void *)&samsung_series_5_550,\n\t},\n\t{\n\t\t.ident = \"Samsung Series 5\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Alex\"),\n\t\t},\n\t\t.driver_data = (void *)&samsung_series_5,\n\t},\n\t{\n\t\t.ident = \"Chromebook Pixel\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"GOOGLE\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Link\"),\n\t\t},\n\t\t.driver_data = (void *)&chromebook_pixel,\n\t},\n\t{\n\t\t.ident = \"Wolf\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BIOS_VENDOR, \"coreboot\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Wolf\"),\n\t\t},\n\t\t.driver_data = (void *)&dell_chromebook_11,\n\t},\n\t{\n\t\t.ident = \"HP Chromebook 14\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BIOS_VENDOR, \"coreboot\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Falco\"),\n\t\t},\n\t\t.driver_data = (void *)&hp_chromebook_14,\n\t},\n\t{\n\t\t.ident = \"Toshiba CB35\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BIOS_VENDOR, \"coreboot\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Leon\"),\n\t\t},\n\t\t.driver_data = (void *)&toshiba_cb35,\n\t},\n\t{\n\t\t.ident = \"Acer C7 Chromebook\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Parrot\"),\n\t\t},\n\t\t.driver_data = (void *)&acer_c7_chromebook,\n\t},\n\t{\n\t\t.ident = \"Acer AC700\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"ZGB\"),\n\t\t},\n\t\t.driver_data = (void *)&acer_ac700,\n\t},\n\t{\n\t\t.ident = \"Acer C720\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Peppy\"),\n\t\t},\n\t\t.driver_data = (void *)&acer_c720,\n\t},\n\t{\n\t\t.ident = \"HP Pavilion 14 Chromebook\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Butterfly\"),\n\t\t},\n\t\t.driver_data = (void *)&hp_pavilion_14_chromebook,\n\t},\n\t{\n\t\t.ident = \"Cr-48\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Mario\"),\n\t\t},\n\t\t.driver_data = (void *)&cr48,\n\t},\n\t \n\t{\n\t\t.ident = \"Chromebook Pro\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Google\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Caroline\"),\n\t\t},\n\t\t.driver_data = (void *)&samus,\n\t},\n\t{\n\t\t.ident = \"Google Pixel 2 (2015)\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"GOOGLE\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Samus\"),\n\t\t},\n\t\t.driver_data = (void *)&samus,\n\t},\n\t{\n\t\t.ident = \"Samsung Chromebook 3\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"GOOGLE\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Celes\"),\n\t\t},\n\t\t.driver_data = (void *)&samus,\n\t},\n\t{\n\t\t \n\t\t.ident = \"Other Chromebook\",\n\t\t.matches = {\n\t\t\t \n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"GOOGLE\"),\n\t\t},\n\t\t.driver_data = (void *)&generic_atmel,\n\t},\n\t{ }\n};\nMODULE_DEVICE_TABLE(dmi, chromeos_laptop_dmi_table);\n\nstatic int __init chromeos_laptop_scan_peripherals(struct device *dev, void *data)\n{\n\tint error;\n\n\tif (dev->type == &i2c_adapter_type) {\n\t\tchromeos_laptop_check_adapter(to_i2c_adapter(dev));\n\t} else if (dev->type == &i2c_client_type) {\n\t\tif (chromeos_laptop_adjust_client(to_i2c_client(dev))) {\n\t\t\t \n\t\t\terror = device_attach(dev);\n\t\t\tif (error < 0)\n\t\t\t\tdev_warn(dev,\n\t\t\t\t\t \"%s: device_attach() failed: %d\\n\",\n\t\t\t\t\t __func__, error);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int __init chromeos_laptop_get_irq_from_dmi(const char *dmi_name)\n{\n\tconst struct dmi_device *dmi_dev;\n\tconst struct dmi_dev_onboard *dev_data;\n\n\tdmi_dev = dmi_find_device(DMI_DEV_TYPE_DEV_ONBOARD, dmi_name, NULL);\n\tif (!dmi_dev) {\n\t\tpr_err(\"failed to find DMI device '%s'\\n\", dmi_name);\n\t\treturn -ENOENT;\n\t}\n\n\tdev_data = dmi_dev->device_data;\n\tif (!dev_data) {\n\t\tpr_err(\"failed to get data from DMI for '%s'\\n\", dmi_name);\n\t\treturn -EINVAL;\n\t}\n\n\treturn dev_data->instance;\n}\n\nstatic int __init chromeos_laptop_setup_irq(struct i2c_peripheral *i2c_dev)\n{\n\tint irq;\n\n\tif (i2c_dev->dmi_name) {\n\t\tirq = chromeos_laptop_get_irq_from_dmi(i2c_dev->dmi_name);\n\t\tif (irq < 0)\n\t\t\treturn irq;\n\n\t\ti2c_dev->irq_resource  = (struct resource)\n\t\t\tDEFINE_RES_NAMED(irq, 1, NULL,\n\t\t\t\t\t IORESOURCE_IRQ | i2c_dev->irqflags);\n\t\ti2c_dev->board_info.resources = &i2c_dev->irq_resource;\n\t\ti2c_dev->board_info.num_resources = 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int __init\nchromeos_laptop_prepare_i2c_peripherals(struct chromeos_laptop *cros_laptop,\n\t\t\t\t\tconst struct chromeos_laptop *src)\n{\n\tstruct i2c_peripheral *i2c_peripherals;\n\tstruct i2c_peripheral *i2c_dev;\n\tstruct i2c_board_info *info;\n\tint i;\n\tint error;\n\n\tif (!src->num_i2c_peripherals)\n\t\treturn 0;\n\n\ti2c_peripherals = kmemdup(src->i2c_peripherals,\n\t\t\t\t\t      src->num_i2c_peripherals *\n\t\t\t\t\t  sizeof(*src->i2c_peripherals),\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!i2c_peripherals)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < src->num_i2c_peripherals; i++) {\n\t\ti2c_dev = &i2c_peripherals[i];\n\t\tinfo = &i2c_dev->board_info;\n\n\t\terror = chromeos_laptop_setup_irq(i2c_dev);\n\t\tif (error)\n\t\t\tgoto err_out;\n\n\t\t \n\t\tif (i2c_dev->properties) {\n\t\t\tinfo->fwnode = fwnode_create_software_node(i2c_dev->properties, NULL);\n\t\t\tif (IS_ERR(info->fwnode)) {\n\t\t\t\terror = PTR_ERR(info->fwnode);\n\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t}\n\t}\n\n\tcros_laptop->i2c_peripherals = i2c_peripherals;\n\tcros_laptop->num_i2c_peripherals = src->num_i2c_peripherals;\n\n\treturn 0;\n\nerr_out:\n\twhile (--i >= 0) {\n\t\ti2c_dev = &i2c_peripherals[i];\n\t\tinfo = &i2c_dev->board_info;\n\t\tif (!IS_ERR_OR_NULL(info->fwnode))\n\t\t\tfwnode_remove_software_node(info->fwnode);\n\t}\n\tkfree(i2c_peripherals);\n\treturn error;\n}\n\nstatic int __init\nchromeos_laptop_prepare_acpi_peripherals(struct chromeos_laptop *cros_laptop,\n\t\t\t\t\tconst struct chromeos_laptop *src)\n{\n\tstruct acpi_peripheral *acpi_peripherals;\n\tstruct acpi_peripheral *acpi_dev;\n\tconst struct acpi_peripheral *src_dev;\n\tint n_peripherals = 0;\n\tint i;\n\tint error;\n\n\tfor (i = 0; i < src->num_acpi_peripherals; i++) {\n\t\tif (acpi_dev_present(src->acpi_peripherals[i].hid, NULL, -1))\n\t\t\tn_peripherals++;\n\t}\n\n\tif (!n_peripherals)\n\t\treturn 0;\n\n\tacpi_peripherals = kcalloc(n_peripherals,\n\t\t\t\t   sizeof(*src->acpi_peripherals),\n\t\t\t\t   GFP_KERNEL);\n\tif (!acpi_peripherals)\n\t\treturn -ENOMEM;\n\n\tacpi_dev = acpi_peripherals;\n\tfor (i = 0; i < src->num_acpi_peripherals; i++) {\n\t\tsrc_dev = &src->acpi_peripherals[i];\n\t\tif (!acpi_dev_present(src_dev->hid, NULL, -1))\n\t\t\tcontinue;\n\n\t\t*acpi_dev = *src_dev;\n\n\t\t \n\t\tif (src_dev->swnode.properties) {\n\t\t\tacpi_dev->swnode.properties =\n\t\t\t\tproperty_entries_dup(src_dev->swnode.properties);\n\t\t\tif (IS_ERR(acpi_dev->swnode.properties)) {\n\t\t\t\terror = PTR_ERR(acpi_dev->swnode.properties);\n\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t}\n\n\t\tacpi_dev++;\n\t}\n\n\tcros_laptop->acpi_peripherals = acpi_peripherals;\n\tcros_laptop->num_acpi_peripherals = n_peripherals;\n\n\treturn 0;\n\nerr_out:\n\twhile (--i >= 0) {\n\t\tacpi_dev = &acpi_peripherals[i];\n\t\tif (!IS_ERR_OR_NULL(acpi_dev->swnode.properties))\n\t\t\tproperty_entries_free(acpi_dev->swnode.properties);\n\t}\n\n\tkfree(acpi_peripherals);\n\treturn error;\n}\n\nstatic void chromeos_laptop_destroy(const struct chromeos_laptop *cros_laptop)\n{\n\tconst struct acpi_peripheral *acpi_dev;\n\tstruct i2c_peripheral *i2c_dev;\n\tint i;\n\n\tfor (i = 0; i < cros_laptop->num_i2c_peripherals; i++) {\n\t\ti2c_dev = &cros_laptop->i2c_peripherals[i];\n\t\ti2c_unregister_device(i2c_dev->client);\n\t}\n\n\tfor (i = 0; i < cros_laptop->num_acpi_peripherals; i++) {\n\t\tacpi_dev = &cros_laptop->acpi_peripherals[i];\n\n\t\tif (acpi_dev->client)\n\t\t\tdevice_remove_software_node(&acpi_dev->client->dev);\n\n\t\tproperty_entries_free(acpi_dev->swnode.properties);\n\t}\n\n\tkfree(cros_laptop->i2c_peripherals);\n\tkfree(cros_laptop->acpi_peripherals);\n\tkfree(cros_laptop);\n}\n\nstatic struct chromeos_laptop * __init\nchromeos_laptop_prepare(const struct chromeos_laptop *src)\n{\n\tstruct chromeos_laptop *cros_laptop;\n\tint error;\n\n\tcros_laptop = kzalloc(sizeof(*cros_laptop), GFP_KERNEL);\n\tif (!cros_laptop)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terror = chromeos_laptop_prepare_i2c_peripherals(cros_laptop, src);\n\tif (!error)\n\t\terror = chromeos_laptop_prepare_acpi_peripherals(cros_laptop,\n\t\t\t\t\t\t\t\t src);\n\n\tif (error) {\n\t\tchromeos_laptop_destroy(cros_laptop);\n\t\treturn ERR_PTR(error);\n\t}\n\n\treturn cros_laptop;\n}\n\nstatic int __init chromeos_laptop_init(void)\n{\n\tconst struct dmi_system_id *dmi_id;\n\tint error;\n\n\tdmi_id = dmi_first_match(chromeos_laptop_dmi_table);\n\tif (!dmi_id) {\n\t\tpr_debug(\"unsupported system\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tpr_debug(\"DMI Matched %s\\n\", dmi_id->ident);\n\n\tcros_laptop = chromeos_laptop_prepare((void *)dmi_id->driver_data);\n\tif (IS_ERR(cros_laptop))\n\t\treturn PTR_ERR(cros_laptop);\n\n\tif (!cros_laptop->num_i2c_peripherals &&\n\t    !cros_laptop->num_acpi_peripherals) {\n\t\tpr_debug(\"no relevant devices detected\\n\");\n\t\terror = -ENODEV;\n\t\tgoto err_destroy_cros_laptop;\n\t}\n\n\terror = bus_register_notifier(&i2c_bus_type,\n\t\t\t\t      &chromeos_laptop_i2c_notifier);\n\tif (error) {\n\t\tpr_err(\"failed to register i2c bus notifier: %d\\n\",\n\t\t       error);\n\t\tgoto err_destroy_cros_laptop;\n\t}\n\n\t \n\ti2c_for_each_dev(NULL, chromeos_laptop_scan_peripherals);\n\n\treturn 0;\n\nerr_destroy_cros_laptop:\n\tchromeos_laptop_destroy(cros_laptop);\n\treturn error;\n}\n\nstatic void __exit chromeos_laptop_exit(void)\n{\n\tbus_unregister_notifier(&i2c_bus_type, &chromeos_laptop_i2c_notifier);\n\tchromeos_laptop_destroy(cros_laptop);\n}\n\nmodule_init(chromeos_laptop_init);\nmodule_exit(chromeos_laptop_exit);\n\nMODULE_DESCRIPTION(\"Chrome OS Laptop driver\");\nMODULE_AUTHOR(\"Benson Leung <bleung@chromium.org>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}