{
  "module_name": "cros_ec_sensorhub_ring.c",
  "hash_id": "6bb81de4cefb8697e2286ac837afae46effc84376e896b1d8ba0c137c4524db3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/chrome/cros_ec_sensorhub_ring.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/iio/iio.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/platform_data/cros_ec_commands.h>\n#include <linux/platform_data/cros_ec_proto.h>\n#include <linux/platform_data/cros_ec_sensorhub.h>\n#include <linux/platform_device.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n\n#define CREATE_TRACE_POINTS\n#include \"cros_ec_sensorhub_trace.h\"\n\n \n#define M_PRECISION BIT(23)\n\n \n#define TS_HISTORY_THRESHOLD 8\n\n \n#define TS_HISTORY_BORED_US 500000\n\n \n#define FUTURE_TS_ANALYTICS_COUNT_MAX 100\n\nstatic inline int\ncros_sensorhub_send_sample(struct cros_ec_sensorhub *sensorhub,\n\t\t\t   struct cros_ec_sensors_ring_sample *sample)\n{\n\tcros_ec_sensorhub_push_data_cb_t cb;\n\tint id = sample->sensor_id;\n\tstruct iio_dev *indio_dev;\n\n\tif (id >= sensorhub->sensor_num)\n\t\treturn -EINVAL;\n\n\tcb = sensorhub->push_data[id].push_data_cb;\n\tif (!cb)\n\t\treturn 0;\n\n\tindio_dev = sensorhub->push_data[id].indio_dev;\n\n\tif (sample->flag & MOTIONSENSE_SENSOR_FLAG_FLUSH)\n\t\treturn 0;\n\n\treturn cb(indio_dev, sample->vector, sample->timestamp);\n}\n\n \nint cros_ec_sensorhub_register_push_data(struct cros_ec_sensorhub *sensorhub,\n\t\t\t\t\t u8 sensor_num,\n\t\t\t\t\t struct iio_dev *indio_dev,\n\t\t\t\t\t cros_ec_sensorhub_push_data_cb_t cb)\n{\n\tif (sensor_num >= sensorhub->sensor_num)\n\t\treturn -EINVAL;\n\tif (sensorhub->push_data[sensor_num].indio_dev)\n\t\treturn -EINVAL;\n\n\tsensorhub->push_data[sensor_num].indio_dev = indio_dev;\n\tsensorhub->push_data[sensor_num].push_data_cb = cb;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(cros_ec_sensorhub_register_push_data);\n\nvoid cros_ec_sensorhub_unregister_push_data(struct cros_ec_sensorhub *sensorhub,\n\t\t\t\t\t    u8 sensor_num)\n{\n\tsensorhub->push_data[sensor_num].indio_dev = NULL;\n\tsensorhub->push_data[sensor_num].push_data_cb = NULL;\n}\nEXPORT_SYMBOL_GPL(cros_ec_sensorhub_unregister_push_data);\n\n \nint cros_ec_sensorhub_ring_fifo_enable(struct cros_ec_sensorhub *sensorhub,\n\t\t\t\t       bool on)\n{\n\tint ret, i;\n\n\tmutex_lock(&sensorhub->cmd_lock);\n\tif (sensorhub->tight_timestamps)\n\t\tfor (i = 0; i < sensorhub->sensor_num; i++)\n\t\t\tsensorhub->batch_state[i].last_len = 0;\n\n\tsensorhub->params->cmd = MOTIONSENSE_CMD_FIFO_INT_ENABLE;\n\tsensorhub->params->fifo_int_enable.enable = on;\n\n\tsensorhub->msg->outsize = sizeof(struct ec_params_motion_sense);\n\tsensorhub->msg->insize = sizeof(struct ec_response_motion_sense);\n\n\tret = cros_ec_cmd_xfer_status(sensorhub->ec->ec_dev, sensorhub->msg);\n\tmutex_unlock(&sensorhub->cmd_lock);\n\n\t \n\tif (ret > 0)\n\t\tret = 0;\n\n\treturn ret;\n}\n\nstatic int cros_ec_sensor_ring_median_cmp(const void *pv1, const void *pv2)\n{\n\ts64 v1 = *(s64 *)pv1;\n\ts64 v2 = *(s64 *)pv2;\n\n\tif (v1 > v2)\n\t\treturn 1;\n\telse if (v1 < v2)\n\t\treturn -1;\n\telse\n\t\treturn 0;\n}\n\n \nstatic s64 cros_ec_sensor_ring_median(s64 *array, size_t length)\n{\n\tsort(array, length, sizeof(s64), cros_ec_sensor_ring_median_cmp, NULL);\n\treturn array[length / 2];\n}\n\n \n\n \nstatic void\ncros_ec_sensor_ring_ts_filter_update(struct cros_ec_sensors_ts_filter_state\n\t\t\t\t     *state,\n\t\t\t\t     s64 b, s64 c)\n{\n\ts64 x, y;\n\ts64 dx, dy;\n\ts64 m;  \n\ts64 *m_history_copy = state->temp_buf;\n\ts64 *error = state->temp_buf;\n\tint i;\n\n\t \n\tx = b;\n\t \n\ty = c - b * 1000;\n\n\tdx = (state->x_history[0] + state->x_offset) - x;\n\tif (dx == 0)\n\t\treturn;  \n\tdy = (state->y_history[0] + state->y_offset) - y;\n\tm = div64_s64(dy * M_PRECISION, dx);\n\n\t \n\tif (-dx > TS_HISTORY_BORED_US)\n\t\tstate->history_len = 0;\n\n\t \n\tfor (i = state->history_len - 1; i >= 1; i--) {\n\t\tstate->x_history[i] = state->x_history[i - 1] + dx;\n\t\tstate->y_history[i] = state->y_history[i - 1] + dy;\n\n\t\tstate->m_history[i] = state->m_history[i - 1];\n\t\t \n\t\tm_history_copy[i] = state->m_history[i - 1];\n\t}\n\n\t \n\tstate->x_offset = x;\n\tstate->y_offset = y;\n\tstate->x_history[0] = 0;\n\tstate->y_history[0] = 0;\n\n\tstate->m_history[0] = m;\n\tm_history_copy[0] = m;\n\n\tif (state->history_len < CROS_EC_SENSORHUB_TS_HISTORY_SIZE)\n\t\tstate->history_len++;\n\n\t \n\tif (state->history_len > TS_HISTORY_THRESHOLD) {\n\t\tstate->median_m =\n\t\t    cros_ec_sensor_ring_median(m_history_copy,\n\t\t\t\t\t       state->history_len - 1);\n\n\t\t \n\t\tfor (i = 0; i < state->history_len; i++)\n\t\t\terror[i] = state->y_history[i] -\n\t\t\t\tdiv_s64(state->median_m * state->x_history[i],\n\t\t\t\t\tM_PRECISION);\n\t\tstate->median_error =\n\t\t\tcros_ec_sensor_ring_median(error, state->history_len);\n\t} else {\n\t\tstate->median_m = 0;\n\t\tstate->median_error = 0;\n\t}\n\ttrace_cros_ec_sensorhub_filter(state, dx, dy);\n}\n\n \nstatic s64\ncros_ec_sensor_ring_ts_filter(struct cros_ec_sensors_ts_filter_state *state,\n\t\t\t      s64 x)\n{\n\treturn div_s64(state->median_m * (x - state->x_offset), M_PRECISION)\n\t       + state->median_error + state->y_offset + x * 1000;\n}\n\n \nstatic void\ncros_ec_sensor_ring_fix_overflow(s64 *ts,\n\t\t\t\t const s64 overflow_period,\n\t\t\t\t struct cros_ec_sensors_ec_overflow_state\n\t\t\t\t *state)\n{\n\ts64 adjust;\n\n\t*ts += state->offset;\n\tif (abs(state->last - *ts) > (overflow_period / 2)) {\n\t\tadjust = state->last > *ts ? overflow_period : -overflow_period;\n\t\tstate->offset += adjust;\n\t\t*ts += adjust;\n\t}\n\tstate->last = *ts;\n}\n\nstatic void\ncros_ec_sensor_ring_check_for_past_timestamp(struct cros_ec_sensorhub\n\t\t\t\t\t     *sensorhub,\n\t\t\t\t\t     struct cros_ec_sensors_ring_sample\n\t\t\t\t\t     *sample)\n{\n\tconst u8 sensor_id = sample->sensor_id;\n\n\t \n\tif (sensorhub->batch_state[sensor_id].newest_sensor_event >\n\t    sample->timestamp)\n\t\t \n\t\tsample->timestamp =\n\t\t\tsensorhub->batch_state[sensor_id].last_ts;\n\telse\n\t\tsensorhub->batch_state[sensor_id].newest_sensor_event =\n\t\t\tsample->timestamp;\n}\n\n \nstatic bool\ncros_ec_sensor_ring_process_event(struct cros_ec_sensorhub *sensorhub,\n\t\t\t\tconst struct ec_response_motion_sense_fifo_info\n\t\t\t\t*fifo_info,\n\t\t\t\tconst ktime_t fifo_timestamp,\n\t\t\t\tktime_t *current_timestamp,\n\t\t\t\tstruct ec_response_motion_sensor_data *in,\n\t\t\t\tstruct cros_ec_sensors_ring_sample *out)\n{\n\tconst s64 now = cros_ec_get_time_ns();\n\tint axis, async_flags;\n\n\t \n\tasync_flags = in->flags &\n\t\t(MOTIONSENSE_SENSOR_FLAG_ODR | MOTIONSENSE_SENSOR_FLAG_FLUSH);\n\n\tif (in->flags & MOTIONSENSE_SENSOR_FLAG_TIMESTAMP && !async_flags) {\n\t\ts64 a = in->timestamp;\n\t\ts64 b = fifo_info->timestamp;\n\t\ts64 c = fifo_timestamp;\n\n\t\tcros_ec_sensor_ring_fix_overflow(&a, 1LL << 32,\n\t\t\t\t\t  &sensorhub->overflow_a);\n\t\tcros_ec_sensor_ring_fix_overflow(&b, 1LL << 32,\n\t\t\t\t\t  &sensorhub->overflow_b);\n\n\t\tif (sensorhub->tight_timestamps) {\n\t\t\tcros_ec_sensor_ring_ts_filter_update(\n\t\t\t\t\t&sensorhub->filter, b, c);\n\t\t\t*current_timestamp = cros_ec_sensor_ring_ts_filter(\n\t\t\t\t\t&sensorhub->filter, a);\n\t\t} else {\n\t\t\ts64 new_timestamp;\n\n\t\t\t \n\t\t\tnew_timestamp = c - b * 1000 + a * 1000;\n\t\t\t \n\t\t\tif (new_timestamp - *current_timestamp > 0)\n\t\t\t\t*current_timestamp = new_timestamp;\n\t\t}\n\t\ttrace_cros_ec_sensorhub_timestamp(in->timestamp,\n\t\t\t\t\t\t  fifo_info->timestamp,\n\t\t\t\t\t\t  fifo_timestamp,\n\t\t\t\t\t\t  *current_timestamp,\n\t\t\t\t\t\t  now);\n\t}\n\n\tif (in->flags & MOTIONSENSE_SENSOR_FLAG_ODR) {\n\t\tif (sensorhub->tight_timestamps) {\n\t\t\tsensorhub->batch_state[in->sensor_num].last_len = 0;\n\t\t\tsensorhub->batch_state[in->sensor_num].penul_len = 0;\n\t\t}\n\t\t \n\t\treturn false;\n\t}\n\n\tif (in->flags & MOTIONSENSE_SENSOR_FLAG_FLUSH) {\n\t\tout->sensor_id = in->sensor_num;\n\t\tout->timestamp = *current_timestamp;\n\t\tout->flag = in->flags;\n\t\tif (sensorhub->tight_timestamps)\n\t\t\tsensorhub->batch_state[out->sensor_id].last_len = 0;\n\t\t \n\t\treturn true;\n\t}\n\n\tif (in->flags & MOTIONSENSE_SENSOR_FLAG_TIMESTAMP)\n\t\t \n\t\treturn false;\n\n\t \n\tout->sensor_id = in->sensor_num;\n\ttrace_cros_ec_sensorhub_data(in->sensor_num,\n\t\t\t\t     fifo_info->timestamp,\n\t\t\t\t     fifo_timestamp,\n\t\t\t\t     *current_timestamp,\n\t\t\t\t     now);\n\n\tif (*current_timestamp - now > 0) {\n\t\t \n\t\tsensorhub->future_timestamp_total_ns +=\n\t\t\t*current_timestamp - now;\n\t\tif (++sensorhub->future_timestamp_count ==\n\t\t\t\tFUTURE_TS_ANALYTICS_COUNT_MAX) {\n\t\t\ts64 avg = div_s64(sensorhub->future_timestamp_total_ns,\n\t\t\t\t\tsensorhub->future_timestamp_count);\n\t\t\tdev_warn_ratelimited(sensorhub->dev,\n\t\t\t\t\t     \"100 timestamps in the future, %lldns shaved on average\\n\",\n\t\t\t\t\t     avg);\n\t\t\tsensorhub->future_timestamp_count = 0;\n\t\t\tsensorhub->future_timestamp_total_ns = 0;\n\t\t}\n\t\tout->timestamp = now;\n\t} else {\n\t\tout->timestamp = *current_timestamp;\n\t}\n\n\tout->flag = in->flags;\n\tfor (axis = 0; axis < 3; axis++)\n\t\tout->vector[axis] = in->data[axis];\n\n\tif (sensorhub->tight_timestamps)\n\t\tcros_ec_sensor_ring_check_for_past_timestamp(sensorhub, out);\n\treturn true;\n}\n\n \nstatic void\ncros_ec_sensor_ring_spread_add(struct cros_ec_sensorhub *sensorhub,\n\t\t\t       unsigned long sensor_mask,\n\t\t\t       struct cros_ec_sensors_ring_sample *last_out)\n{\n\tstruct cros_ec_sensors_ring_sample *batch_start, *next_batch_start;\n\tint id;\n\n\tfor_each_set_bit(id, &sensor_mask, sensorhub->sensor_num) {\n\t\tfor (batch_start = sensorhub->ring; batch_start < last_out;\n\t\t     batch_start = next_batch_start) {\n\t\t\t \n\t\t\tint batch_len, sample_idx;\n\t\t\tstruct cros_ec_sensors_ring_sample *batch_end =\n\t\t\t\tbatch_start;\n\t\t\tstruct cros_ec_sensors_ring_sample *s;\n\t\t\ts64 batch_timestamp = batch_start->timestamp;\n\t\t\ts64 sample_period;\n\n\t\t\t \n\t\t\tif (batch_start->sensor_id != id) {\n\t\t\t\tnext_batch_start = batch_start + 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (batch_start->flag & MOTIONSENSE_SENSOR_FLAG_FLUSH) {\n\t\t\t\tcros_sensorhub_send_sample(sensorhub,\n\t\t\t\t\t\t\t   batch_start);\n\t\t\t\tnext_batch_start = batch_start + 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (batch_start->timestamp <=\n\t\t\t    sensorhub->batch_state[id].last_ts) {\n\t\t\t\tbatch_timestamp =\n\t\t\t\t\tsensorhub->batch_state[id].last_ts;\n\t\t\t\tbatch_len = sensorhub->batch_state[id].last_len;\n\n\t\t\t\tsample_idx = batch_len;\n\n\t\t\t\tsensorhub->batch_state[id].last_ts =\n\t\t\t\t  sensorhub->batch_state[id].penul_ts;\n\t\t\t\tsensorhub->batch_state[id].last_len =\n\t\t\t\t  sensorhub->batch_state[id].penul_len;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tsample_idx = 1;\n\t\t\t\tbatch_len = 1;\n\t\t\t\tcros_sensorhub_send_sample(sensorhub,\n\t\t\t\t\t\t\t   batch_start);\n\t\t\t\tbatch_start++;\n\t\t\t}\n\n\t\t\t \n\t\t\tfor (s = batch_start; s < last_out; s++) {\n\t\t\t\tif (s->sensor_id != id)\n\t\t\t\t\t \n\t\t\t\t\tcontinue;\n\t\t\t\tif (s->timestamp != batch_timestamp)\n\t\t\t\t\t \n\t\t\t\t\tbreak;\n\t\t\t\tif (s->flag & MOTIONSENSE_SENSOR_FLAG_FLUSH)\n\t\t\t\t\t \n\t\t\t\t\tbreak;\n\t\t\t\tbatch_end = s;\n\t\t\t\tbatch_len++;\n\t\t\t}\n\n\t\t\tif (batch_len == 1)\n\t\t\t\tgoto done_with_this_batch;\n\n\t\t\t \n\t\t\tif (sensorhub->batch_state[id].last_len == 0) {\n\t\t\t\tdev_warn(sensorhub->dev, \"Sensor %d: lost %d samples when spreading\\n\",\n\t\t\t\t\t id, batch_len - 1);\n\t\t\t\tgoto done_with_this_batch;\n\t\t\t\t \n\t\t\t}\n\n\t\t\tsample_period = div_s64(batch_timestamp -\n\t\t\t\tsensorhub->batch_state[id].last_ts,\n\t\t\t\tsensorhub->batch_state[id].last_len);\n\t\t\tdev_dbg(sensorhub->dev,\n\t\t\t\t\"Adjusting %d samples, sensor %d last_batch @%lld (%d samples) batch_timestamp=%lld => period=%lld\\n\",\n\t\t\t\tbatch_len, id,\n\t\t\t\tsensorhub->batch_state[id].last_ts,\n\t\t\t\tsensorhub->batch_state[id].last_len,\n\t\t\t\tbatch_timestamp,\n\t\t\t\tsample_period);\n\n\t\t\t \n\t\t\tfor (s = batch_start; s <= batch_end; s++) {\n\t\t\t\tif (s->sensor_id != id)\n\t\t\t\t\t \n\t\t\t\t\tcontinue;\n\n\t\t\t\ts->timestamp = batch_timestamp +\n\t\t\t\t\tsample_period * sample_idx;\n\t\t\t\tsample_idx++;\n\n\t\t\t\tcros_sensorhub_send_sample(sensorhub, s);\n\t\t\t}\n\ndone_with_this_batch:\n\t\t\tsensorhub->batch_state[id].penul_ts =\n\t\t\t\tsensorhub->batch_state[id].last_ts;\n\t\t\tsensorhub->batch_state[id].penul_len =\n\t\t\t\tsensorhub->batch_state[id].last_len;\n\n\t\t\tsensorhub->batch_state[id].last_ts =\n\t\t\t\tbatch_timestamp;\n\t\t\tsensorhub->batch_state[id].last_len = batch_len;\n\n\t\t\tnext_batch_start = batch_end + 1;\n\t\t}\n\t}\n}\n\n \nstatic void\ncros_ec_sensor_ring_spread_add_legacy(struct cros_ec_sensorhub *sensorhub,\n\t\t\t\t      unsigned long sensor_mask,\n\t\t\t\t      s64 current_timestamp,\n\t\t\t\t      struct cros_ec_sensors_ring_sample\n\t\t\t\t      *last_out)\n{\n\tstruct cros_ec_sensors_ring_sample *out;\n\tint i;\n\n\tfor_each_set_bit(i, &sensor_mask, sensorhub->sensor_num) {\n\t\ts64 timestamp;\n\t\tint count = 0;\n\t\ts64 time_period;\n\n\t\tfor (out = sensorhub->ring; out < last_out; out++) {\n\t\t\tif (out->sensor_id != i)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\ttimestamp = out->timestamp;\n\t\t\tout++;\n\t\t\tcount = 1;\n\t\t\tbreak;\n\t\t}\n\t\tfor (; out < last_out; out++) {\n\t\t\t \n\t\t\tif (out->sensor_id != i)\n\t\t\t\tcontinue;\n\t\t\tcount++;\n\t\t}\n\t\tif (count == 0)\n\t\t\tcontinue;\n\n\t\t \n\t\ttime_period = div_s64(current_timestamp - timestamp, count);\n\n\t\tfor (out = sensorhub->ring; out < last_out; out++) {\n\t\t\tif (out->sensor_id != i)\n\t\t\t\tcontinue;\n\t\t\ttimestamp += time_period;\n\t\t\tout->timestamp = timestamp;\n\t\t}\n\t}\n\n\t \n\tfor (out = sensorhub->ring; out < last_out; out++)\n\t\tcros_sensorhub_send_sample(sensorhub, out);\n}\n\n \nstatic void cros_ec_sensorhub_ring_handler(struct cros_ec_sensorhub *sensorhub)\n{\n\tstruct ec_response_motion_sense_fifo_info *fifo_info =\n\t\tsensorhub->fifo_info;\n\tstruct cros_ec_dev *ec = sensorhub->ec;\n\tktime_t fifo_timestamp, current_timestamp;\n\tint i, j, number_data, ret;\n\tunsigned long sensor_mask = 0;\n\tstruct ec_response_motion_sensor_data *in;\n\tstruct cros_ec_sensors_ring_sample *out, *last_out;\n\n\tmutex_lock(&sensorhub->cmd_lock);\n\n\t \n\tif (fifo_info->total_lost) {\n\t\tint fifo_info_length =\n\t\t\tsizeof(struct ec_response_motion_sense_fifo_info) +\n\t\t\tsizeof(u16) * sensorhub->sensor_num;\n\n\t\t \n\t\tsensorhub->params->cmd = MOTIONSENSE_CMD_FIFO_INFO;\n\t\tsensorhub->msg->outsize = 1;\n\t\tsensorhub->msg->insize = fifo_info_length;\n\n\t\tif (cros_ec_cmd_xfer_status(ec->ec_dev, sensorhub->msg) < 0)\n\t\t\tgoto error;\n\n\t\tmemcpy(fifo_info, &sensorhub->resp->fifo_info,\n\t\t       fifo_info_length);\n\n\t\t \n\t\tfifo_timestamp = cros_ec_get_time_ns();\n\t} else {\n\t\tfifo_timestamp = sensorhub->fifo_timestamp[\n\t\t\tCROS_EC_SENSOR_NEW_TS];\n\t}\n\n\tif (fifo_info->count > sensorhub->fifo_size ||\n\t    fifo_info->size != sensorhub->fifo_size) {\n\t\tdev_warn(sensorhub->dev,\n\t\t\t \"Mismatch EC data: count %d, size %d - expected %d\\n\",\n\t\t\t fifo_info->count, fifo_info->size,\n\t\t\t sensorhub->fifo_size);\n\t\tgoto error;\n\t}\n\n\t \n\tcurrent_timestamp = sensorhub->fifo_timestamp[CROS_EC_SENSOR_LAST_TS];\n\tout = sensorhub->ring;\n\tfor (i = 0; i < fifo_info->count; i += number_data) {\n\t\tsensorhub->params->cmd = MOTIONSENSE_CMD_FIFO_READ;\n\t\tsensorhub->params->fifo_read.max_data_vector =\n\t\t\tfifo_info->count - i;\n\t\tsensorhub->msg->outsize =\n\t\t\tsizeof(struct ec_params_motion_sense);\n\t\tsensorhub->msg->insize =\n\t\t\tsizeof(sensorhub->resp->fifo_read) +\n\t\t\tsensorhub->params->fifo_read.max_data_vector *\n\t\t\t  sizeof(struct ec_response_motion_sensor_data);\n\t\tret = cros_ec_cmd_xfer_status(ec->ec_dev, sensorhub->msg);\n\t\tif (ret < 0) {\n\t\t\tdev_warn(sensorhub->dev, \"Fifo error: %d\\n\", ret);\n\t\t\tbreak;\n\t\t}\n\t\tnumber_data = sensorhub->resp->fifo_read.number_data;\n\t\tif (number_data == 0) {\n\t\t\tdev_dbg(sensorhub->dev, \"Unexpected empty FIFO\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tif (number_data > fifo_info->count - i) {\n\t\t\tdev_warn(sensorhub->dev,\n\t\t\t\t \"Invalid EC data: too many entry received: %d, expected %d\\n\",\n\t\t\t\t number_data, fifo_info->count - i);\n\t\t\tbreak;\n\t\t}\n\t\tif (out + number_data >\n\t\t    sensorhub->ring + fifo_info->count) {\n\t\t\tdev_warn(sensorhub->dev,\n\t\t\t\t \"Too many samples: %d (%zd data) to %d entries for expected %d entries\\n\",\n\t\t\t\t i, out - sensorhub->ring, i + number_data,\n\t\t\t\t fifo_info->count);\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (in = sensorhub->resp->fifo_read.data, j = 0;\n\t\t     j < number_data; j++, in++) {\n\t\t\tif (cros_ec_sensor_ring_process_event(\n\t\t\t\t\t\tsensorhub, fifo_info,\n\t\t\t\t\t\tfifo_timestamp,\n\t\t\t\t\t\t&current_timestamp,\n\t\t\t\t\t\tin, out)) {\n\t\t\t\tsensor_mask |= BIT(in->sensor_num);\n\t\t\t\tout++;\n\t\t\t}\n\t\t}\n\t}\n\tmutex_unlock(&sensorhub->cmd_lock);\n\tlast_out = out;\n\n\tif (out == sensorhub->ring)\n\t\t \n\t\tgoto ring_handler_end;\n\n\t \n\tif (!sensorhub->tight_timestamps &&\n\t    (last_out - 1)->timestamp == current_timestamp)\n\t\tcurrent_timestamp = fifo_timestamp;\n\n\t \n\tif (fifo_info->total_lost)\n\t\tfor (i = 0; i < sensorhub->sensor_num; i++) {\n\t\t\tif (fifo_info->lost[i]) {\n\t\t\t\tdev_warn_ratelimited(sensorhub->dev,\n\t\t\t\t\t\t     \"Sensor %d: lost: %d out of %d\\n\",\n\t\t\t\t\t\t     i, fifo_info->lost[i],\n\t\t\t\t\t\t     fifo_info->total_lost);\n\t\t\t\tif (sensorhub->tight_timestamps)\n\t\t\t\t\tsensorhub->batch_state[i].last_len = 0;\n\t\t\t}\n\t\t}\n\n\t \n\tif (sensorhub->tight_timestamps)\n\t\tcros_ec_sensor_ring_spread_add(sensorhub, sensor_mask,\n\t\t\t\t\t       last_out);\n\telse\n\t\tcros_ec_sensor_ring_spread_add_legacy(sensorhub, sensor_mask,\n\t\t\t\t\t\t      current_timestamp,\n\t\t\t\t\t\t      last_out);\n\nring_handler_end:\n\tsensorhub->fifo_timestamp[CROS_EC_SENSOR_LAST_TS] = current_timestamp;\n\treturn;\n\nerror:\n\tmutex_unlock(&sensorhub->cmd_lock);\n}\n\nstatic int cros_ec_sensorhub_event(struct notifier_block *nb,\n\t\t\t\t   unsigned long queued_during_suspend,\n\t\t\t\t   void *_notify)\n{\n\tstruct cros_ec_sensorhub *sensorhub;\n\tstruct cros_ec_device *ec_dev;\n\n\tsensorhub = container_of(nb, struct cros_ec_sensorhub, notifier);\n\tec_dev = sensorhub->ec->ec_dev;\n\n\tif (ec_dev->event_data.event_type != EC_MKBP_EVENT_SENSOR_FIFO)\n\t\treturn NOTIFY_DONE;\n\n\tif (ec_dev->event_size != sizeof(ec_dev->event_data.data.sensor_fifo)) {\n\t\tdev_warn(ec_dev->dev, \"Invalid fifo info size\\n\");\n\t\treturn NOTIFY_DONE;\n\t}\n\n\tif (queued_during_suspend)\n\t\treturn NOTIFY_OK;\n\n\tmemcpy(sensorhub->fifo_info, &ec_dev->event_data.data.sensor_fifo.info,\n\t       sizeof(*sensorhub->fifo_info));\n\tsensorhub->fifo_timestamp[CROS_EC_SENSOR_NEW_TS] =\n\t\tec_dev->last_event_time;\n\tcros_ec_sensorhub_ring_handler(sensorhub);\n\n\treturn NOTIFY_OK;\n}\n\n \nint cros_ec_sensorhub_ring_allocate(struct cros_ec_sensorhub *sensorhub)\n{\n\tint fifo_info_length =\n\t\tsizeof(struct ec_response_motion_sense_fifo_info) +\n\t\tsizeof(u16) * sensorhub->sensor_num;\n\n\t \n\tsensorhub->fifo_info = devm_kzalloc(sensorhub->dev, fifo_info_length,\n\t\t\t\t\t    GFP_KERNEL);\n\tif (!sensorhub->fifo_info)\n\t\treturn -ENOMEM;\n\n\t \n\tsensorhub->push_data = devm_kcalloc(sensorhub->dev,\n\t\t\tsensorhub->sensor_num,\n\t\t\tsizeof(*sensorhub->push_data),\n\t\t\tGFP_KERNEL);\n\tif (!sensorhub->push_data)\n\t\treturn -ENOMEM;\n\n\tsensorhub->tight_timestamps = cros_ec_check_features(\n\t\t\tsensorhub->ec,\n\t\t\tEC_FEATURE_MOTION_SENSE_TIGHT_TIMESTAMPS);\n\n\tif (sensorhub->tight_timestamps) {\n\t\tsensorhub->batch_state = devm_kcalloc(sensorhub->dev,\n\t\t\t\tsensorhub->sensor_num,\n\t\t\t\tsizeof(*sensorhub->batch_state),\n\t\t\t\tGFP_KERNEL);\n\t\tif (!sensorhub->batch_state)\n\t\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\n \nint cros_ec_sensorhub_ring_add(struct cros_ec_sensorhub *sensorhub)\n{\n\tstruct cros_ec_dev *ec = sensorhub->ec;\n\tint ret;\n\tint fifo_info_length =\n\t\tsizeof(struct ec_response_motion_sense_fifo_info) +\n\t\tsizeof(u16) * sensorhub->sensor_num;\n\n\t \n\tsensorhub->msg->version = 2;\n\tsensorhub->params->cmd = MOTIONSENSE_CMD_FIFO_INFO;\n\tsensorhub->msg->outsize = 1;\n\tsensorhub->msg->insize = fifo_info_length;\n\n\tret = cros_ec_cmd_xfer_status(ec->ec_dev, sensorhub->msg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tsensorhub->fifo_size = sensorhub->resp->fifo_info.size;\n\tsensorhub->ring = devm_kcalloc(sensorhub->dev, sensorhub->fifo_size,\n\t\t\t\t       sizeof(*sensorhub->ring), GFP_KERNEL);\n\tif (!sensorhub->ring)\n\t\treturn -ENOMEM;\n\n\tsensorhub->fifo_timestamp[CROS_EC_SENSOR_LAST_TS] =\n\t\tcros_ec_get_time_ns();\n\n\t \n\tsensorhub->notifier.notifier_call = cros_ec_sensorhub_event;\n\tret = blocking_notifier_chain_register(&ec->ec_dev->event_notifier,\n\t\t\t\t\t       &sensorhub->notifier);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\treturn cros_ec_sensorhub_ring_fifo_enable(sensorhub, true);\n}\n\nvoid cros_ec_sensorhub_ring_remove(void *arg)\n{\n\tstruct cros_ec_sensorhub *sensorhub = arg;\n\tstruct cros_ec_device *ec_dev = sensorhub->ec->ec_dev;\n\n\t \n\tcros_ec_sensorhub_ring_fifo_enable(sensorhub, false);\n\tblocking_notifier_chain_unregister(&ec_dev->event_notifier,\n\t\t\t\t\t   &sensorhub->notifier);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}