{
  "module_name": "mailbox.c",
  "hash_id": "38b1a2a423ea877a00a22ed4242d8c2f02c84140d94050164d601610fc7d5eb3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/chrome/wilco_ec/mailbox.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/io.h>\n#include <linux/platform_data/wilco-ec.h>\n#include <linux/platform_device.h>\n\n#include \"../cros_ec_lpc_mec.h\"\n\n \n#define EC_MAILBOX_VERSION\t\t0\n\n \n#define EC_MAILBOX_START_COMMAND\t0xda\n\n \n#define EC_MAILBOX_PROTO_VERSION\t3\n\n \n#define EC_MAILBOX_DATA_EXTRA\t\t2\n\n \n#define EC_MAILBOX_TIMEOUT\t\tHZ\n\n \n#define EC_CMDR_DATA\t\tBIT(0)\t \n#define EC_CMDR_PENDING\t\tBIT(1)\t \n#define EC_CMDR_BUSY\t\tBIT(2)\t \n#define EC_CMDR_CMD\t\tBIT(3)\t \n\n \nstatic bool wilco_ec_response_timed_out(struct wilco_ec_device *ec)\n{\n\tunsigned long timeout = jiffies + EC_MAILBOX_TIMEOUT;\n\n\tdo {\n\t\tif (!(inb(ec->io_command->start) &\n\t\t      (EC_CMDR_PENDING | EC_CMDR_BUSY)))\n\t\t\treturn false;\n\t\tusleep_range(100, 200);\n\t} while (time_before(jiffies, timeout));\n\n\treturn true;\n}\n\n \nstatic u8 wilco_ec_checksum(const void *data, size_t size)\n{\n\tu8 *data_bytes = (u8 *)data;\n\tu8 checksum = 0;\n\tsize_t i;\n\n\tfor (i = 0; i < size; i++)\n\t\tchecksum += data_bytes[i];\n\n\treturn checksum;\n}\n\n \nstatic void wilco_ec_prepare(struct wilco_ec_message *msg,\n\t\t\t     struct wilco_ec_request *rq)\n{\n\tmemset(rq, 0, sizeof(*rq));\n\trq->struct_version = EC_MAILBOX_PROTO_VERSION;\n\trq->mailbox_id = msg->type;\n\trq->mailbox_version = EC_MAILBOX_VERSION;\n\trq->data_size = msg->request_size;\n\n\t \n\trq->checksum = wilco_ec_checksum(rq, sizeof(*rq));\n\trq->checksum += wilco_ec_checksum(msg->request_data, msg->request_size);\n\trq->checksum = -rq->checksum;\n}\n\n \nstatic int wilco_ec_transfer(struct wilco_ec_device *ec,\n\t\t\t     struct wilco_ec_message *msg,\n\t\t\t     struct wilco_ec_request *rq)\n{\n\tstruct wilco_ec_response *rs;\n\tu8 checksum;\n\tu8 flag;\n\n\t \n\tcros_ec_lpc_io_bytes_mec(MEC_IO_WRITE, 0, sizeof(*rq), (u8 *)rq);\n\tcros_ec_lpc_io_bytes_mec(MEC_IO_WRITE, sizeof(*rq), msg->request_size,\n\t\t\t\t msg->request_data);\n\n\t \n\toutb(EC_MAILBOX_START_COMMAND, ec->io_command->start);\n\n\t \n\tif (msg->flags & WILCO_EC_FLAG_NO_RESPONSE) {\n\t\tdev_dbg(ec->dev, \"EC does not respond to this command\\n\");\n\t\treturn 0;\n\t}\n\n\t \n\tif (wilco_ec_response_timed_out(ec)) {\n\t\tdev_dbg(ec->dev, \"response timed out\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\t \n\tflag = inb(ec->io_data->start);\n\tif (flag) {\n\t\tdev_dbg(ec->dev, \"bad response: 0x%02x\\n\", flag);\n\t\treturn -EIO;\n\t}\n\n\t \n\trs = ec->data_buffer;\n\tchecksum = cros_ec_lpc_io_bytes_mec(MEC_IO_READ, 0,\n\t\t\t\t\t    sizeof(*rs) + EC_MAILBOX_DATA_SIZE,\n\t\t\t\t\t    (u8 *)rs);\n\tif (checksum) {\n\t\tdev_dbg(ec->dev, \"bad packet checksum 0x%02x\\n\", rs->checksum);\n\t\treturn -EBADMSG;\n\t}\n\n\tif (rs->result) {\n\t\tdev_dbg(ec->dev, \"EC reported failure: 0x%02x\\n\", rs->result);\n\t\treturn -EBADMSG;\n\t}\n\n\tif (rs->data_size != EC_MAILBOX_DATA_SIZE) {\n\t\tdev_dbg(ec->dev, \"unexpected packet size (%u != %u)\\n\",\n\t\t\trs->data_size, EC_MAILBOX_DATA_SIZE);\n\t\treturn -EMSGSIZE;\n\t}\n\n\tif (rs->data_size < msg->response_size) {\n\t\tdev_dbg(ec->dev, \"EC didn't return enough data (%u < %zu)\\n\",\n\t\t\trs->data_size, msg->response_size);\n\t\treturn -EMSGSIZE;\n\t}\n\n\tmemcpy(msg->response_data, rs->data, msg->response_size);\n\n\treturn rs->data_size;\n}\n\n \nint wilco_ec_mailbox(struct wilco_ec_device *ec, struct wilco_ec_message *msg)\n{\n\tstruct wilco_ec_request *rq;\n\tint ret;\n\n\tdev_dbg(ec->dev, \"type=%04x flags=%02x rslen=%zu rqlen=%zu\\n\",\n\t\tmsg->type, msg->flags, msg->response_size, msg->request_size);\n\n\tmutex_lock(&ec->mailbox_lock);\n\t \n\trq = ec->data_buffer;\n\twilco_ec_prepare(msg, rq);\n\n\tret = wilco_ec_transfer(ec, msg, rq);\n\tmutex_unlock(&ec->mailbox_lock);\n\n\treturn ret;\n\n}\nEXPORT_SYMBOL_GPL(wilco_ec_mailbox);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}