{
  "module_name": "debugfs.c",
  "hash_id": "b449d200899910cabca6559a1742a61422b47ee2dfdaf2142aa928fd2b13b044",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/chrome/wilco_ec/debugfs.c",
  "human_readable_source": "\n \n\n#include <linux/ctype.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/platform_data/wilco-ec.h>\n#include <linux/platform_device.h>\n\n#define DRV_NAME \"wilco-ec-debugfs\"\n\n \n#define FORMATTED_BUFFER_SIZE (EC_MAILBOX_DATA_SIZE * 4)\n\nstruct wilco_ec_debugfs {\n\tstruct wilco_ec_device *ec;\n\tstruct dentry *dir;\n\tsize_t response_size;\n\tu8 raw_data[EC_MAILBOX_DATA_SIZE];\n\tu8 formatted_data[FORMATTED_BUFFER_SIZE];\n};\nstatic struct wilco_ec_debugfs *debug_info;\n\n \nstatic int parse_hex_sentence(const char *in, int isize, u8 *out, int osize)\n{\n\tint n_parsed = 0;\n\tint word_start = 0;\n\tint word_end;\n\tint word_len;\n\t \n\t#define MAX_WORD_SIZE 16\n\tchar tmp[MAX_WORD_SIZE + 1];\n\tu8 byte;\n\n\twhile (word_start < isize && n_parsed < osize) {\n\t\t \n\t\twhile (word_start < isize && isspace(in[word_start]))\n\t\t\tword_start++;\n\t\t  \n\t\tif (word_start >= isize)\n\t\t\tbreak;\n\n\t\t \n\t\tword_end = word_start;\n\t\twhile (word_end < isize && !isspace(in[word_end]))\n\t\t\tword_end++;\n\n\t\t \n\t\tword_len = word_end - word_start;\n\t\tif (word_len > MAX_WORD_SIZE)\n\t\t\treturn -EINVAL;\n\t\tmemcpy(tmp, in + word_start, word_len);\n\t\ttmp[word_len] = '\\0';\n\n\t\t \n\t\tif (kstrtou8(tmp, 16, &byte))\n\t\t\treturn -EINVAL;\n\t\tout[n_parsed++] = byte;\n\n\t\tword_start = word_end;\n\t}\n\treturn n_parsed;\n}\n\n \n#define TYPE_AND_DATA_SIZE ((EC_MAILBOX_DATA_SIZE) + 2)\n\nstatic ssize_t raw_write(struct file *file, const char __user *user_buf,\n\t\t\t size_t count, loff_t *ppos)\n{\n\tchar *buf = debug_info->formatted_data;\n\tstruct wilco_ec_message msg;\n\tu8 request_data[TYPE_AND_DATA_SIZE];\n\tssize_t kcount;\n\tint ret;\n\n\tif (count > FORMATTED_BUFFER_SIZE)\n\t\treturn -EINVAL;\n\n\tkcount = simple_write_to_buffer(buf, FORMATTED_BUFFER_SIZE, ppos,\n\t\t\t\t\tuser_buf, count);\n\tif (kcount < 0)\n\t\treturn kcount;\n\n\tret = parse_hex_sentence(buf, kcount, request_data, TYPE_AND_DATA_SIZE);\n\tif (ret < 0)\n\t\treturn ret;\n\t \n\tif (ret < 3)\n\t\treturn -EINVAL;\n\n\tmsg.type = request_data[0] << 8 | request_data[1];\n\tmsg.flags = 0;\n\tmsg.request_data = request_data + 2;\n\tmsg.request_size = ret - 2;\n\tmemset(debug_info->raw_data, 0, sizeof(debug_info->raw_data));\n\tmsg.response_data = debug_info->raw_data;\n\tmsg.response_size = EC_MAILBOX_DATA_SIZE;\n\n\tret = wilco_ec_mailbox(debug_info->ec, &msg);\n\tif (ret < 0)\n\t\treturn ret;\n\tdebug_info->response_size = ret;\n\n\treturn count;\n}\n\nstatic ssize_t raw_read(struct file *file, char __user *user_buf, size_t count,\n\t\t\tloff_t *ppos)\n{\n\tint fmt_len = 0;\n\n\tif (debug_info->response_size) {\n\t\tfmt_len = hex_dump_to_buffer(debug_info->raw_data,\n\t\t\t\t\t     debug_info->response_size,\n\t\t\t\t\t     16, 1, debug_info->formatted_data,\n\t\t\t\t\t     sizeof(debug_info->formatted_data),\n\t\t\t\t\t     true);\n\t\t \n\t\tdebug_info->response_size = 0;\n\t}\n\n\treturn simple_read_from_buffer(user_buf, count, ppos,\n\t\t\t\t       debug_info->formatted_data, fmt_len);\n}\n\nstatic const struct file_operations fops_raw = {\n\t.owner = THIS_MODULE,\n\t.read = raw_read,\n\t.write = raw_write,\n\t.llseek = no_llseek,\n};\n\n#define CMD_KB_CHROME\t\t0x88\n#define SUB_CMD_H1_GPIO\t\t0x0A\n#define SUB_CMD_TEST_EVENT\t0x0B\n\nstruct ec_request {\n\tu8 cmd;\t\t \n\tu8 reserved;\n\tu8 sub_cmd;\n} __packed;\n\nstruct ec_response {\n\tu8 status;\t \n\tu8 val;\n} __packed;\n\nstatic int send_ec_cmd(struct wilco_ec_device *ec, u8 sub_cmd, u8 *out_val)\n{\n\tstruct ec_request rq;\n\tstruct ec_response rs;\n\tstruct wilco_ec_message msg;\n\tint ret;\n\n\tmemset(&rq, 0, sizeof(rq));\n\trq.cmd = CMD_KB_CHROME;\n\trq.sub_cmd = sub_cmd;\n\n\tmemset(&msg, 0, sizeof(msg));\n\tmsg.type = WILCO_EC_MSG_LEGACY;\n\tmsg.request_data = &rq;\n\tmsg.request_size = sizeof(rq);\n\tmsg.response_data = &rs;\n\tmsg.response_size = sizeof(rs);\n\tret = wilco_ec_mailbox(ec, &msg);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (rs.status)\n\t\treturn -EIO;\n\n\t*out_val = rs.val;\n\n\treturn 0;\n}\n\n \nstatic int h1_gpio_get(void *arg, u64 *val)\n{\n\tint ret;\n\n\tret = send_ec_cmd(arg, SUB_CMD_H1_GPIO, (u8 *)val);\n\tif (ret == 0)\n\t\t*val &= 0xFF;\n\treturn ret;\n}\n\nDEFINE_DEBUGFS_ATTRIBUTE(fops_h1_gpio, h1_gpio_get, NULL, \"0x%02llx\\n\");\n\n \nstatic int test_event_set(void *arg, u64 val)\n{\n\tu8 ret;\n\n\treturn send_ec_cmd(arg, SUB_CMD_TEST_EVENT, &ret);\n}\n\n \nDEFINE_DEBUGFS_ATTRIBUTE(fops_test_event, NULL, test_event_set, \"%llu\\n\");\n\n \nstatic int wilco_ec_debugfs_probe(struct platform_device *pdev)\n{\n\tstruct wilco_ec_device *ec = dev_get_drvdata(pdev->dev.parent);\n\n\tdebug_info = devm_kzalloc(&pdev->dev, sizeof(*debug_info), GFP_KERNEL);\n\tif (!debug_info)\n\t\treturn 0;\n\tdebug_info->ec = ec;\n\tdebug_info->dir = debugfs_create_dir(\"wilco_ec\", NULL);\n\tdebugfs_create_file(\"raw\", 0644, debug_info->dir, NULL, &fops_raw);\n\tdebugfs_create_file(\"h1_gpio\", 0444, debug_info->dir, ec,\n\t\t\t    &fops_h1_gpio);\n\tdebugfs_create_file(\"test_event\", 0200, debug_info->dir, ec,\n\t\t\t    &fops_test_event);\n\n\treturn 0;\n}\n\nstatic int wilco_ec_debugfs_remove(struct platform_device *pdev)\n{\n\tdebugfs_remove_recursive(debug_info->dir);\n\n\treturn 0;\n}\n\nstatic struct platform_driver wilco_ec_debugfs_driver = {\n\t.driver = {\n\t\t.name = DRV_NAME,\n\t},\n\t.probe = wilco_ec_debugfs_probe,\n\t.remove = wilco_ec_debugfs_remove,\n};\n\nmodule_platform_driver(wilco_ec_debugfs_driver);\n\nMODULE_ALIAS(\"platform:\" DRV_NAME);\nMODULE_AUTHOR(\"Nick Crews <ncrews@chromium.org>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"Wilco EC debugfs driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}