{
  "module_name": "telemetry.c",
  "hash_id": "4bcc966195d52d14fea985d3584d2bee8a4b2484e1a6eea44cb6d5500ff70f07",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/chrome/wilco_ec/telemetry.c",
  "human_readable_source": "\n \n\n#include <linux/cdev.h>\n#include <linux/device.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/platform_data/wilco-ec.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/uaccess.h>\n\n#define TELEM_DEV_NAME\t\t\"wilco_telem\"\n#define TELEM_CLASS_NAME\tTELEM_DEV_NAME\n#define DRV_NAME\t\tTELEM_DEV_NAME\n#define TELEM_DEV_NAME_FMT\t(TELEM_DEV_NAME \"%d\")\nstatic struct class telem_class = {\n\t.name\t= TELEM_CLASS_NAME,\n};\n\n \n#define TELEM_MAX_DEV 128\nstatic int telem_major;\nstatic DEFINE_IDA(telem_ida);\n\n \n#define WILCO_EC_TELEM_GET_LOG\t\t\t0x99\n#define WILCO_EC_TELEM_GET_VERSION\t\t0x38\n#define WILCO_EC_TELEM_GET_FAN_INFO\t\t0x2E\n#define WILCO_EC_TELEM_GET_DIAG_INFO\t\t0xFA\n#define WILCO_EC_TELEM_GET_TEMP_INFO\t\t0x95\n#define WILCO_EC_TELEM_GET_TEMP_READ\t\t0x2C\n#define WILCO_EC_TELEM_GET_BATT_EXT_INFO\t0x07\n#define WILCO_EC_TELEM_GET_BATT_PPID_INFO\t0x8A\n\n#define TELEM_ARGS_SIZE_MAX\t30\n\n \n\nstruct telem_args_get_log {\n\tu8 log_type;\n\tu8 log_index;\n} __packed;\n\n \nstruct telem_args_get_version {\n\tu8 index;\n} __packed;\n\nstruct telem_args_get_fan_info {\n\tu8 command;\n\tu8 fan_number;\n\tu8 arg;\n} __packed;\n\nstruct telem_args_get_diag_info {\n\tu8 type;\n\tu8 sub_type;\n} __packed;\n\nstruct telem_args_get_temp_info {\n\tu8 command;\n\tu8 index;\n\tu8 field;\n\tu8 zone;\n} __packed;\n\nstruct telem_args_get_temp_read {\n\tu8 sensor_index;\n} __packed;\n\nstruct telem_args_get_batt_ext_info {\n\tu8 var_args[5];\n} __packed;\n\nstruct telem_args_get_batt_ppid_info {\n\tu8 always1;  \n} __packed;\n\n \nstruct wilco_ec_telem_request {\n\tu8 command;\n\tu8 reserved;\n\tunion {\n\t\tu8 buf[TELEM_ARGS_SIZE_MAX];\n\t\tstruct telem_args_get_log\t\tget_log;\n\t\tstruct telem_args_get_version\t\tget_version;\n\t\tstruct telem_args_get_fan_info\t\tget_fan_info;\n\t\tstruct telem_args_get_diag_info\t\tget_diag_info;\n\t\tstruct telem_args_get_temp_info\t\tget_temp_info;\n\t\tstruct telem_args_get_temp_read\t\tget_temp_read;\n\t\tstruct telem_args_get_batt_ext_info\tget_batt_ext_info;\n\t\tstruct telem_args_get_batt_ppid_info\tget_batt_ppid_info;\n\t} args;\n} __packed;\n\n \nstatic int check_telem_request(struct wilco_ec_telem_request *rq,\n\t\t\t       size_t size)\n{\n\tsize_t max_size = offsetof(struct wilco_ec_telem_request, args);\n\n\tif (rq->reserved)\n\t\treturn -EINVAL;\n\n\tswitch (rq->command) {\n\tcase WILCO_EC_TELEM_GET_LOG:\n\t\tmax_size += sizeof(rq->args.get_log);\n\t\tbreak;\n\tcase WILCO_EC_TELEM_GET_VERSION:\n\t\tmax_size += sizeof(rq->args.get_version);\n\t\tbreak;\n\tcase WILCO_EC_TELEM_GET_FAN_INFO:\n\t\tmax_size += sizeof(rq->args.get_fan_info);\n\t\tbreak;\n\tcase WILCO_EC_TELEM_GET_DIAG_INFO:\n\t\tmax_size += sizeof(rq->args.get_diag_info);\n\t\tbreak;\n\tcase WILCO_EC_TELEM_GET_TEMP_INFO:\n\t\tmax_size += sizeof(rq->args.get_temp_info);\n\t\tbreak;\n\tcase WILCO_EC_TELEM_GET_TEMP_READ:\n\t\tmax_size += sizeof(rq->args.get_temp_read);\n\t\tbreak;\n\tcase WILCO_EC_TELEM_GET_BATT_EXT_INFO:\n\t\tmax_size += sizeof(rq->args.get_batt_ext_info);\n\t\tbreak;\n\tcase WILCO_EC_TELEM_GET_BATT_PPID_INFO:\n\t\tif (rq->args.get_batt_ppid_info.always1 != 1)\n\t\t\treturn -EINVAL;\n\n\t\tmax_size += sizeof(rq->args.get_batt_ppid_info);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn (size <= max_size) ? 0 : -EMSGSIZE;\n}\n\n \nstruct telem_device_data {\n\tstruct device dev;\n\tstruct cdev cdev;\n\tstruct wilco_ec_device *ec;\n\tatomic_t available;\n};\n\n#define TELEM_RESPONSE_SIZE\tEC_MAILBOX_DATA_SIZE\n\n \nstruct telem_session_data {\n\tstruct telem_device_data *dev_data;\n\tstruct wilco_ec_telem_request request;\n\tu8 response[TELEM_RESPONSE_SIZE];\n\tbool has_msg;\n};\n\n \nstatic int telem_open(struct inode *inode, struct file *filp)\n{\n\tstruct telem_device_data *dev_data;\n\tstruct telem_session_data *sess_data;\n\n\t \n\tdev_data = container_of(inode->i_cdev, struct telem_device_data, cdev);\n\tif (atomic_cmpxchg(&dev_data->available, 1, 0) == 0)\n\t\treturn -EBUSY;\n\n\tget_device(&dev_data->dev);\n\n\tsess_data = kzalloc(sizeof(*sess_data), GFP_KERNEL);\n\tif (!sess_data) {\n\t\tatomic_set(&dev_data->available, 1);\n\t\treturn -ENOMEM;\n\t}\n\tsess_data->dev_data = dev_data;\n\tsess_data->has_msg = false;\n\n\tstream_open(inode, filp);\n\tfilp->private_data = sess_data;\n\n\treturn 0;\n}\n\nstatic ssize_t telem_write(struct file *filp, const char __user *buf,\n\t\t\t   size_t count, loff_t *pos)\n{\n\tstruct telem_session_data *sess_data = filp->private_data;\n\tstruct wilco_ec_message msg = {};\n\tint ret;\n\n\tif (count > sizeof(sess_data->request))\n\t\treturn -EMSGSIZE;\n\tmemset(&sess_data->request, 0, sizeof(sess_data->request));\n\tif (copy_from_user(&sess_data->request, buf, count))\n\t\treturn -EFAULT;\n\tret = check_telem_request(&sess_data->request, count);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmemset(sess_data->response, 0, sizeof(sess_data->response));\n\tmsg.type = WILCO_EC_MSG_TELEMETRY;\n\tmsg.request_data = &sess_data->request;\n\tmsg.request_size = sizeof(sess_data->request);\n\tmsg.response_data = sess_data->response;\n\tmsg.response_size = sizeof(sess_data->response);\n\n\tret = wilco_ec_mailbox(sess_data->dev_data->ec, &msg);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret != sizeof(sess_data->response))\n\t\treturn -EMSGSIZE;\n\n\tsess_data->has_msg = true;\n\n\treturn count;\n}\n\nstatic ssize_t telem_read(struct file *filp, char __user *buf, size_t count,\n\t\t\t  loff_t *pos)\n{\n\tstruct telem_session_data *sess_data = filp->private_data;\n\n\tif (!sess_data->has_msg)\n\t\treturn -ENODATA;\n\tif (count > sizeof(sess_data->response))\n\t\treturn -EINVAL;\n\n\tif (copy_to_user(buf, sess_data->response, count))\n\t\treturn -EFAULT;\n\n\tsess_data->has_msg = false;\n\n\treturn count;\n}\n\nstatic int telem_release(struct inode *inode, struct file *filp)\n{\n\tstruct telem_session_data *sess_data = filp->private_data;\n\n\tatomic_set(&sess_data->dev_data->available, 1);\n\tput_device(&sess_data->dev_data->dev);\n\tkfree(sess_data);\n\n\treturn 0;\n}\n\nstatic const struct file_operations telem_fops = {\n\t.open = telem_open,\n\t.write = telem_write,\n\t.read = telem_read,\n\t.release = telem_release,\n\t.llseek = no_llseek,\n\t.owner = THIS_MODULE,\n};\n\n \nstatic void telem_device_free(struct device *d)\n{\n\tstruct telem_device_data *dev_data;\n\n\tdev_data = container_of(d, struct telem_device_data, dev);\n\tkfree(dev_data);\n}\n\n \nstatic int telem_device_probe(struct platform_device *pdev)\n{\n\tstruct telem_device_data *dev_data;\n\tint error, minor;\n\n\t \n\tminor = ida_alloc_max(&telem_ida, TELEM_MAX_DEV-1, GFP_KERNEL);\n\tif (minor < 0) {\n\t\terror = minor;\n\t\tdev_err(&pdev->dev, \"Failed to find minor number: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\tdev_data = kzalloc(sizeof(*dev_data), GFP_KERNEL);\n\tif (!dev_data) {\n\t\tida_simple_remove(&telem_ida, minor);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tdev_data->ec = dev_get_platdata(&pdev->dev);\n\tatomic_set(&dev_data->available, 1);\n\tplatform_set_drvdata(pdev, dev_data);\n\n\t \n\tdev_data->dev.devt = MKDEV(telem_major, minor);\n\tdev_data->dev.class = &telem_class;\n\tdev_data->dev.release = telem_device_free;\n\tdev_set_name(&dev_data->dev, TELEM_DEV_NAME_FMT, minor);\n\tdevice_initialize(&dev_data->dev);\n\n\t ;\n\tcdev_init(&dev_data->cdev, &telem_fops);\n\terror = cdev_device_add(&dev_data->cdev, &dev_data->dev);\n\tif (error) {\n\t\tput_device(&dev_data->dev);\n\t\tida_simple_remove(&telem_ida, minor);\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic int telem_device_remove(struct platform_device *pdev)\n{\n\tstruct telem_device_data *dev_data = platform_get_drvdata(pdev);\n\n\tcdev_device_del(&dev_data->cdev, &dev_data->dev);\n\tida_simple_remove(&telem_ida, MINOR(dev_data->dev.devt));\n\tput_device(&dev_data->dev);\n\n\treturn 0;\n}\n\nstatic struct platform_driver telem_driver = {\n\t.probe = telem_device_probe,\n\t.remove = telem_device_remove,\n\t.driver = {\n\t\t.name = DRV_NAME,\n\t},\n};\n\nstatic int __init telem_module_init(void)\n{\n\tdev_t dev_num = 0;\n\tint ret;\n\n\tret = class_register(&telem_class);\n\tif (ret) {\n\t\tpr_err(DRV_NAME \": Failed registering class: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = alloc_chrdev_region(&dev_num, 0, TELEM_MAX_DEV, TELEM_DEV_NAME);\n\tif (ret) {\n\t\tpr_err(DRV_NAME \": Failed allocating dev numbers: %d\\n\", ret);\n\t\tgoto destroy_class;\n\t}\n\ttelem_major = MAJOR(dev_num);\n\n\tret = platform_driver_register(&telem_driver);\n\tif (ret < 0) {\n\t\tpr_err(DRV_NAME \": Failed registering driver: %d\\n\", ret);\n\t\tgoto unregister_region;\n\t}\n\n\treturn 0;\n\nunregister_region:\n\tunregister_chrdev_region(MKDEV(telem_major, 0), TELEM_MAX_DEV);\ndestroy_class:\n\tclass_unregister(&telem_class);\n\tida_destroy(&telem_ida);\n\treturn ret;\n}\n\nstatic void __exit telem_module_exit(void)\n{\n\tplatform_driver_unregister(&telem_driver);\n\tunregister_chrdev_region(MKDEV(telem_major, 0), TELEM_MAX_DEV);\n\tclass_unregister(&telem_class);\n\tida_destroy(&telem_ida);\n}\n\nmodule_init(telem_module_init);\nmodule_exit(telem_module_exit);\n\nMODULE_AUTHOR(\"Nick Crews <ncrews@chromium.org>\");\nMODULE_DESCRIPTION(\"Wilco EC telemetry driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:\" DRV_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}