{
  "module_name": "sysfs.c",
  "hash_id": "da4192e7a9d39922aa1f5fdb0cc50d8fa14cfcf65df503adb533b3a0625b9817",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/chrome/wilco_ec/sysfs.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/platform_data/wilco-ec.h>\n#include <linux/string.h>\n#include <linux/sysfs.h>\n#include <linux/types.h>\n\n#define CMD_KB_CMOS\t\t\t0x7C\n#define SUB_CMD_KB_CMOS_AUTO_ON\t\t0x03\n\nstruct boot_on_ac_request {\n\tu8 cmd;\t\t\t \n\tu8 reserved1;\n\tu8 sub_cmd;\t\t \n\tu8 reserved3to5[3];\n\tu8 val;\t\t\t \n\tu8 reserved7;\n} __packed;\n\n#define CMD_USB_CHARGE 0x39\n\nenum usb_charge_op {\n\tUSB_CHARGE_GET = 0,\n\tUSB_CHARGE_SET = 1,\n};\n\nstruct usb_charge_request {\n\tu8 cmd;\t\t \n\tu8 reserved;\n\tu8 op;\t\t \n\tu8 val;\t\t \n} __packed;\n\nstruct usb_charge_response {\n\tu8 reserved;\n\tu8 status;\t \n\tu8 val;\t\t \n} __packed;\n\n#define CMD_EC_INFO\t\t\t0x38\nenum get_ec_info_op {\n\tCMD_GET_EC_LABEL\t= 0,\n\tCMD_GET_EC_REV\t\t= 1,\n\tCMD_GET_EC_MODEL\t= 2,\n\tCMD_GET_EC_BUILD_DATE\t= 3,\n};\n\nstruct get_ec_info_req {\n\tu8 cmd;\t\t\t \n\tu8 reserved;\n\tu8 op;\t\t\t \n} __packed;\n\nstruct get_ec_info_resp {\n\tu8 reserved[2];\n\tchar value[9];  \n} __packed;\n\nstatic ssize_t boot_on_ac_store(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct wilco_ec_device *ec = dev_get_drvdata(dev);\n\tstruct boot_on_ac_request rq;\n\tstruct wilco_ec_message msg;\n\tint ret;\n\tu8 val;\n\n\tret = kstrtou8(buf, 10, &val);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (val > 1)\n\t\treturn -EINVAL;\n\n\tmemset(&rq, 0, sizeof(rq));\n\trq.cmd = CMD_KB_CMOS;\n\trq.sub_cmd = SUB_CMD_KB_CMOS_AUTO_ON;\n\trq.val = val;\n\n\tmemset(&msg, 0, sizeof(msg));\n\tmsg.type = WILCO_EC_MSG_LEGACY;\n\tmsg.request_data = &rq;\n\tmsg.request_size = sizeof(rq);\n\tret = wilco_ec_mailbox(ec, &msg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR_WO(boot_on_ac);\n\nstatic ssize_t get_info(struct device *dev, char *buf, enum get_ec_info_op op)\n{\n\tstruct wilco_ec_device *ec = dev_get_drvdata(dev);\n\tstruct get_ec_info_req req = { .cmd = CMD_EC_INFO, .op = op };\n\tstruct get_ec_info_resp resp;\n\tint ret;\n\n\tstruct wilco_ec_message msg = {\n\t\t.type = WILCO_EC_MSG_LEGACY,\n\t\t.request_data = &req,\n\t\t.request_size = sizeof(req),\n\t\t.response_data = &resp,\n\t\t.response_size = sizeof(resp),\n\t};\n\n\tret = wilco_ec_mailbox(ec, &msg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn sysfs_emit(buf, \"%.*s\\n\", (int)sizeof(resp.value), (char *)&resp.value);\n}\n\nstatic ssize_t version_show(struct device *dev, struct device_attribute *attr,\n\t\t\t  char *buf)\n{\n\treturn get_info(dev, buf, CMD_GET_EC_LABEL);\n}\n\nstatic DEVICE_ATTR_RO(version);\n\nstatic ssize_t build_revision_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\treturn get_info(dev, buf, CMD_GET_EC_REV);\n}\n\nstatic DEVICE_ATTR_RO(build_revision);\n\nstatic ssize_t build_date_show(struct device *dev,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\treturn get_info(dev, buf, CMD_GET_EC_BUILD_DATE);\n}\n\nstatic DEVICE_ATTR_RO(build_date);\n\nstatic ssize_t model_number_show(struct device *dev,\n\t\t\t\t struct device_attribute *attr, char *buf)\n{\n\treturn get_info(dev, buf, CMD_GET_EC_MODEL);\n}\n\nstatic DEVICE_ATTR_RO(model_number);\n\nstatic int send_usb_charge(struct wilco_ec_device *ec,\n\t\t\t\tstruct usb_charge_request *rq,\n\t\t\t\tstruct usb_charge_response *rs)\n{\n\tstruct wilco_ec_message msg;\n\tint ret;\n\n\tmemset(&msg, 0, sizeof(msg));\n\tmsg.type = WILCO_EC_MSG_LEGACY;\n\tmsg.request_data = rq;\n\tmsg.request_size = sizeof(*rq);\n\tmsg.response_data = rs;\n\tmsg.response_size = sizeof(*rs);\n\tret = wilco_ec_mailbox(ec, &msg);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (rs->status)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic ssize_t usb_charge_show(struct device *dev,\n\t\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct wilco_ec_device *ec = dev_get_drvdata(dev);\n\tstruct usb_charge_request rq;\n\tstruct usb_charge_response rs;\n\tint ret;\n\n\tmemset(&rq, 0, sizeof(rq));\n\trq.cmd = CMD_USB_CHARGE;\n\trq.op = USB_CHARGE_GET;\n\n\tret = send_usb_charge(ec, &rq, &rs);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn sprintf(buf, \"%d\\n\", rs.val);\n}\n\nstatic ssize_t usb_charge_store(struct device *dev,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     const char *buf, size_t count)\n{\n\tstruct wilco_ec_device *ec = dev_get_drvdata(dev);\n\tstruct usb_charge_request rq;\n\tstruct usb_charge_response rs;\n\tint ret;\n\tu8 val;\n\n\tret = kstrtou8(buf, 10, &val);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (val > 1)\n\t\treturn -EINVAL;\n\n\tmemset(&rq, 0, sizeof(rq));\n\trq.cmd = CMD_USB_CHARGE;\n\trq.op = USB_CHARGE_SET;\n\trq.val = val;\n\n\tret = send_usb_charge(ec, &rq, &rs);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR_RW(usb_charge);\n\nstatic struct attribute *wilco_dev_attrs[] = {\n\t&dev_attr_boot_on_ac.attr,\n\t&dev_attr_build_date.attr,\n\t&dev_attr_build_revision.attr,\n\t&dev_attr_model_number.attr,\n\t&dev_attr_usb_charge.attr,\n\t&dev_attr_version.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group wilco_dev_attr_group = {\n\t.attrs = wilco_dev_attrs,\n};\n\nint wilco_ec_add_sysfs(struct wilco_ec_device *ec)\n{\n\treturn sysfs_create_group(&ec->dev->kobj, &wilco_dev_attr_group);\n}\n\nvoid wilco_ec_remove_sysfs(struct wilco_ec_device *ec)\n{\n\tsysfs_remove_group(&ec->dev->kobj, &wilco_dev_attr_group);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}