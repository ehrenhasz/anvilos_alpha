{
  "module_name": "event.c",
  "hash_id": "e9ed44c88bd08679ffea34e0937c8e1845fd71da083eeff62b845bf53346bf6d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/chrome/wilco_ec/event.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/cdev.h>\n#include <linux/device.h>\n#include <linux/fs.h>\n#include <linux/idr.h>\n#include <linux/io.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/poll.h>\n#include <linux/spinlock.h>\n#include <linux/uaccess.h>\n#include <linux/wait.h>\n\n \n#define EC_ACPI_NOTIFY_EVENT\t\t0x90\n \n#define EC_ACPI_GET_EVENT\t\t\"QSET\"\n \n#define EC_ACPI_MAX_EVENT_WORDS\t\t6\n#define EC_ACPI_MAX_EVENT_SIZE \\\n\t(sizeof(struct ec_event) + (EC_ACPI_MAX_EVENT_WORDS) * sizeof(u16))\n\n \n#define EVENT_DEV_NAME\t\t\"wilco_event\"\n#define EVENT_CLASS_NAME\tEVENT_DEV_NAME\n#define DRV_NAME\t\tEVENT_DEV_NAME\n#define EVENT_DEV_NAME_FMT\t(EVENT_DEV_NAME \"%d\")\nstatic struct class event_class = {\n\t.name\t= EVENT_CLASS_NAME,\n};\n\n \n#define EVENT_MAX_DEV 128\nstatic int event_major;\nstatic DEFINE_IDA(event_ida);\n\n \n#define MAX_NUM_EVENTS 64\n\n \nstruct ec_event {\n\tu16 size;\n\tu16 type;\n\tu16 event[];\n} __packed;\n\n#define ec_event_num_words(ev) (ev->size - 1)\n#define ec_event_size(ev) (sizeof(*ev) + (ec_event_num_words(ev) * sizeof(u16)))\n\n \nstruct ec_event_queue {\n\tint capacity;\n\tint head;\n\tint tail;\n\tstruct ec_event *entries[];\n};\n\n \nstatic int queue_size = 64;\nmodule_param(queue_size, int, 0644);\n\nstatic struct ec_event_queue *event_queue_new(int capacity)\n{\n\tstruct ec_event_queue *q;\n\n\tq = kzalloc(struct_size(q, entries, capacity), GFP_KERNEL);\n\tif (!q)\n\t\treturn NULL;\n\n\tq->capacity = capacity;\n\n\treturn q;\n}\n\nstatic inline bool event_queue_empty(struct ec_event_queue *q)\n{\n\t \n\treturn q->head == q->tail && !q->entries[q->head];\n}\n\nstatic inline bool event_queue_full(struct ec_event_queue *q)\n{\n\t \n\treturn q->head == q->tail && q->entries[q->head];\n}\n\nstatic struct ec_event *event_queue_pop(struct ec_event_queue *q)\n{\n\tstruct ec_event *ev;\n\n\tif (event_queue_empty(q))\n\t\treturn NULL;\n\n\tev = q->entries[q->tail];\n\tq->entries[q->tail] = NULL;\n\tq->tail = (q->tail + 1) % q->capacity;\n\n\treturn ev;\n}\n\n \nstatic struct ec_event *event_queue_push(struct ec_event_queue *q,\n\t\t\t\t\t struct ec_event *ev)\n{\n\tstruct ec_event *popped = NULL;\n\n\tif (event_queue_full(q))\n\t\tpopped = event_queue_pop(q);\n\tq->entries[q->head] = ev;\n\tq->head = (q->head + 1) % q->capacity;\n\n\treturn popped;\n}\n\nstatic void event_queue_free(struct ec_event_queue *q)\n{\n\tstruct ec_event *event;\n\n\twhile ((event = event_queue_pop(q)) != NULL)\n\t\tkfree(event);\n\n\tkfree(q);\n}\n\n \nstruct event_device_data {\n\tstruct ec_event_queue *events;\n\tspinlock_t queue_lock;\n\twait_queue_head_t wq;\n\tstruct device dev;\n\tstruct cdev cdev;\n\tbool exist;\n\tatomic_t available;\n};\n\n \nstatic int enqueue_events(struct acpi_device *adev, const u8 *buf, u32 length)\n{\n\tstruct event_device_data *dev_data = adev->driver_data;\n\tstruct ec_event *event, *queue_event, *old_event;\n\tsize_t num_words, event_size;\n\tu32 offset = 0;\n\n\twhile (offset < length) {\n\t\tevent = (struct ec_event *)(buf + offset);\n\n\t\tnum_words = ec_event_num_words(event);\n\t\tevent_size = ec_event_size(event);\n\t\tif (num_words > EC_ACPI_MAX_EVENT_WORDS) {\n\t\t\tdev_err(&adev->dev, \"Too many event words: %zu > %d\\n\",\n\t\t\t\tnum_words, EC_ACPI_MAX_EVENT_WORDS);\n\t\t\treturn -EOVERFLOW;\n\t\t}\n\n\t\t \n\t\tif ((offset + event_size) > length) {\n\t\t\tdev_err(&adev->dev, \"Event exceeds buffer: %zu > %d\\n\",\n\t\t\t\toffset + event_size, length);\n\t\t\treturn -EOVERFLOW;\n\t\t}\n\n\t\t \n\t\toffset += event_size;\n\n\t\t \n\t\tqueue_event = kmemdup(event, event_size, GFP_KERNEL);\n\t\tif (!queue_event)\n\t\t\treturn -ENOMEM;\n\t\tspin_lock(&dev_data->queue_lock);\n\t\told_event = event_queue_push(dev_data->events, queue_event);\n\t\tspin_unlock(&dev_data->queue_lock);\n\t\tkfree(old_event);\n\t\twake_up_interruptible(&dev_data->wq);\n\t}\n\n\treturn 0;\n}\n\n \nstatic void event_device_notify(struct acpi_device *adev, u32 value)\n{\n\tstruct acpi_buffer event_buffer = { ACPI_ALLOCATE_BUFFER, NULL };\n\tunion acpi_object *obj;\n\tacpi_status status;\n\n\tif (value != EC_ACPI_NOTIFY_EVENT) {\n\t\tdev_err(&adev->dev, \"Invalid event: 0x%08x\\n\", value);\n\t\treturn;\n\t}\n\n\t \n\tstatus = acpi_evaluate_object(adev->handle, EC_ACPI_GET_EVENT,\n\t\t\t\t      NULL, &event_buffer);\n\tif (ACPI_FAILURE(status)) {\n\t\tdev_err(&adev->dev, \"Error executing ACPI method %s()\\n\",\n\t\t\tEC_ACPI_GET_EVENT);\n\t\treturn;\n\t}\n\n\tobj = (union acpi_object *)event_buffer.pointer;\n\tif (!obj) {\n\t\tdev_err(&adev->dev, \"Nothing returned from %s()\\n\",\n\t\t\tEC_ACPI_GET_EVENT);\n\t\treturn;\n\t}\n\tif (obj->type != ACPI_TYPE_BUFFER) {\n\t\tdev_err(&adev->dev, \"Invalid object returned from %s()\\n\",\n\t\t\tEC_ACPI_GET_EVENT);\n\t\tkfree(obj);\n\t\treturn;\n\t}\n\tif (obj->buffer.length < sizeof(struct ec_event)) {\n\t\tdev_err(&adev->dev, \"Invalid buffer length %d from %s()\\n\",\n\t\t\tobj->buffer.length, EC_ACPI_GET_EVENT);\n\t\tkfree(obj);\n\t\treturn;\n\t}\n\n\tenqueue_events(adev, obj->buffer.pointer, obj->buffer.length);\n\tkfree(obj);\n}\n\nstatic int event_open(struct inode *inode, struct file *filp)\n{\n\tstruct event_device_data *dev_data;\n\n\tdev_data = container_of(inode->i_cdev, struct event_device_data, cdev);\n\tif (!dev_data->exist)\n\t\treturn -ENODEV;\n\n\tif (atomic_cmpxchg(&dev_data->available, 1, 0) == 0)\n\t\treturn -EBUSY;\n\n\t \n\tget_device(&dev_data->dev);\n\tstream_open(inode, filp);\n\tfilp->private_data = dev_data;\n\n\treturn 0;\n}\n\nstatic __poll_t event_poll(struct file *filp, poll_table *wait)\n{\n\tstruct event_device_data *dev_data = filp->private_data;\n\t__poll_t mask = 0;\n\n\tpoll_wait(filp, &dev_data->wq, wait);\n\tif (!dev_data->exist)\n\t\treturn EPOLLHUP;\n\tif (!event_queue_empty(dev_data->events))\n\t\tmask |= EPOLLIN | EPOLLRDNORM | EPOLLPRI;\n\treturn mask;\n}\n\n \nstatic ssize_t event_read(struct file *filp, char __user *buf, size_t count,\n\t\t\t  loff_t *pos)\n{\n\tstruct event_device_data *dev_data = filp->private_data;\n\tstruct ec_event *event;\n\tssize_t n_bytes_written = 0;\n\tint err;\n\n\t \n\tif (count != 0 && count < EC_ACPI_MAX_EVENT_SIZE)\n\t\treturn -EINVAL;\n\n\tspin_lock(&dev_data->queue_lock);\n\twhile (event_queue_empty(dev_data->events)) {\n\t\tspin_unlock(&dev_data->queue_lock);\n\t\tif (filp->f_flags & O_NONBLOCK)\n\t\t\treturn -EAGAIN;\n\n\t\terr = wait_event_interruptible(dev_data->wq,\n\t\t\t\t\t!event_queue_empty(dev_data->events) ||\n\t\t\t\t\t!dev_data->exist);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\t \n\t\tif (!dev_data->exist)\n\t\t\treturn -ENODEV;\n\t\tspin_lock(&dev_data->queue_lock);\n\t}\n\tevent = event_queue_pop(dev_data->events);\n\tspin_unlock(&dev_data->queue_lock);\n\tn_bytes_written = ec_event_size(event);\n\tif (copy_to_user(buf, event, n_bytes_written))\n\t\tn_bytes_written = -EFAULT;\n\tkfree(event);\n\n\treturn n_bytes_written;\n}\n\nstatic int event_release(struct inode *inode, struct file *filp)\n{\n\tstruct event_device_data *dev_data = filp->private_data;\n\n\tatomic_set(&dev_data->available, 1);\n\tput_device(&dev_data->dev);\n\n\treturn 0;\n}\n\nstatic const struct file_operations event_fops = {\n\t.open = event_open,\n\t.poll  = event_poll,\n\t.read = event_read,\n\t.release = event_release,\n\t.llseek = no_llseek,\n\t.owner = THIS_MODULE,\n};\n\n \nstatic void free_device_data(struct device *d)\n{\n\tstruct event_device_data *dev_data;\n\n\tdev_data = container_of(d, struct event_device_data, dev);\n\tevent_queue_free(dev_data->events);\n\tkfree(dev_data);\n}\n\nstatic void hangup_device(struct event_device_data *dev_data)\n{\n\tdev_data->exist = false;\n\t \n\twake_up_interruptible(&dev_data->wq);\n\tput_device(&dev_data->dev);\n}\n\n \nstatic int event_device_add(struct acpi_device *adev)\n{\n\tstruct event_device_data *dev_data;\n\tint error, minor;\n\n\tminor = ida_alloc_max(&event_ida, EVENT_MAX_DEV-1, GFP_KERNEL);\n\tif (minor < 0) {\n\t\terror = minor;\n\t\tdev_err(&adev->dev, \"Failed to find minor number: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\tdev_data = kzalloc(sizeof(*dev_data), GFP_KERNEL);\n\tif (!dev_data) {\n\t\terror = -ENOMEM;\n\t\tgoto free_minor;\n\t}\n\n\t \n\tadev->driver_data = dev_data;\n\tdev_data->events = event_queue_new(queue_size);\n\tif (!dev_data->events) {\n\t\tkfree(dev_data);\n\t\terror = -ENOMEM;\n\t\tgoto free_minor;\n\t}\n\tspin_lock_init(&dev_data->queue_lock);\n\tinit_waitqueue_head(&dev_data->wq);\n\tdev_data->exist = true;\n\tatomic_set(&dev_data->available, 1);\n\n\t \n\tdev_data->dev.devt = MKDEV(event_major, minor);\n\tdev_data->dev.class = &event_class;\n\tdev_data->dev.release = free_device_data;\n\tdev_set_name(&dev_data->dev, EVENT_DEV_NAME_FMT, minor);\n\tdevice_initialize(&dev_data->dev);\n\n\t \n\tcdev_init(&dev_data->cdev, &event_fops);\n\terror = cdev_device_add(&dev_data->cdev, &dev_data->dev);\n\tif (error)\n\t\tgoto free_dev_data;\n\n\treturn 0;\n\nfree_dev_data:\n\thangup_device(dev_data);\nfree_minor:\n\tida_simple_remove(&event_ida, minor);\n\treturn error;\n}\n\nstatic void event_device_remove(struct acpi_device *adev)\n{\n\tstruct event_device_data *dev_data = adev->driver_data;\n\n\tcdev_device_del(&dev_data->cdev, &dev_data->dev);\n\tida_simple_remove(&event_ida, MINOR(dev_data->dev.devt));\n\thangup_device(dev_data);\n}\n\nstatic const struct acpi_device_id event_acpi_ids[] = {\n\t{ \"GOOG000D\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(acpi, event_acpi_ids);\n\nstatic struct acpi_driver event_driver = {\n\t.name = DRV_NAME,\n\t.class = DRV_NAME,\n\t.ids = event_acpi_ids,\n\t.ops = {\n\t\t.add = event_device_add,\n\t\t.notify = event_device_notify,\n\t\t.remove = event_device_remove,\n\t},\n\t.owner = THIS_MODULE,\n};\n\nstatic int __init event_module_init(void)\n{\n\tdev_t dev_num = 0;\n\tint ret;\n\n\tret = class_register(&event_class);\n\tif (ret) {\n\t\tpr_err(DRV_NAME \": Failed registering class: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = alloc_chrdev_region(&dev_num, 0, EVENT_MAX_DEV, EVENT_DEV_NAME);\n\tif (ret) {\n\t\tpr_err(DRV_NAME \": Failed allocating dev numbers: %d\\n\", ret);\n\t\tgoto destroy_class;\n\t}\n\tevent_major = MAJOR(dev_num);\n\n\tret = acpi_bus_register_driver(&event_driver);\n\tif (ret < 0) {\n\t\tpr_err(DRV_NAME \": Failed registering driver: %d\\n\", ret);\n\t\tgoto unregister_region;\n\t}\n\n\treturn 0;\n\nunregister_region:\n\tunregister_chrdev_region(MKDEV(event_major, 0), EVENT_MAX_DEV);\ndestroy_class:\n\tclass_unregister(&event_class);\n\tida_destroy(&event_ida);\n\treturn ret;\n}\n\nstatic void __exit event_module_exit(void)\n{\n\tacpi_bus_unregister_driver(&event_driver);\n\tunregister_chrdev_region(MKDEV(event_major, 0), EVENT_MAX_DEV);\n\tclass_unregister(&event_class);\n\tida_destroy(&event_ida);\n}\n\nmodule_init(event_module_init);\nmodule_exit(event_module_exit);\n\nMODULE_AUTHOR(\"Nick Crews <ncrews@chromium.org>\");\nMODULE_DESCRIPTION(\"Wilco EC ACPI event driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:\" DRV_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}