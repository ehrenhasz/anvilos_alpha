{
  "module_name": "cros_typec_switch.c",
  "hash_id": "e745357078f52ac9bd9e564295bba19c4b3a995427863cb3225348d0151897e9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/chrome/cros_typec_switch.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/module.h>\n#include <linux/platform_data/cros_ec_commands.h>\n#include <linux/platform_data/cros_ec_proto.h>\n#include <linux/platform_device.h>\n#include <linux/usb/typec_altmode.h>\n#include <linux/usb/typec_dp.h>\n#include <linux/usb/typec_mux.h>\n#include <linux/usb/typec_retimer.h>\n\n \nstruct cros_typec_port {\n\tint port_num;\n\tstruct typec_mux_dev *mode_switch;\n\tstruct typec_retimer *retimer;\n\tstruct cros_typec_switch_data *sdata;\n};\n\n \nstruct cros_typec_switch_data {\n\tstruct device *dev;\n\tstruct cros_ec_device *ec;\n\tstruct cros_typec_port *ports[EC_USB_PD_MAX_PORTS];\n};\n\nstatic int cros_typec_cmd_mux_set(struct cros_typec_switch_data *sdata, int port_num, u8 index,\n\t\t\t\t  u8 state)\n{\n\tstruct ec_params_typec_control req = {\n\t\t.port = port_num,\n\t\t.command = TYPEC_CONTROL_COMMAND_USB_MUX_SET,\n\t\t.mux_params = {\n\t\t\t.mux_index = index,\n\t\t\t.mux_flags = state,\n\t\t},\n\t};\n\n\treturn cros_ec_cmd(sdata->ec, 0, EC_CMD_TYPEC_CONTROL, &req, sizeof(req), NULL, 0);\n}\n\nstatic int cros_typec_get_mux_state(unsigned long mode, struct typec_altmode *alt)\n{\n\tint ret = -EOPNOTSUPP;\n\tu8 pin_assign;\n\n\tif (mode == TYPEC_STATE_SAFE) {\n\t\tret = USB_PD_MUX_SAFE_MODE;\n\t} else if (mode == TYPEC_STATE_USB) {\n\t\tret = USB_PD_MUX_USB_ENABLED;\n\t} else if (alt && alt->svid == USB_TYPEC_DP_SID) {\n\t\tret = USB_PD_MUX_DP_ENABLED;\n\t\tpin_assign = mode - TYPEC_STATE_MODAL;\n\t\tif (pin_assign & DP_PIN_ASSIGN_D)\n\t\t\tret |= USB_PD_MUX_USB_ENABLED;\n\t}\n\n\treturn ret;\n}\n\nstatic int cros_typec_send_clear_event(struct cros_typec_switch_data *sdata, int port_num,\n\t\t\t\t       u32 events_mask)\n{\n\tstruct ec_params_typec_control req = {\n\t\t.port = port_num,\n\t\t.command = TYPEC_CONTROL_COMMAND_CLEAR_EVENTS,\n\t\t.clear_events_mask = events_mask,\n\t};\n\n\treturn cros_ec_cmd(sdata->ec, 0, EC_CMD_TYPEC_CONTROL, &req, sizeof(req), NULL, 0);\n}\n\nstatic bool cros_typec_check_event(struct cros_typec_switch_data *sdata, int port_num, u32 mask)\n{\n\tstruct ec_response_typec_status resp;\n\tstruct ec_params_typec_status req = {\n\t\t.port = port_num,\n\t};\n\tint ret;\n\n\tret = cros_ec_cmd(sdata->ec, 0, EC_CMD_TYPEC_STATUS, &req, sizeof(req),\n\t\t\t  &resp, sizeof(resp));\n\tif (ret < 0) {\n\t\tdev_warn(sdata->dev, \"EC_CMD_TYPEC_STATUS failed for port: %d\\n\", port_num);\n\t\treturn false;\n\t}\n\n\tif (resp.events & mask)\n\t\treturn true;\n\n\treturn false;\n}\n\n \nstatic int cros_typec_configure_mux(struct cros_typec_switch_data *sdata, int port_num, int index,\n\t\t\t\t    unsigned long mode, struct typec_altmode *alt)\n{\n\tunsigned long end;\n\tu32 event_mask;\n\tu8 mux_state;\n\tint ret;\n\n\tret = cros_typec_get_mux_state(mode, alt);\n\tif (ret < 0)\n\t\treturn ret;\n\tmux_state = (u8)ret;\n\n\t \n\tif (index == 0)\n\t\tevent_mask = PD_STATUS_EVENT_MUX_0_SET_DONE;\n\telse\n\t\tevent_mask = PD_STATUS_EVENT_MUX_1_SET_DONE;\n\n\tret = cros_typec_send_clear_event(sdata, port_num, event_mask);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = cros_typec_cmd_mux_set(sdata, port_num, index, mux_state);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tend = jiffies + msecs_to_jiffies(1000);\n\tdo {\n\t\tif (cros_typec_check_event(sdata, port_num, event_mask))\n\t\t\treturn 0;\n\n\t\tusleep_range(500, 1000);\n\t} while (time_before(jiffies, end));\n\n\tdev_err(sdata->dev, \"Timed out waiting for mux set done on index: %d, state: %d\\n\",\n\t\tindex, mux_state);\n\n\treturn -ETIMEDOUT;\n}\n\nstatic int cros_typec_mode_switch_set(struct typec_mux_dev *mode_switch,\n\t\t\t\t      struct typec_mux_state *state)\n{\n\tstruct cros_typec_port *port = typec_mux_get_drvdata(mode_switch);\n\n\t \n\treturn cros_typec_configure_mux(port->sdata, port->port_num, 0, state->mode, state->alt);\n}\n\nstatic int cros_typec_retimer_set(struct typec_retimer *retimer, struct typec_retimer_state *state)\n{\n\tstruct cros_typec_port *port = typec_retimer_get_drvdata(retimer);\n\n\t \n\treturn cros_typec_configure_mux(port->sdata, port->port_num, 1, state->mode, state->alt);\n}\n\nstatic void cros_typec_unregister_switches(struct cros_typec_switch_data *sdata)\n{\n\tint i;\n\n\tfor (i = 0; i < EC_USB_PD_MAX_PORTS; i++) {\n\t\tif (!sdata->ports[i])\n\t\t\tcontinue;\n\t\ttypec_retimer_unregister(sdata->ports[i]->retimer);\n\t\ttypec_mux_unregister(sdata->ports[i]->mode_switch);\n\t}\n}\n\nstatic int cros_typec_register_mode_switch(struct cros_typec_port *port,\n\t\t\t\t\t   struct fwnode_handle *fwnode)\n{\n\tstruct typec_mux_desc mode_switch_desc = {\n\t\t.fwnode = fwnode,\n\t\t.drvdata = port,\n\t\t.name = fwnode_get_name(fwnode),\n\t\t.set = cros_typec_mode_switch_set,\n\t};\n\n\tport->mode_switch = typec_mux_register(port->sdata->dev, &mode_switch_desc);\n\n\treturn PTR_ERR_OR_ZERO(port->mode_switch);\n}\n\nstatic int cros_typec_register_retimer(struct cros_typec_port *port, struct fwnode_handle *fwnode)\n{\n\tstruct typec_retimer_desc retimer_desc = {\n\t\t.fwnode = fwnode,\n\t\t.drvdata = port,\n\t\t.name = fwnode_get_name(fwnode),\n\t\t.set = cros_typec_retimer_set,\n\t};\n\n\tport->retimer = typec_retimer_register(port->sdata->dev, &retimer_desc);\n\n\treturn PTR_ERR_OR_ZERO(port->retimer);\n}\n\nstatic int cros_typec_register_switches(struct cros_typec_switch_data *sdata)\n{\n\tstruct cros_typec_port *port;\n\tstruct device *dev = sdata->dev;\n\tstruct fwnode_handle *fwnode;\n\tstruct acpi_device *adev;\n\tunsigned long long index;\n\tint nports, ret;\n\n\tnports = device_get_child_node_count(dev);\n\tif (nports == 0) {\n\t\tdev_err(dev, \"No switch devices found.\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tdevice_for_each_child_node(dev, fwnode) {\n\t\tport = devm_kzalloc(dev, sizeof(*port), GFP_KERNEL);\n\t\tif (!port) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_switch;\n\t\t}\n\n\t\tadev = to_acpi_device_node(fwnode);\n\t\tif (!adev) {\n\t\t\tdev_err(fwnode->dev, \"Couldn't get ACPI device handle\\n\");\n\t\t\tret = -ENODEV;\n\t\t\tgoto err_switch;\n\t\t}\n\n\t\tret = acpi_evaluate_integer(adev->handle, \"_ADR\", NULL, &index);\n\t\tif (ACPI_FAILURE(ret)) {\n\t\t\tdev_err(fwnode->dev, \"_ADR wasn't evaluated\\n\");\n\t\t\tret = -ENODATA;\n\t\t\tgoto err_switch;\n\t\t}\n\n\t\tif (index >= EC_USB_PD_MAX_PORTS) {\n\t\t\tdev_err(fwnode->dev, \"Invalid port index number: %llu\\n\", index);\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_switch;\n\t\t}\n\t\tport->sdata = sdata;\n\t\tport->port_num = index;\n\t\tsdata->ports[index] = port;\n\n\t\tif (fwnode_property_present(fwnode, \"retimer-switch\")) {\n\t\t\tret = cros_typec_register_retimer(port, fwnode);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(dev, \"Retimer switch register failed\\n\");\n\t\t\t\tgoto err_switch;\n\t\t\t}\n\n\t\t\tdev_dbg(dev, \"Retimer switch registered for index %llu\\n\", index);\n\t\t}\n\n\t\tif (!fwnode_property_present(fwnode, \"mode-switch\"))\n\t\t\tcontinue;\n\n\t\tret = cros_typec_register_mode_switch(port, fwnode);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Mode switch register failed\\n\");\n\t\t\tgoto err_switch;\n\t\t}\n\n\t\tdev_dbg(dev, \"Mode switch registered for index %llu\\n\", index);\n\t}\n\n\treturn 0;\nerr_switch:\n\tfwnode_handle_put(fwnode);\n\tcros_typec_unregister_switches(sdata);\n\treturn ret;\n}\n\nstatic int cros_typec_switch_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct cros_typec_switch_data *sdata;\n\n\tsdata = devm_kzalloc(dev, sizeof(*sdata), GFP_KERNEL);\n\tif (!sdata)\n\t\treturn -ENOMEM;\n\n\tsdata->dev = dev;\n\tsdata->ec = dev_get_drvdata(pdev->dev.parent);\n\n\tplatform_set_drvdata(pdev, sdata);\n\n\treturn cros_typec_register_switches(sdata);\n}\n\nstatic int cros_typec_switch_remove(struct platform_device *pdev)\n{\n\tstruct cros_typec_switch_data *sdata = platform_get_drvdata(pdev);\n\n\tcros_typec_unregister_switches(sdata);\n\treturn 0;\n}\n\n#ifdef CONFIG_ACPI\nstatic const struct acpi_device_id cros_typec_switch_acpi_id[] = {\n\t{ \"GOOG001A\", 0 },\n\t{}\n};\nMODULE_DEVICE_TABLE(acpi, cros_typec_switch_acpi_id);\n#endif\n\nstatic struct platform_driver cros_typec_switch_driver = {\n\t.driver\t= {\n\t\t.name = \"cros-typec-switch\",\n\t\t.acpi_match_table = ACPI_PTR(cros_typec_switch_acpi_id),\n\t},\n\t.probe = cros_typec_switch_probe,\n\t.remove = cros_typec_switch_remove,\n};\n\nmodule_platform_driver(cros_typec_switch_driver);\n\nMODULE_AUTHOR(\"Prashant Malani <pmalani@chromium.org>\");\nMODULE_DESCRIPTION(\"ChromeOS EC Type-C Switch control\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}