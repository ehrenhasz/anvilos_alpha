{
  "module_name": "Kconfig",
  "hash_id": "7d64aa339db4cff9cdce203d7e4ab1af4b06ae211fee5187cd65bfea17a6b28d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/chrome/Kconfig",
  "human_readable_source": "# SPDX-License-Identifier: GPL-2.0-only\n#\n# Platform support for Chrome OS hardware (Chromebooks and Chromeboxes)\n#\n\nmenuconfig CHROME_PLATFORMS\n\tbool \"Platform support for Chrome hardware\"\n\tdepends on X86 || ARM || ARM64 || COMPILE_TEST\n\thelp\n\t  Say Y here to get to see options for platform support for\n\t  various Chromebooks and Chromeboxes. This option alone does\n\t  not add any kernel code.\n\n\t  If you say N, all options in this submenu will be skipped and disabled.\n\nif CHROME_PLATFORMS\n\nconfig CHROMEOS_ACPI\n\ttristate \"ChromeOS specific ACPI extensions\"\n\tdepends on ACPI\n\thelp\n\t  This driver provides the firmware interface for the services\n\t  exported through the ChromeOS interfaces when using ChromeOS\n\t  ACPI firmware.\n\n\t  If you have an ACPI-compatible Chromebook, say Y or M here.\n\t  The module will be called chromeos_acpi.\n\nconfig CHROMEOS_LAPTOP\n\ttristate \"Chrome OS Laptop\"\n\tdepends on I2C && DMI && X86\n\thelp\n\t  This driver instantiates i2c and smbus devices such as\n\t  light sensors and touchpads.\n\n\t  If you have a supported Chromebook, choose Y or M here.\n\t  The module will be called chromeos_laptop.\n\nconfig CHROMEOS_PSTORE\n\ttristate \"Chrome OS pstore support\"\n\tdepends on X86\n\thelp\n\t  This module instantiates the persistent storage on x86 ChromeOS\n\t  devices. It can be used to store away console logs and crash\n\t  information across reboots.\n\n\t  The range of memory used is 0xf00000-0x1000000, traditionally\n\t  the memory used to back VGA controller memory.\n\n\t  If you have a supported Chromebook, choose Y or M here.\n\t  The module will be called chromeos_pstore.\n\nconfig CHROMEOS_TBMC\n\ttristate \"ChromeOS Tablet Switch Controller\"\n\tdepends on ACPI\n\tdepends on INPUT\n\thelp\n\t  This option adds a driver for the tablet switch on\n\t  select Chrome OS systems.\n\n\t  To compile this driver as a module, choose M here: the\n\t  module will be called chromeos_tbmc.\n\nconfig CROS_EC\n\ttristate \"ChromeOS Embedded Controller\"\n\tselect CROS_EC_PROTO\n\tdepends on X86 || ARM || ARM64 || COMPILE_TEST\n\thelp\n\t  If you say Y here you get support for the ChromeOS Embedded\n\t  Controller (EC) providing keyboard, battery and power services.\n\t  You also need to enable the driver for the bus you are using. The\n\t  protocol for talking to the EC is defined by the bus driver.\n\n\t  To compile this driver as a module, choose M here: the\n\t  module will be called cros_ec.\n\nconfig CROS_EC_I2C\n\ttristate \"ChromeOS Embedded Controller (I2C)\"\n\tdepends on CROS_EC && I2C\n\n\thelp\n\t  If you say Y here, you get support for talking to the ChromeOS\n\t  EC through an I2C bus. This uses a simple byte-level protocol with\n\t  a checksum. Failing accesses will be retried three times to\n\t  improve reliability.\n\nconfig CROS_EC_RPMSG\n\ttristate \"ChromeOS Embedded Controller (rpmsg)\"\n\tdepends on CROS_EC && RPMSG && OF\n\thelp\n\t  If you say Y here, you get support for talking to the ChromeOS EC\n\t  through rpmsg. This uses a simple byte-level protocol with a\n\t  checksum. Also since there's no addition EC-to-host interrupt, this\n\t  use a byte in message to distinguish host event from host command.\n\n\t  To compile this driver as a module, choose M here: the\n\t  module will be called cros_ec_rpmsg.\n\nconfig CROS_EC_ISHTP\n\ttristate \"ChromeOS Embedded Controller (ISHTP)\"\n\tdepends on CROS_EC\n\tdepends on INTEL_ISH_HID\n\thelp\n\t  If you say Y here, you get support for talking to the ChromeOS EC\n\t  firmware running on Intel Integrated Sensor Hub (ISH), using the\n\t  ISH Transport protocol (ISH-TP). This uses a simple byte-level\n\t  protocol with a checksum.\n\n\t  To compile this driver as a module, choose M here: the\n\t  module will be called cros_ec_ishtp.\n\nconfig CROS_EC_SPI\n\ttristate \"ChromeOS Embedded Controller (SPI)\"\n\tdepends on CROS_EC && SPI\n\n\thelp\n\t  If you say Y here, you get support for talking to the ChromeOS EC\n\t  through a SPI bus, using a byte-level protocol. Since the EC's\n\t  response time cannot be guaranteed, we support ignoring\n\t  'pre-amble' bytes before the response actually starts.\n\nconfig CROS_EC_UART\n\ttristate \"ChromeOS Embedded Controller (UART)\"\n\tdepends on CROS_EC && ACPI && SERIAL_DEV_BUS\n\thelp\n\t  If you say Y here, you get support for talking to the ChromeOS EC\n\t  through a UART, using a byte-level protocol.\n\n\t  To compile this driver as a module, choose M here: the\n\t  module will be called cros_ec_uart.\n\nconfig CROS_EC_LPC\n\ttristate \"ChromeOS Embedded Controller (LPC)\"\n\tdepends on CROS_EC && ACPI && (X86 || COMPILE_TEST)\n\thelp\n\t  If you say Y here, you get support for talking to the ChromeOS EC\n\t  over an LPC bus, including the LPC Microchip EC (MEC) variant.\n\t  This uses a simple byte-level protocol with a checksum. This is\n\t  used for userspace access only. The kernel typically has its own\n\t  communication methods.\n\n\t  To compile this driver as a module, choose M here: the\n\t  module will be called cros_ec_lpcs.\n\nconfig CROS_EC_PROTO\n\tbool\n\thelp\n\t  ChromeOS EC communication protocol helpers.\n\nconfig CROS_KBD_LED_BACKLIGHT\n\ttristate \"Backlight LED support for Chrome OS keyboards\"\n\tdepends on LEDS_CLASS && (ACPI || CROS_EC)\n\thelp\n\t  This option enables support for the keyboard backlight LEDs on\n\t  select Chrome OS systems.\n\n\t  To compile this driver as a module, choose M here: the\n\t  module will be called cros_kbd_led_backlight.\n\nconfig CROS_EC_CHARDEV\n\ttristate \"ChromeOS EC miscdevice\"\n\tdepends on MFD_CROS_EC_DEV\n\tdefault MFD_CROS_EC_DEV\n\thelp\n\t  This driver adds file operations support to talk with the\n\t  ChromeOS EC from userspace via a character device.\n\n\t  To compile this driver as a module, choose M here: the\n\t  module will be called cros_ec_chardev.\n\nconfig CROS_EC_LIGHTBAR\n\ttristate \"Chromebook Pixel's lightbar support\"\n\tdepends on MFD_CROS_EC_DEV\n\tdefault MFD_CROS_EC_DEV\n\thelp\n\t  This option exposes the Chromebook Pixel's lightbar to\n\t  userspace.\n\n\t  To compile this driver as a module, choose M here: the\n\t  module will be called cros_ec_lightbar.\n\nconfig CROS_EC_VBC\n\ttristate \"ChromeOS EC vboot context support\"\n\tdepends on MFD_CROS_EC_DEV && OF\n\tdefault MFD_CROS_EC_DEV\n\thelp\n\t  This option exposes the ChromeOS EC vboot context nvram to\n\t  userspace.\n\n\t  To compile this driver as a module, choose M here: the\n\t  module will be called cros_ec_vbc.\n\nconfig CROS_EC_DEBUGFS\n\ttristate \"Export ChromeOS EC internals in DebugFS\"\n\tdepends on MFD_CROS_EC_DEV && DEBUG_FS\n\tdefault MFD_CROS_EC_DEV\n\thelp\n\t  This option exposes the ChromeOS EC device internals to\n\t  userspace.\n\n\t  To compile this driver as a module, choose M here: the\n\t  module will be called cros_ec_debugfs.\n\nconfig CROS_EC_SENSORHUB\n\ttristate \"ChromeOS EC MEMS Sensor Hub\"\n\tdepends on MFD_CROS_EC_DEV\n\tdefault MFD_CROS_EC_DEV\n\thelp\n\t  Allow loading IIO sensors. This driver is loaded by MFD and will in\n\t  turn query the EC and register the sensors.\n\t  It also spreads the sensor data coming from the EC to the IIO sensor\n\t  object.\n\n\t  To compile this driver as a module, choose M here: the\n\t  module will be called cros_ec_sensorhub.\n\nconfig CROS_EC_SYSFS\n\ttristate \"ChromeOS EC control and information through sysfs\"\n\tdepends on MFD_CROS_EC_DEV && SYSFS\n\tdefault MFD_CROS_EC_DEV\n\thelp\n\t  This option exposes some sysfs attributes to control and get\n\t  information from ChromeOS EC.\n\n\t  To compile this driver as a module, choose M here: the\n\t  module will be called cros_ec_sysfs.\n\nconfig CROS_EC_TYPEC\n\ttristate \"ChromeOS EC Type-C Connector Control\"\n\tdepends on MFD_CROS_EC_DEV && TYPEC\n\tdepends on CROS_USBPD_NOTIFY\n\tdepends on USB_ROLE_SWITCH\n\tdefault MFD_CROS_EC_DEV\n\thelp\n\t  If you say Y here, you get support for accessing Type C connector\n\t  information from the Chrome OS EC.\n\n\t  To compile this driver as a module, choose M here: the module will be\n\t  called cros-ec-typec.\n\nconfig CROS_HPS_I2C\n\ttristate \"ChromeOS HPS device\"\n\tdepends on HID && I2C && PM\n\thelp\n\t  Say Y here if you want to enable support for the ChromeOS\n\t  human presence sensor (HPS), attached via I2C. The driver supports a\n\t  sensor connected to the I2C bus and exposes it as a character device.\n\t  To save power, the sensor is automatically powered down when no\n\t  clients are accessing it.\n\nconfig CROS_USBPD_LOGGER\n\ttristate \"Logging driver for USB PD charger\"\n\tdepends on CHARGER_CROS_USBPD\n\tdefault y\n\tselect RTC_LIB\n\thelp\n\t  This option enables support for logging event data for the USB PD charger\n\t  available in the Embedded Controller on ChromeOS systems.\n\n\t  To compile this driver as a module, choose M here: the\n\t  module will be called cros_usbpd_logger.\n\nconfig CROS_USBPD_NOTIFY\n\ttristate \"ChromeOS Type-C power delivery event notifier\"\n\tdepends on MFD_CROS_EC_DEV\n\tdefault MFD_CROS_EC_DEV\n\thelp\n\t  If you say Y here, you get support for Type-C PD event notifications\n\t  from the ChromeOS EC. On ACPI platorms this driver will bind to the\n\t  GOOG0003 ACPI device, and on platforms which don't have this device it\n\t  will get initialized on ECs which support the feature\n\t  EC_FEATURE_USB_PD.\n\n\t  To compile this driver as a module, choose M here: the\n\t  module will be called cros_usbpd_notify.\n\nconfig CHROMEOS_PRIVACY_SCREEN\n\ttristate \"ChromeOS Privacy Screen support\"\n\tdepends on ACPI\n\tdepends on DRM\n\tselect DRM_PRIVACY_SCREEN\n\thelp\n\t  This driver provides the support needed for the in-built electronic\n\t  privacy screen that is present on some ChromeOS devices. When enabled,\n\t  this should probably always be built into the kernel to avoid or\n\t  minimize drm probe deferral.\n\nconfig CROS_TYPEC_SWITCH\n\ttristate \"ChromeOS EC Type-C Switch Control\"\n\tdepends on MFD_CROS_EC_DEV && TYPEC && ACPI\n\tdefault MFD_CROS_EC_DEV\n\thelp\n\t  If you say Y here, you get support for configuring the ChromeOS EC Type-C\n\t  muxes and retimers.\n\n\t  To compile this driver as a module, choose M here: the module will be\n\t  called cros_typec_switch.\n\nsource \"drivers/platform/chrome/wilco_ec/Kconfig\"\n\n# Kunit test cases\nconfig CROS_KUNIT\n\ttristate \"Kunit tests for ChromeOS\" if !KUNIT_ALL_TESTS\n\tdepends on KUNIT && CROS_EC\n\tdefault KUNIT_ALL_TESTS\n\tselect CROS_EC_PROTO\n\thelp\n\t  ChromeOS Kunit tests.\n\nendif # CHROMEOS_PLATFORMS\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}