{
  "module_name": "cros_ec_sensorhub.c",
  "hash_id": "bdb3bdfc51e6fea9eb352d5e8de44eb19bf4a43d15fbf43d95aa9e16a8d035ff",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/chrome/cros_ec_sensorhub.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/module.h>\n#include <linux/platform_data/cros_ec_commands.h>\n#include <linux/platform_data/cros_ec_proto.h>\n#include <linux/platform_data/cros_ec_sensorhub.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define DRV_NAME\t\t\"cros-ec-sensorhub\"\n\nstatic void cros_ec_sensorhub_free_sensor(void *arg)\n{\n\tstruct platform_device *pdev = arg;\n\n\tplatform_device_unregister(pdev);\n}\n\nstatic int cros_ec_sensorhub_allocate_sensor(struct device *parent,\n\t\t\t\t\t     char *sensor_name,\n\t\t\t\t\t     int sensor_num)\n{\n\tstruct cros_ec_sensor_platform sensor_platforms = {\n\t\t.sensor_num = sensor_num,\n\t};\n\tstruct platform_device *pdev;\n\n\tpdev = platform_device_register_data(parent, sensor_name,\n\t\t\t\t\t     PLATFORM_DEVID_AUTO,\n\t\t\t\t\t     &sensor_platforms,\n\t\t\t\t\t     sizeof(sensor_platforms));\n\tif (IS_ERR(pdev))\n\t\treturn PTR_ERR(pdev);\n\n\treturn devm_add_action_or_reset(parent,\n\t\t\t\t\tcros_ec_sensorhub_free_sensor,\n\t\t\t\t\tpdev);\n}\n\nstatic int cros_ec_sensorhub_register(struct device *dev,\n\t\t\t\t      struct cros_ec_sensorhub *sensorhub)\n{\n\tint sensor_type[MOTIONSENSE_TYPE_MAX] = { 0 };\n\tstruct cros_ec_command *msg = sensorhub->msg;\n\tstruct cros_ec_dev *ec = sensorhub->ec;\n\tint ret, i;\n\tchar *name;\n\n\n\tmsg->version = 1;\n\tmsg->insize = sizeof(struct ec_response_motion_sense);\n\tmsg->outsize = sizeof(struct ec_params_motion_sense);\n\n\tfor (i = 0; i < sensorhub->sensor_num; i++) {\n\t\tsensorhub->params->cmd = MOTIONSENSE_CMD_INFO;\n\t\tsensorhub->params->info.sensor_num = i;\n\n\t\tret = cros_ec_cmd_xfer_status(ec->ec_dev, msg);\n\t\tif (ret < 0) {\n\t\t\tdev_warn(dev, \"no info for EC sensor %d : %d/%d\\n\",\n\t\t\t\t i, ret, msg->result);\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (sensorhub->resp->info.type) {\n\t\tcase MOTIONSENSE_TYPE_ACCEL:\n\t\t\tname = \"cros-ec-accel\";\n\t\t\tbreak;\n\t\tcase MOTIONSENSE_TYPE_BARO:\n\t\t\tname = \"cros-ec-baro\";\n\t\t\tbreak;\n\t\tcase MOTIONSENSE_TYPE_GYRO:\n\t\t\tname = \"cros-ec-gyro\";\n\t\t\tbreak;\n\t\tcase MOTIONSENSE_TYPE_MAG:\n\t\t\tname = \"cros-ec-mag\";\n\t\t\tbreak;\n\t\tcase MOTIONSENSE_TYPE_PROX:\n\t\t\tname = \"cros-ec-prox\";\n\t\t\tbreak;\n\t\tcase MOTIONSENSE_TYPE_LIGHT:\n\t\t\tname = \"cros-ec-light\";\n\t\t\tbreak;\n\t\tcase MOTIONSENSE_TYPE_ACTIVITY:\n\t\t\tname = \"cros-ec-activity\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_warn(dev, \"unknown type %d\\n\",\n\t\t\t\t sensorhub->resp->info.type);\n\t\t\tcontinue;\n\t\t}\n\n\t\tret = cros_ec_sensorhub_allocate_sensor(dev, name, i);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tsensor_type[sensorhub->resp->info.type]++;\n\t}\n\n\tif (sensor_type[MOTIONSENSE_TYPE_ACCEL] >= 2)\n\t\tec->has_kb_wake_angle = true;\n\n\tif (cros_ec_check_features(ec,\n\t\t\t\t   EC_FEATURE_REFINED_TABLET_MODE_HYSTERESIS)) {\n\t\tret = cros_ec_sensorhub_allocate_sensor(dev,\n\t\t\t\t\t\t\t\"cros-ec-lid-angle\",\n\t\t\t\t\t\t\t0);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int cros_ec_sensorhub_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct cros_ec_dev *ec = dev_get_drvdata(dev->parent);\n\tstruct cros_ec_sensorhub *data;\n\tstruct cros_ec_command *msg;\n\tint ret, i, sensor_num;\n\n\tmsg = devm_kzalloc(dev, sizeof(struct cros_ec_command) +\n\t\t\t   max((u16)sizeof(struct ec_params_motion_sense),\n\t\t\t       ec->ec_dev->max_response), GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\tmsg->command = EC_CMD_MOTION_SENSE_CMD + ec->cmd_offset;\n\n\tdata = devm_kzalloc(dev, sizeof(struct cros_ec_sensorhub), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&data->cmd_lock);\n\n\tdata->dev = dev;\n\tdata->ec = ec;\n\tdata->msg = msg;\n\tdata->params = (struct ec_params_motion_sense *)msg->data;\n\tdata->resp = (struct ec_response_motion_sense *)msg->data;\n\n\tdev_set_drvdata(dev, data);\n\n\t \n\tif (cros_ec_check_features(ec, EC_FEATURE_MOTION_SENSE)) {\n\t\tsensor_num = cros_ec_get_sensor_count(ec);\n\t\tif (sensor_num < 0) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"Unable to retrieve sensor information (err:%d)\\n\",\n\t\t\t\tsensor_num);\n\t\t\treturn sensor_num;\n\t\t}\n\t\tif (sensor_num == 0) {\n\t\t\tdev_err(dev, \"Zero sensors reported.\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tdata->sensor_num = sensor_num;\n\n\t\t \n\t\tif (cros_ec_check_features(ec, EC_FEATURE_MOTION_SENSE_FIFO)) {\n\t\t\tret = cros_ec_sensorhub_ring_allocate(data);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tret = cros_ec_sensorhub_register(dev, data);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tif (cros_ec_check_features(ec, EC_FEATURE_MOTION_SENSE_FIFO)) {\n\t\t\tret = cros_ec_sensorhub_ring_add(data);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\t \n\t\t\treturn devm_add_action_or_reset(dev,\n\t\t\t\t\tcros_ec_sensorhub_ring_remove,\n\t\t\t\t\tdata);\n\t\t}\n\n\t} else {\n\t\t \n\t\tdata->sensor_num = 2;\n\t\tfor (i = 0; i < data->sensor_num; i++) {\n\t\t\tret = cros_ec_sensorhub_allocate_sensor(dev,\n\t\t\t\t\t\t\"cros-ec-accel-legacy\", i);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM_SLEEP\n \nstatic int cros_ec_sensorhub_suspend(struct device *dev)\n{\n\tstruct cros_ec_sensorhub *sensorhub = dev_get_drvdata(dev);\n\tstruct cros_ec_dev *ec = sensorhub->ec;\n\n\tif (cros_ec_check_features(ec, EC_FEATURE_MOTION_SENSE_FIFO))\n\t\treturn cros_ec_sensorhub_ring_fifo_enable(sensorhub, false);\n\treturn 0;\n}\n\nstatic int cros_ec_sensorhub_resume(struct device *dev)\n{\n\tstruct cros_ec_sensorhub *sensorhub = dev_get_drvdata(dev);\n\tstruct cros_ec_dev *ec = sensorhub->ec;\n\n\tif (cros_ec_check_features(ec, EC_FEATURE_MOTION_SENSE_FIFO))\n\t\treturn cros_ec_sensorhub_ring_fifo_enable(sensorhub, true);\n\treturn 0;\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(cros_ec_sensorhub_pm_ops,\n\t\tcros_ec_sensorhub_suspend,\n\t\tcros_ec_sensorhub_resume);\n\nstatic struct platform_driver cros_ec_sensorhub_driver = {\n\t.driver = {\n\t\t.name = DRV_NAME,\n\t\t.pm = &cros_ec_sensorhub_pm_ops,\n\t},\n\t.probe = cros_ec_sensorhub_probe,\n};\n\nmodule_platform_driver(cros_ec_sensorhub_driver);\n\nMODULE_ALIAS(\"platform:\" DRV_NAME);\nMODULE_AUTHOR(\"Gwendal Grignou <gwendal@chromium.org>\");\nMODULE_DESCRIPTION(\"ChromeOS EC MEMS Sensor Hub Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}