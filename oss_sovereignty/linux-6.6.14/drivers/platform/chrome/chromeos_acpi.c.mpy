{
  "module_name": "chromeos_acpi.c",
  "hash_id": "310ef912d51d838b1447769c531ab43249e58f6c933e842082c29e4f77d838ab",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/chrome/chromeos_acpi.c",
  "human_readable_source": "\n \n#include <linux/acpi.h>\n#include <linux/platform_device.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/module.h>\n\n#define ACPI_ATTR_NAME_LEN 4\n\n#define DEV_ATTR(_var, _name)\t\t\t\t\t\\\n\tstatic struct device_attribute dev_attr_##_var =\t\\\n\t\t__ATTR(_name, 0444, chromeos_first_level_attr_show, NULL);\n\n#define GPIO_ATTR_GROUP(_group, _name, _num)\t\t\t\t\t\t\\\n\tstatic umode_t attr_is_visible_gpio_##_num(struct kobject *kobj,\t\t\\\n\t\t\t\t\t\t   struct attribute *attr, int n)\t\\\n\t{\t\t\t\t\t\t\t\t\t\t\\\n\t\tif (_num < chromeos_acpi_gpio_groups)\t\t\t\t\t\\\n\t\t\treturn attr->mode;\t\t\t\t\t\t\\\n\t\treturn 0;\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\\\n\tstatic ssize_t chromeos_attr_show_gpio_##_num(struct device *dev,\t\t\\\n\t\t\t\t\t\t      struct device_attribute *attr,\t\\\n\t\t\t\t\t\t      char *buf)\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\t\t\\\n\t\tchar name[ACPI_ATTR_NAME_LEN + 1];\t\t\t\t\t\\\n\t\tint ret, num;\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tret = parse_attr_name(attr->attr.name, name, &num);\t\t\t\\\n\t\tif (ret)\t\t\t\t\t\t\t\t\\\n\t\t\treturn ret;\t\t\t\t\t\t\t\\\n\t\treturn chromeos_acpi_evaluate_method(dev, _num, num, name, buf);\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\\\n\tstatic struct device_attribute dev_attr_0_##_group =\t\t\t\t\\\n\t\t__ATTR(GPIO.0, 0444, chromeos_attr_show_gpio_##_num, NULL);\t\t\\\n\tstatic struct device_attribute dev_attr_1_##_group =\t\t\t\t\\\n\t\t__ATTR(GPIO.1, 0444, chromeos_attr_show_gpio_##_num, NULL);\t\t\\\n\tstatic struct device_attribute dev_attr_2_##_group =\t\t\t\t\\\n\t\t__ATTR(GPIO.2, 0444, chromeos_attr_show_gpio_##_num, NULL);\t\t\\\n\tstatic struct device_attribute dev_attr_3_##_group =\t\t\t\t\\\n\t\t__ATTR(GPIO.3, 0444, chromeos_attr_show_gpio_##_num, NULL);\t\t\\\n\t\t\t\t\t\t\t\t\t\t\t\\\n\tstatic struct attribute *attrs_##_group[] = {\t\t\t\t\t\\\n\t\t&dev_attr_0_##_group.attr,\t\t\t\t\t\t\\\n\t\t&dev_attr_1_##_group.attr,\t\t\t\t\t\t\\\n\t\t&dev_attr_2_##_group.attr,\t\t\t\t\t\t\\\n\t\t&dev_attr_3_##_group.attr,\t\t\t\t\t\t\\\n\t\tNULL\t\t\t\t\t\t\t\t\t\\\n\t};\t\t\t\t\t\t\t\t\t\t\\\n\tstatic const struct attribute_group attr_group_##_group = {\t\t\t\\\n\t\t.name = _name,\t\t\t\t\t\t\t\t\\\n\t\t.is_visible = attr_is_visible_gpio_##_num,\t\t\t\t\\\n\t\t.attrs = attrs_##_group,\t\t\t\t\t\t\\\n\t};\n\nstatic unsigned int chromeos_acpi_gpio_groups;\n\n \nstatic int chromeos_acpi_handle_package(struct device *dev, union acpi_object *obj,\n\t\t\t\t\tint pkg_num, int sub_pkg_num, char *name, char *buf)\n{\n\tunion acpi_object *element = obj->package.elements;\n\n\tif (pkg_num >= obj->package.count)\n\t\treturn -EINVAL;\n\telement += pkg_num;\n\n\tif (element->type == ACPI_TYPE_PACKAGE) {\n\t\tif (sub_pkg_num >= element->package.count)\n\t\t\treturn -EINVAL;\n\t\t \n\t\telement = element->package.elements;\n\t\telement += sub_pkg_num;\n\t}\n\n\tswitch (element->type) {\n\tcase ACPI_TYPE_INTEGER:\n\t\treturn sysfs_emit(buf, \"%d\\n\", (int)element->integer.value);\n\tcase ACPI_TYPE_STRING:\n\t\treturn sysfs_emit(buf, \"%s\\n\", element->string.pointer);\n\tcase ACPI_TYPE_BUFFER:\n\t\t{\n\t\t\tint i, r, at, room_left;\n\t\t\tconst int byte_per_line = 16;\n\n\t\t\tat = 0;\n\t\t\troom_left = PAGE_SIZE - 1;\n\t\t\tfor (i = 0; i < element->buffer.length && room_left; i += byte_per_line) {\n\t\t\t\tr = hex_dump_to_buffer(element->buffer.pointer + i,\n\t\t\t\t\t\t       element->buffer.length - i,\n\t\t\t\t\t\t       byte_per_line, 1, buf + at, room_left,\n\t\t\t\t\t\t       false);\n\t\t\t\tif (r > room_left)\n\t\t\t\t\tgoto truncating;\n\t\t\t\tat += r;\n\t\t\t\troom_left -= r;\n\n\t\t\t\tr = sysfs_emit_at(buf, at, \"\\n\");\n\t\t\t\tif (!r)\n\t\t\t\t\tgoto truncating;\n\t\t\t\tat += r;\n\t\t\t\troom_left -= r;\n\t\t\t}\n\n\t\t\tbuf[at] = 0;\n\t\t\treturn at;\ntruncating:\n\t\t\tdev_info_once(dev, \"truncating sysfs content for %s\\n\", name);\n\t\t\tsysfs_emit_at(buf, PAGE_SIZE - 4, \"..\\n\");\n\t\t\treturn PAGE_SIZE - 1;\n\t\t}\n\tdefault:\n\t\tdev_err(dev, \"element type %d not supported\\n\", element->type);\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int chromeos_acpi_evaluate_method(struct device *dev, int pkg_num, int sub_pkg_num,\n\t\t\t\t\t char *name, char *buf)\n{\n\tstruct acpi_buffer output = { ACPI_ALLOCATE_BUFFER, NULL };\n\tacpi_status status;\n\tint ret = -EINVAL;\n\n\tstatus = acpi_evaluate_object(ACPI_HANDLE(dev), name, NULL, &output);\n\tif (ACPI_FAILURE(status)) {\n\t\tdev_err(dev, \"failed to retrieve %s. %s\\n\", name, acpi_format_exception(status));\n\t\treturn ret;\n\t}\n\n\tif (((union acpi_object *)output.pointer)->type == ACPI_TYPE_PACKAGE)\n\t\tret = chromeos_acpi_handle_package(dev, output.pointer, pkg_num, sub_pkg_num,\n\t\t\t\t\t\t   name, buf);\n\n\tkfree(output.pointer);\n\treturn ret;\n}\n\nstatic int parse_attr_name(const char *name, char *attr_name, int *attr_num)\n{\n\tint ret;\n\n\tret = strscpy(attr_name, name, ACPI_ATTR_NAME_LEN + 1);\n\tif (ret == -E2BIG)\n\t\treturn kstrtoint(&name[ACPI_ATTR_NAME_LEN + 1], 0, attr_num);\n\treturn 0;\n}\n\nstatic ssize_t chromeos_first_level_attr_show(struct device *dev, struct device_attribute *attr,\n\t\t\t\t\t      char *buf)\n{\n\tchar attr_name[ACPI_ATTR_NAME_LEN + 1];\n\tint ret, attr_num = 0;\n\n\tret = parse_attr_name(attr->attr.name, attr_name, &attr_num);\n\tif (ret)\n\t\treturn ret;\n\treturn chromeos_acpi_evaluate_method(dev, attr_num, 0, attr_name, buf);\n}\n\nstatic unsigned int get_gpio_pkg_num(struct device *dev)\n{\n\tstruct acpi_buffer output = { ACPI_ALLOCATE_BUFFER, NULL };\n\tunion acpi_object *obj;\n\tacpi_status status;\n\tunsigned int count = 0;\n\tchar *name = \"GPIO\";\n\n\tstatus = acpi_evaluate_object(ACPI_HANDLE(dev), name, NULL, &output);\n\tif (ACPI_FAILURE(status)) {\n\t\tdev_err(dev, \"failed to retrieve %s. %s\\n\", name, acpi_format_exception(status));\n\t\treturn count;\n\t}\n\n\tobj = output.pointer;\n\n\tif (obj->type == ACPI_TYPE_PACKAGE)\n\t\tcount = obj->package.count;\n\n\tkfree(output.pointer);\n\treturn count;\n}\n\nDEV_ATTR(binf2, BINF.2)\nDEV_ATTR(binf3, BINF.3)\nDEV_ATTR(chsw, CHSW)\nDEV_ATTR(fmap, FMAP)\nDEV_ATTR(frid, FRID)\nDEV_ATTR(fwid, FWID)\nDEV_ATTR(hwid, HWID)\nDEV_ATTR(meck, MECK)\nDEV_ATTR(vbnv0, VBNV.0)\nDEV_ATTR(vbnv1, VBNV.1)\nDEV_ATTR(vdat, VDAT)\n\nstatic struct attribute *first_level_attrs[] = {\n\t&dev_attr_binf2.attr,\n\t&dev_attr_binf3.attr,\n\t&dev_attr_chsw.attr,\n\t&dev_attr_fmap.attr,\n\t&dev_attr_frid.attr,\n\t&dev_attr_fwid.attr,\n\t&dev_attr_hwid.attr,\n\t&dev_attr_meck.attr,\n\t&dev_attr_vbnv0.attr,\n\t&dev_attr_vbnv1.attr,\n\t&dev_attr_vdat.attr,\n\tNULL\n};\n\nstatic const struct attribute_group first_level_attr_group = {\n\t.attrs = first_level_attrs,\n};\n\n \nGPIO_ATTR_GROUP(gpio0, \"GPIO.0\", 0)\nGPIO_ATTR_GROUP(gpio1, \"GPIO.1\", 1)\nGPIO_ATTR_GROUP(gpio2, \"GPIO.2\", 2)\nGPIO_ATTR_GROUP(gpio3, \"GPIO.3\", 3)\nGPIO_ATTR_GROUP(gpio4, \"GPIO.4\", 4)\nGPIO_ATTR_GROUP(gpio5, \"GPIO.5\", 5)\nGPIO_ATTR_GROUP(gpio6, \"GPIO.6\", 6)\nGPIO_ATTR_GROUP(gpio7, \"GPIO.7\", 7)\n\nstatic const struct attribute_group *chromeos_acpi_all_groups[] = {\n\t&first_level_attr_group,\n\t&attr_group_gpio0,\n\t&attr_group_gpio1,\n\t&attr_group_gpio2,\n\t&attr_group_gpio3,\n\t&attr_group_gpio4,\n\t&attr_group_gpio5,\n\t&attr_group_gpio6,\n\t&attr_group_gpio7,\n\tNULL\n};\n\nstatic int chromeos_acpi_device_probe(struct platform_device *pdev)\n{\n\tchromeos_acpi_gpio_groups = get_gpio_pkg_num(&pdev->dev);\n\n\t \n\tif (chromeos_acpi_gpio_groups > ARRAY_SIZE(chromeos_acpi_all_groups) - 2)\n\t\tdev_warn(&pdev->dev, \"Only %zu GPIO attr groups supported by the driver out of total %u.\\n\",\n\t\t\t ARRAY_SIZE(chromeos_acpi_all_groups) - 2, chromeos_acpi_gpio_groups);\n\treturn 0;\n}\n\nstatic const struct acpi_device_id chromeos_device_ids[] = {\n\t{ \"GGL0001\", 0 },\n\t{ \"GOOG0016\", 0 },\n\t{}\n};\nMODULE_DEVICE_TABLE(acpi, chromeos_device_ids);\n\nstatic struct platform_driver chromeos_acpi_device_driver = {\n\t.probe = chromeos_acpi_device_probe,\n\t.driver = {\n\t\t.name = KBUILD_MODNAME,\n\t\t.dev_groups = chromeos_acpi_all_groups,\n\t\t.acpi_match_table = chromeos_device_ids,\n\t}\n};\nmodule_platform_driver(chromeos_acpi_device_driver);\n\nMODULE_AUTHOR(\"Muhammad Usama Anjum <usama.anjum@collabora.com>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"ChromeOS specific ACPI extensions\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}