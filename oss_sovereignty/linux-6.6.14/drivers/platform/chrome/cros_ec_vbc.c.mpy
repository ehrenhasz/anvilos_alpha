{
  "module_name": "cros_ec_vbc.c",
  "hash_id": "898e88f43f1a5c87ae0c2833b66ebdbdcc8f01f3363548c61b6783f86ac7f207",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/chrome/cros_ec_vbc.c",
  "human_readable_source": "\n\n\n\n\n\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/module.h>\n#include <linux/platform_data/cros_ec_commands.h>\n#include <linux/platform_data/cros_ec_proto.h>\n#include <linux/slab.h>\n\n#define DRV_NAME \"cros-ec-vbc\"\n\nstatic ssize_t vboot_context_read(struct file *filp, struct kobject *kobj,\n\t\t\t\t  struct bin_attribute *att, char *buf,\n\t\t\t\t  loff_t pos, size_t count)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct cros_ec_dev *ec = to_cros_ec_dev(dev);\n\tstruct cros_ec_device *ecdev = ec->ec_dev;\n\tstruct ec_params_vbnvcontext *params;\n\tstruct cros_ec_command *msg;\n\tint err;\n\tconst size_t para_sz = sizeof(params->op);\n\tconst size_t resp_sz = sizeof(struct ec_response_vbnvcontext);\n\tconst size_t payload = max(para_sz, resp_sz);\n\n\tmsg = kmalloc(sizeof(*msg) + payload, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\t \n\tparams = (struct ec_params_vbnvcontext *)msg->data;\n\tparams->op = EC_VBNV_CONTEXT_OP_READ;\n\n\tmsg->version = EC_VER_VBNV_CONTEXT;\n\tmsg->command = EC_CMD_VBNV_CONTEXT;\n\tmsg->outsize = para_sz;\n\tmsg->insize = resp_sz;\n\n\terr = cros_ec_cmd_xfer_status(ecdev, msg);\n\tif (err < 0) {\n\t\tdev_err(dev, \"Error sending read request: %d\\n\", err);\n\t\tkfree(msg);\n\t\treturn err;\n\t}\n\n\tmemcpy(buf, msg->data, resp_sz);\n\n\tkfree(msg);\n\treturn resp_sz;\n}\n\nstatic ssize_t vboot_context_write(struct file *filp, struct kobject *kobj,\n\t\t\t\t   struct bin_attribute *attr, char *buf,\n\t\t\t\t   loff_t pos, size_t count)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct cros_ec_dev *ec = to_cros_ec_dev(dev);\n\tstruct cros_ec_device *ecdev = ec->ec_dev;\n\tstruct ec_params_vbnvcontext *params;\n\tstruct cros_ec_command *msg;\n\tint err;\n\tconst size_t para_sz = sizeof(*params);\n\tconst size_t data_sz = sizeof(params->block);\n\n\t \n\tif (count != data_sz)\n\t\treturn -EINVAL;\n\n\tmsg = kmalloc(sizeof(*msg) + para_sz, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\tparams = (struct ec_params_vbnvcontext *)msg->data;\n\tparams->op = EC_VBNV_CONTEXT_OP_WRITE;\n\tmemcpy(params->block, buf, data_sz);\n\n\tmsg->version = EC_VER_VBNV_CONTEXT;\n\tmsg->command = EC_CMD_VBNV_CONTEXT;\n\tmsg->outsize = para_sz;\n\tmsg->insize = 0;\n\n\terr = cros_ec_cmd_xfer_status(ecdev, msg);\n\tif (err < 0) {\n\t\tdev_err(dev, \"Error sending write request: %d\\n\", err);\n\t\tkfree(msg);\n\t\treturn err;\n\t}\n\n\tkfree(msg);\n\treturn data_sz;\n}\n\nstatic BIN_ATTR_RW(vboot_context, 16);\n\nstatic struct bin_attribute *cros_ec_vbc_bin_attrs[] = {\n\t&bin_attr_vboot_context,\n\tNULL\n};\n\nstatic const struct attribute_group cros_ec_vbc_attr_group = {\n\t.name = \"vbc\",\n\t.bin_attrs = cros_ec_vbc_bin_attrs,\n};\n\nstatic int cros_ec_vbc_probe(struct platform_device *pd)\n{\n\tstruct cros_ec_dev *ec_dev = dev_get_drvdata(pd->dev.parent);\n\tstruct device *dev = &pd->dev;\n\tint ret;\n\n\tret = sysfs_create_group(&ec_dev->class_dev.kobj,\n\t\t\t\t &cros_ec_vbc_attr_group);\n\tif (ret < 0)\n\t\tdev_err(dev, \"failed to create %s attributes. err=%d\\n\",\n\t\t\tcros_ec_vbc_attr_group.name, ret);\n\n\treturn ret;\n}\n\nstatic int cros_ec_vbc_remove(struct platform_device *pd)\n{\n\tstruct cros_ec_dev *ec_dev = dev_get_drvdata(pd->dev.parent);\n\n\tsysfs_remove_group(&ec_dev->class_dev.kobj,\n\t\t\t   &cros_ec_vbc_attr_group);\n\n\treturn 0;\n}\n\nstatic struct platform_driver cros_ec_vbc_driver = {\n\t.driver = {\n\t\t.name = DRV_NAME,\n\t},\n\t.probe = cros_ec_vbc_probe,\n\t.remove = cros_ec_vbc_remove,\n};\n\nmodule_platform_driver(cros_ec_vbc_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Expose the vboot context nvram to userspace\");\nMODULE_ALIAS(\"platform:\" DRV_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}