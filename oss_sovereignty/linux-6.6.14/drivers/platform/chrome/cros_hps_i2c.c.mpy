{
  "module_name": "cros_hps_i2c.c",
  "hash_id": "1158c30e9b717ad42798b720ea67dfac33bc725610414b7a982c5f2c9a58fc77",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/chrome/cros_hps_i2c.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/fs.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/miscdevice.h>\n#include <linux/module.h>\n#include <linux/pm_runtime.h>\n\n#define HPS_ACPI_ID\t\t\"GOOG0020\"\n\nstruct hps_drvdata {\n\tstruct i2c_client *client;\n\tstruct miscdevice misc_device;\n\tstruct gpio_desc *enable_gpio;\n};\n\nstatic void hps_set_power(struct hps_drvdata *hps, bool state)\n{\n\tgpiod_set_value_cansleep(hps->enable_gpio, state);\n}\n\nstatic int hps_open(struct inode *inode, struct file *file)\n{\n\tstruct hps_drvdata *hps = container_of(file->private_data,\n\t\t\t\t\t       struct hps_drvdata, misc_device);\n\tstruct device *dev = &hps->client->dev;\n\n\treturn pm_runtime_resume_and_get(dev);\n}\n\nstatic int hps_release(struct inode *inode, struct file *file)\n{\n\tstruct hps_drvdata *hps = container_of(file->private_data,\n\t\t\t\t\t       struct hps_drvdata, misc_device);\n\tstruct device *dev = &hps->client->dev;\n\n\treturn pm_runtime_put(dev);\n}\n\nstatic const struct file_operations hps_fops = {\n\t.owner = THIS_MODULE,\n\t.open = hps_open,\n\t.release = hps_release,\n};\n\nstatic int hps_i2c_probe(struct i2c_client *client)\n{\n\tstruct hps_drvdata *hps;\n\tint ret;\n\n\thps = devm_kzalloc(&client->dev, sizeof(*hps), GFP_KERNEL);\n\tif (!hps)\n\t\treturn -ENOMEM;\n\n\thps->misc_device.parent = &client->dev;\n\thps->misc_device.minor = MISC_DYNAMIC_MINOR;\n\thps->misc_device.name = \"cros-hps\";\n\thps->misc_device.fops = &hps_fops;\n\n\ti2c_set_clientdata(client, hps);\n\thps->client = client;\n\n\t \n\thps->enable_gpio = devm_gpiod_get(&client->dev, \"enable\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(hps->enable_gpio)) {\n\t\tret = PTR_ERR(hps->enable_gpio);\n\t\tdev_err(&client->dev, \"failed to get enable gpio: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = misc_register(&hps->misc_device);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"failed to initialize misc device: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\thps_set_power(hps, false);\n\tpm_runtime_enable(&client->dev);\n\treturn 0;\n}\n\nstatic void hps_i2c_remove(struct i2c_client *client)\n{\n\tstruct hps_drvdata *hps = i2c_get_clientdata(client);\n\n\tpm_runtime_disable(&client->dev);\n\tmisc_deregister(&hps->misc_device);\n\n\t \n\thps_set_power(hps, true);\n}\n\nstatic int hps_suspend(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct hps_drvdata *hps = i2c_get_clientdata(client);\n\n\thps_set_power(hps, false);\n\treturn 0;\n}\n\nstatic int hps_resume(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct hps_drvdata *hps = i2c_get_clientdata(client);\n\n\thps_set_power(hps, true);\n\treturn 0;\n}\nstatic UNIVERSAL_DEV_PM_OPS(hps_pm_ops, hps_suspend, hps_resume, NULL);\n\nstatic const struct i2c_device_id hps_i2c_id[] = {\n\t{ \"cros-hps\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, hps_i2c_id);\n\n#ifdef CONFIG_ACPI\nstatic const struct acpi_device_id hps_acpi_id[] = {\n\t{ HPS_ACPI_ID, 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(acpi, hps_acpi_id);\n#endif  \n\nstatic struct i2c_driver hps_i2c_driver = {\n\t.probe = hps_i2c_probe,\n\t.remove = hps_i2c_remove,\n\t.id_table = hps_i2c_id,\n\t.driver = {\n\t\t.name = \"cros-hps\",\n\t\t.pm = &hps_pm_ops,\n\t\t.acpi_match_table = ACPI_PTR(hps_acpi_id),\n\t},\n};\nmodule_i2c_driver(hps_i2c_driver);\n\nMODULE_ALIAS(\"acpi:\" HPS_ACPI_ID);\nMODULE_AUTHOR(\"Sami Ky\u00f6stil\u00e4 <skyostil@chromium.org>\");\nMODULE_DESCRIPTION(\"Driver for ChromeOS HPS\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}