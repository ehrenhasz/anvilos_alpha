{
  "module_name": "cros_ec_spi.c",
  "hash_id": "717fb795d737e1326d0b47a21a28cdddba512b0ab30f49e297bf1e904cc1c1c1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/chrome/cros_ec_spi.c",
  "human_readable_source": "\n\n\n\n\n#include <linux/delay.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_data/cros_ec_commands.h>\n#include <linux/platform_data/cros_ec_proto.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/spi/spi.h>\n#include <uapi/linux/sched/types.h>\n\n#include \"cros_ec.h\"\n\n \n#define EC_MSG_HEADER\t\t\t0xec\n\n \n#define EC_MSG_PREAMBLE_COUNT\t\t32\n\n \n#define EC_MSG_DEADLINE_MS\t\t200\n\n \n#define EC_SPI_RECOVERY_TIME_NS\t(200 * 1000)\n\n \nstruct cros_ec_spi {\n\tstruct spi_device *spi;\n\ts64 last_transfer_ns;\n\tunsigned int start_of_msg_delay;\n\tunsigned int end_of_msg_delay;\n\tstruct kthread_worker *high_pri_worker;\n};\n\ntypedef int (*cros_ec_xfer_fn_t) (struct cros_ec_device *ec_dev,\n\t\t\t\t  struct cros_ec_command *ec_msg);\n\n \n\nstruct cros_ec_xfer_work_params {\n\tstruct kthread_work work;\n\tcros_ec_xfer_fn_t fn;\n\tstruct cros_ec_device *ec_dev;\n\tstruct cros_ec_command *ec_msg;\n\tint ret;\n};\n\nstatic void debug_packet(struct device *dev, const char *name, u8 *ptr,\n\t\t\t int len)\n{\n#ifdef DEBUG\n\tdev_dbg(dev, \"%s: %*ph\\n\", name, len, ptr);\n#endif\n}\n\nstatic int terminate_request(struct cros_ec_device *ec_dev)\n{\n\tstruct cros_ec_spi *ec_spi = ec_dev->priv;\n\tstruct spi_message msg;\n\tstruct spi_transfer trans;\n\tint ret;\n\n\t \n\tspi_message_init(&msg);\n\tmemset(&trans, 0, sizeof(trans));\n\ttrans.delay.value = ec_spi->end_of_msg_delay;\n\ttrans.delay.unit = SPI_DELAY_UNIT_USECS;\n\tspi_message_add_tail(&trans, &msg);\n\n\tret = spi_sync_locked(ec_spi->spi, &msg);\n\n\t \n\tec_spi->last_transfer_ns = ktime_get_ns();\n\tif (ret < 0) {\n\t\tdev_err(ec_dev->dev,\n\t\t\t\"cs-deassert spi transfer failed: %d\\n\",\n\t\t\tret);\n\t}\n\n\treturn ret;\n}\n\n \nstatic int receive_n_bytes(struct cros_ec_device *ec_dev, u8 *buf, int n)\n{\n\tstruct cros_ec_spi *ec_spi = ec_dev->priv;\n\tstruct spi_transfer trans;\n\tstruct spi_message msg;\n\tint ret;\n\n\tif (buf - ec_dev->din + n > ec_dev->din_size)\n\t\treturn -EINVAL;\n\n\tmemset(&trans, 0, sizeof(trans));\n\ttrans.cs_change = 1;\n\ttrans.rx_buf = buf;\n\ttrans.len = n;\n\n\tspi_message_init(&msg);\n\tspi_message_add_tail(&trans, &msg);\n\tret = spi_sync_locked(ec_spi->spi, &msg);\n\tif (ret < 0)\n\t\tdev_err(ec_dev->dev, \"spi transfer failed: %d\\n\", ret);\n\n\treturn ret;\n}\n\n \nstatic int cros_ec_spi_receive_packet(struct cros_ec_device *ec_dev,\n\t\t\t\t      int need_len)\n{\n\tstruct ec_host_response *response;\n\tu8 *ptr, *end;\n\tint ret;\n\tunsigned long deadline;\n\tint todo;\n\n\tif (ec_dev->din_size < EC_MSG_PREAMBLE_COUNT)\n\t\treturn -EINVAL;\n\n\t \n\tdeadline = jiffies + msecs_to_jiffies(EC_MSG_DEADLINE_MS);\n\twhile (true) {\n\t\tunsigned long start_jiffies = jiffies;\n\n\t\tret = receive_n_bytes(ec_dev,\n\t\t\t\t      ec_dev->din,\n\t\t\t\t      EC_MSG_PREAMBLE_COUNT);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tptr = ec_dev->din;\n\t\tfor (end = ptr + EC_MSG_PREAMBLE_COUNT; ptr != end; ptr++) {\n\t\t\tif (*ptr == EC_SPI_FRAME_START) {\n\t\t\t\tdev_dbg(ec_dev->dev, \"msg found at %zd\\n\",\n\t\t\t\t\tptr - ec_dev->din);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (ptr != end)\n\t\t\tbreak;\n\n\t\t \n\t\tif (time_after(start_jiffies, deadline)) {\n\t\t\tdev_warn(ec_dev->dev, \"EC failed to respond in time\\n\");\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t}\n\n\t \n\ttodo = end - ++ptr;\n\ttodo = min(todo, need_len);\n\tmemmove(ec_dev->din, ptr, todo);\n\tptr = ec_dev->din + todo;\n\tdev_dbg(ec_dev->dev, \"need %d, got %d bytes from preamble\\n\",\n\t\tneed_len, todo);\n\tneed_len -= todo;\n\n\t \n\tif (todo < sizeof(*response)) {\n\t\tret = receive_n_bytes(ec_dev, ptr, sizeof(*response) - todo);\n\t\tif (ret < 0)\n\t\t\treturn -EBADMSG;\n\t\tptr += (sizeof(*response) - todo);\n\t\ttodo = sizeof(*response);\n\t}\n\n\tresponse = (struct ec_host_response *)ec_dev->din;\n\n\t \n\tif (response->data_len > ec_dev->din_size)\n\t\treturn -EMSGSIZE;\n\n\t \n\twhile (need_len > 0) {\n\t\t \n\t\ttodo = min(need_len, 256);\n\t\tdev_dbg(ec_dev->dev, \"loop, todo=%d, need_len=%d, ptr=%zd\\n\",\n\t\t\ttodo, need_len, ptr - ec_dev->din);\n\n\t\tret = receive_n_bytes(ec_dev, ptr, todo);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tptr += todo;\n\t\tneed_len -= todo;\n\t}\n\n\tdev_dbg(ec_dev->dev, \"loop done, ptr=%zd\\n\", ptr - ec_dev->din);\n\n\treturn 0;\n}\n\n \nstatic int cros_ec_spi_receive_response(struct cros_ec_device *ec_dev,\n\t\t\t\t\tint need_len)\n{\n\tu8 *ptr, *end;\n\tint ret;\n\tunsigned long deadline;\n\tint todo;\n\n\tif (ec_dev->din_size < EC_MSG_PREAMBLE_COUNT)\n\t\treturn -EINVAL;\n\n\t \n\tdeadline = jiffies + msecs_to_jiffies(EC_MSG_DEADLINE_MS);\n\twhile (true) {\n\t\tunsigned long start_jiffies = jiffies;\n\n\t\tret = receive_n_bytes(ec_dev,\n\t\t\t\t      ec_dev->din,\n\t\t\t\t      EC_MSG_PREAMBLE_COUNT);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tptr = ec_dev->din;\n\t\tfor (end = ptr + EC_MSG_PREAMBLE_COUNT; ptr != end; ptr++) {\n\t\t\tif (*ptr == EC_SPI_FRAME_START) {\n\t\t\t\tdev_dbg(ec_dev->dev, \"msg found at %zd\\n\",\n\t\t\t\t\tptr - ec_dev->din);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (ptr != end)\n\t\t\tbreak;\n\n\t\t \n\t\tif (time_after(start_jiffies, deadline)) {\n\t\t\tdev_warn(ec_dev->dev, \"EC failed to respond in time\\n\");\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t}\n\n\t \n\ttodo = end - ++ptr;\n\ttodo = min(todo, need_len);\n\tmemmove(ec_dev->din, ptr, todo);\n\tptr = ec_dev->din + todo;\n\tdev_dbg(ec_dev->dev, \"need %d, got %d bytes from preamble\\n\",\n\t\t need_len, todo);\n\tneed_len -= todo;\n\n\t \n\twhile (need_len > 0) {\n\t\t \n\t\ttodo = min(need_len, 256);\n\t\tdev_dbg(ec_dev->dev, \"loop, todo=%d, need_len=%d, ptr=%zd\\n\",\n\t\t\ttodo, need_len, ptr - ec_dev->din);\n\n\t\tret = receive_n_bytes(ec_dev, ptr, todo);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tdebug_packet(ec_dev->dev, \"interim\", ptr, todo);\n\t\tptr += todo;\n\t\tneed_len -= todo;\n\t}\n\n\tdev_dbg(ec_dev->dev, \"loop done, ptr=%zd\\n\", ptr - ec_dev->din);\n\n\treturn 0;\n}\n\n \nstatic int do_cros_ec_pkt_xfer_spi(struct cros_ec_device *ec_dev,\n\t\t\t\t   struct cros_ec_command *ec_msg)\n{\n\tstruct ec_host_response *response;\n\tstruct cros_ec_spi *ec_spi = ec_dev->priv;\n\tstruct spi_transfer trans, trans_delay;\n\tstruct spi_message msg;\n\tint i, len;\n\tu8 *ptr;\n\tu8 *rx_buf;\n\tu8 sum;\n\tu8 rx_byte;\n\tint ret = 0, final_ret;\n\tunsigned long delay;\n\n\tlen = cros_ec_prepare_tx(ec_dev, ec_msg);\n\tif (len < 0)\n\t\treturn len;\n\tdev_dbg(ec_dev->dev, \"prepared, len=%d\\n\", len);\n\n\t \n\tdelay = ktime_get_ns() - ec_spi->last_transfer_ns;\n\tif (delay < EC_SPI_RECOVERY_TIME_NS)\n\t\tndelay(EC_SPI_RECOVERY_TIME_NS - delay);\n\n\trx_buf = kzalloc(len, GFP_KERNEL);\n\tif (!rx_buf)\n\t\treturn -ENOMEM;\n\n\tspi_bus_lock(ec_spi->spi->master);\n\n\t \n\tspi_message_init(&msg);\n\tif (ec_spi->start_of_msg_delay) {\n\t\tmemset(&trans_delay, 0, sizeof(trans_delay));\n\t\ttrans_delay.delay.value = ec_spi->start_of_msg_delay;\n\t\ttrans_delay.delay.unit = SPI_DELAY_UNIT_USECS;\n\t\tspi_message_add_tail(&trans_delay, &msg);\n\t}\n\n\t \n\tmemset(&trans, 0, sizeof(trans));\n\ttrans.tx_buf = ec_dev->dout;\n\ttrans.rx_buf = rx_buf;\n\ttrans.len = len;\n\ttrans.cs_change = 1;\n\tspi_message_add_tail(&trans, &msg);\n\tret = spi_sync_locked(ec_spi->spi, &msg);\n\n\t \n\tif (!ret) {\n\t\t \n\t\tfor (i = 0; i < len; i++) {\n\t\t\trx_byte = rx_buf[i];\n\t\t\t \n\t\t\tif (rx_byte == EC_SPI_PAST_END  ||\n\t\t\t    rx_byte == EC_SPI_RX_BAD_DATA ||\n\t\t\t    rx_byte == EC_SPI_NOT_READY) {\n\t\t\t\tret = -EAGAIN;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!ret)\n\t\tret = cros_ec_spi_receive_packet(ec_dev,\n\t\t\t\tec_msg->insize + sizeof(*response));\n\telse if (ret != -EAGAIN)\n\t\tdev_err(ec_dev->dev, \"spi transfer failed: %d\\n\", ret);\n\n\tfinal_ret = terminate_request(ec_dev);\n\n\tspi_bus_unlock(ec_spi->spi->master);\n\n\tif (!ret)\n\t\tret = final_ret;\n\tif (ret < 0)\n\t\tgoto exit;\n\n\tptr = ec_dev->din;\n\n\t \n\tresponse = (struct ec_host_response *)ptr;\n\tec_msg->result = response->result;\n\n\tret = cros_ec_check_result(ec_dev, ec_msg);\n\tif (ret)\n\t\tgoto exit;\n\n\tlen = response->data_len;\n\tsum = 0;\n\tif (len > ec_msg->insize) {\n\t\tdev_err(ec_dev->dev, \"packet too long (%d bytes, expected %d)\",\n\t\t\tlen, ec_msg->insize);\n\t\tret = -EMSGSIZE;\n\t\tgoto exit;\n\t}\n\n\tfor (i = 0; i < sizeof(*response); i++)\n\t\tsum += ptr[i];\n\n\t \n\tmemcpy(ec_msg->data, ptr + sizeof(*response), len);\n\tfor (i = 0; i < len; i++)\n\t\tsum += ec_msg->data[i];\n\n\tif (sum) {\n\t\tdev_err(ec_dev->dev,\n\t\t\t\"bad packet checksum, calculated %x\\n\",\n\t\t\tsum);\n\t\tret = -EBADMSG;\n\t\tgoto exit;\n\t}\n\n\tret = len;\nexit:\n\tkfree(rx_buf);\n\tif (ec_msg->command == EC_CMD_REBOOT_EC)\n\t\tmsleep(EC_REBOOT_DELAY_MS);\n\n\treturn ret;\n}\n\n \nstatic int do_cros_ec_cmd_xfer_spi(struct cros_ec_device *ec_dev,\n\t\t\t\t   struct cros_ec_command *ec_msg)\n{\n\tstruct cros_ec_spi *ec_spi = ec_dev->priv;\n\tstruct spi_transfer trans;\n\tstruct spi_message msg;\n\tint i, len;\n\tu8 *ptr;\n\tu8 *rx_buf;\n\tu8 rx_byte;\n\tint sum;\n\tint ret = 0, final_ret;\n\tunsigned long delay;\n\n\tlen = cros_ec_prepare_tx(ec_dev, ec_msg);\n\tif (len < 0)\n\t\treturn len;\n\tdev_dbg(ec_dev->dev, \"prepared, len=%d\\n\", len);\n\n\t \n\tdelay = ktime_get_ns() - ec_spi->last_transfer_ns;\n\tif (delay < EC_SPI_RECOVERY_TIME_NS)\n\t\tndelay(EC_SPI_RECOVERY_TIME_NS - delay);\n\n\trx_buf = kzalloc(len, GFP_KERNEL);\n\tif (!rx_buf)\n\t\treturn -ENOMEM;\n\n\tspi_bus_lock(ec_spi->spi->master);\n\n\t \n\tdebug_packet(ec_dev->dev, \"out\", ec_dev->dout, len);\n\tmemset(&trans, 0, sizeof(trans));\n\ttrans.tx_buf = ec_dev->dout;\n\ttrans.rx_buf = rx_buf;\n\ttrans.len = len;\n\ttrans.cs_change = 1;\n\tspi_message_init(&msg);\n\tspi_message_add_tail(&trans, &msg);\n\tret = spi_sync_locked(ec_spi->spi, &msg);\n\n\t \n\tif (!ret) {\n\t\t \n\t\tfor (i = 0; i < len; i++) {\n\t\t\trx_byte = rx_buf[i];\n\t\t\t \n\t\t\tif (rx_byte == EC_SPI_PAST_END  ||\n\t\t\t    rx_byte == EC_SPI_RX_BAD_DATA ||\n\t\t\t    rx_byte == EC_SPI_NOT_READY) {\n\t\t\t\tret = -EAGAIN;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!ret)\n\t\tret = cros_ec_spi_receive_response(ec_dev,\n\t\t\t\tec_msg->insize + EC_MSG_TX_PROTO_BYTES);\n\telse if (ret != -EAGAIN)\n\t\tdev_err(ec_dev->dev, \"spi transfer failed: %d\\n\", ret);\n\n\tfinal_ret = terminate_request(ec_dev);\n\n\tspi_bus_unlock(ec_spi->spi->master);\n\n\tif (!ret)\n\t\tret = final_ret;\n\tif (ret < 0)\n\t\tgoto exit;\n\n\tptr = ec_dev->din;\n\n\t \n\tec_msg->result = ptr[0];\n\tret = cros_ec_check_result(ec_dev, ec_msg);\n\tif (ret)\n\t\tgoto exit;\n\n\tlen = ptr[1];\n\tsum = ptr[0] + ptr[1];\n\tif (len > ec_msg->insize) {\n\t\tdev_err(ec_dev->dev, \"packet too long (%d bytes, expected %d)\",\n\t\t\tlen, ec_msg->insize);\n\t\tret = -ENOSPC;\n\t\tgoto exit;\n\t}\n\n\t \n\tfor (i = 0; i < len; i++) {\n\t\tsum += ptr[i + 2];\n\t\tif (ec_msg->insize)\n\t\t\tec_msg->data[i] = ptr[i + 2];\n\t}\n\tsum &= 0xff;\n\n\tdebug_packet(ec_dev->dev, \"in\", ptr, len + 3);\n\n\tif (sum != ptr[len + 2]) {\n\t\tdev_err(ec_dev->dev,\n\t\t\t\"bad packet checksum, expected %02x, got %02x\\n\",\n\t\t\tsum, ptr[len + 2]);\n\t\tret = -EBADMSG;\n\t\tgoto exit;\n\t}\n\n\tret = len;\nexit:\n\tkfree(rx_buf);\n\tif (ec_msg->command == EC_CMD_REBOOT_EC)\n\t\tmsleep(EC_REBOOT_DELAY_MS);\n\n\treturn ret;\n}\n\nstatic void cros_ec_xfer_high_pri_work(struct kthread_work *work)\n{\n\tstruct cros_ec_xfer_work_params *params;\n\n\tparams = container_of(work, struct cros_ec_xfer_work_params, work);\n\tparams->ret = params->fn(params->ec_dev, params->ec_msg);\n}\n\nstatic int cros_ec_xfer_high_pri(struct cros_ec_device *ec_dev,\n\t\t\t\t struct cros_ec_command *ec_msg,\n\t\t\t\t cros_ec_xfer_fn_t fn)\n{\n\tstruct cros_ec_spi *ec_spi = ec_dev->priv;\n\tstruct cros_ec_xfer_work_params params = {\n\t\t.work = KTHREAD_WORK_INIT(params.work,\n\t\t\t\t\t  cros_ec_xfer_high_pri_work),\n\t\t.ec_dev = ec_dev,\n\t\t.ec_msg = ec_msg,\n\t\t.fn = fn,\n\t};\n\n\t \n\tkthread_queue_work(ec_spi->high_pri_worker, &params.work);\n\tkthread_flush_work(&params.work);\n\n\treturn params.ret;\n}\n\nstatic int cros_ec_pkt_xfer_spi(struct cros_ec_device *ec_dev,\n\t\t\t\tstruct cros_ec_command *ec_msg)\n{\n\treturn cros_ec_xfer_high_pri(ec_dev, ec_msg, do_cros_ec_pkt_xfer_spi);\n}\n\nstatic int cros_ec_cmd_xfer_spi(struct cros_ec_device *ec_dev,\n\t\t\t\tstruct cros_ec_command *ec_msg)\n{\n\treturn cros_ec_xfer_high_pri(ec_dev, ec_msg, do_cros_ec_cmd_xfer_spi);\n}\n\nstatic void cros_ec_spi_dt_probe(struct cros_ec_spi *ec_spi, struct device *dev)\n{\n\tstruct device_node *np = dev->of_node;\n\tu32 val;\n\tint ret;\n\n\tret = of_property_read_u32(np, \"google,cros-ec-spi-pre-delay\", &val);\n\tif (!ret)\n\t\tec_spi->start_of_msg_delay = val;\n\n\tret = of_property_read_u32(np, \"google,cros-ec-spi-msg-delay\", &val);\n\tif (!ret)\n\t\tec_spi->end_of_msg_delay = val;\n}\n\nstatic void cros_ec_spi_high_pri_release(void *worker)\n{\n\tkthread_destroy_worker(worker);\n}\n\nstatic int cros_ec_spi_devm_high_pri_alloc(struct device *dev,\n\t\t\t\t\t   struct cros_ec_spi *ec_spi)\n{\n\tint err;\n\n\tec_spi->high_pri_worker =\n\t\tkthread_create_worker(0, \"cros_ec_spi_high_pri\");\n\n\tif (IS_ERR(ec_spi->high_pri_worker)) {\n\t\terr = PTR_ERR(ec_spi->high_pri_worker);\n\t\tdev_err(dev, \"Can't create cros_ec high pri worker: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\terr = devm_add_action_or_reset(dev, cros_ec_spi_high_pri_release,\n\t\t\t\t       ec_spi->high_pri_worker);\n\tif (err)\n\t\treturn err;\n\n\tsched_set_fifo(ec_spi->high_pri_worker->task);\n\n\treturn 0;\n}\n\nstatic int cros_ec_spi_probe(struct spi_device *spi)\n{\n\tstruct device *dev = &spi->dev;\n\tstruct cros_ec_device *ec_dev;\n\tstruct cros_ec_spi *ec_spi;\n\tint err;\n\n\tspi->rt = true;\n\terr = spi_setup(spi);\n\tif (err < 0)\n\t\treturn err;\n\n\tec_spi = devm_kzalloc(dev, sizeof(*ec_spi), GFP_KERNEL);\n\tif (ec_spi == NULL)\n\t\treturn -ENOMEM;\n\tec_spi->spi = spi;\n\tec_dev = devm_kzalloc(dev, sizeof(*ec_dev), GFP_KERNEL);\n\tif (!ec_dev)\n\t\treturn -ENOMEM;\n\n\t \n\tcros_ec_spi_dt_probe(ec_spi, dev);\n\n\tspi_set_drvdata(spi, ec_dev);\n\tec_dev->dev = dev;\n\tec_dev->priv = ec_spi;\n\tec_dev->irq = spi->irq;\n\tec_dev->cmd_xfer = cros_ec_cmd_xfer_spi;\n\tec_dev->pkt_xfer = cros_ec_pkt_xfer_spi;\n\tec_dev->phys_name = dev_name(&ec_spi->spi->dev);\n\tec_dev->din_size = EC_MSG_PREAMBLE_COUNT +\n\t\t\t   sizeof(struct ec_host_response) +\n\t\t\t   sizeof(struct ec_response_get_protocol_info);\n\tec_dev->dout_size = sizeof(struct ec_host_request);\n\n\tec_spi->last_transfer_ns = ktime_get_ns();\n\n\terr = cros_ec_spi_devm_high_pri_alloc(dev, ec_spi);\n\tif (err)\n\t\treturn err;\n\n\terr = cros_ec_register(ec_dev);\n\tif (err) {\n\t\tdev_err(dev, \"cannot register EC\\n\");\n\t\treturn err;\n\t}\n\n\tdevice_init_wakeup(&spi->dev, true);\n\n\treturn 0;\n}\n\nstatic void cros_ec_spi_remove(struct spi_device *spi)\n{\n\tstruct cros_ec_device *ec_dev = spi_get_drvdata(spi);\n\n\tcros_ec_unregister(ec_dev);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int cros_ec_spi_suspend(struct device *dev)\n{\n\tstruct cros_ec_device *ec_dev = dev_get_drvdata(dev);\n\n\treturn cros_ec_suspend(ec_dev);\n}\n\nstatic int cros_ec_spi_resume(struct device *dev)\n{\n\tstruct cros_ec_device *ec_dev = dev_get_drvdata(dev);\n\n\treturn cros_ec_resume(ec_dev);\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(cros_ec_spi_pm_ops, cros_ec_spi_suspend,\n\t\t\t cros_ec_spi_resume);\n\nstatic const struct of_device_id cros_ec_spi_of_match[] = {\n\t{ .compatible = \"google,cros-ec-spi\", },\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, cros_ec_spi_of_match);\n\nstatic const struct spi_device_id cros_ec_spi_id[] = {\n\t{ \"cros-ec-spi\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(spi, cros_ec_spi_id);\n\nstatic struct spi_driver cros_ec_driver_spi = {\n\t.driver\t= {\n\t\t.name\t= \"cros-ec-spi\",\n\t\t.of_match_table = cros_ec_spi_of_match,\n\t\t.pm\t= &cros_ec_spi_pm_ops,\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t},\n\t.probe\t\t= cros_ec_spi_probe,\n\t.remove\t\t= cros_ec_spi_remove,\n\t.id_table\t= cros_ec_spi_id,\n};\n\nmodule_spi_driver(cros_ec_driver_spi);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"SPI interface for ChromeOS Embedded Controller\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}