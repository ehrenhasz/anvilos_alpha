{
  "module_name": "cros_ec_rpmsg.c",
  "hash_id": "a5bd0db49dcb0f7fb97c93a3c3975100d7e31a6b3e2de0775bcb2872fd55275d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/chrome/cros_ec_rpmsg.c",
  "human_readable_source": "\n\n\n\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_data/cros_ec_commands.h>\n#include <linux/platform_data/cros_ec_proto.h>\n#include <linux/platform_device.h>\n#include <linux/rpmsg.h>\n#include <linux/slab.h>\n\n#include \"cros_ec.h\"\n\n#define EC_MSG_TIMEOUT_MS\t200\n#define HOST_COMMAND_MARK\t1\n#define HOST_EVENT_MARK\t\t2\n\n \nstruct cros_ec_rpmsg_response {\n\tu8 type;\n\tu8 data[] __aligned(4);\n};\n\n \nstruct cros_ec_rpmsg {\n\tstruct rpmsg_device *rpdev;\n\tstruct completion xfer_ack;\n\tstruct work_struct host_event_work;\n\tstruct rpmsg_endpoint *ept;\n\tbool has_pending_host_event;\n\tbool probe_done;\n};\n\n \nstatic int cros_ec_cmd_xfer_rpmsg(struct cros_ec_device *ec_dev,\n\t\t\t\t  struct cros_ec_command *ec_msg)\n{\n\treturn -EINVAL;\n}\n\n \nstatic int cros_ec_pkt_xfer_rpmsg(struct cros_ec_device *ec_dev,\n\t\t\t\t  struct cros_ec_command *ec_msg)\n{\n\tstruct cros_ec_rpmsg *ec_rpmsg = ec_dev->priv;\n\tstruct ec_host_response *response;\n\tunsigned long timeout;\n\tint len;\n\tint ret;\n\tu8 sum;\n\tint i;\n\n\tec_msg->result = 0;\n\tlen = cros_ec_prepare_tx(ec_dev, ec_msg);\n\tif (len < 0)\n\t\treturn len;\n\tdev_dbg(ec_dev->dev, \"prepared, len=%d\\n\", len);\n\n\treinit_completion(&ec_rpmsg->xfer_ack);\n\tret = rpmsg_send(ec_rpmsg->ept, ec_dev->dout, len);\n\tif (ret) {\n\t\tdev_err(ec_dev->dev, \"rpmsg send failed\\n\");\n\t\treturn ret;\n\t}\n\n\ttimeout = msecs_to_jiffies(EC_MSG_TIMEOUT_MS);\n\tret = wait_for_completion_timeout(&ec_rpmsg->xfer_ack, timeout);\n\tif (!ret) {\n\t\tdev_err(ec_dev->dev, \"rpmsg send timeout\\n\");\n\t\treturn -EIO;\n\t}\n\n\t \n\tresponse = (struct ec_host_response *)ec_dev->din;\n\tec_msg->result = response->result;\n\n\tret = cros_ec_check_result(ec_dev, ec_msg);\n\tif (ret)\n\t\tgoto exit;\n\n\tif (response->data_len > ec_msg->insize) {\n\t\tdev_err(ec_dev->dev, \"packet too long (%d bytes, expected %d)\",\n\t\t\tresponse->data_len, ec_msg->insize);\n\t\tret = -EMSGSIZE;\n\t\tgoto exit;\n\t}\n\n\t \n\tmemcpy(ec_msg->data, ec_dev->din + sizeof(*response),\n\t       response->data_len);\n\n\tsum = 0;\n\tfor (i = 0; i < sizeof(*response) + response->data_len; i++)\n\t\tsum += ec_dev->din[i];\n\n\tif (sum) {\n\t\tdev_err(ec_dev->dev, \"bad packet checksum, calculated %x\\n\",\n\t\t\tsum);\n\t\tret = -EBADMSG;\n\t\tgoto exit;\n\t}\n\n\tret = response->data_len;\nexit:\n\tif (ec_msg->command == EC_CMD_REBOOT_EC)\n\t\tmsleep(EC_REBOOT_DELAY_MS);\n\n\treturn ret;\n}\n\nstatic void\ncros_ec_rpmsg_host_event_function(struct work_struct *host_event_work)\n{\n\tstruct cros_ec_rpmsg *ec_rpmsg = container_of(host_event_work,\n\t\t\t\t\t\t      struct cros_ec_rpmsg,\n\t\t\t\t\t\t      host_event_work);\n\n\tcros_ec_irq_thread(0, dev_get_drvdata(&ec_rpmsg->rpdev->dev));\n}\n\nstatic int cros_ec_rpmsg_callback(struct rpmsg_device *rpdev, void *data,\n\t\t\t\t  int len, void *priv, u32 src)\n{\n\tstruct cros_ec_device *ec_dev = dev_get_drvdata(&rpdev->dev);\n\tstruct cros_ec_rpmsg *ec_rpmsg = ec_dev->priv;\n\tstruct cros_ec_rpmsg_response *resp;\n\n\tif (!len) {\n\t\tdev_warn(ec_dev->dev, \"rpmsg received empty response\");\n\t\treturn -EINVAL;\n\t}\n\n\tresp = data;\n\tlen -= offsetof(struct cros_ec_rpmsg_response, data);\n\tif (resp->type == HOST_COMMAND_MARK) {\n\t\tif (len > ec_dev->din_size) {\n\t\t\tdev_warn(ec_dev->dev,\n\t\t\t\t \"received length %d > din_size %d, truncating\",\n\t\t\t\t len, ec_dev->din_size);\n\t\t\tlen = ec_dev->din_size;\n\t\t}\n\n\t\tmemcpy(ec_dev->din, resp->data, len);\n\t\tcomplete(&ec_rpmsg->xfer_ack);\n\t} else if (resp->type == HOST_EVENT_MARK) {\n\t\t \n\t\tif (ec_rpmsg->probe_done)\n\t\t\tschedule_work(&ec_rpmsg->host_event_work);\n\t\telse\n\t\t\tec_rpmsg->has_pending_host_event = true;\n\t} else {\n\t\tdev_warn(ec_dev->dev, \"rpmsg received invalid type = %d\",\n\t\t\t resp->type);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic struct rpmsg_endpoint *\ncros_ec_rpmsg_create_ept(struct rpmsg_device *rpdev)\n{\n\tstruct rpmsg_channel_info chinfo = {};\n\n\tstrscpy(chinfo.name, rpdev->id.name, RPMSG_NAME_SIZE);\n\tchinfo.src = rpdev->src;\n\tchinfo.dst = RPMSG_ADDR_ANY;\n\n\treturn rpmsg_create_ept(rpdev, cros_ec_rpmsg_callback, NULL, chinfo);\n}\n\nstatic int cros_ec_rpmsg_probe(struct rpmsg_device *rpdev)\n{\n\tstruct device *dev = &rpdev->dev;\n\tstruct cros_ec_rpmsg *ec_rpmsg;\n\tstruct cros_ec_device *ec_dev;\n\tint ret;\n\n\tec_dev = devm_kzalloc(dev, sizeof(*ec_dev), GFP_KERNEL);\n\tif (!ec_dev)\n\t\treturn -ENOMEM;\n\n\tec_rpmsg = devm_kzalloc(dev, sizeof(*ec_rpmsg), GFP_KERNEL);\n\tif (!ec_rpmsg)\n\t\treturn -ENOMEM;\n\n\tec_dev->dev = dev;\n\tec_dev->priv = ec_rpmsg;\n\tec_dev->cmd_xfer = cros_ec_cmd_xfer_rpmsg;\n\tec_dev->pkt_xfer = cros_ec_pkt_xfer_rpmsg;\n\tec_dev->phys_name = dev_name(&rpdev->dev);\n\tec_dev->din_size = sizeof(struct ec_host_response) +\n\t\t\t   sizeof(struct ec_response_get_protocol_info);\n\tec_dev->dout_size = sizeof(struct ec_host_request);\n\tdev_set_drvdata(dev, ec_dev);\n\n\tec_rpmsg->rpdev = rpdev;\n\tinit_completion(&ec_rpmsg->xfer_ack);\n\tINIT_WORK(&ec_rpmsg->host_event_work,\n\t\t  cros_ec_rpmsg_host_event_function);\n\n\tec_rpmsg->ept = cros_ec_rpmsg_create_ept(rpdev);\n\tif (!ec_rpmsg->ept)\n\t\treturn -ENOMEM;\n\n\tret = cros_ec_register(ec_dev);\n\tif (ret < 0) {\n\t\trpmsg_destroy_ept(ec_rpmsg->ept);\n\t\tcancel_work_sync(&ec_rpmsg->host_event_work);\n\t\treturn ret;\n\t}\n\n\tec_rpmsg->probe_done = true;\n\n\tif (ec_rpmsg->has_pending_host_event)\n\t\tschedule_work(&ec_rpmsg->host_event_work);\n\n\treturn 0;\n}\n\nstatic void cros_ec_rpmsg_remove(struct rpmsg_device *rpdev)\n{\n\tstruct cros_ec_device *ec_dev = dev_get_drvdata(&rpdev->dev);\n\tstruct cros_ec_rpmsg *ec_rpmsg = ec_dev->priv;\n\n\tcros_ec_unregister(ec_dev);\n\trpmsg_destroy_ept(ec_rpmsg->ept);\n\tcancel_work_sync(&ec_rpmsg->host_event_work);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int cros_ec_rpmsg_suspend(struct device *dev)\n{\n\tstruct cros_ec_device *ec_dev = dev_get_drvdata(dev);\n\n\treturn cros_ec_suspend(ec_dev);\n}\n\nstatic int cros_ec_rpmsg_resume(struct device *dev)\n{\n\tstruct cros_ec_device *ec_dev = dev_get_drvdata(dev);\n\n\treturn cros_ec_resume(ec_dev);\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(cros_ec_rpmsg_pm_ops, cros_ec_rpmsg_suspend,\n\t\t\t cros_ec_rpmsg_resume);\n\nstatic const struct of_device_id cros_ec_rpmsg_of_match[] = {\n\t{ .compatible = \"google,cros-ec-rpmsg\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, cros_ec_rpmsg_of_match);\n\nstatic struct rpmsg_driver cros_ec_driver_rpmsg = {\n\t.drv = {\n\t\t.name   = \"cros-ec-rpmsg\",\n\t\t.of_match_table = cros_ec_rpmsg_of_match,\n\t\t.pm\t= &cros_ec_rpmsg_pm_ops,\n\t},\n\t.probe\t\t= cros_ec_rpmsg_probe,\n\t.remove\t\t= cros_ec_rpmsg_remove,\n};\n\nmodule_rpmsg_driver(cros_ec_driver_rpmsg);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"ChromeOS EC multi function device (rpmsg)\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}