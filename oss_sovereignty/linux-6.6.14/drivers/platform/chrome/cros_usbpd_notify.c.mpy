{
  "module_name": "cros_usbpd_notify.c",
  "hash_id": "13afab0e27b848dd0cd04605ec8c47004e37b656b6377c458a1f1d0ebd91c7f5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/chrome/cros_usbpd_notify.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/module.h>\n#include <linux/platform_data/cros_ec_proto.h>\n#include <linux/platform_data/cros_usbpd_notify.h>\n#include <linux/platform_device.h>\n\n#define DRV_NAME \"cros-usbpd-notify\"\n#define DRV_NAME_PLAT_ACPI \"cros-usbpd-notify-acpi\"\n#define ACPI_DRV_NAME \"GOOG0003\"\n\nstatic BLOCKING_NOTIFIER_HEAD(cros_usbpd_notifier_list);\n\nstruct cros_usbpd_notify_data {\n\tstruct device *dev;\n\tstruct cros_ec_device *ec;\n\tstruct notifier_block nb;\n};\n\n \nint cros_usbpd_register_notify(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_register(&cros_usbpd_notifier_list,\n\t\t\t\t\t\tnb);\n}\nEXPORT_SYMBOL_GPL(cros_usbpd_register_notify);\n\n \nvoid cros_usbpd_unregister_notify(struct notifier_block *nb)\n{\n\tblocking_notifier_chain_unregister(&cros_usbpd_notifier_list, nb);\n}\nEXPORT_SYMBOL_GPL(cros_usbpd_unregister_notify);\n\nstatic void cros_usbpd_get_event_and_notify(struct device  *dev,\n\t\t\t\t\t    struct cros_ec_device *ec_dev)\n{\n\tstruct ec_response_host_event_status host_event_status;\n\tu32 event = 0;\n\tint ret;\n\n\t \n\tif (!ec_dev) {\n\t\tdev_dbg(dev,\n\t\t\t\"EC device inaccessible; sending 0 event status.\\n\");\n\t\tgoto send_notify;\n\t}\n\n\t \n\tret = cros_ec_cmd(ec_dev, 0, EC_CMD_PD_HOST_EVENT_STATUS,\n\t\t\t  NULL, 0, &host_event_status, sizeof(host_event_status));\n\tif (ret < 0) {\n\t\tdev_warn(dev, \"Can't get host event status (err: %d)\\n\", ret);\n\t\tgoto send_notify;\n\t}\n\n\tevent = host_event_status.status;\n\nsend_notify:\n\tblocking_notifier_call_chain(&cros_usbpd_notifier_list, event, NULL);\n}\n\n#ifdef CONFIG_ACPI\n\nstatic void cros_usbpd_notify_acpi(acpi_handle device, u32 event, void *data)\n{\n\tstruct cros_usbpd_notify_data *pdnotify = data;\n\n\tcros_usbpd_get_event_and_notify(pdnotify->dev, pdnotify->ec);\n}\n\nstatic int cros_usbpd_notify_probe_acpi(struct platform_device *pdev)\n{\n\tstruct cros_usbpd_notify_data *pdnotify;\n\tstruct device *dev = &pdev->dev;\n\tstruct acpi_device *adev;\n\tstruct cros_ec_device *ec_dev;\n\tacpi_status status;\n\n\tadev = ACPI_COMPANION(dev);\n\n\tpdnotify = devm_kzalloc(dev, sizeof(*pdnotify), GFP_KERNEL);\n\tif (!pdnotify)\n\t\treturn -ENOMEM;\n\n\t \n\tec_dev = dev_get_drvdata(dev->parent);\n\tif (!ec_dev) {\n\t\t \n\t\tdev_warn(dev, \"Couldn't get Chrome EC device pointer.\\n\");\n\t}\n\n\tpdnotify->dev = dev;\n\tpdnotify->ec = ec_dev;\n\n\tstatus = acpi_install_notify_handler(adev->handle,\n\t\t\t\t\t     ACPI_ALL_NOTIFY,\n\t\t\t\t\t     cros_usbpd_notify_acpi,\n\t\t\t\t\t     pdnotify);\n\tif (ACPI_FAILURE(status)) {\n\t\tdev_warn(dev, \"Failed to register notify handler %08x\\n\",\n\t\t\t status);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int cros_usbpd_notify_remove_acpi(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct acpi_device *adev = ACPI_COMPANION(dev);\n\n\tacpi_remove_notify_handler(adev->handle, ACPI_ALL_NOTIFY,\n\t\t\t\t   cros_usbpd_notify_acpi);\n\n\treturn 0;\n}\n\nstatic const struct acpi_device_id cros_usbpd_notify_acpi_device_ids[] = {\n\t{ ACPI_DRV_NAME, 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(acpi, cros_usbpd_notify_acpi_device_ids);\n\nstatic struct platform_driver cros_usbpd_notify_acpi_driver = {\n\t.driver = {\n\t\t.name = DRV_NAME_PLAT_ACPI,\n\t\t.acpi_match_table = cros_usbpd_notify_acpi_device_ids,\n\t},\n\t.probe = cros_usbpd_notify_probe_acpi,\n\t.remove = cros_usbpd_notify_remove_acpi,\n};\n\n#endif  \n\nstatic int cros_usbpd_notify_plat(struct notifier_block *nb,\n\t\t\t\t  unsigned long queued_during_suspend,\n\t\t\t\t  void *data)\n{\n\tstruct cros_usbpd_notify_data *pdnotify = container_of(nb,\n\t\t\tstruct cros_usbpd_notify_data, nb);\n\tstruct cros_ec_device *ec_dev = (struct cros_ec_device *)data;\n\tu32 host_event = cros_ec_get_host_event(ec_dev);\n\n\tif (!host_event)\n\t\treturn NOTIFY_DONE;\n\n\tif (host_event & (EC_HOST_EVENT_MASK(EC_HOST_EVENT_PD_MCU) |\n\t\t\t  EC_HOST_EVENT_MASK(EC_HOST_EVENT_USB_MUX))) {\n\t\tcros_usbpd_get_event_and_notify(pdnotify->dev, ec_dev);\n\t\treturn NOTIFY_OK;\n\t}\n\treturn NOTIFY_DONE;\n}\n\nstatic int cros_usbpd_notify_probe_plat(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct cros_ec_dev *ecdev = dev_get_drvdata(dev->parent);\n\tstruct cros_usbpd_notify_data *pdnotify;\n\tint ret;\n\n\tpdnotify = devm_kzalloc(dev, sizeof(*pdnotify), GFP_KERNEL);\n\tif (!pdnotify)\n\t\treturn -ENOMEM;\n\n\tpdnotify->dev = dev;\n\tpdnotify->ec = ecdev->ec_dev;\n\tpdnotify->nb.notifier_call = cros_usbpd_notify_plat;\n\n\tdev_set_drvdata(dev, pdnotify);\n\n\tret = blocking_notifier_chain_register(&ecdev->ec_dev->event_notifier,\n\t\t\t\t\t       &pdnotify->nb);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to register notifier\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int cros_usbpd_notify_remove_plat(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct cros_ec_dev *ecdev = dev_get_drvdata(dev->parent);\n\tstruct cros_usbpd_notify_data *pdnotify =\n\t\t(struct cros_usbpd_notify_data *)dev_get_drvdata(dev);\n\n\tblocking_notifier_chain_unregister(&ecdev->ec_dev->event_notifier,\n\t\t\t\t\t   &pdnotify->nb);\n\n\treturn 0;\n}\n\nstatic struct platform_driver cros_usbpd_notify_plat_driver = {\n\t.driver = {\n\t\t.name = DRV_NAME,\n\t},\n\t.probe = cros_usbpd_notify_probe_plat,\n\t.remove = cros_usbpd_notify_remove_plat,\n};\n\nstatic int __init cros_usbpd_notify_init(void)\n{\n\tint ret;\n\n\tret = platform_driver_register(&cros_usbpd_notify_plat_driver);\n\tif (ret < 0)\n\t\treturn ret;\n\n#ifdef CONFIG_ACPI\n\tret = platform_driver_register(&cros_usbpd_notify_acpi_driver);\n\tif (ret) {\n\t\tplatform_driver_unregister(&cros_usbpd_notify_plat_driver);\n\t\treturn ret;\n\t}\n#endif\n\treturn 0;\n}\n\nstatic void __exit cros_usbpd_notify_exit(void)\n{\n#ifdef CONFIG_ACPI\n\tplatform_driver_unregister(&cros_usbpd_notify_acpi_driver);\n#endif\n\tplatform_driver_unregister(&cros_usbpd_notify_plat_driver);\n}\n\nmodule_init(cros_usbpd_notify_init);\nmodule_exit(cros_usbpd_notify_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"ChromeOS power delivery notifier device\");\nMODULE_AUTHOR(\"Jon Flatley <jflat@chromium.org>\");\nMODULE_ALIAS(\"platform:\" DRV_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}