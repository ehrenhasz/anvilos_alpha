{
  "module_name": "mlxbf-bootctl.c",
  "hash_id": "e5fa3f04980008e0e2794c00f16cf71a2b48a1b737a3348d9b467b43a109934f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/mellanox/mlxbf-bootctl.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/arm-smccc.h>\n#include <linux/delay.h>\n#include <linux/if_ether.h>\n#include <linux/iopoll.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n\n#include \"mlxbf-bootctl.h\"\n\n#define MLXBF_BOOTCTL_SB_SECURE_MASK\t\t0x03\n#define MLXBF_BOOTCTL_SB_TEST_MASK\t\t0x0c\n#define MLXBF_BOOTCTL_SB_DEV_MASK\t\tBIT(4)\n\n#define MLXBF_SB_KEY_NUM\t\t\t4\n\n \nstatic const char *mlxbf_bootctl_svc_uuid_str =\n\t\"89c036b4-e7d7-11e6-8797-001aca00bfc4\";\n\nstruct mlxbf_bootctl_name {\n\tu32 value;\n\tconst char *name;\n};\n\nstatic struct mlxbf_bootctl_name boot_names[] = {\n\t{ MLXBF_BOOTCTL_EXTERNAL, \"external\" },\n\t{ MLXBF_BOOTCTL_EMMC, \"emmc\" },\n\t{ MLNX_BOOTCTL_SWAP_EMMC, \"swap_emmc\" },\n\t{ MLXBF_BOOTCTL_EMMC_LEGACY, \"emmc_legacy\" },\n\t{ MLXBF_BOOTCTL_NONE, \"none\" },\n};\n\nenum {\n\tMLXBF_BOOTCTL_SB_LIFECYCLE_PRODUCTION = 0,\n\tMLXBF_BOOTCTL_SB_LIFECYCLE_GA_SECURE = 1,\n\tMLXBF_BOOTCTL_SB_LIFECYCLE_GA_NON_SECURE = 2,\n\tMLXBF_BOOTCTL_SB_LIFECYCLE_RMA = 3\n};\n\nstatic const char * const mlxbf_bootctl_lifecycle_states[] = {\n\t[MLXBF_BOOTCTL_SB_LIFECYCLE_PRODUCTION] = \"Production\",\n\t[MLXBF_BOOTCTL_SB_LIFECYCLE_GA_SECURE] = \"GA Secured\",\n\t[MLXBF_BOOTCTL_SB_LIFECYCLE_GA_NON_SECURE] = \"GA Non-Secured\",\n\t[MLXBF_BOOTCTL_SB_LIFECYCLE_RMA] = \"RMA\",\n};\n\n \n#define MLXBF_RSH_LOG_TYPE_MASK\t\tGENMASK_ULL(59, 56)\n#define MLXBF_RSH_LOG_LEN_MASK\t\tGENMASK_ULL(54, 48)\n#define MLXBF_RSH_LOG_LEVEL_MASK\tGENMASK_ULL(7, 0)\n\n \n#define MLXBF_RSH_LOG_TYPE_MSG\t\t0x04ULL\n\n \n#define MLXBF_RSH_SCRATCH_BUF_CTL_OFF\t0\n#define MLXBF_RSH_SCRATCH_BUF_DATA_OFF\t0x10\n\n \nenum {\n\tMLXBF_RSH_LOG_INFO,\n\tMLXBF_RSH_LOG_WARN,\n\tMLXBF_RSH_LOG_ERR,\n\tMLXBF_RSH_LOG_ASSERT\n};\n\n \nstatic void __iomem *mlxbf_rsh_boot_data;\nstatic void __iomem *mlxbf_rsh_boot_cnt;\n\n \nstatic void __iomem *mlxbf_rsh_semaphore;\nstatic void __iomem *mlxbf_rsh_scratch_buf_ctl;\nstatic void __iomem *mlxbf_rsh_scratch_buf_data;\n\n \nstatic const char * const mlxbf_rsh_log_level[] = {\n\t\"INFO\", \"WARN\", \"ERR\", \"ASSERT\"};\n\nstatic DEFINE_MUTEX(icm_ops_lock);\nstatic DEFINE_MUTEX(os_up_lock);\nstatic DEFINE_MUTEX(mfg_ops_lock);\n\n \nenum {\n\tMLNX_MFG_TYPE_OOB_MAC = 1,\n\tMLNX_MFG_TYPE_OPN_0,\n\tMLNX_MFG_TYPE_OPN_1,\n\tMLNX_MFG_TYPE_OPN_2,\n\tMLNX_MFG_TYPE_SKU_0,\n\tMLNX_MFG_TYPE_SKU_1,\n\tMLNX_MFG_TYPE_SKU_2,\n\tMLNX_MFG_TYPE_MODL_0,\n\tMLNX_MFG_TYPE_MODL_1,\n\tMLNX_MFG_TYPE_MODL_2,\n\tMLNX_MFG_TYPE_SN_0,\n\tMLNX_MFG_TYPE_SN_1,\n\tMLNX_MFG_TYPE_SN_2,\n\tMLNX_MFG_TYPE_UUID_0,\n\tMLNX_MFG_TYPE_UUID_1,\n\tMLNX_MFG_TYPE_UUID_2,\n\tMLNX_MFG_TYPE_UUID_3,\n\tMLNX_MFG_TYPE_UUID_4,\n\tMLNX_MFG_TYPE_REV,\n};\n\n#define MLNX_MFG_OPN_VAL_LEN         24\n#define MLNX_MFG_SKU_VAL_LEN         24\n#define MLNX_MFG_MODL_VAL_LEN        24\n#define MLNX_MFG_SN_VAL_LEN          24\n#define MLNX_MFG_UUID_VAL_LEN        40\n#define MLNX_MFG_REV_VAL_LEN         8\n#define MLNX_MFG_VAL_QWORD_CNT(type) \\\n\t(MLNX_MFG_##type##_VAL_LEN / sizeof(u64))\n\n \n#define MLNX_MFG_OOB_MAC_FORMAT_LEN \\\n\t((ETH_ALEN * 2) + (ETH_ALEN - 1))\n\n \nstatic int mlxbf_bootctl_smc(unsigned int smc_op, int smc_arg)\n{\n\tstruct arm_smccc_res res;\n\n\tarm_smccc_smc(smc_op, smc_arg, 0, 0, 0, 0, 0, 0, &res);\n\n\treturn res.a0;\n}\n\n \nstatic int mlxbf_bootctl_reset_action_to_val(const char *action)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(boot_names); i++)\n\t\tif (sysfs_streq(boot_names[i].name, action))\n\t\t\treturn boot_names[i].value;\n\n\treturn -EINVAL;\n}\n\n \nstatic const char *mlxbf_bootctl_action_to_string(int action)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(boot_names); i++)\n\t\tif (boot_names[i].value == action)\n\t\t\treturn boot_names[i].name;\n\n\treturn \"invalid action\";\n}\n\nstatic ssize_t post_reset_wdog_show(struct device *dev,\n\t\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tint ret;\n\n\tret = mlxbf_bootctl_smc(MLXBF_BOOTCTL_GET_POST_RESET_WDOG, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn sprintf(buf, \"%d\\n\", ret);\n}\n\nstatic ssize_t post_reset_wdog_store(struct device *dev,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     const char *buf, size_t count)\n{\n\tunsigned long value;\n\tint ret;\n\n\tret = kstrtoul(buf, 10, &value);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mlxbf_bootctl_smc(MLXBF_BOOTCTL_SET_POST_RESET_WDOG, value);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn count;\n}\n\nstatic ssize_t mlxbf_bootctl_show(int smc_op, char *buf)\n{\n\tint action;\n\n\taction = mlxbf_bootctl_smc(smc_op, 0);\n\tif (action < 0)\n\t\treturn action;\n\n\treturn sprintf(buf, \"%s\\n\", mlxbf_bootctl_action_to_string(action));\n}\n\nstatic int mlxbf_bootctl_store(int smc_op, const char *buf, size_t count)\n{\n\tint ret, action;\n\n\taction = mlxbf_bootctl_reset_action_to_val(buf);\n\tif (action < 0)\n\t\treturn action;\n\n\tret = mlxbf_bootctl_smc(smc_op, action);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn count;\n}\n\nstatic ssize_t reset_action_show(struct device *dev,\n\t\t\t\t struct device_attribute *attr, char *buf)\n{\n\treturn mlxbf_bootctl_show(MLXBF_BOOTCTL_GET_RESET_ACTION, buf);\n}\n\nstatic ssize_t reset_action_store(struct device *dev,\n\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t  const char *buf, size_t count)\n{\n\treturn mlxbf_bootctl_store(MLXBF_BOOTCTL_SET_RESET_ACTION, buf, count);\n}\n\nstatic ssize_t second_reset_action_show(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\treturn mlxbf_bootctl_show(MLXBF_BOOTCTL_GET_SECOND_RESET_ACTION, buf);\n}\n\nstatic ssize_t second_reset_action_store(struct device *dev,\n\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t const char *buf, size_t count)\n{\n\treturn mlxbf_bootctl_store(MLXBF_BOOTCTL_SET_SECOND_RESET_ACTION, buf,\n\t\t\t\t   count);\n}\n\nstatic ssize_t lifecycle_state_show(struct device *dev,\n\t\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tint status_bits;\n\tint use_dev_key;\n\tint test_state;\n\tint lc_state;\n\n\tstatus_bits = mlxbf_bootctl_smc(MLXBF_BOOTCTL_GET_TBB_FUSE_STATUS,\n\t\t\t\t\tMLXBF_BOOTCTL_FUSE_STATUS_LIFECYCLE);\n\tif (status_bits < 0)\n\t\treturn status_bits;\n\n\tuse_dev_key = status_bits & MLXBF_BOOTCTL_SB_DEV_MASK;\n\ttest_state = status_bits & MLXBF_BOOTCTL_SB_TEST_MASK;\n\tlc_state = status_bits & MLXBF_BOOTCTL_SB_SECURE_MASK;\n\n\t \n\tif (test_state) {\n\t\treturn sprintf(buf, \"%s(test)\\n\",\n\t\t\t       mlxbf_bootctl_lifecycle_states[lc_state]);\n\t} else if (use_dev_key &&\n\t\t   (lc_state == MLXBF_BOOTCTL_SB_LIFECYCLE_GA_SECURE)) {\n\t\treturn sprintf(buf, \"Secured (development)\\n\");\n\t}\n\n\treturn sprintf(buf, \"%s\\n\", mlxbf_bootctl_lifecycle_states[lc_state]);\n}\n\nstatic ssize_t secure_boot_fuse_state_show(struct device *dev,\n\t\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t\t   char *buf)\n{\n\tint burnt, valid, key, key_state, buf_len = 0, upper_key_used = 0;\n\tconst char *status;\n\n\tkey_state = mlxbf_bootctl_smc(MLXBF_BOOTCTL_GET_TBB_FUSE_STATUS,\n\t\t\t\t      MLXBF_BOOTCTL_FUSE_STATUS_KEYS);\n\tif (key_state < 0)\n\t\treturn key_state;\n\n\t \n\tfor (key = MLXBF_SB_KEY_NUM - 1; key >= 0; key--) {\n\t\tburnt = key_state & BIT(key);\n\t\tvalid = key_state & BIT(key + MLXBF_SB_KEY_NUM);\n\n\t\tif (burnt && valid)\n\t\t\tupper_key_used = 1;\n\n\t\tif (upper_key_used) {\n\t\t\tif (burnt)\n\t\t\t\tstatus = valid ? \"Used\" : \"Wasted\";\n\t\t\telse\n\t\t\t\tstatus = valid ? \"Invalid\" : \"Skipped\";\n\t\t} else {\n\t\t\tif (burnt)\n\t\t\t\tstatus = valid ? \"InUse\" : \"Incomplete\";\n\t\t\telse\n\t\t\t\tstatus = valid ? \"Invalid\" : \"Free\";\n\t\t}\n\t\tbuf_len += sprintf(buf + buf_len, \"%d:%s \", key, status);\n\t}\n\tbuf_len += sprintf(buf + buf_len, \"\\n\");\n\n\treturn buf_len;\n}\n\nstatic ssize_t fw_reset_store(struct device *dev,\n\t\t\t      struct device_attribute *attr,\n\t\t\t      const char *buf, size_t count)\n{\n\tunsigned long key;\n\tint err;\n\n\terr = kstrtoul(buf, 16, &key);\n\tif (err)\n\t\treturn err;\n\n\tif (mlxbf_bootctl_smc(MLXBF_BOOTCTL_FW_RESET, key) < 0)\n\t\treturn -EINVAL;\n\n\treturn count;\n}\n\n \n#define RSH_SCRATCH_BUF_CTL_IDX_MASK\t0x7f\n\n \n#define RSH_SCRATCH_BUF_POLL_TIMEOUT\t100000\n\nstatic int mlxbf_rsh_log_sem_lock(void)\n{\n\tunsigned long reg;\n\n\treturn readq_poll_timeout(mlxbf_rsh_semaphore, reg, !reg, 0,\n\t\t\t\t  RSH_SCRATCH_BUF_POLL_TIMEOUT);\n}\n\nstatic void mlxbf_rsh_log_sem_unlock(void)\n{\n\twriteq(0, mlxbf_rsh_semaphore);\n}\n\nstatic ssize_t rsh_log_store(struct device *dev,\n\t\t\t     struct device_attribute *attr,\n\t\t\t     const char *buf, size_t count)\n{\n\tint rc, idx, num, len, level = MLXBF_RSH_LOG_INFO;\n\tsize_t size = count;\n\tu64 data;\n\n\tif (!size)\n\t\treturn -EINVAL;\n\n\tif (!mlxbf_rsh_semaphore || !mlxbf_rsh_scratch_buf_ctl)\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif (buf[size - 1] == '\\n')\n\t\tsize--;\n\n\t \n\tfor (idx = 0; idx < ARRAY_SIZE(mlxbf_rsh_log_level); idx++) {\n\t\tlen = strlen(mlxbf_rsh_log_level[idx]);\n\t\tif (len + 1 < size &&\n\t\t    !strncmp(buf, mlxbf_rsh_log_level[idx], len)) {\n\t\t\tbuf += len;\n\t\t\tsize -= len;\n\t\t\tlevel = idx;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\twhile (size > 0 && buf[0] == ' ') {\n\t\tsize--;\n\t\tbuf++;\n\t}\n\n\t \n\trc = mlxbf_rsh_log_sem_lock();\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tidx = readq(mlxbf_rsh_scratch_buf_ctl);\n\tnum = min((int)DIV_ROUND_UP(size, sizeof(u64)),\n\t\t  RSH_SCRATCH_BUF_CTL_IDX_MASK - idx - 1);\n\tif (num <= 0)\n\t\tgoto done;\n\n\t \n\tdata = FIELD_PREP(MLXBF_RSH_LOG_TYPE_MASK, MLXBF_RSH_LOG_TYPE_MSG);\n\tdata |= FIELD_PREP(MLXBF_RSH_LOG_LEN_MASK, num);\n\tdata |= FIELD_PREP(MLXBF_RSH_LOG_LEVEL_MASK, level);\n\twriteq(data, mlxbf_rsh_scratch_buf_data);\n\n\t \n\tfor (idx = 0; idx < num && size > 0; idx++) {\n\t\tif (size < sizeof(u64)) {\n\t\t\tdata = 0;\n\t\t\tmemcpy(&data, buf, size);\n\t\t\tsize = 0;\n\t\t} else {\n\t\t\tmemcpy(&data, buf, sizeof(u64));\n\t\t\tsize -= sizeof(u64);\n\t\t\tbuf += sizeof(u64);\n\t\t}\n\t\twriteq(data, mlxbf_rsh_scratch_buf_data);\n\t}\n\ndone:\n\t \n\tmlxbf_rsh_log_sem_unlock();\n\n\t \n\treturn count;\n}\n\nstatic ssize_t large_icm_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct arm_smccc_res res;\n\n\tmutex_lock(&icm_ops_lock);\n\tarm_smccc_smc(MLNX_HANDLE_GET_ICM_INFO, 0, 0, 0, 0,\n\t\t      0, 0, 0, &res);\n\tmutex_unlock(&icm_ops_lock);\n\tif (res.a0)\n\t\treturn -EPERM;\n\n\treturn snprintf(buf, PAGE_SIZE, \"0x%lx\", res.a1);\n}\n\nstatic ssize_t large_icm_store(struct device *dev,\n\t\t\t       struct device_attribute *attr,\n\t\t\t       const char *buf, size_t count)\n{\n\tstruct arm_smccc_res res;\n\tunsigned long icm_data;\n\tint err;\n\n\terr = kstrtoul(buf, MLXBF_LARGE_ICMC_MAX_STRING_SIZE, &icm_data);\n\tif (err)\n\t\treturn err;\n\n\tif ((icm_data != 0 && icm_data < MLXBF_LARGE_ICMC_SIZE_MIN) ||\n\t    icm_data > MLXBF_LARGE_ICMC_SIZE_MAX || icm_data % MLXBF_LARGE_ICMC_GRANULARITY)\n\t\treturn -EPERM;\n\n\tmutex_lock(&icm_ops_lock);\n\tarm_smccc_smc(MLNX_HANDLE_SET_ICM_INFO, icm_data, 0, 0, 0, 0, 0, 0, &res);\n\tmutex_unlock(&icm_ops_lock);\n\n\treturn res.a0 ? -EPERM : count;\n}\n\nstatic ssize_t os_up_store(struct device *dev,\n\t\t\t   struct device_attribute *attr,\n\t\t\t   const char *buf, size_t count)\n{\n\tstruct arm_smccc_res res;\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tif (val != 1)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&os_up_lock);\n\tarm_smccc_smc(MLNX_HANDLE_OS_UP, 0, 0, 0, 0, 0, 0, 0, &res);\n\tmutex_unlock(&os_up_lock);\n\n\treturn count;\n}\n\nstatic ssize_t oob_mac_show(struct device *dev,\n\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct arm_smccc_res res;\n\tu8 *mac_byte_ptr;\n\n\tmutex_lock(&mfg_ops_lock);\n\tarm_smccc_smc(MLXBF_BOOTCTL_GET_MFG_INFO, MLNX_MFG_TYPE_OOB_MAC, 0, 0, 0,\n\t\t      0, 0, 0, &res);\n\tmutex_unlock(&mfg_ops_lock);\n\tif (res.a0)\n\t\treturn -EPERM;\n\n\tmac_byte_ptr = (u8 *)&res.a1;\n\n\treturn sysfs_format_mac(buf, mac_byte_ptr, ETH_ALEN);\n}\n\nstatic ssize_t oob_mac_store(struct device *dev,\n\t\t\t     struct device_attribute *attr,\n\t\t\t     const char *buf, size_t count)\n{\n\tunsigned int byte[MLNX_MFG_OOB_MAC_FORMAT_LEN] = { 0 };\n\tstruct arm_smccc_res res;\n\tint byte_idx, len;\n\tu64 mac_addr = 0;\n\tu8 *mac_byte_ptr;\n\n\tif ((count - 1) != MLNX_MFG_OOB_MAC_FORMAT_LEN)\n\t\treturn -EINVAL;\n\n\tlen = sscanf(buf, \"%02x:%02x:%02x:%02x:%02x:%02x\",\n\t\t     &byte[0], &byte[1], &byte[2],\n\t\t     &byte[3], &byte[4], &byte[5]);\n\tif (len != ETH_ALEN)\n\t\treturn -EINVAL;\n\n\tmac_byte_ptr = (u8 *)&mac_addr;\n\n\tfor (byte_idx = 0; byte_idx < ETH_ALEN; byte_idx++)\n\t\tmac_byte_ptr[byte_idx] = (u8)byte[byte_idx];\n\n\tmutex_lock(&mfg_ops_lock);\n\tarm_smccc_smc(MLXBF_BOOTCTL_SET_MFG_INFO, MLNX_MFG_TYPE_OOB_MAC,\n\t\t      ETH_ALEN, mac_addr, 0, 0, 0, 0, &res);\n\tmutex_unlock(&mfg_ops_lock);\n\n\treturn res.a0 ? -EPERM : count;\n}\n\nstatic ssize_t opn_show(struct device *dev,\n\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tu64 opn_data[MLNX_MFG_VAL_QWORD_CNT(OPN) + 1] = { 0 };\n\tstruct arm_smccc_res res;\n\tint word;\n\n\tmutex_lock(&mfg_ops_lock);\n\tfor (word = 0; word < MLNX_MFG_VAL_QWORD_CNT(OPN); word++) {\n\t\tarm_smccc_smc(MLXBF_BOOTCTL_GET_MFG_INFO,\n\t\t\t      MLNX_MFG_TYPE_OPN_0 + word,\n\t\t\t      0, 0, 0, 0, 0, 0, &res);\n\t\tif (res.a0) {\n\t\t\tmutex_unlock(&mfg_ops_lock);\n\t\t\treturn -EPERM;\n\t\t}\n\t\topn_data[word] = res.a1;\n\t}\n\tmutex_unlock(&mfg_ops_lock);\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\", (char *)opn_data);\n}\n\nstatic ssize_t opn_store(struct device *dev,\n\t\t\t struct device_attribute *attr,\n\t\t\t const char *buf, size_t count)\n{\n\tu64 opn[MLNX_MFG_VAL_QWORD_CNT(OPN)] = { 0 };\n\tstruct arm_smccc_res res;\n\tint word;\n\n\tif (count > MLNX_MFG_OPN_VAL_LEN)\n\t\treturn -EINVAL;\n\n\tmemcpy(opn, buf, count);\n\n\tmutex_lock(&mfg_ops_lock);\n\tfor (word = 0; word < MLNX_MFG_VAL_QWORD_CNT(OPN); word++) {\n\t\tarm_smccc_smc(MLXBF_BOOTCTL_SET_MFG_INFO,\n\t\t\t      MLNX_MFG_TYPE_OPN_0 + word,\n\t\t\t      sizeof(u64), opn[word], 0, 0, 0, 0, &res);\n\t\tif (res.a0) {\n\t\t\tmutex_unlock(&mfg_ops_lock);\n\t\t\treturn -EPERM;\n\t\t}\n\t}\n\tmutex_unlock(&mfg_ops_lock);\n\n\treturn count;\n}\n\nstatic ssize_t sku_show(struct device *dev,\n\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tu64 sku_data[MLNX_MFG_VAL_QWORD_CNT(SKU) + 1] = { 0 };\n\tstruct arm_smccc_res res;\n\tint word;\n\n\tmutex_lock(&mfg_ops_lock);\n\tfor (word = 0; word < MLNX_MFG_VAL_QWORD_CNT(SKU); word++) {\n\t\tarm_smccc_smc(MLXBF_BOOTCTL_GET_MFG_INFO,\n\t\t\t      MLNX_MFG_TYPE_SKU_0 + word,\n\t\t\t      0, 0, 0, 0, 0, 0, &res);\n\t\tif (res.a0) {\n\t\t\tmutex_unlock(&mfg_ops_lock);\n\t\t\treturn -EPERM;\n\t\t}\n\t\tsku_data[word] = res.a1;\n\t}\n\tmutex_unlock(&mfg_ops_lock);\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\", (char *)sku_data);\n}\n\nstatic ssize_t sku_store(struct device *dev,\n\t\t\t struct device_attribute *attr,\n\t\t\t const char *buf, size_t count)\n{\n\tu64 sku[MLNX_MFG_VAL_QWORD_CNT(SKU)] = { 0 };\n\tstruct arm_smccc_res res;\n\tint word;\n\n\tif (count > MLNX_MFG_SKU_VAL_LEN)\n\t\treturn -EINVAL;\n\n\tmemcpy(sku, buf, count);\n\n\tmutex_lock(&mfg_ops_lock);\n\tfor (word = 0; word < MLNX_MFG_VAL_QWORD_CNT(SKU); word++) {\n\t\tarm_smccc_smc(MLXBF_BOOTCTL_SET_MFG_INFO,\n\t\t\t      MLNX_MFG_TYPE_SKU_0 + word,\n\t\t\t      sizeof(u64), sku[word], 0, 0, 0, 0, &res);\n\t\tif (res.a0) {\n\t\t\tmutex_unlock(&mfg_ops_lock);\n\t\t\treturn -EPERM;\n\t\t}\n\t}\n\tmutex_unlock(&mfg_ops_lock);\n\n\treturn count;\n}\n\nstatic ssize_t modl_show(struct device *dev,\n\t\t\t struct device_attribute *attr, char *buf)\n{\n\tu64 modl_data[MLNX_MFG_VAL_QWORD_CNT(MODL) + 1] = { 0 };\n\tstruct arm_smccc_res res;\n\tint word;\n\n\tmutex_lock(&mfg_ops_lock);\n\tfor (word = 0; word < MLNX_MFG_VAL_QWORD_CNT(MODL); word++) {\n\t\tarm_smccc_smc(MLXBF_BOOTCTL_GET_MFG_INFO,\n\t\t\t      MLNX_MFG_TYPE_MODL_0 + word,\n\t\t\t      0, 0, 0, 0, 0, 0, &res);\n\t\tif (res.a0) {\n\t\t\tmutex_unlock(&mfg_ops_lock);\n\t\t\treturn -EPERM;\n\t\t}\n\t\tmodl_data[word] = res.a1;\n\t}\n\tmutex_unlock(&mfg_ops_lock);\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\", (char *)modl_data);\n}\n\nstatic ssize_t modl_store(struct device *dev,\n\t\t\t  struct device_attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tu64 modl[MLNX_MFG_VAL_QWORD_CNT(MODL)] = { 0 };\n\tstruct arm_smccc_res res;\n\tint word;\n\n\tif (count > MLNX_MFG_MODL_VAL_LEN)\n\t\treturn -EINVAL;\n\n\tmemcpy(modl, buf, count);\n\n\tmutex_lock(&mfg_ops_lock);\n\tfor (word = 0; word < MLNX_MFG_VAL_QWORD_CNT(MODL); word++) {\n\t\tarm_smccc_smc(MLXBF_BOOTCTL_SET_MFG_INFO,\n\t\t\t      MLNX_MFG_TYPE_MODL_0 + word,\n\t\t\t      sizeof(u64), modl[word], 0, 0, 0, 0, &res);\n\t\tif (res.a0) {\n\t\t\tmutex_unlock(&mfg_ops_lock);\n\t\t\treturn -EPERM;\n\t\t}\n\t}\n\tmutex_unlock(&mfg_ops_lock);\n\n\treturn count;\n}\n\nstatic ssize_t sn_show(struct device *dev,\n\t\t       struct device_attribute *attr, char *buf)\n{\n\tu64 sn_data[MLNX_MFG_VAL_QWORD_CNT(SN) + 1] = { 0 };\n\tstruct arm_smccc_res res;\n\tint word;\n\n\tmutex_lock(&mfg_ops_lock);\n\tfor (word = 0; word < MLNX_MFG_VAL_QWORD_CNT(SN); word++) {\n\t\tarm_smccc_smc(MLXBF_BOOTCTL_GET_MFG_INFO,\n\t\t\t      MLNX_MFG_TYPE_SN_0 + word,\n\t\t\t      0, 0, 0, 0, 0, 0, &res);\n\t\tif (res.a0) {\n\t\t\tmutex_unlock(&mfg_ops_lock);\n\t\t\treturn -EPERM;\n\t\t}\n\t\tsn_data[word] = res.a1;\n\t}\n\tmutex_unlock(&mfg_ops_lock);\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\", (char *)sn_data);\n}\n\nstatic ssize_t sn_store(struct device *dev,\n\t\t\tstruct device_attribute *attr,\n\t\t\tconst char *buf, size_t count)\n{\n\tu64 sn[MLNX_MFG_VAL_QWORD_CNT(SN)] = { 0 };\n\tstruct arm_smccc_res res;\n\tint word;\n\n\tif (count > MLNX_MFG_SN_VAL_LEN)\n\t\treturn -EINVAL;\n\n\tmemcpy(sn, buf, count);\n\n\tmutex_lock(&mfg_ops_lock);\n\tfor (word = 0; word < MLNX_MFG_VAL_QWORD_CNT(SN); word++) {\n\t\tarm_smccc_smc(MLXBF_BOOTCTL_SET_MFG_INFO,\n\t\t\t      MLNX_MFG_TYPE_SN_0 + word,\n\t\t\t      sizeof(u64), sn[word], 0, 0, 0, 0, &res);\n\t\tif (res.a0) {\n\t\t\tmutex_unlock(&mfg_ops_lock);\n\t\t\treturn -EPERM;\n\t\t}\n\t}\n\tmutex_unlock(&mfg_ops_lock);\n\n\treturn count;\n}\n\nstatic ssize_t uuid_show(struct device *dev,\n\t\t\t struct device_attribute *attr, char *buf)\n{\n\tu64 uuid_data[MLNX_MFG_VAL_QWORD_CNT(UUID) + 1] = { 0 };\n\tstruct arm_smccc_res res;\n\tint word;\n\n\tmutex_lock(&mfg_ops_lock);\n\tfor (word = 0; word < MLNX_MFG_VAL_QWORD_CNT(UUID); word++) {\n\t\tarm_smccc_smc(MLXBF_BOOTCTL_GET_MFG_INFO,\n\t\t\t      MLNX_MFG_TYPE_UUID_0 + word,\n\t\t\t      0, 0, 0, 0, 0, 0, &res);\n\t\tif (res.a0) {\n\t\t\tmutex_unlock(&mfg_ops_lock);\n\t\t\treturn -EPERM;\n\t\t}\n\t\tuuid_data[word] = res.a1;\n\t}\n\tmutex_unlock(&mfg_ops_lock);\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\", (char *)uuid_data);\n}\n\nstatic ssize_t uuid_store(struct device *dev,\n\t\t\t  struct device_attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tu64 uuid[MLNX_MFG_VAL_QWORD_CNT(UUID)] = { 0 };\n\tstruct arm_smccc_res res;\n\tint word;\n\n\tif (count > MLNX_MFG_UUID_VAL_LEN)\n\t\treturn -EINVAL;\n\n\tmemcpy(uuid, buf, count);\n\n\tmutex_lock(&mfg_ops_lock);\n\tfor (word = 0; word < MLNX_MFG_VAL_QWORD_CNT(UUID); word++) {\n\t\tarm_smccc_smc(MLXBF_BOOTCTL_SET_MFG_INFO,\n\t\t\t      MLNX_MFG_TYPE_UUID_0 + word,\n\t\t\t      sizeof(u64), uuid[word], 0, 0, 0, 0, &res);\n\t\tif (res.a0) {\n\t\t\tmutex_unlock(&mfg_ops_lock);\n\t\t\treturn -EPERM;\n\t\t}\n\t}\n\tmutex_unlock(&mfg_ops_lock);\n\n\treturn count;\n}\n\nstatic ssize_t rev_show(struct device *dev,\n\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tu64 rev_data[MLNX_MFG_VAL_QWORD_CNT(REV) + 1] = { 0 };\n\tstruct arm_smccc_res res;\n\tint word;\n\n\tmutex_lock(&mfg_ops_lock);\n\tfor (word = 0; word < MLNX_MFG_VAL_QWORD_CNT(REV); word++) {\n\t\tarm_smccc_smc(MLXBF_BOOTCTL_GET_MFG_INFO,\n\t\t\t      MLNX_MFG_TYPE_REV + word,\n\t\t\t      0, 0, 0, 0, 0, 0, &res);\n\t\tif (res.a0) {\n\t\t\tmutex_unlock(&mfg_ops_lock);\n\t\t\treturn -EPERM;\n\t\t}\n\t\trev_data[word] = res.a1;\n\t}\n\tmutex_unlock(&mfg_ops_lock);\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\", (char *)rev_data);\n}\n\nstatic ssize_t rev_store(struct device *dev,\n\t\t\t struct device_attribute *attr,\n\t\t\t const char *buf, size_t count)\n{\n\tu64 rev[MLNX_MFG_VAL_QWORD_CNT(REV)] = { 0 };\n\tstruct arm_smccc_res res;\n\tint word;\n\n\tif (count > MLNX_MFG_REV_VAL_LEN)\n\t\treturn -EINVAL;\n\n\tmemcpy(rev, buf, count);\n\n\tmutex_lock(&mfg_ops_lock);\n\tfor (word = 0; word < MLNX_MFG_VAL_QWORD_CNT(REV); word++) {\n\t\tarm_smccc_smc(MLXBF_BOOTCTL_SET_MFG_INFO,\n\t\t\t      MLNX_MFG_TYPE_REV + word,\n\t\t\t      sizeof(u64), rev[word], 0, 0, 0, 0, &res);\n\t\tif (res.a0) {\n\t\t\tmutex_unlock(&mfg_ops_lock);\n\t\t\treturn -EPERM;\n\t\t}\n\t}\n\tmutex_unlock(&mfg_ops_lock);\n\n\treturn count;\n}\n\nstatic ssize_t mfg_lock_store(struct device *dev,\n\t\t\t      struct device_attribute *attr,\n\t\t\t      const char *buf, size_t count)\n{\n\tstruct arm_smccc_res res;\n\tunsigned long val;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\n\tif (val != 1)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&mfg_ops_lock);\n\tarm_smccc_smc(MLXBF_BOOTCTL_LOCK_MFG_INFO, 0, 0, 0, 0, 0, 0, 0, &res);\n\tmutex_unlock(&mfg_ops_lock);\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR_RW(post_reset_wdog);\nstatic DEVICE_ATTR_RW(reset_action);\nstatic DEVICE_ATTR_RW(second_reset_action);\nstatic DEVICE_ATTR_RO(lifecycle_state);\nstatic DEVICE_ATTR_RO(secure_boot_fuse_state);\nstatic DEVICE_ATTR_WO(fw_reset);\nstatic DEVICE_ATTR_WO(rsh_log);\nstatic DEVICE_ATTR_RW(large_icm);\nstatic DEVICE_ATTR_WO(os_up);\nstatic DEVICE_ATTR_RW(oob_mac);\nstatic DEVICE_ATTR_RW(opn);\nstatic DEVICE_ATTR_RW(sku);\nstatic DEVICE_ATTR_RW(modl);\nstatic DEVICE_ATTR_RW(sn);\nstatic DEVICE_ATTR_RW(uuid);\nstatic DEVICE_ATTR_RW(rev);\nstatic DEVICE_ATTR_WO(mfg_lock);\n\nstatic struct attribute *mlxbf_bootctl_attrs[] = {\n\t&dev_attr_post_reset_wdog.attr,\n\t&dev_attr_reset_action.attr,\n\t&dev_attr_second_reset_action.attr,\n\t&dev_attr_lifecycle_state.attr,\n\t&dev_attr_secure_boot_fuse_state.attr,\n\t&dev_attr_fw_reset.attr,\n\t&dev_attr_rsh_log.attr,\n\t&dev_attr_large_icm.attr,\n\t&dev_attr_os_up.attr,\n\t&dev_attr_oob_mac.attr,\n\t&dev_attr_opn.attr,\n\t&dev_attr_sku.attr,\n\t&dev_attr_modl.attr,\n\t&dev_attr_sn.attr,\n\t&dev_attr_uuid.attr,\n\t&dev_attr_rev.attr,\n\t&dev_attr_mfg_lock.attr,\n\tNULL\n};\n\nATTRIBUTE_GROUPS(mlxbf_bootctl);\n\nstatic const struct acpi_device_id mlxbf_bootctl_acpi_ids[] = {\n\t{\"MLNXBF04\", 0},\n\t{}\n};\n\nMODULE_DEVICE_TABLE(acpi, mlxbf_bootctl_acpi_ids);\n\nstatic ssize_t mlxbf_bootctl_bootfifo_read(struct file *filp,\n\t\t\t\t\t   struct kobject *kobj,\n\t\t\t\t\t   struct bin_attribute *bin_attr,\n\t\t\t\t\t   char *buf, loff_t pos,\n\t\t\t\t\t   size_t count)\n{\n\tunsigned long timeout = msecs_to_jiffies(500);\n\tunsigned long expire = jiffies + timeout;\n\tu64 data, cnt = 0;\n\tchar *p = buf;\n\n\twhile (count >= sizeof(data)) {\n\t\t \n\t\tif (!cnt) {\n\t\t\tcnt = readq(mlxbf_rsh_boot_cnt);\n\t\t\tif (!cnt) {\n\t\t\t\tif (time_after(jiffies, expire))\n\t\t\t\t\tbreak;\n\t\t\t\tusleep_range(10, 50);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tdata = readq(mlxbf_rsh_boot_data);\n\t\tmemcpy(p, &data, sizeof(data));\n\t\tcount -= sizeof(data);\n\t\tp += sizeof(data);\n\t\tcnt--;\n\t\texpire = jiffies + timeout;\n\t}\n\n\treturn p - buf;\n}\n\nstatic struct bin_attribute mlxbf_bootctl_bootfifo_sysfs_attr = {\n\t.attr = { .name = \"bootfifo\", .mode = 0400 },\n\t.read = mlxbf_bootctl_bootfifo_read,\n};\n\nstatic bool mlxbf_bootctl_guid_match(const guid_t *guid,\n\t\t\t\t     const struct arm_smccc_res *res)\n{\n\tguid_t id = GUID_INIT(res->a0, res->a1, res->a1 >> 16,\n\t\t\t      res->a2, res->a2 >> 8, res->a2 >> 16,\n\t\t\t      res->a2 >> 24, res->a3, res->a3 >> 8,\n\t\t\t      res->a3 >> 16, res->a3 >> 24);\n\n\treturn guid_equal(guid, &id);\n}\n\nstatic int mlxbf_bootctl_probe(struct platform_device *pdev)\n{\n\tstruct arm_smccc_res res = { 0 };\n\tvoid __iomem *reg;\n\tguid_t guid;\n\tint ret;\n\n\t \n\tmlxbf_rsh_boot_data = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(mlxbf_rsh_boot_data))\n\t\treturn PTR_ERR(mlxbf_rsh_boot_data);\n\n\t \n\tmlxbf_rsh_boot_cnt = devm_platform_ioremap_resource(pdev, 1);\n\tif (IS_ERR(mlxbf_rsh_boot_cnt))\n\t\treturn PTR_ERR(mlxbf_rsh_boot_cnt);\n\n\t \n\tmlxbf_rsh_semaphore = devm_platform_ioremap_resource(pdev, 2);\n\tif (IS_ERR(mlxbf_rsh_semaphore))\n\t\treturn PTR_ERR(mlxbf_rsh_semaphore);\n\n\t \n\treg = devm_platform_ioremap_resource(pdev, 3);\n\tif (IS_ERR(reg))\n\t\treturn PTR_ERR(reg);\n\tmlxbf_rsh_scratch_buf_ctl = reg + MLXBF_RSH_SCRATCH_BUF_CTL_OFF;\n\tmlxbf_rsh_scratch_buf_data = reg + MLXBF_RSH_SCRATCH_BUF_DATA_OFF;\n\n\t \n\tarm_smccc_smc(MLXBF_BOOTCTL_SIP_SVC_UID, 0, 0, 0, 0, 0, 0, 0, &res);\n\tguid_parse(mlxbf_bootctl_svc_uuid_str, &guid);\n\tif (!mlxbf_bootctl_guid_match(&guid, &res))\n\t\treturn -ENODEV;\n\n\t \n\tret = mlxbf_bootctl_smc(MLXBF_BOOTCTL_SET_RESET_ACTION,\n\t\t\t\tMLXBF_BOOTCTL_EMMC);\n\tif (ret < 0)\n\t\tdev_warn(&pdev->dev, \"Unable to reset the EMMC boot mode\\n\");\n\n\tret = sysfs_create_bin_file(&pdev->dev.kobj,\n\t\t\t\t    &mlxbf_bootctl_bootfifo_sysfs_attr);\n\tif (ret)\n\t\tpr_err(\"Unable to create bootfifo sysfs file, error %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int mlxbf_bootctl_remove(struct platform_device *pdev)\n{\n\tsysfs_remove_bin_file(&pdev->dev.kobj,\n\t\t\t      &mlxbf_bootctl_bootfifo_sysfs_attr);\n\n\treturn 0;\n}\n\nstatic struct platform_driver mlxbf_bootctl_driver = {\n\t.probe = mlxbf_bootctl_probe,\n\t.remove = mlxbf_bootctl_remove,\n\t.driver = {\n\t\t.name = \"mlxbf-bootctl\",\n\t\t.dev_groups = mlxbf_bootctl_groups,\n\t\t.acpi_match_table = mlxbf_bootctl_acpi_ids,\n\t}\n};\n\nmodule_platform_driver(mlxbf_bootctl_driver);\n\nMODULE_DESCRIPTION(\"Mellanox boot control driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Mellanox Technologies\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}