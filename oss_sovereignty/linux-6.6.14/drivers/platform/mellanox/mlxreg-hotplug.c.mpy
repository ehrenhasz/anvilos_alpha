{
  "module_name": "mlxreg-hotplug.c",
  "hash_id": "e5bd507d54f0797ad290ba7b95e1dfb4a029d566898021bcd565326046df24b5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/mellanox/mlxreg-hotplug.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/device.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/platform_data/mlxreg.h>\n#include <linux/platform_device.h>\n#include <linux/spinlock.h>\n#include <linux/string_helpers.h>\n#include <linux/regmap.h>\n#include <linux/workqueue.h>\n\n \n#define MLXREG_HOTPLUG_EVENT_OFF\t1\n#define MLXREG_HOTPLUG_MASK_OFF\t\t2\n#define MLXREG_HOTPLUG_AGGR_MASK_OFF\t1\n\n \n#define MLXREG_HOTPLUG_GOOD_HEALTH_MASK\t0x02\n\n#define MLXREG_HOTPLUG_ATTRS_MAX\t128\n#define MLXREG_HOTPLUG_NOT_ASSERT\t3\n\n \nstruct mlxreg_hotplug_priv_data {\n\tint irq;\n\tstruct device *dev;\n\tstruct platform_device *pdev;\n\tstruct mlxreg_hotplug_platform_data *plat;\n\tstruct regmap *regmap;\n\tstruct delayed_work dwork_irq;\n\tspinlock_t lock;  \n\tstruct device *hwmon;\n\tstruct attribute *mlxreg_hotplug_attr[MLXREG_HOTPLUG_ATTRS_MAX + 1];\n\tstruct sensor_device_attribute_2\n\t\t\tmlxreg_hotplug_dev_attr[MLXREG_HOTPLUG_ATTRS_MAX];\n\tstruct attribute_group group;\n\tconst struct attribute_group *groups[2];\n\tu32 cell;\n\tu32 mask;\n\tu32 aggr_cache;\n\tbool after_probe;\n\tu8 not_asserted;\n};\n\n \nstatic char *mlxreg_hotplug_udev_envp[] = { NULL, NULL };\n\nstatic int\nmlxreg_hotplug_udev_event_send(struct kobject *kobj,\n\t\t\t       struct mlxreg_core_data *data, bool action)\n{\n\tchar event_str[MLXREG_CORE_LABEL_MAX_SIZE + 2];\n\tchar label[MLXREG_CORE_LABEL_MAX_SIZE] = { 0 };\n\n\tmlxreg_hotplug_udev_envp[0] = event_str;\n\tstring_upper(label, data->label);\n\tsnprintf(event_str, MLXREG_CORE_LABEL_MAX_SIZE, \"%s=%d\", label, !!action);\n\n\treturn kobject_uevent_env(kobj, KOBJ_CHANGE, mlxreg_hotplug_udev_envp);\n}\n\nstatic void\nmlxreg_hotplug_pdata_export(void *pdata, void *regmap)\n{\n\tstruct mlxreg_core_hotplug_platform_data *dev_pdata = pdata;\n\n\t \n\tdev_pdata->regmap = regmap;\n}\n\nstatic int mlxreg_hotplug_device_create(struct mlxreg_hotplug_priv_data *priv,\n\t\t\t\t\tstruct mlxreg_core_data *data,\n\t\t\t\t\tenum mlxreg_hotplug_kind kind)\n{\n\tstruct i2c_board_info *brdinfo = data->hpdev.brdinfo;\n\tstruct mlxreg_core_hotplug_platform_data *pdata;\n\tstruct i2c_client *client;\n\n\t \n\tmlxreg_hotplug_udev_event_send(&priv->hwmon->kobj, data, true);\n\n\t \n\tif (data->hpdev.nr < 0 && data->hpdev.action != MLXREG_HOTPLUG_DEVICE_NO_ACTION)\n\t\treturn 0;\n\n\tpdata = dev_get_platdata(&priv->pdev->dev);\n\tswitch (data->hpdev.action) {\n\tcase MLXREG_HOTPLUG_DEVICE_DEFAULT_ACTION:\n\t\tdata->hpdev.adapter = i2c_get_adapter(data->hpdev.nr +\n\t\t\t\t\t\t      pdata->shift_nr);\n\t\tif (!data->hpdev.adapter) {\n\t\t\tdev_err(priv->dev, \"Failed to get adapter for bus %d\\n\",\n\t\t\t\tdata->hpdev.nr + pdata->shift_nr);\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\t \n\t\tif (brdinfo->platform_data)\n\t\t\tmlxreg_hotplug_pdata_export(brdinfo->platform_data, pdata->regmap);\n\n\t\tclient = i2c_new_client_device(data->hpdev.adapter,\n\t\t\t\t\t       brdinfo);\n\t\tif (IS_ERR(client)) {\n\t\t\tdev_err(priv->dev, \"Failed to create client %s at bus %d at addr 0x%02x\\n\",\n\t\t\t\tbrdinfo->type, data->hpdev.nr +\n\t\t\t\tpdata->shift_nr, brdinfo->addr);\n\n\t\t\ti2c_put_adapter(data->hpdev.adapter);\n\t\t\tdata->hpdev.adapter = NULL;\n\t\t\treturn PTR_ERR(client);\n\t\t}\n\n\t\tdata->hpdev.client = client;\n\t\tbreak;\n\tcase MLXREG_HOTPLUG_DEVICE_PLATFORM_ACTION:\n\t\t \n\t\tif (data->hpdev.brdinfo && data->hpdev.brdinfo->platform_data)\n\t\t\tmlxreg_hotplug_pdata_export(data->hpdev.brdinfo->platform_data,\n\t\t\t\t\t\t    pdata->regmap);\n\t\t \n\t\tdata->notifier = data->hpdev.notifier;\n\t\tdata->hpdev.pdev = platform_device_register_resndata(&priv->pdev->dev,\n\t\t\t\t\t\t\t\t     brdinfo->type,\n\t\t\t\t\t\t\t\t     data->hpdev.nr,\n\t\t\t\t\t\t\t\t     NULL, 0, data,\n\t\t\t\t\t\t\t\t     sizeof(*data));\n\t\tif (IS_ERR(data->hpdev.pdev))\n\t\t\treturn PTR_ERR(data->hpdev.pdev);\n\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (data->hpdev.notifier && data->hpdev.notifier->user_handler)\n\t\treturn data->hpdev.notifier->user_handler(data->hpdev.notifier->handle, kind, 1);\n\n\treturn 0;\n}\n\nstatic void\nmlxreg_hotplug_device_destroy(struct mlxreg_hotplug_priv_data *priv,\n\t\t\t      struct mlxreg_core_data *data,\n\t\t\t      enum mlxreg_hotplug_kind kind)\n{\n\t \n\tmlxreg_hotplug_udev_event_send(&priv->hwmon->kobj, data, false);\n\tif (data->hpdev.notifier && data->hpdev.notifier->user_handler)\n\t\tdata->hpdev.notifier->user_handler(data->hpdev.notifier->handle, kind, 0);\n\n\tswitch (data->hpdev.action) {\n\tcase MLXREG_HOTPLUG_DEVICE_DEFAULT_ACTION:\n\t\tif (data->hpdev.client) {\n\t\t\ti2c_unregister_device(data->hpdev.client);\n\t\t\tdata->hpdev.client = NULL;\n\t\t}\n\n\t\tif (data->hpdev.adapter) {\n\t\t\ti2c_put_adapter(data->hpdev.adapter);\n\t\t\tdata->hpdev.adapter = NULL;\n\t\t}\n\t\tbreak;\n\tcase MLXREG_HOTPLUG_DEVICE_PLATFORM_ACTION:\n\t\tif (data->hpdev.pdev)\n\t\t\tplatform_device_unregister(data->hpdev.pdev);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic ssize_t mlxreg_hotplug_attr_show(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tstruct mlxreg_hotplug_priv_data *priv = dev_get_drvdata(dev);\n\tstruct mlxreg_core_hotplug_platform_data *pdata;\n\tint index = to_sensor_dev_attr_2(attr)->index;\n\tint nr = to_sensor_dev_attr_2(attr)->nr;\n\tstruct mlxreg_core_item *item;\n\tstruct mlxreg_core_data *data;\n\tu32 regval;\n\tint ret;\n\n\tpdata = dev_get_platdata(&priv->pdev->dev);\n\titem = pdata->items + nr;\n\tdata = item->data + index;\n\n\tret = regmap_read(priv->regmap, data->reg, &regval);\n\tif (ret)\n\t\treturn ret;\n\n\tif (item->health) {\n\t\tregval &= data->mask;\n\t} else {\n\t\t \n\t\tif (item->inversed)\n\t\t\tregval = !(regval & data->mask);\n\t\telse\n\t\t\tregval = !!(regval & data->mask);\n\t}\n\n\treturn sprintf(buf, \"%u\\n\", regval);\n}\n\n#define PRIV_ATTR(i) priv->mlxreg_hotplug_attr[i]\n#define PRIV_DEV_ATTR(i) priv->mlxreg_hotplug_dev_attr[i]\n\nstatic int mlxreg_hotplug_item_label_index_get(u32 mask, u32 bit)\n{\n\tint i, j;\n\n\tfor (i = 0, j = -1; i <= bit; i++) {\n\t\tif (mask & BIT(i))\n\t\t\tj++;\n\t}\n\treturn j;\n}\n\nstatic int mlxreg_hotplug_attr_init(struct mlxreg_hotplug_priv_data *priv)\n{\n\tstruct mlxreg_core_hotplug_platform_data *pdata;\n\tstruct mlxreg_core_item *item;\n\tstruct mlxreg_core_data *data;\n\tunsigned long mask;\n\tu32 regval;\n\tint num_attrs = 0, id = 0, i, j, k, count, ret;\n\n\tpdata = dev_get_platdata(&priv->pdev->dev);\n\titem = pdata->items;\n\n\t \n\tfor (i = 0; i < pdata->counter; i++, item++) {\n\t\tif (item->capability) {\n\t\t\t \n\t\t\tret = regmap_read(priv->regmap, item->capability,\n\t\t\t\t\t  &regval);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\titem->mask = GENMASK((regval & item->mask) - 1, 0);\n\t\t}\n\n\t\tdata = item->data;\n\n\t\t \n\t\tmask = item->mask;\n\t\tk = 0;\n\t\tcount = item->ind ? item->ind : item->count;\n\t\tfor_each_set_bit(j, &mask, count) {\n\t\t\tif (data->capability) {\n\t\t\t\t \n\t\t\t\tret = regmap_read(priv->regmap,\n\t\t\t\t\t\t  data->capability, &regval);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\n\t\t\t\tif (!(regval & data->bit)) {\n\t\t\t\t\tdata++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tPRIV_ATTR(id) = &PRIV_DEV_ATTR(id).dev_attr.attr;\n\t\t\tPRIV_ATTR(id)->name = devm_kasprintf(&priv->pdev->dev,\n\t\t\t\t\t\t\t     GFP_KERNEL,\n\t\t\t\t\t\t\t     data->label);\n\t\t\tif (!PRIV_ATTR(id)->name) {\n\t\t\t\tdev_err(priv->dev, \"Memory allocation failed for attr %d.\\n\",\n\t\t\t\t\tid);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\n\t\t\tPRIV_DEV_ATTR(id).dev_attr.attr.name =\n\t\t\t\t\t\t\tPRIV_ATTR(id)->name;\n\t\t\tPRIV_DEV_ATTR(id).dev_attr.attr.mode = 0444;\n\t\t\tPRIV_DEV_ATTR(id).dev_attr.show =\n\t\t\t\t\t\tmlxreg_hotplug_attr_show;\n\t\t\tPRIV_DEV_ATTR(id).nr = i;\n\t\t\tPRIV_DEV_ATTR(id).index = k;\n\t\t\tsysfs_attr_init(&PRIV_DEV_ATTR(id).dev_attr.attr);\n\t\t\tdata++;\n\t\t\tid++;\n\t\t\tk++;\n\t\t}\n\t\tnum_attrs += k;\n\t}\n\n\tpriv->group.attrs = devm_kcalloc(&priv->pdev->dev,\n\t\t\t\t\t num_attrs,\n\t\t\t\t\t sizeof(struct attribute *),\n\t\t\t\t\t GFP_KERNEL);\n\tif (!priv->group.attrs)\n\t\treturn -ENOMEM;\n\n\tpriv->group.attrs = priv->mlxreg_hotplug_attr;\n\tpriv->groups[0] = &priv->group;\n\tpriv->groups[1] = NULL;\n\n\treturn 0;\n}\n\nstatic void\nmlxreg_hotplug_work_helper(struct mlxreg_hotplug_priv_data *priv,\n\t\t\t   struct mlxreg_core_item *item)\n{\n\tstruct mlxreg_core_data *data;\n\tunsigned long asserted;\n\tu32 regval, bit;\n\tint ret;\n\n\t \n\tif (unlikely(!item)) {\n\t\tdev_err(priv->dev, \"False signal: at offset:mask 0x%02x:0x%02x.\\n\",\n\t\t\titem->reg, item->mask);\n\n\t\treturn;\n\t}\n\n\t \n\tret = regmap_write(priv->regmap, item->reg + MLXREG_HOTPLUG_MASK_OFF,\n\t\t\t   0);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tret = regmap_read(priv->regmap, item->reg, &regval);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tregval &= item->mask;\n\tasserted = item->cache ^ regval;\n\titem->cache = regval;\n\tfor_each_set_bit(bit, &asserted, 8) {\n\t\tint pos;\n\n\t\tpos = mlxreg_hotplug_item_label_index_get(item->mask, bit);\n\t\tif (pos < 0)\n\t\t\tgoto out;\n\n\t\tdata = item->data + pos;\n\t\tif (regval & BIT(bit)) {\n\t\t\tif (item->inversed)\n\t\t\t\tmlxreg_hotplug_device_destroy(priv, data, item->kind);\n\t\t\telse\n\t\t\t\tmlxreg_hotplug_device_create(priv, data, item->kind);\n\t\t} else {\n\t\t\tif (item->inversed)\n\t\t\t\tmlxreg_hotplug_device_create(priv, data, item->kind);\n\t\t\telse\n\t\t\t\tmlxreg_hotplug_device_destroy(priv, data, item->kind);\n\t\t}\n\t}\n\n\t \n\tret = regmap_write(priv->regmap, item->reg + MLXREG_HOTPLUG_EVENT_OFF,\n\t\t\t   0);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tret = regmap_write(priv->regmap, item->reg + MLXREG_HOTPLUG_MASK_OFF,\n\t\t\t   item->mask);\n\n out:\n\tif (ret)\n\t\tdev_err(priv->dev, \"Failed to complete workqueue.\\n\");\n}\n\nstatic void\nmlxreg_hotplug_health_work_helper(struct mlxreg_hotplug_priv_data *priv,\n\t\t\t\t  struct mlxreg_core_item *item)\n{\n\tstruct mlxreg_core_data *data = item->data;\n\tu32 regval;\n\tint i, ret = 0;\n\n\tfor (i = 0; i < item->count; i++, data++) {\n\t\t \n\t\tret = regmap_write(priv->regmap, data->reg +\n\t\t\t\t   MLXREG_HOTPLUG_MASK_OFF, 0);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\t \n\t\tret = regmap_read(priv->regmap, data->reg, &regval);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tregval &= data->mask;\n\n\t\tif (item->cache == regval)\n\t\t\tgoto ack_event;\n\n\t\t \n\t\tif (regval == MLXREG_HOTPLUG_GOOD_HEALTH_MASK) {\n\t\t\tif (!data->attached) {\n\t\t\t\t \n\t\t\t\tmlxreg_hotplug_device_create(priv, data, item->kind);\n\t\t\t\tdata->attached = true;\n\t\t\t}\n\t\t} else {\n\t\t\tif (data->attached) {\n\t\t\t\t \n\t\t\t\tmlxreg_hotplug_device_destroy(priv, data, item->kind);\n\t\t\t\tdata->attached = false;\n\t\t\t\tdata->health_cntr = 0;\n\t\t\t}\n\t\t}\n\t\titem->cache = regval;\nack_event:\n\t\t \n\t\tret = regmap_write(priv->regmap, data->reg +\n\t\t\t\t   MLXREG_HOTPLUG_EVENT_OFF, 0);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\t \n\t\tret = regmap_write(priv->regmap, data->reg +\n\t\t\t\t   MLXREG_HOTPLUG_MASK_OFF, data->mask);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n out:\n\tif (ret)\n\t\tdev_err(priv->dev, \"Failed to complete workqueue.\\n\");\n}\n\n \nstatic void mlxreg_hotplug_work_handler(struct work_struct *work)\n{\n\tstruct mlxreg_core_hotplug_platform_data *pdata;\n\tstruct mlxreg_hotplug_priv_data *priv;\n\tstruct mlxreg_core_item *item;\n\tu32 regval, aggr_asserted;\n\tunsigned long flags;\n\tint i, ret;\n\n\tpriv = container_of(work, struct mlxreg_hotplug_priv_data,\n\t\t\t    dwork_irq.work);\n\tpdata = dev_get_platdata(&priv->pdev->dev);\n\titem = pdata->items;\n\n\t \n\tret = regmap_write(priv->regmap, pdata->cell +\n\t\t\t   MLXREG_HOTPLUG_AGGR_MASK_OFF, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t \n\tret = regmap_read(priv->regmap, pdata->cell, &regval);\n\tif (ret)\n\t\tgoto out;\n\n\tregval &= pdata->mask;\n\taggr_asserted = priv->aggr_cache ^ regval;\n\tpriv->aggr_cache = regval;\n\n\t \n\tif (priv->not_asserted == MLXREG_HOTPLUG_NOT_ASSERT) {\n\t\tpriv->not_asserted = 0;\n\t\taggr_asserted = pdata->mask;\n\t}\n\tif (!aggr_asserted)\n\t\tgoto unmask_event;\n\n\t \n\tfor (i = 0; i < pdata->counter; i++, item++) {\n\t\tif (aggr_asserted & item->aggr_mask) {\n\t\t\tif (item->health)\n\t\t\t\tmlxreg_hotplug_health_work_helper(priv, item);\n\t\t\telse\n\t\t\t\tmlxreg_hotplug_work_helper(priv, item);\n\t\t}\n\t}\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\n\t \n\tcancel_delayed_work(&priv->dwork_irq);\n\tschedule_delayed_work(&priv->dwork_irq, 0);\n\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\treturn;\n\nunmask_event:\n\tpriv->not_asserted++;\n\t \n\tret = regmap_write(priv->regmap, pdata->cell +\n\t\t\t   MLXREG_HOTPLUG_AGGR_MASK_OFF, pdata->mask);\n\n out:\n\tif (ret)\n\t\tdev_err(priv->dev, \"Failed to complete workqueue.\\n\");\n}\n\nstatic int mlxreg_hotplug_set_irq(struct mlxreg_hotplug_priv_data *priv)\n{\n\tstruct mlxreg_core_hotplug_platform_data *pdata;\n\tstruct mlxreg_core_item *item;\n\tstruct mlxreg_core_data *data;\n\tu32 regval;\n\tint i, j, ret;\n\n\tpdata = dev_get_platdata(&priv->pdev->dev);\n\titem = pdata->items;\n\n\tfor (i = 0; i < pdata->counter; i++, item++) {\n\t\t \n\t\tret = regmap_write(priv->regmap, item->reg +\n\t\t\t\t   MLXREG_HOTPLUG_EVENT_OFF, 0);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\t \n\t\tdata = item->data;\n\t\tfor (j = 0; j < item->count; j++, data++) {\n\t\t\t \n\t\t\tif (data->capability) {\n\t\t\t\t \n\t\t\t\tret = regmap_read(priv->regmap,\n\t\t\t\t\t\t  data->capability, &regval);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto out;\n\n\t\t\t\tif (!(regval & data->bit))\n\t\t\t\t\titem->mask &= ~BIT(j);\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (item->inversed) {\n\t\t\titem->cache = item->mask;\n\t\t\tret = regmap_write(priv->regmap, item->reg +\n\t\t\t\t\t   MLXREG_HOTPLUG_MASK_OFF,\n\t\t\t\t\t   item->mask);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tret = regmap_write(priv->regmap, pdata->cell +\n\t\t\t   MLXREG_HOTPLUG_AGGR_MASK_OFF, pdata->mask);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tif (pdata->cell_low) {\n\t\tret = regmap_write(priv->regmap, pdata->cell_low +\n\t\t\t\t   MLXREG_HOTPLUG_AGGR_MASK_OFF,\n\t\t\t\t   pdata->mask_low);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\t \n\tmlxreg_hotplug_work_handler(&priv->dwork_irq.work);\n\n out:\n\tif (ret)\n\t\tdev_err(priv->dev, \"Failed to set interrupts.\\n\");\n\tenable_irq(priv->irq);\n\treturn ret;\n}\n\nstatic void mlxreg_hotplug_unset_irq(struct mlxreg_hotplug_priv_data *priv)\n{\n\tstruct mlxreg_core_hotplug_platform_data *pdata;\n\tstruct mlxreg_core_item *item;\n\tstruct mlxreg_core_data *data;\n\tint count, i, j;\n\n\tpdata = dev_get_platdata(&priv->pdev->dev);\n\titem = pdata->items;\n\tdisable_irq(priv->irq);\n\tcancel_delayed_work_sync(&priv->dwork_irq);\n\n\t \n\tif (pdata->cell_low)\n\t\tregmap_write(priv->regmap, pdata->cell_low +\n\t\t\t     MLXREG_HOTPLUG_AGGR_MASK_OFF, 0);\n\n\t \n\tregmap_write(priv->regmap, pdata->cell + MLXREG_HOTPLUG_AGGR_MASK_OFF,\n\t\t     0);\n\n\t \n\tfor (i = 0; i < pdata->counter; i++, item++) {\n\t\tdata = item->data;\n\t\t \n\t\tregmap_write(priv->regmap, data->reg + MLXREG_HOTPLUG_MASK_OFF,\n\t\t\t     0);\n\t\t \n\t\tregmap_write(priv->regmap, data->reg +\n\t\t\t     MLXREG_HOTPLUG_EVENT_OFF, 0);\n\n\t\t \n\t\tcount = item->count;\n\t\tfor (j = 0; j < count; j++, data++)\n\t\t\tmlxreg_hotplug_device_destroy(priv, data, item->kind);\n\t}\n}\n\nstatic irqreturn_t mlxreg_hotplug_irq_handler(int irq, void *dev)\n{\n\tstruct mlxreg_hotplug_priv_data *priv;\n\n\tpriv = (struct mlxreg_hotplug_priv_data *)dev;\n\n\t \n\tschedule_delayed_work(&priv->dwork_irq, 0);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int mlxreg_hotplug_probe(struct platform_device *pdev)\n{\n\tstruct mlxreg_core_hotplug_platform_data *pdata;\n\tstruct mlxreg_hotplug_priv_data *priv;\n\tstruct i2c_adapter *deferred_adap;\n\tint err;\n\n\tpdata = dev_get_platdata(&pdev->dev);\n\tif (!pdata) {\n\t\tdev_err(&pdev->dev, \"Failed to get platform data.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tdeferred_adap = i2c_get_adapter(pdata->deferred_nr);\n\tif (!deferred_adap)\n\t\treturn -EPROBE_DEFER;\n\ti2c_put_adapter(deferred_adap);\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tif (pdata->irq) {\n\t\tpriv->irq = pdata->irq;\n\t} else {\n\t\tpriv->irq = platform_get_irq(pdev, 0);\n\t\tif (priv->irq < 0)\n\t\t\treturn priv->irq;\n\t}\n\n\tpriv->regmap = pdata->regmap;\n\tpriv->dev = pdev->dev.parent;\n\tpriv->pdev = pdev;\n\n\terr = devm_request_irq(&pdev->dev, priv->irq,\n\t\t\t       mlxreg_hotplug_irq_handler, IRQF_TRIGGER_FALLING\n\t\t\t       | IRQF_SHARED, \"mlxreg-hotplug\", priv);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Failed to request irq: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tdisable_irq(priv->irq);\n\tspin_lock_init(&priv->lock);\n\tINIT_DELAYED_WORK(&priv->dwork_irq, mlxreg_hotplug_work_handler);\n\tdev_set_drvdata(&pdev->dev, priv);\n\n\terr = mlxreg_hotplug_attr_init(priv);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Failed to allocate attributes: %d\\n\",\n\t\t\terr);\n\t\treturn err;\n\t}\n\n\tpriv->hwmon = devm_hwmon_device_register_with_groups(&pdev->dev,\n\t\t\t\t\t\"mlxreg_hotplug\", priv, priv->groups);\n\tif (IS_ERR(priv->hwmon)) {\n\t\tdev_err(&pdev->dev, \"Failed to register hwmon device %ld\\n\",\n\t\t\tPTR_ERR(priv->hwmon));\n\t\treturn PTR_ERR(priv->hwmon);\n\t}\n\n\t \n\tmlxreg_hotplug_set_irq(priv);\n\tpriv->after_probe = true;\n\n\treturn 0;\n}\n\nstatic int mlxreg_hotplug_remove(struct platform_device *pdev)\n{\n\tstruct mlxreg_hotplug_priv_data *priv = dev_get_drvdata(&pdev->dev);\n\n\t \n\tmlxreg_hotplug_unset_irq(priv);\n\tdevm_free_irq(&pdev->dev, priv->irq, priv);\n\n\treturn 0;\n}\n\nstatic struct platform_driver mlxreg_hotplug_driver = {\n\t.driver = {\n\t\t.name = \"mlxreg-hotplug\",\n\t},\n\t.probe = mlxreg_hotplug_probe,\n\t.remove = mlxreg_hotplug_remove,\n};\n\nmodule_platform_driver(mlxreg_hotplug_driver);\n\nMODULE_AUTHOR(\"Vadim Pasternak <vadimp@mellanox.com>\");\nMODULE_DESCRIPTION(\"Mellanox regmap hotplug platform driver\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_ALIAS(\"platform:mlxreg-hotplug\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}