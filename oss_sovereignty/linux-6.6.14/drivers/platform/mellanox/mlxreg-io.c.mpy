{
  "module_name": "mlxreg-io.c",
  "hash_id": "eed5c08aba1a7219c7bc45b199bcd5ae324fd9f8e10afeeb209cb2222a271c2b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/mellanox/mlxreg-io.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/device.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/module.h>\n#include <linux/platform_data/mlxreg.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n\n \n#define MLXREG_IO_ATT_SIZE\t10\n#define MLXREG_IO_ATT_NUM\t96\n\n \nstruct mlxreg_io_priv_data {\n\tstruct platform_device *pdev;\n\tstruct mlxreg_core_platform_data *pdata;\n\tstruct device *hwmon;\n\tstruct attribute *mlxreg_io_attr[MLXREG_IO_ATT_NUM + 1];\n\tstruct sensor_device_attribute mlxreg_io_dev_attr[MLXREG_IO_ATT_NUM];\n\tstruct attribute_group group;\n\tconst struct attribute_group *groups[2];\n\tint regsize;\n\tstruct mutex io_lock;  \n};\n\nstatic int\nmlxreg_io_get_reg(void *regmap, struct mlxreg_core_data *data, u32 in_val,\n\t\t  bool rw_flag, int regsize, u32 *regval)\n{\n\tint i, val, ret;\n\n\tret = regmap_read(regmap, data->reg, regval);\n\tif (ret)\n\t\tgoto access_error;\n\n\t \n\tif (!data->bit) {\n\t\t \n\t\tif (rw_flag) {\n\t\t\t \n\t\t\t*regval = !!(*regval & ~data->mask);\n\t\t} else {\n\t\t\t \n\t\t\t*regval &= data->mask;\n\t\t\tif (in_val)\n\t\t\t\t*regval |= ~data->mask;\n\t\t}\n\t} else if (data->mask) {\n\t\t \n\t\tif (rw_flag) {\n\t\t\t \n\t\t\t*regval = ror32(*regval & data->mask, (data->bit - 1));\n\t\t} else {\n\t\t\t \n\t\t\tin_val = rol32(in_val, data->bit - 1) & data->mask;\n\t\t\t \n\t\t\t*regval = (*regval & ~data->mask) | in_val;\n\t\t}\n\t} else {\n\t\t \n\t\tfor (i = 1; i < data->regnum; i++) {\n\t\t\tret = regmap_read(regmap, data->reg + i, &val);\n\t\t\tif (ret)\n\t\t\t\tgoto access_error;\n\n\t\t\t*regval |= rol32(val, regsize * i * 8);\n\t\t}\n\t}\n\naccess_error:\n\treturn ret;\n}\n\nstatic ssize_t\nmlxreg_io_attr_show(struct device *dev, struct device_attribute *attr,\n\t\t    char *buf)\n{\n\tstruct mlxreg_io_priv_data *priv = dev_get_drvdata(dev);\n\tint index = to_sensor_dev_attr(attr)->index;\n\tstruct mlxreg_core_data *data = priv->pdata->data + index;\n\tu32 regval = 0;\n\tint ret;\n\n\tmutex_lock(&priv->io_lock);\n\n\tret = mlxreg_io_get_reg(priv->pdata->regmap, data, 0, true,\n\t\t\t\tpriv->regsize, &regval);\n\tif (ret)\n\t\tgoto access_error;\n\n\tmutex_unlock(&priv->io_lock);\n\n\treturn sprintf(buf, \"%u\\n\", regval);\n\naccess_error:\n\tmutex_unlock(&priv->io_lock);\n\treturn ret;\n}\n\nstatic ssize_t\nmlxreg_io_attr_store(struct device *dev, struct device_attribute *attr,\n\t\t     const char *buf, size_t len)\n{\n\tstruct mlxreg_io_priv_data *priv = dev_get_drvdata(dev);\n\tint index = to_sensor_dev_attr(attr)->index;\n\tstruct mlxreg_core_data *data = priv->pdata->data + index;\n\tu32 input_val, regval;\n\tint ret;\n\n\tif (len > MLXREG_IO_ATT_SIZE)\n\t\treturn -EINVAL;\n\n\t \n\tret = kstrtou32(buf, 0, &input_val);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&priv->io_lock);\n\n\tret = mlxreg_io_get_reg(priv->pdata->regmap, data, input_val, false,\n\t\t\t\tpriv->regsize, &regval);\n\tif (ret)\n\t\tgoto access_error;\n\n\tret = regmap_write(priv->pdata->regmap, data->reg, regval);\n\tif (ret)\n\t\tgoto access_error;\n\n\tmutex_unlock(&priv->io_lock);\n\n\treturn len;\n\naccess_error:\n\tmutex_unlock(&priv->io_lock);\n\tdev_err(&priv->pdev->dev, \"Bus access error\\n\");\n\treturn ret;\n}\n\nstatic struct device_attribute mlxreg_io_devattr_rw = {\n\t.show\t= mlxreg_io_attr_show,\n\t.store\t= mlxreg_io_attr_store,\n};\n\nstatic int mlxreg_io_attr_init(struct mlxreg_io_priv_data *priv)\n{\n\tint i;\n\n\tpriv->group.attrs = devm_kcalloc(&priv->pdev->dev,\n\t\t\t\t\t priv->pdata->counter,\n\t\t\t\t\t sizeof(struct attribute *),\n\t\t\t\t\t GFP_KERNEL);\n\tif (!priv->group.attrs)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < priv->pdata->counter; i++) {\n\t\tpriv->mlxreg_io_attr[i] =\n\t\t\t\t&priv->mlxreg_io_dev_attr[i].dev_attr.attr;\n\t\tmemcpy(&priv->mlxreg_io_dev_attr[i].dev_attr,\n\t\t       &mlxreg_io_devattr_rw, sizeof(struct device_attribute));\n\n\t\t \n\t\tpriv->mlxreg_io_attr[i]->name =\n\t\t\t\tdevm_kasprintf(&priv->pdev->dev, GFP_KERNEL,\n\t\t\t\t\t       priv->pdata->data[i].label);\n\n\t\tif (!priv->mlxreg_io_attr[i]->name) {\n\t\t\tdev_err(&priv->pdev->dev, \"Memory allocation failed for sysfs attribute %d.\\n\",\n\t\t\t\ti + 1);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tpriv->mlxreg_io_dev_attr[i].dev_attr.attr.mode =\n\t\t\t\t\t\tpriv->pdata->data[i].mode;\n\t\tpriv->mlxreg_io_dev_attr[i].dev_attr.attr.name =\n\t\t\t\t\tpriv->mlxreg_io_attr[i]->name;\n\t\tpriv->mlxreg_io_dev_attr[i].index = i;\n\t\tsysfs_attr_init(&priv->mlxreg_io_dev_attr[i].dev_attr.attr);\n\t}\n\n\tpriv->group.attrs = priv->mlxreg_io_attr;\n\tpriv->groups[0] = &priv->group;\n\tpriv->groups[1] = NULL;\n\n\treturn 0;\n}\n\nstatic int mlxreg_io_probe(struct platform_device *pdev)\n{\n\tstruct mlxreg_io_priv_data *priv;\n\tint err;\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->pdata = dev_get_platdata(&pdev->dev);\n\tif (!priv->pdata) {\n\t\tdev_err(&pdev->dev, \"Failed to get platform data.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpriv->pdev = pdev;\n\tpriv->regsize = regmap_get_val_bytes(priv->pdata->regmap);\n\tif (priv->regsize < 0)\n\t\treturn priv->regsize;\n\n\terr = mlxreg_io_attr_init(priv);\n\tif (err) {\n\t\tdev_err(&priv->pdev->dev, \"Failed to allocate attributes: %d\\n\",\n\t\t\terr);\n\t\treturn err;\n\t}\n\n\tpriv->hwmon = devm_hwmon_device_register_with_groups(&pdev->dev,\n\t\t\t\t\t\t\t     \"mlxreg_io\",\n\t\t\t\t\t\t\t      priv,\n\t\t\t\t\t\t\t      priv->groups);\n\tif (IS_ERR(priv->hwmon)) {\n\t\tdev_err(&pdev->dev, \"Failed to register hwmon device %ld\\n\",\n\t\t\tPTR_ERR(priv->hwmon));\n\t\treturn PTR_ERR(priv->hwmon);\n\t}\n\n\tmutex_init(&priv->io_lock);\n\tdev_set_drvdata(&pdev->dev, priv);\n\n\treturn 0;\n}\n\nstatic int mlxreg_io_remove(struct platform_device *pdev)\n{\n\tstruct mlxreg_io_priv_data *priv = dev_get_drvdata(&pdev->dev);\n\n\tmutex_destroy(&priv->io_lock);\n\n\treturn 0;\n}\n\nstatic struct platform_driver mlxreg_io_driver = {\n\t.driver = {\n\t    .name = \"mlxreg-io\",\n\t},\n\t.probe = mlxreg_io_probe,\n\t.remove = mlxreg_io_remove,\n};\n\nmodule_platform_driver(mlxreg_io_driver);\n\nMODULE_AUTHOR(\"Vadim Pasternak <vadimp@mellanox.com>\");\nMODULE_DESCRIPTION(\"Mellanox regmap I/O access driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:mlxreg-io\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}