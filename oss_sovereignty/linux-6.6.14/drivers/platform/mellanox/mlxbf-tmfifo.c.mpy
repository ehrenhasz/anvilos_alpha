{
  "module_name": "mlxbf-tmfifo.c",
  "hash_id": "135012d0fbbb1a2df90d0ab0406333f811c75eadc435c67d5cb574bbbf8549fe",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/mellanox/mlxbf-tmfifo.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/bitfield.h>\n#include <linux/circ_buf.h>\n#include <linux/efi.h>\n#include <linux/irq.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/platform_device.h>\n#include <linux/types.h>\n\n#include <linux/virtio_config.h>\n#include <linux/virtio_console.h>\n#include <linux/virtio_ids.h>\n#include <linux/virtio_net.h>\n#include <linux/virtio_ring.h>\n\n#include \"mlxbf-tmfifo-regs.h\"\n\n \n#define MLXBF_TMFIFO_VRING_SIZE\t\t\tSZ_1K\n\n \n#define MLXBF_TMFIFO_CON_TX_BUF_SIZE\t\tSZ_32K\n\n \n#define MLXBF_TMFIFO_CON_TX_BUF_RSV_SIZE\t8\n\n \n#define MLXBF_TMFIFO_TIMER_INTERVAL\t\t(HZ / 10)\n\n \n#define MLXBF_TMFIFO_VDEV_MAX\t\t(VIRTIO_ID_CONSOLE + 1)\n\n \n#define MLXBF_TMFIFO_RESERVE_RATIO\t\t16\n\n \n#define MLXBF_TMFIFO_DATA_MIN_WORDS\t\t2\n\n \n#define TMFIFO_BF3_UID\t\t\t\t1\n\nstruct mlxbf_tmfifo;\n\n \nstruct mlxbf_tmfifo_vring {\n\tvoid *va;\n\tdma_addr_t dma;\n\tstruct virtqueue *vq;\n\tstruct vring_desc *desc;\n\tstruct vring_desc *desc_head;\n\tstruct vring_desc drop_desc;\n\tint cur_len;\n\tint rem_len;\n\tu32 pkt_len;\n\tu16 next_avail;\n\tint num;\n\tint align;\n\tint index;\n\tint vdev_id;\n\tstruct mlxbf_tmfifo *fifo;\n};\n\n \n#define IS_VRING_DROP(_r) ({ \\\n\ttypeof(_r) (r) = (_r); \\\n\t(r->desc_head == &r->drop_desc ? true : false); })\n\n \n#define VRING_DROP_DESC_MAX_LEN\t\tGENMASK(15, 0)\n\n \nenum {\n\tMLXBF_TM_RX_LWM_IRQ,\n\tMLXBF_TM_RX_HWM_IRQ,\n\tMLXBF_TM_TX_LWM_IRQ,\n\tMLXBF_TM_TX_HWM_IRQ,\n\tMLXBF_TM_MAX_IRQ\n};\n\n \nenum {\n\tMLXBF_TMFIFO_VRING_RX,\n\tMLXBF_TMFIFO_VRING_TX,\n\tMLXBF_TMFIFO_VRING_MAX\n};\n\n \nstruct mlxbf_tmfifo_vdev {\n\tstruct virtio_device vdev;\n\tu8 status;\n\tu64 features;\n\tstruct mlxbf_tmfifo_vring vrings[MLXBF_TMFIFO_VRING_MAX];\n\tunion {\n\t\tstruct virtio_console_config cons;\n\t\tstruct virtio_net_config net;\n\t} config;\n\tstruct circ_buf tx_buf;\n};\n\n \nstruct mlxbf_tmfifo_irq_info {\n\tstruct mlxbf_tmfifo *fifo;\n\tint irq;\n\tint index;\n};\n\n \nstruct mlxbf_tmfifo_io {\n\tvoid __iomem *ctl;\n\tvoid __iomem *sts;\n\tvoid __iomem *data;\n};\n\n \nstruct mlxbf_tmfifo {\n\tstruct mlxbf_tmfifo_vdev *vdev[MLXBF_TMFIFO_VDEV_MAX];\n\tstruct mutex lock;\t\t \n\tvoid __iomem *res0;\n\tvoid __iomem *res1;\n\tstruct mlxbf_tmfifo_io rx;\n\tstruct mlxbf_tmfifo_io tx;\n\tint rx_fifo_size;\n\tint tx_fifo_size;\n\tunsigned long pend_events;\n\tstruct mlxbf_tmfifo_irq_info irq_info[MLXBF_TM_MAX_IRQ];\n\tstruct work_struct work;\n\tstruct timer_list timer;\n\tstruct mlxbf_tmfifo_vring *vring[2];\n\tspinlock_t spin_lock[2];\t \n\tbool is_ready;\n};\n\n \nstruct mlxbf_tmfifo_msg_hdr {\n\tu8 type;\n\t__be16 len;\n\t \n\tu8 unused[5];\n} __packed __aligned(sizeof(u64));\n\n \nstatic u8 mlxbf_tmfifo_net_default_mac[ETH_ALEN] = {\n\t0x00, 0x1A, 0xCA, 0xFF, 0xFF, 0x01\n};\n\n \nstatic efi_char16_t mlxbf_tmfifo_efi_name[] = L\"RshimMacAddr\";\n\n \n#define MLXBF_TMFIFO_NET_L2_OVERHEAD\t(ETH_HLEN + VLAN_HLEN)\n\n \n#define MLXBF_TMFIFO_NET_FEATURES \\\n\t(BIT_ULL(VIRTIO_NET_F_MTU) | BIT_ULL(VIRTIO_NET_F_STATUS) | \\\n\t BIT_ULL(VIRTIO_NET_F_MAC))\n\n#define mlxbf_vdev_to_tmfifo(d) container_of(d, struct mlxbf_tmfifo_vdev, vdev)\n\n \nstatic void mlxbf_tmfifo_free_vrings(struct mlxbf_tmfifo *fifo,\n\t\t\t\t     struct mlxbf_tmfifo_vdev *tm_vdev)\n{\n\tstruct mlxbf_tmfifo_vring *vring;\n\tint i, size;\n\n\tfor (i = 0; i < ARRAY_SIZE(tm_vdev->vrings); i++) {\n\t\tvring = &tm_vdev->vrings[i];\n\t\tif (vring->va) {\n\t\t\tsize = vring_size(vring->num, vring->align);\n\t\t\tdma_free_coherent(tm_vdev->vdev.dev.parent, size,\n\t\t\t\t\t  vring->va, vring->dma);\n\t\t\tvring->va = NULL;\n\t\t\tif (vring->vq) {\n\t\t\t\tvring_del_virtqueue(vring->vq);\n\t\t\t\tvring->vq = NULL;\n\t\t\t}\n\t\t}\n\t}\n}\n\n \nstatic int mlxbf_tmfifo_alloc_vrings(struct mlxbf_tmfifo *fifo,\n\t\t\t\t     struct mlxbf_tmfifo_vdev *tm_vdev)\n{\n\tstruct mlxbf_tmfifo_vring *vring;\n\tstruct device *dev;\n\tdma_addr_t dma;\n\tint i, size;\n\tvoid *va;\n\n\tfor (i = 0; i < ARRAY_SIZE(tm_vdev->vrings); i++) {\n\t\tvring = &tm_vdev->vrings[i];\n\t\tvring->fifo = fifo;\n\t\tvring->num = MLXBF_TMFIFO_VRING_SIZE;\n\t\tvring->align = SMP_CACHE_BYTES;\n\t\tvring->index = i;\n\t\tvring->vdev_id = tm_vdev->vdev.id.device;\n\t\tvring->drop_desc.len = VRING_DROP_DESC_MAX_LEN;\n\t\tdev = &tm_vdev->vdev.dev;\n\n\t\tsize = vring_size(vring->num, vring->align);\n\t\tva = dma_alloc_coherent(dev->parent, size, &dma, GFP_KERNEL);\n\t\tif (!va) {\n\t\t\tmlxbf_tmfifo_free_vrings(fifo, tm_vdev);\n\t\t\tdev_err(dev->parent, \"dma_alloc_coherent failed\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tvring->va = va;\n\t\tvring->dma = dma;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void mlxbf_tmfifo_disable_irqs(struct mlxbf_tmfifo *fifo)\n{\n\tint i, irq;\n\n\tfor (i = 0; i < MLXBF_TM_MAX_IRQ; i++) {\n\t\tirq = fifo->irq_info[i].irq;\n\t\tfifo->irq_info[i].irq = 0;\n\t\tdisable_irq(irq);\n\t}\n}\n\n \nstatic irqreturn_t mlxbf_tmfifo_irq_handler(int irq, void *arg)\n{\n\tstruct mlxbf_tmfifo_irq_info *irq_info = arg;\n\n\tif (!test_and_set_bit(irq_info->index, &irq_info->fifo->pend_events))\n\t\tschedule_work(&irq_info->fifo->work);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic struct vring_desc *\nmlxbf_tmfifo_get_next_desc(struct mlxbf_tmfifo_vring *vring)\n{\n\tconst struct vring *vr = virtqueue_get_vring(vring->vq);\n\tstruct virtio_device *vdev = vring->vq->vdev;\n\tunsigned int idx, head;\n\n\tif (vring->next_avail == virtio16_to_cpu(vdev, vr->avail->idx))\n\t\treturn NULL;\n\n\t \n\tvirtio_rmb(false);\n\n\tidx = vring->next_avail % vr->num;\n\thead = virtio16_to_cpu(vdev, vr->avail->ring[idx]);\n\tif (WARN_ON(head >= vr->num))\n\t\treturn NULL;\n\n\tvring->next_avail++;\n\n\treturn &vr->desc[head];\n}\n\n \nstatic void mlxbf_tmfifo_release_desc(struct mlxbf_tmfifo_vring *vring,\n\t\t\t\t      struct vring_desc *desc, u32 len)\n{\n\tconst struct vring *vr = virtqueue_get_vring(vring->vq);\n\tstruct virtio_device *vdev = vring->vq->vdev;\n\tu16 idx, vr_idx;\n\n\tvr_idx = virtio16_to_cpu(vdev, vr->used->idx);\n\tidx = vr_idx % vr->num;\n\tvr->used->ring[idx].id = cpu_to_virtio32(vdev, desc - vr->desc);\n\tvr->used->ring[idx].len = cpu_to_virtio32(vdev, len);\n\n\t \n\tvirtio_mb(false);\n\tvr->used->idx = cpu_to_virtio16(vdev, vr_idx + 1);\n}\n\n \nstatic u32 mlxbf_tmfifo_get_pkt_len(struct mlxbf_tmfifo_vring *vring,\n\t\t\t\t    struct vring_desc *desc)\n{\n\tconst struct vring *vr = virtqueue_get_vring(vring->vq);\n\tstruct virtio_device *vdev = vring->vq->vdev;\n\tu32 len = 0, idx;\n\n\twhile (desc) {\n\t\tlen += virtio32_to_cpu(vdev, desc->len);\n\t\tif (!(virtio16_to_cpu(vdev, desc->flags) & VRING_DESC_F_NEXT))\n\t\t\tbreak;\n\t\tidx = virtio16_to_cpu(vdev, desc->next);\n\t\tdesc = &vr->desc[idx];\n\t}\n\n\treturn len;\n}\n\nstatic void mlxbf_tmfifo_release_pkt(struct mlxbf_tmfifo_vring *vring)\n{\n\tstruct vring_desc *desc_head;\n\tu32 len = 0;\n\n\tif (vring->desc_head) {\n\t\tdesc_head = vring->desc_head;\n\t\tlen = vring->pkt_len;\n\t} else {\n\t\tdesc_head = mlxbf_tmfifo_get_next_desc(vring);\n\t\tlen = mlxbf_tmfifo_get_pkt_len(vring, desc_head);\n\t}\n\n\tif (desc_head)\n\t\tmlxbf_tmfifo_release_desc(vring, desc_head, len);\n\n\tvring->pkt_len = 0;\n\tvring->desc = NULL;\n\tvring->desc_head = NULL;\n}\n\nstatic void mlxbf_tmfifo_init_net_desc(struct mlxbf_tmfifo_vring *vring,\n\t\t\t\t       struct vring_desc *desc, bool is_rx)\n{\n\tstruct virtio_device *vdev = vring->vq->vdev;\n\tstruct virtio_net_hdr *net_hdr;\n\n\tnet_hdr = phys_to_virt(virtio64_to_cpu(vdev, desc->addr));\n\tmemset(net_hdr, 0, sizeof(*net_hdr));\n}\n\n \nstatic struct vring_desc *\nmlxbf_tmfifo_get_next_pkt(struct mlxbf_tmfifo_vring *vring, bool is_rx)\n{\n\tstruct vring_desc *desc;\n\n\tdesc = mlxbf_tmfifo_get_next_desc(vring);\n\tif (desc && is_rx && vring->vdev_id == VIRTIO_ID_NET)\n\t\tmlxbf_tmfifo_init_net_desc(vring, desc, is_rx);\n\n\tvring->desc_head = desc;\n\tvring->desc = desc;\n\n\treturn desc;\n}\n\n \nstatic void mlxbf_tmfifo_timer(struct timer_list *t)\n{\n\tstruct mlxbf_tmfifo *fifo = container_of(t, struct mlxbf_tmfifo, timer);\n\tint rx, tx;\n\n\trx = !test_and_set_bit(MLXBF_TM_RX_HWM_IRQ, &fifo->pend_events);\n\ttx = !test_and_set_bit(MLXBF_TM_TX_LWM_IRQ, &fifo->pend_events);\n\n\tif (rx || tx)\n\t\tschedule_work(&fifo->work);\n\n\tmod_timer(&fifo->timer, jiffies + MLXBF_TMFIFO_TIMER_INTERVAL);\n}\n\n \nstatic void mlxbf_tmfifo_console_output_one(struct mlxbf_tmfifo_vdev *cons,\n\t\t\t\t\t    struct mlxbf_tmfifo_vring *vring,\n\t\t\t\t\t    struct vring_desc *desc)\n{\n\tconst struct vring *vr = virtqueue_get_vring(vring->vq);\n\tstruct virtio_device *vdev = &cons->vdev;\n\tu32 len, idx, seg;\n\tvoid *addr;\n\n\twhile (desc) {\n\t\taddr = phys_to_virt(virtio64_to_cpu(vdev, desc->addr));\n\t\tlen = virtio32_to_cpu(vdev, desc->len);\n\n\t\tseg = CIRC_SPACE_TO_END(cons->tx_buf.head, cons->tx_buf.tail,\n\t\t\t\t\tMLXBF_TMFIFO_CON_TX_BUF_SIZE);\n\t\tif (len <= seg) {\n\t\t\tmemcpy(cons->tx_buf.buf + cons->tx_buf.head, addr, len);\n\t\t} else {\n\t\t\tmemcpy(cons->tx_buf.buf + cons->tx_buf.head, addr, seg);\n\t\t\taddr += seg;\n\t\t\tmemcpy(cons->tx_buf.buf, addr, len - seg);\n\t\t}\n\t\tcons->tx_buf.head = (cons->tx_buf.head + len) %\n\t\t\tMLXBF_TMFIFO_CON_TX_BUF_SIZE;\n\n\t\tif (!(virtio16_to_cpu(vdev, desc->flags) & VRING_DESC_F_NEXT))\n\t\t\tbreak;\n\t\tidx = virtio16_to_cpu(vdev, desc->next);\n\t\tdesc = &vr->desc[idx];\n\t}\n}\n\n \nstatic void mlxbf_tmfifo_console_output(struct mlxbf_tmfifo_vdev *cons,\n\t\t\t\t\tstruct mlxbf_tmfifo_vring *vring)\n{\n\tstruct vring_desc *desc;\n\tu32 len, avail;\n\n\tdesc = mlxbf_tmfifo_get_next_desc(vring);\n\twhile (desc) {\n\t\t \n\t\tlen = mlxbf_tmfifo_get_pkt_len(vring, desc);\n\t\tavail = CIRC_SPACE(cons->tx_buf.head, cons->tx_buf.tail,\n\t\t\t\t   MLXBF_TMFIFO_CON_TX_BUF_SIZE);\n\t\tif (len + MLXBF_TMFIFO_CON_TX_BUF_RSV_SIZE > avail) {\n\t\t\tmlxbf_tmfifo_release_desc(vring, desc, len);\n\t\t\tbreak;\n\t\t}\n\n\t\tmlxbf_tmfifo_console_output_one(cons, vring, desc);\n\t\tmlxbf_tmfifo_release_desc(vring, desc, len);\n\t\tdesc = mlxbf_tmfifo_get_next_desc(vring);\n\t}\n}\n\n \nstatic int mlxbf_tmfifo_get_rx_avail(struct mlxbf_tmfifo *fifo)\n{\n\tu64 sts;\n\n\tsts = readq(fifo->rx.sts);\n\treturn FIELD_GET(MLXBF_TMFIFO_RX_STS__COUNT_MASK, sts);\n}\n\n \nstatic int mlxbf_tmfifo_get_tx_avail(struct mlxbf_tmfifo *fifo, int vdev_id)\n{\n\tint tx_reserve;\n\tu32 count;\n\tu64 sts;\n\n\t \n\tif (vdev_id == VIRTIO_ID_NET)\n\t\ttx_reserve = fifo->tx_fifo_size / MLXBF_TMFIFO_RESERVE_RATIO;\n\telse\n\t\ttx_reserve = 1;\n\n\tsts = readq(fifo->tx.sts);\n\tcount = FIELD_GET(MLXBF_TMFIFO_TX_STS__COUNT_MASK, sts);\n\treturn fifo->tx_fifo_size - tx_reserve - count;\n}\n\n \nstatic void mlxbf_tmfifo_console_tx(struct mlxbf_tmfifo *fifo, int avail)\n{\n\tstruct mlxbf_tmfifo_msg_hdr hdr;\n\tstruct mlxbf_tmfifo_vdev *cons;\n\tunsigned long flags;\n\tint size, seg;\n\tvoid *addr;\n\tu64 data;\n\n\t \n\tif (avail < MLXBF_TMFIFO_DATA_MIN_WORDS)\n\t\treturn;\n\n\tcons = fifo->vdev[VIRTIO_ID_CONSOLE];\n\tif (!cons || !cons->tx_buf.buf)\n\t\treturn;\n\n\t \n\tsize = CIRC_CNT(cons->tx_buf.head, cons->tx_buf.tail,\n\t\t\tMLXBF_TMFIFO_CON_TX_BUF_SIZE);\n\tif (size == 0)\n\t\treturn;\n\n\t \n\tif (size + sizeof(hdr) > avail * sizeof(u64))\n\t\tsize = avail * sizeof(u64) - sizeof(hdr);\n\n\t \n\thdr.type = VIRTIO_ID_CONSOLE;\n\thdr.len = htons(size);\n\twriteq(*(u64 *)&hdr, fifo->tx.data);\n\n\t \n\tspin_lock_irqsave(&fifo->spin_lock[0], flags);\n\n\twhile (size > 0) {\n\t\taddr = cons->tx_buf.buf + cons->tx_buf.tail;\n\n\t\tseg = CIRC_CNT_TO_END(cons->tx_buf.head, cons->tx_buf.tail,\n\t\t\t\t      MLXBF_TMFIFO_CON_TX_BUF_SIZE);\n\t\tif (seg >= sizeof(u64)) {\n\t\t\tmemcpy(&data, addr, sizeof(u64));\n\t\t} else {\n\t\t\tmemcpy(&data, addr, seg);\n\t\t\tmemcpy((u8 *)&data + seg, cons->tx_buf.buf,\n\t\t\t       sizeof(u64) - seg);\n\t\t}\n\t\twriteq(data, fifo->tx.data);\n\n\t\tif (size >= sizeof(u64)) {\n\t\t\tcons->tx_buf.tail = (cons->tx_buf.tail + sizeof(u64)) %\n\t\t\t\tMLXBF_TMFIFO_CON_TX_BUF_SIZE;\n\t\t\tsize -= sizeof(u64);\n\t\t} else {\n\t\t\tcons->tx_buf.tail = (cons->tx_buf.tail + size) %\n\t\t\t\tMLXBF_TMFIFO_CON_TX_BUF_SIZE;\n\t\t\tsize = 0;\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&fifo->spin_lock[0], flags);\n}\n\n \nstatic void mlxbf_tmfifo_rxtx_word(struct mlxbf_tmfifo_vring *vring,\n\t\t\t\t   struct vring_desc *desc,\n\t\t\t\t   bool is_rx, int len)\n{\n\tstruct virtio_device *vdev = vring->vq->vdev;\n\tstruct mlxbf_tmfifo *fifo = vring->fifo;\n\tvoid *addr;\n\tu64 data;\n\n\t \n\taddr = phys_to_virt(virtio64_to_cpu(vdev, desc->addr));\n\n\t \n\tif (is_rx)\n\t\tdata = readq(fifo->rx.data);\n\n\tif (vring->cur_len + sizeof(u64) <= len) {\n\t\t \n\t\tif (is_rx) {\n\t\t\tif (!IS_VRING_DROP(vring))\n\t\t\t\tmemcpy(addr + vring->cur_len, &data,\n\t\t\t\t       sizeof(u64));\n\t\t} else {\n\t\t\tmemcpy(&data, addr + vring->cur_len,\n\t\t\t       sizeof(u64));\n\t\t}\n\t\tvring->cur_len += sizeof(u64);\n\t} else {\n\t\t \n\t\tif (is_rx) {\n\t\t\tif (!IS_VRING_DROP(vring))\n\t\t\t\tmemcpy(addr + vring->cur_len, &data,\n\t\t\t\t       len - vring->cur_len);\n\t\t} else {\n\t\t\tdata = 0;\n\t\t\tmemcpy(&data, addr + vring->cur_len,\n\t\t\t       len - vring->cur_len);\n\t\t}\n\t\tvring->cur_len = len;\n\t}\n\n\t \n\tif (!is_rx)\n\t\twriteq(data, fifo->tx.data);\n}\n\n \nstatic void mlxbf_tmfifo_rxtx_header(struct mlxbf_tmfifo_vring *vring,\n\t\t\t\t     struct vring_desc **desc,\n\t\t\t\t     bool is_rx, bool *vring_change)\n{\n\tstruct mlxbf_tmfifo *fifo = vring->fifo;\n\tstruct virtio_net_config *config;\n\tstruct mlxbf_tmfifo_msg_hdr hdr;\n\tint vdev_id, hdr_len;\n\tbool drop_rx = false;\n\n\t \n\tif (is_rx) {\n\t\t \n\t\t*(u64 *)&hdr = readq(fifo->rx.data);\n\n\t\t \n\t\tif (hdr.len == 0)\n\t\t\treturn;\n\n\t\t \n\t\tif (hdr.type == VIRTIO_ID_NET) {\n\t\t\tvdev_id = VIRTIO_ID_NET;\n\t\t\thdr_len = sizeof(struct virtio_net_hdr);\n\t\t\tconfig = &fifo->vdev[vdev_id]->config.net;\n\t\t\t \n\t\t\tif (ntohs(hdr.len) >\n\t\t\t    __virtio16_to_cpu(virtio_legacy_is_little_endian(),\n\t\t\t\t\t      config->mtu) +\n\t\t\t\t\t      MLXBF_TMFIFO_NET_L2_OVERHEAD)\n\t\t\t\tdrop_rx = true;\n\t\t} else {\n\t\t\tvdev_id = VIRTIO_ID_CONSOLE;\n\t\t\thdr_len = 0;\n\t\t}\n\n\t\t \n\t\tif (vdev_id != vring->vdev_id) {\n\t\t\tstruct mlxbf_tmfifo_vdev *tm_dev2 = fifo->vdev[vdev_id];\n\n\t\t\tif (!tm_dev2)\n\t\t\t\treturn;\n\t\t\tvring->desc = *desc;\n\t\t\tvring = &tm_dev2->vrings[MLXBF_TMFIFO_VRING_RX];\n\t\t\t*vring_change = true;\n\t\t}\n\n\t\tif (drop_rx && !IS_VRING_DROP(vring)) {\n\t\t\tif (vring->desc_head)\n\t\t\t\tmlxbf_tmfifo_release_pkt(vring);\n\t\t\t*desc = &vring->drop_desc;\n\t\t\tvring->desc_head = *desc;\n\t\t\tvring->desc = *desc;\n\t\t}\n\n\t\tvring->pkt_len = ntohs(hdr.len) + hdr_len;\n\t} else {\n\t\t \n\t\thdr_len = (vring->vdev_id == VIRTIO_ID_NET) ?\n\t\t\t   sizeof(struct virtio_net_hdr) : 0;\n\t\tvring->pkt_len = mlxbf_tmfifo_get_pkt_len(vring, *desc);\n\t\thdr.type = (vring->vdev_id == VIRTIO_ID_NET) ?\n\t\t\t    VIRTIO_ID_NET : VIRTIO_ID_CONSOLE;\n\t\thdr.len = htons(vring->pkt_len - hdr_len);\n\t\twriteq(*(u64 *)&hdr, fifo->tx.data);\n\t}\n\n\tvring->cur_len = hdr_len;\n\tvring->rem_len = vring->pkt_len;\n\tfifo->vring[is_rx] = vring;\n}\n\n \nstatic bool mlxbf_tmfifo_rxtx_one_desc(struct mlxbf_tmfifo_vring *vring,\n\t\t\t\t       bool is_rx, int *avail)\n{\n\tconst struct vring *vr = virtqueue_get_vring(vring->vq);\n\tstruct mlxbf_tmfifo *fifo = vring->fifo;\n\tstruct virtio_device *vdev;\n\tbool vring_change = false;\n\tstruct vring_desc *desc;\n\tunsigned long flags;\n\tu32 len, idx;\n\n\tvdev = &fifo->vdev[vring->vdev_id]->vdev;\n\n\t \n\tif (!vring->desc) {\n\t\tdesc = mlxbf_tmfifo_get_next_pkt(vring, is_rx);\n\t\tif (!desc) {\n\t\t\t \n\t\t\tif (is_rx) {\n\t\t\t\tdesc = &vring->drop_desc;\n\t\t\t\tvring->desc_head = desc;\n\t\t\t\tvring->desc = desc;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tdesc = vring->desc;\n\t}\n\n\t \n\tif (vring->pkt_len == 0) {\n\t\tmlxbf_tmfifo_rxtx_header(vring, &desc, is_rx, &vring_change);\n\t\t(*avail)--;\n\n\t\t \n\t\tif (vring_change)\n\t\t\treturn false;\n\t\tgoto mlxbf_tmfifo_desc_done;\n\t}\n\n\t \n\tlen = virtio32_to_cpu(vdev, desc->len);\n\tif (len > vring->rem_len)\n\t\tlen = vring->rem_len;\n\n\t \n\tif (vring->cur_len < len) {\n\t\tmlxbf_tmfifo_rxtx_word(vring, desc, is_rx, len);\n\t\t(*avail)--;\n\t}\n\n\t \n\tif (vring->cur_len == len) {\n\t\tvring->cur_len = 0;\n\t\tvring->rem_len -= len;\n\n\t\t \n\t\tif (!IS_VRING_DROP(vring) && vring->rem_len > 0 &&\n\t\t    (virtio16_to_cpu(vdev, desc->flags) & VRING_DESC_F_NEXT)) {\n\t\t\tidx = virtio16_to_cpu(vdev, desc->next);\n\t\t\tdesc = &vr->desc[idx];\n\t\t\tgoto mlxbf_tmfifo_desc_done;\n\t\t}\n\n\t\t \n\t\tdesc = NULL;\n\t\tfifo->vring[is_rx] = NULL;\n\t\tif (!IS_VRING_DROP(vring)) {\n\t\t\tmlxbf_tmfifo_release_pkt(vring);\n\t\t} else {\n\t\t\tvring->pkt_len = 0;\n\t\t\tvring->desc_head = NULL;\n\t\t\tvring->desc = NULL;\n\t\t\treturn false;\n\t\t}\n\n\t\t \n\t\tvirtio_mb(false);\n\n\t\t \n\t\tspin_lock_irqsave(&fifo->spin_lock[is_rx], flags);\n\t\tvring_interrupt(0, vring->vq);\n\t\tspin_unlock_irqrestore(&fifo->spin_lock[is_rx], flags);\n\t}\n\nmlxbf_tmfifo_desc_done:\n\t \n\tvring->desc = desc;\n\n\treturn true;\n}\n\n \nstatic void mlxbf_tmfifo_rxtx(struct mlxbf_tmfifo_vring *vring, bool is_rx)\n{\n\tint avail = 0, devid = vring->vdev_id;\n\tstruct mlxbf_tmfifo *fifo;\n\tbool more;\n\n\tfifo = vring->fifo;\n\n\t \n\tif (!fifo || !fifo->vdev[devid])\n\t\treturn;\n\n\t \n\tif (fifo->vring[is_rx] && fifo->vring[is_rx] != vring)\n\t\treturn;\n\n\t \n\tif (WARN_ON(devid != VIRTIO_ID_NET && devid != VIRTIO_ID_CONSOLE))\n\t\treturn;\n\n\tdo {\n\t\t \n\t\tif (avail == 0) {\n\t\t\tif (is_rx)\n\t\t\t\tavail = mlxbf_tmfifo_get_rx_avail(fifo);\n\t\t\telse\n\t\t\t\tavail = mlxbf_tmfifo_get_tx_avail(fifo, devid);\n\t\t\tif (avail <= 0)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (!is_rx && devid == VIRTIO_ID_CONSOLE) {\n\t\t\tmlxbf_tmfifo_console_tx(fifo, avail);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tmore = mlxbf_tmfifo_rxtx_one_desc(vring, is_rx, &avail);\n\t} while (more);\n}\n\n \nstatic void mlxbf_tmfifo_work_rxtx(struct mlxbf_tmfifo *fifo, int queue_id,\n\t\t\t\t   int irq_id, bool is_rx)\n{\n\tstruct mlxbf_tmfifo_vdev *tm_vdev;\n\tstruct mlxbf_tmfifo_vring *vring;\n\tint i;\n\n\tif (!test_and_clear_bit(irq_id, &fifo->pend_events) ||\n\t    !fifo->irq_info[irq_id].irq)\n\t\treturn;\n\n\tfor (i = 0; i < MLXBF_TMFIFO_VDEV_MAX; i++) {\n\t\ttm_vdev = fifo->vdev[i];\n\t\tif (tm_vdev) {\n\t\t\tvring = &tm_vdev->vrings[queue_id];\n\t\t\tif (vring->vq)\n\t\t\t\tmlxbf_tmfifo_rxtx(vring, is_rx);\n\t\t}\n\t}\n}\n\n \nstatic void mlxbf_tmfifo_work_handler(struct work_struct *work)\n{\n\tstruct mlxbf_tmfifo *fifo;\n\n\tfifo = container_of(work, struct mlxbf_tmfifo, work);\n\tif (!fifo->is_ready)\n\t\treturn;\n\n\tmutex_lock(&fifo->lock);\n\n\t \n\tmlxbf_tmfifo_work_rxtx(fifo, MLXBF_TMFIFO_VRING_TX,\n\t\t\t       MLXBF_TM_TX_LWM_IRQ, false);\n\n\t \n\tmlxbf_tmfifo_work_rxtx(fifo, MLXBF_TMFIFO_VRING_RX,\n\t\t\t       MLXBF_TM_RX_HWM_IRQ, true);\n\n\tmutex_unlock(&fifo->lock);\n}\n\n \nstatic bool mlxbf_tmfifo_virtio_notify(struct virtqueue *vq)\n{\n\tstruct mlxbf_tmfifo_vring *vring = vq->priv;\n\tstruct mlxbf_tmfifo_vdev *tm_vdev;\n\tstruct mlxbf_tmfifo *fifo;\n\tunsigned long flags;\n\n\tfifo = vring->fifo;\n\n\t \n\tif (vring->index & BIT(0)) {\n\t\t \n\t\tif (vring->vdev_id == VIRTIO_ID_CONSOLE) {\n\t\t\tspin_lock_irqsave(&fifo->spin_lock[0], flags);\n\t\t\ttm_vdev = fifo->vdev[VIRTIO_ID_CONSOLE];\n\t\t\tmlxbf_tmfifo_console_output(tm_vdev, vring);\n\t\t\tspin_unlock_irqrestore(&fifo->spin_lock[0], flags);\n\t\t\tset_bit(MLXBF_TM_TX_LWM_IRQ, &fifo->pend_events);\n\t\t} else if (test_and_set_bit(MLXBF_TM_TX_LWM_IRQ,\n\t\t\t\t\t    &fifo->pend_events)) {\n\t\t\treturn true;\n\t\t}\n\t} else {\n\t\tif (test_and_set_bit(MLXBF_TM_RX_HWM_IRQ, &fifo->pend_events))\n\t\t\treturn true;\n\t}\n\n\tschedule_work(&fifo->work);\n\n\treturn true;\n}\n\n \nstatic u64 mlxbf_tmfifo_virtio_get_features(struct virtio_device *vdev)\n{\n\tstruct mlxbf_tmfifo_vdev *tm_vdev = mlxbf_vdev_to_tmfifo(vdev);\n\n\treturn tm_vdev->features;\n}\n\n \nstatic int mlxbf_tmfifo_virtio_finalize_features(struct virtio_device *vdev)\n{\n\tstruct mlxbf_tmfifo_vdev *tm_vdev = mlxbf_vdev_to_tmfifo(vdev);\n\n\ttm_vdev->features = vdev->features;\n\n\treturn 0;\n}\n\n \nstatic void mlxbf_tmfifo_virtio_del_vqs(struct virtio_device *vdev)\n{\n\tstruct mlxbf_tmfifo_vdev *tm_vdev = mlxbf_vdev_to_tmfifo(vdev);\n\tstruct mlxbf_tmfifo_vring *vring;\n\tstruct virtqueue *vq;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(tm_vdev->vrings); i++) {\n\t\tvring = &tm_vdev->vrings[i];\n\n\t\t \n\t\tif (vring->desc)\n\t\t\tmlxbf_tmfifo_release_pkt(vring);\n\t\tvq = vring->vq;\n\t\tif (vq) {\n\t\t\tvring->vq = NULL;\n\t\t\tvring_del_virtqueue(vq);\n\t\t}\n\t}\n}\n\n \nstatic int mlxbf_tmfifo_virtio_find_vqs(struct virtio_device *vdev,\n\t\t\t\t\tunsigned int nvqs,\n\t\t\t\t\tstruct virtqueue *vqs[],\n\t\t\t\t\tvq_callback_t *callbacks[],\n\t\t\t\t\tconst char * const names[],\n\t\t\t\t\tconst bool *ctx,\n\t\t\t\t\tstruct irq_affinity *desc)\n{\n\tstruct mlxbf_tmfifo_vdev *tm_vdev = mlxbf_vdev_to_tmfifo(vdev);\n\tstruct mlxbf_tmfifo_vring *vring;\n\tstruct virtqueue *vq;\n\tint i, ret, size;\n\n\tif (nvqs > ARRAY_SIZE(tm_vdev->vrings))\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < nvqs; ++i) {\n\t\tif (!names[i]) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto error;\n\t\t}\n\t\tvring = &tm_vdev->vrings[i];\n\n\t\t \n\t\tsize = vring_size(vring->num, vring->align);\n\t\tmemset(vring->va, 0, size);\n\t\tvq = vring_new_virtqueue(i, vring->num, vring->align, vdev,\n\t\t\t\t\t false, false, vring->va,\n\t\t\t\t\t mlxbf_tmfifo_virtio_notify,\n\t\t\t\t\t callbacks[i], names[i]);\n\t\tif (!vq) {\n\t\t\tdev_err(&vdev->dev, \"vring_new_virtqueue failed\\n\");\n\t\t\tret = -ENOMEM;\n\t\t\tgoto error;\n\t\t}\n\n\t\tvq->num_max = vring->num;\n\n\t\tvq->priv = vring;\n\n\t\t \n\t\tvirtio_mb(false);\n\n\t\tvqs[i] = vq;\n\t\tvring->vq = vq;\n\t}\n\n\treturn 0;\n\nerror:\n\tmlxbf_tmfifo_virtio_del_vqs(vdev);\n\treturn ret;\n}\n\n \nstatic u8 mlxbf_tmfifo_virtio_get_status(struct virtio_device *vdev)\n{\n\tstruct mlxbf_tmfifo_vdev *tm_vdev = mlxbf_vdev_to_tmfifo(vdev);\n\n\treturn tm_vdev->status;\n}\n\n \nstatic void mlxbf_tmfifo_virtio_set_status(struct virtio_device *vdev,\n\t\t\t\t\t   u8 status)\n{\n\tstruct mlxbf_tmfifo_vdev *tm_vdev = mlxbf_vdev_to_tmfifo(vdev);\n\n\ttm_vdev->status = status;\n}\n\n \nstatic void mlxbf_tmfifo_virtio_reset(struct virtio_device *vdev)\n{\n\tstruct mlxbf_tmfifo_vdev *tm_vdev = mlxbf_vdev_to_tmfifo(vdev);\n\n\ttm_vdev->status = 0;\n}\n\n \nstatic void mlxbf_tmfifo_virtio_get(struct virtio_device *vdev,\n\t\t\t\t    unsigned int offset,\n\t\t\t\t    void *buf,\n\t\t\t\t    unsigned int len)\n{\n\tstruct mlxbf_tmfifo_vdev *tm_vdev = mlxbf_vdev_to_tmfifo(vdev);\n\n\tif ((u64)offset + len > sizeof(tm_vdev->config))\n\t\treturn;\n\n\tmemcpy(buf, (u8 *)&tm_vdev->config + offset, len);\n}\n\n \nstatic void mlxbf_tmfifo_virtio_set(struct virtio_device *vdev,\n\t\t\t\t    unsigned int offset,\n\t\t\t\t    const void *buf,\n\t\t\t\t    unsigned int len)\n{\n\tstruct mlxbf_tmfifo_vdev *tm_vdev = mlxbf_vdev_to_tmfifo(vdev);\n\n\tif ((u64)offset + len > sizeof(tm_vdev->config))\n\t\treturn;\n\n\tmemcpy((u8 *)&tm_vdev->config + offset, buf, len);\n}\n\nstatic void tmfifo_virtio_dev_release(struct device *device)\n{\n\tstruct virtio_device *vdev =\n\t\t\tcontainer_of(device, struct virtio_device, dev);\n\tstruct mlxbf_tmfifo_vdev *tm_vdev = mlxbf_vdev_to_tmfifo(vdev);\n\n\tkfree(tm_vdev);\n}\n\n \nstatic const struct virtio_config_ops mlxbf_tmfifo_virtio_config_ops = {\n\t.get_features = mlxbf_tmfifo_virtio_get_features,\n\t.finalize_features = mlxbf_tmfifo_virtio_finalize_features,\n\t.find_vqs = mlxbf_tmfifo_virtio_find_vqs,\n\t.del_vqs = mlxbf_tmfifo_virtio_del_vqs,\n\t.reset = mlxbf_tmfifo_virtio_reset,\n\t.set_status = mlxbf_tmfifo_virtio_set_status,\n\t.get_status = mlxbf_tmfifo_virtio_get_status,\n\t.get = mlxbf_tmfifo_virtio_get,\n\t.set = mlxbf_tmfifo_virtio_set,\n};\n\n \nstatic int mlxbf_tmfifo_create_vdev(struct device *dev,\n\t\t\t\t    struct mlxbf_tmfifo *fifo,\n\t\t\t\t    int vdev_id, u64 features,\n\t\t\t\t    void *config, u32 size)\n{\n\tstruct mlxbf_tmfifo_vdev *tm_vdev, *reg_dev = NULL;\n\tint ret;\n\n\tmutex_lock(&fifo->lock);\n\n\ttm_vdev = fifo->vdev[vdev_id];\n\tif (tm_vdev) {\n\t\tdev_err(dev, \"vdev %d already exists\\n\", vdev_id);\n\t\tret = -EEXIST;\n\t\tgoto fail;\n\t}\n\n\ttm_vdev = kzalloc(sizeof(*tm_vdev), GFP_KERNEL);\n\tif (!tm_vdev) {\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\ttm_vdev->vdev.id.device = vdev_id;\n\ttm_vdev->vdev.config = &mlxbf_tmfifo_virtio_config_ops;\n\ttm_vdev->vdev.dev.parent = dev;\n\ttm_vdev->vdev.dev.release = tmfifo_virtio_dev_release;\n\ttm_vdev->features = features;\n\tif (config)\n\t\tmemcpy(&tm_vdev->config, config, size);\n\n\tif (mlxbf_tmfifo_alloc_vrings(fifo, tm_vdev)) {\n\t\tdev_err(dev, \"unable to allocate vring\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto vdev_fail;\n\t}\n\n\t \n\tif (vdev_id == VIRTIO_ID_CONSOLE)\n\t\ttm_vdev->tx_buf.buf = devm_kmalloc(dev,\n\t\t\t\t\t\t   MLXBF_TMFIFO_CON_TX_BUF_SIZE,\n\t\t\t\t\t\t   GFP_KERNEL);\n\tfifo->vdev[vdev_id] = tm_vdev;\n\n\t \n\tret = register_virtio_device(&tm_vdev->vdev);\n\treg_dev = tm_vdev;\n\tif (ret) {\n\t\tdev_err(dev, \"register_virtio_device failed\\n\");\n\t\tgoto vdev_fail;\n\t}\n\n\tmutex_unlock(&fifo->lock);\n\treturn 0;\n\nvdev_fail:\n\tmlxbf_tmfifo_free_vrings(fifo, tm_vdev);\n\tfifo->vdev[vdev_id] = NULL;\n\tif (reg_dev)\n\t\tput_device(&tm_vdev->vdev.dev);\n\telse\n\t\tkfree(tm_vdev);\nfail:\n\tmutex_unlock(&fifo->lock);\n\treturn ret;\n}\n\n \nstatic int mlxbf_tmfifo_delete_vdev(struct mlxbf_tmfifo *fifo, int vdev_id)\n{\n\tstruct mlxbf_tmfifo_vdev *tm_vdev;\n\n\tmutex_lock(&fifo->lock);\n\n\t \n\ttm_vdev = fifo->vdev[vdev_id];\n\tif (tm_vdev) {\n\t\tunregister_virtio_device(&tm_vdev->vdev);\n\t\tmlxbf_tmfifo_free_vrings(fifo, tm_vdev);\n\t\tfifo->vdev[vdev_id] = NULL;\n\t}\n\n\tmutex_unlock(&fifo->lock);\n\n\treturn 0;\n}\n\n \nstatic void mlxbf_tmfifo_get_cfg_mac(u8 *mac)\n{\n\tefi_guid_t guid = EFI_GLOBAL_VARIABLE_GUID;\n\tunsigned long size = ETH_ALEN;\n\tu8 buf[ETH_ALEN];\n\tefi_status_t rc;\n\n\trc = efi.get_variable(mlxbf_tmfifo_efi_name, &guid, NULL, &size, buf);\n\tif (rc == EFI_SUCCESS && size == ETH_ALEN)\n\t\tether_addr_copy(mac, buf);\n\telse\n\t\tether_addr_copy(mac, mlxbf_tmfifo_net_default_mac);\n}\n\n \nstatic void mlxbf_tmfifo_set_threshold(struct mlxbf_tmfifo *fifo)\n{\n\tu64 ctl;\n\n\t \n\tctl = readq(fifo->tx.ctl);\n\tfifo->tx_fifo_size =\n\t\tFIELD_GET(MLXBF_TMFIFO_TX_CTL__MAX_ENTRIES_MASK, ctl);\n\tctl = (ctl & ~MLXBF_TMFIFO_TX_CTL__LWM_MASK) |\n\t\tFIELD_PREP(MLXBF_TMFIFO_TX_CTL__LWM_MASK,\n\t\t\t   fifo->tx_fifo_size / 2);\n\tctl = (ctl & ~MLXBF_TMFIFO_TX_CTL__HWM_MASK) |\n\t\tFIELD_PREP(MLXBF_TMFIFO_TX_CTL__HWM_MASK,\n\t\t\t   fifo->tx_fifo_size - 1);\n\twriteq(ctl, fifo->tx.ctl);\n\n\t \n\tctl = readq(fifo->rx.ctl);\n\tfifo->rx_fifo_size =\n\t\tFIELD_GET(MLXBF_TMFIFO_RX_CTL__MAX_ENTRIES_MASK, ctl);\n\tctl = (ctl & ~MLXBF_TMFIFO_RX_CTL__LWM_MASK) |\n\t\tFIELD_PREP(MLXBF_TMFIFO_RX_CTL__LWM_MASK, 0);\n\tctl = (ctl & ~MLXBF_TMFIFO_RX_CTL__HWM_MASK) |\n\t\tFIELD_PREP(MLXBF_TMFIFO_RX_CTL__HWM_MASK, 1);\n\twriteq(ctl, fifo->rx.ctl);\n}\n\nstatic void mlxbf_tmfifo_cleanup(struct mlxbf_tmfifo *fifo)\n{\n\tint i;\n\n\tfifo->is_ready = false;\n\tdel_timer_sync(&fifo->timer);\n\tmlxbf_tmfifo_disable_irqs(fifo);\n\tcancel_work_sync(&fifo->work);\n\tfor (i = 0; i < MLXBF_TMFIFO_VDEV_MAX; i++)\n\t\tmlxbf_tmfifo_delete_vdev(fifo, i);\n}\n\n \nstatic int mlxbf_tmfifo_probe(struct platform_device *pdev)\n{\n\tstruct virtio_net_config net_config;\n\tstruct device *dev = &pdev->dev;\n\tstruct mlxbf_tmfifo *fifo;\n\tu64 dev_id;\n\tint i, rc;\n\n\trc = acpi_dev_uid_to_integer(ACPI_COMPANION(dev), &dev_id);\n\tif (rc) {\n\t\tdev_err(dev, \"Cannot retrieve UID\\n\");\n\t\treturn rc;\n\t}\n\n\tfifo = devm_kzalloc(dev, sizeof(*fifo), GFP_KERNEL);\n\tif (!fifo)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&fifo->spin_lock[0]);\n\tspin_lock_init(&fifo->spin_lock[1]);\n\tINIT_WORK(&fifo->work, mlxbf_tmfifo_work_handler);\n\tmutex_init(&fifo->lock);\n\n\t \n\tfifo->res0 = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(fifo->res0))\n\t\treturn PTR_ERR(fifo->res0);\n\n\t \n\tfifo->res1 = devm_platform_ioremap_resource(pdev, 1);\n\tif (IS_ERR(fifo->res1))\n\t\treturn PTR_ERR(fifo->res1);\n\n\tif (dev_id == TMFIFO_BF3_UID) {\n\t\tfifo->rx.ctl = fifo->res1 + MLXBF_TMFIFO_RX_CTL_BF3;\n\t\tfifo->rx.sts = fifo->res1 + MLXBF_TMFIFO_RX_STS_BF3;\n\t\tfifo->rx.data = fifo->res0 + MLXBF_TMFIFO_RX_DATA_BF3;\n\t\tfifo->tx.ctl = fifo->res1 + MLXBF_TMFIFO_TX_CTL_BF3;\n\t\tfifo->tx.sts = fifo->res1 + MLXBF_TMFIFO_TX_STS_BF3;\n\t\tfifo->tx.data = fifo->res0 + MLXBF_TMFIFO_TX_DATA_BF3;\n\t} else {\n\t\tfifo->rx.ctl = fifo->res0 + MLXBF_TMFIFO_RX_CTL;\n\t\tfifo->rx.sts = fifo->res0 + MLXBF_TMFIFO_RX_STS;\n\t\tfifo->rx.data = fifo->res0 + MLXBF_TMFIFO_RX_DATA;\n\t\tfifo->tx.ctl = fifo->res1 + MLXBF_TMFIFO_TX_CTL;\n\t\tfifo->tx.sts = fifo->res1 + MLXBF_TMFIFO_TX_STS;\n\t\tfifo->tx.data = fifo->res1 + MLXBF_TMFIFO_TX_DATA;\n\t}\n\n\tplatform_set_drvdata(pdev, fifo);\n\n\ttimer_setup(&fifo->timer, mlxbf_tmfifo_timer, 0);\n\n\tfor (i = 0; i < MLXBF_TM_MAX_IRQ; i++) {\n\t\tfifo->irq_info[i].index = i;\n\t\tfifo->irq_info[i].fifo = fifo;\n\t\tfifo->irq_info[i].irq = platform_get_irq(pdev, i);\n\t\trc = devm_request_irq(dev, fifo->irq_info[i].irq,\n\t\t\t\t      mlxbf_tmfifo_irq_handler, 0,\n\t\t\t\t      \"tmfifo\", &fifo->irq_info[i]);\n\t\tif (rc) {\n\t\t\tdev_err(dev, \"devm_request_irq failed\\n\");\n\t\t\tfifo->irq_info[i].irq = 0;\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\tmlxbf_tmfifo_set_threshold(fifo);\n\n\t \n\trc = mlxbf_tmfifo_create_vdev(dev, fifo, VIRTIO_ID_CONSOLE, 0, NULL, 0);\n\tif (rc)\n\t\tgoto fail;\n\n\t \n\tmemset(&net_config, 0, sizeof(net_config));\n\n\t \n\tnet_config.mtu = __cpu_to_virtio16(virtio_legacy_is_little_endian(),\n\t\t\t\t\t   ETH_DATA_LEN);\n\tnet_config.status = __cpu_to_virtio16(virtio_legacy_is_little_endian(),\n\t\t\t\t\t      VIRTIO_NET_S_LINK_UP);\n\tmlxbf_tmfifo_get_cfg_mac(net_config.mac);\n\trc = mlxbf_tmfifo_create_vdev(dev, fifo, VIRTIO_ID_NET,\n\t\t\t\t      MLXBF_TMFIFO_NET_FEATURES, &net_config,\n\t\t\t\t      sizeof(net_config));\n\tif (rc)\n\t\tgoto fail;\n\n\tmod_timer(&fifo->timer, jiffies + MLXBF_TMFIFO_TIMER_INTERVAL);\n\n\t \n\tvirtio_mb(false);\n\n\tfifo->is_ready = true;\n\treturn 0;\n\nfail:\n\tmlxbf_tmfifo_cleanup(fifo);\n\treturn rc;\n}\n\n \nstatic int mlxbf_tmfifo_remove(struct platform_device *pdev)\n{\n\tstruct mlxbf_tmfifo *fifo = platform_get_drvdata(pdev);\n\n\tmlxbf_tmfifo_cleanup(fifo);\n\n\treturn 0;\n}\n\nstatic const struct acpi_device_id mlxbf_tmfifo_acpi_match[] = {\n\t{ \"MLNXBF01\", 0 },\n\t{}\n};\nMODULE_DEVICE_TABLE(acpi, mlxbf_tmfifo_acpi_match);\n\nstatic struct platform_driver mlxbf_tmfifo_driver = {\n\t.probe = mlxbf_tmfifo_probe,\n\t.remove = mlxbf_tmfifo_remove,\n\t.driver = {\n\t\t.name = \"bf-tmfifo\",\n\t\t.acpi_match_table = mlxbf_tmfifo_acpi_match,\n\t},\n};\n\nmodule_platform_driver(mlxbf_tmfifo_driver);\n\nMODULE_DESCRIPTION(\"Mellanox BlueField SoC TmFifo Driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Mellanox Technologies\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}