{
  "module_name": "mlxbf-pmc.c",
  "hash_id": "61a92d402c3b47a8147d4304b9d6f18a91266c191fed84b69f0a1058496ba637",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/mellanox/mlxbf-pmc.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/arm-smccc.h>\n#include <linux/bitfield.h>\n#include <linux/errno.h>\n#include <linux/hwmon.h>\n#include <linux/platform_device.h>\n#include <linux/string.h>\n#include <uapi/linux/psci.h>\n\n#define MLXBF_PMC_WRITE_REG_32 0x82000009\n#define MLXBF_PMC_READ_REG_32 0x8200000A\n#define MLXBF_PMC_WRITE_REG_64 0x8200000B\n#define MLXBF_PMC_READ_REG_64 0x8200000C\n#define MLXBF_PMC_SIP_SVC_UID 0x8200ff01\n#define MLXBF_PMC_SIP_SVC_VERSION 0x8200ff03\n#define MLXBF_PMC_SVC_REQ_MAJOR 0\n#define MLXBF_PMC_SVC_MIN_MINOR 3\n\n#define MLXBF_PMC_SMCCC_ACCESS_VIOLATION -4\n\n#define MLXBF_PMC_EVENT_SET_BF1 0\n#define MLXBF_PMC_EVENT_SET_BF2 1\n#define MLXBF_PMC_EVENT_INFO_LEN 100\n\n#define MLXBF_PMC_MAX_BLOCKS 30\n#define MLXBF_PMC_MAX_ATTRS 30\n#define MLXBF_PMC_INFO_SZ 4\n#define MLXBF_PMC_REG_SIZE 8\n#define MLXBF_PMC_L3C_REG_SIZE 4\n\n#define MLXBF_PMC_TYPE_COUNTER 1\n#define MLXBF_PMC_TYPE_REGISTER 0\n\n#define MLXBF_PMC_PERFCTL 0\n#define MLXBF_PMC_PERFEVT 1\n#define MLXBF_PMC_PERFACC0 4\n\n#define MLXBF_PMC_PERFMON_CONFIG_WR_R_B BIT(0)\n#define MLXBF_PMC_PERFMON_CONFIG_STROBE BIT(1)\n#define MLXBF_PMC_PERFMON_CONFIG_ADDR GENMASK_ULL(4, 2)\n#define MLXBF_PMC_PERFMON_CONFIG_WDATA GENMASK_ULL(60, 5)\n\n#define MLXBF_PMC_PERFCTL_FM0 GENMASK_ULL(18, 16)\n#define MLXBF_PMC_PERFCTL_MS0 GENMASK_ULL(21, 20)\n#define MLXBF_PMC_PERFCTL_ACCM0 GENMASK_ULL(26, 24)\n#define MLXBF_PMC_PERFCTL_AD0 BIT(27)\n#define MLXBF_PMC_PERFCTL_ETRIG0 GENMASK_ULL(29, 28)\n#define MLXBF_PMC_PERFCTL_EB0 BIT(30)\n#define MLXBF_PMC_PERFCTL_EN0 BIT(31)\n\n#define MLXBF_PMC_PERFEVT_EVTSEL GENMASK_ULL(31, 24)\n\n#define MLXBF_PMC_L3C_PERF_CNT_CFG 0x0\n#define MLXBF_PMC_L3C_PERF_CNT_SEL 0x10\n#define MLXBF_PMC_L3C_PERF_CNT_SEL_1 0x14\n#define MLXBF_PMC_L3C_PERF_CNT_LOW 0x40\n#define MLXBF_PMC_L3C_PERF_CNT_HIGH 0x60\n\n#define MLXBF_PMC_L3C_PERF_CNT_CFG_EN BIT(0)\n#define MLXBF_PMC_L3C_PERF_CNT_CFG_RST BIT(1)\n#define MLXBF_PMC_L3C_PERF_CNT_SEL_CNT_0 GENMASK(5, 0)\n#define MLXBF_PMC_L3C_PERF_CNT_SEL_CNT_1 GENMASK(13, 8)\n#define MLXBF_PMC_L3C_PERF_CNT_SEL_CNT_2 GENMASK(21, 16)\n#define MLXBF_PMC_L3C_PERF_CNT_SEL_CNT_3 GENMASK(29, 24)\n\n#define MLXBF_PMC_L3C_PERF_CNT_SEL_1_CNT_4 GENMASK(5, 0)\n\n#define MLXBF_PMC_L3C_PERF_CNT_LOW_VAL GENMASK(31, 0)\n#define MLXBF_PMC_L3C_PERF_CNT_HIGH_VAL GENMASK(24, 0)\n\n \nstruct mlxbf_pmc_attribute {\n\tstruct device_attribute dev_attr;\n\tint index;\n\tint nr;\n};\n\n \nstruct mlxbf_pmc_block_info {\n\tvoid __iomem *mmio_base;\n\tsize_t blk_size;\n\tsize_t counters;\n\tint type;\n\tstruct mlxbf_pmc_attribute *attr_counter;\n\tstruct mlxbf_pmc_attribute *attr_event;\n\tstruct mlxbf_pmc_attribute attr_event_list;\n\tstruct mlxbf_pmc_attribute attr_enable;\n\tstruct attribute *block_attr[MLXBF_PMC_MAX_ATTRS];\n\tstruct attribute_group block_attr_grp;\n};\n\n \nstruct mlxbf_pmc_context {\n\tstruct platform_device *pdev;\n\tuint32_t total_blocks;\n\tuint32_t tile_count;\n\tstruct device *hwmon_dev;\n\tconst char *block_name[MLXBF_PMC_MAX_BLOCKS];\n\tstruct mlxbf_pmc_block_info block[MLXBF_PMC_MAX_BLOCKS];\n\tconst struct attribute_group *groups[MLXBF_PMC_MAX_BLOCKS];\n\tbool svc_sreg_support;\n\tuint32_t sreg_tbl_perf;\n\tunsigned int event_set;\n};\n\n \nstruct mlxbf_pmc_events {\n\tint evt_num;\n\tchar *evt_name;\n};\n\nstatic const struct mlxbf_pmc_events mlxbf_pmc_pcie_events[] = {\n\t{ 0x0, \"IN_P_PKT_CNT\" },\n\t{ 0x10, \"IN_NP_PKT_CNT\" },\n\t{ 0x18, \"IN_C_PKT_CNT\" },\n\t{ 0x20, \"OUT_P_PKT_CNT\" },\n\t{ 0x28, \"OUT_NP_PKT_CNT\" },\n\t{ 0x30, \"OUT_C_PKT_CNT\" },\n\t{ 0x38, \"IN_P_BYTE_CNT\" },\n\t{ 0x40, \"IN_NP_BYTE_CNT\" },\n\t{ 0x48, \"IN_C_BYTE_CNT\" },\n\t{ 0x50, \"OUT_P_BYTE_CNT\" },\n\t{ 0x58, \"OUT_NP_BYTE_CNT\" },\n\t{ 0x60, \"OUT_C_BYTE_CNT\" },\n};\n\nstatic const struct mlxbf_pmc_events mlxbf_pmc_smgen_events[] = {\n\t{ 0x0, \"AW_REQ\" },\n\t{ 0x1, \"AW_BEATS\" },\n\t{ 0x2, \"AW_TRANS\" },\n\t{ 0x3, \"AW_RESP\" },\n\t{ 0x4, \"AW_STL\" },\n\t{ 0x5, \"AW_LAT\" },\n\t{ 0x6, \"AW_REQ_TBU\" },\n\t{ 0x8, \"AR_REQ\" },\n\t{ 0x9, \"AR_BEATS\" },\n\t{ 0xa, \"AR_TRANS\" },\n\t{ 0xb, \"AR_STL\" },\n\t{ 0xc, \"AR_LAT\" },\n\t{ 0xd, \"AR_REQ_TBU\" },\n\t{ 0xe, \"TBU_MISS\" },\n\t{ 0xf, \"TX_DAT_AF\" },\n\t{ 0x10, \"RX_DAT_AF\" },\n\t{ 0x11, \"RETRYQ_CRED\" },\n};\n\nstatic const struct mlxbf_pmc_events mlxbf_pmc_trio_events_1[] = {\n\t{ 0x0, \"DISABLE\" },\n\t{ 0xa0, \"TPIO_DATA_BEAT\" },\n\t{ 0xa1, \"TDMA_DATA_BEAT\" },\n\t{ 0xa2, \"MAP_DATA_BEAT\" },\n\t{ 0xa3, \"TXMSG_DATA_BEAT\" },\n\t{ 0xa4, \"TPIO_DATA_PACKET\" },\n\t{ 0xa5, \"TDMA_DATA_PACKET\" },\n\t{ 0xa6, \"MAP_DATA_PACKET\" },\n\t{ 0xa7, \"TXMSG_DATA_PACKET\" },\n\t{ 0xa8, \"TDMA_RT_AF\" },\n\t{ 0xa9, \"TDMA_PBUF_MAC_AF\" },\n\t{ 0xaa, \"TRIO_MAP_WRQ_BUF_EMPTY\" },\n\t{ 0xab, \"TRIO_MAP_CPL_BUF_EMPTY\" },\n\t{ 0xac, \"TRIO_MAP_RDQ0_BUF_EMPTY\" },\n\t{ 0xad, \"TRIO_MAP_RDQ1_BUF_EMPTY\" },\n\t{ 0xae, \"TRIO_MAP_RDQ2_BUF_EMPTY\" },\n\t{ 0xaf, \"TRIO_MAP_RDQ3_BUF_EMPTY\" },\n\t{ 0xb0, \"TRIO_MAP_RDQ4_BUF_EMPTY\" },\n\t{ 0xb1, \"TRIO_MAP_RDQ5_BUF_EMPTY\" },\n\t{ 0xb2, \"TRIO_MAP_RDQ6_BUF_EMPTY\" },\n\t{ 0xb3, \"TRIO_MAP_RDQ7_BUF_EMPTY\" },\n};\n\nstatic const struct mlxbf_pmc_events mlxbf_pmc_trio_events_2[] = {\n\t{ 0x0, \"DISABLE\" },\n\t{ 0xa0, \"TPIO_DATA_BEAT\" },\n\t{ 0xa1, \"TDMA_DATA_BEAT\" },\n\t{ 0xa2, \"MAP_DATA_BEAT\" },\n\t{ 0xa3, \"TXMSG_DATA_BEAT\" },\n\t{ 0xa4, \"TPIO_DATA_PACKET\" },\n\t{ 0xa5, \"TDMA_DATA_PACKET\" },\n\t{ 0xa6, \"MAP_DATA_PACKET\" },\n\t{ 0xa7, \"TXMSG_DATA_PACKET\" },\n\t{ 0xa8, \"TDMA_RT_AF\" },\n\t{ 0xa9, \"TDMA_PBUF_MAC_AF\" },\n\t{ 0xaa, \"TRIO_MAP_WRQ_BUF_EMPTY\" },\n\t{ 0xab, \"TRIO_MAP_CPL_BUF_EMPTY\" },\n\t{ 0xac, \"TRIO_MAP_RDQ0_BUF_EMPTY\" },\n\t{ 0xad, \"TRIO_MAP_RDQ1_BUF_EMPTY\" },\n\t{ 0xae, \"TRIO_MAP_RDQ2_BUF_EMPTY\" },\n\t{ 0xaf, \"TRIO_MAP_RDQ3_BUF_EMPTY\" },\n\t{ 0xb0, \"TRIO_MAP_RDQ4_BUF_EMPTY\" },\n\t{ 0xb1, \"TRIO_MAP_RDQ5_BUF_EMPTY\" },\n\t{ 0xb2, \"TRIO_MAP_RDQ6_BUF_EMPTY\" },\n\t{ 0xb3, \"TRIO_MAP_RDQ7_BUF_EMPTY\" },\n\t{ 0xb4, \"TRIO_RING_TX_FLIT_CH0\" },\n\t{ 0xb5, \"TRIO_RING_TX_FLIT_CH1\" },\n\t{ 0xb6, \"TRIO_RING_TX_FLIT_CH2\" },\n\t{ 0xb7, \"TRIO_RING_TX_FLIT_CH3\" },\n\t{ 0xb8, \"TRIO_RING_TX_FLIT_CH4\" },\n\t{ 0xb9, \"TRIO_RING_RX_FLIT_CH0\" },\n\t{ 0xba, \"TRIO_RING_RX_FLIT_CH1\" },\n\t{ 0xbb, \"TRIO_RING_RX_FLIT_CH2\" },\n\t{ 0xbc, \"TRIO_RING_RX_FLIT_CH3\" },\n};\n\nstatic const struct mlxbf_pmc_events mlxbf_pmc_ecc_events[] = {\n\t{ 0x0, \"DISABLE\" },\n\t{ 0x100, \"ECC_SINGLE_ERROR_CNT\" },\n\t{ 0x104, \"ECC_DOUBLE_ERROR_CNT\" },\n\t{ 0x114, \"SERR_INJ\" },\n\t{ 0x118, \"DERR_INJ\" },\n\t{ 0x124, \"ECC_SINGLE_ERROR_0\" },\n\t{ 0x164, \"ECC_DOUBLE_ERROR_0\" },\n\t{ 0x340, \"DRAM_ECC_COUNT\" },\n\t{ 0x344, \"DRAM_ECC_INJECT\" },\n\t{ 0x348, \"DRAM_ECC_ERROR\" },\n};\n\nstatic const struct mlxbf_pmc_events mlxbf_pmc_mss_events[] = {\n\t{ 0x0, \"DISABLE\" },\n\t{ 0xc0, \"RXREQ_MSS\" },\n\t{ 0xc1, \"RXDAT_MSS\" },\n\t{ 0xc2, \"TXRSP_MSS\" },\n\t{ 0xc3, \"TXDAT_MSS\" },\n};\n\nstatic const struct mlxbf_pmc_events mlxbf_pmc_hnf_events[] = {\n\t{ 0x0, \"DISABLE\" },\n\t{ 0x45, \"HNF_REQUESTS\" },\n\t{ 0x46, \"HNF_REJECTS\" },\n\t{ 0x47, \"ALL_BUSY\" },\n\t{ 0x48, \"MAF_BUSY\" },\n\t{ 0x49, \"MAF_REQUESTS\" },\n\t{ 0x4a, \"RNF_REQUESTS\" },\n\t{ 0x4b, \"REQUEST_TYPE\" },\n\t{ 0x4c, \"MEMORY_READS\" },\n\t{ 0x4d, \"MEMORY_WRITES\" },\n\t{ 0x4e, \"VICTIM_WRITE\" },\n\t{ 0x4f, \"POC_FULL\" },\n\t{ 0x50, \"POC_FAIL\" },\n\t{ 0x51, \"POC_SUCCESS\" },\n\t{ 0x52, \"POC_WRITES\" },\n\t{ 0x53, \"POC_READS\" },\n\t{ 0x54, \"FORWARD\" },\n\t{ 0x55, \"RXREQ_HNF\" },\n\t{ 0x56, \"RXRSP_HNF\" },\n\t{ 0x57, \"RXDAT_HNF\" },\n\t{ 0x58, \"TXREQ_HNF\" },\n\t{ 0x59, \"TXRSP_HNF\" },\n\t{ 0x5a, \"TXDAT_HNF\" },\n\t{ 0x5b, \"TXSNP_HNF\" },\n\t{ 0x5c, \"INDEX_MATCH\" },\n\t{ 0x5d, \"A72_ACCESS\" },\n\t{ 0x5e, \"IO_ACCESS\" },\n\t{ 0x5f, \"TSO_WRITE\" },\n\t{ 0x60, \"TSO_CONFLICT\" },\n\t{ 0x61, \"DIR_HIT\" },\n\t{ 0x62, \"HNF_ACCEPTS\" },\n\t{ 0x63, \"REQ_BUF_EMPTY\" },\n\t{ 0x64, \"REQ_BUF_IDLE_MAF\" },\n\t{ 0x65, \"TSO_NOARB\" },\n\t{ 0x66, \"TSO_NOARB_CYCLES\" },\n\t{ 0x67, \"MSS_NO_CREDIT\" },\n\t{ 0x68, \"TXDAT_NO_LCRD\" },\n\t{ 0x69, \"TXSNP_NO_LCRD\" },\n\t{ 0x6a, \"TXRSP_NO_LCRD\" },\n\t{ 0x6b, \"TXREQ_NO_LCRD\" },\n\t{ 0x6c, \"TSO_CL_MATCH\" },\n\t{ 0x6d, \"MEMORY_READS_BYPASS\" },\n\t{ 0x6e, \"TSO_NOARB_TIMEOUT\" },\n\t{ 0x6f, \"ALLOCATE\" },\n\t{ 0x70, \"VICTIM\" },\n\t{ 0x71, \"A72_WRITE\" },\n\t{ 0x72, \"A72_READ\" },\n\t{ 0x73, \"IO_WRITE\" },\n\t{ 0x74, \"IO_READ\" },\n\t{ 0x75, \"TSO_REJECT\" },\n\t{ 0x80, \"TXREQ_RN\" },\n\t{ 0x81, \"TXRSP_RN\" },\n\t{ 0x82, \"TXDAT_RN\" },\n\t{ 0x83, \"RXSNP_RN\" },\n\t{ 0x84, \"RXRSP_RN\" },\n\t{ 0x85, \"RXDAT_RN\" },\n};\n\nstatic const struct mlxbf_pmc_events mlxbf_pmc_hnfnet_events[] = {\n\t{ 0x0, \"DISABLE\" },\n\t{ 0x12, \"CDN_REQ\" },\n\t{ 0x13, \"DDN_REQ\" },\n\t{ 0x14, \"NDN_REQ\" },\n\t{ 0x15, \"CDN_DIAG_N_OUT_OF_CRED\" },\n\t{ 0x16, \"CDN_DIAG_S_OUT_OF_CRED\" },\n\t{ 0x17, \"CDN_DIAG_E_OUT_OF_CRED\" },\n\t{ 0x18, \"CDN_DIAG_W_OUT_OF_CRED\" },\n\t{ 0x19, \"CDN_DIAG_C_OUT_OF_CRED\" },\n\t{ 0x1a, \"CDN_DIAG_N_EGRESS\" },\n\t{ 0x1b, \"CDN_DIAG_S_EGRESS\" },\n\t{ 0x1c, \"CDN_DIAG_E_EGRESS\" },\n\t{ 0x1d, \"CDN_DIAG_W_EGRESS\" },\n\t{ 0x1e, \"CDN_DIAG_C_EGRESS\" },\n\t{ 0x1f, \"CDN_DIAG_N_INGRESS\" },\n\t{ 0x20, \"CDN_DIAG_S_INGRESS\" },\n\t{ 0x21, \"CDN_DIAG_E_INGRESS\" },\n\t{ 0x22, \"CDN_DIAG_W_INGRESS\" },\n\t{ 0x23, \"CDN_DIAG_C_INGRESS\" },\n\t{ 0x24, \"CDN_DIAG_CORE_SENT\" },\n\t{ 0x25, \"DDN_DIAG_N_OUT_OF_CRED\" },\n\t{ 0x26, \"DDN_DIAG_S_OUT_OF_CRED\" },\n\t{ 0x27, \"DDN_DIAG_E_OUT_OF_CRED\" },\n\t{ 0x28, \"DDN_DIAG_W_OUT_OF_CRED\" },\n\t{ 0x29, \"DDN_DIAG_C_OUT_OF_CRED\" },\n\t{ 0x2a, \"DDN_DIAG_N_EGRESS\" },\n\t{ 0x2b, \"DDN_DIAG_S_EGRESS\" },\n\t{ 0x2c, \"DDN_DIAG_E_EGRESS\" },\n\t{ 0x2d, \"DDN_DIAG_W_EGRESS\" },\n\t{ 0x2e, \"DDN_DIAG_C_EGRESS\" },\n\t{ 0x2f, \"DDN_DIAG_N_INGRESS\" },\n\t{ 0x30, \"DDN_DIAG_S_INGRESS\" },\n\t{ 0x31, \"DDN_DIAG_E_INGRESS\" },\n\t{ 0x32, \"DDN_DIAG_W_INGRESS\" },\n\t{ 0x33, \"DDN_DIAG_C_INGRESS\" },\n\t{ 0x34, \"DDN_DIAG_CORE_SENT\" },\n\t{ 0x35, \"NDN_DIAG_N_OUT_OF_CRED\" },\n\t{ 0x36, \"NDN_DIAG_S_OUT_OF_CRED\" },\n\t{ 0x37, \"NDN_DIAG_E_OUT_OF_CRED\" },\n\t{ 0x38, \"NDN_DIAG_W_OUT_OF_CRED\" },\n\t{ 0x39, \"NDN_DIAG_C_OUT_OF_CRED\" },\n\t{ 0x3a, \"NDN_DIAG_N_EGRESS\" },\n\t{ 0x3b, \"NDN_DIAG_S_EGRESS\" },\n\t{ 0x3c, \"NDN_DIAG_E_EGRESS\" },\n\t{ 0x3d, \"NDN_DIAG_W_EGRESS\" },\n\t{ 0x3e, \"NDN_DIAG_C_EGRESS\" },\n\t{ 0x3f, \"NDN_DIAG_N_INGRESS\" },\n\t{ 0x40, \"NDN_DIAG_S_INGRESS\" },\n\t{ 0x41, \"NDN_DIAG_E_INGRESS\" },\n\t{ 0x42, \"NDN_DIAG_W_INGRESS\" },\n\t{ 0x43, \"NDN_DIAG_C_INGRESS\" },\n\t{ 0x44, \"NDN_DIAG_CORE_SENT\" },\n};\n\nstatic const struct mlxbf_pmc_events mlxbf_pmc_l3c_events[] = {\n\t{ 0x00, \"DISABLE\" },\n\t{ 0x01, \"CYCLES\" },\n\t{ 0x02, \"TOTAL_RD_REQ_IN\" },\n\t{ 0x03, \"TOTAL_WR_REQ_IN\" },\n\t{ 0x04, \"TOTAL_WR_DBID_ACK\" },\n\t{ 0x05, \"TOTAL_WR_DATA_IN\" },\n\t{ 0x06, \"TOTAL_WR_COMP\" },\n\t{ 0x07, \"TOTAL_RD_DATA_OUT\" },\n\t{ 0x08, \"TOTAL_CDN_REQ_IN_BANK0\" },\n\t{ 0x09, \"TOTAL_CDN_REQ_IN_BANK1\" },\n\t{ 0x0a, \"TOTAL_DDN_REQ_IN_BANK0\" },\n\t{ 0x0b, \"TOTAL_DDN_REQ_IN_BANK1\" },\n\t{ 0x0c, \"TOTAL_EMEM_RD_RES_IN_BANK0\" },\n\t{ 0x0d, \"TOTAL_EMEM_RD_RES_IN_BANK1\" },\n\t{ 0x0e, \"TOTAL_CACHE_RD_RES_IN_BANK0\" },\n\t{ 0x0f, \"TOTAL_CACHE_RD_RES_IN_BANK1\" },\n\t{ 0x10, \"TOTAL_EMEM_RD_REQ_BANK0\" },\n\t{ 0x11, \"TOTAL_EMEM_RD_REQ_BANK1\" },\n\t{ 0x12, \"TOTAL_EMEM_WR_REQ_BANK0\" },\n\t{ 0x13, \"TOTAL_EMEM_WR_REQ_BANK1\" },\n\t{ 0x14, \"TOTAL_RD_REQ_OUT\" },\n\t{ 0x15, \"TOTAL_WR_REQ_OUT\" },\n\t{ 0x16, \"TOTAL_RD_RES_IN\" },\n\t{ 0x17, \"HITS_BANK0\" },\n\t{ 0x18, \"HITS_BANK1\" },\n\t{ 0x19, \"MISSES_BANK0\" },\n\t{ 0x1a, \"MISSES_BANK1\" },\n\t{ 0x1b, \"ALLOCATIONS_BANK0\" },\n\t{ 0x1c, \"ALLOCATIONS_BANK1\" },\n\t{ 0x1d, \"EVICTIONS_BANK0\" },\n\t{ 0x1e, \"EVICTIONS_BANK1\" },\n\t{ 0x1f, \"DBID_REJECT\" },\n\t{ 0x20, \"WRDB_REJECT_BANK0\" },\n\t{ 0x21, \"WRDB_REJECT_BANK1\" },\n\t{ 0x22, \"CMDQ_REJECT_BANK0\" },\n\t{ 0x23, \"CMDQ_REJECT_BANK1\" },\n\t{ 0x24, \"COB_REJECT_BANK0\" },\n\t{ 0x25, \"COB_REJECT_BANK1\" },\n\t{ 0x26, \"TRB_REJECT_BANK0\" },\n\t{ 0x27, \"TRB_REJECT_BANK1\" },\n\t{ 0x28, \"TAG_REJECT_BANK0\" },\n\t{ 0x29, \"TAG_REJECT_BANK1\" },\n\t{ 0x2a, \"ANY_REJECT_BANK0\" },\n\t{ 0x2b, \"ANY_REJECT_BANK1\" },\n};\n\nstatic struct mlxbf_pmc_context *pmc;\n\n \nstatic const char *mlxbf_pmc_svc_uuid_str = \"89c036b4-e7d7-11e6-8797-001aca00bfc4\";\n\n \nstatic int mlxbf_pmc_secure_read(void __iomem *addr, uint32_t command,\n\t\t\t\t uint64_t *result)\n{\n\tstruct arm_smccc_res res;\n\tint status, err = 0;\n\n\tarm_smccc_smc(command, pmc->sreg_tbl_perf, (uintptr_t)addr, 0, 0, 0, 0,\n\t\t      0, &res);\n\n\tstatus = res.a0;\n\n\tswitch (status) {\n\tcase PSCI_RET_NOT_SUPPORTED:\n\t\terr = -EINVAL;\n\t\tbreak;\n\tcase MLXBF_PMC_SMCCC_ACCESS_VIOLATION:\n\t\terr = -EACCES;\n\t\tbreak;\n\tdefault:\n\t\t*result = res.a1;\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\n \nstatic int mlxbf_pmc_read(void __iomem *addr, uint32_t command,\n\t\t\t  uint64_t *result)\n{\n\tif (pmc->svc_sreg_support)\n\t\treturn mlxbf_pmc_secure_read(addr, command, result);\n\n\tif (command == MLXBF_PMC_READ_REG_32)\n\t\t*result = readl(addr);\n\telse\n\t\t*result = readq(addr);\n\n\treturn 0;\n}\n\n \nstatic int mlxbf_pmc_readl(void __iomem *addr, uint32_t *result)\n{\n\tuint64_t read_out;\n\tint status;\n\n\tstatus = mlxbf_pmc_read(addr, MLXBF_PMC_READ_REG_32, &read_out);\n\tif (status)\n\t\treturn status;\n\t*result = (uint32_t)read_out;\n\n\treturn 0;\n}\n\n \nstatic int mlxbf_pmc_secure_write(void __iomem *addr, uint32_t command,\n\t\t\t\t  uint64_t value)\n{\n\tstruct arm_smccc_res res;\n\tint status, err = 0;\n\n\tarm_smccc_smc(command, pmc->sreg_tbl_perf, value, (uintptr_t)addr, 0, 0,\n\t\t      0, 0, &res);\n\n\tstatus = res.a0;\n\n\tswitch (status) {\n\tcase PSCI_RET_NOT_SUPPORTED:\n\t\terr = -EINVAL;\n\t\tbreak;\n\tcase MLXBF_PMC_SMCCC_ACCESS_VIOLATION:\n\t\terr = -EACCES;\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\n \nstatic int mlxbf_pmc_write(void __iomem *addr, int command, uint64_t value)\n{\n\tif (pmc->svc_sreg_support)\n\t\treturn mlxbf_pmc_secure_write(addr, command, value);\n\n\tif (command == MLXBF_PMC_WRITE_REG_32)\n\t\twritel(value, addr);\n\telse\n\t\twriteq(value, addr);\n\n\treturn 0;\n}\n\n \nstatic bool mlxbf_pmc_valid_range(int blk_num, uint32_t offset)\n{\n\tif ((offset >= 0) && !(offset % MLXBF_PMC_REG_SIZE) &&\n\t    (offset + MLXBF_PMC_REG_SIZE <= pmc->block[blk_num].blk_size))\n\t\treturn true;  \n\n\treturn false;\n}\n\n \nstatic const struct mlxbf_pmc_events *mlxbf_pmc_event_list(const char *blk,\n\t\t\t\t\t\t\t   int *size)\n{\n\tconst struct mlxbf_pmc_events *events;\n\n\tif (strstr(blk, \"tilenet\")) {\n\t\tevents = mlxbf_pmc_hnfnet_events;\n\t\t*size = ARRAY_SIZE(mlxbf_pmc_hnfnet_events);\n\t} else if (strstr(blk, \"tile\")) {\n\t\tevents = mlxbf_pmc_hnf_events;\n\t\t*size = ARRAY_SIZE(mlxbf_pmc_hnf_events);\n\t} else if (strstr(blk, \"triogen\")) {\n\t\tevents = mlxbf_pmc_smgen_events;\n\t\t*size = ARRAY_SIZE(mlxbf_pmc_smgen_events);\n\t} else if (strstr(blk, \"trio\")) {\n\t\tswitch (pmc->event_set) {\n\t\tcase MLXBF_PMC_EVENT_SET_BF1:\n\t\t\tevents = mlxbf_pmc_trio_events_1;\n\t\t\t*size = ARRAY_SIZE(mlxbf_pmc_trio_events_1);\n\t\t\tbreak;\n\t\tcase MLXBF_PMC_EVENT_SET_BF2:\n\t\t\tevents = mlxbf_pmc_trio_events_2;\n\t\t\t*size = ARRAY_SIZE(mlxbf_pmc_trio_events_2);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tevents = NULL;\n\t\t\t*size = 0;\n\t\t\tbreak;\n\t\t}\n\t} else if (strstr(blk, \"mss\")) {\n\t\tevents = mlxbf_pmc_mss_events;\n\t\t*size = ARRAY_SIZE(mlxbf_pmc_mss_events);\n\t} else if (strstr(blk, \"ecc\")) {\n\t\tevents = mlxbf_pmc_ecc_events;\n\t\t*size = ARRAY_SIZE(mlxbf_pmc_ecc_events);\n\t} else if (strstr(blk, \"pcie\")) {\n\t\tevents = mlxbf_pmc_pcie_events;\n\t\t*size = ARRAY_SIZE(mlxbf_pmc_pcie_events);\n\t} else if (strstr(blk, \"l3cache\")) {\n\t\tevents = mlxbf_pmc_l3c_events;\n\t\t*size = ARRAY_SIZE(mlxbf_pmc_l3c_events);\n\t} else if (strstr(blk, \"gic\")) {\n\t\tevents = mlxbf_pmc_smgen_events;\n\t\t*size = ARRAY_SIZE(mlxbf_pmc_smgen_events);\n\t} else if (strstr(blk, \"smmu\")) {\n\t\tevents = mlxbf_pmc_smgen_events;\n\t\t*size = ARRAY_SIZE(mlxbf_pmc_smgen_events);\n\t} else {\n\t\tevents = NULL;\n\t\t*size = 0;\n\t}\n\n\treturn events;\n}\n\n \nstatic int mlxbf_pmc_get_event_num(const char *blk, const char *evt)\n{\n\tconst struct mlxbf_pmc_events *events;\n\tint i, size;\n\n\tevents = mlxbf_pmc_event_list(blk, &size);\n\tif (!events)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < size; ++i) {\n\t\tif (!strcmp(evt, events[i].evt_name))\n\t\t\treturn events[i].evt_num;\n\t}\n\n\treturn -ENODEV;\n}\n\n \nstatic char *mlxbf_pmc_get_event_name(const char *blk, int evt)\n{\n\tconst struct mlxbf_pmc_events *events;\n\tint i, size;\n\n\tevents = mlxbf_pmc_event_list(blk, &size);\n\tif (!events)\n\t\treturn NULL;\n\n\tfor (i = 0; i < size; ++i) {\n\t\tif (evt == events[i].evt_num)\n\t\t\treturn events[i].evt_name;\n\t}\n\n\treturn NULL;\n}\n\n \nstatic int mlxbf_pmc_config_l3_counters(int blk_num, bool enable, bool reset)\n{\n\tuint32_t perfcnt_cfg = 0;\n\n\tif (enable)\n\t\tperfcnt_cfg |= MLXBF_PMC_L3C_PERF_CNT_CFG_EN;\n\tif (reset)\n\t\tperfcnt_cfg |= MLXBF_PMC_L3C_PERF_CNT_CFG_RST;\n\n\treturn mlxbf_pmc_write(pmc->block[blk_num].mmio_base +\n\t\t\t\t       MLXBF_PMC_L3C_PERF_CNT_CFG,\n\t\t\t       MLXBF_PMC_WRITE_REG_32, perfcnt_cfg);\n}\n\n \nstatic int mlxbf_pmc_program_l3_counter(int blk_num, uint32_t cnt_num,\n\t\t\t\t\tuint32_t evt)\n{\n\tuint32_t perfcnt_sel_1 = 0;\n\tuint32_t perfcnt_sel = 0;\n\tuint32_t *wordaddr;\n\tvoid __iomem *pmcaddr;\n\tint ret;\n\n\t \n\tif (mlxbf_pmc_config_l3_counters(blk_num, false, false))\n\t\treturn -EINVAL;\n\n\t \n\tswitch (cnt_num) {\n\tcase 0 ... 3:\n\t\tpmcaddr = pmc->block[blk_num].mmio_base +\n\t\t\t  MLXBF_PMC_L3C_PERF_CNT_SEL;\n\t\twordaddr = &perfcnt_sel;\n\t\tbreak;\n\tcase 4:\n\t\tpmcaddr = pmc->block[blk_num].mmio_base +\n\t\t\t  MLXBF_PMC_L3C_PERF_CNT_SEL_1;\n\t\twordaddr = &perfcnt_sel_1;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tret = mlxbf_pmc_readl(pmcaddr, wordaddr);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (cnt_num) {\n\tcase 0:\n\t\tperfcnt_sel &= ~MLXBF_PMC_L3C_PERF_CNT_SEL_CNT_0;\n\t\tperfcnt_sel |= FIELD_PREP(MLXBF_PMC_L3C_PERF_CNT_SEL_CNT_0,\n\t\t\t\t\t  evt);\n\t\tbreak;\n\tcase 1:\n\t\tperfcnt_sel &= ~MLXBF_PMC_L3C_PERF_CNT_SEL_CNT_1;\n\t\tperfcnt_sel |= FIELD_PREP(MLXBF_PMC_L3C_PERF_CNT_SEL_CNT_1,\n\t\t\t\t\t  evt);\n\t\tbreak;\n\tcase 2:\n\t\tperfcnt_sel &= ~MLXBF_PMC_L3C_PERF_CNT_SEL_CNT_2;\n\t\tperfcnt_sel |= FIELD_PREP(MLXBF_PMC_L3C_PERF_CNT_SEL_CNT_2,\n\t\t\t\t\t  evt);\n\t\tbreak;\n\tcase 3:\n\t\tperfcnt_sel &= ~MLXBF_PMC_L3C_PERF_CNT_SEL_CNT_3;\n\t\tperfcnt_sel |= FIELD_PREP(MLXBF_PMC_L3C_PERF_CNT_SEL_CNT_3,\n\t\t\t\t\t  evt);\n\t\tbreak;\n\tcase 4:\n\t\tperfcnt_sel_1 &= ~MLXBF_PMC_L3C_PERF_CNT_SEL_1_CNT_4;\n\t\tperfcnt_sel_1 |= FIELD_PREP(MLXBF_PMC_L3C_PERF_CNT_SEL_1_CNT_4,\n\t\t\t\t\t    evt);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn mlxbf_pmc_write(pmcaddr, MLXBF_PMC_WRITE_REG_32, *wordaddr);\n}\n\n \nstatic int mlxbf_pmc_program_counter(int blk_num, uint32_t cnt_num,\n\t\t\t\t     uint32_t evt, bool is_l3)\n{\n\tuint64_t perfctl, perfevt, perfmon_cfg;\n\n\tif (cnt_num >= pmc->block[blk_num].counters)\n\t\treturn -ENODEV;\n\n\tif (is_l3)\n\t\treturn mlxbf_pmc_program_l3_counter(blk_num, cnt_num, evt);\n\n\t \n\tperfctl = FIELD_PREP(MLXBF_PMC_PERFCTL_EN0, 1);\n\tperfctl |= FIELD_PREP(MLXBF_PMC_PERFCTL_EB0, 0);\n\tperfctl |= FIELD_PREP(MLXBF_PMC_PERFCTL_ETRIG0, 1);\n\tperfctl |= FIELD_PREP(MLXBF_PMC_PERFCTL_AD0, 0);\n\tperfctl |= FIELD_PREP(MLXBF_PMC_PERFCTL_ACCM0, 0);\n\tperfctl |= FIELD_PREP(MLXBF_PMC_PERFCTL_MS0, 0);\n\tperfctl |= FIELD_PREP(MLXBF_PMC_PERFCTL_FM0, 0);\n\n\tperfmon_cfg = FIELD_PREP(MLXBF_PMC_PERFMON_CONFIG_WDATA, perfctl);\n\tperfmon_cfg |= FIELD_PREP(MLXBF_PMC_PERFMON_CONFIG_ADDR,\n\t\t\t\t  MLXBF_PMC_PERFCTL);\n\tperfmon_cfg |= FIELD_PREP(MLXBF_PMC_PERFMON_CONFIG_STROBE, 1);\n\tperfmon_cfg |= FIELD_PREP(MLXBF_PMC_PERFMON_CONFIG_WR_R_B, 1);\n\n\tif (mlxbf_pmc_write(pmc->block[blk_num].mmio_base +\n\t\t\t\t    cnt_num * MLXBF_PMC_REG_SIZE,\n\t\t\t    MLXBF_PMC_WRITE_REG_64, perfmon_cfg))\n\t\treturn -EFAULT;\n\n\t \n\tperfevt = FIELD_PREP(MLXBF_PMC_PERFEVT_EVTSEL, evt);\n\n\tperfmon_cfg = FIELD_PREP(MLXBF_PMC_PERFMON_CONFIG_WDATA, perfevt);\n\tperfmon_cfg |= FIELD_PREP(MLXBF_PMC_PERFMON_CONFIG_ADDR,\n\t\t\t\t  MLXBF_PMC_PERFEVT);\n\tperfmon_cfg |= FIELD_PREP(MLXBF_PMC_PERFMON_CONFIG_STROBE, 1);\n\tperfmon_cfg |= FIELD_PREP(MLXBF_PMC_PERFMON_CONFIG_WR_R_B, 1);\n\n\tif (mlxbf_pmc_write(pmc->block[blk_num].mmio_base +\n\t\t\t\t    cnt_num * MLXBF_PMC_REG_SIZE,\n\t\t\t    MLXBF_PMC_WRITE_REG_64, perfmon_cfg))\n\t\treturn -EFAULT;\n\n\t \n\tperfmon_cfg = FIELD_PREP(MLXBF_PMC_PERFMON_CONFIG_ADDR,\n\t\t\t\t MLXBF_PMC_PERFACC0);\n\tperfmon_cfg |= FIELD_PREP(MLXBF_PMC_PERFMON_CONFIG_STROBE, 1);\n\tperfmon_cfg |= FIELD_PREP(MLXBF_PMC_PERFMON_CONFIG_WR_R_B, 1);\n\n\tif (mlxbf_pmc_write(pmc->block[blk_num].mmio_base +\n\t\t\t\t    cnt_num * MLXBF_PMC_REG_SIZE,\n\t\t\t    MLXBF_PMC_WRITE_REG_64, perfmon_cfg))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\n \nstatic int mlxbf_pmc_read_l3_counter(int blk_num, uint32_t cnt_num,\n\t\t\t\t     uint64_t *result)\n{\n\tuint32_t perfcnt_low = 0, perfcnt_high = 0;\n\tuint64_t value;\n\tint status = 0;\n\n\tstatus = mlxbf_pmc_readl(pmc->block[blk_num].mmio_base +\n\t\t\t\t\t MLXBF_PMC_L3C_PERF_CNT_LOW +\n\t\t\t\t\t cnt_num * MLXBF_PMC_L3C_REG_SIZE,\n\t\t\t\t &perfcnt_low);\n\n\tif (status)\n\t\treturn status;\n\n\tstatus = mlxbf_pmc_readl(pmc->block[blk_num].mmio_base +\n\t\t\t\t\t MLXBF_PMC_L3C_PERF_CNT_HIGH +\n\t\t\t\t\t cnt_num * MLXBF_PMC_L3C_REG_SIZE,\n\t\t\t\t &perfcnt_high);\n\n\tif (status)\n\t\treturn status;\n\n\tvalue = perfcnt_high;\n\tvalue = value << 32;\n\tvalue |= perfcnt_low;\n\t*result = value;\n\n\treturn 0;\n}\n\n \nstatic int mlxbf_pmc_read_counter(int blk_num, uint32_t cnt_num, bool is_l3,\n\t\t\t\t  uint64_t *result)\n{\n\tuint32_t perfcfg_offset, perfval_offset;\n\tuint64_t perfmon_cfg;\n\tint status;\n\n\tif (cnt_num >= pmc->block[blk_num].counters)\n\t\treturn -EINVAL;\n\n\tif (is_l3)\n\t\treturn mlxbf_pmc_read_l3_counter(blk_num, cnt_num, result);\n\n\tperfcfg_offset = cnt_num * MLXBF_PMC_REG_SIZE;\n\tperfval_offset = perfcfg_offset +\n\t\t\t pmc->block[blk_num].counters * MLXBF_PMC_REG_SIZE;\n\n\t \n\tperfmon_cfg = FIELD_PREP(MLXBF_PMC_PERFMON_CONFIG_ADDR,\n\t\t\t\t MLXBF_PMC_PERFACC0);\n\tperfmon_cfg |= FIELD_PREP(MLXBF_PMC_PERFMON_CONFIG_STROBE, 1);\n\tperfmon_cfg |= FIELD_PREP(MLXBF_PMC_PERFMON_CONFIG_WR_R_B, 0);\n\n\tstatus = mlxbf_pmc_write(pmc->block[blk_num].mmio_base + perfcfg_offset,\n\t\t\t\t MLXBF_PMC_WRITE_REG_64, perfmon_cfg);\n\n\tif (status)\n\t\treturn status;\n\n\t \n\treturn mlxbf_pmc_read(pmc->block[blk_num].mmio_base + perfval_offset,\n\t\t\t      MLXBF_PMC_READ_REG_64, result);\n}\n\n \nstatic int mlxbf_pmc_read_l3_event(int blk_num, uint32_t cnt_num,\n\t\t\t\t   uint64_t *result)\n{\n\tuint32_t perfcnt_sel = 0, perfcnt_sel_1 = 0;\n\tuint32_t *wordaddr;\n\tvoid __iomem *pmcaddr;\n\tuint64_t evt;\n\n\t \n\tswitch (cnt_num) {\n\tcase 0 ... 3:\n\t\tpmcaddr = pmc->block[blk_num].mmio_base +\n\t\t\t  MLXBF_PMC_L3C_PERF_CNT_SEL;\n\t\twordaddr = &perfcnt_sel;\n\t\tbreak;\n\tcase 4:\n\t\tpmcaddr = pmc->block[blk_num].mmio_base +\n\t\t\t  MLXBF_PMC_L3C_PERF_CNT_SEL_1;\n\t\twordaddr = &perfcnt_sel_1;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (mlxbf_pmc_readl(pmcaddr, wordaddr))\n\t\treturn -EINVAL;\n\n\t \n\tswitch (cnt_num) {\n\tcase 0:\n\t\tevt = FIELD_GET(MLXBF_PMC_L3C_PERF_CNT_SEL_CNT_0, perfcnt_sel);\n\t\tbreak;\n\tcase 1:\n\t\tevt = FIELD_GET(MLXBF_PMC_L3C_PERF_CNT_SEL_CNT_1, perfcnt_sel);\n\t\tbreak;\n\tcase 2:\n\t\tevt = FIELD_GET(MLXBF_PMC_L3C_PERF_CNT_SEL_CNT_2, perfcnt_sel);\n\t\tbreak;\n\tcase 3:\n\t\tevt = FIELD_GET(MLXBF_PMC_L3C_PERF_CNT_SEL_CNT_3, perfcnt_sel);\n\t\tbreak;\n\tcase 4:\n\t\tevt = FIELD_GET(MLXBF_PMC_L3C_PERF_CNT_SEL_1_CNT_4,\n\t\t\t\tperfcnt_sel_1);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\t*result = evt;\n\n\treturn 0;\n}\n\n \nstatic int mlxbf_pmc_read_event(int blk_num, uint32_t cnt_num, bool is_l3,\n\t\t\t\tuint64_t *result)\n{\n\tuint32_t perfcfg_offset, perfval_offset;\n\tuint64_t perfmon_cfg, perfevt;\n\n\tif (cnt_num >= pmc->block[blk_num].counters)\n\t\treturn -EINVAL;\n\n\tif (is_l3)\n\t\treturn mlxbf_pmc_read_l3_event(blk_num, cnt_num, result);\n\n\tperfcfg_offset = cnt_num * MLXBF_PMC_REG_SIZE;\n\tperfval_offset = perfcfg_offset +\n\t\t\t pmc->block[blk_num].counters * MLXBF_PMC_REG_SIZE;\n\n\t \n\tperfmon_cfg = FIELD_PREP(MLXBF_PMC_PERFMON_CONFIG_ADDR,\n\t\t\t\t MLXBF_PMC_PERFEVT);\n\tperfmon_cfg |= FIELD_PREP(MLXBF_PMC_PERFMON_CONFIG_STROBE, 1);\n\tperfmon_cfg |= FIELD_PREP(MLXBF_PMC_PERFMON_CONFIG_WR_R_B, 0);\n\n\tif (mlxbf_pmc_write(pmc->block[blk_num].mmio_base + perfcfg_offset,\n\t\t\t    MLXBF_PMC_WRITE_REG_64, perfmon_cfg))\n\t\treturn -EFAULT;\n\n\t \n\tif (mlxbf_pmc_read(pmc->block[blk_num].mmio_base + perfval_offset,\n\t\t\t   MLXBF_PMC_READ_REG_64, &perfevt))\n\t\treturn -EFAULT;\n\n\t*result = FIELD_GET(MLXBF_PMC_PERFEVT_EVTSEL, perfevt);\n\n\treturn 0;\n}\n\n \nstatic int mlxbf_pmc_read_reg(int blk_num, uint32_t offset, uint64_t *result)\n{\n\tuint32_t ecc_out;\n\n\tif (strstr(pmc->block_name[blk_num], \"ecc\")) {\n\t\tif (mlxbf_pmc_readl(pmc->block[blk_num].mmio_base + offset,\n\t\t\t\t    &ecc_out))\n\t\t\treturn -EFAULT;\n\n\t\t*result = ecc_out;\n\t\treturn 0;\n\t}\n\n\tif (mlxbf_pmc_valid_range(blk_num, offset))\n\t\treturn mlxbf_pmc_read(pmc->block[blk_num].mmio_base + offset,\n\t\t\t\t      MLXBF_PMC_READ_REG_64, result);\n\n\treturn -EINVAL;\n}\n\n \nstatic int mlxbf_pmc_write_reg(int blk_num, uint32_t offset, uint64_t data)\n{\n\tif (strstr(pmc->block_name[blk_num], \"ecc\")) {\n\t\treturn mlxbf_pmc_write(pmc->block[blk_num].mmio_base + offset,\n\t\t\t\t       MLXBF_PMC_WRITE_REG_32, data);\n\t}\n\n\tif (mlxbf_pmc_valid_range(blk_num, offset))\n\t\treturn mlxbf_pmc_write(pmc->block[blk_num].mmio_base + offset,\n\t\t\t\t       MLXBF_PMC_WRITE_REG_64, data);\n\n\treturn -EINVAL;\n}\n\n \nstatic ssize_t mlxbf_pmc_counter_show(struct device *dev,\n\t\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tstruct mlxbf_pmc_attribute *attr_counter = container_of(\n\t\tattr, struct mlxbf_pmc_attribute, dev_attr);\n\tint blk_num, cnt_num, offset;\n\tbool is_l3 = false;\n\tuint64_t value;\n\n\tblk_num = attr_counter->nr;\n\tcnt_num = attr_counter->index;\n\n\tif (strstr(pmc->block_name[blk_num], \"l3cache\"))\n\t\tis_l3 = true;\n\n\tif (pmc->block[blk_num].type == MLXBF_PMC_TYPE_COUNTER) {\n\t\tif (mlxbf_pmc_read_counter(blk_num, cnt_num, is_l3, &value))\n\t\t\treturn -EINVAL;\n\t} else if (pmc->block[blk_num].type == MLXBF_PMC_TYPE_REGISTER) {\n\t\toffset = mlxbf_pmc_get_event_num(pmc->block_name[blk_num],\n\t\t\t\t\t\t attr->attr.name);\n\t\tif (offset < 0)\n\t\t\treturn -EINVAL;\n\t\tif (mlxbf_pmc_read_reg(blk_num, offset, &value))\n\t\t\treturn -EINVAL;\n\t} else\n\t\treturn -EINVAL;\n\n\treturn sysfs_emit(buf, \"0x%llx\\n\", value);\n}\n\n \nstatic ssize_t mlxbf_pmc_counter_store(struct device *dev,\n\t\t\t\t       struct device_attribute *attr,\n\t\t\t\t       const char *buf, size_t count)\n{\n\tstruct mlxbf_pmc_attribute *attr_counter = container_of(\n\t\tattr, struct mlxbf_pmc_attribute, dev_attr);\n\tint blk_num, cnt_num, offset, err, data;\n\tbool is_l3 = false;\n\tuint64_t evt_num;\n\n\tblk_num = attr_counter->nr;\n\tcnt_num = attr_counter->index;\n\n\terr = kstrtoint(buf, 0, &data);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tif (!(strstr(pmc->block_name[blk_num], \"ecc\")) && data)\n\t\treturn -EINVAL;\n\n\t \n\tif (strstr(pmc->block_name[blk_num], \"l3cache\"))\n\t\treturn -EINVAL;\n\n\tif (pmc->block[blk_num].type == MLXBF_PMC_TYPE_COUNTER) {\n\t\terr = mlxbf_pmc_read_event(blk_num, cnt_num, is_l3, &evt_num);\n\t\tif (err)\n\t\t\treturn err;\n\t\terr = mlxbf_pmc_program_counter(blk_num, cnt_num, evt_num,\n\t\t\t\t\t\tis_l3);\n\t\tif (err)\n\t\t\treturn err;\n\t} else if (pmc->block[blk_num].type == MLXBF_PMC_TYPE_REGISTER) {\n\t\toffset = mlxbf_pmc_get_event_num(pmc->block_name[blk_num],\n\t\t\t\t\t\t attr->attr.name);\n\t\tif (offset < 0)\n\t\t\treturn -EINVAL;\n\t\terr = mlxbf_pmc_write_reg(blk_num, offset, data);\n\t\tif (err)\n\t\t\treturn err;\n\t} else\n\t\treturn -EINVAL;\n\n\treturn count;\n}\n\n \nstatic ssize_t mlxbf_pmc_event_show(struct device *dev,\n\t\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct mlxbf_pmc_attribute *attr_event = container_of(\n\t\tattr, struct mlxbf_pmc_attribute, dev_attr);\n\tint blk_num, cnt_num, err;\n\tbool is_l3 = false;\n\tuint64_t evt_num;\n\tchar *evt_name;\n\n\tblk_num = attr_event->nr;\n\tcnt_num = attr_event->index;\n\n\tif (strstr(pmc->block_name[blk_num], \"l3cache\"))\n\t\tis_l3 = true;\n\n\terr = mlxbf_pmc_read_event(blk_num, cnt_num, is_l3, &evt_num);\n\tif (err)\n\t\treturn sysfs_emit(buf, \"No event being monitored\\n\");\n\n\tevt_name = mlxbf_pmc_get_event_name(pmc->block_name[blk_num], evt_num);\n\tif (!evt_name)\n\t\treturn -EINVAL;\n\n\treturn sysfs_emit(buf, \"0x%llx: %s\\n\", evt_num, evt_name);\n}\n\n \nstatic ssize_t mlxbf_pmc_event_store(struct device *dev,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     const char *buf, size_t count)\n{\n\tstruct mlxbf_pmc_attribute *attr_event = container_of(\n\t\tattr, struct mlxbf_pmc_attribute, dev_attr);\n\tint blk_num, cnt_num, evt_num, err;\n\tbool is_l3 = false;\n\n\tblk_num = attr_event->nr;\n\tcnt_num = attr_event->index;\n\n\tif (isalpha(buf[0])) {\n\t\tevt_num = mlxbf_pmc_get_event_num(pmc->block_name[blk_num],\n\t\t\t\t\t\t  buf);\n\t\tif (evt_num < 0)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\terr = kstrtoint(buf, 0, &evt_num);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tif (strstr(pmc->block_name[blk_num], \"l3cache\"))\n\t\tis_l3 = true;\n\n\terr = mlxbf_pmc_program_counter(blk_num, cnt_num, evt_num, is_l3);\n\tif (err)\n\t\treturn err;\n\n\treturn count;\n}\n\n \nstatic ssize_t mlxbf_pmc_event_list_show(struct device *dev,\n\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t char *buf)\n{\n\tstruct mlxbf_pmc_attribute *attr_event_list = container_of(\n\t\tattr, struct mlxbf_pmc_attribute, dev_attr);\n\tint blk_num, i, size, len = 0, ret = 0;\n\tconst struct mlxbf_pmc_events *events;\n\tchar e_info[MLXBF_PMC_EVENT_INFO_LEN];\n\n\tblk_num = attr_event_list->nr;\n\n\tevents = mlxbf_pmc_event_list(pmc->block_name[blk_num], &size);\n\tif (!events)\n\t\treturn -EINVAL;\n\n\tfor (i = 0, buf[0] = '\\0'; i < size; ++i) {\n\t\tlen += snprintf(e_info, sizeof(e_info), \"0x%x: %s\\n\",\n\t\t\t\tevents[i].evt_num, events[i].evt_name);\n\t\tif (len >= PAGE_SIZE)\n\t\t\tbreak;\n\t\tstrcat(buf, e_info);\n\t\tret = len;\n\t}\n\n\treturn ret;\n}\n\n \nstatic ssize_t mlxbf_pmc_enable_show(struct device *dev,\n\t\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct mlxbf_pmc_attribute *attr_enable = container_of(\n\t\tattr, struct mlxbf_pmc_attribute, dev_attr);\n\tuint32_t perfcnt_cfg;\n\tint blk_num, value;\n\n\tblk_num = attr_enable->nr;\n\n\tif (mlxbf_pmc_readl(pmc->block[blk_num].mmio_base +\n\t\t\t\t    MLXBF_PMC_L3C_PERF_CNT_CFG,\n\t\t\t    &perfcnt_cfg))\n\t\treturn -EINVAL;\n\n\tvalue = FIELD_GET(MLXBF_PMC_L3C_PERF_CNT_CFG_EN, perfcnt_cfg);\n\n\treturn sysfs_emit(buf, \"%d\\n\", value);\n}\n\n \nstatic ssize_t mlxbf_pmc_enable_store(struct device *dev,\n\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t      const char *buf, size_t count)\n{\n\tstruct mlxbf_pmc_attribute *attr_enable = container_of(\n\t\tattr, struct mlxbf_pmc_attribute, dev_attr);\n\tint err, en, blk_num;\n\n\tblk_num = attr_enable->nr;\n\n\terr = kstrtoint(buf, 0, &en);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (!en) {\n\t\terr = mlxbf_pmc_config_l3_counters(blk_num, false, false);\n\t\tif (err)\n\t\t\treturn err;\n\t} else if (en == 1) {\n\t\terr = mlxbf_pmc_config_l3_counters(blk_num, false, true);\n\t\tif (err)\n\t\t\treturn err;\n\t\terr = mlxbf_pmc_config_l3_counters(blk_num, true, false);\n\t\tif (err)\n\t\t\treturn err;\n\t} else\n\t\treturn -EINVAL;\n\n\treturn count;\n}\n\n \nstatic int mlxbf_pmc_init_perftype_counter(struct device *dev, int blk_num)\n{\n\tstruct mlxbf_pmc_attribute *attr;\n\tint i = 0, j = 0;\n\n\t \n\tattr = &pmc->block[blk_num].attr_event_list;\n\tattr->dev_attr.attr.mode = 0444;\n\tattr->dev_attr.show = mlxbf_pmc_event_list_show;\n\tattr->nr = blk_num;\n\tattr->dev_attr.attr.name = devm_kasprintf(dev, GFP_KERNEL, \"event_list\");\n\tif (!attr->dev_attr.attr.name)\n\t\treturn -ENOMEM;\n\tpmc->block[blk_num].block_attr[i] = &attr->dev_attr.attr;\n\tattr = NULL;\n\n\t \n\tif (strstr(pmc->block_name[blk_num], \"l3cache\")) {\n\t\tattr = &pmc->block[blk_num].attr_enable;\n\t\tattr->dev_attr.attr.mode = 0644;\n\t\tattr->dev_attr.show = mlxbf_pmc_enable_show;\n\t\tattr->dev_attr.store = mlxbf_pmc_enable_store;\n\t\tattr->nr = blk_num;\n\t\tattr->dev_attr.attr.name = devm_kasprintf(dev, GFP_KERNEL,\n\t\t\t\t\t\t\t  \"enable\");\n\t\tif (!attr->dev_attr.attr.name)\n\t\t\treturn -ENOMEM;\n\t\tpmc->block[blk_num].block_attr[++i] = &attr->dev_attr.attr;\n\t\tattr = NULL;\n\t}\n\n\tpmc->block[blk_num].attr_counter = devm_kcalloc(\n\t\tdev, pmc->block[blk_num].counters,\n\t\tsizeof(struct mlxbf_pmc_attribute), GFP_KERNEL);\n\tif (!pmc->block[blk_num].attr_counter)\n\t\treturn -ENOMEM;\n\n\tpmc->block[blk_num].attr_event = devm_kcalloc(\n\t\tdev, pmc->block[blk_num].counters,\n\t\tsizeof(struct mlxbf_pmc_attribute), GFP_KERNEL);\n\tif (!pmc->block[blk_num].attr_event)\n\t\treturn -ENOMEM;\n\n\t \n\tfor (j = 0; j < pmc->block[blk_num].counters; ++j) {\n\t\tattr = &pmc->block[blk_num].attr_counter[j];\n\t\tattr->dev_attr.attr.mode = 0644;\n\t\tattr->dev_attr.show = mlxbf_pmc_counter_show;\n\t\tattr->dev_attr.store = mlxbf_pmc_counter_store;\n\t\tattr->index = j;\n\t\tattr->nr = blk_num;\n\t\tattr->dev_attr.attr.name = devm_kasprintf(dev, GFP_KERNEL,\n\t\t\t\t\t\t\t  \"counter%d\", j);\n\t\tif (!attr->dev_attr.attr.name)\n\t\t\treturn -ENOMEM;\n\t\tpmc->block[blk_num].block_attr[++i] = &attr->dev_attr.attr;\n\t\tattr = NULL;\n\n\t\tattr = &pmc->block[blk_num].attr_event[j];\n\t\tattr->dev_attr.attr.mode = 0644;\n\t\tattr->dev_attr.show = mlxbf_pmc_event_show;\n\t\tattr->dev_attr.store = mlxbf_pmc_event_store;\n\t\tattr->index = j;\n\t\tattr->nr = blk_num;\n\t\tattr->dev_attr.attr.name = devm_kasprintf(dev, GFP_KERNEL,\n\t\t\t\t\t\t\t  \"event%d\", j);\n\t\tif (!attr->dev_attr.attr.name)\n\t\t\treturn -ENOMEM;\n\t\tpmc->block[blk_num].block_attr[++i] = &attr->dev_attr.attr;\n\t\tattr = NULL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int mlxbf_pmc_init_perftype_reg(struct device *dev, int blk_num)\n{\n\tstruct mlxbf_pmc_attribute *attr;\n\tconst struct mlxbf_pmc_events *events;\n\tint i = 0, j = 0;\n\n\tevents = mlxbf_pmc_event_list(pmc->block_name[blk_num], &j);\n\tif (!events)\n\t\treturn -EINVAL;\n\n\tpmc->block[blk_num].attr_event = devm_kcalloc(\n\t\tdev, j, sizeof(struct mlxbf_pmc_attribute), GFP_KERNEL);\n\tif (!pmc->block[blk_num].attr_event)\n\t\treturn -ENOMEM;\n\n\twhile (j > 0) {\n\t\t--j;\n\t\tattr = &pmc->block[blk_num].attr_event[j];\n\t\tattr->dev_attr.attr.mode = 0644;\n\t\tattr->dev_attr.show = mlxbf_pmc_counter_show;\n\t\tattr->dev_attr.store = mlxbf_pmc_counter_store;\n\t\tattr->nr = blk_num;\n\t\tattr->dev_attr.attr.name = devm_kasprintf(dev, GFP_KERNEL,\n\t\t\t\t\t\t\t  events[j].evt_name);\n\t\tif (!attr->dev_attr.attr.name)\n\t\t\treturn -ENOMEM;\n\t\tpmc->block[blk_num].block_attr[i] = &attr->dev_attr.attr;\n\t\tattr = NULL;\n\t\ti++;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int mlxbf_pmc_create_groups(struct device *dev, int blk_num)\n{\n\tint err;\n\n\t \n\tif (pmc->block[blk_num].type == MLXBF_PMC_TYPE_COUNTER)\n\t\terr = mlxbf_pmc_init_perftype_counter(dev, blk_num);\n\telse if (pmc->block[blk_num].type == MLXBF_PMC_TYPE_REGISTER)\n\t\terr = mlxbf_pmc_init_perftype_reg(dev, blk_num);\n\telse\n\t\terr = -EINVAL;\n\n\tif (err)\n\t\treturn err;\n\n\t \n\tpmc->block[blk_num].block_attr_grp.attrs = pmc->block[blk_num].block_attr;\n\tpmc->block[blk_num].block_attr_grp.name = devm_kasprintf(\n\t\tdev, GFP_KERNEL, pmc->block_name[blk_num]);\n\tif (!pmc->block[blk_num].block_attr_grp.name)\n\t\treturn -ENOMEM;\n\tpmc->groups[blk_num] = &pmc->block[blk_num].block_attr_grp;\n\n\treturn 0;\n}\n\nstatic bool mlxbf_pmc_guid_match(const guid_t *guid,\n\t\t\t\t const struct arm_smccc_res *res)\n{\n\tguid_t id = GUID_INIT(res->a0, res->a1, res->a1 >> 16, res->a2,\n\t\t\t      res->a2 >> 8, res->a2 >> 16, res->a2 >> 24,\n\t\t\t      res->a3, res->a3 >> 8, res->a3 >> 16,\n\t\t\t      res->a3 >> 24);\n\n\treturn guid_equal(guid, &id);\n}\n\n \nstatic int mlxbf_pmc_map_counters(struct device *dev)\n{\n\tuint64_t info[MLXBF_PMC_INFO_SZ];\n\tint i, tile_num, ret;\n\n\tfor (i = 0; i < pmc->total_blocks; ++i) {\n\t\tif (strstr(pmc->block_name[i], \"tile\")) {\n\t\t\tif (sscanf(pmc->block_name[i], \"tile%d\", &tile_num) != 1)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tif (tile_num >= pmc->tile_count)\n\t\t\t\tcontinue;\n\t\t}\n\t\tret = device_property_read_u64_array(dev, pmc->block_name[i],\n\t\t\t\t\t\t     info, MLXBF_PMC_INFO_SZ);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tif (pmc->svc_sreg_support)\n\t\t\tpmc->block[i].mmio_base = (void __iomem *)info[0];\n\t\telse\n\t\t\tpmc->block[i].mmio_base =\n\t\t\t\tdevm_ioremap(dev, info[0], info[1]);\n\n\t\tpmc->block[i].blk_size = info[1];\n\t\tpmc->block[i].counters = info[2];\n\t\tpmc->block[i].type = info[3];\n\n\t\tif (!pmc->block[i].mmio_base)\n\t\t\treturn -ENOMEM;\n\n\t\tret = mlxbf_pmc_create_groups(dev, i);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int mlxbf_pmc_probe(struct platform_device *pdev)\n{\n\tstruct acpi_device *acpi_dev = ACPI_COMPANION(&pdev->dev);\n\tconst char *hid = acpi_device_hid(acpi_dev);\n\tstruct device *dev = &pdev->dev;\n\tstruct arm_smccc_res res;\n\tguid_t guid;\n\tint ret;\n\n\t \n\tarm_smccc_smc(MLXBF_PMC_SIP_SVC_UID, 0, 0, 0, 0, 0, 0, 0, &res);\n\tguid_parse(mlxbf_pmc_svc_uuid_str, &guid);\n\tif (!mlxbf_pmc_guid_match(&guid, &res))\n\t\treturn -ENODEV;\n\n\tpmc = devm_kzalloc(dev, sizeof(struct mlxbf_pmc_context), GFP_KERNEL);\n\tif (!pmc)\n\t\treturn -ENOMEM;\n\n\t \n\tret = device_property_read_u32(dev, \"sec_reg_block\",\n\t\t\t\t       &pmc->sreg_tbl_perf);\n\tif (ret) {\n\t\tpmc->svc_sreg_support = false;\n\t} else {\n\t\t \n\t\tarm_smccc_smc(MLXBF_PMC_SIP_SVC_VERSION, 0, 0, 0, 0, 0, 0, 0,\n\t\t\t      &res);\n\t\tif (res.a0 == MLXBF_PMC_SVC_REQ_MAJOR &&\n\t\t    res.a1 >= MLXBF_PMC_SVC_MIN_MINOR)\n\t\t\tpmc->svc_sreg_support = true;\n\t\telse\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (!strcmp(hid, \"MLNXBFD0\"))\n\t\tpmc->event_set = MLXBF_PMC_EVENT_SET_BF1;\n\telse if (!strcmp(hid, \"MLNXBFD1\"))\n\t\tpmc->event_set = MLXBF_PMC_EVENT_SET_BF2;\n\telse\n\t\treturn -ENODEV;\n\n\tret = device_property_read_u32(dev, \"block_num\", &pmc->total_blocks);\n\tif (ret)\n\t\treturn ret;\n\n\tret = device_property_read_string_array(dev, \"block_name\",\n\t\t\t\t\t\tpmc->block_name,\n\t\t\t\t\t\tpmc->total_blocks);\n\tif (ret != pmc->total_blocks)\n\t\treturn -EFAULT;\n\n\tret = device_property_read_u32(dev, \"tile_num\", &pmc->tile_count);\n\tif (ret)\n\t\treturn ret;\n\n\tpmc->pdev = pdev;\n\n\tret = mlxbf_pmc_map_counters(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tpmc->hwmon_dev = devm_hwmon_device_register_with_groups(\n\t\tdev, \"bfperf\", pmc, pmc->groups);\n\tif (IS_ERR(pmc->hwmon_dev))\n\t\treturn PTR_ERR(pmc->hwmon_dev);\n\tplatform_set_drvdata(pdev, pmc);\n\n\treturn 0;\n}\n\nstatic const struct acpi_device_id mlxbf_pmc_acpi_ids[] = { { \"MLNXBFD0\", 0 },\n\t\t\t\t\t\t\t    { \"MLNXBFD1\", 0 },\n\t\t\t\t\t\t\t    {}, };\n\nMODULE_DEVICE_TABLE(acpi, mlxbf_pmc_acpi_ids);\nstatic struct platform_driver pmc_driver = {\n\t.driver = { .name = \"mlxbf-pmc\",\n\t\t    .acpi_match_table = ACPI_PTR(mlxbf_pmc_acpi_ids), },\n\t.probe = mlxbf_pmc_probe,\n};\n\nmodule_platform_driver(pmc_driver);\n\nMODULE_AUTHOR(\"Shravan Kumar Ramani <sramani@mellanox.com>\");\nMODULE_DESCRIPTION(\"Mellanox PMC driver\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}