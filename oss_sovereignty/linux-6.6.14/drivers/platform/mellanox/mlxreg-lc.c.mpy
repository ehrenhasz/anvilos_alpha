{
  "module_name": "mlxreg-lc.c",
  "hash_id": "bffa53dd866c91e32f8c85f2419ec973ef7573f9716f655deebee708a3fa2add",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/mellanox/mlxreg-lc.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/i2c.h>\n#include <linux/module.h>\n#include <linux/platform_data/mlxcpld.h>\n#include <linux/platform_data/mlxreg.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n\n \n#define MLXREG_LC_REG_CPLD1_VER_OFFSET\t\t0x2500\n#define MLXREG_LC_REG_FPGA1_VER_OFFSET\t\t0x2501\n#define MLXREG_LC_REG_CPLD1_PN_OFFSET\t\t0x2504\n#define MLXREG_LC_REG_FPGA1_PN_OFFSET\t\t0x2506\n#define MLXREG_LC_REG_RESET_CAUSE_OFFSET\t0x251d\n#define MLXREG_LC_REG_LED1_OFFSET\t\t0x2520\n#define MLXREG_LC_REG_GP0_OFFSET\t\t0x252e\n#define MLXREG_LC_REG_FIELD_UPGRADE\t\t0x2534\n#define MLXREG_LC_CHANNEL_I2C_REG\t\t0x25dc\n#define MLXREG_LC_REG_CPLD1_MVER_OFFSET\t\t0x25de\n#define MLXREG_LC_REG_FPGA1_MVER_OFFSET\t\t0x25df\n#define MLXREG_LC_REG_MAX_POWER_OFFSET\t\t0x25f1\n#define MLXREG_LC_REG_CONFIG_OFFSET\t\t0x25fb\n#define MLXREG_LC_REG_MAX\t\t\t0x3fff\n\n \nenum mlxreg_lc_type {\n\tMLXREG_LC_SN4800_C16 = 0x0000,\n};\n\n \nenum mlxreg_lc_state {\n\tMLXREG_LC_INITIALIZED = BIT(0),\n\tMLXREG_LC_POWERED = BIT(1),\n\tMLXREG_LC_SYNCED = BIT(2),\n};\n\n#define MLXREG_LC_CONFIGURED\t(MLXREG_LC_INITIALIZED | MLXREG_LC_POWERED | MLXREG_LC_SYNCED)\n\n \nstruct mlxreg_lc {\n\tstruct device *dev;\n\tstruct mutex lock;  \n\tvoid *par_regmap;\n\tstruct mlxreg_core_data *data;\n\tstruct mlxreg_core_platform_data *io_data;\n\tstruct mlxreg_core_platform_data *led_data;\n\tstruct mlxcpld_mux_plat_data *mux_data;\n\tstruct platform_device *led;\n\tstruct platform_device *io_regs;\n\tstruct i2c_board_info *mux_brdinfo;\n\tstruct platform_device *mux;\n\tstruct mlxreg_hotplug_device *aux_devs;\n\tint aux_devs_num;\n\tstruct mlxreg_hotplug_device *main_devs;\n\tint main_devs_num;\n\tenum mlxreg_lc_state state;\n};\n\nstatic bool mlxreg_lc_writeable_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase MLXREG_LC_REG_LED1_OFFSET:\n\tcase MLXREG_LC_REG_GP0_OFFSET:\n\tcase MLXREG_LC_REG_FIELD_UPGRADE:\n\tcase MLXREG_LC_CHANNEL_I2C_REG:\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic bool mlxreg_lc_readable_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase MLXREG_LC_REG_CPLD1_VER_OFFSET:\n\tcase MLXREG_LC_REG_FPGA1_VER_OFFSET:\n\tcase MLXREG_LC_REG_CPLD1_PN_OFFSET:\n\tcase MLXREG_LC_REG_FPGA1_PN_OFFSET:\n\tcase MLXREG_LC_REG_RESET_CAUSE_OFFSET:\n\tcase MLXREG_LC_REG_LED1_OFFSET:\n\tcase MLXREG_LC_REG_GP0_OFFSET:\n\tcase MLXREG_LC_REG_FIELD_UPGRADE:\n\tcase MLXREG_LC_CHANNEL_I2C_REG:\n\tcase MLXREG_LC_REG_CPLD1_MVER_OFFSET:\n\tcase MLXREG_LC_REG_FPGA1_MVER_OFFSET:\n\tcase MLXREG_LC_REG_MAX_POWER_OFFSET:\n\tcase MLXREG_LC_REG_CONFIG_OFFSET:\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic bool mlxreg_lc_volatile_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase MLXREG_LC_REG_CPLD1_VER_OFFSET:\n\tcase MLXREG_LC_REG_FPGA1_VER_OFFSET:\n\tcase MLXREG_LC_REG_CPLD1_PN_OFFSET:\n\tcase MLXREG_LC_REG_FPGA1_PN_OFFSET:\n\tcase MLXREG_LC_REG_RESET_CAUSE_OFFSET:\n\tcase MLXREG_LC_REG_LED1_OFFSET:\n\tcase MLXREG_LC_REG_GP0_OFFSET:\n\tcase MLXREG_LC_REG_FIELD_UPGRADE:\n\tcase MLXREG_LC_CHANNEL_I2C_REG:\n\tcase MLXREG_LC_REG_CPLD1_MVER_OFFSET:\n\tcase MLXREG_LC_REG_FPGA1_MVER_OFFSET:\n\tcase MLXREG_LC_REG_MAX_POWER_OFFSET:\n\tcase MLXREG_LC_REG_CONFIG_OFFSET:\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic const struct reg_default mlxreg_lc_regmap_default[] = {\n\t{ MLXREG_LC_CHANNEL_I2C_REG, 0x00 },\n};\n\n \nstatic const struct regmap_config mlxreg_lc_regmap_conf = {\n\t.reg_bits = 16,\n\t.val_bits = 8,\n\t.max_register = MLXREG_LC_REG_MAX,\n\t.cache_type = REGCACHE_FLAT,\n\t.writeable_reg = mlxreg_lc_writeable_reg,\n\t.readable_reg = mlxreg_lc_readable_reg,\n\t.volatile_reg = mlxreg_lc_volatile_reg,\n\t.reg_defaults = mlxreg_lc_regmap_default,\n\t.num_reg_defaults = ARRAY_SIZE(mlxreg_lc_regmap_default),\n};\n\n \nstatic int mlxreg_lc_chan[] = {\n\t0x04, 0x05, 0x06, 0x07, 0x08, 0x10, 0x20, 0x21, 0x22, 0x23, 0x40, 0x41,\n\t0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d,\n\t0x4e, 0x4f\n};\n\n \nstatic struct mlxcpld_mux_plat_data mlxreg_lc_mux_data[] = {\n\t{\n\t\t.chan_ids = mlxreg_lc_chan,\n\t\t.num_adaps = ARRAY_SIZE(mlxreg_lc_chan),\n\t\t.sel_reg_addr = MLXREG_LC_CHANNEL_I2C_REG,\n\t\t.reg_size = 2,\n\t},\n};\n\n \nstatic struct i2c_board_info mlxreg_lc_mux_brdinfo = {\n\tI2C_BOARD_INFO(\"i2c-mux-mlxcpld\", 0x32),\n};\n\n \nstatic struct i2c_board_info mlxreg_lc_aux_pwr_devices[] = {\n\t{\n\t\tI2C_BOARD_INFO(\"24c32\", 0x51),\n\t},\n\t{\n\t\tI2C_BOARD_INFO(\"24c32\", 0x51),\n\t},\n};\n\n \nstatic struct mlxreg_hotplug_device mlxreg_lc_aux_pwr_brdinfo[] = {\n\t{\n\t\t.brdinfo = &mlxreg_lc_aux_pwr_devices[0],\n\t\t.nr = 3,\n\t},\n\t{\n\t\t.brdinfo = &mlxreg_lc_aux_pwr_devices[1],\n\t\t.nr = 4,\n\t},\n};\n\n \nstatic struct i2c_board_info mlxreg_lc_main_pwr_devices[] = {\n\t{\n\t\tI2C_BOARD_INFO(\"mp2975\", 0x62),\n\t},\n\t{\n\t\tI2C_BOARD_INFO(\"mp2975\", 0x64),\n\t},\n\t{\n\t\tI2C_BOARD_INFO(\"max11603\", 0x6d),\n\t},\n\t{\n\t\tI2C_BOARD_INFO(\"lm25066\", 0x15),\n\t},\n};\n\n \nstatic struct mlxreg_hotplug_device mlxreg_lc_main_pwr_brdinfo[] = {\n\t{\n\t\t.brdinfo = &mlxreg_lc_main_pwr_devices[0],\n\t\t.nr = 0,\n\t},\n\t{\n\t\t.brdinfo = &mlxreg_lc_main_pwr_devices[1],\n\t\t.nr = 0,\n\t},\n\t{\n\t\t.brdinfo = &mlxreg_lc_main_pwr_devices[2],\n\t\t.nr = 1,\n\t},\n\t{\n\t\t.brdinfo = &mlxreg_lc_main_pwr_devices[3],\n\t\t.nr = 2,\n\t},\n};\n\n \nstatic struct mlxreg_core_data mlxreg_lc_led_data[] = {\n\t{\n\t\t.label = \"status:green\",\n\t\t.reg = MLXREG_LC_REG_LED1_OFFSET,\n\t\t.mask = GENMASK(7, 4),\n\t},\n\t{\n\t\t.label = \"status:orange\",\n\t\t.reg = MLXREG_LC_REG_LED1_OFFSET,\n\t\t.mask = GENMASK(7, 4),\n\t},\n};\n\nstatic struct mlxreg_core_platform_data mlxreg_lc_led = {\n\t.identity = \"pci\",\n\t.data = mlxreg_lc_led_data,\n\t.counter = ARRAY_SIZE(mlxreg_lc_led_data),\n};\n\n \nstatic struct mlxreg_core_data mlxreg_lc_io_data[] = {\n\t{\n\t\t.label = \"cpld1_version\",\n\t\t.reg = MLXREG_LC_REG_CPLD1_VER_OFFSET,\n\t\t.bit = GENMASK(7, 0),\n\t\t.mode = 0444,\n\t},\n\t{\n\t\t.label = \"fpga1_version\",\n\t\t.reg = MLXREG_LC_REG_FPGA1_VER_OFFSET,\n\t\t.bit = GENMASK(7, 0),\n\t\t.mode = 0444,\n\t},\n\t{\n\t\t.label = \"cpld1_pn\",\n\t\t.reg = MLXREG_LC_REG_CPLD1_PN_OFFSET,\n\t\t.bit = GENMASK(15, 0),\n\t\t.mode = 0444,\n\t\t.regnum = 2,\n\t},\n\t{\n\t\t.label = \"fpga1_pn\",\n\t\t.reg = MLXREG_LC_REG_FPGA1_PN_OFFSET,\n\t\t.bit = GENMASK(15, 0),\n\t\t.mode = 0444,\n\t\t.regnum = 2,\n\t},\n\t{\n\t\t.label = \"cpld1_version_min\",\n\t\t.reg = MLXREG_LC_REG_CPLD1_MVER_OFFSET,\n\t\t.bit = GENMASK(7, 0),\n\t\t.mode = 0444,\n\t},\n\t{\n\t\t.label = \"fpga1_version_min\",\n\t\t.reg = MLXREG_LC_REG_FPGA1_MVER_OFFSET,\n\t\t.bit = GENMASK(7, 0),\n\t\t.mode = 0444,\n\t},\n\t{\n\t\t.label = \"reset_fpga_not_done\",\n\t\t.reg = MLXREG_LC_REG_RESET_CAUSE_OFFSET,\n\t\t.mask = GENMASK(7, 0) & ~BIT(1),\n\t\t.mode = 0444,\n\t},\n\t{\n\t\t.label = \"reset_aux_pwr_or_ref\",\n\t\t.reg = MLXREG_LC_REG_RESET_CAUSE_OFFSET,\n\t\t.mask = GENMASK(7, 0) & ~BIT(2),\n\t\t.mode = 0444,\n\t},\n\t{\n\t\t.label = \"reset_dc_dc_pwr_fail\",\n\t\t.reg = MLXREG_LC_REG_RESET_CAUSE_OFFSET,\n\t\t.mask = GENMASK(7, 0) & ~BIT(3),\n\t\t.mode = 0444,\n\t},\n\t{\n\t\t.label = \"reset_from_chassis\",\n\t\t.reg = MLXREG_LC_REG_RESET_CAUSE_OFFSET,\n\t\t.mask = GENMASK(7, 0) & ~BIT(4),\n\t\t.mode = 0444,\n\t},\n\t{\n\t\t.label = \"reset_pwr_off_from_chassis\",\n\t\t.reg = MLXREG_LC_REG_RESET_CAUSE_OFFSET,\n\t\t.mask = GENMASK(7, 0) & ~BIT(5),\n\t\t.mode = 0444,\n\t},\n\t{\n\t\t.label = \"reset_line_card\",\n\t\t.reg = MLXREG_LC_REG_RESET_CAUSE_OFFSET,\n\t\t.mask = GENMASK(7, 0) & ~BIT(6),\n\t\t.mode = 0444,\n\t},\n\t{\n\t\t.label = \"reset_line_card_pwr_en\",\n\t\t.reg = MLXREG_LC_REG_RESET_CAUSE_OFFSET,\n\t\t.mask = GENMASK(7, 0) & ~BIT(7),\n\t\t.mode = 0444,\n\t},\n\t{\n\t\t.label = \"cpld_upgrade_en\",\n\t\t.reg = MLXREG_LC_REG_FIELD_UPGRADE,\n\t\t.mask = GENMASK(7, 0) & ~BIT(0),\n\t\t.mode = 0644,\n\t\t.secured = 1,\n\t},\n\t{\n\t\t.label = \"fpga_upgrade_en\",\n\t\t.reg = MLXREG_LC_REG_FIELD_UPGRADE,\n\t\t.mask = GENMASK(7, 0) & ~BIT(1),\n\t\t.mode = 0644,\n\t\t.secured = 1,\n\t},\n\t{\n\t\t.label = \"qsfp_pwr_en\",\n\t\t.reg = MLXREG_LC_REG_GP0_OFFSET,\n\t\t.mask = GENMASK(7, 0) & ~BIT(0),\n\t\t.mode = 0644,\n\t},\n\t{\n\t\t.label = \"vpd_wp\",\n\t\t.reg = MLXREG_LC_REG_GP0_OFFSET,\n\t\t.mask = GENMASK(7, 0) & ~BIT(3),\n\t\t.mode = 0644,\n\t\t.secured = 1,\n\t},\n\t{\n\t\t.label = \"agb_spi_burn_en\",\n\t\t.reg = MLXREG_LC_REG_GP0_OFFSET,\n\t\t.mask = GENMASK(7, 0) & ~BIT(5),\n\t\t.mode = 0644,\n\t\t.secured = 1,\n\t},\n\t{\n\t\t.label = \"fpga_spi_burn_en\",\n\t\t.reg = MLXREG_LC_REG_GP0_OFFSET,\n\t\t.mask = GENMASK(7, 0) & ~BIT(6),\n\t\t.mode = 0644,\n\t\t.secured = 1,\n\t},\n\t{\n\t\t.label = \"max_power\",\n\t\t.reg = MLXREG_LC_REG_MAX_POWER_OFFSET,\n\t\t.bit = GENMASK(15, 0),\n\t\t.mode = 0444,\n\t\t.regnum = 2,\n\t},\n\t{\n\t\t.label = \"config\",\n\t\t.reg = MLXREG_LC_REG_CONFIG_OFFSET,\n\t\t.bit = GENMASK(15, 0),\n\t\t.mode = 0444,\n\t\t.regnum = 2,\n\t},\n};\n\nstatic struct mlxreg_core_platform_data mlxreg_lc_regs_io = {\n\t.data = mlxreg_lc_io_data,\n\t.counter = ARRAY_SIZE(mlxreg_lc_io_data),\n};\n\nstatic int\nmlxreg_lc_create_static_devices(struct mlxreg_lc *mlxreg_lc, struct mlxreg_hotplug_device *devs,\n\t\t\t\tint size)\n{\n\tstruct mlxreg_hotplug_device *dev = devs;\n\tint i, ret;\n\n\t \n\tfor (i = 0; i < size; i++, dev++) {\n\t\tdev->client = i2c_new_client_device(dev->adapter, dev->brdinfo);\n\t\tif (IS_ERR(dev->client)) {\n\t\t\tdev_err(mlxreg_lc->dev, \"Failed to create client %s at bus %d at addr 0x%02x\\n\",\n\t\t\t\tdev->brdinfo->type, dev->nr, dev->brdinfo->addr);\n\n\t\t\tdev->adapter = NULL;\n\t\t\tret = PTR_ERR(dev->client);\n\t\t\tgoto fail_create_static_devices;\n\t\t}\n\t}\n\n\treturn 0;\n\nfail_create_static_devices:\n\twhile (--i >= 0) {\n\t\tdev = devs + i;\n\t\ti2c_unregister_device(dev->client);\n\t\tdev->client = NULL;\n\t}\n\treturn ret;\n}\n\nstatic void\nmlxreg_lc_destroy_static_devices(struct mlxreg_lc *mlxreg_lc, struct mlxreg_hotplug_device *devs,\n\t\t\t\t int size)\n{\n\tstruct mlxreg_hotplug_device *dev = devs;\n\tint i;\n\n\t \n\tfor (i = 0; i < size; i++, dev++) {\n\t\tif (dev->client) {\n\t\t\ti2c_unregister_device(dev->client);\n\t\t\tdev->client = NULL;\n\t\t}\n\t}\n}\n\nstatic int mlxreg_lc_power_on_off(struct mlxreg_lc *mlxreg_lc, u8 action)\n{\n\tu32 regval;\n\tint err;\n\n\terr = regmap_read(mlxreg_lc->par_regmap, mlxreg_lc->data->reg_pwr, &regval);\n\tif (err)\n\t\tgoto regmap_read_fail;\n\n\tif (action)\n\t\tregval |= BIT(mlxreg_lc->data->slot - 1);\n\telse\n\t\tregval &= ~BIT(mlxreg_lc->data->slot - 1);\n\n\terr = regmap_write(mlxreg_lc->par_regmap, mlxreg_lc->data->reg_pwr, regval);\n\nregmap_read_fail:\n\treturn err;\n}\n\nstatic int mlxreg_lc_enable_disable(struct mlxreg_lc *mlxreg_lc, bool action)\n{\n\tu32 regval;\n\tint err;\n\n\t \n\terr = regmap_read(mlxreg_lc->par_regmap, mlxreg_lc->data->reg_ena, &regval);\n\tif (err)\n\t\tgoto regmap_read_fail;\n\n\tif (action)\n\t\tregval |= BIT(mlxreg_lc->data->slot - 1);\n\telse\n\t\tregval &= ~BIT(mlxreg_lc->data->slot - 1);\n\n\terr = regmap_write(mlxreg_lc->par_regmap, mlxreg_lc->data->reg_ena, regval);\n\nregmap_read_fail:\n\treturn err;\n}\n\nstatic int\nmlxreg_lc_sn4800_c16_config_init(struct mlxreg_lc *mlxreg_lc, void *regmap,\n\t\t\t\t struct mlxreg_core_data *data)\n{\n\tstruct device *dev = &data->hpdev.client->dev;\n\n\t \n\tmlxreg_lc->mux_data = mlxreg_lc_mux_data;\n\tmlxreg_lc->io_data = &mlxreg_lc_regs_io;\n\tmlxreg_lc->led_data = &mlxreg_lc_led;\n\tmlxreg_lc->mux_brdinfo = &mlxreg_lc_mux_brdinfo;\n\n\tmlxreg_lc->aux_devs = devm_kmemdup(dev, mlxreg_lc_aux_pwr_brdinfo,\n\t\t\t\t\t   sizeof(mlxreg_lc_aux_pwr_brdinfo), GFP_KERNEL);\n\tif (!mlxreg_lc->aux_devs)\n\t\treturn -ENOMEM;\n\tmlxreg_lc->aux_devs_num = ARRAY_SIZE(mlxreg_lc_aux_pwr_brdinfo);\n\tmlxreg_lc->main_devs = devm_kmemdup(dev, mlxreg_lc_main_pwr_brdinfo,\n\t\t\t\t\t    sizeof(mlxreg_lc_main_pwr_brdinfo), GFP_KERNEL);\n\tif (!mlxreg_lc->main_devs)\n\t\treturn -ENOMEM;\n\tmlxreg_lc->main_devs_num = ARRAY_SIZE(mlxreg_lc_main_pwr_brdinfo);\n\n\treturn 0;\n}\n\nstatic void\nmlxreg_lc_state_update(struct mlxreg_lc *mlxreg_lc, enum mlxreg_lc_state state, u8 action)\n{\n\tif (action)\n\t\tmlxreg_lc->state |= state;\n\telse\n\t\tmlxreg_lc->state &= ~state;\n}\n\nstatic void\nmlxreg_lc_state_update_locked(struct mlxreg_lc *mlxreg_lc, enum mlxreg_lc_state state, u8 action)\n{\n\tmutex_lock(&mlxreg_lc->lock);\n\n\tif (action)\n\t\tmlxreg_lc->state |= state;\n\telse\n\t\tmlxreg_lc->state &= ~state;\n\n\tmutex_unlock(&mlxreg_lc->lock);\n}\n\n \nstatic int mlxreg_lc_event_handler(void *handle, enum mlxreg_hotplug_kind kind, u8 action)\n{\n\tstruct mlxreg_lc *mlxreg_lc = handle;\n\tint err = 0;\n\n\tdev_info(mlxreg_lc->dev, \"linecard#%d state %d event kind %d action %d\\n\",\n\t\t mlxreg_lc->data->slot, mlxreg_lc->state, kind, action);\n\n\tmutex_lock(&mlxreg_lc->lock);\n\tif (!(mlxreg_lc->state & MLXREG_LC_INITIALIZED))\n\t\tgoto mlxreg_lc_non_initialzed_exit;\n\n\tswitch (kind) {\n\tcase MLXREG_HOTPLUG_LC_SYNCED:\n\t\t \n\t\tmlxreg_lc_state_update(mlxreg_lc, MLXREG_LC_SYNCED, action);\n\t\t \n\t\tif (!(mlxreg_lc->state & MLXREG_LC_POWERED) && action) {\n\t\t\terr = mlxreg_lc_power_on_off(mlxreg_lc, 1);\n\t\t\tif (err)\n\t\t\t\tgoto mlxreg_lc_power_on_off_fail;\n\t\t}\n\t\t \n\t\tif (mlxreg_lc->state & MLXREG_LC_CONFIGURED && action)\n\t\t\terr = mlxreg_lc_enable_disable(mlxreg_lc, 1);\n\t\tbreak;\n\tcase MLXREG_HOTPLUG_LC_POWERED:\n\t\t \n\t\tif (action) {\n\t\t\t \n\t\t\tif (mlxreg_lc->state & MLXREG_LC_POWERED) {\n\t\t\t\t \n\t\t\t\tif (mlxreg_lc->state & MLXREG_LC_CONFIGURED)\n\t\t\t\t\terr = mlxreg_lc_enable_disable(mlxreg_lc, 1);\n\n\t\t\t\tgoto mlxreg_lc_enable_disable_exit;\n\t\t\t}\n\t\t\terr = mlxreg_lc_create_static_devices(mlxreg_lc, mlxreg_lc->main_devs,\n\t\t\t\t\t\t\t      mlxreg_lc->main_devs_num);\n\t\t\tif (err)\n\t\t\t\tgoto mlxreg_lc_create_static_devices_fail;\n\n\t\t\t \n\t\t\tif (mlxreg_lc->state & MLXREG_LC_CONFIGURED)\n\t\t\t\terr = mlxreg_lc_enable_disable(mlxreg_lc, 1);\n\t\t} else {\n\t\t\tmlxreg_lc_destroy_static_devices(mlxreg_lc, mlxreg_lc->main_devs,\n\t\t\t\t\t\t\t mlxreg_lc->main_devs_num);\n\t\t}\n\t\tmlxreg_lc_state_update(mlxreg_lc, MLXREG_LC_POWERED, action);\n\t\tbreak;\n\tcase MLXREG_HOTPLUG_LC_READY:\n\t\t \n\t\terr = mlxreg_lc_enable_disable(mlxreg_lc, !!action);\n\t\tbreak;\n\tcase MLXREG_HOTPLUG_LC_THERMAL:\n\t\t \n\t\tif (action)\n\t\t\terr = mlxreg_lc_power_on_off(mlxreg_lc, 0);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\nmlxreg_lc_enable_disable_exit:\nmlxreg_lc_power_on_off_fail:\nmlxreg_lc_create_static_devices_fail:\nmlxreg_lc_non_initialzed_exit:\n\tmutex_unlock(&mlxreg_lc->lock);\n\n\treturn err;\n}\n\n \nstatic int mlxreg_lc_completion_notify(void *handle, struct i2c_adapter *parent,\n\t\t\t\t       struct i2c_adapter *adapters[])\n{\n\tstruct mlxreg_hotplug_device *main_dev, *aux_dev;\n\tstruct mlxreg_lc *mlxreg_lc = handle;\n\tu32 regval;\n\tint i, err;\n\n\t \n\taux_dev = mlxreg_lc->aux_devs;\n\tfor (i = 0; i < mlxreg_lc->aux_devs_num; i++, aux_dev++) {\n\t\taux_dev->adapter = adapters[aux_dev->nr];\n\t\taux_dev->nr = adapters[aux_dev->nr]->nr;\n\t}\n\n\terr = mlxreg_lc_create_static_devices(mlxreg_lc, mlxreg_lc->aux_devs,\n\t\t\t\t\t      mlxreg_lc->aux_devs_num);\n\tif (err)\n\t\treturn err;\n\n\t \n\tmain_dev = mlxreg_lc->main_devs;\n\tfor (i = 0; i < mlxreg_lc->main_devs_num; i++, main_dev++) {\n\t\tmain_dev->adapter = adapters[main_dev->nr];\n\t\tmain_dev->nr = adapters[main_dev->nr]->nr;\n\t}\n\n\t \n\terr = regmap_read(mlxreg_lc->par_regmap, mlxreg_lc->data->reg_pwr, &regval);\n\tif (err)\n\t\tgoto mlxreg_lc_regmap_read_power_fail;\n\n\tif (regval & mlxreg_lc->data->mask) {\n\t\terr = mlxreg_lc_create_static_devices(mlxreg_lc, mlxreg_lc->main_devs,\n\t\t\t\t\t\t      mlxreg_lc->main_devs_num);\n\t\tif (err)\n\t\t\tgoto mlxreg_lc_create_static_devices_failed;\n\n\t\tmlxreg_lc_state_update_locked(mlxreg_lc, MLXREG_LC_POWERED, 1);\n\t}\n\n\t \n\terr = regmap_read(mlxreg_lc->par_regmap, mlxreg_lc->data->reg_sync, &regval);\n\tif (err)\n\t\tgoto mlxreg_lc_regmap_read_sync_fail;\n\n\t \n\tif (regval & mlxreg_lc->data->mask) {\n\t\tmlxreg_lc->state |= MLXREG_LC_SYNCED;\n\t\tmlxreg_lc_state_update_locked(mlxreg_lc, MLXREG_LC_SYNCED, 1);\n\t\tif (mlxreg_lc->state & ~MLXREG_LC_POWERED) {\n\t\t\terr = mlxreg_lc_power_on_off(mlxreg_lc, 1);\n\t\t\tif (err)\n\t\t\t\tgoto mlxreg_lc_regmap_power_on_off_fail;\n\t\t}\n\t}\n\n\tmlxreg_lc_state_update_locked(mlxreg_lc, MLXREG_LC_INITIALIZED, 1);\n\n\treturn 0;\n\nmlxreg_lc_regmap_power_on_off_fail:\nmlxreg_lc_regmap_read_sync_fail:\n\tif (mlxreg_lc->state & MLXREG_LC_POWERED)\n\t\tmlxreg_lc_destroy_static_devices(mlxreg_lc, mlxreg_lc->main_devs,\n\t\t\t\t\t\t mlxreg_lc->main_devs_num);\nmlxreg_lc_create_static_devices_failed:\n\tmlxreg_lc_destroy_static_devices(mlxreg_lc, mlxreg_lc->aux_devs, mlxreg_lc->aux_devs_num);\nmlxreg_lc_regmap_read_power_fail:\n\treturn err;\n}\n\nstatic int\nmlxreg_lc_config_init(struct mlxreg_lc *mlxreg_lc, void *regmap,\n\t\t      struct mlxreg_core_data *data)\n{\n\tstruct device *dev = &data->hpdev.client->dev;\n\tint lsb, err;\n\tu32 regval;\n\n\t \n\terr = regmap_read(regmap, MLXREG_LC_REG_CONFIG_OFFSET, &lsb);\n\terr = (!err) ? regmap_read(regmap, MLXREG_LC_REG_CONFIG_OFFSET, &regval) : err;\n\tif (err)\n\t\treturn err;\n\tregval = (regval & GENMASK(7, 0)) << 8 | (lsb & GENMASK(7, 0));\n\tswitch (regval) {\n\tcase MLXREG_LC_SN4800_C16:\n\t\terr = mlxreg_lc_sn4800_c16_config_init(mlxreg_lc, regmap, data);\n\t\tif (err) {\n\t\t\tdev_err(dev, \"Failed to config client %s at bus %d at addr 0x%02x\\n\",\n\t\t\t\tdata->hpdev.brdinfo->type, data->hpdev.nr,\n\t\t\t\tdata->hpdev.brdinfo->addr);\n\t\t\treturn err;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tmlxreg_lc->mux_data->handle = mlxreg_lc;\n\tmlxreg_lc->mux_data->completion_notify = mlxreg_lc_completion_notify;\n\tmlxreg_lc->mux_brdinfo->platform_data = mlxreg_lc->mux_data;\n\tmlxreg_lc->mux = platform_device_register_resndata(dev, \"i2c-mux-mlxcpld\", data->hpdev.nr,\n\t\t\t\t\t\t\t   NULL, 0, mlxreg_lc->mux_data,\n\t\t\t\t\t\t\t   sizeof(*mlxreg_lc->mux_data));\n\tif (IS_ERR(mlxreg_lc->mux)) {\n\t\tdev_err(dev, \"Failed to create mux infra for client %s at bus %d at addr 0x%02x\\n\",\n\t\t\tdata->hpdev.brdinfo->type, data->hpdev.nr, data->hpdev.brdinfo->addr);\n\t\treturn PTR_ERR(mlxreg_lc->mux);\n\t}\n\n\t \n\tif (mlxreg_lc->io_data) {\n\t\tmlxreg_lc->io_data->regmap = regmap;\n\t\tmlxreg_lc->io_regs =\n\t\tplatform_device_register_resndata(dev, \"mlxreg-io\", data->hpdev.nr, NULL, 0,\n\t\t\t\t\t\t  mlxreg_lc->io_data, sizeof(*mlxreg_lc->io_data));\n\t\tif (IS_ERR(mlxreg_lc->io_regs)) {\n\t\t\tdev_err(dev, \"Failed to create regio for client %s at bus %d at addr 0x%02x\\n\",\n\t\t\t\tdata->hpdev.brdinfo->type, data->hpdev.nr,\n\t\t\t\tdata->hpdev.brdinfo->addr);\n\t\t\terr = PTR_ERR(mlxreg_lc->io_regs);\n\t\t\tgoto fail_register_io;\n\t\t}\n\t}\n\n\t \n\tif (mlxreg_lc->led_data) {\n\t\tmlxreg_lc->led_data->regmap = regmap;\n\t\tmlxreg_lc->led =\n\t\tplatform_device_register_resndata(dev, \"leds-mlxreg\", data->hpdev.nr, NULL, 0,\n\t\t\t\t\t\t  mlxreg_lc->led_data,\n\t\t\t\t\t\t  sizeof(*mlxreg_lc->led_data));\n\t\tif (IS_ERR(mlxreg_lc->led)) {\n\t\t\tdev_err(dev, \"Failed to create LED objects for client %s at bus %d at addr 0x%02x\\n\",\n\t\t\t\tdata->hpdev.brdinfo->type, data->hpdev.nr,\n\t\t\t\tdata->hpdev.brdinfo->addr);\n\t\t\terr = PTR_ERR(mlxreg_lc->led);\n\t\t\tgoto fail_register_led;\n\t\t}\n\t}\n\n\treturn 0;\n\nfail_register_led:\n\tif (mlxreg_lc->io_regs)\n\t\tplatform_device_unregister(mlxreg_lc->io_regs);\nfail_register_io:\n\tif (mlxreg_lc->mux)\n\t\tplatform_device_unregister(mlxreg_lc->mux);\n\n\treturn err;\n}\n\nstatic void mlxreg_lc_config_exit(struct mlxreg_lc *mlxreg_lc)\n{\n\t \n\tif (mlxreg_lc->led)\n\t\tplatform_device_unregister(mlxreg_lc->led);\n\t \n\tif (mlxreg_lc->io_regs)\n\t\tplatform_device_unregister(mlxreg_lc->io_regs);\n\t \n\tif (mlxreg_lc->mux)\n\t\tplatform_device_unregister(mlxreg_lc->mux);\n}\n\nstatic int mlxreg_lc_probe(struct platform_device *pdev)\n{\n\tstruct mlxreg_core_hotplug_platform_data *par_pdata;\n\tstruct mlxreg_core_data *data;\n\tstruct mlxreg_lc *mlxreg_lc;\n\tvoid *regmap;\n\tint i, err;\n\n\tdata = dev_get_platdata(&pdev->dev);\n\tif (!data)\n\t\treturn -EINVAL;\n\n\tmlxreg_lc = devm_kzalloc(&pdev->dev, sizeof(*mlxreg_lc), GFP_KERNEL);\n\tif (!mlxreg_lc)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&mlxreg_lc->lock);\n\t \n\tdata->notifier->user_handler = mlxreg_lc_event_handler;\n\tdata->notifier->handle = mlxreg_lc;\n\n\tdata->hpdev.adapter = i2c_get_adapter(data->hpdev.nr);\n\tif (!data->hpdev.adapter) {\n\t\tdev_err(&pdev->dev, \"Failed to get adapter for bus %d\\n\",\n\t\t\tdata->hpdev.nr);\n\t\terr = -EFAULT;\n\t\tgoto i2c_get_adapter_fail;\n\t}\n\n\t \n\tdata->hpdev.client = i2c_new_client_device(data->hpdev.adapter,\n\t\t\t\t\t\t   data->hpdev.brdinfo);\n\tif (IS_ERR(data->hpdev.client)) {\n\t\tdev_err(&pdev->dev, \"Failed to create client %s at bus %d at addr 0x%02x\\n\",\n\t\t\tdata->hpdev.brdinfo->type, data->hpdev.nr, data->hpdev.brdinfo->addr);\n\t\terr = PTR_ERR(data->hpdev.client);\n\t\tgoto i2c_new_device_fail;\n\t}\n\n\tregmap = devm_regmap_init_i2c(data->hpdev.client,\n\t\t\t\t      &mlxreg_lc_regmap_conf);\n\tif (IS_ERR(regmap)) {\n\t\tdev_err(&pdev->dev, \"Failed to create regmap for client %s at bus %d at addr 0x%02x\\n\",\n\t\t\tdata->hpdev.brdinfo->type, data->hpdev.nr, data->hpdev.brdinfo->addr);\n\t\terr = PTR_ERR(regmap);\n\t\tgoto devm_regmap_init_i2c_fail;\n\t}\n\n\t \n\tfor (i = 0; i < mlxreg_lc_regmap_conf.num_reg_defaults; i++) {\n\t\terr = regmap_write(regmap, mlxreg_lc_regmap_default[i].reg,\n\t\t\t\t   mlxreg_lc_regmap_default[i].def);\n\t\tif (err) {\n\t\t\tdev_err(&pdev->dev, \"Failed to set default regmap %d for client %s at bus %d at addr 0x%02x\\n\",\n\t\t\t\ti, data->hpdev.brdinfo->type, data->hpdev.nr,\n\t\t\t\tdata->hpdev.brdinfo->addr);\n\t\t\tgoto regmap_write_fail;\n\t\t}\n\t}\n\n\t \n\tregcache_mark_dirty(regmap);\n\terr = regcache_sync(regmap);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Failed to sync regmap for client %s at bus %d at addr 0x%02x\\n\",\n\t\t\tdata->hpdev.brdinfo->type, data->hpdev.nr, data->hpdev.brdinfo->addr);\n\t\tgoto regcache_sync_fail;\n\t}\n\n\tpar_pdata = data->hpdev.brdinfo->platform_data;\n\tmlxreg_lc->par_regmap = par_pdata->regmap;\n\tmlxreg_lc->data = data;\n\tmlxreg_lc->dev = &pdev->dev;\n\tplatform_set_drvdata(pdev, mlxreg_lc);\n\n\t \n\terr = mlxreg_lc_config_init(mlxreg_lc, regmap, data);\n\tif (err)\n\t\tgoto mlxreg_lc_config_init_fail;\n\n\treturn 0;\n\nmlxreg_lc_config_init_fail:\nregcache_sync_fail:\nregmap_write_fail:\ndevm_regmap_init_i2c_fail:\n\ti2c_unregister_device(data->hpdev.client);\n\tdata->hpdev.client = NULL;\ni2c_new_device_fail:\n\ti2c_put_adapter(data->hpdev.adapter);\n\tdata->hpdev.adapter = NULL;\ni2c_get_adapter_fail:\n\t \n\tif (data->notifier) {\n\t\tdata->notifier->user_handler = NULL;\n\t\tdata->notifier->handle = NULL;\n\t}\n\treturn err;\n}\n\nstatic int mlxreg_lc_remove(struct platform_device *pdev)\n{\n\tstruct mlxreg_core_data *data = dev_get_platdata(&pdev->dev);\n\tstruct mlxreg_lc *mlxreg_lc = platform_get_drvdata(pdev);\n\n\tmlxreg_lc_state_update_locked(mlxreg_lc, MLXREG_LC_INITIALIZED, 0);\n\n\t \n\tif (!data->notifier || !data->notifier->handle)\n\t\treturn 0;\n\n\t \n\tdata->notifier->user_handler = NULL;\n\tdata->notifier->handle = NULL;\n\n\t \n\tmlxreg_lc_destroy_static_devices(mlxreg_lc, mlxreg_lc->main_devs,\n\t\t\t\t\t mlxreg_lc->main_devs_num);\n\t \n\tmlxreg_lc_destroy_static_devices(mlxreg_lc, mlxreg_lc->aux_devs, mlxreg_lc->aux_devs_num);\n\t \n\tmlxreg_lc_config_exit(mlxreg_lc);\n\tif (data->hpdev.client) {\n\t\ti2c_unregister_device(data->hpdev.client);\n\t\tdata->hpdev.client = NULL;\n\t\ti2c_put_adapter(data->hpdev.adapter);\n\t\tdata->hpdev.adapter = NULL;\n\t}\n\n\treturn 0;\n}\n\nstatic struct platform_driver mlxreg_lc_driver = {\n\t.probe = mlxreg_lc_probe,\n\t.remove = mlxreg_lc_remove,\n\t.driver = {\n\t\t.name = \"mlxreg-lc\",\n\t},\n};\n\nmodule_platform_driver(mlxreg_lc_driver);\n\nMODULE_AUTHOR(\"Vadim Pasternak <vadimp@nvidia.com>\");\nMODULE_DESCRIPTION(\"Nvidia line card platform driver\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_ALIAS(\"platform:mlxreg-lc\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}