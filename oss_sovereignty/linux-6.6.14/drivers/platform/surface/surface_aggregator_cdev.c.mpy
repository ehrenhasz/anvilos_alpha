{
  "module_name": "surface_aggregator_cdev.c",
  "hash_id": "c0194827afeb69c19ded68643b8fd6aee9f2beaebe04421e61e47f56745eedad",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/surface/surface_aggregator_cdev.c",
  "human_readable_source": "\n \n\n#include <linux/fs.h>\n#include <linux/ioctl.h>\n#include <linux/kernel.h>\n#include <linux/kfifo.h>\n#include <linux/kref.h>\n#include <linux/miscdevice.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/poll.h>\n#include <linux/rwsem.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n\n#include <linux/surface_aggregator/cdev.h>\n#include <linux/surface_aggregator/controller.h>\n#include <linux/surface_aggregator/serial_hub.h>\n\n#define SSAM_CDEV_DEVICE_NAME\t\"surface_aggregator_cdev\"\n\n\n \n\nenum ssam_cdev_device_state {\n\tSSAM_CDEV_DEVICE_SHUTDOWN_BIT = BIT(0),\n};\n\nstruct ssam_cdev {\n\tstruct kref kref;\n\tstruct rw_semaphore lock;\n\n\tstruct device *dev;\n\tstruct ssam_controller *ctrl;\n\tstruct miscdevice mdev;\n\tunsigned long flags;\n\n\tstruct rw_semaphore client_lock;   \n\tstruct list_head client_list;\n};\n\nstruct ssam_cdev_client;\n\nstruct ssam_cdev_notifier {\n\tstruct ssam_cdev_client *client;\n\tstruct ssam_event_notifier nf;\n};\n\nstruct ssam_cdev_client {\n\tstruct ssam_cdev *cdev;\n\tstruct list_head node;\n\n\tstruct mutex notifier_lock;\t \n\tstruct ssam_cdev_notifier *notifier[SSH_NUM_EVENTS];\n\n\tstruct mutex read_lock;\t\t \n\tstruct mutex write_lock;\t \n\tDECLARE_KFIFO(buffer, u8, 4096);\n\n\twait_queue_head_t waitq;\n\tstruct fasync_struct *fasync;\n};\n\nstatic void __ssam_cdev_release(struct kref *kref)\n{\n\tkfree(container_of(kref, struct ssam_cdev, kref));\n}\n\nstatic struct ssam_cdev *ssam_cdev_get(struct ssam_cdev *cdev)\n{\n\tif (cdev)\n\t\tkref_get(&cdev->kref);\n\n\treturn cdev;\n}\n\nstatic void ssam_cdev_put(struct ssam_cdev *cdev)\n{\n\tif (cdev)\n\t\tkref_put(&cdev->kref, __ssam_cdev_release);\n}\n\n\n \n\nstatic u32 ssam_cdev_notifier(struct ssam_event_notifier *nf, const struct ssam_event *in)\n{\n\tstruct ssam_cdev_notifier *cdev_nf = container_of(nf, struct ssam_cdev_notifier, nf);\n\tstruct ssam_cdev_client *client = cdev_nf->client;\n\tstruct ssam_cdev_event event;\n\tsize_t n = struct_size(&event, data, in->length);\n\n\t \n\tevent.target_category = in->target_category;\n\tevent.target_id = in->target_id;\n\tevent.command_id = in->command_id;\n\tevent.instance_id = in->instance_id;\n\tevent.length = in->length;\n\n\tmutex_lock(&client->write_lock);\n\n\t \n\tif (kfifo_avail(&client->buffer) < n) {\n\t\tdev_warn(client->cdev->dev,\n\t\t\t \"buffer full, dropping event (tc: %#04x, tid: %#04x, cid: %#04x, iid: %#04x)\\n\",\n\t\t\t in->target_category, in->target_id, in->command_id, in->instance_id);\n\t\tmutex_unlock(&client->write_lock);\n\t\treturn 0;\n\t}\n\n\t \n\tkfifo_in(&client->buffer, (const u8 *)&event, struct_size(&event, data, 0));\n\tkfifo_in(&client->buffer, &in->data[0], in->length);\n\n\tmutex_unlock(&client->write_lock);\n\n\t \n\tkill_fasync(&client->fasync, SIGIO, POLL_IN);\n\twake_up_interruptible(&client->waitq);\n\n\t \n\treturn 0;\n}\n\nstatic int ssam_cdev_notifier_register(struct ssam_cdev_client *client, u8 tc, int priority)\n{\n\tconst u16 rqid = ssh_tc_to_rqid(tc);\n\tconst u16 event = ssh_rqid_to_event(rqid);\n\tstruct ssam_cdev_notifier *nf;\n\tint status;\n\n\tlockdep_assert_held_read(&client->cdev->lock);\n\n\t \n\tif (!ssh_rqid_is_event(rqid))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&client->notifier_lock);\n\n\t \n\tif (client->notifier[event]) {\n\t\tmutex_unlock(&client->notifier_lock);\n\t\treturn -EEXIST;\n\t}\n\n\t \n\tnf = kzalloc(sizeof(*nf), GFP_KERNEL);\n\tif (!nf) {\n\t\tmutex_unlock(&client->notifier_lock);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tnf->client = client;\n\tnf->nf.base.fn = ssam_cdev_notifier;\n\tnf->nf.base.priority = priority;\n\tnf->nf.event.id.target_category = tc;\n\tnf->nf.event.mask = 0;\t \n\tnf->nf.flags = SSAM_EVENT_NOTIFIER_OBSERVER;\n\n\t \n\tstatus = ssam_notifier_register(client->cdev->ctrl, &nf->nf);\n\tif (status)\n\t\tkfree(nf);\n\telse\n\t\tclient->notifier[event] = nf;\n\n\tmutex_unlock(&client->notifier_lock);\n\treturn status;\n}\n\nstatic int ssam_cdev_notifier_unregister(struct ssam_cdev_client *client, u8 tc)\n{\n\tconst u16 rqid = ssh_tc_to_rqid(tc);\n\tconst u16 event = ssh_rqid_to_event(rqid);\n\tint status;\n\n\tlockdep_assert_held_read(&client->cdev->lock);\n\n\t \n\tif (!ssh_rqid_is_event(rqid))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&client->notifier_lock);\n\n\t \n\tif (!client->notifier[event]) {\n\t\tmutex_unlock(&client->notifier_lock);\n\t\treturn -ENOENT;\n\t}\n\n\t \n\tstatus = ssam_notifier_unregister(client->cdev->ctrl, &client->notifier[event]->nf);\n\tkfree(client->notifier[event]);\n\tclient->notifier[event] = NULL;\n\n\tmutex_unlock(&client->notifier_lock);\n\treturn status;\n}\n\nstatic void ssam_cdev_notifier_unregister_all(struct ssam_cdev_client *client)\n{\n\tint i;\n\n\tdown_read(&client->cdev->lock);\n\n\t \n\tif (client->cdev->ctrl) {\n\t\tfor (i = 0; i < SSH_NUM_EVENTS; i++)\n\t\t\tssam_cdev_notifier_unregister(client, i + 1);\n\n\t} else {\n\t\tint count = 0;\n\n\t\t \n\t\tmutex_lock(&client->notifier_lock);\n\t\tfor (i = 0; i < SSH_NUM_EVENTS; i++) {\n\t\t\tcount += !!(client->notifier[i]);\n\t\t\tkfree(client->notifier[i]);\n\t\t\tclient->notifier[i] = NULL;\n\t\t}\n\t\tmutex_unlock(&client->notifier_lock);\n\n\t\tWARN_ON(count > 0);\n\t}\n\n\tup_read(&client->cdev->lock);\n}\n\n\n \n\nstatic long ssam_cdev_request(struct ssam_cdev_client *client, struct ssam_cdev_request __user *r)\n{\n\tstruct ssam_cdev_request rqst;\n\tstruct ssam_request spec = {};\n\tstruct ssam_response rsp = {};\n\tconst void __user *plddata;\n\tvoid __user *rspdata;\n\tint status = 0, ret = 0, tmp;\n\n\tlockdep_assert_held_read(&client->cdev->lock);\n\n\tret = copy_struct_from_user(&rqst, sizeof(rqst), r, sizeof(*r));\n\tif (ret)\n\t\tgoto out;\n\n\tplddata = u64_to_user_ptr(rqst.payload.data);\n\trspdata = u64_to_user_ptr(rqst.response.data);\n\n\t \n\tspec.target_category = rqst.target_category;\n\tspec.target_id = rqst.target_id;\n\tspec.command_id = rqst.command_id;\n\tspec.instance_id = rqst.instance_id;\n\tspec.flags = 0;\n\tspec.length = rqst.payload.length;\n\tspec.payload = NULL;\n\n\tif (rqst.flags & SSAM_CDEV_REQUEST_HAS_RESPONSE)\n\t\tspec.flags |= SSAM_REQUEST_HAS_RESPONSE;\n\n\tif (rqst.flags & SSAM_CDEV_REQUEST_UNSEQUENCED)\n\t\tspec.flags |= SSAM_REQUEST_UNSEQUENCED;\n\n\trsp.capacity = rqst.response.length;\n\trsp.length = 0;\n\trsp.pointer = NULL;\n\n\t \n\tif (spec.length) {\n\t\tif (!plddata) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tspec.payload = kzalloc(spec.length, GFP_KERNEL);\n\t\tif (!spec.payload) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (copy_from_user((void *)spec.payload, plddata, spec.length)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tif (rsp.capacity) {\n\t\tif (!rspdata) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\trsp.pointer = kzalloc(rsp.capacity, GFP_KERNEL);\n\t\tif (!rsp.pointer) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tstatus = ssam_request_do_sync(client->cdev->ctrl, &spec, &rsp);\n\tif (status)\n\t\tgoto out;\n\n\t \n\tif (rsp.length && copy_to_user(rspdata, rsp.pointer, rsp.length))\n\t\tret = -EFAULT;\n\nout:\n\t \n\ttmp = put_user(rsp.length, &r->response.length);\n\tif (tmp)\n\t\tret = tmp;\n\n\ttmp = put_user(status, &r->status);\n\tif (tmp)\n\t\tret = tmp;\n\n\t \n\tkfree(spec.payload);\n\tkfree(rsp.pointer);\n\n\treturn ret;\n}\n\nstatic long ssam_cdev_notif_register(struct ssam_cdev_client *client,\n\t\t\t\t     const struct ssam_cdev_notifier_desc __user *d)\n{\n\tstruct ssam_cdev_notifier_desc desc;\n\tlong ret;\n\n\tlockdep_assert_held_read(&client->cdev->lock);\n\n\tret = copy_struct_from_user(&desc, sizeof(desc), d, sizeof(*d));\n\tif (ret)\n\t\treturn ret;\n\n\treturn ssam_cdev_notifier_register(client, desc.target_category, desc.priority);\n}\n\nstatic long ssam_cdev_notif_unregister(struct ssam_cdev_client *client,\n\t\t\t\t       const struct ssam_cdev_notifier_desc __user *d)\n{\n\tstruct ssam_cdev_notifier_desc desc;\n\tlong ret;\n\n\tlockdep_assert_held_read(&client->cdev->lock);\n\n\tret = copy_struct_from_user(&desc, sizeof(desc), d, sizeof(*d));\n\tif (ret)\n\t\treturn ret;\n\n\treturn ssam_cdev_notifier_unregister(client, desc.target_category);\n}\n\nstatic long ssam_cdev_event_enable(struct ssam_cdev_client *client,\n\t\t\t\t   const struct ssam_cdev_event_desc __user *d)\n{\n\tstruct ssam_cdev_event_desc desc;\n\tstruct ssam_event_registry reg;\n\tstruct ssam_event_id id;\n\tlong ret;\n\n\tlockdep_assert_held_read(&client->cdev->lock);\n\n\t \n\tret = copy_struct_from_user(&desc, sizeof(desc), d, sizeof(*d));\n\tif (ret)\n\t\treturn ret;\n\n\t \n\treg.target_category = desc.reg.target_category;\n\treg.target_id = desc.reg.target_id;\n\treg.cid_enable = desc.reg.cid_enable;\n\treg.cid_disable = desc.reg.cid_disable;\n\n\tid.target_category = desc.id.target_category;\n\tid.instance = desc.id.instance;\n\n\t \n\treturn ssam_controller_event_enable(client->cdev->ctrl, reg, id, desc.flags);\n}\n\nstatic long ssam_cdev_event_disable(struct ssam_cdev_client *client,\n\t\t\t\t    const struct ssam_cdev_event_desc __user *d)\n{\n\tstruct ssam_cdev_event_desc desc;\n\tstruct ssam_event_registry reg;\n\tstruct ssam_event_id id;\n\tlong ret;\n\n\tlockdep_assert_held_read(&client->cdev->lock);\n\n\t \n\tret = copy_struct_from_user(&desc, sizeof(desc), d, sizeof(*d));\n\tif (ret)\n\t\treturn ret;\n\n\t \n\treg.target_category = desc.reg.target_category;\n\treg.target_id = desc.reg.target_id;\n\treg.cid_enable = desc.reg.cid_enable;\n\treg.cid_disable = desc.reg.cid_disable;\n\n\tid.target_category = desc.id.target_category;\n\tid.instance = desc.id.instance;\n\n\t \n\treturn ssam_controller_event_disable(client->cdev->ctrl, reg, id, desc.flags);\n}\n\n\n \n\nstatic int ssam_cdev_device_open(struct inode *inode, struct file *filp)\n{\n\tstruct miscdevice *mdev = filp->private_data;\n\tstruct ssam_cdev_client *client;\n\tstruct ssam_cdev *cdev = container_of(mdev, struct ssam_cdev, mdev);\n\n\t \n\tclient = vzalloc(sizeof(*client));\n\tif (!client)\n\t\treturn -ENOMEM;\n\n\tclient->cdev = ssam_cdev_get(cdev);\n\n\tINIT_LIST_HEAD(&client->node);\n\n\tmutex_init(&client->notifier_lock);\n\n\tmutex_init(&client->read_lock);\n\tmutex_init(&client->write_lock);\n\tINIT_KFIFO(client->buffer);\n\tinit_waitqueue_head(&client->waitq);\n\n\tfilp->private_data = client;\n\n\t \n\tdown_write(&cdev->client_lock);\n\n\tif (test_bit(SSAM_CDEV_DEVICE_SHUTDOWN_BIT, &cdev->flags)) {\n\t\tup_write(&cdev->client_lock);\n\t\tmutex_destroy(&client->write_lock);\n\t\tmutex_destroy(&client->read_lock);\n\t\tmutex_destroy(&client->notifier_lock);\n\t\tssam_cdev_put(client->cdev);\n\t\tvfree(client);\n\t\treturn -ENODEV;\n\t}\n\tlist_add_tail(&client->node, &cdev->client_list);\n\n\tup_write(&cdev->client_lock);\n\n\tstream_open(inode, filp);\n\treturn 0;\n}\n\nstatic int ssam_cdev_device_release(struct inode *inode, struct file *filp)\n{\n\tstruct ssam_cdev_client *client = filp->private_data;\n\n\t \n\tssam_cdev_notifier_unregister_all(client);\n\n\t \n\tdown_write(&client->cdev->client_lock);\n\tlist_del(&client->node);\n\tup_write(&client->cdev->client_lock);\n\n\t \n\tmutex_destroy(&client->write_lock);\n\tmutex_destroy(&client->read_lock);\n\n\tmutex_destroy(&client->notifier_lock);\n\n\tssam_cdev_put(client->cdev);\n\tvfree(client);\n\n\treturn 0;\n}\n\nstatic long __ssam_cdev_device_ioctl(struct ssam_cdev_client *client, unsigned int cmd,\n\t\t\t\t     unsigned long arg)\n{\n\tlockdep_assert_held_read(&client->cdev->lock);\n\n\tswitch (cmd) {\n\tcase SSAM_CDEV_REQUEST:\n\t\treturn ssam_cdev_request(client, (struct ssam_cdev_request __user *)arg);\n\n\tcase SSAM_CDEV_NOTIF_REGISTER:\n\t\treturn ssam_cdev_notif_register(client,\n\t\t\t\t\t\t(struct ssam_cdev_notifier_desc __user *)arg);\n\n\tcase SSAM_CDEV_NOTIF_UNREGISTER:\n\t\treturn ssam_cdev_notif_unregister(client,\n\t\t\t\t\t\t  (struct ssam_cdev_notifier_desc __user *)arg);\n\n\tcase SSAM_CDEV_EVENT_ENABLE:\n\t\treturn ssam_cdev_event_enable(client, (struct ssam_cdev_event_desc __user *)arg);\n\n\tcase SSAM_CDEV_EVENT_DISABLE:\n\t\treturn ssam_cdev_event_disable(client, (struct ssam_cdev_event_desc __user *)arg);\n\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n}\n\nstatic long ssam_cdev_device_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tstruct ssam_cdev_client *client = file->private_data;\n\tlong status;\n\n\t \n\tif (down_read_killable(&client->cdev->lock))\n\t\treturn -ERESTARTSYS;\n\n\tif (test_bit(SSAM_CDEV_DEVICE_SHUTDOWN_BIT, &client->cdev->flags)) {\n\t\tup_read(&client->cdev->lock);\n\t\treturn -ENODEV;\n\t}\n\n\tstatus = __ssam_cdev_device_ioctl(client, cmd, arg);\n\n\tup_read(&client->cdev->lock);\n\treturn status;\n}\n\nstatic ssize_t ssam_cdev_read(struct file *file, char __user *buf, size_t count, loff_t *offs)\n{\n\tstruct ssam_cdev_client *client = file->private_data;\n\tstruct ssam_cdev *cdev = client->cdev;\n\tunsigned int copied;\n\tint status = 0;\n\n\tif (down_read_killable(&cdev->lock))\n\t\treturn -ERESTARTSYS;\n\n\t \n\tif (test_bit(SSAM_CDEV_DEVICE_SHUTDOWN_BIT, &cdev->flags)) {\n\t\tup_read(&cdev->lock);\n\t\treturn -ENODEV;\n\t}\n\n\tdo {\n\t\t \n\t\tif (kfifo_is_empty(&client->buffer)) {\n\t\t\tup_read(&cdev->lock);\n\n\t\t\tif (file->f_flags & O_NONBLOCK)\n\t\t\t\treturn -EAGAIN;\n\n\t\t\tstatus = wait_event_interruptible(client->waitq,\n\t\t\t\t\t\t\t  !kfifo_is_empty(&client->buffer) ||\n\t\t\t\t\t\t\t  test_bit(SSAM_CDEV_DEVICE_SHUTDOWN_BIT,\n\t\t\t\t\t\t\t\t   &cdev->flags));\n\t\t\tif (status < 0)\n\t\t\t\treturn status;\n\n\t\t\tif (down_read_killable(&cdev->lock))\n\t\t\t\treturn -ERESTARTSYS;\n\n\t\t\t \n\t\t\tif (test_bit(SSAM_CDEV_DEVICE_SHUTDOWN_BIT, &cdev->flags)) {\n\t\t\t\tup_read(&cdev->lock);\n\t\t\t\treturn -ENODEV;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (mutex_lock_interruptible(&client->read_lock)) {\n\t\t\tup_read(&cdev->lock);\n\t\t\treturn -ERESTARTSYS;\n\t\t}\n\n\t\tstatus = kfifo_to_user(&client->buffer, buf, count, &copied);\n\t\tmutex_unlock(&client->read_lock);\n\n\t\tif (status < 0) {\n\t\t\tup_read(&cdev->lock);\n\t\t\treturn status;\n\t\t}\n\n\t\t \n\t\tif (copied == 0 && (file->f_flags & O_NONBLOCK)) {\n\t\t\tup_read(&cdev->lock);\n\t\t\treturn -EAGAIN;\n\t\t}\n\t} while (copied == 0);\n\n\tup_read(&cdev->lock);\n\treturn copied;\n}\n\nstatic __poll_t ssam_cdev_poll(struct file *file, struct poll_table_struct *pt)\n{\n\tstruct ssam_cdev_client *client = file->private_data;\n\t__poll_t events = 0;\n\n\tif (test_bit(SSAM_CDEV_DEVICE_SHUTDOWN_BIT, &client->cdev->flags))\n\t\treturn EPOLLHUP | EPOLLERR;\n\n\tpoll_wait(file, &client->waitq, pt);\n\n\tif (!kfifo_is_empty(&client->buffer))\n\t\tevents |= EPOLLIN | EPOLLRDNORM;\n\n\treturn events;\n}\n\nstatic int ssam_cdev_fasync(int fd, struct file *file, int on)\n{\n\tstruct ssam_cdev_client *client = file->private_data;\n\n\treturn fasync_helper(fd, file, on, &client->fasync);\n}\n\nstatic const struct file_operations ssam_controller_fops = {\n\t.owner          = THIS_MODULE,\n\t.open           = ssam_cdev_device_open,\n\t.release        = ssam_cdev_device_release,\n\t.read           = ssam_cdev_read,\n\t.poll           = ssam_cdev_poll,\n\t.fasync         = ssam_cdev_fasync,\n\t.unlocked_ioctl = ssam_cdev_device_ioctl,\n\t.compat_ioctl   = ssam_cdev_device_ioctl,\n\t.llseek         = no_llseek,\n};\n\n\n \n\nstatic int ssam_dbg_device_probe(struct platform_device *pdev)\n{\n\tstruct ssam_controller *ctrl;\n\tstruct ssam_cdev *cdev;\n\tint status;\n\n\tctrl = ssam_client_bind(&pdev->dev);\n\tif (IS_ERR(ctrl))\n\t\treturn PTR_ERR(ctrl) == -ENODEV ? -EPROBE_DEFER : PTR_ERR(ctrl);\n\n\tcdev = kzalloc(sizeof(*cdev), GFP_KERNEL);\n\tif (!cdev)\n\t\treturn -ENOMEM;\n\n\tkref_init(&cdev->kref);\n\tinit_rwsem(&cdev->lock);\n\tcdev->ctrl = ctrl;\n\tcdev->dev = &pdev->dev;\n\n\tcdev->mdev.parent   = &pdev->dev;\n\tcdev->mdev.minor    = MISC_DYNAMIC_MINOR;\n\tcdev->mdev.name     = \"surface_aggregator\";\n\tcdev->mdev.nodename = \"surface/aggregator\";\n\tcdev->mdev.fops     = &ssam_controller_fops;\n\n\tinit_rwsem(&cdev->client_lock);\n\tINIT_LIST_HEAD(&cdev->client_list);\n\n\tstatus = misc_register(&cdev->mdev);\n\tif (status) {\n\t\tkfree(cdev);\n\t\treturn status;\n\t}\n\n\tplatform_set_drvdata(pdev, cdev);\n\treturn 0;\n}\n\nstatic int ssam_dbg_device_remove(struct platform_device *pdev)\n{\n\tstruct ssam_cdev *cdev = platform_get_drvdata(pdev);\n\tstruct ssam_cdev_client *client;\n\n\t \n\tset_bit(SSAM_CDEV_DEVICE_SHUTDOWN_BIT, &cdev->flags);\n\n\tdown_write(&cdev->client_lock);\n\n\t \n\tlist_for_each_entry(client, &cdev->client_list, node) {\n\t\tssam_cdev_notifier_unregister_all(client);\n\t}\n\n\t \n\tlist_for_each_entry(client, &cdev->client_list, node) {\n\t\tkill_fasync(&client->fasync, SIGIO, POLL_HUP);\n\t}\n\n\t \n\tlist_for_each_entry(client, &cdev->client_list, node) {\n\t\twake_up_interruptible(&client->waitq);\n\t}\n\n\tup_write(&cdev->client_lock);\n\n\t \n\tdown_write(&cdev->lock);\n\tcdev->ctrl = NULL;\n\tcdev->dev = NULL;\n\tup_write(&cdev->lock);\n\n\tmisc_deregister(&cdev->mdev);\n\n\tssam_cdev_put(cdev);\n\treturn 0;\n}\n\nstatic struct platform_device *ssam_cdev_device;\n\nstatic struct platform_driver ssam_cdev_driver = {\n\t.probe = ssam_dbg_device_probe,\n\t.remove = ssam_dbg_device_remove,\n\t.driver = {\n\t\t.name = SSAM_CDEV_DEVICE_NAME,\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t},\n};\n\nstatic int __init ssam_debug_init(void)\n{\n\tint status;\n\n\tssam_cdev_device = platform_device_alloc(SSAM_CDEV_DEVICE_NAME,\n\t\t\t\t\t\t PLATFORM_DEVID_NONE);\n\tif (!ssam_cdev_device)\n\t\treturn -ENOMEM;\n\n\tstatus = platform_device_add(ssam_cdev_device);\n\tif (status)\n\t\tgoto err_device;\n\n\tstatus = platform_driver_register(&ssam_cdev_driver);\n\tif (status)\n\t\tgoto err_driver;\n\n\treturn 0;\n\nerr_driver:\n\tplatform_device_del(ssam_cdev_device);\nerr_device:\n\tplatform_device_put(ssam_cdev_device);\n\treturn status;\n}\nmodule_init(ssam_debug_init);\n\nstatic void __exit ssam_debug_exit(void)\n{\n\tplatform_driver_unregister(&ssam_cdev_driver);\n\tplatform_device_unregister(ssam_cdev_device);\n}\nmodule_exit(ssam_debug_exit);\n\nMODULE_AUTHOR(\"Maximilian Luz <luzmaximilian@gmail.com>\");\nMODULE_DESCRIPTION(\"User-space interface for Surface System Aggregator Module\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}