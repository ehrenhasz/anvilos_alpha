{
  "module_name": "surface_hotplug.c",
  "hash_id": "51b4d7ddf6d145d06a2656e672902ffec4ac4f92b46904029e0d537356c858ee",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/surface/surface_hotplug.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/gpio.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/platform_device.h>\n\nstatic const struct acpi_gpio_params shps_base_presence_int   = { 0, 0, false };\nstatic const struct acpi_gpio_params shps_base_presence       = { 1, 0, false };\nstatic const struct acpi_gpio_params shps_device_power_int    = { 2, 0, false };\nstatic const struct acpi_gpio_params shps_device_power        = { 3, 0, false };\nstatic const struct acpi_gpio_params shps_device_presence_int = { 4, 0, false };\nstatic const struct acpi_gpio_params shps_device_presence     = { 5, 0, false };\n\nstatic const struct acpi_gpio_mapping shps_acpi_gpios[] = {\n\t{ \"base_presence-int-gpio\",   &shps_base_presence_int,   1 },\n\t{ \"base_presence-gpio\",       &shps_base_presence,       1 },\n\t{ \"device_power-int-gpio\",    &shps_device_power_int,    1 },\n\t{ \"device_power-gpio\",        &shps_device_power,        1 },\n\t{ \"device_presence-int-gpio\", &shps_device_presence_int, 1 },\n\t{ \"device_presence-gpio\",     &shps_device_presence,     1 },\n\t{ },\n};\n\n \nstatic const guid_t shps_dsm_guid =\n\tGUID_INIT(0x5515a847, 0xed55, 0x4b27, 0x83, 0x52, 0xcd, 0x32, 0x0e, 0x10, 0x36, 0x0a);\n\n#define SHPS_DSM_REVISION\t\t1\n\nenum shps_dsm_fn {\n\tSHPS_DSM_FN_PCI_NUM_ENTRIES\t= 0x01,\n\tSHPS_DSM_FN_PCI_GET_ENTRIES\t= 0x02,\n\tSHPS_DSM_FN_IRQ_BASE_PRESENCE\t= 0x03,\n\tSHPS_DSM_FN_IRQ_DEVICE_POWER\t= 0x04,\n\tSHPS_DSM_FN_IRQ_DEVICE_PRESENCE\t= 0x05,\n};\n\nenum shps_irq_type {\n\t \n\tSHPS_IRQ_TYPE_BASE_PRESENCE\t= 0,\n\tSHPS_IRQ_TYPE_DEVICE_POWER\t= 1,\n\tSHPS_IRQ_TYPE_DEVICE_PRESENCE\t= 2,\n\tSHPS_NUM_IRQS,\n};\n\nstatic const char *const shps_gpio_names[] = {\n\t[SHPS_IRQ_TYPE_BASE_PRESENCE]\t= \"base_presence\",\n\t[SHPS_IRQ_TYPE_DEVICE_POWER]\t= \"device_power\",\n\t[SHPS_IRQ_TYPE_DEVICE_PRESENCE]\t= \"device_presence\",\n};\n\nstruct shps_device {\n\tstruct mutex lock[SHPS_NUM_IRQS];   \n\tstruct gpio_desc *gpio[SHPS_NUM_IRQS];\n\tunsigned int irq[SHPS_NUM_IRQS];\n};\n\n#define SHPS_IRQ_NOT_PRESENT\t\t((unsigned int)-1)\n\nstatic enum shps_dsm_fn shps_dsm_fn_for_irq(enum shps_irq_type type)\n{\n\treturn SHPS_DSM_FN_IRQ_BASE_PRESENCE + type;\n}\n\nstatic void shps_dsm_notify_irq(struct platform_device *pdev, enum shps_irq_type type)\n{\n\tstruct shps_device *sdev = platform_get_drvdata(pdev);\n\tacpi_handle handle = ACPI_HANDLE(&pdev->dev);\n\tunion acpi_object *result;\n\tunion acpi_object param;\n\tint value;\n\n\tmutex_lock(&sdev->lock[type]);\n\n\tvalue = gpiod_get_value_cansleep(sdev->gpio[type]);\n\tif (value < 0) {\n\t\tmutex_unlock(&sdev->lock[type]);\n\t\tdev_err(&pdev->dev, \"failed to get gpio: %d (irq=%d)\\n\", type, value);\n\t\treturn;\n\t}\n\n\tdev_dbg(&pdev->dev, \"IRQ notification via DSM (irq=%d, value=%d)\\n\", type, value);\n\n\tparam.type = ACPI_TYPE_INTEGER;\n\tparam.integer.value = value;\n\n\tresult = acpi_evaluate_dsm_typed(handle, &shps_dsm_guid, SHPS_DSM_REVISION,\n\t\t\t\t\t shps_dsm_fn_for_irq(type), &param, ACPI_TYPE_BUFFER);\n\tif (!result) {\n\t\tdev_err(&pdev->dev, \"IRQ notification via DSM failed (irq=%d, gpio=%d)\\n\",\n\t\t\ttype, value);\n\n\t} else if (result->buffer.length != 1 || result->buffer.pointer[0] != 0) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"IRQ notification via DSM failed: unexpected result value (irq=%d, gpio=%d)\\n\",\n\t\t\ttype, value);\n\t}\n\n\tmutex_unlock(&sdev->lock[type]);\n\n\tACPI_FREE(result);\n}\n\nstatic irqreturn_t shps_handle_irq(int irq, void *data)\n{\n\tstruct platform_device *pdev = data;\n\tstruct shps_device *sdev = platform_get_drvdata(pdev);\n\tint type;\n\n\t \n\tfor (type = 0; type < SHPS_NUM_IRQS; type++)\n\t\tif (irq == sdev->irq[type])\n\t\t\tbreak;\n\n\t \n\tif (WARN(type >= SHPS_NUM_IRQS, \"invalid IRQ number: %d\\n\", irq))\n\t\treturn IRQ_HANDLED;\n\n\t \n\tshps_dsm_notify_irq(pdev, type);\n\treturn IRQ_HANDLED;\n}\n\nstatic int shps_setup_irq(struct platform_device *pdev, enum shps_irq_type type)\n{\n\tunsigned long flags = IRQF_ONESHOT | IRQF_TRIGGER_FALLING | IRQF_TRIGGER_RISING;\n\tstruct shps_device *sdev = platform_get_drvdata(pdev);\n\tstruct gpio_desc *gpiod;\n\tacpi_handle handle = ACPI_HANDLE(&pdev->dev);\n\tconst char *irq_name;\n\tconst int dsm = shps_dsm_fn_for_irq(type);\n\tint status, irq;\n\n\t \n\tif (!acpi_check_dsm(handle, &shps_dsm_guid, SHPS_DSM_REVISION, BIT(dsm))) {\n\t\tdev_dbg(&pdev->dev, \"IRQ notification via DSM not present (irq=%d)\\n\", type);\n\t\treturn 0;\n\t}\n\n\tgpiod = devm_gpiod_get(&pdev->dev, shps_gpio_names[type], GPIOD_ASIS);\n\tif (IS_ERR(gpiod))\n\t\treturn PTR_ERR(gpiod);\n\n\tirq = gpiod_to_irq(gpiod);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tirq_name = devm_kasprintf(&pdev->dev, GFP_KERNEL, \"shps-irq-%d\", type);\n\tif (!irq_name)\n\t\treturn -ENOMEM;\n\n\tstatus = devm_request_threaded_irq(&pdev->dev, irq, NULL, shps_handle_irq,\n\t\t\t\t\t   flags, irq_name, pdev);\n\tif (status)\n\t\treturn status;\n\n\tdev_dbg(&pdev->dev, \"set up irq %d as type %d\\n\", irq, type);\n\n\tsdev->gpio[type] = gpiod;\n\tsdev->irq[type] = irq;\n\n\treturn 0;\n}\n\nstatic int surface_hotplug_remove(struct platform_device *pdev)\n{\n\tstruct shps_device *sdev = platform_get_drvdata(pdev);\n\tint i;\n\n\t \n\tfor (i = 0; i < SHPS_NUM_IRQS; i++) {\n\t\tif (sdev->irq[i] != SHPS_IRQ_NOT_PRESENT)\n\t\t\tdisable_irq(sdev->irq[i]);\n\n\t\tmutex_destroy(&sdev->lock[i]);\n\t}\n\n\treturn 0;\n}\n\nstatic int surface_hotplug_probe(struct platform_device *pdev)\n{\n\tstruct shps_device *sdev;\n\tint status, i;\n\n\t \n\tif (gpiod_count(&pdev->dev, NULL) < 0)\n\t\treturn -ENODEV;\n\n\tstatus = devm_acpi_dev_add_driver_gpios(&pdev->dev, shps_acpi_gpios);\n\tif (status)\n\t\treturn status;\n\n\tsdev = devm_kzalloc(&pdev->dev, sizeof(*sdev), GFP_KERNEL);\n\tif (!sdev)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, sdev);\n\n\t \n\tfor (i = 0; i < SHPS_NUM_IRQS; i++)\n\t\tsdev->irq[i] = SHPS_IRQ_NOT_PRESENT;\n\n\t \n\tfor (i = 0; i < SHPS_NUM_IRQS; i++) {\n\t\tmutex_init(&sdev->lock[i]);\n\n\t\tstatus = shps_setup_irq(pdev, i);\n\t\tif (status) {\n\t\t\tdev_err(&pdev->dev, \"failed to set up IRQ %d: %d\\n\", i, status);\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < SHPS_NUM_IRQS; i++)\n\t\tif (sdev->irq[i] != SHPS_IRQ_NOT_PRESENT)\n\t\t\tshps_dsm_notify_irq(pdev, i);\n\n\treturn 0;\n\nerr:\n\tsurface_hotplug_remove(pdev);\n\treturn status;\n}\n\nstatic const struct acpi_device_id surface_hotplug_acpi_match[] = {\n\t{ \"MSHW0153\", 0 },\n\t{ },\n};\nMODULE_DEVICE_TABLE(acpi, surface_hotplug_acpi_match);\n\nstatic struct platform_driver surface_hotplug_driver = {\n\t.probe = surface_hotplug_probe,\n\t.remove = surface_hotplug_remove,\n\t.driver = {\n\t\t.name = \"surface_hotplug\",\n\t\t.acpi_match_table = surface_hotplug_acpi_match,\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t},\n};\nmodule_platform_driver(surface_hotplug_driver);\n\nMODULE_AUTHOR(\"Maximilian Luz <luzmaximilian@gmail.com>\");\nMODULE_DESCRIPTION(\"Surface Hot-Plug Signaling Driver for Surface Book Devices\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}