{
  "module_name": "surface_acpi_notify.c",
  "hash_id": "96990b7a449e55540caa19e6e07320936544863f6ac098cb585eea26bc8f987e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/surface/surface_acpi_notify.c",
  "human_readable_source": "\n \n\n#include <asm/unaligned.h>\n#include <linux/acpi.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/notifier.h>\n#include <linux/platform_device.h>\n#include <linux/rwsem.h>\n\n#include <linux/surface_aggregator/controller.h>\n#include <linux/surface_acpi_notify.h>\n\nstruct san_data {\n\tstruct device *dev;\n\tstruct ssam_controller *ctrl;\n\n\tstruct acpi_connection_info info;\n\n\tstruct ssam_event_notifier nf_bat;\n\tstruct ssam_event_notifier nf_tmp;\n};\n\n#define to_san_data(ptr, member) \\\n\tcontainer_of(ptr, struct san_data, member)\n\nstatic struct workqueue_struct *san_wq;\n\n \n\nstruct san_rqsg_if {\n\tstruct rw_semaphore lock;\n\tstruct device *dev;\n\tstruct blocking_notifier_head nh;\n};\n\nstatic struct san_rqsg_if san_rqsg_if = {\n\t.lock = __RWSEM_INITIALIZER(san_rqsg_if.lock),\n\t.dev = NULL,\n\t.nh = BLOCKING_NOTIFIER_INIT(san_rqsg_if.nh),\n};\n\nstatic int san_set_rqsg_interface_device(struct device *dev)\n{\n\tint status = 0;\n\n\tdown_write(&san_rqsg_if.lock);\n\tif (!san_rqsg_if.dev && dev)\n\t\tsan_rqsg_if.dev = dev;\n\telse\n\t\tstatus = -EBUSY;\n\tup_write(&san_rqsg_if.lock);\n\n\treturn status;\n}\n\n \nint san_client_link(struct device *client)\n{\n\tconst u32 flags = DL_FLAG_PM_RUNTIME | DL_FLAG_AUTOREMOVE_CONSUMER;\n\tstruct device_link *link;\n\n\tdown_read(&san_rqsg_if.lock);\n\n\tif (!san_rqsg_if.dev) {\n\t\tup_read(&san_rqsg_if.lock);\n\t\treturn -ENXIO;\n\t}\n\n\tlink = device_link_add(client, san_rqsg_if.dev, flags);\n\tif (!link) {\n\t\tup_read(&san_rqsg_if.lock);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (READ_ONCE(link->status) == DL_STATE_SUPPLIER_UNBIND) {\n\t\tup_read(&san_rqsg_if.lock);\n\t\treturn -ENXIO;\n\t}\n\n\tup_read(&san_rqsg_if.lock);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(san_client_link);\n\n \nint san_dgpu_notifier_register(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_register(&san_rqsg_if.nh, nb);\n}\nEXPORT_SYMBOL_GPL(san_dgpu_notifier_register);\n\n \nint san_dgpu_notifier_unregister(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_unregister(&san_rqsg_if.nh, nb);\n}\nEXPORT_SYMBOL_GPL(san_dgpu_notifier_unregister);\n\nstatic int san_dgpu_notifier_call(struct san_dgpu_event *evt)\n{\n\tint ret;\n\n\tret = blocking_notifier_call_chain(&san_rqsg_if.nh, evt->command, evt);\n\treturn notifier_to_errno(ret);\n}\n\n\n \n\n#define SAN_DSM_REVISION\t0\n\n \nstatic const guid_t SAN_DSM_UUID =\n\tGUID_INIT(0x93b666c5, 0x70c6, 0x469f, 0xa2, 0x15, 0x3d,\n\t\t  0x48, 0x7c, 0x91, 0xab, 0x3c);\n\nenum san_dsm_event_fn {\n\tSAN_DSM_EVENT_FN_BAT1_STAT = 0x03,\n\tSAN_DSM_EVENT_FN_BAT1_INFO = 0x04,\n\tSAN_DSM_EVENT_FN_ADP1_STAT = 0x05,\n\tSAN_DSM_EVENT_FN_ADP1_INFO = 0x06,\n\tSAN_DSM_EVENT_FN_BAT2_STAT = 0x07,\n\tSAN_DSM_EVENT_FN_BAT2_INFO = 0x08,\n\tSAN_DSM_EVENT_FN_THERMAL   = 0x09,\n\tSAN_DSM_EVENT_FN_DPTF      = 0x0a,\n};\n\nenum sam_event_cid_bat {\n\tSAM_EVENT_CID_BAT_BIX  = 0x15,\n\tSAM_EVENT_CID_BAT_BST  = 0x16,\n\tSAM_EVENT_CID_BAT_ADP  = 0x17,\n\tSAM_EVENT_CID_BAT_PROT = 0x18,\n\tSAM_EVENT_CID_BAT_DPTF = 0x4f,\n};\n\nenum sam_event_cid_tmp {\n\tSAM_EVENT_CID_TMP_TRIP = 0x0b,\n};\n\nstruct san_event_work {\n\tstruct delayed_work work;\n\tstruct device *dev;\n\tstruct ssam_event event;\t \n};\n\nstatic int san_acpi_notify_event(struct device *dev, u64 func,\n\t\t\t\t union acpi_object *param)\n{\n\tacpi_handle san = ACPI_HANDLE(dev);\n\tunion acpi_object *obj;\n\tint status = 0;\n\n\tif (!acpi_check_dsm(san, &SAN_DSM_UUID, SAN_DSM_REVISION, BIT_ULL(func)))\n\t\treturn 0;\n\n\tdev_dbg(dev, \"notify event %#04llx\\n\", func);\n\n\tobj = acpi_evaluate_dsm_typed(san, &SAN_DSM_UUID, SAN_DSM_REVISION,\n\t\t\t\t      func, param, ACPI_TYPE_BUFFER);\n\tif (!obj)\n\t\treturn -EFAULT;\n\n\tif (obj->buffer.length != 1 || obj->buffer.pointer[0] != 0) {\n\t\tdev_err(dev, \"got unexpected result from _DSM\\n\");\n\t\tstatus = -EPROTO;\n\t}\n\n\tACPI_FREE(obj);\n\treturn status;\n}\n\nstatic int san_evt_bat_adp(struct device *dev, const struct ssam_event *event)\n{\n\tint status;\n\n\tstatus = san_acpi_notify_event(dev, SAN_DSM_EVENT_FN_ADP1_STAT, NULL);\n\tif (status)\n\t\treturn status;\n\n\t \n\n\tstatus = san_acpi_notify_event(dev, SAN_DSM_EVENT_FN_BAT1_STAT, NULL);\n\tif (status)\n\t\treturn status;\n\n\treturn san_acpi_notify_event(dev, SAN_DSM_EVENT_FN_BAT2_STAT, NULL);\n}\n\nstatic int san_evt_bat_bix(struct device *dev, const struct ssam_event *event)\n{\n\tenum san_dsm_event_fn fn;\n\n\tif (event->instance_id == 0x02)\n\t\tfn = SAN_DSM_EVENT_FN_BAT2_INFO;\n\telse\n\t\tfn = SAN_DSM_EVENT_FN_BAT1_INFO;\n\n\treturn san_acpi_notify_event(dev, fn, NULL);\n}\n\nstatic int san_evt_bat_bst(struct device *dev, const struct ssam_event *event)\n{\n\tenum san_dsm_event_fn fn;\n\n\tif (event->instance_id == 0x02)\n\t\tfn = SAN_DSM_EVENT_FN_BAT2_STAT;\n\telse\n\t\tfn = SAN_DSM_EVENT_FN_BAT1_STAT;\n\n\treturn san_acpi_notify_event(dev, fn, NULL);\n}\n\nstatic int san_evt_bat_dptf(struct device *dev, const struct ssam_event *event)\n{\n\tunion acpi_object payload;\n\n\t \n\tpayload.type = ACPI_TYPE_BUFFER;\n\tpayload.buffer.length = event->length;\n\tpayload.buffer.pointer = (u8 *)&event->data[0];\n\n\treturn san_acpi_notify_event(dev, SAN_DSM_EVENT_FN_DPTF, &payload);\n}\n\nstatic unsigned long san_evt_bat_delay(u8 cid)\n{\n\tswitch (cid) {\n\tcase SAM_EVENT_CID_BAT_ADP:\n\t\t \n\t\treturn msecs_to_jiffies(5000);\n\n\tcase SAM_EVENT_CID_BAT_BST:\n\t\t \n\t\treturn msecs_to_jiffies(2000);\n\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic bool san_evt_bat(const struct ssam_event *event, struct device *dev)\n{\n\tint status;\n\n\tswitch (event->command_id) {\n\tcase SAM_EVENT_CID_BAT_BIX:\n\t\tstatus = san_evt_bat_bix(dev, event);\n\t\tbreak;\n\n\tcase SAM_EVENT_CID_BAT_BST:\n\t\tstatus = san_evt_bat_bst(dev, event);\n\t\tbreak;\n\n\tcase SAM_EVENT_CID_BAT_ADP:\n\t\tstatus = san_evt_bat_adp(dev, event);\n\t\tbreak;\n\n\tcase SAM_EVENT_CID_BAT_PROT:\n\t\t \n\t\treturn true;\n\n\tcase SAM_EVENT_CID_BAT_DPTF:\n\t\tstatus = san_evt_bat_dptf(dev, event);\n\t\tbreak;\n\n\tdefault:\n\t\treturn false;\n\t}\n\n\tif (status) {\n\t\tdev_err(dev, \"error handling power event (cid = %#04x)\\n\",\n\t\t\tevent->command_id);\n\t}\n\n\treturn true;\n}\n\nstatic void san_evt_bat_workfn(struct work_struct *work)\n{\n\tstruct san_event_work *ev;\n\n\tev = container_of(work, struct san_event_work, work.work);\n\tsan_evt_bat(&ev->event, ev->dev);\n\tkfree(ev);\n}\n\nstatic u32 san_evt_bat_nf(struct ssam_event_notifier *nf,\n\t\t\t  const struct ssam_event *event)\n{\n\tstruct san_data *d = to_san_data(nf, nf_bat);\n\tstruct san_event_work *work;\n\tunsigned long delay = san_evt_bat_delay(event->command_id);\n\n\tif (delay == 0)\n\t\treturn san_evt_bat(event, d->dev) ? SSAM_NOTIF_HANDLED : 0;\n\n\twork = kzalloc(sizeof(*work) + event->length, GFP_KERNEL);\n\tif (!work)\n\t\treturn ssam_notifier_from_errno(-ENOMEM);\n\n\tINIT_DELAYED_WORK(&work->work, san_evt_bat_workfn);\n\twork->dev = d->dev;\n\n\twork->event = *event;\n\tmemcpy(work->event.data, event->data, event->length);\n\n\tqueue_delayed_work(san_wq, &work->work, delay);\n\treturn SSAM_NOTIF_HANDLED;\n}\n\nstatic int san_evt_tmp_trip(struct device *dev, const struct ssam_event *event)\n{\n\tunion acpi_object param;\n\n\t \n\tparam.type = ACPI_TYPE_INTEGER;\n\tparam.integer.value = event->instance_id;\n\n\treturn san_acpi_notify_event(dev, SAN_DSM_EVENT_FN_THERMAL, &param);\n}\n\nstatic bool san_evt_tmp(const struct ssam_event *event, struct device *dev)\n{\n\tint status;\n\n\tswitch (event->command_id) {\n\tcase SAM_EVENT_CID_TMP_TRIP:\n\t\tstatus = san_evt_tmp_trip(dev, event);\n\t\tbreak;\n\n\tdefault:\n\t\treturn false;\n\t}\n\n\tif (status) {\n\t\tdev_err(dev, \"error handling thermal event (cid = %#04x)\\n\",\n\t\t\tevent->command_id);\n\t}\n\n\treturn true;\n}\n\nstatic u32 san_evt_tmp_nf(struct ssam_event_notifier *nf,\n\t\t\t  const struct ssam_event *event)\n{\n\tstruct san_data *d = to_san_data(nf, nf_tmp);\n\n\treturn san_evt_tmp(event, d->dev) ? SSAM_NOTIF_HANDLED : 0;\n}\n\n\n \n\nstruct gsb_data_in {\n\tu8 cv;\n} __packed;\n\nstruct gsb_data_rqsx {\n\tu8 cv;\t\t\t\t \n\tu8 tc;\t\t\t\t \n\tu8 tid;\t\t\t\t \n\tu8 iid;\t\t\t\t \n\tu8 snc;\t\t\t\t \n\tu8 cid;\t\t\t\t \n\tu16 cdl;\t\t\t \n\tu8 pld[];\t\t\t \n} __packed;\n\nstruct gsb_data_etwl {\n\tu8 cv;\t\t\t\t \n\tu8 etw3;\t\t\t \n\tu8 etw4;\t\t\t \n\tu8 msg[];\t\t\t \n} __packed;\n\nstruct gsb_data_out {\n\tu8 status;\t\t\t \n\tu8 len;\t\t\t\t \n\tu8 pld[];\t\t\t \n} __packed;\n\nunion gsb_buffer_data {\n\tstruct gsb_data_in   in;\t \n\tstruct gsb_data_rqsx rqsx;\t \n\tstruct gsb_data_etwl etwl;\t \n\tstruct gsb_data_out  out;\t \n};\n\nstruct gsb_buffer {\n\tu8 status;\t\t\t \n\tu8 len;\t\t\t\t \n\tunion gsb_buffer_data data;\n} __packed;\n\n#define SAN_GSB_MAX_RQSX_PAYLOAD  (U8_MAX - 2 - sizeof(struct gsb_data_rqsx))\n#define SAN_GSB_MAX_RESPONSE\t  (U8_MAX - 2 - sizeof(struct gsb_data_out))\n\n#define SAN_GSB_COMMAND\t\t0\n\nenum san_gsb_request_cv {\n\tSAN_GSB_REQUEST_CV_RQST = 0x01,\n\tSAN_GSB_REQUEST_CV_ETWL = 0x02,\n\tSAN_GSB_REQUEST_CV_RQSG = 0x03,\n};\n\n#define SAN_REQUEST_NUM_TRIES\t5\n\nstatic acpi_status san_etwl(struct san_data *d, struct gsb_buffer *b)\n{\n\tstruct gsb_data_etwl *etwl = &b->data.etwl;\n\n\tif (b->len < sizeof(struct gsb_data_etwl)) {\n\t\tdev_err(d->dev, \"invalid ETWL package (len = %d)\\n\", b->len);\n\t\treturn AE_OK;\n\t}\n\n\tdev_err(d->dev, \"ETWL(%#04x, %#04x): %.*s\\n\", etwl->etw3, etwl->etw4,\n\t\t(unsigned int)(b->len - sizeof(struct gsb_data_etwl)),\n\t\t(char *)etwl->msg);\n\n\t \n\tb->status = 0x00;\n\tb->len = 0x00;\n\n\treturn AE_OK;\n}\n\nstatic\nstruct gsb_data_rqsx *san_validate_rqsx(struct device *dev, const char *type,\n\t\t\t\t\tstruct gsb_buffer *b)\n{\n\tstruct gsb_data_rqsx *rqsx = &b->data.rqsx;\n\n\tif (b->len < sizeof(struct gsb_data_rqsx)) {\n\t\tdev_err(dev, \"invalid %s package (len = %d)\\n\", type, b->len);\n\t\treturn NULL;\n\t}\n\n\tif (get_unaligned(&rqsx->cdl) != b->len - sizeof(struct gsb_data_rqsx)) {\n\t\tdev_err(dev, \"bogus %s package (len = %d, cdl = %d)\\n\",\n\t\t\ttype, b->len, get_unaligned(&rqsx->cdl));\n\t\treturn NULL;\n\t}\n\n\tif (get_unaligned(&rqsx->cdl) > SAN_GSB_MAX_RQSX_PAYLOAD) {\n\t\tdev_err(dev, \"payload for %s package too large (cdl = %d)\\n\",\n\t\t\ttype, get_unaligned(&rqsx->cdl));\n\t\treturn NULL;\n\t}\n\n\treturn rqsx;\n}\n\nstatic void gsb_rqsx_response_error(struct gsb_buffer *gsb, int status)\n{\n\tgsb->status = 0x00;\n\tgsb->len = 0x02;\n\tgsb->data.out.status = (u8)(-status);\n\tgsb->data.out.len = 0x00;\n}\n\nstatic void gsb_rqsx_response_success(struct gsb_buffer *gsb, u8 *ptr, size_t len)\n{\n\tgsb->status = 0x00;\n\tgsb->len = len + 2;\n\tgsb->data.out.status = 0x00;\n\tgsb->data.out.len = len;\n\n\tif (len)\n\t\tmemcpy(&gsb->data.out.pld[0], ptr, len);\n}\n\nstatic acpi_status san_rqst_fixup_suspended(struct san_data *d,\n\t\t\t\t\t    struct ssam_request *rqst,\n\t\t\t\t\t    struct gsb_buffer *gsb)\n{\n\tif (rqst->target_category == SSAM_SSH_TC_BAS && rqst->command_id == 0x0D) {\n\t\tu8 base_state = 1;\n\n\t\t \n\n\t\tdev_dbg(d->dev, \"rqst: fixup: base-state quirk\\n\");\n\n\t\tgsb_rqsx_response_success(gsb, &base_state, sizeof(base_state));\n\t\treturn AE_OK;\n\t}\n\n\tgsb_rqsx_response_error(gsb, -ENXIO);\n\treturn AE_OK;\n}\n\nstatic acpi_status san_rqst(struct san_data *d, struct gsb_buffer *buffer)\n{\n\tu8 rspbuf[SAN_GSB_MAX_RESPONSE];\n\tstruct gsb_data_rqsx *gsb_rqst;\n\tstruct ssam_request rqst;\n\tstruct ssam_response rsp;\n\tint status = 0;\n\n\tgsb_rqst = san_validate_rqsx(d->dev, \"RQST\", buffer);\n\tif (!gsb_rqst)\n\t\treturn AE_OK;\n\n\trqst.target_category = gsb_rqst->tc;\n\trqst.target_id = gsb_rqst->tid;\n\trqst.command_id = gsb_rqst->cid;\n\trqst.instance_id = gsb_rqst->iid;\n\trqst.flags = gsb_rqst->snc ? SSAM_REQUEST_HAS_RESPONSE : 0;\n\trqst.length = get_unaligned(&gsb_rqst->cdl);\n\trqst.payload = &gsb_rqst->pld[0];\n\n\trsp.capacity = ARRAY_SIZE(rspbuf);\n\trsp.length = 0;\n\trsp.pointer = &rspbuf[0];\n\n\t \n\tif (d->dev->power.is_suspended) {\n\t\tdev_warn(d->dev, \"rqst: device is suspended, not executing\\n\");\n\t\treturn san_rqst_fixup_suspended(d, &rqst, buffer);\n\t}\n\n\tstatus = __ssam_retry(ssam_request_do_sync_onstack, SAN_REQUEST_NUM_TRIES,\n\t\t\t      d->ctrl, &rqst, &rsp, SAN_GSB_MAX_RQSX_PAYLOAD);\n\n\tif (!status) {\n\t\tgsb_rqsx_response_success(buffer, rsp.pointer, rsp.length);\n\t} else {\n\t\tdev_err(d->dev, \"rqst: failed with error %d\\n\", status);\n\t\tgsb_rqsx_response_error(buffer, status);\n\t}\n\n\treturn AE_OK;\n}\n\nstatic acpi_status san_rqsg(struct san_data *d, struct gsb_buffer *buffer)\n{\n\tstruct gsb_data_rqsx *gsb_rqsg;\n\tstruct san_dgpu_event evt;\n\tint status;\n\n\tgsb_rqsg = san_validate_rqsx(d->dev, \"RQSG\", buffer);\n\tif (!gsb_rqsg)\n\t\treturn AE_OK;\n\n\tevt.category = gsb_rqsg->tc;\n\tevt.target = gsb_rqsg->tid;\n\tevt.command = gsb_rqsg->cid;\n\tevt.instance = gsb_rqsg->iid;\n\tevt.length = get_unaligned(&gsb_rqsg->cdl);\n\tevt.payload = &gsb_rqsg->pld[0];\n\n\tstatus = san_dgpu_notifier_call(&evt);\n\tif (!status) {\n\t\tgsb_rqsx_response_success(buffer, NULL, 0);\n\t} else {\n\t\tdev_err(d->dev, \"rqsg: failed with error %d\\n\", status);\n\t\tgsb_rqsx_response_error(buffer, status);\n\t}\n\n\treturn AE_OK;\n}\n\nstatic acpi_status san_opreg_handler(u32 function, acpi_physical_address command,\n\t\t\t\t     u32 bits, u64 *value64, void *opreg_context,\n\t\t\t\t     void *region_context)\n{\n\tstruct san_data *d = to_san_data(opreg_context, info);\n\tstruct gsb_buffer *buffer = (struct gsb_buffer *)value64;\n\tint accessor_type = (function & 0xFFFF0000) >> 16;\n\n\tif (command != SAN_GSB_COMMAND) {\n\t\tdev_warn(d->dev, \"unsupported command: %#04llx\\n\", command);\n\t\treturn AE_OK;\n\t}\n\n\tif (accessor_type != ACPI_GSB_ACCESS_ATTRIB_RAW_PROCESS) {\n\t\tdev_err(d->dev, \"invalid access type: %#04x\\n\", accessor_type);\n\t\treturn AE_OK;\n\t}\n\n\t \n\tif (buffer->len == 0) {\n\t\tdev_err(d->dev, \"request-package too small\\n\");\n\t\treturn AE_OK;\n\t}\n\n\tswitch (buffer->data.in.cv) {\n\tcase SAN_GSB_REQUEST_CV_RQST:\n\t\treturn san_rqst(d, buffer);\n\n\tcase SAN_GSB_REQUEST_CV_ETWL:\n\t\treturn san_etwl(d, buffer);\n\n\tcase SAN_GSB_REQUEST_CV_RQSG:\n\t\treturn san_rqsg(d, buffer);\n\n\tdefault:\n\t\tdev_warn(d->dev, \"unsupported SAN0 request (cv: %#04x)\\n\",\n\t\t\t buffer->data.in.cv);\n\t\treturn AE_OK;\n\t}\n}\n\n\n \n\nstatic int san_events_register(struct platform_device *pdev)\n{\n\tstruct san_data *d = platform_get_drvdata(pdev);\n\tint status;\n\n\td->nf_bat.base.priority = 1;\n\td->nf_bat.base.fn = san_evt_bat_nf;\n\td->nf_bat.event.reg = SSAM_EVENT_REGISTRY_SAM;\n\td->nf_bat.event.id.target_category = SSAM_SSH_TC_BAT;\n\td->nf_bat.event.id.instance = 0;\n\td->nf_bat.event.mask = SSAM_EVENT_MASK_TARGET;\n\td->nf_bat.event.flags = SSAM_EVENT_SEQUENCED;\n\n\td->nf_tmp.base.priority = 1;\n\td->nf_tmp.base.fn = san_evt_tmp_nf;\n\td->nf_tmp.event.reg = SSAM_EVENT_REGISTRY_SAM;\n\td->nf_tmp.event.id.target_category = SSAM_SSH_TC_TMP;\n\td->nf_tmp.event.id.instance = 0;\n\td->nf_tmp.event.mask = SSAM_EVENT_MASK_TARGET;\n\td->nf_tmp.event.flags = SSAM_EVENT_SEQUENCED;\n\n\tstatus = ssam_notifier_register(d->ctrl, &d->nf_bat);\n\tif (status)\n\t\treturn status;\n\n\tstatus = ssam_notifier_register(d->ctrl, &d->nf_tmp);\n\tif (status)\n\t\tssam_notifier_unregister(d->ctrl, &d->nf_bat);\n\n\treturn status;\n}\n\nstatic void san_events_unregister(struct platform_device *pdev)\n{\n\tstruct san_data *d = platform_get_drvdata(pdev);\n\n\tssam_notifier_unregister(d->ctrl, &d->nf_bat);\n\tssam_notifier_unregister(d->ctrl, &d->nf_tmp);\n}\n\n#define san_consumer_printk(level, dev, handle, fmt, ...)\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\t\\\n\tchar *path = \"<error getting consumer path>\";\t\t\t\t\\\n\tstruct acpi_buffer buffer = {\t\t\t\t\t\t\\\n\t\t.length = ACPI_ALLOCATE_BUFFER,\t\t\t\t\t\\\n\t\t.pointer = NULL,\t\t\t\t\t\t\\\n\t};\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\t\\\n\tif (ACPI_SUCCESS(acpi_get_name(handle, ACPI_FULL_PATHNAME, &buffer)))\t\\\n\t\tpath = buffer.pointer;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\t\\\n\tdev_##level(dev, \"[%s]: \" fmt, path, ##__VA_ARGS__);\t\t\t\\\n\tkfree(buffer.pointer);\t\t\t\t\t\t\t\\\n} while (0)\n\n#define san_consumer_dbg(dev, handle, fmt, ...) \\\n\tsan_consumer_printk(dbg, dev, handle, fmt, ##__VA_ARGS__)\n\n#define san_consumer_warn(dev, handle, fmt, ...) \\\n\tsan_consumer_printk(warn, dev, handle, fmt, ##__VA_ARGS__)\n\nstatic bool is_san_consumer(struct platform_device *pdev, acpi_handle handle)\n{\n\tstruct acpi_handle_list dep_devices;\n\tacpi_handle supplier = ACPI_HANDLE(&pdev->dev);\n\tacpi_status status;\n\tint i;\n\n\tif (!acpi_has_method(handle, \"_DEP\"))\n\t\treturn false;\n\n\tstatus = acpi_evaluate_reference(handle, \"_DEP\", NULL, &dep_devices);\n\tif (ACPI_FAILURE(status)) {\n\t\tsan_consumer_dbg(&pdev->dev, handle, \"failed to evaluate _DEP\\n\");\n\t\treturn false;\n\t}\n\n\tfor (i = 0; i < dep_devices.count; i++) {\n\t\tif (dep_devices.handles[i] == supplier)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic acpi_status san_consumer_setup(acpi_handle handle, u32 lvl,\n\t\t\t\t      void *context, void **rv)\n{\n\tconst u32 flags = DL_FLAG_PM_RUNTIME | DL_FLAG_AUTOREMOVE_SUPPLIER;\n\tstruct platform_device *pdev = context;\n\tstruct acpi_device *adev;\n\tstruct device_link *link;\n\n\tif (!is_san_consumer(pdev, handle))\n\t\treturn AE_OK;\n\n\t \n\tadev = acpi_fetch_acpi_dev(handle);\n\tif (!adev)\n\t\treturn AE_OK;\n\n\tsan_consumer_dbg(&pdev->dev, handle, \"creating device link\\n\");\n\n\t \n\tlink = device_link_add(&adev->dev, &pdev->dev, flags);\n\tif (!link) {\n\t\tsan_consumer_warn(&pdev->dev, handle, \"failed to create device link\\n\");\n\t\treturn AE_OK;\n\t}\n\n\treturn AE_OK;\n}\n\nstatic int san_consumer_links_setup(struct platform_device *pdev)\n{\n\tacpi_status status;\n\n\tstatus = acpi_walk_namespace(ACPI_TYPE_DEVICE, ACPI_ROOT_OBJECT,\n\t\t\t\t     ACPI_UINT32_MAX, san_consumer_setup, NULL,\n\t\t\t\t     pdev, NULL);\n\n\treturn status ? -EFAULT : 0;\n}\n\nstatic int san_probe(struct platform_device *pdev)\n{\n\tstruct acpi_device *san = ACPI_COMPANION(&pdev->dev);\n\tstruct ssam_controller *ctrl;\n\tstruct san_data *data;\n\tacpi_status astatus;\n\tint status;\n\n\tctrl = ssam_client_bind(&pdev->dev);\n\tif (IS_ERR(ctrl))\n\t\treturn PTR_ERR(ctrl) == -ENODEV ? -EPROBE_DEFER : PTR_ERR(ctrl);\n\n\tstatus = san_consumer_links_setup(pdev);\n\tif (status)\n\t\treturn status;\n\n\tdata = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->dev = &pdev->dev;\n\tdata->ctrl = ctrl;\n\n\tplatform_set_drvdata(pdev, data);\n\n\tastatus = acpi_install_address_space_handler(san->handle,\n\t\t\t\t\t\t     ACPI_ADR_SPACE_GSBUS,\n\t\t\t\t\t\t     &san_opreg_handler, NULL,\n\t\t\t\t\t\t     &data->info);\n\tif (ACPI_FAILURE(astatus))\n\t\treturn -ENXIO;\n\n\tstatus = san_events_register(pdev);\n\tif (status)\n\t\tgoto err_enable_events;\n\n\tstatus = san_set_rqsg_interface_device(&pdev->dev);\n\tif (status)\n\t\tgoto err_install_dev;\n\n\tacpi_dev_clear_dependencies(san);\n\treturn 0;\n\nerr_install_dev:\n\tsan_events_unregister(pdev);\nerr_enable_events:\n\tacpi_remove_address_space_handler(san, ACPI_ADR_SPACE_GSBUS,\n\t\t\t\t\t  &san_opreg_handler);\n\treturn status;\n}\n\nstatic int san_remove(struct platform_device *pdev)\n{\n\tacpi_handle san = ACPI_HANDLE(&pdev->dev);\n\n\tsan_set_rqsg_interface_device(NULL);\n\tacpi_remove_address_space_handler(san, ACPI_ADR_SPACE_GSBUS,\n\t\t\t\t\t  &san_opreg_handler);\n\tsan_events_unregister(pdev);\n\n\t \n\tflush_workqueue(san_wq);\n\n\treturn 0;\n}\n\nstatic const struct acpi_device_id san_match[] = {\n\t{ \"MSHW0091\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(acpi, san_match);\n\nstatic struct platform_driver surface_acpi_notify = {\n\t.probe = san_probe,\n\t.remove = san_remove,\n\t.driver = {\n\t\t.name = \"surface_acpi_notify\",\n\t\t.acpi_match_table = san_match,\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t},\n};\n\nstatic int __init san_init(void)\n{\n\tint ret;\n\n\tsan_wq = alloc_workqueue(\"san_wq\", 0, 0);\n\tif (!san_wq)\n\t\treturn -ENOMEM;\n\tret = platform_driver_register(&surface_acpi_notify);\n\tif (ret)\n\t\tdestroy_workqueue(san_wq);\n\treturn ret;\n}\nmodule_init(san_init);\n\nstatic void __exit san_exit(void)\n{\n\tplatform_driver_unregister(&surface_acpi_notify);\n\tdestroy_workqueue(san_wq);\n}\nmodule_exit(san_exit);\n\nMODULE_AUTHOR(\"Maximilian Luz <luzmaximilian@gmail.com>\");\nMODULE_DESCRIPTION(\"Surface ACPI Notify driver for Surface System Aggregator Module\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}