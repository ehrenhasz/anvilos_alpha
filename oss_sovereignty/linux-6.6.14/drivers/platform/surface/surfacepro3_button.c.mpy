{
  "module_name": "surfacepro3_button.c",
  "hash_id": "96ed34101e2bb640461c77b63717959ea7236e7017231ac58d005007112b7535",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/surface/surfacepro3_button.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/types.h>\n#include <linux/input.h>\n#include <linux/acpi.h>\n#include <acpi/button.h>\n\n#define SURFACE_PRO3_BUTTON_HID\t\t\"MSHW0028\"\n#define SURFACE_PRO4_BUTTON_HID\t\t\"MSHW0040\"\n#define SURFACE_BUTTON_OBJ_NAME\t\t\"VGBI\"\n#define SURFACE_BUTTON_DEVICE_NAME\t\"Surface Pro 3/4 Buttons\"\n\n#define MSHW0040_DSM_REVISION\t\t0x01\n#define MSHW0040_DSM_GET_OMPR\t\t0x02\t\nstatic const guid_t MSHW0040_DSM_UUID =\n\tGUID_INIT(0x6fd05c69, 0xcde3, 0x49f4, 0x95, 0xed, 0xab, 0x16, 0x65,\n\t\t  0x49, 0x80, 0x35);\n\n#define SURFACE_BUTTON_NOTIFY_TABLET_MODE\t0xc8\n\n#define SURFACE_BUTTON_NOTIFY_PRESS_POWER\t0xc6\n#define SURFACE_BUTTON_NOTIFY_RELEASE_POWER\t0xc7\n\n#define SURFACE_BUTTON_NOTIFY_PRESS_HOME\t0xc4\n#define SURFACE_BUTTON_NOTIFY_RELEASE_HOME\t0xc5\n\n#define SURFACE_BUTTON_NOTIFY_PRESS_VOLUME_UP\t0xc0\n#define SURFACE_BUTTON_NOTIFY_RELEASE_VOLUME_UP\t0xc1\n\n#define SURFACE_BUTTON_NOTIFY_PRESS_VOLUME_DOWN\t\t0xc2\n#define SURFACE_BUTTON_NOTIFY_RELEASE_VOLUME_DOWN\t0xc3\n\nMODULE_AUTHOR(\"Chen Yu\");\nMODULE_DESCRIPTION(\"Surface Pro3 Button Driver\");\nMODULE_LICENSE(\"GPL v2\");\n\n \nstatic const struct acpi_device_id surface_button_device_ids[] = {\n\t{SURFACE_PRO3_BUTTON_HID,    0},\n\t{SURFACE_PRO4_BUTTON_HID,    0},\n\t{\"\", 0},\n};\nMODULE_DEVICE_TABLE(acpi, surface_button_device_ids);\n\nstruct surface_button {\n\tunsigned int type;\n\tstruct input_dev *input;\n\tchar phys[32];\t\t\t \n\tunsigned long pushed;\n\tbool suspended;\n};\n\nstatic void surface_button_notify(struct acpi_device *device, u32 event)\n{\n\tstruct surface_button *button = acpi_driver_data(device);\n\tstruct input_dev *input;\n\tint key_code = KEY_RESERVED;\n\tbool pressed = false;\n\n\tswitch (event) {\n\t \n\tcase SURFACE_BUTTON_NOTIFY_PRESS_POWER:\n\t\tpressed = true;\n\t\tfallthrough;\n\tcase SURFACE_BUTTON_NOTIFY_RELEASE_POWER:\n\t\tkey_code = KEY_POWER;\n\t\tbreak;\n\t \n\tcase SURFACE_BUTTON_NOTIFY_PRESS_HOME:\n\t\tpressed = true;\n\t\tfallthrough;\n\tcase SURFACE_BUTTON_NOTIFY_RELEASE_HOME:\n\t\tkey_code = KEY_LEFTMETA;\n\t\tbreak;\n\t \n\tcase SURFACE_BUTTON_NOTIFY_PRESS_VOLUME_UP:\n\t\tpressed = true;\n\t\tfallthrough;\n\tcase SURFACE_BUTTON_NOTIFY_RELEASE_VOLUME_UP:\n\t\tkey_code = KEY_VOLUMEUP;\n\t\tbreak;\n\t \n\tcase SURFACE_BUTTON_NOTIFY_PRESS_VOLUME_DOWN:\n\t\tpressed = true;\n\t\tfallthrough;\n\tcase SURFACE_BUTTON_NOTIFY_RELEASE_VOLUME_DOWN:\n\t\tkey_code = KEY_VOLUMEDOWN;\n\t\tbreak;\n\tcase SURFACE_BUTTON_NOTIFY_TABLET_MODE:\n\t\tdev_warn_once(&device->dev, \"Tablet mode is not supported\\n\");\n\t\tbreak;\n\tdefault:\n\t\tdev_info_ratelimited(&device->dev,\n\t\t\t\t     \"Unsupported event [0x%x]\\n\", event);\n\t\tbreak;\n\t}\n\tinput = button->input;\n\tif (key_code == KEY_RESERVED)\n\t\treturn;\n\tif (pressed)\n\t\tpm_wakeup_dev_event(&device->dev, 0, button->suspended);\n\tif (button->suspended)\n\t\treturn;\n\tinput_report_key(input, key_code, pressed?1:0);\n\tinput_sync(input);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int surface_button_suspend(struct device *dev)\n{\n\tstruct acpi_device *device = to_acpi_device(dev);\n\tstruct surface_button *button = acpi_driver_data(device);\n\n\tbutton->suspended = true;\n\treturn 0;\n}\n\nstatic int surface_button_resume(struct device *dev)\n{\n\tstruct acpi_device *device = to_acpi_device(dev);\n\tstruct surface_button *button = acpi_driver_data(device);\n\n\tbutton->suspended = false;\n\treturn 0;\n}\n#endif\n\n \nstatic bool surface_button_check_MSHW0040(struct acpi_device *dev)\n{\n\tacpi_handle handle = dev->handle;\n\tunion acpi_object *result;\n\tu64 oem_platform_rev = 0;\t\n\n\t\n\tresult = acpi_evaluate_dsm_typed(handle, &MSHW0040_DSM_UUID,\n\t\t\t\t\t MSHW0040_DSM_REVISION,\n\t\t\t\t\t MSHW0040_DSM_GET_OMPR,\n\t\t\t\t\t NULL, ACPI_TYPE_INTEGER);\n\n\t \n\n\tif (result) {\n\t\toem_platform_rev = result->integer.value;\n\t\tACPI_FREE(result);\n\t}\n\n\tdev_dbg(&dev->dev, \"OEM Platform Revision %llu\\n\", oem_platform_rev);\n\n\treturn oem_platform_rev == 0;\n}\n\n\nstatic int surface_button_add(struct acpi_device *device)\n{\n\tstruct surface_button *button;\n\tstruct input_dev *input;\n\tconst char *hid = acpi_device_hid(device);\n\tchar *name;\n\tint error;\n\n\tif (strncmp(acpi_device_bid(device), SURFACE_BUTTON_OBJ_NAME,\n\t    strlen(SURFACE_BUTTON_OBJ_NAME)))\n\t\treturn -ENODEV;\n\n\tif (!surface_button_check_MSHW0040(device))\n\t\treturn -ENODEV;\n\n\tbutton = kzalloc(sizeof(struct surface_button), GFP_KERNEL);\n\tif (!button)\n\t\treturn -ENOMEM;\n\n\tdevice->driver_data = button;\n\tbutton->input = input = input_allocate_device();\n\tif (!input) {\n\t\terror = -ENOMEM;\n\t\tgoto err_free_button;\n\t}\n\n\tname = acpi_device_name(device);\n\tstrcpy(name, SURFACE_BUTTON_DEVICE_NAME);\n\tsnprintf(button->phys, sizeof(button->phys), \"%s/buttons\", hid);\n\n\tinput->name = name;\n\tinput->phys = button->phys;\n\tinput->id.bustype = BUS_HOST;\n\tinput->dev.parent = &device->dev;\n\tinput_set_capability(input, EV_KEY, KEY_POWER);\n\tinput_set_capability(input, EV_KEY, KEY_LEFTMETA);\n\tinput_set_capability(input, EV_KEY, KEY_VOLUMEUP);\n\tinput_set_capability(input, EV_KEY, KEY_VOLUMEDOWN);\n\n\terror = input_register_device(input);\n\tif (error)\n\t\tgoto err_free_input;\n\n\tdevice_init_wakeup(&device->dev, true);\n\tdev_info(&device->dev,\n\t\t\t\"%s [%s]\\n\", name, acpi_device_bid(device));\n\treturn 0;\n\n err_free_input:\n\tinput_free_device(input);\n err_free_button:\n\tkfree(button);\n\treturn error;\n}\n\nstatic void surface_button_remove(struct acpi_device *device)\n{\n\tstruct surface_button *button = acpi_driver_data(device);\n\n\tinput_unregister_device(button->input);\n\tkfree(button);\n}\n\nstatic SIMPLE_DEV_PM_OPS(surface_button_pm,\n\t\tsurface_button_suspend, surface_button_resume);\n\nstatic struct acpi_driver surface_button_driver = {\n\t.name = \"surface_pro3_button\",\n\t.class = \"SurfacePro3\",\n\t.ids = surface_button_device_ids,\n\t.ops = {\n\t\t.add = surface_button_add,\n\t\t.remove = surface_button_remove,\n\t\t.notify = surface_button_notify,\n\t},\n\t.drv.pm = &surface_button_pm,\n};\n\nmodule_acpi_driver(surface_button_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}