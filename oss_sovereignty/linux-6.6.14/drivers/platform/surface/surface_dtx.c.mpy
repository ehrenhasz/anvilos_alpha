{
  "module_name": "surface_dtx.c",
  "hash_id": "0f005dd75b7b36ad03364d6a8ae3fb919d701fbf61627d748b729a796ec90ea0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/surface/surface_dtx.c",
  "human_readable_source": "\n \n\n#include <linux/fs.h>\n#include <linux/input.h>\n#include <linux/ioctl.h>\n#include <linux/kernel.h>\n#include <linux/kfifo.h>\n#include <linux/kref.h>\n#include <linux/miscdevice.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/platform_device.h>\n#include <linux/poll.h>\n#include <linux/rwsem.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n\n#include <linux/surface_aggregator/controller.h>\n#include <linux/surface_aggregator/device.h>\n#include <linux/surface_aggregator/dtx.h>\n\n\n \n\nenum sam_event_cid_bas {\n\tSAM_EVENT_CID_DTX_CONNECTION\t\t\t= 0x0c,\n\tSAM_EVENT_CID_DTX_REQUEST\t\t\t= 0x0e,\n\tSAM_EVENT_CID_DTX_CANCEL\t\t\t= 0x0f,\n\tSAM_EVENT_CID_DTX_LATCH_STATUS\t\t\t= 0x11,\n};\n\nenum ssam_bas_base_state {\n\tSSAM_BAS_BASE_STATE_DETACH_SUCCESS\t\t= 0x00,\n\tSSAM_BAS_BASE_STATE_ATTACHED\t\t\t= 0x01,\n\tSSAM_BAS_BASE_STATE_NOT_FEASIBLE\t\t= 0x02,\n};\n\nenum ssam_bas_latch_status {\n\tSSAM_BAS_LATCH_STATUS_CLOSED\t\t\t= 0x00,\n\tSSAM_BAS_LATCH_STATUS_OPENED\t\t\t= 0x01,\n\tSSAM_BAS_LATCH_STATUS_FAILED_TO_OPEN\t\t= 0x02,\n\tSSAM_BAS_LATCH_STATUS_FAILED_TO_REMAIN_OPEN\t= 0x03,\n\tSSAM_BAS_LATCH_STATUS_FAILED_TO_CLOSE\t\t= 0x04,\n};\n\nenum ssam_bas_cancel_reason {\n\tSSAM_BAS_CANCEL_REASON_NOT_FEASIBLE\t\t= 0x00,   \n\tSSAM_BAS_CANCEL_REASON_TIMEOUT\t\t\t= 0x02,\n\tSSAM_BAS_CANCEL_REASON_FAILED_TO_OPEN\t\t= 0x03,\n\tSSAM_BAS_CANCEL_REASON_FAILED_TO_REMAIN_OPEN\t= 0x04,\n\tSSAM_BAS_CANCEL_REASON_FAILED_TO_CLOSE\t\t= 0x05,\n};\n\nstruct ssam_bas_base_info {\n\tu8 state;\n\tu8 base_id;\n} __packed;\n\nstatic_assert(sizeof(struct ssam_bas_base_info) == 2);\n\nSSAM_DEFINE_SYNC_REQUEST_N(ssam_bas_latch_lock, {\n\t.target_category = SSAM_SSH_TC_BAS,\n\t.target_id       = SSAM_SSH_TID_SAM,\n\t.command_id      = 0x06,\n\t.instance_id     = 0x00,\n});\n\nSSAM_DEFINE_SYNC_REQUEST_N(ssam_bas_latch_unlock, {\n\t.target_category = SSAM_SSH_TC_BAS,\n\t.target_id       = SSAM_SSH_TID_SAM,\n\t.command_id      = 0x07,\n\t.instance_id     = 0x00,\n});\n\nSSAM_DEFINE_SYNC_REQUEST_N(ssam_bas_latch_request, {\n\t.target_category = SSAM_SSH_TC_BAS,\n\t.target_id       = SSAM_SSH_TID_SAM,\n\t.command_id      = 0x08,\n\t.instance_id     = 0x00,\n});\n\nSSAM_DEFINE_SYNC_REQUEST_N(ssam_bas_latch_confirm, {\n\t.target_category = SSAM_SSH_TC_BAS,\n\t.target_id       = SSAM_SSH_TID_SAM,\n\t.command_id      = 0x09,\n\t.instance_id     = 0x00,\n});\n\nSSAM_DEFINE_SYNC_REQUEST_N(ssam_bas_latch_heartbeat, {\n\t.target_category = SSAM_SSH_TC_BAS,\n\t.target_id       = SSAM_SSH_TID_SAM,\n\t.command_id      = 0x0a,\n\t.instance_id     = 0x00,\n});\n\nSSAM_DEFINE_SYNC_REQUEST_N(ssam_bas_latch_cancel, {\n\t.target_category = SSAM_SSH_TC_BAS,\n\t.target_id       = SSAM_SSH_TID_SAM,\n\t.command_id      = 0x0b,\n\t.instance_id     = 0x00,\n});\n\nSSAM_DEFINE_SYNC_REQUEST_R(ssam_bas_get_base, struct ssam_bas_base_info, {\n\t.target_category = SSAM_SSH_TC_BAS,\n\t.target_id       = SSAM_SSH_TID_SAM,\n\t.command_id      = 0x0c,\n\t.instance_id     = 0x00,\n});\n\nSSAM_DEFINE_SYNC_REQUEST_R(ssam_bas_get_device_mode, u8, {\n\t.target_category = SSAM_SSH_TC_BAS,\n\t.target_id       = SSAM_SSH_TID_SAM,\n\t.command_id      = 0x0d,\n\t.instance_id     = 0x00,\n});\n\nSSAM_DEFINE_SYNC_REQUEST_R(ssam_bas_get_latch_status, u8, {\n\t.target_category = SSAM_SSH_TC_BAS,\n\t.target_id       = SSAM_SSH_TID_SAM,\n\t.command_id      = 0x11,\n\t.instance_id     = 0x00,\n});\n\n\n \n\nenum sdtx_device_state {\n\tSDTX_DEVICE_SHUTDOWN_BIT    = BIT(0),\n\tSDTX_DEVICE_DIRTY_BASE_BIT  = BIT(1),\n\tSDTX_DEVICE_DIRTY_MODE_BIT  = BIT(2),\n\tSDTX_DEVICE_DIRTY_LATCH_BIT = BIT(3),\n};\n\nstruct sdtx_device {\n\tstruct kref kref;\n\tstruct rw_semaphore lock;          \n\n\tstruct device *dev;\n\tstruct ssam_controller *ctrl;\n\tunsigned long flags;\n\n\tstruct miscdevice mdev;\n\twait_queue_head_t waitq;\n\tstruct mutex write_lock;           \n\tstruct rw_semaphore client_lock;   \n\tstruct list_head client_list;\n\n\tstruct delayed_work state_work;\n\tstruct {\n\t\tstruct ssam_bas_base_info base;\n\t\tu8 device_mode;\n\t\tu8 latch_status;\n\t} state;\n\n\tstruct delayed_work mode_work;\n\tstruct input_dev *mode_switch;\n\n\tstruct ssam_event_notifier notif;\n};\n\nenum sdtx_client_state {\n\tSDTX_CLIENT_EVENTS_ENABLED_BIT = BIT(0),\n};\n\nstruct sdtx_client {\n\tstruct sdtx_device *ddev;\n\tstruct list_head node;\n\tunsigned long flags;\n\n\tstruct fasync_struct *fasync;\n\n\tstruct mutex read_lock;            \n\tDECLARE_KFIFO(buffer, u8, 512);\n};\n\nstatic void __sdtx_device_release(struct kref *kref)\n{\n\tstruct sdtx_device *ddev = container_of(kref, struct sdtx_device, kref);\n\n\tmutex_destroy(&ddev->write_lock);\n\tkfree(ddev);\n}\n\nstatic struct sdtx_device *sdtx_device_get(struct sdtx_device *ddev)\n{\n\tif (ddev)\n\t\tkref_get(&ddev->kref);\n\n\treturn ddev;\n}\n\nstatic void sdtx_device_put(struct sdtx_device *ddev)\n{\n\tif (ddev)\n\t\tkref_put(&ddev->kref, __sdtx_device_release);\n}\n\n\n \n\nstatic u16 sdtx_translate_base_state(struct sdtx_device *ddev, u8 state)\n{\n\tswitch (state) {\n\tcase SSAM_BAS_BASE_STATE_ATTACHED:\n\t\treturn SDTX_BASE_ATTACHED;\n\n\tcase SSAM_BAS_BASE_STATE_DETACH_SUCCESS:\n\t\treturn SDTX_BASE_DETACHED;\n\n\tcase SSAM_BAS_BASE_STATE_NOT_FEASIBLE:\n\t\treturn SDTX_DETACH_NOT_FEASIBLE;\n\n\tdefault:\n\t\tdev_err(ddev->dev, \"unknown base state: %#04x\\n\", state);\n\t\treturn SDTX_UNKNOWN(state);\n\t}\n}\n\nstatic u16 sdtx_translate_latch_status(struct sdtx_device *ddev, u8 status)\n{\n\tswitch (status) {\n\tcase SSAM_BAS_LATCH_STATUS_CLOSED:\n\t\treturn SDTX_LATCH_CLOSED;\n\n\tcase SSAM_BAS_LATCH_STATUS_OPENED:\n\t\treturn SDTX_LATCH_OPENED;\n\n\tcase SSAM_BAS_LATCH_STATUS_FAILED_TO_OPEN:\n\t\treturn SDTX_ERR_FAILED_TO_OPEN;\n\n\tcase SSAM_BAS_LATCH_STATUS_FAILED_TO_REMAIN_OPEN:\n\t\treturn SDTX_ERR_FAILED_TO_REMAIN_OPEN;\n\n\tcase SSAM_BAS_LATCH_STATUS_FAILED_TO_CLOSE:\n\t\treturn SDTX_ERR_FAILED_TO_CLOSE;\n\n\tdefault:\n\t\tdev_err(ddev->dev, \"unknown latch status: %#04x\\n\", status);\n\t\treturn SDTX_UNKNOWN(status);\n\t}\n}\n\nstatic u16 sdtx_translate_cancel_reason(struct sdtx_device *ddev, u8 reason)\n{\n\tswitch (reason) {\n\tcase SSAM_BAS_CANCEL_REASON_NOT_FEASIBLE:\n\t\treturn SDTX_DETACH_NOT_FEASIBLE;\n\n\tcase SSAM_BAS_CANCEL_REASON_TIMEOUT:\n\t\treturn SDTX_DETACH_TIMEDOUT;\n\n\tcase SSAM_BAS_CANCEL_REASON_FAILED_TO_OPEN:\n\t\treturn SDTX_ERR_FAILED_TO_OPEN;\n\n\tcase SSAM_BAS_CANCEL_REASON_FAILED_TO_REMAIN_OPEN:\n\t\treturn SDTX_ERR_FAILED_TO_REMAIN_OPEN;\n\n\tcase SSAM_BAS_CANCEL_REASON_FAILED_TO_CLOSE:\n\t\treturn SDTX_ERR_FAILED_TO_CLOSE;\n\n\tdefault:\n\t\tdev_err(ddev->dev, \"unknown cancel reason: %#04x\\n\", reason);\n\t\treturn SDTX_UNKNOWN(reason);\n\t}\n}\n\n\n \n\nstatic int sdtx_ioctl_get_base_info(struct sdtx_device *ddev,\n\t\t\t\t    struct sdtx_base_info __user *buf)\n{\n\tstruct ssam_bas_base_info raw;\n\tstruct sdtx_base_info info;\n\tint status;\n\n\tlockdep_assert_held_read(&ddev->lock);\n\n\tstatus = ssam_retry(ssam_bas_get_base, ddev->ctrl, &raw);\n\tif (status < 0)\n\t\treturn status;\n\n\tinfo.state = sdtx_translate_base_state(ddev, raw.state);\n\tinfo.base_id = SDTX_BASE_TYPE_SSH(raw.base_id);\n\n\tif (copy_to_user(buf, &info, sizeof(info)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int sdtx_ioctl_get_device_mode(struct sdtx_device *ddev, u16 __user *buf)\n{\n\tu8 mode;\n\tint status;\n\n\tlockdep_assert_held_read(&ddev->lock);\n\n\tstatus = ssam_retry(ssam_bas_get_device_mode, ddev->ctrl, &mode);\n\tif (status < 0)\n\t\treturn status;\n\n\treturn put_user(mode, buf);\n}\n\nstatic int sdtx_ioctl_get_latch_status(struct sdtx_device *ddev, u16 __user *buf)\n{\n\tu8 latch;\n\tint status;\n\n\tlockdep_assert_held_read(&ddev->lock);\n\n\tstatus = ssam_retry(ssam_bas_get_latch_status, ddev->ctrl, &latch);\n\tif (status < 0)\n\t\treturn status;\n\n\treturn put_user(sdtx_translate_latch_status(ddev, latch), buf);\n}\n\nstatic long __surface_dtx_ioctl(struct sdtx_client *client, unsigned int cmd, unsigned long arg)\n{\n\tstruct sdtx_device *ddev = client->ddev;\n\n\tlockdep_assert_held_read(&ddev->lock);\n\n\tswitch (cmd) {\n\tcase SDTX_IOCTL_EVENTS_ENABLE:\n\t\tset_bit(SDTX_CLIENT_EVENTS_ENABLED_BIT, &client->flags);\n\t\treturn 0;\n\n\tcase SDTX_IOCTL_EVENTS_DISABLE:\n\t\tclear_bit(SDTX_CLIENT_EVENTS_ENABLED_BIT, &client->flags);\n\t\treturn 0;\n\n\tcase SDTX_IOCTL_LATCH_LOCK:\n\t\treturn ssam_retry(ssam_bas_latch_lock, ddev->ctrl);\n\n\tcase SDTX_IOCTL_LATCH_UNLOCK:\n\t\treturn ssam_retry(ssam_bas_latch_unlock, ddev->ctrl);\n\n\tcase SDTX_IOCTL_LATCH_REQUEST:\n\t\treturn ssam_retry(ssam_bas_latch_request, ddev->ctrl);\n\n\tcase SDTX_IOCTL_LATCH_CONFIRM:\n\t\treturn ssam_retry(ssam_bas_latch_confirm, ddev->ctrl);\n\n\tcase SDTX_IOCTL_LATCH_HEARTBEAT:\n\t\treturn ssam_retry(ssam_bas_latch_heartbeat, ddev->ctrl);\n\n\tcase SDTX_IOCTL_LATCH_CANCEL:\n\t\treturn ssam_retry(ssam_bas_latch_cancel, ddev->ctrl);\n\n\tcase SDTX_IOCTL_GET_BASE_INFO:\n\t\treturn sdtx_ioctl_get_base_info(ddev, (struct sdtx_base_info __user *)arg);\n\n\tcase SDTX_IOCTL_GET_DEVICE_MODE:\n\t\treturn sdtx_ioctl_get_device_mode(ddev, (u16 __user *)arg);\n\n\tcase SDTX_IOCTL_GET_LATCH_STATUS:\n\t\treturn sdtx_ioctl_get_latch_status(ddev, (u16 __user *)arg);\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic long surface_dtx_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tstruct sdtx_client *client = file->private_data;\n\tlong status;\n\n\tif (down_read_killable(&client->ddev->lock))\n\t\treturn -ERESTARTSYS;\n\n\tif (test_bit(SDTX_DEVICE_SHUTDOWN_BIT, &client->ddev->flags)) {\n\t\tup_read(&client->ddev->lock);\n\t\treturn -ENODEV;\n\t}\n\n\tstatus = __surface_dtx_ioctl(client, cmd, arg);\n\n\tup_read(&client->ddev->lock);\n\treturn status;\n}\n\n\n \n\nstatic int surface_dtx_open(struct inode *inode, struct file *file)\n{\n\tstruct sdtx_device *ddev = container_of(file->private_data, struct sdtx_device, mdev);\n\tstruct sdtx_client *client;\n\n\t \n\tclient = kzalloc(sizeof(*client), GFP_KERNEL);\n\tif (!client)\n\t\treturn -ENOMEM;\n\n\tclient->ddev = sdtx_device_get(ddev);\n\n\tINIT_LIST_HEAD(&client->node);\n\n\tmutex_init(&client->read_lock);\n\tINIT_KFIFO(client->buffer);\n\n\tfile->private_data = client;\n\n\t \n\tdown_write(&ddev->client_lock);\n\n\t \n\tif (test_bit(SDTX_DEVICE_SHUTDOWN_BIT, &ddev->flags)) {\n\t\tup_write(&ddev->client_lock);\n\t\tmutex_destroy(&client->read_lock);\n\t\tsdtx_device_put(client->ddev);\n\t\tkfree(client);\n\t\treturn -ENODEV;\n\t}\n\n\tlist_add_tail(&client->node, &ddev->client_list);\n\tup_write(&ddev->client_lock);\n\n\tstream_open(inode, file);\n\treturn 0;\n}\n\nstatic int surface_dtx_release(struct inode *inode, struct file *file)\n{\n\tstruct sdtx_client *client = file->private_data;\n\n\t \n\tdown_write(&client->ddev->client_lock);\n\tlist_del(&client->node);\n\tup_write(&client->ddev->client_lock);\n\n\t \n\tsdtx_device_put(client->ddev);\n\tmutex_destroy(&client->read_lock);\n\tkfree(client);\n\n\treturn 0;\n}\n\nstatic ssize_t surface_dtx_read(struct file *file, char __user *buf, size_t count, loff_t *offs)\n{\n\tstruct sdtx_client *client = file->private_data;\n\tstruct sdtx_device *ddev = client->ddev;\n\tunsigned int copied;\n\tint status = 0;\n\n\tif (down_read_killable(&ddev->lock))\n\t\treturn -ERESTARTSYS;\n\n\t \n\tif (test_bit(SDTX_DEVICE_SHUTDOWN_BIT, &ddev->flags)) {\n\t\tup_read(&ddev->lock);\n\t\treturn -ENODEV;\n\t}\n\n\tdo {\n\t\t \n\t\tif (kfifo_is_empty(&client->buffer)) {\n\t\t\tup_read(&ddev->lock);\n\n\t\t\tif (file->f_flags & O_NONBLOCK)\n\t\t\t\treturn -EAGAIN;\n\n\t\t\tstatus = wait_event_interruptible(ddev->waitq,\n\t\t\t\t\t\t\t  !kfifo_is_empty(&client->buffer) ||\n\t\t\t\t\t\t\t  test_bit(SDTX_DEVICE_SHUTDOWN_BIT,\n\t\t\t\t\t\t\t\t   &ddev->flags));\n\t\t\tif (status < 0)\n\t\t\t\treturn status;\n\n\t\t\tif (down_read_killable(&ddev->lock))\n\t\t\t\treturn -ERESTARTSYS;\n\n\t\t\t \n\t\t\tif (test_bit(SDTX_DEVICE_SHUTDOWN_BIT, &ddev->flags)) {\n\t\t\t\tup_read(&ddev->lock);\n\t\t\t\treturn -ENODEV;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (mutex_lock_interruptible(&client->read_lock)) {\n\t\t\tup_read(&ddev->lock);\n\t\t\treturn -ERESTARTSYS;\n\t\t}\n\n\t\tstatus = kfifo_to_user(&client->buffer, buf, count, &copied);\n\t\tmutex_unlock(&client->read_lock);\n\n\t\tif (status < 0) {\n\t\t\tup_read(&ddev->lock);\n\t\t\treturn status;\n\t\t}\n\n\t\t \n\t\tif (copied == 0 && (file->f_flags & O_NONBLOCK)) {\n\t\t\tup_read(&ddev->lock);\n\t\t\treturn -EAGAIN;\n\t\t}\n\t} while (copied == 0);\n\n\tup_read(&ddev->lock);\n\treturn copied;\n}\n\nstatic __poll_t surface_dtx_poll(struct file *file, struct poll_table_struct *pt)\n{\n\tstruct sdtx_client *client = file->private_data;\n\t__poll_t events = 0;\n\n\tif (test_bit(SDTX_DEVICE_SHUTDOWN_BIT, &client->ddev->flags))\n\t\treturn EPOLLHUP | EPOLLERR;\n\n\tpoll_wait(file, &client->ddev->waitq, pt);\n\n\tif (!kfifo_is_empty(&client->buffer))\n\t\tevents |= EPOLLIN | EPOLLRDNORM;\n\n\treturn events;\n}\n\nstatic int surface_dtx_fasync(int fd, struct file *file, int on)\n{\n\tstruct sdtx_client *client = file->private_data;\n\n\treturn fasync_helper(fd, file, on, &client->fasync);\n}\n\nstatic const struct file_operations surface_dtx_fops = {\n\t.owner          = THIS_MODULE,\n\t.open           = surface_dtx_open,\n\t.release        = surface_dtx_release,\n\t.read           = surface_dtx_read,\n\t.poll           = surface_dtx_poll,\n\t.fasync         = surface_dtx_fasync,\n\t.unlocked_ioctl = surface_dtx_ioctl,\n\t.compat_ioctl   = surface_dtx_ioctl,\n\t.llseek         = no_llseek,\n};\n\n\n \n\n \n#define SDTX_DEVICE_MODE_DELAY_CONNECT\tmsecs_to_jiffies(100)\n#define SDTX_DEVICE_MODE_DELAY_RECHECK\tmsecs_to_jiffies(100)\n\nstruct sdtx_status_event {\n\tstruct sdtx_event e;\n\t__u16 v;\n} __packed;\n\nstruct sdtx_base_info_event {\n\tstruct sdtx_event e;\n\tstruct sdtx_base_info v;\n} __packed;\n\nunion sdtx_generic_event {\n\tstruct sdtx_event common;\n\tstruct sdtx_status_event status;\n\tstruct sdtx_base_info_event base;\n};\n\nstatic void sdtx_update_device_mode(struct sdtx_device *ddev, unsigned long delay);\n\n \nstatic void sdtx_push_event(struct sdtx_device *ddev, struct sdtx_event *evt)\n{\n\tconst size_t len = sizeof(struct sdtx_event) + evt->length;\n\tstruct sdtx_client *client;\n\n\tlockdep_assert_held(&ddev->write_lock);\n\n\tdown_read(&ddev->client_lock);\n\tlist_for_each_entry(client, &ddev->client_list, node) {\n\t\tif (!test_bit(SDTX_CLIENT_EVENTS_ENABLED_BIT, &client->flags))\n\t\t\tcontinue;\n\n\t\tif (likely(kfifo_avail(&client->buffer) >= len))\n\t\t\tkfifo_in(&client->buffer, (const u8 *)evt, len);\n\t\telse\n\t\t\tdev_warn(ddev->dev, \"event buffer overrun\\n\");\n\n\t\tkill_fasync(&client->fasync, SIGIO, POLL_IN);\n\t}\n\tup_read(&ddev->client_lock);\n\n\twake_up_interruptible(&ddev->waitq);\n}\n\nstatic u32 sdtx_notifier(struct ssam_event_notifier *nf, const struct ssam_event *in)\n{\n\tstruct sdtx_device *ddev = container_of(nf, struct sdtx_device, notif);\n\tunion sdtx_generic_event event;\n\tsize_t len;\n\n\t \n\tswitch (in->command_id) {\n\tcase SAM_EVENT_CID_DTX_CONNECTION:\n\t\tlen = 2 * sizeof(u8);\n\t\tbreak;\n\n\tcase SAM_EVENT_CID_DTX_REQUEST:\n\t\tlen = 0;\n\t\tbreak;\n\n\tcase SAM_EVENT_CID_DTX_CANCEL:\n\t\tlen = sizeof(u8);\n\t\tbreak;\n\n\tcase SAM_EVENT_CID_DTX_LATCH_STATUS:\n\t\tlen = sizeof(u8);\n\t\tbreak;\n\n\tdefault:\n\t\treturn 0;\n\t}\n\n\tif (in->length != len) {\n\t\tdev_err(ddev->dev,\n\t\t\t\"unexpected payload size for event %#04x: got %u, expected %zu\\n\",\n\t\t\tin->command_id, in->length, len);\n\t\treturn 0;\n\t}\n\n\tmutex_lock(&ddev->write_lock);\n\n\t \n\tswitch (in->command_id) {\n\tcase SAM_EVENT_CID_DTX_CONNECTION:\n\t\tclear_bit(SDTX_DEVICE_DIRTY_BASE_BIT, &ddev->flags);\n\n\t\t \n\t\tif (ddev->state.base.state == in->data[0] &&\n\t\t    ddev->state.base.base_id == in->data[1])\n\t\t\tgoto out;\n\n\t\tddev->state.base.state = in->data[0];\n\t\tddev->state.base.base_id = in->data[1];\n\n\t\tevent.base.e.length = sizeof(struct sdtx_base_info);\n\t\tevent.base.e.code = SDTX_EVENT_BASE_CONNECTION;\n\t\tevent.base.v.state = sdtx_translate_base_state(ddev, in->data[0]);\n\t\tevent.base.v.base_id = SDTX_BASE_TYPE_SSH(in->data[1]);\n\t\tbreak;\n\n\tcase SAM_EVENT_CID_DTX_REQUEST:\n\t\tevent.common.code = SDTX_EVENT_REQUEST;\n\t\tevent.common.length = 0;\n\t\tbreak;\n\n\tcase SAM_EVENT_CID_DTX_CANCEL:\n\t\tevent.status.e.length = sizeof(u16);\n\t\tevent.status.e.code = SDTX_EVENT_CANCEL;\n\t\tevent.status.v = sdtx_translate_cancel_reason(ddev, in->data[0]);\n\t\tbreak;\n\n\tcase SAM_EVENT_CID_DTX_LATCH_STATUS:\n\t\tclear_bit(SDTX_DEVICE_DIRTY_LATCH_BIT, &ddev->flags);\n\n\t\t \n\t\tif (ddev->state.latch_status == in->data[0])\n\t\t\tgoto out;\n\n\t\tddev->state.latch_status = in->data[0];\n\n\t\tevent.status.e.length = sizeof(u16);\n\t\tevent.status.e.code = SDTX_EVENT_LATCH_STATUS;\n\t\tevent.status.v = sdtx_translate_latch_status(ddev, in->data[0]);\n\t\tbreak;\n\t}\n\n\tsdtx_push_event(ddev, &event.common);\n\n\t \n\tif (in->command_id == SAM_EVENT_CID_DTX_CONNECTION) {\n\t\tunsigned long delay;\n\n\t\tdelay = in->data[0] ? SDTX_DEVICE_MODE_DELAY_CONNECT : 0;\n\t\tsdtx_update_device_mode(ddev, delay);\n\t}\n\nout:\n\tmutex_unlock(&ddev->write_lock);\n\treturn SSAM_NOTIF_HANDLED;\n}\n\n\n \n\nstatic bool sdtx_device_mode_invalid(u8 mode, u8 base_state)\n{\n\treturn ((base_state == SSAM_BAS_BASE_STATE_ATTACHED) &&\n\t\t(mode == SDTX_DEVICE_MODE_TABLET)) ||\n\t       ((base_state == SSAM_BAS_BASE_STATE_DETACH_SUCCESS) &&\n\t\t(mode != SDTX_DEVICE_MODE_TABLET));\n}\n\nstatic void sdtx_device_mode_workfn(struct work_struct *work)\n{\n\tstruct sdtx_device *ddev = container_of(work, struct sdtx_device, mode_work.work);\n\tstruct sdtx_status_event event;\n\tstruct ssam_bas_base_info base;\n\tint status, tablet;\n\tu8 mode;\n\n\t \n\tstatus = ssam_retry(ssam_bas_get_device_mode, ddev->ctrl, &mode);\n\tif (status) {\n\t\tdev_err(ddev->dev, \"failed to get device mode: %d\\n\", status);\n\t\treturn;\n\t}\n\n\t \n\tstatus = ssam_retry(ssam_bas_get_base, ddev->ctrl, &base);\n\tif (status) {\n\t\tdev_err(ddev->dev, \"failed to get base info: %d\\n\", status);\n\t\treturn;\n\t}\n\n\t \n\tif (sdtx_device_mode_invalid(mode, base.state)) {\n\t\tdev_dbg(ddev->dev, \"device mode is invalid, trying again\\n\");\n\t\tsdtx_update_device_mode(ddev, SDTX_DEVICE_MODE_DELAY_RECHECK);\n\t\treturn;\n\t}\n\n\tmutex_lock(&ddev->write_lock);\n\tclear_bit(SDTX_DEVICE_DIRTY_MODE_BIT, &ddev->flags);\n\n\t \n\tif (ddev->state.device_mode == mode) {\n\t\tmutex_unlock(&ddev->write_lock);\n\t\treturn;\n\t}\n\n\tddev->state.device_mode = mode;\n\n\tevent.e.length = sizeof(u16);\n\tevent.e.code = SDTX_EVENT_DEVICE_MODE;\n\tevent.v = mode;\n\n\tsdtx_push_event(ddev, &event.e);\n\n\t \n\ttablet = mode != SDTX_DEVICE_MODE_LAPTOP;\n\tinput_report_switch(ddev->mode_switch, SW_TABLET_MODE, tablet);\n\tinput_sync(ddev->mode_switch);\n\n\tmutex_unlock(&ddev->write_lock);\n}\n\nstatic void sdtx_update_device_mode(struct sdtx_device *ddev, unsigned long delay)\n{\n\tschedule_delayed_work(&ddev->mode_work, delay);\n}\n\n \nstatic void __sdtx_device_state_update_base(struct sdtx_device *ddev,\n\t\t\t\t\t    struct ssam_bas_base_info info)\n{\n\tstruct sdtx_base_info_event event;\n\n\tlockdep_assert_held(&ddev->write_lock);\n\n\t \n\tif (ddev->state.base.state == info.state &&\n\t    ddev->state.base.base_id == info.base_id)\n\t\treturn;\n\n\tddev->state.base = info;\n\n\tevent.e.length = sizeof(struct sdtx_base_info);\n\tevent.e.code = SDTX_EVENT_BASE_CONNECTION;\n\tevent.v.state = sdtx_translate_base_state(ddev, info.state);\n\tevent.v.base_id = SDTX_BASE_TYPE_SSH(info.base_id);\n\n\tsdtx_push_event(ddev, &event.e);\n}\n\n \nstatic void __sdtx_device_state_update_mode(struct sdtx_device *ddev, u8 mode)\n{\n\tstruct sdtx_status_event event;\n\tint tablet;\n\n\t \n\n\tlockdep_assert_held(&ddev->write_lock);\n\n\tif (sdtx_device_mode_invalid(mode, ddev->state.base.state)) {\n\t\tdev_dbg(ddev->dev, \"device mode is invalid, trying again\\n\");\n\t\tsdtx_update_device_mode(ddev, SDTX_DEVICE_MODE_DELAY_RECHECK);\n\t\treturn;\n\t}\n\n\t \n\tif (ddev->state.device_mode == mode)\n\t\treturn;\n\n\tddev->state.device_mode = mode;\n\n\t \n\tevent.e.length = sizeof(u16);\n\tevent.e.code = SDTX_EVENT_DEVICE_MODE;\n\tevent.v = mode;\n\n\tsdtx_push_event(ddev, &event.e);\n\n\t \n\ttablet = mode != SDTX_DEVICE_MODE_LAPTOP;\n\tinput_report_switch(ddev->mode_switch, SW_TABLET_MODE, tablet);\n\tinput_sync(ddev->mode_switch);\n}\n\n \nstatic void __sdtx_device_state_update_latch(struct sdtx_device *ddev, u8 status)\n{\n\tstruct sdtx_status_event event;\n\n\tlockdep_assert_held(&ddev->write_lock);\n\n\t \n\tif (ddev->state.latch_status == status)\n\t\treturn;\n\n\tddev->state.latch_status = status;\n\n\tevent.e.length = sizeof(struct sdtx_base_info);\n\tevent.e.code = SDTX_EVENT_BASE_CONNECTION;\n\tevent.v = sdtx_translate_latch_status(ddev, status);\n\n\tsdtx_push_event(ddev, &event.e);\n}\n\nstatic void sdtx_device_state_workfn(struct work_struct *work)\n{\n\tstruct sdtx_device *ddev = container_of(work, struct sdtx_device, state_work.work);\n\tstruct ssam_bas_base_info base;\n\tu8 mode, latch;\n\tint status;\n\n\t \n\tset_bit(SDTX_DEVICE_DIRTY_BASE_BIT, &ddev->flags);\n\tset_bit(SDTX_DEVICE_DIRTY_MODE_BIT, &ddev->flags);\n\tset_bit(SDTX_DEVICE_DIRTY_LATCH_BIT, &ddev->flags);\n\n\t \n\tsmp_mb__after_atomic();\n\n\tstatus = ssam_retry(ssam_bas_get_base, ddev->ctrl, &base);\n\tif (status) {\n\t\tdev_err(ddev->dev, \"failed to get base state: %d\\n\", status);\n\t\treturn;\n\t}\n\n\tstatus = ssam_retry(ssam_bas_get_device_mode, ddev->ctrl, &mode);\n\tif (status) {\n\t\tdev_err(ddev->dev, \"failed to get device mode: %d\\n\", status);\n\t\treturn;\n\t}\n\n\tstatus = ssam_retry(ssam_bas_get_latch_status, ddev->ctrl, &latch);\n\tif (status) {\n\t\tdev_err(ddev->dev, \"failed to get latch status: %d\\n\", status);\n\t\treturn;\n\t}\n\n\tmutex_lock(&ddev->write_lock);\n\n\t \n\n\tif (test_and_clear_bit(SDTX_DEVICE_DIRTY_BASE_BIT, &ddev->flags))\n\t\t__sdtx_device_state_update_base(ddev, base);\n\n\tif (test_and_clear_bit(SDTX_DEVICE_DIRTY_MODE_BIT, &ddev->flags))\n\t\t__sdtx_device_state_update_mode(ddev, mode);\n\n\tif (test_and_clear_bit(SDTX_DEVICE_DIRTY_LATCH_BIT, &ddev->flags))\n\t\t__sdtx_device_state_update_latch(ddev, latch);\n\n\tmutex_unlock(&ddev->write_lock);\n}\n\nstatic void sdtx_update_device_state(struct sdtx_device *ddev, unsigned long delay)\n{\n\tschedule_delayed_work(&ddev->state_work, delay);\n}\n\n\n \n\nstatic int sdtx_device_init(struct sdtx_device *ddev, struct device *dev,\n\t\t\t    struct ssam_controller *ctrl)\n{\n\tint status, tablet_mode;\n\n\t \n\tkref_init(&ddev->kref);\n\tinit_rwsem(&ddev->lock);\n\tddev->dev = dev;\n\tddev->ctrl = ctrl;\n\n\tddev->mdev.minor = MISC_DYNAMIC_MINOR;\n\tddev->mdev.name = \"surface_dtx\";\n\tddev->mdev.nodename = \"surface/dtx\";\n\tddev->mdev.fops = &surface_dtx_fops;\n\n\tddev->notif.base.priority = 1;\n\tddev->notif.base.fn = sdtx_notifier;\n\tddev->notif.event.reg = SSAM_EVENT_REGISTRY_SAM;\n\tddev->notif.event.id.target_category = SSAM_SSH_TC_BAS;\n\tddev->notif.event.id.instance = 0;\n\tddev->notif.event.mask = SSAM_EVENT_MASK_NONE;\n\tddev->notif.event.flags = SSAM_EVENT_SEQUENCED;\n\n\tinit_waitqueue_head(&ddev->waitq);\n\tmutex_init(&ddev->write_lock);\n\tinit_rwsem(&ddev->client_lock);\n\tINIT_LIST_HEAD(&ddev->client_list);\n\n\tINIT_DELAYED_WORK(&ddev->mode_work, sdtx_device_mode_workfn);\n\tINIT_DELAYED_WORK(&ddev->state_work, sdtx_device_state_workfn);\n\n\t \n\tstatus = ssam_retry(ssam_bas_get_base, ddev->ctrl, &ddev->state.base);\n\tif (status)\n\t\treturn status;\n\n\tstatus = ssam_retry(ssam_bas_get_device_mode, ddev->ctrl, &ddev->state.device_mode);\n\tif (status)\n\t\treturn status;\n\n\tstatus = ssam_retry(ssam_bas_get_latch_status, ddev->ctrl, &ddev->state.latch_status);\n\tif (status)\n\t\treturn status;\n\n\t \n\tddev->mode_switch = input_allocate_device();\n\tif (!ddev->mode_switch)\n\t\treturn -ENOMEM;\n\n\tddev->mode_switch->name = \"Microsoft Surface DTX Device Mode Switch\";\n\tddev->mode_switch->phys = \"ssam/01:11:01:00:00/input0\";\n\tddev->mode_switch->id.bustype = BUS_HOST;\n\tddev->mode_switch->dev.parent = ddev->dev;\n\n\ttablet_mode = (ddev->state.device_mode != SDTX_DEVICE_MODE_LAPTOP);\n\tinput_set_capability(ddev->mode_switch, EV_SW, SW_TABLET_MODE);\n\tinput_report_switch(ddev->mode_switch, SW_TABLET_MODE, tablet_mode);\n\n\tstatus = input_register_device(ddev->mode_switch);\n\tif (status) {\n\t\tinput_free_device(ddev->mode_switch);\n\t\treturn status;\n\t}\n\n\t \n\tstatus = ssam_notifier_register(ddev->ctrl, &ddev->notif);\n\tif (status)\n\t\tgoto err_notif;\n\n\t \n\tstatus = misc_register(&ddev->mdev);\n\tif (status)\n\t\tgoto err_mdev;\n\n\t \n\tsdtx_update_device_state(ddev, 0);\n\treturn 0;\n\nerr_notif:\n\tssam_notifier_unregister(ddev->ctrl, &ddev->notif);\n\tcancel_delayed_work_sync(&ddev->mode_work);\nerr_mdev:\n\tinput_unregister_device(ddev->mode_switch);\n\treturn status;\n}\n\nstatic struct sdtx_device *sdtx_device_create(struct device *dev, struct ssam_controller *ctrl)\n{\n\tstruct sdtx_device *ddev;\n\tint status;\n\n\tddev = kzalloc(sizeof(*ddev), GFP_KERNEL);\n\tif (!ddev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tstatus = sdtx_device_init(ddev, dev, ctrl);\n\tif (status) {\n\t\tsdtx_device_put(ddev);\n\t\treturn ERR_PTR(status);\n\t}\n\n\treturn ddev;\n}\n\nstatic void sdtx_device_destroy(struct sdtx_device *ddev)\n{\n\tstruct sdtx_client *client;\n\n\t \n\tset_bit(SDTX_DEVICE_SHUTDOWN_BIT, &ddev->flags);\n\n\t \n\tssam_notifier_unregister(ddev->ctrl, &ddev->notif);\n\n\t \n\tcancel_delayed_work_sync(&ddev->mode_work);\n\n\t \n\tcancel_delayed_work_sync(&ddev->state_work);\n\n\t \n\tinput_unregister_device(ddev->mode_switch);\n\n\t \n\tdown_write(&ddev->client_lock);\n\tlist_for_each_entry(client, &ddev->client_list, node) {\n\t\tkill_fasync(&client->fasync, SIGIO, POLL_HUP);\n\t}\n\tup_write(&ddev->client_lock);\n\n\t \n\twake_up_interruptible(&ddev->waitq);\n\n\t \n\tdown_write(&ddev->lock);\n\tddev->dev = NULL;\n\tddev->ctrl = NULL;\n\tup_write(&ddev->lock);\n\n\t \n\tmisc_deregister(&ddev->mdev);\n\n\t \n\tsdtx_device_put(ddev);\n}\n\n\n \n\n#ifdef CONFIG_PM_SLEEP\n\nstatic void surface_dtx_pm_complete(struct device *dev)\n{\n\tstruct sdtx_device *ddev = dev_get_drvdata(dev);\n\n\t \n\tsdtx_update_device_state(ddev, msecs_to_jiffies(1000));\n}\n\nstatic const struct dev_pm_ops surface_dtx_pm_ops = {\n\t.complete = surface_dtx_pm_complete,\n};\n\n#else  \n\nstatic const struct dev_pm_ops surface_dtx_pm_ops = {};\n\n#endif  \n\n\n \n\nstatic int surface_dtx_platform_probe(struct platform_device *pdev)\n{\n\tstruct ssam_controller *ctrl;\n\tstruct sdtx_device *ddev;\n\n\t \n\tctrl = ssam_client_bind(&pdev->dev);\n\tif (IS_ERR(ctrl))\n\t\treturn PTR_ERR(ctrl) == -ENODEV ? -EPROBE_DEFER : PTR_ERR(ctrl);\n\n\tddev = sdtx_device_create(&pdev->dev, ctrl);\n\tif (IS_ERR(ddev))\n\t\treturn PTR_ERR(ddev);\n\n\tplatform_set_drvdata(pdev, ddev);\n\treturn 0;\n}\n\nstatic int surface_dtx_platform_remove(struct platform_device *pdev)\n{\n\tsdtx_device_destroy(platform_get_drvdata(pdev));\n\treturn 0;\n}\n\nstatic const struct acpi_device_id surface_dtx_acpi_match[] = {\n\t{ \"MSHW0133\", 0 },\n\t{ },\n};\nMODULE_DEVICE_TABLE(acpi, surface_dtx_acpi_match);\n\nstatic struct platform_driver surface_dtx_platform_driver = {\n\t.probe = surface_dtx_platform_probe,\n\t.remove = surface_dtx_platform_remove,\n\t.driver = {\n\t\t.name = \"surface_dtx_pltf\",\n\t\t.acpi_match_table = surface_dtx_acpi_match,\n\t\t.pm = &surface_dtx_pm_ops,\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t},\n};\n\n\n \n\n#ifdef CONFIG_SURFACE_AGGREGATOR_BUS\n\nstatic int surface_dtx_ssam_probe(struct ssam_device *sdev)\n{\n\tstruct sdtx_device *ddev;\n\n\tddev = sdtx_device_create(&sdev->dev, sdev->ctrl);\n\tif (IS_ERR(ddev))\n\t\treturn PTR_ERR(ddev);\n\n\tssam_device_set_drvdata(sdev, ddev);\n\treturn 0;\n}\n\nstatic void surface_dtx_ssam_remove(struct ssam_device *sdev)\n{\n\tsdtx_device_destroy(ssam_device_get_drvdata(sdev));\n}\n\nstatic const struct ssam_device_id surface_dtx_ssam_match[] = {\n\t{ SSAM_SDEV(BAS, SAM, 0x00, 0x00) },\n\t{ },\n};\nMODULE_DEVICE_TABLE(ssam, surface_dtx_ssam_match);\n\nstatic struct ssam_device_driver surface_dtx_ssam_driver = {\n\t.probe = surface_dtx_ssam_probe,\n\t.remove = surface_dtx_ssam_remove,\n\t.match_table = surface_dtx_ssam_match,\n\t.driver = {\n\t\t.name = \"surface_dtx\",\n\t\t.pm = &surface_dtx_pm_ops,\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t},\n};\n\nstatic int ssam_dtx_driver_register(void)\n{\n\treturn ssam_device_driver_register(&surface_dtx_ssam_driver);\n}\n\nstatic void ssam_dtx_driver_unregister(void)\n{\n\tssam_device_driver_unregister(&surface_dtx_ssam_driver);\n}\n\n#else  \n\nstatic int ssam_dtx_driver_register(void)\n{\n\treturn 0;\n}\n\nstatic void ssam_dtx_driver_unregister(void)\n{\n}\n\n#endif  \n\n\n \n\nstatic int __init surface_dtx_init(void)\n{\n\tint status;\n\n\tstatus = ssam_dtx_driver_register();\n\tif (status)\n\t\treturn status;\n\n\tstatus = platform_driver_register(&surface_dtx_platform_driver);\n\tif (status)\n\t\tssam_dtx_driver_unregister();\n\n\treturn status;\n}\nmodule_init(surface_dtx_init);\n\nstatic void __exit surface_dtx_exit(void)\n{\n\tplatform_driver_unregister(&surface_dtx_platform_driver);\n\tssam_dtx_driver_unregister();\n}\nmodule_exit(surface_dtx_exit);\n\nMODULE_AUTHOR(\"Maximilian Luz <luzmaximilian@gmail.com>\");\nMODULE_DESCRIPTION(\"Detachment-system driver for Surface System Aggregator Module\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}