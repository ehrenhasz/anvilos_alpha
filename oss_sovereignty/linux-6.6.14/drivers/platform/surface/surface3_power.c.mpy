{
  "module_name": "surface3_power.c",
  "hash_id": "4cf52d842c95421f5829ad7f37818f99dbbe8bcdce7c714ca317ea06679f94fb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/surface/surface3_power.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/bits.h>\n#include <linux/freezer.h>\n#include <linux/i2c.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/uuid.h>\n#include <asm/unaligned.h>\n\n#define SURFACE_3_POLL_INTERVAL\t\t(2 * HZ)\n#define SURFACE_3_STRLEN\t\t10\n\nstruct mshw0011_data {\n\tstruct i2c_client\t*adp1;\n\tstruct i2c_client\t*bat0;\n\tunsigned short\t\tnotify_mask;\n\tstruct task_struct\t*poll_task;\n\tbool\t\t\tkthread_running;\n\n\tbool\t\t\tcharging;\n\tbool\t\t\tbat_charging;\n\tu8\t\t\ttrip_point;\n\ts32\t\t\tfull_capacity;\n};\n\nstruct mshw0011_handler_data {\n\tstruct acpi_connection_info\tinfo;\n\tstruct i2c_client\t\t*client;\n};\n\nstruct bix {\n\tu32\trevision;\n\tu32\tpower_unit;\n\tu32\tdesign_capacity;\n\tu32\tlast_full_charg_capacity;\n\tu32\tbattery_technology;\n\tu32\tdesign_voltage;\n\tu32\tdesign_capacity_of_warning;\n\tu32\tdesign_capacity_of_low;\n\tu32\tcycle_count;\n\tu32\tmeasurement_accuracy;\n\tu32\tmax_sampling_time;\n\tu32\tmin_sampling_time;\n\tu32\tmax_average_interval;\n\tu32\tmin_average_interval;\n\tu32\tbattery_capacity_granularity_1;\n\tu32\tbattery_capacity_granularity_2;\n\tchar\tmodel[SURFACE_3_STRLEN];\n\tchar\tserial[SURFACE_3_STRLEN];\n\tchar\ttype[SURFACE_3_STRLEN];\n\tchar\tOEM[SURFACE_3_STRLEN];\n} __packed;\n\nstruct bst {\n\tu32\tbattery_state;\n\ts32\tbattery_present_rate;\n\tu32\tbattery_remaining_capacity;\n\tu32\tbattery_present_voltage;\n} __packed;\n\nstruct gsb_command {\n\tu8\targ0;\n\tu8\targ1;\n\tu8\targ2;\n} __packed;\n\nstruct gsb_buffer {\n\tu8\tstatus;\n\tu8\tlen;\n\tu8\tret;\n\tunion {\n\t\tstruct gsb_command\tcmd;\n\t\tstruct bst\t\tbst;\n\t\tstruct bix\t\tbix;\n\t} __packed;\n} __packed;\n\n#define ACPI_BATTERY_STATE_DISCHARGING\tBIT(0)\n#define ACPI_BATTERY_STATE_CHARGING\tBIT(1)\n#define ACPI_BATTERY_STATE_CRITICAL\tBIT(2)\n\n#define MSHW0011_CMD_DEST_BAT0\t\t0x01\n#define MSHW0011_CMD_DEST_ADP1\t\t0x03\n\n#define MSHW0011_CMD_BAT0_STA\t\t0x01\n#define MSHW0011_CMD_BAT0_BIX\t\t0x02\n#define MSHW0011_CMD_BAT0_BCT\t\t0x03\n#define MSHW0011_CMD_BAT0_BTM\t\t0x04\n#define MSHW0011_CMD_BAT0_BST\t\t0x05\n#define MSHW0011_CMD_BAT0_BTP\t\t0x06\n#define MSHW0011_CMD_ADP1_PSR\t\t0x07\n#define MSHW0011_CMD_BAT0_PSOC\t\t0x09\n#define MSHW0011_CMD_BAT0_PMAX\t\t0x0a\n#define MSHW0011_CMD_BAT0_PSRC\t\t0x0b\n#define MSHW0011_CMD_BAT0_CHGI\t\t0x0c\n#define MSHW0011_CMD_BAT0_ARTG\t\t0x0d\n\n#define MSHW0011_NOTIFY_GET_VERSION\t0x00\n#define MSHW0011_NOTIFY_ADP1\t\t0x01\n#define MSHW0011_NOTIFY_BAT0_BST\t0x02\n#define MSHW0011_NOTIFY_BAT0_BIX\t0x05\n\n#define MSHW0011_ADP1_REG_PSR\t\t0x04\n\n#define MSHW0011_BAT0_REG_CAPACITY\t\t0x0c\n#define MSHW0011_BAT0_REG_FULL_CHG_CAPACITY\t0x0e\n#define MSHW0011_BAT0_REG_DESIGN_CAPACITY\t0x40\n#define MSHW0011_BAT0_REG_VOLTAGE\t0x08\n#define MSHW0011_BAT0_REG_RATE\t\t0x14\n#define MSHW0011_BAT0_REG_OEM\t\t0x45\n#define MSHW0011_BAT0_REG_TYPE\t\t0x4e\n#define MSHW0011_BAT0_REG_SERIAL_NO\t0x56\n#define MSHW0011_BAT0_REG_CYCLE_CNT\t0x6e\n\n#define MSHW0011_EV_2_5_MASK\t\tGENMASK(8, 0)\n\n \nstatic const guid_t mshw0011_guid =\n\tGUID_INIT(0x3F99E367, 0x6220, 0x4955, 0x8B, 0x0F, 0x06, 0xEF,\n\t\t  0x2A, 0xE7, 0x94, 0x12);\n\nstatic int\nmshw0011_notify(struct mshw0011_data *cdata, u8 arg1, u8 arg2,\n\t\tunsigned int *ret_value)\n{\n\tunion acpi_object *obj;\n\tacpi_handle handle;\n\tunsigned int i;\n\n\thandle = ACPI_HANDLE(&cdata->adp1->dev);\n\tif (!handle)\n\t\treturn -ENODEV;\n\n\tobj = acpi_evaluate_dsm_typed(handle, &mshw0011_guid, arg1, arg2, NULL,\n\t\t\t\t      ACPI_TYPE_BUFFER);\n\tif (!obj) {\n\t\tdev_err(&cdata->adp1->dev, \"device _DSM execution failed\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t*ret_value = 0;\n\tfor (i = 0; i < obj->buffer.length; i++)\n\t\t*ret_value |= obj->buffer.pointer[i] << (i * 8);\n\n\tACPI_FREE(obj);\n\treturn 0;\n}\n\nstatic const struct bix default_bix = {\n\t.revision = 0x00,\n\t.power_unit = 0x01,\n\t.design_capacity = 0x1dca,\n\t.last_full_charg_capacity = 0x1dca,\n\t.battery_technology = 0x01,\n\t.design_voltage = 0x10df,\n\t.design_capacity_of_warning = 0x8f,\n\t.design_capacity_of_low = 0x47,\n\t.cycle_count = 0xffffffff,\n\t.measurement_accuracy = 0x00015f90,\n\t.max_sampling_time = 0x03e8,\n\t.min_sampling_time = 0x03e8,\n\t.max_average_interval = 0x03e8,\n\t.min_average_interval = 0x03e8,\n\t.battery_capacity_granularity_1 = 0x45,\n\t.battery_capacity_granularity_2 = 0x11,\n\t.model = \"P11G8M\",\n\t.serial = \"\",\n\t.type = \"LION\",\n\t.OEM = \"\",\n};\n\nstatic int mshw0011_bix(struct mshw0011_data *cdata, struct bix *bix)\n{\n\tstruct i2c_client *client = cdata->bat0;\n\tchar buf[SURFACE_3_STRLEN];\n\tint ret;\n\n\t*bix = default_bix;\n\n\t \n\tret = i2c_smbus_read_word_data(client,\n\t\t\t\t       MSHW0011_BAT0_REG_DESIGN_CAPACITY);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"Error reading design capacity: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\tbix->design_capacity = ret;\n\n\t \n\tret = i2c_smbus_read_word_data(client,\n\t\t\t\t       MSHW0011_BAT0_REG_FULL_CHG_CAPACITY);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev,\n\t\t\t\"Error reading last full charge capacity: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tbix->last_full_charg_capacity = ret;\n\n\t \n\tret = i2c_smbus_read_i2c_block_data(client, MSHW0011_BAT0_REG_SERIAL_NO,\n\t\t\t\t\t    sizeof(buf), buf);\n\tif (ret == -EREMOTEIO) {\n\t\t \n\t} else if (ret != sizeof(buf)) {\n\t\tdev_err(&client->dev, \"Error reading serial no: %d\\n\", ret);\n\t\treturn ret;\n\t} else {\n\t\tsnprintf(bix->serial, ARRAY_SIZE(bix->serial), \"%3pE%6pE\", buf + 7, buf);\n\t}\n\n\t \n\tret = i2c_smbus_read_word_data(client, MSHW0011_BAT0_REG_CYCLE_CNT);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"Error reading cycle count: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tbix->cycle_count = ret;\n\n\t \n\tret = i2c_smbus_read_i2c_block_data(client, MSHW0011_BAT0_REG_OEM,\n\t\t\t\t\t    4, buf);\n\tif (ret != 4) {\n\t\tdev_err(&client->dev, \"Error reading cycle count: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tsnprintf(bix->OEM, ARRAY_SIZE(bix->OEM), \"%3pE\", buf);\n\n\treturn 0;\n}\n\nstatic int mshw0011_bst(struct mshw0011_data *cdata, struct bst *bst)\n{\n\tstruct i2c_client *client = cdata->bat0;\n\tint rate, capacity, voltage, state;\n\ts16 tmp;\n\n\trate = i2c_smbus_read_word_data(client, MSHW0011_BAT0_REG_RATE);\n\tif (rate < 0)\n\t\treturn rate;\n\n\tcapacity = i2c_smbus_read_word_data(client, MSHW0011_BAT0_REG_CAPACITY);\n\tif (capacity < 0)\n\t\treturn capacity;\n\n\tvoltage = i2c_smbus_read_word_data(client, MSHW0011_BAT0_REG_VOLTAGE);\n\tif (voltage < 0)\n\t\treturn voltage;\n\n\ttmp = rate;\n\tbst->battery_present_rate = abs((s32)tmp);\n\n\tstate = 0;\n\tif ((s32) tmp > 0)\n\t\tstate |= ACPI_BATTERY_STATE_CHARGING;\n\telse if ((s32) tmp < 0)\n\t\tstate |= ACPI_BATTERY_STATE_DISCHARGING;\n\tbst->battery_state = state;\n\n\tbst->battery_remaining_capacity = capacity;\n\tbst->battery_present_voltage = voltage;\n\n\treturn 0;\n}\n\nstatic int mshw0011_adp_psr(struct mshw0011_data *cdata)\n{\n\treturn i2c_smbus_read_byte_data(cdata->adp1, MSHW0011_ADP1_REG_PSR);\n}\n\nstatic int mshw0011_isr(struct mshw0011_data *cdata)\n{\n\tstruct bst bst;\n\tstruct bix bix;\n\tint ret;\n\tbool status, bat_status;\n\n\tret = mshw0011_adp_psr(cdata);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tstatus = ret;\n\tif (status != cdata->charging)\n\t\tmshw0011_notify(cdata, cdata->notify_mask,\n\t\t\t\tMSHW0011_NOTIFY_ADP1, &ret);\n\n\tcdata->charging = status;\n\n\tret = mshw0011_bst(cdata, &bst);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tbat_status = bst.battery_state;\n\tif (bat_status != cdata->bat_charging)\n\t\tmshw0011_notify(cdata, cdata->notify_mask,\n\t\t\t\tMSHW0011_NOTIFY_BAT0_BST, &ret);\n\n\tcdata->bat_charging = bat_status;\n\n\tret = mshw0011_bix(cdata, &bix);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (bix.last_full_charg_capacity != cdata->full_capacity)\n\t\tmshw0011_notify(cdata, cdata->notify_mask,\n\t\t\t\tMSHW0011_NOTIFY_BAT0_BIX, &ret);\n\n\tcdata->full_capacity = bix.last_full_charg_capacity;\n\n\treturn 0;\n}\n\nstatic int mshw0011_poll_task(void *data)\n{\n\tstruct mshw0011_data *cdata = data;\n\tint ret = 0;\n\n\tcdata->kthread_running = true;\n\n\tset_freezable();\n\n\twhile (!kthread_should_stop()) {\n\t\tschedule_timeout_interruptible(SURFACE_3_POLL_INTERVAL);\n\t\ttry_to_freeze();\n\t\tret = mshw0011_isr(data);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\tcdata->kthread_running = false;\n\treturn ret;\n}\n\nstatic acpi_status\nmshw0011_space_handler(u32 function, acpi_physical_address command,\n\t\t\tu32 bits, u64 *value64,\n\t\t\tvoid *handler_context, void *region_context)\n{\n\tstruct gsb_buffer *gsb = (struct gsb_buffer *)value64;\n\tstruct mshw0011_handler_data *data = handler_context;\n\tstruct acpi_connection_info *info = &data->info;\n\tstruct acpi_resource_i2c_serialbus *sb;\n\tstruct i2c_client *client = data->client;\n\tstruct mshw0011_data *cdata = i2c_get_clientdata(client);\n\tstruct acpi_resource *ares;\n\tu32 accessor_type = function >> 16;\n\tacpi_status ret;\n\tint status = 1;\n\n\tret = acpi_buffer_to_resource(info->connection, info->length, &ares);\n\tif (ACPI_FAILURE(ret))\n\t\treturn ret;\n\n\tif (!value64 || !i2c_acpi_get_i2c_resource(ares, &sb)) {\n\t\tret = AE_BAD_PARAMETER;\n\t\tgoto err;\n\t}\n\n\tif (accessor_type != ACPI_GSB_ACCESS_ATTRIB_RAW_PROCESS) {\n\t\tret = AE_BAD_PARAMETER;\n\t\tgoto err;\n\t}\n\n\tif (gsb->cmd.arg0 == MSHW0011_CMD_DEST_ADP1 &&\n\t    gsb->cmd.arg1 == MSHW0011_CMD_ADP1_PSR) {\n\t\tstatus = mshw0011_adp_psr(cdata);\n\t\tif (status >= 0) {\n\t\t\tret = AE_OK;\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tret = AE_ERROR;\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tif (gsb->cmd.arg0 != MSHW0011_CMD_DEST_BAT0) {\n\t\tret = AE_BAD_PARAMETER;\n\t\tgoto err;\n\t}\n\n\tswitch (gsb->cmd.arg1) {\n\tcase MSHW0011_CMD_BAT0_STA:\n\t\tbreak;\n\tcase MSHW0011_CMD_BAT0_BIX:\n\t\tret = mshw0011_bix(cdata, &gsb->bix);\n\t\tbreak;\n\tcase MSHW0011_CMD_BAT0_BTP:\n\t\tcdata->trip_point = gsb->cmd.arg2;\n\t\tbreak;\n\tcase MSHW0011_CMD_BAT0_BST:\n\t\tret = mshw0011_bst(cdata, &gsb->bst);\n\t\tbreak;\n\tdefault:\n\t\tdev_info(&cdata->bat0->dev, \"command(0x%02x) is not supported.\\n\", gsb->cmd.arg1);\n\t\tret = AE_BAD_PARAMETER;\n\t\tgoto err;\n\t}\n\n out:\n\tgsb->ret = status;\n\tgsb->status = 0;\n\n err:\n\tACPI_FREE(ares);\n\treturn ret;\n}\n\nstatic int mshw0011_install_space_handler(struct i2c_client *client)\n{\n\tstruct acpi_device *adev;\n\tstruct mshw0011_handler_data *data;\n\tacpi_status status;\n\n\tadev = ACPI_COMPANION(&client->dev);\n\tif (!adev)\n\t\treturn -ENODEV;\n\n\tdata = kzalloc(sizeof(struct mshw0011_handler_data),\n\t\t\t    GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->client = client;\n\tstatus = acpi_bus_attach_private_data(adev->handle, (void *)data);\n\tif (ACPI_FAILURE(status)) {\n\t\tkfree(data);\n\t\treturn -ENOMEM;\n\t}\n\n\tstatus = acpi_install_address_space_handler(adev->handle,\n\t\t\t\t\t\t    ACPI_ADR_SPACE_GSBUS,\n\t\t\t\t\t\t    &mshw0011_space_handler,\n\t\t\t\t\t\t    NULL,\n\t\t\t\t\t\t    data);\n\tif (ACPI_FAILURE(status)) {\n\t\tdev_err(&client->dev, \"Error installing i2c space handler\\n\");\n\t\tacpi_bus_detach_private_data(adev->handle);\n\t\tkfree(data);\n\t\treturn -ENOMEM;\n\t}\n\n\tacpi_dev_clear_dependencies(adev);\n\treturn 0;\n}\n\nstatic void mshw0011_remove_space_handler(struct i2c_client *client)\n{\n\tstruct mshw0011_handler_data *data;\n\tacpi_handle handle;\n\tacpi_status status;\n\n\thandle = ACPI_HANDLE(&client->dev);\n\tif (!handle)\n\t\treturn;\n\n\tacpi_remove_address_space_handler(handle,\n\t\t\t\tACPI_ADR_SPACE_GSBUS,\n\t\t\t\t&mshw0011_space_handler);\n\n\tstatus = acpi_bus_get_private_data(handle, (void **)&data);\n\tif (ACPI_SUCCESS(status))\n\t\tkfree(data);\n\n\tacpi_bus_detach_private_data(handle);\n}\n\nstatic int mshw0011_probe(struct i2c_client *client)\n{\n\tstruct i2c_board_info board_info;\n\tstruct device *dev = &client->dev;\n\tstruct i2c_client *bat0;\n\tstruct mshw0011_data *data;\n\tint error, mask;\n\n\tdata = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->adp1 = client;\n\ti2c_set_clientdata(client, data);\n\n\tmemset(&board_info, 0, sizeof(board_info));\n\tstrscpy(board_info.type, \"MSHW0011-bat0\", I2C_NAME_SIZE);\n\n\tbat0 = i2c_acpi_new_device(dev, 1, &board_info);\n\tif (IS_ERR(bat0))\n\t\treturn PTR_ERR(bat0);\n\n\tdata->bat0 = bat0;\n\ti2c_set_clientdata(bat0, data);\n\n\terror = mshw0011_notify(data, 1, MSHW0011_NOTIFY_GET_VERSION, &mask);\n\tif (error)\n\t\tgoto out_err;\n\n\tdata->notify_mask = mask == MSHW0011_EV_2_5_MASK;\n\n\tdata->poll_task = kthread_run(mshw0011_poll_task, data, \"mshw0011_adp\");\n\tif (IS_ERR(data->poll_task)) {\n\t\terror = PTR_ERR(data->poll_task);\n\t\tdev_err(&client->dev, \"Unable to run kthread err %d\\n\", error);\n\t\tgoto out_err;\n\t}\n\n\terror = mshw0011_install_space_handler(client);\n\tif (error)\n\t\tgoto out_err;\n\n\treturn 0;\n\nout_err:\n\tif (data->kthread_running)\n\t\tkthread_stop(data->poll_task);\n\ti2c_unregister_device(data->bat0);\n\treturn error;\n}\n\nstatic void mshw0011_remove(struct i2c_client *client)\n{\n\tstruct mshw0011_data *cdata = i2c_get_clientdata(client);\n\n\tmshw0011_remove_space_handler(client);\n\n\tif (cdata->kthread_running)\n\t\tkthread_stop(cdata->poll_task);\n\n\ti2c_unregister_device(cdata->bat0);\n}\n\nstatic const struct acpi_device_id mshw0011_acpi_match[] = {\n\t{ \"MSHW0011\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(acpi, mshw0011_acpi_match);\n\nstatic struct i2c_driver mshw0011_driver = {\n\t.probe = mshw0011_probe,\n\t.remove = mshw0011_remove,\n\t.driver = {\n\t\t.name = \"mshw0011\",\n\t\t.acpi_match_table = mshw0011_acpi_match,\n\t},\n};\nmodule_i2c_driver(mshw0011_driver);\n\nMODULE_AUTHOR(\"Benjamin Tissoires <benjamin.tissoires@gmail.com>\");\nMODULE_DESCRIPTION(\"mshw0011 driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}