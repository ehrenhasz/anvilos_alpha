{
  "module_name": "controller.c",
  "hash_id": "b9b358953c61291fad56b3121d54fa71bb0ccf9e67885851af4cbee3b34f9e03",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/surface/aggregator/controller.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/atomic.h>\n#include <linux/completion.h>\n#include <linux/gpio/consumer.h>\n#include <linux/interrupt.h>\n#include <linux/kref.h>\n#include <linux/limits.h>\n#include <linux/list.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/rculist.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/serdev.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/srcu.h>\n#include <linux/types.h>\n#include <linux/workqueue.h>\n\n#include <linux/surface_aggregator/controller.h>\n#include <linux/surface_aggregator/serial_hub.h>\n\n#include \"controller.h\"\n#include \"ssh_msgb.h\"\n#include \"ssh_request_layer.h\"\n\n#include \"trace.h\"\n\n\n \n\n \nstatic void ssh_seq_reset(struct ssh_seq_counter *c)\n{\n\tWRITE_ONCE(c->value, 0);\n}\n\n \nstatic u8 ssh_seq_next(struct ssh_seq_counter *c)\n{\n\tu8 old = READ_ONCE(c->value);\n\tu8 new = old + 1;\n\tu8 ret;\n\n\twhile (unlikely((ret = cmpxchg(&c->value, old, new)) != old)) {\n\t\told = ret;\n\t\tnew = old + 1;\n\t}\n\n\treturn old;\n}\n\n \nstatic void ssh_rqid_reset(struct ssh_rqid_counter *c)\n{\n\tWRITE_ONCE(c->value, 0);\n}\n\n \nstatic u16 ssh_rqid_next(struct ssh_rqid_counter *c)\n{\n\tu16 old = READ_ONCE(c->value);\n\tu16 new = ssh_rqid_next_valid(old);\n\tu16 ret;\n\n\twhile (unlikely((ret = cmpxchg(&c->value, old, new)) != old)) {\n\t\told = ret;\n\t\tnew = ssh_rqid_next_valid(old);\n\t}\n\n\treturn old;\n}\n\n\n \n \n\n \nstatic bool ssam_event_matches_notifier(const struct ssam_event_notifier *n,\n\t\t\t\t\tconst struct ssam_event *event)\n{\n\tbool match = n->event.id.target_category == event->target_category;\n\n\tif (n->event.mask & SSAM_EVENT_MASK_TARGET)\n\t\tmatch &= n->event.reg.target_id == event->target_id;\n\n\tif (n->event.mask & SSAM_EVENT_MASK_INSTANCE)\n\t\tmatch &= n->event.id.instance == event->instance_id;\n\n\treturn match;\n}\n\n \nstatic int ssam_nfblk_call_chain(struct ssam_nf_head *nh, struct ssam_event *event)\n{\n\tstruct ssam_event_notifier *nf;\n\tint ret = 0, idx;\n\n\tidx = srcu_read_lock(&nh->srcu);\n\n\tlist_for_each_entry_rcu(nf, &nh->head, base.node,\n\t\t\t\tsrcu_read_lock_held(&nh->srcu)) {\n\t\tif (ssam_event_matches_notifier(nf, event)) {\n\t\t\tret = (ret & SSAM_NOTIF_STATE_MASK) | nf->base.fn(nf, event);\n\t\t\tif (ret & SSAM_NOTIF_STOP)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tsrcu_read_unlock(&nh->srcu, idx);\n\treturn ret;\n}\n\n \nstatic int ssam_nfblk_insert(struct ssam_nf_head *nh, struct ssam_notifier_block *nb)\n{\n\tstruct ssam_notifier_block *p;\n\tstruct list_head *h;\n\n\t \n\tlist_for_each(h, &nh->head) {\n\t\tp = list_entry(h, struct ssam_notifier_block, node);\n\n\t\tif (unlikely(p == nb)) {\n\t\t\tWARN(1, \"double register detected\");\n\t\t\treturn -EEXIST;\n\t\t}\n\n\t\tif (nb->priority > p->priority)\n\t\t\tbreak;\n\t}\n\n\tlist_add_tail_rcu(&nb->node, h);\n\treturn 0;\n}\n\n \nstatic bool ssam_nfblk_find(struct ssam_nf_head *nh, struct ssam_notifier_block *nb)\n{\n\tstruct ssam_notifier_block *p;\n\n\t \n\tlist_for_each_entry(p, &nh->head, node) {\n\t\tif (p == nb)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n \nstatic void ssam_nfblk_remove(struct ssam_notifier_block *nb)\n{\n\tlist_del_rcu(&nb->node);\n}\n\n \nstatic int ssam_nf_head_init(struct ssam_nf_head *nh)\n{\n\tint status;\n\n\tstatus = init_srcu_struct(&nh->srcu);\n\tif (status)\n\t\treturn status;\n\n\tINIT_LIST_HEAD(&nh->head);\n\treturn 0;\n}\n\n \nstatic void ssam_nf_head_destroy(struct ssam_nf_head *nh)\n{\n\tcleanup_srcu_struct(&nh->srcu);\n}\n\n\n \n\n \nstruct ssam_nf_refcount_key {\n\tstruct ssam_event_registry reg;\n\tstruct ssam_event_id id;\n};\n\n \nstruct ssam_nf_refcount_entry {\n\tstruct rb_node node;\n\tstruct ssam_nf_refcount_key key;\n\tint refcount;\n\tu8 flags;\n};\n\n \nstatic struct ssam_nf_refcount_entry *\nssam_nf_refcount_inc(struct ssam_nf *nf, struct ssam_event_registry reg,\n\t\t     struct ssam_event_id id)\n{\n\tstruct ssam_nf_refcount_entry *entry;\n\tstruct ssam_nf_refcount_key key;\n\tstruct rb_node **link = &nf->refcount.rb_node;\n\tstruct rb_node *parent = NULL;\n\tint cmp;\n\n\tlockdep_assert_held(&nf->lock);\n\n\tkey.reg = reg;\n\tkey.id = id;\n\n\twhile (*link) {\n\t\tentry = rb_entry(*link, struct ssam_nf_refcount_entry, node);\n\t\tparent = *link;\n\n\t\tcmp = memcmp(&key, &entry->key, sizeof(key));\n\t\tif (cmp < 0) {\n\t\t\tlink = &(*link)->rb_left;\n\t\t} else if (cmp > 0) {\n\t\t\tlink = &(*link)->rb_right;\n\t\t} else if (entry->refcount < INT_MAX) {\n\t\t\tentry->refcount++;\n\t\t\treturn entry;\n\t\t} else {\n\t\t\tWARN_ON(1);\n\t\t\treturn ERR_PTR(-ENOSPC);\n\t\t}\n\t}\n\n\tentry = kzalloc(sizeof(*entry), GFP_KERNEL);\n\tif (!entry)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tentry->key = key;\n\tentry->refcount = 1;\n\n\trb_link_node(&entry->node, parent, link);\n\trb_insert_color(&entry->node, &nf->refcount);\n\n\treturn entry;\n}\n\n \nstatic struct ssam_nf_refcount_entry *\nssam_nf_refcount_dec(struct ssam_nf *nf, struct ssam_event_registry reg,\n\t\t     struct ssam_event_id id)\n{\n\tstruct ssam_nf_refcount_entry *entry;\n\tstruct ssam_nf_refcount_key key;\n\tstruct rb_node *node = nf->refcount.rb_node;\n\tint cmp;\n\n\tlockdep_assert_held(&nf->lock);\n\n\tkey.reg = reg;\n\tkey.id = id;\n\n\twhile (node) {\n\t\tentry = rb_entry(node, struct ssam_nf_refcount_entry, node);\n\n\t\tcmp = memcmp(&key, &entry->key, sizeof(key));\n\t\tif (cmp < 0) {\n\t\t\tnode = node->rb_left;\n\t\t} else if (cmp > 0) {\n\t\t\tnode = node->rb_right;\n\t\t} else {\n\t\t\tentry->refcount--;\n\t\t\tif (entry->refcount == 0)\n\t\t\t\trb_erase(&entry->node, &nf->refcount);\n\n\t\t\treturn entry;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\n \nstatic void ssam_nf_refcount_dec_free(struct ssam_nf *nf,\n\t\t\t\t      struct ssam_event_registry reg,\n\t\t\t\t      struct ssam_event_id id)\n{\n\tstruct ssam_nf_refcount_entry *entry;\n\n\tlockdep_assert_held(&nf->lock);\n\n\tentry = ssam_nf_refcount_dec(nf, reg, id);\n\tif (entry && entry->refcount == 0)\n\t\tkfree(entry);\n}\n\n \nstatic bool ssam_nf_refcount_empty(struct ssam_nf *nf)\n{\n\treturn RB_EMPTY_ROOT(&nf->refcount);\n}\n\n \nstatic void ssam_nf_call(struct ssam_nf *nf, struct device *dev, u16 rqid,\n\t\t\t struct ssam_event *event)\n{\n\tstruct ssam_nf_head *nf_head;\n\tint status, nf_ret;\n\n\tif (!ssh_rqid_is_event(rqid)) {\n\t\tdev_warn(dev, \"event: unsupported rqid: %#06x\\n\", rqid);\n\t\treturn;\n\t}\n\n\tnf_head = &nf->head[ssh_rqid_to_event(rqid)];\n\tnf_ret = ssam_nfblk_call_chain(nf_head, event);\n\tstatus = ssam_notifier_to_errno(nf_ret);\n\n\tif (status < 0) {\n\t\tdev_err(dev,\n\t\t\t\"event: error handling event: %d (tc: %#04x, tid: %#04x, cid: %#04x, iid: %#04x)\\n\",\n\t\t\tstatus, event->target_category, event->target_id,\n\t\t\tevent->command_id, event->instance_id);\n\t} else if (!(nf_ret & SSAM_NOTIF_HANDLED)) {\n\t\tdev_warn(dev,\n\t\t\t \"event: unhandled event (rqid: %#04x, tc: %#04x, tid: %#04x, cid: %#04x, iid: %#04x)\\n\",\n\t\t\t rqid, event->target_category, event->target_id,\n\t\t\t event->command_id, event->instance_id);\n\t}\n}\n\n \nstatic int ssam_nf_init(struct ssam_nf *nf)\n{\n\tint i, status;\n\n\tfor (i = 0; i < SSH_NUM_EVENTS; i++) {\n\t\tstatus = ssam_nf_head_init(&nf->head[i]);\n\t\tif (status)\n\t\t\tbreak;\n\t}\n\n\tif (status) {\n\t\twhile (i--)\n\t\t\tssam_nf_head_destroy(&nf->head[i]);\n\n\t\treturn status;\n\t}\n\n\tmutex_init(&nf->lock);\n\treturn 0;\n}\n\n \nstatic void ssam_nf_destroy(struct ssam_nf *nf)\n{\n\tint i;\n\n\tfor (i = 0; i < SSH_NUM_EVENTS; i++)\n\t\tssam_nf_head_destroy(&nf->head[i]);\n\n\tmutex_destroy(&nf->lock);\n}\n\n\n \n\n#define SSAM_CPLT_WQ_NAME\t\"ssam_cpltq\"\n\n \n#define SSAM_CPLT_WQ_BATCH\t10\n\n \n#define SSAM_EVENT_ITEM_CACHE_PAYLOAD_LEN\t32\n\nstatic struct kmem_cache *ssam_event_item_cache;\n\n \nint ssam_event_item_cache_init(void)\n{\n\tconst unsigned int size = sizeof(struct ssam_event_item)\n\t\t\t\t  + SSAM_EVENT_ITEM_CACHE_PAYLOAD_LEN;\n\tconst unsigned int align = __alignof__(struct ssam_event_item);\n\tstruct kmem_cache *cache;\n\n\tcache = kmem_cache_create(\"ssam_event_item\", size, align, 0, NULL);\n\tif (!cache)\n\t\treturn -ENOMEM;\n\n\tssam_event_item_cache = cache;\n\treturn 0;\n}\n\n \nvoid ssam_event_item_cache_destroy(void)\n{\n\tkmem_cache_destroy(ssam_event_item_cache);\n\tssam_event_item_cache = NULL;\n}\n\nstatic void __ssam_event_item_free_cached(struct ssam_event_item *item)\n{\n\tkmem_cache_free(ssam_event_item_cache, item);\n}\n\nstatic void __ssam_event_item_free_generic(struct ssam_event_item *item)\n{\n\tkfree(item);\n}\n\n \nstatic void ssam_event_item_free(struct ssam_event_item *item)\n{\n\ttrace_ssam_event_item_free(item);\n\titem->ops.free(item);\n}\n\n \nstatic struct ssam_event_item *ssam_event_item_alloc(size_t len, gfp_t flags)\n{\n\tstruct ssam_event_item *item;\n\n\tif (len <= SSAM_EVENT_ITEM_CACHE_PAYLOAD_LEN) {\n\t\titem = kmem_cache_alloc(ssam_event_item_cache, flags);\n\t\tif (!item)\n\t\t\treturn NULL;\n\n\t\titem->ops.free = __ssam_event_item_free_cached;\n\t} else {\n\t\titem = kzalloc(struct_size(item, event.data, len), flags);\n\t\tif (!item)\n\t\t\treturn NULL;\n\n\t\titem->ops.free = __ssam_event_item_free_generic;\n\t}\n\n\titem->event.length = len;\n\n\ttrace_ssam_event_item_alloc(item, len);\n\treturn item;\n}\n\n \nstatic void ssam_event_queue_push(struct ssam_event_queue *q,\n\t\t\t\t  struct ssam_event_item *item)\n{\n\tspin_lock(&q->lock);\n\tlist_add_tail(&item->node, &q->head);\n\tspin_unlock(&q->lock);\n}\n\n \nstatic struct ssam_event_item *ssam_event_queue_pop(struct ssam_event_queue *q)\n{\n\tstruct ssam_event_item *item;\n\n\tspin_lock(&q->lock);\n\titem = list_first_entry_or_null(&q->head, struct ssam_event_item, node);\n\tif (item)\n\t\tlist_del(&item->node);\n\tspin_unlock(&q->lock);\n\n\treturn item;\n}\n\n \nstatic bool ssam_event_queue_is_empty(struct ssam_event_queue *q)\n{\n\tbool empty;\n\n\tspin_lock(&q->lock);\n\tempty = list_empty(&q->head);\n\tspin_unlock(&q->lock);\n\n\treturn empty;\n}\n\n \nstatic\nstruct ssam_event_queue *ssam_cplt_get_event_queue(struct ssam_cplt *cplt,\n\t\t\t\t\t\t   u8 tid, u16 rqid)\n{\n\tu16 event = ssh_rqid_to_event(rqid);\n\tu16 tidx = ssh_tid_to_index(tid);\n\n\tif (!ssh_rqid_is_event(rqid)) {\n\t\tdev_err(cplt->dev, \"event: unsupported request ID: %#06x\\n\", rqid);\n\t\treturn NULL;\n\t}\n\n\tif (!ssh_tid_is_valid(tid)) {\n\t\tdev_warn(cplt->dev, \"event: unsupported target ID: %u\\n\", tid);\n\t\ttidx = 0;\n\t}\n\n\treturn &cplt->event.target[tidx].queue[event];\n}\n\n \nstatic bool ssam_cplt_submit(struct ssam_cplt *cplt, struct work_struct *work)\n{\n\treturn queue_work(cplt->wq, work);\n}\n\n \nstatic int ssam_cplt_submit_event(struct ssam_cplt *cplt,\n\t\t\t\t  struct ssam_event_item *item)\n{\n\tstruct ssam_event_queue *evq;\n\n\tevq = ssam_cplt_get_event_queue(cplt, item->event.target_id, item->rqid);\n\tif (!evq)\n\t\treturn -EINVAL;\n\n\tssam_event_queue_push(evq, item);\n\tssam_cplt_submit(cplt, &evq->work);\n\treturn 0;\n}\n\n \nstatic void ssam_cplt_flush(struct ssam_cplt *cplt)\n{\n\tflush_workqueue(cplt->wq);\n}\n\nstatic void ssam_event_queue_work_fn(struct work_struct *work)\n{\n\tstruct ssam_event_queue *queue;\n\tstruct ssam_event_item *item;\n\tstruct ssam_nf *nf;\n\tstruct device *dev;\n\tunsigned int iterations = SSAM_CPLT_WQ_BATCH;\n\n\tqueue = container_of(work, struct ssam_event_queue, work);\n\tnf = &queue->cplt->event.notif;\n\tdev = queue->cplt->dev;\n\n\t \n\tdo {\n\t\titem = ssam_event_queue_pop(queue);\n\t\tif (!item)\n\t\t\treturn;\n\n\t\tssam_nf_call(nf, dev, item->rqid, &item->event);\n\t\tssam_event_item_free(item);\n\t} while (--iterations);\n\n\tif (!ssam_event_queue_is_empty(queue))\n\t\tssam_cplt_submit(queue->cplt, &queue->work);\n}\n\n \nstatic void ssam_event_queue_init(struct ssam_cplt *cplt,\n\t\t\t\t  struct ssam_event_queue *evq)\n{\n\tevq->cplt = cplt;\n\tspin_lock_init(&evq->lock);\n\tINIT_LIST_HEAD(&evq->head);\n\tINIT_WORK(&evq->work, ssam_event_queue_work_fn);\n}\n\n \nstatic int ssam_cplt_init(struct ssam_cplt *cplt, struct device *dev)\n{\n\tstruct ssam_event_target *target;\n\tint status, c, i;\n\n\tcplt->dev = dev;\n\n\tcplt->wq = alloc_workqueue(SSAM_CPLT_WQ_NAME, WQ_UNBOUND | WQ_MEM_RECLAIM, 0);\n\tif (!cplt->wq)\n\t\treturn -ENOMEM;\n\n\tfor (c = 0; c < ARRAY_SIZE(cplt->event.target); c++) {\n\t\ttarget = &cplt->event.target[c];\n\n\t\tfor (i = 0; i < ARRAY_SIZE(target->queue); i++)\n\t\t\tssam_event_queue_init(cplt, &target->queue[i]);\n\t}\n\n\tstatus = ssam_nf_init(&cplt->event.notif);\n\tif (status)\n\t\tdestroy_workqueue(cplt->wq);\n\n\treturn status;\n}\n\n \nstatic void ssam_cplt_destroy(struct ssam_cplt *cplt)\n{\n\t \n\tdestroy_workqueue(cplt->wq);\n\tssam_nf_destroy(&cplt->event.notif);\n}\n\n\n \n\n \nstruct device *ssam_controller_device(struct ssam_controller *c)\n{\n\treturn ssh_rtl_get_device(&c->rtl);\n}\nEXPORT_SYMBOL_GPL(ssam_controller_device);\n\nstatic void __ssam_controller_release(struct kref *kref)\n{\n\tstruct ssam_controller *ctrl = to_ssam_controller(kref, kref);\n\n\t \n\tssam_controller_lock(ctrl);\n\tssam_controller_destroy(ctrl);\n\tssam_controller_unlock(ctrl);\n\n\tkfree(ctrl);\n}\n\n \nstruct ssam_controller *ssam_controller_get(struct ssam_controller *c)\n{\n\tif (c)\n\t\tkref_get(&c->kref);\n\treturn c;\n}\nEXPORT_SYMBOL_GPL(ssam_controller_get);\n\n \nvoid ssam_controller_put(struct ssam_controller *c)\n{\n\tif (c)\n\t\tkref_put(&c->kref, __ssam_controller_release);\n}\nEXPORT_SYMBOL_GPL(ssam_controller_put);\n\n \nvoid ssam_controller_statelock(struct ssam_controller *c)\n{\n\tdown_read(&c->lock);\n}\nEXPORT_SYMBOL_GPL(ssam_controller_statelock);\n\n \nvoid ssam_controller_stateunlock(struct ssam_controller *c)\n{\n\tup_read(&c->lock);\n}\nEXPORT_SYMBOL_GPL(ssam_controller_stateunlock);\n\n \nvoid ssam_controller_lock(struct ssam_controller *c)\n{\n\tdown_write(&c->lock);\n}\n\n \nvoid ssam_controller_unlock(struct ssam_controller *c)\n{\n\tup_write(&c->lock);\n}\n\nstatic void ssam_handle_event(struct ssh_rtl *rtl,\n\t\t\t      const struct ssh_command *cmd,\n\t\t\t      const struct ssam_span *data)\n{\n\tstruct ssam_controller *ctrl = to_ssam_controller(rtl, rtl);\n\tstruct ssam_event_item *item;\n\n\titem = ssam_event_item_alloc(data->len, GFP_KERNEL);\n\tif (!item)\n\t\treturn;\n\n\titem->rqid = get_unaligned_le16(&cmd->rqid);\n\titem->event.target_category = cmd->tc;\n\titem->event.target_id = cmd->sid;\n\titem->event.command_id = cmd->cid;\n\titem->event.instance_id = cmd->iid;\n\tmemcpy(&item->event.data[0], data->ptr, data->len);\n\n\tif (WARN_ON(ssam_cplt_submit_event(&ctrl->cplt, item)))\n\t\tssam_event_item_free(item);\n}\n\nstatic const struct ssh_rtl_ops ssam_rtl_ops = {\n\t.handle_event = ssam_handle_event,\n};\n\nstatic bool ssam_notifier_is_empty(struct ssam_controller *ctrl);\nstatic void ssam_notifier_unregister_all(struct ssam_controller *ctrl);\n\n#define SSAM_SSH_DSM_REVISION\t0\n\n \nstatic const guid_t SSAM_SSH_DSM_GUID =\n\tGUID_INIT(0xd5e383e1, 0xd892, 0x4a76,\n\t\t  0x89, 0xfc, 0xf6, 0xaa, 0xae, 0x7e, 0xd5, 0xb5);\n\nenum ssh_dsm_fn {\n\tSSH_DSM_FN_SSH_POWER_PROFILE             = 0x05,\n\tSSH_DSM_FN_SCREEN_ON_SLEEP_IDLE_TIMEOUT  = 0x06,\n\tSSH_DSM_FN_SCREEN_OFF_SLEEP_IDLE_TIMEOUT = 0x07,\n\tSSH_DSM_FN_D3_CLOSES_HANDLE              = 0x08,\n\tSSH_DSM_FN_SSH_BUFFER_SIZE               = 0x09,\n};\n\nstatic int ssam_dsm_get_functions(acpi_handle handle, u64 *funcs)\n{\n\tunion acpi_object *obj;\n\tu64 mask = 0;\n\tint i;\n\n\t*funcs = 0;\n\n\t \n\tif (!acpi_has_method(handle, \"_DSM\"))\n\t\treturn 0;\n\n\tobj = acpi_evaluate_dsm_typed(handle, &SSAM_SSH_DSM_GUID,\n\t\t\t\t      SSAM_SSH_DSM_REVISION, 0, NULL,\n\t\t\t\t      ACPI_TYPE_BUFFER);\n\tif (!obj)\n\t\treturn -EIO;\n\n\tfor (i = 0; i < obj->buffer.length && i < 8; i++)\n\t\tmask |= (((u64)obj->buffer.pointer[i]) << (i * 8));\n\n\tif (mask & BIT(0))\n\t\t*funcs = mask;\n\n\tACPI_FREE(obj);\n\treturn 0;\n}\n\nstatic int ssam_dsm_load_u32(acpi_handle handle, u64 funcs, u64 func, u32 *ret)\n{\n\tunion acpi_object *obj;\n\tu64 val;\n\n\tif (!(funcs & BIT_ULL(func)))\n\t\treturn 0;  \n\n\tobj = acpi_evaluate_dsm_typed(handle, &SSAM_SSH_DSM_GUID,\n\t\t\t\t      SSAM_SSH_DSM_REVISION, func, NULL,\n\t\t\t\t      ACPI_TYPE_INTEGER);\n\tif (!obj)\n\t\treturn -EIO;\n\n\tval = obj->integer.value;\n\tACPI_FREE(obj);\n\n\tif (val > U32_MAX)\n\t\treturn -ERANGE;\n\n\t*ret = val;\n\treturn 0;\n}\n\n \nstatic\nint ssam_controller_caps_load_from_acpi(acpi_handle handle,\n\t\t\t\t\tstruct ssam_controller_caps *caps)\n{\n\tu32 d3_closes_handle = false;\n\tu64 funcs;\n\tint status;\n\n\t \n\tcaps->ssh_power_profile = U32_MAX;\n\tcaps->screen_on_sleep_idle_timeout = U32_MAX;\n\tcaps->screen_off_sleep_idle_timeout = U32_MAX;\n\tcaps->d3_closes_handle = false;\n\tcaps->ssh_buffer_size = U32_MAX;\n\n\t \n\tstatus = ssam_dsm_get_functions(handle, &funcs);\n\tif (status)\n\t\treturn status;\n\n\t \n\tstatus = ssam_dsm_load_u32(handle, funcs, SSH_DSM_FN_SSH_POWER_PROFILE,\n\t\t\t\t   &caps->ssh_power_profile);\n\tif (status)\n\t\treturn status;\n\n\tstatus = ssam_dsm_load_u32(handle, funcs,\n\t\t\t\t   SSH_DSM_FN_SCREEN_ON_SLEEP_IDLE_TIMEOUT,\n\t\t\t\t   &caps->screen_on_sleep_idle_timeout);\n\tif (status)\n\t\treturn status;\n\n\tstatus = ssam_dsm_load_u32(handle, funcs,\n\t\t\t\t   SSH_DSM_FN_SCREEN_OFF_SLEEP_IDLE_TIMEOUT,\n\t\t\t\t   &caps->screen_off_sleep_idle_timeout);\n\tif (status)\n\t\treturn status;\n\n\tstatus = ssam_dsm_load_u32(handle, funcs, SSH_DSM_FN_D3_CLOSES_HANDLE,\n\t\t\t\t   &d3_closes_handle);\n\tif (status)\n\t\treturn status;\n\n\tcaps->d3_closes_handle = !!d3_closes_handle;\n\n\tstatus = ssam_dsm_load_u32(handle, funcs, SSH_DSM_FN_SSH_BUFFER_SIZE,\n\t\t\t\t   &caps->ssh_buffer_size);\n\tif (status)\n\t\treturn status;\n\n\treturn 0;\n}\n\n \nint ssam_controller_init(struct ssam_controller *ctrl,\n\t\t\t struct serdev_device *serdev)\n{\n\tacpi_handle handle = ACPI_HANDLE(&serdev->dev);\n\tint status;\n\n\tinit_rwsem(&ctrl->lock);\n\tkref_init(&ctrl->kref);\n\n\tstatus = ssam_controller_caps_load_from_acpi(handle, &ctrl->caps);\n\tif (status)\n\t\treturn status;\n\n\tdev_dbg(&serdev->dev,\n\t\t\"device capabilities:\\n\"\n\t\t\"  ssh_power_profile:             %u\\n\"\n\t\t\"  ssh_buffer_size:               %u\\n\"\n\t\t\"  screen_on_sleep_idle_timeout:  %u\\n\"\n\t\t\"  screen_off_sleep_idle_timeout: %u\\n\"\n\t\t\"  d3_closes_handle:              %u\\n\",\n\t\tctrl->caps.ssh_power_profile,\n\t\tctrl->caps.ssh_buffer_size,\n\t\tctrl->caps.screen_on_sleep_idle_timeout,\n\t\tctrl->caps.screen_off_sleep_idle_timeout,\n\t\tctrl->caps.d3_closes_handle);\n\n\tssh_seq_reset(&ctrl->counter.seq);\n\tssh_rqid_reset(&ctrl->counter.rqid);\n\n\t \n\tstatus = ssam_cplt_init(&ctrl->cplt, &serdev->dev);\n\tif (status)\n\t\treturn status;\n\n\t \n\tstatus = ssh_rtl_init(&ctrl->rtl, serdev, &ssam_rtl_ops);\n\tif (status) {\n\t\tssam_cplt_destroy(&ctrl->cplt);\n\t\treturn status;\n\t}\n\n\t \n\tWRITE_ONCE(ctrl->state, SSAM_CONTROLLER_INITIALIZED);\n\treturn 0;\n}\n\n \nint ssam_controller_start(struct ssam_controller *ctrl)\n{\n\tint status;\n\n\tlockdep_assert_held_write(&ctrl->lock);\n\n\tif (ctrl->state != SSAM_CONTROLLER_INITIALIZED)\n\t\treturn -EINVAL;\n\n\tstatus = ssh_rtl_start(&ctrl->rtl);\n\tif (status)\n\t\treturn status;\n\n\t \n\tWRITE_ONCE(ctrl->state, SSAM_CONTROLLER_STARTED);\n\treturn 0;\n}\n\n \n#define SSAM_CTRL_SHUTDOWN_FLUSH_TIMEOUT\tmsecs_to_jiffies(5000)\n\n \nvoid ssam_controller_shutdown(struct ssam_controller *ctrl)\n{\n\tenum ssam_controller_state s = ctrl->state;\n\tint status;\n\n\tlockdep_assert_held_write(&ctrl->lock);\n\n\tif (s == SSAM_CONTROLLER_UNINITIALIZED || s == SSAM_CONTROLLER_STOPPED)\n\t\treturn;\n\n\t \n\tstatus = ssh_rtl_flush(&ctrl->rtl, SSAM_CTRL_SHUTDOWN_FLUSH_TIMEOUT);\n\tif (status) {\n\t\tssam_err(ctrl, \"failed to flush request transport layer: %d\\n\",\n\t\t\t status);\n\t}\n\n\t \n\tssam_cplt_flush(&ctrl->cplt);\n\n\t \n\tWARN_ON(!ssam_notifier_is_empty(ctrl));\n\n\t \n\tssam_notifier_unregister_all(ctrl);\n\n\t \n\tssh_rtl_shutdown(&ctrl->rtl);\n\n\t \n\tWRITE_ONCE(ctrl->state, SSAM_CONTROLLER_STOPPED);\n\tctrl->rtl.ptl.serdev = NULL;\n}\n\n \nvoid ssam_controller_destroy(struct ssam_controller *ctrl)\n{\n\tlockdep_assert_held_write(&ctrl->lock);\n\n\tif (ctrl->state == SSAM_CONTROLLER_UNINITIALIZED)\n\t\treturn;\n\n\tWARN_ON(ctrl->state != SSAM_CONTROLLER_STOPPED);\n\n\t \n\n\t \n\tssam_cplt_destroy(&ctrl->cplt);\n\tssh_rtl_destroy(&ctrl->rtl);\n\n\t \n\tWRITE_ONCE(ctrl->state, SSAM_CONTROLLER_UNINITIALIZED);\n}\n\n \nint ssam_controller_suspend(struct ssam_controller *ctrl)\n{\n\tssam_controller_lock(ctrl);\n\n\tif (ctrl->state != SSAM_CONTROLLER_STARTED) {\n\t\tssam_controller_unlock(ctrl);\n\t\treturn -EINVAL;\n\t}\n\n\tssam_dbg(ctrl, \"pm: suspending controller\\n\");\n\n\t \n\tWRITE_ONCE(ctrl->state, SSAM_CONTROLLER_SUSPENDED);\n\n\tssam_controller_unlock(ctrl);\n\treturn 0;\n}\n\n \nint ssam_controller_resume(struct ssam_controller *ctrl)\n{\n\tssam_controller_lock(ctrl);\n\n\tif (ctrl->state != SSAM_CONTROLLER_SUSPENDED) {\n\t\tssam_controller_unlock(ctrl);\n\t\treturn -EINVAL;\n\t}\n\n\tssam_dbg(ctrl, \"pm: resuming controller\\n\");\n\n\t \n\tWRITE_ONCE(ctrl->state, SSAM_CONTROLLER_STARTED);\n\n\tssam_controller_unlock(ctrl);\n\treturn 0;\n}\n\n\n \n\n \nssize_t ssam_request_write_data(struct ssam_span *buf,\n\t\t\t\tstruct ssam_controller *ctrl,\n\t\t\t\tconst struct ssam_request *spec)\n{\n\tstruct msgbuf msgb;\n\tu16 rqid;\n\tu8 seq;\n\n\tif (spec->length > SSH_COMMAND_MAX_PAYLOAD_SIZE)\n\t\treturn -EINVAL;\n\n\tif (SSH_COMMAND_MESSAGE_LENGTH(spec->length) > buf->len)\n\t\treturn -EINVAL;\n\n\tmsgb_init(&msgb, buf->ptr, buf->len);\n\tseq = ssh_seq_next(&ctrl->counter.seq);\n\trqid = ssh_rqid_next(&ctrl->counter.rqid);\n\tmsgb_push_cmd(&msgb, seq, rqid, spec);\n\n\treturn msgb_bytes_used(&msgb);\n}\nEXPORT_SYMBOL_GPL(ssam_request_write_data);\n\nstatic void ssam_request_sync_complete(struct ssh_request *rqst,\n\t\t\t\t       const struct ssh_command *cmd,\n\t\t\t\t       const struct ssam_span *data, int status)\n{\n\tstruct ssh_rtl *rtl = ssh_request_rtl(rqst);\n\tstruct ssam_request_sync *r;\n\n\tr = container_of(rqst, struct ssam_request_sync, base);\n\tr->status = status;\n\n\tif (r->resp)\n\t\tr->resp->length = 0;\n\n\tif (status) {\n\t\trtl_dbg_cond(rtl, \"rsp: request failed: %d\\n\", status);\n\t\treturn;\n\t}\n\n\tif (!data)\t \n\t\treturn;\n\n\tif (!r->resp || !r->resp->pointer) {\n\t\tif (data->len)\n\t\t\trtl_warn(rtl, \"rsp: no response buffer provided, dropping data\\n\");\n\t\treturn;\n\t}\n\n\tif (data->len > r->resp->capacity) {\n\t\trtl_err(rtl,\n\t\t\t\"rsp: response buffer too small, capacity: %zu bytes, got: %zu bytes\\n\",\n\t\t\tr->resp->capacity, data->len);\n\t\tr->status = -ENOSPC;\n\t\treturn;\n\t}\n\n\tr->resp->length = data->len;\n\tmemcpy(r->resp->pointer, data->ptr, data->len);\n}\n\nstatic void ssam_request_sync_release(struct ssh_request *rqst)\n{\n\tcomplete_all(&container_of(rqst, struct ssam_request_sync, base)->comp);\n}\n\nstatic const struct ssh_request_ops ssam_request_sync_ops = {\n\t.release = ssam_request_sync_release,\n\t.complete = ssam_request_sync_complete,\n};\n\n \nint ssam_request_sync_alloc(size_t payload_len, gfp_t flags,\n\t\t\t    struct ssam_request_sync **rqst,\n\t\t\t    struct ssam_span *buffer)\n{\n\tsize_t msglen = SSH_COMMAND_MESSAGE_LENGTH(payload_len);\n\n\t*rqst = kzalloc(sizeof(**rqst) + msglen, flags);\n\tif (!*rqst)\n\t\treturn -ENOMEM;\n\n\tbuffer->ptr = (u8 *)(*rqst + 1);\n\tbuffer->len = msglen;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ssam_request_sync_alloc);\n\n \nvoid ssam_request_sync_free(struct ssam_request_sync *rqst)\n{\n\tkfree(rqst);\n}\nEXPORT_SYMBOL_GPL(ssam_request_sync_free);\n\n \nint ssam_request_sync_init(struct ssam_request_sync *rqst,\n\t\t\t   enum ssam_request_flags flags)\n{\n\tint status;\n\n\tstatus = ssh_request_init(&rqst->base, flags, &ssam_request_sync_ops);\n\tif (status)\n\t\treturn status;\n\n\tinit_completion(&rqst->comp);\n\trqst->resp = NULL;\n\trqst->status = 0;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ssam_request_sync_init);\n\n \nint ssam_request_sync_submit(struct ssam_controller *ctrl,\n\t\t\t     struct ssam_request_sync *rqst)\n{\n\tint status;\n\n\t \n\tif (WARN_ON(READ_ONCE(ctrl->state) != SSAM_CONTROLLER_STARTED)) {\n\t\tssh_request_put(&rqst->base);\n\t\treturn -ENODEV;\n\t}\n\n\tstatus = ssh_rtl_submit(&ctrl->rtl, &rqst->base);\n\tssh_request_put(&rqst->base);\n\n\treturn status;\n}\nEXPORT_SYMBOL_GPL(ssam_request_sync_submit);\n\n \nint ssam_request_do_sync(struct ssam_controller *ctrl,\n\t\t\t const struct ssam_request *spec,\n\t\t\t struct ssam_response *rsp)\n{\n\tstruct ssam_request_sync *rqst;\n\tstruct ssam_span buf;\n\tssize_t len;\n\tint status;\n\n\tstatus = ssam_request_sync_alloc(spec->length, GFP_KERNEL, &rqst, &buf);\n\tif (status)\n\t\treturn status;\n\n\tstatus = ssam_request_sync_init(rqst, spec->flags);\n\tif (status) {\n\t\tssam_request_sync_free(rqst);\n\t\treturn status;\n\t}\n\n\tssam_request_sync_set_resp(rqst, rsp);\n\n\tlen = ssam_request_write_data(&buf, ctrl, spec);\n\tif (len < 0) {\n\t\tssam_request_sync_free(rqst);\n\t\treturn len;\n\t}\n\n\tssam_request_sync_set_data(rqst, buf.ptr, len);\n\n\tstatus = ssam_request_sync_submit(ctrl, rqst);\n\tif (!status)\n\t\tstatus = ssam_request_sync_wait(rqst);\n\n\tssam_request_sync_free(rqst);\n\treturn status;\n}\nEXPORT_SYMBOL_GPL(ssam_request_do_sync);\n\n \nint ssam_request_do_sync_with_buffer(struct ssam_controller *ctrl,\n\t\t\t\t     const struct ssam_request *spec,\n\t\t\t\t     struct ssam_response *rsp,\n\t\t\t\t     struct ssam_span *buf)\n{\n\tstruct ssam_request_sync rqst;\n\tssize_t len;\n\tint status;\n\n\tstatus = ssam_request_sync_init(&rqst, spec->flags);\n\tif (status)\n\t\treturn status;\n\n\tssam_request_sync_set_resp(&rqst, rsp);\n\n\tlen = ssam_request_write_data(buf, ctrl, spec);\n\tif (len < 0)\n\t\treturn len;\n\n\tssam_request_sync_set_data(&rqst, buf->ptr, len);\n\n\tstatus = ssam_request_sync_submit(ctrl, &rqst);\n\tif (!status)\n\t\tstatus = ssam_request_sync_wait(&rqst);\n\n\treturn status;\n}\nEXPORT_SYMBOL_GPL(ssam_request_do_sync_with_buffer);\n\n\n \n\nSSAM_DEFINE_SYNC_REQUEST_R(ssam_ssh_get_firmware_version, __le32, {\n\t.target_category = SSAM_SSH_TC_SAM,\n\t.target_id       = SSAM_SSH_TID_SAM,\n\t.command_id      = 0x13,\n\t.instance_id     = 0x00,\n});\n\nSSAM_DEFINE_SYNC_REQUEST_R(ssam_ssh_notif_display_off, u8, {\n\t.target_category = SSAM_SSH_TC_SAM,\n\t.target_id       = SSAM_SSH_TID_SAM,\n\t.command_id      = 0x15,\n\t.instance_id     = 0x00,\n});\n\nSSAM_DEFINE_SYNC_REQUEST_R(ssam_ssh_notif_display_on, u8, {\n\t.target_category = SSAM_SSH_TC_SAM,\n\t.target_id       = SSAM_SSH_TID_SAM,\n\t.command_id      = 0x16,\n\t.instance_id     = 0x00,\n});\n\nSSAM_DEFINE_SYNC_REQUEST_R(ssam_ssh_notif_d0_exit, u8, {\n\t.target_category = SSAM_SSH_TC_SAM,\n\t.target_id       = SSAM_SSH_TID_SAM,\n\t.command_id      = 0x33,\n\t.instance_id     = 0x00,\n});\n\nSSAM_DEFINE_SYNC_REQUEST_R(ssam_ssh_notif_d0_entry, u8, {\n\t.target_category = SSAM_SSH_TC_SAM,\n\t.target_id       = SSAM_SSH_TID_SAM,\n\t.command_id      = 0x34,\n\t.instance_id     = 0x00,\n});\n\n \nstruct ssh_notification_params {\n\tu8 target_category;\n\tu8 flags;\n\t__le16 request_id;\n\tu8 instance_id;\n} __packed;\n\nstatic_assert(sizeof(struct ssh_notification_params) == 5);\n\nstatic int __ssam_ssh_event_request(struct ssam_controller *ctrl,\n\t\t\t\t    struct ssam_event_registry reg, u8 cid,\n\t\t\t\t    struct ssam_event_id id, u8 flags)\n{\n\tstruct ssh_notification_params params;\n\tstruct ssam_request rqst;\n\tstruct ssam_response result;\n\tint status;\n\n\tu16 rqid = ssh_tc_to_rqid(id.target_category);\n\tu8 buf = 0;\n\n\t \n\tif (!ssh_rqid_is_event(rqid))\n\t\treturn -EINVAL;\n\n\tparams.target_category = id.target_category;\n\tparams.instance_id = id.instance;\n\tparams.flags = flags;\n\tput_unaligned_le16(rqid, &params.request_id);\n\n\trqst.target_category = reg.target_category;\n\trqst.target_id = reg.target_id;\n\trqst.command_id = cid;\n\trqst.instance_id = 0x00;\n\trqst.flags = SSAM_REQUEST_HAS_RESPONSE;\n\trqst.length = sizeof(params);\n\trqst.payload = (u8 *)&params;\n\n\tresult.capacity = sizeof(buf);\n\tresult.length = 0;\n\tresult.pointer = &buf;\n\n\tstatus = ssam_retry(ssam_request_do_sync_onstack, ctrl, &rqst, &result,\n\t\t\t    sizeof(params));\n\n\treturn status < 0 ? status : buf;\n}\n\n \nstatic int ssam_ssh_event_enable(struct ssam_controller *ctrl,\n\t\t\t\t struct ssam_event_registry reg,\n\t\t\t\t struct ssam_event_id id, u8 flags)\n{\n\tint status;\n\n\tstatus = __ssam_ssh_event_request(ctrl, reg, reg.cid_enable, id, flags);\n\n\tif (status < 0 && status != -EINVAL) {\n\t\tssam_err(ctrl,\n\t\t\t \"failed to enable event source (tc: %#04x, iid: %#04x, reg: %#04x)\\n\",\n\t\t\t id.target_category, id.instance, reg.target_category);\n\t}\n\n\tif (status > 0) {\n\t\tssam_err(ctrl,\n\t\t\t \"unexpected result while enabling event source: %#04x (tc: %#04x, iid: %#04x, reg: %#04x)\\n\",\n\t\t\t status, id.target_category, id.instance, reg.target_category);\n\t\treturn -EPROTO;\n\t}\n\n\treturn status;\n}\n\n \nstatic int ssam_ssh_event_disable(struct ssam_controller *ctrl,\n\t\t\t\t  struct ssam_event_registry reg,\n\t\t\t\t  struct ssam_event_id id, u8 flags)\n{\n\tint status;\n\n\tstatus = __ssam_ssh_event_request(ctrl, reg, reg.cid_disable, id, flags);\n\n\tif (status < 0 && status != -EINVAL) {\n\t\tssam_err(ctrl,\n\t\t\t \"failed to disable event source (tc: %#04x, iid: %#04x, reg: %#04x)\\n\",\n\t\t\t id.target_category, id.instance, reg.target_category);\n\t}\n\n\tif (status > 0) {\n\t\tssam_err(ctrl,\n\t\t\t \"unexpected result while disabling event source: %#04x (tc: %#04x, iid: %#04x, reg: %#04x)\\n\",\n\t\t\t status, id.target_category, id.instance, reg.target_category);\n\t\treturn -EPROTO;\n\t}\n\n\treturn status;\n}\n\n\n \n\n \nint ssam_get_firmware_version(struct ssam_controller *ctrl, u32 *version)\n{\n\t__le32 __version;\n\tint status;\n\n\tstatus = ssam_retry(ssam_ssh_get_firmware_version, ctrl, &__version);\n\tif (status)\n\t\treturn status;\n\n\t*version = le32_to_cpu(__version);\n\treturn 0;\n}\n\n \nint ssam_ctrl_notif_display_off(struct ssam_controller *ctrl)\n{\n\tint status;\n\tu8 response;\n\n\tssam_dbg(ctrl, \"pm: notifying display off\\n\");\n\n\tstatus = ssam_retry(ssam_ssh_notif_display_off, ctrl, &response);\n\tif (status)\n\t\treturn status;\n\n\tif (response != 0) {\n\t\tssam_err(ctrl, \"unexpected response from display-off notification: %#04x\\n\",\n\t\t\t response);\n\t\treturn -EPROTO;\n\t}\n\n\treturn 0;\n}\n\n \nint ssam_ctrl_notif_display_on(struct ssam_controller *ctrl)\n{\n\tint status;\n\tu8 response;\n\n\tssam_dbg(ctrl, \"pm: notifying display on\\n\");\n\n\tstatus = ssam_retry(ssam_ssh_notif_display_on, ctrl, &response);\n\tif (status)\n\t\treturn status;\n\n\tif (response != 0) {\n\t\tssam_err(ctrl, \"unexpected response from display-on notification: %#04x\\n\",\n\t\t\t response);\n\t\treturn -EPROTO;\n\t}\n\n\treturn 0;\n}\n\n \nint ssam_ctrl_notif_d0_exit(struct ssam_controller *ctrl)\n{\n\tint status;\n\tu8 response;\n\n\tif (!ctrl->caps.d3_closes_handle)\n\t\treturn 0;\n\n\tssam_dbg(ctrl, \"pm: notifying D0 exit\\n\");\n\n\tstatus = ssam_retry(ssam_ssh_notif_d0_exit, ctrl, &response);\n\tif (status)\n\t\treturn status;\n\n\tif (response != 0) {\n\t\tssam_err(ctrl, \"unexpected response from D0-exit notification: %#04x\\n\",\n\t\t\t response);\n\t\treturn -EPROTO;\n\t}\n\n\treturn 0;\n}\n\n \nint ssam_ctrl_notif_d0_entry(struct ssam_controller *ctrl)\n{\n\tint status;\n\tu8 response;\n\n\tif (!ctrl->caps.d3_closes_handle)\n\t\treturn 0;\n\n\tssam_dbg(ctrl, \"pm: notifying D0 entry\\n\");\n\n\tstatus = ssam_retry(ssam_ssh_notif_d0_entry, ctrl, &response);\n\tif (status)\n\t\treturn status;\n\n\tif (response != 0) {\n\t\tssam_err(ctrl, \"unexpected response from D0-entry notification: %#04x\\n\",\n\t\t\t response);\n\t\treturn -EPROTO;\n\t}\n\n\treturn 0;\n}\n\n\n \n\n \nstatic int ssam_nf_refcount_enable(struct ssam_controller *ctrl,\n\t\t\t\t   struct ssam_nf_refcount_entry *entry, u8 flags)\n{\n\tconst struct ssam_event_registry reg = entry->key.reg;\n\tconst struct ssam_event_id id = entry->key.id;\n\tstruct ssam_nf *nf = &ctrl->cplt.event.notif;\n\tint status;\n\n\tlockdep_assert_held(&nf->lock);\n\n\tssam_dbg(ctrl, \"enabling event (reg: %#04x, tc: %#04x, iid: %#04x, rc: %d)\\n\",\n\t\t reg.target_category, id.target_category, id.instance, entry->refcount);\n\n\tif (entry->refcount == 1) {\n\t\tstatus = ssam_ssh_event_enable(ctrl, reg, id, flags);\n\t\tif (status)\n\t\t\treturn status;\n\n\t\tentry->flags = flags;\n\n\t} else if (entry->flags != flags) {\n\t\tssam_warn(ctrl,\n\t\t\t  \"inconsistent flags when enabling event: got %#04x, expected %#04x (reg: %#04x, tc: %#04x, iid: %#04x)\\n\",\n\t\t\t  flags, entry->flags, reg.target_category, id.target_category,\n\t\t\t  id.instance);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int ssam_nf_refcount_disable_free(struct ssam_controller *ctrl,\n\t\t\t\t\t struct ssam_nf_refcount_entry *entry, u8 flags, bool ec)\n{\n\tconst struct ssam_event_registry reg = entry->key.reg;\n\tconst struct ssam_event_id id = entry->key.id;\n\tstruct ssam_nf *nf = &ctrl->cplt.event.notif;\n\tint status = 0;\n\n\tlockdep_assert_held(&nf->lock);\n\n\tssam_dbg(ctrl, \"%s event (reg: %#04x, tc: %#04x, iid: %#04x, rc: %d)\\n\",\n\t\t ec ? \"disabling\" : \"detaching\", reg.target_category, id.target_category,\n\t\t id.instance, entry->refcount);\n\n\tif (entry->flags != flags) {\n\t\tssam_warn(ctrl,\n\t\t\t  \"inconsistent flags when disabling event: got %#04x, expected %#04x (reg: %#04x, tc: %#04x, iid: %#04x)\\n\",\n\t\t\t  flags, entry->flags, reg.target_category, id.target_category,\n\t\t\t  id.instance);\n\t}\n\n\tif (ec && entry->refcount == 0) {\n\t\tstatus = ssam_ssh_event_disable(ctrl, reg, id, flags);\n\t\tkfree(entry);\n\t}\n\n\treturn status;\n}\n\n \nint ssam_notifier_register(struct ssam_controller *ctrl, struct ssam_event_notifier *n)\n{\n\tu16 rqid = ssh_tc_to_rqid(n->event.id.target_category);\n\tstruct ssam_nf_refcount_entry *entry = NULL;\n\tstruct ssam_nf_head *nf_head;\n\tstruct ssam_nf *nf;\n\tint status;\n\n\tif (!ssh_rqid_is_event(rqid))\n\t\treturn -EINVAL;\n\n\tnf = &ctrl->cplt.event.notif;\n\tnf_head = &nf->head[ssh_rqid_to_event(rqid)];\n\n\tmutex_lock(&nf->lock);\n\n\tif (!(n->flags & SSAM_EVENT_NOTIFIER_OBSERVER)) {\n\t\tentry = ssam_nf_refcount_inc(nf, n->event.reg, n->event.id);\n\t\tif (IS_ERR(entry)) {\n\t\t\tmutex_unlock(&nf->lock);\n\t\t\treturn PTR_ERR(entry);\n\t\t}\n\t}\n\n\tstatus = ssam_nfblk_insert(nf_head, &n->base);\n\tif (status) {\n\t\tif (entry)\n\t\t\tssam_nf_refcount_dec_free(nf, n->event.reg, n->event.id);\n\n\t\tmutex_unlock(&nf->lock);\n\t\treturn status;\n\t}\n\n\tif (entry) {\n\t\tstatus = ssam_nf_refcount_enable(ctrl, entry, n->event.flags);\n\t\tif (status) {\n\t\t\tssam_nfblk_remove(&n->base);\n\t\t\tssam_nf_refcount_dec_free(nf, n->event.reg, n->event.id);\n\t\t\tmutex_unlock(&nf->lock);\n\t\t\tsynchronize_srcu(&nf_head->srcu);\n\t\t\treturn status;\n\t\t}\n\t}\n\n\tmutex_unlock(&nf->lock);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ssam_notifier_register);\n\n \nint __ssam_notifier_unregister(struct ssam_controller *ctrl, struct ssam_event_notifier *n,\n\t\t\t       bool disable)\n{\n\tu16 rqid = ssh_tc_to_rqid(n->event.id.target_category);\n\tstruct ssam_nf_refcount_entry *entry;\n\tstruct ssam_nf_head *nf_head;\n\tstruct ssam_nf *nf;\n\tint status = 0;\n\n\tif (!ssh_rqid_is_event(rqid))\n\t\treturn -EINVAL;\n\n\tnf = &ctrl->cplt.event.notif;\n\tnf_head = &nf->head[ssh_rqid_to_event(rqid)];\n\n\tmutex_lock(&nf->lock);\n\n\tif (!ssam_nfblk_find(nf_head, &n->base)) {\n\t\tmutex_unlock(&nf->lock);\n\t\treturn -ENOENT;\n\t}\n\n\t \n\tif (!(n->flags & SSAM_EVENT_NOTIFIER_OBSERVER)) {\n\t\tentry = ssam_nf_refcount_dec(nf, n->event.reg, n->event.id);\n\t\tif (WARN_ON(!entry)) {\n\t\t\t \n\t\t\tstatus = -ENOENT;\n\t\t\tgoto remove;\n\t\t}\n\n\t\tstatus = ssam_nf_refcount_disable_free(ctrl, entry, n->event.flags, disable);\n\t}\n\nremove:\n\tssam_nfblk_remove(&n->base);\n\tmutex_unlock(&nf->lock);\n\tsynchronize_srcu(&nf_head->srcu);\n\n\treturn status;\n}\nEXPORT_SYMBOL_GPL(__ssam_notifier_unregister);\n\n \nint ssam_controller_event_enable(struct ssam_controller *ctrl,\n\t\t\t\t struct ssam_event_registry reg,\n\t\t\t\t struct ssam_event_id id, u8 flags)\n{\n\tu16 rqid = ssh_tc_to_rqid(id.target_category);\n\tstruct ssam_nf *nf = &ctrl->cplt.event.notif;\n\tstruct ssam_nf_refcount_entry *entry;\n\tint status;\n\n\tif (!ssh_rqid_is_event(rqid))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&nf->lock);\n\n\tentry = ssam_nf_refcount_inc(nf, reg, id);\n\tif (IS_ERR(entry)) {\n\t\tmutex_unlock(&nf->lock);\n\t\treturn PTR_ERR(entry);\n\t}\n\n\tstatus = ssam_nf_refcount_enable(ctrl, entry, flags);\n\tif (status) {\n\t\tssam_nf_refcount_dec_free(nf, reg, id);\n\t\tmutex_unlock(&nf->lock);\n\t\treturn status;\n\t}\n\n\tmutex_unlock(&nf->lock);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ssam_controller_event_enable);\n\n \nint ssam_controller_event_disable(struct ssam_controller *ctrl,\n\t\t\t\t  struct ssam_event_registry reg,\n\t\t\t\t  struct ssam_event_id id, u8 flags)\n{\n\tu16 rqid = ssh_tc_to_rqid(id.target_category);\n\tstruct ssam_nf *nf = &ctrl->cplt.event.notif;\n\tstruct ssam_nf_refcount_entry *entry;\n\tint status;\n\n\tif (!ssh_rqid_is_event(rqid))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&nf->lock);\n\n\tentry = ssam_nf_refcount_dec(nf, reg, id);\n\tif (!entry) {\n\t\tmutex_unlock(&nf->lock);\n\t\treturn -ENOENT;\n\t}\n\n\tstatus = ssam_nf_refcount_disable_free(ctrl, entry, flags, true);\n\n\tmutex_unlock(&nf->lock);\n\treturn status;\n}\nEXPORT_SYMBOL_GPL(ssam_controller_event_disable);\n\n \nint ssam_notifier_disable_registered(struct ssam_controller *ctrl)\n{\n\tstruct ssam_nf *nf = &ctrl->cplt.event.notif;\n\tstruct rb_node *n;\n\tint status;\n\n\tmutex_lock(&nf->lock);\n\tfor (n = rb_first(&nf->refcount); n; n = rb_next(n)) {\n\t\tstruct ssam_nf_refcount_entry *e;\n\n\t\te = rb_entry(n, struct ssam_nf_refcount_entry, node);\n\t\tstatus = ssam_ssh_event_disable(ctrl, e->key.reg,\n\t\t\t\t\t\te->key.id, e->flags);\n\t\tif (status)\n\t\t\tgoto err;\n\t}\n\tmutex_unlock(&nf->lock);\n\n\treturn 0;\n\nerr:\n\tfor (n = rb_prev(n); n; n = rb_prev(n)) {\n\t\tstruct ssam_nf_refcount_entry *e;\n\n\t\te = rb_entry(n, struct ssam_nf_refcount_entry, node);\n\t\tssam_ssh_event_enable(ctrl, e->key.reg, e->key.id, e->flags);\n\t}\n\tmutex_unlock(&nf->lock);\n\n\treturn status;\n}\n\n \nvoid ssam_notifier_restore_registered(struct ssam_controller *ctrl)\n{\n\tstruct ssam_nf *nf = &ctrl->cplt.event.notif;\n\tstruct rb_node *n;\n\n\tmutex_lock(&nf->lock);\n\tfor (n = rb_first(&nf->refcount); n; n = rb_next(n)) {\n\t\tstruct ssam_nf_refcount_entry *e;\n\n\t\te = rb_entry(n, struct ssam_nf_refcount_entry, node);\n\n\t\t \n\t\tssam_ssh_event_enable(ctrl, e->key.reg, e->key.id, e->flags);\n\t}\n\tmutex_unlock(&nf->lock);\n}\n\n \nstatic bool ssam_notifier_is_empty(struct ssam_controller *ctrl)\n{\n\tstruct ssam_nf *nf = &ctrl->cplt.event.notif;\n\tbool result;\n\n\tmutex_lock(&nf->lock);\n\tresult = ssam_nf_refcount_empty(nf);\n\tmutex_unlock(&nf->lock);\n\n\treturn result;\n}\n\n \nstatic void ssam_notifier_unregister_all(struct ssam_controller *ctrl)\n{\n\tstruct ssam_nf *nf = &ctrl->cplt.event.notif;\n\tstruct ssam_nf_refcount_entry *e, *n;\n\n\tmutex_lock(&nf->lock);\n\trbtree_postorder_for_each_entry_safe(e, n, &nf->refcount, node) {\n\t\t \n\t\tssam_ssh_event_disable(ctrl, e->key.reg, e->key.id, e->flags);\n\t\tkfree(e);\n\t}\n\tnf->refcount = RB_ROOT;\n\tmutex_unlock(&nf->lock);\n}\n\n\n \n\nstatic irqreturn_t ssam_irq_handle(int irq, void *dev_id)\n{\n\tstruct ssam_controller *ctrl = dev_id;\n\n\tssam_dbg(ctrl, \"pm: wake irq triggered\\n\");\n\n\t \n\n\treturn IRQ_HANDLED;\n}\n\n \nint ssam_irq_setup(struct ssam_controller *ctrl)\n{\n\tstruct device *dev = ssam_controller_device(ctrl);\n\tstruct gpio_desc *gpiod;\n\tint irq;\n\tint status;\n\n\t \n\tconst int irqf = IRQF_ONESHOT | IRQF_TRIGGER_RISING | IRQF_NO_AUTOEN;\n\n\tgpiod = gpiod_get(dev, \"ssam_wakeup-int\", GPIOD_ASIS);\n\tif (IS_ERR(gpiod))\n\t\treturn PTR_ERR(gpiod);\n\n\tirq = gpiod_to_irq(gpiod);\n\tgpiod_put(gpiod);\n\n\tif (irq < 0)\n\t\treturn irq;\n\n\tstatus = request_threaded_irq(irq, NULL, ssam_irq_handle, irqf,\n\t\t\t\t      \"ssam_wakeup\", ctrl);\n\tif (status)\n\t\treturn status;\n\n\tctrl->irq.num = irq;\n\treturn 0;\n}\n\n \nvoid ssam_irq_free(struct ssam_controller *ctrl)\n{\n\tfree_irq(ctrl->irq.num, ctrl);\n\tctrl->irq.num = -1;\n}\n\n \nint ssam_irq_arm_for_wakeup(struct ssam_controller *ctrl)\n{\n\tstruct device *dev = ssam_controller_device(ctrl);\n\tint status;\n\n\tenable_irq(ctrl->irq.num);\n\tif (device_may_wakeup(dev)) {\n\t\tstatus = enable_irq_wake(ctrl->irq.num);\n\t\tif (status) {\n\t\t\tssam_err(ctrl, \"failed to enable wake IRQ: %d\\n\", status);\n\t\t\tdisable_irq(ctrl->irq.num);\n\t\t\treturn status;\n\t\t}\n\n\t\tctrl->irq.wakeup_enabled = true;\n\t} else {\n\t\tctrl->irq.wakeup_enabled = false;\n\t}\n\n\treturn 0;\n}\n\n \nvoid ssam_irq_disarm_wakeup(struct ssam_controller *ctrl)\n{\n\tint status;\n\n\tif (ctrl->irq.wakeup_enabled) {\n\t\tstatus = disable_irq_wake(ctrl->irq.num);\n\t\tif (status)\n\t\t\tssam_err(ctrl, \"failed to disable wake IRQ: %d\\n\", status);\n\n\t\tctrl->irq.wakeup_enabled = false;\n\t}\n\tdisable_irq(ctrl->irq.num);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}