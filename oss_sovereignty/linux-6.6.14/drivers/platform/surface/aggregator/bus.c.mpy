{
  "module_name": "bus.c",
  "hash_id": "92db788bae1e237f4bee7877d966a55d43753fd6c658b58f460760865619b70d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/surface/aggregator/bus.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/property.h>\n#include <linux/slab.h>\n\n#include <linux/surface_aggregator/controller.h>\n#include <linux/surface_aggregator/device.h>\n\n#include \"bus.h\"\n#include \"controller.h\"\n\n\n \n\nstatic ssize_t modalias_show(struct device *dev, struct device_attribute *attr,\n\t\t\t     char *buf)\n{\n\tstruct ssam_device *sdev = to_ssam_device(dev);\n\n\treturn sysfs_emit(buf, \"ssam:d%02Xc%02Xt%02Xi%02Xf%02X\\n\",\n\t\t\tsdev->uid.domain, sdev->uid.category, sdev->uid.target,\n\t\t\tsdev->uid.instance, sdev->uid.function);\n}\nstatic DEVICE_ATTR_RO(modalias);\n\nstatic struct attribute *ssam_device_attrs[] = {\n\t&dev_attr_modalias.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(ssam_device);\n\nstatic int ssam_device_uevent(const struct device *dev, struct kobj_uevent_env *env)\n{\n\tconst struct ssam_device *sdev = to_ssam_device(dev);\n\n\treturn add_uevent_var(env, \"MODALIAS=ssam:d%02Xc%02Xt%02Xi%02Xf%02X\",\n\t\t\t      sdev->uid.domain, sdev->uid.category,\n\t\t\t      sdev->uid.target, sdev->uid.instance,\n\t\t\t      sdev->uid.function);\n}\n\nstatic void ssam_device_release(struct device *dev)\n{\n\tstruct ssam_device *sdev = to_ssam_device(dev);\n\n\tssam_controller_put(sdev->ctrl);\n\tfwnode_handle_put(sdev->dev.fwnode);\n\tkfree(sdev);\n}\n\nconst struct device_type ssam_device_type = {\n\t.name    = \"surface_aggregator_device\",\n\t.groups  = ssam_device_groups,\n\t.uevent  = ssam_device_uevent,\n\t.release = ssam_device_release,\n};\nEXPORT_SYMBOL_GPL(ssam_device_type);\n\n \nstruct ssam_device *ssam_device_alloc(struct ssam_controller *ctrl,\n\t\t\t\t      struct ssam_device_uid uid)\n{\n\tstruct ssam_device *sdev;\n\n\tsdev = kzalloc(sizeof(*sdev), GFP_KERNEL);\n\tif (!sdev)\n\t\treturn NULL;\n\n\tdevice_initialize(&sdev->dev);\n\tsdev->dev.bus = &ssam_bus_type;\n\tsdev->dev.type = &ssam_device_type;\n\tsdev->dev.parent = ssam_controller_device(ctrl);\n\tsdev->ctrl = ssam_controller_get(ctrl);\n\tsdev->uid = uid;\n\n\tdev_set_name(&sdev->dev, \"%02x:%02x:%02x:%02x:%02x\",\n\t\t     sdev->uid.domain, sdev->uid.category, sdev->uid.target,\n\t\t     sdev->uid.instance, sdev->uid.function);\n\n\treturn sdev;\n}\nEXPORT_SYMBOL_GPL(ssam_device_alloc);\n\n \nint ssam_device_add(struct ssam_device *sdev)\n{\n\tint status;\n\n\t \n\tssam_controller_statelock(sdev->ctrl);\n\n\tif (sdev->ctrl->state != SSAM_CONTROLLER_STARTED) {\n\t\tssam_controller_stateunlock(sdev->ctrl);\n\t\treturn -ENODEV;\n\t}\n\n\tstatus = device_add(&sdev->dev);\n\n\tssam_controller_stateunlock(sdev->ctrl);\n\treturn status;\n}\nEXPORT_SYMBOL_GPL(ssam_device_add);\n\n \nvoid ssam_device_remove(struct ssam_device *sdev)\n{\n\tdevice_unregister(&sdev->dev);\n}\nEXPORT_SYMBOL_GPL(ssam_device_remove);\n\n \nstatic bool ssam_device_id_compatible(const struct ssam_device_id *id,\n\t\t\t\t      struct ssam_device_uid uid)\n{\n\tif (id->domain != uid.domain || id->category != uid.category)\n\t\treturn false;\n\n\tif ((id->match_flags & SSAM_MATCH_TARGET) && id->target != uid.target)\n\t\treturn false;\n\n\tif ((id->match_flags & SSAM_MATCH_INSTANCE) && id->instance != uid.instance)\n\t\treturn false;\n\n\tif ((id->match_flags & SSAM_MATCH_FUNCTION) && id->function != uid.function)\n\t\treturn false;\n\n\treturn true;\n}\n\n \nstatic bool ssam_device_id_is_null(const struct ssam_device_id *id)\n{\n\treturn id->match_flags == 0 &&\n\t\tid->domain == 0 &&\n\t\tid->category == 0 &&\n\t\tid->target == 0 &&\n\t\tid->instance == 0 &&\n\t\tid->function == 0 &&\n\t\tid->driver_data == 0;\n}\n\n \nconst struct ssam_device_id *ssam_device_id_match(const struct ssam_device_id *table,\n\t\t\t\t\t\t  const struct ssam_device_uid uid)\n{\n\tconst struct ssam_device_id *id;\n\n\tfor (id = table; !ssam_device_id_is_null(id); ++id)\n\t\tif (ssam_device_id_compatible(id, uid))\n\t\t\treturn id;\n\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(ssam_device_id_match);\n\n \nconst struct ssam_device_id *ssam_device_get_match(const struct ssam_device *dev)\n{\n\tconst struct ssam_device_driver *sdrv;\n\n\tsdrv = to_ssam_device_driver(dev->dev.driver);\n\tif (!sdrv)\n\t\treturn NULL;\n\n\tif (!sdrv->match_table)\n\t\treturn NULL;\n\n\treturn ssam_device_id_match(sdrv->match_table, dev->uid);\n}\nEXPORT_SYMBOL_GPL(ssam_device_get_match);\n\n \nconst void *ssam_device_get_match_data(const struct ssam_device *dev)\n{\n\tconst struct ssam_device_id *id;\n\n\tid = ssam_device_get_match(dev);\n\tif (!id)\n\t\treturn NULL;\n\n\treturn (const void *)id->driver_data;\n}\nEXPORT_SYMBOL_GPL(ssam_device_get_match_data);\n\nstatic int ssam_bus_match(struct device *dev, struct device_driver *drv)\n{\n\tstruct ssam_device_driver *sdrv = to_ssam_device_driver(drv);\n\tstruct ssam_device *sdev = to_ssam_device(dev);\n\n\tif (!is_ssam_device(dev))\n\t\treturn 0;\n\n\treturn !!ssam_device_id_match(sdrv->match_table, sdev->uid);\n}\n\nstatic int ssam_bus_probe(struct device *dev)\n{\n\treturn to_ssam_device_driver(dev->driver)\n\t\t->probe(to_ssam_device(dev));\n}\n\nstatic void ssam_bus_remove(struct device *dev)\n{\n\tstruct ssam_device_driver *sdrv = to_ssam_device_driver(dev->driver);\n\n\tif (sdrv->remove)\n\t\tsdrv->remove(to_ssam_device(dev));\n}\n\nstruct bus_type ssam_bus_type = {\n\t.name   = \"surface_aggregator\",\n\t.match  = ssam_bus_match,\n\t.probe  = ssam_bus_probe,\n\t.remove = ssam_bus_remove,\n};\nEXPORT_SYMBOL_GPL(ssam_bus_type);\n\n \nint __ssam_device_driver_register(struct ssam_device_driver *sdrv,\n\t\t\t\t  struct module *owner)\n{\n\tsdrv->driver.owner = owner;\n\tsdrv->driver.bus = &ssam_bus_type;\n\n\t \n\tsdrv->driver.probe_type = PROBE_PREFER_ASYNCHRONOUS;\n\n\treturn driver_register(&sdrv->driver);\n}\nEXPORT_SYMBOL_GPL(__ssam_device_driver_register);\n\n \nvoid ssam_device_driver_unregister(struct ssam_device_driver *sdrv)\n{\n\tdriver_unregister(&sdrv->driver);\n}\nEXPORT_SYMBOL_GPL(ssam_device_driver_unregister);\n\n\n \n\n \nint ssam_bus_register(void)\n{\n\treturn bus_register(&ssam_bus_type);\n}\n\n \nvoid ssam_bus_unregister(void)\n{\n\treturn bus_unregister(&ssam_bus_type);\n}\n\n\n \n\nstatic int ssam_device_uid_from_string(const char *str, struct ssam_device_uid *uid)\n{\n\tu8 d, tc, tid, iid, fn;\n\tint n;\n\n\tn = sscanf(str, \"%hhx:%hhx:%hhx:%hhx:%hhx\", &d, &tc, &tid, &iid, &fn);\n\tif (n != 5)\n\t\treturn -EINVAL;\n\n\tuid->domain = d;\n\tuid->category = tc;\n\tuid->target = tid;\n\tuid->instance = iid;\n\tuid->function = fn;\n\n\treturn 0;\n}\n\nstatic int ssam_get_uid_for_node(struct fwnode_handle *node, struct ssam_device_uid *uid)\n{\n\tconst char *str = fwnode_get_name(node);\n\n\t \n\tif (strncmp(str, \"ssam:\", strlen(\"ssam:\")) != 0)\n\t\treturn -ENODEV;\n\n\tstr += strlen(\"ssam:\");\n\treturn ssam_device_uid_from_string(str, uid);\n}\n\nstatic int ssam_add_client_device(struct device *parent, struct ssam_controller *ctrl,\n\t\t\t\t  struct fwnode_handle *node)\n{\n\tstruct ssam_device_uid uid;\n\tstruct ssam_device *sdev;\n\tint status;\n\n\tstatus = ssam_get_uid_for_node(node, &uid);\n\tif (status)\n\t\treturn status;\n\n\tsdev = ssam_device_alloc(ctrl, uid);\n\tif (!sdev)\n\t\treturn -ENOMEM;\n\n\tsdev->dev.parent = parent;\n\tsdev->dev.fwnode = fwnode_handle_get(node);\n\n\tstatus = ssam_device_add(sdev);\n\tif (status)\n\t\tssam_device_put(sdev);\n\n\treturn status;\n}\n\n \nint __ssam_register_clients(struct device *parent, struct ssam_controller *ctrl,\n\t\t\t    struct fwnode_handle *node)\n{\n\tstruct fwnode_handle *child;\n\tint status;\n\n\tfwnode_for_each_child_node(node, child) {\n\t\t \n\t\tstatus = ssam_add_client_device(parent, ctrl, child);\n\t\tif (status && status != -ENODEV) {\n\t\t\tfwnode_handle_put(child);\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\treturn 0;\nerr:\n\tssam_remove_clients(parent);\n\treturn status;\n}\nEXPORT_SYMBOL_GPL(__ssam_register_clients);\n\nstatic int ssam_remove_device(struct device *dev, void *_data)\n{\n\tstruct ssam_device *sdev = to_ssam_device(dev);\n\n\tif (is_ssam_device(dev))\n\t\tssam_device_remove(sdev);\n\n\treturn 0;\n}\n\n \nvoid ssam_remove_clients(struct device *dev)\n{\n\tdevice_for_each_child_reverse(dev, NULL, ssam_remove_device);\n}\nEXPORT_SYMBOL_GPL(ssam_remove_clients);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}