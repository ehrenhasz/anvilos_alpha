{
  "module_name": "ssh_parser.c",
  "hash_id": "8eb012d0abb36aec65e5d3ee3d1467e3246466c0f6b296508e632151710d923d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/surface/aggregator/ssh_parser.c",
  "human_readable_source": "\n \n\n#include <asm/unaligned.h>\n#include <linux/compiler.h>\n#include <linux/device.h>\n#include <linux/types.h>\n\n#include <linux/surface_aggregator/serial_hub.h>\n#include \"ssh_parser.h\"\n\n \nstatic bool sshp_validate_crc(const struct ssam_span *src, const u8 *crc)\n{\n\tu16 actual = ssh_crc(src->ptr, src->len);\n\tu16 expected = get_unaligned_le16(crc);\n\n\treturn actual == expected;\n}\n\n \nstatic bool sshp_starts_with_syn(const struct ssam_span *src)\n{\n\treturn src->len >= 2 && get_unaligned_le16(src->ptr) == SSH_MSG_SYN;\n}\n\n \nbool sshp_find_syn(const struct ssam_span *src, struct ssam_span *rem)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < src->len - 1; i++) {\n\t\tif (likely(get_unaligned_le16(src->ptr + i) == SSH_MSG_SYN)) {\n\t\t\trem->ptr = src->ptr + i;\n\t\t\trem->len = src->len - i;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tif (unlikely(src->ptr[src->len - 1] == (SSH_MSG_SYN & 0xff))) {\n\t\trem->ptr = src->ptr + src->len - 1;\n\t\trem->len = 1;\n\t\treturn false;\n\t}\n\n\trem->ptr = src->ptr + src->len;\n\trem->len = 0;\n\treturn false;\n}\n\n \nint sshp_parse_frame(const struct device *dev, const struct ssam_span *source,\n\t\t     struct ssh_frame **frame, struct ssam_span *payload,\n\t\t     size_t maxlen)\n{\n\tstruct ssam_span sf;\n\tstruct ssam_span sp;\n\n\t \n\t*frame = NULL;\n\tpayload->ptr = NULL;\n\tpayload->len = 0;\n\n\tif (!sshp_starts_with_syn(source)) {\n\t\tdev_warn(dev, \"rx: parser: invalid start of frame\\n\");\n\t\treturn -ENOMSG;\n\t}\n\n\t \n\tif (unlikely(source->len < SSH_MESSAGE_LENGTH(0))) {\n\t\tdev_dbg(dev, \"rx: parser: not enough data for frame\\n\");\n\t\treturn 0;\n\t}\n\n\t \n\tsf.ptr = source->ptr + sizeof(u16);\n\tsf.len = sizeof(struct ssh_frame);\n\n\t \n\tif (unlikely(!sshp_validate_crc(&sf, sf.ptr + sf.len))) {\n\t\tdev_warn(dev, \"rx: parser: invalid frame CRC\\n\");\n\t\treturn -EBADMSG;\n\t}\n\n\t \n\tsp.len = get_unaligned_le16(&((struct ssh_frame *)sf.ptr)->len);\n\tif (unlikely(SSH_MESSAGE_LENGTH(sp.len) > maxlen)) {\n\t\tdev_warn(dev, \"rx: parser: frame too large: %llu bytes\\n\",\n\t\t\t SSH_MESSAGE_LENGTH(sp.len));\n\t\treturn -EMSGSIZE;\n\t}\n\n\t \n\tsp.ptr = sf.ptr + sf.len + sizeof(u16);\n\n\t \n\tif (source->len < SSH_MESSAGE_LENGTH(sp.len)) {\n\t\tdev_dbg(dev, \"rx: parser: not enough data for payload\\n\");\n\t\treturn 0;\n\t}\n\n\t \n\tif (unlikely(!sshp_validate_crc(&sp, sp.ptr + sp.len))) {\n\t\tdev_warn(dev, \"rx: parser: invalid payload CRC\\n\");\n\t\treturn -EBADMSG;\n\t}\n\n\t*frame = (struct ssh_frame *)sf.ptr;\n\t*payload = sp;\n\n\tdev_dbg(dev, \"rx: parser: valid frame found (type: %#04x, len: %u)\\n\",\n\t\t(*frame)->type, (*frame)->len);\n\n\treturn 0;\n}\n\n \nint sshp_parse_command(const struct device *dev, const struct ssam_span *source,\n\t\t       struct ssh_command **command,\n\t\t       struct ssam_span *command_data)\n{\n\t \n\tif (unlikely(source->len < sizeof(struct ssh_command))) {\n\t\t*command = NULL;\n\t\tcommand_data->ptr = NULL;\n\t\tcommand_data->len = 0;\n\n\t\tdev_err(dev, \"rx: parser: command payload is too short\\n\");\n\t\treturn -ENOMSG;\n\t}\n\n\t*command = (struct ssh_command *)source->ptr;\n\tcommand_data->ptr = source->ptr + sizeof(struct ssh_command);\n\tcommand_data->len = source->len - sizeof(struct ssh_command);\n\n\tdev_dbg(dev, \"rx: parser: valid command found (tc: %#04x, cid: %#04x)\\n\",\n\t\t(*command)->tc, (*command)->cid);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}