{
  "module_name": "ssh_packet_layer.c",
  "hash_id": "a674425110d3569f91d68a620c7a7a533cb607ed7f01362489caf32e9ab69f7a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/surface/aggregator/ssh_packet_layer.c",
  "human_readable_source": "\n \n\n#include <asm/unaligned.h>\n#include <linux/atomic.h>\n#include <linux/error-injection.h>\n#include <linux/jiffies.h>\n#include <linux/kfifo.h>\n#include <linux/kref.h>\n#include <linux/kthread.h>\n#include <linux/ktime.h>\n#include <linux/limits.h>\n#include <linux/list.h>\n#include <linux/lockdep.h>\n#include <linux/serdev.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\n#include <linux/surface_aggregator/serial_hub.h>\n\n#include \"ssh_msgb.h\"\n#include \"ssh_packet_layer.h\"\n#include \"ssh_parser.h\"\n\n#include \"trace.h\"\n\n \n\n \n#define SSH_PTL_MAX_PACKET_TRIES\t\t3\n\n \n#define SSH_PTL_TX_TIMEOUT\t\t\tHZ\n\n \n#define SSH_PTL_PACKET_TIMEOUT\t\t\tms_to_ktime(1000)\n\n \n#define SSH_PTL_PACKET_TIMEOUT_RESOLUTION\tms_to_ktime(max(2000 / HZ, 50))\n\n \n#define SSH_PTL_MAX_PENDING\t\t\t1\n\n \n#define SSH_PTL_RX_BUF_LEN\t\t\t4096\n\n \n#define SSH_PTL_RX_FIFO_LEN\t\t\t4096\n\n#ifdef CONFIG_SURFACE_AGGREGATOR_ERROR_INJECTION\n\n \nstatic noinline bool ssh_ptl_should_drop_ack_packet(void)\n{\n\treturn false;\n}\nALLOW_ERROR_INJECTION(ssh_ptl_should_drop_ack_packet, TRUE);\n\n \nstatic noinline bool ssh_ptl_should_drop_nak_packet(void)\n{\n\treturn false;\n}\nALLOW_ERROR_INJECTION(ssh_ptl_should_drop_nak_packet, TRUE);\n\n \nstatic noinline bool ssh_ptl_should_drop_dsq_packet(void)\n{\n\treturn false;\n}\nALLOW_ERROR_INJECTION(ssh_ptl_should_drop_dsq_packet, TRUE);\n\n \nstatic noinline int ssh_ptl_should_fail_write(void)\n{\n\treturn 0;\n}\nALLOW_ERROR_INJECTION(ssh_ptl_should_fail_write, ERRNO);\n\n \nstatic noinline bool ssh_ptl_should_corrupt_tx_data(void)\n{\n\treturn false;\n}\nALLOW_ERROR_INJECTION(ssh_ptl_should_corrupt_tx_data, TRUE);\n\n \nstatic noinline bool ssh_ptl_should_corrupt_rx_syn(void)\n{\n\treturn false;\n}\nALLOW_ERROR_INJECTION(ssh_ptl_should_corrupt_rx_syn, TRUE);\n\n \nstatic noinline bool ssh_ptl_should_corrupt_rx_data(void)\n{\n\treturn false;\n}\nALLOW_ERROR_INJECTION(ssh_ptl_should_corrupt_rx_data, TRUE);\n\nstatic bool __ssh_ptl_should_drop_ack_packet(struct ssh_packet *packet)\n{\n\tif (likely(!ssh_ptl_should_drop_ack_packet()))\n\t\treturn false;\n\n\ttrace_ssam_ei_tx_drop_ack_packet(packet);\n\tptl_info(packet->ptl, \"packet error injection: dropping ACK packet %p\\n\",\n\t\t packet);\n\n\treturn true;\n}\n\nstatic bool __ssh_ptl_should_drop_nak_packet(struct ssh_packet *packet)\n{\n\tif (likely(!ssh_ptl_should_drop_nak_packet()))\n\t\treturn false;\n\n\ttrace_ssam_ei_tx_drop_nak_packet(packet);\n\tptl_info(packet->ptl, \"packet error injection: dropping NAK packet %p\\n\",\n\t\t packet);\n\n\treturn true;\n}\n\nstatic bool __ssh_ptl_should_drop_dsq_packet(struct ssh_packet *packet)\n{\n\tif (likely(!ssh_ptl_should_drop_dsq_packet()))\n\t\treturn false;\n\n\ttrace_ssam_ei_tx_drop_dsq_packet(packet);\n\tptl_info(packet->ptl,\n\t\t \"packet error injection: dropping sequenced data packet %p\\n\",\n\t\t packet);\n\n\treturn true;\n}\n\nstatic bool ssh_ptl_should_drop_packet(struct ssh_packet *packet)\n{\n\t \n\tif (!packet->data.ptr || !packet->data.len)\n\t\treturn false;\n\n\tswitch (packet->data.ptr[SSH_MSGOFFSET_FRAME(type)]) {\n\tcase SSH_FRAME_TYPE_ACK:\n\t\treturn __ssh_ptl_should_drop_ack_packet(packet);\n\n\tcase SSH_FRAME_TYPE_NAK:\n\t\treturn __ssh_ptl_should_drop_nak_packet(packet);\n\n\tcase SSH_FRAME_TYPE_DATA_SEQ:\n\t\treturn __ssh_ptl_should_drop_dsq_packet(packet);\n\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic int ssh_ptl_write_buf(struct ssh_ptl *ptl, struct ssh_packet *packet,\n\t\t\t     const unsigned char *buf, size_t count)\n{\n\tint status;\n\n\tstatus = ssh_ptl_should_fail_write();\n\tif (unlikely(status)) {\n\t\ttrace_ssam_ei_tx_fail_write(packet, status);\n\t\tptl_info(packet->ptl,\n\t\t\t \"packet error injection: simulating transmit error %d, packet %p\\n\",\n\t\t\t status, packet);\n\n\t\treturn status;\n\t}\n\n\treturn serdev_device_write_buf(ptl->serdev, buf, count);\n}\n\nstatic void ssh_ptl_tx_inject_invalid_data(struct ssh_packet *packet)\n{\n\t \n\tif (!packet->data.ptr || !packet->data.len)\n\t\treturn;\n\n\t \n\tif (packet->data.ptr[SSH_MSGOFFSET_FRAME(type)] != SSH_FRAME_TYPE_DATA_SEQ)\n\t\treturn;\n\n\tif (likely(!ssh_ptl_should_corrupt_tx_data()))\n\t\treturn;\n\n\ttrace_ssam_ei_tx_corrupt_data(packet);\n\tptl_info(packet->ptl,\n\t\t \"packet error injection: simulating invalid transmit data on packet %p\\n\",\n\t\t packet);\n\n\t \n\tmemset(packet->data.ptr, 0xb3, packet->data.len);\n}\n\nstatic void ssh_ptl_rx_inject_invalid_syn(struct ssh_ptl *ptl,\n\t\t\t\t\t  struct ssam_span *data)\n{\n\tstruct ssam_span frame;\n\n\t \n\tif (!sshp_find_syn(data, &frame))\n\t\treturn;\n\n\tif (likely(!ssh_ptl_should_corrupt_rx_syn()))\n\t\treturn;\n\n\ttrace_ssam_ei_rx_corrupt_syn(data->len);\n\n\tdata->ptr[1] = 0xb3;\t \n}\n\nstatic void ssh_ptl_rx_inject_invalid_data(struct ssh_ptl *ptl,\n\t\t\t\t\t   struct ssam_span *frame)\n{\n\tsize_t payload_len, message_len;\n\tstruct ssh_frame *sshf;\n\n\t \n\tif (frame->len < SSH_MESSAGE_LENGTH(0))\n\t\treturn;\n\n\t \n\tpayload_len = get_unaligned_le16(&frame->ptr[SSH_MSGOFFSET_FRAME(len)]);\n\tmessage_len = SSH_MESSAGE_LENGTH(payload_len);\n\tif (frame->len < message_len)\n\t\treturn;\n\n\tif (likely(!ssh_ptl_should_corrupt_rx_data()))\n\t\treturn;\n\n\tsshf = (struct ssh_frame *)&frame->ptr[SSH_MSGOFFSET_FRAME(type)];\n\ttrace_ssam_ei_rx_corrupt_data(sshf);\n\n\t \n\tframe->ptr[frame->len - 2] = ~frame->ptr[frame->len - 2];\n}\n\n#else  \n\nstatic inline bool ssh_ptl_should_drop_packet(struct ssh_packet *packet)\n{\n\treturn false;\n}\n\nstatic inline int ssh_ptl_write_buf(struct ssh_ptl *ptl,\n\t\t\t\t    struct ssh_packet *packet,\n\t\t\t\t    const unsigned char *buf,\n\t\t\t\t    size_t count)\n{\n\treturn serdev_device_write_buf(ptl->serdev, buf, count);\n}\n\nstatic inline void ssh_ptl_tx_inject_invalid_data(struct ssh_packet *packet)\n{\n}\n\nstatic inline void ssh_ptl_rx_inject_invalid_syn(struct ssh_ptl *ptl,\n\t\t\t\t\t\t struct ssam_span *data)\n{\n}\n\nstatic inline void ssh_ptl_rx_inject_invalid_data(struct ssh_ptl *ptl,\n\t\t\t\t\t\t  struct ssam_span *frame)\n{\n}\n\n#endif  \n\nstatic void __ssh_ptl_packet_release(struct kref *kref)\n{\n\tstruct ssh_packet *p = container_of(kref, struct ssh_packet, refcnt);\n\n\ttrace_ssam_packet_release(p);\n\n\tptl_dbg_cond(p->ptl, \"ptl: releasing packet %p\\n\", p);\n\tp->ops->release(p);\n}\n\n \nstruct ssh_packet *ssh_packet_get(struct ssh_packet *packet)\n{\n\tif (packet)\n\t\tkref_get(&packet->refcnt);\n\treturn packet;\n}\nEXPORT_SYMBOL_GPL(ssh_packet_get);\n\n \nvoid ssh_packet_put(struct ssh_packet *packet)\n{\n\tif (packet)\n\t\tkref_put(&packet->refcnt, __ssh_ptl_packet_release);\n}\nEXPORT_SYMBOL_GPL(ssh_packet_put);\n\nstatic u8 ssh_packet_get_seq(struct ssh_packet *packet)\n{\n\treturn packet->data.ptr[SSH_MSGOFFSET_FRAME(seq)];\n}\n\n \nvoid ssh_packet_init(struct ssh_packet *packet, unsigned long type,\n\t\t     u8 priority, const struct ssh_packet_ops *ops)\n{\n\tkref_init(&packet->refcnt);\n\n\tpacket->ptl = NULL;\n\tINIT_LIST_HEAD(&packet->queue_node);\n\tINIT_LIST_HEAD(&packet->pending_node);\n\n\tpacket->state = type & SSH_PACKET_FLAGS_TY_MASK;\n\tpacket->priority = priority;\n\tpacket->timestamp = KTIME_MAX;\n\n\tpacket->data.ptr = NULL;\n\tpacket->data.len = 0;\n\n\tpacket->ops = ops;\n}\n\nstatic struct kmem_cache *ssh_ctrl_packet_cache;\n\n \nint ssh_ctrl_packet_cache_init(void)\n{\n\tconst unsigned int size = sizeof(struct ssh_packet) + SSH_MSG_LEN_CTRL;\n\tconst unsigned int align = __alignof__(struct ssh_packet);\n\tstruct kmem_cache *cache;\n\n\tcache = kmem_cache_create(\"ssam_ctrl_packet\", size, align, 0, NULL);\n\tif (!cache)\n\t\treturn -ENOMEM;\n\n\tssh_ctrl_packet_cache = cache;\n\treturn 0;\n}\n\n \nvoid ssh_ctrl_packet_cache_destroy(void)\n{\n\tkmem_cache_destroy(ssh_ctrl_packet_cache);\n\tssh_ctrl_packet_cache = NULL;\n}\n\n \nstatic int ssh_ctrl_packet_alloc(struct ssh_packet **packet,\n\t\t\t\t struct ssam_span *buffer, gfp_t flags)\n{\n\t*packet = kmem_cache_alloc(ssh_ctrl_packet_cache, flags);\n\tif (!*packet)\n\t\treturn -ENOMEM;\n\n\tbuffer->ptr = (u8 *)(*packet + 1);\n\tbuffer->len = SSH_MSG_LEN_CTRL;\n\n\ttrace_ssam_ctrl_packet_alloc(*packet, buffer->len);\n\treturn 0;\n}\n\n \nstatic void ssh_ctrl_packet_free(struct ssh_packet *p)\n{\n\ttrace_ssam_ctrl_packet_free(p);\n\tkmem_cache_free(ssh_ctrl_packet_cache, p);\n}\n\nstatic const struct ssh_packet_ops ssh_ptl_ctrl_packet_ops = {\n\t.complete = NULL,\n\t.release = ssh_ctrl_packet_free,\n};\n\nstatic void ssh_ptl_timeout_reaper_mod(struct ssh_ptl *ptl, ktime_t now,\n\t\t\t\t       ktime_t expires)\n{\n\tunsigned long delta = msecs_to_jiffies(ktime_ms_delta(expires, now));\n\tktime_t aexp = ktime_add(expires, SSH_PTL_PACKET_TIMEOUT_RESOLUTION);\n\n\tspin_lock(&ptl->rtx_timeout.lock);\n\n\t \n\tif (ktime_before(aexp, ptl->rtx_timeout.expires)) {\n\t\tptl->rtx_timeout.expires = expires;\n\t\tmod_delayed_work(system_wq, &ptl->rtx_timeout.reaper, delta);\n\t}\n\n\tspin_unlock(&ptl->rtx_timeout.lock);\n}\n\n \nstatic void ssh_packet_next_try(struct ssh_packet *p)\n{\n\tu8 base = ssh_packet_priority_get_base(p->priority);\n\tu8 try = ssh_packet_priority_get_try(p->priority);\n\n\tlockdep_assert_held(&p->ptl->queue.lock);\n\n\t \n\tWRITE_ONCE(p->priority, __SSH_PACKET_PRIORITY(base, try + 1));\n}\n\n \nstatic struct list_head *__ssh_ptl_queue_find_entrypoint(struct ssh_packet *p)\n{\n\tstruct list_head *head;\n\tstruct ssh_packet *q;\n\n\tlockdep_assert_held(&p->ptl->queue.lock);\n\n\t \n\n\tif (p->priority > SSH_PACKET_PRIORITY(DATA, 0)) {\n\t\tlist_for_each(head, &p->ptl->queue.head) {\n\t\t\tq = list_entry(head, struct ssh_packet, queue_node);\n\n\t\t\tif (q->priority < p->priority)\n\t\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tlist_for_each_prev(head, &p->ptl->queue.head) {\n\t\t\tq = list_entry(head, struct ssh_packet, queue_node);\n\n\t\t\tif (q->priority >= p->priority) {\n\t\t\t\thead = head->next;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn head;\n}\n\n \nstatic int __ssh_ptl_queue_push(struct ssh_packet *packet)\n{\n\tstruct ssh_ptl *ptl = packet->ptl;\n\tstruct list_head *head;\n\n\tlockdep_assert_held(&ptl->queue.lock);\n\n\tif (test_bit(SSH_PTL_SF_SHUTDOWN_BIT, &ptl->state))\n\t\treturn -ESHUTDOWN;\n\n\t \n\tif (test_bit(SSH_PACKET_SF_LOCKED_BIT, &packet->state))\n\t\treturn -EINVAL;\n\n\t \n\tif (test_and_set_bit(SSH_PACKET_SF_QUEUED_BIT, &packet->state))\n\t\treturn -EALREADY;\n\n\thead = __ssh_ptl_queue_find_entrypoint(packet);\n\n\tlist_add_tail(&ssh_packet_get(packet)->queue_node, head);\n\treturn 0;\n}\n\nstatic int ssh_ptl_queue_push(struct ssh_packet *packet)\n{\n\tint status;\n\n\tspin_lock(&packet->ptl->queue.lock);\n\tstatus = __ssh_ptl_queue_push(packet);\n\tspin_unlock(&packet->ptl->queue.lock);\n\n\treturn status;\n}\n\nstatic void ssh_ptl_queue_remove(struct ssh_packet *packet)\n{\n\tstruct ssh_ptl *ptl = packet->ptl;\n\n\tspin_lock(&ptl->queue.lock);\n\n\tif (!test_and_clear_bit(SSH_PACKET_SF_QUEUED_BIT, &packet->state)) {\n\t\tspin_unlock(&ptl->queue.lock);\n\t\treturn;\n\t}\n\n\tlist_del(&packet->queue_node);\n\n\tspin_unlock(&ptl->queue.lock);\n\tssh_packet_put(packet);\n}\n\nstatic void ssh_ptl_pending_push(struct ssh_packet *p)\n{\n\tstruct ssh_ptl *ptl = p->ptl;\n\tconst ktime_t timestamp = ktime_get_coarse_boottime();\n\tconst ktime_t timeout = ptl->rtx_timeout.timeout;\n\n\t \n\n\tspin_lock(&ptl->pending.lock);\n\n\t \n\tif (test_bit(SSH_PACKET_SF_LOCKED_BIT, &p->state)) {\n\t\tspin_unlock(&ptl->pending.lock);\n\t\treturn;\n\t}\n\n\t \n\tp->timestamp = timestamp;\n\n\t \n\tif (!test_and_set_bit(SSH_PACKET_SF_PENDING_BIT, &p->state)) {\n\t\tatomic_inc(&ptl->pending.count);\n\t\tlist_add_tail(&ssh_packet_get(p)->pending_node, &ptl->pending.head);\n\t}\n\n\tspin_unlock(&ptl->pending.lock);\n\n\t \n\tssh_ptl_timeout_reaper_mod(ptl, timestamp, timestamp + timeout);\n}\n\nstatic void ssh_ptl_pending_remove(struct ssh_packet *packet)\n{\n\tstruct ssh_ptl *ptl = packet->ptl;\n\n\tspin_lock(&ptl->pending.lock);\n\n\tif (!test_and_clear_bit(SSH_PACKET_SF_PENDING_BIT, &packet->state)) {\n\t\tspin_unlock(&ptl->pending.lock);\n\t\treturn;\n\t}\n\n\tlist_del(&packet->pending_node);\n\tatomic_dec(&ptl->pending.count);\n\n\tspin_unlock(&ptl->pending.lock);\n\n\tssh_packet_put(packet);\n}\n\n \nstatic void __ssh_ptl_complete(struct ssh_packet *p, int status)\n{\n\tstruct ssh_ptl *ptl = READ_ONCE(p->ptl);\n\n\ttrace_ssam_packet_complete(p, status);\n\tptl_dbg_cond(ptl, \"ptl: completing packet %p (status: %d)\\n\", p, status);\n\n\tif (p->ops->complete)\n\t\tp->ops->complete(p, status);\n}\n\nstatic void ssh_ptl_remove_and_complete(struct ssh_packet *p, int status)\n{\n\t \n\n\tif (test_and_set_bit(SSH_PACKET_SF_COMPLETED_BIT, &p->state))\n\t\treturn;\n\n\tssh_ptl_queue_remove(p);\n\tssh_ptl_pending_remove(p);\n\n\t__ssh_ptl_complete(p, status);\n}\n\nstatic bool ssh_ptl_tx_can_process(struct ssh_packet *packet)\n{\n\tstruct ssh_ptl *ptl = packet->ptl;\n\n\tif (test_bit(SSH_PACKET_TY_FLUSH_BIT, &packet->state))\n\t\treturn !atomic_read(&ptl->pending.count);\n\n\t \n\tif (!test_bit(SSH_PACKET_TY_BLOCKING_BIT, &packet->state))\n\t\treturn true;\n\n\t \n\tif (test_bit(SSH_PACKET_SF_PENDING_BIT, &packet->state))\n\t\treturn true;\n\n\t \n\treturn atomic_read(&ptl->pending.count) < SSH_PTL_MAX_PENDING;\n}\n\nstatic struct ssh_packet *ssh_ptl_tx_pop(struct ssh_ptl *ptl)\n{\n\tstruct ssh_packet *packet = ERR_PTR(-ENOENT);\n\tstruct ssh_packet *p, *n;\n\n\tspin_lock(&ptl->queue.lock);\n\tlist_for_each_entry_safe(p, n, &ptl->queue.head, queue_node) {\n\t\t \n\t\tif (test_bit(SSH_PACKET_SF_LOCKED_BIT, &p->state))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (!ssh_ptl_tx_can_process(p)) {\n\t\t\tpacket = ERR_PTR(-EBUSY);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\n\t\tlist_del(&p->queue_node);\n\n\t\tset_bit(SSH_PACKET_SF_TRANSMITTING_BIT, &p->state);\n\t\t \n\t\tsmp_mb__before_atomic();\n\t\tclear_bit(SSH_PACKET_SF_QUEUED_BIT, &p->state);\n\n\t\t \n\t\tssh_packet_next_try(p);\n\n\t\tpacket = p;\n\t\tbreak;\n\t}\n\tspin_unlock(&ptl->queue.lock);\n\n\treturn packet;\n}\n\nstatic struct ssh_packet *ssh_ptl_tx_next(struct ssh_ptl *ptl)\n{\n\tstruct ssh_packet *p;\n\n\tp = ssh_ptl_tx_pop(ptl);\n\tif (IS_ERR(p))\n\t\treturn p;\n\n\tif (test_bit(SSH_PACKET_TY_SEQUENCED_BIT, &p->state)) {\n\t\tptl_dbg(ptl, \"ptl: transmitting sequenced packet %p\\n\", p);\n\t\tssh_ptl_pending_push(p);\n\t} else {\n\t\tptl_dbg(ptl, \"ptl: transmitting non-sequenced packet %p\\n\", p);\n\t}\n\n\treturn p;\n}\n\nstatic void ssh_ptl_tx_compl_success(struct ssh_packet *packet)\n{\n\tstruct ssh_ptl *ptl = packet->ptl;\n\n\tptl_dbg(ptl, \"ptl: successfully transmitted packet %p\\n\", packet);\n\n\t \n\tset_bit(SSH_PACKET_SF_TRANSMITTED_BIT, &packet->state);\n\t \n\tsmp_mb__before_atomic();\n\tclear_bit(SSH_PACKET_SF_TRANSMITTING_BIT, &packet->state);\n\n\t \n\tif (!test_bit(SSH_PACKET_TY_SEQUENCED_BIT, &packet->state)) {\n\t\tset_bit(SSH_PACKET_SF_LOCKED_BIT, &packet->state);\n\t\tssh_ptl_remove_and_complete(packet, 0);\n\t}\n\n\t \n\twake_up_all(&ptl->tx.packet_wq);\n}\n\nstatic void ssh_ptl_tx_compl_error(struct ssh_packet *packet, int status)\n{\n\t \n\tset_bit(SSH_PACKET_SF_LOCKED_BIT, &packet->state);\n\t \n\tsmp_mb__before_atomic();\n\tclear_bit(SSH_PACKET_SF_TRANSMITTING_BIT, &packet->state);\n\n\tptl_err(packet->ptl, \"ptl: transmission error: %d\\n\", status);\n\tptl_dbg(packet->ptl, \"ptl: failed to transmit packet: %p\\n\", packet);\n\n\tssh_ptl_remove_and_complete(packet, status);\n\n\t \n\twake_up_all(&packet->ptl->tx.packet_wq);\n}\n\nstatic long ssh_ptl_tx_wait_packet(struct ssh_ptl *ptl)\n{\n\tint status;\n\n\tstatus = wait_for_completion_interruptible(&ptl->tx.thread_cplt_pkt);\n\treinit_completion(&ptl->tx.thread_cplt_pkt);\n\n\t \n\tsmp_mb__after_atomic();\n\n\treturn status;\n}\n\nstatic long ssh_ptl_tx_wait_transfer(struct ssh_ptl *ptl, long timeout)\n{\n\tlong status;\n\n\tstatus = wait_for_completion_interruptible_timeout(&ptl->tx.thread_cplt_tx,\n\t\t\t\t\t\t\t   timeout);\n\treinit_completion(&ptl->tx.thread_cplt_tx);\n\n\t \n\tsmp_mb__after_atomic();\n\n\treturn status;\n}\n\nstatic int ssh_ptl_tx_packet(struct ssh_ptl *ptl, struct ssh_packet *packet)\n{\n\tlong timeout = SSH_PTL_TX_TIMEOUT;\n\tsize_t offset = 0;\n\n\t \n\tif (unlikely(!packet->data.ptr))\n\t\treturn 0;\n\n\t \n\tif (ssh_ptl_should_drop_packet(packet))\n\t\treturn 0;\n\n\t \n\tssh_ptl_tx_inject_invalid_data(packet);\n\n\tptl_dbg(ptl, \"tx: sending data (length: %zu)\\n\", packet->data.len);\n\tprint_hex_dump_debug(\"tx: \", DUMP_PREFIX_OFFSET, 16, 1,\n\t\t\t     packet->data.ptr, packet->data.len, false);\n\n\tdo {\n\t\tssize_t status, len;\n\t\tu8 *buf;\n\n\t\tbuf = packet->data.ptr + offset;\n\t\tlen = packet->data.len - offset;\n\n\t\tstatus = ssh_ptl_write_buf(ptl, packet, buf, len);\n\t\tif (status < 0)\n\t\t\treturn status;\n\n\t\tif (status == len)\n\t\t\treturn 0;\n\n\t\toffset += status;\n\n\t\ttimeout = ssh_ptl_tx_wait_transfer(ptl, timeout);\n\t\tif (kthread_should_stop() || !atomic_read(&ptl->tx.running))\n\t\t\treturn -ESHUTDOWN;\n\n\t\tif (timeout < 0)\n\t\t\treturn -EINTR;\n\n\t\tif (timeout == 0)\n\t\t\treturn -ETIMEDOUT;\n\t} while (true);\n}\n\nstatic int ssh_ptl_tx_threadfn(void *data)\n{\n\tstruct ssh_ptl *ptl = data;\n\n\twhile (!kthread_should_stop() && atomic_read(&ptl->tx.running)) {\n\t\tstruct ssh_packet *packet;\n\t\tint status;\n\n\t\t \n\t\tpacket = ssh_ptl_tx_next(ptl);\n\n\t\t \n\t\tif (IS_ERR(packet)) {\n\t\t\tssh_ptl_tx_wait_packet(ptl);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tstatus = ssh_ptl_tx_packet(ptl, packet);\n\t\tif (status)\n\t\t\tssh_ptl_tx_compl_error(packet, status);\n\t\telse\n\t\t\tssh_ptl_tx_compl_success(packet);\n\n\t\tssh_packet_put(packet);\n\t}\n\n\treturn 0;\n}\n\n \nstatic void ssh_ptl_tx_wakeup_packet(struct ssh_ptl *ptl)\n{\n\tif (test_bit(SSH_PTL_SF_SHUTDOWN_BIT, &ptl->state))\n\t\treturn;\n\n\tcomplete(&ptl->tx.thread_cplt_pkt);\n}\n\n \nint ssh_ptl_tx_start(struct ssh_ptl *ptl)\n{\n\tatomic_set_release(&ptl->tx.running, 1);\n\n\tptl->tx.thread = kthread_run(ssh_ptl_tx_threadfn, ptl, \"ssam_serial_hub-tx\");\n\tif (IS_ERR(ptl->tx.thread))\n\t\treturn PTR_ERR(ptl->tx.thread);\n\n\treturn 0;\n}\n\n \nint ssh_ptl_tx_stop(struct ssh_ptl *ptl)\n{\n\tint status = 0;\n\n\tif (!IS_ERR_OR_NULL(ptl->tx.thread)) {\n\t\t \n\t\tatomic_set_release(&ptl->tx.running, 0);\n\n\t\t \n\t\tcomplete(&ptl->tx.thread_cplt_pkt);\n\t\tcomplete(&ptl->tx.thread_cplt_tx);\n\n\t\t \n\t\tstatus = kthread_stop(ptl->tx.thread);\n\t\tptl->tx.thread = NULL;\n\t}\n\n\treturn status;\n}\n\nstatic struct ssh_packet *ssh_ptl_ack_pop(struct ssh_ptl *ptl, u8 seq_id)\n{\n\tstruct ssh_packet *packet = ERR_PTR(-ENOENT);\n\tstruct ssh_packet *p, *n;\n\n\tspin_lock(&ptl->pending.lock);\n\tlist_for_each_entry_safe(p, n, &ptl->pending.head, pending_node) {\n\t\t \n\t\tif (unlikely(ssh_packet_get_seq(p) != seq_id))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (unlikely(test_bit(SSH_PACKET_SF_LOCKED_BIT, &p->state))) {\n\t\t\tpacket = ERR_PTR(-EPERM);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tset_bit(SSH_PACKET_SF_ACKED_BIT, &p->state);\n\t\t \n\t\tsmp_mb__before_atomic();\n\t\tclear_bit(SSH_PACKET_SF_PENDING_BIT, &p->state);\n\n\t\tatomic_dec(&ptl->pending.count);\n\t\tlist_del(&p->pending_node);\n\t\tpacket = p;\n\n\t\tbreak;\n\t}\n\tspin_unlock(&ptl->pending.lock);\n\n\treturn packet;\n}\n\nstatic void ssh_ptl_wait_until_transmitted(struct ssh_packet *packet)\n{\n\twait_event(packet->ptl->tx.packet_wq,\n\t\t   test_bit(SSH_PACKET_SF_TRANSMITTED_BIT, &packet->state) ||\n\t\t   test_bit(SSH_PACKET_SF_LOCKED_BIT, &packet->state));\n}\n\nstatic void ssh_ptl_acknowledge(struct ssh_ptl *ptl, u8 seq)\n{\n\tstruct ssh_packet *p;\n\n\tp = ssh_ptl_ack_pop(ptl, seq);\n\tif (IS_ERR(p)) {\n\t\tif (PTR_ERR(p) == -ENOENT) {\n\t\t\t \n\t\t\tptl_warn(ptl, \"ptl: received ACK for non-pending packet\\n\");\n\t\t} else {\n\t\t\t \n\t\t\tWARN_ON(PTR_ERR(p) != -EPERM);\n\t\t}\n\t\treturn;\n\t}\n\n\tptl_dbg(ptl, \"ptl: received ACK for packet %p\\n\", p);\n\n\t \n\tssh_ptl_wait_until_transmitted(p);\n\n\t \n\tif (unlikely(test_and_set_bit(SSH_PACKET_SF_LOCKED_BIT, &p->state))) {\n\t\tif (unlikely(!test_bit(SSH_PACKET_SF_TRANSMITTED_BIT, &p->state)))\n\t\t\tptl_err(ptl, \"ptl: received ACK before packet had been fully transmitted\\n\");\n\n\t\tssh_packet_put(p);\n\t\treturn;\n\t}\n\n\tssh_ptl_remove_and_complete(p, 0);\n\tssh_packet_put(p);\n\n\tif (atomic_read(&ptl->pending.count) < SSH_PTL_MAX_PENDING)\n\t\tssh_ptl_tx_wakeup_packet(ptl);\n}\n\n \nint ssh_ptl_submit(struct ssh_ptl *ptl, struct ssh_packet *p)\n{\n\tstruct ssh_ptl *ptl_old;\n\tint status;\n\n\ttrace_ssam_packet_submit(p);\n\n\t \n\tif (test_bit(SSH_PACKET_TY_FLUSH_BIT, &p->state)) {\n\t\tif (p->data.ptr || test_bit(SSH_PACKET_TY_SEQUENCED_BIT, &p->state))\n\t\t\treturn -EINVAL;\n\t} else if (!p->data.ptr) {\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tptl_old = READ_ONCE(p->ptl);\n\tif (!ptl_old)\n\t\tWRITE_ONCE(p->ptl, ptl);\n\telse if (WARN_ON(ptl_old != ptl))\n\t\treturn -EALREADY;\t \n\n\tstatus = ssh_ptl_queue_push(p);\n\tif (status)\n\t\treturn status;\n\n\tif (!test_bit(SSH_PACKET_TY_BLOCKING_BIT, &p->state) ||\n\t    (atomic_read(&ptl->pending.count) < SSH_PTL_MAX_PENDING))\n\t\tssh_ptl_tx_wakeup_packet(ptl);\n\n\treturn 0;\n}\n\n \nstatic int __ssh_ptl_resubmit(struct ssh_packet *packet)\n{\n\tint status;\n\tu8 try;\n\n\tlockdep_assert_held(&packet->ptl->pending.lock);\n\n\ttrace_ssam_packet_resubmit(packet);\n\n\tspin_lock(&packet->ptl->queue.lock);\n\n\t \n\ttry = ssh_packet_priority_get_try(packet->priority);\n\tif (try >= SSH_PTL_MAX_PACKET_TRIES) {\n\t\tspin_unlock(&packet->ptl->queue.lock);\n\t\treturn -ECANCELED;\n\t}\n\n\tstatus = __ssh_ptl_queue_push(packet);\n\tif (status) {\n\t\t \n\t\tspin_unlock(&packet->ptl->queue.lock);\n\t\treturn status;\n\t}\n\n\tpacket->timestamp = KTIME_MAX;\n\n\tspin_unlock(&packet->ptl->queue.lock);\n\treturn 0;\n}\n\nstatic void ssh_ptl_resubmit_pending(struct ssh_ptl *ptl)\n{\n\tstruct ssh_packet *p;\n\tbool resub = false;\n\n\t \n\n\tspin_lock(&ptl->pending.lock);\n\n\t \n\tlist_for_each_entry(p, &ptl->pending.head, pending_node) {\n\t\t \n\t\tif (!__ssh_ptl_resubmit(p))\n\t\t\tresub = true;\n\t}\n\n\tspin_unlock(&ptl->pending.lock);\n\n\tif (resub)\n\t\tssh_ptl_tx_wakeup_packet(ptl);\n}\n\n \nvoid ssh_ptl_cancel(struct ssh_packet *p)\n{\n\tif (test_and_set_bit(SSH_PACKET_SF_CANCELED_BIT, &p->state))\n\t\treturn;\n\n\ttrace_ssam_packet_cancel(p);\n\n\t \n\tif (test_and_set_bit(SSH_PACKET_SF_LOCKED_BIT, &p->state))\n\t\treturn;\n\n\t \n\n\tif (READ_ONCE(p->ptl)) {\n\t\tssh_ptl_remove_and_complete(p, -ECANCELED);\n\n\t\tif (atomic_read(&p->ptl->pending.count) < SSH_PTL_MAX_PENDING)\n\t\t\tssh_ptl_tx_wakeup_packet(p->ptl);\n\n\t} else if (!test_and_set_bit(SSH_PACKET_SF_COMPLETED_BIT, &p->state)) {\n\t\t__ssh_ptl_complete(p, -ECANCELED);\n\t}\n}\n\n \nstatic ktime_t ssh_packet_get_expiration(struct ssh_packet *p, ktime_t timeout)\n{\n\tlockdep_assert_held(&p->ptl->pending.lock);\n\n\tif (p->timestamp != KTIME_MAX)\n\t\treturn ktime_add(p->timestamp, timeout);\n\telse\n\t\treturn KTIME_MAX;\n}\n\nstatic void ssh_ptl_timeout_reap(struct work_struct *work)\n{\n\tstruct ssh_ptl *ptl = to_ssh_ptl(work, rtx_timeout.reaper.work);\n\tstruct ssh_packet *p, *n;\n\tLIST_HEAD(claimed);\n\tktime_t now = ktime_get_coarse_boottime();\n\tktime_t timeout = ptl->rtx_timeout.timeout;\n\tktime_t next = KTIME_MAX;\n\tbool resub = false;\n\tint status;\n\n\ttrace_ssam_ptl_timeout_reap(atomic_read(&ptl->pending.count));\n\n\t \n\tspin_lock(&ptl->rtx_timeout.lock);\n\tptl->rtx_timeout.expires = KTIME_MAX;\n\tspin_unlock(&ptl->rtx_timeout.lock);\n\n\tspin_lock(&ptl->pending.lock);\n\n\tlist_for_each_entry_safe(p, n, &ptl->pending.head, pending_node) {\n\t\tktime_t expires = ssh_packet_get_expiration(p, timeout);\n\n\t\t \n\t\tif (ktime_after(expires, now)) {\n\t\t\tnext = ktime_before(expires, next) ? expires : next;\n\t\t\tcontinue;\n\t\t}\n\n\t\ttrace_ssam_packet_timeout(p);\n\n\t\tstatus = __ssh_ptl_resubmit(p);\n\n\t\t \n\t\tif (!status)\n\t\t\tresub = true;\n\n\t\t \n\t\tif (status != -ECANCELED)\n\t\t\tcontinue;\n\n\t\t \n\n\t\t \n\t\tif (test_and_set_bit(SSH_PACKET_SF_LOCKED_BIT, &p->state))\n\t\t\tcontinue;\n\n\t\t \n\n\t\tclear_bit(SSH_PACKET_SF_PENDING_BIT, &p->state);\n\n\t\tatomic_dec(&ptl->pending.count);\n\t\tlist_move_tail(&p->pending_node, &claimed);\n\t}\n\n\tspin_unlock(&ptl->pending.lock);\n\n\t \n\tlist_for_each_entry_safe(p, n, &claimed, pending_node) {\n\t\tif (!test_and_set_bit(SSH_PACKET_SF_COMPLETED_BIT, &p->state)) {\n\t\t\tssh_ptl_queue_remove(p);\n\t\t\t__ssh_ptl_complete(p, -ETIMEDOUT);\n\t\t}\n\n\t\t \n\t\tlist_del(&p->pending_node);\n\t\tssh_packet_put(p);\n\t}\n\n\t \n\tnext = max(next, ktime_add(now, SSH_PTL_PACKET_TIMEOUT_RESOLUTION));\n\tif (next != KTIME_MAX)\n\t\tssh_ptl_timeout_reaper_mod(ptl, now, next);\n\n\tif (resub)\n\t\tssh_ptl_tx_wakeup_packet(ptl);\n}\n\nstatic bool ssh_ptl_rx_retransmit_check(struct ssh_ptl *ptl, const struct ssh_frame *frame)\n{\n\tint i;\n\n\t \n\tif (frame->type == SSH_FRAME_TYPE_DATA_NSQ)\n\t\treturn false;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(ptl->rx.blocked.seqs); i++) {\n\t\tif (likely(ptl->rx.blocked.seqs[i] != frame->seq))\n\t\t\tcontinue;\n\n\t\tptl_dbg(ptl, \"ptl: ignoring repeated data packet\\n\");\n\t\treturn true;\n\t}\n\n\t \n\tptl->rx.blocked.seqs[ptl->rx.blocked.offset] = frame->seq;\n\tptl->rx.blocked.offset = (ptl->rx.blocked.offset + 1)\n\t\t\t\t  % ARRAY_SIZE(ptl->rx.blocked.seqs);\n\n\treturn false;\n}\n\nstatic void ssh_ptl_rx_dataframe(struct ssh_ptl *ptl,\n\t\t\t\t const struct ssh_frame *frame,\n\t\t\t\t const struct ssam_span *payload)\n{\n\tif (ssh_ptl_rx_retransmit_check(ptl, frame))\n\t\treturn;\n\n\tptl->ops.data_received(ptl, payload);\n}\n\nstatic void ssh_ptl_send_ack(struct ssh_ptl *ptl, u8 seq)\n{\n\tstruct ssh_packet *packet;\n\tstruct ssam_span buf;\n\tstruct msgbuf msgb;\n\tint status;\n\n\tstatus = ssh_ctrl_packet_alloc(&packet, &buf, GFP_KERNEL);\n\tif (status) {\n\t\tptl_err(ptl, \"ptl: failed to allocate ACK packet\\n\");\n\t\treturn;\n\t}\n\n\tssh_packet_init(packet, 0, SSH_PACKET_PRIORITY(ACK, 0),\n\t\t\t&ssh_ptl_ctrl_packet_ops);\n\n\tmsgb_init(&msgb, buf.ptr, buf.len);\n\tmsgb_push_ack(&msgb, seq);\n\tssh_packet_set_data(packet, msgb.begin, msgb_bytes_used(&msgb));\n\n\tssh_ptl_submit(ptl, packet);\n\tssh_packet_put(packet);\n}\n\nstatic void ssh_ptl_send_nak(struct ssh_ptl *ptl)\n{\n\tstruct ssh_packet *packet;\n\tstruct ssam_span buf;\n\tstruct msgbuf msgb;\n\tint status;\n\n\tstatus = ssh_ctrl_packet_alloc(&packet, &buf, GFP_KERNEL);\n\tif (status) {\n\t\tptl_err(ptl, \"ptl: failed to allocate NAK packet\\n\");\n\t\treturn;\n\t}\n\n\tssh_packet_init(packet, 0, SSH_PACKET_PRIORITY(NAK, 0),\n\t\t\t&ssh_ptl_ctrl_packet_ops);\n\n\tmsgb_init(&msgb, buf.ptr, buf.len);\n\tmsgb_push_nak(&msgb);\n\tssh_packet_set_data(packet, msgb.begin, msgb_bytes_used(&msgb));\n\n\tssh_ptl_submit(ptl, packet);\n\tssh_packet_put(packet);\n}\n\nstatic size_t ssh_ptl_rx_eval(struct ssh_ptl *ptl, struct ssam_span *source)\n{\n\tstruct ssh_frame *frame;\n\tstruct ssam_span payload;\n\tstruct ssam_span aligned;\n\tbool syn_found;\n\tint status;\n\n\t \n\tssh_ptl_rx_inject_invalid_syn(ptl, source);\n\n\t \n\tsyn_found = sshp_find_syn(source, &aligned);\n\n\tif (unlikely(aligned.ptr != source->ptr)) {\n\t\t \n\n\t\tptl_warn(ptl, \"rx: parser: invalid start of frame, skipping\\n\");\n\n\t\t \n\t\tssh_ptl_send_nak(ptl);\n\t}\n\n\tif (unlikely(!syn_found))\n\t\treturn aligned.ptr - source->ptr;\n\n\t \n\tssh_ptl_rx_inject_invalid_data(ptl, &aligned);\n\n\t \n\tstatus = sshp_parse_frame(&ptl->serdev->dev, &aligned, &frame, &payload,\n\t\t\t\t  SSH_PTL_RX_BUF_LEN);\n\tif (status)\t \n\t\treturn aligned.ptr - source->ptr + sizeof(u16);\n\tif (!frame)\t \n\t\treturn aligned.ptr - source->ptr;\n\n\ttrace_ssam_rx_frame_received(frame);\n\n\tswitch (frame->type) {\n\tcase SSH_FRAME_TYPE_ACK:\n\t\tssh_ptl_acknowledge(ptl, frame->seq);\n\t\tbreak;\n\n\tcase SSH_FRAME_TYPE_NAK:\n\t\tssh_ptl_resubmit_pending(ptl);\n\t\tbreak;\n\n\tcase SSH_FRAME_TYPE_DATA_SEQ:\n\t\tssh_ptl_send_ack(ptl, frame->seq);\n\t\tfallthrough;\n\n\tcase SSH_FRAME_TYPE_DATA_NSQ:\n\t\tssh_ptl_rx_dataframe(ptl, frame, &payload);\n\t\tbreak;\n\n\tdefault:\n\t\tptl_warn(ptl, \"ptl: received frame with unknown type %#04x\\n\",\n\t\t\t frame->type);\n\t\tbreak;\n\t}\n\n\treturn aligned.ptr - source->ptr + SSH_MESSAGE_LENGTH(payload.len);\n}\n\nstatic int ssh_ptl_rx_threadfn(void *data)\n{\n\tstruct ssh_ptl *ptl = data;\n\n\twhile (true) {\n\t\tstruct ssam_span span;\n\t\tsize_t offs = 0;\n\t\tsize_t n;\n\n\t\twait_event_interruptible(ptl->rx.wq,\n\t\t\t\t\t !kfifo_is_empty(&ptl->rx.fifo) ||\n\t\t\t\t\t kthread_should_stop());\n\t\tif (kthread_should_stop())\n\t\t\tbreak;\n\n\t\t \n\t\tn = sshp_buf_read_from_fifo(&ptl->rx.buf, &ptl->rx.fifo);\n\n\t\tptl_dbg(ptl, \"rx: received data (size: %zu)\\n\", n);\n\t\tprint_hex_dump_debug(\"rx: \", DUMP_PREFIX_OFFSET, 16, 1,\n\t\t\t\t     ptl->rx.buf.ptr + ptl->rx.buf.len - n,\n\t\t\t\t     n, false);\n\n\t\t \n\t\twhile (offs < ptl->rx.buf.len) {\n\t\t\tsshp_buf_span_from(&ptl->rx.buf, offs, &span);\n\t\t\tn = ssh_ptl_rx_eval(ptl, &span);\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\t \n\n\t\t\toffs += n;\n\t\t}\n\n\t\t \n\t\tsshp_buf_drop(&ptl->rx.buf, offs);\n\t}\n\n\treturn 0;\n}\n\nstatic void ssh_ptl_rx_wakeup(struct ssh_ptl *ptl)\n{\n\twake_up(&ptl->rx.wq);\n}\n\n \nint ssh_ptl_rx_start(struct ssh_ptl *ptl)\n{\n\tif (ptl->rx.thread)\n\t\treturn 0;\n\n\tptl->rx.thread = kthread_run(ssh_ptl_rx_threadfn, ptl,\n\t\t\t\t     \"ssam_serial_hub-rx\");\n\tif (IS_ERR(ptl->rx.thread))\n\t\treturn PTR_ERR(ptl->rx.thread);\n\n\treturn 0;\n}\n\n \nint ssh_ptl_rx_stop(struct ssh_ptl *ptl)\n{\n\tint status = 0;\n\n\tif (ptl->rx.thread) {\n\t\tstatus = kthread_stop(ptl->rx.thread);\n\t\tptl->rx.thread = NULL;\n\t}\n\n\treturn status;\n}\n\n \nint ssh_ptl_rx_rcvbuf(struct ssh_ptl *ptl, const u8 *buf, size_t n)\n{\n\tint used;\n\n\tif (test_bit(SSH_PTL_SF_SHUTDOWN_BIT, &ptl->state))\n\t\treturn -ESHUTDOWN;\n\n\tused = kfifo_in(&ptl->rx.fifo, buf, n);\n\tif (used)\n\t\tssh_ptl_rx_wakeup(ptl);\n\n\treturn used;\n}\n\n \nvoid ssh_ptl_shutdown(struct ssh_ptl *ptl)\n{\n\tLIST_HEAD(complete_q);\n\tLIST_HEAD(complete_p);\n\tstruct ssh_packet *p, *n;\n\tint status;\n\n\t \n\tset_bit(SSH_PTL_SF_SHUTDOWN_BIT, &ptl->state);\n\t \n\tsmp_mb__after_atomic();\n\n\tstatus = ssh_ptl_rx_stop(ptl);\n\tif (status)\n\t\tptl_err(ptl, \"ptl: failed to stop receiver thread\\n\");\n\n\tstatus = ssh_ptl_tx_stop(ptl);\n\tif (status)\n\t\tptl_err(ptl, \"ptl: failed to stop transmitter thread\\n\");\n\n\tcancel_delayed_work_sync(&ptl->rtx_timeout.reaper);\n\n\t \n\n\t \n\tspin_lock(&ptl->queue.lock);\n\tlist_for_each_entry_safe(p, n, &ptl->queue.head, queue_node) {\n\t\tset_bit(SSH_PACKET_SF_LOCKED_BIT, &p->state);\n\t\t \n\t\tsmp_mb__before_atomic();\n\t\tclear_bit(SSH_PACKET_SF_QUEUED_BIT, &p->state);\n\n\t\tlist_move_tail(&p->queue_node, &complete_q);\n\t}\n\tspin_unlock(&ptl->queue.lock);\n\n\t \n\tspin_lock(&ptl->pending.lock);\n\tlist_for_each_entry_safe(p, n, &ptl->pending.head, pending_node) {\n\t\tset_bit(SSH_PACKET_SF_LOCKED_BIT, &p->state);\n\t\t \n\t\tsmp_mb__before_atomic();\n\t\tclear_bit(SSH_PACKET_SF_PENDING_BIT, &p->state);\n\n\t\tlist_move_tail(&p->pending_node, &complete_q);\n\t}\n\tatomic_set(&ptl->pending.count, 0);\n\tspin_unlock(&ptl->pending.lock);\n\n\t \n\tlist_for_each_entry(p, &complete_q, queue_node) {\n\t\tif (!test_and_set_bit(SSH_PACKET_SF_COMPLETED_BIT, &p->state))\n\t\t\t__ssh_ptl_complete(p, -ESHUTDOWN);\n\n\t\tssh_packet_put(p);\n\t}\n\n\t \n\tlist_for_each_entry(p, &complete_p, pending_node) {\n\t\tif (!test_and_set_bit(SSH_PACKET_SF_COMPLETED_BIT, &p->state))\n\t\t\t__ssh_ptl_complete(p, -ESHUTDOWN);\n\n\t\tssh_packet_put(p);\n\t}\n\n\t \n}\n\n \nint ssh_ptl_init(struct ssh_ptl *ptl, struct serdev_device *serdev,\n\t\t struct ssh_ptl_ops *ops)\n{\n\tint i, status;\n\n\tptl->serdev = serdev;\n\tptl->state = 0;\n\n\tspin_lock_init(&ptl->queue.lock);\n\tINIT_LIST_HEAD(&ptl->queue.head);\n\n\tspin_lock_init(&ptl->pending.lock);\n\tINIT_LIST_HEAD(&ptl->pending.head);\n\tatomic_set_release(&ptl->pending.count, 0);\n\n\tptl->tx.thread = NULL;\n\tatomic_set(&ptl->tx.running, 0);\n\tinit_completion(&ptl->tx.thread_cplt_pkt);\n\tinit_completion(&ptl->tx.thread_cplt_tx);\n\tinit_waitqueue_head(&ptl->tx.packet_wq);\n\n\tptl->rx.thread = NULL;\n\tinit_waitqueue_head(&ptl->rx.wq);\n\n\tspin_lock_init(&ptl->rtx_timeout.lock);\n\tptl->rtx_timeout.timeout = SSH_PTL_PACKET_TIMEOUT;\n\tptl->rtx_timeout.expires = KTIME_MAX;\n\tINIT_DELAYED_WORK(&ptl->rtx_timeout.reaper, ssh_ptl_timeout_reap);\n\n\tptl->ops = *ops;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(ptl->rx.blocked.seqs); i++)\n\t\tptl->rx.blocked.seqs[i] = U16_MAX;\n\tptl->rx.blocked.offset = 0;\n\n\tstatus = kfifo_alloc(&ptl->rx.fifo, SSH_PTL_RX_FIFO_LEN, GFP_KERNEL);\n\tif (status)\n\t\treturn status;\n\n\tstatus = sshp_buf_alloc(&ptl->rx.buf, SSH_PTL_RX_BUF_LEN, GFP_KERNEL);\n\tif (status)\n\t\tkfifo_free(&ptl->rx.fifo);\n\n\treturn status;\n}\n\n \nvoid ssh_ptl_destroy(struct ssh_ptl *ptl)\n{\n\tkfifo_free(&ptl->rx.fifo);\n\tsshp_buf_free(&ptl->rx.buf);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}