{
  "module_name": "core.c",
  "hash_id": "c46a38fca52f242e737379ee7d67f5ad6813dbddb5baaec68f3109b5610394d1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/surface/aggregator/core.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/atomic.h>\n#include <linux/completion.h>\n#include <linux/gpio/consumer.h>\n#include <linux/kernel.h>\n#include <linux/kref.h>\n#include <linux/module.h>\n#include <linux/pm.h>\n#include <linux/serdev.h>\n#include <linux/sysfs.h>\n\n#include <linux/surface_aggregator/controller.h>\n#include <linux/surface_aggregator/device.h>\n\n#include \"bus.h\"\n#include \"controller.h\"\n\n#define CREATE_TRACE_POINTS\n#include \"trace.h\"\n\n\n \n\n \nstatic struct ssam_controller *__ssam_controller;\nstatic DEFINE_SPINLOCK(__ssam_controller_lock);\n\n \nstruct ssam_controller *ssam_get_controller(void)\n{\n\tstruct ssam_controller *ctrl;\n\n\tspin_lock(&__ssam_controller_lock);\n\n\tctrl = __ssam_controller;\n\tif (!ctrl)\n\t\tgoto out;\n\n\tif (WARN_ON(!kref_get_unless_zero(&ctrl->kref)))\n\t\tctrl = NULL;\n\nout:\n\tspin_unlock(&__ssam_controller_lock);\n\treturn ctrl;\n}\nEXPORT_SYMBOL_GPL(ssam_get_controller);\n\n \nstatic int ssam_try_set_controller(struct ssam_controller *ctrl)\n{\n\tint status = 0;\n\n\tspin_lock(&__ssam_controller_lock);\n\tif (!__ssam_controller)\n\t\t__ssam_controller = ctrl;\n\telse\n\t\tstatus = -EEXIST;\n\tspin_unlock(&__ssam_controller_lock);\n\n\treturn status;\n}\n\n \nstatic void ssam_clear_controller(void)\n{\n\tspin_lock(&__ssam_controller_lock);\n\t__ssam_controller = NULL;\n\tspin_unlock(&__ssam_controller_lock);\n}\n\n \nint ssam_client_link(struct ssam_controller *c, struct device *client)\n{\n\tconst u32 flags = DL_FLAG_PM_RUNTIME | DL_FLAG_AUTOREMOVE_CONSUMER;\n\tstruct device_link *link;\n\tstruct device *ctrldev;\n\n\tssam_controller_statelock(c);\n\n\tif (c->state != SSAM_CONTROLLER_STARTED) {\n\t\tssam_controller_stateunlock(c);\n\t\treturn -ENODEV;\n\t}\n\n\tctrldev = ssam_controller_device(c);\n\tif (!ctrldev) {\n\t\tssam_controller_stateunlock(c);\n\t\treturn -ENODEV;\n\t}\n\n\tlink = device_link_add(client, ctrldev, flags);\n\tif (!link) {\n\t\tssam_controller_stateunlock(c);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tif (READ_ONCE(link->status) == DL_STATE_SUPPLIER_UNBIND) {\n\t\tssam_controller_stateunlock(c);\n\t\treturn -ENODEV;\n\t}\n\n\tssam_controller_stateunlock(c);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ssam_client_link);\n\n \nstruct ssam_controller *ssam_client_bind(struct device *client)\n{\n\tstruct ssam_controller *c;\n\tint status;\n\n\tc = ssam_get_controller();\n\tif (!c)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tstatus = ssam_client_link(c, client);\n\n\t \n\tssam_controller_put(c);\n\n\treturn status >= 0 ? c : ERR_PTR(status);\n}\nEXPORT_SYMBOL_GPL(ssam_client_bind);\n\n\n \n\nstatic int ssam_receive_buf(struct serdev_device *dev, const unsigned char *buf,\n\t\t\t    size_t n)\n{\n\tstruct ssam_controller *ctrl;\n\tint ret;\n\n\tctrl = serdev_device_get_drvdata(dev);\n\tret = ssam_controller_receive_buf(ctrl, buf, n);\n\n\treturn ret < 0 ? 0 : ret;\n}\n\nstatic void ssam_write_wakeup(struct serdev_device *dev)\n{\n\tssam_controller_write_wakeup(serdev_device_get_drvdata(dev));\n}\n\nstatic const struct serdev_device_ops ssam_serdev_ops = {\n\t.receive_buf = ssam_receive_buf,\n\t.write_wakeup = ssam_write_wakeup,\n};\n\n\n \n\nstatic int ssam_log_firmware_version(struct ssam_controller *ctrl)\n{\n\tu32 version, a, b, c;\n\tint status;\n\n\tstatus = ssam_get_firmware_version(ctrl, &version);\n\tif (status)\n\t\treturn status;\n\n\ta = (version >> 24) & 0xff;\n\tb = ((version >> 8) & 0xffff);\n\tc = version & 0xff;\n\n\tssam_info(ctrl, \"SAM firmware version: %u.%u.%u\\n\", a, b, c);\n\treturn 0;\n}\n\nstatic ssize_t firmware_version_show(struct device *dev,\n\t\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct ssam_controller *ctrl = dev_get_drvdata(dev);\n\tu32 version, a, b, c;\n\tint status;\n\n\tstatus = ssam_get_firmware_version(ctrl, &version);\n\tif (status < 0)\n\t\treturn status;\n\n\ta = (version >> 24) & 0xff;\n\tb = ((version >> 8) & 0xffff);\n\tc = version & 0xff;\n\n\treturn sysfs_emit(buf, \"%u.%u.%u\\n\", a, b, c);\n}\nstatic DEVICE_ATTR_RO(firmware_version);\n\nstatic struct attribute *ssam_sam_attrs[] = {\n\t&dev_attr_firmware_version.attr,\n\tNULL\n};\n\nstatic const struct attribute_group ssam_sam_group = {\n\t.name = \"sam\",\n\t.attrs = ssam_sam_attrs,\n};\n\n\n \n\nstatic acpi_status ssam_serdev_setup_via_acpi_crs(struct acpi_resource *rsc,\n\t\t\t\t\t\t  void *ctx)\n{\n\tstruct serdev_device *serdev = ctx;\n\tstruct acpi_resource_uart_serialbus *uart;\n\tbool flow_control;\n\tint status = 0;\n\n\tif (!serdev_acpi_get_uart_resource(rsc, &uart))\n\t\treturn AE_OK;\n\n\t \n\tserdev_device_set_baudrate(serdev, uart->default_baud_rate);\n\n\t \n\tif (uart->flow_control & (~((u8)ACPI_UART_FLOW_CONTROL_HW))) {\n\t\tdev_warn(&serdev->dev, \"setup: unsupported flow control (value: %#04x)\\n\",\n\t\t\t uart->flow_control);\n\t}\n\n\t \n\tflow_control = uart->flow_control & ACPI_UART_FLOW_CONTROL_HW;\n\tserdev_device_set_flow_control(serdev, flow_control);\n\n\t \n\tswitch (uart->parity) {\n\tcase ACPI_UART_PARITY_NONE:\n\t\tstatus = serdev_device_set_parity(serdev, SERDEV_PARITY_NONE);\n\t\tbreak;\n\tcase ACPI_UART_PARITY_EVEN:\n\t\tstatus = serdev_device_set_parity(serdev, SERDEV_PARITY_EVEN);\n\t\tbreak;\n\tcase ACPI_UART_PARITY_ODD:\n\t\tstatus = serdev_device_set_parity(serdev, SERDEV_PARITY_ODD);\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(&serdev->dev, \"setup: unsupported parity (value: %#04x)\\n\",\n\t\t\t uart->parity);\n\t\tbreak;\n\t}\n\n\tif (status) {\n\t\tdev_err(&serdev->dev, \"setup: failed to set parity (value: %#04x, error: %d)\\n\",\n\t\t\tuart->parity, status);\n\t\treturn AE_ERROR;\n\t}\n\n\t \n\treturn AE_CTRL_TERMINATE;\n}\n\nstatic acpi_status ssam_serdev_setup_via_acpi(acpi_handle handle,\n\t\t\t\t\t      struct serdev_device *serdev)\n{\n\treturn acpi_walk_resources(handle, METHOD_NAME__CRS,\n\t\t\t\t   ssam_serdev_setup_via_acpi_crs, serdev);\n}\n\n\n \n\nstatic void ssam_serial_hub_shutdown(struct device *dev)\n{\n\tstruct ssam_controller *c = dev_get_drvdata(dev);\n\tint status;\n\n\t \n\n\tstatus = ssam_notifier_disable_registered(c);\n\tif (status) {\n\t\tssam_err(c, \"pm: failed to disable notifiers for shutdown: %d\\n\",\n\t\t\t status);\n\t}\n\n\tstatus = ssam_ctrl_notif_display_off(c);\n\tif (status)\n\t\tssam_err(c, \"pm: display-off notification failed: %d\\n\", status);\n\n\tstatus = ssam_ctrl_notif_d0_exit(c);\n\tif (status)\n\t\tssam_err(c, \"pm: D0-exit notification failed: %d\\n\", status);\n}\n\n#ifdef CONFIG_PM_SLEEP\n\nstatic int ssam_serial_hub_pm_prepare(struct device *dev)\n{\n\tstruct ssam_controller *c = dev_get_drvdata(dev);\n\tint status;\n\n\t \n\n\tstatus = ssam_ctrl_notif_display_off(c);\n\tif (status)\n\t\tssam_err(c, \"pm: display-off notification failed: %d\\n\", status);\n\n\treturn status;\n}\n\nstatic void ssam_serial_hub_pm_complete(struct device *dev)\n{\n\tstruct ssam_controller *c = dev_get_drvdata(dev);\n\tint status;\n\n\t \n\n\tstatus = ssam_ctrl_notif_display_on(c);\n\tif (status)\n\t\tssam_err(c, \"pm: display-on notification failed: %d\\n\", status);\n}\n\nstatic int ssam_serial_hub_pm_suspend(struct device *dev)\n{\n\tstruct ssam_controller *c = dev_get_drvdata(dev);\n\tint status;\n\n\t \n\n\tstatus = ssam_ctrl_notif_d0_exit(c);\n\tif (status) {\n\t\tssam_err(c, \"pm: D0-exit notification failed: %d\\n\", status);\n\t\tgoto err_notif;\n\t}\n\n\tstatus = ssam_irq_arm_for_wakeup(c);\n\tif (status)\n\t\tgoto err_irq;\n\n\tWARN_ON(ssam_controller_suspend(c));\n\treturn 0;\n\nerr_irq:\n\tssam_ctrl_notif_d0_entry(c);\nerr_notif:\n\tssam_ctrl_notif_display_on(c);\n\treturn status;\n}\n\nstatic int ssam_serial_hub_pm_resume(struct device *dev)\n{\n\tstruct ssam_controller *c = dev_get_drvdata(dev);\n\tint status;\n\n\tWARN_ON(ssam_controller_resume(c));\n\n\t \n\n\tssam_irq_disarm_wakeup(c);\n\n\tstatus = ssam_ctrl_notif_d0_entry(c);\n\tif (status)\n\t\tssam_err(c, \"pm: D0-entry notification failed: %d\\n\", status);\n\n\treturn 0;\n}\n\nstatic int ssam_serial_hub_pm_freeze(struct device *dev)\n{\n\tstruct ssam_controller *c = dev_get_drvdata(dev);\n\tint status;\n\n\t \n\n\tstatus = ssam_ctrl_notif_d0_exit(c);\n\tif (status) {\n\t\tssam_err(c, \"pm: D0-exit notification failed: %d\\n\", status);\n\t\tssam_ctrl_notif_display_on(c);\n\t\treturn status;\n\t}\n\n\tWARN_ON(ssam_controller_suspend(c));\n\treturn 0;\n}\n\nstatic int ssam_serial_hub_pm_thaw(struct device *dev)\n{\n\tstruct ssam_controller *c = dev_get_drvdata(dev);\n\tint status;\n\n\tWARN_ON(ssam_controller_resume(c));\n\n\tstatus = ssam_ctrl_notif_d0_entry(c);\n\tif (status)\n\t\tssam_err(c, \"pm: D0-exit notification failed: %d\\n\", status);\n\n\treturn status;\n}\n\nstatic int ssam_serial_hub_pm_poweroff(struct device *dev)\n{\n\tstruct ssam_controller *c = dev_get_drvdata(dev);\n\tint status;\n\n\t \n\n\tstatus = ssam_notifier_disable_registered(c);\n\tif (status) {\n\t\tssam_err(c, \"pm: failed to disable notifiers for hibernation: %d\\n\",\n\t\t\t status);\n\t\treturn status;\n\t}\n\n\tstatus = ssam_ctrl_notif_d0_exit(c);\n\tif (status) {\n\t\tssam_err(c, \"pm: D0-exit notification failed: %d\\n\", status);\n\t\tssam_notifier_restore_registered(c);\n\t\treturn status;\n\t}\n\n\tWARN_ON(ssam_controller_suspend(c));\n\treturn 0;\n}\n\nstatic int ssam_serial_hub_pm_restore(struct device *dev)\n{\n\tstruct ssam_controller *c = dev_get_drvdata(dev);\n\tint status;\n\n\t \n\n\tWARN_ON(ssam_controller_resume(c));\n\n\tstatus = ssam_ctrl_notif_d0_entry(c);\n\tif (status)\n\t\tssam_err(c, \"pm: D0-entry notification failed: %d\\n\", status);\n\n\tssam_notifier_restore_registered(c);\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops ssam_serial_hub_pm_ops = {\n\t.prepare  = ssam_serial_hub_pm_prepare,\n\t.complete = ssam_serial_hub_pm_complete,\n\t.suspend  = ssam_serial_hub_pm_suspend,\n\t.resume   = ssam_serial_hub_pm_resume,\n\t.freeze   = ssam_serial_hub_pm_freeze,\n\t.thaw     = ssam_serial_hub_pm_thaw,\n\t.poweroff = ssam_serial_hub_pm_poweroff,\n\t.restore  = ssam_serial_hub_pm_restore,\n};\n\n#else  \n\nstatic const struct dev_pm_ops ssam_serial_hub_pm_ops = { };\n\n#endif  \n\n\n \n\nstatic const struct acpi_gpio_params gpio_ssam_wakeup_int = { 0, 0, false };\nstatic const struct acpi_gpio_params gpio_ssam_wakeup     = { 1, 0, false };\n\nstatic const struct acpi_gpio_mapping ssam_acpi_gpios[] = {\n\t{ \"ssam_wakeup-int-gpio\", &gpio_ssam_wakeup_int, 1 },\n\t{ \"ssam_wakeup-gpio\",     &gpio_ssam_wakeup,     1 },\n\t{ },\n};\n\nstatic int ssam_serial_hub_probe(struct serdev_device *serdev)\n{\n\tstruct acpi_device *ssh = ACPI_COMPANION(&serdev->dev);\n\tstruct ssam_controller *ctrl;\n\tacpi_status astatus;\n\tint status;\n\n\tif (gpiod_count(&serdev->dev, NULL) < 0)\n\t\treturn -ENODEV;\n\n\tstatus = devm_acpi_dev_add_driver_gpios(&serdev->dev, ssam_acpi_gpios);\n\tif (status)\n\t\treturn status;\n\n\t \n\tctrl = kzalloc(sizeof(*ctrl), GFP_KERNEL);\n\tif (!ctrl)\n\t\treturn -ENOMEM;\n\n\t \n\tstatus = ssam_controller_init(ctrl, serdev);\n\tif (status)\n\t\tgoto err_ctrl_init;\n\n\tssam_controller_lock(ctrl);\n\n\t \n\tserdev_device_set_drvdata(serdev, ctrl);\n\tserdev_device_set_client_ops(serdev, &ssam_serdev_ops);\n\tstatus = serdev_device_open(serdev);\n\tif (status)\n\t\tgoto err_devopen;\n\n\tastatus = ssam_serdev_setup_via_acpi(ssh->handle, serdev);\n\tif (ACPI_FAILURE(astatus)) {\n\t\tstatus = -ENXIO;\n\t\tgoto err_devinit;\n\t}\n\n\t \n\tstatus = ssam_controller_start(ctrl);\n\tif (status)\n\t\tgoto err_devinit;\n\n\tssam_controller_unlock(ctrl);\n\n\t \n\tstatus = ssam_log_firmware_version(ctrl);\n\tif (status)\n\t\tgoto err_initrq;\n\n\tstatus = ssam_ctrl_notif_d0_entry(ctrl);\n\tif (status)\n\t\tgoto err_initrq;\n\n\tstatus = ssam_ctrl_notif_display_on(ctrl);\n\tif (status)\n\t\tgoto err_initrq;\n\n\tstatus = sysfs_create_group(&serdev->dev.kobj, &ssam_sam_group);\n\tif (status)\n\t\tgoto err_initrq;\n\n\t \n\tstatus = ssam_irq_setup(ctrl);\n\tif (status)\n\t\tgoto err_irq;\n\n\t \n\tstatus = ssam_try_set_controller(ctrl);\n\tif (WARN_ON(status))\t \n\t\tgoto err_mainref;\n\n\t \n\tdevice_set_wakeup_capable(&serdev->dev, true);\n\tacpi_dev_clear_dependencies(ssh);\n\n\treturn 0;\n\nerr_mainref:\n\tssam_irq_free(ctrl);\nerr_irq:\n\tsysfs_remove_group(&serdev->dev.kobj, &ssam_sam_group);\nerr_initrq:\n\tssam_controller_lock(ctrl);\n\tssam_controller_shutdown(ctrl);\nerr_devinit:\n\tserdev_device_close(serdev);\nerr_devopen:\n\tssam_controller_destroy(ctrl);\n\tssam_controller_unlock(ctrl);\nerr_ctrl_init:\n\tkfree(ctrl);\n\treturn status;\n}\n\nstatic void ssam_serial_hub_remove(struct serdev_device *serdev)\n{\n\tstruct ssam_controller *ctrl = serdev_device_get_drvdata(serdev);\n\tint status;\n\n\t \n\tssam_clear_controller();\n\n\t \n\tssam_irq_free(ctrl);\n\n\tsysfs_remove_group(&serdev->dev.kobj, &ssam_sam_group);\n\tssam_controller_lock(ctrl);\n\n\t \n\tssam_remove_clients(&serdev->dev);\n\n\t \n\tstatus = ssam_ctrl_notif_display_off(ctrl);\n\tif (status) {\n\t\tdev_err(&serdev->dev, \"display-off notification failed: %d\\n\",\n\t\t\tstatus);\n\t}\n\n\tstatus = ssam_ctrl_notif_d0_exit(ctrl);\n\tif (status) {\n\t\tdev_err(&serdev->dev, \"D0-exit notification failed: %d\\n\",\n\t\t\tstatus);\n\t}\n\n\t \n\tssam_controller_shutdown(ctrl);\n\n\t \n\tserdev_device_wait_until_sent(serdev, 0);\n\tserdev_device_close(serdev);\n\n\t \n\tssam_controller_unlock(ctrl);\n\tssam_controller_put(ctrl);\n\n\tdevice_set_wakeup_capable(&serdev->dev, false);\n}\n\nstatic const struct acpi_device_id ssam_serial_hub_match[] = {\n\t{ \"MSHW0084\", 0 },\n\t{ },\n};\nMODULE_DEVICE_TABLE(acpi, ssam_serial_hub_match);\n\nstatic struct serdev_device_driver ssam_serial_hub = {\n\t.probe = ssam_serial_hub_probe,\n\t.remove = ssam_serial_hub_remove,\n\t.driver = {\n\t\t.name = \"surface_serial_hub\",\n\t\t.acpi_match_table = ssam_serial_hub_match,\n\t\t.pm = &ssam_serial_hub_pm_ops,\n\t\t.shutdown = ssam_serial_hub_shutdown,\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t},\n};\n\n\n \n\nstatic int __init ssam_core_init(void)\n{\n\tint status;\n\n\tstatus = ssam_bus_register();\n\tif (status)\n\t\tgoto err_bus;\n\n\tstatus = ssh_ctrl_packet_cache_init();\n\tif (status)\n\t\tgoto err_cpkg;\n\n\tstatus = ssam_event_item_cache_init();\n\tif (status)\n\t\tgoto err_evitem;\n\n\tstatus = serdev_device_driver_register(&ssam_serial_hub);\n\tif (status)\n\t\tgoto err_register;\n\n\treturn 0;\n\nerr_register:\n\tssam_event_item_cache_destroy();\nerr_evitem:\n\tssh_ctrl_packet_cache_destroy();\nerr_cpkg:\n\tssam_bus_unregister();\nerr_bus:\n\treturn status;\n}\nsubsys_initcall(ssam_core_init);\n\nstatic void __exit ssam_core_exit(void)\n{\n\tserdev_device_driver_unregister(&ssam_serial_hub);\n\tssam_event_item_cache_destroy();\n\tssh_ctrl_packet_cache_destroy();\n\tssam_bus_unregister();\n}\nmodule_exit(ssam_core_exit);\n\nMODULE_AUTHOR(\"Maximilian Luz <luzmaximilian@gmail.com>\");\nMODULE_DESCRIPTION(\"Subsystem and Surface Serial Hub driver for Surface System Aggregator Module\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}