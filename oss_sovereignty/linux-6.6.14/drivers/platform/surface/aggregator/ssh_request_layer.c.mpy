{
  "module_name": "ssh_request_layer.c",
  "hash_id": "a3b9d9d49e8114bb34eaac5bdf6faea72bf79e949796ab13df5f838fdd0af033",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/surface/aggregator/ssh_request_layer.c",
  "human_readable_source": "\n \n\n#include <asm/unaligned.h>\n#include <linux/atomic.h>\n#include <linux/completion.h>\n#include <linux/error-injection.h>\n#include <linux/ktime.h>\n#include <linux/limits.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/workqueue.h>\n\n#include <linux/surface_aggregator/serial_hub.h>\n#include <linux/surface_aggregator/controller.h>\n\n#include \"ssh_packet_layer.h\"\n#include \"ssh_request_layer.h\"\n\n#include \"trace.h\"\n\n \n#define SSH_RTL_REQUEST_TIMEOUT\t\t\tms_to_ktime(3000)\n\n \n#define SSH_RTL_REQUEST_TIMEOUT_RESOLUTION\tms_to_ktime(max(2000 / HZ, 50))\n\n \n#define SSH_RTL_MAX_PENDING\t\t3\n\n \n#define SSH_RTL_TX_BATCH\t\t10\n\n#ifdef CONFIG_SURFACE_AGGREGATOR_ERROR_INJECTION\n\n \nstatic noinline bool ssh_rtl_should_drop_response(void)\n{\n\treturn false;\n}\nALLOW_ERROR_INJECTION(ssh_rtl_should_drop_response, TRUE);\n\n#else\n\nstatic inline bool ssh_rtl_should_drop_response(void)\n{\n\treturn false;\n}\n\n#endif\n\nstatic u16 ssh_request_get_rqid(struct ssh_request *rqst)\n{\n\treturn get_unaligned_le16(rqst->packet.data.ptr\n\t\t\t\t  + SSH_MSGOFFSET_COMMAND(rqid));\n}\n\nstatic u32 ssh_request_get_rqid_safe(struct ssh_request *rqst)\n{\n\tif (!rqst->packet.data.ptr)\n\t\treturn U32_MAX;\n\n\treturn ssh_request_get_rqid(rqst);\n}\n\nstatic void ssh_rtl_queue_remove(struct ssh_request *rqst)\n{\n\tstruct ssh_rtl *rtl = ssh_request_rtl(rqst);\n\n\tspin_lock(&rtl->queue.lock);\n\n\tif (!test_and_clear_bit(SSH_REQUEST_SF_QUEUED_BIT, &rqst->state)) {\n\t\tspin_unlock(&rtl->queue.lock);\n\t\treturn;\n\t}\n\n\tlist_del(&rqst->node);\n\n\tspin_unlock(&rtl->queue.lock);\n\tssh_request_put(rqst);\n}\n\nstatic bool ssh_rtl_queue_empty(struct ssh_rtl *rtl)\n{\n\tbool empty;\n\n\tspin_lock(&rtl->queue.lock);\n\tempty = list_empty(&rtl->queue.head);\n\tspin_unlock(&rtl->queue.lock);\n\n\treturn empty;\n}\n\nstatic void ssh_rtl_pending_remove(struct ssh_request *rqst)\n{\n\tstruct ssh_rtl *rtl = ssh_request_rtl(rqst);\n\n\tspin_lock(&rtl->pending.lock);\n\n\tif (!test_and_clear_bit(SSH_REQUEST_SF_PENDING_BIT, &rqst->state)) {\n\t\tspin_unlock(&rtl->pending.lock);\n\t\treturn;\n\t}\n\n\tatomic_dec(&rtl->pending.count);\n\tlist_del(&rqst->node);\n\n\tspin_unlock(&rtl->pending.lock);\n\n\tssh_request_put(rqst);\n}\n\nstatic int ssh_rtl_tx_pending_push(struct ssh_request *rqst)\n{\n\tstruct ssh_rtl *rtl = ssh_request_rtl(rqst);\n\n\tspin_lock(&rtl->pending.lock);\n\n\tif (test_bit(SSH_REQUEST_SF_LOCKED_BIT, &rqst->state)) {\n\t\tspin_unlock(&rtl->pending.lock);\n\t\treturn -EINVAL;\n\t}\n\n\tif (test_and_set_bit(SSH_REQUEST_SF_PENDING_BIT, &rqst->state)) {\n\t\tspin_unlock(&rtl->pending.lock);\n\t\treturn -EALREADY;\n\t}\n\n\tatomic_inc(&rtl->pending.count);\n\tlist_add_tail(&ssh_request_get(rqst)->node, &rtl->pending.head);\n\n\tspin_unlock(&rtl->pending.lock);\n\treturn 0;\n}\n\nstatic void ssh_rtl_complete_with_status(struct ssh_request *rqst, int status)\n{\n\tstruct ssh_rtl *rtl = ssh_request_rtl(rqst);\n\n\ttrace_ssam_request_complete(rqst, status);\n\n\t \n\trtl_dbg_cond(rtl, \"rtl: completing request (rqid: %#06x, status: %d)\\n\",\n\t\t     ssh_request_get_rqid_safe(rqst), status);\n\n\trqst->ops->complete(rqst, NULL, NULL, status);\n}\n\nstatic void ssh_rtl_complete_with_rsp(struct ssh_request *rqst,\n\t\t\t\t      const struct ssh_command *cmd,\n\t\t\t\t      const struct ssam_span *data)\n{\n\tstruct ssh_rtl *rtl = ssh_request_rtl(rqst);\n\n\ttrace_ssam_request_complete(rqst, 0);\n\n\trtl_dbg(rtl, \"rtl: completing request with response (rqid: %#06x)\\n\",\n\t\tssh_request_get_rqid(rqst));\n\n\trqst->ops->complete(rqst, cmd, data, 0);\n}\n\nstatic bool ssh_rtl_tx_can_process(struct ssh_request *rqst)\n{\n\tstruct ssh_rtl *rtl = ssh_request_rtl(rqst);\n\n\tif (test_bit(SSH_REQUEST_TY_FLUSH_BIT, &rqst->state))\n\t\treturn !atomic_read(&rtl->pending.count);\n\n\treturn atomic_read(&rtl->pending.count) < SSH_RTL_MAX_PENDING;\n}\n\nstatic struct ssh_request *ssh_rtl_tx_next(struct ssh_rtl *rtl)\n{\n\tstruct ssh_request *rqst = ERR_PTR(-ENOENT);\n\tstruct ssh_request *p, *n;\n\n\tspin_lock(&rtl->queue.lock);\n\n\t \n\tlist_for_each_entry_safe(p, n, &rtl->queue.head, node) {\n\t\tif (unlikely(test_bit(SSH_REQUEST_SF_LOCKED_BIT, &p->state)))\n\t\t\tcontinue;\n\n\t\tif (!ssh_rtl_tx_can_process(p)) {\n\t\t\trqst = ERR_PTR(-EBUSY);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tset_bit(SSH_REQUEST_SF_TRANSMITTING_BIT, &p->state);\n\t\t \n\t\tsmp_mb__before_atomic();\n\t\tclear_bit(SSH_REQUEST_SF_QUEUED_BIT, &p->state);\n\n\t\tlist_del(&p->node);\n\n\t\trqst = p;\n\t\tbreak;\n\t}\n\n\tspin_unlock(&rtl->queue.lock);\n\treturn rqst;\n}\n\nstatic int ssh_rtl_tx_try_process_one(struct ssh_rtl *rtl)\n{\n\tstruct ssh_request *rqst;\n\tint status;\n\n\t \n\trqst = ssh_rtl_tx_next(rtl);\n\tif (IS_ERR(rqst))\n\t\treturn PTR_ERR(rqst);\n\n\t \n\tstatus = ssh_rtl_tx_pending_push(rqst);\n\tif (status) {\n\t\tssh_request_put(rqst);\n\t\treturn -EAGAIN;\n\t}\n\n\t \n\tstatus = ssh_ptl_submit(&rtl->ptl, &rqst->packet);\n\tif (status == -ESHUTDOWN) {\n\t\t \n\t\tset_bit(SSH_REQUEST_SF_LOCKED_BIT, &rqst->state);\n\t\t \n\n\t\tssh_rtl_pending_remove(rqst);\n\t\tssh_rtl_complete_with_status(rqst, -ESHUTDOWN);\n\n\t\tssh_request_put(rqst);\n\t\treturn -ESHUTDOWN;\n\n\t} else if (status) {\n\t\t \n\n\t\tWARN_ON(status != -EINVAL);\n\n\t\tssh_request_put(rqst);\n\t\treturn -EAGAIN;\n\t}\n\n\tssh_request_put(rqst);\n\treturn 0;\n}\n\nstatic bool ssh_rtl_tx_schedule(struct ssh_rtl *rtl)\n{\n\tif (atomic_read(&rtl->pending.count) >= SSH_RTL_MAX_PENDING)\n\t\treturn false;\n\n\tif (ssh_rtl_queue_empty(rtl))\n\t\treturn false;\n\n\treturn schedule_work(&rtl->tx.work);\n}\n\nstatic void ssh_rtl_tx_work_fn(struct work_struct *work)\n{\n\tstruct ssh_rtl *rtl = to_ssh_rtl(work, tx.work);\n\tunsigned int iterations = SSH_RTL_TX_BATCH;\n\tint status;\n\n\t \n\tdo {\n\t\tstatus = ssh_rtl_tx_try_process_one(rtl);\n\t\tif (status == -ENOENT || status == -EBUSY)\n\t\t\treturn;\t\t \n\n\t\tif (status == -ESHUTDOWN) {\n\t\t\t \n\t\t\treturn;\n\t\t}\n\n\t\tWARN_ON(status != 0 && status != -EAGAIN);\n\t} while (--iterations);\n\n\t \n\tssh_rtl_tx_schedule(rtl);\n}\n\n \nint ssh_rtl_submit(struct ssh_rtl *rtl, struct ssh_request *rqst)\n{\n\ttrace_ssam_request_submit(rqst);\n\n\t \n\tif (test_bit(SSH_REQUEST_TY_HAS_RESPONSE_BIT, &rqst->state))\n\t\tif (!test_bit(SSH_PACKET_TY_SEQUENCED_BIT, &rqst->packet.state))\n\t\t\treturn -EINVAL;\n\n\tspin_lock(&rtl->queue.lock);\n\n\t \n\tif (cmpxchg(&rqst->packet.ptl, NULL, &rtl->ptl)) {\n\t\tspin_unlock(&rtl->queue.lock);\n\t\treturn -EALREADY;\n\t}\n\n\t \n\tsmp_mb__after_atomic();\n\n\tif (test_bit(SSH_RTL_SF_SHUTDOWN_BIT, &rtl->state)) {\n\t\tspin_unlock(&rtl->queue.lock);\n\t\treturn -ESHUTDOWN;\n\t}\n\n\tif (test_bit(SSH_REQUEST_SF_LOCKED_BIT, &rqst->state)) {\n\t\tspin_unlock(&rtl->queue.lock);\n\t\treturn -EINVAL;\n\t}\n\n\tset_bit(SSH_REQUEST_SF_QUEUED_BIT, &rqst->state);\n\tlist_add_tail(&ssh_request_get(rqst)->node, &rtl->queue.head);\n\n\tspin_unlock(&rtl->queue.lock);\n\n\tssh_rtl_tx_schedule(rtl);\n\treturn 0;\n}\n\nstatic void ssh_rtl_timeout_reaper_mod(struct ssh_rtl *rtl, ktime_t now,\n\t\t\t\t       ktime_t expires)\n{\n\tunsigned long delta = msecs_to_jiffies(ktime_ms_delta(expires, now));\n\tktime_t aexp = ktime_add(expires, SSH_RTL_REQUEST_TIMEOUT_RESOLUTION);\n\n\tspin_lock(&rtl->rtx_timeout.lock);\n\n\t \n\tif (ktime_before(aexp, rtl->rtx_timeout.expires)) {\n\t\trtl->rtx_timeout.expires = expires;\n\t\tmod_delayed_work(system_wq, &rtl->rtx_timeout.reaper, delta);\n\t}\n\n\tspin_unlock(&rtl->rtx_timeout.lock);\n}\n\nstatic void ssh_rtl_timeout_start(struct ssh_request *rqst)\n{\n\tstruct ssh_rtl *rtl = ssh_request_rtl(rqst);\n\tktime_t timestamp = ktime_get_coarse_boottime();\n\tktime_t timeout = rtl->rtx_timeout.timeout;\n\n\tif (test_bit(SSH_REQUEST_SF_LOCKED_BIT, &rqst->state))\n\t\treturn;\n\n\t \n\tWRITE_ONCE(rqst->timestamp, timestamp);\n\t \n\tsmp_mb__after_atomic();\n\n\tssh_rtl_timeout_reaper_mod(rtl, timestamp, timestamp + timeout);\n}\n\nstatic void ssh_rtl_complete(struct ssh_rtl *rtl,\n\t\t\t     const struct ssh_command *command,\n\t\t\t     const struct ssam_span *command_data)\n{\n\tstruct ssh_request *r = NULL;\n\tstruct ssh_request *p, *n;\n\tu16 rqid = get_unaligned_le16(&command->rqid);\n\n\ttrace_ssam_rx_response_received(command, command_data->len);\n\n\t \n\tspin_lock(&rtl->pending.lock);\n\tlist_for_each_entry_safe(p, n, &rtl->pending.head, node) {\n\t\t \n\t\tif (unlikely(ssh_request_get_rqid(p) != rqid))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (ssh_rtl_should_drop_response()) {\n\t\t\tspin_unlock(&rtl->pending.lock);\n\n\t\t\ttrace_ssam_ei_rx_drop_response(p);\n\t\t\trtl_info(rtl, \"request error injection: dropping response for request %p\\n\",\n\t\t\t\t &p->packet);\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tset_bit(SSH_REQUEST_SF_LOCKED_BIT, &p->state);\n\t\tset_bit(SSH_REQUEST_SF_RSPRCVD_BIT, &p->state);\n\t\t \n\t\tsmp_mb__before_atomic();\n\t\tclear_bit(SSH_REQUEST_SF_PENDING_BIT, &p->state);\n\n\t\tatomic_dec(&rtl->pending.count);\n\t\tlist_del(&p->node);\n\n\t\tr = p;\n\t\tbreak;\n\t}\n\tspin_unlock(&rtl->pending.lock);\n\n\tif (!r) {\n\t\trtl_warn(rtl, \"rtl: dropping unexpected command message (rqid = %#06x)\\n\",\n\t\t\t rqid);\n\t\treturn;\n\t}\n\n\t \n\tif (test_and_set_bit(SSH_REQUEST_SF_COMPLETED_BIT, &r->state)) {\n\t\tssh_request_put(r);\n\t\tssh_rtl_tx_schedule(rtl);\n\t\treturn;\n\t}\n\n\t \n\tif (!test_bit(SSH_REQUEST_SF_TRANSMITTED_BIT, &r->state)) {\n\t\trtl_err(rtl, \"rtl: received response before ACK for request (rqid = %#06x)\\n\",\n\t\t\trqid);\n\n\t\t \n\t\tssh_rtl_queue_remove(r);\n\n\t\tssh_rtl_complete_with_status(r, -EREMOTEIO);\n\t\tssh_request_put(r);\n\n\t\tssh_rtl_tx_schedule(rtl);\n\t\treturn;\n\t}\n\n\t \n\n\tssh_rtl_complete_with_rsp(r, command, command_data);\n\tssh_request_put(r);\n\n\tssh_rtl_tx_schedule(rtl);\n}\n\nstatic bool ssh_rtl_cancel_nonpending(struct ssh_request *r)\n{\n\tstruct ssh_rtl *rtl;\n\tunsigned long flags, fixed;\n\tbool remove;\n\n\t \n\tfixed = READ_ONCE(r->state) & SSH_REQUEST_FLAGS_TY_MASK;\n\tflags = cmpxchg(&r->state, fixed, SSH_REQUEST_SF_LOCKED_BIT);\n\n\t \n\tsmp_mb__after_atomic();\n\n\tif (flags == fixed && !READ_ONCE(r->packet.ptl)) {\n\t\tif (test_and_set_bit(SSH_REQUEST_SF_COMPLETED_BIT, &r->state))\n\t\t\treturn true;\n\n\t\tssh_rtl_complete_with_status(r, -ECANCELED);\n\t\treturn true;\n\t}\n\n\trtl = ssh_request_rtl(r);\n\tspin_lock(&rtl->queue.lock);\n\n\t \n\n\tremove = test_and_clear_bit(SSH_REQUEST_SF_QUEUED_BIT, &r->state);\n\tif (!remove) {\n\t\tspin_unlock(&rtl->queue.lock);\n\t\treturn false;\n\t}\n\n\tset_bit(SSH_REQUEST_SF_LOCKED_BIT, &r->state);\n\tlist_del(&r->node);\n\n\tspin_unlock(&rtl->queue.lock);\n\n\tssh_request_put(r);\t \n\n\tif (test_and_set_bit(SSH_REQUEST_SF_COMPLETED_BIT, &r->state))\n\t\treturn true;\n\n\tssh_rtl_complete_with_status(r, -ECANCELED);\n\treturn true;\n}\n\nstatic bool ssh_rtl_cancel_pending(struct ssh_request *r)\n{\n\t \n\tif (test_and_set_bit(SSH_REQUEST_SF_LOCKED_BIT, &r->state))\n\t\treturn true;\n\n\t \n\tif (!READ_ONCE(r->packet.ptl)) {\n\t\tif (test_and_set_bit(SSH_REQUEST_SF_COMPLETED_BIT, &r->state))\n\t\t\treturn true;\n\n\t\tssh_rtl_complete_with_status(r, -ECANCELED);\n\t\treturn true;\n\t}\n\n\t \n\tssh_ptl_cancel(&r->packet);\n\n\t \n\tif (test_and_set_bit(SSH_REQUEST_SF_COMPLETED_BIT, &r->state))\n\t\treturn true;\n\n\tssh_rtl_queue_remove(r);\n\tssh_rtl_pending_remove(r);\n\tssh_rtl_complete_with_status(r, -ECANCELED);\n\n\treturn true;\n}\n\n \nbool ssh_rtl_cancel(struct ssh_request *rqst, bool pending)\n{\n\tstruct ssh_rtl *rtl;\n\tbool canceled;\n\n\tif (test_and_set_bit(SSH_REQUEST_SF_CANCELED_BIT, &rqst->state))\n\t\treturn true;\n\n\ttrace_ssam_request_cancel(rqst);\n\n\tif (pending)\n\t\tcanceled = ssh_rtl_cancel_pending(rqst);\n\telse\n\t\tcanceled = ssh_rtl_cancel_nonpending(rqst);\n\n\t \n\trtl = ssh_request_rtl(rqst);\n\tif (canceled && rtl)\n\t\tssh_rtl_tx_schedule(rtl);\n\n\treturn canceled;\n}\n\nstatic void ssh_rtl_packet_callback(struct ssh_packet *p, int status)\n{\n\tstruct ssh_request *r = to_ssh_request(p);\n\n\tif (unlikely(status)) {\n\t\tset_bit(SSH_REQUEST_SF_LOCKED_BIT, &r->state);\n\n\t\tif (test_and_set_bit(SSH_REQUEST_SF_COMPLETED_BIT, &r->state))\n\t\t\treturn;\n\n\t\t \n\t\tssh_rtl_queue_remove(r);\n\t\tssh_rtl_pending_remove(r);\n\t\tssh_rtl_complete_with_status(r, status);\n\n\t\tssh_rtl_tx_schedule(ssh_request_rtl(r));\n\t\treturn;\n\t}\n\n\t \n\tset_bit(SSH_REQUEST_SF_TRANSMITTED_BIT, &r->state);\n\t \n\tsmp_mb__before_atomic();\n\tclear_bit(SSH_REQUEST_SF_TRANSMITTING_BIT, &r->state);\n\n\t \n\tif (test_bit(SSH_REQUEST_TY_HAS_RESPONSE_BIT, &r->state)) {\n\t\t \n\t\tssh_rtl_timeout_start(r);\n\t\treturn;\n\t}\n\n\t \n\n\tset_bit(SSH_REQUEST_SF_LOCKED_BIT, &r->state);\n\tif (test_and_set_bit(SSH_REQUEST_SF_COMPLETED_BIT, &r->state))\n\t\treturn;\n\n\tssh_rtl_pending_remove(r);\n\tssh_rtl_complete_with_status(r, 0);\n\n\tssh_rtl_tx_schedule(ssh_request_rtl(r));\n}\n\nstatic ktime_t ssh_request_get_expiration(struct ssh_request *r, ktime_t timeout)\n{\n\tktime_t timestamp = READ_ONCE(r->timestamp);\n\n\tif (timestamp != KTIME_MAX)\n\t\treturn ktime_add(timestamp, timeout);\n\telse\n\t\treturn KTIME_MAX;\n}\n\nstatic void ssh_rtl_timeout_reap(struct work_struct *work)\n{\n\tstruct ssh_rtl *rtl = to_ssh_rtl(work, rtx_timeout.reaper.work);\n\tstruct ssh_request *r, *n;\n\tLIST_HEAD(claimed);\n\tktime_t now = ktime_get_coarse_boottime();\n\tktime_t timeout = rtl->rtx_timeout.timeout;\n\tktime_t next = KTIME_MAX;\n\n\ttrace_ssam_rtl_timeout_reap(atomic_read(&rtl->pending.count));\n\n\t \n\tspin_lock(&rtl->rtx_timeout.lock);\n\trtl->rtx_timeout.expires = KTIME_MAX;\n\tspin_unlock(&rtl->rtx_timeout.lock);\n\n\tspin_lock(&rtl->pending.lock);\n\tlist_for_each_entry_safe(r, n, &rtl->pending.head, node) {\n\t\tktime_t expires = ssh_request_get_expiration(r, timeout);\n\n\t\t \n\t\tif (ktime_after(expires, now)) {\n\t\t\tnext = ktime_before(expires, next) ? expires : next;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (test_and_set_bit(SSH_REQUEST_SF_LOCKED_BIT, &r->state))\n\t\t\tcontinue;\n\n\t\t \n\n\t\tclear_bit(SSH_REQUEST_SF_PENDING_BIT, &r->state);\n\n\t\tatomic_dec(&rtl->pending.count);\n\t\tlist_move_tail(&r->node, &claimed);\n\t}\n\tspin_unlock(&rtl->pending.lock);\n\n\t \n\tlist_for_each_entry_safe(r, n, &claimed, node) {\n\t\ttrace_ssam_request_timeout(r);\n\n\t\t \n\t\tif (!test_and_set_bit(SSH_REQUEST_SF_COMPLETED_BIT, &r->state))\n\t\t\tssh_rtl_complete_with_status(r, -ETIMEDOUT);\n\n\t\t \n\t\tlist_del(&r->node);\n\t\tssh_request_put(r);\n\t}\n\n\t \n\tnext = max(next, ktime_add(now, SSH_RTL_REQUEST_TIMEOUT_RESOLUTION));\n\tif (next != KTIME_MAX)\n\t\tssh_rtl_timeout_reaper_mod(rtl, now, next);\n\n\tssh_rtl_tx_schedule(rtl);\n}\n\nstatic void ssh_rtl_rx_event(struct ssh_rtl *rtl, const struct ssh_command *cmd,\n\t\t\t     const struct ssam_span *data)\n{\n\ttrace_ssam_rx_event_received(cmd, data->len);\n\n\trtl_dbg(rtl, \"rtl: handling event (rqid: %#06x)\\n\",\n\t\tget_unaligned_le16(&cmd->rqid));\n\n\trtl->ops.handle_event(rtl, cmd, data);\n}\n\nstatic void ssh_rtl_rx_command(struct ssh_ptl *p, const struct ssam_span *data)\n{\n\tstruct ssh_rtl *rtl = to_ssh_rtl(p, ptl);\n\tstruct device *dev = &p->serdev->dev;\n\tstruct ssh_command *command;\n\tstruct ssam_span command_data;\n\n\tif (sshp_parse_command(dev, data, &command, &command_data))\n\t\treturn;\n\n\t \n\tif (command->tid != SSAM_SSH_TID_HOST) {\n\t\trtl_warn(rtl, \"rtl: dropping message not intended for us (tid = %#04x)\\n\",\n\t\t\t command->tid);\n\t\treturn;\n\t}\n\n\tif (ssh_rqid_is_event(get_unaligned_le16(&command->rqid)))\n\t\tssh_rtl_rx_event(rtl, command, &command_data);\n\telse\n\t\tssh_rtl_complete(rtl, command, &command_data);\n}\n\nstatic void ssh_rtl_rx_data(struct ssh_ptl *p, const struct ssam_span *data)\n{\n\tif (!data->len) {\n\t\tptl_err(p, \"rtl: rx: no data frame payload\\n\");\n\t\treturn;\n\t}\n\n\tswitch (data->ptr[0]) {\n\tcase SSH_PLD_TYPE_CMD:\n\t\tssh_rtl_rx_command(p, data);\n\t\tbreak;\n\n\tdefault:\n\t\tptl_err(p, \"rtl: rx: unknown frame payload type (type: %#04x)\\n\",\n\t\t\tdata->ptr[0]);\n\t\tbreak;\n\t}\n}\n\nstatic void ssh_rtl_packet_release(struct ssh_packet *p)\n{\n\tstruct ssh_request *rqst;\n\n\trqst = to_ssh_request(p);\n\trqst->ops->release(rqst);\n}\n\nstatic const struct ssh_packet_ops ssh_rtl_packet_ops = {\n\t.complete = ssh_rtl_packet_callback,\n\t.release = ssh_rtl_packet_release,\n};\n\n \nint ssh_request_init(struct ssh_request *rqst, enum ssam_request_flags flags,\n\t\t     const struct ssh_request_ops *ops)\n{\n\tunsigned long type = BIT(SSH_PACKET_TY_BLOCKING_BIT);\n\n\t \n\tif (flags & SSAM_REQUEST_UNSEQUENCED && flags & SSAM_REQUEST_HAS_RESPONSE)\n\t\treturn -EINVAL;\n\n\tif (!(flags & SSAM_REQUEST_UNSEQUENCED))\n\t\ttype |= BIT(SSH_PACKET_TY_SEQUENCED_BIT);\n\n\tssh_packet_init(&rqst->packet, type, SSH_PACKET_PRIORITY(DATA, 0),\n\t\t\t&ssh_rtl_packet_ops);\n\n\tINIT_LIST_HEAD(&rqst->node);\n\n\trqst->state = 0;\n\tif (flags & SSAM_REQUEST_HAS_RESPONSE)\n\t\trqst->state |= BIT(SSH_REQUEST_TY_HAS_RESPONSE_BIT);\n\n\trqst->timestamp = KTIME_MAX;\n\trqst->ops = ops;\n\n\treturn 0;\n}\n\n \nint ssh_rtl_init(struct ssh_rtl *rtl, struct serdev_device *serdev,\n\t\t const struct ssh_rtl_ops *ops)\n{\n\tstruct ssh_ptl_ops ptl_ops;\n\tint status;\n\n\tptl_ops.data_received = ssh_rtl_rx_data;\n\n\tstatus = ssh_ptl_init(&rtl->ptl, serdev, &ptl_ops);\n\tif (status)\n\t\treturn status;\n\n\tspin_lock_init(&rtl->queue.lock);\n\tINIT_LIST_HEAD(&rtl->queue.head);\n\n\tspin_lock_init(&rtl->pending.lock);\n\tINIT_LIST_HEAD(&rtl->pending.head);\n\tatomic_set_release(&rtl->pending.count, 0);\n\n\tINIT_WORK(&rtl->tx.work, ssh_rtl_tx_work_fn);\n\n\tspin_lock_init(&rtl->rtx_timeout.lock);\n\trtl->rtx_timeout.timeout = SSH_RTL_REQUEST_TIMEOUT;\n\trtl->rtx_timeout.expires = KTIME_MAX;\n\tINIT_DELAYED_WORK(&rtl->rtx_timeout.reaper, ssh_rtl_timeout_reap);\n\n\trtl->ops = *ops;\n\n\treturn 0;\n}\n\n \nvoid ssh_rtl_destroy(struct ssh_rtl *rtl)\n{\n\tssh_ptl_destroy(&rtl->ptl);\n}\n\n \nint ssh_rtl_start(struct ssh_rtl *rtl)\n{\n\tint status;\n\n\tstatus = ssh_ptl_tx_start(&rtl->ptl);\n\tif (status)\n\t\treturn status;\n\n\tssh_rtl_tx_schedule(rtl);\n\n\tstatus = ssh_ptl_rx_start(&rtl->ptl);\n\tif (status) {\n\t\tssh_rtl_flush(rtl, msecs_to_jiffies(5000));\n\t\tssh_ptl_tx_stop(&rtl->ptl);\n\t\treturn status;\n\t}\n\n\treturn 0;\n}\n\nstruct ssh_flush_request {\n\tstruct ssh_request base;\n\tstruct completion completion;\n\tint status;\n};\n\nstatic void ssh_rtl_flush_request_complete(struct ssh_request *r,\n\t\t\t\t\t   const struct ssh_command *cmd,\n\t\t\t\t\t   const struct ssam_span *data,\n\t\t\t\t\t   int status)\n{\n\tstruct ssh_flush_request *rqst;\n\n\trqst = container_of(r, struct ssh_flush_request, base);\n\trqst->status = status;\n}\n\nstatic void ssh_rtl_flush_request_release(struct ssh_request *r)\n{\n\tstruct ssh_flush_request *rqst;\n\n\trqst = container_of(r, struct ssh_flush_request, base);\n\tcomplete_all(&rqst->completion);\n}\n\nstatic const struct ssh_request_ops ssh_rtl_flush_request_ops = {\n\t.complete = ssh_rtl_flush_request_complete,\n\t.release = ssh_rtl_flush_request_release,\n};\n\n \nint ssh_rtl_flush(struct ssh_rtl *rtl, unsigned long timeout)\n{\n\tconst unsigned int init_flags = SSAM_REQUEST_UNSEQUENCED;\n\tstruct ssh_flush_request rqst;\n\tint status;\n\n\tssh_request_init(&rqst.base, init_flags, &ssh_rtl_flush_request_ops);\n\trqst.base.packet.state |= BIT(SSH_PACKET_TY_FLUSH_BIT);\n\trqst.base.packet.priority = SSH_PACKET_PRIORITY(FLUSH, 0);\n\trqst.base.state |= BIT(SSH_REQUEST_TY_FLUSH_BIT);\n\n\tinit_completion(&rqst.completion);\n\n\tstatus = ssh_rtl_submit(rtl, &rqst.base);\n\tif (status)\n\t\treturn status;\n\n\tssh_request_put(&rqst.base);\n\n\tif (!wait_for_completion_timeout(&rqst.completion, timeout)) {\n\t\tssh_rtl_cancel(&rqst.base, true);\n\t\twait_for_completion(&rqst.completion);\n\t}\n\n\tWARN_ON(rqst.status != 0 && rqst.status != -ECANCELED &&\n\t\trqst.status != -ESHUTDOWN && rqst.status != -EINTR);\n\n\treturn rqst.status == -ECANCELED ? -ETIMEDOUT : rqst.status;\n}\n\n \nvoid ssh_rtl_shutdown(struct ssh_rtl *rtl)\n{\n\tstruct ssh_request *r, *n;\n\tLIST_HEAD(claimed);\n\tint pending;\n\n\tset_bit(SSH_RTL_SF_SHUTDOWN_BIT, &rtl->state);\n\t \n\tsmp_mb__after_atomic();\n\n\t \n\tspin_lock(&rtl->queue.lock);\n\tlist_for_each_entry_safe(r, n, &rtl->queue.head, node) {\n\t\tset_bit(SSH_REQUEST_SF_LOCKED_BIT, &r->state);\n\t\t \n\t\tsmp_mb__before_atomic();\n\t\tclear_bit(SSH_REQUEST_SF_QUEUED_BIT, &r->state);\n\n\t\tlist_move_tail(&r->node, &claimed);\n\t}\n\tspin_unlock(&rtl->queue.lock);\n\n\t \n\n\tcancel_work_sync(&rtl->tx.work);\n\tssh_ptl_shutdown(&rtl->ptl);\n\tcancel_delayed_work_sync(&rtl->rtx_timeout.reaper);\n\n\t \n\n\tpending = atomic_read(&rtl->pending.count);\n\tif (WARN_ON(pending)) {\n\t\tspin_lock(&rtl->pending.lock);\n\t\tlist_for_each_entry_safe(r, n, &rtl->pending.head, node) {\n\t\t\tset_bit(SSH_REQUEST_SF_LOCKED_BIT, &r->state);\n\t\t\t \n\t\t\tsmp_mb__before_atomic();\n\t\t\tclear_bit(SSH_REQUEST_SF_PENDING_BIT, &r->state);\n\n\t\t\tlist_move_tail(&r->node, &claimed);\n\t\t}\n\t\tspin_unlock(&rtl->pending.lock);\n\t}\n\n\t \n\tlist_for_each_entry_safe(r, n, &claimed, node) {\n\t\t \n\t\tif (!test_and_set_bit(SSH_REQUEST_SF_COMPLETED_BIT, &r->state))\n\t\t\tssh_rtl_complete_with_status(r, -ESHUTDOWN);\n\n\t\t \n\t\tlist_del(&r->node);\n\t\tssh_request_put(r);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}