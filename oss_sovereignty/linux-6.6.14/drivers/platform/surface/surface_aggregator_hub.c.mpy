{
  "module_name": "surface_aggregator_hub.c",
  "hash_id": "35f9b130b2c74cd093158feadcdd1419b1689bbe1b2269f490a478801ece9ee3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/surface/surface_aggregator_hub.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/limits.h>\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/workqueue.h>\n\n#include <linux/surface_aggregator/device.h>\n\n\n \n\nenum ssam_hub_state {\n\tSSAM_HUB_UNINITIALIZED,\t\t \n\tSSAM_HUB_CONNECTED,\n\tSSAM_HUB_DISCONNECTED,\n};\n\nenum ssam_hub_flags {\n\tSSAM_HUB_HOT_REMOVED,\n};\n\nstruct ssam_hub;\n\nstruct ssam_hub_ops {\n\tint (*get_state)(struct ssam_hub *hub, enum ssam_hub_state *state);\n};\n\nstruct ssam_hub {\n\tstruct ssam_device *sdev;\n\n\tenum ssam_hub_state state;\n\tunsigned long flags;\n\n\tstruct delayed_work update_work;\n\tunsigned long connect_delay;\n\n\tstruct ssam_event_notifier notif;\n\tstruct ssam_hub_ops ops;\n};\n\nstruct ssam_hub_desc {\n\tstruct {\n\t\tstruct ssam_event_registry reg;\n\t\tstruct ssam_event_id id;\n\t\tenum ssam_event_mask mask;\n\t} event;\n\n\tstruct {\n\t\tu32 (*notify)(struct ssam_event_notifier *nf, const struct ssam_event *event);\n\t\tint (*get_state)(struct ssam_hub *hub, enum ssam_hub_state *state);\n\t} ops;\n\n\tunsigned long connect_delay_ms;\n};\n\nstatic void ssam_hub_update_workfn(struct work_struct *work)\n{\n\tstruct ssam_hub *hub = container_of(work, struct ssam_hub, update_work.work);\n\tenum ssam_hub_state state;\n\tint status = 0;\n\n\tstatus = hub->ops.get_state(hub, &state);\n\tif (status)\n\t\treturn;\n\n\t \n\tif (test_and_clear_bit(SSAM_HUB_HOT_REMOVED, &hub->flags)) {\n\t\tif (state == SSAM_HUB_CONNECTED)\n\t\t\tschedule_delayed_work(&hub->update_work, hub->connect_delay);\n\n\t\tstate = SSAM_HUB_DISCONNECTED;\n\t}\n\n\tif (hub->state == state)\n\t\treturn;\n\thub->state = state;\n\n\tif (hub->state == SSAM_HUB_CONNECTED)\n\t\tstatus = ssam_device_register_clients(hub->sdev);\n\telse\n\t\tssam_remove_clients(&hub->sdev->dev);\n\n\tif (status)\n\t\tdev_err(&hub->sdev->dev, \"failed to update hub child devices: %d\\n\", status);\n}\n\nstatic int ssam_hub_mark_hot_removed(struct device *dev, void *_data)\n{\n\tstruct ssam_device *sdev = to_ssam_device(dev);\n\n\tif (is_ssam_device(dev))\n\t\tssam_device_mark_hot_removed(sdev);\n\n\treturn 0;\n}\n\nstatic void ssam_hub_update(struct ssam_hub *hub, bool connected)\n{\n\tunsigned long delay;\n\n\t \n\tif (!connected) {\n\t\tset_bit(SSAM_HUB_HOT_REMOVED, &hub->flags);\n\t\tdevice_for_each_child_reverse(&hub->sdev->dev, NULL, ssam_hub_mark_hot_removed);\n\t}\n\n\t \n\tdelay = connected ? hub->connect_delay : 0;\n\n\tschedule_delayed_work(&hub->update_work, delay);\n}\n\nstatic int __maybe_unused ssam_hub_resume(struct device *dev)\n{\n\tstruct ssam_hub *hub = dev_get_drvdata(dev);\n\n\tschedule_delayed_work(&hub->update_work, 0);\n\treturn 0;\n}\nstatic SIMPLE_DEV_PM_OPS(ssam_hub_pm_ops, NULL, ssam_hub_resume);\n\nstatic int ssam_hub_probe(struct ssam_device *sdev)\n{\n\tconst struct ssam_hub_desc *desc;\n\tstruct ssam_hub *hub;\n\tint status;\n\n\tdesc = ssam_device_get_match_data(sdev);\n\tif (!desc) {\n\t\tWARN(1, \"no driver match data specified\");\n\t\treturn -EINVAL;\n\t}\n\n\thub = devm_kzalloc(&sdev->dev, sizeof(*hub), GFP_KERNEL);\n\tif (!hub)\n\t\treturn -ENOMEM;\n\n\thub->sdev = sdev;\n\thub->state = SSAM_HUB_UNINITIALIZED;\n\n\thub->notif.base.priority = INT_MAX;   \n\thub->notif.base.fn = desc->ops.notify;\n\thub->notif.event.reg = desc->event.reg;\n\thub->notif.event.id = desc->event.id;\n\thub->notif.event.mask = desc->event.mask;\n\thub->notif.event.flags = SSAM_EVENT_SEQUENCED;\n\n\thub->connect_delay = msecs_to_jiffies(desc->connect_delay_ms);\n\thub->ops.get_state = desc->ops.get_state;\n\n\tINIT_DELAYED_WORK(&hub->update_work, ssam_hub_update_workfn);\n\n\tssam_device_set_drvdata(sdev, hub);\n\n\tstatus = ssam_device_notifier_register(sdev, &hub->notif);\n\tif (status)\n\t\treturn status;\n\n\tschedule_delayed_work(&hub->update_work, 0);\n\treturn 0;\n}\n\nstatic void ssam_hub_remove(struct ssam_device *sdev)\n{\n\tstruct ssam_hub *hub = ssam_device_get_drvdata(sdev);\n\n\tssam_device_notifier_unregister(sdev, &hub->notif);\n\tcancel_delayed_work_sync(&hub->update_work);\n\tssam_remove_clients(&sdev->dev);\n}\n\n\n \n\n \n#define SSAM_BASE_UPDATE_CONNECT_DELAY\t\t2500\n\nSSAM_DEFINE_SYNC_REQUEST_R(ssam_bas_query_opmode, u8, {\n\t.target_category = SSAM_SSH_TC_BAS,\n\t.target_id       = SSAM_SSH_TID_SAM,\n\t.command_id      = 0x0d,\n\t.instance_id     = 0x00,\n});\n\n#define SSAM_BAS_OPMODE_TABLET\t\t0x00\n#define SSAM_EVENT_BAS_CID_CONNECTION\t0x0c\n\nstatic int ssam_base_hub_query_state(struct ssam_hub *hub, enum ssam_hub_state *state)\n{\n\tu8 opmode;\n\tint status;\n\n\tstatus = ssam_retry(ssam_bas_query_opmode, hub->sdev->ctrl, &opmode);\n\tif (status < 0) {\n\t\tdev_err(&hub->sdev->dev, \"failed to query base state: %d\\n\", status);\n\t\treturn status;\n\t}\n\n\tif (opmode != SSAM_BAS_OPMODE_TABLET)\n\t\t*state = SSAM_HUB_CONNECTED;\n\telse\n\t\t*state = SSAM_HUB_DISCONNECTED;\n\n\treturn 0;\n}\n\nstatic u32 ssam_base_hub_notif(struct ssam_event_notifier *nf, const struct ssam_event *event)\n{\n\tstruct ssam_hub *hub = container_of(nf, struct ssam_hub, notif);\n\n\tif (event->command_id != SSAM_EVENT_BAS_CID_CONNECTION)\n\t\treturn 0;\n\n\tif (event->length < 1) {\n\t\tdev_err(&hub->sdev->dev, \"unexpected payload size: %u\\n\", event->length);\n\t\treturn 0;\n\t}\n\n\tssam_hub_update(hub, event->data[0]);\n\n\t \n\treturn 0;\n}\n\nstatic const struct ssam_hub_desc base_hub = {\n\t.event = {\n\t\t.reg = SSAM_EVENT_REGISTRY_SAM,\n\t\t.id = {\n\t\t\t.target_category = SSAM_SSH_TC_BAS,\n\t\t\t.instance = 0,\n\t\t},\n\t\t.mask = SSAM_EVENT_MASK_NONE,\n\t},\n\t.ops = {\n\t\t.notify = ssam_base_hub_notif,\n\t\t.get_state = ssam_base_hub_query_state,\n\t},\n\t.connect_delay_ms = SSAM_BASE_UPDATE_CONNECT_DELAY,\n};\n\n\n \n\n \n#define SSAM_KIP_UPDATE_CONNECT_DELAY\t\t250\n\n#define SSAM_EVENT_KIP_CID_CONNECTION\t\t0x2c\n\nSSAM_DEFINE_SYNC_REQUEST_R(__ssam_kip_query_state, u8, {\n\t.target_category = SSAM_SSH_TC_KIP,\n\t.target_id       = SSAM_SSH_TID_SAM,\n\t.command_id      = 0x2c,\n\t.instance_id     = 0x00,\n});\n\nstatic int ssam_kip_hub_query_state(struct ssam_hub *hub, enum ssam_hub_state *state)\n{\n\tint status;\n\tu8 connected;\n\n\tstatus = ssam_retry(__ssam_kip_query_state, hub->sdev->ctrl, &connected);\n\tif (status < 0) {\n\t\tdev_err(&hub->sdev->dev, \"failed to query KIP connection state: %d\\n\", status);\n\t\treturn status;\n\t}\n\n\t*state = connected ? SSAM_HUB_CONNECTED : SSAM_HUB_DISCONNECTED;\n\treturn 0;\n}\n\nstatic u32 ssam_kip_hub_notif(struct ssam_event_notifier *nf, const struct ssam_event *event)\n{\n\tstruct ssam_hub *hub = container_of(nf, struct ssam_hub, notif);\n\n\tif (event->command_id != SSAM_EVENT_KIP_CID_CONNECTION)\n\t\treturn 0;\t \n\n\tif (event->length < 1) {\n\t\tdev_err(&hub->sdev->dev, \"unexpected payload size: %u\\n\", event->length);\n\t\treturn 0;\n\t}\n\n\tssam_hub_update(hub, event->data[0]);\n\treturn SSAM_NOTIF_HANDLED;\n}\n\nstatic const struct ssam_hub_desc kip_hub = {\n\t.event = {\n\t\t.reg = SSAM_EVENT_REGISTRY_SAM,\n\t\t.id = {\n\t\t\t.target_category = SSAM_SSH_TC_KIP,\n\t\t\t.instance = 0,\n\t\t},\n\t\t.mask = SSAM_EVENT_MASK_TARGET,\n\t},\n\t.ops = {\n\t\t.notify = ssam_kip_hub_notif,\n\t\t.get_state = ssam_kip_hub_query_state,\n\t},\n\t.connect_delay_ms = SSAM_KIP_UPDATE_CONNECT_DELAY,\n};\n\n\n \n\nstatic const struct ssam_device_id ssam_hub_match[] = {\n\t{ SSAM_VDEV(HUB, SAM, SSAM_SSH_TC_KIP, 0x00), (unsigned long)&kip_hub  },\n\t{ SSAM_VDEV(HUB, SAM, SSAM_SSH_TC_BAS, 0x00), (unsigned long)&base_hub },\n\t{ }\n};\nMODULE_DEVICE_TABLE(ssam, ssam_hub_match);\n\nstatic struct ssam_device_driver ssam_subsystem_hub_driver = {\n\t.probe = ssam_hub_probe,\n\t.remove = ssam_hub_remove,\n\t.match_table = ssam_hub_match,\n\t.driver = {\n\t\t.name = \"surface_aggregator_subsystem_hub\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t\t.pm = &ssam_hub_pm_ops,\n\t},\n};\nmodule_ssam_device_driver(ssam_subsystem_hub_driver);\n\nMODULE_AUTHOR(\"Maximilian Luz <luzmaximilian@gmail.com>\");\nMODULE_DESCRIPTION(\"Subsystem device hub driver for Surface System Aggregator Module\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}