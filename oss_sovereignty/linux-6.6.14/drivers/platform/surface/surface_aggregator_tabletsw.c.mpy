{
  "module_name": "surface_aggregator_tabletsw.c",
  "hash_id": "74e1af42198dc0a9ef6a9fc5920af35cc3a42e03fee4621571c4c14e620aa526",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/surface/surface_aggregator_tabletsw.c",
  "human_readable_source": "\n \n\n#include <asm/unaligned.h>\n#include <linux/input.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/workqueue.h>\n\n#include <linux/surface_aggregator/controller.h>\n#include <linux/surface_aggregator/device.h>\n\n\n \n\nstruct ssam_tablet_sw;\n\nstruct ssam_tablet_sw_state {\n\tu32 source;\n\tu32 state;\n};\n\nstruct ssam_tablet_sw_ops {\n\tint (*get_state)(struct ssam_tablet_sw *sw, struct ssam_tablet_sw_state *state);\n\tconst char *(*state_name)(struct ssam_tablet_sw *sw,\n\t\t\t\t  const struct ssam_tablet_sw_state *state);\n\tbool (*state_is_tablet_mode)(struct ssam_tablet_sw *sw,\n\t\t\t\t     const struct ssam_tablet_sw_state *state);\n};\n\nstruct ssam_tablet_sw {\n\tstruct ssam_device *sdev;\n\n\tstruct ssam_tablet_sw_state state;\n\tstruct work_struct update_work;\n\tstruct input_dev *mode_switch;\n\n\tstruct ssam_tablet_sw_ops ops;\n\tstruct ssam_event_notifier notif;\n};\n\nstruct ssam_tablet_sw_desc {\n\tstruct {\n\t\tconst char *name;\n\t\tconst char *phys;\n\t} dev;\n\n\tstruct {\n\t\tu32 (*notify)(struct ssam_event_notifier *nf, const struct ssam_event *event);\n\t\tint (*get_state)(struct ssam_tablet_sw *sw, struct ssam_tablet_sw_state *state);\n\t\tconst char *(*state_name)(struct ssam_tablet_sw *sw,\n\t\t\t\t\t  const struct ssam_tablet_sw_state *state);\n\t\tbool (*state_is_tablet_mode)(struct ssam_tablet_sw *sw,\n\t\t\t\t\t     const struct ssam_tablet_sw_state *state);\n\t} ops;\n\n\tstruct {\n\t\tstruct ssam_event_registry reg;\n\t\tstruct ssam_event_id id;\n\t\tenum ssam_event_mask mask;\n\t\tu8 flags;\n\t} event;\n};\n\nstatic ssize_t state_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct ssam_tablet_sw *sw = dev_get_drvdata(dev);\n\tconst char *state = sw->ops.state_name(sw, &sw->state);\n\n\treturn sysfs_emit(buf, \"%s\\n\", state);\n}\nstatic DEVICE_ATTR_RO(state);\n\nstatic struct attribute *ssam_tablet_sw_attrs[] = {\n\t&dev_attr_state.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group ssam_tablet_sw_group = {\n\t.attrs = ssam_tablet_sw_attrs,\n};\n\nstatic void ssam_tablet_sw_update_workfn(struct work_struct *work)\n{\n\tstruct ssam_tablet_sw *sw = container_of(work, struct ssam_tablet_sw, update_work);\n\tstruct ssam_tablet_sw_state state;\n\tint tablet, status;\n\n\tstatus = sw->ops.get_state(sw, &state);\n\tif (status)\n\t\treturn;\n\n\tif (sw->state.source == state.source && sw->state.state == state.state)\n\t\treturn;\n\tsw->state = state;\n\n\t \n\ttablet = sw->ops.state_is_tablet_mode(sw, &state);\n\tinput_report_switch(sw->mode_switch, SW_TABLET_MODE, tablet);\n\tinput_sync(sw->mode_switch);\n}\n\nstatic int __maybe_unused ssam_tablet_sw_resume(struct device *dev)\n{\n\tstruct ssam_tablet_sw *sw = dev_get_drvdata(dev);\n\n\tschedule_work(&sw->update_work);\n\treturn 0;\n}\nstatic SIMPLE_DEV_PM_OPS(ssam_tablet_sw_pm_ops, NULL, ssam_tablet_sw_resume);\n\nstatic int ssam_tablet_sw_probe(struct ssam_device *sdev)\n{\n\tconst struct ssam_tablet_sw_desc *desc;\n\tstruct ssam_tablet_sw *sw;\n\tint tablet, status;\n\n\tdesc = ssam_device_get_match_data(sdev);\n\tif (!desc) {\n\t\tWARN(1, \"no driver match data specified\");\n\t\treturn -EINVAL;\n\t}\n\n\tsw = devm_kzalloc(&sdev->dev, sizeof(*sw), GFP_KERNEL);\n\tif (!sw)\n\t\treturn -ENOMEM;\n\n\tsw->sdev = sdev;\n\n\tsw->ops.get_state = desc->ops.get_state;\n\tsw->ops.state_name = desc->ops.state_name;\n\tsw->ops.state_is_tablet_mode = desc->ops.state_is_tablet_mode;\n\n\tINIT_WORK(&sw->update_work, ssam_tablet_sw_update_workfn);\n\n\tssam_device_set_drvdata(sdev, sw);\n\n\t \n\tstatus = sw->ops.get_state(sw, &sw->state);\n\tif (status)\n\t\treturn status;\n\n\t \n\tsw->mode_switch = devm_input_allocate_device(&sdev->dev);\n\tif (!sw->mode_switch)\n\t\treturn -ENOMEM;\n\n\tsw->mode_switch->name = desc->dev.name;\n\tsw->mode_switch->phys = desc->dev.phys;\n\tsw->mode_switch->id.bustype = BUS_HOST;\n\tsw->mode_switch->dev.parent = &sdev->dev;\n\n\ttablet = sw->ops.state_is_tablet_mode(sw, &sw->state);\n\tinput_set_capability(sw->mode_switch, EV_SW, SW_TABLET_MODE);\n\tinput_report_switch(sw->mode_switch, SW_TABLET_MODE, tablet);\n\n\tstatus = input_register_device(sw->mode_switch);\n\tif (status)\n\t\treturn status;\n\n\t \n\tsw->notif.base.priority = 0;\n\tsw->notif.base.fn = desc->ops.notify;\n\tsw->notif.event.reg = desc->event.reg;\n\tsw->notif.event.id = desc->event.id;\n\tsw->notif.event.mask = desc->event.mask;\n\tsw->notif.event.flags = SSAM_EVENT_SEQUENCED;\n\n\tstatus = ssam_device_notifier_register(sdev, &sw->notif);\n\tif (status)\n\t\treturn status;\n\n\tstatus = sysfs_create_group(&sdev->dev.kobj, &ssam_tablet_sw_group);\n\tif (status)\n\t\tgoto err;\n\n\t \n\tschedule_work(&sw->update_work);\n\treturn 0;\n\nerr:\n\tssam_device_notifier_unregister(sdev, &sw->notif);\n\tcancel_work_sync(&sw->update_work);\n\treturn status;\n}\n\nstatic void ssam_tablet_sw_remove(struct ssam_device *sdev)\n{\n\tstruct ssam_tablet_sw *sw = ssam_device_get_drvdata(sdev);\n\n\tsysfs_remove_group(&sdev->dev.kobj, &ssam_tablet_sw_group);\n\n\tssam_device_notifier_unregister(sdev, &sw->notif);\n\tcancel_work_sync(&sw->update_work);\n}\n\n\n \n\n#define SSAM_EVENT_KIP_CID_COVER_STATE_CHANGED\t0x1d\n\nenum ssam_kip_cover_state {\n\tSSAM_KIP_COVER_STATE_DISCONNECTED  = 0x01,\n\tSSAM_KIP_COVER_STATE_CLOSED        = 0x02,\n\tSSAM_KIP_COVER_STATE_LAPTOP        = 0x03,\n\tSSAM_KIP_COVER_STATE_FOLDED_CANVAS = 0x04,\n\tSSAM_KIP_COVER_STATE_FOLDED_BACK   = 0x05,\n\tSSAM_KIP_COVER_STATE_BOOK          = 0x06,\n};\n\nstatic const char *ssam_kip_cover_state_name(struct ssam_tablet_sw *sw,\n\t\t\t\t\t     const struct ssam_tablet_sw_state *state)\n{\n\tswitch (state->state) {\n\tcase SSAM_KIP_COVER_STATE_DISCONNECTED:\n\t\treturn \"disconnected\";\n\n\tcase SSAM_KIP_COVER_STATE_CLOSED:\n\t\treturn \"closed\";\n\n\tcase SSAM_KIP_COVER_STATE_LAPTOP:\n\t\treturn \"laptop\";\n\n\tcase SSAM_KIP_COVER_STATE_FOLDED_CANVAS:\n\t\treturn \"folded-canvas\";\n\n\tcase SSAM_KIP_COVER_STATE_FOLDED_BACK:\n\t\treturn \"folded-back\";\n\n\tcase SSAM_KIP_COVER_STATE_BOOK:\n\t\treturn \"book\";\n\n\tdefault:\n\t\tdev_warn(&sw->sdev->dev, \"unknown KIP cover state: %u\\n\", state->state);\n\t\treturn \"<unknown>\";\n\t}\n}\n\nstatic bool ssam_kip_cover_state_is_tablet_mode(struct ssam_tablet_sw *sw,\n\t\t\t\t\t\tconst struct ssam_tablet_sw_state *state)\n{\n\tswitch (state->state) {\n\tcase SSAM_KIP_COVER_STATE_DISCONNECTED:\n\tcase SSAM_KIP_COVER_STATE_FOLDED_CANVAS:\n\tcase SSAM_KIP_COVER_STATE_FOLDED_BACK:\n\tcase SSAM_KIP_COVER_STATE_BOOK:\n\t\treturn true;\n\n\tcase SSAM_KIP_COVER_STATE_CLOSED:\n\tcase SSAM_KIP_COVER_STATE_LAPTOP:\n\t\treturn false;\n\n\tdefault:\n\t\tdev_warn(&sw->sdev->dev, \"unknown KIP cover state: %d\\n\", state->state);\n\t\treturn true;\n\t}\n}\n\nSSAM_DEFINE_SYNC_REQUEST_R(__ssam_kip_get_cover_state, u8, {\n\t.target_category = SSAM_SSH_TC_KIP,\n\t.target_id       = SSAM_SSH_TID_SAM,\n\t.command_id      = 0x1d,\n\t.instance_id     = 0x00,\n});\n\nstatic int ssam_kip_get_cover_state(struct ssam_tablet_sw *sw, struct ssam_tablet_sw_state *state)\n{\n\tint status;\n\tu8 raw;\n\n\tstatus = ssam_retry(__ssam_kip_get_cover_state, sw->sdev->ctrl, &raw);\n\tif (status < 0) {\n\t\tdev_err(&sw->sdev->dev, \"failed to query KIP lid state: %d\\n\", status);\n\t\treturn status;\n\t}\n\n\tstate->source = 0;\t \n\tstate->state = raw;\n\treturn 0;\n}\n\nstatic u32 ssam_kip_sw_notif(struct ssam_event_notifier *nf, const struct ssam_event *event)\n{\n\tstruct ssam_tablet_sw *sw = container_of(nf, struct ssam_tablet_sw, notif);\n\n\tif (event->command_id != SSAM_EVENT_KIP_CID_COVER_STATE_CHANGED)\n\t\treturn 0;\t \n\n\tif (event->length < 1)\n\t\tdev_warn(&sw->sdev->dev, \"unexpected payload size: %u\\n\", event->length);\n\n\tschedule_work(&sw->update_work);\n\treturn SSAM_NOTIF_HANDLED;\n}\n\nstatic const struct ssam_tablet_sw_desc ssam_kip_sw_desc = {\n\t.dev = {\n\t\t.name = \"Microsoft Surface KIP Tablet Mode Switch\",\n\t\t.phys = \"ssam/01:0e:01:00:01/input0\",\n\t},\n\t.ops = {\n\t\t.notify = ssam_kip_sw_notif,\n\t\t.get_state = ssam_kip_get_cover_state,\n\t\t.state_name = ssam_kip_cover_state_name,\n\t\t.state_is_tablet_mode = ssam_kip_cover_state_is_tablet_mode,\n\t},\n\t.event = {\n\t\t.reg = SSAM_EVENT_REGISTRY_SAM,\n\t\t.id = {\n\t\t\t.target_category = SSAM_SSH_TC_KIP,\n\t\t\t.instance = 0,\n\t\t},\n\t\t.mask = SSAM_EVENT_MASK_TARGET,\n\t},\n};\n\n\n \n\nstatic bool tablet_mode_in_slate_state = true;\nmodule_param(tablet_mode_in_slate_state, bool, 0644);\nMODULE_PARM_DESC(tablet_mode_in_slate_state, \"Enable tablet mode in slate device posture, default is 'true'\");\n\n#define SSAM_EVENT_POS_CID_POSTURE_CHANGED\t0x03\n#define SSAM_POS_MAX_SOURCES\t\t\t4\n\nenum ssam_pos_source_id {\n\tSSAM_POS_SOURCE_COVER = 0x00,\n\tSSAM_POS_SOURCE_SLS   = 0x03,\n};\n\nenum ssam_pos_state_cover {\n\tSSAM_POS_COVER_DISCONNECTED  = 0x01,\n\tSSAM_POS_COVER_CLOSED        = 0x02,\n\tSSAM_POS_COVER_LAPTOP        = 0x03,\n\tSSAM_POS_COVER_FOLDED_CANVAS = 0x04,\n\tSSAM_POS_COVER_FOLDED_BACK   = 0x05,\n\tSSAM_POS_COVER_BOOK          = 0x06,\n};\n\nenum ssam_pos_state_sls {\n\tSSAM_POS_SLS_LID_CLOSED = 0x00,\n\tSSAM_POS_SLS_LAPTOP     = 0x01,\n\tSSAM_POS_SLS_SLATE      = 0x02,\n\tSSAM_POS_SLS_TABLET     = 0x03,\n};\n\nstruct ssam_sources_list {\n\t__le32 count;\n\t__le32 id[SSAM_POS_MAX_SOURCES];\n} __packed;\n\nstatic const char *ssam_pos_state_name_cover(struct ssam_tablet_sw *sw, u32 state)\n{\n\tswitch (state) {\n\tcase SSAM_POS_COVER_DISCONNECTED:\n\t\treturn \"disconnected\";\n\n\tcase SSAM_POS_COVER_CLOSED:\n\t\treturn \"closed\";\n\n\tcase SSAM_POS_COVER_LAPTOP:\n\t\treturn \"laptop\";\n\n\tcase SSAM_POS_COVER_FOLDED_CANVAS:\n\t\treturn \"folded-canvas\";\n\n\tcase SSAM_POS_COVER_FOLDED_BACK:\n\t\treturn \"folded-back\";\n\n\tcase SSAM_POS_COVER_BOOK:\n\t\treturn \"book\";\n\n\tdefault:\n\t\tdev_warn(&sw->sdev->dev, \"unknown device posture for type-cover: %u\\n\", state);\n\t\treturn \"<unknown>\";\n\t}\n}\n\nstatic const char *ssam_pos_state_name_sls(struct ssam_tablet_sw *sw, u32 state)\n{\n\tswitch (state) {\n\tcase SSAM_POS_SLS_LID_CLOSED:\n\t\treturn \"closed\";\n\n\tcase SSAM_POS_SLS_LAPTOP:\n\t\treturn \"laptop\";\n\n\tcase SSAM_POS_SLS_SLATE:\n\t\treturn \"slate\";\n\n\tcase SSAM_POS_SLS_TABLET:\n\t\treturn \"tablet\";\n\n\tdefault:\n\t\tdev_warn(&sw->sdev->dev, \"unknown device posture for SLS: %u\\n\", state);\n\t\treturn \"<unknown>\";\n\t}\n}\n\nstatic const char *ssam_pos_state_name(struct ssam_tablet_sw *sw,\n\t\t\t\t       const struct ssam_tablet_sw_state *state)\n{\n\tswitch (state->source) {\n\tcase SSAM_POS_SOURCE_COVER:\n\t\treturn ssam_pos_state_name_cover(sw, state->state);\n\n\tcase SSAM_POS_SOURCE_SLS:\n\t\treturn ssam_pos_state_name_sls(sw, state->state);\n\n\tdefault:\n\t\tdev_warn(&sw->sdev->dev, \"unknown device posture source: %u\\n\", state->source);\n\t\treturn \"<unknown>\";\n\t}\n}\n\nstatic bool ssam_pos_state_is_tablet_mode_cover(struct ssam_tablet_sw *sw, u32 state)\n{\n\tswitch (state) {\n\tcase SSAM_POS_COVER_DISCONNECTED:\n\tcase SSAM_POS_COVER_FOLDED_CANVAS:\n\tcase SSAM_POS_COVER_FOLDED_BACK:\n\tcase SSAM_POS_COVER_BOOK:\n\t\treturn true;\n\n\tcase SSAM_POS_COVER_CLOSED:\n\tcase SSAM_POS_COVER_LAPTOP:\n\t\treturn false;\n\n\tdefault:\n\t\tdev_warn(&sw->sdev->dev, \"unknown device posture for type-cover: %u\\n\", state);\n\t\treturn true;\n\t}\n}\n\nstatic bool ssam_pos_state_is_tablet_mode_sls(struct ssam_tablet_sw *sw, u32 state)\n{\n\tswitch (state) {\n\tcase SSAM_POS_SLS_LAPTOP:\n\tcase SSAM_POS_SLS_LID_CLOSED:\n\t\treturn false;\n\n\tcase SSAM_POS_SLS_SLATE:\n\t\treturn tablet_mode_in_slate_state;\n\n\tcase SSAM_POS_SLS_TABLET:\n\t\treturn true;\n\n\tdefault:\n\t\tdev_warn(&sw->sdev->dev, \"unknown device posture for SLS: %u\\n\", state);\n\t\treturn true;\n\t}\n}\n\nstatic bool ssam_pos_state_is_tablet_mode(struct ssam_tablet_sw *sw,\n\t\t\t\t\t  const struct ssam_tablet_sw_state *state)\n{\n\tswitch (state->source) {\n\tcase SSAM_POS_SOURCE_COVER:\n\t\treturn ssam_pos_state_is_tablet_mode_cover(sw, state->state);\n\n\tcase SSAM_POS_SOURCE_SLS:\n\t\treturn ssam_pos_state_is_tablet_mode_sls(sw, state->state);\n\n\tdefault:\n\t\tdev_warn(&sw->sdev->dev, \"unknown device posture source: %u\\n\", state->source);\n\t\treturn true;\n\t}\n}\n\nstatic int ssam_pos_get_sources_list(struct ssam_tablet_sw *sw, struct ssam_sources_list *sources)\n{\n\tstruct ssam_request rqst;\n\tstruct ssam_response rsp;\n\tint status;\n\n\trqst.target_category = SSAM_SSH_TC_POS;\n\trqst.target_id = SSAM_SSH_TID_SAM;\n\trqst.command_id = 0x01;\n\trqst.instance_id = 0x00;\n\trqst.flags = SSAM_REQUEST_HAS_RESPONSE;\n\trqst.length = 0;\n\trqst.payload = NULL;\n\n\trsp.capacity = sizeof(*sources);\n\trsp.length = 0;\n\trsp.pointer = (u8 *)sources;\n\n\tstatus = ssam_retry(ssam_request_do_sync_onstack, sw->sdev->ctrl, &rqst, &rsp, 0);\n\tif (status)\n\t\treturn status;\n\n\t \n\tif (rsp.length < sizeof(__le32)) {\n\t\tdev_err(&sw->sdev->dev, \"received source list response is too small\\n\");\n\t\treturn -EPROTO;\n\t}\n\n\t \n\tif (get_unaligned_le32(&sources->count) * sizeof(__le32) + sizeof(__le32) != rsp.length) {\n\t\tdev_err(&sw->sdev->dev, \"mismatch between number of sources and response size\\n\");\n\t\treturn -EPROTO;\n\t}\n\n\treturn 0;\n}\n\nstatic int ssam_pos_get_source(struct ssam_tablet_sw *sw, u32 *source_id)\n{\n\tstruct ssam_sources_list sources = {};\n\tint status;\n\n\tstatus = ssam_pos_get_sources_list(sw, &sources);\n\tif (status)\n\t\treturn status;\n\n\tif (get_unaligned_le32(&sources.count) == 0) {\n\t\tdev_err(&sw->sdev->dev, \"no posture sources found\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tWARN_ON(get_unaligned_le32(&sources.count) > 1);\n\n\t*source_id = get_unaligned_le32(&sources.id[0]);\n\treturn 0;\n}\n\nSSAM_DEFINE_SYNC_REQUEST_WR(__ssam_pos_get_posture_for_source, __le32, __le32, {\n\t.target_category = SSAM_SSH_TC_POS,\n\t.target_id       = SSAM_SSH_TID_SAM,\n\t.command_id      = 0x02,\n\t.instance_id     = 0x00,\n});\n\nstatic int ssam_pos_get_posture_for_source(struct ssam_tablet_sw *sw, u32 source_id, u32 *posture)\n{\n\t__le32 source_le = cpu_to_le32(source_id);\n\t__le32 rspval_le = 0;\n\tint status;\n\n\tstatus = ssam_retry(__ssam_pos_get_posture_for_source, sw->sdev->ctrl,\n\t\t\t    &source_le, &rspval_le);\n\tif (status)\n\t\treturn status;\n\n\t*posture = le32_to_cpu(rspval_le);\n\treturn 0;\n}\n\nstatic int ssam_pos_get_posture(struct ssam_tablet_sw *sw, struct ssam_tablet_sw_state *state)\n{\n\tu32 source_id;\n\tu32 source_state;\n\tint status;\n\n\tstatus = ssam_pos_get_source(sw, &source_id);\n\tif (status) {\n\t\tdev_err(&sw->sdev->dev, \"failed to get posture source ID: %d\\n\", status);\n\t\treturn status;\n\t}\n\n\tstatus = ssam_pos_get_posture_for_source(sw, source_id, &source_state);\n\tif (status) {\n\t\tdev_err(&sw->sdev->dev, \"failed to get posture value for source %u: %d\\n\",\n\t\t\tsource_id, status);\n\t\treturn status;\n\t}\n\n\tstate->source = source_id;\n\tstate->state = source_state;\n\treturn 0;\n}\n\nstatic u32 ssam_pos_sw_notif(struct ssam_event_notifier *nf, const struct ssam_event *event)\n{\n\tstruct ssam_tablet_sw *sw = container_of(nf, struct ssam_tablet_sw, notif);\n\n\tif (event->command_id != SSAM_EVENT_POS_CID_POSTURE_CHANGED)\n\t\treturn 0;\t \n\n\tif (event->length != sizeof(__le32) * 3)\n\t\tdev_warn(&sw->sdev->dev, \"unexpected payload size: %u\\n\", event->length);\n\n\tschedule_work(&sw->update_work);\n\treturn SSAM_NOTIF_HANDLED;\n}\n\nstatic const struct ssam_tablet_sw_desc ssam_pos_sw_desc = {\n\t.dev = {\n\t\t.name = \"Microsoft Surface POS Tablet Mode Switch\",\n\t\t.phys = \"ssam/01:26:01:00:01/input0\",\n\t},\n\t.ops = {\n\t\t.notify = ssam_pos_sw_notif,\n\t\t.get_state = ssam_pos_get_posture,\n\t\t.state_name = ssam_pos_state_name,\n\t\t.state_is_tablet_mode = ssam_pos_state_is_tablet_mode,\n\t},\n\t.event = {\n\t\t.reg = SSAM_EVENT_REGISTRY_SAM,\n\t\t.id = {\n\t\t\t.target_category = SSAM_SSH_TC_POS,\n\t\t\t.instance = 0,\n\t\t},\n\t\t.mask = SSAM_EVENT_MASK_TARGET,\n\t},\n};\n\n\n \n\nstatic const struct ssam_device_id ssam_tablet_sw_match[] = {\n\t{ SSAM_SDEV(KIP, SAM, 0x00, 0x01), (unsigned long)&ssam_kip_sw_desc },\n\t{ SSAM_SDEV(POS, SAM, 0x00, 0x01), (unsigned long)&ssam_pos_sw_desc },\n\t{ },\n};\nMODULE_DEVICE_TABLE(ssam, ssam_tablet_sw_match);\n\nstatic struct ssam_device_driver ssam_tablet_sw_driver = {\n\t.probe = ssam_tablet_sw_probe,\n\t.remove = ssam_tablet_sw_remove,\n\t.match_table = ssam_tablet_sw_match,\n\t.driver = {\n\t\t.name = \"surface_aggregator_tablet_mode_switch\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t\t.pm = &ssam_tablet_sw_pm_ops,\n\t},\n};\nmodule_ssam_device_driver(ssam_tablet_sw_driver);\n\nMODULE_AUTHOR(\"Maximilian Luz <luzmaximilian@gmail.com>\");\nMODULE_DESCRIPTION(\"Tablet mode switch driver for Surface devices using the Surface Aggregator Module\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}