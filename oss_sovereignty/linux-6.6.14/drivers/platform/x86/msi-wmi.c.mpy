{
  "module_name": "msi-wmi.c",
  "hash_id": "67ae74bbebd1afd380f8b46a222268eee4e26d20d0e9f1b95c931bee39a7a360",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/x86/msi-wmi.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/input.h>\n#include <linux/input/sparse-keymap.h>\n#include <linux/acpi.h>\n#include <linux/backlight.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <acpi/video.h>\n\nMODULE_AUTHOR(\"Thomas Renninger <trenn@suse.de>\");\nMODULE_DESCRIPTION(\"MSI laptop WMI hotkeys driver\");\nMODULE_LICENSE(\"GPL\");\n\n#define DRV_NAME \"msi-wmi\"\n\n#define MSIWMI_BIOS_GUID \"551A1F84-FBDD-4125-91DB-3EA8F44F1D45\"\n#define MSIWMI_MSI_EVENT_GUID \"B6F3EEF2-3D2F-49DC-9DE3-85BCE18C62F2\"\n#define MSIWMI_WIND_EVENT_GUID \"5B3CC38A-40D9-7245-8AE6-1145B751BE3F\"\n\nMODULE_ALIAS(\"wmi:\" MSIWMI_BIOS_GUID);\nMODULE_ALIAS(\"wmi:\" MSIWMI_MSI_EVENT_GUID);\nMODULE_ALIAS(\"wmi:\" MSIWMI_WIND_EVENT_GUID);\n\nenum msi_scancodes {\n\t \n\tMSI_KEY_BRIGHTNESSUP\t= 0xD0,\n\tMSI_KEY_BRIGHTNESSDOWN,\n\tMSI_KEY_VOLUMEUP,\n\tMSI_KEY_VOLUMEDOWN,\n\tMSI_KEY_MUTE,\n\t \n\tWIND_KEY_TOUCHPAD\t= 0x08,\t \n\tWIND_KEY_BLUETOOTH\t= 0x56,\t \n\tWIND_KEY_CAMERA,\t\t \n\tWIND_KEY_WLAN\t\t= 0x5f,\t \n\tWIND_KEY_TURBO,\t\t\t \n\tWIND_KEY_ECO\t\t= 0x69,\t \n};\nstatic struct key_entry msi_wmi_keymap[] = {\n\t{ KE_KEY, MSI_KEY_BRIGHTNESSUP,\t\t{KEY_BRIGHTNESSUP} },\n\t{ KE_KEY, MSI_KEY_BRIGHTNESSDOWN,\t{KEY_BRIGHTNESSDOWN} },\n\t{ KE_KEY, MSI_KEY_VOLUMEUP,\t\t{KEY_VOLUMEUP} },\n\t{ KE_KEY, MSI_KEY_VOLUMEDOWN,\t\t{KEY_VOLUMEDOWN} },\n\t{ KE_KEY, MSI_KEY_MUTE,\t\t\t{KEY_MUTE} },\n\n\t \n\t{ KE_IGNORE, WIND_KEY_TOUCHPAD,\t\t{KEY_TOUCHPAD_TOGGLE} },\n\t{ KE_IGNORE, WIND_KEY_BLUETOOTH,\t{KEY_BLUETOOTH} },\n\t{ KE_IGNORE, WIND_KEY_CAMERA,\t\t{KEY_CAMERA} },\n\t{ KE_IGNORE, WIND_KEY_WLAN,\t\t{KEY_WLAN} },\n\n\t \n\t{ KE_IGNORE, 0x00 },\n\t{ KE_IGNORE, 0x62 },\n\t{ KE_IGNORE, 0x63 },\n\n\t \n\t{ KE_KEY, WIND_KEY_TURBO,\t\t{KEY_PROG1} },\n\t{ KE_KEY, WIND_KEY_ECO,\t\t\t{KEY_PROG2} },\n\n\t{ KE_END, 0 }\n};\n\nstatic ktime_t last_pressed;\n\nstatic const struct {\n\tconst char *guid;\n\tbool quirk_last_pressed;\n} *event_wmi, event_wmis[] = {\n\t{ MSIWMI_MSI_EVENT_GUID, true },\n\t{ MSIWMI_WIND_EVENT_GUID, false },\n};\n\nstatic struct backlight_device *backlight;\n\nstatic int backlight_map[] = { 0x00, 0x33, 0x66, 0x99, 0xCC, 0xFF };\n\nstatic struct input_dev *msi_wmi_input_dev;\n\nstatic int msi_wmi_query_block(int instance, int *ret)\n{\n\tacpi_status status;\n\tunion acpi_object *obj;\n\n\tstruct acpi_buffer output = { ACPI_ALLOCATE_BUFFER, NULL };\n\n\tstatus = wmi_query_block(MSIWMI_BIOS_GUID, instance, &output);\n\tif (ACPI_FAILURE(status))\n\t\treturn -EIO;\n\n\tobj = output.pointer;\n\n\tif (!obj || obj->type != ACPI_TYPE_INTEGER) {\n\t\tif (obj) {\n\t\t\tpr_err(\"query block returned object \"\n\t\t\t       \"type: %d - buffer length:%d\\n\", obj->type,\n\t\t\t       obj->type == ACPI_TYPE_BUFFER ?\n\t\t\t       obj->buffer.length : 0);\n\t\t}\n\t\tkfree(obj);\n\t\treturn -EINVAL;\n\t}\n\t*ret = obj->integer.value;\n\tkfree(obj);\n\treturn 0;\n}\n\nstatic int msi_wmi_set_block(int instance, int value)\n{\n\tacpi_status status;\n\n\tstruct acpi_buffer input = { sizeof(int), &value };\n\n\tpr_debug(\"Going to set block of instance: %d - value: %d\\n\",\n\t\t instance, value);\n\n\tstatus = wmi_set_block(MSIWMI_BIOS_GUID, instance, &input);\n\n\treturn ACPI_SUCCESS(status) ? 0 : 1;\n}\n\nstatic int bl_get(struct backlight_device *bd)\n{\n\tint level, err, ret;\n\n\t \n\terr = msi_wmi_query_block(1, &ret);\n\tif (err) {\n\t\tpr_err(\"Could not query backlight: %d\\n\", err);\n\t\treturn -EINVAL;\n\t}\n\tpr_debug(\"Get: Query block returned: %d\\n\", ret);\n\tfor (level = 0; level < ARRAY_SIZE(backlight_map); level++) {\n\t\tif (backlight_map[level] == ret) {\n\t\t\tpr_debug(\"Current backlight level: 0x%X - index: %d\\n\",\n\t\t\t\t backlight_map[level], level);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (level == ARRAY_SIZE(backlight_map)) {\n\t\tpr_err(\"get: Invalid brightness value: 0x%X\\n\", ret);\n\t\treturn -EINVAL;\n\t}\n\treturn level;\n}\n\nstatic int bl_set_status(struct backlight_device *bd)\n{\n\tint bright = bd->props.brightness;\n\tif (bright >= ARRAY_SIZE(backlight_map) || bright < 0)\n\t\treturn -EINVAL;\n\n\t \n\treturn msi_wmi_set_block(0, backlight_map[bright]);\n}\n\nstatic const struct backlight_ops msi_backlight_ops = {\n\t.get_brightness\t= bl_get,\n\t.update_status\t= bl_set_status,\n};\n\nstatic void msi_wmi_notify(u32 value, void *context)\n{\n\tstruct acpi_buffer response = { ACPI_ALLOCATE_BUFFER, NULL };\n\tstruct key_entry *key;\n\tunion acpi_object *obj;\n\tacpi_status status;\n\n\tstatus = wmi_get_event_data(value, &response);\n\tif (status != AE_OK) {\n\t\tpr_info(\"bad event status 0x%x\\n\", status);\n\t\treturn;\n\t}\n\n\tobj = (union acpi_object *)response.pointer;\n\n\tif (obj && obj->type == ACPI_TYPE_INTEGER) {\n\t\tint eventcode = obj->integer.value;\n\t\tpr_debug(\"Eventcode: 0x%x\\n\", eventcode);\n\t\tkey = sparse_keymap_entry_from_scancode(msi_wmi_input_dev,\n\t\t\t\teventcode);\n\t\tif (!key) {\n\t\t\tpr_info(\"Unknown key pressed - %x\\n\", eventcode);\n\t\t\tgoto msi_wmi_notify_exit;\n\t\t}\n\n\t\tif (event_wmi->quirk_last_pressed) {\n\t\t\tktime_t cur = ktime_get_real();\n\t\t\tktime_t diff = ktime_sub(cur, last_pressed);\n\t\t\t \n\t\t\tif (ktime_to_us(diff) < 1000 * 50) {\n\t\t\t\tpr_debug(\"Suppressed key event 0x%X - \"\n\t\t\t\t\t \"Last press was %lld us ago\\n\",\n\t\t\t\t\t key->code, ktime_to_us(diff));\n\t\t\t\tgoto msi_wmi_notify_exit;\n\t\t\t}\n\t\t\tlast_pressed = cur;\n\t\t}\n\n\t\tif (key->type == KE_KEY &&\n\t\t \n\t\t(backlight ||\n\t\t(key->code != MSI_KEY_BRIGHTNESSUP &&\n\t\tkey->code != MSI_KEY_BRIGHTNESSDOWN))) {\n\t\t\tpr_debug(\"Send key: 0x%X - Input layer keycode: %d\\n\",\n\t\t\t\t key->code, key->keycode);\n\t\t\tsparse_keymap_report_entry(msi_wmi_input_dev, key, 1,\n\t\t\t\t\t\t   true);\n\t\t}\n\t} else\n\t\tpr_info(\"Unknown event received\\n\");\n\nmsi_wmi_notify_exit:\n\tkfree(response.pointer);\n}\n\nstatic int __init msi_wmi_backlight_setup(void)\n{\n\tint err;\n\tstruct backlight_properties props;\n\n\tmemset(&props, 0, sizeof(struct backlight_properties));\n\tprops.type = BACKLIGHT_PLATFORM;\n\tprops.max_brightness = ARRAY_SIZE(backlight_map) - 1;\n\tbacklight = backlight_device_register(DRV_NAME, NULL, NULL,\n\t\t\t\t\t      &msi_backlight_ops,\n\t\t\t\t\t      &props);\n\tif (IS_ERR(backlight))\n\t\treturn PTR_ERR(backlight);\n\n\terr = bl_get(NULL);\n\tif (err < 0) {\n\t\tbacklight_device_unregister(backlight);\n\t\treturn err;\n\t}\n\n\tbacklight->props.brightness = err;\n\n\treturn 0;\n}\n\nstatic int __init msi_wmi_input_setup(void)\n{\n\tint err;\n\n\tmsi_wmi_input_dev = input_allocate_device();\n\tif (!msi_wmi_input_dev)\n\t\treturn -ENOMEM;\n\n\tmsi_wmi_input_dev->name = \"MSI WMI hotkeys\";\n\tmsi_wmi_input_dev->phys = \"wmi/input0\";\n\tmsi_wmi_input_dev->id.bustype = BUS_HOST;\n\n\terr = sparse_keymap_setup(msi_wmi_input_dev, msi_wmi_keymap, NULL);\n\tif (err)\n\t\tgoto err_free_dev;\n\n\terr = input_register_device(msi_wmi_input_dev);\n\n\tif (err)\n\t\tgoto err_free_dev;\n\n\tlast_pressed = 0;\n\n\treturn 0;\n\nerr_free_dev:\n\tinput_free_device(msi_wmi_input_dev);\n\treturn err;\n}\n\nstatic int __init msi_wmi_init(void)\n{\n\tint err;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(event_wmis); i++) {\n\t\tif (!wmi_has_guid(event_wmis[i].guid))\n\t\t\tcontinue;\n\n\t\terr = msi_wmi_input_setup();\n\t\tif (err) {\n\t\t\tpr_err(\"Unable to setup input device\\n\");\n\t\t\treturn err;\n\t\t}\n\n\t\terr = wmi_install_notify_handler(event_wmis[i].guid,\n\t\t\tmsi_wmi_notify, NULL);\n\t\tif (ACPI_FAILURE(err)) {\n\t\t\tpr_err(\"Unable to setup WMI notify handler\\n\");\n\t\t\tgoto err_free_input;\n\t\t}\n\n\t\tpr_debug(\"Event handler installed\\n\");\n\t\tevent_wmi = &event_wmis[i];\n\t\tbreak;\n\t}\n\n\tif (wmi_has_guid(MSIWMI_BIOS_GUID) &&\n\t    acpi_video_get_backlight_type() == acpi_backlight_vendor) {\n\t\terr = msi_wmi_backlight_setup();\n\t\tif (err) {\n\t\t\tpr_err(\"Unable to setup backlight device\\n\");\n\t\t\tgoto err_uninstall_handler;\n\t\t}\n\t\tpr_debug(\"Backlight device created\\n\");\n\t}\n\n\tif (!event_wmi && !backlight) {\n\t\tpr_err(\"This machine doesn't have neither MSI-hotkeys nor backlight through WMI\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n\nerr_uninstall_handler:\n\tif (event_wmi)\n\t\twmi_remove_notify_handler(event_wmi->guid);\nerr_free_input:\n\tif (event_wmi)\n\t\tinput_unregister_device(msi_wmi_input_dev);\n\treturn err;\n}\n\nstatic void __exit msi_wmi_exit(void)\n{\n\tif (event_wmi) {\n\t\twmi_remove_notify_handler(event_wmi->guid);\n\t\tinput_unregister_device(msi_wmi_input_dev);\n\t}\n\tbacklight_device_unregister(backlight);\n}\n\nmodule_init(msi_wmi_init);\nmodule_exit(msi_wmi_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}