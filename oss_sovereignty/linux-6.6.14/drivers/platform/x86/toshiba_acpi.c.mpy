{
  "module_name": "toshiba_acpi.c",
  "hash_id": "904c42176cf3fce6c748dc109bd560883ccf6f877313c0ac795f6a5e727c2b16",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/x86/toshiba_acpi.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#define TOSHIBA_ACPI_VERSION\t\"0.24\"\n#define PROC_INTERFACE_VERSION\t1\n\n#include <linux/compiler.h>\n#include <linux/dmi.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/init.h>\n#include <linux/types.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/backlight.h>\n#include <linux/input.h>\n#include <linux/input/sparse-keymap.h>\n#include <linux/leds.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/i8042.h>\n#include <linux/acpi.h>\n#include <linux/uaccess.h>\n#include <linux/miscdevice.h>\n#include <linux/rfkill.h>\n#include <linux/hwmon.h>\n#include <linux/iio/iio.h>\n#include <linux/toshiba.h>\n#include <acpi/battery.h>\n#include <acpi/video.h>\n\nMODULE_AUTHOR(\"John Belmonte\");\nMODULE_DESCRIPTION(\"Toshiba Laptop ACPI Extras Driver\");\nMODULE_LICENSE(\"GPL\");\n\nstatic int turn_on_panel_on_resume = -1;\nmodule_param(turn_on_panel_on_resume, int, 0644);\nMODULE_PARM_DESC(turn_on_panel_on_resume,\n\t\"Call HCI_PANEL_POWER_ON on resume (-1 = auto, 0 = no, 1 = yes\");\n\n#define TOSHIBA_WMI_EVENT_GUID \"59142400-C6A3-40FA-BADB-8A2652834100\"\n\n \n#define TOS1900_FN_SCAN\t\t0x6e\n\n \n#define METHOD_VIDEO_OUT\t\"\\\\_SB_.VALX.DSSX\"\n\n \n\n#define TCI_WORDS\t\t\t6\n\n \n#define HCI_SET\t\t\t\t0xff00\n#define HCI_GET\t\t\t\t0xfe00\n#define SCI_OPEN\t\t\t0xf100\n#define SCI_CLOSE\t\t\t0xf200\n#define SCI_GET\t\t\t\t0xf300\n#define SCI_SET\t\t\t\t0xf400\n\n \n#define TOS_SUCCESS\t\t\t0x0000\n#define TOS_SUCCESS2\t\t\t0x0001\n#define TOS_OPEN_CLOSE_OK\t\t0x0044\n#define TOS_FAILURE\t\t\t0x1000\n#define TOS_NOT_SUPPORTED\t\t0x8000\n#define TOS_ALREADY_OPEN\t\t0x8100\n#define TOS_NOT_OPENED\t\t\t0x8200\n#define TOS_INPUT_DATA_ERROR\t\t0x8300\n#define TOS_WRITE_PROTECTED\t\t0x8400\n#define TOS_NOT_PRESENT\t\t\t0x8600\n#define TOS_FIFO_EMPTY\t\t\t0x8c00\n#define TOS_DATA_NOT_AVAILABLE\t\t0x8d20\n#define TOS_NOT_INITIALIZED\t\t0x8d50\n#define TOS_NOT_INSTALLED\t\t0x8e00\n\n \n#define HCI_PANEL_POWER_ON\t\t0x0002\n#define HCI_FAN\t\t\t\t0x0004\n#define HCI_TR_BACKLIGHT\t\t0x0005\n#define HCI_SYSTEM_EVENT\t\t0x0016\n#define HCI_VIDEO_OUT\t\t\t0x001c\n#define HCI_HOTKEY_EVENT\t\t0x001e\n#define HCI_LCD_BRIGHTNESS\t\t0x002a\n#define HCI_FAN_RPM\t\t\t0x0045\n#define HCI_WIRELESS\t\t\t0x0056\n#define HCI_ACCELEROMETER\t\t0x006d\n#define HCI_COOLING_METHOD\t\t0x007f\n#define HCI_KBD_ILLUMINATION\t\t0x0095\n#define HCI_ECO_MODE\t\t\t0x0097\n#define HCI_ACCELEROMETER2\t\t0x00a6\n#define HCI_BATTERY_CHARGE_MODE\t\t0x00ba\n#define HCI_SYSTEM_INFO\t\t\t0xc000\n#define SCI_PANEL_POWER_ON\t\t0x010d\n#define SCI_ILLUMINATION\t\t0x014e\n#define SCI_USB_SLEEP_CHARGE\t\t0x0150\n#define SCI_KBD_ILLUM_STATUS\t\t0x015c\n#define SCI_USB_SLEEP_MUSIC\t\t0x015e\n#define SCI_USB_THREE\t\t\t0x0169\n#define SCI_TOUCHPAD\t\t\t0x050e\n#define SCI_KBD_FUNCTION_KEYS\t\t0x0522\n\n \n#define HCI_ACCEL_MASK\t\t\t0x7fff\n#define HCI_ACCEL_DIRECTION_MASK\t0x8000\n#define HCI_HOTKEY_DISABLE\t\t0x0b\n#define HCI_HOTKEY_ENABLE\t\t0x09\n#define HCI_HOTKEY_SPECIAL_FUNCTIONS\t0x10\n#define HCI_LCD_BRIGHTNESS_BITS\t\t3\n#define HCI_LCD_BRIGHTNESS_SHIFT\t(16-HCI_LCD_BRIGHTNESS_BITS)\n#define HCI_LCD_BRIGHTNESS_LEVELS\t(1 << HCI_LCD_BRIGHTNESS_BITS)\n#define HCI_MISC_SHIFT\t\t\t0x10\n#define HCI_SYSTEM_TYPE1\t\t0x10\n#define HCI_SYSTEM_TYPE2\t\t0x11\n#define HCI_VIDEO_OUT_LCD\t\t0x1\n#define HCI_VIDEO_OUT_CRT\t\t0x2\n#define HCI_VIDEO_OUT_TV\t\t0x4\n#define SCI_KBD_MODE_MASK\t\t0x1f\n#define SCI_KBD_MODE_FNZ\t\t0x1\n#define SCI_KBD_MODE_AUTO\t\t0x2\n#define SCI_KBD_MODE_ON\t\t\t0x8\n#define SCI_KBD_MODE_OFF\t\t0x10\n#define SCI_KBD_TIME_MAX\t\t0x3c001a\n#define HCI_WIRELESS_STATUS\t\t0x1\n#define HCI_WIRELESS_WWAN\t\t0x3\n#define HCI_WIRELESS_WWAN_STATUS\t0x2000\n#define HCI_WIRELESS_WWAN_POWER\t\t0x4000\n#define SCI_USB_CHARGE_MODE_MASK\t0xff\n#define SCI_USB_CHARGE_DISABLED\t\t0x00\n#define SCI_USB_CHARGE_ALTERNATE\t0x09\n#define SCI_USB_CHARGE_TYPICAL\t\t0x11\n#define SCI_USB_CHARGE_AUTO\t\t0x21\n#define SCI_USB_CHARGE_BAT_MASK\t\t0x7\n#define SCI_USB_CHARGE_BAT_LVL_OFF\t0x1\n#define SCI_USB_CHARGE_BAT_LVL_ON\t0x4\n#define SCI_USB_CHARGE_BAT_LVL\t\t0x0200\n#define SCI_USB_CHARGE_RAPID_DSP\t0x0300\n\nstruct toshiba_acpi_dev {\n\tstruct acpi_device *acpi_dev;\n\tconst char *method_hci;\n\tstruct input_dev *hotkey_dev;\n\tstruct work_struct hotkey_work;\n\tstruct backlight_device *backlight_dev;\n\tstruct led_classdev led_dev;\n\tstruct led_classdev kbd_led;\n\tstruct led_classdev eco_led;\n\tstruct miscdevice miscdev;\n\tstruct rfkill *wwan_rfk;\n\tstruct iio_dev *indio_dev;\n#if IS_ENABLED(CONFIG_HWMON)\n\tstruct device *hwmon_device;\n#endif\n\n\tint force_fan;\n\tint last_key_event;\n\tint key_event_valid;\n\tint kbd_type;\n\tint kbd_mode;\n\tint kbd_time;\n\tint usbsc_bat_level;\n\tint usbsc_mode_base;\n\tint hotkey_event_type;\n\tint max_cooling_method;\n\n\tunsigned int illumination_supported:1;\n\tunsigned int video_supported:1;\n\tunsigned int fan_supported:1;\n\tunsigned int fan_rpm_supported:1;\n\tunsigned int system_event_supported:1;\n\tunsigned int ntfy_supported:1;\n\tunsigned int info_supported:1;\n\tunsigned int tr_backlight_supported:1;\n\tunsigned int kbd_illum_supported:1;\n\tunsigned int touchpad_supported:1;\n\tunsigned int eco_supported:1;\n\tunsigned int accelerometer_supported:1;\n\tunsigned int usb_sleep_charge_supported:1;\n\tunsigned int usb_rapid_charge_supported:1;\n\tunsigned int usb_sleep_music_supported:1;\n\tunsigned int kbd_function_keys_supported:1;\n\tunsigned int panel_power_on_supported:1;\n\tunsigned int usb_three_supported:1;\n\tunsigned int wwan_supported:1;\n\tunsigned int cooling_method_supported:1;\n\tunsigned int battery_charge_mode_supported:1;\n\tunsigned int sysfs_created:1;\n\tunsigned int special_functions;\n\n\tbool kbd_event_generated;\n\tbool killswitch;\n};\n\nstatic struct toshiba_acpi_dev *toshiba_acpi;\n\nstatic bool disable_hotkeys;\nmodule_param(disable_hotkeys, bool, 0444);\nMODULE_PARM_DESC(disable_hotkeys, \"Disables the hotkeys activation\");\n\nstatic const struct acpi_device_id toshiba_device_ids[] = {\n\t{\"TOS6200\", 0},\n\t{\"TOS6207\", 0},\n\t{\"TOS6208\", 0},\n\t{\"TOS1900\", 0},\n\t{\"\", 0},\n};\nMODULE_DEVICE_TABLE(acpi, toshiba_device_ids);\n\nstatic const struct key_entry toshiba_acpi_keymap[] = {\n\t{ KE_KEY, 0x9e, { KEY_RFKILL } },\n\t{ KE_KEY, 0x101, { KEY_MUTE } },\n\t{ KE_KEY, 0x102, { KEY_ZOOMOUT } },\n\t{ KE_KEY, 0x103, { KEY_ZOOMIN } },\n\t{ KE_KEY, 0x10f, { KEY_TAB } },\n\t{ KE_KEY, 0x12c, { KEY_KBDILLUMTOGGLE } },\n\t{ KE_KEY, 0x139, { KEY_ZOOMRESET } },\n\t{ KE_KEY, 0x13b, { KEY_COFFEE } },\n\t{ KE_KEY, 0x13c, { KEY_BATTERY } },\n\t{ KE_KEY, 0x13d, { KEY_SLEEP } },\n\t{ KE_KEY, 0x13e, { KEY_SUSPEND } },\n\t{ KE_KEY, 0x13f, { KEY_SWITCHVIDEOMODE } },\n\t{ KE_KEY, 0x140, { KEY_BRIGHTNESSDOWN } },\n\t{ KE_KEY, 0x141, { KEY_BRIGHTNESSUP } },\n\t{ KE_KEY, 0x142, { KEY_WLAN } },\n\t{ KE_KEY, 0x143, { KEY_TOUCHPAD_TOGGLE } },\n\t{ KE_KEY, 0x17f, { KEY_FN } },\n\t{ KE_KEY, 0xb05, { KEY_PROG2 } },\n\t{ KE_KEY, 0xb06, { KEY_WWW } },\n\t{ KE_KEY, 0xb07, { KEY_MAIL } },\n\t{ KE_KEY, 0xb30, { KEY_STOP } },\n\t{ KE_KEY, 0xb31, { KEY_PREVIOUSSONG } },\n\t{ KE_KEY, 0xb32, { KEY_NEXTSONG } },\n\t{ KE_KEY, 0xb33, { KEY_PLAYPAUSE } },\n\t{ KE_KEY, 0xb5a, { KEY_MEDIA } },\n\t{ KE_IGNORE, 0x1430, { KEY_RESERVED } },  \n\t{ KE_IGNORE, 0x1501, { KEY_RESERVED } },  \n\t{ KE_IGNORE, 0x1502, { KEY_RESERVED } },  \n\t{ KE_IGNORE, 0x1ABE, { KEY_RESERVED } },  \n\t{ KE_IGNORE, 0x1ABF, { KEY_RESERVED } },  \n\t{ KE_END, 0 },\n};\n\nstatic const struct key_entry toshiba_acpi_alt_keymap[] = {\n\t{ KE_KEY, 0x102, { KEY_ZOOMOUT } },\n\t{ KE_KEY, 0x103, { KEY_ZOOMIN } },\n\t{ KE_KEY, 0x12c, { KEY_KBDILLUMTOGGLE } },\n\t{ KE_KEY, 0x139, { KEY_ZOOMRESET } },\n\t{ KE_KEY, 0x13c, { KEY_BRIGHTNESSDOWN } },\n\t{ KE_KEY, 0x13d, { KEY_BRIGHTNESSUP } },\n\t{ KE_KEY, 0x13e, { KEY_SWITCHVIDEOMODE } },\n\t{ KE_KEY, 0x13f, { KEY_TOUCHPAD_TOGGLE } },\n\t{ KE_KEY, 0x157, { KEY_MUTE } },\n\t{ KE_KEY, 0x158, { KEY_WLAN } },\n\t{ KE_END, 0 },\n};\n\n \n\nstatic inline void _set_bit(u32 *word, u32 mask, int value)\n{\n\t*word = (*word & ~mask) | (mask * value);\n}\n\n \n\nstatic int write_acpi_int(const char *methodName, int val)\n{\n\tacpi_status status;\n\n\tstatus = acpi_execute_simple_method(NULL, (char *)methodName, val);\n\treturn (status == AE_OK) ? 0 : -EIO;\n}\n\n \nstatic acpi_status tci_raw(struct toshiba_acpi_dev *dev,\n\t\t\t   const u32 in[TCI_WORDS], u32 out[TCI_WORDS])\n{\n\tunion acpi_object in_objs[TCI_WORDS], out_objs[TCI_WORDS + 1];\n\tstruct acpi_object_list params;\n\tstruct acpi_buffer results;\n\tacpi_status status;\n\tint i;\n\n\tparams.count = TCI_WORDS;\n\tparams.pointer = in_objs;\n\tfor (i = 0; i < TCI_WORDS; ++i) {\n\t\tin_objs[i].type = ACPI_TYPE_INTEGER;\n\t\tin_objs[i].integer.value = in[i];\n\t}\n\n\tresults.length = sizeof(out_objs);\n\tresults.pointer = out_objs;\n\n\tstatus = acpi_evaluate_object(dev->acpi_dev->handle,\n\t\t\t\t      (char *)dev->method_hci, &params,\n\t\t\t\t      &results);\n\tif ((status == AE_OK) && (out_objs->package.count <= TCI_WORDS)) {\n\t\tfor (i = 0; i < out_objs->package.count; ++i)\n\t\t\tout[i] = out_objs->package.elements[i].integer.value;\n\t}\n\n\treturn status;\n}\n\n \n\nstatic u32 hci_write(struct toshiba_acpi_dev *dev, u32 reg, u32 in1)\n{\n\tu32 in[TCI_WORDS] = { HCI_SET, reg, in1, 0, 0, 0 };\n\tu32 out[TCI_WORDS];\n\tacpi_status status = tci_raw(dev, in, out);\n\n\treturn ACPI_SUCCESS(status) ? out[0] : TOS_FAILURE;\n}\n\nstatic u32 hci_read(struct toshiba_acpi_dev *dev, u32 reg, u32 *out1)\n{\n\tu32 in[TCI_WORDS] = { HCI_GET, reg, 0, 0, 0, 0 };\n\tu32 out[TCI_WORDS];\n\tacpi_status status = tci_raw(dev, in, out);\n\n\tif (ACPI_FAILURE(status))\n\t\treturn TOS_FAILURE;\n\n\t*out1 = out[2];\n\n\treturn out[0];\n}\n\n \n\nstatic int sci_open(struct toshiba_acpi_dev *dev)\n{\n\tu32 in[TCI_WORDS] = { SCI_OPEN, 0, 0, 0, 0, 0 };\n\tu32 out[TCI_WORDS];\n\tacpi_status status = tci_raw(dev, in, out);\n\n\tif  (ACPI_FAILURE(status)) {\n\t\tpr_err(\"ACPI call to open SCI failed\\n\");\n\t\treturn 0;\n\t}\n\n\tif (out[0] == TOS_OPEN_CLOSE_OK) {\n\t\treturn 1;\n\t} else if (out[0] == TOS_ALREADY_OPEN) {\n\t\tpr_info(\"Toshiba SCI already opened\\n\");\n\t\treturn 1;\n\t} else if (out[0] == TOS_NOT_SUPPORTED) {\n\t\t \n\t\treturn 1;\n\t} else if (out[0] == TOS_NOT_PRESENT) {\n\t\tpr_info(\"Toshiba SCI is not present\\n\");\n\t}\n\n\treturn 0;\n}\n\nstatic void sci_close(struct toshiba_acpi_dev *dev)\n{\n\tu32 in[TCI_WORDS] = { SCI_CLOSE, 0, 0, 0, 0, 0 };\n\tu32 out[TCI_WORDS];\n\tacpi_status status = tci_raw(dev, in, out);\n\n\tif (ACPI_FAILURE(status)) {\n\t\tpr_err(\"ACPI call to close SCI failed\\n\");\n\t\treturn;\n\t}\n\n\tif (out[0] == TOS_OPEN_CLOSE_OK)\n\t\treturn;\n\telse if (out[0] == TOS_NOT_OPENED)\n\t\tpr_info(\"Toshiba SCI not opened\\n\");\n\telse if (out[0] == TOS_NOT_PRESENT)\n\t\tpr_info(\"Toshiba SCI is not present\\n\");\n}\n\nstatic u32 sci_read(struct toshiba_acpi_dev *dev, u32 reg, u32 *out1)\n{\n\tu32 in[TCI_WORDS] = { SCI_GET, reg, 0, 0, 0, 0 };\n\tu32 out[TCI_WORDS];\n\tacpi_status status = tci_raw(dev, in, out);\n\n\tif (ACPI_FAILURE(status))\n\t\treturn TOS_FAILURE;\n\n\t*out1 = out[2];\n\n\treturn out[0];\n}\n\nstatic u32 sci_write(struct toshiba_acpi_dev *dev, u32 reg, u32 in1)\n{\n\tu32 in[TCI_WORDS] = { SCI_SET, reg, in1, 0, 0, 0 };\n\tu32 out[TCI_WORDS];\n\tacpi_status status = tci_raw(dev, in, out);\n\n\treturn ACPI_SUCCESS(status) ? out[0] : TOS_FAILURE;\n}\n\n \nstatic void toshiba_illumination_available(struct toshiba_acpi_dev *dev)\n{\n\tu32 in[TCI_WORDS] = { SCI_GET, SCI_ILLUMINATION, 0, 0, 0, 0 };\n\tu32 out[TCI_WORDS];\n\tacpi_status status;\n\n\tdev->illumination_supported = 0;\n\n\tif (!sci_open(dev))\n\t\treturn;\n\n\tstatus = tci_raw(dev, in, out);\n\tsci_close(dev);\n\tif (ACPI_FAILURE(status)) {\n\t\tpr_err(\"ACPI call to query Illumination support failed\\n\");\n\t\treturn;\n\t}\n\n\tif (out[0] != TOS_SUCCESS)\n\t\treturn;\n\n\tdev->illumination_supported = 1;\n}\n\nstatic void toshiba_illumination_set(struct led_classdev *cdev,\n\t\t\t\t     enum led_brightness brightness)\n{\n\tstruct toshiba_acpi_dev *dev = container_of(cdev,\n\t\t\tstruct toshiba_acpi_dev, led_dev);\n\tu32 result;\n\tu32 state;\n\n\t \n\tif (!sci_open(dev))\n\t\treturn;\n\n\t \n\tstate = brightness ? 1 : 0;\n\tresult = sci_write(dev, SCI_ILLUMINATION, state);\n\tsci_close(dev);\n\tif (result == TOS_FAILURE)\n\t\tpr_err(\"ACPI call for illumination failed\\n\");\n}\n\nstatic enum led_brightness toshiba_illumination_get(struct led_classdev *cdev)\n{\n\tstruct toshiba_acpi_dev *dev = container_of(cdev,\n\t\t\tstruct toshiba_acpi_dev, led_dev);\n\tu32 result;\n\tu32 state;\n\n\t \n\tif (!sci_open(dev))\n\t\treturn LED_OFF;\n\n\t \n\tresult = sci_read(dev, SCI_ILLUMINATION, &state);\n\tsci_close(dev);\n\tif (result == TOS_FAILURE) {\n\t\tpr_err(\"ACPI call for illumination failed\\n\");\n\t\treturn LED_OFF;\n\t} else if (result != TOS_SUCCESS) {\n\t\treturn LED_OFF;\n\t}\n\n\treturn state ? LED_FULL : LED_OFF;\n}\n\n \nstatic void toshiba_kbd_illum_available(struct toshiba_acpi_dev *dev)\n{\n\tu32 in[TCI_WORDS] = { SCI_GET, SCI_KBD_ILLUM_STATUS, 0, 0, 0, 0 };\n\tu32 out[TCI_WORDS];\n\tacpi_status status;\n\n\tdev->kbd_illum_supported = 0;\n\tdev->kbd_event_generated = false;\n\n\tif (!sci_open(dev))\n\t\treturn;\n\n\tstatus = tci_raw(dev, in, out);\n\tsci_close(dev);\n\tif (ACPI_FAILURE(status)) {\n\t\tpr_err(\"ACPI call to query kbd illumination support failed\\n\");\n\t\treturn;\n\t}\n\n\tif (out[0] != TOS_SUCCESS)\n\t\treturn;\n\n\t \n\tif (out[3] == SCI_KBD_TIME_MAX)\n\t\tdev->kbd_type = 2;\n\telse\n\t\tdev->kbd_type = 1;\n\t \n\tdev->kbd_mode = out[2] & SCI_KBD_MODE_MASK;\n\t \n\tdev->kbd_time = out[2] >> HCI_MISC_SHIFT;\n\t \n\tdev->kbd_illum_supported = 1;\n}\n\nstatic int toshiba_kbd_illum_status_set(struct toshiba_acpi_dev *dev, u32 time)\n{\n\tu32 result;\n\n\tif (!sci_open(dev))\n\t\treturn -EIO;\n\n\tresult = sci_write(dev, SCI_KBD_ILLUM_STATUS, time);\n\tsci_close(dev);\n\tif (result == TOS_FAILURE)\n\t\tpr_err(\"ACPI call to set KBD backlight status failed\\n\");\n\telse if (result == TOS_NOT_SUPPORTED)\n\t\treturn -ENODEV;\n\n\treturn result == TOS_SUCCESS ? 0 : -EIO;\n}\n\nstatic int toshiba_kbd_illum_status_get(struct toshiba_acpi_dev *dev, u32 *time)\n{\n\tu32 result;\n\n\tif (!sci_open(dev))\n\t\treturn -EIO;\n\n\tresult = sci_read(dev, SCI_KBD_ILLUM_STATUS, time);\n\tsci_close(dev);\n\tif (result == TOS_FAILURE)\n\t\tpr_err(\"ACPI call to get KBD backlight status failed\\n\");\n\telse if (result == TOS_NOT_SUPPORTED)\n\t\treturn -ENODEV;\n\n\treturn result == TOS_SUCCESS ? 0 : -EIO;\n}\n\nstatic enum led_brightness toshiba_kbd_backlight_get(struct led_classdev *cdev)\n{\n\tstruct toshiba_acpi_dev *dev = container_of(cdev,\n\t\t\tstruct toshiba_acpi_dev, kbd_led);\n\tu32 result;\n\tu32 state;\n\n\t \n\tresult = hci_read(dev, HCI_KBD_ILLUMINATION, &state);\n\tif (result == TOS_FAILURE) {\n\t\tpr_err(\"ACPI call to get the keyboard backlight failed\\n\");\n\t\treturn LED_OFF;\n\t} else if (result != TOS_SUCCESS) {\n\t\treturn LED_OFF;\n\t}\n\n\treturn state ? LED_FULL : LED_OFF;\n}\n\nstatic void toshiba_kbd_backlight_set(struct led_classdev *cdev,\n\t\t\t\t     enum led_brightness brightness)\n{\n\tstruct toshiba_acpi_dev *dev = container_of(cdev,\n\t\t\tstruct toshiba_acpi_dev, kbd_led);\n\tu32 result;\n\tu32 state;\n\n\t \n\tstate = brightness ? 1 : 0;\n\tresult = hci_write(dev, HCI_KBD_ILLUMINATION, state);\n\tif (result == TOS_FAILURE)\n\t\tpr_err(\"ACPI call to set KBD Illumination mode failed\\n\");\n}\n\n \nstatic int toshiba_touchpad_set(struct toshiba_acpi_dev *dev, u32 state)\n{\n\tu32 result;\n\n\tif (!sci_open(dev))\n\t\treturn -EIO;\n\n\tresult = sci_write(dev, SCI_TOUCHPAD, state);\n\tsci_close(dev);\n\tif (result == TOS_FAILURE)\n\t\tpr_err(\"ACPI call to set the touchpad failed\\n\");\n\telse if (result == TOS_NOT_SUPPORTED)\n\t\treturn -ENODEV;\n\n\treturn result == TOS_SUCCESS ? 0 : -EIO;\n}\n\nstatic int toshiba_touchpad_get(struct toshiba_acpi_dev *dev, u32 *state)\n{\n\tu32 result;\n\n\tif (!sci_open(dev))\n\t\treturn -EIO;\n\n\tresult = sci_read(dev, SCI_TOUCHPAD, state);\n\tsci_close(dev);\n\tif (result == TOS_FAILURE)\n\t\tpr_err(\"ACPI call to query the touchpad failed\\n\");\n\telse if (result == TOS_NOT_SUPPORTED)\n\t\treturn -ENODEV;\n\n\treturn result == TOS_SUCCESS ? 0 : -EIO;\n}\n\n \nstatic void toshiba_eco_mode_available(struct toshiba_acpi_dev *dev)\n{\n\tu32 in[TCI_WORDS] = { HCI_GET, HCI_ECO_MODE, 0, 0, 0, 0 };\n\tu32 out[TCI_WORDS];\n\tacpi_status status;\n\n\tdev->eco_supported = 0;\n\n\tstatus = tci_raw(dev, in, out);\n\tif (ACPI_FAILURE(status)) {\n\t\tpr_err(\"ACPI call to get ECO led failed\\n\");\n\t\treturn;\n\t}\n\n\tif (out[0] == TOS_INPUT_DATA_ERROR || out[0] == TOS_NOT_SUPPORTED) {\n\t\t \n\t\tin[3] = 1;\n\t\tstatus = tci_raw(dev, in, out);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tpr_err(\"ACPI call to get ECO led failed\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\tif (out[0] != TOS_SUCCESS)\n\t\t\treturn;\n\n\t\tdev->eco_supported = 1;\n\t}\n}\n\nstatic enum led_brightness\ntoshiba_eco_mode_get_status(struct led_classdev *cdev)\n{\n\tstruct toshiba_acpi_dev *dev = container_of(cdev,\n\t\t\tstruct toshiba_acpi_dev, eco_led);\n\tu32 in[TCI_WORDS] = { HCI_GET, HCI_ECO_MODE, 0, 1, 0, 0 };\n\tu32 out[TCI_WORDS];\n\tacpi_status status;\n\n\tstatus = tci_raw(dev, in, out);\n\tif (ACPI_FAILURE(status)) {\n\t\tpr_err(\"ACPI call to get ECO led failed\\n\");\n\t\treturn LED_OFF;\n\t}\n\n\tif (out[0] != TOS_SUCCESS)\n\t\treturn LED_OFF;\n\n\treturn out[2] ? LED_FULL : LED_OFF;\n}\n\nstatic void toshiba_eco_mode_set_status(struct led_classdev *cdev,\n\t\t\t\t     enum led_brightness brightness)\n{\n\tstruct toshiba_acpi_dev *dev = container_of(cdev,\n\t\t\tstruct toshiba_acpi_dev, eco_led);\n\tu32 in[TCI_WORDS] = { HCI_SET, HCI_ECO_MODE, 0, 1, 0, 0 };\n\tu32 out[TCI_WORDS];\n\tacpi_status status;\n\n\t \n\tin[2] = (brightness) ? 1 : 0;\n\tstatus = tci_raw(dev, in, out);\n\tif (ACPI_FAILURE(status))\n\t\tpr_err(\"ACPI call to set ECO led failed\\n\");\n}\n\n \nstatic void toshiba_accelerometer_available(struct toshiba_acpi_dev *dev)\n{\n\tu32 in[TCI_WORDS] = { HCI_GET, HCI_ACCELEROMETER2, 0, 0, 0, 0 };\n\tu32 out[TCI_WORDS];\n\tacpi_status status;\n\n\tdev->accelerometer_supported = 0;\n\n\t \n\tstatus = tci_raw(dev, in, out);\n\tif (ACPI_FAILURE(status)) {\n\t\tpr_err(\"ACPI call to query the accelerometer failed\\n\");\n\t\treturn;\n\t}\n\n\tif (out[0] != TOS_SUCCESS)\n\t\treturn;\n\n\tdev->accelerometer_supported = 1;\n}\n\nstatic int toshiba_accelerometer_get(struct toshiba_acpi_dev *dev,\n\t\t\t\t     u32 *xy, u32 *z)\n{\n\tu32 in[TCI_WORDS] = { HCI_GET, HCI_ACCELEROMETER, 0, 1, 0, 0 };\n\tu32 out[TCI_WORDS];\n\tacpi_status status;\n\n\t \n\tstatus = tci_raw(dev, in, out);\n\tif (ACPI_FAILURE(status)) {\n\t\tpr_err(\"ACPI call to query the accelerometer failed\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (out[0] == TOS_NOT_SUPPORTED)\n\t\treturn -ENODEV;\n\n\tif (out[0] != TOS_SUCCESS)\n\t\treturn -EIO;\n\n\t*xy = out[2];\n\t*z = out[4];\n\n\treturn 0;\n}\n\n \nstatic void toshiba_usb_sleep_charge_available(struct toshiba_acpi_dev *dev)\n{\n\tu32 in[TCI_WORDS] = { SCI_GET, SCI_USB_SLEEP_CHARGE, 0, 0, 0, 0 };\n\tu32 out[TCI_WORDS];\n\tacpi_status status;\n\n\tdev->usb_sleep_charge_supported = 0;\n\n\tif (!sci_open(dev))\n\t\treturn;\n\n\tstatus = tci_raw(dev, in, out);\n\tif (ACPI_FAILURE(status)) {\n\t\tpr_err(\"ACPI call to get USB Sleep and Charge mode failed\\n\");\n\t\tsci_close(dev);\n\t\treturn;\n\t}\n\n\tif (out[0] != TOS_SUCCESS) {\n\t\tsci_close(dev);\n\t\treturn;\n\t}\n\n\tdev->usbsc_mode_base = out[4];\n\n\tin[5] = SCI_USB_CHARGE_BAT_LVL;\n\tstatus = tci_raw(dev, in, out);\n\tsci_close(dev);\n\tif (ACPI_FAILURE(status)) {\n\t\tpr_err(\"ACPI call to get USB Sleep and Charge mode failed\\n\");\n\t\treturn;\n\t}\n\n\tif (out[0] != TOS_SUCCESS)\n\t\treturn;\n\n\tdev->usbsc_bat_level = out[2];\n\t \n\tdev->usb_sleep_charge_supported = 1;\n}\n\nstatic int toshiba_usb_sleep_charge_get(struct toshiba_acpi_dev *dev,\n\t\t\t\t\tu32 *mode)\n{\n\tu32 result;\n\n\tif (!sci_open(dev))\n\t\treturn -EIO;\n\n\tresult = sci_read(dev, SCI_USB_SLEEP_CHARGE, mode);\n\tsci_close(dev);\n\tif (result == TOS_FAILURE)\n\t\tpr_err(\"ACPI call to set USB S&C mode failed\\n\");\n\telse if (result == TOS_NOT_SUPPORTED)\n\t\treturn -ENODEV;\n\n\treturn result == TOS_SUCCESS ? 0 : -EIO;\n}\n\nstatic int toshiba_usb_sleep_charge_set(struct toshiba_acpi_dev *dev,\n\t\t\t\t\tu32 mode)\n{\n\tu32 result;\n\n\tif (!sci_open(dev))\n\t\treturn -EIO;\n\n\tresult = sci_write(dev, SCI_USB_SLEEP_CHARGE, mode);\n\tsci_close(dev);\n\tif (result == TOS_FAILURE)\n\t\tpr_err(\"ACPI call to set USB S&C mode failed\\n\");\n\telse if (result == TOS_NOT_SUPPORTED)\n\t\treturn -ENODEV;\n\n\treturn result == TOS_SUCCESS ? 0 : -EIO;\n}\n\nstatic int toshiba_sleep_functions_status_get(struct toshiba_acpi_dev *dev,\n\t\t\t\t\t      u32 *mode)\n{\n\tu32 in[TCI_WORDS] = { SCI_GET, SCI_USB_SLEEP_CHARGE, 0, 0, 0, 0 };\n\tu32 out[TCI_WORDS];\n\tacpi_status status;\n\n\tif (!sci_open(dev))\n\t\treturn -EIO;\n\n\tin[5] = SCI_USB_CHARGE_BAT_LVL;\n\tstatus = tci_raw(dev, in, out);\n\tsci_close(dev);\n\tif (ACPI_FAILURE(status)) {\n\t\tpr_err(\"ACPI call to get USB S&C battery level failed\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (out[0] == TOS_NOT_SUPPORTED)\n\t\treturn -ENODEV;\n\n\tif (out[0] != TOS_SUCCESS)\n\t\treturn -EIO;\n\n\t*mode = out[2];\n\n\treturn 0;\n\n}\n\nstatic int toshiba_sleep_functions_status_set(struct toshiba_acpi_dev *dev,\n\t\t\t\t\t      u32 mode)\n{\n\tu32 in[TCI_WORDS] = { SCI_SET, SCI_USB_SLEEP_CHARGE, 0, 0, 0, 0 };\n\tu32 out[TCI_WORDS];\n\tacpi_status status;\n\n\tif (!sci_open(dev))\n\t\treturn -EIO;\n\n\tin[2] = mode;\n\tin[5] = SCI_USB_CHARGE_BAT_LVL;\n\tstatus = tci_raw(dev, in, out);\n\tsci_close(dev);\n\tif (ACPI_FAILURE(status)) {\n\t\tpr_err(\"ACPI call to set USB S&C battery level failed\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (out[0] == TOS_NOT_SUPPORTED)\n\t\treturn -ENODEV;\n\n\treturn out[0] == TOS_SUCCESS ? 0 : -EIO;\n}\n\nstatic int toshiba_usb_rapid_charge_get(struct toshiba_acpi_dev *dev,\n\t\t\t\t\tu32 *state)\n{\n\tu32 in[TCI_WORDS] = { SCI_GET, SCI_USB_SLEEP_CHARGE, 0, 0, 0, 0 };\n\tu32 out[TCI_WORDS];\n\tacpi_status status;\n\n\tif (!sci_open(dev))\n\t\treturn -EIO;\n\n\tin[5] = SCI_USB_CHARGE_RAPID_DSP;\n\tstatus = tci_raw(dev, in, out);\n\tsci_close(dev);\n\tif (ACPI_FAILURE(status)) {\n\t\tpr_err(\"ACPI call to get USB Rapid Charge failed\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (out[0] == TOS_NOT_SUPPORTED)\n\t\treturn -ENODEV;\n\n\tif (out[0] != TOS_SUCCESS && out[0] != TOS_SUCCESS2)\n\t\treturn -EIO;\n\n\t*state = out[2];\n\n\treturn 0;\n}\n\nstatic int toshiba_usb_rapid_charge_set(struct toshiba_acpi_dev *dev,\n\t\t\t\t\tu32 state)\n{\n\tu32 in[TCI_WORDS] = { SCI_SET, SCI_USB_SLEEP_CHARGE, 0, 0, 0, 0 };\n\tu32 out[TCI_WORDS];\n\tacpi_status status;\n\n\tif (!sci_open(dev))\n\t\treturn -EIO;\n\n\tin[2] = state;\n\tin[5] = SCI_USB_CHARGE_RAPID_DSP;\n\tstatus = tci_raw(dev, in, out);\n\tsci_close(dev);\n\tif (ACPI_FAILURE(status)) {\n\t\tpr_err(\"ACPI call to set USB Rapid Charge failed\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (out[0] == TOS_NOT_SUPPORTED)\n\t\treturn -ENODEV;\n\n\treturn (out[0] == TOS_SUCCESS || out[0] == TOS_SUCCESS2) ? 0 : -EIO;\n}\n\nstatic int toshiba_usb_sleep_music_get(struct toshiba_acpi_dev *dev, u32 *state)\n{\n\tu32 result;\n\n\tif (!sci_open(dev))\n\t\treturn -EIO;\n\n\tresult = sci_read(dev, SCI_USB_SLEEP_MUSIC, state);\n\tsci_close(dev);\n\tif (result == TOS_FAILURE)\n\t\tpr_err(\"ACPI call to get Sleep and Music failed\\n\");\n\telse if (result == TOS_NOT_SUPPORTED)\n\t\treturn -ENODEV;\n\n\treturn result == TOS_SUCCESS ? 0 : -EIO;\n}\n\nstatic int toshiba_usb_sleep_music_set(struct toshiba_acpi_dev *dev, u32 state)\n{\n\tu32 result;\n\n\tif (!sci_open(dev))\n\t\treturn -EIO;\n\n\tresult = sci_write(dev, SCI_USB_SLEEP_MUSIC, state);\n\tsci_close(dev);\n\tif (result == TOS_FAILURE)\n\t\tpr_err(\"ACPI call to set Sleep and Music failed\\n\");\n\telse if (result == TOS_NOT_SUPPORTED)\n\t\treturn -ENODEV;\n\n\treturn result == TOS_SUCCESS ? 0 : -EIO;\n}\n\n \nstatic int toshiba_function_keys_get(struct toshiba_acpi_dev *dev, u32 *mode)\n{\n\tu32 result;\n\n\tif (!sci_open(dev))\n\t\treturn -EIO;\n\n\tresult = sci_read(dev, SCI_KBD_FUNCTION_KEYS, mode);\n\tsci_close(dev);\n\tif (result == TOS_FAILURE)\n\t\tpr_err(\"ACPI call to get KBD function keys failed\\n\");\n\telse if (result == TOS_NOT_SUPPORTED)\n\t\treturn -ENODEV;\n\n\treturn (result == TOS_SUCCESS || result == TOS_SUCCESS2) ? 0 : -EIO;\n}\n\nstatic int toshiba_function_keys_set(struct toshiba_acpi_dev *dev, u32 mode)\n{\n\tu32 result;\n\n\tif (!sci_open(dev))\n\t\treturn -EIO;\n\n\tresult = sci_write(dev, SCI_KBD_FUNCTION_KEYS, mode);\n\tsci_close(dev);\n\tif (result == TOS_FAILURE)\n\t\tpr_err(\"ACPI call to set KBD function keys failed\\n\");\n\telse if (result == TOS_NOT_SUPPORTED)\n\t\treturn -ENODEV;\n\n\treturn (result == TOS_SUCCESS || result == TOS_SUCCESS2) ? 0 : -EIO;\n}\n\n \nstatic int toshiba_panel_power_on_get(struct toshiba_acpi_dev *dev, u32 *state)\n{\n\tu32 result;\n\n\tif (!sci_open(dev))\n\t\treturn -EIO;\n\n\tresult = sci_read(dev, SCI_PANEL_POWER_ON, state);\n\tsci_close(dev);\n\tif (result == TOS_FAILURE)\n\t\tpr_err(\"ACPI call to get Panel Power ON failed\\n\");\n\telse if (result == TOS_NOT_SUPPORTED)\n\t\treturn -ENODEV;\n\n\treturn result == TOS_SUCCESS ? 0 : -EIO;\n}\n\nstatic int toshiba_panel_power_on_set(struct toshiba_acpi_dev *dev, u32 state)\n{\n\tu32 result;\n\n\tif (!sci_open(dev))\n\t\treturn -EIO;\n\n\tresult = sci_write(dev, SCI_PANEL_POWER_ON, state);\n\tsci_close(dev);\n\tif (result == TOS_FAILURE)\n\t\tpr_err(\"ACPI call to set Panel Power ON failed\\n\");\n\telse if (result == TOS_NOT_SUPPORTED)\n\t\treturn -ENODEV;\n\n\treturn result == TOS_SUCCESS ? 0 : -EIO;\n}\n\n \nstatic int toshiba_usb_three_get(struct toshiba_acpi_dev *dev, u32 *state)\n{\n\tu32 result;\n\n\tif (!sci_open(dev))\n\t\treturn -EIO;\n\n\tresult = sci_read(dev, SCI_USB_THREE, state);\n\tsci_close(dev);\n\tif (result == TOS_FAILURE)\n\t\tpr_err(\"ACPI call to get USB 3 failed\\n\");\n\telse if (result == TOS_NOT_SUPPORTED)\n\t\treturn -ENODEV;\n\n\treturn (result == TOS_SUCCESS || result == TOS_SUCCESS2) ? 0 : -EIO;\n}\n\nstatic int toshiba_usb_three_set(struct toshiba_acpi_dev *dev, u32 state)\n{\n\tu32 result;\n\n\tif (!sci_open(dev))\n\t\treturn -EIO;\n\n\tresult = sci_write(dev, SCI_USB_THREE, state);\n\tsci_close(dev);\n\tif (result == TOS_FAILURE)\n\t\tpr_err(\"ACPI call to set USB 3 failed\\n\");\n\telse if (result == TOS_NOT_SUPPORTED)\n\t\treturn -ENODEV;\n\n\treturn (result == TOS_SUCCESS || result == TOS_SUCCESS2) ? 0 : -EIO;\n}\n\n \nstatic int toshiba_hotkey_event_type_get(struct toshiba_acpi_dev *dev,\n\t\t\t\t\t u32 *type)\n{\n\tu32 in[TCI_WORDS] = { HCI_GET, HCI_SYSTEM_INFO, 0x03, 0, 0, 0 };\n\tu32 out[TCI_WORDS];\n\tacpi_status status;\n\n\tstatus = tci_raw(dev, in, out);\n\tif (ACPI_FAILURE(status)) {\n\t\tpr_err(\"ACPI call to get System type failed\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (out[0] == TOS_NOT_SUPPORTED)\n\t\treturn -ENODEV;\n\n\tif (out[0] != TOS_SUCCESS)\n\t\treturn -EIO;\n\n\t*type = out[3];\n\n\treturn 0;\n}\n\n \nstatic int toshiba_wireless_status(struct toshiba_acpi_dev *dev)\n{\n\tu32 in[TCI_WORDS] = { HCI_GET, HCI_WIRELESS, 0, 0, 0, 0 };\n\tu32 out[TCI_WORDS];\n\tacpi_status status;\n\n\tin[3] = HCI_WIRELESS_STATUS;\n\tstatus = tci_raw(dev, in, out);\n\n\tif (ACPI_FAILURE(status)) {\n\t\tpr_err(\"ACPI call to get Wireless status failed\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (out[0] == TOS_NOT_SUPPORTED)\n\t\treturn -ENODEV;\n\n\tif (out[0] != TOS_SUCCESS)\n\t\treturn -EIO;\n\n\tdev->killswitch = !!(out[2] & HCI_WIRELESS_STATUS);\n\n\treturn 0;\n}\n\n \nstatic void toshiba_wwan_available(struct toshiba_acpi_dev *dev)\n{\n\tu32 in[TCI_WORDS] = { HCI_GET, HCI_WIRELESS, 0, 0, 0, 0 };\n\tu32 out[TCI_WORDS];\n\tacpi_status status;\n\n\tdev->wwan_supported = 0;\n\n\t \n\tin[3] = HCI_WIRELESS_WWAN;\n\tstatus = tci_raw(dev, in, out);\n\tif (ACPI_FAILURE(status)) {\n\t\tpr_err(\"ACPI call to get WWAN status failed\\n\");\n\t\treturn;\n\t}\n\n\tif (out[0] != TOS_SUCCESS)\n\t\treturn;\n\n\tdev->wwan_supported = (out[2] == HCI_WIRELESS_WWAN_STATUS);\n}\n\nstatic int toshiba_wwan_set(struct toshiba_acpi_dev *dev, u32 state)\n{\n\tu32 in[TCI_WORDS] = { HCI_SET, HCI_WIRELESS, state, 0, 0, 0 };\n\tu32 out[TCI_WORDS];\n\tacpi_status status;\n\n\tin[3] = HCI_WIRELESS_WWAN_STATUS;\n\tstatus = tci_raw(dev, in, out);\n\tif (ACPI_FAILURE(status)) {\n\t\tpr_err(\"ACPI call to set WWAN status failed\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (out[0] == TOS_NOT_SUPPORTED)\n\t\treturn -ENODEV;\n\n\tif (out[0] != TOS_SUCCESS)\n\t\treturn -EIO;\n\n\t \n\tin[3] = HCI_WIRELESS_WWAN_POWER;\n\tstatus = tci_raw(dev, in, out);\n\tif (ACPI_FAILURE(status)) {\n\t\tpr_err(\"ACPI call to set WWAN power failed\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (out[0] == TOS_NOT_SUPPORTED)\n\t\treturn -ENODEV;\n\n\treturn out[0] == TOS_SUCCESS ? 0 : -EIO;\n}\n\n \nstatic void toshiba_cooling_method_available(struct toshiba_acpi_dev *dev)\n{\n\tu32 in[TCI_WORDS] = { HCI_GET, HCI_COOLING_METHOD, 0, 0, 0, 0 };\n\tu32 out[TCI_WORDS];\n\tacpi_status status;\n\n\tdev->cooling_method_supported = 0;\n\tdev->max_cooling_method = 0;\n\n\tstatus = tci_raw(dev, in, out);\n\tif (ACPI_FAILURE(status)) {\n\t\tpr_err(\"ACPI call to get Cooling Method failed\\n\");\n\t\treturn;\n\t}\n\n\tif (out[0] != TOS_SUCCESS && out[0] != TOS_SUCCESS2)\n\t\treturn;\n\n\tdev->cooling_method_supported = 1;\n\tdev->max_cooling_method = out[3];\n}\n\nstatic int toshiba_cooling_method_get(struct toshiba_acpi_dev *dev, u32 *state)\n{\n\tu32 result = hci_read(dev, HCI_COOLING_METHOD, state);\n\n\tif (result == TOS_FAILURE)\n\t\tpr_err(\"ACPI call to get Cooling Method failed\\n\");\n\n\tif (result == TOS_NOT_SUPPORTED)\n\t\treturn -ENODEV;\n\n\treturn (result == TOS_SUCCESS || result == TOS_SUCCESS2) ? 0 : -EIO;\n}\n\nstatic int toshiba_cooling_method_set(struct toshiba_acpi_dev *dev, u32 state)\n{\n\tu32 result = hci_write(dev, HCI_COOLING_METHOD, state);\n\n\tif (result == TOS_FAILURE)\n\t\tpr_err(\"ACPI call to set Cooling Method failed\\n\");\n\n\tif (result == TOS_NOT_SUPPORTED)\n\t\treturn -ENODEV;\n\n\treturn (result == TOS_SUCCESS || result == TOS_SUCCESS2) ? 0 : -EIO;\n}\n\n \nstatic void toshiba_battery_charge_mode_available(struct toshiba_acpi_dev *dev)\n{\n\tu32 in[TCI_WORDS] = { HCI_GET, HCI_BATTERY_CHARGE_MODE, 0, 0, 0, 0 };\n\tu32 out[TCI_WORDS];\n\tacpi_status status;\n\n\tdev->battery_charge_mode_supported = 0;\n\n\tstatus = tci_raw(dev, in, out);\n\tif (ACPI_FAILURE(status)) {\n\t\tpr_err(\"ACPI call to get Battery Charge Mode failed\\n\");\n\t\treturn;\n\t}\n\n\tif (out[0] != TOS_SUCCESS && out[0] != TOS_SUCCESS2)\n\t\treturn;\n\n\tdev->battery_charge_mode_supported = 1;\n}\n\nstatic int toshiba_battery_charge_mode_get(struct toshiba_acpi_dev *dev, u32 *state)\n{\n\tu32 in[TCI_WORDS] = { HCI_GET, HCI_BATTERY_CHARGE_MODE, 0, 0, 0, 0x1 };\n\tu32 out[TCI_WORDS];\n\tint retries = 3;\n\n\tdo {\n\t\tacpi_status status = tci_raw(dev, in, out);\n\n\t\tif (ACPI_FAILURE(status))\n\t\t\tpr_err(\"ACPI call to get Battery Charge Mode failed\\n\");\n\t\tswitch (out[0]) {\n\t\tcase TOS_SUCCESS:\n\t\tcase TOS_SUCCESS2:\n\t\t\t*state = out[2];\n\t\t\treturn 0;\n\t\tcase TOS_NOT_SUPPORTED:\n\t\t\treturn -ENODEV;\n\t\tcase TOS_DATA_NOT_AVAILABLE:\n\t\t\tretries--;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EIO;\n\t\t}\n\t} while (retries);\n\n\treturn -EIO;\n}\n\nstatic int toshiba_battery_charge_mode_set(struct toshiba_acpi_dev *dev, u32 state)\n{\n\tu32 result = hci_write(dev, HCI_BATTERY_CHARGE_MODE, state);\n\n\tif (result == TOS_FAILURE)\n\t\tpr_err(\"ACPI call to set Battery Charge Mode failed\\n\");\n\n\tif (result == TOS_NOT_SUPPORTED)\n\t\treturn -ENODEV;\n\n\treturn (result == TOS_SUCCESS || result == TOS_SUCCESS2) ? 0 : -EIO;\n}\n\n \nstatic int get_tr_backlight_status(struct toshiba_acpi_dev *dev, u32 *status)\n{\n\tu32 result = hci_read(dev, HCI_TR_BACKLIGHT, status);\n\n\tif (result == TOS_FAILURE)\n\t\tpr_err(\"ACPI call to get Transflective Backlight failed\\n\");\n\telse if (result == TOS_NOT_SUPPORTED)\n\t\treturn -ENODEV;\n\n\treturn result == TOS_SUCCESS ? 0 : -EIO;\n}\n\nstatic int set_tr_backlight_status(struct toshiba_acpi_dev *dev, u32 status)\n{\n\tu32 result = hci_write(dev, HCI_TR_BACKLIGHT, !status);\n\n\tif (result == TOS_FAILURE)\n\t\tpr_err(\"ACPI call to set Transflective Backlight failed\\n\");\n\telse if (result == TOS_NOT_SUPPORTED)\n\t\treturn -ENODEV;\n\n\treturn result == TOS_SUCCESS ? 0 : -EIO;\n}\n\nstatic struct proc_dir_entry *toshiba_proc_dir;\n\n \nstatic int __get_lcd_brightness(struct toshiba_acpi_dev *dev)\n{\n\tint brightness = 0;\n\tu32 result;\n\tu32 value;\n\n\tif (dev->tr_backlight_supported) {\n\t\tint ret = get_tr_backlight_status(dev, &value);\n\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif (value)\n\t\t\treturn 0;\n\t\tbrightness++;\n\t}\n\n\tresult = hci_read(dev, HCI_LCD_BRIGHTNESS, &value);\n\tif (result == TOS_FAILURE)\n\t\tpr_err(\"ACPI call to get LCD Brightness failed\\n\");\n\telse if (result == TOS_NOT_SUPPORTED)\n\t\treturn -ENODEV;\n\n\treturn result == TOS_SUCCESS ?\n\t\t\tbrightness + (value >> HCI_LCD_BRIGHTNESS_SHIFT) :\n\t\t\t-EIO;\n}\n\nstatic int get_lcd_brightness(struct backlight_device *bd)\n{\n\tstruct toshiba_acpi_dev *dev = bl_get_data(bd);\n\n\treturn __get_lcd_brightness(dev);\n}\n\nstatic int lcd_proc_show(struct seq_file *m, void *v)\n{\n\tstruct toshiba_acpi_dev *dev = m->private;\n\tint levels;\n\tint value;\n\n\tif (!dev->backlight_dev)\n\t\treturn -ENODEV;\n\n\tlevels = dev->backlight_dev->props.max_brightness + 1;\n\tvalue = get_lcd_brightness(dev->backlight_dev);\n\tif (value < 0) {\n\t\tpr_err(\"Error reading LCD brightness\\n\");\n\t\treturn value;\n\t}\n\n\tseq_printf(m, \"brightness:              %d\\n\", value);\n\tseq_printf(m, \"brightness_levels:       %d\\n\", levels);\n\n\treturn 0;\n}\n\nstatic int lcd_proc_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, lcd_proc_show, pde_data(inode));\n}\n\nstatic int set_lcd_brightness(struct toshiba_acpi_dev *dev, int value)\n{\n\tu32 result;\n\n\tif (dev->tr_backlight_supported) {\n\t\tint ret = set_tr_backlight_status(dev, !value);\n\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif (value)\n\t\t\tvalue--;\n\t}\n\n\tvalue = value << HCI_LCD_BRIGHTNESS_SHIFT;\n\tresult = hci_write(dev, HCI_LCD_BRIGHTNESS, value);\n\tif (result == TOS_FAILURE)\n\t\tpr_err(\"ACPI call to set LCD Brightness failed\\n\");\n\telse if (result == TOS_NOT_SUPPORTED)\n\t\treturn -ENODEV;\n\n\treturn result == TOS_SUCCESS ? 0 : -EIO;\n}\n\nstatic int set_lcd_status(struct backlight_device *bd)\n{\n\tstruct toshiba_acpi_dev *dev = bl_get_data(bd);\n\n\treturn set_lcd_brightness(dev, bd->props.brightness);\n}\n\nstatic ssize_t lcd_proc_write(struct file *file, const char __user *buf,\n\t\t\t      size_t count, loff_t *pos)\n{\n\tstruct toshiba_acpi_dev *dev = pde_data(file_inode(file));\n\tchar cmd[42];\n\tsize_t len;\n\tint levels;\n\tint value;\n\n\tlen = min(count, sizeof(cmd) - 1);\n\tif (copy_from_user(cmd, buf, len))\n\t\treturn -EFAULT;\n\tcmd[len] = '\\0';\n\n\tlevels = dev->backlight_dev->props.max_brightness + 1;\n\tif (sscanf(cmd, \" brightness : %i\", &value) != 1 &&\n\t    value < 0 && value > levels)\n\t\treturn -EINVAL;\n\n\tif (set_lcd_brightness(dev, value))\n\t\treturn -EIO;\n\n\treturn count;\n}\n\nstatic const struct proc_ops lcd_proc_ops = {\n\t.proc_open\t= lcd_proc_open,\n\t.proc_read\t= seq_read,\n\t.proc_lseek\t= seq_lseek,\n\t.proc_release\t= single_release,\n\t.proc_write\t= lcd_proc_write,\n};\n\n \nstatic int get_video_status(struct toshiba_acpi_dev *dev, u32 *status)\n{\n\tu32 result = hci_read(dev, HCI_VIDEO_OUT, status);\n\n\tif (result == TOS_FAILURE)\n\t\tpr_err(\"ACPI call to get Video-Out failed\\n\");\n\telse if (result == TOS_NOT_SUPPORTED)\n\t\treturn -ENODEV;\n\n\treturn result == TOS_SUCCESS ? 0 : -EIO;\n}\n\nstatic int video_proc_show(struct seq_file *m, void *v)\n{\n\tstruct toshiba_acpi_dev *dev = m->private;\n\tint is_lcd, is_crt, is_tv;\n\tu32 value;\n\n\tif (get_video_status(dev, &value))\n\t\treturn -EIO;\n\n\tis_lcd = (value & HCI_VIDEO_OUT_LCD) ? 1 : 0;\n\tis_crt = (value & HCI_VIDEO_OUT_CRT) ? 1 : 0;\n\tis_tv = (value & HCI_VIDEO_OUT_TV) ? 1 : 0;\n\n\tseq_printf(m, \"lcd_out:                 %d\\n\", is_lcd);\n\tseq_printf(m, \"crt_out:                 %d\\n\", is_crt);\n\tseq_printf(m, \"tv_out:                  %d\\n\", is_tv);\n\n\treturn 0;\n}\n\nstatic int video_proc_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, video_proc_show, pde_data(inode));\n}\n\nstatic ssize_t video_proc_write(struct file *file, const char __user *buf,\n\t\t\t\tsize_t count, loff_t *pos)\n{\n\tstruct toshiba_acpi_dev *dev = pde_data(file_inode(file));\n\tchar *buffer;\n\tchar *cmd;\n\tint lcd_out = -1, crt_out = -1, tv_out = -1;\n\tint remain = count;\n\tint value;\n\tint ret;\n\tu32 video_out;\n\n\tcmd = memdup_user_nul(buf, count);\n\tif (IS_ERR(cmd))\n\t\treturn PTR_ERR(cmd);\n\n\tbuffer = cmd;\n\n\t \n\twhile (remain) {\n\t\tif (sscanf(buffer, \" lcd_out : %i\", &value) == 1)\n\t\t\tlcd_out = value & 1;\n\t\telse if (sscanf(buffer, \" crt_out : %i\", &value) == 1)\n\t\t\tcrt_out = value & 1;\n\t\telse if (sscanf(buffer, \" tv_out : %i\", &value) == 1)\n\t\t\ttv_out = value & 1;\n\t\t \n\t\tdo {\n\t\t\t++buffer;\n\t\t\t--remain;\n\t\t} while (remain && *(buffer - 1) != ';');\n\t}\n\n\tkfree(cmd);\n\n\tret = get_video_status(dev, &video_out);\n\tif (!ret) {\n\t\tunsigned int new_video_out = video_out;\n\n\t\tif (lcd_out != -1)\n\t\t\t_set_bit(&new_video_out, HCI_VIDEO_OUT_LCD, lcd_out);\n\t\tif (crt_out != -1)\n\t\t\t_set_bit(&new_video_out, HCI_VIDEO_OUT_CRT, crt_out);\n\t\tif (tv_out != -1)\n\t\t\t_set_bit(&new_video_out, HCI_VIDEO_OUT_TV, tv_out);\n\t\t \n\t\tif (new_video_out != video_out)\n\t\t\tret = write_acpi_int(METHOD_VIDEO_OUT, new_video_out);\n\t}\n\n\treturn ret ? -EIO : count;\n}\n\nstatic const struct proc_ops video_proc_ops = {\n\t.proc_open\t= video_proc_open,\n\t.proc_read\t= seq_read,\n\t.proc_lseek\t= seq_lseek,\n\t.proc_release\t= single_release,\n\t.proc_write\t= video_proc_write,\n};\n\n \nstatic int get_fan_status(struct toshiba_acpi_dev *dev, u32 *status)\n{\n\tu32 result = hci_read(dev, HCI_FAN, status);\n\n\tif (result == TOS_FAILURE)\n\t\tpr_err(\"ACPI call to get Fan status failed\\n\");\n\telse if (result == TOS_NOT_SUPPORTED)\n\t\treturn -ENODEV;\n\n\treturn result == TOS_SUCCESS ? 0 : -EIO;\n}\n\nstatic int set_fan_status(struct toshiba_acpi_dev *dev, u32 status)\n{\n\tu32 result = hci_write(dev, HCI_FAN, status);\n\n\tif (result == TOS_FAILURE)\n\t\tpr_err(\"ACPI call to set Fan status failed\\n\");\n\telse if (result == TOS_NOT_SUPPORTED)\n\t\treturn -ENODEV;\n\n\treturn result == TOS_SUCCESS ? 0 : -EIO;\n}\n\nstatic int fan_proc_show(struct seq_file *m, void *v)\n{\n\tstruct toshiba_acpi_dev *dev = m->private;\n\tu32 value;\n\n\tif (get_fan_status(dev, &value))\n\t\treturn -EIO;\n\n\tseq_printf(m, \"running:                 %d\\n\", (value > 0));\n\tseq_printf(m, \"force_on:                %d\\n\", dev->force_fan);\n\n\treturn 0;\n}\n\nstatic int fan_proc_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, fan_proc_show, pde_data(inode));\n}\n\nstatic ssize_t fan_proc_write(struct file *file, const char __user *buf,\n\t\t\t      size_t count, loff_t *pos)\n{\n\tstruct toshiba_acpi_dev *dev = pde_data(file_inode(file));\n\tchar cmd[42];\n\tsize_t len;\n\tint value;\n\n\tlen = min(count, sizeof(cmd) - 1);\n\tif (copy_from_user(cmd, buf, len))\n\t\treturn -EFAULT;\n\tcmd[len] = '\\0';\n\n\tif (sscanf(cmd, \" force_on : %i\", &value) != 1 &&\n\t    value != 0 && value != 1)\n\t\treturn -EINVAL;\n\n\tif (set_fan_status(dev, value))\n\t\treturn -EIO;\n\n\tdev->force_fan = value;\n\n\treturn count;\n}\n\nstatic const struct proc_ops fan_proc_ops = {\n\t.proc_open\t= fan_proc_open,\n\t.proc_read\t= seq_read,\n\t.proc_lseek\t= seq_lseek,\n\t.proc_release\t= single_release,\n\t.proc_write\t= fan_proc_write,\n};\n\n \nstatic int get_fan_rpm(struct toshiba_acpi_dev *dev, u32 *rpm)\n{\n\tu32 in[TCI_WORDS] = { HCI_GET, HCI_FAN_RPM, 0, 1, 0, 0 };\n\tu32 out[TCI_WORDS];\n\tacpi_status status = tci_raw(dev, in, out);\n\n\tif (ACPI_FAILURE(status)) {\n\t\tpr_err(\"ACPI call to get Fan speed failed\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (out[0] == TOS_NOT_SUPPORTED)\n\t\treturn -ENODEV;\n\n\tif (out[0] == TOS_SUCCESS) {\n\t\t*rpm = out[2];\n\t\treturn 0;\n\t}\n\n\treturn -EIO;\n}\n\nstatic int keys_proc_show(struct seq_file *m, void *v)\n{\n\tstruct toshiba_acpi_dev *dev = m->private;\n\n\tseq_printf(m, \"hotkey_ready:            %d\\n\", dev->key_event_valid);\n\tseq_printf(m, \"hotkey:                  0x%04x\\n\", dev->last_key_event);\n\n\treturn 0;\n}\n\nstatic int keys_proc_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, keys_proc_show, pde_data(inode));\n}\n\nstatic ssize_t keys_proc_write(struct file *file, const char __user *buf,\n\t\t\t       size_t count, loff_t *pos)\n{\n\tstruct toshiba_acpi_dev *dev = pde_data(file_inode(file));\n\tchar cmd[42];\n\tsize_t len;\n\tint value;\n\n\tlen = min(count, sizeof(cmd) - 1);\n\tif (copy_from_user(cmd, buf, len))\n\t\treturn -EFAULT;\n\tcmd[len] = '\\0';\n\n\tif (sscanf(cmd, \" hotkey_ready : %i\", &value) == 1 && value == 0)\n\t\tdev->key_event_valid = 0;\n\telse\n\t\treturn -EINVAL;\n\n\treturn count;\n}\n\nstatic const struct proc_ops keys_proc_ops = {\n\t.proc_open\t= keys_proc_open,\n\t.proc_read\t= seq_read,\n\t.proc_lseek\t= seq_lseek,\n\t.proc_release\t= single_release,\n\t.proc_write\t= keys_proc_write,\n};\n\nstatic int __maybe_unused version_proc_show(struct seq_file *m, void *v)\n{\n\tseq_printf(m, \"driver:                  %s\\n\", TOSHIBA_ACPI_VERSION);\n\tseq_printf(m, \"proc_interface:          %d\\n\", PROC_INTERFACE_VERSION);\n\treturn 0;\n}\n\n \n\n#define PROC_TOSHIBA\t\t\"toshiba\"\n\nstatic void create_toshiba_proc_entries(struct toshiba_acpi_dev *dev)\n{\n\tif (dev->backlight_dev)\n\t\tproc_create_data(\"lcd\", S_IRUGO | S_IWUSR, toshiba_proc_dir,\n\t\t\t\t &lcd_proc_ops, dev);\n\tif (dev->video_supported)\n\t\tproc_create_data(\"video\", S_IRUGO | S_IWUSR, toshiba_proc_dir,\n\t\t\t\t &video_proc_ops, dev);\n\tif (dev->fan_supported)\n\t\tproc_create_data(\"fan\", S_IRUGO | S_IWUSR, toshiba_proc_dir,\n\t\t\t\t &fan_proc_ops, dev);\n\tif (dev->hotkey_dev)\n\t\tproc_create_data(\"keys\", S_IRUGO | S_IWUSR, toshiba_proc_dir,\n\t\t\t\t &keys_proc_ops, dev);\n\tproc_create_single_data(\"version\", S_IRUGO, toshiba_proc_dir,\n\t\t\tversion_proc_show, dev);\n}\n\nstatic void remove_toshiba_proc_entries(struct toshiba_acpi_dev *dev)\n{\n\tif (dev->backlight_dev)\n\t\tremove_proc_entry(\"lcd\", toshiba_proc_dir);\n\tif (dev->video_supported)\n\t\tremove_proc_entry(\"video\", toshiba_proc_dir);\n\tif (dev->fan_supported)\n\t\tremove_proc_entry(\"fan\", toshiba_proc_dir);\n\tif (dev->hotkey_dev)\n\t\tremove_proc_entry(\"keys\", toshiba_proc_dir);\n\tremove_proc_entry(\"version\", toshiba_proc_dir);\n}\n\nstatic const struct backlight_ops toshiba_backlight_data = {\n\t.options = BL_CORE_SUSPENDRESUME,\n\t.get_brightness = get_lcd_brightness,\n\t.update_status  = set_lcd_status,\n};\n\n \nstatic void toshiba_acpi_kbd_bl_work(struct work_struct *work);\n\nstatic DECLARE_WORK(kbd_bl_work, toshiba_acpi_kbd_bl_work);\n\n \nstatic ssize_t version_show(struct device *dev,\n\t\t\t    struct device_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%s\\n\", TOSHIBA_ACPI_VERSION);\n}\nstatic DEVICE_ATTR_RO(version);\n\nstatic ssize_t fan_store(struct device *dev,\n\t\t\t struct device_attribute *attr,\n\t\t\t const char *buf, size_t count)\n{\n\tstruct toshiba_acpi_dev *toshiba = dev_get_drvdata(dev);\n\tint state;\n\tint ret;\n\n\tret = kstrtoint(buf, 0, &state);\n\tif (ret)\n\t\treturn ret;\n\n\tif (state != 0 && state != 1)\n\t\treturn -EINVAL;\n\n\tret = set_fan_status(toshiba, state);\n\tif (ret)\n\t\treturn ret;\n\n\treturn count;\n}\n\nstatic ssize_t fan_show(struct device *dev,\n\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct toshiba_acpi_dev *toshiba = dev_get_drvdata(dev);\n\tu32 value;\n\tint ret;\n\n\tret = get_fan_status(toshiba, &value);\n\tif (ret)\n\t\treturn ret;\n\n\treturn sprintf(buf, \"%d\\n\", value);\n}\nstatic DEVICE_ATTR_RW(fan);\n\nstatic ssize_t kbd_backlight_mode_store(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct toshiba_acpi_dev *toshiba = dev_get_drvdata(dev);\n\tint mode;\n\tint ret;\n\n\n\tret = kstrtoint(buf, 0, &mode);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (toshiba->kbd_type == 1) {\n\t\t \n\t\tif (mode != SCI_KBD_MODE_FNZ && mode != SCI_KBD_MODE_AUTO)\n\t\t\treturn -EINVAL;\n\t} else if (toshiba->kbd_type == 2) {\n\t\t \n\t\tif (mode != SCI_KBD_MODE_AUTO && mode != SCI_KBD_MODE_ON &&\n\t\t    mode != SCI_KBD_MODE_OFF)\n\t\t\treturn -EINVAL;\n\t}\n\n\t \n\n\t \n\tif (toshiba->kbd_mode != mode) {\n\t\t \n\t\tint time = toshiba->kbd_time << HCI_MISC_SHIFT;\n\n\t\t \n\t\tif (toshiba->kbd_type == 1) {\n\t\t\t \n\t\t\ttime |= toshiba->kbd_mode;\n\t\t} else if (toshiba->kbd_type == 2) {\n\t\t\t \n\t\t\ttime |= mode;\n\t\t}\n\n\t\tret = toshiba_kbd_illum_status_set(toshiba, time);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\ttoshiba->kbd_mode = mode;\n\t\ttoshiba_acpi->kbd_mode = mode;\n\n\t\t \n\t\tif (toshiba->kbd_type == 2 &&\n\t\t    !toshiba->kbd_event_generated)\n\t\t\tschedule_work(&kbd_bl_work);\n\t}\n\n\treturn count;\n}\n\nstatic ssize_t kbd_backlight_mode_show(struct device *dev,\n\t\t\t\t       struct device_attribute *attr,\n\t\t\t\t       char *buf)\n{\n\tstruct toshiba_acpi_dev *toshiba = dev_get_drvdata(dev);\n\tu32 time;\n\n\tif (toshiba_kbd_illum_status_get(toshiba, &time) < 0)\n\t\treturn -EIO;\n\n\treturn sprintf(buf, \"%i\\n\", time & SCI_KBD_MODE_MASK);\n}\nstatic DEVICE_ATTR_RW(kbd_backlight_mode);\n\nstatic ssize_t kbd_type_show(struct device *dev,\n\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct toshiba_acpi_dev *toshiba = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%d\\n\", toshiba->kbd_type);\n}\nstatic DEVICE_ATTR_RO(kbd_type);\n\nstatic ssize_t available_kbd_modes_show(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tstruct toshiba_acpi_dev *toshiba = dev_get_drvdata(dev);\n\n\tif (toshiba->kbd_type == 1)\n\t\treturn sprintf(buf, \"0x%x 0x%x\\n\",\n\t\t\t       SCI_KBD_MODE_FNZ, SCI_KBD_MODE_AUTO);\n\n\treturn sprintf(buf, \"0x%x 0x%x 0x%x\\n\",\n\t\t       SCI_KBD_MODE_AUTO, SCI_KBD_MODE_ON, SCI_KBD_MODE_OFF);\n}\nstatic DEVICE_ATTR_RO(available_kbd_modes);\n\nstatic ssize_t kbd_backlight_timeout_store(struct device *dev,\n\t\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t\t   const char *buf, size_t count)\n{\n\tstruct toshiba_acpi_dev *toshiba = dev_get_drvdata(dev);\n\tint time;\n\tint ret;\n\n\tret = kstrtoint(buf, 0, &time);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (toshiba->kbd_type == 1) {\n\t\tif (time < 0 || time > 60)\n\t\t\treturn -EINVAL;\n\t} else if (toshiba->kbd_type == 2) {\n\t\tif (time < 1 || time > 60)\n\t\t\treturn -EINVAL;\n\t}\n\n\t \n\n\t \n\tif (toshiba->kbd_time != time) {\n\t\t \n\t\ttime = time << HCI_MISC_SHIFT;\n\t\t \n\t\tif (toshiba->kbd_type == 1)\n\t\t\ttime |= SCI_KBD_MODE_FNZ;\n\t\telse if (toshiba->kbd_type == 2)\n\t\t\ttime |= SCI_KBD_MODE_AUTO;\n\n\t\tret = toshiba_kbd_illum_status_set(toshiba, time);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\ttoshiba->kbd_time = time >> HCI_MISC_SHIFT;\n\t}\n\n\treturn count;\n}\n\nstatic ssize_t kbd_backlight_timeout_show(struct device *dev,\n\t\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t\t  char *buf)\n{\n\tstruct toshiba_acpi_dev *toshiba = dev_get_drvdata(dev);\n\tu32 time;\n\n\tif (toshiba_kbd_illum_status_get(toshiba, &time) < 0)\n\t\treturn -EIO;\n\n\treturn sprintf(buf, \"%i\\n\", time >> HCI_MISC_SHIFT);\n}\nstatic DEVICE_ATTR_RW(kbd_backlight_timeout);\n\nstatic ssize_t touchpad_store(struct device *dev,\n\t\t\t      struct device_attribute *attr,\n\t\t\t      const char *buf, size_t count)\n{\n\tstruct toshiba_acpi_dev *toshiba = dev_get_drvdata(dev);\n\tint state;\n\tint ret;\n\n\t \n\tret = kstrtoint(buf, 0, &state);\n\tif (ret)\n\t\treturn ret;\n\tif (state != 0 && state != 1)\n\t\treturn -EINVAL;\n\n\tret = toshiba_touchpad_set(toshiba, state);\n\tif (ret)\n\t\treturn ret;\n\n\treturn count;\n}\n\nstatic ssize_t touchpad_show(struct device *dev,\n\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct toshiba_acpi_dev *toshiba = dev_get_drvdata(dev);\n\tu32 state;\n\tint ret;\n\n\tret = toshiba_touchpad_get(toshiba, &state);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn sprintf(buf, \"%i\\n\", state);\n}\nstatic DEVICE_ATTR_RW(touchpad);\n\nstatic ssize_t usb_sleep_charge_show(struct device *dev,\n\t\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct toshiba_acpi_dev *toshiba = dev_get_drvdata(dev);\n\tu32 mode;\n\tint ret;\n\n\tret = toshiba_usb_sleep_charge_get(toshiba, &mode);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn sprintf(buf, \"%x\\n\", mode & SCI_USB_CHARGE_MODE_MASK);\n}\n\nstatic ssize_t usb_sleep_charge_store(struct device *dev,\n\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t      const char *buf, size_t count)\n{\n\tstruct toshiba_acpi_dev *toshiba = dev_get_drvdata(dev);\n\tint state;\n\tu32 mode;\n\tint ret;\n\n\tret = kstrtoint(buf, 0, &state);\n\tif (ret)\n\t\treturn ret;\n\t \n\tif (state != 0 && state != 1 && state != 2 && state != 3)\n\t\treturn -EINVAL;\n\n\t \n\tmode = toshiba->usbsc_mode_base;\n\tif (state == 0)\n\t\tmode |= SCI_USB_CHARGE_DISABLED;\n\telse if (state == 1)\n\t\tmode |= SCI_USB_CHARGE_ALTERNATE;\n\telse if (state == 2)\n\t\tmode |= SCI_USB_CHARGE_AUTO;\n\telse if (state == 3)\n\t\tmode |= SCI_USB_CHARGE_TYPICAL;\n\n\tret = toshiba_usb_sleep_charge_set(toshiba, mode);\n\tif (ret)\n\t\treturn ret;\n\n\treturn count;\n}\nstatic DEVICE_ATTR_RW(usb_sleep_charge);\n\nstatic ssize_t sleep_functions_on_battery_show(struct device *dev,\n\t\t\t\t\t       struct device_attribute *attr,\n\t\t\t\t\t       char *buf)\n{\n\tstruct toshiba_acpi_dev *toshiba = dev_get_drvdata(dev);\n\tint bat_lvl, status;\n\tu32 state;\n\tint ret;\n\tint tmp;\n\n\tret = toshiba_sleep_functions_status_get(toshiba, &state);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\ttmp = state & SCI_USB_CHARGE_BAT_MASK;\n\tstatus = (tmp == 0x4) ? 1 : 0;\n\t \n\tbat_lvl = state >> HCI_MISC_SHIFT;\n\n\treturn sprintf(buf, \"%d %d\\n\", status, bat_lvl);\n}\n\nstatic ssize_t sleep_functions_on_battery_store(struct device *dev,\n\t\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct toshiba_acpi_dev *toshiba = dev_get_drvdata(dev);\n\tu32 status;\n\tint value;\n\tint ret;\n\tint tmp;\n\n\tret = kstrtoint(buf, 0, &value);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (value < 0 || value > 100)\n\t\treturn -EINVAL;\n\n\tif (value == 0) {\n\t\ttmp = toshiba->usbsc_bat_level << HCI_MISC_SHIFT;\n\t\tstatus = tmp | SCI_USB_CHARGE_BAT_LVL_OFF;\n\t} else {\n\t\ttmp = value << HCI_MISC_SHIFT;\n\t\tstatus = tmp | SCI_USB_CHARGE_BAT_LVL_ON;\n\t}\n\tret = toshiba_sleep_functions_status_set(toshiba, status);\n\tif (ret < 0)\n\t\treturn ret;\n\n\ttoshiba->usbsc_bat_level = status >> HCI_MISC_SHIFT;\n\n\treturn count;\n}\nstatic DEVICE_ATTR_RW(sleep_functions_on_battery);\n\nstatic ssize_t usb_rapid_charge_show(struct device *dev,\n\t\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct toshiba_acpi_dev *toshiba = dev_get_drvdata(dev);\n\tu32 state;\n\tint ret;\n\n\tret = toshiba_usb_rapid_charge_get(toshiba, &state);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn sprintf(buf, \"%d\\n\", state);\n}\n\nstatic ssize_t usb_rapid_charge_store(struct device *dev,\n\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t      const char *buf, size_t count)\n{\n\tstruct toshiba_acpi_dev *toshiba = dev_get_drvdata(dev);\n\tint state;\n\tint ret;\n\n\tret = kstrtoint(buf, 0, &state);\n\tif (ret)\n\t\treturn ret;\n\tif (state != 0 && state != 1)\n\t\treturn -EINVAL;\n\n\tret = toshiba_usb_rapid_charge_set(toshiba, state);\n\tif (ret)\n\t\treturn ret;\n\n\treturn count;\n}\nstatic DEVICE_ATTR_RW(usb_rapid_charge);\n\nstatic ssize_t usb_sleep_music_show(struct device *dev,\n\t\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct toshiba_acpi_dev *toshiba = dev_get_drvdata(dev);\n\tu32 state;\n\tint ret;\n\n\tret = toshiba_usb_sleep_music_get(toshiba, &state);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn sprintf(buf, \"%d\\n\", state);\n}\n\nstatic ssize_t usb_sleep_music_store(struct device *dev,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     const char *buf, size_t count)\n{\n\tstruct toshiba_acpi_dev *toshiba = dev_get_drvdata(dev);\n\tint state;\n\tint ret;\n\n\tret = kstrtoint(buf, 0, &state);\n\tif (ret)\n\t\treturn ret;\n\tif (state != 0 && state != 1)\n\t\treturn -EINVAL;\n\n\tret = toshiba_usb_sleep_music_set(toshiba, state);\n\tif (ret)\n\t\treturn ret;\n\n\treturn count;\n}\nstatic DEVICE_ATTR_RW(usb_sleep_music);\n\nstatic ssize_t kbd_function_keys_show(struct device *dev,\n\t\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tstruct toshiba_acpi_dev *toshiba = dev_get_drvdata(dev);\n\tint mode;\n\tint ret;\n\n\tret = toshiba_function_keys_get(toshiba, &mode);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn sprintf(buf, \"%d\\n\", mode);\n}\n\nstatic ssize_t kbd_function_keys_store(struct device *dev,\n\t\t\t\t       struct device_attribute *attr,\n\t\t\t\t       const char *buf, size_t count)\n{\n\tstruct toshiba_acpi_dev *toshiba = dev_get_drvdata(dev);\n\tint mode;\n\tint ret;\n\n\tret = kstrtoint(buf, 0, &mode);\n\tif (ret)\n\t\treturn ret;\n\t \n\tif (mode != 0 && mode != 1)\n\t\treturn -EINVAL;\n\n\tret = toshiba_function_keys_set(toshiba, mode);\n\tif (ret)\n\t\treturn ret;\n\n\tpr_info(\"Reboot for changes to KBD Function Keys to take effect\");\n\n\treturn count;\n}\nstatic DEVICE_ATTR_RW(kbd_function_keys);\n\nstatic ssize_t panel_power_on_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct toshiba_acpi_dev *toshiba = dev_get_drvdata(dev);\n\tu32 state;\n\tint ret;\n\n\tret = toshiba_panel_power_on_get(toshiba, &state);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn sprintf(buf, \"%d\\n\", state);\n}\n\nstatic ssize_t panel_power_on_store(struct device *dev,\n\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t    const char *buf, size_t count)\n{\n\tstruct toshiba_acpi_dev *toshiba = dev_get_drvdata(dev);\n\tint state;\n\tint ret;\n\n\tret = kstrtoint(buf, 0, &state);\n\tif (ret)\n\t\treturn ret;\n\tif (state != 0 && state != 1)\n\t\treturn -EINVAL;\n\n\tret = toshiba_panel_power_on_set(toshiba, state);\n\tif (ret)\n\t\treturn ret;\n\n\tpr_info(\"Reboot for changes to Panel Power ON to take effect\");\n\n\treturn count;\n}\nstatic DEVICE_ATTR_RW(panel_power_on);\n\nstatic ssize_t usb_three_show(struct device *dev,\n\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tstruct toshiba_acpi_dev *toshiba = dev_get_drvdata(dev);\n\tu32 state;\n\tint ret;\n\n\tret = toshiba_usb_three_get(toshiba, &state);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn sprintf(buf, \"%d\\n\", state);\n}\n\nstatic ssize_t usb_three_store(struct device *dev,\n\t\t\t       struct device_attribute *attr,\n\t\t\t       const char *buf, size_t count)\n{\n\tstruct toshiba_acpi_dev *toshiba = dev_get_drvdata(dev);\n\tint state;\n\tint ret;\n\n\tret = kstrtoint(buf, 0, &state);\n\tif (ret)\n\t\treturn ret;\n\t \n\tif (state != 0 && state != 1)\n\t\treturn -EINVAL;\n\n\tret = toshiba_usb_three_set(toshiba, state);\n\tif (ret)\n\t\treturn ret;\n\n\tpr_info(\"Reboot for changes to USB 3 to take effect\");\n\n\treturn count;\n}\nstatic DEVICE_ATTR_RW(usb_three);\n\nstatic ssize_t cooling_method_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct toshiba_acpi_dev *toshiba = dev_get_drvdata(dev);\n\tint state;\n\tint ret;\n\n\tret = toshiba_cooling_method_get(toshiba, &state);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn sprintf(buf, \"%d %d\\n\", state, toshiba->max_cooling_method);\n}\n\nstatic ssize_t cooling_method_store(struct device *dev,\n\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t    const char *buf, size_t count)\n{\n\tstruct toshiba_acpi_dev *toshiba = dev_get_drvdata(dev);\n\tint state;\n\tint ret;\n\n\tret = kstrtoint(buf, 0, &state);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (state < 0 || state > toshiba->max_cooling_method)\n\t\treturn -EINVAL;\n\n\tret = toshiba_cooling_method_set(toshiba, state);\n\tif (ret)\n\t\treturn ret;\n\n\treturn count;\n}\nstatic DEVICE_ATTR_RW(cooling_method);\n\nstatic struct attribute *toshiba_attributes[] = {\n\t&dev_attr_version.attr,\n\t&dev_attr_fan.attr,\n\t&dev_attr_kbd_backlight_mode.attr,\n\t&dev_attr_kbd_type.attr,\n\t&dev_attr_available_kbd_modes.attr,\n\t&dev_attr_kbd_backlight_timeout.attr,\n\t&dev_attr_touchpad.attr,\n\t&dev_attr_usb_sleep_charge.attr,\n\t&dev_attr_sleep_functions_on_battery.attr,\n\t&dev_attr_usb_rapid_charge.attr,\n\t&dev_attr_usb_sleep_music.attr,\n\t&dev_attr_kbd_function_keys.attr,\n\t&dev_attr_panel_power_on.attr,\n\t&dev_attr_usb_three.attr,\n\t&dev_attr_cooling_method.attr,\n\tNULL,\n};\n\nstatic umode_t toshiba_sysfs_is_visible(struct kobject *kobj,\n\t\t\t\t\tstruct attribute *attr, int idx)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct toshiba_acpi_dev *drv = dev_get_drvdata(dev);\n\tbool exists = true;\n\n\tif (attr == &dev_attr_fan.attr)\n\t\texists = (drv->fan_supported) ? true : false;\n\telse if (attr == &dev_attr_kbd_backlight_mode.attr)\n\t\texists = (drv->kbd_illum_supported) ? true : false;\n\telse if (attr == &dev_attr_kbd_backlight_timeout.attr)\n\t\texists = (drv->kbd_mode == SCI_KBD_MODE_AUTO) ? true : false;\n\telse if (attr == &dev_attr_touchpad.attr)\n\t\texists = (drv->touchpad_supported) ? true : false;\n\telse if (attr == &dev_attr_usb_sleep_charge.attr)\n\t\texists = (drv->usb_sleep_charge_supported) ? true : false;\n\telse if (attr == &dev_attr_sleep_functions_on_battery.attr)\n\t\texists = (drv->usb_sleep_charge_supported) ? true : false;\n\telse if (attr == &dev_attr_usb_rapid_charge.attr)\n\t\texists = (drv->usb_rapid_charge_supported) ? true : false;\n\telse if (attr == &dev_attr_usb_sleep_music.attr)\n\t\texists = (drv->usb_sleep_music_supported) ? true : false;\n\telse if (attr == &dev_attr_kbd_function_keys.attr)\n\t\texists = (drv->kbd_function_keys_supported) ? true : false;\n\telse if (attr == &dev_attr_panel_power_on.attr)\n\t\texists = (drv->panel_power_on_supported) ? true : false;\n\telse if (attr == &dev_attr_usb_three.attr)\n\t\texists = (drv->usb_three_supported) ? true : false;\n\telse if (attr == &dev_attr_cooling_method.attr)\n\t\texists = (drv->cooling_method_supported) ? true : false;\n\n\treturn exists ? attr->mode : 0;\n}\n\nstatic const struct attribute_group toshiba_attr_group = {\n\t.is_visible = toshiba_sysfs_is_visible,\n\t.attrs = toshiba_attributes,\n};\n\nstatic void toshiba_acpi_kbd_bl_work(struct work_struct *work)\n{\n\t \n\tif (sysfs_update_group(&toshiba_acpi->acpi_dev->dev.kobj,\n\t\t\t       &toshiba_attr_group))\n\t\tpr_err(\"Unable to update sysfs entries\\n\");\n\n\t \n\tif (toshiba_acpi->kbd_type == 2 &&\n\t    toshiba_acpi->kbd_mode != SCI_KBD_MODE_AUTO)\n\t\tled_classdev_notify_brightness_hw_changed(&toshiba_acpi->kbd_led,\n\t\t\t\t(toshiba_acpi->kbd_mode == SCI_KBD_MODE_ON) ?\n\t\t\t\tLED_FULL : LED_OFF);\n\n\t \n\tacpi_bus_generate_netlink_event(toshiba_acpi->acpi_dev->pnp.device_class,\n\t\t\t\t\tdev_name(&toshiba_acpi->acpi_dev->dev),\n\t\t\t\t\t0x92, 0);\n}\n\n \n\nenum toshiba_iio_accel_chan {\n\tAXIS_X,\n\tAXIS_Y,\n\tAXIS_Z\n};\n\nstatic int toshiba_iio_accel_get_axis(enum toshiba_iio_accel_chan chan)\n{\n\tu32 xyval, zval;\n\tint ret;\n\n\tret = toshiba_accelerometer_get(toshiba_acpi, &xyval, &zval);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tswitch (chan) {\n\tcase AXIS_X:\n\t\treturn xyval & HCI_ACCEL_DIRECTION_MASK ?\n\t\t\t-(xyval & HCI_ACCEL_MASK) : xyval & HCI_ACCEL_MASK;\n\tcase AXIS_Y:\n\t\treturn (xyval >> HCI_MISC_SHIFT) & HCI_ACCEL_DIRECTION_MASK ?\n\t\t\t-((xyval >> HCI_MISC_SHIFT) & HCI_ACCEL_MASK) :\n\t\t\t(xyval >> HCI_MISC_SHIFT) & HCI_ACCEL_MASK;\n\tcase AXIS_Z:\n\t\treturn zval & HCI_ACCEL_DIRECTION_MASK ?\n\t\t\t-(zval & HCI_ACCEL_MASK) : zval & HCI_ACCEL_MASK;\n\t}\n\n\treturn ret;\n}\n\nstatic int toshiba_iio_accel_read_raw(struct iio_dev *indio_dev,\n\t\t\t\t      struct iio_chan_spec const *chan,\n\t\t\t\t      int *val, int *val2, long mask)\n{\n\tint ret;\n\n\tswitch (mask) {\n\tcase IIO_CHAN_INFO_RAW:\n\t\tret = toshiba_iio_accel_get_axis(chan->channel);\n\t\tif (ret == -EIO || ret == -ENODEV)\n\t\t\treturn ret;\n\n\t\t*val = ret;\n\n\t\treturn IIO_VAL_INT;\n\t}\n\n\treturn -EINVAL;\n}\n\n#define TOSHIBA_IIO_ACCEL_CHANNEL(axis, chan) { \\\n\t.type = IIO_ACCEL, \\\n\t.modified = 1, \\\n\t.channel = chan, \\\n\t.channel2 = IIO_MOD_##axis, \\\n\t.output = 1, \\\n\t.info_mask_separate = BIT(IIO_CHAN_INFO_RAW), \\\n}\n\nstatic const struct iio_chan_spec toshiba_iio_accel_channels[] = {\n\tTOSHIBA_IIO_ACCEL_CHANNEL(X, AXIS_X),\n\tTOSHIBA_IIO_ACCEL_CHANNEL(Y, AXIS_Y),\n\tTOSHIBA_IIO_ACCEL_CHANNEL(Z, AXIS_Z),\n};\n\nstatic const struct iio_info toshiba_iio_accel_info = {\n\t.read_raw = &toshiba_iio_accel_read_raw,\n};\n\n \nstatic int toshiba_acpi_smm_bridge(SMMRegisters *regs)\n{\n\tu32 in[TCI_WORDS] = { regs->eax, regs->ebx, regs->ecx,\n\t\t\t      regs->edx, regs->esi, regs->edi };\n\tu32 out[TCI_WORDS];\n\tacpi_status status;\n\n\tstatus = tci_raw(toshiba_acpi, in, out);\n\tif (ACPI_FAILURE(status)) {\n\t\tpr_err(\"ACPI call to query SMM registers failed\\n\");\n\t\treturn -EIO;\n\t}\n\n\t \n\tregs->eax = out[0];\n\tregs->ebx = out[1];\n\tregs->ecx = out[2];\n\tregs->edx = out[3];\n\tregs->esi = out[4];\n\tregs->edi = out[5];\n\n\treturn 0;\n}\n\nstatic long toshiba_acpi_ioctl(struct file *fp, unsigned int cmd,\n\t\t\t       unsigned long arg)\n{\n\tSMMRegisters __user *argp = (SMMRegisters __user *)arg;\n\tSMMRegisters regs;\n\tint ret;\n\n\tif (!argp)\n\t\treturn -EINVAL;\n\n\tswitch (cmd) {\n\tcase TOSH_SMM:\n\t\tif (copy_from_user(&regs, argp, sizeof(SMMRegisters)))\n\t\t\treturn -EFAULT;\n\t\tret = toshiba_acpi_smm_bridge(&regs);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif (copy_to_user(argp, &regs, sizeof(SMMRegisters)))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\tcase TOSHIBA_ACPI_SCI:\n\t\tif (copy_from_user(&regs, argp, sizeof(SMMRegisters)))\n\t\t\treturn -EFAULT;\n\t\t \n\t\tif (regs.eax != SCI_GET && regs.eax != SCI_SET)\n\t\t\treturn -EINVAL;\n\t\tif (!sci_open(toshiba_acpi))\n\t\t\treturn -EIO;\n\t\tret = toshiba_acpi_smm_bridge(&regs);\n\t\tsci_close(toshiba_acpi);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif (copy_to_user(argp, &regs, sizeof(SMMRegisters)))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct file_operations toshiba_acpi_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.unlocked_ioctl = toshiba_acpi_ioctl,\n\t.llseek\t\t= noop_llseek,\n};\n\n \nstatic int toshiba_acpi_wwan_set_block(void *data, bool blocked)\n{\n\tstruct toshiba_acpi_dev *dev = data;\n\tint ret;\n\n\tret = toshiba_wireless_status(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!dev->killswitch)\n\t\treturn 0;\n\n\treturn toshiba_wwan_set(dev, !blocked);\n}\n\nstatic void toshiba_acpi_wwan_poll(struct rfkill *rfkill, void *data)\n{\n\tstruct toshiba_acpi_dev *dev = data;\n\n\tif (toshiba_wireless_status(dev))\n\t\treturn;\n\n\trfkill_set_hw_state(dev->wwan_rfk, !dev->killswitch);\n}\n\nstatic const struct rfkill_ops wwan_rfk_ops = {\n\t.set_block = toshiba_acpi_wwan_set_block,\n\t.poll = toshiba_acpi_wwan_poll,\n};\n\nstatic int toshiba_acpi_setup_wwan_rfkill(struct toshiba_acpi_dev *dev)\n{\n\tint ret = toshiba_wireless_status(dev);\n\n\tif (ret)\n\t\treturn ret;\n\n\tdev->wwan_rfk = rfkill_alloc(\"Toshiba WWAN\",\n\t\t\t\t     &dev->acpi_dev->dev,\n\t\t\t\t     RFKILL_TYPE_WWAN,\n\t\t\t\t     &wwan_rfk_ops,\n\t\t\t\t     dev);\n\tif (!dev->wwan_rfk) {\n\t\tpr_err(\"Unable to allocate WWAN rfkill device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\trfkill_set_hw_state(dev->wwan_rfk, !dev->killswitch);\n\n\tret = rfkill_register(dev->wwan_rfk);\n\tif (ret) {\n\t\tpr_err(\"Unable to register WWAN rfkill device\\n\");\n\t\trfkill_destroy(dev->wwan_rfk);\n\t}\n\n\treturn ret;\n}\n\n \nstatic int toshiba_acpi_enable_hotkeys(struct toshiba_acpi_dev *dev)\n{\n\tacpi_status status;\n\tu32 result;\n\n\tstatus = acpi_evaluate_object(dev->acpi_dev->handle,\n\t\t\t\t      \"ENAB\", NULL, NULL);\n\tif (ACPI_FAILURE(status))\n\t\treturn -ENODEV;\n\n\t \n\tif (dev->kbd_function_keys_supported && dev->special_functions)\n\t\tresult = hci_write(dev, HCI_HOTKEY_EVENT,\n\t\t\t\t   HCI_HOTKEY_SPECIAL_FUNCTIONS);\n\telse\n\t\tresult = hci_write(dev, HCI_HOTKEY_EVENT, HCI_HOTKEY_ENABLE);\n\n\tif (result == TOS_FAILURE)\n\t\treturn -EIO;\n\telse if (result == TOS_NOT_SUPPORTED)\n\t\treturn -ENODEV;\n\n\treturn 0;\n}\n\nstatic bool toshiba_acpi_i8042_filter(unsigned char data, unsigned char str,\n\t\t\t\t      struct serio *port)\n{\n\tif (str & I8042_STR_AUXDATA)\n\t\treturn false;\n\n\tif (unlikely(data == 0xe0))\n\t\treturn false;\n\n\tif ((data & 0x7f) == TOS1900_FN_SCAN) {\n\t\tschedule_work(&toshiba_acpi->hotkey_work);\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic void toshiba_acpi_hotkey_work(struct work_struct *work)\n{\n\tacpi_handle ec_handle = ec_get_handle();\n\tacpi_status status;\n\n\tif (!ec_handle)\n\t\treturn;\n\n\tstatus = acpi_evaluate_object(ec_handle, \"NTFY\", NULL, NULL);\n\tif (ACPI_FAILURE(status))\n\t\tpr_err(\"ACPI NTFY method execution failed\\n\");\n}\n\n \nstatic int toshiba_acpi_query_hotkey(struct toshiba_acpi_dev *dev)\n{\n\tunsigned long long value;\n\tacpi_status status;\n\n\tstatus = acpi_evaluate_integer(dev->acpi_dev->handle, \"INFO\",\n\t\t\t\t      NULL, &value);\n\tif (ACPI_FAILURE(status)) {\n\t\tpr_err(\"ACPI INFO method execution failed\\n\");\n\t\treturn -EIO;\n\t}\n\n\treturn value;\n}\n\nstatic void toshiba_acpi_report_hotkey(struct toshiba_acpi_dev *dev,\n\t\t\t\t       int scancode)\n{\n\tif (scancode == 0x100)\n\t\treturn;\n\n\t \n\tif (scancode & 0x80)\n\t\treturn;\n\n\tif (!sparse_keymap_report_event(dev->hotkey_dev, scancode, 1, true))\n\t\tpr_info(\"Unknown key %x\\n\", scancode);\n}\n\nstatic void toshiba_acpi_process_hotkeys(struct toshiba_acpi_dev *dev)\n{\n\tif (dev->info_supported) {\n\t\tint scancode = toshiba_acpi_query_hotkey(dev);\n\n\t\tif (scancode < 0) {\n\t\t\tpr_err(\"Failed to query hotkey event\\n\");\n\t\t} else if (scancode != 0) {\n\t\t\ttoshiba_acpi_report_hotkey(dev, scancode);\n\t\t\tdev->key_event_valid = 1;\n\t\t\tdev->last_key_event = scancode;\n\t\t}\n\t} else if (dev->system_event_supported) {\n\t\tu32 result;\n\t\tu32 value;\n\t\tint retries = 3;\n\n\t\tdo {\n\t\t\tresult = hci_read(dev, HCI_SYSTEM_EVENT, &value);\n\t\t\tswitch (result) {\n\t\t\tcase TOS_SUCCESS:\n\t\t\t\ttoshiba_acpi_report_hotkey(dev, (int)value);\n\t\t\t\tdev->key_event_valid = 1;\n\t\t\t\tdev->last_key_event = value;\n\t\t\t\tbreak;\n\t\t\tcase TOS_NOT_SUPPORTED:\n\t\t\t\t \n\t\t\t\tresult = hci_write(dev, HCI_SYSTEM_EVENT, 1);\n\t\t\t\tif (result == TOS_SUCCESS)\n\t\t\t\t\tpr_notice(\"Re-enabled hotkeys\\n\");\n\t\t\t\tfallthrough;\n\t\t\tdefault:\n\t\t\t\tretries--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (retries && result != TOS_FIFO_EMPTY);\n\t}\n}\n\nstatic int toshiba_acpi_setup_keyboard(struct toshiba_acpi_dev *dev)\n{\n\tconst struct key_entry *keymap = toshiba_acpi_keymap;\n\tacpi_handle ec_handle;\n\tint error;\n\n\tif (disable_hotkeys) {\n\t\tpr_info(\"Hotkeys disabled by module parameter\\n\");\n\t\treturn 0;\n\t}\n\n\tif (wmi_has_guid(TOSHIBA_WMI_EVENT_GUID)) {\n\t\tpr_info(\"WMI event detected, hotkeys will not be monitored\\n\");\n\t\treturn 0;\n\t}\n\n\terror = toshiba_acpi_enable_hotkeys(dev);\n\tif (error)\n\t\treturn error;\n\n\tif (toshiba_hotkey_event_type_get(dev, &dev->hotkey_event_type))\n\t\tpr_notice(\"Unable to query Hotkey Event Type\\n\");\n\n\tdev->hotkey_dev = input_allocate_device();\n\tif (!dev->hotkey_dev)\n\t\treturn -ENOMEM;\n\n\tdev->hotkey_dev->name = \"Toshiba input device\";\n\tdev->hotkey_dev->phys = \"toshiba_acpi/input0\";\n\tdev->hotkey_dev->id.bustype = BUS_HOST;\n\tdev->hotkey_dev->dev.parent = &dev->acpi_dev->dev;\n\n\tif (dev->hotkey_event_type == HCI_SYSTEM_TYPE1 ||\n\t    !dev->kbd_function_keys_supported)\n\t\tkeymap = toshiba_acpi_keymap;\n\telse if (dev->hotkey_event_type == HCI_SYSTEM_TYPE2 ||\n\t\t dev->kbd_function_keys_supported)\n\t\tkeymap = toshiba_acpi_alt_keymap;\n\telse\n\t\tpr_info(\"Unknown event type received %x\\n\",\n\t\t\tdev->hotkey_event_type);\n\terror = sparse_keymap_setup(dev->hotkey_dev, keymap, NULL);\n\tif (error)\n\t\tgoto err_free_dev;\n\n\t \n\tec_handle = ec_get_handle();\n\tif (ec_handle && acpi_has_method(ec_handle, \"NTFY\")) {\n\t\tINIT_WORK(&dev->hotkey_work, toshiba_acpi_hotkey_work);\n\n\t\terror = i8042_install_filter(toshiba_acpi_i8042_filter);\n\t\tif (error) {\n\t\t\tpr_err(\"Error installing key filter\\n\");\n\t\t\tgoto err_free_dev;\n\t\t}\n\n\t\tdev->ntfy_supported = 1;\n\t}\n\n\t \n\tif (acpi_has_method(dev->acpi_dev->handle, \"INFO\"))\n\t\tdev->info_supported = 1;\n\telse if (hci_write(dev, HCI_SYSTEM_EVENT, 1) == TOS_SUCCESS)\n\t\tdev->system_event_supported = 1;\n\n\tif (!dev->info_supported && !dev->system_event_supported) {\n\t\tpr_warn(\"No hotkey query interface found\\n\");\n\t\terror = -EINVAL;\n\t\tgoto err_remove_filter;\n\t}\n\n\terror = input_register_device(dev->hotkey_dev);\n\tif (error) {\n\t\tpr_info(\"Unable to register input device\\n\");\n\t\tgoto err_remove_filter;\n\t}\n\n\treturn 0;\n\n err_remove_filter:\n\tif (dev->ntfy_supported)\n\t\ti8042_remove_filter(toshiba_acpi_i8042_filter);\n err_free_dev:\n\tinput_free_device(dev->hotkey_dev);\n\tdev->hotkey_dev = NULL;\n\treturn error;\n}\n\nstatic int toshiba_acpi_setup_backlight(struct toshiba_acpi_dev *dev)\n{\n\tstruct backlight_properties props;\n\tint brightness;\n\tint ret;\n\n\t \n\tbrightness = __get_lcd_brightness(dev);\n\tif (brightness < 0)\n\t\treturn 0;\n\t \n\tif (dev->tr_backlight_supported && brightness == 0)\n\t\tbrightness++;\n\tret = set_lcd_brightness(dev, brightness);\n\tif (ret) {\n\t\tpr_debug(\"Backlight method is read-only, disabling backlight support\\n\");\n\t\treturn 0;\n\t}\n\n\tif (acpi_video_get_backlight_type() != acpi_backlight_vendor)\n\t\treturn 0;\n\n\tmemset(&props, 0, sizeof(props));\n\tprops.type = BACKLIGHT_PLATFORM;\n\tprops.max_brightness = HCI_LCD_BRIGHTNESS_LEVELS - 1;\n\n\t \n\tif (dev->tr_backlight_supported)\n\t\tprops.max_brightness++;\n\n\tdev->backlight_dev = backlight_device_register(\"toshiba\",\n\t\t\t\t\t\t       &dev->acpi_dev->dev,\n\t\t\t\t\t\t       dev,\n\t\t\t\t\t\t       &toshiba_backlight_data,\n\t\t\t\t\t\t       &props);\n\tif (IS_ERR(dev->backlight_dev)) {\n\t\tret = PTR_ERR(dev->backlight_dev);\n\t\tpr_err(\"Could not register toshiba backlight device\\n\");\n\t\tdev->backlight_dev = NULL;\n\t\treturn ret;\n\t}\n\n\tdev->backlight_dev->props.brightness = brightness;\n\treturn 0;\n}\n\n \n#if IS_ENABLED(CONFIG_HWMON)\nstatic umode_t toshiba_acpi_hwmon_is_visible(const void *drvdata,\n\t\t\t\t\t     enum hwmon_sensor_types type,\n\t\t\t\t\t     u32 attr, int channel)\n{\n\treturn 0444;\n}\n\nstatic int toshiba_acpi_hwmon_read(struct device *dev, enum hwmon_sensor_types type,\n\t\t\t\t   u32 attr, int channel, long *val)\n{\n\t \n\tif (type == hwmon_fan && channel == 0 && attr == hwmon_fan_input) {\n\t\tu32 value;\n\t\tint ret;\n\n\t\tret = get_fan_rpm(toshiba_acpi, &value);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t*val = value;\n\t\treturn 0;\n\t}\n\treturn -EOPNOTSUPP;\n}\n\nstatic const struct hwmon_channel_info * const toshiba_acpi_hwmon_info[] = {\n\tHWMON_CHANNEL_INFO(fan, HWMON_F_INPUT),\n\tNULL\n};\n\nstatic const struct hwmon_ops toshiba_acpi_hwmon_ops = {\n\t.is_visible = toshiba_acpi_hwmon_is_visible,\n\t.read = toshiba_acpi_hwmon_read,\n};\n\nstatic const struct hwmon_chip_info toshiba_acpi_hwmon_chip_info = {\n\t.ops = &toshiba_acpi_hwmon_ops,\n\t.info = toshiba_acpi_hwmon_info,\n};\n#endif\n\n \nstatic ssize_t charge_control_end_threshold_show(struct device *device,\n\t\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t\t char *buf)\n{\n\tu32 state;\n\tint status;\n\n\tif (toshiba_acpi == NULL) {\n\t\tpr_err(\"Toshiba ACPI object invalid\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tstatus = toshiba_battery_charge_mode_get(toshiba_acpi, &state);\n\n\tif (status != 0)\n\t\treturn status;\n\n\tif (state == 1)\n\t\treturn sprintf(buf, \"80\\n\");\n\telse\n\t\treturn sprintf(buf, \"100\\n\");\n}\n\nstatic ssize_t charge_control_end_threshold_store(struct device *dev,\n\t\t\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t\t\t  const char *buf,\n\t\t\t\t\t\t  size_t count)\n{\n\tu32 value;\n\tint rval;\n\n\tif (toshiba_acpi == NULL) {\n\t\tpr_err(\"Toshiba ACPI object invalid\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\trval = kstrtou32(buf, 10, &value);\n\tif (rval)\n\t\treturn rval;\n\n\tif (value < 1 || value > 100)\n\t\treturn -EINVAL;\n\trval = toshiba_battery_charge_mode_set(toshiba_acpi,\n\t\t\t\t\t       (value < 90) ? 1 : 0);\n\tif (rval < 0)\n\t\treturn rval;\n\telse\n\t\treturn count;\n}\n\nstatic DEVICE_ATTR_RW(charge_control_end_threshold);\n\nstatic struct attribute *toshiba_acpi_battery_attrs[] = {\n\t&dev_attr_charge_control_end_threshold.attr,\n\tNULL,\n};\n\nATTRIBUTE_GROUPS(toshiba_acpi_battery);\n\nstatic int toshiba_acpi_battery_add(struct power_supply *battery, struct acpi_battery_hook *hook)\n{\n\tif (toshiba_acpi == NULL) {\n\t\tpr_err(\"Init order issue\\n\");\n\t\treturn -ENODEV;\n\t}\n\tif (!toshiba_acpi->battery_charge_mode_supported)\n\t\treturn -ENODEV;\n\tif (device_add_groups(&battery->dev, toshiba_acpi_battery_groups))\n\t\treturn -ENODEV;\n\treturn 0;\n}\n\nstatic int toshiba_acpi_battery_remove(struct power_supply *battery, struct acpi_battery_hook *hook)\n{\n\tdevice_remove_groups(&battery->dev, toshiba_acpi_battery_groups);\n\treturn 0;\n}\n\nstatic struct acpi_battery_hook battery_hook = {\n\t.add_battery = toshiba_acpi_battery_add,\n\t.remove_battery = toshiba_acpi_battery_remove,\n\t.name = \"Toshiba Battery Extension\",\n};\n\nstatic void print_supported_features(struct toshiba_acpi_dev *dev)\n{\n\tpr_info(\"Supported laptop features:\");\n\n\tif (dev->hotkey_dev)\n\t\tpr_cont(\" hotkeys\");\n\tif (dev->backlight_dev)\n\t\tpr_cont(\" backlight\");\n\tif (dev->video_supported)\n\t\tpr_cont(\" video-out\");\n\tif (dev->fan_supported)\n\t\tpr_cont(\" fan\");\n\tif (dev->fan_rpm_supported)\n\t\tpr_cont(\" fan-rpm\");\n\tif (dev->tr_backlight_supported)\n\t\tpr_cont(\" transflective-backlight\");\n\tif (dev->illumination_supported)\n\t\tpr_cont(\" illumination\");\n\tif (dev->kbd_illum_supported)\n\t\tpr_cont(\" keyboard-backlight\");\n\tif (dev->touchpad_supported)\n\t\tpr_cont(\" touchpad\");\n\tif (dev->eco_supported)\n\t\tpr_cont(\" eco-led\");\n\tif (dev->accelerometer_supported)\n\t\tpr_cont(\" accelerometer-axes\");\n\tif (dev->usb_sleep_charge_supported)\n\t\tpr_cont(\" usb-sleep-charge\");\n\tif (dev->usb_rapid_charge_supported)\n\t\tpr_cont(\" usb-rapid-charge\");\n\tif (dev->usb_sleep_music_supported)\n\t\tpr_cont(\" usb-sleep-music\");\n\tif (dev->kbd_function_keys_supported)\n\t\tpr_cont(\" special-function-keys\");\n\tif (dev->panel_power_on_supported)\n\t\tpr_cont(\" panel-power-on\");\n\tif (dev->usb_three_supported)\n\t\tpr_cont(\" usb3\");\n\tif (dev->wwan_supported)\n\t\tpr_cont(\" wwan\");\n\tif (dev->cooling_method_supported)\n\t\tpr_cont(\" cooling-method\");\n\tif (dev->battery_charge_mode_supported)\n\t\tpr_cont(\" battery-charge-mode\");\n\n\tpr_cont(\"\\n\");\n}\n\nstatic void toshiba_acpi_remove(struct acpi_device *acpi_dev)\n{\n\tstruct toshiba_acpi_dev *dev = acpi_driver_data(acpi_dev);\n\n\tmisc_deregister(&dev->miscdev);\n\n\tremove_toshiba_proc_entries(dev);\n\n#if IS_ENABLED(CONFIG_HWMON)\n\tif (dev->hwmon_device)\n\t\thwmon_device_unregister(dev->hwmon_device);\n#endif\n\n\tif (dev->accelerometer_supported && dev->indio_dev) {\n\t\tiio_device_unregister(dev->indio_dev);\n\t\tiio_device_free(dev->indio_dev);\n\t}\n\n\tif (dev->sysfs_created)\n\t\tsysfs_remove_group(&dev->acpi_dev->dev.kobj,\n\t\t\t\t   &toshiba_attr_group);\n\n\tif (dev->ntfy_supported) {\n\t\ti8042_remove_filter(toshiba_acpi_i8042_filter);\n\t\tcancel_work_sync(&dev->hotkey_work);\n\t}\n\n\tif (dev->hotkey_dev)\n\t\tinput_unregister_device(dev->hotkey_dev);\n\n\tbacklight_device_unregister(dev->backlight_dev);\n\n\tled_classdev_unregister(&dev->led_dev);\n\tled_classdev_unregister(&dev->kbd_led);\n\tled_classdev_unregister(&dev->eco_led);\n\n\tif (dev->wwan_rfk) {\n\t\trfkill_unregister(dev->wwan_rfk);\n\t\trfkill_destroy(dev->wwan_rfk);\n\t}\n\n\tif (dev->battery_charge_mode_supported)\n\t\tbattery_hook_unregister(&battery_hook);\n\n\tif (toshiba_acpi)\n\t\ttoshiba_acpi = NULL;\n\n\tkfree(dev);\n}\n\nstatic const char *find_hci_method(acpi_handle handle)\n{\n\tif (acpi_has_method(handle, \"GHCI\"))\n\t\treturn \"GHCI\";\n\n\tif (acpi_has_method(handle, \"SPFC\"))\n\t\treturn \"SPFC\";\n\n\treturn NULL;\n}\n\n \nstatic const struct dmi_system_id turn_on_panel_on_resume_dmi_ids[] = {\n\t{\n\t  \n\t  \n\t  \n\t .matches = {\n\t\tDMI_MATCH(DMI_SYS_VENDOR, \"TOSHIBA\"),\n\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Z830\"),\n\t\t},\n\t},\n};\n\nstatic int toshiba_acpi_add(struct acpi_device *acpi_dev)\n{\n\tstruct toshiba_acpi_dev *dev;\n\tconst char *hci_method;\n\tu32 dummy;\n\tint ret = 0;\n\n\tif (toshiba_acpi)\n\t\treturn -EBUSY;\n\n\tpr_info(\"Toshiba Laptop ACPI Extras version %s\\n\",\n\t       TOSHIBA_ACPI_VERSION);\n\n\thci_method = find_hci_method(acpi_dev->handle);\n\tif (!hci_method) {\n\t\tpr_err(\"HCI interface not found\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\tdev->acpi_dev = acpi_dev;\n\tdev->method_hci = hci_method;\n\tdev->miscdev.minor = MISC_DYNAMIC_MINOR;\n\tdev->miscdev.name = \"toshiba_acpi\";\n\tdev->miscdev.fops = &toshiba_acpi_fops;\n\n\tret = misc_register(&dev->miscdev);\n\tif (ret) {\n\t\tpr_err(\"Failed to register miscdevice\\n\");\n\t\tkfree(dev);\n\t\treturn ret;\n\t}\n\n\tacpi_dev->driver_data = dev;\n\tdev_set_drvdata(&acpi_dev->dev, dev);\n\n\t \n\n\t \n\tret = toshiba_function_keys_get(dev, &dev->special_functions);\n\tdev->kbd_function_keys_supported = !ret;\n\n\tdev->hotkey_event_type = 0;\n\tif (toshiba_acpi_setup_keyboard(dev))\n\t\tpr_info(\"Unable to activate hotkeys\\n\");\n\n\t \n\tret = get_tr_backlight_status(dev, &dummy);\n\tdev->tr_backlight_supported = !ret;\n\n\tret = toshiba_acpi_setup_backlight(dev);\n\tif (ret)\n\t\tgoto error;\n\n\ttoshiba_illumination_available(dev);\n\tif (dev->illumination_supported) {\n\t\tdev->led_dev.name = \"toshiba::illumination\";\n\t\tdev->led_dev.max_brightness = 1;\n\t\tdev->led_dev.brightness_set = toshiba_illumination_set;\n\t\tdev->led_dev.brightness_get = toshiba_illumination_get;\n\t\tled_classdev_register(&acpi_dev->dev, &dev->led_dev);\n\t}\n\n\ttoshiba_eco_mode_available(dev);\n\tif (dev->eco_supported) {\n\t\tdev->eco_led.name = \"toshiba::eco_mode\";\n\t\tdev->eco_led.max_brightness = 1;\n\t\tdev->eco_led.brightness_set = toshiba_eco_mode_set_status;\n\t\tdev->eco_led.brightness_get = toshiba_eco_mode_get_status;\n\t\tled_classdev_register(&dev->acpi_dev->dev, &dev->eco_led);\n\t}\n\n\ttoshiba_kbd_illum_available(dev);\n\t \n\tif (dev->kbd_illum_supported &&\n\t    (dev->kbd_mode == SCI_KBD_MODE_FNZ || dev->kbd_type == 2)) {\n\t\tdev->kbd_led.name = \"toshiba::kbd_backlight\";\n\t\tdev->kbd_led.flags = LED_BRIGHT_HW_CHANGED;\n\t\tdev->kbd_led.max_brightness = 1;\n\t\tdev->kbd_led.brightness_set = toshiba_kbd_backlight_set;\n\t\tdev->kbd_led.brightness_get = toshiba_kbd_backlight_get;\n\t\tled_classdev_register(&dev->acpi_dev->dev, &dev->kbd_led);\n\t}\n\n\tret = toshiba_touchpad_get(dev, &dummy);\n\tdev->touchpad_supported = !ret;\n\n\ttoshiba_accelerometer_available(dev);\n\tif (dev->accelerometer_supported) {\n\t\tdev->indio_dev = iio_device_alloc(&acpi_dev->dev, sizeof(*dev));\n\t\tif (!dev->indio_dev) {\n\t\t\tpr_err(\"Unable to allocate iio device\\n\");\n\t\t\tgoto iio_error;\n\t\t}\n\n\t\tpr_info(\"Registering Toshiba accelerometer iio device\\n\");\n\n\t\tdev->indio_dev->info = &toshiba_iio_accel_info;\n\t\tdev->indio_dev->name = \"Toshiba accelerometer\";\n\t\tdev->indio_dev->modes = INDIO_DIRECT_MODE;\n\t\tdev->indio_dev->channels = toshiba_iio_accel_channels;\n\t\tdev->indio_dev->num_channels =\n\t\t\t\t\tARRAY_SIZE(toshiba_iio_accel_channels);\n\n\t\tret = iio_device_register(dev->indio_dev);\n\t\tif (ret < 0) {\n\t\t\tpr_err(\"Unable to register iio device\\n\");\n\t\t\tiio_device_free(dev->indio_dev);\n\t\t}\n\t}\niio_error:\n\n\ttoshiba_usb_sleep_charge_available(dev);\n\n\tret = toshiba_usb_rapid_charge_get(dev, &dummy);\n\tdev->usb_rapid_charge_supported = !ret;\n\n\tret = toshiba_usb_sleep_music_get(dev, &dummy);\n\tdev->usb_sleep_music_supported = !ret;\n\n\tret = toshiba_panel_power_on_get(dev, &dummy);\n\tdev->panel_power_on_supported = !ret;\n\n\tret = toshiba_usb_three_get(dev, &dummy);\n\tdev->usb_three_supported = !ret;\n\n\tret = get_video_status(dev, &dummy);\n\tdev->video_supported = !ret;\n\n\tret = get_fan_status(dev, &dummy);\n\tdev->fan_supported = !ret;\n\n\tret = get_fan_rpm(dev, &dummy);\n\tdev->fan_rpm_supported = !ret;\n\n#if IS_ENABLED(CONFIG_HWMON)\n\tif (dev->fan_rpm_supported) {\n\t\tdev->hwmon_device = hwmon_device_register_with_info(\n\t\t\t&dev->acpi_dev->dev, \"toshiba_acpi_sensors\", NULL,\n\t\t\t&toshiba_acpi_hwmon_chip_info, NULL);\n\t\tif (IS_ERR(dev->hwmon_device)) {\n\t\t\tdev->hwmon_device = NULL;\n\t\t\tpr_warn(\"unable to register hwmon device, skipping\\n\");\n\t\t}\n\t}\n#endif\n\n\tif (turn_on_panel_on_resume == -1)\n\t\tturn_on_panel_on_resume = dmi_check_system(turn_on_panel_on_resume_dmi_ids);\n\n\ttoshiba_wwan_available(dev);\n\tif (dev->wwan_supported)\n\t\ttoshiba_acpi_setup_wwan_rfkill(dev);\n\n\ttoshiba_cooling_method_available(dev);\n\n\ttoshiba_battery_charge_mode_available(dev);\n\n\tprint_supported_features(dev);\n\n\tret = sysfs_create_group(&dev->acpi_dev->dev.kobj,\n\t\t\t\t &toshiba_attr_group);\n\tif (ret) {\n\t\tdev->sysfs_created = 0;\n\t\tgoto error;\n\t}\n\tdev->sysfs_created = !ret;\n\n\tcreate_toshiba_proc_entries(dev);\n\n\ttoshiba_acpi = dev;\n\n\t \n\tif (dev->battery_charge_mode_supported)\n\t\tbattery_hook_register(&battery_hook);\n\n\treturn 0;\n\nerror:\n\ttoshiba_acpi_remove(acpi_dev);\n\treturn ret;\n}\n\nstatic void toshiba_acpi_notify(struct acpi_device *acpi_dev, u32 event)\n{\n\tstruct toshiba_acpi_dev *dev = acpi_driver_data(acpi_dev);\n\n\tswitch (event) {\n\tcase 0x80:  \n\t\t \n\t\tif (wmi_has_guid(TOSHIBA_WMI_EVENT_GUID))\n\t\t\treturn;\n\t\ttoshiba_acpi_process_hotkeys(dev);\n\t\tbreak;\n\tcase 0x81:  \n\tcase 0x82:\n\tcase 0x83:\n\t\tpr_info(\"Dock event received %x\\n\", event);\n\t\tbreak;\n\tcase 0x88:  \n\t\tpr_info(\"Thermal event received\\n\");\n\t\tbreak;\n\tcase 0x8f:  \n\tcase 0x90:  \n\t\tbreak;\n\tcase 0x8c:  \n\tcase 0x8b:\n\t\tpr_info(\"SATA power event received %x\\n\", event);\n\t\tbreak;\n\tcase 0x92:  \n\t\tdev->kbd_event_generated = true;\n\t\t \n\t\tif (sysfs_update_group(&acpi_dev->dev.kobj,\n\t\t\t\t       &toshiba_attr_group))\n\t\t\tpr_err(\"Unable to update sysfs entries\\n\");\n\t\t \n\t\tif (dev->kbd_type == 2 && dev->kbd_mode != SCI_KBD_MODE_AUTO)\n\t\t\tled_classdev_notify_brightness_hw_changed(&dev->kbd_led,\n\t\t\t\t\t(dev->kbd_mode == SCI_KBD_MODE_ON) ?\n\t\t\t\t\tLED_FULL : LED_OFF);\n\t\tbreak;\n\tcase 0x85:  \n\tcase 0x8d:  \n\tcase 0x8e:  \n\tcase 0x94:  \n\tcase 0x95:  \n\tdefault:\n\t\tpr_info(\"Unknown event received %x\\n\", event);\n\t\tbreak;\n\t}\n\n\tacpi_bus_generate_netlink_event(acpi_dev->pnp.device_class,\n\t\t\t\t\tdev_name(&acpi_dev->dev),\n\t\t\t\t\tevent, (event == 0x80) ?\n\t\t\t\t\tdev->last_key_event : 0);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int toshiba_acpi_suspend(struct device *device)\n{\n\tstruct toshiba_acpi_dev *dev = acpi_driver_data(to_acpi_device(device));\n\n\tif (dev->hotkey_dev) {\n\t\tu32 result;\n\n\t\tresult = hci_write(dev, HCI_HOTKEY_EVENT, HCI_HOTKEY_DISABLE);\n\t\tif (result != TOS_SUCCESS)\n\t\t\tpr_info(\"Unable to disable hotkeys\\n\");\n\t}\n\n\treturn 0;\n}\n\nstatic int toshiba_acpi_resume(struct device *device)\n{\n\tstruct toshiba_acpi_dev *dev = acpi_driver_data(to_acpi_device(device));\n\n\tif (dev->hotkey_dev) {\n\t\tif (toshiba_acpi_enable_hotkeys(dev))\n\t\t\tpr_info(\"Unable to re-enable hotkeys\\n\");\n\t}\n\n\tif (dev->wwan_rfk) {\n\t\tif (!toshiba_wireless_status(dev))\n\t\t\trfkill_set_hw_state(dev->wwan_rfk, !dev->killswitch);\n\t}\n\n\tif (turn_on_panel_on_resume)\n\t\thci_write(dev, HCI_PANEL_POWER_ON, 1);\n\n\treturn 0;\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(toshiba_acpi_pm,\n\t\t\t toshiba_acpi_suspend, toshiba_acpi_resume);\n\nstatic struct acpi_driver toshiba_acpi_driver = {\n\t.name\t= \"Toshiba ACPI driver\",\n\t.owner\t= THIS_MODULE,\n\t.ids\t= toshiba_device_ids,\n\t.flags\t= ACPI_DRIVER_ALL_NOTIFY_EVENTS,\n\t.ops\t= {\n\t\t.add\t\t= toshiba_acpi_add,\n\t\t.remove\t\t= toshiba_acpi_remove,\n\t\t.notify\t\t= toshiba_acpi_notify,\n\t},\n\t.drv.pm\t= &toshiba_acpi_pm,\n};\n\nstatic int __init toshiba_acpi_init(void)\n{\n\tint ret;\n\n\ttoshiba_proc_dir = proc_mkdir(PROC_TOSHIBA, acpi_root_dir);\n\tif (!toshiba_proc_dir) {\n\t\tpr_err(\"Unable to create proc dir \" PROC_TOSHIBA \"\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tret = acpi_bus_register_driver(&toshiba_acpi_driver);\n\tif (ret) {\n\t\tpr_err(\"Failed to register ACPI driver: %d\\n\", ret);\n\t\tremove_proc_entry(PROC_TOSHIBA, acpi_root_dir);\n\t}\n\n\treturn ret;\n}\n\nstatic void __exit toshiba_acpi_exit(void)\n{\n\tacpi_bus_unregister_driver(&toshiba_acpi_driver);\n\tif (toshiba_proc_dir)\n\t\tremove_proc_entry(PROC_TOSHIBA, acpi_root_dir);\n}\n\nmodule_init(toshiba_acpi_init);\nmodule_exit(toshiba_acpi_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}