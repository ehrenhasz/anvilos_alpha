{
  "module_name": "serial-multi-instantiate.c",
  "hash_id": "b2188b461e76a9693e020cbdd4bbd976af6b829ca5ea5b8a9163c5e844728368",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/x86/serial-multi-instantiate.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/bits.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/property.h>\n#include <linux/spi/spi.h>\n#include <linux/types.h>\n\n#define IRQ_RESOURCE_TYPE\tGENMASK(1, 0)\n#define IRQ_RESOURCE_NONE\t0\n#define IRQ_RESOURCE_GPIO\t1\n#define IRQ_RESOURCE_APIC\t2\n#define IRQ_RESOURCE_AUTO   3\n\nenum smi_bus_type {\n\tSMI_I2C,\n\tSMI_SPI,\n\tSMI_AUTO_DETECT,\n};\n\nstruct smi_instance {\n\tconst char *type;\n\tunsigned int flags;\n\tint irq_idx;\n};\n\nstruct smi_node {\n\tenum smi_bus_type bus_type;\n\tstruct smi_instance instances[];\n};\n\nstruct smi {\n\tint i2c_num;\n\tint spi_num;\n\tstruct i2c_client **i2c_devs;\n\tstruct spi_device **spi_devs;\n};\n\nstatic int smi_get_irq(struct platform_device *pdev, struct acpi_device *adev,\n\t\t       const struct smi_instance *inst)\n{\n\tint ret;\n\n\tswitch (inst->flags & IRQ_RESOURCE_TYPE) {\n\tcase IRQ_RESOURCE_AUTO:\n\t\tret = acpi_dev_gpio_irq_get(adev, inst->irq_idx);\n\t\tif (ret > 0) {\n\t\t\tdev_dbg(&pdev->dev, \"Using gpio irq\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tret = platform_get_irq(pdev, inst->irq_idx);\n\t\tif (ret > 0) {\n\t\t\tdev_dbg(&pdev->dev, \"Using platform irq\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase IRQ_RESOURCE_GPIO:\n\t\tret = acpi_dev_gpio_irq_get(adev, inst->irq_idx);\n\t\tbreak;\n\tcase IRQ_RESOURCE_APIC:\n\t\tret = platform_get_irq(pdev, inst->irq_idx);\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\tif (ret < 0)\n\t\treturn dev_err_probe(&pdev->dev, ret, \"Error requesting irq at index %d\\n\",\n\t\t\t\t     inst->irq_idx);\n\n\treturn ret;\n}\n\nstatic void smi_devs_unregister(struct smi *smi)\n{\n\twhile (smi->i2c_num--)\n\t\ti2c_unregister_device(smi->i2c_devs[smi->i2c_num]);\n\n\twhile (smi->spi_num--)\n\t\tspi_unregister_device(smi->spi_devs[smi->spi_num]);\n}\n\n \nstatic int smi_spi_probe(struct platform_device *pdev, struct smi *smi,\n\t\t\t const struct smi_instance *inst_array)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct acpi_device *adev = ACPI_COMPANION(dev);\n\tstruct spi_controller *ctlr;\n\tstruct spi_device *spi_dev;\n\tchar name[50];\n\tint i, ret, count;\n\n\tret = acpi_spi_count_resources(adev);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (!ret)\n\t\treturn -ENOENT;\n\n\tcount = ret;\n\n\tsmi->spi_devs = devm_kcalloc(dev, count, sizeof(*smi->spi_devs), GFP_KERNEL);\n\tif (!smi->spi_devs)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < count && inst_array[i].type; i++) {\n\n\t\tspi_dev = acpi_spi_device_alloc(NULL, adev, i);\n\t\tif (IS_ERR(spi_dev)) {\n\t\t\tret = dev_err_probe(dev, PTR_ERR(spi_dev), \"failed to allocate SPI device %s from ACPI\\n\",\n\t\t\t\t\t    dev_name(&adev->dev));\n\t\t\tgoto error;\n\t\t}\n\n\t\tctlr = spi_dev->controller;\n\n\t\tstrscpy(spi_dev->modalias, inst_array[i].type, sizeof(spi_dev->modalias));\n\n\t\tret = smi_get_irq(pdev, adev, &inst_array[i]);\n\t\tif (ret < 0) {\n\t\t\tspi_dev_put(spi_dev);\n\t\t\tgoto error;\n\t\t}\n\t\tspi_dev->irq = ret;\n\n\t\tsnprintf(name, sizeof(name), \"%s-%s-%s.%d\", dev_name(&ctlr->dev), dev_name(dev),\n\t\t\t inst_array[i].type, i);\n\t\tspi_dev->dev.init_name = name;\n\n\t\tret = spi_add_device(spi_dev);\n\t\tif (ret) {\n\t\t\tdev_err_probe(&ctlr->dev, ret, \"failed to add SPI device %s from ACPI\\n\",\n\t\t\t\t      dev_name(&adev->dev));\n\t\t\tspi_dev_put(spi_dev);\n\t\t\tgoto error;\n\t\t}\n\n\t\tdev_dbg(dev, \"SPI device %s using chip select %u\", name,\n\t\t\tspi_get_chipselect(spi_dev, 0));\n\n\t\tsmi->spi_devs[i] = spi_dev;\n\t\tsmi->spi_num++;\n\t}\n\n\tif (smi->spi_num < count) {\n\t\tdev_dbg(dev, \"Error finding driver, idx %d\\n\", i);\n\t\tret = -ENODEV;\n\t\tgoto error;\n\t}\n\n\tdev_info(dev, \"Instantiated %d SPI devices.\\n\", smi->spi_num);\n\n\treturn 0;\nerror:\n\tsmi_devs_unregister(smi);\n\n\treturn ret;\n}\n\n \nstatic int smi_i2c_probe(struct platform_device *pdev, struct smi *smi,\n\t\t\t const struct smi_instance *inst_array)\n{\n\tstruct i2c_board_info board_info = {};\n\tstruct device *dev = &pdev->dev;\n\tstruct acpi_device *adev = ACPI_COMPANION(dev);\n\tchar name[32];\n\tint i, ret, count;\n\n\tret = i2c_acpi_client_count(adev);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (!ret)\n\t\treturn -ENOENT;\n\n\tcount = ret;\n\n\tsmi->i2c_devs = devm_kcalloc(dev, count, sizeof(*smi->i2c_devs), GFP_KERNEL);\n\tif (!smi->i2c_devs)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < count && inst_array[i].type; i++) {\n\t\tmemset(&board_info, 0, sizeof(board_info));\n\t\tstrscpy(board_info.type, inst_array[i].type, I2C_NAME_SIZE);\n\t\tsnprintf(name, sizeof(name), \"%s-%s.%d\", dev_name(dev), inst_array[i].type, i);\n\t\tboard_info.dev_name = name;\n\n\t\tret = smi_get_irq(pdev, adev, &inst_array[i]);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t\tboard_info.irq = ret;\n\n\t\tsmi->i2c_devs[i] = i2c_acpi_new_device(dev, i, &board_info);\n\t\tif (IS_ERR(smi->i2c_devs[i])) {\n\t\t\tret = dev_err_probe(dev, PTR_ERR(smi->i2c_devs[i]),\n\t\t\t\t\t    \"Error creating i2c-client, idx %d\\n\", i);\n\t\t\tgoto error;\n\t\t}\n\t\tsmi->i2c_num++;\n\t}\n\tif (smi->i2c_num < count) {\n\t\tdev_dbg(dev, \"Error finding driver, idx %d\\n\", i);\n\t\tret = -ENODEV;\n\t\tgoto error;\n\t}\n\n\tdev_info(dev, \"Instantiated %d I2C devices.\\n\", smi->i2c_num);\n\n\treturn 0;\nerror:\n\tsmi_devs_unregister(smi);\n\n\treturn ret;\n}\n\nstatic int smi_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tconst struct smi_node *node;\n\tstruct smi *smi;\n\tint ret;\n\n\tnode = device_get_match_data(dev);\n\tif (!node) {\n\t\tdev_dbg(dev, \"Error ACPI match data is missing\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tsmi = devm_kzalloc(dev, sizeof(*smi), GFP_KERNEL);\n\tif (!smi)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, smi);\n\n\tswitch (node->bus_type) {\n\tcase SMI_I2C:\n\t\treturn smi_i2c_probe(pdev, smi, node->instances);\n\tcase SMI_SPI:\n\t\treturn smi_spi_probe(pdev, smi, node->instances);\n\tcase SMI_AUTO_DETECT:\n\t\t \n\t\tret = smi_i2c_probe(pdev, smi, node->instances);\n\t\tif (ret != -ENOENT)\n\t\t\treturn ret;\n\t\treturn smi_spi_probe(pdev, smi, node->instances);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic void smi_remove(struct platform_device *pdev)\n{\n\tstruct smi *smi = platform_get_drvdata(pdev);\n\n\tsmi_devs_unregister(smi);\n}\n\nstatic const struct smi_node bsg1160_data = {\n\t.instances = {\n\t\t{ \"bmc150_accel\", IRQ_RESOURCE_GPIO, 0 },\n\t\t{ \"bmc150_magn\" },\n\t\t{ \"bmg160\" },\n\t\t{}\n\t},\n\t.bus_type = SMI_I2C,\n};\n\nstatic const struct smi_node bsg2150_data = {\n\t.instances = {\n\t\t{ \"bmc150_accel\", IRQ_RESOURCE_GPIO, 0 },\n\t\t{ \"bmc150_magn\" },\n\t\t \n\t\t{ \"bsg2150_dummy_dev\" },\n\t\t{}\n\t},\n\t.bus_type = SMI_I2C,\n};\n\nstatic const struct smi_node int3515_data = {\n\t.instances = {\n\t\t{ \"tps6598x\", IRQ_RESOURCE_APIC, 0 },\n\t\t{ \"tps6598x\", IRQ_RESOURCE_APIC, 1 },\n\t\t{ \"tps6598x\", IRQ_RESOURCE_APIC, 2 },\n\t\t{ \"tps6598x\", IRQ_RESOURCE_APIC, 3 },\n\t\t{}\n\t},\n\t.bus_type = SMI_I2C,\n};\n\nstatic const struct smi_node cs35l41_hda = {\n\t.instances = {\n\t\t{ \"cs35l41-hda\", IRQ_RESOURCE_AUTO, 0 },\n\t\t{ \"cs35l41-hda\", IRQ_RESOURCE_AUTO, 0 },\n\t\t{ \"cs35l41-hda\", IRQ_RESOURCE_AUTO, 0 },\n\t\t{ \"cs35l41-hda\", IRQ_RESOURCE_AUTO, 0 },\n\t\t{}\n\t},\n\t.bus_type = SMI_AUTO_DETECT,\n};\n\nstatic const struct smi_node cs35l56_hda = {\n\t.instances = {\n\t\t{ \"cs35l56-hda\", IRQ_RESOURCE_AUTO, 0 },\n\t\t{ \"cs35l56-hda\", IRQ_RESOURCE_AUTO, 0 },\n\t\t{ \"cs35l56-hda\", IRQ_RESOURCE_AUTO, 0 },\n\t\t{ \"cs35l56-hda\", IRQ_RESOURCE_AUTO, 0 },\n\t\t \n\t\t{ \"cs35l56-hda_dummy_dev\" },\n\t\t{}\n\t},\n\t.bus_type = SMI_AUTO_DETECT,\n};\n\n \nstatic const struct acpi_device_id smi_acpi_ids[] = {\n\t{ \"BSG1160\", (unsigned long)&bsg1160_data },\n\t{ \"BSG2150\", (unsigned long)&bsg2150_data },\n\t{ \"CSC3551\", (unsigned long)&cs35l41_hda },\n\t{ \"CSC3556\", (unsigned long)&cs35l56_hda },\n\t{ \"INT3515\", (unsigned long)&int3515_data },\n\t \n\t{ \"CLSA0100\", (unsigned long)&cs35l41_hda },\n\t{ \"CLSA0101\", (unsigned long)&cs35l41_hda },\n\t{ }\n};\nMODULE_DEVICE_TABLE(acpi, smi_acpi_ids);\n\nstatic struct platform_driver smi_driver = {\n\t.driver\t= {\n\t\t.name = \"Serial bus multi instantiate pseudo device driver\",\n\t\t.acpi_match_table = smi_acpi_ids,\n\t},\n\t.probe = smi_probe,\n\t.remove_new = smi_remove,\n};\nmodule_platform_driver(smi_driver);\n\nMODULE_DESCRIPTION(\"Serial multi instantiate pseudo device driver\");\nMODULE_AUTHOR(\"Hans de Goede <hdegoede@redhat.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}