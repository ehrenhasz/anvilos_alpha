{
  "module_name": "dcdbas.c",
  "hash_id": "d179556660ec31c6bbe52edd22cce1a156522d45778dd517d6dc93aaa77272b6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/x86/dell/dcdbas.c",
  "human_readable_source": "\n \n\n#include <linux/platform_device.h>\n#include <linux/acpi.h>\n#include <linux/dma-mapping.h>\n#include <linux/dmi.h>\n#include <linux/errno.h>\n#include <linux/cpu.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/mc146818rtc.h>\n#include <linux/module.h>\n#include <linux/reboot.h>\n#include <linux/sched.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n\n#include \"dcdbas.h\"\n\n#define DRIVER_NAME\t\t\"dcdbas\"\n#define DRIVER_VERSION\t\t\"5.6.0-3.4\"\n#define DRIVER_DESCRIPTION\t\"Dell Systems Management Base Driver\"\n\nstatic struct platform_device *dcdbas_pdev;\n\nstatic unsigned long max_smi_data_buf_size = MAX_SMI_DATA_BUF_SIZE;\nstatic DEFINE_MUTEX(smi_data_lock);\nstatic u8 *bios_buffer;\nstatic struct smi_buffer smi_buf;\n\nstatic unsigned int host_control_action;\nstatic unsigned int host_control_smi_type;\nstatic unsigned int host_control_on_shutdown;\n\nstatic bool wsmt_enabled;\n\nint dcdbas_smi_alloc(struct smi_buffer *smi_buffer, unsigned long size)\n{\n\tsmi_buffer->virt = dma_alloc_coherent(&dcdbas_pdev->dev, size,\n\t\t\t\t\t      &smi_buffer->dma, GFP_KERNEL);\n\tif (!smi_buffer->virt) {\n\t\tdev_dbg(&dcdbas_pdev->dev,\n\t\t\t\"%s: failed to allocate memory size %lu\\n\",\n\t\t\t__func__, size);\n\t\treturn -ENOMEM;\n\t}\n\tsmi_buffer->size = size;\n\n\tdev_dbg(&dcdbas_pdev->dev, \"%s: phys: %x size: %lu\\n\",\n\t\t__func__, (u32)smi_buffer->dma, smi_buffer->size);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(dcdbas_smi_alloc);\n\nvoid dcdbas_smi_free(struct smi_buffer *smi_buffer)\n{\n\tif (!smi_buffer->virt)\n\t\treturn;\n\n\tdev_dbg(&dcdbas_pdev->dev, \"%s: phys: %x size: %lu\\n\",\n\t\t__func__, (u32)smi_buffer->dma, smi_buffer->size);\n\tdma_free_coherent(&dcdbas_pdev->dev, smi_buffer->size,\n\t\t\t  smi_buffer->virt, smi_buffer->dma);\n\tsmi_buffer->virt = NULL;\n\tsmi_buffer->dma = 0;\n\tsmi_buffer->size = 0;\n}\nEXPORT_SYMBOL_GPL(dcdbas_smi_free);\n\n \nstatic void smi_data_buf_free(void)\n{\n\tif (!smi_buf.virt || wsmt_enabled)\n\t\treturn;\n\n\tdcdbas_smi_free(&smi_buf);\n}\n\n \nstatic int smi_data_buf_realloc(unsigned long size)\n{\n\tstruct smi_buffer tmp;\n\tint ret;\n\n\tif (smi_buf.size >= size)\n\t\treturn 0;\n\n\tif (size > max_smi_data_buf_size)\n\t\treturn -EINVAL;\n\n\t \n\tret = dcdbas_smi_alloc(&tmp, size);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (smi_buf.virt)\n\t\tmemcpy(tmp.virt, smi_buf.virt, smi_buf.size);\n\n\t \n\tsmi_data_buf_free();\n\n\t \n\tsmi_buf = tmp;\n\n\treturn 0;\n}\n\nstatic ssize_t smi_data_buf_phys_addr_show(struct device *dev,\n\t\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t\t   char *buf)\n{\n\treturn sprintf(buf, \"%x\\n\", (u32)smi_buf.dma);\n}\n\nstatic ssize_t smi_data_buf_size_show(struct device *dev,\n\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t      char *buf)\n{\n\treturn sprintf(buf, \"%lu\\n\", smi_buf.size);\n}\n\nstatic ssize_t smi_data_buf_size_store(struct device *dev,\n\t\t\t\t       struct device_attribute *attr,\n\t\t\t\t       const char *buf, size_t count)\n{\n\tunsigned long buf_size;\n\tssize_t ret;\n\n\tbuf_size = simple_strtoul(buf, NULL, 10);\n\n\t \n\tmutex_lock(&smi_data_lock);\n\tret = smi_data_buf_realloc(buf_size);\n\tmutex_unlock(&smi_data_lock);\n\tif (ret)\n\t\treturn ret;\n\n\treturn count;\n}\n\nstatic ssize_t smi_data_read(struct file *filp, struct kobject *kobj,\n\t\t\t     struct bin_attribute *bin_attr,\n\t\t\t     char *buf, loff_t pos, size_t count)\n{\n\tssize_t ret;\n\n\tmutex_lock(&smi_data_lock);\n\tret = memory_read_from_buffer(buf, count, &pos, smi_buf.virt,\n\t\t\t\t\tsmi_buf.size);\n\tmutex_unlock(&smi_data_lock);\n\treturn ret;\n}\n\nstatic ssize_t smi_data_write(struct file *filp, struct kobject *kobj,\n\t\t\t      struct bin_attribute *bin_attr,\n\t\t\t      char *buf, loff_t pos, size_t count)\n{\n\tssize_t ret;\n\n\tif ((pos + count) > max_smi_data_buf_size)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&smi_data_lock);\n\n\tret = smi_data_buf_realloc(pos + count);\n\tif (ret)\n\t\tgoto out;\n\n\tmemcpy(smi_buf.virt + pos, buf, count);\n\tret = count;\nout:\n\tmutex_unlock(&smi_data_lock);\n\treturn ret;\n}\n\nstatic ssize_t host_control_action_show(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\treturn sprintf(buf, \"%u\\n\", host_control_action);\n}\n\nstatic ssize_t host_control_action_store(struct device *dev,\n\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t const char *buf, size_t count)\n{\n\tssize_t ret;\n\n\t \n\tmutex_lock(&smi_data_lock);\n\tret = smi_data_buf_realloc(sizeof(struct apm_cmd));\n\tmutex_unlock(&smi_data_lock);\n\tif (ret)\n\t\treturn ret;\n\n\thost_control_action = simple_strtoul(buf, NULL, 10);\n\treturn count;\n}\n\nstatic ssize_t host_control_smi_type_show(struct device *dev,\n\t\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t\t  char *buf)\n{\n\treturn sprintf(buf, \"%u\\n\", host_control_smi_type);\n}\n\nstatic ssize_t host_control_smi_type_store(struct device *dev,\n\t\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t\t   const char *buf, size_t count)\n{\n\thost_control_smi_type = simple_strtoul(buf, NULL, 10);\n\treturn count;\n}\n\nstatic ssize_t host_control_on_shutdown_show(struct device *dev,\n\t\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t\t     char *buf)\n{\n\treturn sprintf(buf, \"%u\\n\", host_control_on_shutdown);\n}\n\nstatic ssize_t host_control_on_shutdown_store(struct device *dev,\n\t\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t\t      const char *buf, size_t count)\n{\n\thost_control_on_shutdown = simple_strtoul(buf, NULL, 10);\n\treturn count;\n}\n\nstatic int raise_smi(void *par)\n{\n\tstruct smi_cmd *smi_cmd = par;\n\n\tif (smp_processor_id() != 0) {\n\t\tdev_dbg(&dcdbas_pdev->dev, \"%s: failed to get CPU 0\\n\",\n\t\t\t__func__);\n\t\treturn -EBUSY;\n\t}\n\n\t \n\t \n\tasm volatile (\n\t\t\"outb %b0,%w1\\n\"\n\t\t\"inb %w1\"\n\t\t:  \n\t\t: \"a\" (smi_cmd->command_code),\n\t\t  \"d\" (smi_cmd->command_address),\n\t\t  \"b\" (smi_cmd->ebx),\n\t\t  \"c\" (smi_cmd->ecx)\n\t\t: \"memory\"\n\t);\n\n\treturn 0;\n}\n \nint dcdbas_smi_request(struct smi_cmd *smi_cmd)\n{\n\tint ret;\n\n\tif (smi_cmd->magic != SMI_CMD_MAGIC) {\n\t\tdev_info(&dcdbas_pdev->dev, \"%s: invalid magic value\\n\",\n\t\t\t __func__);\n\t\treturn -EBADR;\n\t}\n\n\t \n\tcpus_read_lock();\n\tret = smp_call_on_cpu(0, raise_smi, smi_cmd, true);\n\tcpus_read_unlock();\n\n\treturn ret;\n}\nEXPORT_SYMBOL(dcdbas_smi_request);\n\n \nstatic ssize_t smi_request_store(struct device *dev,\n\t\t\t\t struct device_attribute *attr,\n\t\t\t\t const char *buf, size_t count)\n{\n\tstruct smi_cmd *smi_cmd;\n\tunsigned long val = simple_strtoul(buf, NULL, 10);\n\tssize_t ret;\n\n\tmutex_lock(&smi_data_lock);\n\n\tif (smi_buf.size < sizeof(struct smi_cmd)) {\n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\tsmi_cmd = (struct smi_cmd *)smi_buf.virt;\n\n\tswitch (val) {\n\tcase 2:\n\t\t \n\t\tret = dcdbas_smi_request(smi_cmd);\n\t\tif (!ret)\n\t\t\tret = count;\n\t\tbreak;\n\tcase 1:\n\t\t \n\t\tsmi_cmd->ebx = (u32)smi_buf.dma +\n\t\t\t\toffsetof(struct smi_cmd, command_buffer);\n\t\tret = dcdbas_smi_request(smi_cmd);\n\t\tif (!ret)\n\t\t\tret = count;\n\t\tbreak;\n\tcase 0:\n\t\tmemset(smi_buf.virt, 0, smi_buf.size);\n\t\tret = count;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\nout:\n\tmutex_unlock(&smi_data_lock);\n\treturn ret;\n}\n\n \nstatic int host_control_smi(void)\n{\n\tstruct apm_cmd *apm_cmd;\n\tu8 *data;\n\tunsigned long flags;\n\tu32 num_ticks;\n\ts8 cmd_status;\n\tu8 index;\n\n\tapm_cmd = (struct apm_cmd *)smi_buf.virt;\n\tapm_cmd->status = ESM_STATUS_CMD_UNSUCCESSFUL;\n\n\tswitch (host_control_smi_type) {\n\tcase HC_SMITYPE_TYPE1:\n\t\tspin_lock_irqsave(&rtc_lock, flags);\n\t\t \n\t\tdata = (u8 *)&smi_buf.dma;\n\t\tfor (index = PE1300_CMOS_CMD_STRUCT_PTR;\n\t\t     index < (PE1300_CMOS_CMD_STRUCT_PTR + 4);\n\t\t     index++, data++) {\n\t\t\toutb(index,\n\t\t\t     (CMOS_BASE_PORT + CMOS_PAGE2_INDEX_PORT_PIIX4));\n\t\t\toutb(*data,\n\t\t\t     (CMOS_BASE_PORT + CMOS_PAGE2_DATA_PORT_PIIX4));\n\t\t}\n\n\t\t \n\t\tcmd_status = ESM_STATUS_CMD_UNSUCCESSFUL;\n\t\toutb((u8) cmd_status, PCAT_APM_STATUS_PORT);\n\n\t\t \n\t\toutb(ESM_APM_CMD, PCAT_APM_CONTROL_PORT);\n\t\tspin_unlock_irqrestore(&rtc_lock, flags);\n\n\t\t \n\t\tnum_ticks = TIMEOUT_USEC_SHORT_SEMA_BLOCKING;\n\t\twhile ((s8)inb(PCAT_APM_STATUS_PORT) == ESM_STATUS_CMD_UNSUCCESSFUL) {\n\t\t\tnum_ticks--;\n\t\t\tif (num_ticks == EXPIRED_TIMER)\n\t\t\t\treturn -ETIME;\n\t\t}\n\t\tbreak;\n\n\tcase HC_SMITYPE_TYPE2:\n\tcase HC_SMITYPE_TYPE3:\n\t\tspin_lock_irqsave(&rtc_lock, flags);\n\t\t \n\t\tdata = (u8 *)&smi_buf.dma;\n\t\tfor (index = PE1400_CMOS_CMD_STRUCT_PTR;\n\t\t     index < (PE1400_CMOS_CMD_STRUCT_PTR + 4);\n\t\t     index++, data++) {\n\t\t\toutb(index, (CMOS_BASE_PORT + CMOS_PAGE1_INDEX_PORT));\n\t\t\toutb(*data, (CMOS_BASE_PORT + CMOS_PAGE1_DATA_PORT));\n\t\t}\n\n\t\t \n\t\tif (host_control_smi_type == HC_SMITYPE_TYPE3)\n\t\t\toutb(ESM_APM_CMD, PCAT_APM_CONTROL_PORT);\n\t\telse\n\t\t\toutb(ESM_APM_CMD, PE1400_APM_CONTROL_PORT);\n\n\t\t \n\t\tCMOS_READ(RTC_REG_C);\n\t\tspin_unlock_irqrestore(&rtc_lock, flags);\n\n\t\t \n\t\tcmd_status = inb(PE1400_APM_CONTROL_PORT);\n\n\t\t \n\t\tnum_ticks = TIMEOUT_USEC_SHORT_SEMA_BLOCKING;\n\t\twhile (apm_cmd->status == ESM_STATUS_CMD_UNSUCCESSFUL) {\n\t\t\tnum_ticks--;\n\t\t\tif (num_ticks == EXPIRED_TIMER)\n\t\t\t\treturn -ETIME;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tdev_dbg(&dcdbas_pdev->dev, \"%s: invalid SMI type %u\\n\",\n\t\t\t__func__, host_control_smi_type);\n\t\treturn -ENOSYS;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void dcdbas_host_control(void)\n{\n\tstruct apm_cmd *apm_cmd;\n\tu8 action;\n\n\tif (host_control_action == HC_ACTION_NONE)\n\t\treturn;\n\n\taction = host_control_action;\n\thost_control_action = HC_ACTION_NONE;\n\n\tif (!smi_buf.virt) {\n\t\tdev_dbg(&dcdbas_pdev->dev, \"%s: no SMI buffer\\n\", __func__);\n\t\treturn;\n\t}\n\n\tif (smi_buf.size < sizeof(struct apm_cmd)) {\n\t\tdev_dbg(&dcdbas_pdev->dev, \"%s: SMI buffer too small\\n\",\n\t\t\t__func__);\n\t\treturn;\n\t}\n\n\tapm_cmd = (struct apm_cmd *)smi_buf.virt;\n\n\t \n\tif (action & HC_ACTION_HOST_CONTROL_POWEROFF) {\n\t\tapm_cmd->command = ESM_APM_POWER_CYCLE;\n\t\tapm_cmd->reserved = 0;\n\t\t*((s16 *)&apm_cmd->parameters.shortreq.parm[0]) = (s16) 0;\n\t\thost_control_smi();\n\t} else if (action & HC_ACTION_HOST_CONTROL_POWERCYCLE) {\n\t\tapm_cmd->command = ESM_APM_POWER_CYCLE;\n\t\tapm_cmd->reserved = 0;\n\t\t*((s16 *)&apm_cmd->parameters.shortreq.parm[0]) = (s16) 20;\n\t\thost_control_smi();\n\t}\n}\n\n \n\nstatic u8 checksum(u8 *buffer, u8 length)\n{\n\tu8 sum = 0;\n\tu8 *end = buffer + length;\n\n\twhile (buffer < end)\n\t\tsum += *buffer++;\n\treturn sum;\n}\n\nstatic inline struct smm_eps_table *check_eps_table(u8 *addr)\n{\n\tstruct smm_eps_table *eps = (struct smm_eps_table *)addr;\n\n\tif (strncmp(eps->smm_comm_buff_anchor, SMM_EPS_SIG, 4) != 0)\n\t\treturn NULL;\n\n\tif (checksum(addr, eps->length) != 0)\n\t\treturn NULL;\n\n\treturn eps;\n}\n\nstatic int dcdbas_check_wsmt(void)\n{\n\tconst struct dmi_device *dev = NULL;\n\tstruct acpi_table_wsmt *wsmt = NULL;\n\tstruct smm_eps_table *eps = NULL;\n\tu64 bios_buf_paddr;\n\tu64 remap_size;\n\tu8 *addr;\n\n\tacpi_get_table(ACPI_SIG_WSMT, 0, (struct acpi_table_header **)&wsmt);\n\tif (!wsmt)\n\t\treturn 0;\n\n\t \n\tif (!(wsmt->protection_flags & ACPI_WSMT_FIXED_COMM_BUFFERS) ||\n\t    !(wsmt->protection_flags & ACPI_WSMT_COMM_BUFFER_NESTED_PTR_PROTECTION))\n\t\treturn 0;\n\n\t \n\n\t \n\twhile ((dev = dmi_find_device(DMI_DEV_TYPE_OEM_STRING, NULL, dev)))\n\t\tif (sscanf(dev->name, \"30[%16llx;%8llx]\", &bios_buf_paddr,\n\t\t    &remap_size) == 2)\n\t\t\tgoto remap;\n\n\t \n\tfor (addr = (u8 *)__va(0xf0000);\n\t     addr < (u8 *)__va(0x100000 - sizeof(struct smm_eps_table));\n\t     addr += 16) {\n\t\teps = check_eps_table(addr);\n\t\tif (eps)\n\t\t\tbreak;\n\t}\n\n\tif (!eps) {\n\t\tdev_dbg(&dcdbas_pdev->dev, \"found WSMT, but no firmware buffer found\\n\");\n\t\treturn -ENODEV;\n\t}\n\tbios_buf_paddr = eps->smm_comm_buff_addr;\n\tremap_size = eps->num_of_4k_pages * PAGE_SIZE;\n\nremap:\n\t \n\tif (upper_32_bits(bios_buf_paddr + 8)) {\n\t\tdev_warn(&dcdbas_pdev->dev, \"found WSMT, but buffer address is above 4GB\\n\");\n\t\treturn -EINVAL;\n\t}\n\t \n\tif (remap_size > MAX_SMI_DATA_BUF_SIZE + 8)\n\t\tremap_size = MAX_SMI_DATA_BUF_SIZE + 8;\n\n\tbios_buffer = memremap(bios_buf_paddr, remap_size, MEMREMAP_WB);\n\tif (!bios_buffer) {\n\t\tdev_warn(&dcdbas_pdev->dev, \"found WSMT, but failed to map buffer\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tsmi_buf.dma = bios_buf_paddr + 8;\n\tsmi_buf.virt = bios_buffer + 8;\n\tsmi_buf.size = remap_size - 8;\n\tmax_smi_data_buf_size = smi_buf.size;\n\twsmt_enabled = true;\n\tdev_info(&dcdbas_pdev->dev,\n\t\t \"WSMT found, using firmware-provided SMI buffer.\\n\");\n\treturn 1;\n}\n\n \nstatic int dcdbas_reboot_notify(struct notifier_block *nb, unsigned long code,\n\t\t\t\tvoid *unused)\n{\n\tswitch (code) {\n\tcase SYS_DOWN:\n\tcase SYS_HALT:\n\tcase SYS_POWER_OFF:\n\t\tif (host_control_on_shutdown) {\n\t\t\t \n\t\t\tprintk(KERN_WARNING \"Please wait for shutdown \"\n\t\t\t       \"action to complete...\\n\");\n\t\t\tdcdbas_host_control();\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block dcdbas_reboot_nb = {\n\t.notifier_call = dcdbas_reboot_notify,\n\t.next = NULL,\n\t.priority = INT_MIN\n};\n\nstatic DCDBAS_BIN_ATTR_RW(smi_data);\n\nstatic struct bin_attribute *dcdbas_bin_attrs[] = {\n\t&bin_attr_smi_data,\n\tNULL\n};\n\nstatic DCDBAS_DEV_ATTR_RW(smi_data_buf_size);\nstatic DCDBAS_DEV_ATTR_RO(smi_data_buf_phys_addr);\nstatic DCDBAS_DEV_ATTR_WO(smi_request);\nstatic DCDBAS_DEV_ATTR_RW(host_control_action);\nstatic DCDBAS_DEV_ATTR_RW(host_control_smi_type);\nstatic DCDBAS_DEV_ATTR_RW(host_control_on_shutdown);\n\nstatic struct attribute *dcdbas_dev_attrs[] = {\n\t&dev_attr_smi_data_buf_size.attr,\n\t&dev_attr_smi_data_buf_phys_addr.attr,\n\t&dev_attr_smi_request.attr,\n\t&dev_attr_host_control_action.attr,\n\t&dev_attr_host_control_smi_type.attr,\n\t&dev_attr_host_control_on_shutdown.attr,\n\tNULL\n};\n\nstatic const struct attribute_group dcdbas_attr_group = {\n\t.attrs = dcdbas_dev_attrs,\n\t.bin_attrs = dcdbas_bin_attrs,\n};\n\nstatic int dcdbas_probe(struct platform_device *dev)\n{\n\tint error;\n\n\thost_control_action = HC_ACTION_NONE;\n\thost_control_smi_type = HC_SMITYPE_NONE;\n\n\tdcdbas_pdev = dev;\n\n\t \n\terror = dcdbas_check_wsmt();\n\tif (error < 0)\n\t\treturn error;\n\n\t \n\terror = dma_set_coherent_mask(&dcdbas_pdev->dev, DMA_BIT_MASK(32));\n\tif (error)\n\t\treturn error;\n\n\terror = sysfs_create_group(&dev->dev.kobj, &dcdbas_attr_group);\n\tif (error)\n\t\treturn error;\n\n\tregister_reboot_notifier(&dcdbas_reboot_nb);\n\n\tdev_info(&dev->dev, \"%s (version %s)\\n\",\n\t\t DRIVER_DESCRIPTION, DRIVER_VERSION);\n\n\treturn 0;\n}\n\nstatic void dcdbas_remove(struct platform_device *dev)\n{\n\tunregister_reboot_notifier(&dcdbas_reboot_nb);\n\tsysfs_remove_group(&dev->dev.kobj, &dcdbas_attr_group);\n}\n\nstatic struct platform_driver dcdbas_driver = {\n\t.driver\t\t= {\n\t\t.name\t= DRIVER_NAME,\n\t},\n\t.probe\t\t= dcdbas_probe,\n\t.remove_new\t= dcdbas_remove,\n};\n\nstatic const struct platform_device_info dcdbas_dev_info __initconst = {\n\t.name\t\t= DRIVER_NAME,\n\t.id\t\t= PLATFORM_DEVID_NONE,\n\t.dma_mask\t= DMA_BIT_MASK(32),\n};\n\nstatic struct platform_device *dcdbas_pdev_reg;\n\n \nstatic int __init dcdbas_init(void)\n{\n\tint error;\n\n\terror = platform_driver_register(&dcdbas_driver);\n\tif (error)\n\t\treturn error;\n\n\tdcdbas_pdev_reg = platform_device_register_full(&dcdbas_dev_info);\n\tif (IS_ERR(dcdbas_pdev_reg)) {\n\t\terror = PTR_ERR(dcdbas_pdev_reg);\n\t\tgoto err_unregister_driver;\n\t}\n\n\treturn 0;\n\n err_unregister_driver:\n\tplatform_driver_unregister(&dcdbas_driver);\n\treturn error;\n}\n\n \nstatic void __exit dcdbas_exit(void)\n{\n\t \n\tunregister_reboot_notifier(&dcdbas_reboot_nb);\n\n\t \n\tif (dcdbas_pdev)\n\t\tsmi_data_buf_free();\n\tif (bios_buffer)\n\t\tmemunmap(bios_buffer);\n\tplatform_device_unregister(dcdbas_pdev_reg);\n\tplatform_driver_unregister(&dcdbas_driver);\n}\n\nsubsys_initcall_sync(dcdbas_init);\nmodule_exit(dcdbas_exit);\n\nMODULE_DESCRIPTION(DRIVER_DESCRIPTION \" (version \" DRIVER_VERSION \")\");\nMODULE_VERSION(DRIVER_VERSION);\nMODULE_AUTHOR(\"Dell Inc.\");\nMODULE_LICENSE(\"GPL\");\n \nMODULE_ALIAS(\"dmi:*:[bs]vnD[Ee][Ll][Ll]*:*\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}