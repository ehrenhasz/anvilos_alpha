{
  "module_name": "dell-laptop.c",
  "hash_id": "751a54c8d22821445546308431b654353fd5425c5a45ef5a76bf00ec38300455",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/x86/dell/dell-laptop.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/platform_device.h>\n#include <linux/backlight.h>\n#include <linux/err.h>\n#include <linux/dmi.h>\n#include <linux/io.h>\n#include <linux/rfkill.h>\n#include <linux/power_supply.h>\n#include <linux/acpi.h>\n#include <linux/mm.h>\n#include <linux/i8042.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <acpi/video.h>\n#include \"dell-rbtn.h\"\n#include \"dell-smbios.h\"\n\n#include \"dell-wmi-privacy.h\"\n\nstruct quirk_entry {\n\tbool touchpad_led;\n\tbool kbd_led_not_present;\n\tbool kbd_led_levels_off_1;\n\tbool kbd_missing_ac_tag;\n\n\tbool needs_kbd_timeouts;\n\t \n\tint kbd_timeouts[];\n};\n\nstatic struct quirk_entry *quirks;\n\nstatic struct quirk_entry quirk_dell_vostro_v130 = {\n\t.touchpad_led = true,\n};\n\nstatic int __init dmi_matched(const struct dmi_system_id *dmi)\n{\n\tquirks = dmi->driver_data;\n\treturn 1;\n}\n\n \nstatic struct quirk_entry quirk_dell_xps13_9333 = {\n\t.needs_kbd_timeouts = true,\n\t.kbd_timeouts = { 0, 5, 15, 60, 5 * 60, 15 * 60, -1 },\n};\n\nstatic struct quirk_entry quirk_dell_xps13_9370 = {\n\t.kbd_missing_ac_tag = true,\n};\n\nstatic struct quirk_entry quirk_dell_latitude_e6410 = {\n\t.kbd_led_levels_off_1 = true,\n};\n\nstatic struct quirk_entry quirk_dell_inspiron_1012 = {\n\t.kbd_led_not_present = true,\n};\n\nstatic struct quirk_entry quirk_dell_latitude_7520 = {\n\t.kbd_missing_ac_tag = true,\n};\n\nstatic struct platform_driver platform_driver = {\n\t.driver = {\n\t\t.name = \"dell-laptop\",\n\t}\n};\n\nstatic struct platform_device *platform_device;\nstatic struct backlight_device *dell_backlight_device;\nstatic struct rfkill *wifi_rfkill;\nstatic struct rfkill *bluetooth_rfkill;\nstatic struct rfkill *wwan_rfkill;\nstatic bool force_rfkill;\nstatic bool micmute_led_registered;\nstatic bool mute_led_registered;\n\nmodule_param(force_rfkill, bool, 0444);\nMODULE_PARM_DESC(force_rfkill, \"enable rfkill on non whitelisted models\");\n\nstatic const struct dmi_system_id dell_device_table[] __initconst = {\n\t{\n\t\t.ident = \"Dell laptop\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Inc.\"),\n\t\t\tDMI_MATCH(DMI_CHASSIS_TYPE, \"8\"),\n\t\t},\n\t},\n\t{\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Inc.\"),\n\t\t\tDMI_MATCH(DMI_CHASSIS_TYPE, \"9\"),  \n\t\t},\n\t},\n\t{\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Inc.\"),\n\t\t\tDMI_MATCH(DMI_CHASSIS_TYPE, \"10\"),  \n\t\t},\n\t},\n\t{\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Inc.\"),\n\t\t\tDMI_MATCH(DMI_CHASSIS_TYPE, \"30\"),  \n\t\t},\n\t},\n\t{\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Inc.\"),\n\t\t\tDMI_MATCH(DMI_CHASSIS_TYPE, \"31\"),  \n\t\t},\n\t},\n\t{\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Inc.\"),\n\t\t\tDMI_MATCH(DMI_CHASSIS_TYPE, \"32\"),  \n\t\t},\n\t},\n\t{\n\t\t.ident = \"Dell Computer Corporation\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Computer Corporation\"),\n\t\t\tDMI_MATCH(DMI_CHASSIS_TYPE, \"8\"),\n\t\t},\n\t},\n\t{ }\n};\nMODULE_DEVICE_TABLE(dmi, dell_device_table);\n\nstatic const struct dmi_system_id dell_quirks[] __initconst = {\n\t{\n\t\t.callback = dmi_matched,\n\t\t.ident = \"Dell Vostro V130\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Inc.\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Vostro V130\"),\n\t\t},\n\t\t.driver_data = &quirk_dell_vostro_v130,\n\t},\n\t{\n\t\t.callback = dmi_matched,\n\t\t.ident = \"Dell Vostro V131\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Inc.\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Vostro V131\"),\n\t\t},\n\t\t.driver_data = &quirk_dell_vostro_v130,\n\t},\n\t{\n\t\t.callback = dmi_matched,\n\t\t.ident = \"Dell Vostro 3350\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Inc.\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Vostro 3350\"),\n\t\t},\n\t\t.driver_data = &quirk_dell_vostro_v130,\n\t},\n\t{\n\t\t.callback = dmi_matched,\n\t\t.ident = \"Dell Vostro 3555\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Inc.\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Vostro 3555\"),\n\t\t},\n\t\t.driver_data = &quirk_dell_vostro_v130,\n\t},\n\t{\n\t\t.callback = dmi_matched,\n\t\t.ident = \"Dell Inspiron N311z\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Inc.\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Inspiron N311z\"),\n\t\t},\n\t\t.driver_data = &quirk_dell_vostro_v130,\n\t},\n\t{\n\t\t.callback = dmi_matched,\n\t\t.ident = \"Dell Inspiron M5110\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Inc.\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Inspiron M5110\"),\n\t\t},\n\t\t.driver_data = &quirk_dell_vostro_v130,\n\t},\n\t{\n\t\t.callback = dmi_matched,\n\t\t.ident = \"Dell Vostro 3360\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Inc.\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Vostro 3360\"),\n\t\t},\n\t\t.driver_data = &quirk_dell_vostro_v130,\n\t},\n\t{\n\t\t.callback = dmi_matched,\n\t\t.ident = \"Dell Vostro 3460\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Inc.\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Vostro 3460\"),\n\t\t},\n\t\t.driver_data = &quirk_dell_vostro_v130,\n\t},\n\t{\n\t\t.callback = dmi_matched,\n\t\t.ident = \"Dell Vostro 3560\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Inc.\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Vostro 3560\"),\n\t\t},\n\t\t.driver_data = &quirk_dell_vostro_v130,\n\t},\n\t{\n\t\t.callback = dmi_matched,\n\t\t.ident = \"Dell Vostro 3450\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Inc.\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Dell System Vostro 3450\"),\n\t\t},\n\t\t.driver_data = &quirk_dell_vostro_v130,\n\t},\n\t{\n\t\t.callback = dmi_matched,\n\t\t.ident = \"Dell Inspiron 5420\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Inc.\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Inspiron 5420\"),\n\t\t},\n\t\t.driver_data = &quirk_dell_vostro_v130,\n\t},\n\t{\n\t\t.callback = dmi_matched,\n\t\t.ident = \"Dell Inspiron 5520\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Inc.\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Inspiron 5520\"),\n\t\t},\n\t\t.driver_data = &quirk_dell_vostro_v130,\n\t},\n\t{\n\t\t.callback = dmi_matched,\n\t\t.ident = \"Dell Inspiron 5720\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Inc.\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Inspiron 5720\"),\n\t\t},\n\t\t.driver_data = &quirk_dell_vostro_v130,\n\t},\n\t{\n\t\t.callback = dmi_matched,\n\t\t.ident = \"Dell Inspiron 7420\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Inc.\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Inspiron 7420\"),\n\t\t},\n\t\t.driver_data = &quirk_dell_vostro_v130,\n\t},\n\t{\n\t\t.callback = dmi_matched,\n\t\t.ident = \"Dell Inspiron 7520\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Inc.\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Inspiron 7520\"),\n\t\t},\n\t\t.driver_data = &quirk_dell_vostro_v130,\n\t},\n\t{\n\t\t.callback = dmi_matched,\n\t\t.ident = \"Dell Inspiron 7720\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Inc.\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Inspiron 7720\"),\n\t\t},\n\t\t.driver_data = &quirk_dell_vostro_v130,\n\t},\n\t{\n\t\t.callback = dmi_matched,\n\t\t.ident = \"Dell XPS13 9333\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Inc.\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"XPS13 9333\"),\n\t\t},\n\t\t.driver_data = &quirk_dell_xps13_9333,\n\t},\n\t{\n\t\t.callback = dmi_matched,\n\t\t.ident = \"Dell XPS 13 9370\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Inc.\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"XPS 13 9370\"),\n\t\t},\n\t\t.driver_data = &quirk_dell_xps13_9370,\n\t},\n\t{\n\t\t.callback = dmi_matched,\n\t\t.ident = \"Dell Latitude E6410\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Inc.\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Latitude E6410\"),\n\t\t},\n\t\t.driver_data = &quirk_dell_latitude_e6410,\n\t},\n\t{\n\t\t.callback = dmi_matched,\n\t\t.ident = \"Dell Inspiron 1012\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Inc.\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Inspiron 1012\"),\n\t\t},\n\t\t.driver_data = &quirk_dell_inspiron_1012,\n\t},\n\t{\n\t\t.callback = dmi_matched,\n\t\t.ident = \"Dell Inspiron 1018\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Inc.\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Inspiron 1018\"),\n\t\t},\n\t\t.driver_data = &quirk_dell_inspiron_1012,\n\t},\n\t{\n\t\t.callback = dmi_matched,\n\t\t.ident = \"Dell Latitude 7520\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Inc.\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Latitude 7520\"),\n\t\t},\n\t\t.driver_data = &quirk_dell_latitude_7520,\n\t},\n\t{ }\n};\n\nstatic void dell_fill_request(struct calling_interface_buffer *buffer,\n\t\t\t       u32 arg0, u32 arg1, u32 arg2, u32 arg3)\n{\n\tmemset(buffer, 0, sizeof(struct calling_interface_buffer));\n\tbuffer->input[0] = arg0;\n\tbuffer->input[1] = arg1;\n\tbuffer->input[2] = arg2;\n\tbuffer->input[3] = arg3;\n}\n\nstatic int dell_send_request(struct calling_interface_buffer *buffer,\n\t\t\t     u16 class, u16 select)\n{\n\tint ret;\n\n\tbuffer->cmd_class = class;\n\tbuffer->cmd_select = select;\n\tret = dell_smbios_call(buffer);\n\tif (ret != 0)\n\t\treturn ret;\n\treturn dell_smbios_error(buffer->output[0]);\n}\n\n \n\nstatic int dell_rfkill_set(void *data, bool blocked)\n{\n\tint disable = blocked ? 1 : 0;\n\tunsigned long radio = (unsigned long)data;\n\tint hwswitch_bit = (unsigned long)data - 1;\n\tstruct calling_interface_buffer buffer;\n\tint hwswitch;\n\tint status;\n\tint ret;\n\n\tdell_fill_request(&buffer, 0, 0, 0, 0);\n\tret = dell_send_request(&buffer, CLASS_INFO, SELECT_RFKILL);\n\tif (ret)\n\t\treturn ret;\n\tstatus = buffer.output[1];\n\n\tdell_fill_request(&buffer, 0x2, 0, 0, 0);\n\tret = dell_send_request(&buffer, CLASS_INFO, SELECT_RFKILL);\n\tif (ret)\n\t\treturn ret;\n\thwswitch = buffer.output[1];\n\n\t \n\tif (ret == 0 && (hwswitch & BIT(hwswitch_bit)) &&\n\t    (status & BIT(0)) && !(status & BIT(16)))\n\t\tdisable = 1;\n\n\tdell_fill_request(&buffer, 1 | (radio<<8) | (disable << 16), 0, 0, 0);\n\tret = dell_send_request(&buffer, CLASS_INFO, SELECT_RFKILL);\n\treturn ret;\n}\n\nstatic void dell_rfkill_update_sw_state(struct rfkill *rfkill, int radio,\n\t\t\t\t\tint status)\n{\n\tif (status & BIT(0)) {\n\t\t \n\t\tstruct calling_interface_buffer buffer;\n\t\tint block = rfkill_blocked(rfkill);\n\t\tdell_fill_request(&buffer,\n\t\t\t\t   1 | (radio << 8) | (block << 16), 0, 0, 0);\n\t\tdell_send_request(&buffer, CLASS_INFO, SELECT_RFKILL);\n\t} else {\n\t\t \n\t\trfkill_set_sw_state(rfkill, !!(status & BIT(radio + 16)));\n\t}\n}\n\nstatic void dell_rfkill_update_hw_state(struct rfkill *rfkill, int radio,\n\t\t\t\t\tint status, int hwswitch)\n{\n\tif (hwswitch & (BIT(radio - 1)))\n\t\trfkill_set_hw_state(rfkill, !(status & BIT(16)));\n}\n\nstatic void dell_rfkill_query(struct rfkill *rfkill, void *data)\n{\n\tint radio = ((unsigned long)data & 0xF);\n\tstruct calling_interface_buffer buffer;\n\tint hwswitch;\n\tint status;\n\tint ret;\n\n\tdell_fill_request(&buffer, 0, 0, 0, 0);\n\tret = dell_send_request(&buffer, CLASS_INFO, SELECT_RFKILL);\n\tstatus = buffer.output[1];\n\n\tif (ret != 0 || !(status & BIT(0))) {\n\t\treturn;\n\t}\n\n\tdell_fill_request(&buffer, 0x2, 0, 0, 0);\n\tret = dell_send_request(&buffer, CLASS_INFO, SELECT_RFKILL);\n\thwswitch = buffer.output[1];\n\n\tif (ret != 0)\n\t\treturn;\n\n\tdell_rfkill_update_hw_state(rfkill, radio, status, hwswitch);\n}\n\nstatic const struct rfkill_ops dell_rfkill_ops = {\n\t.set_block = dell_rfkill_set,\n\t.query = dell_rfkill_query,\n};\n\nstatic struct dentry *dell_laptop_dir;\n\nstatic int dell_debugfs_show(struct seq_file *s, void *data)\n{\n\tstruct calling_interface_buffer buffer;\n\tint hwswitch_state;\n\tint hwswitch_ret;\n\tint status;\n\tint ret;\n\n\tdell_fill_request(&buffer, 0, 0, 0, 0);\n\tret = dell_send_request(&buffer, CLASS_INFO, SELECT_RFKILL);\n\tif (ret)\n\t\treturn ret;\n\tstatus = buffer.output[1];\n\n\tdell_fill_request(&buffer, 0x2, 0, 0, 0);\n\thwswitch_ret = dell_send_request(&buffer, CLASS_INFO, SELECT_RFKILL);\n\tif (hwswitch_ret)\n\t\treturn hwswitch_ret;\n\thwswitch_state = buffer.output[1];\n\n\tseq_printf(s, \"return:\\t%d\\n\", ret);\n\tseq_printf(s, \"status:\\t0x%X\\n\", status);\n\tseq_printf(s, \"Bit 0 : Hardware switch supported:   %lu\\n\",\n\t\t   status & BIT(0));\n\tseq_printf(s, \"Bit 1 : Wifi locator supported:      %lu\\n\",\n\t\t  (status & BIT(1)) >> 1);\n\tseq_printf(s, \"Bit 2 : Wifi is supported:           %lu\\n\",\n\t\t  (status & BIT(2)) >> 2);\n\tseq_printf(s, \"Bit 3 : Bluetooth is supported:      %lu\\n\",\n\t\t  (status & BIT(3)) >> 3);\n\tseq_printf(s, \"Bit 4 : WWAN is supported:           %lu\\n\",\n\t\t  (status & BIT(4)) >> 4);\n\tseq_printf(s, \"Bit 5 : Wireless keyboard supported: %lu\\n\",\n\t\t  (status & BIT(5)) >> 5);\n\tseq_printf(s, \"Bit 6 : UWB supported:               %lu\\n\",\n\t\t  (status & BIT(6)) >> 6);\n\tseq_printf(s, \"Bit 7 : WiGig supported:             %lu\\n\",\n\t\t  (status & BIT(7)) >> 7);\n\tseq_printf(s, \"Bit 8 : Wifi is installed:           %lu\\n\",\n\t\t  (status & BIT(8)) >> 8);\n\tseq_printf(s, \"Bit 9 : Bluetooth is installed:      %lu\\n\",\n\t\t  (status & BIT(9)) >> 9);\n\tseq_printf(s, \"Bit 10: WWAN is installed:           %lu\\n\",\n\t\t  (status & BIT(10)) >> 10);\n\tseq_printf(s, \"Bit 11: UWB installed:               %lu\\n\",\n\t\t  (status & BIT(11)) >> 11);\n\tseq_printf(s, \"Bit 12: WiGig installed:             %lu\\n\",\n\t\t  (status & BIT(12)) >> 12);\n\n\tseq_printf(s, \"Bit 16: Hardware switch is on:       %lu\\n\",\n\t\t  (status & BIT(16)) >> 16);\n\tseq_printf(s, \"Bit 17: Wifi is blocked:             %lu\\n\",\n\t\t  (status & BIT(17)) >> 17);\n\tseq_printf(s, \"Bit 18: Bluetooth is blocked:        %lu\\n\",\n\t\t  (status & BIT(18)) >> 18);\n\tseq_printf(s, \"Bit 19: WWAN is blocked:             %lu\\n\",\n\t\t  (status & BIT(19)) >> 19);\n\tseq_printf(s, \"Bit 20: UWB is blocked:              %lu\\n\",\n\t\t  (status & BIT(20)) >> 20);\n\tseq_printf(s, \"Bit 21: WiGig is blocked:            %lu\\n\",\n\t\t  (status & BIT(21)) >> 21);\n\n\tseq_printf(s, \"\\nhwswitch_return:\\t%d\\n\", hwswitch_ret);\n\tseq_printf(s, \"hwswitch_state:\\t0x%X\\n\", hwswitch_state);\n\tseq_printf(s, \"Bit 0 : Wifi controlled by switch:      %lu\\n\",\n\t\t   hwswitch_state & BIT(0));\n\tseq_printf(s, \"Bit 1 : Bluetooth controlled by switch: %lu\\n\",\n\t\t   (hwswitch_state & BIT(1)) >> 1);\n\tseq_printf(s, \"Bit 2 : WWAN controlled by switch:      %lu\\n\",\n\t\t   (hwswitch_state & BIT(2)) >> 2);\n\tseq_printf(s, \"Bit 3 : UWB controlled by switch:       %lu\\n\",\n\t\t   (hwswitch_state & BIT(3)) >> 3);\n\tseq_printf(s, \"Bit 4 : WiGig controlled by switch:     %lu\\n\",\n\t\t   (hwswitch_state & BIT(4)) >> 4);\n\tseq_printf(s, \"Bit 7 : Wireless switch config locked:  %lu\\n\",\n\t\t   (hwswitch_state & BIT(7)) >> 7);\n\tseq_printf(s, \"Bit 8 : Wifi locator enabled:           %lu\\n\",\n\t\t   (hwswitch_state & BIT(8)) >> 8);\n\tseq_printf(s, \"Bit 15: Wifi locator setting locked:    %lu\\n\",\n\t\t   (hwswitch_state & BIT(15)) >> 15);\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(dell_debugfs);\n\nstatic void dell_update_rfkill(struct work_struct *ignored)\n{\n\tstruct calling_interface_buffer buffer;\n\tint hwswitch = 0;\n\tint status;\n\tint ret;\n\n\tdell_fill_request(&buffer, 0, 0, 0, 0);\n\tret = dell_send_request(&buffer, CLASS_INFO, SELECT_RFKILL);\n\tstatus = buffer.output[1];\n\n\tif (ret != 0)\n\t\treturn;\n\n\tdell_fill_request(&buffer, 0x2, 0, 0, 0);\n\tret = dell_send_request(&buffer, CLASS_INFO, SELECT_RFKILL);\n\n\tif (ret == 0 && (status & BIT(0)))\n\t\thwswitch = buffer.output[1];\n\n\tif (wifi_rfkill) {\n\t\tdell_rfkill_update_hw_state(wifi_rfkill, 1, status, hwswitch);\n\t\tdell_rfkill_update_sw_state(wifi_rfkill, 1, status);\n\t}\n\tif (bluetooth_rfkill) {\n\t\tdell_rfkill_update_hw_state(bluetooth_rfkill, 2, status,\n\t\t\t\t\t    hwswitch);\n\t\tdell_rfkill_update_sw_state(bluetooth_rfkill, 2, status);\n\t}\n\tif (wwan_rfkill) {\n\t\tdell_rfkill_update_hw_state(wwan_rfkill, 3, status, hwswitch);\n\t\tdell_rfkill_update_sw_state(wwan_rfkill, 3, status);\n\t}\n}\nstatic DECLARE_DELAYED_WORK(dell_rfkill_work, dell_update_rfkill);\n\nstatic bool dell_laptop_i8042_filter(unsigned char data, unsigned char str,\n\t\t\t      struct serio *port)\n{\n\tstatic bool extended;\n\n\tif (str & I8042_STR_AUXDATA)\n\t\treturn false;\n\n\tif (unlikely(data == 0xe0)) {\n\t\textended = true;\n\t\treturn false;\n\t} else if (unlikely(extended)) {\n\t\tswitch (data) {\n\t\tcase 0x8:\n\t\t\tschedule_delayed_work(&dell_rfkill_work,\n\t\t\t\t\t      round_jiffies_relative(HZ / 4));\n\t\t\tbreak;\n\t\t}\n\t\textended = false;\n\t}\n\n\treturn false;\n}\n\nstatic int (*dell_rbtn_notifier_register_func)(struct notifier_block *);\nstatic int (*dell_rbtn_notifier_unregister_func)(struct notifier_block *);\n\nstatic int dell_laptop_rbtn_notifier_call(struct notifier_block *nb,\n\t\t\t\t\t  unsigned long action, void *data)\n{\n\tschedule_delayed_work(&dell_rfkill_work, 0);\n\treturn NOTIFY_OK;\n}\n\nstatic struct notifier_block dell_laptop_rbtn_notifier = {\n\t.notifier_call = dell_laptop_rbtn_notifier_call,\n};\n\nstatic int __init dell_setup_rfkill(void)\n{\n\tstruct calling_interface_buffer buffer;\n\tint status, ret, whitelisted;\n\tconst char *product;\n\n\t \n\twhitelisted = 0;\n\tproduct = dmi_get_system_info(DMI_PRODUCT_NAME);\n\tif (product &&  (strncmp(product, \"Latitude\", 8) == 0 ||\n\t\t\t strncmp(product, \"Precision\", 9) == 0))\n\t\twhitelisted = 1;\n\tif (!force_rfkill && !whitelisted)\n\t\treturn 0;\n\n\tdell_fill_request(&buffer, 0, 0, 0, 0);\n\tret = dell_send_request(&buffer, CLASS_INFO, SELECT_RFKILL);\n\tstatus = buffer.output[1];\n\n\t \n\tif (ret != 0)\n\t\treturn 0;\n\n\t \n\tif (!(status & BIT(0)) && !force_rfkill)\n\t\treturn 0;\n\n\tif ((status & (1<<2|1<<8)) == (1<<2|1<<8)) {\n\t\twifi_rfkill = rfkill_alloc(\"dell-wifi\", &platform_device->dev,\n\t\t\t\t\t   RFKILL_TYPE_WLAN,\n\t\t\t\t\t   &dell_rfkill_ops, (void *) 1);\n\t\tif (!wifi_rfkill) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_wifi;\n\t\t}\n\t\tret = rfkill_register(wifi_rfkill);\n\t\tif (ret)\n\t\t\tgoto err_wifi;\n\t}\n\n\tif ((status & (1<<3|1<<9)) == (1<<3|1<<9)) {\n\t\tbluetooth_rfkill = rfkill_alloc(\"dell-bluetooth\",\n\t\t\t\t\t\t&platform_device->dev,\n\t\t\t\t\t\tRFKILL_TYPE_BLUETOOTH,\n\t\t\t\t\t\t&dell_rfkill_ops, (void *) 2);\n\t\tif (!bluetooth_rfkill) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_bluetooth;\n\t\t}\n\t\tret = rfkill_register(bluetooth_rfkill);\n\t\tif (ret)\n\t\t\tgoto err_bluetooth;\n\t}\n\n\tif ((status & (1<<4|1<<10)) == (1<<4|1<<10)) {\n\t\twwan_rfkill = rfkill_alloc(\"dell-wwan\",\n\t\t\t\t\t   &platform_device->dev,\n\t\t\t\t\t   RFKILL_TYPE_WWAN,\n\t\t\t\t\t   &dell_rfkill_ops, (void *) 3);\n\t\tif (!wwan_rfkill) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_wwan;\n\t\t}\n\t\tret = rfkill_register(wwan_rfkill);\n\t\tif (ret)\n\t\t\tgoto err_wwan;\n\t}\n\n\t \n\n\tdell_rbtn_notifier_register_func =\n\t\tsymbol_request(dell_rbtn_notifier_register);\n\tif (dell_rbtn_notifier_register_func) {\n\t\tdell_rbtn_notifier_unregister_func =\n\t\t\tsymbol_request(dell_rbtn_notifier_unregister);\n\t\tif (!dell_rbtn_notifier_unregister_func) {\n\t\t\tsymbol_put(dell_rbtn_notifier_register);\n\t\t\tdell_rbtn_notifier_register_func = NULL;\n\t\t}\n\t}\n\n\tif (dell_rbtn_notifier_register_func) {\n\t\tret = dell_rbtn_notifier_register_func(\n\t\t\t&dell_laptop_rbtn_notifier);\n\t\tsymbol_put(dell_rbtn_notifier_register);\n\t\tdell_rbtn_notifier_register_func = NULL;\n\t\tif (ret != 0) {\n\t\t\tsymbol_put(dell_rbtn_notifier_unregister);\n\t\t\tdell_rbtn_notifier_unregister_func = NULL;\n\t\t}\n\t} else {\n\t\tpr_info(\"Symbols from dell-rbtn acpi driver are not available\\n\");\n\t\tret = -ENODEV;\n\t}\n\n\tif (ret == 0) {\n\t\tpr_info(\"Using dell-rbtn acpi driver for receiving events\\n\");\n\t} else if (ret != -ENODEV) {\n\t\tpr_warn(\"Unable to register dell rbtn notifier\\n\");\n\t\tgoto err_filter;\n\t} else {\n\t\tret = i8042_install_filter(dell_laptop_i8042_filter);\n\t\tif (ret) {\n\t\t\tpr_warn(\"Unable to install key filter\\n\");\n\t\t\tgoto err_filter;\n\t\t}\n\t\tpr_info(\"Using i8042 filter function for receiving events\\n\");\n\t}\n\n\treturn 0;\nerr_filter:\n\tif (wwan_rfkill)\n\t\trfkill_unregister(wwan_rfkill);\nerr_wwan:\n\trfkill_destroy(wwan_rfkill);\n\tif (bluetooth_rfkill)\n\t\trfkill_unregister(bluetooth_rfkill);\nerr_bluetooth:\n\trfkill_destroy(bluetooth_rfkill);\n\tif (wifi_rfkill)\n\t\trfkill_unregister(wifi_rfkill);\nerr_wifi:\n\trfkill_destroy(wifi_rfkill);\n\n\treturn ret;\n}\n\nstatic void dell_cleanup_rfkill(void)\n{\n\tif (dell_rbtn_notifier_unregister_func) {\n\t\tdell_rbtn_notifier_unregister_func(&dell_laptop_rbtn_notifier);\n\t\tsymbol_put(dell_rbtn_notifier_unregister);\n\t\tdell_rbtn_notifier_unregister_func = NULL;\n\t} else {\n\t\ti8042_remove_filter(dell_laptop_i8042_filter);\n\t}\n\tcancel_delayed_work_sync(&dell_rfkill_work);\n\tif (wifi_rfkill) {\n\t\trfkill_unregister(wifi_rfkill);\n\t\trfkill_destroy(wifi_rfkill);\n\t}\n\tif (bluetooth_rfkill) {\n\t\trfkill_unregister(bluetooth_rfkill);\n\t\trfkill_destroy(bluetooth_rfkill);\n\t}\n\tif (wwan_rfkill) {\n\t\trfkill_unregister(wwan_rfkill);\n\t\trfkill_destroy(wwan_rfkill);\n\t}\n}\n\nstatic int dell_send_intensity(struct backlight_device *bd)\n{\n\tstruct calling_interface_buffer buffer;\n\tstruct calling_interface_token *token;\n\tint ret;\n\n\ttoken = dell_smbios_find_token(BRIGHTNESS_TOKEN);\n\tif (!token)\n\t\treturn -ENODEV;\n\n\tdell_fill_request(&buffer,\n\t\t\t   token->location, bd->props.brightness, 0, 0);\n\tif (power_supply_is_system_supplied() > 0)\n\t\tret = dell_send_request(&buffer,\n\t\t\t\t\tCLASS_TOKEN_WRITE, SELECT_TOKEN_AC);\n\telse\n\t\tret = dell_send_request(&buffer,\n\t\t\t\t\tCLASS_TOKEN_WRITE, SELECT_TOKEN_BAT);\n\n\treturn ret;\n}\n\nstatic int dell_get_intensity(struct backlight_device *bd)\n{\n\tstruct calling_interface_buffer buffer;\n\tstruct calling_interface_token *token;\n\tint ret;\n\n\ttoken = dell_smbios_find_token(BRIGHTNESS_TOKEN);\n\tif (!token)\n\t\treturn -ENODEV;\n\n\tdell_fill_request(&buffer, token->location, 0, 0, 0);\n\tif (power_supply_is_system_supplied() > 0)\n\t\tret = dell_send_request(&buffer,\n\t\t\t\t\tCLASS_TOKEN_READ, SELECT_TOKEN_AC);\n\telse\n\t\tret = dell_send_request(&buffer,\n\t\t\t\t\tCLASS_TOKEN_READ, SELECT_TOKEN_BAT);\n\n\tif (ret == 0)\n\t\tret = buffer.output[1];\n\n\treturn ret;\n}\n\nstatic const struct backlight_ops dell_ops = {\n\t.get_brightness = dell_get_intensity,\n\t.update_status  = dell_send_intensity,\n};\n\nstatic void touchpad_led_on(void)\n{\n\tint command = 0x97;\n\tchar data = 1;\n\ti8042_command(&data, command | 1 << 12);\n}\n\nstatic void touchpad_led_off(void)\n{\n\tint command = 0x97;\n\tchar data = 2;\n\ti8042_command(&data, command | 1 << 12);\n}\n\nstatic void touchpad_led_set(struct led_classdev *led_cdev,\n\tenum led_brightness value)\n{\n\tif (value > 0)\n\t\ttouchpad_led_on();\n\telse\n\t\ttouchpad_led_off();\n}\n\nstatic struct led_classdev touchpad_led = {\n\t.name = \"dell-laptop::touchpad\",\n\t.brightness_set = touchpad_led_set,\n\t.flags = LED_CORE_SUSPENDRESUME,\n};\n\nstatic int __init touchpad_led_init(struct device *dev)\n{\n\treturn led_classdev_register(dev, &touchpad_led);\n}\n\nstatic void touchpad_led_exit(void)\n{\n\tled_classdev_unregister(&touchpad_led);\n}\n\n \n\n\nenum kbd_timeout_unit {\n\tKBD_TIMEOUT_SECONDS = 0,\n\tKBD_TIMEOUT_MINUTES,\n\tKBD_TIMEOUT_HOURS,\n\tKBD_TIMEOUT_DAYS,\n};\n\nenum kbd_mode_bit {\n\tKBD_MODE_BIT_OFF = 0,\n\tKBD_MODE_BIT_ON,\n\tKBD_MODE_BIT_ALS,\n\tKBD_MODE_BIT_TRIGGER_ALS,\n\tKBD_MODE_BIT_TRIGGER,\n\tKBD_MODE_BIT_TRIGGER_25,\n\tKBD_MODE_BIT_TRIGGER_50,\n\tKBD_MODE_BIT_TRIGGER_75,\n\tKBD_MODE_BIT_TRIGGER_100,\n};\n\n#define kbd_is_als_mode_bit(bit) \\\n\t((bit) == KBD_MODE_BIT_ALS || (bit) == KBD_MODE_BIT_TRIGGER_ALS)\n#define kbd_is_trigger_mode_bit(bit) \\\n\t((bit) >= KBD_MODE_BIT_TRIGGER_ALS && (bit) <= KBD_MODE_BIT_TRIGGER_100)\n#define kbd_is_level_mode_bit(bit) \\\n\t((bit) >= KBD_MODE_BIT_TRIGGER_25 && (bit) <= KBD_MODE_BIT_TRIGGER_100)\n\nstruct kbd_info {\n\tu16 modes;\n\tu8 type;\n\tu8 triggers;\n\tu8 levels;\n\tu8 seconds;\n\tu8 minutes;\n\tu8 hours;\n\tu8 days;\n};\n\nstruct kbd_state {\n\tu8 mode_bit;\n\tu8 triggers;\n\tu8 timeout_value;\n\tu8 timeout_unit;\n\tu8 timeout_value_ac;\n\tu8 timeout_unit_ac;\n\tu8 als_setting;\n\tu8 als_value;\n\tu8 level;\n};\n\nstatic const int kbd_tokens[] = {\n\tKBD_LED_OFF_TOKEN,\n\tKBD_LED_AUTO_25_TOKEN,\n\tKBD_LED_AUTO_50_TOKEN,\n\tKBD_LED_AUTO_75_TOKEN,\n\tKBD_LED_AUTO_100_TOKEN,\n\tKBD_LED_ON_TOKEN,\n};\n\nstatic u16 kbd_token_bits;\n\nstatic struct kbd_info kbd_info;\nstatic bool kbd_als_supported;\nstatic bool kbd_triggers_supported;\nstatic bool kbd_timeout_ac_supported;\n\nstatic u8 kbd_mode_levels[16];\nstatic int kbd_mode_levels_count;\n\nstatic u8 kbd_previous_level;\nstatic u8 kbd_previous_mode_bit;\n\nstatic bool kbd_led_present;\nstatic DEFINE_MUTEX(kbd_led_mutex);\nstatic enum led_brightness kbd_led_level;\n\n \n\nstatic int kbd_get_info(struct kbd_info *info)\n{\n\tstruct calling_interface_buffer buffer;\n\tu8 units;\n\tint ret;\n\n\tdell_fill_request(&buffer, 0, 0, 0, 0);\n\tret = dell_send_request(&buffer,\n\t\t\t\tCLASS_KBD_BACKLIGHT, SELECT_KBD_BACKLIGHT);\n\tif (ret)\n\t\treturn ret;\n\n\tinfo->modes = buffer.output[1] & 0xFFFF;\n\tinfo->type = (buffer.output[1] >> 24) & 0xFF;\n\tinfo->triggers = buffer.output[2] & 0xFF;\n\tunits = (buffer.output[2] >> 8) & 0xFF;\n\tinfo->levels = (buffer.output[2] >> 16) & 0xFF;\n\n\tif (quirks && quirks->kbd_led_levels_off_1 && info->levels)\n\t\tinfo->levels--;\n\n\tif (units & BIT(0))\n\t\tinfo->seconds = (buffer.output[3] >> 0) & 0xFF;\n\tif (units & BIT(1))\n\t\tinfo->minutes = (buffer.output[3] >> 8) & 0xFF;\n\tif (units & BIT(2))\n\t\tinfo->hours = (buffer.output[3] >> 16) & 0xFF;\n\tif (units & BIT(3))\n\t\tinfo->days = (buffer.output[3] >> 24) & 0xFF;\n\n\treturn ret;\n}\n\nstatic unsigned int kbd_get_max_level(void)\n{\n\tif (kbd_info.levels != 0)\n\t\treturn kbd_info.levels;\n\tif (kbd_mode_levels_count > 0)\n\t\treturn kbd_mode_levels_count - 1;\n\treturn 0;\n}\n\nstatic int kbd_get_level(struct kbd_state *state)\n{\n\tint i;\n\n\tif (kbd_info.levels != 0)\n\t\treturn state->level;\n\n\tif (kbd_mode_levels_count > 0) {\n\t\tfor (i = 0; i < kbd_mode_levels_count; ++i)\n\t\t\tif (kbd_mode_levels[i] == state->mode_bit)\n\t\t\t\treturn i;\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int kbd_set_level(struct kbd_state *state, u8 level)\n{\n\tif (kbd_info.levels != 0) {\n\t\tif (level != 0)\n\t\t\tkbd_previous_level = level;\n\t\tif (state->level == level)\n\t\t\treturn 0;\n\t\tstate->level = level;\n\t\tif (level != 0 && state->mode_bit == KBD_MODE_BIT_OFF)\n\t\t\tstate->mode_bit = kbd_previous_mode_bit;\n\t\telse if (level == 0 && state->mode_bit != KBD_MODE_BIT_OFF) {\n\t\t\tkbd_previous_mode_bit = state->mode_bit;\n\t\t\tstate->mode_bit = KBD_MODE_BIT_OFF;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (kbd_mode_levels_count > 0 && level < kbd_mode_levels_count) {\n\t\tif (level != 0)\n\t\t\tkbd_previous_level = level;\n\t\tstate->mode_bit = kbd_mode_levels[level];\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int kbd_get_state(struct kbd_state *state)\n{\n\tstruct calling_interface_buffer buffer;\n\tint ret;\n\n\tdell_fill_request(&buffer, 0x1, 0, 0, 0);\n\tret = dell_send_request(&buffer,\n\t\t\t\tCLASS_KBD_BACKLIGHT, SELECT_KBD_BACKLIGHT);\n\tif (ret)\n\t\treturn ret;\n\n\tstate->mode_bit = ffs(buffer.output[1] & 0xFFFF);\n\tif (state->mode_bit != 0)\n\t\tstate->mode_bit--;\n\n\tstate->triggers = (buffer.output[1] >> 16) & 0xFF;\n\tstate->timeout_value = (buffer.output[1] >> 24) & 0x3F;\n\tstate->timeout_unit = (buffer.output[1] >> 30) & 0x3;\n\tstate->als_setting = buffer.output[2] & 0xFF;\n\tstate->als_value = (buffer.output[2] >> 8) & 0xFF;\n\tstate->level = (buffer.output[2] >> 16) & 0xFF;\n\tstate->timeout_value_ac = (buffer.output[2] >> 24) & 0x3F;\n\tstate->timeout_unit_ac = (buffer.output[2] >> 30) & 0x3;\n\n\treturn ret;\n}\n\nstatic int kbd_set_state(struct kbd_state *state)\n{\n\tstruct calling_interface_buffer buffer;\n\tint ret;\n\tu32 input1;\n\tu32 input2;\n\n\tinput1 = BIT(state->mode_bit) & 0xFFFF;\n\tinput1 |= (state->triggers & 0xFF) << 16;\n\tinput1 |= (state->timeout_value & 0x3F) << 24;\n\tinput1 |= (state->timeout_unit & 0x3) << 30;\n\tinput2 = state->als_setting & 0xFF;\n\tinput2 |= (state->level & 0xFF) << 16;\n\tinput2 |= (state->timeout_value_ac & 0x3F) << 24;\n\tinput2 |= (state->timeout_unit_ac & 0x3) << 30;\n\tdell_fill_request(&buffer, 0x2, input1, input2, 0);\n\tret = dell_send_request(&buffer,\n\t\t\t\tCLASS_KBD_BACKLIGHT, SELECT_KBD_BACKLIGHT);\n\n\treturn ret;\n}\n\nstatic int kbd_set_state_safe(struct kbd_state *state, struct kbd_state *old)\n{\n\tint ret;\n\n\tret = kbd_set_state(state);\n\tif (ret == 0)\n\t\treturn 0;\n\n\t \n\n\tif (kbd_set_state(old))\n\t\tpr_err(\"Setting old previous keyboard state failed\\n\");\n\n\treturn ret;\n}\n\nstatic int kbd_set_token_bit(u8 bit)\n{\n\tstruct calling_interface_buffer buffer;\n\tstruct calling_interface_token *token;\n\tint ret;\n\n\tif (bit >= ARRAY_SIZE(kbd_tokens))\n\t\treturn -EINVAL;\n\n\ttoken = dell_smbios_find_token(kbd_tokens[bit]);\n\tif (!token)\n\t\treturn -EINVAL;\n\n\tdell_fill_request(&buffer, token->location, token->value, 0, 0);\n\tret = dell_send_request(&buffer, CLASS_TOKEN_WRITE, SELECT_TOKEN_STD);\n\n\treturn ret;\n}\n\nstatic int kbd_get_token_bit(u8 bit)\n{\n\tstruct calling_interface_buffer buffer;\n\tstruct calling_interface_token *token;\n\tint ret;\n\tint val;\n\n\tif (bit >= ARRAY_SIZE(kbd_tokens))\n\t\treturn -EINVAL;\n\n\ttoken = dell_smbios_find_token(kbd_tokens[bit]);\n\tif (!token)\n\t\treturn -EINVAL;\n\n\tdell_fill_request(&buffer, token->location, 0, 0, 0);\n\tret = dell_send_request(&buffer, CLASS_TOKEN_READ, SELECT_TOKEN_STD);\n\tval = buffer.output[1];\n\n\tif (ret)\n\t\treturn ret;\n\n\treturn (val == token->value);\n}\n\nstatic int kbd_get_first_active_token_bit(void)\n{\n\tint i;\n\tint ret;\n\n\tfor (i = 0; i < ARRAY_SIZE(kbd_tokens); ++i) {\n\t\tret = kbd_get_token_bit(i);\n\t\tif (ret == 1)\n\t\t\treturn i;\n\t}\n\n\treturn ret;\n}\n\nstatic int kbd_get_valid_token_counts(void)\n{\n\treturn hweight16(kbd_token_bits);\n}\n\nstatic inline int kbd_init_info(void)\n{\n\tstruct kbd_state state;\n\tint ret;\n\tint i;\n\n\tret = kbd_get_info(&kbd_info);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif ((quirks && quirks->kbd_missing_ac_tag) ||\n\t    dell_smbios_find_token(KBD_LED_AC_TOKEN))\n\t\tkbd_timeout_ac_supported = true;\n\n\tkbd_get_state(&state);\n\n\t \n\tif (kbd_info.seconds > 63)\n\t\tkbd_info.seconds = 63;\n\tif (kbd_info.minutes > 63)\n\t\tkbd_info.minutes = 63;\n\tif (kbd_info.hours > 63)\n\t\tkbd_info.hours = 63;\n\tif (kbd_info.days > 63)\n\t\tkbd_info.days = 63;\n\n\t \n\tkbd_info.modes &= ~BIT(KBD_MODE_BIT_ON);\n\n\tkbd_previous_level = kbd_get_level(&state);\n\tkbd_previous_mode_bit = state.mode_bit;\n\n\tif (kbd_previous_level == 0 && kbd_get_max_level() != 0)\n\t\tkbd_previous_level = 1;\n\n\tif (kbd_previous_mode_bit == KBD_MODE_BIT_OFF) {\n\t\tkbd_previous_mode_bit =\n\t\t\tffs(kbd_info.modes & ~BIT(KBD_MODE_BIT_OFF));\n\t\tif (kbd_previous_mode_bit != 0)\n\t\t\tkbd_previous_mode_bit--;\n\t}\n\n\tif (kbd_info.modes & (BIT(KBD_MODE_BIT_ALS) |\n\t\t\t      BIT(KBD_MODE_BIT_TRIGGER_ALS)))\n\t\tkbd_als_supported = true;\n\n\tif (kbd_info.modes & (\n\t    BIT(KBD_MODE_BIT_TRIGGER_ALS) | BIT(KBD_MODE_BIT_TRIGGER) |\n\t    BIT(KBD_MODE_BIT_TRIGGER_25) | BIT(KBD_MODE_BIT_TRIGGER_50) |\n\t    BIT(KBD_MODE_BIT_TRIGGER_75) | BIT(KBD_MODE_BIT_TRIGGER_100)\n\t   ))\n\t\tkbd_triggers_supported = true;\n\n\t \n\tfor (i = 0; i < 16; ++i)\n\t\tif (kbd_is_level_mode_bit(i) && (BIT(i) & kbd_info.modes))\n\t\t\tkbd_mode_levels[1 + kbd_mode_levels_count++] = i;\n\n\t \n\tif (kbd_mode_levels_count > 0) {\n\t\tfor (i = 0; i < 16; ++i) {\n\t\t\tif (BIT(i) & kbd_info.modes) {\n\t\t\t\tkbd_mode_levels[0] = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tkbd_mode_levels_count++;\n\t}\n\n\treturn 0;\n\n}\n\nstatic inline void kbd_init_tokens(void)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(kbd_tokens); ++i)\n\t\tif (dell_smbios_find_token(kbd_tokens[i]))\n\t\t\tkbd_token_bits |= BIT(i);\n}\n\nstatic void kbd_init(void)\n{\n\tint ret;\n\n\tif (quirks && quirks->kbd_led_not_present)\n\t\treturn;\n\n\tret = kbd_init_info();\n\tkbd_init_tokens();\n\n\t \n\tif ((ret == 0 && (kbd_info.levels != 0 || kbd_mode_levels_count >= 2))\n\t    || kbd_get_valid_token_counts() >= 2)\n\t\tkbd_led_present = true;\n}\n\nstatic ssize_t kbd_led_timeout_store(struct device *dev,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     const char *buf, size_t count)\n{\n\tstruct kbd_state new_state;\n\tstruct kbd_state state;\n\tbool convert;\n\tint value;\n\tint ret;\n\tchar ch;\n\tu8 unit;\n\tint i;\n\n\tret = sscanf(buf, \"%d %c\", &value, &ch);\n\tif (ret < 1)\n\t\treturn -EINVAL;\n\telse if (ret == 1)\n\t\tch = 's';\n\n\tif (value < 0)\n\t\treturn -EINVAL;\n\n\tconvert = false;\n\n\tswitch (ch) {\n\tcase 's':\n\t\tif (value > kbd_info.seconds)\n\t\t\tconvert = true;\n\t\tunit = KBD_TIMEOUT_SECONDS;\n\t\tbreak;\n\tcase 'm':\n\t\tif (value > kbd_info.minutes)\n\t\t\tconvert = true;\n\t\tunit = KBD_TIMEOUT_MINUTES;\n\t\tbreak;\n\tcase 'h':\n\t\tif (value > kbd_info.hours)\n\t\t\tconvert = true;\n\t\tunit = KBD_TIMEOUT_HOURS;\n\t\tbreak;\n\tcase 'd':\n\t\tif (value > kbd_info.days)\n\t\t\tconvert = true;\n\t\tunit = KBD_TIMEOUT_DAYS;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (quirks && quirks->needs_kbd_timeouts)\n\t\tconvert = true;\n\n\tif (convert) {\n\t\t \n\t\tswitch (unit) {\n\t\tcase KBD_TIMEOUT_DAYS:\n\t\t\tvalue *= 24;\n\t\t\tfallthrough;\n\t\tcase KBD_TIMEOUT_HOURS:\n\t\t\tvalue *= 60;\n\t\t\tfallthrough;\n\t\tcase KBD_TIMEOUT_MINUTES:\n\t\t\tvalue *= 60;\n\t\t\tunit = KBD_TIMEOUT_SECONDS;\n\t\t}\n\n\t\tif (quirks && quirks->needs_kbd_timeouts) {\n\t\t\tfor (i = 0; quirks->kbd_timeouts[i] != -1; i++) {\n\t\t\t\tif (value <= quirks->kbd_timeouts[i]) {\n\t\t\t\t\tvalue = quirks->kbd_timeouts[i];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (value <= kbd_info.seconds && kbd_info.seconds) {\n\t\t\tunit = KBD_TIMEOUT_SECONDS;\n\t\t} else if (value / 60 <= kbd_info.minutes && kbd_info.minutes) {\n\t\t\tvalue /= 60;\n\t\t\tunit = KBD_TIMEOUT_MINUTES;\n\t\t} else if (value / (60 * 60) <= kbd_info.hours && kbd_info.hours) {\n\t\t\tvalue /= (60 * 60);\n\t\t\tunit = KBD_TIMEOUT_HOURS;\n\t\t} else if (value / (60 * 60 * 24) <= kbd_info.days && kbd_info.days) {\n\t\t\tvalue /= (60 * 60 * 24);\n\t\t\tunit = KBD_TIMEOUT_DAYS;\n\t\t} else {\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tmutex_lock(&kbd_led_mutex);\n\n\tret = kbd_get_state(&state);\n\tif (ret)\n\t\tgoto out;\n\n\tnew_state = state;\n\n\tif (kbd_timeout_ac_supported && power_supply_is_system_supplied() > 0) {\n\t\tnew_state.timeout_value_ac = value;\n\t\tnew_state.timeout_unit_ac = unit;\n\t} else {\n\t\tnew_state.timeout_value = value;\n\t\tnew_state.timeout_unit = unit;\n\t}\n\n\tret = kbd_set_state_safe(&new_state, &state);\n\tif (ret)\n\t\tgoto out;\n\n\tret = count;\nout:\n\tmutex_unlock(&kbd_led_mutex);\n\treturn ret;\n}\n\nstatic ssize_t kbd_led_timeout_show(struct device *dev,\n\t\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct kbd_state state;\n\tint value;\n\tint ret;\n\tint len;\n\tu8 unit;\n\n\tret = kbd_get_state(&state);\n\tif (ret)\n\t\treturn ret;\n\n\tif (kbd_timeout_ac_supported && power_supply_is_system_supplied() > 0) {\n\t\tvalue = state.timeout_value_ac;\n\t\tunit = state.timeout_unit_ac;\n\t} else {\n\t\tvalue = state.timeout_value;\n\t\tunit = state.timeout_unit;\n\t}\n\n\tlen = sprintf(buf, \"%d\", value);\n\n\tswitch (unit) {\n\tcase KBD_TIMEOUT_SECONDS:\n\t\treturn len + sprintf(buf+len, \"s\\n\");\n\tcase KBD_TIMEOUT_MINUTES:\n\t\treturn len + sprintf(buf+len, \"m\\n\");\n\tcase KBD_TIMEOUT_HOURS:\n\t\treturn len + sprintf(buf+len, \"h\\n\");\n\tcase KBD_TIMEOUT_DAYS:\n\t\treturn len + sprintf(buf+len, \"d\\n\");\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn len;\n}\n\nstatic DEVICE_ATTR(stop_timeout, S_IRUGO | S_IWUSR,\n\t\t   kbd_led_timeout_show, kbd_led_timeout_store);\n\nstatic const char * const kbd_led_triggers[] = {\n\t\"keyboard\",\n\t\"touchpad\",\n\t  NULL,  \n\t\"mouse\",\n};\n\nstatic ssize_t kbd_led_triggers_store(struct device *dev,\n\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t      const char *buf, size_t count)\n{\n\tstruct kbd_state new_state;\n\tstruct kbd_state state;\n\tbool triggers_enabled = false;\n\tint trigger_bit = -1;\n\tchar trigger[21];\n\tint i, ret;\n\n\tret = sscanf(buf, \"%20s\", trigger);\n\tif (ret != 1)\n\t\treturn -EINVAL;\n\n\tif (trigger[0] != '+' && trigger[0] != '-')\n\t\treturn -EINVAL;\n\n\tmutex_lock(&kbd_led_mutex);\n\n\tret = kbd_get_state(&state);\n\tif (ret)\n\t\tgoto out;\n\n\tif (kbd_triggers_supported)\n\t\ttriggers_enabled = kbd_is_trigger_mode_bit(state.mode_bit);\n\n\tif (kbd_triggers_supported) {\n\t\tfor (i = 0; i < ARRAY_SIZE(kbd_led_triggers); ++i) {\n\t\t\tif (!(kbd_info.triggers & BIT(i)))\n\t\t\t\tcontinue;\n\t\t\tif (!kbd_led_triggers[i])\n\t\t\t\tcontinue;\n\t\t\tif (strcmp(trigger+1, kbd_led_triggers[i]) != 0)\n\t\t\t\tcontinue;\n\t\t\tif (trigger[0] == '+' &&\n\t\t\t    triggers_enabled && (state.triggers & BIT(i))) {\n\t\t\t\tret = count;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (trigger[0] == '-' &&\n\t\t\t    (!triggers_enabled || !(state.triggers & BIT(i)))) {\n\t\t\t\tret = count;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\ttrigger_bit = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (trigger_bit == -1) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tnew_state = state;\n\tif (trigger[0] == '+')\n\t\tnew_state.triggers |= BIT(trigger_bit);\n\telse {\n\t\tnew_state.triggers &= ~BIT(trigger_bit);\n\t\t \n\t\tif (trigger_bit == 1)\n\t\t\tnew_state.triggers &= ~BIT(2);\n\t}\n\tif ((kbd_info.triggers & new_state.triggers) !=\n\t    new_state.triggers) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (new_state.triggers && !triggers_enabled) {\n\t\tnew_state.mode_bit = KBD_MODE_BIT_TRIGGER;\n\t\tkbd_set_level(&new_state, kbd_previous_level);\n\t} else if (new_state.triggers == 0) {\n\t\tkbd_set_level(&new_state, 0);\n\t}\n\tif (!(kbd_info.modes & BIT(new_state.mode_bit))) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tret = kbd_set_state_safe(&new_state, &state);\n\tif (ret)\n\t\tgoto out;\n\tif (new_state.mode_bit != KBD_MODE_BIT_OFF)\n\t\tkbd_previous_mode_bit = new_state.mode_bit;\n\tret = count;\nout:\n\tmutex_unlock(&kbd_led_mutex);\n\treturn ret;\n}\n\nstatic ssize_t kbd_led_triggers_show(struct device *dev,\n\t\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct kbd_state state;\n\tbool triggers_enabled;\n\tint level, i, ret;\n\tint len = 0;\n\n\tret = kbd_get_state(&state);\n\tif (ret)\n\t\treturn ret;\n\n\tlen = 0;\n\n\tif (kbd_triggers_supported) {\n\t\ttriggers_enabled = kbd_is_trigger_mode_bit(state.mode_bit);\n\t\tlevel = kbd_get_level(&state);\n\t\tfor (i = 0; i < ARRAY_SIZE(kbd_led_triggers); ++i) {\n\t\t\tif (!(kbd_info.triggers & BIT(i)))\n\t\t\t\tcontinue;\n\t\t\tif (!kbd_led_triggers[i])\n\t\t\t\tcontinue;\n\t\t\tif ((triggers_enabled || level <= 0) &&\n\t\t\t    (state.triggers & BIT(i)))\n\t\t\t\tbuf[len++] = '+';\n\t\t\telse\n\t\t\t\tbuf[len++] = '-';\n\t\t\tlen += sprintf(buf+len, \"%s \", kbd_led_triggers[i]);\n\t\t}\n\t}\n\n\tif (len)\n\t\tbuf[len - 1] = '\\n';\n\n\treturn len;\n}\n\nstatic DEVICE_ATTR(start_triggers, S_IRUGO | S_IWUSR,\n\t\t   kbd_led_triggers_show, kbd_led_triggers_store);\n\nstatic ssize_t kbd_led_als_enabled_store(struct device *dev,\n\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t const char *buf, size_t count)\n{\n\tstruct kbd_state new_state;\n\tstruct kbd_state state;\n\tbool triggers_enabled = false;\n\tint enable;\n\tint ret;\n\n\tret = kstrtoint(buf, 0, &enable);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&kbd_led_mutex);\n\n\tret = kbd_get_state(&state);\n\tif (ret)\n\t\tgoto out;\n\n\tif (enable == kbd_is_als_mode_bit(state.mode_bit)) {\n\t\tret = count;\n\t\tgoto out;\n\t}\n\n\tnew_state = state;\n\n\tif (kbd_triggers_supported)\n\t\ttriggers_enabled = kbd_is_trigger_mode_bit(state.mode_bit);\n\n\tif (enable) {\n\t\tif (triggers_enabled)\n\t\t\tnew_state.mode_bit = KBD_MODE_BIT_TRIGGER_ALS;\n\t\telse\n\t\t\tnew_state.mode_bit = KBD_MODE_BIT_ALS;\n\t} else {\n\t\tif (triggers_enabled) {\n\t\t\tnew_state.mode_bit = KBD_MODE_BIT_TRIGGER;\n\t\t\tkbd_set_level(&new_state, kbd_previous_level);\n\t\t} else {\n\t\t\tnew_state.mode_bit = KBD_MODE_BIT_ON;\n\t\t}\n\t}\n\tif (!(kbd_info.modes & BIT(new_state.mode_bit)))  {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = kbd_set_state_safe(&new_state, &state);\n\tif (ret)\n\t\tgoto out;\n\tkbd_previous_mode_bit = new_state.mode_bit;\n\n\tret = count;\nout:\n\tmutex_unlock(&kbd_led_mutex);\n\treturn ret;\n}\n\nstatic ssize_t kbd_led_als_enabled_show(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tstruct kbd_state state;\n\tbool enabled = false;\n\tint ret;\n\n\tret = kbd_get_state(&state);\n\tif (ret)\n\t\treturn ret;\n\tenabled = kbd_is_als_mode_bit(state.mode_bit);\n\n\treturn sprintf(buf, \"%d\\n\", enabled ? 1 : 0);\n}\n\nstatic DEVICE_ATTR(als_enabled, S_IRUGO | S_IWUSR,\n\t\t   kbd_led_als_enabled_show, kbd_led_als_enabled_store);\n\nstatic ssize_t kbd_led_als_setting_store(struct device *dev,\n\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t const char *buf, size_t count)\n{\n\tstruct kbd_state state;\n\tstruct kbd_state new_state;\n\tu8 setting;\n\tint ret;\n\n\tret = kstrtou8(buf, 10, &setting);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&kbd_led_mutex);\n\n\tret = kbd_get_state(&state);\n\tif (ret)\n\t\tgoto out;\n\n\tnew_state = state;\n\tnew_state.als_setting = setting;\n\n\tret = kbd_set_state_safe(&new_state, &state);\n\tif (ret)\n\t\tgoto out;\n\n\tret = count;\nout:\n\tmutex_unlock(&kbd_led_mutex);\n\treturn ret;\n}\n\nstatic ssize_t kbd_led_als_setting_show(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tstruct kbd_state state;\n\tint ret;\n\n\tret = kbd_get_state(&state);\n\tif (ret)\n\t\treturn ret;\n\n\treturn sprintf(buf, \"%d\\n\", state.als_setting);\n}\n\nstatic DEVICE_ATTR(als_setting, S_IRUGO | S_IWUSR,\n\t\t   kbd_led_als_setting_show, kbd_led_als_setting_store);\n\nstatic struct attribute *kbd_led_attrs[] = {\n\t&dev_attr_stop_timeout.attr,\n\t&dev_attr_start_triggers.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group kbd_led_group = {\n\t.attrs = kbd_led_attrs,\n};\n\nstatic struct attribute *kbd_led_als_attrs[] = {\n\t&dev_attr_als_enabled.attr,\n\t&dev_attr_als_setting.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group kbd_led_als_group = {\n\t.attrs = kbd_led_als_attrs,\n};\n\nstatic const struct attribute_group *kbd_led_groups[] = {\n\t&kbd_led_group,\n\t&kbd_led_als_group,\n\tNULL,\n};\n\nstatic enum led_brightness kbd_led_level_get(struct led_classdev *led_cdev)\n{\n\tint ret;\n\tu16 num;\n\tstruct kbd_state state;\n\n\tif (kbd_get_max_level()) {\n\t\tret = kbd_get_state(&state);\n\t\tif (ret)\n\t\t\treturn 0;\n\t\tret = kbd_get_level(&state);\n\t\tif (ret < 0)\n\t\t\treturn 0;\n\t\treturn ret;\n\t}\n\n\tif (kbd_get_valid_token_counts()) {\n\t\tret = kbd_get_first_active_token_bit();\n\t\tif (ret < 0)\n\t\t\treturn 0;\n\t\tfor (num = kbd_token_bits; num != 0 && ret > 0; --ret)\n\t\t\tnum &= num - 1;  \n\t\tif (num == 0)\n\t\t\treturn 0;\n\t\treturn ffs(num) - 1;\n\t}\n\n\tpr_warn(\"Keyboard brightness level control not supported\\n\");\n\treturn 0;\n}\n\nstatic int kbd_led_level_set(struct led_classdev *led_cdev,\n\t\t\t     enum led_brightness value)\n{\n\tenum led_brightness new_value = value;\n\tstruct kbd_state state;\n\tstruct kbd_state new_state;\n\tu16 num;\n\tint ret;\n\n\tmutex_lock(&kbd_led_mutex);\n\n\tif (kbd_get_max_level()) {\n\t\tret = kbd_get_state(&state);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tnew_state = state;\n\t\tret = kbd_set_level(&new_state, value);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tret = kbd_set_state_safe(&new_state, &state);\n\t} else if (kbd_get_valid_token_counts()) {\n\t\tfor (num = kbd_token_bits; num != 0 && value > 0; --value)\n\t\t\tnum &= num - 1;  \n\t\tif (num == 0)\n\t\t\tret = 0;\n\t\telse\n\t\t\tret = kbd_set_token_bit(ffs(num) - 1);\n\t} else {\n\t\tpr_warn(\"Keyboard brightness level control not supported\\n\");\n\t\tret = -ENXIO;\n\t}\n\nout:\n\tif (ret == 0)\n\t\tkbd_led_level = new_value;\n\n\tmutex_unlock(&kbd_led_mutex);\n\treturn ret;\n}\n\nstatic struct led_classdev kbd_led = {\n\t.name           = \"dell::kbd_backlight\",\n\t.flags\t\t= LED_BRIGHT_HW_CHANGED,\n\t.brightness_set_blocking = kbd_led_level_set,\n\t.brightness_get = kbd_led_level_get,\n\t.groups         = kbd_led_groups,\n};\n\nstatic int __init kbd_led_init(struct device *dev)\n{\n\tint ret;\n\n\tkbd_init();\n\tif (!kbd_led_present)\n\t\treturn -ENODEV;\n\tif (!kbd_als_supported)\n\t\tkbd_led_groups[1] = NULL;\n\tkbd_led.max_brightness = kbd_get_max_level();\n\tif (!kbd_led.max_brightness) {\n\t\tkbd_led.max_brightness = kbd_get_valid_token_counts();\n\t\tif (kbd_led.max_brightness)\n\t\t\tkbd_led.max_brightness--;\n\t}\n\n\tkbd_led_level = kbd_led_level_get(NULL);\n\n\tret = led_classdev_register(dev, &kbd_led);\n\tif (ret)\n\t\tkbd_led_present = false;\n\n\treturn ret;\n}\n\nstatic void brightness_set_exit(struct led_classdev *led_cdev,\n\t\t\t\tenum led_brightness value)\n{\n\t \n};\n\nstatic void kbd_led_exit(void)\n{\n\tif (!kbd_led_present)\n\t\treturn;\n\tkbd_led.brightness_set = brightness_set_exit;\n\tled_classdev_unregister(&kbd_led);\n}\n\nstatic int dell_laptop_notifier_call(struct notifier_block *nb,\n\t\t\t\t     unsigned long action, void *data)\n{\n\tbool changed = false;\n\tenum led_brightness new_kbd_led_level;\n\n\tswitch (action) {\n\tcase DELL_LAPTOP_KBD_BACKLIGHT_BRIGHTNESS_CHANGED:\n\t\tif (!kbd_led_present)\n\t\t\tbreak;\n\n\t\tmutex_lock(&kbd_led_mutex);\n\t\tnew_kbd_led_level = kbd_led_level_get(&kbd_led);\n\t\tif (kbd_led_level != new_kbd_led_level) {\n\t\t\tkbd_led_level = new_kbd_led_level;\n\t\t\tchanged = true;\n\t\t}\n\t\tmutex_unlock(&kbd_led_mutex);\n\n\t\tif (changed)\n\t\t\tled_classdev_notify_brightness_hw_changed(&kbd_led,\n\t\t\t\t\t\t\t\tkbd_led_level);\n\t\tbreak;\n\t}\n\n\treturn NOTIFY_OK;\n}\n\nstatic struct notifier_block dell_laptop_notifier = {\n\t.notifier_call = dell_laptop_notifier_call,\n};\n\nstatic int micmute_led_set(struct led_classdev *led_cdev,\n\t\t\t   enum led_brightness brightness)\n{\n\tstruct calling_interface_buffer buffer;\n\tstruct calling_interface_token *token;\n\tint state = brightness != LED_OFF;\n\n\tif (state == 0)\n\t\ttoken = dell_smbios_find_token(GLOBAL_MIC_MUTE_DISABLE);\n\telse\n\t\ttoken = dell_smbios_find_token(GLOBAL_MIC_MUTE_ENABLE);\n\n\tif (!token)\n\t\treturn -ENODEV;\n\n\tdell_fill_request(&buffer, token->location, token->value, 0, 0);\n\tdell_send_request(&buffer, CLASS_TOKEN_WRITE, SELECT_TOKEN_STD);\n\n\treturn 0;\n}\n\nstatic struct led_classdev micmute_led_cdev = {\n\t.name = \"platform::micmute\",\n\t.max_brightness = 1,\n\t.brightness_set_blocking = micmute_led_set,\n\t.default_trigger = \"audio-micmute\",\n};\n\nstatic int mute_led_set(struct led_classdev *led_cdev,\n\t\t\t   enum led_brightness brightness)\n{\n\tstruct calling_interface_buffer buffer;\n\tstruct calling_interface_token *token;\n\tint state = brightness != LED_OFF;\n\n\tif (state == 0)\n\t\ttoken = dell_smbios_find_token(GLOBAL_MUTE_DISABLE);\n\telse\n\t\ttoken = dell_smbios_find_token(GLOBAL_MUTE_ENABLE);\n\n\tif (!token)\n\t\treturn -ENODEV;\n\n\tdell_fill_request(&buffer, token->location, token->value, 0, 0);\n\tdell_send_request(&buffer, CLASS_TOKEN_WRITE, SELECT_TOKEN_STD);\n\n\treturn 0;\n}\n\nstatic struct led_classdev mute_led_cdev = {\n\t.name = \"platform::mute\",\n\t.max_brightness = 1,\n\t.brightness_set_blocking = mute_led_set,\n\t.default_trigger = \"audio-mute\",\n};\n\nstatic int __init dell_init(void)\n{\n\tstruct calling_interface_token *token;\n\tint max_intensity = 0;\n\tint ret;\n\n\tif (!dmi_check_system(dell_device_table))\n\t\treturn -ENODEV;\n\n\tquirks = NULL;\n\t \n\tdmi_check_system(dell_quirks);\n\n\tret = platform_driver_register(&platform_driver);\n\tif (ret)\n\t\tgoto fail_platform_driver;\n\tplatform_device = platform_device_alloc(\"dell-laptop\", PLATFORM_DEVID_NONE);\n\tif (!platform_device) {\n\t\tret = -ENOMEM;\n\t\tgoto fail_platform_device1;\n\t}\n\tret = platform_device_add(platform_device);\n\tif (ret)\n\t\tgoto fail_platform_device2;\n\n\tret = dell_setup_rfkill();\n\n\tif (ret) {\n\t\tpr_warn(\"Unable to setup rfkill\\n\");\n\t\tgoto fail_rfkill;\n\t}\n\n\tif (quirks && quirks->touchpad_led)\n\t\ttouchpad_led_init(&platform_device->dev);\n\n\tkbd_led_init(&platform_device->dev);\n\n\tdell_laptop_dir = debugfs_create_dir(\"dell_laptop\", NULL);\n\tdebugfs_create_file(\"rfkill\", 0444, dell_laptop_dir, NULL,\n\t\t\t    &dell_debugfs_fops);\n\n\tdell_laptop_register_notifier(&dell_laptop_notifier);\n\n\tif (dell_smbios_find_token(GLOBAL_MIC_MUTE_DISABLE) &&\n\t    dell_smbios_find_token(GLOBAL_MIC_MUTE_ENABLE) &&\n\t    !dell_privacy_has_mic_mute()) {\n\t\tmicmute_led_cdev.brightness = ledtrig_audio_get(LED_AUDIO_MICMUTE);\n\t\tret = led_classdev_register(&platform_device->dev, &micmute_led_cdev);\n\t\tif (ret < 0)\n\t\t\tgoto fail_led;\n\t\tmicmute_led_registered = true;\n\t}\n\n\tif (dell_smbios_find_token(GLOBAL_MUTE_DISABLE) &&\n\t    dell_smbios_find_token(GLOBAL_MUTE_ENABLE)) {\n\t\tmute_led_cdev.brightness = ledtrig_audio_get(LED_AUDIO_MUTE);\n\t\tret = led_classdev_register(&platform_device->dev, &mute_led_cdev);\n\t\tif (ret < 0)\n\t\t\tgoto fail_backlight;\n\t\tmute_led_registered = true;\n\t}\n\n\tif (acpi_video_get_backlight_type() != acpi_backlight_vendor)\n\t\treturn 0;\n\n\ttoken = dell_smbios_find_token(BRIGHTNESS_TOKEN);\n\tif (token) {\n\t\tstruct calling_interface_buffer buffer;\n\n\t\tdell_fill_request(&buffer, token->location, 0, 0, 0);\n\t\tret = dell_send_request(&buffer,\n\t\t\t\t\tCLASS_TOKEN_READ, SELECT_TOKEN_AC);\n\t\tif (ret == 0)\n\t\t\tmax_intensity = buffer.output[3];\n\t}\n\n\tif (max_intensity) {\n\t\tstruct backlight_properties props;\n\t\tmemset(&props, 0, sizeof(struct backlight_properties));\n\t\tprops.type = BACKLIGHT_PLATFORM;\n\t\tprops.max_brightness = max_intensity;\n\t\tdell_backlight_device = backlight_device_register(\"dell_backlight\",\n\t\t\t\t\t\t\t\t  &platform_device->dev,\n\t\t\t\t\t\t\t\t  NULL,\n\t\t\t\t\t\t\t\t  &dell_ops,\n\t\t\t\t\t\t\t\t  &props);\n\n\t\tif (IS_ERR(dell_backlight_device)) {\n\t\t\tret = PTR_ERR(dell_backlight_device);\n\t\t\tdell_backlight_device = NULL;\n\t\t\tgoto fail_backlight;\n\t\t}\n\n\t\tdell_backlight_device->props.brightness =\n\t\t\tdell_get_intensity(dell_backlight_device);\n\t\tif (dell_backlight_device->props.brightness < 0) {\n\t\t\tret = dell_backlight_device->props.brightness;\n\t\t\tgoto fail_get_brightness;\n\t\t}\n\t\tbacklight_update_status(dell_backlight_device);\n\t}\n\n\treturn 0;\n\nfail_get_brightness:\n\tbacklight_device_unregister(dell_backlight_device);\nfail_backlight:\n\tif (micmute_led_registered)\n\t\tled_classdev_unregister(&micmute_led_cdev);\n\tif (mute_led_registered)\n\t\tled_classdev_unregister(&mute_led_cdev);\nfail_led:\n\tdell_cleanup_rfkill();\nfail_rfkill:\n\tplatform_device_del(platform_device);\nfail_platform_device2:\n\tplatform_device_put(platform_device);\nfail_platform_device1:\n\tplatform_driver_unregister(&platform_driver);\nfail_platform_driver:\n\treturn ret;\n}\n\nstatic void __exit dell_exit(void)\n{\n\tdell_laptop_unregister_notifier(&dell_laptop_notifier);\n\tdebugfs_remove_recursive(dell_laptop_dir);\n\tif (quirks && quirks->touchpad_led)\n\t\ttouchpad_led_exit();\n\tkbd_led_exit();\n\tbacklight_device_unregister(dell_backlight_device);\n\tif (micmute_led_registered)\n\t\tled_classdev_unregister(&micmute_led_cdev);\n\tif (mute_led_registered)\n\t\tled_classdev_unregister(&mute_led_cdev);\n\tdell_cleanup_rfkill();\n\tif (platform_device) {\n\t\tplatform_device_unregister(platform_device);\n\t\tplatform_driver_unregister(&platform_driver);\n\t}\n}\n\n \nlate_initcall(dell_init);\nmodule_exit(dell_exit);\n\nMODULE_AUTHOR(\"Matthew Garrett <mjg@redhat.com>\");\nMODULE_AUTHOR(\"Gabriele Mazzotta <gabriele.mzt@gmail.com>\");\nMODULE_AUTHOR(\"Pali Roh\u00e1r <pali@kernel.org>\");\nMODULE_DESCRIPTION(\"Dell laptop driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}