{
  "module_name": "biosattr-interface.c",
  "hash_id": "fd3ed1c1a62ccd8b6ec247622b88ecdbe5b0bf1ca2be78bdab707fc553690f09",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/x86/dell/dell-wmi-sysman/biosattr-interface.c",
  "human_readable_source": "\n \n\n#include <linux/wmi.h>\n#include \"dell-wmi-sysman.h\"\n\n#define SETDEFAULTVALUES_METHOD_ID\t\t\t\t\t0x02\n#define SETBIOSDEFAULTS_METHOD_ID\t\t\t\t\t0x03\n#define SETATTRIBUTE_METHOD_ID\t\t\t\t\t\t0x04\n\nstatic int call_biosattributes_interface(struct wmi_device *wdev, char *in_args, size_t size,\n\t\t\t\t\tint method_id)\n{\n\tstruct acpi_buffer output = {ACPI_ALLOCATE_BUFFER, NULL};\n\tstruct acpi_buffer input;\n\tunion acpi_object *obj;\n\tacpi_status status;\n\tint ret = -EIO;\n\n\tinput.length =  (acpi_size) size;\n\tinput.pointer = in_args;\n\tstatus = wmidev_evaluate_method(wdev, 0, method_id, &input, &output);\n\tif (ACPI_FAILURE(status))\n\t\treturn -EIO;\n\tobj = (union acpi_object *)output.pointer;\n\tif (obj->type == ACPI_TYPE_INTEGER)\n\t\tret = obj->integer.value;\n\n\tif (wmi_priv.pending_changes == 0) {\n\t\twmi_priv.pending_changes = 1;\n\t\t \n\t\tkobject_uevent(&wmi_priv.class_dev->kobj, KOBJ_CHANGE);\n\t}\n\tkfree(output.pointer);\n\treturn map_wmi_error(ret);\n}\n\n \nint set_attribute(const char *a_name, const char *a_value)\n{\n\tsize_t security_area_size, buffer_size;\n\tsize_t a_name_size, a_value_size;\n\tchar *buffer = NULL, *start;\n\tint ret;\n\n\tmutex_lock(&wmi_priv.mutex);\n\tif (!wmi_priv.bios_attr_wdev) {\n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\n\t \n\tsecurity_area_size = calculate_security_buffer(wmi_priv.current_admin_password);\n\ta_name_size = calculate_string_buffer(a_name);\n\ta_value_size = calculate_string_buffer(a_value);\n\tbuffer_size = security_area_size + a_name_size + a_value_size;\n\tbuffer = kzalloc(buffer_size, GFP_KERNEL);\n\tif (!buffer) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t \n\tpopulate_security_buffer(buffer, wmi_priv.current_admin_password);\n\n\t \n\tstart = buffer + security_area_size;\n\tret = populate_string_buffer(start, a_name_size, a_name);\n\tif (ret < 0)\n\t\tgoto out;\n\tstart += ret;\n\tret = populate_string_buffer(start, a_value_size, a_value);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tprint_hex_dump_bytes(\"set attribute data: \", DUMP_PREFIX_NONE, buffer, buffer_size);\n\tret = call_biosattributes_interface(wmi_priv.bios_attr_wdev,\n\t\t\t\t\t    buffer, buffer_size,\n\t\t\t\t\t    SETATTRIBUTE_METHOD_ID);\n\tif (ret == -EOPNOTSUPP)\n\t\tdev_err(&wmi_priv.bios_attr_wdev->dev, \"admin password must be configured\\n\");\n\telse if (ret == -EACCES)\n\t\tdev_err(&wmi_priv.bios_attr_wdev->dev, \"invalid password\\n\");\n\nout:\n\tkfree(buffer);\n\tmutex_unlock(&wmi_priv.mutex);\n\treturn ret;\n}\n\n \nint set_bios_defaults(u8 deftype)\n{\n\tsize_t security_area_size, buffer_size;\n\tsize_t integer_area_size = sizeof(u8);\n\tchar *buffer = NULL;\n\tu8 *defaultType;\n\tint ret;\n\n\tmutex_lock(&wmi_priv.mutex);\n\tif (!wmi_priv.bios_attr_wdev) {\n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tsecurity_area_size = calculate_security_buffer(wmi_priv.current_admin_password);\n\tbuffer_size = security_area_size + integer_area_size;\n\tbuffer = kzalloc(buffer_size, GFP_KERNEL);\n\tif (!buffer) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t \n\tpopulate_security_buffer(buffer, wmi_priv.current_admin_password);\n\n\tdefaultType = buffer + security_area_size;\n\t*defaultType = deftype;\n\n\tret = call_biosattributes_interface(wmi_priv.bios_attr_wdev, buffer, buffer_size,\n\t\t\t\t\t    SETBIOSDEFAULTS_METHOD_ID);\n\tif (ret)\n\t\tdev_err(&wmi_priv.bios_attr_wdev->dev, \"reset BIOS defaults failed: %d\\n\", ret);\n\n\tkfree(buffer);\nout:\n\tmutex_unlock(&wmi_priv.mutex);\n\treturn ret;\n}\n\nstatic int bios_attr_set_interface_probe(struct wmi_device *wdev, const void *context)\n{\n\tmutex_lock(&wmi_priv.mutex);\n\twmi_priv.bios_attr_wdev = wdev;\n\tmutex_unlock(&wmi_priv.mutex);\n\treturn 0;\n}\n\nstatic void bios_attr_set_interface_remove(struct wmi_device *wdev)\n{\n\tmutex_lock(&wmi_priv.mutex);\n\twmi_priv.bios_attr_wdev = NULL;\n\tmutex_unlock(&wmi_priv.mutex);\n}\n\nstatic const struct wmi_device_id bios_attr_set_interface_id_table[] = {\n\t{ .guid_string = DELL_WMI_BIOS_ATTRIBUTES_INTERFACE_GUID },\n\t{ },\n};\nstatic struct wmi_driver bios_attr_set_interface_driver = {\n\t.driver = {\n\t\t.name = DRIVER_NAME\n\t},\n\t.probe = bios_attr_set_interface_probe,\n\t.remove = bios_attr_set_interface_remove,\n\t.id_table = bios_attr_set_interface_id_table,\n};\n\nint init_bios_attr_set_interface(void)\n{\n\treturn wmi_driver_register(&bios_attr_set_interface_driver);\n}\n\nvoid exit_bios_attr_set_interface(void)\n{\n\twmi_driver_unregister(&bios_attr_set_interface_driver);\n}\n\nMODULE_DEVICE_TABLE(wmi, bios_attr_set_interface_id_table);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}