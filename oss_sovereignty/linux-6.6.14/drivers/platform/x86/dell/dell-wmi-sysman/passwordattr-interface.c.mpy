{
  "module_name": "passwordattr-interface.c",
  "hash_id": "5a5bb9378ac105e2d816bca2762d820b12b3cd82a4f9ec7bbfa16837998be437",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/x86/dell/dell-wmi-sysman/passwordattr-interface.c",
  "human_readable_source": "\n \n\n#include <linux/wmi.h>\n#include \"dell-wmi-sysman.h\"\n\nstatic int call_password_interface(struct wmi_device *wdev, char *in_args, size_t size)\n{\n\tstruct acpi_buffer output = {ACPI_ALLOCATE_BUFFER, NULL};\n\tstruct acpi_buffer input;\n\tunion acpi_object *obj;\n\tacpi_status status;\n\tint ret = -EIO;\n\n\tinput.length =  (acpi_size) size;\n\tinput.pointer = in_args;\n\tstatus = wmidev_evaluate_method(wdev, 0, 1, &input, &output);\n\tif (ACPI_FAILURE(status))\n\t\treturn -EIO;\n\tobj = (union acpi_object *)output.pointer;\n\tif (obj->type == ACPI_TYPE_INTEGER)\n\t\tret = obj->integer.value;\n\n\tkfree(output.pointer);\n\t \n\tkobject_uevent(&wmi_priv.class_dev->kobj, KOBJ_CHANGE);\n\treturn map_wmi_error(ret);\n}\n\n \nint set_new_password(const char *password_type, const char *new)\n{\n\tsize_t password_type_size, current_password_size, new_size;\n\tsize_t security_area_size, buffer_size;\n\tchar *buffer = NULL, *start;\n\tchar *current_password;\n\tint ret;\n\n\tmutex_lock(&wmi_priv.mutex);\n\tif (!wmi_priv.password_attr_wdev) {\n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\tif (strcmp(password_type, \"Admin\") == 0) {\n\t\tcurrent_password = wmi_priv.current_admin_password;\n\t} else if (strcmp(password_type, \"System\") == 0) {\n\t\tcurrent_password = wmi_priv.current_system_password;\n\t} else {\n\t\tret = -EINVAL;\n\t\tdev_err(&wmi_priv.password_attr_wdev->dev, \"unknown password type %s\\n\",\n\t\t\tpassword_type);\n\t\tgoto out;\n\t}\n\n\t \n\tsecurity_area_size = calculate_security_buffer(wmi_priv.current_admin_password);\n\tpassword_type_size = calculate_string_buffer(password_type);\n\tcurrent_password_size = calculate_string_buffer(current_password);\n\tnew_size = calculate_string_buffer(new);\n\tbuffer_size = security_area_size + password_type_size + current_password_size + new_size;\n\tbuffer = kzalloc(buffer_size, GFP_KERNEL);\n\tif (!buffer) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t \n\tpopulate_security_buffer(buffer, wmi_priv.current_admin_password);\n\n\t \n\tstart = buffer + security_area_size;\n\tret = populate_string_buffer(start, password_type_size, password_type);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tstart += ret;\n\tret = populate_string_buffer(start, current_password_size, current_password);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tstart += ret;\n\tret = populate_string_buffer(start, new_size, new);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tprint_hex_dump_bytes(\"set new password data: \", DUMP_PREFIX_NONE, buffer, buffer_size);\n\tret = call_password_interface(wmi_priv.password_attr_wdev, buffer, buffer_size);\n\t \n\tif (!ret)\n\t\tstrscpy(current_password, new, MAX_BUFF);\n\t \n\telse if (ret == -EOPNOTSUPP)\n\t\tdev_err(&wmi_priv.password_attr_wdev->dev, \"admin password must be configured\\n\");\n\telse if (ret == -EACCES)\n\t\tdev_err(&wmi_priv.password_attr_wdev->dev, \"invalid password\\n\");\n\nout:\n\tkfree(buffer);\n\tmutex_unlock(&wmi_priv.mutex);\n\n\treturn ret;\n}\n\nstatic int bios_attr_pass_interface_probe(struct wmi_device *wdev, const void *context)\n{\n\tmutex_lock(&wmi_priv.mutex);\n\twmi_priv.password_attr_wdev = wdev;\n\tmutex_unlock(&wmi_priv.mutex);\n\treturn 0;\n}\n\nstatic void bios_attr_pass_interface_remove(struct wmi_device *wdev)\n{\n\tmutex_lock(&wmi_priv.mutex);\n\twmi_priv.password_attr_wdev = NULL;\n\tmutex_unlock(&wmi_priv.mutex);\n}\n\nstatic const struct wmi_device_id bios_attr_pass_interface_id_table[] = {\n\t{ .guid_string = DELL_WMI_BIOS_PASSWORD_INTERFACE_GUID },\n\t{ },\n};\nstatic struct wmi_driver bios_attr_pass_interface_driver = {\n\t.driver = {\n\t\t.name = DRIVER_NAME\"-password\"\n\t},\n\t.probe = bios_attr_pass_interface_probe,\n\t.remove = bios_attr_pass_interface_remove,\n\t.id_table = bios_attr_pass_interface_id_table,\n};\n\nint init_bios_attr_pass_interface(void)\n{\n\treturn wmi_driver_register(&bios_attr_pass_interface_driver);\n}\n\nvoid exit_bios_attr_pass_interface(void)\n{\n\twmi_driver_unregister(&bios_attr_pass_interface_driver);\n}\n\nMODULE_DEVICE_TABLE(wmi, bios_attr_pass_interface_id_table);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}