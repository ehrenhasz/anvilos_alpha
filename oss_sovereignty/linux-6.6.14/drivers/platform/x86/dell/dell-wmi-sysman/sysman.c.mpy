{
  "module_name": "sysman.c",
  "hash_id": "2b1db3a5b71133838cef1967d6a7dd6686640c9b33d16f3ce545cc35586fa86d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/x86/dell/dell-wmi-sysman/sysman.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/fs.h>\n#include <linux/dmi.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/wmi.h>\n#include \"dell-wmi-sysman.h\"\n#include \"../../firmware_attributes_class.h\"\n\n#define MAX_TYPES  4\n#include <linux/nls.h>\n\nstruct wmi_sysman_priv wmi_priv = {\n\t.mutex = __MUTEX_INITIALIZER(wmi_priv.mutex),\n};\n\n \nstatic const char * const reset_types[] = {\"builtinsafe\", \"lastknowngood\", \"factory\", \"custom\"};\nstatic int reset_option = -1;\nstatic struct class *fw_attr_class;\n\n\n \nssize_t populate_string_buffer(char *buffer, size_t buffer_len, const char *str)\n{\n\tu16 *length = (u16 *)buffer;\n\tu16 *target = length + 1;\n\tint ret;\n\n\tret = utf8s_to_utf16s(str, strlen(str), UTF16_HOST_ENDIAN,\n\t\t\t      target, buffer_len - sizeof(u16));\n\tif (ret < 0) {\n\t\tdev_err(wmi_priv.class_dev, \"UTF16 conversion failed\\n\");\n\t\treturn ret;\n\t}\n\n\tif ((ret * sizeof(u16)) > U16_MAX) {\n\t\tdev_err(wmi_priv.class_dev, \"Error string too long\\n\");\n\t\treturn -ERANGE;\n\t}\n\n\t*length = ret * sizeof(u16);\n\treturn sizeof(u16) + *length;\n}\n\n \nsize_t calculate_string_buffer(const char *str)\n{\n\t \n\treturn sizeof(u16) + strlen(str) * sizeof(u16);\n}\n\n \nsize_t calculate_security_buffer(char *authentication)\n{\n\tif (strlen(authentication) > 0) {\n\t\treturn (sizeof(u32) * 2) + strlen(authentication) +\n\t\t\tstrlen(authentication) % 2;\n\t}\n\treturn sizeof(u32) * 2;\n}\n\n \nvoid populate_security_buffer(char *buffer, char *authentication)\n{\n\tchar *auth = buffer + sizeof(u32) * 2;\n\tu32 *sectype = (u32 *) buffer;\n\tu32 *seclen = sectype + 1;\n\n\t*sectype = strlen(authentication) > 0 ? 1 : 0;\n\t*seclen = strlen(authentication);\n\n\t \n\tif (strlen(authentication) > 0)\n\t\tmemcpy(auth, authentication, *seclen);\n}\n\n \nint map_wmi_error(int error_code)\n{\n\tswitch (error_code) {\n\tcase 0:\n\t\t \n\t\treturn 0;\n\tcase 1:\n\t\t \n\t\treturn -EIO;\n\tcase 2:\n\t\t \n\t\treturn -EINVAL;\n\tcase 3:\n\t\t \n\t\treturn -EACCES;\n\tcase 4:\n\t\t \n\t\treturn -EOPNOTSUPP;\n\tcase 5:\n\t\t \n\t\treturn -ENOMEM;\n\tcase 6:\n\t\t \n\t\treturn -EPROTO;\n\t}\n\t \n\treturn -EIO;\n}\n\n \nstatic ssize_t reset_bios_show(struct kobject *kobj, struct kobj_attribute *attr, char *buf)\n{\n\tchar *start = buf;\n\tint i;\n\n\tfor (i = 0; i < MAX_TYPES; i++) {\n\t\tif (i == reset_option)\n\t\t\tbuf += sprintf(buf, \"[%s] \", reset_types[i]);\n\t\telse\n\t\t\tbuf += sprintf(buf, \"%s \", reset_types[i]);\n\t}\n\tbuf += sprintf(buf, \"\\n\");\n\treturn buf-start;\n}\n\n \nstatic ssize_t reset_bios_store(struct kobject *kobj,\n\t\t\t\tstruct kobj_attribute *attr, const char *buf, size_t count)\n{\n\tint type = sysfs_match_string(reset_types, buf);\n\tint ret;\n\n\tif (type < 0)\n\t\treturn type;\n\n\tret = set_bios_defaults(type);\n\tpr_debug(\"reset all attributes request type %d: %d\\n\", type, ret);\n\tif (!ret) {\n\t\treset_option = type;\n\t\tret = count;\n\t}\n\n\treturn ret;\n}\n\n \nstatic ssize_t pending_reboot_show(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t\t   char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", wmi_priv.pending_changes);\n}\n\nstatic struct kobj_attribute reset_bios = __ATTR_RW(reset_bios);\nstatic struct kobj_attribute pending_reboot = __ATTR_RO(pending_reboot);\n\n\n \nstatic int create_attributes_level_sysfs_files(void)\n{\n\tint ret;\n\n\tret = sysfs_create_file(&wmi_priv.main_dir_kset->kobj, &reset_bios.attr);\n\tif (ret)\n\t\treturn ret;\n\n\tret = sysfs_create_file(&wmi_priv.main_dir_kset->kobj, &pending_reboot.attr);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic ssize_t wmi_sysman_attr_show(struct kobject *kobj, struct attribute *attr,\n\t\t\t\t    char *buf)\n{\n\tstruct kobj_attribute *kattr;\n\tssize_t ret = -EIO;\n\n\tkattr = container_of(attr, struct kobj_attribute, attr);\n\tif (kattr->show)\n\t\tret = kattr->show(kobj, kattr, buf);\n\treturn ret;\n}\n\nstatic ssize_t wmi_sysman_attr_store(struct kobject *kobj, struct attribute *attr,\n\t\t\t\t     const char *buf, size_t count)\n{\n\tstruct kobj_attribute *kattr;\n\tssize_t ret = -EIO;\n\n\tkattr = container_of(attr, struct kobj_attribute, attr);\n\tif (kattr->store)\n\t\tret = kattr->store(kobj, kattr, buf, count);\n\treturn ret;\n}\n\nstatic const struct sysfs_ops wmi_sysman_kobj_sysfs_ops = {\n\t.show\t= wmi_sysman_attr_show,\n\t.store\t= wmi_sysman_attr_store,\n};\n\nstatic void attr_name_release(struct kobject *kobj)\n{\n\tkfree(kobj);\n}\n\nstatic const struct kobj_type attr_name_ktype = {\n\t.release\t= attr_name_release,\n\t.sysfs_ops\t= &wmi_sysman_kobj_sysfs_ops,\n};\n\n \nvoid strlcpy_attr(char *dest, char *src)\n{\n\tsize_t len = strlen(src) + 1;\n\n\tif (len > 1 && len <= MAX_BUFF)\n\t\tstrscpy(dest, src, len);\n\n\t \n\tif (len > MAX_BUFF)\n\t\tpr_err(\"Source string returned from BIOS is out of bound!\\n\");\n}\n\n \nunion acpi_object *get_wmiobj_pointer(int instance_id, const char *guid_string)\n{\n\tstruct acpi_buffer out = { ACPI_ALLOCATE_BUFFER, NULL };\n\tacpi_status status;\n\n\tstatus = wmi_query_block(guid_string, instance_id, &out);\n\n\treturn ACPI_SUCCESS(status) ? (union acpi_object *)out.pointer : NULL;\n}\n\n \nint get_instance_count(const char *guid_string)\n{\n\tint ret;\n\n\tret = wmi_instance_count(guid_string);\n\tif (ret < 0)\n\t\treturn 0;\n\n\treturn ret;\n}\n\n \nstatic int alloc_attributes_data(int attr_type)\n{\n\tint retval = 0;\n\n\tswitch (attr_type) {\n\tcase ENUM:\n\t\tretval = alloc_enum_data();\n\t\tbreak;\n\tcase INT:\n\t\tretval = alloc_int_data();\n\t\tbreak;\n\tcase STR:\n\t\tretval = alloc_str_data();\n\t\tbreak;\n\tcase PO:\n\t\tretval = alloc_po_data();\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn retval;\n}\n\n \nstatic void destroy_attribute_objs(struct kset *kset)\n{\n\tstruct kobject *pos, *next;\n\n\tlist_for_each_entry_safe(pos, next, &kset->list, entry) {\n\t\tkobject_put(pos);\n\t}\n}\n\n \nstatic void release_attributes_data(void)\n{\n\tmutex_lock(&wmi_priv.mutex);\n\texit_enum_attributes();\n\texit_int_attributes();\n\texit_str_attributes();\n\texit_po_attributes();\n\tif (wmi_priv.authentication_dir_kset) {\n\t\tdestroy_attribute_objs(wmi_priv.authentication_dir_kset);\n\t\tkset_unregister(wmi_priv.authentication_dir_kset);\n\t\twmi_priv.authentication_dir_kset = NULL;\n\t}\n\tif (wmi_priv.main_dir_kset) {\n\t\tsysfs_remove_file(&wmi_priv.main_dir_kset->kobj, &reset_bios.attr);\n\t\tsysfs_remove_file(&wmi_priv.main_dir_kset->kobj, &pending_reboot.attr);\n\t\tdestroy_attribute_objs(wmi_priv.main_dir_kset);\n\t\tkset_unregister(wmi_priv.main_dir_kset);\n\t\twmi_priv.main_dir_kset = NULL;\n\t}\n\tmutex_unlock(&wmi_priv.mutex);\n}\n\n \nstatic int init_bios_attributes(int attr_type, const char *guid)\n{\n\tstruct kobject *attr_name_kobj; \n\tunion acpi_object *obj = NULL;\n\tunion acpi_object *elements;\n\tstruct kobject *duplicate;\n\tstruct kset *tmp_set;\n\tint min_elements;\n\n\t \n\tint instance_id = 0;\n\tint retval = 0;\n\n\tretval = alloc_attributes_data(attr_type);\n\tif (retval)\n\t\treturn retval;\n\n\tswitch (attr_type) {\n\tcase ENUM:\tmin_elements = 8;\tbreak;\n\tcase INT:\tmin_elements = 9;\tbreak;\n\tcase STR:\tmin_elements = 8;\tbreak;\n\tcase PO:\tmin_elements = 4;\tbreak;\n\tdefault:\n\t\tpr_err(\"Error: Unknown attr_type: %d\\n\", attr_type);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tobj = get_wmiobj_pointer(instance_id, guid);\n\tif (!obj)\n\t\treturn -ENODEV;\n\n\tmutex_lock(&wmi_priv.mutex);\n\twhile (obj) {\n\t\tif (obj->type != ACPI_TYPE_PACKAGE) {\n\t\t\tpr_err(\"Error: Expected ACPI-package type, got: %d\\n\", obj->type);\n\t\t\tretval = -EIO;\n\t\t\tgoto err_attr_init;\n\t\t}\n\n\t\tif (obj->package.count < min_elements) {\n\t\t\tpr_err(\"Error: ACPI-package does not have enough elements: %d < %d\\n\",\n\t\t\t       obj->package.count, min_elements);\n\t\t\tgoto nextobj;\n\t\t}\n\n\t\telements = obj->package.elements;\n\n\t\t \n\t\tif (elements[ATTR_NAME].type != ACPI_TYPE_STRING) {\n\t\t\tpr_debug(\"incorrect element type\\n\");\n\t\t\tgoto nextobj;\n\t\t}\n\t\tif (strlen(elements[ATTR_NAME].string.pointer) == 0) {\n\t\t\tpr_debug(\"empty attribute found\\n\");\n\t\t\tgoto nextobj;\n\t\t}\n\t\tif (attr_type == PO)\n\t\t\ttmp_set = wmi_priv.authentication_dir_kset;\n\t\telse\n\t\t\ttmp_set = wmi_priv.main_dir_kset;\n\n\t\tduplicate = kset_find_obj(tmp_set, elements[ATTR_NAME].string.pointer);\n\t\tif (duplicate) {\n\t\t\tpr_debug(\"Duplicate attribute name found - %s\\n\",\n\t\t\t\t elements[ATTR_NAME].string.pointer);\n\t\t\tkobject_put(duplicate);\n\t\t\tgoto nextobj;\n\t\t}\n\n\t\t \n\t\tattr_name_kobj = kzalloc(sizeof(*attr_name_kobj), GFP_KERNEL);\n\t\tif (!attr_name_kobj) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto err_attr_init;\n\t\t}\n\n\t\tattr_name_kobj->kset = tmp_set;\n\n\t\tretval = kobject_init_and_add(attr_name_kobj, &attr_name_ktype, NULL, \"%s\",\n\t\t\t\t\t\telements[ATTR_NAME].string.pointer);\n\t\tif (retval) {\n\t\t\tkobject_put(attr_name_kobj);\n\t\t\tgoto err_attr_init;\n\t\t}\n\n\t\t \n\t\tswitch (attr_type) {\n\t\tcase ENUM:\n\t\t\tretval = populate_enum_data(elements, instance_id, attr_name_kobj,\n\t\t\t\t\tobj->package.count);\n\t\t\tbreak;\n\t\tcase INT:\n\t\t\tretval = populate_int_data(elements, instance_id, attr_name_kobj);\n\t\t\tbreak;\n\t\tcase STR:\n\t\t\tretval = populate_str_data(elements, instance_id, attr_name_kobj);\n\t\t\tbreak;\n\t\tcase PO:\n\t\t\tretval = populate_po_data(elements, instance_id, attr_name_kobj);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tif (retval) {\n\t\t\tpr_debug(\"failed to populate %s\\n\",\n\t\t\t\telements[ATTR_NAME].string.pointer);\n\t\t\tgoto err_attr_init;\n\t\t}\n\nnextobj:\n\t\tkfree(obj);\n\t\tinstance_id++;\n\t\tobj = get_wmiobj_pointer(instance_id, guid);\n\t}\n\n\tmutex_unlock(&wmi_priv.mutex);\n\treturn 0;\n\nerr_attr_init:\n\tmutex_unlock(&wmi_priv.mutex);\n\tkfree(obj);\n\treturn retval;\n}\n\nstatic int __init sysman_init(void)\n{\n\tint ret = 0;\n\n\tif (!dmi_find_device(DMI_DEV_TYPE_OEM_STRING, \"Dell System\", NULL) &&\n\t    !dmi_find_device(DMI_DEV_TYPE_OEM_STRING, \"www.dell.com\", NULL)) {\n\t\tpr_err(\"Unable to run on non-Dell system\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tret = init_bios_attr_set_interface();\n\tif (ret)\n\t\treturn ret;\n\n\tret = init_bios_attr_pass_interface();\n\tif (ret)\n\t\tgoto err_exit_bios_attr_set_interface;\n\n\tif (!wmi_priv.bios_attr_wdev || !wmi_priv.password_attr_wdev) {\n\t\tpr_debug(\"failed to find set or pass interface\\n\");\n\t\tret = -ENODEV;\n\t\tgoto err_exit_bios_attr_pass_interface;\n\t}\n\n\tret = fw_attributes_class_get(&fw_attr_class);\n\tif (ret)\n\t\tgoto err_exit_bios_attr_pass_interface;\n\n\twmi_priv.class_dev = device_create(fw_attr_class, NULL, MKDEV(0, 0),\n\t\t\t\t  NULL, \"%s\", DRIVER_NAME);\n\tif (IS_ERR(wmi_priv.class_dev)) {\n\t\tret = PTR_ERR(wmi_priv.class_dev);\n\t\tgoto err_unregister_class;\n\t}\n\n\twmi_priv.main_dir_kset = kset_create_and_add(\"attributes\", NULL,\n\t\t\t\t\t\t     &wmi_priv.class_dev->kobj);\n\tif (!wmi_priv.main_dir_kset) {\n\t\tret = -ENOMEM;\n\t\tgoto err_destroy_classdev;\n\t}\n\n\twmi_priv.authentication_dir_kset = kset_create_and_add(\"authentication\", NULL,\n\t\t\t\t\t\t\t\t&wmi_priv.class_dev->kobj);\n\tif (!wmi_priv.authentication_dir_kset) {\n\t\tret = -ENOMEM;\n\t\tgoto err_release_attributes_data;\n\t}\n\n\tret = create_attributes_level_sysfs_files();\n\tif (ret) {\n\t\tpr_debug(\"could not create reset BIOS attribute\\n\");\n\t\tgoto err_release_attributes_data;\n\t}\n\n\tret = init_bios_attributes(ENUM, DELL_WMI_BIOS_ENUMERATION_ATTRIBUTE_GUID);\n\tif (ret) {\n\t\tpr_debug(\"failed to populate enumeration type attributes\\n\");\n\t\tgoto err_release_attributes_data;\n\t}\n\n\tret = init_bios_attributes(INT, DELL_WMI_BIOS_INTEGER_ATTRIBUTE_GUID);\n\tif (ret) {\n\t\tpr_debug(\"failed to populate integer type attributes\\n\");\n\t\tgoto err_release_attributes_data;\n\t}\n\n\tret = init_bios_attributes(STR, DELL_WMI_BIOS_STRING_ATTRIBUTE_GUID);\n\tif (ret) {\n\t\tpr_debug(\"failed to populate string type attributes\\n\");\n\t\tgoto err_release_attributes_data;\n\t}\n\n\tret = init_bios_attributes(PO, DELL_WMI_BIOS_PASSOBJ_ATTRIBUTE_GUID);\n\tif (ret) {\n\t\tpr_debug(\"failed to populate pass object type attributes\\n\");\n\t\tgoto err_release_attributes_data;\n\t}\n\n\treturn 0;\n\nerr_release_attributes_data:\n\trelease_attributes_data();\n\nerr_destroy_classdev:\n\tdevice_destroy(fw_attr_class, MKDEV(0, 0));\n\nerr_unregister_class:\n\tfw_attributes_class_put();\n\nerr_exit_bios_attr_pass_interface:\n\texit_bios_attr_pass_interface();\n\nerr_exit_bios_attr_set_interface:\n\texit_bios_attr_set_interface();\n\n\treturn ret;\n}\n\nstatic void __exit sysman_exit(void)\n{\n\trelease_attributes_data();\n\tdevice_destroy(fw_attr_class, MKDEV(0, 0));\n\tfw_attributes_class_put();\n\texit_bios_attr_set_interface();\n\texit_bios_attr_pass_interface();\n}\n\nmodule_init(sysman_init);\nmodule_exit(sysman_exit);\n\nMODULE_AUTHOR(\"Mario Limonciello <mario.limonciello@outlook.com>\");\nMODULE_AUTHOR(\"Prasanth Ksr <prasanth.ksr@dell.com>\");\nMODULE_AUTHOR(\"Divya Bharathi <divya.bharathi@dell.com>\");\nMODULE_DESCRIPTION(\"Dell platform setting control interface\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}