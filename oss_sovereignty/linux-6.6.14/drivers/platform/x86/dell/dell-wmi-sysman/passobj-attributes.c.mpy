{
  "module_name": "passobj-attributes.c",
  "hash_id": "6074f439d876b79095e55db03e06948d5a49c237208cd9df58e4cc9669709b4d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/x86/dell/dell-wmi-sysman/passobj-attributes.c",
  "human_readable_source": "\n \n\n#include \"dell-wmi-sysman.h\"\n\nenum po_properties {IS_PASS_SET = 1, MIN_PASS_LEN, MAX_PASS_LEN};\n\nget_instance_id(po);\n\nstatic ssize_t is_enabled_show(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t\t\t  char *buf)\n{\n\tint instance_id = get_po_instance_id(kobj);\n\tunion acpi_object *obj;\n\tssize_t ret;\n\n\tif (instance_id < 0)\n\t\treturn instance_id;\n\n\t \n\tobj = get_wmiobj_pointer(instance_id, DELL_WMI_BIOS_PASSOBJ_ATTRIBUTE_GUID);\n\tif (!obj)\n\t\treturn -EIO;\n\tif (obj->package.elements[IS_PASS_SET].type != ACPI_TYPE_INTEGER) {\n\t\tkfree(obj);\n\t\treturn -EINVAL;\n\t}\n\tret = snprintf(buf, PAGE_SIZE, \"%lld\\n\", obj->package.elements[IS_PASS_SET].integer.value);\n\tkfree(obj);\n\treturn ret;\n}\n\nstatic struct kobj_attribute po_is_pass_set = __ATTR_RO(is_enabled);\n\nstatic ssize_t current_password_store(struct kobject *kobj,\n\t\t\t\t      struct kobj_attribute *attr,\n\t\t\t\t      const char *buf, size_t count)\n{\n\tchar *target = NULL;\n\tint length;\n\n\tlength = strlen(buf);\n\tif (buf[length-1] == '\\n')\n\t\tlength--;\n\n\t \n\tif (length >= MAX_BUFF)\n\t\treturn -EINVAL;\n\n\tif (strcmp(kobj->name, \"Admin\") == 0)\n\t\ttarget = wmi_priv.current_admin_password;\n\telse if (strcmp(kobj->name, \"System\") == 0)\n\t\ttarget = wmi_priv.current_system_password;\n\tif (!target)\n\t\treturn -EIO;\n\tmemcpy(target, buf, length);\n\ttarget[length] = '\\0';\n\n\treturn count;\n}\n\nstatic struct kobj_attribute po_current_password = __ATTR_WO(current_password);\n\nstatic ssize_t new_password_store(struct kobject *kobj,\n\t\t\t\t  struct kobj_attribute *attr,\n\t\t\t\t  const char *buf, size_t count)\n{\n\tchar *p, *buf_cp;\n\tint ret;\n\n\tbuf_cp = kstrdup(buf, GFP_KERNEL);\n\tif (!buf_cp)\n\t\treturn -ENOMEM;\n\tp = memchr(buf_cp, '\\n', count);\n\n\tif (p != NULL)\n\t\t*p = '\\0';\n\tif (strlen(buf_cp) > MAX_BUFF) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = set_new_password(kobj->name, buf_cp);\n\nout:\n\tkfree(buf_cp);\n\treturn ret ? ret : count;\n}\n\nstatic struct kobj_attribute po_new_password = __ATTR_WO(new_password);\n\nattribute_n_property_show(min_password_length, po);\nstatic struct kobj_attribute po_min_pass_length = __ATTR_RO(min_password_length);\n\nattribute_n_property_show(max_password_length, po);\nstatic struct kobj_attribute po_max_pass_length = __ATTR_RO(max_password_length);\n\nstatic ssize_t mechanism_show(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t char *buf)\n{\n\treturn sprintf(buf, \"password\\n\");\n}\n\nstatic struct kobj_attribute po_mechanism = __ATTR_RO(mechanism);\n\nstatic ssize_t role_show(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t char *buf)\n{\n\tif (strcmp(kobj->name, \"Admin\") == 0)\n\t\treturn sprintf(buf, \"bios-admin\\n\");\n\telse if (strcmp(kobj->name, \"System\") == 0)\n\t\treturn sprintf(buf, \"power-on\\n\");\n\treturn -EIO;\n}\n\nstatic struct kobj_attribute po_role = __ATTR_RO(role);\n\nstatic struct attribute *po_attrs[] = {\n\t&po_is_pass_set.attr,\n\t&po_min_pass_length.attr,\n\t&po_max_pass_length.attr,\n\t&po_current_password.attr,\n\t&po_new_password.attr,\n\t&po_role.attr,\n\t&po_mechanism.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group po_attr_group = {\n\t.attrs = po_attrs,\n};\n\nint alloc_po_data(void)\n{\n\tint ret = 0;\n\n\twmi_priv.po_instances_count = get_instance_count(DELL_WMI_BIOS_PASSOBJ_ATTRIBUTE_GUID);\n\twmi_priv.po_data = kcalloc(wmi_priv.po_instances_count, sizeof(struct po_data), GFP_KERNEL);\n\tif (!wmi_priv.po_data) {\n\t\twmi_priv.po_instances_count = 0;\n\t\tret = -ENOMEM;\n\t}\n\treturn ret;\n}\n\n \nint populate_po_data(union acpi_object *po_obj, int instance_id, struct kobject *attr_name_kobj)\n{\n\twmi_priv.po_data[instance_id].attr_name_kobj = attr_name_kobj;\n\tif (check_property_type(po, ATTR_NAME, ACPI_TYPE_STRING))\n\t\treturn -EINVAL;\n\tstrlcpy_attr(wmi_priv.po_data[instance_id].attribute_name,\n\t\t     po_obj[ATTR_NAME].string.pointer);\n\tif (check_property_type(po, MIN_PASS_LEN, ACPI_TYPE_INTEGER))\n\t\treturn -EINVAL;\n\twmi_priv.po_data[instance_id].min_password_length =\n\t\t(uintptr_t)po_obj[MIN_PASS_LEN].string.pointer;\n\tif (check_property_type(po, MAX_PASS_LEN, ACPI_TYPE_INTEGER))\n\t\treturn -EINVAL;\n\twmi_priv.po_data[instance_id].max_password_length =\n\t\t(uintptr_t) po_obj[MAX_PASS_LEN].string.pointer;\n\n\treturn sysfs_create_group(attr_name_kobj, &po_attr_group);\n}\n\n \nvoid exit_po_attributes(void)\n{\n\tint instance_id;\n\n\tfor (instance_id = 0; instance_id < wmi_priv.po_instances_count; instance_id++) {\n\t\tif (wmi_priv.po_data[instance_id].attr_name_kobj)\n\t\t\tsysfs_remove_group(wmi_priv.po_data[instance_id].attr_name_kobj,\n\t\t\t\t\t\t\t\t&po_attr_group);\n\t}\n\twmi_priv.po_instances_count = 0;\n\n\tkfree(wmi_priv.po_data);\n\twmi_priv.po_data = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}