{
  "module_name": "dell-wmi-privacy.c",
  "hash_id": "fc369bf91ed75684accdc1ef10330560b4b4dc324d4d51587e5713fb12dc117c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/x86/dell/dell-wmi-privacy.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/acpi.h>\n#include <linux/bitops.h>\n#include <linux/input.h>\n#include <linux/input/sparse-keymap.h>\n#include <linux/list.h>\n#include <linux/leds.h>\n#include <linux/module.h>\n#include <linux/wmi.h>\n\n#include \"dell-wmi-privacy.h\"\n\n#define DELL_PRIVACY_GUID \"6932965F-1671-4CEB-B988-D3AB0A901919\"\n#define MICROPHONE_STATUS\t\tBIT(0)\n#define CAMERA_STATUS\t\t        BIT(1)\n#define DELL_PRIVACY_AUDIO_EVENT  0x1\n#define DELL_PRIVACY_CAMERA_EVENT 0x2\n#define led_to_priv(c)       container_of(c, struct privacy_wmi_data, cdev)\n\n \nstatic LIST_HEAD(wmi_list);\nstatic DEFINE_MUTEX(list_mutex);\n\nstruct privacy_wmi_data {\n\tstruct input_dev *input_dev;\n\tstruct wmi_device *wdev;\n\tstruct list_head list;\n\tstruct led_classdev cdev;\n\tu32 features_present;\n\tu32 last_status;\n};\n\n \nenum dell_hardware_privacy_type {\n\tDELL_PRIVACY_TYPE_AUDIO = 0,\n\tDELL_PRIVACY_TYPE_CAMERA,\n\tDELL_PRIVACY_TYPE_SCREEN,\n\tDELL_PRIVACY_TYPE_MAX,\n};\n\nstatic const char * const privacy_types[DELL_PRIVACY_TYPE_MAX] = {\n\t[DELL_PRIVACY_TYPE_AUDIO] = \"Microphone\",\n\t[DELL_PRIVACY_TYPE_CAMERA] = \"Camera Shutter\",\n\t[DELL_PRIVACY_TYPE_SCREEN] = \"ePrivacy Screen\",\n};\n\n \nstatic const struct key_entry dell_wmi_keymap_type_0012[] = {\n\t \n\t{ KE_KEY, 0x0001, { KEY_MICMUTE } },\n\t \n\t{ KE_VSW, 0x0002, { SW_CAMERA_LENS_COVER } },\n\t{ KE_END, 0},\n};\n\nbool dell_privacy_has_mic_mute(void)\n{\n\tstruct privacy_wmi_data *priv;\n\n\tmutex_lock(&list_mutex);\n\tpriv = list_first_entry_or_null(&wmi_list,\n\t\t\tstruct privacy_wmi_data,\n\t\t\tlist);\n\tmutex_unlock(&list_mutex);\n\n\treturn priv && (priv->features_present & BIT(DELL_PRIVACY_TYPE_AUDIO));\n}\nEXPORT_SYMBOL_GPL(dell_privacy_has_mic_mute);\n\n \nbool dell_privacy_process_event(int type, int code, int status)\n{\n\tstruct privacy_wmi_data *priv;\n\tconst struct key_entry *key;\n\tbool ret = false;\n\n\tmutex_lock(&list_mutex);\n\tpriv = list_first_entry_or_null(&wmi_list,\n\t\t\tstruct privacy_wmi_data,\n\t\t\tlist);\n\tif (!priv)\n\t\tgoto error;\n\n\tkey = sparse_keymap_entry_from_scancode(priv->input_dev, (type << 16) | code);\n\tif (!key) {\n\t\tdev_warn(&priv->wdev->dev, \"Unknown key with type 0x%04x and code 0x%04x pressed\\n\",\n\t\t\ttype, code);\n\t\tgoto error;\n\t}\n\tdev_dbg(&priv->wdev->dev, \"Key with type 0x%04x and code 0x%04x pressed\\n\", type, code);\n\n\tswitch (code) {\n\tcase DELL_PRIVACY_AUDIO_EVENT:  \n\t\tpriv->last_status = status;\n\t\tsparse_keymap_report_entry(priv->input_dev, key, 1, true);\n\t\tret = true;\n\t\tbreak;\n\tcase DELL_PRIVACY_CAMERA_EVENT:  \n\t\tpriv->last_status = status;\n\t\tsparse_keymap_report_entry(priv->input_dev, key, !(status & CAMERA_STATUS), false);\n\t\tret = true;\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(&priv->wdev->dev, \"unknown event type 0x%04x 0x%04x\\n\", type, code);\n\t}\n\nerror:\n\tmutex_unlock(&list_mutex);\n\treturn ret;\n}\n\nstatic ssize_t dell_privacy_supported_type_show(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tstruct privacy_wmi_data *priv = dev_get_drvdata(dev);\n\tenum dell_hardware_privacy_type type;\n\tu32 privacy_list;\n\tint len = 0;\n\n\tprivacy_list = priv->features_present;\n\tfor (type = DELL_PRIVACY_TYPE_AUDIO; type < DELL_PRIVACY_TYPE_MAX; type++) {\n\t\tif (privacy_list & BIT(type))\n\t\t\tlen += sysfs_emit_at(buf, len, \"[%s] [supported]\\n\", privacy_types[type]);\n\t\telse\n\t\t\tlen += sysfs_emit_at(buf, len, \"[%s] [unsupported]\\n\", privacy_types[type]);\n\t}\n\n\treturn len;\n}\n\nstatic ssize_t dell_privacy_current_state_show(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tstruct privacy_wmi_data *priv = dev_get_drvdata(dev);\n\tu32 privacy_supported = priv->features_present;\n\tenum dell_hardware_privacy_type type;\n\tu32 privacy_state = priv->last_status;\n\tint len = 0;\n\n\tfor (type = DELL_PRIVACY_TYPE_AUDIO; type < DELL_PRIVACY_TYPE_MAX; type++) {\n\t\tif (privacy_supported & BIT(type)) {\n\t\t\tif (privacy_state & BIT(type))\n\t\t\t\tlen += sysfs_emit_at(buf, len, \"[%s] [unmuted]\\n\", privacy_types[type]);\n\t\t\telse\n\t\t\t\tlen += sysfs_emit_at(buf, len, \"[%s] [muted]\\n\", privacy_types[type]);\n\t\t}\n\t}\n\n\treturn len;\n}\n\nstatic DEVICE_ATTR_RO(dell_privacy_supported_type);\nstatic DEVICE_ATTR_RO(dell_privacy_current_state);\n\nstatic struct attribute *privacy_attrs[] = {\n\t&dev_attr_dell_privacy_supported_type.attr,\n\t&dev_attr_dell_privacy_current_state.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(privacy);\n\n \nstatic int get_current_status(struct wmi_device *wdev)\n{\n\tstruct privacy_wmi_data *priv = dev_get_drvdata(&wdev->dev);\n\tunion acpi_object *obj_present;\n\tu32 *buffer;\n\tint ret = 0;\n\n\tif (!priv) {\n\t\tdev_err(&wdev->dev, \"dell privacy priv is NULL\\n\");\n\t\treturn -EINVAL;\n\t}\n\t \n\tobj_present = wmidev_block_query(wdev, 0);\n\tif (!obj_present) {\n\t\tdev_err(&wdev->dev, \"failed to read Binary MOF\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (obj_present->type != ACPI_TYPE_BUFFER) {\n\t\tdev_err(&wdev->dev, \"Binary MOF is not a buffer!\\n\");\n\t\tret = -EIO;\n\t\tgoto obj_free;\n\t}\n\t \n\tif (obj_present->buffer.length != 8) {\n\t\tdev_err(&wdev->dev, \"Dell privacy buffer has unexpected length (%d)!\\n\",\n\t\t\t\tobj_present->buffer.length);\n\t\tret = -EINVAL;\n\t\tgoto obj_free;\n\t}\n\tbuffer = (u32 *)obj_present->buffer.pointer;\n\tpriv->features_present = buffer[0];\n\tpriv->last_status = buffer[1];\n\nobj_free:\n\tkfree(obj_present);\n\treturn ret;\n}\n\nstatic int dell_privacy_micmute_led_set(struct led_classdev *led_cdev,\n\t\t\t\t\tenum led_brightness brightness)\n{\n\tstruct privacy_wmi_data *priv = led_to_priv(led_cdev);\n\tstatic char *acpi_method = (char *)\"ECAK\";\n\tacpi_status status;\n\tacpi_handle handle;\n\n\thandle = ec_get_handle();\n\tif (!handle)\n\t\treturn -EIO;\n\n\tif (!acpi_has_method(handle, acpi_method))\n\t\treturn -EIO;\n\n\tstatus = acpi_evaluate_object(handle, acpi_method, NULL, NULL);\n\tif (ACPI_FAILURE(status)) {\n\t\tdev_err(&priv->wdev->dev, \"Error setting privacy EC ack value: %s\\n\",\n\t\t\t\tacpi_format_exception(status));\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int dell_privacy_leds_setup(struct device *dev)\n{\n\tstruct privacy_wmi_data *priv = dev_get_drvdata(dev);\n\n\tpriv->cdev.name = \"dell-privacy::micmute\";\n\tpriv->cdev.max_brightness = 1;\n\tpriv->cdev.brightness_set_blocking = dell_privacy_micmute_led_set;\n\tpriv->cdev.default_trigger = \"audio-micmute\";\n\tpriv->cdev.brightness = ledtrig_audio_get(LED_AUDIO_MICMUTE);\n\treturn devm_led_classdev_register(dev, &priv->cdev);\n}\n\nstatic int dell_privacy_wmi_probe(struct wmi_device *wdev, const void *context)\n{\n\tstruct privacy_wmi_data *priv;\n\tstruct key_entry *keymap;\n\tint ret, i, j;\n\n\tret = wmi_has_guid(DELL_PRIVACY_GUID);\n\tif (!ret)\n\t\tpr_debug(\"Unable to detect available Dell privacy devices!\\n\");\n\n\tpriv = devm_kzalloc(&wdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tdev_set_drvdata(&wdev->dev, priv);\n\tpriv->wdev = wdev;\n\n\tret = get_current_status(priv->wdev);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tpriv->input_dev = devm_input_allocate_device(&wdev->dev);\n\tif (!priv->input_dev)\n\t\treturn -ENOMEM;\n\n\t \n\tkeymap = kcalloc(ARRAY_SIZE(dell_wmi_keymap_type_0012),\n\t\t\tsizeof(struct key_entry), GFP_KERNEL);\n\tif (!keymap)\n\t\treturn -ENOMEM;\n\n\t \n\tfor (i = 0, j = 0; i < ARRAY_SIZE(dell_wmi_keymap_type_0012); i++) {\n\t\t \n\t\tif (dell_wmi_keymap_type_0012[i].type == KE_VSW &&\n\t\t    dell_wmi_keymap_type_0012[i].sw.code == SW_CAMERA_LENS_COVER &&\n\t\t    !(priv->features_present & BIT(DELL_PRIVACY_TYPE_CAMERA)))\n\t\t\tcontinue;\n\n\t\tkeymap[j] = dell_wmi_keymap_type_0012[i];\n\t\tkeymap[j].code |= (0x0012 << 16);\n\t\tj++;\n\t}\n\tret = sparse_keymap_setup(priv->input_dev, keymap, NULL);\n\tkfree(keymap);\n\tif (ret)\n\t\treturn ret;\n\n\tpriv->input_dev->dev.parent = &wdev->dev;\n\tpriv->input_dev->name = \"Dell Privacy Driver\";\n\tpriv->input_dev->id.bustype = BUS_HOST;\n\n\t \n\tif (priv->features_present & BIT(DELL_PRIVACY_TYPE_CAMERA))\n\t\tinput_report_switch(priv->input_dev, SW_CAMERA_LENS_COVER,\n\t\t\t\t    !(priv->last_status & CAMERA_STATUS));\n\n\tret = input_register_device(priv->input_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tif (priv->features_present & BIT(DELL_PRIVACY_TYPE_AUDIO)) {\n\t\tret = dell_privacy_leds_setup(&priv->wdev->dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tmutex_lock(&list_mutex);\n\tlist_add_tail(&priv->list, &wmi_list);\n\tmutex_unlock(&list_mutex);\n\treturn 0;\n}\n\nstatic void dell_privacy_wmi_remove(struct wmi_device *wdev)\n{\n\tstruct privacy_wmi_data *priv = dev_get_drvdata(&wdev->dev);\n\n\tmutex_lock(&list_mutex);\n\tlist_del(&priv->list);\n\tmutex_unlock(&list_mutex);\n}\n\nstatic const struct wmi_device_id dell_wmi_privacy_wmi_id_table[] = {\n\t{ .guid_string = DELL_PRIVACY_GUID },\n\t{ },\n};\n\nstatic struct wmi_driver dell_privacy_wmi_driver = {\n\t.driver = {\n\t\t.name = \"dell-privacy\",\n\t\t.dev_groups = privacy_groups,\n\t},\n\t.probe = dell_privacy_wmi_probe,\n\t.remove = dell_privacy_wmi_remove,\n\t.id_table = dell_wmi_privacy_wmi_id_table,\n};\n\nint dell_privacy_register_driver(void)\n{\n\treturn wmi_driver_register(&dell_privacy_wmi_driver);\n}\n\nvoid dell_privacy_unregister_driver(void)\n{\n\twmi_driver_unregister(&dell_privacy_wmi_driver);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}