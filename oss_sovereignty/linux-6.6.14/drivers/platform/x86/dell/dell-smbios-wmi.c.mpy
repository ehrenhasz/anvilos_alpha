{
  "module_name": "dell-smbios-wmi.c",
  "hash_id": "56bf56cfc90cf0fcae71269e5dac3e237b6ad393806f899eb5d5cc7958f98650",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/x86/dell/dell-smbios-wmi.c",
  "human_readable_source": "\n \n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/dmi.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/uaccess.h>\n#include <linux/wmi.h>\n#include \"dell-smbios.h\"\n#include \"dell-wmi-descriptor.h\"\n\nstatic DEFINE_MUTEX(call_mutex);\nstatic DEFINE_MUTEX(list_mutex);\nstatic int wmi_supported;\n\nstruct misc_bios_flags_structure {\n\tstruct dmi_header header;\n\tu16 flags0;\n} __packed;\n#define FLAG_HAS_ACPI_WMI 0x02\n\n#define DELL_WMI_SMBIOS_GUID \"A80593CE-A997-11DA-B012-B622A1EF5492\"\n\nstruct wmi_smbios_priv {\n\tstruct dell_wmi_smbios_buffer *buf;\n\tstruct list_head list;\n\tstruct wmi_device *wdev;\n\tstruct device *child;\n\tu32 req_buf_size;\n};\nstatic LIST_HEAD(wmi_list);\n\nstatic inline struct wmi_smbios_priv *get_first_smbios_priv(void)\n{\n\treturn list_first_entry_or_null(&wmi_list,\n\t\t\t\t\tstruct wmi_smbios_priv,\n\t\t\t\t\tlist);\n}\n\nstatic int run_smbios_call(struct wmi_device *wdev)\n{\n\tstruct acpi_buffer output = {ACPI_ALLOCATE_BUFFER, NULL};\n\tstruct wmi_smbios_priv *priv;\n\tstruct acpi_buffer input;\n\tunion acpi_object *obj;\n\tacpi_status status;\n\n\tpriv = dev_get_drvdata(&wdev->dev);\n\tinput.length = priv->req_buf_size - sizeof(u64);\n\tinput.pointer = &priv->buf->std;\n\n\tdev_dbg(&wdev->dev, \"evaluating: %u/%u [%x,%x,%x,%x]\\n\",\n\t\tpriv->buf->std.cmd_class, priv->buf->std.cmd_select,\n\t\tpriv->buf->std.input[0], priv->buf->std.input[1],\n\t\tpriv->buf->std.input[2], priv->buf->std.input[3]);\n\n\tstatus = wmidev_evaluate_method(wdev, 0, 1, &input, &output);\n\tif (ACPI_FAILURE(status))\n\t\treturn -EIO;\n\tobj = (union acpi_object *)output.pointer;\n\tif (obj->type != ACPI_TYPE_BUFFER) {\n\t\tdev_dbg(&wdev->dev, \"received type: %d\\n\", obj->type);\n\t\tif (obj->type == ACPI_TYPE_INTEGER)\n\t\t\tdev_dbg(&wdev->dev, \"SMBIOS call failed: %llu\\n\",\n\t\t\t\tobj->integer.value);\n\t\tkfree(output.pointer);\n\t\treturn -EIO;\n\t}\n\tmemcpy(input.pointer, obj->buffer.pointer, obj->buffer.length);\n\tdev_dbg(&wdev->dev, \"result: [%08x,%08x,%08x,%08x]\\n\",\n\t\tpriv->buf->std.output[0], priv->buf->std.output[1],\n\t\tpriv->buf->std.output[2], priv->buf->std.output[3]);\n\tkfree(output.pointer);\n\n\treturn 0;\n}\n\nstatic int dell_smbios_wmi_call(struct calling_interface_buffer *buffer)\n{\n\tstruct wmi_smbios_priv *priv;\n\tsize_t difference;\n\tsize_t size;\n\tint ret;\n\n\tmutex_lock(&call_mutex);\n\tpriv = get_first_smbios_priv();\n\tif (!priv) {\n\t\tret = -ENODEV;\n\t\tgoto out_wmi_call;\n\t}\n\n\tsize = sizeof(struct calling_interface_buffer);\n\tdifference = priv->req_buf_size - sizeof(u64) - size;\n\n\tmemset(&priv->buf->ext, 0, difference);\n\tmemcpy(&priv->buf->std, buffer, size);\n\tret = run_smbios_call(priv->wdev);\n\tmemcpy(buffer, &priv->buf->std, size);\nout_wmi_call:\n\tmutex_unlock(&call_mutex);\n\n\treturn ret;\n}\n\nstatic long dell_smbios_wmi_filter(struct wmi_device *wdev, unsigned int cmd,\n\t\t\t\t   struct wmi_ioctl_buffer *arg)\n{\n\tstruct wmi_smbios_priv *priv;\n\tint ret = 0;\n\n\tswitch (cmd) {\n\tcase DELL_WMI_SMBIOS_CMD:\n\t\tmutex_lock(&call_mutex);\n\t\tpriv = dev_get_drvdata(&wdev->dev);\n\t\tif (!priv) {\n\t\t\tret = -ENODEV;\n\t\t\tgoto fail_smbios_cmd;\n\t\t}\n\t\tmemcpy(priv->buf, arg, priv->req_buf_size);\n\t\tif (dell_smbios_call_filter(&wdev->dev, &priv->buf->std)) {\n\t\t\tdev_err(&wdev->dev, \"Invalid call %d/%d:%8x\\n\",\n\t\t\t\tpriv->buf->std.cmd_class,\n\t\t\t\tpriv->buf->std.cmd_select,\n\t\t\t\tpriv->buf->std.input[0]);\n\t\t\tret = -EFAULT;\n\t\t\tgoto fail_smbios_cmd;\n\t\t}\n\t\tret = run_smbios_call(priv->wdev);\n\t\tif (ret)\n\t\t\tgoto fail_smbios_cmd;\n\t\tmemcpy(arg, priv->buf, priv->req_buf_size);\nfail_smbios_cmd:\n\t\tmutex_unlock(&call_mutex);\n\t\tbreak;\n\tdefault:\n\t\tret = -ENOIOCTLCMD;\n\t}\n\treturn ret;\n}\n\nstatic int dell_smbios_wmi_probe(struct wmi_device *wdev, const void *context)\n{\n\tstruct wmi_driver *wdriver =\n\t\tcontainer_of(wdev->dev.driver, struct wmi_driver, driver);\n\tstruct wmi_smbios_priv *priv;\n\tu32 hotfix;\n\tint count;\n\tint ret;\n\n\tret = dell_wmi_get_descriptor_valid();\n\tif (ret)\n\t\treturn ret;\n\n\tpriv = devm_kzalloc(&wdev->dev, sizeof(struct wmi_smbios_priv),\n\t\t\t    GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\t \n\tif (!dell_wmi_get_size(&priv->req_buf_size))\n\t\treturn -EPROBE_DEFER;\n\n\t \n\tif (!dell_wmi_get_hotfix(&hotfix))\n\t\treturn -EPROBE_DEFER;\n\tif (!hotfix) {\n\t\tdev_warn(&wdev->dev,\n\t\t\t\"WMI SMBIOS userspace interface not supported(%u), try upgrading to a newer BIOS\\n\",\n\t\t\thotfix);\n\t\twdriver->filter_callback = NULL;\n\t}\n\n\t \n\tpriv->req_buf_size += sizeof(u64);\n\tret = set_required_buffer_size(wdev, priv->req_buf_size);\n\tif (ret)\n\t\treturn ret;\n\n\tcount = get_order(priv->req_buf_size);\n\tpriv->buf = (void *)__get_free_pages(GFP_KERNEL, count);\n\tif (!priv->buf)\n\t\treturn -ENOMEM;\n\n\t \n\twdev->dev.id = 1;\n\tret = dell_smbios_register_device(&wdev->dev, &dell_smbios_wmi_call);\n\tif (ret)\n\t\tgoto fail_register;\n\n\tpriv->wdev = wdev;\n\tdev_set_drvdata(&wdev->dev, priv);\n\tmutex_lock(&list_mutex);\n\tlist_add_tail(&priv->list, &wmi_list);\n\tmutex_unlock(&list_mutex);\n\n\treturn 0;\n\nfail_register:\n\tfree_pages((unsigned long)priv->buf, count);\n\treturn ret;\n}\n\nstatic void dell_smbios_wmi_remove(struct wmi_device *wdev)\n{\n\tstruct wmi_smbios_priv *priv = dev_get_drvdata(&wdev->dev);\n\tint count;\n\n\tmutex_lock(&call_mutex);\n\tmutex_lock(&list_mutex);\n\tlist_del(&priv->list);\n\tmutex_unlock(&list_mutex);\n\tdell_smbios_unregister_device(&wdev->dev);\n\tcount = get_order(priv->req_buf_size);\n\tfree_pages((unsigned long)priv->buf, count);\n\tmutex_unlock(&call_mutex);\n}\n\nstatic const struct wmi_device_id dell_smbios_wmi_id_table[] = {\n\t{ .guid_string = DELL_WMI_SMBIOS_GUID },\n\t{ },\n};\n\nstatic void parse_b1_table(const struct dmi_header *dm)\n{\n\tstruct misc_bios_flags_structure *flags =\n\tcontainer_of(dm, struct misc_bios_flags_structure, header);\n\n\t \n\tif (dm->length < 12)\n\t\treturn;\n\tif (dm->handle != 0xb100)\n\t\treturn;\n\tif ((flags->flags0 & FLAG_HAS_ACPI_WMI))\n\t\twmi_supported = 1;\n}\n\nstatic void find_b1(const struct dmi_header *dm, void *dummy)\n{\n\tswitch (dm->type) {\n\tcase 0xb1:  \n\t\tparse_b1_table(dm);\n\t\tbreak;\n\t}\n}\n\nstatic struct wmi_driver dell_smbios_wmi_driver = {\n\t.driver = {\n\t\t.name = \"dell-smbios\",\n\t},\n\t.probe = dell_smbios_wmi_probe,\n\t.remove = dell_smbios_wmi_remove,\n\t.id_table = dell_smbios_wmi_id_table,\n\t.filter_callback = dell_smbios_wmi_filter,\n};\n\nint init_dell_smbios_wmi(void)\n{\n\tdmi_walk(find_b1, NULL);\n\n\tif (!wmi_supported)\n\t\treturn -ENODEV;\n\n\treturn wmi_driver_register(&dell_smbios_wmi_driver);\n}\n\nvoid exit_dell_smbios_wmi(void)\n{\n\tif (wmi_supported)\n\t\twmi_driver_unregister(&dell_smbios_wmi_driver);\n}\n\nMODULE_DEVICE_TABLE(wmi, dell_smbios_wmi_id_table);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}