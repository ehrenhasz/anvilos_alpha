{
  "module_name": "dell-wmi-ddv.c",
  "hash_id": "b9f1b71f432e996ba5d1b4f4664d21327b454e72c09a323bc15b6828fdb92d93",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/x86/dell/dell-wmi-ddv.c",
  "human_readable_source": "\n \n\n#define pr_format(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/acpi.h>\n#include <linux/debugfs.h>\n#include <linux/device.h>\n#include <linux/device/driver.h>\n#include <linux/dev_printk.h>\n#include <linux/errno.h>\n#include <linux/kconfig.h>\n#include <linux/kernel.h>\n#include <linux/hwmon.h>\n#include <linux/kstrtox.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/limits.h>\n#include <linux/pm.h>\n#include <linux/power_supply.h>\n#include <linux/printk.h>\n#include <linux/seq_file.h>\n#include <linux/sysfs.h>\n#include <linux/types.h>\n#include <linux/wmi.h>\n\n#include <acpi/battery.h>\n\n#include <asm/unaligned.h>\n\n#define DRIVER_NAME\t\"dell-wmi-ddv\"\n\n#define DELL_DDV_SUPPORTED_VERSION_MIN\t2\n#define DELL_DDV_SUPPORTED_VERSION_MAX\t3\n#define DELL_DDV_GUID\t\"8A42EA14-4F2A-FD45-6422-0087F7A7E608\"\n\n#define DELL_EPPID_LENGTH\t20\n#define DELL_EPPID_EXT_LENGTH\t23\n\nstatic bool force;\nmodule_param_unsafe(force, bool, 0);\nMODULE_PARM_DESC(force, \"Force loading without checking for supported WMI interface versions\");\n\nenum dell_ddv_method {\n\tDELL_DDV_BATTERY_DESIGN_CAPACITY\t= 0x01,\n\tDELL_DDV_BATTERY_FULL_CHARGE_CAPACITY\t= 0x02,\n\tDELL_DDV_BATTERY_MANUFACTURE_NAME\t= 0x03,\n\tDELL_DDV_BATTERY_MANUFACTURE_DATE\t= 0x04,\n\tDELL_DDV_BATTERY_SERIAL_NUMBER\t\t= 0x05,\n\tDELL_DDV_BATTERY_CHEMISTRY_VALUE\t= 0x06,\n\tDELL_DDV_BATTERY_TEMPERATURE\t\t= 0x07,\n\tDELL_DDV_BATTERY_CURRENT\t\t= 0x08,\n\tDELL_DDV_BATTERY_VOLTAGE\t\t= 0x09,\n\tDELL_DDV_BATTERY_MANUFACTURER_ACCESS\t= 0x0A,\n\tDELL_DDV_BATTERY_RELATIVE_CHARGE_STATE\t= 0x0B,\n\tDELL_DDV_BATTERY_CYCLE_COUNT\t\t= 0x0C,\n\tDELL_DDV_BATTERY_EPPID\t\t\t= 0x0D,\n\tDELL_DDV_BATTERY_RAW_ANALYTICS_START\t= 0x0E,\n\tDELL_DDV_BATTERY_RAW_ANALYTICS\t\t= 0x0F,\n\tDELL_DDV_BATTERY_DESIGN_VOLTAGE\t\t= 0x10,\n\tDELL_DDV_BATTERY_RAW_ANALYTICS_A_BLOCK\t= 0x11,  \n\n\tDELL_DDV_INTERFACE_VERSION\t\t= 0x12,\n\n\tDELL_DDV_FAN_SENSOR_INFORMATION\t\t= 0x20,\n\tDELL_DDV_THERMAL_SENSOR_INFORMATION\t= 0x22,\n};\n\nstruct fan_sensor_entry {\n\tu8 type;\n\t__le16 rpm;\n} __packed;\n\nstruct thermal_sensor_entry {\n\tu8 type;\n\ts8 now;\n\ts8 min;\n\ts8 max;\n\tu8 unknown;\n} __packed;\n\nstruct combined_channel_info {\n\tstruct hwmon_channel_info info;\n\tu32 config[];\n};\n\nstruct combined_chip_info {\n\tstruct hwmon_chip_info chip;\n\tconst struct hwmon_channel_info *info[];\n};\n\nstruct dell_wmi_ddv_sensors {\n\tbool active;\n\tstruct mutex lock;\t \n\tunsigned long timestamp;\n\tunion acpi_object *obj;\n\tu64 entries;\n};\n\nstruct dell_wmi_ddv_data {\n\tstruct acpi_battery_hook hook;\n\tstruct device_attribute temp_attr;\n\tstruct device_attribute eppid_attr;\n\tstruct dell_wmi_ddv_sensors fans;\n\tstruct dell_wmi_ddv_sensors temps;\n\tstruct wmi_device *wdev;\n};\n\nstatic const char * const fan_labels[] = {\n\t\"CPU Fan\",\n\t\"Chassis Motherboard Fan\",\n\t\"Video Fan\",\n\t\"Power Supply Fan\",\n\t\"Chipset Fan\",\n\t\"Memory Fan\",\n\t\"PCI Fan\",\n\t\"HDD Fan\",\n};\n\nstatic const char * const fan_dock_labels[] = {\n\t\"Docking Chassis/Motherboard Fan\",\n\t\"Docking Video Fan\",\n\t\"Docking Power Supply Fan\",\n\t\"Docking Chipset Fan\",\n};\n\nstatic int dell_wmi_ddv_query_type(struct wmi_device *wdev, enum dell_ddv_method method, u32 arg,\n\t\t\t\t   union acpi_object **result, acpi_object_type type)\n{\n\tstruct acpi_buffer out = { ACPI_ALLOCATE_BUFFER, NULL };\n\tconst struct acpi_buffer in = {\n\t\t.length = sizeof(arg),\n\t\t.pointer = &arg,\n\t};\n\tunion acpi_object *obj;\n\tacpi_status ret;\n\n\tret = wmidev_evaluate_method(wdev, 0x0, method, &in, &out);\n\tif (ACPI_FAILURE(ret))\n\t\treturn -EIO;\n\n\tobj = out.pointer;\n\tif (!obj)\n\t\treturn -ENODATA;\n\n\tif (obj->type != type) {\n\t\tkfree(obj);\n\t\treturn -ENOMSG;\n\t}\n\n\t*result = obj;\n\n\treturn 0;\n}\n\nstatic int dell_wmi_ddv_query_integer(struct wmi_device *wdev, enum dell_ddv_method method,\n\t\t\t\t      u32 arg, u32 *res)\n{\n\tunion acpi_object *obj;\n\tint ret;\n\n\tret = dell_wmi_ddv_query_type(wdev, method, arg, &obj, ACPI_TYPE_INTEGER);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (obj->integer.value <= U32_MAX)\n\t\t*res = (u32)obj->integer.value;\n\telse\n\t\tret = -ERANGE;\n\n\tkfree(obj);\n\n\treturn ret;\n}\n\nstatic int dell_wmi_ddv_query_buffer(struct wmi_device *wdev, enum dell_ddv_method method,\n\t\t\t\t     u32 arg, union acpi_object **result)\n{\n\tunion acpi_object *obj;\n\tu64 buffer_size;\n\tint ret;\n\n\tret = dell_wmi_ddv_query_type(wdev, method, arg, &obj, ACPI_TYPE_PACKAGE);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (obj->package.count != 2 ||\n\t    obj->package.elements[0].type != ACPI_TYPE_INTEGER ||\n\t    obj->package.elements[1].type != ACPI_TYPE_BUFFER) {\n\t\tret = -ENOMSG;\n\n\t\tgoto err_free;\n\t}\n\n\tbuffer_size = obj->package.elements[0].integer.value;\n\n\tif (!buffer_size) {\n\t\tret = -ENODATA;\n\n\t\tgoto err_free;\n\t}\n\n\tif (buffer_size > obj->package.elements[1].buffer.length) {\n\t\tdev_warn(&wdev->dev,\n\t\t\t FW_WARN \"WMI buffer size (%llu) exceeds ACPI buffer size (%d)\\n\",\n\t\t\t buffer_size, obj->package.elements[1].buffer.length);\n\t\tret = -EMSGSIZE;\n\n\t\tgoto err_free;\n\t}\n\n\t*result = obj;\n\n\treturn 0;\n\nerr_free:\n\tkfree(obj);\n\n\treturn ret;\n}\n\nstatic int dell_wmi_ddv_query_string(struct wmi_device *wdev, enum dell_ddv_method method,\n\t\t\t\t     u32 arg, union acpi_object **result)\n{\n\treturn dell_wmi_ddv_query_type(wdev, method, arg, result, ACPI_TYPE_STRING);\n}\n\n \nstatic int dell_wmi_ddv_update_sensors(struct wmi_device *wdev, enum dell_ddv_method method,\n\t\t\t\t       struct dell_wmi_ddv_sensors *sensors, size_t entry_size)\n{\n\tu64 buffer_size, rem, entries;\n\tunion acpi_object *obj;\n\tu8 *buffer;\n\tint ret;\n\n\tif (sensors->obj) {\n\t\tif (time_before(jiffies, sensors->timestamp + HZ))\n\t\t\treturn 0;\n\n\t\tkfree(sensors->obj);\n\t\tsensors->obj = NULL;\n\t}\n\n\tret = dell_wmi_ddv_query_buffer(wdev, method, 0, &obj);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tbuffer_size = obj->package.elements[0].integer.value;\n\tbuffer = obj->package.elements[1].buffer.pointer;\n\tentries = div64_u64_rem(buffer_size, entry_size, &rem);\n\tif (rem != 1 || buffer[buffer_size - 1] != 0xff) {\n\t\tret = -ENOMSG;\n\t\tgoto err_free;\n\t}\n\n\tif (!entries) {\n\t\tret = -ENODATA;\n\t\tgoto err_free;\n\t}\n\n\tsensors->obj = obj;\n\tsensors->entries = entries;\n\tsensors->timestamp = jiffies;\n\n\treturn 0;\n\nerr_free:\n\tkfree(obj);\n\n\treturn ret;\n}\n\nstatic umode_t dell_wmi_ddv_is_visible(const void *drvdata, enum hwmon_sensor_types type, u32 attr,\n\t\t\t\t       int channel)\n{\n\treturn 0444;\n}\n\nstatic int dell_wmi_ddv_fan_read_channel(struct dell_wmi_ddv_data *data, u32 attr, int channel,\n\t\t\t\t\t long *val)\n{\n\tstruct fan_sensor_entry *entry;\n\tint ret;\n\n\tret = dell_wmi_ddv_update_sensors(data->wdev, DELL_DDV_FAN_SENSOR_INFORMATION,\n\t\t\t\t\t  &data->fans, sizeof(*entry));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (channel >= data->fans.entries)\n\t\treturn -ENXIO;\n\n\tentry = (struct fan_sensor_entry *)data->fans.obj->package.elements[1].buffer.pointer;\n\tswitch (attr) {\n\tcase hwmon_fan_input:\n\t\t*val = get_unaligned_le16(&entry[channel].rpm);\n\t\treturn 0;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic int dell_wmi_ddv_temp_read_channel(struct dell_wmi_ddv_data *data, u32 attr, int channel,\n\t\t\t\t\t  long *val)\n{\n\tstruct thermal_sensor_entry *entry;\n\tint ret;\n\n\tret = dell_wmi_ddv_update_sensors(data->wdev, DELL_DDV_THERMAL_SENSOR_INFORMATION,\n\t\t\t\t\t  &data->temps, sizeof(*entry));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (channel >= data->temps.entries)\n\t\treturn -ENXIO;\n\n\tentry = (struct thermal_sensor_entry *)data->temps.obj->package.elements[1].buffer.pointer;\n\tswitch (attr) {\n\tcase hwmon_temp_input:\n\t\t*val = entry[channel].now * 1000;\n\t\treturn 0;\n\tcase hwmon_temp_min:\n\t\t*val = entry[channel].min * 1000;\n\t\treturn 0;\n\tcase hwmon_temp_max:\n\t\t*val = entry[channel].max * 1000;\n\t\treturn 0;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic int dell_wmi_ddv_read(struct device *dev, enum hwmon_sensor_types type, u32 attr,\n\t\t\t     int channel, long *val)\n{\n\tstruct dell_wmi_ddv_data *data = dev_get_drvdata(dev);\n\tint ret;\n\n\tswitch (type) {\n\tcase hwmon_fan:\n\t\tmutex_lock(&data->fans.lock);\n\t\tret = dell_wmi_ddv_fan_read_channel(data, attr, channel, val);\n\t\tmutex_unlock(&data->fans.lock);\n\t\treturn ret;\n\tcase hwmon_temp:\n\t\tmutex_lock(&data->temps.lock);\n\t\tret = dell_wmi_ddv_temp_read_channel(data, attr, channel, val);\n\t\tmutex_unlock(&data->temps.lock);\n\t\treturn ret;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic int dell_wmi_ddv_fan_read_string(struct dell_wmi_ddv_data *data, int channel,\n\t\t\t\t\tconst char **str)\n{\n\tstruct fan_sensor_entry *entry;\n\tint ret;\n\tu8 type;\n\n\tret = dell_wmi_ddv_update_sensors(data->wdev, DELL_DDV_FAN_SENSOR_INFORMATION,\n\t\t\t\t\t  &data->fans, sizeof(*entry));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (channel >= data->fans.entries)\n\t\treturn -ENXIO;\n\n\tentry = (struct fan_sensor_entry *)data->fans.obj->package.elements[1].buffer.pointer;\n\ttype = entry[channel].type;\n\tswitch (type) {\n\tcase 0x00 ... 0x07:\n\t\t*str = fan_labels[type];\n\t\tbreak;\n\tcase 0x11 ... 0x14:\n\t\t*str = fan_dock_labels[type - 0x11];\n\t\tbreak;\n\tdefault:\n\t\t*str = \"Unknown Fan\";\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int dell_wmi_ddv_temp_read_string(struct dell_wmi_ddv_data *data, int channel,\n\t\t\t\t\t const char **str)\n{\n\tstruct thermal_sensor_entry *entry;\n\tint ret;\n\n\tret = dell_wmi_ddv_update_sensors(data->wdev, DELL_DDV_THERMAL_SENSOR_INFORMATION,\n\t\t\t\t\t  &data->temps, sizeof(*entry));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (channel >= data->temps.entries)\n\t\treturn -ENXIO;\n\n\tentry = (struct thermal_sensor_entry *)data->temps.obj->package.elements[1].buffer.pointer;\n\tswitch (entry[channel].type) {\n\tcase 0x00:\n\t\t*str = \"CPU\";\n\t\tbreak;\n\tcase 0x11:\n\t\t*str = \"Video\";\n\t\tbreak;\n\tcase 0x22:\n\t\t*str = \"Memory\";  \n\t\tbreak;\n\tcase 0x33:\n\t\t*str = \"Other\";\n\t\tbreak;\n\tcase 0x44:\n\t\t*str = \"Ambient\";  \n\t\tbreak;\n\tcase 0x52:\n\t\t*str = \"SODIMM\";\n\t\tbreak;\n\tcase 0x55:\n\t\t*str = \"HDD\";\n\t\tbreak;\n\tcase 0x62:\n\t\t*str = \"SODIMM 2\";\n\t\tbreak;\n\tcase 0x73:\n\t\t*str = \"NB\";\n\t\tbreak;\n\tcase 0x83:\n\t\t*str = \"Charger\";\n\t\tbreak;\n\tcase 0xbb:\n\t\t*str = \"Memory 3\";\n\t\tbreak;\n\tdefault:\n\t\t*str = \"Unknown\";\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int dell_wmi_ddv_read_string(struct device *dev, enum hwmon_sensor_types type, u32 attr,\n\t\t\t\t    int channel, const char **str)\n{\n\tstruct dell_wmi_ddv_data *data = dev_get_drvdata(dev);\n\tint ret;\n\n\tswitch (type) {\n\tcase hwmon_fan:\n\t\tswitch (attr) {\n\t\tcase hwmon_fan_label:\n\t\t\tmutex_lock(&data->fans.lock);\n\t\t\tret = dell_wmi_ddv_fan_read_string(data, channel, str);\n\t\t\tmutex_unlock(&data->fans.lock);\n\t\t\treturn ret;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase hwmon_temp:\n\t\tswitch (attr) {\n\t\tcase hwmon_temp_label:\n\t\t\tmutex_lock(&data->temps.lock);\n\t\t\tret = dell_wmi_ddv_temp_read_string(data, channel, str);\n\t\t\tmutex_unlock(&data->temps.lock);\n\t\t\treturn ret;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic const struct hwmon_ops dell_wmi_ddv_ops = {\n\t.is_visible = dell_wmi_ddv_is_visible,\n\t.read = dell_wmi_ddv_read,\n\t.read_string = dell_wmi_ddv_read_string,\n};\n\nstatic struct hwmon_channel_info *dell_wmi_ddv_channel_create(struct device *dev, u64 count,\n\t\t\t\t\t\t\t      enum hwmon_sensor_types type,\n\t\t\t\t\t\t\t      u32 config)\n{\n\tstruct combined_channel_info *cinfo;\n\tint i;\n\n\tcinfo = devm_kzalloc(dev, struct_size(cinfo, config, count + 1), GFP_KERNEL);\n\tif (!cinfo)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcinfo->info.type = type;\n\tcinfo->info.config = cinfo->config;\n\n\tfor (i = 0; i < count; i++)\n\t\tcinfo->config[i] = config;\n\n\treturn &cinfo->info;\n}\n\nstatic void dell_wmi_ddv_hwmon_cache_invalidate(struct dell_wmi_ddv_sensors *sensors)\n{\n\tif (!sensors->active)\n\t\treturn;\n\n\tmutex_lock(&sensors->lock);\n\tkfree(sensors->obj);\n\tsensors->obj = NULL;\n\tmutex_unlock(&sensors->lock);\n}\n\nstatic void dell_wmi_ddv_hwmon_cache_destroy(void *data)\n{\n\tstruct dell_wmi_ddv_sensors *sensors = data;\n\n\tsensors->active = false;\n\tmutex_destroy(&sensors->lock);\n\tkfree(sensors->obj);\n}\n\nstatic struct hwmon_channel_info *dell_wmi_ddv_channel_init(struct wmi_device *wdev,\n\t\t\t\t\t\t\t    enum dell_ddv_method method,\n\t\t\t\t\t\t\t    struct dell_wmi_ddv_sensors *sensors,\n\t\t\t\t\t\t\t    size_t entry_size,\n\t\t\t\t\t\t\t    enum hwmon_sensor_types type,\n\t\t\t\t\t\t\t    u32 config)\n{\n\tstruct hwmon_channel_info *info;\n\tint ret;\n\n\tret = dell_wmi_ddv_update_sensors(wdev, method, sensors, entry_size);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\n\tmutex_init(&sensors->lock);\n\tsensors->active = true;\n\n\tret = devm_add_action_or_reset(&wdev->dev, dell_wmi_ddv_hwmon_cache_destroy, sensors);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\n\tinfo = dell_wmi_ddv_channel_create(&wdev->dev, sensors->entries, type, config);\n\tif (IS_ERR(info))\n\t\tdevm_release_action(&wdev->dev, dell_wmi_ddv_hwmon_cache_destroy, sensors);\n\n\treturn info;\n}\n\nstatic int dell_wmi_ddv_hwmon_add(struct dell_wmi_ddv_data *data)\n{\n\tstruct wmi_device *wdev = data->wdev;\n\tstruct combined_chip_info *cinfo;\n\tstruct hwmon_channel_info *info;\n\tstruct device *hdev;\n\tint index = 0;\n\tint ret;\n\n\tif (!devres_open_group(&wdev->dev, dell_wmi_ddv_hwmon_add, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\tcinfo = devm_kzalloc(&wdev->dev, struct_size(cinfo, info, 4), GFP_KERNEL);\n\tif (!cinfo) {\n\t\tret = -ENOMEM;\n\n\t\tgoto err_release;\n\t}\n\n\tcinfo->chip.ops = &dell_wmi_ddv_ops;\n\tcinfo->chip.info = cinfo->info;\n\n\tinfo = dell_wmi_ddv_channel_create(&wdev->dev, 1, hwmon_chip, HWMON_C_REGISTER_TZ);\n\tif (IS_ERR(info)) {\n\t\tret = PTR_ERR(info);\n\n\t\tgoto err_release;\n\t}\n\n\tcinfo->info[index] = info;\n\tindex++;\n\n\tinfo = dell_wmi_ddv_channel_init(wdev, DELL_DDV_FAN_SENSOR_INFORMATION, &data->fans,\n\t\t\t\t\t sizeof(struct fan_sensor_entry), hwmon_fan,\n\t\t\t\t\t (HWMON_F_INPUT | HWMON_F_LABEL));\n\tif (!IS_ERR(info)) {\n\t\tcinfo->info[index] = info;\n\t\tindex++;\n\t}\n\n\tinfo = dell_wmi_ddv_channel_init(wdev, DELL_DDV_THERMAL_SENSOR_INFORMATION, &data->temps,\n\t\t\t\t\t sizeof(struct thermal_sensor_entry), hwmon_temp,\n\t\t\t\t\t (HWMON_T_INPUT | HWMON_T_MIN | HWMON_T_MAX |\n\t\t\t\t\t HWMON_T_LABEL));\n\tif (!IS_ERR(info)) {\n\t\tcinfo->info[index] = info;\n\t\tindex++;\n\t}\n\n\tif (index < 2) {\n\t\t \n\t\tret = 0;\n\n\t\tgoto err_release;\n\t}\n\n\thdev = devm_hwmon_device_register_with_info(&wdev->dev, \"dell_ddv\", data, &cinfo->chip,\n\t\t\t\t\t\t    NULL);\n\tif (IS_ERR(hdev)) {\n\t\tret = PTR_ERR(hdev);\n\n\t\tgoto err_release;\n\t}\n\n\tdevres_close_group(&wdev->dev, dell_wmi_ddv_hwmon_add);\n\n\treturn 0;\n\nerr_release:\n\tdevres_release_group(&wdev->dev, dell_wmi_ddv_hwmon_add);\n\n\treturn ret;\n}\n\nstatic int dell_wmi_ddv_battery_index(struct acpi_device *acpi_dev, u32 *index)\n{\n\tconst char *uid_str;\n\n\tuid_str = acpi_device_uid(acpi_dev);\n\tif (!uid_str)\n\t\treturn -ENODEV;\n\n\treturn kstrtou32(uid_str, 10, index);\n}\n\nstatic ssize_t temp_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct dell_wmi_ddv_data *data = container_of(attr, struct dell_wmi_ddv_data, temp_attr);\n\tu32 index, value;\n\tint ret;\n\n\tret = dell_wmi_ddv_battery_index(to_acpi_device(dev->parent), &index);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = dell_wmi_ddv_query_integer(data->wdev, DELL_DDV_BATTERY_TEMPERATURE, index, &value);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\treturn sysfs_emit(buf, \"%d\\n\", value - 2731);\n}\n\nstatic ssize_t eppid_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct dell_wmi_ddv_data *data = container_of(attr, struct dell_wmi_ddv_data, eppid_attr);\n\tunion acpi_object *obj;\n\tu32 index;\n\tint ret;\n\n\tret = dell_wmi_ddv_battery_index(to_acpi_device(dev->parent), &index);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = dell_wmi_ddv_query_string(data->wdev, DELL_DDV_BATTERY_EPPID, index, &obj);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (obj->string.length != DELL_EPPID_LENGTH && obj->string.length != DELL_EPPID_EXT_LENGTH)\n\t\tdev_info_once(&data->wdev->dev, FW_INFO \"Suspicious ePPID length (%d)\\n\",\n\t\t\t      obj->string.length);\n\n\tret = sysfs_emit(buf, \"%s\\n\", obj->string.pointer);\n\n\tkfree(obj);\n\n\treturn ret;\n}\n\nstatic int dell_wmi_ddv_add_battery(struct power_supply *battery, struct acpi_battery_hook *hook)\n{\n\tstruct dell_wmi_ddv_data *data = container_of(hook, struct dell_wmi_ddv_data, hook);\n\tu32 index;\n\tint ret;\n\n\t \n\tret = dell_wmi_ddv_battery_index(to_acpi_device(battery->dev.parent), &index);\n\tif (ret < 0)\n\t\treturn 0;\n\n\tret = device_create_file(&battery->dev, &data->temp_attr);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = device_create_file(&battery->dev, &data->eppid_attr);\n\tif (ret < 0) {\n\t\tdevice_remove_file(&battery->dev, &data->temp_attr);\n\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int dell_wmi_ddv_remove_battery(struct power_supply *battery, struct acpi_battery_hook *hook)\n{\n\tstruct dell_wmi_ddv_data *data = container_of(hook, struct dell_wmi_ddv_data, hook);\n\n\tdevice_remove_file(&battery->dev, &data->temp_attr);\n\tdevice_remove_file(&battery->dev, &data->eppid_attr);\n\n\treturn 0;\n}\n\nstatic void dell_wmi_ddv_battery_remove(void *data)\n{\n\tstruct acpi_battery_hook *hook = data;\n\n\tbattery_hook_unregister(hook);\n}\n\nstatic int dell_wmi_ddv_battery_add(struct dell_wmi_ddv_data *data)\n{\n\tdata->hook.name = \"Dell DDV Battery Extension\";\n\tdata->hook.add_battery = dell_wmi_ddv_add_battery;\n\tdata->hook.remove_battery = dell_wmi_ddv_remove_battery;\n\n\tsysfs_attr_init(&data->temp_attr.attr);\n\tdata->temp_attr.attr.name = \"temp\";\n\tdata->temp_attr.attr.mode = 0444;\n\tdata->temp_attr.show = temp_show;\n\n\tsysfs_attr_init(&data->eppid_attr.attr);\n\tdata->eppid_attr.attr.name = \"eppid\";\n\tdata->eppid_attr.attr.mode = 0444;\n\tdata->eppid_attr.show = eppid_show;\n\n\tbattery_hook_register(&data->hook);\n\n\treturn devm_add_action_or_reset(&data->wdev->dev, dell_wmi_ddv_battery_remove, &data->hook);\n}\n\nstatic int dell_wmi_ddv_buffer_read(struct seq_file *seq, enum dell_ddv_method method)\n{\n\tstruct device *dev = seq->private;\n\tstruct dell_wmi_ddv_data *data = dev_get_drvdata(dev);\n\tunion acpi_object *obj;\n\tu64 size;\n\tu8 *buf;\n\tint ret;\n\n\tret = dell_wmi_ddv_query_buffer(data->wdev, method, 0, &obj);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tsize = obj->package.elements[0].integer.value;\n\tbuf = obj->package.elements[1].buffer.pointer;\n\tret = seq_write(seq, buf, size);\n\tkfree(obj);\n\n\treturn ret;\n}\n\nstatic int dell_wmi_ddv_fan_read(struct seq_file *seq, void *offset)\n{\n\treturn dell_wmi_ddv_buffer_read(seq, DELL_DDV_FAN_SENSOR_INFORMATION);\n}\n\nstatic int dell_wmi_ddv_temp_read(struct seq_file *seq, void *offset)\n{\n\treturn dell_wmi_ddv_buffer_read(seq, DELL_DDV_THERMAL_SENSOR_INFORMATION);\n}\n\nstatic void dell_wmi_ddv_debugfs_remove(void *data)\n{\n\tstruct dentry *entry = data;\n\n\tdebugfs_remove(entry);\n}\n\nstatic void dell_wmi_ddv_debugfs_init(struct wmi_device *wdev)\n{\n\tstruct dentry *entry;\n\tchar name[64];\n\n\tscnprintf(name, ARRAY_SIZE(name), \"%s-%s\", DRIVER_NAME, dev_name(&wdev->dev));\n\tentry = debugfs_create_dir(name, NULL);\n\n\tdebugfs_create_devm_seqfile(&wdev->dev, \"fan_sensor_information\", entry,\n\t\t\t\t    dell_wmi_ddv_fan_read);\n\tdebugfs_create_devm_seqfile(&wdev->dev, \"thermal_sensor_information\", entry,\n\t\t\t\t    dell_wmi_ddv_temp_read);\n\n\tdevm_add_action_or_reset(&wdev->dev, dell_wmi_ddv_debugfs_remove, entry);\n}\n\nstatic int dell_wmi_ddv_probe(struct wmi_device *wdev, const void *context)\n{\n\tstruct dell_wmi_ddv_data *data;\n\tu32 version;\n\tint ret;\n\n\tret = dell_wmi_ddv_query_integer(wdev, DELL_DDV_INTERFACE_VERSION, 0, &version);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdev_dbg(&wdev->dev, \"WMI interface version: %d\\n\", version);\n\tif (version < DELL_DDV_SUPPORTED_VERSION_MIN || version > DELL_DDV_SUPPORTED_VERSION_MAX) {\n\t\tif (!force)\n\t\t\treturn -ENODEV;\n\n\t\tdev_warn(&wdev->dev, \"Loading despite unsupported WMI interface version (%u)\\n\",\n\t\t\t version);\n\t}\n\n\tdata = devm_kzalloc(&wdev->dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdev_set_drvdata(&wdev->dev, data);\n\tdata->wdev = wdev;\n\n\tdell_wmi_ddv_debugfs_init(wdev);\n\n\tif (IS_REACHABLE(CONFIG_ACPI_BATTERY)) {\n\t\tret = dell_wmi_ddv_battery_add(data);\n\t\tif (ret < 0)\n\t\t\tdev_warn(&wdev->dev, \"Unable to register ACPI battery hook: %d\\n\", ret);\n\t}\n\n\tif (IS_REACHABLE(CONFIG_HWMON)) {\n\t\tret = dell_wmi_ddv_hwmon_add(data);\n\t\tif (ret < 0)\n\t\t\tdev_warn(&wdev->dev, \"Unable to register hwmon interface: %d\\n\", ret);\n\t}\n\n\treturn 0;\n}\n\nstatic int dell_wmi_ddv_resume(struct device *dev)\n{\n\tstruct dell_wmi_ddv_data *data = dev_get_drvdata(dev);\n\n\t \n\tdell_wmi_ddv_hwmon_cache_invalidate(&data->fans);\n\tdell_wmi_ddv_hwmon_cache_invalidate(&data->temps);\n\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(dell_wmi_ddv_dev_pm_ops, NULL, dell_wmi_ddv_resume);\n\nstatic const struct wmi_device_id dell_wmi_ddv_id_table[] = {\n\t{ DELL_DDV_GUID, NULL },\n\t{ }\n};\nMODULE_DEVICE_TABLE(wmi, dell_wmi_ddv_id_table);\n\nstatic struct wmi_driver dell_wmi_ddv_driver = {\n\t.driver = {\n\t\t.name = DRIVER_NAME,\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t\t.pm = pm_sleep_ptr(&dell_wmi_ddv_dev_pm_ops),\n\t},\n\t.id_table = dell_wmi_ddv_id_table,\n\t.probe = dell_wmi_ddv_probe,\n};\nmodule_wmi_driver(dell_wmi_ddv_driver);\n\nMODULE_AUTHOR(\"Armin Wolf <W_Armin@gmx.de>\");\nMODULE_DESCRIPTION(\"Dell WMI sensor driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}