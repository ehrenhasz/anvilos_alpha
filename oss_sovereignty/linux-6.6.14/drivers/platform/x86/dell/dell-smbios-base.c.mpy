{
  "module_name": "dell-smbios-base.c",
  "hash_id": "17aa774509b0e7b5f2e3da0ce6b4bc55ff70934a0cd42a3ea5ebde9e1a0a26ad",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/x86/dell/dell-smbios-base.c",
  "human_readable_source": "\n \n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/capability.h>\n#include <linux/dmi.h>\n#include <linux/err.h>\n#include <linux/mutex.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include \"dell-smbios.h\"\n\nstatic u32 da_supported_commands;\nstatic int da_num_tokens;\nstatic struct platform_device *platform_device;\nstatic struct calling_interface_token *da_tokens;\nstatic struct device_attribute *token_location_attrs;\nstatic struct device_attribute *token_value_attrs;\nstatic struct attribute **token_attrs;\nstatic DEFINE_MUTEX(smbios_mutex);\n\nstruct smbios_device {\n\tstruct list_head list;\n\tstruct device *device;\n\tint (*call_fn)(struct calling_interface_buffer *arg);\n};\n\nstruct smbios_call {\n\tu32 need_capability;\n\tint cmd_class;\n\tint cmd_select;\n};\n\n \nstatic struct smbios_call call_whitelist[] = {\n\t \n\t{CAP_SYS_ADMIN,\tCLASS_TOKEN_READ,\tSELECT_TOKEN_STD},\n\t{CAP_SYS_ADMIN,\tCLASS_TOKEN_READ,\tSELECT_TOKEN_AC},\n\t{CAP_SYS_ADMIN,\tCLASS_TOKEN_READ,\tSELECT_TOKEN_BAT},\n\t{CAP_SYS_ADMIN,\tCLASS_TOKEN_WRITE,\tSELECT_TOKEN_STD},\n\t{CAP_SYS_ADMIN,\tCLASS_TOKEN_WRITE,\tSELECT_TOKEN_AC},\n\t{CAP_SYS_ADMIN,\tCLASS_TOKEN_WRITE,\tSELECT_TOKEN_BAT},\n\t \n\t{CAP_SYS_ADMIN, CLASS_ADMIN_PROP,\tSELECT_ADMIN_PROP},\n\t \n\t{CAP_SYS_ADMIN,\tCLASS_INFO,\t\tSELECT_DOCK},\n\t{CAP_SYS_ADMIN,\tCLASS_FLASH_INTERFACE,\tSELECT_FLASH_INTERFACE},\n};\n\n \nstatic struct smbios_call call_blacklist[] = {\n\t{0x0000,  1,  7},  \n\t{0x0000,  6,  5},  \n\t{0x0000, 11,  3},  \n\t{0x0000, 11,  7},  \n\t{0x0000, 11, 11},  \n\t{0x0000, 19, -1},  \n\t \n\t{0x0000, CLASS_INFO, SELECT_RFKILL},\n\t{0x0000, CLASS_KBD_BACKLIGHT, SELECT_KBD_BACKLIGHT},\n};\n\nstruct token_range {\n\tu32 need_capability;\n\tu16 min;\n\tu16 max;\n};\n\n \nstatic struct token_range token_whitelist[] = {\n\t \n\t{CAP_SYS_ADMIN,\tCAPSULE_EN_TOKEN,\tCAPSULE_DIS_TOKEN},\n\t \n\t{0x0000,\tWSMT_EN_TOKEN,\t\tWSMT_DIS_TOKEN}\n};\n\n \nstatic struct token_range token_blacklist[] = {\n\t{0x0000, 0x0058, 0x0059},  \n\t{0x0000, 0x00CD, 0x00D0},  \n\t{0x0000, 0x013A, 0x01FF},  \n\t{0x0000, 0x0175, 0x0176},  \n\t{0x0000, 0x0195, 0x0197},  \n\t{0x0000, 0x01DC, 0x01DD},  \n\t{0x0000, 0x027D, 0x0284},  \n\t{0x0000, 0x02E3, 0x02E3},  \n\t{0x0000, 0x02FF, 0x02FF},  \n\t{0x0000, 0x0300, 0x0302},  \n\t{0x0000, 0x0325, 0x0326},  \n\t{0x0000, 0x0332, 0x0335},  \n\t{0x0000, 0x0350, 0x0350},  \n\t{0x0000, 0x0363, 0x0363},  \n\t{0x0000, 0x0368, 0x0368},  \n\t{0x0000, 0x03F6, 0x03F7},  \n\t{0x0000, 0x049E, 0x049F},  \n\t{0x0000, 0x04A0, 0x04A3},  \n\t{0x0000, 0x04E6, 0x04E7},  \n\t{0x0000, 0x4000, 0x7FFF},  \n\t{0x0000, 0x9000, 0x9001},  \n\t{0x0000, 0xA000, 0xBFFF},  \n\t{0x0000, 0xEFF0, 0xEFFF},  \n\t \n\t{0x0000, BRIGHTNESS_TOKEN,\tBRIGHTNESS_TOKEN},\n\t{0x0000, KBD_LED_OFF_TOKEN,\tKBD_LED_AUTO_TOKEN},\n\t{0x0000, KBD_LED_AC_TOKEN,\tKBD_LED_AC_TOKEN},\n\t{0x0000, KBD_LED_AUTO_25_TOKEN,\tKBD_LED_AUTO_75_TOKEN},\n\t{0x0000, KBD_LED_AUTO_100_TOKEN,\tKBD_LED_AUTO_100_TOKEN},\n\t{0x0000, GLOBAL_MIC_MUTE_ENABLE,\tGLOBAL_MIC_MUTE_DISABLE},\n};\n\nstatic LIST_HEAD(smbios_device_list);\n\nint dell_smbios_error(int value)\n{\n\tswitch (value) {\n\tcase 0:  \n\t\treturn 0;\n\tcase -1:  \n\t\treturn -EIO;\n\tcase -2:  \n\t\treturn -ENXIO;\n\tdefault:  \n\t\treturn -EINVAL;\n\t}\n}\nEXPORT_SYMBOL_GPL(dell_smbios_error);\n\nint dell_smbios_register_device(struct device *d, void *call_fn)\n{\n\tstruct smbios_device *priv;\n\n\tpriv = devm_kzalloc(d, sizeof(struct smbios_device), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\tget_device(d);\n\tpriv->device = d;\n\tpriv->call_fn = call_fn;\n\tmutex_lock(&smbios_mutex);\n\tlist_add_tail(&priv->list, &smbios_device_list);\n\tmutex_unlock(&smbios_mutex);\n\tdev_dbg(d, \"Added device: %s\\n\", d->driver->name);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(dell_smbios_register_device);\n\nvoid dell_smbios_unregister_device(struct device *d)\n{\n\tstruct smbios_device *priv;\n\n\tmutex_lock(&smbios_mutex);\n\tlist_for_each_entry(priv, &smbios_device_list, list) {\n\t\tif (priv->device == d) {\n\t\t\tlist_del(&priv->list);\n\t\t\tput_device(d);\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&smbios_mutex);\n\tdev_dbg(d, \"Remove device: %s\\n\", d->driver->name);\n}\nEXPORT_SYMBOL_GPL(dell_smbios_unregister_device);\n\nint dell_smbios_call_filter(struct device *d,\n\t\t\t    struct calling_interface_buffer *buffer)\n{\n\tu16 t = 0;\n\tint i;\n\n\t \n\tif (buffer->cmd_class > 30) {\n\t\tdev_dbg(d, \"class too big: %u\\n\", buffer->cmd_class);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (!(da_supported_commands & (1 << buffer->cmd_class))) {\n\t\tdev_dbg(d, \"invalid command, supported commands: 0x%8x\\n\",\n\t\t\tda_supported_commands);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(call_blacklist); i++) {\n\t\tif (buffer->cmd_class != call_blacklist[i].cmd_class)\n\t\t\tcontinue;\n\t\tif (buffer->cmd_select != call_blacklist[i].cmd_select &&\n\t\t    call_blacklist[i].cmd_select != -1)\n\t\t\tcontinue;\n\t\tdev_dbg(d, \"blacklisted command: %u/%u\\n\",\n\t\t\tbuffer->cmd_class, buffer->cmd_select);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\n\tif ((buffer->cmd_class == CLASS_TOKEN_READ ||\n\t     buffer->cmd_class == CLASS_TOKEN_WRITE) &&\n\t     buffer->cmd_select < 3) {\n\t\t \n\t\tif (!da_tokens) {\n\t\t\tdev_dbg(d, \"no token support on this system\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tfor (i = 0; i < da_num_tokens; i++) {\n\t\t\tif (da_tokens[i].location != buffer->input[0])\n\t\t\t\tcontinue;\n\t\t\tt = da_tokens[i].tokenID;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (!t) {\n\t\t\tdev_dbg(d, \"token at location %04x doesn't exist\\n\",\n\t\t\t\tbuffer->input[0]);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tfor (i = 0; i < ARRAY_SIZE(token_blacklist); i++) {\n\t\t\tif (!token_blacklist[i].min || !token_blacklist[i].max)\n\t\t\t\tcontinue;\n\t\t\tif (t >= token_blacklist[i].min &&\n\t\t\t    t <= token_blacklist[i].max)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tfor (i = 0; i < ARRAY_SIZE(token_whitelist); i++) {\n\t\t\tif (!token_whitelist[i].min || !token_whitelist[i].max)\n\t\t\t\tcontinue;\n\t\t\tif (t < token_whitelist[i].min ||\n\t\t\t    t > token_whitelist[i].max)\n\t\t\t\tcontinue;\n\t\t\tif (!token_whitelist[i].need_capability ||\n\t\t\t    capable(token_whitelist[i].need_capability)) {\n\t\t\t\tdev_dbg(d, \"whitelisted token: %x\\n\", t);\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t}\n\t}\n\t \n\tfor (i = 0; i < ARRAY_SIZE(call_whitelist); i++) {\n\t\tif (buffer->cmd_class != call_whitelist[i].cmd_class)\n\t\t\tcontinue;\n\t\tif (buffer->cmd_select != call_whitelist[i].cmd_select)\n\t\t\tcontinue;\n\t\tif (!call_whitelist[i].need_capability ||\n\t\t    capable(call_whitelist[i].need_capability)) {\n\t\t\tdev_dbg(d, \"whitelisted capable command: %u/%u\\n\",\n\t\t\tbuffer->cmd_class, buffer->cmd_select);\n\t\t\treturn 0;\n\t\t}\n\t\tdev_dbg(d, \"missing capability %d for %u/%u\\n\",\n\t\t\tcall_whitelist[i].need_capability,\n\t\t\tbuffer->cmd_class, buffer->cmd_select);\n\n\t}\n\n\t \n\tif (capable(CAP_SYS_RAWIO)) {\n\t\tdev_dbg(d, \"Allowing %u/%u due to CAP_SYS_RAWIO\\n\",\n\t\t\tbuffer->cmd_class, buffer->cmd_select);\n\t\treturn 0;\n\t}\n\n\treturn -EACCES;\n}\nEXPORT_SYMBOL_GPL(dell_smbios_call_filter);\n\nint dell_smbios_call(struct calling_interface_buffer *buffer)\n{\n\tint (*call_fn)(struct calling_interface_buffer *) = NULL;\n\tstruct device *selected_dev = NULL;\n\tstruct smbios_device *priv;\n\tint ret;\n\n\tmutex_lock(&smbios_mutex);\n\tlist_for_each_entry(priv, &smbios_device_list, list) {\n\t\tif (!selected_dev || priv->device->id >= selected_dev->id) {\n\t\t\tdev_dbg(priv->device, \"Trying device ID: %d\\n\",\n\t\t\t\tpriv->device->id);\n\t\t\tcall_fn = priv->call_fn;\n\t\t\tselected_dev = priv->device;\n\t\t}\n\t}\n\n\tif (!selected_dev) {\n\t\tret = -ENODEV;\n\t\tpr_err(\"No dell-smbios drivers are loaded\\n\");\n\t\tgoto out_smbios_call;\n\t}\n\n\tret = call_fn(buffer);\n\nout_smbios_call:\n\tmutex_unlock(&smbios_mutex);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(dell_smbios_call);\n\nstruct calling_interface_token *dell_smbios_find_token(int tokenid)\n{\n\tint i;\n\n\tif (!da_tokens)\n\t\treturn NULL;\n\n\tfor (i = 0; i < da_num_tokens; i++) {\n\t\tif (da_tokens[i].tokenID == tokenid)\n\t\t\treturn &da_tokens[i];\n\t}\n\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(dell_smbios_find_token);\n\nstatic BLOCKING_NOTIFIER_HEAD(dell_laptop_chain_head);\n\nint dell_laptop_register_notifier(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_register(&dell_laptop_chain_head, nb);\n}\nEXPORT_SYMBOL_GPL(dell_laptop_register_notifier);\n\nint dell_laptop_unregister_notifier(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_unregister(&dell_laptop_chain_head, nb);\n}\nEXPORT_SYMBOL_GPL(dell_laptop_unregister_notifier);\n\nvoid dell_laptop_call_notifier(unsigned long action, void *data)\n{\n\tblocking_notifier_call_chain(&dell_laptop_chain_head, action, data);\n}\nEXPORT_SYMBOL_GPL(dell_laptop_call_notifier);\n\nstatic void __init parse_da_table(const struct dmi_header *dm)\n{\n\t \n\tint tokens = (dm->length-11)/sizeof(struct calling_interface_token)-1;\n\tstruct calling_interface_token *new_da_tokens;\n\tstruct calling_interface_structure *table =\n\t\tcontainer_of(dm, struct calling_interface_structure, header);\n\n\t \n\n\tif (dm->length < 17)\n\t\treturn;\n\n\tda_supported_commands = table->supportedCmds;\n\n\tnew_da_tokens = krealloc(da_tokens, (da_num_tokens + tokens) *\n\t\t\t\t sizeof(struct calling_interface_token),\n\t\t\t\t GFP_KERNEL);\n\n\tif (!new_da_tokens)\n\t\treturn;\n\tda_tokens = new_da_tokens;\n\n\tmemcpy(da_tokens+da_num_tokens, table->tokens,\n\t       sizeof(struct calling_interface_token) * tokens);\n\n\tda_num_tokens += tokens;\n}\n\nstatic void zero_duplicates(struct device *dev)\n{\n\tint i, j;\n\n\tfor (i = 0; i < da_num_tokens; i++) {\n\t\tif (da_tokens[i].tokenID == 0)\n\t\t\tcontinue;\n\t\tfor (j = i+1; j < da_num_tokens; j++) {\n\t\t\tif (da_tokens[j].tokenID == 0)\n\t\t\t\tcontinue;\n\t\t\tif (da_tokens[i].tokenID == da_tokens[j].tokenID) {\n\t\t\t\tdev_dbg(dev, \"Zeroing dup token ID %x(%x/%x)\\n\",\n\t\t\t\t\tda_tokens[j].tokenID,\n\t\t\t\t\tda_tokens[j].location,\n\t\t\t\t\tda_tokens[j].value);\n\t\t\t\tda_tokens[j].tokenID = 0;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void __init find_tokens(const struct dmi_header *dm, void *dummy)\n{\n\tswitch (dm->type) {\n\tcase 0xd4:  \n\tcase 0xd5:  \n\tcase 0xd6:  \n\t\tbreak;\n\tcase 0xda:  \n\t\tparse_da_table(dm);\n\t\tbreak;\n\t}\n}\n\nstatic int match_attribute(struct device *dev,\n\t\t\t   struct device_attribute *attr)\n{\n\tint i;\n\n\tfor (i = 0; i < da_num_tokens * 2; i++) {\n\t\tif (!token_attrs[i])\n\t\t\tcontinue;\n\t\tif (strcmp(token_attrs[i]->name, attr->attr.name) == 0)\n\t\t\treturn i/2;\n\t}\n\tdev_dbg(dev, \"couldn't match: %s\\n\", attr->attr.name);\n\treturn -EINVAL;\n}\n\nstatic ssize_t location_show(struct device *dev,\n\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tint i;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\ti = match_attribute(dev, attr);\n\tif (i > 0)\n\t\treturn sysfs_emit(buf, \"%08x\", da_tokens[i].location);\n\treturn 0;\n}\n\nstatic ssize_t value_show(struct device *dev,\n\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tint i;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\ti = match_attribute(dev, attr);\n\tif (i > 0)\n\t\treturn sysfs_emit(buf, \"%08x\", da_tokens[i].value);\n\treturn 0;\n}\n\nstatic struct attribute_group smbios_attribute_group = {\n\t.name = \"tokens\"\n};\n\nstatic struct platform_driver platform_driver = {\n\t.driver = {\n\t\t.name = \"dell-smbios\",\n\t},\n};\n\nstatic int build_tokens_sysfs(struct platform_device *dev)\n{\n\tchar *location_name;\n\tchar *value_name;\n\tsize_t size;\n\tint ret;\n\tint i, j;\n\n\t \n\tsize = sizeof(struct device_attribute) * (da_num_tokens + 1);\n\ttoken_location_attrs = kzalloc(size, GFP_KERNEL);\n\tif (!token_location_attrs)\n\t\treturn -ENOMEM;\n\ttoken_value_attrs = kzalloc(size, GFP_KERNEL);\n\tif (!token_value_attrs)\n\t\tgoto out_allocate_value;\n\n\t \n\tsize = sizeof(struct attribute *) * ((2 * da_num_tokens) + 1);\n\ttoken_attrs = kzalloc(size, GFP_KERNEL);\n\tif (!token_attrs)\n\t\tgoto out_allocate_attrs;\n\n\tfor (i = 0, j = 0; i < da_num_tokens; i++) {\n\t\t \n\t\tif (da_tokens[i].tokenID == 0)\n\t\t\tcontinue;\n\t\t \n\t\tlocation_name = kasprintf(GFP_KERNEL, \"%04x_location\",\n\t\t\t\t\t  da_tokens[i].tokenID);\n\t\tif (location_name == NULL)\n\t\t\tgoto out_unwind_strings;\n\t\tsysfs_attr_init(&token_location_attrs[i].attr);\n\t\ttoken_location_attrs[i].attr.name = location_name;\n\t\ttoken_location_attrs[i].attr.mode = 0444;\n\t\ttoken_location_attrs[i].show = location_show;\n\t\ttoken_attrs[j++] = &token_location_attrs[i].attr;\n\n\t\t \n\t\tvalue_name = kasprintf(GFP_KERNEL, \"%04x_value\",\n\t\t\t\t       da_tokens[i].tokenID);\n\t\tif (value_name == NULL)\n\t\t\tgoto loop_fail_create_value;\n\t\tsysfs_attr_init(&token_value_attrs[i].attr);\n\t\ttoken_value_attrs[i].attr.name = value_name;\n\t\ttoken_value_attrs[i].attr.mode = 0444;\n\t\ttoken_value_attrs[i].show = value_show;\n\t\ttoken_attrs[j++] = &token_value_attrs[i].attr;\n\t\tcontinue;\n\nloop_fail_create_value:\n\t\tkfree(location_name);\n\t\tgoto out_unwind_strings;\n\t}\n\tsmbios_attribute_group.attrs = token_attrs;\n\n\tret = sysfs_create_group(&dev->dev.kobj, &smbios_attribute_group);\n\tif (ret)\n\t\tgoto out_unwind_strings;\n\treturn 0;\n\nout_unwind_strings:\n\twhile (i--) {\n\t\tkfree(token_location_attrs[i].attr.name);\n\t\tkfree(token_value_attrs[i].attr.name);\n\t}\n\tkfree(token_attrs);\nout_allocate_attrs:\n\tkfree(token_value_attrs);\nout_allocate_value:\n\tkfree(token_location_attrs);\n\n\treturn -ENOMEM;\n}\n\nstatic void free_group(struct platform_device *pdev)\n{\n\tint i;\n\n\tsysfs_remove_group(&pdev->dev.kobj,\n\t\t\t\t&smbios_attribute_group);\n\tfor (i = 0; i < da_num_tokens; i++) {\n\t\tkfree(token_location_attrs[i].attr.name);\n\t\tkfree(token_value_attrs[i].attr.name);\n\t}\n\tkfree(token_attrs);\n\tkfree(token_value_attrs);\n\tkfree(token_location_attrs);\n}\n\nstatic int __init dell_smbios_init(void)\n{\n\tint ret, wmi, smm;\n\n\tif (!dmi_find_device(DMI_DEV_TYPE_OEM_STRING, \"Dell System\", NULL) &&\n\t    !dmi_find_device(DMI_DEV_TYPE_OEM_STRING, \"www.dell.com\", NULL)) {\n\t\tpr_err(\"Unable to run on non-Dell system\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tdmi_walk(find_tokens, NULL);\n\n\tret = platform_driver_register(&platform_driver);\n\tif (ret)\n\t\tgoto fail_platform_driver;\n\n\tplatform_device = platform_device_alloc(\"dell-smbios\", 0);\n\tif (!platform_device) {\n\t\tret = -ENOMEM;\n\t\tgoto fail_platform_device_alloc;\n\t}\n\tret = platform_device_add(platform_device);\n\tif (ret)\n\t\tgoto fail_platform_device_add;\n\n\t \n\twmi = init_dell_smbios_wmi();\n\tif (wmi)\n\t\tpr_debug(\"Failed to initialize WMI backend: %d\\n\", wmi);\n\tsmm = init_dell_smbios_smm();\n\tif (smm)\n\t\tpr_debug(\"Failed to initialize SMM backend: %d\\n\", smm);\n\tif (wmi && smm) {\n\t\tpr_err(\"No SMBIOS backends available (wmi: %d, smm: %d)\\n\",\n\t\t\twmi, smm);\n\t\tret = -ENODEV;\n\t\tgoto fail_create_group;\n\t}\n\n\tif (da_tokens)  {\n\t\t \n\t\tzero_duplicates(&platform_device->dev);\n\n\t\tret = build_tokens_sysfs(platform_device);\n\t\tif (ret)\n\t\t\tgoto fail_sysfs;\n\t}\n\n\treturn 0;\n\nfail_sysfs:\n\tfree_group(platform_device);\n\nfail_create_group:\n\tplatform_device_del(platform_device);\n\nfail_platform_device_add:\n\tplatform_device_put(platform_device);\n\nfail_platform_device_alloc:\n\tplatform_driver_unregister(&platform_driver);\n\nfail_platform_driver:\n\tkfree(da_tokens);\n\treturn ret;\n}\n\nstatic void __exit dell_smbios_exit(void)\n{\n\texit_dell_smbios_wmi();\n\texit_dell_smbios_smm();\n\tmutex_lock(&smbios_mutex);\n\tif (platform_device) {\n\t\tif (da_tokens)\n\t\t\tfree_group(platform_device);\n\t\tplatform_device_unregister(platform_device);\n\t\tplatform_driver_unregister(&platform_driver);\n\t}\n\tkfree(da_tokens);\n\tmutex_unlock(&smbios_mutex);\n}\n\nmodule_init(dell_smbios_init);\nmodule_exit(dell_smbios_exit);\n\nMODULE_AUTHOR(\"Matthew Garrett <mjg@redhat.com>\");\nMODULE_AUTHOR(\"Gabriele Mazzotta <gabriele.mzt@gmail.com>\");\nMODULE_AUTHOR(\"Pali Roh\u00e1r <pali@kernel.org>\");\nMODULE_AUTHOR(\"Mario Limonciello <mario.limonciello@outlook.com>\");\nMODULE_DESCRIPTION(\"Common functions for kernel modules using Dell SMBIOS\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}