{
  "module_name": "dell-rbtn.c",
  "hash_id": "b7b147e27514d8fcf6bcaa13c002d1b0efd344c54d82dfce641acfbb39593f2b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/x86/dell/dell-rbtn.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/acpi.h>\n#include <linux/rfkill.h>\n#include <linux/input.h>\n\n#include \"dell-rbtn.h\"\n\nenum rbtn_type {\n\tRBTN_UNKNOWN,\n\tRBTN_TOGGLE,\n\tRBTN_SLIDER,\n};\n\nstruct rbtn_data {\n\tenum rbtn_type type;\n\tstruct rfkill *rfkill;\n\tstruct input_dev *input_dev;\n\tbool suspended;\n};\n\n\n \n\nstatic enum rbtn_type rbtn_check(struct acpi_device *device)\n{\n\tunsigned long long output;\n\tacpi_status status;\n\n\tstatus = acpi_evaluate_integer(device->handle, \"CRBT\", NULL, &output);\n\tif (ACPI_FAILURE(status))\n\t\treturn RBTN_UNKNOWN;\n\n\tswitch (output) {\n\tcase 0:\n\tcase 1:\n\t\treturn RBTN_TOGGLE;\n\tcase 2:\n\tcase 3:\n\t\treturn RBTN_SLIDER;\n\tdefault:\n\t\treturn RBTN_UNKNOWN;\n\t}\n}\n\nstatic int rbtn_get(struct acpi_device *device)\n{\n\tunsigned long long output;\n\tacpi_status status;\n\n\tstatus = acpi_evaluate_integer(device->handle, \"GRBT\", NULL, &output);\n\tif (ACPI_FAILURE(status))\n\t\treturn -EINVAL;\n\n\treturn !output;\n}\n\nstatic int rbtn_acquire(struct acpi_device *device, bool enable)\n{\n\tstruct acpi_object_list input;\n\tunion acpi_object param;\n\tacpi_status status;\n\n\tparam.type = ACPI_TYPE_INTEGER;\n\tparam.integer.value = enable;\n\tinput.count = 1;\n\tinput.pointer = &param;\n\n\tstatus = acpi_evaluate_object(device->handle, \"ARBT\", &input, NULL);\n\tif (ACPI_FAILURE(status))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n\n \n\nstatic void rbtn_rfkill_query(struct rfkill *rfkill, void *data)\n{\n\tstruct acpi_device *device = data;\n\tint state;\n\n\tstate = rbtn_get(device);\n\tif (state < 0)\n\t\treturn;\n\n\trfkill_set_states(rfkill, state, state);\n}\n\nstatic int rbtn_rfkill_set_block(void *data, bool blocked)\n{\n\t \n\treturn -EINVAL;\n}\n\nstatic const struct rfkill_ops rbtn_ops = {\n\t.query = rbtn_rfkill_query,\n\t.set_block = rbtn_rfkill_set_block,\n};\n\nstatic int rbtn_rfkill_init(struct acpi_device *device)\n{\n\tstruct rbtn_data *rbtn_data = device->driver_data;\n\tint ret;\n\n\tif (rbtn_data->rfkill)\n\t\treturn 0;\n\n\t \n\trbtn_data->rfkill = rfkill_alloc(\"dell-rbtn\", &device->dev,\n\t\t\t\t\t RFKILL_TYPE_WLAN, &rbtn_ops, device);\n\tif (!rbtn_data->rfkill)\n\t\treturn -ENOMEM;\n\n\tret = rfkill_register(rbtn_data->rfkill);\n\tif (ret) {\n\t\trfkill_destroy(rbtn_data->rfkill);\n\t\trbtn_data->rfkill = NULL;\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void rbtn_rfkill_exit(struct acpi_device *device)\n{\n\tstruct rbtn_data *rbtn_data = device->driver_data;\n\n\tif (!rbtn_data->rfkill)\n\t\treturn;\n\n\trfkill_unregister(rbtn_data->rfkill);\n\trfkill_destroy(rbtn_data->rfkill);\n\trbtn_data->rfkill = NULL;\n}\n\nstatic void rbtn_rfkill_event(struct acpi_device *device)\n{\n\tstruct rbtn_data *rbtn_data = device->driver_data;\n\n\tif (rbtn_data->rfkill)\n\t\trbtn_rfkill_query(rbtn_data->rfkill, device);\n}\n\n\n \n\nstatic int rbtn_input_init(struct rbtn_data *rbtn_data)\n{\n\tint ret;\n\n\trbtn_data->input_dev = input_allocate_device();\n\tif (!rbtn_data->input_dev)\n\t\treturn -ENOMEM;\n\n\trbtn_data->input_dev->name = \"DELL Wireless hotkeys\";\n\trbtn_data->input_dev->phys = \"dellabce/input0\";\n\trbtn_data->input_dev->id.bustype = BUS_HOST;\n\trbtn_data->input_dev->evbit[0] = BIT(EV_KEY);\n\tset_bit(KEY_RFKILL, rbtn_data->input_dev->keybit);\n\n\tret = input_register_device(rbtn_data->input_dev);\n\tif (ret) {\n\t\tinput_free_device(rbtn_data->input_dev);\n\t\trbtn_data->input_dev = NULL;\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void rbtn_input_exit(struct rbtn_data *rbtn_data)\n{\n\tinput_unregister_device(rbtn_data->input_dev);\n\trbtn_data->input_dev = NULL;\n}\n\nstatic void rbtn_input_event(struct rbtn_data *rbtn_data)\n{\n\tinput_report_key(rbtn_data->input_dev, KEY_RFKILL, 1);\n\tinput_sync(rbtn_data->input_dev);\n\tinput_report_key(rbtn_data->input_dev, KEY_RFKILL, 0);\n\tinput_sync(rbtn_data->input_dev);\n}\n\n\n \n\nstatic int rbtn_add(struct acpi_device *device);\nstatic void rbtn_remove(struct acpi_device *device);\nstatic void rbtn_notify(struct acpi_device *device, u32 event);\n\nstatic const struct acpi_device_id rbtn_ids[] = {\n\t{ \"DELRBTN\", 0 },\n\t{ \"DELLABCE\", 0 },\n\n\t \n\n\t{ \"\", 0 },\n};\n\n#ifdef CONFIG_PM_SLEEP\nstatic void ACPI_SYSTEM_XFACE rbtn_clear_suspended_flag(void *context)\n{\n\tstruct rbtn_data *rbtn_data = context;\n\n\trbtn_data->suspended = false;\n}\n\nstatic int rbtn_suspend(struct device *dev)\n{\n\tstruct acpi_device *device = to_acpi_device(dev);\n\tstruct rbtn_data *rbtn_data = acpi_driver_data(device);\n\n\trbtn_data->suspended = true;\n\n\treturn 0;\n}\n\nstatic int rbtn_resume(struct device *dev)\n{\n\tstruct acpi_device *device = to_acpi_device(dev);\n\tstruct rbtn_data *rbtn_data = acpi_driver_data(device);\n\tacpi_status status;\n\n\t \n\tstatus = acpi_os_execute(OSL_NOTIFY_HANDLER,\n\t\t\t rbtn_clear_suspended_flag, rbtn_data);\n\tif (ACPI_FAILURE(status))\n\t\trbtn_clear_suspended_flag(rbtn_data);\n\n\treturn 0;\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(rbtn_pm_ops, rbtn_suspend, rbtn_resume);\n\nstatic struct acpi_driver rbtn_driver = {\n\t.name = \"dell-rbtn\",\n\t.ids = rbtn_ids,\n\t.drv.pm = &rbtn_pm_ops,\n\t.ops = {\n\t\t.add = rbtn_add,\n\t\t.remove = rbtn_remove,\n\t\t.notify = rbtn_notify,\n\t},\n\t.owner = THIS_MODULE,\n};\n\n\n \n\nstatic bool auto_remove_rfkill = true;\n\nstatic ATOMIC_NOTIFIER_HEAD(rbtn_chain_head);\n\nstatic int rbtn_inc_count(struct device *dev, void *data)\n{\n\tstruct acpi_device *device = to_acpi_device(dev);\n\tstruct rbtn_data *rbtn_data = device->driver_data;\n\tint *count = data;\n\n\tif (rbtn_data->type == RBTN_SLIDER)\n\t\t(*count)++;\n\n\treturn 0;\n}\n\nstatic int rbtn_switch_dev(struct device *dev, void *data)\n{\n\tstruct acpi_device *device = to_acpi_device(dev);\n\tstruct rbtn_data *rbtn_data = device->driver_data;\n\tbool enable = data;\n\n\tif (rbtn_data->type != RBTN_SLIDER)\n\t\treturn 0;\n\n\tif (enable)\n\t\trbtn_rfkill_init(device);\n\telse\n\t\trbtn_rfkill_exit(device);\n\n\treturn 0;\n}\n\nint dell_rbtn_notifier_register(struct notifier_block *nb)\n{\n\tbool first;\n\tint count;\n\tint ret;\n\n\tcount = 0;\n\tret = driver_for_each_device(&rbtn_driver.drv, NULL, &count,\n\t\t\t\t     rbtn_inc_count);\n\tif (ret || count == 0)\n\t\treturn -ENODEV;\n\n\tfirst = !rbtn_chain_head.head;\n\n\tret = atomic_notifier_chain_register(&rbtn_chain_head, nb);\n\tif (ret != 0)\n\t\treturn ret;\n\n\tif (auto_remove_rfkill && first)\n\t\tret = driver_for_each_device(&rbtn_driver.drv, NULL,\n\t\t\t\t\t     (void *)false, rbtn_switch_dev);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(dell_rbtn_notifier_register);\n\nint dell_rbtn_notifier_unregister(struct notifier_block *nb)\n{\n\tint ret;\n\n\tret = atomic_notifier_chain_unregister(&rbtn_chain_head, nb);\n\tif (ret != 0)\n\t\treturn ret;\n\n\tif (auto_remove_rfkill && !rbtn_chain_head.head)\n\t\tret = driver_for_each_device(&rbtn_driver.drv, NULL,\n\t\t\t\t\t     (void *)true, rbtn_switch_dev);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(dell_rbtn_notifier_unregister);\n\n\n \n\nstatic int rbtn_add(struct acpi_device *device)\n{\n\tstruct rbtn_data *rbtn_data;\n\tenum rbtn_type type;\n\tint ret = 0;\n\n\ttype = rbtn_check(device);\n\tif (type == RBTN_UNKNOWN) {\n\t\tdev_info(&device->dev, \"Unknown device type\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\trbtn_data = devm_kzalloc(&device->dev, sizeof(*rbtn_data), GFP_KERNEL);\n\tif (!rbtn_data)\n\t\treturn -ENOMEM;\n\n\tret = rbtn_acquire(device, true);\n\tif (ret < 0) {\n\t\tdev_err(&device->dev, \"Cannot enable device\\n\");\n\t\treturn ret;\n\t}\n\n\trbtn_data->type = type;\n\tdevice->driver_data = rbtn_data;\n\n\tswitch (rbtn_data->type) {\n\tcase RBTN_TOGGLE:\n\t\tret = rbtn_input_init(rbtn_data);\n\t\tbreak;\n\tcase RBTN_SLIDER:\n\t\tif (auto_remove_rfkill && rbtn_chain_head.head)\n\t\t\tret = 0;\n\t\telse\n\t\t\tret = rbtn_rfkill_init(device);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\tif (ret)\n\t\trbtn_acquire(device, false);\n\n\treturn ret;\n}\n\nstatic void rbtn_remove(struct acpi_device *device)\n{\n\tstruct rbtn_data *rbtn_data = device->driver_data;\n\n\tswitch (rbtn_data->type) {\n\tcase RBTN_TOGGLE:\n\t\trbtn_input_exit(rbtn_data);\n\t\tbreak;\n\tcase RBTN_SLIDER:\n\t\trbtn_rfkill_exit(device);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\trbtn_acquire(device, false);\n}\n\nstatic void rbtn_notify(struct acpi_device *device, u32 event)\n{\n\tstruct rbtn_data *rbtn_data = device->driver_data;\n\n\t \n\tif (rbtn_data->suspended) {\n\t\tdev_dbg(&device->dev, \"ACPI notification ignored\\n\");\n\t\treturn;\n\t}\n\n\tif (event != 0x80) {\n\t\tdev_info(&device->dev, \"Received unknown event (0x%x)\\n\",\n\t\t\t event);\n\t\treturn;\n\t}\n\n\tswitch (rbtn_data->type) {\n\tcase RBTN_TOGGLE:\n\t\trbtn_input_event(rbtn_data);\n\t\tbreak;\n\tcase RBTN_SLIDER:\n\t\trbtn_rfkill_event(device);\n\t\tatomic_notifier_call_chain(&rbtn_chain_head, event, device);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n\n \n\nmodule_acpi_driver(rbtn_driver);\n\nmodule_param(auto_remove_rfkill, bool, 0444);\n\nMODULE_PARM_DESC(auto_remove_rfkill, \"Automatically remove rfkill devices when \"\n\t\t\t\t     \"other modules start receiving events \"\n\t\t\t\t     \"from this module and re-add them when \"\n\t\t\t\t     \"the last module stops receiving events \"\n\t\t\t\t     \"(default true)\");\nMODULE_DEVICE_TABLE(acpi, rbtn_ids);\nMODULE_DESCRIPTION(\"Dell Airplane Mode Switch driver\");\nMODULE_AUTHOR(\"Pali Roh\u00e1r <pali@kernel.org>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}