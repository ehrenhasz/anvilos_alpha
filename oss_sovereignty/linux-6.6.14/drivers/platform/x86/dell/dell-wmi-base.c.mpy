{
  "module_name": "dell-wmi-base.c",
  "hash_id": "7440210c0bde29fce837279f2dac915a9ee6488deb4e3a5c89c3a1f5d4f00175",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/x86/dell/dell-wmi-base.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/input.h>\n#include <linux/input/sparse-keymap.h>\n#include <linux/acpi.h>\n#include <linux/string.h>\n#include <linux/dmi.h>\n#include <linux/wmi.h>\n#include <acpi/video.h>\n#include \"dell-smbios.h\"\n#include \"dell-wmi-descriptor.h\"\n#include \"dell-wmi-privacy.h\"\n\nMODULE_AUTHOR(\"Matthew Garrett <mjg@redhat.com>\");\nMODULE_AUTHOR(\"Pali Roh\u00e1r <pali@kernel.org>\");\nMODULE_DESCRIPTION(\"Dell laptop WMI hotkeys driver\");\nMODULE_LICENSE(\"GPL\");\n\n#define DELL_EVENT_GUID \"9DBB5994-A997-11DA-B012-B622A1EF5492\"\n\nstatic bool wmi_requires_smbios_request;\n\nstruct dell_wmi_priv {\n\tstruct input_dev *input_dev;\n\tstruct input_dev *tabletswitch_dev;\n\tu32 interface_version;\n};\n\nstatic int __init dmi_matched(const struct dmi_system_id *dmi)\n{\n\twmi_requires_smbios_request = 1;\n\treturn 1;\n}\n\nstatic const struct dmi_system_id dell_wmi_smbios_list[] __initconst = {\n\t{\n\t\t.callback = dmi_matched,\n\t\t.ident = \"Dell Inspiron M5110\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Inc.\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Inspiron M5110\"),\n\t\t},\n\t},\n\t{\n\t\t.callback = dmi_matched,\n\t\t.ident = \"Dell Vostro V131\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Inc.\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Vostro V131\"),\n\t\t},\n\t},\n\t{ }\n};\n\n \nstatic const struct key_entry dell_wmi_keymap_type_0000[] = {\n\t{ KE_IGNORE, 0x003a, { KEY_CAPSLOCK } },\n\n\t \n\t{ KE_KEY,    0xe005, { KEY_BRIGHTNESSDOWN } },\n\t{ KE_KEY,    0xe006, { KEY_BRIGHTNESSUP } },\n\n\t \n\t{ KE_KEY,    0xe007, { KEY_BATTERY } },\n\n\t \n\t{ KE_IGNORE, 0xe008, { KEY_RFKILL } },\n\n\t{ KE_KEY,    0xe009, { KEY_EJECTCD } },\n\n\t \n\t{ KE_KEY,    0xe00b, { KEY_SWITCHVIDEOMODE } },\n\n\t \n\t{ KE_IGNORE, 0xe00c, { KEY_KBDILLUMTOGGLE } },\n\n\t \n\t{ KE_IGNORE, 0xe00d, { KEY_RESERVED } },\n\n\t \n\t{ KE_IGNORE, 0xe00e, { KEY_RESERVED } },\n\n\t \n\t{ KE_KEY,    0xe011, { KEY_WLAN } },\n\n\t \n\t{ KE_IGNORE, 0xe013, { KEY_RESERVED } },\n\n\t{ KE_IGNORE, 0xe020, { KEY_MUTE } },\n\n\t \n\t \n\n\t \n\t \n\n\t \n\t{ KE_KEY,    0xe025, { KEY_PROG4 } },\n\n\t \n\t{ KE_IGNORE, 0xe026, { KEY_RESERVED } },\n\n\t \n\t{ KE_KEY,    0xe027, { KEY_DISPLAYTOGGLE } },\n\n\t \n\t \n\n\t \n\t{ KE_KEY,    0xe029, { KEY_PROG4 } },\n\n\t \n\t \n\n\t \n\t \n\n\t \n\t \n\n\t{ KE_IGNORE, 0xe02e, { KEY_VOLUMEDOWN } },\n\t{ KE_IGNORE, 0xe030, { KEY_VOLUMEUP } },\n\t{ KE_IGNORE, 0xe033, { KEY_KBDILLUMUP } },\n\t{ KE_IGNORE, 0xe034, { KEY_KBDILLUMDOWN } },\n\t{ KE_IGNORE, 0xe03a, { KEY_CAPSLOCK } },\n\n\t \n\t{ KE_IGNORE, 0xe043, { KEY_RESERVED } },\n\n\t \n\t{ KE_IGNORE, 0xe044, { KEY_RESERVED } },\n\n\t \n\t{ KE_IGNORE, 0xe045, { KEY_NUMLOCK } },\n\n\t \n\t{ KE_IGNORE, 0xe046, { KEY_SCROLLLOCK } },\n\n\t \n\t \n\n\t \n\t{ KE_IGNORE, 0xe06e, { KEY_RESERVED } },\n\n\t{ KE_IGNORE, 0xe0f7, { KEY_MUTE } },\n\t{ KE_IGNORE, 0xe0f8, { KEY_VOLUMEDOWN } },\n\t{ KE_IGNORE, 0xe0f9, { KEY_VOLUMEUP } },\n};\n\nstruct dell_bios_keymap_entry {\n\tu16 scancode;\n\tu16 keycode;\n};\n\nstruct dell_bios_hotkey_table {\n\tstruct dmi_header header;\n\tstruct dell_bios_keymap_entry keymap[];\n\n};\n\nstruct dell_dmi_results {\n\tint err;\n\tint keymap_size;\n\tstruct key_entry *keymap;\n};\n\n \nstatic const u16 bios_to_linux_keycode[256] = {\n\t[0]\t= KEY_MEDIA,\n\t[1]\t= KEY_NEXTSONG,\n\t[2]\t= KEY_PLAYPAUSE,\n\t[3]\t= KEY_PREVIOUSSONG,\n\t[4]\t= KEY_STOPCD,\n\t[5]\t= KEY_UNKNOWN,\n\t[6]\t= KEY_UNKNOWN,\n\t[7]\t= KEY_UNKNOWN,\n\t[8]\t= KEY_WWW,\n\t[9]\t= KEY_UNKNOWN,\n\t[10]\t= KEY_VOLUMEDOWN,\n\t[11]\t= KEY_MUTE,\n\t[12]\t= KEY_VOLUMEUP,\n\t[13]\t= KEY_UNKNOWN,\n\t[14]\t= KEY_BATTERY,\n\t[15]\t= KEY_EJECTCD,\n\t[16]\t= KEY_UNKNOWN,\n\t[17]\t= KEY_SLEEP,\n\t[18]\t= KEY_PROG1,\n\t[19]\t= KEY_BRIGHTNESSDOWN,\n\t[20]\t= KEY_BRIGHTNESSUP,\n\t[21]\t= KEY_BRIGHTNESS_AUTO,\n\t[22]\t= KEY_KBDILLUMTOGGLE,\n\t[23]\t= KEY_UNKNOWN,\n\t[24]\t= KEY_SWITCHVIDEOMODE,\n\t[25]\t= KEY_UNKNOWN,\n\t[26]\t= KEY_UNKNOWN,\n\t[27]\t= KEY_SWITCHVIDEOMODE,\n\t[28]\t= KEY_UNKNOWN,\n\t[29]\t= KEY_UNKNOWN,\n\t[30]\t= KEY_PROG2,\n\t[31]\t= KEY_UNKNOWN,\n\t[32]\t= KEY_UNKNOWN,\n\t[33]\t= KEY_UNKNOWN,\n\t[34]\t= KEY_UNKNOWN,\n\t[35]\t= KEY_UNKNOWN,\n\t[36]\t= KEY_UNKNOWN,\n\t[37]\t= KEY_UNKNOWN,\n\t[38]\t= KEY_MICMUTE,\n\t[255]\t= KEY_PROG3,\n};\n\n \nstatic const struct key_entry dell_wmi_keymap_type_0010[] = {\n\t \n\t{ KE_IGNORE, 0x0, { KEY_RESERVED } },\n\n\t \n\t{ KE_IGNORE, 0x1, { KEY_RESERVED } },\n\n\t \n\t{ KE_IGNORE, 0x3f, { KEY_RESERVED } },\n\n\t \n\t{ KE_KEY,    0x57, { KEY_BRIGHTNESSDOWN } },\n\t{ KE_KEY,    0x58, { KEY_BRIGHTNESSUP } },\n\n\t \n\t{ KE_KEY, 0x109, { KEY_MUTE} },\n\n\t \n\t{ KE_KEY, 0x150, { KEY_MICMUTE } },\n\n\t \n\t{ KE_IGNORE, 0x151, { KEY_RESERVED } },\n\n\t \n\t{ KE_IGNORE, 0x152, { KEY_KBDILLUMTOGGLE } },\n\n\t \n\t{ KE_IGNORE, 0x153, { KEY_RFKILL } },\n\n\t \n\t{ KE_IGNORE, 0x154, { KEY_RESERVED } },\n\n\t \n\t{ KE_IGNORE, 0x155, { KEY_RESERVED } },\n\n\t \n\t{ KE_IGNORE, 0x156, { KEY_RESERVED } },\n\t{ KE_IGNORE, 0x157, { KEY_RESERVED } },\n\n\t \n\t{ KE_KEY,    0x850, { KEY_PROG1 } },\n\t{ KE_KEY,    0x851, { KEY_PROG2 } },\n\t{ KE_KEY,    0x852, { KEY_PROG3 } },\n\n\t \n\t{ KE_IGNORE, 0xe008, { KEY_RFKILL } },\n\n\t \n\t{ KE_IGNORE, 0xe035, { KEY_RESERVED } },\n};\n\n \nstatic const struct key_entry dell_wmi_keymap_type_0011[] = {\n\t \n\t{ KE_IGNORE, 0xe070, { KEY_RESERVED } },\n\n\t \n\t{ KE_IGNORE, 0xfff0, { KEY_RESERVED } },\n\n\t \n\t{ KE_IGNORE, 0xfff1, { KEY_RESERVED } },\n\n\t \n\t{ KE_IGNORE, 0xfff2, { KEY_RESERVED } },\n\n\t \n\t{ KE_IGNORE, 0xfff3, { KEY_RESERVED } },\n\n\t \n\t{ KE_IGNORE, KBD_LED_OFF_TOKEN,      { KEY_RESERVED } },\n\t{ KE_IGNORE, KBD_LED_ON_TOKEN,       { KEY_RESERVED } },\n\t{ KE_IGNORE, KBD_LED_AUTO_TOKEN,     { KEY_RESERVED } },\n\t{ KE_IGNORE, KBD_LED_AUTO_25_TOKEN,  { KEY_RESERVED } },\n\t{ KE_IGNORE, KBD_LED_AUTO_50_TOKEN,  { KEY_RESERVED } },\n\t{ KE_IGNORE, KBD_LED_AUTO_75_TOKEN,  { KEY_RESERVED } },\n\t{ KE_IGNORE, KBD_LED_AUTO_100_TOKEN, { KEY_RESERVED } },\n};\n\n \nstatic const struct key_entry dell_wmi_keymap_type_0012[] = {\n\t \n\t{ KE_IGNORE, 0x0003, { KEY_RESERVED } },\n\n\t \n\t{ KE_IGNORE, 0x000d, { KEY_RESERVED } },\n\n\t \n\t{ KE_IGNORE, 0xe035, { KEY_RESERVED } },\n};\n\nstatic void dell_wmi_switch_event(struct input_dev **subdev,\n\t\t\t\t  const char *devname,\n\t\t\t\t  int switchid,\n\t\t\t\t  int value)\n{\n\tif (!*subdev) {\n\t\tstruct input_dev *dev = input_allocate_device();\n\n\t\tif (!dev) {\n\t\t\tpr_warn(\"could not allocate device for %s\\n\", devname);\n\t\t\treturn;\n\t\t}\n\t\t__set_bit(EV_SW, (dev)->evbit);\n\t\t__set_bit(switchid, (dev)->swbit);\n\n\t\t(dev)->name = devname;\n\t\t(dev)->id.bustype = BUS_HOST;\n\t\tif (input_register_device(dev)) {\n\t\t\tinput_free_device(dev);\n\t\t\tpr_warn(\"could not register device for %s\\n\", devname);\n\t\t\treturn;\n\t\t}\n\t\t*subdev = dev;\n\t}\n\n\tinput_report_switch(*subdev, switchid, value);\n\tinput_sync(*subdev);\n}\n\nstatic int dell_wmi_process_key(struct wmi_device *wdev, int type, int code, u16 *buffer, int remaining)\n{\n\tstruct dell_wmi_priv *priv = dev_get_drvdata(&wdev->dev);\n\tconst struct key_entry *key;\n\tint used = 0;\n\tint value = 1;\n\n\tkey = sparse_keymap_entry_from_scancode(priv->input_dev,\n\t\t\t\t\t\t(type << 16) | code);\n\tif (!key) {\n\t\tpr_info(\"Unknown key with type 0x%04x and code 0x%04x pressed\\n\",\n\t\t\ttype, code);\n\t\treturn 0;\n\t}\n\n\tpr_debug(\"Key with type 0x%04x and code 0x%04x pressed\\n\", type, code);\n\n\t \n\tif ((key->keycode == KEY_BRIGHTNESSUP ||\n\t     key->keycode == KEY_BRIGHTNESSDOWN) &&\n\t    acpi_video_handles_brightness_key_presses())\n\t\treturn 0;\n\n\tif (type == 0x0000 && code == 0xe025 && !wmi_requires_smbios_request)\n\t\treturn 0;\n\n\tif (key->keycode == KEY_KBDILLUMTOGGLE) {\n\t\tdell_laptop_call_notifier(\n\t\t\tDELL_LAPTOP_KBD_BACKLIGHT_BRIGHTNESS_CHANGED, NULL);\n\t} else if (type == 0x0011 && code == 0xe070 && remaining > 0) {\n\t\tdell_wmi_switch_event(&priv->tabletswitch_dev,\n\t\t\t\t      \"Dell tablet mode switch\",\n\t\t\t\t      SW_TABLET_MODE, !buffer[0]);\n\t\treturn 1;\n\t} else if (type == 0x0012 && code == 0x000d && remaining > 0) {\n\t\tvalue = (buffer[2] == 2);\n\t\tused = 1;\n\t}\n\n\tsparse_keymap_report_entry(priv->input_dev, key, value, true);\n\n\treturn used;\n}\n\nstatic void dell_wmi_notify(struct wmi_device *wdev,\n\t\t\t    union acpi_object *obj)\n{\n\tstruct dell_wmi_priv *priv = dev_get_drvdata(&wdev->dev);\n\tu16 *buffer_entry, *buffer_end;\n\tacpi_size buffer_size;\n\tint len, i;\n\n\tif (obj->type != ACPI_TYPE_BUFFER) {\n\t\tpr_warn(\"bad response type %x\\n\", obj->type);\n\t\treturn;\n\t}\n\n\tpr_debug(\"Received WMI event (%*ph)\\n\",\n\t\tobj->buffer.length, obj->buffer.pointer);\n\n\tbuffer_entry = (u16 *)obj->buffer.pointer;\n\tbuffer_size = obj->buffer.length/2;\n\tbuffer_end = buffer_entry + buffer_size;\n\n\t \n\tif (priv->interface_version == 0 && buffer_entry < buffer_end)\n\t\tif (buffer_end > buffer_entry + buffer_entry[0] + 1)\n\t\t\tbuffer_end = buffer_entry + buffer_entry[0] + 1;\n\n\twhile (buffer_entry < buffer_end) {\n\n\t\tlen = buffer_entry[0];\n\t\tif (len == 0)\n\t\t\tbreak;\n\n\t\tlen++;\n\n\t\tif (buffer_entry + len > buffer_end) {\n\t\t\tpr_warn(\"Invalid length of WMI event\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tpr_debug(\"Process buffer (%*ph)\\n\", len*2, buffer_entry);\n\n\t\tswitch (buffer_entry[1]) {\n\t\tcase 0x0000:  \n\t\t\tif (len > 2)\n\t\t\t\tdell_wmi_process_key(wdev, buffer_entry[1],\n\t\t\t\t\t\t     buffer_entry[2],\n\t\t\t\t\t\t     buffer_entry + 3,\n\t\t\t\t\t\t     len - 3);\n\t\t\t \n\t\t\tbreak;\n\t\tcase 0x0010:  \n\t\tcase 0x0011:  \n\t\t\tfor (i = 2; i < len; ++i)\n\t\t\t\ti += dell_wmi_process_key(wdev, buffer_entry[1],\n\t\t\t\t\t\t\t  buffer_entry[i],\n\t\t\t\t\t\t\t  buffer_entry + i,\n\t\t\t\t\t\t\t  len - i - 1);\n\t\t\tbreak;\n\t\tcase 0x0012:\n\t\t\tif ((len > 4) && dell_privacy_process_event(buffer_entry[1], buffer_entry[3],\n\t\t\t\t\t\t\t\t    buffer_entry[4]))\n\t\t\t\t ;\n\t\t\telse if (len > 2)\n\t\t\t\tdell_wmi_process_key(wdev, buffer_entry[1], buffer_entry[2],\n\t\t\t\t\t\t     buffer_entry + 3, len - 3);\n\t\t\tbreak;\n\t\tdefault:  \n\t\t\tpr_info(\"Unknown WMI event type 0x%x\\n\",\n\t\t\t\t(int)buffer_entry[1]);\n\t\t\tbreak;\n\t\t}\n\n\t\tbuffer_entry += len;\n\n\t}\n\n}\n\nstatic bool have_scancode(u32 scancode, const struct key_entry *keymap, int len)\n{\n\tint i;\n\n\tfor (i = 0; i < len; i++)\n\t\tif (keymap[i].code == scancode)\n\t\t\treturn true;\n\n\treturn false;\n}\n\nstatic void handle_dmi_entry(const struct dmi_header *dm, void *opaque)\n{\n\tstruct dell_dmi_results *results = opaque;\n\tstruct dell_bios_hotkey_table *table;\n\tint hotkey_num, i, pos = 0;\n\tstruct key_entry *keymap;\n\n\tif (results->err || results->keymap)\n\t\treturn;\t\t \n\n\t \n\tif (dm->type != 0xb2)\n\t\treturn;\n\n\ttable = container_of(dm, struct dell_bios_hotkey_table, header);\n\n\thotkey_num = (table->header.length -\n\t\t      sizeof(struct dell_bios_hotkey_table)) /\n\t\t\t\tsizeof(struct dell_bios_keymap_entry);\n\tif (hotkey_num < 1) {\n\t\t \n\t\treturn;\n\t}\n\n\tkeymap = kcalloc(hotkey_num, sizeof(struct key_entry), GFP_KERNEL);\n\tif (!keymap) {\n\t\tresults->err = -ENOMEM;\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < hotkey_num; i++) {\n\t\tconst struct dell_bios_keymap_entry *bios_entry =\n\t\t\t\t\t&table->keymap[i];\n\n\t\t \n\t\tu16 keycode = (bios_entry->keycode <\n\t\t\t       ARRAY_SIZE(bios_to_linux_keycode)) ?\n\t\t\tbios_to_linux_keycode[bios_entry->keycode] :\n\t\t\t(bios_entry->keycode == 0xffff ? KEY_UNKNOWN : KEY_RESERVED);\n\n\t\t \n\t\tif (keycode == KEY_RESERVED) {\n\t\t\tpr_info(\"firmware scancode 0x%x maps to unrecognized keycode 0x%x\\n\",\n\t\t\t\tbios_entry->scancode, bios_entry->keycode);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (keycode == KEY_KBDILLUMTOGGLE)\n\t\t\tkeymap[pos].type = KE_IGNORE;\n\t\telse\n\t\t\tkeymap[pos].type = KE_KEY;\n\t\tkeymap[pos].code = bios_entry->scancode;\n\t\tkeymap[pos].keycode = keycode;\n\n\t\tpos++;\n\t}\n\n\tresults->keymap = keymap;\n\tresults->keymap_size = pos;\n}\n\nstatic int dell_wmi_input_setup(struct wmi_device *wdev)\n{\n\tstruct dell_wmi_priv *priv = dev_get_drvdata(&wdev->dev);\n\tstruct dell_dmi_results dmi_results = {};\n\tstruct key_entry *keymap;\n\tint err, i, pos = 0;\n\n\tpriv->input_dev = input_allocate_device();\n\tif (!priv->input_dev)\n\t\treturn -ENOMEM;\n\n\tpriv->input_dev->name = \"Dell WMI hotkeys\";\n\tpriv->input_dev->id.bustype = BUS_HOST;\n\tpriv->input_dev->dev.parent = &wdev->dev;\n\n\tif (dmi_walk(handle_dmi_entry, &dmi_results)) {\n\t\t \n\t\tpr_warn(\"no DMI; using the old-style hotkey interface\\n\");\n\t}\n\n\tif (dmi_results.err) {\n\t\terr = dmi_results.err;\n\t\tgoto err_free_dev;\n\t}\n\n\tkeymap = kcalloc(dmi_results.keymap_size +\n\t\t\t ARRAY_SIZE(dell_wmi_keymap_type_0000) +\n\t\t\t ARRAY_SIZE(dell_wmi_keymap_type_0010) +\n\t\t\t ARRAY_SIZE(dell_wmi_keymap_type_0011) +\n\t\t\t ARRAY_SIZE(dell_wmi_keymap_type_0012) +\n\t\t\t 1,\n\t\t\t sizeof(struct key_entry), GFP_KERNEL);\n\tif (!keymap) {\n\t\tkfree(dmi_results.keymap);\n\t\terr = -ENOMEM;\n\t\tgoto err_free_dev;\n\t}\n\n\t \n\tfor (i = 0; i < dmi_results.keymap_size; i++) {\n\t\tkeymap[pos] = dmi_results.keymap[i];\n\t\tkeymap[pos].code |= (0x0010 << 16);\n\t\tpos++;\n\t}\n\n\tkfree(dmi_results.keymap);\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(dell_wmi_keymap_type_0010); i++) {\n\t\tconst struct key_entry *entry = &dell_wmi_keymap_type_0010[i];\n\n\t\t \n\t\tif (dmi_results.keymap_size &&\n\t\t    have_scancode(entry->code | (0x0010 << 16),\n\t\t\t\t  keymap, dmi_results.keymap_size)\n\t\t   )\n\t\t\tcontinue;\n\n\t\tkeymap[pos] = *entry;\n\t\tkeymap[pos].code |= (0x0010 << 16);\n\t\tpos++;\n\t}\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(dell_wmi_keymap_type_0011); i++) {\n\t\tkeymap[pos] = dell_wmi_keymap_type_0011[i];\n\t\tkeymap[pos].code |= (0x0011 << 16);\n\t\tpos++;\n\t}\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(dell_wmi_keymap_type_0012); i++) {\n\t\tkeymap[pos] = dell_wmi_keymap_type_0012[i];\n\t\tkeymap[pos].code |= (0x0012 << 16);\n\t\tpos++;\n\t}\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(dell_wmi_keymap_type_0000); i++) {\n\t\tkeymap[pos] = dell_wmi_keymap_type_0000[i];\n\t\tpos++;\n\t}\n\n\tkeymap[pos].type = KE_END;\n\n\terr = sparse_keymap_setup(priv->input_dev, keymap, NULL);\n\t \n\tkfree(keymap);\n\tif (err)\n\t\tgoto err_free_dev;\n\n\terr = input_register_device(priv->input_dev);\n\tif (err)\n\t\tgoto err_free_dev;\n\n\treturn 0;\n\n err_free_dev:\n\tinput_free_device(priv->input_dev);\n\treturn err;\n}\n\nstatic void dell_wmi_input_destroy(struct wmi_device *wdev)\n{\n\tstruct dell_wmi_priv *priv = dev_get_drvdata(&wdev->dev);\n\n\tinput_unregister_device(priv->input_dev);\n\tif (priv->tabletswitch_dev)\n\t\tinput_unregister_device(priv->tabletswitch_dev);\n}\n\n \n\nstatic int dell_wmi_events_set_enabled(bool enable)\n{\n\tstruct calling_interface_buffer *buffer;\n\tint ret;\n\n\tbuffer = kzalloc(sizeof(struct calling_interface_buffer), GFP_KERNEL);\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\tbuffer->cmd_class = CLASS_INFO;\n\tbuffer->cmd_select = SELECT_APP_REGISTRATION;\n\tbuffer->input[0] = 0x10000;\n\tbuffer->input[1] = 0x51534554;\n\tbuffer->input[3] = enable;\n\tret = dell_smbios_call(buffer);\n\tif (ret == 0)\n\t\tret = buffer->output[0];\n\tkfree(buffer);\n\n\treturn dell_smbios_error(ret);\n}\n\nstatic int dell_wmi_probe(struct wmi_device *wdev, const void *context)\n{\n\tstruct dell_wmi_priv *priv;\n\tint ret;\n\n\tret = dell_wmi_get_descriptor_valid();\n\tif (ret)\n\t\treturn ret;\n\n\tpriv = devm_kzalloc(\n\t\t&wdev->dev, sizeof(struct dell_wmi_priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\tdev_set_drvdata(&wdev->dev, priv);\n\n\tif (!dell_wmi_get_interface_version(&priv->interface_version))\n\t\treturn -EPROBE_DEFER;\n\n\treturn dell_wmi_input_setup(wdev);\n}\n\nstatic void dell_wmi_remove(struct wmi_device *wdev)\n{\n\tdell_wmi_input_destroy(wdev);\n}\nstatic const struct wmi_device_id dell_wmi_id_table[] = {\n\t{ .guid_string = DELL_EVENT_GUID },\n\t{ },\n};\n\nstatic struct wmi_driver dell_wmi_driver = {\n\t.driver = {\n\t\t.name = \"dell-wmi\",\n\t},\n\t.id_table = dell_wmi_id_table,\n\t.probe = dell_wmi_probe,\n\t.remove = dell_wmi_remove,\n\t.notify = dell_wmi_notify,\n};\n\nstatic int __init dell_wmi_init(void)\n{\n\tint err;\n\n\tdmi_check_system(dell_wmi_smbios_list);\n\n\tif (wmi_requires_smbios_request) {\n\t\terr = dell_wmi_events_set_enabled(true);\n\t\tif (err) {\n\t\t\tpr_err(\"Failed to enable WMI events\\n\");\n\t\t\treturn err;\n\t\t}\n\t}\n\n\terr = dell_privacy_register_driver();\n\tif (err)\n\t\treturn err;\n\n\treturn wmi_driver_register(&dell_wmi_driver);\n}\nlate_initcall(dell_wmi_init);\n\nstatic void __exit dell_wmi_exit(void)\n{\n\tif (wmi_requires_smbios_request)\n\t\tdell_wmi_events_set_enabled(false);\n\n\twmi_driver_unregister(&dell_wmi_driver);\n\tdell_privacy_unregister_driver();\n}\nmodule_exit(dell_wmi_exit);\n\nMODULE_DEVICE_TABLE(wmi, dell_wmi_id_table);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}