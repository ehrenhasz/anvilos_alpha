{
  "module_name": "dell-smbios-smm.c",
  "hash_id": "1c9731aa864072452eeaee520f4b0581b42b3198cd968decc31ecb946a1527b6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/x86/dell/dell-smbios-smm.c",
  "human_readable_source": "\n \n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/dmi.h>\n#include <linux/gfp.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/platform_device.h>\n#include \"dcdbas.h\"\n#include \"dell-smbios.h\"\n\nstatic int da_command_address;\nstatic int da_command_code;\nstatic struct smi_buffer smi_buf;\nstatic struct calling_interface_buffer *buffer;\nstatic struct platform_device *platform_device;\nstatic DEFINE_MUTEX(smm_mutex);\n\nstatic void parse_da_table(const struct dmi_header *dm)\n{\n\tstruct calling_interface_structure *table =\n\t\tcontainer_of(dm, struct calling_interface_structure, header);\n\n\t \n\tif (dm->length < 17)\n\t\treturn;\n\n\tda_command_address = table->cmdIOAddress;\n\tda_command_code = table->cmdIOCode;\n}\n\nstatic void find_cmd_address(const struct dmi_header *dm, void *dummy)\n{\n\tswitch (dm->type) {\n\tcase 0xda:  \n\t\tparse_da_table(dm);\n\t\tbreak;\n\t}\n}\n\nstatic int dell_smbios_smm_call(struct calling_interface_buffer *input)\n{\n\tstruct smi_cmd command;\n\tsize_t size;\n\n\tsize = sizeof(struct calling_interface_buffer);\n\tcommand.magic = SMI_CMD_MAGIC;\n\tcommand.command_address = da_command_address;\n\tcommand.command_code = da_command_code;\n\tcommand.ebx = smi_buf.dma;\n\tcommand.ecx = 0x42534931;\n\n\tmutex_lock(&smm_mutex);\n\tmemcpy(buffer, input, size);\n\tdcdbas_smi_request(&command);\n\tmemcpy(input, buffer, size);\n\tmutex_unlock(&smm_mutex);\n\treturn 0;\n}\n\n \nstatic bool test_wsmt_enabled(void)\n{\n\tstruct calling_interface_token *wsmt;\n\n\t \n\twsmt = dell_smbios_find_token(WSMT_EN_TOKEN);\n\tif (!wsmt)\n\t\treturn false;\n\n\t \n\tbuffer->cmd_class = CLASS_TOKEN_READ;\n\tbuffer->cmd_select = SELECT_TOKEN_STD;\n\tmemset(buffer, 0, sizeof(struct calling_interface_buffer));\n\tbuffer->input[0] = wsmt->location;\n\tbuffer->output[0] = 99;\n\tdell_smbios_smm_call(buffer);\n\tif (buffer->output[0] == 99)\n\t\treturn true;\n\n\treturn false;\n}\n\nint init_dell_smbios_smm(void)\n{\n\tint ret;\n\t \n\tret = dcdbas_smi_alloc(&smi_buf, PAGE_SIZE);\n\tif (ret)\n\t\treturn ret;\n\tbuffer = (void *)smi_buf.virt;\n\n\tdmi_walk(find_cmd_address, NULL);\n\n\tif (test_wsmt_enabled()) {\n\t\tpr_debug(\"Disabling due to WSMT enabled\\n\");\n\t\tret = -ENODEV;\n\t\tgoto fail_wsmt;\n\t}\n\n\tplatform_device = platform_device_alloc(\"dell-smbios\", 1);\n\tif (!platform_device) {\n\t\tret = -ENOMEM;\n\t\tgoto fail_platform_device_alloc;\n\t}\n\n\tret = platform_device_add(platform_device);\n\tif (ret)\n\t\tgoto fail_platform_device_add;\n\n\tret = dell_smbios_register_device(&platform_device->dev,\n\t\t\t\t\t  &dell_smbios_smm_call);\n\tif (ret)\n\t\tgoto fail_register;\n\n\treturn 0;\n\nfail_register:\n\tplatform_device_del(platform_device);\n\nfail_platform_device_add:\n\tplatform_device_put(platform_device);\n\nfail_wsmt:\nfail_platform_device_alloc:\n\tdcdbas_smi_free(&smi_buf);\n\treturn ret;\n}\n\nvoid exit_dell_smbios_smm(void)\n{\n\tif (platform_device) {\n\t\tdell_smbios_unregister_device(&platform_device->dev);\n\t\tplatform_device_unregister(platform_device);\n\t\tdcdbas_smi_free(&smi_buf);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}