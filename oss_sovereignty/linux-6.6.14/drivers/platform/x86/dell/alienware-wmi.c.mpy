{
  "module_name": "alienware-wmi.c",
  "hash_id": "9927399ecc44b7c9c192352f132ca0e23a8cdd3feba1344d336c8b1a2076e3bb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/x86/dell/alienware-wmi.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/acpi.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/dmi.h>\n#include <linux/leds.h>\n\n#define LEGACY_CONTROL_GUID\t\t\"A90597CE-A997-11DA-B012-B622A1EF5492\"\n#define LEGACY_POWER_CONTROL_GUID\t\"A80593CE-A997-11DA-B012-B622A1EF5492\"\n#define WMAX_CONTROL_GUID\t\t\"A70591CE-A997-11DA-B012-B622A1EF5492\"\n\n#define WMAX_METHOD_HDMI_SOURCE\t\t0x1\n#define WMAX_METHOD_HDMI_STATUS\t\t0x2\n#define WMAX_METHOD_BRIGHTNESS\t\t0x3\n#define WMAX_METHOD_ZONE_CONTROL\t0x4\n#define WMAX_METHOD_HDMI_CABLE\t\t0x5\n#define WMAX_METHOD_AMPLIFIER_CABLE\t0x6\n#define WMAX_METHOD_DEEP_SLEEP_CONTROL\t0x0B\n#define WMAX_METHOD_DEEP_SLEEP_STATUS\t0x0C\n\nMODULE_AUTHOR(\"Mario Limonciello <mario.limonciello@outlook.com>\");\nMODULE_DESCRIPTION(\"Alienware special feature control\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"wmi:\" LEGACY_CONTROL_GUID);\nMODULE_ALIAS(\"wmi:\" WMAX_CONTROL_GUID);\n\nenum INTERFACE_FLAGS {\n\tLEGACY,\n\tWMAX,\n};\n\nenum LEGACY_CONTROL_STATES {\n\tLEGACY_RUNNING = 1,\n\tLEGACY_BOOTING = 0,\n\tLEGACY_SUSPEND = 3,\n};\n\nenum WMAX_CONTROL_STATES {\n\tWMAX_RUNNING = 0xFF,\n\tWMAX_BOOTING = 0,\n\tWMAX_SUSPEND = 3,\n};\n\nstruct quirk_entry {\n\tu8 num_zones;\n\tu8 hdmi_mux;\n\tu8 amplifier;\n\tu8 deepslp;\n};\n\nstatic struct quirk_entry *quirks;\n\n\nstatic struct quirk_entry quirk_inspiron5675 = {\n\t.num_zones = 2,\n\t.hdmi_mux = 0,\n\t.amplifier = 0,\n\t.deepslp = 0,\n};\n\nstatic struct quirk_entry quirk_unknown = {\n\t.num_zones = 2,\n\t.hdmi_mux = 0,\n\t.amplifier = 0,\n\t.deepslp = 0,\n};\n\nstatic struct quirk_entry quirk_x51_r1_r2 = {\n\t.num_zones = 3,\n\t.hdmi_mux = 0,\n\t.amplifier = 0,\n\t.deepslp = 0,\n};\n\nstatic struct quirk_entry quirk_x51_r3 = {\n\t.num_zones = 4,\n\t.hdmi_mux = 0,\n\t.amplifier = 1,\n\t.deepslp = 0,\n};\n\nstatic struct quirk_entry quirk_asm100 = {\n\t.num_zones = 2,\n\t.hdmi_mux = 1,\n\t.amplifier = 0,\n\t.deepslp = 0,\n};\n\nstatic struct quirk_entry quirk_asm200 = {\n\t.num_zones = 2,\n\t.hdmi_mux = 1,\n\t.amplifier = 0,\n\t.deepslp = 1,\n};\n\nstatic struct quirk_entry quirk_asm201 = {\n\t.num_zones = 2,\n\t.hdmi_mux = 1,\n\t.amplifier = 1,\n\t.deepslp = 1,\n};\n\nstatic int __init dmi_matched(const struct dmi_system_id *dmi)\n{\n\tquirks = dmi->driver_data;\n\treturn 1;\n}\n\nstatic const struct dmi_system_id alienware_quirks[] __initconst = {\n\t{\n\t .callback = dmi_matched,\n\t .ident = \"Alienware X51 R3\",\n\t .matches = {\n\t\t     DMI_MATCH(DMI_SYS_VENDOR, \"Alienware\"),\n\t\t     DMI_MATCH(DMI_PRODUCT_NAME, \"Alienware X51 R3\"),\n\t\t     },\n\t .driver_data = &quirk_x51_r3,\n\t },\n\t{\n\t .callback = dmi_matched,\n\t .ident = \"Alienware X51 R2\",\n\t .matches = {\n\t\t     DMI_MATCH(DMI_SYS_VENDOR, \"Alienware\"),\n\t\t     DMI_MATCH(DMI_PRODUCT_NAME, \"Alienware X51 R2\"),\n\t\t     },\n\t .driver_data = &quirk_x51_r1_r2,\n\t },\n\t{\n\t .callback = dmi_matched,\n\t .ident = \"Alienware X51 R1\",\n\t .matches = {\n\t\t     DMI_MATCH(DMI_SYS_VENDOR, \"Alienware\"),\n\t\t     DMI_MATCH(DMI_PRODUCT_NAME, \"Alienware X51\"),\n\t\t     },\n\t .driver_data = &quirk_x51_r1_r2,\n\t },\n\t{\n\t .callback = dmi_matched,\n\t .ident = \"Alienware ASM100\",\n\t .matches = {\n\t\t     DMI_MATCH(DMI_SYS_VENDOR, \"Alienware\"),\n\t\t     DMI_MATCH(DMI_PRODUCT_NAME, \"ASM100\"),\n\t\t     },\n\t .driver_data = &quirk_asm100,\n\t },\n\t{\n\t .callback = dmi_matched,\n\t .ident = \"Alienware ASM200\",\n\t .matches = {\n\t\t     DMI_MATCH(DMI_SYS_VENDOR, \"Alienware\"),\n\t\t     DMI_MATCH(DMI_PRODUCT_NAME, \"ASM200\"),\n\t\t     },\n\t .driver_data = &quirk_asm200,\n\t },\n\t{\n\t .callback = dmi_matched,\n\t .ident = \"Alienware ASM201\",\n\t .matches = {\n\t\t     DMI_MATCH(DMI_SYS_VENDOR, \"Alienware\"),\n\t\t     DMI_MATCH(DMI_PRODUCT_NAME, \"ASM201\"),\n\t\t     },\n\t .driver_data = &quirk_asm201,\n\t },\n\t {\n\t .callback = dmi_matched,\n\t .ident = \"Dell Inc. Inspiron 5675\",\n\t .matches = {\n\t\t     DMI_MATCH(DMI_SYS_VENDOR, \"Dell Inc.\"),\n\t\t     DMI_MATCH(DMI_PRODUCT_NAME, \"Inspiron 5675\"),\n\t\t     },\n\t .driver_data = &quirk_inspiron5675,\n\t },\n\t{}\n};\n\nstruct color_platform {\n\tu8 blue;\n\tu8 green;\n\tu8 red;\n} __packed;\n\nstruct platform_zone {\n\tu8 location;\n\tstruct device_attribute *attr;\n\tstruct color_platform colors;\n};\n\nstruct wmax_brightness_args {\n\tu32 led_mask;\n\tu32 percentage;\n};\n\nstruct wmax_basic_args {\n\tu8 arg;\n};\n\nstruct legacy_led_args {\n\tstruct color_platform colors;\n\tu8 brightness;\n\tu8 state;\n} __packed;\n\nstruct wmax_led_args {\n\tu32 led_mask;\n\tstruct color_platform colors;\n\tu8 state;\n} __packed;\n\nstatic struct platform_device *platform_device;\nstatic struct device_attribute *zone_dev_attrs;\nstatic struct attribute **zone_attrs;\nstatic struct platform_zone *zone_data;\n\nstatic struct platform_driver platform_driver = {\n\t.driver = {\n\t\t   .name = \"alienware-wmi\",\n\t\t   }\n};\n\nstatic struct attribute_group zone_attribute_group = {\n\t.name = \"rgb_zones\",\n};\n\nstatic u8 interface;\nstatic u8 lighting_control_state;\nstatic u8 global_brightness;\n\n \nstatic int parse_rgb(const char *buf, struct platform_zone *zone)\n{\n\tlong unsigned int rgb;\n\tint ret;\n\tunion color_union {\n\t\tstruct color_platform cp;\n\t\tint package;\n\t} repackager;\n\n\tret = kstrtoul(buf, 16, &rgb);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (rgb > 0xFFFFFF)\n\t\treturn -EINVAL;\n\n\trepackager.package = rgb & 0x0f0f0f0f;\n\tpr_debug(\"alienware-wmi: r: %d g:%d b: %d\\n\",\n\t\t repackager.cp.red, repackager.cp.green, repackager.cp.blue);\n\tzone->colors = repackager.cp;\n\treturn 0;\n}\n\nstatic struct platform_zone *match_zone(struct device_attribute *attr)\n{\n\tu8 zone;\n\n\tfor (zone = 0; zone < quirks->num_zones; zone++) {\n\t\tif ((struct device_attribute *)zone_data[zone].attr == attr) {\n\t\t\tpr_debug(\"alienware-wmi: matched zone location: %d\\n\",\n\t\t\t\t zone_data[zone].location);\n\t\t\treturn &zone_data[zone];\n\t\t}\n\t}\n\treturn NULL;\n}\n\n \nstatic int alienware_update_led(struct platform_zone *zone)\n{\n\tint method_id;\n\tacpi_status status;\n\tchar *guid;\n\tstruct acpi_buffer input;\n\tstruct legacy_led_args legacy_args;\n\tstruct wmax_led_args wmax_basic_args;\n\tif (interface == WMAX) {\n\t\twmax_basic_args.led_mask = 1 << zone->location;\n\t\twmax_basic_args.colors = zone->colors;\n\t\twmax_basic_args.state = lighting_control_state;\n\t\tguid = WMAX_CONTROL_GUID;\n\t\tmethod_id = WMAX_METHOD_ZONE_CONTROL;\n\n\t\tinput.length = (acpi_size) sizeof(wmax_basic_args);\n\t\tinput.pointer = &wmax_basic_args;\n\t} else {\n\t\tlegacy_args.colors = zone->colors;\n\t\tlegacy_args.brightness = global_brightness;\n\t\tlegacy_args.state = 0;\n\t\tif (lighting_control_state == LEGACY_BOOTING ||\n\t\t    lighting_control_state == LEGACY_SUSPEND) {\n\t\t\tguid = LEGACY_POWER_CONTROL_GUID;\n\t\t\tlegacy_args.state = lighting_control_state;\n\t\t} else\n\t\t\tguid = LEGACY_CONTROL_GUID;\n\t\tmethod_id = zone->location + 1;\n\n\t\tinput.length = (acpi_size) sizeof(legacy_args);\n\t\tinput.pointer = &legacy_args;\n\t}\n\tpr_debug(\"alienware-wmi: guid %s method %d\\n\", guid, method_id);\n\n\tstatus = wmi_evaluate_method(guid, 0, method_id, &input, NULL);\n\tif (ACPI_FAILURE(status))\n\t\tpr_err(\"alienware-wmi: zone set failure: %u\\n\", status);\n\treturn ACPI_FAILURE(status);\n}\n\nstatic ssize_t zone_show(struct device *dev, struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct platform_zone *target_zone;\n\ttarget_zone = match_zone(attr);\n\tif (target_zone == NULL)\n\t\treturn sprintf(buf, \"red: -1, green: -1, blue: -1\\n\");\n\treturn sprintf(buf, \"red: %d, green: %d, blue: %d\\n\",\n\t\t       target_zone->colors.red,\n\t\t       target_zone->colors.green, target_zone->colors.blue);\n\n}\n\nstatic ssize_t zone_set(struct device *dev, struct device_attribute *attr,\n\t\t\tconst char *buf, size_t count)\n{\n\tstruct platform_zone *target_zone;\n\tint ret;\n\ttarget_zone = match_zone(attr);\n\tif (target_zone == NULL) {\n\t\tpr_err(\"alienware-wmi: invalid target zone\\n\");\n\t\treturn 1;\n\t}\n\tret = parse_rgb(buf, target_zone);\n\tif (ret)\n\t\treturn ret;\n\tret = alienware_update_led(target_zone);\n\treturn ret ? ret : count;\n}\n\n \nstatic int wmax_brightness(int brightness)\n{\n\tacpi_status status;\n\tstruct acpi_buffer input;\n\tstruct wmax_brightness_args args = {\n\t\t.led_mask = 0xFF,\n\t\t.percentage = brightness,\n\t};\n\tinput.length = (acpi_size) sizeof(args);\n\tinput.pointer = &args;\n\tstatus = wmi_evaluate_method(WMAX_CONTROL_GUID, 0,\n\t\t\t\t     WMAX_METHOD_BRIGHTNESS, &input, NULL);\n\tif (ACPI_FAILURE(status))\n\t\tpr_err(\"alienware-wmi: brightness set failure: %u\\n\", status);\n\treturn ACPI_FAILURE(status);\n}\n\nstatic void global_led_set(struct led_classdev *led_cdev,\n\t\t\t   enum led_brightness brightness)\n{\n\tint ret;\n\tglobal_brightness = brightness;\n\tif (interface == WMAX)\n\t\tret = wmax_brightness(brightness);\n\telse\n\t\tret = alienware_update_led(&zone_data[0]);\n\tif (ret)\n\t\tpr_err(\"LED brightness update failed\\n\");\n}\n\nstatic enum led_brightness global_led_get(struct led_classdev *led_cdev)\n{\n\treturn global_brightness;\n}\n\nstatic struct led_classdev global_led = {\n\t.brightness_set = global_led_set,\n\t.brightness_get = global_led_get,\n\t.name = \"alienware::global_brightness\",\n};\n\n \nstatic ssize_t show_control_state(struct device *dev,\n\t\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tif (lighting_control_state == LEGACY_BOOTING)\n\t\treturn sysfs_emit(buf, \"[booting] running suspend\\n\");\n\telse if (lighting_control_state == LEGACY_SUSPEND)\n\t\treturn sysfs_emit(buf, \"booting running [suspend]\\n\");\n\treturn sysfs_emit(buf, \"booting [running] suspend\\n\");\n}\n\nstatic ssize_t store_control_state(struct device *dev,\n\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t   const char *buf, size_t count)\n{\n\tlong unsigned int val;\n\tif (strcmp(buf, \"booting\\n\") == 0)\n\t\tval = LEGACY_BOOTING;\n\telse if (strcmp(buf, \"suspend\\n\") == 0)\n\t\tval = LEGACY_SUSPEND;\n\telse if (interface == LEGACY)\n\t\tval = LEGACY_RUNNING;\n\telse\n\t\tval = WMAX_RUNNING;\n\tlighting_control_state = val;\n\tpr_debug(\"alienware-wmi: updated control state to %d\\n\",\n\t\t lighting_control_state);\n\treturn count;\n}\n\nstatic DEVICE_ATTR(lighting_control_state, 0644, show_control_state,\n\t\t   store_control_state);\n\nstatic int alienware_zone_init(struct platform_device *dev)\n{\n\tu8 zone;\n\tchar buffer[10];\n\tchar *name;\n\n\tif (interface == WMAX) {\n\t\tlighting_control_state = WMAX_RUNNING;\n\t} else if (interface == LEGACY) {\n\t\tlighting_control_state = LEGACY_RUNNING;\n\t}\n\tglobal_led.max_brightness = 0x0F;\n\tglobal_brightness = global_led.max_brightness;\n\n\t \n\tzone_dev_attrs =\n\t    kcalloc(quirks->num_zones + 1, sizeof(struct device_attribute),\n\t\t    GFP_KERNEL);\n\tif (!zone_dev_attrs)\n\t\treturn -ENOMEM;\n\n\tzone_attrs =\n\t    kcalloc(quirks->num_zones + 2, sizeof(struct attribute *),\n\t\t    GFP_KERNEL);\n\tif (!zone_attrs)\n\t\treturn -ENOMEM;\n\n\tzone_data =\n\t    kcalloc(quirks->num_zones, sizeof(struct platform_zone),\n\t\t    GFP_KERNEL);\n\tif (!zone_data)\n\t\treturn -ENOMEM;\n\n\tfor (zone = 0; zone < quirks->num_zones; zone++) {\n\t\tsprintf(buffer, \"zone%02hhX\", zone);\n\t\tname = kstrdup(buffer, GFP_KERNEL);\n\t\tif (name == NULL)\n\t\t\treturn 1;\n\t\tsysfs_attr_init(&zone_dev_attrs[zone].attr);\n\t\tzone_dev_attrs[zone].attr.name = name;\n\t\tzone_dev_attrs[zone].attr.mode = 0644;\n\t\tzone_dev_attrs[zone].show = zone_show;\n\t\tzone_dev_attrs[zone].store = zone_set;\n\t\tzone_data[zone].location = zone;\n\t\tzone_attrs[zone] = &zone_dev_attrs[zone].attr;\n\t\tzone_data[zone].attr = &zone_dev_attrs[zone];\n\t}\n\tzone_attrs[quirks->num_zones] = &dev_attr_lighting_control_state.attr;\n\tzone_attribute_group.attrs = zone_attrs;\n\n\tled_classdev_register(&dev->dev, &global_led);\n\n\treturn sysfs_create_group(&dev->dev.kobj, &zone_attribute_group);\n}\n\nstatic void alienware_zone_exit(struct platform_device *dev)\n{\n\tu8 zone;\n\n\tsysfs_remove_group(&dev->dev.kobj, &zone_attribute_group);\n\tled_classdev_unregister(&global_led);\n\tif (zone_dev_attrs) {\n\t\tfor (zone = 0; zone < quirks->num_zones; zone++)\n\t\t\tkfree(zone_dev_attrs[zone].attr.name);\n\t}\n\tkfree(zone_dev_attrs);\n\tkfree(zone_data);\n\tkfree(zone_attrs);\n}\n\nstatic acpi_status alienware_wmax_command(struct wmax_basic_args *in_args,\n\t\t\t\t\t  u32 command, int *out_data)\n{\n\tacpi_status status;\n\tunion acpi_object *obj;\n\tstruct acpi_buffer input;\n\tstruct acpi_buffer output;\n\n\tinput.length = (acpi_size) sizeof(*in_args);\n\tinput.pointer = in_args;\n\tif (out_data) {\n\t\toutput.length = ACPI_ALLOCATE_BUFFER;\n\t\toutput.pointer = NULL;\n\t\tstatus = wmi_evaluate_method(WMAX_CONTROL_GUID, 0,\n\t\t\t\t\t     command, &input, &output);\n\t\tif (ACPI_SUCCESS(status)) {\n\t\t\tobj = (union acpi_object *)output.pointer;\n\t\t\tif (obj && obj->type == ACPI_TYPE_INTEGER)\n\t\t\t\t*out_data = (u32)obj->integer.value;\n\t\t}\n\t\tkfree(output.pointer);\n\t} else {\n\t\tstatus = wmi_evaluate_method(WMAX_CONTROL_GUID, 0,\n\t\t\t\t\t     command, &input, NULL);\n\t}\n\treturn status;\n}\n\n \nstatic ssize_t show_hdmi_cable(struct device *dev,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tacpi_status status;\n\tu32 out_data;\n\tstruct wmax_basic_args in_args = {\n\t\t.arg = 0,\n\t};\n\tstatus =\n\t    alienware_wmax_command(&in_args, WMAX_METHOD_HDMI_CABLE,\n\t\t\t\t   (u32 *) &out_data);\n\tif (ACPI_SUCCESS(status)) {\n\t\tif (out_data == 0)\n\t\t\treturn sysfs_emit(buf, \"[unconnected] connected unknown\\n\");\n\t\telse if (out_data == 1)\n\t\t\treturn sysfs_emit(buf, \"unconnected [connected] unknown\\n\");\n\t}\n\tpr_err(\"alienware-wmi: unknown HDMI cable status: %d\\n\", status);\n\treturn sysfs_emit(buf, \"unconnected connected [unknown]\\n\");\n}\n\nstatic ssize_t show_hdmi_source(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tacpi_status status;\n\tu32 out_data;\n\tstruct wmax_basic_args in_args = {\n\t\t.arg = 0,\n\t};\n\tstatus =\n\t    alienware_wmax_command(&in_args, WMAX_METHOD_HDMI_STATUS,\n\t\t\t\t   (u32 *) &out_data);\n\n\tif (ACPI_SUCCESS(status)) {\n\t\tif (out_data == 1)\n\t\t\treturn sysfs_emit(buf, \"[input] gpu unknown\\n\");\n\t\telse if (out_data == 2)\n\t\t\treturn sysfs_emit(buf, \"input [gpu] unknown\\n\");\n\t}\n\tpr_err(\"alienware-wmi: unknown HDMI source status: %u\\n\", status);\n\treturn sysfs_emit(buf, \"input gpu [unknown]\\n\");\n}\n\nstatic ssize_t toggle_hdmi_source(struct device *dev,\n\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t  const char *buf, size_t count)\n{\n\tacpi_status status;\n\tstruct wmax_basic_args args;\n\tif (strcmp(buf, \"gpu\\n\") == 0)\n\t\targs.arg = 1;\n\telse if (strcmp(buf, \"input\\n\") == 0)\n\t\targs.arg = 2;\n\telse\n\t\targs.arg = 3;\n\tpr_debug(\"alienware-wmi: setting hdmi to %d : %s\", args.arg, buf);\n\n\tstatus = alienware_wmax_command(&args, WMAX_METHOD_HDMI_SOURCE, NULL);\n\n\tif (ACPI_FAILURE(status))\n\t\tpr_err(\"alienware-wmi: HDMI toggle failed: results: %u\\n\",\n\t\t       status);\n\treturn count;\n}\n\nstatic DEVICE_ATTR(cable, S_IRUGO, show_hdmi_cable, NULL);\nstatic DEVICE_ATTR(source, S_IRUGO | S_IWUSR, show_hdmi_source,\n\t\t   toggle_hdmi_source);\n\nstatic struct attribute *hdmi_attrs[] = {\n\t&dev_attr_cable.attr,\n\t&dev_attr_source.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group hdmi_attribute_group = {\n\t.name = \"hdmi\",\n\t.attrs = hdmi_attrs,\n};\n\nstatic void remove_hdmi(struct platform_device *dev)\n{\n\tif (quirks->hdmi_mux > 0)\n\t\tsysfs_remove_group(&dev->dev.kobj, &hdmi_attribute_group);\n}\n\nstatic int create_hdmi(struct platform_device *dev)\n{\n\tint ret;\n\n\tret = sysfs_create_group(&dev->dev.kobj, &hdmi_attribute_group);\n\tif (ret)\n\t\tremove_hdmi(dev);\n\treturn ret;\n}\n\n \nstatic ssize_t show_amplifier_status(struct device *dev,\n\t\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tacpi_status status;\n\tu32 out_data;\n\tstruct wmax_basic_args in_args = {\n\t\t.arg = 0,\n\t};\n\tstatus =\n\t    alienware_wmax_command(&in_args, WMAX_METHOD_AMPLIFIER_CABLE,\n\t\t\t\t   (u32 *) &out_data);\n\tif (ACPI_SUCCESS(status)) {\n\t\tif (out_data == 0)\n\t\t\treturn sysfs_emit(buf, \"[unconnected] connected unknown\\n\");\n\t\telse if (out_data == 1)\n\t\t\treturn sysfs_emit(buf, \"unconnected [connected] unknown\\n\");\n\t}\n\tpr_err(\"alienware-wmi: unknown amplifier cable status: %d\\n\", status);\n\treturn sysfs_emit(buf, \"unconnected connected [unknown]\\n\");\n}\n\nstatic DEVICE_ATTR(status, S_IRUGO, show_amplifier_status, NULL);\n\nstatic struct attribute *amplifier_attrs[] = {\n\t&dev_attr_status.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group amplifier_attribute_group = {\n\t.name = \"amplifier\",\n\t.attrs = amplifier_attrs,\n};\n\nstatic void remove_amplifier(struct platform_device *dev)\n{\n\tif (quirks->amplifier > 0)\n\t\tsysfs_remove_group(&dev->dev.kobj, &amplifier_attribute_group);\n}\n\nstatic int create_amplifier(struct platform_device *dev)\n{\n\tint ret;\n\n\tret = sysfs_create_group(&dev->dev.kobj, &amplifier_attribute_group);\n\tif (ret)\n\t\tremove_amplifier(dev);\n\treturn ret;\n}\n\n \nstatic ssize_t show_deepsleep_status(struct device *dev,\n\t\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tacpi_status status;\n\tu32 out_data;\n\tstruct wmax_basic_args in_args = {\n\t\t.arg = 0,\n\t};\n\tstatus = alienware_wmax_command(&in_args, WMAX_METHOD_DEEP_SLEEP_STATUS,\n\t\t\t\t\t(u32 *) &out_data);\n\tif (ACPI_SUCCESS(status)) {\n\t\tif (out_data == 0)\n\t\t\treturn sysfs_emit(buf, \"[disabled] s5 s5_s4\\n\");\n\t\telse if (out_data == 1)\n\t\t\treturn sysfs_emit(buf, \"disabled [s5] s5_s4\\n\");\n\t\telse if (out_data == 2)\n\t\t\treturn sysfs_emit(buf, \"disabled s5 [s5_s4]\\n\");\n\t}\n\tpr_err(\"alienware-wmi: unknown deep sleep status: %d\\n\", status);\n\treturn sysfs_emit(buf, \"disabled s5 s5_s4 [unknown]\\n\");\n}\n\nstatic ssize_t toggle_deepsleep(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tconst char *buf, size_t count)\n{\n\tacpi_status status;\n\tstruct wmax_basic_args args;\n\n\tif (strcmp(buf, \"disabled\\n\") == 0)\n\t\targs.arg = 0;\n\telse if (strcmp(buf, \"s5\\n\") == 0)\n\t\targs.arg = 1;\n\telse\n\t\targs.arg = 2;\n\tpr_debug(\"alienware-wmi: setting deep sleep to %d : %s\", args.arg, buf);\n\n\tstatus = alienware_wmax_command(&args, WMAX_METHOD_DEEP_SLEEP_CONTROL,\n\t\t\t\t\tNULL);\n\n\tif (ACPI_FAILURE(status))\n\t\tpr_err(\"alienware-wmi: deep sleep control failed: results: %u\\n\",\n\t\t\tstatus);\n\treturn count;\n}\n\nstatic DEVICE_ATTR(deepsleep, S_IRUGO | S_IWUSR, show_deepsleep_status, toggle_deepsleep);\n\nstatic struct attribute *deepsleep_attrs[] = {\n\t&dev_attr_deepsleep.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group deepsleep_attribute_group = {\n\t.name = \"deepsleep\",\n\t.attrs = deepsleep_attrs,\n};\n\nstatic void remove_deepsleep(struct platform_device *dev)\n{\n\tif (quirks->deepslp > 0)\n\t\tsysfs_remove_group(&dev->dev.kobj, &deepsleep_attribute_group);\n}\n\nstatic int create_deepsleep(struct platform_device *dev)\n{\n\tint ret;\n\n\tret = sysfs_create_group(&dev->dev.kobj, &deepsleep_attribute_group);\n\tif (ret)\n\t\tremove_deepsleep(dev);\n\treturn ret;\n}\n\nstatic int __init alienware_wmi_init(void)\n{\n\tint ret;\n\n\tif (wmi_has_guid(LEGACY_CONTROL_GUID))\n\t\tinterface = LEGACY;\n\telse if (wmi_has_guid(WMAX_CONTROL_GUID))\n\t\tinterface = WMAX;\n\telse {\n\t\tpr_warn(\"alienware-wmi: No known WMI GUID found\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tdmi_check_system(alienware_quirks);\n\tif (quirks == NULL)\n\t\tquirks = &quirk_unknown;\n\n\tret = platform_driver_register(&platform_driver);\n\tif (ret)\n\t\tgoto fail_platform_driver;\n\tplatform_device = platform_device_alloc(\"alienware-wmi\", PLATFORM_DEVID_NONE);\n\tif (!platform_device) {\n\t\tret = -ENOMEM;\n\t\tgoto fail_platform_device1;\n\t}\n\tret = platform_device_add(platform_device);\n\tif (ret)\n\t\tgoto fail_platform_device2;\n\n\tif (quirks->hdmi_mux > 0) {\n\t\tret = create_hdmi(platform_device);\n\t\tif (ret)\n\t\t\tgoto fail_prep_hdmi;\n\t}\n\n\tif (quirks->amplifier > 0) {\n\t\tret = create_amplifier(platform_device);\n\t\tif (ret)\n\t\t\tgoto fail_prep_amplifier;\n\t}\n\n\tif (quirks->deepslp > 0) {\n\t\tret = create_deepsleep(platform_device);\n\t\tif (ret)\n\t\t\tgoto fail_prep_deepsleep;\n\t}\n\n\tret = alienware_zone_init(platform_device);\n\tif (ret)\n\t\tgoto fail_prep_zones;\n\n\treturn 0;\n\nfail_prep_zones:\n\talienware_zone_exit(platform_device);\nfail_prep_deepsleep:\nfail_prep_amplifier:\nfail_prep_hdmi:\n\tplatform_device_del(platform_device);\nfail_platform_device2:\n\tplatform_device_put(platform_device);\nfail_platform_device1:\n\tplatform_driver_unregister(&platform_driver);\nfail_platform_driver:\n\treturn ret;\n}\n\nmodule_init(alienware_wmi_init);\n\nstatic void __exit alienware_wmi_exit(void)\n{\n\tif (platform_device) {\n\t\talienware_zone_exit(platform_device);\n\t\tremove_hdmi(platform_device);\n\t\tplatform_device_unregister(platform_device);\n\t\tplatform_driver_unregister(&platform_driver);\n\t}\n}\n\nmodule_exit(alienware_wmi_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}