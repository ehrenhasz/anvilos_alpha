{
  "module_name": "dell_rbu.c",
  "hash_id": "730b257db2243569d9184f4628507927280a0e089f53e2cbbb3b7fd5045d4a5e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/x86/dell/dell_rbu.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt)\tKBUILD_MODNAME \": \" fmt\n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/blkdev.h>\n#include <linux/platform_device.h>\n#include <linux/spinlock.h>\n#include <linux/moduleparam.h>\n#include <linux/firmware.h>\n#include <linux/dma-mapping.h>\n#include <asm/set_memory.h>\n\nMODULE_AUTHOR(\"Abhay Salunke <abhay_salunke@dell.com>\");\nMODULE_DESCRIPTION(\"Driver for updating BIOS image on DELL systems\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(\"3.2\");\n\n#define BIOS_SCAN_LIMIT 0xffffffff\n#define MAX_IMAGE_LENGTH 16\nstatic struct _rbu_data {\n\tvoid *image_update_buffer;\n\tunsigned long image_update_buffer_size;\n\tunsigned long bios_image_size;\n\tint image_update_ordernum;\n\tspinlock_t lock;\n\tunsigned long packet_read_count;\n\tunsigned long num_packets;\n\tunsigned long packetsize;\n\tunsigned long imagesize;\n\tint entry_created;\n} rbu_data;\n\nstatic char image_type[MAX_IMAGE_LENGTH + 1] = \"mono\";\nmodule_param_string(image_type, image_type, sizeof (image_type), 0);\nMODULE_PARM_DESC(image_type, \"BIOS image type. choose- mono or packet or init\");\n\nstatic unsigned long allocation_floor = 0x100000;\nmodule_param(allocation_floor, ulong, 0644);\nMODULE_PARM_DESC(allocation_floor, \"Minimum address for allocations when using Packet mode\");\n\nstruct packet_data {\n\tstruct list_head list;\n\tsize_t length;\n\tvoid *data;\n\tint ordernum;\n};\n\nstatic struct packet_data packet_data_head;\n\nstatic struct platform_device *rbu_device;\nstatic int context;\n\nstatic void init_packet_head(void)\n{\n\tINIT_LIST_HEAD(&packet_data_head.list);\n\trbu_data.packet_read_count = 0;\n\trbu_data.num_packets = 0;\n\trbu_data.packetsize = 0;\n\trbu_data.imagesize = 0;\n}\n\nstatic int create_packet(void *data, size_t length)\n{\n\tstruct packet_data *newpacket;\n\tint ordernum = 0;\n\tint retval = 0;\n\tunsigned int packet_array_size = 0;\n\tvoid **invalid_addr_packet_array = NULL;\n\tvoid *packet_data_temp_buf = NULL;\n\tunsigned int idx = 0;\n\n\tpr_debug(\"entry\\n\");\n\n\tif (!rbu_data.packetsize) {\n\t\tpr_debug(\"packetsize not specified\\n\");\n\t\tretval = -EINVAL;\n\t\tgoto out_noalloc;\n\t}\n\n\tspin_unlock(&rbu_data.lock);\n\n\tnewpacket = kzalloc(sizeof (struct packet_data), GFP_KERNEL);\n\n\tif (!newpacket) {\n\t\tpr_warn(\"failed to allocate new packet\\n\");\n\t\tretval = -ENOMEM;\n\t\tspin_lock(&rbu_data.lock);\n\t\tgoto out_noalloc;\n\t}\n\n\tordernum = get_order(length);\n\n\t \n\tpacket_array_size = max_t(unsigned int, allocation_floor / rbu_data.packetsize, 1);\n\tinvalid_addr_packet_array = kcalloc(packet_array_size, sizeof(void *),\n\t\t\t\t\t\tGFP_KERNEL);\n\n\tif (!invalid_addr_packet_array) {\n\t\tpr_warn(\"failed to allocate invalid_addr_packet_array\\n\");\n\t\tretval = -ENOMEM;\n\t\tspin_lock(&rbu_data.lock);\n\t\tgoto out_alloc_packet;\n\t}\n\n\twhile (!packet_data_temp_buf) {\n\t\tpacket_data_temp_buf = (unsigned char *)\n\t\t\t__get_free_pages(GFP_KERNEL, ordernum);\n\t\tif (!packet_data_temp_buf) {\n\t\t\tpr_warn(\"failed to allocate new packet\\n\");\n\t\t\tretval = -ENOMEM;\n\t\t\tspin_lock(&rbu_data.lock);\n\t\t\tgoto out_alloc_packet_array;\n\t\t}\n\n\t\tif ((unsigned long)virt_to_phys(packet_data_temp_buf)\n\t\t\t\t< allocation_floor) {\n\t\t\tpr_debug(\"packet 0x%lx below floor at 0x%lx\\n\",\n\t\t\t\t\t(unsigned long)virt_to_phys(\n\t\t\t\t\t\tpacket_data_temp_buf),\n\t\t\t\t\tallocation_floor);\n\t\t\tinvalid_addr_packet_array[idx++] = packet_data_temp_buf;\n\t\t\tpacket_data_temp_buf = NULL;\n\t\t}\n\t}\n\t \n\tset_memory_uc((unsigned long)packet_data_temp_buf, 1 << ordernum);\n\n\tspin_lock(&rbu_data.lock);\n\n\tnewpacket->data = packet_data_temp_buf;\n\n\tpr_debug(\"newpacket at physical addr %lx\\n\",\n\t\t(unsigned long)virt_to_phys(newpacket->data));\n\n\t \n\tnewpacket->length = length;\n\tnewpacket->ordernum = ordernum;\n\t++rbu_data.num_packets;\n\n\t \n\tINIT_LIST_HEAD(&newpacket->list);\n\tlist_add_tail(&newpacket->list, &packet_data_head.list);\n\n\tmemcpy(newpacket->data, data, length);\n\n\tpr_debug(\"exit\\n\");\n\nout_alloc_packet_array:\n\t \n\twhile (idx--) {\n\t\tpr_debug(\"freeing unused packet below floor 0x%lx\\n\",\n\t\t\t(unsigned long)virt_to_phys(invalid_addr_packet_array[idx]));\n\t\tfree_pages((unsigned long)invalid_addr_packet_array[idx], ordernum);\n\t}\n\tkfree(invalid_addr_packet_array);\n\nout_alloc_packet:\n\t \n\tif (retval)\n\t\tkfree(newpacket);\n\nout_noalloc:\n\treturn retval;\n}\n\nstatic int packetize_data(const u8 *data, size_t length)\n{\n\tint rc = 0;\n\tint done = 0;\n\tint packet_length;\n\tu8 *temp;\n\tu8 *end = (u8 *) data + length;\n\tpr_debug(\"data length %zd\\n\", length);\n\tif (!rbu_data.packetsize) {\n\t\tpr_warn(\"packetsize not specified\\n\");\n\t\treturn -EIO;\n\t}\n\n\ttemp = (u8 *) data;\n\n\t \n\twhile (!done) {\n\t\tif ((temp + rbu_data.packetsize) < end)\n\t\t\tpacket_length = rbu_data.packetsize;\n\t\telse {\n\t\t\t \n\t\t\tpacket_length = end - temp;\n\t\t\tdone = 1;\n\t\t}\n\n\t\tif ((rc = create_packet(temp, packet_length)))\n\t\t\treturn rc;\n\n\t\tpr_debug(\"%p:%td\\n\", temp, (end - temp));\n\t\ttemp += packet_length;\n\t}\n\n\trbu_data.imagesize = length;\n\n\treturn rc;\n}\n\nstatic int do_packet_read(char *data, struct packet_data *newpacket,\n\tint length, int bytes_read, int *list_read_count)\n{\n\tvoid *ptemp_buf;\n\tint bytes_copied = 0;\n\tint j = 0;\n\n\t*list_read_count += newpacket->length;\n\n\tif (*list_read_count > bytes_read) {\n\t\t \n\t\tj = newpacket->length - (*list_read_count - bytes_read);\n\t\t \n\t\tptemp_buf = (u8 *) newpacket->data + j;\n\t\t \n\t\tif (length > (*list_read_count - bytes_read))\n\t\t\t \n\t\t\tbytes_copied = (*list_read_count - bytes_read);\n\t\telse\n\t\t\t \n\t\t\tbytes_copied = length;\n\t\tmemcpy(data, ptemp_buf, bytes_copied);\n\t}\n\treturn bytes_copied;\n}\n\nstatic int packet_read_list(char *data, size_t * pread_length)\n{\n\tstruct packet_data *newpacket;\n\tint temp_count = 0;\n\tint bytes_copied = 0;\n\tint bytes_read = 0;\n\tint remaining_bytes = 0;\n\tchar *pdest = data;\n\n\t \n\tif (0 == rbu_data.num_packets)\n\t\treturn -ENOMEM;\n\n\tremaining_bytes = *pread_length;\n\tbytes_read = rbu_data.packet_read_count;\n\n\tlist_for_each_entry(newpacket, (&packet_data_head.list)->next, list) {\n\t\tbytes_copied = do_packet_read(pdest, newpacket,\n\t\t\tremaining_bytes, bytes_read, &temp_count);\n\t\tremaining_bytes -= bytes_copied;\n\t\tbytes_read += bytes_copied;\n\t\tpdest += bytes_copied;\n\t\t \n\t\tif (remaining_bytes == 0)\n\t\t\tbreak;\n\t}\n\t \n\t*pread_length = bytes_read - rbu_data.packet_read_count;\n\trbu_data.packet_read_count = bytes_read;\n\treturn 0;\n}\n\nstatic void packet_empty_list(void)\n{\n\tstruct packet_data *newpacket, *tmp;\n\n\tlist_for_each_entry_safe(newpacket, tmp, (&packet_data_head.list)->next, list) {\n\t\tlist_del(&newpacket->list);\n\n\t\t \n\t\tmemset(newpacket->data, 0, rbu_data.packetsize);\n\t\tset_memory_wb((unsigned long)newpacket->data,\n\t\t\t1 << newpacket->ordernum);\n\t\tfree_pages((unsigned long) newpacket->data,\n\t\t\tnewpacket->ordernum);\n\t\tkfree(newpacket);\n\t}\n\trbu_data.packet_read_count = 0;\n\trbu_data.num_packets = 0;\n\trbu_data.imagesize = 0;\n}\n\n \nstatic void img_update_free(void)\n{\n\tif (!rbu_data.image_update_buffer)\n\t\treturn;\n\t \n\tmemset(rbu_data.image_update_buffer, 0,\n\t\trbu_data.image_update_buffer_size);\n\tfree_pages((unsigned long) rbu_data.image_update_buffer,\n\t\trbu_data.image_update_ordernum);\n\n\t \n\trbu_data.image_update_ordernum = -1;\n\trbu_data.image_update_buffer = NULL;\n\trbu_data.image_update_buffer_size = 0;\n\trbu_data.bios_image_size = 0;\n}\n\n \nstatic int img_update_realloc(unsigned long size)\n{\n\tunsigned char *image_update_buffer = NULL;\n\tunsigned long img_buf_phys_addr;\n\tint ordernum;\n\n\t \n\tif (rbu_data.image_update_buffer_size >= size) {\n\t\t \n\t\tif ((size != 0) && (rbu_data.image_update_buffer == NULL)) {\n\t\t\tpr_err(\"corruption check failed\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t \n\t\treturn 0;\n\t}\n\n\t \n\timg_update_free();\n\n\tspin_unlock(&rbu_data.lock);\n\n\tordernum = get_order(size);\n\timage_update_buffer =\n\t\t(unsigned char *)__get_free_pages(GFP_DMA32, ordernum);\n\tspin_lock(&rbu_data.lock);\n\tif (!image_update_buffer) {\n\t\tpr_debug(\"Not enough memory for image update: size = %ld\\n\", size);\n\t\treturn -ENOMEM;\n\t}\n\n\timg_buf_phys_addr = (unsigned long)virt_to_phys(image_update_buffer);\n\tif (WARN_ON_ONCE(img_buf_phys_addr > BIOS_SCAN_LIMIT))\n\t\treturn -EINVAL;  \n\n\trbu_data.image_update_buffer = image_update_buffer;\n\trbu_data.image_update_buffer_size = size;\n\trbu_data.bios_image_size = rbu_data.image_update_buffer_size;\n\trbu_data.image_update_ordernum = ordernum;\n\treturn 0;\n}\n\nstatic ssize_t read_packet_data(char *buffer, loff_t pos, size_t count)\n{\n\tint retval;\n\tsize_t bytes_left;\n\tsize_t data_length;\n\tchar *ptempBuf = buffer;\n\n\t \n\tif (rbu_data.num_packets == 0) {\n\t\tpr_debug(\"no packets written\\n\");\n\t\tretval = -ENOMEM;\n\t\tgoto read_rbu_data_exit;\n\t}\n\n\tif (pos > rbu_data.imagesize) {\n\t\tretval = 0;\n\t\tpr_warn(\"data underrun\\n\");\n\t\tgoto read_rbu_data_exit;\n\t}\n\n\tbytes_left = rbu_data.imagesize - pos;\n\tdata_length = min(bytes_left, count);\n\n\tif ((retval = packet_read_list(ptempBuf, &data_length)) < 0)\n\t\tgoto read_rbu_data_exit;\n\n\tif ((pos + count) > rbu_data.imagesize) {\n\t\trbu_data.packet_read_count = 0;\n\t\t \n\t\tretval = bytes_left;\n\t} else\n\t\tretval = count;\n\n      read_rbu_data_exit:\n\treturn retval;\n}\n\nstatic ssize_t read_rbu_mono_data(char *buffer, loff_t pos, size_t count)\n{\n\t \n\tif ((rbu_data.image_update_buffer == NULL) ||\n\t\t(rbu_data.bios_image_size == 0)) {\n\t\tpr_debug(\"image_update_buffer %p, bios_image_size %lu\\n\",\n\t\t\trbu_data.image_update_buffer,\n\t\t\trbu_data.bios_image_size);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn memory_read_from_buffer(buffer, count, &pos,\n\t\t\trbu_data.image_update_buffer, rbu_data.bios_image_size);\n}\n\nstatic ssize_t data_read(struct file *filp, struct kobject *kobj,\n\t\t\t struct bin_attribute *bin_attr,\n\t\t\t char *buffer, loff_t pos, size_t count)\n{\n\tssize_t ret_count = 0;\n\n\tspin_lock(&rbu_data.lock);\n\n\tif (!strcmp(image_type, \"mono\"))\n\t\tret_count = read_rbu_mono_data(buffer, pos, count);\n\telse if (!strcmp(image_type, \"packet\"))\n\t\tret_count = read_packet_data(buffer, pos, count);\n\telse\n\t\tpr_debug(\"invalid image type specified\\n\");\n\n\tspin_unlock(&rbu_data.lock);\n\treturn ret_count;\n}\nstatic BIN_ATTR_RO(data, 0);\n\nstatic void callbackfn_rbu(const struct firmware *fw, void *context)\n{\n\trbu_data.entry_created = 0;\n\n\tif (!fw)\n\t\treturn;\n\n\tif (!fw->size)\n\t\tgoto out;\n\n\tspin_lock(&rbu_data.lock);\n\tif (!strcmp(image_type, \"mono\")) {\n\t\tif (!img_update_realloc(fw->size))\n\t\t\tmemcpy(rbu_data.image_update_buffer,\n\t\t\t\tfw->data, fw->size);\n\t} else if (!strcmp(image_type, \"packet\")) {\n\t\t \n\t\tpacket_empty_list();\n\t\tif (packetize_data(fw->data, fw->size))\n\t\t\t \n\t\t\tpacket_empty_list();\n\t} else\n\t\tpr_debug(\"invalid image type specified\\n\");\n\tspin_unlock(&rbu_data.lock);\n out:\n\trelease_firmware(fw);\n}\n\nstatic ssize_t image_type_read(struct file *filp, struct kobject *kobj,\n\t\t\t       struct bin_attribute *bin_attr,\n\t\t\t       char *buffer, loff_t pos, size_t count)\n{\n\tint size = 0;\n\tif (!pos)\n\t\tsize = scnprintf(buffer, count, \"%s\\n\", image_type);\n\treturn size;\n}\n\nstatic ssize_t image_type_write(struct file *filp, struct kobject *kobj,\n\t\t\t\tstruct bin_attribute *bin_attr,\n\t\t\t\tchar *buffer, loff_t pos, size_t count)\n{\n\tint rc = count;\n\tint req_firm_rc = 0;\n\tint i;\n\tspin_lock(&rbu_data.lock);\n\t \n\tfor (i = 0; i < count; ++i)\n\t\tif (buffer[i] == '\\n' || buffer[i] == ' ') {\n\t\t\tbuffer[i] = '\\0';\n\t\t\tbreak;\n\t\t}\n\tif (i == count)\n\t\tbuffer[count] = '\\0';\n\n\tif (strstr(buffer, \"mono\"))\n\t\tstrcpy(image_type, \"mono\");\n\telse if (strstr(buffer, \"packet\"))\n\t\tstrcpy(image_type, \"packet\");\n\telse if (strstr(buffer, \"init\")) {\n\t\t \n\t\tif (!rbu_data.entry_created) {\n\t\t\tspin_unlock(&rbu_data.lock);\n\t\t\treq_firm_rc = request_firmware_nowait(THIS_MODULE,\n\t\t\t\tFW_ACTION_NOUEVENT, \"dell_rbu\",\n\t\t\t\t&rbu_device->dev, GFP_KERNEL, &context,\n\t\t\t\tcallbackfn_rbu);\n\t\t\tif (req_firm_rc) {\n\t\t\t\tpr_err(\"request_firmware_nowait failed %d\\n\", rc);\n\t\t\t\trc = -EIO;\n\t\t\t} else\n\t\t\t\trbu_data.entry_created = 1;\n\n\t\t\tspin_lock(&rbu_data.lock);\n\t\t}\n\t} else {\n\t\tpr_warn(\"image_type is invalid\\n\");\n\t\tspin_unlock(&rbu_data.lock);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tpacket_empty_list();\n\timg_update_free();\n\tspin_unlock(&rbu_data.lock);\n\n\treturn rc;\n}\nstatic BIN_ATTR_RW(image_type, 0);\n\nstatic ssize_t packet_size_read(struct file *filp, struct kobject *kobj,\n\t\t\t\tstruct bin_attribute *bin_attr,\n\t\t\t\tchar *buffer, loff_t pos, size_t count)\n{\n\tint size = 0;\n\tif (!pos) {\n\t\tspin_lock(&rbu_data.lock);\n\t\tsize = scnprintf(buffer, count, \"%lu\\n\", rbu_data.packetsize);\n\t\tspin_unlock(&rbu_data.lock);\n\t}\n\treturn size;\n}\n\nstatic ssize_t packet_size_write(struct file *filp, struct kobject *kobj,\n\t\t\t\t struct bin_attribute *bin_attr,\n\t\t\t\t char *buffer, loff_t pos, size_t count)\n{\n\tunsigned long temp;\n\tspin_lock(&rbu_data.lock);\n\tpacket_empty_list();\n\tsscanf(buffer, \"%lu\", &temp);\n\tif (temp < 0xffffffff)\n\t\trbu_data.packetsize = temp;\n\n\tspin_unlock(&rbu_data.lock);\n\treturn count;\n}\nstatic BIN_ATTR_RW(packet_size, 0);\n\nstatic struct bin_attribute *rbu_bin_attrs[] = {\n\t&bin_attr_data,\n\t&bin_attr_image_type,\n\t&bin_attr_packet_size,\n\tNULL\n};\n\nstatic const struct attribute_group rbu_group = {\n\t.bin_attrs = rbu_bin_attrs,\n};\n\nstatic int __init dcdrbu_init(void)\n{\n\tint rc;\n\tspin_lock_init(&rbu_data.lock);\n\n\tinit_packet_head();\n\trbu_device = platform_device_register_simple(\"dell_rbu\", PLATFORM_DEVID_NONE, NULL, 0);\n\tif (IS_ERR(rbu_device)) {\n\t\tpr_err(\"platform_device_register_simple failed\\n\");\n\t\treturn PTR_ERR(rbu_device);\n\t}\n\n\trc = sysfs_create_group(&rbu_device->dev.kobj, &rbu_group);\n\tif (rc)\n\t\tgoto out_devreg;\n\n\trbu_data.entry_created = 0;\n\treturn 0;\n\nout_devreg:\n\tplatform_device_unregister(rbu_device);\n\treturn rc;\n}\n\nstatic __exit void dcdrbu_exit(void)\n{\n\tspin_lock(&rbu_data.lock);\n\tpacket_empty_list();\n\timg_update_free();\n\tspin_unlock(&rbu_data.lock);\n\tsysfs_remove_group(&rbu_device->dev.kobj, &rbu_group);\n\tplatform_device_unregister(rbu_device);\n}\n\nmodule_exit(dcdrbu_exit);\nmodule_init(dcdrbu_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}