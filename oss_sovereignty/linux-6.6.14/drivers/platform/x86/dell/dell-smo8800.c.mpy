{
  "module_name": "dell-smo8800.c",
  "hash_id": "c238c3ac42ff3cfaa13e1e1cb1181e6bf475eeb1d2cbdaa68d2a5aa25ee37a90",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/x86/dell/dell-smo8800.c",
  "human_readable_source": "\n \n\n#define DRIVER_NAME \"smo8800\"\n\n#include <linux/fs.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/miscdevice.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/uaccess.h>\n\nstruct smo8800_device {\n\tu32 irq;                      \n\tatomic_t counter;             \n\tstruct miscdevice miscdev;    \n\tunsigned long misc_opened;    \n\twait_queue_head_t misc_wait;  \n\tstruct device *dev;           \n};\n\nstatic irqreturn_t smo8800_interrupt_quick(int irq, void *data)\n{\n\tstruct smo8800_device *smo8800 = data;\n\n\tatomic_inc(&smo8800->counter);\n\twake_up_interruptible(&smo8800->misc_wait);\n\treturn IRQ_WAKE_THREAD;\n}\n\nstatic irqreturn_t smo8800_interrupt_thread(int irq, void *data)\n{\n\tstruct smo8800_device *smo8800 = data;\n\n\tdev_info(smo8800->dev, \"detected free fall\\n\");\n\treturn IRQ_HANDLED;\n}\n\nstatic ssize_t smo8800_misc_read(struct file *file, char __user *buf,\n\t\t\t\t size_t count, loff_t *pos)\n{\n\tstruct smo8800_device *smo8800 = container_of(file->private_data,\n\t\t\t\t\t struct smo8800_device, miscdev);\n\n\tu32 data = 0;\n\tunsigned char byte_data;\n\tssize_t retval = 1;\n\n\tif (count < 1)\n\t\treturn -EINVAL;\n\n\tatomic_set(&smo8800->counter, 0);\n\tretval = wait_event_interruptible(smo8800->misc_wait,\n\t\t\t\t(data = atomic_xchg(&smo8800->counter, 0)));\n\n\tif (retval)\n\t\treturn retval;\n\n\tretval = 1;\n\n\tbyte_data = min_t(u32, data, 255);\n\n\tif (put_user(byte_data, buf))\n\t\tretval = -EFAULT;\n\n\treturn retval;\n}\n\nstatic int smo8800_misc_open(struct inode *inode, struct file *file)\n{\n\tstruct smo8800_device *smo8800 = container_of(file->private_data,\n\t\t\t\t\t struct smo8800_device, miscdev);\n\n\tif (test_and_set_bit(0, &smo8800->misc_opened))\n\t\treturn -EBUSY;  \n\n\tatomic_set(&smo8800->counter, 0);\n\treturn 0;\n}\n\nstatic int smo8800_misc_release(struct inode *inode, struct file *file)\n{\n\tstruct smo8800_device *smo8800 = container_of(file->private_data,\n\t\t\t\t\t struct smo8800_device, miscdev);\n\n\tclear_bit(0, &smo8800->misc_opened);  \n\treturn 0;\n}\n\nstatic const struct file_operations smo8800_misc_fops = {\n\t.owner = THIS_MODULE,\n\t.read = smo8800_misc_read,\n\t.open = smo8800_misc_open,\n\t.release = smo8800_misc_release,\n};\n\nstatic int smo8800_probe(struct platform_device *device)\n{\n\tint err;\n\tstruct smo8800_device *smo8800;\n\n\tsmo8800 = devm_kzalloc(&device->dev, sizeof(*smo8800), GFP_KERNEL);\n\tif (!smo8800) {\n\t\tdev_err(&device->dev, \"failed to allocate device data\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tsmo8800->dev = &device->dev;\n\tsmo8800->miscdev.minor = MISC_DYNAMIC_MINOR;\n\tsmo8800->miscdev.name = \"freefall\";\n\tsmo8800->miscdev.fops = &smo8800_misc_fops;\n\n\tinit_waitqueue_head(&smo8800->misc_wait);\n\n\terr = misc_register(&smo8800->miscdev);\n\tif (err) {\n\t\tdev_err(&device->dev, \"failed to register misc dev: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tplatform_set_drvdata(device, smo8800);\n\n\terr = platform_get_irq(device, 0);\n\tif (err < 0)\n\t\tgoto error;\n\tsmo8800->irq = err;\n\n\terr = request_threaded_irq(smo8800->irq, smo8800_interrupt_quick,\n\t\t\t\t   smo8800_interrupt_thread,\n\t\t\t\t   IRQF_TRIGGER_RISING | IRQF_ONESHOT,\n\t\t\t\t   DRIVER_NAME, smo8800);\n\tif (err) {\n\t\tdev_err(&device->dev,\n\t\t\t\"failed to request thread for IRQ %d: %d\\n\",\n\t\t\tsmo8800->irq, err);\n\t\tgoto error;\n\t}\n\n\tdev_dbg(&device->dev, \"device /dev/freefall registered with IRQ %d\\n\",\n\t\t smo8800->irq);\n\treturn 0;\n\nerror:\n\tmisc_deregister(&smo8800->miscdev);\n\treturn err;\n}\n\nstatic void smo8800_remove(struct platform_device *device)\n{\n\tstruct smo8800_device *smo8800 = platform_get_drvdata(device);\n\n\tfree_irq(smo8800->irq, smo8800);\n\tmisc_deregister(&smo8800->miscdev);\n\tdev_dbg(&device->dev, \"device /dev/freefall unregistered\\n\");\n}\n\n \nstatic const struct acpi_device_id smo8800_ids[] = {\n\t{ \"SMO8800\", 0 },\n\t{ \"SMO8801\", 0 },\n\t{ \"SMO8810\", 0 },\n\t{ \"SMO8811\", 0 },\n\t{ \"SMO8820\", 0 },\n\t{ \"SMO8821\", 0 },\n\t{ \"SMO8830\", 0 },\n\t{ \"SMO8831\", 0 },\n\t{ \"\", 0 },\n};\nMODULE_DEVICE_TABLE(acpi, smo8800_ids);\n\nstatic struct platform_driver smo8800_driver = {\n\t.probe = smo8800_probe,\n\t.remove_new = smo8800_remove,\n\t.driver = {\n\t\t.name = DRIVER_NAME,\n\t\t.acpi_match_table = smo8800_ids,\n\t},\n};\nmodule_platform_driver(smo8800_driver);\n\nMODULE_DESCRIPTION(\"Dell Latitude freefall driver (ACPI SMO88XX)\");\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Sonal Santan, Pali Roh\u00e1r\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}