{
  "module_name": "think-lmi.c",
  "hash_id": "65a66bef97dfac4630ee3b77815051da018fad741c07af7ba93f1a3167bf9c82",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/x86/think-lmi.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/acpi.h>\n#include <linux/errno.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/dmi.h>\n#include <linux/wmi.h>\n#include \"firmware_attributes_class.h\"\n#include \"think-lmi.h\"\n\nstatic bool debug_support;\nmodule_param(debug_support, bool, 0444);\nMODULE_PARM_DESC(debug_support, \"Enable debug command support\");\n\n \n#define LENOVO_BIOS_SETTING_GUID \"51F5230E-9677-46CD-A1CF-C0B23EE34DB7\"\n\n \n#define LENOVO_SET_BIOS_SETTINGS_GUID \"98479A64-33F5-4E33-A707-8E251EBBC3A1\"\n\n \n#define LENOVO_SAVE_BIOS_SETTINGS_GUID \"6A4B54EF-A5ED-4D33-9455-B0D9B48DF4B3\"\n\n \n#define LENOVO_BIOS_PASSWORD_SETTINGS_GUID \"8ADB159E-1E32-455C-BC93-308A7ED98246\"\n\n \n#define LENOVO_SET_BIOS_PASSWORD_GUID \"2651D9FD-911C-4B69-B94E-D0DED5963BD7\"\n\n \n#define LENOVO_GET_BIOS_SELECTIONS_GUID\t\"7364651A-132F-4FE7-ADAA-40C6C7EE2E3B\"\n\n \n#define LENOVO_DEBUG_CMD_GUID \"7FF47003-3B6C-4E5E-A227-E979824A85D1\"\n\n \n#define LENOVO_OPCODE_IF_GUID \"DFDDEF2C-57D4-48ce-B196-0FB787D90836\"\n\n \n#define LENOVO_SET_BIOS_CERT_GUID    \"26861C9F-47E9-44C4-BD8B-DFE7FA2610FE\"\n\n \n#define LENOVO_UPDATE_BIOS_CERT_GUID \"9AA3180A-9750-41F7-B9F7-D5D3B1BAC3CE\"\n\n \n#define LENOVO_CLEAR_BIOS_CERT_GUID  \"B2BC39A7-78DD-4D71-B059-A510DEC44890\"\n \n#define LENOVO_CERT_TO_PASSWORD_GUID \"0DE8590D-5510-4044-9621-77C227F5A70D\"\n\n \n#define LENOVO_SET_BIOS_SETTING_CERT_GUID  \"34A008CC-D205-4B62-9E67-31DFA8B90003\"\n\n \n#define LENOVO_SAVE_BIOS_SETTING_CERT_GUID \"C050FB9D-DF5F-4606-B066-9EFC401B2551\"\n\n \n#define LENOVO_CERT_THUMBPRINT_GUID \"C59119ED-1C0D-4806-A8E9-59AA318176C4\"\n\n#define TLMI_POP_PWD BIT(0)  \n#define TLMI_PAP_PWD BIT(1)  \n#define TLMI_HDD_PWD BIT(2)  \n#define TLMI_SMP_PWD BIT(6)  \n#define TLMI_CERT    BIT(7)  \n\n#define to_tlmi_pwd_setting(kobj)  container_of(kobj, struct tlmi_pwd_setting, kobj)\n#define to_tlmi_attr_setting(kobj)  container_of(kobj, struct tlmi_attr_setting, kobj)\n\nstatic const struct tlmi_err_codes tlmi_errs[] = {\n\t{\"Success\", 0},\n\t{\"Not Supported\", -EOPNOTSUPP},\n\t{\"Invalid Parameter\", -EINVAL},\n\t{\"Access Denied\", -EACCES},\n\t{\"System Busy\", -EBUSY},\n};\n\nstatic const char * const encoding_options[] = {\n\t[TLMI_ENCODING_ASCII] = \"ascii\",\n\t[TLMI_ENCODING_SCANCODE] = \"scancode\",\n};\nstatic const char * const level_options[] = {\n\t[TLMI_LEVEL_USER] = \"user\",\n\t[TLMI_LEVEL_MASTER] = \"master\",\n};\nstatic struct think_lmi tlmi_priv;\nstatic struct class *fw_attr_class;\nstatic DEFINE_MUTEX(tlmi_mutex);\n\n \n \nstatic void strip_cr(char *str)\n{\n\tchar *p = strchrnul(str, '\\n');\n\t*p = '\\0';\n}\n\n \nstatic int tlmi_errstr_to_err(const char *errstr)\n{\n\tint i;\n\n\tfor (i = 0; i < sizeof(tlmi_errs)/sizeof(struct tlmi_err_codes); i++) {\n\t\tif (!strcmp(tlmi_errs[i].err_str, errstr))\n\t\t\treturn tlmi_errs[i].err_code;\n\t}\n\treturn -EPERM;\n}\n\n \nstatic int tlmi_extract_error(const struct acpi_buffer *output)\n{\n\tconst union acpi_object *obj;\n\n\tobj = output->pointer;\n\tif (!obj)\n\t\treturn -ENOMEM;\n\tif (obj->type != ACPI_TYPE_STRING || !obj->string.pointer)\n\t\treturn -EIO;\n\n\treturn tlmi_errstr_to_err(obj->string.pointer);\n}\n\n \nstatic int tlmi_simple_call(const char *guid, const char *arg)\n{\n\tconst struct acpi_buffer input = { strlen(arg), (char *)arg };\n\tstruct acpi_buffer output = { ACPI_ALLOCATE_BUFFER, NULL };\n\tacpi_status status;\n\tint i, err;\n\n\t \n\tfor (i = 0; i < 2; i++) {\n\t\t \n\t\toutput.length = ACPI_ALLOCATE_BUFFER;\n\t\toutput.pointer = NULL;\n\n\t\tstatus = wmi_evaluate_method(guid, 0, 0, &input, &output);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tkfree(output.pointer);\n\t\t\treturn -EIO;\n\t\t}\n\t\terr = tlmi_extract_error(&output);\n\t\tkfree(output.pointer);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n\n \nstatic int tlmi_extract_output_string(const struct acpi_buffer *output,\n\t\t\t\t      char **string)\n{\n\tconst union acpi_object *obj;\n\tchar *s;\n\n\tobj = output->pointer;\n\tif (!obj)\n\t\treturn -ENOMEM;\n\tif (obj->type != ACPI_TYPE_STRING || !obj->string.pointer)\n\t\treturn -EIO;\n\n\ts = kstrdup(obj->string.pointer, GFP_KERNEL);\n\tif (!s)\n\t\treturn -ENOMEM;\n\t*string = s;\n\treturn 0;\n}\n\n \n\n \nstatic int tlmi_get_pwd_settings(struct tlmi_pwdcfg *pwdcfg)\n{\n\tstruct acpi_buffer output = { ACPI_ALLOCATE_BUFFER, NULL };\n\tconst union acpi_object *obj;\n\tacpi_status status;\n\tint copy_size;\n\n\tif (!tlmi_priv.can_get_password_settings)\n\t\treturn -EOPNOTSUPP;\n\n\tstatus = wmi_query_block(LENOVO_BIOS_PASSWORD_SETTINGS_GUID, 0,\n\t\t\t\t &output);\n\tif (ACPI_FAILURE(status))\n\t\treturn -EIO;\n\n\tobj = output.pointer;\n\tif (!obj)\n\t\treturn -ENOMEM;\n\tif (obj->type != ACPI_TYPE_BUFFER || !obj->buffer.pointer) {\n\t\tkfree(obj);\n\t\treturn -EIO;\n\t}\n\t \n\tif (obj->buffer.length < sizeof(struct tlmi_pwdcfg_core)) {\n\t\tpr_warn(\"Unknown pwdcfg buffer length %d\\n\", obj->buffer.length);\n\t\tkfree(obj);\n\t\treturn -EIO;\n\t}\n\n\tcopy_size = min_t(size_t, obj->buffer.length, sizeof(struct tlmi_pwdcfg));\n\n\tmemcpy(pwdcfg, obj->buffer.pointer, copy_size);\n\tkfree(obj);\n\n\tif (WARN_ON(pwdcfg->core.max_length >= TLMI_PWD_BUFSIZE))\n\t\tpwdcfg->core.max_length = TLMI_PWD_BUFSIZE - 1;\n\treturn 0;\n}\n\nstatic int tlmi_save_bios_settings(const char *password)\n{\n\treturn tlmi_simple_call(LENOVO_SAVE_BIOS_SETTINGS_GUID,\n\t\t\t\tpassword);\n}\n\nstatic int tlmi_opcode_setting(char *setting, const char *value)\n{\n\tchar *opcode_str;\n\tint ret;\n\n\topcode_str = kasprintf(GFP_KERNEL, \"%s:%s;\", setting, value);\n\tif (!opcode_str)\n\t\treturn -ENOMEM;\n\n\tret = tlmi_simple_call(LENOVO_OPCODE_IF_GUID, opcode_str);\n\tkfree(opcode_str);\n\treturn ret;\n}\n\nstatic int tlmi_setting(int item, char **value, const char *guid_string)\n{\n\tstruct acpi_buffer output = { ACPI_ALLOCATE_BUFFER, NULL };\n\tacpi_status status;\n\tint ret;\n\n\tstatus = wmi_query_block(guid_string, item, &output);\n\tif (ACPI_FAILURE(status)) {\n\t\tkfree(output.pointer);\n\t\treturn -EIO;\n\t}\n\n\tret = tlmi_extract_output_string(&output, value);\n\tkfree(output.pointer);\n\treturn ret;\n}\n\nstatic int tlmi_get_bios_selections(const char *item, char **value)\n{\n\tconst struct acpi_buffer input = { strlen(item), (char *)item };\n\tstruct acpi_buffer output = { ACPI_ALLOCATE_BUFFER, NULL };\n\tacpi_status status;\n\tint ret;\n\n\tstatus = wmi_evaluate_method(LENOVO_GET_BIOS_SELECTIONS_GUID,\n\t\t\t\t     0, 0, &input, &output);\n\n\tif (ACPI_FAILURE(status)) {\n\t\tkfree(output.pointer);\n\t\treturn -EIO;\n\t}\n\n\tret = tlmi_extract_output_string(&output, value);\n\tkfree(output.pointer);\n\treturn ret;\n}\n\n \nstatic ssize_t is_enabled_show(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t\t\t  char *buf)\n{\n\tstruct tlmi_pwd_setting *setting = to_tlmi_pwd_setting(kobj);\n\n\treturn sysfs_emit(buf, \"%d\\n\", setting->valid);\n}\n\nstatic struct kobj_attribute auth_is_pass_set = __ATTR_RO(is_enabled);\n\nstatic ssize_t current_password_store(struct kobject *kobj,\n\t\t\t\t      struct kobj_attribute *attr,\n\t\t\t\t      const char *buf, size_t count)\n{\n\tstruct tlmi_pwd_setting *setting = to_tlmi_pwd_setting(kobj);\n\tsize_t pwdlen;\n\n\tpwdlen = strlen(buf);\n\t \n\tif (pwdlen && ((pwdlen < setting->minlen) || (pwdlen > setting->maxlen)))\n\t\treturn -EINVAL;\n\n\tstrscpy(setting->password, buf, setting->maxlen);\n\t \n\tstrip_cr(setting->password);\n\treturn count;\n}\n\nstatic struct kobj_attribute auth_current_password = __ATTR_WO(current_password);\n\nstatic ssize_t new_password_store(struct kobject *kobj,\n\t\t\t\t  struct kobj_attribute *attr,\n\t\t\t\t  const char *buf, size_t count)\n{\n\tstruct tlmi_pwd_setting *setting = to_tlmi_pwd_setting(kobj);\n\tchar *auth_str, *new_pwd;\n\tsize_t pwdlen;\n\tint ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (!tlmi_priv.can_set_bios_password)\n\t\treturn -EOPNOTSUPP;\n\n\tnew_pwd = kstrdup(buf, GFP_KERNEL);\n\tif (!new_pwd)\n\t\treturn -ENOMEM;\n\n\t \n\tstrip_cr(new_pwd);\n\n\t \n\tmutex_lock(&tlmi_mutex);\n\n\tpwdlen = strlen(new_pwd);\n\t \n\tif (pwdlen && ((pwdlen < setting->minlen) || (pwdlen > setting->maxlen))) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t \n\tif (tlmi_priv.opcode_support) {\n\t\tchar pwd_type[8];\n\n\t\t \n\t\tif (setting == tlmi_priv.pwd_hdd) {\n\t\t\tif (setting->level == TLMI_LEVEL_USER)\n\t\t\t\tsprintf(pwd_type, \"uhdp%d\", setting->index);\n\t\t\telse\n\t\t\t\tsprintf(pwd_type, \"mhdp%d\", setting->index);\n\t\t} else if (setting == tlmi_priv.pwd_nvme) {\n\t\t\tif (setting->level == TLMI_LEVEL_USER)\n\t\t\t\tsprintf(pwd_type, \"udrp%d\", setting->index);\n\t\t\telse\n\t\t\t\tsprintf(pwd_type, \"adrp%d\", setting->index);\n\t\t} else {\n\t\t\tsprintf(pwd_type, \"%s\", setting->pwd_type);\n\t\t}\n\n\t\tret = tlmi_opcode_setting(\"WmiOpcodePasswordType\", pwd_type);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tif (tlmi_priv.pwd_admin->valid) {\n\t\t\tret = tlmi_opcode_setting(\"WmiOpcodePasswordAdmin\",\n\t\t\t\t\ttlmi_priv.pwd_admin->password);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t}\n\t\tret = tlmi_opcode_setting(\"WmiOpcodePasswordCurrent01\", setting->password);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tret = tlmi_opcode_setting(\"WmiOpcodePasswordNew01\", new_pwd);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tret = tlmi_simple_call(LENOVO_OPCODE_IF_GUID, \"WmiOpcodePasswordSetUpdate;\");\n\t} else {\n\t\t \n\t\tauth_str = kasprintf(GFP_KERNEL, \"%s,%s,%s,%s,%s;\",\n\t\t\t\tsetting->pwd_type, setting->password, new_pwd,\n\t\t\t\tencoding_options[setting->encoding], setting->kbdlang);\n\t\tif (!auth_str) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tret = tlmi_simple_call(LENOVO_SET_BIOS_PASSWORD_GUID, auth_str);\n\t\tkfree(auth_str);\n\t}\nout:\n\tmutex_unlock(&tlmi_mutex);\n\tkfree(new_pwd);\n\treturn ret ?: count;\n}\n\nstatic struct kobj_attribute auth_new_password = __ATTR_WO(new_password);\n\nstatic ssize_t min_password_length_show(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct tlmi_pwd_setting *setting = to_tlmi_pwd_setting(kobj);\n\n\treturn sysfs_emit(buf, \"%d\\n\", setting->minlen);\n}\n\nstatic struct kobj_attribute auth_min_pass_length = __ATTR_RO(min_password_length);\n\nstatic ssize_t max_password_length_show(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct tlmi_pwd_setting *setting = to_tlmi_pwd_setting(kobj);\n\n\treturn sysfs_emit(buf, \"%d\\n\", setting->maxlen);\n}\nstatic struct kobj_attribute auth_max_pass_length = __ATTR_RO(max_password_length);\n\nstatic ssize_t mechanism_show(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t char *buf)\n{\n\treturn sysfs_emit(buf, \"password\\n\");\n}\nstatic struct kobj_attribute auth_mechanism = __ATTR_RO(mechanism);\n\nstatic ssize_t encoding_show(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct tlmi_pwd_setting *setting = to_tlmi_pwd_setting(kobj);\n\n\treturn sysfs_emit(buf, \"%s\\n\", encoding_options[setting->encoding]);\n}\n\nstatic ssize_t encoding_store(struct kobject *kobj,\n\t\t\t\t  struct kobj_attribute *attr,\n\t\t\t\t  const char *buf, size_t count)\n{\n\tstruct tlmi_pwd_setting *setting = to_tlmi_pwd_setting(kobj);\n\tint i;\n\n\t \n\ti = sysfs_match_string(encoding_options, buf);\n\tif (i < 0)\n\t\treturn -EINVAL;\n\n\tsetting->encoding = i;\n\treturn count;\n}\n\nstatic struct kobj_attribute auth_encoding = __ATTR_RW(encoding);\n\nstatic ssize_t kbdlang_show(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct tlmi_pwd_setting *setting = to_tlmi_pwd_setting(kobj);\n\n\treturn sysfs_emit(buf, \"%s\\n\", setting->kbdlang);\n}\n\nstatic ssize_t kbdlang_store(struct kobject *kobj,\n\t\t\t\t  struct kobj_attribute *attr,\n\t\t\t\t  const char *buf, size_t count)\n{\n\tstruct tlmi_pwd_setting *setting = to_tlmi_pwd_setting(kobj);\n\tint length;\n\n\t \n\tlength = strchrnul(buf, '\\n') - buf;\n\tif (!length || length >= TLMI_LANG_MAXLEN)\n\t\treturn -EINVAL;\n\n\tmemcpy(setting->kbdlang, buf, length);\n\tsetting->kbdlang[length] = '\\0';\n\treturn count;\n}\n\nstatic struct kobj_attribute auth_kbdlang = __ATTR_RW(kbdlang);\n\nstatic ssize_t role_show(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct tlmi_pwd_setting *setting = to_tlmi_pwd_setting(kobj);\n\n\treturn sysfs_emit(buf, \"%s\\n\", setting->role);\n}\nstatic struct kobj_attribute auth_role = __ATTR_RO(role);\n\nstatic ssize_t index_show(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct tlmi_pwd_setting *setting = to_tlmi_pwd_setting(kobj);\n\n\treturn sysfs_emit(buf, \"%d\\n\", setting->index);\n}\n\nstatic ssize_t index_store(struct kobject *kobj,\n\t\t\t\t  struct kobj_attribute *attr,\n\t\t\t\t  const char *buf, size_t count)\n{\n\tstruct tlmi_pwd_setting *setting = to_tlmi_pwd_setting(kobj);\n\tint err, val;\n\n\terr = kstrtoint(buf, 10, &val);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (val < 0 || val > TLMI_INDEX_MAX)\n\t\treturn -EINVAL;\n\n\tsetting->index = val;\n\treturn count;\n}\n\nstatic struct kobj_attribute auth_index = __ATTR_RW(index);\n\nstatic ssize_t level_show(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct tlmi_pwd_setting *setting = to_tlmi_pwd_setting(kobj);\n\n\treturn sysfs_emit(buf, \"%s\\n\", level_options[setting->level]);\n}\n\nstatic ssize_t level_store(struct kobject *kobj,\n\t\t\t\t  struct kobj_attribute *attr,\n\t\t\t\t  const char *buf, size_t count)\n{\n\tstruct tlmi_pwd_setting *setting = to_tlmi_pwd_setting(kobj);\n\tint i;\n\n\t \n\ti = sysfs_match_string(level_options, buf);\n\tif (i < 0)\n\t\treturn -EINVAL;\n\n\tsetting->level = i;\n\treturn count;\n}\n\nstatic struct kobj_attribute auth_level = __ATTR_RW(level);\n\nstatic ssize_t cert_thumbprint(char *buf, const char *arg, int count)\n{\n\tconst struct acpi_buffer input = { strlen(arg), (char *)arg };\n\tstruct acpi_buffer output = { ACPI_ALLOCATE_BUFFER, NULL };\n\tconst union acpi_object *obj;\n\tacpi_status status;\n\n\tstatus = wmi_evaluate_method(LENOVO_CERT_THUMBPRINT_GUID, 0, 0, &input, &output);\n\tif (ACPI_FAILURE(status)) {\n\t\tkfree(output.pointer);\n\t\treturn -EIO;\n\t}\n\tobj = output.pointer;\n\tif (!obj)\n\t\treturn -ENOMEM;\n\tif (obj->type != ACPI_TYPE_STRING || !obj->string.pointer) {\n\t\tkfree(output.pointer);\n\t\treturn -EIO;\n\t}\n\tcount += sysfs_emit_at(buf, count, \"%s : %s\\n\", arg, (char *)obj->string.pointer);\n\tkfree(output.pointer);\n\n\treturn count;\n}\n\nstatic ssize_t certificate_thumbprint_show(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct tlmi_pwd_setting *setting = to_tlmi_pwd_setting(kobj);\n\tint count = 0;\n\n\tif (!tlmi_priv.certificate_support || !setting->cert_installed)\n\t\treturn -EOPNOTSUPP;\n\n\tcount += cert_thumbprint(buf, \"Md5\", count);\n\tcount += cert_thumbprint(buf, \"Sha1\", count);\n\tcount += cert_thumbprint(buf, \"Sha256\", count);\n\treturn count;\n}\n\nstatic struct kobj_attribute auth_cert_thumb = __ATTR_RO(certificate_thumbprint);\n\nstatic ssize_t cert_to_password_store(struct kobject *kobj,\n\t\t\t\t  struct kobj_attribute *attr,\n\t\t\t\t  const char *buf, size_t count)\n{\n\tstruct tlmi_pwd_setting *setting = to_tlmi_pwd_setting(kobj);\n\tchar *auth_str, *passwd;\n\tint ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (!tlmi_priv.certificate_support)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!setting->cert_installed)\n\t\treturn -EINVAL;\n\n\tif (!setting->signature || !setting->signature[0])\n\t\treturn -EACCES;\n\n\tpasswd = kstrdup(buf, GFP_KERNEL);\n\tif (!passwd)\n\t\treturn -ENOMEM;\n\n\t \n\tstrip_cr(passwd);\n\n\t \n\tauth_str = kasprintf(GFP_KERNEL, \"%s,%s\", passwd, setting->signature);\n\tif (!auth_str) {\n\t\tkfree_sensitive(passwd);\n\t\treturn -ENOMEM;\n\t}\n\tret = tlmi_simple_call(LENOVO_CERT_TO_PASSWORD_GUID, auth_str);\n\tkfree(auth_str);\n\tkfree_sensitive(passwd);\n\n\treturn ret ?: count;\n}\n\nstatic struct kobj_attribute auth_cert_to_password = __ATTR_WO(cert_to_password);\n\nstatic ssize_t certificate_store(struct kobject *kobj,\n\t\t\t\t  struct kobj_attribute *attr,\n\t\t\t\t  const char *buf, size_t count)\n{\n\tstruct tlmi_pwd_setting *setting = to_tlmi_pwd_setting(kobj);\n\tchar *auth_str, *new_cert;\n\tchar *guid;\n\tint ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (!tlmi_priv.certificate_support)\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif ((buf[0] == '\\0') || (buf[0] == '\\n')) {  \n\t\t \n\t\tif (!setting->signature || !setting->signature[0])\n\t\t\treturn -EACCES;\n\n\t\t \n\t\tauth_str = kasprintf(GFP_KERNEL, \"%s,%s\",\n\t\t\t\tdmi_get_system_info(DMI_PRODUCT_SERIAL),\n\t\t\t\tsetting->signature);\n\t\tif (!auth_str)\n\t\t\treturn -ENOMEM;\n\n\t\tret = tlmi_simple_call(LENOVO_CLEAR_BIOS_CERT_GUID, auth_str);\n\t\tkfree(auth_str);\n\n\t\treturn ret ?: count;\n\t}\n\n\tnew_cert = kstrdup(buf, GFP_KERNEL);\n\tif (!new_cert)\n\t\treturn -ENOMEM;\n\t \n\tstrip_cr(new_cert);\n\n\tif (setting->cert_installed) {\n\t\t \n\t\tif (!setting->signature || !setting->signature[0]) {\n\t\t\tkfree(new_cert);\n\t\t\treturn -EACCES;\n\t\t}\n\t\tguid = LENOVO_UPDATE_BIOS_CERT_GUID;\n\t\t \n\t\tauth_str = kasprintf(GFP_KERNEL, \"%s,%s\",\n\t\t\t\tnew_cert, setting->signature);\n\t} else {\n\t\t \n\t\tif (!setting->valid || !setting->password[0]) {\n\t\t\tkfree(new_cert);\n\t\t\treturn -EACCES;\n\t\t}\n\t\tguid = LENOVO_SET_BIOS_CERT_GUID;\n\t\t \n\t\tauth_str = kasprintf(GFP_KERNEL, \"%s,%s\",\n\t\t\t\tnew_cert, setting->password);\n\t}\n\tkfree(new_cert);\n\tif (!auth_str)\n\t\treturn -ENOMEM;\n\n\tret = tlmi_simple_call(guid, auth_str);\n\tkfree(auth_str);\n\n\treturn ret ?: count;\n}\n\nstatic struct kobj_attribute auth_certificate = __ATTR_WO(certificate);\n\nstatic ssize_t signature_store(struct kobject *kobj,\n\t\t\t\t  struct kobj_attribute *attr,\n\t\t\t\t  const char *buf, size_t count)\n{\n\tstruct tlmi_pwd_setting *setting = to_tlmi_pwd_setting(kobj);\n\tchar *new_signature;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (!tlmi_priv.certificate_support)\n\t\treturn -EOPNOTSUPP;\n\n\tnew_signature = kstrdup(buf, GFP_KERNEL);\n\tif (!new_signature)\n\t\treturn -ENOMEM;\n\n\t \n\tstrip_cr(new_signature);\n\n\t \n\tkfree(setting->signature);\n\tsetting->signature = new_signature;\n\n\treturn count;\n}\n\nstatic struct kobj_attribute auth_signature = __ATTR_WO(signature);\n\nstatic ssize_t save_signature_store(struct kobject *kobj,\n\t\t\t\t  struct kobj_attribute *attr,\n\t\t\t\t  const char *buf, size_t count)\n{\n\tstruct tlmi_pwd_setting *setting = to_tlmi_pwd_setting(kobj);\n\tchar *new_signature;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (!tlmi_priv.certificate_support)\n\t\treturn -EOPNOTSUPP;\n\n\tnew_signature = kstrdup(buf, GFP_KERNEL);\n\tif (!new_signature)\n\t\treturn -ENOMEM;\n\n\t \n\tstrip_cr(new_signature);\n\n\t \n\tkfree(setting->save_signature);\n\tsetting->save_signature = new_signature;\n\n\treturn count;\n}\n\nstatic struct kobj_attribute auth_save_signature = __ATTR_WO(save_signature);\n\nstatic umode_t auth_attr_is_visible(struct kobject *kobj,\n\t\t\t\t\t     struct attribute *attr, int n)\n{\n\tstruct tlmi_pwd_setting *setting = to_tlmi_pwd_setting(kobj);\n\n\t \n\tif (attr == &auth_index.attr || attr == &auth_level.attr) {\n\t\tif ((setting == tlmi_priv.pwd_hdd) || (setting == tlmi_priv.pwd_nvme))\n\t\t\treturn attr->mode;\n\t\treturn 0;\n\t}\n\n\t \n\tif (attr == &auth_certificate.attr ||\n\t    attr == &auth_signature.attr ||\n\t    attr == &auth_save_signature.attr ||\n\t    attr == &auth_cert_thumb.attr ||\n\t    attr == &auth_cert_to_password.attr) {\n\t\tif ((setting == tlmi_priv.pwd_admin) && tlmi_priv.certificate_support)\n\t\t\treturn attr->mode;\n\t\treturn 0;\n\t}\n\n\t \n\tif ((attr == &auth_encoding.attr || attr == &auth_kbdlang.attr) &&\n\t    tlmi_priv.opcode_support)\n\t\treturn 0;\n\n\treturn attr->mode;\n}\n\nstatic struct attribute *auth_attrs[] = {\n\t&auth_is_pass_set.attr,\n\t&auth_min_pass_length.attr,\n\t&auth_max_pass_length.attr,\n\t&auth_current_password.attr,\n\t&auth_new_password.attr,\n\t&auth_role.attr,\n\t&auth_mechanism.attr,\n\t&auth_encoding.attr,\n\t&auth_kbdlang.attr,\n\t&auth_index.attr,\n\t&auth_level.attr,\n\t&auth_certificate.attr,\n\t&auth_signature.attr,\n\t&auth_save_signature.attr,\n\t&auth_cert_thumb.attr,\n\t&auth_cert_to_password.attr,\n\tNULL\n};\n\nstatic const struct attribute_group auth_attr_group = {\n\t.is_visible = auth_attr_is_visible,\n\t.attrs = auth_attrs,\n};\n\n \nstatic ssize_t display_name_show(struct kobject *kobj, struct kobj_attribute *attr,\n\t\tchar *buf)\n{\n\tstruct tlmi_attr_setting *setting = to_tlmi_attr_setting(kobj);\n\n\treturn sysfs_emit(buf, \"%s\\n\", setting->display_name);\n}\n\nstatic ssize_t current_value_show(struct kobject *kobj, struct kobj_attribute *attr, char *buf)\n{\n\tstruct tlmi_attr_setting *setting = to_tlmi_attr_setting(kobj);\n\tchar *item, *value, *p;\n\tint ret;\n\n\tret = tlmi_setting(setting->index, &item, LENOVO_BIOS_SETTING_GUID);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tvalue = strpbrk(item, \",\");\n\tif (!value || value == item || !strlen(value + 1))\n\t\tret = -EINVAL;\n\telse {\n\t\t \n\t\tp = strchrnul(value, ';');\n\t\t*p = '\\0';\n\t\tret = sysfs_emit(buf, \"%s\\n\", value + 1);\n\t}\n\tkfree(item);\n\n\treturn ret;\n}\n\nstatic ssize_t possible_values_show(struct kobject *kobj, struct kobj_attribute *attr, char *buf)\n{\n\tstruct tlmi_attr_setting *setting = to_tlmi_attr_setting(kobj);\n\n\treturn sysfs_emit(buf, \"%s\\n\", setting->possible_values);\n}\n\nstatic ssize_t type_show(struct kobject *kobj, struct kobj_attribute *attr,\n\t\tchar *buf)\n{\n\tstruct tlmi_attr_setting *setting = to_tlmi_attr_setting(kobj);\n\n\tif (setting->possible_values) {\n\t\t \n\t\tif (strchr(setting->possible_values, ';'))\n\t\t\treturn sysfs_emit(buf, \"enumeration\\n\");\n\t}\n\t \n\treturn sysfs_emit(buf, \"string\\n\");\n}\n\nstatic ssize_t current_value_store(struct kobject *kobj,\n\t\tstruct kobj_attribute *attr,\n\t\tconst char *buf, size_t count)\n{\n\tstruct tlmi_attr_setting *setting = to_tlmi_attr_setting(kobj);\n\tchar *set_str = NULL, *new_setting = NULL;\n\tchar *auth_str = NULL;\n\tint ret;\n\n\tif (!tlmi_priv.can_set_bios_settings)\n\t\treturn -EOPNOTSUPP;\n\n\tnew_setting = kstrdup(buf, GFP_KERNEL);\n\tif (!new_setting)\n\t\treturn -ENOMEM;\n\n\t \n\tstrip_cr(new_setting);\n\n\t \n\tmutex_lock(&tlmi_mutex);\n\n\t \n\tif (tlmi_priv.certificate_support && tlmi_priv.pwd_admin->cert_installed) {\n\t\tif (!tlmi_priv.pwd_admin->signature || !tlmi_priv.pwd_admin->save_signature) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tset_str = kasprintf(GFP_KERNEL, \"%s,%s,%s\", setting->display_name,\n\t\t\t\t\tnew_setting, tlmi_priv.pwd_admin->signature);\n\t\tif (!set_str) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = tlmi_simple_call(LENOVO_SET_BIOS_SETTING_CERT_GUID, set_str);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tret = tlmi_simple_call(LENOVO_SAVE_BIOS_SETTING_CERT_GUID,\n\t\t\t\ttlmi_priv.pwd_admin->save_signature);\n\t\tif (ret)\n\t\t\tgoto out;\n\t} else if (tlmi_priv.opcode_support) {\n\t\t \n\t\tset_str = kasprintf(GFP_KERNEL, \"%s,%s;\", setting->display_name,\n\t\t\t\t    new_setting);\n\t\tif (!set_str) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = tlmi_simple_call(LENOVO_SET_BIOS_SETTINGS_GUID, set_str);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tif (tlmi_priv.pwd_admin->valid && tlmi_priv.pwd_admin->password[0]) {\n\t\t\tret = tlmi_opcode_setting(\"WmiOpcodePasswordAdmin\",\n\t\t\t\t\t\t  tlmi_priv.pwd_admin->password);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\tret = tlmi_save_bios_settings(\"\");\n\t} else {  \n\t\tif (tlmi_priv.pwd_admin->valid && tlmi_priv.pwd_admin->password[0]) {\n\t\t\tauth_str = kasprintf(GFP_KERNEL, \"%s,%s,%s;\",\n\t\t\t\t\ttlmi_priv.pwd_admin->password,\n\t\t\t\t\tencoding_options[tlmi_priv.pwd_admin->encoding],\n\t\t\t\t\ttlmi_priv.pwd_admin->kbdlang);\n\t\t\tif (!auth_str) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tif (auth_str)\n\t\t\tset_str = kasprintf(GFP_KERNEL, \"%s,%s,%s\", setting->display_name,\n\t\t\t\t\tnew_setting, auth_str);\n\t\telse\n\t\t\tset_str = kasprintf(GFP_KERNEL, \"%s,%s;\", setting->display_name,\n\t\t\t\t\tnew_setting);\n\t\tif (!set_str) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = tlmi_simple_call(LENOVO_SET_BIOS_SETTINGS_GUID, set_str);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tif (auth_str)\n\t\t\tret = tlmi_save_bios_settings(auth_str);\n\t\telse\n\t\t\tret = tlmi_save_bios_settings(\"\");\n\t}\n\tif (!ret && !tlmi_priv.pending_changes) {\n\t\ttlmi_priv.pending_changes = true;\n\t\t \n\t\tkobject_uevent(&tlmi_priv.class_dev->kobj, KOBJ_CHANGE);\n\t}\nout:\n\tmutex_unlock(&tlmi_mutex);\n\tkfree(auth_str);\n\tkfree(set_str);\n\tkfree(new_setting);\n\treturn ret ?: count;\n}\n\nstatic struct kobj_attribute attr_displ_name = __ATTR_RO(display_name);\n\nstatic struct kobj_attribute attr_possible_values = __ATTR_RO(possible_values);\n\nstatic struct kobj_attribute attr_current_val = __ATTR_RW_MODE(current_value, 0600);\n\nstatic struct kobj_attribute attr_type = __ATTR_RO(type);\n\nstatic umode_t attr_is_visible(struct kobject *kobj,\n\t\t\t\t\t     struct attribute *attr, int n)\n{\n\tstruct tlmi_attr_setting *setting = to_tlmi_attr_setting(kobj);\n\n\t \n\tif ((attr == &attr_possible_values.attr) && (!setting->possible_values))\n\t\treturn 0;\n\n\treturn attr->mode;\n}\n\nstatic struct attribute *tlmi_attrs[] = {\n\t&attr_displ_name.attr,\n\t&attr_current_val.attr,\n\t&attr_possible_values.attr,\n\t&attr_type.attr,\n\tNULL\n};\n\nstatic const struct attribute_group tlmi_attr_group = {\n\t.is_visible = attr_is_visible,\n\t.attrs = tlmi_attrs,\n};\n\nstatic void tlmi_attr_setting_release(struct kobject *kobj)\n{\n\tstruct tlmi_attr_setting *setting = to_tlmi_attr_setting(kobj);\n\n\tkfree(setting->possible_values);\n\tkfree(setting);\n}\n\nstatic void tlmi_pwd_setting_release(struct kobject *kobj)\n{\n\tstruct tlmi_pwd_setting *setting = to_tlmi_pwd_setting(kobj);\n\n\tkfree(setting);\n}\n\nstatic const struct kobj_type tlmi_attr_setting_ktype = {\n\t.release        = &tlmi_attr_setting_release,\n\t.sysfs_ops\t= &kobj_sysfs_ops,\n};\n\nstatic const struct kobj_type tlmi_pwd_setting_ktype = {\n\t.release        = &tlmi_pwd_setting_release,\n\t.sysfs_ops\t= &kobj_sysfs_ops,\n};\n\nstatic ssize_t pending_reboot_show(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t\t   char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", tlmi_priv.pending_changes);\n}\n\nstatic struct kobj_attribute pending_reboot = __ATTR_RO(pending_reboot);\n\n \nstatic ssize_t debug_cmd_store(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t\tconst char *buf, size_t count)\n{\n\tchar *set_str = NULL, *new_setting = NULL;\n\tchar *auth_str = NULL;\n\tint ret;\n\n\tif (!tlmi_priv.can_debug_cmd)\n\t\treturn -EOPNOTSUPP;\n\n\tnew_setting = kstrdup(buf, GFP_KERNEL);\n\tif (!new_setting)\n\t\treturn -ENOMEM;\n\n\t \n\tstrip_cr(new_setting);\n\n\tif (tlmi_priv.pwd_admin->valid && tlmi_priv.pwd_admin->password[0]) {\n\t\tauth_str = kasprintf(GFP_KERNEL, \"%s,%s,%s;\",\n\t\t\t\ttlmi_priv.pwd_admin->password,\n\t\t\t\tencoding_options[tlmi_priv.pwd_admin->encoding],\n\t\t\t\ttlmi_priv.pwd_admin->kbdlang);\n\t\tif (!auth_str) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (auth_str)\n\t\tset_str = kasprintf(GFP_KERNEL, \"%s,%s\", new_setting, auth_str);\n\telse\n\t\tset_str = kasprintf(GFP_KERNEL, \"%s;\", new_setting);\n\tif (!set_str) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tret = tlmi_simple_call(LENOVO_DEBUG_CMD_GUID, set_str);\n\tif (ret)\n\t\tgoto out;\n\n\tif (!ret && !tlmi_priv.pending_changes) {\n\t\ttlmi_priv.pending_changes = true;\n\t\t \n\t\tkobject_uevent(&tlmi_priv.class_dev->kobj, KOBJ_CHANGE);\n\t}\nout:\n\tkfree(auth_str);\n\tkfree(set_str);\n\tkfree(new_setting);\n\treturn ret ?: count;\n}\n\nstatic struct kobj_attribute debug_cmd = __ATTR_WO(debug_cmd);\n\n \nstatic void tlmi_release_attr(void)\n{\n\tint i;\n\n\t \n\tfor (i = 0; i < TLMI_SETTINGS_COUNT; i++) {\n\t\tif (tlmi_priv.setting[i]) {\n\t\t\tsysfs_remove_group(&tlmi_priv.setting[i]->kobj, &tlmi_attr_group);\n\t\t\tkobject_put(&tlmi_priv.setting[i]->kobj);\n\t\t}\n\t}\n\tsysfs_remove_file(&tlmi_priv.attribute_kset->kobj, &pending_reboot.attr);\n\tif (tlmi_priv.can_debug_cmd && debug_support)\n\t\tsysfs_remove_file(&tlmi_priv.attribute_kset->kobj, &debug_cmd.attr);\n\n\tkset_unregister(tlmi_priv.attribute_kset);\n\n\t \n\tkfree(tlmi_priv.pwd_admin->signature);\n\tkfree(tlmi_priv.pwd_admin->save_signature);\n\n\t \n\tsysfs_remove_group(&tlmi_priv.pwd_admin->kobj, &auth_attr_group);\n\tkobject_put(&tlmi_priv.pwd_admin->kobj);\n\tsysfs_remove_group(&tlmi_priv.pwd_power->kobj, &auth_attr_group);\n\tkobject_put(&tlmi_priv.pwd_power->kobj);\n\n\tif (tlmi_priv.opcode_support) {\n\t\tsysfs_remove_group(&tlmi_priv.pwd_system->kobj, &auth_attr_group);\n\t\tkobject_put(&tlmi_priv.pwd_system->kobj);\n\t\tsysfs_remove_group(&tlmi_priv.pwd_hdd->kobj, &auth_attr_group);\n\t\tkobject_put(&tlmi_priv.pwd_hdd->kobj);\n\t\tsysfs_remove_group(&tlmi_priv.pwd_nvme->kobj, &auth_attr_group);\n\t\tkobject_put(&tlmi_priv.pwd_nvme->kobj);\n\t}\n\n\tkset_unregister(tlmi_priv.authentication_kset);\n}\n\nstatic int tlmi_validate_setting_name(struct kset *attribute_kset, char *name)\n{\n\tstruct kobject *duplicate;\n\n\tif (!strcmp(name, \"Reserved\"))\n\t\treturn -EINVAL;\n\n\tduplicate = kset_find_obj(attribute_kset, name);\n\tif (duplicate) {\n\t\tpr_debug(\"Duplicate attribute name found - %s\\n\", name);\n\t\t \n\t\tkobject_put(duplicate);\n\t\treturn -EBUSY;\n\t}\n\n\treturn 0;\n}\n\nstatic int tlmi_sysfs_init(void)\n{\n\tint i, ret;\n\n\tret = fw_attributes_class_get(&fw_attr_class);\n\tif (ret)\n\t\treturn ret;\n\n\ttlmi_priv.class_dev = device_create(fw_attr_class, NULL, MKDEV(0, 0),\n\t\t\tNULL, \"%s\", \"thinklmi\");\n\tif (IS_ERR(tlmi_priv.class_dev)) {\n\t\tret = PTR_ERR(tlmi_priv.class_dev);\n\t\tgoto fail_class_created;\n\t}\n\n\ttlmi_priv.attribute_kset = kset_create_and_add(\"attributes\", NULL,\n\t\t\t&tlmi_priv.class_dev->kobj);\n\tif (!tlmi_priv.attribute_kset) {\n\t\tret = -ENOMEM;\n\t\tgoto fail_device_created;\n\t}\n\n\tfor (i = 0; i < TLMI_SETTINGS_COUNT; i++) {\n\t\t \n\t\tif (!tlmi_priv.setting[i])\n\t\t\tcontinue;\n\n\t\t \n\t\tif (tlmi_validate_setting_name(tlmi_priv.attribute_kset,\n\t\t\t\t\t       tlmi_priv.setting[i]->display_name) < 0) {\n\t\t\tkfree(tlmi_priv.setting[i]->possible_values);\n\t\t\tkfree(tlmi_priv.setting[i]);\n\t\t\ttlmi_priv.setting[i] = NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\ttlmi_priv.setting[i]->kobj.kset = tlmi_priv.attribute_kset;\n\t\tret = kobject_add(&tlmi_priv.setting[i]->kobj, NULL,\n\t\t\t\t  \"%s\", tlmi_priv.setting[i]->display_name);\n\t\tif (ret)\n\t\t\tgoto fail_create_attr;\n\n\t\tret = sysfs_create_group(&tlmi_priv.setting[i]->kobj, &tlmi_attr_group);\n\t\tif (ret)\n\t\t\tgoto fail_create_attr;\n\t}\n\n\tret = sysfs_create_file(&tlmi_priv.attribute_kset->kobj, &pending_reboot.attr);\n\tif (ret)\n\t\tgoto fail_create_attr;\n\n\tif (tlmi_priv.can_debug_cmd && debug_support) {\n\t\tret = sysfs_create_file(&tlmi_priv.attribute_kset->kobj, &debug_cmd.attr);\n\t\tif (ret)\n\t\t\tgoto fail_create_attr;\n\t}\n\n\t \n\ttlmi_priv.authentication_kset = kset_create_and_add(\"authentication\", NULL,\n\t\t\t\t\t\t\t\t&tlmi_priv.class_dev->kobj);\n\tif (!tlmi_priv.authentication_kset) {\n\t\tret = -ENOMEM;\n\t\tgoto fail_create_attr;\n\t}\n\ttlmi_priv.pwd_admin->kobj.kset = tlmi_priv.authentication_kset;\n\tret = kobject_add(&tlmi_priv.pwd_admin->kobj, NULL, \"%s\", \"Admin\");\n\tif (ret)\n\t\tgoto fail_create_attr;\n\n\tret = sysfs_create_group(&tlmi_priv.pwd_admin->kobj, &auth_attr_group);\n\tif (ret)\n\t\tgoto fail_create_attr;\n\n\ttlmi_priv.pwd_power->kobj.kset = tlmi_priv.authentication_kset;\n\tret = kobject_add(&tlmi_priv.pwd_power->kobj, NULL, \"%s\", \"Power-on\");\n\tif (ret)\n\t\tgoto fail_create_attr;\n\n\tret = sysfs_create_group(&tlmi_priv.pwd_power->kobj, &auth_attr_group);\n\tif (ret)\n\t\tgoto fail_create_attr;\n\n\tif (tlmi_priv.opcode_support) {\n\t\ttlmi_priv.pwd_system->kobj.kset = tlmi_priv.authentication_kset;\n\t\tret = kobject_add(&tlmi_priv.pwd_system->kobj, NULL, \"%s\", \"System\");\n\t\tif (ret)\n\t\t\tgoto fail_create_attr;\n\n\t\tret = sysfs_create_group(&tlmi_priv.pwd_system->kobj, &auth_attr_group);\n\t\tif (ret)\n\t\t\tgoto fail_create_attr;\n\n\t\ttlmi_priv.pwd_hdd->kobj.kset = tlmi_priv.authentication_kset;\n\t\tret = kobject_add(&tlmi_priv.pwd_hdd->kobj, NULL, \"%s\", \"HDD\");\n\t\tif (ret)\n\t\t\tgoto fail_create_attr;\n\n\t\tret = sysfs_create_group(&tlmi_priv.pwd_hdd->kobj, &auth_attr_group);\n\t\tif (ret)\n\t\t\tgoto fail_create_attr;\n\n\t\ttlmi_priv.pwd_nvme->kobj.kset = tlmi_priv.authentication_kset;\n\t\tret = kobject_add(&tlmi_priv.pwd_nvme->kobj, NULL, \"%s\", \"NVMe\");\n\t\tif (ret)\n\t\t\tgoto fail_create_attr;\n\n\t\tret = sysfs_create_group(&tlmi_priv.pwd_nvme->kobj, &auth_attr_group);\n\t\tif (ret)\n\t\t\tgoto fail_create_attr;\n\t}\n\n\treturn ret;\n\nfail_create_attr:\n\ttlmi_release_attr();\nfail_device_created:\n\tdevice_destroy(fw_attr_class, MKDEV(0, 0));\nfail_class_created:\n\tfw_attributes_class_put();\n\treturn ret;\n}\n\n \nstatic struct tlmi_pwd_setting *tlmi_create_auth(const char *pwd_type,\n\t\t\t    const char *pwd_role)\n{\n\tstruct tlmi_pwd_setting *new_pwd;\n\n\tnew_pwd = kzalloc(sizeof(struct tlmi_pwd_setting), GFP_KERNEL);\n\tif (!new_pwd)\n\t\treturn NULL;\n\n\tstrscpy(new_pwd->kbdlang, \"us\", TLMI_LANG_MAXLEN);\n\tnew_pwd->encoding = TLMI_ENCODING_ASCII;\n\tnew_pwd->pwd_type = pwd_type;\n\tnew_pwd->role = pwd_role;\n\tnew_pwd->minlen = tlmi_priv.pwdcfg.core.min_length;\n\tnew_pwd->maxlen = tlmi_priv.pwdcfg.core.max_length;\n\tnew_pwd->index = 0;\n\n\tkobject_init(&new_pwd->kobj, &tlmi_pwd_setting_ktype);\n\n\treturn new_pwd;\n}\n\nstatic int tlmi_analyze(void)\n{\n\tint i, ret;\n\n\tif (wmi_has_guid(LENOVO_SET_BIOS_SETTINGS_GUID) &&\n\t    wmi_has_guid(LENOVO_SAVE_BIOS_SETTINGS_GUID))\n\t\ttlmi_priv.can_set_bios_settings = true;\n\n\tif (wmi_has_guid(LENOVO_GET_BIOS_SELECTIONS_GUID))\n\t\ttlmi_priv.can_get_bios_selections = true;\n\n\tif (wmi_has_guid(LENOVO_SET_BIOS_PASSWORD_GUID))\n\t\ttlmi_priv.can_set_bios_password = true;\n\n\tif (wmi_has_guid(LENOVO_BIOS_PASSWORD_SETTINGS_GUID))\n\t\ttlmi_priv.can_get_password_settings = true;\n\n\tif (wmi_has_guid(LENOVO_DEBUG_CMD_GUID))\n\t\ttlmi_priv.can_debug_cmd = true;\n\n\tif (wmi_has_guid(LENOVO_OPCODE_IF_GUID))\n\t\ttlmi_priv.opcode_support = true;\n\n\tif (wmi_has_guid(LENOVO_SET_BIOS_CERT_GUID) &&\n\t\twmi_has_guid(LENOVO_SET_BIOS_SETTING_CERT_GUID) &&\n\t\twmi_has_guid(LENOVO_SAVE_BIOS_SETTING_CERT_GUID))\n\t\ttlmi_priv.certificate_support = true;\n\n\t \n\tfor (i = 0; i < TLMI_SETTINGS_COUNT; ++i) {\n\t\tstruct tlmi_attr_setting *setting;\n\t\tchar *item = NULL;\n\t\tchar *p;\n\n\t\ttlmi_priv.setting[i] = NULL;\n\t\tret = tlmi_setting(i, &item, LENOVO_BIOS_SETTING_GUID);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tif (!item)\n\t\t\tbreak;\n\t\tif (!*item) {\n\t\t\tkfree(item);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tstrreplace(item, '/', '\\\\');\n\n\t\t \n\t\tp = strchrnul(item, ',');\n\t\t*p = '\\0';\n\n\t\t \n\t\tsetting = kzalloc(sizeof(*setting), GFP_KERNEL);\n\t\tif (!setting) {\n\t\t\tret = -ENOMEM;\n\t\t\tkfree(item);\n\t\t\tgoto fail_clear_attr;\n\t\t}\n\t\tsetting->index = i;\n\t\tstrscpy(setting->display_name, item, TLMI_SETTINGS_MAXLEN);\n\t\t \n\t\tif (tlmi_priv.can_get_bios_selections) {\n\t\t\tret = tlmi_get_bios_selections(setting->display_name,\n\t\t\t\t\t&setting->possible_values);\n\t\t\tif (ret || !setting->possible_values)\n\t\t\t\tpr_info(\"Error retrieving possible values for %d : %s\\n\",\n\t\t\t\t\t\ti, setting->display_name);\n\t\t} else {\n\t\t\t \n\t\t\tchar *optitem, *optstart, *optend;\n\n\t\t\tif (!tlmi_setting(setting->index, &optitem, LENOVO_BIOS_SETTING_GUID)) {\n\t\t\t\toptstart = strstr(optitem, \"[Optional:\");\n\t\t\t\tif (optstart) {\n\t\t\t\t\toptstart += strlen(\"[Optional:\");\n\t\t\t\t\toptend = strstr(optstart, \"]\");\n\t\t\t\t\tif (optend)\n\t\t\t\t\t\tsetting->possible_values =\n\t\t\t\t\t\t\tkstrndup(optstart, optend - optstart,\n\t\t\t\t\t\t\t\t\tGFP_KERNEL);\n\t\t\t\t}\n\t\t\t\tkfree(optitem);\n\t\t\t}\n\t\t}\n\t\t \n\t\tif (setting->possible_values)\n\t\t\tstrreplace(setting->possible_values, ',', ';');\n\n\t\tkobject_init(&setting->kobj, &tlmi_attr_setting_ktype);\n\t\ttlmi_priv.setting[i] = setting;\n\t\tkfree(item);\n\t}\n\n\t \n\tret = tlmi_get_pwd_settings(&tlmi_priv.pwdcfg);\n\tif (ret)\n\t\tgoto fail_clear_attr;\n\n\t \n\tret = -ENOMEM;\n\n\ttlmi_priv.pwd_admin = tlmi_create_auth(\"pap\", \"bios-admin\");\n\tif (!tlmi_priv.pwd_admin)\n\t\tgoto fail_clear_attr;\n\n\tif (tlmi_priv.pwdcfg.core.password_state & TLMI_PAP_PWD)\n\t\ttlmi_priv.pwd_admin->valid = true;\n\n\ttlmi_priv.pwd_power = tlmi_create_auth(\"pop\", \"power-on\");\n\tif (!tlmi_priv.pwd_power)\n\t\tgoto fail_clear_attr;\n\n\tif (tlmi_priv.pwdcfg.core.password_state & TLMI_POP_PWD)\n\t\ttlmi_priv.pwd_power->valid = true;\n\n\tif (tlmi_priv.opcode_support) {\n\t\ttlmi_priv.pwd_system = tlmi_create_auth(\"smp\", \"system\");\n\t\tif (!tlmi_priv.pwd_system)\n\t\t\tgoto fail_clear_attr;\n\n\t\tif (tlmi_priv.pwdcfg.core.password_state & TLMI_SMP_PWD)\n\t\t\ttlmi_priv.pwd_system->valid = true;\n\n\t\ttlmi_priv.pwd_hdd = tlmi_create_auth(\"hdd\", \"hdd\");\n\t\tif (!tlmi_priv.pwd_hdd)\n\t\t\tgoto fail_clear_attr;\n\n\t\ttlmi_priv.pwd_nvme = tlmi_create_auth(\"nvm\", \"nvme\");\n\t\tif (!tlmi_priv.pwd_nvme)\n\t\t\tgoto fail_clear_attr;\n\n\t\t \n\t\ttlmi_priv.pwd_hdd->index = 1;\n\t\ttlmi_priv.pwd_nvme->index = 1;\n\n\t\tif (tlmi_priv.pwdcfg.core.password_state & TLMI_HDD_PWD) {\n\t\t\t \n\t\t\tif (tlmi_priv.pwdcfg.ext.hdd_user_password ||\n\t\t\t\t\ttlmi_priv.pwdcfg.ext.hdd_master_password) {\n\t\t\t\ttlmi_priv.pwd_hdd->valid = true;\n\t\t\t\tif (tlmi_priv.pwdcfg.ext.hdd_master_password)\n\t\t\t\t\ttlmi_priv.pwd_hdd->index =\n\t\t\t\t\t\tffs(tlmi_priv.pwdcfg.ext.hdd_master_password) - 1;\n\t\t\t\telse\n\t\t\t\t\ttlmi_priv.pwd_hdd->index =\n\t\t\t\t\t\tffs(tlmi_priv.pwdcfg.ext.hdd_user_password) - 1;\n\t\t\t}\n\t\t\tif (tlmi_priv.pwdcfg.ext.nvme_user_password ||\n\t\t\t\t\ttlmi_priv.pwdcfg.ext.nvme_master_password) {\n\t\t\t\ttlmi_priv.pwd_nvme->valid = true;\n\t\t\t\tif (tlmi_priv.pwdcfg.ext.nvme_master_password)\n\t\t\t\t\ttlmi_priv.pwd_nvme->index =\n\t\t\t\t\t\tffs(tlmi_priv.pwdcfg.ext.nvme_master_password) - 1;\n\t\t\t\telse\n\t\t\t\t\ttlmi_priv.pwd_nvme->index =\n\t\t\t\t\t\tffs(tlmi_priv.pwdcfg.ext.nvme_user_password) - 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (tlmi_priv.certificate_support &&\n\t\t(tlmi_priv.pwdcfg.core.password_state & TLMI_CERT))\n\t\ttlmi_priv.pwd_admin->cert_installed = true;\n\n\treturn 0;\n\nfail_clear_attr:\n\tfor (i = 0; i < TLMI_SETTINGS_COUNT; ++i) {\n\t\tif (tlmi_priv.setting[i]) {\n\t\t\tkfree(tlmi_priv.setting[i]->possible_values);\n\t\t\tkfree(tlmi_priv.setting[i]);\n\t\t}\n\t}\n\tkfree(tlmi_priv.pwd_admin);\n\tkfree(tlmi_priv.pwd_power);\n\tkfree(tlmi_priv.pwd_system);\n\tkfree(tlmi_priv.pwd_hdd);\n\tkfree(tlmi_priv.pwd_nvme);\n\treturn ret;\n}\n\nstatic void tlmi_remove(struct wmi_device *wdev)\n{\n\ttlmi_release_attr();\n\tdevice_destroy(fw_attr_class, MKDEV(0, 0));\n\tfw_attributes_class_put();\n}\n\nstatic int tlmi_probe(struct wmi_device *wdev, const void *context)\n{\n\tint ret;\n\n\tret = tlmi_analyze();\n\tif (ret)\n\t\treturn ret;\n\n\treturn tlmi_sysfs_init();\n}\n\nstatic const struct wmi_device_id tlmi_id_table[] = {\n\t{ .guid_string = LENOVO_BIOS_SETTING_GUID },\n\t{ }\n};\nMODULE_DEVICE_TABLE(wmi, tlmi_id_table);\n\nstatic struct wmi_driver tlmi_driver = {\n\t.driver = {\n\t\t.name = \"think-lmi\",\n\t},\n\t.id_table = tlmi_id_table,\n\t.probe = tlmi_probe,\n\t.remove = tlmi_remove,\n};\n\nMODULE_AUTHOR(\"Sugumaran L <slacshiminar@lenovo.com>\");\nMODULE_AUTHOR(\"Mark Pearson <markpearson@lenovo.com>\");\nMODULE_AUTHOR(\"Corentin Chary <corentin.chary@gmail.com>\");\nMODULE_DESCRIPTION(\"ThinkLMI Driver\");\nMODULE_LICENSE(\"GPL\");\n\nmodule_wmi_driver(tlmi_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}