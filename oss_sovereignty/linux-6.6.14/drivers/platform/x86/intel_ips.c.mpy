{
  "module_name": "intel_ips.c",
  "hash_id": "8a445d25c5b2c367195578195864d1d9f39ba61468f6936f7f7054c0508119ce",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/x86/intel_ips.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/sched.h>\n#include <linux/sched/loadavg.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/tick.h>\n#include <linux/timer.h>\n#include <linux/dmi.h>\n#include <drm/i915_drm.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include \"intel_ips.h\"\n\n#include <linux/io-64-nonatomic-lo-hi.h>\n\n#define PCI_DEVICE_ID_INTEL_THERMAL_SENSOR 0x3b32\n\n \n#define PLATFORM_INFO\t0xce\n#define   PLATFORM_TDP\t\t(1<<29)\n#define   PLATFORM_RATIO\t(1<<28)\n\n#define IA32_MISC_ENABLE\t0x1a0\n#define   IA32_MISC_TURBO_EN\t(1ULL<<38)\n\n#define TURBO_POWER_CURRENT_LIMIT\t0x1ac\n#define   TURBO_TDC_OVR_EN\t(1UL<<31)\n#define   TURBO_TDC_MASK\t(0x000000007fff0000UL)\n#define   TURBO_TDC_SHIFT\t(16)\n#define   TURBO_TDP_OVR_EN\t(1UL<<15)\n#define   TURBO_TDP_MASK\t(0x0000000000003fffUL)\n\n \n#define IA32_PERF_CTL\t\t0x199\n#define   IA32_PERF_TURBO_DIS\t(1ULL<<32)\n\n \n#define THM_CFG_TBAR\t0x10\n#define THM_CFG_TBAR_HI\t0x14\n\n#define THM_TSIU\t0x00\n#define THM_TSE\t\t0x01\n#define   TSE_EN\t0xb8\n#define THM_TSS\t\t0x02\n#define THM_TSTR\t0x03\n#define THM_TSTTP\t0x04\n#define THM_TSCO\t0x08\n#define THM_TSES\t0x0c\n#define THM_TSGPEN\t0x0d\n#define   TSGPEN_HOT_LOHI\t(1<<1)\n#define   TSGPEN_CRIT_LOHI\t(1<<2)\n#define THM_TSPC\t0x0e\n#define THM_PPEC\t0x10\n#define THM_CTA\t\t0x12\n#define THM_PTA\t\t0x14\n#define   PTA_SLOPE_MASK\t(0xff00)\n#define   PTA_SLOPE_SHIFT\t8\n#define   PTA_OFFSET_MASK\t(0x00ff)\n#define THM_MGTA\t0x16\n#define   MGTA_SLOPE_MASK\t(0xff00)\n#define   MGTA_SLOPE_SHIFT\t8\n#define   MGTA_OFFSET_MASK\t(0x00ff)\n#define THM_TRC\t\t0x1a\n#define   TRC_CORE2_EN\t(1<<15)\n#define   TRC_THM_EN\t(1<<12)\n#define   TRC_C6_WAR\t(1<<8)\n#define   TRC_CORE1_EN\t(1<<7)\n#define   TRC_CORE_PWR\t(1<<6)\n#define   TRC_PCH_EN\t(1<<5)\n#define   TRC_MCH_EN\t(1<<4)\n#define   TRC_DIMM4\t(1<<3)\n#define   TRC_DIMM3\t(1<<2)\n#define   TRC_DIMM2\t(1<<1)\n#define   TRC_DIMM1\t(1<<0)\n#define THM_TES\t\t0x20\n#define THM_TEN\t\t0x21\n#define   TEN_UPDATE_EN\t1\n#define THM_PSC\t\t0x24\n#define   PSC_NTG\t(1<<0)  \n#define   PSC_NTPC\t(1<<1)  \n#define   PSC_PP_DEF\t(0<<2)  \n#define   PSP_PP_PC\t(1<<2)  \n#define   PSP_PP_BAL\t(2<<2)  \n#define   PSP_PP_GFX\t(3<<2)  \n#define   PSP_PBRT\t(1<<4)  \n#define THM_CTV1\t0x30\n#define   CTV_TEMP_ERROR (1<<15)\n#define   CTV_TEMP_MASK\t0x3f\n#define   CTV_\n#define THM_CTV2\t0x32\n#define THM_CEC\t\t0x34  \n#define THM_AE\t\t0x3f\n#define THM_HTS\t\t0x50  \n#define   HTS_PCPL_MASK\t(0x7fe00000)\n#define   HTS_PCPL_SHIFT 21\n#define   HTS_GPL_MASK  (0x001ff000)\n#define   HTS_GPL_SHIFT 12\n#define   HTS_PP_MASK\t(0x00000c00)\n#define   HTS_PP_SHIFT  10\n#define   HTS_PP_DEF\t0\n#define   HTS_PP_PROC\t1\n#define   HTS_PP_BAL\t2\n#define   HTS_PP_GFX\t3\n#define   HTS_PCTD_DIS\t(1<<9)\n#define   HTS_GTD_DIS\t(1<<8)\n#define   HTS_PTL_MASK  (0x000000fe)\n#define   HTS_PTL_SHIFT 1\n#define   HTS_NVV\t(1<<0)\n#define THM_HTSHI\t0x54  \n#define   HTS2_PPL_MASK\t\t(0x03ff)\n#define   HTS2_PRST_MASK\t(0x3c00)\n#define   HTS2_PRST_SHIFT\t10\n#define   HTS2_PRST_UNLOADED\t0\n#define   HTS2_PRST_RUNNING\t1\n#define   HTS2_PRST_TDISOP\t2  \n#define   HTS2_PRST_TDISHT\t3  \n#define   HTS2_PRST_TDISUSR\t4  \n#define   HTS2_PRST_TDISPLAT\t5  \n#define   HTS2_PRST_TDISPM\t6  \n#define   HTS2_PRST_TDISERR\t7  \n#define THM_PTL\t\t0x56\n#define THM_MGTV\t0x58\n#define   TV_MASK\t0x000000000000ff00\n#define   TV_SHIFT\t8\n#define THM_PTV\t\t0x60\n#define   PTV_MASK\t0x00ff\n#define THM_MMGPC\t0x64\n#define THM_MPPC\t0x66\n#define THM_MPCPC\t0x68\n#define THM_TSPIEN\t0x82\n#define   TSPIEN_AUX_LOHI\t(1<<0)\n#define   TSPIEN_HOT_LOHI\t(1<<1)\n#define   TSPIEN_CRIT_LOHI\t(1<<2)\n#define   TSPIEN_AUX2_LOHI\t(1<<3)\n#define THM_TSLOCK\t0x83\n#define THM_ATR\t\t0x84\n#define THM_TOF\t\t0x87\n#define THM_STS\t\t0x98\n#define   STS_PCPL_MASK\t\t(0x7fe00000)\n#define   STS_PCPL_SHIFT\t21\n#define   STS_GPL_MASK\t\t(0x001ff000)\n#define   STS_GPL_SHIFT\t\t12\n#define   STS_PP_MASK\t\t(0x00000c00)\n#define   STS_PP_SHIFT\t\t10\n#define   STS_PP_DEF\t\t0\n#define   STS_PP_PROC\t\t1\n#define   STS_PP_BAL\t\t2\n#define   STS_PP_GFX\t\t3\n#define   STS_PCTD_DIS\t\t(1<<9)\n#define   STS_GTD_DIS\t\t(1<<8)\n#define   STS_PTL_MASK\t\t(0x000000fe)\n#define   STS_PTL_SHIFT\t\t1\n#define   STS_NVV\t\t(1<<0)\n#define THM_SEC\t\t0x9c\n#define   SEC_ACK\t(1<<0)\n#define THM_TC3\t\t0xa4\n#define THM_TC1\t\t0xa8\n#define   STS_PPL_MASK\t\t(0x0003ff00)\n#define   STS_PPL_SHIFT\t\t16\n#define THM_TC2\t\t0xac\n#define THM_DTV\t\t0xb0\n#define THM_ITV\t\t0xd8\n#define   ITV_ME_SEQNO_MASK 0x00ff0000  \n#define   ITV_ME_SEQNO_SHIFT (16)\n#define   ITV_MCH_TEMP_MASK 0x0000ff00\n#define   ITV_MCH_TEMP_SHIFT (8)\n#define   ITV_PCH_TEMP_MASK 0x000000ff\n\n#define thm_readb(off) readb(ips->regmap + (off))\n#define thm_readw(off) readw(ips->regmap + (off))\n#define thm_readl(off) readl(ips->regmap + (off))\n#define thm_readq(off) readq(ips->regmap + (off))\n\n#define thm_writeb(off, val) writeb((val), ips->regmap + (off))\n#define thm_writew(off, val) writew((val), ips->regmap + (off))\n#define thm_writel(off, val) writel((val), ips->regmap + (off))\n\nstatic const int IPS_ADJUST_PERIOD = 5000;  \nstatic bool late_i915_load = false;\n\n \nstatic const int IPS_SAMPLE_PERIOD = 200;  \nstatic const int IPS_SAMPLE_WINDOW = 5000;  \n#define IPS_SAMPLE_COUNT (IPS_SAMPLE_WINDOW / IPS_SAMPLE_PERIOD)\n\n \nstruct ips_mcp_limits {\n\tint mcp_power_limit;  \n\tint core_power_limit;\n\tint mch_power_limit;\n\tint core_temp_limit;  \n\tint mch_temp_limit;\n};\n\n \n\nstatic struct ips_mcp_limits ips_sv_limits = {\n\t.mcp_power_limit = 35000,\n\t.core_power_limit = 29000,\n\t.mch_power_limit = 20000,\n\t.core_temp_limit = 95,\n\t.mch_temp_limit = 90\n};\n\nstatic struct ips_mcp_limits ips_lv_limits = {\n\t.mcp_power_limit = 25000,\n\t.core_power_limit = 21000,\n\t.mch_power_limit = 13000,\n\t.core_temp_limit = 95,\n\t.mch_temp_limit = 90\n};\n\nstatic struct ips_mcp_limits ips_ulv_limits = {\n\t.mcp_power_limit = 18000,\n\t.core_power_limit = 14000,\n\t.mch_power_limit = 11000,\n\t.core_temp_limit = 95,\n\t.mch_temp_limit = 90\n};\n\nstruct ips_driver {\n\tstruct device *dev;\n\tvoid __iomem *regmap;\n\tint irq;\n\n\tstruct task_struct *monitor;\n\tstruct task_struct *adjust;\n\tstruct dentry *debug_root;\n\tstruct timer_list timer;\n\n\t \n\tu16 ctv1_avg_temp;\n\tu16 ctv2_avg_temp;\n\t \n\tu16 mch_avg_temp;\n\t \n\tu16 mcp_avg_temp;\n\t \n\tu32 cpu_avg_power;\n\tu32 mch_avg_power;\n\n\t \n\tu16 cta_val;\n\tu16 pta_val;\n\tu16 mgta_val;\n\n\t \n\tspinlock_t turbo_status_lock;\n\tu16 mcp_temp_limit;\n\tu16 mcp_power_limit;\n\tu16 core_power_limit;\n\tu16 mch_power_limit;\n\tbool cpu_turbo_enabled;\n\tbool __cpu_turbo_on;\n\tbool gpu_turbo_enabled;\n\tbool __gpu_turbo_on;\n\tbool gpu_preferred;\n\tbool poll_turbo_status;\n\tbool second_cpu;\n\tbool turbo_toggle_allowed;\n\tstruct ips_mcp_limits *limits;\n\n\t \n\tunsigned long (*read_mch_val)(void);\n\tbool (*gpu_raise)(void);\n\tbool (*gpu_lower)(void);\n\tbool (*gpu_busy)(void);\n\tbool (*gpu_turbo_disable)(void);\n\n\t \n\tu64 orig_turbo_limit;\n\tu64 orig_turbo_ratios;\n};\n\nstatic bool\nips_gpu_turbo_enabled(struct ips_driver *ips);\n\n \nstatic bool ips_cpu_busy(struct ips_driver *ips)\n{\n\tif ((avenrun[0] >> FSHIFT) > 1)\n\t\treturn true;\n\n\treturn false;\n}\n\n \nstatic void ips_cpu_raise(struct ips_driver *ips)\n{\n\tu64 turbo_override;\n\tu16 cur_tdp_limit, new_tdp_limit;\n\n\tif (!ips->cpu_turbo_enabled)\n\t\treturn;\n\n\trdmsrl(TURBO_POWER_CURRENT_LIMIT, turbo_override);\n\n\tcur_tdp_limit = turbo_override & TURBO_TDP_MASK;\n\tnew_tdp_limit = cur_tdp_limit + 8;  \n\n\t \n\tif (((new_tdp_limit * 10) / 8) > ips->core_power_limit)\n\t\tnew_tdp_limit = cur_tdp_limit;\n\n\tthm_writew(THM_MPCPC, (new_tdp_limit * 10) / 8);\n\n\tturbo_override |= TURBO_TDC_OVR_EN | TURBO_TDP_OVR_EN;\n\twrmsrl(TURBO_POWER_CURRENT_LIMIT, turbo_override);\n\n\tturbo_override &= ~TURBO_TDP_MASK;\n\tturbo_override |= new_tdp_limit;\n\n\twrmsrl(TURBO_POWER_CURRENT_LIMIT, turbo_override);\n}\n\n \nstatic void ips_cpu_lower(struct ips_driver *ips)\n{\n\tu64 turbo_override;\n\tu16 cur_limit, new_limit;\n\n\trdmsrl(TURBO_POWER_CURRENT_LIMIT, turbo_override);\n\n\tcur_limit = turbo_override & TURBO_TDP_MASK;\n\tnew_limit = cur_limit - 8;  \n\n\t \n\tif (new_limit  < (ips->orig_turbo_limit & TURBO_TDP_MASK))\n\t\tnew_limit = ips->orig_turbo_limit & TURBO_TDP_MASK;\n\n\tthm_writew(THM_MPCPC, (new_limit * 10) / 8);\n\n\tturbo_override |= TURBO_TDC_OVR_EN | TURBO_TDP_OVR_EN;\n\twrmsrl(TURBO_POWER_CURRENT_LIMIT, turbo_override);\n\n\tturbo_override &= ~TURBO_TDP_MASK;\n\tturbo_override |= new_limit;\n\n\twrmsrl(TURBO_POWER_CURRENT_LIMIT, turbo_override);\n}\n\n \nstatic void do_enable_cpu_turbo(void *data)\n{\n\tu64 perf_ctl;\n\n\trdmsrl(IA32_PERF_CTL, perf_ctl);\n\tif (perf_ctl & IA32_PERF_TURBO_DIS) {\n\t\tperf_ctl &= ~IA32_PERF_TURBO_DIS;\n\t\twrmsrl(IA32_PERF_CTL, perf_ctl);\n\t}\n}\n\n \nstatic void ips_enable_cpu_turbo(struct ips_driver *ips)\n{\n\t \n\tif (ips->__cpu_turbo_on)\n\t\treturn;\n\n\tif (ips->turbo_toggle_allowed)\n\t\ton_each_cpu(do_enable_cpu_turbo, ips, 1);\n\n\tips->__cpu_turbo_on = true;\n}\n\n \nstatic void do_disable_cpu_turbo(void *data)\n{\n\tu64 perf_ctl;\n\n\trdmsrl(IA32_PERF_CTL, perf_ctl);\n\tif (!(perf_ctl & IA32_PERF_TURBO_DIS)) {\n\t\tperf_ctl |= IA32_PERF_TURBO_DIS;\n\t\twrmsrl(IA32_PERF_CTL, perf_ctl);\n\t}\n}\n\n \nstatic void ips_disable_cpu_turbo(struct ips_driver *ips)\n{\n\t \n\tif (!ips->__cpu_turbo_on)\n\t\treturn;\n\n\tif (ips->turbo_toggle_allowed)\n\t\ton_each_cpu(do_disable_cpu_turbo, ips, 1);\n\n\tips->__cpu_turbo_on = false;\n}\n\n \nstatic bool ips_gpu_busy(struct ips_driver *ips)\n{\n\tif (!ips_gpu_turbo_enabled(ips))\n\t\treturn false;\n\n\treturn ips->gpu_busy();\n}\n\n \nstatic void ips_gpu_raise(struct ips_driver *ips)\n{\n\tif (!ips_gpu_turbo_enabled(ips))\n\t\treturn;\n\n\tif (!ips->gpu_raise())\n\t\tips->gpu_turbo_enabled = false;\n\n\treturn;\n}\n\n \nstatic void ips_gpu_lower(struct ips_driver *ips)\n{\n\tif (!ips_gpu_turbo_enabled(ips))\n\t\treturn;\n\n\tif (!ips->gpu_lower())\n\t\tips->gpu_turbo_enabled = false;\n\n\treturn;\n}\n\n \nstatic void ips_enable_gpu_turbo(struct ips_driver *ips)\n{\n\tif (ips->__gpu_turbo_on)\n\t\treturn;\n\tips->__gpu_turbo_on = true;\n}\n\n \nstatic void ips_disable_gpu_turbo(struct ips_driver *ips)\n{\n\t \n\tif (!ips->__gpu_turbo_on)\n\t\treturn;\n\n\tif (!ips->gpu_turbo_disable())\n\t\tdev_err(ips->dev, \"failed to disable graphics turbo\\n\");\n\telse\n\t\tips->__gpu_turbo_on = false;\n}\n\n \nstatic bool mcp_exceeded(struct ips_driver *ips)\n{\n\tunsigned long flags;\n\tbool ret = false;\n\tu32 temp_limit;\n\tu32 avg_power;\n\n\tspin_lock_irqsave(&ips->turbo_status_lock, flags);\n\n\ttemp_limit = ips->mcp_temp_limit * 100;\n\tif (ips->mcp_avg_temp > temp_limit)\n\t\tret = true;\n\n\tavg_power = ips->cpu_avg_power + ips->mch_avg_power;\n\tif (avg_power > ips->mcp_power_limit)\n\t\tret = true;\n\n\tspin_unlock_irqrestore(&ips->turbo_status_lock, flags);\n\n\treturn ret;\n}\n\n \nstatic bool cpu_exceeded(struct ips_driver *ips, int cpu)\n{\n\tunsigned long flags;\n\tint avg;\n\tbool ret = false;\n\n\tspin_lock_irqsave(&ips->turbo_status_lock, flags);\n\tavg = cpu ? ips->ctv2_avg_temp : ips->ctv1_avg_temp;\n\tif (avg > (ips->limits->core_temp_limit * 100))\n\t\tret = true;\n\tif (ips->cpu_avg_power > ips->core_power_limit * 100)\n\t\tret = true;\n\tspin_unlock_irqrestore(&ips->turbo_status_lock, flags);\n\n\tif (ret)\n\t\tdev_info(ips->dev, \"CPU power or thermal limit exceeded\\n\");\n\n\treturn ret;\n}\n\n \nstatic bool mch_exceeded(struct ips_driver *ips)\n{\n\tunsigned long flags;\n\tbool ret = false;\n\n\tspin_lock_irqsave(&ips->turbo_status_lock, flags);\n\tif (ips->mch_avg_temp > (ips->limits->mch_temp_limit * 100))\n\t\tret = true;\n\tif (ips->mch_avg_power > ips->mch_power_limit)\n\t\tret = true;\n\tspin_unlock_irqrestore(&ips->turbo_status_lock, flags);\n\n\treturn ret;\n}\n\n \nstatic void verify_limits(struct ips_driver *ips)\n{\n\tif (ips->mcp_power_limit < ips->limits->mcp_power_limit ||\n\t    ips->mcp_power_limit > 35000)\n\t\tips->mcp_power_limit = ips->limits->mcp_power_limit;\n\n\tif (ips->mcp_temp_limit < ips->limits->core_temp_limit ||\n\t    ips->mcp_temp_limit < ips->limits->mch_temp_limit ||\n\t    ips->mcp_temp_limit > 150)\n\t\tips->mcp_temp_limit = min(ips->limits->core_temp_limit,\n\t\t\t\t\t  ips->limits->mch_temp_limit);\n}\n\n \nstatic void update_turbo_limits(struct ips_driver *ips)\n{\n\tu32 hts = thm_readl(THM_HTS);\n\n\tips->cpu_turbo_enabled = !(hts & HTS_PCTD_DIS);\n\t \n\tips->cpu_turbo_enabled = false;\n\n\tif (ips->gpu_busy)\n\t\tips->gpu_turbo_enabled = !(hts & HTS_GTD_DIS);\n\n\tips->core_power_limit = thm_readw(THM_MPCPC);\n\tips->mch_power_limit = thm_readw(THM_MMGPC);\n\tips->mcp_temp_limit = thm_readw(THM_PTL);\n\tips->mcp_power_limit = thm_readw(THM_MPPC);\n\n\tverify_limits(ips);\n\t \n}\n\n \nstatic int ips_adjust(void *data)\n{\n\tstruct ips_driver *ips = data;\n\tunsigned long flags;\n\n\tdev_dbg(ips->dev, \"starting ips-adjust thread\\n\");\n\n\t \n\tdo {\n\t\tbool cpu_busy = ips_cpu_busy(ips);\n\t\tbool gpu_busy = ips_gpu_busy(ips);\n\n\t\tspin_lock_irqsave(&ips->turbo_status_lock, flags);\n\t\tif (ips->poll_turbo_status)\n\t\t\tupdate_turbo_limits(ips);\n\t\tspin_unlock_irqrestore(&ips->turbo_status_lock, flags);\n\n\t\t \n\t\tif (ips->cpu_turbo_enabled)\n\t\t\tips_enable_cpu_turbo(ips);\n\t\telse\n\t\t\tips_disable_cpu_turbo(ips);\n\n\t\tif (ips->gpu_turbo_enabled)\n\t\t\tips_enable_gpu_turbo(ips);\n\t\telse\n\t\t\tips_disable_gpu_turbo(ips);\n\n\t\t \n\t\tif (mcp_exceeded(ips)) {\n\t\t\tips_cpu_lower(ips);\n\t\t\tips_gpu_lower(ips);\n\t\t\tgoto sleep;\n\t\t}\n\n\t\tif (!cpu_exceeded(ips, 0) && cpu_busy)\n\t\t\tips_cpu_raise(ips);\n\t\telse\n\t\t\tips_cpu_lower(ips);\n\n\t\tif (!mch_exceeded(ips) && gpu_busy)\n\t\t\tips_gpu_raise(ips);\n\t\telse\n\t\t\tips_gpu_lower(ips);\n\nsleep:\n\t\tschedule_timeout_interruptible(msecs_to_jiffies(IPS_ADJUST_PERIOD));\n\t} while (!kthread_should_stop());\n\n\tdev_dbg(ips->dev, \"ips-adjust thread stopped\\n\");\n\n\treturn 0;\n}\n\n \n\nstatic u16 calc_avg_temp(struct ips_driver *ips, u16 *array)\n{\n\tu64 total = 0;\n\tint i;\n\tu16 avg;\n\n\tfor (i = 0; i < IPS_SAMPLE_COUNT; i++)\n\t\ttotal += (u64)(array[i] * 100);\n\n\tdo_div(total, IPS_SAMPLE_COUNT);\n\n\tavg = (u16)total;\n\n\treturn avg;\n}\n\nstatic u16 read_mgtv(struct ips_driver *ips)\n{\n\tu16 __maybe_unused ret;\n\tu64 slope, offset;\n\tu64 val;\n\n\tval = thm_readq(THM_MGTV);\n\tval = (val & TV_MASK) >> TV_SHIFT;\n\n\tslope = offset = thm_readw(THM_MGTA);\n\tslope = (slope & MGTA_SLOPE_MASK) >> MGTA_SLOPE_SHIFT;\n\toffset = offset & MGTA_OFFSET_MASK;\n\n\tret = ((val * slope + 0x40) >> 7) + offset;\n\n\treturn 0;  \n}\n\nstatic u16 read_ptv(struct ips_driver *ips)\n{\n\tu16 val;\n\n\tval = thm_readw(THM_PTV) & PTV_MASK;\n\n\treturn val;\n}\n\nstatic u16 read_ctv(struct ips_driver *ips, int cpu)\n{\n\tint reg = cpu ? THM_CTV2 : THM_CTV1;\n\tu16 val;\n\n\tval = thm_readw(reg);\n\tif (!(val & CTV_TEMP_ERROR))\n\t\tval = (val) >> 6;  \n\telse\n\t\tval = 0;\n\n\treturn val;\n}\n\nstatic u32 get_cpu_power(struct ips_driver *ips, u32 *last, int period)\n{\n\tu32 val;\n\tu32 ret;\n\n\t \n\tval = thm_readl(THM_CEC);\n\n\t \n\tret = (((val - *last) * 1000) / period);\n\tret = (ret * 1000) / 65535;\n\t*last = val;\n\n\treturn 0;\n}\n\nstatic const u16 temp_decay_factor = 2;\nstatic u16 update_average_temp(u16 avg, u16 val)\n{\n\tu16 ret;\n\n\t \n\tret = (val * 100 / temp_decay_factor) +\n\t\t(((temp_decay_factor - 1) * avg) / temp_decay_factor);\n\treturn ret;\n}\n\nstatic const u16 power_decay_factor = 2;\nstatic u16 update_average_power(u32 avg, u32 val)\n{\n\tu32 ret;\n\n\tret = (val / power_decay_factor) +\n\t\t(((power_decay_factor - 1) * avg) / power_decay_factor);\n\n\treturn ret;\n}\n\nstatic u32 calc_avg_power(struct ips_driver *ips, u32 *array)\n{\n\tu64 total = 0;\n\tu32 avg;\n\tint i;\n\n\tfor (i = 0; i < IPS_SAMPLE_COUNT; i++)\n\t\ttotal += array[i];\n\n\tdo_div(total, IPS_SAMPLE_COUNT);\n\tavg = (u32)total;\n\n\treturn avg;\n}\n\nstatic void monitor_timeout(struct timer_list *t)\n{\n\tstruct ips_driver *ips = from_timer(ips, t, timer);\n\twake_up_process(ips->monitor);\n}\n\n \nstatic int ips_monitor(void *data)\n{\n\tstruct ips_driver *ips = data;\n\tunsigned long seqno_timestamp, expire, last_msecs, last_sample_period;\n\tint i;\n\tu32 *cpu_samples, *mchp_samples, old_cpu_power;\n\tu16 *mcp_samples, *ctv1_samples, *ctv2_samples, *mch_samples;\n\tu8 cur_seqno, last_seqno;\n\n\tmcp_samples = kcalloc(IPS_SAMPLE_COUNT, sizeof(u16), GFP_KERNEL);\n\tctv1_samples = kcalloc(IPS_SAMPLE_COUNT, sizeof(u16), GFP_KERNEL);\n\tctv2_samples = kcalloc(IPS_SAMPLE_COUNT, sizeof(u16), GFP_KERNEL);\n\tmch_samples = kcalloc(IPS_SAMPLE_COUNT, sizeof(u16), GFP_KERNEL);\n\tcpu_samples = kcalloc(IPS_SAMPLE_COUNT, sizeof(u32), GFP_KERNEL);\n\tmchp_samples = kcalloc(IPS_SAMPLE_COUNT, sizeof(u32), GFP_KERNEL);\n\tif (!mcp_samples || !ctv1_samples || !ctv2_samples || !mch_samples ||\n\t\t\t!cpu_samples || !mchp_samples) {\n\t\tdev_err(ips->dev,\n\t\t\t\"failed to allocate sample array, ips disabled\\n\");\n\t\tkfree(mcp_samples);\n\t\tkfree(ctv1_samples);\n\t\tkfree(ctv2_samples);\n\t\tkfree(mch_samples);\n\t\tkfree(cpu_samples);\n\t\tkfree(mchp_samples);\n\t\treturn -ENOMEM;\n\t}\n\n\tlast_seqno = (thm_readl(THM_ITV) & ITV_ME_SEQNO_MASK) >>\n\t\tITV_ME_SEQNO_SHIFT;\n\tseqno_timestamp = get_jiffies_64();\n\n\told_cpu_power = thm_readl(THM_CEC);\n\tschedule_timeout_interruptible(msecs_to_jiffies(IPS_SAMPLE_PERIOD));\n\n\t \n\tfor (i = 0; i < IPS_SAMPLE_COUNT; i++) {\n\t\tu32 mchp, cpu_power;\n\t\tu16 val;\n\n\t\tmcp_samples[i] = read_ptv(ips);\n\n\t\tval = read_ctv(ips, 0);\n\t\tctv1_samples[i] = val;\n\n\t\tval = read_ctv(ips, 1);\n\t\tctv2_samples[i] = val;\n\n\t\tval = read_mgtv(ips);\n\t\tmch_samples[i] = val;\n\n\t\tcpu_power = get_cpu_power(ips, &old_cpu_power,\n\t\t\t\t\t  IPS_SAMPLE_PERIOD);\n\t\tcpu_samples[i] = cpu_power;\n\n\t\tif (ips->read_mch_val) {\n\t\t\tmchp = ips->read_mch_val();\n\t\t\tmchp_samples[i] = mchp;\n\t\t}\n\n\t\tschedule_timeout_interruptible(msecs_to_jiffies(IPS_SAMPLE_PERIOD));\n\t\tif (kthread_should_stop())\n\t\t\tbreak;\n\t}\n\n\tips->mcp_avg_temp = calc_avg_temp(ips, mcp_samples);\n\tips->ctv1_avg_temp = calc_avg_temp(ips, ctv1_samples);\n\tips->ctv2_avg_temp = calc_avg_temp(ips, ctv2_samples);\n\tips->mch_avg_temp = calc_avg_temp(ips, mch_samples);\n\tips->cpu_avg_power = calc_avg_power(ips, cpu_samples);\n\tips->mch_avg_power = calc_avg_power(ips, mchp_samples);\n\tkfree(mcp_samples);\n\tkfree(ctv1_samples);\n\tkfree(ctv2_samples);\n\tkfree(mch_samples);\n\tkfree(cpu_samples);\n\tkfree(mchp_samples);\n\n\t \n\twake_up_process(ips->adjust);\n\n\t \n\told_cpu_power = thm_readl(THM_CEC);\n\tschedule_timeout_interruptible(msecs_to_jiffies(IPS_SAMPLE_PERIOD));\n\tlast_sample_period = IPS_SAMPLE_PERIOD;\n\n\ttimer_setup(&ips->timer, monitor_timeout, TIMER_DEFERRABLE);\n\tdo {\n\t\tu32 cpu_val, mch_val;\n\t\tu16 val;\n\n\t\t \n\t\tval = read_ptv(ips);\n\t\tips->mcp_avg_temp = update_average_temp(ips->mcp_avg_temp, val);\n\n\t\t \n\t\tval = read_ctv(ips, 0);\n\t\tips->ctv1_avg_temp =\n\t\t\tupdate_average_temp(ips->ctv1_avg_temp, val);\n\t\t \n\t\tcpu_val = get_cpu_power(ips, &old_cpu_power,\n\t\t\t\t\tlast_sample_period);\n\t\tips->cpu_avg_power =\n\t\t\tupdate_average_power(ips->cpu_avg_power, cpu_val);\n\n\t\tif (ips->second_cpu) {\n\t\t\t \n\t\t\tval = read_ctv(ips, 1);\n\t\t\tips->ctv2_avg_temp =\n\t\t\t\tupdate_average_temp(ips->ctv2_avg_temp, val);\n\t\t}\n\n\t\t \n\t\tval = read_mgtv(ips);\n\t\tips->mch_avg_temp = update_average_temp(ips->mch_avg_temp, val);\n\t\t \n\t\tif (ips->read_mch_val) {\n\t\t\tmch_val = ips->read_mch_val();\n\t\t\tips->mch_avg_power =\n\t\t\t\tupdate_average_power(ips->mch_avg_power,\n\t\t\t\t\t\t     mch_val);\n\t\t}\n\n\t\t \n\t\tcur_seqno = (thm_readl(THM_ITV) & ITV_ME_SEQNO_MASK) >>\n\t\t\tITV_ME_SEQNO_SHIFT;\n\t\tif (cur_seqno == last_seqno &&\n\t\t    time_after(jiffies, seqno_timestamp + HZ)) {\n\t\t\tdev_warn(ips->dev,\n\t\t\t\t \"ME failed to update for more than 1s, likely hung\\n\");\n\t\t} else {\n\t\t\tseqno_timestamp = get_jiffies_64();\n\t\t\tlast_seqno = cur_seqno;\n\t\t}\n\n\t\tlast_msecs = jiffies_to_msecs(jiffies);\n\t\texpire = jiffies + msecs_to_jiffies(IPS_SAMPLE_PERIOD);\n\n\t\t__set_current_state(TASK_INTERRUPTIBLE);\n\t\tmod_timer(&ips->timer, expire);\n\t\tschedule();\n\n\t\t \n\t\tlast_sample_period = jiffies_to_msecs(jiffies) - last_msecs;\n\t\tif (!last_sample_period)\n\t\t\tlast_sample_period = 1;\n\t} while (!kthread_should_stop());\n\n\tdel_timer_sync(&ips->timer);\n\n\tdev_dbg(ips->dev, \"ips-monitor thread stopped\\n\");\n\n\treturn 0;\n}\n\n#if 0\n#define THM_DUMPW(reg) \\\n\t{ \\\n\tu16 val = thm_readw(reg); \\\n\tdev_dbg(ips->dev, #reg \": 0x%04x\\n\", val); \\\n\t}\n#define THM_DUMPL(reg) \\\n\t{ \\\n\tu32 val = thm_readl(reg); \\\n\tdev_dbg(ips->dev, #reg \": 0x%08x\\n\", val); \\\n\t}\n#define THM_DUMPQ(reg) \\\n\t{ \\\n\tu64 val = thm_readq(reg); \\\n\tdev_dbg(ips->dev, #reg \": 0x%016x\\n\", val); \\\n\t}\n\nstatic void dump_thermal_info(struct ips_driver *ips)\n{\n\tu16 ptl;\n\n\tptl = thm_readw(THM_PTL);\n\tdev_dbg(ips->dev, \"Processor temp limit: %d\\n\", ptl);\n\n\tTHM_DUMPW(THM_CTA);\n\tTHM_DUMPW(THM_TRC);\n\tTHM_DUMPW(THM_CTV1);\n\tTHM_DUMPL(THM_STS);\n\tTHM_DUMPW(THM_PTV);\n\tTHM_DUMPQ(THM_MGTV);\n}\n#endif\n\n \nstatic irqreturn_t ips_irq_handler(int irq, void *arg)\n{\n\tstruct ips_driver *ips = arg;\n\tu8 tses = thm_readb(THM_TSES);\n\tu8 tes = thm_readb(THM_TES);\n\n\tif (!tses && !tes)\n\t\treturn IRQ_NONE;\n\n\tdev_info(ips->dev, \"TSES: 0x%02x\\n\", tses);\n\tdev_info(ips->dev, \"TES: 0x%02x\\n\", tes);\n\n\t \n\tif (tes & 1) {\n\t\tu32 sts, tc1;\n\n\t\tsts = thm_readl(THM_STS);\n\t\ttc1 = thm_readl(THM_TC1);\n\n\t\tif (sts & STS_NVV) {\n\t\t\tspin_lock(&ips->turbo_status_lock);\n\t\t\tips->core_power_limit = (sts & STS_PCPL_MASK) >>\n\t\t\t\tSTS_PCPL_SHIFT;\n\t\t\tips->mch_power_limit = (sts & STS_GPL_MASK) >>\n\t\t\t\tSTS_GPL_SHIFT;\n\t\t\t \n\t\t\tips->cpu_turbo_enabled = !(sts & STS_PCTD_DIS);\n\t\t\t \n\t\t\tips->cpu_turbo_enabled = false;\n\t\t\tif (ips->gpu_busy)\n\t\t\t\tips->gpu_turbo_enabled = !(sts & STS_GTD_DIS);\n\t\t\tips->mcp_temp_limit = (sts & STS_PTL_MASK) >>\n\t\t\t\tSTS_PTL_SHIFT;\n\t\t\tips->mcp_power_limit = (tc1 & STS_PPL_MASK) >>\n\t\t\t\tSTS_PPL_SHIFT;\n\t\t\tverify_limits(ips);\n\t\t\tspin_unlock(&ips->turbo_status_lock);\n\n\t\t\tthm_writeb(THM_SEC, SEC_ACK);\n\t\t}\n\t\tthm_writeb(THM_TES, tes);\n\t}\n\n\t \n\tif (tses) {\n\t\tdev_warn(ips->dev, \"thermal trip occurred, tses: 0x%04x\\n\",\n\t\t\t tses);\n\t\tthm_writeb(THM_TSES, tses);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\n#ifndef CONFIG_DEBUG_FS\nstatic void ips_debugfs_init(struct ips_driver *ips) { return; }\nstatic void ips_debugfs_cleanup(struct ips_driver *ips) { return; }\n#else\n\n \n\nstatic int cpu_temp_show(struct seq_file *m, void *data)\n{\n\tstruct ips_driver *ips = m->private;\n\n\tseq_printf(m, \"%d.%02d\\n\", ips->ctv1_avg_temp / 100,\n\t\t   ips->ctv1_avg_temp % 100);\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(cpu_temp);\n\nstatic int cpu_power_show(struct seq_file *m, void *data)\n{\n\tstruct ips_driver *ips = m->private;\n\n\tseq_printf(m, \"%dmW\\n\", ips->cpu_avg_power);\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(cpu_power);\n\nstatic int cpu_clamp_show(struct seq_file *m, void *data)\n{\n\tu64 turbo_override;\n\tint tdp, tdc;\n\n\trdmsrl(TURBO_POWER_CURRENT_LIMIT, turbo_override);\n\n\ttdp = (int)(turbo_override & TURBO_TDP_MASK);\n\ttdc = (int)((turbo_override & TURBO_TDC_MASK) >> TURBO_TDC_SHIFT);\n\n\t \n\ttdp = tdp * 10 / 8;\n\ttdc = tdc * 10 / 8;\n\n\t \n\tseq_printf(m, \"%d.%dW %d.%dA\\n\", tdp / 10, tdp % 10,\n\t\t   tdc / 10, tdc % 10);\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(cpu_clamp);\n\nstatic int mch_temp_show(struct seq_file *m, void *data)\n{\n\tstruct ips_driver *ips = m->private;\n\n\tseq_printf(m, \"%d.%02d\\n\", ips->mch_avg_temp / 100,\n\t\t   ips->mch_avg_temp % 100);\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(mch_temp);\n\nstatic int mch_power_show(struct seq_file *m, void *data)\n{\n\tstruct ips_driver *ips = m->private;\n\n\tseq_printf(m, \"%dmW\\n\", ips->mch_avg_power);\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(mch_power);\n\nstatic void ips_debugfs_cleanup(struct ips_driver *ips)\n{\n\tdebugfs_remove_recursive(ips->debug_root);\n}\n\nstatic void ips_debugfs_init(struct ips_driver *ips)\n{\n\tips->debug_root = debugfs_create_dir(\"ips\", NULL);\n\n\tdebugfs_create_file(\"cpu_temp\", 0444, ips->debug_root, ips, &cpu_temp_fops);\n\tdebugfs_create_file(\"cpu_power\", 0444, ips->debug_root, ips, &cpu_power_fops);\n\tdebugfs_create_file(\"cpu_clamp\", 0444, ips->debug_root, ips, &cpu_clamp_fops);\n\tdebugfs_create_file(\"mch_temp\", 0444, ips->debug_root, ips, &mch_temp_fops);\n\tdebugfs_create_file(\"mch_power\", 0444, ips->debug_root, ips, &mch_power_fops);\n}\n#endif  \n\n \nstatic struct ips_mcp_limits *ips_detect_cpu(struct ips_driver *ips)\n{\n\tu64 turbo_power, misc_en;\n\tstruct ips_mcp_limits *limits = NULL;\n\tu16 tdp;\n\n\tif (!(boot_cpu_data.x86 == 6 && boot_cpu_data.x86_model == 37)) {\n\t\tdev_info(ips->dev, \"Non-IPS CPU detected.\\n\");\n\t\treturn NULL;\n\t}\n\n\trdmsrl(IA32_MISC_ENABLE, misc_en);\n\t \n\tif (misc_en & IA32_MISC_TURBO_EN)\n\t\tips->turbo_toggle_allowed = true;\n\telse\n\t\tips->turbo_toggle_allowed = false;\n\n\tif (strstr(boot_cpu_data.x86_model_id, \"CPU       M\"))\n\t\tlimits = &ips_sv_limits;\n\telse if (strstr(boot_cpu_data.x86_model_id, \"CPU       L\"))\n\t\tlimits = &ips_lv_limits;\n\telse if (strstr(boot_cpu_data.x86_model_id, \"CPU       U\"))\n\t\tlimits = &ips_ulv_limits;\n\telse {\n\t\tdev_info(ips->dev, \"No CPUID match found.\\n\");\n\t\treturn NULL;\n\t}\n\n\trdmsrl(TURBO_POWER_CURRENT_LIMIT, turbo_power);\n\ttdp = turbo_power & TURBO_TDP_MASK;\n\n\t \n\tif (limits->core_power_limit != (tdp / 8) * 1000) {\n\t\tdev_info(ips->dev,\n\t\t\t \"CPU TDP doesn't match expected value (found %d, expected %d)\\n\",\n\t\t\t tdp / 8, limits->core_power_limit / 1000);\n\t\tlimits->core_power_limit = (tdp / 8) * 1000;\n\t}\n\n\treturn limits;\n}\n\n \nstatic bool ips_get_i915_syms(struct ips_driver *ips)\n{\n\tips->read_mch_val = symbol_get(i915_read_mch_val);\n\tif (!ips->read_mch_val)\n\t\tgoto out_err;\n\tips->gpu_raise = symbol_get(i915_gpu_raise);\n\tif (!ips->gpu_raise)\n\t\tgoto out_put_mch;\n\tips->gpu_lower = symbol_get(i915_gpu_lower);\n\tif (!ips->gpu_lower)\n\t\tgoto out_put_raise;\n\tips->gpu_busy = symbol_get(i915_gpu_busy);\n\tif (!ips->gpu_busy)\n\t\tgoto out_put_lower;\n\tips->gpu_turbo_disable = symbol_get(i915_gpu_turbo_disable);\n\tif (!ips->gpu_turbo_disable)\n\t\tgoto out_put_busy;\n\n\treturn true;\n\nout_put_busy:\n\tsymbol_put(i915_gpu_busy);\nout_put_lower:\n\tsymbol_put(i915_gpu_lower);\nout_put_raise:\n\tsymbol_put(i915_gpu_raise);\nout_put_mch:\n\tsymbol_put(i915_read_mch_val);\nout_err:\n\treturn false;\n}\n\nstatic bool\nips_gpu_turbo_enabled(struct ips_driver *ips)\n{\n\tif (!ips->gpu_busy && late_i915_load) {\n\t\tif (ips_get_i915_syms(ips)) {\n\t\t\tdev_info(ips->dev,\n\t\t\t\t \"i915 driver attached, reenabling gpu turbo\\n\");\n\t\t\tips->gpu_turbo_enabled = !(thm_readl(THM_HTS) & HTS_GTD_DIS);\n\t\t}\n\t}\n\n\treturn ips->gpu_turbo_enabled;\n}\n\nvoid\nips_link_to_i915_driver(void)\n{\n\t \n\tlate_i915_load = true;\n}\nEXPORT_SYMBOL_GPL(ips_link_to_i915_driver);\n\nstatic const struct pci_device_id ips_id_table[] = {\n\t{ PCI_VDEVICE(INTEL, PCI_DEVICE_ID_INTEL_THERMAL_SENSOR), },\n\t{ 0, }\n};\n\nMODULE_DEVICE_TABLE(pci, ips_id_table);\n\nstatic int ips_blacklist_callback(const struct dmi_system_id *id)\n{\n\tpr_info(\"Blacklisted intel_ips for %s\\n\", id->ident);\n\treturn 1;\n}\n\nstatic const struct dmi_system_id ips_blacklist[] = {\n\t{\n\t\t.callback = ips_blacklist_callback,\n\t\t.ident = \"HP ProBook\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Hewlett-Packard\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"HP ProBook\"),\n\t\t},\n\t},\n\t{ }\t \n};\n\nstatic int ips_probe(struct pci_dev *dev, const struct pci_device_id *id)\n{\n\tu64 platform_info;\n\tstruct ips_driver *ips;\n\tu32 hts;\n\tint ret = 0;\n\tu16 htshi, trc, trc_required_mask;\n\tu8 tse;\n\n\tif (dmi_check_system(ips_blacklist))\n\t\treturn -ENODEV;\n\n\tips = devm_kzalloc(&dev->dev, sizeof(*ips), GFP_KERNEL);\n\tif (!ips)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&ips->turbo_status_lock);\n\tips->dev = &dev->dev;\n\n\tips->limits = ips_detect_cpu(ips);\n\tif (!ips->limits) {\n\t\tdev_info(&dev->dev, \"IPS not supported on this CPU\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tret = pcim_enable_device(dev);\n\tif (ret) {\n\t\tdev_err(&dev->dev, \"can't enable PCI device, aborting\\n\");\n\t\treturn ret;\n\t}\n\n\tret = pcim_iomap_regions(dev, 1 << 0, pci_name(dev));\n\tif (ret) {\n\t\tdev_err(&dev->dev, \"failed to map thermal regs, aborting\\n\");\n\t\treturn ret;\n\t}\n\tips->regmap = pcim_iomap_table(dev)[0];\n\n\tpci_set_drvdata(dev, ips);\n\n\ttse = thm_readb(THM_TSE);\n\tif (tse != TSE_EN) {\n\t\tdev_err(&dev->dev, \"thermal device not enabled (0x%02x), aborting\\n\", tse);\n\t\treturn -ENXIO;\n\t}\n\n\ttrc = thm_readw(THM_TRC);\n\ttrc_required_mask = TRC_CORE1_EN | TRC_CORE_PWR | TRC_MCH_EN;\n\tif ((trc & trc_required_mask) != trc_required_mask) {\n\t\tdev_err(&dev->dev, \"thermal reporting for required devices not enabled, aborting\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tif (trc & TRC_CORE2_EN)\n\t\tips->second_cpu = true;\n\n\tupdate_turbo_limits(ips);\n\tdev_dbg(&dev->dev, \"max cpu power clamp: %dW\\n\",\n\t\tips->mcp_power_limit / 10);\n\tdev_dbg(&dev->dev, \"max core power clamp: %dW\\n\",\n\t\tips->core_power_limit / 10);\n\t \n\tif (thm_readl(THM_PSC) & PSP_PBRT)\n\t\tips->poll_turbo_status = true;\n\n\tif (!ips_get_i915_syms(ips)) {\n\t\tdev_info(&dev->dev, \"failed to get i915 symbols, graphics turbo disabled until i915 loads\\n\");\n\t\tips->gpu_turbo_enabled = false;\n\t} else {\n\t\tdev_dbg(&dev->dev, \"graphics turbo enabled\\n\");\n\t\tips->gpu_turbo_enabled = true;\n\t}\n\n\t \n\trdmsrl(PLATFORM_INFO, platform_info);\n\tif (!(platform_info & PLATFORM_TDP)) {\n\t\tdev_err(&dev->dev, \"platform indicates TDP override unavailable, aborting\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tret = pci_alloc_irq_vectors(dev, 1, 1, PCI_IRQ_LEGACY);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tips->irq = pci_irq_vector(dev, 0);\n\n\tret = request_irq(ips->irq, ips_irq_handler, IRQF_SHARED, \"ips\", ips);\n\tif (ret) {\n\t\tdev_err(&dev->dev, \"request irq failed, aborting\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tthm_writeb(THM_TSPIEN, TSPIEN_AUX2_LOHI | TSPIEN_CRIT_LOHI |\n\t\t   TSPIEN_HOT_LOHI | TSPIEN_AUX_LOHI);\n\tthm_writeb(THM_TEN, TEN_UPDATE_EN);\n\n\t \n\tips->cta_val = thm_readw(THM_CTA);\n\tips->pta_val = thm_readw(THM_PTA);\n\tips->mgta_val = thm_readw(THM_MGTA);\n\n\t \n\trdmsrl(TURBO_POWER_CURRENT_LIMIT, ips->orig_turbo_limit);\n\n\tips_disable_cpu_turbo(ips);\n\tips->cpu_turbo_enabled = false;\n\n\t \n\tips->adjust = kthread_create(ips_adjust, ips, \"ips-adjust\");\n\tif (IS_ERR(ips->adjust)) {\n\t\tdev_err(&dev->dev,\n\t\t\t\"failed to create thermal adjust thread, aborting\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto error_free_irq;\n\n\t}\n\n\t \n\tips->monitor = kthread_run(ips_monitor, ips, \"ips-monitor\");\n\tif (IS_ERR(ips->monitor)) {\n\t\tdev_err(&dev->dev,\n\t\t\t\"failed to create thermal monitor thread, aborting\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto error_thread_cleanup;\n\t}\n\n\thts = (ips->core_power_limit << HTS_PCPL_SHIFT) |\n\t\t(ips->mcp_temp_limit << HTS_PTL_SHIFT) | HTS_NVV;\n\thtshi = HTS2_PRST_RUNNING << HTS2_PRST_SHIFT;\n\n\tthm_writew(THM_HTSHI, htshi);\n\tthm_writel(THM_HTS, hts);\n\n\tips_debugfs_init(ips);\n\n\tdev_info(&dev->dev, \"IPS driver initialized, MCP temp limit %d\\n\",\n\t\t ips->mcp_temp_limit);\n\treturn ret;\n\nerror_thread_cleanup:\n\tkthread_stop(ips->adjust);\nerror_free_irq:\n\tfree_irq(ips->irq, ips);\n\tpci_free_irq_vectors(dev);\n\treturn ret;\n}\n\nstatic void ips_remove(struct pci_dev *dev)\n{\n\tstruct ips_driver *ips = pci_get_drvdata(dev);\n\tu64 turbo_override;\n\n\tips_debugfs_cleanup(ips);\n\n\t \n\tif (ips->read_mch_val)\n\t\tsymbol_put(i915_read_mch_val);\n\tif (ips->gpu_raise)\n\t\tsymbol_put(i915_gpu_raise);\n\tif (ips->gpu_lower)\n\t\tsymbol_put(i915_gpu_lower);\n\tif (ips->gpu_busy)\n\t\tsymbol_put(i915_gpu_busy);\n\tif (ips->gpu_turbo_disable)\n\t\tsymbol_put(i915_gpu_turbo_disable);\n\n\trdmsrl(TURBO_POWER_CURRENT_LIMIT, turbo_override);\n\tturbo_override &= ~(TURBO_TDC_OVR_EN | TURBO_TDP_OVR_EN);\n\twrmsrl(TURBO_POWER_CURRENT_LIMIT, turbo_override);\n\twrmsrl(TURBO_POWER_CURRENT_LIMIT, ips->orig_turbo_limit);\n\n\tfree_irq(ips->irq, ips);\n\tpci_free_irq_vectors(dev);\n\tif (ips->adjust)\n\t\tkthread_stop(ips->adjust);\n\tif (ips->monitor)\n\t\tkthread_stop(ips->monitor);\n\tdev_dbg(&dev->dev, \"IPS driver removed\\n\");\n}\n\nstatic struct pci_driver ips_pci_driver = {\n\t.name = \"intel ips\",\n\t.id_table = ips_id_table,\n\t.probe = ips_probe,\n\t.remove = ips_remove,\n};\n\nmodule_pci_driver(ips_pci_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Jesse Barnes <jbarnes@virtuousgeek.org>\");\nMODULE_DESCRIPTION(\"Intelligent Power Sharing Driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}