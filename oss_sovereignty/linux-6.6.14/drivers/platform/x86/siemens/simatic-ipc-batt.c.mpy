{
  "module_name": "simatic-ipc-batt.c",
  "hash_id": "2698a970b8491dc220ab7fd4a1b7295ced4555833dd0f6f0312b663a9e92a7ad",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/x86/siemens/simatic-ipc-batt.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/ioport.h>\n#include <linux/gpio/machine.h>\n#include <linux/gpio/consumer.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/platform_data/x86/simatic-ipc-base.h>\n#include <linux/sizes.h>\n\n#include \"simatic-ipc-batt.h\"\n\n#define BATT_DELAY_MS\t(1000 * 60 * 60 * 24)\t \n\n#define SIMATIC_IPC_BATT_LEVEL_FULL\t3000\n#define SIMATIC_IPC_BATT_LEVEL_CRIT\t2750\n#define SIMATIC_IPC_BATT_LEVEL_EMPTY\t   0\n\nstatic struct simatic_ipc_batt {\n\tu8 devmode;\n\tlong current_state;\n\tstruct gpio_desc *gpios[3];\n\tunsigned long last_updated_jiffies;\n} priv;\n\nstatic long simatic_ipc_batt_read_gpio(void)\n{\n\tlong r = SIMATIC_IPC_BATT_LEVEL_FULL;\n\n\tif (priv.gpios[2]) {\n\t\tgpiod_set_value(priv.gpios[2], 1);\n\t\tmsleep(150);\n\t}\n\n\tif (gpiod_get_value_cansleep(priv.gpios[0]))\n\t\tr = SIMATIC_IPC_BATT_LEVEL_EMPTY;\n\telse if (gpiod_get_value_cansleep(priv.gpios[1]))\n\t\tr = SIMATIC_IPC_BATT_LEVEL_CRIT;\n\n\tif (priv.gpios[2])\n\t\tgpiod_set_value(priv.gpios[2], 0);\n\n\treturn r;\n}\n\n#define SIMATIC_IPC_BATT_PORT_BASE\t0x404D\nstatic struct resource simatic_ipc_batt_io_res =\n\tDEFINE_RES_IO_NAMED(SIMATIC_IPC_BATT_PORT_BASE, SZ_1, KBUILD_MODNAME);\n\nstatic long simatic_ipc_batt_read_io(struct device *dev)\n{\n\tlong r = SIMATIC_IPC_BATT_LEVEL_FULL;\n\tstruct resource *res = &simatic_ipc_batt_io_res;\n\tu8 val;\n\n\tif (!request_muxed_region(res->start, resource_size(res), res->name)) {\n\t\tdev_err(dev, \"Unable to register IO resource at %pR\\n\", res);\n\t\treturn -EBUSY;\n\t}\n\n\tval = inb(SIMATIC_IPC_BATT_PORT_BASE);\n\trelease_region(simatic_ipc_batt_io_res.start, resource_size(&simatic_ipc_batt_io_res));\n\n\tif (val & (1 << 7))\n\t\tr = SIMATIC_IPC_BATT_LEVEL_EMPTY;\n\telse if (val & (1 << 6))\n\t\tr = SIMATIC_IPC_BATT_LEVEL_CRIT;\n\n\treturn r;\n}\n\nstatic long simatic_ipc_batt_read_value(struct device *dev)\n{\n\tunsigned long next_update;\n\n\tnext_update = priv.last_updated_jiffies + msecs_to_jiffies(BATT_DELAY_MS);\n\tif (time_after(jiffies, next_update) || !priv.last_updated_jiffies) {\n\t\tif (priv.devmode == SIMATIC_IPC_DEVICE_227E)\n\t\t\tpriv.current_state = simatic_ipc_batt_read_io(dev);\n\t\telse\n\t\t\tpriv.current_state = simatic_ipc_batt_read_gpio();\n\n\t\tpriv.last_updated_jiffies = jiffies;\n\t\tif (priv.current_state < SIMATIC_IPC_BATT_LEVEL_FULL)\n\t\t\tdev_warn(dev, \"CMOS battery needs to be replaced.\\n\");\n\t}\n\n\treturn priv.current_state;\n}\n\nstatic int simatic_ipc_batt_read(struct device *dev, enum hwmon_sensor_types type,\n\t\t\t\t u32 attr, int channel, long *val)\n{\n\tswitch (attr) {\n\tcase hwmon_in_input:\n\t\t*val = simatic_ipc_batt_read_value(dev);\n\t\tbreak;\n\tcase hwmon_in_lcrit:\n\t\t*val = SIMATIC_IPC_BATT_LEVEL_CRIT;\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic umode_t simatic_ipc_batt_is_visible(const void *data, enum hwmon_sensor_types type,\n\t\t\t\t\t   u32 attr, int channel)\n{\n\tif (attr == hwmon_in_input || attr == hwmon_in_lcrit)\n\t\treturn 0444;\n\n\treturn 0;\n}\n\nstatic const struct hwmon_ops simatic_ipc_batt_ops = {\n\t.is_visible = simatic_ipc_batt_is_visible,\n\t.read = simatic_ipc_batt_read,\n};\n\nstatic const struct hwmon_channel_info *simatic_ipc_batt_info[] = {\n\tHWMON_CHANNEL_INFO(in, HWMON_I_INPUT | HWMON_I_LCRIT),\n\tNULL\n};\n\nstatic const struct hwmon_chip_info simatic_ipc_batt_chip_info = {\n\t.ops = &simatic_ipc_batt_ops,\n\t.info = simatic_ipc_batt_info,\n};\n\nint simatic_ipc_batt_remove(struct platform_device *pdev, struct gpiod_lookup_table *table)\n{\n\tgpiod_remove_lookup_table(table);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(simatic_ipc_batt_remove);\n\nint simatic_ipc_batt_probe(struct platform_device *pdev, struct gpiod_lookup_table *table)\n{\n\tstruct simatic_ipc_platform *plat;\n\tstruct device *dev = &pdev->dev;\n\tstruct device *hwmon_dev;\n\tunsigned long flags;\n\tint err;\n\n\tplat = pdev->dev.platform_data;\n\tpriv.devmode = plat->devmode;\n\n\tswitch (priv.devmode) {\n\tcase SIMATIC_IPC_DEVICE_127E:\n\tcase SIMATIC_IPC_DEVICE_227G:\n\tcase SIMATIC_IPC_DEVICE_BX_39A:\n\tcase SIMATIC_IPC_DEVICE_BX_21A:\n\tcase SIMATIC_IPC_DEVICE_BX_59A:\n\t\ttable->dev_id = dev_name(dev);\n\t\tgpiod_add_lookup_table(table);\n\t\tbreak;\n\tcase SIMATIC_IPC_DEVICE_227E:\n\t\tgoto nogpio;\n\tdefault:\n\t\treturn -ENODEV;\n\t}\n\n\tpriv.gpios[0] = devm_gpiod_get_index(dev, \"CMOSBattery empty\", 0, GPIOD_IN);\n\tif (IS_ERR(priv.gpios[0])) {\n\t\terr = PTR_ERR(priv.gpios[0]);\n\t\tpriv.gpios[0] = NULL;\n\t\tgoto out;\n\t}\n\tpriv.gpios[1] = devm_gpiod_get_index(dev, \"CMOSBattery low\", 1, GPIOD_IN);\n\tif (IS_ERR(priv.gpios[1])) {\n\t\terr = PTR_ERR(priv.gpios[1]);\n\t\tpriv.gpios[1] = NULL;\n\t\tgoto out;\n\t}\n\n\tif (table->table[2].key) {\n\t\tflags = GPIOD_OUT_HIGH;\n\t\tif (priv.devmode == SIMATIC_IPC_DEVICE_BX_21A ||\n\t\t    priv.devmode == SIMATIC_IPC_DEVICE_BX_59A)\n\t\t\tflags = GPIOD_OUT_LOW;\n\t\tpriv.gpios[2] = devm_gpiod_get_index(dev, \"CMOSBattery meter\", 2, flags);\n\t\tif (IS_ERR(priv.gpios[2])) {\n\t\t\terr = PTR_ERR(priv.gpios[2]);\n\t\t\tpriv.gpios[2] = NULL;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tpriv.gpios[2] = NULL;\n\t}\n\nnogpio:\n\thwmon_dev = devm_hwmon_device_register_with_info(dev, KBUILD_MODNAME,\n\t\t\t\t\t\t\t &priv,\n\t\t\t\t\t\t\t &simatic_ipc_batt_chip_info,\n\t\t\t\t\t\t\t NULL);\n\tif (IS_ERR(hwmon_dev)) {\n\t\terr = PTR_ERR(hwmon_dev);\n\t\tgoto out;\n\t}\n\n\t \n\tsimatic_ipc_batt_read_value(dev);\n\n\treturn 0;\nout:\n\tsimatic_ipc_batt_remove(pdev, table);\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(simatic_ipc_batt_probe);\n\nstatic int simatic_ipc_batt_io_remove(struct platform_device *pdev)\n{\n\treturn simatic_ipc_batt_remove(pdev, NULL);\n}\n\nstatic int simatic_ipc_batt_io_probe(struct platform_device *pdev)\n{\n\treturn simatic_ipc_batt_probe(pdev, NULL);\n}\n\nstatic struct platform_driver simatic_ipc_batt_driver = {\n\t.probe = simatic_ipc_batt_io_probe,\n\t.remove = simatic_ipc_batt_io_remove,\n\t.driver = {\n\t\t.name = KBUILD_MODNAME,\n\t},\n};\n\nmodule_platform_driver(simatic_ipc_batt_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:\" KBUILD_MODNAME);\nMODULE_AUTHOR(\"Henning Schild <henning.schild@siemens.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}