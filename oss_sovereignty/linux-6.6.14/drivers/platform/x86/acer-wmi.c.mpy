{
  "module_name": "acer-wmi.c",
  "hash_id": "19f29bf657073bcb5de858c1ec1c9383f2fe42fc28a764297f1c74bf5df1d125",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/x86/acer-wmi.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/types.h>\n#include <linux/dmi.h>\n#include <linux/fb.h>\n#include <linux/backlight.h>\n#include <linux/leds.h>\n#include <linux/platform_device.h>\n#include <linux/acpi.h>\n#include <linux/i8042.h>\n#include <linux/rfkill.h>\n#include <linux/workqueue.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/input.h>\n#include <linux/input/sparse-keymap.h>\n#include <acpi/video.h>\n\nMODULE_AUTHOR(\"Carlos Corbacho\");\nMODULE_DESCRIPTION(\"Acer Laptop WMI Extras Driver\");\nMODULE_LICENSE(\"GPL\");\n\n \n#define ACER_AMW0_WRITE\t0x9610\n\n \n#define ACER_AMW0_WIRELESS_MASK  0x35\n#define ACER_AMW0_BLUETOOTH_MASK 0x34\n#define ACER_AMW0_MAILLED_MASK   0x31\n\n \n#define ACER_WMID_GET_WIRELESS_METHODID\t\t1\n#define ACER_WMID_GET_BLUETOOTH_METHODID\t2\n#define ACER_WMID_GET_BRIGHTNESS_METHODID\t3\n#define ACER_WMID_SET_WIRELESS_METHODID\t\t4\n#define ACER_WMID_SET_BLUETOOTH_METHODID\t5\n#define ACER_WMID_SET_BRIGHTNESS_METHODID\t6\n#define ACER_WMID_GET_THREEG_METHODID\t\t10\n#define ACER_WMID_SET_THREEG_METHODID\t\t11\n\n#define ACER_WMID_SET_GAMING_LED_METHODID 2\n#define ACER_WMID_GET_GAMING_LED_METHODID 4\n#define ACER_WMID_SET_GAMING_FAN_BEHAVIOR 14\n#define ACER_WMID_SET_GAMING_MISC_SETTING_METHODID 22\n\n \n#define AMW0_GUID1\t\t\"67C3371D-95A3-4C37-BB61-DD47B491DAAB\"\n#define AMW0_GUID2\t\t\"431F16ED-0C2B-444C-B267-27DEB140CF9C\"\n#define WMID_GUID1\t\t\"6AF4F258-B401-42FD-BE91-3D4AC2D7C0D3\"\n#define WMID_GUID2\t\t\"95764E09-FB56-4E83-B31A-37761F60994A\"\n#define WMID_GUID3\t\t\"61EF69EA-865C-4BC3-A502-A0DEBA0CB531\"\n#define WMID_GUID4\t\t\"7A4DDFE7-5B5D-40B4-8595-4408E0CC7F56\"\n\n \n#define ACERWMID_EVENT_GUID \"676AA15E-6A47-4D9F-A2CC-1E6D18D14026\"\n\nMODULE_ALIAS(\"wmi:67C3371D-95A3-4C37-BB61-DD47B491DAAB\");\nMODULE_ALIAS(\"wmi:6AF4F258-B401-42FD-BE91-3D4AC2D7C0D3\");\nMODULE_ALIAS(\"wmi:676AA15E-6A47-4D9F-A2CC-1E6D18D14026\");\n\nenum acer_wmi_event_ids {\n\tWMID_HOTKEY_EVENT = 0x1,\n\tWMID_ACCEL_OR_KBD_DOCK_EVENT = 0x5,\n\tWMID_GAMING_TURBO_KEY_EVENT = 0x7,\n};\n\nstatic const struct key_entry acer_wmi_keymap[] __initconst = {\n\t{KE_KEY, 0x01, {KEY_WLAN} },      \n\t{KE_KEY, 0x03, {KEY_WLAN} },      \n\t{KE_KEY, 0x04, {KEY_WLAN} },      \n\t{KE_KEY, 0x12, {KEY_BLUETOOTH} },\t \n\t{KE_KEY, 0x21, {KEY_PROG1} },     \n\t{KE_KEY, 0x22, {KEY_PROG2} },     \n\t{KE_KEY, 0x23, {KEY_PROG3} },     \n\t{KE_KEY, 0x24, {KEY_PROG4} },     \n\t{KE_KEY, 0x27, {KEY_HELP} },\n\t{KE_KEY, 0x29, {KEY_PROG3} },     \n\t{KE_IGNORE, 0x41, {KEY_MUTE} },\n\t{KE_IGNORE, 0x42, {KEY_PREVIOUSSONG} },\n\t{KE_IGNORE, 0x4d, {KEY_PREVIOUSSONG} },\n\t{KE_IGNORE, 0x43, {KEY_NEXTSONG} },\n\t{KE_IGNORE, 0x4e, {KEY_NEXTSONG} },\n\t{KE_IGNORE, 0x44, {KEY_PLAYPAUSE} },\n\t{KE_IGNORE, 0x4f, {KEY_PLAYPAUSE} },\n\t{KE_IGNORE, 0x45, {KEY_STOP} },\n\t{KE_IGNORE, 0x50, {KEY_STOP} },\n\t{KE_IGNORE, 0x48, {KEY_VOLUMEUP} },\n\t{KE_IGNORE, 0x49, {KEY_VOLUMEDOWN} },\n\t{KE_IGNORE, 0x4a, {KEY_VOLUMEDOWN} },\n\t \n\t{KE_KEY, 0x61, {KEY_UNKNOWN} },\n\t{KE_IGNORE, 0x62, {KEY_BRIGHTNESSUP} },\n\t{KE_IGNORE, 0x63, {KEY_BRIGHTNESSDOWN} },\n\t{KE_KEY, 0x64, {KEY_SWITCHVIDEOMODE} },\t \n\t{KE_IGNORE, 0x81, {KEY_SLEEP} },\n\t{KE_KEY, 0x82, {KEY_TOUCHPAD_TOGGLE} },\t \n\t{KE_IGNORE, 0x84, {KEY_KBDILLUMTOGGLE} },  \n\t{KE_KEY, KEY_TOUCHPAD_ON, {KEY_TOUCHPAD_ON} },\n\t{KE_KEY, KEY_TOUCHPAD_OFF, {KEY_TOUCHPAD_OFF} },\n\t{KE_IGNORE, 0x83, {KEY_TOUCHPAD_TOGGLE} },\n\t{KE_KEY, 0x85, {KEY_TOUCHPAD_TOGGLE} },\n\t{KE_KEY, 0x86, {KEY_WLAN} },\n\t{KE_KEY, 0x87, {KEY_POWER} },\n\t{KE_END, 0}\n};\n\nstatic struct input_dev *acer_wmi_input_dev;\nstatic struct input_dev *acer_wmi_accel_dev;\n\nstruct event_return_value {\n\tu8 function;\n\tu8 key_num;\n\tu16 device_state;\n\tu16 reserved1;\n\tu8 kbd_dock_state;\n\tu8 reserved2;\n} __packed;\n\n \n#define ACER_WMID3_GDS_WIRELESS\t\t(1<<0)\t \n#define ACER_WMID3_GDS_THREEG\t\t(1<<6)\t \n#define ACER_WMID3_GDS_WIMAX\t\t(1<<7)\t \n#define ACER_WMID3_GDS_BLUETOOTH\t(1<<11)\t \n#define ACER_WMID3_GDS_RFBTN\t\t(1<<14)\t \n\n#define ACER_WMID3_GDS_TOUCHPAD\t\t(1<<1)\t \n\n \nstruct func_input_params {\n\tu8 function_num;         \n\tu16 commun_devices;      \n\tu16 devices;             \n\tu8 app_status;           \n\tu8 app_mask;\t\t \n\tu8 reserved;\n} __packed;\n\nstruct func_return_value {\n\tu8 error_code;           \n\tu8 ec_return_value;      \n\tu16 reserved;\n} __packed;\n\nstruct wmid3_gds_set_input_param {      \n\tu8 function_num;         \n\tu8 hotkey_number;        \n\tu16 devices;             \n\tu8 volume_value;         \n} __packed;\n\nstruct wmid3_gds_get_input_param {      \n\tu8 function_num;\t \n\tu8 hotkey_number;\t \n\tu16 devices;\t\t \n} __packed;\n\nstruct wmid3_gds_return_value {\t \n\tu8 error_code;\t\t \n\tu8 ec_return_value;\t \n\tu16 devices;\t\t \n\tu32 reserved;\n} __packed;\n\nstruct hotkey_function_type_aa {\n\tu8 type;\n\tu8 length;\n\tu16 handle;\n\tu16 commun_func_bitmap;\n\tu16 application_func_bitmap;\n\tu16 media_func_bitmap;\n\tu16 display_func_bitmap;\n\tu16 others_func_bitmap;\n\tu8 commun_fn_key_number;\n} __packed;\n\n \n#define ACER_CAP_MAILLED\t\tBIT(0)\n#define ACER_CAP_WIRELESS\t\tBIT(1)\n#define ACER_CAP_BLUETOOTH\t\tBIT(2)\n#define ACER_CAP_BRIGHTNESS\t\tBIT(3)\n#define ACER_CAP_THREEG\t\t\tBIT(4)\n#define ACER_CAP_SET_FUNCTION_MODE\tBIT(5)\n#define ACER_CAP_KBD_DOCK\t\tBIT(6)\n#define ACER_CAP_TURBO_OC     BIT(7)\n#define ACER_CAP_TURBO_LED     BIT(8)\n#define ACER_CAP_TURBO_FAN     BIT(9)\n\n \nenum interface_flags {\n\tACER_AMW0,\n\tACER_AMW0_V2,\n\tACER_WMID,\n\tACER_WMID_v2,\n};\n\n#define ACER_DEFAULT_WIRELESS  0\n#define ACER_DEFAULT_BLUETOOTH 0\n#define ACER_DEFAULT_MAILLED   0\n#define ACER_DEFAULT_THREEG    0\n\nstatic int max_brightness = 0xF;\n\nstatic int mailled = -1;\nstatic int brightness = -1;\nstatic int threeg = -1;\nstatic int force_series;\nstatic int force_caps = -1;\nstatic bool ec_raw_mode;\nstatic bool has_type_aa;\nstatic u16 commun_func_bitmap;\nstatic u8 commun_fn_key_number;\n\nmodule_param(mailled, int, 0444);\nmodule_param(brightness, int, 0444);\nmodule_param(threeg, int, 0444);\nmodule_param(force_series, int, 0444);\nmodule_param(force_caps, int, 0444);\nmodule_param(ec_raw_mode, bool, 0444);\nMODULE_PARM_DESC(mailled, \"Set initial state of Mail LED\");\nMODULE_PARM_DESC(brightness, \"Set initial LCD backlight brightness\");\nMODULE_PARM_DESC(threeg, \"Set initial state of 3G hardware\");\nMODULE_PARM_DESC(force_series, \"Force a different laptop series\");\nMODULE_PARM_DESC(force_caps, \"Force the capability bitmask to this value\");\nMODULE_PARM_DESC(ec_raw_mode, \"Enable EC raw mode\");\n\nstruct acer_data {\n\tint mailled;\n\tint threeg;\n\tint brightness;\n};\n\nstruct acer_debug {\n\tstruct dentry *root;\n\tu32 wmid_devices;\n};\n\nstatic struct rfkill *wireless_rfkill;\nstatic struct rfkill *bluetooth_rfkill;\nstatic struct rfkill *threeg_rfkill;\nstatic bool rfkill_inited;\n\n \nstruct wmi_interface {\n\t \n\tu32 type;\n\n\t \n\tu32 capability;\n\n\t \n\tstruct acer_data data;\n\n\t \n\tstruct acer_debug debug;\n};\n\n \nstatic struct wmi_interface *interface;\n\n \n\nstruct quirk_entry {\n\tu8 wireless;\n\tu8 mailled;\n\ts8 brightness;\n\tu8 bluetooth;\n\tu8 turbo;\n\tu8 cpu_fans;\n\tu8 gpu_fans;\n};\n\nstatic struct quirk_entry *quirks;\n\nstatic void __init set_quirks(void)\n{\n\tif (quirks->mailled)\n\t\tinterface->capability |= ACER_CAP_MAILLED;\n\n\tif (quirks->brightness)\n\t\tinterface->capability |= ACER_CAP_BRIGHTNESS;\n\n\tif (quirks->turbo)\n\t\tinterface->capability |= ACER_CAP_TURBO_OC | ACER_CAP_TURBO_LED\n\t\t\t\t\t | ACER_CAP_TURBO_FAN;\n}\n\nstatic int __init dmi_matched(const struct dmi_system_id *dmi)\n{\n\tquirks = dmi->driver_data;\n\treturn 1;\n}\n\nstatic int __init set_force_caps(const struct dmi_system_id *dmi)\n{\n\tif (force_caps == -1) {\n\t\tforce_caps = (uintptr_t)dmi->driver_data;\n\t\tpr_info(\"Found %s, set force_caps to 0x%x\\n\", dmi->ident, force_caps);\n\t}\n\treturn 1;\n}\n\nstatic struct quirk_entry quirk_unknown = {\n};\n\nstatic struct quirk_entry quirk_acer_aspire_1520 = {\n\t.brightness = -1,\n};\n\nstatic struct quirk_entry quirk_acer_travelmate_2490 = {\n\t.mailled = 1,\n};\n\nstatic struct quirk_entry quirk_acer_predator_ph315_53 = {\n\t.turbo = 1,\n\t.cpu_fans = 1,\n\t.gpu_fans = 1,\n};\n\n \nstatic struct quirk_entry quirk_medion_md_98300 = {\n\t.wireless = 1,\n};\n\nstatic struct quirk_entry quirk_fujitsu_amilo_li_1718 = {\n\t.wireless = 2,\n};\n\nstatic struct quirk_entry quirk_lenovo_ideapad_s205 = {\n\t.wireless = 3,\n};\n\n \nstatic const struct dmi_system_id acer_blacklist[] __initconst = {\n\t{\n\t\t.ident = \"Acer Aspire One (SSD)\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Acer\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"AOA110\"),\n\t\t},\n\t},\n\t{\n\t\t.ident = \"Acer Aspire One (HDD)\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Acer\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"AOA150\"),\n\t\t},\n\t},\n\t{}\n};\n\nstatic const struct dmi_system_id amw0_whitelist[] __initconst = {\n\t{\n\t\t.ident = \"Acer\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Acer\"),\n\t\t},\n\t},\n\t{\n\t\t.ident = \"Gateway\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Gateway\"),\n\t\t},\n\t},\n\t{\n\t\t.ident = \"Packard Bell\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Packard Bell\"),\n\t\t},\n\t},\n\t{}\n};\n\n \nstatic const struct dmi_system_id acer_quirks[] __initconst = {\n\t{\n\t\t.callback = dmi_matched,\n\t\t.ident = \"Acer Aspire 1360\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Acer\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Aspire 1360\"),\n\t\t},\n\t\t.driver_data = &quirk_acer_aspire_1520,\n\t},\n\t{\n\t\t.callback = dmi_matched,\n\t\t.ident = \"Acer Aspire 1520\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Acer\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Aspire 1520\"),\n\t\t},\n\t\t.driver_data = &quirk_acer_aspire_1520,\n\t},\n\t{\n\t\t.callback = dmi_matched,\n\t\t.ident = \"Acer Aspire 3100\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Acer\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Aspire 3100\"),\n\t\t},\n\t\t.driver_data = &quirk_acer_travelmate_2490,\n\t},\n\t{\n\t\t.callback = dmi_matched,\n\t\t.ident = \"Acer Aspire 3610\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Acer\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Aspire 3610\"),\n\t\t},\n\t\t.driver_data = &quirk_acer_travelmate_2490,\n\t},\n\t{\n\t\t.callback = dmi_matched,\n\t\t.ident = \"Acer Aspire 5100\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Acer\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Aspire 5100\"),\n\t\t},\n\t\t.driver_data = &quirk_acer_travelmate_2490,\n\t},\n\t{\n\t\t.callback = dmi_matched,\n\t\t.ident = \"Acer Aspire 5610\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Acer\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Aspire 5610\"),\n\t\t},\n\t\t.driver_data = &quirk_acer_travelmate_2490,\n\t},\n\t{\n\t\t.callback = dmi_matched,\n\t\t.ident = \"Acer Aspire 5630\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Acer\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Aspire 5630\"),\n\t\t},\n\t\t.driver_data = &quirk_acer_travelmate_2490,\n\t},\n\t{\n\t\t.callback = dmi_matched,\n\t\t.ident = \"Acer Aspire 5650\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Acer\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Aspire 5650\"),\n\t\t},\n\t\t.driver_data = &quirk_acer_travelmate_2490,\n\t},\n\t{\n\t\t.callback = dmi_matched,\n\t\t.ident = \"Acer Aspire 5680\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Acer\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Aspire 5680\"),\n\t\t},\n\t\t.driver_data = &quirk_acer_travelmate_2490,\n\t},\n\t{\n\t\t.callback = dmi_matched,\n\t\t.ident = \"Acer Aspire 9110\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Acer\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Aspire 9110\"),\n\t\t},\n\t\t.driver_data = &quirk_acer_travelmate_2490,\n\t},\n\t{\n\t\t.callback = dmi_matched,\n\t\t.ident = \"Acer TravelMate 2490\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Acer\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"TravelMate 2490\"),\n\t\t},\n\t\t.driver_data = &quirk_acer_travelmate_2490,\n\t},\n\t{\n\t\t.callback = dmi_matched,\n\t\t.ident = \"Acer TravelMate 4200\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Acer\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"TravelMate 4200\"),\n\t\t},\n\t\t.driver_data = &quirk_acer_travelmate_2490,\n\t},\n\t{\n\t\t.callback = dmi_matched,\n\t\t.ident = \"Acer Predator PH315-53\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Acer\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Predator PH315-53\"),\n\t\t},\n\t\t.driver_data = &quirk_acer_predator_ph315_53,\n\t},\n\t{\n\t\t.callback = set_force_caps,\n\t\t.ident = \"Acer Aspire Switch 10E SW3-016\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Acer\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Aspire SW3-016\"),\n\t\t},\n\t\t.driver_data = (void *)ACER_CAP_KBD_DOCK,\n\t},\n\t{\n\t\t.callback = set_force_caps,\n\t\t.ident = \"Acer Aspire Switch 10 SW5-012\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Acer\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Aspire SW5-012\"),\n\t\t},\n\t\t.driver_data = (void *)ACER_CAP_KBD_DOCK,\n\t},\n\t{\n\t\t.callback = set_force_caps,\n\t\t.ident = \"Acer Aspire Switch V 10 SW5-017\",\n\t\t.matches = {\n\t\t\tDMI_EXACT_MATCH(DMI_SYS_VENDOR, \"Acer\"),\n\t\t\tDMI_EXACT_MATCH(DMI_PRODUCT_NAME, \"SW5-017\"),\n\t\t},\n\t\t.driver_data = (void *)ACER_CAP_KBD_DOCK,\n\t},\n\t{\n\t\t.callback = set_force_caps,\n\t\t.ident = \"Acer One 10 (S1003)\",\n\t\t.matches = {\n\t\t\tDMI_EXACT_MATCH(DMI_SYS_VENDOR, \"Acer\"),\n\t\t\tDMI_EXACT_MATCH(DMI_PRODUCT_NAME, \"One S1003\"),\n\t\t},\n\t\t.driver_data = (void *)ACER_CAP_KBD_DOCK,\n\t},\n\t{}\n};\n\n \nstatic const struct dmi_system_id non_acer_quirks[] __initconst = {\n\t{\n\t\t.callback = dmi_matched,\n\t\t.ident = \"Fujitsu Siemens Amilo Li 1718\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"FUJITSU SIEMENS\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"AMILO Li 1718\"),\n\t\t},\n\t\t.driver_data = &quirk_fujitsu_amilo_li_1718,\n\t},\n\t{\n\t\t.callback = dmi_matched,\n\t\t.ident = \"Medion MD 98300\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"MEDION\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"WAM2030\"),\n\t\t},\n\t\t.driver_data = &quirk_medion_md_98300,\n\t},\n\t{\n\t\t.callback = dmi_matched,\n\t\t.ident = \"Lenovo Ideapad S205\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"LENOVO\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"10382LG\"),\n\t\t},\n\t\t.driver_data = &quirk_lenovo_ideapad_s205,\n\t},\n\t{\n\t\t.callback = dmi_matched,\n\t\t.ident = \"Lenovo Ideapad S205 (Brazos)\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"LENOVO\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Brazos\"),\n\t\t},\n\t\t.driver_data = &quirk_lenovo_ideapad_s205,\n\t},\n\t{\n\t\t.callback = dmi_matched,\n\t\t.ident = \"Lenovo 3000 N200\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"LENOVO\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"0687A31\"),\n\t\t},\n\t\t.driver_data = &quirk_fujitsu_amilo_li_1718,\n\t},\n\t{\n\t\t.callback = dmi_matched,\n\t\t.ident = \"Lenovo Ideapad S205-10382JG\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"LENOVO\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"10382JG\"),\n\t\t},\n\t\t.driver_data = &quirk_lenovo_ideapad_s205,\n\t},\n\t{\n\t\t.callback = dmi_matched,\n\t\t.ident = \"Lenovo Ideapad S205-1038DPG\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"LENOVO\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"1038DPG\"),\n\t\t},\n\t\t.driver_data = &quirk_lenovo_ideapad_s205,\n\t},\n\t{}\n};\n\n \nstatic void __init find_quirks(void)\n{\n\tif (!force_series) {\n\t\tdmi_check_system(acer_quirks);\n\t\tdmi_check_system(non_acer_quirks);\n\t} else if (force_series == 2490) {\n\t\tquirks = &quirk_acer_travelmate_2490;\n\t}\n\n\tif (quirks == NULL)\n\t\tquirks = &quirk_unknown;\n}\n\n \n\nstatic bool has_cap(u32 cap)\n{\n\treturn interface->capability & cap;\n}\n\n \nstruct wmab_args {\n\tu32 eax;\n\tu32 ebx;\n\tu32 ecx;\n\tu32 edx;\n};\n\nstruct wmab_ret {\n\tu32 eax;\n\tu32 ebx;\n\tu32 ecx;\n\tu32 edx;\n\tu32 eex;\n};\n\nstatic acpi_status wmab_execute(struct wmab_args *regbuf,\nstruct acpi_buffer *result)\n{\n\tstruct acpi_buffer input;\n\tacpi_status status;\n\tinput.length = sizeof(struct wmab_args);\n\tinput.pointer = (u8 *)regbuf;\n\n\tstatus = wmi_evaluate_method(AMW0_GUID1, 0, 1, &input, result);\n\n\treturn status;\n}\n\nstatic acpi_status AMW0_get_u32(u32 *value, u32 cap)\n{\n\tint err;\n\tu8 result;\n\n\tswitch (cap) {\n\tcase ACER_CAP_MAILLED:\n\t\tswitch (quirks->mailled) {\n\t\tdefault:\n\t\t\terr = ec_read(0xA, &result);\n\t\t\tif (err)\n\t\t\t\treturn AE_ERROR;\n\t\t\t*value = (result >> 7) & 0x1;\n\t\t\treturn AE_OK;\n\t\t}\n\t\tbreak;\n\tcase ACER_CAP_WIRELESS:\n\t\tswitch (quirks->wireless) {\n\t\tcase 1:\n\t\t\terr = ec_read(0x7B, &result);\n\t\t\tif (err)\n\t\t\t\treturn AE_ERROR;\n\t\t\t*value = result & 0x1;\n\t\t\treturn AE_OK;\n\t\tcase 2:\n\t\t\terr = ec_read(0x71, &result);\n\t\t\tif (err)\n\t\t\t\treturn AE_ERROR;\n\t\t\t*value = result & 0x1;\n\t\t\treturn AE_OK;\n\t\tcase 3:\n\t\t\terr = ec_read(0x78, &result);\n\t\t\tif (err)\n\t\t\t\treturn AE_ERROR;\n\t\t\t*value = result & 0x1;\n\t\t\treturn AE_OK;\n\t\tdefault:\n\t\t\terr = ec_read(0xA, &result);\n\t\t\tif (err)\n\t\t\t\treturn AE_ERROR;\n\t\t\t*value = (result >> 2) & 0x1;\n\t\t\treturn AE_OK;\n\t\t}\n\t\tbreak;\n\tcase ACER_CAP_BLUETOOTH:\n\t\tswitch (quirks->bluetooth) {\n\t\tdefault:\n\t\t\terr = ec_read(0xA, &result);\n\t\t\tif (err)\n\t\t\t\treturn AE_ERROR;\n\t\t\t*value = (result >> 4) & 0x1;\n\t\t\treturn AE_OK;\n\t\t}\n\t\tbreak;\n\tcase ACER_CAP_BRIGHTNESS:\n\t\tswitch (quirks->brightness) {\n\t\tdefault:\n\t\t\terr = ec_read(0x83, &result);\n\t\t\tif (err)\n\t\t\t\treturn AE_ERROR;\n\t\t\t*value = result;\n\t\t\treturn AE_OK;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn AE_ERROR;\n\t}\n\treturn AE_OK;\n}\n\nstatic acpi_status AMW0_set_u32(u32 value, u32 cap)\n{\n\tstruct wmab_args args;\n\n\targs.eax = ACER_AMW0_WRITE;\n\targs.ebx = value ? (1<<8) : 0;\n\targs.ecx = args.edx = 0;\n\n\tswitch (cap) {\n\tcase ACER_CAP_MAILLED:\n\t\tif (value > 1)\n\t\t\treturn AE_BAD_PARAMETER;\n\t\targs.ebx |= ACER_AMW0_MAILLED_MASK;\n\t\tbreak;\n\tcase ACER_CAP_WIRELESS:\n\t\tif (value > 1)\n\t\t\treturn AE_BAD_PARAMETER;\n\t\targs.ebx |= ACER_AMW0_WIRELESS_MASK;\n\t\tbreak;\n\tcase ACER_CAP_BLUETOOTH:\n\t\tif (value > 1)\n\t\t\treturn AE_BAD_PARAMETER;\n\t\targs.ebx |= ACER_AMW0_BLUETOOTH_MASK;\n\t\tbreak;\n\tcase ACER_CAP_BRIGHTNESS:\n\t\tif (value > max_brightness)\n\t\t\treturn AE_BAD_PARAMETER;\n\t\tswitch (quirks->brightness) {\n\t\tdefault:\n\t\t\treturn ec_write(0x83, value);\n\t\t}\n\tdefault:\n\t\treturn AE_ERROR;\n\t}\n\n\t \n\treturn wmab_execute(&args, NULL);\n}\n\nstatic acpi_status __init AMW0_find_mailled(void)\n{\n\tstruct wmab_args args;\n\tstruct wmab_ret ret;\n\tacpi_status status = AE_OK;\n\tstruct acpi_buffer out = { ACPI_ALLOCATE_BUFFER, NULL };\n\tunion acpi_object *obj;\n\n\targs.eax = 0x86;\n\targs.ebx = args.ecx = args.edx = 0;\n\n\tstatus = wmab_execute(&args, &out);\n\tif (ACPI_FAILURE(status))\n\t\treturn status;\n\n\tobj = (union acpi_object *) out.pointer;\n\tif (obj && obj->type == ACPI_TYPE_BUFFER &&\n\tobj->buffer.length == sizeof(struct wmab_ret)) {\n\t\tret = *((struct wmab_ret *) obj->buffer.pointer);\n\t} else {\n\t\tkfree(out.pointer);\n\t\treturn AE_ERROR;\n\t}\n\n\tif (ret.eex & 0x1)\n\t\tinterface->capability |= ACER_CAP_MAILLED;\n\n\tkfree(out.pointer);\n\n\treturn AE_OK;\n}\n\nstatic const struct acpi_device_id norfkill_ids[] __initconst = {\n\t{ \"VPC2004\", 0},\n\t{ \"IBM0068\", 0},\n\t{ \"LEN0068\", 0},\n\t{ \"SNY5001\", 0},\t \n\t{ \"HPQ6601\", 0},\n\t{ \"\", 0},\n};\n\nstatic int __init AMW0_set_cap_acpi_check_device(void)\n{\n\tconst struct acpi_device_id *id;\n\n\tfor (id = norfkill_ids; id->id[0]; id++)\n\t\tif (acpi_dev_found(id->id))\n\t\t\treturn true;\n\n\treturn false;\n}\n\nstatic acpi_status __init AMW0_set_capabilities(void)\n{\n\tstruct wmab_args args;\n\tstruct wmab_ret ret;\n\tacpi_status status;\n\tstruct acpi_buffer out = { ACPI_ALLOCATE_BUFFER, NULL };\n\tunion acpi_object *obj;\n\n\t \n\tif (wmi_has_guid(AMW0_GUID2)) {\n\t\tif ((quirks != &quirk_unknown) ||\n\t\t    !AMW0_set_cap_acpi_check_device())\n\t\t\tinterface->capability |= ACER_CAP_WIRELESS;\n\t\treturn AE_OK;\n\t}\n\n\targs.eax = ACER_AMW0_WRITE;\n\targs.ecx = args.edx = 0;\n\n\targs.ebx = 0xa2 << 8;\n\targs.ebx |= ACER_AMW0_WIRELESS_MASK;\n\n\tstatus = wmab_execute(&args, &out);\n\tif (ACPI_FAILURE(status))\n\t\treturn status;\n\n\tobj = out.pointer;\n\tif (obj && obj->type == ACPI_TYPE_BUFFER &&\n\tobj->buffer.length == sizeof(struct wmab_ret)) {\n\t\tret = *((struct wmab_ret *) obj->buffer.pointer);\n\t} else {\n\t\tstatus = AE_ERROR;\n\t\tgoto out;\n\t}\n\n\tif (ret.eax & 0x1)\n\t\tinterface->capability |= ACER_CAP_WIRELESS;\n\n\targs.ebx = 2 << 8;\n\targs.ebx |= ACER_AMW0_BLUETOOTH_MASK;\n\n\t \n\tstatus = wmab_execute(&args, &out);\n\tif (ACPI_FAILURE(status))\n\t\tgoto out;\n\n\tobj = (union acpi_object *) out.pointer;\n\tif (obj && obj->type == ACPI_TYPE_BUFFER\n\t&& obj->buffer.length == sizeof(struct wmab_ret)) {\n\t\tret = *((struct wmab_ret *) obj->buffer.pointer);\n\t} else {\n\t\tstatus = AE_ERROR;\n\t\tgoto out;\n\t}\n\n\tif (ret.eax & 0x1)\n\t\tinterface->capability |= ACER_CAP_BLUETOOTH;\n\n\t \n\tif (quirks->brightness >= 0)\n\t\tinterface->capability |= ACER_CAP_BRIGHTNESS;\n\n\tstatus = AE_OK;\nout:\n\tkfree(out.pointer);\n\treturn status;\n}\n\nstatic struct wmi_interface AMW0_interface = {\n\t.type = ACER_AMW0,\n};\n\nstatic struct wmi_interface AMW0_V2_interface = {\n\t.type = ACER_AMW0_V2,\n};\n\n \nstatic acpi_status\nWMI_execute_u32(u32 method_id, u32 in, u32 *out)\n{\n\tstruct acpi_buffer input = { (acpi_size) sizeof(u32), (void *)(&in) };\n\tstruct acpi_buffer result = { ACPI_ALLOCATE_BUFFER, NULL };\n\tunion acpi_object *obj;\n\tu32 tmp = 0;\n\tacpi_status status;\n\n\tstatus = wmi_evaluate_method(WMID_GUID1, 0, method_id, &input, &result);\n\n\tif (ACPI_FAILURE(status))\n\t\treturn status;\n\n\tobj = (union acpi_object *) result.pointer;\n\tif (obj) {\n\t\tif (obj->type == ACPI_TYPE_BUFFER &&\n\t\t\t(obj->buffer.length == sizeof(u32) ||\n\t\t\tobj->buffer.length == sizeof(u64))) {\n\t\t\ttmp = *((u32 *) obj->buffer.pointer);\n\t\t} else if (obj->type == ACPI_TYPE_INTEGER) {\n\t\t\ttmp = (u32) obj->integer.value;\n\t\t}\n\t}\n\n\tif (out)\n\t\t*out = tmp;\n\n\tkfree(result.pointer);\n\n\treturn status;\n}\n\nstatic acpi_status WMID_get_u32(u32 *value, u32 cap)\n{\n\tacpi_status status;\n\tu8 tmp;\n\tu32 result, method_id = 0;\n\n\tswitch (cap) {\n\tcase ACER_CAP_WIRELESS:\n\t\tmethod_id = ACER_WMID_GET_WIRELESS_METHODID;\n\t\tbreak;\n\tcase ACER_CAP_BLUETOOTH:\n\t\tmethod_id = ACER_WMID_GET_BLUETOOTH_METHODID;\n\t\tbreak;\n\tcase ACER_CAP_BRIGHTNESS:\n\t\tmethod_id = ACER_WMID_GET_BRIGHTNESS_METHODID;\n\t\tbreak;\n\tcase ACER_CAP_THREEG:\n\t\tmethod_id = ACER_WMID_GET_THREEG_METHODID;\n\t\tbreak;\n\tcase ACER_CAP_MAILLED:\n\t\tif (quirks->mailled == 1) {\n\t\t\tec_read(0x9f, &tmp);\n\t\t\t*value = tmp & 0x1;\n\t\t\treturn 0;\n\t\t}\n\t\tfallthrough;\n\tdefault:\n\t\treturn AE_ERROR;\n\t}\n\tstatus = WMI_execute_u32(method_id, 0, &result);\n\n\tif (ACPI_SUCCESS(status))\n\t\t*value = (u8)result;\n\n\treturn status;\n}\n\nstatic acpi_status WMID_set_u32(u32 value, u32 cap)\n{\n\tu32 method_id = 0;\n\tchar param;\n\n\tswitch (cap) {\n\tcase ACER_CAP_BRIGHTNESS:\n\t\tif (value > max_brightness)\n\t\t\treturn AE_BAD_PARAMETER;\n\t\tmethod_id = ACER_WMID_SET_BRIGHTNESS_METHODID;\n\t\tbreak;\n\tcase ACER_CAP_WIRELESS:\n\t\tif (value > 1)\n\t\t\treturn AE_BAD_PARAMETER;\n\t\tmethod_id = ACER_WMID_SET_WIRELESS_METHODID;\n\t\tbreak;\n\tcase ACER_CAP_BLUETOOTH:\n\t\tif (value > 1)\n\t\t\treturn AE_BAD_PARAMETER;\n\t\tmethod_id = ACER_WMID_SET_BLUETOOTH_METHODID;\n\t\tbreak;\n\tcase ACER_CAP_THREEG:\n\t\tif (value > 1)\n\t\t\treturn AE_BAD_PARAMETER;\n\t\tmethod_id = ACER_WMID_SET_THREEG_METHODID;\n\t\tbreak;\n\tcase ACER_CAP_MAILLED:\n\t\tif (value > 1)\n\t\t\treturn AE_BAD_PARAMETER;\n\t\tif (quirks->mailled == 1) {\n\t\t\tparam = value ? 0x92 : 0x93;\n\t\t\ti8042_lock_chip();\n\t\t\ti8042_command(&param, 0x1059);\n\t\t\ti8042_unlock_chip();\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn AE_ERROR;\n\t}\n\treturn WMI_execute_u32(method_id, (u32)value, NULL);\n}\n\nstatic acpi_status wmid3_get_device_status(u32 *value, u16 device)\n{\n\tstruct wmid3_gds_return_value return_value;\n\tacpi_status status;\n\tunion acpi_object *obj;\n\tstruct wmid3_gds_get_input_param params = {\n\t\t.function_num = 0x1,\n\t\t.hotkey_number = commun_fn_key_number,\n\t\t.devices = device,\n\t};\n\tstruct acpi_buffer input = {\n\t\tsizeof(struct wmid3_gds_get_input_param),\n\t\t&params\n\t};\n\tstruct acpi_buffer output = { ACPI_ALLOCATE_BUFFER, NULL };\n\n\tstatus = wmi_evaluate_method(WMID_GUID3, 0, 0x2, &input, &output);\n\tif (ACPI_FAILURE(status))\n\t\treturn status;\n\n\tobj = output.pointer;\n\n\tif (!obj)\n\t\treturn AE_ERROR;\n\telse if (obj->type != ACPI_TYPE_BUFFER) {\n\t\tkfree(obj);\n\t\treturn AE_ERROR;\n\t}\n\tif (obj->buffer.length != 8) {\n\t\tpr_warn(\"Unknown buffer length %d\\n\", obj->buffer.length);\n\t\tkfree(obj);\n\t\treturn AE_ERROR;\n\t}\n\n\treturn_value = *((struct wmid3_gds_return_value *)obj->buffer.pointer);\n\tkfree(obj);\n\n\tif (return_value.error_code || return_value.ec_return_value)\n\t\tpr_warn(\"Get 0x%x Device Status failed: 0x%x - 0x%x\\n\",\n\t\t\tdevice,\n\t\t\treturn_value.error_code,\n\t\t\treturn_value.ec_return_value);\n\telse\n\t\t*value = !!(return_value.devices & device);\n\n\treturn status;\n}\n\nstatic acpi_status wmid_v2_get_u32(u32 *value, u32 cap)\n{\n\tu16 device;\n\n\tswitch (cap) {\n\tcase ACER_CAP_WIRELESS:\n\t\tdevice = ACER_WMID3_GDS_WIRELESS;\n\t\tbreak;\n\tcase ACER_CAP_BLUETOOTH:\n\t\tdevice = ACER_WMID3_GDS_BLUETOOTH;\n\t\tbreak;\n\tcase ACER_CAP_THREEG:\n\t\tdevice = ACER_WMID3_GDS_THREEG;\n\t\tbreak;\n\tdefault:\n\t\treturn AE_ERROR;\n\t}\n\treturn wmid3_get_device_status(value, device);\n}\n\nstatic acpi_status wmid3_set_device_status(u32 value, u16 device)\n{\n\tstruct wmid3_gds_return_value return_value;\n\tacpi_status status;\n\tunion acpi_object *obj;\n\tu16 devices;\n\tstruct wmid3_gds_get_input_param get_params = {\n\t\t.function_num = 0x1,\n\t\t.hotkey_number = commun_fn_key_number,\n\t\t.devices = commun_func_bitmap,\n\t};\n\tstruct acpi_buffer get_input = {\n\t\tsizeof(struct wmid3_gds_get_input_param),\n\t\t&get_params\n\t};\n\tstruct wmid3_gds_set_input_param set_params = {\n\t\t.function_num = 0x2,\n\t\t.hotkey_number = commun_fn_key_number,\n\t\t.devices = commun_func_bitmap,\n\t};\n\tstruct acpi_buffer set_input = {\n\t\tsizeof(struct wmid3_gds_set_input_param),\n\t\t&set_params\n\t};\n\tstruct acpi_buffer output = { ACPI_ALLOCATE_BUFFER, NULL };\n\tstruct acpi_buffer output2 = { ACPI_ALLOCATE_BUFFER, NULL };\n\n\tstatus = wmi_evaluate_method(WMID_GUID3, 0, 0x2, &get_input, &output);\n\tif (ACPI_FAILURE(status))\n\t\treturn status;\n\n\tobj = output.pointer;\n\n\tif (!obj)\n\t\treturn AE_ERROR;\n\telse if (obj->type != ACPI_TYPE_BUFFER) {\n\t\tkfree(obj);\n\t\treturn AE_ERROR;\n\t}\n\tif (obj->buffer.length != 8) {\n\t\tpr_warn(\"Unknown buffer length %d\\n\", obj->buffer.length);\n\t\tkfree(obj);\n\t\treturn AE_ERROR;\n\t}\n\n\treturn_value = *((struct wmid3_gds_return_value *)obj->buffer.pointer);\n\tkfree(obj);\n\n\tif (return_value.error_code || return_value.ec_return_value) {\n\t\tpr_warn(\"Get Current Device Status failed: 0x%x - 0x%x\\n\",\n\t\t\treturn_value.error_code,\n\t\t\treturn_value.ec_return_value);\n\t\treturn status;\n\t}\n\n\tdevices = return_value.devices;\n\tset_params.devices = (value) ? (devices | device) : (devices & ~device);\n\n\tstatus = wmi_evaluate_method(WMID_GUID3, 0, 0x1, &set_input, &output2);\n\tif (ACPI_FAILURE(status))\n\t\treturn status;\n\n\tobj = output2.pointer;\n\n\tif (!obj)\n\t\treturn AE_ERROR;\n\telse if (obj->type != ACPI_TYPE_BUFFER) {\n\t\tkfree(obj);\n\t\treturn AE_ERROR;\n\t}\n\tif (obj->buffer.length != 4) {\n\t\tpr_warn(\"Unknown buffer length %d\\n\", obj->buffer.length);\n\t\tkfree(obj);\n\t\treturn AE_ERROR;\n\t}\n\n\treturn_value = *((struct wmid3_gds_return_value *)obj->buffer.pointer);\n\tkfree(obj);\n\n\tif (return_value.error_code || return_value.ec_return_value)\n\t\tpr_warn(\"Set Device Status failed: 0x%x - 0x%x\\n\",\n\t\t\treturn_value.error_code,\n\t\t\treturn_value.ec_return_value);\n\n\treturn status;\n}\n\nstatic acpi_status wmid_v2_set_u32(u32 value, u32 cap)\n{\n\tu16 device;\n\n\tswitch (cap) {\n\tcase ACER_CAP_WIRELESS:\n\t\tdevice = ACER_WMID3_GDS_WIRELESS;\n\t\tbreak;\n\tcase ACER_CAP_BLUETOOTH:\n\t\tdevice = ACER_WMID3_GDS_BLUETOOTH;\n\t\tbreak;\n\tcase ACER_CAP_THREEG:\n\t\tdevice = ACER_WMID3_GDS_THREEG;\n\t\tbreak;\n\tdefault:\n\t\treturn AE_ERROR;\n\t}\n\treturn wmid3_set_device_status(value, device);\n}\n\nstatic void __init type_aa_dmi_decode(const struct dmi_header *header, void *d)\n{\n\tstruct hotkey_function_type_aa *type_aa;\n\n\t \n\tif (header->type != 0xAA)\n\t\treturn;\n\n\thas_type_aa = true;\n\ttype_aa = (struct hotkey_function_type_aa *) header;\n\n\tpr_info(\"Function bitmap for Communication Button: 0x%x\\n\",\n\t\ttype_aa->commun_func_bitmap);\n\tcommun_func_bitmap = type_aa->commun_func_bitmap;\n\n\tif (type_aa->commun_func_bitmap & ACER_WMID3_GDS_WIRELESS)\n\t\tinterface->capability |= ACER_CAP_WIRELESS;\n\tif (type_aa->commun_func_bitmap & ACER_WMID3_GDS_THREEG)\n\t\tinterface->capability |= ACER_CAP_THREEG;\n\tif (type_aa->commun_func_bitmap & ACER_WMID3_GDS_BLUETOOTH)\n\t\tinterface->capability |= ACER_CAP_BLUETOOTH;\n\tif (type_aa->commun_func_bitmap & ACER_WMID3_GDS_RFBTN)\n\t\tcommun_func_bitmap &= ~ACER_WMID3_GDS_RFBTN;\n\n\tcommun_fn_key_number = type_aa->commun_fn_key_number;\n}\n\nstatic acpi_status __init WMID_set_capabilities(void)\n{\n\tstruct acpi_buffer out = {ACPI_ALLOCATE_BUFFER, NULL};\n\tunion acpi_object *obj;\n\tacpi_status status;\n\tu32 devices;\n\n\tstatus = wmi_query_block(WMID_GUID2, 0, &out);\n\tif (ACPI_FAILURE(status))\n\t\treturn status;\n\n\tobj = (union acpi_object *) out.pointer;\n\tif (obj) {\n\t\tif (obj->type == ACPI_TYPE_BUFFER &&\n\t\t\t(obj->buffer.length == sizeof(u32) ||\n\t\t\tobj->buffer.length == sizeof(u64))) {\n\t\t\tdevices = *((u32 *) obj->buffer.pointer);\n\t\t} else if (obj->type == ACPI_TYPE_INTEGER) {\n\t\t\tdevices = (u32) obj->integer.value;\n\t\t} else {\n\t\t\tkfree(out.pointer);\n\t\t\treturn AE_ERROR;\n\t\t}\n\t} else {\n\t\tkfree(out.pointer);\n\t\treturn AE_ERROR;\n\t}\n\n\tpr_info(\"Function bitmap for Communication Device: 0x%x\\n\", devices);\n\tif (devices & 0x07)\n\t\tinterface->capability |= ACER_CAP_WIRELESS;\n\tif (devices & 0x40)\n\t\tinterface->capability |= ACER_CAP_THREEG;\n\tif (devices & 0x10)\n\t\tinterface->capability |= ACER_CAP_BLUETOOTH;\n\n\tif (!(devices & 0x20))\n\t\tmax_brightness = 0x9;\n\n\tkfree(out.pointer);\n\treturn status;\n}\n\nstatic struct wmi_interface wmid_interface = {\n\t.type = ACER_WMID,\n};\n\nstatic struct wmi_interface wmid_v2_interface = {\n\t.type = ACER_WMID_v2,\n};\n\n \n\nstatic acpi_status\nWMI_gaming_execute_u64(u32 method_id, u64 in, u64 *out)\n{\n\tstruct acpi_buffer input = { (acpi_size) sizeof(u64), (void *)(&in) };\n\tstruct acpi_buffer result = { ACPI_ALLOCATE_BUFFER, NULL };\n\tunion acpi_object *obj;\n\tu32 tmp = 0;\n\tacpi_status status;\n\n\tstatus = wmi_evaluate_method(WMID_GUID4, 0, method_id, &input, &result);\n\n\tif (ACPI_FAILURE(status))\n\t\treturn status;\n\tobj = (union acpi_object *) result.pointer;\n\n\tif (obj) {\n\t\tif (obj->type == ACPI_TYPE_BUFFER) {\n\t\t\tif (obj->buffer.length == sizeof(u32))\n\t\t\t\ttmp = *((u32 *) obj->buffer.pointer);\n\t\t\telse if (obj->buffer.length == sizeof(u64))\n\t\t\t\ttmp = *((u64 *) obj->buffer.pointer);\n\t\t} else if (obj->type == ACPI_TYPE_INTEGER) {\n\t\t\ttmp = (u64) obj->integer.value;\n\t\t}\n\t}\n\n\tif (out)\n\t\t*out = tmp;\n\n\tkfree(result.pointer);\n\n\treturn status;\n}\n\nstatic acpi_status WMID_gaming_set_u64(u64 value, u32 cap)\n{\n\tu32 method_id = 0;\n\n\tif (!(interface->capability & cap))\n\t\treturn AE_BAD_PARAMETER;\n\n\tswitch (cap) {\n\tcase ACER_CAP_TURBO_LED:\n\t\tmethod_id = ACER_WMID_SET_GAMING_LED_METHODID;\n\t\tbreak;\n\tcase ACER_CAP_TURBO_FAN:\n\t\tmethod_id = ACER_WMID_SET_GAMING_FAN_BEHAVIOR;\n\t\tbreak;\n\tcase ACER_CAP_TURBO_OC:\n\t\tmethod_id = ACER_WMID_SET_GAMING_MISC_SETTING_METHODID;\n\t\tbreak;\n\tdefault:\n\t\treturn AE_BAD_PARAMETER;\n\t}\n\n\treturn WMI_gaming_execute_u64(method_id, value, NULL);\n}\n\nstatic acpi_status WMID_gaming_get_u64(u64 *value, u32 cap)\n{\n\tacpi_status status;\n\tu64 result;\n\tu64 input;\n\tu32 method_id;\n\n\tif (!(interface->capability & cap))\n\t\treturn AE_BAD_PARAMETER;\n\n\tswitch (cap) {\n\tcase ACER_CAP_TURBO_LED:\n\t\tmethod_id = ACER_WMID_GET_GAMING_LED_METHODID;\n\t\tinput = 0x1;\n\t\tbreak;\n\tdefault:\n\t\treturn AE_BAD_PARAMETER;\n\t}\n\tstatus = WMI_gaming_execute_u64(method_id, input, &result);\n\tif (ACPI_SUCCESS(status))\n\t\t*value = (u64) result;\n\n\treturn status;\n}\n\nstatic void WMID_gaming_set_fan_mode(u8 fan_mode)\n{\n\t \n\tu64 gpu_fan_config1 = 0, gpu_fan_config2 = 0;\n\tint i;\n\n\tif (quirks->cpu_fans > 0)\n\t\tgpu_fan_config2 |= 1;\n\tfor (i = 0; i < (quirks->cpu_fans + quirks->gpu_fans); ++i)\n\t\tgpu_fan_config2 |= 1 << (i + 1);\n\tfor (i = 0; i < quirks->gpu_fans; ++i)\n\t\tgpu_fan_config2 |= 1 << (i + 3);\n\tif (quirks->cpu_fans > 0)\n\t\tgpu_fan_config1 |= fan_mode;\n\tfor (i = 0; i < (quirks->cpu_fans + quirks->gpu_fans); ++i)\n\t\tgpu_fan_config1 |= fan_mode << (2 * i + 2);\n\tfor (i = 0; i < quirks->gpu_fans; ++i)\n\t\tgpu_fan_config1 |= fan_mode << (2 * i + 6);\n\tWMID_gaming_set_u64(gpu_fan_config2 | gpu_fan_config1 << 16, ACER_CAP_TURBO_FAN);\n}\n\n \n\nstatic acpi_status get_u32(u32 *value, u32 cap)\n{\n\tacpi_status status = AE_ERROR;\n\n\tswitch (interface->type) {\n\tcase ACER_AMW0:\n\t\tstatus = AMW0_get_u32(value, cap);\n\t\tbreak;\n\tcase ACER_AMW0_V2:\n\t\tif (cap == ACER_CAP_MAILLED) {\n\t\t\tstatus = AMW0_get_u32(value, cap);\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tcase ACER_WMID:\n\t\tstatus = WMID_get_u32(value, cap);\n\t\tbreak;\n\tcase ACER_WMID_v2:\n\t\tif (cap & (ACER_CAP_WIRELESS |\n\t\t\t   ACER_CAP_BLUETOOTH |\n\t\t\t   ACER_CAP_THREEG))\n\t\t\tstatus = wmid_v2_get_u32(value, cap);\n\t\telse if (wmi_has_guid(WMID_GUID2))\n\t\t\tstatus = WMID_get_u32(value, cap);\n\t\tbreak;\n\t}\n\n\treturn status;\n}\n\nstatic acpi_status set_u32(u32 value, u32 cap)\n{\n\tacpi_status status;\n\n\tif (interface->capability & cap) {\n\t\tswitch (interface->type) {\n\t\tcase ACER_AMW0:\n\t\t\treturn AMW0_set_u32(value, cap);\n\t\tcase ACER_AMW0_V2:\n\t\t\tif (cap == ACER_CAP_MAILLED)\n\t\t\t\treturn AMW0_set_u32(value, cap);\n\n\t\t\t \n\t\t\tif (cap == ACER_CAP_WIRELESS ||\n\t\t\t\tcap == ACER_CAP_BLUETOOTH) {\n\t\t\t\tstatus = WMID_set_u32(value, cap);\n\t\t\t\tif (ACPI_FAILURE(status))\n\t\t\t\t\treturn status;\n\n\t\t\t\treturn AMW0_set_u32(value, cap);\n\t\t\t}\n\t\t\tfallthrough;\n\t\tcase ACER_WMID:\n\t\t\treturn WMID_set_u32(value, cap);\n\t\tcase ACER_WMID_v2:\n\t\t\tif (cap & (ACER_CAP_WIRELESS |\n\t\t\t\t   ACER_CAP_BLUETOOTH |\n\t\t\t\t   ACER_CAP_THREEG))\n\t\t\t\treturn wmid_v2_set_u32(value, cap);\n\t\t\telse if (wmi_has_guid(WMID_GUID2))\n\t\t\t\treturn WMID_set_u32(value, cap);\n\t\t\tfallthrough;\n\t\tdefault:\n\t\t\treturn AE_BAD_PARAMETER;\n\t\t}\n\t}\n\treturn AE_BAD_PARAMETER;\n}\n\nstatic void __init acer_commandline_init(void)\n{\n\t \n\tif (mailled >= 0)\n\t\tset_u32(mailled, ACER_CAP_MAILLED);\n\tif (!has_type_aa && threeg >= 0)\n\t\tset_u32(threeg, ACER_CAP_THREEG);\n\tif (brightness >= 0)\n\t\tset_u32(brightness, ACER_CAP_BRIGHTNESS);\n}\n\n \nstatic void mail_led_set(struct led_classdev *led_cdev,\nenum led_brightness value)\n{\n\tset_u32(value, ACER_CAP_MAILLED);\n}\n\nstatic struct led_classdev mail_led = {\n\t.name = \"acer-wmi::mail\",\n\t.brightness_set = mail_led_set,\n};\n\nstatic int acer_led_init(struct device *dev)\n{\n\treturn led_classdev_register(dev, &mail_led);\n}\n\nstatic void acer_led_exit(void)\n{\n\tset_u32(LED_OFF, ACER_CAP_MAILLED);\n\tled_classdev_unregister(&mail_led);\n}\n\n \nstatic struct backlight_device *acer_backlight_device;\n\nstatic int read_brightness(struct backlight_device *bd)\n{\n\tu32 value;\n\tget_u32(&value, ACER_CAP_BRIGHTNESS);\n\treturn value;\n}\n\nstatic int update_bl_status(struct backlight_device *bd)\n{\n\tint intensity = backlight_get_brightness(bd);\n\n\tset_u32(intensity, ACER_CAP_BRIGHTNESS);\n\n\treturn 0;\n}\n\nstatic const struct backlight_ops acer_bl_ops = {\n\t.get_brightness = read_brightness,\n\t.update_status = update_bl_status,\n};\n\nstatic int acer_backlight_init(struct device *dev)\n{\n\tstruct backlight_properties props;\n\tstruct backlight_device *bd;\n\n\tmemset(&props, 0, sizeof(struct backlight_properties));\n\tprops.type = BACKLIGHT_PLATFORM;\n\tprops.max_brightness = max_brightness;\n\tbd = backlight_device_register(\"acer-wmi\", dev, NULL, &acer_bl_ops,\n\t\t\t\t       &props);\n\tif (IS_ERR(bd)) {\n\t\tpr_err(\"Could not register Acer backlight device\\n\");\n\t\tacer_backlight_device = NULL;\n\t\treturn PTR_ERR(bd);\n\t}\n\n\tacer_backlight_device = bd;\n\n\tbd->props.power = FB_BLANK_UNBLANK;\n\tbd->props.brightness = read_brightness(bd);\n\tbacklight_update_status(bd);\n\treturn 0;\n}\n\nstatic void acer_backlight_exit(void)\n{\n\tbacklight_device_unregister(acer_backlight_device);\n}\n\n \nstatic acpi_handle gsensor_handle;\n\nstatic int acer_gsensor_init(void)\n{\n\tacpi_status status;\n\tstruct acpi_buffer output;\n\tunion acpi_object out_obj;\n\n\toutput.length = sizeof(out_obj);\n\toutput.pointer = &out_obj;\n\tstatus = acpi_evaluate_object(gsensor_handle, \"_INI\", NULL, &output);\n\tif (ACPI_FAILURE(status))\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic int acer_gsensor_open(struct input_dev *input)\n{\n\treturn acer_gsensor_init();\n}\n\nstatic int acer_gsensor_event(void)\n{\n\tacpi_status status;\n\tstruct acpi_buffer output;\n\tunion acpi_object out_obj[5];\n\n\tif (!acer_wmi_accel_dev)\n\t\treturn -1;\n\n\toutput.length = sizeof(out_obj);\n\toutput.pointer = out_obj;\n\n\tstatus = acpi_evaluate_object(gsensor_handle, \"RDVL\", NULL, &output);\n\tif (ACPI_FAILURE(status))\n\t\treturn -1;\n\n\tif (out_obj->package.count != 4)\n\t\treturn -1;\n\n\tinput_report_abs(acer_wmi_accel_dev, ABS_X,\n\t\t(s16)out_obj->package.elements[0].integer.value);\n\tinput_report_abs(acer_wmi_accel_dev, ABS_Y,\n\t\t(s16)out_obj->package.elements[1].integer.value);\n\tinput_report_abs(acer_wmi_accel_dev, ABS_Z,\n\t\t(s16)out_obj->package.elements[2].integer.value);\n\tinput_sync(acer_wmi_accel_dev);\n\treturn 0;\n}\n\n \nstatic int acer_toggle_turbo(void)\n{\n\tu64 turbo_led_state;\n\n\t \n\tif (ACPI_FAILURE(WMID_gaming_get_u64(&turbo_led_state, ACER_CAP_TURBO_LED)))\n\t\treturn -1;\n\n\tif (turbo_led_state) {\n\t\t \n\t\tWMID_gaming_set_u64(0x1, ACER_CAP_TURBO_LED);\n\n\t\t \n\t\tWMID_gaming_set_fan_mode(0x1);\n\n\t\t \n\t\tWMID_gaming_set_u64(0x5, ACER_CAP_TURBO_OC);\n\t\tWMID_gaming_set_u64(0x7, ACER_CAP_TURBO_OC);\n\t} else {\n\t\t \n\t\tWMID_gaming_set_u64(0x10001, ACER_CAP_TURBO_LED);\n\n\t\t \n\t\tWMID_gaming_set_fan_mode(0x2);\n\n\t\t \n\t\tWMID_gaming_set_u64(0x205, ACER_CAP_TURBO_OC);\n\t\tWMID_gaming_set_u64(0x207, ACER_CAP_TURBO_OC);\n\t}\n\treturn turbo_led_state;\n}\n\n \nstatic int acer_kbd_dock_state_to_sw_tablet_mode(u8 kbd_dock_state)\n{\n\tswitch (kbd_dock_state) {\n\tcase 0x01:  \n\t\treturn 0;\n\tcase 0x04:  \n\tcase 0x40:  \n\t\treturn 1;\n\tdefault:\n\t\tpr_warn(\"Unknown kbd_dock_state 0x%02x\\n\", kbd_dock_state);\n\t}\n\n\treturn 0;\n}\n\nstatic void acer_kbd_dock_get_initial_state(void)\n{\n\tu8 *output, input[8] = { 0x05, 0x00, };\n\tstruct acpi_buffer input_buf = { sizeof(input), input };\n\tstruct acpi_buffer output_buf = { ACPI_ALLOCATE_BUFFER, NULL };\n\tunion acpi_object *obj;\n\tacpi_status status;\n\tint sw_tablet_mode;\n\n\tstatus = wmi_evaluate_method(WMID_GUID3, 0, 0x2, &input_buf, &output_buf);\n\tif (ACPI_FAILURE(status)) {\n\t\tpr_err(\"Error getting keyboard-dock initial status: %s\\n\",\n\t\t       acpi_format_exception(status));\n\t\treturn;\n\t}\n\n\tobj = output_buf.pointer;\n\tif (!obj || obj->type != ACPI_TYPE_BUFFER || obj->buffer.length != 8) {\n\t\tpr_err(\"Unexpected output format getting keyboard-dock initial status\\n\");\n\t\tgoto out_free_obj;\n\t}\n\n\toutput = obj->buffer.pointer;\n\tif (output[0] != 0x00 || (output[3] != 0x05 && output[3] != 0x45)) {\n\t\tpr_err(\"Unexpected output [0]=0x%02x [3]=0x%02x getting keyboard-dock initial status\\n\",\n\t\t       output[0], output[3]);\n\t\tgoto out_free_obj;\n\t}\n\n\tsw_tablet_mode = acer_kbd_dock_state_to_sw_tablet_mode(output[4]);\n\tinput_report_switch(acer_wmi_input_dev, SW_TABLET_MODE, sw_tablet_mode);\n\nout_free_obj:\n\tkfree(obj);\n}\n\nstatic void acer_kbd_dock_event(const struct event_return_value *event)\n{\n\tint sw_tablet_mode;\n\n\tif (!has_cap(ACER_CAP_KBD_DOCK))\n\t\treturn;\n\n\tsw_tablet_mode = acer_kbd_dock_state_to_sw_tablet_mode(event->kbd_dock_state);\n\tinput_report_switch(acer_wmi_input_dev, SW_TABLET_MODE, sw_tablet_mode);\n\tinput_sync(acer_wmi_input_dev);\n}\n\n \nstatic void acer_rfkill_update(struct work_struct *ignored);\nstatic DECLARE_DELAYED_WORK(acer_rfkill_work, acer_rfkill_update);\nstatic void acer_rfkill_update(struct work_struct *ignored)\n{\n\tu32 state;\n\tacpi_status status;\n\n\tif (has_cap(ACER_CAP_WIRELESS)) {\n\t\tstatus = get_u32(&state, ACER_CAP_WIRELESS);\n\t\tif (ACPI_SUCCESS(status)) {\n\t\t\tif (quirks->wireless == 3)\n\t\t\t\trfkill_set_hw_state(wireless_rfkill, !state);\n\t\t\telse\n\t\t\t\trfkill_set_sw_state(wireless_rfkill, !state);\n\t\t}\n\t}\n\n\tif (has_cap(ACER_CAP_BLUETOOTH)) {\n\t\tstatus = get_u32(&state, ACER_CAP_BLUETOOTH);\n\t\tif (ACPI_SUCCESS(status))\n\t\t\trfkill_set_sw_state(bluetooth_rfkill, !state);\n\t}\n\n\tif (has_cap(ACER_CAP_THREEG) && wmi_has_guid(WMID_GUID3)) {\n\t\tstatus = get_u32(&state, ACER_WMID3_GDS_THREEG);\n\t\tif (ACPI_SUCCESS(status))\n\t\t\trfkill_set_sw_state(threeg_rfkill, !state);\n\t}\n\n\tschedule_delayed_work(&acer_rfkill_work, round_jiffies_relative(HZ));\n}\n\nstatic int acer_rfkill_set(void *data, bool blocked)\n{\n\tacpi_status status;\n\tu32 cap = (unsigned long)data;\n\n\tif (rfkill_inited) {\n\t\tstatus = set_u32(!blocked, cap);\n\t\tif (ACPI_FAILURE(status))\n\t\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct rfkill_ops acer_rfkill_ops = {\n\t.set_block = acer_rfkill_set,\n};\n\nstatic struct rfkill *acer_rfkill_register(struct device *dev,\n\t\t\t\t\t   enum rfkill_type type,\n\t\t\t\t\t   char *name, u32 cap)\n{\n\tint err;\n\tstruct rfkill *rfkill_dev;\n\tu32 state;\n\tacpi_status status;\n\n\trfkill_dev = rfkill_alloc(name, dev, type,\n\t\t\t\t  &acer_rfkill_ops,\n\t\t\t\t  (void *)(unsigned long)cap);\n\tif (!rfkill_dev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tstatus = get_u32(&state, cap);\n\n\terr = rfkill_register(rfkill_dev);\n\tif (err) {\n\t\trfkill_destroy(rfkill_dev);\n\t\treturn ERR_PTR(err);\n\t}\n\n\tif (ACPI_SUCCESS(status))\n\t\trfkill_set_sw_state(rfkill_dev, !state);\n\n\treturn rfkill_dev;\n}\n\nstatic int acer_rfkill_init(struct device *dev)\n{\n\tint err;\n\n\tif (has_cap(ACER_CAP_WIRELESS)) {\n\t\twireless_rfkill = acer_rfkill_register(dev, RFKILL_TYPE_WLAN,\n\t\t\t\"acer-wireless\", ACER_CAP_WIRELESS);\n\t\tif (IS_ERR(wireless_rfkill)) {\n\t\t\terr = PTR_ERR(wireless_rfkill);\n\t\t\tgoto error_wireless;\n\t\t}\n\t}\n\n\tif (has_cap(ACER_CAP_BLUETOOTH)) {\n\t\tbluetooth_rfkill = acer_rfkill_register(dev,\n\t\t\tRFKILL_TYPE_BLUETOOTH, \"acer-bluetooth\",\n\t\t\tACER_CAP_BLUETOOTH);\n\t\tif (IS_ERR(bluetooth_rfkill)) {\n\t\t\terr = PTR_ERR(bluetooth_rfkill);\n\t\t\tgoto error_bluetooth;\n\t\t}\n\t}\n\n\tif (has_cap(ACER_CAP_THREEG)) {\n\t\tthreeg_rfkill = acer_rfkill_register(dev,\n\t\t\tRFKILL_TYPE_WWAN, \"acer-threeg\",\n\t\t\tACER_CAP_THREEG);\n\t\tif (IS_ERR(threeg_rfkill)) {\n\t\t\terr = PTR_ERR(threeg_rfkill);\n\t\t\tgoto error_threeg;\n\t\t}\n\t}\n\n\trfkill_inited = true;\n\n\tif ((ec_raw_mode || !wmi_has_guid(ACERWMID_EVENT_GUID)) &&\n\t    has_cap(ACER_CAP_WIRELESS | ACER_CAP_BLUETOOTH | ACER_CAP_THREEG))\n\t\tschedule_delayed_work(&acer_rfkill_work,\n\t\t\tround_jiffies_relative(HZ));\n\n\treturn 0;\n\nerror_threeg:\n\tif (has_cap(ACER_CAP_BLUETOOTH)) {\n\t\trfkill_unregister(bluetooth_rfkill);\n\t\trfkill_destroy(bluetooth_rfkill);\n\t}\nerror_bluetooth:\n\tif (has_cap(ACER_CAP_WIRELESS)) {\n\t\trfkill_unregister(wireless_rfkill);\n\t\trfkill_destroy(wireless_rfkill);\n\t}\nerror_wireless:\n\treturn err;\n}\n\nstatic void acer_rfkill_exit(void)\n{\n\tif ((ec_raw_mode || !wmi_has_guid(ACERWMID_EVENT_GUID)) &&\n\t    has_cap(ACER_CAP_WIRELESS | ACER_CAP_BLUETOOTH | ACER_CAP_THREEG))\n\t\tcancel_delayed_work_sync(&acer_rfkill_work);\n\n\tif (has_cap(ACER_CAP_WIRELESS)) {\n\t\trfkill_unregister(wireless_rfkill);\n\t\trfkill_destroy(wireless_rfkill);\n\t}\n\n\tif (has_cap(ACER_CAP_BLUETOOTH)) {\n\t\trfkill_unregister(bluetooth_rfkill);\n\t\trfkill_destroy(bluetooth_rfkill);\n\t}\n\n\tif (has_cap(ACER_CAP_THREEG)) {\n\t\trfkill_unregister(threeg_rfkill);\n\t\trfkill_destroy(threeg_rfkill);\n\t}\n\treturn;\n}\n\nstatic void acer_wmi_notify(u32 value, void *context)\n{\n\tstruct acpi_buffer response = { ACPI_ALLOCATE_BUFFER, NULL };\n\tunion acpi_object *obj;\n\tstruct event_return_value return_value;\n\tacpi_status status;\n\tu16 device_state;\n\tconst struct key_entry *key;\n\tu32 scancode;\n\n\tstatus = wmi_get_event_data(value, &response);\n\tif (status != AE_OK) {\n\t\tpr_warn(\"bad event status 0x%x\\n\", status);\n\t\treturn;\n\t}\n\n\tobj = (union acpi_object *)response.pointer;\n\n\tif (!obj)\n\t\treturn;\n\tif (obj->type != ACPI_TYPE_BUFFER) {\n\t\tpr_warn(\"Unknown response received %d\\n\", obj->type);\n\t\tkfree(obj);\n\t\treturn;\n\t}\n\tif (obj->buffer.length != 8) {\n\t\tpr_warn(\"Unknown buffer length %d\\n\", obj->buffer.length);\n\t\tkfree(obj);\n\t\treturn;\n\t}\n\n\treturn_value = *((struct event_return_value *)obj->buffer.pointer);\n\tkfree(obj);\n\n\tswitch (return_value.function) {\n\tcase WMID_HOTKEY_EVENT:\n\t\tdevice_state = return_value.device_state;\n\t\tpr_debug(\"device state: 0x%x\\n\", device_state);\n\n\t\tkey = sparse_keymap_entry_from_scancode(acer_wmi_input_dev,\n\t\t\t\t\t\t\treturn_value.key_num);\n\t\tif (!key) {\n\t\t\tpr_warn(\"Unknown key number - 0x%x\\n\",\n\t\t\t\treturn_value.key_num);\n\t\t} else {\n\t\t\tscancode = return_value.key_num;\n\t\t\tswitch (key->keycode) {\n\t\t\tcase KEY_WLAN:\n\t\t\tcase KEY_BLUETOOTH:\n\t\t\t\tif (has_cap(ACER_CAP_WIRELESS))\n\t\t\t\t\trfkill_set_sw_state(wireless_rfkill,\n\t\t\t\t\t\t!(device_state & ACER_WMID3_GDS_WIRELESS));\n\t\t\t\tif (has_cap(ACER_CAP_THREEG))\n\t\t\t\t\trfkill_set_sw_state(threeg_rfkill,\n\t\t\t\t\t\t!(device_state & ACER_WMID3_GDS_THREEG));\n\t\t\t\tif (has_cap(ACER_CAP_BLUETOOTH))\n\t\t\t\t\trfkill_set_sw_state(bluetooth_rfkill,\n\t\t\t\t\t\t!(device_state & ACER_WMID3_GDS_BLUETOOTH));\n\t\t\t\tbreak;\n\t\t\tcase KEY_TOUCHPAD_TOGGLE:\n\t\t\t\tscancode = (device_state & ACER_WMID3_GDS_TOUCHPAD) ?\n\t\t\t\t\t\tKEY_TOUCHPAD_ON : KEY_TOUCHPAD_OFF;\n\t\t\t}\n\t\t\tsparse_keymap_report_event(acer_wmi_input_dev, scancode, 1, true);\n\t\t}\n\t\tbreak;\n\tcase WMID_ACCEL_OR_KBD_DOCK_EVENT:\n\t\tacer_gsensor_event();\n\t\tacer_kbd_dock_event(&return_value);\n\t\tbreak;\n\tcase WMID_GAMING_TURBO_KEY_EVENT:\n\t\tif (return_value.key_num == 0x4)\n\t\t\tacer_toggle_turbo();\n\t\tbreak;\n\tdefault:\n\t\tpr_warn(\"Unknown function number - %d - %d\\n\",\n\t\t\treturn_value.function, return_value.key_num);\n\t\tbreak;\n\t}\n}\n\nstatic acpi_status __init\nwmid3_set_function_mode(struct func_input_params *params,\n\t\t\tstruct func_return_value *return_value)\n{\n\tacpi_status status;\n\tunion acpi_object *obj;\n\n\tstruct acpi_buffer input = { sizeof(struct func_input_params), params };\n\tstruct acpi_buffer output = { ACPI_ALLOCATE_BUFFER, NULL };\n\n\tstatus = wmi_evaluate_method(WMID_GUID3, 0, 0x1, &input, &output);\n\tif (ACPI_FAILURE(status))\n\t\treturn status;\n\n\tobj = output.pointer;\n\n\tif (!obj)\n\t\treturn AE_ERROR;\n\telse if (obj->type != ACPI_TYPE_BUFFER) {\n\t\tkfree(obj);\n\t\treturn AE_ERROR;\n\t}\n\tif (obj->buffer.length != 4) {\n\t\tpr_warn(\"Unknown buffer length %d\\n\", obj->buffer.length);\n\t\tkfree(obj);\n\t\treturn AE_ERROR;\n\t}\n\n\t*return_value = *((struct func_return_value *)obj->buffer.pointer);\n\tkfree(obj);\n\n\treturn status;\n}\n\nstatic int __init acer_wmi_enable_ec_raw(void)\n{\n\tstruct func_return_value return_value;\n\tacpi_status status;\n\tstruct func_input_params params = {\n\t\t.function_num = 0x1,\n\t\t.commun_devices = 0xFFFF,\n\t\t.devices = 0xFFFF,\n\t\t.app_status = 0x00,\t\t \n\t\t.app_mask = 0x01,\n\t};\n\n\tstatus = wmid3_set_function_mode(&params, &return_value);\n\n\tif (return_value.error_code || return_value.ec_return_value)\n\t\tpr_warn(\"Enabling EC raw mode failed: 0x%x - 0x%x\\n\",\n\t\t\treturn_value.error_code,\n\t\t\treturn_value.ec_return_value);\n\telse\n\t\tpr_info(\"Enabled EC raw mode\\n\");\n\n\treturn status;\n}\n\nstatic int __init acer_wmi_enable_lm(void)\n{\n\tstruct func_return_value return_value;\n\tacpi_status status;\n\tstruct func_input_params params = {\n\t\t.function_num = 0x1,\n\t\t.commun_devices = 0xFFFF,\n\t\t.devices = 0xFFFF,\n\t\t.app_status = 0x01,             \n\t\t.app_mask = 0x01,\n\t};\n\n\tstatus = wmid3_set_function_mode(&params, &return_value);\n\n\tif (return_value.error_code || return_value.ec_return_value)\n\t\tpr_warn(\"Enabling Launch Manager failed: 0x%x - 0x%x\\n\",\n\t\t\treturn_value.error_code,\n\t\t\treturn_value.ec_return_value);\n\n\treturn status;\n}\n\nstatic int __init acer_wmi_enable_rf_button(void)\n{\n\tstruct func_return_value return_value;\n\tacpi_status status;\n\tstruct func_input_params params = {\n\t\t.function_num = 0x1,\n\t\t.commun_devices = 0xFFFF,\n\t\t.devices = 0xFFFF,\n\t\t.app_status = 0x10,             \n\t\t.app_mask = 0x10,\n\t};\n\n\tstatus = wmid3_set_function_mode(&params, &return_value);\n\n\tif (return_value.error_code || return_value.ec_return_value)\n\t\tpr_warn(\"Enabling RF Button failed: 0x%x - 0x%x\\n\",\n\t\t\treturn_value.error_code,\n\t\t\treturn_value.ec_return_value);\n\n\treturn status;\n}\n\nstatic int __init acer_wmi_accel_setup(void)\n{\n\tstruct acpi_device *adev;\n\tint err;\n\n\tadev = acpi_dev_get_first_match_dev(\"BST0001\", NULL, -1);\n\tif (!adev)\n\t\treturn -ENODEV;\n\n\tgsensor_handle = acpi_device_handle(adev);\n\tacpi_dev_put(adev);\n\n\tacer_wmi_accel_dev = input_allocate_device();\n\tif (!acer_wmi_accel_dev)\n\t\treturn -ENOMEM;\n\n\tacer_wmi_accel_dev->open = acer_gsensor_open;\n\n\tacer_wmi_accel_dev->name = \"Acer BMA150 accelerometer\";\n\tacer_wmi_accel_dev->phys = \"wmi/input1\";\n\tacer_wmi_accel_dev->id.bustype = BUS_HOST;\n\tacer_wmi_accel_dev->evbit[0] = BIT_MASK(EV_ABS);\n\tinput_set_abs_params(acer_wmi_accel_dev, ABS_X, -16384, 16384, 0, 0);\n\tinput_set_abs_params(acer_wmi_accel_dev, ABS_Y, -16384, 16384, 0, 0);\n\tinput_set_abs_params(acer_wmi_accel_dev, ABS_Z, -16384, 16384, 0, 0);\n\n\terr = input_register_device(acer_wmi_accel_dev);\n\tif (err)\n\t\tgoto err_free_dev;\n\n\treturn 0;\n\nerr_free_dev:\n\tinput_free_device(acer_wmi_accel_dev);\n\treturn err;\n}\n\nstatic int __init acer_wmi_input_setup(void)\n{\n\tacpi_status status;\n\tint err;\n\n\tacer_wmi_input_dev = input_allocate_device();\n\tif (!acer_wmi_input_dev)\n\t\treturn -ENOMEM;\n\n\tacer_wmi_input_dev->name = \"Acer WMI hotkeys\";\n\tacer_wmi_input_dev->phys = \"wmi/input0\";\n\tacer_wmi_input_dev->id.bustype = BUS_HOST;\n\n\terr = sparse_keymap_setup(acer_wmi_input_dev, acer_wmi_keymap, NULL);\n\tif (err)\n\t\tgoto err_free_dev;\n\n\tif (has_cap(ACER_CAP_KBD_DOCK))\n\t\tinput_set_capability(acer_wmi_input_dev, EV_SW, SW_TABLET_MODE);\n\n\tstatus = wmi_install_notify_handler(ACERWMID_EVENT_GUID,\n\t\t\t\t\t\tacer_wmi_notify, NULL);\n\tif (ACPI_FAILURE(status)) {\n\t\terr = -EIO;\n\t\tgoto err_free_dev;\n\t}\n\n\tif (has_cap(ACER_CAP_KBD_DOCK))\n\t\tacer_kbd_dock_get_initial_state();\n\n\terr = input_register_device(acer_wmi_input_dev);\n\tif (err)\n\t\tgoto err_uninstall_notifier;\n\n\treturn 0;\n\nerr_uninstall_notifier:\n\twmi_remove_notify_handler(ACERWMID_EVENT_GUID);\nerr_free_dev:\n\tinput_free_device(acer_wmi_input_dev);\n\treturn err;\n}\n\nstatic void acer_wmi_input_destroy(void)\n{\n\twmi_remove_notify_handler(ACERWMID_EVENT_GUID);\n\tinput_unregister_device(acer_wmi_input_dev);\n}\n\n \nstatic u32 get_wmid_devices(void)\n{\n\tstruct acpi_buffer out = {ACPI_ALLOCATE_BUFFER, NULL};\n\tunion acpi_object *obj;\n\tacpi_status status;\n\tu32 devices = 0;\n\n\tstatus = wmi_query_block(WMID_GUID2, 0, &out);\n\tif (ACPI_FAILURE(status))\n\t\treturn 0;\n\n\tobj = (union acpi_object *) out.pointer;\n\tif (obj) {\n\t\tif (obj->type == ACPI_TYPE_BUFFER &&\n\t\t\t(obj->buffer.length == sizeof(u32) ||\n\t\t\tobj->buffer.length == sizeof(u64))) {\n\t\t\tdevices = *((u32 *) obj->buffer.pointer);\n\t\t} else if (obj->type == ACPI_TYPE_INTEGER) {\n\t\t\tdevices = (u32) obj->integer.value;\n\t\t}\n\t}\n\n\tkfree(out.pointer);\n\treturn devices;\n}\n\n \nstatic int acer_platform_probe(struct platform_device *device)\n{\n\tint err;\n\n\tif (has_cap(ACER_CAP_MAILLED)) {\n\t\terr = acer_led_init(&device->dev);\n\t\tif (err)\n\t\t\tgoto error_mailled;\n\t}\n\n\tif (has_cap(ACER_CAP_BRIGHTNESS)) {\n\t\terr = acer_backlight_init(&device->dev);\n\t\tif (err)\n\t\t\tgoto error_brightness;\n\t}\n\n\terr = acer_rfkill_init(&device->dev);\n\tif (err)\n\t\tgoto error_rfkill;\n\n\treturn err;\n\nerror_rfkill:\n\tif (has_cap(ACER_CAP_BRIGHTNESS))\n\t\tacer_backlight_exit();\nerror_brightness:\n\tif (has_cap(ACER_CAP_MAILLED))\n\t\tacer_led_exit();\nerror_mailled:\n\treturn err;\n}\n\nstatic void acer_platform_remove(struct platform_device *device)\n{\n\tif (has_cap(ACER_CAP_MAILLED))\n\t\tacer_led_exit();\n\tif (has_cap(ACER_CAP_BRIGHTNESS))\n\t\tacer_backlight_exit();\n\n\tacer_rfkill_exit();\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int acer_suspend(struct device *dev)\n{\n\tu32 value;\n\tstruct acer_data *data = &interface->data;\n\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tif (has_cap(ACER_CAP_MAILLED)) {\n\t\tget_u32(&value, ACER_CAP_MAILLED);\n\t\tset_u32(LED_OFF, ACER_CAP_MAILLED);\n\t\tdata->mailled = value;\n\t}\n\n\tif (has_cap(ACER_CAP_BRIGHTNESS)) {\n\t\tget_u32(&value, ACER_CAP_BRIGHTNESS);\n\t\tdata->brightness = value;\n\t}\n\n\treturn 0;\n}\n\nstatic int acer_resume(struct device *dev)\n{\n\tstruct acer_data *data = &interface->data;\n\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tif (has_cap(ACER_CAP_MAILLED))\n\t\tset_u32(data->mailled, ACER_CAP_MAILLED);\n\n\tif (has_cap(ACER_CAP_BRIGHTNESS))\n\t\tset_u32(data->brightness, ACER_CAP_BRIGHTNESS);\n\n\tif (acer_wmi_accel_dev)\n\t\tacer_gsensor_init();\n\n\treturn 0;\n}\n#else\n#define acer_suspend\tNULL\n#define acer_resume\tNULL\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(acer_pm, acer_suspend, acer_resume);\n\nstatic void acer_platform_shutdown(struct platform_device *device)\n{\n\tstruct acer_data *data = &interface->data;\n\n\tif (!data)\n\t\treturn;\n\n\tif (has_cap(ACER_CAP_MAILLED))\n\t\tset_u32(LED_OFF, ACER_CAP_MAILLED);\n}\n\nstatic struct platform_driver acer_platform_driver = {\n\t.driver = {\n\t\t.name = \"acer-wmi\",\n\t\t.pm = &acer_pm,\n\t},\n\t.probe = acer_platform_probe,\n\t.remove_new = acer_platform_remove,\n\t.shutdown = acer_platform_shutdown,\n};\n\nstatic struct platform_device *acer_platform_device;\n\nstatic void remove_debugfs(void)\n{\n\tdebugfs_remove_recursive(interface->debug.root);\n}\n\nstatic void __init create_debugfs(void)\n{\n\tinterface->debug.root = debugfs_create_dir(\"acer-wmi\", NULL);\n\n\tdebugfs_create_u32(\"devices\", S_IRUGO, interface->debug.root,\n\t\t\t   &interface->debug.wmid_devices);\n}\n\nstatic int __init acer_wmi_init(void)\n{\n\tint err;\n\n\tpr_info(\"Acer Laptop ACPI-WMI Extras\\n\");\n\n\tif (dmi_check_system(acer_blacklist)) {\n\t\tpr_info(\"Blacklisted hardware detected - not loading\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tfind_quirks();\n\n\t \n\tif (wmi_has_guid(AMW0_GUID1) &&\n\t    !dmi_check_system(amw0_whitelist) &&\n\t    quirks == &quirk_unknown) {\n\t\tpr_debug(\"Unsupported machine has AMW0_GUID1, unable to load\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tif (wmi_has_guid(AMW0_GUID1) && wmi_has_guid(WMID_GUID1))\n\t\tinterface = &AMW0_V2_interface;\n\n\tif (!wmi_has_guid(AMW0_GUID1) && wmi_has_guid(WMID_GUID1))\n\t\tinterface = &wmid_interface;\n\n\tif (wmi_has_guid(WMID_GUID3))\n\t\tinterface = &wmid_v2_interface;\n\n\tif (interface)\n\t\tdmi_walk(type_aa_dmi_decode, NULL);\n\n\tif (wmi_has_guid(WMID_GUID2) && interface) {\n\t\tif (!has_type_aa && ACPI_FAILURE(WMID_set_capabilities())) {\n\t\t\tpr_err(\"Unable to detect available WMID devices\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t\t \n\t\tinterface->capability |= ACER_CAP_BRIGHTNESS;\n\t} else if (!wmi_has_guid(WMID_GUID2) && interface && !has_type_aa && force_caps == -1) {\n\t\tpr_err(\"No WMID device detection method found\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (wmi_has_guid(AMW0_GUID1) && !wmi_has_guid(WMID_GUID1)) {\n\t\tinterface = &AMW0_interface;\n\n\t\tif (ACPI_FAILURE(AMW0_set_capabilities())) {\n\t\t\tpr_err(\"Unable to detect available AMW0 devices\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\tif (wmi_has_guid(AMW0_GUID1))\n\t\tAMW0_find_mailled();\n\n\tif (!interface) {\n\t\tpr_err(\"No or unsupported WMI interface, unable to load\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tset_quirks();\n\n\tif (acpi_video_get_backlight_type() != acpi_backlight_vendor)\n\t\tinterface->capability &= ~ACER_CAP_BRIGHTNESS;\n\n\tif (wmi_has_guid(WMID_GUID3))\n\t\tinterface->capability |= ACER_CAP_SET_FUNCTION_MODE;\n\n\tif (force_caps != -1)\n\t\tinterface->capability = force_caps;\n\n\tif (wmi_has_guid(WMID_GUID3) &&\n\t    (interface->capability & ACER_CAP_SET_FUNCTION_MODE)) {\n\t\tif (ACPI_FAILURE(acer_wmi_enable_rf_button()))\n\t\t\tpr_warn(\"Cannot enable RF Button Driver\\n\");\n\n\t\tif (ec_raw_mode) {\n\t\t\tif (ACPI_FAILURE(acer_wmi_enable_ec_raw())) {\n\t\t\t\tpr_err(\"Cannot enable EC raw mode\\n\");\n\t\t\t\treturn -ENODEV;\n\t\t\t}\n\t\t} else if (ACPI_FAILURE(acer_wmi_enable_lm())) {\n\t\t\tpr_err(\"Cannot enable Launch Manager mode\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t} else if (ec_raw_mode) {\n\t\tpr_info(\"No WMID EC raw mode enable method\\n\");\n\t}\n\n\tif (wmi_has_guid(ACERWMID_EVENT_GUID)) {\n\t\terr = acer_wmi_input_setup();\n\t\tif (err)\n\t\t\treturn err;\n\t\terr = acer_wmi_accel_setup();\n\t\tif (err && err != -ENODEV)\n\t\t\tpr_warn(\"Cannot enable accelerometer\\n\");\n\t}\n\n\terr = platform_driver_register(&acer_platform_driver);\n\tif (err) {\n\t\tpr_err(\"Unable to register platform driver\\n\");\n\t\tgoto error_platform_register;\n\t}\n\n\tacer_platform_device = platform_device_alloc(\"acer-wmi\", PLATFORM_DEVID_NONE);\n\tif (!acer_platform_device) {\n\t\terr = -ENOMEM;\n\t\tgoto error_device_alloc;\n\t}\n\n\terr = platform_device_add(acer_platform_device);\n\tif (err)\n\t\tgoto error_device_add;\n\n\tif (wmi_has_guid(WMID_GUID2)) {\n\t\tinterface->debug.wmid_devices = get_wmid_devices();\n\t\tcreate_debugfs();\n\t}\n\n\t \n\tacer_commandline_init();\n\n\treturn 0;\n\nerror_device_add:\n\tplatform_device_put(acer_platform_device);\nerror_device_alloc:\n\tplatform_driver_unregister(&acer_platform_driver);\nerror_platform_register:\n\tif (wmi_has_guid(ACERWMID_EVENT_GUID))\n\t\tacer_wmi_input_destroy();\n\tif (acer_wmi_accel_dev)\n\t\tinput_unregister_device(acer_wmi_accel_dev);\n\n\treturn err;\n}\n\nstatic void __exit acer_wmi_exit(void)\n{\n\tif (wmi_has_guid(ACERWMID_EVENT_GUID))\n\t\tacer_wmi_input_destroy();\n\n\tif (acer_wmi_accel_dev)\n\t\tinput_unregister_device(acer_wmi_accel_dev);\n\n\tremove_debugfs();\n\tplatform_device_unregister(acer_platform_device);\n\tplatform_driver_unregister(&acer_platform_driver);\n\n\tpr_info(\"Acer Laptop WMI Extras unloaded\\n\");\n\treturn;\n}\n\nmodule_init(acer_wmi_init);\nmodule_exit(acer_wmi_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}