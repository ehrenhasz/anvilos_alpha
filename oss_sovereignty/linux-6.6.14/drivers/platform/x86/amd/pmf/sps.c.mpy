{
  "module_name": "sps.c",
  "hash_id": "f76b7156e15c995cd1acda6c26d0052c5b9923036e7112ebd1e7f02bb5e7a1e5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/x86/amd/pmf/sps.c",
  "human_readable_source": "\n \n\n#include \"pmf.h\"\n\nstatic struct amd_pmf_static_slider_granular config_store;\n\n#ifdef CONFIG_AMD_PMF_DEBUG\nstatic const char *slider_as_str(unsigned int state)\n{\n\tswitch (state) {\n\tcase POWER_MODE_PERFORMANCE:\n\t\treturn \"PERFORMANCE\";\n\tcase POWER_MODE_BALANCED_POWER:\n\t\treturn \"BALANCED_POWER\";\n\tcase POWER_MODE_POWER_SAVER:\n\t\treturn \"POWER_SAVER\";\n\tdefault:\n\t\treturn \"Unknown Slider State\";\n\t}\n}\n\nstatic const char *source_as_str(unsigned int state)\n{\n\tswitch (state) {\n\tcase POWER_SOURCE_AC:\n\t\treturn \"AC\";\n\tcase POWER_SOURCE_DC:\n\t\treturn \"DC\";\n\tdefault:\n\t\treturn \"Unknown Power State\";\n\t}\n}\n\nstatic void amd_pmf_dump_sps_defaults(struct amd_pmf_static_slider_granular *data)\n{\n\tint i, j;\n\n\tpr_debug(\"Static Slider Data - BEGIN\\n\");\n\n\tfor (i = 0; i < POWER_SOURCE_MAX; i++) {\n\t\tfor (j = 0; j < POWER_MODE_MAX; j++) {\n\t\t\tpr_debug(\"--- Source:%s Mode:%s ---\\n\", source_as_str(i), slider_as_str(j));\n\t\t\tpr_debug(\"SPL: %u mW\\n\", data->prop[i][j].spl);\n\t\t\tpr_debug(\"SPPT: %u mW\\n\", data->prop[i][j].sppt);\n\t\t\tpr_debug(\"SPPT_ApuOnly: %u mW\\n\", data->prop[i][j].sppt_apu_only);\n\t\t\tpr_debug(\"FPPT: %u mW\\n\", data->prop[i][j].fppt);\n\t\t\tpr_debug(\"STTMinLimit: %u mW\\n\", data->prop[i][j].stt_min);\n\t\t\tpr_debug(\"STT_SkinTempLimit_APU: %u C\\n\",\n\t\t\t\t data->prop[i][j].stt_skin_temp[STT_TEMP_APU]);\n\t\t\tpr_debug(\"STT_SkinTempLimit_HS2: %u C\\n\",\n\t\t\t\t data->prop[i][j].stt_skin_temp[STT_TEMP_HS2]);\n\t\t}\n\t}\n\n\tpr_debug(\"Static Slider Data - END\\n\");\n}\n#else\nstatic void amd_pmf_dump_sps_defaults(struct amd_pmf_static_slider_granular *data) {}\n#endif\n\nstatic void amd_pmf_load_defaults_sps(struct amd_pmf_dev *dev)\n{\n\tstruct apmf_static_slider_granular_output output;\n\tint i, j, idx = 0;\n\n\tmemset(&config_store, 0, sizeof(config_store));\n\tapmf_get_static_slider_granular(dev, &output);\n\n\tfor (i = 0; i < POWER_SOURCE_MAX; i++) {\n\t\tfor (j = 0; j < POWER_MODE_MAX; j++) {\n\t\t\tconfig_store.prop[i][j].spl = output.prop[idx].spl;\n\t\t\tconfig_store.prop[i][j].sppt = output.prop[idx].sppt;\n\t\t\tconfig_store.prop[i][j].sppt_apu_only =\n\t\t\t\t\t\toutput.prop[idx].sppt_apu_only;\n\t\t\tconfig_store.prop[i][j].fppt = output.prop[idx].fppt;\n\t\t\tconfig_store.prop[i][j].stt_min = output.prop[idx].stt_min;\n\t\t\tconfig_store.prop[i][j].stt_skin_temp[STT_TEMP_APU] =\n\t\t\t\t\toutput.prop[idx].stt_skin_temp[STT_TEMP_APU];\n\t\t\tconfig_store.prop[i][j].stt_skin_temp[STT_TEMP_HS2] =\n\t\t\t\t\toutput.prop[idx].stt_skin_temp[STT_TEMP_HS2];\n\t\t\tconfig_store.prop[i][j].fan_id = output.prop[idx].fan_id;\n\t\t\tidx++;\n\t\t}\n\t}\n\tamd_pmf_dump_sps_defaults(&config_store);\n}\n\nvoid amd_pmf_update_slider(struct amd_pmf_dev *dev, bool op, int idx,\n\t\t\t   struct amd_pmf_static_slider_granular *table)\n{\n\tint src = amd_pmf_get_power_source();\n\n\tif (op == SLIDER_OP_SET) {\n\t\tamd_pmf_send_cmd(dev, SET_SPL, false, config_store.prop[src][idx].spl, NULL);\n\t\tamd_pmf_send_cmd(dev, SET_FPPT, false, config_store.prop[src][idx].fppt, NULL);\n\t\tamd_pmf_send_cmd(dev, SET_SPPT, false, config_store.prop[src][idx].sppt, NULL);\n\t\tamd_pmf_send_cmd(dev, SET_SPPT_APU_ONLY, false,\n\t\t\t\t config_store.prop[src][idx].sppt_apu_only, NULL);\n\t\tamd_pmf_send_cmd(dev, SET_STT_MIN_LIMIT, false,\n\t\t\t\t config_store.prop[src][idx].stt_min, NULL);\n\t\tamd_pmf_send_cmd(dev, SET_STT_LIMIT_APU, false,\n\t\t\t\t config_store.prop[src][idx].stt_skin_temp[STT_TEMP_APU], NULL);\n\t\tamd_pmf_send_cmd(dev, SET_STT_LIMIT_HS2, false,\n\t\t\t\t config_store.prop[src][idx].stt_skin_temp[STT_TEMP_HS2], NULL);\n\t} else if (op == SLIDER_OP_GET) {\n\t\tamd_pmf_send_cmd(dev, GET_SPL, true, ARG_NONE, &table->prop[src][idx].spl);\n\t\tamd_pmf_send_cmd(dev, GET_FPPT, true, ARG_NONE, &table->prop[src][idx].fppt);\n\t\tamd_pmf_send_cmd(dev, GET_SPPT, true, ARG_NONE, &table->prop[src][idx].sppt);\n\t\tamd_pmf_send_cmd(dev, GET_SPPT_APU_ONLY, true, ARG_NONE,\n\t\t\t\t &table->prop[src][idx].sppt_apu_only);\n\t\tamd_pmf_send_cmd(dev, GET_STT_MIN_LIMIT, true, ARG_NONE,\n\t\t\t\t &table->prop[src][idx].stt_min);\n\t\tamd_pmf_send_cmd(dev, GET_STT_LIMIT_APU, true, ARG_NONE,\n\t\t\t\t (u32 *)&table->prop[src][idx].stt_skin_temp[STT_TEMP_APU]);\n\t\tamd_pmf_send_cmd(dev, GET_STT_LIMIT_HS2, true, ARG_NONE,\n\t\t\t\t (u32 *)&table->prop[src][idx].stt_skin_temp[STT_TEMP_HS2]);\n\t}\n}\n\nint amd_pmf_set_sps_power_limits(struct amd_pmf_dev *pmf)\n{\n\tint mode;\n\n\tmode = amd_pmf_get_pprof_modes(pmf);\n\tif (mode < 0)\n\t\treturn mode;\n\n\tamd_pmf_update_slider(pmf, SLIDER_OP_SET, mode, NULL);\n\n\treturn 0;\n}\n\nbool is_pprof_balanced(struct amd_pmf_dev *pmf)\n{\n\treturn (pmf->current_profile == PLATFORM_PROFILE_BALANCED) ? true : false;\n}\n\nstatic int amd_pmf_profile_get(struct platform_profile_handler *pprof,\n\t\t\t       enum platform_profile_option *profile)\n{\n\tstruct amd_pmf_dev *pmf = container_of(pprof, struct amd_pmf_dev, pprof);\n\n\t*profile = pmf->current_profile;\n\treturn 0;\n}\n\nint amd_pmf_get_pprof_modes(struct amd_pmf_dev *pmf)\n{\n\tint mode;\n\n\tswitch (pmf->current_profile) {\n\tcase PLATFORM_PROFILE_PERFORMANCE:\n\t\tmode = POWER_MODE_PERFORMANCE;\n\t\tbreak;\n\tcase PLATFORM_PROFILE_BALANCED:\n\t\tmode = POWER_MODE_BALANCED_POWER;\n\t\tbreak;\n\tcase PLATFORM_PROFILE_LOW_POWER:\n\t\tmode = POWER_MODE_POWER_SAVER;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(pmf->dev, \"Unknown Platform Profile.\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn mode;\n}\n\nint amd_pmf_power_slider_update_event(struct amd_pmf_dev *dev)\n{\n\tu8 flag = 0;\n\tint mode;\n\tint src;\n\n\tmode = amd_pmf_get_pprof_modes(dev);\n\tif (mode < 0)\n\t\treturn mode;\n\n\tsrc = amd_pmf_get_power_source();\n\n\tif (src == POWER_SOURCE_AC) {\n\t\tswitch (mode) {\n\t\tcase POWER_MODE_PERFORMANCE:\n\t\t\tflag |= BIT(AC_BEST_PERF);\n\t\t\tbreak;\n\t\tcase POWER_MODE_BALANCED_POWER:\n\t\t\tflag |= BIT(AC_BETTER_PERF);\n\t\t\tbreak;\n\t\tcase POWER_MODE_POWER_SAVER:\n\t\t\tflag |= BIT(AC_BETTER_BATTERY);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(dev->dev, \"unsupported platform profile\\n\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\n\t} else if (src == POWER_SOURCE_DC) {\n\t\tswitch (mode) {\n\t\tcase POWER_MODE_PERFORMANCE:\n\t\t\tflag |= BIT(DC_BEST_PERF);\n\t\t\tbreak;\n\t\tcase POWER_MODE_BALANCED_POWER:\n\t\t\tflag |= BIT(DC_BETTER_PERF);\n\t\t\tbreak;\n\t\tcase POWER_MODE_POWER_SAVER:\n\t\t\tflag |= BIT(DC_BATTERY_SAVER);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(dev->dev, \"unsupported platform profile\\n\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t}\n\n\tapmf_os_power_slider_update(dev, flag);\n\n\treturn 0;\n}\n\nstatic int amd_pmf_profile_set(struct platform_profile_handler *pprof,\n\t\t\t       enum platform_profile_option profile)\n{\n\tstruct amd_pmf_dev *pmf = container_of(pprof, struct amd_pmf_dev, pprof);\n\tint ret = 0;\n\n\tpmf->current_profile = profile;\n\n\t \n\tif (is_apmf_func_supported(pmf, APMF_FUNC_OS_POWER_SLIDER_UPDATE)) {\n\t\tret = amd_pmf_power_slider_update_event(pmf);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (is_apmf_func_supported(pmf, APMF_FUNC_STATIC_SLIDER_GRANULAR)) {\n\t\tret = amd_pmf_set_sps_power_limits(pmf);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nint amd_pmf_init_sps(struct amd_pmf_dev *dev)\n{\n\tint err;\n\n\tdev->current_profile = PLATFORM_PROFILE_BALANCED;\n\n\tif (is_apmf_func_supported(dev, APMF_FUNC_STATIC_SLIDER_GRANULAR)) {\n\t\tamd_pmf_load_defaults_sps(dev);\n\n\t\t \n\t\tamd_pmf_set_sps_power_limits(dev);\n\t}\n\n\tdev->pprof.profile_get = amd_pmf_profile_get;\n\tdev->pprof.profile_set = amd_pmf_profile_set;\n\n\t \n\tset_bit(PLATFORM_PROFILE_LOW_POWER, dev->pprof.choices);\n\tset_bit(PLATFORM_PROFILE_BALANCED, dev->pprof.choices);\n\tset_bit(PLATFORM_PROFILE_PERFORMANCE, dev->pprof.choices);\n\n\t \n\terr = platform_profile_register(&dev->pprof);\n\tif (err)\n\t\tdev_err(dev->dev, \"Failed to register SPS support, this is most likely an SBIOS bug: %d\\n\",\n\t\t\terr);\n\n\treturn err;\n}\n\nvoid amd_pmf_deinit_sps(struct amd_pmf_dev *dev)\n{\n\tplatform_profile_remove();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}