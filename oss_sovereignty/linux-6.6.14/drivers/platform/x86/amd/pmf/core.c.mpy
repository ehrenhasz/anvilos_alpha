{
  "module_name": "core.c",
  "hash_id": "ce68a487715f21c7c3e3a41a68418ddc2f0da9b63ec5e7f2b0ebce6726bd87ec",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/x86/amd/pmf/core.c",
  "human_readable_source": "\n \n\n#include <asm/amd_nb.h>\n#include <linux/debugfs.h>\n#include <linux/iopoll.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/platform_device.h>\n#include <linux/power_supply.h>\n#include \"pmf.h\"\n\n \n#define AMD_PMF_REGISTER_MESSAGE\t0xA18\n#define AMD_PMF_REGISTER_RESPONSE\t0xA78\n#define AMD_PMF_REGISTER_ARGUMENT\t0xA58\n\n \n#define AMD_PMF_MAPPING_SIZE\t\t0x01000\n#define AMD_PMF_BASE_ADDR_OFFSET\t0x10000\n#define AMD_PMF_BASE_ADDR_LO\t\t0x13B102E8\n#define AMD_PMF_BASE_ADDR_HI\t\t0x13B102EC\n#define AMD_PMF_BASE_ADDR_LO_MASK\tGENMASK(15, 0)\n#define AMD_PMF_BASE_ADDR_HI_MASK\tGENMASK(31, 20)\n\n \n#define AMD_PMF_RESULT_OK                    0x01\n#define AMD_PMF_RESULT_CMD_REJECT_BUSY       0xFC\n#define AMD_PMF_RESULT_CMD_REJECT_PREREQ     0xFD\n#define AMD_PMF_RESULT_CMD_UNKNOWN           0xFE\n#define AMD_PMF_RESULT_FAILED                0xFF\n\n \n#define AMD_CPU_ID_RMB\t\t\t0x14b5\n#define AMD_CPU_ID_PS\t\t\t0x14e8\n#define PCI_DEVICE_ID_AMD_1AH_M20H_ROOT\t0x1507\n\n#define PMF_MSG_DELAY_MIN_US\t\t50\n#define RESPONSE_REGISTER_LOOP_MAX\t20000\n\n#define DELAY_MIN_US\t2000\n#define DELAY_MAX_US\t3000\n\n \nstatic int metrics_table_loop_ms = 1000;\nmodule_param(metrics_table_loop_ms, int, 0644);\nMODULE_PARM_DESC(metrics_table_loop_ms, \"Metrics Table sample size time (default = 1000ms)\");\n\n \nstatic bool force_load;\nmodule_param(force_load, bool, 0444);\nMODULE_PARM_DESC(force_load, \"Force load this driver on supported older platforms (experimental)\");\n\nstatic int amd_pmf_pwr_src_notify_call(struct notifier_block *nb, unsigned long event, void *data)\n{\n\tstruct amd_pmf_dev *pmf = container_of(nb, struct amd_pmf_dev, pwr_src_notifier);\n\n\tif (event != PSY_EVENT_PROP_CHANGED)\n\t\treturn NOTIFY_OK;\n\n\tif (is_apmf_func_supported(pmf, APMF_FUNC_AUTO_MODE) ||\n\t    is_apmf_func_supported(pmf, APMF_FUNC_DYN_SLIDER_DC) ||\n\t    is_apmf_func_supported(pmf, APMF_FUNC_DYN_SLIDER_AC)) {\n\t\tif ((pmf->amt_enabled || pmf->cnqf_enabled) && is_pprof_balanced(pmf))\n\t\t\treturn NOTIFY_DONE;\n\t}\n\n\tif (is_apmf_func_supported(pmf, APMF_FUNC_STATIC_SLIDER_GRANULAR))\n\t\tamd_pmf_set_sps_power_limits(pmf);\n\n\tif (is_apmf_func_supported(pmf, APMF_FUNC_OS_POWER_SLIDER_UPDATE))\n\t\tamd_pmf_power_slider_update_event(pmf);\n\n\treturn NOTIFY_OK;\n}\n\nstatic int current_power_limits_show(struct seq_file *seq, void *unused)\n{\n\tstruct amd_pmf_dev *dev = seq->private;\n\tstruct amd_pmf_static_slider_granular table;\n\tint mode, src = 0;\n\n\tmode = amd_pmf_get_pprof_modes(dev);\n\tif (mode < 0)\n\t\treturn mode;\n\n\tsrc = amd_pmf_get_power_source();\n\tamd_pmf_update_slider(dev, SLIDER_OP_GET, mode, &table);\n\tseq_printf(seq, \"spl:%u fppt:%u sppt:%u sppt_apu_only:%u stt_min:%u stt[APU]:%u stt[HS2]: %u\\n\",\n\t\t   table.prop[src][mode].spl,\n\t\t   table.prop[src][mode].fppt,\n\t\t   table.prop[src][mode].sppt,\n\t\t   table.prop[src][mode].sppt_apu_only,\n\t\t   table.prop[src][mode].stt_min,\n\t\t   table.prop[src][mode].stt_skin_temp[STT_TEMP_APU],\n\t\t   table.prop[src][mode].stt_skin_temp[STT_TEMP_HS2]);\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(current_power_limits);\n\nstatic void amd_pmf_dbgfs_unregister(struct amd_pmf_dev *dev)\n{\n\tdebugfs_remove_recursive(dev->dbgfs_dir);\n}\n\nstatic void amd_pmf_dbgfs_register(struct amd_pmf_dev *dev)\n{\n\tdev->dbgfs_dir = debugfs_create_dir(\"amd_pmf\", NULL);\n\tdebugfs_create_file(\"current_power_limits\", 0644, dev->dbgfs_dir, dev,\n\t\t\t    &current_power_limits_fops);\n}\n\nint amd_pmf_get_power_source(void)\n{\n\tif (power_supply_is_system_supplied() > 0)\n\t\treturn POWER_SOURCE_AC;\n\telse\n\t\treturn POWER_SOURCE_DC;\n}\n\nstatic void amd_pmf_get_metrics(struct work_struct *work)\n{\n\tstruct amd_pmf_dev *dev = container_of(work, struct amd_pmf_dev, work_buffer.work);\n\tktime_t time_elapsed_ms;\n\tint socket_power;\n\n\tmutex_lock(&dev->update_mutex);\n\t \n\tmemset(dev->buf, 0, sizeof(dev->m_table));\n\tamd_pmf_send_cmd(dev, SET_TRANSFER_TABLE, 0, 7, NULL);\n\tmemcpy(&dev->m_table, dev->buf, sizeof(dev->m_table));\n\n\ttime_elapsed_ms = ktime_to_ms(ktime_get()) - dev->start_time;\n\t \n\tsocket_power = dev->m_table.apu_power + dev->m_table.dgpu_power;\n\n\tif (dev->amt_enabled) {\n\t\t \n\t\tamd_pmf_trans_automode(dev, socket_power, time_elapsed_ms);\n\t}\n\n\tif (dev->cnqf_enabled) {\n\t\t \n\t\tamd_pmf_trans_cnqf(dev, socket_power, time_elapsed_ms);\n\t}\n\n\tdev->start_time = ktime_to_ms(ktime_get());\n\tschedule_delayed_work(&dev->work_buffer, msecs_to_jiffies(metrics_table_loop_ms));\n\tmutex_unlock(&dev->update_mutex);\n}\n\nstatic inline u32 amd_pmf_reg_read(struct amd_pmf_dev *dev, int reg_offset)\n{\n\treturn ioread32(dev->regbase + reg_offset);\n}\n\nstatic inline void amd_pmf_reg_write(struct amd_pmf_dev *dev, int reg_offset, u32 val)\n{\n\tiowrite32(val, dev->regbase + reg_offset);\n}\n\nstatic void __maybe_unused amd_pmf_dump_registers(struct amd_pmf_dev *dev)\n{\n\tu32 value;\n\n\tvalue = amd_pmf_reg_read(dev, AMD_PMF_REGISTER_RESPONSE);\n\tdev_dbg(dev->dev, \"AMD_PMF_REGISTER_RESPONSE:%x\\n\", value);\n\n\tvalue = amd_pmf_reg_read(dev, AMD_PMF_REGISTER_ARGUMENT);\n\tdev_dbg(dev->dev, \"AMD_PMF_REGISTER_ARGUMENT:%d\\n\", value);\n\n\tvalue = amd_pmf_reg_read(dev, AMD_PMF_REGISTER_MESSAGE);\n\tdev_dbg(dev->dev, \"AMD_PMF_REGISTER_MESSAGE:%x\\n\", value);\n}\n\nint amd_pmf_send_cmd(struct amd_pmf_dev *dev, u8 message, bool get, u32 arg, u32 *data)\n{\n\tint rc;\n\tu32 val;\n\n\tmutex_lock(&dev->lock);\n\n\t \n\trc = readx_poll_timeout(ioread32, dev->regbase + AMD_PMF_REGISTER_RESPONSE,\n\t\t\t\tval, val != 0, PMF_MSG_DELAY_MIN_US,\n\t\t\t\tPMF_MSG_DELAY_MIN_US * RESPONSE_REGISTER_LOOP_MAX);\n\tif (rc) {\n\t\tdev_err(dev->dev, \"failed to talk to SMU\\n\");\n\t\tgoto out_unlock;\n\t}\n\n\t \n\tamd_pmf_reg_write(dev, AMD_PMF_REGISTER_RESPONSE, 0);\n\n\t \n\tamd_pmf_reg_write(dev, AMD_PMF_REGISTER_ARGUMENT, arg);\n\n\t \n\tamd_pmf_reg_write(dev, AMD_PMF_REGISTER_MESSAGE, message);\n\n\t \n\trc = readx_poll_timeout(ioread32, dev->regbase + AMD_PMF_REGISTER_RESPONSE,\n\t\t\t\tval, val != 0, PMF_MSG_DELAY_MIN_US,\n\t\t\t\tPMF_MSG_DELAY_MIN_US * RESPONSE_REGISTER_LOOP_MAX);\n\tif (rc) {\n\t\tdev_err(dev->dev, \"SMU response timed out\\n\");\n\t\tgoto out_unlock;\n\t}\n\n\tswitch (val) {\n\tcase AMD_PMF_RESULT_OK:\n\t\tif (get) {\n\t\t\t \n\t\t\tusleep_range(DELAY_MIN_US, 10 * DELAY_MAX_US);\n\t\t\t*data = amd_pmf_reg_read(dev, AMD_PMF_REGISTER_ARGUMENT);\n\t\t}\n\t\tbreak;\n\tcase AMD_PMF_RESULT_CMD_REJECT_BUSY:\n\t\tdev_err(dev->dev, \"SMU not ready. err: 0x%x\\n\", val);\n\t\trc = -EBUSY;\n\t\tgoto out_unlock;\n\tcase AMD_PMF_RESULT_CMD_UNKNOWN:\n\t\tdev_err(dev->dev, \"SMU cmd unknown. err: 0x%x\\n\", val);\n\t\trc = -EINVAL;\n\t\tgoto out_unlock;\n\tcase AMD_PMF_RESULT_CMD_REJECT_PREREQ:\n\tcase AMD_PMF_RESULT_FAILED:\n\tdefault:\n\t\tdev_err(dev->dev, \"SMU cmd failed. err: 0x%x\\n\", val);\n\t\trc = -EIO;\n\t\tgoto out_unlock;\n\t}\n\nout_unlock:\n\tmutex_unlock(&dev->lock);\n\tamd_pmf_dump_registers(dev);\n\treturn rc;\n}\n\nstatic const struct pci_device_id pmf_pci_ids[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_AMD, AMD_CPU_ID_RMB) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_AMD, AMD_CPU_ID_PS) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_1AH_M20H_ROOT) },\n\t{ }\n};\n\nstatic void amd_pmf_set_dram_addr(struct amd_pmf_dev *dev)\n{\n\tu64 phys_addr;\n\tu32 hi, low;\n\n\tphys_addr = virt_to_phys(dev->buf);\n\thi = phys_addr >> 32;\n\tlow = phys_addr & GENMASK(31, 0);\n\n\tamd_pmf_send_cmd(dev, SET_DRAM_ADDR_HIGH, 0, hi, NULL);\n\tamd_pmf_send_cmd(dev, SET_DRAM_ADDR_LOW, 0, low, NULL);\n}\n\nint amd_pmf_init_metrics_table(struct amd_pmf_dev *dev)\n{\n\t \n\tdev->buf = kzalloc(sizeof(dev->m_table), GFP_KERNEL);\n\tif (!dev->buf)\n\t\treturn -ENOMEM;\n\n\tINIT_DELAYED_WORK(&dev->work_buffer, amd_pmf_get_metrics);\n\n\tamd_pmf_set_dram_addr(dev);\n\n\t \n\tschedule_delayed_work(&dev->work_buffer, msecs_to_jiffies(metrics_table_loop_ms * 3));\n\n\treturn 0;\n}\n\nstatic int amd_pmf_resume_handler(struct device *dev)\n{\n\tstruct amd_pmf_dev *pdev = dev_get_drvdata(dev);\n\n\tif (pdev->buf)\n\t\tamd_pmf_set_dram_addr(pdev);\n\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(amd_pmf_pm, NULL, amd_pmf_resume_handler);\n\nstatic void amd_pmf_init_features(struct amd_pmf_dev *dev)\n{\n\tint ret;\n\n\t \n\tif (is_apmf_func_supported(dev, APMF_FUNC_STATIC_SLIDER_GRANULAR) ||\n\t    is_apmf_func_supported(dev, APMF_FUNC_OS_POWER_SLIDER_UPDATE)) {\n\t\tamd_pmf_init_sps(dev);\n\t\tdev->pwr_src_notifier.notifier_call = amd_pmf_pwr_src_notify_call;\n\t\tpower_supply_reg_notifier(&dev->pwr_src_notifier);\n\t\tdev_dbg(dev->dev, \"SPS enabled and Platform Profiles registered\\n\");\n\t}\n\n\t \n\tif (is_apmf_func_supported(dev, APMF_FUNC_AUTO_MODE)) {\n\t\tamd_pmf_init_auto_mode(dev);\n\t\tdev_dbg(dev->dev, \"Auto Mode Init done\\n\");\n\t} else if (is_apmf_func_supported(dev, APMF_FUNC_DYN_SLIDER_AC) ||\n\t\t\t  is_apmf_func_supported(dev, APMF_FUNC_DYN_SLIDER_DC)) {\n\t\t \n\t\tret = amd_pmf_init_cnqf(dev);\n\t\tif (ret)\n\t\t\tdev_warn(dev->dev, \"CnQF Init failed\\n\");\n\t}\n}\n\nstatic void amd_pmf_deinit_features(struct amd_pmf_dev *dev)\n{\n\tif (is_apmf_func_supported(dev, APMF_FUNC_STATIC_SLIDER_GRANULAR) ||\n\t    is_apmf_func_supported(dev, APMF_FUNC_OS_POWER_SLIDER_UPDATE)) {\n\t\tpower_supply_unreg_notifier(&dev->pwr_src_notifier);\n\t\tamd_pmf_deinit_sps(dev);\n\t}\n\n\tif (is_apmf_func_supported(dev, APMF_FUNC_AUTO_MODE)) {\n\t\tamd_pmf_deinit_auto_mode(dev);\n\t} else if (is_apmf_func_supported(dev, APMF_FUNC_DYN_SLIDER_AC) ||\n\t\t\t  is_apmf_func_supported(dev, APMF_FUNC_DYN_SLIDER_DC)) {\n\t\tamd_pmf_deinit_cnqf(dev);\n\t}\n}\n\nstatic const struct acpi_device_id amd_pmf_acpi_ids[] = {\n\t{\"AMDI0100\", 0x100},\n\t{\"AMDI0102\", 0},\n\t{\"AMDI0103\", 0},\n\t{ }\n};\nMODULE_DEVICE_TABLE(acpi, amd_pmf_acpi_ids);\n\nstatic int amd_pmf_probe(struct platform_device *pdev)\n{\n\tconst struct acpi_device_id *id;\n\tstruct amd_pmf_dev *dev;\n\tstruct pci_dev *rdev;\n\tu32 base_addr_lo;\n\tu32 base_addr_hi;\n\tu64 base_addr;\n\tu32 val;\n\tint err;\n\n\tid = acpi_match_device(amd_pmf_acpi_ids, &pdev->dev);\n\tif (!id)\n\t\treturn -ENODEV;\n\n\tif (id->driver_data == 0x100 && !force_load)\n\t\treturn -ENODEV;\n\n\tdev = devm_kzalloc(&pdev->dev, sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tdev->dev = &pdev->dev;\n\n\trdev = pci_get_domain_bus_and_slot(0, 0, PCI_DEVFN(0, 0));\n\tif (!rdev || !pci_match_id(pmf_pci_ids, rdev)) {\n\t\tpci_dev_put(rdev);\n\t\treturn -ENODEV;\n\t}\n\n\tdev->cpu_id = rdev->device;\n\n\terr = amd_smn_read(0, AMD_PMF_BASE_ADDR_LO, &val);\n\tif (err) {\n\t\tdev_err(dev->dev, \"error in reading from 0x%x\\n\", AMD_PMF_BASE_ADDR_LO);\n\t\tpci_dev_put(rdev);\n\t\treturn pcibios_err_to_errno(err);\n\t}\n\n\tbase_addr_lo = val & AMD_PMF_BASE_ADDR_HI_MASK;\n\n\terr = amd_smn_read(0, AMD_PMF_BASE_ADDR_HI, &val);\n\tif (err) {\n\t\tdev_err(dev->dev, \"error in reading from 0x%x\\n\", AMD_PMF_BASE_ADDR_HI);\n\t\tpci_dev_put(rdev);\n\t\treturn pcibios_err_to_errno(err);\n\t}\n\n\tbase_addr_hi = val & AMD_PMF_BASE_ADDR_LO_MASK;\n\tpci_dev_put(rdev);\n\tbase_addr = ((u64)base_addr_hi << 32 | base_addr_lo);\n\n\tdev->regbase = devm_ioremap(dev->dev, base_addr + AMD_PMF_BASE_ADDR_OFFSET,\n\t\t\t\t    AMD_PMF_MAPPING_SIZE);\n\tif (!dev->regbase)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&dev->lock);\n\tmutex_init(&dev->update_mutex);\n\n\tapmf_acpi_init(dev);\n\tplatform_set_drvdata(pdev, dev);\n\tamd_pmf_init_features(dev);\n\tapmf_install_handler(dev);\n\tamd_pmf_dbgfs_register(dev);\n\n\tdev_info(dev->dev, \"registered PMF device successfully\\n\");\n\n\treturn 0;\n}\n\nstatic void amd_pmf_remove(struct platform_device *pdev)\n{\n\tstruct amd_pmf_dev *dev = platform_get_drvdata(pdev);\n\n\tamd_pmf_deinit_features(dev);\n\tapmf_acpi_deinit(dev);\n\tamd_pmf_dbgfs_unregister(dev);\n\tmutex_destroy(&dev->lock);\n\tmutex_destroy(&dev->update_mutex);\n\tkfree(dev->buf);\n}\n\nstatic const struct attribute_group *amd_pmf_driver_groups[] = {\n\t&cnqf_feature_attribute_group,\n\tNULL,\n};\n\nstatic struct platform_driver amd_pmf_driver = {\n\t.driver = {\n\t\t.name = \"amd-pmf\",\n\t\t.acpi_match_table = amd_pmf_acpi_ids,\n\t\t.dev_groups = amd_pmf_driver_groups,\n\t\t.pm = pm_sleep_ptr(&amd_pmf_pm),\n\t},\n\t.probe = amd_pmf_probe,\n\t.remove_new = amd_pmf_remove,\n};\nmodule_platform_driver(amd_pmf_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"AMD Platform Management Framework Driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}