{
  "module_name": "acpi.c",
  "hash_id": "d0b0d5f56ba19b0568c05a191ea6dfc57464cf94ba95cf58d6944c60a0e5474a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/x86/amd/pmf/acpi.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include \"pmf.h\"\n\n#define APMF_CQL_NOTIFICATION  2\n#define APMF_AMT_NOTIFICATION  3\n\nstatic union acpi_object *apmf_if_call(struct amd_pmf_dev *pdev, int fn, struct acpi_buffer *param)\n{\n\tstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };\n\tacpi_handle ahandle = ACPI_HANDLE(pdev->dev);\n\tstruct acpi_object_list apmf_if_arg_list;\n\tunion acpi_object apmf_if_args[2];\n\tacpi_status status;\n\n\tapmf_if_arg_list.count = 2;\n\tapmf_if_arg_list.pointer = &apmf_if_args[0];\n\n\tapmf_if_args[0].type = ACPI_TYPE_INTEGER;\n\tapmf_if_args[0].integer.value = fn;\n\n\tif (param) {\n\t\tapmf_if_args[1].type = ACPI_TYPE_BUFFER;\n\t\tapmf_if_args[1].buffer.length = param->length;\n\t\tapmf_if_args[1].buffer.pointer = param->pointer;\n\t} else {\n\t\tapmf_if_args[1].type = ACPI_TYPE_INTEGER;\n\t\tapmf_if_args[1].integer.value = 0;\n\t}\n\n\tstatus = acpi_evaluate_object(ahandle, \"APMF\", &apmf_if_arg_list, &buffer);\n\tif (ACPI_FAILURE(status)) {\n\t\tdev_err(pdev->dev, \"APMF method:%d call failed\\n\", fn);\n\t\tkfree(buffer.pointer);\n\t\treturn NULL;\n\t}\n\n\treturn buffer.pointer;\n}\n\nstatic int apmf_if_call_store_buffer(struct amd_pmf_dev *pdev, int fn, void *dest, size_t out_sz)\n{\n\tunion acpi_object *info;\n\tsize_t size;\n\tint err = 0;\n\n\tinfo = apmf_if_call(pdev, fn, NULL);\n\tif (!info)\n\t\treturn -EIO;\n\n\tif (info->type != ACPI_TYPE_BUFFER) {\n\t\tdev_err(pdev->dev, \"object is not a buffer\\n\");\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (info->buffer.length < 2) {\n\t\tdev_err(pdev->dev, \"buffer too small\\n\");\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tsize = *(u16 *)info->buffer.pointer;\n\tif (info->buffer.length < size) {\n\t\tdev_err(pdev->dev, \"buffer smaller then headersize %u < %zu\\n\",\n\t\t\tinfo->buffer.length, size);\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (size < out_sz) {\n\t\tdev_err(pdev->dev, \"buffer too small %zu\\n\", size);\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tmemcpy(dest, info->buffer.pointer, out_sz);\n\nout:\n\tkfree(info);\n\treturn err;\n}\n\nint is_apmf_func_supported(struct amd_pmf_dev *pdev, unsigned long index)\n{\n\t \n\treturn !!(pdev->supported_func & BIT(index - 1));\n}\n\nint apmf_get_static_slider_granular(struct amd_pmf_dev *pdev,\n\t\t\t\t    struct apmf_static_slider_granular_output *data)\n{\n\tif (!is_apmf_func_supported(pdev, APMF_FUNC_STATIC_SLIDER_GRANULAR))\n\t\treturn -EINVAL;\n\n\treturn apmf_if_call_store_buffer(pdev, APMF_FUNC_STATIC_SLIDER_GRANULAR,\n\t\t\t\t\t\t\t\t\t data, sizeof(*data));\n}\n\nint apmf_os_power_slider_update(struct amd_pmf_dev *pdev, u8 event)\n{\n\tstruct os_power_slider args;\n\tstruct acpi_buffer params;\n\tunion acpi_object *info;\n\tint err = 0;\n\n\targs.size = sizeof(args);\n\targs.slider_event = event;\n\n\tparams.length = sizeof(args);\n\tparams.pointer = (void *)&args;\n\n\tinfo = apmf_if_call(pdev, APMF_FUNC_OS_POWER_SLIDER_UPDATE, &params);\n\tif (!info)\n\t\terr = -EIO;\n\n\tkfree(info);\n\treturn err;\n}\n\nstatic void apmf_sbios_heartbeat_notify(struct work_struct *work)\n{\n\tstruct amd_pmf_dev *dev = container_of(work, struct amd_pmf_dev, heart_beat.work);\n\tunion acpi_object *info;\n\n\tdev_dbg(dev->dev, \"Sending heartbeat to SBIOS\\n\");\n\tinfo = apmf_if_call(dev, APMF_FUNC_SBIOS_HEARTBEAT, NULL);\n\tif (!info)\n\t\tgoto out;\n\n\tschedule_delayed_work(&dev->heart_beat, msecs_to_jiffies(dev->hb_interval * 1000));\n\nout:\n\tkfree(info);\n}\n\nint apmf_update_fan_idx(struct amd_pmf_dev *pdev, bool manual, u32 idx)\n{\n\tunion acpi_object *info;\n\tstruct apmf_fan_idx args;\n\tstruct acpi_buffer params;\n\tint err = 0;\n\n\targs.size = sizeof(args);\n\targs.fan_ctl_mode = manual;\n\targs.fan_ctl_idx = idx;\n\n\tparams.length = sizeof(args);\n\tparams.pointer = (void *)&args;\n\n\tinfo = apmf_if_call(pdev, APMF_FUNC_SET_FAN_IDX, &params);\n\tif (!info) {\n\t\terr = -EIO;\n\t\tgoto out;\n\t}\n\nout:\n\tkfree(info);\n\treturn err;\n}\n\nint apmf_get_auto_mode_def(struct amd_pmf_dev *pdev, struct apmf_auto_mode *data)\n{\n\treturn apmf_if_call_store_buffer(pdev, APMF_FUNC_AUTO_MODE, data, sizeof(*data));\n}\n\nint apmf_get_sbios_requests(struct amd_pmf_dev *pdev, struct apmf_sbios_req *req)\n{\n\treturn apmf_if_call_store_buffer(pdev, APMF_FUNC_SBIOS_REQUESTS,\n\t\t\t\t\t\t\t\t\t req, sizeof(*req));\n}\n\nstatic void apmf_event_handler(acpi_handle handle, u32 event, void *data)\n{\n\tstruct amd_pmf_dev *pmf_dev = data;\n\tstruct apmf_sbios_req req;\n\tint ret;\n\n\tmutex_lock(&pmf_dev->update_mutex);\n\tret = apmf_get_sbios_requests(pmf_dev, &req);\n\tif (ret) {\n\t\tdev_err(pmf_dev->dev, \"Failed to get SBIOS requests:%d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tif (req.pending_req & BIT(APMF_AMT_NOTIFICATION)) {\n\t\tdev_dbg(pmf_dev->dev, \"AMT is supported and notifications %s\\n\",\n\t\t\treq.amt_event ? \"Enabled\" : \"Disabled\");\n\t\tpmf_dev->amt_enabled = !!req.amt_event;\n\n\t\tif (pmf_dev->amt_enabled)\n\t\t\tamd_pmf_handle_amt(pmf_dev);\n\t\telse\n\t\t\tamd_pmf_reset_amt(pmf_dev);\n\t}\n\n\tif (req.pending_req & BIT(APMF_CQL_NOTIFICATION)) {\n\t\tdev_dbg(pmf_dev->dev, \"CQL is supported and notifications %s\\n\",\n\t\t\treq.cql_event ? \"Enabled\" : \"Disabled\");\n\n\t\t \n\t\tif (pmf_dev->amt_enabled)\n\t\t\tamd_pmf_update_2_cql(pmf_dev, req.cql_event);\n\t}\nout:\n\tmutex_unlock(&pmf_dev->update_mutex);\n}\n\nstatic int apmf_if_verify_interface(struct amd_pmf_dev *pdev)\n{\n\tstruct apmf_verify_interface output;\n\tint err;\n\n\terr = apmf_if_call_store_buffer(pdev, APMF_FUNC_VERIFY_INTERFACE, &output, sizeof(output));\n\tif (err)\n\t\treturn err;\n\n\tpdev->supported_func = output.supported_functions;\n\tdev_dbg(pdev->dev, \"supported functions:0x%x notifications:0x%x\\n\",\n\t\toutput.supported_functions, output.notification_mask);\n\n\treturn 0;\n}\n\nstatic int apmf_get_system_params(struct amd_pmf_dev *dev)\n{\n\tstruct apmf_system_params params;\n\tint err;\n\n\tif (!is_apmf_func_supported(dev, APMF_FUNC_GET_SYS_PARAMS))\n\t\treturn -EINVAL;\n\n\terr = apmf_if_call_store_buffer(dev, APMF_FUNC_GET_SYS_PARAMS, &params, sizeof(params));\n\tif (err)\n\t\treturn err;\n\n\tdev_dbg(dev->dev, \"system params mask:0x%x flags:0x%x cmd_code:0x%x heartbeat:%d\\n\",\n\t\tparams.valid_mask,\n\t\tparams.flags,\n\t\tparams.command_code,\n\t\tparams.heartbeat_int);\n\tparams.flags = params.flags & params.valid_mask;\n\tdev->hb_interval = params.heartbeat_int;\n\n\treturn 0;\n}\n\nint apmf_get_dyn_slider_def_ac(struct amd_pmf_dev *pdev, struct apmf_dyn_slider_output *data)\n{\n\treturn apmf_if_call_store_buffer(pdev, APMF_FUNC_DYN_SLIDER_AC, data, sizeof(*data));\n}\n\nint apmf_get_dyn_slider_def_dc(struct amd_pmf_dev *pdev, struct apmf_dyn_slider_output *data)\n{\n\treturn apmf_if_call_store_buffer(pdev, APMF_FUNC_DYN_SLIDER_DC, data, sizeof(*data));\n}\n\nint apmf_install_handler(struct amd_pmf_dev *pmf_dev)\n{\n\tacpi_handle ahandle = ACPI_HANDLE(pmf_dev->dev);\n\tacpi_status status;\n\n\t \n\tif (is_apmf_func_supported(pmf_dev, APMF_FUNC_AUTO_MODE) &&\n\t    is_apmf_func_supported(pmf_dev, APMF_FUNC_SBIOS_REQUESTS)) {\n\t\tstatus = acpi_install_notify_handler(ahandle, ACPI_ALL_NOTIFY,\n\t\t\t\t\t\t     apmf_event_handler, pmf_dev);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tdev_err(pmf_dev->dev, \"failed to install notify handler\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\t \n\t\tapmf_event_handler(ahandle, 0, pmf_dev);\n\t}\n\n\treturn 0;\n}\n\nvoid apmf_acpi_deinit(struct amd_pmf_dev *pmf_dev)\n{\n\tacpi_handle ahandle = ACPI_HANDLE(pmf_dev->dev);\n\n\tif (pmf_dev->hb_interval)\n\t\tcancel_delayed_work_sync(&pmf_dev->heart_beat);\n\n\tif (is_apmf_func_supported(pmf_dev, APMF_FUNC_AUTO_MODE) &&\n\t    is_apmf_func_supported(pmf_dev, APMF_FUNC_SBIOS_REQUESTS))\n\t\tacpi_remove_notify_handler(ahandle, ACPI_ALL_NOTIFY, apmf_event_handler);\n}\n\nint apmf_acpi_init(struct amd_pmf_dev *pmf_dev)\n{\n\tint ret;\n\n\tret = apmf_if_verify_interface(pmf_dev);\n\tif (ret) {\n\t\tdev_err(pmf_dev->dev, \"APMF verify interface failed :%d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tret = apmf_get_system_params(pmf_dev);\n\tif (ret) {\n\t\tdev_dbg(pmf_dev->dev, \"APMF apmf_get_system_params failed :%d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tif (pmf_dev->hb_interval) {\n\t\t \n\t\tINIT_DELAYED_WORK(&pmf_dev->heart_beat, apmf_sbios_heartbeat_notify);\n\t\tschedule_delayed_work(&pmf_dev->heart_beat, 0);\n\t}\n\nout:\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}