{
  "module_name": "cnqf.c",
  "hash_id": "db075532858b5f9af77a2cf5a324048a2b8992ff8022078fcbc3a12c8b24b382",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/x86/amd/pmf/cnqf.c",
  "human_readable_source": "\n \n\n#include <linux/string_choices.h>\n#include <linux/workqueue.h>\n#include \"pmf.h\"\n\nstatic struct cnqf_config config_store;\n\n#ifdef CONFIG_AMD_PMF_DEBUG\nstatic const char *state_as_str_cnqf(unsigned int state)\n{\n\tswitch (state) {\n\tcase APMF_CNQF_TURBO:\n\t\treturn \"turbo\";\n\tcase APMF_CNQF_PERFORMANCE:\n\t\treturn \"performance\";\n\tcase APMF_CNQF_BALANCE:\n\t\treturn \"balance\";\n\tcase APMF_CNQF_QUIET:\n\t\treturn \"quiet\";\n\tdefault:\n\t\treturn \"Unknown CnQF State\";\n\t}\n}\n\nstatic void amd_pmf_cnqf_dump_defaults(struct apmf_dyn_slider_output *data, int idx)\n{\n\tint i;\n\n\tpr_debug(\"Dynamic Slider %s Defaults - BEGIN\\n\", idx ? \"DC\" : \"AC\");\n\tpr_debug(\"size: %u\\n\", data->size);\n\tpr_debug(\"flags: 0x%x\\n\", data->flags);\n\n\t \n\tpr_debug(\"t_perf_to_turbo: %u ms\\n\", data->t_perf_to_turbo);\n\tpr_debug(\"t_balanced_to_perf: %u ms\\n\", data->t_balanced_to_perf);\n\tpr_debug(\"t_quiet_to_balanced: %u ms\\n\", data->t_quiet_to_balanced);\n\tpr_debug(\"t_balanced_to_quiet: %u ms\\n\", data->t_balanced_to_quiet);\n\tpr_debug(\"t_perf_to_balanced: %u ms\\n\", data->t_perf_to_balanced);\n\tpr_debug(\"t_turbo_to_perf: %u ms\\n\", data->t_turbo_to_perf);\n\n\tfor (i = 0 ; i < CNQF_MODE_MAX ; i++) {\n\t\tpr_debug(\"pfloor_%s: %u mW\\n\", state_as_str_cnqf(i), data->ps[i].pfloor);\n\t\tpr_debug(\"fppt_%s: %u mW\\n\", state_as_str_cnqf(i), data->ps[i].fppt);\n\t\tpr_debug(\"sppt_%s: %u mW\\n\", state_as_str_cnqf(i), data->ps[i].sppt);\n\t\tpr_debug(\"sppt_apuonly_%s: %u mW\\n\",\n\t\t\t state_as_str_cnqf(i), data->ps[i].sppt_apu_only);\n\t\tpr_debug(\"spl_%s: %u mW\\n\", state_as_str_cnqf(i), data->ps[i].spl);\n\t\tpr_debug(\"stt_minlimit_%s: %u mW\\n\",\n\t\t\t state_as_str_cnqf(i), data->ps[i].stt_min_limit);\n\t\tpr_debug(\"stt_skintemp_apu_%s: %u C\\n\", state_as_str_cnqf(i),\n\t\t\t data->ps[i].stt_skintemp[STT_TEMP_APU]);\n\t\tpr_debug(\"stt_skintemp_hs2_%s: %u C\\n\", state_as_str_cnqf(i),\n\t\t\t data->ps[i].stt_skintemp[STT_TEMP_HS2]);\n\t\tpr_debug(\"fan_id_%s: %u\\n\", state_as_str_cnqf(i), data->ps[i].fan_id);\n\t}\n\n\tpr_debug(\"Dynamic Slider %s Defaults - END\\n\", idx ? \"DC\" : \"AC\");\n}\n#else\nstatic void amd_pmf_cnqf_dump_defaults(struct apmf_dyn_slider_output *data, int idx) {}\n#endif\n\nstatic int amd_pmf_set_cnqf(struct amd_pmf_dev *dev, int src, int idx,\n\t\t\t    struct cnqf_config *table)\n{\n\tstruct power_table_control *pc;\n\n\tpc = &config_store.mode_set[src][idx].power_control;\n\n\tamd_pmf_send_cmd(dev, SET_SPL, false, pc->spl, NULL);\n\tamd_pmf_send_cmd(dev, SET_FPPT, false, pc->fppt, NULL);\n\tamd_pmf_send_cmd(dev, SET_SPPT, false, pc->sppt, NULL);\n\tamd_pmf_send_cmd(dev, SET_SPPT_APU_ONLY, false, pc->sppt_apu_only, NULL);\n\tamd_pmf_send_cmd(dev, SET_STT_MIN_LIMIT, false, pc->stt_min, NULL);\n\tamd_pmf_send_cmd(dev, SET_STT_LIMIT_APU, false, pc->stt_skin_temp[STT_TEMP_APU],\n\t\t\t NULL);\n\tamd_pmf_send_cmd(dev, SET_STT_LIMIT_HS2, false, pc->stt_skin_temp[STT_TEMP_HS2],\n\t\t\t NULL);\n\n\tif (is_apmf_func_supported(dev, APMF_FUNC_SET_FAN_IDX))\n\t\tapmf_update_fan_idx(dev,\n\t\t\t\t    config_store.mode_set[src][idx].fan_control.manual,\n\t\t\t\t    config_store.mode_set[src][idx].fan_control.fan_id);\n\n\treturn 0;\n}\n\nstatic void amd_pmf_update_power_threshold(int src)\n{\n\tstruct cnqf_mode_settings *ts;\n\tstruct cnqf_tran_params *tp;\n\n\ttp = &config_store.trans_param[src][CNQF_TRANSITION_TO_QUIET];\n\tts = &config_store.mode_set[src][CNQF_MODE_BALANCE];\n\ttp->power_threshold = ts->power_floor;\n\n\ttp = &config_store.trans_param[src][CNQF_TRANSITION_TO_TURBO];\n\tts = &config_store.mode_set[src][CNQF_MODE_PERFORMANCE];\n\ttp->power_threshold = ts->power_floor;\n\n\ttp = &config_store.trans_param[src][CNQF_TRANSITION_FROM_BALANCE_TO_PERFORMANCE];\n\tts = &config_store.mode_set[src][CNQF_MODE_BALANCE];\n\ttp->power_threshold = ts->power_floor;\n\n\ttp = &config_store.trans_param[src][CNQF_TRANSITION_FROM_PERFORMANCE_TO_BALANCE];\n\tts = &config_store.mode_set[src][CNQF_MODE_PERFORMANCE];\n\ttp->power_threshold = ts->power_floor;\n\n\ttp = &config_store.trans_param[src][CNQF_TRANSITION_FROM_QUIET_TO_BALANCE];\n\tts = &config_store.mode_set[src][CNQF_MODE_QUIET];\n\ttp->power_threshold = ts->power_floor;\n\n\ttp = &config_store.trans_param[src][CNQF_TRANSITION_FROM_TURBO_TO_PERFORMANCE];\n\tts = &config_store.mode_set[src][CNQF_MODE_TURBO];\n\ttp->power_threshold = ts->power_floor;\n}\n\nstatic const char *state_as_str(unsigned int state)\n{\n\tswitch (state) {\n\tcase CNQF_MODE_QUIET:\n\t\treturn \"QUIET\";\n\tcase CNQF_MODE_BALANCE:\n\t\treturn \"BALANCED\";\n\tcase CNQF_MODE_TURBO:\n\t\treturn \"TURBO\";\n\tcase CNQF_MODE_PERFORMANCE:\n\t\treturn \"PERFORMANCE\";\n\tdefault:\n\t\treturn \"Unknown CnQF mode\";\n\t}\n}\n\nstatic int amd_pmf_cnqf_get_power_source(struct amd_pmf_dev *dev)\n{\n\tif (is_apmf_func_supported(dev, APMF_FUNC_DYN_SLIDER_AC) &&\n\t    is_apmf_func_supported(dev, APMF_FUNC_DYN_SLIDER_DC))\n\t\treturn amd_pmf_get_power_source();\n\telse if (is_apmf_func_supported(dev, APMF_FUNC_DYN_SLIDER_DC))\n\t\treturn POWER_SOURCE_DC;\n\telse\n\t\treturn POWER_SOURCE_AC;\n}\n\nint amd_pmf_trans_cnqf(struct amd_pmf_dev *dev, int socket_power, ktime_t time_lapsed_ms)\n{\n\tstruct cnqf_tran_params *tp;\n\tint src, i, j;\n\tu32 avg_power = 0;\n\n\tsrc = amd_pmf_cnqf_get_power_source(dev);\n\n\tif (is_pprof_balanced(dev)) {\n\t\tamd_pmf_set_cnqf(dev, src, config_store.current_mode, NULL);\n\t} else {\n\t\t \n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < CNQF_TRANSITION_MAX; i++) {\n\t\tconfig_store.trans_param[src][i].timer += time_lapsed_ms;\n\t\tconfig_store.trans_param[src][i].total_power += socket_power;\n\t\tconfig_store.trans_param[src][i].count++;\n\n\t\ttp = &config_store.trans_param[src][i];\n\n#ifdef CONFIG_AMD_PMF_DEBUG\n\t\tdev_dbg(dev->dev, \"avg_power: %u mW total_power: %u mW count: %u timer: %u ms\\n\",\n\t\t\tavg_power, config_store.trans_param[src][i].total_power,\n\t\t\tconfig_store.trans_param[src][i].count,\n\t\t\tconfig_store.trans_param[src][i].timer);\n#endif\n\t\tif (tp->timer >= tp->time_constant && tp->count) {\n\t\t\tavg_power = tp->total_power / tp->count;\n\n\t\t\t \n\t\t\ttp->timer = 0;\n\t\t\ttp->total_power = 0;\n\t\t\ttp->count = 0;\n\n\t\t\tif ((tp->shifting_up && avg_power >= tp->power_threshold) ||\n\t\t\t    (!tp->shifting_up && avg_power <= tp->power_threshold)) {\n\t\t\t\ttp->priority = true;\n\t\t\t} else {\n\t\t\t\ttp->priority = false;\n\t\t\t}\n\t\t}\n\t}\n\n\tdev_dbg(dev->dev, \"[CNQF] Avg power: %u mW socket power: %u mW mode:%s\\n\",\n\t\tavg_power, socket_power, state_as_str(config_store.current_mode));\n\n#ifdef CONFIG_AMD_PMF_DEBUG\n\tdev_dbg(dev->dev, \"[CNQF] priority1: %u priority2: %u priority3: %u\\n\",\n\t\tconfig_store.trans_param[src][0].priority,\n\t\tconfig_store.trans_param[src][1].priority,\n\t\tconfig_store.trans_param[src][2].priority);\n\n\tdev_dbg(dev->dev, \"[CNQF] priority4: %u priority5: %u priority6: %u\\n\",\n\t\tconfig_store.trans_param[src][3].priority,\n\t\tconfig_store.trans_param[src][4].priority,\n\t\tconfig_store.trans_param[src][5].priority);\n#endif\n\n\tfor (j = 0; j < CNQF_TRANSITION_MAX; j++) {\n\t\t \n\t\tif (config_store.trans_param[src][j].priority) {\n\t\t\tif (config_store.current_mode !=\n\t\t\t    config_store.trans_param[src][j].target_mode) {\n\t\t\t\tconfig_store.current_mode =\n\t\t\t\t\t\tconfig_store.trans_param[src][j].target_mode;\n\t\t\t\tdev_dbg(dev->dev, \"Moving to Mode :%s\\n\",\n\t\t\t\t\tstate_as_str(config_store.current_mode));\n\t\t\t\tamd_pmf_set_cnqf(dev, src,\n\t\t\t\t\t\t config_store.current_mode, NULL);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void amd_pmf_update_trans_data(int idx, struct apmf_dyn_slider_output *out)\n{\n\tstruct cnqf_tran_params *tp;\n\n\ttp = &config_store.trans_param[idx][CNQF_TRANSITION_TO_QUIET];\n\ttp->time_constant = out->t_balanced_to_quiet;\n\ttp->target_mode = CNQF_MODE_QUIET;\n\ttp->shifting_up = false;\n\n\ttp = &config_store.trans_param[idx][CNQF_TRANSITION_FROM_BALANCE_TO_PERFORMANCE];\n\ttp->time_constant = out->t_balanced_to_perf;\n\ttp->target_mode = CNQF_MODE_PERFORMANCE;\n\ttp->shifting_up = true;\n\n\ttp = &config_store.trans_param[idx][CNQF_TRANSITION_FROM_QUIET_TO_BALANCE];\n\ttp->time_constant = out->t_quiet_to_balanced;\n\ttp->target_mode = CNQF_MODE_BALANCE;\n\ttp->shifting_up = true;\n\n\ttp = &config_store.trans_param[idx][CNQF_TRANSITION_FROM_PERFORMANCE_TO_BALANCE];\n\ttp->time_constant = out->t_perf_to_balanced;\n\ttp->target_mode = CNQF_MODE_BALANCE;\n\ttp->shifting_up = false;\n\n\ttp = &config_store.trans_param[idx][CNQF_TRANSITION_FROM_TURBO_TO_PERFORMANCE];\n\ttp->time_constant = out->t_turbo_to_perf;\n\ttp->target_mode = CNQF_MODE_PERFORMANCE;\n\ttp->shifting_up = false;\n\n\ttp = &config_store.trans_param[idx][CNQF_TRANSITION_TO_TURBO];\n\ttp->time_constant = out->t_perf_to_turbo;\n\ttp->target_mode = CNQF_MODE_TURBO;\n\ttp->shifting_up = true;\n}\n\nstatic void amd_pmf_update_mode_set(int idx, struct apmf_dyn_slider_output *out)\n{\n\tstruct cnqf_mode_settings *ms;\n\n\t \n\tms = &config_store.mode_set[idx][CNQF_MODE_QUIET];\n\tms->power_floor = out->ps[APMF_CNQF_QUIET].pfloor;\n\tms->power_control.fppt = out->ps[APMF_CNQF_QUIET].fppt;\n\tms->power_control.sppt = out->ps[APMF_CNQF_QUIET].sppt;\n\tms->power_control.sppt_apu_only = out->ps[APMF_CNQF_QUIET].sppt_apu_only;\n\tms->power_control.spl = out->ps[APMF_CNQF_QUIET].spl;\n\tms->power_control.stt_min = out->ps[APMF_CNQF_QUIET].stt_min_limit;\n\tms->power_control.stt_skin_temp[STT_TEMP_APU] =\n\t\tout->ps[APMF_CNQF_QUIET].stt_skintemp[STT_TEMP_APU];\n\tms->power_control.stt_skin_temp[STT_TEMP_HS2] =\n\t\tout->ps[APMF_CNQF_QUIET].stt_skintemp[STT_TEMP_HS2];\n\tms->fan_control.fan_id = out->ps[APMF_CNQF_QUIET].fan_id;\n\n\t \n\tms = &config_store.mode_set[idx][CNQF_MODE_BALANCE];\n\tms->power_floor = out->ps[APMF_CNQF_BALANCE].pfloor;\n\tms->power_control.fppt = out->ps[APMF_CNQF_BALANCE].fppt;\n\tms->power_control.sppt = out->ps[APMF_CNQF_BALANCE].sppt;\n\tms->power_control.sppt_apu_only = out->ps[APMF_CNQF_BALANCE].sppt_apu_only;\n\tms->power_control.spl = out->ps[APMF_CNQF_BALANCE].spl;\n\tms->power_control.stt_min = out->ps[APMF_CNQF_BALANCE].stt_min_limit;\n\tms->power_control.stt_skin_temp[STT_TEMP_APU] =\n\t\tout->ps[APMF_CNQF_BALANCE].stt_skintemp[STT_TEMP_APU];\n\tms->power_control.stt_skin_temp[STT_TEMP_HS2] =\n\t\tout->ps[APMF_CNQF_BALANCE].stt_skintemp[STT_TEMP_HS2];\n\tms->fan_control.fan_id = out->ps[APMF_CNQF_BALANCE].fan_id;\n\n\t \n\tms = &config_store.mode_set[idx][CNQF_MODE_PERFORMANCE];\n\tms->power_floor = out->ps[APMF_CNQF_PERFORMANCE].pfloor;\n\tms->power_control.fppt = out->ps[APMF_CNQF_PERFORMANCE].fppt;\n\tms->power_control.sppt = out->ps[APMF_CNQF_PERFORMANCE].sppt;\n\tms->power_control.sppt_apu_only = out->ps[APMF_CNQF_PERFORMANCE].sppt_apu_only;\n\tms->power_control.spl = out->ps[APMF_CNQF_PERFORMANCE].spl;\n\tms->power_control.stt_min = out->ps[APMF_CNQF_PERFORMANCE].stt_min_limit;\n\tms->power_control.stt_skin_temp[STT_TEMP_APU] =\n\t\tout->ps[APMF_CNQF_PERFORMANCE].stt_skintemp[STT_TEMP_APU];\n\tms->power_control.stt_skin_temp[STT_TEMP_HS2] =\n\t\tout->ps[APMF_CNQF_PERFORMANCE].stt_skintemp[STT_TEMP_HS2];\n\tms->fan_control.fan_id = out->ps[APMF_CNQF_PERFORMANCE].fan_id;\n\n\t \n\tms = &config_store.mode_set[idx][CNQF_MODE_TURBO];\n\tms->power_floor = out->ps[APMF_CNQF_TURBO].pfloor;\n\tms->power_control.fppt = out->ps[APMF_CNQF_TURBO].fppt;\n\tms->power_control.sppt = out->ps[APMF_CNQF_TURBO].sppt;\n\tms->power_control.sppt_apu_only = out->ps[APMF_CNQF_TURBO].sppt_apu_only;\n\tms->power_control.spl = out->ps[APMF_CNQF_TURBO].spl;\n\tms->power_control.stt_min = out->ps[APMF_CNQF_TURBO].stt_min_limit;\n\tms->power_control.stt_skin_temp[STT_TEMP_APU] =\n\t\tout->ps[APMF_CNQF_TURBO].stt_skintemp[STT_TEMP_APU];\n\tms->power_control.stt_skin_temp[STT_TEMP_HS2] =\n\t\tout->ps[APMF_CNQF_TURBO].stt_skintemp[STT_TEMP_HS2];\n\tms->fan_control.fan_id = out->ps[APMF_CNQF_TURBO].fan_id;\n}\n\nstatic int amd_pmf_check_flags(struct amd_pmf_dev *dev)\n{\n\tstruct apmf_dyn_slider_output out = {};\n\n\tif (is_apmf_func_supported(dev, APMF_FUNC_DYN_SLIDER_AC))\n\t\tapmf_get_dyn_slider_def_ac(dev, &out);\n\telse if (is_apmf_func_supported(dev, APMF_FUNC_DYN_SLIDER_DC))\n\t\tapmf_get_dyn_slider_def_dc(dev, &out);\n\n\treturn out.flags;\n}\n\nstatic int amd_pmf_load_defaults_cnqf(struct amd_pmf_dev *dev)\n{\n\tstruct apmf_dyn_slider_output out;\n\tint i, j, ret;\n\n\tfor (i = 0; i < POWER_SOURCE_MAX; i++) {\n\t\tif (!is_apmf_func_supported(dev, APMF_FUNC_DYN_SLIDER_AC + i))\n\t\t\tcontinue;\n\n\t\tif (i == POWER_SOURCE_AC)\n\t\t\tret = apmf_get_dyn_slider_def_ac(dev, &out);\n\t\telse\n\t\t\tret = apmf_get_dyn_slider_def_dc(dev, &out);\n\t\tif (ret) {\n\t\t\tdev_err(dev->dev, \"APMF apmf_get_dyn_slider_def_dc failed :%d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tamd_pmf_cnqf_dump_defaults(&out, i);\n\t\tamd_pmf_update_mode_set(i, &out);\n\t\tamd_pmf_update_trans_data(i, &out);\n\t\tamd_pmf_update_power_threshold(i);\n\n\t\tfor (j = 0; j < CNQF_MODE_MAX; j++) {\n\t\t\tif (config_store.mode_set[i][j].fan_control.fan_id == FAN_INDEX_AUTO)\n\t\t\t\tconfig_store.mode_set[i][j].fan_control.manual = false;\n\t\t\telse\n\t\t\t\tconfig_store.mode_set[i][j].fan_control.manual = true;\n\t\t}\n\t}\n\n\t \n\tconfig_store.current_mode = CNQF_MODE_BALANCE;\n\n\treturn 0;\n}\n\nstatic ssize_t cnqf_enable_store(struct device *dev,\n\t\t\t\t struct device_attribute *attr,\n\t\t\t\t const char *buf, size_t count)\n{\n\tstruct amd_pmf_dev *pdev = dev_get_drvdata(dev);\n\tint result, src;\n\tbool input;\n\n\tresult = kstrtobool(buf, &input);\n\tif (result)\n\t\treturn result;\n\n\tsrc = amd_pmf_cnqf_get_power_source(pdev);\n\tpdev->cnqf_enabled = input;\n\n\tif (pdev->cnqf_enabled && is_pprof_balanced(pdev)) {\n\t\tamd_pmf_set_cnqf(pdev, src, config_store.current_mode, NULL);\n\t} else {\n\t\tif (is_apmf_func_supported(pdev, APMF_FUNC_STATIC_SLIDER_GRANULAR))\n\t\t\tamd_pmf_set_sps_power_limits(pdev);\n\t}\n\n\tdev_dbg(pdev->dev, \"Received CnQF %s\\n\", str_on_off(input));\n\treturn count;\n}\n\nstatic ssize_t cnqf_enable_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\tstruct amd_pmf_dev *pdev = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%s\\n\", str_on_off(pdev->cnqf_enabled));\n}\n\nstatic DEVICE_ATTR_RW(cnqf_enable);\n\nstatic umode_t cnqf_feature_is_visible(struct kobject *kobj,\n\t\t\t\t       struct attribute *attr, int n)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct amd_pmf_dev *pdev = dev_get_drvdata(dev);\n\n\treturn pdev->cnqf_supported ? attr->mode : 0;\n}\n\nstatic struct attribute *cnqf_feature_attrs[] = {\n\t&dev_attr_cnqf_enable.attr,\n\tNULL\n};\n\nconst struct attribute_group cnqf_feature_attribute_group = {\n\t.is_visible = cnqf_feature_is_visible,\n\t.attrs = cnqf_feature_attrs,\n};\n\nvoid amd_pmf_deinit_cnqf(struct amd_pmf_dev *dev)\n{\n\tcancel_delayed_work_sync(&dev->work_buffer);\n}\n\nint amd_pmf_init_cnqf(struct amd_pmf_dev *dev)\n{\n\tint ret, src;\n\n\t \n\n\tret = amd_pmf_load_defaults_cnqf(dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tamd_pmf_init_metrics_table(dev);\n\n\tdev->cnqf_supported = true;\n\tdev->cnqf_enabled = amd_pmf_check_flags(dev);\n\n\t \n\tif (dev->cnqf_enabled && is_pprof_balanced(dev)) {\n\t\tsrc = amd_pmf_cnqf_get_power_source(dev);\n\t\tamd_pmf_set_cnqf(dev, src, config_store.current_mode, NULL);\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}