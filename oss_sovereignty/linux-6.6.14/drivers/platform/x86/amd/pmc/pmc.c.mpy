{
  "module_name": "pmc.c",
  "hash_id": "706db634568424b4fb8a30056ce2d68198775c0ba7c76133a1b945d1201d4911",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/x86/amd/pmc/pmc.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <asm/amd_nb.h>\n#include <linux/acpi.h>\n#include <linux/bitfield.h>\n#include <linux/bits.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/limits.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/platform_device.h>\n#include <linux/rtc.h>\n#include <linux/serio.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\n#include \"pmc.h\"\n\n \n#define AMD_PMC_REGISTER_MESSAGE\t0x538\n#define AMD_PMC_REGISTER_RESPONSE\t0x980\n#define AMD_PMC_REGISTER_ARGUMENT\t0x9BC\n\n \n#define AMD_PMC_SCRATCH_REG_CZN\t\t0x94\n#define AMD_PMC_SCRATCH_REG_YC\t\t0xD14\n\n \n#define AMD_PMC_STB_PMI_0\t\t0x03E30600\n#define AMD_PMC_STB_S2IDLE_PREPARE\t0xC6000001\n#define AMD_PMC_STB_S2IDLE_RESTORE\t0xC6000002\n#define AMD_PMC_STB_S2IDLE_CHECK\t0xC6000003\n#define AMD_PMC_STB_DUMMY_PC\t\t0xC6000007\n\n \n#define AMD_S2D_REGISTER_MESSAGE\t0xA20\n#define AMD_S2D_REGISTER_RESPONSE\t0xA80\n#define AMD_S2D_REGISTER_ARGUMENT\t0xA88\n\n \n#define S2D_TELEMETRY_BYTES_MAX\t\t0x100000\n#define S2D_TELEMETRY_DRAMBYTES_MAX\t0x1000000\n\n \n#define AMD_PMC_MAPPING_SIZE\t\t0x01000\n#define AMD_PMC_BASE_ADDR_OFFSET\t0x10000\n#define AMD_PMC_BASE_ADDR_LO\t\t0x13B102E8\n#define AMD_PMC_BASE_ADDR_HI\t\t0x13B102EC\n#define AMD_PMC_BASE_ADDR_LO_MASK\tGENMASK(15, 0)\n#define AMD_PMC_BASE_ADDR_HI_MASK\tGENMASK(31, 20)\n\n \n#define AMD_PMC_RESULT_OK                    0x01\n#define AMD_PMC_RESULT_CMD_REJECT_BUSY       0xFC\n#define AMD_PMC_RESULT_CMD_REJECT_PREREQ     0xFD\n#define AMD_PMC_RESULT_CMD_UNKNOWN           0xFE\n#define AMD_PMC_RESULT_FAILED                0xFF\n\n \n#define FCH_S0I3_ENTRY_TIME_L_OFFSET\t0x30\n#define FCH_S0I3_ENTRY_TIME_H_OFFSET\t0x34\n#define FCH_S0I3_EXIT_TIME_L_OFFSET\t0x38\n#define FCH_S0I3_EXIT_TIME_H_OFFSET\t0x3C\n#define FCH_SSC_MAPPING_SIZE\t\t0x800\n#define FCH_BASE_PHY_ADDR_LOW\t\t0xFED81100\n#define FCH_BASE_PHY_ADDR_HIGH\t\t0x00000000\n\n \n#define SMU_MSG_GETSMUVERSION\t\t0x02\n#define SMU_MSG_LOG_GETDRAM_ADDR_HI\t0x04\n#define SMU_MSG_LOG_GETDRAM_ADDR_LO\t0x05\n#define SMU_MSG_LOG_START\t\t0x06\n#define SMU_MSG_LOG_RESET\t\t0x07\n#define SMU_MSG_LOG_DUMP_DATA\t\t0x08\n#define SMU_MSG_GET_SUP_CONSTRAINTS\t0x09\n\n#define PMC_MSG_DELAY_MIN_US\t\t50\n#define RESPONSE_REGISTER_LOOP_MAX\t20000\n\n#define DELAY_MIN_US\t\t2000\n#define DELAY_MAX_US\t\t3000\n#define FIFO_SIZE\t\t4096\n\nenum amd_pmc_def {\n\tMSG_TEST = 0x01,\n\tMSG_OS_HINT_PCO,\n\tMSG_OS_HINT_RN,\n};\n\nenum s2d_arg {\n\tS2D_TELEMETRY_SIZE = 0x01,\n\tS2D_PHYS_ADDR_LOW,\n\tS2D_PHYS_ADDR_HIGH,\n\tS2D_NUM_SAMPLES,\n\tS2D_DRAM_SIZE,\n};\n\nstruct amd_pmc_bit_map {\n\tconst char *name;\n\tu32 bit_mask;\n};\n\nstatic const struct amd_pmc_bit_map soc15_ip_blk[] = {\n\t{\"DISPLAY\",\tBIT(0)},\n\t{\"CPU\",\t\tBIT(1)},\n\t{\"GFX\",\t\tBIT(2)},\n\t{\"VDD\",\t\tBIT(3)},\n\t{\"ACP\",\t\tBIT(4)},\n\t{\"VCN\",\t\tBIT(5)},\n\t{\"ISP\",\t\tBIT(6)},\n\t{\"NBIO\",\tBIT(7)},\n\t{\"DF\",\t\tBIT(8)},\n\t{\"USB3_0\",\tBIT(9)},\n\t{\"USB3_1\",\tBIT(10)},\n\t{\"LAPIC\",\tBIT(11)},\n\t{\"USB3_2\",\tBIT(12)},\n\t{\"USB3_3\",\tBIT(13)},\n\t{\"USB3_4\",\tBIT(14)},\n\t{\"USB4_0\",\tBIT(15)},\n\t{\"USB4_1\",\tBIT(16)},\n\t{\"MPM\",\t\tBIT(17)},\n\t{\"JPEG\",\tBIT(18)},\n\t{\"IPU\",\t\tBIT(19)},\n\t{\"UMSCH\",\tBIT(20)},\n\t{}\n};\n\nstatic bool enable_stb;\nmodule_param(enable_stb, bool, 0644);\nMODULE_PARM_DESC(enable_stb, \"Enable the STB debug mechanism\");\n\nstatic bool disable_workarounds;\nmodule_param(disable_workarounds, bool, 0644);\nMODULE_PARM_DESC(disable_workarounds, \"Disable workarounds for platform bugs\");\n\nstatic struct amd_pmc_dev pmc;\nstatic int amd_pmc_send_cmd(struct amd_pmc_dev *dev, u32 arg, u32 *data, u8 msg, bool ret);\nstatic int amd_pmc_read_stb(struct amd_pmc_dev *dev, u32 *buf);\nstatic int amd_pmc_write_stb(struct amd_pmc_dev *dev, u32 data);\n\nstatic inline u32 amd_pmc_reg_read(struct amd_pmc_dev *dev, int reg_offset)\n{\n\treturn ioread32(dev->regbase + reg_offset);\n}\n\nstatic inline void amd_pmc_reg_write(struct amd_pmc_dev *dev, int reg_offset, u32 val)\n{\n\tiowrite32(val, dev->regbase + reg_offset);\n}\n\nstruct smu_metrics {\n\tu32 table_version;\n\tu32 hint_count;\n\tu32 s0i3_last_entry_status;\n\tu32 timein_s0i2;\n\tu64 timeentering_s0i3_lastcapture;\n\tu64 timeentering_s0i3_totaltime;\n\tu64 timeto_resume_to_os_lastcapture;\n\tu64 timeto_resume_to_os_totaltime;\n\tu64 timein_s0i3_lastcapture;\n\tu64 timein_s0i3_totaltime;\n\tu64 timein_swdrips_lastcapture;\n\tu64 timein_swdrips_totaltime;\n\tu64 timecondition_notmet_lastcapture[32];\n\tu64 timecondition_notmet_totaltime[32];\n} __packed;\n\nstatic int amd_pmc_stb_debugfs_open(struct inode *inode, struct file *filp)\n{\n\tstruct amd_pmc_dev *dev = filp->f_inode->i_private;\n\tu32 size = FIFO_SIZE * sizeof(u32);\n\tu32 *buf;\n\tint rc;\n\n\tbuf = kzalloc(size, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\trc = amd_pmc_read_stb(dev, buf);\n\tif (rc) {\n\t\tkfree(buf);\n\t\treturn rc;\n\t}\n\n\tfilp->private_data = buf;\n\treturn rc;\n}\n\nstatic ssize_t amd_pmc_stb_debugfs_read(struct file *filp, char __user *buf, size_t size,\n\t\t\t\t\tloff_t *pos)\n{\n\tif (!filp->private_data)\n\t\treturn -EINVAL;\n\n\treturn simple_read_from_buffer(buf, size, pos, filp->private_data,\n\t\t\t\t       FIFO_SIZE * sizeof(u32));\n}\n\nstatic int amd_pmc_stb_debugfs_release(struct inode *inode, struct file *filp)\n{\n\tkfree(filp->private_data);\n\treturn 0;\n}\n\nstatic const struct file_operations amd_pmc_stb_debugfs_fops = {\n\t.owner = THIS_MODULE,\n\t.open = amd_pmc_stb_debugfs_open,\n\t.read = amd_pmc_stb_debugfs_read,\n\t.release = amd_pmc_stb_debugfs_release,\n};\n\nstatic int amd_pmc_stb_debugfs_open_v2(struct inode *inode, struct file *filp)\n{\n\tstruct amd_pmc_dev *dev = filp->f_inode->i_private;\n\tu32 *buf, fsize, num_samples, stb_rdptr_offset = 0;\n\tint ret;\n\n\t \n\tret = amd_pmc_write_stb(dev, AMD_PMC_STB_DUMMY_PC);\n\tif (ret)\n\t\tdev_err(dev->dev, \"error writing to STB: %d\\n\", ret);\n\n\tbuf = kzalloc(S2D_TELEMETRY_BYTES_MAX, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\t \n\tdev->msg_port = 1;\n\n\t \n\tret = amd_pmc_send_cmd(dev, S2D_NUM_SAMPLES, &num_samples, dev->s2d_msg_id, true);\n\t \n\tdev->msg_port = 0;\n\tif (ret) {\n\t\tdev_err(dev->dev, \"error: S2D_NUM_SAMPLES not supported : %d\\n\", ret);\n\t\tkfree(buf);\n\t\treturn ret;\n\t}\n\n\t \n\tif (num_samples > S2D_TELEMETRY_BYTES_MAX) {\n\t\tfsize  = S2D_TELEMETRY_BYTES_MAX;\n\t\tstb_rdptr_offset = num_samples - fsize;\n\t} else {\n\t\tfsize = num_samples;\n\t\tstb_rdptr_offset = 0;\n\t}\n\n\tmemcpy_fromio(buf, dev->stb_virt_addr + stb_rdptr_offset, fsize);\n\tfilp->private_data = buf;\n\n\treturn 0;\n}\n\nstatic ssize_t amd_pmc_stb_debugfs_read_v2(struct file *filp, char __user *buf, size_t size,\n\t\t\t\t\t   loff_t *pos)\n{\n\tif (!filp->private_data)\n\t\treturn -EINVAL;\n\n\treturn simple_read_from_buffer(buf, size, pos, filp->private_data,\n\t\t\t\t\tS2D_TELEMETRY_BYTES_MAX);\n}\n\nstatic int amd_pmc_stb_debugfs_release_v2(struct inode *inode, struct file *filp)\n{\n\tkfree(filp->private_data);\n\treturn 0;\n}\n\nstatic const struct file_operations amd_pmc_stb_debugfs_fops_v2 = {\n\t.owner = THIS_MODULE,\n\t.open = amd_pmc_stb_debugfs_open_v2,\n\t.read = amd_pmc_stb_debugfs_read_v2,\n\t.release = amd_pmc_stb_debugfs_release_v2,\n};\n\nstatic void amd_pmc_get_ip_info(struct amd_pmc_dev *dev)\n{\n\tswitch (dev->cpu_id) {\n\tcase AMD_CPU_ID_PCO:\n\tcase AMD_CPU_ID_RN:\n\tcase AMD_CPU_ID_YC:\n\tcase AMD_CPU_ID_CB:\n\t\tdev->num_ips = 12;\n\t\tdev->s2d_msg_id = 0xBE;\n\t\tbreak;\n\tcase AMD_CPU_ID_PS:\n\t\tdev->num_ips = 21;\n\t\tdev->s2d_msg_id = 0x85;\n\t\tbreak;\n\t}\n}\n\nstatic int amd_pmc_setup_smu_logging(struct amd_pmc_dev *dev)\n{\n\tif (dev->cpu_id == AMD_CPU_ID_PCO) {\n\t\tdev_warn_once(dev->dev, \"SMU debugging info not supported on this platform\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (!dev->active_ips)\n\t\tamd_pmc_send_cmd(dev, 0, &dev->active_ips, SMU_MSG_GET_SUP_CONSTRAINTS, true);\n\n\t \n\tif (!dev->smu_virt_addr) {\n\t\tu32 phys_addr_low, phys_addr_hi;\n\t\tu64 smu_phys_addr;\n\n\t\tamd_pmc_send_cmd(dev, 0, &phys_addr_low, SMU_MSG_LOG_GETDRAM_ADDR_LO, true);\n\t\tamd_pmc_send_cmd(dev, 0, &phys_addr_hi, SMU_MSG_LOG_GETDRAM_ADDR_HI, true);\n\t\tsmu_phys_addr = ((u64)phys_addr_hi << 32 | phys_addr_low);\n\n\t\tdev->smu_virt_addr = devm_ioremap(dev->dev, smu_phys_addr,\n\t\t\t\t\t\t  sizeof(struct smu_metrics));\n\t\tif (!dev->smu_virt_addr)\n\t\t\treturn -ENOMEM;\n\t}\n\n\t \n\tamd_pmc_send_cmd(dev, 0, NULL, SMU_MSG_LOG_RESET, false);\n\tamd_pmc_send_cmd(dev, 0, NULL, SMU_MSG_LOG_START, false);\n\n\treturn 0;\n}\n\nstatic int get_metrics_table(struct amd_pmc_dev *pdev, struct smu_metrics *table)\n{\n\tif (!pdev->smu_virt_addr) {\n\t\tint ret = amd_pmc_setup_smu_logging(pdev);\n\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (pdev->cpu_id == AMD_CPU_ID_PCO)\n\t\treturn -ENODEV;\n\tmemcpy_fromio(table, pdev->smu_virt_addr, sizeof(struct smu_metrics));\n\treturn 0;\n}\n\nstatic void amd_pmc_validate_deepest(struct amd_pmc_dev *pdev)\n{\n\tstruct smu_metrics table;\n\n\tif (get_metrics_table(pdev, &table))\n\t\treturn;\n\n\tif (!table.s0i3_last_entry_status)\n\t\tdev_warn(pdev->dev, \"Last suspend didn't reach deepest state\\n\");\n\tpm_report_hw_sleep_time(table.s0i3_last_entry_status ?\n\t\t\t\ttable.timein_s0i3_lastcapture : 0);\n}\n\nstatic int amd_pmc_get_smu_version(struct amd_pmc_dev *dev)\n{\n\tint rc;\n\tu32 val;\n\n\tif (dev->cpu_id == AMD_CPU_ID_PCO)\n\t\treturn -ENODEV;\n\n\trc = amd_pmc_send_cmd(dev, 0, &val, SMU_MSG_GETSMUVERSION, true);\n\tif (rc)\n\t\treturn rc;\n\n\tdev->smu_program = (val >> 24) & GENMASK(7, 0);\n\tdev->major = (val >> 16) & GENMASK(7, 0);\n\tdev->minor = (val >> 8) & GENMASK(7, 0);\n\tdev->rev = (val >> 0) & GENMASK(7, 0);\n\n\tdev_dbg(dev->dev, \"SMU program %u version is %u.%u.%u\\n\",\n\t\tdev->smu_program, dev->major, dev->minor, dev->rev);\n\n\treturn 0;\n}\n\nstatic ssize_t smu_fw_version_show(struct device *d, struct device_attribute *attr,\n\t\t\t\t   char *buf)\n{\n\tstruct amd_pmc_dev *dev = dev_get_drvdata(d);\n\n\tif (!dev->major) {\n\t\tint rc = amd_pmc_get_smu_version(dev);\n\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\treturn sysfs_emit(buf, \"%u.%u.%u\\n\", dev->major, dev->minor, dev->rev);\n}\n\nstatic ssize_t smu_program_show(struct device *d, struct device_attribute *attr,\n\t\t\t\t   char *buf)\n{\n\tstruct amd_pmc_dev *dev = dev_get_drvdata(d);\n\n\tif (!dev->major) {\n\t\tint rc = amd_pmc_get_smu_version(dev);\n\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\treturn sysfs_emit(buf, \"%u\\n\", dev->smu_program);\n}\n\nstatic DEVICE_ATTR_RO(smu_fw_version);\nstatic DEVICE_ATTR_RO(smu_program);\n\nstatic umode_t pmc_attr_is_visible(struct kobject *kobj, struct attribute *attr, int idx)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct amd_pmc_dev *pdev = dev_get_drvdata(dev);\n\n\tif (pdev->cpu_id == AMD_CPU_ID_PCO)\n\t\treturn 0;\n\treturn 0444;\n}\n\nstatic struct attribute *pmc_attrs[] = {\n\t&dev_attr_smu_fw_version.attr,\n\t&dev_attr_smu_program.attr,\n\tNULL,\n};\n\nstatic struct attribute_group pmc_attr_group = {\n\t.attrs = pmc_attrs,\n\t.is_visible = pmc_attr_is_visible,\n};\n\nstatic const struct attribute_group *pmc_groups[] = {\n\t&pmc_attr_group,\n\tNULL,\n};\n\nstatic int smu_fw_info_show(struct seq_file *s, void *unused)\n{\n\tstruct amd_pmc_dev *dev = s->private;\n\tstruct smu_metrics table;\n\tint idx;\n\n\tif (get_metrics_table(dev, &table))\n\t\treturn -EINVAL;\n\n\tseq_puts(s, \"\\n=== SMU Statistics ===\\n\");\n\tseq_printf(s, \"Table Version: %d\\n\", table.table_version);\n\tseq_printf(s, \"Hint Count: %d\\n\", table.hint_count);\n\tseq_printf(s, \"Last S0i3 Status: %s\\n\", table.s0i3_last_entry_status ? \"Success\" :\n\t\t   \"Unknown/Fail\");\n\tseq_printf(s, \"Time (in us) to S0i3: %lld\\n\", table.timeentering_s0i3_lastcapture);\n\tseq_printf(s, \"Time (in us) in S0i3: %lld\\n\", table.timein_s0i3_lastcapture);\n\tseq_printf(s, \"Time (in us) to resume from S0i3: %lld\\n\",\n\t\t   table.timeto_resume_to_os_lastcapture);\n\n\tseq_puts(s, \"\\n=== Active time (in us) ===\\n\");\n\tfor (idx = 0 ; idx < dev->num_ips ; idx++) {\n\t\tif (soc15_ip_blk[idx].bit_mask & dev->active_ips)\n\t\t\tseq_printf(s, \"%-8s : %lld\\n\", soc15_ip_blk[idx].name,\n\t\t\t\t   table.timecondition_notmet_lastcapture[idx]);\n\t}\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(smu_fw_info);\n\nstatic int s0ix_stats_show(struct seq_file *s, void *unused)\n{\n\tstruct amd_pmc_dev *dev = s->private;\n\tu64 entry_time, exit_time, residency;\n\n\t \n\tif (!dev->fch_virt_addr) {\n\t\tu32 base_addr_lo = FCH_BASE_PHY_ADDR_LOW;\n\t\tu32 base_addr_hi = FCH_BASE_PHY_ADDR_HIGH;\n\t\tu64 fch_phys_addr = ((u64)base_addr_hi << 32 | base_addr_lo);\n\n\t\tdev->fch_virt_addr = devm_ioremap(dev->dev, fch_phys_addr, FCH_SSC_MAPPING_SIZE);\n\t\tif (!dev->fch_virt_addr)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tentry_time = ioread32(dev->fch_virt_addr + FCH_S0I3_ENTRY_TIME_H_OFFSET);\n\tentry_time = entry_time << 32 | ioread32(dev->fch_virt_addr + FCH_S0I3_ENTRY_TIME_L_OFFSET);\n\n\texit_time = ioread32(dev->fch_virt_addr + FCH_S0I3_EXIT_TIME_H_OFFSET);\n\texit_time = exit_time << 32 | ioread32(dev->fch_virt_addr + FCH_S0I3_EXIT_TIME_L_OFFSET);\n\n\t \n\tresidency = exit_time - entry_time;\n\tdo_div(residency, 48);\n\n\tseq_puts(s, \"=== S0ix statistics ===\\n\");\n\tseq_printf(s, \"S0ix Entry Time: %lld\\n\", entry_time);\n\tseq_printf(s, \"S0ix Exit Time: %lld\\n\", exit_time);\n\tseq_printf(s, \"Residency Time: %lld\\n\", residency);\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(s0ix_stats);\n\nstatic int amd_pmc_idlemask_read(struct amd_pmc_dev *pdev, struct device *dev,\n\t\t\t\t struct seq_file *s)\n{\n\tu32 val;\n\tint rc;\n\n\tswitch (pdev->cpu_id) {\n\tcase AMD_CPU_ID_CZN:\n\t\t \n\t\tif (!pdev->major) {\n\t\t\trc = amd_pmc_get_smu_version(pdev);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t}\n\t\tif (pdev->major > 56 || (pdev->major >= 55 && pdev->minor >= 37))\n\t\t\tval = amd_pmc_reg_read(pdev, AMD_PMC_SCRATCH_REG_CZN);\n\t\telse\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase AMD_CPU_ID_YC:\n\tcase AMD_CPU_ID_CB:\n\tcase AMD_CPU_ID_PS:\n\t\tval = amd_pmc_reg_read(pdev, AMD_PMC_SCRATCH_REG_YC);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (dev)\n\t\tpm_pr_dbg(\"SMU idlemask s0i3: 0x%x\\n\", val);\n\n\tif (s)\n\t\tseq_printf(s, \"SMU idlemask : 0x%x\\n\", val);\n\n\treturn 0;\n}\n\nstatic int amd_pmc_idlemask_show(struct seq_file *s, void *unused)\n{\n\treturn amd_pmc_idlemask_read(s->private, NULL, s);\n}\nDEFINE_SHOW_ATTRIBUTE(amd_pmc_idlemask);\n\nstatic void amd_pmc_dbgfs_unregister(struct amd_pmc_dev *dev)\n{\n\tdebugfs_remove_recursive(dev->dbgfs_dir);\n}\n\nstatic bool amd_pmc_is_stb_supported(struct amd_pmc_dev *dev)\n{\n\tswitch (dev->cpu_id) {\n\tcase AMD_CPU_ID_YC:\n\tcase AMD_CPU_ID_CB:\n\tcase AMD_CPU_ID_PS:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic void amd_pmc_dbgfs_register(struct amd_pmc_dev *dev)\n{\n\tdev->dbgfs_dir = debugfs_create_dir(\"amd_pmc\", NULL);\n\tdebugfs_create_file(\"smu_fw_info\", 0644, dev->dbgfs_dir, dev,\n\t\t\t    &smu_fw_info_fops);\n\tdebugfs_create_file(\"s0ix_stats\", 0644, dev->dbgfs_dir, dev,\n\t\t\t    &s0ix_stats_fops);\n\tdebugfs_create_file(\"amd_pmc_idlemask\", 0644, dev->dbgfs_dir, dev,\n\t\t\t    &amd_pmc_idlemask_fops);\n\t \n\tif (enable_stb) {\n\t\tif (amd_pmc_is_stb_supported(dev))\n\t\t\tdebugfs_create_file(\"stb_read\", 0644, dev->dbgfs_dir, dev,\n\t\t\t\t\t    &amd_pmc_stb_debugfs_fops_v2);\n\t\telse\n\t\t\tdebugfs_create_file(\"stb_read\", 0644, dev->dbgfs_dir, dev,\n\t\t\t\t\t    &amd_pmc_stb_debugfs_fops);\n\t}\n}\n\nstatic void amd_pmc_dump_registers(struct amd_pmc_dev *dev)\n{\n\tu32 value, message, argument, response;\n\n\tif (dev->msg_port) {\n\t\tmessage = AMD_S2D_REGISTER_MESSAGE;\n\t\targument = AMD_S2D_REGISTER_ARGUMENT;\n\t\tresponse = AMD_S2D_REGISTER_RESPONSE;\n\t} else {\n\t\tmessage = AMD_PMC_REGISTER_MESSAGE;\n\t\targument = AMD_PMC_REGISTER_ARGUMENT;\n\t\tresponse = AMD_PMC_REGISTER_RESPONSE;\n\t}\n\n\tvalue = amd_pmc_reg_read(dev, response);\n\tdev_dbg(dev->dev, \"AMD_%s_REGISTER_RESPONSE:%x\\n\", dev->msg_port ? \"S2D\" : \"PMC\", value);\n\n\tvalue = amd_pmc_reg_read(dev, argument);\n\tdev_dbg(dev->dev, \"AMD_%s_REGISTER_ARGUMENT:%x\\n\", dev->msg_port ? \"S2D\" : \"PMC\", value);\n\n\tvalue = amd_pmc_reg_read(dev, message);\n\tdev_dbg(dev->dev, \"AMD_%s_REGISTER_MESSAGE:%x\\n\", dev->msg_port ? \"S2D\" : \"PMC\", value);\n}\n\nstatic int amd_pmc_send_cmd(struct amd_pmc_dev *dev, u32 arg, u32 *data, u8 msg, bool ret)\n{\n\tint rc;\n\tu32 val, message, argument, response;\n\n\tmutex_lock(&dev->lock);\n\n\tif (dev->msg_port) {\n\t\tmessage = AMD_S2D_REGISTER_MESSAGE;\n\t\targument = AMD_S2D_REGISTER_ARGUMENT;\n\t\tresponse = AMD_S2D_REGISTER_RESPONSE;\n\t} else {\n\t\tmessage = AMD_PMC_REGISTER_MESSAGE;\n\t\targument = AMD_PMC_REGISTER_ARGUMENT;\n\t\tresponse = AMD_PMC_REGISTER_RESPONSE;\n\t}\n\n\t \n\trc = readx_poll_timeout(ioread32, dev->regbase + response,\n\t\t\t\tval, val != 0, PMC_MSG_DELAY_MIN_US,\n\t\t\t\tPMC_MSG_DELAY_MIN_US * RESPONSE_REGISTER_LOOP_MAX);\n\tif (rc) {\n\t\tdev_err(dev->dev, \"failed to talk to SMU\\n\");\n\t\tgoto out_unlock;\n\t}\n\n\t \n\tamd_pmc_reg_write(dev, response, 0);\n\n\t \n\tamd_pmc_reg_write(dev, argument, arg);\n\n\t \n\tamd_pmc_reg_write(dev, message, msg);\n\n\t \n\trc = readx_poll_timeout(ioread32, dev->regbase + response,\n\t\t\t\tval, val != 0, PMC_MSG_DELAY_MIN_US,\n\t\t\t\tPMC_MSG_DELAY_MIN_US * RESPONSE_REGISTER_LOOP_MAX);\n\tif (rc) {\n\t\tdev_err(dev->dev, \"SMU response timed out\\n\");\n\t\tgoto out_unlock;\n\t}\n\n\tswitch (val) {\n\tcase AMD_PMC_RESULT_OK:\n\t\tif (ret) {\n\t\t\t \n\t\t\tusleep_range(DELAY_MIN_US, 10 * DELAY_MAX_US);\n\t\t\t*data = amd_pmc_reg_read(dev, argument);\n\t\t}\n\t\tbreak;\n\tcase AMD_PMC_RESULT_CMD_REJECT_BUSY:\n\t\tdev_err(dev->dev, \"SMU not ready. err: 0x%x\\n\", val);\n\t\trc = -EBUSY;\n\t\tgoto out_unlock;\n\tcase AMD_PMC_RESULT_CMD_UNKNOWN:\n\t\tdev_err(dev->dev, \"SMU cmd unknown. err: 0x%x\\n\", val);\n\t\trc = -EINVAL;\n\t\tgoto out_unlock;\n\tcase AMD_PMC_RESULT_CMD_REJECT_PREREQ:\n\tcase AMD_PMC_RESULT_FAILED:\n\tdefault:\n\t\tdev_err(dev->dev, \"SMU cmd failed. err: 0x%x\\n\", val);\n\t\trc = -EIO;\n\t\tgoto out_unlock;\n\t}\n\nout_unlock:\n\tmutex_unlock(&dev->lock);\n\tamd_pmc_dump_registers(dev);\n\treturn rc;\n}\n\nstatic int amd_pmc_get_os_hint(struct amd_pmc_dev *dev)\n{\n\tswitch (dev->cpu_id) {\n\tcase AMD_CPU_ID_PCO:\n\t\treturn MSG_OS_HINT_PCO;\n\tcase AMD_CPU_ID_RN:\n\tcase AMD_CPU_ID_YC:\n\tcase AMD_CPU_ID_CB:\n\tcase AMD_CPU_ID_PS:\n\t\treturn MSG_OS_HINT_RN;\n\t}\n\treturn -EINVAL;\n}\n\nstatic int amd_pmc_wa_irq1(struct amd_pmc_dev *pdev)\n{\n\tstruct device *d;\n\tint rc;\n\n\t \n\tif (pdev->cpu_id == AMD_CPU_ID_CZN) {\n\t\tif (!pdev->major) {\n\t\t\trc = amd_pmc_get_smu_version(pdev);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t}\n\n\t\tif (pdev->major > 64 || (pdev->major == 64 && pdev->minor > 65))\n\t\t\treturn 0;\n\t}\n\n\td = bus_find_device_by_name(&serio_bus, NULL, \"serio0\");\n\tif (!d)\n\t\treturn 0;\n\tif (device_may_wakeup(d)) {\n\t\tdev_info_once(d, \"Disabling IRQ1 wakeup source to avoid platform firmware bug\\n\");\n\t\tdisable_irq_wake(1);\n\t\tdevice_set_wakeup_enable(d, false);\n\t}\n\tput_device(d);\n\n\treturn 0;\n}\n\nstatic int amd_pmc_verify_czn_rtc(struct amd_pmc_dev *pdev, u32 *arg)\n{\n\tstruct rtc_device *rtc_device;\n\ttime64_t then, now, duration;\n\tstruct rtc_wkalrm alarm;\n\tstruct rtc_time tm;\n\tint rc;\n\n\t \n\tif (!pdev->major) {\n\t\trc = amd_pmc_get_smu_version(pdev);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\tif (pdev->major < 64 || (pdev->major == 64 && pdev->minor < 53))\n\t\treturn 0;\n\n\trtc_device = rtc_class_open(\"rtc0\");\n\tif (!rtc_device)\n\t\treturn 0;\n\trc = rtc_read_alarm(rtc_device, &alarm);\n\tif (rc)\n\t\treturn rc;\n\tif (!alarm.enabled) {\n\t\tdev_dbg(pdev->dev, \"alarm not enabled\\n\");\n\t\treturn 0;\n\t}\n\trc = rtc_read_time(rtc_device, &tm);\n\tif (rc)\n\t\treturn rc;\n\tthen = rtc_tm_to_time64(&alarm.time);\n\tnow = rtc_tm_to_time64(&tm);\n\tduration = then-now;\n\n\t \n\tif (then < now)\n\t\treturn 0;\n\n\t \n\tif (duration <= 4 || duration > U16_MAX)\n\t\treturn -EINVAL;\n\n\t*arg |= (duration << 16);\n\trc = rtc_alarm_irq_enable(rtc_device, 0);\n\tpm_pr_dbg(\"wakeup timer programmed for %lld seconds\\n\", duration);\n\n\treturn rc;\n}\n\nstatic void amd_pmc_s2idle_prepare(void)\n{\n\tstruct amd_pmc_dev *pdev = &pmc;\n\tint rc;\n\tu8 msg;\n\tu32 arg = 1;\n\n\t \n\tamd_pmc_setup_smu_logging(pdev);\n\n\t \n\tif (pdev->cpu_id == AMD_CPU_ID_CZN && !disable_workarounds) {\n\t\trc = amd_pmc_verify_czn_rtc(pdev, &arg);\n\t\tif (rc) {\n\t\t\tdev_err(pdev->dev, \"failed to set RTC: %d\\n\", rc);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tmsg = amd_pmc_get_os_hint(pdev);\n\trc = amd_pmc_send_cmd(pdev, arg, NULL, msg, false);\n\tif (rc) {\n\t\tdev_err(pdev->dev, \"suspend failed: %d\\n\", rc);\n\t\treturn;\n\t}\n\n\trc = amd_pmc_write_stb(pdev, AMD_PMC_STB_S2IDLE_PREPARE);\n\tif (rc)\n\t\tdev_err(pdev->dev, \"error writing to STB: %d\\n\", rc);\n}\n\nstatic void amd_pmc_s2idle_check(void)\n{\n\tstruct amd_pmc_dev *pdev = &pmc;\n\tstruct smu_metrics table;\n\tint rc;\n\n\t \n\tif (pdev->cpu_id == AMD_CPU_ID_CZN && !get_metrics_table(pdev, &table) &&\n\t    table.s0i3_last_entry_status)\n\t\tusleep_range(10000, 20000);\n\n\t \n\tamd_pmc_idlemask_read(pdev, pdev->dev, NULL);\n\n\trc = amd_pmc_write_stb(pdev, AMD_PMC_STB_S2IDLE_CHECK);\n\tif (rc)\n\t\tdev_err(pdev->dev, \"error writing to STB: %d\\n\", rc);\n}\n\nstatic int amd_pmc_dump_data(struct amd_pmc_dev *pdev)\n{\n\tif (pdev->cpu_id == AMD_CPU_ID_PCO)\n\t\treturn -ENODEV;\n\n\treturn amd_pmc_send_cmd(pdev, 0, NULL, SMU_MSG_LOG_DUMP_DATA, false);\n}\n\nstatic void amd_pmc_s2idle_restore(void)\n{\n\tstruct amd_pmc_dev *pdev = &pmc;\n\tint rc;\n\tu8 msg;\n\n\tmsg = amd_pmc_get_os_hint(pdev);\n\trc = amd_pmc_send_cmd(pdev, 0, NULL, msg, false);\n\tif (rc)\n\t\tdev_err(pdev->dev, \"resume failed: %d\\n\", rc);\n\n\t \n\tamd_pmc_dump_data(pdev);\n\n\trc = amd_pmc_write_stb(pdev, AMD_PMC_STB_S2IDLE_RESTORE);\n\tif (rc)\n\t\tdev_err(pdev->dev, \"error writing to STB: %d\\n\", rc);\n\n\t \n\tamd_pmc_validate_deepest(pdev);\n\n\tamd_pmc_process_restore_quirks(pdev);\n}\n\nstatic struct acpi_s2idle_dev_ops amd_pmc_s2idle_dev_ops = {\n\t.prepare = amd_pmc_s2idle_prepare,\n\t.check = amd_pmc_s2idle_check,\n\t.restore = amd_pmc_s2idle_restore,\n};\n\nstatic int amd_pmc_suspend_handler(struct device *dev)\n{\n\tstruct amd_pmc_dev *pdev = dev_get_drvdata(dev);\n\n\tif (pdev->disable_8042_wakeup && !disable_workarounds) {\n\t\tint rc = amd_pmc_wa_irq1(pdev);\n\n\t\tif (rc) {\n\t\t\tdev_err(pdev->dev, \"failed to adjust keyboard wakeup: %d\\n\", rc);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(amd_pmc_pm, amd_pmc_suspend_handler, NULL);\n\nstatic const struct pci_device_id pmc_pci_ids[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_AMD, AMD_CPU_ID_PS) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_AMD, AMD_CPU_ID_CB) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_AMD, AMD_CPU_ID_YC) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_AMD, AMD_CPU_ID_CZN) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_AMD, AMD_CPU_ID_RN) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_AMD, AMD_CPU_ID_PCO) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_AMD, AMD_CPU_ID_RV) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_AMD, AMD_CPU_ID_SP) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_1AH_M20H_ROOT) },\n\t{ }\n};\n\nstatic int amd_pmc_s2d_init(struct amd_pmc_dev *dev)\n{\n\tu32 phys_addr_low, phys_addr_hi;\n\tu64 stb_phys_addr;\n\tu32 size = 0;\n\tint ret;\n\n\t \n\tdev->msg_port = 1;\n\n\t \n\tamd_pmc_get_ip_info(dev);\n\n\tamd_pmc_send_cmd(dev, S2D_TELEMETRY_SIZE, &size, dev->s2d_msg_id, true);\n\tif (size != S2D_TELEMETRY_BYTES_MAX)\n\t\treturn -EIO;\n\n\t \n\tret = amd_pmc_send_cmd(dev, S2D_DRAM_SIZE, &dev->dram_size, dev->s2d_msg_id, true);\n\tif (ret || !dev->dram_size)\n\t\tdev->dram_size = S2D_TELEMETRY_DRAMBYTES_MAX;\n\n\t \n\tamd_pmc_send_cmd(dev, S2D_PHYS_ADDR_LOW, &phys_addr_low, dev->s2d_msg_id, true);\n\tamd_pmc_send_cmd(dev, S2D_PHYS_ADDR_HIGH, &phys_addr_hi, dev->s2d_msg_id, true);\n\n\tstb_phys_addr = ((u64)phys_addr_hi << 32 | phys_addr_low);\n\n\t \n\tdev->msg_port = 0;\n\n\tdev->stb_virt_addr = devm_ioremap(dev->dev, stb_phys_addr, dev->dram_size);\n\tif (!dev->stb_virt_addr)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic int amd_pmc_write_stb(struct amd_pmc_dev *dev, u32 data)\n{\n\tint err;\n\n\terr = amd_smn_write(0, AMD_PMC_STB_PMI_0, data);\n\tif (err) {\n\t\tdev_err(dev->dev, \"failed to write data in stb: 0x%X\\n\", AMD_PMC_STB_PMI_0);\n\t\treturn pcibios_err_to_errno(err);\n\t}\n\n\treturn 0;\n}\n\nstatic int amd_pmc_read_stb(struct amd_pmc_dev *dev, u32 *buf)\n{\n\tint i, err;\n\n\tfor (i = 0; i < FIFO_SIZE; i++) {\n\t\terr = amd_smn_read(0, AMD_PMC_STB_PMI_0, buf++);\n\t\tif (err) {\n\t\t\tdev_err(dev->dev, \"error reading data from stb: 0x%X\\n\", AMD_PMC_STB_PMI_0);\n\t\t\treturn pcibios_err_to_errno(err);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int amd_pmc_probe(struct platform_device *pdev)\n{\n\tstruct amd_pmc_dev *dev = &pmc;\n\tstruct pci_dev *rdev;\n\tu32 base_addr_lo, base_addr_hi;\n\tu64 base_addr;\n\tint err;\n\tu32 val;\n\n\tdev->dev = &pdev->dev;\n\n\trdev = pci_get_domain_bus_and_slot(0, 0, PCI_DEVFN(0, 0));\n\tif (!rdev || !pci_match_id(pmc_pci_ids, rdev)) {\n\t\terr = -ENODEV;\n\t\tgoto err_pci_dev_put;\n\t}\n\n\tdev->cpu_id = rdev->device;\n\n\tif (dev->cpu_id == AMD_CPU_ID_SP) {\n\t\tdev_warn_once(dev->dev, \"S0i3 is not supported on this hardware\\n\");\n\t\terr = -ENODEV;\n\t\tgoto err_pci_dev_put;\n\t}\n\n\tdev->rdev = rdev;\n\terr = amd_smn_read(0, AMD_PMC_BASE_ADDR_LO, &val);\n\tif (err) {\n\t\tdev_err(dev->dev, \"error reading 0x%x\\n\", AMD_PMC_BASE_ADDR_LO);\n\t\terr = pcibios_err_to_errno(err);\n\t\tgoto err_pci_dev_put;\n\t}\n\n\tbase_addr_lo = val & AMD_PMC_BASE_ADDR_HI_MASK;\n\n\terr = amd_smn_read(0, AMD_PMC_BASE_ADDR_HI, &val);\n\tif (err) {\n\t\tdev_err(dev->dev, \"error reading 0x%x\\n\", AMD_PMC_BASE_ADDR_HI);\n\t\terr = pcibios_err_to_errno(err);\n\t\tgoto err_pci_dev_put;\n\t}\n\n\tbase_addr_hi = val & AMD_PMC_BASE_ADDR_LO_MASK;\n\tbase_addr = ((u64)base_addr_hi << 32 | base_addr_lo);\n\n\tdev->regbase = devm_ioremap(dev->dev, base_addr + AMD_PMC_BASE_ADDR_OFFSET,\n\t\t\t\t    AMD_PMC_MAPPING_SIZE);\n\tif (!dev->regbase) {\n\t\terr = -ENOMEM;\n\t\tgoto err_pci_dev_put;\n\t}\n\n\tmutex_init(&dev->lock);\n\n\tif (enable_stb && amd_pmc_is_stb_supported(dev)) {\n\t\terr = amd_pmc_s2d_init(dev);\n\t\tif (err)\n\t\t\tgoto err_pci_dev_put;\n\t}\n\n\tplatform_set_drvdata(pdev, dev);\n\tif (IS_ENABLED(CONFIG_SUSPEND)) {\n\t\terr = acpi_register_lps0_dev(&amd_pmc_s2idle_dev_ops);\n\t\tif (err)\n\t\t\tdev_warn(dev->dev, \"failed to register LPS0 sleep handler, expect increased power consumption\\n\");\n\t\tif (!disable_workarounds)\n\t\t\tamd_pmc_quirks_init(dev);\n\t}\n\n\tamd_pmc_dbgfs_register(dev);\n\tpm_report_max_hw_sleep(U64_MAX);\n\treturn 0;\n\nerr_pci_dev_put:\n\tpci_dev_put(rdev);\n\treturn err;\n}\n\nstatic void amd_pmc_remove(struct platform_device *pdev)\n{\n\tstruct amd_pmc_dev *dev = platform_get_drvdata(pdev);\n\n\tif (IS_ENABLED(CONFIG_SUSPEND))\n\t\tacpi_unregister_lps0_dev(&amd_pmc_s2idle_dev_ops);\n\tamd_pmc_dbgfs_unregister(dev);\n\tpci_dev_put(dev->rdev);\n\tmutex_destroy(&dev->lock);\n}\n\nstatic const struct acpi_device_id amd_pmc_acpi_ids[] = {\n\t{\"AMDI0005\", 0},\n\t{\"AMDI0006\", 0},\n\t{\"AMDI0007\", 0},\n\t{\"AMDI0008\", 0},\n\t{\"AMDI0009\", 0},\n\t{\"AMDI000A\", 0},\n\t{\"AMD0004\", 0},\n\t{\"AMD0005\", 0},\n\t{ }\n};\nMODULE_DEVICE_TABLE(acpi, amd_pmc_acpi_ids);\n\nstatic struct platform_driver amd_pmc_driver = {\n\t.driver = {\n\t\t.name = \"amd_pmc\",\n\t\t.acpi_match_table = amd_pmc_acpi_ids,\n\t\t.dev_groups = pmc_groups,\n\t\t.pm = pm_sleep_ptr(&amd_pmc_pm),\n\t},\n\t.probe = amd_pmc_probe,\n\t.remove_new = amd_pmc_remove,\n};\nmodule_platform_driver(amd_pmc_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"AMD PMC Driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}