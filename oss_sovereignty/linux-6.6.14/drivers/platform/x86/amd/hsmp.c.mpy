{
  "module_name": "hsmp.c",
  "hash_id": "0bb17f5817af7042210493c947219560098af49653eba24f89681c561a9d6b48",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/x86/amd/hsmp.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <asm/amd_hsmp.h>\n#include <asm/amd_nb.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/miscdevice.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/platform_device.h>\n#include <linux/semaphore.h>\n\n#define DRIVER_NAME\t\t\"amd_hsmp\"\n#define DRIVER_VERSION\t\t\"1.0\"\n\n \n#define HSMP_STATUS_NOT_READY\t0x00\n#define HSMP_STATUS_OK\t\t0x01\n#define HSMP_ERR_INVALID_MSG\t0xFE\n#define HSMP_ERR_INVALID_INPUT\t0xFF\n\n \n#define HSMP_MSG_TIMEOUT\t100\n#define HSMP_SHORT_SLEEP\t1\n\n#define HSMP_WR\t\t\ttrue\n#define HSMP_RD\t\t\tfalse\n\n \n#define SMN_HSMP_MSG_ID\t\t0x3B10534\n#define SMN_HSMP_MSG_RESP\t0x3B10980\n#define SMN_HSMP_MSG_DATA\t0x3B109E0\n\n#define HSMP_INDEX_REG\t\t0xc4\n#define HSMP_DATA_REG\t\t0xc8\n\nstatic struct semaphore *hsmp_sem;\n\nstatic struct miscdevice hsmp_device;\n\nstatic int amd_hsmp_rdwr(struct pci_dev *root, u32 address,\n\t\t\t u32 *value, bool write)\n{\n\tint ret;\n\n\tret = pci_write_config_dword(root, HSMP_INDEX_REG, address);\n\tif (ret)\n\t\treturn ret;\n\n\tret = (write ? pci_write_config_dword(root, HSMP_DATA_REG, *value)\n\t\t     : pci_read_config_dword(root, HSMP_DATA_REG, value));\n\n\treturn ret;\n}\n\n \nstatic int __hsmp_send_message(struct pci_dev *root, struct hsmp_message *msg)\n{\n\tunsigned long timeout, short_sleep;\n\tu32 mbox_status;\n\tu32 index;\n\tint ret;\n\n\t \n\tmbox_status = HSMP_STATUS_NOT_READY;\n\tret = amd_hsmp_rdwr(root, SMN_HSMP_MSG_RESP, &mbox_status, HSMP_WR);\n\tif (ret) {\n\t\tpr_err(\"Error %d clearing mailbox status register\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tindex = 0;\n\t \n\twhile (index < msg->num_args) {\n\t\tret = amd_hsmp_rdwr(root, SMN_HSMP_MSG_DATA + (index << 2),\n\t\t\t\t    &msg->args[index], HSMP_WR);\n\t\tif (ret) {\n\t\t\tpr_err(\"Error %d writing message argument %d\\n\", ret, index);\n\t\t\treturn ret;\n\t\t}\n\t\tindex++;\n\t}\n\n\t \n\tret = amd_hsmp_rdwr(root, SMN_HSMP_MSG_ID, &msg->msg_id, HSMP_WR);\n\tif (ret) {\n\t\tpr_err(\"Error %d writing message ID %u\\n\", ret, msg->msg_id);\n\t\treturn ret;\n\t}\n\n\t \n\tshort_sleep = jiffies + msecs_to_jiffies(HSMP_SHORT_SLEEP);\n\ttimeout\t= jiffies + msecs_to_jiffies(HSMP_MSG_TIMEOUT);\n\n\twhile (time_before(jiffies, timeout)) {\n\t\tret = amd_hsmp_rdwr(root, SMN_HSMP_MSG_RESP, &mbox_status, HSMP_RD);\n\t\tif (ret) {\n\t\t\tpr_err(\"Error %d reading mailbox status\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (mbox_status != HSMP_STATUS_NOT_READY)\n\t\t\tbreak;\n\t\tif (time_before(jiffies, short_sleep))\n\t\t\tusleep_range(50, 100);\n\t\telse\n\t\t\tusleep_range(1000, 2000);\n\t}\n\n\tif (unlikely(mbox_status == HSMP_STATUS_NOT_READY)) {\n\t\treturn -ETIMEDOUT;\n\t} else if (unlikely(mbox_status == HSMP_ERR_INVALID_MSG)) {\n\t\treturn -ENOMSG;\n\t} else if (unlikely(mbox_status == HSMP_ERR_INVALID_INPUT)) {\n\t\treturn -EINVAL;\n\t} else if (unlikely(mbox_status != HSMP_STATUS_OK)) {\n\t\tpr_err(\"Message ID %u unknown failure (status = 0x%X)\\n\",\n\t\t       msg->msg_id, mbox_status);\n\t\treturn -EIO;\n\t}\n\n\t \n\tindex = 0;\n\twhile (index < msg->response_sz) {\n\t\tret = amd_hsmp_rdwr(root, SMN_HSMP_MSG_DATA + (index << 2),\n\t\t\t\t    &msg->args[index], HSMP_RD);\n\t\tif (ret) {\n\t\t\tpr_err(\"Error %d reading response %u for message ID:%u\\n\",\n\t\t\t       ret, index, msg->msg_id);\n\t\t\tbreak;\n\t\t}\n\t\tindex++;\n\t}\n\n\treturn ret;\n}\n\nstatic int validate_message(struct hsmp_message *msg)\n{\n\t \n\tif (msg->msg_id < HSMP_TEST || msg->msg_id >= HSMP_MSG_ID_MAX)\n\t\treturn -ENOMSG;\n\n\t \n\tif (hsmp_msg_desc_table[msg->msg_id].type == HSMP_RSVD)\n\t\treturn -ENOMSG;\n\n\t \n\tif (msg->num_args != hsmp_msg_desc_table[msg->msg_id].num_args ||\n\t    msg->response_sz != hsmp_msg_desc_table[msg->msg_id].response_sz)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nint hsmp_send_message(struct hsmp_message *msg)\n{\n\tstruct amd_northbridge *nb;\n\tint ret;\n\n\tif (!msg)\n\t\treturn -EINVAL;\n\n\tnb = node_to_amd_nb(msg->sock_ind);\n\tif (!nb || !nb->root)\n\t\treturn -ENODEV;\n\n\tret = validate_message(msg);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = down_timeout(&hsmp_sem[msg->sock_ind],\n\t\t\t   msecs_to_jiffies(HSMP_MSG_TIMEOUT));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = __hsmp_send_message(nb->root, msg);\n\n\tup(&hsmp_sem[msg->sock_ind]);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(hsmp_send_message);\n\nstatic int hsmp_test(u16 sock_ind, u32 value)\n{\n\tstruct hsmp_message msg = { 0 };\n\tstruct amd_northbridge *nb;\n\tint ret = -ENODEV;\n\n\tnb = node_to_amd_nb(sock_ind);\n\tif (!nb || !nb->root)\n\t\treturn ret;\n\n\t \n\tmsg.msg_id\t= HSMP_TEST;\n\tmsg.num_args\t= 1;\n\tmsg.response_sz\t= 1;\n\tmsg.args[0]\t= value;\n\tmsg.sock_ind\t= sock_ind;\n\n\tret = __hsmp_send_message(nb->root, &msg);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (msg.args[0] != (value + 1)) {\n\t\tpr_err(\"Socket %d test message failed, Expected 0x%08X, received 0x%08X\\n\",\n\t\t       sock_ind, (value + 1), msg.args[0]);\n\t\treturn -EBADE;\n\t}\n\n\treturn ret;\n}\n\nstatic long hsmp_ioctl(struct file *fp, unsigned int cmd, unsigned long arg)\n{\n\tint __user *arguser = (int  __user *)arg;\n\tstruct hsmp_message msg = { 0 };\n\tint ret;\n\n\tif (copy_struct_from_user(&msg, sizeof(msg), arguser, sizeof(struct hsmp_message)))\n\t\treturn -EFAULT;\n\n\t \n\tif (msg.msg_id < HSMP_TEST || msg.msg_id >= HSMP_MSG_ID_MAX)\n\t\treturn -ENOMSG;\n\n\tswitch (fp->f_mode & (FMODE_WRITE | FMODE_READ)) {\n\tcase FMODE_WRITE:\n\t\t \n\t\tif (hsmp_msg_desc_table[msg.msg_id].type != HSMP_SET)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase FMODE_READ:\n\t\t \n\t\tif (hsmp_msg_desc_table[msg.msg_id].type != HSMP_GET)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase FMODE_READ | FMODE_WRITE:\n\t\t \n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tret = hsmp_send_message(&msg);\n\tif (ret)\n\t\treturn ret;\n\n\tif (hsmp_msg_desc_table[msg.msg_id].response_sz > 0) {\n\t\t \n\t\tif (copy_to_user(arguser, &msg, sizeof(struct hsmp_message)))\n\t\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct file_operations hsmp_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.unlocked_ioctl\t= hsmp_ioctl,\n\t.compat_ioctl\t= hsmp_ioctl,\n};\n\nstatic int hsmp_pltdrv_probe(struct platform_device *pdev)\n{\n\tint i;\n\n\thsmp_sem = devm_kzalloc(&pdev->dev,\n\t\t\t\t(amd_nb_num() * sizeof(struct semaphore)),\n\t\t\t\tGFP_KERNEL);\n\tif (!hsmp_sem)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < amd_nb_num(); i++)\n\t\tsema_init(&hsmp_sem[i], 1);\n\n\thsmp_device.name\t= \"hsmp_cdev\";\n\thsmp_device.minor\t= MISC_DYNAMIC_MINOR;\n\thsmp_device.fops\t= &hsmp_fops;\n\thsmp_device.parent\t= &pdev->dev;\n\thsmp_device.nodename\t= \"hsmp\";\n\thsmp_device.mode\t= 0644;\n\n\treturn misc_register(&hsmp_device);\n}\n\nstatic void hsmp_pltdrv_remove(struct platform_device *pdev)\n{\n\tmisc_deregister(&hsmp_device);\n}\n\nstatic struct platform_driver amd_hsmp_driver = {\n\t.probe\t\t= hsmp_pltdrv_probe,\n\t.remove_new\t= hsmp_pltdrv_remove,\n\t.driver\t\t= {\n\t\t.name\t= DRIVER_NAME,\n\t},\n};\n\nstatic struct platform_device *amd_hsmp_platdev;\n\nstatic int __init hsmp_plt_init(void)\n{\n\tint ret = -ENODEV;\n\tu16 num_sockets;\n\tint i;\n\n\tif (boot_cpu_data.x86_vendor != X86_VENDOR_AMD || boot_cpu_data.x86 < 0x19) {\n\t\tpr_err(\"HSMP is not supported on Family:%x model:%x\\n\",\n\t\t       boot_cpu_data.x86, boot_cpu_data.x86_model);\n\t\treturn ret;\n\t}\n\n\t \n\tnum_sockets = amd_nb_num();\n\tif (num_sockets == 0)\n\t\treturn ret;\n\n\t \n\tfor (i = 0; i < num_sockets; i++) {\n\t\tret = hsmp_test(i, 0xDEADBEEF);\n\t\tif (ret) {\n\t\t\tpr_err(\"HSMP is not supported on Fam:%x model:%x\\n\",\n\t\t\t       boot_cpu_data.x86, boot_cpu_data.x86_model);\n\t\t\tpr_err(\"Or Is HSMP disabled in BIOS ?\\n\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t}\n\n\tret = platform_driver_register(&amd_hsmp_driver);\n\tif (ret)\n\t\treturn ret;\n\n\tamd_hsmp_platdev = platform_device_alloc(DRIVER_NAME, PLATFORM_DEVID_NONE);\n\tif (!amd_hsmp_platdev) {\n\t\tret = -ENOMEM;\n\t\tgoto drv_unregister;\n\t}\n\n\tret = platform_device_add(amd_hsmp_platdev);\n\tif (ret) {\n\t\tplatform_device_put(amd_hsmp_platdev);\n\t\tgoto drv_unregister;\n\t}\n\n\treturn 0;\n\ndrv_unregister:\n\tplatform_driver_unregister(&amd_hsmp_driver);\n\treturn ret;\n}\n\nstatic void __exit hsmp_plt_exit(void)\n{\n\tplatform_device_unregister(amd_hsmp_platdev);\n\tplatform_driver_unregister(&amd_hsmp_driver);\n}\n\ndevice_initcall(hsmp_plt_init);\nmodule_exit(hsmp_plt_exit);\n\nMODULE_DESCRIPTION(\"AMD HSMP Platform Interface Driver\");\nMODULE_VERSION(DRIVER_VERSION);\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}