{
  "module_name": "barco-p50-gpio.c",
  "hash_id": "512d22c6fe1ef06d3b32c6d3886e7fa0be72c846aba98e0df2aa05cdaf6e4736",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/x86/barco-p50-gpio.c",
  "human_readable_source": "\n\n \n\n#define pr_fmt(fmt)\tKBUILD_MODNAME \": \" fmt\n\n#include <linux/delay.h>\n#include <linux/dmi.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/leds.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/gpio_keys.h>\n#include <linux/gpio/driver.h>\n#include <linux/gpio/machine.h>\n#include <linux/input.h>\n\n\n#define DRIVER_NAME\t\t\"barco-p50-gpio\"\n\n \n#define P50_GPIO_LINE_LED\t0\n#define P50_GPIO_LINE_BTN\t1\n\n \n#define P50_GPIO_IO_PORT_BASE\t0x299\n\n#define P50_PORT_DATA\t\t0x00\n#define P50_PORT_CMD\t\t0x01\n\n#define P50_STATUS_OBF\t\t0x01  \n#define P50_STATUS_IBF\t\t0x02  \n\n#define P50_CMD_READ\t\t0xa0\n#define P50_CMD_WRITE\t\t0x50\n\n \n#define P50_MBOX_REG_CMD\t0x00\n#define P50_MBOX_REG_STATUS\t0x01\n#define P50_MBOX_REG_PARAM\t0x02\n#define P50_MBOX_REG_DATA\t0x03\n\n#define P50_MBOX_CMD_READ_GPIO\t0x11\n#define P50_MBOX_CMD_WRITE_GPIO\t0x12\n#define P50_MBOX_CMD_CLEAR\t0xff\n\n#define P50_MBOX_STATUS_SUCCESS\t0x01\n\n#define P50_MBOX_PARAM_LED\t0x12\n#define P50_MBOX_PARAM_BTN\t0x13\n\n\nstruct p50_gpio {\n\tstruct gpio_chip gc;\n\tstruct mutex lock;\n\tunsigned long base;\n\tstruct platform_device *leds_pdev;\n\tstruct platform_device *keys_pdev;\n};\n\nstatic struct platform_device *gpio_pdev;\n\nstatic int gpio_params[] = {\n\t[P50_GPIO_LINE_LED] = P50_MBOX_PARAM_LED,\n\t[P50_GPIO_LINE_BTN] = P50_MBOX_PARAM_BTN,\n};\n\nstatic const char * const gpio_names[] = {\n\t[P50_GPIO_LINE_LED] = \"identify-led\",\n\t[P50_GPIO_LINE_BTN] = \"identify-button\",\n};\n\n\nstatic struct gpiod_lookup_table p50_gpio_led_table = {\n\t.dev_id = \"leds-gpio\",\n\t.table = {\n\t\tGPIO_LOOKUP_IDX(DRIVER_NAME, P50_GPIO_LINE_LED, NULL, 0, GPIO_ACTIVE_HIGH),\n\t\t{}\n\t}\n};\n\n \nstatic struct gpio_led leds[] = {\n\t{ .name = \"identify\" }\n};\n\nstatic struct gpio_led_platform_data leds_pdata = {\n\t.num_leds = ARRAY_SIZE(leds),\n\t.leds = leds,\n};\n\n \nstatic struct gpio_keys_button buttons[] = {\n\t{\n\t\t.code = KEY_VENDOR,\n\t\t.gpio = P50_GPIO_LINE_BTN,\n\t\t.active_low = 1,\n\t\t.type = EV_KEY,\n\t\t.value = 1,\n\t},\n};\n\nstatic struct gpio_keys_platform_data keys_pdata = {\n\t.buttons = buttons,\n\t.nbuttons = ARRAY_SIZE(buttons),\n\t.poll_interval = 100,\n\t.rep = 0,\n\t.name = \"identify\",\n};\n\n\n \n\nstatic int p50_wait_ec(struct p50_gpio *p50, int mask, int expected)\n{\n\tint i, val;\n\n\tfor (i = 0; i < 100; i++) {\n\t\tval = inb(p50->base + P50_PORT_CMD) & mask;\n\t\tif (val == expected)\n\t\t\treturn 0;\n\t\tusleep_range(500, 2000);\n\t}\n\n\tdev_err(p50->gc.parent, \"Timed out waiting for EC (0x%x)\\n\", val);\n\treturn -ETIMEDOUT;\n}\n\n\nstatic int p50_read_mbox_reg(struct p50_gpio *p50, int reg)\n{\n\tint ret;\n\n\tret = p50_wait_ec(p50, P50_STATUS_IBF, 0);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tinb(p50->base + P50_PORT_DATA);\n\n\t \n\toutb(P50_CMD_READ | reg, p50->base + P50_PORT_CMD);\n\n\tret = p50_wait_ec(p50, P50_STATUS_OBF, P50_STATUS_OBF);\n\tif (ret)\n\t\treturn ret;\n\n\treturn inb(p50->base + P50_PORT_DATA);\n}\n\nstatic int p50_write_mbox_reg(struct p50_gpio *p50, int reg, int val)\n{\n\tint ret;\n\n\tret = p50_wait_ec(p50, P50_STATUS_IBF, 0);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\toutb(P50_CMD_WRITE | reg, p50->base + P50_PORT_CMD);\n\n\tret = p50_wait_ec(p50, P50_STATUS_IBF, 0);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\toutb(val, p50->base + P50_PORT_DATA);\n\n\treturn 0;\n}\n\n\n \n\nstatic int p50_wait_mbox_idle(struct p50_gpio *p50)\n{\n\tint i, val;\n\n\tfor (i = 0; i < 1000; i++) {\n\t\tval = p50_read_mbox_reg(p50, P50_MBOX_REG_CMD);\n\t\t \n\t\tif (val <= 0)\n\t\t\treturn val;\n\n\t\tusleep_range(500, 2000);\n\t}\n\n\tdev_err(p50->gc.parent,\t\"Timed out waiting for EC mbox idle (CMD: 0x%x)\\n\", val);\n\n\treturn -ETIMEDOUT;\n}\n\nstatic int p50_send_mbox_cmd(struct p50_gpio *p50, int cmd, int param, int data)\n{\n\tint ret;\n\n\tret = p50_wait_mbox_idle(p50);\n\tif (ret)\n\t\treturn ret;\n\n\tret = p50_write_mbox_reg(p50, P50_MBOX_REG_DATA, data);\n\tif (ret)\n\t\treturn ret;\n\n\tret = p50_write_mbox_reg(p50, P50_MBOX_REG_PARAM, param);\n\tif (ret)\n\t\treturn ret;\n\n\tret = p50_write_mbox_reg(p50, P50_MBOX_REG_CMD, cmd);\n\tif (ret)\n\t\treturn ret;\n\n\tret = p50_wait_mbox_idle(p50);\n\tif (ret)\n\t\treturn ret;\n\n\tret = p50_read_mbox_reg(p50, P50_MBOX_REG_STATUS);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ret == P50_MBOX_STATUS_SUCCESS)\n\t\treturn 0;\n\n\tdev_err(p50->gc.parent,\t\"Mbox command failed (CMD=0x%x STAT=0x%x PARAM=0x%x DATA=0x%x)\\n\",\n\t\tcmd, ret, param, data);\n\n\treturn -EIO;\n}\n\n\n \n\nstatic int p50_gpio_get_direction(struct gpio_chip *gc, unsigned int offset)\n{\n\tswitch (offset) {\n\tcase P50_GPIO_LINE_BTN:\n\t\treturn GPIO_LINE_DIRECTION_IN;\n\n\tcase P50_GPIO_LINE_LED:\n\t\treturn GPIO_LINE_DIRECTION_OUT;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int p50_gpio_get(struct gpio_chip *gc, unsigned int offset)\n{\n\tstruct p50_gpio *p50 = gpiochip_get_data(gc);\n\tint ret;\n\n\tmutex_lock(&p50->lock);\n\n\tret = p50_send_mbox_cmd(p50, P50_MBOX_CMD_READ_GPIO, gpio_params[offset], 0);\n\tif (ret == 0)\n\t\tret = p50_read_mbox_reg(p50, P50_MBOX_REG_DATA);\n\n\tmutex_unlock(&p50->lock);\n\n\treturn ret;\n}\n\nstatic void p50_gpio_set(struct gpio_chip *gc, unsigned int offset, int value)\n{\n\tstruct p50_gpio *p50 = gpiochip_get_data(gc);\n\n\tmutex_lock(&p50->lock);\n\n\tp50_send_mbox_cmd(p50, P50_MBOX_CMD_WRITE_GPIO, gpio_params[offset], value);\n\n\tmutex_unlock(&p50->lock);\n}\n\nstatic int p50_gpio_probe(struct platform_device *pdev)\n{\n\tstruct p50_gpio *p50;\n\tstruct resource *res;\n\tint ret;\n\n\tres = platform_get_resource(pdev, IORESOURCE_IO, 0);\n\tif (!res) {\n\t\tdev_err(&pdev->dev, \"Cannot get I/O ports\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (!devm_request_region(&pdev->dev, res->start, resource_size(res), pdev->name)) {\n\t\tdev_err(&pdev->dev, \"Unable to reserve I/O region\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tp50 = devm_kzalloc(&pdev->dev, sizeof(*p50), GFP_KERNEL);\n\tif (!p50)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, p50);\n\tmutex_init(&p50->lock);\n\tp50->base = res->start;\n\tp50->gc.owner = THIS_MODULE;\n\tp50->gc.parent = &pdev->dev;\n\tp50->gc.label = dev_name(&pdev->dev);\n\tp50->gc.ngpio = ARRAY_SIZE(gpio_names);\n\tp50->gc.names = gpio_names;\n\tp50->gc.can_sleep = true;\n\tp50->gc.base = -1;\n\tp50->gc.get_direction = p50_gpio_get_direction;\n\tp50->gc.get = p50_gpio_get;\n\tp50->gc.set = p50_gpio_set;\n\n\n\t \n\tret = p50_wait_mbox_idle(p50);\n\tif (ret)\n\t\treturn ret;\n\n\tret = p50_write_mbox_reg(p50, P50_MBOX_REG_CMD, P50_MBOX_CMD_CLEAR);\n\tif (ret)\n\t\treturn ret;\n\n\tret = p50_wait_mbox_idle(p50);\n\tif (ret)\n\t\treturn ret;\n\n\n\tret = devm_gpiochip_add_data(&pdev->dev, &p50->gc, p50);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"Could not register gpiochip: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tgpiod_add_lookup_table(&p50_gpio_led_table);\n\n\tp50->leds_pdev = platform_device_register_data(&pdev->dev,\n\t\t\"leds-gpio\", PLATFORM_DEVID_NONE, &leds_pdata, sizeof(leds_pdata));\n\n\tif (IS_ERR(p50->leds_pdev)) {\n\t\tret = PTR_ERR(p50->leds_pdev);\n\t\tdev_err(&pdev->dev, \"Could not register leds-gpio: %d\\n\", ret);\n\t\tgoto err_leds;\n\t}\n\n\t \n\tbuttons[0].gpio += p50->gc.base;\n\n\tp50->keys_pdev =\n\t\tplatform_device_register_data(&pdev->dev, \"gpio-keys-polled\",\n\t\t\t\t\t      PLATFORM_DEVID_NONE,\n\t\t\t\t\t      &keys_pdata, sizeof(keys_pdata));\n\n\tif (IS_ERR(p50->keys_pdev)) {\n\t\tret = PTR_ERR(p50->keys_pdev);\n\t\tdev_err(&pdev->dev, \"Could not register gpio-keys-polled: %d\\n\", ret);\n\t\tgoto err_keys;\n\t}\n\n\treturn 0;\n\nerr_keys:\n\tplatform_device_unregister(p50->leds_pdev);\nerr_leds:\n\tgpiod_remove_lookup_table(&p50_gpio_led_table);\n\n\treturn ret;\n}\n\nstatic void p50_gpio_remove(struct platform_device *pdev)\n{\n\tstruct p50_gpio *p50 = platform_get_drvdata(pdev);\n\n\tplatform_device_unregister(p50->keys_pdev);\n\tplatform_device_unregister(p50->leds_pdev);\n\n\tgpiod_remove_lookup_table(&p50_gpio_led_table);\n}\n\nstatic struct platform_driver p50_gpio_driver = {\n\t.driver = {\n\t\t.name = DRIVER_NAME,\n\t},\n\t.probe = p50_gpio_probe,\n\t.remove_new = p50_gpio_remove,\n};\n\n \nstatic const struct dmi_system_id dmi_ids[] __initconst = {\n\t{\n\t\t.matches = {\n\t\t\tDMI_EXACT_MATCH(DMI_SYS_VENDOR, \"Barco\"),\n\t\t\tDMI_EXACT_MATCH(DMI_PRODUCT_FAMILY, \"P50\")\n\t\t},\n\t},\n\t{}\n};\nMODULE_DEVICE_TABLE(dmi, dmi_ids);\n\nstatic int __init p50_module_init(void)\n{\n\tstruct resource res = DEFINE_RES_IO(P50_GPIO_IO_PORT_BASE, P50_PORT_CMD + 1);\n\tint ret;\n\n\tif (!dmi_first_match(dmi_ids))\n\t\treturn -ENODEV;\n\n\tret = platform_driver_register(&p50_gpio_driver);\n\tif (ret)\n\t\treturn ret;\n\n\tgpio_pdev = platform_device_register_simple(DRIVER_NAME, PLATFORM_DEVID_NONE, &res, 1);\n\tif (IS_ERR(gpio_pdev)) {\n\t\tpr_err(\"failed registering %s: %ld\\n\", DRIVER_NAME, PTR_ERR(gpio_pdev));\n\t\tplatform_driver_unregister(&p50_gpio_driver);\n\t\treturn PTR_ERR(gpio_pdev);\n\t}\n\n\treturn 0;\n}\n\nstatic void __exit p50_module_exit(void)\n{\n\tplatform_device_unregister(gpio_pdev);\n\tplatform_driver_unregister(&p50_gpio_driver);\n}\n\nmodule_init(p50_module_init);\nmodule_exit(p50_module_exit);\n\nMODULE_AUTHOR(\"Santosh Kumar Yadav, Barco NV <santoshkumar.yadav@barco.com>\");\nMODULE_DESCRIPTION(\"Barco P50 identify GPIOs driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}