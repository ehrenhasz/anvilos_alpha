{
  "module_name": "intel_scu_ipcutil.c",
  "hash_id": "15c76eaf39a69336dad138f3d92b6dff54b002bf0521faedec09ce1fe44388ba",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/x86/intel_scu_ipcutil.c",
  "human_readable_source": "\n \n\n#include <linux/errno.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/uaccess.h>\n\n#include <asm/intel_scu_ipc.h>\n\nstatic int major;\n\nstruct intel_scu_ipc_dev *scu;\nstatic DEFINE_MUTEX(scu_lock);\n\n \n#define\tINTE_SCU_IPC_REGISTER_READ\t0\n#define INTE_SCU_IPC_REGISTER_WRITE\t1\n#define INTE_SCU_IPC_REGISTER_UPDATE\t2\n\nstruct scu_ipc_data {\n\tu32     count;   \n\tu16     addr[5];  \n\tu8      data[5];  \n\tu8      mask;  \n};\n\n \n\nstatic int scu_reg_access(u32 cmd, struct scu_ipc_data  *data)\n{\n\tunsigned int count = data->count;\n\n\tif (count == 0 || count == 3 || count > 4)\n\t\treturn -EINVAL;\n\n\tswitch (cmd) {\n\tcase INTE_SCU_IPC_REGISTER_READ:\n\t\treturn intel_scu_ipc_dev_readv(scu, data->addr, data->data, count);\n\tcase INTE_SCU_IPC_REGISTER_WRITE:\n\t\treturn intel_scu_ipc_dev_writev(scu, data->addr, data->data, count);\n\tcase INTE_SCU_IPC_REGISTER_UPDATE:\n\t\treturn intel_scu_ipc_dev_update(scu, data->addr[0], data->data[0],\n\t\t\t\t\t\tdata->mask);\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n}\n\n \nstatic long scu_ipc_ioctl(struct file *fp, unsigned int cmd,\n\t\t\t\t\t\t\tunsigned long arg)\n{\n\tint ret;\n\tstruct scu_ipc_data  data;\n\tvoid __user *argp = (void __user *)arg;\n\n\tif (!capable(CAP_SYS_RAWIO))\n\t\treturn -EPERM;\n\n\tif (copy_from_user(&data, argp, sizeof(struct scu_ipc_data)))\n\t\treturn -EFAULT;\n\tret = scu_reg_access(cmd, &data);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (copy_to_user(argp, &data, sizeof(struct scu_ipc_data)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int scu_ipc_open(struct inode *inode, struct file *file)\n{\n\tint ret = 0;\n\n\t \n\tmutex_lock(&scu_lock);\n\tif (scu) {\n\t\tret = -EBUSY;\n\t\tgoto unlock;\n\t}\n\n\tscu = intel_scu_ipc_dev_get();\n\tif (!scu)\n\t\tret = -ENODEV;\n\nunlock:\n\tmutex_unlock(&scu_lock);\n\treturn ret;\n}\n\nstatic int scu_ipc_release(struct inode *inode, struct file *file)\n{\n\tmutex_lock(&scu_lock);\n\tintel_scu_ipc_dev_put(scu);\n\tscu = NULL;\n\tmutex_unlock(&scu_lock);\n\n\treturn 0;\n}\n\nstatic const struct file_operations scu_ipc_fops = {\n\t.unlocked_ioctl = scu_ipc_ioctl,\n\t.open = scu_ipc_open,\n\t.release = scu_ipc_release,\n};\n\nstatic int __init ipc_module_init(void)\n{\n\tmajor = register_chrdev(0, \"intel_mid_scu\", &scu_ipc_fops);\n\tif (major < 0)\n\t\treturn major;\n\n\treturn 0;\n}\n\nstatic void __exit ipc_module_exit(void)\n{\n\tunregister_chrdev(major, \"intel_mid_scu\");\n}\n\nmodule_init(ipc_module_init);\nmodule_exit(ipc_module_exit);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"Utility driver for intel scu ipc\");\nMODULE_AUTHOR(\"Sreedhara <sreedhara.ds@intel.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}