{
  "module_name": "hdaps.c",
  "hash_id": "4f2052331e9e843ee926de7ba9453746dbef45ce82804364f35d4a66e610bb25",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/x86/hdaps.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/delay.h>\n#include <linux/platform_device.h>\n#include <linux/input.h>\n#include <linux/kernel.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/timer.h>\n#include <linux/dmi.h>\n#include <linux/jiffies.h>\n#include <linux/io.h>\n\n#define HDAPS_LOW_PORT\t\t0x1600\t \n#define HDAPS_NR_PORTS\t\t0x30\t \n\n#define HDAPS_PORT_STATE\t0x1611\t \n#define HDAPS_PORT_YPOS\t\t0x1612\t \n#define\tHDAPS_PORT_XPOS\t\t0x1614\t \n#define HDAPS_PORT_TEMP1\t0x1616\t \n#define HDAPS_PORT_YVAR\t\t0x1617\t \n#define HDAPS_PORT_XVAR\t\t0x1619\t \n#define HDAPS_PORT_TEMP2\t0x161b\t \n#define HDAPS_PORT_UNKNOWN\t0x161c\t \n#define HDAPS_PORT_KMACT\t0x161d\t \n\n#define STATE_FRESH\t\t0x50\t \n\n#define KEYBD_MASK\t\t0x20\t \n#define MOUSE_MASK\t\t0x40\t \n#define KEYBD_ISSET(n)\t\t(!! (n & KEYBD_MASK))\t \n#define MOUSE_ISSET(n)\t\t(!! (n & MOUSE_MASK))\t \n\n#define INIT_TIMEOUT_MSECS\t4000\t \n#define INIT_WAIT_MSECS\t\t200\t \n\n#define HDAPS_POLL_INTERVAL\t50\t \n#define HDAPS_INPUT_FUZZ\t4\t \n#define HDAPS_INPUT_FLAT\t4\n\n#define HDAPS_X_AXIS\t\t(1 << 0)\n#define HDAPS_Y_AXIS\t\t(1 << 1)\n#define HDAPS_BOTH_AXES\t\t(HDAPS_X_AXIS | HDAPS_Y_AXIS)\n\nstatic struct platform_device *pdev;\nstatic struct input_dev *hdaps_idev;\nstatic unsigned int hdaps_invert;\nstatic u8 km_activity;\nstatic int rest_x;\nstatic int rest_y;\n\nstatic DEFINE_MUTEX(hdaps_mtx);\n\n \nstatic inline u8 __get_latch(u16 port)\n{\n\treturn inb(port) & 0xff;\n}\n\n \nstatic inline int __check_latch(u16 port, u8 val)\n{\n\tif (__get_latch(port) == val)\n\t\treturn 0;\n\treturn -EINVAL;\n}\n\n \nstatic int __wait_latch(u16 port, u8 val)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < 20; i++) {\n\t\tif (!__check_latch(port, val))\n\t\t\treturn 0;\n\t\tudelay(5);\n\t}\n\n\treturn -EIO;\n}\n\n \nstatic void __device_refresh(void)\n{\n\tudelay(200);\n\tif (inb(0x1604) != STATE_FRESH) {\n\t\toutb(0x11, 0x1610);\n\t\toutb(0x01, 0x161f);\n\t}\n}\n\n \nstatic int __device_refresh_sync(void)\n{\n\t__device_refresh();\n\treturn __wait_latch(0x1604, STATE_FRESH);\n}\n\n \nstatic inline void __device_complete(void)\n{\n\tinb(0x161f);\n\tinb(0x1604);\n\t__device_refresh();\n}\n\n \nstatic int hdaps_readb_one(unsigned int port, u8 *val)\n{\n\tint ret;\n\n\tmutex_lock(&hdaps_mtx);\n\n\t \n\tret = __device_refresh_sync();\n\tif (ret)\n\t\tgoto out;\n\n\t*val = inb(port);\n\t__device_complete();\n\nout:\n\tmutex_unlock(&hdaps_mtx);\n\treturn ret;\n}\n\n \nstatic int __hdaps_read_pair(unsigned int port1, unsigned int port2,\n\t\t\t     int *x, int *y)\n{\n\t \n\tif (__device_refresh_sync())\n\t\treturn -EIO;\n\n\t*y = inw(port2);\n\t*x = inw(port1);\n\tkm_activity = inb(HDAPS_PORT_KMACT);\n\t__device_complete();\n\n\t \n\tif (hdaps_invert & HDAPS_X_AXIS)\n\t\t*x = -*x;\n\tif (hdaps_invert & HDAPS_Y_AXIS)\n\t\t*y = -*y;\n\n\treturn 0;\n}\n\n \nstatic int hdaps_read_pair(unsigned int port1, unsigned int port2,\n\t\t\t   int *val1, int *val2)\n{\n\tint ret;\n\n\tmutex_lock(&hdaps_mtx);\n\tret = __hdaps_read_pair(port1, port2, val1, val2);\n\tmutex_unlock(&hdaps_mtx);\n\n\treturn ret;\n}\n\n \nstatic int hdaps_device_init(void)\n{\n\tint total, ret = -ENXIO;\n\n\tmutex_lock(&hdaps_mtx);\n\n\toutb(0x13, 0x1610);\n\toutb(0x01, 0x161f);\n\tif (__wait_latch(0x161f, 0x00))\n\t\tgoto out;\n\n\t \n\tif (__check_latch(0x1611, 0x03) &&\n\t\t     __check_latch(0x1611, 0x02) &&\n\t\t     __check_latch(0x1611, 0x01))\n\t\tgoto out;\n\n\tprintk(KERN_DEBUG \"hdaps: initial latch check good (0x%02x)\\n\",\n\t       __get_latch(0x1611));\n\n\toutb(0x17, 0x1610);\n\toutb(0x81, 0x1611);\n\toutb(0x01, 0x161f);\n\tif (__wait_latch(0x161f, 0x00))\n\t\tgoto out;\n\tif (__wait_latch(0x1611, 0x00))\n\t\tgoto out;\n\tif (__wait_latch(0x1612, 0x60))\n\t\tgoto out;\n\tif (__wait_latch(0x1613, 0x00))\n\t\tgoto out;\n\toutb(0x14, 0x1610);\n\toutb(0x01, 0x1611);\n\toutb(0x01, 0x161f);\n\tif (__wait_latch(0x161f, 0x00))\n\t\tgoto out;\n\toutb(0x10, 0x1610);\n\toutb(0xc8, 0x1611);\n\toutb(0x00, 0x1612);\n\toutb(0x02, 0x1613);\n\toutb(0x01, 0x161f);\n\tif (__wait_latch(0x161f, 0x00))\n\t\tgoto out;\n\tif (__device_refresh_sync())\n\t\tgoto out;\n\tif (__wait_latch(0x1611, 0x00))\n\t\tgoto out;\n\n\t \n\tfor (total = INIT_TIMEOUT_MSECS; total > 0; total -= INIT_WAIT_MSECS) {\n\t\tint x, y;\n\n\t\t \n\t\t__hdaps_read_pair(HDAPS_PORT_XPOS, HDAPS_PORT_YPOS, &x, &y);\n\t\tif (!__wait_latch(0x1611, 0x02)) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tmsleep(INIT_WAIT_MSECS);\n\t}\n\nout:\n\tmutex_unlock(&hdaps_mtx);\n\treturn ret;\n}\n\n\n \n\nstatic int hdaps_probe(struct platform_device *dev)\n{\n\tint ret;\n\n\tret = hdaps_device_init();\n\tif (ret)\n\t\treturn ret;\n\n\tpr_info(\"device successfully initialized\\n\");\n\treturn 0;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int hdaps_resume(struct device *dev)\n{\n\treturn hdaps_device_init();\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(hdaps_pm, NULL, hdaps_resume);\n\nstatic struct platform_driver hdaps_driver = {\n\t.probe = hdaps_probe,\n\t.driver\t= {\n\t\t.name = \"hdaps\",\n\t\t.pm = &hdaps_pm,\n\t},\n};\n\n \nstatic void hdaps_calibrate(void)\n{\n\t__hdaps_read_pair(HDAPS_PORT_XPOS, HDAPS_PORT_YPOS, &rest_x, &rest_y);\n}\n\nstatic void hdaps_mousedev_poll(struct input_dev *input_dev)\n{\n\tint x, y;\n\n\tmutex_lock(&hdaps_mtx);\n\n\tif (__hdaps_read_pair(HDAPS_PORT_XPOS, HDAPS_PORT_YPOS, &x, &y))\n\t\tgoto out;\n\n\tinput_report_abs(input_dev, ABS_X, x - rest_x);\n\tinput_report_abs(input_dev, ABS_Y, y - rest_y);\n\tinput_sync(input_dev);\n\nout:\n\tmutex_unlock(&hdaps_mtx);\n}\n\n\n \n\nstatic ssize_t hdaps_position_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tint ret, x, y;\n\n\tret = hdaps_read_pair(HDAPS_PORT_XPOS, HDAPS_PORT_YPOS, &x, &y);\n\tif (ret)\n\t\treturn ret;\n\n\treturn sprintf(buf, \"(%d,%d)\\n\", x, y);\n}\n\nstatic ssize_t hdaps_variance_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tint ret, x, y;\n\n\tret = hdaps_read_pair(HDAPS_PORT_XVAR, HDAPS_PORT_YVAR, &x, &y);\n\tif (ret)\n\t\treturn ret;\n\n\treturn sprintf(buf, \"(%d,%d)\\n\", x, y);\n}\n\nstatic ssize_t hdaps_temp1_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tu8 temp;\n\tint ret;\n\n\tret = hdaps_readb_one(HDAPS_PORT_TEMP1, &temp);\n\tif (ret)\n\t\treturn ret;\n\n\treturn sprintf(buf, \"%u\\n\", temp);\n}\n\nstatic ssize_t hdaps_temp2_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tu8 temp;\n\tint ret;\n\n\tret = hdaps_readb_one(HDAPS_PORT_TEMP2, &temp);\n\tif (ret)\n\t\treturn ret;\n\n\treturn sprintf(buf, \"%u\\n\", temp);\n}\n\nstatic ssize_t hdaps_keyboard_activity_show(struct device *dev,\n\t\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t\t    char *buf)\n{\n\treturn sprintf(buf, \"%u\\n\", KEYBD_ISSET(km_activity));\n}\n\nstatic ssize_t hdaps_mouse_activity_show(struct device *dev,\n\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t char *buf)\n{\n\treturn sprintf(buf, \"%u\\n\", MOUSE_ISSET(km_activity));\n}\n\nstatic ssize_t hdaps_calibrate_show(struct device *dev,\n\t\t\t\t    struct device_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"(%d,%d)\\n\", rest_x, rest_y);\n}\n\nstatic ssize_t hdaps_calibrate_store(struct device *dev,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     const char *buf, size_t count)\n{\n\tmutex_lock(&hdaps_mtx);\n\thdaps_calibrate();\n\tmutex_unlock(&hdaps_mtx);\n\n\treturn count;\n}\n\nstatic ssize_t hdaps_invert_show(struct device *dev,\n\t\t\t\t struct device_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%u\\n\", hdaps_invert);\n}\n\nstatic ssize_t hdaps_invert_store(struct device *dev,\n\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t  const char *buf, size_t count)\n{\n\tint invert;\n\n\tif (sscanf(buf, \"%d\", &invert) != 1 ||\n\t    invert < 0 || invert > HDAPS_BOTH_AXES)\n\t\treturn -EINVAL;\n\n\thdaps_invert = invert;\n\thdaps_calibrate();\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR(position, 0444, hdaps_position_show, NULL);\nstatic DEVICE_ATTR(variance, 0444, hdaps_variance_show, NULL);\nstatic DEVICE_ATTR(temp1, 0444, hdaps_temp1_show, NULL);\nstatic DEVICE_ATTR(temp2, 0444, hdaps_temp2_show, NULL);\nstatic DEVICE_ATTR(keyboard_activity, 0444, hdaps_keyboard_activity_show, NULL);\nstatic DEVICE_ATTR(mouse_activity, 0444, hdaps_mouse_activity_show, NULL);\nstatic DEVICE_ATTR(calibrate, 0644, hdaps_calibrate_show,hdaps_calibrate_store);\nstatic DEVICE_ATTR(invert, 0644, hdaps_invert_show, hdaps_invert_store);\n\nstatic struct attribute *hdaps_attributes[] = {\n\t&dev_attr_position.attr,\n\t&dev_attr_variance.attr,\n\t&dev_attr_temp1.attr,\n\t&dev_attr_temp2.attr,\n\t&dev_attr_keyboard_activity.attr,\n\t&dev_attr_mouse_activity.attr,\n\t&dev_attr_calibrate.attr,\n\t&dev_attr_invert.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group hdaps_attribute_group = {\n\t.attrs = hdaps_attributes,\n};\n\n\n \n\n \nstatic int __init hdaps_dmi_match(const struct dmi_system_id *id)\n{\n\tpr_info(\"%s detected\\n\", id->ident);\n\treturn 1;\n}\n\n \nstatic int __init hdaps_dmi_match_invert(const struct dmi_system_id *id)\n{\n\thdaps_invert = (unsigned long)id->driver_data;\n\tpr_info(\"inverting axis (%u) readings\\n\", hdaps_invert);\n\treturn hdaps_dmi_match(id);\n}\n\n#define HDAPS_DMI_MATCH_INVERT(vendor, model, axes) {\t\\\n\t.ident = vendor \" \" model,\t\t\t\\\n\t.callback = hdaps_dmi_match_invert,\t\t\\\n\t.driver_data = (void *)axes,\t\t\t\\\n\t.matches = {\t\t\t\t\t\\\n\t\tDMI_MATCH(DMI_BOARD_VENDOR, vendor),\t\\\n\t\tDMI_MATCH(DMI_PRODUCT_VERSION, model)\t\\\n\t}\t\t\t\t\t\t\\\n}\n\n#define HDAPS_DMI_MATCH_NORMAL(vendor, model)\t\t\\\n\tHDAPS_DMI_MATCH_INVERT(vendor, model, 0)\n\n \nstatic const struct dmi_system_id hdaps_whitelist[] __initconst = {\n\tHDAPS_DMI_MATCH_INVERT(\"IBM\", \"ThinkPad R50p\", HDAPS_BOTH_AXES),\n\tHDAPS_DMI_MATCH_NORMAL(\"IBM\", \"ThinkPad R50\"),\n\tHDAPS_DMI_MATCH_NORMAL(\"IBM\", \"ThinkPad R51\"),\n\tHDAPS_DMI_MATCH_NORMAL(\"IBM\", \"ThinkPad R52\"),\n\tHDAPS_DMI_MATCH_INVERT(\"LENOVO\", \"ThinkPad R61i\", HDAPS_BOTH_AXES),\n\tHDAPS_DMI_MATCH_INVERT(\"LENOVO\", \"ThinkPad R61\", HDAPS_BOTH_AXES),\n\tHDAPS_DMI_MATCH_INVERT(\"IBM\", \"ThinkPad T41p\", HDAPS_BOTH_AXES),\n\tHDAPS_DMI_MATCH_NORMAL(\"IBM\", \"ThinkPad T41\"),\n\tHDAPS_DMI_MATCH_INVERT(\"IBM\", \"ThinkPad T42p\", HDAPS_BOTH_AXES),\n\tHDAPS_DMI_MATCH_NORMAL(\"IBM\", \"ThinkPad T42\"),\n\tHDAPS_DMI_MATCH_NORMAL(\"IBM\", \"ThinkPad T43\"),\n\tHDAPS_DMI_MATCH_INVERT(\"LENOVO\", \"ThinkPad T400\", HDAPS_BOTH_AXES),\n\tHDAPS_DMI_MATCH_INVERT(\"LENOVO\", \"ThinkPad T60\", HDAPS_BOTH_AXES),\n\tHDAPS_DMI_MATCH_INVERT(\"LENOVO\", \"ThinkPad T61p\", HDAPS_BOTH_AXES),\n\tHDAPS_DMI_MATCH_INVERT(\"LENOVO\", \"ThinkPad T61\", HDAPS_BOTH_AXES),\n\tHDAPS_DMI_MATCH_NORMAL(\"IBM\", \"ThinkPad X40\"),\n\tHDAPS_DMI_MATCH_INVERT(\"IBM\", \"ThinkPad X41\", HDAPS_Y_AXIS),\n\tHDAPS_DMI_MATCH_INVERT(\"LENOVO\", \"ThinkPad X60\", HDAPS_BOTH_AXES),\n\tHDAPS_DMI_MATCH_INVERT(\"LENOVO\", \"ThinkPad X61s\", HDAPS_BOTH_AXES),\n\tHDAPS_DMI_MATCH_INVERT(\"LENOVO\", \"ThinkPad X61\", HDAPS_BOTH_AXES),\n\tHDAPS_DMI_MATCH_NORMAL(\"IBM\", \"ThinkPad Z60m\"),\n\tHDAPS_DMI_MATCH_INVERT(\"LENOVO\", \"ThinkPad Z61m\", HDAPS_BOTH_AXES),\n\tHDAPS_DMI_MATCH_INVERT(\"LENOVO\", \"ThinkPad Z61p\", HDAPS_BOTH_AXES),\n\t{ .ident = NULL }\n};\n\nstatic int __init hdaps_init(void)\n{\n\tint ret;\n\n\tif (!dmi_check_system(hdaps_whitelist)) {\n\t\tpr_warn(\"supported laptop not found!\\n\");\n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tif (!request_region(HDAPS_LOW_PORT, HDAPS_NR_PORTS, \"hdaps\")) {\n\t\tret = -ENXIO;\n\t\tgoto out;\n\t}\n\n\tret = platform_driver_register(&hdaps_driver);\n\tif (ret)\n\t\tgoto out_region;\n\n\tpdev = platform_device_register_simple(\"hdaps\", PLATFORM_DEVID_NONE, NULL, 0);\n\tif (IS_ERR(pdev)) {\n\t\tret = PTR_ERR(pdev);\n\t\tgoto out_driver;\n\t}\n\n\tret = sysfs_create_group(&pdev->dev.kobj, &hdaps_attribute_group);\n\tif (ret)\n\t\tgoto out_device;\n\n\thdaps_idev = input_allocate_device();\n\tif (!hdaps_idev) {\n\t\tret = -ENOMEM;\n\t\tgoto out_group;\n\t}\n\n\t \n\thdaps_calibrate();\n\n\t \n\thdaps_idev->name = \"hdaps\";\n\thdaps_idev->phys = \"isa1600/input0\";\n\thdaps_idev->id.bustype = BUS_ISA;\n\thdaps_idev->dev.parent = &pdev->dev;\n\tinput_set_abs_params(hdaps_idev, ABS_X,\n\t\t\t-256, 256, HDAPS_INPUT_FUZZ, HDAPS_INPUT_FLAT);\n\tinput_set_abs_params(hdaps_idev, ABS_Y,\n\t\t\t-256, 256, HDAPS_INPUT_FUZZ, HDAPS_INPUT_FLAT);\n\n\tret = input_setup_polling(hdaps_idev, hdaps_mousedev_poll);\n\tif (ret)\n\t\tgoto out_idev;\n\n\tinput_set_poll_interval(hdaps_idev, HDAPS_POLL_INTERVAL);\n\n\tret = input_register_device(hdaps_idev);\n\tif (ret)\n\t\tgoto out_idev;\n\n\tpr_info(\"driver successfully loaded\\n\");\n\treturn 0;\n\nout_idev:\n\tinput_free_device(hdaps_idev);\nout_group:\n\tsysfs_remove_group(&pdev->dev.kobj, &hdaps_attribute_group);\nout_device:\n\tplatform_device_unregister(pdev);\nout_driver:\n\tplatform_driver_unregister(&hdaps_driver);\nout_region:\n\trelease_region(HDAPS_LOW_PORT, HDAPS_NR_PORTS);\nout:\n\tpr_warn(\"driver init failed (ret=%d)!\\n\", ret);\n\treturn ret;\n}\n\nstatic void __exit hdaps_exit(void)\n{\n\tinput_unregister_device(hdaps_idev);\n\tsysfs_remove_group(&pdev->dev.kobj, &hdaps_attribute_group);\n\tplatform_device_unregister(pdev);\n\tplatform_driver_unregister(&hdaps_driver);\n\trelease_region(HDAPS_LOW_PORT, HDAPS_NR_PORTS);\n\n\tpr_info(\"driver unloaded\\n\");\n}\n\nmodule_init(hdaps_init);\nmodule_exit(hdaps_exit);\n\nmodule_param_named(invert, hdaps_invert, int, 0);\nMODULE_PARM_DESC(invert, \"invert data along each axis. 1 invert x-axis, \"\n\t\t \"2 invert y-axis, 3 invert both axes.\");\n\nMODULE_AUTHOR(\"Robert Love\");\nMODULE_DESCRIPTION(\"IBM Hard Drive Active Protection System (HDAPS) driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}