{
  "module_name": "lg-laptop.c",
  "hash_id": "79cc271cf66ea3c93ffe8c9110c27a2c3164b18f576008765338a0101b2ef0f4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/x86/lg-laptop.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/acpi.h>\n#include <linux/dmi.h>\n#include <linux/input.h>\n#include <linux/input/sparse-keymap.h>\n#include <linux/kernel.h>\n#include <linux/leds.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/types.h>\n\n#include <acpi/battery.h>\n\n#define LED_DEVICE(_name, max, flag) struct led_classdev _name = { \\\n\t.name           = __stringify(_name),   \\\n\t.max_brightness = max,                  \\\n\t.brightness_set = _name##_set,          \\\n\t.brightness_get = _name##_get,          \\\n\t.flags = flag,                          \\\n}\n\nMODULE_AUTHOR(\"Matan Ziv-Av\");\nMODULE_DESCRIPTION(\"LG WMI Hotkey Driver\");\nMODULE_LICENSE(\"GPL\");\n\n#define WMI_EVENT_GUID0\t\"E4FB94F9-7F2B-4173-AD1A-CD1D95086248\"\n#define WMI_EVENT_GUID1\t\"023B133E-49D1-4E10-B313-698220140DC2\"\n#define WMI_EVENT_GUID2\t\"37BE1AC0-C3F2-4B1F-BFBE-8FDEAF2814D6\"\n#define WMI_EVENT_GUID3\t\"911BAD44-7DF8-4FBB-9319-BABA1C4B293B\"\n#define WMI_METHOD_WMAB \"C3A72B38-D3EF-42D3-8CBB-D5A57049F66D\"\n#define WMI_METHOD_WMBB \"2B4F501A-BD3C-4394-8DCF-00A7D2BC8210\"\n#define WMI_EVENT_GUID  WMI_EVENT_GUID0\n\n#define WMAB_METHOD     \"\\\\XINI.WMAB\"\n#define WMBB_METHOD     \"\\\\XINI.WMBB\"\n#define SB_GGOV_METHOD  \"\\\\_SB.GGOV\"\n#define GOV_TLED        0x2020008\n#define WM_GET          1\n#define WM_SET          2\n#define WM_KEY_LIGHT    0x400\n#define WM_TLED         0x404\n#define WM_FN_LOCK      0x407\n#define WM_BATT_LIMIT   0x61\n#define WM_READER_MODE  0xBF\n#define WM_FAN_MODE\t0x33\n#define WMBB_USB_CHARGE 0x10B\n#define WMBB_BATT_LIMIT 0x10C\n\n#define PLATFORM_NAME   \"lg-laptop\"\n\nMODULE_ALIAS(\"wmi:\" WMI_EVENT_GUID0);\nMODULE_ALIAS(\"wmi:\" WMI_EVENT_GUID1);\nMODULE_ALIAS(\"wmi:\" WMI_EVENT_GUID2);\nMODULE_ALIAS(\"wmi:\" WMI_EVENT_GUID3);\nMODULE_ALIAS(\"wmi:\" WMI_METHOD_WMAB);\nMODULE_ALIAS(\"wmi:\" WMI_METHOD_WMBB);\n\nstatic struct platform_device *pf_device;\nstatic struct input_dev *wmi_input_dev;\n\nstatic u32 inited;\n#define INIT_INPUT_WMI_0        0x01\n#define INIT_INPUT_WMI_2        0x02\n#define INIT_INPUT_ACPI         0x04\n#define INIT_SPARSE_KEYMAP      0x80\n\nstatic int battery_limit_use_wmbb;\nstatic struct led_classdev kbd_backlight;\nstatic enum led_brightness get_kbd_backlight_level(void);\n\nstatic const struct key_entry wmi_keymap[] = {\n\t{KE_KEY, 0x70, {KEY_F15} },\t  \n\t{KE_KEY, 0x74, {KEY_F21} },\t  \n\t{KE_KEY, 0xf020000, {KEY_F14} },  \n\t{KE_KEY, 0x10000000, {KEY_F16} }, \n\t{KE_KEY, 0x80, {KEY_RFKILL} },\n\t{KE_END, 0}\n};\n\nstatic int ggov(u32 arg0)\n{\n\tunion acpi_object args[1];\n\tunion acpi_object *r;\n\tacpi_status status;\n\tacpi_handle handle;\n\tstruct acpi_object_list arg;\n\tstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };\n\tint res;\n\n\targs[0].type = ACPI_TYPE_INTEGER;\n\targs[0].integer.value = arg0;\n\n\tstatus = acpi_get_handle(NULL, (acpi_string) SB_GGOV_METHOD, &handle);\n\tif (ACPI_FAILURE(status)) {\n\t\tpr_err(\"Cannot get handle\");\n\t\treturn -ENODEV;\n\t}\n\n\targ.count = 1;\n\targ.pointer = args;\n\n\tstatus = acpi_evaluate_object(handle, NULL, &arg, &buffer);\n\tif (ACPI_FAILURE(status)) {\n\t\tacpi_handle_err(handle, \"GGOV: call failed.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tr = buffer.pointer;\n\tif (r->type != ACPI_TYPE_INTEGER) {\n\t\tkfree(r);\n\t\treturn -EINVAL;\n\t}\n\n\tres = r->integer.value;\n\tkfree(r);\n\n\treturn res;\n}\n\nstatic union acpi_object *lg_wmab(u32 method, u32 arg1, u32 arg2)\n{\n\tunion acpi_object args[3];\n\tacpi_status status;\n\tacpi_handle handle;\n\tstruct acpi_object_list arg;\n\tstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };\n\n\targs[0].type = ACPI_TYPE_INTEGER;\n\targs[0].integer.value = method;\n\targs[1].type = ACPI_TYPE_INTEGER;\n\targs[1].integer.value = arg1;\n\targs[2].type = ACPI_TYPE_INTEGER;\n\targs[2].integer.value = arg2;\n\n\tstatus = acpi_get_handle(NULL, (acpi_string) WMAB_METHOD, &handle);\n\tif (ACPI_FAILURE(status)) {\n\t\tpr_err(\"Cannot get handle\");\n\t\treturn NULL;\n\t}\n\n\targ.count = 3;\n\targ.pointer = args;\n\n\tstatus = acpi_evaluate_object(handle, NULL, &arg, &buffer);\n\tif (ACPI_FAILURE(status)) {\n\t\tacpi_handle_err(handle, \"WMAB: call failed.\\n\");\n\t\treturn NULL;\n\t}\n\n\treturn buffer.pointer;\n}\n\nstatic union acpi_object *lg_wmbb(u32 method_id, u32 arg1, u32 arg2)\n{\n\tunion acpi_object args[3];\n\tacpi_status status;\n\tacpi_handle handle;\n\tstruct acpi_object_list arg;\n\tstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };\n\tu8 buf[32];\n\n\t*(u32 *)buf = method_id;\n\t*(u32 *)(buf + 4) = arg1;\n\t*(u32 *)(buf + 16) = arg2;\n\targs[0].type = ACPI_TYPE_INTEGER;\n\targs[0].integer.value = 0;  \n\targs[1].type = ACPI_TYPE_INTEGER;\n\targs[1].integer.value = 1;  \n\targs[2].type = ACPI_TYPE_BUFFER;\n\targs[2].buffer.length = 32;\n\targs[2].buffer.pointer = buf;\n\n\tstatus = acpi_get_handle(NULL, (acpi_string)WMBB_METHOD, &handle);\n\tif (ACPI_FAILURE(status)) {\n\t\tpr_err(\"Cannot get handle\");\n\t\treturn NULL;\n\t}\n\n\targ.count = 3;\n\targ.pointer = args;\n\n\tstatus = acpi_evaluate_object(handle, NULL, &arg, &buffer);\n\tif (ACPI_FAILURE(status)) {\n\t\tacpi_handle_err(handle, \"WMAB: call failed.\\n\");\n\t\treturn NULL;\n\t}\n\n\treturn (union acpi_object *)buffer.pointer;\n}\n\nstatic void wmi_notify(u32 value, void *context)\n{\n\tstruct acpi_buffer response = { ACPI_ALLOCATE_BUFFER, NULL };\n\tunion acpi_object *obj;\n\tacpi_status status;\n\tlong data = (long)context;\n\n\tpr_debug(\"event guid %li\\n\", data);\n\tstatus = wmi_get_event_data(value, &response);\n\tif (ACPI_FAILURE(status)) {\n\t\tpr_err(\"Bad event status 0x%x\\n\", status);\n\t\treturn;\n\t}\n\n\tobj = (union acpi_object *)response.pointer;\n\tif (!obj)\n\t\treturn;\n\n\tif (obj->type == ACPI_TYPE_INTEGER) {\n\t\tint eventcode = obj->integer.value;\n\t\tstruct key_entry *key;\n\n\t\tif (eventcode == 0x10000000) {\n\t\t\tled_classdev_notify_brightness_hw_changed(\n\t\t\t\t&kbd_backlight, get_kbd_backlight_level());\n\t\t} else {\n\t\t\tkey = sparse_keymap_entry_from_scancode(\n\t\t\t\twmi_input_dev, eventcode);\n\t\t\tif (key && key->type == KE_KEY)\n\t\t\t\tsparse_keymap_report_entry(wmi_input_dev,\n\t\t\t\t\t\t\t   key, 1, true);\n\t\t}\n\t}\n\n\tpr_debug(\"Type: %i    Eventcode: 0x%llx\\n\", obj->type,\n\t\t obj->integer.value);\n\tkfree(response.pointer);\n}\n\nstatic void wmi_input_setup(void)\n{\n\tacpi_status status;\n\n\twmi_input_dev = input_allocate_device();\n\tif (wmi_input_dev) {\n\t\twmi_input_dev->name = \"LG WMI hotkeys\";\n\t\twmi_input_dev->phys = \"wmi/input0\";\n\t\twmi_input_dev->id.bustype = BUS_HOST;\n\n\t\tif (sparse_keymap_setup(wmi_input_dev, wmi_keymap, NULL) ||\n\t\t    input_register_device(wmi_input_dev)) {\n\t\t\tpr_info(\"Cannot initialize input device\");\n\t\t\tinput_free_device(wmi_input_dev);\n\t\t\treturn;\n\t\t}\n\n\t\tinited |= INIT_SPARSE_KEYMAP;\n\t\tstatus = wmi_install_notify_handler(WMI_EVENT_GUID0, wmi_notify,\n\t\t\t\t\t\t    (void *)0);\n\t\tif (ACPI_SUCCESS(status))\n\t\t\tinited |= INIT_INPUT_WMI_0;\n\n\t\tstatus = wmi_install_notify_handler(WMI_EVENT_GUID2, wmi_notify,\n\t\t\t\t\t\t    (void *)2);\n\t\tif (ACPI_SUCCESS(status))\n\t\t\tinited |= INIT_INPUT_WMI_2;\n\t} else {\n\t\tpr_info(\"Cannot allocate input device\");\n\t}\n}\n\nstatic void acpi_notify(struct acpi_device *device, u32 event)\n{\n\tstruct key_entry *key;\n\n\tacpi_handle_debug(device->handle, \"notify: %d\\n\", event);\n\tif (inited & INIT_SPARSE_KEYMAP) {\n\t\tkey = sparse_keymap_entry_from_scancode(wmi_input_dev, 0x80);\n\t\tif (key && key->type == KE_KEY)\n\t\t\tsparse_keymap_report_entry(wmi_input_dev, key, 1, true);\n\t}\n}\n\nstatic ssize_t fan_mode_store(struct device *dev,\n\t\t\t      struct device_attribute *attr,\n\t\t\t      const char *buffer, size_t count)\n{\n\tbool value;\n\tunion acpi_object *r;\n\tu32 m;\n\tint ret;\n\n\tret = kstrtobool(buffer, &value);\n\tif (ret)\n\t\treturn ret;\n\n\tr = lg_wmab(WM_FAN_MODE, WM_GET, 0);\n\tif (!r)\n\t\treturn -EIO;\n\n\tif (r->type != ACPI_TYPE_INTEGER) {\n\t\tkfree(r);\n\t\treturn -EIO;\n\t}\n\n\tm = r->integer.value;\n\tkfree(r);\n\tr = lg_wmab(WM_FAN_MODE, WM_SET, (m & 0xffffff0f) | (value << 4));\n\tkfree(r);\n\tr = lg_wmab(WM_FAN_MODE, WM_SET, (m & 0xfffffff0) | value);\n\tkfree(r);\n\n\treturn count;\n}\n\nstatic ssize_t fan_mode_show(struct device *dev,\n\t\t\t     struct device_attribute *attr, char *buffer)\n{\n\tunsigned int status;\n\tunion acpi_object *r;\n\n\tr = lg_wmab(WM_FAN_MODE, WM_GET, 0);\n\tif (!r)\n\t\treturn -EIO;\n\n\tif (r->type != ACPI_TYPE_INTEGER) {\n\t\tkfree(r);\n\t\treturn -EIO;\n\t}\n\n\tstatus = r->integer.value & 0x01;\n\tkfree(r);\n\n\treturn sysfs_emit(buffer, \"%d\\n\", status);\n}\n\nstatic ssize_t usb_charge_store(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tconst char *buffer, size_t count)\n{\n\tbool value;\n\tunion acpi_object *r;\n\tint ret;\n\n\tret = kstrtobool(buffer, &value);\n\tif (ret)\n\t\treturn ret;\n\n\tr = lg_wmbb(WMBB_USB_CHARGE, WM_SET, value);\n\tif (!r)\n\t\treturn -EIO;\n\n\tkfree(r);\n\treturn count;\n}\n\nstatic ssize_t usb_charge_show(struct device *dev,\n\t\t\t       struct device_attribute *attr, char *buffer)\n{\n\tunsigned int status;\n\tunion acpi_object *r;\n\n\tr = lg_wmbb(WMBB_USB_CHARGE, WM_GET, 0);\n\tif (!r)\n\t\treturn -EIO;\n\n\tif (r->type != ACPI_TYPE_BUFFER) {\n\t\tkfree(r);\n\t\treturn -EIO;\n\t}\n\n\tstatus = !!r->buffer.pointer[0x10];\n\n\tkfree(r);\n\n\treturn sysfs_emit(buffer, \"%d\\n\", status);\n}\n\nstatic ssize_t reader_mode_store(struct device *dev,\n\t\t\t\t struct device_attribute *attr,\n\t\t\t\t const char *buffer, size_t count)\n{\n\tbool value;\n\tunion acpi_object *r;\n\tint ret;\n\n\tret = kstrtobool(buffer, &value);\n\tif (ret)\n\t\treturn ret;\n\n\tr = lg_wmab(WM_READER_MODE, WM_SET, value);\n\tif (!r)\n\t\treturn -EIO;\n\n\tkfree(r);\n\treturn count;\n}\n\nstatic ssize_t reader_mode_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buffer)\n{\n\tunsigned int status;\n\tunion acpi_object *r;\n\n\tr = lg_wmab(WM_READER_MODE, WM_GET, 0);\n\tif (!r)\n\t\treturn -EIO;\n\n\tif (r->type != ACPI_TYPE_INTEGER) {\n\t\tkfree(r);\n\t\treturn -EIO;\n\t}\n\n\tstatus = !!r->integer.value;\n\n\tkfree(r);\n\n\treturn sysfs_emit(buffer, \"%d\\n\", status);\n}\n\nstatic ssize_t fn_lock_store(struct device *dev,\n\t\t\t     struct device_attribute *attr,\n\t\t\t     const char *buffer, size_t count)\n{\n\tbool value;\n\tunion acpi_object *r;\n\tint ret;\n\n\tret = kstrtobool(buffer, &value);\n\tif (ret)\n\t\treturn ret;\n\n\tr = lg_wmab(WM_FN_LOCK, WM_SET, value);\n\tif (!r)\n\t\treturn -EIO;\n\n\tkfree(r);\n\treturn count;\n}\n\nstatic ssize_t fn_lock_show(struct device *dev,\n\t\t\t    struct device_attribute *attr, char *buffer)\n{\n\tunsigned int status;\n\tunion acpi_object *r;\n\n\tr = lg_wmab(WM_FN_LOCK, WM_GET, 0);\n\tif (!r)\n\t\treturn -EIO;\n\n\tif (r->type != ACPI_TYPE_BUFFER) {\n\t\tkfree(r);\n\t\treturn -EIO;\n\t}\n\n\tstatus = !!r->buffer.pointer[0];\n\tkfree(r);\n\n\treturn sysfs_emit(buffer, \"%d\\n\", status);\n}\n\nstatic ssize_t charge_control_end_threshold_store(struct device *dev,\n\t\t\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t\t\t  const char *buf, size_t count)\n{\n\tunsigned long value;\n\tint ret;\n\n\tret = kstrtoul(buf, 10, &value);\n\tif (ret)\n\t\treturn ret;\n\n\tif (value == 100 || value == 80) {\n\t\tunion acpi_object *r;\n\n\t\tif (battery_limit_use_wmbb)\n\t\t\tr = lg_wmbb(WMBB_BATT_LIMIT, WM_SET, value);\n\t\telse\n\t\t\tr = lg_wmab(WM_BATT_LIMIT, WM_SET, value);\n\t\tif (!r)\n\t\t\treturn -EIO;\n\n\t\tkfree(r);\n\t\treturn count;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic ssize_t charge_control_end_threshold_show(struct device *device,\n\t\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t\t char *buf)\n{\n\tunsigned int status;\n\tunion acpi_object *r;\n\n\tif (battery_limit_use_wmbb) {\n\t\tr = lg_wmbb(WMBB_BATT_LIMIT, WM_GET, 0);\n\t\tif (!r)\n\t\t\treturn -EIO;\n\n\t\tif (r->type != ACPI_TYPE_BUFFER) {\n\t\t\tkfree(r);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tstatus = r->buffer.pointer[0x10];\n\t} else {\n\t\tr = lg_wmab(WM_BATT_LIMIT, WM_GET, 0);\n\t\tif (!r)\n\t\t\treturn -EIO;\n\n\t\tif (r->type != ACPI_TYPE_INTEGER) {\n\t\t\tkfree(r);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tstatus = r->integer.value;\n\t}\n\tkfree(r);\n\tif (status != 80 && status != 100)\n\t\tstatus = 0;\n\n\treturn sysfs_emit(buf, \"%d\\n\", status);\n}\n\nstatic ssize_t battery_care_limit_show(struct device *dev,\n\t\t\t\t       struct device_attribute *attr,\n\t\t\t\t       char *buffer)\n{\n\treturn charge_control_end_threshold_show(dev, attr, buffer);\n}\n\nstatic ssize_t battery_care_limit_store(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tconst char *buffer, size_t count)\n{\n\treturn charge_control_end_threshold_store(dev, attr, buffer, count);\n}\n\nstatic DEVICE_ATTR_RW(fan_mode);\nstatic DEVICE_ATTR_RW(usb_charge);\nstatic DEVICE_ATTR_RW(reader_mode);\nstatic DEVICE_ATTR_RW(fn_lock);\nstatic DEVICE_ATTR_RW(charge_control_end_threshold);\nstatic DEVICE_ATTR_RW(battery_care_limit);\n\nstatic int lg_battery_add(struct power_supply *battery, struct acpi_battery_hook *hook)\n{\n\tif (device_create_file(&battery->dev,\n\t\t\t       &dev_attr_charge_control_end_threshold))\n\t\treturn -ENODEV;\n\n\treturn 0;\n}\n\nstatic int lg_battery_remove(struct power_supply *battery, struct acpi_battery_hook *hook)\n{\n\tdevice_remove_file(&battery->dev,\n\t\t\t   &dev_attr_charge_control_end_threshold);\n\treturn 0;\n}\n\nstatic struct acpi_battery_hook battery_hook = {\n\t.add_battery = lg_battery_add,\n\t.remove_battery = lg_battery_remove,\n\t.name = \"LG Battery Extension\",\n};\n\nstatic struct attribute *dev_attributes[] = {\n\t&dev_attr_fan_mode.attr,\n\t&dev_attr_usb_charge.attr,\n\t&dev_attr_reader_mode.attr,\n\t&dev_attr_fn_lock.attr,\n\t&dev_attr_battery_care_limit.attr,\n\tNULL\n};\n\nstatic const struct attribute_group dev_attribute_group = {\n\t.attrs = dev_attributes,\n};\n\nstatic void tpad_led_set(struct led_classdev *cdev,\n\t\t\t enum led_brightness brightness)\n{\n\tunion acpi_object *r;\n\n\tr = lg_wmab(WM_TLED, WM_SET, brightness > LED_OFF);\n\tkfree(r);\n}\n\nstatic enum led_brightness tpad_led_get(struct led_classdev *cdev)\n{\n\treturn ggov(GOV_TLED) > 0 ? LED_ON : LED_OFF;\n}\n\nstatic LED_DEVICE(tpad_led, 1, 0);\n\nstatic void kbd_backlight_set(struct led_classdev *cdev,\n\t\t\t      enum led_brightness brightness)\n{\n\tu32 val;\n\tunion acpi_object *r;\n\n\tval = 0x22;\n\tif (brightness <= LED_OFF)\n\t\tval = 0;\n\tif (brightness >= LED_FULL)\n\t\tval = 0x24;\n\tr = lg_wmab(WM_KEY_LIGHT, WM_SET, val);\n\tkfree(r);\n}\n\nstatic enum led_brightness get_kbd_backlight_level(void)\n{\n\tunion acpi_object *r;\n\tint val;\n\n\tr = lg_wmab(WM_KEY_LIGHT, WM_GET, 0);\n\n\tif (!r)\n\t\treturn LED_OFF;\n\n\tif (r->type != ACPI_TYPE_BUFFER || r->buffer.pointer[1] != 0x05) {\n\t\tkfree(r);\n\t\treturn LED_OFF;\n\t}\n\n\tswitch (r->buffer.pointer[0] & 0x27) {\n\tcase 0x24:\n\t\tval = LED_FULL;\n\t\tbreak;\n\tcase 0x22:\n\t\tval = LED_HALF;\n\t\tbreak;\n\tdefault:\n\t\tval = LED_OFF;\n\t}\n\n\tkfree(r);\n\n\treturn val;\n}\n\nstatic enum led_brightness kbd_backlight_get(struct led_classdev *cdev)\n{\n\treturn get_kbd_backlight_level();\n}\n\nstatic LED_DEVICE(kbd_backlight, 255, LED_BRIGHT_HW_CHANGED);\n\nstatic void wmi_input_destroy(void)\n{\n\tif (inited & INIT_INPUT_WMI_2)\n\t\twmi_remove_notify_handler(WMI_EVENT_GUID2);\n\n\tif (inited & INIT_INPUT_WMI_0)\n\t\twmi_remove_notify_handler(WMI_EVENT_GUID0);\n\n\tif (inited & INIT_SPARSE_KEYMAP)\n\t\tinput_unregister_device(wmi_input_dev);\n\n\tinited &= ~(INIT_INPUT_WMI_0 | INIT_INPUT_WMI_2 | INIT_SPARSE_KEYMAP);\n}\n\nstatic struct platform_driver pf_driver = {\n\t.driver = {\n\t\t   .name = PLATFORM_NAME,\n\t}\n};\n\nstatic int acpi_add(struct acpi_device *device)\n{\n\tint ret;\n\tconst char *product;\n\tint year = 2017;\n\n\tif (pf_device)\n\t\treturn 0;\n\n\tret = platform_driver_register(&pf_driver);\n\tif (ret)\n\t\treturn ret;\n\n\tpf_device = platform_device_register_simple(PLATFORM_NAME,\n\t\t\t\t\t\t    PLATFORM_DEVID_NONE,\n\t\t\t\t\t\t    NULL, 0);\n\tif (IS_ERR(pf_device)) {\n\t\tret = PTR_ERR(pf_device);\n\t\tpf_device = NULL;\n\t\tpr_err(\"unable to register platform device\\n\");\n\t\tgoto out_platform_registered;\n\t}\n\tproduct = dmi_get_system_info(DMI_PRODUCT_NAME);\n\tif (product && strlen(product) > 4)\n\t\tswitch (product[4]) {\n\t\tcase '5':\n\t\t\tif (strlen(product) > 5)\n\t\t\t\tswitch (product[5]) {\n\t\t\t\tcase 'N':\n\t\t\t\t\tyear = 2021;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '0':\n\t\t\t\t\tyear = 2016;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tyear = 2022;\n\t\t\t\t}\n\t\t\tbreak;\n\t\tcase '6':\n\t\t\tyear = 2016;\n\t\t\tbreak;\n\t\tcase '7':\n\t\t\tyear = 2017;\n\t\t\tbreak;\n\t\tcase '8':\n\t\t\tyear = 2018;\n\t\t\tbreak;\n\t\tcase '9':\n\t\t\tyear = 2019;\n\t\t\tbreak;\n\t\tcase '0':\n\t\t\tif (strlen(product) > 5)\n\t\t\t\tswitch (product[5]) {\n\t\t\t\tcase 'N':\n\t\t\t\t\tyear = 2020;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'P':\n\t\t\t\t\tyear = 2021;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tyear = 2022;\n\t\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tyear = 2019;\n\t\t}\n\tpr_info(\"product: %s  year: %d\\n\", product, year);\n\n\tif (year >= 2019)\n\t\tbattery_limit_use_wmbb = 1;\n\n\tret = sysfs_create_group(&pf_device->dev.kobj, &dev_attribute_group);\n\tif (ret)\n\t\tgoto out_platform_device;\n\n\t \n\tled_classdev_register(&pf_device->dev, &kbd_backlight);\n\tled_classdev_register(&pf_device->dev, &tpad_led);\n\n\twmi_input_setup();\n\tbattery_hook_register(&battery_hook);\n\n\treturn 0;\n\nout_platform_device:\n\tplatform_device_unregister(pf_device);\nout_platform_registered:\n\tplatform_driver_unregister(&pf_driver);\n\treturn ret;\n}\n\nstatic void acpi_remove(struct acpi_device *device)\n{\n\tsysfs_remove_group(&pf_device->dev.kobj, &dev_attribute_group);\n\n\tled_classdev_unregister(&tpad_led);\n\tled_classdev_unregister(&kbd_backlight);\n\n\tbattery_hook_unregister(&battery_hook);\n\twmi_input_destroy();\n\tplatform_device_unregister(pf_device);\n\tpf_device = NULL;\n\tplatform_driver_unregister(&pf_driver);\n}\n\nstatic const struct acpi_device_id device_ids[] = {\n\t{\"LGEX0815\", 0},\n\t{\"\", 0}\n};\nMODULE_DEVICE_TABLE(acpi, device_ids);\n\nstatic struct acpi_driver acpi_driver = {\n\t.name = \"LG Gram Laptop Support\",\n\t.class = \"lg-laptop\",\n\t.ids = device_ids,\n\t.ops = {\n\t\t.add = acpi_add,\n\t\t.remove = acpi_remove,\n\t\t.notify = acpi_notify,\n\t\t},\n\t.owner = THIS_MODULE,\n};\n\nstatic int __init acpi_init(void)\n{\n\tint result;\n\n\tresult = acpi_bus_register_driver(&acpi_driver);\n\tif (result < 0) {\n\t\tpr_debug(\"Error registering driver\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic void __exit acpi_exit(void)\n{\n\tacpi_bus_unregister_driver(&acpi_driver);\n}\n\nmodule_init(acpi_init);\nmodule_exit(acpi_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}