{
  "module_name": "amilo-rfkill.c",
  "hash_id": "77f46df1a3f9cf887c746b822207a81f3cc07c766c4916006397b5f59957df66",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/x86/amilo-rfkill.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/dmi.h>\n#include <linux/i8042.h>\n#include <linux/io.h>\n#include <linux/moduleparam.h>\n#include <linux/platform_device.h>\n#include <linux/rfkill.h>\n\n \n#define A1655_WIFI_COMMAND\t0x10C5\n#define A1655_WIFI_ON\t\t0x25\n#define A1655_WIFI_OFF\t\t0x45\n\nstatic int amilo_a1655_rfkill_set_block(void *data, bool blocked)\n{\n\tu8 param = blocked ? A1655_WIFI_OFF : A1655_WIFI_ON;\n\tint rc;\n\n\ti8042_lock_chip();\n\trc = i8042_command(&param, A1655_WIFI_COMMAND);\n\ti8042_unlock_chip();\n\treturn rc;\n}\n\nstatic const struct rfkill_ops amilo_a1655_rfkill_ops = {\n\t.set_block = amilo_a1655_rfkill_set_block\n};\n\n \n#define M7440_PORT1\t\t0x118f\n#define M7440_PORT2\t\t0x118e\n#define M7440_RADIO_ON1\t\t0x12\n#define M7440_RADIO_ON2\t\t0x80\n#define M7440_RADIO_OFF1\t0x10\n#define M7440_RADIO_OFF2\t0x00\n\nstatic int amilo_m7440_rfkill_set_block(void *data, bool blocked)\n{\n\tu8 val1 = blocked ? M7440_RADIO_OFF1 : M7440_RADIO_ON1;\n\tu8 val2 = blocked ? M7440_RADIO_OFF2 : M7440_RADIO_ON2;\n\n\toutb(val1, M7440_PORT1);\n\toutb(val2, M7440_PORT2);\n\n\t \n\tif (inb(M7440_PORT1) != val1 || inb(M7440_PORT2) != val2)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic const struct rfkill_ops amilo_m7440_rfkill_ops = {\n\t.set_block = amilo_m7440_rfkill_set_block\n};\n\nstatic const struct dmi_system_id amilo_rfkill_id_table[] = {\n\t{\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"FUJITSU SIEMENS\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"AMILO A1655\"),\n\t\t},\n\t\t.driver_data = (void *)&amilo_a1655_rfkill_ops\n\t},\n\t{\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"FUJITSU SIEMENS\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"AMILO L1310\"),\n\t\t},\n\t\t.driver_data = (void *)&amilo_a1655_rfkill_ops\n\t},\n\t{\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"FUJITSU SIEMENS\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"AMILO M7440\"),\n\t\t},\n\t\t.driver_data = (void *)&amilo_m7440_rfkill_ops\n\t},\n\t{}\n};\n\nstatic struct platform_device *amilo_rfkill_pdev;\nstatic struct rfkill *amilo_rfkill_dev;\n\nstatic int amilo_rfkill_probe(struct platform_device *device)\n{\n\tint rc;\n\tconst struct dmi_system_id *system_id =\n\t\tdmi_first_match(amilo_rfkill_id_table);\n\n\tif (!system_id)\n\t\treturn -ENXIO;\n\n\tamilo_rfkill_dev = rfkill_alloc(KBUILD_MODNAME, &device->dev,\n\t\t\t\t\tRFKILL_TYPE_WLAN,\n\t\t\t\t\tsystem_id->driver_data, NULL);\n\tif (!amilo_rfkill_dev)\n\t\treturn -ENOMEM;\n\n\trc = rfkill_register(amilo_rfkill_dev);\n\tif (rc)\n\t\tgoto fail;\n\n\treturn 0;\n\nfail:\n\trfkill_destroy(amilo_rfkill_dev);\n\treturn rc;\n}\n\nstatic void amilo_rfkill_remove(struct platform_device *device)\n{\n\trfkill_unregister(amilo_rfkill_dev);\n\trfkill_destroy(amilo_rfkill_dev);\n}\n\nstatic struct platform_driver amilo_rfkill_driver = {\n\t.driver = {\n\t\t.name\t= KBUILD_MODNAME,\n\t},\n\t.probe\t= amilo_rfkill_probe,\n\t.remove_new = amilo_rfkill_remove,\n};\n\nstatic int __init amilo_rfkill_init(void)\n{\n\tint rc;\n\n\tif (dmi_first_match(amilo_rfkill_id_table) == NULL)\n\t\treturn -ENODEV;\n\n\trc = platform_driver_register(&amilo_rfkill_driver);\n\tif (rc)\n\t\treturn rc;\n\n\tamilo_rfkill_pdev = platform_device_register_simple(KBUILD_MODNAME,\n\t\t\t\t\t\t\t    PLATFORM_DEVID_NONE,\n\t\t\t\t\t\t\t    NULL, 0);\n\tif (IS_ERR(amilo_rfkill_pdev)) {\n\t\trc = PTR_ERR(amilo_rfkill_pdev);\n\t\tgoto fail;\n\t}\n\n\treturn 0;\n\nfail:\n\tplatform_driver_unregister(&amilo_rfkill_driver);\n\treturn rc;\n}\n\nstatic void __exit amilo_rfkill_exit(void)\n{\n\tplatform_device_unregister(amilo_rfkill_pdev);\n\tplatform_driver_unregister(&amilo_rfkill_driver);\n}\n\nMODULE_AUTHOR(\"Ben Hutchings <ben@decadent.org.uk>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DEVICE_TABLE(dmi, amilo_rfkill_id_table);\n\nmodule_init(amilo_rfkill_init);\nmodule_exit(amilo_rfkill_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}