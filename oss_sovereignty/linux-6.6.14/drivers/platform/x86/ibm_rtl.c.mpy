{
  "module_name": "ibm_rtl.c",
  "hash_id": "2103220331560c08d9bb954e81f73e2dc9f8e357298452262970817be606facd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/x86/ibm_rtl.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/delay.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/dmi.h>\n#include <linux/efi.h>\n#include <linux/mutex.h>\n#include <asm/bios_ebda.h>\n\n#include <linux/io-64-nonatomic-lo-hi.h>\n\nstatic bool force;\nmodule_param(force, bool, 0);\nMODULE_PARM_DESC(force, \"Force driver load, ignore DMI data\");\n\nstatic bool debug;\nmodule_param(debug, bool, 0644);\nMODULE_PARM_DESC(debug, \"Show debug output\");\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Keith Mannthey <kmmanth@us.ibm.com>\");\nMODULE_AUTHOR(\"Vernon Mauery <vernux@us.ibm.com>\");\n\n#define RTL_ADDR_TYPE_IO    1\n#define RTL_ADDR_TYPE_MMIO  2\n\n#define RTL_CMD_ENTER_PRTM  1\n#define RTL_CMD_EXIT_PRTM   2\n\n \nstruct ibm_rtl_table {\n\tchar signature[5];  \n\tu8 version;\n\tu8 rt_status;\n\tu8 command;\n\tu8 command_status;\n\tu8 cmd_address_type;\n\tu8 cmd_granularity;\n\tu8 cmd_offset;\n\tu16 reserve1;\n\tu32 cmd_port_address;  \n\tu32 cmd_port_value;    \n} __attribute__((packed));\n\n \n#define RTL_SIGNATURE 0x0000005f4c54525fULL\n#define RTL_MASK      0x000000ffffffffffULL\n\n#define RTL_DEBUG(fmt, ...)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\\\n\tif (debug)\t\t\t\t\t\\\n\t\tpr_info(fmt, ##__VA_ARGS__);\t\t\\\n} while (0)\n\nstatic DEFINE_MUTEX(rtl_lock);\nstatic struct ibm_rtl_table __iomem *rtl_table;\nstatic void __iomem *ebda_map;\nstatic void __iomem *rtl_cmd_addr;\nstatic u8 rtl_cmd_type;\nstatic u8 rtl_cmd_width;\n\nstatic void __iomem *rtl_port_map(phys_addr_t addr, unsigned long len)\n{\n\tif (rtl_cmd_type == RTL_ADDR_TYPE_MMIO)\n\t\treturn ioremap(addr, len);\n\treturn ioport_map(addr, len);\n}\n\nstatic void rtl_port_unmap(void __iomem *addr)\n{\n\tif (addr && rtl_cmd_type == RTL_ADDR_TYPE_MMIO)\n\t\tiounmap(addr);\n\telse\n\t\tioport_unmap(addr);\n}\n\nstatic int ibm_rtl_write(u8 value)\n{\n\tint ret = 0, count = 0;\n\tu32 cmd_port_val;\n\n\tRTL_DEBUG(\"%s(%d)\\n\", __func__, value);\n\n\tvalue = value == 1 ? RTL_CMD_ENTER_PRTM : RTL_CMD_EXIT_PRTM;\n\n\tmutex_lock(&rtl_lock);\n\n\tif (ioread8(&rtl_table->rt_status) != value) {\n\t\tiowrite8(value, &rtl_table->command);\n\n\t\tswitch (rtl_cmd_width) {\n\t\tcase 8:\n\t\t\tcmd_port_val = ioread8(&rtl_table->cmd_port_value);\n\t\t\tRTL_DEBUG(\"cmd_port_val = %u\\n\", cmd_port_val);\n\t\t\tiowrite8((u8)cmd_port_val, rtl_cmd_addr);\n\t\t\tbreak;\n\t\tcase 16:\n\t\t\tcmd_port_val = ioread16(&rtl_table->cmd_port_value);\n\t\t\tRTL_DEBUG(\"cmd_port_val = %u\\n\", cmd_port_val);\n\t\t\tiowrite16((u16)cmd_port_val, rtl_cmd_addr);\n\t\t\tbreak;\n\t\tcase 32:\n\t\t\tcmd_port_val = ioread32(&rtl_table->cmd_port_value);\n\t\t\tRTL_DEBUG(\"cmd_port_val = %u\\n\", cmd_port_val);\n\t\t\tiowrite32(cmd_port_val, rtl_cmd_addr);\n\t\t\tbreak;\n\t\t}\n\n\t\twhile (ioread8(&rtl_table->command)) {\n\t\t\tmsleep(10);\n\t\t\tif (count++ > 500) {\n\t\t\t\tpr_err(\"Hardware not responding to \"\n\t\t\t\t       \"mode switch request\\n\");\n\t\t\t\tret = -EIO;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t}\n\n\t\tif (ioread8(&rtl_table->command_status)) {\n\t\t\tRTL_DEBUG(\"command_status reports failed command\\n\");\n\t\t\tret = -EIO;\n\t\t}\n\t}\n\n\tmutex_unlock(&rtl_lock);\n\treturn ret;\n}\n\nstatic ssize_t rtl_show_version(struct device *dev,\n                                struct device_attribute *attr,\n                                char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", (int)ioread8(&rtl_table->version));\n}\n\nstatic ssize_t rtl_show_state(struct device *dev,\n                              struct device_attribute *attr,\n                              char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", ioread8(&rtl_table->rt_status));\n}\n\nstatic ssize_t rtl_set_state(struct device *dev,\n                             struct device_attribute *attr,\n                             const char *buf,\n                             size_t count)\n{\n\tssize_t ret;\n\n\tif (count < 1 || count > 2)\n\t\treturn -EINVAL;\n\n\tswitch (buf[0]) {\n\tcase '0':\n\t\tret = ibm_rtl_write(0);\n\t\tbreak;\n\tcase '1':\n\t\tret = ibm_rtl_write(1);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\tif (ret >= 0)\n\t\tret = count;\n\n\treturn ret;\n}\n\nstatic struct bus_type rtl_subsys = {\n\t.name = \"ibm_rtl\",\n\t.dev_name = \"ibm_rtl\",\n};\n\nstatic DEVICE_ATTR(version, S_IRUGO, rtl_show_version, NULL);\nstatic DEVICE_ATTR(state, 0600, rtl_show_state, rtl_set_state);\n\nstatic struct device_attribute *rtl_attributes[] = {\n\t&dev_attr_version,\n\t&dev_attr_state,\n\tNULL\n};\n\n\nstatic int rtl_setup_sysfs(void) {\n\tint ret, i;\n\n\tret = subsys_system_register(&rtl_subsys, NULL);\n\tif (!ret) {\n\t\tstruct device *dev_root = bus_get_dev_root(&rtl_subsys);\n\n\t\tif (dev_root) {\n\t\t\tfor (i = 0; rtl_attributes[i]; i ++)\n\t\t\t\tdevice_create_file(dev_root, rtl_attributes[i]);\n\t\t\tput_device(dev_root);\n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic void rtl_teardown_sysfs(void) {\n\tstruct device *dev_root = bus_get_dev_root(&rtl_subsys);\n\tint i;\n\n\tif (dev_root) {\n\t\tfor (i = 0; rtl_attributes[i]; i ++)\n\t\t\tdevice_remove_file(dev_root, rtl_attributes[i]);\n\t\tput_device(dev_root);\n\t}\n\tbus_unregister(&rtl_subsys);\n}\n\n\nstatic const struct dmi_system_id ibm_rtl_dmi_table[] __initconst = {\n\t{                                                  \\\n\t\t.matches = {                               \\\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"IBM\"),  \\\n\t\t},                                         \\\n\t},\n\t{ }\n};\n\nstatic int __init ibm_rtl_init(void) {\n\tunsigned long ebda_addr, ebda_size;\n\tunsigned int ebda_kb;\n\tint ret = -ENODEV, i;\n\n\tif (force)\n\t\tpr_warn(\"module loaded by force\\n\");\n\t \n\telse if (efi_enabled(EFI_BOOT) || !dmi_check_system(ibm_rtl_dmi_table))\n\t\treturn -ENODEV;\n\n\t \n\tebda_addr = get_bios_ebda();\n\tif (!ebda_addr) {\n\t\tRTL_DEBUG(\"no BIOS EBDA found\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tebda_map = ioremap(ebda_addr, 4);\n\tif (!ebda_map)\n\t\treturn -ENOMEM;\n\n\t \n\tebda_kb = ioread16(ebda_map);\n\tRTL_DEBUG(\"EBDA is %d kB\\n\", ebda_kb);\n\n\tif (ebda_kb == 0)\n\t\tgoto out;\n\n\tiounmap(ebda_map);\n\tebda_size = ebda_kb*1024;\n\n\t \n\tebda_map = ioremap(ebda_addr, ebda_size);\n\tif (!ebda_map)\n\t\treturn -ENOMEM;\n\n\t \n\tfor (i = 0 ; i < ebda_size/sizeof(unsigned int); i++) {\n\t\tstruct ibm_rtl_table __iomem * tmp;\n\t\ttmp = (struct ibm_rtl_table __iomem *) (ebda_map+i);\n\t\tif ((readq(&tmp->signature) & RTL_MASK) == RTL_SIGNATURE) {\n\t\t\tphys_addr_t addr;\n\t\t\tunsigned int plen;\n\t\t\tRTL_DEBUG(\"found RTL_SIGNATURE at %p\\n\", tmp);\n\t\t\trtl_table = tmp;\n\t\t\t \n\t\t\trtl_cmd_width = ioread8(&rtl_table->cmd_granularity);\n\t\t\trtl_cmd_type = ioread8(&rtl_table->cmd_address_type);\n\t\t\tRTL_DEBUG(\"rtl_cmd_width = %u, rtl_cmd_type = %u\\n\",\n\t\t\t\t  rtl_cmd_width, rtl_cmd_type);\n\t\t\taddr = ioread32(&rtl_table->cmd_port_address);\n\t\t\tRTL_DEBUG(\"addr = %#llx\\n\", (unsigned long long)addr);\n\t\t\tplen = rtl_cmd_width/sizeof(char);\n\t\t\trtl_cmd_addr = rtl_port_map(addr, plen);\n\t\t\tRTL_DEBUG(\"rtl_cmd_addr = %p\\n\", rtl_cmd_addr);\n\t\t\tif (!rtl_cmd_addr) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tret = rtl_setup_sysfs();\n\t\t\tbreak;\n\t\t}\n\t}\n\nout:\n\tif (ret) {\n\t\tiounmap(ebda_map);\n\t\trtl_port_unmap(rtl_cmd_addr);\n\t}\n\n\treturn ret;\n}\n\nstatic void __exit ibm_rtl_exit(void)\n{\n\tif (rtl_table) {\n\t\tRTL_DEBUG(\"cleaning up\");\n\t\t \n\t\tibm_rtl_write(0);\n\t\t \n\t\trtl_teardown_sysfs();\n\t\tiounmap(ebda_map);\n\t\trtl_port_unmap(rtl_cmd_addr);\n\t}\n}\n\nmodule_init(ibm_rtl_init);\nmodule_exit(ibm_rtl_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}