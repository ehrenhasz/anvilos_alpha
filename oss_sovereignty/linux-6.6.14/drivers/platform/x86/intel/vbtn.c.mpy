{
  "module_name": "vbtn.c",
  "hash_id": "8854bb2c6047a1fbee17abbb358799d868909ea66fd4d94d38d88fc808e8be66",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/x86/intel/vbtn.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/dmi.h>\n#include <linux/input.h>\n#include <linux/input/sparse-keymap.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/suspend.h>\n#include \"../dual_accel_detect.h\"\n\n \n#define VGBS_TABLET_MODE_FLAG_ALT\t0x10\n \n#define VGBS_TABLET_MODE_FLAG\t\t0x40\n#define VGBS_DOCK_MODE_FLAG\t\t0x80\n\n#define VGBS_TABLET_MODE_FLAGS (VGBS_TABLET_MODE_FLAG | VGBS_TABLET_MODE_FLAG_ALT)\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"AceLan Kao\");\n\nstatic const struct acpi_device_id intel_vbtn_ids[] = {\n\t{\"INT33D6\", 0},\n\t{\"\", 0},\n};\nMODULE_DEVICE_TABLE(acpi, intel_vbtn_ids);\n\n \nstatic const struct key_entry intel_vbtn_keymap[] = {\n\t{ KE_KEY, 0xC0, { KEY_POWER } },\t \n\t{ KE_IGNORE, 0xC1, { KEY_POWER } },\t \n\t{ KE_KEY, 0xC2, { KEY_LEFTMETA } },\t\t \n\t{ KE_KEY, 0xC3, { KEY_LEFTMETA } },\t\t \n\t{ KE_KEY, 0xC4, { KEY_VOLUMEUP } },\t\t \n\t{ KE_IGNORE, 0xC5, { KEY_VOLUMEUP } },\t\t \n\t{ KE_KEY, 0xC6, { KEY_VOLUMEDOWN } },\t\t \n\t{ KE_IGNORE, 0xC7, { KEY_VOLUMEDOWN } },\t \n\t{ KE_KEY,    0xC8, { KEY_ROTATE_LOCK_TOGGLE } },\t \n\t{ KE_KEY,    0xC9, { KEY_ROTATE_LOCK_TOGGLE } },\t \n\t{ KE_END }\n};\n\nstatic const struct key_entry intel_vbtn_switchmap[] = {\n\t \n\t{ KE_IGNORE, 0xCA, { .sw = { SW_DOCK, 1 } } },\t\t \n\t{ KE_IGNORE, 0xCB, { .sw = { SW_DOCK, 0 } } },\t\t \n\t{ KE_SW,     0xCC, { .sw = { SW_TABLET_MODE, 1 } } },\t \n\t{ KE_SW,     0xCD, { .sw = { SW_TABLET_MODE, 0 } } },\t \n\t{ KE_END }\n};\n\nstruct intel_vbtn_priv {\n\tstruct input_dev *buttons_dev;\n\tstruct input_dev *switches_dev;\n\tbool dual_accel;\n\tbool has_buttons;\n\tbool has_switches;\n\tbool wakeup_mode;\n};\n\nstatic void detect_tablet_mode(struct device *dev)\n{\n\tstruct intel_vbtn_priv *priv = dev_get_drvdata(dev);\n\tacpi_handle handle = ACPI_HANDLE(dev);\n\tunsigned long long vgbs;\n\tacpi_status status;\n\tint m;\n\n\tstatus = acpi_evaluate_integer(handle, \"VGBS\", NULL, &vgbs);\n\tif (ACPI_FAILURE(status))\n\t\treturn;\n\n\tm = !(vgbs & VGBS_TABLET_MODE_FLAGS);\n\tinput_report_switch(priv->switches_dev, SW_TABLET_MODE, m);\n\tm = (vgbs & VGBS_DOCK_MODE_FLAG) ? 1 : 0;\n\tinput_report_switch(priv->switches_dev, SW_DOCK, m);\n\n\tinput_sync(priv->switches_dev);\n}\n\n \nstatic int intel_vbtn_input_setup(struct platform_device *device)\n{\n\tstruct intel_vbtn_priv *priv = dev_get_drvdata(&device->dev);\n\tint ret;\n\n\tpriv->buttons_dev = devm_input_allocate_device(&device->dev);\n\tif (!priv->buttons_dev)\n\t\treturn -ENOMEM;\n\n\tret = sparse_keymap_setup(priv->buttons_dev, intel_vbtn_keymap, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tpriv->buttons_dev->dev.parent = &device->dev;\n\tpriv->buttons_dev->name = \"Intel Virtual Buttons\";\n\tpriv->buttons_dev->id.bustype = BUS_HOST;\n\n\tif (priv->has_buttons) {\n\t\tret = input_register_device(priv->buttons_dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tpriv->switches_dev = devm_input_allocate_device(&device->dev);\n\tif (!priv->switches_dev)\n\t\treturn -ENOMEM;\n\n\tret = sparse_keymap_setup(priv->switches_dev, intel_vbtn_switchmap, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tpriv->switches_dev->dev.parent = &device->dev;\n\tpriv->switches_dev->name = \"Intel Virtual Switches\";\n\tpriv->switches_dev->id.bustype = BUS_HOST;\n\n\tif (priv->has_switches) {\n\t\tdetect_tablet_mode(&device->dev);\n\n\t\tret = input_register_device(priv->switches_dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void notify_handler(acpi_handle handle, u32 event, void *context)\n{\n\tstruct platform_device *device = context;\n\tstruct intel_vbtn_priv *priv = dev_get_drvdata(&device->dev);\n\tunsigned int val = !(event & 1);  \n\tconst struct key_entry *ke, *ke_rel;\n\tstruct input_dev *input_dev;\n\tbool autorelease;\n\tint ret;\n\n\tif ((ke = sparse_keymap_entry_from_scancode(priv->buttons_dev, event))) {\n\t\tif (!priv->has_buttons) {\n\t\t\tdev_warn(&device->dev, \"Warning: received a button event on a device without buttons, please report this.\\n\");\n\t\t\treturn;\n\t\t}\n\t\tinput_dev = priv->buttons_dev;\n\t} else if ((ke = sparse_keymap_entry_from_scancode(priv->switches_dev, event))) {\n\t\tif (!priv->has_switches) {\n\t\t\t \n\t\t\tif (priv->dual_accel)\n\t\t\t\treturn;\n\n\t\t\tdev_info(&device->dev, \"Registering Intel Virtual Switches input-dev after receiving a switch event\\n\");\n\t\t\tret = input_register_device(priv->switches_dev);\n\t\t\tif (ret)\n\t\t\t\treturn;\n\n\t\t\tpriv->has_switches = true;\n\t\t}\n\t\tinput_dev = priv->switches_dev;\n\t} else {\n\t\tdev_dbg(&device->dev, \"unknown event index 0x%x\\n\", event);\n\t\treturn;\n\t}\n\n\tif (priv->wakeup_mode) {\n\t\tpm_wakeup_hard_event(&device->dev);\n\n\t\t \n\t\tif (ke->type == KE_KEY)\n\t\t\treturn;\n\t}\n\n\t \n\tke_rel = sparse_keymap_entry_from_scancode(input_dev, event | 1);\n\tautorelease = val && (!ke_rel || ke_rel->type == KE_IGNORE);\n\n\tsparse_keymap_report_event(input_dev, event, val, autorelease);\n\n\t \n\tacpi_evaluate_object(handle, \"VBDL\", NULL, NULL);\n}\n\n \nstatic const struct dmi_system_id dmi_switches_allow_list[] = {\n\t{\n\t\t.matches = {\n\t\t\tDMI_EXACT_MATCH(DMI_CHASSIS_TYPE, \"31\"  ),\n\t\t},\n\t},\n\t{\n\t\t.matches = {\n\t\t\tDMI_EXACT_MATCH(DMI_CHASSIS_TYPE, \"32\"  ),\n\t\t},\n\t},\n\t{\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Inc.\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Venue 11 Pro 7130\"),\n\t\t},\n\t},\n\t{\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Hewlett-Packard\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"HP Pavilion 13 x360 PC\"),\n\t\t},\n\t},\n\t{\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Acer\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Switch SA5-271\"),\n\t\t},\n\t},\n\t{\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Inc.\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Inspiron 7352\"),\n\t\t},\n\t},\n\t{}  \n};\n\nstatic bool intel_vbtn_has_switches(acpi_handle handle, bool dual_accel)\n{\n\tunsigned long long vgbs;\n\tacpi_status status;\n\n\t \n\tif (dual_accel)\n\t\treturn false;\n\n\tif (!dmi_check_system(dmi_switches_allow_list))\n\t\treturn false;\n\n\tstatus = acpi_evaluate_integer(handle, \"VGBS\", NULL, &vgbs);\n\treturn ACPI_SUCCESS(status);\n}\n\nstatic int intel_vbtn_probe(struct platform_device *device)\n{\n\tacpi_handle handle = ACPI_HANDLE(&device->dev);\n\tbool dual_accel, has_buttons, has_switches;\n\tstruct intel_vbtn_priv *priv;\n\tacpi_status status;\n\tint err;\n\n\tdual_accel = dual_accel_detect();\n\thas_buttons = acpi_has_method(handle, \"VBDL\");\n\thas_switches = intel_vbtn_has_switches(handle, dual_accel);\n\n\tif (!has_buttons && !has_switches) {\n\t\tdev_warn(&device->dev, \"failed to read Intel Virtual Button driver\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tpriv = devm_kzalloc(&device->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\tdev_set_drvdata(&device->dev, priv);\n\n\tpriv->dual_accel = dual_accel;\n\tpriv->has_buttons = has_buttons;\n\tpriv->has_switches = has_switches;\n\n\terr = intel_vbtn_input_setup(device);\n\tif (err) {\n\t\tpr_err(\"Failed to setup Intel Virtual Button\\n\");\n\t\treturn err;\n\t}\n\n\tstatus = acpi_install_notify_handler(handle,\n\t\t\t\t\t     ACPI_DEVICE_NOTIFY,\n\t\t\t\t\t     notify_handler,\n\t\t\t\t\t     device);\n\tif (ACPI_FAILURE(status))\n\t\treturn -EBUSY;\n\n\tif (has_buttons) {\n\t\tstatus = acpi_evaluate_object(handle, \"VBDL\", NULL, NULL);\n\t\tif (ACPI_FAILURE(status))\n\t\t\tdev_err(&device->dev, \"Error VBDL failed with ACPI status %d\\n\", status);\n\t}\n\n\tdevice_init_wakeup(&device->dev, true);\n\t \n\tacpi_ec_mark_gpe_for_wake();\n\treturn 0;\n}\n\nstatic void intel_vbtn_remove(struct platform_device *device)\n{\n\tacpi_handle handle = ACPI_HANDLE(&device->dev);\n\n\tdevice_init_wakeup(&device->dev, false);\n\tacpi_remove_notify_handler(handle, ACPI_DEVICE_NOTIFY, notify_handler);\n}\n\nstatic int intel_vbtn_pm_prepare(struct device *dev)\n{\n\tif (device_may_wakeup(dev)) {\n\t\tstruct intel_vbtn_priv *priv = dev_get_drvdata(dev);\n\n\t\tpriv->wakeup_mode = true;\n\t}\n\treturn 0;\n}\n\nstatic void intel_vbtn_pm_complete(struct device *dev)\n{\n\tstruct intel_vbtn_priv *priv = dev_get_drvdata(dev);\n\n\tpriv->wakeup_mode = false;\n}\n\nstatic int intel_vbtn_pm_resume(struct device *dev)\n{\n\tstruct intel_vbtn_priv *priv = dev_get_drvdata(dev);\n\n\tintel_vbtn_pm_complete(dev);\n\n\tif (priv->has_switches)\n\t\tdetect_tablet_mode(dev);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops intel_vbtn_pm_ops = {\n\t.prepare = intel_vbtn_pm_prepare,\n\t.complete = intel_vbtn_pm_complete,\n\t.resume = intel_vbtn_pm_resume,\n\t.restore = intel_vbtn_pm_resume,\n\t.thaw = intel_vbtn_pm_resume,\n};\n\nstatic struct platform_driver intel_vbtn_pl_driver = {\n\t.driver = {\n\t\t.name = \"intel-vbtn\",\n\t\t.acpi_match_table = intel_vbtn_ids,\n\t\t.pm = &intel_vbtn_pm_ops,\n\t},\n\t.probe = intel_vbtn_probe,\n\t.remove_new = intel_vbtn_remove,\n};\n\nstatic acpi_status __init\ncheck_acpi_dev(acpi_handle handle, u32 lvl, void *context, void **rv)\n{\n\tconst struct acpi_device_id *ids = context;\n\tstruct acpi_device *dev = acpi_fetch_acpi_dev(handle);\n\n\tif (dev && acpi_match_device_ids(dev, ids) == 0)\n\t\tif (!IS_ERR_OR_NULL(acpi_create_platform_device(dev, NULL)))\n\t\t\tdev_info(&dev->dev,\n\t\t\t\t \"intel-vbtn: created platform device\\n\");\n\n\treturn AE_OK;\n}\n\nstatic int __init intel_vbtn_init(void)\n{\n\tacpi_walk_namespace(ACPI_TYPE_DEVICE, ACPI_ROOT_OBJECT,\n\t\t\t    ACPI_UINT32_MAX, check_acpi_dev, NULL,\n\t\t\t    (void *)intel_vbtn_ids, NULL);\n\n\treturn platform_driver_register(&intel_vbtn_pl_driver);\n}\nmodule_init(intel_vbtn_init);\n\nstatic void __exit intel_vbtn_exit(void)\n{\n\tplatform_driver_unregister(&intel_vbtn_pl_driver);\n}\nmodule_exit(intel_vbtn_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}