{
  "module_name": "runtest.c",
  "hash_id": "6e59b324d91aa7628352a88f8ba08ac843237c899f5ad59c5d879b8026cbebee",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/x86/intel/ifs/runtest.c",
  "human_readable_source": "\n \n\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/slab.h>\n#include <linux/stop_machine.h>\n\n#include \"ifs.h\"\n\n \n\n#define CREATE_TRACE_POINTS\n#include <trace/events/intel_ifs.h>\n\n \n#define MAX_IFS_RETRIES  5\n\n \n#define IFS_THREAD_WAIT 100000\n\nenum ifs_status_err_code {\n\tIFS_NO_ERROR\t\t\t\t= 0,\n\tIFS_OTHER_THREAD_COULD_NOT_JOIN\t\t= 1,\n\tIFS_INTERRUPTED_BEFORE_RENDEZVOUS\t= 2,\n\tIFS_POWER_MGMT_INADEQUATE_FOR_SCAN\t= 3,\n\tIFS_INVALID_CHUNK_RANGE\t\t\t= 4,\n\tIFS_MISMATCH_ARGUMENTS_BETWEEN_THREADS\t= 5,\n\tIFS_CORE_NOT_CAPABLE_CURRENTLY\t\t= 6,\n\tIFS_UNASSIGNED_ERROR_CODE\t\t= 7,\n\tIFS_EXCEED_NUMBER_OF_THREADS_CONCURRENT\t= 8,\n\tIFS_INTERRUPTED_DURING_EXECUTION\t= 9,\n};\n\nstatic const char * const scan_test_status[] = {\n\t[IFS_NO_ERROR] = \"SCAN no error\",\n\t[IFS_OTHER_THREAD_COULD_NOT_JOIN] = \"Other thread could not join.\",\n\t[IFS_INTERRUPTED_BEFORE_RENDEZVOUS] = \"Interrupt occurred prior to SCAN coordination.\",\n\t[IFS_POWER_MGMT_INADEQUATE_FOR_SCAN] =\n\t\"Core Abort SCAN Response due to power management condition.\",\n\t[IFS_INVALID_CHUNK_RANGE] = \"Non valid chunks in the range\",\n\t[IFS_MISMATCH_ARGUMENTS_BETWEEN_THREADS] = \"Mismatch in arguments between threads T0/T1.\",\n\t[IFS_CORE_NOT_CAPABLE_CURRENTLY] = \"Core not capable of performing SCAN currently\",\n\t[IFS_UNASSIGNED_ERROR_CODE] = \"Unassigned error code 0x7\",\n\t[IFS_EXCEED_NUMBER_OF_THREADS_CONCURRENT] =\n\t\"Exceeded number of Logical Processors (LP) allowed to run Scan-At-Field concurrently\",\n\t[IFS_INTERRUPTED_DURING_EXECUTION] = \"Interrupt occurred prior to SCAN start\",\n};\n\nstatic void message_not_tested(struct device *dev, int cpu, union ifs_status status)\n{\n\tif (status.error_code < ARRAY_SIZE(scan_test_status)) {\n\t\tdev_info(dev, \"CPU(s) %*pbl: SCAN operation did not start. %s\\n\",\n\t\t\t cpumask_pr_args(cpu_smt_mask(cpu)),\n\t\t\t scan_test_status[status.error_code]);\n\t} else if (status.error_code == IFS_SW_TIMEOUT) {\n\t\tdev_info(dev, \"CPU(s) %*pbl: software timeout during scan\\n\",\n\t\t\t cpumask_pr_args(cpu_smt_mask(cpu)));\n\t} else if (status.error_code == IFS_SW_PARTIAL_COMPLETION) {\n\t\tdev_info(dev, \"CPU(s) %*pbl: %s\\n\",\n\t\t\t cpumask_pr_args(cpu_smt_mask(cpu)),\n\t\t\t \"Not all scan chunks were executed. Maximum forward progress retries exceeded\");\n\t} else {\n\t\tdev_info(dev, \"CPU(s) %*pbl: SCAN unknown status %llx\\n\",\n\t\t\t cpumask_pr_args(cpu_smt_mask(cpu)), status.data);\n\t}\n}\n\nstatic void message_fail(struct device *dev, int cpu, union ifs_status status)\n{\n\tstruct ifs_data *ifsd = ifs_get_data(dev);\n\n\t \n\tif (status.control_error) {\n\t\tdev_err(dev, \"CPU(s) %*pbl: could not execute from loaded scan image. Batch: %02x version: 0x%x\\n\",\n\t\t\tcpumask_pr_args(cpu_smt_mask(cpu)), ifsd->cur_batch, ifsd->loaded_version);\n\t}\n\n\t \n\tif (status.signature_error) {\n\t\tdev_err(dev, \"CPU(s) %*pbl: test signature incorrect. Batch: %02x version: 0x%x\\n\",\n\t\t\tcpumask_pr_args(cpu_smt_mask(cpu)), ifsd->cur_batch, ifsd->loaded_version);\n\t}\n}\n\nstatic bool can_restart(union ifs_status status)\n{\n\tenum ifs_status_err_code err_code = status.error_code;\n\n\t \n\tif (status.signature_error || status.control_error)\n\t\treturn false;\n\n\tswitch (err_code) {\n\tcase IFS_NO_ERROR:\n\tcase IFS_OTHER_THREAD_COULD_NOT_JOIN:\n\tcase IFS_INTERRUPTED_BEFORE_RENDEZVOUS:\n\tcase IFS_POWER_MGMT_INADEQUATE_FOR_SCAN:\n\tcase IFS_EXCEED_NUMBER_OF_THREADS_CONCURRENT:\n\tcase IFS_INTERRUPTED_DURING_EXECUTION:\n\t\treturn true;\n\tcase IFS_INVALID_CHUNK_RANGE:\n\tcase IFS_MISMATCH_ARGUMENTS_BETWEEN_THREADS:\n\tcase IFS_CORE_NOT_CAPABLE_CURRENTLY:\n\tcase IFS_UNASSIGNED_ERROR_CODE:\n\t\tbreak;\n\t}\n\treturn false;\n}\n\n \nstatic int doscan(void *data)\n{\n\tint cpu = smp_processor_id();\n\tu64 *msrs = data;\n\tint first;\n\n\t \n\tfirst = cpumask_first(cpu_smt_mask(cpu));\n\n\t \n\twrmsrl(MSR_ACTIVATE_SCAN, msrs[0]);\n\n\tif (cpu == first) {\n\t\t \n\t\trdmsrl(MSR_SCAN_STATUS, msrs[1]);\n\t}\n\n\treturn 0;\n}\n\n \nstatic void ifs_test_core(int cpu, struct device *dev)\n{\n\tunion ifs_scan activate;\n\tunion ifs_status status;\n\tunsigned long timeout;\n\tstruct ifs_data *ifsd;\n\tu64 msrvals[2];\n\tint retries;\n\n\tifsd = ifs_get_data(dev);\n\n\tactivate.rsvd = 0;\n\tactivate.delay = IFS_THREAD_WAIT;\n\tactivate.sigmce = 0;\n\tactivate.start = 0;\n\tactivate.stop = ifsd->valid_chunks - 1;\n\n\ttimeout = jiffies + HZ / 2;\n\tretries = MAX_IFS_RETRIES;\n\n\twhile (activate.start <= activate.stop) {\n\t\tif (time_after(jiffies, timeout)) {\n\t\t\tstatus.error_code = IFS_SW_TIMEOUT;\n\t\t\tbreak;\n\t\t}\n\n\t\tmsrvals[0] = activate.data;\n\t\tstop_core_cpuslocked(cpu, doscan, msrvals);\n\n\t\tstatus.data = msrvals[1];\n\n\t\ttrace_ifs_status(cpu, activate, status);\n\n\t\t \n\t\tif (!can_restart(status))\n\t\t\tbreak;\n\n\t\tif (status.chunk_num == activate.start) {\n\t\t\t \n\t\t\tif (--retries == 0) {\n\t\t\t\tif (status.error_code == IFS_NO_ERROR)\n\t\t\t\t\tstatus.error_code = IFS_SW_PARTIAL_COMPLETION;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tretries = MAX_IFS_RETRIES;\n\t\t\tactivate.start = status.chunk_num;\n\t\t}\n\t}\n\n\t \n\tifsd->scan_details = status.data;\n\n\tif (status.control_error || status.signature_error) {\n\t\tifsd->status = SCAN_TEST_FAIL;\n\t\tmessage_fail(dev, cpu, status);\n\t} else if (status.error_code) {\n\t\tifsd->status = SCAN_NOT_TESTED;\n\t\tmessage_not_tested(dev, cpu, status);\n\t} else {\n\t\tifsd->status = SCAN_TEST_PASS;\n\t}\n}\n\n#define SPINUNIT 100  \nstatic atomic_t array_cpus_out;\n\n \nstatic void wait_for_sibling_cpu(atomic_t *t, long long timeout)\n{\n\tint cpu = smp_processor_id();\n\tconst struct cpumask *smt_mask = cpu_smt_mask(cpu);\n\tint all_cpus = cpumask_weight(smt_mask);\n\n\tatomic_inc(t);\n\twhile (atomic_read(t) < all_cpus) {\n\t\tif (timeout < SPINUNIT)\n\t\t\treturn;\n\t\tndelay(SPINUNIT);\n\t\ttimeout -= SPINUNIT;\n\t\ttouch_nmi_watchdog();\n\t}\n}\n\nstatic int do_array_test(void *data)\n{\n\tunion ifs_array *command = data;\n\tint cpu = smp_processor_id();\n\tint first;\n\n\t \n\tfirst = cpumask_first(cpu_smt_mask(cpu));\n\n\tif (cpu == first) {\n\t\twrmsrl(MSR_ARRAY_BIST, command->data);\n\t\t \n\t\trdmsrl(MSR_ARRAY_BIST, command->data);\n\t}\n\n\t \n\twait_for_sibling_cpu(&array_cpus_out, NSEC_PER_SEC);\n\n\treturn 0;\n}\n\nstatic void ifs_array_test_core(int cpu, struct device *dev)\n{\n\tunion ifs_array command = {};\n\tbool timed_out = false;\n\tstruct ifs_data *ifsd;\n\tunsigned long timeout;\n\n\tifsd = ifs_get_data(dev);\n\n\tcommand.array_bitmask = ~0U;\n\ttimeout = jiffies + HZ / 2;\n\n\tdo {\n\t\tif (time_after(jiffies, timeout)) {\n\t\t\ttimed_out = true;\n\t\t\tbreak;\n\t\t}\n\t\tatomic_set(&array_cpus_out, 0);\n\t\tstop_core_cpuslocked(cpu, do_array_test, &command);\n\n\t\tif (command.ctrl_result)\n\t\t\tbreak;\n\t} while (command.array_bitmask);\n\n\tifsd->scan_details = command.data;\n\n\tif (command.ctrl_result)\n\t\tifsd->status = SCAN_TEST_FAIL;\n\telse if (timed_out || command.array_bitmask)\n\t\tifsd->status = SCAN_NOT_TESTED;\n\telse\n\t\tifsd->status = SCAN_TEST_PASS;\n}\n\n \nint do_core_test(int cpu, struct device *dev)\n{\n\tconst struct ifs_test_caps *test = ifs_get_test_caps(dev);\n\tstruct ifs_data *ifsd = ifs_get_data(dev);\n\tint ret = 0;\n\n\t \n\tcpus_read_lock();\n\n\tif (!cpu_online(cpu)) {\n\t\tdev_info(dev, \"cannot test on the offline cpu %d\\n\", cpu);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tswitch (test->test_num) {\n\tcase IFS_TYPE_SAF:\n\t\tif (!ifsd->loaded)\n\t\t\tret = -EPERM;\n\t\telse\n\t\t\tifs_test_core(cpu, dev);\n\t\tbreak;\n\tcase IFS_TYPE_ARRAY_BIST:\n\t\tifs_array_test_core(cpu, dev);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\nout:\n\tcpus_read_unlock();\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}