{
  "module_name": "load.c",
  "hash_id": "f226aa7d59513e95307334ced7ae02737574c16b5bbf6263e4c08720beb4b576",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/x86/intel/ifs/load.c",
  "human_readable_source": "\n \n\n#include <linux/firmware.h>\n#include <asm/cpu.h>\n#include <asm/microcode.h>\n\n#include \"ifs.h\"\n\n#define IFS_CHUNK_ALIGNMENT\t256\nunion meta_data {\n\tstruct {\n\t\tu32 meta_type;\t\t\n\t\tu32 meta_size;\t\t\n\t\tu32 test_type;\t\t\n\t\tu32 fusa_info;\t\t\n\t\tu32 total_images;\t\n\t\tu32 current_image;\t\n\t\tu32 total_chunks;\t\n\t\tu32 starting_chunk;\t\n\t\tu32 size_per_chunk;\t\n\t\tu32 chunks_per_stride;\t\n\t};\n\tu8 padding[IFS_CHUNK_ALIGNMENT];\n};\n\n#define IFS_HEADER_SIZE\t(sizeof(struct microcode_header_intel))\n#define META_TYPE_IFS\t1\nstatic  struct microcode_header_intel *ifs_header_ptr;\t \nstatic u64 ifs_hash_ptr;\t\t\t \nstatic u64 ifs_test_image_ptr;\t\t\t \nstatic DECLARE_COMPLETION(ifs_done);\n\nstatic const char * const scan_hash_status[] = {\n\t[0] = \"No error reported\",\n\t[1] = \"Attempt to copy scan hashes when copy already in progress\",\n\t[2] = \"Secure Memory not set up correctly\",\n\t[3] = \"FuSaInfo.ProgramID does not match or ff-mm-ss does not match\",\n\t[4] = \"Reserved\",\n\t[5] = \"Integrity check failed\",\n\t[6] = \"Scan reload or test is in progress\"\n};\n\nstatic const char * const scan_authentication_status[] = {\n\t[0] = \"No error reported\",\n\t[1] = \"Attempt to authenticate a chunk which is already marked as authentic\",\n\t[2] = \"Chunk authentication error. The hash of chunk did not match expected value\"\n};\n\n#define MC_HEADER_META_TYPE_END\t\t(0)\n\nstruct metadata_header {\n\tunsigned int\t\ttype;\n\tunsigned int\t\tblk_size;\n};\n\nstatic struct metadata_header *find_meta_data(void *ucode, unsigned int meta_type)\n{\n\tstruct microcode_header_intel *hdr = &((struct microcode_intel *)ucode)->hdr;\n\tstruct metadata_header *meta_header;\n\tunsigned long data_size, total_meta;\n\tunsigned long meta_size = 0;\n\n\tdata_size = intel_microcode_get_datasize(hdr);\n\ttotal_meta = hdr->metasize;\n\tif (!total_meta)\n\t\treturn NULL;\n\n\tmeta_header = (ucode + MC_HEADER_SIZE + data_size) - total_meta;\n\n\twhile (meta_header->type != MC_HEADER_META_TYPE_END &&\n\t       meta_header->blk_size &&\n\t       meta_size < total_meta) {\n\t\tmeta_size += meta_header->blk_size;\n\t\tif (meta_header->type == meta_type)\n\t\t\treturn meta_header;\n\n\t\tmeta_header = (void *)meta_header + meta_header->blk_size;\n\t}\n\treturn NULL;\n}\n\n \nstatic void copy_hashes_authenticate_chunks(struct work_struct *work)\n{\n\tstruct ifs_work *local_work = container_of(work, struct ifs_work, w);\n\tunion ifs_scan_hashes_status hashes_status;\n\tunion ifs_chunks_auth_status chunk_status;\n\tstruct device *dev = local_work->dev;\n\tint i, num_chunks, chunk_size;\n\tstruct ifs_data *ifsd;\n\tu64 linear_addr, base;\n\tu32 err_code;\n\n\tifsd = ifs_get_data(dev);\n\t \n\twrmsrl(MSR_COPY_SCAN_HASHES, ifs_hash_ptr);\n\trdmsrl(MSR_SCAN_HASHES_STATUS, hashes_status.data);\n\n\t \n\tnum_chunks = hashes_status.num_chunks;\n\tchunk_size = hashes_status.chunk_size * 1024;\n\terr_code = hashes_status.error_code;\n\n\tif (!hashes_status.valid) {\n\t\tifsd->loading_error = true;\n\t\tif (err_code >= ARRAY_SIZE(scan_hash_status)) {\n\t\t\tdev_err(dev, \"invalid error code 0x%x for hash copy\\n\", err_code);\n\t\t\tgoto done;\n\t\t}\n\t\tdev_err(dev, \"Hash copy error : %s\", scan_hash_status[err_code]);\n\t\tgoto done;\n\t}\n\n\t \n\tbase = ifs_test_image_ptr;\n\n\t \n\tfor (i = 0; i < num_chunks; i++) {\n\t\tlinear_addr = base + i * chunk_size;\n\t\tlinear_addr |= i;\n\n\t\twrmsrl(MSR_AUTHENTICATE_AND_COPY_CHUNK, linear_addr);\n\t\trdmsrl(MSR_CHUNKS_AUTHENTICATION_STATUS, chunk_status.data);\n\n\t\tifsd->valid_chunks = chunk_status.valid_chunks;\n\t\terr_code = chunk_status.error_code;\n\n\t\tif (err_code) {\n\t\t\tifsd->loading_error = true;\n\t\t\tif (err_code >= ARRAY_SIZE(scan_authentication_status)) {\n\t\t\t\tdev_err(dev,\n\t\t\t\t\t\"invalid error code 0x%x for authentication\\n\", err_code);\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tdev_err(dev, \"Chunk authentication error %s\\n\",\n\t\t\t\tscan_authentication_status[err_code]);\n\t\t\tgoto done;\n\t\t}\n\t}\ndone:\n\tcomplete(&ifs_done);\n}\n\nstatic int validate_ifs_metadata(struct device *dev)\n{\n\tstruct ifs_data *ifsd = ifs_get_data(dev);\n\tunion meta_data *ifs_meta;\n\tchar test_file[64];\n\tint ret = -EINVAL;\n\n\tsnprintf(test_file, sizeof(test_file), \"%02x-%02x-%02x-%02x.scan\",\n\t\t boot_cpu_data.x86, boot_cpu_data.x86_model,\n\t\t boot_cpu_data.x86_stepping, ifsd->cur_batch);\n\n\tifs_meta = (union meta_data *)find_meta_data(ifs_header_ptr, META_TYPE_IFS);\n\tif (!ifs_meta) {\n\t\tdev_err(dev, \"IFS Metadata missing in file %s\\n\", test_file);\n\t\treturn ret;\n\t}\n\n\tifs_test_image_ptr = (u64)ifs_meta + sizeof(union meta_data);\n\n\t \n\tif (!IS_ALIGNED(ifs_test_image_ptr, IFS_CHUNK_ALIGNMENT)) {\n\t\tdev_err(dev, \"Scan pattern is not aligned on %d bytes aligned in %s\\n\",\n\t\t\tIFS_CHUNK_ALIGNMENT, test_file);\n\t\treturn ret;\n\t}\n\n\tif (ifs_meta->current_image != ifsd->cur_batch) {\n\t\tdev_warn(dev, \"Mismatch between filename %s and batch metadata 0x%02x\\n\",\n\t\t\t test_file, ifs_meta->current_image);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int scan_chunks_sanity_check(struct device *dev)\n{\n\tstruct ifs_data *ifsd = ifs_get_data(dev);\n\tstruct ifs_work local_work;\n\tint curr_pkg, cpu, ret;\n\n\tmemset(ifs_pkg_auth, 0, (topology_max_packages() * sizeof(bool)));\n\tret = validate_ifs_metadata(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tifsd->loading_error = false;\n\tifsd->loaded_version = ifs_header_ptr->rev;\n\n\t \n\tcpus_read_lock();\n\tfor_each_online_cpu(cpu) {\n\t\tcurr_pkg = topology_physical_package_id(cpu);\n\t\tif (ifs_pkg_auth[curr_pkg])\n\t\t\tcontinue;\n\t\treinit_completion(&ifs_done);\n\t\tlocal_work.dev = dev;\n\t\tINIT_WORK_ONSTACK(&local_work.w, copy_hashes_authenticate_chunks);\n\t\tschedule_work_on(cpu, &local_work.w);\n\t\twait_for_completion(&ifs_done);\n\t\tif (ifsd->loading_error) {\n\t\t\tret = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tifs_pkg_auth[curr_pkg] = 1;\n\t}\n\tret = 0;\nout:\n\tcpus_read_unlock();\n\n\treturn ret;\n}\n\nstatic int image_sanity_check(struct device *dev, const struct microcode_header_intel *data)\n{\n\tstruct ucode_cpu_info uci;\n\n\t \n\tif (data->hdrver != MC_HEADER_TYPE_IFS) {\n\t\tdev_err(dev, \"Header version %d not supported\\n\", data->hdrver);\n\t\treturn -EINVAL;\n\t}\n\n\tif (intel_microcode_sanity_check((void *)data, true, MC_HEADER_TYPE_IFS)) {\n\t\tdev_err(dev, \"sanity check failed\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tintel_cpu_collect_info(&uci);\n\n\tif (!intel_find_matching_signature((void *)data,\n\t\t\t\t\t   uci.cpu_sig.sig,\n\t\t\t\t\t   uci.cpu_sig.pf)) {\n\t\tdev_err(dev, \"cpu signature, processor flags not matching\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nint ifs_load_firmware(struct device *dev)\n{\n\tconst struct ifs_test_caps *test = ifs_get_test_caps(dev);\n\tstruct ifs_data *ifsd = ifs_get_data(dev);\n\tconst struct firmware *fw;\n\tchar scan_path[64];\n\tint ret = -EINVAL;\n\n\tsnprintf(scan_path, sizeof(scan_path), \"intel/ifs_%d/%02x-%02x-%02x-%02x.scan\",\n\t\t test->test_num, boot_cpu_data.x86, boot_cpu_data.x86_model,\n\t\t boot_cpu_data.x86_stepping, ifsd->cur_batch);\n\n\tret = request_firmware_direct(&fw, scan_path, dev);\n\tif (ret) {\n\t\tdev_err(dev, \"ifs file %s load failed\\n\", scan_path);\n\t\tgoto done;\n\t}\n\n\tret = image_sanity_check(dev, (struct microcode_header_intel *)fw->data);\n\tif (ret)\n\t\tgoto release;\n\n\tifs_header_ptr = (struct microcode_header_intel *)fw->data;\n\tifs_hash_ptr = (u64)(ifs_header_ptr + 1);\n\n\tret = scan_chunks_sanity_check(dev);\n\tif (ret)\n\t\tdev_err(dev, \"Load failure for batch: %02x\\n\", ifsd->cur_batch);\n\nrelease:\n\trelease_firmware(fw);\ndone:\n\tifsd->loaded = (ret == 0);\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}