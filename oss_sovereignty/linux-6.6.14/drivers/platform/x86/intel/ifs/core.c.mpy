{
  "module_name": "core.c",
  "hash_id": "58e2597579949f14c577c8ac089b29a6137dfc631cd7a6d1072168393acd2574",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/x86/intel/ifs/core.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kdev_t.h>\n#include <linux/semaphore.h>\n#include <linux/slab.h>\n\n#include <asm/cpu_device_id.h>\n\n#include \"ifs.h\"\n\n#define X86_MATCH(model)\t\t\t\t\\\n\tX86_MATCH_VENDOR_FAM_MODEL_FEATURE(INTEL, 6,\t\\\n\t\tINTEL_FAM6_##model, X86_FEATURE_CORE_CAPABILITIES, NULL)\n\nstatic const struct x86_cpu_id ifs_cpu_ids[] __initconst = {\n\tX86_MATCH(SAPPHIRERAPIDS_X),\n\tX86_MATCH(EMERALDRAPIDS_X),\n\t{}\n};\nMODULE_DEVICE_TABLE(x86cpu, ifs_cpu_ids);\n\nATTRIBUTE_GROUPS(plat_ifs);\nATTRIBUTE_GROUPS(plat_ifs_array);\n\nbool *ifs_pkg_auth;\n\nstatic const struct ifs_test_caps scan_test = {\n\t.integrity_cap_bit = MSR_INTEGRITY_CAPS_PERIODIC_BIST_BIT,\n\t.test_num = IFS_TYPE_SAF,\n};\n\nstatic const struct ifs_test_caps array_test = {\n\t.integrity_cap_bit = MSR_INTEGRITY_CAPS_ARRAY_BIST_BIT,\n\t.test_num = IFS_TYPE_ARRAY_BIST,\n};\n\nstatic struct ifs_device ifs_devices[] = {\n\t[IFS_TYPE_SAF] = {\n\t\t.test_caps = &scan_test,\n\t\t.misc = {\n\t\t\t.name = \"intel_ifs_0\",\n\t\t\t.minor = MISC_DYNAMIC_MINOR,\n\t\t\t.groups = plat_ifs_groups,\n\t\t},\n\t},\n\t[IFS_TYPE_ARRAY_BIST] = {\n\t\t.test_caps = &array_test,\n\t\t.misc = {\n\t\t\t.name = \"intel_ifs_1\",\n\t\t\t.minor = MISC_DYNAMIC_MINOR,\n\t\t\t.groups = plat_ifs_array_groups,\n\t\t},\n\t},\n};\n\n#define IFS_NUMTESTS ARRAY_SIZE(ifs_devices)\n\nstatic void ifs_cleanup(void)\n{\n\tint i;\n\n\tfor (i = 0; i < IFS_NUMTESTS; i++) {\n\t\tif (ifs_devices[i].misc.this_device)\n\t\t\tmisc_deregister(&ifs_devices[i].misc);\n\t}\n\tkfree(ifs_pkg_auth);\n}\n\nstatic int __init ifs_init(void)\n{\n\tconst struct x86_cpu_id *m;\n\tu64 msrval;\n\tint i, ret;\n\n\tm = x86_match_cpu(ifs_cpu_ids);\n\tif (!m)\n\t\treturn -ENODEV;\n\n\tif (rdmsrl_safe(MSR_IA32_CORE_CAPS, &msrval))\n\t\treturn -ENODEV;\n\n\tif (!(msrval & MSR_IA32_CORE_CAPS_INTEGRITY_CAPS))\n\t\treturn -ENODEV;\n\n\tif (rdmsrl_safe(MSR_INTEGRITY_CAPS, &msrval))\n\t\treturn -ENODEV;\n\n\tifs_pkg_auth = kmalloc_array(topology_max_packages(), sizeof(bool), GFP_KERNEL);\n\tif (!ifs_pkg_auth)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < IFS_NUMTESTS; i++) {\n\t\tif (!(msrval & BIT(ifs_devices[i].test_caps->integrity_cap_bit)))\n\t\t\tcontinue;\n\t\tret = misc_register(&ifs_devices[i].misc);\n\t\tif (ret)\n\t\t\tgoto err_exit;\n\t}\n\treturn 0;\n\nerr_exit:\n\tifs_cleanup();\n\treturn ret;\n}\n\nstatic void __exit ifs_exit(void)\n{\n\tifs_cleanup();\n}\n\nmodule_init(ifs_init);\nmodule_exit(ifs_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Intel In Field Scan (IFS) device\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}