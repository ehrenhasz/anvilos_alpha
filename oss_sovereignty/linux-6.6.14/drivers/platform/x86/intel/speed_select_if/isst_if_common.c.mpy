{
  "module_name": "isst_if_common.c",
  "hash_id": "13a168ece9a4a2735b2421dfcf04eab9f1e3b82888ec74dffc88f2496569cf36",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/x86/intel/speed_select_if/isst_if_common.c",
  "human_readable_source": "\n \n\n#include <linux/cpufeature.h>\n#include <linux/cpuhotplug.h>\n#include <linux/fs.h>\n#include <linux/hashtable.h>\n#include <linux/miscdevice.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <uapi/linux/isst_if.h>\n\n#include <asm/cpu_device_id.h>\n#include <asm/intel-family.h>\n\n#include \"isst_if_common.h\"\n\n#define MSR_THREAD_ID_INFO\t0x53\n#define MSR_PM_LOGICAL_ID\t0x54\n#define MSR_CPU_BUS_NUMBER\t0x128\n\nstatic struct isst_if_cmd_cb punit_callbacks[ISST_IF_DEV_MAX];\n\nstatic int punit_msr_white_list[] = {\n\tMSR_TURBO_RATIO_LIMIT,\n\tMSR_CONFIG_TDP_CONTROL,\n\tMSR_TURBO_RATIO_LIMIT1,\n\tMSR_TURBO_RATIO_LIMIT2,\n\tMSR_PM_LOGICAL_ID,\n};\n\nstruct isst_valid_cmd_ranges {\n\tu16 cmd;\n\tu16 sub_cmd_beg;\n\tu16 sub_cmd_end;\n};\n\nstruct isst_cmd_set_req_type {\n\tu16 cmd;\n\tu16 sub_cmd;\n\tu16 param;\n};\n\nstatic const struct isst_valid_cmd_ranges isst_valid_cmds[] = {\n\t{0xD0, 0x00, 0x03},\n\t{0x7F, 0x00, 0x0C},\n\t{0x7F, 0x10, 0x12},\n\t{0x7F, 0x20, 0x23},\n\t{0x94, 0x03, 0x03},\n\t{0x95, 0x03, 0x03},\n};\n\nstatic const struct isst_cmd_set_req_type isst_cmd_set_reqs[] = {\n\t{0xD0, 0x00, 0x08},\n\t{0xD0, 0x01, 0x08},\n\t{0xD0, 0x02, 0x08},\n\t{0xD0, 0x03, 0x08},\n\t{0x7F, 0x02, 0x00},\n\t{0x7F, 0x08, 0x00},\n\t{0x95, 0x03, 0x03},\n};\n\nstruct isst_cmd {\n\tstruct hlist_node hnode;\n\tu64 data;\n\tu32 cmd;\n\tint cpu;\n\tint mbox_cmd_type;\n\tu32 param;\n};\n\nstatic bool isst_hpm_support;\n\nstatic DECLARE_HASHTABLE(isst_hash, 8);\nstatic DEFINE_MUTEX(isst_hash_lock);\n\nstatic int isst_store_new_cmd(int cmd, u32 cpu, int mbox_cmd_type, u32 param,\n\t\t\t      u32 data)\n{\n\tstruct isst_cmd *sst_cmd;\n\n\tsst_cmd = kmalloc(sizeof(*sst_cmd), GFP_KERNEL);\n\tif (!sst_cmd)\n\t\treturn -ENOMEM;\n\n\tsst_cmd->cpu = cpu;\n\tsst_cmd->cmd = cmd;\n\tsst_cmd->mbox_cmd_type = mbox_cmd_type;\n\tsst_cmd->param = param;\n\tsst_cmd->data = data;\n\n\thash_add(isst_hash, &sst_cmd->hnode, sst_cmd->cmd);\n\n\treturn 0;\n}\n\nstatic void isst_delete_hash(void)\n{\n\tstruct isst_cmd *sst_cmd;\n\tstruct hlist_node *tmp;\n\tint i;\n\n\thash_for_each_safe(isst_hash, i, tmp, sst_cmd, hnode) {\n\t\thash_del(&sst_cmd->hnode);\n\t\tkfree(sst_cmd);\n\t}\n}\n\n \nint isst_store_cmd(int cmd, int sub_cmd, u32 cpu, int mbox_cmd_type,\n\t\t   u32 param, u64 data)\n{\n\tstruct isst_cmd *sst_cmd;\n\tint full_cmd, ret;\n\n\tfull_cmd = (cmd & GENMASK_ULL(15, 0)) << 16;\n\tfull_cmd |= (sub_cmd & GENMASK_ULL(15, 0));\n\tmutex_lock(&isst_hash_lock);\n\thash_for_each_possible(isst_hash, sst_cmd, hnode, full_cmd) {\n\t\tif (sst_cmd->cmd == full_cmd && sst_cmd->cpu == cpu &&\n\t\t    sst_cmd->mbox_cmd_type == mbox_cmd_type) {\n\t\t\tsst_cmd->param = param;\n\t\t\tsst_cmd->data = data;\n\t\t\tmutex_unlock(&isst_hash_lock);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tret = isst_store_new_cmd(full_cmd, cpu, mbox_cmd_type, param, data);\n\tmutex_unlock(&isst_hash_lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(isst_store_cmd);\n\nstatic void isst_mbox_resume_command(struct isst_if_cmd_cb *cb,\n\t\t\t\t     struct isst_cmd *sst_cmd)\n{\n\tstruct isst_if_mbox_cmd mbox_cmd;\n\tint wr_only;\n\n\tmbox_cmd.command = (sst_cmd->cmd & GENMASK_ULL(31, 16)) >> 16;\n\tmbox_cmd.sub_command = sst_cmd->cmd & GENMASK_ULL(15, 0);\n\tmbox_cmd.parameter = sst_cmd->param;\n\tmbox_cmd.req_data = sst_cmd->data;\n\tmbox_cmd.logical_cpu = sst_cmd->cpu;\n\t(cb->cmd_callback)((u8 *)&mbox_cmd, &wr_only, 1);\n}\n\n \nvoid isst_resume_common(void)\n{\n\tstruct isst_cmd *sst_cmd;\n\tint i;\n\n\thash_for_each(isst_hash, i, sst_cmd, hnode) {\n\t\tstruct isst_if_cmd_cb *cb;\n\n\t\tif (sst_cmd->mbox_cmd_type) {\n\t\t\tcb = &punit_callbacks[ISST_IF_DEV_MBOX];\n\t\t\tif (cb->registered)\n\t\t\t\tisst_mbox_resume_command(cb, sst_cmd);\n\t\t} else {\n\t\t\twrmsrl_safe_on_cpu(sst_cmd->cpu, sst_cmd->cmd,\n\t\t\t\t\t   sst_cmd->data);\n\t\t}\n\t}\n}\nEXPORT_SYMBOL_GPL(isst_resume_common);\n\nstatic void isst_restore_msr_local(int cpu)\n{\n\tstruct isst_cmd *sst_cmd;\n\tint i;\n\n\tmutex_lock(&isst_hash_lock);\n\tfor (i = 0; i < ARRAY_SIZE(punit_msr_white_list); ++i) {\n\t\tif (!punit_msr_white_list[i])\n\t\t\tbreak;\n\n\t\thash_for_each_possible(isst_hash, sst_cmd, hnode,\n\t\t\t\t       punit_msr_white_list[i]) {\n\t\t\tif (!sst_cmd->mbox_cmd_type && sst_cmd->cpu == cpu)\n\t\t\t\twrmsrl_safe(sst_cmd->cmd, sst_cmd->data);\n\t\t}\n\t}\n\tmutex_unlock(&isst_hash_lock);\n}\n\n \nbool isst_if_mbox_cmd_invalid(struct isst_if_mbox_cmd *cmd)\n{\n\tint i;\n\n\tif (cmd->logical_cpu >= nr_cpu_ids)\n\t\treturn true;\n\n\tfor (i = 0; i < ARRAY_SIZE(isst_valid_cmds); ++i) {\n\t\tif (cmd->command == isst_valid_cmds[i].cmd &&\n\t\t    (cmd->sub_command >= isst_valid_cmds[i].sub_cmd_beg &&\n\t\t     cmd->sub_command <= isst_valid_cmds[i].sub_cmd_end)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\nEXPORT_SYMBOL_GPL(isst_if_mbox_cmd_invalid);\n\n \nbool isst_if_mbox_cmd_set_req(struct isst_if_mbox_cmd *cmd)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(isst_cmd_set_reqs); ++i) {\n\t\tif (cmd->command == isst_cmd_set_reqs[i].cmd &&\n\t\t    cmd->sub_command == isst_cmd_set_reqs[i].sub_cmd &&\n\t\t    cmd->parameter == isst_cmd_set_reqs[i].param) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\nEXPORT_SYMBOL_GPL(isst_if_mbox_cmd_set_req);\n\nstatic int isst_if_api_version;\n\nstatic int isst_if_get_platform_info(void __user *argp)\n{\n\tstruct isst_if_platform_info info;\n\n\tinfo.api_version = isst_if_api_version;\n\tinfo.driver_version = ISST_IF_DRIVER_VERSION;\n\tinfo.max_cmds_per_ioctl = ISST_IF_CMD_LIMIT;\n\tinfo.mbox_supported = punit_callbacks[ISST_IF_DEV_MBOX].registered;\n\tinfo.mmio_supported = punit_callbacks[ISST_IF_DEV_MMIO].registered;\n\n\tif (copy_to_user(argp, &info, sizeof(info)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\n#define ISST_MAX_BUS_NUMBER\t2\n\nstruct isst_if_cpu_info {\n\t \n\tint bus_info[ISST_MAX_BUS_NUMBER];\n\tstruct pci_dev *pci_dev[ISST_MAX_BUS_NUMBER];\n\tint punit_cpu_id;\n\tint numa_node;\n};\n\nstruct isst_if_pkg_info {\n\tstruct pci_dev *pci_dev[ISST_MAX_BUS_NUMBER];\n};\n\nstatic struct isst_if_cpu_info *isst_cpu_info;\nstatic struct isst_if_pkg_info *isst_pkg_info;\n\nstatic struct pci_dev *_isst_if_get_pci_dev(int cpu, int bus_no, int dev, int fn)\n{\n\tstruct pci_dev *matched_pci_dev = NULL;\n\tstruct pci_dev *pci_dev = NULL;\n\tstruct pci_dev *_pci_dev = NULL;\n\tint no_matches = 0, pkg_id;\n\tint bus_number;\n\n\tif (bus_no < 0 || bus_no >= ISST_MAX_BUS_NUMBER || cpu < 0 ||\n\t    cpu >= nr_cpu_ids || cpu >= num_possible_cpus())\n\t\treturn NULL;\n\n\tpkg_id = topology_physical_package_id(cpu);\n\n\tbus_number = isst_cpu_info[cpu].bus_info[bus_no];\n\tif (bus_number < 0)\n\t\treturn NULL;\n\n\tfor_each_pci_dev(_pci_dev) {\n\t\tint node;\n\n\t\tif (_pci_dev->bus->number != bus_number ||\n\t\t    _pci_dev->devfn != PCI_DEVFN(dev, fn))\n\t\t\tcontinue;\n\n\t\t++no_matches;\n\t\tif (!matched_pci_dev)\n\t\t\tmatched_pci_dev = _pci_dev;\n\n\t\tnode = dev_to_node(&_pci_dev->dev);\n\t\tif (node == NUMA_NO_NODE) {\n\t\t\tpr_info_once(\"Fail to get numa node for CPU:%d bus:%d dev:%d fn:%d\\n\",\n\t\t\t\t     cpu, bus_no, dev, fn);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (node == isst_cpu_info[cpu].numa_node) {\n\t\t\tisst_pkg_info[pkg_id].pci_dev[bus_no] = _pci_dev;\n\n\t\t\tpci_dev = _pci_dev;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (!pci_dev && no_matches == 1)\n\t\tpci_dev = matched_pci_dev;\n\n\t \n\tif (!pci_dev)\n\t\tpci_dev = isst_pkg_info[pkg_id].pci_dev[bus_no];\n\n\treturn pci_dev;\n}\n\n \nstruct pci_dev *isst_if_get_pci_dev(int cpu, int bus_no, int dev, int fn)\n{\n\tstruct pci_dev *pci_dev;\n\n\tif (bus_no < 0 || bus_no >= ISST_MAX_BUS_NUMBER  || cpu < 0 ||\n\t    cpu >= nr_cpu_ids || cpu >= num_possible_cpus())\n\t\treturn NULL;\n\n\tpci_dev = isst_cpu_info[cpu].pci_dev[bus_no];\n\n\tif (pci_dev && pci_dev->devfn == PCI_DEVFN(dev, fn))\n\t\treturn pci_dev;\n\n\treturn _isst_if_get_pci_dev(cpu, bus_no, dev, fn);\n}\nEXPORT_SYMBOL_GPL(isst_if_get_pci_dev);\n\nstatic int isst_if_cpu_online(unsigned int cpu)\n{\n\tu64 data;\n\tint ret;\n\n\tisst_cpu_info[cpu].numa_node = cpu_to_node(cpu);\n\n\tret = rdmsrl_safe(MSR_CPU_BUS_NUMBER, &data);\n\tif (ret) {\n\t\t \n\t\tisst_cpu_info[cpu].bus_info[0] = -1;\n\t\tisst_cpu_info[cpu].bus_info[1] = -1;\n\t} else {\n\t\tisst_cpu_info[cpu].bus_info[0] = data & 0xff;\n\t\tisst_cpu_info[cpu].bus_info[1] = (data >> 8) & 0xff;\n\t\tisst_cpu_info[cpu].pci_dev[0] = _isst_if_get_pci_dev(cpu, 0, 0, 1);\n\t\tisst_cpu_info[cpu].pci_dev[1] = _isst_if_get_pci_dev(cpu, 1, 30, 1);\n\t}\n\n\tif (isst_hpm_support) {\n\n\t\tret = rdmsrl_safe(MSR_PM_LOGICAL_ID, &data);\n\t\tif (!ret)\n\t\t\tgoto set_punit_id;\n\t}\n\n\tret = rdmsrl_safe(MSR_THREAD_ID_INFO, &data);\n\tif (ret) {\n\t\tisst_cpu_info[cpu].punit_cpu_id = -1;\n\t\treturn ret;\n\t}\n\nset_punit_id:\n\tisst_cpu_info[cpu].punit_cpu_id = data;\n\n\tisst_restore_msr_local(cpu);\n\n\treturn 0;\n}\n\nstatic int isst_if_online_id;\n\nstatic int isst_if_cpu_info_init(void)\n{\n\tint ret;\n\n\tisst_cpu_info = kcalloc(num_possible_cpus(),\n\t\t\t\tsizeof(*isst_cpu_info),\n\t\t\t\tGFP_KERNEL);\n\tif (!isst_cpu_info)\n\t\treturn -ENOMEM;\n\n\tisst_pkg_info = kcalloc(topology_max_packages(),\n\t\t\t\tsizeof(*isst_pkg_info),\n\t\t\t\tGFP_KERNEL);\n\tif (!isst_pkg_info) {\n\t\tkfree(isst_cpu_info);\n\t\treturn -ENOMEM;\n\t}\n\n\tret = cpuhp_setup_state(CPUHP_AP_ONLINE_DYN,\n\t\t\t\t\"platform/x86/isst-if:online\",\n\t\t\t\tisst_if_cpu_online, NULL);\n\tif (ret < 0) {\n\t\tkfree(isst_pkg_info);\n\t\tkfree(isst_cpu_info);\n\t\treturn ret;\n\t}\n\n\tisst_if_online_id = ret;\n\n\treturn 0;\n}\n\nstatic void isst_if_cpu_info_exit(void)\n{\n\tcpuhp_remove_state(isst_if_online_id);\n\tkfree(isst_pkg_info);\n\tkfree(isst_cpu_info);\n};\n\nstatic long isst_if_proc_phyid_req(u8 *cmd_ptr, int *write_only, int resume)\n{\n\tstruct isst_if_cpu_map *cpu_map;\n\n\tcpu_map = (struct isst_if_cpu_map *)cmd_ptr;\n\tif (cpu_map->logical_cpu >= nr_cpu_ids ||\n\t    cpu_map->logical_cpu >= num_possible_cpus())\n\t\treturn -EINVAL;\n\n\t*write_only = 0;\n\tcpu_map->physical_cpu = isst_cpu_info[cpu_map->logical_cpu].punit_cpu_id;\n\n\treturn 0;\n}\n\nstatic bool match_punit_msr_white_list(int msr)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(punit_msr_white_list); ++i) {\n\t\tif (punit_msr_white_list[i] == msr)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic long isst_if_msr_cmd_req(u8 *cmd_ptr, int *write_only, int resume)\n{\n\tstruct isst_if_msr_cmd *msr_cmd;\n\tint ret;\n\n\tmsr_cmd = (struct isst_if_msr_cmd *)cmd_ptr;\n\n\tif (!match_punit_msr_white_list(msr_cmd->msr))\n\t\treturn -EINVAL;\n\n\tif (msr_cmd->logical_cpu >= nr_cpu_ids)\n\t\treturn -EINVAL;\n\n\tif (msr_cmd->read_write) {\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\tret = wrmsrl_safe_on_cpu(msr_cmd->logical_cpu,\n\t\t\t\t\t msr_cmd->msr,\n\t\t\t\t\t msr_cmd->data);\n\t\t*write_only = 1;\n\t\tif (!ret && !resume)\n\t\t\tret = isst_store_cmd(0, msr_cmd->msr,\n\t\t\t\t\t     msr_cmd->logical_cpu,\n\t\t\t\t\t     0, 0, msr_cmd->data);\n\t} else {\n\t\tu64 data;\n\n\t\tret = rdmsrl_safe_on_cpu(msr_cmd->logical_cpu,\n\t\t\t\t\t msr_cmd->msr, &data);\n\t\tif (!ret) {\n\t\t\tmsr_cmd->data = data;\n\t\t\t*write_only = 0;\n\t\t}\n\t}\n\n\n\treturn ret;\n}\n\nstatic long isst_if_exec_multi_cmd(void __user *argp, struct isst_if_cmd_cb *cb)\n{\n\tunsigned char __user *ptr;\n\tu32 cmd_count;\n\tu8 *cmd_ptr;\n\tlong ret;\n\tint i;\n\n\t \n\tif (copy_from_user(&cmd_count, argp, sizeof(cmd_count)))\n\t\treturn -EFAULT;\n\n\tif (!cmd_count || cmd_count > ISST_IF_CMD_LIMIT)\n\t\treturn -EINVAL;\n\n\tcmd_ptr = kmalloc(cb->cmd_size, GFP_KERNEL);\n\tif (!cmd_ptr)\n\t\treturn -ENOMEM;\n\n\t \n\tptr = argp + cb->offset;\n\n\tfor (i = 0; i < cmd_count; ++i) {\n\t\tint wr_only;\n\n\t\tif (signal_pending(current)) {\n\t\t\tret = -EINTR;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (copy_from_user(cmd_ptr, ptr, cb->cmd_size)) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = cb->cmd_callback(cmd_ptr, &wr_only, 0);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tif (!wr_only && copy_to_user(ptr, cmd_ptr, cb->cmd_size)) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tptr += cb->cmd_size;\n\t}\n\n\tkfree(cmd_ptr);\n\n\treturn i ? i : ret;\n}\n\nstatic long isst_if_def_ioctl(struct file *file, unsigned int cmd,\n\t\t\t      unsigned long arg)\n{\n\tvoid __user *argp = (void __user *)arg;\n\tstruct isst_if_cmd_cb cmd_cb;\n\tstruct isst_if_cmd_cb *cb;\n\tlong ret = -ENOTTY;\n\tint i;\n\n\tswitch (cmd) {\n\tcase ISST_IF_GET_PLATFORM_INFO:\n\t\tret = isst_if_get_platform_info(argp);\n\t\tbreak;\n\tcase ISST_IF_GET_PHY_ID:\n\t\tcmd_cb.cmd_size = sizeof(struct isst_if_cpu_map);\n\t\tcmd_cb.offset = offsetof(struct isst_if_cpu_maps, cpu_map);\n\t\tcmd_cb.cmd_callback = isst_if_proc_phyid_req;\n\t\tret = isst_if_exec_multi_cmd(argp, &cmd_cb);\n\t\tbreak;\n\tcase ISST_IF_IO_CMD:\n\t\tcb = &punit_callbacks[ISST_IF_DEV_MMIO];\n\t\tif (cb->registered)\n\t\t\tret = isst_if_exec_multi_cmd(argp, cb);\n\t\tbreak;\n\tcase ISST_IF_MBOX_COMMAND:\n\t\tcb = &punit_callbacks[ISST_IF_DEV_MBOX];\n\t\tif (cb->registered)\n\t\t\tret = isst_if_exec_multi_cmd(argp, cb);\n\t\tbreak;\n\tcase ISST_IF_MSR_COMMAND:\n\t\tcmd_cb.cmd_size = sizeof(struct isst_if_msr_cmd);\n\t\tcmd_cb.offset = offsetof(struct isst_if_msr_cmds, msr_cmd);\n\t\tcmd_cb.cmd_callback = isst_if_msr_cmd_req;\n\t\tret = isst_if_exec_multi_cmd(argp, &cmd_cb);\n\t\tbreak;\n\tdefault:\n\t\tfor (i = 0; i < ISST_IF_DEV_MAX; ++i) {\n\t\t\tstruct isst_if_cmd_cb *cb = &punit_callbacks[i];\n\t\t\tint ret;\n\n\t\t\tif (cb->def_ioctl) {\n\t\t\t\tret = cb->def_ioctl(file, cmd, arg);\n\t\t\t\tif (!ret)\n\t\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\n \nstatic DEFINE_MUTEX(punit_misc_dev_open_lock);\n \nstatic DEFINE_MUTEX(punit_misc_dev_reg_lock);\nstatic int misc_usage_count;\nstatic int misc_device_ret;\nstatic int misc_device_open;\n\nstatic int isst_if_open(struct inode *inode, struct file *file)\n{\n\tint i, ret = 0;\n\n\t \n\tmutex_lock(&punit_misc_dev_open_lock);\n\tfor (i = 0; i < ISST_IF_DEV_MAX; ++i) {\n\t\tstruct isst_if_cmd_cb *cb = &punit_callbacks[i];\n\n\t\tif (cb->registered && !try_module_get(cb->owner)) {\n\t\t\tret = -ENODEV;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (ret) {\n\t\tint j;\n\n\t\tfor (j = 0; j < i; ++j) {\n\t\t\tstruct isst_if_cmd_cb *cb;\n\n\t\t\tcb = &punit_callbacks[j];\n\t\t\tif (cb->registered)\n\t\t\t\tmodule_put(cb->owner);\n\t\t}\n\t} else {\n\t\tmisc_device_open++;\n\t}\n\tmutex_unlock(&punit_misc_dev_open_lock);\n\n\treturn ret;\n}\n\nstatic int isst_if_relase(struct inode *inode, struct file *f)\n{\n\tint i;\n\n\tmutex_lock(&punit_misc_dev_open_lock);\n\tmisc_device_open--;\n\tfor (i = 0; i < ISST_IF_DEV_MAX; ++i) {\n\t\tstruct isst_if_cmd_cb *cb = &punit_callbacks[i];\n\n\t\tif (cb->registered)\n\t\t\tmodule_put(cb->owner);\n\t}\n\tmutex_unlock(&punit_misc_dev_open_lock);\n\n\treturn 0;\n}\n\nstatic const struct file_operations isst_if_char_driver_ops = {\n\t.open = isst_if_open,\n\t.unlocked_ioctl = isst_if_def_ioctl,\n\t.release = isst_if_relase,\n};\n\nstatic struct miscdevice isst_if_char_driver = {\n\t.minor\t\t= MISC_DYNAMIC_MINOR,\n\t.name\t\t= \"isst_interface\",\n\t.fops\t\t= &isst_if_char_driver_ops,\n};\n\nstatic const struct x86_cpu_id hpm_cpu_ids[] = {\n\tX86_MATCH_INTEL_FAM6_MODEL(GRANITERAPIDS_X,\tNULL),\n\tX86_MATCH_INTEL_FAM6_MODEL(ATOM_CRESTMONT_X,\tNULL),\n\t{}\n};\n\nstatic int isst_misc_reg(void)\n{\n\tmutex_lock(&punit_misc_dev_reg_lock);\n\tif (misc_device_ret)\n\t\tgoto unlock_exit;\n\n\tif (!misc_usage_count) {\n\t\tconst struct x86_cpu_id *id;\n\n\t\tid = x86_match_cpu(hpm_cpu_ids);\n\t\tif (id)\n\t\t\tisst_hpm_support = true;\n\n\t\tmisc_device_ret = isst_if_cpu_info_init();\n\t\tif (misc_device_ret)\n\t\t\tgoto unlock_exit;\n\n\t\tmisc_device_ret = misc_register(&isst_if_char_driver);\n\t\tif (misc_device_ret) {\n\t\t\tisst_if_cpu_info_exit();\n\t\t\tgoto unlock_exit;\n\t\t}\n\t}\n\tmisc_usage_count++;\n\nunlock_exit:\n\tmutex_unlock(&punit_misc_dev_reg_lock);\n\n\treturn misc_device_ret;\n}\n\nstatic void isst_misc_unreg(void)\n{\n\tmutex_lock(&punit_misc_dev_reg_lock);\n\tif (misc_usage_count)\n\t\tmisc_usage_count--;\n\tif (!misc_usage_count && !misc_device_ret) {\n\t\tmisc_deregister(&isst_if_char_driver);\n\t\tisst_if_cpu_info_exit();\n\t}\n\tmutex_unlock(&punit_misc_dev_reg_lock);\n}\n\n \nint isst_if_cdev_register(int device_type, struct isst_if_cmd_cb *cb)\n{\n\tint ret;\n\n\tif (device_type >= ISST_IF_DEV_MAX)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&punit_misc_dev_open_lock);\n\t \n\tif (misc_device_open) {\n\t\tmutex_unlock(&punit_misc_dev_open_lock);\n\t\treturn -EAGAIN;\n\t}\n\tif (!cb->api_version)\n\t\tcb->api_version = ISST_IF_API_VERSION;\n\tif (cb->api_version > isst_if_api_version)\n\t\tisst_if_api_version = cb->api_version;\n\tmemcpy(&punit_callbacks[device_type], cb, sizeof(*cb));\n\tpunit_callbacks[device_type].registered = 1;\n\tmutex_unlock(&punit_misc_dev_open_lock);\n\n\tret = isst_misc_reg();\n\tif (ret) {\n\t\t \n\t\tpunit_callbacks[device_type].registered = 0;\n\t\treturn ret;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(isst_if_cdev_register);\n\n \nvoid isst_if_cdev_unregister(int device_type)\n{\n\tisst_misc_unreg();\n\tmutex_lock(&punit_misc_dev_open_lock);\n\tpunit_callbacks[device_type].def_ioctl = NULL;\n\tpunit_callbacks[device_type].registered = 0;\n\tif (device_type == ISST_IF_DEV_MBOX)\n\t\tisst_delete_hash();\n\tmutex_unlock(&punit_misc_dev_open_lock);\n}\nEXPORT_SYMBOL_GPL(isst_if_cdev_unregister);\n\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}