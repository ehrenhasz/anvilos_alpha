{
  "module_name": "isst_if_mmio.c",
  "hash_id": "7d92e67bd3efd00a999c482521e85a0e309ca178fffdd3de6742252a61b7ce0c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/x86/intel/speed_select_if/isst_if_mmio.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/sched/signal.h>\n#include <linux/uaccess.h>\n#include <uapi/linux/isst_if.h>\n\n#include \"isst_if_common.h\"\n\nstruct isst_mmio_range {\n\tint beg;\n\tint end;\n};\n\nstatic struct isst_mmio_range mmio_range_devid_0[] = {\n\t{0x04, 0x14},\n\t{0x20, 0xD0},\n};\n\nstatic struct isst_mmio_range mmio_range_devid_1[] = {\n\t{0x04, 0x14},\n\t{0x20, 0x11C},\n};\n\nstruct isst_if_device {\n\tvoid __iomem *punit_mmio;\n\tu32 range_0[5];\n\tu32 range_1[64];\n\tstruct isst_mmio_range *mmio_range;\n\tstruct mutex mutex;\n};\n\nstatic long isst_if_mmio_rd_wr(u8 *cmd_ptr, int *write_only, int resume)\n{\n\tstruct isst_if_device *punit_dev;\n\tstruct isst_if_io_reg *io_reg;\n\tstruct pci_dev *pdev;\n\n\tio_reg = (struct isst_if_io_reg *)cmd_ptr;\n\n\tif (io_reg->reg % 4)\n\t\treturn -EINVAL;\n\n\tif (io_reg->read_write && !capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tpdev = isst_if_get_pci_dev(io_reg->logical_cpu, 0, 0, 1);\n\tif (!pdev)\n\t\treturn -EINVAL;\n\n\tpunit_dev = pci_get_drvdata(pdev);\n\tif (!punit_dev)\n\t\treturn -EINVAL;\n\n\tif (io_reg->reg < punit_dev->mmio_range[0].beg ||\n\t    io_reg->reg > punit_dev->mmio_range[1].end)\n\t\treturn -EINVAL;\n\n\t \n\tmutex_lock(&punit_dev->mutex);\n\tif (io_reg->read_write) {\n\t\twritel(io_reg->value, punit_dev->punit_mmio+io_reg->reg);\n\t\t*write_only = 1;\n\t} else {\n\t\tio_reg->value = readl(punit_dev->punit_mmio+io_reg->reg);\n\t\t*write_only = 0;\n\t}\n\tmutex_unlock(&punit_dev->mutex);\n\n\treturn 0;\n}\n\nstatic const struct pci_device_id isst_if_ids[] = {\n\t{ PCI_DEVICE_DATA(INTEL, RAPL_PRIO_DEVID_0, &mmio_range_devid_0)},\n\t{ PCI_DEVICE_DATA(INTEL, RAPL_PRIO_DEVID_1, &mmio_range_devid_1)},\n\t{ 0 },\n};\nMODULE_DEVICE_TABLE(pci, isst_if_ids);\n\nstatic int isst_if_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tstruct isst_if_device *punit_dev;\n\tstruct isst_if_cmd_cb cb;\n\tu32 mmio_base, pcu_base;\n\tu64 base_addr;\n\tint ret;\n\n\tpunit_dev = devm_kzalloc(&pdev->dev, sizeof(*punit_dev), GFP_KERNEL);\n\tif (!punit_dev)\n\t\treturn -ENOMEM;\n\n\tret = pcim_enable_device(pdev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = pci_read_config_dword(pdev, 0xD0, &mmio_base);\n\tif (ret)\n\t\treturn ret;\n\n\tret = pci_read_config_dword(pdev, 0xFC, &pcu_base);\n\tif (ret)\n\t\treturn ret;\n\n\tpcu_base &= GENMASK(10, 0);\n\tbase_addr = (u64)mmio_base << 23 | (u64) pcu_base << 12;\n\tpunit_dev->punit_mmio = devm_ioremap(&pdev->dev, base_addr, 256);\n\tif (!punit_dev->punit_mmio)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&punit_dev->mutex);\n\tpci_set_drvdata(pdev, punit_dev);\n\tpunit_dev->mmio_range = (struct isst_mmio_range *) ent->driver_data;\n\n\tmemset(&cb, 0, sizeof(cb));\n\tcb.cmd_size = sizeof(struct isst_if_io_reg);\n\tcb.offset = offsetof(struct isst_if_io_regs, io_reg);\n\tcb.cmd_callback = isst_if_mmio_rd_wr;\n\tcb.owner = THIS_MODULE;\n\tret = isst_if_cdev_register(ISST_IF_DEV_MMIO, &cb);\n\tif (ret)\n\t\tmutex_destroy(&punit_dev->mutex);\n\n\treturn ret;\n}\n\nstatic void isst_if_remove(struct pci_dev *pdev)\n{\n\tstruct isst_if_device *punit_dev;\n\n\tpunit_dev = pci_get_drvdata(pdev);\n\tisst_if_cdev_unregister(ISST_IF_DEV_MMIO);\n\tmutex_destroy(&punit_dev->mutex);\n}\n\nstatic int __maybe_unused isst_if_suspend(struct device *device)\n{\n\tstruct isst_if_device *punit_dev = dev_get_drvdata(device);\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(punit_dev->range_0); ++i)\n\t\tpunit_dev->range_0[i] = readl(punit_dev->punit_mmio +\n\t\t\t\t\t\tpunit_dev->mmio_range[0].beg + 4 * i);\n\tfor (i = 0; i < ARRAY_SIZE(punit_dev->range_1); ++i) {\n\t\tu32 addr;\n\n\t\taddr = punit_dev->mmio_range[1].beg + 4 * i;\n\t\tif (addr > punit_dev->mmio_range[1].end)\n\t\t\tbreak;\n\t\tpunit_dev->range_1[i] = readl(punit_dev->punit_mmio + addr);\n\t}\n\n\treturn 0;\n}\n\nstatic int __maybe_unused isst_if_resume(struct device *device)\n{\n\tstruct isst_if_device *punit_dev = dev_get_drvdata(device);\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(punit_dev->range_0); ++i)\n\t\twritel(punit_dev->range_0[i], punit_dev->punit_mmio +\n\t\t\t\t\t\tpunit_dev->mmio_range[0].beg + 4 * i);\n\tfor (i = 0; i < ARRAY_SIZE(punit_dev->range_1); ++i) {\n\t\tu32 addr;\n\n\t\taddr = punit_dev->mmio_range[1].beg + 4 * i;\n\t\tif (addr > punit_dev->mmio_range[1].end)\n\t\t\tbreak;\n\n\t\twritel(punit_dev->range_1[i], punit_dev->punit_mmio + addr);\n\t}\n\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(isst_if_pm_ops, isst_if_suspend, isst_if_resume);\n\nstatic struct pci_driver isst_if_pci_driver = {\n\t.name\t\t\t= \"isst_if_pci\",\n\t.id_table\t\t= isst_if_ids,\n\t.probe\t\t\t= isst_if_probe,\n\t.remove\t\t\t= isst_if_remove,\n\t.driver.pm\t\t= &isst_if_pm_ops,\n};\n\nmodule_pci_driver(isst_if_pci_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"Intel speed select interface mmio driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}