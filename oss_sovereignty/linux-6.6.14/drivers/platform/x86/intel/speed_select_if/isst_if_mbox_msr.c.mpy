{
  "module_name": "isst_if_mbox_msr.c",
  "hash_id": "75587a8d2f8afc89aa9f57599d34a311b54b5a73dd8e29f4bec0b6c7b373085b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/x86/intel/speed_select_if/isst_if_mbox_msr.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/cpuhotplug.h>\n#include <linux/pci.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/topology.h>\n#include <linux/uaccess.h>\n#include <uapi/linux/isst_if.h>\n#include <asm/cpu_device_id.h>\n#include <asm/intel-family.h>\n\n#include \"isst_if_common.h\"\n\n#define MSR_OS_MAILBOX_INTERFACE\t0xB0\n#define MSR_OS_MAILBOX_DATA\t\t0xB1\n#define MSR_OS_MAILBOX_BUSY_BIT\t\t31\n\n \n#define OS_MAILBOX_RETRY_COUNT\t\t3\n\nstatic int isst_if_send_mbox_cmd(u8 command, u8 sub_command, u32 parameter,\n\t\t\t\t u32 command_data, u32 *response_data)\n{\n\tu32 retries;\n\tu64 data;\n\tint ret;\n\n\t \n\tretries = OS_MAILBOX_RETRY_COUNT;\n\tdo {\n\t\trdmsrl(MSR_OS_MAILBOX_INTERFACE, data);\n\t\tif (data & BIT_ULL(MSR_OS_MAILBOX_BUSY_BIT)) {\n\t\t\tret = -EBUSY;\n\t\t\tcontinue;\n\t\t}\n\t\tret = 0;\n\t\tbreak;\n\t} while (--retries);\n\n\tif (ret)\n\t\treturn ret;\n\n\t \n\twrmsrl(MSR_OS_MAILBOX_DATA, command_data);\n\n\t \n\tdata = BIT_ULL(MSR_OS_MAILBOX_BUSY_BIT) |\n\t\t      (parameter & GENMASK_ULL(13, 0)) << 16 |\n\t\t      (sub_command << 8) |\n\t\t      command;\n\twrmsrl(MSR_OS_MAILBOX_INTERFACE, data);\n\n\t \n\tretries = OS_MAILBOX_RETRY_COUNT;\n\tdo {\n\t\trdmsrl(MSR_OS_MAILBOX_INTERFACE, data);\n\t\tif (data & BIT_ULL(MSR_OS_MAILBOX_BUSY_BIT)) {\n\t\t\tret = -EBUSY;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (data & 0xff)\n\t\t\treturn -ENXIO;\n\n\t\tif (response_data) {\n\t\t\trdmsrl(MSR_OS_MAILBOX_DATA, data);\n\t\t\t*response_data = data;\n\t\t}\n\t\tret = 0;\n\t\tbreak;\n\t} while (--retries);\n\n\treturn ret;\n}\n\nstruct msrl_action {\n\tint err;\n\tstruct isst_if_mbox_cmd *mbox_cmd;\n};\n\n \nstatic void msrl_update_func(void *info)\n{\n\tstruct msrl_action *act = info;\n\n\tact->err = isst_if_send_mbox_cmd(act->mbox_cmd->command,\n\t\t\t\t\t act->mbox_cmd->sub_command,\n\t\t\t\t\t act->mbox_cmd->parameter,\n\t\t\t\t\t act->mbox_cmd->req_data,\n\t\t\t\t\t &act->mbox_cmd->resp_data);\n}\n\nstatic long isst_if_mbox_proc_cmd(u8 *cmd_ptr, int *write_only, int resume)\n{\n\tstruct msrl_action action;\n\tint ret;\n\n\taction.mbox_cmd = (struct isst_if_mbox_cmd *)cmd_ptr;\n\n\tif (isst_if_mbox_cmd_invalid(action.mbox_cmd))\n\t\treturn -EINVAL;\n\n\tif (isst_if_mbox_cmd_set_req(action.mbox_cmd) &&\n\t    !capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\t \n\tret = smp_call_function_single(action.mbox_cmd->logical_cpu,\n\t\t\t\t       msrl_update_func, &action, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!action.err && !resume && isst_if_mbox_cmd_set_req(action.mbox_cmd))\n\t\taction.err = isst_store_cmd(action.mbox_cmd->command,\n\t\t\t\t\t    action.mbox_cmd->sub_command,\n\t\t\t\t\t    action.mbox_cmd->logical_cpu, 1,\n\t\t\t\t\t    action.mbox_cmd->parameter,\n\t\t\t\t\t    action.mbox_cmd->req_data);\n\t*write_only = 0;\n\n\treturn action.err;\n}\n\n\nstatic int isst_pm_notify(struct notifier_block *nb,\n\t\t\t       unsigned long mode, void *_unused)\n{\n\tswitch (mode) {\n\tcase PM_POST_HIBERNATION:\n\tcase PM_POST_RESTORE:\n\tcase PM_POST_SUSPEND:\n\t\tisst_resume_common();\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic struct notifier_block isst_pm_nb = {\n\t.notifier_call = isst_pm_notify,\n};\n\nstatic const struct x86_cpu_id isst_if_cpu_ids[] = {\n\tX86_MATCH_INTEL_FAM6_MODEL(SKYLAKE_X, NULL),\n\t{}\n};\nMODULE_DEVICE_TABLE(x86cpu, isst_if_cpu_ids);\n\nstatic int __init isst_if_mbox_init(void)\n{\n\tstruct isst_if_cmd_cb cb;\n\tconst struct x86_cpu_id *id;\n\tu64 data;\n\tint ret;\n\n\tid = x86_match_cpu(isst_if_cpu_ids);\n\tif (!id)\n\t\treturn -ENODEV;\n\n\t \n\tret = rdmsrl_safe(MSR_OS_MAILBOX_INTERFACE, &data);\n\tif (ret)\n\t\treturn ret;\n\n\tret = rdmsrl_safe(MSR_OS_MAILBOX_DATA, &data);\n\tif (ret)\n\t\treturn ret;\n\n\tmemset(&cb, 0, sizeof(cb));\n\tcb.cmd_size = sizeof(struct isst_if_mbox_cmd);\n\tcb.offset = offsetof(struct isst_if_mbox_cmds, mbox_cmd);\n\tcb.cmd_callback = isst_if_mbox_proc_cmd;\n\tcb.owner = THIS_MODULE;\n\tret = isst_if_cdev_register(ISST_IF_DEV_MBOX, &cb);\n\tif (ret)\n\t\treturn ret;\n\n\tret = register_pm_notifier(&isst_pm_nb);\n\tif (ret)\n\t\tisst_if_cdev_unregister(ISST_IF_DEV_MBOX);\n\n\treturn ret;\n}\nmodule_init(isst_if_mbox_init)\n\nstatic void __exit isst_if_mbox_exit(void)\n{\n\tunregister_pm_notifier(&isst_pm_nb);\n\tisst_if_cdev_unregister(ISST_IF_DEV_MBOX);\n}\nmodule_exit(isst_if_mbox_exit)\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"Intel speed select interface mailbox driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}