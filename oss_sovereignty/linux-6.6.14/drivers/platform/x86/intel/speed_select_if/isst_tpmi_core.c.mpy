{
  "module_name": "isst_tpmi_core.c",
  "hash_id": "7c73909b7fd4b225d3074ec0c71136511f85076990697f0c7965bfad062dfad3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/x86/intel/speed_select_if/isst_tpmi_core.c",
  "human_readable_source": "\n \n\n#include <linux/auxiliary_bus.h>\n#include <linux/delay.h>\n#include <linux/intel_tpmi.h>\n#include <linux/fs.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <uapi/linux/isst_if.h>\n\n#include \"isst_tpmi_core.h\"\n#include \"isst_if_common.h\"\n\n \n#define ISST_HEADER_VERSION\t\t1\n\n \n#define SST_MUL_FACTOR_NONE    1\n\n \n#define SST_MUL_FACTOR_FREQ    100\n\n \n#define SST_REG_SIZE   8\n\n \nstruct sst_header {\n\tu8 interface_version;\n\tu8 cap_mask;\n\tu8 cp_offset;\n\tu8 pp_offset;\n\tu32 reserved;\n} __packed;\n\n \nstruct cp_header {\n\tu64 feature_id :4;\n\tu64 feature_rev :8;\n\tu64 ratio_unit :2;\n\tu64 reserved :50;\n} __packed;\n\n \nstruct pp_header {\n\tu64 feature_id :4;\n\tu64 feature_rev :8;\n\tu64 level_en_mask :8;\n\tu64 allowed_level_mask :8;\n\tu64 reserved0 :4;\n\tu64 ratio_unit :2;\n\tu64 block_size :8;\n\tu64 dynamic_switch :1;\n\tu64 memory_ratio_unit :2;\n\tu64 reserved1 :19;\n} __packed;\n\n \nstruct feature_offset {\n\tu64 pp_offset :8;\n\tu64 bf_offset :8;\n\tu64 tf_offset :8;\n\tu64 reserved :40;\n} __packed;\n\n \nstruct levels_offset {\n\tu64 sst_pp_level0_offset :8;\n\tu64 sst_pp_level1_offset :8;\n\tu64 sst_pp_level2_offset :8;\n\tu64 sst_pp_level3_offset :8;\n\tu64 sst_pp_level4_offset :8;\n\tu64 reserved :24;\n} __packed;\n\n \nstruct pp_control_offset {\n\tu64 perf_level :3;\n\tu64 perf_level_lock :1;\n\tu64 resvd0 :4;\n\tu64 current_state :8;\n\tu64 reserved :48;\n} __packed;\n\n \nstruct pp_status_offset {\n\tu64 sst_pp_level :3;\n\tu64 sst_pp_lock :1;\n\tu64 error_type :4;\n\tu64 feature_state :8;\n\tu64 reserved0 :16;\n\tu64 feature_error_type : 24;\n\tu64 reserved1 :8;\n} __packed;\n\n \nstruct perf_level {\n\tint mmio_offset;\n\tint level;\n};\n\n \nstruct tpmi_per_power_domain_info {\n\tint package_id;\n\tint power_domain_id;\n\tint max_level;\n\tint ratio_unit;\n\tint avx_levels;\n\tint pp_block_size;\n\tstruct sst_header sst_header;\n\tstruct cp_header cp_header;\n\tstruct pp_header pp_header;\n\tstruct perf_level *perf_levels;\n\tstruct feature_offset feature_offsets;\n\tstruct pp_control_offset control_offset;\n\tstruct pp_status_offset status_offset;\n\tvoid __iomem *sst_base;\n\tstruct auxiliary_device *auxdev;\n\tu64 saved_sst_cp_control;\n\tu64 saved_clos_configs[4];\n\tu64 saved_clos_assocs[4];\n\tu64 saved_pp_control;\n};\n\n \nstruct tpmi_sst_struct {\n\tint package_id;\n\tint number_of_power_domains;\n\tstruct tpmi_per_power_domain_info *power_domain_info;\n};\n\n \nstruct tpmi_sst_common_struct {\n\tint max_index;\n\tstruct tpmi_sst_struct **sst_inst;\n};\n\n \nstatic DEFINE_MUTEX(isst_tpmi_dev_lock);\n\n \nstatic int isst_core_usage_count;\n\n \nstatic struct tpmi_sst_common_struct isst_common;\n\n#define SST_MAX_AVX_LEVELS\t3\n\n#define SST_PP_OFFSET_0\t\t8\n#define SST_PP_OFFSET_1\t\t16\n#define SST_PP_OFFSET_SIZE\t8\n\nstatic int sst_add_perf_profiles(struct auxiliary_device *auxdev,\n\t\t\t\t struct tpmi_per_power_domain_info *pd_info,\n\t\t\t\t int levels)\n{\n\tu64 perf_level_offsets;\n\tint i;\n\n\tpd_info->perf_levels = devm_kcalloc(&auxdev->dev, levels,\n\t\t\t\t\t    sizeof(struct perf_level),\n\t\t\t\t\t    GFP_KERNEL);\n\tif (!pd_info->perf_levels)\n\t\treturn 0;\n\n\tpd_info->ratio_unit = pd_info->pp_header.ratio_unit;\n\tpd_info->avx_levels = SST_MAX_AVX_LEVELS;\n\tpd_info->pp_block_size = pd_info->pp_header.block_size;\n\n\t \n\t*((u64 *)&pd_info->feature_offsets) = readq(pd_info->sst_base +\n\t\t\t\t\t\t    pd_info->sst_header.pp_offset +\n\t\t\t\t\t\t    SST_PP_OFFSET_0);\n\n\tperf_level_offsets = readq(pd_info->sst_base + pd_info->sst_header.pp_offset +\n\t\t\t\t   SST_PP_OFFSET_1);\n\n\tfor (i = 0; i < levels; ++i) {\n\t\tu64 offset;\n\n\t\toffset = perf_level_offsets & (0xffULL << (i * SST_PP_OFFSET_SIZE));\n\t\toffset >>= (i * 8);\n\t\toffset &= 0xff;\n\t\toffset *= 8;  \n\t\tpd_info->perf_levels[i].mmio_offset = pd_info->sst_header.pp_offset + offset;\n\t}\n\n\treturn 0;\n}\n\nstatic int sst_main(struct auxiliary_device *auxdev, struct tpmi_per_power_domain_info *pd_info)\n{\n\tint i, mask, levels;\n\n\t*((u64 *)&pd_info->sst_header) = readq(pd_info->sst_base);\n\tpd_info->sst_header.cp_offset *= 8;\n\tpd_info->sst_header.pp_offset *= 8;\n\n\tif (pd_info->sst_header.interface_version != ISST_HEADER_VERSION) {\n\t\tdev_err(&auxdev->dev, \"SST: Unsupported version:%x\\n\",\n\t\t\tpd_info->sst_header.interface_version);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\t*((u64 *)&pd_info->cp_header) = readq(pd_info->sst_base + pd_info->sst_header.cp_offset);\n\n\t \n\t*((u64 *)&pd_info->pp_header) = readq(pd_info->sst_base + pd_info->sst_header.pp_offset);\n\n\t \n\tpd_info->pp_header.level_en_mask |= 0x01;\n\n\tmask = 0x01;\n\tlevels = 0;\n\tfor (i = 0; i < 8; ++i) {\n\t\tif (pd_info->pp_header.level_en_mask & mask)\n\t\t\tlevels = i;\n\t\tmask <<= 1;\n\t}\n\tpd_info->max_level = levels;\n\tsst_add_perf_profiles(auxdev, pd_info, levels + 1);\n\n\treturn 0;\n}\n\n \nstatic struct tpmi_per_power_domain_info *get_instance(int pkg_id, int power_domain_id)\n{\n\tstruct tpmi_per_power_domain_info *power_domain_info;\n\tstruct tpmi_sst_struct *sst_inst;\n\n\tif (pkg_id < 0 || pkg_id > isst_common.max_index ||\n\t    pkg_id >= topology_max_packages())\n\t\treturn NULL;\n\n\tsst_inst = isst_common.sst_inst[pkg_id];\n\tif (!sst_inst)\n\t\treturn NULL;\n\n\tif (power_domain_id < 0 || power_domain_id >= sst_inst->number_of_power_domains)\n\t\treturn NULL;\n\n\tpower_domain_info = &sst_inst->power_domain_info[power_domain_id];\n\n\tif (power_domain_info && !power_domain_info->sst_base)\n\t\treturn NULL;\n\n\treturn power_domain_info;\n}\n\nstatic bool disable_dynamic_sst_features(void)\n{\n\tu64 value;\n\n\trdmsrl(MSR_PM_ENABLE, value);\n\treturn !(value & 0x1);\n}\n\n#define _read_cp_info(name_str, name, offset, start, width, mult_factor)\\\n{\\\n\tu64 val, mask;\\\n\t\\\n\tval = readq(power_domain_info->sst_base + power_domain_info->sst_header.cp_offset +\\\n\t\t\t(offset));\\\n\tmask = GENMASK_ULL((start + width - 1), start);\\\n\tval &= mask; \\\n\tval >>= start;\\\n\tname = (val * mult_factor);\\\n}\n\n#define _write_cp_info(name_str, name, offset, start, width, div_factor)\\\n{\\\n\tu64 val, mask;\\\n\t\\\n\tval = readq(power_domain_info->sst_base +\\\n\t\t    power_domain_info->sst_header.cp_offset + (offset));\\\n\tmask = GENMASK_ULL((start + width - 1), start);\\\n\tval &= ~mask;\\\n\tval |= (name / div_factor) << start;\\\n\twriteq(val, power_domain_info->sst_base + power_domain_info->sst_header.cp_offset +\\\n\t\t(offset));\\\n}\n\n#define\tSST_CP_CONTROL_OFFSET\t8\n#define\tSST_CP_STATUS_OFFSET\t16\n\n#define SST_CP_ENABLE_START\t\t0\n#define SST_CP_ENABLE_WIDTH\t\t1\n\n#define SST_CP_PRIORITY_TYPE_START\t1\n#define SST_CP_PRIORITY_TYPE_WIDTH\t1\n\nstatic long isst_if_core_power_state(void __user *argp)\n{\n\tstruct tpmi_per_power_domain_info *power_domain_info;\n\tstruct isst_core_power core_power;\n\n\tif (disable_dynamic_sst_features())\n\t\treturn -EFAULT;\n\n\tif (copy_from_user(&core_power, argp, sizeof(core_power)))\n\t\treturn -EFAULT;\n\n\tpower_domain_info = get_instance(core_power.socket_id, core_power.power_domain_id);\n\tif (!power_domain_info)\n\t\treturn -EINVAL;\n\n\tif (core_power.get_set) {\n\t\t_write_cp_info(\"cp_enable\", core_power.enable, SST_CP_CONTROL_OFFSET,\n\t\t\t       SST_CP_ENABLE_START, SST_CP_ENABLE_WIDTH, SST_MUL_FACTOR_NONE)\n\t\t_write_cp_info(\"cp_prio_type\", core_power.priority_type, SST_CP_CONTROL_OFFSET,\n\t\t\t       SST_CP_PRIORITY_TYPE_START, SST_CP_PRIORITY_TYPE_WIDTH,\n\t\t\t       SST_MUL_FACTOR_NONE)\n\t} else {\n\t\t \n\t\t_read_cp_info(\"cp_enable\", core_power.enable, SST_CP_STATUS_OFFSET,\n\t\t\t      SST_CP_ENABLE_START, SST_CP_ENABLE_WIDTH, SST_MUL_FACTOR_NONE)\n\t\t_read_cp_info(\"cp_prio_type\", core_power.priority_type, SST_CP_STATUS_OFFSET,\n\t\t\t      SST_CP_PRIORITY_TYPE_START, SST_CP_PRIORITY_TYPE_WIDTH,\n\t\t\t      SST_MUL_FACTOR_NONE)\n\t\tcore_power.supported = !!(power_domain_info->sst_header.cap_mask & BIT(0));\n\t\tif (copy_to_user(argp, &core_power, sizeof(core_power)))\n\t\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n}\n\n#define SST_CLOS_CONFIG_0_OFFSET\t24\n\n#define SST_CLOS_CONFIG_PRIO_START\t4\n#define SST_CLOS_CONFIG_PRIO_WIDTH\t4\n\n#define SST_CLOS_CONFIG_MIN_START\t8\n#define SST_CLOS_CONFIG_MIN_WIDTH\t8\n\n#define SST_CLOS_CONFIG_MAX_START\t16\n#define SST_CLOS_CONFIG_MAX_WIDTH\t8\n\nstatic long isst_if_clos_param(void __user *argp)\n{\n\tstruct tpmi_per_power_domain_info *power_domain_info;\n\tstruct isst_clos_param clos_param;\n\n\tif (copy_from_user(&clos_param, argp, sizeof(clos_param)))\n\t\treturn -EFAULT;\n\n\tpower_domain_info = get_instance(clos_param.socket_id, clos_param.power_domain_id);\n\tif (!power_domain_info)\n\t\treturn -EINVAL;\n\n\tif (clos_param.get_set) {\n\t\t_write_cp_info(\"clos.min_freq\", clos_param.min_freq_mhz,\n\t\t\t       (SST_CLOS_CONFIG_0_OFFSET + clos_param.clos * SST_REG_SIZE),\n\t\t\t       SST_CLOS_CONFIG_MIN_START, SST_CLOS_CONFIG_MIN_WIDTH,\n\t\t\t       SST_MUL_FACTOR_FREQ);\n\t\t_write_cp_info(\"clos.max_freq\", clos_param.max_freq_mhz,\n\t\t\t       (SST_CLOS_CONFIG_0_OFFSET + clos_param.clos * SST_REG_SIZE),\n\t\t\t       SST_CLOS_CONFIG_MAX_START, SST_CLOS_CONFIG_MAX_WIDTH,\n\t\t\t       SST_MUL_FACTOR_FREQ);\n\t\t_write_cp_info(\"clos.prio\", clos_param.prop_prio,\n\t\t\t       (SST_CLOS_CONFIG_0_OFFSET + clos_param.clos * SST_REG_SIZE),\n\t\t\t       SST_CLOS_CONFIG_PRIO_START, SST_CLOS_CONFIG_PRIO_WIDTH,\n\t\t\t       SST_MUL_FACTOR_NONE);\n\t} else {\n\t\t \n\t\t_read_cp_info(\"clos.min_freq\", clos_param.min_freq_mhz,\n\t\t\t\t(SST_CLOS_CONFIG_0_OFFSET + clos_param.clos * SST_REG_SIZE),\n\t\t\t\tSST_CLOS_CONFIG_MIN_START, SST_CLOS_CONFIG_MIN_WIDTH,\n\t\t\t\tSST_MUL_FACTOR_FREQ)\n\t\t_read_cp_info(\"clos.max_freq\", clos_param.max_freq_mhz,\n\t\t\t\t(SST_CLOS_CONFIG_0_OFFSET + clos_param.clos * SST_REG_SIZE),\n\t\t\t\tSST_CLOS_CONFIG_MAX_START, SST_CLOS_CONFIG_MAX_WIDTH,\n\t\t\t\tSST_MUL_FACTOR_FREQ)\n\t\t_read_cp_info(\"clos.prio\", clos_param.prop_prio,\n\t\t\t\t(SST_CLOS_CONFIG_0_OFFSET + clos_param.clos * SST_REG_SIZE),\n\t\t\t\tSST_CLOS_CONFIG_PRIO_START, SST_CLOS_CONFIG_PRIO_WIDTH,\n\t\t\t\tSST_MUL_FACTOR_NONE)\n\n\t\tif (copy_to_user(argp, &clos_param, sizeof(clos_param)))\n\t\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n}\n\n#define SST_CLOS_ASSOC_0_OFFSET\t\t56\n#define SST_CLOS_ASSOC_CPUS_PER_REG\t16\n#define SST_CLOS_ASSOC_BITS_PER_CPU\t4\n\nstatic long isst_if_clos_assoc(void __user *argp)\n{\n\tstruct isst_if_clos_assoc_cmds assoc_cmds;\n\tunsigned char __user *ptr;\n\tint i;\n\n\t \n\tif (copy_from_user(&assoc_cmds, argp, sizeof(assoc_cmds)))\n\t\treturn -EFAULT;\n\n\tif (!assoc_cmds.cmd_count || assoc_cmds.cmd_count > ISST_IF_CMD_LIMIT)\n\t\treturn -EINVAL;\n\n\tptr = argp + offsetof(struct isst_if_clos_assoc_cmds, assoc_info);\n\tfor (i = 0; i < assoc_cmds.cmd_count; ++i) {\n\t\tstruct tpmi_per_power_domain_info *power_domain_info;\n\t\tstruct isst_if_clos_assoc clos_assoc;\n\t\tint punit_id, punit_cpu_no, pkg_id;\n\t\tstruct tpmi_sst_struct *sst_inst;\n\t\tint offset, shift, cpu;\n\t\tu64 val, mask, clos;\n\n\t\tif (copy_from_user(&clos_assoc, ptr, sizeof(clos_assoc)))\n\t\t\treturn -EFAULT;\n\n\t\tif (clos_assoc.socket_id > topology_max_packages())\n\t\t\treturn -EINVAL;\n\n\t\tcpu = clos_assoc.logical_cpu;\n\t\tclos = clos_assoc.clos;\n\n\t\tif (assoc_cmds.punit_cpu_map)\n\t\t\tpunit_cpu_no = cpu;\n\t\telse\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tif (punit_cpu_no < 0)\n\t\t\treturn -EINVAL;\n\n\t\tpunit_id = clos_assoc.power_domain_id;\n\t\tpkg_id = clos_assoc.socket_id;\n\n\t\tsst_inst = isst_common.sst_inst[pkg_id];\n\n\t\tif (clos_assoc.power_domain_id > sst_inst->number_of_power_domains)\n\t\t\treturn -EINVAL;\n\n\t\tpower_domain_info = &sst_inst->power_domain_info[punit_id];\n\n\t\toffset = SST_CLOS_ASSOC_0_OFFSET +\n\t\t\t\t(punit_cpu_no / SST_CLOS_ASSOC_CPUS_PER_REG) * SST_REG_SIZE;\n\t\tshift = punit_cpu_no % SST_CLOS_ASSOC_CPUS_PER_REG;\n\t\tshift *= SST_CLOS_ASSOC_BITS_PER_CPU;\n\n\t\tval = readq(power_domain_info->sst_base +\n\t\t\t\tpower_domain_info->sst_header.cp_offset + offset);\n\t\tif (assoc_cmds.get_set) {\n\t\t\tmask = GENMASK_ULL((shift + SST_CLOS_ASSOC_BITS_PER_CPU - 1), shift);\n\t\t\tval &= ~mask;\n\t\t\tval |= (clos << shift);\n\t\t\twriteq(val, power_domain_info->sst_base +\n\t\t\t\t\tpower_domain_info->sst_header.cp_offset + offset);\n\t\t} else {\n\t\t\tval >>= shift;\n\t\t\tclos_assoc.clos = val & GENMASK(SST_CLOS_ASSOC_BITS_PER_CPU - 1, 0);\n\t\t\tif (copy_to_user(ptr, &clos_assoc, sizeof(clos_assoc)))\n\t\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tptr += sizeof(clos_assoc);\n\t}\n\n\treturn 0;\n}\n\n#define _read_pp_info(name_str, name, offset, start, width, mult_factor)\\\n{\\\n\tu64 val, _mask;\\\n\t\\\n\tval = readq(power_domain_info->sst_base + power_domain_info->sst_header.pp_offset +\\\n\t\t    (offset));\\\n\t_mask = GENMASK_ULL((start + width - 1), start);\\\n\tval &= _mask;\\\n\tval >>= start;\\\n\tname = (val * mult_factor);\\\n}\n\n#define _write_pp_info(name_str, name, offset, start, width, div_factor)\\\n{\\\n\tu64 val, _mask;\\\n\t\\\n\tval = readq(power_domain_info->sst_base + power_domain_info->sst_header.pp_offset +\\\n\t\t    (offset));\\\n\t_mask = GENMASK((start + width - 1), start);\\\n\tval &= ~_mask;\\\n\tval |= (name / div_factor) << start;\\\n\twriteq(val, power_domain_info->sst_base + power_domain_info->sst_header.pp_offset +\\\n\t      (offset));\\\n}\n\n#define _read_bf_level_info(name_str, name, level, offset, start, width, mult_factor)\\\n{\\\n\tu64 val, _mask;\\\n\t\\\n\tval = readq(power_domain_info->sst_base +\\\n\t\t    power_domain_info->perf_levels[level].mmio_offset +\\\n\t\t(power_domain_info->feature_offsets.bf_offset * 8) + (offset));\\\n\t_mask = GENMASK_ULL((start + width - 1), start);\\\n\tval &= _mask; \\\n\tval >>= start;\\\n\tname = (val * mult_factor);\\\n}\n\n#define _read_tf_level_info(name_str, name, level, offset, start, width, mult_factor)\\\n{\\\n\tu64 val, _mask;\\\n\t\\\n\tval = readq(power_domain_info->sst_base +\\\n\t\t    power_domain_info->perf_levels[level].mmio_offset +\\\n\t\t(power_domain_info->feature_offsets.tf_offset * 8) + (offset));\\\n\t_mask = GENMASK_ULL((start + width - 1), start);\\\n\tval &= _mask; \\\n\tval >>= start;\\\n\tname = (val * mult_factor);\\\n}\n\n#define SST_PP_STATUS_OFFSET\t32\n\n#define SST_PP_LEVEL_START\t0\n#define SST_PP_LEVEL_WIDTH\t3\n\n#define SST_PP_LOCK_START\t3\n#define SST_PP_LOCK_WIDTH\t1\n\n#define SST_PP_FEATURE_STATE_START\t8\n#define SST_PP_FEATURE_STATE_WIDTH\t8\n\n#define SST_BF_FEATURE_SUPPORTED_START\t12\n#define SST_BF_FEATURE_SUPPORTED_WIDTH\t1\n\n#define SST_TF_FEATURE_SUPPORTED_START\t12\n#define SST_TF_FEATURE_SUPPORTED_WIDTH\t1\n\nstatic int isst_if_get_perf_level(void __user *argp)\n{\n\tstruct isst_perf_level_info perf_level;\n\tstruct tpmi_per_power_domain_info *power_domain_info;\n\n\tif (copy_from_user(&perf_level, argp, sizeof(perf_level)))\n\t\treturn -EFAULT;\n\n\tpower_domain_info = get_instance(perf_level.socket_id, perf_level.power_domain_id);\n\tif (!power_domain_info)\n\t\treturn -EINVAL;\n\n\tperf_level.max_level = power_domain_info->max_level;\n\tperf_level.level_mask = power_domain_info->pp_header.allowed_level_mask;\n\tperf_level.feature_rev = power_domain_info->pp_header.feature_rev;\n\t_read_pp_info(\"current_level\", perf_level.current_level, SST_PP_STATUS_OFFSET,\n\t\t      SST_PP_LEVEL_START, SST_PP_LEVEL_WIDTH, SST_MUL_FACTOR_NONE)\n\t_read_pp_info(\"locked\", perf_level.locked, SST_PP_STATUS_OFFSET,\n\t\t      SST_PP_LOCK_START, SST_PP_LEVEL_WIDTH, SST_MUL_FACTOR_NONE)\n\t_read_pp_info(\"feature_state\", perf_level.feature_state, SST_PP_STATUS_OFFSET,\n\t\t      SST_PP_FEATURE_STATE_START, SST_PP_FEATURE_STATE_WIDTH, SST_MUL_FACTOR_NONE)\n\tperf_level.enabled = !!(power_domain_info->sst_header.cap_mask & BIT(1));\n\n\t_read_bf_level_info(\"bf_support\", perf_level.sst_bf_support, 0, 0,\n\t\t\t    SST_BF_FEATURE_SUPPORTED_START, SST_BF_FEATURE_SUPPORTED_WIDTH,\n\t\t\t    SST_MUL_FACTOR_NONE);\n\t_read_tf_level_info(\"tf_support\", perf_level.sst_tf_support, 0, 0,\n\t\t\t    SST_TF_FEATURE_SUPPORTED_START, SST_TF_FEATURE_SUPPORTED_WIDTH,\n\t\t\t    SST_MUL_FACTOR_NONE);\n\n\tif (copy_to_user(argp, &perf_level, sizeof(perf_level)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\n#define SST_PP_CONTROL_OFFSET\t\t24\n#define SST_PP_LEVEL_CHANGE_TIME_MS\t5\n#define SST_PP_LEVEL_CHANGE_RETRY_COUNT\t3\n\nstatic int isst_if_set_perf_level(void __user *argp)\n{\n\tstruct isst_perf_level_control perf_level;\n\tstruct tpmi_per_power_domain_info *power_domain_info;\n\tint level, retry = 0;\n\n\tif (disable_dynamic_sst_features())\n\t\treturn -EFAULT;\n\n\tif (copy_from_user(&perf_level, argp, sizeof(perf_level)))\n\t\treturn -EFAULT;\n\n\tpower_domain_info = get_instance(perf_level.socket_id, perf_level.power_domain_id);\n\tif (!power_domain_info)\n\t\treturn -EINVAL;\n\n\tif (!(power_domain_info->pp_header.allowed_level_mask & BIT(perf_level.level)))\n\t\treturn -EINVAL;\n\n\t_read_pp_info(\"current_level\", level, SST_PP_STATUS_OFFSET,\n\t\t      SST_PP_LEVEL_START, SST_PP_LEVEL_WIDTH, SST_MUL_FACTOR_NONE)\n\n\t \n\tif (perf_level.level == level)\n\t\treturn -EINVAL;\n\n\t_write_pp_info(\"perf_level\", perf_level.level, SST_PP_CONTROL_OFFSET,\n\t\t       SST_PP_LEVEL_START, SST_PP_LEVEL_WIDTH, SST_MUL_FACTOR_NONE)\n\n\t \n\tdo {\n\t\t \n\t\tmsleep(SST_PP_LEVEL_CHANGE_TIME_MS);\n\n\t\t_read_pp_info(\"current_level\", level, SST_PP_STATUS_OFFSET,\n\t\t\t      SST_PP_LEVEL_START, SST_PP_LEVEL_WIDTH, SST_MUL_FACTOR_NONE)\n\n\t\t \n\t\tif (perf_level.level == level)\n\t\t\tbreak;\n\n\t} while (retry++ < SST_PP_LEVEL_CHANGE_RETRY_COUNT);\n\n\t \n\tif (perf_level.level != level)\n\t\treturn -EFAULT;\n\n\t \n\t_write_pp_info(\"perf_feature\", 0, SST_PP_CONTROL_OFFSET,\n\t\t       SST_PP_FEATURE_STATE_START, SST_PP_FEATURE_STATE_WIDTH,\n\t\t       SST_MUL_FACTOR_NONE)\n\n\t \n\tmsleep(SST_PP_LEVEL_CHANGE_TIME_MS);\n\n\treturn 0;\n}\n\nstatic int isst_if_set_perf_feature(void __user *argp)\n{\n\tstruct isst_perf_feature_control perf_feature;\n\tstruct tpmi_per_power_domain_info *power_domain_info;\n\n\tif (disable_dynamic_sst_features())\n\t\treturn -EFAULT;\n\n\tif (copy_from_user(&perf_feature, argp, sizeof(perf_feature)))\n\t\treturn -EFAULT;\n\n\tpower_domain_info = get_instance(perf_feature.socket_id, perf_feature.power_domain_id);\n\tif (!power_domain_info)\n\t\treturn -EINVAL;\n\n\t_write_pp_info(\"perf_feature\", perf_feature.feature, SST_PP_CONTROL_OFFSET,\n\t\t       SST_PP_FEATURE_STATE_START, SST_PP_FEATURE_STATE_WIDTH,\n\t\t       SST_MUL_FACTOR_NONE)\n\n\treturn 0;\n}\n\n#define _read_pp_level_info(name_str, name, level, offset, start, width, mult_factor)\\\n{\\\n\tu64 val, _mask;\\\n\t\\\n\tval = readq(power_domain_info->sst_base +\\\n\t\t    power_domain_info->perf_levels[level].mmio_offset +\\\n\t\t(power_domain_info->feature_offsets.pp_offset * 8) + (offset));\\\n\t_mask = GENMASK_ULL((start + width - 1), start);\\\n\tval &= _mask; \\\n\tval >>= start;\\\n\tname = (val * mult_factor);\\\n}\n\n#define SST_PP_INFO_0_OFFSET\t0\n#define SST_PP_INFO_1_OFFSET\t8\n#define SST_PP_INFO_2_OFFSET\t16\n#define SST_PP_INFO_3_OFFSET\t24\n\n \n#define SST_PP_INFO_4_OFFSET\t32\n\n#define SST_PP_INFO_10_OFFSET\t80\n#define SST_PP_INFO_11_OFFSET\t88\n\n#define SST_PP_P1_SSE_START\t0\n#define SST_PP_P1_SSE_WIDTH\t8\n\n#define SST_PP_P1_AVX2_START\t8\n#define SST_PP_P1_AVX2_WIDTH\t8\n\n#define SST_PP_P1_AVX512_START\t16\n#define SST_PP_P1_AVX512_WIDTH\t8\n\n#define SST_PP_P1_AMX_START\t24\n#define SST_PP_P1_AMX_WIDTH\t8\n\n#define SST_PP_TDP_START\t32\n#define SST_PP_TDP_WIDTH\t15\n\n#define SST_PP_T_PROCHOT_START\t47\n#define SST_PP_T_PROCHOT_WIDTH\t8\n\n#define SST_PP_MAX_MEMORY_FREQ_START\t55\n#define SST_PP_MAX_MEMORY_FREQ_WIDTH\t7\n\n#define SST_PP_COOLING_TYPE_START\t62\n#define SST_PP_COOLING_TYPE_WIDTH\t2\n\n#define SST_PP_TRL_0_RATIO_0_START\t0\n#define SST_PP_TRL_0_RATIO_0_WIDTH\t8\n\n#define SST_PP_TRL_CORES_BUCKET_0_START\t0\n#define SST_PP_TRL_CORES_BUCKET_0_WIDTH\t8\n\n#define SST_PP_CORE_RATIO_P0_START\t0\n#define SST_PP_CORE_RATIO_P0_WIDTH\t8\n\n#define SST_PP_CORE_RATIO_P1_START\t8\n#define SST_PP_CORE_RATIO_P1_WIDTH\t8\n\n#define SST_PP_CORE_RATIO_PN_START\t16\n#define SST_PP_CORE_RATIO_PN_WIDTH\t8\n\n#define SST_PP_CORE_RATIO_PM_START\t24\n#define SST_PP_CORE_RATIO_PM_WIDTH\t8\n\n#define SST_PP_CORE_RATIO_P0_FABRIC_START\t32\n#define SST_PP_CORE_RATIO_P0_FABRIC_WIDTH\t8\n\n#define SST_PP_CORE_RATIO_P1_FABRIC_START\t40\n#define SST_PP_CORE_RATIO_P1_FABRIC_WIDTH\t8\n\n#define SST_PP_CORE_RATIO_PM_FABRIC_START\t48\n#define SST_PP_CORE_RATIO_PM_FABRIC_WIDTH\t8\n\nstatic int isst_if_get_perf_level_info(void __user *argp)\n{\n\tstruct isst_perf_level_data_info perf_level;\n\tstruct tpmi_per_power_domain_info *power_domain_info;\n\tint i, j;\n\n\tif (copy_from_user(&perf_level, argp, sizeof(perf_level)))\n\t\treturn -EFAULT;\n\n\tpower_domain_info = get_instance(perf_level.socket_id, perf_level.power_domain_id);\n\tif (!power_domain_info)\n\t\treturn -EINVAL;\n\n\tif (perf_level.level > power_domain_info->max_level)\n\t\treturn -EINVAL;\n\n\tif (!(power_domain_info->pp_header.level_en_mask & BIT(perf_level.level)))\n\t\treturn -EINVAL;\n\n\t_read_pp_level_info(\"tdp_ratio\", perf_level.tdp_ratio, perf_level.level,\n\t\t\t    SST_PP_INFO_0_OFFSET, SST_PP_P1_SSE_START, SST_PP_P1_SSE_WIDTH,\n\t\t\t    SST_MUL_FACTOR_NONE)\n\t_read_pp_level_info(\"base_freq_mhz\", perf_level.base_freq_mhz, perf_level.level,\n\t\t\t    SST_PP_INFO_0_OFFSET, SST_PP_P1_SSE_START, SST_PP_P1_SSE_WIDTH,\n\t\t\t    SST_MUL_FACTOR_FREQ)\n\t_read_pp_level_info(\"base_freq_avx2_mhz\", perf_level.base_freq_avx2_mhz, perf_level.level,\n\t\t\t    SST_PP_INFO_0_OFFSET, SST_PP_P1_AVX2_START, SST_PP_P1_AVX2_WIDTH,\n\t\t\t    SST_MUL_FACTOR_FREQ)\n\t_read_pp_level_info(\"base_freq_avx512_mhz\", perf_level.base_freq_avx512_mhz,\n\t\t\t    perf_level.level, SST_PP_INFO_0_OFFSET, SST_PP_P1_AVX512_START,\n\t\t\t    SST_PP_P1_AVX512_WIDTH, SST_MUL_FACTOR_FREQ)\n\t_read_pp_level_info(\"base_freq_amx_mhz\", perf_level.base_freq_amx_mhz, perf_level.level,\n\t\t\t    SST_PP_INFO_0_OFFSET, SST_PP_P1_AMX_START, SST_PP_P1_AMX_WIDTH,\n\t\t\t    SST_MUL_FACTOR_FREQ)\n\n\t_read_pp_level_info(\"thermal_design_power_w\", perf_level.thermal_design_power_w,\n\t\t\t    perf_level.level, SST_PP_INFO_1_OFFSET, SST_PP_TDP_START,\n\t\t\t    SST_PP_TDP_WIDTH, SST_MUL_FACTOR_NONE)\n\tperf_level.thermal_design_power_w /= 8;  \n\t_read_pp_level_info(\"tjunction_max_c\", perf_level.tjunction_max_c, perf_level.level,\n\t\t\t    SST_PP_INFO_1_OFFSET, SST_PP_T_PROCHOT_START, SST_PP_T_PROCHOT_WIDTH,\n\t\t\t    SST_MUL_FACTOR_NONE)\n\t_read_pp_level_info(\"max_memory_freq_mhz\", perf_level.max_memory_freq_mhz,\n\t\t\t    perf_level.level, SST_PP_INFO_1_OFFSET, SST_PP_MAX_MEMORY_FREQ_START,\n\t\t\t    SST_PP_MAX_MEMORY_FREQ_WIDTH, SST_MUL_FACTOR_FREQ)\n\t_read_pp_level_info(\"cooling_type\", perf_level.cooling_type, perf_level.level,\n\t\t\t    SST_PP_INFO_1_OFFSET, SST_PP_COOLING_TYPE_START,\n\t\t\t    SST_PP_COOLING_TYPE_WIDTH, SST_MUL_FACTOR_NONE)\n\n\tfor (i = 0; i < TRL_MAX_LEVELS; ++i) {\n\t\tfor (j = 0; j < TRL_MAX_BUCKETS; ++j)\n\t\t\t_read_pp_level_info(\"trl*_bucket*_freq_mhz\",\n\t\t\t\t\t    perf_level.trl_freq_mhz[i][j], perf_level.level,\n\t\t\t\t\t    SST_PP_INFO_4_OFFSET + (i * SST_PP_TRL_0_RATIO_0_WIDTH),\n\t\t\t\t\t    j * SST_PP_TRL_0_RATIO_0_WIDTH,\n\t\t\t\t\t    SST_PP_TRL_0_RATIO_0_WIDTH,\n\t\t\t\t\t    SST_MUL_FACTOR_FREQ);\n\t}\n\n\tfor (i = 0; i < TRL_MAX_BUCKETS; ++i)\n\t\t_read_pp_level_info(\"bucket*_core_count\", perf_level.bucket_core_counts[i],\n\t\t\t\t    perf_level.level, SST_PP_INFO_10_OFFSET,\n\t\t\t\t    SST_PP_TRL_CORES_BUCKET_0_WIDTH * i,\n\t\t\t\t    SST_PP_TRL_CORES_BUCKET_0_WIDTH, SST_MUL_FACTOR_NONE)\n\n\tperf_level.max_buckets = TRL_MAX_BUCKETS;\n\tperf_level.max_trl_levels = TRL_MAX_LEVELS;\n\n\t_read_pp_level_info(\"p0_freq_mhz\", perf_level.p0_freq_mhz, perf_level.level,\n\t\t\t    SST_PP_INFO_11_OFFSET, SST_PP_CORE_RATIO_P0_START,\n\t\t\t    SST_PP_CORE_RATIO_P0_WIDTH, SST_MUL_FACTOR_FREQ)\n\t_read_pp_level_info(\"p1_freq_mhz\", perf_level.p1_freq_mhz, perf_level.level,\n\t\t\t    SST_PP_INFO_11_OFFSET, SST_PP_CORE_RATIO_P1_START,\n\t\t\t    SST_PP_CORE_RATIO_P1_WIDTH, SST_MUL_FACTOR_FREQ)\n\t_read_pp_level_info(\"pn_freq_mhz\", perf_level.pn_freq_mhz, perf_level.level,\n\t\t\t    SST_PP_INFO_11_OFFSET, SST_PP_CORE_RATIO_PN_START,\n\t\t\t    SST_PP_CORE_RATIO_PN_WIDTH, SST_MUL_FACTOR_FREQ)\n\t_read_pp_level_info(\"pm_freq_mhz\", perf_level.pm_freq_mhz, perf_level.level,\n\t\t\t    SST_PP_INFO_11_OFFSET, SST_PP_CORE_RATIO_PM_START,\n\t\t\t    SST_PP_CORE_RATIO_PM_WIDTH, SST_MUL_FACTOR_FREQ)\n\t_read_pp_level_info(\"p0_fabric_freq_mhz\", perf_level.p0_fabric_freq_mhz,\n\t\t\t    perf_level.level, SST_PP_INFO_11_OFFSET,\n\t\t\t    SST_PP_CORE_RATIO_P0_FABRIC_START,\n\t\t\t    SST_PP_CORE_RATIO_P0_FABRIC_WIDTH, SST_MUL_FACTOR_FREQ)\n\t_read_pp_level_info(\"p1_fabric_freq_mhz\", perf_level.p1_fabric_freq_mhz,\n\t\t\t    perf_level.level, SST_PP_INFO_11_OFFSET,\n\t\t\t    SST_PP_CORE_RATIO_P1_FABRIC_START,\n\t\t\t    SST_PP_CORE_RATIO_P1_FABRIC_WIDTH, SST_MUL_FACTOR_FREQ)\n\t_read_pp_level_info(\"pm_fabric_freq_mhz\", perf_level.pm_fabric_freq_mhz,\n\t\t\t    perf_level.level, SST_PP_INFO_11_OFFSET,\n\t\t\t    SST_PP_CORE_RATIO_PM_FABRIC_START,\n\t\t\t    SST_PP_CORE_RATIO_PM_FABRIC_WIDTH, SST_MUL_FACTOR_FREQ)\n\n\tif (copy_to_user(argp, &perf_level, sizeof(perf_level)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\n#define SST_PP_FUSED_CORE_COUNT_START\t0\n#define SST_PP_FUSED_CORE_COUNT_WIDTH\t8\n\n#define SST_PP_RSLVD_CORE_COUNT_START\t8\n#define SST_PP_RSLVD_CORE_COUNT_WIDTH\t8\n\n#define SST_PP_RSLVD_CORE_MASK_START\t0\n#define SST_PP_RSLVD_CORE_MASK_WIDTH\t64\n\nstatic int isst_if_get_perf_level_mask(void __user *argp)\n{\n\tstatic struct isst_perf_level_cpu_mask cpumask;\n\tstruct tpmi_per_power_domain_info *power_domain_info;\n\tu64 mask;\n\n\tif (copy_from_user(&cpumask, argp, sizeof(cpumask)))\n\t\treturn -EFAULT;\n\n\tpower_domain_info = get_instance(cpumask.socket_id, cpumask.power_domain_id);\n\tif (!power_domain_info)\n\t\treturn -EINVAL;\n\n\t_read_pp_level_info(\"mask\", mask, cpumask.level, SST_PP_INFO_2_OFFSET,\n\t\t\t    SST_PP_RSLVD_CORE_MASK_START, SST_PP_RSLVD_CORE_MASK_WIDTH,\n\t\t\t    SST_MUL_FACTOR_NONE)\n\n\tcpumask.mask = mask;\n\n\tif (!cpumask.punit_cpu_map)\n\t\treturn -EOPNOTSUPP;\n\n\tif (copy_to_user(argp, &cpumask, sizeof(cpumask)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\n#define SST_BF_INFO_0_OFFSET\t0\n#define SST_BF_INFO_1_OFFSET\t8\n\n#define SST_BF_P1_HIGH_START\t13\n#define SST_BF_P1_HIGH_WIDTH\t8\n\n#define SST_BF_P1_LOW_START\t21\n#define SST_BF_P1_LOW_WIDTH\t8\n\n#define SST_BF_T_PROHOT_START\t38\n#define SST_BF_T_PROHOT_WIDTH\t8\n\n#define SST_BF_TDP_START\t46\n#define SST_BF_TDP_WIDTH\t15\n\nstatic int isst_if_get_base_freq_info(void __user *argp)\n{\n\tstatic struct isst_base_freq_info base_freq;\n\tstruct tpmi_per_power_domain_info *power_domain_info;\n\n\tif (copy_from_user(&base_freq, argp, sizeof(base_freq)))\n\t\treturn -EFAULT;\n\n\tpower_domain_info = get_instance(base_freq.socket_id, base_freq.power_domain_id);\n\tif (!power_domain_info)\n\t\treturn -EINVAL;\n\n\tif (base_freq.level > power_domain_info->max_level)\n\t\treturn -EINVAL;\n\n\t_read_bf_level_info(\"p1_high\", base_freq.high_base_freq_mhz, base_freq.level,\n\t\t\t    SST_BF_INFO_0_OFFSET, SST_BF_P1_HIGH_START, SST_BF_P1_HIGH_WIDTH,\n\t\t\t    SST_MUL_FACTOR_FREQ)\n\t_read_bf_level_info(\"p1_low\", base_freq.low_base_freq_mhz, base_freq.level,\n\t\t\t    SST_BF_INFO_0_OFFSET, SST_BF_P1_LOW_START, SST_BF_P1_LOW_WIDTH,\n\t\t\t    SST_MUL_FACTOR_FREQ)\n\t_read_bf_level_info(\"BF-TJ\", base_freq.tjunction_max_c, base_freq.level,\n\t\t\t    SST_BF_INFO_0_OFFSET, SST_BF_T_PROHOT_START, SST_BF_T_PROHOT_WIDTH,\n\t\t\t    SST_MUL_FACTOR_NONE)\n\t_read_bf_level_info(\"BF-tdp\", base_freq.thermal_design_power_w, base_freq.level,\n\t\t\t    SST_BF_INFO_0_OFFSET, SST_BF_TDP_START, SST_BF_TDP_WIDTH,\n\t\t\t    SST_MUL_FACTOR_NONE)\n\tbase_freq.thermal_design_power_w /= 8;  \n\n\tif (copy_to_user(argp, &base_freq, sizeof(base_freq)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\n#define P1_HI_CORE_MASK_START\t0\n#define P1_HI_CORE_MASK_WIDTH\t64\n\nstatic int isst_if_get_base_freq_mask(void __user *argp)\n{\n\tstatic struct isst_perf_level_cpu_mask cpumask;\n\tstruct tpmi_per_power_domain_info *power_domain_info;\n\tu64 mask;\n\n\tif (copy_from_user(&cpumask, argp, sizeof(cpumask)))\n\t\treturn -EFAULT;\n\n\tpower_domain_info = get_instance(cpumask.socket_id, cpumask.power_domain_id);\n\tif (!power_domain_info)\n\t\treturn -EINVAL;\n\n\t_read_bf_level_info(\"BF-cpumask\", mask, cpumask.level, SST_BF_INFO_1_OFFSET,\n\t\t\t    P1_HI_CORE_MASK_START, P1_HI_CORE_MASK_WIDTH,\n\t\t\t    SST_MUL_FACTOR_NONE)\n\n\tcpumask.mask = mask;\n\n\tif (!cpumask.punit_cpu_map)\n\t\treturn -EOPNOTSUPP;\n\n\tif (copy_to_user(argp, &cpumask, sizeof(cpumask)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int isst_if_get_tpmi_instance_count(void __user *argp)\n{\n\tstruct isst_tpmi_instance_count tpmi_inst;\n\tstruct tpmi_sst_struct *sst_inst;\n\tint i;\n\n\tif (copy_from_user(&tpmi_inst, argp, sizeof(tpmi_inst)))\n\t\treturn -EFAULT;\n\n\tif (tpmi_inst.socket_id >= topology_max_packages())\n\t\treturn -EINVAL;\n\n\ttpmi_inst.count = isst_common.sst_inst[tpmi_inst.socket_id]->number_of_power_domains;\n\n\tsst_inst = isst_common.sst_inst[tpmi_inst.socket_id];\n\ttpmi_inst.valid_mask = 0;\n\tfor (i = 0; i < sst_inst->number_of_power_domains; ++i) {\n\t\tstruct tpmi_per_power_domain_info *pd_info;\n\n\t\tpd_info = &sst_inst->power_domain_info[i];\n\t\tif (pd_info->sst_base)\n\t\t\ttpmi_inst.valid_mask |= BIT(i);\n\t}\n\n\tif (copy_to_user(argp, &tpmi_inst, sizeof(tpmi_inst)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\n#define SST_TF_INFO_0_OFFSET\t0\n#define SST_TF_INFO_1_OFFSET\t8\n#define SST_TF_INFO_2_OFFSET\t16\n\n#define SST_TF_MAX_LP_CLIP_RATIOS\tTRL_MAX_LEVELS\n\n#define SST_TF_LP_CLIP_RATIO_0_START\t16\n#define SST_TF_LP_CLIP_RATIO_0_WIDTH\t8\n\n#define SST_TF_RATIO_0_START\t0\n#define SST_TF_RATIO_0_WIDTH\t8\n\n#define SST_TF_NUM_CORE_0_START 0\n#define SST_TF_NUM_CORE_0_WIDTH 8\n\nstatic int isst_if_get_turbo_freq_info(void __user *argp)\n{\n\tstatic struct isst_turbo_freq_info turbo_freq;\n\tstruct tpmi_per_power_domain_info *power_domain_info;\n\tint i, j;\n\n\tif (copy_from_user(&turbo_freq, argp, sizeof(turbo_freq)))\n\t\treturn -EFAULT;\n\n\tpower_domain_info = get_instance(turbo_freq.socket_id, turbo_freq.power_domain_id);\n\tif (!power_domain_info)\n\t\treturn -EINVAL;\n\n\tif (turbo_freq.level > power_domain_info->max_level)\n\t\treturn -EINVAL;\n\n\tturbo_freq.max_buckets = TRL_MAX_BUCKETS;\n\tturbo_freq.max_trl_levels = TRL_MAX_LEVELS;\n\tturbo_freq.max_clip_freqs = SST_TF_MAX_LP_CLIP_RATIOS;\n\n\tfor (i = 0; i < turbo_freq.max_clip_freqs; ++i)\n\t\t_read_tf_level_info(\"lp_clip*\", turbo_freq.lp_clip_freq_mhz[i],\n\t\t\t\t    turbo_freq.level, SST_TF_INFO_0_OFFSET,\n\t\t\t\t    SST_TF_LP_CLIP_RATIO_0_START +\n\t\t\t\t    (i * SST_TF_LP_CLIP_RATIO_0_WIDTH),\n\t\t\t\t    SST_TF_LP_CLIP_RATIO_0_WIDTH, SST_MUL_FACTOR_FREQ)\n\n\tfor (i = 0; i < TRL_MAX_LEVELS; ++i) {\n\t\tfor (j = 0; j < TRL_MAX_BUCKETS; ++j)\n\t\t\t_read_tf_level_info(\"cydn*_bucket_*_trl\",\n\t\t\t\t\t    turbo_freq.trl_freq_mhz[i][j], turbo_freq.level,\n\t\t\t\t\t    SST_TF_INFO_2_OFFSET + (i * SST_TF_RATIO_0_WIDTH),\n\t\t\t\t\t    j * SST_TF_RATIO_0_WIDTH, SST_TF_RATIO_0_WIDTH,\n\t\t\t\t\t    SST_MUL_FACTOR_FREQ)\n\t}\n\n\tfor (i = 0; i < TRL_MAX_BUCKETS; ++i)\n\t\t_read_tf_level_info(\"bucket_*_core_count\", turbo_freq.bucket_core_counts[i],\n\t\t\t\t    turbo_freq.level, SST_TF_INFO_1_OFFSET,\n\t\t\t\t    SST_TF_NUM_CORE_0_WIDTH * i, SST_TF_NUM_CORE_0_WIDTH,\n\t\t\t\t    SST_MUL_FACTOR_NONE)\n\n\tif (copy_to_user(argp, &turbo_freq, sizeof(turbo_freq)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic long isst_if_def_ioctl(struct file *file, unsigned int cmd,\n\t\t\t      unsigned long arg)\n{\n\tvoid __user *argp = (void __user *)arg;\n\tlong ret = -ENOTTY;\n\n\tmutex_lock(&isst_tpmi_dev_lock);\n\tswitch (cmd) {\n\tcase ISST_IF_COUNT_TPMI_INSTANCES:\n\t\tret = isst_if_get_tpmi_instance_count(argp);\n\t\tbreak;\n\tcase ISST_IF_CORE_POWER_STATE:\n\t\tret = isst_if_core_power_state(argp);\n\t\tbreak;\n\tcase ISST_IF_CLOS_PARAM:\n\t\tret = isst_if_clos_param(argp);\n\t\tbreak;\n\tcase ISST_IF_CLOS_ASSOC:\n\t\tret = isst_if_clos_assoc(argp);\n\t\tbreak;\n\tcase ISST_IF_PERF_LEVELS:\n\t\tret = isst_if_get_perf_level(argp);\n\t\tbreak;\n\tcase ISST_IF_PERF_SET_LEVEL:\n\t\tret = isst_if_set_perf_level(argp);\n\t\tbreak;\n\tcase ISST_IF_PERF_SET_FEATURE:\n\t\tret = isst_if_set_perf_feature(argp);\n\t\tbreak;\n\tcase ISST_IF_GET_PERF_LEVEL_INFO:\n\t\tret = isst_if_get_perf_level_info(argp);\n\t\tbreak;\n\tcase ISST_IF_GET_PERF_LEVEL_CPU_MASK:\n\t\tret = isst_if_get_perf_level_mask(argp);\n\t\tbreak;\n\tcase ISST_IF_GET_BASE_FREQ_INFO:\n\t\tret = isst_if_get_base_freq_info(argp);\n\t\tbreak;\n\tcase ISST_IF_GET_BASE_FREQ_CPU_MASK:\n\t\tret = isst_if_get_base_freq_mask(argp);\n\t\tbreak;\n\tcase ISST_IF_GET_TURBO_FREQ_INFO:\n\t\tret = isst_if_get_turbo_freq_info(argp);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tmutex_unlock(&isst_tpmi_dev_lock);\n\n\treturn ret;\n}\n\n#define TPMI_SST_AUTO_SUSPEND_DELAY_MS\t2000\n\nint tpmi_sst_dev_add(struct auxiliary_device *auxdev)\n{\n\tstruct intel_tpmi_plat_info *plat_info;\n\tstruct tpmi_sst_struct *tpmi_sst;\n\tint i, ret, pkg = 0, inst = 0;\n\tint num_resources;\n\n\tplat_info = tpmi_get_platform_data(auxdev);\n\tif (!plat_info) {\n\t\tdev_err(&auxdev->dev, \"No platform info\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpkg = plat_info->package_id;\n\tif (pkg >= topology_max_packages()) {\n\t\tdev_err(&auxdev->dev, \"Invalid package id :%x\\n\", pkg);\n\t\treturn -EINVAL;\n\t}\n\n\tif (isst_common.sst_inst[pkg])\n\t\treturn -EEXIST;\n\n\tnum_resources = tpmi_get_resource_count(auxdev);\n\n\tif (!num_resources)\n\t\treturn -EINVAL;\n\n\ttpmi_sst = devm_kzalloc(&auxdev->dev, sizeof(*tpmi_sst), GFP_KERNEL);\n\tif (!tpmi_sst)\n\t\treturn -ENOMEM;\n\n\ttpmi_sst->power_domain_info = devm_kcalloc(&auxdev->dev, num_resources,\n\t\t\t\t\t\t   sizeof(*tpmi_sst->power_domain_info),\n\t\t\t\t\t\t   GFP_KERNEL);\n\tif (!tpmi_sst->power_domain_info)\n\t\treturn -ENOMEM;\n\n\ttpmi_sst->number_of_power_domains = num_resources;\n\n\tfor (i = 0; i < num_resources; ++i) {\n\t\tstruct resource *res;\n\n\t\tres = tpmi_get_resource_at_index(auxdev, i);\n\t\tif (!res) {\n\t\t\ttpmi_sst->power_domain_info[i].sst_base = NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\ttpmi_sst->power_domain_info[i].package_id = pkg;\n\t\ttpmi_sst->power_domain_info[i].power_domain_id = i;\n\t\ttpmi_sst->power_domain_info[i].auxdev = auxdev;\n\t\ttpmi_sst->power_domain_info[i].sst_base = devm_ioremap_resource(&auxdev->dev, res);\n\t\tif (IS_ERR(tpmi_sst->power_domain_info[i].sst_base))\n\t\t\treturn PTR_ERR(tpmi_sst->power_domain_info[i].sst_base);\n\n\t\tret = sst_main(auxdev, &tpmi_sst->power_domain_info[i]);\n\t\tif (ret) {\n\t\t\tdevm_iounmap(&auxdev->dev, tpmi_sst->power_domain_info[i].sst_base);\n\t\t\ttpmi_sst->power_domain_info[i].sst_base =  NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\t++inst;\n\t}\n\n\tif (!inst)\n\t\treturn -ENODEV;\n\n\ttpmi_sst->package_id = pkg;\n\tauxiliary_set_drvdata(auxdev, tpmi_sst);\n\n\tmutex_lock(&isst_tpmi_dev_lock);\n\tif (isst_common.max_index < pkg)\n\t\tisst_common.max_index = pkg;\n\tisst_common.sst_inst[pkg] = tpmi_sst;\n\tmutex_unlock(&isst_tpmi_dev_lock);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_NS_GPL(tpmi_sst_dev_add, INTEL_TPMI_SST);\n\nvoid tpmi_sst_dev_remove(struct auxiliary_device *auxdev)\n{\n\tstruct tpmi_sst_struct *tpmi_sst = auxiliary_get_drvdata(auxdev);\n\n\tmutex_lock(&isst_tpmi_dev_lock);\n\tisst_common.sst_inst[tpmi_sst->package_id] = NULL;\n\tmutex_unlock(&isst_tpmi_dev_lock);\n}\nEXPORT_SYMBOL_NS_GPL(tpmi_sst_dev_remove, INTEL_TPMI_SST);\n\nvoid tpmi_sst_dev_suspend(struct auxiliary_device *auxdev)\n{\n\tstruct tpmi_sst_struct *tpmi_sst = auxiliary_get_drvdata(auxdev);\n\tstruct tpmi_per_power_domain_info *power_domain_info = tpmi_sst->power_domain_info;\n\tvoid __iomem *cp_base;\n\n\tcp_base = power_domain_info->sst_base + power_domain_info->sst_header.cp_offset;\n\tpower_domain_info->saved_sst_cp_control = readq(cp_base + SST_CP_CONTROL_OFFSET);\n\n\tmemcpy_fromio(power_domain_info->saved_clos_configs, cp_base + SST_CLOS_CONFIG_0_OFFSET,\n\t\t      sizeof(power_domain_info->saved_clos_configs));\n\n\tmemcpy_fromio(power_domain_info->saved_clos_assocs, cp_base + SST_CLOS_ASSOC_0_OFFSET,\n\t\t      sizeof(power_domain_info->saved_clos_assocs));\n\n\tpower_domain_info->saved_pp_control = readq(power_domain_info->sst_base +\n\t\t\t\t\t\t    power_domain_info->sst_header.pp_offset +\n\t\t\t\t\t\t    SST_PP_CONTROL_OFFSET);\n}\nEXPORT_SYMBOL_NS_GPL(tpmi_sst_dev_suspend, INTEL_TPMI_SST);\n\nvoid tpmi_sst_dev_resume(struct auxiliary_device *auxdev)\n{\n\tstruct tpmi_sst_struct *tpmi_sst = auxiliary_get_drvdata(auxdev);\n\tstruct tpmi_per_power_domain_info *power_domain_info = tpmi_sst->power_domain_info;\n\tvoid __iomem *cp_base;\n\n\tcp_base = power_domain_info->sst_base + power_domain_info->sst_header.cp_offset;\n\twriteq(power_domain_info->saved_sst_cp_control, cp_base + SST_CP_CONTROL_OFFSET);\n\n\tmemcpy_toio(cp_base + SST_CLOS_CONFIG_0_OFFSET, power_domain_info->saved_clos_configs,\n\t\t    sizeof(power_domain_info->saved_clos_configs));\n\n\tmemcpy_toio(cp_base + SST_CLOS_ASSOC_0_OFFSET, power_domain_info->saved_clos_assocs,\n\t\t    sizeof(power_domain_info->saved_clos_assocs));\n\n\twriteq(power_domain_info->saved_pp_control, power_domain_info->sst_base +\n\t\t\t\tpower_domain_info->sst_header.pp_offset + SST_PP_CONTROL_OFFSET);\n}\nEXPORT_SYMBOL_NS_GPL(tpmi_sst_dev_resume, INTEL_TPMI_SST);\n\n#define ISST_TPMI_API_VERSION\t0x02\n\nint tpmi_sst_init(void)\n{\n\tstruct isst_if_cmd_cb cb;\n\tint ret = 0;\n\n\tmutex_lock(&isst_tpmi_dev_lock);\n\n\tif (isst_core_usage_count) {\n\t\t++isst_core_usage_count;\n\t\tgoto init_done;\n\t}\n\n\tisst_common.sst_inst = kcalloc(topology_max_packages(),\n\t\t\t\t       sizeof(*isst_common.sst_inst),\n\t\t\t\t       GFP_KERNEL);\n\tif (!isst_common.sst_inst) {\n\t\tret = -ENOMEM;\n\t\tgoto init_done;\n\t}\n\n\tmemset(&cb, 0, sizeof(cb));\n\tcb.cmd_size = sizeof(struct isst_if_io_reg);\n\tcb.offset = offsetof(struct isst_if_io_regs, io_reg);\n\tcb.cmd_callback = NULL;\n\tcb.api_version = ISST_TPMI_API_VERSION;\n\tcb.def_ioctl = isst_if_def_ioctl;\n\tcb.owner = THIS_MODULE;\n\tret = isst_if_cdev_register(ISST_IF_DEV_TPMI, &cb);\n\tif (ret)\n\t\tkfree(isst_common.sst_inst);\n\telse\n\t\t++isst_core_usage_count;\ninit_done:\n\tmutex_unlock(&isst_tpmi_dev_lock);\n\treturn ret;\n}\nEXPORT_SYMBOL_NS_GPL(tpmi_sst_init, INTEL_TPMI_SST);\n\nvoid tpmi_sst_exit(void)\n{\n\tmutex_lock(&isst_tpmi_dev_lock);\n\tif (isst_core_usage_count)\n\t\t--isst_core_usage_count;\n\n\tif (!isst_core_usage_count) {\n\t\tisst_if_cdev_unregister(ISST_IF_DEV_TPMI);\n\t\tkfree(isst_common.sst_inst);\n\t}\n\tmutex_unlock(&isst_tpmi_dev_lock);\n}\nEXPORT_SYMBOL_NS_GPL(tpmi_sst_exit, INTEL_TPMI_SST);\n\nMODULE_IMPORT_NS(INTEL_TPMI);\nMODULE_IMPORT_NS(INTEL_TPMI_POWER_DOMAIN);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}