{
  "module_name": "int0002_vgpio.c",
  "hash_id": "337e2b9e9dc8129ea8838fd354ceb776a0731d442c021b74c5a8206c551276ea",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/x86/intel/int0002_vgpio.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/bitmap.h>\n#include <linux/gpio/driver.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/platform_data/x86/soc.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n\n#define DRV_NAME\t\t\t\"INT0002 Virtual GPIO\"\n\n \n#define GPE0A_PME_B0_VIRT_GPIO_PIN\t2\n\n#define GPE0A_PME_B0_STS_BIT\t\tBIT(13)\n#define GPE0A_PME_B0_EN_BIT\t\tBIT(13)\n#define GPE0A_STS_PORT\t\t\t0x420\n#define GPE0A_EN_PORT\t\t\t0x428\n\nstruct int0002_data {\n\tstruct gpio_chip chip;\n\tint parent_irq;\n\tint wake_enable_count;\n};\n\n \n\nstatic int int0002_gpio_get(struct gpio_chip *chip, unsigned int offset)\n{\n\treturn 0;\n}\n\nstatic void int0002_gpio_set(struct gpio_chip *chip, unsigned int offset,\n\t\t\t     int value)\n{\n}\n\nstatic int int0002_gpio_direction_output(struct gpio_chip *chip,\n\t\t\t\t\t unsigned int offset, int value)\n{\n\treturn 0;\n}\n\nstatic void int0002_irq_ack(struct irq_data *data)\n{\n\toutl(GPE0A_PME_B0_STS_BIT, GPE0A_STS_PORT);\n}\n\nstatic void int0002_irq_unmask(struct irq_data *data)\n{\n\tu32 gpe_en_reg;\n\n\tgpe_en_reg = inl(GPE0A_EN_PORT);\n\tgpe_en_reg |= GPE0A_PME_B0_EN_BIT;\n\toutl(gpe_en_reg, GPE0A_EN_PORT);\n}\n\nstatic void int0002_irq_mask(struct irq_data *data)\n{\n\tu32 gpe_en_reg;\n\n\tgpe_en_reg = inl(GPE0A_EN_PORT);\n\tgpe_en_reg &= ~GPE0A_PME_B0_EN_BIT;\n\toutl(gpe_en_reg, GPE0A_EN_PORT);\n}\n\nstatic int int0002_irq_set_wake(struct irq_data *data, unsigned int on)\n{\n\tstruct gpio_chip *chip = irq_data_get_irq_chip_data(data);\n\tstruct int0002_data *int0002 = container_of(chip, struct int0002_data, chip);\n\n\t \n\tif (on)\n\t\tint0002->wake_enable_count++;\n\telse\n\t\tint0002->wake_enable_count--;\n\n\treturn 0;\n}\n\nstatic irqreturn_t int0002_irq(int irq, void *data)\n{\n\tstruct gpio_chip *chip = data;\n\tu32 gpe_sts_reg;\n\n\tgpe_sts_reg = inl(GPE0A_STS_PORT);\n\tif (!(gpe_sts_reg & GPE0A_PME_B0_STS_BIT))\n\t\treturn IRQ_NONE;\n\n\tgeneric_handle_domain_irq_safe(chip->irq.domain, GPE0A_PME_B0_VIRT_GPIO_PIN);\n\n\tpm_wakeup_hard_event(chip->parent);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic bool int0002_check_wake(void *data)\n{\n\tu32 gpe_sts_reg;\n\n\tgpe_sts_reg = inl(GPE0A_STS_PORT);\n\treturn (gpe_sts_reg & GPE0A_PME_B0_STS_BIT);\n}\n\nstatic struct irq_chip int0002_irqchip = {\n\t.name\t\t\t= DRV_NAME,\n\t.irq_ack\t\t= int0002_irq_ack,\n\t.irq_mask\t\t= int0002_irq_mask,\n\t.irq_unmask\t\t= int0002_irq_unmask,\n\t.irq_set_wake\t\t= int0002_irq_set_wake,\n};\n\nstatic void int0002_init_irq_valid_mask(struct gpio_chip *chip,\n\t\t\t\t\tunsigned long *valid_mask,\n\t\t\t\t\tunsigned int ngpios)\n{\n\tbitmap_clear(valid_mask, 0, GPE0A_PME_B0_VIRT_GPIO_PIN);\n}\n\nstatic int int0002_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct int0002_data *int0002;\n\tstruct gpio_irq_chip *girq;\n\tstruct gpio_chip *chip;\n\tint irq, ret;\n\n\t \n\tif (!soc_intel_is_byt() && !soc_intel_is_cht())\n\t\treturn -ENODEV;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tint0002 = devm_kzalloc(dev, sizeof(*int0002), GFP_KERNEL);\n\tif (!int0002)\n\t\treturn -ENOMEM;\n\n\tint0002->parent_irq = irq;\n\n\tchip = &int0002->chip;\n\tchip->label = DRV_NAME;\n\tchip->parent = dev;\n\tchip->owner = THIS_MODULE;\n\tchip->get = int0002_gpio_get;\n\tchip->set = int0002_gpio_set;\n\tchip->direction_input = int0002_gpio_get;\n\tchip->direction_output = int0002_gpio_direction_output;\n\tchip->base = -1;\n\tchip->ngpio = GPE0A_PME_B0_VIRT_GPIO_PIN + 1;\n\tchip->irq.init_valid_mask = int0002_init_irq_valid_mask;\n\n\t \n\tret = devm_request_irq(dev, irq, int0002_irq,\n\t\t\t       IRQF_SHARED, \"INT0002\", chip);\n\tif (ret) {\n\t\tdev_err(dev, \"Error requesting IRQ %d: %d\\n\", irq, ret);\n\t\treturn ret;\n\t}\n\n\tgirq = &chip->irq;\n\tgirq->chip = &int0002_irqchip;\n\t \n\tgirq->parent_handler = NULL;\n\tgirq->num_parents = 0;\n\tgirq->parents = NULL;\n\tgirq->default_type = IRQ_TYPE_NONE;\n\tgirq->handler = handle_edge_irq;\n\n\tret = devm_gpiochip_add_data(dev, chip, NULL);\n\tif (ret) {\n\t\tdev_err(dev, \"Error adding gpio chip: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tacpi_register_wakeup_handler(irq, int0002_check_wake, NULL);\n\tdevice_init_wakeup(dev, true);\n\tdev_set_drvdata(dev, int0002);\n\treturn 0;\n}\n\nstatic void int0002_remove(struct platform_device *pdev)\n{\n\tdevice_init_wakeup(&pdev->dev, false);\n\tacpi_unregister_wakeup_handler(int0002_check_wake, NULL);\n}\n\nstatic int int0002_suspend(struct device *dev)\n{\n\tstruct int0002_data *int0002 = dev_get_drvdata(dev);\n\n\t \n\tif (!pm_suspend_via_firmware() && int0002->wake_enable_count)\n\t\tenable_irq_wake(int0002->parent_irq);\n\n\treturn 0;\n}\n\nstatic int int0002_resume(struct device *dev)\n{\n\tstruct int0002_data *int0002 = dev_get_drvdata(dev);\n\n\tif (!pm_suspend_via_firmware() && int0002->wake_enable_count)\n\t\tdisable_irq_wake(int0002->parent_irq);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops int0002_pm_ops = {\n\t.suspend = int0002_suspend,\n\t.resume = int0002_resume,\n};\n\nstatic const struct acpi_device_id int0002_acpi_ids[] = {\n\t{ \"INT0002\", 0 },\n\t{ },\n};\nMODULE_DEVICE_TABLE(acpi, int0002_acpi_ids);\n\nstatic struct platform_driver int0002_driver = {\n\t.driver = {\n\t\t.name\t\t\t= DRV_NAME,\n\t\t.acpi_match_table\t= int0002_acpi_ids,\n\t\t.pm\t\t\t= &int0002_pm_ops,\n\t},\n\t.probe\t= int0002_probe,\n\t.remove_new = int0002_remove,\n};\n\nmodule_platform_driver(int0002_driver);\n\nMODULE_AUTHOR(\"Hans de Goede <hdegoede@redhat.com>\");\nMODULE_DESCRIPTION(\"Intel INT0002 Virtual GPIO driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}