{
  "module_name": "crystal_cove_charger.c",
  "hash_id": "3f0fcedc346f2216368a8d0f989876b38222bd846a8b57ea3ac0e9e131469414",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/x86/intel/crystal_cove_charger.c",
  "human_readable_source": "\n \n\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/mfd/intel_soc_pmic.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n\n#define CHGRIRQ_REG\t\t\t\t\t0x0a\n#define MCHGRIRQ_REG\t\t\t\t\t0x17\n\nstruct crystal_cove_charger_data {\n\tstruct mutex buslock;  \n\tstruct irq_chip irqchip;\n\tstruct regmap *regmap;\n\tstruct irq_domain *irq_domain;\n\tint irq;\n\tint charger_irq;\n\tu8 mask;\n\tu8 new_mask;\n};\n\nstatic irqreturn_t crystal_cove_charger_irq(int irq, void *data)\n{\n\tstruct crystal_cove_charger_data *charger = data;\n\n\t \n\thandle_nested_irq(charger->charger_irq);\n\n\t \n\tregmap_write(charger->regmap, CHGRIRQ_REG, BIT(0));\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void crystal_cove_charger_irq_bus_lock(struct irq_data *data)\n{\n\tstruct crystal_cove_charger_data *charger = irq_data_get_irq_chip_data(data);\n\n\tmutex_lock(&charger->buslock);\n}\n\nstatic void crystal_cove_charger_irq_bus_sync_unlock(struct irq_data *data)\n{\n\tstruct crystal_cove_charger_data *charger = irq_data_get_irq_chip_data(data);\n\n\tif (charger->mask != charger->new_mask) {\n\t\tregmap_write(charger->regmap, MCHGRIRQ_REG, charger->new_mask);\n\t\tcharger->mask = charger->new_mask;\n\t}\n\n\tmutex_unlock(&charger->buslock);\n}\n\nstatic void crystal_cove_charger_irq_unmask(struct irq_data *data)\n{\n\tstruct crystal_cove_charger_data *charger = irq_data_get_irq_chip_data(data);\n\n\tcharger->new_mask &= ~BIT(data->hwirq);\n}\n\nstatic void crystal_cove_charger_irq_mask(struct irq_data *data)\n{\n\tstruct crystal_cove_charger_data *charger = irq_data_get_irq_chip_data(data);\n\n\tcharger->new_mask |= BIT(data->hwirq);\n}\n\nstatic void crystal_cove_charger_rm_irq_domain(void *data)\n{\n\tstruct crystal_cove_charger_data *charger = data;\n\n\tirq_domain_remove(charger->irq_domain);\n}\n\nstatic int crystal_cove_charger_probe(struct platform_device *pdev)\n{\n\tstruct intel_soc_pmic *pmic = dev_get_drvdata(pdev->dev.parent);\n\tstruct crystal_cove_charger_data *charger;\n\tint ret;\n\n\tcharger = devm_kzalloc(&pdev->dev, sizeof(*charger), GFP_KERNEL);\n\tif (!charger)\n\t\treturn -ENOMEM;\n\n\tcharger->regmap = pmic->regmap;\n\tmutex_init(&charger->buslock);\n\n\tcharger->irq = platform_get_irq(pdev, 0);\n\tif (charger->irq < 0)\n\t\treturn charger->irq;\n\n\tcharger->irq_domain = irq_domain_create_linear(dev_fwnode(pdev->dev.parent), 1,\n\t\t\t\t\t\t       &irq_domain_simple_ops, NULL);\n\tif (!charger->irq_domain)\n\t\treturn -ENOMEM;\n\n\t \n\tirq_domain_update_bus_token(charger->irq_domain, DOMAIN_BUS_WAKEUP);\n\n\tret = devm_add_action_or_reset(&pdev->dev, crystal_cove_charger_rm_irq_domain, charger);\n\tif (ret)\n\t\treturn ret;\n\n\tcharger->charger_irq = irq_create_mapping(charger->irq_domain, 0);\n\tif (!charger->charger_irq)\n\t\treturn -ENOMEM;\n\n\tcharger->irqchip.name = KBUILD_MODNAME;\n\tcharger->irqchip.irq_unmask = crystal_cove_charger_irq_unmask;\n\tcharger->irqchip.irq_mask = crystal_cove_charger_irq_mask;\n\tcharger->irqchip.irq_bus_lock = crystal_cove_charger_irq_bus_lock;\n\tcharger->irqchip.irq_bus_sync_unlock = crystal_cove_charger_irq_bus_sync_unlock;\n\n\tirq_set_chip_data(charger->charger_irq, charger);\n\tirq_set_chip_and_handler(charger->charger_irq, &charger->irqchip, handle_simple_irq);\n\tirq_set_nested_thread(charger->charger_irq, true);\n\tirq_set_noprobe(charger->charger_irq);\n\n\t \n\tcharger->mask = charger->new_mask = BIT(0);\n\tregmap_write(charger->regmap, MCHGRIRQ_REG, charger->mask);\n\n\tret = devm_request_threaded_irq(&pdev->dev, charger->irq, NULL,\n\t\t\t\t\tcrystal_cove_charger_irq,\n\t\t\t\t\tIRQF_ONESHOT, KBUILD_MODNAME, charger);\n\tif (ret)\n\t\treturn dev_err_probe(&pdev->dev, ret, \"requesting irq\\n\");\n\n\treturn 0;\n}\n\nstatic struct platform_driver crystal_cove_charger_driver = {\n\t.probe = crystal_cove_charger_probe,\n\t.driver = {\n\t\t.name = \"crystal_cove_charger\",\n\t},\n};\nmodule_platform_driver(crystal_cove_charger_driver);\n\nMODULE_AUTHOR(\"Hans de Goede <hdegoede@redhat.com\");\nMODULE_DESCRIPTION(\"Intel Bay Trail Crystal Cove external charger IRQ pass-through\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}