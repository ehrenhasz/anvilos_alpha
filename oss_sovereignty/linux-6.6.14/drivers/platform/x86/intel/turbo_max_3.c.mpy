{
  "module_name": "turbo_max_3.c",
  "hash_id": "1d1bcfa9b9878fa3d3cf896d7039e9184cb55b64e8d62ba68bd4877d0e77a000",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/x86/intel/turbo_max_3.c",
  "human_readable_source": "\n \n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/cpufeature.h>\n#include <linux/cpuhotplug.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/topology.h>\n#include <linux/workqueue.h>\n\n#include <asm/cpu_device_id.h>\n#include <asm/intel-family.h>\n\n#define MSR_OC_MAILBOX\t\t\t0x150\n#define MSR_OC_MAILBOX_CMD_OFFSET\t32\n#define MSR_OC_MAILBOX_RSP_OFFSET\t32\n#define MSR_OC_MAILBOX_BUSY_BIT\t\t63\n#define OC_MAILBOX_FC_CONTROL_CMD\t0x1C\n\n \n#define OC_MAILBOX_RETRY_COUNT\t\t2\n\nstatic int get_oc_core_priority(unsigned int cpu)\n{\n\tu64 value, cmd = OC_MAILBOX_FC_CONTROL_CMD;\n\tint ret, i;\n\n\t \n\tvalue = cmd << MSR_OC_MAILBOX_CMD_OFFSET;\n\t \n\tvalue |=  BIT_ULL(MSR_OC_MAILBOX_BUSY_BIT);\n\tret = wrmsrl_safe(MSR_OC_MAILBOX, value);\n\tif (ret) {\n\t\tpr_debug(\"cpu %d OC mailbox write failed\\n\", cpu);\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < OC_MAILBOX_RETRY_COUNT; ++i) {\n\t\tret = rdmsrl_safe(MSR_OC_MAILBOX, &value);\n\t\tif (ret) {\n\t\t\tpr_debug(\"cpu %d OC mailbox read failed\\n\", cpu);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (value & BIT_ULL(MSR_OC_MAILBOX_BUSY_BIT)) {\n\t\t\tpr_debug(\"cpu %d OC mailbox still processing\\n\", cpu);\n\t\t\tret = -EBUSY;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ((value >> MSR_OC_MAILBOX_RSP_OFFSET) & 0xff) {\n\t\t\tpr_debug(\"cpu %d OC mailbox cmd failed\\n\", cpu);\n\t\t\tret = -ENXIO;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = value & 0xff;\n\t\tpr_debug(\"cpu %d max_ratio %d\\n\", cpu, ret);\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\n \nstatic void itmt_legacy_work_fn(struct work_struct *work)\n{\n\tsched_set_itmt_support();\n}\n\nstatic DECLARE_WORK(sched_itmt_work, itmt_legacy_work_fn);\n\nstatic int itmt_legacy_cpu_online(unsigned int cpu)\n{\n\tstatic u32 max_highest_perf = 0, min_highest_perf = U32_MAX;\n\tint priority;\n\n\tpriority = get_oc_core_priority(cpu);\n\tif (priority < 0)\n\t\treturn 0;\n\n\tsched_set_itmt_core_prio(priority, cpu);\n\n\t \n\tif (max_highest_perf <= min_highest_perf) {\n\t\tif (priority > max_highest_perf)\n\t\t\tmax_highest_perf = priority;\n\n\t\tif (priority < min_highest_perf)\n\t\t\tmin_highest_perf = priority;\n\n\t\tif (max_highest_perf > min_highest_perf)\n\t\t\tschedule_work(&sched_itmt_work);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct x86_cpu_id itmt_legacy_cpu_ids[] = {\n\tX86_MATCH_INTEL_FAM6_MODEL(BROADWELL_X,\tNULL),\n\tX86_MATCH_INTEL_FAM6_MODEL(SKYLAKE_X,\tNULL),\n\t{}\n};\n\nstatic int __init itmt_legacy_init(void)\n{\n\tconst struct x86_cpu_id *id;\n\tint ret;\n\n\tid = x86_match_cpu(itmt_legacy_cpu_ids);\n\tif (!id)\n\t\treturn -ENODEV;\n\n\tret = cpuhp_setup_state(CPUHP_AP_ONLINE_DYN,\n\t\t\t\t\"platform/x86/turbo_max_3:online\",\n\t\t\t\titmt_legacy_cpu_online,\tNULL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\nlate_initcall(itmt_legacy_init)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}