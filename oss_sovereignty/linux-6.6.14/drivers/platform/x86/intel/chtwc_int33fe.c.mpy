{
  "module_name": "chtwc_int33fe.c",
  "hash_id": "2f2b3d2aedec57449d69b530bf1ab2e7953df5a1253328316261d0d538e08344",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/x86/intel/chtwc_int33fe.c",
  "human_readable_source": "\n \n\n#include <linux/dmi.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/platform_device.h>\n#include <linux/property.h>\n#include <linux/regulator/consumer.h>\n#include <linux/slab.h>\n#include <linux/usb/pd.h>\n\nstruct cht_int33fe_data {\n\tstruct i2c_client *battery_fg;\n\tstruct i2c_client *fusb302;\n\tstruct i2c_client *pi3usb30532;\n\tstruct fwnode_handle *dp;\n};\n\n \nstatic int cht_int33fe_check_for_max17047(struct device *dev, void *data)\n{\n\tstruct i2c_client **max17047 = data;\n\tstruct acpi_device *adev;\n\n\tadev = ACPI_COMPANION(dev);\n\tif (!adev)\n\t\treturn 0;\n\n\t \n\tif (!acpi_dev_hid_uid_match(adev, \"MAX17047\", NULL))\n\t\treturn 0;\n\n\t*max17047 = to_i2c_client(dev);\n\treturn 1;\n}\n\nstatic const char * const max17047_suppliers[] = { \"bq24190-charger\" };\n\nstatic const struct property_entry max17047_properties[] = {\n\tPROPERTY_ENTRY_STRING_ARRAY(\"supplied-from\", max17047_suppliers),\n\t{ }\n};\n\nstatic const struct software_node max17047_node = {\n\t.name = \"max17047\",\n\t.properties = max17047_properties,\n};\n\n \nstatic struct software_node_ref_args fusb302_mux_refs[] = {\n\t{ .node = NULL },\n};\n\nstatic const struct property_entry fusb302_properties[] = {\n\tPROPERTY_ENTRY_STRING(\"linux,extcon-name\", \"cht_wcove_pwrsrc\"),\n\tPROPERTY_ENTRY_REF_ARRAY(\"usb-role-switch\", fusb302_mux_refs),\n\t{ }\n};\n\nstatic const struct software_node fusb302_node = {\n\t.name = \"fusb302\",\n\t.properties = fusb302_properties,\n};\n\n#define PDO_FIXED_FLAGS \\\n\t(PDO_FIXED_DUAL_ROLE | PDO_FIXED_DATA_SWAP | PDO_FIXED_USB_COMM)\n\nstatic const u32 src_pdo[] = {\n\tPDO_FIXED(5000, 1500, PDO_FIXED_FLAGS),\n};\n\nstatic const u32 snk_pdo[] = {\n\tPDO_FIXED(5000, 400, PDO_FIXED_FLAGS),\n\tPDO_VAR(5000, 12000, 3000),\n};\n\nstatic const struct software_node pi3usb30532_node = {\n\t.name = \"pi3usb30532\",\n};\n\nstatic const struct software_node displayport_node = {\n\t.name = \"displayport\",\n};\n\nstatic const struct property_entry usb_connector_properties[] = {\n\tPROPERTY_ENTRY_STRING(\"data-role\", \"dual\"),\n\tPROPERTY_ENTRY_STRING(\"power-role\", \"dual\"),\n\tPROPERTY_ENTRY_STRING(\"try-power-role\", \"sink\"),\n\tPROPERTY_ENTRY_U32_ARRAY(\"source-pdos\", src_pdo),\n\tPROPERTY_ENTRY_U32_ARRAY(\"sink-pdos\", snk_pdo),\n\tPROPERTY_ENTRY_U32(\"op-sink-microwatt\", 2500000),\n\tPROPERTY_ENTRY_REF(\"orientation-switch\", &pi3usb30532_node),\n\tPROPERTY_ENTRY_REF(\"mode-switch\", &pi3usb30532_node),\n\tPROPERTY_ENTRY_REF(\"displayport\", &displayport_node),\n\t{ }\n};\n\nstatic const struct software_node usb_connector_node = {\n\t.name = \"connector\",\n\t.parent = &fusb302_node,\n\t.properties = usb_connector_properties,\n};\n\nstatic const struct software_node altmodes_node = {\n\t.name = \"altmodes\",\n\t.parent = &usb_connector_node,\n};\n\nstatic const struct property_entry dp_altmode_properties[] = {\n\tPROPERTY_ENTRY_U32(\"svid\", 0xff01),\n\tPROPERTY_ENTRY_U32(\"vdo\", 0x0c0086),\n\t{ }\n};\n\nstatic const struct software_node dp_altmode_node = {\n\t.name = \"displayport-altmode\",\n\t.parent = &altmodes_node,\n\t.properties = dp_altmode_properties,\n};\n\nstatic const struct software_node *node_group[] = {\n\t&fusb302_node,\n\t&max17047_node,\n\t&pi3usb30532_node,\n\t&displayport_node,\n\t&usb_connector_node,\n\t&altmodes_node,\n\t&dp_altmode_node,\n\tNULL\n};\n\nstatic int cht_int33fe_setup_dp(struct cht_int33fe_data *data)\n{\n\tstruct fwnode_handle *fwnode;\n\tstruct pci_dev *pdev;\n\n\tfwnode = software_node_fwnode(&displayport_node);\n\tif (!fwnode)\n\t\treturn -ENODEV;\n\n\t \n\tpdev = pci_get_class(PCI_CLASS_DISPLAY_VGA << 8, NULL);\n\tif (!pdev || pdev->vendor != PCI_VENDOR_ID_INTEL) {\n\t\tpci_dev_put(pdev);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tdata->dp = device_get_named_child_node(&pdev->dev, \"DD04\");\n\tpci_dev_put(pdev);\n\tif (!data->dp)\n\t\treturn -ENODEV;\n\n\tfwnode->secondary = ERR_PTR(-ENODEV);\n\tdata->dp->secondary = fwnode;\n\n\treturn 0;\n}\n\nstatic void cht_int33fe_remove_nodes(struct cht_int33fe_data *data)\n{\n\tsoftware_node_unregister_node_group(node_group);\n\n\tif (fusb302_mux_refs[0].node) {\n\t\tfwnode_handle_put(software_node_fwnode(fusb302_mux_refs[0].node));\n\t\tfusb302_mux_refs[0].node = NULL;\n\t}\n\n\tif (data->dp) {\n\t\tdata->dp->secondary = NULL;\n\t\tfwnode_handle_put(data->dp);\n\t\tdata->dp = NULL;\n\t}\n}\n\nstatic int cht_int33fe_add_nodes(struct cht_int33fe_data *data)\n{\n\tconst struct software_node *mux_ref_node;\n\tint ret;\n\n\t \n\tmux_ref_node = software_node_find_by_name(NULL, \"intel-xhci-usb-sw\");\n\tif (!mux_ref_node)\n\t\treturn -EPROBE_DEFER;\n\n\t \n\tfusb302_mux_refs[0].node = mux_ref_node;\n\n\tret = software_node_register_node_group(node_group);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\n\t \n\tret = cht_int33fe_setup_dp(data);\n\tif (ret)\n\t\tgoto err_remove_nodes;\n\n\treturn 0;\n\nerr_remove_nodes:\n\tcht_int33fe_remove_nodes(data);\n\n\treturn ret;\n}\n\nstatic int\ncht_int33fe_register_max17047(struct device *dev, struct cht_int33fe_data *data)\n{\n\tstruct i2c_client *max17047 = NULL;\n\tstruct i2c_board_info board_info;\n\tstruct fwnode_handle *fwnode;\n\tint ret;\n\n\tfwnode = software_node_fwnode(&max17047_node);\n\tif (!fwnode)\n\t\treturn -ENODEV;\n\n\ti2c_for_each_dev(&max17047, cht_int33fe_check_for_max17047);\n\tif (max17047) {\n\t\t \n\t\tset_secondary_fwnode(&max17047->dev, fwnode);\n\t\t \n\t\tret = device_reprobe(&max17047->dev);\n\t\tif (ret)\n\t\t\tdev_warn(dev, \"Reprobing max17047 error: %d\\n\", ret);\n\t\treturn 0;\n\t}\n\n\tmemset(&board_info, 0, sizeof(board_info));\n\tstrscpy(board_info.type, \"max17047\", I2C_NAME_SIZE);\n\tboard_info.dev_name = \"max17047\";\n\tboard_info.fwnode = fwnode;\n\tdata->battery_fg = i2c_acpi_new_device(dev, 1, &board_info);\n\n\treturn PTR_ERR_OR_ZERO(data->battery_fg);\n}\n\nstatic const struct dmi_system_id cht_int33fe_typec_ids[] = {\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_EXACT_MATCH(DMI_BOARD_VENDOR, \"AMI Corporation\"),\n\t\t\tDMI_EXACT_MATCH(DMI_BOARD_NAME, \"Default string\"),\n\t\t\tDMI_EXACT_MATCH(DMI_BOARD_SERIAL, \"Default string\"),\n\t\t\tDMI_EXACT_MATCH(DMI_PRODUCT_NAME, \"Default string\"),\n\t\t},\n\t},\n\t{ }\n};\nMODULE_DEVICE_TABLE(dmi, cht_int33fe_typec_ids);\n\nstatic int cht_int33fe_typec_probe(struct platform_device *pdev)\n{\n\tstruct i2c_board_info board_info;\n\tstruct device *dev = &pdev->dev;\n\tstruct cht_int33fe_data *data;\n\tstruct fwnode_handle *fwnode;\n\tstruct regulator *regulator;\n\tint fusb302_irq;\n\tint ret;\n\n\tif (!dmi_check_system(cht_int33fe_typec_ids))\n\t\treturn -ENODEV;\n\n\tdata = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\t \n\tregulator = regulator_get_optional(dev, \"cht_wc_usb_typec_vbus\");\n\tif (IS_ERR(regulator)) {\n\t\tret = PTR_ERR(regulator);\n\t\treturn (ret == -ENODEV) ? -EPROBE_DEFER : ret;\n\t}\n\tregulator_put(regulator);\n\n\t \n\tfusb302_irq = acpi_dev_gpio_irq_get(ACPI_COMPANION(dev), 1);\n\tif (fusb302_irq < 0) {\n\t\tif (fusb302_irq != -EPROBE_DEFER)\n\t\t\tdev_err(dev, \"Error getting FUSB302 irq\\n\");\n\t\treturn fusb302_irq;\n\t}\n\n\tret = cht_int33fe_add_nodes(data);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = cht_int33fe_register_max17047(dev, data);\n\tif (ret)\n\t\tgoto out_remove_nodes;\n\n\tfwnode = software_node_fwnode(&fusb302_node);\n\tif (!fwnode) {\n\t\tret = -ENODEV;\n\t\tgoto out_unregister_max17047;\n\t}\n\n\tmemset(&board_info, 0, sizeof(board_info));\n\tstrscpy(board_info.type, \"typec_fusb302\", I2C_NAME_SIZE);\n\tboard_info.dev_name = \"fusb302\";\n\tboard_info.fwnode = fwnode;\n\tboard_info.irq = fusb302_irq;\n\n\tdata->fusb302 = i2c_acpi_new_device(dev, 2, &board_info);\n\tif (IS_ERR(data->fusb302)) {\n\t\tret = PTR_ERR(data->fusb302);\n\t\tgoto out_unregister_max17047;\n\t}\n\n\tfwnode = software_node_fwnode(&pi3usb30532_node);\n\tif (!fwnode) {\n\t\tret = -ENODEV;\n\t\tgoto out_unregister_fusb302;\n\t}\n\n\tmemset(&board_info, 0, sizeof(board_info));\n\tboard_info.dev_name = \"pi3usb30532\";\n\tboard_info.fwnode = fwnode;\n\tstrscpy(board_info.type, \"pi3usb30532\", I2C_NAME_SIZE);\n\n\tdata->pi3usb30532 = i2c_acpi_new_device(dev, 3, &board_info);\n\tif (IS_ERR(data->pi3usb30532)) {\n\t\tret = PTR_ERR(data->pi3usb30532);\n\t\tgoto out_unregister_fusb302;\n\t}\n\n\tplatform_set_drvdata(pdev, data);\n\n\treturn 0;\n\nout_unregister_fusb302:\n\ti2c_unregister_device(data->fusb302);\n\nout_unregister_max17047:\n\ti2c_unregister_device(data->battery_fg);\n\nout_remove_nodes:\n\tcht_int33fe_remove_nodes(data);\n\n\treturn ret;\n}\n\nstatic void cht_int33fe_typec_remove(struct platform_device *pdev)\n{\n\tstruct cht_int33fe_data *data = platform_get_drvdata(pdev);\n\n\ti2c_unregister_device(data->pi3usb30532);\n\ti2c_unregister_device(data->fusb302);\n\ti2c_unregister_device(data->battery_fg);\n\n\tcht_int33fe_remove_nodes(data);\n}\n\nstatic const struct acpi_device_id cht_int33fe_acpi_ids[] = {\n\t{ \"INT33FE\", },\n\t{ }\n};\n\nstatic struct platform_driver cht_int33fe_typec_driver = {\n\t.driver\t= {\n\t\t.name = \"Intel Cherry Trail ACPI INT33FE Type-C driver\",\n\t\t.acpi_match_table = ACPI_PTR(cht_int33fe_acpi_ids),\n\t},\n\t.probe = cht_int33fe_typec_probe,\n\t.remove_new = cht_int33fe_typec_remove,\n};\n\nmodule_platform_driver(cht_int33fe_typec_driver);\n\nMODULE_DESCRIPTION(\"Intel Cherry Trail ACPI INT33FE Type-C pseudo device driver\");\nMODULE_AUTHOR(\"Hans de Goede <hdegoede@redhat.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}