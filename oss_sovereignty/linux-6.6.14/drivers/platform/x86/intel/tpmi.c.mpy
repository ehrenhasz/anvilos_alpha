{
  "module_name": "tpmi.c",
  "hash_id": "6ab560909f620a5ce4bef1238c0262a0cfa7080bb7142f3e98e70f9a7f3cca6d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/x86/intel/tpmi.c",
  "human_readable_source": "\n \n\n#include <linux/auxiliary_bus.h>\n#include <linux/bitfield.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/intel_tpmi.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/security.h>\n#include <linux/sizes.h>\n#include <linux/string_helpers.h>\n\n#include \"vsec.h\"\n\n \nstruct intel_tpmi_pfs_entry {\n\tu64 tpmi_id:8;\n\tu64 num_entries:8;\n\tu64 entry_size:16;\n\tu64 cap_offset:16;\n\tu64 attribute:2;\n\tu64 reserved:14;\n} __packed;\n\n \nstruct intel_tpmi_pm_feature {\n\tstruct intel_tpmi_pfs_entry pfs_header;\n\tunsigned int vsec_offset;\n\tstruct intel_vsec_device *vsec_dev;\n};\n\n \nstruct intel_tpmi_info {\n\tstruct intel_tpmi_pm_feature *tpmi_features;\n\tstruct intel_vsec_device *vsec_dev;\n\tint feature_count;\n\tu64 pfs_start;\n\tstruct intel_tpmi_plat_info plat_info;\n\tvoid __iomem *tpmi_control_mem;\n\tstruct dentry *dbgfs_dir;\n};\n\n \nstruct tpmi_info_header {\n\tu64 fn:3;\n\tu64 dev:5;\n\tu64 bus:8;\n\tu64 pkg:8;\n\tu64 reserved:39;\n\tu64 lock:1;\n} __packed;\n\n \nenum intel_tpmi_id {\n\tTPMI_ID_RAPL = 0,  \n\tTPMI_ID_PEM = 1,  \n\tTPMI_ID_UNCORE = 2,  \n\tTPMI_ID_SST = 5,  \n\tTPMI_CONTROL_ID = 0x80,  \n\tTPMI_INFO_ID = 0x81,  \n};\n\n \n#define TPMI_GET_SINGLE_ENTRY_SIZE(pfs)\t\t\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\t\t\\\n\tpfs->pfs_header.entry_size > SZ_1K ? 0 : pfs->pfs_header.entry_size << 2;\t\\\n})\n\n \nstatic DEFINE_IDA(intel_vsec_tpmi_ida);\n\nstruct intel_tpmi_plat_info *tpmi_get_platform_data(struct auxiliary_device *auxdev)\n{\n\tstruct intel_vsec_device *vsec_dev = auxdev_to_ivdev(auxdev);\n\n\treturn vsec_dev->priv_data;\n}\nEXPORT_SYMBOL_NS_GPL(tpmi_get_platform_data, INTEL_TPMI);\n\nint tpmi_get_resource_count(struct auxiliary_device *auxdev)\n{\n\tstruct intel_vsec_device *vsec_dev = auxdev_to_ivdev(auxdev);\n\n\tif (vsec_dev)\n\t\treturn vsec_dev->num_resources;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_NS_GPL(tpmi_get_resource_count, INTEL_TPMI);\n\nstruct resource *tpmi_get_resource_at_index(struct auxiliary_device *auxdev, int index)\n{\n\tstruct intel_vsec_device *vsec_dev = auxdev_to_ivdev(auxdev);\n\n\tif (vsec_dev && index < vsec_dev->num_resources)\n\t\treturn &vsec_dev->resource[index];\n\n\treturn NULL;\n}\nEXPORT_SYMBOL_NS_GPL(tpmi_get_resource_at_index, INTEL_TPMI);\n\n \n\n#define TPMI_CONTROL_STATUS_OFFSET\t0x00\n#define TPMI_COMMAND_OFFSET\t\t0x08\n\n \n#define TPMI_CONTROL_TIMEOUT_US\t\t(10 * USEC_PER_MSEC)\n#define TPMI_CONTROL_TIMEOUT_MAX_US\t(1 * USEC_PER_SEC)\n\n#define TPMI_RB_TIMEOUT_US\t\t(10 * USEC_PER_MSEC)\n#define TPMI_RB_TIMEOUT_MAX_US\t\tUSEC_PER_SEC\n\n \n\n#define TPMI_CONTROL_STATUS_RB\t\tBIT_ULL(0)\n\n#define TPMI_CONTROL_STATUS_OWNER\tGENMASK_ULL(5, 4)\n#define TPMI_OWNER_NONE\t\t\t0\n#define TPMI_OWNER_IN_BAND\t\t1\n\n#define TPMI_CONTROL_STATUS_CPL\t\tBIT_ULL(6)\n#define TPMI_CONTROL_STATUS_RESULT\tGENMASK_ULL(15, 8)\n#define TPMI_CONTROL_STATUS_LEN\t\tGENMASK_ULL(31, 16)\n\n#define TPMI_CMD_PKT_LEN\t\t2\n#define TPMI_CMD_STATUS_SUCCESS\t\t0x40\n\n \n#define TMPI_CONTROL_DATA_CMD\t\tGENMASK_ULL(7, 0)\n#define TMPI_CONTROL_DATA_VAL\t\tGENMASK_ULL(63, 32)\n#define TPMI_CONTROL_DATA_VAL_FEATURE\tGENMASK_ULL(48, 40)\n\n \n#define TPMI_CONTROL_GET_STATE_CMD\t0x10\n\n#define TPMI_CONTROL_CMD_MASK\t\tGENMASK_ULL(48, 40)\n\n#define TPMI_CMD_LEN_MASK\t\tGENMASK_ULL(18, 16)\n\n#define TPMI_STATE_DISABLED\t\tBIT_ULL(0)\n#define TPMI_STATE_LOCKED\t\tBIT_ULL(31)\n\n \nstatic DEFINE_MUTEX(tpmi_dev_lock);\n\nstatic int tpmi_wait_for_owner(struct intel_tpmi_info *tpmi_info, u8 owner)\n{\n\tu64 control;\n\n\treturn readq_poll_timeout(tpmi_info->tpmi_control_mem + TPMI_CONTROL_STATUS_OFFSET,\n\t\t\t\t  control, owner == FIELD_GET(TPMI_CONTROL_STATUS_OWNER, control),\n\t\t\t\t  TPMI_CONTROL_TIMEOUT_US, TPMI_CONTROL_TIMEOUT_MAX_US);\n}\n\nstatic int tpmi_read_feature_status(struct intel_tpmi_info *tpmi_info, int feature_id,\n\t\t\t\t    int *locked, int *disabled)\n{\n\tu64 control, data;\n\tint ret;\n\n\tif (!tpmi_info->tpmi_control_mem)\n\t\treturn -EFAULT;\n\n\tmutex_lock(&tpmi_dev_lock);\n\n\t \n\tret = tpmi_wait_for_owner(tpmi_info, TPMI_OWNER_NONE);\n\tif (ret)\n\t\tgoto err_unlock;\n\n\t \n\tdata = FIELD_PREP(TMPI_CONTROL_DATA_CMD, TPMI_CONTROL_GET_STATE_CMD);\n\n\t \n\tdata |= FIELD_PREP(TPMI_CONTROL_DATA_VAL_FEATURE, feature_id);\n\n\t \n\twriteq(data, tpmi_info->tpmi_control_mem + TPMI_COMMAND_OFFSET);\n\n\t \n\tret = tpmi_wait_for_owner(tpmi_info, TPMI_OWNER_IN_BAND);\n\tif (ret)\n\t\tgoto err_unlock;\n\n\t \n\tcontrol = TPMI_CONTROL_STATUS_RB;\n\tcontrol |= FIELD_PREP(TPMI_CONTROL_STATUS_LEN, TPMI_CMD_PKT_LEN);\n\n\t \n\twriteq(control, tpmi_info->tpmi_control_mem + TPMI_CONTROL_STATUS_OFFSET);\n\n\t \n\tret = readq_poll_timeout(tpmi_info->tpmi_control_mem + TPMI_CONTROL_STATUS_OFFSET,\n\t\t\t\t control, !(control & TPMI_CONTROL_STATUS_RB),\n\t\t\t\t TPMI_RB_TIMEOUT_US, TPMI_RB_TIMEOUT_MAX_US);\n\tif (ret)\n\t\tgoto done_proc;\n\n\tcontrol = FIELD_GET(TPMI_CONTROL_STATUS_RESULT, control);\n\tif (control != TPMI_CMD_STATUS_SUCCESS) {\n\t\tret = -EBUSY;\n\t\tgoto done_proc;\n\t}\n\n\t \n\tdata = readq(tpmi_info->tpmi_control_mem + TPMI_COMMAND_OFFSET);\n\tdata = FIELD_GET(TMPI_CONTROL_DATA_VAL, data);\n\n\t*disabled = 0;\n\t*locked = 0;\n\n\tif (!(data & TPMI_STATE_DISABLED))\n\t\t*disabled = 1;\n\n\tif (data & TPMI_STATE_LOCKED)\n\t\t*locked = 1;\n\n\tret = 0;\n\ndone_proc:\n\t \n\twriteq(TPMI_CONTROL_STATUS_CPL, tpmi_info->tpmi_control_mem + TPMI_CONTROL_STATUS_OFFSET);\n\nerr_unlock:\n\tmutex_unlock(&tpmi_dev_lock);\n\n\treturn ret;\n}\n\nint tpmi_get_feature_status(struct auxiliary_device *auxdev, int feature_id,\n\t\t\t    int *locked, int *disabled)\n{\n\tstruct intel_vsec_device *intel_vsec_dev = dev_to_ivdev(auxdev->dev.parent);\n\tstruct intel_tpmi_info *tpmi_info = auxiliary_get_drvdata(&intel_vsec_dev->auxdev);\n\n\treturn tpmi_read_feature_status(tpmi_info, feature_id, locked, disabled);\n}\nEXPORT_SYMBOL_NS_GPL(tpmi_get_feature_status, INTEL_TPMI);\n\nstatic int tpmi_pfs_dbg_show(struct seq_file *s, void *unused)\n{\n\tstruct intel_tpmi_info *tpmi_info = s->private;\n\tstruct intel_tpmi_pm_feature *pfs;\n\tint locked, disabled, ret, i;\n\n\tseq_printf(s, \"tpmi PFS start offset 0x:%llx\\n\", tpmi_info->pfs_start);\n\tseq_puts(s, \"tpmi_id\\t\\tentries\\t\\tsize\\t\\tcap_offset\\tattribute\\tvsec_offset\\tlocked\\tdisabled\\n\");\n\tfor (i = 0; i < tpmi_info->feature_count; ++i) {\n\t\tpfs = &tpmi_info->tpmi_features[i];\n\t\tret = tpmi_read_feature_status(tpmi_info, pfs->pfs_header.tpmi_id, &locked,\n\t\t\t\t\t       &disabled);\n\t\tif (ret) {\n\t\t\tlocked = 'U';\n\t\t\tdisabled = 'U';\n\t\t} else {\n\t\t\tdisabled = disabled ? 'Y' : 'N';\n\t\t\tlocked = locked ? 'Y' : 'N';\n\t\t}\n\t\tseq_printf(s, \"0x%02x\\t\\t0x%02x\\t\\t0x%04x\\t\\t0x%04x\\t\\t0x%02x\\t\\t0x%08x\\t%c\\t%c\\n\",\n\t\t\t   pfs->pfs_header.tpmi_id, pfs->pfs_header.num_entries,\n\t\t\t   pfs->pfs_header.entry_size, pfs->pfs_header.cap_offset,\n\t\t\t   pfs->pfs_header.attribute, pfs->vsec_offset, locked, disabled);\n\t}\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(tpmi_pfs_dbg);\n\n#define MEM_DUMP_COLUMN_COUNT\t8\n\nstatic int tpmi_mem_dump_show(struct seq_file *s, void *unused)\n{\n\tsize_t row_size = MEM_DUMP_COLUMN_COUNT * sizeof(u32);\n\tstruct intel_tpmi_pm_feature *pfs = s->private;\n\tint count, ret = 0;\n\tvoid __iomem *mem;\n\tu32 off, size;\n\tu8 *buffer;\n\n\tsize = TPMI_GET_SINGLE_ENTRY_SIZE(pfs);\n\tif (!size)\n\t\treturn -EIO;\n\n\tbuffer = kmalloc(size, GFP_KERNEL);\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\n\toff = pfs->vsec_offset;\n\n\tmutex_lock(&tpmi_dev_lock);\n\n\tfor (count = 0; count < pfs->pfs_header.num_entries; ++count) {\n\t\tseq_printf(s, \"TPMI Instance:%d offset:0x%x\\n\", count, off);\n\n\t\tmem = ioremap(off, size);\n\t\tif (!mem) {\n\t\t\tret = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\tmemcpy_fromio(buffer, mem, size);\n\n\t\tseq_hex_dump(s, \" \", DUMP_PREFIX_OFFSET, row_size, sizeof(u32), buffer, size,\n\t\t\t     false);\n\n\t\tiounmap(mem);\n\n\t\toff += size;\n\t}\n\n\tmutex_unlock(&tpmi_dev_lock);\n\n\tkfree(buffer);\n\n\treturn ret;\n}\nDEFINE_SHOW_ATTRIBUTE(tpmi_mem_dump);\n\nstatic ssize_t mem_write(struct file *file, const char __user *userbuf, size_t len, loff_t *ppos)\n{\n\tstruct seq_file *m = file->private_data;\n\tstruct intel_tpmi_pm_feature *pfs = m->private;\n\tu32 addr, value, punit, size;\n\tu32 num_elems, *array;\n\tvoid __iomem *mem;\n\tint ret;\n\n\tsize = TPMI_GET_SINGLE_ENTRY_SIZE(pfs);\n\tif (!size)\n\t\treturn -EIO;\n\n\tret = parse_int_array_user(userbuf, len, (int **)&array);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tnum_elems = *array;\n\tif (num_elems != 3) {\n\t\tret = -EINVAL;\n\t\tgoto exit_write;\n\t}\n\n\tpunit = array[1];\n\taddr = array[2];\n\tvalue = array[3];\n\n\tif (punit >= pfs->pfs_header.num_entries) {\n\t\tret = -EINVAL;\n\t\tgoto exit_write;\n\t}\n\n\tif (addr >= size) {\n\t\tret = -EINVAL;\n\t\tgoto exit_write;\n\t}\n\n\tmutex_lock(&tpmi_dev_lock);\n\n\tmem = ioremap(pfs->vsec_offset + punit * size, size);\n\tif (!mem) {\n\t\tret = -ENOMEM;\n\t\tgoto unlock_mem_write;\n\t}\n\n\twritel(value, mem + addr);\n\n\tiounmap(mem);\n\n\tret = len;\n\nunlock_mem_write:\n\tmutex_unlock(&tpmi_dev_lock);\n\nexit_write:\n\tkfree(array);\n\n\treturn ret;\n}\n\nstatic int mem_write_show(struct seq_file *s, void *unused)\n{\n\treturn 0;\n}\n\nstatic int mem_write_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, mem_write_show, inode->i_private);\n}\n\nstatic const struct file_operations mem_write_ops = {\n\t.open           = mem_write_open,\n\t.read           = seq_read,\n\t.write          = mem_write,\n\t.llseek         = seq_lseek,\n\t.release        = single_release,\n};\n\n#define tpmi_to_dev(info)\t(&info->vsec_dev->pcidev->dev)\n\nstatic void tpmi_dbgfs_register(struct intel_tpmi_info *tpmi_info)\n{\n\tchar name[64];\n\tint i;\n\n\tsnprintf(name, sizeof(name), \"tpmi-%s\", dev_name(tpmi_to_dev(tpmi_info)));\n\ttpmi_info->dbgfs_dir = debugfs_create_dir(name, NULL);\n\n\tdebugfs_create_file(\"pfs_dump\", 0444, tpmi_info->dbgfs_dir, tpmi_info, &tpmi_pfs_dbg_fops);\n\n\tfor (i = 0; i < tpmi_info->feature_count; ++i) {\n\t\tstruct intel_tpmi_pm_feature *pfs;\n\t\tstruct dentry *dir;\n\n\t\tpfs = &tpmi_info->tpmi_features[i];\n\t\tsnprintf(name, sizeof(name), \"tpmi-id-%02x\", pfs->pfs_header.tpmi_id);\n\t\tdir = debugfs_create_dir(name, tpmi_info->dbgfs_dir);\n\n\t\tdebugfs_create_file(\"mem_dump\", 0444, dir, pfs, &tpmi_mem_dump_fops);\n\t\tdebugfs_create_file(\"mem_write\", 0644, dir, pfs, &mem_write_ops);\n\t}\n}\n\nstatic void tpmi_set_control_base(struct auxiliary_device *auxdev,\n\t\t\t\t  struct intel_tpmi_info *tpmi_info,\n\t\t\t\t  struct intel_tpmi_pm_feature *pfs)\n{\n\tvoid __iomem *mem;\n\tu32 size;\n\n\tsize = TPMI_GET_SINGLE_ENTRY_SIZE(pfs);\n\tif (!size)\n\t\treturn;\n\n\tmem = devm_ioremap(&auxdev->dev, pfs->vsec_offset, size);\n\tif (!mem)\n\t\treturn;\n\n\t \n\ttpmi_info->tpmi_control_mem = mem;\n}\n\nstatic const char *intel_tpmi_name(enum intel_tpmi_id id)\n{\n\tswitch (id) {\n\tcase TPMI_ID_RAPL:\n\t\treturn \"rapl\";\n\tcase TPMI_ID_PEM:\n\t\treturn \"pem\";\n\tcase TPMI_ID_UNCORE:\n\t\treturn \"uncore\";\n\tcase TPMI_ID_SST:\n\t\treturn \"sst\";\n\tdefault:\n\t\treturn NULL;\n\t}\n}\n\n \n#define TPMI_FEATURE_NAME_LEN\t14\n\nstatic int tpmi_create_device(struct intel_tpmi_info *tpmi_info,\n\t\t\t      struct intel_tpmi_pm_feature *pfs,\n\t\t\t      u64 pfs_start)\n{\n\tstruct intel_vsec_device *vsec_dev = tpmi_info->vsec_dev;\n\tchar feature_id_name[TPMI_FEATURE_NAME_LEN];\n\tstruct intel_vsec_device *feature_vsec_dev;\n\tstruct resource *res, *tmp;\n\tconst char *name;\n\tint i;\n\n\tname = intel_tpmi_name(pfs->pfs_header.tpmi_id);\n\tif (!name)\n\t\treturn -EOPNOTSUPP;\n\n\tres = kcalloc(pfs->pfs_header.num_entries, sizeof(*res), GFP_KERNEL);\n\tif (!res)\n\t\treturn -ENOMEM;\n\n\tfeature_vsec_dev = kzalloc(sizeof(*feature_vsec_dev), GFP_KERNEL);\n\tif (!feature_vsec_dev) {\n\t\tkfree(res);\n\t\treturn -ENOMEM;\n\t}\n\n\tsnprintf(feature_id_name, sizeof(feature_id_name), \"tpmi-%s\", name);\n\n\tfor (i = 0, tmp = res; i < pfs->pfs_header.num_entries; i++, tmp++) {\n\t\tu64 entry_size_bytes = pfs->pfs_header.entry_size * sizeof(u32);\n\n\t\ttmp->start = pfs->vsec_offset + entry_size_bytes * i;\n\t\ttmp->end = tmp->start + entry_size_bytes - 1;\n\t\ttmp->flags = IORESOURCE_MEM;\n\t}\n\n\tfeature_vsec_dev->pcidev = vsec_dev->pcidev;\n\tfeature_vsec_dev->resource = res;\n\tfeature_vsec_dev->num_resources = pfs->pfs_header.num_entries;\n\tfeature_vsec_dev->priv_data = &tpmi_info->plat_info;\n\tfeature_vsec_dev->priv_data_size = sizeof(tpmi_info->plat_info);\n\tfeature_vsec_dev->ida = &intel_vsec_tpmi_ida;\n\n\t \n\treturn intel_vsec_add_aux(vsec_dev->pcidev, &vsec_dev->auxdev.dev,\n\t\t\t\t  feature_vsec_dev, feature_id_name);\n}\n\nstatic int tpmi_create_devices(struct intel_tpmi_info *tpmi_info)\n{\n\tstruct intel_vsec_device *vsec_dev = tpmi_info->vsec_dev;\n\tint ret, i;\n\n\tfor (i = 0; i < vsec_dev->num_resources; i++) {\n\t\tret = tpmi_create_device(tpmi_info, &tpmi_info->tpmi_features[i],\n\t\t\t\t\t tpmi_info->pfs_start);\n\t\t \n\t\tif (ret && ret != -EOPNOTSUPP)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n#define TPMI_INFO_BUS_INFO_OFFSET\t0x08\n\nstatic int tpmi_process_info(struct intel_tpmi_info *tpmi_info,\n\t\t\t     struct intel_tpmi_pm_feature *pfs)\n{\n\tstruct tpmi_info_header header;\n\tvoid __iomem *info_mem;\n\n\tinfo_mem = ioremap(pfs->vsec_offset + TPMI_INFO_BUS_INFO_OFFSET,\n\t\t\t   pfs->pfs_header.entry_size * sizeof(u32) - TPMI_INFO_BUS_INFO_OFFSET);\n\tif (!info_mem)\n\t\treturn -ENOMEM;\n\n\tmemcpy_fromio(&header, info_mem, sizeof(header));\n\n\ttpmi_info->plat_info.package_id = header.pkg;\n\ttpmi_info->plat_info.bus_number = header.bus;\n\ttpmi_info->plat_info.device_number = header.dev;\n\ttpmi_info->plat_info.function_number = header.fn;\n\n\tiounmap(info_mem);\n\n\treturn 0;\n}\n\nstatic int tpmi_fetch_pfs_header(struct intel_tpmi_pm_feature *pfs, u64 start, int size)\n{\n\tvoid __iomem *pfs_mem;\n\n\tpfs_mem = ioremap(start, size);\n\tif (!pfs_mem)\n\t\treturn -ENOMEM;\n\n\tmemcpy_fromio(&pfs->pfs_header, pfs_mem, sizeof(pfs->pfs_header));\n\n\tiounmap(pfs_mem);\n\n\treturn 0;\n}\n\n#define TPMI_CAP_OFFSET_UNIT\t1024\n\nstatic int intel_vsec_tpmi_init(struct auxiliary_device *auxdev)\n{\n\tstruct intel_vsec_device *vsec_dev = auxdev_to_ivdev(auxdev);\n\tstruct pci_dev *pci_dev = vsec_dev->pcidev;\n\tstruct intel_tpmi_info *tpmi_info;\n\tu64 pfs_start = 0;\n\tint ret, i;\n\n\ttpmi_info = devm_kzalloc(&auxdev->dev, sizeof(*tpmi_info), GFP_KERNEL);\n\tif (!tpmi_info)\n\t\treturn -ENOMEM;\n\n\ttpmi_info->vsec_dev = vsec_dev;\n\ttpmi_info->feature_count = vsec_dev->num_resources;\n\ttpmi_info->plat_info.bus_number = pci_dev->bus->number;\n\n\ttpmi_info->tpmi_features = devm_kcalloc(&auxdev->dev, vsec_dev->num_resources,\n\t\t\t\t\t\tsizeof(*tpmi_info->tpmi_features),\n\t\t\t\t\t\tGFP_KERNEL);\n\tif (!tpmi_info->tpmi_features)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < vsec_dev->num_resources; i++) {\n\t\tstruct intel_tpmi_pm_feature *pfs;\n\t\tstruct resource *res;\n\t\tu64 res_start;\n\t\tint size, ret;\n\n\t\tpfs = &tpmi_info->tpmi_features[i];\n\t\tpfs->vsec_dev = vsec_dev;\n\n\t\tres = &vsec_dev->resource[i];\n\t\tif (!res)\n\t\t\tcontinue;\n\n\t\tres_start = res->start;\n\t\tsize = resource_size(res);\n\t\tif (size < 0)\n\t\t\tcontinue;\n\n\t\tret = tpmi_fetch_pfs_header(pfs, res_start, size);\n\t\tif (ret)\n\t\t\tcontinue;\n\n\t\tif (!pfs_start)\n\t\t\tpfs_start = res_start;\n\n\t\tpfs->vsec_offset = pfs_start + pfs->pfs_header.cap_offset * TPMI_CAP_OFFSET_UNIT;\n\n\t\t \n\t\tif (pfs->pfs_header.tpmi_id == TPMI_INFO_ID)\n\t\t\ttpmi_process_info(tpmi_info, pfs);\n\n\t\tif (pfs->pfs_header.tpmi_id == TPMI_CONTROL_ID)\n\t\t\ttpmi_set_control_base(auxdev, tpmi_info, pfs);\n\t}\n\n\ttpmi_info->pfs_start = pfs_start;\n\n\tauxiliary_set_drvdata(auxdev, tpmi_info);\n\n\tret = tpmi_create_devices(tpmi_info);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (!security_locked_down(LOCKDOWN_DEV_MEM) && capable(CAP_SYS_RAWIO))\n\t\ttpmi_dbgfs_register(tpmi_info);\n\n\treturn 0;\n}\n\nstatic int tpmi_probe(struct auxiliary_device *auxdev,\n\t\t      const struct auxiliary_device_id *id)\n{\n\treturn intel_vsec_tpmi_init(auxdev);\n}\n\nstatic void tpmi_remove(struct auxiliary_device *auxdev)\n{\n\tstruct intel_tpmi_info *tpmi_info = auxiliary_get_drvdata(auxdev);\n\n\tdebugfs_remove_recursive(tpmi_info->dbgfs_dir);\n}\n\nstatic const struct auxiliary_device_id tpmi_id_table[] = {\n\t{ .name = \"intel_vsec.tpmi\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(auxiliary, tpmi_id_table);\n\nstatic struct auxiliary_driver tpmi_aux_driver = {\n\t.id_table\t= tpmi_id_table,\n\t.probe\t\t= tpmi_probe,\n\t.remove         = tpmi_remove,\n};\n\nmodule_auxiliary_driver(tpmi_aux_driver);\n\nMODULE_IMPORT_NS(INTEL_VSEC);\nMODULE_DESCRIPTION(\"Intel TPMI enumeration module\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}