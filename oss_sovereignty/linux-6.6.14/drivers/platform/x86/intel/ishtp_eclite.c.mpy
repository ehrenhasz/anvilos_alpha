{
  "module_name": "ishtp_eclite.c",
  "hash_id": "944885735a2a6cde77f5efd453a953817f2363da163d66f74fb0651be210299d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/x86/intel/ishtp_eclite.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/bitops.h>\n#include <linux/device.h>\n#include <linux/errno.h>\n#include <linux/intel-ish-client-if.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/types.h>\n#include <linux/uuid.h>\n#include <linux/uaccess.h>\n\n#define ECLITE_DATA_OPREGION_ID\t0x9E\n#define ECLITE_CMD_OPREGION_ID\t0x9F\n\n#define ECL_MSG_DATA\t0x1\n#define ECL_MSG_EVENT\t0x2\n\n#define ECL_ISH_READ\t0x1\n#define ECL_ISH_WRITE\t0x2\n#define ECL_ISH_HEADER_VERSION\t0\n\n#define ECL_CL_RX_RING_SIZE\t16\n#define ECL_CL_TX_RING_SIZE\t8\n\n#define ECL_DATA_OPR_BUFLEN\t384\n#define ECL_EVENTS_NOTIFY\t333\n\n#define cmd_opr_offsetof(element)\toffsetof(struct opregion_cmd, element)\n#define cl_data_to_dev(opr_dev)\tishtp_device((opr_dev)->cl_device)\n\n#ifndef BITS_TO_BYTES\n#define BITS_TO_BYTES(x) ((x) / 8)\n#endif\n\nstruct opregion_cmd {\n\tunsigned int command;\n\tunsigned int offset;\n\tunsigned int length;\n\tunsigned int event_id;\n};\n\nstruct opregion_data {\n\tchar data[ECL_DATA_OPR_BUFLEN];\n};\n\nstruct opregion_context {\n\tstruct opregion_cmd cmd_area;\n\tstruct opregion_data data_area;\n};\n\nstruct ecl_message_header {\n\tunsigned int version:2;\n\tunsigned int data_type:2;\n\tunsigned int request_type:2;\n\tunsigned int offset:9;\n\tunsigned int data_len:9;\n\tunsigned int event:8;\n};\n\nstruct ecl_message {\n\tstruct ecl_message_header header;\n\tchar payload[ECL_DATA_OPR_BUFLEN];\n};\n\nstruct ishtp_opregion_dev {\n\tstruct opregion_context opr_context;\n\tstruct ishtp_cl *ecl_ishtp_cl;\n\tstruct ishtp_cl_device *cl_device;\n\tstruct ishtp_fw_client *fw_client;\n\tstruct ishtp_cl_rb *rb;\n\tstruct acpi_device *adev;\n\tunsigned int dsm_event_id;\n\tunsigned int ish_link_ready;\n\tunsigned int ish_read_done;\n\tunsigned int acpi_init_done;\n\twait_queue_head_t read_wait;\n\tstruct work_struct event_work;\n\tstruct work_struct reset_work;\n\t \n\tstruct mutex lock;\n\n};\n\n \nstatic const struct ishtp_device_id ecl_ishtp_id_table[] = {\n\t{ .guid = GUID_INIT(0x6a19cc4b, 0xd760, 0x4de3,\n\t\t  0xb1, 0x4d, 0xf2, 0x5e, 0xbd, 0xf, 0xbc, 0xd9), },\n\t{ }\n};\nMODULE_DEVICE_TABLE(ishtp, ecl_ishtp_id_table);\n\n \nstatic const guid_t ecl_acpi_guid =\n\tGUID_INIT(0x91d936a7, 0x1f01, 0x49c6, 0xa6,\n\t\t  0xb4, 0x72, 0xf0, 0x0a, 0xd8, 0xd8, 0xa5);\n\n \nstatic int ecl_ish_cl_read(struct ishtp_opregion_dev *opr_dev)\n{\n\tstruct ecl_message_header header;\n\tint len, rv;\n\n\tif (!opr_dev->ish_link_ready)\n\t\treturn -EIO;\n\n\tif ((opr_dev->opr_context.cmd_area.offset +\n\t     opr_dev->opr_context.cmd_area.length) > ECL_DATA_OPR_BUFLEN) {\n\t\treturn -EINVAL;\n\t}\n\n\theader.version = ECL_ISH_HEADER_VERSION;\n\theader.data_type = ECL_MSG_DATA;\n\theader.request_type = ECL_ISH_READ;\n\theader.offset = opr_dev->opr_context.cmd_area.offset;\n\theader.data_len = opr_dev->opr_context.cmd_area.length;\n\theader.event = opr_dev->opr_context.cmd_area.event_id;\n\tlen = sizeof(header);\n\n\topr_dev->ish_read_done = false;\n\trv = ishtp_cl_send(opr_dev->ecl_ishtp_cl, (uint8_t *)&header, len);\n\tif (rv) {\n\t\tdev_err(cl_data_to_dev(opr_dev), \"ish-read : send failed\\n\");\n\t\treturn -EIO;\n\t}\n\n\tdev_dbg(cl_data_to_dev(opr_dev),\n\t\t\"[ish_rd] Req: off : %x, len : %x\\n\",\n\t\theader.offset,\n\t\theader.data_len);\n\n\trv = wait_event_interruptible_timeout(opr_dev->read_wait,\n\t\t\t\t\t      opr_dev->ish_read_done,\n\t\t\t\t\t      2 * HZ);\n\tif (!rv) {\n\t\tdev_err(cl_data_to_dev(opr_dev),\n\t\t\t\"[ish_rd] No response from firmware\\n\");\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int ecl_ish_cl_write(struct ishtp_opregion_dev *opr_dev)\n{\n\tstruct ecl_message message;\n\tint len;\n\n\tif (!opr_dev->ish_link_ready)\n\t\treturn -EIO;\n\n\tif ((opr_dev->opr_context.cmd_area.offset +\n\t     opr_dev->opr_context.cmd_area.length) > ECL_DATA_OPR_BUFLEN) {\n\t\treturn -EINVAL;\n\t}\n\n\tmessage.header.version = ECL_ISH_HEADER_VERSION;\n\tmessage.header.data_type = ECL_MSG_DATA;\n\tmessage.header.request_type = ECL_ISH_WRITE;\n\tmessage.header.offset = opr_dev->opr_context.cmd_area.offset;\n\tmessage.header.data_len = opr_dev->opr_context.cmd_area.length;\n\tmessage.header.event = opr_dev->opr_context.cmd_area.event_id;\n\tlen = sizeof(struct ecl_message_header) + message.header.data_len;\n\n\tmemcpy(message.payload,\n\t       opr_dev->opr_context.data_area.data + message.header.offset,\n\t       message.header.data_len);\n\n\tdev_dbg(cl_data_to_dev(opr_dev),\n\t\t\"[ish_wr] off : %x, len : %x\\n\",\n\t\tmessage.header.offset,\n\t\tmessage.header.data_len);\n\n\treturn ishtp_cl_send(opr_dev->ecl_ishtp_cl, (uint8_t *)&message, len);\n}\n\nstatic acpi_status\necl_opregion_cmd_handler(u32 function, acpi_physical_address address,\n\t\t\t u32 bits, u64 *value64,\n\t\t\t void *handler_context, void *region_context)\n{\n\tstruct ishtp_opregion_dev *opr_dev;\n\tstruct opregion_cmd *cmd;\n\tacpi_status status = AE_OK;\n\n\tif (!region_context || !value64)\n\t\treturn AE_BAD_PARAMETER;\n\n\tif (function == ACPI_READ)\n\t\treturn AE_ERROR;\n\n\topr_dev = (struct ishtp_opregion_dev *)region_context;\n\n\tmutex_lock(&opr_dev->lock);\n\n\tcmd = &opr_dev->opr_context.cmd_area;\n\n\tswitch (address) {\n\tcase cmd_opr_offsetof(command):\n\t\tcmd->command = (u32)*value64;\n\n\t\tif (cmd->command == ECL_ISH_READ)\n\t\t\tstatus =  ecl_ish_cl_read(opr_dev);\n\t\telse if (cmd->command == ECL_ISH_WRITE)\n\t\t\tstatus = ecl_ish_cl_write(opr_dev);\n\t\telse\n\t\t\tstatus = AE_ERROR;\n\t\tbreak;\n\tcase cmd_opr_offsetof(offset):\n\t\tcmd->offset = (u32)*value64;\n\t\tbreak;\n\tcase cmd_opr_offsetof(length):\n\t\tcmd->length = (u32)*value64;\n\t\tbreak;\n\tcase cmd_opr_offsetof(event_id):\n\t\tcmd->event_id = (u32)*value64;\n\t\tbreak;\n\tdefault:\n\t\tstatus = AE_ERROR;\n\t}\n\n\tmutex_unlock(&opr_dev->lock);\n\n\treturn status;\n}\n\nstatic acpi_status\necl_opregion_data_handler(u32 function, acpi_physical_address address,\n\t\t\t  u32 bits, u64 *value64,\n\t\t\t  void *handler_context, void *region_context)\n{\n\tstruct ishtp_opregion_dev *opr_dev;\n\tunsigned int bytes = BITS_TO_BYTES(bits);\n\tvoid *data_addr;\n\n\tif (!region_context || !value64)\n\t\treturn AE_BAD_PARAMETER;\n\n\tif (address + bytes > ECL_DATA_OPR_BUFLEN)\n\t\treturn AE_BAD_PARAMETER;\n\n\topr_dev = (struct ishtp_opregion_dev *)region_context;\n\n\tmutex_lock(&opr_dev->lock);\n\n\tdata_addr = &opr_dev->opr_context.data_area.data[address];\n\n\tif (function == ACPI_READ) {\n\t\tmemcpy(value64, data_addr, bytes);\n\t} else if (function == ACPI_WRITE) {\n\t\tmemcpy(data_addr, value64, bytes);\n\t} else {\n\t\tmutex_unlock(&opr_dev->lock);\n\t\treturn AE_BAD_PARAMETER;\n\t}\n\n\tmutex_unlock(&opr_dev->lock);\n\n\treturn AE_OK;\n}\n\nstatic int acpi_find_eclite_device(struct ishtp_opregion_dev *opr_dev)\n{\n\tstruct acpi_device *adev;\n\n\t \n\tadev = acpi_dev_get_first_match_dev(\"INTC1035\", NULL, -1);\n\tif (!adev) {\n\t\tdev_err(cl_data_to_dev(opr_dev), \"eclite ACPI device not found\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\topr_dev->adev = adev;\n\n\treturn 0;\n}\n\nstatic int acpi_opregion_init(struct ishtp_opregion_dev *opr_dev)\n{\n\tacpi_status status;\n\n\tstatus = acpi_install_address_space_handler(opr_dev->adev->handle,\n\t\t\t\t\t\t    ECLITE_CMD_OPREGION_ID,\n\t\t\t\t\t\t    ecl_opregion_cmd_handler,\n\t\t\t\t\t\t    NULL, opr_dev);\n\tif (ACPI_FAILURE(status)) {\n\t\tdev_err(cl_data_to_dev(opr_dev),\n\t\t\t\"cmd space handler install failed\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tstatus = acpi_install_address_space_handler(opr_dev->adev->handle,\n\t\t\t\t\t\t    ECLITE_DATA_OPREGION_ID,\n\t\t\t\t\t\t    ecl_opregion_data_handler,\n\t\t\t\t\t\t    NULL, opr_dev);\n\tif (ACPI_FAILURE(status)) {\n\t\tdev_err(cl_data_to_dev(opr_dev),\n\t\t\t\"data space handler install failed\\n\");\n\n\t\tacpi_remove_address_space_handler(opr_dev->adev->handle,\n\t\t\t\t\t\t  ECLITE_CMD_OPREGION_ID,\n\t\t\t\t\t\t  ecl_opregion_cmd_handler);\n\t\treturn -ENODEV;\n\t}\n\topr_dev->acpi_init_done = true;\n\n\tdev_dbg(cl_data_to_dev(opr_dev), \"Opregion handlers are installed\\n\");\n\n\treturn 0;\n}\n\nstatic void acpi_opregion_deinit(struct ishtp_opregion_dev *opr_dev)\n{\n\tacpi_remove_address_space_handler(opr_dev->adev->handle,\n\t\t\t\t\t  ECLITE_CMD_OPREGION_ID,\n\t\t\t\t\t  ecl_opregion_cmd_handler);\n\n\tacpi_remove_address_space_handler(opr_dev->adev->handle,\n\t\t\t\t\t  ECLITE_DATA_OPREGION_ID,\n\t\t\t\t\t  ecl_opregion_data_handler);\n\topr_dev->acpi_init_done = false;\n}\n\nstatic void ecl_acpi_invoke_dsm(struct work_struct *work)\n{\n\tstruct ishtp_opregion_dev *opr_dev;\n\tunion acpi_object *obj;\n\n\topr_dev = container_of(work, struct ishtp_opregion_dev, event_work);\n\tif (!opr_dev->acpi_init_done)\n\t\treturn;\n\n\tobj = acpi_evaluate_dsm(opr_dev->adev->handle, &ecl_acpi_guid, 0,\n\t\t\t\topr_dev->dsm_event_id, NULL);\n\tif (!obj) {\n\t\tdev_warn(cl_data_to_dev(opr_dev), \"_DSM fn call failed\\n\");\n\t\treturn;\n\t}\n\n\tdev_dbg(cl_data_to_dev(opr_dev), \"Exec DSM function code: %d success\\n\",\n\t\topr_dev->dsm_event_id);\n\n\tACPI_FREE(obj);\n}\n\nstatic void ecl_ish_process_rx_data(struct ishtp_opregion_dev *opr_dev)\n{\n\tstruct ecl_message *message =\n\t\t(struct ecl_message *)opr_dev->rb->buffer.data;\n\n\tdev_dbg(cl_data_to_dev(opr_dev),\n\t\t\"[ish_rd] Resp: off : %x, len : %x\\n\",\n\t\tmessage->header.offset,\n\t\tmessage->header.data_len);\n\n\tif ((message->header.offset + message->header.data_len) >\n\t\t\tECL_DATA_OPR_BUFLEN) {\n\t\treturn;\n\t}\n\n\tmemcpy(opr_dev->opr_context.data_area.data + message->header.offset,\n\t       message->payload, message->header.data_len);\n\n\topr_dev->ish_read_done = true;\n\twake_up_interruptible(&opr_dev->read_wait);\n}\n\nstatic void ecl_ish_process_rx_event(struct ishtp_opregion_dev *opr_dev)\n{\n\tstruct ecl_message_header *header =\n\t\t(struct ecl_message_header *)opr_dev->rb->buffer.data;\n\n\tdev_dbg(cl_data_to_dev(opr_dev),\n\t\t\"[ish_ev] Evt received: %8x\\n\", header->event);\n\n\topr_dev->dsm_event_id = header->event;\n\tschedule_work(&opr_dev->event_work);\n}\n\nstatic int ecl_ish_cl_enable_events(struct ishtp_opregion_dev *opr_dev,\n\t\t\t\t    bool config_enable)\n{\n\tstruct ecl_message message;\n\tint len;\n\n\tmessage.header.version = ECL_ISH_HEADER_VERSION;\n\tmessage.header.data_type = ECL_MSG_DATA;\n\tmessage.header.request_type = ECL_ISH_WRITE;\n\tmessage.header.offset = ECL_EVENTS_NOTIFY;\n\tmessage.header.data_len = 1;\n\tmessage.payload[0] = config_enable;\n\n\tlen = sizeof(struct ecl_message_header) + message.header.data_len;\n\n\treturn ishtp_cl_send(opr_dev->ecl_ishtp_cl, (uint8_t *)&message, len);\n}\n\nstatic void ecl_ishtp_cl_event_cb(struct ishtp_cl_device *cl_device)\n{\n\tstruct ishtp_cl *ecl_ishtp_cl = ishtp_get_drvdata(cl_device);\n\tstruct ishtp_opregion_dev *opr_dev;\n\tstruct ecl_message_header *header;\n\tstruct ishtp_cl_rb *rb;\n\n\topr_dev = ishtp_get_client_data(ecl_ishtp_cl);\n\twhile ((rb = ishtp_cl_rx_get_rb(opr_dev->ecl_ishtp_cl)) != NULL) {\n\t\topr_dev->rb = rb;\n\t\theader = (struct ecl_message_header *)rb->buffer.data;\n\n\t\tif (header->data_type == ECL_MSG_DATA)\n\t\t\tecl_ish_process_rx_data(opr_dev);\n\t\telse if (header->data_type == ECL_MSG_EVENT)\n\t\t\tecl_ish_process_rx_event(opr_dev);\n\t\telse\n\t\t\t \n\t\t\tdev_err(cl_data_to_dev(opr_dev),\n\t\t\t\t\"[ish_cb] Received wrong data_type\\n\");\n\n\t\tishtp_cl_io_rb_recycle(rb);\n\t}\n}\n\nstatic int ecl_ishtp_cl_init(struct ishtp_cl *ecl_ishtp_cl)\n{\n\tstruct ishtp_opregion_dev *opr_dev =\n\t\tishtp_get_client_data(ecl_ishtp_cl);\n\tstruct ishtp_fw_client *fw_client;\n\tstruct ishtp_device *dev;\n\tint rv;\n\n\trv = ishtp_cl_link(ecl_ishtp_cl);\n\tif (rv) {\n\t\tdev_err(cl_data_to_dev(opr_dev), \"ishtp_cl_link failed\\n\");\n\t\treturn\trv;\n\t}\n\n\tdev = ishtp_get_ishtp_device(ecl_ishtp_cl);\n\n\t \n\tishtp_set_tx_ring_size(ecl_ishtp_cl, ECL_CL_TX_RING_SIZE);\n\tishtp_set_rx_ring_size(ecl_ishtp_cl, ECL_CL_RX_RING_SIZE);\n\n\tfw_client = ishtp_fw_cl_get_client(dev, &ecl_ishtp_id_table[0].guid);\n\tif (!fw_client) {\n\t\tdev_err(cl_data_to_dev(opr_dev), \"fw client not found\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\tishtp_cl_set_fw_client_id(ecl_ishtp_cl,\n\t\t\t\t  ishtp_get_fw_client_id(fw_client));\n\n\tishtp_set_connection_state(ecl_ishtp_cl, ISHTP_CL_CONNECTING);\n\n\trv = ishtp_cl_connect(ecl_ishtp_cl);\n\tif (rv) {\n\t\tdev_err(cl_data_to_dev(opr_dev), \"client connect failed\\n\");\n\n\t\tishtp_cl_unlink(ecl_ishtp_cl);\n\t\treturn rv;\n\t}\n\n\tdev_dbg(cl_data_to_dev(opr_dev), \"Host connected to fw client\\n\");\n\n\treturn 0;\n}\n\nstatic void ecl_ishtp_cl_deinit(struct ishtp_cl *ecl_ishtp_cl)\n{\n\tishtp_cl_unlink(ecl_ishtp_cl);\n\tishtp_cl_flush_queues(ecl_ishtp_cl);\n\tishtp_cl_free(ecl_ishtp_cl);\n}\n\nstatic void ecl_ishtp_cl_reset_handler(struct work_struct *work)\n{\n\tstruct ishtp_opregion_dev *opr_dev;\n\tstruct ishtp_cl_device *cl_device;\n\tstruct ishtp_cl *ecl_ishtp_cl;\n\tint rv;\n\tint retry;\n\n\topr_dev = container_of(work, struct ishtp_opregion_dev, reset_work);\n\n\topr_dev->ish_link_ready = false;\n\n\tcl_device = opr_dev->cl_device;\n\tecl_ishtp_cl = opr_dev->ecl_ishtp_cl;\n\n\tecl_ishtp_cl_deinit(ecl_ishtp_cl);\n\n\tecl_ishtp_cl = ishtp_cl_allocate(cl_device);\n\tif (!ecl_ishtp_cl)\n\t\treturn;\n\n\tishtp_set_drvdata(cl_device, ecl_ishtp_cl);\n\tishtp_set_client_data(ecl_ishtp_cl, opr_dev);\n\n\topr_dev->ecl_ishtp_cl = ecl_ishtp_cl;\n\n\tfor (retry = 0; retry < 3; ++retry) {\n\t\trv = ecl_ishtp_cl_init(ecl_ishtp_cl);\n\t\tif (!rv)\n\t\t\tbreak;\n\t}\n\tif (rv) {\n\t\tishtp_cl_free(ecl_ishtp_cl);\n\t\topr_dev->ecl_ishtp_cl = NULL;\n\t\tdev_err(cl_data_to_dev(opr_dev),\n\t\t\t\"[ish_rst] Reset failed. Link not ready.\\n\");\n\t\treturn;\n\t}\n\n\tishtp_register_event_cb(cl_device, ecl_ishtp_cl_event_cb);\n\tdev_info(cl_data_to_dev(opr_dev),\n\t\t \"[ish_rst] Reset Success. Link ready.\\n\");\n\n\topr_dev->ish_link_ready = true;\n\n\tif (opr_dev->acpi_init_done)\n\t\treturn;\n\n\trv = acpi_opregion_init(opr_dev);\n\tif (rv) {\n\t\tdev_err(cl_data_to_dev(opr_dev),\n\t\t\t\"ACPI opregion init failed\\n\");\n\t}\n}\n\nstatic int ecl_ishtp_cl_probe(struct ishtp_cl_device *cl_device)\n{\n\tstruct ishtp_cl *ecl_ishtp_cl;\n\tstruct ishtp_opregion_dev *opr_dev;\n\tint rv;\n\n\topr_dev = devm_kzalloc(ishtp_device(cl_device), sizeof(*opr_dev),\n\t\t\t       GFP_KERNEL);\n\tif (!opr_dev)\n\t\treturn -ENOMEM;\n\n\tecl_ishtp_cl = ishtp_cl_allocate(cl_device);\n\tif (!ecl_ishtp_cl)\n\t\treturn -ENOMEM;\n\n\tishtp_set_drvdata(cl_device, ecl_ishtp_cl);\n\tishtp_set_client_data(ecl_ishtp_cl, opr_dev);\n\topr_dev->ecl_ishtp_cl = ecl_ishtp_cl;\n\topr_dev->cl_device = cl_device;\n\n\tinit_waitqueue_head(&opr_dev->read_wait);\n\tINIT_WORK(&opr_dev->event_work, ecl_acpi_invoke_dsm);\n\tINIT_WORK(&opr_dev->reset_work, ecl_ishtp_cl_reset_handler);\n\n\t \n\trv = ecl_ishtp_cl_init(ecl_ishtp_cl);\n\tif (rv) {\n\t\tdev_err(cl_data_to_dev(opr_dev), \"Client init failed\\n\");\n\t\tgoto err_exit;\n\t}\n\n\tdev_dbg(cl_data_to_dev(opr_dev), \"eclite-ishtp client initialised\\n\");\n\n\topr_dev->ish_link_ready = true;\n\tmutex_init(&opr_dev->lock);\n\n\trv = acpi_find_eclite_device(opr_dev);\n\tif (rv) {\n\t\tdev_err(cl_data_to_dev(opr_dev), \"ECLite ACPI ID not found\\n\");\n\t\tgoto err_exit;\n\t}\n\n\t \n\tishtp_register_event_cb(cl_device, ecl_ishtp_cl_event_cb);\n\n\t \n\trv = acpi_opregion_init(opr_dev);\n\tif (rv) {\n\t\tdev_err(cl_data_to_dev(opr_dev), \"ACPI opregion init failed\\n\");\n\t\tgoto err_exit;\n\t}\n\n\t \n\tacpi_dev_clear_dependencies(opr_dev->adev);\n\n\treturn 0;\nerr_exit:\n\tishtp_set_connection_state(ecl_ishtp_cl, ISHTP_CL_DISCONNECTING);\n\tishtp_cl_disconnect(ecl_ishtp_cl);\n\tecl_ishtp_cl_deinit(ecl_ishtp_cl);\n\n\treturn rv;\n}\n\nstatic void ecl_ishtp_cl_remove(struct ishtp_cl_device *cl_device)\n{\n\tstruct ishtp_cl *ecl_ishtp_cl = ishtp_get_drvdata(cl_device);\n\tstruct ishtp_opregion_dev *opr_dev =\n\t\tishtp_get_client_data(ecl_ishtp_cl);\n\n\tif (opr_dev->acpi_init_done)\n\t\tacpi_opregion_deinit(opr_dev);\n\n\tacpi_dev_put(opr_dev->adev);\n\n\tishtp_set_connection_state(ecl_ishtp_cl, ISHTP_CL_DISCONNECTING);\n\tishtp_cl_disconnect(ecl_ishtp_cl);\n\tecl_ishtp_cl_deinit(ecl_ishtp_cl);\n\n\tcancel_work_sync(&opr_dev->reset_work);\n\tcancel_work_sync(&opr_dev->event_work);\n}\n\nstatic int ecl_ishtp_cl_reset(struct ishtp_cl_device *cl_device)\n{\n\tstruct ishtp_cl *ecl_ishtp_cl = ishtp_get_drvdata(cl_device);\n\tstruct ishtp_opregion_dev *opr_dev =\n\t\tishtp_get_client_data(ecl_ishtp_cl);\n\n\tschedule_work(&opr_dev->reset_work);\n\n\treturn 0;\n}\n\nstatic int ecl_ishtp_cl_suspend(struct device *device)\n{\n\tstruct ishtp_cl_device *cl_device = ishtp_dev_to_cl_device(device);\n\tstruct ishtp_cl *ecl_ishtp_cl = ishtp_get_drvdata(cl_device);\n\tstruct ishtp_opregion_dev *opr_dev =\n\t\tishtp_get_client_data(ecl_ishtp_cl);\n\n\tif (acpi_target_system_state() == ACPI_STATE_S0)\n\t\treturn 0;\n\n\tacpi_opregion_deinit(opr_dev);\n\tecl_ish_cl_enable_events(opr_dev, false);\n\n\treturn 0;\n}\n\nstatic int ecl_ishtp_cl_resume(struct device *device)\n{\n\t \n\treturn 0;\n}\n\nstatic const struct dev_pm_ops ecl_ishtp_pm_ops = {\n\t.suspend = ecl_ishtp_cl_suspend,\n\t.resume = ecl_ishtp_cl_resume,\n};\n\nstatic struct ishtp_cl_driver ecl_ishtp_cl_driver = {\n\t.name = \"ishtp-eclite\",\n\t.id = ecl_ishtp_id_table,\n\t.probe = ecl_ishtp_cl_probe,\n\t.remove = ecl_ishtp_cl_remove,\n\t.reset = ecl_ishtp_cl_reset,\n\t.driver.pm = &ecl_ishtp_pm_ops,\n};\n\nstatic int __init ecl_ishtp_init(void)\n{\n\treturn ishtp_cl_driver_register(&ecl_ishtp_cl_driver, THIS_MODULE);\n}\n\nstatic void __exit ecl_ishtp_exit(void)\n{\n\treturn ishtp_cl_driver_unregister(&ecl_ishtp_cl_driver);\n}\n\nlate_initcall(ecl_ishtp_init);\nmodule_exit(ecl_ishtp_exit);\n\nMODULE_DESCRIPTION(\"ISH ISHTP eclite client opregion driver\");\nMODULE_AUTHOR(\"K Naduvalath, Sumesh <sumesh.k.naduvalath@intel.com>\");\n\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}