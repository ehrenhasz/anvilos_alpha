{
  "module_name": "bxtwc_tmu.c",
  "hash_id": "14ad77b0f1852e0d8cac5599688d4c333dd733391f2a341d1dacbc4e6fe0fec3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/x86/intel/bxtwc_tmu.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/interrupt.h>\n#include <linux/platform_device.h>\n#include <linux/mfd/intel_soc_pmic.h>\n\n#define BXTWC_TMUIRQ\t\t0x4fb6\n#define BXTWC_MIRQLVL1\t\t0x4e0e\n#define BXTWC_MTMUIRQ_REG\t0x4fb7\n#define BXTWC_MIRQLVL1_MTMU\tBIT(1)\n#define BXTWC_TMU_WK_ALRM\tBIT(1)\n#define BXTWC_TMU_SYS_ALRM\tBIT(2)\n#define BXTWC_TMU_ALRM_MASK\t(BXTWC_TMU_WK_ALRM | BXTWC_TMU_SYS_ALRM)\n#define BXTWC_TMU_ALRM_IRQ\t(BXTWC_TMU_WK_ALRM | BXTWC_TMU_SYS_ALRM)\n\nstruct wcove_tmu {\n\tint irq;\n\tstruct device *dev;\n\tstruct regmap *regmap;\n};\n\nstatic irqreturn_t bxt_wcove_tmu_irq_handler(int irq, void *data)\n{\n\tstruct wcove_tmu *wctmu = data;\n\tunsigned int tmu_irq;\n\n\t \n\tregmap_read(wctmu->regmap, BXTWC_TMUIRQ, &tmu_irq);\n\tif (tmu_irq & BXTWC_TMU_ALRM_IRQ) {\n\t\t \n\t\tregmap_write(wctmu->regmap, BXTWC_TMUIRQ, tmu_irq);\n\t\treturn IRQ_HANDLED;\n\t}\n\treturn IRQ_NONE;\n}\n\nstatic int bxt_wcove_tmu_probe(struct platform_device *pdev)\n{\n\tstruct intel_soc_pmic *pmic = dev_get_drvdata(pdev->dev.parent);\n\tstruct regmap_irq_chip_data *regmap_irq_chip;\n\tstruct wcove_tmu *wctmu;\n\tint ret, virq, irq;\n\n\twctmu = devm_kzalloc(&pdev->dev, sizeof(*wctmu), GFP_KERNEL);\n\tif (!wctmu)\n\t\treturn -ENOMEM;\n\n\twctmu->dev = &pdev->dev;\n\twctmu->regmap = pmic->regmap;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tregmap_irq_chip = pmic->irq_chip_data_tmu;\n\tvirq = regmap_irq_get_virq(regmap_irq_chip, irq);\n\tif (virq < 0) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"failed to get virtual interrupt=%d\\n\", irq);\n\t\treturn virq;\n\t}\n\n\tret = devm_request_threaded_irq(&pdev->dev, virq,\n\t\t\t\t\tNULL, bxt_wcove_tmu_irq_handler,\n\t\t\t\t\tIRQF_ONESHOT, \"bxt_wcove_tmu\", wctmu);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"request irq failed: %d,virq: %d\\n\",\n\t\t\t\t\t\t\tret, virq);\n\t\treturn ret;\n\t}\n\twctmu->irq = virq;\n\n\t \n\tregmap_update_bits(wctmu->regmap, BXTWC_MTMUIRQ_REG,\n\t\t\t\t  BXTWC_TMU_ALRM_MASK, 0);\n\n\tplatform_set_drvdata(pdev, wctmu);\n\treturn 0;\n}\n\nstatic void bxt_wcove_tmu_remove(struct platform_device *pdev)\n{\n\tstruct wcove_tmu *wctmu = platform_get_drvdata(pdev);\n\tunsigned int val;\n\n\t \n\tregmap_read(wctmu->regmap, BXTWC_MIRQLVL1, &val);\n\tregmap_write(wctmu->regmap, BXTWC_MIRQLVL1,\n\t\t\tval | BXTWC_MIRQLVL1_MTMU);\n\tregmap_read(wctmu->regmap, BXTWC_MTMUIRQ_REG, &val);\n\tregmap_write(wctmu->regmap, BXTWC_MTMUIRQ_REG,\n\t\t\tval | BXTWC_TMU_ALRM_MASK);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int bxtwc_tmu_suspend(struct device *dev)\n{\n\tstruct wcove_tmu *wctmu = dev_get_drvdata(dev);\n\n\tenable_irq_wake(wctmu->irq);\n\treturn 0;\n}\n\nstatic int bxtwc_tmu_resume(struct device *dev)\n{\n\tstruct wcove_tmu *wctmu = dev_get_drvdata(dev);\n\n\tdisable_irq_wake(wctmu->irq);\n\treturn 0;\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(bxtwc_tmu_pm_ops, bxtwc_tmu_suspend, bxtwc_tmu_resume);\n\nstatic const struct platform_device_id bxt_wcove_tmu_id_table[] = {\n\t{ .name = \"bxt_wcove_tmu\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(platform, bxt_wcove_tmu_id_table);\n\nstatic struct platform_driver bxt_wcove_tmu_driver = {\n\t.probe = bxt_wcove_tmu_probe,\n\t.remove_new = bxt_wcove_tmu_remove,\n\t.driver = {\n\t\t.name = \"bxt_wcove_tmu\",\n\t\t.pm     = &bxtwc_tmu_pm_ops,\n\t},\n\t.id_table = bxt_wcove_tmu_id_table,\n};\n\nmodule_platform_driver(bxt_wcove_tmu_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Nilesh Bacchewar <nilesh.bacchewar@intel.com>\");\nMODULE_DESCRIPTION(\"BXT Whiskey Cove TMU Driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}