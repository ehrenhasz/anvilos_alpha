{
  "module_name": "sdsi.c",
  "hash_id": "a846ee6149007e77cd5b77ef0432627cbe6bf253b5932dc2584ea542db2e50b8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/x86/intel/sdsi.c",
  "human_readable_source": "\n \n\n#include <linux/auxiliary_bus.h>\n#include <linux/bits.h>\n#include <linux/bitfield.h>\n#include <linux/device.h>\n#include <linux/iopoll.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/types.h>\n#include <linux/uaccess.h>\n\n#include \"vsec.h\"\n\n#define ACCESS_TYPE_BARID\t\t2\n#define ACCESS_TYPE_LOCAL\t\t3\n\n#define SDSI_MIN_SIZE_DWORDS\t\t276\n#define SDSI_SIZE_MAILBOX\t\t1024\n#define SDSI_SIZE_REGS\t\t\t80\n#define SDSI_SIZE_CMD\t\t\tsizeof(u64)\n\n \n#define SDSI_SIZE_WRITE_MSG\t\tSDSI_SIZE_MAILBOX\n#define SDSI_SIZE_READ_MSG\t\t(SDSI_SIZE_MAILBOX * 4)\n\n#define SDSI_ENABLED_FEATURES_OFFSET\t16\n#define SDSI_FEATURE_SDSI\t\tBIT(3)\n#define SDSI_FEATURE_METERING\t\tBIT(26)\n\n#define SDSI_SOCKET_ID_OFFSET\t\t64\n#define SDSI_SOCKET_ID\t\t\tGENMASK(3, 0)\n\n#define SDSI_MBOX_CMD_SUCCESS\t\t0x40\n#define SDSI_MBOX_CMD_TIMEOUT\t\t0x80\n\n#define MBOX_TIMEOUT_US\t\t\t500000\n#define MBOX_TIMEOUT_ACQUIRE_US\t\t1000\n#define MBOX_POLLING_PERIOD_US\t\t100\n#define MBOX_ACQUIRE_NUM_RETRIES\t5\n#define MBOX_ACQUIRE_RETRY_DELAY_MS\t500\n#define MBOX_MAX_PACKETS\t\t4\n\n#define MBOX_OWNER_NONE\t\t\t0x00\n#define MBOX_OWNER_INBAND\t\t0x01\n\n#define CTRL_RUN_BUSY\t\t\tBIT(0)\n#define CTRL_READ_WRITE\t\t\tBIT(1)\n#define CTRL_SOM\t\t\tBIT(2)\n#define CTRL_EOM\t\t\tBIT(3)\n#define CTRL_OWNER\t\t\tGENMASK(5, 4)\n#define CTRL_COMPLETE\t\t\tBIT(6)\n#define CTRL_READY\t\t\tBIT(7)\n#define CTRL_STATUS\t\t\tGENMASK(15, 8)\n#define CTRL_PACKET_SIZE\t\tGENMASK(31, 16)\n#define CTRL_MSG_SIZE\t\t\tGENMASK(63, 48)\n\n#define DISC_TABLE_SIZE\t\t\t12\n#define DT_ACCESS_TYPE\t\t\tGENMASK(3, 0)\n#define DT_SIZE\t\t\t\tGENMASK(27, 12)\n#define DT_TBIR\t\t\t\tGENMASK(2, 0)\n#define DT_OFFSET(v)\t\t\t((v) & GENMASK(31, 3))\n\n#define SDSI_GUID_V1\t\t\t0x006DD191\n#define GUID_V1_CNTRL_SIZE\t\t8\n#define GUID_V1_REGS_SIZE\t\t72\n#define SDSI_GUID_V2\t\t\t0xF210D9EF\n#define GUID_V2_CNTRL_SIZE\t\t16\n#define GUID_V2_REGS_SIZE\t\t80\n\nenum sdsi_command {\n\tSDSI_CMD_PROVISION_AKC\t\t= 0x0004,\n\tSDSI_CMD_PROVISION_CAP\t\t= 0x0008,\n\tSDSI_CMD_READ_STATE\t\t= 0x0010,\n\tSDSI_CMD_READ_METER\t\t= 0x0014,\n};\n\nstruct sdsi_mbox_info {\n\tu64\t*payload;\n\tvoid\t*buffer;\n\tint\tsize;\n};\n\nstruct disc_table {\n\tu32\taccess_info;\n\tu32\tguid;\n\tu32\toffset;\n};\n\nstruct sdsi_priv {\n\tstruct mutex\t\tmb_lock;\t \n\tstruct device\t\t*dev;\n\tvoid __iomem\t\t*control_addr;\n\tvoid __iomem\t\t*mbox_addr;\n\tvoid __iomem\t\t*regs_addr;\n\tint\t\t\tcontrol_size;\n\tint\t\t\tmaibox_size;\n\tint\t\t\tregisters_size;\n\tu32\t\t\tguid;\n\tu32\t\t\tfeatures;\n};\n\n \nstatic __always_inline void\nsdsi_memcpy64_toio(u64 __iomem *to, const u64 *from, size_t count_bytes)\n{\n\tsize_t count = count_bytes / sizeof(*to);\n\tint i;\n\n\tfor (i = 0; i < count; i++)\n\t\twriteq(from[i], &to[i]);\n}\n\nstatic __always_inline void\nsdsi_memcpy64_fromio(u64 *to, const u64 __iomem *from, size_t count_bytes)\n{\n\tsize_t count = count_bytes / sizeof(*to);\n\tint i;\n\n\tfor (i = 0; i < count; i++)\n\t\tto[i] = readq(&from[i]);\n}\n\nstatic inline void sdsi_complete_transaction(struct sdsi_priv *priv)\n{\n\tu64 control = FIELD_PREP(CTRL_COMPLETE, 1);\n\n\tlockdep_assert_held(&priv->mb_lock);\n\twriteq(control, priv->control_addr);\n}\n\nstatic int sdsi_status_to_errno(u32 status)\n{\n\tswitch (status) {\n\tcase SDSI_MBOX_CMD_SUCCESS:\n\t\treturn 0;\n\tcase SDSI_MBOX_CMD_TIMEOUT:\n\t\treturn -ETIMEDOUT;\n\tdefault:\n\t\treturn -EIO;\n\t}\n}\n\nstatic int sdsi_mbox_cmd_read(struct sdsi_priv *priv, struct sdsi_mbox_info *info,\n\t\t\t      size_t *data_size)\n{\n\tstruct device *dev = priv->dev;\n\tu32 total, loop, eom, status, message_size;\n\tu64 control;\n\tint ret;\n\n\tlockdep_assert_held(&priv->mb_lock);\n\n\t \n\tcontrol = FIELD_PREP(CTRL_EOM, 1) |\n\t\t  FIELD_PREP(CTRL_SOM, 1) |\n\t\t  FIELD_PREP(CTRL_RUN_BUSY, 1) |\n\t\t  FIELD_PREP(CTRL_PACKET_SIZE, info->size);\n\twriteq(control, priv->control_addr);\n\n\t \n\ttotal = 0;\n\tloop = 0;\n\tdo {\n\t\tvoid *buf = info->buffer + (SDSI_SIZE_MAILBOX * loop);\n\t\tu32 packet_size;\n\n\t\t \n\t\tret = readq_poll_timeout(priv->control_addr, control, control & CTRL_READY,\n\t\t\t\t\t MBOX_POLLING_PERIOD_US, MBOX_TIMEOUT_US);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\teom = FIELD_GET(CTRL_EOM, control);\n\t\tstatus = FIELD_GET(CTRL_STATUS, control);\n\t\tpacket_size = FIELD_GET(CTRL_PACKET_SIZE, control);\n\t\tmessage_size = FIELD_GET(CTRL_MSG_SIZE, control);\n\n\t\tret = sdsi_status_to_errno(status);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\t \n\t\tif (!eom && packet_size != SDSI_SIZE_MAILBOX) {\n\t\t\tdev_err(dev, \"Invalid packet size\\n\");\n\t\t\tret = -EPROTO;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (packet_size > SDSI_SIZE_MAILBOX) {\n\t\t\tdev_err(dev, \"Packet size too large\\n\");\n\t\t\tret = -EPROTO;\n\t\t\tbreak;\n\t\t}\n\n\t\tsdsi_memcpy64_fromio(buf, priv->mbox_addr, round_up(packet_size, SDSI_SIZE_CMD));\n\n\t\ttotal += packet_size;\n\n\t\tsdsi_complete_transaction(priv);\n\t} while (!eom && ++loop < MBOX_MAX_PACKETS);\n\n\tif (ret) {\n\t\tsdsi_complete_transaction(priv);\n\t\treturn ret;\n\t}\n\n\tif (!eom) {\n\t\tdev_err(dev, \"Exceeded read attempts\\n\");\n\t\treturn -EPROTO;\n\t}\n\n\t \n\tif (loop && total != message_size)\n\t\tdev_warn(dev, \"Read count %u differs from expected count %u\\n\",\n\t\t\t total, message_size);\n\n\t*data_size = total;\n\n\treturn 0;\n}\n\nstatic int sdsi_mbox_cmd_write(struct sdsi_priv *priv, struct sdsi_mbox_info *info)\n{\n\tu64 control;\n\tu32 status;\n\tint ret;\n\n\tlockdep_assert_held(&priv->mb_lock);\n\n\t \n\tsdsi_memcpy64_toio(priv->mbox_addr + SDSI_SIZE_CMD, info->payload + 1,\n\t\t\t   info->size - SDSI_SIZE_CMD);\n\n\t \n\tcontrol = FIELD_PREP(CTRL_EOM, 1) |\n\t\t  FIELD_PREP(CTRL_SOM, 1) |\n\t\t  FIELD_PREP(CTRL_RUN_BUSY, 1) |\n\t\t  FIELD_PREP(CTRL_READ_WRITE, 1) |\n\t\t  FIELD_PREP(CTRL_PACKET_SIZE, info->size);\n\twriteq(control, priv->control_addr);\n\n\t \n\tret = readq_poll_timeout(priv->control_addr, control, control & CTRL_READY,\n\t\t\t\t MBOX_POLLING_PERIOD_US, MBOX_TIMEOUT_US);\n\n\tif (ret)\n\t\tgoto release_mbox;\n\n\tstatus = FIELD_GET(CTRL_STATUS, control);\n\tret = sdsi_status_to_errno(status);\n\nrelease_mbox:\n\tsdsi_complete_transaction(priv);\n\n\treturn ret;\n}\n\nstatic int sdsi_mbox_acquire(struct sdsi_priv *priv, struct sdsi_mbox_info *info)\n{\n\tu64 control;\n\tu32 owner;\n\tint ret, retries = 0;\n\n\tlockdep_assert_held(&priv->mb_lock);\n\n\t \n\tcontrol = readq(priv->control_addr);\n\towner = FIELD_GET(CTRL_OWNER, control);\n\tif (owner != MBOX_OWNER_NONE)\n\t\treturn -EBUSY;\n\n\t \n\tdo {\n\t\t \n\t\twriteq(info->payload[0], priv->mbox_addr);\n\n\t\t \n\t\tret = readq_poll_timeout(priv->control_addr, control,\n\t\t\tFIELD_GET(CTRL_OWNER, control) == MBOX_OWNER_INBAND,\n\t\t\tMBOX_POLLING_PERIOD_US, MBOX_TIMEOUT_ACQUIRE_US);\n\n\t\tif (FIELD_GET(CTRL_OWNER, control) == MBOX_OWNER_NONE &&\n\t\t    retries++ < MBOX_ACQUIRE_NUM_RETRIES) {\n\t\t\tmsleep(MBOX_ACQUIRE_RETRY_DELAY_MS);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tbreak;\n\t} while (true);\n\n\treturn ret;\n}\n\nstatic int sdsi_mbox_write(struct sdsi_priv *priv, struct sdsi_mbox_info *info)\n{\n\tint ret;\n\n\tlockdep_assert_held(&priv->mb_lock);\n\n\tret = sdsi_mbox_acquire(priv, info);\n\tif (ret)\n\t\treturn ret;\n\n\treturn sdsi_mbox_cmd_write(priv, info);\n}\n\nstatic int sdsi_mbox_read(struct sdsi_priv *priv, struct sdsi_mbox_info *info, size_t *data_size)\n{\n\tint ret;\n\n\tlockdep_assert_held(&priv->mb_lock);\n\n\tret = sdsi_mbox_acquire(priv, info);\n\tif (ret)\n\t\treturn ret;\n\n\treturn sdsi_mbox_cmd_read(priv, info, data_size);\n}\n\nstatic ssize_t sdsi_provision(struct sdsi_priv *priv, char *buf, size_t count,\n\t\t\t      enum sdsi_command command)\n{\n\tstruct sdsi_mbox_info info;\n\tint ret;\n\n\tif (count > (SDSI_SIZE_WRITE_MSG - SDSI_SIZE_CMD))\n\t\treturn -EOVERFLOW;\n\n\t \n\tinfo.size = round_up(count, SDSI_SIZE_CMD) + SDSI_SIZE_CMD;\n\n\tinfo.payload = kzalloc(info.size, GFP_KERNEL);\n\tif (!info.payload)\n\t\treturn -ENOMEM;\n\n\t \n\tmemcpy(info.payload, buf, count);\n\n\t \n\tinfo.payload[(info.size - SDSI_SIZE_CMD) / SDSI_SIZE_CMD] = command;\n\n\tret = mutex_lock_interruptible(&priv->mb_lock);\n\tif (ret)\n\t\tgoto free_payload;\n\tret = sdsi_mbox_write(priv, &info);\n\tmutex_unlock(&priv->mb_lock);\n\nfree_payload:\n\tkfree(info.payload);\n\n\tif (ret)\n\t\treturn ret;\n\n\treturn count;\n}\n\nstatic ssize_t provision_akc_write(struct file *filp, struct kobject *kobj,\n\t\t\t\t   struct bin_attribute *attr, char *buf, loff_t off,\n\t\t\t\t   size_t count)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct sdsi_priv *priv = dev_get_drvdata(dev);\n\n\tif (off)\n\t\treturn -ESPIPE;\n\n\treturn sdsi_provision(priv, buf, count, SDSI_CMD_PROVISION_AKC);\n}\nstatic BIN_ATTR_WO(provision_akc, SDSI_SIZE_WRITE_MSG);\n\nstatic ssize_t provision_cap_write(struct file *filp, struct kobject *kobj,\n\t\t\t\t   struct bin_attribute *attr, char *buf, loff_t off,\n\t\t\t\t   size_t count)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct sdsi_priv *priv = dev_get_drvdata(dev);\n\n\tif (off)\n\t\treturn -ESPIPE;\n\n\treturn sdsi_provision(priv, buf, count, SDSI_CMD_PROVISION_CAP);\n}\nstatic BIN_ATTR_WO(provision_cap, SDSI_SIZE_WRITE_MSG);\n\nstatic ssize_t\ncertificate_read(u64 command, struct sdsi_priv *priv, char *buf, loff_t off,\n\t\t size_t count)\n{\n\tstruct sdsi_mbox_info info;\n\tsize_t size;\n\tint ret;\n\n\tif (off)\n\t\treturn 0;\n\n\t \n\tinfo.buffer = kmalloc(SDSI_SIZE_READ_MSG, GFP_KERNEL);\n\tif (!info.buffer)\n\t\treturn -ENOMEM;\n\n\tinfo.payload = &command;\n\tinfo.size = sizeof(command);\n\n\tret = mutex_lock_interruptible(&priv->mb_lock);\n\tif (ret)\n\t\tgoto free_buffer;\n\tret = sdsi_mbox_read(priv, &info, &size);\n\tmutex_unlock(&priv->mb_lock);\n\tif (ret < 0)\n\t\tgoto free_buffer;\n\n\tif (size > count)\n\t\tsize = count;\n\n\tmemcpy(buf, info.buffer, size);\n\nfree_buffer:\n\tkfree(info.buffer);\n\n\tif (ret)\n\t\treturn ret;\n\n\treturn size;\n}\n\nstatic ssize_t\nstate_certificate_read(struct file *filp, struct kobject *kobj,\n\t\t       struct bin_attribute *attr, char *buf, loff_t off,\n\t\t       size_t count)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct sdsi_priv *priv = dev_get_drvdata(dev);\n\n\treturn certificate_read(SDSI_CMD_READ_STATE, priv, buf, off, count);\n}\nstatic BIN_ATTR_ADMIN_RO(state_certificate, SDSI_SIZE_READ_MSG);\n\nstatic ssize_t\nmeter_certificate_read(struct file *filp, struct kobject *kobj,\n\t\t       struct bin_attribute *attr, char *buf, loff_t off,\n\t\t       size_t count)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct sdsi_priv *priv = dev_get_drvdata(dev);\n\n\treturn certificate_read(SDSI_CMD_READ_METER, priv, buf, off, count);\n}\nstatic BIN_ATTR_ADMIN_RO(meter_certificate, SDSI_SIZE_READ_MSG);\n\nstatic ssize_t registers_read(struct file *filp, struct kobject *kobj,\n\t\t\t      struct bin_attribute *attr, char *buf, loff_t off,\n\t\t\t      size_t count)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct sdsi_priv *priv = dev_get_drvdata(dev);\n\tvoid __iomem *addr = priv->regs_addr;\n\tint size =  priv->registers_size;\n\n\t \n\tif (off >= size)\n\t\treturn 0;\n\n\tif (off + count > size)\n\t\tcount = size - off;\n\n\tmemcpy_fromio(buf, addr + off, count);\n\n\treturn count;\n}\nstatic BIN_ATTR_ADMIN_RO(registers, SDSI_SIZE_REGS);\n\nstatic struct bin_attribute *sdsi_bin_attrs[] = {\n\t&bin_attr_registers,\n\t&bin_attr_state_certificate,\n\t&bin_attr_meter_certificate,\n\t&bin_attr_provision_akc,\n\t&bin_attr_provision_cap,\n\tNULL\n};\n\nstatic umode_t\nsdsi_battr_is_visible(struct kobject *kobj, struct bin_attribute *attr, int n)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct sdsi_priv *priv = dev_get_drvdata(dev);\n\n\t \n\tif (attr == &bin_attr_registers)\n\t\treturn attr->attr.mode;\n\n\t \n\tif (!(priv->features & SDSI_FEATURE_SDSI))\n\t\treturn 0;\n\n\tif (attr == &bin_attr_meter_certificate)\n\t\treturn (priv->features & SDSI_FEATURE_METERING) ?\n\t\t\t\tattr->attr.mode : 0;\n\n\treturn attr->attr.mode;\n}\n\nstatic ssize_t guid_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct sdsi_priv *priv = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"0x%x\\n\", priv->guid);\n}\nstatic DEVICE_ATTR_RO(guid);\n\nstatic struct attribute *sdsi_attrs[] = {\n\t&dev_attr_guid.attr,\n\tNULL\n};\n\nstatic const struct attribute_group sdsi_group = {\n\t.attrs = sdsi_attrs,\n\t.bin_attrs = sdsi_bin_attrs,\n\t.is_bin_visible = sdsi_battr_is_visible,\n};\n__ATTRIBUTE_GROUPS(sdsi);\n\nstatic int sdsi_get_layout(struct sdsi_priv *priv, struct disc_table *table)\n{\n\tswitch (table->guid) {\n\tcase SDSI_GUID_V1:\n\t\tpriv->control_size = GUID_V1_CNTRL_SIZE;\n\t\tpriv->registers_size = GUID_V1_REGS_SIZE;\n\t\tbreak;\n\tcase SDSI_GUID_V2:\n\t\tpriv->control_size = GUID_V2_CNTRL_SIZE;\n\t\tpriv->registers_size = GUID_V2_REGS_SIZE;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(priv->dev, \"Unrecognized GUID 0x%x\\n\", table->guid);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int sdsi_map_mbox_registers(struct sdsi_priv *priv, struct pci_dev *parent,\n\t\t\t\t   struct disc_table *disc_table, struct resource *disc_res)\n{\n\tu32 access_type = FIELD_GET(DT_ACCESS_TYPE, disc_table->access_info);\n\tu32 size = FIELD_GET(DT_SIZE, disc_table->access_info);\n\tu32 tbir = FIELD_GET(DT_TBIR, disc_table->offset);\n\tu32 offset = DT_OFFSET(disc_table->offset);\n\tstruct resource res = {};\n\n\t \n\tswitch (access_type) {\n\tcase ACCESS_TYPE_LOCAL:\n\t\tif (tbir) {\n\t\t\tdev_err(priv->dev, \"Unsupported BAR index %u for access type %u\\n\",\n\t\t\t\ttbir, access_type);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tres.start = disc_res->end + offset + 1;\n\t\tbreak;\n\n\tcase ACCESS_TYPE_BARID:\n\t\tres.start = pci_resource_start(parent, tbir) + offset;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(priv->dev, \"Unrecognized access_type %u\\n\", access_type);\n\t\treturn -EINVAL;\n\t}\n\n\tres.end = res.start + size * sizeof(u32) - 1;\n\tres.flags = IORESOURCE_MEM;\n\n\tpriv->control_addr = devm_ioremap_resource(priv->dev, &res);\n\tif (IS_ERR(priv->control_addr))\n\t\treturn PTR_ERR(priv->control_addr);\n\n\tpriv->mbox_addr = priv->control_addr + priv->control_size;\n\tpriv->regs_addr = priv->mbox_addr + SDSI_SIZE_MAILBOX;\n\n\tpriv->features = readq(priv->regs_addr + SDSI_ENABLED_FEATURES_OFFSET);\n\n\treturn 0;\n}\n\nstatic int sdsi_probe(struct auxiliary_device *auxdev, const struct auxiliary_device_id *id)\n{\n\tstruct intel_vsec_device *intel_cap_dev = auxdev_to_ivdev(auxdev);\n\tstruct disc_table disc_table;\n\tstruct resource *disc_res;\n\tvoid __iomem *disc_addr;\n\tstruct sdsi_priv *priv;\n\tint ret;\n\n\tpriv = devm_kzalloc(&auxdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->dev = &auxdev->dev;\n\tmutex_init(&priv->mb_lock);\n\tauxiliary_set_drvdata(auxdev, priv);\n\n\t \n\tdisc_res = &intel_cap_dev->resource[0];\n\tdisc_addr = devm_ioremap_resource(&auxdev->dev, disc_res);\n\tif (IS_ERR(disc_addr))\n\t\treturn PTR_ERR(disc_addr);\n\n\tmemcpy_fromio(&disc_table, disc_addr, DISC_TABLE_SIZE);\n\n\tpriv->guid = disc_table.guid;\n\n\t \n\tret = sdsi_get_layout(priv, &disc_table);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = sdsi_map_mbox_registers(priv, intel_cap_dev->pcidev, &disc_table, disc_res);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic const struct auxiliary_device_id sdsi_aux_id_table[] = {\n\t{ .name = \"intel_vsec.sdsi\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(auxiliary, sdsi_aux_id_table);\n\nstatic struct auxiliary_driver sdsi_aux_driver = {\n\t.driver = {\n\t\t.dev_groups = sdsi_groups,\n\t},\n\t.id_table\t= sdsi_aux_id_table,\n\t.probe\t\t= sdsi_probe,\n\t \n};\nmodule_auxiliary_driver(sdsi_aux_driver);\n\nMODULE_AUTHOR(\"David E. Box <david.e.box@linux.intel.com>\");\nMODULE_DESCRIPTION(\"Intel On Demand (SDSi) driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}