{
  "module_name": "core_ssram.c",
  "hash_id": "002636d81103d9218591079f5fb7a2de3978f5ac9d5a0f0aa453bb3a849ce677",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/x86/intel/pmc/core_ssram.c",
  "human_readable_source": "\n \n\n#include <linux/pci.h>\n#include <linux/io-64-nonatomic-lo-hi.h>\n\n#include \"core.h\"\n\n#define SSRAM_HDR_SIZE\t\t0x100\n#define SSRAM_PWRM_OFFSET\t0x14\n#define SSRAM_DVSEC_OFFSET\t0x1C\n#define SSRAM_DVSEC_SIZE\t0x10\n#define SSRAM_PCH_OFFSET\t0x60\n#define SSRAM_IOE_OFFSET\t0x68\n#define SSRAM_DEVID_OFFSET\t0x70\n\nstatic const struct pmc_reg_map *pmc_core_find_regmap(struct pmc_info *list, u16 devid)\n{\n\tfor (; list->map; ++list)\n\t\tif (devid == list->devid)\n\t\t\treturn list->map;\n\n\treturn NULL;\n}\n\nstatic inline u64 get_base(void __iomem *addr, u32 offset)\n{\n\treturn lo_hi_readq(addr + offset) & GENMASK_ULL(63, 3);\n}\n\nstatic void\npmc_core_pmc_add(struct pmc_dev *pmcdev, u64 pwrm_base,\n\t\t const struct pmc_reg_map *reg_map, int pmc_index)\n{\n\tstruct pmc *pmc = pmcdev->pmcs[pmc_index];\n\n\tif (!pwrm_base)\n\t\treturn;\n\n\t \n\tif (!pmc) {\n\t\tpmc = devm_kzalloc(&pmcdev->pdev->dev, sizeof(*pmc), GFP_KERNEL);\n\t\tif (!pmc)\n\t\t\treturn;\n\t}\n\n\tpmc->map = reg_map;\n\tpmc->base_addr = pwrm_base;\n\tpmc->regbase = ioremap(pmc->base_addr, pmc->map->regmap_length);\n\n\tif (!pmc->regbase) {\n\t\tdevm_kfree(&pmcdev->pdev->dev, pmc);\n\t\treturn;\n\t}\n\n\tpmcdev->pmcs[pmc_index] = pmc;\n}\n\nstatic void\npmc_core_ssram_get_pmc(struct pmc_dev *pmcdev, void __iomem *ssram, u32 offset,\n\t\t       int pmc_idx)\n{\n\tu64 pwrm_base;\n\tu16 devid;\n\n\tif (pmc_idx != PMC_IDX_SOC) {\n\t\tu64 ssram_base = get_base(ssram, offset);\n\n\t\tif (!ssram_base)\n\t\t\treturn;\n\n\t\tssram = ioremap(ssram_base, SSRAM_HDR_SIZE);\n\t\tif (!ssram)\n\t\t\treturn;\n\t}\n\n\tpwrm_base = get_base(ssram, SSRAM_PWRM_OFFSET);\n\tdevid = readw(ssram + SSRAM_DEVID_OFFSET);\n\n\tif (pmcdev->regmap_list) {\n\t\tconst struct pmc_reg_map *map;\n\n\t\tmap = pmc_core_find_regmap(pmcdev->regmap_list, devid);\n\t\tif (map)\n\t\t\tpmc_core_pmc_add(pmcdev, pwrm_base, map, pmc_idx);\n\t}\n\n\tif (pmc_idx != PMC_IDX_SOC)\n\t\tiounmap(ssram);\n}\n\nvoid pmc_core_ssram_init(struct pmc_dev *pmcdev)\n{\n\tvoid __iomem *ssram;\n\tstruct pci_dev *pcidev;\n\tu64 ssram_base;\n\tint ret;\n\n\tpcidev = pci_get_domain_bus_and_slot(0, 0, PCI_DEVFN(20, 2));\n\tif (!pcidev)\n\t\tgoto out;\n\n\tret = pcim_enable_device(pcidev);\n\tif (ret)\n\t\tgoto release_dev;\n\n\tssram_base = pcidev->resource[0].start;\n\tssram = ioremap(ssram_base, SSRAM_HDR_SIZE);\n\tif (!ssram)\n\t\tgoto disable_dev;\n\n\tpmcdev->ssram_pcidev = pcidev;\n\n\tpmc_core_ssram_get_pmc(pmcdev, ssram, 0, PMC_IDX_SOC);\n\tpmc_core_ssram_get_pmc(pmcdev, ssram, SSRAM_IOE_OFFSET, PMC_IDX_IOE);\n\tpmc_core_ssram_get_pmc(pmcdev, ssram, SSRAM_PCH_OFFSET, PMC_IDX_PCH);\n\n\tiounmap(ssram);\nout:\n\treturn;\n\ndisable_dev:\n\tpci_disable_device(pcidev);\nrelease_dev:\n\tpci_dev_put(pcidev);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}