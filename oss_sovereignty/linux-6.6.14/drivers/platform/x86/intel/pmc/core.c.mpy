{
  "module_name": "core.c",
  "hash_id": "819225ffdfb49b98e25a6b2833838541d417c78e3ef278051db0082557f56531",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/x86/intel/pmc/core.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/bitfield.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/dmi.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n\n#include <asm/cpu_device_id.h>\n#include <asm/intel-family.h>\n#include <asm/msr.h>\n#include <asm/tsc.h>\n\n#include \"core.h\"\n\n \nconst char *pmc_lpm_modes[] = {\n\t\"S0i2.0\",\n\t\"S0i2.1\",\n\t\"S0i2.2\",\n\t\"S0i3.0\",\n\t\"S0i3.1\",\n\t\"S0i3.2\",\n\t\"S0i3.3\",\n\t\"S0i3.4\",\n\tNULL\n};\n\n \nconst struct pmc_bit_map msr_map[] = {\n\t{\"Package C2\",                  MSR_PKG_C2_RESIDENCY},\n\t{\"Package C3\",                  MSR_PKG_C3_RESIDENCY},\n\t{\"Package C6\",                  MSR_PKG_C6_RESIDENCY},\n\t{\"Package C7\",                  MSR_PKG_C7_RESIDENCY},\n\t{\"Package C8\",                  MSR_PKG_C8_RESIDENCY},\n\t{\"Package C9\",                  MSR_PKG_C9_RESIDENCY},\n\t{\"Package C10\",                 MSR_PKG_C10_RESIDENCY},\n\t{}\n};\n\nstatic inline u32 pmc_core_reg_read(struct pmc *pmc, int reg_offset)\n{\n\treturn readl(pmc->regbase + reg_offset);\n}\n\nstatic inline void pmc_core_reg_write(struct pmc *pmc, int reg_offset,\n\t\t\t\t      u32 val)\n{\n\twritel(val, pmc->regbase + reg_offset);\n}\n\nstatic inline u64 pmc_core_adjust_slp_s0_step(struct pmc *pmc, u32 value)\n{\n\t \n\tconst int lpm_adj_x2 = pmc->map->lpm_res_counter_step_x2;\n\n\tif (pmc->map == &adl_reg_map)\n\t\treturn (u64)value * GET_X2_COUNTER((u64)lpm_adj_x2);\n\telse\n\t\treturn (u64)value * pmc->map->slp_s0_res_counter_step;\n}\n\nstatic int set_etr3(struct pmc_dev *pmcdev)\n{\n\tstruct pmc *pmc = pmcdev->pmcs[PMC_IDX_MAIN];\n\tconst struct pmc_reg_map *map = pmc->map;\n\tu32 reg;\n\tint err;\n\n\tif (!map->etr3_offset)\n\t\treturn -EOPNOTSUPP;\n\n\tmutex_lock(&pmcdev->lock);\n\n\t \n\treg = pmc_core_reg_read(pmc, map->etr3_offset);\n\tif (reg & ETR3_CF9LOCK) {\n\t\terr = -EACCES;\n\t\tgoto out_unlock;\n\t}\n\n\t \n\treg |= ETR3_CF9GR;\n\tpmc_core_reg_write(pmc, map->etr3_offset, reg);\n\n\treg = pmc_core_reg_read(pmc, map->etr3_offset);\n\tif (!(reg & ETR3_CF9GR)) {\n\t\terr = -EIO;\n\t\tgoto out_unlock;\n\t}\n\n\terr = 0;\n\nout_unlock:\n\tmutex_unlock(&pmcdev->lock);\n\treturn err;\n}\nstatic umode_t etr3_is_visible(struct kobject *kobj,\n\t\t\t\tstruct attribute *attr,\n\t\t\t\tint idx)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct pmc_dev *pmcdev = dev_get_drvdata(dev);\n\tstruct pmc *pmc = pmcdev->pmcs[PMC_IDX_MAIN];\n\tconst struct pmc_reg_map *map = pmc->map;\n\tu32 reg;\n\n\tmutex_lock(&pmcdev->lock);\n\treg = pmc_core_reg_read(pmc, map->etr3_offset);\n\tmutex_unlock(&pmcdev->lock);\n\n\treturn reg & ETR3_CF9LOCK ? attr->mode & (SYSFS_PREALLOC | 0444) : attr->mode;\n}\n\nstatic ssize_t etr3_show(struct device *dev,\n\t\t\t\t struct device_attribute *attr, char *buf)\n{\n\tstruct pmc_dev *pmcdev = dev_get_drvdata(dev);\n\tstruct pmc *pmc = pmcdev->pmcs[PMC_IDX_MAIN];\n\tconst struct pmc_reg_map *map = pmc->map;\n\tu32 reg;\n\n\tif (!map->etr3_offset)\n\t\treturn -EOPNOTSUPP;\n\n\tmutex_lock(&pmcdev->lock);\n\n\treg = pmc_core_reg_read(pmc, map->etr3_offset);\n\treg &= ETR3_CF9GR | ETR3_CF9LOCK;\n\n\tmutex_unlock(&pmcdev->lock);\n\n\treturn sysfs_emit(buf, \"0x%08x\", reg);\n}\n\nstatic ssize_t etr3_store(struct device *dev,\n\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t  const char *buf, size_t len)\n{\n\tstruct pmc_dev *pmcdev = dev_get_drvdata(dev);\n\tint err;\n\tu32 reg;\n\n\terr = kstrtouint(buf, 16, &reg);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (reg != ETR3_CF9GR)\n\t\treturn -EINVAL;\n\n\terr = set_etr3(pmcdev);\n\tif (err)\n\t\treturn err;\n\n\treturn len;\n}\nstatic DEVICE_ATTR_RW(etr3);\n\nstatic struct attribute *pmc_attrs[] = {\n\t&dev_attr_etr3.attr,\n\tNULL\n};\n\nstatic const struct attribute_group pmc_attr_group = {\n\t.attrs = pmc_attrs,\n\t.is_visible = etr3_is_visible,\n};\n\nstatic const struct attribute_group *pmc_dev_groups[] = {\n\t&pmc_attr_group,\n\tNULL\n};\n\nstatic int pmc_core_dev_state_get(void *data, u64 *val)\n{\n\tstruct pmc *pmc = data;\n\tconst struct pmc_reg_map *map = pmc->map;\n\tu32 value;\n\n\tvalue = pmc_core_reg_read(pmc, map->slp_s0_offset);\n\t*val = pmc_core_adjust_slp_s0_step(pmc, value);\n\n\treturn 0;\n}\n\nDEFINE_DEBUGFS_ATTRIBUTE(pmc_core_dev_state, pmc_core_dev_state_get, NULL, \"%llu\\n\");\n\nstatic int pmc_core_check_read_lock_bit(struct pmc *pmc)\n{\n\tu32 value;\n\n\tvalue = pmc_core_reg_read(pmc, pmc->map->pm_cfg_offset);\n\treturn value & BIT(pmc->map->pm_read_disable_bit);\n}\n\nstatic void pmc_core_slps0_display(struct pmc *pmc, struct device *dev,\n\t\t\t\t   struct seq_file *s)\n{\n\tconst struct pmc_bit_map **maps = pmc->map->slps0_dbg_maps;\n\tconst struct pmc_bit_map *map;\n\tint offset = pmc->map->slps0_dbg_offset;\n\tu32 data;\n\n\twhile (*maps) {\n\t\tmap = *maps;\n\t\tdata = pmc_core_reg_read(pmc, offset);\n\t\toffset += 4;\n\t\twhile (map->name) {\n\t\t\tif (dev)\n\t\t\t\tdev_info(dev, \"SLP_S0_DBG: %-32s\\tState: %s\\n\",\n\t\t\t\t\tmap->name,\n\t\t\t\t\tdata & map->bit_mask ? \"Yes\" : \"No\");\n\t\t\tif (s)\n\t\t\t\tseq_printf(s, \"SLP_S0_DBG: %-32s\\tState: %s\\n\",\n\t\t\t\t\t   map->name,\n\t\t\t\t\t   data & map->bit_mask ? \"Yes\" : \"No\");\n\t\t\t++map;\n\t\t}\n\t\t++maps;\n\t}\n}\n\nstatic int pmc_core_lpm_get_arr_size(const struct pmc_bit_map **maps)\n{\n\tint idx;\n\n\tfor (idx = 0; maps[idx]; idx++)\n\t\t; \n\n\treturn idx;\n}\n\nstatic void pmc_core_lpm_display(struct pmc *pmc, struct device *dev,\n\t\t\t\t struct seq_file *s, u32 offset, int pmc_index,\n\t\t\t\t const char *str,\n\t\t\t\t const struct pmc_bit_map **maps)\n{\n\tint index, idx, len = 32, bit_mask, arr_size;\n\tu32 *lpm_regs;\n\n\tarr_size = pmc_core_lpm_get_arr_size(maps);\n\tlpm_regs = kmalloc_array(arr_size, sizeof(*lpm_regs), GFP_KERNEL);\n\tif (!lpm_regs)\n\t\treturn;\n\n\tfor (index = 0; index < arr_size; index++) {\n\t\tlpm_regs[index] = pmc_core_reg_read(pmc, offset);\n\t\toffset += 4;\n\t}\n\n\tfor (idx = 0; idx < arr_size; idx++) {\n\t\tif (dev)\n\t\t\tdev_info(dev, \"\\nPMC%d:LPM_%s_%d:\\t0x%x\\n\", pmc_index, str, idx,\n\t\t\t\tlpm_regs[idx]);\n\t\tif (s)\n\t\t\tseq_printf(s, \"\\nPMC%d:LPM_%s_%d:\\t0x%x\\n\", pmc_index, str, idx,\n\t\t\t\t   lpm_regs[idx]);\n\t\tfor (index = 0; maps[idx][index].name && index < len; index++) {\n\t\t\tbit_mask = maps[idx][index].bit_mask;\n\t\t\tif (dev)\n\t\t\t\tdev_info(dev, \"PMC%d:%-30s %-30d\\n\", pmc_index,\n\t\t\t\t\tmaps[idx][index].name,\n\t\t\t\t\tlpm_regs[idx] & bit_mask ? 1 : 0);\n\t\t\tif (s)\n\t\t\t\tseq_printf(s, \"PMC%d:%-30s %-30d\\n\", pmc_index,\n\t\t\t\t\t   maps[idx][index].name,\n\t\t\t\t\t   lpm_regs[idx] & bit_mask ? 1 : 0);\n\t\t}\n\t}\n\n\tkfree(lpm_regs);\n}\n\nstatic bool slps0_dbg_latch;\n\nstatic inline u8 pmc_core_reg_read_byte(struct pmc *pmc, int offset)\n{\n\treturn readb(pmc->regbase + offset);\n}\n\nstatic void pmc_core_display_map(struct seq_file *s, int index, int idx, int ip,\n\t\t\t\t int pmc_index, u8 pf_reg, const struct pmc_bit_map **pf_map)\n{\n\tseq_printf(s, \"PMC%d:PCH IP: %-2d - %-32s\\tState: %s\\n\",\n\t\t   pmc_index, ip, pf_map[idx][index].name,\n\t\t   pf_map[idx][index].bit_mask & pf_reg ? \"Off\" : \"On\");\n}\n\nstatic int pmc_core_ppfear_show(struct seq_file *s, void *unused)\n{\n\tstruct pmc_dev *pmcdev = s->private;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(pmcdev->pmcs); ++i) {\n\t\tstruct pmc *pmc = pmcdev->pmcs[i];\n\t\tconst struct pmc_bit_map **maps;\n\t\tu8 pf_regs[PPFEAR_MAX_NUM_ENTRIES];\n\t\tint index, iter, idx, ip = 0;\n\n\t\tif (!pmc)\n\t\t\tcontinue;\n\n\t\tmaps = pmc->map->pfear_sts;\n\t\titer = pmc->map->ppfear0_offset;\n\n\t\tfor (index = 0; index < pmc->map->ppfear_buckets &&\n\t\t     index < PPFEAR_MAX_NUM_ENTRIES; index++, iter++)\n\t\t\tpf_regs[index] = pmc_core_reg_read_byte(pmc, iter);\n\n\t\tfor (idx = 0; maps[idx]; idx++) {\n\t\t\tfor (index = 0; maps[idx][index].name &&\n\t\t\t     index < pmc->map->ppfear_buckets * 8; ip++, index++)\n\t\t\t\tpmc_core_display_map(s, index, idx, ip, i,\n\t\t\t\t\t\t     pf_regs[index / 8], maps);\n\t\t}\n\t}\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(pmc_core_ppfear);\n\n \nstatic int pmc_core_mtpmc_link_status(struct pmc *pmc)\n{\n\tu32 value;\n\n\tvalue = pmc_core_reg_read(pmc, SPT_PMC_PM_STS_OFFSET);\n\treturn value & BIT(SPT_PMC_MSG_FULL_STS_BIT);\n}\n\nstatic int pmc_core_send_msg(struct pmc *pmc, u32 *addr_xram)\n{\n\tu32 dest;\n\tint timeout;\n\n\tfor (timeout = NUM_RETRIES; timeout > 0; timeout--) {\n\t\tif (pmc_core_mtpmc_link_status(pmc) == 0)\n\t\t\tbreak;\n\t\tmsleep(5);\n\t}\n\n\tif (timeout <= 0 && pmc_core_mtpmc_link_status(pmc))\n\t\treturn -EBUSY;\n\n\tdest = (*addr_xram & MTPMC_MASK) | (1U << 1);\n\tpmc_core_reg_write(pmc, SPT_PMC_MTPMC_OFFSET, dest);\n\treturn 0;\n}\n\nstatic int pmc_core_mphy_pg_show(struct seq_file *s, void *unused)\n{\n\tstruct pmc_dev *pmcdev = s->private;\n\tstruct pmc *pmc = pmcdev->pmcs[PMC_IDX_MAIN];\n\tconst struct pmc_bit_map *map = pmc->map->mphy_sts;\n\tu32 mphy_core_reg_low, mphy_core_reg_high;\n\tu32 val_low, val_high;\n\tint index, err = 0;\n\n\tif (pmcdev->pmc_xram_read_bit) {\n\t\tseq_puts(s, \"Access denied: please disable PMC_READ_DISABLE setting in BIOS.\");\n\t\treturn 0;\n\t}\n\n\tmphy_core_reg_low  = (SPT_PMC_MPHY_CORE_STS_0 << 16);\n\tmphy_core_reg_high = (SPT_PMC_MPHY_CORE_STS_1 << 16);\n\n\tmutex_lock(&pmcdev->lock);\n\n\tif (pmc_core_send_msg(pmc, &mphy_core_reg_low) != 0) {\n\t\terr = -EBUSY;\n\t\tgoto out_unlock;\n\t}\n\n\tmsleep(10);\n\tval_low = pmc_core_reg_read(pmc, SPT_PMC_MFPMC_OFFSET);\n\n\tif (pmc_core_send_msg(pmc, &mphy_core_reg_high) != 0) {\n\t\terr = -EBUSY;\n\t\tgoto out_unlock;\n\t}\n\n\tmsleep(10);\n\tval_high = pmc_core_reg_read(pmc, SPT_PMC_MFPMC_OFFSET);\n\n\tfor (index = 0; index < 8 && map[index].name; index++) {\n\t\tseq_printf(s, \"%-32s\\tState: %s\\n\",\n\t\t\t   map[index].name,\n\t\t\t   map[index].bit_mask & val_low ? \"Not power gated\" :\n\t\t\t   \"Power gated\");\n\t}\n\n\tfor (index = 8; map[index].name; index++) {\n\t\tseq_printf(s, \"%-32s\\tState: %s\\n\",\n\t\t\t   map[index].name,\n\t\t\t   map[index].bit_mask & val_high ? \"Not power gated\" :\n\t\t\t   \"Power gated\");\n\t}\n\nout_unlock:\n\tmutex_unlock(&pmcdev->lock);\n\treturn err;\n}\nDEFINE_SHOW_ATTRIBUTE(pmc_core_mphy_pg);\n\nstatic int pmc_core_pll_show(struct seq_file *s, void *unused)\n{\n\tstruct pmc_dev *pmcdev = s->private;\n\tstruct pmc *pmc = pmcdev->pmcs[PMC_IDX_MAIN];\n\tconst struct pmc_bit_map *map = pmc->map->pll_sts;\n\tu32 mphy_common_reg, val;\n\tint index, err = 0;\n\n\tif (pmcdev->pmc_xram_read_bit) {\n\t\tseq_puts(s, \"Access denied: please disable PMC_READ_DISABLE setting in BIOS.\");\n\t\treturn 0;\n\t}\n\n\tmphy_common_reg  = (SPT_PMC_MPHY_COM_STS_0 << 16);\n\tmutex_lock(&pmcdev->lock);\n\n\tif (pmc_core_send_msg(pmc, &mphy_common_reg) != 0) {\n\t\terr = -EBUSY;\n\t\tgoto out_unlock;\n\t}\n\n\t \n\tmsleep(10);\n\tval = pmc_core_reg_read(pmc, SPT_PMC_MFPMC_OFFSET);\n\n\tfor (index = 0; map[index].name ; index++) {\n\t\tseq_printf(s, \"%-32s\\tState: %s\\n\",\n\t\t\t   map[index].name,\n\t\t\t   map[index].bit_mask & val ? \"Active\" : \"Idle\");\n\t}\n\nout_unlock:\n\tmutex_unlock(&pmcdev->lock);\n\treturn err;\n}\nDEFINE_SHOW_ATTRIBUTE(pmc_core_pll);\n\nint pmc_core_send_ltr_ignore(struct pmc_dev *pmcdev, u32 value, int ignore)\n{\n\tstruct pmc *pmc;\n\tconst struct pmc_reg_map *map;\n\tu32 reg;\n\tint pmc_index, ltr_index;\n\n\tltr_index = value;\n\t \n\tfor (pmc_index = 0; pmc_index < ARRAY_SIZE(pmcdev->pmcs) && ltr_index >= 0; pmc_index++) {\n\t\tpmc = pmcdev->pmcs[pmc_index];\n\n\t\tif (!pmc)\n\t\t\tcontinue;\n\n\t\tmap = pmc->map;\n\t\tif (ltr_index <= map->ltr_ignore_max)\n\t\t\tbreak;\n\n\t\t \n\t\tltr_index = ltr_index - (map->ltr_ignore_max + 2) - 1;\n\t}\n\n\tif (pmc_index >= ARRAY_SIZE(pmcdev->pmcs) || ltr_index < 0)\n\t\treturn -EINVAL;\n\n\tpr_debug(\"ltr_ignore for pmc%d: ltr_index:%d\\n\", pmc_index, ltr_index);\n\n\tmutex_lock(&pmcdev->lock);\n\n\treg = pmc_core_reg_read(pmc, map->ltr_ignore_offset);\n\tif (ignore)\n\t\treg |= BIT(ltr_index);\n\telse\n\t\treg &= ~BIT(ltr_index);\n\tpmc_core_reg_write(pmc, map->ltr_ignore_offset, reg);\n\n\tmutex_unlock(&pmcdev->lock);\n\n\treturn 0;\n}\n\nstatic ssize_t pmc_core_ltr_ignore_write(struct file *file,\n\t\t\t\t\t const char __user *userbuf,\n\t\t\t\t\t size_t count, loff_t *ppos)\n{\n\tstruct seq_file *s = file->private_data;\n\tstruct pmc_dev *pmcdev = s->private;\n\tu32 buf_size, value;\n\tint err;\n\n\tbuf_size = min_t(u32, count, 64);\n\n\terr = kstrtou32_from_user(userbuf, buf_size, 10, &value);\n\tif (err)\n\t\treturn err;\n\n\terr = pmc_core_send_ltr_ignore(pmcdev, value, 1);\n\n\treturn err == 0 ? count : err;\n}\n\nstatic int pmc_core_ltr_ignore_show(struct seq_file *s, void *unused)\n{\n\treturn 0;\n}\n\nstatic int pmc_core_ltr_ignore_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, pmc_core_ltr_ignore_show, inode->i_private);\n}\n\nstatic const struct file_operations pmc_core_ltr_ignore_ops = {\n\t.open           = pmc_core_ltr_ignore_open,\n\t.read           = seq_read,\n\t.write          = pmc_core_ltr_ignore_write,\n\t.llseek         = seq_lseek,\n\t.release        = single_release,\n};\n\nstatic void pmc_core_slps0_dbg_latch(struct pmc_dev *pmcdev, bool reset)\n{\n\tstruct pmc *pmc = pmcdev->pmcs[PMC_IDX_MAIN];\n\tconst struct pmc_reg_map *map = pmc->map;\n\tu32 fd;\n\n\tmutex_lock(&pmcdev->lock);\n\n\tif (!reset && !slps0_dbg_latch)\n\t\tgoto out_unlock;\n\n\tfd = pmc_core_reg_read(pmc, map->slps0_dbg_offset);\n\tif (reset)\n\t\tfd &= ~CNP_PMC_LATCH_SLPS0_EVENTS;\n\telse\n\t\tfd |= CNP_PMC_LATCH_SLPS0_EVENTS;\n\tpmc_core_reg_write(pmc, map->slps0_dbg_offset, fd);\n\n\tslps0_dbg_latch = false;\n\nout_unlock:\n\tmutex_unlock(&pmcdev->lock);\n}\n\nstatic int pmc_core_slps0_dbg_show(struct seq_file *s, void *unused)\n{\n\tstruct pmc_dev *pmcdev = s->private;\n\n\tpmc_core_slps0_dbg_latch(pmcdev, false);\n\tpmc_core_slps0_display(pmcdev->pmcs[PMC_IDX_MAIN], NULL, s);\n\tpmc_core_slps0_dbg_latch(pmcdev, true);\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(pmc_core_slps0_dbg);\n\nstatic u32 convert_ltr_scale(u32 val)\n{\n\t \n\tif (val > 5) {\n\t\tpr_warn(\"Invalid LTR scale factor.\\n\");\n\t\treturn 0;\n\t}\n\n\treturn 1U << (5 * val);\n}\n\nstatic int pmc_core_ltr_show(struct seq_file *s, void *unused)\n{\n\tstruct pmc_dev *pmcdev = s->private;\n\tu64 decoded_snoop_ltr, decoded_non_snoop_ltr;\n\tu32 ltr_raw_data, scale, val;\n\tu16 snoop_ltr, nonsnoop_ltr;\n\tint i, index, ltr_index = 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(pmcdev->pmcs); ++i) {\n\t\tstruct pmc *pmc = pmcdev->pmcs[i];\n\t\tconst struct pmc_bit_map *map;\n\n\t\tif (!pmc)\n\t\t\tcontinue;\n\n\t\tmap = pmc->map->ltr_show_sts;\n\t\tfor (index = 0; map[index].name; index++) {\n\t\t\tdecoded_snoop_ltr = decoded_non_snoop_ltr = 0;\n\t\t\tltr_raw_data = pmc_core_reg_read(pmc,\n\t\t\t\t\t\t\t map[index].bit_mask);\n\t\t\tsnoop_ltr = ltr_raw_data & ~MTPMC_MASK;\n\t\t\tnonsnoop_ltr = (ltr_raw_data >> 0x10) & ~MTPMC_MASK;\n\n\t\t\tif (FIELD_GET(LTR_REQ_NONSNOOP, ltr_raw_data)) {\n\t\t\t\tscale = FIELD_GET(LTR_DECODED_SCALE, nonsnoop_ltr);\n\t\t\t\tval = FIELD_GET(LTR_DECODED_VAL, nonsnoop_ltr);\n\t\t\t\tdecoded_non_snoop_ltr = val * convert_ltr_scale(scale);\n\t\t\t}\n\t\t\tif (FIELD_GET(LTR_REQ_SNOOP, ltr_raw_data)) {\n\t\t\t\tscale = FIELD_GET(LTR_DECODED_SCALE, snoop_ltr);\n\t\t\t\tval = FIELD_GET(LTR_DECODED_VAL, snoop_ltr);\n\t\t\t\tdecoded_snoop_ltr = val * convert_ltr_scale(scale);\n\t\t\t}\n\n\t\t\tseq_printf(s, \"%d\\tPMC%d:%-32s\\tLTR: RAW: 0x%-16x\\tNon-Snoop(ns): %-16llu\\tSnoop(ns): %-16llu\\n\",\n\t\t\t\t   ltr_index, i, map[index].name, ltr_raw_data,\n\t\t\t\t   decoded_non_snoop_ltr,\n\t\t\t\t   decoded_snoop_ltr);\n\t\t\tltr_index++;\n\t\t}\n\t}\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(pmc_core_ltr);\n\nstatic inline u64 adjust_lpm_residency(struct pmc *pmc, u32 offset,\n\t\t\t\t       const int lpm_adj_x2)\n{\n\tu64 lpm_res = pmc_core_reg_read(pmc, offset);\n\n\treturn GET_X2_COUNTER((u64)lpm_adj_x2 * lpm_res);\n}\n\nstatic int pmc_core_substate_res_show(struct seq_file *s, void *unused)\n{\n\tstruct pmc_dev *pmcdev = s->private;\n\tstruct pmc *pmc = pmcdev->pmcs[PMC_IDX_MAIN];\n\tconst int lpm_adj_x2 = pmc->map->lpm_res_counter_step_x2;\n\tu32 offset = pmc->map->lpm_residency_offset;\n\tint i, mode;\n\n\tseq_printf(s, \"%-10s %-15s\\n\", \"Substate\", \"Residency\");\n\n\tpmc_for_each_mode(i, mode, pmcdev) {\n\t\tseq_printf(s, \"%-10s %-15llu\\n\", pmc_lpm_modes[mode],\n\t\t\t   adjust_lpm_residency(pmc, offset + (4 * mode), lpm_adj_x2));\n\t}\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(pmc_core_substate_res);\n\nstatic int pmc_core_substate_sts_regs_show(struct seq_file *s, void *unused)\n{\n\tstruct pmc_dev *pmcdev = s->private;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(pmcdev->pmcs); ++i) {\n\t\tstruct pmc *pmc = pmcdev->pmcs[i];\n\t\tconst struct pmc_bit_map **maps;\n\t\tu32 offset;\n\n\t\tif (!pmc)\n\t\t\tcontinue;\n\t\tmaps = pmc->map->lpm_sts;\n\t\toffset = pmc->map->lpm_status_offset;\n\t\tpmc_core_lpm_display(pmc, NULL, s, offset, i, \"STATUS\", maps);\n\t}\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(pmc_core_substate_sts_regs);\n\nstatic int pmc_core_substate_l_sts_regs_show(struct seq_file *s, void *unused)\n{\n\tstruct pmc_dev *pmcdev = s->private;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(pmcdev->pmcs); ++i) {\n\t\tstruct pmc *pmc = pmcdev->pmcs[i];\n\t\tconst struct pmc_bit_map **maps;\n\t\tu32 offset;\n\n\t\tif (!pmc)\n\t\t\tcontinue;\n\t\tmaps = pmc->map->lpm_sts;\n\t\toffset = pmc->map->lpm_live_status_offset;\n\t\tpmc_core_lpm_display(pmc, NULL, s, offset, i, \"LIVE_STATUS\", maps);\n\t}\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(pmc_core_substate_l_sts_regs);\n\nstatic void pmc_core_substate_req_header_show(struct seq_file *s)\n{\n\tstruct pmc_dev *pmcdev = s->private;\n\tint i, mode;\n\n\tseq_printf(s, \"%30s |\", \"Element\");\n\tpmc_for_each_mode(i, mode, pmcdev)\n\t\tseq_printf(s, \" %9s |\", pmc_lpm_modes[mode]);\n\n\tseq_printf(s, \" %9s |\\n\", \"Status\");\n}\n\nstatic int pmc_core_substate_req_regs_show(struct seq_file *s, void *unused)\n{\n\tstruct pmc_dev *pmcdev = s->private;\n\tstruct pmc *pmc = pmcdev->pmcs[PMC_IDX_MAIN];\n\tconst struct pmc_bit_map **maps = pmc->map->lpm_sts;\n\tconst struct pmc_bit_map *map;\n\tconst int num_maps = pmc->map->lpm_num_maps;\n\tu32 sts_offset = pmc->map->lpm_status_offset;\n\tu32 *lpm_req_regs = pmc->lpm_req_regs;\n\tint mp;\n\n\t \n\tpmc_core_substate_req_header_show(s);\n\n\t \n\tfor (mp = 0; mp < num_maps; mp++) {\n\t\tu32 req_mask = 0;\n\t\tu32 lpm_status;\n\t\tint mode, idx, i, len = 32;\n\n\t\t \n\t\tpmc_for_each_mode(idx, mode, pmcdev)\n\t\t\treq_mask |= lpm_req_regs[mp + (mode * num_maps)];\n\n\t\t \n\t\tlpm_status = pmc_core_reg_read(pmc, sts_offset + (mp * 4));\n\n\t\t \n\t\tmap = maps[mp];\n\t\tfor (i = 0; map[i].name && i < len; i++) {\n\t\t\tu32 bit_mask = map[i].bit_mask;\n\n\t\t\tif (!(bit_mask & req_mask))\n\t\t\t\t \n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tseq_printf(s, \"%30s |\", map[i].name);\n\n\t\t\t \n\t\t\tpmc_for_each_mode(idx, mode, pmcdev) {\n\t\t\t\tif (lpm_req_regs[mp + (mode * num_maps)] & bit_mask)\n\t\t\t\t\tseq_printf(s, \" %9s |\",\n\t\t\t\t\t\t   \"Required\");\n\t\t\t\telse\n\t\t\t\t\tseq_printf(s, \" %9s |\", \" \");\n\t\t\t}\n\n\t\t\t \n\t\t\tif (lpm_status & bit_mask)\n\t\t\t\tseq_printf(s, \" %9s |\", \"Yes\");\n\t\t\telse\n\t\t\t\tseq_printf(s, \" %9s |\", \" \");\n\n\t\t\tseq_puts(s, \"\\n\");\n\t\t}\n\t}\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(pmc_core_substate_req_regs);\n\nstatic int pmc_core_lpm_latch_mode_show(struct seq_file *s, void *unused)\n{\n\tstruct pmc_dev *pmcdev = s->private;\n\tstruct pmc *pmc = pmcdev->pmcs[PMC_IDX_MAIN];\n\tbool c10;\n\tu32 reg;\n\tint idx, mode;\n\n\treg = pmc_core_reg_read(pmc, pmc->map->lpm_sts_latch_en_offset);\n\tif (reg & LPM_STS_LATCH_MODE) {\n\t\tseq_puts(s, \"c10\");\n\t\tc10 = false;\n\t} else {\n\t\tseq_puts(s, \"[c10]\");\n\t\tc10 = true;\n\t}\n\n\tpmc_for_each_mode(idx, mode, pmcdev) {\n\t\tif ((BIT(mode) & reg) && !c10)\n\t\t\tseq_printf(s, \" [%s]\", pmc_lpm_modes[mode]);\n\t\telse\n\t\t\tseq_printf(s, \" %s\", pmc_lpm_modes[mode]);\n\t}\n\n\tseq_puts(s, \" clear\\n\");\n\n\treturn 0;\n}\n\nstatic ssize_t pmc_core_lpm_latch_mode_write(struct file *file,\n\t\t\t\t\t     const char __user *userbuf,\n\t\t\t\t\t     size_t count, loff_t *ppos)\n{\n\tstruct seq_file *s = file->private_data;\n\tstruct pmc_dev *pmcdev = s->private;\n\tstruct pmc *pmc = pmcdev->pmcs[PMC_IDX_MAIN];\n\tbool clear = false, c10 = false;\n\tunsigned char buf[8];\n\tint idx, m, mode;\n\tu32 reg;\n\n\tif (count > sizeof(buf) - 1)\n\t\treturn -EINVAL;\n\tif (copy_from_user(buf, userbuf, count))\n\t\treturn -EFAULT;\n\tbuf[count] = '\\0';\n\n\t \n\tmode = sysfs_match_string(pmc_lpm_modes, buf);\n\n\t \n\tpmc_for_each_mode(idx, m, pmcdev)\n\t\tif (mode == m)\n\t\t\tbreak;\n\n\tif (mode != m || mode < 0) {\n\t\tif (sysfs_streq(buf, \"clear\"))\n\t\t\tclear = true;\n\t\telse if (sysfs_streq(buf, \"c10\"))\n\t\t\tc10 = true;\n\t\telse\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (clear) {\n\t\tmutex_lock(&pmcdev->lock);\n\n\t\treg = pmc_core_reg_read(pmc, pmc->map->etr3_offset);\n\t\treg |= ETR3_CLEAR_LPM_EVENTS;\n\t\tpmc_core_reg_write(pmc, pmc->map->etr3_offset, reg);\n\n\t\tmutex_unlock(&pmcdev->lock);\n\n\t\treturn count;\n\t}\n\n\tif (c10) {\n\t\tmutex_lock(&pmcdev->lock);\n\n\t\treg = pmc_core_reg_read(pmc, pmc->map->lpm_sts_latch_en_offset);\n\t\treg &= ~LPM_STS_LATCH_MODE;\n\t\tpmc_core_reg_write(pmc, pmc->map->lpm_sts_latch_en_offset, reg);\n\n\t\tmutex_unlock(&pmcdev->lock);\n\n\t\treturn count;\n\t}\n\n\t \n\treg = LPM_STS_LATCH_MODE | BIT(mode);\n\tmutex_lock(&pmcdev->lock);\n\tpmc_core_reg_write(pmc, pmc->map->lpm_sts_latch_en_offset, reg);\n\tmutex_unlock(&pmcdev->lock);\n\n\treturn count;\n}\nDEFINE_PMC_CORE_ATTR_WRITE(pmc_core_lpm_latch_mode);\n\nstatic int pmc_core_pkgc_show(struct seq_file *s, void *unused)\n{\n\tstruct pmc *pmc = s->private;\n\tconst struct pmc_bit_map *map = pmc->map->msr_sts;\n\tu64 pcstate_count;\n\tint index;\n\n\tfor (index = 0; map[index].name ; index++) {\n\t\tif (rdmsrl_safe(map[index].bit_mask, &pcstate_count))\n\t\t\tcontinue;\n\n\t\tpcstate_count *= 1000;\n\t\tdo_div(pcstate_count, tsc_khz);\n\t\tseq_printf(s, \"%-8s : %llu\\n\", map[index].name,\n\t\t\t   pcstate_count);\n\t}\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(pmc_core_pkgc);\n\nstatic bool pmc_core_pri_verify(u32 lpm_pri, u8 *mode_order)\n{\n\tint i, j;\n\n\tif (!lpm_pri)\n\t\treturn false;\n\t \n\tfor (i = 0; i < 8; i++) {\n\t\tint level = lpm_pri & GENMASK(3, 0);\n\n\t\tif (level >= LPM_MAX_NUM_MODES)\n\t\t\treturn false;\n\n\t\tmode_order[i] = level;\n\t\tlpm_pri >>= 4;\n\t}\n\n\t \n\tfor (i = 0; i < LPM_MAX_NUM_MODES - 1; i++)\n\t\tfor (j = i + 1; j < LPM_MAX_NUM_MODES; j++)\n\t\t\tif (mode_order[i] == mode_order[j])\n\t\t\t\treturn false;\n\n\treturn true;\n}\n\nstatic void pmc_core_get_low_power_modes(struct platform_device *pdev)\n{\n\tstruct pmc_dev *pmcdev = platform_get_drvdata(pdev);\n\tstruct pmc *pmc = pmcdev->pmcs[PMC_IDX_MAIN];\n\tu8 pri_order[LPM_MAX_NUM_MODES] = LPM_DEFAULT_PRI;\n\tu8 mode_order[LPM_MAX_NUM_MODES];\n\tu32 lpm_pri;\n\tu32 lpm_en;\n\tint mode, i, p;\n\n\t \n\tif (!pmc->map->lpm_num_maps)\n\t\treturn;\n\n\tlpm_en = pmc_core_reg_read(pmc, pmc->map->lpm_en_offset);\n\t \n\tpmcdev->num_lpm_modes = hweight32(lpm_en & 0xFF);\n\n\t \n\tlpm_pri = pmc_core_reg_read(pmc, pmc->map->lpm_priority_offset);\n\n\n\t \n\tif (pmc_core_pri_verify(lpm_pri, mode_order))\n\t\t \n\t\tfor (mode = 0; mode < LPM_MAX_NUM_MODES; mode++)\n\t\t\tpri_order[mode_order[mode]] = mode;\n\telse\n\t\tdev_warn(&pdev->dev, \"Assuming a default substate order for this platform\\n\");\n\n\t \n\ti = 0;\n\tfor (p = LPM_MAX_NUM_MODES - 1; p >= 0; p--) {\n\t\tint mode = pri_order[p];\n\n\t\tif (!(BIT(mode) & lpm_en))\n\t\t\tcontinue;\n\n\t\tpmcdev->lpm_en_modes[i++] = mode;\n\t}\n}\n\nint get_primary_reg_base(struct pmc *pmc)\n{\n\tu64 slp_s0_addr;\n\n\tif (lpit_read_residency_count_address(&slp_s0_addr)) {\n\t\tpmc->base_addr = PMC_BASE_ADDR_DEFAULT;\n\n\t\tif (page_is_ram(PHYS_PFN(pmc->base_addr)))\n\t\t\treturn -ENODEV;\n\t} else {\n\t\tpmc->base_addr = slp_s0_addr - pmc->map->slp_s0_offset;\n\t}\n\n\tpmc->regbase = ioremap(pmc->base_addr, pmc->map->regmap_length);\n\tif (!pmc->regbase)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nstatic void pmc_core_dbgfs_unregister(struct pmc_dev *pmcdev)\n{\n\tdebugfs_remove_recursive(pmcdev->dbgfs_dir);\n}\n\nstatic void pmc_core_dbgfs_register(struct pmc_dev *pmcdev)\n{\n\tstruct pmc *primary_pmc = pmcdev->pmcs[PMC_IDX_MAIN];\n\tstruct dentry *dir;\n\n\tdir = debugfs_create_dir(\"pmc_core\", NULL);\n\tpmcdev->dbgfs_dir = dir;\n\n\tdebugfs_create_file(\"slp_s0_residency_usec\", 0444, dir, primary_pmc,\n\t\t\t    &pmc_core_dev_state);\n\n\tif (primary_pmc->map->pfear_sts)\n\t\tdebugfs_create_file(\"pch_ip_power_gating_status\", 0444, dir,\n\t\t\t\t    pmcdev, &pmc_core_ppfear_fops);\n\n\tdebugfs_create_file(\"ltr_ignore\", 0644, dir, pmcdev,\n\t\t\t    &pmc_core_ltr_ignore_ops);\n\n\tdebugfs_create_file(\"ltr_show\", 0444, dir, pmcdev, &pmc_core_ltr_fops);\n\n\tdebugfs_create_file(\"package_cstate_show\", 0444, dir, primary_pmc,\n\t\t\t    &pmc_core_pkgc_fops);\n\n\tif (primary_pmc->map->pll_sts)\n\t\tdebugfs_create_file(\"pll_status\", 0444, dir, pmcdev,\n\t\t\t\t    &pmc_core_pll_fops);\n\n\tif (primary_pmc->map->mphy_sts)\n\t\tdebugfs_create_file(\"mphy_core_lanes_power_gating_status\",\n\t\t\t\t    0444, dir, pmcdev,\n\t\t\t\t    &pmc_core_mphy_pg_fops);\n\n\tif (primary_pmc->map->slps0_dbg_maps) {\n\t\tdebugfs_create_file(\"slp_s0_debug_status\", 0444,\n\t\t\t\t    dir, pmcdev,\n\t\t\t\t    &pmc_core_slps0_dbg_fops);\n\n\t\tdebugfs_create_bool(\"slp_s0_dbg_latch\", 0644,\n\t\t\t\t    dir, &slps0_dbg_latch);\n\t}\n\n\tif (primary_pmc->map->lpm_en_offset) {\n\t\tdebugfs_create_file(\"substate_residencies\", 0444,\n\t\t\t\t    pmcdev->dbgfs_dir, pmcdev,\n\t\t\t\t    &pmc_core_substate_res_fops);\n\t}\n\n\tif (primary_pmc->map->lpm_status_offset) {\n\t\tdebugfs_create_file(\"substate_status_registers\", 0444,\n\t\t\t\t    pmcdev->dbgfs_dir, pmcdev,\n\t\t\t\t    &pmc_core_substate_sts_regs_fops);\n\t\tdebugfs_create_file(\"substate_live_status_registers\", 0444,\n\t\t\t\t    pmcdev->dbgfs_dir, pmcdev,\n\t\t\t\t    &pmc_core_substate_l_sts_regs_fops);\n\t\tdebugfs_create_file(\"lpm_latch_mode\", 0644,\n\t\t\t\t    pmcdev->dbgfs_dir, pmcdev,\n\t\t\t\t    &pmc_core_lpm_latch_mode_fops);\n\t}\n\n\tif (primary_pmc->lpm_req_regs) {\n\t\tdebugfs_create_file(\"substate_requirements\", 0444,\n\t\t\t\t    pmcdev->dbgfs_dir, pmcdev,\n\t\t\t\t    &pmc_core_substate_req_regs_fops);\n\t}\n}\n\nstatic const struct x86_cpu_id intel_pmc_core_ids[] = {\n\tX86_MATCH_INTEL_FAM6_MODEL(SKYLAKE_L,\t\tspt_core_init),\n\tX86_MATCH_INTEL_FAM6_MODEL(SKYLAKE,\t\tspt_core_init),\n\tX86_MATCH_INTEL_FAM6_MODEL(KABYLAKE_L,\t\tspt_core_init),\n\tX86_MATCH_INTEL_FAM6_MODEL(KABYLAKE,\t\tspt_core_init),\n\tX86_MATCH_INTEL_FAM6_MODEL(CANNONLAKE_L,\tcnp_core_init),\n\tX86_MATCH_INTEL_FAM6_MODEL(ICELAKE_L,\t\ticl_core_init),\n\tX86_MATCH_INTEL_FAM6_MODEL(ICELAKE_NNPI,\ticl_core_init),\n\tX86_MATCH_INTEL_FAM6_MODEL(COMETLAKE,\t\tcnp_core_init),\n\tX86_MATCH_INTEL_FAM6_MODEL(COMETLAKE_L,\t\tcnp_core_init),\n\tX86_MATCH_INTEL_FAM6_MODEL(TIGERLAKE_L,\t\ttgl_core_init),\n\tX86_MATCH_INTEL_FAM6_MODEL(TIGERLAKE,\t\ttgl_core_init),\n\tX86_MATCH_INTEL_FAM6_MODEL(ATOM_TREMONT,\ttgl_core_init),\n\tX86_MATCH_INTEL_FAM6_MODEL(ATOM_TREMONT_L,\ticl_core_init),\n\tX86_MATCH_INTEL_FAM6_MODEL(ROCKETLAKE,\t\ttgl_core_init),\n\tX86_MATCH_INTEL_FAM6_MODEL(ALDERLAKE_L,\t\ttgl_core_init),\n\tX86_MATCH_INTEL_FAM6_MODEL(ATOM_GRACEMONT,\ttgl_core_init),\n\tX86_MATCH_INTEL_FAM6_MODEL(ALDERLAKE,\t\tadl_core_init),\n\tX86_MATCH_INTEL_FAM6_MODEL(RAPTORLAKE_P,        tgl_core_init),\n\tX86_MATCH_INTEL_FAM6_MODEL(RAPTORLAKE,\t\tadl_core_init),\n\tX86_MATCH_INTEL_FAM6_MODEL(RAPTORLAKE_S,\tadl_core_init),\n\tX86_MATCH_INTEL_FAM6_MODEL(METEORLAKE_L,\tmtl_core_init),\n\t{}\n};\n\nMODULE_DEVICE_TABLE(x86cpu, intel_pmc_core_ids);\n\nstatic const struct pci_device_id pmc_pci_ids[] = {\n\t{ PCI_VDEVICE(INTEL, SPT_PMC_PCI_DEVICE_ID) },\n\t{ }\n};\n\n \nstatic bool xtal_ignore;\nstatic int quirk_xtal_ignore(const struct dmi_system_id *id)\n{\n\txtal_ignore = true;\n\treturn 0;\n}\n\nstatic void pmc_core_xtal_ignore(struct pmc *pmc)\n{\n\tu32 value;\n\n\tvalue = pmc_core_reg_read(pmc, pmc->map->pm_vric1_offset);\n\t \n\tvalue |= SPT_PMC_VRIC1_XTALSDQDIS;\n\t \n\tvalue &= ~SPT_PMC_VRIC1_SLPS0LVEN;\n\tpmc_core_reg_write(pmc, pmc->map->pm_vric1_offset, value);\n}\n\nstatic const struct dmi_system_id pmc_core_dmi_table[]  = {\n\t{\n\t.callback = quirk_xtal_ignore,\n\t.ident = \"HP Elite x2 1013 G3\",\n\t.matches = {\n\t\tDMI_MATCH(DMI_SYS_VENDOR, \"HP\"),\n\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"HP Elite x2 1013 G3\"),\n\t\t},\n\t},\n\t{}\n};\n\nstatic void pmc_core_do_dmi_quirks(struct pmc *pmc)\n{\n\tdmi_check_system(pmc_core_dmi_table);\n\n\tif (xtal_ignore)\n\t\tpmc_core_xtal_ignore(pmc);\n}\n\nstatic void pmc_core_clean_structure(struct platform_device *pdev)\n{\n\tstruct pmc_dev *pmcdev = platform_get_drvdata(pdev);\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(pmcdev->pmcs); ++i) {\n\t\tstruct pmc *pmc = pmcdev->pmcs[i];\n\n\t\tif (pmc)\n\t\t\tiounmap(pmc->regbase);\n\t}\n\n\tif (pmcdev->ssram_pcidev) {\n\t\tpci_dev_put(pmcdev->ssram_pcidev);\n\t\tpci_disable_device(pmcdev->ssram_pcidev);\n\t}\n\tplatform_set_drvdata(pdev, NULL);\n\tmutex_destroy(&pmcdev->lock);\n}\n\nstatic int pmc_core_probe(struct platform_device *pdev)\n{\n\tstatic bool device_initialized;\n\tstruct pmc_dev *pmcdev;\n\tconst struct x86_cpu_id *cpu_id;\n\tint (*core_init)(struct pmc_dev *pmcdev);\n\tstruct pmc *primary_pmc;\n\tint ret;\n\n\tif (device_initialized)\n\t\treturn -ENODEV;\n\n\tpmcdev = devm_kzalloc(&pdev->dev, sizeof(*pmcdev), GFP_KERNEL);\n\tif (!pmcdev)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, pmcdev);\n\tpmcdev->pdev = pdev;\n\n\tcpu_id = x86_match_cpu(intel_pmc_core_ids);\n\tif (!cpu_id)\n\t\treturn -ENODEV;\n\n\tcore_init = (int (*)(struct pmc_dev *))cpu_id->driver_data;\n\n\t \n\tprimary_pmc = devm_kzalloc(&pdev->dev, sizeof(*primary_pmc), GFP_KERNEL);\n\tif (!primary_pmc)\n\t\treturn -ENOMEM;\n\tpmcdev->pmcs[PMC_IDX_MAIN] = primary_pmc;\n\n\t \n\tif (core_init == spt_core_init && !pci_dev_present(pmc_pci_ids))\n\t\tcore_init = cnp_core_init;\n\n\tmutex_init(&pmcdev->lock);\n\tret = core_init(pmcdev);\n\tif (ret) {\n\t\tpmc_core_clean_structure(pdev);\n\t\treturn ret;\n\t}\n\n\tpmcdev->pmc_xram_read_bit = pmc_core_check_read_lock_bit(primary_pmc);\n\tpmc_core_get_low_power_modes(pdev);\n\tpmc_core_do_dmi_quirks(primary_pmc);\n\n\tpmc_core_dbgfs_register(pmcdev);\n\tpm_report_max_hw_sleep(FIELD_MAX(SLP_S0_RES_COUNTER_MASK) *\n\t\t\t       pmc_core_adjust_slp_s0_step(primary_pmc, 1));\n\n\tdevice_initialized = true;\n\tdev_info(&pdev->dev, \" initialized\\n\");\n\n\treturn 0;\n}\n\nstatic void pmc_core_remove(struct platform_device *pdev)\n{\n\tstruct pmc_dev *pmcdev = platform_get_drvdata(pdev);\n\tpmc_core_dbgfs_unregister(pmcdev);\n\tpmc_core_clean_structure(pdev);\n}\n\nstatic bool warn_on_s0ix_failures;\nmodule_param(warn_on_s0ix_failures, bool, 0644);\nMODULE_PARM_DESC(warn_on_s0ix_failures, \"Check and warn for S0ix failures\");\n\nstatic __maybe_unused int pmc_core_suspend(struct device *dev)\n{\n\tstruct pmc_dev *pmcdev = dev_get_drvdata(dev);\n\tstruct pmc *pmc = pmcdev->pmcs[PMC_IDX_MAIN];\n\n\tif (pmcdev->suspend)\n\t\tpmcdev->suspend(pmcdev);\n\n\t \n\tif (pm_suspend_via_firmware())\n\t\treturn 0;\n\n\t \n\tif (rdmsrl_safe(MSR_PKG_C10_RESIDENCY, &pmcdev->pc10_counter))\n\t\treturn -EIO;\n\n\t \n\tif (pmc_core_dev_state_get(pmc, &pmcdev->s0ix_counter))\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic inline bool pmc_core_is_pc10_failed(struct pmc_dev *pmcdev)\n{\n\tu64 pc10_counter;\n\n\tif (rdmsrl_safe(MSR_PKG_C10_RESIDENCY, &pc10_counter))\n\t\treturn false;\n\n\tif (pc10_counter == pmcdev->pc10_counter)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic inline bool pmc_core_is_s0ix_failed(struct pmc_dev *pmcdev)\n{\n\tu64 s0ix_counter;\n\n\tif (pmc_core_dev_state_get(pmcdev->pmcs[PMC_IDX_MAIN], &s0ix_counter))\n\t\treturn false;\n\n\tpm_report_hw_sleep_time((u32)(s0ix_counter - pmcdev->s0ix_counter));\n\n\tif (s0ix_counter == pmcdev->s0ix_counter)\n\t\treturn true;\n\n\treturn false;\n}\n\nint pmc_core_resume_common(struct pmc_dev *pmcdev)\n{\n\tstruct device *dev = &pmcdev->pdev->dev;\n\tstruct pmc *pmc = pmcdev->pmcs[PMC_IDX_MAIN];\n\tconst struct pmc_bit_map **maps = pmc->map->lpm_sts;\n\tint offset = pmc->map->lpm_status_offset;\n\tint i;\n\n\t \n\tif (pm_suspend_via_firmware())\n\t\treturn 0;\n\n\tif (!pmc_core_is_s0ix_failed(pmcdev))\n\t\treturn 0;\n\n\tif (!warn_on_s0ix_failures)\n\t\treturn 0;\n\n\tif (pmc_core_is_pc10_failed(pmcdev)) {\n\t\t \n\t\tdev_info(dev, \"CPU did not enter PC10!!! (PC10 cnt=0x%llx)\\n\",\n\t\t\t pmcdev->pc10_counter);\n\t\treturn 0;\n\t}\n\n\t \n\tdev_warn(dev, \"CPU did not enter SLP_S0!!! (S0ix cnt=%llu)\\n\",\n\t\t pmcdev->s0ix_counter);\n\n\tif (pmc->map->slps0_dbg_maps)\n\t\tpmc_core_slps0_display(pmc, dev, NULL);\n\n\tfor (i = 0; i < ARRAY_SIZE(pmcdev->pmcs); ++i) {\n\t\tstruct pmc *pmc = pmcdev->pmcs[i];\n\n\t\tif (!pmc)\n\t\t\tcontinue;\n\t\tif (pmc->map->lpm_sts)\n\t\t\tpmc_core_lpm_display(pmc, dev, NULL, offset, i, \"STATUS\", maps);\n\t}\n\n\treturn 0;\n}\n\nstatic __maybe_unused int pmc_core_resume(struct device *dev)\n{\n\tstruct pmc_dev *pmcdev = dev_get_drvdata(dev);\n\n\tif (pmcdev->resume)\n\t\treturn pmcdev->resume(pmcdev);\n\n\treturn pmc_core_resume_common(pmcdev);\n}\n\nstatic const struct dev_pm_ops pmc_core_pm_ops = {\n\tSET_LATE_SYSTEM_SLEEP_PM_OPS(pmc_core_suspend, pmc_core_resume)\n};\n\nstatic const struct acpi_device_id pmc_core_acpi_ids[] = {\n\t{\"INT33A1\", 0},  \n\t{ }\n};\nMODULE_DEVICE_TABLE(acpi, pmc_core_acpi_ids);\n\nstatic struct platform_driver pmc_core_driver = {\n\t.driver = {\n\t\t.name = \"intel_pmc_core\",\n\t\t.acpi_match_table = ACPI_PTR(pmc_core_acpi_ids),\n\t\t.pm = &pmc_core_pm_ops,\n\t\t.dev_groups = pmc_dev_groups,\n\t},\n\t.probe = pmc_core_probe,\n\t.remove_new = pmc_core_remove,\n};\n\nmodule_platform_driver(pmc_core_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"Intel PMC Core Driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}