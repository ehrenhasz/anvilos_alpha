{
  "module_name": "pm.c",
  "hash_id": "e18c23e1fc740b094598f377be97c0329123b2aa197687051a0dd21b125ba930",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/x86/intel/atomisp2/pm.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/pci.h>\n#include <linux/pm_runtime.h>\n#include <asm/iosf_mbi.h>\n\n \n#define PCI_INTERRUPT_CTRL\t\t0x9c\n\n#define PCI_CSI_CONTROL\t\t\t0xe8\n#define PCI_CSI_CONTROL_PORTS_OFF_MASK\t0x7\n\n \n#define ISPSSPM0\t\t\t0x39\n#define ISPSSPM0_ISPSSC_OFFSET\t\t0\n#define ISPSSPM0_ISPSSC_MASK\t\t0x00000003\n#define ISPSSPM0_ISPSSS_OFFSET\t\t24\n#define ISPSSPM0_ISPSSS_MASK\t\t0x03000000\n#define ISPSSPM0_IUNIT_POWER_ON\t\t0x0\n#define ISPSSPM0_IUNIT_POWER_OFF\t0x3\n\nstatic int isp_set_power(struct pci_dev *dev, bool enable)\n{\n\tunsigned long timeout;\n\tu32 val = enable ? ISPSSPM0_IUNIT_POWER_ON : ISPSSPM0_IUNIT_POWER_OFF;\n\n\t \n\tiosf_mbi_modify(BT_MBI_UNIT_PMC, MBI_REG_READ, ISPSSPM0,\n\t\t\tval, ISPSSPM0_ISPSSC_MASK);\n\n\t \n\ttimeout = jiffies + msecs_to_jiffies(50);\n\tdo {\n\t\tu32 tmp;\n\n\t\t \n\t\tiosf_mbi_read(BT_MBI_UNIT_PMC, MBI_REG_READ, ISPSSPM0, &tmp);\n\t\ttmp = (tmp & ISPSSPM0_ISPSSS_MASK) >> ISPSSPM0_ISPSSS_OFFSET;\n\t\tif (tmp == val)\n\t\t\treturn 0;\n\n\t\tusleep_range(1000, 2000);\n\t} while (time_before(jiffies, timeout));\n\n\tdev_err(&dev->dev, \"IUNIT power-%s timeout.\\n\", enable ? \"on\" : \"off\");\n\treturn -EBUSY;\n}\n\nstatic int isp_probe(struct pci_dev *dev, const struct pci_device_id *id)\n{\n\tpm_runtime_allow(&dev->dev);\n\tpm_runtime_put_sync_suspend(&dev->dev);\n\n\treturn 0;\n}\n\nstatic void isp_remove(struct pci_dev *dev)\n{\n\tpm_runtime_get_sync(&dev->dev);\n\tpm_runtime_forbid(&dev->dev);\n}\n\nstatic int isp_pci_suspend(struct device *dev)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tu32 val;\n\n\tpci_write_config_dword(pdev, PCI_INTERRUPT_CTRL, 0);\n\n\t \n\tpci_read_config_dword(pdev, PCI_CSI_CONTROL, &val);\n\tval |= PCI_CSI_CONTROL_PORTS_OFF_MASK;\n\tpci_write_config_dword(pdev, PCI_CSI_CONTROL, val);\n\n\t \n\tpci_save_state(pdev);\n\tpdev->current_state = PCI_D3cold;\n\tisp_set_power(pdev, false);\n\n\treturn 0;\n}\n\nstatic int isp_pci_resume(struct device *dev)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\n\tisp_set_power(pdev, true);\n\tpdev->current_state = PCI_D0;\n\tpci_restore_state(pdev);\n\n\treturn 0;\n}\n\nstatic UNIVERSAL_DEV_PM_OPS(isp_pm_ops, isp_pci_suspend,\n\t\t\t    isp_pci_resume, NULL);\n\nstatic const struct pci_device_id isp_id_table[] = {\n\t{ PCI_VDEVICE(INTEL, 0x0f38), },\n\t{ PCI_VDEVICE(INTEL, 0x22b8), },\n\t{ 0, }\n};\nMODULE_DEVICE_TABLE(pci, isp_id_table);\n\nstatic struct pci_driver isp_pci_driver = {\n\t.name = \"intel_atomisp2_pm\",\n\t.id_table = isp_id_table,\n\t.probe = isp_probe,\n\t.remove = isp_remove,\n\t.driver.pm = &isp_pm_ops,\n};\n\nmodule_pci_driver(isp_pci_driver);\n\nMODULE_DESCRIPTION(\"Intel AtomISP2 dummy / power-management drv (for suspend)\");\nMODULE_AUTHOR(\"Hans de Goede <hdegoede@redhat.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}