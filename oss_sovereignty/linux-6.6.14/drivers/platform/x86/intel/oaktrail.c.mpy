{
  "module_name": "oaktrail.c",
  "hash_id": "d2cfede34fa14f399f5e7e7664a4777c215e9b7db8d03a1ab9adeb3c195293a8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/x86/intel/oaktrail.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/acpi.h>\n#include <linux/backlight.h>\n#include <linux/dmi.h>\n#include <linux/err.h>\n#include <linux/fb.h>\n#include <linux/i2c.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/platform_device.h>\n#include <linux/rfkill.h>\n\n#include <acpi/video.h>\n\n#define DRIVER_NAME\t\"intel_oaktrail\"\n#define DRIVER_VERSION\t\"0.4ac1\"\n\n \n#define OT_EC_DEVICE_STATE_ADDRESS\t0xD6\n\n#define OT_EC_CAMERA_MASK\t(1 << 0)\n#define OT_EC_BT_MASK\t\t(1 << 1)\n#define OT_EC_GPS_MASK\t\t(1 << 2)\n#define OT_EC_WIFI_MASK\t\t(1 << 3)\n#define OT_EC_WWAN_MASK\t\t(1 << 4)\n#define OT_EC_TS_MASK\t\t(1 << 5)\n\n \n#define OT_EC_BL_BRIGHTNESS_ADDRESS\t0x44\n#define OT_EC_BL_BRIGHTNESS_MAX\t\t100\n#define OT_EC_BL_CONTROL_ADDRESS\t0x3A\n#define OT_EC_BL_CONTROL_ON_DATA\t0x1A\n\n\nstatic bool force;\nmodule_param(force, bool, 0);\nMODULE_PARM_DESC(force, \"Force driver load, ignore DMI data\");\n\nstatic struct platform_device *oaktrail_device;\nstatic struct backlight_device *oaktrail_bl_device;\nstatic struct rfkill *bt_rfkill;\nstatic struct rfkill *gps_rfkill;\nstatic struct rfkill *wifi_rfkill;\nstatic struct rfkill *wwan_rfkill;\n\n\n \nstatic int oaktrail_rfkill_set(void *data, bool blocked)\n{\n\tu8 value;\n\tu8 result;\n\tunsigned long radio = (unsigned long) data;\n\n\tec_read(OT_EC_DEVICE_STATE_ADDRESS, &result);\n\n\tif (!blocked)\n\t\tvalue = (u8) (result | radio);\n\telse\n\t\tvalue = (u8) (result & ~radio);\n\n\tec_write(OT_EC_DEVICE_STATE_ADDRESS, value);\n\n\treturn 0;\n}\n\nstatic const struct rfkill_ops oaktrail_rfkill_ops = {\n\t.set_block = oaktrail_rfkill_set,\n};\n\nstatic struct rfkill *oaktrail_rfkill_new(char *name, enum rfkill_type type,\n\t\t\t\t\t  unsigned long mask)\n{\n\tstruct rfkill *rfkill_dev;\n\tu8 value;\n\tint err;\n\n\trfkill_dev = rfkill_alloc(name, &oaktrail_device->dev, type,\n\t\t\t\t  &oaktrail_rfkill_ops, (void *)mask);\n\tif (!rfkill_dev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tec_read(OT_EC_DEVICE_STATE_ADDRESS, &value);\n\trfkill_init_sw_state(rfkill_dev, (value & mask) != 1);\n\n\terr = rfkill_register(rfkill_dev);\n\tif (err) {\n\t\trfkill_destroy(rfkill_dev);\n\t\treturn ERR_PTR(err);\n\t}\n\n\treturn rfkill_dev;\n}\n\nstatic inline void __oaktrail_rfkill_cleanup(struct rfkill *rf)\n{\n\tif (rf) {\n\t\trfkill_unregister(rf);\n\t\trfkill_destroy(rf);\n\t}\n}\n\nstatic void oaktrail_rfkill_cleanup(void)\n{\n\t__oaktrail_rfkill_cleanup(wifi_rfkill);\n\t__oaktrail_rfkill_cleanup(bt_rfkill);\n\t__oaktrail_rfkill_cleanup(gps_rfkill);\n\t__oaktrail_rfkill_cleanup(wwan_rfkill);\n}\n\nstatic int oaktrail_rfkill_init(void)\n{\n\tint ret;\n\n\twifi_rfkill = oaktrail_rfkill_new(\"oaktrail-wifi\",\n\t\t\t\t\t  RFKILL_TYPE_WLAN,\n\t\t\t\t\t  OT_EC_WIFI_MASK);\n\tif (IS_ERR(wifi_rfkill)) {\n\t\tret = PTR_ERR(wifi_rfkill);\n\t\twifi_rfkill = NULL;\n\t\tgoto cleanup;\n\t}\n\n\tbt_rfkill = oaktrail_rfkill_new(\"oaktrail-bluetooth\",\n\t\t\t\t\tRFKILL_TYPE_BLUETOOTH,\n\t\t\t\t\tOT_EC_BT_MASK);\n\tif (IS_ERR(bt_rfkill)) {\n\t\tret = PTR_ERR(bt_rfkill);\n\t\tbt_rfkill = NULL;\n\t\tgoto cleanup;\n\t}\n\n\tgps_rfkill = oaktrail_rfkill_new(\"oaktrail-gps\",\n\t\t\t\t\t RFKILL_TYPE_GPS,\n\t\t\t\t\t OT_EC_GPS_MASK);\n\tif (IS_ERR(gps_rfkill)) {\n\t\tret = PTR_ERR(gps_rfkill);\n\t\tgps_rfkill = NULL;\n\t\tgoto cleanup;\n\t}\n\n\twwan_rfkill = oaktrail_rfkill_new(\"oaktrail-wwan\",\n\t\t\t\t\t  RFKILL_TYPE_WWAN,\n\t\t\t\t\t  OT_EC_WWAN_MASK);\n\tif (IS_ERR(wwan_rfkill)) {\n\t\tret = PTR_ERR(wwan_rfkill);\n\t\twwan_rfkill = NULL;\n\t\tgoto cleanup;\n\t}\n\n\treturn 0;\n\ncleanup:\n\toaktrail_rfkill_cleanup();\n\treturn ret;\n}\n\n\n \nstatic int get_backlight_brightness(struct backlight_device *b)\n{\n\tu8 value;\n\tec_read(OT_EC_BL_BRIGHTNESS_ADDRESS, &value);\n\n\treturn value;\n}\n\nstatic int set_backlight_brightness(struct backlight_device *b)\n{\n\tu8 percent = (u8) b->props.brightness;\n\tif (percent < 0 || percent > OT_EC_BL_BRIGHTNESS_MAX)\n\t\treturn -EINVAL;\n\n\tec_write(OT_EC_BL_BRIGHTNESS_ADDRESS, percent);\n\tec_write(OT_EC_BL_CONTROL_ADDRESS, OT_EC_BL_CONTROL_ON_DATA);\n\n\treturn 0;\n}\n\nstatic const struct backlight_ops oaktrail_bl_ops = {\n\t.get_brightness = get_backlight_brightness,\n\t.update_status\t= set_backlight_brightness,\n};\n\nstatic int oaktrail_backlight_init(void)\n{\n\tstruct backlight_device *bd;\n\tstruct backlight_properties props;\n\n\tmemset(&props, 0, sizeof(struct backlight_properties));\n\tprops.type = BACKLIGHT_PLATFORM;\n\tprops.max_brightness = OT_EC_BL_BRIGHTNESS_MAX;\n\tbd = backlight_device_register(DRIVER_NAME,\n\t\t\t\t       &oaktrail_device->dev, NULL,\n\t\t\t\t       &oaktrail_bl_ops,\n\t\t\t\t       &props);\n\n\tif (IS_ERR(bd)) {\n\t\toaktrail_bl_device = NULL;\n\t\tpr_warn(\"Unable to register backlight device\\n\");\n\t\treturn PTR_ERR(bd);\n\t}\n\n\toaktrail_bl_device = bd;\n\n\tbd->props.brightness = get_backlight_brightness(bd);\n\tbd->props.power = FB_BLANK_UNBLANK;\n\tbacklight_update_status(bd);\n\n\treturn 0;\n}\n\nstatic void oaktrail_backlight_exit(void)\n{\n\tbacklight_device_unregister(oaktrail_bl_device);\n}\n\nstatic int oaktrail_probe(struct platform_device *pdev)\n{\n\treturn 0;\n}\n\nstatic struct platform_driver oaktrail_driver = {\n\t.driver = {\n\t\t.name = DRIVER_NAME,\n\t},\n\t.probe\t= oaktrail_probe,\n};\n\nstatic int dmi_check_cb(const struct dmi_system_id *id)\n{\n\tpr_info(\"Identified model '%s'\\n\", id->ident);\n\treturn 0;\n}\n\nstatic const struct dmi_system_id oaktrail_dmi_table[] __initconst = {\n\t{\n\t\t.ident = \"OakTrail platform\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"OakTrail platform\"),\n\t\t},\n\t\t.callback = dmi_check_cb\n\t},\n\t{ }\n};\nMODULE_DEVICE_TABLE(dmi, oaktrail_dmi_table);\n\nstatic int __init oaktrail_init(void)\n{\n\tint ret;\n\n\tif (acpi_disabled) {\n\t\tpr_err(\"ACPI needs to be enabled for this driver to work!\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (!force && !dmi_check_system(oaktrail_dmi_table)) {\n\t\tpr_err(\"Platform not recognized (You could try the module's force-parameter)\");\n\t\treturn -ENODEV;\n\t}\n\n\tret = platform_driver_register(&oaktrail_driver);\n\tif (ret) {\n\t\tpr_warn(\"Unable to register platform driver\\n\");\n\t\tgoto err_driver_reg;\n\t}\n\n\toaktrail_device = platform_device_alloc(DRIVER_NAME, PLATFORM_DEVID_NONE);\n\tif (!oaktrail_device) {\n\t\tpr_warn(\"Unable to allocate platform device\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto err_device_alloc;\n\t}\n\n\tret = platform_device_add(oaktrail_device);\n\tif (ret) {\n\t\tpr_warn(\"Unable to add platform device\\n\");\n\t\tgoto err_device_add;\n\t}\n\n\tif (acpi_video_get_backlight_type() == acpi_backlight_vendor) {\n\t\tret = oaktrail_backlight_init();\n\t\tif (ret)\n\t\t\tgoto err_backlight;\n\t}\n\n\tret = oaktrail_rfkill_init();\n\tif (ret) {\n\t\tpr_warn(\"Setup rfkill failed\\n\");\n\t\tgoto err_rfkill;\n\t}\n\n\tpr_info(\"Driver \"DRIVER_VERSION\" successfully loaded\\n\");\n\treturn 0;\n\nerr_rfkill:\n\toaktrail_backlight_exit();\nerr_backlight:\n\tplatform_device_del(oaktrail_device);\nerr_device_add:\n\tplatform_device_put(oaktrail_device);\nerr_device_alloc:\n\tplatform_driver_unregister(&oaktrail_driver);\nerr_driver_reg:\n\n\treturn ret;\n}\n\nstatic void __exit oaktrail_cleanup(void)\n{\n\toaktrail_backlight_exit();\n\toaktrail_rfkill_cleanup();\n\tplatform_device_unregister(oaktrail_device);\n\tplatform_driver_unregister(&oaktrail_driver);\n\n\tpr_info(\"Driver unloaded\\n\");\n}\n\nmodule_init(oaktrail_init);\nmodule_exit(oaktrail_cleanup);\n\nMODULE_AUTHOR(\"Yin Kangkai (kangkai.yin@intel.com)\");\nMODULE_DESCRIPTION(\"Intel Oaktrail Platform ACPI Extras\");\nMODULE_VERSION(DRIVER_VERSION);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}