{
  "module_name": "telemetry.c",
  "hash_id": "c093d2b6112b5d0335dabb959e8ba1dadcf2541167e69011c44e688ab63457e6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/x86/intel/pmt/telemetry.c",
  "human_readable_source": "\n \n\n#include <linux/auxiliary_bus.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/overflow.h>\n\n#include \"../vsec.h\"\n#include \"class.h\"\n\n#define TELEM_SIZE_OFFSET\t0x0\n#define TELEM_GUID_OFFSET\t0x4\n#define TELEM_BASE_OFFSET\t0x8\n#define TELEM_ACCESS(v)\t\t((v) & GENMASK(3, 0))\n#define TELEM_TYPE(v)\t\t(((v) & GENMASK(7, 4)) >> 4)\n \n#define TELEM_SIZE(v)\t\t(((v) & GENMASK(27, 12)) >> 10)\n\n \n#define TELEM_CLIENT_FIXED_BLOCK_GUID\t0x10000000\n\nenum telem_type {\n\tTELEM_TYPE_PUNIT = 0,\n\tTELEM_TYPE_CRASHLOG,\n\tTELEM_TYPE_PUNIT_FIXED,\n};\n\nstruct pmt_telem_priv {\n\tint\t\t\t\tnum_entries;\n\tstruct intel_pmt_entry\t\tentry[];\n};\n\nstatic bool pmt_telem_region_overlaps(struct intel_pmt_entry *entry,\n\t\t\t\t      struct device *dev)\n{\n\tu32 guid = readl(entry->disc_table + TELEM_GUID_OFFSET);\n\n\tif (intel_pmt_is_early_client_hw(dev)) {\n\t\tu32 type = TELEM_TYPE(readl(entry->disc_table));\n\n\t\tif ((type == TELEM_TYPE_PUNIT_FIXED) ||\n\t\t    (guid == TELEM_CLIENT_FIXED_BLOCK_GUID))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic int pmt_telem_header_decode(struct intel_pmt_entry *entry,\n\t\t\t\t   struct intel_pmt_header *header,\n\t\t\t\t   struct device *dev)\n{\n\tvoid __iomem *disc_table = entry->disc_table;\n\n\tif (pmt_telem_region_overlaps(entry, dev))\n\t\treturn 1;\n\n\theader->access_type = TELEM_ACCESS(readl(disc_table));\n\theader->guid = readl(disc_table + TELEM_GUID_OFFSET);\n\theader->base_offset = readl(disc_table + TELEM_BASE_OFFSET);\n\n\t \n\theader->size = TELEM_SIZE(readl(disc_table));\n\n\t \n\tif (header->size == 0 || header->access_type == 0xF)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic DEFINE_XARRAY_ALLOC(telem_array);\nstatic struct intel_pmt_namespace pmt_telem_ns = {\n\t.name = \"telem\",\n\t.xa = &telem_array,\n\t.pmt_header_decode = pmt_telem_header_decode,\n};\n\nstatic void pmt_telem_remove(struct auxiliary_device *auxdev)\n{\n\tstruct pmt_telem_priv *priv = auxiliary_get_drvdata(auxdev);\n\tint i;\n\n\tfor (i = 0; i < priv->num_entries; i++)\n\t\tintel_pmt_dev_destroy(&priv->entry[i], &pmt_telem_ns);\n}\n\nstatic int pmt_telem_probe(struct auxiliary_device *auxdev, const struct auxiliary_device_id *id)\n{\n\tstruct intel_vsec_device *intel_vsec_dev = auxdev_to_ivdev(auxdev);\n\tstruct pmt_telem_priv *priv;\n\tsize_t size;\n\tint i, ret;\n\n\tsize = struct_size(priv, entry, intel_vsec_dev->num_resources);\n\tpriv = devm_kzalloc(&auxdev->dev, size, GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tauxiliary_set_drvdata(auxdev, priv);\n\n\tfor (i = 0; i < intel_vsec_dev->num_resources; i++) {\n\t\tstruct intel_pmt_entry *entry = &priv->entry[priv->num_entries];\n\n\t\tret = intel_pmt_dev_create(entry, &pmt_telem_ns, intel_vsec_dev, i);\n\t\tif (ret < 0)\n\t\t\tgoto abort_probe;\n\t\tif (ret)\n\t\t\tcontinue;\n\n\t\tpriv->num_entries++;\n\t}\n\n\treturn 0;\nabort_probe:\n\tpmt_telem_remove(auxdev);\n\treturn ret;\n}\n\nstatic const struct auxiliary_device_id pmt_telem_id_table[] = {\n\t{ .name = \"intel_vsec.telemetry\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(auxiliary, pmt_telem_id_table);\n\nstatic struct auxiliary_driver pmt_telem_aux_driver = {\n\t.id_table\t= pmt_telem_id_table,\n\t.remove\t\t= pmt_telem_remove,\n\t.probe\t\t= pmt_telem_probe,\n};\n\nstatic int __init pmt_telem_init(void)\n{\n\treturn auxiliary_driver_register(&pmt_telem_aux_driver);\n}\nmodule_init(pmt_telem_init);\n\nstatic void __exit pmt_telem_exit(void)\n{\n\tauxiliary_driver_unregister(&pmt_telem_aux_driver);\n\txa_destroy(&telem_array);\n}\nmodule_exit(pmt_telem_exit);\n\nMODULE_AUTHOR(\"David E. Box <david.e.box@linux.intel.com>\");\nMODULE_DESCRIPTION(\"Intel PMT Telemetry driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_IMPORT_NS(INTEL_PMT);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}