{
  "module_name": "crashlog.c",
  "hash_id": "422abea0dc5ce6c1baa20fa0ae154108a87d99b3db2ee1c12359972db898fa0b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/x86/intel/pmt/crashlog.c",
  "human_readable_source": "\n \n\n#include <linux/auxiliary_bus.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/overflow.h>\n\n#include \"../vsec.h\"\n#include \"class.h\"\n\n \n#define CRASH_TYPE_OOBMSM\t1\n\n \n#define CRASHLOG_FLAG_DISABLE\t\tBIT(28)\n\n \n#define CRASHLOG_FLAG_TRIGGER_CLEAR\tBIT(29)\n#define CRASHLOG_FLAG_TRIGGER_EXECUTE\tBIT(30)\n#define CRASHLOG_FLAG_TRIGGER_COMPLETE\tBIT(31)\n#define CRASHLOG_FLAG_TRIGGER_MASK\tGENMASK(31, 28)\n\n \n#define CONTROL_OFFSET\t\t0x0\n#define GUID_OFFSET\t\t0x4\n#define BASE_OFFSET\t\t0x8\n#define SIZE_OFFSET\t\t0xC\n#define GET_ACCESS(v)\t\t((v) & GENMASK(3, 0))\n#define GET_TYPE(v)\t\t(((v) & GENMASK(7, 4)) >> 4)\n#define GET_VERSION(v)\t\t(((v) & GENMASK(19, 16)) >> 16)\n \n#define GET_SIZE(v)\t\t((v) * sizeof(u32))\n\nstruct crashlog_entry {\n\t \n\tstruct intel_pmt_entry\t\tentry;\n\tstruct mutex\t\t\tcontrol_mutex;\n};\n\nstruct pmt_crashlog_priv {\n\tint\t\t\tnum_entries;\n\tstruct crashlog_entry\tentry[];\n};\n\n \nstatic bool pmt_crashlog_complete(struct intel_pmt_entry *entry)\n{\n\tu32 control = readl(entry->disc_table + CONTROL_OFFSET);\n\n\t \n\treturn !!(control & CRASHLOG_FLAG_TRIGGER_COMPLETE);\n}\n\nstatic bool pmt_crashlog_disabled(struct intel_pmt_entry *entry)\n{\n\tu32 control = readl(entry->disc_table + CONTROL_OFFSET);\n\n\t \n\treturn !!(control & CRASHLOG_FLAG_DISABLE);\n}\n\nstatic bool pmt_crashlog_supported(struct intel_pmt_entry *entry)\n{\n\tu32 discovery_header = readl(entry->disc_table + CONTROL_OFFSET);\n\tu32 crash_type, version;\n\n\tcrash_type = GET_TYPE(discovery_header);\n\tversion = GET_VERSION(discovery_header);\n\n\t \n\treturn crash_type == CRASH_TYPE_OOBMSM && version == 0;\n}\n\nstatic void pmt_crashlog_set_disable(struct intel_pmt_entry *entry,\n\t\t\t\t     bool disable)\n{\n\tu32 control = readl(entry->disc_table + CONTROL_OFFSET);\n\n\t \n\tcontrol &= ~CRASHLOG_FLAG_TRIGGER_MASK;\n\n\tif (disable)\n\t\tcontrol |= CRASHLOG_FLAG_DISABLE;\n\telse\n\t\tcontrol &= ~CRASHLOG_FLAG_DISABLE;\n\n\twritel(control, entry->disc_table + CONTROL_OFFSET);\n}\n\nstatic void pmt_crashlog_set_clear(struct intel_pmt_entry *entry)\n{\n\tu32 control = readl(entry->disc_table + CONTROL_OFFSET);\n\n\tcontrol &= ~CRASHLOG_FLAG_TRIGGER_MASK;\n\tcontrol |= CRASHLOG_FLAG_TRIGGER_CLEAR;\n\n\twritel(control, entry->disc_table + CONTROL_OFFSET);\n}\n\nstatic void pmt_crashlog_set_execute(struct intel_pmt_entry *entry)\n{\n\tu32 control = readl(entry->disc_table + CONTROL_OFFSET);\n\n\tcontrol &= ~CRASHLOG_FLAG_TRIGGER_MASK;\n\tcontrol |= CRASHLOG_FLAG_TRIGGER_EXECUTE;\n\n\twritel(control, entry->disc_table + CONTROL_OFFSET);\n}\n\n \nstatic ssize_t\nenable_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct intel_pmt_entry *entry = dev_get_drvdata(dev);\n\tint enabled = !pmt_crashlog_disabled(entry);\n\n\treturn sprintf(buf, \"%d\\n\", enabled);\n}\n\nstatic ssize_t\nenable_store(struct device *dev, struct device_attribute *attr,\n\t    const char *buf, size_t count)\n{\n\tstruct crashlog_entry *entry;\n\tbool enabled;\n\tint result;\n\n\tentry = dev_get_drvdata(dev);\n\n\tresult = kstrtobool(buf, &enabled);\n\tif (result)\n\t\treturn result;\n\n\tmutex_lock(&entry->control_mutex);\n\tpmt_crashlog_set_disable(&entry->entry, !enabled);\n\tmutex_unlock(&entry->control_mutex);\n\n\treturn count;\n}\nstatic DEVICE_ATTR_RW(enable);\n\nstatic ssize_t\ntrigger_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct intel_pmt_entry *entry;\n\tint trigger;\n\n\tentry = dev_get_drvdata(dev);\n\ttrigger = pmt_crashlog_complete(entry);\n\n\treturn sprintf(buf, \"%d\\n\", trigger);\n}\n\nstatic ssize_t\ntrigger_store(struct device *dev, struct device_attribute *attr,\n\t    const char *buf, size_t count)\n{\n\tstruct crashlog_entry *entry;\n\tbool trigger;\n\tint result;\n\n\tentry = dev_get_drvdata(dev);\n\n\tresult = kstrtobool(buf, &trigger);\n\tif (result)\n\t\treturn result;\n\n\tmutex_lock(&entry->control_mutex);\n\n\tif (!trigger) {\n\t\tpmt_crashlog_set_clear(&entry->entry);\n\t} else if (pmt_crashlog_complete(&entry->entry)) {\n\t\t \n\t\tresult = -EEXIST;\n\t\tgoto err;\n\t} else if (pmt_crashlog_disabled(&entry->entry)) {\n\t\t \n\t\tresult = -EBUSY;\n\t\tgoto err;\n\t} else {\n\t\tpmt_crashlog_set_execute(&entry->entry);\n\t}\n\n\tresult = count;\nerr:\n\tmutex_unlock(&entry->control_mutex);\n\treturn result;\n}\nstatic DEVICE_ATTR_RW(trigger);\n\nstatic struct attribute *pmt_crashlog_attrs[] = {\n\t&dev_attr_enable.attr,\n\t&dev_attr_trigger.attr,\n\tNULL\n};\n\nstatic const struct attribute_group pmt_crashlog_group = {\n\t.attrs\t= pmt_crashlog_attrs,\n};\n\nstatic int pmt_crashlog_header_decode(struct intel_pmt_entry *entry,\n\t\t\t\t      struct intel_pmt_header *header,\n\t\t\t\t      struct device *dev)\n{\n\tvoid __iomem *disc_table = entry->disc_table;\n\tstruct crashlog_entry *crashlog;\n\n\tif (!pmt_crashlog_supported(entry))\n\t\treturn 1;\n\n\t \n\tcrashlog = container_of(entry, struct crashlog_entry, entry);\n\tmutex_init(&crashlog->control_mutex);\n\n\theader->access_type = GET_ACCESS(readl(disc_table));\n\theader->guid = readl(disc_table + GUID_OFFSET);\n\theader->base_offset = readl(disc_table + BASE_OFFSET);\n\n\t \n\theader->size = GET_SIZE(readl(disc_table + SIZE_OFFSET));\n\n\treturn 0;\n}\n\nstatic DEFINE_XARRAY_ALLOC(crashlog_array);\nstatic struct intel_pmt_namespace pmt_crashlog_ns = {\n\t.name = \"crashlog\",\n\t.xa = &crashlog_array,\n\t.attr_grp = &pmt_crashlog_group,\n\t.pmt_header_decode = pmt_crashlog_header_decode,\n};\n\n \nstatic void pmt_crashlog_remove(struct auxiliary_device *auxdev)\n{\n\tstruct pmt_crashlog_priv *priv = auxiliary_get_drvdata(auxdev);\n\tint i;\n\n\tfor (i = 0; i < priv->num_entries; i++)\n\t\tintel_pmt_dev_destroy(&priv->entry[i].entry, &pmt_crashlog_ns);\n}\n\nstatic int pmt_crashlog_probe(struct auxiliary_device *auxdev,\n\t\t\t      const struct auxiliary_device_id *id)\n{\n\tstruct intel_vsec_device *intel_vsec_dev = auxdev_to_ivdev(auxdev);\n\tstruct pmt_crashlog_priv *priv;\n\tsize_t size;\n\tint i, ret;\n\n\tsize = struct_size(priv, entry, intel_vsec_dev->num_resources);\n\tpriv = devm_kzalloc(&auxdev->dev, size, GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tauxiliary_set_drvdata(auxdev, priv);\n\n\tfor (i = 0; i < intel_vsec_dev->num_resources; i++) {\n\t\tstruct intel_pmt_entry *entry = &priv->entry[priv->num_entries].entry;\n\n\t\tret = intel_pmt_dev_create(entry, &pmt_crashlog_ns, intel_vsec_dev, i);\n\t\tif (ret < 0)\n\t\t\tgoto abort_probe;\n\t\tif (ret)\n\t\t\tcontinue;\n\n\t\tpriv->num_entries++;\n\t}\n\n\treturn 0;\nabort_probe:\n\tpmt_crashlog_remove(auxdev);\n\treturn ret;\n}\n\nstatic const struct auxiliary_device_id pmt_crashlog_id_table[] = {\n\t{ .name = \"intel_vsec.crashlog\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(auxiliary, pmt_crashlog_id_table);\n\nstatic struct auxiliary_driver pmt_crashlog_aux_driver = {\n\t.id_table\t= pmt_crashlog_id_table,\n\t.remove\t\t= pmt_crashlog_remove,\n\t.probe\t\t= pmt_crashlog_probe,\n};\n\nstatic int __init pmt_crashlog_init(void)\n{\n\treturn auxiliary_driver_register(&pmt_crashlog_aux_driver);\n}\n\nstatic void __exit pmt_crashlog_exit(void)\n{\n\tauxiliary_driver_unregister(&pmt_crashlog_aux_driver);\n\txa_destroy(&crashlog_array);\n}\n\nmodule_init(pmt_crashlog_init);\nmodule_exit(pmt_crashlog_exit);\n\nMODULE_AUTHOR(\"Alexander Duyck <alexander.h.duyck@linux.intel.com>\");\nMODULE_DESCRIPTION(\"Intel PMT Crashlog driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_IMPORT_NS(INTEL_PMT);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}