{
  "module_name": "class.c",
  "hash_id": "48d5c2bc14f294ebe4eb82d53aafc64dee8351ed90d581103e340e9fc690418e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/x86/intel/pmt/class.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/io-64-nonatomic-lo-hi.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/pci.h>\n\n#include \"../vsec.h\"\n#include \"class.h\"\n\n#define PMT_XA_START\t\t0\n#define PMT_XA_MAX\t\tINT_MAX\n#define PMT_XA_LIMIT\t\tXA_LIMIT(PMT_XA_START, PMT_XA_MAX)\n#define GUID_SPR_PUNIT\t\t0x9956f43f\n\nbool intel_pmt_is_early_client_hw(struct device *dev)\n{\n\tstruct intel_vsec_device *ivdev = dev_to_ivdev(dev);\n\n\t \n\treturn !!(ivdev->info->quirks & VSEC_QUIRK_EARLY_HW);\n}\nEXPORT_SYMBOL_NS_GPL(intel_pmt_is_early_client_hw, INTEL_PMT);\n\nstatic inline int\npmt_memcpy64_fromio(void *to, const u64 __iomem *from, size_t count)\n{\n\tint i, remain;\n\tu64 *buf = to;\n\n\tif (!IS_ALIGNED((unsigned long)from, 8))\n\t\treturn -EFAULT;\n\n\tfor (i = 0; i < count/8; i++)\n\t\tbuf[i] = readq(&from[i]);\n\n\t \n\tremain = count % 8;\n\tif (remain) {\n\t\tu64 tmp = readq(&from[i]);\n\n\t\tmemcpy(&buf[i], &tmp, remain);\n\t}\n\n\treturn count;\n}\n\n \nstatic ssize_t\nintel_pmt_read(struct file *filp, struct kobject *kobj,\n\t       struct bin_attribute *attr, char *buf, loff_t off,\n\t       size_t count)\n{\n\tstruct intel_pmt_entry *entry = container_of(attr,\n\t\t\t\t\t\t     struct intel_pmt_entry,\n\t\t\t\t\t\t     pmt_bin_attr);\n\n\tif (off < 0)\n\t\treturn -EINVAL;\n\n\tif (off >= entry->size)\n\t\treturn 0;\n\n\tif (count > entry->size - off)\n\t\tcount = entry->size - off;\n\n\tif (entry->guid == GUID_SPR_PUNIT)\n\t\t \n\t\tcount = pmt_memcpy64_fromio(buf, entry->base + off, count);\n\telse\n\t\tmemcpy_fromio(buf, entry->base + off, count);\n\n\treturn count;\n}\n\nstatic int\nintel_pmt_mmap(struct file *filp, struct kobject *kobj,\n\t\tstruct bin_attribute *attr, struct vm_area_struct *vma)\n{\n\tstruct intel_pmt_entry *entry = container_of(attr,\n\t\t\t\t\t\t     struct intel_pmt_entry,\n\t\t\t\t\t\t     pmt_bin_attr);\n\tunsigned long vsize = vma->vm_end - vma->vm_start;\n\tstruct device *dev = kobj_to_dev(kobj);\n\tunsigned long phys = entry->base_addr;\n\tunsigned long pfn = PFN_DOWN(phys);\n\tunsigned long psize;\n\n\tif (vma->vm_flags & (VM_WRITE | VM_MAYWRITE))\n\t\treturn -EROFS;\n\n\tpsize = (PFN_UP(entry->base_addr + entry->size) - pfn) * PAGE_SIZE;\n\tif (vsize > psize) {\n\t\tdev_err(dev, \"Requested mmap size is too large\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\n\tif (io_remap_pfn_range(vma, vma->vm_start, pfn,\n\t\tvsize, vma->vm_page_prot))\n\t\treturn -EAGAIN;\n\n\treturn 0;\n}\n\nstatic ssize_t\nguid_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct intel_pmt_entry *entry = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"0x%x\\n\", entry->guid);\n}\nstatic DEVICE_ATTR_RO(guid);\n\nstatic ssize_t size_show(struct device *dev, struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct intel_pmt_entry *entry = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%zu\\n\", entry->size);\n}\nstatic DEVICE_ATTR_RO(size);\n\nstatic ssize_t\noffset_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct intel_pmt_entry *entry = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%lu\\n\", offset_in_page(entry->base_addr));\n}\nstatic DEVICE_ATTR_RO(offset);\n\nstatic struct attribute *intel_pmt_attrs[] = {\n\t&dev_attr_guid.attr,\n\t&dev_attr_size.attr,\n\t&dev_attr_offset.attr,\n\tNULL\n};\nATTRIBUTE_GROUPS(intel_pmt);\n\nstatic struct class intel_pmt_class = {\n\t.name = \"intel_pmt\",\n\t.dev_groups = intel_pmt_groups,\n};\n\nstatic int intel_pmt_populate_entry(struct intel_pmt_entry *entry,\n\t\t\t\t    struct intel_pmt_header *header,\n\t\t\t\t    struct device *dev,\n\t\t\t\t    struct resource *disc_res)\n{\n\tstruct pci_dev *pci_dev = to_pci_dev(dev->parent);\n\tu8 bir;\n\n\t \n\tbir = GET_BIR(header->base_offset);\n\n\t \n\tswitch (header->access_type) {\n\tcase ACCESS_LOCAL:\n\t\tif (bir) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"Unsupported BAR index %d for access type %d\\n\",\n\t\t\t\tbir, header->access_type);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t \n\t\tentry->base_addr = disc_res->end + 1 + header->base_offset;\n\n\t\t \n\t\tif (intel_pmt_is_early_client_hw(dev)) {\n\t\t\tint i;\n\n\t\t\tentry->base_addr = 0;\n\t\t\tfor (i = 0; i < 6; i++)\n\t\t\t\tif (disc_res->start >= pci_resource_start(pci_dev, i) &&\n\t\t\t\t   (disc_res->start <= pci_resource_end(pci_dev, i))) {\n\t\t\t\t\tentry->base_addr = pci_resource_start(pci_dev, i) +\n\t\t\t\t\t\t\t   header->base_offset;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tif (!entry->base_addr)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tbreak;\n\tcase ACCESS_BARID:\n\t\t \n\t\tentry->base_addr = pci_resource_start(pci_dev, bir) +\n\t\t\t\t   GET_ADDRESS(header->base_offset);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"Unsupported access type %d\\n\",\n\t\t\theader->access_type);\n\t\treturn -EINVAL;\n\t}\n\n\tentry->guid = header->guid;\n\tentry->size = header->size;\n\n\treturn 0;\n}\n\nstatic int intel_pmt_dev_register(struct intel_pmt_entry *entry,\n\t\t\t\t  struct intel_pmt_namespace *ns,\n\t\t\t\t  struct device *parent)\n{\n\tstruct resource res = {0};\n\tstruct device *dev;\n\tint ret;\n\n\tret = xa_alloc(ns->xa, &entry->devid, entry, PMT_XA_LIMIT, GFP_KERNEL);\n\tif (ret)\n\t\treturn ret;\n\n\tdev = device_create(&intel_pmt_class, parent, MKDEV(0, 0), entry,\n\t\t\t    \"%s%d\", ns->name, entry->devid);\n\n\tif (IS_ERR(dev)) {\n\t\tdev_err(parent, \"Could not create %s%d device node\\n\",\n\t\t\tns->name, entry->devid);\n\t\tret = PTR_ERR(dev);\n\t\tgoto fail_dev_create;\n\t}\n\n\tentry->kobj = &dev->kobj;\n\n\tif (ns->attr_grp) {\n\t\tret = sysfs_create_group(entry->kobj, ns->attr_grp);\n\t\tif (ret)\n\t\t\tgoto fail_sysfs;\n\t}\n\n\t \n\tif (!entry->size)\n\t\treturn 0;\n\n\tres.start = entry->base_addr;\n\tres.end = res.start + entry->size - 1;\n\tres.flags = IORESOURCE_MEM;\n\n\tentry->base = devm_ioremap_resource(dev, &res);\n\tif (IS_ERR(entry->base)) {\n\t\tret = PTR_ERR(entry->base);\n\t\tgoto fail_ioremap;\n\t}\n\n\tsysfs_bin_attr_init(&entry->pmt_bin_attr);\n\tentry->pmt_bin_attr.attr.name = ns->name;\n\tentry->pmt_bin_attr.attr.mode = 0440;\n\tentry->pmt_bin_attr.mmap = intel_pmt_mmap;\n\tentry->pmt_bin_attr.read = intel_pmt_read;\n\tentry->pmt_bin_attr.size = entry->size;\n\n\tret = sysfs_create_bin_file(&dev->kobj, &entry->pmt_bin_attr);\n\tif (!ret)\n\t\treturn 0;\n\nfail_ioremap:\n\tif (ns->attr_grp)\n\t\tsysfs_remove_group(entry->kobj, ns->attr_grp);\nfail_sysfs:\n\tdevice_unregister(dev);\nfail_dev_create:\n\txa_erase(ns->xa, entry->devid);\n\n\treturn ret;\n}\n\nint intel_pmt_dev_create(struct intel_pmt_entry *entry, struct intel_pmt_namespace *ns,\n\t\t\t struct intel_vsec_device *intel_vsec_dev, int idx)\n{\n\tstruct device *dev = &intel_vsec_dev->auxdev.dev;\n\tstruct intel_pmt_header header;\n\tstruct resource\t*disc_res;\n\tint ret;\n\n\tdisc_res = &intel_vsec_dev->resource[idx];\n\n\tentry->disc_table = devm_ioremap_resource(dev, disc_res);\n\tif (IS_ERR(entry->disc_table))\n\t\treturn PTR_ERR(entry->disc_table);\n\n\tret = ns->pmt_header_decode(entry, &header, dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = intel_pmt_populate_entry(entry, &header, dev, disc_res);\n\tif (ret)\n\t\treturn ret;\n\n\treturn intel_pmt_dev_register(entry, ns, dev);\n\n}\nEXPORT_SYMBOL_NS_GPL(intel_pmt_dev_create, INTEL_PMT);\n\nvoid intel_pmt_dev_destroy(struct intel_pmt_entry *entry,\n\t\t\t   struct intel_pmt_namespace *ns)\n{\n\tstruct device *dev = kobj_to_dev(entry->kobj);\n\n\tif (entry->size)\n\t\tsysfs_remove_bin_file(entry->kobj, &entry->pmt_bin_attr);\n\n\tif (ns->attr_grp)\n\t\tsysfs_remove_group(entry->kobj, ns->attr_grp);\n\n\tdevice_unregister(dev);\n\txa_erase(ns->xa, entry->devid);\n}\nEXPORT_SYMBOL_NS_GPL(intel_pmt_dev_destroy, INTEL_PMT);\n\nstatic int __init pmt_class_init(void)\n{\n\treturn class_register(&intel_pmt_class);\n}\n\nstatic void __exit pmt_class_exit(void)\n{\n\tclass_unregister(&intel_pmt_class);\n}\n\nmodule_init(pmt_class_init);\nmodule_exit(pmt_class_exit);\n\nMODULE_AUTHOR(\"Alexander Duyck <alexander.h.duyck@linux.intel.com>\");\nMODULE_DESCRIPTION(\"Intel PMT Class driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}