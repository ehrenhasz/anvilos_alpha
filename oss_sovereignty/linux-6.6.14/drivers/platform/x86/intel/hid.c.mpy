{
  "module_name": "hid.c",
  "hash_id": "b3e9a1cae97249b093d0dc1c8cd6686792dd98378d34c25048a4061339c9c065",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/x86/intel/hid.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/dmi.h>\n#include <linux/input.h>\n#include <linux/input/sparse-keymap.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/suspend.h>\n#include \"../dual_accel_detect.h\"\n\nenum intel_hid_tablet_sw_mode {\n\tTABLET_SW_AUTO = -1,\n\tTABLET_SW_OFF  = 0,\n\tTABLET_SW_AT_EVENT,\n\tTABLET_SW_AT_PROBE,\n};\n\nstatic bool enable_5_button_array;\nmodule_param(enable_5_button_array, bool, 0444);\nMODULE_PARM_DESC(enable_5_button_array,\n\t\"Enable 5 Button Array support. \"\n\t\"If you need this please report this to: platform-driver-x86@vger.kernel.org\");\n\nstatic int enable_sw_tablet_mode = TABLET_SW_AUTO;\nmodule_param(enable_sw_tablet_mode, int, 0444);\nMODULE_PARM_DESC(enable_sw_tablet_mode,\n\t\"Enable SW_TABLET_MODE reporting -1:auto 0:off 1:at-first-event 2:at-probe. \"\n\t\"If you need this please report this to: platform-driver-x86@vger.kernel.org\");\n\n \n#define TABLET_MODE_FLAG BIT(6)\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Alex Hung\");\n\nstatic const struct acpi_device_id intel_hid_ids[] = {\n\t{\"INT33D5\", 0},\n\t{\"INTC1051\", 0},\n\t{\"INTC1054\", 0},\n\t{\"INTC1070\", 0},\n\t{\"INTC1076\", 0},\n\t{\"INTC1077\", 0},\n\t{\"INTC1078\", 0},\n\t{\"\", 0},\n};\nMODULE_DEVICE_TABLE(acpi, intel_hid_ids);\n\n \nstatic const struct key_entry intel_hid_keymap[] = {\n\t \n\t \n\t{ KE_KEY, 3, { KEY_NUMLOCK } },\n\t{ KE_KEY, 4, { KEY_HOME } },\n\t{ KE_KEY, 5, { KEY_END } },\n\t{ KE_KEY, 6, { KEY_PAGEUP } },\n\t{ KE_KEY, 7, { KEY_PAGEDOWN } },\n\t{ KE_KEY, 8, { KEY_RFKILL } },\n\t{ KE_KEY, 9, { KEY_POWER } },\n\t{ KE_KEY, 11, { KEY_SLEEP } },\n\t \n\t{ KE_KEY, 14, { KEY_STOPCD } },\n\t{ KE_KEY, 15, { KEY_PLAYPAUSE } },\n\t{ KE_KEY, 16, { KEY_MUTE } },\n\t{ KE_KEY, 17, { KEY_VOLUMEUP } },\n\t{ KE_KEY, 18, { KEY_VOLUMEDOWN } },\n\t{ KE_KEY, 19, { KEY_BRIGHTNESSUP } },\n\t{ KE_KEY, 20, { KEY_BRIGHTNESSDOWN } },\n\t \n\t{ KE_END },\n};\n\n \nstatic const struct key_entry intel_array_keymap[] = {\n\t{ KE_KEY,    0xC2, { KEY_LEFTMETA } },                 \n\t{ KE_IGNORE, 0xC3, { KEY_LEFTMETA } },                 \n\t{ KE_KEY,    0xC4, { KEY_VOLUMEUP } },                 \n\t{ KE_IGNORE, 0xC5, { KEY_VOLUMEUP } },                 \n\t{ KE_KEY,    0xC6, { KEY_VOLUMEDOWN } },               \n\t{ KE_IGNORE, 0xC7, { KEY_VOLUMEDOWN } },               \n\t{ KE_KEY,    0xC8, { KEY_ROTATE_LOCK_TOGGLE } },       \n\t{ KE_IGNORE, 0xC9, { KEY_ROTATE_LOCK_TOGGLE } },       \n\t{ KE_KEY,    0xCE, { KEY_POWER } },                    \n\t{ KE_IGNORE, 0xCF, { KEY_POWER } },                    \n\t{ KE_END },\n};\n\nstatic const struct dmi_system_id button_array_table[] = {\n\t{\n\t\t.ident = \"Wacom MobileStudio Pro 13\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Wacom Co.,Ltd\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Wacom MobileStudio Pro 13\"),\n\t\t},\n\t},\n\t{\n\t\t.ident = \"Wacom MobileStudio Pro 16\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Wacom Co.,Ltd\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Wacom MobileStudio Pro 16\"),\n\t\t},\n\t},\n\t{\n\t\t.ident = \"HP Spectre x2 (2015)\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"HP\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"HP Spectre x2 Detachable\"),\n\t\t},\n\t},\n\t{\n\t\t.ident = \"Lenovo ThinkPad X1 Tablet Gen 2\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"LENOVO\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_FAMILY, \"ThinkPad X1 Tablet Gen 2\"),\n\t\t},\n\t},\n\t{\n\t\t.ident = \"Microsoft Surface Go 3\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Microsoft Corporation\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Surface Go 3\"),\n\t\t},\n\t},\n\t{ }\n};\n\n \nstatic const struct dmi_system_id dmi_vgbs_allow_list[] = {\n\t{\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"HP\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"HP Spectre x360 Convertible 15-df0xxx\"),\n\t\t},\n\t},\n\t{\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Microsoft Corporation\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Surface Go\"),\n\t\t},\n\t},\n\t{\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"HP\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"HP Elite Dragonfly G2 Notebook PC\"),\n\t\t},\n\t},\n\t{ }\n};\n\n \nstatic const struct dmi_system_id dmi_auto_add_switch[] = {\n\t{\n\t\t.matches = {\n\t\t\tDMI_EXACT_MATCH(DMI_CHASSIS_TYPE, \"31\"  ),\n\t\t},\n\t},\n\t{\n\t\t.matches = {\n\t\t\tDMI_EXACT_MATCH(DMI_CHASSIS_TYPE, \"32\"  ),\n\t\t},\n\t},\n\t{}  \n};\n\nstruct intel_hid_priv {\n\tstruct input_dev *input_dev;\n\tstruct input_dev *array;\n\tstruct input_dev *switches;\n\tbool wakeup_mode;\n};\n\n#define HID_EVENT_FILTER_UUID\t\"eeec56b3-4442-408f-a792-4edd4d758054\"\n\nenum intel_hid_dsm_fn_codes {\n\tINTEL_HID_DSM_FN_INVALID,\n\tINTEL_HID_DSM_BTNL_FN,\n\tINTEL_HID_DSM_HDMM_FN,\n\tINTEL_HID_DSM_HDSM_FN,\n\tINTEL_HID_DSM_HDEM_FN,\n\tINTEL_HID_DSM_BTNS_FN,\n\tINTEL_HID_DSM_BTNE_FN,\n\tINTEL_HID_DSM_HEBC_V1_FN,\n\tINTEL_HID_DSM_VGBS_FN,\n\tINTEL_HID_DSM_HEBC_V2_FN,\n\tINTEL_HID_DSM_FN_MAX\n};\n\nstatic const char *intel_hid_dsm_fn_to_method[INTEL_HID_DSM_FN_MAX] = {\n\tNULL,\n\t\"BTNL\",\n\t\"HDMM\",\n\t\"HDSM\",\n\t\"HDEM\",\n\t\"BTNS\",\n\t\"BTNE\",\n\t\"HEBC\",\n\t\"VGBS\",\n\t\"HEBC\"\n};\n\nstatic unsigned long long intel_hid_dsm_fn_mask;\nstatic guid_t intel_dsm_guid;\n\nstatic bool intel_hid_execute_method(acpi_handle handle,\n\t\t\t\t     enum intel_hid_dsm_fn_codes fn_index,\n\t\t\t\t     unsigned long long arg)\n{\n\tunion acpi_object *obj, argv4, req;\n\tacpi_status status;\n\tchar *method_name;\n\n\tif (fn_index <= INTEL_HID_DSM_FN_INVALID ||\n\t    fn_index >= INTEL_HID_DSM_FN_MAX)\n\t\treturn false;\n\n\tmethod_name = (char *)intel_hid_dsm_fn_to_method[fn_index];\n\n\tif (!(intel_hid_dsm_fn_mask & BIT(fn_index)))\n\t\tgoto skip_dsm_exec;\n\n\t \n\treq.type = ACPI_TYPE_INTEGER;\n\treq.integer.value = arg;\n\n\targv4.type = ACPI_TYPE_PACKAGE;\n\targv4.package.count = 1;\n\targv4.package.elements = &req;\n\n\tobj = acpi_evaluate_dsm(handle, &intel_dsm_guid, 1, fn_index, &argv4);\n\tif (obj) {\n\t\tacpi_handle_debug(handle, \"Exec DSM Fn code: %d[%s] success\\n\",\n\t\t\t\t  fn_index, method_name);\n\t\tACPI_FREE(obj);\n\t\treturn true;\n\t}\n\nskip_dsm_exec:\n\tstatus = acpi_execute_simple_method(handle, method_name, arg);\n\tif (ACPI_SUCCESS(status))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic bool intel_hid_evaluate_method(acpi_handle handle,\n\t\t\t\t      enum intel_hid_dsm_fn_codes fn_index,\n\t\t\t\t      unsigned long long *result)\n{\n\tunion acpi_object *obj;\n\tacpi_status status;\n\tchar *method_name;\n\n\tif (fn_index <= INTEL_HID_DSM_FN_INVALID ||\n\t    fn_index >= INTEL_HID_DSM_FN_MAX)\n\t\treturn false;\n\n\tmethod_name = (char *)intel_hid_dsm_fn_to_method[fn_index];\n\n\tif (!(intel_hid_dsm_fn_mask & BIT(fn_index)))\n\t\tgoto skip_dsm_eval;\n\n\tobj = acpi_evaluate_dsm_typed(handle, &intel_dsm_guid,\n\t\t\t\t      1, fn_index,\n\t\t\t\t      NULL,  ACPI_TYPE_INTEGER);\n\tif (obj) {\n\t\t*result = obj->integer.value;\n\t\tacpi_handle_debug(handle,\n\t\t\t\t  \"Eval DSM Fn code: %d[%s] results: 0x%llx\\n\",\n\t\t\t\t  fn_index, method_name, *result);\n\t\tACPI_FREE(obj);\n\t\treturn true;\n\t}\n\nskip_dsm_eval:\n\tstatus = acpi_evaluate_integer(handle, method_name, NULL, result);\n\tif (ACPI_SUCCESS(status))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic void intel_hid_init_dsm(acpi_handle handle)\n{\n\tunion acpi_object *obj;\n\n\tguid_parse(HID_EVENT_FILTER_UUID, &intel_dsm_guid);\n\n\tobj = acpi_evaluate_dsm_typed(handle, &intel_dsm_guid, 1, 0, NULL,\n\t\t\t\t      ACPI_TYPE_BUFFER);\n\tif (obj) {\n\t\tswitch (obj->buffer.length) {\n\t\tdefault:\n\t\tcase 2:\n\t\t\tintel_hid_dsm_fn_mask = *(u16 *)obj->buffer.pointer;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tintel_hid_dsm_fn_mask = *obj->buffer.pointer;\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tacpi_handle_warn(handle, \"intel_hid_dsm_fn_mask length is zero\\n\");\n\t\t\tintel_hid_dsm_fn_mask = 0;\n\t\t\tbreak;\n\t\t}\n\t\tACPI_FREE(obj);\n\t}\n\n\tacpi_handle_debug(handle, \"intel_hid_dsm_fn_mask = %llx\\n\",\n\t\t\t  intel_hid_dsm_fn_mask);\n}\n\nstatic int intel_hid_set_enable(struct device *device, bool enable)\n{\n\tacpi_handle handle = ACPI_HANDLE(device);\n\n\t \n\tif (!intel_hid_execute_method(handle, INTEL_HID_DSM_HDSM_FN,\n\t\t\t\t      enable)) {\n\t\tdev_warn(device, \"failed to %sable hotkeys\\n\",\n\t\t\t enable ? \"en\" : \"dis\");\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic void intel_button_array_enable(struct device *device, bool enable)\n{\n\tstruct intel_hid_priv *priv = dev_get_drvdata(device);\n\tacpi_handle handle = ACPI_HANDLE(device);\n\tunsigned long long button_cap;\n\tacpi_status status;\n\n\tif (!priv->array)\n\t\treturn;\n\n\t \n\tstatus = acpi_evaluate_integer(handle, \"BTNC\", NULL, &button_cap);\n\tif (ACPI_FAILURE(status)) {\n\t\tdev_warn(device, \"failed to get button capability\\n\");\n\t\treturn;\n\t}\n\n\t \n\tif (!intel_hid_execute_method(handle, INTEL_HID_DSM_BTNE_FN,\n\t\t\t\t      enable ? button_cap : 1))\n\t\tdev_warn(device, \"failed to set button capability\\n\");\n}\n\nstatic int intel_hid_pm_prepare(struct device *device)\n{\n\tif (device_may_wakeup(device)) {\n\t\tstruct intel_hid_priv *priv = dev_get_drvdata(device);\n\n\t\tpriv->wakeup_mode = true;\n\t}\n\treturn 0;\n}\n\nstatic void intel_hid_pm_complete(struct device *device)\n{\n\tstruct intel_hid_priv *priv = dev_get_drvdata(device);\n\n\tpriv->wakeup_mode = false;\n}\n\nstatic int intel_hid_pl_suspend_handler(struct device *device)\n{\n\tintel_button_array_enable(device, false);\n\n\tif (!pm_suspend_no_platform())\n\t\tintel_hid_set_enable(device, false);\n\n\treturn 0;\n}\n\nstatic int intel_hid_pl_resume_handler(struct device *device)\n{\n\tintel_hid_pm_complete(device);\n\n\tif (!pm_suspend_no_platform())\n\t\tintel_hid_set_enable(device, true);\n\n\tintel_button_array_enable(device, true);\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops intel_hid_pl_pm_ops = {\n\t.prepare = intel_hid_pm_prepare,\n\t.complete = intel_hid_pm_complete,\n\t.freeze  = intel_hid_pl_suspend_handler,\n\t.thaw  = intel_hid_pl_resume_handler,\n\t.restore  = intel_hid_pl_resume_handler,\n\t.suspend  = intel_hid_pl_suspend_handler,\n\t.resume  = intel_hid_pl_resume_handler,\n};\n\nstatic int intel_hid_input_setup(struct platform_device *device)\n{\n\tstruct intel_hid_priv *priv = dev_get_drvdata(&device->dev);\n\tint ret;\n\n\tpriv->input_dev = devm_input_allocate_device(&device->dev);\n\tif (!priv->input_dev)\n\t\treturn -ENOMEM;\n\n\tret = sparse_keymap_setup(priv->input_dev, intel_hid_keymap, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tpriv->input_dev->name = \"Intel HID events\";\n\tpriv->input_dev->id.bustype = BUS_HOST;\n\n\treturn input_register_device(priv->input_dev);\n}\n\nstatic int intel_button_array_input_setup(struct platform_device *device)\n{\n\tstruct intel_hid_priv *priv = dev_get_drvdata(&device->dev);\n\tint ret;\n\n\t \n\tpriv->array = devm_input_allocate_device(&device->dev);\n\tif (!priv->array)\n\t\treturn -ENOMEM;\n\n\tret = sparse_keymap_setup(priv->array, intel_array_keymap, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tpriv->array->name = \"Intel HID 5 button array\";\n\tpriv->array->id.bustype = BUS_HOST;\n\n\treturn input_register_device(priv->array);\n}\n\nstatic int intel_hid_switches_setup(struct platform_device *device)\n{\n\tstruct intel_hid_priv *priv = dev_get_drvdata(&device->dev);\n\n\t \n\tpriv->switches = devm_input_allocate_device(&device->dev);\n\tif (!priv->switches)\n\t\treturn -ENOMEM;\n\n\t__set_bit(EV_SW, priv->switches->evbit);\n\t__set_bit(SW_TABLET_MODE, priv->switches->swbit);\n\n\tpriv->switches->name = \"Intel HID switches\";\n\tpriv->switches->id.bustype = BUS_HOST;\n\treturn input_register_device(priv->switches);\n}\n\nstatic void report_tablet_mode_state(struct platform_device *device)\n{\n\tstruct intel_hid_priv *priv = dev_get_drvdata(&device->dev);\n\tacpi_handle handle = ACPI_HANDLE(&device->dev);\n\tunsigned long long vgbs;\n\tint m;\n\n\tif (!intel_hid_evaluate_method(handle, INTEL_HID_DSM_VGBS_FN, &vgbs))\n\t\treturn;\n\n\tm = !(vgbs & TABLET_MODE_FLAG);\n\tinput_report_switch(priv->switches, SW_TABLET_MODE, m);\n\tinput_sync(priv->switches);\n}\n\nstatic bool report_tablet_mode_event(struct input_dev *input_dev, u32 event)\n{\n\tif (!input_dev)\n\t\treturn false;\n\n\tswitch (event) {\n\tcase 0xcc:\n\t\tinput_report_switch(input_dev, SW_TABLET_MODE, 1);\n\t\tinput_sync(input_dev);\n\t\treturn true;\n\tcase 0xcd:\n\t\tinput_report_switch(input_dev, SW_TABLET_MODE, 0);\n\t\tinput_sync(input_dev);\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic void notify_handler(acpi_handle handle, u32 event, void *context)\n{\n\tstruct platform_device *device = context;\n\tstruct intel_hid_priv *priv = dev_get_drvdata(&device->dev);\n\tunsigned long long ev_index;\n\tint err;\n\n\t \n\tif (!priv->switches && enable_sw_tablet_mode == TABLET_SW_AT_EVENT &&\n\t    (event == 0xcc || event == 0xcd)) {\n\t\tdev_info(&device->dev, \"switch event received, enable switches supports\\n\");\n\t\terr = intel_hid_switches_setup(device);\n\t\tif (err)\n\t\t\tpr_err(\"Failed to setup Intel HID switches\\n\");\n\t}\n\n\tif (priv->wakeup_mode) {\n\t\t \n\t\tif (event == 0xce)\n\t\t\tgoto wakeup;\n\n\t\t \n\t\tif (event == 0xcc || event == 0xcd) {\n\t\t\treport_tablet_mode_event(priv->switches, event);\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tif (event == 0xc0 || !priv->array)\n\t\t\treturn;\n\n\t\tif (!sparse_keymap_entry_from_scancode(priv->array, event)) {\n\t\t\tdev_info(&device->dev, \"unknown event 0x%x\\n\", event);\n\t\t\treturn;\n\t\t}\n\nwakeup:\n\t\tpm_wakeup_hard_event(&device->dev);\n\n\t\treturn;\n\t}\n\n\t \n\tif (!priv->array) {\n\t\tif (event == 0xce) {\n\t\t\tinput_report_key(priv->input_dev, KEY_POWER, 1);\n\t\t\tinput_sync(priv->input_dev);\n\t\t\treturn;\n\t\t}\n\n\t\tif (event == 0xcf) {\n\t\t\tinput_report_key(priv->input_dev, KEY_POWER, 0);\n\t\t\tinput_sync(priv->input_dev);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (report_tablet_mode_event(priv->switches, event))\n\t\treturn;\n\n\t \n\tif (event != 0xc0) {\n\t\tif (!priv->array ||\n\t\t    !sparse_keymap_report_event(priv->array, event, 1, true))\n\t\t\tdev_dbg(&device->dev, \"unknown event 0x%x\\n\", event);\n\t\treturn;\n\t}\n\n\tif (!intel_hid_evaluate_method(handle, INTEL_HID_DSM_HDEM_FN,\n\t\t\t\t       &ev_index)) {\n\t\tdev_warn(&device->dev, \"failed to get event index\\n\");\n\t\treturn;\n\t}\n\n\tif (!sparse_keymap_report_event(priv->input_dev, ev_index, 1, true))\n\t\tdev_dbg(&device->dev, \"unknown event index 0x%llx\\n\",\n\t\t\t ev_index);\n}\n\nstatic bool button_array_present(struct platform_device *device)\n{\n\tacpi_handle handle = ACPI_HANDLE(&device->dev);\n\tunsigned long long event_cap;\n\n\tif (intel_hid_evaluate_method(handle, INTEL_HID_DSM_HEBC_V2_FN,\n\t\t\t\t      &event_cap)) {\n\t\t \n\t\tif (event_cap & 0x60000)\n\t\t\treturn true;\n\t}\n\n\tif (intel_hid_evaluate_method(handle, INTEL_HID_DSM_HEBC_V1_FN,\n\t\t\t\t      &event_cap)) {\n\t\tif (event_cap & 0x20000)\n\t\t\treturn true;\n\t}\n\n\tif (enable_5_button_array || dmi_check_system(button_array_table))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic int intel_hid_probe(struct platform_device *device)\n{\n\tacpi_handle handle = ACPI_HANDLE(&device->dev);\n\tunsigned long long mode, dummy;\n\tstruct intel_hid_priv *priv;\n\tacpi_status status;\n\tint err;\n\n\tintel_hid_init_dsm(handle);\n\n\tif (!intel_hid_evaluate_method(handle, INTEL_HID_DSM_HDMM_FN, &mode)) {\n\t\tdev_warn(&device->dev, \"failed to read mode\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (mode != 0) {\n\t\t \n\t\tdev_info(&device->dev, \"platform is not in simple mode\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tpriv = devm_kzalloc(&device->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\tdev_set_drvdata(&device->dev, priv);\n\n\t \n\tif (enable_sw_tablet_mode == TABLET_SW_AUTO) {\n\t\tif (dmi_check_system(dmi_vgbs_allow_list))\n\t\t\tenable_sw_tablet_mode = TABLET_SW_AT_PROBE;\n\t\telse if (dmi_check_system(dmi_auto_add_switch) && !dual_accel_detect())\n\t\t\tenable_sw_tablet_mode = TABLET_SW_AT_EVENT;\n\t\telse\n\t\t\tenable_sw_tablet_mode = TABLET_SW_OFF;\n\t}\n\n\terr = intel_hid_input_setup(device);\n\tif (err) {\n\t\tpr_err(\"Failed to setup Intel HID hotkeys\\n\");\n\t\treturn err;\n\t}\n\n\t \n\tif (button_array_present(device)) {\n\t\tdev_info(&device->dev, \"platform supports 5 button array\\n\");\n\t\terr = intel_button_array_input_setup(device);\n\t\tif (err)\n\t\t\tpr_err(\"Failed to setup Intel 5 button array hotkeys\\n\");\n\t}\n\n\t \n\tif (enable_sw_tablet_mode == TABLET_SW_AT_PROBE) {\n\t\tdev_info(&device->dev, \"platform supports switches\\n\");\n\t\terr = intel_hid_switches_setup(device);\n\t\tif (err)\n\t\t\tpr_err(\"Failed to setup Intel HID switches\\n\");\n\t\telse\n\t\t\treport_tablet_mode_state(device);\n\t}\n\n\tstatus = acpi_install_notify_handler(handle,\n\t\t\t\t\t     ACPI_DEVICE_NOTIFY,\n\t\t\t\t\t     notify_handler,\n\t\t\t\t\t     device);\n\tif (ACPI_FAILURE(status))\n\t\treturn -EBUSY;\n\n\terr = intel_hid_set_enable(&device->dev, true);\n\tif (err)\n\t\tgoto err_remove_notify;\n\n\tintel_button_array_enable(&device->dev, true);\n\n\t \n\tif (!intel_hid_evaluate_method(handle, INTEL_HID_DSM_BTNL_FN, &dummy))\n\t\tdev_warn(&device->dev, \"failed to enable HID power button\\n\");\n\n\tdevice_init_wakeup(&device->dev, true);\n\t \n\tacpi_ec_mark_gpe_for_wake();\n\treturn 0;\n\nerr_remove_notify:\n\tacpi_remove_notify_handler(handle, ACPI_DEVICE_NOTIFY, notify_handler);\n\n\treturn err;\n}\n\nstatic void intel_hid_remove(struct platform_device *device)\n{\n\tacpi_handle handle = ACPI_HANDLE(&device->dev);\n\n\tdevice_init_wakeup(&device->dev, false);\n\tacpi_remove_notify_handler(handle, ACPI_DEVICE_NOTIFY, notify_handler);\n\tintel_hid_set_enable(&device->dev, false);\n\tintel_button_array_enable(&device->dev, false);\n}\n\nstatic struct platform_driver intel_hid_pl_driver = {\n\t.driver = {\n\t\t.name = \"intel-hid\",\n\t\t.acpi_match_table = intel_hid_ids,\n\t\t.pm = &intel_hid_pl_pm_ops,\n\t},\n\t.probe = intel_hid_probe,\n\t.remove_new = intel_hid_remove,\n};\n\n \nstatic acpi_status __init\ncheck_acpi_dev(acpi_handle handle, u32 lvl, void *context, void **rv)\n{\n\tconst struct acpi_device_id *ids = context;\n\tstruct acpi_device *dev = acpi_fetch_acpi_dev(handle);\n\n\tif (dev && acpi_match_device_ids(dev, ids) == 0)\n\t\tif (!IS_ERR_OR_NULL(acpi_create_platform_device(dev, NULL)))\n\t\t\tdev_info(&dev->dev,\n\t\t\t\t \"intel-hid: created platform device\\n\");\n\n\treturn AE_OK;\n}\n\nstatic int __init intel_hid_init(void)\n{\n\tacpi_walk_namespace(ACPI_TYPE_DEVICE, ACPI_ROOT_OBJECT,\n\t\t\t    ACPI_UINT32_MAX, check_acpi_dev, NULL,\n\t\t\t    (void *)intel_hid_ids, NULL);\n\n\treturn platform_driver_register(&intel_hid_pl_driver);\n}\nmodule_init(intel_hid_init);\n\nstatic void __exit intel_hid_exit(void)\n{\n\tplatform_driver_unregister(&intel_hid_pl_driver);\n}\nmodule_exit(intel_hid_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}