{
  "module_name": "clk_and_regulator.c",
  "hash_id": "e2243b599051bd180d23bfa92017f1a6f23ca4920a111f05d9988245e317bf7a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/x86/intel/int3472/clk_and_regulator.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/clkdev.h>\n#include <linux/clk-provider.h>\n#include <linux/device.h>\n#include <linux/dmi.h>\n#include <linux/gpio/consumer.h>\n#include <linux/regulator/driver.h>\n#include <linux/slab.h>\n\n#include \"common.h\"\n\n \nstatic const guid_t img_clk_guid =\n\tGUID_INIT(0x82c0d13a, 0x78c5, 0x4244,\n\t\t  0x9b, 0xb1, 0xeb, 0x8b, 0x53, 0x9a, 0x8d, 0x11);\n\nstatic void skl_int3472_enable_clk(struct int3472_clock *clk, int enable)\n{\n\tstruct int3472_discrete_device *int3472 = to_int3472_device(clk);\n\tunion acpi_object args[3];\n\tunion acpi_object argv4;\n\n\tif (clk->ena_gpio) {\n\t\tgpiod_set_value_cansleep(clk->ena_gpio, enable);\n\t\treturn;\n\t}\n\n\targs[0].integer.type = ACPI_TYPE_INTEGER;\n\targs[0].integer.value = clk->imgclk_index;\n\targs[1].integer.type = ACPI_TYPE_INTEGER;\n\targs[1].integer.value = enable;\n\targs[2].integer.type = ACPI_TYPE_INTEGER;\n\targs[2].integer.value = 1;\n\n\targv4.type = ACPI_TYPE_PACKAGE;\n\targv4.package.count = 3;\n\targv4.package.elements = args;\n\n\tacpi_evaluate_dsm(acpi_device_handle(int3472->adev), &img_clk_guid,\n\t\t\t  0, 1, &argv4);\n}\n\n \nstatic const struct regulator_ops int3472_gpio_regulator_ops;\n\nstatic int skl_int3472_clk_prepare(struct clk_hw *hw)\n{\n\tskl_int3472_enable_clk(to_int3472_clk(hw), 1);\n\treturn 0;\n}\n\nstatic void skl_int3472_clk_unprepare(struct clk_hw *hw)\n{\n\tskl_int3472_enable_clk(to_int3472_clk(hw), 0);\n}\n\nstatic int skl_int3472_clk_enable(struct clk_hw *hw)\n{\n\t \n\treturn 0;\n}\n\nstatic void skl_int3472_clk_disable(struct clk_hw *hw)\n{\n\t \n}\n\nstatic unsigned int skl_int3472_get_clk_frequency(struct int3472_discrete_device *int3472)\n{\n\tunion acpi_object *obj;\n\tunsigned int freq;\n\n\tobj = skl_int3472_get_acpi_buffer(int3472->sensor, \"SSDB\");\n\tif (IS_ERR(obj))\n\t\treturn 0;  \n\n\tif (obj->buffer.length < CIO2_SENSOR_SSDB_MCLKSPEED_OFFSET + sizeof(u32)) {\n\t\tdev_err(int3472->dev, \"The buffer is too small\\n\");\n\t\tkfree(obj);\n\t\treturn 0;\n\t}\n\n\tfreq = *(u32 *)(obj->buffer.pointer + CIO2_SENSOR_SSDB_MCLKSPEED_OFFSET);\n\n\tkfree(obj);\n\treturn freq;\n}\n\nstatic unsigned long skl_int3472_clk_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t\t unsigned long parent_rate)\n{\n\tstruct int3472_clock *clk = to_int3472_clk(hw);\n\n\treturn clk->frequency;\n}\n\nstatic const struct clk_ops skl_int3472_clock_ops = {\n\t.prepare = skl_int3472_clk_prepare,\n\t.unprepare = skl_int3472_clk_unprepare,\n\t.enable = skl_int3472_clk_enable,\n\t.disable = skl_int3472_clk_disable,\n\t.recalc_rate = skl_int3472_clk_recalc_rate,\n};\n\nint skl_int3472_register_dsm_clock(struct int3472_discrete_device *int3472)\n{\n\tstruct acpi_device *adev = int3472->adev;\n\tstruct clk_init_data init = {\n\t\t.ops = &skl_int3472_clock_ops,\n\t\t.flags = CLK_GET_RATE_NOCACHE,\n\t};\n\tint ret;\n\n\tif (int3472->clock.cl)\n\t\treturn 0;  \n\n\tif (!acpi_check_dsm(adev->handle, &img_clk_guid, 0, BIT(1)))\n\t\treturn 0;  \n\n\tinit.name = kasprintf(GFP_KERNEL, \"%s-clk\", acpi_dev_name(adev));\n\tif (!init.name)\n\t\treturn -ENOMEM;\n\n\tint3472->clock.frequency = skl_int3472_get_clk_frequency(int3472);\n\tint3472->clock.clk_hw.init = &init;\n\tint3472->clock.clk = clk_register(&adev->dev, &int3472->clock.clk_hw);\n\tif (IS_ERR(int3472->clock.clk)) {\n\t\tret = PTR_ERR(int3472->clock.clk);\n\t\tgoto out_free_init_name;\n\t}\n\n\tint3472->clock.cl = clkdev_create(int3472->clock.clk, NULL, int3472->sensor_name);\n\tif (!int3472->clock.cl) {\n\t\tret = -ENOMEM;\n\t\tgoto err_unregister_clk;\n\t}\n\n\tkfree(init.name);\n\treturn 0;\n\nerr_unregister_clk:\n\tclk_unregister(int3472->clock.clk);\nout_free_init_name:\n\tkfree(init.name);\n\treturn ret;\n}\n\nint skl_int3472_register_gpio_clock(struct int3472_discrete_device *int3472,\n\t\t\t\t    struct acpi_resource_gpio *agpio, u32 polarity)\n{\n\tchar *path = agpio->resource_source.string_ptr;\n\tstruct clk_init_data init = {\n\t\t.ops = &skl_int3472_clock_ops,\n\t\t.flags = CLK_GET_RATE_NOCACHE,\n\t};\n\tint ret;\n\n\tif (int3472->clock.cl)\n\t\treturn -EBUSY;\n\n\tint3472->clock.ena_gpio = acpi_get_and_request_gpiod(path, agpio->pin_table[0],\n\t\t\t\t\t\t\t     \"int3472,clk-enable\");\n\tif (IS_ERR(int3472->clock.ena_gpio)) {\n\t\tret = PTR_ERR(int3472->clock.ena_gpio);\n\t\tint3472->clock.ena_gpio = NULL;\n\t\treturn dev_err_probe(int3472->dev, ret, \"getting clk-enable GPIO\\n\");\n\t}\n\n\tif (polarity == GPIO_ACTIVE_LOW)\n\t\tgpiod_toggle_active_low(int3472->clock.ena_gpio);\n\n\t \n\tgpiod_direction_output(int3472->clock.ena_gpio, 0);\n\n\tinit.name = kasprintf(GFP_KERNEL, \"%s-clk\",\n\t\t\t      acpi_dev_name(int3472->adev));\n\tif (!init.name) {\n\t\tret = -ENOMEM;\n\t\tgoto out_put_gpio;\n\t}\n\n\tint3472->clock.frequency = skl_int3472_get_clk_frequency(int3472);\n\n\tint3472->clock.clk_hw.init = &init;\n\tint3472->clock.clk = clk_register(&int3472->adev->dev,\n\t\t\t\t\t  &int3472->clock.clk_hw);\n\tif (IS_ERR(int3472->clock.clk)) {\n\t\tret = PTR_ERR(int3472->clock.clk);\n\t\tgoto out_free_init_name;\n\t}\n\n\tint3472->clock.cl = clkdev_create(int3472->clock.clk, NULL,\n\t\t\t\t\t  int3472->sensor_name);\n\tif (!int3472->clock.cl) {\n\t\tret = -ENOMEM;\n\t\tgoto err_unregister_clk;\n\t}\n\n\tkfree(init.name);\n\treturn 0;\n\nerr_unregister_clk:\n\tclk_unregister(int3472->clock.clk);\nout_free_init_name:\n\tkfree(init.name);\nout_put_gpio:\n\tgpiod_put(int3472->clock.ena_gpio);\n\n\treturn ret;\n}\n\nvoid skl_int3472_unregister_clock(struct int3472_discrete_device *int3472)\n{\n\tif (!int3472->clock.cl)\n\t\treturn;\n\n\tclkdev_drop(int3472->clock.cl);\n\tclk_unregister(int3472->clock.clk);\n\tgpiod_put(int3472->clock.ena_gpio);\n}\n\n \nstatic const char * const skl_int3472_regulator_map_supplies[] = {\n\t\"avdd\",\n\t\"AVDD\",\n};\n\nstatic_assert(ARRAY_SIZE(skl_int3472_regulator_map_supplies) ==\n\t      GPIO_REGULATOR_SUPPLY_MAP_COUNT);\n\n \nstatic const struct dmi_system_id skl_int3472_regulator_second_sensor[] = {\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"LENOVO\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_VERSION, \"MIIX 510-12IKB\"),\n\t\t},\n\t\t.driver_data = \"i2c-OVTI2680:00\",\n\t},\n\t{ }\n};\n\nint skl_int3472_register_regulator(struct int3472_discrete_device *int3472,\n\t\t\t\t   struct acpi_resource_gpio *agpio)\n{\n\tchar *path = agpio->resource_source.string_ptr;\n\tstruct regulator_init_data init_data = { };\n\tstruct regulator_config cfg = { };\n\tconst char *second_sensor = NULL;\n\tconst struct dmi_system_id *id;\n\tint i, j, ret;\n\n\tid = dmi_first_match(skl_int3472_regulator_second_sensor);\n\tif (id)\n\t\tsecond_sensor = id->driver_data;\n\n\tfor (i = 0, j = 0; i < ARRAY_SIZE(skl_int3472_regulator_map_supplies); i++) {\n\t\tint3472->regulator.supply_map[j].supply = skl_int3472_regulator_map_supplies[i];\n\t\tint3472->regulator.supply_map[j].dev_name = int3472->sensor_name;\n\t\tj++;\n\n\t\tif (second_sensor) {\n\t\t\tint3472->regulator.supply_map[j].supply =\n\t\t\t\tskl_int3472_regulator_map_supplies[i];\n\t\t\tint3472->regulator.supply_map[j].dev_name = second_sensor;\n\t\t\tj++;\n\t\t}\n\t}\n\n\tinit_data.constraints.valid_ops_mask = REGULATOR_CHANGE_STATUS;\n\tinit_data.consumer_supplies = int3472->regulator.supply_map;\n\tinit_data.num_consumer_supplies = j;\n\n\tsnprintf(int3472->regulator.regulator_name,\n\t\t sizeof(int3472->regulator.regulator_name), \"%s-regulator\",\n\t\t acpi_dev_name(int3472->adev));\n\tsnprintf(int3472->regulator.supply_name,\n\t\t GPIO_REGULATOR_SUPPLY_NAME_LENGTH, \"supply-0\");\n\n\tint3472->regulator.rdesc = INT3472_REGULATOR(\n\t\t\t\t\t\tint3472->regulator.regulator_name,\n\t\t\t\t\t\tint3472->regulator.supply_name,\n\t\t\t\t\t\t&int3472_gpio_regulator_ops);\n\n\tint3472->regulator.gpio = acpi_get_and_request_gpiod(path, agpio->pin_table[0],\n\t\t\t\t\t\t\t     \"int3472,regulator\");\n\tif (IS_ERR(int3472->regulator.gpio)) {\n\t\tret = PTR_ERR(int3472->regulator.gpio);\n\t\tint3472->regulator.gpio = NULL;\n\t\treturn dev_err_probe(int3472->dev, ret, \"getting regulator GPIO\\n\");\n\t}\n\n\t \n\tgpiod_direction_output(int3472->regulator.gpio, 0);\n\n\tcfg.dev = &int3472->adev->dev;\n\tcfg.init_data = &init_data;\n\tcfg.ena_gpiod = int3472->regulator.gpio;\n\n\tint3472->regulator.rdev = regulator_register(int3472->dev,\n\t\t\t\t\t\t     &int3472->regulator.rdesc,\n\t\t\t\t\t\t     &cfg);\n\tif (IS_ERR(int3472->regulator.rdev)) {\n\t\tret = PTR_ERR(int3472->regulator.rdev);\n\t\tgoto err_free_gpio;\n\t}\n\n\treturn 0;\n\nerr_free_gpio:\n\tgpiod_put(int3472->regulator.gpio);\n\n\treturn ret;\n}\n\nvoid skl_int3472_unregister_regulator(struct int3472_discrete_device *int3472)\n{\n\tregulator_unregister(int3472->regulator.rdev);\n\tgpiod_put(int3472->regulator.gpio);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}