{
  "module_name": "common.c",
  "hash_id": "8ec87a2f5307aaf3b63ea7b2d636954cee18ffdb4a858f4e1896b4fd33dfc714",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/x86/intel/int3472/common.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/slab.h>\n\n#include \"common.h\"\n\nunion acpi_object *skl_int3472_get_acpi_buffer(struct acpi_device *adev, char *id)\n{\n\tstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };\n\tacpi_handle handle = adev->handle;\n\tunion acpi_object *obj;\n\tacpi_status status;\n\n\tstatus = acpi_evaluate_object(handle, id, NULL, &buffer);\n\tif (ACPI_FAILURE(status))\n\t\treturn ERR_PTR(-ENODEV);\n\n\tobj = buffer.pointer;\n\tif (!obj)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tif (obj->type != ACPI_TYPE_BUFFER) {\n\t\tacpi_handle_err(handle, \"%s object is not an ACPI buffer\\n\", id);\n\t\tkfree(obj);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn obj;\n}\n\nint skl_int3472_fill_cldb(struct acpi_device *adev, struct int3472_cldb *cldb)\n{\n\tunion acpi_object *obj;\n\tint ret;\n\n\tobj = skl_int3472_get_acpi_buffer(adev, \"CLDB\");\n\tif (IS_ERR(obj))\n\t\treturn PTR_ERR(obj);\n\n\tif (obj->buffer.length > sizeof(*cldb)) {\n\t\tacpi_handle_err(adev->handle, \"The CLDB buffer is too large\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out_free_obj;\n\t}\n\n\tmemcpy(cldb, obj->buffer.pointer, obj->buffer.length);\n\tret = 0;\n\nout_free_obj:\n\tkfree(obj);\n\treturn ret;\n}\n\n \nint skl_int3472_get_sensor_adev_and_name(struct device *dev,\n\t\t\t\t\t struct acpi_device **sensor_adev_ret,\n\t\t\t\t\t const char **name_ret)\n{\n\tstruct acpi_device *adev = ACPI_COMPANION(dev);\n\tstruct acpi_device *sensor;\n\tint ret = 0;\n\n\tsensor = acpi_dev_get_next_consumer_dev(adev, NULL);\n\tif (!sensor) {\n\t\tdev_err(dev, \"INT3472 seems to have no dependents.\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t*name_ret = devm_kasprintf(dev, GFP_KERNEL, I2C_DEV_NAME_FORMAT,\n\t\t\t\t   acpi_dev_name(sensor));\n\tif (!*name_ret)\n\t\tret = -ENOMEM;\n\n\tif (ret == 0 && sensor_adev_ret)\n\t\t*sensor_adev_ret = sensor;\n\telse\n\t\tacpi_dev_put(sensor);\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}