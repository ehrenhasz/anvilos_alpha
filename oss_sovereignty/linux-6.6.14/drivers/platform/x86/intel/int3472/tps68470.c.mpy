{
  "module_name": "tps68470.c",
  "hash_id": "fec7e6df0eb6c301f0dd72a1444bc76a9be389e23bf9f5cf51c1d3a0a5d2bb17",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/x86/intel/int3472/tps68470.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/i2c.h>\n#include <linux/kernel.h>\n#include <linux/mfd/core.h>\n#include <linux/mfd/tps68470.h>\n#include <linux/platform_device.h>\n#include <linux/platform_data/tps68470.h>\n#include <linux/regmap.h>\n#include <linux/string.h>\n\n#include \"common.h\"\n#include \"tps68470.h\"\n\n#define DESIGNED_FOR_CHROMEOS\t\t1\n#define DESIGNED_FOR_WINDOWS\t\t2\n\n#define TPS68470_WIN_MFD_CELL_COUNT\t3\n\nstatic const struct mfd_cell tps68470_cros[] = {\n\t{ .name = \"tps68470-gpio\" },\n\t{ .name = \"tps68470_pmic_opregion\" },\n};\n\nstatic const struct regmap_config tps68470_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.max_register = TPS68470_REG_MAX,\n};\n\nstatic int tps68470_chip_init(struct device *dev, struct regmap *regmap)\n{\n\tunsigned int version;\n\tint ret;\n\n\t \n\tret = regmap_write(regmap, TPS68470_REG_RESET, TPS68470_REG_RESET_MASK);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_read(regmap, TPS68470_REG_REVID, &version);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to read revision register: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tdev_info(dev, \"TPS68470 REVID: 0x%02x\\n\", version);\n\n\treturn 0;\n}\n\n \nstatic int skl_int3472_tps68470_calc_type(struct acpi_device *adev)\n{\n\tstruct int3472_cldb cldb = { 0 };\n\tint ret;\n\n\t \n\tret = skl_int3472_fill_cldb(adev, &cldb);\n\tif (ret && ret != -ENODEV)\n\t\treturn ret;\n\n\tif (ret)\n\t\treturn DESIGNED_FOR_CHROMEOS;\n\n\tif (cldb.control_logic_type != 2)\n\t\treturn -EINVAL;\n\n\treturn DESIGNED_FOR_WINDOWS;\n}\n\n \nstatic int\nskl_int3472_fill_clk_pdata(struct device *dev, struct tps68470_clk_platform_data **clk_pdata)\n{\n\tstruct acpi_device *adev = ACPI_COMPANION(dev);\n\tstruct acpi_device *consumer;\n\tunsigned int n_consumers = 0;\n\tconst char *sensor_name;\n\tunsigned int i = 0;\n\n\tfor_each_acpi_consumer_dev(adev, consumer)\n\t\tn_consumers++;\n\n\tif (!n_consumers) {\n\t\tdev_err(dev, \"INT3472 seems to have no dependents\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t*clk_pdata = devm_kzalloc(dev, struct_size(*clk_pdata, consumers, n_consumers),\n\t\t\t\t  GFP_KERNEL);\n\tif (!*clk_pdata)\n\t\treturn -ENOMEM;\n\n\t(*clk_pdata)->n_consumers = n_consumers;\n\ti = 0;\n\n\tfor_each_acpi_consumer_dev(adev, consumer) {\n\t\tsensor_name = devm_kasprintf(dev, GFP_KERNEL, I2C_DEV_NAME_FORMAT,\n\t\t\t\t\t     acpi_dev_name(consumer));\n\t\tif (!sensor_name) {\n\t\t\tacpi_dev_put(consumer);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\t(*clk_pdata)->consumers[i].consumer_dev_name = sensor_name;\n\t\ti++;\n\t}\n\n\treturn n_consumers;\n}\n\nstatic int skl_int3472_tps68470_probe(struct i2c_client *client)\n{\n\tstruct acpi_device *adev = ACPI_COMPANION(&client->dev);\n\tconst struct int3472_tps68470_board_data *board_data;\n\tstruct tps68470_clk_platform_data *clk_pdata;\n\tstruct mfd_cell *cells;\n\tstruct regmap *regmap;\n\tint n_consumers;\n\tint device_type;\n\tint ret;\n\tint i;\n\n\tn_consumers = skl_int3472_fill_clk_pdata(&client->dev, &clk_pdata);\n\tif (n_consumers < 0)\n\t\treturn n_consumers;\n\n\tregmap = devm_regmap_init_i2c(client, &tps68470_regmap_config);\n\tif (IS_ERR(regmap)) {\n\t\tdev_err(&client->dev, \"Failed to create regmap: %ld\\n\", PTR_ERR(regmap));\n\t\treturn PTR_ERR(regmap);\n\t}\n\n\ti2c_set_clientdata(client, regmap);\n\n\tret = tps68470_chip_init(&client->dev, regmap);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"TPS68470 init error %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tdevice_type = skl_int3472_tps68470_calc_type(adev);\n\tswitch (device_type) {\n\tcase DESIGNED_FOR_WINDOWS:\n\t\tboard_data = int3472_tps68470_get_board_data(dev_name(&client->dev));\n\t\tif (!board_data)\n\t\t\treturn dev_err_probe(&client->dev, -ENODEV, \"No board-data found for this model\\n\");\n\n\t\tcells = kcalloc(TPS68470_WIN_MFD_CELL_COUNT, sizeof(*cells), GFP_KERNEL);\n\t\tif (!cells)\n\t\t\treturn -ENOMEM;\n\n\t\t \n\t\tcells[0].name = \"tps68470-clk\";\n\t\tcells[0].platform_data = clk_pdata;\n\t\tcells[0].pdata_size = struct_size(clk_pdata, consumers, n_consumers);\n\t\tcells[1].name = \"tps68470-regulator\";\n\t\tcells[1].platform_data = (void *)board_data->tps68470_regulator_pdata;\n\t\tcells[1].pdata_size = sizeof(struct tps68470_regulator_platform_data);\n\t\tcells[2].name = \"tps68470-gpio\";\n\n\t\tfor (i = 0; i < board_data->n_gpiod_lookups; i++)\n\t\t\tgpiod_add_lookup_table(board_data->tps68470_gpio_lookup_tables[i]);\n\n\t\tret = devm_mfd_add_devices(&client->dev, PLATFORM_DEVID_NONE,\n\t\t\t\t\t   cells, TPS68470_WIN_MFD_CELL_COUNT,\n\t\t\t\t\t   NULL, 0, NULL);\n\t\tkfree(cells);\n\n\t\tif (ret) {\n\t\t\tfor (i = 0; i < board_data->n_gpiod_lookups; i++)\n\t\t\t\tgpiod_remove_lookup_table(board_data->tps68470_gpio_lookup_tables[i]);\n\t\t}\n\n\t\tbreak;\n\tcase DESIGNED_FOR_CHROMEOS:\n\t\tret = devm_mfd_add_devices(&client->dev, PLATFORM_DEVID_NONE,\n\t\t\t\t\t   tps68470_cros, ARRAY_SIZE(tps68470_cros),\n\t\t\t\t\t   NULL, 0, NULL);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&client->dev, \"Failed to add MFD devices\\n\");\n\t\treturn device_type;\n\t}\n\n\t \n\n\treturn ret;\n}\n\nstatic void skl_int3472_tps68470_remove(struct i2c_client *client)\n{\n\tconst struct int3472_tps68470_board_data *board_data;\n\tint i;\n\n\tboard_data = int3472_tps68470_get_board_data(dev_name(&client->dev));\n\tif (board_data) {\n\t\tfor (i = 0; i < board_data->n_gpiod_lookups; i++)\n\t\t\tgpiod_remove_lookup_table(board_data->tps68470_gpio_lookup_tables[i]);\n\t}\n}\n\nstatic const struct acpi_device_id int3472_device_id[] = {\n\t{ \"INT3472\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(acpi, int3472_device_id);\n\nstatic struct i2c_driver int3472_tps68470 = {\n\t.driver = {\n\t\t.name = \"int3472-tps68470\",\n\t\t.acpi_match_table = int3472_device_id,\n\t},\n\t.probe = skl_int3472_tps68470_probe,\n\t.remove = skl_int3472_tps68470_remove,\n};\nmodule_i2c_driver(int3472_tps68470);\n\nMODULE_DESCRIPTION(\"Intel SkyLake INT3472 ACPI TPS68470 Device Driver\");\nMODULE_AUTHOR(\"Daniel Scally <djrscally@gmail.com>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_SOFTDEP(\"pre: clk-tps68470 tps68470-regulator\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}