{
  "module_name": "discrete.c",
  "hash_id": "b731e51b585a3cacab4a8c0d09464bcdd23b8b4bb15c6765819b3168d1585acb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/x86/intel/int3472/discrete.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/bitfield.h>\n#include <linux/device.h>\n#include <linux/gpio/consumer.h>\n#include <linux/gpio/machine.h>\n#include <linux/i2c.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/overflow.h>\n#include <linux/platform_device.h>\n#include <linux/uuid.h>\n\n#include \"common.h\"\n\n \nstatic const guid_t int3472_gpio_guid =\n\tGUID_INIT(0x79234640, 0x9e10, 0x4fea,\n\t\t  0xa5, 0xc1, 0xb5, 0xaa, 0x8b, 0x19, 0x75, 0x6f);\n\n#define INT3472_GPIO_DSM_TYPE\t\t\t\tGENMASK(7, 0)\n#define INT3472_GPIO_DSM_PIN\t\t\t\tGENMASK(15, 8)\n#define INT3472_GPIO_DSM_SENSOR_ON_VAL\t\t\tGENMASK(31, 24)\n\n \nstatic const guid_t cio2_sensor_module_guid =\n\tGUID_INIT(0x822ace8f, 0x2814, 0x4174,\n\t\t  0xa5, 0x6b, 0x5f, 0x02, 0x9f, 0xe0, 0x79, 0xee);\n\nstatic void skl_int3472_log_sensor_module_name(struct int3472_discrete_device *int3472)\n{\n\tunion acpi_object *obj;\n\n\tobj = acpi_evaluate_dsm_typed(int3472->sensor->handle,\n\t\t\t\t      &cio2_sensor_module_guid, 0x00,\n\t\t\t\t      0x01, NULL, ACPI_TYPE_STRING);\n\tif (obj) {\n\t\tdev_dbg(int3472->dev, \"Sensor module id: '%s'\\n\", obj->string.pointer);\n\t\tACPI_FREE(obj);\n\t}\n}\n\nstatic int skl_int3472_map_gpio_to_sensor(struct int3472_discrete_device *int3472,\n\t\t\t\t\t  struct acpi_resource_gpio *agpio,\n\t\t\t\t\t  const char *func, u32 polarity)\n{\n\tchar *path = agpio->resource_source.string_ptr;\n\tstruct gpiod_lookup *table_entry;\n\tstruct acpi_device *adev;\n\tacpi_handle handle;\n\tacpi_status status;\n\n\tif (int3472->n_sensor_gpios >= INT3472_MAX_SENSOR_GPIOS) {\n\t\tdev_warn(int3472->dev, \"Too many GPIOs mapped\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tstatus = acpi_get_handle(NULL, path, &handle);\n\tif (ACPI_FAILURE(status))\n\t\treturn -EINVAL;\n\n\tadev = acpi_fetch_acpi_dev(handle);\n\tif (!adev)\n\t\treturn -ENODEV;\n\n\ttable_entry = &int3472->gpios.table[int3472->n_sensor_gpios];\n\ttable_entry->key = acpi_dev_name(adev);\n\ttable_entry->chip_hwnum = agpio->pin_table[0];\n\ttable_entry->con_id = func;\n\ttable_entry->idx = 0;\n\ttable_entry->flags = polarity;\n\n\tint3472->n_sensor_gpios++;\n\n\treturn 0;\n}\n\nstatic void int3472_get_func_and_polarity(u8 type, const char **func, u32 *polarity)\n{\n\tswitch (type) {\n\tcase INT3472_GPIO_TYPE_RESET:\n\t\t*func = \"reset\";\n\t\t*polarity = GPIO_ACTIVE_LOW;\n\t\tbreak;\n\tcase INT3472_GPIO_TYPE_POWERDOWN:\n\t\t*func = \"powerdown\";\n\t\t*polarity = GPIO_ACTIVE_LOW;\n\t\tbreak;\n\tcase INT3472_GPIO_TYPE_CLK_ENABLE:\n\t\t*func = \"clk-enable\";\n\t\t*polarity = GPIO_ACTIVE_HIGH;\n\t\tbreak;\n\tcase INT3472_GPIO_TYPE_PRIVACY_LED:\n\t\t*func = \"privacy-led\";\n\t\t*polarity = GPIO_ACTIVE_HIGH;\n\t\tbreak;\n\tcase INT3472_GPIO_TYPE_POWER_ENABLE:\n\t\t*func = \"power-enable\";\n\t\t*polarity = GPIO_ACTIVE_HIGH;\n\t\tbreak;\n\tdefault:\n\t\t*func = \"unknown\";\n\t\t*polarity = GPIO_ACTIVE_HIGH;\n\t\tbreak;\n\t}\n}\n\n \nstatic int skl_int3472_handle_gpio_resources(struct acpi_resource *ares,\n\t\t\t\t\t     void *data)\n{\n\tstruct int3472_discrete_device *int3472 = data;\n\tstruct acpi_resource_gpio *agpio;\n\tu8 active_value, pin, type;\n\tunion acpi_object *obj;\n\tconst char *err_msg;\n\tconst char *func;\n\tu32 polarity;\n\tint ret;\n\n\tif (!acpi_gpio_get_io_resource(ares, &agpio))\n\t\treturn 1;\n\n\t \n\tobj = acpi_evaluate_dsm_typed(int3472->adev->handle,\n\t\t\t\t      &int3472_gpio_guid, 0x00,\n\t\t\t\t      int3472->ngpios + 2,\n\t\t\t\t      NULL, ACPI_TYPE_INTEGER);\n\n\tif (!obj) {\n\t\tdev_warn(int3472->dev, \"No _DSM entry for GPIO pin %u\\n\",\n\t\t\t agpio->pin_table[0]);\n\t\treturn 1;\n\t}\n\n\ttype = FIELD_GET(INT3472_GPIO_DSM_TYPE, obj->integer.value);\n\n\tint3472_get_func_and_polarity(type, &func, &polarity);\n\n\tpin = FIELD_GET(INT3472_GPIO_DSM_PIN, obj->integer.value);\n\tif (pin != agpio->pin_table[0])\n\t\tdev_warn(int3472->dev, \"%s %s pin number mismatch _DSM %d resource %d\\n\",\n\t\t\t func, agpio->resource_source.string_ptr, pin,\n\t\t\t agpio->pin_table[0]);\n\n\tactive_value = FIELD_GET(INT3472_GPIO_DSM_SENSOR_ON_VAL, obj->integer.value);\n\tif (!active_value)\n\t\tpolarity ^= GPIO_ACTIVE_LOW;\n\n\tdev_dbg(int3472->dev, \"%s %s pin %d active-%s\\n\", func,\n\t\tagpio->resource_source.string_ptr, agpio->pin_table[0],\n\t\t(polarity == GPIO_ACTIVE_HIGH) ? \"high\" : \"low\");\n\n\tswitch (type) {\n\tcase INT3472_GPIO_TYPE_RESET:\n\tcase INT3472_GPIO_TYPE_POWERDOWN:\n\t\tret = skl_int3472_map_gpio_to_sensor(int3472, agpio, func, polarity);\n\t\tif (ret)\n\t\t\terr_msg = \"Failed to map GPIO pin to sensor\\n\";\n\n\t\tbreak;\n\tcase INT3472_GPIO_TYPE_CLK_ENABLE:\n\t\tret = skl_int3472_register_gpio_clock(int3472, agpio, polarity);\n\t\tif (ret)\n\t\t\terr_msg = \"Failed to register clock\\n\";\n\n\t\tbreak;\n\tcase INT3472_GPIO_TYPE_PRIVACY_LED:\n\t\tret = skl_int3472_register_pled(int3472, agpio, polarity);\n\t\tif (ret)\n\t\t\terr_msg = \"Failed to register LED\\n\";\n\n\t\tbreak;\n\tcase INT3472_GPIO_TYPE_POWER_ENABLE:\n\t\tret = skl_int3472_register_regulator(int3472, agpio);\n\t\tif (ret)\n\t\t\terr_msg = \"Failed to map regulator to sensor\\n\";\n\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(int3472->dev,\n\t\t\t \"GPIO type 0x%02x unknown; the sensor may not work\\n\",\n\t\t\t type);\n\t\tret = 1;\n\t\tbreak;\n\t}\n\n\tint3472->ngpios++;\n\tACPI_FREE(obj);\n\n\tif (ret < 0)\n\t\treturn dev_err_probe(int3472->dev, ret, err_msg);\n\n\treturn ret;\n}\n\nstatic int skl_int3472_parse_crs(struct int3472_discrete_device *int3472)\n{\n\tLIST_HEAD(resource_list);\n\tint ret;\n\n\tskl_int3472_log_sensor_module_name(int3472);\n\n\tret = acpi_dev_get_resources(int3472->adev, &resource_list,\n\t\t\t\t     skl_int3472_handle_gpio_resources,\n\t\t\t\t     int3472);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tacpi_dev_free_resource_list(&resource_list);\n\n\t \n\tret = skl_int3472_register_dsm_clock(int3472);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tint3472->gpios.dev_id = int3472->sensor_name;\n\tgpiod_add_lookup_table(&int3472->gpios);\n\n\treturn 0;\n}\n\nstatic void skl_int3472_discrete_remove(struct platform_device *pdev)\n{\n\tstruct int3472_discrete_device *int3472 = platform_get_drvdata(pdev);\n\n\tgpiod_remove_lookup_table(&int3472->gpios);\n\n\tskl_int3472_unregister_clock(int3472);\n\tskl_int3472_unregister_pled(int3472);\n\tskl_int3472_unregister_regulator(int3472);\n}\n\nstatic int skl_int3472_discrete_probe(struct platform_device *pdev)\n{\n\tstruct acpi_device *adev = ACPI_COMPANION(&pdev->dev);\n\tstruct int3472_discrete_device *int3472;\n\tstruct int3472_cldb cldb;\n\tint ret;\n\n\tret = skl_int3472_fill_cldb(adev, &cldb);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Couldn't fill CLDB structure\\n\");\n\t\treturn ret;\n\t}\n\n\tif (cldb.control_logic_type != 1) {\n\t\tdev_err(&pdev->dev, \"Unsupported control logic type %u\\n\",\n\t\t\tcldb.control_logic_type);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tint3472 = devm_kzalloc(&pdev->dev, struct_size(int3472, gpios.table,\n\t\t\t       INT3472_MAX_SENSOR_GPIOS + 1), GFP_KERNEL);\n\tif (!int3472)\n\t\treturn -ENOMEM;\n\n\tint3472->adev = adev;\n\tint3472->dev = &pdev->dev;\n\tplatform_set_drvdata(pdev, int3472);\n\tint3472->clock.imgclk_index = cldb.clock_source;\n\n\tret = skl_int3472_get_sensor_adev_and_name(&pdev->dev, &int3472->sensor,\n\t\t\t\t\t\t   &int3472->sensor_name);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tINIT_LIST_HEAD(&int3472->gpios.list);\n\n\tret = skl_int3472_parse_crs(int3472);\n\tif (ret) {\n\t\tskl_int3472_discrete_remove(pdev);\n\t\treturn ret;\n\t}\n\n\tacpi_dev_clear_dependencies(adev);\n\treturn 0;\n}\n\nstatic const struct acpi_device_id int3472_device_id[] = {\n\t{ \"INT3472\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(acpi, int3472_device_id);\n\nstatic struct platform_driver int3472_discrete = {\n\t.driver = {\n\t\t.name = \"int3472-discrete\",\n\t\t.acpi_match_table = int3472_device_id,\n\t},\n\t.probe = skl_int3472_discrete_probe,\n\t.remove_new = skl_int3472_discrete_remove,\n};\nmodule_platform_driver(int3472_discrete);\n\nMODULE_DESCRIPTION(\"Intel SkyLake INT3472 ACPI Discrete Device Driver\");\nMODULE_AUTHOR(\"Daniel Scally <djrscally@gmail.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}