{
  "module_name": "intel_sar.c",
  "hash_id": "4ea426aae3da4352aa9a639466a018a6f1d2d126942f5196ad34711f03c0dfbb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/x86/intel/int1092/intel_sar.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/kobject.h>\n#include <linux/platform_device.h>\n#include <linux/sysfs.h>\n#include \"intel_sar.h\"\n\n \nstatic int get_int_value(union acpi_object *obj, int *out)\n{\n\tif (!obj || obj->type != ACPI_TYPE_INTEGER)\n\t\treturn -EIO;\n\t*out = (int)obj->integer.value;\n\treturn 0;\n}\n\n \nstatic void update_sar_data(struct wwan_sar_context *context)\n{\n\tstruct wwan_device_mode_configuration *config =\n\t\t&context->config_data[context->reg_value];\n\n\tif (config->device_mode_info &&\n\t    context->sar_data.device_mode < config->total_dev_mode) {\n\t\tint itr = 0;\n\n\t\tfor (itr = 0; itr < config->total_dev_mode; itr++) {\n\t\t\tif (context->sar_data.device_mode ==\n\t\t\t\tconfig->device_mode_info[itr].device_mode) {\n\t\t\t\tstruct wwan_device_mode_info *dev_mode =\n\t\t\t\t&config->device_mode_info[itr];\n\n\t\t\t\tcontext->sar_data.antennatable_index = dev_mode->antennatable_index;\n\t\t\t\tcontext->sar_data.bandtable_index = dev_mode->bandtable_index;\n\t\t\t\tcontext->sar_data.sartable_index = dev_mode->sartable_index;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\n \nstatic acpi_status parse_package(struct wwan_sar_context *context, union acpi_object *item)\n{\n\tstruct wwan_device_mode_configuration *data;\n\tint value, itr, reg;\n\tunion acpi_object *num;\n\n\tnum = &item->package.elements[0];\n\tif (get_int_value(num, &value) || value < 0 || value >= MAX_REGULATORY)\n\t\treturn AE_ERROR;\n\n\treg = value;\n\n\tdata = &context->config_data[reg];\n\tif (data->total_dev_mode > MAX_DEV_MODES ||\tdata->total_dev_mode == 0 ||\n\t    item->package.count <= data->total_dev_mode)\n\t\treturn AE_ERROR;\n\n\tdata->device_mode_info = kmalloc_array(data->total_dev_mode,\n\t\t\t\t\t       sizeof(struct wwan_device_mode_info), GFP_KERNEL);\n\tif (!data->device_mode_info)\n\t\treturn AE_ERROR;\n\n\tfor (itr = 0; itr < data->total_dev_mode; itr++) {\n\t\tstruct wwan_device_mode_info temp = { 0 };\n\n\t\tnum = &item->package.elements[itr + 1];\n\t\tif (num->type != ACPI_TYPE_PACKAGE || num->package.count < TOTAL_DATA)\n\t\t\tcontinue;\n\t\tif (get_int_value(&num->package.elements[0], &temp.device_mode))\n\t\t\tcontinue;\n\t\tif (get_int_value(&num->package.elements[1], &temp.bandtable_index))\n\t\t\tcontinue;\n\t\tif (get_int_value(&num->package.elements[2], &temp.antennatable_index))\n\t\t\tcontinue;\n\t\tif (get_int_value(&num->package.elements[3], &temp.sartable_index))\n\t\t\tcontinue;\n\t\tdata->device_mode_info[itr] = temp;\n\t}\n\treturn AE_OK;\n}\n\n \nstatic acpi_status sar_get_device_mode(struct platform_device *device)\n{\n\tstruct wwan_sar_context *context = dev_get_drvdata(&device->dev);\n\tacpi_status status = AE_OK;\n\tunion acpi_object *out;\n\tu32 rev = 0;\n\n\tout = acpi_evaluate_dsm_typed(context->handle, &context->guid, rev,\n\t\t\t\t      COMMAND_ID_DEV_MODE, NULL, ACPI_TYPE_INTEGER);\n\tif (!out) {\n\t\tdev_err(&device->dev, \"DSM cmd:%d Failed to retrieve value\\n\", COMMAND_ID_DEV_MODE);\n\t\tstatus = AE_ERROR;\n\t\tgoto dev_mode_error;\n\t}\n\tcontext->sar_data.device_mode = out->integer.value;\n\tupdate_sar_data(context);\n\tsysfs_notify(&device->dev.kobj, NULL, SYSFS_DATANAME);\n\ndev_mode_error:\n\tACPI_FREE(out);\n\treturn status;\n}\n\nstatic const struct acpi_device_id sar_device_ids[] = {\n\t{ \"INTC1092\", 0},\n\t{}\n};\nMODULE_DEVICE_TABLE(acpi, sar_device_ids);\n\nstatic ssize_t intc_data_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct wwan_sar_context *context = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%d %d %d %d\\n\", context->sar_data.device_mode,\n\t\t      context->sar_data.bandtable_index,\n\t\t      context->sar_data.antennatable_index,\n\t\t      context->sar_data.sartable_index);\n}\nstatic DEVICE_ATTR_RO(intc_data);\n\nstatic ssize_t intc_reg_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct wwan_sar_context *context = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%d\\n\", context->reg_value);\n}\n\nstatic ssize_t intc_reg_store(struct device *dev, struct device_attribute *attr,\n\t\t\t      const char *buf, size_t count)\n{\n\tstruct wwan_sar_context *context = dev_get_drvdata(dev);\n\tunsigned int value;\n\tint read;\n\n\tif (!count)\n\t\treturn -EINVAL;\n\tread = kstrtouint(buf, 10, &value);\n\tif (read < 0)\n\t\treturn read;\n\tif (value >= MAX_REGULATORY)\n\t\treturn -EOVERFLOW;\n\tcontext->reg_value = value;\n\tupdate_sar_data(context);\n\tsysfs_notify(&dev->kobj, NULL, SYSFS_DATANAME);\n\treturn count;\n}\nstatic DEVICE_ATTR_RW(intc_reg);\n\nstatic struct attribute *intcsar_attrs[] = {\n\t&dev_attr_intc_data.attr,\n\t&dev_attr_intc_reg.attr,\n\tNULL\n};\n\nstatic struct attribute_group intcsar_group = {\n\t.attrs = intcsar_attrs,\n};\n\nstatic void sar_notify(acpi_handle handle, u32 event, void *data)\n{\n\tstruct platform_device *device = data;\n\n\tif (event == SAR_EVENT) {\n\t\tif (sar_get_device_mode(device) != AE_OK)\n\t\t\tdev_err(&device->dev, \"sar_get_device_mode error\");\n\t}\n}\n\nstatic void sar_get_data(int reg, struct wwan_sar_context *context)\n{\n\tunion acpi_object *out, req;\n\tu32 rev = 0;\n\n\treq.type = ACPI_TYPE_INTEGER;\n\treq.integer.value = reg;\n\tout = acpi_evaluate_dsm_typed(context->handle, &context->guid, rev,\n\t\t\t\t      COMMAND_ID_CONFIG_TABLE, &req, ACPI_TYPE_PACKAGE);\n\tif (!out)\n\t\treturn;\n\tif (out->package.count >= 3 &&\n\t    out->package.elements[0].type == ACPI_TYPE_INTEGER &&\n\t    out->package.elements[1].type == ACPI_TYPE_INTEGER &&\n\t    out->package.elements[2].type == ACPI_TYPE_PACKAGE &&\n\t    out->package.elements[2].package.count > 0) {\n\t\tcontext->config_data[reg].version = out->package.elements[0].integer.value;\n\t\tcontext->config_data[reg].total_dev_mode =\n\t\t\tout->package.elements[1].integer.value;\n\t\tif (context->config_data[reg].total_dev_mode <= 0 ||\n\t\t    context->config_data[reg].total_dev_mode > MAX_DEV_MODES) {\n\t\t\tACPI_FREE(out);\n\t\t\treturn;\n\t\t}\n\t\tparse_package(context, &out->package.elements[2]);\n\t}\n\tACPI_FREE(out);\n}\n\nstatic int sar_probe(struct platform_device *device)\n{\n\tstruct wwan_sar_context *context;\n\tint reg;\n\tint result;\n\n\tcontext = kzalloc(sizeof(*context), GFP_KERNEL);\n\tif (!context)\n\t\treturn -ENOMEM;\n\n\tcontext->sar_device = device;\n\tcontext->handle = ACPI_HANDLE(&device->dev);\n\tdev_set_drvdata(&device->dev, context);\n\n\tresult = guid_parse(SAR_DSM_UUID, &context->guid);\n\tif (result) {\n\t\tdev_err(&device->dev, \"SAR UUID parse error: %d\\n\", result);\n\t\tgoto r_free;\n\t}\n\n\tfor (reg = 0; reg < MAX_REGULATORY; reg++)\n\t\tsar_get_data(reg, context);\n\n\tif (sar_get_device_mode(device) != AE_OK) {\n\t\tdev_err(&device->dev, \"Failed to get device mode\\n\");\n\t\tresult = -EIO;\n\t\tgoto r_free;\n\t}\n\n\tresult = sysfs_create_group(&device->dev.kobj, &intcsar_group);\n\tif (result) {\n\t\tdev_err(&device->dev, \"sysfs creation failed\\n\");\n\t\tgoto r_free;\n\t}\n\n\tif (acpi_install_notify_handler(ACPI_HANDLE(&device->dev), ACPI_DEVICE_NOTIFY,\n\t\t\t\t\tsar_notify, (void *)device) != AE_OK) {\n\t\tdev_err(&device->dev, \"Failed acpi_install_notify_handler\\n\");\n\t\tresult = -EIO;\n\t\tgoto r_sys;\n\t}\n\treturn 0;\n\nr_sys:\n\tsysfs_remove_group(&device->dev.kobj, &intcsar_group);\nr_free:\n\tkfree(context);\n\treturn result;\n}\n\nstatic void sar_remove(struct platform_device *device)\n{\n\tstruct wwan_sar_context *context = dev_get_drvdata(&device->dev);\n\tint reg;\n\n\tacpi_remove_notify_handler(ACPI_HANDLE(&device->dev),\n\t\t\t\t   ACPI_DEVICE_NOTIFY, sar_notify);\n\tsysfs_remove_group(&device->dev.kobj, &intcsar_group);\n\tfor (reg = 0; reg < MAX_REGULATORY; reg++)\n\t\tkfree(context->config_data[reg].device_mode_info);\n\n\tkfree(context);\n}\n\nstatic struct platform_driver sar_driver = {\n\t.probe = sar_probe,\n\t.remove_new = sar_remove,\n\t.driver = {\n\t\t.name = DRVNAME,\n\t\t.acpi_match_table = ACPI_PTR(sar_device_ids)\n\t}\n};\nmodule_platform_driver(sar_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"Platform device driver for INTEL MODEM BIOS SAR\");\nMODULE_AUTHOR(\"Shravan Sudhakar <s.shravan@intel.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}