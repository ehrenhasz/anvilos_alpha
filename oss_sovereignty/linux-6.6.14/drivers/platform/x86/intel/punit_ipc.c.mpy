{
  "module_name": "punit_ipc.c",
  "hash_id": "5c83c32dbc6ff56f5f7c11ef94e3866f22b3e8aa0288f531d7bff8038383bf6f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/x86/intel/punit_ipc.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n\n#include <asm/intel_punit_ipc.h>\n\n \n#define OFFSET_DATA_LOW\t\t0x0\n#define OFFSET_DATA_HIGH\t0x4\n \n#define\tCMD_RUN\t\t\tBIT(31)\n#define\tCMD_ERRCODE_MASK\tGENMASK(7, 0)\n#define\tCMD_PARA1_SHIFT\t\t8\n#define\tCMD_PARA2_SHIFT\t\t16\n\n#define CMD_TIMEOUT_SECONDS\t1\n\nenum {\n\tBASE_DATA = 0,\n\tBASE_IFACE,\n\tBASE_MAX,\n};\n\ntypedef struct {\n\tstruct device *dev;\n\tstruct mutex lock;\n\tint irq;\n\tstruct completion cmd_complete;\n\t \n\tvoid __iomem *base[RESERVED_IPC][BASE_MAX];\n\tIPC_TYPE type;\n} IPC_DEV;\n\nstatic IPC_DEV *punit_ipcdev;\n\nstatic inline u32 ipc_read_status(IPC_DEV *ipcdev, IPC_TYPE type)\n{\n\treturn readl(ipcdev->base[type][BASE_IFACE]);\n}\n\nstatic inline void ipc_write_cmd(IPC_DEV *ipcdev, IPC_TYPE type, u32 cmd)\n{\n\twritel(cmd, ipcdev->base[type][BASE_IFACE]);\n}\n\nstatic inline u32 ipc_read_data_low(IPC_DEV *ipcdev, IPC_TYPE type)\n{\n\treturn readl(ipcdev->base[type][BASE_DATA] + OFFSET_DATA_LOW);\n}\n\nstatic inline u32 ipc_read_data_high(IPC_DEV *ipcdev, IPC_TYPE type)\n{\n\treturn readl(ipcdev->base[type][BASE_DATA] + OFFSET_DATA_HIGH);\n}\n\nstatic inline void ipc_write_data_low(IPC_DEV *ipcdev, IPC_TYPE type, u32 data)\n{\n\twritel(data, ipcdev->base[type][BASE_DATA] + OFFSET_DATA_LOW);\n}\n\nstatic inline void ipc_write_data_high(IPC_DEV *ipcdev, IPC_TYPE type, u32 data)\n{\n\twritel(data, ipcdev->base[type][BASE_DATA] + OFFSET_DATA_HIGH);\n}\n\nstatic const char *ipc_err_string(int error)\n{\n\tif (error == IPC_PUNIT_ERR_SUCCESS)\n\t\treturn \"no error\";\n\telse if (error == IPC_PUNIT_ERR_INVALID_CMD)\n\t\treturn \"invalid command\";\n\telse if (error == IPC_PUNIT_ERR_INVALID_PARAMETER)\n\t\treturn \"invalid parameter\";\n\telse if (error == IPC_PUNIT_ERR_CMD_TIMEOUT)\n\t\treturn \"command timeout\";\n\telse if (error == IPC_PUNIT_ERR_CMD_LOCKED)\n\t\treturn \"command locked\";\n\telse if (error == IPC_PUNIT_ERR_INVALID_VR_ID)\n\t\treturn \"invalid vr id\";\n\telse if (error == IPC_PUNIT_ERR_VR_ERR)\n\t\treturn \"vr error\";\n\telse\n\t\treturn \"unknown error\";\n}\n\nstatic int intel_punit_ipc_check_status(IPC_DEV *ipcdev, IPC_TYPE type)\n{\n\tint loops = CMD_TIMEOUT_SECONDS * USEC_PER_SEC;\n\tint errcode;\n\tint status;\n\n\tif (ipcdev->irq) {\n\t\tif (!wait_for_completion_timeout(&ipcdev->cmd_complete,\n\t\t\t\t\t\t CMD_TIMEOUT_SECONDS * HZ)) {\n\t\t\tdev_err(ipcdev->dev, \"IPC timed out\\n\");\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t} else {\n\t\twhile ((ipc_read_status(ipcdev, type) & CMD_RUN) && --loops)\n\t\t\tudelay(1);\n\t\tif (!loops) {\n\t\t\tdev_err(ipcdev->dev, \"IPC timed out\\n\");\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t}\n\n\tstatus = ipc_read_status(ipcdev, type);\n\terrcode = status & CMD_ERRCODE_MASK;\n\tif (errcode) {\n\t\tdev_err(ipcdev->dev, \"IPC failed: %s, IPC_STS=0x%x\\n\",\n\t\t\tipc_err_string(errcode), status);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\n \nint intel_punit_ipc_simple_command(int cmd, int para1, int para2)\n{\n\tIPC_DEV *ipcdev = punit_ipcdev;\n\tIPC_TYPE type;\n\tu32 val;\n\tint ret;\n\n\tmutex_lock(&ipcdev->lock);\n\n\treinit_completion(&ipcdev->cmd_complete);\n\ttype = (cmd & IPC_PUNIT_CMD_TYPE_MASK) >> IPC_TYPE_OFFSET;\n\n\tval = cmd & ~IPC_PUNIT_CMD_TYPE_MASK;\n\tval |= CMD_RUN | para2 << CMD_PARA2_SHIFT | para1 << CMD_PARA1_SHIFT;\n\tipc_write_cmd(ipcdev, type, val);\n\tret = intel_punit_ipc_check_status(ipcdev, type);\n\n\tmutex_unlock(&ipcdev->lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(intel_punit_ipc_simple_command);\n\n \nint intel_punit_ipc_command(u32 cmd, u32 para1, u32 para2, u32 *in, u32 *out)\n{\n\tIPC_DEV *ipcdev = punit_ipcdev;\n\tIPC_TYPE type;\n\tu32 val;\n\tint ret;\n\n\tmutex_lock(&ipcdev->lock);\n\n\treinit_completion(&ipcdev->cmd_complete);\n\ttype = (cmd & IPC_PUNIT_CMD_TYPE_MASK) >> IPC_TYPE_OFFSET;\n\n\tif (in) {\n\t\tipc_write_data_low(ipcdev, type, *in);\n\t\tif (type == GTDRIVER_IPC || type == ISPDRIVER_IPC)\n\t\t\tipc_write_data_high(ipcdev, type, *++in);\n\t}\n\n\tval = cmd & ~IPC_PUNIT_CMD_TYPE_MASK;\n\tval |= CMD_RUN | para2 << CMD_PARA2_SHIFT | para1 << CMD_PARA1_SHIFT;\n\tipc_write_cmd(ipcdev, type, val);\n\n\tret = intel_punit_ipc_check_status(ipcdev, type);\n\tif (ret)\n\t\tgoto out;\n\n\tif (out) {\n\t\t*out = ipc_read_data_low(ipcdev, type);\n\t\tif (type == GTDRIVER_IPC || type == ISPDRIVER_IPC)\n\t\t\t*++out = ipc_read_data_high(ipcdev, type);\n\t}\n\nout:\n\tmutex_unlock(&ipcdev->lock);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(intel_punit_ipc_command);\n\nstatic irqreturn_t intel_punit_ioc(int irq, void *dev_id)\n{\n\tIPC_DEV *ipcdev = dev_id;\n\n\tcomplete(&ipcdev->cmd_complete);\n\treturn IRQ_HANDLED;\n}\n\nstatic int intel_punit_get_bars(struct platform_device *pdev)\n{\n\tvoid __iomem *addr;\n\n\t \n\taddr = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(addr))\n\t\treturn PTR_ERR(addr);\n\tpunit_ipcdev->base[BIOS_IPC][BASE_DATA] = addr;\n\n\taddr = devm_platform_ioremap_resource(pdev, 1);\n\tif (IS_ERR(addr))\n\t\treturn PTR_ERR(addr);\n\tpunit_ipcdev->base[BIOS_IPC][BASE_IFACE] = addr;\n\n\t \n\taddr = devm_platform_ioremap_resource(pdev, 2);\n\tif (!IS_ERR(addr))\n\t\tpunit_ipcdev->base[ISPDRIVER_IPC][BASE_DATA] = addr;\n\n\taddr = devm_platform_ioremap_resource(pdev, 3);\n\tif (!IS_ERR(addr))\n\t\tpunit_ipcdev->base[ISPDRIVER_IPC][BASE_IFACE] = addr;\n\n\taddr = devm_platform_ioremap_resource(pdev, 4);\n\tif (!IS_ERR(addr))\n\t\tpunit_ipcdev->base[GTDRIVER_IPC][BASE_DATA] = addr;\n\n\taddr = devm_platform_ioremap_resource(pdev, 5);\n\tif (!IS_ERR(addr))\n\t\tpunit_ipcdev->base[GTDRIVER_IPC][BASE_IFACE] = addr;\n\n\treturn 0;\n}\n\nstatic int intel_punit_ipc_probe(struct platform_device *pdev)\n{\n\tint irq, ret;\n\n\tpunit_ipcdev = devm_kzalloc(&pdev->dev,\n\t\t\t\t    sizeof(*punit_ipcdev), GFP_KERNEL);\n\tif (!punit_ipcdev)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, punit_ipcdev);\n\n\tirq = platform_get_irq_optional(pdev, 0);\n\tif (irq < 0) {\n\t\tdev_warn(&pdev->dev, \"Invalid IRQ, using polling mode\\n\");\n\t} else {\n\t\tret = devm_request_irq(&pdev->dev, irq, intel_punit_ioc,\n\t\t\t\t       IRQF_NO_SUSPEND, \"intel_punit_ipc\",\n\t\t\t\t       &punit_ipcdev);\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev, \"Failed to request irq: %d\\n\", irq);\n\t\t\treturn ret;\n\t\t}\n\t\tpunit_ipcdev->irq = irq;\n\t}\n\n\tret = intel_punit_get_bars(pdev);\n\tif (ret)\n\t\treturn ret;\n\n\tpunit_ipcdev->dev = &pdev->dev;\n\tmutex_init(&punit_ipcdev->lock);\n\tinit_completion(&punit_ipcdev->cmd_complete);\n\n\treturn 0;\n}\n\nstatic const struct acpi_device_id punit_ipc_acpi_ids[] = {\n\t{ \"INT34D4\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(acpi, punit_ipc_acpi_ids);\n\nstatic struct platform_driver intel_punit_ipc_driver = {\n\t.probe = intel_punit_ipc_probe,\n\t.driver = {\n\t\t.name = \"intel_punit_ipc\",\n\t\t.acpi_match_table = punit_ipc_acpi_ids,\n\t},\n};\n\nstatic int __init intel_punit_ipc_init(void)\n{\n\treturn platform_driver_register(&intel_punit_ipc_driver);\n}\n\nstatic void __exit intel_punit_ipc_exit(void)\n{\n\tplatform_driver_unregister(&intel_punit_ipc_driver);\n}\n\nMODULE_AUTHOR(\"Zha Qipeng <qipeng.zha@intel.com>\");\nMODULE_DESCRIPTION(\"Intel P-Unit IPC driver\");\nMODULE_LICENSE(\"GPL v2\");\n\n \nfs_initcall(intel_punit_ipc_init);\nmodule_exit(intel_punit_ipc_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}