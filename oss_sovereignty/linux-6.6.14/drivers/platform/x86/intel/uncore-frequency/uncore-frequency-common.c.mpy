{
  "module_name": "uncore-frequency-common.c",
  "hash_id": "a8848a032260f1872c7af74090afcbb7f9933b2b67330d11af4df95b2b4bd368",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/x86/intel/uncore-frequency/uncore-frequency-common.c",
  "human_readable_source": "\n \n#include <linux/cpu.h>\n#include <linux/module.h>\n#include \"uncore-frequency-common.h\"\n\n \nstatic DEFINE_MUTEX(uncore_lock);\n \nstatic struct kobject *uncore_root_kobj;\n \nstatic int uncore_instance_count;\n\nstatic DEFINE_IDA(intel_uncore_ida);\n\n \nstatic int (*uncore_read)(struct uncore_data *data, unsigned int *min, unsigned int *max);\nstatic int (*uncore_write)(struct uncore_data *data, unsigned int input, unsigned int min_max);\nstatic int (*uncore_read_freq)(struct uncore_data *data, unsigned int *freq);\n\nstatic ssize_t show_domain_id(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct uncore_data *data = container_of(attr, struct uncore_data, domain_id_dev_attr);\n\n\treturn sprintf(buf, \"%u\\n\", data->domain_id);\n}\n\nstatic ssize_t show_fabric_cluster_id(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct uncore_data *data = container_of(attr, struct uncore_data, fabric_cluster_id_dev_attr);\n\n\treturn sprintf(buf, \"%u\\n\", data->cluster_id);\n}\n\nstatic ssize_t show_package_id(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct uncore_data *data = container_of(attr, struct uncore_data, package_id_dev_attr);\n\n\treturn sprintf(buf, \"%u\\n\", data->package_id);\n}\n\nstatic ssize_t show_min_max_freq_khz(struct uncore_data *data,\n\t\t\t\t      char *buf, int min_max)\n{\n\tunsigned int min, max;\n\tint ret;\n\n\tmutex_lock(&uncore_lock);\n\tret = uncore_read(data, &min, &max);\n\tmutex_unlock(&uncore_lock);\n\tif (ret)\n\t\treturn ret;\n\n\tif (min_max)\n\t\treturn sprintf(buf, \"%u\\n\", max);\n\n\treturn sprintf(buf, \"%u\\n\", min);\n}\n\nstatic ssize_t store_min_max_freq_khz(struct uncore_data *data,\n\t\t\t\t      const char *buf, ssize_t count,\n\t\t\t\t      int min_max)\n{\n\tunsigned int input;\n\tint ret;\n\n\tif (kstrtouint(buf, 10, &input))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&uncore_lock);\n\tret = uncore_write(data, input, min_max);\n\tmutex_unlock(&uncore_lock);\n\n\tif (ret)\n\t\treturn ret;\n\n\treturn count;\n}\n\nstatic ssize_t show_perf_status_freq_khz(struct uncore_data *data, char *buf)\n{\n\tunsigned int freq;\n\tint ret;\n\n\tmutex_lock(&uncore_lock);\n\tret = uncore_read_freq(data, &freq);\n\tmutex_unlock(&uncore_lock);\n\tif (ret)\n\t\treturn ret;\n\n\treturn sprintf(buf, \"%u\\n\", freq);\n}\n\n#define store_uncore_min_max(name, min_max)\t\t\t\t\\\n\tstatic ssize_t store_##name(struct device *dev,\t\t\\\n\t\t\t\t     struct device_attribute *attr,\t\\\n\t\t\t\t     const char *buf, size_t count)\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\tstruct uncore_data *data = container_of(attr, struct uncore_data, name##_dev_attr);\\\n\t\t\t\t\t\t\t\t\t\\\n\t\treturn store_min_max_freq_khz(data, buf, count,\t\\\n\t\t\t\t\t      min_max);\t\t\\\n\t}\n\n#define show_uncore_min_max(name, min_max)\t\t\t\t\\\n\tstatic ssize_t show_##name(struct device *dev,\t\t\\\n\t\t\t\t    struct device_attribute *attr, char *buf)\\\n\t{                                                               \\\n\t\tstruct uncore_data *data = container_of(attr, struct uncore_data, name##_dev_attr);\\\n\t\t\t\t\t\t\t\t\t\\\n\t\treturn show_min_max_freq_khz(data, buf, min_max);\t\\\n\t}\n\n#define show_uncore_perf_status(name)\t\t\t\t\t\\\n\tstatic ssize_t show_##name(struct device *dev,\t\t\\\n\t\t\t\t   struct device_attribute *attr, char *buf)\\\n\t{                                                               \\\n\t\tstruct uncore_data *data = container_of(attr, struct uncore_data, name##_dev_attr);\\\n\t\t\t\t\t\t\t\t\t\\\n\t\treturn show_perf_status_freq_khz(data, buf); \\\n\t}\n\nstore_uncore_min_max(min_freq_khz, 0);\nstore_uncore_min_max(max_freq_khz, 1);\n\nshow_uncore_min_max(min_freq_khz, 0);\nshow_uncore_min_max(max_freq_khz, 1);\n\nshow_uncore_perf_status(current_freq_khz);\n\n#define show_uncore_data(member_name)\t\t\t\t\t\\\n\tstatic ssize_t show_##member_name(struct device *dev,\t\\\n\t\t\t\t\t   struct device_attribute *attr, char *buf)\\\n\t{                                                               \\\n\t\tstruct uncore_data *data = container_of(attr, struct uncore_data,\\\n\t\t\t\t\t\t\t  member_name##_dev_attr);\\\n\t\t\t\t\t\t\t\t\t\\\n\t\treturn sysfs_emit(buf, \"%u\\n\",\t\t\t\t\\\n\t\t\t\t data->member_name);\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\nshow_uncore_data(initial_min_freq_khz);\nshow_uncore_data(initial_max_freq_khz);\n\n#define init_attribute_rw(_name)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tsysfs_attr_init(&data->_name##_dev_attr.attr);\t\\\n\t\tdata->_name##_dev_attr.show = show_##_name;\t\t\\\n\t\tdata->_name##_dev_attr.store = store_##_name;\t\t\\\n\t\tdata->_name##_dev_attr.attr.name = #_name;\t\t\\\n\t\tdata->_name##_dev_attr.attr.mode = 0644;\t\t\\\n\t} while (0)\n\n#define init_attribute_ro(_name)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tsysfs_attr_init(&data->_name##_dev_attr.attr);\t\\\n\t\tdata->_name##_dev_attr.show = show_##_name;\t\t\\\n\t\tdata->_name##_dev_attr.store = NULL;\t\t\t\\\n\t\tdata->_name##_dev_attr.attr.name = #_name;\t\t\\\n\t\tdata->_name##_dev_attr.attr.mode = 0444;\t\t\\\n\t} while (0)\n\n#define init_attribute_root_ro(_name)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tsysfs_attr_init(&data->_name##_dev_attr.attr);\t\\\n\t\tdata->_name##_dev_attr.show = show_##_name;\t\t\\\n\t\tdata->_name##_dev_attr.store = NULL;\t\t\t\\\n\t\tdata->_name##_dev_attr.attr.name = #_name;\t\t\\\n\t\tdata->_name##_dev_attr.attr.mode = 0400;\t\t\\\n\t} while (0)\n\nstatic int create_attr_group(struct uncore_data *data, char *name)\n{\n\tint ret, freq, index = 0;\n\n\tinit_attribute_rw(max_freq_khz);\n\tinit_attribute_rw(min_freq_khz);\n\tinit_attribute_ro(initial_min_freq_khz);\n\tinit_attribute_ro(initial_max_freq_khz);\n\tinit_attribute_root_ro(current_freq_khz);\n\n\tif (data->domain_id != UNCORE_DOMAIN_ID_INVALID) {\n\t\tinit_attribute_root_ro(domain_id);\n\t\tdata->uncore_attrs[index++] = &data->domain_id_dev_attr.attr;\n\t\tinit_attribute_root_ro(fabric_cluster_id);\n\t\tdata->uncore_attrs[index++] = &data->fabric_cluster_id_dev_attr.attr;\n\t\tinit_attribute_root_ro(package_id);\n\t\tdata->uncore_attrs[index++] = &data->package_id_dev_attr.attr;\n\t}\n\n\tdata->uncore_attrs[index++] = &data->max_freq_khz_dev_attr.attr;\n\tdata->uncore_attrs[index++] = &data->min_freq_khz_dev_attr.attr;\n\tdata->uncore_attrs[index++] = &data->initial_min_freq_khz_dev_attr.attr;\n\tdata->uncore_attrs[index++] = &data->initial_max_freq_khz_dev_attr.attr;\n\n\tret = uncore_read_freq(data, &freq);\n\tif (!ret)\n\t\tdata->uncore_attrs[index++] = &data->current_freq_khz_dev_attr.attr;\n\n\tdata->uncore_attrs[index] = NULL;\n\n\tdata->uncore_attr_group.name = name;\n\tdata->uncore_attr_group.attrs = data->uncore_attrs;\n\tret = sysfs_create_group(uncore_root_kobj, &data->uncore_attr_group);\n\n\treturn ret;\n}\n\nstatic void delete_attr_group(struct uncore_data *data, char *name)\n{\n\tsysfs_remove_group(uncore_root_kobj, &data->uncore_attr_group);\n}\n\nint uncore_freq_add_entry(struct uncore_data *data, int cpu)\n{\n\tint ret = 0;\n\n\tmutex_lock(&uncore_lock);\n\tif (data->valid) {\n\t\t \n\t\tdata->control_cpu = cpu;\n\t\tgoto uncore_unlock;\n\t}\n\n\tif (data->domain_id != UNCORE_DOMAIN_ID_INVALID) {\n\t\tret = ida_alloc(&intel_uncore_ida, GFP_KERNEL);\n\t\tif (ret < 0)\n\t\t\tgoto uncore_unlock;\n\n\t\tdata->instance_id = ret;\n\t\tsprintf(data->name, \"uncore%02d\", ret);\n\t} else {\n\t\tsprintf(data->name, \"package_%02d_die_%02d\", data->package_id, data->die_id);\n\t}\n\n\tuncore_read(data, &data->initial_min_freq_khz, &data->initial_max_freq_khz);\n\n\tret = create_attr_group(data, data->name);\n\tif (ret) {\n\t\tif (data->domain_id != UNCORE_DOMAIN_ID_INVALID)\n\t\t\tida_free(&intel_uncore_ida, data->instance_id);\n\t} else {\n\t\tdata->control_cpu = cpu;\n\t\tdata->valid = true;\n\t}\n\nuncore_unlock:\n\tmutex_unlock(&uncore_lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_NS_GPL(uncore_freq_add_entry, INTEL_UNCORE_FREQUENCY);\n\nvoid uncore_freq_remove_die_entry(struct uncore_data *data)\n{\n\tmutex_lock(&uncore_lock);\n\tdelete_attr_group(data, data->name);\n\tdata->control_cpu = -1;\n\tdata->valid = false;\n\tif (data->domain_id != UNCORE_DOMAIN_ID_INVALID)\n\t\tida_free(&intel_uncore_ida, data->instance_id);\n\n\tmutex_unlock(&uncore_lock);\n}\nEXPORT_SYMBOL_NS_GPL(uncore_freq_remove_die_entry, INTEL_UNCORE_FREQUENCY);\n\nint uncore_freq_common_init(int (*read_control_freq)(struct uncore_data *data, unsigned int *min, unsigned int *max),\n\t\t\t     int (*write_control_freq)(struct uncore_data *data, unsigned int input, unsigned int set_max),\n\t\t\t     int (*read_freq)(struct uncore_data *data, unsigned int *freq))\n{\n\tmutex_lock(&uncore_lock);\n\n\tuncore_read = read_control_freq;\n\tuncore_write = write_control_freq;\n\tuncore_read_freq = read_freq;\n\n\tif (!uncore_root_kobj) {\n\t\tstruct device *dev_root = bus_get_dev_root(&cpu_subsys);\n\n\t\tif (dev_root) {\n\t\t\tuncore_root_kobj = kobject_create_and_add(\"intel_uncore_frequency\",\n\t\t\t\t\t\t\t\t  &dev_root->kobj);\n\t\t\tput_device(dev_root);\n\t\t}\n\t}\n\tif (uncore_root_kobj)\n\t\t++uncore_instance_count;\n\tmutex_unlock(&uncore_lock);\n\n\treturn uncore_root_kobj ? 0 : -ENOMEM;\n}\nEXPORT_SYMBOL_NS_GPL(uncore_freq_common_init, INTEL_UNCORE_FREQUENCY);\n\nvoid uncore_freq_common_exit(void)\n{\n\tmutex_lock(&uncore_lock);\n\t--uncore_instance_count;\n\tif (!uncore_instance_count) {\n\t\tkobject_put(uncore_root_kobj);\n\t\tuncore_root_kobj = NULL;\n\t}\n\tmutex_unlock(&uncore_lock);\n}\nEXPORT_SYMBOL_NS_GPL(uncore_freq_common_exit, INTEL_UNCORE_FREQUENCY);\n\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"Intel Uncore Frequency Common Module\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}