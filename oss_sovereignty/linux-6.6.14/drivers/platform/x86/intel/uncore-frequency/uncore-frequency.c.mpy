{
  "module_name": "uncore-frequency.c",
  "hash_id": "549bd7cd433d052d527f28ba77d49dbe69955a065d9a9f108891db946eadc9eb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/x86/intel/uncore-frequency/uncore-frequency.c",
  "human_readable_source": "\n \n\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <asm/cpu_device_id.h>\n#include <asm/intel-family.h>\n\n#include \"uncore-frequency-common.h\"\n\n \nstatic int uncore_max_entries __read_mostly;\n \nstatic struct uncore_data *uncore_instances;\n \nstatic cpumask_t uncore_cpu_mask;\n \nstatic enum cpuhp_state uncore_hp_state __read_mostly;\n\n#define MSR_UNCORE_RATIO_LIMIT\t0x620\n#define MSR_UNCORE_PERF_STATUS\t0x621\n#define UNCORE_FREQ_KHZ_MULTIPLIER\t100000\n\nstatic int uncore_read_control_freq(struct uncore_data *data, unsigned int *min,\n\t\t\t\t    unsigned int *max)\n{\n\tu64 cap;\n\tint ret;\n\n\tif (data->control_cpu < 0)\n\t\treturn -ENXIO;\n\n\tret = rdmsrl_on_cpu(data->control_cpu, MSR_UNCORE_RATIO_LIMIT, &cap);\n\tif (ret)\n\t\treturn ret;\n\n\t*max = (cap & 0x7F) * UNCORE_FREQ_KHZ_MULTIPLIER;\n\t*min = ((cap & GENMASK(14, 8)) >> 8) * UNCORE_FREQ_KHZ_MULTIPLIER;\n\n\treturn 0;\n}\n\nstatic int uncore_write_control_freq(struct uncore_data *data, unsigned int input,\n\t\t\t\t     unsigned int min_max)\n{\n\tint ret;\n\tu64 cap;\n\n\tinput /= UNCORE_FREQ_KHZ_MULTIPLIER;\n\tif (!input || input > 0x7F)\n\t\treturn -EINVAL;\n\n\tif (data->control_cpu < 0)\n\t\treturn -ENXIO;\n\n\tret = rdmsrl_on_cpu(data->control_cpu, MSR_UNCORE_RATIO_LIMIT, &cap);\n\tif (ret)\n\t\treturn ret;\n\n\tif (min_max) {\n\t\tcap &= ~0x7F;\n\t\tcap |= input;\n\t} else  {\n\t\tcap &= ~GENMASK(14, 8);\n\t\tcap |= (input << 8);\n\t}\n\n\tret = wrmsrl_on_cpu(data->control_cpu, MSR_UNCORE_RATIO_LIMIT, cap);\n\tif (ret)\n\t\treturn ret;\n\n\tdata->stored_uncore_data = cap;\n\n\treturn 0;\n}\n\nstatic int uncore_read_freq(struct uncore_data *data, unsigned int *freq)\n{\n\tu64 ratio;\n\tint ret;\n\n\tif (data->control_cpu < 0)\n\t\treturn -ENXIO;\n\n\tret = rdmsrl_on_cpu(data->control_cpu, MSR_UNCORE_PERF_STATUS, &ratio);\n\tif (ret)\n\t\treturn ret;\n\n\t*freq = (ratio & 0x7F) * UNCORE_FREQ_KHZ_MULTIPLIER;\n\n\treturn 0;\n}\n\n \nstatic struct uncore_data *uncore_get_instance(unsigned int cpu)\n{\n\tint id = topology_logical_die_id(cpu);\n\n\tif (id >= 0 && id < uncore_max_entries)\n\t\treturn &uncore_instances[id];\n\n\treturn NULL;\n}\n\nstatic int uncore_event_cpu_online(unsigned int cpu)\n{\n\tstruct uncore_data *data;\n\tint target;\n\n\t \n\ttarget = cpumask_any_and(&uncore_cpu_mask, topology_die_cpumask(cpu));\n\tif (target < nr_cpu_ids)\n\t\treturn 0;\n\n\t \n\tcpumask_set_cpu(cpu, &uncore_cpu_mask);\n\n\tdata = uncore_get_instance(cpu);\n\tif (!data)\n\t\treturn 0;\n\n\tdata->package_id = topology_physical_package_id(cpu);\n\tdata->die_id = topology_die_id(cpu);\n\tdata->domain_id = UNCORE_DOMAIN_ID_INVALID;\n\n\treturn uncore_freq_add_entry(data, cpu);\n}\n\nstatic int uncore_event_cpu_offline(unsigned int cpu)\n{\n\tstruct uncore_data *data;\n\tint target;\n\n\tdata = uncore_get_instance(cpu);\n\tif (!data)\n\t\treturn 0;\n\n\t \n\tif (!cpumask_test_and_clear_cpu(cpu, &uncore_cpu_mask))\n\t\treturn 0;\n\n\t \n\ttarget = cpumask_any_but(topology_die_cpumask(cpu), cpu);\n\n\tif (target < nr_cpu_ids) {\n\t\tcpumask_set_cpu(target, &uncore_cpu_mask);\n\t\tuncore_freq_add_entry(data, target);\n\t} else {\n\t\tuncore_freq_remove_die_entry(data);\n\t}\n\n\treturn 0;\n}\n\nstatic int uncore_pm_notify(struct notifier_block *nb, unsigned long mode,\n\t\t\t    void *_unused)\n{\n\tint i;\n\n\tswitch (mode) {\n\tcase PM_POST_HIBERNATION:\n\tcase PM_POST_RESTORE:\n\tcase PM_POST_SUSPEND:\n\t\tfor (i = 0; i < uncore_max_entries; ++i) {\n\t\t\tstruct uncore_data *data = &uncore_instances[i];\n\n\t\t\tif (!data || !data->valid || !data->stored_uncore_data)\n\t\t\t\treturn 0;\n\n\t\t\twrmsrl_on_cpu(data->control_cpu, MSR_UNCORE_RATIO_LIMIT,\n\t\t\t\t      data->stored_uncore_data);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic struct notifier_block uncore_pm_nb = {\n\t.notifier_call = uncore_pm_notify,\n};\n\nstatic const struct x86_cpu_id intel_uncore_cpu_ids[] = {\n\tX86_MATCH_INTEL_FAM6_MODEL(BROADWELL_G,\tNULL),\n\tX86_MATCH_INTEL_FAM6_MODEL(BROADWELL_X,\tNULL),\n\tX86_MATCH_INTEL_FAM6_MODEL(BROADWELL_D,\tNULL),\n\tX86_MATCH_INTEL_FAM6_MODEL(SKYLAKE_X,\tNULL),\n\tX86_MATCH_INTEL_FAM6_MODEL(ICELAKE_X,\tNULL),\n\tX86_MATCH_INTEL_FAM6_MODEL(ICELAKE_D,\tNULL),\n\tX86_MATCH_INTEL_FAM6_MODEL(SAPPHIRERAPIDS_X, NULL),\n\tX86_MATCH_INTEL_FAM6_MODEL(EMERALDRAPIDS_X, NULL),\n\tX86_MATCH_INTEL_FAM6_MODEL(ALDERLAKE, NULL),\n\tX86_MATCH_INTEL_FAM6_MODEL(ALDERLAKE_L, NULL),\n\tX86_MATCH_INTEL_FAM6_MODEL(RAPTORLAKE, NULL),\n\tX86_MATCH_INTEL_FAM6_MODEL(RAPTORLAKE_P, NULL),\n\tX86_MATCH_INTEL_FAM6_MODEL(RAPTORLAKE_S, NULL),\n\tX86_MATCH_INTEL_FAM6_MODEL(METEORLAKE, NULL),\n\tX86_MATCH_INTEL_FAM6_MODEL(METEORLAKE_L, NULL),\n\t{}\n};\nMODULE_DEVICE_TABLE(x86cpu, intel_uncore_cpu_ids);\n\nstatic int __init intel_uncore_init(void)\n{\n\tconst struct x86_cpu_id *id;\n\tint ret;\n\n\tif (cpu_feature_enabled(X86_FEATURE_HYPERVISOR))\n\t\treturn -ENODEV;\n\n\tid = x86_match_cpu(intel_uncore_cpu_ids);\n\tif (!id)\n\t\treturn -ENODEV;\n\n\tuncore_max_entries = topology_max_packages() *\n\t\t\t\t\ttopology_max_die_per_package();\n\tuncore_instances = kcalloc(uncore_max_entries,\n\t\t\t\t   sizeof(*uncore_instances), GFP_KERNEL);\n\tif (!uncore_instances)\n\t\treturn -ENOMEM;\n\n\tret = uncore_freq_common_init(uncore_read_control_freq, uncore_write_control_freq,\n\t\t\t\t      uncore_read_freq);\n\tif (ret)\n\t\tgoto err_free;\n\n\tret = cpuhp_setup_state(CPUHP_AP_ONLINE_DYN,\n\t\t\t\t\"platform/x86/uncore-freq:online\",\n\t\t\t\tuncore_event_cpu_online,\n\t\t\t\tuncore_event_cpu_offline);\n\tif (ret < 0)\n\t\tgoto err_rem_kobj;\n\n\tuncore_hp_state = ret;\n\n\tret = register_pm_notifier(&uncore_pm_nb);\n\tif (ret)\n\t\tgoto err_rem_state;\n\n\treturn 0;\n\nerr_rem_state:\n\tcpuhp_remove_state(uncore_hp_state);\nerr_rem_kobj:\n\tuncore_freq_common_exit();\nerr_free:\n\tkfree(uncore_instances);\n\n\treturn ret;\n}\nmodule_init(intel_uncore_init)\n\nstatic void __exit intel_uncore_exit(void)\n{\n\tint i;\n\n\tunregister_pm_notifier(&uncore_pm_nb);\n\tcpuhp_remove_state(uncore_hp_state);\n\tfor (i = 0; i < uncore_max_entries; ++i)\n\t\tuncore_freq_remove_die_entry(&uncore_instances[i]);\n\tuncore_freq_common_exit();\n\tkfree(uncore_instances);\n}\nmodule_exit(intel_uncore_exit)\n\nMODULE_IMPORT_NS(INTEL_UNCORE_FREQUENCY);\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"Intel Uncore Frequency Limits Driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}