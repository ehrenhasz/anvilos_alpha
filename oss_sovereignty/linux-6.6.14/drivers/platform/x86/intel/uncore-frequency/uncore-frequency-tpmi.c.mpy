{
  "module_name": "uncore-frequency-tpmi.c",
  "hash_id": "01e81816e2fa843c3365aab3250499d52d4ae361bcf1adf9edf1cfe93106856a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/x86/intel/uncore-frequency/uncore-frequency-tpmi.c",
  "human_readable_source": "\n \n\n#include <linux/auxiliary_bus.h>\n#include <linux/bitfield.h>\n#include <linux/bits.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/intel_tpmi.h>\n\n#include \"uncore-frequency-common.h\"\n\n#define\tUNCORE_HEADER_VERSION\t\t1\n#define UNCORE_HEADER_INDEX\t\t0\n#define UNCORE_FABRIC_CLUSTER_OFFSET\t8\n\n \n#define UNCORE_FABRIC_CLUSTER_SIZE\t(4 * 8)\n\n#define UNCORE_STATUS_INDEX\t\t0\n#define UNCORE_CONTROL_INDEX\t\t8\n\n#define UNCORE_FREQ_KHZ_MULTIPLIER\t100000\n\nstruct tpmi_uncore_struct;\n\n \nstruct tpmi_uncore_cluster_info {\n\tbool root_domain;\n\tu8 __iomem *cluster_base;\n\tstruct uncore_data uncore_data;\n\tstruct tpmi_uncore_struct *uncore_root;\n};\n\n \nstruct tpmi_uncore_power_domain_info {\n\tu8 __iomem *uncore_base;\n\tint ufs_header_ver;\n\tint cluster_count;\n\tstruct tpmi_uncore_cluster_info *cluster_infos;\n};\n\n \nstruct tpmi_uncore_struct {\n\tint power_domain_count;\n\tint max_ratio;\n\tint min_ratio;\n\tstruct tpmi_uncore_power_domain_info *pd_info;\n\tstruct tpmi_uncore_cluster_info root_cluster;\n};\n\n#define UNCORE_GENMASK_MIN_RATIO\tGENMASK_ULL(21, 15)\n#define UNCORE_GENMASK_MAX_RATIO\tGENMASK_ULL(14, 8)\n#define UNCORE_GENMASK_CURRENT_RATIO\tGENMASK_ULL(6, 0)\n\n \nstatic void read_control_freq(struct tpmi_uncore_cluster_info *cluster_info,\n\t\t\t     unsigned int *min, unsigned int *max)\n{\n\tu64 control;\n\n\tcontrol = readq(cluster_info->cluster_base + UNCORE_CONTROL_INDEX);\n\t*max = FIELD_GET(UNCORE_GENMASK_MAX_RATIO, control) * UNCORE_FREQ_KHZ_MULTIPLIER;\n\t*min = FIELD_GET(UNCORE_GENMASK_MIN_RATIO, control) * UNCORE_FREQ_KHZ_MULTIPLIER;\n}\n\n#define UNCORE_MAX_RATIO\tFIELD_MAX(UNCORE_GENMASK_MAX_RATIO)\n\n \nstatic int uncore_read_control_freq(struct uncore_data *data, unsigned int *min,\n\t\t\t\t    unsigned int *max)\n{\n\tstruct tpmi_uncore_cluster_info *cluster_info;\n\n\tcluster_info = container_of(data, struct tpmi_uncore_cluster_info, uncore_data);\n\n\tif (cluster_info->root_domain) {\n\t\tstruct tpmi_uncore_struct *uncore_root = cluster_info->uncore_root;\n\t\tint i, _min = 0, _max = 0;\n\n\t\t*min = UNCORE_MAX_RATIO * UNCORE_FREQ_KHZ_MULTIPLIER;\n\t\t*max = 0;\n\n\t\t \n\t\tfor (i = 0; i < uncore_root->power_domain_count; ++i) {\n\t\t\tint j;\n\n\t\t\tfor (j = 0; j < uncore_root->pd_info[i].cluster_count; ++j) {\n\t\t\t\tread_control_freq(&uncore_root->pd_info[i].cluster_infos[j],\n\t\t\t\t\t\t  &_min, &_max);\n\t\t\t\tif (*min > _min)\n\t\t\t\t\t*min = _min;\n\t\t\t\tif (*max < _max)\n\t\t\t\t\t*max = _max;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tread_control_freq(cluster_info, min, max);\n\n\treturn 0;\n}\n\n \nstatic void write_control_freq(struct tpmi_uncore_cluster_info *cluster_info, unsigned int input,\n\t\t\t      unsigned int min_max)\n{\n\tu64 control;\n\n\tcontrol = readq(cluster_info->cluster_base + UNCORE_CONTROL_INDEX);\n\n\tif (min_max) {\n\t\tcontrol &= ~UNCORE_GENMASK_MAX_RATIO;\n\t\tcontrol |= FIELD_PREP(UNCORE_GENMASK_MAX_RATIO, input);\n\t} else {\n\t\tcontrol &= ~UNCORE_GENMASK_MIN_RATIO;\n\t\tcontrol |= FIELD_PREP(UNCORE_GENMASK_MIN_RATIO, input);\n\t}\n\n\twriteq(control, (cluster_info->cluster_base + UNCORE_CONTROL_INDEX));\n}\n\n \nstatic int uncore_write_control_freq(struct uncore_data *data, unsigned int input,\n\t\t\t\t     unsigned int min_max)\n{\n\tstruct tpmi_uncore_cluster_info *cluster_info;\n\tstruct tpmi_uncore_struct *uncore_root;\n\n\tinput /= UNCORE_FREQ_KHZ_MULTIPLIER;\n\tif (!input || input > UNCORE_MAX_RATIO)\n\t\treturn -EINVAL;\n\n\tcluster_info = container_of(data, struct tpmi_uncore_cluster_info, uncore_data);\n\tuncore_root = cluster_info->uncore_root;\n\n\t \n\tif (cluster_info->root_domain) {\n\t\tstruct tpmi_uncore_struct *uncore_root = cluster_info->uncore_root;\n\t\tint i;\n\n\t\tfor (i = 0; i < uncore_root->power_domain_count; ++i) {\n\t\t\tint j;\n\n\t\t\tfor (j = 0; j < uncore_root->pd_info[i].cluster_count; ++j)\n\t\t\t\twrite_control_freq(&uncore_root->pd_info[i].cluster_infos[j],\n\t\t\t\t\t\t  input, min_max);\n\t\t}\n\n\t\tif (min_max)\n\t\t\tuncore_root->max_ratio = input;\n\t\telse\n\t\t\tuncore_root->min_ratio = input;\n\n\t\treturn 0;\n\t}\n\n\tif (min_max && uncore_root->max_ratio && uncore_root->max_ratio < input)\n\t\treturn -EINVAL;\n\n\tif (!min_max && uncore_root->min_ratio && uncore_root->min_ratio > input)\n\t\treturn -EINVAL;\n\n\twrite_control_freq(cluster_info, input, min_max);\n\n\treturn 0;\n}\n\n \nstatic int uncore_read_freq(struct uncore_data *data, unsigned int *freq)\n{\n\tstruct tpmi_uncore_cluster_info *cluster_info;\n\tu64 status;\n\n\tcluster_info = container_of(data, struct tpmi_uncore_cluster_info, uncore_data);\n\tif (cluster_info->root_domain)\n\t\treturn -ENODATA;\n\n\tstatus = readq((u8 __iomem *)cluster_info->cluster_base + UNCORE_STATUS_INDEX);\n\t*freq = FIELD_GET(UNCORE_GENMASK_CURRENT_RATIO, status) * UNCORE_FREQ_KHZ_MULTIPLIER;\n\n\treturn 0;\n}\n\nstatic void remove_cluster_entries(struct tpmi_uncore_struct *tpmi_uncore)\n{\n\tint i;\n\n\tfor (i = 0; i < tpmi_uncore->power_domain_count; ++i) {\n\t\tstruct tpmi_uncore_power_domain_info *pd_info;\n\t\tint j;\n\n\t\tpd_info = &tpmi_uncore->pd_info[i];\n\t\tif (!pd_info->uncore_base)\n\t\t\tcontinue;\n\n\t\tfor (j = 0; j < pd_info->cluster_count; ++j) {\n\t\t\tstruct tpmi_uncore_cluster_info *cluster_info;\n\n\t\t\tcluster_info = &pd_info->cluster_infos[j];\n\t\t\tuncore_freq_remove_die_entry(&cluster_info->uncore_data);\n\t\t}\n\t}\n}\n\n#define UNCORE_VERSION_MASK\t\t\tGENMASK_ULL(7, 0)\n#define UNCORE_LOCAL_FABRIC_CLUSTER_ID_MASK\tGENMASK_ULL(15, 8)\n#define UNCORE_CLUSTER_OFF_MASK\t\t\tGENMASK_ULL(7, 0)\n#define UNCORE_MAX_CLUSTER_PER_DOMAIN\t\t8\n\nstatic int uncore_probe(struct auxiliary_device *auxdev, const struct auxiliary_device_id *id)\n{\n\tstruct intel_tpmi_plat_info *plat_info;\n\tstruct tpmi_uncore_struct *tpmi_uncore;\n\tint ret, i, pkg = 0;\n\tint num_resources;\n\n\t \n\tnum_resources = tpmi_get_resource_count(auxdev);\n\tif (!num_resources)\n\t\treturn -EINVAL;\n\n\t \n\tret = uncore_freq_common_init(uncore_read_control_freq, uncore_write_control_freq,\n\t\t\t\t      uncore_read_freq);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\ttpmi_uncore = devm_kzalloc(&auxdev->dev, sizeof(*tpmi_uncore), GFP_KERNEL);\n\tif (!tpmi_uncore) {\n\t\tret = -ENOMEM;\n\t\tgoto err_rem_common;\n\t}\n\n\t \n\ttpmi_uncore->pd_info = devm_kcalloc(&auxdev->dev, num_resources,\n\t\t\t\t\t    sizeof(*tpmi_uncore->pd_info),\n\t\t\t\t\t    GFP_KERNEL);\n\tif (!tpmi_uncore->pd_info) {\n\t\tret = -ENOMEM;\n\t\tgoto err_rem_common;\n\t}\n\n\ttpmi_uncore->power_domain_count = num_resources;\n\n\t \n\tplat_info = tpmi_get_platform_data(auxdev);\n\tif (plat_info)\n\t\tpkg = plat_info->package_id;\n\telse\n\t\tdev_info(&auxdev->dev, \"Platform information is NULL\\n\");\n\n\tfor (i = 0; i < num_resources; ++i) {\n\t\tstruct tpmi_uncore_power_domain_info *pd_info;\n\t\tstruct resource *res;\n\t\tu64 cluster_offset;\n\t\tu8 cluster_mask;\n\t\tint mask, j;\n\t\tu64 header;\n\n\t\tres = tpmi_get_resource_at_index(auxdev, i);\n\t\tif (!res)\n\t\t\tcontinue;\n\n\t\tpd_info = &tpmi_uncore->pd_info[i];\n\n\t\tpd_info->uncore_base = devm_ioremap_resource(&auxdev->dev, res);\n\t\tif (IS_ERR(pd_info->uncore_base)) {\n\t\t\tret = PTR_ERR(pd_info->uncore_base);\n\t\t\t \n\t\t\tpd_info->uncore_base = NULL;\n\t\t\tgoto remove_clusters;\n\t\t}\n\n\t\t \n\t\theader = readq(pd_info->uncore_base);\n\t\tpd_info->ufs_header_ver = header & UNCORE_VERSION_MASK;\n\t\tif (pd_info->ufs_header_ver != UNCORE_HEADER_VERSION) {\n\t\t\tdev_info(&auxdev->dev, \"Uncore: Unsupported version:%d\\n\",\n\t\t\t\tpd_info->ufs_header_ver);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tcluster_mask = FIELD_GET(UNCORE_LOCAL_FABRIC_CLUSTER_ID_MASK, header);\n\t\tif (!cluster_mask) {\n\t\t\tdev_info(&auxdev->dev, \"Uncore: Invalid cluster mask:%x\\n\", cluster_mask);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tpd_info->cluster_count = hweight8(cluster_mask);\n\n\t\tpd_info->cluster_infos = devm_kcalloc(&auxdev->dev, pd_info->cluster_count,\n\t\t\t\t\t\t      sizeof(struct tpmi_uncore_cluster_info),\n\t\t\t\t\t\t      GFP_KERNEL);\n\t\tif (!pd_info->cluster_infos) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto remove_clusters;\n\t\t}\n\t\t \n\t\tcluster_offset = readq(pd_info->uncore_base +\n\t\t\t\t\tUNCORE_FABRIC_CLUSTER_OFFSET);\n\n\t\tfor (j = 0; j < pd_info->cluster_count; ++j) {\n\t\t\tstruct tpmi_uncore_cluster_info *cluster_info;\n\n\t\t\t \n\t\t\tmask = (cluster_offset & UNCORE_CLUSTER_OFF_MASK);\n\t\t\t \n\t\t\tmask <<= 3;\n\n\t\t\tcluster_info = &pd_info->cluster_infos[j];\n\n\t\t\tcluster_info->cluster_base = pd_info->uncore_base + mask;\n\n\t\t\tcluster_info->uncore_data.package_id = pkg;\n\t\t\t \n\t\t\tcluster_info->uncore_data.die_id = 0;\n\t\t\tcluster_info->uncore_data.domain_id = i;\n\t\t\tcluster_info->uncore_data.cluster_id = j;\n\n\t\t\tcluster_info->uncore_root = tpmi_uncore;\n\n\t\t\tret = uncore_freq_add_entry(&cluster_info->uncore_data, 0);\n\t\t\tif (ret) {\n\t\t\t\tcluster_info->cluster_base = NULL;\n\t\t\t\tgoto remove_clusters;\n\t\t\t}\n\t\t\t \n\t\t\tcluster_offset >>= UNCORE_MAX_CLUSTER_PER_DOMAIN;\n\t\t}\n\t}\n\n\tauxiliary_set_drvdata(auxdev, tpmi_uncore);\n\n\ttpmi_uncore->root_cluster.root_domain = true;\n\ttpmi_uncore->root_cluster.uncore_root = tpmi_uncore;\n\n\ttpmi_uncore->root_cluster.uncore_data.package_id = pkg;\n\ttpmi_uncore->root_cluster.uncore_data.domain_id = UNCORE_DOMAIN_ID_INVALID;\n\tret = uncore_freq_add_entry(&tpmi_uncore->root_cluster.uncore_data, 0);\n\tif (ret)\n\t\tgoto remove_clusters;\n\n\treturn 0;\n\nremove_clusters:\n\tremove_cluster_entries(tpmi_uncore);\nerr_rem_common:\n\tuncore_freq_common_exit();\n\n\treturn ret;\n}\n\nstatic void uncore_remove(struct auxiliary_device *auxdev)\n{\n\tstruct tpmi_uncore_struct *tpmi_uncore = auxiliary_get_drvdata(auxdev);\n\n\tuncore_freq_remove_die_entry(&tpmi_uncore->root_cluster.uncore_data);\n\tremove_cluster_entries(tpmi_uncore);\n\n\tuncore_freq_common_exit();\n}\n\nstatic const struct auxiliary_device_id intel_uncore_id_table[] = {\n\t{ .name = \"intel_vsec.tpmi-uncore\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(auxiliary, intel_uncore_id_table);\n\nstatic struct auxiliary_driver intel_uncore_aux_driver = {\n\t.id_table       = intel_uncore_id_table,\n\t.remove         = uncore_remove,\n\t.probe          = uncore_probe,\n};\n\nmodule_auxiliary_driver(intel_uncore_aux_driver);\n\nMODULE_IMPORT_NS(INTEL_TPMI);\nMODULE_IMPORT_NS(INTEL_UNCORE_FREQUENCY);\nMODULE_DESCRIPTION(\"Intel TPMI UFS Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}