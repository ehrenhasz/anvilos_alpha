{
  "module_name": "compal-laptop.c",
  "hash_id": "bf20952857f7cd2c61a3299ae7196f5dae87248f2fa031e3af3dc50c82ca75d6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/x86/compal-laptop.c",
  "human_readable_source": "\n \n\n \n\n \n\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/acpi.h>\n#include <linux/dmi.h>\n#include <linux/backlight.h>\n#include <linux/platform_device.h>\n#include <linux/rfkill.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/power_supply.h>\n#include <linux/fb.h>\n#include <acpi/video.h>\n\n \n \n \n#define DRIVER_NAME \"compal-laptop\"\n#define DRIVER_VERSION\t\"0.2.7\"\n\n#define BACKLIGHT_LEVEL_ADDR\t\t0xB9\n#define BACKLIGHT_LEVEL_MAX\t\t7\n#define BACKLIGHT_STATE_ADDR\t\t0x59\n#define BACKLIGHT_STATE_ON_DATA\t\t0xE1\n#define BACKLIGHT_STATE_OFF_DATA\t0xE2\n\n#define WAKE_UP_ADDR\t\t\t0xA4\n#define WAKE_UP_PME\t\t\t(1 << 0)\n#define WAKE_UP_MODEM\t\t\t(1 << 1)\n#define WAKE_UP_LAN\t\t\t(1 << 2)\n#define WAKE_UP_WLAN\t\t\t(1 << 4)\n#define WAKE_UP_KEY\t\t\t(1 << 6)\n#define WAKE_UP_MOUSE\t\t\t(1 << 7)\n\n#define WIRELESS_ADDR\t\t\t0xBB\n#define WIRELESS_WLAN\t\t\t(1 << 0)\n#define WIRELESS_BT\t\t\t(1 << 1)\n#define WIRELESS_WLAN_EXISTS\t\t(1 << 2)\n#define WIRELESS_BT_EXISTS\t\t(1 << 3)\n#define WIRELESS_KILLSWITCH\t\t(1 << 4)\n\n#define PWM_ADDRESS\t\t\t0x46\n#define PWM_DISABLE_ADDR\t\t0x59\n#define PWM_DISABLE_DATA\t\t0xA5\n#define PWM_ENABLE_ADDR\t\t\t0x59\n#define PWM_ENABLE_DATA\t\t\t0xA8\n\n#define FAN_ADDRESS\t\t\t0x46\n#define FAN_DATA\t\t\t0x81\n#define FAN_FULL_ON_CMD\t\t\t0x59  \n#define FAN_FULL_ON_ENABLE\t\t0x76  \n#define FAN_FULL_ON_DISABLE\t\t0x77  \n\n#define TEMP_CPU\t\t\t0xB0\n#define TEMP_CPU_LOCAL\t\t\t0xB1\n#define TEMP_CPU_DTS\t\t\t0xB5\n#define TEMP_NORTHBRIDGE\t\t0xB6\n#define TEMP_VGA\t\t\t0xB4\n#define TEMP_SKIN\t\t\t0xB2\n\n#define BAT_MANUFACTURER_NAME_ADDR\t0x10\n#define BAT_MANUFACTURER_NAME_LEN\t9\n#define BAT_MODEL_NAME_ADDR\t\t0x19\n#define BAT_MODEL_NAME_LEN\t\t6\n#define BAT_SERIAL_NUMBER_ADDR\t\t0xC4\n#define BAT_SERIAL_NUMBER_LEN\t\t5\n#define BAT_CHARGE_NOW\t\t\t0xC2\n#define BAT_CHARGE_DESIGN\t\t0xCA\n#define BAT_VOLTAGE_NOW\t\t\t0xC6\n#define BAT_VOLTAGE_DESIGN\t\t0xC8\n#define BAT_CURRENT_NOW\t\t\t0xD0\n#define BAT_CURRENT_AVG\t\t\t0xD2\n#define BAT_POWER\t\t\t0xD4\n#define BAT_CAPACITY\t\t\t0xCE\n#define BAT_TEMP\t\t\t0xD6\n#define BAT_TEMP_AVG\t\t\t0xD7\n#define BAT_STATUS0\t\t\t0xC1\n#define BAT_STATUS1\t\t\t0xF0\n#define BAT_STATUS2\t\t\t0xF1\n#define BAT_STOP_CHARGE1\t\t0xF2\n#define BAT_STOP_CHARGE2\t\t0xF3\n#define BAT_CHARGE_LIMIT\t\t0x03\n#define BAT_CHARGE_LIMIT_MAX\t\t100\n\n#define BAT_S0_DISCHARGE\t\t(1 << 0)\n#define BAT_S0_DISCHRG_CRITICAL\t\t(1 << 2)\n#define BAT_S0_LOW\t\t\t(1 << 3)\n#define BAT_S0_CHARGING\t\t\t(1 << 1)\n#define BAT_S0_AC\t\t\t(1 << 7)\n#define BAT_S1_EXISTS\t\t\t(1 << 0)\n#define BAT_S1_FULL\t\t\t(1 << 1)\n#define BAT_S1_EMPTY\t\t\t(1 << 2)\n#define BAT_S1_LiION_OR_NiMH\t\t(1 << 7)\n#define BAT_S2_LOW_LOW\t\t\t(1 << 0)\n#define BAT_STOP_CHRG1_BAD_CELL\t\t(1 << 1)\n#define BAT_STOP_CHRG1_COMM_FAIL\t(1 << 2)\n#define BAT_STOP_CHRG1_OVERVOLTAGE\t(1 << 6)\n#define BAT_STOP_CHRG1_OVERTEMPERATURE\t(1 << 7)\n\n\n \n \n \nstruct compal_data{\n\t \n\tint pwm_enable;  \n\tunsigned char curr_pwm;\n\n\t \n\tstruct power_supply *psy;\n\tstruct power_supply_info psy_info;\n\tchar bat_model_name[BAT_MODEL_NAME_LEN + 1];\n\tchar bat_manufacturer_name[BAT_MANUFACTURER_NAME_LEN + 1];\n\tchar bat_serial_number[BAT_SERIAL_NUMBER_LEN + 1];\n};\n\n\n \n \n \nstatic bool force;\nmodule_param(force, bool, 0);\nMODULE_PARM_DESC(force, \"Force driver load, ignore DMI data\");\n\n \nstatic bool extra_features;\n\n \nstatic const unsigned char pwm_lookup_table[256] = {\n\t0, 0, 0, 1, 1, 1, 2, 253, 254, 3, 3, 3, 4, 4, 4, 5, 5, 5, 6, 6, 6,\n\t7, 7, 7, 8, 86, 86, 9, 9, 9, 10, 10, 10, 11, 92, 92, 12, 12, 95,\n\t13, 66, 66, 14, 14, 98, 15, 15, 15, 16, 16, 67, 17, 17, 72, 18, 70,\n\t75, 19, 90, 90, 73, 73, 73, 21, 21, 91, 91, 91, 96, 23, 94, 94, 94,\n\t94, 94, 94, 94, 94, 94, 94, 141, 141, 238, 223, 192, 139, 139, 139,\n\t139, 139, 142, 142, 142, 142, 142, 78, 78, 78, 78, 78, 76, 76, 76,\n\t76, 76, 79, 79, 79, 79, 79, 79, 79, 20, 20, 20, 20, 20, 22, 22, 22,\n\t22, 22, 24, 24, 24, 24, 24, 24, 219, 219, 219, 219, 219, 219, 219,\n\t219, 27, 27, 188, 188, 28, 28, 28, 29, 186, 186, 186, 186, 186,\n\t186, 186, 186, 186, 186, 31, 31, 31, 31, 31, 32, 32, 32, 41, 33,\n\t33, 33, 33, 33, 252, 252, 34, 34, 34, 43, 35, 35, 35, 36, 36, 38,\n\t206, 206, 206, 206, 206, 206, 206, 206, 206, 37, 37, 37, 46, 46,\n\t47, 47, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 48, 48,\n\t48, 48, 48, 40, 40, 40, 49, 42, 42, 42, 42, 42, 42, 42, 42, 44,\n\t189, 189, 189, 189, 54, 54, 45, 45, 45, 45, 45, 45, 45, 45, 251,\n\t191, 199, 199, 199, 199, 199, 215, 215, 215, 215, 187, 187, 187,\n\t187, 187, 193, 50\n};\n\n\n\n\n \n \n \n \nstatic u8 ec_read_u8(u8 addr)\n{\n\tu8 value = 0;\n\tec_read(addr, &value);\n\treturn value;\n}\n\nstatic s8 ec_read_s8(u8 addr)\n{\n\treturn (s8)ec_read_u8(addr);\n}\n\nstatic u16 ec_read_u16(u8 addr)\n{\n\tint hi, lo;\n\tlo = ec_read_u8(addr);\n\thi = ec_read_u8(addr + 1);\n\treturn (hi << 8) + lo;\n}\n\nstatic s16 ec_read_s16(u8 addr)\n{\n\treturn (s16) ec_read_u16(addr);\n}\n\nstatic void ec_read_sequence(u8 addr, u8 *buf, int len)\n{\n\tint i;\n\tfor (i = 0; i < len; i++)\n\t\tec_read(addr + i, buf + i);\n}\n\n\n \nstatic int set_backlight_level(int level)\n{\n\tif (level < 0 || level > BACKLIGHT_LEVEL_MAX)\n\t\treturn -EINVAL;\n\n\tec_write(BACKLIGHT_LEVEL_ADDR, level);\n\n\treturn 0;\n}\n\nstatic int get_backlight_level(void)\n{\n\treturn (int) ec_read_u8(BACKLIGHT_LEVEL_ADDR);\n}\n\nstatic void set_backlight_state(bool on)\n{\n\tu8 data = on ? BACKLIGHT_STATE_ON_DATA : BACKLIGHT_STATE_OFF_DATA;\n\tec_transaction(BACKLIGHT_STATE_ADDR, &data, 1, NULL, 0);\n}\n\n\n \nstatic void pwm_enable_control(void)\n{\n\tunsigned char writeData = PWM_ENABLE_DATA;\n\tec_transaction(PWM_ENABLE_ADDR, &writeData, 1, NULL, 0);\n}\n\nstatic void pwm_disable_control(void)\n{\n\tunsigned char writeData = PWM_DISABLE_DATA;\n\tec_transaction(PWM_DISABLE_ADDR, &writeData, 1, NULL, 0);\n}\n\nstatic void set_pwm(int pwm)\n{\n\tec_transaction(PWM_ADDRESS, &pwm_lookup_table[pwm], 1, NULL, 0);\n}\n\nstatic int get_fan_rpm(void)\n{\n\tu8 value, data = FAN_DATA;\n\tec_transaction(FAN_ADDRESS, &data, 1, &value, 1);\n\treturn 100 * (int)value;\n}\n\n\n\n\n \n \n \n\n \nstatic int bl_get_brightness(struct backlight_device *b)\n{\n\treturn get_backlight_level();\n}\n\nstatic int bl_update_status(struct backlight_device *b)\n{\n\tint ret = set_backlight_level(b->props.brightness);\n\tif (ret)\n\t\treturn ret;\n\n\tset_backlight_state(!backlight_is_blank(b));\n\treturn 0;\n}\n\nstatic const struct backlight_ops compalbl_ops = {\n\t.get_brightness = bl_get_brightness,\n\t.update_status\t= bl_update_status,\n};\n\n\n \nstatic int compal_rfkill_set(void *data, bool blocked)\n{\n\tunsigned long radio = (unsigned long) data;\n\tu8 result = ec_read_u8(WIRELESS_ADDR);\n\tu8 value;\n\n\tif (!blocked)\n\t\tvalue = (u8) (result | radio);\n\telse\n\t\tvalue = (u8) (result & ~radio);\n\tec_write(WIRELESS_ADDR, value);\n\n\treturn 0;\n}\n\nstatic void compal_rfkill_poll(struct rfkill *rfkill, void *data)\n{\n\tu8 result = ec_read_u8(WIRELESS_ADDR);\n\tbool hw_blocked = !(result & WIRELESS_KILLSWITCH);\n\trfkill_set_hw_state(rfkill, hw_blocked);\n}\n\nstatic const struct rfkill_ops compal_rfkill_ops = {\n\t.poll = compal_rfkill_poll,\n\t.set_block = compal_rfkill_set,\n};\n\n\n \n#define SIMPLE_MASKED_STORE_SHOW(NAME, ADDR, MASK)\t\t\t\\\nstatic ssize_t NAME##_show(struct device *dev,\t\t\t\t\\\n\tstruct device_attribute *attr, char *buf)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\treturn sprintf(buf, \"%d\\n\", ((ec_read_u8(ADDR) & MASK) != 0));\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic ssize_t NAME##_store(struct device *dev,\t\t\t\t\\\n\tstruct device_attribute *attr, const char *buf, size_t count)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tint state;\t\t\t\t\t\t\t\\\n\tu8 old_val = ec_read_u8(ADDR);\t\t\t\t\t\\\n\tif (sscanf(buf, \"%d\", &state) != 1 || (state < 0 || state > 1))\t\\\n\t\treturn -EINVAL;\t\t\t\t\t\t\\\n\tec_write(ADDR, state ? (old_val | MASK) : (old_val & ~MASK));\t\\\n\treturn count;\t\t\t\t\t\t\t\\\n}\n\nSIMPLE_MASKED_STORE_SHOW(wake_up_pme,\tWAKE_UP_ADDR, WAKE_UP_PME)\nSIMPLE_MASKED_STORE_SHOW(wake_up_modem,\tWAKE_UP_ADDR, WAKE_UP_MODEM)\nSIMPLE_MASKED_STORE_SHOW(wake_up_lan,\tWAKE_UP_ADDR, WAKE_UP_LAN)\nSIMPLE_MASKED_STORE_SHOW(wake_up_wlan,\tWAKE_UP_ADDR, WAKE_UP_WLAN)\nSIMPLE_MASKED_STORE_SHOW(wake_up_key,\tWAKE_UP_ADDR, WAKE_UP_KEY)\nSIMPLE_MASKED_STORE_SHOW(wake_up_mouse,\tWAKE_UP_ADDR, WAKE_UP_MOUSE)\n\n \nstatic ssize_t pwm_enable_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct compal_data *data = dev_get_drvdata(dev);\n\treturn sprintf(buf, \"%d\\n\", data->pwm_enable);\n}\n\nstatic ssize_t pwm_enable_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct compal_data *data = dev_get_drvdata(dev);\n\tlong val;\n\tint err;\n\n\terr = kstrtol(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\tif (val < 0)\n\t\treturn -EINVAL;\n\n\tdata->pwm_enable = val;\n\n\tswitch (val) {\n\tcase 0:   \n\t\tpwm_enable_control();\n\t\tset_pwm(255);\n\t\tbreak;\n\tcase 1:   \n\t\tpwm_enable_control();\n\t\tset_pwm(data->curr_pwm);\n\t\tbreak;\n\tdefault:  \n\t\tpwm_disable_control();\n\t\tbreak;\n\t}\n\n\treturn count;\n}\n\nstatic ssize_t pwm_show(struct device *dev, struct device_attribute *attr,\n\t\tchar *buf)\n{\n\tstruct compal_data *data = dev_get_drvdata(dev);\n\treturn sprintf(buf, \"%hhu\\n\", data->curr_pwm);\n}\n\nstatic ssize_t pwm_store(struct device *dev, struct device_attribute *attr,\n\t\tconst char *buf, size_t count)\n{\n\tstruct compal_data *data = dev_get_drvdata(dev);\n\tlong val;\n\tint err;\n\n\terr = kstrtol(buf, 10, &val);\n\tif (err)\n\t\treturn err;\n\tif (val < 0 || val > 255)\n\t\treturn -EINVAL;\n\n\tdata->curr_pwm = val;\n\n\tif (data->pwm_enable != 1)\n\t\treturn count;\n\tset_pwm(val);\n\n\treturn count;\n}\n\nstatic ssize_t fan_show(struct device *dev, struct device_attribute *attr,\n\t\tchar *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", get_fan_rpm());\n}\n\n\n \n#define TEMPERATURE_SHOW_TEMP_AND_LABEL(POSTFIX, ADDRESS, LABEL)\t\\\nstatic ssize_t temp_##POSTFIX(struct device *dev,\t\t\t\\\n\t\tstruct device_attribute *attr, char *buf)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\treturn sprintf(buf, \"%d\\n\", 1000 * (int)ec_read_s8(ADDRESS));\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic ssize_t label_##POSTFIX(struct device *dev,\t\t\t\\\n\t\tstruct device_attribute *attr, char *buf)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\treturn sprintf(buf, \"%s\\n\", LABEL);\t\t\t\t\\\n}\n\n \nTEMPERATURE_SHOW_TEMP_AND_LABEL(cpu,        TEMP_CPU,        \"CPU_TEMP\");\nTEMPERATURE_SHOW_TEMP_AND_LABEL(cpu_local,  TEMP_CPU_LOCAL,  \"CPU_TEMP_LOCAL\");\nTEMPERATURE_SHOW_TEMP_AND_LABEL(cpu_DTS,    TEMP_CPU_DTS,    \"CPU_DTS\");\nTEMPERATURE_SHOW_TEMP_AND_LABEL(northbridge,TEMP_NORTHBRIDGE,\"NorthBridge\");\nTEMPERATURE_SHOW_TEMP_AND_LABEL(vga,        TEMP_VGA,        \"VGA_TEMP\");\nTEMPERATURE_SHOW_TEMP_AND_LABEL(SKIN,       TEMP_SKIN,       \"SKIN_TEMP90\");\n\n\n \nstatic int bat_status(void)\n{\n\tu8 status0 = ec_read_u8(BAT_STATUS0);\n\tu8 status1 = ec_read_u8(BAT_STATUS1);\n\n\tif (status0 & BAT_S0_CHARGING)\n\t\treturn POWER_SUPPLY_STATUS_CHARGING;\n\tif (status0 & BAT_S0_DISCHARGE)\n\t\treturn POWER_SUPPLY_STATUS_DISCHARGING;\n\tif (status1 & BAT_S1_FULL)\n\t\treturn POWER_SUPPLY_STATUS_FULL;\n\treturn POWER_SUPPLY_STATUS_NOT_CHARGING;\n}\n\nstatic int bat_health(void)\n{\n\tu8 status = ec_read_u8(BAT_STOP_CHARGE1);\n\n\tif (status & BAT_STOP_CHRG1_OVERTEMPERATURE)\n\t\treturn POWER_SUPPLY_HEALTH_OVERHEAT;\n\tif (status & BAT_STOP_CHRG1_OVERVOLTAGE)\n\t\treturn POWER_SUPPLY_HEALTH_OVERVOLTAGE;\n\tif (status & BAT_STOP_CHRG1_BAD_CELL)\n\t\treturn POWER_SUPPLY_HEALTH_DEAD;\n\tif (status & BAT_STOP_CHRG1_COMM_FAIL)\n\t\treturn POWER_SUPPLY_HEALTH_UNKNOWN;\n\treturn POWER_SUPPLY_HEALTH_GOOD;\n}\n\nstatic int bat_is_present(void)\n{\n\tu8 status = ec_read_u8(BAT_STATUS2);\n\treturn ((status & BAT_S1_EXISTS) != 0);\n}\n\nstatic int bat_technology(void)\n{\n\tu8 status = ec_read_u8(BAT_STATUS1);\n\n\tif (status & BAT_S1_LiION_OR_NiMH)\n\t\treturn POWER_SUPPLY_TECHNOLOGY_LION;\n\treturn POWER_SUPPLY_TECHNOLOGY_NiMH;\n}\n\nstatic int bat_capacity_level(void)\n{\n\tu8 status0 = ec_read_u8(BAT_STATUS0);\n\tu8 status1 = ec_read_u8(BAT_STATUS1);\n\tu8 status2 = ec_read_u8(BAT_STATUS2);\n\n\tif (status0 & BAT_S0_DISCHRG_CRITICAL\n\t\t\t|| status1 & BAT_S1_EMPTY\n\t\t\t|| status2 & BAT_S2_LOW_LOW)\n\t\treturn POWER_SUPPLY_CAPACITY_LEVEL_CRITICAL;\n\tif (status0 & BAT_S0_LOW)\n\t\treturn POWER_SUPPLY_CAPACITY_LEVEL_LOW;\n\tif (status1 & BAT_S1_FULL)\n\t\treturn POWER_SUPPLY_CAPACITY_LEVEL_FULL;\n\treturn POWER_SUPPLY_CAPACITY_LEVEL_NORMAL;\n}\n\nstatic int bat_get_property(struct power_supply *psy,\n\t\t\t\tenum power_supply_property psp,\n\t\t\t\tunion power_supply_propval *val)\n{\n\tstruct compal_data *data = power_supply_get_drvdata(psy);\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_STATUS:\n\t\tval->intval = bat_status();\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_HEALTH:\n\t\tval->intval = bat_health();\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_PRESENT:\n\t\tval->intval = bat_is_present();\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_TECHNOLOGY:\n\t\tval->intval = bat_technology();\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN:  \n\t\tval->intval = ec_read_u16(BAT_VOLTAGE_DESIGN) * 1000;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_VOLTAGE_NOW:\n\t\tval->intval = ec_read_u16(BAT_VOLTAGE_NOW) * 1000;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CURRENT_NOW:\n\t\tval->intval = ec_read_s16(BAT_CURRENT_NOW) * 1000;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CURRENT_AVG:\n\t\tval->intval = ec_read_s16(BAT_CURRENT_AVG) * 1000;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_POWER_NOW:\n\t\tval->intval = ec_read_u8(BAT_POWER) * 1000000;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN:\n\t\tval->intval = ec_read_u16(BAT_CHARGE_DESIGN) * 1000;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CHARGE_NOW:\n\t\tval->intval = ec_read_u16(BAT_CHARGE_NOW) * 1000;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT:\n\t\tval->intval = ec_read_u8(BAT_CHARGE_LIMIT);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT_MAX:\n\t\tval->intval = BAT_CHARGE_LIMIT_MAX;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CAPACITY:\n\t\tval->intval = ec_read_u8(BAT_CAPACITY);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CAPACITY_LEVEL:\n\t\tval->intval = bat_capacity_level();\n\t\tbreak;\n\t \n\tcase POWER_SUPPLY_PROP_TEMP:\n\t\tval->intval = ((222 - (int)ec_read_u8(BAT_TEMP)) * 1000) >> 8;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_TEMP_AMBIENT:  \n\t\tval->intval = ec_read_s8(BAT_TEMP_AVG) * 10;\n\t\tbreak;\n\t \n\tcase POWER_SUPPLY_PROP_MODEL_NAME:\n\t\tval->strval = data->bat_model_name;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_MANUFACTURER:\n\t\tval->strval = data->bat_manufacturer_name;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_SERIAL_NUMBER:\n\t\tval->strval = data->bat_serial_number;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int bat_set_property(struct power_supply *psy,\n\t\t\t\tenum power_supply_property psp,\n\t\t\t\tconst union power_supply_propval *val)\n{\n\tint level;\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT:\n\t\tlevel = val->intval;\n\t\tif (level < 0 || level > BAT_CHARGE_LIMIT_MAX)\n\t\t\treturn -EINVAL;\n\t\tif (ec_write(BAT_CHARGE_LIMIT, level) < 0)\n\t\t\treturn -EIO;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int bat_writeable_property(struct power_supply *psy,\n\t\t\t\tenum power_supply_property psp)\n{\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT:\n\t\treturn 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\n\n\n\n \n \n \nstatic DEVICE_ATTR_RW(wake_up_pme);\nstatic DEVICE_ATTR_RW(wake_up_modem);\nstatic DEVICE_ATTR_RW(wake_up_lan);\nstatic DEVICE_ATTR_RW(wake_up_wlan);\nstatic DEVICE_ATTR_RW(wake_up_key);\nstatic DEVICE_ATTR_RW(wake_up_mouse);\n\nstatic DEVICE_ATTR(fan1_input,  S_IRUGO, fan_show,          NULL);\nstatic DEVICE_ATTR(temp1_input, S_IRUGO, temp_cpu,          NULL);\nstatic DEVICE_ATTR(temp2_input, S_IRUGO, temp_cpu_local,    NULL);\nstatic DEVICE_ATTR(temp3_input, S_IRUGO, temp_cpu_DTS,      NULL);\nstatic DEVICE_ATTR(temp4_input, S_IRUGO, temp_northbridge,  NULL);\nstatic DEVICE_ATTR(temp5_input, S_IRUGO, temp_vga,          NULL);\nstatic DEVICE_ATTR(temp6_input, S_IRUGO, temp_SKIN,         NULL);\nstatic DEVICE_ATTR(temp1_label, S_IRUGO, label_cpu,         NULL);\nstatic DEVICE_ATTR(temp2_label, S_IRUGO, label_cpu_local,   NULL);\nstatic DEVICE_ATTR(temp3_label, S_IRUGO, label_cpu_DTS,     NULL);\nstatic DEVICE_ATTR(temp4_label, S_IRUGO, label_northbridge, NULL);\nstatic DEVICE_ATTR(temp5_label, S_IRUGO, label_vga,         NULL);\nstatic DEVICE_ATTR(temp6_label, S_IRUGO, label_SKIN,        NULL);\nstatic DEVICE_ATTR(pwm1, S_IRUGO | S_IWUSR, pwm_show, pwm_store);\nstatic DEVICE_ATTR(pwm1_enable,\n\t\t   S_IRUGO | S_IWUSR, pwm_enable_show, pwm_enable_store);\n\nstatic struct attribute *compal_platform_attrs[] = {\n\t&dev_attr_wake_up_pme.attr,\n\t&dev_attr_wake_up_modem.attr,\n\t&dev_attr_wake_up_lan.attr,\n\t&dev_attr_wake_up_wlan.attr,\n\t&dev_attr_wake_up_key.attr,\n\t&dev_attr_wake_up_mouse.attr,\n\tNULL\n};\nstatic const struct attribute_group compal_platform_attr_group = {\n\t.attrs = compal_platform_attrs\n};\n\nstatic struct attribute *compal_hwmon_attrs[] = {\n\t&dev_attr_pwm1_enable.attr,\n\t&dev_attr_pwm1.attr,\n\t&dev_attr_fan1_input.attr,\n\t&dev_attr_temp1_input.attr,\n\t&dev_attr_temp2_input.attr,\n\t&dev_attr_temp3_input.attr,\n\t&dev_attr_temp4_input.attr,\n\t&dev_attr_temp5_input.attr,\n\t&dev_attr_temp6_input.attr,\n\t&dev_attr_temp1_label.attr,\n\t&dev_attr_temp2_label.attr,\n\t&dev_attr_temp3_label.attr,\n\t&dev_attr_temp4_label.attr,\n\t&dev_attr_temp5_label.attr,\n\t&dev_attr_temp6_label.attr,\n\tNULL\n};\nATTRIBUTE_GROUPS(compal_hwmon);\n\nstatic enum power_supply_property compal_bat_properties[] = {\n\tPOWER_SUPPLY_PROP_STATUS,\n\tPOWER_SUPPLY_PROP_HEALTH,\n\tPOWER_SUPPLY_PROP_PRESENT,\n\tPOWER_SUPPLY_PROP_TECHNOLOGY,\n\tPOWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN,\n\tPOWER_SUPPLY_PROP_VOLTAGE_NOW,\n\tPOWER_SUPPLY_PROP_CURRENT_NOW,\n\tPOWER_SUPPLY_PROP_CURRENT_AVG,\n\tPOWER_SUPPLY_PROP_POWER_NOW,\n\tPOWER_SUPPLY_PROP_CHARGE_FULL_DESIGN,\n\tPOWER_SUPPLY_PROP_CHARGE_NOW,\n\tPOWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT,\n\tPOWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT_MAX,\n\tPOWER_SUPPLY_PROP_CAPACITY,\n\tPOWER_SUPPLY_PROP_CAPACITY_LEVEL,\n\tPOWER_SUPPLY_PROP_TEMP,\n\tPOWER_SUPPLY_PROP_TEMP_AMBIENT,\n\tPOWER_SUPPLY_PROP_MODEL_NAME,\n\tPOWER_SUPPLY_PROP_MANUFACTURER,\n\tPOWER_SUPPLY_PROP_SERIAL_NUMBER,\n};\n\nstatic struct backlight_device *compalbl_device;\n\nstatic struct platform_device *compal_device;\n\nstatic struct rfkill *wifi_rfkill;\nstatic struct rfkill *bt_rfkill;\n\n\n\n\n\n \n \n \n\nstatic int dmi_check_cb(const struct dmi_system_id *id)\n{\n\tpr_info(\"Identified laptop model '%s'\\n\", id->ident);\n\textra_features = false;\n\treturn 1;\n}\n\nstatic int dmi_check_cb_extra(const struct dmi_system_id *id)\n{\n\tpr_info(\"Identified laptop model '%s', enabling extra features\\n\",\n\t\tid->ident);\n\textra_features = true;\n\treturn 1;\n}\n\nstatic const struct dmi_system_id compal_dmi_table[] __initconst = {\n\t{\n\t\t.ident = \"FL90/IFL90\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"IFL90\"),\n\t\t\tDMI_MATCH(DMI_BOARD_VERSION, \"IFT00\"),\n\t\t},\n\t\t.callback = dmi_check_cb\n\t},\n\t{\n\t\t.ident = \"FL90/IFL90\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"IFL90\"),\n\t\t\tDMI_MATCH(DMI_BOARD_VERSION, \"REFERENCE\"),\n\t\t},\n\t\t.callback = dmi_check_cb\n\t},\n\t{\n\t\t.ident = \"FL91/IFL91\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"IFL91\"),\n\t\t\tDMI_MATCH(DMI_BOARD_VERSION, \"IFT00\"),\n\t\t},\n\t\t.callback = dmi_check_cb\n\t},\n\t{\n\t\t.ident = \"FL92/JFL92\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"JFL92\"),\n\t\t\tDMI_MATCH(DMI_BOARD_VERSION, \"IFT00\"),\n\t\t},\n\t\t.callback = dmi_check_cb\n\t},\n\t{\n\t\t.ident = \"FT00/IFT00\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"IFT00\"),\n\t\t\tDMI_MATCH(DMI_BOARD_VERSION, \"IFT00\"),\n\t\t},\n\t\t.callback = dmi_check_cb\n\t},\n\t{\n\t\t.ident = \"Dell Mini 9\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Inc.\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Inspiron 910\"),\n\t\t},\n\t\t.callback = dmi_check_cb\n\t},\n\t{\n\t\t.ident = \"Dell Mini 10\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Inc.\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Inspiron 1010\"),\n\t\t},\n\t\t.callback = dmi_check_cb\n\t},\n\t{\n\t\t.ident = \"Dell Mini 10v\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Inc.\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Inspiron 1011\"),\n\t\t},\n\t\t.callback = dmi_check_cb\n\t},\n\t{\n\t\t.ident = \"Dell Mini 1012\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Inc.\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Inspiron 1012\"),\n\t\t},\n\t\t.callback = dmi_check_cb\n\t},\n\t{\n\t\t.ident = \"Dell Inspiron 11z\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Inc.\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Inspiron 1110\"),\n\t\t},\n\t\t.callback = dmi_check_cb\n\t},\n\t{\n\t\t.ident = \"Dell Mini 12\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Inc.\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Inspiron 1210\"),\n\t\t},\n\t\t.callback = dmi_check_cb\n\t},\n\t{\n\t\t.ident = \"JHL90\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"JHL90\"),\n\t\t\tDMI_MATCH(DMI_BOARD_VERSION, \"REFERENCE\"),\n\t\t},\n\t\t.callback = dmi_check_cb_extra\n\t},\n\t{\n\t\t.ident = \"KHLB2\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"KHLB2\"),\n\t\t\tDMI_MATCH(DMI_BOARD_VERSION, \"REFERENCE\"),\n\t\t},\n\t\t.callback = dmi_check_cb_extra\n\t},\n\t{ }\n};\nMODULE_DEVICE_TABLE(dmi, compal_dmi_table);\n\nstatic const struct power_supply_desc psy_bat_desc = {\n\t.name\t\t= DRIVER_NAME,\n\t.type\t\t= POWER_SUPPLY_TYPE_BATTERY,\n\t.properties\t= compal_bat_properties,\n\t.num_properties\t= ARRAY_SIZE(compal_bat_properties),\n\t.get_property\t= bat_get_property,\n\t.set_property\t= bat_set_property,\n\t.property_is_writeable = bat_writeable_property,\n};\n\nstatic void initialize_power_supply_data(struct compal_data *data)\n{\n\tec_read_sequence(BAT_MANUFACTURER_NAME_ADDR,\n\t\t\t\t\tdata->bat_manufacturer_name,\n\t\t\t\t\tBAT_MANUFACTURER_NAME_LEN);\n\tdata->bat_manufacturer_name[BAT_MANUFACTURER_NAME_LEN] = 0;\n\n\tec_read_sequence(BAT_MODEL_NAME_ADDR,\n\t\t\t\t\tdata->bat_model_name,\n\t\t\t\t\tBAT_MODEL_NAME_LEN);\n\tdata->bat_model_name[BAT_MODEL_NAME_LEN] = 0;\n\n\tscnprintf(data->bat_serial_number, BAT_SERIAL_NUMBER_LEN + 1, \"%d\",\n\t\t\t\tec_read_u16(BAT_SERIAL_NUMBER_ADDR));\n}\n\nstatic void initialize_fan_control_data(struct compal_data *data)\n{\n\tdata->pwm_enable = 2;  \n\tdata->curr_pwm = 255;  \n}\n\nstatic int setup_rfkill(void)\n{\n\tint ret;\n\n\twifi_rfkill = rfkill_alloc(\"compal-wifi\", &compal_device->dev,\n\t\t\t\tRFKILL_TYPE_WLAN, &compal_rfkill_ops,\n\t\t\t\t(void *) WIRELESS_WLAN);\n\tif (!wifi_rfkill)\n\t\treturn -ENOMEM;\n\n\tret = rfkill_register(wifi_rfkill);\n\tif (ret)\n\t\tgoto err_wifi;\n\n\tbt_rfkill = rfkill_alloc(\"compal-bluetooth\", &compal_device->dev,\n\t\t\t\tRFKILL_TYPE_BLUETOOTH, &compal_rfkill_ops,\n\t\t\t\t(void *) WIRELESS_BT);\n\tif (!bt_rfkill) {\n\t\tret = -ENOMEM;\n\t\tgoto err_allocate_bt;\n\t}\n\tret = rfkill_register(bt_rfkill);\n\tif (ret)\n\t\tgoto err_register_bt;\n\n\treturn 0;\n\nerr_register_bt:\n\trfkill_destroy(bt_rfkill);\n\nerr_allocate_bt:\n\trfkill_unregister(wifi_rfkill);\n\nerr_wifi:\n\trfkill_destroy(wifi_rfkill);\n\n\treturn ret;\n}\n\nstatic int compal_probe(struct platform_device *pdev)\n{\n\tint err;\n\tstruct compal_data *data;\n\tstruct device *hwmon_dev;\n\tstruct power_supply_config psy_cfg = {};\n\n\tif (!extra_features)\n\t\treturn 0;\n\n\t \n\tdata = devm_kzalloc(&pdev->dev, sizeof(struct compal_data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tinitialize_fan_control_data(data);\n\n\terr = sysfs_create_group(&pdev->dev.kobj, &compal_platform_attr_group);\n\tif (err)\n\t\treturn err;\n\n\thwmon_dev = devm_hwmon_device_register_with_groups(&pdev->dev,\n\t\t\t\t\t\t\t   \"compal\", data,\n\t\t\t\t\t\t\t   compal_hwmon_groups);\n\tif (IS_ERR(hwmon_dev)) {\n\t\terr = PTR_ERR(hwmon_dev);\n\t\tgoto remove;\n\t}\n\n\t \n\tinitialize_power_supply_data(data);\n\tpsy_cfg.drv_data = data;\n\tdata->psy = power_supply_register(&compal_device->dev, &psy_bat_desc,\n\t\t\t\t\t  &psy_cfg);\n\tif (IS_ERR(data->psy)) {\n\t\terr = PTR_ERR(data->psy);\n\t\tgoto remove;\n\t}\n\n\tplatform_set_drvdata(pdev, data);\n\n\treturn 0;\n\nremove:\n\tsysfs_remove_group(&pdev->dev.kobj, &compal_platform_attr_group);\n\treturn err;\n}\n\nstatic void compal_remove(struct platform_device *pdev)\n{\n\tstruct compal_data *data;\n\n\tif (!extra_features)\n\t\treturn;\n\n\tpr_info(\"Unloading: resetting fan control to motherboard\\n\");\n\tpwm_disable_control();\n\n\tdata = platform_get_drvdata(pdev);\n\tpower_supply_unregister(data->psy);\n\n\tsysfs_remove_group(&pdev->dev.kobj, &compal_platform_attr_group);\n}\n\nstatic struct platform_driver compal_driver = {\n\t.driver = {\n\t\t.name = DRIVER_NAME,\n\t},\n\t.probe\t= compal_probe,\n\t.remove_new = compal_remove,\n};\n\nstatic int __init compal_init(void)\n{\n\tint ret;\n\n\tif (acpi_disabled) {\n\t\tpr_err(\"ACPI needs to be enabled for this driver to work!\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (!force && !dmi_check_system(compal_dmi_table)) {\n\t\tpr_err(\"Motherboard not recognized (You could try the module's force-parameter)\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (acpi_video_get_backlight_type() == acpi_backlight_vendor) {\n\t\tstruct backlight_properties props;\n\t\tmemset(&props, 0, sizeof(struct backlight_properties));\n\t\tprops.type = BACKLIGHT_PLATFORM;\n\t\tprops.max_brightness = BACKLIGHT_LEVEL_MAX;\n\t\tcompalbl_device = backlight_device_register(DRIVER_NAME,\n\t\t\t\t\t\t\t    NULL, NULL,\n\t\t\t\t\t\t\t    &compalbl_ops,\n\t\t\t\t\t\t\t    &props);\n\t\tif (IS_ERR(compalbl_device))\n\t\t\treturn PTR_ERR(compalbl_device);\n\t}\n\n\tret = platform_driver_register(&compal_driver);\n\tif (ret)\n\t\tgoto err_backlight;\n\n\tcompal_device = platform_device_alloc(DRIVER_NAME, PLATFORM_DEVID_NONE);\n\tif (!compal_device) {\n\t\tret = -ENOMEM;\n\t\tgoto err_platform_driver;\n\t}\n\n\tret = platform_device_add(compal_device);  \n\tif (ret)\n\t\tgoto err_platform_device;\n\n\tret = setup_rfkill();\n\tif (ret)\n\t\tgoto err_rfkill;\n\n\tpr_info(\"Driver \" DRIVER_VERSION \" successfully loaded\\n\");\n\treturn 0;\n\nerr_rfkill:\n\tplatform_device_del(compal_device);\n\nerr_platform_device:\n\tplatform_device_put(compal_device);\n\nerr_platform_driver:\n\tplatform_driver_unregister(&compal_driver);\n\nerr_backlight:\n\tbacklight_device_unregister(compalbl_device);\n\n\treturn ret;\n}\n\nstatic void __exit compal_cleanup(void)\n{\n\tplatform_device_unregister(compal_device);\n\tplatform_driver_unregister(&compal_driver);\n\tbacklight_device_unregister(compalbl_device);\n\trfkill_unregister(wifi_rfkill);\n\trfkill_unregister(bt_rfkill);\n\trfkill_destroy(wifi_rfkill);\n\trfkill_destroy(bt_rfkill);\n\n\tpr_info(\"Driver unloaded\\n\");\n}\n\nmodule_init(compal_init);\nmodule_exit(compal_cleanup);\n\nMODULE_AUTHOR(\"Cezary Jackiewicz\");\nMODULE_AUTHOR(\"Roald Frederickx (roald.frederickx@gmail.com)\");\nMODULE_DESCRIPTION(\"Compal Laptop Support\");\nMODULE_VERSION(DRIVER_VERSION);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}