{
  "module_name": "acerhdf.c",
  "hash_id": "dbbebdc476a413f89fa4858d770de94e3ce1c523d549d81bc8b0f75a3d9cbad5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/x86/acerhdf.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"acerhdf: \" fmt\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/dmi.h>\n#include <linux/acpi.h>\n#include <linux/thermal.h>\n#include <linux/platform_device.h>\n\n \n#undef START_IN_KERNEL_MODE\n\n#define DRV_VER \"0.7.0\"\n\n \n#define ACERHDF_DEFAULT_TEMP_FANON 60000\n#define ACERHDF_DEFAULT_TEMP_FANOFF 53000\n#define ACERHDF_TEMP_CRIT 89000\n#define ACERHDF_FAN_OFF 0\n#define ACERHDF_FAN_AUTO 1\n\n \n#define ACERHDF_MAX_FANON 80000\n\n \n#define ACERHDF_MAX_INTERVAL 15\n\n#ifdef START_IN_KERNEL_MODE\nstatic int kernelmode = 1;\n#else\nstatic int kernelmode;\n#endif\n\nstatic unsigned int interval = 10;\nstatic unsigned int fanon = ACERHDF_DEFAULT_TEMP_FANON;\nstatic unsigned int fanoff = ACERHDF_DEFAULT_TEMP_FANOFF;\nstatic unsigned int verbose;\nstatic unsigned int list_supported;\nstatic unsigned int fanstate = ACERHDF_FAN_AUTO;\nstatic char force_bios[16];\nstatic char force_product[16];\nstatic struct thermal_zone_device *thz_dev;\nstatic struct thermal_cooling_device *cl_dev;\nstatic struct platform_device *acerhdf_dev;\n\nmodule_param(kernelmode, uint, 0);\nMODULE_PARM_DESC(kernelmode, \"Kernel mode fan control on / off\");\nmodule_param(fanon, uint, 0600);\nMODULE_PARM_DESC(fanon, \"Turn the fan on above this temperature\");\nmodule_param(fanoff, uint, 0600);\nMODULE_PARM_DESC(fanoff, \"Turn the fan off below this temperature\");\nmodule_param(verbose, uint, 0600);\nMODULE_PARM_DESC(verbose, \"Enable verbose dmesg output\");\nmodule_param(list_supported, uint, 0600);\nMODULE_PARM_DESC(list_supported, \"List supported models and BIOS versions\");\nmodule_param_string(force_bios, force_bios, 16, 0);\nMODULE_PARM_DESC(force_bios, \"Pretend system has this known supported BIOS version\");\nmodule_param_string(force_product, force_product, 16, 0);\nMODULE_PARM_DESC(force_product, \"Pretend system is this known supported model\");\n\n \nstruct fancmd {\n\tu8 cmd_off;\n\tu8 cmd_auto;\n};\n\nstruct manualcmd {\n\tu8 mreg;\n\tu8 moff;\n};\n\n \nstatic const struct manualcmd mcmd = {\n\t.mreg = 0x94,\n\t.moff = 0xff,\n};\n\n \nstruct bios_settings {\n\tconst char *vendor;\n\tconst char *product;\n\tconst char *version;\n\tu8 fanreg;\n\tu8 tempreg;\n\tstruct fancmd cmd;\n\tint mcmd_enable;\n};\n\n \nstruct ctrl_settings {\n\tu8 fanreg;\n\tu8 tempreg;\n\tstruct fancmd cmd;\n\tint mcmd_enable;\n};\n\nstatic struct thermal_trip trips[] = {\n\t[0] = { .temperature = ACERHDF_DEFAULT_TEMP_FANON,\n\t\t.hysteresis = ACERHDF_DEFAULT_TEMP_FANON - ACERHDF_DEFAULT_TEMP_FANOFF,\n\t\t.type = THERMAL_TRIP_ACTIVE },\n\n\t[1] = { .temperature = ACERHDF_TEMP_CRIT,\n\t\t.type = THERMAL_TRIP_CRITICAL }\n};\n\nstatic struct ctrl_settings ctrl_cfg __read_mostly;\n\n \nstatic const struct bios_settings bios_tbl[] __initconst = {\n\t \n\t{\"Acer\", \"AOA110\", \"v0.3109\", 0x55, 0x58, {0x1f, 0x00}, 0},\n\t{\"Acer\", \"AOA110\", \"v0.3114\", 0x55, 0x58, {0x1f, 0x00}, 0},\n\t{\"Acer\", \"AOA110\", \"v0.3301\", 0x55, 0x58, {0xaf, 0x00}, 0},\n\t{\"Acer\", \"AOA110\", \"v0.3304\", 0x55, 0x58, {0xaf, 0x00}, 0},\n\t{\"Acer\", \"AOA110\", \"v0.3305\", 0x55, 0x58, {0xaf, 0x00}, 0},\n\t{\"Acer\", \"AOA110\", \"v0.3307\", 0x55, 0x58, {0xaf, 0x00}, 0},\n\t{\"Acer\", \"AOA110\", \"v0.3308\", 0x55, 0x58, {0x21, 0x00}, 0},\n\t{\"Acer\", \"AOA110\", \"v0.3309\", 0x55, 0x58, {0x21, 0x00}, 0},\n\t{\"Acer\", \"AOA110\", \"v0.3310\", 0x55, 0x58, {0x21, 0x00}, 0},\n\t \n\t{\"Acer\", \"AOA150\", \"v0.3114\", 0x55, 0x58, {0x1f, 0x00}, 0},\n\t{\"Acer\", \"AOA150\", \"v0.3301\", 0x55, 0x58, {0x20, 0x00}, 0},\n\t{\"Acer\", \"AOA150\", \"v0.3304\", 0x55, 0x58, {0x20, 0x00}, 0},\n\t{\"Acer\", \"AOA150\", \"v0.3305\", 0x55, 0x58, {0x20, 0x00}, 0},\n\t{\"Acer\", \"AOA150\", \"v0.3307\", 0x55, 0x58, {0x20, 0x00}, 0},\n\t{\"Acer\", \"AOA150\", \"v0.3308\", 0x55, 0x58, {0x20, 0x00}, 0},\n\t{\"Acer\", \"AOA150\", \"v0.3309\", 0x55, 0x58, {0x20, 0x00}, 0},\n\t{\"Acer\", \"AOA150\", \"v0.3310\", 0x55, 0x58, {0x20, 0x00}, 0},\n\t \n\t{\"Acer\", \"LT-10Q\", \"v0.3310\", 0x55, 0x58, {0x20, 0x00}, 0},\n\t \n\t{\"Acer\", \"Aspire 1410\", \"v0.3108\", 0x55, 0x58, {0x9e, 0x00}, 0},\n\t{\"Acer\", \"Aspire 1410\", \"v0.3113\", 0x55, 0x58, {0x9e, 0x00}, 0},\n\t{\"Acer\", \"Aspire 1410\", \"v0.3115\", 0x55, 0x58, {0x9e, 0x00}, 0},\n\t{\"Acer\", \"Aspire 1410\", \"v0.3117\", 0x55, 0x58, {0x9e, 0x00}, 0},\n\t{\"Acer\", \"Aspire 1410\", \"v0.3119\", 0x55, 0x58, {0x9e, 0x00}, 0},\n\t{\"Acer\", \"Aspire 1410\", \"v0.3120\", 0x55, 0x58, {0x9e, 0x00}, 0},\n\t{\"Acer\", \"Aspire 1410\", \"v1.3204\", 0x55, 0x58, {0x9e, 0x00}, 0},\n\t{\"Acer\", \"Aspire 1410\", \"v1.3303\", 0x55, 0x58, {0x9e, 0x00}, 0},\n\t{\"Acer\", \"Aspire 1410\", \"v1.3308\", 0x55, 0x58, {0x9e, 0x00}, 0},\n\t{\"Acer\", \"Aspire 1410\", \"v1.3310\", 0x55, 0x58, {0x9e, 0x00}, 0},\n\t{\"Acer\", \"Aspire 1410\", \"v1.3314\", 0x55, 0x58, {0x9e, 0x00}, 0},\n\t \n\t{\"Acer\", \"Aspire 1810TZ\", \"v0.3108\", 0x55, 0x58, {0x9e, 0x00}, 0},\n\t{\"Acer\", \"Aspire 1810T\",  \"v0.3108\", 0x55, 0x58, {0x9e, 0x00}, 0},\n\t{\"Acer\", \"Aspire 1810TZ\", \"v0.3113\", 0x55, 0x58, {0x9e, 0x00}, 0},\n\t{\"Acer\", \"Aspire 1810T\",  \"v0.3113\", 0x55, 0x58, {0x9e, 0x00}, 0},\n\t{\"Acer\", \"Aspire 1810TZ\", \"v0.3115\", 0x55, 0x58, {0x9e, 0x00}, 0},\n\t{\"Acer\", \"Aspire 1810T\",  \"v0.3115\", 0x55, 0x58, {0x9e, 0x00}, 0},\n\t{\"Acer\", \"Aspire 1810TZ\", \"v0.3117\", 0x55, 0x58, {0x9e, 0x00}, 0},\n\t{\"Acer\", \"Aspire 1810T\",  \"v0.3117\", 0x55, 0x58, {0x9e, 0x00}, 0},\n\t{\"Acer\", \"Aspire 1810TZ\", \"v0.3119\", 0x55, 0x58, {0x9e, 0x00}, 0},\n\t{\"Acer\", \"Aspire 1810T\",  \"v0.3119\", 0x55, 0x58, {0x9e, 0x00}, 0},\n\t{\"Acer\", \"Aspire 1810TZ\", \"v0.3120\", 0x55, 0x58, {0x9e, 0x00}, 0},\n\t{\"Acer\", \"Aspire 1810T\",  \"v0.3120\", 0x55, 0x58, {0x9e, 0x00}, 0},\n\t{\"Acer\", \"Aspire 1810TZ\", \"v1.3204\", 0x55, 0x58, {0x9e, 0x00}, 0},\n\t{\"Acer\", \"Aspire 1810T\",  \"v1.3204\", 0x55, 0x58, {0x9e, 0x00}, 0},\n\t{\"Acer\", \"Aspire 1810TZ\", \"v1.3303\", 0x55, 0x58, {0x9e, 0x00}, 0},\n\t{\"Acer\", \"Aspire 1810T\",  \"v1.3303\", 0x55, 0x58, {0x9e, 0x00}, 0},\n\t{\"Acer\", \"Aspire 1810TZ\", \"v1.3308\", 0x55, 0x58, {0x9e, 0x00}, 0},\n\t{\"Acer\", \"Aspire 1810T\",  \"v1.3308\", 0x55, 0x58, {0x9e, 0x00}, 0},\n\t{\"Acer\", \"Aspire 1810TZ\", \"v1.3310\", 0x55, 0x58, {0x9e, 0x00}, 0},\n\t{\"Acer\", \"Aspire 1810T\",  \"v1.3310\", 0x55, 0x58, {0x9e, 0x00}, 0},\n\t{\"Acer\", \"Aspire 1810TZ\", \"v1.3314\", 0x55, 0x58, {0x9e, 0x00}, 0},\n\t{\"Acer\", \"Aspire 1810T\",  \"v1.3314\", 0x55, 0x58, {0x9e, 0x00}, 0},\n\t \n\t{\"Acer\", \"Aspire 5755G\",  \"V1.20\",   0xab, 0xb4, {0x00, 0x08}, 0},\n\t{\"Acer\", \"Aspire 5755G\",  \"V1.21\",   0xab, 0xb3, {0x00, 0x08}, 0},\n\t \n\t{\"Acer\", \"AO521\", \"V1.11\", 0x55, 0x58, {0x1f, 0x00}, 0},\n\t \n\t{\"Acer\", \"AO531h\", \"v0.3104\", 0x55, 0x58, {0x20, 0x00}, 0},\n\t{\"Acer\", \"AO531h\", \"v0.3201\", 0x55, 0x58, {0x20, 0x00}, 0},\n\t{\"Acer\", \"AO531h\", \"v0.3304\", 0x55, 0x58, {0x20, 0x00}, 0},\n\t \n\t{\"Acer\", \"AO751h\", \"V0.3206\", 0x55, 0x58, {0x21, 0x00}, 0},\n\t{\"Acer\", \"AO751h\", \"V0.3212\", 0x55, 0x58, {0x21, 0x00}, 0},\n\t \n\t{\"Acer\", \"Aspire One 753\", \"V1.24\", 0x93, 0xac, {0x14, 0x04}, 1},\n\t \n\t{\"Acer\", \"Aspire 1825PTZ\", \"V1.3118\", 0x55, 0x58, {0x9e, 0x00}, 0},\n\t{\"Acer\", \"Aspire 1825PTZ\", \"V1.3127\", 0x55, 0x58, {0x9e, 0x00}, 0},\n\t \n\t{\"Acer\", \"Extensa 5420\", \"V1.17\", 0x93, 0xac, {0x14, 0x04}, 1},\n\t \n\t{\"Acer\", \"Aspire 5315\", \"V1.19\", 0x93, 0xac, {0x14, 0x04}, 1},\n\t \n\t{\"Acer\", \"Aspire 5739G\", \"V1.3311\", 0x55, 0x58, {0x20, 0x00}, 0},\n\t \n\t{\"Acer\", \"TravelMate 7730G\", \"v0.3509\", 0x55, 0x58, {0xaf, 0x00}, 0},\n\t \n\t{\"Acer\", \"Aspire 7551\", \"V1.18\", 0x93, 0xa8, {0x14, 0x04}, 1},\n\t \n\t{\"Acer\", \"TM8573T\", \"V1.13\", 0x93, 0xa8, {0x14, 0x04}, 1},\n\t \n\t{\"Gateway\", \"AOA110\", \"v0.3103\",  0x55, 0x58, {0x21, 0x00}, 0},\n\t{\"Gateway\", \"AOA150\", \"v0.3103\",  0x55, 0x58, {0x20, 0x00}, 0},\n\t{\"Gateway\", \"LT31\",   \"v1.3103\",  0x55, 0x58, {0x9e, 0x00}, 0},\n\t{\"Gateway\", \"LT31\",   \"v1.3201\",  0x55, 0x58, {0x9e, 0x00}, 0},\n\t{\"Gateway\", \"LT31\",   \"v1.3302\",  0x55, 0x58, {0x9e, 0x00}, 0},\n\t{\"Gateway\", \"LT31\",   \"v1.3303t\", 0x55, 0x58, {0x9e, 0x00}, 0},\n\t{\"Gateway\", \"LT31\",   \"v1.3307\",  0x55, 0x58, {0x9e, 0x00}, 0},\n\t \n\t{\"Packard Bell\", \"DOA150\",  \"v0.3104\",  0x55, 0x58, {0x21, 0x00}, 0},\n\t{\"Packard Bell\", \"DOA150\",  \"v0.3105\",  0x55, 0x58, {0x20, 0x00}, 0},\n\t{\"Packard Bell\", \"AOA110\",  \"v0.3105\",  0x55, 0x58, {0x21, 0x00}, 0},\n\t{\"Packard Bell\", \"AOA150\",  \"v0.3105\",  0x55, 0x58, {0x20, 0x00}, 0},\n\t{\"Packard Bell\", \"ENBFT\",   \"V1.3118\",  0x55, 0x58, {0x9e, 0x00}, 0},\n\t{\"Packard Bell\", \"ENBFT\",   \"V1.3127\",  0x55, 0x58, {0x9e, 0x00}, 0},\n\t{\"Packard Bell\", \"DOTMU\",   \"v1.3303\",  0x55, 0x58, {0x9e, 0x00}, 0},\n\t{\"Packard Bell\", \"DOTMU\",   \"v0.3120\",  0x55, 0x58, {0x9e, 0x00}, 0},\n\t{\"Packard Bell\", \"DOTMU\",   \"v0.3108\",  0x55, 0x58, {0x9e, 0x00}, 0},\n\t{\"Packard Bell\", \"DOTMU\",   \"v0.3113\",  0x55, 0x58, {0x9e, 0x00}, 0},\n\t{\"Packard Bell\", \"DOTMU\",   \"v0.3115\",  0x55, 0x58, {0x9e, 0x00}, 0},\n\t{\"Packard Bell\", \"DOTMU\",   \"v0.3117\",  0x55, 0x58, {0x9e, 0x00}, 0},\n\t{\"Packard Bell\", \"DOTMU\",   \"v0.3119\",  0x55, 0x58, {0x9e, 0x00}, 0},\n\t{\"Packard Bell\", \"DOTMU\",   \"v1.3204\",  0x55, 0x58, {0x9e, 0x00}, 0},\n\t{\"Packard Bell\", \"DOTMA\",   \"v1.3201\",  0x55, 0x58, {0x9e, 0x00}, 0},\n\t{\"Packard Bell\", \"DOTMA\",   \"v1.3302\",  0x55, 0x58, {0x9e, 0x00}, 0},\n\t{\"Packard Bell\", \"DOTMA\",   \"v1.3303t\", 0x55, 0x58, {0x9e, 0x00}, 0},\n\t{\"Packard Bell\", \"DOTVR46\", \"v1.3308\",  0x55, 0x58, {0x9e, 0x00}, 0},\n\t \n\t{\"\", \"\", \"\", 0, 0, {0, 0}, 0}\n};\n\n \nstatic struct thermal_zone_params acerhdf_zone_params = {\n\t.governor_name = \"bang_bang\",\n};\n\nstatic int acerhdf_get_temp(int *temp)\n{\n\tu8 read_temp;\n\n\tif (ec_read(ctrl_cfg.tempreg, &read_temp))\n\t\treturn -EINVAL;\n\n\t*temp = read_temp * 1000;\n\n\treturn 0;\n}\n\nstatic int acerhdf_get_fanstate(int *state)\n{\n\tu8 fan;\n\n\tif (ec_read(ctrl_cfg.fanreg, &fan))\n\t\treturn -EINVAL;\n\n\tif (fan != ctrl_cfg.cmd.cmd_off)\n\t\t*state = ACERHDF_FAN_AUTO;\n\telse\n\t\t*state = ACERHDF_FAN_OFF;\n\n\treturn 0;\n}\n\nstatic void acerhdf_change_fanstate(int state)\n{\n\tunsigned char cmd;\n\n\tif (verbose)\n\t\tpr_notice(\"fan %s\\n\", state == ACERHDF_FAN_OFF ? \"OFF\" : \"ON\");\n\n\tif ((state != ACERHDF_FAN_OFF) && (state != ACERHDF_FAN_AUTO)) {\n\t\tpr_err(\"invalid fan state %d requested, setting to auto!\\n\",\n\t\t       state);\n\t\tstate = ACERHDF_FAN_AUTO;\n\t}\n\n\tcmd = (state == ACERHDF_FAN_OFF) ? ctrl_cfg.cmd.cmd_off\n\t\t\t\t\t : ctrl_cfg.cmd.cmd_auto;\n\tfanstate = state;\n\n\tec_write(ctrl_cfg.fanreg, cmd);\n\n\tif (ctrl_cfg.mcmd_enable && state == ACERHDF_FAN_OFF) {\n\t\tif (verbose)\n\t\t\tpr_notice(\"turning off fan manually\\n\");\n\t\tec_write(mcmd.mreg, mcmd.moff);\n\t}\n}\n\nstatic void acerhdf_check_param(struct thermal_zone_device *thermal)\n{\n\tif (fanon > ACERHDF_MAX_FANON) {\n\t\tpr_err(\"fanon temperature too high, set to %d\\n\",\n\t\t       ACERHDF_MAX_FANON);\n\t\tfanon = ACERHDF_MAX_FANON;\n\t}\n\n\tif (fanon < fanoff) {\n\t\tpr_err(\"fanoff temperature (%d) is above fanon temperature (%d), clamping to %d\\n\",\n\t\t       fanoff, fanon, fanon);\n\t\tfanoff = fanon;\n\t}\n\n\ttrips[0].temperature = fanon;\n\ttrips[0].hysteresis  = fanon - fanoff;\n\n\tif (kernelmode) {\n\t\tif (interval > ACERHDF_MAX_INTERVAL) {\n\t\t\tpr_err(\"interval too high, set to %d\\n\",\n\t\t\t       ACERHDF_MAX_INTERVAL);\n\t\t\tinterval = ACERHDF_MAX_INTERVAL;\n\t\t}\n\n\t\tif (verbose)\n\t\t\tpr_notice(\"interval changed to: %d\\n\", interval);\n\t}\n}\n\n \nstatic int acerhdf_get_ec_temp(struct thermal_zone_device *thermal, int *t)\n{\n\tint temp, err = 0;\n\n\terr = acerhdf_get_temp(&temp);\n\tif (err)\n\t\treturn err;\n\n\tif (verbose)\n\t\tpr_notice(\"temp %d\\n\", temp);\n\n\t*t = temp;\n\treturn 0;\n}\n\nstatic int acerhdf_bind(struct thermal_zone_device *thermal,\n\t\t\tstruct thermal_cooling_device *cdev)\n{\n\t \n\tif (cdev != cl_dev)\n\t\treturn 0;\n\n\tif (thermal_zone_bind_cooling_device(thermal, 0, cdev,\n\t\t\tTHERMAL_NO_LIMIT, THERMAL_NO_LIMIT,\n\t\t\tTHERMAL_WEIGHT_DEFAULT)) {\n\t\tpr_err(\"error binding cooling dev\\n\");\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int acerhdf_unbind(struct thermal_zone_device *thermal,\n\t\t\t  struct thermal_cooling_device *cdev)\n{\n\tif (cdev != cl_dev)\n\t\treturn 0;\n\n\tif (thermal_zone_unbind_cooling_device(thermal, 0, cdev)) {\n\t\tpr_err(\"error unbinding cooling dev\\n\");\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic inline void acerhdf_revert_to_bios_mode(void)\n{\n\tacerhdf_change_fanstate(ACERHDF_FAN_AUTO);\n\tkernelmode = 0;\n\n\tpr_notice(\"kernel mode fan control OFF\\n\");\n}\nstatic inline void acerhdf_enable_kernelmode(void)\n{\n\tkernelmode = 1;\n\n\tpr_notice(\"kernel mode fan control ON\\n\");\n}\n\n \nstatic int acerhdf_change_mode(struct thermal_zone_device *thermal,\n\t\t\t       enum thermal_device_mode mode)\n{\n\tif (mode == THERMAL_DEVICE_DISABLED && kernelmode)\n\t\tacerhdf_revert_to_bios_mode();\n\telse if (mode == THERMAL_DEVICE_ENABLED && !kernelmode)\n\t\tacerhdf_enable_kernelmode();\n\n\treturn 0;\n}\n\nstatic int acerhdf_get_crit_temp(struct thermal_zone_device *thermal,\n\t\t\t\t int *temperature)\n{\n\t*temperature = ACERHDF_TEMP_CRIT;\n\treturn 0;\n}\n\n \nstatic struct thermal_zone_device_ops acerhdf_dev_ops = {\n\t.bind = acerhdf_bind,\n\t.unbind = acerhdf_unbind,\n\t.get_temp = acerhdf_get_ec_temp,\n\t.change_mode = acerhdf_change_mode,\n\t.get_crit_temp = acerhdf_get_crit_temp,\n};\n\n \nstatic int acerhdf_get_max_state(struct thermal_cooling_device *cdev,\n\t\t\t\t unsigned long *state)\n{\n\t*state = 1;\n\n\treturn 0;\n}\n\nstatic int acerhdf_get_cur_state(struct thermal_cooling_device *cdev,\n\t\t\t\t unsigned long *state)\n{\n\tint err = 0, tmp;\n\n\terr = acerhdf_get_fanstate(&tmp);\n\tif (err)\n\t\treturn err;\n\n\t*state = (tmp == ACERHDF_FAN_AUTO) ? 1 : 0;\n\treturn 0;\n}\n\n \nstatic int acerhdf_set_cur_state(struct thermal_cooling_device *cdev,\n\t\t\t\t unsigned long state)\n{\n\tint cur_temp, cur_state, err = 0;\n\n\tif (!kernelmode)\n\t\treturn 0;\n\n\terr = acerhdf_get_temp(&cur_temp);\n\tif (err) {\n\t\tpr_err(\"error reading temperature, hand off control to BIOS\\n\");\n\t\tgoto err_out;\n\t}\n\n\terr = acerhdf_get_fanstate(&cur_state);\n\tif (err) {\n\t\tpr_err(\"error reading fan state, hand off control to BIOS\\n\");\n\t\tgoto err_out;\n\t}\n\n\tif (state == 0) {\n\t\tif (cur_state == ACERHDF_FAN_AUTO)\n\t\t\tacerhdf_change_fanstate(ACERHDF_FAN_OFF);\n\t} else {\n\t\tif (cur_state == ACERHDF_FAN_OFF)\n\t\t\tacerhdf_change_fanstate(ACERHDF_FAN_AUTO);\n\t}\n\treturn 0;\n\nerr_out:\n\tacerhdf_revert_to_bios_mode();\n\treturn -EINVAL;\n}\n\n \nstatic const struct thermal_cooling_device_ops acerhdf_cooling_ops = {\n\t.get_max_state = acerhdf_get_max_state,\n\t.get_cur_state = acerhdf_get_cur_state,\n\t.set_cur_state = acerhdf_set_cur_state,\n};\n\n \nstatic int acerhdf_suspend(struct device *dev)\n{\n\tif (kernelmode)\n\t\tacerhdf_change_fanstate(ACERHDF_FAN_AUTO);\n\n\tif (verbose)\n\t\tpr_notice(\"going suspend\\n\");\n\n\treturn 0;\n}\n\nstatic int acerhdf_probe(struct platform_device *device)\n{\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops acerhdf_pm_ops = {\n\t.suspend = acerhdf_suspend,\n\t.freeze  = acerhdf_suspend,\n};\n\nstatic struct platform_driver acerhdf_driver = {\n\t.driver = {\n\t\t.name  = \"acerhdf\",\n\t\t.pm    = &acerhdf_pm_ops,\n\t},\n\t.probe = acerhdf_probe,\n};\n\n \nstatic int __init acerhdf_check_hardware(void)\n{\n\tchar const *vendor, *version, *product;\n\tconst struct bios_settings *bt = NULL;\n\tint found = 0;\n\n\t \n\tvendor  = dmi_get_system_info(DMI_SYS_VENDOR);\n\tversion = dmi_get_system_info(DMI_BIOS_VERSION);\n\tproduct = dmi_get_system_info(DMI_PRODUCT_NAME);\n\n\tif (!vendor || !version || !product) {\n\t\tpr_err(\"error getting hardware information\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpr_info(\"Acer Aspire One Fan driver, v.%s\\n\", DRV_VER);\n\n\tif (list_supported) {\n\t\tpr_info(\"List of supported Manufacturer/Model/BIOS:\\n\");\n\t\tpr_info(\"---------------------------------------------------\\n\");\n\t\tfor (bt = bios_tbl; bt->vendor[0]; bt++) {\n\t\t\tpr_info(\"%-13s | %-17s | %-10s\\n\", bt->vendor,\n\t\t\t\tbt->product, bt->version);\n\t\t}\n\t\tpr_info(\"---------------------------------------------------\\n\");\n\t\treturn -ECANCELED;\n\t}\n\n\tif (force_bios[0]) {\n\t\tversion = force_bios;\n\t\tpr_info(\"forcing BIOS version: %s\\n\", version);\n\t\tkernelmode = 0;\n\t}\n\n\tif (force_product[0]) {\n\t\tproduct = force_product;\n\t\tpr_info(\"forcing BIOS product: %s\\n\", product);\n\t\tkernelmode = 0;\n\t}\n\n\tif (verbose)\n\t\tpr_info(\"BIOS info: %s %s, product: %s\\n\",\n\t\t\tvendor, version, product);\n\n\t \n\tfor (bt = bios_tbl; bt->vendor[0]; bt++) {\n\t\t \n\t\tif (strstarts(vendor, bt->vendor) &&\n\t\t    strstarts(product, bt->product) &&\n\t\t    strstarts(version, bt->version)) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!found) {\n\t\tpr_err(\"unknown (unsupported) BIOS version %s/%s/%s, please report, aborting!\\n\",\n\t\t       vendor, product, version);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tctrl_cfg.fanreg = bt->fanreg;\n\tctrl_cfg.tempreg = bt->tempreg;\n\tmemcpy(&ctrl_cfg.cmd, &bt->cmd, sizeof(struct fancmd));\n\tctrl_cfg.mcmd_enable = bt->mcmd_enable;\n\n\t \n\tif (!kernelmode) {\n\t\tpr_notice(\"Fan control off, to enable do:\\n\");\n\t\tpr_notice(\"echo -n \\\"enabled\\\" > /sys/class/thermal/thermal_zoneN/mode # N=0,1,2...\\n\");\n\t}\n\n\treturn 0;\n}\n\nstatic int __init acerhdf_register_platform(void)\n{\n\tint err = 0;\n\n\terr = platform_driver_register(&acerhdf_driver);\n\tif (err)\n\t\treturn err;\n\n\tacerhdf_dev = platform_device_alloc(\"acerhdf\", PLATFORM_DEVID_NONE);\n\tif (!acerhdf_dev) {\n\t\terr = -ENOMEM;\n\t\tgoto err_device_alloc;\n\t}\n\terr = platform_device_add(acerhdf_dev);\n\tif (err)\n\t\tgoto err_device_add;\n\n\treturn 0;\n\nerr_device_add:\n\tplatform_device_put(acerhdf_dev);\nerr_device_alloc:\n\tplatform_driver_unregister(&acerhdf_driver);\n\treturn err;\n}\n\nstatic void acerhdf_unregister_platform(void)\n{\n\tplatform_device_unregister(acerhdf_dev);\n\tplatform_driver_unregister(&acerhdf_driver);\n}\n\nstatic int __init acerhdf_register_thermal(void)\n{\n\tint ret;\n\n\tcl_dev = thermal_cooling_device_register(\"acerhdf-fan\", NULL,\n\t\t\t\t\t\t &acerhdf_cooling_ops);\n\n\tif (IS_ERR(cl_dev))\n\t\treturn -EINVAL;\n\n\tthz_dev = thermal_zone_device_register_with_trips(\"acerhdf\", trips, ARRAY_SIZE(trips),\n\t\t\t\t\t\t\t  0, NULL, &acerhdf_dev_ops,\n\t\t\t\t\t\t\t  &acerhdf_zone_params, 0,\n\t\t\t\t\t\t\t  (kernelmode) ? interval*1000 : 0);\n\tif (IS_ERR(thz_dev))\n\t\treturn -EINVAL;\n\n\tif (kernelmode)\n\t\tret = thermal_zone_device_enable(thz_dev);\n\telse\n\t\tret = thermal_zone_device_disable(thz_dev);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic void acerhdf_unregister_thermal(void)\n{\n\tif (cl_dev) {\n\t\tthermal_cooling_device_unregister(cl_dev);\n\t\tcl_dev = NULL;\n\t}\n\n\tif (thz_dev) {\n\t\tthermal_zone_device_unregister(thz_dev);\n\t\tthz_dev = NULL;\n\t}\n}\n\nstatic int __init acerhdf_init(void)\n{\n\tint err = 0;\n\n\terr = acerhdf_check_hardware();\n\tif (err)\n\t\tgoto out_err;\n\n\terr = acerhdf_register_platform();\n\tif (err)\n\t\tgoto out_err;\n\n\terr = acerhdf_register_thermal();\n\tif (err)\n\t\tgoto err_unreg;\n\n\treturn 0;\n\nerr_unreg:\n\tacerhdf_unregister_thermal();\n\tacerhdf_unregister_platform();\n\nout_err:\n\treturn err;\n}\n\nstatic void __exit acerhdf_exit(void)\n{\n\tacerhdf_change_fanstate(ACERHDF_FAN_AUTO);\n\tacerhdf_unregister_thermal();\n\tacerhdf_unregister_platform();\n}\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Peter Kaestle\");\nMODULE_DESCRIPTION(\"Aspire One temperature and fan driver\");\nMODULE_ALIAS(\"dmi:*:*Acer*:pnAOA*:\");\nMODULE_ALIAS(\"dmi:*:*Acer*:pnAO751h*:\");\nMODULE_ALIAS(\"dmi:*:*Acer*:pnAspire*1410*:\");\nMODULE_ALIAS(\"dmi:*:*Acer*:pnAspire*1810*:\");\nMODULE_ALIAS(\"dmi:*:*Acer*:pnAspire*5755G:\");\nMODULE_ALIAS(\"dmi:*:*Acer*:pnAspire*1825PTZ:\");\nMODULE_ALIAS(\"dmi:*:*Acer*:pnAO521*:\");\nMODULE_ALIAS(\"dmi:*:*Acer*:pnAO531*:\");\nMODULE_ALIAS(\"dmi:*:*Acer*:pnAspire*5739G:\");\nMODULE_ALIAS(\"dmi:*:*Acer*:pnAspire*One*753:\");\nMODULE_ALIAS(\"dmi:*:*Acer*:pnAspire*5315:\");\nMODULE_ALIAS(\"dmi:*:*Acer*:TravelMate*7730G:\");\nMODULE_ALIAS(\"dmi:*:*Acer*:pnAspire*7551:\");\nMODULE_ALIAS(\"dmi:*:*Acer*:TM8573T:\");\nMODULE_ALIAS(\"dmi:*:*Gateway*:pnAOA*:\");\nMODULE_ALIAS(\"dmi:*:*Gateway*:pnLT31*:\");\nMODULE_ALIAS(\"dmi:*:*Packard*Bell*:pnAOA*:\");\nMODULE_ALIAS(\"dmi:*:*Packard*Bell*:pnDOA*:\");\nMODULE_ALIAS(\"dmi:*:*Packard*Bell*:pnDOTMU*:\");\nMODULE_ALIAS(\"dmi:*:*Packard*Bell*:pnENBFT*:\");\nMODULE_ALIAS(\"dmi:*:*Packard*Bell*:pnDOTMA*:\");\nMODULE_ALIAS(\"dmi:*:*Packard*Bell*:pnDOTVR46*:\");\nMODULE_ALIAS(\"dmi:*:*Acer*:pnExtensa*5420*:\");\n\nmodule_init(acerhdf_init);\nmodule_exit(acerhdf_exit);\n\nstatic int interval_set_uint(const char *val, const struct kernel_param *kp)\n{\n\tint ret;\n\n\tret = param_set_uint(val, kp);\n\tif (ret)\n\t\treturn ret;\n\n\tacerhdf_check_param(thz_dev);\n\n\treturn 0;\n}\n\nstatic const struct kernel_param_ops interval_ops = {\n\t.set = interval_set_uint,\n\t.get = param_get_uint,\n};\n\nmodule_param_cb(interval, &interval_ops, &interval, 0000);\nMODULE_PARM_DESC(interval, \"Polling interval of temperature check\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}