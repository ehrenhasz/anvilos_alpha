{
  "module_name": "toshiba_haps.c",
  "hash_id": "7f6995bafa1eeaae6ab299f5e7bb4ee032d05e276acc27cb1276a445944c72cc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/x86/toshiba_haps.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/types.h>\n#include <linux/acpi.h>\n\nMODULE_AUTHOR(\"Azael Avalos <coproscefalo@gmail.com>\");\nMODULE_DESCRIPTION(\"Toshiba HDD Active Protection Sensor\");\nMODULE_LICENSE(\"GPL\");\n\nstruct toshiba_haps_dev {\n\tstruct acpi_device *acpi_dev;\n\n\tint protection_level;\n};\n\nstatic struct toshiba_haps_dev *toshiba_haps;\n\n \nstatic int toshiba_haps_reset_protection(acpi_handle handle)\n{\n\tacpi_status status;\n\n\tstatus = acpi_evaluate_object(handle, \"RSSS\", NULL, NULL);\n\tif (ACPI_FAILURE(status)) {\n\t\tpr_err(\"Unable to reset the HDD protection\\n\");\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int toshiba_haps_protection_level(acpi_handle handle, int level)\n{\n\tacpi_status status;\n\n\tstatus = acpi_execute_simple_method(handle, \"PTLV\", level);\n\tif (ACPI_FAILURE(status)) {\n\t\tpr_err(\"Error while setting the protection level\\n\");\n\t\treturn -EIO;\n\t}\n\n\tpr_debug(\"HDD protection level set to: %d\\n\", level);\n\n\treturn 0;\n}\n\n \nstatic ssize_t protection_level_show(struct device *dev,\n\t\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct toshiba_haps_dev *haps = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%i\\n\", haps->protection_level);\n}\n\nstatic ssize_t protection_level_store(struct device *dev,\n\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t      const char *buf, size_t count)\n{\n\tstruct toshiba_haps_dev *haps = dev_get_drvdata(dev);\n\tint level;\n\tint ret;\n\n\tret = kstrtoint(buf, 0, &level);\n\tif (ret)\n\t\treturn ret;\n\t \n\tif (level < 0 || level > 3)\n\t\treturn -EINVAL;\n\n\t \n\tret = toshiba_haps_protection_level(haps->acpi_dev->handle, level);\n\tif (ret != 0)\n\t\treturn ret;\n\n\thaps->protection_level = level;\n\n\treturn count;\n}\nstatic DEVICE_ATTR_RW(protection_level);\n\nstatic ssize_t reset_protection_store(struct device *dev,\n\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t      const char *buf, size_t count)\n{\n\tstruct toshiba_haps_dev *haps = dev_get_drvdata(dev);\n\tint reset;\n\tint ret;\n\n\tret = kstrtoint(buf, 0, &reset);\n\tif (ret)\n\t\treturn ret;\n\t \n\tif (reset != 1)\n\t\treturn -EINVAL;\n\n\t \n\tret = toshiba_haps_reset_protection(haps->acpi_dev->handle);\n\tif (ret != 0)\n\t\treturn ret;\n\n\treturn count;\n}\nstatic DEVICE_ATTR_WO(reset_protection);\n\nstatic struct attribute *haps_attributes[] = {\n\t&dev_attr_protection_level.attr,\n\t&dev_attr_reset_protection.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group haps_attr_group = {\n\t.attrs = haps_attributes,\n};\n\n \nstatic void toshiba_haps_notify(struct acpi_device *device, u32 event)\n{\n\tpr_debug(\"Received event: 0x%x\\n\", event);\n\n\tacpi_bus_generate_netlink_event(device->pnp.device_class,\n\t\t\t\t\tdev_name(&device->dev),\n\t\t\t\t\tevent, 0);\n}\n\nstatic void toshiba_haps_remove(struct acpi_device *device)\n{\n\tsysfs_remove_group(&device->dev.kobj, &haps_attr_group);\n\n\tif (toshiba_haps)\n\t\ttoshiba_haps = NULL;\n}\n\n \nstatic int toshiba_haps_available(acpi_handle handle)\n{\n\tacpi_status status;\n\tu64 hdd_present;\n\n\t \n\tstatus = acpi_evaluate_integer(handle, \"_STA\", NULL, &hdd_present);\n\tif (ACPI_FAILURE(status)) {\n\t\tpr_err(\"ACPI call to query HDD protection failed\\n\");\n\t\treturn 0;\n\t}\n\n\tif (!hdd_present) {\n\t\tpr_info(\"HDD protection not available or using SSD\\n\");\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic int toshiba_haps_add(struct acpi_device *acpi_dev)\n{\n\tstruct toshiba_haps_dev *haps;\n\tint ret;\n\n\tif (toshiba_haps)\n\t\treturn -EBUSY;\n\n\tif (!toshiba_haps_available(acpi_dev->handle))\n\t\treturn -ENODEV;\n\n\tpr_info(\"Toshiba HDD Active Protection Sensor device\\n\");\n\n\thaps = kzalloc(sizeof(struct toshiba_haps_dev), GFP_KERNEL);\n\tif (!haps)\n\t\treturn -ENOMEM;\n\n\thaps->acpi_dev = acpi_dev;\n\thaps->protection_level = 2;\n\tacpi_dev->driver_data = haps;\n\tdev_set_drvdata(&acpi_dev->dev, haps);\n\n\t \n\tret = toshiba_haps_protection_level(acpi_dev->handle, 2);\n\tif (ret != 0)\n\t\treturn ret;\n\n\tret = sysfs_create_group(&acpi_dev->dev.kobj, &haps_attr_group);\n\tif (ret)\n\t\treturn ret;\n\n\ttoshiba_haps = haps;\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int toshiba_haps_suspend(struct device *device)\n{\n\tstruct toshiba_haps_dev *haps;\n\tint ret;\n\n\thaps = acpi_driver_data(to_acpi_device(device));\n\n\t \n\tret = toshiba_haps_protection_level(haps->acpi_dev->handle, 0);\n\n\treturn ret;\n}\n\nstatic int toshiba_haps_resume(struct device *device)\n{\n\tstruct toshiba_haps_dev *haps;\n\tint ret;\n\n\thaps = acpi_driver_data(to_acpi_device(device));\n\n\t \n\tret = toshiba_haps_protection_level(haps->acpi_dev->handle,\n\t\t\t\t\t    haps->protection_level);\n\n\t \n\tret = toshiba_haps_reset_protection(haps->acpi_dev->handle);\n\tif (ret != 0)\n\t\treturn ret;\n\n\treturn ret;\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(toshiba_haps_pm,\n\t\t\t toshiba_haps_suspend, toshiba_haps_resume);\n\nstatic const struct acpi_device_id haps_device_ids[] = {\n\t{\"TOS620A\", 0},\n\t{\"\", 0},\n};\nMODULE_DEVICE_TABLE(acpi, haps_device_ids);\n\nstatic struct acpi_driver toshiba_haps_driver = {\n\t.name = \"Toshiba HAPS\",\n\t.owner = THIS_MODULE,\n\t.ids = haps_device_ids,\n\t.flags = ACPI_DRIVER_ALL_NOTIFY_EVENTS,\n\t.ops = {\n\t\t.add =\t\ttoshiba_haps_add,\n\t\t.remove =\ttoshiba_haps_remove,\n\t\t.notify =\ttoshiba_haps_notify,\n\t},\n\t.drv.pm = &toshiba_haps_pm,\n};\n\nmodule_acpi_driver(toshiba_haps_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}