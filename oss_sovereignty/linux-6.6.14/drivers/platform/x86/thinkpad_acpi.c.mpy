{
  "module_name": "thinkpad_acpi.c",
  "hash_id": "63876d3445c62d5e44bbb11094535c85fb3f877b4a186a4dd26a70c656aa2b84",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/x86/thinkpad_acpi.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#define TPACPI_VERSION \"0.26\"\n#define TPACPI_SYSFS_VERSION 0x030000\n\n \n\n#include <linux/acpi.h>\n#include <linux/backlight.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/dmi.h>\n#include <linux/fb.h>\n#include <linux/freezer.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/init.h>\n#include <linux/input.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/leds.h>\n#include <linux/list.h>\n#include <linux/lockdep.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/nvram.h>\n#include <linux/pci.h>\n#include <linux/platform_device.h>\n#include <linux/platform_profile.h>\n#include <linux/power_supply.h>\n#include <linux/proc_fs.h>\n#include <linux/rfkill.h>\n#include <linux/sched.h>\n#include <linux/sched/signal.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/string_helpers.h>\n#include <linux/sysfs.h>\n#include <linux/types.h>\n#include <linux/uaccess.h>\n#include <linux/workqueue.h>\n\n#include <acpi/battery.h>\n#include <acpi/video.h>\n\n#include <drm/drm_privacy_screen_driver.h>\n\n#include <sound/control.h>\n#include <sound/core.h>\n#include <sound/initval.h>\n\n#include \"dual_accel_detect.h\"\n\n \n#define TP_CMOS_VOLUME_DOWN\t0\n#define TP_CMOS_VOLUME_UP\t1\n#define TP_CMOS_VOLUME_MUTE\t2\n#define TP_CMOS_BRIGHTNESS_UP\t4\n#define TP_CMOS_BRIGHTNESS_DOWN\t5\n#define TP_CMOS_THINKLIGHT_ON\t12\n#define TP_CMOS_THINKLIGHT_OFF\t13\n\n \nenum tp_nvram_addr {\n\tTP_NVRAM_ADDR_HK2\t\t= 0x57,\n\tTP_NVRAM_ADDR_THINKLIGHT\t= 0x58,\n\tTP_NVRAM_ADDR_VIDEO\t\t= 0x59,\n\tTP_NVRAM_ADDR_BRIGHTNESS\t= 0x5e,\n\tTP_NVRAM_ADDR_MIXER\t\t= 0x60,\n};\n\n \nenum {\n\tTP_NVRAM_MASK_HKT_THINKPAD\t= 0x08,\n\tTP_NVRAM_MASK_HKT_ZOOM\t\t= 0x20,\n\tTP_NVRAM_MASK_HKT_DISPLAY\t= 0x40,\n\tTP_NVRAM_MASK_HKT_HIBERNATE\t= 0x80,\n\tTP_NVRAM_MASK_THINKLIGHT\t= 0x10,\n\tTP_NVRAM_MASK_HKT_DISPEXPND\t= 0x30,\n\tTP_NVRAM_MASK_HKT_BRIGHTNESS\t= 0x20,\n\tTP_NVRAM_MASK_LEVEL_BRIGHTNESS\t= 0x0f,\n\tTP_NVRAM_POS_LEVEL_BRIGHTNESS\t= 0,\n\tTP_NVRAM_MASK_MUTE\t\t= 0x40,\n\tTP_NVRAM_MASK_HKT_VOLUME\t= 0x80,\n\tTP_NVRAM_MASK_LEVEL_VOLUME\t= 0x0f,\n\tTP_NVRAM_POS_LEVEL_VOLUME\t= 0,\n};\n\n \nenum {\n\tTP_NVRAM_LEVEL_VOLUME_MAX = 14,\n};\n\n \n#define TPACPI_ACPI_IBM_HKEY_HID\t\"IBM0068\"\n#define TPACPI_ACPI_LENOVO_HKEY_HID\t\"LEN0068\"\n#define TPACPI_ACPI_LENOVO_HKEY_V2_HID\t\"LEN0268\"\n#define TPACPI_ACPI_EC_HID\t\t\"PNP0C09\"\n\n \n#define TPACPI_HKEY_INPUT_PRODUCT\t0x5054  \n#define TPACPI_HKEY_INPUT_VERSION\t0x4101\n\n \nenum {\n\tTP_ACPI_WGSV_GET_STATE\t\t= 0x01,  \n\tTP_ACPI_WGSV_PWR_ON_ON_RESUME\t= 0x02,  \n\tTP_ACPI_WGSV_PWR_OFF_ON_RESUME\t= 0x03,\t \n\tTP_ACPI_WGSV_SAVE_STATE\t\t= 0x04,  \n};\n\n \nenum {\n\tTP_ACPI_WGSV_STATE_WWANEXIST\t= 0x0001,  \n\tTP_ACPI_WGSV_STATE_WWANPWR\t= 0x0002,  \n\tTP_ACPI_WGSV_STATE_WWANPWRRES\t= 0x0004,  \n\tTP_ACPI_WGSV_STATE_WWANBIOSOFF\t= 0x0008,  \n\tTP_ACPI_WGSV_STATE_BLTHEXIST\t= 0x0001,  \n\tTP_ACPI_WGSV_STATE_BLTHPWR\t= 0x0002,  \n\tTP_ACPI_WGSV_STATE_BLTHPWRRES\t= 0x0004,  \n\tTP_ACPI_WGSV_STATE_BLTHBIOSOFF\t= 0x0008,  \n\tTP_ACPI_WGSV_STATE_UWBEXIST\t= 0x0010,  \n\tTP_ACPI_WGSV_STATE_UWBPWR\t= 0x0020,  \n};\n\n \nenum tpacpi_hkey_event_t {\n\t \n\tTP_HKEY_EV_HOTKEY_BASE\t\t= 0x1001,  \n\tTP_HKEY_EV_BRGHT_UP\t\t= 0x1010,  \n\tTP_HKEY_EV_BRGHT_DOWN\t\t= 0x1011,  \n\tTP_HKEY_EV_KBD_LIGHT\t\t= 0x1012,  \n\tTP_HKEY_EV_VOL_UP\t\t= 0x1015,  \n\tTP_HKEY_EV_VOL_DOWN\t\t= 0x1016,  \n\tTP_HKEY_EV_VOL_MUTE\t\t= 0x1017,  \n\tTP_HKEY_EV_PRIVACYGUARD_TOGGLE\t= 0x130f,  \n\tTP_HKEY_EV_AMT_TOGGLE\t\t= 0x131a,  \n\n\t \n\tTP_HKEY_EV_WKUP_S3_UNDOCK\t= 0x2304,  \n\tTP_HKEY_EV_WKUP_S4_UNDOCK\t= 0x2404,  \n\tTP_HKEY_EV_WKUP_S3_BAYEJ\t= 0x2305,  \n\tTP_HKEY_EV_WKUP_S4_BAYEJ\t= 0x2405,  \n\tTP_HKEY_EV_WKUP_S3_BATLOW\t= 0x2313,  \n\tTP_HKEY_EV_WKUP_S4_BATLOW\t= 0x2413,  \n\n\t \n\tTP_HKEY_EV_BAYEJ_ACK\t\t= 0x3003,  \n\tTP_HKEY_EV_UNDOCK_ACK\t\t= 0x4003,  \n\n\t \n\tTP_HKEY_EV_OPTDRV_EJ\t\t= 0x3006,  \n\tTP_HKEY_EV_HOTPLUG_DOCK\t\t= 0x4010,  \n\tTP_HKEY_EV_HOTPLUG_UNDOCK\t= 0x4011,  \n\t \n\tTP_HKEY_EV_KBD_COVER_ATTACH\t= 0x4012,  \n\tTP_HKEY_EV_KBD_COVER_DETACH\t= 0x4013,  \n\n\t \n\tTP_HKEY_EV_LID_CLOSE\t\t= 0x5001,  \n\tTP_HKEY_EV_LID_OPEN\t\t= 0x5002,  \n\tTP_HKEY_EV_TABLET_TABLET\t= 0x5009,  \n\tTP_HKEY_EV_TABLET_NOTEBOOK\t= 0x500a,  \n\tTP_HKEY_EV_TABLET_CHANGED\t= 0x60c0,  \n\tTP_HKEY_EV_PEN_INSERTED\t\t= 0x500b,  \n\tTP_HKEY_EV_PEN_REMOVED\t\t= 0x500c,  \n\tTP_HKEY_EV_BRGHT_CHANGED\t= 0x5010,  \n\n\t \n\tTP_HKEY_EV_KEY_NUMLOCK\t\t= 0x6000,  \n\tTP_HKEY_EV_KEY_FN\t\t= 0x6005,  \n\tTP_HKEY_EV_KEY_FN_ESC           = 0x6060,  \n\n\t \n\tTP_HKEY_EV_ALARM_BAT_HOT\t= 0x6011,  \n\tTP_HKEY_EV_ALARM_BAT_XHOT\t= 0x6012,  \n\tTP_HKEY_EV_ALARM_SENSOR_HOT\t= 0x6021,  \n\tTP_HKEY_EV_ALARM_SENSOR_XHOT\t= 0x6022,  \n\tTP_HKEY_EV_THM_TABLE_CHANGED\t= 0x6030,  \n\tTP_HKEY_EV_THM_CSM_COMPLETED    = 0x6032,  \n\tTP_HKEY_EV_THM_TRANSFM_CHANGED  = 0x60F0,  \n\n\t \n\tTP_HKEY_EV_AC_CHANGED\t\t= 0x6040,  \n\n\t \n\tTP_HKEY_EV_PALM_DETECTED\t= 0x60b0,  \n\tTP_HKEY_EV_PALM_UNDETECTED\t= 0x60b1,  \n\n\t \n\tTP_HKEY_EV_RFKILL_CHANGED\t= 0x7000,  \n};\n\n \n\n#define TPACPI_NAME \"thinkpad\"\n#define TPACPI_DESC \"ThinkPad ACPI Extras\"\n#define TPACPI_FILE TPACPI_NAME \"_acpi\"\n#define TPACPI_URL \"http://ibm-acpi.sf.net/\"\n#define TPACPI_MAIL \"ibm-acpi-devel@lists.sourceforge.net\"\n\n#define TPACPI_PROC_DIR \"ibm\"\n#define TPACPI_ACPI_EVENT_PREFIX \"ibm\"\n#define TPACPI_DRVR_NAME TPACPI_FILE\n#define TPACPI_DRVR_SHORTNAME \"tpacpi\"\n#define TPACPI_HWMON_DRVR_NAME TPACPI_NAME \"_hwmon\"\n\n#define TPACPI_NVRAM_KTHREAD_NAME \"ktpacpi_nvramd\"\n#define TPACPI_WORKQUEUE_NAME \"ktpacpid\"\n\n#define TPACPI_MAX_ACPI_ARGS 3\n\n \n#define TPACPI_DBG_ALL\t\t0xffff\n#define TPACPI_DBG_DISCLOSETASK\t0x8000\n#define TPACPI_DBG_INIT\t\t0x0001\n#define TPACPI_DBG_EXIT\t\t0x0002\n#define TPACPI_DBG_RFKILL\t0x0004\n#define TPACPI_DBG_HKEY\t\t0x0008\n#define TPACPI_DBG_FAN\t\t0x0010\n#define TPACPI_DBG_BRGHT\t0x0020\n#define TPACPI_DBG_MIXER\t0x0040\n\n#define FAN_NOT_PRESENT\t\t65535\n\n \n\nstruct ibm_struct;\n\nstruct tp_acpi_drv_struct {\n\tconst struct acpi_device_id *hid;\n\tstruct acpi_driver *driver;\n\n\tvoid (*notify) (struct ibm_struct *, u32);\n\tacpi_handle *handle;\n\tu32 type;\n\tstruct acpi_device *device;\n};\n\nstruct ibm_struct {\n\tchar *name;\n\n\tint (*read) (struct seq_file *);\n\tint (*write) (char *);\n\tvoid (*exit) (void);\n\tvoid (*resume) (void);\n\tvoid (*suspend) (void);\n\tvoid (*shutdown) (void);\n\n\tstruct list_head all_drivers;\n\n\tstruct tp_acpi_drv_struct *acpi;\n\n\tstruct {\n\t\tu8 acpi_driver_registered:1;\n\t\tu8 acpi_notify_installed:1;\n\t\tu8 proc_created:1;\n\t\tu8 init_called:1;\n\t\tu8 experimental:1;\n\t} flags;\n};\n\nstruct ibm_init_struct {\n\tchar param[32];\n\n\tint (*init) (struct ibm_init_struct *);\n\tumode_t base_procfs_mode;\n\tstruct ibm_struct *data;\n};\n\n \nstruct quirk_entry {\n\tbool btusb_bug;\n};\n\nstatic struct quirk_entry quirk_btusb_bug = {\n\t.btusb_bug = true,\n};\n\nstatic struct {\n\tu32 bluetooth:1;\n\tu32 hotkey:1;\n\tu32 hotkey_mask:1;\n\tu32 hotkey_wlsw:1;\n\tenum {\n\t\tTP_HOTKEY_TABLET_NONE = 0,\n\t\tTP_HOTKEY_TABLET_USES_MHKG,\n\t\tTP_HOTKEY_TABLET_USES_GMMS,\n\t} hotkey_tablet;\n\tu32 kbdlight:1;\n\tu32 light:1;\n\tu32 light_status:1;\n\tu32 bright_acpimode:1;\n\tu32 bright_unkfw:1;\n\tu32 wan:1;\n\tu32 uwb:1;\n\tu32 fan_ctrl_status_undef:1;\n\tu32 second_fan:1;\n\tu32 second_fan_ctl:1;\n\tu32 beep_needs_two_args:1;\n\tu32 mixer_no_level_control:1;\n\tu32 battery_force_primary:1;\n\tu32 input_device_registered:1;\n\tu32 platform_drv_registered:1;\n\tu32 sensors_pdrv_registered:1;\n\tu32 hotkey_poll_active:1;\n\tu32 has_adaptive_kbd:1;\n\tu32 kbd_lang:1;\n\tstruct quirk_entry *quirks;\n} tp_features;\n\nstatic struct {\n\tu16 hotkey_mask_ff:1;\n\tu16 volume_ctrl_forbidden:1;\n} tp_warned;\n\nstruct thinkpad_id_data {\n\tunsigned int vendor;\t \n\n\tchar *bios_version_str;\t \n\tchar *ec_version_str;\t \n\n\tu32 bios_model;\t\t \n\tu32 ec_model;\n\tu16 bios_release;\t \n\tu16 ec_release;\n\n\tchar *model_str;\t \n\tchar *nummodel_str;\t \n};\nstatic struct thinkpad_id_data thinkpad_id;\n\nstatic enum {\n\tTPACPI_LIFE_INIT = 0,\n\tTPACPI_LIFE_RUNNING,\n\tTPACPI_LIFE_EXITING,\n} tpacpi_lifecycle;\n\nstatic int experimental;\nstatic u32 dbg_level;\n\nstatic struct workqueue_struct *tpacpi_wq;\n\nenum led_status_t {\n\tTPACPI_LED_OFF = 0,\n\tTPACPI_LED_ON,\n\tTPACPI_LED_BLINK,\n};\n\n \nstruct tpacpi_led_classdev {\n\tstruct led_classdev led_classdev;\n\tint led;\n};\n\n \nstatic unsigned int bright_maxlvl;\t \n\n#ifdef CONFIG_THINKPAD_ACPI_DEBUGFACILITIES\nstatic int dbg_wlswemul;\nstatic bool tpacpi_wlsw_emulstate;\nstatic int dbg_bluetoothemul;\nstatic bool tpacpi_bluetooth_emulstate;\nstatic int dbg_wwanemul;\nstatic bool tpacpi_wwan_emulstate;\nstatic int dbg_uwbemul;\nstatic bool tpacpi_uwb_emulstate;\n#endif\n\n\n \n\n#define dbg_printk(a_dbg_level, format, arg...)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tif (dbg_level & (a_dbg_level))\t\t\t\t\t\\\n\t\tprintk(KERN_DEBUG pr_fmt(\"%s: \" format),\t\t\\\n\t\t       __func__, ##arg);\t\t\t\t\\\n} while (0)\n\n#ifdef CONFIG_THINKPAD_ACPI_DEBUG\n#define vdbg_printk dbg_printk\nstatic const char *str_supported(int is_supported);\n#else\nstatic inline const char *str_supported(int is_supported) { return \"\"; }\n#define vdbg_printk(a_dbg_level, format, arg...)\t\\\n\tdo { if (0) no_printk(format, ##arg); } while (0)\n#endif\n\nstatic void tpacpi_log_usertask(const char * const what)\n{\n\tprintk(KERN_DEBUG pr_fmt(\"%s: access by process with PID %d\\n\"),\n\t       what, task_tgid_vnr(current));\n}\n\n#define tpacpi_disclose_usertask(what, format, arg...)\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tif (unlikely((dbg_level & TPACPI_DBG_DISCLOSETASK) &&\t\t\\\n\t\t     (tpacpi_lifecycle == TPACPI_LIFE_RUNNING))) {\t\\\n\t\tprintk(KERN_DEBUG pr_fmt(\"%s: PID %d: \" format),\t\\\n\t\t       what, task_tgid_vnr(current), ## arg);\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n} while (0)\n\n \n\n#define TPACPI_MATCH_ANY\t\t0xffffffffU\n#define TPACPI_MATCH_ANY_VERSION\t0xffffU\n#define TPACPI_MATCH_UNKNOWN\t\t0U\n\n \n#define TPID(__c1, __c2)\t(((__c1) << 8) | (__c2))\n#define TPID3(__c1, __c2, __c3)\t(((__c1) << 16) | ((__c2) << 8) | (__c3))\n#define TPVER TPID\n\n#define TPACPI_Q_IBM(__id1, __id2, __quirk)\t\\\n\t{ .vendor = PCI_VENDOR_ID_IBM,\t\t\\\n\t  .bios = TPID(__id1, __id2),\t\t\\\n\t  .ec = TPACPI_MATCH_ANY,\t\t\\\n\t  .quirks = (__quirk) }\n\n#define TPACPI_Q_LNV(__id1, __id2, __quirk)\t\\\n\t{ .vendor = PCI_VENDOR_ID_LENOVO,\t\\\n\t  .bios = TPID(__id1, __id2),\t\t\\\n\t  .ec = TPACPI_MATCH_ANY,\t\t\\\n\t  .quirks = (__quirk) }\n\n#define TPACPI_Q_LNV3(__id1, __id2, __id3, __quirk) \\\n\t{ .vendor = PCI_VENDOR_ID_LENOVO,\t\\\n\t  .bios = TPID3(__id1, __id2, __id3),\t\\\n\t  .ec = TPACPI_MATCH_ANY,\t\t\\\n\t  .quirks = (__quirk) }\n\n#define TPACPI_QEC_IBM(__id1, __id2, __quirk)\t\\\n\t{ .vendor = PCI_VENDOR_ID_IBM,\t\t\\\n\t  .bios = TPACPI_MATCH_ANY,\t\t\\\n\t  .ec = TPID(__id1, __id2),\t\t\\\n\t  .quirks = (__quirk) }\n\n#define TPACPI_QEC_LNV(__id1, __id2, __quirk)\t\\\n\t{ .vendor = PCI_VENDOR_ID_LENOVO,\t\\\n\t  .bios = TPACPI_MATCH_ANY,\t\t\\\n\t  .ec = TPID(__id1, __id2),\t\t\\\n\t  .quirks = (__quirk) }\n\nstruct tpacpi_quirk {\n\tunsigned int vendor;\n\tu32 bios;\n\tu32 ec;\n\tunsigned long quirks;\n};\n\n \nstatic unsigned long __init tpacpi_check_quirks(\n\t\t\tconst struct tpacpi_quirk *qlist,\n\t\t\tunsigned int qlist_size)\n{\n\twhile (qlist_size) {\n\t\tif ((qlist->vendor == thinkpad_id.vendor ||\n\t\t\t\tqlist->vendor == TPACPI_MATCH_ANY) &&\n\t\t    (qlist->bios == thinkpad_id.bios_model ||\n\t\t\t\tqlist->bios == TPACPI_MATCH_ANY) &&\n\t\t    (qlist->ec == thinkpad_id.ec_model ||\n\t\t\t\tqlist->ec == TPACPI_MATCH_ANY))\n\t\t\treturn qlist->quirks;\n\n\t\tqlist_size--;\n\t\tqlist++;\n\t}\n\treturn 0;\n}\n\nstatic inline bool __pure __init tpacpi_is_lenovo(void)\n{\n\treturn thinkpad_id.vendor == PCI_VENDOR_ID_LENOVO;\n}\n\nstatic inline bool __pure __init tpacpi_is_ibm(void)\n{\n\treturn thinkpad_id.vendor == PCI_VENDOR_ID_IBM;\n}\n\n \n\n \n\nstatic acpi_handle root_handle;\nstatic acpi_handle ec_handle;\n\n#define TPACPI_HANDLE(object, parent, paths...)\t\t\t\\\n\tstatic acpi_handle  object##_handle;\t\t\t\\\n\tstatic const acpi_handle * const object##_parent __initconst =\t\\\n\t\t\t\t\t\t&parent##_handle; \\\n\tstatic char *object##_paths[] __initdata = { paths }\n\nTPACPI_HANDLE(ecrd, ec, \"ECRD\");\t \nTPACPI_HANDLE(ecwr, ec, \"ECWR\");\t \n\nTPACPI_HANDLE(cmos, root, \"\\\\UCMS\",\t \n\t\t\t\t\t \n\t   \"\\\\CMOS\",\t\t \n\t   \"\\\\CMS\",\t\t \n\t   );\t\t\t \n\nTPACPI_HANDLE(hkey, ec, \"\\\\_SB.HKEY\",\t \n\t   \"^HKEY\",\t\t \n\t   \"HKEY\",\t\t \n\t   );\t\t\t \n\n \n\nstatic int acpi_evalf(acpi_handle handle,\n\t\t      int *res, char *method, char *fmt, ...)\n{\n\tchar *fmt0 = fmt;\n\tstruct acpi_object_list params;\n\tunion acpi_object in_objs[TPACPI_MAX_ACPI_ARGS];\n\tstruct acpi_buffer result, *resultp;\n\tunion acpi_object out_obj;\n\tacpi_status status;\n\tva_list ap;\n\tchar res_type;\n\tint success;\n\tint quiet;\n\n\tif (!*fmt) {\n\t\tpr_err(\"acpi_evalf() called with empty format\\n\");\n\t\treturn 0;\n\t}\n\n\tif (*fmt == 'q') {\n\t\tquiet = 1;\n\t\tfmt++;\n\t} else\n\t\tquiet = 0;\n\n\tres_type = *(fmt++);\n\n\tparams.count = 0;\n\tparams.pointer = &in_objs[0];\n\n\tva_start(ap, fmt);\n\twhile (*fmt) {\n\t\tchar c = *(fmt++);\n\t\tswitch (c) {\n\t\tcase 'd':\t \n\t\t\tin_objs[params.count].integer.value = va_arg(ap, int);\n\t\t\tin_objs[params.count++].type = ACPI_TYPE_INTEGER;\n\t\t\tbreak;\n\t\t\t \n\t\tdefault:\n\t\t\tpr_err(\"acpi_evalf() called with invalid format character '%c'\\n\",\n\t\t\t       c);\n\t\t\tva_end(ap);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tva_end(ap);\n\n\tif (res_type != 'v') {\n\t\tresult.length = sizeof(out_obj);\n\t\tresult.pointer = &out_obj;\n\t\tresultp = &result;\n\t} else\n\t\tresultp = NULL;\n\n\tstatus = acpi_evaluate_object(handle, method, &params, resultp);\n\n\tswitch (res_type) {\n\tcase 'd':\t\t \n\t\tsuccess = (status == AE_OK &&\n\t\t\t   out_obj.type == ACPI_TYPE_INTEGER);\n\t\tif (success && res)\n\t\t\t*res = out_obj.integer.value;\n\t\tbreak;\n\tcase 'v':\t\t \n\t\tsuccess = status == AE_OK;\n\t\tbreak;\n\t\t \n\tdefault:\n\t\tpr_err(\"acpi_evalf() called with invalid format character '%c'\\n\",\n\t\t       res_type);\n\t\treturn 0;\n\t}\n\n\tif (!success && !quiet)\n\t\tpr_err(\"acpi_evalf(%s, %s, ...) failed: %s\\n\",\n\t\t       method, fmt0, acpi_format_exception(status));\n\n\treturn success;\n}\n\nstatic int acpi_ec_read(int i, u8 *p)\n{\n\tint v;\n\n\tif (ecrd_handle) {\n\t\tif (!acpi_evalf(ecrd_handle, &v, NULL, \"dd\", i))\n\t\t\treturn 0;\n\t\t*p = v;\n\t} else {\n\t\tif (ec_read(i, p) < 0)\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic int acpi_ec_write(int i, u8 v)\n{\n\tif (ecwr_handle) {\n\t\tif (!acpi_evalf(ecwr_handle, NULL, NULL, \"vdd\", i, v))\n\t\t\treturn 0;\n\t} else {\n\t\tif (ec_write(i, v) < 0)\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic int issue_thinkpad_cmos_command(int cmos_cmd)\n{\n\tif (!cmos_handle)\n\t\treturn -ENXIO;\n\n\tif (!acpi_evalf(cmos_handle, NULL, NULL, \"vd\", cmos_cmd))\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\n \n\n#define TPACPI_ACPIHANDLE_INIT(object) \\\n\tdrv_acpi_handle_init(#object, &object##_handle, *object##_parent, \\\n\t\tobject##_paths, ARRAY_SIZE(object##_paths))\n\nstatic void __init drv_acpi_handle_init(const char *name,\n\t\t\t   acpi_handle *handle, const acpi_handle parent,\n\t\t\t   char **paths, const int num_paths)\n{\n\tint i;\n\tacpi_status status;\n\n\tvdbg_printk(TPACPI_DBG_INIT, \"trying to locate ACPI handle for %s\\n\",\n\t\tname);\n\n\tfor (i = 0; i < num_paths; i++) {\n\t\tstatus = acpi_get_handle(parent, paths[i], handle);\n\t\tif (ACPI_SUCCESS(status)) {\n\t\t\tdbg_printk(TPACPI_DBG_INIT,\n\t\t\t\t   \"Found ACPI handle %s for %s\\n\",\n\t\t\t\t   paths[i], name);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tvdbg_printk(TPACPI_DBG_INIT, \"ACPI handle for %s not found\\n\",\n\t\t    name);\n\t*handle = NULL;\n}\n\nstatic acpi_status __init tpacpi_acpi_handle_locate_callback(acpi_handle handle,\n\t\t\tu32 level, void *context, void **return_value)\n{\n\tif (!strcmp(context, \"video\")) {\n\t\tstruct acpi_device *dev = acpi_fetch_acpi_dev(handle);\n\n\t\tif (!dev || strcmp(ACPI_VIDEO_HID, acpi_device_hid(dev)))\n\t\t\treturn AE_OK;\n\t}\n\n\t*(acpi_handle *)return_value = handle;\n\n\treturn AE_CTRL_TERMINATE;\n}\n\nstatic void __init tpacpi_acpi_handle_locate(const char *name,\n\t\tconst char *hid,\n\t\tacpi_handle *handle)\n{\n\tacpi_status status;\n\tacpi_handle device_found;\n\n\tBUG_ON(!name || !handle);\n\tvdbg_printk(TPACPI_DBG_INIT,\n\t\t\t\"trying to locate ACPI handle for %s, using HID %s\\n\",\n\t\t\tname, hid ? hid : \"NULL\");\n\n\tmemset(&device_found, 0, sizeof(device_found));\n\tstatus = acpi_get_devices(hid, tpacpi_acpi_handle_locate_callback,\n\t\t\t\t  (void *)name, &device_found);\n\n\t*handle = NULL;\n\n\tif (ACPI_SUCCESS(status)) {\n\t\t*handle = device_found;\n\t\tdbg_printk(TPACPI_DBG_INIT,\n\t\t\t   \"Found ACPI handle for %s\\n\", name);\n\t} else {\n\t\tvdbg_printk(TPACPI_DBG_INIT,\n\t\t\t    \"Could not locate an ACPI handle for %s: %s\\n\",\n\t\t\t    name, acpi_format_exception(status));\n\t}\n}\n\nstatic void dispatch_acpi_notify(acpi_handle handle, u32 event, void *data)\n{\n\tstruct ibm_struct *ibm = data;\n\n\tif (tpacpi_lifecycle != TPACPI_LIFE_RUNNING)\n\t\treturn;\n\n\tif (!ibm || !ibm->acpi || !ibm->acpi->notify)\n\t\treturn;\n\n\tibm->acpi->notify(ibm, event);\n}\n\nstatic int __init setup_acpi_notify(struct ibm_struct *ibm)\n{\n\tacpi_status status;\n\n\tBUG_ON(!ibm->acpi);\n\n\tif (!*ibm->acpi->handle)\n\t\treturn 0;\n\n\tvdbg_printk(TPACPI_DBG_INIT,\n\t\t\"setting up ACPI notify for %s\\n\", ibm->name);\n\n\tibm->acpi->device = acpi_fetch_acpi_dev(*ibm->acpi->handle);\n\tif (!ibm->acpi->device) {\n\t\tpr_err(\"acpi_fetch_acpi_dev(%s) failed\\n\", ibm->name);\n\t\treturn -ENODEV;\n\t}\n\n\tibm->acpi->device->driver_data = ibm;\n\tsprintf(acpi_device_class(ibm->acpi->device), \"%s/%s\",\n\t\tTPACPI_ACPI_EVENT_PREFIX,\n\t\tibm->name);\n\n\tstatus = acpi_install_notify_handler(*ibm->acpi->handle,\n\t\t\tibm->acpi->type, dispatch_acpi_notify, ibm);\n\tif (ACPI_FAILURE(status)) {\n\t\tif (status == AE_ALREADY_EXISTS) {\n\t\t\tpr_notice(\"another device driver is already handling %s events\\n\",\n\t\t\t\t  ibm->name);\n\t\t} else {\n\t\t\tpr_err(\"acpi_install_notify_handler(%s) failed: %s\\n\",\n\t\t\t       ibm->name, acpi_format_exception(status));\n\t\t}\n\t\treturn -ENODEV;\n\t}\n\tibm->flags.acpi_notify_installed = 1;\n\treturn 0;\n}\n\nstatic int __init tpacpi_device_add(struct acpi_device *device)\n{\n\treturn 0;\n}\n\nstatic int __init register_tpacpi_subdriver(struct ibm_struct *ibm)\n{\n\tint rc;\n\n\tdbg_printk(TPACPI_DBG_INIT,\n\t\t\"registering %s as an ACPI driver\\n\", ibm->name);\n\n\tBUG_ON(!ibm->acpi);\n\n\tibm->acpi->driver = kzalloc(sizeof(struct acpi_driver), GFP_KERNEL);\n\tif (!ibm->acpi->driver) {\n\t\tpr_err(\"failed to allocate memory for ibm->acpi->driver\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tsprintf(ibm->acpi->driver->name, \"%s_%s\", TPACPI_NAME, ibm->name);\n\tibm->acpi->driver->ids = ibm->acpi->hid;\n\n\tibm->acpi->driver->ops.add = &tpacpi_device_add;\n\n\trc = acpi_bus_register_driver(ibm->acpi->driver);\n\tif (rc < 0) {\n\t\tpr_err(\"acpi_bus_register_driver(%s) failed: %d\\n\",\n\t\t       ibm->name, rc);\n\t\tkfree(ibm->acpi->driver);\n\t\tibm->acpi->driver = NULL;\n\t} else if (!rc)\n\t\tibm->flags.acpi_driver_registered = 1;\n\n\treturn rc;\n}\n\n\n \n\nstatic int dispatch_proc_show(struct seq_file *m, void *v)\n{\n\tstruct ibm_struct *ibm = m->private;\n\n\tif (!ibm || !ibm->read)\n\t\treturn -EINVAL;\n\treturn ibm->read(m);\n}\n\nstatic int dispatch_proc_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, dispatch_proc_show, pde_data(inode));\n}\n\nstatic ssize_t dispatch_proc_write(struct file *file,\n\t\t\tconst char __user *userbuf,\n\t\t\tsize_t count, loff_t *pos)\n{\n\tstruct ibm_struct *ibm = pde_data(file_inode(file));\n\tchar *kernbuf;\n\tint ret;\n\n\tif (!ibm || !ibm->write)\n\t\treturn -EINVAL;\n\tif (count > PAGE_SIZE - 1)\n\t\treturn -EINVAL;\n\n\tkernbuf = memdup_user_nul(userbuf, count);\n\tif (IS_ERR(kernbuf))\n\t\treturn PTR_ERR(kernbuf);\n\tret = ibm->write(kernbuf);\n\tif (ret == 0)\n\t\tret = count;\n\n\tkfree(kernbuf);\n\n\treturn ret;\n}\n\nstatic const struct proc_ops dispatch_proc_ops = {\n\t.proc_open\t= dispatch_proc_open,\n\t.proc_read\t= seq_read,\n\t.proc_lseek\t= seq_lseek,\n\t.proc_release\t= single_release,\n\t.proc_write\t= dispatch_proc_write,\n};\n\n \n\nstatic struct platform_device *tpacpi_pdev;\nstatic struct platform_device *tpacpi_sensors_pdev;\nstatic struct device *tpacpi_hwmon;\nstatic struct input_dev *tpacpi_inputdev;\nstatic struct mutex tpacpi_inputdev_send_mutex;\nstatic LIST_HEAD(tpacpi_all_drivers);\n\n#ifdef CONFIG_PM_SLEEP\nstatic int tpacpi_suspend_handler(struct device *dev)\n{\n\tstruct ibm_struct *ibm, *itmp;\n\n\tlist_for_each_entry_safe(ibm, itmp,\n\t\t\t\t &tpacpi_all_drivers,\n\t\t\t\t all_drivers) {\n\t\tif (ibm->suspend)\n\t\t\t(ibm->suspend)();\n\t}\n\n\treturn 0;\n}\n\nstatic int tpacpi_resume_handler(struct device *dev)\n{\n\tstruct ibm_struct *ibm, *itmp;\n\n\tlist_for_each_entry_safe(ibm, itmp,\n\t\t\t\t &tpacpi_all_drivers,\n\t\t\t\t all_drivers) {\n\t\tif (ibm->resume)\n\t\t\t(ibm->resume)();\n\t}\n\n\treturn 0;\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(tpacpi_pm,\n\t\t\t tpacpi_suspend_handler, tpacpi_resume_handler);\n\nstatic void tpacpi_shutdown_handler(struct platform_device *pdev)\n{\n\tstruct ibm_struct *ibm, *itmp;\n\n\tlist_for_each_entry_safe(ibm, itmp,\n\t\t\t\t &tpacpi_all_drivers,\n\t\t\t\t all_drivers) {\n\t\tif (ibm->shutdown)\n\t\t\t(ibm->shutdown)();\n\t}\n}\n\n \n\nstatic int parse_strtoul(const char *buf,\n\t\tunsigned long max, unsigned long *value)\n{\n\tchar *endp;\n\n\t*value = simple_strtoul(skip_spaces(buf), &endp, 0);\n\tendp = skip_spaces(endp);\n\tif (*endp || *value > max)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic void tpacpi_disable_brightness_delay(void)\n{\n\tif (acpi_evalf(hkey_handle, NULL, \"PWMS\", \"qvd\", 0))\n\t\tpr_notice(\"ACPI backlight control delay disabled\\n\");\n}\n\nstatic void printk_deprecated_attribute(const char * const what,\n\t\t\t\t\tconst char * const details)\n{\n\ttpacpi_log_usertask(\"deprecated sysfs attribute\");\n\tpr_warn(\"WARNING: sysfs attribute %s is deprecated and will be removed. %s\\n\",\n\t\twhat, details);\n}\n\n \n\n \n\n \nenum tpacpi_rfkill_state {\n\tTPACPI_RFK_RADIO_OFF = 0,\n\tTPACPI_RFK_RADIO_ON\n};\n\n \nenum tpacpi_rfk_id {\n\tTPACPI_RFK_BLUETOOTH_SW_ID = 0,\n\tTPACPI_RFK_WWAN_SW_ID,\n\tTPACPI_RFK_UWB_SW_ID,\n\tTPACPI_RFK_SW_MAX\n};\n\nstatic const char *tpacpi_rfkill_names[] = {\n\t[TPACPI_RFK_BLUETOOTH_SW_ID] = \"bluetooth\",\n\t[TPACPI_RFK_WWAN_SW_ID] = \"wwan\",\n\t[TPACPI_RFK_UWB_SW_ID] = \"uwb\",\n\t[TPACPI_RFK_SW_MAX] = NULL\n};\n\n \nstruct tpacpi_rfk {\n\tstruct rfkill *rfkill;\n\tenum tpacpi_rfk_id id;\n\tconst struct tpacpi_rfk_ops *ops;\n};\n\nstruct tpacpi_rfk_ops {\n\t \n\tint (*get_status)(void);\n\tint (*set_status)(const enum tpacpi_rfkill_state);\n};\n\nstatic struct tpacpi_rfk *tpacpi_rfkill_switches[TPACPI_RFK_SW_MAX];\n\n \nstatic int tpacpi_rfk_update_swstate(const struct tpacpi_rfk *tp_rfk)\n{\n\tint status;\n\n\tif (!tp_rfk)\n\t\treturn -ENODEV;\n\n\tstatus = (tp_rfk->ops->get_status)();\n\tif (status < 0)\n\t\treturn status;\n\n\trfkill_set_sw_state(tp_rfk->rfkill,\n\t\t\t    (status == TPACPI_RFK_RADIO_OFF));\n\n\treturn status;\n}\n\n \nstatic void tpacpi_rfk_update_hwblock_state(bool blocked)\n{\n\tunsigned int i;\n\tstruct tpacpi_rfk *tp_rfk;\n\n\tfor (i = 0; i < TPACPI_RFK_SW_MAX; i++) {\n\t\ttp_rfk = tpacpi_rfkill_switches[i];\n\t\tif (tp_rfk) {\n\t\t\tif (rfkill_set_hw_state(tp_rfk->rfkill,\n\t\t\t\t\t\tblocked)) {\n\t\t\t\t \n\t\t\t}\n\t\t}\n\t}\n}\n\n \nstatic int hotkey_get_wlsw(void);\n\n \nstatic bool tpacpi_rfk_check_hwblock_state(void)\n{\n\tint res = hotkey_get_wlsw();\n\tint hw_blocked;\n\n\t \n\tif (res < 0)\n\t\treturn false;\n\n\thw_blocked = (res == TPACPI_RFK_RADIO_OFF);\n\ttpacpi_rfk_update_hwblock_state(hw_blocked);\n\n\treturn hw_blocked;\n}\n\nstatic int tpacpi_rfk_hook_set_block(void *data, bool blocked)\n{\n\tstruct tpacpi_rfk *tp_rfk = data;\n\tint res;\n\n\tdbg_printk(TPACPI_DBG_RFKILL,\n\t\t   \"request to change radio state to %s\\n\",\n\t\t   blocked ? \"blocked\" : \"unblocked\");\n\n\t \n\tres = (tp_rfk->ops->set_status)(blocked ?\n\t\t\t\tTPACPI_RFK_RADIO_OFF : TPACPI_RFK_RADIO_ON);\n\n\t \n\ttpacpi_rfk_update_swstate(tp_rfk);\n\n\treturn (res < 0) ? res : 0;\n}\n\nstatic const struct rfkill_ops tpacpi_rfk_rfkill_ops = {\n\t.set_block = tpacpi_rfk_hook_set_block,\n};\n\nstatic int __init tpacpi_new_rfkill(const enum tpacpi_rfk_id id,\n\t\t\tconst struct tpacpi_rfk_ops *tp_rfkops,\n\t\t\tconst enum rfkill_type rfktype,\n\t\t\tconst char *name,\n\t\t\tconst bool set_default)\n{\n\tstruct tpacpi_rfk *atp_rfk;\n\tint res;\n\tbool sw_state = false;\n\tbool hw_state;\n\tint sw_status;\n\n\tBUG_ON(id >= TPACPI_RFK_SW_MAX || tpacpi_rfkill_switches[id]);\n\n\tatp_rfk = kzalloc(sizeof(struct tpacpi_rfk), GFP_KERNEL);\n\tif (atp_rfk)\n\t\tatp_rfk->rfkill = rfkill_alloc(name,\n\t\t\t\t\t\t&tpacpi_pdev->dev,\n\t\t\t\t\t\trfktype,\n\t\t\t\t\t\t&tpacpi_rfk_rfkill_ops,\n\t\t\t\t\t\tatp_rfk);\n\tif (!atp_rfk || !atp_rfk->rfkill) {\n\t\tpr_err(\"failed to allocate memory for rfkill class\\n\");\n\t\tkfree(atp_rfk);\n\t\treturn -ENOMEM;\n\t}\n\n\tatp_rfk->id = id;\n\tatp_rfk->ops = tp_rfkops;\n\n\tsw_status = (tp_rfkops->get_status)();\n\tif (sw_status < 0) {\n\t\tpr_err(\"failed to read initial state for %s, error %d\\n\",\n\t\t       name, sw_status);\n\t} else {\n\t\tsw_state = (sw_status == TPACPI_RFK_RADIO_OFF);\n\t\tif (set_default) {\n\t\t\t \n\t\t\trfkill_init_sw_state(atp_rfk->rfkill, sw_state);\n\t\t}\n\t}\n\thw_state = tpacpi_rfk_check_hwblock_state();\n\trfkill_set_hw_state(atp_rfk->rfkill, hw_state);\n\n\tres = rfkill_register(atp_rfk->rfkill);\n\tif (res < 0) {\n\t\tpr_err(\"failed to register %s rfkill switch: %d\\n\", name, res);\n\t\trfkill_destroy(atp_rfk->rfkill);\n\t\tkfree(atp_rfk);\n\t\treturn res;\n\t}\n\n\ttpacpi_rfkill_switches[id] = atp_rfk;\n\n\tpr_info(\"rfkill switch %s: radio is %sblocked\\n\",\n\t\tname, (sw_state || hw_state) ? \"\" : \"un\");\n\treturn 0;\n}\n\nstatic void tpacpi_destroy_rfkill(const enum tpacpi_rfk_id id)\n{\n\tstruct tpacpi_rfk *tp_rfk;\n\n\tBUG_ON(id >= TPACPI_RFK_SW_MAX);\n\n\ttp_rfk = tpacpi_rfkill_switches[id];\n\tif (tp_rfk) {\n\t\trfkill_unregister(tp_rfk->rfkill);\n\t\trfkill_destroy(tp_rfk->rfkill);\n\t\ttpacpi_rfkill_switches[id] = NULL;\n\t\tkfree(tp_rfk);\n\t}\n}\n\nstatic void printk_deprecated_rfkill_attribute(const char * const what)\n{\n\tprintk_deprecated_attribute(what,\n\t\t\t\"Please switch to generic rfkill before year 2010\");\n}\n\n \nstatic ssize_t tpacpi_rfk_sysfs_enable_show(const enum tpacpi_rfk_id id,\n\t\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t\t    char *buf)\n{\n\tint status;\n\n\tprintk_deprecated_rfkill_attribute(attr->attr.name);\n\n\t \n\tif (tpacpi_rfk_check_hwblock_state()) {\n\t\tstatus = TPACPI_RFK_RADIO_OFF;\n\t} else {\n\t\tstatus = tpacpi_rfk_update_swstate(tpacpi_rfkill_switches[id]);\n\t\tif (status < 0)\n\t\t\treturn status;\n\t}\n\n\treturn sysfs_emit(buf, \"%d\\n\",\n\t\t\t(status == TPACPI_RFK_RADIO_ON) ? 1 : 0);\n}\n\nstatic ssize_t tpacpi_rfk_sysfs_enable_store(const enum tpacpi_rfk_id id,\n\t\t\t    struct device_attribute *attr,\n\t\t\t    const char *buf, size_t count)\n{\n\tunsigned long t;\n\tint res;\n\n\tprintk_deprecated_rfkill_attribute(attr->attr.name);\n\n\tif (parse_strtoul(buf, 1, &t))\n\t\treturn -EINVAL;\n\n\ttpacpi_disclose_usertask(attr->attr.name, \"set to %ld\\n\", t);\n\n\t \n\tif (tpacpi_rfk_check_hwblock_state() && !!t)\n\t\treturn -EPERM;\n\n\tres = tpacpi_rfkill_switches[id]->ops->set_status((!!t) ?\n\t\t\t\tTPACPI_RFK_RADIO_ON : TPACPI_RFK_RADIO_OFF);\n\ttpacpi_rfk_update_swstate(tpacpi_rfkill_switches[id]);\n\n\treturn (res < 0) ? res : count;\n}\n\n \nstatic int tpacpi_rfk_procfs_read(const enum tpacpi_rfk_id id, struct seq_file *m)\n{\n\tif (id >= TPACPI_RFK_SW_MAX)\n\t\tseq_printf(m, \"status:\\t\\tnot supported\\n\");\n\telse {\n\t\tint status;\n\n\t\t \n\t\tif (tpacpi_rfk_check_hwblock_state()) {\n\t\t\tstatus = TPACPI_RFK_RADIO_OFF;\n\t\t} else {\n\t\t\tstatus = tpacpi_rfk_update_swstate(\n\t\t\t\t\t\ttpacpi_rfkill_switches[id]);\n\t\t\tif (status < 0)\n\t\t\t\treturn status;\n\t\t}\n\n\t\tseq_printf(m, \"status:\\t\\t%s\\n\", str_enabled_disabled(status == TPACPI_RFK_RADIO_ON));\n\t\tseq_printf(m, \"commands:\\tenable, disable\\n\");\n\t}\n\n\treturn 0;\n}\n\nstatic int tpacpi_rfk_procfs_write(const enum tpacpi_rfk_id id, char *buf)\n{\n\tchar *cmd;\n\tint status = -1;\n\tint res = 0;\n\n\tif (id >= TPACPI_RFK_SW_MAX)\n\t\treturn -ENODEV;\n\n\twhile ((cmd = strsep(&buf, \",\"))) {\n\t\tif (strstarts(cmd, \"enable\"))\n\t\t\tstatus = TPACPI_RFK_RADIO_ON;\n\t\telse if (strstarts(cmd, \"disable\"))\n\t\t\tstatus = TPACPI_RFK_RADIO_OFF;\n\t\telse\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (status != -1) {\n\t\ttpacpi_disclose_usertask(\"procfs\", \"attempt to %s %s\\n\",\n\t\t\t\tstr_enable_disable(status == TPACPI_RFK_RADIO_ON),\n\t\t\t\ttpacpi_rfkill_names[id]);\n\t\tres = (tpacpi_rfkill_switches[id]->ops->set_status)(status);\n\t\ttpacpi_rfk_update_swstate(tpacpi_rfkill_switches[id]);\n\t}\n\n\treturn res;\n}\n\n \n\n \nstatic ssize_t interface_version_show(struct device_driver *drv, char *buf)\n{\n\treturn sysfs_emit(buf, \"0x%08x\\n\", TPACPI_SYSFS_VERSION);\n}\nstatic DRIVER_ATTR_RO(interface_version);\n\n \nstatic ssize_t debug_level_show(struct device_driver *drv, char *buf)\n{\n\treturn sysfs_emit(buf, \"0x%04x\\n\", dbg_level);\n}\n\nstatic ssize_t debug_level_store(struct device_driver *drv, const char *buf,\n\t\t\t\t size_t count)\n{\n\tunsigned long t;\n\n\tif (parse_strtoul(buf, 0xffff, &t))\n\t\treturn -EINVAL;\n\n\tdbg_level = t;\n\n\treturn count;\n}\nstatic DRIVER_ATTR_RW(debug_level);\n\n \nstatic ssize_t version_show(struct device_driver *drv, char *buf)\n{\n\treturn sysfs_emit(buf, \"%s v%s\\n\",\n\t\t\tTPACPI_DESC, TPACPI_VERSION);\n}\nstatic DRIVER_ATTR_RO(version);\n\n \n\n#ifdef CONFIG_THINKPAD_ACPI_DEBUGFACILITIES\n\n \nstatic ssize_t wlsw_emulstate_show(struct device_driver *drv, char *buf)\n{\n\treturn sysfs_emit(buf, \"%d\\n\", !!tpacpi_wlsw_emulstate);\n}\n\nstatic ssize_t wlsw_emulstate_store(struct device_driver *drv, const char *buf,\n\t\t\t\t    size_t count)\n{\n\tunsigned long t;\n\n\tif (parse_strtoul(buf, 1, &t))\n\t\treturn -EINVAL;\n\n\tif (tpacpi_wlsw_emulstate != !!t) {\n\t\ttpacpi_wlsw_emulstate = !!t;\n\t\ttpacpi_rfk_update_hwblock_state(!t);\t \n\t}\n\n\treturn count;\n}\nstatic DRIVER_ATTR_RW(wlsw_emulstate);\n\n \nstatic ssize_t bluetooth_emulstate_show(struct device_driver *drv, char *buf)\n{\n\treturn sysfs_emit(buf, \"%d\\n\", !!tpacpi_bluetooth_emulstate);\n}\n\nstatic ssize_t bluetooth_emulstate_store(struct device_driver *drv,\n\t\t\t\t\t const char *buf, size_t count)\n{\n\tunsigned long t;\n\n\tif (parse_strtoul(buf, 1, &t))\n\t\treturn -EINVAL;\n\n\ttpacpi_bluetooth_emulstate = !!t;\n\n\treturn count;\n}\nstatic DRIVER_ATTR_RW(bluetooth_emulstate);\n\n \nstatic ssize_t wwan_emulstate_show(struct device_driver *drv, char *buf)\n{\n\treturn sysfs_emit(buf, \"%d\\n\", !!tpacpi_wwan_emulstate);\n}\n\nstatic ssize_t wwan_emulstate_store(struct device_driver *drv, const char *buf,\n\t\t\t\t    size_t count)\n{\n\tunsigned long t;\n\n\tif (parse_strtoul(buf, 1, &t))\n\t\treturn -EINVAL;\n\n\ttpacpi_wwan_emulstate = !!t;\n\n\treturn count;\n}\nstatic DRIVER_ATTR_RW(wwan_emulstate);\n\n \nstatic ssize_t uwb_emulstate_show(struct device_driver *drv, char *buf)\n{\n\treturn sysfs_emit(buf, \"%d\\n\", !!tpacpi_uwb_emulstate);\n}\n\nstatic ssize_t uwb_emulstate_store(struct device_driver *drv, const char *buf,\n\t\t\t\t   size_t count)\n{\n\tunsigned long t;\n\n\tif (parse_strtoul(buf, 1, &t))\n\t\treturn -EINVAL;\n\n\ttpacpi_uwb_emulstate = !!t;\n\n\treturn count;\n}\nstatic DRIVER_ATTR_RW(uwb_emulstate);\n#endif\n\n \n\n \n\n#define TPV_Q(__v, __id1, __id2, __bv1, __bv2)\t\t\\\n\t{ .vendor\t= (__v),\t\t\t\\\n\t  .bios\t\t= TPID(__id1, __id2),\t\t\\\n\t  .ec\t\t= TPACPI_MATCH_ANY,\t\t\\\n\t  .quirks\t= TPACPI_MATCH_ANY_VERSION << 16 \\\n\t\t\t  | TPVER(__bv1, __bv2) }\n\n#define TPV_Q_X(__v, __bid1, __bid2, __bv1, __bv2,\t\\\n\t\t__eid, __ev1, __ev2)\t\t\t\\\n\t{ .vendor\t= (__v),\t\t\t\\\n\t  .bios\t\t= TPID(__bid1, __bid2),\t\t\\\n\t  .ec\t\t= __eid,\t\t\t\\\n\t  .quirks\t= TPVER(__ev1, __ev2) << 16\t\\\n\t\t\t  | TPVER(__bv1, __bv2) }\n\n#define TPV_QI0(__id1, __id2, __bv1, __bv2) \\\n\tTPV_Q(PCI_VENDOR_ID_IBM, __id1, __id2, __bv1, __bv2)\n\n \n#define TPV_QI1(__id1, __id2, __bv1, __bv2, __ev1, __ev2) \\\n\tTPV_Q_X(PCI_VENDOR_ID_IBM, __id1, __id2, \t\\\n\t\t__bv1, __bv2, TPID(__id1, __id2),\t\\\n\t\t__ev1, __ev2),\t\t\t\t\\\n\tTPV_Q_X(PCI_VENDOR_ID_IBM, __id1, __id2, \t\\\n\t\t__bv1, __bv2, TPACPI_MATCH_UNKNOWN,\t\\\n\t\t__ev1, __ev2)\n\n \n#define TPV_QI2(__bid1, __bid2, __bv1, __bv2,\t\t\\\n\t\t__eid1, __eid2, __ev1, __ev2) \t\t\\\n\tTPV_Q_X(PCI_VENDOR_ID_IBM, __bid1, __bid2, \t\\\n\t\t__bv1, __bv2, TPID(__eid1, __eid2),\t\\\n\t\t__ev1, __ev2),\t\t\t\t\\\n\tTPV_Q_X(PCI_VENDOR_ID_IBM, __bid1, __bid2, \t\\\n\t\t__bv1, __bv2, TPACPI_MATCH_UNKNOWN,\t\\\n\t\t__ev1, __ev2)\n\n#define TPV_QL0(__id1, __id2, __bv1, __bv2) \\\n\tTPV_Q(PCI_VENDOR_ID_LENOVO, __id1, __id2, __bv1, __bv2)\n\n#define TPV_QL1(__id1, __id2, __bv1, __bv2, __ev1, __ev2) \\\n\tTPV_Q_X(PCI_VENDOR_ID_LENOVO, __id1, __id2, \t\\\n\t\t__bv1, __bv2, TPID(__id1, __id2),\t\\\n\t\t__ev1, __ev2)\n\n#define TPV_QL2(__bid1, __bid2, __bv1, __bv2,\t\t\\\n\t\t__eid1, __eid2, __ev1, __ev2) \t\t\\\n\tTPV_Q_X(PCI_VENDOR_ID_LENOVO, __bid1, __bid2, \t\\\n\t\t__bv1, __bv2, TPID(__eid1, __eid2),\t\\\n\t\t__ev1, __ev2)\n\nstatic const struct tpacpi_quirk tpacpi_bios_version_qtable[] __initconst = {\n\t \n\t \n\tTPV_QI0('I', 'M',  '6', '5'),\t\t  \n\tTPV_QI0('I', 'U',  '2', '6'),\t\t  \n\tTPV_QI0('I', 'B',  '5', '4'),\t\t  \n\tTPV_QI0('I', 'H',  '4', '7'),\t\t  \n\tTPV_QI0('I', 'N',  '3', '6'),\t\t  \n\tTPV_QI0('I', 'T',  '5', '5'),\t\t  \n\tTPV_QI0('I', 'D',  '4', '8'),\t\t  \n\tTPV_QI0('I', 'I',  '4', '2'),\t\t  \n\tTPV_QI0('I', 'O',  '2', '3'),\t\t  \n\n\t \n\t \n\tTPV_QI0('I', 'W',  '5', '9'),\t\t  \n\tTPV_QI0('I', 'V',  '6', '9'),\t\t  \n\tTPV_QI0('1', '0',  '2', '6'),\t\t  \n\tTPV_QI0('K', 'U',  '3', '6'),\t\t  \n\tTPV_QI0('K', 'X',  '3', '6'),\t\t  \n\tTPV_QI0('K', 'Y',  '3', '8'),\t\t  \n\tTPV_QI0('1', 'B',  '1', '7'),\t\t  \n\tTPV_QI0('1', '3',  '2', '0'),\t\t  \n\tTPV_QI0('1', 'E',  '7', '3'),\t\t  \n\tTPV_QI1('1', 'G',  '4', '1',  '1', '7'),  \n\tTPV_QI1('1', 'N',  '1', '6',  '0', '7'),  \n\n\t \n\t \n\tTPV_QI0('1', 'T',  'A', '6'),\t\t  \n\tTPV_QI0('1', 'X',  '5', '7'),\t\t  \n\n\t \n\t \n\tTPV_QI0('1', 'C',  'F', '0'),\t\t  \n\tTPV_QI0('1', 'F',  'F', '1'),\t\t  \n\tTPV_QI0('1', 'M',  '9', '7'),\t\t  \n\tTPV_QI0('1', 'O',  '6', '1'),\t\t  \n\tTPV_QI0('1', 'P',  '6', '5'),\t\t  \n\tTPV_QI0('1', 'S',  '7', '0'),\t\t  \n\tTPV_QI1('1', 'R',  'D', 'R',  '7', '1'),  \n\tTPV_QI1('1', 'V',  '7', '1',  '2', '8'),  \n\tTPV_QI1('7', '8',  '7', '1',  '0', '6'),  \n\tTPV_QI1('7', '6',  '6', '9',  '1', '6'),  \n\tTPV_QI1('7', '0',  '6', '9',  '2', '8'),  \n\n\tTPV_QI0('I', 'Y',  '6', '1'),\t\t  \n\tTPV_QI0('K', 'Z',  '3', '4'),\t\t  \n\tTPV_QI0('1', '6',  '3', '2'),\t\t  \n\tTPV_QI1('1', 'A',  '6', '4',  '2', '3'),  \n\tTPV_QI1('1', 'I',  '7', '1',  '2', '0'),  \n\tTPV_QI1('1', 'Y',  '6', '5',  '2', '9'),  \n\n\tTPV_QL1('7', '9',  'E', '3',  '5', '0'),  \n\tTPV_QL1('7', 'C',  'D', '2',  '2', '2'),  \n\tTPV_QL1('7', 'E',  'D', '0',  '1', '5'),  \n\n\t \n\tTPV_QI2('1', 'W',  '9', '0',  '1', 'V', '2', '8'),  \n\tTPV_QL2('7', 'I',  '3', '4',  '7', '9', '5', '0'),  \n\n\t \n\t \n\tTPV_QI0('I', 'Z',  '9', 'D'),\t\t  \n\tTPV_QI0('1', 'D',  '7', '0'),\t\t  \n\tTPV_QI1('1', 'K',  '4', '8',  '1', '8'),  \n\tTPV_QI1('1', 'Q',  '9', '7',  '2', '3'),  \n\tTPV_QI1('1', 'U',  'D', '3',  'B', '2'),  \n\tTPV_QI1('7', '4',  '6', '4',  '2', '7'),  \n\tTPV_QI1('7', '5',  '6', '0',  '2', '0'),  \n\n\tTPV_QL1('7', 'B',  'D', '7',  '4', '0'),  \n\tTPV_QL1('7', 'J',  '3', '0',  '1', '3'),  \n\n\t \n\t \n};\n\n#undef TPV_QL1\n#undef TPV_QL0\n#undef TPV_QI2\n#undef TPV_QI1\n#undef TPV_QI0\n#undef TPV_Q_X\n#undef TPV_Q\n\nstatic void __init tpacpi_check_outdated_fw(void)\n{\n\tunsigned long fwvers;\n\tu16 ec_version, bios_version;\n\n\tfwvers = tpacpi_check_quirks(tpacpi_bios_version_qtable,\n\t\t\t\tARRAY_SIZE(tpacpi_bios_version_qtable));\n\n\tif (!fwvers)\n\t\treturn;\n\n\tbios_version = fwvers & 0xffffU;\n\tec_version = (fwvers >> 16) & 0xffffU;\n\n\t \n\tif ((bios_version > thinkpad_id.bios_release) ||\n\t    (ec_version > thinkpad_id.ec_release &&\n\t\t\t\tec_version != TPACPI_MATCH_ANY_VERSION)) {\n\t\t \n\t\tpr_warn(\"WARNING: Outdated ThinkPad BIOS/EC firmware\\n\");\n\t\tpr_warn(\"WARNING: This firmware may be missing critical bug fixes and/or important features\\n\");\n\t}\n}\n\nstatic bool __init tpacpi_is_fw_known(void)\n{\n\treturn tpacpi_check_quirks(tpacpi_bios_version_qtable,\n\t\t\tARRAY_SIZE(tpacpi_bios_version_qtable)) != 0;\n}\n\n \n\n \n\nstatic int thinkpad_acpi_driver_read(struct seq_file *m)\n{\n\tseq_printf(m, \"driver:\\t\\t%s\\n\", TPACPI_DESC);\n\tseq_printf(m, \"version:\\t%s\\n\", TPACPI_VERSION);\n\treturn 0;\n}\n\nstatic struct ibm_struct thinkpad_acpi_driver_data = {\n\t.name = \"driver\",\n\t.read = thinkpad_acpi_driver_read,\n};\n\n \n\n \n\nenum {\t \n\tTP_ACPI_HOTKEYSCAN_FNF1\t\t= 0,\n\tTP_ACPI_HOTKEYSCAN_FNF2,\n\tTP_ACPI_HOTKEYSCAN_FNF3,\n\tTP_ACPI_HOTKEYSCAN_FNF4,\n\tTP_ACPI_HOTKEYSCAN_FNF5,\n\tTP_ACPI_HOTKEYSCAN_FNF6,\n\tTP_ACPI_HOTKEYSCAN_FNF7,\n\tTP_ACPI_HOTKEYSCAN_FNF8,\n\tTP_ACPI_HOTKEYSCAN_FNF9,\n\tTP_ACPI_HOTKEYSCAN_FNF10,\n\tTP_ACPI_HOTKEYSCAN_FNF11,\n\tTP_ACPI_HOTKEYSCAN_FNF12,\n\tTP_ACPI_HOTKEYSCAN_FNBACKSPACE,\n\tTP_ACPI_HOTKEYSCAN_FNINSERT,\n\tTP_ACPI_HOTKEYSCAN_FNDELETE,\n\tTP_ACPI_HOTKEYSCAN_FNHOME,\n\tTP_ACPI_HOTKEYSCAN_FNEND,\n\tTP_ACPI_HOTKEYSCAN_FNPAGEUP,\n\tTP_ACPI_HOTKEYSCAN_FNPAGEDOWN,\n\tTP_ACPI_HOTKEYSCAN_FNSPACE,\n\tTP_ACPI_HOTKEYSCAN_VOLUMEUP,\n\tTP_ACPI_HOTKEYSCAN_VOLUMEDOWN,\n\tTP_ACPI_HOTKEYSCAN_MUTE,\n\tTP_ACPI_HOTKEYSCAN_THINKPAD,\n\tTP_ACPI_HOTKEYSCAN_UNK1,\n\tTP_ACPI_HOTKEYSCAN_UNK2,\n\tTP_ACPI_HOTKEYSCAN_UNK3,\n\tTP_ACPI_HOTKEYSCAN_UNK4,\n\tTP_ACPI_HOTKEYSCAN_UNK5,\n\tTP_ACPI_HOTKEYSCAN_UNK6,\n\tTP_ACPI_HOTKEYSCAN_UNK7,\n\tTP_ACPI_HOTKEYSCAN_UNK8,\n\n\t \n\tTP_ACPI_HOTKEYSCAN_ADAPTIVE_START,\n\tTP_ACPI_HOTKEYSCAN_MUTE2        = TP_ACPI_HOTKEYSCAN_ADAPTIVE_START,\n\tTP_ACPI_HOTKEYSCAN_BRIGHTNESS_ZERO,\n\tTP_ACPI_HOTKEYSCAN_CLIPPING_TOOL,\n\tTP_ACPI_HOTKEYSCAN_CLOUD,\n\tTP_ACPI_HOTKEYSCAN_UNK9,\n\tTP_ACPI_HOTKEYSCAN_VOICE,\n\tTP_ACPI_HOTKEYSCAN_UNK10,\n\tTP_ACPI_HOTKEYSCAN_GESTURES,\n\tTP_ACPI_HOTKEYSCAN_UNK11,\n\tTP_ACPI_HOTKEYSCAN_UNK12,\n\tTP_ACPI_HOTKEYSCAN_UNK13,\n\tTP_ACPI_HOTKEYSCAN_CONFIG,\n\tTP_ACPI_HOTKEYSCAN_NEW_TAB,\n\tTP_ACPI_HOTKEYSCAN_RELOAD,\n\tTP_ACPI_HOTKEYSCAN_BACK,\n\tTP_ACPI_HOTKEYSCAN_MIC_DOWN,\n\tTP_ACPI_HOTKEYSCAN_MIC_UP,\n\tTP_ACPI_HOTKEYSCAN_MIC_CANCELLATION,\n\tTP_ACPI_HOTKEYSCAN_CAMERA_MODE,\n\tTP_ACPI_HOTKEYSCAN_ROTATE_DISPLAY,\n\n\t \n\tTP_ACPI_HOTKEYSCAN_EXTENDED_START,\n\t \n\tTP_ACPI_HOTKEYSCAN_STAR = 69,\n\tTP_ACPI_HOTKEYSCAN_CLIPPING_TOOL2,\n\tTP_ACPI_HOTKEYSCAN_CALCULATOR,\n\tTP_ACPI_HOTKEYSCAN_BLUETOOTH,\n\tTP_ACPI_HOTKEYSCAN_KEYBOARD,\n\tTP_ACPI_HOTKEYSCAN_FN_RIGHT_SHIFT,  \n\tTP_ACPI_HOTKEYSCAN_NOTIFICATION_CENTER,\n\tTP_ACPI_HOTKEYSCAN_PICKUP_PHONE,\n\tTP_ACPI_HOTKEYSCAN_HANGUP_PHONE,\n\n\t \n\tTPACPI_HOTKEY_MAP_LEN\n};\n\nenum {\t \n\tTPACPI_HKEY_NVRAM_KNOWN_MASK = 0x00fb88c0U,\n\tTPACPI_HKEY_NVRAM_GOOD_MASK  = 0x00fb8000U,\n};\n\nenum {\t \n\tTP_ACPI_HKEY_DISPSWTCH_MASK\t= 1 << TP_ACPI_HOTKEYSCAN_FNF7,\n\tTP_ACPI_HKEY_DISPXPAND_MASK\t= 1 << TP_ACPI_HOTKEYSCAN_FNF8,\n\tTP_ACPI_HKEY_HIBERNATE_MASK\t= 1 << TP_ACPI_HOTKEYSCAN_FNF12,\n\tTP_ACPI_HKEY_BRGHTUP_MASK\t= 1 << TP_ACPI_HOTKEYSCAN_FNHOME,\n\tTP_ACPI_HKEY_BRGHTDWN_MASK\t= 1 << TP_ACPI_HOTKEYSCAN_FNEND,\n\tTP_ACPI_HKEY_KBD_LIGHT_MASK\t= 1 << TP_ACPI_HOTKEYSCAN_FNPAGEUP,\n\tTP_ACPI_HKEY_ZOOM_MASK\t\t= 1 << TP_ACPI_HOTKEYSCAN_FNSPACE,\n\tTP_ACPI_HKEY_VOLUP_MASK\t\t= 1 << TP_ACPI_HOTKEYSCAN_VOLUMEUP,\n\tTP_ACPI_HKEY_VOLDWN_MASK\t= 1 << TP_ACPI_HOTKEYSCAN_VOLUMEDOWN,\n\tTP_ACPI_HKEY_MUTE_MASK\t\t= 1 << TP_ACPI_HOTKEYSCAN_MUTE,\n\tTP_ACPI_HKEY_THINKPAD_MASK\t= 1 << TP_ACPI_HOTKEYSCAN_THINKPAD,\n};\n\nenum {\t \n\tTP_NVRAM_HKEY_GROUP_HK2\t\t= TP_ACPI_HKEY_THINKPAD_MASK |\n\t\t\t\t\t  TP_ACPI_HKEY_ZOOM_MASK |\n\t\t\t\t\t  TP_ACPI_HKEY_DISPSWTCH_MASK |\n\t\t\t\t\t  TP_ACPI_HKEY_HIBERNATE_MASK,\n\tTP_NVRAM_HKEY_GROUP_BRIGHTNESS\t= TP_ACPI_HKEY_BRGHTUP_MASK |\n\t\t\t\t\t  TP_ACPI_HKEY_BRGHTDWN_MASK,\n\tTP_NVRAM_HKEY_GROUP_VOLUME\t= TP_ACPI_HKEY_VOLUP_MASK |\n\t\t\t\t\t  TP_ACPI_HKEY_VOLDWN_MASK |\n\t\t\t\t\t  TP_ACPI_HKEY_MUTE_MASK,\n};\n\n#ifdef CONFIG_THINKPAD_ACPI_HOTKEY_POLL\nstruct tp_nvram_state {\n       u16 thinkpad_toggle:1;\n       u16 zoom_toggle:1;\n       u16 display_toggle:1;\n       u16 thinklight_toggle:1;\n       u16 hibernate_toggle:1;\n       u16 displayexp_toggle:1;\n       u16 display_state:1;\n       u16 brightness_toggle:1;\n       u16 volume_toggle:1;\n       u16 mute:1;\n\n       u8 brightness_level;\n       u8 volume_level;\n};\n\n \nstatic struct task_struct *tpacpi_hotkey_task;\n\n \nstatic struct mutex hotkey_thread_data_mutex;\nstatic unsigned int hotkey_config_change;\n\n \nstatic u32 hotkey_source_mask;\t\t \nstatic unsigned int hotkey_poll_freq = 10;  \n\n#define HOTKEY_CONFIG_CRITICAL_START \\\n\tdo { \\\n\t\tmutex_lock(&hotkey_thread_data_mutex); \\\n\t\thotkey_config_change++; \\\n\t} while (0);\n#define HOTKEY_CONFIG_CRITICAL_END \\\n\tmutex_unlock(&hotkey_thread_data_mutex);\n\n#else  \n\n#define hotkey_source_mask 0U\n#define HOTKEY_CONFIG_CRITICAL_START\n#define HOTKEY_CONFIG_CRITICAL_END\n\n#endif  \n\nstatic struct mutex hotkey_mutex;\n\nstatic enum {\t \n\tTP_ACPI_WAKEUP_NONE = 0,\t \n\tTP_ACPI_WAKEUP_BAYEJ,\t\t \n\tTP_ACPI_WAKEUP_UNDOCK,\t\t \n} hotkey_wakeup_reason;\n\nstatic int hotkey_autosleep_ack;\n\nstatic u32 hotkey_orig_mask;\t\t \nstatic u32 hotkey_all_mask;\t\t \nstatic u32 hotkey_adaptive_all_mask;\t \nstatic u32 hotkey_reserved_mask;\t \nstatic u32 hotkey_driver_mask;\t\t \nstatic u32 hotkey_user_mask;\t\t \nstatic u32 hotkey_acpi_mask;\t\t \n\nstatic u16 *hotkey_keycode_map;\n\nstatic void tpacpi_driver_event(const unsigned int hkey_event);\nstatic void hotkey_driver_event(const unsigned int scancode);\nstatic void hotkey_poll_setup(const bool may_warn);\n\n \n#define TP_HOTKEY_TABLET_MASK (1 << 3)\nenum {\n\tTP_ACPI_MULTI_MODE_INVALID\t= 0,\n\tTP_ACPI_MULTI_MODE_UNKNOWN\t= 1 << 0,\n\tTP_ACPI_MULTI_MODE_LAPTOP\t= 1 << 1,\n\tTP_ACPI_MULTI_MODE_TABLET\t= 1 << 2,\n\tTP_ACPI_MULTI_MODE_FLAT\t\t= 1 << 3,\n\tTP_ACPI_MULTI_MODE_STAND\t= 1 << 4,\n\tTP_ACPI_MULTI_MODE_TENT\t\t= 1 << 5,\n\tTP_ACPI_MULTI_MODE_STAND_TENT\t= 1 << 6,\n};\n\nenum {\n\t \n\tTP_ACPI_MULTI_MODE_TABLET_LIKE\t= TP_ACPI_MULTI_MODE_TABLET |\n\t\t\t\t\t  TP_ACPI_MULTI_MODE_STAND |\n\t\t\t\t\t  TP_ACPI_MULTI_MODE_TENT |\n\t\t\t\t\t  TP_ACPI_MULTI_MODE_STAND_TENT,\n};\n\nstatic int hotkey_get_wlsw(void)\n{\n\tint status;\n\n\tif (!tp_features.hotkey_wlsw)\n\t\treturn -ENODEV;\n\n#ifdef CONFIG_THINKPAD_ACPI_DEBUGFACILITIES\n\tif (dbg_wlswemul)\n\t\treturn (tpacpi_wlsw_emulstate) ?\n\t\t\t\tTPACPI_RFK_RADIO_ON : TPACPI_RFK_RADIO_OFF;\n#endif\n\n\tif (!acpi_evalf(hkey_handle, &status, \"WLSW\", \"d\"))\n\t\treturn -EIO;\n\n\treturn (status) ? TPACPI_RFK_RADIO_ON : TPACPI_RFK_RADIO_OFF;\n}\n\nstatic int hotkey_gmms_get_tablet_mode(int s, int *has_tablet_mode)\n{\n\tint type = (s >> 16) & 0xffff;\n\tint value = s & 0xffff;\n\tint mode = TP_ACPI_MULTI_MODE_INVALID;\n\tint valid_modes = 0;\n\n\tif (has_tablet_mode)\n\t\t*has_tablet_mode = 0;\n\n\tswitch (type) {\n\tcase 1:\n\t\tvalid_modes = TP_ACPI_MULTI_MODE_LAPTOP |\n\t\t\t      TP_ACPI_MULTI_MODE_TABLET |\n\t\t\t      TP_ACPI_MULTI_MODE_STAND_TENT;\n\t\tbreak;\n\tcase 2:\n\t\tvalid_modes = TP_ACPI_MULTI_MODE_LAPTOP |\n\t\t\t      TP_ACPI_MULTI_MODE_FLAT |\n\t\t\t      TP_ACPI_MULTI_MODE_TABLET |\n\t\t\t      TP_ACPI_MULTI_MODE_STAND |\n\t\t\t      TP_ACPI_MULTI_MODE_TENT;\n\t\tbreak;\n\tcase 3:\n\t\tvalid_modes = TP_ACPI_MULTI_MODE_LAPTOP |\n\t\t\t      TP_ACPI_MULTI_MODE_FLAT;\n\t\tbreak;\n\tcase 4:\n\tcase 5:\n\t\t \n\t\tvalid_modes = TP_ACPI_MULTI_MODE_LAPTOP |\n\t\t\t      TP_ACPI_MULTI_MODE_FLAT |\n\t\t\t      TP_ACPI_MULTI_MODE_TABLET |\n\t\t\t      TP_ACPI_MULTI_MODE_STAND |\n\t\t\t      TP_ACPI_MULTI_MODE_TENT;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"Unknown multi mode status type %d with value 0x%04X, please report this to %s\\n\",\n\t\t       type, value, TPACPI_MAIL);\n\t\treturn 0;\n\t}\n\n\tif (has_tablet_mode && (valid_modes & TP_ACPI_MULTI_MODE_TABLET_LIKE))\n\t\t*has_tablet_mode = 1;\n\n\tswitch (value) {\n\tcase 1:\n\t\tmode = TP_ACPI_MULTI_MODE_LAPTOP;\n\t\tbreak;\n\tcase 2:\n\t\tmode = TP_ACPI_MULTI_MODE_FLAT;\n\t\tbreak;\n\tcase 3:\n\t\tmode = TP_ACPI_MULTI_MODE_TABLET;\n\t\tbreak;\n\tcase 4:\n\t\tif (type == 1)\n\t\t\tmode = TP_ACPI_MULTI_MODE_STAND_TENT;\n\t\telse\n\t\t\tmode = TP_ACPI_MULTI_MODE_STAND;\n\t\tbreak;\n\tcase 5:\n\t\tmode = TP_ACPI_MULTI_MODE_TENT;\n\t\tbreak;\n\tdefault:\n\t\tif (type == 5 && value == 0xffff) {\n\t\t\tpr_warn(\"Multi mode status is undetected, assuming laptop\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (!(mode & valid_modes)) {\n\t\tpr_err(\"Unknown/reserved multi mode value 0x%04X for type %d, please report this to %s\\n\",\n\t\t       value, type, TPACPI_MAIL);\n\t\treturn 0;\n\t}\n\n\treturn !!(mode & TP_ACPI_MULTI_MODE_TABLET_LIKE);\n}\n\nstatic int hotkey_get_tablet_mode(int *status)\n{\n\tint s;\n\n\tswitch (tp_features.hotkey_tablet) {\n\tcase TP_HOTKEY_TABLET_USES_MHKG:\n\t\tif (!acpi_evalf(hkey_handle, &s, \"MHKG\", \"d\"))\n\t\t\treturn -EIO;\n\n\t\t*status = ((s & TP_HOTKEY_TABLET_MASK) != 0);\n\t\tbreak;\n\tcase TP_HOTKEY_TABLET_USES_GMMS:\n\t\tif (!acpi_evalf(hkey_handle, &s, \"GMMS\", \"dd\", 0))\n\t\t\treturn -EIO;\n\n\t\t*status = hotkey_gmms_get_tablet_mode(s, NULL);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int hotkey_mask_get(void)\n{\n\tlockdep_assert_held(&hotkey_mutex);\n\n\tif (tp_features.hotkey_mask) {\n\t\tu32 m = 0;\n\n\t\tif (!acpi_evalf(hkey_handle, &m, \"DHKN\", \"d\"))\n\t\t\treturn -EIO;\n\n\t\thotkey_acpi_mask = m;\n\t} else {\n\t\t \n\t\thotkey_acpi_mask = hotkey_all_mask;\n\t}\n\n\t \n\thotkey_user_mask &= (hotkey_acpi_mask | hotkey_source_mask);\n\n\treturn 0;\n}\n\nstatic void hotkey_mask_warn_incomplete_mask(void)\n{\n\t \n\tconst u32 wantedmask = hotkey_driver_mask &\n\t\t~(hotkey_acpi_mask | hotkey_source_mask) &\n\t\t(hotkey_all_mask | TPACPI_HKEY_NVRAM_KNOWN_MASK);\n\n\tif (wantedmask)\n\t\tpr_notice(\"required events 0x%08x not enabled!\\n\", wantedmask);\n}\n\n \nstatic int hotkey_mask_set(u32 mask)\n{\n\tint i;\n\tint rc = 0;\n\n\tconst u32 fwmask = mask & ~hotkey_source_mask;\n\n\tlockdep_assert_held(&hotkey_mutex);\n\n\tif (tp_features.hotkey_mask) {\n\t\tfor (i = 0; i < 32; i++) {\n\t\t\tif (!acpi_evalf(hkey_handle,\n\t\t\t\t\tNULL, \"MHKM\", \"vdd\", i + 1,\n\t\t\t\t\t!!(mask & (1 << i)))) {\n\t\t\t\trc = -EIO;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (!hotkey_mask_get() && !rc && (fwmask & ~hotkey_acpi_mask)) {\n\t\tpr_notice(\"asked for hotkey mask 0x%08x, but firmware forced it to 0x%08x\\n\",\n\t\t\t  fwmask, hotkey_acpi_mask);\n\t}\n\n\tif (tpacpi_lifecycle != TPACPI_LIFE_EXITING)\n\t\thotkey_mask_warn_incomplete_mask();\n\n\treturn rc;\n}\n\n \nstatic int hotkey_user_mask_set(const u32 mask)\n{\n\tint rc;\n\n\tlockdep_assert_held(&hotkey_mutex);\n\n\t \n\tif (!tp_warned.hotkey_mask_ff &&\n\t    (mask == 0xffff || mask == 0xffffff ||\n\t     mask == 0xffffffff)) {\n\t\ttp_warned.hotkey_mask_ff = 1;\n\t\tpr_notice(\"setting the hotkey mask to 0x%08x is likely not the best way to go about it\\n\",\n\t\t\t  mask);\n\t\tpr_notice(\"please consider using the driver defaults, and refer to up-to-date thinkpad-acpi documentation\\n\");\n\t}\n\n\t \n\trc = hotkey_mask_set((mask | hotkey_driver_mask) & ~hotkey_source_mask);\n\n\t \n\thotkey_user_mask = mask & (hotkey_acpi_mask | hotkey_source_mask);\n\n\treturn rc;\n}\n\n \nstatic int tpacpi_hotkey_driver_mask_set(const u32 mask)\n{\n\tint rc;\n\n\t \n\tif (!tp_features.hotkey) {\n\t\thotkey_driver_mask = mask;\n\t\treturn 0;\n\t}\n\n\tmutex_lock(&hotkey_mutex);\n\n\tHOTKEY_CONFIG_CRITICAL_START\n\thotkey_driver_mask = mask;\n#ifdef CONFIG_THINKPAD_ACPI_HOTKEY_POLL\n\thotkey_source_mask |= (mask & ~hotkey_all_mask);\n#endif\n\tHOTKEY_CONFIG_CRITICAL_END\n\n\trc = hotkey_mask_set((hotkey_acpi_mask | hotkey_driver_mask) &\n\t\t\t\t\t\t\t~hotkey_source_mask);\n\thotkey_poll_setup(true);\n\n\tmutex_unlock(&hotkey_mutex);\n\n\treturn rc;\n}\n\nstatic int hotkey_status_get(int *status)\n{\n\tif (!acpi_evalf(hkey_handle, status, \"DHKC\", \"d\"))\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic int hotkey_status_set(bool enable)\n{\n\tif (!acpi_evalf(hkey_handle, NULL, \"MHKC\", \"vd\", enable ? 1 : 0))\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic void tpacpi_input_send_tabletsw(void)\n{\n\tint state;\n\n\tif (tp_features.hotkey_tablet &&\n\t    !hotkey_get_tablet_mode(&state)) {\n\t\tmutex_lock(&tpacpi_inputdev_send_mutex);\n\n\t\tinput_report_switch(tpacpi_inputdev,\n\t\t\t\t    SW_TABLET_MODE, !!state);\n\t\tinput_sync(tpacpi_inputdev);\n\n\t\tmutex_unlock(&tpacpi_inputdev_send_mutex);\n\t}\n}\n\n \nstatic void tpacpi_input_send_key(const unsigned int scancode)\n{\n\tconst unsigned int keycode = hotkey_keycode_map[scancode];\n\n\tif (keycode != KEY_RESERVED) {\n\t\tmutex_lock(&tpacpi_inputdev_send_mutex);\n\n\t\tinput_event(tpacpi_inputdev, EV_MSC, MSC_SCAN, scancode);\n\t\tinput_report_key(tpacpi_inputdev, keycode, 1);\n\t\tinput_sync(tpacpi_inputdev);\n\n\t\tinput_event(tpacpi_inputdev, EV_MSC, MSC_SCAN, scancode);\n\t\tinput_report_key(tpacpi_inputdev, keycode, 0);\n\t\tinput_sync(tpacpi_inputdev);\n\n\t\tmutex_unlock(&tpacpi_inputdev_send_mutex);\n\t}\n}\n\n \nstatic void tpacpi_input_send_key_masked(const unsigned int scancode)\n{\n\thotkey_driver_event(scancode);\n\tif (hotkey_user_mask & (1 << scancode))\n\t\ttpacpi_input_send_key(scancode);\n}\n\n#ifdef CONFIG_THINKPAD_ACPI_HOTKEY_POLL\nstatic struct tp_acpi_drv_struct ibm_hotkey_acpidriver;\n\n \nstatic void tpacpi_hotkey_send_key(unsigned int scancode)\n{\n\ttpacpi_input_send_key_masked(scancode);\n}\n\nstatic void hotkey_read_nvram(struct tp_nvram_state *n, const u32 m)\n{\n\tu8 d;\n\n\tif (m & TP_NVRAM_HKEY_GROUP_HK2) {\n\t\td = nvram_read_byte(TP_NVRAM_ADDR_HK2);\n\t\tn->thinkpad_toggle = !!(d & TP_NVRAM_MASK_HKT_THINKPAD);\n\t\tn->zoom_toggle = !!(d & TP_NVRAM_MASK_HKT_ZOOM);\n\t\tn->display_toggle = !!(d & TP_NVRAM_MASK_HKT_DISPLAY);\n\t\tn->hibernate_toggle = !!(d & TP_NVRAM_MASK_HKT_HIBERNATE);\n\t}\n\tif (m & TP_ACPI_HKEY_KBD_LIGHT_MASK) {\n\t\td = nvram_read_byte(TP_NVRAM_ADDR_THINKLIGHT);\n\t\tn->thinklight_toggle = !!(d & TP_NVRAM_MASK_THINKLIGHT);\n\t}\n\tif (m & TP_ACPI_HKEY_DISPXPAND_MASK) {\n\t\td = nvram_read_byte(TP_NVRAM_ADDR_VIDEO);\n\t\tn->displayexp_toggle =\n\t\t\t\t!!(d & TP_NVRAM_MASK_HKT_DISPEXPND);\n\t}\n\tif (m & TP_NVRAM_HKEY_GROUP_BRIGHTNESS) {\n\t\td = nvram_read_byte(TP_NVRAM_ADDR_BRIGHTNESS);\n\t\tn->brightness_level = (d & TP_NVRAM_MASK_LEVEL_BRIGHTNESS)\n\t\t\t\t>> TP_NVRAM_POS_LEVEL_BRIGHTNESS;\n\t\tn->brightness_toggle =\n\t\t\t\t!!(d & TP_NVRAM_MASK_HKT_BRIGHTNESS);\n\t}\n\tif (m & TP_NVRAM_HKEY_GROUP_VOLUME) {\n\t\td = nvram_read_byte(TP_NVRAM_ADDR_MIXER);\n\t\tn->volume_level = (d & TP_NVRAM_MASK_LEVEL_VOLUME)\n\t\t\t\t>> TP_NVRAM_POS_LEVEL_VOLUME;\n\t\tn->mute = !!(d & TP_NVRAM_MASK_MUTE);\n\t\tn->volume_toggle = !!(d & TP_NVRAM_MASK_HKT_VOLUME);\n\t}\n}\n\n#define TPACPI_COMPARE_KEY(__scancode, __member) \\\ndo { \\\n\tif ((event_mask & (1 << __scancode)) && \\\n\t    oldn->__member != newn->__member) \\\n\t\ttpacpi_hotkey_send_key(__scancode); \\\n} while (0)\n\n#define TPACPI_MAY_SEND_KEY(__scancode) \\\ndo { \\\n\tif (event_mask & (1 << __scancode)) \\\n\t\ttpacpi_hotkey_send_key(__scancode); \\\n} while (0)\n\nstatic void issue_volchange(const unsigned int oldvol,\n\t\t\t    const unsigned int newvol,\n\t\t\t    const u32 event_mask)\n{\n\tunsigned int i = oldvol;\n\n\twhile (i > newvol) {\n\t\tTPACPI_MAY_SEND_KEY(TP_ACPI_HOTKEYSCAN_VOLUMEDOWN);\n\t\ti--;\n\t}\n\twhile (i < newvol) {\n\t\tTPACPI_MAY_SEND_KEY(TP_ACPI_HOTKEYSCAN_VOLUMEUP);\n\t\ti++;\n\t}\n}\n\nstatic void issue_brightnesschange(const unsigned int oldbrt,\n\t\t\t\t   const unsigned int newbrt,\n\t\t\t\t   const u32 event_mask)\n{\n\tunsigned int i = oldbrt;\n\n\twhile (i > newbrt) {\n\t\tTPACPI_MAY_SEND_KEY(TP_ACPI_HOTKEYSCAN_FNEND);\n\t\ti--;\n\t}\n\twhile (i < newbrt) {\n\t\tTPACPI_MAY_SEND_KEY(TP_ACPI_HOTKEYSCAN_FNHOME);\n\t\ti++;\n\t}\n}\n\nstatic void hotkey_compare_and_issue_event(struct tp_nvram_state *oldn,\n\t\t\t\t\t   struct tp_nvram_state *newn,\n\t\t\t\t\t   const u32 event_mask)\n{\n\n\tTPACPI_COMPARE_KEY(TP_ACPI_HOTKEYSCAN_THINKPAD, thinkpad_toggle);\n\tTPACPI_COMPARE_KEY(TP_ACPI_HOTKEYSCAN_FNSPACE, zoom_toggle);\n\tTPACPI_COMPARE_KEY(TP_ACPI_HOTKEYSCAN_FNF7, display_toggle);\n\tTPACPI_COMPARE_KEY(TP_ACPI_HOTKEYSCAN_FNF12, hibernate_toggle);\n\n\tTPACPI_COMPARE_KEY(TP_ACPI_HOTKEYSCAN_FNPAGEUP, thinklight_toggle);\n\n\tTPACPI_COMPARE_KEY(TP_ACPI_HOTKEYSCAN_FNF8, displayexp_toggle);\n\n\t \n\tif (newn->mute) {\n\t\t \n\t\tif (!oldn->mute ||\n\t\t    oldn->volume_toggle != newn->volume_toggle ||\n\t\t    oldn->volume_level != newn->volume_level) {\n\t\t\t \n\t\t\tissue_volchange(oldn->volume_level, newn->volume_level,\n\t\t\t\tevent_mask);\n\t\t\tTPACPI_MAY_SEND_KEY(TP_ACPI_HOTKEYSCAN_MUTE);\n\t\t}\n\t} else {\n\t\t \n\t\tif (oldn->mute) {\n\t\t\t \n\t\t\tTPACPI_MAY_SEND_KEY(TP_ACPI_HOTKEYSCAN_VOLUMEUP);\n\t\t}\n\t\tif (oldn->volume_level != newn->volume_level) {\n\t\t\tissue_volchange(oldn->volume_level, newn->volume_level,\n\t\t\t\tevent_mask);\n\t\t} else if (oldn->volume_toggle != newn->volume_toggle) {\n\t\t\t \n\t\t\tif (newn->volume_level == 0)\n\t\t\t\tTPACPI_MAY_SEND_KEY(TP_ACPI_HOTKEYSCAN_VOLUMEDOWN);\n\t\t\telse if (newn->volume_level >= TP_NVRAM_LEVEL_VOLUME_MAX)\n\t\t\t\tTPACPI_MAY_SEND_KEY(TP_ACPI_HOTKEYSCAN_VOLUMEUP);\n\t\t}\n\t}\n\n\t \n\tif (oldn->brightness_level != newn->brightness_level) {\n\t\tissue_brightnesschange(oldn->brightness_level,\n\t\t\t\t       newn->brightness_level, event_mask);\n\t} else if (oldn->brightness_toggle != newn->brightness_toggle) {\n\t\t \n\t\tif (newn->brightness_level == 0)\n\t\t\tTPACPI_MAY_SEND_KEY(TP_ACPI_HOTKEYSCAN_FNEND);\n\t\telse if (newn->brightness_level >= bright_maxlvl\n\t\t\t\t&& !tp_features.bright_unkfw)\n\t\t\tTPACPI_MAY_SEND_KEY(TP_ACPI_HOTKEYSCAN_FNHOME);\n\t}\n\n#undef TPACPI_COMPARE_KEY\n#undef TPACPI_MAY_SEND_KEY\n}\n\n \nstatic int hotkey_kthread(void *data)\n{\n\tstruct tp_nvram_state s[2] = { 0 };\n\tu32 poll_mask, event_mask;\n\tunsigned int si, so;\n\tunsigned long t;\n\tunsigned int change_detector;\n\tunsigned int poll_freq;\n\tbool was_frozen;\n\n\tif (tpacpi_lifecycle == TPACPI_LIFE_EXITING)\n\t\tgoto exit;\n\n\tset_freezable();\n\n\tso = 0;\n\tsi = 1;\n\tt = 0;\n\n\t \n\tmutex_lock(&hotkey_thread_data_mutex);\n\tchange_detector = hotkey_config_change;\n\tpoll_mask = hotkey_source_mask;\n\tevent_mask = hotkey_source_mask &\n\t\t\t(hotkey_driver_mask | hotkey_user_mask);\n\tpoll_freq = hotkey_poll_freq;\n\tmutex_unlock(&hotkey_thread_data_mutex);\n\thotkey_read_nvram(&s[so], poll_mask);\n\n\twhile (!kthread_should_stop()) {\n\t\tif (t == 0) {\n\t\t\tif (likely(poll_freq))\n\t\t\t\tt = 1000/poll_freq;\n\t\t\telse\n\t\t\t\tt = 100;\t \n\t\t}\n\t\tt = msleep_interruptible(t);\n\t\tif (unlikely(kthread_freezable_should_stop(&was_frozen)))\n\t\t\tbreak;\n\n\t\tif (t > 0 && !was_frozen)\n\t\t\tcontinue;\n\n\t\tmutex_lock(&hotkey_thread_data_mutex);\n\t\tif (was_frozen || hotkey_config_change != change_detector) {\n\t\t\t \n\t\t\tsi = so;\n\t\t\tt = 0;\n\t\t\tchange_detector = hotkey_config_change;\n\t\t}\n\t\tpoll_mask = hotkey_source_mask;\n\t\tevent_mask = hotkey_source_mask &\n\t\t\t\t(hotkey_driver_mask | hotkey_user_mask);\n\t\tpoll_freq = hotkey_poll_freq;\n\t\tmutex_unlock(&hotkey_thread_data_mutex);\n\n\t\tif (likely(poll_mask)) {\n\t\t\thotkey_read_nvram(&s[si], poll_mask);\n\t\t\tif (likely(si != so)) {\n\t\t\t\thotkey_compare_and_issue_event(&s[so], &s[si],\n\t\t\t\t\t\t\t\tevent_mask);\n\t\t\t}\n\t\t}\n\n\t\tso = si;\n\t\tsi ^= 1;\n\t}\n\nexit:\n\treturn 0;\n}\n\nstatic void hotkey_poll_stop_sync(void)\n{\n\tlockdep_assert_held(&hotkey_mutex);\n\n\tif (tpacpi_hotkey_task) {\n\t\tkthread_stop(tpacpi_hotkey_task);\n\t\ttpacpi_hotkey_task = NULL;\n\t}\n}\n\nstatic void hotkey_poll_setup(const bool may_warn)\n{\n\tconst u32 poll_driver_mask = hotkey_driver_mask & hotkey_source_mask;\n\tconst u32 poll_user_mask = hotkey_user_mask & hotkey_source_mask;\n\n\tlockdep_assert_held(&hotkey_mutex);\n\n\tif (hotkey_poll_freq > 0 &&\n\t    (poll_driver_mask ||\n\t     (poll_user_mask && tpacpi_inputdev->users > 0))) {\n\t\tif (!tpacpi_hotkey_task) {\n\t\t\ttpacpi_hotkey_task = kthread_run(hotkey_kthread,\n\t\t\t\t\tNULL, TPACPI_NVRAM_KTHREAD_NAME);\n\t\t\tif (IS_ERR(tpacpi_hotkey_task)) {\n\t\t\t\ttpacpi_hotkey_task = NULL;\n\t\t\t\tpr_err(\"could not create kernel thread for hotkey polling\\n\");\n\t\t\t}\n\t\t}\n\t} else {\n\t\thotkey_poll_stop_sync();\n\t\tif (may_warn && (poll_driver_mask || poll_user_mask) &&\n\t\t    hotkey_poll_freq == 0) {\n\t\t\tpr_notice(\"hot keys 0x%08x and/or events 0x%08x require polling, which is currently disabled\\n\",\n\t\t\t\t  poll_user_mask, poll_driver_mask);\n\t\t}\n\t}\n}\n\nstatic void hotkey_poll_setup_safe(const bool may_warn)\n{\n\tmutex_lock(&hotkey_mutex);\n\thotkey_poll_setup(may_warn);\n\tmutex_unlock(&hotkey_mutex);\n}\n\nstatic void hotkey_poll_set_freq(unsigned int freq)\n{\n\tlockdep_assert_held(&hotkey_mutex);\n\n\tif (!freq)\n\t\thotkey_poll_stop_sync();\n\n\thotkey_poll_freq = freq;\n}\n\n#else  \n\nstatic void hotkey_poll_setup(const bool __unused)\n{\n}\n\nstatic void hotkey_poll_setup_safe(const bool __unused)\n{\n}\n\n#endif  \n\nstatic int hotkey_inputdev_open(struct input_dev *dev)\n{\n\tswitch (tpacpi_lifecycle) {\n\tcase TPACPI_LIFE_INIT:\n\tcase TPACPI_LIFE_RUNNING:\n\t\thotkey_poll_setup_safe(false);\n\t\treturn 0;\n\tcase TPACPI_LIFE_EXITING:\n\t\treturn -EBUSY;\n\t}\n\n\t \n\tBUG();\n\treturn -EBUSY;\n}\n\nstatic void hotkey_inputdev_close(struct input_dev *dev)\n{\n\t \n\tif (tpacpi_lifecycle != TPACPI_LIFE_EXITING &&\n\t    !(hotkey_source_mask & hotkey_driver_mask))\n\t\thotkey_poll_setup_safe(false);\n}\n\n \nstatic ssize_t hotkey_enable_show(struct device *dev,\n\t\t\t   struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\tint res, status;\n\n\tprintk_deprecated_attribute(\"hotkey_enable\",\n\t\t\t\"Hotkey reporting is always enabled\");\n\n\tres = hotkey_status_get(&status);\n\tif (res)\n\t\treturn res;\n\n\treturn sysfs_emit(buf, \"%d\\n\", status);\n}\n\nstatic ssize_t hotkey_enable_store(struct device *dev,\n\t\t\t    struct device_attribute *attr,\n\t\t\t    const char *buf, size_t count)\n{\n\tunsigned long t;\n\n\tprintk_deprecated_attribute(\"hotkey_enable\",\n\t\t\t\"Hotkeys can be disabled through hotkey_mask\");\n\n\tif (parse_strtoul(buf, 1, &t))\n\t\treturn -EINVAL;\n\n\tif (t == 0)\n\t\treturn -EPERM;\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR_RW(hotkey_enable);\n\n \nstatic ssize_t hotkey_mask_show(struct device *dev,\n\t\t\t   struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\treturn sysfs_emit(buf, \"0x%08x\\n\", hotkey_user_mask);\n}\n\nstatic ssize_t hotkey_mask_store(struct device *dev,\n\t\t\t    struct device_attribute *attr,\n\t\t\t    const char *buf, size_t count)\n{\n\tunsigned long t;\n\tint res;\n\n\tif (parse_strtoul(buf, 0xffffffffUL, &t))\n\t\treturn -EINVAL;\n\n\tif (mutex_lock_killable(&hotkey_mutex))\n\t\treturn -ERESTARTSYS;\n\n\tres = hotkey_user_mask_set(t);\n\n#ifdef CONFIG_THINKPAD_ACPI_HOTKEY_POLL\n\thotkey_poll_setup(true);\n#endif\n\n\tmutex_unlock(&hotkey_mutex);\n\n\ttpacpi_disclose_usertask(\"hotkey_mask\", \"set to 0x%08lx\\n\", t);\n\n\treturn (res) ? res : count;\n}\n\nstatic DEVICE_ATTR_RW(hotkey_mask);\n\n \nstatic ssize_t hotkey_bios_enabled_show(struct device *dev,\n\t\t\t   struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\treturn sprintf(buf, \"0\\n\");\n}\n\nstatic DEVICE_ATTR_RO(hotkey_bios_enabled);\n\n \nstatic ssize_t hotkey_bios_mask_show(struct device *dev,\n\t\t\t   struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\tprintk_deprecated_attribute(\"hotkey_bios_mask\",\n\t\t\t\"This attribute is useless.\");\n\treturn sysfs_emit(buf, \"0x%08x\\n\", hotkey_orig_mask);\n}\n\nstatic DEVICE_ATTR_RO(hotkey_bios_mask);\n\n \nstatic ssize_t hotkey_all_mask_show(struct device *dev,\n\t\t\t   struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\treturn sysfs_emit(buf, \"0x%08x\\n\",\n\t\t\t\thotkey_all_mask | hotkey_source_mask);\n}\n\nstatic DEVICE_ATTR_RO(hotkey_all_mask);\n\n \nstatic ssize_t hotkey_adaptive_all_mask_show(struct device *dev,\n\t\t\t   struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\treturn sysfs_emit(buf, \"0x%08x\\n\",\n\t\t\thotkey_adaptive_all_mask | hotkey_source_mask);\n}\n\nstatic DEVICE_ATTR_RO(hotkey_adaptive_all_mask);\n\n \nstatic ssize_t hotkey_recommended_mask_show(struct device *dev,\n\t\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t\t    char *buf)\n{\n\treturn sysfs_emit(buf, \"0x%08x\\n\",\n\t\t\t(hotkey_all_mask | hotkey_source_mask)\n\t\t\t& ~hotkey_reserved_mask);\n}\n\nstatic DEVICE_ATTR_RO(hotkey_recommended_mask);\n\n#ifdef CONFIG_THINKPAD_ACPI_HOTKEY_POLL\n\n \nstatic ssize_t hotkey_source_mask_show(struct device *dev,\n\t\t\t   struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\treturn sysfs_emit(buf, \"0x%08x\\n\", hotkey_source_mask);\n}\n\nstatic ssize_t hotkey_source_mask_store(struct device *dev,\n\t\t\t    struct device_attribute *attr,\n\t\t\t    const char *buf, size_t count)\n{\n\tunsigned long t;\n\tu32 r_ev;\n\tint rc;\n\n\tif (parse_strtoul(buf, 0xffffffffUL, &t) ||\n\t\t((t & ~TPACPI_HKEY_NVRAM_KNOWN_MASK) != 0))\n\t\treturn -EINVAL;\n\n\tif (mutex_lock_killable(&hotkey_mutex))\n\t\treturn -ERESTARTSYS;\n\n\tHOTKEY_CONFIG_CRITICAL_START\n\thotkey_source_mask = t;\n\tHOTKEY_CONFIG_CRITICAL_END\n\n\trc = hotkey_mask_set((hotkey_user_mask | hotkey_driver_mask) &\n\t\t\t~hotkey_source_mask);\n\thotkey_poll_setup(true);\n\n\t \n\tr_ev = hotkey_driver_mask & ~(hotkey_acpi_mask & hotkey_all_mask)\n\t\t& ~hotkey_source_mask & TPACPI_HKEY_NVRAM_KNOWN_MASK;\n\n\tmutex_unlock(&hotkey_mutex);\n\n\tif (rc < 0)\n\t\tpr_err(\"hotkey_source_mask: failed to update the firmware event mask!\\n\");\n\n\tif (r_ev)\n\t\tpr_notice(\"hotkey_source_mask: some important events were disabled: 0x%04x\\n\",\n\t\t\t  r_ev);\n\n\ttpacpi_disclose_usertask(\"hotkey_source_mask\", \"set to 0x%08lx\\n\", t);\n\n\treturn (rc < 0) ? rc : count;\n}\n\nstatic DEVICE_ATTR_RW(hotkey_source_mask);\n\n \nstatic ssize_t hotkey_poll_freq_show(struct device *dev,\n\t\t\t   struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\treturn sysfs_emit(buf, \"%d\\n\", hotkey_poll_freq);\n}\n\nstatic ssize_t hotkey_poll_freq_store(struct device *dev,\n\t\t\t    struct device_attribute *attr,\n\t\t\t    const char *buf, size_t count)\n{\n\tunsigned long t;\n\n\tif (parse_strtoul(buf, 25, &t))\n\t\treturn -EINVAL;\n\n\tif (mutex_lock_killable(&hotkey_mutex))\n\t\treturn -ERESTARTSYS;\n\n\thotkey_poll_set_freq(t);\n\thotkey_poll_setup(true);\n\n\tmutex_unlock(&hotkey_mutex);\n\n\ttpacpi_disclose_usertask(\"hotkey_poll_freq\", \"set to %lu\\n\", t);\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR_RW(hotkey_poll_freq);\n\n#endif  \n\n \nstatic ssize_t hotkey_radio_sw_show(struct device *dev,\n\t\t\t   struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\tint res;\n\tres = hotkey_get_wlsw();\n\tif (res < 0)\n\t\treturn res;\n\n\t \n\ttpacpi_rfk_update_hwblock_state((res == TPACPI_RFK_RADIO_OFF));\n\n\treturn sysfs_emit(buf, \"%d\\n\",\n\t\t\t(res == TPACPI_RFK_RADIO_OFF) ? 0 : 1);\n}\n\nstatic DEVICE_ATTR_RO(hotkey_radio_sw);\n\nstatic void hotkey_radio_sw_notify_change(void)\n{\n\tif (tp_features.hotkey_wlsw)\n\t\tsysfs_notify(&tpacpi_pdev->dev.kobj, NULL,\n\t\t\t     \"hotkey_radio_sw\");\n}\n\n \nstatic ssize_t hotkey_tablet_mode_show(struct device *dev,\n\t\t\t   struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\tint res, s;\n\tres = hotkey_get_tablet_mode(&s);\n\tif (res < 0)\n\t\treturn res;\n\n\treturn sysfs_emit(buf, \"%d\\n\", !!s);\n}\n\nstatic DEVICE_ATTR_RO(hotkey_tablet_mode);\n\nstatic void hotkey_tablet_mode_notify_change(void)\n{\n\tif (tp_features.hotkey_tablet)\n\t\tsysfs_notify(&tpacpi_pdev->dev.kobj, NULL,\n\t\t\t     \"hotkey_tablet_mode\");\n}\n\n \nstatic ssize_t hotkey_wakeup_reason_show(struct device *dev,\n\t\t\t   struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\treturn sysfs_emit(buf, \"%d\\n\", hotkey_wakeup_reason);\n}\n\nstatic DEVICE_ATTR(wakeup_reason, S_IRUGO, hotkey_wakeup_reason_show, NULL);\n\nstatic void hotkey_wakeup_reason_notify_change(void)\n{\n\tsysfs_notify(&tpacpi_pdev->dev.kobj, NULL,\n\t\t     \"wakeup_reason\");\n}\n\n \nstatic ssize_t hotkey_wakeup_hotunplug_complete_show(struct device *dev,\n\t\t\t   struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\treturn sysfs_emit(buf, \"%d\\n\", hotkey_autosleep_ack);\n}\n\nstatic DEVICE_ATTR(wakeup_hotunplug_complete, S_IRUGO,\n\t\t   hotkey_wakeup_hotunplug_complete_show, NULL);\n\nstatic void hotkey_wakeup_hotunplug_complete_notify_change(void)\n{\n\tsysfs_notify(&tpacpi_pdev->dev.kobj, NULL,\n\t\t     \"wakeup_hotunplug_complete\");\n}\n\n \n\nstatic int adaptive_keyboard_get_mode(void);\nstatic int adaptive_keyboard_set_mode(int new_mode);\n\nenum ADAPTIVE_KEY_MODE {\n\tHOME_MODE,\n\tWEB_BROWSER_MODE,\n\tWEB_CONFERENCE_MODE,\n\tFUNCTION_MODE,\n\tLAYFLAT_MODE\n};\n\nstatic ssize_t adaptive_kbd_mode_show(struct device *dev,\n\t\t\t   struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\tint current_mode;\n\n\tcurrent_mode = adaptive_keyboard_get_mode();\n\tif (current_mode < 0)\n\t\treturn current_mode;\n\n\treturn sysfs_emit(buf, \"%d\\n\", current_mode);\n}\n\nstatic ssize_t adaptive_kbd_mode_store(struct device *dev,\n\t\t\t    struct device_attribute *attr,\n\t\t\t    const char *buf, size_t count)\n{\n\tunsigned long t;\n\tint res;\n\n\tif (parse_strtoul(buf, LAYFLAT_MODE, &t))\n\t\treturn -EINVAL;\n\n\tres = adaptive_keyboard_set_mode(t);\n\treturn (res < 0) ? res : count;\n}\n\nstatic DEVICE_ATTR_RW(adaptive_kbd_mode);\n\nstatic struct attribute *adaptive_kbd_attributes[] = {\n\t&dev_attr_adaptive_kbd_mode.attr,\n\tNULL\n};\n\nstatic umode_t hadaptive_kbd_attr_is_visible(struct kobject *kobj,\n\t\t\t\t\t     struct attribute *attr, int n)\n{\n\treturn tp_features.has_adaptive_kbd ? attr->mode : 0;\n}\n\nstatic const struct attribute_group adaptive_kbd_attr_group = {\n\t.is_visible = hadaptive_kbd_attr_is_visible,\n\t.attrs = adaptive_kbd_attributes,\n};\n\n \n\nstatic struct attribute *hotkey_attributes[] = {\n\t&dev_attr_hotkey_enable.attr,\n\t&dev_attr_hotkey_bios_enabled.attr,\n\t&dev_attr_hotkey_bios_mask.attr,\n\t&dev_attr_wakeup_reason.attr,\n\t&dev_attr_wakeup_hotunplug_complete.attr,\n\t&dev_attr_hotkey_mask.attr,\n\t&dev_attr_hotkey_all_mask.attr,\n\t&dev_attr_hotkey_adaptive_all_mask.attr,\n\t&dev_attr_hotkey_recommended_mask.attr,\n\t&dev_attr_hotkey_tablet_mode.attr,\n\t&dev_attr_hotkey_radio_sw.attr,\n#ifdef CONFIG_THINKPAD_ACPI_HOTKEY_POLL\n\t&dev_attr_hotkey_source_mask.attr,\n\t&dev_attr_hotkey_poll_freq.attr,\n#endif\n\tNULL\n};\n\nstatic umode_t hotkey_attr_is_visible(struct kobject *kobj,\n\t\t\t\t      struct attribute *attr, int n)\n{\n\tif (attr == &dev_attr_hotkey_tablet_mode.attr) {\n\t\tif (!tp_features.hotkey_tablet)\n\t\t\treturn 0;\n\t} else if (attr == &dev_attr_hotkey_radio_sw.attr) {\n\t\tif (!tp_features.hotkey_wlsw)\n\t\t\treturn 0;\n\t}\n\n\treturn attr->mode;\n}\n\nstatic const struct attribute_group hotkey_attr_group = {\n\t.is_visible = hotkey_attr_is_visible,\n\t.attrs = hotkey_attributes,\n};\n\n \nstatic void tpacpi_send_radiosw_update(void)\n{\n\tint wlsw;\n\n\t \n\n\twlsw = hotkey_get_wlsw();\n\n\t \n\tif (wlsw == TPACPI_RFK_RADIO_OFF)\n\t\ttpacpi_rfk_update_hwblock_state(true);\n\n\t \n\tif (wlsw == TPACPI_RFK_RADIO_ON)\n\t\ttpacpi_rfk_update_hwblock_state(false);\n\n\t \n\tif (!(wlsw < 0)) {\n\t\tmutex_lock(&tpacpi_inputdev_send_mutex);\n\n\t\tinput_report_switch(tpacpi_inputdev,\n\t\t\t\t    SW_RFKILL_ALL, (wlsw > 0));\n\t\tinput_sync(tpacpi_inputdev);\n\n\t\tmutex_unlock(&tpacpi_inputdev_send_mutex);\n\t}\n\n\t \n\thotkey_radio_sw_notify_change();\n}\n\nstatic void hotkey_exit(void)\n{\n#ifdef CONFIG_THINKPAD_ACPI_HOTKEY_POLL\n\tmutex_lock(&hotkey_mutex);\n\thotkey_poll_stop_sync();\n\tmutex_unlock(&hotkey_mutex);\n#endif\n\tdbg_printk(TPACPI_DBG_EXIT | TPACPI_DBG_HKEY,\n\t\t   \"restoring original HKEY status and mask\\n\");\n\t \n\tif (((tp_features.hotkey_mask &&\n\t      hotkey_mask_set(hotkey_orig_mask)) |\n\t     hotkey_status_set(false)) != 0)\n\t\tpr_err(\"failed to restore hot key mask to BIOS defaults\\n\");\n}\n\nstatic void __init hotkey_unmap(const unsigned int scancode)\n{\n\tif (hotkey_keycode_map[scancode] != KEY_RESERVED) {\n\t\tclear_bit(hotkey_keycode_map[scancode],\n\t\t\t  tpacpi_inputdev->keybit);\n\t\thotkey_keycode_map[scancode] = KEY_RESERVED;\n\t}\n}\n\n \n\n#define\tTPACPI_HK_Q_INIMASK\t0x0001\n\nstatic const struct tpacpi_quirk tpacpi_hotkey_qtable[] __initconst = {\n\tTPACPI_Q_IBM('I', 'H', TPACPI_HK_Q_INIMASK),  \n\tTPACPI_Q_IBM('I', 'N', TPACPI_HK_Q_INIMASK),  \n\tTPACPI_Q_IBM('I', 'D', TPACPI_HK_Q_INIMASK),  \n\tTPACPI_Q_IBM('I', 'W', TPACPI_HK_Q_INIMASK),  \n\tTPACPI_Q_IBM('I', 'V', TPACPI_HK_Q_INIMASK),  \n\tTPACPI_Q_IBM('1', '0', TPACPI_HK_Q_INIMASK),  \n\tTPACPI_Q_IBM('K', 'U', TPACPI_HK_Q_INIMASK),  \n\tTPACPI_Q_IBM('K', 'X', TPACPI_HK_Q_INIMASK),  \n\tTPACPI_Q_IBM('K', 'Y', TPACPI_HK_Q_INIMASK),  \n\tTPACPI_Q_IBM('1', 'B', TPACPI_HK_Q_INIMASK),  \n\tTPACPI_Q_IBM('1', '3', TPACPI_HK_Q_INIMASK),  \n\tTPACPI_Q_IBM('1', 'E', TPACPI_HK_Q_INIMASK),  \n\tTPACPI_Q_IBM('1', 'C', TPACPI_HK_Q_INIMASK),  \n\tTPACPI_Q_IBM('1', 'F', TPACPI_HK_Q_INIMASK),  \n\tTPACPI_Q_IBM('I', 'Y', TPACPI_HK_Q_INIMASK),  \n\tTPACPI_Q_IBM('K', 'Z', TPACPI_HK_Q_INIMASK),  \n\tTPACPI_Q_IBM('1', '6', TPACPI_HK_Q_INIMASK),  \n\tTPACPI_Q_IBM('I', 'Z', TPACPI_HK_Q_INIMASK),  \n\tTPACPI_Q_IBM('1', 'D', TPACPI_HK_Q_INIMASK),  \n};\n\ntypedef u16 tpacpi_keymap_entry_t;\ntypedef tpacpi_keymap_entry_t tpacpi_keymap_t[TPACPI_HOTKEY_MAP_LEN];\n\nstatic int hotkey_init_tablet_mode(void)\n{\n\tint in_tablet_mode = 0, res;\n\tchar *type = NULL;\n\n\tif (acpi_evalf(hkey_handle, &res, \"GMMS\", \"qdd\", 0)) {\n\t\tint has_tablet_mode;\n\n\t\tin_tablet_mode = hotkey_gmms_get_tablet_mode(res,\n\t\t\t\t\t\t\t     &has_tablet_mode);\n\t\t \n\t\tif (has_tablet_mode && !dual_accel_detect())\n\t\t\ttp_features.hotkey_tablet = TP_HOTKEY_TABLET_USES_GMMS;\n\t\ttype = \"GMMS\";\n\t} else if (acpi_evalf(hkey_handle, &res, \"MHKG\", \"qd\")) {\n\t\t \n\t\ttp_features.hotkey_tablet = TP_HOTKEY_TABLET_USES_MHKG;\n\t\tin_tablet_mode = !!(res & TP_HOTKEY_TABLET_MASK);\n\t\ttype = \"MHKG\";\n\t}\n\n\tif (!tp_features.hotkey_tablet)\n\t\treturn 0;\n\n\tpr_info(\"Tablet mode switch found (type: %s), currently in %s mode\\n\",\n\t\ttype, in_tablet_mode ? \"tablet\" : \"laptop\");\n\n\treturn in_tablet_mode;\n}\n\nstatic int __init hotkey_init(struct ibm_init_struct *iibm)\n{\n\t \n\n\tenum keymap_index {\n\t\tTPACPI_KEYMAP_IBM_GENERIC = 0,\n\t\tTPACPI_KEYMAP_LENOVO_GENERIC,\n\t};\n\n\tstatic const tpacpi_keymap_t tpacpi_keymaps[] __initconst = {\n\t \n\t[TPACPI_KEYMAP_IBM_GENERIC] = {\n\t\t \n\t\tKEY_FN_F1,\tKEY_BATTERY,\tKEY_COFFEE,\tKEY_SLEEP,\n\t\tKEY_WLAN,\tKEY_FN_F6, KEY_SWITCHVIDEOMODE, KEY_FN_F8,\n\t\tKEY_FN_F9,\tKEY_FN_F10,\tKEY_FN_F11,\tKEY_SUSPEND,\n\n\t\t \n\t\tKEY_UNKNOWN,\t \n\t\tKEY_UNKNOWN,\t \n\t\tKEY_UNKNOWN,\t \n\n\t\t \n\t\tKEY_RESERVED,\t \n\t\tKEY_RESERVED,\t \n\n\t\t \n\t\tKEY_RESERVED,\t \n\n\t\tKEY_UNKNOWN,\t \n\t\tKEY_ZOOM,\t \n\n\t\t \n\t\tKEY_RESERVED,\t \n\t\tKEY_RESERVED,\t \n\t\tKEY_RESERVED,\t \n\n\t\tKEY_VENDOR,\t \n\n\t\t \n\t\tKEY_UNKNOWN, KEY_UNKNOWN, KEY_UNKNOWN, KEY_UNKNOWN,\n\t\tKEY_UNKNOWN, KEY_UNKNOWN, KEY_UNKNOWN, KEY_UNKNOWN,\n\n\t\t \n\t\tKEY_UNKNOWN, KEY_UNKNOWN, KEY_UNKNOWN, KEY_UNKNOWN,\n\t\tKEY_UNKNOWN, KEY_UNKNOWN, KEY_UNKNOWN, KEY_UNKNOWN,\n\t\tKEY_UNKNOWN, KEY_UNKNOWN, KEY_UNKNOWN, KEY_UNKNOWN,\n\t\tKEY_UNKNOWN, KEY_UNKNOWN, KEY_UNKNOWN, KEY_UNKNOWN,\n\t\tKEY_UNKNOWN, KEY_UNKNOWN, KEY_UNKNOWN,\n\n\t\t \n\t\tKEY_UNKNOWN, KEY_UNKNOWN, KEY_UNKNOWN, KEY_UNKNOWN,\n\t\tKEY_UNKNOWN, KEY_UNKNOWN, KEY_UNKNOWN, KEY_UNKNOWN,\n\t\tKEY_UNKNOWN, KEY_UNKNOWN, KEY_UNKNOWN, KEY_UNKNOWN,\n\t\tKEY_UNKNOWN, KEY_UNKNOWN, KEY_UNKNOWN, KEY_UNKNOWN,\n\t\tKEY_UNKNOWN, KEY_UNKNOWN, KEY_UNKNOWN, KEY_UNKNOWN,\n\t\tKEY_UNKNOWN, KEY_UNKNOWN\n\n\t\t},\n\n\t \n\t[TPACPI_KEYMAP_LENOVO_GENERIC] = {\n\t\t \n\t\tKEY_FN_F1,\tKEY_COFFEE,\tKEY_BATTERY,\tKEY_SLEEP,\n\t\tKEY_WLAN,\tKEY_CAMERA, KEY_SWITCHVIDEOMODE, KEY_FN_F8,\n\t\tKEY_FN_F9,\tKEY_FN_F10,\tKEY_FN_F11,\tKEY_SUSPEND,\n\n\t\t \n\t\tKEY_UNKNOWN,\t \n\t\tKEY_UNKNOWN,\t \n\t\tKEY_UNKNOWN,\t \n\n\t\t \n\t\tKEY_BRIGHTNESSUP,\t \n\t\tKEY_BRIGHTNESSDOWN,\t \n\n\t\tKEY_RESERVED,\t \n\n\t\tKEY_UNKNOWN,\t \n\t\tKEY_ZOOM,\t \n\n\t\t \n\t\tKEY_RESERVED,\t \n\t\tKEY_RESERVED,\t \n\t\tKEY_RESERVED,\t \n\n\t\tKEY_VENDOR,\t \n\n\t\t \n\t\tKEY_UNKNOWN, KEY_UNKNOWN,\n\n\t\t \n\t\tKEY_MICMUTE,\t \n\n\t\t \n\t\tKEY_UNKNOWN,\n\n\t\t \n\t\tKEY_CONFIG, KEY_SEARCH, KEY_SCALE, KEY_FILE,\n\n\t\t \n\t\tKEY_RESERVED,         \n\t\tKEY_BRIGHTNESS_MIN,   \n\t\tKEY_RESERVED,         \n\t\tKEY_RESERVED,         \n\t\tKEY_RESERVED,\n\t\tKEY_VOICECOMMAND,     \n\t\tKEY_RESERVED,\n\t\tKEY_RESERVED,         \n\t\tKEY_RESERVED,\n\t\tKEY_RESERVED,\n\t\tKEY_RESERVED,\n\t\tKEY_CONFIG,           \n\t\tKEY_RESERVED,         \n\t\tKEY_REFRESH,          \n\t\tKEY_BACK,             \n\t\tKEY_RESERVED,         \n\t\tKEY_RESERVED,         \n\t\tKEY_RESERVED,         \n\t\tKEY_RESERVED,         \n\t\tKEY_RESERVED,         \n\n\t\t \n\n\t\t \n\t\tKEY_UNKNOWN, KEY_UNKNOWN, KEY_UNKNOWN, KEY_UNKNOWN,\n\t\tKEY_UNKNOWN, KEY_UNKNOWN, KEY_UNKNOWN, KEY_UNKNOWN,\n\t\tKEY_UNKNOWN, KEY_UNKNOWN, KEY_UNKNOWN, KEY_UNKNOWN,\n\t\tKEY_UNKNOWN, KEY_UNKNOWN, KEY_UNKNOWN, KEY_UNKNOWN,\n\t\tKEY_UNKNOWN,\n\n\t\tKEY_BOOKMARKS,\t\t\t \n\t\tKEY_SELECTIVE_SCREENSHOT,\t \n\t\tKEY_CALC,\t\t\t \n\t\tKEY_BLUETOOTH,\t\t\t \n\t\tKEY_KEYBOARD,\t\t\t \n\t\tKEY_FN_RIGHT_SHIFT,\t\t \n\t\tKEY_NOTIFICATION_CENTER,\t \n\t\tKEY_PICKUP_PHONE,\t\t \n\t\tKEY_HANGUP_PHONE,\t\t \n\t\t},\n\t};\n\n\tstatic const struct tpacpi_quirk tpacpi_keymap_qtable[] __initconst = {\n\t\t \n\t\t{\n\t\t  .vendor = PCI_VENDOR_ID_IBM,\n\t\t  .bios = TPACPI_MATCH_ANY, .ec = TPACPI_MATCH_ANY,\n\t\t  .quirks = TPACPI_KEYMAP_IBM_GENERIC,\n\t\t},\n\t\t{\n\t\t  .vendor = PCI_VENDOR_ID_LENOVO,\n\t\t  .bios = TPACPI_MATCH_ANY, .ec = TPACPI_MATCH_ANY,\n\t\t  .quirks = TPACPI_KEYMAP_LENOVO_GENERIC,\n\t\t},\n\t};\n\n#define TPACPI_HOTKEY_MAP_SIZE\t\tsizeof(tpacpi_keymap_t)\n#define TPACPI_HOTKEY_MAP_TYPESIZE\tsizeof(tpacpi_keymap_entry_t)\n\n\tint res, i;\n\tint status;\n\tint hkeyv;\n\tbool radiosw_state  = false;\n\tbool tabletsw_state = false;\n\n\tunsigned long quirks;\n\tunsigned long keymap_id;\n\n\tvdbg_printk(TPACPI_DBG_INIT | TPACPI_DBG_HKEY,\n\t\t\t\"initializing hotkey subdriver\\n\");\n\n\tBUG_ON(!tpacpi_inputdev);\n\tBUG_ON(tpacpi_inputdev->open != NULL ||\n\t       tpacpi_inputdev->close != NULL);\n\n\tTPACPI_ACPIHANDLE_INIT(hkey);\n\tmutex_init(&hotkey_mutex);\n\n#ifdef CONFIG_THINKPAD_ACPI_HOTKEY_POLL\n\tmutex_init(&hotkey_thread_data_mutex);\n#endif\n\n\t \n\ttp_features.hotkey = hkey_handle != NULL;\n\n\tvdbg_printk(TPACPI_DBG_INIT | TPACPI_DBG_HKEY,\n\t\t\"hotkeys are %s\\n\",\n\t\tstr_supported(tp_features.hotkey));\n\n\tif (!tp_features.hotkey)\n\t\treturn -ENODEV;\n\n\tquirks = tpacpi_check_quirks(tpacpi_hotkey_qtable,\n\t\t\t\t     ARRAY_SIZE(tpacpi_hotkey_qtable));\n\n\ttpacpi_disable_brightness_delay();\n\n\t \n\tif (acpi_evalf(hkey_handle, &hkeyv, \"MHKV\", \"qd\")) {\n\t\tvdbg_printk(TPACPI_DBG_INIT | TPACPI_DBG_HKEY,\n\t\t\t    \"firmware HKEY interface version: 0x%x\\n\",\n\t\t\t    hkeyv);\n\n\t\tswitch (hkeyv >> 8) {\n\t\tcase 1:\n\t\t\t \n\n\t\t\t \n\t\t\tif (!acpi_evalf(hkey_handle, &hotkey_all_mask,\n\t\t\t\t\t\"MHKA\", \"qd\")) {\n\t\t\t\tpr_err(\"missing MHKA handler, please report this to %s\\n\",\n\t\t\t\t       TPACPI_MAIL);\n\t\t\t\t \n\t\t\t\thotkey_all_mask = 0x080cU;\n\t\t\t} else {\n\t\t\t\ttp_features.hotkey_mask = 1;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 2:\n\t\t\t \n\n\t\t\t \n\t\t\tif (!acpi_evalf(hkey_handle, &hotkey_all_mask,\n\t\t\t\t\t\"MHKA\", \"dd\", 1)) {\n\t\t\t\tpr_err(\"missing MHKA handler, please report this to %s\\n\",\n\t\t\t\t       TPACPI_MAIL);\n\t\t\t\t \n\t\t\t\thotkey_all_mask = 0x080cU;\n\t\t\t} else {\n\t\t\t\ttp_features.hotkey_mask = 1;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (acpi_evalf(hkey_handle, &hotkey_adaptive_all_mask,\n\t\t\t\t       \"MHKA\", \"dd\", 2)) {\n\t\t\t\tif (hotkey_adaptive_all_mask != 0)\n\t\t\t\t\ttp_features.has_adaptive_kbd = true;\n\t\t\t} else {\n\t\t\t\ttp_features.has_adaptive_kbd = false;\n\t\t\t\thotkey_adaptive_all_mask = 0x0U;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tpr_err(\"unknown version of the HKEY interface: 0x%x\\n\",\n\t\t\t       hkeyv);\n\t\t\tpr_err(\"please report this to %s\\n\", TPACPI_MAIL);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tvdbg_printk(TPACPI_DBG_INIT | TPACPI_DBG_HKEY,\n\t\t\"hotkey masks are %s\\n\",\n\t\tstr_supported(tp_features.hotkey_mask));\n\n\t \n\tif (!tp_features.hotkey_mask && !hotkey_all_mask &&\n\t    (quirks & TPACPI_HK_Q_INIMASK))\n\t\thotkey_all_mask = 0x080cU;   \n\n\t \n\tif (tp_features.hotkey_mask) {\n\t\t \n\t\tmutex_lock(&hotkey_mutex);\n\t\tres = hotkey_mask_get();\n\t\tmutex_unlock(&hotkey_mutex);\n\t\tif (res)\n\t\t\treturn res;\n\n\t\thotkey_orig_mask = hotkey_acpi_mask;\n\t} else {\n\t\thotkey_orig_mask = hotkey_all_mask;\n\t\thotkey_acpi_mask = hotkey_all_mask;\n\t}\n\n#ifdef CONFIG_THINKPAD_ACPI_DEBUGFACILITIES\n\tif (dbg_wlswemul) {\n\t\ttp_features.hotkey_wlsw = 1;\n\t\tradiosw_state = !!tpacpi_wlsw_emulstate;\n\t\tpr_info(\"radio switch emulation enabled\\n\");\n\t} else\n#endif\n\t \n\tif (acpi_evalf(hkey_handle, &status, \"WLSW\", \"qd\")) {\n\t\ttp_features.hotkey_wlsw = 1;\n\t\tradiosw_state = !!status;\n\t\tpr_info(\"radio switch found; radios are %s\\n\", str_enabled_disabled(status & BIT(0)));\n\t}\n\n\ttabletsw_state = hotkey_init_tablet_mode();\n\n\t \n\tkeymap_id = tpacpi_check_quirks(tpacpi_keymap_qtable,\n\t\t\t\t\tARRAY_SIZE(tpacpi_keymap_qtable));\n\tBUG_ON(keymap_id >= ARRAY_SIZE(tpacpi_keymaps));\n\tdbg_printk(TPACPI_DBG_INIT | TPACPI_DBG_HKEY,\n\t\t   \"using keymap number %lu\\n\", keymap_id);\n\n\thotkey_keycode_map = kmemdup(&tpacpi_keymaps[keymap_id],\n\t\t\tTPACPI_HOTKEY_MAP_SIZE,\tGFP_KERNEL);\n\tif (!hotkey_keycode_map) {\n\t\tpr_err(\"failed to allocate memory for key map\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tinput_set_capability(tpacpi_inputdev, EV_MSC, MSC_SCAN);\n\ttpacpi_inputdev->keycodesize = TPACPI_HOTKEY_MAP_TYPESIZE;\n\ttpacpi_inputdev->keycodemax = TPACPI_HOTKEY_MAP_LEN;\n\ttpacpi_inputdev->keycode = hotkey_keycode_map;\n\tfor (i = 0; i < TPACPI_HOTKEY_MAP_LEN; i++) {\n\t\tif (hotkey_keycode_map[i] != KEY_RESERVED) {\n\t\t\tinput_set_capability(tpacpi_inputdev, EV_KEY,\n\t\t\t\t\t\thotkey_keycode_map[i]);\n\t\t} else {\n\t\t\tif (i < sizeof(hotkey_reserved_mask)*8)\n\t\t\t\thotkey_reserved_mask |= 1 << i;\n\t\t}\n\t}\n\n\tif (tp_features.hotkey_wlsw) {\n\t\tinput_set_capability(tpacpi_inputdev, EV_SW, SW_RFKILL_ALL);\n\t\tinput_report_switch(tpacpi_inputdev,\n\t\t\t\t    SW_RFKILL_ALL, radiosw_state);\n\t}\n\tif (tp_features.hotkey_tablet) {\n\t\tinput_set_capability(tpacpi_inputdev, EV_SW, SW_TABLET_MODE);\n\t\tinput_report_switch(tpacpi_inputdev,\n\t\t\t\t    SW_TABLET_MODE, tabletsw_state);\n\t}\n\n\t \n\tif (acpi_video_get_backlight_type() != acpi_backlight_vendor) {\n\t\tpr_info(\"This ThinkPad has standard ACPI backlight brightness control, supported by the ACPI video driver\\n\");\n\t\tpr_notice(\"Disabling thinkpad-acpi brightness events by default...\\n\");\n\n\t\t \n\t\thotkey_reserved_mask |=\n\t\t\t(1 << TP_ACPI_HOTKEYSCAN_FNHOME)\n\t\t\t| (1 << TP_ACPI_HOTKEYSCAN_FNEND);\n\t\thotkey_unmap(TP_ACPI_HOTKEYSCAN_FNHOME);\n\t\thotkey_unmap(TP_ACPI_HOTKEYSCAN_FNEND);\n\t}\n\n#ifdef CONFIG_THINKPAD_ACPI_HOTKEY_POLL\n\thotkey_source_mask = TPACPI_HKEY_NVRAM_GOOD_MASK\n\t\t\t\t& ~hotkey_all_mask\n\t\t\t\t& ~hotkey_reserved_mask;\n\n\tvdbg_printk(TPACPI_DBG_INIT | TPACPI_DBG_HKEY,\n\t\t    \"hotkey source mask 0x%08x, polling freq %u\\n\",\n\t\t    hotkey_source_mask, hotkey_poll_freq);\n#endif\n\n\tdbg_printk(TPACPI_DBG_INIT | TPACPI_DBG_HKEY,\n\t\t\t\"enabling firmware HKEY event interface...\\n\");\n\tres = hotkey_status_set(true);\n\tif (res) {\n\t\thotkey_exit();\n\t\treturn res;\n\t}\n\tmutex_lock(&hotkey_mutex);\n\tres = hotkey_mask_set(((hotkey_all_mask & ~hotkey_reserved_mask)\n\t\t\t       | hotkey_driver_mask)\n\t\t\t      & ~hotkey_source_mask);\n\tmutex_unlock(&hotkey_mutex);\n\tif (res < 0 && res != -ENXIO) {\n\t\thotkey_exit();\n\t\treturn res;\n\t}\n\thotkey_user_mask = (hotkey_acpi_mask | hotkey_source_mask)\n\t\t\t\t& ~hotkey_reserved_mask;\n\tvdbg_printk(TPACPI_DBG_INIT | TPACPI_DBG_HKEY,\n\t\t\"initial masks: user=0x%08x, fw=0x%08x, poll=0x%08x\\n\",\n\t\thotkey_user_mask, hotkey_acpi_mask, hotkey_source_mask);\n\n\ttpacpi_inputdev->open = &hotkey_inputdev_open;\n\ttpacpi_inputdev->close = &hotkey_inputdev_close;\n\n\thotkey_poll_setup_safe(true);\n\n\treturn 0;\n}\n\n \nstatic const int adaptive_keyboard_modes[] = {\n\tHOME_MODE,\n \n\tFUNCTION_MODE\n};\n\n#define DFR_CHANGE_ROW\t\t\t0x101\n#define DFR_SHOW_QUICKVIEW_ROW\t\t0x102\n#define FIRST_ADAPTIVE_KEY\t\t0x103\n\n \nstatic bool adaptive_keyboard_mode_is_saved;\nstatic int adaptive_keyboard_prev_mode;\n\nstatic int adaptive_keyboard_get_mode(void)\n{\n\tint mode = 0;\n\n\tif (!acpi_evalf(hkey_handle, &mode, \"GTRW\", \"dd\", 0)) {\n\t\tpr_err(\"Cannot read adaptive keyboard mode\\n\");\n\t\treturn -EIO;\n\t}\n\n\treturn mode;\n}\n\nstatic int adaptive_keyboard_set_mode(int new_mode)\n{\n\tif (new_mode < 0 ||\n\t\tnew_mode > LAYFLAT_MODE)\n\t\treturn -EINVAL;\n\n\tif (!acpi_evalf(hkey_handle, NULL, \"STRW\", \"vd\", new_mode)) {\n\t\tpr_err(\"Cannot set adaptive keyboard mode\\n\");\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int adaptive_keyboard_get_next_mode(int mode)\n{\n\tsize_t i;\n\tsize_t max_mode = ARRAY_SIZE(adaptive_keyboard_modes) - 1;\n\n\tfor (i = 0; i <= max_mode; i++) {\n\t\tif (adaptive_keyboard_modes[i] == mode)\n\t\t\tbreak;\n\t}\n\n\tif (i >= max_mode)\n\t\ti = 0;\n\telse\n\t\ti++;\n\n\treturn adaptive_keyboard_modes[i];\n}\n\nstatic bool adaptive_keyboard_hotkey_notify_hotkey(unsigned int scancode)\n{\n\tint current_mode = 0;\n\tint new_mode = 0;\n\tint keycode;\n\n\tswitch (scancode) {\n\tcase DFR_CHANGE_ROW:\n\t\tif (adaptive_keyboard_mode_is_saved) {\n\t\t\tnew_mode = adaptive_keyboard_prev_mode;\n\t\t\tadaptive_keyboard_mode_is_saved = false;\n\t\t} else {\n\t\t\tcurrent_mode = adaptive_keyboard_get_mode();\n\t\t\tif (current_mode < 0)\n\t\t\t\treturn false;\n\t\t\tnew_mode = adaptive_keyboard_get_next_mode(\n\t\t\t\t\tcurrent_mode);\n\t\t}\n\n\t\tif (adaptive_keyboard_set_mode(new_mode) < 0)\n\t\t\treturn false;\n\n\t\treturn true;\n\n\tcase DFR_SHOW_QUICKVIEW_ROW:\n\t\tcurrent_mode = adaptive_keyboard_get_mode();\n\t\tif (current_mode < 0)\n\t\t\treturn false;\n\n\t\tadaptive_keyboard_prev_mode = current_mode;\n\t\tadaptive_keyboard_mode_is_saved = true;\n\n\t\tif (adaptive_keyboard_set_mode (FUNCTION_MODE) < 0)\n\t\t\treturn false;\n\t\treturn true;\n\n\tdefault:\n\t\tif (scancode < FIRST_ADAPTIVE_KEY ||\n\t\t    scancode >= FIRST_ADAPTIVE_KEY +\n\t\t    TP_ACPI_HOTKEYSCAN_EXTENDED_START -\n\t\t    TP_ACPI_HOTKEYSCAN_ADAPTIVE_START) {\n\t\t\tpr_info(\"Unhandled adaptive keyboard key: 0x%x\\n\",\n\t\t\t\tscancode);\n\t\t\treturn false;\n\t\t}\n\t\tkeycode = hotkey_keycode_map[scancode - FIRST_ADAPTIVE_KEY +\n\t\t\t\t\t     TP_ACPI_HOTKEYSCAN_ADAPTIVE_START];\n\t\tif (keycode != KEY_RESERVED) {\n\t\t\tmutex_lock(&tpacpi_inputdev_send_mutex);\n\n\t\t\tinput_report_key(tpacpi_inputdev, keycode, 1);\n\t\t\tinput_sync(tpacpi_inputdev);\n\n\t\t\tinput_report_key(tpacpi_inputdev, keycode, 0);\n\t\t\tinput_sync(tpacpi_inputdev);\n\n\t\t\tmutex_unlock(&tpacpi_inputdev_send_mutex);\n\t\t}\n\t\treturn true;\n\t}\n}\n\nstatic bool hotkey_notify_extended_hotkey(const u32 hkey)\n{\n\tunsigned int scancode;\n\n\tswitch (hkey) {\n\tcase TP_HKEY_EV_PRIVACYGUARD_TOGGLE:\n\tcase TP_HKEY_EV_AMT_TOGGLE:\n\t\ttpacpi_driver_event(hkey);\n\t\treturn true;\n\t}\n\n\t \n\tscancode = (hkey & 0xfff) - (0x300 - TP_ACPI_HOTKEYSCAN_EXTENDED_START);\n\tif (scancode >= TP_ACPI_HOTKEYSCAN_EXTENDED_START &&\n\t    scancode < TPACPI_HOTKEY_MAP_LEN) {\n\t\ttpacpi_input_send_key(scancode);\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic bool hotkey_notify_hotkey(const u32 hkey,\n\t\t\t\t bool *send_acpi_ev,\n\t\t\t\t bool *ignore_acpi_ev)\n{\n\t \n\tunsigned int scancode = hkey & 0xfff;\n\t*send_acpi_ev = true;\n\t*ignore_acpi_ev = false;\n\n\t \n\tswitch ((hkey >> 8) & 0xf) {\n\tcase 0:\n\t\tif (scancode > 0 &&\n\t\t    scancode <= TP_ACPI_HOTKEYSCAN_ADAPTIVE_START) {\n\t\t\t \n\t\t\tscancode--;\n\t\t\tif (!(hotkey_source_mask & (1 << scancode))) {\n\t\t\t\ttpacpi_input_send_key_masked(scancode);\n\t\t\t\t*send_acpi_ev = false;\n\t\t\t} else {\n\t\t\t\t*ignore_acpi_ev = true;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\tbreak;\n\n\tcase 1:\n\t\treturn adaptive_keyboard_hotkey_notify_hotkey(scancode);\n\n\tcase 3:\n\t\treturn hotkey_notify_extended_hotkey(hkey);\n\t}\n\n\treturn false;\n}\n\nstatic bool hotkey_notify_wakeup(const u32 hkey,\n\t\t\t\t bool *send_acpi_ev,\n\t\t\t\t bool *ignore_acpi_ev)\n{\n\t \n\t*send_acpi_ev = true;\n\t*ignore_acpi_ev = false;\n\n\tswitch (hkey) {\n\tcase TP_HKEY_EV_WKUP_S3_UNDOCK:  \n\tcase TP_HKEY_EV_WKUP_S4_UNDOCK:  \n\t\thotkey_wakeup_reason = TP_ACPI_WAKEUP_UNDOCK;\n\t\t*ignore_acpi_ev = true;\n\t\tbreak;\n\n\tcase TP_HKEY_EV_WKUP_S3_BAYEJ:  \n\tcase TP_HKEY_EV_WKUP_S4_BAYEJ:  \n\t\thotkey_wakeup_reason = TP_ACPI_WAKEUP_BAYEJ;\n\t\t*ignore_acpi_ev = true;\n\t\tbreak;\n\n\tcase TP_HKEY_EV_WKUP_S3_BATLOW:  \n\tcase TP_HKEY_EV_WKUP_S4_BATLOW:  \n\t\tpr_alert(\"EMERGENCY WAKEUP: battery almost empty\\n\");\n\t\t \n\t\t \n\t\t \n\t\tbreak;\n\n\tdefault:\n\t\treturn false;\n\t}\n\n\tif (hotkey_wakeup_reason != TP_ACPI_WAKEUP_NONE) {\n\t\tpr_info(\"woke up due to a hot-unplug request...\\n\");\n\t\thotkey_wakeup_reason_notify_change();\n\t}\n\treturn true;\n}\n\nstatic bool hotkey_notify_dockevent(const u32 hkey,\n\t\t\t\t bool *send_acpi_ev,\n\t\t\t\t bool *ignore_acpi_ev)\n{\n\t \n\t*send_acpi_ev = true;\n\t*ignore_acpi_ev = false;\n\n\tswitch (hkey) {\n\tcase TP_HKEY_EV_UNDOCK_ACK:\n\t\t \n\t\thotkey_autosleep_ack = 1;\n\t\tpr_info(\"undocked\\n\");\n\t\thotkey_wakeup_hotunplug_complete_notify_change();\n\t\treturn true;\n\n\tcase TP_HKEY_EV_HOTPLUG_DOCK:  \n\t\tpr_info(\"docked into hotplug port replicator\\n\");\n\t\treturn true;\n\tcase TP_HKEY_EV_HOTPLUG_UNDOCK:  \n\t\tpr_info(\"undocked from hotplug port replicator\\n\");\n\t\treturn true;\n\n\t \n\tcase TP_HKEY_EV_KBD_COVER_ATTACH:\n\tcase TP_HKEY_EV_KBD_COVER_DETACH:\n\t\t*send_acpi_ev = false;\n\t\t*ignore_acpi_ev = true;\n\t\treturn true;\n\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool hotkey_notify_usrevent(const u32 hkey,\n\t\t\t\t bool *send_acpi_ev,\n\t\t\t\t bool *ignore_acpi_ev)\n{\n\t \n\t*send_acpi_ev = true;\n\t*ignore_acpi_ev = false;\n\n\tswitch (hkey) {\n\tcase TP_HKEY_EV_PEN_INSERTED:   \n\tcase TP_HKEY_EV_PEN_REMOVED:    \n\t\treturn true;\n\n\tcase TP_HKEY_EV_TABLET_TABLET:    \n\tcase TP_HKEY_EV_TABLET_NOTEBOOK:  \n\t\ttpacpi_input_send_tabletsw();\n\t\thotkey_tablet_mode_notify_change();\n\t\t*send_acpi_ev = false;\n\t\treturn true;\n\n\tcase TP_HKEY_EV_LID_CLOSE:\t \n\tcase TP_HKEY_EV_LID_OPEN:\t \n\tcase TP_HKEY_EV_BRGHT_CHANGED:\t \n\t\t \n\t\t*ignore_acpi_ev = true;\n\t\treturn true;\n\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic void thermal_dump_all_sensors(void);\nstatic void palmsensor_refresh(void);\n\nstatic bool hotkey_notify_6xxx(const u32 hkey,\n\t\t\t\t bool *send_acpi_ev,\n\t\t\t\t bool *ignore_acpi_ev)\n{\n\t \n\t*send_acpi_ev = true;\n\t*ignore_acpi_ev = false;\n\n\tswitch (hkey) {\n\tcase TP_HKEY_EV_THM_TABLE_CHANGED:\n\t\tpr_debug(\"EC reports: Thermal Table has changed\\n\");\n\t\t \n\t\treturn true;\n\tcase TP_HKEY_EV_THM_CSM_COMPLETED:\n\t\tpr_debug(\"EC reports: Thermal Control Command set completed (DYTC)\\n\");\n\t\t \n\t\ttpacpi_driver_event(hkey);\n\t\treturn true;\n\tcase TP_HKEY_EV_THM_TRANSFM_CHANGED:\n\t\tpr_debug(\"EC reports: Thermal Transformation changed (GMTS)\\n\");\n\t\t \n\t\treturn true;\n\tcase TP_HKEY_EV_ALARM_BAT_HOT:\n\t\tpr_crit(\"THERMAL ALARM: battery is too hot!\\n\");\n\t\t \n\t\tbreak;\n\tcase TP_HKEY_EV_ALARM_BAT_XHOT:\n\t\tpr_alert(\"THERMAL EMERGENCY: battery is extremely hot!\\n\");\n\t\t \n\t\tbreak;\n\tcase TP_HKEY_EV_ALARM_SENSOR_HOT:\n\t\tpr_crit(\"THERMAL ALARM: a sensor reports something is too hot!\\n\");\n\t\t \n\t\t \n\t\tbreak;\n\tcase TP_HKEY_EV_ALARM_SENSOR_XHOT:\n\t\tpr_alert(\"THERMAL EMERGENCY: a sensor reports something is extremely hot!\\n\");\n\t\t \n\t\tbreak;\n\tcase TP_HKEY_EV_AC_CHANGED:\n\t\t \n\n\t\tfallthrough;\n\n\tcase TP_HKEY_EV_KEY_NUMLOCK:\n\tcase TP_HKEY_EV_KEY_FN:\n\t\t \n\t\t*send_acpi_ev = false;\n\t\t*ignore_acpi_ev = true;\n\t\treturn true;\n\n\tcase TP_HKEY_EV_KEY_FN_ESC:\n\t\t \n\t\tacpi_evalf(hkey_handle, NULL, \"GMKS\", \"v\");\n\t\t*send_acpi_ev = false;\n\t\t*ignore_acpi_ev = true;\n\t\treturn true;\n\n\tcase TP_HKEY_EV_TABLET_CHANGED:\n\t\ttpacpi_input_send_tabletsw();\n\t\thotkey_tablet_mode_notify_change();\n\t\t*send_acpi_ev = false;\n\t\treturn true;\n\n\tcase TP_HKEY_EV_PALM_DETECTED:\n\tcase TP_HKEY_EV_PALM_UNDETECTED:\n\t\t \n\t\tpalmsensor_refresh();\n\t\treturn true;\n\n\tdefault:\n\t\t \n\t\treturn false;\n\t}\n\n\tthermal_dump_all_sensors();\n\treturn true;\n}\n\nstatic void hotkey_notify(struct ibm_struct *ibm, u32 event)\n{\n\tu32 hkey;\n\tbool send_acpi_ev;\n\tbool ignore_acpi_ev;\n\tbool known_ev;\n\n\tif (event != 0x80) {\n\t\tpr_err(\"unknown HKEY notification event %d\\n\", event);\n\t\t \n\t\tacpi_bus_generate_netlink_event(\n\t\t\t\t\tibm->acpi->device->pnp.device_class,\n\t\t\t\t\tdev_name(&ibm->acpi->device->dev),\n\t\t\t\t\tevent, 0);\n\t\treturn;\n\t}\n\n\twhile (1) {\n\t\tif (!acpi_evalf(hkey_handle, &hkey, \"MHKP\", \"d\")) {\n\t\t\tpr_err(\"failed to retrieve HKEY event\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\tif (hkey == 0) {\n\t\t\t \n\t\t\treturn;\n\t\t}\n\n\t\tsend_acpi_ev = true;\n\t\tignore_acpi_ev = false;\n\n\t\tswitch (hkey >> 12) {\n\t\tcase 1:\n\t\t\t \n\t\t\tknown_ev = hotkey_notify_hotkey(hkey, &send_acpi_ev,\n\t\t\t\t\t\t &ignore_acpi_ev);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\t \n\t\t\tknown_ev = hotkey_notify_wakeup(hkey, &send_acpi_ev,\n\t\t\t\t\t\t &ignore_acpi_ev);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\t \n\t\t\tswitch (hkey) {\n\t\t\tcase TP_HKEY_EV_BAYEJ_ACK:\n\t\t\t\thotkey_autosleep_ack = 1;\n\t\t\t\tpr_info(\"bay ejected\\n\");\n\t\t\t\thotkey_wakeup_hotunplug_complete_notify_change();\n\t\t\t\tknown_ev = true;\n\t\t\t\tbreak;\n\t\t\tcase TP_HKEY_EV_OPTDRV_EJ:\n\t\t\t\t \n\t\t\t\tknown_ev = true;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tknown_ev = false;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\t \n\t\t\tknown_ev = hotkey_notify_dockevent(hkey, &send_acpi_ev,\n\t\t\t\t\t\t&ignore_acpi_ev);\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\t \n\t\t\tknown_ev = hotkey_notify_usrevent(hkey, &send_acpi_ev,\n\t\t\t\t\t\t &ignore_acpi_ev);\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\t \n\t\t\tknown_ev = hotkey_notify_6xxx(hkey, &send_acpi_ev,\n\t\t\t\t\t\t &ignore_acpi_ev);\n\t\t\tbreak;\n\t\tcase 7:\n\t\t\t \n\t\t\tif (tp_features.hotkey_wlsw &&\n\t\t\t\t\thkey == TP_HKEY_EV_RFKILL_CHANGED) {\n\t\t\t\ttpacpi_send_radiosw_update();\n\t\t\t\tsend_acpi_ev = 0;\n\t\t\t\tknown_ev = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfallthrough;\t \n\t\tdefault:\n\t\t\tknown_ev = false;\n\t\t}\n\t\tif (!known_ev) {\n\t\t\tpr_notice(\"unhandled HKEY event 0x%04x\\n\", hkey);\n\t\t\tpr_notice(\"please report the conditions when this event happened to %s\\n\",\n\t\t\t\t  TPACPI_MAIL);\n\t\t}\n\n\t\t \n\t\tif (!ignore_acpi_ev && send_acpi_ev) {\n\t\t\tacpi_bus_generate_netlink_event(\n\t\t\t\t\tibm->acpi->device->pnp.device_class,\n\t\t\t\t\tdev_name(&ibm->acpi->device->dev),\n\t\t\t\t\tevent, hkey);\n\t\t}\n\t}\n}\n\nstatic void hotkey_suspend(void)\n{\n\t \n\thotkey_wakeup_reason = TP_ACPI_WAKEUP_NONE;\n\thotkey_autosleep_ack = 0;\n\n\t \n\tif (tp_features.has_adaptive_kbd) {\n\t\tif (!acpi_evalf(hkey_handle, &adaptive_keyboard_prev_mode,\n\t\t\t\t\t\"GTRW\", \"dd\", 0)) {\n\t\t\tpr_err(\"Cannot read adaptive keyboard mode.\\n\");\n\t\t}\n\t}\n}\n\nstatic void hotkey_resume(void)\n{\n\ttpacpi_disable_brightness_delay();\n\n\tmutex_lock(&hotkey_mutex);\n\tif (hotkey_status_set(true) < 0 ||\n\t    hotkey_mask_set(hotkey_acpi_mask) < 0)\n\t\tpr_err(\"error while attempting to reset the event firmware interface\\n\");\n\tmutex_unlock(&hotkey_mutex);\n\n\ttpacpi_send_radiosw_update();\n\ttpacpi_input_send_tabletsw();\n\thotkey_tablet_mode_notify_change();\n\thotkey_wakeup_reason_notify_change();\n\thotkey_wakeup_hotunplug_complete_notify_change();\n\thotkey_poll_setup_safe(false);\n\n\t \n\tif (tp_features.has_adaptive_kbd) {\n\t\tif (!acpi_evalf(hkey_handle, NULL, \"STRW\", \"vd\",\n\t\t\t\t\tadaptive_keyboard_prev_mode)) {\n\t\t\tpr_err(\"Cannot set adaptive keyboard mode.\\n\");\n\t\t}\n\t}\n}\n\n \nstatic int hotkey_read(struct seq_file *m)\n{\n\tint res, status;\n\n\tif (!tp_features.hotkey) {\n\t\tseq_printf(m, \"status:\\t\\tnot supported\\n\");\n\t\treturn 0;\n\t}\n\n\tif (mutex_lock_killable(&hotkey_mutex))\n\t\treturn -ERESTARTSYS;\n\tres = hotkey_status_get(&status);\n\tif (!res)\n\t\tres = hotkey_mask_get();\n\tmutex_unlock(&hotkey_mutex);\n\tif (res)\n\t\treturn res;\n\n\tseq_printf(m, \"status:\\t\\t%s\\n\", str_enabled_disabled(status & BIT(0)));\n\tif (hotkey_all_mask) {\n\t\tseq_printf(m, \"mask:\\t\\t0x%08x\\n\", hotkey_user_mask);\n\t\tseq_printf(m, \"commands:\\tenable, disable, reset, <mask>\\n\");\n\t} else {\n\t\tseq_printf(m, \"mask:\\t\\tnot supported\\n\");\n\t\tseq_printf(m, \"commands:\\tenable, disable, reset\\n\");\n\t}\n\n\treturn 0;\n}\n\nstatic void hotkey_enabledisable_warn(bool enable)\n{\n\ttpacpi_log_usertask(\"procfs hotkey enable/disable\");\n\tif (!WARN((tpacpi_lifecycle == TPACPI_LIFE_RUNNING || !enable),\n\t\t  pr_fmt(\"hotkey enable/disable functionality has been removed from the driver.  Hotkeys are always enabled.\\n\")))\n\t\tpr_err(\"Please remove the hotkey=enable module parameter, it is deprecated.  Hotkeys are always enabled.\\n\");\n}\n\nstatic int hotkey_write(char *buf)\n{\n\tint res;\n\tu32 mask;\n\tchar *cmd;\n\n\tif (!tp_features.hotkey)\n\t\treturn -ENODEV;\n\n\tif (mutex_lock_killable(&hotkey_mutex))\n\t\treturn -ERESTARTSYS;\n\n\tmask = hotkey_user_mask;\n\n\tres = 0;\n\twhile ((cmd = strsep(&buf, \",\"))) {\n\t\tif (strstarts(cmd, \"enable\")) {\n\t\t\thotkey_enabledisable_warn(1);\n\t\t} else if (strstarts(cmd, \"disable\")) {\n\t\t\thotkey_enabledisable_warn(0);\n\t\t\tres = -EPERM;\n\t\t} else if (strstarts(cmd, \"reset\")) {\n\t\t\tmask = (hotkey_all_mask | hotkey_source_mask)\n\t\t\t\t& ~hotkey_reserved_mask;\n\t\t} else if (sscanf(cmd, \"0x%x\", &mask) == 1) {\n\t\t\t \n\t\t} else if (sscanf(cmd, \"%x\", &mask) == 1) {\n\t\t\t \n\t\t} else {\n\t\t\tres = -EINVAL;\n\t\t\tgoto errexit;\n\t\t}\n\t}\n\n\tif (!res) {\n\t\ttpacpi_disclose_usertask(\"procfs hotkey\",\n\t\t\t\"set mask to 0x%08x\\n\", mask);\n\t\tres = hotkey_user_mask_set(mask);\n\t}\n\nerrexit:\n\tmutex_unlock(&hotkey_mutex);\n\treturn res;\n}\n\nstatic const struct acpi_device_id ibm_htk_device_ids[] = {\n\t{TPACPI_ACPI_IBM_HKEY_HID, 0},\n\t{TPACPI_ACPI_LENOVO_HKEY_HID, 0},\n\t{TPACPI_ACPI_LENOVO_HKEY_V2_HID, 0},\n\t{\"\", 0},\n};\n\nstatic struct tp_acpi_drv_struct ibm_hotkey_acpidriver = {\n\t.hid = ibm_htk_device_ids,\n\t.notify = hotkey_notify,\n\t.handle = &hkey_handle,\n\t.type = ACPI_DEVICE_NOTIFY,\n};\n\nstatic struct ibm_struct hotkey_driver_data = {\n\t.name = \"hotkey\",\n\t.read = hotkey_read,\n\t.write = hotkey_write,\n\t.exit = hotkey_exit,\n\t.resume = hotkey_resume,\n\t.suspend = hotkey_suspend,\n\t.acpi = &ibm_hotkey_acpidriver,\n};\n\n \n\nenum {\n\t \n\tTP_ACPI_BLUETOOTH_HWPRESENT\t= 0x01,\t \n\tTP_ACPI_BLUETOOTH_RADIOSSW\t= 0x02,\t \n\tTP_ACPI_BLUETOOTH_RESUMECTRL\t= 0x04,\t \n};\n\nenum {\n\t \n\tTP_ACPI_BLTH_GET_ULTRAPORT_ID\t= 0x00,  \n\tTP_ACPI_BLTH_GET_PWR_ON_RESUME\t= 0x01,  \n\tTP_ACPI_BLTH_PWR_ON_ON_RESUME\t= 0x02,  \n\tTP_ACPI_BLTH_PWR_OFF_ON_RESUME\t= 0x03,\t \n\tTP_ACPI_BLTH_SAVE_STATE\t\t= 0x05,  \n};\n\n#define TPACPI_RFK_BLUETOOTH_SW_NAME\t\"tpacpi_bluetooth_sw\"\n\nstatic int bluetooth_get_status(void)\n{\n\tint status;\n\n#ifdef CONFIG_THINKPAD_ACPI_DEBUGFACILITIES\n\tif (dbg_bluetoothemul)\n\t\treturn (tpacpi_bluetooth_emulstate) ?\n\t\t       TPACPI_RFK_RADIO_ON : TPACPI_RFK_RADIO_OFF;\n#endif\n\n\tif (!acpi_evalf(hkey_handle, &status, \"GBDC\", \"d\"))\n\t\treturn -EIO;\n\n\treturn ((status & TP_ACPI_BLUETOOTH_RADIOSSW) != 0) ?\n\t\t\tTPACPI_RFK_RADIO_ON : TPACPI_RFK_RADIO_OFF;\n}\n\nstatic int bluetooth_set_status(enum tpacpi_rfkill_state state)\n{\n\tint status;\n\n\tvdbg_printk(TPACPI_DBG_RFKILL, \"will attempt to %s bluetooth\\n\",\n\t\t    str_enable_disable(state == TPACPI_RFK_RADIO_ON));\n\n#ifdef CONFIG_THINKPAD_ACPI_DEBUGFACILITIES\n\tif (dbg_bluetoothemul) {\n\t\ttpacpi_bluetooth_emulstate = (state == TPACPI_RFK_RADIO_ON);\n\t\treturn 0;\n\t}\n#endif\n\n\tif (state == TPACPI_RFK_RADIO_ON)\n\t\tstatus = TP_ACPI_BLUETOOTH_RADIOSSW\n\t\t\t  | TP_ACPI_BLUETOOTH_RESUMECTRL;\n\telse\n\t\tstatus = 0;\n\n\tif (!acpi_evalf(hkey_handle, NULL, \"SBDC\", \"vd\", status))\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\n \nstatic ssize_t bluetooth_enable_show(struct device *dev,\n\t\t\t   struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\treturn tpacpi_rfk_sysfs_enable_show(TPACPI_RFK_BLUETOOTH_SW_ID,\n\t\t\tattr, buf);\n}\n\nstatic ssize_t bluetooth_enable_store(struct device *dev,\n\t\t\t    struct device_attribute *attr,\n\t\t\t    const char *buf, size_t count)\n{\n\treturn tpacpi_rfk_sysfs_enable_store(TPACPI_RFK_BLUETOOTH_SW_ID,\n\t\t\t\tattr, buf, count);\n}\n\nstatic DEVICE_ATTR_RW(bluetooth_enable);\n\n \n\nstatic struct attribute *bluetooth_attributes[] = {\n\t&dev_attr_bluetooth_enable.attr,\n\tNULL\n};\n\nstatic umode_t bluetooth_attr_is_visible(struct kobject *kobj,\n\t\t\t\t\t struct attribute *attr, int n)\n{\n\treturn tp_features.bluetooth ? attr->mode : 0;\n}\n\nstatic const struct attribute_group bluetooth_attr_group = {\n\t.is_visible = bluetooth_attr_is_visible,\n\t.attrs = bluetooth_attributes,\n};\n\nstatic const struct tpacpi_rfk_ops bluetooth_tprfk_ops = {\n\t.get_status = bluetooth_get_status,\n\t.set_status = bluetooth_set_status,\n};\n\nstatic void bluetooth_shutdown(void)\n{\n\t \n\tif (!acpi_evalf(NULL, NULL, \"\\\\BLTH\", \"vd\",\n\t\t\tTP_ACPI_BLTH_SAVE_STATE))\n\t\tpr_notice(\"failed to save bluetooth state to NVRAM\\n\");\n\telse\n\t\tvdbg_printk(TPACPI_DBG_RFKILL,\n\t\t\t\"bluetooth state saved to NVRAM\\n\");\n}\n\nstatic void bluetooth_exit(void)\n{\n\ttpacpi_destroy_rfkill(TPACPI_RFK_BLUETOOTH_SW_ID);\n\tbluetooth_shutdown();\n}\n\nstatic const struct dmi_system_id fwbug_list[] __initconst = {\n\t{\n\t\t.ident = \"ThinkPad E485\",\n\t\t.driver_data = &quirk_btusb_bug,\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"LENOVO\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"20KU\"),\n\t\t},\n\t},\n\t{\n\t\t.ident = \"ThinkPad E585\",\n\t\t.driver_data = &quirk_btusb_bug,\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"LENOVO\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"20KV\"),\n\t\t},\n\t},\n\t{\n\t\t.ident = \"ThinkPad A285 - 20MW\",\n\t\t.driver_data = &quirk_btusb_bug,\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"LENOVO\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"20MW\"),\n\t\t},\n\t},\n\t{\n\t\t.ident = \"ThinkPad A285 - 20MX\",\n\t\t.driver_data = &quirk_btusb_bug,\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"LENOVO\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"20MX\"),\n\t\t},\n\t},\n\t{\n\t\t.ident = \"ThinkPad A485 - 20MU\",\n\t\t.driver_data = &quirk_btusb_bug,\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"LENOVO\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"20MU\"),\n\t\t},\n\t},\n\t{\n\t\t.ident = \"ThinkPad A485 - 20MV\",\n\t\t.driver_data = &quirk_btusb_bug,\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"LENOVO\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"20MV\"),\n\t\t},\n\t},\n\t{}\n};\n\nstatic const struct pci_device_id fwbug_cards_ids[] __initconst = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x24F3) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x24FD) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x2526) },\n\t{}\n};\n\n\nstatic int __init have_bt_fwbug(void)\n{\n\t \n\tif (tp_features.quirks && tp_features.quirks->btusb_bug &&\n\t    pci_dev_present(fwbug_cards_ids)) {\n\t\tvdbg_printk(TPACPI_DBG_INIT | TPACPI_DBG_RFKILL,\n\t\t\tFW_BUG \"disable bluetooth subdriver for Intel cards\\n\");\n\t\treturn 1;\n\t} else\n\t\treturn 0;\n}\n\nstatic int __init bluetooth_init(struct ibm_init_struct *iibm)\n{\n\tint res;\n\tint status = 0;\n\n\tvdbg_printk(TPACPI_DBG_INIT | TPACPI_DBG_RFKILL,\n\t\t\t\"initializing bluetooth subdriver\\n\");\n\n\tTPACPI_ACPIHANDLE_INIT(hkey);\n\n\t \n\ttp_features.bluetooth = !have_bt_fwbug() && hkey_handle &&\n\t    acpi_evalf(hkey_handle, &status, \"GBDC\", \"qd\");\n\n\tvdbg_printk(TPACPI_DBG_INIT | TPACPI_DBG_RFKILL,\n\t\t\"bluetooth is %s, status 0x%02x\\n\",\n\t\tstr_supported(tp_features.bluetooth),\n\t\tstatus);\n\n#ifdef CONFIG_THINKPAD_ACPI_DEBUGFACILITIES\n\tif (dbg_bluetoothemul) {\n\t\ttp_features.bluetooth = 1;\n\t\tpr_info(\"bluetooth switch emulation enabled\\n\");\n\t} else\n#endif\n\tif (tp_features.bluetooth &&\n\t    !(status & TP_ACPI_BLUETOOTH_HWPRESENT)) {\n\t\t \n\t\ttp_features.bluetooth = 0;\n\t\tdbg_printk(TPACPI_DBG_INIT | TPACPI_DBG_RFKILL,\n\t\t\t   \"bluetooth hardware not installed\\n\");\n\t}\n\n\tif (!tp_features.bluetooth)\n\t\treturn -ENODEV;\n\n\tres = tpacpi_new_rfkill(TPACPI_RFK_BLUETOOTH_SW_ID,\n\t\t\t\t&bluetooth_tprfk_ops,\n\t\t\t\tRFKILL_TYPE_BLUETOOTH,\n\t\t\t\tTPACPI_RFK_BLUETOOTH_SW_NAME,\n\t\t\t\ttrue);\n\treturn res;\n}\n\n \nstatic int bluetooth_read(struct seq_file *m)\n{\n\treturn tpacpi_rfk_procfs_read(TPACPI_RFK_BLUETOOTH_SW_ID, m);\n}\n\nstatic int bluetooth_write(char *buf)\n{\n\treturn tpacpi_rfk_procfs_write(TPACPI_RFK_BLUETOOTH_SW_ID, buf);\n}\n\nstatic struct ibm_struct bluetooth_driver_data = {\n\t.name = \"bluetooth\",\n\t.read = bluetooth_read,\n\t.write = bluetooth_write,\n\t.exit = bluetooth_exit,\n\t.shutdown = bluetooth_shutdown,\n};\n\n \n\nenum {\n\t \n\tTP_ACPI_WANCARD_HWPRESENT\t= 0x01,\t \n\tTP_ACPI_WANCARD_RADIOSSW\t= 0x02,\t \n\tTP_ACPI_WANCARD_RESUMECTRL\t= 0x04,\t \n};\n\n#define TPACPI_RFK_WWAN_SW_NAME\t\t\"tpacpi_wwan_sw\"\n\nstatic int wan_get_status(void)\n{\n\tint status;\n\n#ifdef CONFIG_THINKPAD_ACPI_DEBUGFACILITIES\n\tif (dbg_wwanemul)\n\t\treturn (tpacpi_wwan_emulstate) ?\n\t\t       TPACPI_RFK_RADIO_ON : TPACPI_RFK_RADIO_OFF;\n#endif\n\n\tif (!acpi_evalf(hkey_handle, &status, \"GWAN\", \"d\"))\n\t\treturn -EIO;\n\n\treturn ((status & TP_ACPI_WANCARD_RADIOSSW) != 0) ?\n\t\t\tTPACPI_RFK_RADIO_ON : TPACPI_RFK_RADIO_OFF;\n}\n\nstatic int wan_set_status(enum tpacpi_rfkill_state state)\n{\n\tint status;\n\n\tvdbg_printk(TPACPI_DBG_RFKILL, \"will attempt to %s wwan\\n\",\n\t\t    str_enable_disable(state == TPACPI_RFK_RADIO_ON));\n\n#ifdef CONFIG_THINKPAD_ACPI_DEBUGFACILITIES\n\tif (dbg_wwanemul) {\n\t\ttpacpi_wwan_emulstate = (state == TPACPI_RFK_RADIO_ON);\n\t\treturn 0;\n\t}\n#endif\n\n\tif (state == TPACPI_RFK_RADIO_ON)\n\t\tstatus = TP_ACPI_WANCARD_RADIOSSW\n\t\t\t | TP_ACPI_WANCARD_RESUMECTRL;\n\telse\n\t\tstatus = 0;\n\n\tif (!acpi_evalf(hkey_handle, NULL, \"SWAN\", \"vd\", status))\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\n \nstatic ssize_t wan_enable_show(struct device *dev,\n\t\t\t   struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\treturn tpacpi_rfk_sysfs_enable_show(TPACPI_RFK_WWAN_SW_ID,\n\t\t\tattr, buf);\n}\n\nstatic ssize_t wan_enable_store(struct device *dev,\n\t\t\t    struct device_attribute *attr,\n\t\t\t    const char *buf, size_t count)\n{\n\treturn tpacpi_rfk_sysfs_enable_store(TPACPI_RFK_WWAN_SW_ID,\n\t\t\tattr, buf, count);\n}\n\nstatic DEVICE_ATTR(wwan_enable, S_IWUSR | S_IRUGO,\n\t\t   wan_enable_show, wan_enable_store);\n\n \n\nstatic struct attribute *wan_attributes[] = {\n\t&dev_attr_wwan_enable.attr,\n\tNULL\n};\n\nstatic umode_t wan_attr_is_visible(struct kobject *kobj, struct attribute *attr,\n\t\t\t\t   int n)\n{\n\treturn tp_features.wan ? attr->mode : 0;\n}\n\nstatic const struct attribute_group wan_attr_group = {\n\t.is_visible = wan_attr_is_visible,\n\t.attrs = wan_attributes,\n};\n\nstatic const struct tpacpi_rfk_ops wan_tprfk_ops = {\n\t.get_status = wan_get_status,\n\t.set_status = wan_set_status,\n};\n\nstatic void wan_shutdown(void)\n{\n\t \n\tif (!acpi_evalf(NULL, NULL, \"\\\\WGSV\", \"vd\",\n\t\t\tTP_ACPI_WGSV_SAVE_STATE))\n\t\tpr_notice(\"failed to save WWAN state to NVRAM\\n\");\n\telse\n\t\tvdbg_printk(TPACPI_DBG_RFKILL,\n\t\t\t\"WWAN state saved to NVRAM\\n\");\n}\n\nstatic void wan_exit(void)\n{\n\ttpacpi_destroy_rfkill(TPACPI_RFK_WWAN_SW_ID);\n\twan_shutdown();\n}\n\nstatic int __init wan_init(struct ibm_init_struct *iibm)\n{\n\tint res;\n\tint status = 0;\n\n\tvdbg_printk(TPACPI_DBG_INIT | TPACPI_DBG_RFKILL,\n\t\t\t\"initializing wan subdriver\\n\");\n\n\tTPACPI_ACPIHANDLE_INIT(hkey);\n\n\ttp_features.wan = hkey_handle &&\n\t    acpi_evalf(hkey_handle, &status, \"GWAN\", \"qd\");\n\n\tvdbg_printk(TPACPI_DBG_INIT | TPACPI_DBG_RFKILL,\n\t\t\"wan is %s, status 0x%02x\\n\",\n\t\tstr_supported(tp_features.wan),\n\t\tstatus);\n\n#ifdef CONFIG_THINKPAD_ACPI_DEBUGFACILITIES\n\tif (dbg_wwanemul) {\n\t\ttp_features.wan = 1;\n\t\tpr_info(\"wwan switch emulation enabled\\n\");\n\t} else\n#endif\n\tif (tp_features.wan &&\n\t    !(status & TP_ACPI_WANCARD_HWPRESENT)) {\n\t\t \n\t\ttp_features.wan = 0;\n\t\tdbg_printk(TPACPI_DBG_INIT | TPACPI_DBG_RFKILL,\n\t\t\t   \"wan hardware not installed\\n\");\n\t}\n\n\tif (!tp_features.wan)\n\t\treturn -ENODEV;\n\n\tres = tpacpi_new_rfkill(TPACPI_RFK_WWAN_SW_ID,\n\t\t\t\t&wan_tprfk_ops,\n\t\t\t\tRFKILL_TYPE_WWAN,\n\t\t\t\tTPACPI_RFK_WWAN_SW_NAME,\n\t\t\t\ttrue);\n\treturn res;\n}\n\n \nstatic int wan_read(struct seq_file *m)\n{\n\treturn tpacpi_rfk_procfs_read(TPACPI_RFK_WWAN_SW_ID, m);\n}\n\nstatic int wan_write(char *buf)\n{\n\treturn tpacpi_rfk_procfs_write(TPACPI_RFK_WWAN_SW_ID, buf);\n}\n\nstatic struct ibm_struct wan_driver_data = {\n\t.name = \"wan\",\n\t.read = wan_read,\n\t.write = wan_write,\n\t.exit = wan_exit,\n\t.shutdown = wan_shutdown,\n};\n\n \n\nenum {\n\t \n\tTP_ACPI_UWB_HWPRESENT\t= 0x01,\t \n\tTP_ACPI_UWB_RADIOSSW\t= 0x02,\t \n};\n\n#define TPACPI_RFK_UWB_SW_NAME\t\"tpacpi_uwb_sw\"\n\nstatic int uwb_get_status(void)\n{\n\tint status;\n\n#ifdef CONFIG_THINKPAD_ACPI_DEBUGFACILITIES\n\tif (dbg_uwbemul)\n\t\treturn (tpacpi_uwb_emulstate) ?\n\t\t       TPACPI_RFK_RADIO_ON : TPACPI_RFK_RADIO_OFF;\n#endif\n\n\tif (!acpi_evalf(hkey_handle, &status, \"GUWB\", \"d\"))\n\t\treturn -EIO;\n\n\treturn ((status & TP_ACPI_UWB_RADIOSSW) != 0) ?\n\t\t\tTPACPI_RFK_RADIO_ON : TPACPI_RFK_RADIO_OFF;\n}\n\nstatic int uwb_set_status(enum tpacpi_rfkill_state state)\n{\n\tint status;\n\n\tvdbg_printk(TPACPI_DBG_RFKILL, \"will attempt to %s UWB\\n\",\n\t\t    str_enable_disable(state == TPACPI_RFK_RADIO_ON));\n\n#ifdef CONFIG_THINKPAD_ACPI_DEBUGFACILITIES\n\tif (dbg_uwbemul) {\n\t\ttpacpi_uwb_emulstate = (state == TPACPI_RFK_RADIO_ON);\n\t\treturn 0;\n\t}\n#endif\n\n\tif (state == TPACPI_RFK_RADIO_ON)\n\t\tstatus = TP_ACPI_UWB_RADIOSSW;\n\telse\n\t\tstatus = 0;\n\n\tif (!acpi_evalf(hkey_handle, NULL, \"SUWB\", \"vd\", status))\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\n \n\nstatic const struct tpacpi_rfk_ops uwb_tprfk_ops = {\n\t.get_status = uwb_get_status,\n\t.set_status = uwb_set_status,\n};\n\nstatic void uwb_exit(void)\n{\n\ttpacpi_destroy_rfkill(TPACPI_RFK_UWB_SW_ID);\n}\n\nstatic int __init uwb_init(struct ibm_init_struct *iibm)\n{\n\tint res;\n\tint status = 0;\n\n\tvdbg_printk(TPACPI_DBG_INIT | TPACPI_DBG_RFKILL,\n\t\t\t\"initializing uwb subdriver\\n\");\n\n\tTPACPI_ACPIHANDLE_INIT(hkey);\n\n\ttp_features.uwb = hkey_handle &&\n\t    acpi_evalf(hkey_handle, &status, \"GUWB\", \"qd\");\n\n\tvdbg_printk(TPACPI_DBG_INIT | TPACPI_DBG_RFKILL,\n\t\t\"uwb is %s, status 0x%02x\\n\",\n\t\tstr_supported(tp_features.uwb),\n\t\tstatus);\n\n#ifdef CONFIG_THINKPAD_ACPI_DEBUGFACILITIES\n\tif (dbg_uwbemul) {\n\t\ttp_features.uwb = 1;\n\t\tpr_info(\"uwb switch emulation enabled\\n\");\n\t} else\n#endif\n\tif (tp_features.uwb &&\n\t    !(status & TP_ACPI_UWB_HWPRESENT)) {\n\t\t \n\t\ttp_features.uwb = 0;\n\t\tdbg_printk(TPACPI_DBG_INIT,\n\t\t\t   \"uwb hardware not installed\\n\");\n\t}\n\n\tif (!tp_features.uwb)\n\t\treturn -ENODEV;\n\n\tres = tpacpi_new_rfkill(TPACPI_RFK_UWB_SW_ID,\n\t\t\t\t&uwb_tprfk_ops,\n\t\t\t\tRFKILL_TYPE_UWB,\n\t\t\t\tTPACPI_RFK_UWB_SW_NAME,\n\t\t\t\tfalse);\n\treturn res;\n}\n\nstatic struct ibm_struct uwb_driver_data = {\n\t.name = \"uwb\",\n\t.exit = uwb_exit,\n\t.flags.experimental = 1,\n};\n\n \n\n#ifdef CONFIG_THINKPAD_ACPI_VIDEO\n\nenum video_access_mode {\n\tTPACPI_VIDEO_NONE = 0,\n\tTPACPI_VIDEO_570,\t \n\tTPACPI_VIDEO_770,\t \n\tTPACPI_VIDEO_NEW,\t \n};\n\nenum {\t \n\tTP_ACPI_VIDEO_S_LCD = 0x01,\t \n\tTP_ACPI_VIDEO_S_CRT = 0x02,\t \n\tTP_ACPI_VIDEO_S_DVI = 0x08,\t \n};\n\nenum {   \n\tTP_ACPI_VIDEO_570_PHSCMD = 0x87,\t \n\tTP_ACPI_VIDEO_570_PHSMASK = 0x03,\t \n\tTP_ACPI_VIDEO_570_PHS2CMD = 0x8b,\t \n\tTP_ACPI_VIDEO_570_PHS2SET = 0x80,\t \n};\n\nstatic enum video_access_mode video_supported;\nstatic int video_orig_autosw;\n\nstatic int video_autosw_get(void);\nstatic int video_autosw_set(int enable);\n\nTPACPI_HANDLE(vid, root,\n\t      \"\\\\_SB.PCI.AGP.VGA\",\t \n\t      \"\\\\_SB.PCI0.AGP0.VID0\",\t \n\t      \"\\\\_SB.PCI0.VID0\",\t \n\t      \"\\\\_SB.PCI0.VID\",\t\t \n\t      \"\\\\_SB.PCI0.AGP.VGA\",\t \n\t      \"\\\\_SB.PCI0.AGP.VID\",\t \n\t);\t\t\t\t \n\nTPACPI_HANDLE(vid2, root, \"\\\\_SB.PCI0.AGPB.VID\");\t \n\nstatic int __init video_init(struct ibm_init_struct *iibm)\n{\n\tint ivga;\n\n\tvdbg_printk(TPACPI_DBG_INIT, \"initializing video subdriver\\n\");\n\n\tTPACPI_ACPIHANDLE_INIT(vid);\n\tif (tpacpi_is_ibm())\n\t\tTPACPI_ACPIHANDLE_INIT(vid2);\n\n\tif (vid2_handle && acpi_evalf(NULL, &ivga, \"\\\\IVGA\", \"d\") && ivga)\n\t\t \n\t\tvid_handle = vid2_handle;\n\n\tif (!vid_handle)\n\t\t \n\t\tvideo_supported = TPACPI_VIDEO_NONE;\n\telse if (tpacpi_is_ibm() &&\n\t\t acpi_evalf(vid_handle, &video_orig_autosw, \"SWIT\", \"qd\"))\n\t\t \n\t\tvideo_supported = TPACPI_VIDEO_570;\n\telse if (tpacpi_is_ibm() &&\n\t\t acpi_evalf(vid_handle, &video_orig_autosw, \"^VADL\", \"qd\"))\n\t\t \n\t\tvideo_supported = TPACPI_VIDEO_770;\n\telse\n\t\t \n\t\tvideo_supported = TPACPI_VIDEO_NEW;\n\n\tvdbg_printk(TPACPI_DBG_INIT, \"video is %s, mode %d\\n\",\n\t\tstr_supported(video_supported != TPACPI_VIDEO_NONE),\n\t\tvideo_supported);\n\n\treturn (video_supported != TPACPI_VIDEO_NONE) ? 0 : -ENODEV;\n}\n\nstatic void video_exit(void)\n{\n\tdbg_printk(TPACPI_DBG_EXIT,\n\t\t   \"restoring original video autoswitch mode\\n\");\n\tif (video_autosw_set(video_orig_autosw))\n\t\tpr_err(\"error while trying to restore original video autoswitch mode\\n\");\n}\n\nstatic int video_outputsw_get(void)\n{\n\tint status = 0;\n\tint i;\n\n\tswitch (video_supported) {\n\tcase TPACPI_VIDEO_570:\n\t\tif (!acpi_evalf(NULL, &i, \"\\\\_SB.PHS\", \"dd\",\n\t\t\t\t TP_ACPI_VIDEO_570_PHSCMD))\n\t\t\treturn -EIO;\n\t\tstatus = i & TP_ACPI_VIDEO_570_PHSMASK;\n\t\tbreak;\n\tcase TPACPI_VIDEO_770:\n\t\tif (!acpi_evalf(NULL, &i, \"\\\\VCDL\", \"d\"))\n\t\t\treturn -EIO;\n\t\tif (i)\n\t\t\tstatus |= TP_ACPI_VIDEO_S_LCD;\n\t\tif (!acpi_evalf(NULL, &i, \"\\\\VCDC\", \"d\"))\n\t\t\treturn -EIO;\n\t\tif (i)\n\t\t\tstatus |= TP_ACPI_VIDEO_S_CRT;\n\t\tbreak;\n\tcase TPACPI_VIDEO_NEW:\n\t\tif (!acpi_evalf(NULL, NULL, \"\\\\VUPS\", \"vd\", 1) ||\n\t\t    !acpi_evalf(NULL, &i, \"\\\\VCDC\", \"d\"))\n\t\t\treturn -EIO;\n\t\tif (i)\n\t\t\tstatus |= TP_ACPI_VIDEO_S_CRT;\n\n\t\tif (!acpi_evalf(NULL, NULL, \"\\\\VUPS\", \"vd\", 0) ||\n\t\t    !acpi_evalf(NULL, &i, \"\\\\VCDL\", \"d\"))\n\t\t\treturn -EIO;\n\t\tif (i)\n\t\t\tstatus |= TP_ACPI_VIDEO_S_LCD;\n\t\tif (!acpi_evalf(NULL, &i, \"\\\\VCDD\", \"d\"))\n\t\t\treturn -EIO;\n\t\tif (i)\n\t\t\tstatus |= TP_ACPI_VIDEO_S_DVI;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOSYS;\n\t}\n\n\treturn status;\n}\n\nstatic int video_outputsw_set(int status)\n{\n\tint autosw;\n\tint res = 0;\n\n\tswitch (video_supported) {\n\tcase TPACPI_VIDEO_570:\n\t\tres = acpi_evalf(NULL, NULL,\n\t\t\t\t \"\\\\_SB.PHS2\", \"vdd\",\n\t\t\t\t TP_ACPI_VIDEO_570_PHS2CMD,\n\t\t\t\t status | TP_ACPI_VIDEO_570_PHS2SET);\n\t\tbreak;\n\tcase TPACPI_VIDEO_770:\n\t\tautosw = video_autosw_get();\n\t\tif (autosw < 0)\n\t\t\treturn autosw;\n\n\t\tres = video_autosw_set(1);\n\t\tif (res)\n\t\t\treturn res;\n\t\tres = acpi_evalf(vid_handle, NULL,\n\t\t\t\t \"ASWT\", \"vdd\", status * 0x100, 0);\n\t\tif (!autosw && video_autosw_set(autosw)) {\n\t\t\tpr_err(\"video auto-switch left enabled due to error\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tbreak;\n\tcase TPACPI_VIDEO_NEW:\n\t\tres = acpi_evalf(NULL, NULL, \"\\\\VUPS\", \"vd\", 0x80) &&\n\t\t      acpi_evalf(NULL, NULL, \"\\\\VSDS\", \"vdd\", status, 1);\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOSYS;\n\t}\n\n\treturn (res) ? 0 : -EIO;\n}\n\nstatic int video_autosw_get(void)\n{\n\tint autosw = 0;\n\n\tswitch (video_supported) {\n\tcase TPACPI_VIDEO_570:\n\t\tif (!acpi_evalf(vid_handle, &autosw, \"SWIT\", \"d\"))\n\t\t\treturn -EIO;\n\t\tbreak;\n\tcase TPACPI_VIDEO_770:\n\tcase TPACPI_VIDEO_NEW:\n\t\tif (!acpi_evalf(vid_handle, &autosw, \"^VDEE\", \"d\"))\n\t\t\treturn -EIO;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOSYS;\n\t}\n\n\treturn autosw & 1;\n}\n\nstatic int video_autosw_set(int enable)\n{\n\tif (!acpi_evalf(vid_handle, NULL, \"_DOS\", \"vd\", (enable) ? 1 : 0))\n\t\treturn -EIO;\n\treturn 0;\n}\n\nstatic int video_outputsw_cycle(void)\n{\n\tint autosw = video_autosw_get();\n\tint res;\n\n\tif (autosw < 0)\n\t\treturn autosw;\n\n\tswitch (video_supported) {\n\tcase TPACPI_VIDEO_570:\n\t\tres = video_autosw_set(1);\n\t\tif (res)\n\t\t\treturn res;\n\t\tres = acpi_evalf(ec_handle, NULL, \"_Q16\", \"v\");\n\t\tbreak;\n\tcase TPACPI_VIDEO_770:\n\tcase TPACPI_VIDEO_NEW:\n\t\tres = video_autosw_set(1);\n\t\tif (res)\n\t\t\treturn res;\n\t\tres = acpi_evalf(vid_handle, NULL, \"VSWT\", \"v\");\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOSYS;\n\t}\n\tif (!autosw && video_autosw_set(autosw)) {\n\t\tpr_err(\"video auto-switch left enabled due to error\\n\");\n\t\treturn -EIO;\n\t}\n\n\treturn (res) ? 0 : -EIO;\n}\n\nstatic int video_expand_toggle(void)\n{\n\tswitch (video_supported) {\n\tcase TPACPI_VIDEO_570:\n\t\treturn acpi_evalf(ec_handle, NULL, \"_Q17\", \"v\") ?\n\t\t\t0 : -EIO;\n\tcase TPACPI_VIDEO_770:\n\t\treturn acpi_evalf(vid_handle, NULL, \"VEXP\", \"v\") ?\n\t\t\t0 : -EIO;\n\tcase TPACPI_VIDEO_NEW:\n\t\treturn acpi_evalf(NULL, NULL, \"\\\\VEXP\", \"v\") ?\n\t\t\t0 : -EIO;\n\tdefault:\n\t\treturn -ENOSYS;\n\t}\n\t \n}\n\nstatic int video_read(struct seq_file *m)\n{\n\tint status, autosw;\n\n\tif (video_supported == TPACPI_VIDEO_NONE) {\n\t\tseq_printf(m, \"status:\\t\\tnot supported\\n\");\n\t\treturn 0;\n\t}\n\n\t \n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tstatus = video_outputsw_get();\n\tif (status < 0)\n\t\treturn status;\n\n\tautosw = video_autosw_get();\n\tif (autosw < 0)\n\t\treturn autosw;\n\n\tseq_printf(m, \"status:\\t\\tsupported\\n\");\n\tseq_printf(m, \"lcd:\\t\\t%s\\n\", str_enabled_disabled(status & BIT(0)));\n\tseq_printf(m, \"crt:\\t\\t%s\\n\", str_enabled_disabled(status & BIT(1)));\n\tif (video_supported == TPACPI_VIDEO_NEW)\n\t\tseq_printf(m, \"dvi:\\t\\t%s\\n\", str_enabled_disabled(status & BIT(3)));\n\tseq_printf(m, \"auto:\\t\\t%s\\n\", str_enabled_disabled(autosw & BIT(0)));\n\tseq_printf(m, \"commands:\\tlcd_enable, lcd_disable\\n\");\n\tseq_printf(m, \"commands:\\tcrt_enable, crt_disable\\n\");\n\tif (video_supported == TPACPI_VIDEO_NEW)\n\t\tseq_printf(m, \"commands:\\tdvi_enable, dvi_disable\\n\");\n\tseq_printf(m, \"commands:\\tauto_enable, auto_disable\\n\");\n\tseq_printf(m, \"commands:\\tvideo_switch, expand_toggle\\n\");\n\n\treturn 0;\n}\n\nstatic int video_write(char *buf)\n{\n\tchar *cmd;\n\tint enable, disable, status;\n\tint res;\n\n\tif (video_supported == TPACPI_VIDEO_NONE)\n\t\treturn -ENODEV;\n\n\t \n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tenable = 0;\n\tdisable = 0;\n\n\twhile ((cmd = strsep(&buf, \",\"))) {\n\t\tif (strstarts(cmd, \"lcd_enable\")) {\n\t\t\tenable |= TP_ACPI_VIDEO_S_LCD;\n\t\t} else if (strstarts(cmd, \"lcd_disable\")) {\n\t\t\tdisable |= TP_ACPI_VIDEO_S_LCD;\n\t\t} else if (strstarts(cmd, \"crt_enable\")) {\n\t\t\tenable |= TP_ACPI_VIDEO_S_CRT;\n\t\t} else if (strstarts(cmd, \"crt_disable\")) {\n\t\t\tdisable |= TP_ACPI_VIDEO_S_CRT;\n\t\t} else if (video_supported == TPACPI_VIDEO_NEW &&\n\t\t\t   strstarts(cmd, \"dvi_enable\")) {\n\t\t\tenable |= TP_ACPI_VIDEO_S_DVI;\n\t\t} else if (video_supported == TPACPI_VIDEO_NEW &&\n\t\t\t   strstarts(cmd, \"dvi_disable\")) {\n\t\t\tdisable |= TP_ACPI_VIDEO_S_DVI;\n\t\t} else if (strstarts(cmd, \"auto_enable\")) {\n\t\t\tres = video_autosw_set(1);\n\t\t\tif (res)\n\t\t\t\treturn res;\n\t\t} else if (strstarts(cmd, \"auto_disable\")) {\n\t\t\tres = video_autosw_set(0);\n\t\t\tif (res)\n\t\t\t\treturn res;\n\t\t} else if (strstarts(cmd, \"video_switch\")) {\n\t\t\tres = video_outputsw_cycle();\n\t\t\tif (res)\n\t\t\t\treturn res;\n\t\t} else if (strstarts(cmd, \"expand_toggle\")) {\n\t\t\tres = video_expand_toggle();\n\t\t\tif (res)\n\t\t\t\treturn res;\n\t\t} else\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (enable || disable) {\n\t\tstatus = video_outputsw_get();\n\t\tif (status < 0)\n\t\t\treturn status;\n\t\tres = video_outputsw_set((status & ~disable) | enable);\n\t\tif (res)\n\t\t\treturn res;\n\t}\n\n\treturn 0;\n}\n\nstatic struct ibm_struct video_driver_data = {\n\t.name = \"video\",\n\t.read = video_read,\n\t.write = video_write,\n\t.exit = video_exit,\n};\n\n#endif  \n\n \n\nstatic enum led_brightness kbdlight_brightness;\nstatic DEFINE_MUTEX(kbdlight_mutex);\n\nstatic int kbdlight_set_level(int level)\n{\n\tint ret = 0;\n\n\tif (!hkey_handle)\n\t\treturn -ENXIO;\n\n\tmutex_lock(&kbdlight_mutex);\n\n\tif (!acpi_evalf(hkey_handle, NULL, \"MLCS\", \"dd\", level))\n\t\tret = -EIO;\n\telse\n\t\tkbdlight_brightness = level;\n\n\tmutex_unlock(&kbdlight_mutex);\n\n\treturn ret;\n}\n\nstatic int kbdlight_get_level(void)\n{\n\tint status = 0;\n\n\tif (!hkey_handle)\n\t\treturn -ENXIO;\n\n\tif (!acpi_evalf(hkey_handle, &status, \"MLCG\", \"dd\", 0))\n\t\treturn -EIO;\n\n\tif (status < 0)\n\t\treturn status;\n\n\treturn status & 0x3;\n}\n\nstatic bool kbdlight_is_supported(void)\n{\n\tint status = 0;\n\n\tif (!hkey_handle)\n\t\treturn false;\n\n\tif (!acpi_has_method(hkey_handle, \"MLCG\")) {\n\t\tvdbg_printk(TPACPI_DBG_INIT, \"kbdlight MLCG is unavailable\\n\");\n\t\treturn false;\n\t}\n\n\tif (!acpi_evalf(hkey_handle, &status, \"MLCG\", \"qdd\", 0)) {\n\t\tvdbg_printk(TPACPI_DBG_INIT, \"kbdlight MLCG failed\\n\");\n\t\treturn false;\n\t}\n\n\tif (status < 0) {\n\t\tvdbg_printk(TPACPI_DBG_INIT, \"kbdlight MLCG err: %d\\n\", status);\n\t\treturn false;\n\t}\n\n\tvdbg_printk(TPACPI_DBG_INIT, \"kbdlight MLCG returned 0x%x\\n\", status);\n\t \n\treturn status & BIT(9);\n}\n\nstatic int kbdlight_sysfs_set(struct led_classdev *led_cdev,\n\t\t\tenum led_brightness brightness)\n{\n\treturn kbdlight_set_level(brightness);\n}\n\nstatic enum led_brightness kbdlight_sysfs_get(struct led_classdev *led_cdev)\n{\n\tint level;\n\n\tlevel = kbdlight_get_level();\n\tif (level < 0)\n\t\treturn 0;\n\n\treturn level;\n}\n\nstatic struct tpacpi_led_classdev tpacpi_led_kbdlight = {\n\t.led_classdev = {\n\t\t.name\t\t= \"tpacpi::kbd_backlight\",\n\t\t.max_brightness\t= 2,\n\t\t.flags\t\t= LED_BRIGHT_HW_CHANGED,\n\t\t.brightness_set_blocking = &kbdlight_sysfs_set,\n\t\t.brightness_get\t= &kbdlight_sysfs_get,\n\t}\n};\n\nstatic int __init kbdlight_init(struct ibm_init_struct *iibm)\n{\n\tint rc;\n\n\tvdbg_printk(TPACPI_DBG_INIT, \"initializing kbdlight subdriver\\n\");\n\n\tTPACPI_ACPIHANDLE_INIT(hkey);\n\n\tif (!kbdlight_is_supported()) {\n\t\ttp_features.kbdlight = 0;\n\t\tvdbg_printk(TPACPI_DBG_INIT, \"kbdlight is unsupported\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tkbdlight_brightness = kbdlight_sysfs_get(NULL);\n\ttp_features.kbdlight = 1;\n\n\trc = led_classdev_register(&tpacpi_pdev->dev,\n\t\t\t\t   &tpacpi_led_kbdlight.led_classdev);\n\tif (rc < 0) {\n\t\ttp_features.kbdlight = 0;\n\t\treturn rc;\n\t}\n\n\ttpacpi_hotkey_driver_mask_set(hotkey_driver_mask |\n\t\t\t\t      TP_ACPI_HKEY_KBD_LIGHT_MASK);\n\treturn 0;\n}\n\nstatic void kbdlight_exit(void)\n{\n\tled_classdev_unregister(&tpacpi_led_kbdlight.led_classdev);\n}\n\nstatic int kbdlight_set_level_and_update(int level)\n{\n\tint ret;\n\tstruct led_classdev *led_cdev;\n\n\tret = kbdlight_set_level(level);\n\tled_cdev = &tpacpi_led_kbdlight.led_classdev;\n\n\tif (ret == 0 && !(led_cdev->flags & LED_SUSPENDED))\n\t\tled_cdev->brightness = level;\n\n\treturn ret;\n}\n\nstatic int kbdlight_read(struct seq_file *m)\n{\n\tint level;\n\n\tif (!tp_features.kbdlight) {\n\t\tseq_printf(m, \"status:\\t\\tnot supported\\n\");\n\t} else {\n\t\tlevel = kbdlight_get_level();\n\t\tif (level < 0)\n\t\t\tseq_printf(m, \"status:\\t\\terror %d\\n\", level);\n\t\telse\n\t\t\tseq_printf(m, \"status:\\t\\t%d\\n\", level);\n\t\tseq_printf(m, \"commands:\\t0, 1, 2\\n\");\n\t}\n\n\treturn 0;\n}\n\nstatic int kbdlight_write(char *buf)\n{\n\tchar *cmd;\n\tint res, level = -EINVAL;\n\n\tif (!tp_features.kbdlight)\n\t\treturn -ENODEV;\n\n\twhile ((cmd = strsep(&buf, \",\"))) {\n\t\tres = kstrtoint(cmd, 10, &level);\n\t\tif (res < 0)\n\t\t\treturn res;\n\t}\n\n\tif (level >= 3 || level < 0)\n\t\treturn -EINVAL;\n\n\treturn kbdlight_set_level_and_update(level);\n}\n\nstatic void kbdlight_suspend(void)\n{\n\tstruct led_classdev *led_cdev;\n\n\tif (!tp_features.kbdlight)\n\t\treturn;\n\n\tled_cdev = &tpacpi_led_kbdlight.led_classdev;\n\tled_update_brightness(led_cdev);\n\tled_classdev_suspend(led_cdev);\n}\n\nstatic void kbdlight_resume(void)\n{\n\tif (!tp_features.kbdlight)\n\t\treturn;\n\n\tled_classdev_resume(&tpacpi_led_kbdlight.led_classdev);\n}\n\nstatic struct ibm_struct kbdlight_driver_data = {\n\t.name = \"kbdlight\",\n\t.read = kbdlight_read,\n\t.write = kbdlight_write,\n\t.suspend = kbdlight_suspend,\n\t.resume = kbdlight_resume,\n\t.exit = kbdlight_exit,\n};\n\n \n\nTPACPI_HANDLE(lght, root, \"\\\\LGHT\");\t \nTPACPI_HANDLE(ledb, ec, \"LEDB\");\t\t \n\nstatic int light_get_status(void)\n{\n\tint status = 0;\n\n\tif (tp_features.light_status) {\n\t\tif (!acpi_evalf(ec_handle, &status, \"KBLT\", \"d\"))\n\t\t\treturn -EIO;\n\t\treturn (!!status);\n\t}\n\n\treturn -ENXIO;\n}\n\nstatic int light_set_status(int status)\n{\n\tint rc;\n\n\tif (tp_features.light) {\n\t\tif (cmos_handle) {\n\t\t\trc = acpi_evalf(cmos_handle, NULL, NULL, \"vd\",\n\t\t\t\t\t(status) ?\n\t\t\t\t\t\tTP_CMOS_THINKLIGHT_ON :\n\t\t\t\t\t\tTP_CMOS_THINKLIGHT_OFF);\n\t\t} else {\n\t\t\trc = acpi_evalf(lght_handle, NULL, NULL, \"vd\",\n\t\t\t\t\t(status) ? 1 : 0);\n\t\t}\n\t\treturn (rc) ? 0 : -EIO;\n\t}\n\n\treturn -ENXIO;\n}\n\nstatic int light_sysfs_set(struct led_classdev *led_cdev,\n\t\t\tenum led_brightness brightness)\n{\n\treturn light_set_status((brightness != LED_OFF) ?\n\t\t\t\tTPACPI_LED_ON : TPACPI_LED_OFF);\n}\n\nstatic enum led_brightness light_sysfs_get(struct led_classdev *led_cdev)\n{\n\treturn (light_get_status() == 1) ? LED_ON : LED_OFF;\n}\n\nstatic struct tpacpi_led_classdev tpacpi_led_thinklight = {\n\t.led_classdev = {\n\t\t.name\t\t= \"tpacpi::thinklight\",\n\t\t.max_brightness\t= 1,\n\t\t.brightness_set_blocking = &light_sysfs_set,\n\t\t.brightness_get\t= &light_sysfs_get,\n\t}\n};\n\nstatic int __init light_init(struct ibm_init_struct *iibm)\n{\n\tint rc;\n\n\tvdbg_printk(TPACPI_DBG_INIT, \"initializing light subdriver\\n\");\n\n\tif (tpacpi_is_ibm()) {\n\t\tTPACPI_ACPIHANDLE_INIT(ledb);\n\t\tTPACPI_ACPIHANDLE_INIT(lght);\n\t}\n\tTPACPI_ACPIHANDLE_INIT(cmos);\n\n\t \n\ttp_features.light = (cmos_handle || lght_handle) && !ledb_handle;\n\n\tif (tp_features.light)\n\t\t \n\t\ttp_features.light_status =\n\t\t\tacpi_evalf(ec_handle, NULL, \"KBLT\", \"qv\");\n\n\tvdbg_printk(TPACPI_DBG_INIT, \"light is %s, light status is %s\\n\",\n\t\tstr_supported(tp_features.light),\n\t\tstr_supported(tp_features.light_status));\n\n\tif (!tp_features.light)\n\t\treturn -ENODEV;\n\n\trc = led_classdev_register(&tpacpi_pdev->dev,\n\t\t\t\t   &tpacpi_led_thinklight.led_classdev);\n\n\tif (rc < 0) {\n\t\ttp_features.light = 0;\n\t\ttp_features.light_status = 0;\n\t} else  {\n\t\trc = 0;\n\t}\n\n\treturn rc;\n}\n\nstatic void light_exit(void)\n{\n\tled_classdev_unregister(&tpacpi_led_thinklight.led_classdev);\n}\n\nstatic int light_read(struct seq_file *m)\n{\n\tint status;\n\n\tif (!tp_features.light) {\n\t\tseq_printf(m, \"status:\\t\\tnot supported\\n\");\n\t} else if (!tp_features.light_status) {\n\t\tseq_printf(m, \"status:\\t\\tunknown\\n\");\n\t\tseq_printf(m, \"commands:\\ton, off\\n\");\n\t} else {\n\t\tstatus = light_get_status();\n\t\tif (status < 0)\n\t\t\treturn status;\n\t\tseq_printf(m, \"status:\\t\\t%s\\n\", str_on_off(status & BIT(0)));\n\t\tseq_printf(m, \"commands:\\ton, off\\n\");\n\t}\n\n\treturn 0;\n}\n\nstatic int light_write(char *buf)\n{\n\tchar *cmd;\n\tint newstatus = 0;\n\n\tif (!tp_features.light)\n\t\treturn -ENODEV;\n\n\twhile ((cmd = strsep(&buf, \",\"))) {\n\t\tif (strstarts(cmd, \"on\")) {\n\t\t\tnewstatus = 1;\n\t\t} else if (strstarts(cmd, \"off\")) {\n\t\t\tnewstatus = 0;\n\t\t} else\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn light_set_status(newstatus);\n}\n\nstatic struct ibm_struct light_driver_data = {\n\t.name = \"light\",\n\t.read = light_read,\n\t.write = light_write,\n\t.exit = light_exit,\n};\n\n \n\n \nstatic ssize_t cmos_command_store(struct device *dev,\n\t\t\t    struct device_attribute *attr,\n\t\t\t    const char *buf, size_t count)\n{\n\tunsigned long cmos_cmd;\n\tint res;\n\n\tif (parse_strtoul(buf, 21, &cmos_cmd))\n\t\treturn -EINVAL;\n\n\tres = issue_thinkpad_cmos_command(cmos_cmd);\n\treturn (res) ? res : count;\n}\n\nstatic DEVICE_ATTR_WO(cmos_command);\n\nstatic struct attribute *cmos_attributes[] = {\n\t&dev_attr_cmos_command.attr,\n\tNULL\n};\n\nstatic umode_t cmos_attr_is_visible(struct kobject *kobj,\n\t\t\t\t    struct attribute *attr, int n)\n{\n\treturn cmos_handle ? attr->mode : 0;\n}\n\nstatic const struct attribute_group cmos_attr_group = {\n\t.is_visible = cmos_attr_is_visible,\n\t.attrs = cmos_attributes,\n};\n\n \n\nstatic int __init cmos_init(struct ibm_init_struct *iibm)\n{\n\tvdbg_printk(TPACPI_DBG_INIT,\n\t\t    \"initializing cmos commands subdriver\\n\");\n\n\tTPACPI_ACPIHANDLE_INIT(cmos);\n\n\tvdbg_printk(TPACPI_DBG_INIT, \"cmos commands are %s\\n\",\n\t\t    str_supported(cmos_handle != NULL));\n\n\treturn cmos_handle ? 0 : -ENODEV;\n}\n\nstatic int cmos_read(struct seq_file *m)\n{\n\t \n\tif (!cmos_handle)\n\t\tseq_printf(m, \"status:\\t\\tnot supported\\n\");\n\telse {\n\t\tseq_printf(m, \"status:\\t\\tsupported\\n\");\n\t\tseq_printf(m, \"commands:\\t<cmd> (<cmd> is 0-21)\\n\");\n\t}\n\n\treturn 0;\n}\n\nstatic int cmos_write(char *buf)\n{\n\tchar *cmd;\n\tint cmos_cmd, res;\n\n\twhile ((cmd = strsep(&buf, \",\"))) {\n\t\tif (sscanf(cmd, \"%u\", &cmos_cmd) == 1 &&\n\t\t    cmos_cmd >= 0 && cmos_cmd <= 21) {\n\t\t\t \n\t\t} else\n\t\t\treturn -EINVAL;\n\n\t\tres = issue_thinkpad_cmos_command(cmos_cmd);\n\t\tif (res)\n\t\t\treturn res;\n\t}\n\n\treturn 0;\n}\n\nstatic struct ibm_struct cmos_driver_data = {\n\t.name = \"cmos\",\n\t.read = cmos_read,\n\t.write = cmos_write,\n};\n\n \n\nenum led_access_mode {\n\tTPACPI_LED_NONE = 0,\n\tTPACPI_LED_570,\t \n\tTPACPI_LED_OLD,\t \n\tTPACPI_LED_NEW,\t \n};\n\nenum {\t \n\tTPACPI_LED_EC_HLCL = 0x0c,\t \n\tTPACPI_LED_EC_HLBL = 0x0d,\t \n\tTPACPI_LED_EC_HLMS = 0x0e,\t \n};\n\nstatic enum led_access_mode led_supported;\n\nstatic acpi_handle led_handle;\n\n#define TPACPI_LED_NUMLEDS 16\nstatic struct tpacpi_led_classdev *tpacpi_leds;\nstatic enum led_status_t tpacpi_led_state_cache[TPACPI_LED_NUMLEDS];\nstatic const char * const tpacpi_led_names[TPACPI_LED_NUMLEDS] = {\n\t \n\t\"tpacpi::power\",\n\t\"tpacpi:orange:batt\",\n\t\"tpacpi:green:batt\",\n\t\"tpacpi::dock_active\",\n\t\"tpacpi::bay_active\",\n\t\"tpacpi::dock_batt\",\n\t\"tpacpi::unknown_led\",\n\t\"tpacpi::standby\",\n\t\"tpacpi::dock_status1\",\n\t\"tpacpi::dock_status2\",\n\t\"tpacpi::lid_logo_dot\",\n\t\"tpacpi::unknown_led3\",\n\t\"tpacpi::thinkvantage\",\n};\n#define TPACPI_SAFE_LEDS\t0x1481U\n\nstatic inline bool tpacpi_is_led_restricted(const unsigned int led)\n{\n#ifdef CONFIG_THINKPAD_ACPI_UNSAFE_LEDS\n\treturn false;\n#else\n\treturn (1U & (TPACPI_SAFE_LEDS >> led)) == 0;\n#endif\n}\n\nstatic int led_get_status(const unsigned int led)\n{\n\tint status;\n\tenum led_status_t led_s;\n\n\tswitch (led_supported) {\n\tcase TPACPI_LED_570:\n\t\tif (!acpi_evalf(ec_handle,\n\t\t\t\t&status, \"GLED\", \"dd\", 1 << led))\n\t\t\treturn -EIO;\n\t\tled_s = (status == 0) ?\n\t\t\t\tTPACPI_LED_OFF :\n\t\t\t\t((status == 1) ?\n\t\t\t\t\tTPACPI_LED_ON :\n\t\t\t\t\tTPACPI_LED_BLINK);\n\t\ttpacpi_led_state_cache[led] = led_s;\n\t\treturn led_s;\n\tdefault:\n\t\treturn -ENXIO;\n\t}\n\n\t \n}\n\nstatic int led_set_status(const unsigned int led,\n\t\t\t  const enum led_status_t ledstatus)\n{\n\t \n\tstatic const unsigned int led_sled_arg1[] = { 0, 1, 3 };\n\tstatic const unsigned int led_led_arg1[] = { 0, 0x80, 0xc0 };\n\n\tint rc = 0;\n\n\tswitch (led_supported) {\n\tcase TPACPI_LED_570:\n\t\t \n\t\tif (unlikely(led > 7))\n\t\t\treturn -EINVAL;\n\t\tif (unlikely(tpacpi_is_led_restricted(led)))\n\t\t\treturn -EPERM;\n\t\tif (!acpi_evalf(led_handle, NULL, NULL, \"vdd\",\n\t\t\t\t(1 << led), led_sled_arg1[ledstatus]))\n\t\t\treturn -EIO;\n\t\tbreak;\n\tcase TPACPI_LED_OLD:\n\t\t \n\t\tif (unlikely(led > 7))\n\t\t\treturn -EINVAL;\n\t\tif (unlikely(tpacpi_is_led_restricted(led)))\n\t\t\treturn -EPERM;\n\t\trc = ec_write(TPACPI_LED_EC_HLMS, (1 << led));\n\t\tif (rc >= 0)\n\t\t\trc = ec_write(TPACPI_LED_EC_HLBL,\n\t\t\t\t      (ledstatus == TPACPI_LED_BLINK) << led);\n\t\tif (rc >= 0)\n\t\t\trc = ec_write(TPACPI_LED_EC_HLCL,\n\t\t\t\t      (ledstatus != TPACPI_LED_OFF) << led);\n\t\tbreak;\n\tcase TPACPI_LED_NEW:\n\t\t \n\t\tif (unlikely(led >= TPACPI_LED_NUMLEDS))\n\t\t\treturn -EINVAL;\n\t\tif (unlikely(tpacpi_is_led_restricted(led)))\n\t\t\treturn -EPERM;\n\t\tif (!acpi_evalf(led_handle, NULL, NULL, \"vdd\",\n\t\t\t\tled, led_led_arg1[ledstatus]))\n\t\t\treturn -EIO;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENXIO;\n\t}\n\n\tif (!rc)\n\t\ttpacpi_led_state_cache[led] = ledstatus;\n\n\treturn rc;\n}\n\nstatic int led_sysfs_set(struct led_classdev *led_cdev,\n\t\t\tenum led_brightness brightness)\n{\n\tstruct tpacpi_led_classdev *data = container_of(led_cdev,\n\t\t\t     struct tpacpi_led_classdev, led_classdev);\n\tenum led_status_t new_state;\n\n\tif (brightness == LED_OFF)\n\t\tnew_state = TPACPI_LED_OFF;\n\telse if (tpacpi_led_state_cache[data->led] != TPACPI_LED_BLINK)\n\t\tnew_state = TPACPI_LED_ON;\n\telse\n\t\tnew_state = TPACPI_LED_BLINK;\n\n\treturn led_set_status(data->led, new_state);\n}\n\nstatic int led_sysfs_blink_set(struct led_classdev *led_cdev,\n\t\t\tunsigned long *delay_on, unsigned long *delay_off)\n{\n\tstruct tpacpi_led_classdev *data = container_of(led_cdev,\n\t\t\t     struct tpacpi_led_classdev, led_classdev);\n\n\t \n\tif (*delay_on == 0 && *delay_off == 0) {\n\t\t \n\t\t*delay_on = 500;  \n\t\t*delay_off = 500;  \n\t} else if ((*delay_on != 500) || (*delay_off != 500))\n\t\treturn -EINVAL;\n\n\treturn led_set_status(data->led, TPACPI_LED_BLINK);\n}\n\nstatic enum led_brightness led_sysfs_get(struct led_classdev *led_cdev)\n{\n\tint rc;\n\n\tstruct tpacpi_led_classdev *data = container_of(led_cdev,\n\t\t\t     struct tpacpi_led_classdev, led_classdev);\n\n\trc = led_get_status(data->led);\n\n\tif (rc == TPACPI_LED_OFF || rc < 0)\n\t\trc = LED_OFF;\t \n\telse\n\t\trc = LED_FULL;\n\n\treturn rc;\n}\n\nstatic void led_exit(void)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < TPACPI_LED_NUMLEDS; i++)\n\t\tled_classdev_unregister(&tpacpi_leds[i].led_classdev);\n\n\tkfree(tpacpi_leds);\n}\n\nstatic int __init tpacpi_init_led(unsigned int led)\n{\n\t \n\tif (!tpacpi_led_names[led])\n\t\treturn 0;\n\n\ttpacpi_leds[led].led_classdev.brightness_set_blocking = &led_sysfs_set;\n\ttpacpi_leds[led].led_classdev.blink_set = &led_sysfs_blink_set;\n\tif (led_supported == TPACPI_LED_570)\n\t\ttpacpi_leds[led].led_classdev.brightness_get = &led_sysfs_get;\n\n\ttpacpi_leds[led].led_classdev.name = tpacpi_led_names[led];\n\ttpacpi_leds[led].led_classdev.flags = LED_RETAIN_AT_SHUTDOWN;\n\ttpacpi_leds[led].led = led;\n\n\treturn led_classdev_register(&tpacpi_pdev->dev, &tpacpi_leds[led].led_classdev);\n}\n\nstatic const struct tpacpi_quirk led_useful_qtable[] __initconst = {\n\tTPACPI_Q_IBM('1', 'E', 0x009f),  \n\tTPACPI_Q_IBM('1', 'N', 0x009f),  \n\tTPACPI_Q_IBM('1', 'G', 0x009f),  \n\n\tTPACPI_Q_IBM('1', 'I', 0x0097),  \n\tTPACPI_Q_IBM('1', 'R', 0x0097),  \n\tTPACPI_Q_IBM('7', '0', 0x0097),  \n\tTPACPI_Q_IBM('1', 'Y', 0x0097),  \n\tTPACPI_Q_IBM('1', 'W', 0x0097),  \n\tTPACPI_Q_IBM('1', 'V', 0x0097),  \n\tTPACPI_Q_IBM('7', '8', 0x0097),  \n\tTPACPI_Q_IBM('7', '6', 0x0097),  \n\n\tTPACPI_Q_IBM('1', 'K', 0x00bf),  \n\tTPACPI_Q_IBM('1', 'Q', 0x00bf),  \n\tTPACPI_Q_IBM('1', 'U', 0x00bf),  \n\tTPACPI_Q_IBM('7', '4', 0x00bf),  \n\tTPACPI_Q_IBM('7', '5', 0x00bf),  \n\n\tTPACPI_Q_IBM('7', '9', 0x1f97),  \n\tTPACPI_Q_IBM('7', '7', 0x1f97),  \n\tTPACPI_Q_IBM('7', 'F', 0x1f97),  \n\tTPACPI_Q_IBM('7', 'B', 0x1fb7),  \n\n\t \n\n\t \n\t{  \n\t  .vendor = PCI_VENDOR_ID_LENOVO,\n\t  .bios = TPACPI_MATCH_ANY, .ec = TPACPI_MATCH_ANY,\n\t  .quirks = 0x1fffU,\n\t},\n\t{  \n\t  .vendor = PCI_VENDOR_ID_IBM,\n\t  .bios = TPACPI_MATCH_ANY, .ec = TPACPI_MATCH_UNKNOWN,\n\t  .quirks = 0x00ffU,\n\t},\n\t{  \n\t  .vendor = PCI_VENDOR_ID_IBM,\n\t  .bios = TPACPI_MATCH_ANY, .ec = TPACPI_MATCH_ANY,\n\t  .quirks = 0x00bfU,\n\t},\n};\n\nstatic enum led_access_mode __init led_init_detect_mode(void)\n{\n\tacpi_status status;\n\n\tif (tpacpi_is_ibm()) {\n\t\t \n\t\tstatus = acpi_get_handle(ec_handle, \"SLED\", &led_handle);\n\t\tif (ACPI_SUCCESS(status))\n\t\t\treturn TPACPI_LED_570;\n\n\t\t \n\t\tstatus = acpi_get_handle(ec_handle, \"SYSL\", &led_handle);\n\t\tif (ACPI_SUCCESS(status))\n\t\t\treturn TPACPI_LED_OLD;\n\t}\n\n\t \n\tstatus = acpi_get_handle(ec_handle, \"LED\", &led_handle);\n\tif (ACPI_SUCCESS(status))\n\t\treturn TPACPI_LED_NEW;\n\n\t \n\tled_handle = NULL;\n\treturn TPACPI_LED_NONE;\n}\n\nstatic int __init led_init(struct ibm_init_struct *iibm)\n{\n\tunsigned int i;\n\tint rc;\n\tunsigned long useful_leds;\n\n\tvdbg_printk(TPACPI_DBG_INIT, \"initializing LED subdriver\\n\");\n\n\tled_supported = led_init_detect_mode();\n\n\tif (led_supported != TPACPI_LED_NONE) {\n\t\tuseful_leds = tpacpi_check_quirks(led_useful_qtable,\n\t\t\t\tARRAY_SIZE(led_useful_qtable));\n\n\t\tif (!useful_leds) {\n\t\t\tled_handle = NULL;\n\t\t\tled_supported = TPACPI_LED_NONE;\n\t\t}\n\t}\n\n\tvdbg_printk(TPACPI_DBG_INIT, \"LED commands are %s, mode %d\\n\",\n\t\tstr_supported(led_supported), led_supported);\n\n\tif (led_supported == TPACPI_LED_NONE)\n\t\treturn -ENODEV;\n\n\ttpacpi_leds = kcalloc(TPACPI_LED_NUMLEDS, sizeof(*tpacpi_leds),\n\t\t\t      GFP_KERNEL);\n\tif (!tpacpi_leds) {\n\t\tpr_err(\"Out of memory for LED data\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tfor (i = 0; i < TPACPI_LED_NUMLEDS; i++) {\n\t\ttpacpi_leds[i].led = -1;\n\n\t\tif (!tpacpi_is_led_restricted(i) && test_bit(i, &useful_leds)) {\n\t\t\trc = tpacpi_init_led(i);\n\t\t\tif (rc < 0) {\n\t\t\t\tled_exit();\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\t}\n\n#ifdef CONFIG_THINKPAD_ACPI_UNSAFE_LEDS\n\tpr_notice(\"warning: userspace override of important firmware LEDs is enabled\\n\");\n#endif\n\treturn 0;\n}\n\n#define str_led_status(s)\t((s) >= TPACPI_LED_BLINK ? \"blinking\" : str_on_off(s))\n\nstatic int led_read(struct seq_file *m)\n{\n\tif (!led_supported) {\n\t\tseq_printf(m, \"status:\\t\\tnot supported\\n\");\n\t\treturn 0;\n\t}\n\tseq_printf(m, \"status:\\t\\tsupported\\n\");\n\n\tif (led_supported == TPACPI_LED_570) {\n\t\t \n\t\tint i, status;\n\t\tfor (i = 0; i < 8; i++) {\n\t\t\tstatus = led_get_status(i);\n\t\t\tif (status < 0)\n\t\t\t\treturn -EIO;\n\t\t\tseq_printf(m, \"%d:\\t\\t%s\\n\", i, str_led_status(status));\n\t\t}\n\t}\n\n\tseq_printf(m, \"commands:\\t<led> on, <led> off, <led> blink (<led> is 0-15)\\n\");\n\n\treturn 0;\n}\n\nstatic int led_write(char *buf)\n{\n\tchar *cmd;\n\tint led, rc;\n\tenum led_status_t s;\n\n\tif (!led_supported)\n\t\treturn -ENODEV;\n\n\twhile ((cmd = strsep(&buf, \",\"))) {\n\t\tif (sscanf(cmd, \"%d\", &led) != 1)\n\t\t\treturn -EINVAL;\n\n\t\tif (led < 0 || led > (TPACPI_LED_NUMLEDS - 1))\n\t\t\treturn -ENODEV;\n\n\t\tif (tpacpi_leds[led].led < 0)\n\t\t\treturn -ENODEV;\n\n\t\tif (strstr(cmd, \"off\")) {\n\t\t\ts = TPACPI_LED_OFF;\n\t\t} else if (strstr(cmd, \"on\")) {\n\t\t\ts = TPACPI_LED_ON;\n\t\t} else if (strstr(cmd, \"blink\")) {\n\t\t\ts = TPACPI_LED_BLINK;\n\t\t} else {\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\trc = led_set_status(led, s);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t}\n\n\treturn 0;\n}\n\nstatic struct ibm_struct led_driver_data = {\n\t.name = \"led\",\n\t.read = led_read,\n\t.write = led_write,\n\t.exit = led_exit,\n};\n\n \n\nTPACPI_HANDLE(beep, ec, \"BEEP\");\t \n\n#define TPACPI_BEEP_Q1 0x0001\n\nstatic const struct tpacpi_quirk beep_quirk_table[] __initconst = {\n\tTPACPI_Q_IBM('I', 'M', TPACPI_BEEP_Q1),  \n\tTPACPI_Q_IBM('I', 'U', TPACPI_BEEP_Q1),  \n};\n\nstatic int __init beep_init(struct ibm_init_struct *iibm)\n{\n\tunsigned long quirks;\n\n\tvdbg_printk(TPACPI_DBG_INIT, \"initializing beep subdriver\\n\");\n\n\tTPACPI_ACPIHANDLE_INIT(beep);\n\n\tvdbg_printk(TPACPI_DBG_INIT, \"beep is %s\\n\",\n\t\tstr_supported(beep_handle != NULL));\n\n\tquirks = tpacpi_check_quirks(beep_quirk_table,\n\t\t\t\t     ARRAY_SIZE(beep_quirk_table));\n\n\ttp_features.beep_needs_two_args = !!(quirks & TPACPI_BEEP_Q1);\n\n\treturn (beep_handle) ? 0 : -ENODEV;\n}\n\nstatic int beep_read(struct seq_file *m)\n{\n\tif (!beep_handle)\n\t\tseq_printf(m, \"status:\\t\\tnot supported\\n\");\n\telse {\n\t\tseq_printf(m, \"status:\\t\\tsupported\\n\");\n\t\tseq_printf(m, \"commands:\\t<cmd> (<cmd> is 0-17)\\n\");\n\t}\n\n\treturn 0;\n}\n\nstatic int beep_write(char *buf)\n{\n\tchar *cmd;\n\tint beep_cmd;\n\n\tif (!beep_handle)\n\t\treturn -ENODEV;\n\n\twhile ((cmd = strsep(&buf, \",\"))) {\n\t\tif (sscanf(cmd, \"%u\", &beep_cmd) == 1 &&\n\t\t    beep_cmd >= 0 && beep_cmd <= 17) {\n\t\t\t \n\t\t} else\n\t\t\treturn -EINVAL;\n\t\tif (tp_features.beep_needs_two_args) {\n\t\t\tif (!acpi_evalf(beep_handle, NULL, NULL, \"vdd\",\n\t\t\t\t\tbeep_cmd, 0))\n\t\t\t\treturn -EIO;\n\t\t} else {\n\t\t\tif (!acpi_evalf(beep_handle, NULL, NULL, \"vd\",\n\t\t\t\t\tbeep_cmd))\n\t\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic struct ibm_struct beep_driver_data = {\n\t.name = \"beep\",\n\t.read = beep_read,\n\t.write = beep_write,\n};\n\n \n\nenum thermal_access_mode {\n\tTPACPI_THERMAL_NONE = 0,\t \n\tTPACPI_THERMAL_ACPI_TMP07,\t \n\tTPACPI_THERMAL_ACPI_UPDT,\t \n\tTPACPI_THERMAL_TPEC_8,\t\t \n\tTPACPI_THERMAL_TPEC_16,\t\t \n};\n\nenum {  \n\tTP_EC_THERMAL_TMP0 = 0x78,\t \n\tTP_EC_THERMAL_TMP8 = 0xC0,\t \n\tTP_EC_FUNCREV      = 0xEF,       \n\tTP_EC_THERMAL_TMP_NA = -128,\t \n\n\tTPACPI_THERMAL_SENSOR_NA = -128000,  \n};\n\n\n#define TPACPI_MAX_THERMAL_SENSORS 16\t \nstruct ibm_thermal_sensors_struct {\n\ts32 temp[TPACPI_MAX_THERMAL_SENSORS];\n};\n\nstatic enum thermal_access_mode thermal_read_mode;\nstatic bool thermal_use_labels;\n\n \nstatic int thermal_get_sensor(int idx, s32 *value)\n{\n\tint t;\n\ts8 tmp;\n\tchar tmpi[5];\n\n\tt = TP_EC_THERMAL_TMP0;\n\n\tswitch (thermal_read_mode) {\n#if TPACPI_MAX_THERMAL_SENSORS >= 16\n\tcase TPACPI_THERMAL_TPEC_16:\n\t\tif (idx >= 8 && idx <= 15) {\n\t\t\tt = TP_EC_THERMAL_TMP8;\n\t\t\tidx -= 8;\n\t\t}\n#endif\n\t\tfallthrough;\n\tcase TPACPI_THERMAL_TPEC_8:\n\t\tif (idx <= 7) {\n\t\t\tif (!acpi_ec_read(t + idx, &tmp))\n\t\t\t\treturn -EIO;\n\t\t\t*value = tmp * 1000;\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\n\tcase TPACPI_THERMAL_ACPI_UPDT:\n\t\tif (idx <= 7) {\n\t\t\tsnprintf(tmpi, sizeof(tmpi), \"TMP%c\", '0' + idx);\n\t\t\tif (!acpi_evalf(ec_handle, NULL, \"UPDT\", \"v\"))\n\t\t\t\treturn -EIO;\n\t\t\tif (!acpi_evalf(ec_handle, &t, tmpi, \"d\"))\n\t\t\t\treturn -EIO;\n\t\t\t*value = (t - 2732) * 100;\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\n\tcase TPACPI_THERMAL_ACPI_TMP07:\n\t\tif (idx <= 7) {\n\t\t\tsnprintf(tmpi, sizeof(tmpi), \"TMP%c\", '0' + idx);\n\t\t\tif (!acpi_evalf(ec_handle, &t, tmpi, \"d\"))\n\t\t\t\treturn -EIO;\n\t\t\tif (t > 127 || t < -127)\n\t\t\t\tt = TP_EC_THERMAL_TMP_NA;\n\t\t\t*value = t * 1000;\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\n\tcase TPACPI_THERMAL_NONE:\n\tdefault:\n\t\treturn -ENOSYS;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int thermal_get_sensors(struct ibm_thermal_sensors_struct *s)\n{\n\tint res, i;\n\tint n;\n\n\tn = 8;\n\ti = 0;\n\n\tif (!s)\n\t\treturn -EINVAL;\n\n\tif (thermal_read_mode == TPACPI_THERMAL_TPEC_16)\n\t\tn = 16;\n\n\tfor (i = 0 ; i < n; i++) {\n\t\tres = thermal_get_sensor(i, &s->temp[i]);\n\t\tif (res)\n\t\t\treturn res;\n\t}\n\n\treturn n;\n}\n\nstatic void thermal_dump_all_sensors(void)\n{\n\tint n, i;\n\tstruct ibm_thermal_sensors_struct t;\n\n\tn = thermal_get_sensors(&t);\n\tif (n <= 0)\n\t\treturn;\n\n\tpr_notice(\"temperatures (Celsius):\");\n\n\tfor (i = 0; i < n; i++) {\n\t\tif (t.temp[i] != TPACPI_THERMAL_SENSOR_NA)\n\t\t\tpr_cont(\" %d\", (int)(t.temp[i] / 1000));\n\t\telse\n\t\t\tpr_cont(\" N/A\");\n\t}\n\n\tpr_cont(\"\\n\");\n}\n\n \n\nstatic ssize_t thermal_temp_input_show(struct device *dev,\n\t\t\t   struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\tstruct sensor_device_attribute *sensor_attr =\n\t\t\t\t\tto_sensor_dev_attr(attr);\n\tint idx = sensor_attr->index;\n\ts32 value;\n\tint res;\n\n\tres = thermal_get_sensor(idx, &value);\n\tif (res)\n\t\treturn res;\n\tif (value == TPACPI_THERMAL_SENSOR_NA)\n\t\treturn -ENXIO;\n\n\treturn sysfs_emit(buf, \"%d\\n\", value);\n}\n\n#define THERMAL_SENSOR_ATTR_TEMP(_idxA, _idxB) \\\n\t SENSOR_ATTR(temp##_idxA##_input, S_IRUGO, \\\n\t\t     thermal_temp_input_show, NULL, _idxB)\n\nstatic struct sensor_device_attribute sensor_dev_attr_thermal_temp_input[] = {\n\tTHERMAL_SENSOR_ATTR_TEMP(1, 0),\n\tTHERMAL_SENSOR_ATTR_TEMP(2, 1),\n\tTHERMAL_SENSOR_ATTR_TEMP(3, 2),\n\tTHERMAL_SENSOR_ATTR_TEMP(4, 3),\n\tTHERMAL_SENSOR_ATTR_TEMP(5, 4),\n\tTHERMAL_SENSOR_ATTR_TEMP(6, 5),\n\tTHERMAL_SENSOR_ATTR_TEMP(7, 6),\n\tTHERMAL_SENSOR_ATTR_TEMP(8, 7),\n\tTHERMAL_SENSOR_ATTR_TEMP(9, 8),\n\tTHERMAL_SENSOR_ATTR_TEMP(10, 9),\n\tTHERMAL_SENSOR_ATTR_TEMP(11, 10),\n\tTHERMAL_SENSOR_ATTR_TEMP(12, 11),\n\tTHERMAL_SENSOR_ATTR_TEMP(13, 12),\n\tTHERMAL_SENSOR_ATTR_TEMP(14, 13),\n\tTHERMAL_SENSOR_ATTR_TEMP(15, 14),\n\tTHERMAL_SENSOR_ATTR_TEMP(16, 15),\n};\n\n#define THERMAL_ATTRS(X) \\\n\t&sensor_dev_attr_thermal_temp_input[X].dev_attr.attr\n\nstatic struct attribute *thermal_temp_input_attr[] = {\n\tTHERMAL_ATTRS(0),\n\tTHERMAL_ATTRS(1),\n\tTHERMAL_ATTRS(2),\n\tTHERMAL_ATTRS(3),\n\tTHERMAL_ATTRS(4),\n\tTHERMAL_ATTRS(5),\n\tTHERMAL_ATTRS(6),\n\tTHERMAL_ATTRS(7),\n\tTHERMAL_ATTRS(8),\n\tTHERMAL_ATTRS(9),\n\tTHERMAL_ATTRS(10),\n\tTHERMAL_ATTRS(11),\n\tTHERMAL_ATTRS(12),\n\tTHERMAL_ATTRS(13),\n\tTHERMAL_ATTRS(14),\n\tTHERMAL_ATTRS(15),\n\tNULL\n};\n\nstatic umode_t thermal_attr_is_visible(struct kobject *kobj,\n\t\t\t\t       struct attribute *attr, int n)\n{\n\tif (thermal_read_mode == TPACPI_THERMAL_NONE)\n\t\treturn 0;\n\n\tif (attr == THERMAL_ATTRS(8) || attr == THERMAL_ATTRS(9) ||\n\t    attr == THERMAL_ATTRS(10) || attr == THERMAL_ATTRS(11) ||\n\t    attr == THERMAL_ATTRS(12) || attr == THERMAL_ATTRS(13) ||\n\t    attr == THERMAL_ATTRS(14) || attr == THERMAL_ATTRS(15)) {\n\t\tif (thermal_read_mode != TPACPI_THERMAL_TPEC_16)\n\t\t\treturn 0;\n\t}\n\n\treturn attr->mode;\n}\n\nstatic const struct attribute_group thermal_attr_group = {\n\t.is_visible = thermal_attr_is_visible,\n\t.attrs = thermal_temp_input_attr,\n};\n\n#undef THERMAL_SENSOR_ATTR_TEMP\n#undef THERMAL_ATTRS\n\nstatic ssize_t temp1_label_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\treturn sysfs_emit(buf, \"CPU\\n\");\n}\nstatic DEVICE_ATTR_RO(temp1_label);\n\nstatic ssize_t temp2_label_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\treturn sysfs_emit(buf, \"GPU\\n\");\n}\nstatic DEVICE_ATTR_RO(temp2_label);\n\nstatic struct attribute *temp_label_attributes[] = {\n\t&dev_attr_temp1_label.attr,\n\t&dev_attr_temp2_label.attr,\n\tNULL\n};\n\nstatic umode_t temp_label_attr_is_visible(struct kobject *kobj,\n\t\t\t\t\t  struct attribute *attr, int n)\n{\n\treturn thermal_use_labels ? attr->mode : 0;\n}\n\nstatic const struct attribute_group temp_label_attr_group = {\n\t.is_visible = temp_label_attr_is_visible,\n\t.attrs = temp_label_attributes,\n};\n\n \n\nstatic int __init thermal_init(struct ibm_init_struct *iibm)\n{\n\tu8 t, ta1, ta2, ver = 0;\n\tint i;\n\tint acpi_tmp7;\n\n\tvdbg_printk(TPACPI_DBG_INIT, \"initializing thermal subdriver\\n\");\n\n\tacpi_tmp7 = acpi_evalf(ec_handle, NULL, \"TMP7\", \"qv\");\n\n\tif (thinkpad_id.ec_model) {\n\t\t \n\t\tif (!acpi_ec_read(TP_EC_FUNCREV, &ver))\n\t\t\tpr_warn(\"Thinkpad ACPI EC unable to access EC version\\n\");\n\n\t\tta1 = ta2 = 0;\n\t\tfor (i = 0; i < 8; i++) {\n\t\t\tif (acpi_ec_read(TP_EC_THERMAL_TMP0 + i, &t)) {\n\t\t\t\tta1 |= t;\n\t\t\t} else {\n\t\t\t\tta1 = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (ver < 3) {\n\t\t\t\tif (acpi_ec_read(TP_EC_THERMAL_TMP8 + i, &t)) {\n\t\t\t\t\tta2 |= t;\n\t\t\t\t} else {\n\t\t\t\t\tta1 = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ta1 == 0) {\n\t\t\t \n\t\t\tif (acpi_tmp7) {\n\t\t\t\tpr_err(\"ThinkPad ACPI EC access misbehaving, falling back to ACPI TMPx access mode\\n\");\n\t\t\t\tthermal_read_mode = TPACPI_THERMAL_ACPI_TMP07;\n\t\t\t} else {\n\t\t\t\tpr_err(\"ThinkPad ACPI EC access misbehaving, disabling thermal sensors access\\n\");\n\t\t\t\tthermal_read_mode = TPACPI_THERMAL_NONE;\n\t\t\t}\n\t\t} else {\n\t\t\tif (ver >= 3) {\n\t\t\t\tthermal_read_mode = TPACPI_THERMAL_TPEC_8;\n\t\t\t\tthermal_use_labels = true;\n\t\t\t} else {\n\t\t\t\tthermal_read_mode =\n\t\t\t\t\t(ta2 != 0) ?\n\t\t\t\t\tTPACPI_THERMAL_TPEC_16 : TPACPI_THERMAL_TPEC_8;\n\t\t\t}\n\t\t}\n\t} else if (acpi_tmp7) {\n\t\tif (tpacpi_is_ibm() &&\n\t\t    acpi_evalf(ec_handle, NULL, \"UPDT\", \"qv\")) {\n\t\t\t \n\t\t\tthermal_read_mode = TPACPI_THERMAL_ACPI_UPDT;\n\t\t} else {\n\t\t\t \n\t\t\tthermal_read_mode = TPACPI_THERMAL_ACPI_TMP07;\n\t\t}\n\t} else {\n\t\t \n\t\tthermal_read_mode = TPACPI_THERMAL_NONE;\n\t}\n\n\tvdbg_printk(TPACPI_DBG_INIT, \"thermal is %s, mode %d\\n\",\n\t\tstr_supported(thermal_read_mode != TPACPI_THERMAL_NONE),\n\t\tthermal_read_mode);\n\n\treturn thermal_read_mode != TPACPI_THERMAL_NONE ? 0 : -ENODEV;\n}\n\nstatic int thermal_read(struct seq_file *m)\n{\n\tint n, i;\n\tstruct ibm_thermal_sensors_struct t;\n\n\tn = thermal_get_sensors(&t);\n\tif (unlikely(n < 0))\n\t\treturn n;\n\n\tseq_printf(m, \"temperatures:\\t\");\n\n\tif (n > 0) {\n\t\tfor (i = 0; i < (n - 1); i++)\n\t\t\tseq_printf(m, \"%d \", t.temp[i] / 1000);\n\t\tseq_printf(m, \"%d\\n\", t.temp[i] / 1000);\n\t} else\n\t\tseq_printf(m, \"not supported\\n\");\n\n\treturn 0;\n}\n\nstatic struct ibm_struct thermal_driver_data = {\n\t.name = \"thermal\",\n\t.read = thermal_read,\n};\n\n \n\n#define TPACPI_BACKLIGHT_DEV_NAME \"thinkpad_screen\"\n\n \n\nenum {\n\tTP_EC_BACKLIGHT = 0x31,\n\n\t \n\tTP_EC_BACKLIGHT_LVLMSK = 0x1F,\n\tTP_EC_BACKLIGHT_CMDMSK = 0xE0,\n\tTP_EC_BACKLIGHT_MAPSW = 0x20,\n};\n\nenum tpacpi_brightness_access_mode {\n\tTPACPI_BRGHT_MODE_AUTO = 0,\t \n\tTPACPI_BRGHT_MODE_EC,\t\t \n\tTPACPI_BRGHT_MODE_UCMS_STEP,\t \n\tTPACPI_BRGHT_MODE_ECNVRAM,\t \n\tTPACPI_BRGHT_MODE_MAX\n};\n\nstatic struct backlight_device *ibm_backlight_device;\n\nstatic enum tpacpi_brightness_access_mode brightness_mode =\n\t\tTPACPI_BRGHT_MODE_MAX;\n\nstatic unsigned int brightness_enable = 2;  \n\nstatic struct mutex brightness_mutex;\n\n \nstatic unsigned int tpacpi_brightness_nvram_get(void)\n{\n\tu8 lnvram;\n\n\tlockdep_assert_held(&brightness_mutex);\n\n\tlnvram = (nvram_read_byte(TP_NVRAM_ADDR_BRIGHTNESS)\n\t\t  & TP_NVRAM_MASK_LEVEL_BRIGHTNESS)\n\t\t  >> TP_NVRAM_POS_LEVEL_BRIGHTNESS;\n\tlnvram &= bright_maxlvl;\n\n\treturn lnvram;\n}\n\nstatic void tpacpi_brightness_checkpoint_nvram(void)\n{\n\tu8 lec = 0;\n\tu8 b_nvram;\n\n\tif (brightness_mode != TPACPI_BRGHT_MODE_ECNVRAM)\n\t\treturn;\n\n\tvdbg_printk(TPACPI_DBG_BRGHT,\n\t\t\"trying to checkpoint backlight level to NVRAM...\\n\");\n\n\tif (mutex_lock_killable(&brightness_mutex) < 0)\n\t\treturn;\n\n\tif (unlikely(!acpi_ec_read(TP_EC_BACKLIGHT, &lec)))\n\t\tgoto unlock;\n\tlec &= TP_EC_BACKLIGHT_LVLMSK;\n\tb_nvram = nvram_read_byte(TP_NVRAM_ADDR_BRIGHTNESS);\n\n\tif (lec != ((b_nvram & TP_NVRAM_MASK_LEVEL_BRIGHTNESS)\n\t\t\t     >> TP_NVRAM_POS_LEVEL_BRIGHTNESS)) {\n\t\t \n\t\tb_nvram &= ~(TP_NVRAM_MASK_LEVEL_BRIGHTNESS <<\n\t\t\t\tTP_NVRAM_POS_LEVEL_BRIGHTNESS);\n\t\tb_nvram |= lec;\n\t\tnvram_write_byte(b_nvram, TP_NVRAM_ADDR_BRIGHTNESS);\n\t\tdbg_printk(TPACPI_DBG_BRGHT,\n\t\t\t   \"updated NVRAM backlight level to %u (0x%02x)\\n\",\n\t\t\t   (unsigned int) lec, (unsigned int) b_nvram);\n\t} else\n\t\tvdbg_printk(TPACPI_DBG_BRGHT,\n\t\t\t   \"NVRAM backlight level already is %u (0x%02x)\\n\",\n\t\t\t   (unsigned int) lec, (unsigned int) b_nvram);\n\nunlock:\n\tmutex_unlock(&brightness_mutex);\n}\n\n\nstatic int tpacpi_brightness_get_raw(int *status)\n{\n\tu8 lec = 0;\n\n\tlockdep_assert_held(&brightness_mutex);\n\n\tswitch (brightness_mode) {\n\tcase TPACPI_BRGHT_MODE_UCMS_STEP:\n\t\t*status = tpacpi_brightness_nvram_get();\n\t\treturn 0;\n\tcase TPACPI_BRGHT_MODE_EC:\n\tcase TPACPI_BRGHT_MODE_ECNVRAM:\n\t\tif (unlikely(!acpi_ec_read(TP_EC_BACKLIGHT, &lec)))\n\t\t\treturn -EIO;\n\t\t*status = lec;\n\t\treturn 0;\n\tdefault:\n\t\treturn -ENXIO;\n\t}\n}\n\n \nstatic int tpacpi_brightness_set_ec(unsigned int value)\n{\n\tu8 lec = 0;\n\n\tlockdep_assert_held(&brightness_mutex);\n\n\tif (unlikely(!acpi_ec_read(TP_EC_BACKLIGHT, &lec)))\n\t\treturn -EIO;\n\n\tif (unlikely(!acpi_ec_write(TP_EC_BACKLIGHT,\n\t\t\t\t(lec & TP_EC_BACKLIGHT_CMDMSK) |\n\t\t\t\t(value & TP_EC_BACKLIGHT_LVLMSK))))\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic int tpacpi_brightness_set_ucmsstep(unsigned int value)\n{\n\tint cmos_cmd, inc;\n\tunsigned int current_value, i;\n\n\tlockdep_assert_held(&brightness_mutex);\n\n\tcurrent_value = tpacpi_brightness_nvram_get();\n\n\tif (value == current_value)\n\t\treturn 0;\n\n\tcmos_cmd = (value > current_value) ?\n\t\t\tTP_CMOS_BRIGHTNESS_UP :\n\t\t\tTP_CMOS_BRIGHTNESS_DOWN;\n\tinc = (value > current_value) ? 1 : -1;\n\n\tfor (i = current_value; i != value; i += inc)\n\t\tif (issue_thinkpad_cmos_command(cmos_cmd))\n\t\t\treturn -EIO;\n\n\treturn 0;\n}\n\n \nstatic int brightness_set(unsigned int value)\n{\n\tint res;\n\n\tif (value > bright_maxlvl)\n\t\treturn -EINVAL;\n\n\tvdbg_printk(TPACPI_DBG_BRGHT,\n\t\t\t\"set backlight level to %d\\n\", value);\n\n\tres = mutex_lock_killable(&brightness_mutex);\n\tif (res < 0)\n\t\treturn res;\n\n\tswitch (brightness_mode) {\n\tcase TPACPI_BRGHT_MODE_EC:\n\tcase TPACPI_BRGHT_MODE_ECNVRAM:\n\t\tres = tpacpi_brightness_set_ec(value);\n\t\tbreak;\n\tcase TPACPI_BRGHT_MODE_UCMS_STEP:\n\t\tres = tpacpi_brightness_set_ucmsstep(value);\n\t\tbreak;\n\tdefault:\n\t\tres = -ENXIO;\n\t}\n\n\tmutex_unlock(&brightness_mutex);\n\treturn res;\n}\n\n \n\nstatic int brightness_update_status(struct backlight_device *bd)\n{\n\tint level = backlight_get_brightness(bd);\n\n\tdbg_printk(TPACPI_DBG_BRGHT,\n\t\t\t\"backlight: attempt to set level to %d\\n\",\n\t\t\tlevel);\n\n\t \n\treturn brightness_set(level);\n}\n\nstatic int brightness_get(struct backlight_device *bd)\n{\n\tint status, res;\n\n\tres = mutex_lock_killable(&brightness_mutex);\n\tif (res < 0)\n\t\treturn 0;\n\n\tres = tpacpi_brightness_get_raw(&status);\n\n\tmutex_unlock(&brightness_mutex);\n\n\tif (res < 0)\n\t\treturn 0;\n\n\treturn status & TP_EC_BACKLIGHT_LVLMSK;\n}\n\nstatic void tpacpi_brightness_notify_change(void)\n{\n\tbacklight_force_update(ibm_backlight_device,\n\t\t\t       BACKLIGHT_UPDATE_HOTKEY);\n}\n\nstatic const struct backlight_ops ibm_backlight_data = {\n\t.get_brightness = brightness_get,\n\t.update_status  = brightness_update_status,\n};\n\n \n\nstatic int __init tpacpi_evaluate_bcl(struct acpi_device *adev, void *not_used)\n{\n\tstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };\n\tunion acpi_object *obj;\n\tacpi_status status;\n\tint rc;\n\n\tstatus = acpi_evaluate_object(adev->handle, \"_BCL\", NULL, &buffer);\n\tif (ACPI_FAILURE(status))\n\t\treturn 0;\n\n\tobj = buffer.pointer;\n\tif (!obj || obj->type != ACPI_TYPE_PACKAGE) {\n\t\tacpi_handle_info(adev->handle,\n\t\t\t\t \"Unknown _BCL data, please report this to %s\\n\",\n\t\t\t\t TPACPI_MAIL);\n\t\trc = 0;\n\t} else {\n\t\trc = obj->package.count;\n\t}\n\tkfree(obj);\n\n\treturn rc;\n}\n\n \n\nstatic int __init tpacpi_query_bcl_levels(acpi_handle handle)\n{\n\tstruct acpi_device *device;\n\n\tdevice = acpi_fetch_acpi_dev(handle);\n\tif (!device)\n\t\treturn 0;\n\n\treturn acpi_dev_for_each_child(device, tpacpi_evaluate_bcl, NULL);\n}\n\n\n \nstatic unsigned int __init tpacpi_check_std_acpi_brightness_support(void)\n{\n\tacpi_handle video_device;\n\tint bcl_levels = 0;\n\n\ttpacpi_acpi_handle_locate(\"video\", NULL, &video_device);\n\tif (video_device)\n\t\tbcl_levels = tpacpi_query_bcl_levels(video_device);\n\n\ttp_features.bright_acpimode = (bcl_levels > 0);\n\n\treturn (bcl_levels > 2) ? (bcl_levels - 2) : 0;\n}\n\n \n#define TPACPI_BRGHT_Q_NOEC\t0x0001\t \n#define TPACPI_BRGHT_Q_EC\t0x0002   \n#define TPACPI_BRGHT_Q_ASK\t0x8000\t \n\nstatic const struct tpacpi_quirk brightness_quirk_table[] __initconst = {\n\t \n\tTPACPI_Q_IBM('1', 'Y', TPACPI_BRGHT_Q_EC),\t \n\n\t \n\tTPACPI_Q_IBM('1', 'R', TPACPI_BRGHT_Q_EC),\t \n\tTPACPI_Q_IBM('1', 'Q', TPACPI_BRGHT_Q_ASK|TPACPI_BRGHT_Q_EC),\n\tTPACPI_Q_IBM('7', '6', TPACPI_BRGHT_Q_EC),\t \n\tTPACPI_Q_IBM('7', '8', TPACPI_BRGHT_Q_ASK|TPACPI_BRGHT_Q_EC),\n\n\t \n\tTPACPI_Q_IBM('1', 'U', TPACPI_BRGHT_Q_NOEC),\t \n\tTPACPI_Q_IBM('1', 'V', TPACPI_BRGHT_Q_ASK|TPACPI_BRGHT_Q_EC),\n\tTPACPI_Q_IBM('1', 'W', TPACPI_BRGHT_Q_ASK|TPACPI_BRGHT_Q_EC),\n\n\t \n\tTPACPI_Q_IBM('7', '0', TPACPI_BRGHT_Q_NOEC),\t \n\tTPACPI_Q_IBM('7', '4', TPACPI_BRGHT_Q_NOEC),\t \n\tTPACPI_Q_IBM('7', '5', TPACPI_BRGHT_Q_NOEC),\t \n};\n\n \nstatic void __init tpacpi_detect_brightness_capabilities(void)\n{\n\tunsigned int b;\n\n\tvdbg_printk(TPACPI_DBG_INIT,\n\t\t    \"detecting firmware brightness interface capabilities\\n\");\n\n\t \n\n\t \n\tb = tpacpi_check_std_acpi_brightness_support();\n\tswitch (b) {\n\tcase 16:\n\t\tbright_maxlvl = 15;\n\t\tbreak;\n\tcase 8:\n\tcase 0:\n\t\tbright_maxlvl = 7;\n\t\tbreak;\n\tdefault:\n\t\ttp_features.bright_unkfw = 1;\n\t\tbright_maxlvl = b - 1;\n\t}\n\tpr_debug(\"detected %u brightness levels\\n\", bright_maxlvl + 1);\n}\n\nstatic int __init brightness_init(struct ibm_init_struct *iibm)\n{\n\tstruct backlight_properties props;\n\tint b;\n\tunsigned long quirks;\n\n\tvdbg_printk(TPACPI_DBG_INIT, \"initializing brightness subdriver\\n\");\n\n\tmutex_init(&brightness_mutex);\n\n\tquirks = tpacpi_check_quirks(brightness_quirk_table,\n\t\t\t\tARRAY_SIZE(brightness_quirk_table));\n\n\t \n\n\t \n\tif (tp_features.bright_unkfw)\n\t\treturn -ENODEV;\n\n\tif (!brightness_enable) {\n\t\tdbg_printk(TPACPI_DBG_INIT | TPACPI_DBG_BRGHT,\n\t\t\t   \"brightness support disabled by module parameter\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (acpi_video_get_backlight_type() != acpi_backlight_vendor) {\n\t\tif (brightness_enable > 1) {\n\t\t\tpr_info(\"Standard ACPI backlight interface available, not loading native one\\n\");\n\t\t\treturn -ENODEV;\n\t\t} else if (brightness_enable == 1) {\n\t\t\tpr_warn(\"Cannot enable backlight brightness support, ACPI is already handling it.  Refer to the acpi_backlight kernel parameter.\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t} else if (!tp_features.bright_acpimode) {\n\t\tpr_notice(\"ACPI backlight interface not available\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tpr_notice(\"ACPI native brightness control enabled\\n\");\n\n\t \n\tif (brightness_mode > TPACPI_BRGHT_MODE_MAX)\n\t\treturn -EINVAL;\n\n\t \n\tif (brightness_mode == TPACPI_BRGHT_MODE_AUTO ||\n\t    brightness_mode == TPACPI_BRGHT_MODE_MAX) {\n\t\tif (quirks & TPACPI_BRGHT_Q_EC)\n\t\t\tbrightness_mode = TPACPI_BRGHT_MODE_ECNVRAM;\n\t\telse\n\t\t\tbrightness_mode = TPACPI_BRGHT_MODE_UCMS_STEP;\n\n\t\tdbg_printk(TPACPI_DBG_BRGHT,\n\t\t\t   \"driver auto-selected brightness_mode=%d\\n\",\n\t\t\t   brightness_mode);\n\t}\n\n\t \n\tif (!tpacpi_is_ibm() &&\n\t    (brightness_mode == TPACPI_BRGHT_MODE_ECNVRAM ||\n\t     brightness_mode == TPACPI_BRGHT_MODE_EC))\n\t\treturn -EINVAL;\n\n\tif (tpacpi_brightness_get_raw(&b) < 0)\n\t\treturn -ENODEV;\n\n\tmemset(&props, 0, sizeof(struct backlight_properties));\n\tprops.type = BACKLIGHT_PLATFORM;\n\tprops.max_brightness = bright_maxlvl;\n\tprops.brightness = b & TP_EC_BACKLIGHT_LVLMSK;\n\tibm_backlight_device = backlight_device_register(TPACPI_BACKLIGHT_DEV_NAME,\n\t\t\t\t\t\t\t NULL, NULL,\n\t\t\t\t\t\t\t &ibm_backlight_data,\n\t\t\t\t\t\t\t &props);\n\tif (IS_ERR(ibm_backlight_device)) {\n\t\tint rc = PTR_ERR(ibm_backlight_device);\n\t\tibm_backlight_device = NULL;\n\t\tpr_err(\"Could not register backlight device\\n\");\n\t\treturn rc;\n\t}\n\tvdbg_printk(TPACPI_DBG_INIT | TPACPI_DBG_BRGHT,\n\t\t\t\"brightness is supported\\n\");\n\n\tif (quirks & TPACPI_BRGHT_Q_ASK) {\n\t\tpr_notice(\"brightness: will use unverified default: brightness_mode=%d\\n\",\n\t\t\t  brightness_mode);\n\t\tpr_notice(\"brightness: please report to %s whether it works well or not on your ThinkPad\\n\",\n\t\t\t  TPACPI_MAIL);\n\t}\n\n\t \n\tbacklight_update_status(ibm_backlight_device);\n\n\tvdbg_printk(TPACPI_DBG_INIT | TPACPI_DBG_BRGHT,\n\t\t    \"brightness: registering brightness hotkeys as change notification\\n\");\n\ttpacpi_hotkey_driver_mask_set(hotkey_driver_mask\n\t\t\t\t| TP_ACPI_HKEY_BRGHTUP_MASK\n\t\t\t\t| TP_ACPI_HKEY_BRGHTDWN_MASK);\n\treturn 0;\n}\n\nstatic void brightness_suspend(void)\n{\n\ttpacpi_brightness_checkpoint_nvram();\n}\n\nstatic void brightness_shutdown(void)\n{\n\ttpacpi_brightness_checkpoint_nvram();\n}\n\nstatic void brightness_exit(void)\n{\n\tif (ibm_backlight_device) {\n\t\tvdbg_printk(TPACPI_DBG_EXIT | TPACPI_DBG_BRGHT,\n\t\t\t    \"calling backlight_device_unregister()\\n\");\n\t\tbacklight_device_unregister(ibm_backlight_device);\n\t}\n\n\ttpacpi_brightness_checkpoint_nvram();\n}\n\nstatic int brightness_read(struct seq_file *m)\n{\n\tint level;\n\n\tlevel = brightness_get(NULL);\n\tif (level < 0) {\n\t\tseq_printf(m, \"level:\\t\\tunreadable\\n\");\n\t} else {\n\t\tseq_printf(m, \"level:\\t\\t%d\\n\", level);\n\t\tseq_printf(m, \"commands:\\tup, down\\n\");\n\t\tseq_printf(m, \"commands:\\tlevel <level> (<level> is 0-%d)\\n\",\n\t\t\t       bright_maxlvl);\n\t}\n\n\treturn 0;\n}\n\nstatic int brightness_write(char *buf)\n{\n\tint level;\n\tint rc;\n\tchar *cmd;\n\n\tlevel = brightness_get(NULL);\n\tif (level < 0)\n\t\treturn level;\n\n\twhile ((cmd = strsep(&buf, \",\"))) {\n\t\tif (strstarts(cmd, \"up\")) {\n\t\t\tif (level < bright_maxlvl)\n\t\t\t\tlevel++;\n\t\t} else if (strstarts(cmd, \"down\")) {\n\t\t\tif (level > 0)\n\t\t\t\tlevel--;\n\t\t} else if (sscanf(cmd, \"level %d\", &level) == 1 &&\n\t\t\t   level >= 0 && level <= bright_maxlvl) {\n\t\t\t \n\t\t} else\n\t\t\treturn -EINVAL;\n\t}\n\n\ttpacpi_disclose_usertask(\"procfs brightness\",\n\t\t\t\"set level to %d\\n\", level);\n\n\t \n\trc = brightness_set(level);\n\tif (!rc && ibm_backlight_device)\n\t\tbacklight_force_update(ibm_backlight_device,\n\t\t\t\t\tBACKLIGHT_UPDATE_SYSFS);\n\treturn (rc == -EINTR) ? -ERESTARTSYS : rc;\n}\n\nstatic struct ibm_struct brightness_driver_data = {\n\t.name = \"brightness\",\n\t.read = brightness_read,\n\t.write = brightness_write,\n\t.exit = brightness_exit,\n\t.suspend = brightness_suspend,\n\t.shutdown = brightness_shutdown,\n};\n\n \n\n \n\n#ifdef CONFIG_THINKPAD_ACPI_ALSA_SUPPORT\n\n#define TPACPI_ALSA_DRVNAME  \"ThinkPad EC\"\n#define TPACPI_ALSA_SHRTNAME \"ThinkPad Console Audio Control\"\n#define TPACPI_ALSA_MIXERNAME TPACPI_ALSA_SHRTNAME\n\n#if SNDRV_CARDS <= 32\n#define DEFAULT_ALSA_IDX\t\t~((1 << (SNDRV_CARDS - 3)) - 1)\n#else\n#define DEFAULT_ALSA_IDX\t\t~((1 << (32 - 3)) - 1)\n#endif\nstatic int alsa_index = DEFAULT_ALSA_IDX;  \nstatic char *alsa_id = \"ThinkPadEC\";\nstatic bool alsa_enable = SNDRV_DEFAULT_ENABLE1;\n\nstruct tpacpi_alsa_data {\n\tstruct snd_card *card;\n\tstruct snd_ctl_elem_id *ctl_mute_id;\n\tstruct snd_ctl_elem_id *ctl_vol_id;\n};\n\nstatic struct snd_card *alsa_card;\n\nenum {\n\tTP_EC_AUDIO = 0x30,\n\n\t \n\tTP_EC_AUDIO_MUTESW = 6,\n\n\t \n\tTP_EC_AUDIO_LVL_MSK = 0x0F,\n\tTP_EC_AUDIO_MUTESW_MSK = (1 << TP_EC_AUDIO_MUTESW),\n\n\t \n\tTP_EC_VOLUME_MAX = 14,\n};\n\nenum tpacpi_volume_access_mode {\n\tTPACPI_VOL_MODE_AUTO = 0,\t \n\tTPACPI_VOL_MODE_EC,\t\t \n\tTPACPI_VOL_MODE_UCMS_STEP,\t \n\tTPACPI_VOL_MODE_ECNVRAM,\t \n\tTPACPI_VOL_MODE_MAX\n};\n\nenum tpacpi_volume_capabilities {\n\tTPACPI_VOL_CAP_AUTO = 0,\t \n\tTPACPI_VOL_CAP_VOLMUTE,\t\t \n\tTPACPI_VOL_CAP_MUTEONLY,\t \n\tTPACPI_VOL_CAP_MAX\n};\n\nenum tpacpi_mute_btn_mode {\n\tTP_EC_MUTE_BTN_LATCH  = 0,\t \n\t \n\tTP_EC_MUTE_BTN_NONE   = 2,\t \n\tTP_EC_MUTE_BTN_TOGGLE = 3,\t \n};\n\nstatic enum tpacpi_volume_access_mode volume_mode =\n\tTPACPI_VOL_MODE_MAX;\n\nstatic enum tpacpi_volume_capabilities volume_capabilities;\nstatic bool volume_control_allowed;\nstatic bool software_mute_requested = true;\nstatic bool software_mute_active;\nstatic int software_mute_orig_mode;\n\n \nstatic struct mutex volume_mutex;\n\nstatic void tpacpi_volume_checkpoint_nvram(void)\n{\n\tu8 lec = 0;\n\tu8 b_nvram;\n\tu8 ec_mask;\n\n\tif (volume_mode != TPACPI_VOL_MODE_ECNVRAM)\n\t\treturn;\n\tif (!volume_control_allowed)\n\t\treturn;\n\tif (software_mute_active)\n\t\treturn;\n\n\tvdbg_printk(TPACPI_DBG_MIXER,\n\t\t\"trying to checkpoint mixer state to NVRAM...\\n\");\n\n\tif (tp_features.mixer_no_level_control)\n\t\tec_mask = TP_EC_AUDIO_MUTESW_MSK;\n\telse\n\t\tec_mask = TP_EC_AUDIO_MUTESW_MSK | TP_EC_AUDIO_LVL_MSK;\n\n\tif (mutex_lock_killable(&volume_mutex) < 0)\n\t\treturn;\n\n\tif (unlikely(!acpi_ec_read(TP_EC_AUDIO, &lec)))\n\t\tgoto unlock;\n\tlec &= ec_mask;\n\tb_nvram = nvram_read_byte(TP_NVRAM_ADDR_MIXER);\n\n\tif (lec != (b_nvram & ec_mask)) {\n\t\t \n\t\tb_nvram &= ~ec_mask;\n\t\tb_nvram |= lec;\n\t\tnvram_write_byte(b_nvram, TP_NVRAM_ADDR_MIXER);\n\t\tdbg_printk(TPACPI_DBG_MIXER,\n\t\t\t   \"updated NVRAM mixer status to 0x%02x (0x%02x)\\n\",\n\t\t\t   (unsigned int) lec, (unsigned int) b_nvram);\n\t} else {\n\t\tvdbg_printk(TPACPI_DBG_MIXER,\n\t\t\t   \"NVRAM mixer status already is 0x%02x (0x%02x)\\n\",\n\t\t\t   (unsigned int) lec, (unsigned int) b_nvram);\n\t}\n\nunlock:\n\tmutex_unlock(&volume_mutex);\n}\n\nstatic int volume_get_status_ec(u8 *status)\n{\n\tu8 s;\n\n\tif (!acpi_ec_read(TP_EC_AUDIO, &s))\n\t\treturn -EIO;\n\n\t*status = s;\n\n\tdbg_printk(TPACPI_DBG_MIXER, \"status 0x%02x\\n\", s);\n\n\treturn 0;\n}\n\nstatic int volume_get_status(u8 *status)\n{\n\treturn volume_get_status_ec(status);\n}\n\nstatic int volume_set_status_ec(const u8 status)\n{\n\tif (!acpi_ec_write(TP_EC_AUDIO, status))\n\t\treturn -EIO;\n\n\tdbg_printk(TPACPI_DBG_MIXER, \"set EC mixer to 0x%02x\\n\", status);\n\n\t \n\tmsleep(1);\n\n\treturn 0;\n}\n\nstatic int volume_set_status(const u8 status)\n{\n\treturn volume_set_status_ec(status);\n}\n\n \nstatic int __volume_set_mute_ec(const bool mute)\n{\n\tint rc;\n\tu8 s, n;\n\n\tif (mutex_lock_killable(&volume_mutex) < 0)\n\t\treturn -EINTR;\n\n\trc = volume_get_status_ec(&s);\n\tif (rc)\n\t\tgoto unlock;\n\n\tn = (mute) ? s | TP_EC_AUDIO_MUTESW_MSK :\n\t\t     s & ~TP_EC_AUDIO_MUTESW_MSK;\n\n\tif (n != s) {\n\t\trc = volume_set_status_ec(n);\n\t\tif (!rc)\n\t\t\trc = 1;\n\t}\n\nunlock:\n\tmutex_unlock(&volume_mutex);\n\treturn rc;\n}\n\nstatic int volume_alsa_set_mute(const bool mute)\n{\n\tdbg_printk(TPACPI_DBG_MIXER, \"ALSA: trying to %smute\\n\",\n\t\t   (mute) ? \"\" : \"un\");\n\treturn __volume_set_mute_ec(mute);\n}\n\nstatic int volume_set_mute(const bool mute)\n{\n\tint rc;\n\n\tdbg_printk(TPACPI_DBG_MIXER, \"trying to %smute\\n\",\n\t\t   (mute) ? \"\" : \"un\");\n\n\trc = __volume_set_mute_ec(mute);\n\treturn (rc < 0) ? rc : 0;\n}\n\n \nstatic int __volume_set_volume_ec(const u8 vol)\n{\n\tint rc;\n\tu8 s, n;\n\n\tif (vol > TP_EC_VOLUME_MAX)\n\t\treturn -EINVAL;\n\n\tif (mutex_lock_killable(&volume_mutex) < 0)\n\t\treturn -EINTR;\n\n\trc = volume_get_status_ec(&s);\n\tif (rc)\n\t\tgoto unlock;\n\n\tn = (s & ~TP_EC_AUDIO_LVL_MSK) | vol;\n\n\tif (n != s) {\n\t\trc = volume_set_status_ec(n);\n\t\tif (!rc)\n\t\t\trc = 1;\n\t}\n\nunlock:\n\tmutex_unlock(&volume_mutex);\n\treturn rc;\n}\n\nstatic int volume_set_software_mute(bool startup)\n{\n\tint result;\n\n\tif (!tpacpi_is_lenovo())\n\t\treturn -ENODEV;\n\n\tif (startup) {\n\t\tif (!acpi_evalf(ec_handle, &software_mute_orig_mode,\n\t\t\t\t\"HAUM\", \"qd\"))\n\t\t\treturn -EIO;\n\n\t\tdbg_printk(TPACPI_DBG_INIT | TPACPI_DBG_MIXER,\n\t\t\t    \"Initial HAUM setting was %d\\n\",\n\t\t\t    software_mute_orig_mode);\n\t}\n\n\tif (!acpi_evalf(ec_handle, &result, \"SAUM\", \"qdd\",\n\t\t\t(int)TP_EC_MUTE_BTN_NONE))\n\t\treturn -EIO;\n\n\tif (result != TP_EC_MUTE_BTN_NONE)\n\t\tpr_warn(\"Unexpected SAUM result %d\\n\",\n\t\t\tresult);\n\n\t \n\tif (tp_features.mixer_no_level_control)\n\t\tresult = volume_set_mute(false);\n\telse\n\t\tresult = volume_set_status(TP_EC_VOLUME_MAX);\n\n\tif (result != 0)\n\t\tpr_warn(\"Failed to unmute the HW mute switch\\n\");\n\n\treturn 0;\n}\n\nstatic void volume_exit_software_mute(void)\n{\n\tint r;\n\n\tif (!acpi_evalf(ec_handle, &r, \"SAUM\", \"qdd\", software_mute_orig_mode)\n\t    || r != software_mute_orig_mode)\n\t\tpr_warn(\"Failed to restore mute mode\\n\");\n}\n\nstatic int volume_alsa_set_volume(const u8 vol)\n{\n\tdbg_printk(TPACPI_DBG_MIXER,\n\t\t   \"ALSA: trying to set volume level to %hu\\n\", vol);\n\treturn __volume_set_volume_ec(vol);\n}\n\nstatic void volume_alsa_notify_change(void)\n{\n\tstruct tpacpi_alsa_data *d;\n\n\tif (alsa_card && alsa_card->private_data) {\n\t\td = alsa_card->private_data;\n\t\tif (d->ctl_mute_id)\n\t\t\tsnd_ctl_notify(alsa_card,\n\t\t\t\t\tSNDRV_CTL_EVENT_MASK_VALUE,\n\t\t\t\t\td->ctl_mute_id);\n\t\tif (d->ctl_vol_id)\n\t\t\tsnd_ctl_notify(alsa_card,\n\t\t\t\t\tSNDRV_CTL_EVENT_MASK_VALUE,\n\t\t\t\t\td->ctl_vol_id);\n\t}\n}\n\nstatic int volume_alsa_vol_info(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = TP_EC_VOLUME_MAX;\n\treturn 0;\n}\n\nstatic int volume_alsa_vol_get(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tu8 s;\n\tint rc;\n\n\trc = volume_get_status(&s);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tucontrol->value.integer.value[0] = s & TP_EC_AUDIO_LVL_MSK;\n\treturn 0;\n}\n\nstatic int volume_alsa_vol_put(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\ttpacpi_disclose_usertask(\"ALSA\", \"set volume to %ld\\n\",\n\t\t\t\t ucontrol->value.integer.value[0]);\n\treturn volume_alsa_set_volume(ucontrol->value.integer.value[0]);\n}\n\n#define volume_alsa_mute_info snd_ctl_boolean_mono_info\n\nstatic int volume_alsa_mute_get(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tu8 s;\n\tint rc;\n\n\trc = volume_get_status(&s);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tucontrol->value.integer.value[0] =\n\t\t\t\t(s & TP_EC_AUDIO_MUTESW_MSK) ? 0 : 1;\n\treturn 0;\n}\n\nstatic int volume_alsa_mute_put(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\ttpacpi_disclose_usertask(\"ALSA\", \"%smute\\n\",\n\t\t\t\t ucontrol->value.integer.value[0] ?\n\t\t\t\t\t\"un\" : \"\");\n\treturn volume_alsa_set_mute(!ucontrol->value.integer.value[0]);\n}\n\nstatic struct snd_kcontrol_new volume_alsa_control_vol __initdata = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"Console Playback Volume\",\n\t.index = 0,\n\t.access = SNDRV_CTL_ELEM_ACCESS_READ,\n\t.info = volume_alsa_vol_info,\n\t.get = volume_alsa_vol_get,\n};\n\nstatic struct snd_kcontrol_new volume_alsa_control_mute __initdata = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"Console Playback Switch\",\n\t.index = 0,\n\t.access = SNDRV_CTL_ELEM_ACCESS_READ,\n\t.info = volume_alsa_mute_info,\n\t.get = volume_alsa_mute_get,\n};\n\nstatic void volume_suspend(void)\n{\n\ttpacpi_volume_checkpoint_nvram();\n}\n\nstatic void volume_resume(void)\n{\n\tif (software_mute_active) {\n\t\tif (volume_set_software_mute(false) < 0)\n\t\t\tpr_warn(\"Failed to restore software mute\\n\");\n\t} else {\n\t\tvolume_alsa_notify_change();\n\t}\n}\n\nstatic void volume_shutdown(void)\n{\n\ttpacpi_volume_checkpoint_nvram();\n}\n\nstatic void volume_exit(void)\n{\n\tif (alsa_card) {\n\t\tsnd_card_free(alsa_card);\n\t\talsa_card = NULL;\n\t}\n\n\ttpacpi_volume_checkpoint_nvram();\n\n\tif (software_mute_active)\n\t\tvolume_exit_software_mute();\n}\n\nstatic int __init volume_create_alsa_mixer(void)\n{\n\tstruct snd_card *card;\n\tstruct tpacpi_alsa_data *data;\n\tstruct snd_kcontrol *ctl_vol;\n\tstruct snd_kcontrol *ctl_mute;\n\tint rc;\n\n\trc = snd_card_new(&tpacpi_pdev->dev,\n\t\t\t  alsa_index, alsa_id, THIS_MODULE,\n\t\t\t  sizeof(struct tpacpi_alsa_data), &card);\n\tif (rc < 0 || !card) {\n\t\tpr_err(\"Failed to create ALSA card structures: %d\\n\", rc);\n\t\treturn -ENODEV;\n\t}\n\n\tBUG_ON(!card->private_data);\n\tdata = card->private_data;\n\tdata->card = card;\n\n\tstrscpy(card->driver, TPACPI_ALSA_DRVNAME,\n\t\tsizeof(card->driver));\n\tstrscpy(card->shortname, TPACPI_ALSA_SHRTNAME,\n\t\tsizeof(card->shortname));\n\tsnprintf(card->mixername, sizeof(card->mixername), \"ThinkPad EC %s\",\n\t\t (thinkpad_id.ec_version_str) ?\n\t\t\tthinkpad_id.ec_version_str : \"(unknown)\");\n\tsnprintf(card->longname, sizeof(card->longname),\n\t\t \"%s at EC reg 0x%02x, fw %s\", card->shortname, TP_EC_AUDIO,\n\t\t (thinkpad_id.ec_version_str) ?\n\t\t\tthinkpad_id.ec_version_str : \"unknown\");\n\n\tif (volume_control_allowed) {\n\t\tvolume_alsa_control_vol.put = volume_alsa_vol_put;\n\t\tvolume_alsa_control_vol.access =\n\t\t\t\tSNDRV_CTL_ELEM_ACCESS_READWRITE;\n\n\t\tvolume_alsa_control_mute.put = volume_alsa_mute_put;\n\t\tvolume_alsa_control_mute.access =\n\t\t\t\tSNDRV_CTL_ELEM_ACCESS_READWRITE;\n\t}\n\n\tif (!tp_features.mixer_no_level_control) {\n\t\tctl_vol = snd_ctl_new1(&volume_alsa_control_vol, NULL);\n\t\trc = snd_ctl_add(card, ctl_vol);\n\t\tif (rc < 0) {\n\t\t\tpr_err(\"Failed to create ALSA volume control: %d\\n\",\n\t\t\t       rc);\n\t\t\tgoto err_exit;\n\t\t}\n\t\tdata->ctl_vol_id = &ctl_vol->id;\n\t}\n\n\tctl_mute = snd_ctl_new1(&volume_alsa_control_mute, NULL);\n\trc = snd_ctl_add(card, ctl_mute);\n\tif (rc < 0) {\n\t\tpr_err(\"Failed to create ALSA mute control: %d\\n\", rc);\n\t\tgoto err_exit;\n\t}\n\tdata->ctl_mute_id = &ctl_mute->id;\n\n\trc = snd_card_register(card);\n\tif (rc < 0) {\n\t\tpr_err(\"Failed to register ALSA card: %d\\n\", rc);\n\t\tgoto err_exit;\n\t}\n\n\talsa_card = card;\n\treturn 0;\n\nerr_exit:\n\tsnd_card_free(card);\n\treturn -ENODEV;\n}\n\n#define TPACPI_VOL_Q_MUTEONLY\t0x0001\t \n#define TPACPI_VOL_Q_LEVEL\t0x0002   \n\nstatic const struct tpacpi_quirk volume_quirk_table[] __initconst = {\n\t \n\t{ .vendor = PCI_VENDOR_ID_IBM,\n\t  .bios   = TPACPI_MATCH_ANY,\n\t  .ec     = TPACPI_MATCH_ANY,\n\t  .quirks = TPACPI_VOL_Q_LEVEL },\n\n\t \n\tTPACPI_QEC_LNV('7', 'C', TPACPI_VOL_Q_LEVEL),  \n\tTPACPI_QEC_LNV('7', 'E', TPACPI_VOL_Q_LEVEL),  \n\tTPACPI_QEC_LNV('7', '9', TPACPI_VOL_Q_LEVEL),  \n\tTPACPI_QEC_LNV('7', 'B', TPACPI_VOL_Q_LEVEL),  \n\tTPACPI_QEC_LNV('7', 'J', TPACPI_VOL_Q_LEVEL),  \n\tTPACPI_QEC_LNV('7', '7', TPACPI_VOL_Q_LEVEL),  \n\tTPACPI_QEC_LNV('7', 'F', TPACPI_VOL_Q_LEVEL),  \n\n\t \n\t{ .vendor = PCI_VENDOR_ID_LENOVO,\n\t  .bios   = TPACPI_MATCH_ANY,\n\t  .ec\t  = TPACPI_MATCH_ANY,\n\t  .quirks = TPACPI_VOL_Q_MUTEONLY }\n};\n\nstatic int __init volume_init(struct ibm_init_struct *iibm)\n{\n\tunsigned long quirks;\n\tint rc;\n\n\tvdbg_printk(TPACPI_DBG_INIT, \"initializing volume subdriver\\n\");\n\n\tmutex_init(&volume_mutex);\n\n\t \n\tif (volume_mode > TPACPI_VOL_MODE_MAX)\n\t\treturn -EINVAL;\n\n\tif (volume_mode == TPACPI_VOL_MODE_UCMS_STEP) {\n\t\tpr_err(\"UCMS step volume mode not implemented, please contact %s\\n\",\n\t\t       TPACPI_MAIL);\n\t\treturn -ENODEV;\n\t}\n\n\tif (volume_capabilities >= TPACPI_VOL_CAP_MAX)\n\t\treturn -EINVAL;\n\n\t \n\tif (!alsa_enable) {\n\t\tvdbg_printk(TPACPI_DBG_INIT | TPACPI_DBG_MIXER,\n\t\t\t    \"ALSA mixer disabled by parameter, not loading volume subdriver...\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tquirks = tpacpi_check_quirks(volume_quirk_table,\n\t\t\t\t     ARRAY_SIZE(volume_quirk_table));\n\n\tswitch (volume_capabilities) {\n\tcase TPACPI_VOL_CAP_AUTO:\n\t\tif (quirks & TPACPI_VOL_Q_MUTEONLY)\n\t\t\ttp_features.mixer_no_level_control = 1;\n\t\telse if (quirks & TPACPI_VOL_Q_LEVEL)\n\t\t\ttp_features.mixer_no_level_control = 0;\n\t\telse\n\t\t\treturn -ENODEV;  \n\t\tbreak;\n\tcase TPACPI_VOL_CAP_VOLMUTE:\n\t\ttp_features.mixer_no_level_control = 0;\n\t\tbreak;\n\tcase TPACPI_VOL_CAP_MUTEONLY:\n\t\ttp_features.mixer_no_level_control = 1;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENODEV;\n\t}\n\n\tif (volume_capabilities != TPACPI_VOL_CAP_AUTO)\n\t\tdbg_printk(TPACPI_DBG_INIT | TPACPI_DBG_MIXER,\n\t\t\t\t\"using user-supplied volume_capabilities=%d\\n\",\n\t\t\t\tvolume_capabilities);\n\n\tif (volume_mode == TPACPI_VOL_MODE_AUTO ||\n\t    volume_mode == TPACPI_VOL_MODE_MAX) {\n\t\tvolume_mode = TPACPI_VOL_MODE_ECNVRAM;\n\n\t\tdbg_printk(TPACPI_DBG_INIT | TPACPI_DBG_MIXER,\n\t\t\t\t\"driver auto-selected volume_mode=%d\\n\",\n\t\t\t\tvolume_mode);\n\t} else {\n\t\tdbg_printk(TPACPI_DBG_INIT | TPACPI_DBG_MIXER,\n\t\t\t\t\"using user-supplied volume_mode=%d\\n\",\n\t\t\t\tvolume_mode);\n\t}\n\n\tvdbg_printk(TPACPI_DBG_INIT | TPACPI_DBG_MIXER,\n\t\t\t\"mute is supported, volume control is %s\\n\",\n\t\t\tstr_supported(!tp_features.mixer_no_level_control));\n\n\tif (software_mute_requested && volume_set_software_mute(true) == 0) {\n\t\tsoftware_mute_active = true;\n\t} else {\n\t\trc = volume_create_alsa_mixer();\n\t\tif (rc) {\n\t\t\tpr_err(\"Could not create the ALSA mixer interface\\n\");\n\t\t\treturn rc;\n\t\t}\n\n\t\tpr_info(\"Console audio control enabled, mode: %s\\n\",\n\t\t\t(volume_control_allowed) ?\n\t\t\t\t\"override (read/write)\" :\n\t\t\t\t\"monitor (read only)\");\n\t}\n\n\tvdbg_printk(TPACPI_DBG_INIT | TPACPI_DBG_MIXER,\n\t\t\"registering volume hotkeys as change notification\\n\");\n\ttpacpi_hotkey_driver_mask_set(hotkey_driver_mask\n\t\t\t| TP_ACPI_HKEY_VOLUP_MASK\n\t\t\t| TP_ACPI_HKEY_VOLDWN_MASK\n\t\t\t| TP_ACPI_HKEY_MUTE_MASK);\n\n\treturn 0;\n}\n\nstatic int volume_read(struct seq_file *m)\n{\n\tu8 status;\n\n\tif (volume_get_status(&status) < 0) {\n\t\tseq_printf(m, \"level:\\t\\tunreadable\\n\");\n\t} else {\n\t\tif (tp_features.mixer_no_level_control)\n\t\t\tseq_printf(m, \"level:\\t\\tunsupported\\n\");\n\t\telse\n\t\t\tseq_printf(m, \"level:\\t\\t%d\\n\",\n\t\t\t\t\tstatus & TP_EC_AUDIO_LVL_MSK);\n\n\t\tseq_printf(m, \"mute:\\t\\t%s\\n\", str_on_off(status & BIT(TP_EC_AUDIO_MUTESW)));\n\n\t\tif (volume_control_allowed) {\n\t\t\tseq_printf(m, \"commands:\\tunmute, mute\\n\");\n\t\t\tif (!tp_features.mixer_no_level_control) {\n\t\t\t\tseq_printf(m, \"commands:\\tup, down\\n\");\n\t\t\t\tseq_printf(m, \"commands:\\tlevel <level> (<level> is 0-%d)\\n\",\n\t\t\t\t\t      TP_EC_VOLUME_MAX);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int volume_write(char *buf)\n{\n\tu8 s;\n\tu8 new_level, new_mute;\n\tint l;\n\tchar *cmd;\n\tint rc;\n\n\t \n\tif (!volume_control_allowed && tpacpi_lifecycle != TPACPI_LIFE_INIT) {\n\t\tif (unlikely(!tp_warned.volume_ctrl_forbidden)) {\n\t\t\ttp_warned.volume_ctrl_forbidden = 1;\n\t\t\tpr_notice(\"Console audio control in monitor mode, changes are not allowed\\n\");\n\t\t\tpr_notice(\"Use the volume_control=1 module parameter to enable volume control\\n\");\n\t\t}\n\t\treturn -EPERM;\n\t}\n\n\trc = volume_get_status(&s);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tnew_level = s & TP_EC_AUDIO_LVL_MSK;\n\tnew_mute  = s & TP_EC_AUDIO_MUTESW_MSK;\n\n\twhile ((cmd = strsep(&buf, \",\"))) {\n\t\tif (!tp_features.mixer_no_level_control) {\n\t\t\tif (strstarts(cmd, \"up\")) {\n\t\t\t\tif (new_mute)\n\t\t\t\t\tnew_mute = 0;\n\t\t\t\telse if (new_level < TP_EC_VOLUME_MAX)\n\t\t\t\t\tnew_level++;\n\t\t\t\tcontinue;\n\t\t\t} else if (strstarts(cmd, \"down\")) {\n\t\t\t\tif (new_mute)\n\t\t\t\t\tnew_mute = 0;\n\t\t\t\telse if (new_level > 0)\n\t\t\t\t\tnew_level--;\n\t\t\t\tcontinue;\n\t\t\t} else if (sscanf(cmd, \"level %u\", &l) == 1 &&\n\t\t\t\t   l >= 0 && l <= TP_EC_VOLUME_MAX) {\n\t\t\t\tnew_level = l;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (strstarts(cmd, \"mute\"))\n\t\t\tnew_mute = TP_EC_AUDIO_MUTESW_MSK;\n\t\telse if (strstarts(cmd, \"unmute\"))\n\t\t\tnew_mute = 0;\n\t\telse\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (tp_features.mixer_no_level_control) {\n\t\ttpacpi_disclose_usertask(\"procfs volume\", \"%smute\\n\",\n\t\t\t\t\tnew_mute ? \"\" : \"un\");\n\t\trc = volume_set_mute(!!new_mute);\n\t} else {\n\t\ttpacpi_disclose_usertask(\"procfs volume\",\n\t\t\t\t\t\"%smute and set level to %d\\n\",\n\t\t\t\t\tnew_mute ? \"\" : \"un\", new_level);\n\t\trc = volume_set_status(new_mute | new_level);\n\t}\n\tvolume_alsa_notify_change();\n\n\treturn (rc == -EINTR) ? -ERESTARTSYS : rc;\n}\n\nstatic struct ibm_struct volume_driver_data = {\n\t.name = \"volume\",\n\t.read = volume_read,\n\t.write = volume_write,\n\t.exit = volume_exit,\n\t.suspend = volume_suspend,\n\t.resume = volume_resume,\n\t.shutdown = volume_shutdown,\n};\n\n#else  \n\n#define alsa_card NULL\n\nstatic inline void volume_alsa_notify_change(void)\n{\n}\n\nstatic int __init volume_init(struct ibm_init_struct *iibm)\n{\n\tpr_info(\"volume: disabled as there is no ALSA support in this kernel\\n\");\n\n\treturn -ENODEV;\n}\n\nstatic struct ibm_struct volume_driver_data = {\n\t.name = \"volume\",\n};\n\n#endif  \n\n \n\n \n\n#define FAN_RPM_CAL_CONST 491520\t \n\n#define FAN_NS_CTRL_STATUS\tBIT(2)\t\t \n#define FAN_NS_CTRL\t\tBIT(4)\t\t \n\nenum {\t\t\t\t\t \n\tfan_status_offset = 0x2f,\t \n\tfan_rpm_offset = 0x84,\t\t \n\tfan_select_offset = 0x31,\t \n\n\tfan_status_offset_ns = 0x93,\t \n\tfan2_status_offset_ns = 0x96,\t \n\tfan_rpm_status_ns = 0x95,\t \n\tfan2_rpm_status_ns = 0x98,\t \n\n\tTP_EC_FAN_FULLSPEED = 0x40,\t \n\tTP_EC_FAN_AUTO\t    = 0x80,\t \n\n\tTPACPI_FAN_LAST_LEVEL = 0x100,\t \n};\n\nenum fan_status_access_mode {\n\tTPACPI_FAN_NONE = 0,\t\t \n\tTPACPI_FAN_RD_ACPI_GFAN,\t \n\tTPACPI_FAN_RD_TPEC,\t\t \n\tTPACPI_FAN_RD_TPEC_NS,\t\t \n};\n\nenum fan_control_access_mode {\n\tTPACPI_FAN_WR_NONE = 0,\t\t \n\tTPACPI_FAN_WR_ACPI_SFAN,\t \n\tTPACPI_FAN_WR_TPEC,\t\t \n\tTPACPI_FAN_WR_ACPI_FANS,\t \n};\n\nenum fan_control_commands {\n\tTPACPI_FAN_CMD_SPEED \t= 0x0001,\t \n\tTPACPI_FAN_CMD_LEVEL \t= 0x0002,\t \n\tTPACPI_FAN_CMD_ENABLE\t= 0x0004,\t \n};\n\nstatic bool fan_control_allowed;\n\nstatic enum fan_status_access_mode fan_status_access_mode;\nstatic enum fan_control_access_mode fan_control_access_mode;\nstatic enum fan_control_commands fan_control_commands;\n\nstatic u8 fan_control_initial_status;\nstatic u8 fan_control_desired_level;\nstatic u8 fan_control_resume_level;\nstatic int fan_watchdog_maxinterval;\n\nstatic bool fan_with_ns_addr;\n\nstatic struct mutex fan_mutex;\n\nstatic void fan_watchdog_fire(struct work_struct *ignored);\nstatic DECLARE_DELAYED_WORK(fan_watchdog_task, fan_watchdog_fire);\n\nTPACPI_HANDLE(fans, ec, \"FANS\");\t \nTPACPI_HANDLE(gfan, ec, \"GFAN\",\t \n\t   \"\\\\FSPD\",\t\t \n\t   );\t\t\t \nTPACPI_HANDLE(sfan, ec, \"SFAN\",\t \n\t   \"JFNS\",\t\t \n\t   );\t\t\t \n\n \n\nstatic void fan_quirk1_setup(void)\n{\n\tif (fan_control_initial_status == 0x07) {\n\t\tpr_notice(\"fan_init: initial fan status is unknown, assuming it is in auto mode\\n\");\n\t\ttp_features.fan_ctrl_status_undef = 1;\n\t}\n}\n\nstatic void fan_quirk1_handle(u8 *fan_status)\n{\n\tif (unlikely(tp_features.fan_ctrl_status_undef)) {\n\t\tif (*fan_status != fan_control_initial_status) {\n\t\t\t \n\t\t\ttp_features.fan_ctrl_status_undef = 0;\n\t\t} else {\n\t\t\t \n\t\t\t*fan_status = TP_EC_FAN_AUTO;\n\t\t}\n\t}\n}\n\n \nstatic bool fan_select_fan1(void)\n{\n\tif (tp_features.second_fan) {\n\t\tu8 val;\n\n\t\tif (ec_read(fan_select_offset, &val) < 0)\n\t\t\treturn false;\n\t\tval &= 0xFEU;\n\t\tif (ec_write(fan_select_offset, val) < 0)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\n \nstatic bool fan_select_fan2(void)\n{\n\tu8 val;\n\n\tif (!tp_features.second_fan)\n\t\treturn false;\n\n\tif (ec_read(fan_select_offset, &val) < 0)\n\t\treturn false;\n\tval |= 0x01U;\n\tif (ec_write(fan_select_offset, val) < 0)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic void fan_update_desired_level(u8 status)\n{\n\tlockdep_assert_held(&fan_mutex);\n\n\tif ((status &\n\t     (TP_EC_FAN_AUTO | TP_EC_FAN_FULLSPEED)) == 0) {\n\t\tif (status > 7)\n\t\t\tfan_control_desired_level = 7;\n\t\telse\n\t\t\tfan_control_desired_level = status;\n\t}\n}\n\nstatic int fan_get_status(u8 *status)\n{\n\tu8 s;\n\n\t \n\n\tswitch (fan_status_access_mode) {\n\tcase TPACPI_FAN_RD_ACPI_GFAN: {\n\t\t \n\t\tint res;\n\n\t\tif (unlikely(!acpi_evalf(gfan_handle, &res, NULL, \"d\")))\n\t\t\treturn -EIO;\n\n\t\tif (likely(status))\n\t\t\t*status = res & 0x07;\n\n\t\tbreak;\n\t}\n\tcase TPACPI_FAN_RD_TPEC:\n\t\t \n\t\tif (unlikely(!acpi_ec_read(fan_status_offset, &s)))\n\t\t\treturn -EIO;\n\n\t\tif (likely(status)) {\n\t\t\t*status = s;\n\t\t\tfan_quirk1_handle(status);\n\t\t}\n\n\t\tbreak;\n\tcase TPACPI_FAN_RD_TPEC_NS:\n\t\t \n\t\tif (!acpi_ec_read(fan_status_offset_ns, &s))\n\t\t\treturn -EIO;\n\n\t\tif (status)\n\t\t\t*status = s;\n\n\t\tbreak;\n\n\tdefault:\n\t\treturn -ENXIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int fan_get_status_safe(u8 *status)\n{\n\tint rc;\n\tu8 s;\n\n\tif (mutex_lock_killable(&fan_mutex))\n\t\treturn -ERESTARTSYS;\n\trc = fan_get_status(&s);\n\t \n\tif (!rc && !fan_with_ns_addr)\n\t\tfan_update_desired_level(s);\n\tmutex_unlock(&fan_mutex);\n\n\tif (rc)\n\t\treturn rc;\n\tif (status)\n\t\t*status = s;\n\n\treturn 0;\n}\n\nstatic int fan_get_speed(unsigned int *speed)\n{\n\tu8 hi, lo;\n\n\tswitch (fan_status_access_mode) {\n\tcase TPACPI_FAN_RD_TPEC:\n\t\t \n\t\tif (unlikely(!fan_select_fan1()))\n\t\t\treturn -EIO;\n\t\tif (unlikely(!acpi_ec_read(fan_rpm_offset, &lo) ||\n\t\t\t     !acpi_ec_read(fan_rpm_offset + 1, &hi)))\n\t\t\treturn -EIO;\n\n\t\tif (likely(speed))\n\t\t\t*speed = (hi << 8) | lo;\n\t\tbreak;\n\tcase TPACPI_FAN_RD_TPEC_NS:\n\t\tif (!acpi_ec_read(fan_rpm_status_ns, &lo))\n\t\t\treturn -EIO;\n\n\t\tif (speed)\n\t\t\t*speed = lo ? FAN_RPM_CAL_CONST / lo : 0;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -ENXIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int fan2_get_speed(unsigned int *speed)\n{\n\tu8 hi, lo, status;\n\tbool rc;\n\n\tswitch (fan_status_access_mode) {\n\tcase TPACPI_FAN_RD_TPEC:\n\t\t \n\t\tif (unlikely(!fan_select_fan2()))\n\t\t\treturn -EIO;\n\t\trc = !acpi_ec_read(fan_rpm_offset, &lo) ||\n\t\t\t     !acpi_ec_read(fan_rpm_offset + 1, &hi);\n\t\tfan_select_fan1();  \n\t\tif (rc)\n\t\t\treturn -EIO;\n\n\t\tif (likely(speed))\n\t\t\t*speed = (hi << 8) | lo;\n\t\tbreak;\n\n\tcase TPACPI_FAN_RD_TPEC_NS:\n\t\trc = !acpi_ec_read(fan2_status_offset_ns, &status);\n\t\tif (rc)\n\t\t\treturn -EIO;\n\t\tif (!(status & FAN_NS_CTRL_STATUS)) {\n\t\t\tpr_info(\"secondary fan control not supported\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t\trc = !acpi_ec_read(fan2_rpm_status_ns, &lo);\n\t\tif (rc)\n\t\t\treturn -EIO;\n\t\tif (speed)\n\t\t\t*speed = lo ? FAN_RPM_CAL_CONST / lo : 0;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -ENXIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int fan_set_level(int level)\n{\n\tif (!fan_control_allowed)\n\t\treturn -EPERM;\n\n\tswitch (fan_control_access_mode) {\n\tcase TPACPI_FAN_WR_ACPI_SFAN:\n\t\tif ((level < 0) || (level > 7))\n\t\t\treturn -EINVAL;\n\n\t\tif (tp_features.second_fan_ctl) {\n\t\t\tif (!fan_select_fan2() ||\n\t\t\t    !acpi_evalf(sfan_handle, NULL, NULL, \"vd\", level)) {\n\t\t\t\tpr_warn(\"Couldn't set 2nd fan level, disabling support\\n\");\n\t\t\t\ttp_features.second_fan_ctl = 0;\n\t\t\t}\n\t\t\tfan_select_fan1();\n\t\t}\n\t\tif (!acpi_evalf(sfan_handle, NULL, NULL, \"vd\", level))\n\t\t\treturn -EIO;\n\t\tbreak;\n\n\tcase TPACPI_FAN_WR_ACPI_FANS:\n\tcase TPACPI_FAN_WR_TPEC:\n\t\tif (!(level & TP_EC_FAN_AUTO) &&\n\t\t    !(level & TP_EC_FAN_FULLSPEED) &&\n\t\t    ((level < 0) || (level > 7)))\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tif (level & TP_EC_FAN_FULLSPEED)\n\t\t\tlevel |= 7;\t \n\t\telse if (level & TP_EC_FAN_AUTO)\n\t\t\tlevel |= 4;\t \n\n\t\tif (tp_features.second_fan_ctl) {\n\t\t\tif (!fan_select_fan2() ||\n\t\t\t    !acpi_ec_write(fan_status_offset, level)) {\n\t\t\t\tpr_warn(\"Couldn't set 2nd fan level, disabling support\\n\");\n\t\t\t\ttp_features.second_fan_ctl = 0;\n\t\t\t}\n\t\t\tfan_select_fan1();\n\n\t\t}\n\t\tif (!acpi_ec_write(fan_status_offset, level))\n\t\t\treturn -EIO;\n\t\telse\n\t\t\ttp_features.fan_ctrl_status_undef = 0;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -ENXIO;\n\t}\n\n\tvdbg_printk(TPACPI_DBG_FAN,\n\t\t\"fan control: set fan control register to 0x%02x\\n\", level);\n\treturn 0;\n}\n\nstatic int fan_set_level_safe(int level)\n{\n\tint rc;\n\n\tif (!fan_control_allowed)\n\t\treturn -EPERM;\n\n\tif (mutex_lock_killable(&fan_mutex))\n\t\treturn -ERESTARTSYS;\n\n\tif (level == TPACPI_FAN_LAST_LEVEL)\n\t\tlevel = fan_control_desired_level;\n\n\trc = fan_set_level(level);\n\tif (!rc)\n\t\tfan_update_desired_level(level);\n\n\tmutex_unlock(&fan_mutex);\n\treturn rc;\n}\n\nstatic int fan_set_enable(void)\n{\n\tu8 s;\n\tint rc;\n\n\tif (!fan_control_allowed)\n\t\treturn -EPERM;\n\n\tif (mutex_lock_killable(&fan_mutex))\n\t\treturn -ERESTARTSYS;\n\n\tswitch (fan_control_access_mode) {\n\tcase TPACPI_FAN_WR_ACPI_FANS:\n\tcase TPACPI_FAN_WR_TPEC:\n\t\trc = fan_get_status(&s);\n\t\tif (rc)\n\t\t\tbreak;\n\n\t\t \n\t\tif (s != 7) {\n\t\t\ts &= 0x07;\n\t\t\ts |= TP_EC_FAN_AUTO | 4;  \n\t\t}\n\n\t\tif (!acpi_ec_write(fan_status_offset, s))\n\t\t\trc = -EIO;\n\t\telse {\n\t\t\ttp_features.fan_ctrl_status_undef = 0;\n\t\t\trc = 0;\n\t\t}\n\t\tbreak;\n\n\tcase TPACPI_FAN_WR_ACPI_SFAN:\n\t\trc = fan_get_status(&s);\n\t\tif (rc)\n\t\t\tbreak;\n\n\t\ts &= 0x07;\n\n\t\t \n\t\ts |= 4;\n\n\t\tif (!acpi_evalf(sfan_handle, NULL, NULL, \"vd\", s))\n\t\t\trc = -EIO;\n\t\telse\n\t\t\trc = 0;\n\t\tbreak;\n\n\tdefault:\n\t\trc = -ENXIO;\n\t}\n\n\tmutex_unlock(&fan_mutex);\n\n\tif (!rc)\n\t\tvdbg_printk(TPACPI_DBG_FAN,\n\t\t\t\"fan control: set fan control register to 0x%02x\\n\",\n\t\t\ts);\n\treturn rc;\n}\n\nstatic int fan_set_disable(void)\n{\n\tint rc;\n\n\tif (!fan_control_allowed)\n\t\treturn -EPERM;\n\n\tif (mutex_lock_killable(&fan_mutex))\n\t\treturn -ERESTARTSYS;\n\n\trc = 0;\n\tswitch (fan_control_access_mode) {\n\tcase TPACPI_FAN_WR_ACPI_FANS:\n\tcase TPACPI_FAN_WR_TPEC:\n\t\tif (!acpi_ec_write(fan_status_offset, 0x00))\n\t\t\trc = -EIO;\n\t\telse {\n\t\t\tfan_control_desired_level = 0;\n\t\t\ttp_features.fan_ctrl_status_undef = 0;\n\t\t}\n\t\tbreak;\n\n\tcase TPACPI_FAN_WR_ACPI_SFAN:\n\t\tif (!acpi_evalf(sfan_handle, NULL, NULL, \"vd\", 0x00))\n\t\t\trc = -EIO;\n\t\telse\n\t\t\tfan_control_desired_level = 0;\n\t\tbreak;\n\n\tdefault:\n\t\trc = -ENXIO;\n\t}\n\n\tif (!rc)\n\t\tvdbg_printk(TPACPI_DBG_FAN,\n\t\t\t\"fan control: set fan control register to 0\\n\");\n\n\tmutex_unlock(&fan_mutex);\n\treturn rc;\n}\n\nstatic int fan_set_speed(int speed)\n{\n\tint rc;\n\n\tif (!fan_control_allowed)\n\t\treturn -EPERM;\n\n\tif (mutex_lock_killable(&fan_mutex))\n\t\treturn -ERESTARTSYS;\n\n\trc = 0;\n\tswitch (fan_control_access_mode) {\n\tcase TPACPI_FAN_WR_ACPI_FANS:\n\t\tif (speed >= 0 && speed <= 65535) {\n\t\t\tif (!acpi_evalf(fans_handle, NULL, NULL, \"vddd\",\n\t\t\t\t\tspeed, speed, speed))\n\t\t\t\trc = -EIO;\n\t\t} else\n\t\t\trc = -EINVAL;\n\t\tbreak;\n\n\tdefault:\n\t\trc = -ENXIO;\n\t}\n\n\tmutex_unlock(&fan_mutex);\n\treturn rc;\n}\n\nstatic void fan_watchdog_reset(void)\n{\n\tif (fan_control_access_mode == TPACPI_FAN_WR_NONE)\n\t\treturn;\n\n\tif (fan_watchdog_maxinterval > 0 &&\n\t    tpacpi_lifecycle != TPACPI_LIFE_EXITING)\n\t\tmod_delayed_work(tpacpi_wq, &fan_watchdog_task,\n\t\t\tmsecs_to_jiffies(fan_watchdog_maxinterval * 1000));\n\telse\n\t\tcancel_delayed_work(&fan_watchdog_task);\n}\n\nstatic void fan_watchdog_fire(struct work_struct *ignored)\n{\n\tint rc;\n\n\tif (tpacpi_lifecycle != TPACPI_LIFE_RUNNING)\n\t\treturn;\n\n\tpr_notice(\"fan watchdog: enabling fan\\n\");\n\trc = fan_set_enable();\n\tif (rc < 0) {\n\t\tpr_err(\"fan watchdog: error %d while enabling fan, will try again later...\\n\",\n\t\t       rc);\n\t\t \n\t\tfan_watchdog_reset();\n\t}\n}\n\n \n\n \nstatic ssize_t fan_pwm1_enable_show(struct device *dev,\n\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t    char *buf)\n{\n\tint res, mode;\n\tu8 status;\n\n\tres = fan_get_status_safe(&status);\n\tif (res)\n\t\treturn res;\n\n\tif (status & TP_EC_FAN_FULLSPEED) {\n\t\tmode = 0;\n\t} else if (status & TP_EC_FAN_AUTO) {\n\t\tmode = 2;\n\t} else\n\t\tmode = 1;\n\n\treturn sysfs_emit(buf, \"%d\\n\", mode);\n}\n\nstatic ssize_t fan_pwm1_enable_store(struct device *dev,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     const char *buf, size_t count)\n{\n\tunsigned long t;\n\tint res, level;\n\n\tif (parse_strtoul(buf, 2, &t))\n\t\treturn -EINVAL;\n\n\ttpacpi_disclose_usertask(\"hwmon pwm1_enable\",\n\t\t\t\"set fan mode to %lu\\n\", t);\n\n\tswitch (t) {\n\tcase 0:\n\t\tlevel = TP_EC_FAN_FULLSPEED;\n\t\tbreak;\n\tcase 1:\n\t\tlevel = TPACPI_FAN_LAST_LEVEL;\n\t\tbreak;\n\tcase 2:\n\t\tlevel = TP_EC_FAN_AUTO;\n\t\tbreak;\n\tcase 3:\n\t\t \n\t\treturn -ENOSYS;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tres = fan_set_level_safe(level);\n\tif (res == -ENXIO)\n\t\treturn -EINVAL;\n\telse if (res < 0)\n\t\treturn res;\n\n\tfan_watchdog_reset();\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR(pwm1_enable, S_IWUSR | S_IRUGO,\n\t\t   fan_pwm1_enable_show, fan_pwm1_enable_store);\n\n \nstatic ssize_t fan_pwm1_show(struct device *dev,\n\t\t\t     struct device_attribute *attr,\n\t\t\t     char *buf)\n{\n\tint res;\n\tu8 status;\n\n\tres = fan_get_status_safe(&status);\n\tif (res)\n\t\treturn res;\n\n\tif ((status &\n\t     (TP_EC_FAN_AUTO | TP_EC_FAN_FULLSPEED)) != 0)\n\t\tstatus = fan_control_desired_level;\n\n\tif (status > 7)\n\t\tstatus = 7;\n\n\treturn sysfs_emit(buf, \"%u\\n\", (status * 255) / 7);\n}\n\nstatic ssize_t fan_pwm1_store(struct device *dev,\n\t\t\t      struct device_attribute *attr,\n\t\t\t      const char *buf, size_t count)\n{\n\tunsigned long s;\n\tint rc;\n\tu8 status, newlevel;\n\n\tif (parse_strtoul(buf, 255, &s))\n\t\treturn -EINVAL;\n\n\ttpacpi_disclose_usertask(\"hwmon pwm1\",\n\t\t\t\"set fan speed to %lu\\n\", s);\n\n\t \n\tnewlevel = (s >> 5) & 0x07;\n\n\tif (mutex_lock_killable(&fan_mutex))\n\t\treturn -ERESTARTSYS;\n\n\trc = fan_get_status(&status);\n\tif (!rc && (status &\n\t\t    (TP_EC_FAN_AUTO | TP_EC_FAN_FULLSPEED)) == 0) {\n\t\trc = fan_set_level(newlevel);\n\t\tif (rc == -ENXIO)\n\t\t\trc = -EINVAL;\n\t\telse if (!rc) {\n\t\t\tfan_update_desired_level(newlevel);\n\t\t\tfan_watchdog_reset();\n\t\t}\n\t}\n\n\tmutex_unlock(&fan_mutex);\n\treturn (rc) ? rc : count;\n}\n\nstatic DEVICE_ATTR(pwm1, S_IWUSR | S_IRUGO, fan_pwm1_show, fan_pwm1_store);\n\n \nstatic ssize_t fan_fan1_input_show(struct device *dev,\n\t\t\t   struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\tint res;\n\tunsigned int speed;\n\n\tres = fan_get_speed(&speed);\n\tif (res < 0)\n\t\treturn res;\n\n\treturn sysfs_emit(buf, \"%u\\n\", speed);\n}\n\nstatic DEVICE_ATTR(fan1_input, S_IRUGO, fan_fan1_input_show, NULL);\n\n \nstatic ssize_t fan_fan2_input_show(struct device *dev,\n\t\t\t   struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\tint res;\n\tunsigned int speed;\n\n\tres = fan2_get_speed(&speed);\n\tif (res < 0)\n\t\treturn res;\n\n\treturn sysfs_emit(buf, \"%u\\n\", speed);\n}\n\nstatic DEVICE_ATTR(fan2_input, S_IRUGO, fan_fan2_input_show, NULL);\n\n \nstatic ssize_t fan_watchdog_show(struct device_driver *drv, char *buf)\n{\n\treturn sysfs_emit(buf, \"%u\\n\", fan_watchdog_maxinterval);\n}\n\nstatic ssize_t fan_watchdog_store(struct device_driver *drv, const char *buf,\n\t\t\t\t  size_t count)\n{\n\tunsigned long t;\n\n\tif (parse_strtoul(buf, 120, &t))\n\t\treturn -EINVAL;\n\n\tif (!fan_control_allowed)\n\t\treturn -EPERM;\n\n\tfan_watchdog_maxinterval = t;\n\tfan_watchdog_reset();\n\n\ttpacpi_disclose_usertask(\"fan_watchdog\", \"set to %lu\\n\", t);\n\n\treturn count;\n}\nstatic DRIVER_ATTR_RW(fan_watchdog);\n\n \n\nstatic struct attribute *fan_attributes[] = {\n\t&dev_attr_pwm1_enable.attr,\n\t&dev_attr_pwm1.attr,\n\t&dev_attr_fan1_input.attr,\n\t&dev_attr_fan2_input.attr,\n\tNULL\n};\n\nstatic umode_t fan_attr_is_visible(struct kobject *kobj, struct attribute *attr,\n\t\t\t\t   int n)\n{\n\tif (fan_status_access_mode == TPACPI_FAN_NONE &&\n\t    fan_control_access_mode == TPACPI_FAN_WR_NONE)\n\t\treturn 0;\n\n\tif (attr == &dev_attr_fan2_input.attr) {\n\t\tif (!tp_features.second_fan)\n\t\t\treturn 0;\n\t}\n\n\treturn attr->mode;\n}\n\nstatic const struct attribute_group fan_attr_group = {\n\t.is_visible = fan_attr_is_visible,\n\t.attrs = fan_attributes,\n};\n\nstatic struct attribute *fan_driver_attributes[] = {\n\t&driver_attr_fan_watchdog.attr,\n\tNULL\n};\n\nstatic const struct attribute_group fan_driver_attr_group = {\n\t.is_visible = fan_attr_is_visible,\n\t.attrs = fan_driver_attributes,\n};\n\n#define TPACPI_FAN_Q1\t\t0x0001\t\t \n#define TPACPI_FAN_2FAN\t\t0x0002\t\t \n#define TPACPI_FAN_2CTL\t\t0x0004\t\t \n#define TPACPI_FAN_NOFAN\t0x0008\t\t \n#define TPACPI_FAN_NS\t\t0x0010\t\t \n\nstatic const struct tpacpi_quirk fan_quirk_table[] __initconst = {\n\tTPACPI_QEC_IBM('1', 'Y', TPACPI_FAN_Q1),\n\tTPACPI_QEC_IBM('7', '8', TPACPI_FAN_Q1),\n\tTPACPI_QEC_IBM('7', '6', TPACPI_FAN_Q1),\n\tTPACPI_QEC_IBM('7', '0', TPACPI_FAN_Q1),\n\tTPACPI_QEC_LNV('7', 'M', TPACPI_FAN_2FAN),\n\tTPACPI_Q_LNV('N', '1', TPACPI_FAN_2FAN),\n\tTPACPI_Q_LNV3('N', '1', 'D', TPACPI_FAN_2CTL),\t \n\tTPACPI_Q_LNV3('N', '1', 'E', TPACPI_FAN_2CTL),\t \n\tTPACPI_Q_LNV3('N', '1', 'T', TPACPI_FAN_2CTL),\t \n\tTPACPI_Q_LNV3('N', '1', 'U', TPACPI_FAN_2CTL),\t \n\tTPACPI_Q_LNV3('N', '2', 'C', TPACPI_FAN_2CTL),\t \n\tTPACPI_Q_LNV3('N', '2', 'N', TPACPI_FAN_2CTL),\t \n\tTPACPI_Q_LNV3('N', '2', 'E', TPACPI_FAN_2CTL),\t \n\tTPACPI_Q_LNV3('N', '2', 'O', TPACPI_FAN_2CTL),\t \n\tTPACPI_Q_LNV3('N', '3', '0', TPACPI_FAN_2CTL),\t \n\tTPACPI_Q_LNV3('N', '3', '7', TPACPI_FAN_2CTL),   \n\tTPACPI_Q_LNV3('R', '1', 'F', TPACPI_FAN_NS),\t \n\tTPACPI_Q_LNV3('N', '2', 'U', TPACPI_FAN_NS),\t \n\tTPACPI_Q_LNV3('N', '1', 'O', TPACPI_FAN_NOFAN),\t \n};\n\nstatic int __init fan_init(struct ibm_init_struct *iibm)\n{\n\tunsigned long quirks;\n\n\tvdbg_printk(TPACPI_DBG_INIT | TPACPI_DBG_FAN,\n\t\t\t\"initializing fan subdriver\\n\");\n\n\tmutex_init(&fan_mutex);\n\tfan_status_access_mode = TPACPI_FAN_NONE;\n\tfan_control_access_mode = TPACPI_FAN_WR_NONE;\n\tfan_control_commands = 0;\n\tfan_watchdog_maxinterval = 0;\n\ttp_features.fan_ctrl_status_undef = 0;\n\ttp_features.second_fan = 0;\n\ttp_features.second_fan_ctl = 0;\n\tfan_control_desired_level = 7;\n\n\tif (tpacpi_is_ibm()) {\n\t\tTPACPI_ACPIHANDLE_INIT(fans);\n\t\tTPACPI_ACPIHANDLE_INIT(gfan);\n\t\tTPACPI_ACPIHANDLE_INIT(sfan);\n\t}\n\n\tquirks = tpacpi_check_quirks(fan_quirk_table,\n\t\t\t\t     ARRAY_SIZE(fan_quirk_table));\n\n\tif (quirks & TPACPI_FAN_NOFAN) {\n\t\tpr_info(\"No integrated ThinkPad fan available\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (quirks & TPACPI_FAN_NS) {\n\t\tpr_info(\"ECFW with non-standard fan reg control found\\n\");\n\t\tfan_with_ns_addr = 1;\n\t\t \n\t\ttp_features.fan_ctrl_status_undef = 1;\n\t}\n\n\tif (gfan_handle) {\n\t\t \n\t\tfan_status_access_mode = TPACPI_FAN_RD_ACPI_GFAN;\n\t} else {\n\t\t \n\t\tif (fan_with_ns_addr ||\n\t\t    likely(acpi_ec_read(fan_status_offset, &fan_control_initial_status))) {\n\t\t\tint res;\n\t\t\tunsigned int speed;\n\n\t\t\tfan_status_access_mode = fan_with_ns_addr ?\n\t\t\t\tTPACPI_FAN_RD_TPEC_NS : TPACPI_FAN_RD_TPEC;\n\n\t\t\tif (quirks & TPACPI_FAN_Q1)\n\t\t\t\tfan_quirk1_setup();\n\t\t\t \n\t\t\ttp_features.second_fan = 1;  \n\t\t\tres = fan2_get_speed(&speed);\n\t\t\tif (res >= 0 && speed != FAN_NOT_PRESENT) {\n\t\t\t\t \n\t\t\t\ttp_features.second_fan = 1;\n\t\t\t\t \n\t\t\t\ttp_features.second_fan_ctl = !fan_with_ns_addr;\n\t\t\t\tpr_info(\"secondary fan control detected & enabled\\n\");\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\ttp_features.second_fan = 0;\n\t\t\t\tif (quirks & TPACPI_FAN_2FAN) {\n\t\t\t\t\ttp_features.second_fan = 1;\n\t\t\t\t\tpr_info(\"secondary fan support enabled\\n\");\n\t\t\t\t}\n\t\t\t\tif (quirks & TPACPI_FAN_2CTL) {\n\t\t\t\t\ttp_features.second_fan = 1;\n\t\t\t\t\ttp_features.second_fan_ctl = 1;\n\t\t\t\t\tpr_info(\"secondary fan control enabled\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tpr_err(\"ThinkPad ACPI EC access misbehaving, fan status and control unavailable\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\tif (sfan_handle) {\n\t\t \n\t\tfan_control_access_mode = TPACPI_FAN_WR_ACPI_SFAN;\n\t\tfan_control_commands |=\n\t\t    TPACPI_FAN_CMD_LEVEL | TPACPI_FAN_CMD_ENABLE;\n\t} else {\n\t\tif (!gfan_handle) {\n\t\t\t \n\t\t\t \n\n\t\t\tif (fans_handle) {\n\t\t\t\t \n\t\t\t\tfan_control_access_mode =\n\t\t\t\t    TPACPI_FAN_WR_ACPI_FANS;\n\t\t\t\tfan_control_commands |=\n\t\t\t\t    TPACPI_FAN_CMD_SPEED |\n\t\t\t\t    TPACPI_FAN_CMD_LEVEL |\n\t\t\t\t    TPACPI_FAN_CMD_ENABLE;\n\t\t\t} else {\n\t\t\t\tfan_control_access_mode = TPACPI_FAN_WR_TPEC;\n\t\t\t\tfan_control_commands |=\n\t\t\t\t    TPACPI_FAN_CMD_LEVEL |\n\t\t\t\t    TPACPI_FAN_CMD_ENABLE;\n\t\t\t}\n\t\t}\n\t}\n\n\tvdbg_printk(TPACPI_DBG_INIT | TPACPI_DBG_FAN,\n\t\t\"fan is %s, modes %d, %d\\n\",\n\t\tstr_supported(fan_status_access_mode != TPACPI_FAN_NONE ||\n\t\t  fan_control_access_mode != TPACPI_FAN_WR_NONE),\n\t\tfan_status_access_mode, fan_control_access_mode);\n\n\t \n\tif (!fan_control_allowed) {\n\t\tfan_control_access_mode = TPACPI_FAN_WR_NONE;\n\t\tfan_control_commands = 0;\n\t\tdbg_printk(TPACPI_DBG_INIT | TPACPI_DBG_FAN,\n\t\t\t   \"fan control features disabled by parameter\\n\");\n\t}\n\n\t \n\tif (fan_status_access_mode != TPACPI_FAN_NONE)\n\t\tfan_get_status_safe(NULL);\n\n\tif (fan_status_access_mode == TPACPI_FAN_NONE &&\n\t    fan_control_access_mode == TPACPI_FAN_WR_NONE)\n\t\treturn -ENODEV;\n\n\treturn 0;\n}\n\nstatic void fan_exit(void)\n{\n\tvdbg_printk(TPACPI_DBG_EXIT | TPACPI_DBG_FAN,\n\t\t    \"cancelling any pending fan watchdog tasks\\n\");\n\n\tcancel_delayed_work(&fan_watchdog_task);\n\tflush_workqueue(tpacpi_wq);\n}\n\nstatic void fan_suspend(void)\n{\n\tint rc;\n\n\tif (!fan_control_allowed)\n\t\treturn;\n\n\t \n\tfan_control_resume_level = 0;\n\trc = fan_get_status_safe(&fan_control_resume_level);\n\tif (rc)\n\t\tpr_notice(\"failed to read fan level for later restore during resume: %d\\n\",\n\t\t\t  rc);\n\n\t \n\tif (tp_features.fan_ctrl_status_undef)\n\t\tfan_control_resume_level = 0;\n}\n\nstatic void fan_resume(void)\n{\n\tu8 current_level = 7;\n\tbool do_set = false;\n\tint rc;\n\n\t \n\ttp_features.fan_ctrl_status_undef = 0;\n\n\tif (!fan_control_allowed ||\n\t    !fan_control_resume_level ||\n\t    fan_get_status_safe(&current_level))\n\t\treturn;\n\n\tswitch (fan_control_access_mode) {\n\tcase TPACPI_FAN_WR_ACPI_SFAN:\n\t\t \n\t\tdo_set = (fan_control_resume_level > current_level);\n\t\tbreak;\n\tcase TPACPI_FAN_WR_ACPI_FANS:\n\tcase TPACPI_FAN_WR_TPEC:\n\t\t \n\t\tif (fan_control_resume_level != 7 &&\n\t\t    !(fan_control_resume_level & TP_EC_FAN_FULLSPEED))\n\t\t\treturn;\n\t\telse\n\t\t\tdo_set = !(current_level & TP_EC_FAN_FULLSPEED) &&\n\t\t\t\t (current_level != fan_control_resume_level);\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\tif (do_set) {\n\t\tpr_notice(\"restoring fan level to 0x%02x\\n\",\n\t\t\t  fan_control_resume_level);\n\t\trc = fan_set_level_safe(fan_control_resume_level);\n\t\tif (rc < 0)\n\t\t\tpr_notice(\"failed to restore fan level: %d\\n\", rc);\n\t}\n}\n\nstatic int fan_read(struct seq_file *m)\n{\n\tint rc;\n\tu8 status;\n\tunsigned int speed = 0;\n\n\tswitch (fan_status_access_mode) {\n\tcase TPACPI_FAN_RD_ACPI_GFAN:\n\t\t \n\t\trc = fan_get_status_safe(&status);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\tseq_printf(m, \"status:\\t\\t%s\\n\"\n\t\t\t       \"level:\\t\\t%d\\n\",\n\t\t\t       str_enabled_disabled(status), status);\n\t\tbreak;\n\n\tcase TPACPI_FAN_RD_TPEC_NS:\n\tcase TPACPI_FAN_RD_TPEC:\n\t\t \n\t\trc = fan_get_status_safe(&status);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\tseq_printf(m, \"status:\\t\\t%s\\n\", str_enabled_disabled(status));\n\n\t\trc = fan_get_speed(&speed);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\tseq_printf(m, \"speed:\\t\\t%d\\n\", speed);\n\n\t\tif (fan_status_access_mode == TPACPI_FAN_RD_TPEC_NS) {\n\t\t\t \n\t\t\tseq_printf(m, \"level:\\t\\t%s\\n\", status & FAN_NS_CTRL ? \"unknown\" : \"auto\");\n\t\t} else {\n\t\t\tif (status & TP_EC_FAN_FULLSPEED)\n\t\t\t\t \n\t\t\t\tseq_printf(m, \"level:\\t\\tdisengaged\\n\");\n\t\t\telse if (status & TP_EC_FAN_AUTO)\n\t\t\t\tseq_printf(m, \"level:\\t\\tauto\\n\");\n\t\t\telse\n\t\t\t\tseq_printf(m, \"level:\\t\\t%d\\n\", status);\n\t\t}\n\t\tbreak;\n\n\tcase TPACPI_FAN_NONE:\n\tdefault:\n\t\tseq_printf(m, \"status:\\t\\tnot supported\\n\");\n\t}\n\n\tif (fan_control_commands & TPACPI_FAN_CMD_LEVEL) {\n\t\tseq_printf(m, \"commands:\\tlevel <level>\");\n\n\t\tswitch (fan_control_access_mode) {\n\t\tcase TPACPI_FAN_WR_ACPI_SFAN:\n\t\t\tseq_printf(m, \" (<level> is 0-7)\\n\");\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tseq_printf(m, \" (<level> is 0-7, auto, disengaged, full-speed)\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (fan_control_commands & TPACPI_FAN_CMD_ENABLE)\n\t\tseq_printf(m, \"commands:\\tenable, disable\\n\"\n\t\t\t       \"commands:\\twatchdog <timeout> (<timeout> is 0 (off), 1-120 (seconds))\\n\");\n\n\tif (fan_control_commands & TPACPI_FAN_CMD_SPEED)\n\t\tseq_printf(m, \"commands:\\tspeed <speed> (<speed> is 0-65535)\\n\");\n\n\treturn 0;\n}\n\nstatic int fan_write_cmd_level(const char *cmd, int *rc)\n{\n\tint level;\n\n\tif (strstarts(cmd, \"level auto\"))\n\t\tlevel = TP_EC_FAN_AUTO;\n\telse if (strstarts(cmd, \"level disengaged\") || strstarts(cmd, \"level full-speed\"))\n\t\tlevel = TP_EC_FAN_FULLSPEED;\n\telse if (sscanf(cmd, \"level %d\", &level) != 1)\n\t\treturn 0;\n\n\t*rc = fan_set_level_safe(level);\n\tif (*rc == -ENXIO)\n\t\tpr_err(\"level command accepted for unsupported access mode %d\\n\",\n\t\t       fan_control_access_mode);\n\telse if (!*rc)\n\t\ttpacpi_disclose_usertask(\"procfs fan\",\n\t\t\t\"set level to %d\\n\", level);\n\n\treturn 1;\n}\n\nstatic int fan_write_cmd_enable(const char *cmd, int *rc)\n{\n\tif (!strstarts(cmd, \"enable\"))\n\t\treturn 0;\n\n\t*rc = fan_set_enable();\n\tif (*rc == -ENXIO)\n\t\tpr_err(\"enable command accepted for unsupported access mode %d\\n\",\n\t\t       fan_control_access_mode);\n\telse if (!*rc)\n\t\ttpacpi_disclose_usertask(\"procfs fan\", \"enable\\n\");\n\n\treturn 1;\n}\n\nstatic int fan_write_cmd_disable(const char *cmd, int *rc)\n{\n\tif (!strstarts(cmd, \"disable\"))\n\t\treturn 0;\n\n\t*rc = fan_set_disable();\n\tif (*rc == -ENXIO)\n\t\tpr_err(\"disable command accepted for unsupported access mode %d\\n\",\n\t\t       fan_control_access_mode);\n\telse if (!*rc)\n\t\ttpacpi_disclose_usertask(\"procfs fan\", \"disable\\n\");\n\n\treturn 1;\n}\n\nstatic int fan_write_cmd_speed(const char *cmd, int *rc)\n{\n\tint speed;\n\n\t \n\n\tif (sscanf(cmd, \"speed %d\", &speed) != 1)\n\t\treturn 0;\n\n\t*rc = fan_set_speed(speed);\n\tif (*rc == -ENXIO)\n\t\tpr_err(\"speed command accepted for unsupported access mode %d\\n\",\n\t\t       fan_control_access_mode);\n\telse if (!*rc)\n\t\ttpacpi_disclose_usertask(\"procfs fan\",\n\t\t\t\"set speed to %d\\n\", speed);\n\n\treturn 1;\n}\n\nstatic int fan_write_cmd_watchdog(const char *cmd, int *rc)\n{\n\tint interval;\n\n\tif (sscanf(cmd, \"watchdog %d\", &interval) != 1)\n\t\treturn 0;\n\n\tif (interval < 0 || interval > 120)\n\t\t*rc = -EINVAL;\n\telse {\n\t\tfan_watchdog_maxinterval = interval;\n\t\ttpacpi_disclose_usertask(\"procfs fan\",\n\t\t\t\"set watchdog timer to %d\\n\",\n\t\t\tinterval);\n\t}\n\n\treturn 1;\n}\n\nstatic int fan_write(char *buf)\n{\n\tchar *cmd;\n\tint rc = 0;\n\n\twhile (!rc && (cmd = strsep(&buf, \",\"))) {\n\t\tif (!((fan_control_commands & TPACPI_FAN_CMD_LEVEL) &&\n\t\t      fan_write_cmd_level(cmd, &rc)) &&\n\t\t    !((fan_control_commands & TPACPI_FAN_CMD_ENABLE) &&\n\t\t      (fan_write_cmd_enable(cmd, &rc) ||\n\t\t       fan_write_cmd_disable(cmd, &rc) ||\n\t\t       fan_write_cmd_watchdog(cmd, &rc))) &&\n\t\t    !((fan_control_commands & TPACPI_FAN_CMD_SPEED) &&\n\t\t      fan_write_cmd_speed(cmd, &rc))\n\t\t    )\n\t\t\trc = -EINVAL;\n\t\telse if (!rc)\n\t\t\tfan_watchdog_reset();\n\t}\n\n\treturn rc;\n}\n\nstatic struct ibm_struct fan_driver_data = {\n\t.name = \"fan\",\n\t.read = fan_read,\n\t.write = fan_write,\n\t.exit = fan_exit,\n\t.suspend = fan_suspend,\n\t.resume = fan_resume,\n};\n\n \n\n#define TPACPI_LED_MAX\t\t2\n\nstruct tp_led_table {\n\tacpi_string name;\n\tint on_value;\n\tint off_value;\n\tint state;\n};\n\nstatic struct tp_led_table led_tables[TPACPI_LED_MAX] = {\n\t[LED_AUDIO_MUTE] = {\n\t\t.name = \"SSMS\",\n\t\t.on_value = 1,\n\t\t.off_value = 0,\n\t},\n\t[LED_AUDIO_MICMUTE] = {\n\t\t.name = \"MMTS\",\n\t\t.on_value = 2,\n\t\t.off_value = 0,\n\t},\n};\n\nstatic int mute_led_on_off(struct tp_led_table *t, bool state)\n{\n\tacpi_handle temp;\n\tint output;\n\n\tif (ACPI_FAILURE(acpi_get_handle(hkey_handle, t->name, &temp))) {\n\t\tpr_warn(\"Thinkpad ACPI has no %s interface.\\n\", t->name);\n\t\treturn -EIO;\n\t}\n\n\tif (!acpi_evalf(hkey_handle, &output, t->name, \"dd\",\n\t\t\tstate ? t->on_value : t->off_value))\n\t\treturn -EIO;\n\n\tt->state = state;\n\treturn state;\n}\n\nstatic int tpacpi_led_set(int whichled, bool on)\n{\n\tstruct tp_led_table *t;\n\n\tt = &led_tables[whichled];\n\tif (t->state < 0 || t->state == on)\n\t\treturn t->state;\n\treturn mute_led_on_off(t, on);\n}\n\nstatic int tpacpi_led_mute_set(struct led_classdev *led_cdev,\n\t\t\t       enum led_brightness brightness)\n{\n\treturn tpacpi_led_set(LED_AUDIO_MUTE, brightness != LED_OFF);\n}\n\nstatic int tpacpi_led_micmute_set(struct led_classdev *led_cdev,\n\t\t\t\t  enum led_brightness brightness)\n{\n\treturn tpacpi_led_set(LED_AUDIO_MICMUTE, brightness != LED_OFF);\n}\n\nstatic struct led_classdev mute_led_cdev[TPACPI_LED_MAX] = {\n\t[LED_AUDIO_MUTE] = {\n\t\t.name\t\t= \"platform::mute\",\n\t\t.max_brightness = 1,\n\t\t.brightness_set_blocking = tpacpi_led_mute_set,\n\t\t.default_trigger = \"audio-mute\",\n\t},\n\t[LED_AUDIO_MICMUTE] = {\n\t\t.name\t\t= \"platform::micmute\",\n\t\t.max_brightness = 1,\n\t\t.brightness_set_blocking = tpacpi_led_micmute_set,\n\t\t.default_trigger = \"audio-micmute\",\n\t},\n};\n\nstatic int mute_led_init(struct ibm_init_struct *iibm)\n{\n\tacpi_handle temp;\n\tint i, err;\n\n\tfor (i = 0; i < TPACPI_LED_MAX; i++) {\n\t\tstruct tp_led_table *t = &led_tables[i];\n\t\tif (ACPI_FAILURE(acpi_get_handle(hkey_handle, t->name, &temp))) {\n\t\t\tt->state = -ENODEV;\n\t\t\tcontinue;\n\t\t}\n\n\t\tmute_led_cdev[i].brightness = ledtrig_audio_get(i);\n\t\terr = led_classdev_register(&tpacpi_pdev->dev, &mute_led_cdev[i]);\n\t\tif (err < 0) {\n\t\t\twhile (i--)\n\t\t\t\tled_classdev_unregister(&mute_led_cdev[i]);\n\t\t\treturn err;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void mute_led_exit(void)\n{\n\tint i;\n\n\tfor (i = 0; i < TPACPI_LED_MAX; i++) {\n\t\tled_classdev_unregister(&mute_led_cdev[i]);\n\t\ttpacpi_led_set(i, false);\n\t}\n}\n\nstatic void mute_led_resume(void)\n{\n\tint i;\n\n\tfor (i = 0; i < TPACPI_LED_MAX; i++) {\n\t\tstruct tp_led_table *t = &led_tables[i];\n\t\tif (t->state >= 0)\n\t\t\tmute_led_on_off(t, t->state);\n\t}\n}\n\nstatic struct ibm_struct mute_led_driver_data = {\n\t.name = \"mute_led\",\n\t.exit = mute_led_exit,\n\t.resume = mute_led_resume,\n};\n\n \n\n \n\n#define GET_START\t\"BCTG\"\n#define SET_START\t\"BCCS\"\n#define GET_STOP\t\"BCSG\"\n#define SET_STOP\t\"BCSS\"\n#define GET_DISCHARGE\t\"BDSG\"\n#define SET_DISCHARGE\t\"BDSS\"\n#define GET_INHIBIT\t\"BICG\"\n#define SET_INHIBIT\t\"BICS\"\n\nenum {\n\tBAT_ANY = 0,\n\tBAT_PRIMARY = 1,\n\tBAT_SECONDARY = 2\n};\n\nenum {\n\t \n\tMETHOD_ERR = BIT(31),\n};\n\nenum {\n\t \n\tTHRESHOLD_START,\n\tTHRESHOLD_STOP,\n\tFORCE_DISCHARGE,\n\tINHIBIT_CHARGE,\n};\n\nstruct tpacpi_battery_data {\n\tint charge_start;\n\tint start_support;\n\tint charge_stop;\n\tint stop_support;\n\tunsigned int charge_behaviours;\n};\n\nstruct tpacpi_battery_driver_data {\n\tstruct tpacpi_battery_data batteries[3];\n\tint individual_addressing;\n};\n\nstatic struct tpacpi_battery_driver_data battery_info;\n\n \n\n \nstatic acpi_status tpacpi_battery_acpi_eval(char *method, int *ret, int param)\n{\n\tint response;\n\n\tif (!acpi_evalf(hkey_handle, &response, method, \"dd\", param)) {\n\t\tacpi_handle_err(hkey_handle, \"%s: evaluate failed\", method);\n\t\treturn AE_ERROR;\n\t}\n\tif (response & METHOD_ERR) {\n\t\tacpi_handle_err(hkey_handle,\n\t\t\t\t\"%s evaluated but flagged as error\", method);\n\t\treturn AE_ERROR;\n\t}\n\t*ret = response;\n\treturn AE_OK;\n}\n\nstatic int tpacpi_battery_get(int what, int battery, int *ret)\n{\n\tswitch (what) {\n\tcase THRESHOLD_START:\n\t\tif ACPI_FAILURE(tpacpi_battery_acpi_eval(GET_START, ret, battery))\n\t\t\treturn -ENODEV;\n\n\t\t \n\t\t*ret = *ret & 0xFF;\n\t\treturn 0;\n\tcase THRESHOLD_STOP:\n\t\tif ACPI_FAILURE(tpacpi_battery_acpi_eval(GET_STOP, ret, battery))\n\t\t\treturn -ENODEV;\n\t\t \n\t\t*ret = *ret & 0xFF;\n\t\t \n\t\tif (*ret == 0)\n\t\t\t*ret = 100;\n\t\treturn 0;\n\tcase FORCE_DISCHARGE:\n\t\tif ACPI_FAILURE(tpacpi_battery_acpi_eval(GET_DISCHARGE, ret, battery))\n\t\t\treturn -ENODEV;\n\t\t \n\t\t*ret = *ret & 0x01;\n\t\treturn 0;\n\tcase INHIBIT_CHARGE:\n\t\tif ACPI_FAILURE(tpacpi_battery_acpi_eval(GET_INHIBIT, ret, battery))\n\t\t\treturn -ENODEV;\n\t\t \n\t\t*ret = *ret & 0x01;\n\t\treturn 0;\n\tdefault:\n\t\tpr_crit(\"wrong parameter: %d\", what);\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int tpacpi_battery_set(int what, int battery, int value)\n{\n\tint param, ret;\n\t \n\tparam = value;\n\t \n\tparam |= battery << 8;\n\n\tswitch (what) {\n\tcase THRESHOLD_START:\n\t\tif ACPI_FAILURE(tpacpi_battery_acpi_eval(SET_START, &ret, param)) {\n\t\t\tpr_err(\"failed to set charge threshold on battery %d\",\n\t\t\t\t\tbattery);\n\t\t\treturn -ENODEV;\n\t\t}\n\t\treturn 0;\n\tcase THRESHOLD_STOP:\n\t\tif ACPI_FAILURE(tpacpi_battery_acpi_eval(SET_STOP, &ret, param)) {\n\t\t\tpr_err(\"failed to set stop threshold: %d\", battery);\n\t\t\treturn -ENODEV;\n\t\t}\n\t\treturn 0;\n\tcase FORCE_DISCHARGE:\n\t\t \n\t\tif (ACPI_FAILURE(tpacpi_battery_acpi_eval(SET_DISCHARGE, &ret, param))) {\n\t\t\tpr_err(\"failed to set force discharge on %d\", battery);\n\t\t\treturn -ENODEV;\n\t\t}\n\t\treturn 0;\n\tcase INHIBIT_CHARGE:\n\t\t \n\t\tparam = value;\n\t\tparam |= battery << 4;\n\t\tparam |= 0xFFFF << 8;\n\t\tif (ACPI_FAILURE(tpacpi_battery_acpi_eval(SET_INHIBIT, &ret, param))) {\n\t\t\tpr_err(\"failed to set inhibit charge on %d\", battery);\n\t\t\treturn -ENODEV;\n\t\t}\n\t\treturn 0;\n\tdefault:\n\t\tpr_crit(\"wrong parameter: %d\", what);\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int tpacpi_battery_set_validate(int what, int battery, int value)\n{\n\tint ret, v;\n\n\tret = tpacpi_battery_set(what, battery, value);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = tpacpi_battery_get(what, battery, &v);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (v == value)\n\t\treturn 0;\n\n\tmsleep(500);\n\n\tret = tpacpi_battery_get(what, battery, &v);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (v == value)\n\t\treturn 0;\n\n\treturn -EIO;\n}\n\nstatic int tpacpi_battery_probe(int battery)\n{\n\tint ret = 0;\n\n\tmemset(&battery_info.batteries[battery], 0,\n\t\tsizeof(battery_info.batteries[battery]));\n\n\t \n\tif (acpi_has_method(hkey_handle, GET_START)) {\n\t\tif ACPI_FAILURE(tpacpi_battery_acpi_eval(GET_START, &ret, battery)) {\n\t\t\tpr_err(\"Error probing battery %d\\n\", battery);\n\t\t\treturn -ENODEV;\n\t\t}\n\t\t \n\t\tif (ret & BIT(9))\n\t\t\tbattery_info.individual_addressing = true;\n\t\t \n\t\tif (ret & BIT(8))\n\t\t\tbattery_info.batteries[battery].start_support = 1;\n\t\telse\n\t\t\treturn -ENODEV;\n\t\tif (tpacpi_battery_get(THRESHOLD_START, battery,\n\t\t\t&battery_info.batteries[battery].charge_start)) {\n\t\t\tpr_err(\"Error probing battery %d\\n\", battery);\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\tif (acpi_has_method(hkey_handle, GET_STOP)) {\n\t\tif ACPI_FAILURE(tpacpi_battery_acpi_eval(GET_STOP, &ret, battery)) {\n\t\t\tpr_err(\"Error probing battery stop; %d\\n\", battery);\n\t\t\treturn -ENODEV;\n\t\t}\n\t\t \n\t\tif (ret & BIT(8))\n\t\t\tbattery_info.batteries[battery].stop_support = 1;\n\t\telse\n\t\t\treturn -ENODEV;\n\t\tif (tpacpi_battery_get(THRESHOLD_STOP, battery,\n\t\t\t&battery_info.batteries[battery].charge_stop)) {\n\t\t\tpr_err(\"Error probing battery stop: %d\\n\", battery);\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\tif (acpi_has_method(hkey_handle, GET_DISCHARGE)) {\n\t\tif (ACPI_FAILURE(tpacpi_battery_acpi_eval(GET_DISCHARGE, &ret, battery))) {\n\t\t\tpr_err(\"Error probing battery discharge; %d\\n\", battery);\n\t\t\treturn -ENODEV;\n\t\t}\n\t\t \n\t\tif (ret & BIT(8))\n\t\t\tbattery_info.batteries[battery].charge_behaviours |=\n\t\t\t\tBIT(POWER_SUPPLY_CHARGE_BEHAVIOUR_FORCE_DISCHARGE);\n\t}\n\tif (acpi_has_method(hkey_handle, GET_INHIBIT)) {\n\t\tif (ACPI_FAILURE(tpacpi_battery_acpi_eval(GET_INHIBIT, &ret, battery))) {\n\t\t\tpr_err(\"Error probing battery inhibit charge; %d\\n\", battery);\n\t\t\treturn -ENODEV;\n\t\t}\n\t\t \n\t\tif (ret & BIT(5))\n\t\t\tbattery_info.batteries[battery].charge_behaviours |=\n\t\t\t\tBIT(POWER_SUPPLY_CHARGE_BEHAVIOUR_INHIBIT_CHARGE);\n\t}\n\n\tbattery_info.batteries[battery].charge_behaviours |=\n\t\tBIT(POWER_SUPPLY_CHARGE_BEHAVIOUR_AUTO);\n\n\tpr_info(\"battery %d registered (start %d, stop %d, behaviours: 0x%x)\\n\",\n\t\tbattery,\n\t\tbattery_info.batteries[battery].charge_start,\n\t\tbattery_info.batteries[battery].charge_stop,\n\t\tbattery_info.batteries[battery].charge_behaviours);\n\n\treturn 0;\n}\n\n \n\nstatic int tpacpi_battery_get_id(const char *battery_name)\n{\n\n\tif (strcmp(battery_name, \"BAT0\") == 0 ||\n\t    tp_features.battery_force_primary)\n\t\treturn BAT_PRIMARY;\n\tif (strcmp(battery_name, \"BAT1\") == 0)\n\t\treturn BAT_SECONDARY;\n\t \n\tpr_warn(\"unknown battery %s, assuming primary\", battery_name);\n\treturn BAT_PRIMARY;\n}\n\n \n\nstatic ssize_t tpacpi_battery_store(int what,\n\t\t\t\t    struct device *dev,\n\t\t\t\t    const char *buf, size_t count)\n{\n\tstruct power_supply *supply = to_power_supply(dev);\n\tunsigned long value;\n\tint battery, rval;\n\t \n\tif (battery_info.individual_addressing)\n\t\t \n\t\tbattery = tpacpi_battery_get_id(supply->desc->name);\n\telse\n\t\tbattery = BAT_PRIMARY;\n\n\trval = kstrtoul(buf, 10, &value);\n\tif (rval)\n\t\treturn rval;\n\n\tswitch (what) {\n\tcase THRESHOLD_START:\n\t\tif (!battery_info.batteries[battery].start_support)\n\t\t\treturn -ENODEV;\n\t\t \n\t\tif (value > 99)\n\t\t\treturn -EINVAL;\n\t\tif (value > battery_info.batteries[battery].charge_stop)\n\t\t\treturn -EINVAL;\n\t\tif (tpacpi_battery_set(THRESHOLD_START, battery, value))\n\t\t\treturn -ENODEV;\n\t\tbattery_info.batteries[battery].charge_start = value;\n\t\treturn count;\n\n\tcase THRESHOLD_STOP:\n\t\tif (!battery_info.batteries[battery].stop_support)\n\t\t\treturn -ENODEV;\n\t\t \n\t\tif (value < 1 || value > 100)\n\t\t\treturn -EINVAL;\n\t\tif (value < battery_info.batteries[battery].charge_start)\n\t\t\treturn -EINVAL;\n\t\tbattery_info.batteries[battery].charge_stop = value;\n\t\t \n\t\tif (value == 100)\n\t\t\tvalue = 0;\n\t\tif (tpacpi_battery_set(THRESHOLD_STOP, battery, value))\n\t\t\treturn -EINVAL;\n\t\treturn count;\n\tdefault:\n\t\tpr_crit(\"Wrong parameter: %d\", what);\n\t\treturn -EINVAL;\n\t}\n\treturn count;\n}\n\nstatic ssize_t tpacpi_battery_show(int what,\n\t\t\t\t   struct device *dev,\n\t\t\t\t   char *buf)\n{\n\tstruct power_supply *supply = to_power_supply(dev);\n\tint ret, battery;\n\t \n\tif (battery_info.individual_addressing)\n\t\t \n\t\tbattery = tpacpi_battery_get_id(supply->desc->name);\n\telse\n\t\tbattery = BAT_PRIMARY;\n\tif (tpacpi_battery_get(what, battery, &ret))\n\t\treturn -ENODEV;\n\treturn sprintf(buf, \"%d\\n\", ret);\n}\n\nstatic ssize_t charge_control_start_threshold_show(struct device *device,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\treturn tpacpi_battery_show(THRESHOLD_START, device, buf);\n}\n\nstatic ssize_t charge_control_end_threshold_show(struct device *device,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\treturn tpacpi_battery_show(THRESHOLD_STOP, device, buf);\n}\n\nstatic ssize_t charge_behaviour_show(struct device *dev,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     char *buf)\n{\n\tenum power_supply_charge_behaviour active = POWER_SUPPLY_CHARGE_BEHAVIOUR_AUTO;\n\tstruct power_supply *supply = to_power_supply(dev);\n\tunsigned int available;\n\tint ret, battery;\n\n\tbattery = tpacpi_battery_get_id(supply->desc->name);\n\tavailable = battery_info.batteries[battery].charge_behaviours;\n\n\tif (available & BIT(POWER_SUPPLY_CHARGE_BEHAVIOUR_FORCE_DISCHARGE)) {\n\t\tif (tpacpi_battery_get(FORCE_DISCHARGE, battery, &ret))\n\t\t\treturn -ENODEV;\n\t\tif (ret) {\n\t\t\tactive = POWER_SUPPLY_CHARGE_BEHAVIOUR_FORCE_DISCHARGE;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (available & BIT(POWER_SUPPLY_CHARGE_BEHAVIOUR_INHIBIT_CHARGE)) {\n\t\tif (tpacpi_battery_get(INHIBIT_CHARGE, battery, &ret))\n\t\t\treturn -ENODEV;\n\t\tif (ret) {\n\t\t\tactive = POWER_SUPPLY_CHARGE_BEHAVIOUR_INHIBIT_CHARGE;\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\treturn power_supply_charge_behaviour_show(dev, available, active, buf);\n}\n\nstatic ssize_t charge_control_start_threshold_store(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tconst char *buf, size_t count)\n{\n\treturn tpacpi_battery_store(THRESHOLD_START, dev, buf, count);\n}\n\nstatic ssize_t charge_control_end_threshold_store(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tconst char *buf, size_t count)\n{\n\treturn tpacpi_battery_store(THRESHOLD_STOP, dev, buf, count);\n}\n\nstatic ssize_t charge_behaviour_store(struct device *dev,\n\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t      const char *buf, size_t count)\n{\n\tstruct power_supply *supply = to_power_supply(dev);\n\tint selected, battery, ret = 0;\n\tunsigned int available;\n\n\tbattery = tpacpi_battery_get_id(supply->desc->name);\n\tavailable = battery_info.batteries[battery].charge_behaviours;\n\tselected = power_supply_charge_behaviour_parse(available, buf);\n\n\tif (selected < 0)\n\t\treturn selected;\n\n\tswitch (selected) {\n\tcase POWER_SUPPLY_CHARGE_BEHAVIOUR_AUTO:\n\t\tif (available & BIT(POWER_SUPPLY_CHARGE_BEHAVIOUR_FORCE_DISCHARGE))\n\t\t\tret = tpacpi_battery_set_validate(FORCE_DISCHARGE, battery, 0);\n\t\tif (available & BIT(POWER_SUPPLY_CHARGE_BEHAVIOUR_INHIBIT_CHARGE))\n\t\t\tret = min(ret, tpacpi_battery_set_validate(INHIBIT_CHARGE, battery, 0));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase POWER_SUPPLY_CHARGE_BEHAVIOUR_FORCE_DISCHARGE:\n\t\tif (available & BIT(POWER_SUPPLY_CHARGE_BEHAVIOUR_INHIBIT_CHARGE))\n\t\t\tret = tpacpi_battery_set_validate(INHIBIT_CHARGE, battery, 0);\n\t\tret = min(ret, tpacpi_battery_set_validate(FORCE_DISCHARGE, battery, 1));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase POWER_SUPPLY_CHARGE_BEHAVIOUR_INHIBIT_CHARGE:\n\t\tif (available & BIT(POWER_SUPPLY_CHARGE_BEHAVIOUR_FORCE_DISCHARGE))\n\t\t\tret = tpacpi_battery_set_validate(FORCE_DISCHARGE, battery, 0);\n\t\tret = min(ret, tpacpi_battery_set_validate(INHIBIT_CHARGE, battery, 1));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"Unexpected charge behaviour: %d\\n\", selected);\n\t\treturn -EINVAL;\n\t}\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR_RW(charge_control_start_threshold);\nstatic DEVICE_ATTR_RW(charge_control_end_threshold);\nstatic DEVICE_ATTR_RW(charge_behaviour);\nstatic struct device_attribute dev_attr_charge_start_threshold = __ATTR(\n\tcharge_start_threshold,\n\t0644,\n\tcharge_control_start_threshold_show,\n\tcharge_control_start_threshold_store\n);\nstatic struct device_attribute dev_attr_charge_stop_threshold = __ATTR(\n\tcharge_stop_threshold,\n\t0644,\n\tcharge_control_end_threshold_show,\n\tcharge_control_end_threshold_store\n);\n\nstatic struct attribute *tpacpi_battery_attrs[] = {\n\t&dev_attr_charge_control_start_threshold.attr,\n\t&dev_attr_charge_control_end_threshold.attr,\n\t&dev_attr_charge_start_threshold.attr,\n\t&dev_attr_charge_stop_threshold.attr,\n\t&dev_attr_charge_behaviour.attr,\n\tNULL,\n};\n\nATTRIBUTE_GROUPS(tpacpi_battery);\n\n \n\nstatic int tpacpi_battery_add(struct power_supply *battery, struct acpi_battery_hook *hook)\n{\n\tint batteryid = tpacpi_battery_get_id(battery->desc->name);\n\n\tif (tpacpi_battery_probe(batteryid))\n\t\treturn -ENODEV;\n\tif (device_add_groups(&battery->dev, tpacpi_battery_groups))\n\t\treturn -ENODEV;\n\treturn 0;\n}\n\nstatic int tpacpi_battery_remove(struct power_supply *battery, struct acpi_battery_hook *hook)\n{\n\tdevice_remove_groups(&battery->dev, tpacpi_battery_groups);\n\treturn 0;\n}\n\nstatic struct acpi_battery_hook battery_hook = {\n\t.add_battery = tpacpi_battery_add,\n\t.remove_battery = tpacpi_battery_remove,\n\t.name = \"ThinkPad Battery Extension\",\n};\n\n \n\nstatic const struct tpacpi_quirk battery_quirk_table[] __initconst = {\n\t \n\tTPACPI_Q_LNV('8', 'F', true),        \n\tTPACPI_Q_LNV('J', '7', true),        \n\tTPACPI_Q_LNV('J', 'I', true),        \n\tTPACPI_Q_LNV3('R', '0', 'B', true),  \n\tTPACPI_Q_LNV3('R', '0', 'C', true),  \n\tTPACPI_Q_LNV3('R', '0', 'J', true),  \n\tTPACPI_Q_LNV3('R', '0', 'K', true),  \n};\n\nstatic int __init tpacpi_battery_init(struct ibm_init_struct *ibm)\n{\n\tmemset(&battery_info, 0, sizeof(battery_info));\n\n\ttp_features.battery_force_primary = tpacpi_check_quirks(\n\t\t\t\t\tbattery_quirk_table,\n\t\t\t\t\tARRAY_SIZE(battery_quirk_table));\n\n\tbattery_hook_register(&battery_hook);\n\treturn 0;\n}\n\nstatic void tpacpi_battery_exit(void)\n{\n\tbattery_hook_unregister(&battery_hook);\n}\n\nstatic struct ibm_struct battery_driver_data = {\n\t.name = \"battery\",\n\t.exit = tpacpi_battery_exit,\n};\n\n \n\nstatic struct drm_privacy_screen *lcdshadow_dev;\nstatic acpi_handle lcdshadow_get_handle;\nstatic acpi_handle lcdshadow_set_handle;\n\nstatic int lcdshadow_set_sw_state(struct drm_privacy_screen *priv,\n\t\t\t\t  enum drm_privacy_screen_status state)\n{\n\tint output;\n\n\tif (WARN_ON(!mutex_is_locked(&priv->lock)))\n\t\treturn -EIO;\n\n\tif (!acpi_evalf(lcdshadow_set_handle, &output, NULL, \"dd\", (int)state))\n\t\treturn -EIO;\n\n\tpriv->hw_state = priv->sw_state = state;\n\treturn 0;\n}\n\nstatic void lcdshadow_get_hw_state(struct drm_privacy_screen *priv)\n{\n\tint output;\n\n\tif (!acpi_evalf(lcdshadow_get_handle, &output, NULL, \"dd\", 0))\n\t\treturn;\n\n\tpriv->hw_state = priv->sw_state = output & 0x1;\n}\n\nstatic const struct drm_privacy_screen_ops lcdshadow_ops = {\n\t.set_sw_state = lcdshadow_set_sw_state,\n\t.get_hw_state = lcdshadow_get_hw_state,\n};\n\nstatic int tpacpi_lcdshadow_init(struct ibm_init_struct *iibm)\n{\n\tacpi_status status1, status2;\n\tint output;\n\n\tstatus1 = acpi_get_handle(hkey_handle, \"GSSS\", &lcdshadow_get_handle);\n\tstatus2 = acpi_get_handle(hkey_handle, \"SSSS\", &lcdshadow_set_handle);\n\tif (ACPI_FAILURE(status1) || ACPI_FAILURE(status2))\n\t\treturn 0;\n\n\tif (!acpi_evalf(lcdshadow_get_handle, &output, NULL, \"dd\", 0))\n\t\treturn -EIO;\n\n\tif (!(output & 0x10000))\n\t\treturn 0;\n\n\tlcdshadow_dev = drm_privacy_screen_register(&tpacpi_pdev->dev,\n\t\t\t\t\t\t    &lcdshadow_ops, NULL);\n\tif (IS_ERR(lcdshadow_dev))\n\t\treturn PTR_ERR(lcdshadow_dev);\n\n\treturn 0;\n}\n\nstatic void lcdshadow_exit(void)\n{\n\tdrm_privacy_screen_unregister(lcdshadow_dev);\n}\n\nstatic void lcdshadow_resume(void)\n{\n\tif (!lcdshadow_dev)\n\t\treturn;\n\n\tmutex_lock(&lcdshadow_dev->lock);\n\tlcdshadow_set_sw_state(lcdshadow_dev, lcdshadow_dev->sw_state);\n\tmutex_unlock(&lcdshadow_dev->lock);\n}\n\nstatic int lcdshadow_read(struct seq_file *m)\n{\n\tif (!lcdshadow_dev) {\n\t\tseq_puts(m, \"status:\\t\\tnot supported\\n\");\n\t} else {\n\t\tseq_printf(m, \"status:\\t\\t%d\\n\", lcdshadow_dev->hw_state);\n\t\tseq_puts(m, \"commands:\\t0, 1\\n\");\n\t}\n\n\treturn 0;\n}\n\nstatic int lcdshadow_write(char *buf)\n{\n\tchar *cmd;\n\tint res, state = -EINVAL;\n\n\tif (!lcdshadow_dev)\n\t\treturn -ENODEV;\n\n\twhile ((cmd = strsep(&buf, \",\"))) {\n\t\tres = kstrtoint(cmd, 10, &state);\n\t\tif (res < 0)\n\t\t\treturn res;\n\t}\n\n\tif (state >= 2 || state < 0)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&lcdshadow_dev->lock);\n\tres = lcdshadow_set_sw_state(lcdshadow_dev, state);\n\tmutex_unlock(&lcdshadow_dev->lock);\n\n\tdrm_privacy_screen_call_notifier_chain(lcdshadow_dev);\n\n\treturn res;\n}\n\nstatic struct ibm_struct lcdshadow_driver_data = {\n\t.name = \"lcdshadow\",\n\t.exit = lcdshadow_exit,\n\t.resume = lcdshadow_resume,\n\t.read = lcdshadow_read,\n\t.write = lcdshadow_write,\n};\n\n \n\n#define DYTC_CMD_QUERY        0  \n#define DYTC_QUERY_ENABLE_BIT 8   \n#define DYTC_QUERY_SUBREV_BIT 16  \n#define DYTC_QUERY_REV_BIT    28  \n\n#define DYTC_CMD_GET          2  \n#define DYTC_GET_LAPMODE_BIT 17  \n\n#define PALMSENSOR_PRESENT_BIT 0  \n#define PALMSENSOR_ON_BIT      1  \n\nstatic bool has_palmsensor;\nstatic bool has_lapsensor;\nstatic bool palm_state;\nstatic bool lap_state;\nstatic int dytc_version;\n\nstatic int dytc_command(int command, int *output)\n{\n\tacpi_handle dytc_handle;\n\n\tif (ACPI_FAILURE(acpi_get_handle(hkey_handle, \"DYTC\", &dytc_handle))) {\n\t\t \n\t\treturn -ENODEV;\n\t}\n\tif (!acpi_evalf(dytc_handle, output, NULL, \"dd\", command))\n\t\treturn -EIO;\n\treturn 0;\n}\n\nstatic int lapsensor_get(bool *present, bool *state)\n{\n\tint output, err;\n\n\t*present = false;\n\terr = dytc_command(DYTC_CMD_GET, &output);\n\tif (err)\n\t\treturn err;\n\n\t*present = true;  \n\t*state = output & BIT(DYTC_GET_LAPMODE_BIT) ? true : false;\n\treturn 0;\n}\n\nstatic int palmsensor_get(bool *present, bool *state)\n{\n\tacpi_handle psensor_handle;\n\tint output;\n\n\t*present = false;\n\tif (ACPI_FAILURE(acpi_get_handle(hkey_handle, \"GPSS\", &psensor_handle)))\n\t\treturn -ENODEV;\n\tif (!acpi_evalf(psensor_handle, &output, NULL, \"d\"))\n\t\treturn -EIO;\n\n\t*present = output & BIT(PALMSENSOR_PRESENT_BIT) ? true : false;\n\t*state = output & BIT(PALMSENSOR_ON_BIT) ? true : false;\n\treturn 0;\n}\n\nstatic void lapsensor_refresh(void)\n{\n\tbool state;\n\tint err;\n\n\tif (has_lapsensor) {\n\t\terr = lapsensor_get(&has_lapsensor, &state);\n\t\tif (err)\n\t\t\treturn;\n\t\tif (lap_state != state) {\n\t\t\tlap_state = state;\n\t\t\tsysfs_notify(&tpacpi_pdev->dev.kobj, NULL, \"dytc_lapmode\");\n\t\t}\n\t}\n}\n\nstatic void palmsensor_refresh(void)\n{\n\tbool state;\n\tint err;\n\n\tif (has_palmsensor) {\n\t\terr = palmsensor_get(&has_palmsensor, &state);\n\t\tif (err)\n\t\t\treturn;\n\t\tif (palm_state != state) {\n\t\t\tpalm_state = state;\n\t\t\tsysfs_notify(&tpacpi_pdev->dev.kobj, NULL, \"palmsensor\");\n\t\t}\n\t}\n}\n\nstatic ssize_t dytc_lapmode_show(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tif (has_lapsensor)\n\t\treturn sysfs_emit(buf, \"%d\\n\", lap_state);\n\treturn sysfs_emit(buf, \"\\n\");\n}\nstatic DEVICE_ATTR_RO(dytc_lapmode);\n\nstatic ssize_t palmsensor_show(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tif (has_palmsensor)\n\t\treturn sysfs_emit(buf, \"%d\\n\", palm_state);\n\treturn sysfs_emit(buf, \"\\n\");\n}\nstatic DEVICE_ATTR_RO(palmsensor);\n\nstatic struct attribute *proxsensor_attributes[] = {\n\t&dev_attr_dytc_lapmode.attr,\n\t&dev_attr_palmsensor.attr,\n\tNULL\n};\n\nstatic umode_t proxsensor_attr_is_visible(struct kobject *kobj,\n\t\t\t\t\t  struct attribute *attr, int n)\n{\n\tif (attr == &dev_attr_dytc_lapmode.attr) {\n\t\t \n\t\tif (!has_lapsensor || dytc_version < 5)\n\t\t\treturn 0;\n\t} else if (attr == &dev_attr_palmsensor.attr) {\n\t\tif (!has_palmsensor)\n\t\t\treturn 0;\n\t}\n\n\treturn attr->mode;\n}\n\nstatic const struct attribute_group proxsensor_attr_group = {\n\t.is_visible = proxsensor_attr_is_visible,\n\t.attrs = proxsensor_attributes,\n};\n\nstatic int tpacpi_proxsensor_init(struct ibm_init_struct *iibm)\n{\n\tint palm_err, lap_err;\n\n\tpalm_err = palmsensor_get(&has_palmsensor, &palm_state);\n\tlap_err = lapsensor_get(&has_lapsensor, &lap_state);\n\t \n\tif ((palm_err == -ENODEV) && (lap_err == -ENODEV))\n\t\treturn -ENODEV;\n\t \n\tif (palm_err && (palm_err != -ENODEV))\n\t\treturn palm_err;\n\tif (lap_err && (lap_err != -ENODEV))\n\t\treturn lap_err;\n\n\treturn 0;\n}\n\nstatic struct ibm_struct proxsensor_driver_data = {\n\t.name = \"proximity-sensor\",\n};\n\n \n\n#define DYTC_CMD_SET          1  \n#define DYTC_CMD_MMC_GET      8  \n#define DYTC_CMD_RESET    0x1ff  \n\n#define DYTC_CMD_FUNC_CAP     3  \n#define DYTC_FC_MMC           27  \n#define DYTC_FC_PSC           29  \n#define DYTC_FC_AMT           31  \n\n#define DYTC_GET_FUNCTION_BIT 8   \n#define DYTC_GET_MODE_BIT     12  \n\n#define DYTC_SET_FUNCTION_BIT 12  \n#define DYTC_SET_MODE_BIT     16  \n#define DYTC_SET_VALID_BIT    20  \n\n#define DYTC_FUNCTION_STD     0   \n#define DYTC_FUNCTION_CQL     1   \n#define DYTC_FUNCTION_MMC     11  \n#define DYTC_FUNCTION_PSC     13  \n#define DYTC_FUNCTION_AMT     15  \n\n#define DYTC_MODE_AMT_ENABLE   0x1  \n#define DYTC_MODE_AMT_DISABLE  0xF  \n\n#define DYTC_MODE_MMC_PERFORM  2   \n#define DYTC_MODE_MMC_LOWPOWER 3   \n#define DYTC_MODE_MMC_BALANCE  0xF   \n#define DYTC_MODE_MMC_DEFAULT  0   \n\n#define DYTC_MODE_PSC_LOWPOWER 3   \n#define DYTC_MODE_PSC_BALANCE  5   \n#define DYTC_MODE_PSC_PERFORM  7   \n\n#define DYTC_ERR_MASK       0xF   \n#define DYTC_ERR_SUCCESS      1   \n\n#define DYTC_SET_COMMAND(function, mode, on) \\\n\t(DYTC_CMD_SET | (function) << DYTC_SET_FUNCTION_BIT | \\\n\t (mode) << DYTC_SET_MODE_BIT | \\\n\t (on) << DYTC_SET_VALID_BIT)\n\n#define DYTC_DISABLE_CQL DYTC_SET_COMMAND(DYTC_FUNCTION_CQL, DYTC_MODE_MMC_BALANCE, 0)\n#define DYTC_ENABLE_CQL DYTC_SET_COMMAND(DYTC_FUNCTION_CQL, DYTC_MODE_MMC_BALANCE, 1)\nstatic int dytc_control_amt(bool enable);\nstatic bool dytc_amt_active;\n\nstatic enum platform_profile_option dytc_current_profile;\nstatic atomic_t dytc_ignore_event = ATOMIC_INIT(0);\nstatic DEFINE_MUTEX(dytc_mutex);\nstatic int dytc_capabilities;\nstatic bool dytc_mmc_get_available;\nstatic int profile_force;\n\nstatic int convert_dytc_to_profile(int funcmode, int dytcmode,\n\t\tenum platform_profile_option *profile)\n{\n\tswitch (funcmode) {\n\tcase DYTC_FUNCTION_MMC:\n\t\tswitch (dytcmode) {\n\t\tcase DYTC_MODE_MMC_LOWPOWER:\n\t\t\t*profile = PLATFORM_PROFILE_LOW_POWER;\n\t\t\tbreak;\n\t\tcase DYTC_MODE_MMC_DEFAULT:\n\t\tcase DYTC_MODE_MMC_BALANCE:\n\t\t\t*profile =  PLATFORM_PROFILE_BALANCED;\n\t\t\tbreak;\n\t\tcase DYTC_MODE_MMC_PERFORM:\n\t\t\t*profile =  PLATFORM_PROFILE_PERFORMANCE;\n\t\t\tbreak;\n\t\tdefault:  \n\t\t\treturn -EINVAL;\n\t\t}\n\t\treturn 0;\n\tcase DYTC_FUNCTION_PSC:\n\t\tswitch (dytcmode) {\n\t\tcase DYTC_MODE_PSC_LOWPOWER:\n\t\t\t*profile = PLATFORM_PROFILE_LOW_POWER;\n\t\t\tbreak;\n\t\tcase DYTC_MODE_PSC_BALANCE:\n\t\t\t*profile =  PLATFORM_PROFILE_BALANCED;\n\t\t\tbreak;\n\t\tcase DYTC_MODE_PSC_PERFORM:\n\t\t\t*profile =  PLATFORM_PROFILE_PERFORMANCE;\n\t\t\tbreak;\n\t\tdefault:  \n\t\t\treturn -EINVAL;\n\t\t}\n\t\treturn 0;\n\tcase DYTC_FUNCTION_AMT:\n\t\t \n\t\t*profile =  PLATFORM_PROFILE_BALANCED;\n\t\treturn 0;\n\tdefault:\n\t\t \n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn 0;\n}\n\nstatic int convert_profile_to_dytc(enum platform_profile_option profile, int *perfmode)\n{\n\tswitch (profile) {\n\tcase PLATFORM_PROFILE_LOW_POWER:\n\t\tif (dytc_capabilities & BIT(DYTC_FC_MMC))\n\t\t\t*perfmode = DYTC_MODE_MMC_LOWPOWER;\n\t\telse if (dytc_capabilities & BIT(DYTC_FC_PSC))\n\t\t\t*perfmode = DYTC_MODE_PSC_LOWPOWER;\n\t\tbreak;\n\tcase PLATFORM_PROFILE_BALANCED:\n\t\tif (dytc_capabilities & BIT(DYTC_FC_MMC))\n\t\t\t*perfmode = DYTC_MODE_MMC_BALANCE;\n\t\telse if (dytc_capabilities & BIT(DYTC_FC_PSC))\n\t\t\t*perfmode = DYTC_MODE_PSC_BALANCE;\n\t\tbreak;\n\tcase PLATFORM_PROFILE_PERFORMANCE:\n\t\tif (dytc_capabilities & BIT(DYTC_FC_MMC))\n\t\t\t*perfmode = DYTC_MODE_MMC_PERFORM;\n\t\telse if (dytc_capabilities & BIT(DYTC_FC_PSC))\n\t\t\t*perfmode = DYTC_MODE_PSC_PERFORM;\n\t\tbreak;\n\tdefault:  \n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn 0;\n}\n\n \nstatic int dytc_profile_get(struct platform_profile_handler *pprof,\n\t\t\t    enum platform_profile_option *profile)\n{\n\t*profile = dytc_current_profile;\n\treturn 0;\n}\n\nstatic int dytc_control_amt(bool enable)\n{\n\tint dummy;\n\tint err;\n\tint cmd;\n\n\tif (!(dytc_capabilities & BIT(DYTC_FC_AMT))) {\n\t\tpr_warn(\"Attempting to toggle AMT on a system that doesn't advertise support\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (enable)\n\t\tcmd = DYTC_SET_COMMAND(DYTC_FUNCTION_AMT, DYTC_MODE_AMT_ENABLE, enable);\n\telse\n\t\tcmd = DYTC_SET_COMMAND(DYTC_FUNCTION_AMT, DYTC_MODE_AMT_DISABLE, enable);\n\n\tpr_debug(\"%sabling AMT (cmd 0x%x)\", enable ? \"en\":\"dis\", cmd);\n\terr = dytc_command(cmd, &dummy);\n\tif (err)\n\t\treturn err;\n\tdytc_amt_active = enable;\n\treturn 0;\n}\n\n \nstatic int dytc_cql_command(int command, int *output)\n{\n\tint err, cmd_err, dummy;\n\tint cur_funcmode;\n\n\t \n\terr = dytc_command(DYTC_CMD_GET, output);\n\tif (err)\n\t\treturn err;\n\n\tcur_funcmode = (*output >> DYTC_GET_FUNCTION_BIT) & 0xF;\n\t \n\tif ((command == DYTC_CMD_GET) && (cur_funcmode != DYTC_FUNCTION_CQL))\n\t\treturn 0;\n\n\tif (cur_funcmode == DYTC_FUNCTION_CQL) {\n\t\tatomic_inc(&dytc_ignore_event);\n\t\terr = dytc_command(DYTC_DISABLE_CQL, &dummy);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tcmd_err = dytc_command(command,\toutput);\n\t \n\n\tif (cur_funcmode == DYTC_FUNCTION_CQL) {\n\t\terr = dytc_command(DYTC_ENABLE_CQL, &dummy);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn cmd_err;\n}\n\n \nstatic int dytc_profile_set(struct platform_profile_handler *pprof,\n\t\t\t    enum platform_profile_option profile)\n{\n\tint perfmode;\n\tint output;\n\tint err;\n\n\terr = mutex_lock_interruptible(&dytc_mutex);\n\tif (err)\n\t\treturn err;\n\n\terr = convert_profile_to_dytc(profile, &perfmode);\n\tif (err)\n\t\tgoto unlock;\n\n\tif (dytc_capabilities & BIT(DYTC_FC_MMC)) {\n\t\tif (profile == PLATFORM_PROFILE_BALANCED) {\n\t\t\t \n\t\t\terr = dytc_cql_command(DYTC_CMD_RESET, &output);\n\t\t\tif (err)\n\t\t\t\tgoto unlock;\n\t\t} else {\n\t\t\t \n\t\t\terr = dytc_cql_command(DYTC_SET_COMMAND(DYTC_FUNCTION_MMC, perfmode, 1),\n\t\t\t\t\t\t&output);\n\t\t\tif (err)\n\t\t\t\tgoto unlock;\n\t\t}\n\t} else if (dytc_capabilities & BIT(DYTC_FC_PSC)) {\n\t\terr = dytc_command(DYTC_SET_COMMAND(DYTC_FUNCTION_PSC, perfmode, 1), &output);\n\t\tif (err)\n\t\t\tgoto unlock;\n\n\t\t \n\t\tif (dytc_capabilities & BIT(DYTC_FC_AMT))\n\t\t\tdytc_control_amt(profile == PLATFORM_PROFILE_BALANCED);\n\t}\n\t \n\tdytc_current_profile = profile;\nunlock:\n\tmutex_unlock(&dytc_mutex);\n\treturn err;\n}\n\nstatic void dytc_profile_refresh(void)\n{\n\tenum platform_profile_option profile;\n\tint output = 0, err = 0;\n\tint perfmode, funcmode = 0;\n\n\tmutex_lock(&dytc_mutex);\n\tif (dytc_capabilities & BIT(DYTC_FC_MMC)) {\n\t\tif (dytc_mmc_get_available)\n\t\t\terr = dytc_command(DYTC_CMD_MMC_GET, &output);\n\t\telse\n\t\t\terr = dytc_cql_command(DYTC_CMD_GET, &output);\n\t\tfuncmode = DYTC_FUNCTION_MMC;\n\t} else if (dytc_capabilities & BIT(DYTC_FC_PSC)) {\n\t\terr = dytc_command(DYTC_CMD_GET, &output);\n\t\t \n\t\tfuncmode = (output >> DYTC_GET_FUNCTION_BIT) & 0xF;\n\t} else {  \n\t\terr = -ENODEV;\n\t}\n\tmutex_unlock(&dytc_mutex);\n\tif (err)\n\t\treturn;\n\n\tperfmode = (output >> DYTC_GET_MODE_BIT) & 0xF;\n\tconvert_dytc_to_profile(funcmode, perfmode, &profile);\n\tif (profile != dytc_current_profile) {\n\t\tdytc_current_profile = profile;\n\t\tplatform_profile_notify();\n\t}\n}\n\nstatic struct platform_profile_handler dytc_profile = {\n\t.profile_get = dytc_profile_get,\n\t.profile_set = dytc_profile_set,\n};\n\nstatic int tpacpi_dytc_profile_init(struct ibm_init_struct *iibm)\n{\n\tint err, output;\n\n\t \n\tset_bit(PLATFORM_PROFILE_LOW_POWER, dytc_profile.choices);\n\tset_bit(PLATFORM_PROFILE_BALANCED, dytc_profile.choices);\n\tset_bit(PLATFORM_PROFILE_PERFORMANCE, dytc_profile.choices);\n\n\terr = dytc_command(DYTC_CMD_QUERY, &output);\n\tif (err)\n\t\treturn err;\n\n\tif (output & BIT(DYTC_QUERY_ENABLE_BIT))\n\t\tdytc_version = (output >> DYTC_QUERY_REV_BIT) & 0xF;\n\n\t \n\tif (dytc_version < 5)\n\t\treturn -ENODEV;\n\n\t \n\terr = dytc_command(DYTC_CMD_FUNC_CAP, &dytc_capabilities);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (profile_force) {\n\t\tswitch (profile_force) {\n\t\tcase -1:\n\t\t\tdytc_capabilities = 0;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tdytc_capabilities = BIT(DYTC_FC_MMC);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tdytc_capabilities = BIT(DYTC_FC_PSC);\n\t\t\tbreak;\n\t\t}\n\t\tpr_debug(\"Profile selection forced: 0x%x\\n\", dytc_capabilities);\n\t}\n\tif (dytc_capabilities & BIT(DYTC_FC_MMC)) {  \n\t\tpr_debug(\"MMC is supported\\n\");\n\t\t \n\t\tdytc_mmc_get_available = false;\n\t\tif (dytc_version >= 6) {\n\t\t\terr = dytc_command(DYTC_CMD_MMC_GET, &output);\n\t\t\tif (!err && ((output & DYTC_ERR_MASK) == DYTC_ERR_SUCCESS))\n\t\t\t\tdytc_mmc_get_available = true;\n\t\t}\n\t} else if (dytc_capabilities & BIT(DYTC_FC_PSC)) {  \n\t\tpr_debug(\"PSC is supported\\n\");\n\t} else {\n\t\tdbg_printk(TPACPI_DBG_INIT, \"No DYTC support available\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tdbg_printk(TPACPI_DBG_INIT,\n\t\t\t\"DYTC version %d: thermal mode available\\n\", dytc_version);\n\n\t \n\terr = platform_profile_register(&dytc_profile);\n\t \n\tif (err)\n\t\treturn -ENODEV;\n\n\t \n\tdytc_profile_refresh();\n\n\t \n\tif (dytc_capabilities & BIT(DYTC_FC_PSC))\n\t\tdytc_profile_set(NULL, PLATFORM_PROFILE_BALANCED);\n\n\treturn 0;\n}\n\nstatic void dytc_profile_exit(void)\n{\n\tplatform_profile_remove();\n}\n\nstatic struct ibm_struct  dytc_profile_driver_data = {\n\t.name = \"dytc-profile\",\n\t.exit = dytc_profile_exit,\n};\n\n \n\nstruct keyboard_lang_data {\n\tconst char *lang_str;\n\tint lang_code;\n};\n\nstatic const struct keyboard_lang_data keyboard_lang_data[] = {\n\t{\"be\", 0x080c},\n\t{\"cz\", 0x0405},\n\t{\"da\", 0x0406},\n\t{\"de\", 0x0c07},\n\t{\"en\", 0x0000},\n\t{\"es\", 0x2c0a},\n\t{\"et\", 0x0425},\n\t{\"fr\", 0x040c},\n\t{\"fr-ch\", 0x100c},\n\t{\"hu\", 0x040e},\n\t{\"it\", 0x0410},\n\t{\"jp\", 0x0411},\n\t{\"nl\", 0x0413},\n\t{\"nn\", 0x0414},\n\t{\"pl\", 0x0415},\n\t{\"pt\", 0x0816},\n\t{\"sl\", 0x041b},\n\t{\"sv\", 0x081d},\n\t{\"tr\", 0x041f},\n};\n\nstatic int set_keyboard_lang_command(int command)\n{\n\tacpi_handle sskl_handle;\n\tint output;\n\n\tif (ACPI_FAILURE(acpi_get_handle(hkey_handle, \"SSKL\", &sskl_handle))) {\n\t\t \n\t\treturn -ENODEV;\n\t}\n\n\tif (!acpi_evalf(sskl_handle, &output, NULL, \"dd\", command))\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic int get_keyboard_lang(int *output)\n{\n\tacpi_handle gskl_handle;\n\tint kbd_lang;\n\n\tif (ACPI_FAILURE(acpi_get_handle(hkey_handle, \"GSKL\", &gskl_handle))) {\n\t\t \n\t\treturn -ENODEV;\n\t}\n\n\tif (!acpi_evalf(gskl_handle, &kbd_lang, NULL, \"dd\", 0x02000000))\n\t\treturn -EIO;\n\n\t \n\tif (kbd_lang & METHOD_ERR)\n\t\treturn -ENODEV;\n\n\t*output = kbd_lang;\n\n\treturn 0;\n}\n\n \nstatic ssize_t keyboard_lang_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\tint output, err, i, len = 0;\n\n\terr = get_keyboard_lang(&output);\n\tif (err)\n\t\treturn err;\n\n\tfor (i = 0; i < ARRAY_SIZE(keyboard_lang_data); i++) {\n\t\tif (i)\n\t\t\tlen += sysfs_emit_at(buf, len, \"%s\", \" \");\n\n\t\tif (output == keyboard_lang_data[i].lang_code) {\n\t\t\tlen += sysfs_emit_at(buf, len, \"[%s]\", keyboard_lang_data[i].lang_str);\n\t\t} else {\n\t\t\tlen += sysfs_emit_at(buf, len, \"%s\", keyboard_lang_data[i].lang_str);\n\t\t}\n\t}\n\tlen += sysfs_emit_at(buf, len, \"\\n\");\n\n\treturn len;\n}\n\nstatic ssize_t keyboard_lang_store(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tconst char *buf, size_t count)\n{\n\tint err, i;\n\tbool lang_found = false;\n\tint lang_code = 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(keyboard_lang_data); i++) {\n\t\tif (sysfs_streq(buf, keyboard_lang_data[i].lang_str)) {\n\t\t\tlang_code = keyboard_lang_data[i].lang_code;\n\t\t\tlang_found = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (lang_found) {\n\t\tlang_code = lang_code | 1 << 24;\n\n\t\t \n\t\terr = set_keyboard_lang_command(lang_code);\n\t\tif (err)\n\t\t\treturn err;\n\t} else {\n\t\tdev_err(&tpacpi_pdev->dev, \"Unknown Keyboard language. Ignoring\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\ttpacpi_disclose_usertask(attr->attr.name,\n\t\t\t\"keyboard language is set to  %s\\n\", buf);\n\n\tsysfs_notify(&tpacpi_pdev->dev.kobj, NULL, \"keyboard_lang\");\n\n\treturn count;\n}\nstatic DEVICE_ATTR_RW(keyboard_lang);\n\nstatic struct attribute *kbdlang_attributes[] = {\n\t&dev_attr_keyboard_lang.attr,\n\tNULL\n};\n\nstatic umode_t kbdlang_attr_is_visible(struct kobject *kobj,\n\t\t\t\t       struct attribute *attr, int n)\n{\n\treturn tp_features.kbd_lang ? attr->mode : 0;\n}\n\nstatic const struct attribute_group kbdlang_attr_group = {\n\t.is_visible = kbdlang_attr_is_visible,\n\t.attrs = kbdlang_attributes,\n};\n\nstatic int tpacpi_kbdlang_init(struct ibm_init_struct *iibm)\n{\n\tint err, output;\n\n\terr = get_keyboard_lang(&output);\n\ttp_features.kbd_lang = !err;\n\treturn err;\n}\n\nstatic struct ibm_struct kbdlang_driver_data = {\n\t.name = \"kbdlang\",\n};\n\n \n#define DPRC_GET_WWAN_ANTENNA_TYPE      0x40000\n#define DPRC_WWAN_ANTENNA_TYPE_A_BIT    BIT(4)\n#define DPRC_WWAN_ANTENNA_TYPE_B_BIT    BIT(8)\nstatic bool has_antennatype;\nstatic int wwan_antennatype;\n\nstatic int dprc_command(int command, int *output)\n{\n\tacpi_handle dprc_handle;\n\n\tif (ACPI_FAILURE(acpi_get_handle(hkey_handle, \"DPRC\", &dprc_handle))) {\n\t\t \n\t\treturn -ENODEV;\n\t}\n\n\tif (!acpi_evalf(dprc_handle, output, NULL, \"dd\", command))\n\t\treturn -EIO;\n\n\t \n\tif (*output & METHOD_ERR)\n\t\treturn -ENODEV;\n\n\treturn 0;\n}\n\nstatic int get_wwan_antenna(int *wwan_antennatype)\n{\n\tint output, err;\n\n\t \n\terr = dprc_command(DPRC_GET_WWAN_ANTENNA_TYPE, &output);\n\tif (err)\n\t\treturn err;\n\n\tif (output & DPRC_WWAN_ANTENNA_TYPE_A_BIT)\n\t\t*wwan_antennatype = 1;\n\telse if (output & DPRC_WWAN_ANTENNA_TYPE_B_BIT)\n\t\t*wwan_antennatype = 2;\n\telse\n\t\treturn -ENODEV;\n\n\treturn 0;\n}\n\n \nstatic ssize_t wwan_antenna_type_show(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tswitch (wwan_antennatype) {\n\tcase 1:\n\t\treturn sysfs_emit(buf, \"type a\\n\");\n\tcase 2:\n\t\treturn sysfs_emit(buf, \"type b\\n\");\n\tdefault:\n\t\treturn -ENODATA;\n\t}\n}\nstatic DEVICE_ATTR_RO(wwan_antenna_type);\n\nstatic struct attribute *dprc_attributes[] = {\n\t&dev_attr_wwan_antenna_type.attr,\n\tNULL\n};\n\nstatic umode_t dprc_attr_is_visible(struct kobject *kobj,\n\t\t\t\t    struct attribute *attr, int n)\n{\n\treturn has_antennatype ? attr->mode : 0;\n}\n\nstatic const struct attribute_group dprc_attr_group = {\n\t.is_visible = dprc_attr_is_visible,\n\t.attrs = dprc_attributes,\n};\n\nstatic int tpacpi_dprc_init(struct ibm_init_struct *iibm)\n{\n\tint err;\n\n\terr = get_wwan_antenna(&wwan_antennatype);\n\tif (err)\n\t\treturn err;\n\n\thas_antennatype = true;\n\treturn 0;\n}\n\nstatic struct ibm_struct dprc_driver_data = {\n\t.name = \"dprc\",\n};\n\n \n\nstatic struct attribute *tpacpi_driver_attributes[] = {\n\t&driver_attr_debug_level.attr,\n\t&driver_attr_version.attr,\n\t&driver_attr_interface_version.attr,\n#ifdef CONFIG_THINKPAD_ACPI_DEBUGFACILITIES\n\t&driver_attr_wlsw_emulstate.attr,\n\t&driver_attr_bluetooth_emulstate.attr,\n\t&driver_attr_wwan_emulstate.attr,\n\t&driver_attr_uwb_emulstate.attr,\n#endif\n\tNULL\n};\n\n#ifdef CONFIG_THINKPAD_ACPI_DEBUGFACILITIES\nstatic umode_t tpacpi_attr_is_visible(struct kobject *kobj,\n\t\t\t\t      struct attribute *attr, int n)\n{\n\tif (attr == &driver_attr_wlsw_emulstate.attr) {\n\t\tif (!dbg_wlswemul)\n\t\t\treturn 0;\n\t} else if (attr == &driver_attr_bluetooth_emulstate.attr) {\n\t\tif (!dbg_bluetoothemul)\n\t\t\treturn 0;\n\t} else if (attr == &driver_attr_wwan_emulstate.attr) {\n\t\tif (!dbg_wwanemul)\n\t\t\treturn 0;\n\t} else if (attr == &driver_attr_uwb_emulstate.attr) {\n\t\tif (!dbg_uwbemul)\n\t\t\treturn 0;\n\t}\n\n\treturn attr->mode;\n}\n#endif\n\nstatic const struct attribute_group tpacpi_driver_attr_group = {\n#ifdef CONFIG_THINKPAD_ACPI_DEBUGFACILITIES\n\t.is_visible = tpacpi_attr_is_visible,\n#endif\n\t.attrs = tpacpi_driver_attributes,\n};\n\nstatic const struct attribute_group *tpacpi_driver_groups[] = {\n\t&tpacpi_driver_attr_group,\n\tNULL,\n};\n\nstatic const struct attribute_group *tpacpi_groups[] = {\n\t&adaptive_kbd_attr_group,\n\t&hotkey_attr_group,\n\t&bluetooth_attr_group,\n\t&wan_attr_group,\n\t&cmos_attr_group,\n\t&proxsensor_attr_group,\n\t&kbdlang_attr_group,\n\t&dprc_attr_group,\n\tNULL,\n};\n\nstatic const struct attribute_group *tpacpi_hwmon_groups[] = {\n\t&thermal_attr_group,\n\t&temp_label_attr_group,\n\t&fan_attr_group,\n\tNULL,\n};\n\nstatic const struct attribute_group *tpacpi_hwmon_driver_groups[] = {\n\t&fan_driver_attr_group,\n\tNULL,\n};\n\n \n\nstatic struct platform_driver tpacpi_pdriver = {\n\t.driver = {\n\t\t.name = TPACPI_DRVR_NAME,\n\t\t.pm = &tpacpi_pm,\n\t\t.groups = tpacpi_driver_groups,\n\t\t.dev_groups = tpacpi_groups,\n\t},\n\t.shutdown = tpacpi_shutdown_handler,\n};\n\nstatic struct platform_driver tpacpi_hwmon_pdriver = {\n\t.driver = {\n\t\t.name = TPACPI_HWMON_DRVR_NAME,\n\t\t.groups = tpacpi_hwmon_driver_groups,\n\t},\n};\n\n \n\n \nstatic void tpacpi_driver_event(const unsigned int hkey_event)\n{\n\tif (ibm_backlight_device) {\n\t\tswitch (hkey_event) {\n\t\tcase TP_HKEY_EV_BRGHT_UP:\n\t\tcase TP_HKEY_EV_BRGHT_DOWN:\n\t\t\ttpacpi_brightness_notify_change();\n\t\t}\n\t}\n\tif (alsa_card) {\n\t\tswitch (hkey_event) {\n\t\tcase TP_HKEY_EV_VOL_UP:\n\t\tcase TP_HKEY_EV_VOL_DOWN:\n\t\tcase TP_HKEY_EV_VOL_MUTE:\n\t\t\tvolume_alsa_notify_change();\n\t\t}\n\t}\n\tif (tp_features.kbdlight && hkey_event == TP_HKEY_EV_KBD_LIGHT) {\n\t\tenum led_brightness brightness;\n\n\t\tmutex_lock(&kbdlight_mutex);\n\n\t\t \n\t\tbrightness = kbdlight_sysfs_get(NULL);\n\t\tif (kbdlight_brightness != brightness) {\n\t\t\tkbdlight_brightness = brightness;\n\t\t\tled_classdev_notify_brightness_hw_changed(\n\t\t\t\t&tpacpi_led_kbdlight.led_classdev, brightness);\n\t\t}\n\n\t\tmutex_unlock(&kbdlight_mutex);\n\t}\n\n\tif (hkey_event == TP_HKEY_EV_THM_CSM_COMPLETED) {\n\t\tlapsensor_refresh();\n\t\t \n\t\tif (!atomic_add_unless(&dytc_ignore_event, -1, 0))\n\t\t\tdytc_profile_refresh();\n\t}\n\n\tif (lcdshadow_dev && hkey_event == TP_HKEY_EV_PRIVACYGUARD_TOGGLE) {\n\t\tenum drm_privacy_screen_status old_hw_state;\n\t\tbool changed;\n\n\t\tmutex_lock(&lcdshadow_dev->lock);\n\t\told_hw_state = lcdshadow_dev->hw_state;\n\t\tlcdshadow_get_hw_state(lcdshadow_dev);\n\t\tchanged = lcdshadow_dev->hw_state != old_hw_state;\n\t\tmutex_unlock(&lcdshadow_dev->lock);\n\n\t\tif (changed)\n\t\t\tdrm_privacy_screen_call_notifier_chain(lcdshadow_dev);\n\t}\n\tif (hkey_event == TP_HKEY_EV_AMT_TOGGLE) {\n\t\t \n\t\tif (!dytc_amt_active)\n\t\t\t \n\t\t\tdytc_profile_set(NULL, PLATFORM_PROFILE_BALANCED);\n\t\telse\n\t\t\tdytc_control_amt(!dytc_amt_active);\n\t}\n\n}\n\nstatic void hotkey_driver_event(const unsigned int scancode)\n{\n\ttpacpi_driver_event(TP_HKEY_EV_HOTKEY_BASE + scancode);\n}\n\n \n\n \nstatic struct proc_dir_entry *proc_dir;\n\n \n\nstatic bool force_load;\n\n#ifdef CONFIG_THINKPAD_ACPI_DEBUG\nstatic const char * __init str_supported(int is_supported)\n{\n\tstatic char text_unsupported[] __initdata = \"not supported\";\n\n\treturn (is_supported) ? &text_unsupported[4] : &text_unsupported[0];\n}\n#endif  \n\nstatic void ibm_exit(struct ibm_struct *ibm)\n{\n\tdbg_printk(TPACPI_DBG_EXIT, \"removing %s\\n\", ibm->name);\n\n\tlist_del_init(&ibm->all_drivers);\n\n\tif (ibm->flags.acpi_notify_installed) {\n\t\tdbg_printk(TPACPI_DBG_EXIT,\n\t\t\t\"%s: acpi_remove_notify_handler\\n\", ibm->name);\n\t\tBUG_ON(!ibm->acpi);\n\t\tacpi_remove_notify_handler(*ibm->acpi->handle,\n\t\t\t\t\t   ibm->acpi->type,\n\t\t\t\t\t   dispatch_acpi_notify);\n\t\tibm->flags.acpi_notify_installed = 0;\n\t}\n\n\tif (ibm->flags.proc_created) {\n\t\tdbg_printk(TPACPI_DBG_EXIT,\n\t\t\t\"%s: remove_proc_entry\\n\", ibm->name);\n\t\tremove_proc_entry(ibm->name, proc_dir);\n\t\tibm->flags.proc_created = 0;\n\t}\n\n\tif (ibm->flags.acpi_driver_registered) {\n\t\tdbg_printk(TPACPI_DBG_EXIT,\n\t\t\t\"%s: acpi_bus_unregister_driver\\n\", ibm->name);\n\t\tBUG_ON(!ibm->acpi);\n\t\tacpi_bus_unregister_driver(ibm->acpi->driver);\n\t\tkfree(ibm->acpi->driver);\n\t\tibm->acpi->driver = NULL;\n\t\tibm->flags.acpi_driver_registered = 0;\n\t}\n\n\tif (ibm->flags.init_called && ibm->exit) {\n\t\tibm->exit();\n\t\tibm->flags.init_called = 0;\n\t}\n\n\tdbg_printk(TPACPI_DBG_INIT, \"finished removing %s\\n\", ibm->name);\n}\n\nstatic int __init ibm_init(struct ibm_init_struct *iibm)\n{\n\tint ret;\n\tstruct ibm_struct *ibm = iibm->data;\n\tstruct proc_dir_entry *entry;\n\n\tBUG_ON(ibm == NULL);\n\n\tINIT_LIST_HEAD(&ibm->all_drivers);\n\n\tif (ibm->flags.experimental && !experimental)\n\t\treturn 0;\n\n\tdbg_printk(TPACPI_DBG_INIT,\n\t\t\"probing for %s\\n\", ibm->name);\n\n\tif (iibm->init) {\n\t\tret = iibm->init(iibm);\n\t\tif (ret > 0 || ret == -ENODEV)\n\t\t\treturn 0;  \n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tibm->flags.init_called = 1;\n\t}\n\n\tif (ibm->acpi) {\n\t\tif (ibm->acpi->hid) {\n\t\t\tret = register_tpacpi_subdriver(ibm);\n\t\t\tif (ret)\n\t\t\t\tgoto err_out;\n\t\t}\n\n\t\tif (ibm->acpi->notify) {\n\t\t\tret = setup_acpi_notify(ibm);\n\t\t\tif (ret == -ENODEV) {\n\t\t\t\tpr_notice(\"disabling subdriver %s\\n\",\n\t\t\t\t\t  ibm->name);\n\t\t\t\tret = 0;\n\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t\tif (ret < 0)\n\t\t\t\tgoto err_out;\n\t\t}\n\t}\n\n\tdbg_printk(TPACPI_DBG_INIT,\n\t\t\"%s installed\\n\", ibm->name);\n\n\tif (ibm->read) {\n\t\tumode_t mode = iibm->base_procfs_mode;\n\n\t\tif (!mode)\n\t\t\tmode = S_IRUGO;\n\t\tif (ibm->write)\n\t\t\tmode |= S_IWUSR;\n\t\tentry = proc_create_data(ibm->name, mode, proc_dir,\n\t\t\t\t\t &dispatch_proc_ops, ibm);\n\t\tif (!entry) {\n\t\t\tpr_err(\"unable to create proc entry %s\\n\", ibm->name);\n\t\t\tret = -ENODEV;\n\t\t\tgoto err_out;\n\t\t}\n\t\tibm->flags.proc_created = 1;\n\t}\n\n\tlist_add_tail(&ibm->all_drivers, &tpacpi_all_drivers);\n\n\treturn 0;\n\nerr_out:\n\tdbg_printk(TPACPI_DBG_INIT,\n\t\t\"%s: at error exit path with result %d\\n\",\n\t\tibm->name, ret);\n\n\tibm_exit(ibm);\n\treturn (ret < 0) ? ret : 0;\n}\n\n \n\nstatic char __init tpacpi_parse_fw_id(const char * const s,\n\t\t\t\t      u32 *model, u16 *release)\n{\n\tint i;\n\n\tif (!s || strlen(s) < 8)\n\t\tgoto invalid;\n\n\tfor (i = 0; i < 8; i++)\n\t\tif (!((s[i] >= '0' && s[i] <= '9') ||\n\t\t      (s[i] >= 'A' && s[i] <= 'Z')))\n\t\t\tgoto invalid;\n\n\t \n\tif (s[3] == 'T' || s[3] == 'N') {\n\t\t*model = TPID(s[0], s[1]);\n\t\t*release = TPVER(s[4], s[5]);\n\t\treturn s[2];\n\n\t \n\t} else if (s[4] == 'T' || s[4] == 'N') {\n\t\t*model = TPID3(s[0], s[1], s[2]);\n\t\t*release = TPVER(s[5], s[6]);\n\t\treturn s[3];\n\t}\n\ninvalid:\n\treturn '\\0';\n}\n\nstatic void find_new_ec_fwstr(const struct dmi_header *dm, void *private)\n{\n\tchar *ec_fw_string = (char *) private;\n\tconst char *dmi_data = (const char *)dm;\n\t \n\n\t \n\tif (dm->type != 140 || dm->length < 0x0F ||\n\tmemcmp(dmi_data + 4, \"LENOVO\", 6) != 0 ||\n\tdmi_data[0x0A] != 0x0B || dmi_data[0x0B] != 0x07 ||\n\tdmi_data[0x0C] != 0x01)\n\t\treturn;\n\n\t \n\tstrncpy(ec_fw_string, dmi_data + 0x0F, 8);\n}\n\n \nstatic int __must_check __init get_thinkpad_model_data(\n\t\t\t\t\t\tstruct thinkpad_id_data *tp)\n{\n\tconst struct dmi_device *dev = NULL;\n\tchar ec_fw_string[18] = {0};\n\tchar const *s;\n\tchar t;\n\n\tif (!tp)\n\t\treturn -EINVAL;\n\n\tmemset(tp, 0, sizeof(*tp));\n\n\tif (dmi_name_in_vendors(\"IBM\"))\n\t\ttp->vendor = PCI_VENDOR_ID_IBM;\n\telse if (dmi_name_in_vendors(\"LENOVO\"))\n\t\ttp->vendor = PCI_VENDOR_ID_LENOVO;\n\telse\n\t\treturn 0;\n\n\ts = dmi_get_system_info(DMI_BIOS_VERSION);\n\ttp->bios_version_str = kstrdup(s, GFP_KERNEL);\n\tif (s && !tp->bios_version_str)\n\t\treturn -ENOMEM;\n\n\t \n\tt = tpacpi_parse_fw_id(tp->bios_version_str,\n\t\t\t       &tp->bios_model, &tp->bios_release);\n\tif (t != 'E' && t != 'C')\n\t\treturn 0;\n\n\t \n\twhile ((dev = dmi_find_device(DMI_DEV_TYPE_OEM_STRING, NULL, dev))) {\n\t\tif (sscanf(dev->name,\n\t\t\t   \"IBM ThinkPad Embedded Controller -[%17c\",\n\t\t\t   ec_fw_string) == 1) {\n\t\t\tec_fw_string[sizeof(ec_fw_string) - 1] = 0;\n\t\t\tec_fw_string[strcspn(ec_fw_string, \" ]\")] = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (!ec_fw_string[0])\n\t\tdmi_walk(find_new_ec_fwstr, &ec_fw_string);\n\n\tif (ec_fw_string[0]) {\n\t\ttp->ec_version_str = kstrdup(ec_fw_string, GFP_KERNEL);\n\t\tif (!tp->ec_version_str)\n\t\t\treturn -ENOMEM;\n\n\t\tt = tpacpi_parse_fw_id(ec_fw_string,\n\t\t\t &tp->ec_model, &tp->ec_release);\n\t\tif (t != 'H') {\n\t\t\tpr_notice(\"ThinkPad firmware release %s doesn't match the known patterns\\n\",\n\t\t\t\t  ec_fw_string);\n\t\t\tpr_notice(\"please report this to %s\\n\", TPACPI_MAIL);\n\t\t}\n\t}\n\n\ts = dmi_get_system_info(DMI_PRODUCT_VERSION);\n\tif (s && !(strncasecmp(s, \"ThinkPad\", 8) && strncasecmp(s, \"Lenovo\", 6))) {\n\t\ttp->model_str = kstrdup(s, GFP_KERNEL);\n\t\tif (!tp->model_str)\n\t\t\treturn -ENOMEM;\n\t} else {\n\t\ts = dmi_get_system_info(DMI_BIOS_VENDOR);\n\t\tif (s && !(strncasecmp(s, \"Lenovo\", 6))) {\n\t\t\ttp->model_str = kstrdup(s, GFP_KERNEL);\n\t\t\tif (!tp->model_str)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\ts = dmi_get_system_info(DMI_PRODUCT_NAME);\n\ttp->nummodel_str = kstrdup(s, GFP_KERNEL);\n\tif (s && !tp->nummodel_str)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic int __init probe_for_thinkpad(void)\n{\n\tint is_thinkpad;\n\n\tif (acpi_disabled)\n\t\treturn -ENODEV;\n\n\t \n\tif (!tpacpi_is_ibm() && !tpacpi_is_lenovo())\n\t\treturn -ENODEV;\n\n\t \n\tis_thinkpad = (thinkpad_id.model_str != NULL) ||\n\t\t      (thinkpad_id.ec_model != 0) ||\n\t\t      tpacpi_is_fw_known();\n\n\t \n\ttpacpi_acpi_handle_locate(\"ec\", TPACPI_ACPI_EC_HID, &ec_handle);\n\tif (!ec_handle) {\n\t\tif (is_thinkpad)\n\t\t\tpr_err(\"Not yet supported ThinkPad detected!\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (!is_thinkpad && !force_load)\n\t\treturn -ENODEV;\n\n\treturn 0;\n}\n\nstatic void __init thinkpad_acpi_init_banner(void)\n{\n\tpr_info(\"%s v%s\\n\", TPACPI_DESC, TPACPI_VERSION);\n\tpr_info(\"%s\\n\", TPACPI_URL);\n\n\tpr_info(\"ThinkPad BIOS %s, EC %s\\n\",\n\t\t(thinkpad_id.bios_version_str) ?\n\t\t\tthinkpad_id.bios_version_str : \"unknown\",\n\t\t(thinkpad_id.ec_version_str) ?\n\t\t\tthinkpad_id.ec_version_str : \"unknown\");\n\n\tBUG_ON(!thinkpad_id.vendor);\n\n\tif (thinkpad_id.model_str)\n\t\tpr_info(\"%s %s, model %s\\n\",\n\t\t\t(thinkpad_id.vendor == PCI_VENDOR_ID_IBM) ?\n\t\t\t\t\"IBM\" : ((thinkpad_id.vendor ==\n\t\t\t\t\t\tPCI_VENDOR_ID_LENOVO) ?\n\t\t\t\t\t\"Lenovo\" : \"Unknown vendor\"),\n\t\t\tthinkpad_id.model_str,\n\t\t\t(thinkpad_id.nummodel_str) ?\n\t\t\t\tthinkpad_id.nummodel_str : \"unknown\");\n}\n\n \n\nstatic struct ibm_init_struct ibms_init[] __initdata = {\n\t{\n\t\t.data = &thinkpad_acpi_driver_data,\n\t},\n\t{\n\t\t.init = hotkey_init,\n\t\t.data = &hotkey_driver_data,\n\t},\n\t{\n\t\t.init = bluetooth_init,\n\t\t.data = &bluetooth_driver_data,\n\t},\n\t{\n\t\t.init = wan_init,\n\t\t.data = &wan_driver_data,\n\t},\n\t{\n\t\t.init = uwb_init,\n\t\t.data = &uwb_driver_data,\n\t},\n#ifdef CONFIG_THINKPAD_ACPI_VIDEO\n\t{\n\t\t.init = video_init,\n\t\t.base_procfs_mode = S_IRUSR,\n\t\t.data = &video_driver_data,\n\t},\n#endif\n\t{\n\t\t.init = kbdlight_init,\n\t\t.data = &kbdlight_driver_data,\n\t},\n\t{\n\t\t.init = light_init,\n\t\t.data = &light_driver_data,\n\t},\n\t{\n\t\t.init = cmos_init,\n\t\t.data = &cmos_driver_data,\n\t},\n\t{\n\t\t.init = led_init,\n\t\t.data = &led_driver_data,\n\t},\n\t{\n\t\t.init = beep_init,\n\t\t.data = &beep_driver_data,\n\t},\n\t{\n\t\t.init = thermal_init,\n\t\t.data = &thermal_driver_data,\n\t},\n\t{\n\t\t.init = brightness_init,\n\t\t.data = &brightness_driver_data,\n\t},\n\t{\n\t\t.init = volume_init,\n\t\t.data = &volume_driver_data,\n\t},\n\t{\n\t\t.init = fan_init,\n\t\t.data = &fan_driver_data,\n\t},\n\t{\n\t\t.init = mute_led_init,\n\t\t.data = &mute_led_driver_data,\n\t},\n\t{\n\t\t.init = tpacpi_battery_init,\n\t\t.data = &battery_driver_data,\n\t},\n\t{\n\t\t.init = tpacpi_lcdshadow_init,\n\t\t.data = &lcdshadow_driver_data,\n\t},\n\t{\n\t\t.init = tpacpi_proxsensor_init,\n\t\t.data = &proxsensor_driver_data,\n\t},\n\t{\n\t\t.init = tpacpi_dytc_profile_init,\n\t\t.data = &dytc_profile_driver_data,\n\t},\n\t{\n\t\t.init = tpacpi_kbdlang_init,\n\t\t.data = &kbdlang_driver_data,\n\t},\n\t{\n\t\t.init = tpacpi_dprc_init,\n\t\t.data = &dprc_driver_data,\n\t},\n};\n\nstatic int __init set_ibm_param(const char *val, const struct kernel_param *kp)\n{\n\tunsigned int i;\n\tstruct ibm_struct *ibm;\n\n\tif (!kp || !kp->name || !val)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < ARRAY_SIZE(ibms_init); i++) {\n\t\tibm = ibms_init[i].data;\n\t\tif (!ibm || !ibm->name)\n\t\t\tcontinue;\n\n\t\tif (strcmp(ibm->name, kp->name) == 0 && ibm->write) {\n\t\t\tif (strlen(val) > sizeof(ibms_init[i].param) - 1)\n\t\t\t\treturn -ENOSPC;\n\t\t\tstrcpy(ibms_init[i].param, val);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\nmodule_param(experimental, int, 0444);\nMODULE_PARM_DESC(experimental,\n\t\t \"Enables experimental features when non-zero\");\n\nmodule_param_named(debug, dbg_level, uint, 0);\nMODULE_PARM_DESC(debug, \"Sets debug level bit-mask\");\n\nmodule_param(force_load, bool, 0444);\nMODULE_PARM_DESC(force_load,\n\t\t \"Attempts to load the driver even on a mis-identified ThinkPad when true\");\n\nmodule_param_named(fan_control, fan_control_allowed, bool, 0444);\nMODULE_PARM_DESC(fan_control,\n\t\t \"Enables setting fan parameters features when true\");\n\nmodule_param_named(brightness_mode, brightness_mode, uint, 0444);\nMODULE_PARM_DESC(brightness_mode,\n\t\t \"Selects brightness control strategy: 0=auto, 1=EC, 2=UCMS, 3=EC+NVRAM\");\n\nmodule_param(brightness_enable, uint, 0444);\nMODULE_PARM_DESC(brightness_enable,\n\t\t \"Enables backlight control when 1, disables when 0\");\n\n#ifdef CONFIG_THINKPAD_ACPI_ALSA_SUPPORT\nmodule_param_named(volume_mode, volume_mode, uint, 0444);\nMODULE_PARM_DESC(volume_mode,\n\t\t \"Selects volume control strategy: 0=auto, 1=EC, 2=N/A, 3=EC+NVRAM\");\n\nmodule_param_named(volume_capabilities, volume_capabilities, uint, 0444);\nMODULE_PARM_DESC(volume_capabilities,\n\t\t \"Selects the mixer capabilities: 0=auto, 1=volume and mute, 2=mute only\");\n\nmodule_param_named(volume_control, volume_control_allowed, bool, 0444);\nMODULE_PARM_DESC(volume_control,\n\t\t \"Enables software override for the console audio control when true\");\n\nmodule_param_named(software_mute, software_mute_requested, bool, 0444);\nMODULE_PARM_DESC(software_mute,\n\t\t \"Request full software mute control\");\n\n \nmodule_param_named(index, alsa_index, int, 0444);\nMODULE_PARM_DESC(index, \"ALSA index for the ACPI EC Mixer\");\nmodule_param_named(id, alsa_id, charp, 0444);\nMODULE_PARM_DESC(id, \"ALSA id for the ACPI EC Mixer\");\nmodule_param_named(enable, alsa_enable, bool, 0444);\nMODULE_PARM_DESC(enable, \"Enable the ALSA interface for the ACPI EC Mixer\");\n#endif  \n\n \n#define TPACPI_PARAM(feature) \\\n\tmodule_param_call(feature, set_ibm_param, NULL, NULL, 0); \\\n\tMODULE_PARM_DESC(feature, \"Simulates thinkpad-acpi procfs command at module load, see documentation\")\n\nTPACPI_PARAM(hotkey);\nTPACPI_PARAM(bluetooth);\nTPACPI_PARAM(video);\nTPACPI_PARAM(light);\nTPACPI_PARAM(cmos);\nTPACPI_PARAM(led);\nTPACPI_PARAM(beep);\nTPACPI_PARAM(brightness);\nTPACPI_PARAM(volume);\nTPACPI_PARAM(fan);\n\n#ifdef CONFIG_THINKPAD_ACPI_DEBUGFACILITIES\nmodule_param(dbg_wlswemul, uint, 0444);\nMODULE_PARM_DESC(dbg_wlswemul, \"Enables WLSW emulation\");\nmodule_param_named(wlsw_state, tpacpi_wlsw_emulstate, bool, 0);\nMODULE_PARM_DESC(wlsw_state,\n\t\t \"Initial state of the emulated WLSW switch\");\n\nmodule_param(dbg_bluetoothemul, uint, 0444);\nMODULE_PARM_DESC(dbg_bluetoothemul, \"Enables bluetooth switch emulation\");\nmodule_param_named(bluetooth_state, tpacpi_bluetooth_emulstate, bool, 0);\nMODULE_PARM_DESC(bluetooth_state,\n\t\t \"Initial state of the emulated bluetooth switch\");\n\nmodule_param(dbg_wwanemul, uint, 0444);\nMODULE_PARM_DESC(dbg_wwanemul, \"Enables WWAN switch emulation\");\nmodule_param_named(wwan_state, tpacpi_wwan_emulstate, bool, 0);\nMODULE_PARM_DESC(wwan_state,\n\t\t \"Initial state of the emulated WWAN switch\");\n\nmodule_param(dbg_uwbemul, uint, 0444);\nMODULE_PARM_DESC(dbg_uwbemul, \"Enables UWB switch emulation\");\nmodule_param_named(uwb_state, tpacpi_uwb_emulstate, bool, 0);\nMODULE_PARM_DESC(uwb_state,\n\t\t \"Initial state of the emulated UWB switch\");\n#endif\n\nmodule_param(profile_force, int, 0444);\nMODULE_PARM_DESC(profile_force, \"Force profile mode. -1=off, 1=MMC, 2=PSC\");\n\nstatic void thinkpad_acpi_module_exit(void)\n{\n\tstruct ibm_struct *ibm, *itmp;\n\n\ttpacpi_lifecycle = TPACPI_LIFE_EXITING;\n\n\tif (tpacpi_hwmon)\n\t\thwmon_device_unregister(tpacpi_hwmon);\n\tif (tp_features.sensors_pdrv_registered)\n\t\tplatform_driver_unregister(&tpacpi_hwmon_pdriver);\n\tif (tp_features.platform_drv_registered)\n\t\tplatform_driver_unregister(&tpacpi_pdriver);\n\n\tlist_for_each_entry_safe_reverse(ibm, itmp,\n\t\t\t\t\t &tpacpi_all_drivers,\n\t\t\t\t\t all_drivers) {\n\t\tibm_exit(ibm);\n\t}\n\n\tdbg_printk(TPACPI_DBG_INIT, \"finished subdriver exit path...\\n\");\n\n\tif (tpacpi_inputdev) {\n\t\tif (tp_features.input_device_registered)\n\t\t\tinput_unregister_device(tpacpi_inputdev);\n\t\telse\n\t\t\tinput_free_device(tpacpi_inputdev);\n\t\tkfree(hotkey_keycode_map);\n\t}\n\n\tif (tpacpi_sensors_pdev)\n\t\tplatform_device_unregister(tpacpi_sensors_pdev);\n\tif (tpacpi_pdev)\n\t\tplatform_device_unregister(tpacpi_pdev);\n\tif (proc_dir)\n\t\tremove_proc_entry(TPACPI_PROC_DIR, acpi_root_dir);\n\tif (tpacpi_wq)\n\t\tdestroy_workqueue(tpacpi_wq);\n\n\tkfree(thinkpad_id.bios_version_str);\n\tkfree(thinkpad_id.ec_version_str);\n\tkfree(thinkpad_id.model_str);\n\tkfree(thinkpad_id.nummodel_str);\n}\n\n\nstatic int __init thinkpad_acpi_module_init(void)\n{\n\tconst struct dmi_system_id *dmi_id;\n\tint ret, i;\n\tacpi_object_type obj_type;\n\n\ttpacpi_lifecycle = TPACPI_LIFE_INIT;\n\n\t \n\n\tret = get_thinkpad_model_data(&thinkpad_id);\n\tif (ret) {\n\t\tpr_err(\"unable to get DMI data: %d\\n\", ret);\n\t\tthinkpad_acpi_module_exit();\n\t\treturn ret;\n\t}\n\tret = probe_for_thinkpad();\n\tif (ret) {\n\t\tthinkpad_acpi_module_exit();\n\t\treturn ret;\n\t}\n\n\t \n\n\tthinkpad_acpi_init_banner();\n\ttpacpi_check_outdated_fw();\n\n\tTPACPI_ACPIHANDLE_INIT(ecrd);\n\tTPACPI_ACPIHANDLE_INIT(ecwr);\n\n\t \n\tif (ecrd_handle) {\n\t\tacpi_get_type(ecrd_handle, &obj_type);\n\t\tif (obj_type != ACPI_TYPE_METHOD)\n\t\t\tecrd_handle = NULL;\n\t}\n\tif (ecwr_handle) {\n\t\tacpi_get_type(ecwr_handle, &obj_type);\n\t\tif (obj_type != ACPI_TYPE_METHOD)\n\t\t\tecwr_handle = NULL;\n\t}\n\n\ttpacpi_wq = create_singlethread_workqueue(TPACPI_WORKQUEUE_NAME);\n\tif (!tpacpi_wq) {\n\t\tthinkpad_acpi_module_exit();\n\t\treturn -ENOMEM;\n\t}\n\n\tproc_dir = proc_mkdir(TPACPI_PROC_DIR, acpi_root_dir);\n\tif (!proc_dir) {\n\t\tpr_err(\"unable to create proc dir \" TPACPI_PROC_DIR \"\\n\");\n\t\tthinkpad_acpi_module_exit();\n\t\treturn -ENODEV;\n\t}\n\n\tdmi_id = dmi_first_match(fwbug_list);\n\tif (dmi_id)\n\t\ttp_features.quirks = dmi_id->driver_data;\n\n\t \n\ttpacpi_pdev = platform_device_register_simple(TPACPI_DRVR_NAME, PLATFORM_DEVID_NONE,\n\t\t\t\t\t\t\tNULL, 0);\n\tif (IS_ERR(tpacpi_pdev)) {\n\t\tret = PTR_ERR(tpacpi_pdev);\n\t\ttpacpi_pdev = NULL;\n\t\tpr_err(\"unable to register platform device\\n\");\n\t\tthinkpad_acpi_module_exit();\n\t\treturn ret;\n\t}\n\ttpacpi_sensors_pdev = platform_device_register_simple(\n\t\t\t\t\t\tTPACPI_HWMON_DRVR_NAME,\n\t\t\t\t\t\tPLATFORM_DEVID_NONE, NULL, 0);\n\tif (IS_ERR(tpacpi_sensors_pdev)) {\n\t\tret = PTR_ERR(tpacpi_sensors_pdev);\n\t\ttpacpi_sensors_pdev = NULL;\n\t\tpr_err(\"unable to register hwmon platform device\\n\");\n\t\tthinkpad_acpi_module_exit();\n\t\treturn ret;\n\t}\n\n\tmutex_init(&tpacpi_inputdev_send_mutex);\n\ttpacpi_inputdev = input_allocate_device();\n\tif (!tpacpi_inputdev) {\n\t\tthinkpad_acpi_module_exit();\n\t\treturn -ENOMEM;\n\t} else {\n\t\t \n\t\ttpacpi_inputdev->name = \"ThinkPad Extra Buttons\";\n\t\ttpacpi_inputdev->phys = TPACPI_DRVR_NAME \"/input0\";\n\t\ttpacpi_inputdev->id.bustype = BUS_HOST;\n\t\ttpacpi_inputdev->id.vendor = thinkpad_id.vendor;\n\t\ttpacpi_inputdev->id.product = TPACPI_HKEY_INPUT_PRODUCT;\n\t\ttpacpi_inputdev->id.version = TPACPI_HKEY_INPUT_VERSION;\n\t\ttpacpi_inputdev->dev.parent = &tpacpi_pdev->dev;\n\t}\n\n\t \n\ttpacpi_detect_brightness_capabilities();\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(ibms_init); i++) {\n\t\tret = ibm_init(&ibms_init[i]);\n\t\tif (ret >= 0 && *ibms_init[i].param)\n\t\t\tret = ibms_init[i].data->write(ibms_init[i].param);\n\t\tif (ret < 0) {\n\t\t\tthinkpad_acpi_module_exit();\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\ttpacpi_lifecycle = TPACPI_LIFE_RUNNING;\n\n\tret = platform_driver_register(&tpacpi_pdriver);\n\tif (ret) {\n\t\tpr_err(\"unable to register main platform driver\\n\");\n\t\tthinkpad_acpi_module_exit();\n\t\treturn ret;\n\t}\n\ttp_features.platform_drv_registered = 1;\n\n\tret = platform_driver_register(&tpacpi_hwmon_pdriver);\n\tif (ret) {\n\t\tpr_err(\"unable to register hwmon platform driver\\n\");\n\t\tthinkpad_acpi_module_exit();\n\t\treturn ret;\n\t}\n\ttp_features.sensors_pdrv_registered = 1;\n\n\ttpacpi_hwmon = hwmon_device_register_with_groups(\n\t\t&tpacpi_sensors_pdev->dev, TPACPI_NAME, NULL, tpacpi_hwmon_groups);\n\tif (IS_ERR(tpacpi_hwmon)) {\n\t\tret = PTR_ERR(tpacpi_hwmon);\n\t\ttpacpi_hwmon = NULL;\n\t\tpr_err(\"unable to register hwmon device\\n\");\n\t\tthinkpad_acpi_module_exit();\n\t\treturn ret;\n\t}\n\n\tret = input_register_device(tpacpi_inputdev);\n\tif (ret < 0) {\n\t\tpr_err(\"unable to register input device\\n\");\n\t\tthinkpad_acpi_module_exit();\n\t\treturn ret;\n\t} else {\n\t\ttp_features.input_device_registered = 1;\n\t}\n\n\treturn 0;\n}\n\nMODULE_ALIAS(TPACPI_DRVR_SHORTNAME);\n\n \nMODULE_DEVICE_TABLE(acpi, ibm_htk_device_ids);\n\n \n#define IBM_BIOS_MODULE_ALIAS(__type) \\\n\tMODULE_ALIAS(\"dmi:bvnIBM:bvr\" __type \"ET??WW*\")\n\n \nIBM_BIOS_MODULE_ALIAS(\"I[MU]\");\t\t \n\nMODULE_AUTHOR(\"Borislav Deianov <borislav@users.sf.net>\");\nMODULE_AUTHOR(\"Henrique de Moraes Holschuh <hmh@hmh.eng.br>\");\nMODULE_DESCRIPTION(TPACPI_DESC);\nMODULE_VERSION(TPACPI_VERSION);\nMODULE_LICENSE(\"GPL\");\n\nmodule_init(thinkpad_acpi_module_init);\nmodule_exit(thinkpad_acpi_module_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}