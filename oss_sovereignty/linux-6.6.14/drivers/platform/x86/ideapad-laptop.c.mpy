{
  "module_name": "ideapad-laptop.c",
  "hash_id": "60eaedef3ee0c22f2359ff53e5bcff3570bbe773dee1ad5cada37994fe1c7d7f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/x86/ideapad-laptop.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/acpi.h>\n#include <linux/backlight.h>\n#include <linux/bitfield.h>\n#include <linux/bitops.h>\n#include <linux/bug.h>\n#include <linux/debugfs.h>\n#include <linux/device.h>\n#include <linux/dmi.h>\n#include <linux/fb.h>\n#include <linux/i8042.h>\n#include <linux/init.h>\n#include <linux/input.h>\n#include <linux/input/sparse-keymap.h>\n#include <linux/kernel.h>\n#include <linux/leds.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/platform_profile.h>\n#include <linux/rfkill.h>\n#include <linux/seq_file.h>\n#include <linux/sysfs.h>\n#include <linux/types.h>\n#include <linux/wmi.h>\n#include \"ideapad-laptop.h\"\n\n#include <acpi/video.h>\n\n#include <dt-bindings/leds/common.h>\n\n#define IDEAPAD_RFKILL_DEV_NUM\t3\n\nenum {\n\tCFG_CAP_BT_BIT       = 16,\n\tCFG_CAP_3G_BIT       = 17,\n\tCFG_CAP_WIFI_BIT     = 18,\n\tCFG_CAP_CAM_BIT      = 19,\n\n\t \n\tCFG_OSD_NUMLK_BIT    = 27,\n\tCFG_OSD_CAPSLK_BIT   = 28,\n\tCFG_OSD_MICMUTE_BIT  = 29,\n\tCFG_OSD_TOUCHPAD_BIT = 30,\n\tCFG_OSD_CAM_BIT      = 31,\n};\n\nenum {\n\tGBMD_CONSERVATION_STATE_BIT = 5,\n};\n\nenum {\n\tSBMC_CONSERVATION_ON  = 3,\n\tSBMC_CONSERVATION_OFF = 5,\n};\n\nenum {\n\tHALS_KBD_BL_SUPPORT_BIT       = 4,\n\tHALS_KBD_BL_STATE_BIT         = 5,\n\tHALS_USB_CHARGING_SUPPORT_BIT = 6,\n\tHALS_USB_CHARGING_STATE_BIT   = 7,\n\tHALS_FNLOCK_SUPPORT_BIT       = 9,\n\tHALS_FNLOCK_STATE_BIT         = 10,\n\tHALS_HOTKEYS_PRIMARY_BIT      = 11,\n};\n\nenum {\n\tSALS_KBD_BL_ON        = 0x8,\n\tSALS_KBD_BL_OFF       = 0x9,\n\tSALS_USB_CHARGING_ON  = 0xa,\n\tSALS_USB_CHARGING_OFF = 0xb,\n\tSALS_FNLOCK_ON        = 0xe,\n\tSALS_FNLOCK_OFF       = 0xf,\n};\n\n \nenum {\n\tKBD_BL_STANDARD      = 1,\n\tKBD_BL_TRISTATE      = 2,\n\tKBD_BL_TRISTATE_AUTO = 3,\n};\n\n#define KBD_BL_QUERY_TYPE\t\t0x1\n#define KBD_BL_TRISTATE_TYPE\t\t0x5\n#define KBD_BL_TRISTATE_AUTO_TYPE\t0x7\n\n#define KBD_BL_COMMAND_GET\t\t0x2\n#define KBD_BL_COMMAND_SET\t\t0x3\n#define KBD_BL_COMMAND_TYPE\t\tGENMASK(7, 4)\n\n#define KBD_BL_GET_BRIGHTNESS\t\tGENMASK(15, 1)\n#define KBD_BL_SET_BRIGHTNESS\t\tGENMASK(19, 16)\n\n#define KBD_BL_KBLC_CHANGED_EVENT\t12\n\nstruct ideapad_dytc_priv {\n\tenum platform_profile_option current_profile;\n\tstruct platform_profile_handler pprof;\n\tstruct mutex mutex;  \n\tstruct ideapad_private *priv;\n};\n\nstruct ideapad_rfk_priv {\n\tint dev;\n\tstruct ideapad_private *priv;\n};\n\nstruct ideapad_private {\n\tstruct acpi_device *adev;\n\tstruct rfkill *rfk[IDEAPAD_RFKILL_DEV_NUM];\n\tstruct ideapad_rfk_priv rfk_priv[IDEAPAD_RFKILL_DEV_NUM];\n\tstruct platform_device *platform_device;\n\tstruct input_dev *inputdev;\n\tstruct backlight_device *blightdev;\n\tstruct ideapad_dytc_priv *dytc;\n\tstruct dentry *debug;\n\tunsigned long cfg;\n\tunsigned long r_touchpad_val;\n\tstruct {\n\t\tbool conservation_mode    : 1;\n\t\tbool dytc                 : 1;\n\t\tbool fan_mode             : 1;\n\t\tbool fn_lock              : 1;\n\t\tbool set_fn_lock_led      : 1;\n\t\tbool hw_rfkill_switch     : 1;\n\t\tbool kbd_bl               : 1;\n\t\tbool touchpad_ctrl_via_ec : 1;\n\t\tbool ctrl_ps2_aux_port    : 1;\n\t\tbool usb_charging         : 1;\n\t} features;\n\tstruct {\n\t\tbool initialized;\n\t\tint type;\n\t\tstruct led_classdev led;\n\t\tunsigned int last_brightness;\n\t} kbd_bl;\n};\n\nstatic bool no_bt_rfkill;\nmodule_param(no_bt_rfkill, bool, 0444);\nMODULE_PARM_DESC(no_bt_rfkill, \"No rfkill for bluetooth.\");\n\nstatic bool allow_v4_dytc;\nmodule_param(allow_v4_dytc, bool, 0444);\nMODULE_PARM_DESC(allow_v4_dytc,\n\t\"Enable DYTC version 4 platform-profile support. \"\n\t\"If you need this please report this to: platform-driver-x86@vger.kernel.org\");\n\nstatic bool hw_rfkill_switch;\nmodule_param(hw_rfkill_switch, bool, 0444);\nMODULE_PARM_DESC(hw_rfkill_switch,\n\t\"Enable rfkill support for laptops with a hw on/off wifi switch/slider. \"\n\t\"If you need this please report this to: platform-driver-x86@vger.kernel.org\");\n\nstatic bool set_fn_lock_led;\nmodule_param(set_fn_lock_led, bool, 0444);\nMODULE_PARM_DESC(set_fn_lock_led,\n\t\"Enable driver based updates of the fn-lock LED on fn-lock changes. \"\n\t\"If you need this please report this to: platform-driver-x86@vger.kernel.org\");\n\nstatic bool ctrl_ps2_aux_port;\nmodule_param(ctrl_ps2_aux_port, bool, 0444);\nMODULE_PARM_DESC(ctrl_ps2_aux_port,\n\t\"Enable driver based PS/2 aux port en-/dis-abling on touchpad on/off toggle. \"\n\t\"If you need this please report this to: platform-driver-x86@vger.kernel.org\");\n\nstatic bool touchpad_ctrl_via_ec;\nmodule_param(touchpad_ctrl_via_ec, bool, 0444);\nMODULE_PARM_DESC(touchpad_ctrl_via_ec,\n\t\"Enable registering a 'touchpad' sysfs-attribute which can be used to manually \"\n\t\"tell the EC to enable/disable the touchpad. This may not work on all models.\");\n\n \n\nstatic struct ideapad_private *ideapad_shared;\nstatic DEFINE_MUTEX(ideapad_shared_mutex);\n\nstatic int ideapad_shared_init(struct ideapad_private *priv)\n{\n\tint ret;\n\n\tmutex_lock(&ideapad_shared_mutex);\n\n\tif (!ideapad_shared) {\n\t\tideapad_shared = priv;\n\t\tret = 0;\n\t} else {\n\t\tdev_warn(&priv->adev->dev, \"found multiple platform devices\\n\");\n\t\tret = -EINVAL;\n\t}\n\n\tmutex_unlock(&ideapad_shared_mutex);\n\n\treturn ret;\n}\n\nstatic void ideapad_shared_exit(struct ideapad_private *priv)\n{\n\tmutex_lock(&ideapad_shared_mutex);\n\n\tif (ideapad_shared == priv)\n\t\tideapad_shared = NULL;\n\n\tmutex_unlock(&ideapad_shared_mutex);\n}\n\n \n\nstatic int eval_int(acpi_handle handle, const char *name, unsigned long *res)\n{\n\tunsigned long long result;\n\tacpi_status status;\n\n\tstatus = acpi_evaluate_integer(handle, (char *)name, NULL, &result);\n\tif (ACPI_FAILURE(status))\n\t\treturn -EIO;\n\n\t*res = result;\n\n\treturn 0;\n}\n\nstatic int exec_simple_method(acpi_handle handle, const char *name, unsigned long arg)\n{\n\tacpi_status status = acpi_execute_simple_method(handle, (char *)name, arg);\n\n\treturn ACPI_FAILURE(status) ? -EIO : 0;\n}\n\nstatic int eval_gbmd(acpi_handle handle, unsigned long *res)\n{\n\treturn eval_int(handle, \"GBMD\", res);\n}\n\nstatic int exec_sbmc(acpi_handle handle, unsigned long arg)\n{\n\treturn exec_simple_method(handle, \"SBMC\", arg);\n}\n\nstatic int eval_hals(acpi_handle handle, unsigned long *res)\n{\n\treturn eval_int(handle, \"HALS\", res);\n}\n\nstatic int exec_sals(acpi_handle handle, unsigned long arg)\n{\n\treturn exec_simple_method(handle, \"SALS\", arg);\n}\n\nstatic int exec_kblc(acpi_handle handle, unsigned long arg)\n{\n\treturn exec_simple_method(handle, \"KBLC\", arg);\n}\n\nstatic int eval_kblc(acpi_handle handle, unsigned long cmd, unsigned long *res)\n{\n\treturn eval_int_with_arg(handle, \"KBLC\", cmd, res);\n}\n\nstatic int eval_dytc(acpi_handle handle, unsigned long cmd, unsigned long *res)\n{\n\treturn eval_int_with_arg(handle, \"DYTC\", cmd, res);\n}\n\n \nstatic int debugfs_status_show(struct seq_file *s, void *data)\n{\n\tstruct ideapad_private *priv = s->private;\n\tunsigned long value;\n\n\tif (!read_ec_data(priv->adev->handle, VPCCMD_R_BL_MAX, &value))\n\t\tseq_printf(s, \"Backlight max:  %lu\\n\", value);\n\tif (!read_ec_data(priv->adev->handle, VPCCMD_R_BL, &value))\n\t\tseq_printf(s, \"Backlight now:  %lu\\n\", value);\n\tif (!read_ec_data(priv->adev->handle, VPCCMD_R_BL_POWER, &value))\n\t\tseq_printf(s, \"BL power value: %s (%lu)\\n\", value ? \"on\" : \"off\", value);\n\n\tseq_puts(s, \"=====================\\n\");\n\n\tif (!read_ec_data(priv->adev->handle, VPCCMD_R_RF, &value))\n\t\tseq_printf(s, \"Radio status: %s (%lu)\\n\", value ? \"on\" : \"off\", value);\n\tif (!read_ec_data(priv->adev->handle, VPCCMD_R_WIFI, &value))\n\t\tseq_printf(s, \"Wifi status:  %s (%lu)\\n\", value ? \"on\" : \"off\", value);\n\tif (!read_ec_data(priv->adev->handle, VPCCMD_R_BT, &value))\n\t\tseq_printf(s, \"BT status:    %s (%lu)\\n\", value ? \"on\" : \"off\", value);\n\tif (!read_ec_data(priv->adev->handle, VPCCMD_R_3G, &value))\n\t\tseq_printf(s, \"3G status:    %s (%lu)\\n\", value ? \"on\" : \"off\", value);\n\n\tseq_puts(s, \"=====================\\n\");\n\n\tif (!read_ec_data(priv->adev->handle, VPCCMD_R_TOUCHPAD, &value))\n\t\tseq_printf(s, \"Touchpad status: %s (%lu)\\n\", value ? \"on\" : \"off\", value);\n\tif (!read_ec_data(priv->adev->handle, VPCCMD_R_CAMERA, &value))\n\t\tseq_printf(s, \"Camera status:   %s (%lu)\\n\", value ? \"on\" : \"off\", value);\n\n\tseq_puts(s, \"=====================\\n\");\n\n\tif (!eval_gbmd(priv->adev->handle, &value))\n\t\tseq_printf(s, \"GBMD: %#010lx\\n\", value);\n\tif (!eval_hals(priv->adev->handle, &value))\n\t\tseq_printf(s, \"HALS: %#010lx\\n\", value);\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(debugfs_status);\n\nstatic int debugfs_cfg_show(struct seq_file *s, void *data)\n{\n\tstruct ideapad_private *priv = s->private;\n\n\tseq_printf(s, \"_CFG: %#010lx\\n\\n\", priv->cfg);\n\n\tseq_puts(s, \"Capabilities:\");\n\tif (test_bit(CFG_CAP_BT_BIT, &priv->cfg))\n\t\tseq_puts(s, \" bluetooth\");\n\tif (test_bit(CFG_CAP_3G_BIT, &priv->cfg))\n\t\tseq_puts(s, \" 3G\");\n\tif (test_bit(CFG_CAP_WIFI_BIT, &priv->cfg))\n\t\tseq_puts(s, \" wifi\");\n\tif (test_bit(CFG_CAP_CAM_BIT, &priv->cfg))\n\t\tseq_puts(s, \" camera\");\n\tseq_puts(s, \"\\n\");\n\n\tseq_puts(s, \"OSD support:\");\n\tif (test_bit(CFG_OSD_NUMLK_BIT, &priv->cfg))\n\t\tseq_puts(s, \" num-lock\");\n\tif (test_bit(CFG_OSD_CAPSLK_BIT, &priv->cfg))\n\t\tseq_puts(s, \" caps-lock\");\n\tif (test_bit(CFG_OSD_MICMUTE_BIT, &priv->cfg))\n\t\tseq_puts(s, \" mic-mute\");\n\tif (test_bit(CFG_OSD_TOUCHPAD_BIT, &priv->cfg))\n\t\tseq_puts(s, \" touchpad\");\n\tif (test_bit(CFG_OSD_CAM_BIT, &priv->cfg))\n\t\tseq_puts(s, \" camera\");\n\tseq_puts(s, \"\\n\");\n\n\tseq_puts(s, \"Graphics: \");\n\tswitch (priv->cfg & 0x700) {\n\tcase 0x100:\n\t\tseq_puts(s, \"Intel\");\n\t\tbreak;\n\tcase 0x200:\n\t\tseq_puts(s, \"ATI\");\n\t\tbreak;\n\tcase 0x300:\n\t\tseq_puts(s, \"Nvidia\");\n\t\tbreak;\n\tcase 0x400:\n\t\tseq_puts(s, \"Intel and ATI\");\n\t\tbreak;\n\tcase 0x500:\n\t\tseq_puts(s, \"Intel and Nvidia\");\n\t\tbreak;\n\t}\n\tseq_puts(s, \"\\n\");\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(debugfs_cfg);\n\nstatic void ideapad_debugfs_init(struct ideapad_private *priv)\n{\n\tstruct dentry *dir;\n\n\tdir = debugfs_create_dir(\"ideapad\", NULL);\n\tpriv->debug = dir;\n\n\tdebugfs_create_file(\"cfg\", 0444, dir, priv, &debugfs_cfg_fops);\n\tdebugfs_create_file(\"status\", 0444, dir, priv, &debugfs_status_fops);\n}\n\nstatic void ideapad_debugfs_exit(struct ideapad_private *priv)\n{\n\tdebugfs_remove_recursive(priv->debug);\n\tpriv->debug = NULL;\n}\n\n \nstatic ssize_t camera_power_show(struct device *dev,\n\t\t\t\t struct device_attribute *attr,\n\t\t\t\t char *buf)\n{\n\tstruct ideapad_private *priv = dev_get_drvdata(dev);\n\tunsigned long result;\n\tint err;\n\n\terr = read_ec_data(priv->adev->handle, VPCCMD_R_CAMERA, &result);\n\tif (err)\n\t\treturn err;\n\n\treturn sysfs_emit(buf, \"%d\\n\", !!result);\n}\n\nstatic ssize_t camera_power_store(struct device *dev,\n\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t  const char *buf, size_t count)\n{\n\tstruct ideapad_private *priv = dev_get_drvdata(dev);\n\tbool state;\n\tint err;\n\n\terr = kstrtobool(buf, &state);\n\tif (err)\n\t\treturn err;\n\n\terr = write_ec_cmd(priv->adev->handle, VPCCMD_W_CAMERA, state);\n\tif (err)\n\t\treturn err;\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR_RW(camera_power);\n\nstatic ssize_t conservation_mode_show(struct device *dev,\n\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t      char *buf)\n{\n\tstruct ideapad_private *priv = dev_get_drvdata(dev);\n\tunsigned long result;\n\tint err;\n\n\terr = eval_gbmd(priv->adev->handle, &result);\n\tif (err)\n\t\treturn err;\n\n\treturn sysfs_emit(buf, \"%d\\n\", !!test_bit(GBMD_CONSERVATION_STATE_BIT, &result));\n}\n\nstatic ssize_t conservation_mode_store(struct device *dev,\n\t\t\t\t       struct device_attribute *attr,\n\t\t\t\t       const char *buf, size_t count)\n{\n\tstruct ideapad_private *priv = dev_get_drvdata(dev);\n\tbool state;\n\tint err;\n\n\terr = kstrtobool(buf, &state);\n\tif (err)\n\t\treturn err;\n\n\terr = exec_sbmc(priv->adev->handle, state ? SBMC_CONSERVATION_ON : SBMC_CONSERVATION_OFF);\n\tif (err)\n\t\treturn err;\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR_RW(conservation_mode);\n\nstatic ssize_t fan_mode_show(struct device *dev,\n\t\t\t     struct device_attribute *attr,\n\t\t\t     char *buf)\n{\n\tstruct ideapad_private *priv = dev_get_drvdata(dev);\n\tunsigned long result;\n\tint err;\n\n\terr = read_ec_data(priv->adev->handle, VPCCMD_R_FAN, &result);\n\tif (err)\n\t\treturn err;\n\n\treturn sysfs_emit(buf, \"%lu\\n\", result);\n}\n\nstatic ssize_t fan_mode_store(struct device *dev,\n\t\t\t      struct device_attribute *attr,\n\t\t\t      const char *buf, size_t count)\n{\n\tstruct ideapad_private *priv = dev_get_drvdata(dev);\n\tunsigned int state;\n\tint err;\n\n\terr = kstrtouint(buf, 0, &state);\n\tif (err)\n\t\treturn err;\n\n\tif (state > 4 || state == 3)\n\t\treturn -EINVAL;\n\n\terr = write_ec_cmd(priv->adev->handle, VPCCMD_W_FAN, state);\n\tif (err)\n\t\treturn err;\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR_RW(fan_mode);\n\nstatic ssize_t fn_lock_show(struct device *dev,\n\t\t\t    struct device_attribute *attr,\n\t\t\t    char *buf)\n{\n\tstruct ideapad_private *priv = dev_get_drvdata(dev);\n\tunsigned long hals;\n\tint err;\n\n\terr = eval_hals(priv->adev->handle, &hals);\n\tif (err)\n\t\treturn err;\n\n\treturn sysfs_emit(buf, \"%d\\n\", !!test_bit(HALS_FNLOCK_STATE_BIT, &hals));\n}\n\nstatic ssize_t fn_lock_store(struct device *dev,\n\t\t\t     struct device_attribute *attr,\n\t\t\t     const char *buf, size_t count)\n{\n\tstruct ideapad_private *priv = dev_get_drvdata(dev);\n\tbool state;\n\tint err;\n\n\terr = kstrtobool(buf, &state);\n\tif (err)\n\t\treturn err;\n\n\terr = exec_sals(priv->adev->handle, state ? SALS_FNLOCK_ON : SALS_FNLOCK_OFF);\n\tif (err)\n\t\treturn err;\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR_RW(fn_lock);\n\nstatic ssize_t touchpad_show(struct device *dev,\n\t\t\t     struct device_attribute *attr,\n\t\t\t     char *buf)\n{\n\tstruct ideapad_private *priv = dev_get_drvdata(dev);\n\tunsigned long result;\n\tint err;\n\n\terr = read_ec_data(priv->adev->handle, VPCCMD_R_TOUCHPAD, &result);\n\tif (err)\n\t\treturn err;\n\n\tpriv->r_touchpad_val = result;\n\n\treturn sysfs_emit(buf, \"%d\\n\", !!result);\n}\n\nstatic ssize_t touchpad_store(struct device *dev,\n\t\t\t      struct device_attribute *attr,\n\t\t\t      const char *buf, size_t count)\n{\n\tstruct ideapad_private *priv = dev_get_drvdata(dev);\n\tbool state;\n\tint err;\n\n\terr = kstrtobool(buf, &state);\n\tif (err)\n\t\treturn err;\n\n\terr = write_ec_cmd(priv->adev->handle, VPCCMD_W_TOUCHPAD, state);\n\tif (err)\n\t\treturn err;\n\n\tpriv->r_touchpad_val = state;\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR_RW(touchpad);\n\nstatic ssize_t usb_charging_show(struct device *dev,\n\t\t\t\t struct device_attribute *attr,\n\t\t\t\t char *buf)\n{\n\tstruct ideapad_private *priv = dev_get_drvdata(dev);\n\tunsigned long hals;\n\tint err;\n\n\terr = eval_hals(priv->adev->handle, &hals);\n\tif (err)\n\t\treturn err;\n\n\treturn sysfs_emit(buf, \"%d\\n\", !!test_bit(HALS_USB_CHARGING_STATE_BIT, &hals));\n}\n\nstatic ssize_t usb_charging_store(struct device *dev,\n\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t  const char *buf, size_t count)\n{\n\tstruct ideapad_private *priv = dev_get_drvdata(dev);\n\tbool state;\n\tint err;\n\n\terr = kstrtobool(buf, &state);\n\tif (err)\n\t\treturn err;\n\n\terr = exec_sals(priv->adev->handle, state ? SALS_USB_CHARGING_ON : SALS_USB_CHARGING_OFF);\n\tif (err)\n\t\treturn err;\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR_RW(usb_charging);\n\nstatic struct attribute *ideapad_attributes[] = {\n\t&dev_attr_camera_power.attr,\n\t&dev_attr_conservation_mode.attr,\n\t&dev_attr_fan_mode.attr,\n\t&dev_attr_fn_lock.attr,\n\t&dev_attr_touchpad.attr,\n\t&dev_attr_usb_charging.attr,\n\tNULL\n};\n\nstatic umode_t ideapad_is_visible(struct kobject *kobj,\n\t\t\t\t  struct attribute *attr,\n\t\t\t\t  int idx)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct ideapad_private *priv = dev_get_drvdata(dev);\n\tbool supported = true;\n\n\tif (attr == &dev_attr_camera_power.attr)\n\t\tsupported = test_bit(CFG_CAP_CAM_BIT, &priv->cfg);\n\telse if (attr == &dev_attr_conservation_mode.attr)\n\t\tsupported = priv->features.conservation_mode;\n\telse if (attr == &dev_attr_fan_mode.attr)\n\t\tsupported = priv->features.fan_mode;\n\telse if (attr == &dev_attr_fn_lock.attr)\n\t\tsupported = priv->features.fn_lock;\n\telse if (attr == &dev_attr_touchpad.attr)\n\t\tsupported = priv->features.touchpad_ctrl_via_ec;\n\telse if (attr == &dev_attr_usb_charging.attr)\n\t\tsupported = priv->features.usb_charging;\n\n\treturn supported ? attr->mode : 0;\n}\n\nstatic const struct attribute_group ideapad_attribute_group = {\n\t.is_visible = ideapad_is_visible,\n\t.attrs = ideapad_attributes\n};\n\n \n#define DYTC_CMD_QUERY        0  \n#define DYTC_CMD_SET          1  \n#define DYTC_CMD_GET          2  \n#define DYTC_CMD_RESET    0x1ff  \n\n#define DYTC_QUERY_ENABLE_BIT 8   \n#define DYTC_QUERY_SUBREV_BIT 16  \n#define DYTC_QUERY_REV_BIT    28  \n\n#define DYTC_GET_FUNCTION_BIT 8   \n#define DYTC_GET_MODE_BIT     12  \n\n#define DYTC_SET_FUNCTION_BIT 12  \n#define DYTC_SET_MODE_BIT     16  \n#define DYTC_SET_VALID_BIT    20  \n\n#define DYTC_FUNCTION_STD     0   \n#define DYTC_FUNCTION_CQL     1   \n#define DYTC_FUNCTION_MMC     11  \n\n#define DYTC_MODE_PERFORM     2   \n#define DYTC_MODE_LOW_POWER       3   \n#define DYTC_MODE_BALANCE   0xF   \n\n#define DYTC_SET_COMMAND(function, mode, on) \\\n\t(DYTC_CMD_SET | (function) << DYTC_SET_FUNCTION_BIT | \\\n\t (mode) << DYTC_SET_MODE_BIT | \\\n\t (on) << DYTC_SET_VALID_BIT)\n\n#define DYTC_DISABLE_CQL DYTC_SET_COMMAND(DYTC_FUNCTION_CQL, DYTC_MODE_BALANCE, 0)\n\n#define DYTC_ENABLE_CQL DYTC_SET_COMMAND(DYTC_FUNCTION_CQL, DYTC_MODE_BALANCE, 1)\n\nstatic int convert_dytc_to_profile(int dytcmode, enum platform_profile_option *profile)\n{\n\tswitch (dytcmode) {\n\tcase DYTC_MODE_LOW_POWER:\n\t\t*profile = PLATFORM_PROFILE_LOW_POWER;\n\t\tbreak;\n\tcase DYTC_MODE_BALANCE:\n\t\t*profile =  PLATFORM_PROFILE_BALANCED;\n\t\tbreak;\n\tcase DYTC_MODE_PERFORM:\n\t\t*profile =  PLATFORM_PROFILE_PERFORMANCE;\n\t\tbreak;\n\tdefault:  \n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int convert_profile_to_dytc(enum platform_profile_option profile, int *perfmode)\n{\n\tswitch (profile) {\n\tcase PLATFORM_PROFILE_LOW_POWER:\n\t\t*perfmode = DYTC_MODE_LOW_POWER;\n\t\tbreak;\n\tcase PLATFORM_PROFILE_BALANCED:\n\t\t*perfmode = DYTC_MODE_BALANCE;\n\t\tbreak;\n\tcase PLATFORM_PROFILE_PERFORMANCE:\n\t\t*perfmode = DYTC_MODE_PERFORM;\n\t\tbreak;\n\tdefault:  \n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int dytc_profile_get(struct platform_profile_handler *pprof,\n\t\t\t    enum platform_profile_option *profile)\n{\n\tstruct ideapad_dytc_priv *dytc = container_of(pprof, struct ideapad_dytc_priv, pprof);\n\n\t*profile = dytc->current_profile;\n\treturn 0;\n}\n\n \nstatic int dytc_cql_command(struct ideapad_private *priv, unsigned long cmd,\n\t\t\t    unsigned long *output)\n{\n\tint err, cmd_err, cur_funcmode;\n\n\t \n\terr = eval_dytc(priv->adev->handle, DYTC_CMD_GET, output);\n\tif (err)\n\t\treturn err;\n\n\tcur_funcmode = (*output >> DYTC_GET_FUNCTION_BIT) & 0xF;\n\t \n\tif (cmd == DYTC_CMD_GET && cur_funcmode != DYTC_FUNCTION_CQL)\n\t\treturn 0;\n\n\tif (cur_funcmode == DYTC_FUNCTION_CQL) {\n\t\terr = eval_dytc(priv->adev->handle, DYTC_DISABLE_CQL, NULL);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tcmd_err = eval_dytc(priv->adev->handle, cmd, output);\n\t \n\n\tif (cur_funcmode == DYTC_FUNCTION_CQL) {\n\t\terr = eval_dytc(priv->adev->handle, DYTC_ENABLE_CQL, NULL);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn cmd_err;\n}\n\n \nstatic int dytc_profile_set(struct platform_profile_handler *pprof,\n\t\t\t    enum platform_profile_option profile)\n{\n\tstruct ideapad_dytc_priv *dytc = container_of(pprof, struct ideapad_dytc_priv, pprof);\n\tstruct ideapad_private *priv = dytc->priv;\n\tunsigned long output;\n\tint err;\n\n\terr = mutex_lock_interruptible(&dytc->mutex);\n\tif (err)\n\t\treturn err;\n\n\tif (profile == PLATFORM_PROFILE_BALANCED) {\n\t\t \n\t\terr = eval_dytc(priv->adev->handle, DYTC_CMD_RESET, NULL);\n\t\tif (err)\n\t\t\tgoto unlock;\n\t} else {\n\t\tint perfmode;\n\n\t\terr = convert_profile_to_dytc(profile, &perfmode);\n\t\tif (err)\n\t\t\tgoto unlock;\n\n\t\t \n\t\terr = dytc_cql_command(priv, DYTC_SET_COMMAND(DYTC_FUNCTION_MMC, perfmode, 1),\n\t\t\t\t       &output);\n\t\tif (err)\n\t\t\tgoto unlock;\n\t}\n\n\t \n\tdytc->current_profile = profile;\n\nunlock:\n\tmutex_unlock(&dytc->mutex);\n\n\treturn err;\n}\n\nstatic void dytc_profile_refresh(struct ideapad_private *priv)\n{\n\tenum platform_profile_option profile;\n\tunsigned long output;\n\tint err, perfmode;\n\n\tmutex_lock(&priv->dytc->mutex);\n\terr = dytc_cql_command(priv, DYTC_CMD_GET, &output);\n\tmutex_unlock(&priv->dytc->mutex);\n\tif (err)\n\t\treturn;\n\n\tperfmode = (output >> DYTC_GET_MODE_BIT) & 0xF;\n\n\tif (convert_dytc_to_profile(perfmode, &profile))\n\t\treturn;\n\n\tif (profile != priv->dytc->current_profile) {\n\t\tpriv->dytc->current_profile = profile;\n\t\tplatform_profile_notify();\n\t}\n}\n\nstatic const struct dmi_system_id ideapad_dytc_v4_allow_table[] = {\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"LENOVO\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"82L5\")\n\t\t}\n\t},\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"LENOVO\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_VERSION, \"IdeaPad 5 15ITL05\")\n\t\t}\n\t},\n\t{}\n};\n\nstatic int ideapad_dytc_profile_init(struct ideapad_private *priv)\n{\n\tint err, dytc_version;\n\tunsigned long output;\n\n\tif (!priv->features.dytc)\n\t\treturn -ENODEV;\n\n\terr = eval_dytc(priv->adev->handle, DYTC_CMD_QUERY, &output);\n\t \n\tif (err)\n\t\treturn err;\n\n\t \n\tif (!test_bit(DYTC_QUERY_ENABLE_BIT, &output)) {\n\t\tdev_info(&priv->platform_device->dev, \"DYTC_QUERY_ENABLE_BIT returned false\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tdytc_version = (output >> DYTC_QUERY_REV_BIT) & 0xF;\n\n\tif (dytc_version < 4) {\n\t\tdev_info(&priv->platform_device->dev, \"DYTC_VERSION < 4 is not supported\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (dytc_version < 5 &&\n\t    !(allow_v4_dytc || dmi_check_system(ideapad_dytc_v4_allow_table))) {\n\t\tdev_info(&priv->platform_device->dev,\n\t\t\t \"DYTC_VERSION 4 support may not work. Pass ideapad_laptop.allow_v4_dytc=Y on the kernel commandline to enable\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tpriv->dytc = kzalloc(sizeof(*priv->dytc), GFP_KERNEL);\n\tif (!priv->dytc)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&priv->dytc->mutex);\n\n\tpriv->dytc->priv = priv;\n\tpriv->dytc->pprof.profile_get = dytc_profile_get;\n\tpriv->dytc->pprof.profile_set = dytc_profile_set;\n\n\t \n\tset_bit(PLATFORM_PROFILE_LOW_POWER, priv->dytc->pprof.choices);\n\tset_bit(PLATFORM_PROFILE_BALANCED, priv->dytc->pprof.choices);\n\tset_bit(PLATFORM_PROFILE_PERFORMANCE, priv->dytc->pprof.choices);\n\n\t \n\terr = platform_profile_register(&priv->dytc->pprof);\n\tif (err)\n\t\tgoto pp_reg_failed;\n\n\t \n\tdytc_profile_refresh(priv);\n\n\treturn 0;\n\npp_reg_failed:\n\tmutex_destroy(&priv->dytc->mutex);\n\tkfree(priv->dytc);\n\tpriv->dytc = NULL;\n\n\treturn err;\n}\n\nstatic void ideapad_dytc_profile_exit(struct ideapad_private *priv)\n{\n\tif (!priv->dytc)\n\t\treturn;\n\n\tplatform_profile_remove();\n\tmutex_destroy(&priv->dytc->mutex);\n\tkfree(priv->dytc);\n\n\tpriv->dytc = NULL;\n}\n\n \nstruct ideapad_rfk_data {\n\tchar *name;\n\tint cfgbit;\n\tint opcode;\n\tint type;\n};\n\nstatic const struct ideapad_rfk_data ideapad_rfk_data[] = {\n\t{ \"ideapad_wlan\",      CFG_CAP_WIFI_BIT, VPCCMD_W_WIFI, RFKILL_TYPE_WLAN },\n\t{ \"ideapad_bluetooth\", CFG_CAP_BT_BIT,   VPCCMD_W_BT,   RFKILL_TYPE_BLUETOOTH },\n\t{ \"ideapad_3g\",        CFG_CAP_3G_BIT,   VPCCMD_W_3G,   RFKILL_TYPE_WWAN },\n};\n\nstatic int ideapad_rfk_set(void *data, bool blocked)\n{\n\tstruct ideapad_rfk_priv *priv = data;\n\tint opcode = ideapad_rfk_data[priv->dev].opcode;\n\n\treturn write_ec_cmd(priv->priv->adev->handle, opcode, !blocked);\n}\n\nstatic const struct rfkill_ops ideapad_rfk_ops = {\n\t.set_block = ideapad_rfk_set,\n};\n\nstatic void ideapad_sync_rfk_state(struct ideapad_private *priv)\n{\n\tunsigned long hw_blocked = 0;\n\tint i;\n\n\tif (priv->features.hw_rfkill_switch) {\n\t\tif (read_ec_data(priv->adev->handle, VPCCMD_R_RF, &hw_blocked))\n\t\t\treturn;\n\t\thw_blocked = !hw_blocked;\n\t}\n\n\tfor (i = 0; i < IDEAPAD_RFKILL_DEV_NUM; i++)\n\t\tif (priv->rfk[i])\n\t\t\trfkill_set_hw_state(priv->rfk[i], hw_blocked);\n}\n\nstatic int ideapad_register_rfkill(struct ideapad_private *priv, int dev)\n{\n\tunsigned long rf_enabled;\n\tint err;\n\n\tif (no_bt_rfkill && ideapad_rfk_data[dev].type == RFKILL_TYPE_BLUETOOTH) {\n\t\t \n\t\twrite_ec_cmd(priv->adev->handle, ideapad_rfk_data[dev].opcode, 1);\n\t\treturn 0;\n\t}\n\n\tpriv->rfk_priv[dev].dev = dev;\n\tpriv->rfk_priv[dev].priv = priv;\n\n\tpriv->rfk[dev] = rfkill_alloc(ideapad_rfk_data[dev].name,\n\t\t\t\t      &priv->platform_device->dev,\n\t\t\t\t      ideapad_rfk_data[dev].type,\n\t\t\t\t      &ideapad_rfk_ops,\n\t\t\t\t      &priv->rfk_priv[dev]);\n\tif (!priv->rfk[dev])\n\t\treturn -ENOMEM;\n\n\terr = read_ec_data(priv->adev->handle, ideapad_rfk_data[dev].opcode - 1, &rf_enabled);\n\tif (err)\n\t\trf_enabled = 1;\n\n\trfkill_init_sw_state(priv->rfk[dev], !rf_enabled);\n\n\terr = rfkill_register(priv->rfk[dev]);\n\tif (err)\n\t\trfkill_destroy(priv->rfk[dev]);\n\n\treturn err;\n}\n\nstatic void ideapad_unregister_rfkill(struct ideapad_private *priv, int dev)\n{\n\tif (!priv->rfk[dev])\n\t\treturn;\n\n\trfkill_unregister(priv->rfk[dev]);\n\trfkill_destroy(priv->rfk[dev]);\n}\n\n \nstatic int ideapad_sysfs_init(struct ideapad_private *priv)\n{\n\treturn device_add_group(&priv->platform_device->dev,\n\t\t\t\t&ideapad_attribute_group);\n}\n\nstatic void ideapad_sysfs_exit(struct ideapad_private *priv)\n{\n\tdevice_remove_group(&priv->platform_device->dev,\n\t\t\t    &ideapad_attribute_group);\n}\n\n \n#define IDEAPAD_WMI_KEY 0x100\n\nstatic const struct key_entry ideapad_keymap[] = {\n\t{ KE_KEY,   6, { KEY_SWITCHVIDEOMODE } },\n\t{ KE_KEY,   7, { KEY_CAMERA } },\n\t{ KE_KEY,   8, { KEY_MICMUTE } },\n\t{ KE_KEY,  11, { KEY_F16 } },\n\t{ KE_KEY,  13, { KEY_WLAN } },\n\t{ KE_KEY,  16, { KEY_PROG1 } },\n\t{ KE_KEY,  17, { KEY_PROG2 } },\n\t{ KE_KEY,  64, { KEY_PROG3 } },\n\t{ KE_KEY,  65, { KEY_PROG4 } },\n\t{ KE_KEY,  66, { KEY_TOUCHPAD_OFF } },\n\t{ KE_KEY,  67, { KEY_TOUCHPAD_ON } },\n\t{ KE_KEY, 128, { KEY_ESC } },\n\n\t \n\n\t \n\t{ KE_IGNORE,\t0x02 | IDEAPAD_WMI_KEY },\n\t \n\t{ KE_IGNORE,\t0x03 | IDEAPAD_WMI_KEY },\n\t \n\t{ KE_KEY,\t0x01 | IDEAPAD_WMI_KEY, { KEY_FAVORITES } },\n\t{ KE_KEY,\t0x04 | IDEAPAD_WMI_KEY, { KEY_SELECTIVE_SCREENSHOT } },\n\t \n\t{ KE_KEY,\t0x07 | IDEAPAD_WMI_KEY, { KEY_HELP } },\n\t{ KE_KEY,\t0x0e | IDEAPAD_WMI_KEY, { KEY_PICKUP_PHONE } },\n\t{ KE_KEY,\t0x0f | IDEAPAD_WMI_KEY, { KEY_HANGUP_PHONE } },\n\t \n\t{ KE_KEY,\t0x13 | IDEAPAD_WMI_KEY, { KEY_PROG1 } },\n\t \n\t{ KE_KEY,\t0x12 | IDEAPAD_WMI_KEY, { KEY_PROG2 } },\n\t \n\t{ KE_KEY,\t0x28 | IDEAPAD_WMI_KEY, { KEY_PROG3 } },\n\t \n\t{ KE_KEY,\t0x27 | IDEAPAD_WMI_KEY, { KEY_HELP } },\n\t \n\t{ KE_KEY,\t0x0a | IDEAPAD_WMI_KEY, { KEY_DISPLAYTOGGLE } },\n\n\t{ KE_END },\n};\n\nstatic int ideapad_input_init(struct ideapad_private *priv)\n{\n\tstruct input_dev *inputdev;\n\tint err;\n\n\tinputdev = input_allocate_device();\n\tif (!inputdev)\n\t\treturn -ENOMEM;\n\n\tinputdev->name = \"Ideapad extra buttons\";\n\tinputdev->phys = \"ideapad/input0\";\n\tinputdev->id.bustype = BUS_HOST;\n\tinputdev->dev.parent = &priv->platform_device->dev;\n\n\terr = sparse_keymap_setup(inputdev, ideapad_keymap, NULL);\n\tif (err) {\n\t\tdev_err(&priv->platform_device->dev,\n\t\t\t\"Could not set up input device keymap: %d\\n\", err);\n\t\tgoto err_free_dev;\n\t}\n\n\terr = input_register_device(inputdev);\n\tif (err) {\n\t\tdev_err(&priv->platform_device->dev,\n\t\t\t\"Could not register input device: %d\\n\", err);\n\t\tgoto err_free_dev;\n\t}\n\n\tpriv->inputdev = inputdev;\n\n\treturn 0;\n\nerr_free_dev:\n\tinput_free_device(inputdev);\n\n\treturn err;\n}\n\nstatic void ideapad_input_exit(struct ideapad_private *priv)\n{\n\tinput_unregister_device(priv->inputdev);\n\tpriv->inputdev = NULL;\n}\n\nstatic void ideapad_input_report(struct ideapad_private *priv,\n\t\t\t\t unsigned long scancode)\n{\n\tsparse_keymap_report_event(priv->inputdev, scancode, 1, true);\n}\n\nstatic void ideapad_input_novokey(struct ideapad_private *priv)\n{\n\tunsigned long long_pressed;\n\n\tif (read_ec_data(priv->adev->handle, VPCCMD_R_NOVO, &long_pressed))\n\t\treturn;\n\n\tif (long_pressed)\n\t\tideapad_input_report(priv, 17);\n\telse\n\t\tideapad_input_report(priv, 16);\n}\n\nstatic void ideapad_check_special_buttons(struct ideapad_private *priv)\n{\n\tunsigned long bit, value;\n\n\tif (read_ec_data(priv->adev->handle, VPCCMD_R_SPECIAL_BUTTONS, &value))\n\t\treturn;\n\n\tfor_each_set_bit (bit, &value, 16) {\n\t\tswitch (bit) {\n\t\tcase 6:\t \n\t\tcase 0:\t \n\t\t\t \n\t\t\tideapad_input_report(priv, 65);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\t \n\t\t\tideapad_input_report(priv, 64);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_info(&priv->platform_device->dev,\n\t\t\t\t \"Unknown special button: %lu\\n\", bit);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n \nstatic int ideapad_backlight_get_brightness(struct backlight_device *blightdev)\n{\n\tstruct ideapad_private *priv = bl_get_data(blightdev);\n\tunsigned long now;\n\tint err;\n\n\terr = read_ec_data(priv->adev->handle, VPCCMD_R_BL, &now);\n\tif (err)\n\t\treturn err;\n\n\treturn now;\n}\n\nstatic int ideapad_backlight_update_status(struct backlight_device *blightdev)\n{\n\tstruct ideapad_private *priv = bl_get_data(blightdev);\n\tint err;\n\n\terr = write_ec_cmd(priv->adev->handle, VPCCMD_W_BL,\n\t\t\t   blightdev->props.brightness);\n\tif (err)\n\t\treturn err;\n\n\terr = write_ec_cmd(priv->adev->handle, VPCCMD_W_BL_POWER,\n\t\t\t   blightdev->props.power != FB_BLANK_POWERDOWN);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic const struct backlight_ops ideapad_backlight_ops = {\n\t.get_brightness = ideapad_backlight_get_brightness,\n\t.update_status = ideapad_backlight_update_status,\n};\n\nstatic int ideapad_backlight_init(struct ideapad_private *priv)\n{\n\tstruct backlight_device *blightdev;\n\tstruct backlight_properties props;\n\tunsigned long max, now, power;\n\tint err;\n\n\terr = read_ec_data(priv->adev->handle, VPCCMD_R_BL_MAX, &max);\n\tif (err)\n\t\treturn err;\n\n\terr = read_ec_data(priv->adev->handle, VPCCMD_R_BL, &now);\n\tif (err)\n\t\treturn err;\n\n\terr = read_ec_data(priv->adev->handle, VPCCMD_R_BL_POWER, &power);\n\tif (err)\n\t\treturn err;\n\n\tmemset(&props, 0, sizeof(props));\n\n\tprops.max_brightness = max;\n\tprops.type = BACKLIGHT_PLATFORM;\n\n\tblightdev = backlight_device_register(\"ideapad\",\n\t\t\t\t\t      &priv->platform_device->dev,\n\t\t\t\t\t      priv,\n\t\t\t\t\t      &ideapad_backlight_ops,\n\t\t\t\t\t      &props);\n\tif (IS_ERR(blightdev)) {\n\t\terr = PTR_ERR(blightdev);\n\t\tdev_err(&priv->platform_device->dev,\n\t\t\t\"Could not register backlight device: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tpriv->blightdev = blightdev;\n\tblightdev->props.brightness = now;\n\tblightdev->props.power = power ? FB_BLANK_UNBLANK : FB_BLANK_POWERDOWN;\n\n\tbacklight_update_status(blightdev);\n\n\treturn 0;\n}\n\nstatic void ideapad_backlight_exit(struct ideapad_private *priv)\n{\n\tbacklight_device_unregister(priv->blightdev);\n\tpriv->blightdev = NULL;\n}\n\nstatic void ideapad_backlight_notify_power(struct ideapad_private *priv)\n{\n\tstruct backlight_device *blightdev = priv->blightdev;\n\tunsigned long power;\n\n\tif (!blightdev)\n\t\treturn;\n\n\tif (read_ec_data(priv->adev->handle, VPCCMD_R_BL_POWER, &power))\n\t\treturn;\n\n\tblightdev->props.power = power ? FB_BLANK_UNBLANK : FB_BLANK_POWERDOWN;\n}\n\nstatic void ideapad_backlight_notify_brightness(struct ideapad_private *priv)\n{\n\tunsigned long now;\n\n\t \n\tif (!priv->blightdev)\n\t\tread_ec_data(priv->adev->handle, VPCCMD_R_BL, &now);\n\telse\n\t\tbacklight_force_update(priv->blightdev, BACKLIGHT_UPDATE_HOTKEY);\n}\n\n \nstatic int ideapad_kbd_bl_check_tristate(int type)\n{\n\treturn (type == KBD_BL_TRISTATE) || (type == KBD_BL_TRISTATE_AUTO);\n}\n\nstatic int ideapad_kbd_bl_brightness_get(struct ideapad_private *priv)\n{\n\tunsigned long value;\n\tint err;\n\n\tif (ideapad_kbd_bl_check_tristate(priv->kbd_bl.type)) {\n\t\terr = eval_kblc(priv->adev->handle,\n\t\t\t\tFIELD_PREP(KBD_BL_COMMAND_TYPE, priv->kbd_bl.type) |\n\t\t\t\tKBD_BL_COMMAND_GET,\n\t\t\t\t&value);\n\n\t\tif (err)\n\t\t\treturn err;\n\n\t\t \n\t\tvalue = FIELD_GET(KBD_BL_GET_BRIGHTNESS, value);\n\n\t\t \n\t\tif (value <= priv->kbd_bl.led.max_brightness)\n\t\t\treturn value;\n\n\t\t \n\t\tif (value == priv->kbd_bl.led.max_brightness + 1)\n\t\t\treturn 0;\n\n\t\t \n\t\tdev_warn(&priv->platform_device->dev,\n\t\t\t \"Unknown keyboard backlight value: %lu\", value);\n\t\treturn -EINVAL;\n\t}\n\n\terr = eval_hals(priv->adev->handle, &value);\n\tif (err)\n\t\treturn err;\n\n\treturn !!test_bit(HALS_KBD_BL_STATE_BIT, &value);\n}\n\nstatic enum led_brightness ideapad_kbd_bl_led_cdev_brightness_get(struct led_classdev *led_cdev)\n{\n\tstruct ideapad_private *priv = container_of(led_cdev, struct ideapad_private, kbd_bl.led);\n\n\treturn ideapad_kbd_bl_brightness_get(priv);\n}\n\nstatic int ideapad_kbd_bl_brightness_set(struct ideapad_private *priv, unsigned int brightness)\n{\n\tint err;\n\tunsigned long value;\n\tint type = priv->kbd_bl.type;\n\n\tif (ideapad_kbd_bl_check_tristate(type)) {\n\t\tif (brightness > priv->kbd_bl.led.max_brightness)\n\t\t\treturn -EINVAL;\n\n\t\tvalue = FIELD_PREP(KBD_BL_SET_BRIGHTNESS, brightness) |\n\t\t\tFIELD_PREP(KBD_BL_COMMAND_TYPE, type) |\n\t\t\tKBD_BL_COMMAND_SET;\n\t\terr = exec_kblc(priv->adev->handle, value);\n\t} else {\n\t\terr = exec_sals(priv->adev->handle, brightness ? SALS_KBD_BL_ON : SALS_KBD_BL_OFF);\n\t}\n\n\tif (err)\n\t\treturn err;\n\n\tpriv->kbd_bl.last_brightness = brightness;\n\n\treturn 0;\n}\n\nstatic int ideapad_kbd_bl_led_cdev_brightness_set(struct led_classdev *led_cdev,\n\t\t\t\t\t\t  enum led_brightness brightness)\n{\n\tstruct ideapad_private *priv = container_of(led_cdev, struct ideapad_private, kbd_bl.led);\n\n\treturn ideapad_kbd_bl_brightness_set(priv, brightness);\n}\n\nstatic void ideapad_kbd_bl_notify(struct ideapad_private *priv)\n{\n\tint brightness;\n\n\tif (!priv->kbd_bl.initialized)\n\t\treturn;\n\n\tbrightness = ideapad_kbd_bl_brightness_get(priv);\n\tif (brightness < 0)\n\t\treturn;\n\n\tif (brightness == priv->kbd_bl.last_brightness)\n\t\treturn;\n\n\tpriv->kbd_bl.last_brightness = brightness;\n\n\tled_classdev_notify_brightness_hw_changed(&priv->kbd_bl.led, brightness);\n}\n\nstatic int ideapad_kbd_bl_init(struct ideapad_private *priv)\n{\n\tint brightness, err;\n\n\tif (!priv->features.kbd_bl)\n\t\treturn -ENODEV;\n\n\tif (WARN_ON(priv->kbd_bl.initialized))\n\t\treturn -EEXIST;\n\n\tif (ideapad_kbd_bl_check_tristate(priv->kbd_bl.type)) {\n\t\tpriv->kbd_bl.led.max_brightness = 2;\n\t} else {\n\t\tpriv->kbd_bl.led.max_brightness = 1;\n\t}\n\n\tbrightness = ideapad_kbd_bl_brightness_get(priv);\n\tif (brightness < 0)\n\t\treturn brightness;\n\n\tpriv->kbd_bl.last_brightness = brightness;\n\tpriv->kbd_bl.led.name                    = \"platform::\" LED_FUNCTION_KBD_BACKLIGHT;\n\tpriv->kbd_bl.led.brightness_get          = ideapad_kbd_bl_led_cdev_brightness_get;\n\tpriv->kbd_bl.led.brightness_set_blocking = ideapad_kbd_bl_led_cdev_brightness_set;\n\tpriv->kbd_bl.led.flags                   = LED_BRIGHT_HW_CHANGED;\n\n\terr = led_classdev_register(&priv->platform_device->dev, &priv->kbd_bl.led);\n\tif (err)\n\t\treturn err;\n\n\tpriv->kbd_bl.initialized = true;\n\n\treturn 0;\n}\n\nstatic void ideapad_kbd_bl_exit(struct ideapad_private *priv)\n{\n\tif (!priv->kbd_bl.initialized)\n\t\treturn;\n\n\tpriv->kbd_bl.initialized = false;\n\n\tled_classdev_unregister(&priv->kbd_bl.led);\n}\n\n \nstatic void ideapad_sync_touchpad_state(struct ideapad_private *priv, bool send_events)\n{\n\tunsigned long value;\n\tunsigned char param;\n\tint ret;\n\n\t \n\tret = read_ec_data(priv->adev->handle, VPCCMD_R_TOUCHPAD, &value);\n\tif (ret)\n\t\treturn;\n\n\t \n\tif (priv->features.ctrl_ps2_aux_port)\n\t\ti8042_command(&param, value ? I8042_CMD_AUX_ENABLE : I8042_CMD_AUX_DISABLE);\n\n\t \n\tif (send_events && value != priv->r_touchpad_val) {\n\t\tideapad_input_report(priv, value ? 67 : 66);\n\t\tsysfs_notify(&priv->platform_device->dev.kobj, NULL, \"touchpad\");\n\t}\n\n\tpriv->r_touchpad_val = value;\n}\n\nstatic void ideapad_acpi_notify(acpi_handle handle, u32 event, void *data)\n{\n\tstruct ideapad_private *priv = data;\n\tunsigned long vpc1, vpc2, bit;\n\n\tif (read_ec_data(handle, VPCCMD_R_VPC1, &vpc1))\n\t\treturn;\n\n\tif (read_ec_data(handle, VPCCMD_R_VPC2, &vpc2))\n\t\treturn;\n\n\tvpc1 = (vpc2 << 8) | vpc1;\n\n\tfor_each_set_bit (bit, &vpc1, 16) {\n\t\tswitch (bit) {\n\t\tcase 13:\n\t\tcase 11:\n\t\tcase 8:\n\t\tcase 7:\n\t\tcase 6:\n\t\t\tideapad_input_report(priv, bit);\n\t\t\tbreak;\n\t\tcase 10:\n\t\t\t \n\t\t\tbreak;\n\t\tcase 9:\n\t\t\tideapad_sync_rfk_state(priv);\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tideapad_sync_touchpad_state(priv, true);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tideapad_backlight_notify_brightness(priv);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tideapad_input_novokey(priv);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tideapad_backlight_notify_power(priv);\n\t\t\tbreak;\n\t\tcase KBD_BL_KBLC_CHANGED_EVENT:\n\t\tcase 1:\n\t\t\t \n\t\t\tideapad_kbd_bl_notify(priv);\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tideapad_check_special_buttons(priv);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_info(&priv->platform_device->dev,\n\t\t\t\t \"Unknown event: %lu\\n\", bit);\n\t\t}\n\t}\n}\n\n \nstatic const struct dmi_system_id set_fn_lock_led_list[] = {\n\t{\n\t\t \nstatic const struct dmi_system_id hw_rfkill_list[] = {\n\t{}\n};\n\n \nstatic const struct dmi_system_id ctrl_ps2_aux_port_list[] = {\n\t{\n\t \n\t.matches = {\n\t\tDMI_MATCH(DMI_SYS_VENDOR, \"LENOVO\"),\n\t\tDMI_MATCH(DMI_PRODUCT_VERSION, \"Ideapad Z570\"),\n\t\t},\n\t},\n\t{}\n};\n\nstatic void ideapad_check_features(struct ideapad_private *priv)\n{\n\tacpi_handle handle = priv->adev->handle;\n\tunsigned long val;\n\n\tpriv->features.set_fn_lock_led =\n\t\tset_fn_lock_led || dmi_check_system(set_fn_lock_led_list);\n\tpriv->features.hw_rfkill_switch =\n\t\thw_rfkill_switch || dmi_check_system(hw_rfkill_list);\n\tpriv->features.ctrl_ps2_aux_port =\n\t\tctrl_ps2_aux_port || dmi_check_system(ctrl_ps2_aux_port_list);\n\tpriv->features.touchpad_ctrl_via_ec = touchpad_ctrl_via_ec;\n\n\tif (!read_ec_data(handle, VPCCMD_R_FAN, &val))\n\t\tpriv->features.fan_mode = true;\n\n\tif (acpi_has_method(handle, \"GBMD\") && acpi_has_method(handle, \"SBMC\"))\n\t\tpriv->features.conservation_mode = true;\n\n\tif (acpi_has_method(handle, \"DYTC\"))\n\t\tpriv->features.dytc = true;\n\n\tif (acpi_has_method(handle, \"HALS\") && acpi_has_method(handle, \"SALS\")) {\n\t\tif (!eval_hals(handle, &val)) {\n\t\t\tif (test_bit(HALS_FNLOCK_SUPPORT_BIT, &val))\n\t\t\t\tpriv->features.fn_lock = true;\n\n\t\t\tif (test_bit(HALS_KBD_BL_SUPPORT_BIT, &val)) {\n\t\t\t\tpriv->features.kbd_bl = true;\n\t\t\t\tpriv->kbd_bl.type = KBD_BL_STANDARD;\n\t\t\t}\n\n\t\t\tif (test_bit(HALS_USB_CHARGING_SUPPORT_BIT, &val))\n\t\t\t\tpriv->features.usb_charging = true;\n\t\t}\n\t}\n\n\tif (acpi_has_method(handle, \"KBLC\")) {\n\t\tif (!eval_kblc(priv->adev->handle, KBD_BL_QUERY_TYPE, &val)) {\n\t\t\tif (val == KBD_BL_TRISTATE_TYPE) {\n\t\t\t\tpriv->features.kbd_bl = true;\n\t\t\t\tpriv->kbd_bl.type = KBD_BL_TRISTATE;\n\t\t\t} else if (val == KBD_BL_TRISTATE_AUTO_TYPE) {\n\t\t\t\tpriv->features.kbd_bl = true;\n\t\t\t\tpriv->kbd_bl.type = KBD_BL_TRISTATE_AUTO;\n\t\t\t} else {\n\t\t\t\tdev_warn(&priv->platform_device->dev,\n\t\t\t\t\t \"Unknown keyboard type: %lu\",\n\t\t\t\t\t val);\n\t\t\t}\n\t\t}\n\t}\n}\n\n#if IS_ENABLED(CONFIG_ACPI_WMI)\n \nenum ideapad_wmi_event_type {\n\tIDEAPAD_WMI_EVENT_ESC,\n\tIDEAPAD_WMI_EVENT_FN_KEYS,\n};\n\nstruct ideapad_wmi_private {\n\tenum ideapad_wmi_event_type event;\n};\n\nstatic int ideapad_wmi_probe(struct wmi_device *wdev, const void *context)\n{\n\tstruct ideapad_wmi_private *wpriv;\n\n\twpriv = devm_kzalloc(&wdev->dev, sizeof(*wpriv), GFP_KERNEL);\n\tif (!wpriv)\n\t\treturn -ENOMEM;\n\n\t*wpriv = *(const struct ideapad_wmi_private *)context;\n\n\tdev_set_drvdata(&wdev->dev, wpriv);\n\treturn 0;\n}\n\nstatic void ideapad_wmi_notify(struct wmi_device *wdev, union acpi_object *data)\n{\n\tstruct ideapad_wmi_private *wpriv = dev_get_drvdata(&wdev->dev);\n\tstruct ideapad_private *priv;\n\tunsigned long result;\n\n\tmutex_lock(&ideapad_shared_mutex);\n\n\tpriv = ideapad_shared;\n\tif (!priv)\n\t\tgoto unlock;\n\n\tswitch (wpriv->event) {\n\tcase IDEAPAD_WMI_EVENT_ESC:\n\t\tideapad_input_report(priv, 128);\n\t\tbreak;\n\tcase IDEAPAD_WMI_EVENT_FN_KEYS:\n\t\tif (priv->features.set_fn_lock_led &&\n\t\t    !eval_hals(priv->adev->handle, &result)) {\n\t\t\tbool state = test_bit(HALS_FNLOCK_STATE_BIT, &result);\n\n\t\t\texec_sals(priv->adev->handle, state ? SALS_FNLOCK_ON : SALS_FNLOCK_OFF);\n\t\t}\n\n\t\tif (data->type != ACPI_TYPE_INTEGER) {\n\t\t\tdev_warn(&wdev->dev,\n\t\t\t\t \"WMI event data is not an integer\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tdev_dbg(&wdev->dev, \"WMI fn-key event: 0x%llx\\n\",\n\t\t\tdata->integer.value);\n\n\t\tideapad_input_report(priv,\n\t\t\t\t     data->integer.value | IDEAPAD_WMI_KEY);\n\n\t\tbreak;\n\t}\nunlock:\n\tmutex_unlock(&ideapad_shared_mutex);\n}\n\nstatic const struct ideapad_wmi_private ideapad_wmi_context_esc = {\n\t.event = IDEAPAD_WMI_EVENT_ESC\n};\n\nstatic const struct ideapad_wmi_private ideapad_wmi_context_fn_keys = {\n\t.event = IDEAPAD_WMI_EVENT_FN_KEYS\n};\n\nstatic const struct wmi_device_id ideapad_wmi_ids[] = {\n\t{ \"26CAB2E5-5CF1-46AE-AAC3-4A12B6BA50E6\", &ideapad_wmi_context_esc },  \n\t{ \"56322276-8493-4CE8-A783-98C991274F5E\", &ideapad_wmi_context_esc },  \n\t{ \"8FC0DE0C-B4E4-43FD-B0F3-8871711C1294\", &ideapad_wmi_context_fn_keys },  \n\t{},\n};\nMODULE_DEVICE_TABLE(wmi, ideapad_wmi_ids);\n\nstatic struct wmi_driver ideapad_wmi_driver = {\n\t.driver = {\n\t\t.name = \"ideapad_wmi\",\n\t},\n\t.id_table = ideapad_wmi_ids,\n\t.probe = ideapad_wmi_probe,\n\t.notify = ideapad_wmi_notify,\n};\n\nstatic int ideapad_wmi_driver_register(void)\n{\n\treturn wmi_driver_register(&ideapad_wmi_driver);\n}\n\nstatic void ideapad_wmi_driver_unregister(void)\n{\n\treturn wmi_driver_unregister(&ideapad_wmi_driver);\n}\n\n#else\nstatic inline int ideapad_wmi_driver_register(void) { return 0; }\nstatic inline void ideapad_wmi_driver_unregister(void) { }\n#endif\n\n \nstatic int ideapad_acpi_add(struct platform_device *pdev)\n{\n\tstruct acpi_device *adev = ACPI_COMPANION(&pdev->dev);\n\tstruct ideapad_private *priv;\n\tacpi_status status;\n\tunsigned long cfg;\n\tint err, i;\n\n\tif (!adev || eval_int(adev->handle, \"_CFG\", &cfg))\n\t\treturn -ENODEV;\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tdev_set_drvdata(&pdev->dev, priv);\n\n\tpriv->cfg = cfg;\n\tpriv->adev = adev;\n\tpriv->platform_device = pdev;\n\n\tideapad_check_features(priv);\n\n\terr = ideapad_sysfs_init(priv);\n\tif (err)\n\t\treturn err;\n\n\tideapad_debugfs_init(priv);\n\n\terr = ideapad_input_init(priv);\n\tif (err)\n\t\tgoto input_failed;\n\n\terr = ideapad_kbd_bl_init(priv);\n\tif (err) {\n\t\tif (err != -ENODEV)\n\t\t\tdev_warn(&pdev->dev, \"Could not set up keyboard backlight LED: %d\\n\", err);\n\t\telse\n\t\t\tdev_info(&pdev->dev, \"Keyboard backlight control not available\\n\");\n\t}\n\n\t \n\tif (!priv->features.hw_rfkill_switch)\n\t\twrite_ec_cmd(priv->adev->handle, VPCCMD_W_RF, 1);\n\n\tfor (i = 0; i < IDEAPAD_RFKILL_DEV_NUM; i++)\n\t\tif (test_bit(ideapad_rfk_data[i].cfgbit, &priv->cfg))\n\t\t\tideapad_register_rfkill(priv, i);\n\n\tideapad_sync_rfk_state(priv);\n\tideapad_sync_touchpad_state(priv, false);\n\n\terr = ideapad_dytc_profile_init(priv);\n\tif (err) {\n\t\tif (err != -ENODEV)\n\t\t\tdev_warn(&pdev->dev, \"Could not set up DYTC interface: %d\\n\", err);\n\t\telse\n\t\t\tdev_info(&pdev->dev, \"DYTC interface is not available\\n\");\n\t}\n\n\tif (acpi_video_get_backlight_type() == acpi_backlight_vendor) {\n\t\terr = ideapad_backlight_init(priv);\n\t\tif (err && err != -ENODEV)\n\t\t\tgoto backlight_failed;\n\t}\n\n\tstatus = acpi_install_notify_handler(adev->handle,\n\t\t\t\t\t     ACPI_DEVICE_NOTIFY,\n\t\t\t\t\t     ideapad_acpi_notify, priv);\n\tif (ACPI_FAILURE(status)) {\n\t\terr = -EIO;\n\t\tgoto notification_failed;\n\t}\n\n\terr = ideapad_shared_init(priv);\n\tif (err)\n\t\tgoto shared_init_failed;\n\n\treturn 0;\n\nshared_init_failed:\n\tacpi_remove_notify_handler(priv->adev->handle,\n\t\t\t\t   ACPI_DEVICE_NOTIFY,\n\t\t\t\t   ideapad_acpi_notify);\n\nnotification_failed:\n\tideapad_backlight_exit(priv);\n\nbacklight_failed:\n\tideapad_dytc_profile_exit(priv);\n\n\tfor (i = 0; i < IDEAPAD_RFKILL_DEV_NUM; i++)\n\t\tideapad_unregister_rfkill(priv, i);\n\n\tideapad_kbd_bl_exit(priv);\n\tideapad_input_exit(priv);\n\ninput_failed:\n\tideapad_debugfs_exit(priv);\n\tideapad_sysfs_exit(priv);\n\n\treturn err;\n}\n\nstatic void ideapad_acpi_remove(struct platform_device *pdev)\n{\n\tstruct ideapad_private *priv = dev_get_drvdata(&pdev->dev);\n\tint i;\n\n\tideapad_shared_exit(priv);\n\n\tacpi_remove_notify_handler(priv->adev->handle,\n\t\t\t\t   ACPI_DEVICE_NOTIFY,\n\t\t\t\t   ideapad_acpi_notify);\n\n\tideapad_backlight_exit(priv);\n\tideapad_dytc_profile_exit(priv);\n\n\tfor (i = 0; i < IDEAPAD_RFKILL_DEV_NUM; i++)\n\t\tideapad_unregister_rfkill(priv, i);\n\n\tideapad_kbd_bl_exit(priv);\n\tideapad_input_exit(priv);\n\tideapad_debugfs_exit(priv);\n\tideapad_sysfs_exit(priv);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int ideapad_acpi_resume(struct device *dev)\n{\n\tstruct ideapad_private *priv = dev_get_drvdata(dev);\n\n\tideapad_sync_rfk_state(priv);\n\tideapad_sync_touchpad_state(priv, false);\n\n\tif (priv->dytc)\n\t\tdytc_profile_refresh(priv);\n\n\treturn 0;\n}\n#endif\nstatic SIMPLE_DEV_PM_OPS(ideapad_pm, NULL, ideapad_acpi_resume);\n\nstatic const struct acpi_device_id ideapad_device_ids[] = {\n\t{\"VPC2004\", 0},\n\t{\"\", 0},\n};\nMODULE_DEVICE_TABLE(acpi, ideapad_device_ids);\n\nstatic struct platform_driver ideapad_acpi_driver = {\n\t.probe = ideapad_acpi_add,\n\t.remove_new = ideapad_acpi_remove,\n\t.driver = {\n\t\t.name   = \"ideapad_acpi\",\n\t\t.pm     = &ideapad_pm,\n\t\t.acpi_match_table = ACPI_PTR(ideapad_device_ids),\n\t},\n};\n\nstatic int __init ideapad_laptop_init(void)\n{\n\tint err;\n\n\terr = ideapad_wmi_driver_register();\n\tif (err)\n\t\treturn err;\n\n\terr = platform_driver_register(&ideapad_acpi_driver);\n\tif (err) {\n\t\tideapad_wmi_driver_unregister();\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\nmodule_init(ideapad_laptop_init)\n\nstatic void __exit ideapad_laptop_exit(void)\n{\n\tideapad_wmi_driver_unregister();\n\tplatform_driver_unregister(&ideapad_acpi_driver);\n}\nmodule_exit(ideapad_laptop_exit)\n\nMODULE_AUTHOR(\"David Woodhouse <dwmw2@infradead.org>\");\nMODULE_DESCRIPTION(\"IdeaPad ACPI Extras\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}