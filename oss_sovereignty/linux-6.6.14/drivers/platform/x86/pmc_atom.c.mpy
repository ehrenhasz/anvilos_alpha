{
  "module_name": "pmc_atom.c",
  "hash_id": "45c09db6b0ee570484709e814ef99f0f2061bc2096a626281c84f9e21f7e1754",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/x86/pmc_atom.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/debugfs.h>\n#include <linux/device.h>\n#include <linux/dmi.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/platform_data/x86/clk-pmc-atom.h>\n#include <linux/platform_data/x86/pmc_atom.h>\n#include <linux/platform_data/x86/simatic-ipc.h>\n#include <linux/platform_device.h>\n#include <linux/pci.h>\n#include <linux/seq_file.h>\n\nstruct pmc_bit_map {\n\tconst char *name;\n\tu32 bit_mask;\n};\n\nstruct pmc_reg_map {\n\tconst struct pmc_bit_map *d3_sts_0;\n\tconst struct pmc_bit_map *d3_sts_1;\n\tconst struct pmc_bit_map *func_dis;\n\tconst struct pmc_bit_map *func_dis_2;\n\tconst struct pmc_bit_map *pss;\n};\n\nstruct pmc_data {\n\tconst struct pmc_reg_map *map;\n\tconst struct pmc_clk *clks;\n};\n\nstruct pmc_dev {\n\tu32 base_addr;\n\tvoid __iomem *regmap;\n\tconst struct pmc_reg_map *map;\n#ifdef CONFIG_DEBUG_FS\n\tstruct dentry *dbgfs_dir;\n#endif  \n\tbool init;\n};\n\nstatic struct pmc_dev pmc_device;\nstatic u32 acpi_base_addr;\n\nstatic const struct pmc_clk byt_clks[] = {\n\t{\n\t\t.name = \"xtal\",\n\t\t.freq = 25000000,\n\t\t.parent_name = NULL,\n\t},\n\t{\n\t\t.name = \"pll\",\n\t\t.freq = 19200000,\n\t\t.parent_name = \"xtal\",\n\t},\n\t{}\n};\n\nstatic const struct pmc_clk cht_clks[] = {\n\t{\n\t\t.name = \"xtal\",\n\t\t.freq = 19200000,\n\t\t.parent_name = NULL,\n\t},\n\t{}\n};\n\nstatic const struct pmc_bit_map d3_sts_0_map[] = {\n\t{\"LPSS1_F0_DMA\",\tBIT_LPSS1_F0_DMA},\n\t{\"LPSS1_F1_PWM1\",\tBIT_LPSS1_F1_PWM1},\n\t{\"LPSS1_F2_PWM2\",\tBIT_LPSS1_F2_PWM2},\n\t{\"LPSS1_F3_HSUART1\",\tBIT_LPSS1_F3_HSUART1},\n\t{\"LPSS1_F4_HSUART2\",\tBIT_LPSS1_F4_HSUART2},\n\t{\"LPSS1_F5_SPI\",\tBIT_LPSS1_F5_SPI},\n\t{\"LPSS1_F6_Reserved\",\tBIT_LPSS1_F6_XXX},\n\t{\"LPSS1_F7_Reserved\",\tBIT_LPSS1_F7_XXX},\n\t{\"SCC_EMMC\",\t\tBIT_SCC_EMMC},\n\t{\"SCC_SDIO\",\t\tBIT_SCC_SDIO},\n\t{\"SCC_SDCARD\",\t\tBIT_SCC_SDCARD},\n\t{\"SCC_MIPI\",\t\tBIT_SCC_MIPI},\n\t{\"HDA\",\t\t\tBIT_HDA},\n\t{\"LPE\",\t\t\tBIT_LPE},\n\t{\"OTG\",\t\t\tBIT_OTG},\n\t{\"USH\",\t\t\tBIT_USH},\n\t{\"GBE\",\t\t\tBIT_GBE},\n\t{\"SATA\",\t\tBIT_SATA},\n\t{\"USB_EHCI\",\t\tBIT_USB_EHCI},\n\t{\"SEC\",\t\t\tBIT_SEC},\n\t{\"PCIE_PORT0\",\t\tBIT_PCIE_PORT0},\n\t{\"PCIE_PORT1\",\t\tBIT_PCIE_PORT1},\n\t{\"PCIE_PORT2\",\t\tBIT_PCIE_PORT2},\n\t{\"PCIE_PORT3\",\t\tBIT_PCIE_PORT3},\n\t{\"LPSS2_F0_DMA\",\tBIT_LPSS2_F0_DMA},\n\t{\"LPSS2_F1_I2C1\",\tBIT_LPSS2_F1_I2C1},\n\t{\"LPSS2_F2_I2C2\",\tBIT_LPSS2_F2_I2C2},\n\t{\"LPSS2_F3_I2C3\",\tBIT_LPSS2_F3_I2C3},\n\t{\"LPSS2_F3_I2C4\",\tBIT_LPSS2_F4_I2C4},\n\t{\"LPSS2_F5_I2C5\",\tBIT_LPSS2_F5_I2C5},\n\t{\"LPSS2_F6_I2C6\",\tBIT_LPSS2_F6_I2C6},\n\t{\"LPSS2_F7_I2C7\",\tBIT_LPSS2_F7_I2C7},\n\t{}\n};\n\nstatic struct pmc_bit_map byt_d3_sts_1_map[] = {\n\t{\"SMB\",\t\t\tBIT_SMB},\n\t{\"OTG_SS_PHY\",\t\tBIT_OTG_SS_PHY},\n\t{\"USH_SS_PHY\",\t\tBIT_USH_SS_PHY},\n\t{\"DFX\",\t\t\tBIT_DFX},\n\t{}\n};\n\nstatic struct pmc_bit_map cht_d3_sts_1_map[] = {\n\t{\"SMB\",\t\t\tBIT_SMB},\n\t{\"GMM\",\t\t\tBIT_STS_GMM},\n\t{\"ISH\",\t\t\tBIT_STS_ISH},\n\t{}\n};\n\nstatic struct pmc_bit_map cht_func_dis_2_map[] = {\n\t{\"SMB\",\t\t\tBIT_SMB},\n\t{\"GMM\",\t\t\tBIT_FD_GMM},\n\t{\"ISH\",\t\t\tBIT_FD_ISH},\n\t{}\n};\n\nstatic const struct pmc_bit_map byt_pss_map[] = {\n\t{\"GBE\",\t\t\tPMC_PSS_BIT_GBE},\n\t{\"SATA\",\t\tPMC_PSS_BIT_SATA},\n\t{\"HDA\",\t\t\tPMC_PSS_BIT_HDA},\n\t{\"SEC\",\t\t\tPMC_PSS_BIT_SEC},\n\t{\"PCIE\",\t\tPMC_PSS_BIT_PCIE},\n\t{\"LPSS\",\t\tPMC_PSS_BIT_LPSS},\n\t{\"LPE\",\t\t\tPMC_PSS_BIT_LPE},\n\t{\"DFX\",\t\t\tPMC_PSS_BIT_DFX},\n\t{\"USH_CTRL\",\t\tPMC_PSS_BIT_USH_CTRL},\n\t{\"USH_SUS\",\t\tPMC_PSS_BIT_USH_SUS},\n\t{\"USH_VCCS\",\t\tPMC_PSS_BIT_USH_VCCS},\n\t{\"USH_VCCA\",\t\tPMC_PSS_BIT_USH_VCCA},\n\t{\"OTG_CTRL\",\t\tPMC_PSS_BIT_OTG_CTRL},\n\t{\"OTG_VCCS\",\t\tPMC_PSS_BIT_OTG_VCCS},\n\t{\"OTG_VCCA_CLK\",\tPMC_PSS_BIT_OTG_VCCA_CLK},\n\t{\"OTG_VCCA\",\t\tPMC_PSS_BIT_OTG_VCCA},\n\t{\"USB\",\t\t\tPMC_PSS_BIT_USB},\n\t{\"USB_SUS\",\t\tPMC_PSS_BIT_USB_SUS},\n\t{}\n};\n\nstatic const struct pmc_bit_map cht_pss_map[] = {\n\t{\"SATA\",\t\tPMC_PSS_BIT_SATA},\n\t{\"HDA\",\t\t\tPMC_PSS_BIT_HDA},\n\t{\"SEC\",\t\t\tPMC_PSS_BIT_SEC},\n\t{\"PCIE\",\t\tPMC_PSS_BIT_PCIE},\n\t{\"LPSS\",\t\tPMC_PSS_BIT_LPSS},\n\t{\"LPE\",\t\t\tPMC_PSS_BIT_LPE},\n\t{\"UFS\",\t\t\tPMC_PSS_BIT_CHT_UFS},\n\t{\"UXD\",\t\t\tPMC_PSS_BIT_CHT_UXD},\n\t{\"UXD_FD\",\t\tPMC_PSS_BIT_CHT_UXD_FD},\n\t{\"UX_ENG\",\t\tPMC_PSS_BIT_CHT_UX_ENG},\n\t{\"USB_SUS\",\t\tPMC_PSS_BIT_CHT_USB_SUS},\n\t{\"GMM\",\t\t\tPMC_PSS_BIT_CHT_GMM},\n\t{\"ISH\",\t\t\tPMC_PSS_BIT_CHT_ISH},\n\t{\"DFX_MASTER\",\t\tPMC_PSS_BIT_CHT_DFX_MASTER},\n\t{\"DFX_CLUSTER1\",\tPMC_PSS_BIT_CHT_DFX_CLUSTER1},\n\t{\"DFX_CLUSTER2\",\tPMC_PSS_BIT_CHT_DFX_CLUSTER2},\n\t{\"DFX_CLUSTER3\",\tPMC_PSS_BIT_CHT_DFX_CLUSTER3},\n\t{\"DFX_CLUSTER4\",\tPMC_PSS_BIT_CHT_DFX_CLUSTER4},\n\t{\"DFX_CLUSTER5\",\tPMC_PSS_BIT_CHT_DFX_CLUSTER5},\n\t{}\n};\n\nstatic const struct pmc_reg_map byt_reg_map = {\n\t.d3_sts_0\t= d3_sts_0_map,\n\t.d3_sts_1\t= byt_d3_sts_1_map,\n\t.func_dis\t= d3_sts_0_map,\n\t.func_dis_2\t= byt_d3_sts_1_map,\n\t.pss\t\t= byt_pss_map,\n};\n\nstatic const struct pmc_reg_map cht_reg_map = {\n\t.d3_sts_0\t= d3_sts_0_map,\n\t.d3_sts_1\t= cht_d3_sts_1_map,\n\t.func_dis\t= d3_sts_0_map,\n\t.func_dis_2\t= cht_func_dis_2_map,\n\t.pss\t\t= cht_pss_map,\n};\n\nstatic const struct pmc_data byt_data = {\n\t.map = &byt_reg_map,\n\t.clks = byt_clks,\n};\n\nstatic const struct pmc_data cht_data = {\n\t.map = &cht_reg_map,\n\t.clks = cht_clks,\n};\n\nstatic inline u32 pmc_reg_read(struct pmc_dev *pmc, int reg_offset)\n{\n\treturn readl(pmc->regmap + reg_offset);\n}\n\nstatic inline void pmc_reg_write(struct pmc_dev *pmc, int reg_offset, u32 val)\n{\n\twritel(val, pmc->regmap + reg_offset);\n}\n\nint pmc_atom_read(int offset, u32 *value)\n{\n\tstruct pmc_dev *pmc = &pmc_device;\n\n\tif (!pmc->init)\n\t\treturn -ENODEV;\n\n\t*value = pmc_reg_read(pmc, offset);\n\treturn 0;\n}\n\nstatic void pmc_power_off(void)\n{\n\tu16\tpm1_cnt_port;\n\tu32\tpm1_cnt_value;\n\n\tpr_info(\"Preparing to enter system sleep state S5\\n\");\n\n\tpm1_cnt_port = acpi_base_addr + PM1_CNT;\n\n\tpm1_cnt_value = inl(pm1_cnt_port);\n\tpm1_cnt_value &= ~SLEEP_TYPE_MASK;\n\tpm1_cnt_value |= SLEEP_TYPE_S5;\n\tpm1_cnt_value |= SLEEP_ENABLE;\n\n\toutl(pm1_cnt_value, pm1_cnt_port);\n}\n\nstatic void pmc_hw_reg_setup(struct pmc_dev *pmc)\n{\n\t \n\tpmc_reg_write(pmc, PMC_S0IX_WAKE_EN, (u32)PMC_WAKE_EN_SETTING);\n}\n\n#ifdef CONFIG_DEBUG_FS\nstatic void pmc_dev_state_print(struct seq_file *s, int reg_index,\n\t\t\t\tu32 sts, const struct pmc_bit_map *sts_map,\n\t\t\t\tu32 fd, const struct pmc_bit_map *fd_map)\n{\n\tint offset = PMC_REG_BIT_WIDTH * reg_index;\n\tint index;\n\n\tfor (index = 0; sts_map[index].name; index++) {\n\t\tseq_printf(s, \"Dev: %-2d - %-32s\\tState: %s [%s]\\n\",\n\t\t\toffset + index, sts_map[index].name,\n\t\t\tfd_map[index].bit_mask & fd ?  \"Disabled\" : \"Enabled \",\n\t\t\tsts_map[index].bit_mask & sts ?  \"D3\" : \"D0\");\n\t}\n}\n\nstatic int pmc_dev_state_show(struct seq_file *s, void *unused)\n{\n\tstruct pmc_dev *pmc = s->private;\n\tconst struct pmc_reg_map *m = pmc->map;\n\tu32 func_dis, func_dis_2;\n\tu32 d3_sts_0, d3_sts_1;\n\n\tfunc_dis = pmc_reg_read(pmc, PMC_FUNC_DIS);\n\tfunc_dis_2 = pmc_reg_read(pmc, PMC_FUNC_DIS_2);\n\td3_sts_0 = pmc_reg_read(pmc, PMC_D3_STS_0);\n\td3_sts_1 = pmc_reg_read(pmc, PMC_D3_STS_1);\n\n\t \n\tpmc_dev_state_print(s, 0, d3_sts_0, m->d3_sts_0, func_dis, m->func_dis);\n\n\t \n\tpmc_dev_state_print(s, 1, d3_sts_1, m->d3_sts_1, func_dis_2, m->func_dis_2);\n\n\treturn 0;\n}\n\nDEFINE_SHOW_ATTRIBUTE(pmc_dev_state);\n\nstatic int pmc_pss_state_show(struct seq_file *s, void *unused)\n{\n\tstruct pmc_dev *pmc = s->private;\n\tconst struct pmc_bit_map *map = pmc->map->pss;\n\tu32 pss = pmc_reg_read(pmc, PMC_PSS);\n\tint index;\n\n\tfor (index = 0; map[index].name; index++) {\n\t\tseq_printf(s, \"Island: %-2d - %-32s\\tState: %s\\n\",\n\t\t\tindex, map[index].name,\n\t\t\tmap[index].bit_mask & pss ? \"Off\" : \"On\");\n\t}\n\treturn 0;\n}\n\nDEFINE_SHOW_ATTRIBUTE(pmc_pss_state);\n\nstatic int pmc_sleep_tmr_show(struct seq_file *s, void *unused)\n{\n\tstruct pmc_dev *pmc = s->private;\n\tu64 s0ir_tmr, s0i1_tmr, s0i2_tmr, s0i3_tmr, s0_tmr;\n\n\ts0ir_tmr = (u64)pmc_reg_read(pmc, PMC_S0IR_TMR) << PMC_TMR_SHIFT;\n\ts0i1_tmr = (u64)pmc_reg_read(pmc, PMC_S0I1_TMR) << PMC_TMR_SHIFT;\n\ts0i2_tmr = (u64)pmc_reg_read(pmc, PMC_S0I2_TMR) << PMC_TMR_SHIFT;\n\ts0i3_tmr = (u64)pmc_reg_read(pmc, PMC_S0I3_TMR) << PMC_TMR_SHIFT;\n\ts0_tmr = (u64)pmc_reg_read(pmc, PMC_S0_TMR) << PMC_TMR_SHIFT;\n\n\tseq_printf(s, \"S0IR Residency:\\t%lldus\\n\", s0ir_tmr);\n\tseq_printf(s, \"S0I1 Residency:\\t%lldus\\n\", s0i1_tmr);\n\tseq_printf(s, \"S0I2 Residency:\\t%lldus\\n\", s0i2_tmr);\n\tseq_printf(s, \"S0I3 Residency:\\t%lldus\\n\", s0i3_tmr);\n\tseq_printf(s, \"S0   Residency:\\t%lldus\\n\", s0_tmr);\n\treturn 0;\n}\n\nDEFINE_SHOW_ATTRIBUTE(pmc_sleep_tmr);\n\nstatic void pmc_dbgfs_register(struct pmc_dev *pmc)\n{\n\tstruct dentry *dir;\n\n\tdir = debugfs_create_dir(\"pmc_atom\", NULL);\n\n\tpmc->dbgfs_dir = dir;\n\n\tdebugfs_create_file(\"dev_state\", S_IFREG | S_IRUGO, dir, pmc,\n\t\t\t    &pmc_dev_state_fops);\n\tdebugfs_create_file(\"pss_state\", S_IFREG | S_IRUGO, dir, pmc,\n\t\t\t    &pmc_pss_state_fops);\n\tdebugfs_create_file(\"sleep_state\", S_IFREG | S_IRUGO, dir, pmc,\n\t\t\t    &pmc_sleep_tmr_fops);\n}\n#else\nstatic void pmc_dbgfs_register(struct pmc_dev *pmc)\n{\n}\n#endif  \n\nstatic bool pmc_clk_is_critical = true;\n\nstatic int dmi_callback(const struct dmi_system_id *d)\n{\n\tpr_info(\"%s: PMC critical clocks quirk enabled\\n\", d->ident);\n\n\treturn 1;\n}\n\nstatic int dmi_callback_siemens(const struct dmi_system_id *d)\n{\n\tu32 st_id;\n\n\tif (dmi_walk(simatic_ipc_find_dmi_entry_helper, &st_id))\n\t\tgoto out;\n\n\tif (st_id == SIMATIC_IPC_IPC227E || st_id == SIMATIC_IPC_IPC277E)\n\t\treturn dmi_callback(d);\n\nout:\n\tpmc_clk_is_critical = false;\n\treturn 1;\n}\n\n \nstatic const struct dmi_system_id critclk_systems[] = {\n\t{\n\t\t \n\t\t.ident = \"MPL CEC1x\",\n\t\t.callback = dmi_callback,\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"MPL AG\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"CEC10 Family\"),\n\t\t},\n\t},\n\t{\n\t\t \n\t\t.ident = \"Lex BayTrail\",\n\t\t.callback = dmi_callback,\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Lex BayTrail\"),\n\t\t},\n\t},\n\t{\n\t\t \n\t\t.ident = \"Beckhoff Baytrail\",\n\t\t.callback = dmi_callback,\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Beckhoff Automation\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_FAMILY, \"CBxx63\"),\n\t\t},\n\t},\n\t{\n\t\t.ident = \"SIEMENS AG\",\n\t\t.callback = dmi_callback_siemens,\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"SIEMENS AG\"),\n\t\t},\n\t},\n\t{}\n};\n\nstatic int pmc_setup_clks(struct pci_dev *pdev, void __iomem *pmc_regmap,\n\t\t\t  const struct pmc_data *pmc_data)\n{\n\tstruct platform_device *clkdev;\n\tstruct pmc_clk_data *clk_data;\n\n\tclk_data = kzalloc(sizeof(*clk_data), GFP_KERNEL);\n\tif (!clk_data)\n\t\treturn -ENOMEM;\n\n\tclk_data->base = pmc_regmap;  \n\tclk_data->clks = pmc_data->clks;\n\tif (dmi_check_system(critclk_systems))\n\t\tclk_data->critical = pmc_clk_is_critical;\n\n\tclkdev = platform_device_register_data(&pdev->dev, \"clk-pmc-atom\",\n\t\t\t\t\t       PLATFORM_DEVID_NONE,\n\t\t\t\t\t       clk_data, sizeof(*clk_data));\n\tif (IS_ERR(clkdev)) {\n\t\tkfree(clk_data);\n\t\treturn PTR_ERR(clkdev);\n\t}\n\n\tkfree(clk_data);\n\n\treturn 0;\n}\n\nstatic int pmc_setup_dev(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tstruct pmc_dev *pmc = &pmc_device;\n\tconst struct pmc_data *data = (struct pmc_data *)ent->driver_data;\n\tconst struct pmc_reg_map *map = data->map;\n\tint ret;\n\n\t \n\tpci_read_config_dword(pdev, ACPI_BASE_ADDR_OFFSET, &acpi_base_addr);\n\tacpi_base_addr &= ACPI_BASE_ADDR_MASK;\n\n\t \n\tif (acpi_base_addr != 0 && pm_power_off == NULL)\n\t\tpm_power_off = pmc_power_off;\n\n\tpci_read_config_dword(pdev, PMC_BASE_ADDR_OFFSET, &pmc->base_addr);\n\tpmc->base_addr &= PMC_BASE_ADDR_MASK;\n\n\tpmc->regmap = ioremap(pmc->base_addr, PMC_MMIO_REG_LEN);\n\tif (!pmc->regmap) {\n\t\tdev_err(&pdev->dev, \"error: ioremap failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tpmc->map = map;\n\n\t \n\tpmc_hw_reg_setup(pmc);\n\n\tpmc_dbgfs_register(pmc);\n\n\t \n\tret = pmc_setup_clks(pdev, pmc->regmap, data);\n\tif (ret)\n\t\tdev_warn(&pdev->dev, \"platform clocks register failed: %d\\n\",\n\t\t\t ret);\n\n\tpmc->init = true;\n\treturn ret;\n}\n\n \nstatic const struct pci_device_id pmc_pci_ids[] = {\n\t{ PCI_VDEVICE(INTEL, PCI_DEVICE_ID_VLV_PMC), (kernel_ulong_t)&byt_data },\n\t{ PCI_VDEVICE(INTEL, PCI_DEVICE_ID_CHT_PMC), (kernel_ulong_t)&cht_data },\n\t{}\n};\n\nstatic int __init pmc_atom_init(void)\n{\n\tstruct pci_dev *pdev = NULL;\n\tconst struct pci_device_id *ent;\n\n\t \n\tfor_each_pci_dev(pdev) {\n\t\tent = pci_match_id(pmc_pci_ids, pdev);\n\t\tif (ent)\n\t\t\treturn pmc_setup_dev(pdev, ent);\n\t}\n\t \n\treturn -ENODEV;\n}\n\ndevice_initcall(pmc_atom_init);\n\n \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}