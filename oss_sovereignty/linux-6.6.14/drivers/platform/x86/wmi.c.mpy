{
  "module_name": "wmi.c",
  "hash_id": "811bef4d91fbf5b8c57d4e58a7bd866907e62feeac96a51b2a0f66ceeaf44786",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/x86/wmi.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt)\tKBUILD_MODNAME \": \" fmt\n\n#include <linux/acpi.h>\n#include <linux/bits.h>\n#include <linux/build_bug.h>\n#include <linux/device.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/miscdevice.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/types.h>\n#include <linux/uaccess.h>\n#include <linux/uuid.h>\n#include <linux/wmi.h>\n#include <linux/fs.h>\n#include <uapi/linux/wmi.h>\n\nMODULE_AUTHOR(\"Carlos Corbacho\");\nMODULE_DESCRIPTION(\"ACPI-WMI Mapping Driver\");\nMODULE_LICENSE(\"GPL\");\n\nstatic LIST_HEAD(wmi_block_list);\n\nstruct guid_block {\n\tguid_t guid;\n\tunion {\n\t\tchar object_id[2];\n\t\tstruct {\n\t\t\tunsigned char notify_id;\n\t\t\tunsigned char reserved;\n\t\t};\n\t};\n\tu8 instance_count;\n\tu8 flags;\n} __packed;\nstatic_assert(sizeof(typeof_member(struct guid_block, guid)) == 16);\nstatic_assert(sizeof(struct guid_block) == 20);\nstatic_assert(__alignof__(struct guid_block) == 1);\n\nenum {\t \n\tWMI_READ_TAKES_NO_ARGS,\n\tWMI_PROBED,\n};\n\nstruct wmi_block {\n\tstruct wmi_device dev;\n\tstruct list_head list;\n\tstruct guid_block gblock;\n\tstruct miscdevice char_dev;\n\tstruct mutex char_mutex;\n\tstruct acpi_device *acpi_device;\n\twmi_notify_handler handler;\n\tvoid *handler_data;\n\tu64 req_buf_size;\n\tunsigned long flags;\n};\n\n\n \n#define ACPI_WMI_EXPENSIVE   BIT(0)\n#define ACPI_WMI_METHOD      BIT(1)\t \n#define ACPI_WMI_STRING      BIT(2)\t \n#define ACPI_WMI_EVENT       BIT(3)\t \n\nstatic bool debug_event;\nmodule_param(debug_event, bool, 0444);\nMODULE_PARM_DESC(debug_event,\n\t\t \"Log WMI Events [0/1]\");\n\nstatic bool debug_dump_wdg;\nmodule_param(debug_dump_wdg, bool, 0444);\nMODULE_PARM_DESC(debug_dump_wdg,\n\t\t \"Dump available WMI interfaces [0/1]\");\n\nstatic const struct acpi_device_id wmi_device_ids[] = {\n\t{\"PNP0C14\", 0},\n\t{\"pnp0c14\", 0},\n\t{ }\n};\nMODULE_DEVICE_TABLE(acpi, wmi_device_ids);\n\n \nstatic const char * const allow_duplicates[] = {\n\t\"05901221-D566-11D1-B2F0-00A0C9062910\",\t \n\t\"8A42EA14-4F2A-FD45-6422-0087F7A7E608\",\t \n\tNULL\n};\n\n \n\nstatic acpi_status find_guid(const char *guid_string, struct wmi_block **out)\n{\n\tguid_t guid_input;\n\tstruct wmi_block *wblock;\n\n\tif (!guid_string)\n\t\treturn AE_BAD_PARAMETER;\n\n\tif (guid_parse(guid_string, &guid_input))\n\t\treturn AE_BAD_PARAMETER;\n\n\tlist_for_each_entry(wblock, &wmi_block_list, list) {\n\t\tif (guid_equal(&wblock->gblock.guid, &guid_input)) {\n\t\t\tif (out)\n\t\t\t\t*out = wblock;\n\n\t\t\treturn AE_OK;\n\t\t}\n\t}\n\n\treturn AE_NOT_FOUND;\n}\n\nstatic bool guid_parse_and_compare(const char *string, const guid_t *guid)\n{\n\tguid_t guid_input;\n\n\tif (guid_parse(string, &guid_input))\n\t\treturn false;\n\n\treturn guid_equal(&guid_input, guid);\n}\n\nstatic const void *find_guid_context(struct wmi_block *wblock,\n\t\t\t\t     struct wmi_driver *wdriver)\n{\n\tconst struct wmi_device_id *id;\n\n\tid = wdriver->id_table;\n\tif (!id)\n\t\treturn NULL;\n\n\twhile (*id->guid_string) {\n\t\tif (guid_parse_and_compare(id->guid_string, &wblock->gblock.guid))\n\t\t\treturn id->context;\n\t\tid++;\n\t}\n\treturn NULL;\n}\n\nstatic int get_subobj_info(acpi_handle handle, const char *pathname,\n\t\t\t   struct acpi_device_info **info)\n{\n\tstruct acpi_device_info *dummy_info, **info_ptr;\n\tacpi_handle subobj_handle;\n\tacpi_status status;\n\n\tstatus = acpi_get_handle(handle, (char *)pathname, &subobj_handle);\n\tif (status == AE_NOT_FOUND)\n\t\treturn -ENOENT;\n\telse if (ACPI_FAILURE(status))\n\t\treturn -EIO;\n\n\tinfo_ptr = info ? info : &dummy_info;\n\tstatus = acpi_get_object_info(subobj_handle, info_ptr);\n\tif (ACPI_FAILURE(status))\n\t\treturn -EIO;\n\n\tif (!info)\n\t\tkfree(dummy_info);\n\n\treturn 0;\n}\n\nstatic acpi_status wmi_method_enable(struct wmi_block *wblock, bool enable)\n{\n\tstruct guid_block *block;\n\tchar method[5];\n\tacpi_status status;\n\tacpi_handle handle;\n\n\tblock = &wblock->gblock;\n\thandle = wblock->acpi_device->handle;\n\n\tsnprintf(method, 5, \"WE%02X\", block->notify_id);\n\tstatus = acpi_execute_simple_method(handle, method, enable);\n\tif (status == AE_NOT_FOUND)\n\t\treturn AE_OK;\n\n\treturn status;\n}\n\n#define WMI_ACPI_METHOD_NAME_SIZE 5\n\nstatic inline void get_acpi_method_name(const struct wmi_block *wblock,\n\t\t\t\t\tconst char method,\n\t\t\t\t\tchar buffer[static WMI_ACPI_METHOD_NAME_SIZE])\n{\n\tstatic_assert(ARRAY_SIZE(wblock->gblock.object_id) == 2);\n\tstatic_assert(WMI_ACPI_METHOD_NAME_SIZE >= 5);\n\n\tbuffer[0] = 'W';\n\tbuffer[1] = method;\n\tbuffer[2] = wblock->gblock.object_id[0];\n\tbuffer[3] = wblock->gblock.object_id[1];\n\tbuffer[4] = '\\0';\n}\n\nstatic inline acpi_object_type get_param_acpi_type(const struct wmi_block *wblock)\n{\n\tif (wblock->gblock.flags & ACPI_WMI_STRING)\n\t\treturn ACPI_TYPE_STRING;\n\telse\n\t\treturn ACPI_TYPE_BUFFER;\n}\n\nstatic acpi_status get_event_data(const struct wmi_block *wblock, struct acpi_buffer *out)\n{\n\tunion acpi_object param = {\n\t\t.integer = {\n\t\t\t.type = ACPI_TYPE_INTEGER,\n\t\t\t.value = wblock->gblock.notify_id,\n\t\t}\n\t};\n\tstruct acpi_object_list input = {\n\t\t.count = 1,\n\t\t.pointer = &param,\n\t};\n\n\treturn acpi_evaluate_object(wblock->acpi_device->handle, \"_WED\", &input, out);\n}\n\n \n\n \nint set_required_buffer_size(struct wmi_device *wdev, u64 length)\n{\n\tstruct wmi_block *wblock;\n\n\twblock = container_of(wdev, struct wmi_block, dev);\n\twblock->req_buf_size = length;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(set_required_buffer_size);\n\n \nint wmi_instance_count(const char *guid_string)\n{\n\tstruct wmi_block *wblock;\n\tacpi_status status;\n\n\tstatus = find_guid(guid_string, &wblock);\n\tif (ACPI_FAILURE(status)) {\n\t\tif (status == AE_BAD_PARAMETER)\n\t\t\treturn -EINVAL;\n\n\t\treturn -ENODEV;\n\t}\n\n\treturn wmidev_instance_count(&wblock->dev);\n}\nEXPORT_SYMBOL_GPL(wmi_instance_count);\n\n \nu8 wmidev_instance_count(struct wmi_device *wdev)\n{\n\tstruct wmi_block *wblock = container_of(wdev, struct wmi_block, dev);\n\n\treturn wblock->gblock.instance_count;\n}\nEXPORT_SYMBOL_GPL(wmidev_instance_count);\n\n \nacpi_status wmi_evaluate_method(const char *guid_string, u8 instance, u32 method_id,\n\t\t\t\tconst struct acpi_buffer *in, struct acpi_buffer *out)\n{\n\tstruct wmi_block *wblock = NULL;\n\tacpi_status status;\n\n\tstatus = find_guid(guid_string, &wblock);\n\tif (ACPI_FAILURE(status))\n\t\treturn status;\n\n\treturn wmidev_evaluate_method(&wblock->dev, instance, method_id,\n\t\t\t\t      in, out);\n}\nEXPORT_SYMBOL_GPL(wmi_evaluate_method);\n\n \nacpi_status wmidev_evaluate_method(struct wmi_device *wdev, u8 instance, u32 method_id,\n\t\t\t\t   const struct acpi_buffer *in, struct acpi_buffer *out)\n{\n\tstruct guid_block *block;\n\tstruct wmi_block *wblock;\n\tacpi_handle handle;\n\tstruct acpi_object_list input;\n\tunion acpi_object params[3];\n\tchar method[WMI_ACPI_METHOD_NAME_SIZE];\n\n\twblock = container_of(wdev, struct wmi_block, dev);\n\tblock = &wblock->gblock;\n\thandle = wblock->acpi_device->handle;\n\n\tif (!(block->flags & ACPI_WMI_METHOD))\n\t\treturn AE_BAD_DATA;\n\n\tif (block->instance_count <= instance)\n\t\treturn AE_BAD_PARAMETER;\n\n\tinput.count = 2;\n\tinput.pointer = params;\n\tparams[0].type = ACPI_TYPE_INTEGER;\n\tparams[0].integer.value = instance;\n\tparams[1].type = ACPI_TYPE_INTEGER;\n\tparams[1].integer.value = method_id;\n\n\tif (in) {\n\t\tinput.count = 3;\n\n\t\tparams[2].type = get_param_acpi_type(wblock);\n\t\tparams[2].buffer.length = in->length;\n\t\tparams[2].buffer.pointer = in->pointer;\n\t}\n\n\tget_acpi_method_name(wblock, 'M', method);\n\n\treturn acpi_evaluate_object(handle, method, &input, out);\n}\nEXPORT_SYMBOL_GPL(wmidev_evaluate_method);\n\nstatic acpi_status __query_block(struct wmi_block *wblock, u8 instance,\n\t\t\t\t struct acpi_buffer *out)\n{\n\tstruct guid_block *block;\n\tacpi_handle handle;\n\tacpi_status status, wc_status = AE_ERROR;\n\tstruct acpi_object_list input;\n\tunion acpi_object wq_params[1];\n\tchar wc_method[WMI_ACPI_METHOD_NAME_SIZE];\n\tchar method[WMI_ACPI_METHOD_NAME_SIZE];\n\n\tif (!out)\n\t\treturn AE_BAD_PARAMETER;\n\n\tblock = &wblock->gblock;\n\thandle = wblock->acpi_device->handle;\n\n\tif (block->instance_count <= instance)\n\t\treturn AE_BAD_PARAMETER;\n\n\t \n\tif (block->flags & (ACPI_WMI_EVENT | ACPI_WMI_METHOD))\n\t\treturn AE_ERROR;\n\n\tinput.count = 1;\n\tinput.pointer = wq_params;\n\twq_params[0].type = ACPI_TYPE_INTEGER;\n\twq_params[0].integer.value = instance;\n\n\tif (instance == 0 && test_bit(WMI_READ_TAKES_NO_ARGS, &wblock->flags))\n\t\tinput.count = 0;\n\n\t \n\tif (block->flags & ACPI_WMI_EXPENSIVE) {\n\t\tget_acpi_method_name(wblock, 'C', wc_method);\n\n\t\t \n\t\twc_status = acpi_execute_simple_method(handle, wc_method, 1);\n\t}\n\n\tget_acpi_method_name(wblock, 'Q', method);\n\tstatus = acpi_evaluate_object(handle, method, &input, out);\n\n\t \n\tif ((block->flags & ACPI_WMI_EXPENSIVE) && ACPI_SUCCESS(wc_status)) {\n\t\t \n\t\tacpi_execute_simple_method(handle, wc_method, 0);\n\t}\n\n\treturn status;\n}\n\n \nacpi_status wmi_query_block(const char *guid_string, u8 instance,\n\t\t\t    struct acpi_buffer *out)\n{\n\tstruct wmi_block *wblock;\n\tacpi_status status;\n\n\tstatus = find_guid(guid_string, &wblock);\n\tif (ACPI_FAILURE(status))\n\t\treturn status;\n\n\treturn __query_block(wblock, instance, out);\n}\nEXPORT_SYMBOL_GPL(wmi_query_block);\n\n \nunion acpi_object *wmidev_block_query(struct wmi_device *wdev, u8 instance)\n{\n\tstruct acpi_buffer out = { ACPI_ALLOCATE_BUFFER, NULL };\n\tstruct wmi_block *wblock = container_of(wdev, struct wmi_block, dev);\n\n\tif (ACPI_FAILURE(__query_block(wblock, instance, &out)))\n\t\treturn NULL;\n\n\treturn out.pointer;\n}\nEXPORT_SYMBOL_GPL(wmidev_block_query);\n\n \nacpi_status wmi_set_block(const char *guid_string, u8 instance,\n\t\t\t  const struct acpi_buffer *in)\n{\n\tstruct wmi_block *wblock = NULL;\n\tstruct guid_block *block;\n\tacpi_handle handle;\n\tstruct acpi_object_list input;\n\tunion acpi_object params[2];\n\tchar method[WMI_ACPI_METHOD_NAME_SIZE];\n\tacpi_status status;\n\n\tif (!in)\n\t\treturn AE_BAD_DATA;\n\n\tstatus = find_guid(guid_string, &wblock);\n\tif (ACPI_FAILURE(status))\n\t\treturn status;\n\n\tblock = &wblock->gblock;\n\thandle = wblock->acpi_device->handle;\n\n\tif (block->instance_count <= instance)\n\t\treturn AE_BAD_PARAMETER;\n\n\t \n\tif (block->flags & (ACPI_WMI_EVENT | ACPI_WMI_METHOD))\n\t\treturn AE_ERROR;\n\n\tinput.count = 2;\n\tinput.pointer = params;\n\tparams[0].type = ACPI_TYPE_INTEGER;\n\tparams[0].integer.value = instance;\n\tparams[1].type = get_param_acpi_type(wblock);\n\tparams[1].buffer.length = in->length;\n\tparams[1].buffer.pointer = in->pointer;\n\n\tget_acpi_method_name(wblock, 'S', method);\n\n\treturn acpi_evaluate_object(handle, method, &input, NULL);\n}\nEXPORT_SYMBOL_GPL(wmi_set_block);\n\nstatic void wmi_dump_wdg(const struct guid_block *g)\n{\n\tpr_info(\"%pUL:\\n\", &g->guid);\n\tif (g->flags & ACPI_WMI_EVENT)\n\t\tpr_info(\"\\tnotify_id: 0x%02X\\n\", g->notify_id);\n\telse\n\t\tpr_info(\"\\tobject_id: %2pE\\n\", g->object_id);\n\tpr_info(\"\\tinstance_count: %d\\n\", g->instance_count);\n\tpr_info(\"\\tflags: %#x\", g->flags);\n\tif (g->flags) {\n\t\tif (g->flags & ACPI_WMI_EXPENSIVE)\n\t\t\tpr_cont(\" ACPI_WMI_EXPENSIVE\");\n\t\tif (g->flags & ACPI_WMI_METHOD)\n\t\t\tpr_cont(\" ACPI_WMI_METHOD\");\n\t\tif (g->flags & ACPI_WMI_STRING)\n\t\t\tpr_cont(\" ACPI_WMI_STRING\");\n\t\tif (g->flags & ACPI_WMI_EVENT)\n\t\t\tpr_cont(\" ACPI_WMI_EVENT\");\n\t}\n\tpr_cont(\"\\n\");\n\n}\n\nstatic void wmi_notify_debug(u32 value, void *context)\n{\n\tstruct acpi_buffer response = { ACPI_ALLOCATE_BUFFER, NULL };\n\tunion acpi_object *obj;\n\tacpi_status status;\n\n\tstatus = wmi_get_event_data(value, &response);\n\tif (status != AE_OK) {\n\t\tpr_info(\"bad event status 0x%x\\n\", status);\n\t\treturn;\n\t}\n\n\tobj = response.pointer;\n\tif (!obj)\n\t\treturn;\n\n\tpr_info(\"DEBUG: event 0x%02X \", value);\n\tswitch (obj->type) {\n\tcase ACPI_TYPE_BUFFER:\n\t\tpr_cont(\"BUFFER_TYPE - length %u\\n\", obj->buffer.length);\n\t\tbreak;\n\tcase ACPI_TYPE_STRING:\n\t\tpr_cont(\"STRING_TYPE - %s\\n\", obj->string.pointer);\n\t\tbreak;\n\tcase ACPI_TYPE_INTEGER:\n\t\tpr_cont(\"INTEGER_TYPE - %llu\\n\", obj->integer.value);\n\t\tbreak;\n\tcase ACPI_TYPE_PACKAGE:\n\t\tpr_cont(\"PACKAGE_TYPE - %u elements\\n\", obj->package.count);\n\t\tbreak;\n\tdefault:\n\t\tpr_cont(\"object type 0x%X\\n\", obj->type);\n\t}\n\tkfree(obj);\n}\n\n \nacpi_status wmi_install_notify_handler(const char *guid,\n\t\t\t\t       wmi_notify_handler handler,\n\t\t\t\t       void *data)\n{\n\tstruct wmi_block *block;\n\tacpi_status status = AE_NOT_EXIST;\n\tguid_t guid_input;\n\n\tif (!guid || !handler)\n\t\treturn AE_BAD_PARAMETER;\n\n\tif (guid_parse(guid, &guid_input))\n\t\treturn AE_BAD_PARAMETER;\n\n\tlist_for_each_entry(block, &wmi_block_list, list) {\n\t\tacpi_status wmi_status;\n\n\t\tif (guid_equal(&block->gblock.guid, &guid_input)) {\n\t\t\tif (block->handler &&\n\t\t\t    block->handler != wmi_notify_debug)\n\t\t\t\treturn AE_ALREADY_ACQUIRED;\n\n\t\t\tblock->handler = handler;\n\t\t\tblock->handler_data = data;\n\n\t\t\twmi_status = wmi_method_enable(block, true);\n\t\t\tif ((wmi_status != AE_OK) ||\n\t\t\t    ((wmi_status == AE_OK) && (status == AE_NOT_EXIST)))\n\t\t\t\tstatus = wmi_status;\n\t\t}\n\t}\n\n\treturn status;\n}\nEXPORT_SYMBOL_GPL(wmi_install_notify_handler);\n\n \nacpi_status wmi_remove_notify_handler(const char *guid)\n{\n\tstruct wmi_block *block;\n\tacpi_status status = AE_NOT_EXIST;\n\tguid_t guid_input;\n\n\tif (!guid)\n\t\treturn AE_BAD_PARAMETER;\n\n\tif (guid_parse(guid, &guid_input))\n\t\treturn AE_BAD_PARAMETER;\n\n\tlist_for_each_entry(block, &wmi_block_list, list) {\n\t\tacpi_status wmi_status;\n\n\t\tif (guid_equal(&block->gblock.guid, &guid_input)) {\n\t\t\tif (!block->handler ||\n\t\t\t    block->handler == wmi_notify_debug)\n\t\t\t\treturn AE_NULL_ENTRY;\n\n\t\t\tif (debug_event) {\n\t\t\t\tblock->handler = wmi_notify_debug;\n\t\t\t\tstatus = AE_OK;\n\t\t\t} else {\n\t\t\t\twmi_status = wmi_method_enable(block, false);\n\t\t\t\tblock->handler = NULL;\n\t\t\t\tblock->handler_data = NULL;\n\t\t\t\tif ((wmi_status != AE_OK) ||\n\t\t\t\t    ((wmi_status == AE_OK) &&\n\t\t\t\t     (status == AE_NOT_EXIST)))\n\t\t\t\t\tstatus = wmi_status;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn status;\n}\nEXPORT_SYMBOL_GPL(wmi_remove_notify_handler);\n\n \nacpi_status wmi_get_event_data(u32 event, struct acpi_buffer *out)\n{\n\tstruct wmi_block *wblock;\n\n\tlist_for_each_entry(wblock, &wmi_block_list, list) {\n\t\tstruct guid_block *gblock = &wblock->gblock;\n\n\t\tif ((gblock->flags & ACPI_WMI_EVENT) && gblock->notify_id == event)\n\t\t\treturn get_event_data(wblock, out);\n\t}\n\n\treturn AE_NOT_FOUND;\n}\nEXPORT_SYMBOL_GPL(wmi_get_event_data);\n\n \nbool wmi_has_guid(const char *guid_string)\n{\n\treturn ACPI_SUCCESS(find_guid(guid_string, NULL));\n}\nEXPORT_SYMBOL_GPL(wmi_has_guid);\n\n \nchar *wmi_get_acpi_device_uid(const char *guid_string)\n{\n\tstruct wmi_block *wblock = NULL;\n\tacpi_status status;\n\n\tstatus = find_guid(guid_string, &wblock);\n\tif (ACPI_FAILURE(status))\n\t\treturn NULL;\n\n\treturn acpi_device_uid(wblock->acpi_device);\n}\nEXPORT_SYMBOL_GPL(wmi_get_acpi_device_uid);\n\n#define dev_to_wblock(__dev)\tcontainer_of_const(__dev, struct wmi_block, dev.dev)\n#define dev_to_wdev(__dev)\tcontainer_of_const(__dev, struct wmi_device, dev)\n\nstatic inline struct wmi_driver *drv_to_wdrv(struct device_driver *drv)\n{\n\treturn container_of(drv, struct wmi_driver, driver);\n}\n\n \nstatic ssize_t modalias_show(struct device *dev, struct device_attribute *attr,\n\t\t\t     char *buf)\n{\n\tstruct wmi_block *wblock = dev_to_wblock(dev);\n\n\treturn sysfs_emit(buf, \"wmi:%pUL\\n\", &wblock->gblock.guid);\n}\nstatic DEVICE_ATTR_RO(modalias);\n\nstatic ssize_t guid_show(struct device *dev, struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct wmi_block *wblock = dev_to_wblock(dev);\n\n\treturn sysfs_emit(buf, \"%pUL\\n\", &wblock->gblock.guid);\n}\nstatic DEVICE_ATTR_RO(guid);\n\nstatic ssize_t instance_count_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct wmi_block *wblock = dev_to_wblock(dev);\n\n\treturn sysfs_emit(buf, \"%d\\n\", (int)wblock->gblock.instance_count);\n}\nstatic DEVICE_ATTR_RO(instance_count);\n\nstatic ssize_t expensive_show(struct device *dev,\n\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tstruct wmi_block *wblock = dev_to_wblock(dev);\n\n\treturn sysfs_emit(buf, \"%d\\n\",\n\t\t\t  (wblock->gblock.flags & ACPI_WMI_EXPENSIVE) != 0);\n}\nstatic DEVICE_ATTR_RO(expensive);\n\nstatic struct attribute *wmi_attrs[] = {\n\t&dev_attr_modalias.attr,\n\t&dev_attr_guid.attr,\n\t&dev_attr_instance_count.attr,\n\t&dev_attr_expensive.attr,\n\tNULL\n};\nATTRIBUTE_GROUPS(wmi);\n\nstatic ssize_t notify_id_show(struct device *dev, struct device_attribute *attr,\n\t\t\t      char *buf)\n{\n\tstruct wmi_block *wblock = dev_to_wblock(dev);\n\n\treturn sysfs_emit(buf, \"%02X\\n\", (unsigned int)wblock->gblock.notify_id);\n}\nstatic DEVICE_ATTR_RO(notify_id);\n\nstatic struct attribute *wmi_event_attrs[] = {\n\t&dev_attr_notify_id.attr,\n\tNULL\n};\nATTRIBUTE_GROUPS(wmi_event);\n\nstatic ssize_t object_id_show(struct device *dev, struct device_attribute *attr,\n\t\t\t      char *buf)\n{\n\tstruct wmi_block *wblock = dev_to_wblock(dev);\n\n\treturn sysfs_emit(buf, \"%c%c\\n\", wblock->gblock.object_id[0],\n\t\t\t  wblock->gblock.object_id[1]);\n}\nstatic DEVICE_ATTR_RO(object_id);\n\nstatic ssize_t setable_show(struct device *dev, struct device_attribute *attr,\n\t\t\t    char *buf)\n{\n\tstruct wmi_device *wdev = dev_to_wdev(dev);\n\n\treturn sysfs_emit(buf, \"%d\\n\", (int)wdev->setable);\n}\nstatic DEVICE_ATTR_RO(setable);\n\nstatic struct attribute *wmi_data_attrs[] = {\n\t&dev_attr_object_id.attr,\n\t&dev_attr_setable.attr,\n\tNULL\n};\nATTRIBUTE_GROUPS(wmi_data);\n\nstatic struct attribute *wmi_method_attrs[] = {\n\t&dev_attr_object_id.attr,\n\tNULL\n};\nATTRIBUTE_GROUPS(wmi_method);\n\nstatic int wmi_dev_uevent(const struct device *dev, struct kobj_uevent_env *env)\n{\n\tconst struct wmi_block *wblock = dev_to_wblock(dev);\n\n\tif (add_uevent_var(env, \"MODALIAS=wmi:%pUL\", &wblock->gblock.guid))\n\t\treturn -ENOMEM;\n\n\tif (add_uevent_var(env, \"WMI_GUID=%pUL\", &wblock->gblock.guid))\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic void wmi_dev_release(struct device *dev)\n{\n\tstruct wmi_block *wblock = dev_to_wblock(dev);\n\n\tkfree(wblock);\n}\n\nstatic int wmi_dev_match(struct device *dev, struct device_driver *driver)\n{\n\tstruct wmi_driver *wmi_driver = drv_to_wdrv(driver);\n\tstruct wmi_block *wblock = dev_to_wblock(dev);\n\tconst struct wmi_device_id *id = wmi_driver->id_table;\n\n\tif (id == NULL)\n\t\treturn 0;\n\n\twhile (*id->guid_string) {\n\t\tif (guid_parse_and_compare(id->guid_string, &wblock->gblock.guid))\n\t\t\treturn 1;\n\n\t\tid++;\n\t}\n\n\treturn 0;\n}\nstatic int wmi_char_open(struct inode *inode, struct file *filp)\n{\n\t \n\tstruct wmi_block *wblock = container_of(filp->private_data, struct wmi_block, char_dev);\n\n\tfilp->private_data = wblock;\n\n\treturn nonseekable_open(inode, filp);\n}\n\nstatic ssize_t wmi_char_read(struct file *filp, char __user *buffer,\n\t\t\t     size_t length, loff_t *offset)\n{\n\tstruct wmi_block *wblock = filp->private_data;\n\n\treturn simple_read_from_buffer(buffer, length, offset,\n\t\t\t\t       &wblock->req_buf_size,\n\t\t\t\t       sizeof(wblock->req_buf_size));\n}\n\nstatic long wmi_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n\tstruct wmi_ioctl_buffer __user *input =\n\t\t(struct wmi_ioctl_buffer __user *) arg;\n\tstruct wmi_block *wblock = filp->private_data;\n\tstruct wmi_ioctl_buffer *buf;\n\tstruct wmi_driver *wdriver;\n\tint ret;\n\n\tif (_IOC_TYPE(cmd) != WMI_IOC)\n\t\treturn -ENOTTY;\n\n\t \n\tif (_IOC_NR(cmd) >= wblock->gblock.instance_count)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&wblock->char_mutex);\n\tbuf = wblock->handler_data;\n\tif (get_user(buf->length, &input->length)) {\n\t\tdev_dbg(&wblock->dev.dev, \"Read length from user failed\\n\");\n\t\tret = -EFAULT;\n\t\tgoto out_ioctl;\n\t}\n\t \n\tif (buf->length < wblock->req_buf_size) {\n\t\tdev_err(&wblock->dev.dev,\n\t\t\t\"Buffer %lld too small, need at least %lld\\n\",\n\t\t\tbuf->length, wblock->req_buf_size);\n\t\tret = -EINVAL;\n\t\tgoto out_ioctl;\n\t}\n\t \n\tif (buf->length > wblock->req_buf_size)\n\t\tdev_warn(&wblock->dev.dev,\n\t\t\t\"Buffer %lld is bigger than required %lld\\n\",\n\t\t\tbuf->length, wblock->req_buf_size);\n\n\t \n\tif (copy_from_user(buf, input, wblock->req_buf_size)) {\n\t\tdev_dbg(&wblock->dev.dev, \"Copy %llu from user failed\\n\",\n\t\t\twblock->req_buf_size);\n\t\tret = -EFAULT;\n\t\tgoto out_ioctl;\n\t}\n\n\t \n\twdriver = drv_to_wdrv(wblock->dev.dev.driver);\n\tif (!try_module_get(wdriver->driver.owner)) {\n\t\tret = -EBUSY;\n\t\tgoto out_ioctl;\n\t}\n\tret = wdriver->filter_callback(&wblock->dev, cmd, buf);\n\tmodule_put(wdriver->driver.owner);\n\tif (ret)\n\t\tgoto out_ioctl;\n\n\t \n\tif (copy_to_user(input, buf, wblock->req_buf_size)) {\n\t\tdev_dbg(&wblock->dev.dev, \"Copy %llu to user failed\\n\",\n\t\t\twblock->req_buf_size);\n\t\tret = -EFAULT;\n\t}\n\nout_ioctl:\n\tmutex_unlock(&wblock->char_mutex);\n\treturn ret;\n}\n\nstatic const struct file_operations wmi_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.read\t\t= wmi_char_read,\n\t.open\t\t= wmi_char_open,\n\t.unlocked_ioctl\t= wmi_ioctl,\n\t.compat_ioctl\t= compat_ptr_ioctl,\n};\n\nstatic int wmi_dev_probe(struct device *dev)\n{\n\tstruct wmi_block *wblock = dev_to_wblock(dev);\n\tstruct wmi_driver *wdriver = drv_to_wdrv(dev->driver);\n\tint ret = 0;\n\tchar *buf;\n\n\tif (ACPI_FAILURE(wmi_method_enable(wblock, true)))\n\t\tdev_warn(dev, \"failed to enable device -- probing anyway\\n\");\n\n\tif (wdriver->probe) {\n\t\tret = wdriver->probe(dev_to_wdev(dev),\n\t\t\t\tfind_guid_context(wblock, wdriver));\n\t\tif (ret != 0)\n\t\t\tgoto probe_failure;\n\t}\n\n\t \n\tif (wdriver->filter_callback) {\n\t\t \n\t\tif (!wblock->req_buf_size) {\n\t\t\tdev_err(&wblock->dev.dev,\n\t\t\t\t\"Required buffer size not set\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto probe_failure;\n\t\t}\n\n\t\twblock->handler_data = kmalloc(wblock->req_buf_size,\n\t\t\t\t\t       GFP_KERNEL);\n\t\tif (!wblock->handler_data) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto probe_failure;\n\t\t}\n\n\t\tbuf = kasprintf(GFP_KERNEL, \"wmi/%s\", wdriver->driver.name);\n\t\tif (!buf) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto probe_string_failure;\n\t\t}\n\t\twblock->char_dev.minor = MISC_DYNAMIC_MINOR;\n\t\twblock->char_dev.name = buf;\n\t\twblock->char_dev.fops = &wmi_fops;\n\t\twblock->char_dev.mode = 0444;\n\t\tret = misc_register(&wblock->char_dev);\n\t\tif (ret) {\n\t\t\tdev_warn(dev, \"failed to register char dev: %d\\n\", ret);\n\t\t\tret = -ENOMEM;\n\t\t\tgoto probe_misc_failure;\n\t\t}\n\t}\n\n\tset_bit(WMI_PROBED, &wblock->flags);\n\treturn 0;\n\nprobe_misc_failure:\n\tkfree(buf);\nprobe_string_failure:\n\tkfree(wblock->handler_data);\nprobe_failure:\n\tif (ACPI_FAILURE(wmi_method_enable(wblock, false)))\n\t\tdev_warn(dev, \"failed to disable device\\n\");\n\treturn ret;\n}\n\nstatic void wmi_dev_remove(struct device *dev)\n{\n\tstruct wmi_block *wblock = dev_to_wblock(dev);\n\tstruct wmi_driver *wdriver = drv_to_wdrv(dev->driver);\n\n\tclear_bit(WMI_PROBED, &wblock->flags);\n\n\tif (wdriver->filter_callback) {\n\t\tmisc_deregister(&wblock->char_dev);\n\t\tkfree(wblock->char_dev.name);\n\t\tkfree(wblock->handler_data);\n\t}\n\n\tif (wdriver->remove)\n\t\twdriver->remove(dev_to_wdev(dev));\n\n\tif (ACPI_FAILURE(wmi_method_enable(wblock, false)))\n\t\tdev_warn(dev, \"failed to disable device\\n\");\n}\n\nstatic struct class wmi_bus_class = {\n\t.name = \"wmi_bus\",\n};\n\nstatic struct bus_type wmi_bus_type = {\n\t.name = \"wmi\",\n\t.dev_groups = wmi_groups,\n\t.match = wmi_dev_match,\n\t.uevent = wmi_dev_uevent,\n\t.probe = wmi_dev_probe,\n\t.remove = wmi_dev_remove,\n};\n\nstatic const struct device_type wmi_type_event = {\n\t.name = \"event\",\n\t.groups = wmi_event_groups,\n\t.release = wmi_dev_release,\n};\n\nstatic const struct device_type wmi_type_method = {\n\t.name = \"method\",\n\t.groups = wmi_method_groups,\n\t.release = wmi_dev_release,\n};\n\nstatic const struct device_type wmi_type_data = {\n\t.name = \"data\",\n\t.groups = wmi_data_groups,\n\t.release = wmi_dev_release,\n};\n\n \nstatic int guid_count(const guid_t *guid)\n{\n\tstruct wmi_block *wblock;\n\tint count = 0;\n\n\tlist_for_each_entry(wblock, &wmi_block_list, list) {\n\t\tif (guid_equal(&wblock->gblock.guid, guid))\n\t\t\tcount++;\n\t}\n\n\treturn count;\n}\n\nstatic int wmi_create_device(struct device *wmi_bus_dev,\n\t\t\t     struct wmi_block *wblock,\n\t\t\t     struct acpi_device *device)\n{\n\tstruct acpi_device_info *info;\n\tchar method[WMI_ACPI_METHOD_NAME_SIZE];\n\tint result;\n\tuint count;\n\n\tif (wblock->gblock.flags & ACPI_WMI_EVENT) {\n\t\twblock->dev.dev.type = &wmi_type_event;\n\t\tgoto out_init;\n\t}\n\n\tif (wblock->gblock.flags & ACPI_WMI_METHOD) {\n\t\twblock->dev.dev.type = &wmi_type_method;\n\t\tmutex_init(&wblock->char_mutex);\n\t\tgoto out_init;\n\t}\n\n\t \n\tget_acpi_method_name(wblock, 'Q', method);\n\tresult = get_subobj_info(device->handle, method, &info);\n\n\tif (result) {\n\t\tdev_warn(wmi_bus_dev,\n\t\t\t \"%s data block query control method not found\\n\",\n\t\t\t method);\n\t\treturn result;\n\t}\n\n\twblock->dev.dev.type = &wmi_type_data;\n\n\t \n\tif (info->type != ACPI_TYPE_METHOD || info->param_count == 0)\n\t\tset_bit(WMI_READ_TAKES_NO_ARGS, &wblock->flags);\n\n\tkfree(info);\n\n\tget_acpi_method_name(wblock, 'S', method);\n\tresult = get_subobj_info(device->handle, method, NULL);\n\n\tif (result == 0)\n\t\twblock->dev.setable = true;\n\n out_init:\n\twblock->dev.dev.bus = &wmi_bus_type;\n\twblock->dev.dev.parent = wmi_bus_dev;\n\n\tcount = guid_count(&wblock->gblock.guid);\n\tif (count)\n\t\tdev_set_name(&wblock->dev.dev, \"%pUL-%d\", &wblock->gblock.guid, count);\n\telse\n\t\tdev_set_name(&wblock->dev.dev, \"%pUL\", &wblock->gblock.guid);\n\n\tdevice_initialize(&wblock->dev.dev);\n\n\treturn 0;\n}\n\nstatic void wmi_free_devices(struct acpi_device *device)\n{\n\tstruct wmi_block *wblock, *next;\n\n\t \n\tlist_for_each_entry_safe(wblock, next, &wmi_block_list, list) {\n\t\tif (wblock->acpi_device == device) {\n\t\t\tlist_del(&wblock->list);\n\t\t\tdevice_unregister(&wblock->dev.dev);\n\t\t}\n\t}\n}\n\nstatic bool guid_already_parsed_for_legacy(struct acpi_device *device, const guid_t *guid)\n{\n\tstruct wmi_block *wblock;\n\n\tlist_for_each_entry(wblock, &wmi_block_list, list) {\n\t\t \n\t\tfor (int i = 0; allow_duplicates[i] != NULL; i++) {\n\t\t\tif (guid_parse_and_compare(allow_duplicates[i], guid))\n\t\t\t\treturn false;\n\t\t}\n\t\tif (guid_equal(&wblock->gblock.guid, guid)) {\n\t\t\t \n\t\t\tdev_warn(&device->dev, \"duplicate WMI GUID %pUL (first instance was on %s)\\n\",\n\t\t\t\t guid, dev_name(&wblock->acpi_device->dev));\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\n \nstatic int parse_wdg(struct device *wmi_bus_dev, struct acpi_device *device)\n{\n\tstruct acpi_buffer out = {ACPI_ALLOCATE_BUFFER, NULL};\n\tconst struct guid_block *gblock;\n\tstruct wmi_block *wblock, *next;\n\tunion acpi_object *obj;\n\tacpi_status status;\n\tu32 i, total;\n\tint retval;\n\n\tstatus = acpi_evaluate_object(device->handle, \"_WDG\", NULL, &out);\n\tif (ACPI_FAILURE(status))\n\t\treturn -ENXIO;\n\n\tobj = out.pointer;\n\tif (!obj)\n\t\treturn -ENXIO;\n\n\tif (obj->type != ACPI_TYPE_BUFFER) {\n\t\tkfree(obj);\n\t\treturn -ENXIO;\n\t}\n\n\tgblock = (const struct guid_block *)obj->buffer.pointer;\n\ttotal = obj->buffer.length / sizeof(struct guid_block);\n\n\tfor (i = 0; i < total; i++) {\n\t\tif (debug_dump_wdg)\n\t\t\twmi_dump_wdg(&gblock[i]);\n\n\t\tif (!gblock[i].instance_count) {\n\t\t\tdev_info(wmi_bus_dev, FW_INFO \"%pUL has zero instances\\n\", &gblock[i].guid);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (guid_already_parsed_for_legacy(device, &gblock[i].guid))\n\t\t\tcontinue;\n\n\t\twblock = kzalloc(sizeof(*wblock), GFP_KERNEL);\n\t\tif (!wblock) {\n\t\t\tdev_err(wmi_bus_dev, \"Failed to allocate %pUL\\n\", &gblock[i].guid);\n\t\t\tcontinue;\n\t\t}\n\n\t\twblock->acpi_device = device;\n\t\twblock->gblock = gblock[i];\n\n\t\tretval = wmi_create_device(wmi_bus_dev, wblock, device);\n\t\tif (retval) {\n\t\t\tkfree(wblock);\n\t\t\tcontinue;\n\t\t}\n\n\t\tlist_add_tail(&wblock->list, &wmi_block_list);\n\n\t\tif (debug_event) {\n\t\t\twblock->handler = wmi_notify_debug;\n\t\t\twmi_method_enable(wblock, true);\n\t\t}\n\t}\n\n\t \n\tlist_for_each_entry_safe(wblock, next, &wmi_block_list, list) {\n\t\tif (wblock->acpi_device != device)\n\t\t\tcontinue;\n\n\t\tretval = device_add(&wblock->dev.dev);\n\t\tif (retval) {\n\t\t\tdev_err(wmi_bus_dev, \"failed to register %pUL\\n\",\n\t\t\t\t&wblock->gblock.guid);\n\t\t\tif (debug_event)\n\t\t\t\twmi_method_enable(wblock, false);\n\t\t\tlist_del(&wblock->list);\n\t\t\tput_device(&wblock->dev.dev);\n\t\t}\n\t}\n\n\tkfree(obj);\n\n\treturn 0;\n}\n\n \nstatic acpi_status\nacpi_wmi_ec_space_handler(u32 function, acpi_physical_address address,\n\t\t\t  u32 bits, u64 *value,\n\t\t\t  void *handler_context, void *region_context)\n{\n\tint result = 0, i = 0;\n\tu8 temp = 0;\n\n\tif ((address > 0xFF) || !value)\n\t\treturn AE_BAD_PARAMETER;\n\n\tif (function != ACPI_READ && function != ACPI_WRITE)\n\t\treturn AE_BAD_PARAMETER;\n\n\tif (bits != 8)\n\t\treturn AE_BAD_PARAMETER;\n\n\tif (function == ACPI_READ) {\n\t\tresult = ec_read(address, &temp);\n\t\t(*value) |= ((u64)temp) << i;\n\t} else {\n\t\ttemp = 0xff & ((*value) >> i);\n\t\tresult = ec_write(address, temp);\n\t}\n\n\tswitch (result) {\n\tcase -EINVAL:\n\t\treturn AE_BAD_PARAMETER;\n\tcase -ENODEV:\n\t\treturn AE_NOT_FOUND;\n\tcase -ETIME:\n\t\treturn AE_TIME;\n\tdefault:\n\t\treturn AE_OK;\n\t}\n}\n\nstatic void acpi_wmi_notify_handler(acpi_handle handle, u32 event,\n\t\t\t\t    void *context)\n{\n\tstruct wmi_block *wblock = NULL, *iter;\n\n\tlist_for_each_entry(iter, &wmi_block_list, list) {\n\t\tstruct guid_block *block = &iter->gblock;\n\n\t\tif (iter->acpi_device->handle == handle &&\n\t\t    (block->flags & ACPI_WMI_EVENT) &&\n\t\t    (block->notify_id == event)) {\n\t\t\twblock = iter;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!wblock)\n\t\treturn;\n\n\t \n\tif (test_bit(WMI_PROBED, &wblock->flags) && wblock->dev.dev.driver) {\n\t\tstruct wmi_driver *driver = drv_to_wdrv(wblock->dev.dev.driver);\n\t\tstruct acpi_buffer evdata = { ACPI_ALLOCATE_BUFFER, NULL };\n\t\tacpi_status status;\n\n\t\tif (!driver->no_notify_data) {\n\t\t\tstatus = get_event_data(wblock, &evdata);\n\t\t\tif (ACPI_FAILURE(status)) {\n\t\t\t\tdev_warn(&wblock->dev.dev, \"failed to get event data\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (driver->notify)\n\t\t\tdriver->notify(&wblock->dev, evdata.pointer);\n\n\t\tkfree(evdata.pointer);\n\t} else if (wblock->handler) {\n\t\t \n\t\twblock->handler(event, wblock->handler_data);\n\t}\n\n\tif (debug_event)\n\t\tpr_info(\"DEBUG: GUID %pUL event 0x%02X\\n\", &wblock->gblock.guid, event);\n\n\tacpi_bus_generate_netlink_event(\n\t\twblock->acpi_device->pnp.device_class,\n\t\tdev_name(&wblock->dev.dev),\n\t\tevent, 0);\n}\n\nstatic void acpi_wmi_remove(struct platform_device *device)\n{\n\tstruct acpi_device *acpi_device = ACPI_COMPANION(&device->dev);\n\n\tacpi_remove_notify_handler(acpi_device->handle, ACPI_ALL_NOTIFY,\n\t\t\t\t   acpi_wmi_notify_handler);\n\tacpi_remove_address_space_handler(acpi_device->handle,\n\t\t\t\tACPI_ADR_SPACE_EC, &acpi_wmi_ec_space_handler);\n\twmi_free_devices(acpi_device);\n\tdevice_unregister(dev_get_drvdata(&device->dev));\n}\n\nstatic int acpi_wmi_probe(struct platform_device *device)\n{\n\tstruct acpi_device *acpi_device;\n\tstruct device *wmi_bus_dev;\n\tacpi_status status;\n\tint error;\n\n\tacpi_device = ACPI_COMPANION(&device->dev);\n\tif (!acpi_device) {\n\t\tdev_err(&device->dev, \"ACPI companion is missing\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tstatus = acpi_install_address_space_handler(acpi_device->handle,\n\t\t\t\t\t\t    ACPI_ADR_SPACE_EC,\n\t\t\t\t\t\t    &acpi_wmi_ec_space_handler,\n\t\t\t\t\t\t    NULL, NULL);\n\tif (ACPI_FAILURE(status)) {\n\t\tdev_err(&device->dev, \"Error installing EC region handler\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tstatus = acpi_install_notify_handler(acpi_device->handle,\n\t\t\t\t\t     ACPI_ALL_NOTIFY,\n\t\t\t\t\t     acpi_wmi_notify_handler,\n\t\t\t\t\t     NULL);\n\tif (ACPI_FAILURE(status)) {\n\t\tdev_err(&device->dev, \"Error installing notify handler\\n\");\n\t\terror = -ENODEV;\n\t\tgoto err_remove_ec_handler;\n\t}\n\n\twmi_bus_dev = device_create(&wmi_bus_class, &device->dev, MKDEV(0, 0),\n\t\t\t\t    NULL, \"wmi_bus-%s\", dev_name(&device->dev));\n\tif (IS_ERR(wmi_bus_dev)) {\n\t\terror = PTR_ERR(wmi_bus_dev);\n\t\tgoto err_remove_notify_handler;\n\t}\n\tdev_set_drvdata(&device->dev, wmi_bus_dev);\n\n\terror = parse_wdg(wmi_bus_dev, acpi_device);\n\tif (error) {\n\t\tpr_err(\"Failed to parse WDG method\\n\");\n\t\tgoto err_remove_busdev;\n\t}\n\n\treturn 0;\n\nerr_remove_busdev:\n\tdevice_unregister(wmi_bus_dev);\n\nerr_remove_notify_handler:\n\tacpi_remove_notify_handler(acpi_device->handle, ACPI_ALL_NOTIFY,\n\t\t\t\t   acpi_wmi_notify_handler);\n\nerr_remove_ec_handler:\n\tacpi_remove_address_space_handler(acpi_device->handle,\n\t\t\t\t\t  ACPI_ADR_SPACE_EC,\n\t\t\t\t\t  &acpi_wmi_ec_space_handler);\n\n\treturn error;\n}\n\nint __must_check __wmi_driver_register(struct wmi_driver *driver,\n\t\t\t\t       struct module *owner)\n{\n\tdriver->driver.owner = owner;\n\tdriver->driver.bus = &wmi_bus_type;\n\n\treturn driver_register(&driver->driver);\n}\nEXPORT_SYMBOL(__wmi_driver_register);\n\n \nvoid wmi_driver_unregister(struct wmi_driver *driver)\n{\n\tdriver_unregister(&driver->driver);\n}\nEXPORT_SYMBOL(wmi_driver_unregister);\n\nstatic struct platform_driver acpi_wmi_driver = {\n\t.driver = {\n\t\t.name = \"acpi-wmi\",\n\t\t.acpi_match_table = wmi_device_ids,\n\t},\n\t.probe = acpi_wmi_probe,\n\t.remove_new = acpi_wmi_remove,\n};\n\nstatic int __init acpi_wmi_init(void)\n{\n\tint error;\n\n\tif (acpi_disabled)\n\t\treturn -ENODEV;\n\n\terror = class_register(&wmi_bus_class);\n\tif (error)\n\t\treturn error;\n\n\terror = bus_register(&wmi_bus_type);\n\tif (error)\n\t\tgoto err_unreg_class;\n\n\terror = platform_driver_register(&acpi_wmi_driver);\n\tif (error) {\n\t\tpr_err(\"Error loading mapper\\n\");\n\t\tgoto err_unreg_bus;\n\t}\n\n\treturn 0;\n\nerr_unreg_bus:\n\tbus_unregister(&wmi_bus_type);\n\nerr_unreg_class:\n\tclass_unregister(&wmi_bus_class);\n\n\treturn error;\n}\n\nstatic void __exit acpi_wmi_exit(void)\n{\n\tplatform_driver_unregister(&acpi_wmi_driver);\n\tbus_unregister(&wmi_bus_type);\n\tclass_unregister(&wmi_bus_class);\n}\n\nsubsys_initcall_sync(acpi_wmi_init);\nmodule_exit(acpi_wmi_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}