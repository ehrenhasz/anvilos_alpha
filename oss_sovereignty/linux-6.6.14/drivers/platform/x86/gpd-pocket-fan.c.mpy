{
  "module_name": "gpd-pocket-fan.c",
  "hash_id": "38dd06471572672b5186e625b8704556c75f64a1b1563aea91083f8e1197a2ed",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/x86/gpd-pocket-fan.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/devm-helpers.h>\n#include <linux/gpio/consumer.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/platform_device.h>\n#include <linux/power_supply.h>\n#include <linux/thermal.h>\n#include <linux/workqueue.h>\n\n#define MAX_SPEED 3\n\n#define TEMP_LIMIT0_DEFAULT\t55000\n#define TEMP_LIMIT1_DEFAULT\t60000\n#define TEMP_LIMIT2_DEFAULT\t65000\n\n#define HYSTERESIS_DEFAULT\t3000\n\n#define SPEED_ON_AC_DEFAULT\t2\n\nstatic int temp_limits[3] = {\n\tTEMP_LIMIT0_DEFAULT, TEMP_LIMIT1_DEFAULT, TEMP_LIMIT2_DEFAULT,\n};\nmodule_param_array(temp_limits, int, NULL, 0444);\nMODULE_PARM_DESC(temp_limits,\n\t\t \"Millicelsius values above which the fan speed increases\");\n\nstatic int hysteresis = HYSTERESIS_DEFAULT;\nmodule_param(hysteresis, int, 0444);\nMODULE_PARM_DESC(hysteresis,\n\t\t \"Hysteresis in millicelsius before lowering the fan speed\");\n\nstatic int speed_on_ac = SPEED_ON_AC_DEFAULT;\nmodule_param(speed_on_ac, int, 0444);\nMODULE_PARM_DESC(speed_on_ac,\n\t\t \"minimum fan speed to allow when system is powered by AC\");\n\nstruct gpd_pocket_fan_data {\n\tstruct device *dev;\n\tstruct thermal_zone_device *dts0;\n\tstruct thermal_zone_device *dts1;\n\tstruct gpio_desc *gpio0;\n\tstruct gpio_desc *gpio1;\n\tstruct delayed_work work;\n\tint last_speed;\n};\n\nstatic void gpd_pocket_fan_set_speed(struct gpd_pocket_fan_data *fan, int speed)\n{\n\tif (speed == fan->last_speed)\n\t\treturn;\n\n\tgpiod_direction_output(fan->gpio0, !!(speed & 1));\n\tgpiod_direction_output(fan->gpio1, !!(speed & 2));\n\n\tfan->last_speed = speed;\n}\n\nstatic int gpd_pocket_fan_min_speed(void)\n{\n\tif (power_supply_is_system_supplied())\n\t\treturn speed_on_ac;\n\telse\n\t\treturn 0;\n}\n\nstatic void gpd_pocket_fan_worker(struct work_struct *work)\n{\n\tstruct gpd_pocket_fan_data *fan =\n\t\tcontainer_of(work, struct gpd_pocket_fan_data, work.work);\n\tint t0, t1, temp, speed, min_speed, i;\n\n\tif (thermal_zone_get_temp(fan->dts0, &t0) ||\n\t    thermal_zone_get_temp(fan->dts1, &t1)) {\n\t\tdev_warn(fan->dev, \"Error getting temperature\\n\");\n\t\tspeed = MAX_SPEED;\n\t\tgoto set_speed;\n\t}\n\n\ttemp = max(t0, t1);\n\n\tspeed = fan->last_speed;\n\tmin_speed = gpd_pocket_fan_min_speed();\n\n\t \n\tfor (i = min_speed; i < ARRAY_SIZE(temp_limits); i++) {\n\t\tif (temp < temp_limits[i])\n\t\t\tbreak;\n\t}\n\tif (speed < i)\n\t\tspeed = i;\n\n\t \n\tfor (i = min_speed; i < ARRAY_SIZE(temp_limits); i++) {\n\t\tif (temp <= (temp_limits[i] - hysteresis))\n\t\t\tbreak;\n\t}\n\tif (speed > i)\n\t\tspeed = i;\n\n\tif (fan->last_speed <= 0 && speed)\n\t\tspeed = MAX_SPEED;  \n\nset_speed:\n\tgpd_pocket_fan_set_speed(fan, speed);\n\n\t \n\tqueue_delayed_work(system_wq, &fan->work,\n\t\t\t   msecs_to_jiffies(4000 / (speed + 1)));\n}\n\nstatic void gpd_pocket_fan_force_update(struct gpd_pocket_fan_data *fan)\n{\n\tfan->last_speed = -1;\n\tmod_delayed_work(system_wq, &fan->work, 0);\n}\n\nstatic int gpd_pocket_fan_probe(struct platform_device *pdev)\n{\n\tstruct gpd_pocket_fan_data *fan;\n\tint i, ret;\n\n\tfor (i = 0; i < ARRAY_SIZE(temp_limits); i++) {\n\t\tif (temp_limits[i] < 20000 || temp_limits[i] > 90000) {\n\t\t\tdev_err(&pdev->dev, \"Invalid temp-limit %d (must be between 20000 and 90000)\\n\",\n\t\t\t\ttemp_limits[i]);\n\t\t\ttemp_limits[0] = TEMP_LIMIT0_DEFAULT;\n\t\t\ttemp_limits[1] = TEMP_LIMIT1_DEFAULT;\n\t\t\ttemp_limits[2] = TEMP_LIMIT2_DEFAULT;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (hysteresis < 1000 || hysteresis > 10000) {\n\t\tdev_err(&pdev->dev, \"Invalid hysteresis %d (must be between 1000 and 10000)\\n\",\n\t\t\thysteresis);\n\t\thysteresis = HYSTERESIS_DEFAULT;\n\t}\n\tif (speed_on_ac < 0 || speed_on_ac > MAX_SPEED) {\n\t\tdev_err(&pdev->dev, \"Invalid speed_on_ac %d (must be between 0 and 3)\\n\",\n\t\t\tspeed_on_ac);\n\t\tspeed_on_ac = SPEED_ON_AC_DEFAULT;\n\t}\n\n\tfan = devm_kzalloc(&pdev->dev, sizeof(*fan), GFP_KERNEL);\n\tif (!fan)\n\t\treturn -ENOMEM;\n\n\tfan->dev = &pdev->dev;\n\tret = devm_delayed_work_autocancel(&pdev->dev, &fan->work,\n\t\t\t\t\t   gpd_pocket_fan_worker);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tfan->dts0 = thermal_zone_get_zone_by_name(\"soc_dts0\");\n\tif (IS_ERR(fan->dts0))\n\t\treturn -EPROBE_DEFER;\n\n\tfan->dts1 = thermal_zone_get_zone_by_name(\"soc_dts1\");\n\tif (IS_ERR(fan->dts1))\n\t\treturn -EPROBE_DEFER;\n\n\tfan->gpio0 = devm_gpiod_get_index(fan->dev, NULL, 0, GPIOD_ASIS);\n\tif (IS_ERR(fan->gpio0))\n\t\treturn PTR_ERR(fan->gpio0);\n\n\tfan->gpio1 = devm_gpiod_get_index(fan->dev, NULL, 1, GPIOD_ASIS);\n\tif (IS_ERR(fan->gpio1))\n\t\treturn PTR_ERR(fan->gpio1);\n\n\tgpd_pocket_fan_force_update(fan);\n\n\tplatform_set_drvdata(pdev, fan);\n\treturn 0;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int gpd_pocket_fan_suspend(struct device *dev)\n{\n\tstruct gpd_pocket_fan_data *fan = dev_get_drvdata(dev);\n\n\tcancel_delayed_work_sync(&fan->work);\n\tgpd_pocket_fan_set_speed(fan, gpd_pocket_fan_min_speed());\n\treturn 0;\n}\n\nstatic int gpd_pocket_fan_resume(struct device *dev)\n{\n\tstruct gpd_pocket_fan_data *fan = dev_get_drvdata(dev);\n\n\tgpd_pocket_fan_force_update(fan);\n\treturn 0;\n}\n#endif\nstatic SIMPLE_DEV_PM_OPS(gpd_pocket_fan_pm_ops,\n\t\t\t gpd_pocket_fan_suspend,\n\t\t\t gpd_pocket_fan_resume);\n\nstatic struct acpi_device_id gpd_pocket_fan_acpi_match[] = {\n\t{ \"FAN02501\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(acpi, gpd_pocket_fan_acpi_match);\n\nstatic struct platform_driver gpd_pocket_fan_driver = {\n\t.probe\t= gpd_pocket_fan_probe,\n\t.driver\t= {\n\t\t.name\t\t\t= \"gpd_pocket_fan\",\n\t\t.acpi_match_table\t= gpd_pocket_fan_acpi_match,\n\t\t.pm\t\t\t= &gpd_pocket_fan_pm_ops,\n\t },\n};\n\nmodule_platform_driver(gpd_pocket_fan_driver);\nMODULE_AUTHOR(\"Hans de Goede <hdegoede@redhat.com\");\nMODULE_DESCRIPTION(\"GPD pocket fan driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}