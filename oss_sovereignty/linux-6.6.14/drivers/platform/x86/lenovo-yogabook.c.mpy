{
  "module_name": "lenovo-yogabook.c",
  "hash_id": "f0c4e13d2a08d9627c009c981ffd6f26d2f9b039783487f3369921cbd928a1df",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/x86/lenovo-yogabook.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/gpio/consumer.h>\n#include <linux/gpio/machine.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/leds.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/pwm.h>\n#include <linux/wmi.h>\n#include <linux/workqueue.h>\n\n#define YB_MBTN_EVENT_GUID\t\"243FEC1D-1963-41C1-8100-06A9D82A94B4\"\n\n#define YB_KBD_BL_DEFAULT\t128\n#define YB_KBD_BL_MAX\t\t255\n#define YB_KBD_BL_PWM_PERIOD\t13333\n\n#define YB_PDEV_NAME\t\t\"yogabook-touch-kbd-digitizer-switch\"\n\n \nenum {\n\tYB_KBD_IS_ON,\n\tYB_DIGITIZER_IS_ON,\n\tYB_DIGITIZER_MODE,\n\tYB_TABLET_MODE,\n\tYB_SUSPENDED,\n};\n\nstruct yogabook_data {\n\tstruct device *dev;\n\tstruct acpi_device *kbd_adev;\n\tstruct acpi_device *dig_adev;\n\tstruct device *kbd_dev;\n\tstruct device *dig_dev;\n\tstruct led_classdev *pen_led;\n\tstruct gpio_desc *pen_touch_event;\n\tstruct gpio_desc *kbd_bl_led_enable;\n\tstruct gpio_desc *backside_hall_gpio;\n\tstruct pwm_device *kbd_bl_pwm;\n\tint (*set_kbd_backlight)(struct yogabook_data *data, uint8_t level);\n\tint pen_touch_irq;\n\tint backside_hall_irq;\n\tstruct work_struct work;\n\tstruct led_classdev kbd_bl_led;\n\tunsigned long flags;\n\tuint8_t brightness;\n};\n\nstatic void yogabook_work(struct work_struct *work)\n{\n\tstruct yogabook_data *data = container_of(work, struct yogabook_data, work);\n\tbool kbd_on, digitizer_on;\n\tint r;\n\n\tif (test_bit(YB_SUSPENDED, &data->flags))\n\t\treturn;\n\n\tif (test_bit(YB_TABLET_MODE, &data->flags)) {\n\t\tkbd_on = false;\n\t\tdigitizer_on = false;\n\t} else if (test_bit(YB_DIGITIZER_MODE, &data->flags)) {\n\t\tdigitizer_on = true;\n\t\tkbd_on = false;\n\t} else {\n\t\tkbd_on = true;\n\t\tdigitizer_on = false;\n\t}\n\n\tif (!kbd_on && test_bit(YB_KBD_IS_ON, &data->flags)) {\n\t\t \n\t\tdata->set_kbd_backlight(data, 0);\n\t\tdevice_release_driver(data->kbd_dev);\n\t\tclear_bit(YB_KBD_IS_ON, &data->flags);\n\t}\n\n\tif (!digitizer_on && test_bit(YB_DIGITIZER_IS_ON, &data->flags)) {\n\t\tled_set_brightness(data->pen_led, LED_OFF);\n\t\tdevice_release_driver(data->dig_dev);\n\t\tclear_bit(YB_DIGITIZER_IS_ON, &data->flags);\n\t}\n\n\tif (kbd_on && !test_bit(YB_KBD_IS_ON, &data->flags)) {\n\t\tr = device_reprobe(data->kbd_dev);\n\t\tif (r)\n\t\t\tdev_warn(data->dev, \"Reprobe of keyboard touchscreen failed: %d\\n\", r);\n\n\t\tdata->set_kbd_backlight(data, data->brightness);\n\t\tset_bit(YB_KBD_IS_ON, &data->flags);\n\t}\n\n\tif (digitizer_on && !test_bit(YB_DIGITIZER_IS_ON, &data->flags)) {\n\t\tr = device_reprobe(data->dig_dev);\n\t\tif (r)\n\t\t\tdev_warn(data->dev, \"Reprobe of digitizer failed: %d\\n\", r);\n\n\t\tled_set_brightness(data->pen_led, LED_FULL);\n\t\tset_bit(YB_DIGITIZER_IS_ON, &data->flags);\n\t}\n}\n\nstatic void yogabook_toggle_digitizer_mode(struct yogabook_data *data)\n{\n\tif (test_bit(YB_SUSPENDED, &data->flags))\n\t\treturn;\n\n\tif (test_bit(YB_DIGITIZER_MODE, &data->flags))\n\t\tclear_bit(YB_DIGITIZER_MODE, &data->flags);\n\telse\n\t\tset_bit(YB_DIGITIZER_MODE, &data->flags);\n\n\t \n\tschedule_work(&data->work);\n}\n\nstatic irqreturn_t yogabook_backside_hall_irq(int irq, void *_data)\n{\n\tstruct yogabook_data *data = _data;\n\n\tif (gpiod_get_value(data->backside_hall_gpio))\n\t\tset_bit(YB_TABLET_MODE, &data->flags);\n\telse\n\t\tclear_bit(YB_TABLET_MODE, &data->flags);\n\n\tschedule_work(&data->work);\n\n\treturn IRQ_HANDLED;\n}\n\n#define kbd_led_to_yogabook(cdev) container_of(cdev, struct yogabook_data, kbd_bl_led)\n\nstatic enum led_brightness kbd_brightness_get(struct led_classdev *cdev)\n{\n\tstruct yogabook_data *data = kbd_led_to_yogabook(cdev);\n\n\treturn data->brightness;\n}\n\nstatic int kbd_brightness_set(struct led_classdev *cdev,\n\t\t\t      enum led_brightness value)\n{\n\tstruct yogabook_data *data = kbd_led_to_yogabook(cdev);\n\n\tif ((value < 0) || (value > YB_KBD_BL_MAX))\n\t\treturn -EINVAL;\n\n\tdata->brightness = value;\n\n\tif (!test_bit(YB_KBD_IS_ON, &data->flags))\n\t\treturn 0;\n\n\treturn data->set_kbd_backlight(data, data->brightness);\n}\n\nstatic struct gpiod_lookup_table yogabook_gpios = {\n\t.table = {\n\t\tGPIO_LOOKUP(\"INT33FF:02\", 18, \"backside_hall_sw\", GPIO_ACTIVE_LOW),\n\t\t{}\n\t},\n};\n\nstatic struct led_lookup_data yogabook_pen_led = {\n\t.provider = \"platform::indicator\",\n\t.con_id = \"pen-icon-led\",\n};\n\nstatic int yogabook_probe(struct device *dev, struct yogabook_data *data,\n\t\t\t  const char *kbd_bl_led_name)\n{\n\tint r;\n\n\tdata->dev = dev;\n\tdata->brightness = YB_KBD_BL_DEFAULT;\n\tset_bit(YB_KBD_IS_ON, &data->flags);\n\tset_bit(YB_DIGITIZER_IS_ON, &data->flags);\n\tINIT_WORK(&data->work, yogabook_work);\n\n\tyogabook_pen_led.dev_id = dev_name(dev);\n\tled_add_lookup(&yogabook_pen_led);\n\tdata->pen_led = devm_led_get(dev, \"pen-icon-led\");\n\tled_remove_lookup(&yogabook_pen_led);\n\n\tif (IS_ERR(data->pen_led))\n\t\treturn dev_err_probe(dev, PTR_ERR(data->pen_led), \"Getting pen icon LED\\n\");\n\n\tyogabook_gpios.dev_id = dev_name(dev);\n\tgpiod_add_lookup_table(&yogabook_gpios);\n\tdata->backside_hall_gpio = devm_gpiod_get(dev, \"backside_hall_sw\", GPIOD_IN);\n\tgpiod_remove_lookup_table(&yogabook_gpios);\n\n\tif (IS_ERR(data->backside_hall_gpio))\n\t\treturn dev_err_probe(dev, PTR_ERR(data->backside_hall_gpio),\n\t\t\t\t     \"Getting backside_hall_sw GPIO\\n\");\n\n\tr = gpiod_to_irq(data->backside_hall_gpio);\n\tif (r < 0)\n\t\treturn dev_err_probe(dev, r, \"Getting backside_hall_sw IRQ\\n\");\n\n\tdata->backside_hall_irq = r;\n\n\t \n\tdata->set_kbd_backlight(data, YB_KBD_BL_DEFAULT);\n\n\tr = request_irq(data->backside_hall_irq, yogabook_backside_hall_irq,\n\t\t\tIRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING,\n\t\t\t\"backside_hall_sw\", data);\n\tif (r)\n\t\treturn dev_err_probe(dev, r, \"Requesting backside_hall_sw IRQ\\n\");\n\n\tschedule_work(&data->work);\n\n\tdata->kbd_bl_led.name = kbd_bl_led_name;\n\tdata->kbd_bl_led.brightness_set_blocking = kbd_brightness_set;\n\tdata->kbd_bl_led.brightness_get = kbd_brightness_get;\n\tdata->kbd_bl_led.max_brightness = YB_KBD_BL_MAX;\n\n\tr = devm_led_classdev_register(dev, &data->kbd_bl_led);\n\tif (r < 0) {\n\t\tdev_err_probe(dev, r, \"Registering backlight LED device\\n\");\n\t\tgoto error_free_irq;\n\t}\n\n\tdev_set_drvdata(dev, data);\n\treturn 0;\n\nerror_free_irq:\n\tfree_irq(data->backside_hall_irq, data);\n\tcancel_work_sync(&data->work);\n\treturn r;\n}\n\nstatic void yogabook_remove(struct yogabook_data *data)\n{\n\tint r = 0;\n\n\tfree_irq(data->backside_hall_irq, data);\n\tcancel_work_sync(&data->work);\n\n\tif (!test_bit(YB_KBD_IS_ON, &data->flags))\n\t\tr |= device_reprobe(data->kbd_dev);\n\n\tif (!test_bit(YB_DIGITIZER_IS_ON, &data->flags))\n\t\tr |= device_reprobe(data->dig_dev);\n\n\tif (r)\n\t\tdev_warn(data->dev, \"Reprobe of devices failed\\n\");\n}\n\nstatic int yogabook_suspend(struct device *dev)\n{\n\tstruct yogabook_data *data = dev_get_drvdata(dev);\n\n\tset_bit(YB_SUSPENDED, &data->flags);\n\tflush_work(&data->work);\n\n\tif (test_bit(YB_KBD_IS_ON, &data->flags))\n\t\tdata->set_kbd_backlight(data, 0);\n\n\treturn 0;\n}\n\nstatic int yogabook_resume(struct device *dev)\n{\n\tstruct yogabook_data *data = dev_get_drvdata(dev);\n\n\tif (test_bit(YB_KBD_IS_ON, &data->flags))\n\t\tdata->set_kbd_backlight(data, data->brightness);\n\n\tclear_bit(YB_SUSPENDED, &data->flags);\n\n\t \n\tschedule_work(&data->work);\n\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(yogabook_pm_ops, yogabook_suspend, yogabook_resume);\n\n \n\n \nstatic int yogabook_wmi_set_kbd_backlight(struct yogabook_data *data,\n\t\t\t\t\t  uint8_t level)\n{\n\tstruct acpi_buffer output = { ACPI_ALLOCATE_BUFFER, NULL };\n\tstruct acpi_object_list input;\n\tunion acpi_object param;\n\tacpi_status status;\n\n\tdev_dbg(data->dev, \"Set KBLC level to %u\\n\", level);\n\n\t \n\tacpi_device_set_power(data->kbd_adev, ACPI_STATE_D0);\n\n\tinput.count = 1;\n\tinput.pointer = &param;\n\n\tparam.type = ACPI_TYPE_INTEGER;\n\tparam.integer.value = YB_KBD_BL_MAX - level;\n\n\tstatus = acpi_evaluate_object(acpi_device_handle(data->kbd_adev), \"KBLC\",\n\t\t\t\t      &input, &output);\n\tif (ACPI_FAILURE(status)) {\n\t\tdev_err(data->dev, \"Failed to call KBLC method: 0x%x\\n\", status);\n\t\treturn status;\n\t}\n\n\tkfree(output.pointer);\n\treturn 0;\n}\n\nstatic int yogabook_wmi_probe(struct wmi_device *wdev, const void *context)\n{\n\tstruct device *dev = &wdev->dev;\n\tstruct yogabook_data *data;\n\tint r;\n\n\tdata = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);\n\tif (data == NULL)\n\t\treturn -ENOMEM;\n\n\tdata->kbd_adev = acpi_dev_get_first_match_dev(\"GDIX1001\", NULL, -1);\n\tif (!data->kbd_adev)\n\t\treturn dev_err_probe(dev, -ENODEV, \"Cannot find the touchpad device in ACPI tables\\n\");\n\n\tdata->dig_adev = acpi_dev_get_first_match_dev(\"WCOM0019\", NULL, -1);\n\tif (!data->dig_adev) {\n\t\tr = dev_err_probe(dev, -ENODEV, \"Cannot find the digitizer device in ACPI tables\\n\");\n\t\tgoto error_put_devs;\n\t}\n\n\tdata->kbd_dev = get_device(acpi_get_first_physical_node(data->kbd_adev));\n\tif (!data->kbd_dev || !data->kbd_dev->driver) {\n\t\tr = -EPROBE_DEFER;\n\t\tgoto error_put_devs;\n\t}\n\n\tdata->dig_dev = get_device(acpi_get_first_physical_node(data->dig_adev));\n\tif (!data->dig_dev || !data->dig_dev->driver) {\n\t\tr = -EPROBE_DEFER;\n\t\tgoto error_put_devs;\n\t}\n\n\tdata->set_kbd_backlight = yogabook_wmi_set_kbd_backlight;\n\n\tr = yogabook_probe(dev, data, \"ybwmi::kbd_backlight\");\n\tif (r)\n\t\tgoto error_put_devs;\n\n\treturn 0;\n\nerror_put_devs:\n\tput_device(data->dig_dev);\n\tput_device(data->kbd_dev);\n\tacpi_dev_put(data->dig_adev);\n\tacpi_dev_put(data->kbd_adev);\n\treturn r;\n}\n\nstatic void yogabook_wmi_remove(struct wmi_device *wdev)\n{\n\tstruct yogabook_data *data = dev_get_drvdata(&wdev->dev);\n\n\tyogabook_remove(data);\n\n\tput_device(data->dig_dev);\n\tput_device(data->kbd_dev);\n\tacpi_dev_put(data->dig_adev);\n\tacpi_dev_put(data->kbd_adev);\n}\n\nstatic void yogabook_wmi_notify(struct wmi_device *wdev, union acpi_object *dummy)\n{\n\tyogabook_toggle_digitizer_mode(dev_get_drvdata(&wdev->dev));\n}\n\nstatic const struct wmi_device_id yogabook_wmi_id_table[] = {\n\t{\n\t\t.guid_string = YB_MBTN_EVENT_GUID,\n\t},\n\t{ }  \n};\nMODULE_DEVICE_TABLE(wmi, yogabook_wmi_id_table);\n\nstatic struct wmi_driver yogabook_wmi_driver = {\n\t.driver = {\n\t\t.name = \"yogabook-wmi\",\n\t\t.pm = pm_sleep_ptr(&yogabook_pm_ops),\n\t},\n\t.no_notify_data = true,\n\t.id_table = yogabook_wmi_id_table,\n\t.probe = yogabook_wmi_probe,\n\t.remove = yogabook_wmi_remove,\n\t.notify = yogabook_wmi_notify,\n};\n\n \n\nstatic struct gpiod_lookup_table yogabook_pdev_gpios = {\n\t.dev_id = YB_PDEV_NAME,\n\t.table = {\n\t\tGPIO_LOOKUP(\"INT33FF:00\", 95, \"pen_touch_event\", GPIO_ACTIVE_HIGH),\n\t\tGPIO_LOOKUP(\"INT33FF:03\", 52, \"enable_keyboard_led\", GPIO_ACTIVE_HIGH),\n\t\t{}\n\t},\n};\n\nstatic int yogabook_pdev_set_kbd_backlight(struct yogabook_data *data, u8 level)\n{\n\tstruct pwm_state state = {\n\t\t.period = YB_KBD_BL_PWM_PERIOD,\n\t\t.duty_cycle = YB_KBD_BL_PWM_PERIOD * level / YB_KBD_BL_MAX,\n\t\t.enabled = level,\n\t};\n\n\tpwm_apply_state(data->kbd_bl_pwm, &state);\n\tgpiod_set_value(data->kbd_bl_led_enable, level ? 1 : 0);\n\treturn 0;\n}\n\nstatic irqreturn_t yogabook_pen_touch_irq(int irq, void *data)\n{\n\tyogabook_toggle_digitizer_mode(data);\n\treturn IRQ_HANDLED;\n}\n\nstatic int yogabook_pdev_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct yogabook_data *data;\n\tint r;\n\n\tdata = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);\n\tif (data == NULL)\n\t\treturn -ENOMEM;\n\n\tdata->kbd_dev = bus_find_device_by_name(&i2c_bus_type, NULL, \"i2c-goodix_ts\");\n\tif (!data->kbd_dev || !data->kbd_dev->driver) {\n\t\tr = -EPROBE_DEFER;\n\t\tgoto error_put_devs;\n\t}\n\n\tdata->dig_dev = bus_find_device_by_name(&i2c_bus_type, NULL, \"i2c-wacom\");\n\tif (!data->dig_dev || !data->dig_dev->driver) {\n\t\tr = -EPROBE_DEFER;\n\t\tgoto error_put_devs;\n\t}\n\n\tgpiod_add_lookup_table(&yogabook_pdev_gpios);\n\tdata->pen_touch_event = devm_gpiod_get(dev, \"pen_touch_event\", GPIOD_IN);\n\tdata->kbd_bl_led_enable = devm_gpiod_get(dev, \"enable_keyboard_led\", GPIOD_OUT_HIGH);\n\tgpiod_remove_lookup_table(&yogabook_pdev_gpios);\n\n\tif (IS_ERR(data->pen_touch_event)) {\n\t\tr = dev_err_probe(dev, PTR_ERR(data->pen_touch_event),\n\t\t\t\t  \"Getting pen_touch_event GPIO\\n\");\n\t\tgoto error_put_devs;\n\t}\n\n\tif (IS_ERR(data->kbd_bl_led_enable)) {\n\t\tr = dev_err_probe(dev, PTR_ERR(data->kbd_bl_led_enable),\n\t\t\t\t  \"Getting enable_keyboard_led GPIO\\n\");\n\t\tgoto error_put_devs;\n\t}\n\n\tdata->kbd_bl_pwm = devm_pwm_get(dev, \"pwm_soc_lpss_2\");\n\tif (IS_ERR(data->kbd_bl_pwm)) {\n\t\tr = dev_err_probe(dev, PTR_ERR(data->kbd_bl_pwm),\n\t\t\t\t  \"Getting keyboard backlight PWM\\n\");\n\t\tgoto error_put_devs;\n\t}\n\n\tr = gpiod_to_irq(data->pen_touch_event);\n\tif (r < 0) {\n\t\tdev_err_probe(dev, r, \"Getting pen_touch_event IRQ\\n\");\n\t\tgoto error_put_devs;\n\t}\n\tdata->pen_touch_irq = r;\n\n\tr = request_irq(data->pen_touch_irq, yogabook_pen_touch_irq, IRQF_TRIGGER_FALLING,\n\t\t\t\"pen_touch_event\", data);\n\tif (r) {\n\t\tdev_err_probe(dev, r, \"Requesting pen_touch_event IRQ\\n\");\n\t\tgoto error_put_devs;\n\t}\n\n\tdata->set_kbd_backlight = yogabook_pdev_set_kbd_backlight;\n\n\tr = yogabook_probe(dev, data, \"yogabook::kbd_backlight\");\n\tif (r)\n\t\tgoto error_free_irq;\n\n\treturn 0;\n\nerror_free_irq:\n\tfree_irq(data->pen_touch_irq, data);\n\tcancel_work_sync(&data->work);\nerror_put_devs:\n\tput_device(data->dig_dev);\n\tput_device(data->kbd_dev);\n\treturn r;\n}\n\nstatic void yogabook_pdev_remove(struct platform_device *pdev)\n{\n\tstruct yogabook_data *data = platform_get_drvdata(pdev);\n\n\tyogabook_remove(data);\n\tfree_irq(data->pen_touch_irq, data);\n\tcancel_work_sync(&data->work);\n\tput_device(data->dig_dev);\n\tput_device(data->kbd_dev);\n}\n\nstatic struct platform_driver yogabook_pdev_driver = {\n\t.probe = yogabook_pdev_probe,\n\t.remove_new = yogabook_pdev_remove,\n\t.driver = {\n\t\t.name = YB_PDEV_NAME,\n\t\t.pm = pm_sleep_ptr(&yogabook_pm_ops),\n\t},\n};\n\nstatic int __init yogabook_module_init(void)\n{\n\tint r;\n\n\tr = wmi_driver_register(&yogabook_wmi_driver);\n\tif (r)\n\t\treturn r;\n\n\tr = platform_driver_register(&yogabook_pdev_driver);\n\tif (r)\n\t\twmi_driver_unregister(&yogabook_wmi_driver);\n\n\treturn r;\n}\n\nstatic void __exit yogabook_module_exit(void)\n{\n\tplatform_driver_unregister(&yogabook_pdev_driver);\n\twmi_driver_unregister(&yogabook_wmi_driver);\n}\n\nmodule_init(yogabook_module_init);\nmodule_exit(yogabook_module_exit);\n\nMODULE_ALIAS(\"platform:\" YB_PDEV_NAME);\nMODULE_AUTHOR(\"Yauhen Kharuzhy\");\nMODULE_DESCRIPTION(\"Lenovo Yoga Book driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}