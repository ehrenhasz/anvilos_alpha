{
  "module_name": "sony-laptop.c",
  "hash_id": "52f2ec48edcbcb1759bf08cf880467c62840199c42ac8ef3271c13a684d6288b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/x86/sony-laptop.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/init.h>\n#include <linux/types.h>\n#include <linux/backlight.h>\n#include <linux/platform_device.h>\n#include <linux/err.h>\n#include <linux/dmi.h>\n#include <linux/pci.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n#include <linux/input.h>\n#include <linux/kfifo.h>\n#include <linux/workqueue.h>\n#include <linux/acpi.h>\n#include <linux/slab.h>\n#include <linux/sonypi.h>\n#include <linux/sony-laptop.h>\n#include <linux/rfkill.h>\n#ifdef CONFIG_SONYPI_COMPAT\n#include <linux/poll.h>\n#include <linux/miscdevice.h>\n#endif\n#include <linux/uaccess.h>\n#include <acpi/video.h>\n\n#define dprintk(fmt, ...)\t\t\t\\\ndo {\t\t\t\t\t\t\\\n\tif (debug)\t\t\t\t\\\n\t\tpr_warn(fmt, ##__VA_ARGS__);\t\\\n} while (0)\n\n#define SONY_NC_CLASS\t\t\"sony-nc\"\n#define SONY_NC_HID\t\t\"SNY5001\"\n#define SONY_NC_DRIVER_NAME\t\"Sony Notebook Control Driver\"\n\n#define SONY_PIC_CLASS\t\t\"sony-pic\"\n#define SONY_PIC_HID\t\t\"SNY6001\"\n#define SONY_PIC_DRIVER_NAME\t\"Sony Programmable IO Control Driver\"\n\nMODULE_AUTHOR(\"Stelian Pop, Mattia Dongili\");\nMODULE_DESCRIPTION(\"Sony laptop extras driver (SPIC and SNC ACPI device)\");\nMODULE_LICENSE(\"GPL\");\n\nstatic int debug;\nmodule_param(debug, int, 0);\nMODULE_PARM_DESC(debug, \"set this to 1 (and RTFM) if you want to help \"\n\t\t \"the development of this driver\");\n\nstatic int no_spic;\t\t \nmodule_param(no_spic, int, 0444);\nMODULE_PARM_DESC(no_spic,\n\t\t \"set this if you don't want to enable the SPIC device\");\n\nstatic int compat;\t\t \nmodule_param(compat, int, 0444);\nMODULE_PARM_DESC(compat,\n\t\t \"set this if you want to enable backward compatibility mode\");\n\nstatic unsigned long mask = 0xffffffff;\nmodule_param(mask, ulong, 0644);\nMODULE_PARM_DESC(mask,\n\t\t \"set this to the mask of event you want to enable (see doc)\");\n\nstatic int camera;\t\t \nmodule_param(camera, int, 0444);\nMODULE_PARM_DESC(camera,\n\t\t \"set this to 1 to enable Motion Eye camera controls \"\n\t\t \"(only use it if you have a C1VE or C1VN model)\");\n\n#ifdef CONFIG_SONYPI_COMPAT\nstatic int minor = -1;\nmodule_param(minor, int, 0);\nMODULE_PARM_DESC(minor,\n\t\t \"minor number of the misc device for the SPIC compatibility code, \"\n\t\t \"default is -1 (automatic)\");\n#endif\n\nstatic int kbd_backlight = -1;\nmodule_param(kbd_backlight, int, 0444);\nMODULE_PARM_DESC(kbd_backlight,\n\t\t \"set this to 0 to disable keyboard backlight, \"\n\t\t \"1 to enable it with automatic control and 2 to have it always \"\n\t\t \"on (default: no change from current value)\");\n\nstatic int kbd_backlight_timeout = -1;\nmodule_param(kbd_backlight_timeout, int, 0444);\nMODULE_PARM_DESC(kbd_backlight_timeout,\n\t\t \"meaningful values vary from 0 to 3 and their meaning depends \"\n\t\t \"on the model (default: no change from current value)\");\n\n#ifdef CONFIG_PM_SLEEP\nstatic void sony_nc_thermal_resume(void);\n#endif\nstatic int sony_nc_kbd_backlight_setup(struct platform_device *pd,\n\t\tunsigned int handle);\nstatic void sony_nc_kbd_backlight_cleanup(struct platform_device *pd,\n\t\tunsigned int handle);\n\nstatic int sony_nc_battery_care_setup(struct platform_device *pd,\n\t\tunsigned int handle);\nstatic void sony_nc_battery_care_cleanup(struct platform_device *pd);\n\nstatic int sony_nc_thermal_setup(struct platform_device *pd);\nstatic void sony_nc_thermal_cleanup(struct platform_device *pd);\n\nstatic int sony_nc_lid_resume_setup(struct platform_device *pd,\n\t\t\t\t    unsigned int handle);\nstatic void sony_nc_lid_resume_cleanup(struct platform_device *pd);\n\nstatic int sony_nc_gfx_switch_setup(struct platform_device *pd,\n\t\tunsigned int handle);\nstatic void sony_nc_gfx_switch_cleanup(struct platform_device *pd);\nstatic int __sony_nc_gfx_switch_status_get(void);\n\nstatic int sony_nc_highspeed_charging_setup(struct platform_device *pd);\nstatic void sony_nc_highspeed_charging_cleanup(struct platform_device *pd);\n\nstatic int sony_nc_lowbatt_setup(struct platform_device *pd);\nstatic void sony_nc_lowbatt_cleanup(struct platform_device *pd);\n\nstatic int sony_nc_fanspeed_setup(struct platform_device *pd);\nstatic void sony_nc_fanspeed_cleanup(struct platform_device *pd);\n\nstatic int sony_nc_usb_charge_setup(struct platform_device *pd);\nstatic void sony_nc_usb_charge_cleanup(struct platform_device *pd);\n\nstatic int sony_nc_panelid_setup(struct platform_device *pd);\nstatic void sony_nc_panelid_cleanup(struct platform_device *pd);\n\nstatic int sony_nc_smart_conn_setup(struct platform_device *pd);\nstatic void sony_nc_smart_conn_cleanup(struct platform_device *pd);\n\nstatic int sony_nc_touchpad_setup(struct platform_device *pd,\n\t\t\t\t  unsigned int handle);\nstatic void sony_nc_touchpad_cleanup(struct platform_device *pd);\n\nenum sony_nc_rfkill {\n\tSONY_WIFI,\n\tSONY_BLUETOOTH,\n\tSONY_WWAN,\n\tSONY_WIMAX,\n\tN_SONY_RFKILL,\n};\n\nstatic int sony_rfkill_handle;\nstatic struct rfkill *sony_rfkill_devices[N_SONY_RFKILL];\nstatic int sony_rfkill_address[N_SONY_RFKILL] = {0x300, 0x500, 0x700, 0x900};\nstatic int sony_nc_rfkill_setup(struct acpi_device *device,\n\t\tunsigned int handle);\nstatic void sony_nc_rfkill_cleanup(void);\nstatic void sony_nc_rfkill_update(void);\n\n \n\n#define SONY_LAPTOP_BUF_SIZE\t128\nstruct sony_laptop_input_s {\n\tatomic_t\t\tusers;\n\tstruct input_dev\t*jog_dev;\n\tstruct input_dev\t*key_dev;\n\tstruct kfifo\t\tfifo;\n\tspinlock_t\t\tfifo_lock;\n\tstruct timer_list\trelease_key_timer;\n};\n\nstatic struct sony_laptop_input_s sony_laptop_input = {\n\t.users = ATOMIC_INIT(0),\n};\n\nstruct sony_laptop_keypress {\n\tstruct input_dev *dev;\n\tint key;\n};\n\n \nstatic const int sony_laptop_input_index[] = {\n\t-1,\t \n\t-1,\t \n\t-1,\t \n\t-1,\t \n\t-1,\t \n\t-1,\t \n\t-1,\t \n\t 0,\t \n\t 1,\t \n\t 2,\t \n\t 3,\t \n\t 4,\t \n\t 5,\t \n\t 6,\t \n\t 7,\t \n\t 8,\t \n\t 9,\t \n\t10,\t \n\t11,\t \n\t12,\t \n\t13,\t \n\t14,\t \n\t15,\t \n\t16,\t \n\t17,\t \n\t18,\t \n\t19,\t \n\t20,\t \n\t21,\t \n\t22,\t \n\t23,\t \n\t24,\t \n\t25,\t \n\t26,\t \n\t27,\t \n\t28,\t \n\t-1,\t \n\t-1,\t \n\t29,\t \n\t30,\t \n\t31,\t \n\t32,\t \n\t33,\t \n\t34,\t \n\t35,\t \n\t36,\t \n\t37,\t \n\t38,\t \n\t39,\t \n\t40,\t \n\t41,\t \n\t42,\t \n\t43,\t \n\t44,\t \n\t45,\t \n\t46,\t \n\t-1,\t \n\t-1,\t \n\t-1,\t \n\t-1,\t \n\t47,\t \n\t48,\t \n\t49,\t \n\t50,\t \n\t51,\t \n\t52,\t \n\t53,\t \n\t54,\t \n\t55,\t \n\t56,\t \n\t57,\t \n\t-1,\t \n\t58,\t \n\t59,\t \n};\n\nstatic int sony_laptop_input_keycode_map[] = {\n\tKEY_CAMERA,\t \n\tKEY_RESERVED,\t \n\tKEY_RESERVED,\t \n\tKEY_RESERVED,\t \n\tKEY_FN_ESC,\t \n\tKEY_FN_F1,\t \n\tKEY_FN_F2,\t \n\tKEY_FN_F3,\t \n\tKEY_FN_F4,\t \n\tKEY_FN_F5,\t \n\tKEY_FN_F6,\t \n\tKEY_FN_F7,\t \n\tKEY_FN_F8,\t \n\tKEY_FN_F9,\t \n\tKEY_FN_F10,\t \n\tKEY_FN_F11,\t \n\tKEY_FN_F12,\t \n\tKEY_FN_1,\t \n\tKEY_FN_2,\t \n\tKEY_FN_D,\t \n\tKEY_FN_E,\t \n\tKEY_FN_F,\t \n\tKEY_FN_S,\t \n\tKEY_FN_B,\t \n\tKEY_BLUETOOTH,\t \n\tKEY_PROG1,\t \n\tKEY_PROG2,\t \n\tKEY_PROG3,\t \n\tKEY_BACK,\t \n\tKEY_BLUETOOTH,\t \n\tKEY_BLUETOOTH,\t \n\tKEY_HELP,\t \n\tKEY_FN,\t\t \n\tKEY_RESERVED,\t \n\tKEY_RESERVED,\t \n\tKEY_RESERVED,\t \n\tKEY_RESERVED,\t \n\tKEY_RESERVED,\t \n\tKEY_RESERVED,\t \n\tKEY_RESERVED,\t \n\tKEY_RESERVED,\t \n\tKEY_ZOOM,\t \n\tBTN_THUMB,\t \n\tKEY_RESERVED,\t \n\tKEY_RESERVED,\t \n\tKEY_RESERVED,\t \n\tKEY_RESERVED,\t \n\tKEY_WLAN,\t \n\tKEY_WLAN,\t \n\tKEY_ZOOMIN,\t \n\tKEY_ZOOMOUT,\t \n\tKEY_EJECTCD,\t \n\tKEY_F13,\t \n\tKEY_PROG4,\t \n\tKEY_F14,\t \n\tKEY_F15,\t \n\tKEY_VOLUMEUP,\t \n\tKEY_VOLUMEDOWN,\t \n\tKEY_MEDIA,\t \n\tKEY_VENDOR,\t \n};\n\n \nstatic void do_sony_laptop_release_key(struct timer_list *unused)\n{\n\tstruct sony_laptop_keypress kp;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&sony_laptop_input.fifo_lock, flags);\n\n\tif (kfifo_out(&sony_laptop_input.fifo,\n\t\t      (unsigned char *)&kp, sizeof(kp)) == sizeof(kp)) {\n\t\tinput_report_key(kp.dev, kp.key, 0);\n\t\tinput_sync(kp.dev);\n\t}\n\n\t \n\tif (kfifo_len(&sony_laptop_input.fifo) != 0)\n\t\tmod_timer(&sony_laptop_input.release_key_timer,\n\t\t\t  jiffies + msecs_to_jiffies(10));\n\n\tspin_unlock_irqrestore(&sony_laptop_input.fifo_lock, flags);\n}\n\n \nstatic void sony_laptop_report_input_event(u8 event)\n{\n\tstruct input_dev *jog_dev = sony_laptop_input.jog_dev;\n\tstruct input_dev *key_dev = sony_laptop_input.key_dev;\n\tstruct sony_laptop_keypress kp = { NULL };\n\tint scancode = -1;\n\n\tif (event == SONYPI_EVENT_FNKEY_RELEASED ||\n\t\t\tevent == SONYPI_EVENT_ANYBUTTON_RELEASED) {\n\t\t \n\t\treturn;\n\t}\n\n\t \n\tswitch (event) {\n\t \n\tcase SONYPI_EVENT_JOGDIAL_UP:\n\tcase SONYPI_EVENT_JOGDIAL_UP_PRESSED:\n\t\tinput_report_rel(jog_dev, REL_WHEEL, 1);\n\t\tinput_sync(jog_dev);\n\t\treturn;\n\n\tcase SONYPI_EVENT_JOGDIAL_DOWN:\n\tcase SONYPI_EVENT_JOGDIAL_DOWN_PRESSED:\n\t\tinput_report_rel(jog_dev, REL_WHEEL, -1);\n\t\tinput_sync(jog_dev);\n\t\treturn;\n\n\t \n\tcase SONYPI_EVENT_JOGDIAL_PRESSED:\n\t\tkp.key = BTN_MIDDLE;\n\t\tkp.dev = jog_dev;\n\t\tbreak;\n\n\tdefault:\n\t\tif (event >= ARRAY_SIZE(sony_laptop_input_index)) {\n\t\t\tdprintk(\"sony_laptop_report_input_event, event not known: %d\\n\", event);\n\t\t\tbreak;\n\t\t}\n\t\tif ((scancode = sony_laptop_input_index[event]) != -1) {\n\t\t\tkp.key = sony_laptop_input_keycode_map[scancode];\n\t\t\tif (kp.key != KEY_UNKNOWN)\n\t\t\t\tkp.dev = key_dev;\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (kp.dev) {\n\t\t \n\t\tif (scancode != -1)\n\t\t\tinput_event(kp.dev, EV_MSC, MSC_SCAN, scancode);\n\t\tinput_report_key(kp.dev, kp.key, 1);\n\t\tinput_sync(kp.dev);\n\n\t\t \n\t\tkfifo_in_locked(&sony_laptop_input.fifo,\n\t\t\t\t(unsigned char *)&kp, sizeof(kp),\n\t\t\t\t&sony_laptop_input.fifo_lock);\n\t\tmod_timer(&sony_laptop_input.release_key_timer,\n\t\t\t  jiffies + msecs_to_jiffies(10));\n\t} else\n\t\tdprintk(\"unknown input event %.2x\\n\", event);\n}\n\nstatic int sony_laptop_setup_input(struct acpi_device *acpi_device)\n{\n\tstruct input_dev *jog_dev;\n\tstruct input_dev *key_dev;\n\tint i;\n\tint error;\n\n\t \n\tif (atomic_add_return(1, &sony_laptop_input.users) > 1)\n\t\treturn 0;\n\n\t \n\tspin_lock_init(&sony_laptop_input.fifo_lock);\n\terror = kfifo_alloc(&sony_laptop_input.fifo,\n\t\t\t    SONY_LAPTOP_BUF_SIZE, GFP_KERNEL);\n\tif (error) {\n\t\tpr_err(\"kfifo_alloc failed\\n\");\n\t\tgoto err_dec_users;\n\t}\n\n\ttimer_setup(&sony_laptop_input.release_key_timer,\n\t\t    do_sony_laptop_release_key, 0);\n\n\t \n\tkey_dev = input_allocate_device();\n\tif (!key_dev) {\n\t\terror = -ENOMEM;\n\t\tgoto err_free_kfifo;\n\t}\n\n\tkey_dev->name = \"Sony Vaio Keys\";\n\tkey_dev->id.bustype = BUS_ISA;\n\tkey_dev->id.vendor = PCI_VENDOR_ID_SONY;\n\tkey_dev->dev.parent = &acpi_device->dev;\n\n\t \n\tinput_set_capability(key_dev, EV_MSC, MSC_SCAN);\n\n\t__set_bit(EV_KEY, key_dev->evbit);\n\tkey_dev->keycodesize = sizeof(sony_laptop_input_keycode_map[0]);\n\tkey_dev->keycodemax = ARRAY_SIZE(sony_laptop_input_keycode_map);\n\tkey_dev->keycode = &sony_laptop_input_keycode_map;\n\tfor (i = 0; i < ARRAY_SIZE(sony_laptop_input_keycode_map); i++)\n\t\t__set_bit(sony_laptop_input_keycode_map[i], key_dev->keybit);\n\t__clear_bit(KEY_RESERVED, key_dev->keybit);\n\n\terror = input_register_device(key_dev);\n\tif (error)\n\t\tgoto err_free_keydev;\n\n\tsony_laptop_input.key_dev = key_dev;\n\n\t \n\tjog_dev = input_allocate_device();\n\tif (!jog_dev) {\n\t\terror = -ENOMEM;\n\t\tgoto err_unregister_keydev;\n\t}\n\n\tjog_dev->name = \"Sony Vaio Jogdial\";\n\tjog_dev->id.bustype = BUS_ISA;\n\tjog_dev->id.vendor = PCI_VENDOR_ID_SONY;\n\tjog_dev->dev.parent = &acpi_device->dev;\n\n\tinput_set_capability(jog_dev, EV_KEY, BTN_MIDDLE);\n\tinput_set_capability(jog_dev, EV_REL, REL_WHEEL);\n\n\terror = input_register_device(jog_dev);\n\tif (error)\n\t\tgoto err_free_jogdev;\n\n\tsony_laptop_input.jog_dev = jog_dev;\n\n\treturn 0;\n\nerr_free_jogdev:\n\tinput_free_device(jog_dev);\n\nerr_unregister_keydev:\n\tinput_unregister_device(key_dev);\n\t \n\tkey_dev = NULL;\n\nerr_free_keydev:\n\tinput_free_device(key_dev);\n\nerr_free_kfifo:\n\tkfifo_free(&sony_laptop_input.fifo);\n\nerr_dec_users:\n\tatomic_dec(&sony_laptop_input.users);\n\treturn error;\n}\n\nstatic void sony_laptop_remove_input(void)\n{\n\tstruct sony_laptop_keypress kp = { NULL };\n\n\t \n\tif (!atomic_dec_and_test(&sony_laptop_input.users))\n\t\treturn;\n\n\tdel_timer_sync(&sony_laptop_input.release_key_timer);\n\n\t \n\twhile (kfifo_out(&sony_laptop_input.fifo,\n\t\t\t (unsigned char *)&kp, sizeof(kp)) == sizeof(kp)) {\n\t\tinput_report_key(kp.dev, kp.key, 0);\n\t\tinput_sync(kp.dev);\n\t}\n\n\t \n\tinput_unregister_device(sony_laptop_input.key_dev);\n\tsony_laptop_input.key_dev = NULL;\n\n\tif (sony_laptop_input.jog_dev) {\n\t\tinput_unregister_device(sony_laptop_input.jog_dev);\n\t\tsony_laptop_input.jog_dev = NULL;\n\t}\n\n\tkfifo_free(&sony_laptop_input.fifo);\n}\n\n \n\nstatic atomic_t sony_pf_users = ATOMIC_INIT(0);\nstatic struct platform_driver sony_pf_driver = {\n\t.driver = {\n\t\t   .name = \"sony-laptop\",\n\t\t   }\n};\nstatic struct platform_device *sony_pf_device;\n\nstatic int sony_pf_add(void)\n{\n\tint ret = 0;\n\n\t \n\tif (atomic_add_return(1, &sony_pf_users) > 1)\n\t\treturn 0;\n\n\tret = platform_driver_register(&sony_pf_driver);\n\tif (ret)\n\t\tgoto out;\n\n\tsony_pf_device = platform_device_alloc(\"sony-laptop\", PLATFORM_DEVID_NONE);\n\tif (!sony_pf_device) {\n\t\tret = -ENOMEM;\n\t\tgoto out_platform_registered;\n\t}\n\n\tret = platform_device_add(sony_pf_device);\n\tif (ret)\n\t\tgoto out_platform_alloced;\n\n\treturn 0;\n\n      out_platform_alloced:\n\tplatform_device_put(sony_pf_device);\n\tsony_pf_device = NULL;\n      out_platform_registered:\n\tplatform_driver_unregister(&sony_pf_driver);\n      out:\n\tatomic_dec(&sony_pf_users);\n\treturn ret;\n}\n\nstatic void sony_pf_remove(void)\n{\n\t \n\tif (!atomic_dec_and_test(&sony_pf_users))\n\t\treturn;\n\n\tplatform_device_unregister(sony_pf_device);\n\tplatform_driver_unregister(&sony_pf_driver);\n}\n\n \n\n \n#define SONY_MAX_BRIGHTNESS\t8\n\n#define SNC_VALIDATE_IN\t\t0\n#define SNC_VALIDATE_OUT\t1\n\nstatic ssize_t sony_nc_sysfs_show(struct device *, struct device_attribute *,\n\t\t\t      char *);\nstatic ssize_t sony_nc_sysfs_store(struct device *, struct device_attribute *,\n\t\t\t       const char *, size_t);\nstatic int boolean_validate(const int, const int);\nstatic int brightness_default_validate(const int, const int);\n\nstruct sony_nc_value {\n\tchar *name;\t\t \n\tchar **acpiget;\t\t \n\tchar **acpiset;\t\t \n\tint (*validate)(const int, const int);\t \n\tint value;\t\t \n\tint valid;\t\t \n\tint debug;\t\t \n\tstruct device_attribute devattr;\t \n};\n\n#define SNC_HANDLE_NAMES(_name, _values...) \\\n\tstatic char *snc_##_name[] = { _values, NULL }\n\n#define SNC_HANDLE(_name, _getters, _setters, _validate, _debug) \\\n\t{ \\\n\t\t.name\t\t= __stringify(_name), \\\n\t\t.acpiget\t= _getters, \\\n\t\t.acpiset\t= _setters, \\\n\t\t.validate\t= _validate, \\\n\t\t.debug\t\t= _debug, \\\n\t\t.devattr\t= __ATTR(_name, 0, sony_nc_sysfs_show, sony_nc_sysfs_store), \\\n\t}\n\n#define SNC_HANDLE_NULL\t{ .name = NULL }\n\nSNC_HANDLE_NAMES(fnkey_get, \"GHKE\");\n\nSNC_HANDLE_NAMES(brightness_def_get, \"GPBR\");\nSNC_HANDLE_NAMES(brightness_def_set, \"SPBR\");\n\nSNC_HANDLE_NAMES(cdpower_get, \"GCDP\");\nSNC_HANDLE_NAMES(cdpower_set, \"SCDP\", \"CDPW\");\n\nSNC_HANDLE_NAMES(audiopower_get, \"GAZP\");\nSNC_HANDLE_NAMES(audiopower_set, \"AZPW\");\n\nSNC_HANDLE_NAMES(lanpower_get, \"GLNP\");\nSNC_HANDLE_NAMES(lanpower_set, \"LNPW\");\n\nSNC_HANDLE_NAMES(lidstate_get, \"GLID\");\n\nSNC_HANDLE_NAMES(indicatorlamp_get, \"GILS\");\nSNC_HANDLE_NAMES(indicatorlamp_set, \"SILS\");\n\nSNC_HANDLE_NAMES(gainbass_get, \"GMGB\");\nSNC_HANDLE_NAMES(gainbass_set, \"CMGB\");\n\nSNC_HANDLE_NAMES(PID_get, \"GPID\");\n\nSNC_HANDLE_NAMES(CTR_get, \"GCTR\");\nSNC_HANDLE_NAMES(CTR_set, \"SCTR\");\n\nSNC_HANDLE_NAMES(PCR_get, \"GPCR\");\nSNC_HANDLE_NAMES(PCR_set, \"SPCR\");\n\nSNC_HANDLE_NAMES(CMI_get, \"GCMI\");\nSNC_HANDLE_NAMES(CMI_set, \"SCMI\");\n\nstatic struct sony_nc_value sony_nc_values[] = {\n\tSNC_HANDLE(brightness_default, snc_brightness_def_get,\n\t\t\tsnc_brightness_def_set, brightness_default_validate, 0),\n\tSNC_HANDLE(fnkey, snc_fnkey_get, NULL, NULL, 0),\n\tSNC_HANDLE(cdpower, snc_cdpower_get, snc_cdpower_set, boolean_validate, 0),\n\tSNC_HANDLE(audiopower, snc_audiopower_get, snc_audiopower_set,\n\t\t\tboolean_validate, 0),\n\tSNC_HANDLE(lanpower, snc_lanpower_get, snc_lanpower_set,\n\t\t\tboolean_validate, 1),\n\tSNC_HANDLE(lidstate, snc_lidstate_get, NULL,\n\t\t\tboolean_validate, 0),\n\tSNC_HANDLE(indicatorlamp, snc_indicatorlamp_get, snc_indicatorlamp_set,\n\t\t\tboolean_validate, 0),\n\tSNC_HANDLE(gainbass, snc_gainbass_get, snc_gainbass_set,\n\t\t\tboolean_validate, 0),\n\t \n\tSNC_HANDLE(PID, snc_PID_get, NULL, NULL, 1),\n\tSNC_HANDLE(CTR, snc_CTR_get, snc_CTR_set, NULL, 1),\n\tSNC_HANDLE(PCR, snc_PCR_get, snc_PCR_set, NULL, 1),\n\tSNC_HANDLE(CMI, snc_CMI_get, snc_CMI_set, NULL, 1),\n\tSNC_HANDLE_NULL\n};\n\nstatic acpi_handle sony_nc_acpi_handle;\nstatic struct acpi_device *sony_nc_acpi_device = NULL;\n\n \nstatic union acpi_object *__call_snc_method(acpi_handle handle, char *method,\n\t\tu64 *value)\n{\n\tunion acpi_object *result = NULL;\n\tstruct acpi_buffer output = { ACPI_ALLOCATE_BUFFER, NULL };\n\tacpi_status status;\n\n\tif (value) {\n\t\tstruct acpi_object_list params;\n\t\tunion acpi_object in;\n\t\tin.type = ACPI_TYPE_INTEGER;\n\t\tin.integer.value = *value;\n\t\tparams.count = 1;\n\t\tparams.pointer = &in;\n\t\tstatus = acpi_evaluate_object(handle, method, &params, &output);\n\t\tdprintk(\"__call_snc_method: [%s:0x%.8x%.8x]\\n\", method,\n\t\t\t\t(unsigned int)(*value >> 32),\n\t\t\t\t(unsigned int)*value & 0xffffffff);\n\t} else {\n\t\tstatus = acpi_evaluate_object(handle, method, NULL, &output);\n\t\tdprintk(\"__call_snc_method: [%s]\\n\", method);\n\t}\n\n\tif (ACPI_FAILURE(status)) {\n\t\tpr_err(\"Failed to evaluate [%s]\\n\", method);\n\t\treturn NULL;\n\t}\n\n\tresult = (union acpi_object *) output.pointer;\n\tif (!result)\n\t\tdprintk(\"No return object [%s]\\n\", method);\n\n\treturn result;\n}\n\n#define MIN(a, b)\t(a > b ? b : a)\nstatic int sony_nc_buffer_call(acpi_handle handle, char *name, u64 *value,\n\t\tvoid *buffer, size_t buflen)\n{\n\tint ret = 0;\n\tsize_t len;\n\tunion acpi_object *object = __call_snc_method(handle, name, value);\n\n\tif (!object)\n\t\treturn -EINVAL;\n\n\tif (!buffer) {\n\t\t \n\t} else if (object->type == ACPI_TYPE_BUFFER) {\n\t\tlen = MIN(buflen, object->buffer.length);\n\t\tmemset(buffer, 0, buflen);\n\t\tmemcpy(buffer, object->buffer.pointer, len);\n\n\t} else if (object->type == ACPI_TYPE_INTEGER) {\n\t\tlen = MIN(buflen, sizeof(object->integer.value));\n\t\tmemset(buffer, 0, buflen);\n\t\tmemcpy(buffer, &object->integer.value, len);\n\n\t} else {\n\t\tpr_warn(\"Unexpected acpi_object: 0x%x\\n\", object->type);\n\t\tret = -EINVAL;\n\t}\n\n\tkfree(object);\n\treturn ret;\n}\n\nstatic int sony_nc_int_call(acpi_handle handle, char *name, int *value, int\n\t\t*result)\n{\n\tint ret;\n\n\tif (value) {\n\t\tu64 v = *value;\n\n\t\tret = sony_nc_buffer_call(handle, name, &v, result,\n\t\t\t\tsizeof(*result));\n\t} else {\n\t\tret =  sony_nc_buffer_call(handle, name, NULL, result,\n\t\t\t\tsizeof(*result));\n\t}\n\treturn ret;\n}\n\nstruct sony_nc_handles {\n\tu16 cap[0x10];\n\tstruct device_attribute devattr;\n};\n\nstatic struct sony_nc_handles *handles;\n\nstatic ssize_t sony_nc_handles_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buffer)\n{\n\tssize_t len = 0;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(handles->cap); i++) {\n\t\tlen += sysfs_emit_at(buffer, len, \"0x%.4x \", handles->cap[i]);\n\t}\n\tlen += sysfs_emit_at(buffer, len, \"\\n\");\n\n\treturn len;\n}\n\nstatic int sony_nc_handles_setup(struct platform_device *pd)\n{\n\tint i, r, result, arg;\n\n\thandles = kzalloc(sizeof(*handles), GFP_KERNEL);\n\tif (!handles)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < ARRAY_SIZE(handles->cap); i++) {\n\t\targ = i + 0x20;\n\t\tr = sony_nc_int_call(sony_nc_acpi_handle, \"SN00\", &arg,\n\t\t\t\t\t&result);\n\t\tif (!r) {\n\t\t\tdprintk(\"caching handle 0x%.4x (offset: 0x%.2x)\\n\",\n\t\t\t\t\tresult, i);\n\t\t\thandles->cap[i] = result;\n\t\t}\n\t}\n\n\tif (debug) {\n\t\tsysfs_attr_init(&handles->devattr.attr);\n\t\thandles->devattr.attr.name = \"handles\";\n\t\thandles->devattr.attr.mode = S_IRUGO;\n\t\thandles->devattr.show = sony_nc_handles_show;\n\n\t\t \n\t\tif (device_create_file(&pd->dev, &handles->devattr)) {\n\t\t\tkfree(handles);\n\t\t\thandles = NULL;\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int sony_nc_handles_cleanup(struct platform_device *pd)\n{\n\tif (handles) {\n\t\tif (debug)\n\t\t\tdevice_remove_file(&pd->dev, &handles->devattr);\n\t\tkfree(handles);\n\t\thandles = NULL;\n\t}\n\treturn 0;\n}\n\nstatic int sony_find_snc_handle(int handle)\n{\n\tint i;\n\n\t \n\tif (!handles || !handle)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < 0x10; i++) {\n\t\tif (handles->cap[i] == handle) {\n\t\t\tdprintk(\"found handle 0x%.4x (offset: 0x%.2x)\\n\",\n\t\t\t\t\thandle, i);\n\t\t\treturn i;\n\t\t}\n\t}\n\tdprintk(\"handle 0x%.4x not found\\n\", handle);\n\treturn -EINVAL;\n}\n\nstatic int sony_call_snc_handle(int handle, int argument, int *result)\n{\n\tint arg, ret = 0;\n\tint offset = sony_find_snc_handle(handle);\n\n\tif (offset < 0)\n\t\treturn offset;\n\n\targ = offset | argument;\n\tret = sony_nc_int_call(sony_nc_acpi_handle, \"SN07\", &arg, result);\n\tdprintk(\"called SN07 with 0x%.4x (result: 0x%.4x)\\n\", arg, *result);\n\treturn ret;\n}\n\n \n\n \nstatic int brightness_default_validate(const int direction, const int value)\n{\n\tswitch (direction) {\n\t\tcase SNC_VALIDATE_OUT:\n\t\t\treturn value - 1;\n\t\tcase SNC_VALIDATE_IN:\n\t\t\tif (value >= 0 && value < SONY_MAX_BRIGHTNESS)\n\t\t\t\treturn value + 1;\n\t}\n\treturn -EINVAL;\n}\n\n \nstatic int boolean_validate(const int direction, const int value)\n{\n\tif (direction == SNC_VALIDATE_IN) {\n\t\tif (value != 0 && value != 1)\n\t\t\treturn -EINVAL;\n\t}\n\treturn value;\n}\n\n \nstatic ssize_t sony_nc_sysfs_show(struct device *dev, struct device_attribute *attr,\n\t\t\t      char *buffer)\n{\n\tint value, ret = 0;\n\tstruct sony_nc_value *item =\n\t    container_of(attr, struct sony_nc_value, devattr);\n\n\tif (!*item->acpiget)\n\t\treturn -EIO;\n\n\tret = sony_nc_int_call(sony_nc_acpi_handle, *item->acpiget, NULL,\n\t\t\t\t&value);\n\tif (ret < 0)\n\t\treturn -EIO;\n\n\tif (item->validate)\n\t\tvalue = item->validate(SNC_VALIDATE_OUT, value);\n\n\treturn sysfs_emit(buffer, \"%d\\n\", value);\n}\n\nstatic ssize_t sony_nc_sysfs_store(struct device *dev,\n\t\t\t       struct device_attribute *attr,\n\t\t\t       const char *buffer, size_t count)\n{\n\tint value;\n\tint ret = 0;\n\tstruct sony_nc_value *item =\n\t    container_of(attr, struct sony_nc_value, devattr);\n\n\tif (!item->acpiset)\n\t\treturn -EIO;\n\n\tif (count > 31)\n\t\treturn -EINVAL;\n\n\tif (kstrtoint(buffer, 10, &value))\n\t\treturn -EINVAL;\n\n\tif (item->validate)\n\t\tvalue = item->validate(SNC_VALIDATE_IN, value);\n\n\tif (value < 0)\n\t\treturn value;\n\n\tret = sony_nc_int_call(sony_nc_acpi_handle, *item->acpiset,\n\t\t\t       &value, NULL);\n\tif (ret < 0)\n\t\treturn -EIO;\n\n\titem->value = value;\n\titem->valid = 1;\n\treturn count;\n}\n\n\n \nstruct sony_backlight_props {\n\tstruct backlight_device *dev;\n\tint\t\t\thandle;\n\tint\t\t\tcmd_base;\n\tu8\t\t\toffset;\n\tu8\t\t\tmaxlvl;\n};\nstatic struct sony_backlight_props sony_bl_props;\n\nstatic int sony_backlight_update_status(struct backlight_device *bd)\n{\n\tint arg = bd->props.brightness + 1;\n\treturn sony_nc_int_call(sony_nc_acpi_handle, \"SBRT\", &arg, NULL);\n}\n\nstatic int sony_backlight_get_brightness(struct backlight_device *bd)\n{\n\tint value;\n\n\tif (sony_nc_int_call(sony_nc_acpi_handle, \"GBRT\", NULL, &value))\n\t\treturn 0;\n\t \n\treturn value - 1;\n}\n\nstatic int sony_nc_get_brightness_ng(struct backlight_device *bd)\n{\n\tint result;\n\tstruct sony_backlight_props *sdev =\n\t\t(struct sony_backlight_props *)bl_get_data(bd);\n\n\tsony_call_snc_handle(sdev->handle, sdev->cmd_base + 0x100, &result);\n\n\treturn (result & 0xff) - sdev->offset;\n}\n\nstatic int sony_nc_update_status_ng(struct backlight_device *bd)\n{\n\tint value, result;\n\tstruct sony_backlight_props *sdev =\n\t\t(struct sony_backlight_props *)bl_get_data(bd);\n\n\tvalue = bd->props.brightness + sdev->offset;\n\tif (sony_call_snc_handle(sdev->handle, sdev->cmd_base | (value << 0x10),\n\t\t\t\t&result))\n\t\treturn -EIO;\n\n\treturn value;\n}\n\nstatic const struct backlight_ops sony_backlight_ops = {\n\t.options = BL_CORE_SUSPENDRESUME,\n\t.update_status = sony_backlight_update_status,\n\t.get_brightness = sony_backlight_get_brightness,\n};\nstatic const struct backlight_ops sony_backlight_ng_ops = {\n\t.options = BL_CORE_SUSPENDRESUME,\n\t.update_status = sony_nc_update_status_ng,\n\t.get_brightness = sony_nc_get_brightness_ng,\n};\n\n \nstruct sony_nc_event {\n\tu8\tdata;\n\tu8\tevent;\n};\n\nstatic struct sony_nc_event sony_100_events[] = {\n\t{ 0x90, SONYPI_EVENT_PKEY_P1 },\n\t{ 0x10, SONYPI_EVENT_ANYBUTTON_RELEASED },\n\t{ 0x91, SONYPI_EVENT_PKEY_P2 },\n\t{ 0x11, SONYPI_EVENT_ANYBUTTON_RELEASED },\n\t{ 0x81, SONYPI_EVENT_FNKEY_F1 },\n\t{ 0x01, SONYPI_EVENT_FNKEY_RELEASED },\n\t{ 0x82, SONYPI_EVENT_FNKEY_F2 },\n\t{ 0x02, SONYPI_EVENT_FNKEY_RELEASED },\n\t{ 0x83, SONYPI_EVENT_FNKEY_F3 },\n\t{ 0x03, SONYPI_EVENT_FNKEY_RELEASED },\n\t{ 0x84, SONYPI_EVENT_FNKEY_F4 },\n\t{ 0x04, SONYPI_EVENT_FNKEY_RELEASED },\n\t{ 0x85, SONYPI_EVENT_FNKEY_F5 },\n\t{ 0x05, SONYPI_EVENT_FNKEY_RELEASED },\n\t{ 0x86, SONYPI_EVENT_FNKEY_F6 },\n\t{ 0x06, SONYPI_EVENT_FNKEY_RELEASED },\n\t{ 0x87, SONYPI_EVENT_FNKEY_F7 },\n\t{ 0x07, SONYPI_EVENT_FNKEY_RELEASED },\n\t{ 0x88, SONYPI_EVENT_FNKEY_F8 },\n\t{ 0x08, SONYPI_EVENT_FNKEY_RELEASED },\n\t{ 0x89, SONYPI_EVENT_FNKEY_F9 },\n\t{ 0x09, SONYPI_EVENT_FNKEY_RELEASED },\n\t{ 0x8A, SONYPI_EVENT_FNKEY_F10 },\n\t{ 0x0A, SONYPI_EVENT_FNKEY_RELEASED },\n\t{ 0x8B, SONYPI_EVENT_FNKEY_F11 },\n\t{ 0x0B, SONYPI_EVENT_FNKEY_RELEASED },\n\t{ 0x8C, SONYPI_EVENT_FNKEY_F12 },\n\t{ 0x0C, SONYPI_EVENT_FNKEY_RELEASED },\n\t{ 0x9d, SONYPI_EVENT_ZOOM_PRESSED },\n\t{ 0x1d, SONYPI_EVENT_ANYBUTTON_RELEASED },\n\t{ 0x9f, SONYPI_EVENT_CD_EJECT_PRESSED },\n\t{ 0x1f, SONYPI_EVENT_ANYBUTTON_RELEASED },\n\t{ 0xa1, SONYPI_EVENT_MEDIA_PRESSED },\n\t{ 0x21, SONYPI_EVENT_ANYBUTTON_RELEASED },\n\t{ 0xa4, SONYPI_EVENT_CD_EJECT_PRESSED },\n\t{ 0x24, SONYPI_EVENT_ANYBUTTON_RELEASED },\n\t{ 0xa5, SONYPI_EVENT_VENDOR_PRESSED },\n\t{ 0x25, SONYPI_EVENT_ANYBUTTON_RELEASED },\n\t{ 0xa6, SONYPI_EVENT_HELP_PRESSED },\n\t{ 0x26, SONYPI_EVENT_ANYBUTTON_RELEASED },\n\t{ 0xa8, SONYPI_EVENT_FNKEY_1 },\n\t{ 0x28, SONYPI_EVENT_ANYBUTTON_RELEASED },\n\t{ 0, 0 },\n};\n\nstatic struct sony_nc_event sony_127_events[] = {\n\t{ 0x81, SONYPI_EVENT_MODEKEY_PRESSED },\n\t{ 0x01, SONYPI_EVENT_ANYBUTTON_RELEASED },\n\t{ 0x82, SONYPI_EVENT_PKEY_P1 },\n\t{ 0x02, SONYPI_EVENT_ANYBUTTON_RELEASED },\n\t{ 0x83, SONYPI_EVENT_PKEY_P2 },\n\t{ 0x03, SONYPI_EVENT_ANYBUTTON_RELEASED },\n\t{ 0x84, SONYPI_EVENT_PKEY_P3 },\n\t{ 0x04, SONYPI_EVENT_ANYBUTTON_RELEASED },\n\t{ 0x85, SONYPI_EVENT_PKEY_P4 },\n\t{ 0x05, SONYPI_EVENT_ANYBUTTON_RELEASED },\n\t{ 0x86, SONYPI_EVENT_PKEY_P5 },\n\t{ 0x06, SONYPI_EVENT_ANYBUTTON_RELEASED },\n\t{ 0x87, SONYPI_EVENT_SETTINGKEY_PRESSED },\n\t{ 0x07, SONYPI_EVENT_ANYBUTTON_RELEASED },\n\t{ 0, 0 },\n};\n\nstatic int sony_nc_hotkeys_decode(u32 event, unsigned int handle)\n{\n\tint ret = -EINVAL;\n\tunsigned int result = 0;\n\tstruct sony_nc_event *key_event;\n\n\tif (sony_call_snc_handle(handle, 0x200, &result)) {\n\t\tdprintk(\"Unable to decode event 0x%.2x 0x%.2x\\n\", handle,\n\t\t\t\tevent);\n\t\treturn -EINVAL;\n\t}\n\n\tresult &= 0xFF;\n\n\tif (handle == 0x0100)\n\t\tkey_event = sony_100_events;\n\telse\n\t\tkey_event = sony_127_events;\n\n\tfor (; key_event->data; key_event++) {\n\t\tif (key_event->data == result) {\n\t\t\tret = key_event->event;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!key_event->data)\n\t\tpr_info(\"Unknown hotkey 0x%.2x/0x%.2x (handle 0x%.2x)\\n\",\n\t\t\t\tevent, result, handle);\n\n\treturn ret;\n}\n\n \nenum event_types {\n\tHOTKEY = 1,\n\tKILLSWITCH,\n\tGFX_SWITCH\n};\nstatic void sony_nc_notify(struct acpi_device *device, u32 event)\n{\n\tu32 real_ev = event;\n\tu8 ev_type = 0;\n\tint ret;\n\n\tdprintk(\"sony_nc_notify, event: 0x%.2x\\n\", event);\n\n\tif (event >= 0x90) {\n\t\tunsigned int result = 0;\n\t\tunsigned int arg = 0;\n\t\tunsigned int handle = 0;\n\t\tunsigned int offset = event - 0x90;\n\n\t\tif (offset >= ARRAY_SIZE(handles->cap)) {\n\t\t\tpr_err(\"Event 0x%x outside of capabilities list\\n\",\n\t\t\t\t\tevent);\n\t\t\treturn;\n\t\t}\n\t\thandle = handles->cap[offset];\n\n\t\t \n\t\tswitch (handle) {\n\t\t \n\t\tcase 0x0100:\n\t\tcase 0x0127:\n\t\t\tev_type = HOTKEY;\n\t\t\tret = sony_nc_hotkeys_decode(event, handle);\n\n\t\t\tif (ret > 0) {\n\t\t\t\tsony_laptop_report_input_event(ret);\n\t\t\t\treal_ev = ret;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\t \n\t\tcase 0x0124:\n\t\tcase 0x0135:\n\t\t\t \n\t\t\tev_type = KILLSWITCH;\n\t\t\tsony_call_snc_handle(handle, 0x0100, &result);\n\t\t\treal_ev = result & 0x03;\n\n\t\t\t \n\t\t\tif (real_ev == 1)\n\t\t\t\tsony_nc_rfkill_update();\n\n\t\t\tbreak;\n\n\t\tcase 0x0128:\n\t\tcase 0x0146:\n\t\t\t \n\t\t\tsony_call_snc_handle(handle, 0x0000, &result);\n\t\t\tdprintk(\"GFX switch event received (reason: %s)\\n\",\n\t\t\t\t\t(result == 0x1) ? \"switch change\" :\n\t\t\t\t\t(result == 0x2) ? \"output switch\" :\n\t\t\t\t\t(result == 0x3) ? \"output switch\" :\n\t\t\t\t\t\"\");\n\n\t\t\tev_type = GFX_SWITCH;\n\t\t\treal_ev = __sony_nc_gfx_switch_status_get();\n\t\t\tbreak;\n\n\t\tcase 0x015B:\n\t\t\t \n\t\t\tev_type = GFX_SWITCH;\n\t\t\treal_ev = __sony_nc_gfx_switch_status_get();\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdprintk(\"Unknown event 0x%x for handle 0x%x\\n\",\n\t\t\t\t\tevent, handle);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\targ = 1 << offset;\n\t\tsony_nc_int_call(sony_nc_acpi_handle, \"SN05\", &arg, &result);\n\n\t} else {\n\t\t \n\t\tev_type = HOTKEY;\n\t\tsony_laptop_report_input_event(real_ev);\n\t}\n\tacpi_bus_generate_netlink_event(sony_nc_acpi_device->pnp.device_class,\n\t\t\tdev_name(&sony_nc_acpi_device->dev), ev_type, real_ev);\n}\n\nstatic acpi_status sony_walk_callback(acpi_handle handle, u32 level,\n\t\t\t\t      void *context, void **return_value)\n{\n\tstruct acpi_device_info *info;\n\n\tif (ACPI_SUCCESS(acpi_get_object_info(handle, &info))) {\n\t\tpr_warn(\"method: name: %4.4s, args %X\\n\",\n\t\t\t(char *)&info->name, info->param_count);\n\n\t\tkfree(info);\n\t}\n\n\treturn AE_OK;\n}\n\n \nstatic void sony_nc_function_setup(struct acpi_device *device,\n\t\tstruct platform_device *pf_device)\n{\n\tunsigned int i, result, bitmask, arg;\n\n\tif (!handles)\n\t\treturn;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(handles->cap); i++) {\n\t\tunsigned int handle = handles->cap[i];\n\n\t\tif (!handle)\n\t\t\tcontinue;\n\n\t\tdprintk(\"setting up handle 0x%.4x\\n\", handle);\n\n\t\tswitch (handle) {\n\t\tcase 0x0100:\n\t\tcase 0x0101:\n\t\tcase 0x0127:\n\t\t\t \n\t\t\tsony_call_snc_handle(handle, 0, &result);\n\t\t\tbreak;\n\t\tcase 0x0102:\n\t\t\t \n\t\t\tsony_call_snc_handle(handle, 0x100, &result);\n\t\t\tbreak;\n\t\tcase 0x0105:\n\t\tcase 0x0148:\n\t\t\t \n\t\t\tresult = sony_nc_touchpad_setup(pf_device, handle);\n\t\t\tif (result)\n\t\t\t\tpr_err(\"couldn't set up touchpad control function (%d)\\n\",\n\t\t\t\t\t\tresult);\n\t\t\tbreak;\n\t\tcase 0x0115:\n\t\tcase 0x0136:\n\t\tcase 0x013f:\n\t\t\tresult = sony_nc_battery_care_setup(pf_device, handle);\n\t\t\tif (result)\n\t\t\t\tpr_err(\"couldn't set up battery care function (%d)\\n\",\n\t\t\t\t\t\tresult);\n\t\t\tbreak;\n\t\tcase 0x0119:\n\t\tcase 0x015D:\n\t\t\tresult = sony_nc_lid_resume_setup(pf_device, handle);\n\t\t\tif (result)\n\t\t\t\tpr_err(\"couldn't set up lid resume function (%d)\\n\",\n\t\t\t\t\t\tresult);\n\t\t\tbreak;\n\t\tcase 0x0122:\n\t\t\tresult = sony_nc_thermal_setup(pf_device);\n\t\t\tif (result)\n\t\t\t\tpr_err(\"couldn't set up thermal profile function (%d)\\n\",\n\t\t\t\t\t\tresult);\n\t\t\tbreak;\n\t\tcase 0x0128:\n\t\tcase 0x0146:\n\t\tcase 0x015B:\n\t\t\tresult = sony_nc_gfx_switch_setup(pf_device, handle);\n\t\t\tif (result)\n\t\t\t\tpr_err(\"couldn't set up GFX Switch status (%d)\\n\",\n\t\t\t\t\t\tresult);\n\t\t\tbreak;\n\t\tcase 0x0131:\n\t\t\tresult = sony_nc_highspeed_charging_setup(pf_device);\n\t\t\tif (result)\n\t\t\t\tpr_err(\"couldn't set up high speed charging function (%d)\\n\",\n\t\t\t\t       result);\n\t\t\tbreak;\n\t\tcase 0x0124:\n\t\tcase 0x0135:\n\t\t\tresult = sony_nc_rfkill_setup(device, handle);\n\t\t\tif (result)\n\t\t\t\tpr_err(\"couldn't set up rfkill support (%d)\\n\",\n\t\t\t\t\t\tresult);\n\t\t\tbreak;\n\t\tcase 0x0137:\n\t\tcase 0x0143:\n\t\tcase 0x014b:\n\t\tcase 0x014c:\n\t\tcase 0x0153:\n\t\tcase 0x0163:\n\t\t\tresult = sony_nc_kbd_backlight_setup(pf_device, handle);\n\t\t\tif (result)\n\t\t\t\tpr_err(\"couldn't set up keyboard backlight function (%d)\\n\",\n\t\t\t\t\t\tresult);\n\t\t\tbreak;\n\t\tcase 0x0121:\n\t\t\tresult = sony_nc_lowbatt_setup(pf_device);\n\t\t\tif (result)\n\t\t\t\tpr_err(\"couldn't set up low battery function (%d)\\n\",\n\t\t\t\t       result);\n\t\t\tbreak;\n\t\tcase 0x0149:\n\t\t\tresult = sony_nc_fanspeed_setup(pf_device);\n\t\t\tif (result)\n\t\t\t\tpr_err(\"couldn't set up fan speed function (%d)\\n\",\n\t\t\t\t       result);\n\t\t\tbreak;\n\t\tcase 0x0155:\n\t\t\tresult = sony_nc_usb_charge_setup(pf_device);\n\t\t\tif (result)\n\t\t\t\tpr_err(\"couldn't set up USB charge support (%d)\\n\",\n\t\t\t\t\t\tresult);\n\t\t\tbreak;\n\t\tcase 0x011D:\n\t\t\tresult = sony_nc_panelid_setup(pf_device);\n\t\t\tif (result)\n\t\t\t\tpr_err(\"couldn't set up panel ID function (%d)\\n\",\n\t\t\t\t       result);\n\t\t\tbreak;\n\t\tcase 0x0168:\n\t\t\tresult = sony_nc_smart_conn_setup(pf_device);\n\t\t\tif (result)\n\t\t\t\tpr_err(\"couldn't set up smart connect support (%d)\\n\",\n\t\t\t\t\t\tresult);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\t \n\targ = 0x10;\n\tif (!sony_nc_int_call(sony_nc_acpi_handle, \"SN00\", &arg, &bitmask))\n\t\tsony_nc_int_call(sony_nc_acpi_handle, \"SN02\", &bitmask,\n\t\t\t\t&result);\n}\n\nstatic void sony_nc_function_cleanup(struct platform_device *pd)\n{\n\tunsigned int i, result, bitmask, handle;\n\n\tif (!handles)\n\t\treturn;\n\n\t \n\tsony_nc_int_call(sony_nc_acpi_handle, \"SN01\", NULL, &bitmask);\n\tsony_nc_int_call(sony_nc_acpi_handle, \"SN03\", &bitmask, &result);\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(handles->cap); i++) {\n\n\t\thandle = handles->cap[i];\n\n\t\tif (!handle)\n\t\t\tcontinue;\n\n\t\tswitch (handle) {\n\t\tcase 0x0105:\n\t\tcase 0x0148:\n\t\t\tsony_nc_touchpad_cleanup(pd);\n\t\t\tbreak;\n\t\tcase 0x0115:\n\t\tcase 0x0136:\n\t\tcase 0x013f:\n\t\t\tsony_nc_battery_care_cleanup(pd);\n\t\t\tbreak;\n\t\tcase 0x0119:\n\t\tcase 0x015D:\n\t\t\tsony_nc_lid_resume_cleanup(pd);\n\t\t\tbreak;\n\t\tcase 0x0122:\n\t\t\tsony_nc_thermal_cleanup(pd);\n\t\t\tbreak;\n\t\tcase 0x0128:\n\t\tcase 0x0146:\n\t\tcase 0x015B:\n\t\t\tsony_nc_gfx_switch_cleanup(pd);\n\t\t\tbreak;\n\t\tcase 0x0131:\n\t\t\tsony_nc_highspeed_charging_cleanup(pd);\n\t\t\tbreak;\n\t\tcase 0x0124:\n\t\tcase 0x0135:\n\t\t\tsony_nc_rfkill_cleanup();\n\t\t\tbreak;\n\t\tcase 0x0137:\n\t\tcase 0x0143:\n\t\tcase 0x014b:\n\t\tcase 0x014c:\n\t\tcase 0x0153:\n\t\tcase 0x0163:\n\t\t\tsony_nc_kbd_backlight_cleanup(pd, handle);\n\t\t\tbreak;\n\t\tcase 0x0121:\n\t\t\tsony_nc_lowbatt_cleanup(pd);\n\t\t\tbreak;\n\t\tcase 0x0149:\n\t\t\tsony_nc_fanspeed_cleanup(pd);\n\t\t\tbreak;\n\t\tcase 0x0155:\n\t\t\tsony_nc_usb_charge_cleanup(pd);\n\t\t\tbreak;\n\t\tcase 0x011D:\n\t\t\tsony_nc_panelid_cleanup(pd);\n\t\t\tbreak;\n\t\tcase 0x0168:\n\t\t\tsony_nc_smart_conn_cleanup(pd);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\t \n\tsony_nc_handles_cleanup(pd);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic void sony_nc_function_resume(void)\n{\n\tunsigned int i, result, bitmask, arg;\n\n\tdprintk(\"Resuming SNC device\\n\");\n\n\tfor (i = 0; i < ARRAY_SIZE(handles->cap); i++) {\n\t\tunsigned int handle = handles->cap[i];\n\n\t\tif (!handle)\n\t\t\tcontinue;\n\n\t\tswitch (handle) {\n\t\tcase 0x0100:\n\t\tcase 0x0101:\n\t\tcase 0x0127:\n\t\t\t \n\t\t\tsony_call_snc_handle(handle, 0, &result);\n\t\t\tbreak;\n\t\tcase 0x0102:\n\t\t\t \n\t\t\tsony_call_snc_handle(handle, 0x100, &result);\n\t\t\tbreak;\n\t\tcase 0x0122:\n\t\t\tsony_nc_thermal_resume();\n\t\t\tbreak;\n\t\tcase 0x0124:\n\t\tcase 0x0135:\n\t\t\tsony_nc_rfkill_update();\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\t \n\targ = 0x10;\n\tif (!sony_nc_int_call(sony_nc_acpi_handle, \"SN00\", &arg, &bitmask))\n\t\tsony_nc_int_call(sony_nc_acpi_handle, \"SN02\", &bitmask,\n\t\t\t\t&result);\n}\n\nstatic int sony_nc_resume(struct device *dev)\n{\n\tstruct sony_nc_value *item;\n\n\tfor (item = sony_nc_values; item->name; item++) {\n\t\tint ret;\n\n\t\tif (!item->valid)\n\t\t\tcontinue;\n\t\tret = sony_nc_int_call(sony_nc_acpi_handle, *item->acpiset,\n\t\t\t\t       &item->value, NULL);\n\t\tif (ret < 0) {\n\t\t\tpr_err(\"%s: %d\\n\", __func__, ret);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (acpi_has_method(sony_nc_acpi_handle, \"ECON\")) {\n\t\tint arg = 1;\n\t\tif (sony_nc_int_call(sony_nc_acpi_handle, \"ECON\", &arg, NULL))\n\t\t\tdprintk(\"ECON Method failed\\n\");\n\t}\n\n\tif (acpi_has_method(sony_nc_acpi_handle, \"SN00\"))\n\t\tsony_nc_function_resume();\n\n\treturn 0;\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(sony_nc_pm, NULL, sony_nc_resume);\n\nstatic void sony_nc_rfkill_cleanup(void)\n{\n\tint i;\n\n\tfor (i = 0; i < N_SONY_RFKILL; i++) {\n\t\tif (sony_rfkill_devices[i]) {\n\t\t\trfkill_unregister(sony_rfkill_devices[i]);\n\t\t\trfkill_destroy(sony_rfkill_devices[i]);\n\t\t}\n\t}\n}\n\nstatic int sony_nc_rfkill_set(void *data, bool blocked)\n{\n\tint result;\n\tint argument = sony_rfkill_address[(long) data] + 0x100;\n\n\tif (!blocked)\n\t\targument |= 0x070000;\n\n\treturn sony_call_snc_handle(sony_rfkill_handle, argument, &result);\n}\n\nstatic const struct rfkill_ops sony_rfkill_ops = {\n\t.set_block = sony_nc_rfkill_set,\n};\n\nstatic int sony_nc_setup_rfkill(struct acpi_device *device,\n\t\t\t\tenum sony_nc_rfkill nc_type)\n{\n\tint err;\n\tstruct rfkill *rfk;\n\tenum rfkill_type type;\n\tconst char *name;\n\tint result;\n\tbool hwblock, swblock;\n\n\tswitch (nc_type) {\n\tcase SONY_WIFI:\n\t\ttype = RFKILL_TYPE_WLAN;\n\t\tname = \"sony-wifi\";\n\t\tbreak;\n\tcase SONY_BLUETOOTH:\n\t\ttype = RFKILL_TYPE_BLUETOOTH;\n\t\tname = \"sony-bluetooth\";\n\t\tbreak;\n\tcase SONY_WWAN:\n\t\ttype = RFKILL_TYPE_WWAN;\n\t\tname = \"sony-wwan\";\n\t\tbreak;\n\tcase SONY_WIMAX:\n\t\ttype = RFKILL_TYPE_WIMAX;\n\t\tname = \"sony-wimax\";\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\trfk = rfkill_alloc(name, &device->dev, type,\n\t\t\t   &sony_rfkill_ops, (void *)nc_type);\n\tif (!rfk)\n\t\treturn -ENOMEM;\n\n\terr = sony_call_snc_handle(sony_rfkill_handle, 0x200, &result);\n\tif (err < 0) {\n\t\trfkill_destroy(rfk);\n\t\treturn err;\n\t}\n\thwblock = !(result & 0x1);\n\n\terr = sony_call_snc_handle(sony_rfkill_handle,\n\t\t\t\t   sony_rfkill_address[nc_type],\n\t\t\t\t   &result);\n\tif (err < 0) {\n\t\trfkill_destroy(rfk);\n\t\treturn err;\n\t}\n\tswblock = !(result & 0x2);\n\n\trfkill_init_sw_state(rfk, swblock);\n\trfkill_set_hw_state(rfk, hwblock);\n\n\terr = rfkill_register(rfk);\n\tif (err) {\n\t\trfkill_destroy(rfk);\n\t\treturn err;\n\t}\n\tsony_rfkill_devices[nc_type] = rfk;\n\treturn err;\n}\n\nstatic void sony_nc_rfkill_update(void)\n{\n\tenum sony_nc_rfkill i;\n\tint result;\n\tbool hwblock;\n\n\tsony_call_snc_handle(sony_rfkill_handle, 0x200, &result);\n\thwblock = !(result & 0x1);\n\n\tfor (i = 0; i < N_SONY_RFKILL; i++) {\n\t\tint argument = sony_rfkill_address[i];\n\n\t\tif (!sony_rfkill_devices[i])\n\t\t\tcontinue;\n\n\t\tif (hwblock) {\n\t\t\tif (rfkill_set_hw_state(sony_rfkill_devices[i], true)) {\n\t\t\t\t \n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tsony_call_snc_handle(sony_rfkill_handle, argument, &result);\n\t\trfkill_set_states(sony_rfkill_devices[i],\n\t\t\t\t  !(result & 0x2), false);\n\t}\n}\n\nstatic int sony_nc_rfkill_setup(struct acpi_device *device,\n\t\tunsigned int handle)\n{\n\tu64 offset;\n\tint i;\n\tunsigned char buffer[32] = { 0 };\n\n\toffset = sony_find_snc_handle(handle);\n\tsony_rfkill_handle = handle;\n\n\ti = sony_nc_buffer_call(sony_nc_acpi_handle, \"SN06\", &offset, buffer,\n\t\t\t32);\n\tif (i < 0)\n\t\treturn i;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(buffer); i++) {\n\n\t\tif (buffer[i] == 0xff)\n\t\t\tbreak;\n\n\t\tdprintk(\"Radio devices, found 0x%.2x\\n\", buffer[i]);\n\n\t\tif (buffer[i] == 0 && !sony_rfkill_devices[SONY_WIFI])\n\t\t\tsony_nc_setup_rfkill(device, SONY_WIFI);\n\n\t\tif (buffer[i] == 0x10 && !sony_rfkill_devices[SONY_BLUETOOTH])\n\t\t\tsony_nc_setup_rfkill(device, SONY_BLUETOOTH);\n\n\t\tif (((0xf0 & buffer[i]) == 0x20 ||\n\t\t\t\t\t(0xf0 & buffer[i]) == 0x50) &&\n\t\t\t\t!sony_rfkill_devices[SONY_WWAN])\n\t\t\tsony_nc_setup_rfkill(device, SONY_WWAN);\n\n\t\tif (buffer[i] == 0x30 && !sony_rfkill_devices[SONY_WIMAX])\n\t\t\tsony_nc_setup_rfkill(device, SONY_WIMAX);\n\t}\n\treturn 0;\n}\n\n \nstruct kbd_backlight {\n\tunsigned int handle;\n\tunsigned int base;\n\tunsigned int mode;\n\tunsigned int timeout;\n\tunsigned int has_timeout;\n\tstruct device_attribute mode_attr;\n\tstruct device_attribute timeout_attr;\n};\n\nstatic struct kbd_backlight *kbdbl_ctl;\n\nstatic ssize_t __sony_nc_kbd_backlight_mode_set(u8 value)\n{\n\tint result;\n\n\tif (value > 2)\n\t\treturn -EINVAL;\n\n\tif (sony_call_snc_handle(kbdbl_ctl->handle,\n\t\t\t\t(value << 0x10) | (kbdbl_ctl->base), &result))\n\t\treturn -EIO;\n\n\t \n\tif (value != 1)\n\t\tsony_call_snc_handle(kbdbl_ctl->handle,\n\t\t\t\t(value << 0x0f) | (kbdbl_ctl->base + 0x100),\n\t\t\t\t&result);\n\n\tkbdbl_ctl->mode = value;\n\n\treturn 0;\n}\n\nstatic ssize_t sony_nc_kbd_backlight_mode_store(struct device *dev,\n\t\tstruct device_attribute *attr,\n\t\tconst char *buffer, size_t count)\n{\n\tint ret = 0;\n\tunsigned long value;\n\n\tif (count > 31)\n\t\treturn -EINVAL;\n\n\tif (kstrtoul(buffer, 10, &value))\n\t\treturn -EINVAL;\n\n\tret = __sony_nc_kbd_backlight_mode_set(value);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn count;\n}\n\nstatic ssize_t sony_nc_kbd_backlight_mode_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buffer)\n{\n\treturn sysfs_emit(buffer, \"%d\\n\", kbdbl_ctl->mode);\n}\n\nstatic int __sony_nc_kbd_backlight_timeout_set(u8 value)\n{\n\tint result;\n\n\tif (value > 3)\n\t\treturn -EINVAL;\n\n\tif (sony_call_snc_handle(kbdbl_ctl->handle, (value << 0x10) |\n\t\t\t\t(kbdbl_ctl->base + 0x200), &result))\n\t\treturn -EIO;\n\n\tkbdbl_ctl->timeout = value;\n\n\treturn 0;\n}\n\nstatic ssize_t sony_nc_kbd_backlight_timeout_store(struct device *dev,\n\t\tstruct device_attribute *attr,\n\t\tconst char *buffer, size_t count)\n{\n\tint ret = 0;\n\tunsigned long value;\n\n\tif (count > 31)\n\t\treturn -EINVAL;\n\n\tif (kstrtoul(buffer, 10, &value))\n\t\treturn -EINVAL;\n\n\tret = __sony_nc_kbd_backlight_timeout_set(value);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn count;\n}\n\nstatic ssize_t sony_nc_kbd_backlight_timeout_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buffer)\n{\n\treturn sysfs_emit(buffer, \"%d\\n\", kbdbl_ctl->timeout);\n}\n\nstatic int sony_nc_kbd_backlight_setup(struct platform_device *pd,\n\t\tunsigned int handle)\n{\n\tint result;\n\tint probe_base = 0;\n\tint ctl_base = 0;\n\tint ret = 0;\n\n\tif (kbdbl_ctl) {\n\t\tpr_warn(\"handle 0x%.4x: keyboard backlight setup already done for 0x%.4x\\n\",\n\t\t\t\thandle, kbdbl_ctl->handle);\n\t\treturn -EBUSY;\n\t}\n\n\t \n\tswitch (handle) {\n\tcase 0x0153:\n\t\tprobe_base = 0x0;\n\t\tctl_base = 0x0;\n\t\tbreak;\n\tcase 0x0137:\n\t\tprobe_base = 0x0B00;\n\t\tctl_base = 0x0C00;\n\t\tbreak;\n\tdefault:\n\t\tprobe_base = 0x0100;\n\t\tctl_base = 0x4000;\n\t\tbreak;\n\t}\n\n\t \n\tif (probe_base) {\n\t\tret = sony_call_snc_handle(handle, probe_base, &result);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif ((handle == 0x0137 && !(result & 0x02)) ||\n\t\t\t\t!(result & 0x01)) {\n\t\t\tdprintk(\"no backlight keyboard found\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tkbdbl_ctl = kzalloc(sizeof(*kbdbl_ctl), GFP_KERNEL);\n\tif (!kbdbl_ctl)\n\t\treturn -ENOMEM;\n\n\tkbdbl_ctl->mode = kbd_backlight;\n\tkbdbl_ctl->timeout = kbd_backlight_timeout;\n\tkbdbl_ctl->handle = handle;\n\tkbdbl_ctl->base = ctl_base;\n\t \n\tkbdbl_ctl->has_timeout = handle != 0x0153;\n\n\tsysfs_attr_init(&kbdbl_ctl->mode_attr.attr);\n\tkbdbl_ctl->mode_attr.attr.name = \"kbd_backlight\";\n\tkbdbl_ctl->mode_attr.attr.mode = S_IRUGO | S_IWUSR;\n\tkbdbl_ctl->mode_attr.show = sony_nc_kbd_backlight_mode_show;\n\tkbdbl_ctl->mode_attr.store = sony_nc_kbd_backlight_mode_store;\n\n\tret = device_create_file(&pd->dev, &kbdbl_ctl->mode_attr);\n\tif (ret)\n\t\tgoto outkzalloc;\n\n\t__sony_nc_kbd_backlight_mode_set(kbdbl_ctl->mode);\n\n\tif (kbdbl_ctl->has_timeout) {\n\t\tsysfs_attr_init(&kbdbl_ctl->timeout_attr.attr);\n\t\tkbdbl_ctl->timeout_attr.attr.name = \"kbd_backlight_timeout\";\n\t\tkbdbl_ctl->timeout_attr.attr.mode = S_IRUGO | S_IWUSR;\n\t\tkbdbl_ctl->timeout_attr.show =\n\t\t\tsony_nc_kbd_backlight_timeout_show;\n\t\tkbdbl_ctl->timeout_attr.store =\n\t\t\tsony_nc_kbd_backlight_timeout_store;\n\n\t\tret = device_create_file(&pd->dev, &kbdbl_ctl->timeout_attr);\n\t\tif (ret)\n\t\t\tgoto outmode;\n\n\t\t__sony_nc_kbd_backlight_timeout_set(kbdbl_ctl->timeout);\n\t}\n\n\n\treturn 0;\n\noutmode:\n\tdevice_remove_file(&pd->dev, &kbdbl_ctl->mode_attr);\noutkzalloc:\n\tkfree(kbdbl_ctl);\n\tkbdbl_ctl = NULL;\n\treturn ret;\n}\n\nstatic void sony_nc_kbd_backlight_cleanup(struct platform_device *pd,\n\t\tunsigned int handle)\n{\n\tif (kbdbl_ctl && handle == kbdbl_ctl->handle) {\n\t\tdevice_remove_file(&pd->dev, &kbdbl_ctl->mode_attr);\n\t\tif (kbdbl_ctl->has_timeout)\n\t\t\tdevice_remove_file(&pd->dev, &kbdbl_ctl->timeout_attr);\n\t\tkfree(kbdbl_ctl);\n\t\tkbdbl_ctl = NULL;\n\t}\n}\n\nstruct battery_care_control {\n\tstruct device_attribute attrs[2];\n\tunsigned int handle;\n};\nstatic struct battery_care_control *bcare_ctl;\n\nstatic ssize_t sony_nc_battery_care_limit_store(struct device *dev,\n\t\tstruct device_attribute *attr,\n\t\tconst char *buffer, size_t count)\n{\n\tunsigned int result, cmd;\n\tunsigned long value;\n\n\tif (count > 31)\n\t\treturn -EINVAL;\n\n\tif (kstrtoul(buffer, 10, &value))\n\t\treturn -EINVAL;\n\n\t \n\tcmd = 0;\n\n\tif (value > 0) {\n\t\tif (value <= 50)\n\t\t\tcmd = 0x20;\n\n\t\telse if (value <= 80)\n\t\t\tcmd = 0x10;\n\n\t\telse if (value <= 100)\n\t\t\tcmd = 0x30;\n\n\t\telse\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tif (bcare_ctl->handle != 0x013f)\n\t\t\tcmd = cmd | (cmd << 2);\n\n\t\tcmd = (cmd | 0x1) << 0x10;\n\t}\n\n\tif (sony_call_snc_handle(bcare_ctl->handle, cmd | 0x0100, &result))\n\t\treturn -EIO;\n\n\treturn count;\n}\n\nstatic ssize_t sony_nc_battery_care_limit_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buffer)\n{\n\tunsigned int result, status;\n\n\tif (sony_call_snc_handle(bcare_ctl->handle, 0x0000, &result))\n\t\treturn -EIO;\n\n\tstatus = (result & 0x01) ? ((result & 0x30) >> 0x04) : 0;\n\tswitch (status) {\n\tcase 1:\n\t\tstatus = 80;\n\t\tbreak;\n\tcase 2:\n\t\tstatus = 50;\n\t\tbreak;\n\tcase 3:\n\t\tstatus = 100;\n\t\tbreak;\n\tdefault:\n\t\tstatus = 0;\n\t\tbreak;\n\t}\n\n\treturn sysfs_emit(buffer, \"%d\\n\", status);\n}\n\nstatic ssize_t sony_nc_battery_care_health_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buffer)\n{\n\tunsigned int health;\n\n\tif (sony_call_snc_handle(bcare_ctl->handle, 0x0200, &health))\n\t\treturn -EIO;\n\n\treturn sysfs_emit(buffer, \"%d\\n\", health & 0xff);\n}\n\nstatic int sony_nc_battery_care_setup(struct platform_device *pd,\n\t\tunsigned int handle)\n{\n\tint ret = 0;\n\n\tbcare_ctl = kzalloc(sizeof(struct battery_care_control), GFP_KERNEL);\n\tif (!bcare_ctl)\n\t\treturn -ENOMEM;\n\n\tbcare_ctl->handle = handle;\n\n\tsysfs_attr_init(&bcare_ctl->attrs[0].attr);\n\tbcare_ctl->attrs[0].attr.name = \"battery_care_limiter\";\n\tbcare_ctl->attrs[0].attr.mode = S_IRUGO | S_IWUSR;\n\tbcare_ctl->attrs[0].show = sony_nc_battery_care_limit_show;\n\tbcare_ctl->attrs[0].store = sony_nc_battery_care_limit_store;\n\n\tret = device_create_file(&pd->dev, &bcare_ctl->attrs[0]);\n\tif (ret)\n\t\tgoto outkzalloc;\n\n\t \n\tif (handle == 0x0115)\n\t\treturn 0;\n\n\tsysfs_attr_init(&bcare_ctl->attrs[1].attr);\n\tbcare_ctl->attrs[1].attr.name = \"battery_care_health\";\n\tbcare_ctl->attrs[1].attr.mode = S_IRUGO;\n\tbcare_ctl->attrs[1].show = sony_nc_battery_care_health_show;\n\n\tret = device_create_file(&pd->dev, &bcare_ctl->attrs[1]);\n\tif (ret)\n\t\tgoto outlimiter;\n\n\treturn 0;\n\noutlimiter:\n\tdevice_remove_file(&pd->dev, &bcare_ctl->attrs[0]);\n\noutkzalloc:\n\tkfree(bcare_ctl);\n\tbcare_ctl = NULL;\n\n\treturn ret;\n}\n\nstatic void sony_nc_battery_care_cleanup(struct platform_device *pd)\n{\n\tif (bcare_ctl) {\n\t\tdevice_remove_file(&pd->dev, &bcare_ctl->attrs[0]);\n\t\tif (bcare_ctl->handle != 0x0115)\n\t\t\tdevice_remove_file(&pd->dev, &bcare_ctl->attrs[1]);\n\n\t\tkfree(bcare_ctl);\n\t\tbcare_ctl = NULL;\n\t}\n}\n\nstruct snc_thermal_ctrl {\n\tunsigned int mode;\n\tunsigned int profiles;\n\tstruct device_attribute mode_attr;\n\tstruct device_attribute profiles_attr;\n};\nstatic struct snc_thermal_ctrl *th_handle;\n\n#define THM_PROFILE_MAX 3\nstatic const char * const snc_thermal_profiles[] = {\n\t\"balanced\",\n\t\"silent\",\n\t\"performance\"\n};\n\nstatic int sony_nc_thermal_mode_set(unsigned short mode)\n{\n\tunsigned int result;\n\n\t \n\tif ((mode && !(th_handle->profiles & mode)) || mode >= THM_PROFILE_MAX)\n\t\treturn -EINVAL;\n\n\tif (sony_call_snc_handle(0x0122, mode << 0x10 | 0x0200, &result))\n\t\treturn -EIO;\n\n\tth_handle->mode = mode;\n\n\treturn 0;\n}\n\nstatic int sony_nc_thermal_mode_get(void)\n{\n\tunsigned int result;\n\n\tif (sony_call_snc_handle(0x0122, 0x0100, &result))\n\t\treturn -EIO;\n\n\treturn result & 0xff;\n}\n\nstatic ssize_t sony_nc_thermal_profiles_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buffer)\n{\n\tshort cnt;\n\tsize_t idx = 0;\n\n\tfor (cnt = 0; cnt < THM_PROFILE_MAX; cnt++) {\n\t\tif (!cnt || (th_handle->profiles & cnt))\n\t\t\tidx += sysfs_emit_at(buffer, idx, \"%s \", snc_thermal_profiles[cnt]);\n\t}\n\tidx += sysfs_emit_at(buffer, idx, \"\\n\");\n\n\treturn idx;\n}\n\nstatic ssize_t sony_nc_thermal_mode_store(struct device *dev,\n\t\tstruct device_attribute *attr,\n\t\tconst char *buffer, size_t count)\n{\n\tunsigned short cmd;\n\tsize_t len = count;\n\n\tif (count == 0)\n\t\treturn -EINVAL;\n\n\t \n\tif (buffer[len - 1] == '\\n')\n\t\tlen--;\n\n\tfor (cmd = 0; cmd < THM_PROFILE_MAX; cmd++)\n\t\tif (strncmp(buffer, snc_thermal_profiles[cmd], len) == 0)\n\t\t\tbreak;\n\n\tif (sony_nc_thermal_mode_set(cmd))\n\t\treturn -EIO;\n\n\treturn count;\n}\n\nstatic ssize_t sony_nc_thermal_mode_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buffer)\n{\n\tint mode = sony_nc_thermal_mode_get();\n\n\tif (mode < 0)\n\t\treturn mode;\n\n\treturn sysfs_emit(buffer, \"%s\\n\", snc_thermal_profiles[mode]);\n}\n\nstatic int sony_nc_thermal_setup(struct platform_device *pd)\n{\n\tint ret = 0;\n\tth_handle = kzalloc(sizeof(struct snc_thermal_ctrl), GFP_KERNEL);\n\tif (!th_handle)\n\t\treturn -ENOMEM;\n\n\tret = sony_call_snc_handle(0x0122, 0x0000, &th_handle->profiles);\n\tif (ret) {\n\t\tpr_warn(\"couldn't to read the thermal profiles\\n\");\n\t\tgoto outkzalloc;\n\t}\n\n\tret = sony_nc_thermal_mode_get();\n\tif (ret < 0) {\n\t\tpr_warn(\"couldn't to read the current thermal profile\");\n\t\tgoto outkzalloc;\n\t}\n\tth_handle->mode = ret;\n\n\tsysfs_attr_init(&th_handle->profiles_attr.attr);\n\tth_handle->profiles_attr.attr.name = \"thermal_profiles\";\n\tth_handle->profiles_attr.attr.mode = S_IRUGO;\n\tth_handle->profiles_attr.show = sony_nc_thermal_profiles_show;\n\n\tsysfs_attr_init(&th_handle->mode_attr.attr);\n\tth_handle->mode_attr.attr.name = \"thermal_control\";\n\tth_handle->mode_attr.attr.mode = S_IRUGO | S_IWUSR;\n\tth_handle->mode_attr.show = sony_nc_thermal_mode_show;\n\tth_handle->mode_attr.store = sony_nc_thermal_mode_store;\n\n\tret = device_create_file(&pd->dev, &th_handle->profiles_attr);\n\tif (ret)\n\t\tgoto outkzalloc;\n\n\tret = device_create_file(&pd->dev, &th_handle->mode_attr);\n\tif (ret)\n\t\tgoto outprofiles;\n\n\treturn 0;\n\noutprofiles:\n\tdevice_remove_file(&pd->dev, &th_handle->profiles_attr);\noutkzalloc:\n\tkfree(th_handle);\n\tth_handle = NULL;\n\treturn ret;\n}\n\nstatic void sony_nc_thermal_cleanup(struct platform_device *pd)\n{\n\tif (th_handle) {\n\t\tdevice_remove_file(&pd->dev, &th_handle->profiles_attr);\n\t\tdevice_remove_file(&pd->dev, &th_handle->mode_attr);\n\t\tkfree(th_handle);\n\t\tth_handle = NULL;\n\t}\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic void sony_nc_thermal_resume(void)\n{\n\tint status;\n\n\tif (!th_handle)\n\t\treturn;\n\n\tstatus = sony_nc_thermal_mode_get();\n\n\tif (status != th_handle->mode)\n\t\tsony_nc_thermal_mode_set(th_handle->mode);\n}\n#endif\n\n \n#define LID_RESUME_S5\t0\n#define LID_RESUME_S4\t1\n#define LID_RESUME_S3\t2\n#define LID_RESUME_MAX\t3\nstruct snc_lid_resume_control {\n\tstruct device_attribute attrs[LID_RESUME_MAX];\n\tunsigned int status;\n\tint handle;\n};\nstatic struct snc_lid_resume_control *lid_ctl;\n\nstatic ssize_t sony_nc_lid_resume_store(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tconst char *buffer, size_t count)\n{\n\tunsigned int result;\n\tunsigned long value;\n\tunsigned int pos = LID_RESUME_S5;\n\tif (count > 31)\n\t\treturn -EINVAL;\n\n\tif (kstrtoul(buffer, 10, &value) || value > 1)\n\t\treturn -EINVAL;\n\n\t \n\twhile (pos < LID_RESUME_MAX) {\n\t\tif (&lid_ctl->attrs[pos].attr == &attr->attr)\n\t\t\tbreak;\n\t\tpos++;\n\t}\n\tif (pos == LID_RESUME_MAX)\n\t\treturn -EINVAL;\n\n\tif (value)\n\t\tvalue = lid_ctl->status | (1 << pos);\n\telse\n\t\tvalue = lid_ctl->status & ~(1 << pos);\n\n\tif (sony_call_snc_handle(lid_ctl->handle, value << 0x10 | 0x0100,\n\t\t\t\t&result))\n\t\treturn -EIO;\n\n\tlid_ctl->status = value;\n\n\treturn count;\n}\n\nstatic ssize_t sony_nc_lid_resume_show(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *buffer)\n{\n\tunsigned int pos = LID_RESUME_S5;\n\n\twhile (pos < LID_RESUME_MAX) {\n\t\tif (&lid_ctl->attrs[pos].attr == &attr->attr)\n\t\t\treturn sysfs_emit(buffer, \"%d\\n\",\n\t\t\t\t\t(lid_ctl->status >> pos) & 0x01);\n\t\tpos++;\n\t}\n\treturn -EINVAL;\n}\n\nstatic int sony_nc_lid_resume_setup(struct platform_device *pd,\n\t\t\t\t\tunsigned int handle)\n{\n\tunsigned int result;\n\tint i;\n\n\tif (sony_call_snc_handle(handle, 0x0000, &result))\n\t\treturn -EIO;\n\n\tlid_ctl = kzalloc(sizeof(struct snc_lid_resume_control), GFP_KERNEL);\n\tif (!lid_ctl)\n\t\treturn -ENOMEM;\n\n\tlid_ctl->status = result & 0x7;\n\tlid_ctl->handle = handle;\n\n\tsysfs_attr_init(&lid_ctl->attrs[0].attr);\n\tlid_ctl->attrs[LID_RESUME_S5].attr.name = \"lid_resume_S5\";\n\tlid_ctl->attrs[LID_RESUME_S5].attr.mode = S_IRUGO | S_IWUSR;\n\tlid_ctl->attrs[LID_RESUME_S5].show = sony_nc_lid_resume_show;\n\tlid_ctl->attrs[LID_RESUME_S5].store = sony_nc_lid_resume_store;\n\n\tif (handle == 0x0119) {\n\t\tsysfs_attr_init(&lid_ctl->attrs[1].attr);\n\t\tlid_ctl->attrs[LID_RESUME_S4].attr.name = \"lid_resume_S4\";\n\t\tlid_ctl->attrs[LID_RESUME_S4].attr.mode = S_IRUGO | S_IWUSR;\n\t\tlid_ctl->attrs[LID_RESUME_S4].show = sony_nc_lid_resume_show;\n\t\tlid_ctl->attrs[LID_RESUME_S4].store = sony_nc_lid_resume_store;\n\n\t\tsysfs_attr_init(&lid_ctl->attrs[2].attr);\n\t\tlid_ctl->attrs[LID_RESUME_S3].attr.name = \"lid_resume_S3\";\n\t\tlid_ctl->attrs[LID_RESUME_S3].attr.mode = S_IRUGO | S_IWUSR;\n\t\tlid_ctl->attrs[LID_RESUME_S3].show = sony_nc_lid_resume_show;\n\t\tlid_ctl->attrs[LID_RESUME_S3].store = sony_nc_lid_resume_store;\n\t}\n\tfor (i = 0; i < LID_RESUME_MAX &&\n\t\t\tlid_ctl->attrs[i].attr.name; i++) {\n\t\tresult = device_create_file(&pd->dev, &lid_ctl->attrs[i]);\n\t\tif (result)\n\t\t\tgoto liderror;\n\t}\n\n\treturn 0;\n\nliderror:\n\tfor (i--; i >= 0; i--)\n\t\tdevice_remove_file(&pd->dev, &lid_ctl->attrs[i]);\n\n\tkfree(lid_ctl);\n\tlid_ctl = NULL;\n\n\treturn result;\n}\n\nstatic void sony_nc_lid_resume_cleanup(struct platform_device *pd)\n{\n\tint i;\n\n\tif (lid_ctl) {\n\t\tfor (i = 0; i < LID_RESUME_MAX; i++) {\n\t\t\tif (!lid_ctl->attrs[i].attr.name)\n\t\t\t\tbreak;\n\n\t\t\tdevice_remove_file(&pd->dev, &lid_ctl->attrs[i]);\n\t\t}\n\n\t\tkfree(lid_ctl);\n\t\tlid_ctl = NULL;\n\t}\n}\n\n \nenum gfx_switch {\n\tSPEED,\n\tSTAMINA,\n\tAUTO\n};\nstruct snc_gfx_switch_control {\n\tstruct device_attribute attr;\n\tunsigned int handle;\n};\nstatic struct snc_gfx_switch_control *gfxs_ctl;\n\n \nstatic int __sony_nc_gfx_switch_status_get(void)\n{\n\tunsigned int result;\n\n\tif (sony_call_snc_handle(gfxs_ctl->handle,\n\t\t\t\tgfxs_ctl->handle == 0x015B ? 0x0000 : 0x0100,\n\t\t\t\t&result))\n\t\treturn -EIO;\n\n\tswitch (gfxs_ctl->handle) {\n\tcase 0x0146:\n\t\t \n\t\treturn result & 0x1 ? SPEED : STAMINA;\n\tcase 0x015B:\n\t\t \n\t\treturn result & 0x1 ? STAMINA : SPEED;\n\tcase 0x0128:\n\t\t \n\t\tdprintk(\"GFX Status: 0x%x\\n\", result);\n\t\treturn result & 0x80 ? AUTO :\n\t\t\tresult & 0x02 ? STAMINA : SPEED;\n\t}\n\treturn -EINVAL;\n}\n\nstatic ssize_t sony_nc_gfx_switch_status_show(struct device *dev,\n\t\t\t\t       struct device_attribute *attr,\n\t\t\t\t       char *buffer)\n{\n\tint pos = __sony_nc_gfx_switch_status_get();\n\n\tif (pos < 0)\n\t\treturn pos;\n\n\treturn sysfs_emit(buffer, \"%s\\n\",\n\t\t\t\t\tpos == SPEED ? \"speed\" :\n\t\t\t\t\tpos == STAMINA ? \"stamina\" :\n\t\t\t\t\tpos == AUTO ? \"auto\" : \"unknown\");\n}\n\nstatic int sony_nc_gfx_switch_setup(struct platform_device *pd,\n\t\tunsigned int handle)\n{\n\tunsigned int result;\n\n\tgfxs_ctl = kzalloc(sizeof(struct snc_gfx_switch_control), GFP_KERNEL);\n\tif (!gfxs_ctl)\n\t\treturn -ENOMEM;\n\n\tgfxs_ctl->handle = handle;\n\n\tsysfs_attr_init(&gfxs_ctl->attr.attr);\n\tgfxs_ctl->attr.attr.name = \"gfx_switch_status\";\n\tgfxs_ctl->attr.attr.mode = S_IRUGO;\n\tgfxs_ctl->attr.show = sony_nc_gfx_switch_status_show;\n\n\tresult = device_create_file(&pd->dev, &gfxs_ctl->attr);\n\tif (result)\n\t\tgoto gfxerror;\n\n\treturn 0;\n\ngfxerror:\n\tkfree(gfxs_ctl);\n\tgfxs_ctl = NULL;\n\n\treturn result;\n}\n\nstatic void sony_nc_gfx_switch_cleanup(struct platform_device *pd)\n{\n\tif (gfxs_ctl) {\n\t\tdevice_remove_file(&pd->dev, &gfxs_ctl->attr);\n\n\t\tkfree(gfxs_ctl);\n\t\tgfxs_ctl = NULL;\n\t}\n}\n\n \nstatic struct device_attribute *hsc_handle;\n\nstatic ssize_t sony_nc_highspeed_charging_store(struct device *dev,\n\t\tstruct device_attribute *attr,\n\t\tconst char *buffer, size_t count)\n{\n\tunsigned int result;\n\tunsigned long value;\n\n\tif (count > 31)\n\t\treturn -EINVAL;\n\n\tif (kstrtoul(buffer, 10, &value) || value > 1)\n\t\treturn -EINVAL;\n\n\tif (sony_call_snc_handle(0x0131, value << 0x10 | 0x0200, &result))\n\t\treturn -EIO;\n\n\treturn count;\n}\n\nstatic ssize_t sony_nc_highspeed_charging_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buffer)\n{\n\tunsigned int result;\n\n\tif (sony_call_snc_handle(0x0131, 0x0100, &result))\n\t\treturn -EIO;\n\n\treturn sysfs_emit(buffer, \"%d\\n\", result & 0x01);\n}\n\nstatic int sony_nc_highspeed_charging_setup(struct platform_device *pd)\n{\n\tunsigned int result;\n\n\tif (sony_call_snc_handle(0x0131, 0x0000, &result) || !(result & 0x01)) {\n\t\t \n\t\tpr_info(\"No High Speed Charging capability found\\n\");\n\t\treturn 0;\n\t}\n\n\thsc_handle = kzalloc(sizeof(struct device_attribute), GFP_KERNEL);\n\tif (!hsc_handle)\n\t\treturn -ENOMEM;\n\n\tsysfs_attr_init(&hsc_handle->attr);\n\thsc_handle->attr.name = \"battery_highspeed_charging\";\n\thsc_handle->attr.mode = S_IRUGO | S_IWUSR;\n\thsc_handle->show = sony_nc_highspeed_charging_show;\n\thsc_handle->store = sony_nc_highspeed_charging_store;\n\n\tresult = device_create_file(&pd->dev, hsc_handle);\n\tif (result) {\n\t\tkfree(hsc_handle);\n\t\thsc_handle = NULL;\n\t\treturn result;\n\t}\n\n\treturn 0;\n}\n\nstatic void sony_nc_highspeed_charging_cleanup(struct platform_device *pd)\n{\n\tif (hsc_handle) {\n\t\tdevice_remove_file(&pd->dev, hsc_handle);\n\t\tkfree(hsc_handle);\n\t\thsc_handle = NULL;\n\t}\n}\n\n \nstatic struct device_attribute *lowbatt_handle;\n\nstatic ssize_t sony_nc_lowbatt_store(struct device *dev,\n\t\tstruct device_attribute *attr,\n\t\tconst char *buffer, size_t count)\n{\n\tunsigned int result;\n\tunsigned long value;\n\n\tif (count > 31)\n\t\treturn -EINVAL;\n\n\tif (kstrtoul(buffer, 10, &value) || value > 1)\n\t\treturn -EINVAL;\n\n\tif (sony_call_snc_handle(0x0121, value << 8, &result))\n\t\treturn -EIO;\n\n\treturn count;\n}\n\nstatic ssize_t sony_nc_lowbatt_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buffer)\n{\n\tunsigned int result;\n\n\tif (sony_call_snc_handle(0x0121, 0x0200, &result))\n\t\treturn -EIO;\n\n\treturn sysfs_emit(buffer, \"%d\\n\", result & 1);\n}\n\nstatic int sony_nc_lowbatt_setup(struct platform_device *pd)\n{\n\tunsigned int result;\n\n\tlowbatt_handle = kzalloc(sizeof(struct device_attribute), GFP_KERNEL);\n\tif (!lowbatt_handle)\n\t\treturn -ENOMEM;\n\n\tsysfs_attr_init(&lowbatt_handle->attr);\n\tlowbatt_handle->attr.name = \"lowbatt_hibernate\";\n\tlowbatt_handle->attr.mode = S_IRUGO | S_IWUSR;\n\tlowbatt_handle->show = sony_nc_lowbatt_show;\n\tlowbatt_handle->store = sony_nc_lowbatt_store;\n\n\tresult = device_create_file(&pd->dev, lowbatt_handle);\n\tif (result) {\n\t\tkfree(lowbatt_handle);\n\t\tlowbatt_handle = NULL;\n\t\treturn result;\n\t}\n\n\treturn 0;\n}\n\nstatic void sony_nc_lowbatt_cleanup(struct platform_device *pd)\n{\n\tif (lowbatt_handle) {\n\t\tdevice_remove_file(&pd->dev, lowbatt_handle);\n\t\tkfree(lowbatt_handle);\n\t\tlowbatt_handle = NULL;\n\t}\n}\n\n \nstatic struct device_attribute *fan_handle, *hsf_handle;\n\nstatic ssize_t sony_nc_hsfan_store(struct device *dev,\n\t\tstruct device_attribute *attr,\n\t\tconst char *buffer, size_t count)\n{\n\tunsigned int result;\n\tunsigned long value;\n\n\tif (count > 31)\n\t\treturn -EINVAL;\n\n\tif (kstrtoul(buffer, 10, &value) || value > 1)\n\t\treturn -EINVAL;\n\n\tif (sony_call_snc_handle(0x0149, value << 0x10 | 0x0200, &result))\n\t\treturn -EIO;\n\n\treturn count;\n}\n\nstatic ssize_t sony_nc_hsfan_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buffer)\n{\n\tunsigned int result;\n\n\tif (sony_call_snc_handle(0x0149, 0x0100, &result))\n\t\treturn -EIO;\n\n\treturn sysfs_emit(buffer, \"%d\\n\", result & 0x01);\n}\n\nstatic ssize_t sony_nc_fanspeed_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buffer)\n{\n\tunsigned int result;\n\n\tif (sony_call_snc_handle(0x0149, 0x0300, &result))\n\t\treturn -EIO;\n\n\treturn sysfs_emit(buffer, \"%d\\n\", result & 0xff);\n}\n\nstatic int sony_nc_fanspeed_setup(struct platform_device *pd)\n{\n\tunsigned int result;\n\n\tfan_handle = kzalloc(sizeof(struct device_attribute), GFP_KERNEL);\n\tif (!fan_handle)\n\t\treturn -ENOMEM;\n\n\thsf_handle = kzalloc(sizeof(struct device_attribute), GFP_KERNEL);\n\tif (!hsf_handle) {\n\t\tresult = -ENOMEM;\n\t\tgoto out_hsf_handle_alloc;\n\t}\n\n\tsysfs_attr_init(&fan_handle->attr);\n\tfan_handle->attr.name = \"fanspeed\";\n\tfan_handle->attr.mode = S_IRUGO;\n\tfan_handle->show = sony_nc_fanspeed_show;\n\tfan_handle->store = NULL;\n\n\tsysfs_attr_init(&hsf_handle->attr);\n\thsf_handle->attr.name = \"fan_forced\";\n\thsf_handle->attr.mode = S_IRUGO | S_IWUSR;\n\thsf_handle->show = sony_nc_hsfan_show;\n\thsf_handle->store = sony_nc_hsfan_store;\n\n\tresult = device_create_file(&pd->dev, fan_handle);\n\tif (result)\n\t\tgoto out_fan_handle;\n\n\tresult = device_create_file(&pd->dev, hsf_handle);\n\tif (result)\n\t\tgoto out_hsf_handle;\n\n\treturn 0;\n\nout_hsf_handle:\n\tdevice_remove_file(&pd->dev, fan_handle);\n\nout_fan_handle:\n\tkfree(hsf_handle);\n\thsf_handle = NULL;\n\nout_hsf_handle_alloc:\n\tkfree(fan_handle);\n\tfan_handle = NULL;\n\treturn result;\n}\n\nstatic void sony_nc_fanspeed_cleanup(struct platform_device *pd)\n{\n\tif (fan_handle) {\n\t\tdevice_remove_file(&pd->dev, fan_handle);\n\t\tkfree(fan_handle);\n\t\tfan_handle = NULL;\n\t}\n\tif (hsf_handle) {\n\t\tdevice_remove_file(&pd->dev, hsf_handle);\n\t\tkfree(hsf_handle);\n\t\thsf_handle = NULL;\n\t}\n}\n\n \nstatic struct device_attribute *uc_handle;\n\nstatic ssize_t sony_nc_usb_charge_store(struct device *dev,\n\t\tstruct device_attribute *attr,\n\t\tconst char *buffer, size_t count)\n{\n\tunsigned int result;\n\tunsigned long value;\n\n\tif (count > 31)\n\t\treturn -EINVAL;\n\n\tif (kstrtoul(buffer, 10, &value) || value > 1)\n\t\treturn -EINVAL;\n\n\tif (sony_call_snc_handle(0x0155, value << 0x10 | 0x0100, &result))\n\t\treturn -EIO;\n\n\treturn count;\n}\n\nstatic ssize_t sony_nc_usb_charge_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buffer)\n{\n\tunsigned int result;\n\n\tif (sony_call_snc_handle(0x0155, 0x0000, &result))\n\t\treturn -EIO;\n\n\treturn sysfs_emit(buffer, \"%d\\n\", result & 0x01);\n}\n\nstatic int sony_nc_usb_charge_setup(struct platform_device *pd)\n{\n\tunsigned int result;\n\n\tif (sony_call_snc_handle(0x0155, 0x0000, &result) || !(result & 0x01)) {\n\t\t \n\t\tpr_info(\"No USB Charge capability found\\n\");\n\t\treturn 0;\n\t}\n\n\tuc_handle = kzalloc(sizeof(struct device_attribute), GFP_KERNEL);\n\tif (!uc_handle)\n\t\treturn -ENOMEM;\n\n\tsysfs_attr_init(&uc_handle->attr);\n\tuc_handle->attr.name = \"usb_charge\";\n\tuc_handle->attr.mode = S_IRUGO | S_IWUSR;\n\tuc_handle->show = sony_nc_usb_charge_show;\n\tuc_handle->store = sony_nc_usb_charge_store;\n\n\tresult = device_create_file(&pd->dev, uc_handle);\n\tif (result) {\n\t\tkfree(uc_handle);\n\t\tuc_handle = NULL;\n\t\treturn result;\n\t}\n\n\treturn 0;\n}\n\nstatic void sony_nc_usb_charge_cleanup(struct platform_device *pd)\n{\n\tif (uc_handle) {\n\t\tdevice_remove_file(&pd->dev, uc_handle);\n\t\tkfree(uc_handle);\n\t\tuc_handle = NULL;\n\t}\n}\n\n \nstatic struct device_attribute *panel_handle;\n\nstatic ssize_t sony_nc_panelid_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buffer)\n{\n\tunsigned int result;\n\n\tif (sony_call_snc_handle(0x011D, 0x0000, &result))\n\t\treturn -EIO;\n\n\treturn sysfs_emit(buffer, \"%d\\n\", result);\n}\n\nstatic int sony_nc_panelid_setup(struct platform_device *pd)\n{\n\tunsigned int result;\n\n\tpanel_handle = kzalloc(sizeof(struct device_attribute), GFP_KERNEL);\n\tif (!panel_handle)\n\t\treturn -ENOMEM;\n\n\tsysfs_attr_init(&panel_handle->attr);\n\tpanel_handle->attr.name = \"panel_id\";\n\tpanel_handle->attr.mode = S_IRUGO;\n\tpanel_handle->show = sony_nc_panelid_show;\n\tpanel_handle->store = NULL;\n\n\tresult = device_create_file(&pd->dev, panel_handle);\n\tif (result) {\n\t\tkfree(panel_handle);\n\t\tpanel_handle = NULL;\n\t\treturn result;\n\t}\n\n\treturn 0;\n}\n\nstatic void sony_nc_panelid_cleanup(struct platform_device *pd)\n{\n\tif (panel_handle) {\n\t\tdevice_remove_file(&pd->dev, panel_handle);\n\t\tkfree(panel_handle);\n\t\tpanel_handle = NULL;\n\t}\n}\n\n \nstatic struct device_attribute *sc_handle;\n\nstatic ssize_t sony_nc_smart_conn_store(struct device *dev,\n\t\tstruct device_attribute *attr,\n\t\tconst char *buffer, size_t count)\n{\n\tunsigned int result;\n\tunsigned long value;\n\n\tif (count > 31)\n\t\treturn -EINVAL;\n\n\tif (kstrtoul(buffer, 10, &value) || value > 1)\n\t\treturn -EINVAL;\n\n\tif (sony_call_snc_handle(0x0168, value << 0x10, &result))\n\t\treturn -EIO;\n\n\treturn count;\n}\n\nstatic int sony_nc_smart_conn_setup(struct platform_device *pd)\n{\n\tunsigned int result;\n\n\tsc_handle = kzalloc(sizeof(struct device_attribute), GFP_KERNEL);\n\tif (!sc_handle)\n\t\treturn -ENOMEM;\n\n\tsysfs_attr_init(&sc_handle->attr);\n\tsc_handle->attr.name = \"smart_connect\";\n\tsc_handle->attr.mode = S_IWUSR;\n\tsc_handle->show = NULL;\n\tsc_handle->store = sony_nc_smart_conn_store;\n\n\tresult = device_create_file(&pd->dev, sc_handle);\n\tif (result) {\n\t\tkfree(sc_handle);\n\t\tsc_handle = NULL;\n\t\treturn result;\n\t}\n\n\treturn 0;\n}\n\nstatic void sony_nc_smart_conn_cleanup(struct platform_device *pd)\n{\n\tif (sc_handle) {\n\t\tdevice_remove_file(&pd->dev, sc_handle);\n\t\tkfree(sc_handle);\n\t\tsc_handle = NULL;\n\t}\n}\n\n \nstruct touchpad_control {\n\tstruct device_attribute attr;\n\tint handle;\n};\nstatic struct touchpad_control *tp_ctl;\n\nstatic ssize_t sony_nc_touchpad_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buffer, size_t count)\n{\n\tunsigned int result;\n\tunsigned long value;\n\n\tif (count > 31)\n\t\treturn -EINVAL;\n\n\tif (kstrtoul(buffer, 10, &value) || value > 1)\n\t\treturn -EINVAL;\n\n\t \n\tif (sony_call_snc_handle(tp_ctl->handle,\n\t\t\t\t(!value << 0x10) | 0x100, &result))\n\t\treturn -EIO;\n\n\treturn count;\n}\n\nstatic ssize_t sony_nc_touchpad_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buffer)\n{\n\tunsigned int result;\n\n\tif (sony_call_snc_handle(tp_ctl->handle, 0x000, &result))\n\t\treturn -EINVAL;\n\n\treturn sysfs_emit(buffer, \"%d\\n\", !(result & 0x01));\n}\n\nstatic int sony_nc_touchpad_setup(struct platform_device *pd,\n\t\tunsigned int handle)\n{\n\tint ret = 0;\n\n\ttp_ctl = kzalloc(sizeof(struct touchpad_control), GFP_KERNEL);\n\tif (!tp_ctl)\n\t\treturn -ENOMEM;\n\n\ttp_ctl->handle = handle;\n\n\tsysfs_attr_init(&tp_ctl->attr.attr);\n\ttp_ctl->attr.attr.name = \"touchpad\";\n\ttp_ctl->attr.attr.mode = S_IRUGO | S_IWUSR;\n\ttp_ctl->attr.show = sony_nc_touchpad_show;\n\ttp_ctl->attr.store = sony_nc_touchpad_store;\n\n\tret = device_create_file(&pd->dev, &tp_ctl->attr);\n\tif (ret) {\n\t\tkfree(tp_ctl);\n\t\ttp_ctl = NULL;\n\t}\n\n\treturn ret;\n}\n\nstatic void sony_nc_touchpad_cleanup(struct platform_device *pd)\n{\n\tif (tp_ctl) {\n\t\tdevice_remove_file(&pd->dev, &tp_ctl->attr);\n\t\tkfree(tp_ctl);\n\t\ttp_ctl = NULL;\n\t}\n}\n\nstatic void sony_nc_backlight_ng_read_limits(int handle,\n\t\tstruct sony_backlight_props *props)\n{\n\tu64 offset;\n\tint i;\n\tint lvl_table_len = 0;\n\tu8 min = 0xff, max = 0x00;\n\tunsigned char buffer[32] = { 0 };\n\n\tprops->handle = handle;\n\tprops->offset = 0;\n\tprops->maxlvl = 0xff;\n\n\toffset = sony_find_snc_handle(handle);\n\n\t \n\ti = sony_nc_buffer_call(sony_nc_acpi_handle, \"SN06\", &offset, buffer,\n\t\t\t32);\n\tif (i < 0)\n\t\treturn;\n\n\tswitch (handle) {\n\tcase 0x012f:\n\tcase 0x0137:\n\t\tlvl_table_len = 9;\n\t\tbreak;\n\tcase 0x143:\n\tcase 0x14b:\n\tcase 0x14c:\n\t\tlvl_table_len = 16;\n\t\tbreak;\n\t}\n\n\t \n\tfor (i = 0; i < lvl_table_len && i < ARRAY_SIZE(buffer); i++) {\n\n\t\tdprintk(\"Brightness level: %d\\n\", buffer[i]);\n\n\t\tif (!buffer[i])\n\t\t\tbreak;\n\n\t\tif (buffer[i] > max)\n\t\t\tmax = buffer[i];\n\t\tif (buffer[i] < min)\n\t\t\tmin = buffer[i];\n\t}\n\tprops->offset = min;\n\tprops->maxlvl = max;\n\tdprintk(\"Brightness levels: min=%d max=%d\\n\", props->offset,\n\t\t\tprops->maxlvl);\n}\n\nstatic void sony_nc_backlight_setup(void)\n{\n\tint max_brightness = 0;\n\tconst struct backlight_ops *ops = NULL;\n\tstruct backlight_properties props;\n\n\tif (sony_find_snc_handle(0x12f) >= 0) {\n\t\tops = &sony_backlight_ng_ops;\n\t\tsony_bl_props.cmd_base = 0x0100;\n\t\tsony_nc_backlight_ng_read_limits(0x12f, &sony_bl_props);\n\t\tmax_brightness = sony_bl_props.maxlvl - sony_bl_props.offset;\n\n\t} else if (sony_find_snc_handle(0x137) >= 0) {\n\t\tops = &sony_backlight_ng_ops;\n\t\tsony_bl_props.cmd_base = 0x0100;\n\t\tsony_nc_backlight_ng_read_limits(0x137, &sony_bl_props);\n\t\tmax_brightness = sony_bl_props.maxlvl - sony_bl_props.offset;\n\n\t} else if (sony_find_snc_handle(0x143) >= 0) {\n\t\tops = &sony_backlight_ng_ops;\n\t\tsony_bl_props.cmd_base = 0x3000;\n\t\tsony_nc_backlight_ng_read_limits(0x143, &sony_bl_props);\n\t\tmax_brightness = sony_bl_props.maxlvl - sony_bl_props.offset;\n\n\t} else if (sony_find_snc_handle(0x14b) >= 0) {\n\t\tops = &sony_backlight_ng_ops;\n\t\tsony_bl_props.cmd_base = 0x3000;\n\t\tsony_nc_backlight_ng_read_limits(0x14b, &sony_bl_props);\n\t\tmax_brightness = sony_bl_props.maxlvl - sony_bl_props.offset;\n\n\t} else if (sony_find_snc_handle(0x14c) >= 0) {\n\t\tops = &sony_backlight_ng_ops;\n\t\tsony_bl_props.cmd_base = 0x3000;\n\t\tsony_nc_backlight_ng_read_limits(0x14c, &sony_bl_props);\n\t\tmax_brightness = sony_bl_props.maxlvl - sony_bl_props.offset;\n\n\t} else if (acpi_has_method(sony_nc_acpi_handle, \"GBRT\")) {\n\t\tops = &sony_backlight_ops;\n\t\tmax_brightness = SONY_MAX_BRIGHTNESS - 1;\n\n\t} else\n\t\treturn;\n\n\tmemset(&props, 0, sizeof(struct backlight_properties));\n\tprops.type = BACKLIGHT_PLATFORM;\n\tprops.max_brightness = max_brightness;\n\tsony_bl_props.dev = backlight_device_register(\"sony\", NULL,\n\t\t\t\t\t\t      &sony_bl_props,\n\t\t\t\t\t\t      ops, &props);\n\n\tif (IS_ERR(sony_bl_props.dev)) {\n\t\tpr_warn(\"unable to register backlight device\\n\");\n\t\tsony_bl_props.dev = NULL;\n\t} else\n\t\tsony_bl_props.dev->props.brightness =\n\t\t\tops->get_brightness(sony_bl_props.dev);\n}\n\nstatic void sony_nc_backlight_cleanup(void)\n{\n\tbacklight_device_unregister(sony_bl_props.dev);\n}\n\nstatic int sony_nc_add(struct acpi_device *device)\n{\n\tacpi_status status;\n\tint result = 0;\n\tstruct sony_nc_value *item;\n\n\tsony_nc_acpi_device = device;\n\tstrcpy(acpi_device_class(device), \"sony/hotkey\");\n\n\tsony_nc_acpi_handle = device->handle;\n\n\t \n\tresult = acpi_bus_get_status(device);\n\t \n\tif (!result && !device->status.present) {\n\t\tdprintk(\"Device not present\\n\");\n\t\tresult = -ENODEV;\n\t\tgoto outwalk;\n\t}\n\n\tresult = sony_pf_add();\n\tif (result)\n\t\tgoto outpresent;\n\n\tif (debug) {\n\t\tstatus = acpi_walk_namespace(ACPI_TYPE_METHOD,\n\t\t\t\tsony_nc_acpi_handle, 1, sony_walk_callback,\n\t\t\t\tNULL, NULL, NULL);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tpr_warn(\"unable to walk acpi resources\\n\");\n\t\t\tresult = -ENODEV;\n\t\t\tgoto outpresent;\n\t\t}\n\t}\n\n\tresult = sony_laptop_setup_input(device);\n\tif (result) {\n\t\tpr_err(\"Unable to create input devices\\n\");\n\t\tgoto outplatform;\n\t}\n\n\tif (acpi_has_method(sony_nc_acpi_handle, \"ECON\")) {\n\t\tint arg = 1;\n\t\tif (sony_nc_int_call(sony_nc_acpi_handle, \"ECON\", &arg, NULL))\n\t\t\tdprintk(\"ECON Method failed\\n\");\n\t}\n\n\tif (acpi_has_method(sony_nc_acpi_handle, \"SN00\")) {\n\t\tdprintk(\"Doing SNC setup\\n\");\n\t\t \n\t\tresult = sony_nc_handles_setup(sony_pf_device);\n\t\tif (!result)\n\t\t\tsony_nc_function_setup(device, sony_pf_device);\n\t}\n\n\tif (acpi_video_get_backlight_type() == acpi_backlight_vendor)\n\t\tsony_nc_backlight_setup();\n\n\t \n\tfor (item = sony_nc_values; item->name; ++item) {\n\n\t\tif (!debug && item->debug)\n\t\t\tcontinue;\n\n\t\t \n\t\tfor (; item->acpiget && *item->acpiget; ++item->acpiget) {\n\t\t\tif (acpi_has_method(sony_nc_acpi_handle,\n\t\t\t\t\t\t\t*item->acpiget)) {\n\t\t\t\tdprintk(\"Found %s getter: %s\\n\",\n\t\t\t\t\t\titem->name, *item->acpiget);\n\t\t\t\titem->devattr.attr.mode |= S_IRUGO;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tfor (; item->acpiset && *item->acpiset; ++item->acpiset) {\n\t\t\tif (acpi_has_method(sony_nc_acpi_handle,\n\t\t\t\t\t\t\t*item->acpiset)) {\n\t\t\t\tdprintk(\"Found %s setter: %s\\n\",\n\t\t\t\t\t\titem->name, *item->acpiset);\n\t\t\t\titem->devattr.attr.mode |= S_IWUSR;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (item->devattr.attr.mode != 0) {\n\t\t\tresult =\n\t\t\t    device_create_file(&sony_pf_device->dev,\n\t\t\t\t\t       &item->devattr);\n\t\t\tif (result)\n\t\t\t\tgoto out_sysfs;\n\t\t}\n\t}\n\n\tpr_info(\"SNC setup done.\\n\");\n\treturn 0;\n\nout_sysfs:\n\tfor (item = sony_nc_values; item->name; ++item) {\n\t\tdevice_remove_file(&sony_pf_device->dev, &item->devattr);\n\t}\n\tsony_nc_backlight_cleanup();\n\tsony_nc_function_cleanup(sony_pf_device);\n\tsony_nc_handles_cleanup(sony_pf_device);\n\noutplatform:\n\tsony_laptop_remove_input();\n\noutpresent:\n\tsony_pf_remove();\n\noutwalk:\n\tsony_nc_rfkill_cleanup();\n\treturn result;\n}\n\nstatic void sony_nc_remove(struct acpi_device *device)\n{\n\tstruct sony_nc_value *item;\n\n\tsony_nc_backlight_cleanup();\n\n\tsony_nc_acpi_device = NULL;\n\n\tfor (item = sony_nc_values; item->name; ++item) {\n\t\tdevice_remove_file(&sony_pf_device->dev, &item->devattr);\n\t}\n\n\tsony_nc_function_cleanup(sony_pf_device);\n\tsony_nc_handles_cleanup(sony_pf_device);\n\tsony_pf_remove();\n\tsony_laptop_remove_input();\n\tdprintk(SONY_NC_DRIVER_NAME \" removed.\\n\");\n}\n\nstatic const struct acpi_device_id sony_device_ids[] __maybe_unused = {\n\t{SONY_NC_HID, 0},\n\t{SONY_PIC_HID, 0},\n\t{\"\", 0},\n};\nMODULE_DEVICE_TABLE(acpi, sony_device_ids);\n\nstatic const struct acpi_device_id sony_nc_device_ids[] = {\n\t{SONY_NC_HID, 0},\n\t{\"\", 0},\n};\n\nstatic struct acpi_driver sony_nc_driver = {\n\t.name = SONY_NC_DRIVER_NAME,\n\t.class = SONY_NC_CLASS,\n\t.ids = sony_nc_device_ids,\n\t.owner = THIS_MODULE,\n\t.ops = {\n\t\t.add = sony_nc_add,\n\t\t.remove = sony_nc_remove,\n\t\t.notify = sony_nc_notify,\n\t\t},\n\t.drv.pm = &sony_nc_pm,\n};\n\n \n\n#define SONYPI_DEVICE_TYPE1\t0x00000001\n#define SONYPI_DEVICE_TYPE2\t0x00000002\n#define SONYPI_DEVICE_TYPE3\t0x00000004\n\n#define SONYPI_TYPE1_OFFSET\t0x04\n#define SONYPI_TYPE2_OFFSET\t0x12\n#define SONYPI_TYPE3_OFFSET\t0x12\n\nstruct sony_pic_ioport {\n\tstruct acpi_resource_io\tio1;\n\tstruct acpi_resource_io\tio2;\n\tstruct list_head\tlist;\n};\n\nstruct sony_pic_irq {\n\tstruct acpi_resource_irq\tirq;\n\tstruct list_head\t\tlist;\n};\n\nstruct sonypi_eventtypes {\n\tu8\t\t\tdata;\n\tunsigned long\t\tmask;\n\tstruct sonypi_event\t*events;\n};\n\nstruct sony_pic_dev {\n\tstruct acpi_device\t\t*acpi_dev;\n\tstruct sony_pic_irq\t\t*cur_irq;\n\tstruct sony_pic_ioport\t\t*cur_ioport;\n\tstruct list_head\t\tinterrupts;\n\tstruct list_head\t\tioports;\n\tstruct mutex\t\t\tlock;\n\tstruct sonypi_eventtypes\t*event_types;\n\tint                             (*handle_irq)(const u8, const u8);\n\tint\t\t\t\tmodel;\n\tu16\t\t\t\tevport_offset;\n\tu8\t\t\t\tcamera_power;\n\tu8\t\t\t\tbluetooth_power;\n\tu8\t\t\t\twwan_power;\n};\n\nstatic struct sony_pic_dev spic_dev = {\n\t.interrupts\t= LIST_HEAD_INIT(spic_dev.interrupts),\n\t.ioports\t= LIST_HEAD_INIT(spic_dev.ioports),\n};\n\nstatic int spic_drv_registered;\n\n \n#define SONYPI_JOGGER_MASK\t\t\t0x00000001\n#define SONYPI_CAPTURE_MASK\t\t\t0x00000002\n#define SONYPI_FNKEY_MASK\t\t\t0x00000004\n#define SONYPI_BLUETOOTH_MASK\t\t\t0x00000008\n#define SONYPI_PKEY_MASK\t\t\t0x00000010\n#define SONYPI_BACK_MASK\t\t\t0x00000020\n#define SONYPI_HELP_MASK\t\t\t0x00000040\n#define SONYPI_LID_MASK\t\t\t\t0x00000080\n#define SONYPI_ZOOM_MASK\t\t\t0x00000100\n#define SONYPI_THUMBPHRASE_MASK\t\t\t0x00000200\n#define SONYPI_MEYE_MASK\t\t\t0x00000400\n#define SONYPI_MEMORYSTICK_MASK\t\t\t0x00000800\n#define SONYPI_BATTERY_MASK\t\t\t0x00001000\n#define SONYPI_WIRELESS_MASK\t\t\t0x00002000\n\nstruct sonypi_event {\n\tu8\tdata;\n\tu8\tevent;\n};\n\n \nstatic struct sonypi_event sonypi_releaseev[] = {\n\t{ 0x00, SONYPI_EVENT_ANYBUTTON_RELEASED },\n\t{ 0, 0 }\n};\n\n \nstatic struct sonypi_event sonypi_joggerev[] = {\n\t{ 0x1f, SONYPI_EVENT_JOGDIAL_UP },\n\t{ 0x01, SONYPI_EVENT_JOGDIAL_DOWN },\n\t{ 0x5f, SONYPI_EVENT_JOGDIAL_UP_PRESSED },\n\t{ 0x41, SONYPI_EVENT_JOGDIAL_DOWN_PRESSED },\n\t{ 0x1e, SONYPI_EVENT_JOGDIAL_FAST_UP },\n\t{ 0x02, SONYPI_EVENT_JOGDIAL_FAST_DOWN },\n\t{ 0x5e, SONYPI_EVENT_JOGDIAL_FAST_UP_PRESSED },\n\t{ 0x42, SONYPI_EVENT_JOGDIAL_FAST_DOWN_PRESSED },\n\t{ 0x1d, SONYPI_EVENT_JOGDIAL_VFAST_UP },\n\t{ 0x03, SONYPI_EVENT_JOGDIAL_VFAST_DOWN },\n\t{ 0x5d, SONYPI_EVENT_JOGDIAL_VFAST_UP_PRESSED },\n\t{ 0x43, SONYPI_EVENT_JOGDIAL_VFAST_DOWN_PRESSED },\n\t{ 0x40, SONYPI_EVENT_JOGDIAL_PRESSED },\n\t{ 0, 0 }\n};\n\n \nstatic struct sonypi_event sonypi_captureev[] = {\n\t{ 0x05, SONYPI_EVENT_CAPTURE_PARTIALPRESSED },\n\t{ 0x07, SONYPI_EVENT_CAPTURE_PRESSED },\n\t{ 0x40, SONYPI_EVENT_CAPTURE_PRESSED },\n\t{ 0x01, SONYPI_EVENT_CAPTURE_PARTIALRELEASED },\n\t{ 0, 0 }\n};\n\n \nstatic struct sonypi_event sonypi_fnkeyev[] = {\n\t{ 0x10, SONYPI_EVENT_FNKEY_ESC },\n\t{ 0x11, SONYPI_EVENT_FNKEY_F1 },\n\t{ 0x12, SONYPI_EVENT_FNKEY_F2 },\n\t{ 0x13, SONYPI_EVENT_FNKEY_F3 },\n\t{ 0x14, SONYPI_EVENT_FNKEY_F4 },\n\t{ 0x15, SONYPI_EVENT_FNKEY_F5 },\n\t{ 0x16, SONYPI_EVENT_FNKEY_F6 },\n\t{ 0x17, SONYPI_EVENT_FNKEY_F7 },\n\t{ 0x18, SONYPI_EVENT_FNKEY_F8 },\n\t{ 0x19, SONYPI_EVENT_FNKEY_F9 },\n\t{ 0x1a, SONYPI_EVENT_FNKEY_F10 },\n\t{ 0x1b, SONYPI_EVENT_FNKEY_F11 },\n\t{ 0x1c, SONYPI_EVENT_FNKEY_F12 },\n\t{ 0x1f, SONYPI_EVENT_FNKEY_RELEASED },\n\t{ 0x21, SONYPI_EVENT_FNKEY_1 },\n\t{ 0x22, SONYPI_EVENT_FNKEY_2 },\n\t{ 0x31, SONYPI_EVENT_FNKEY_D },\n\t{ 0x32, SONYPI_EVENT_FNKEY_E },\n\t{ 0x33, SONYPI_EVENT_FNKEY_F },\n\t{ 0x34, SONYPI_EVENT_FNKEY_S },\n\t{ 0x35, SONYPI_EVENT_FNKEY_B },\n\t{ 0x36, SONYPI_EVENT_FNKEY_ONLY },\n\t{ 0, 0 }\n};\n\n \nstatic struct sonypi_event sonypi_pkeyev[] = {\n\t{ 0x01, SONYPI_EVENT_PKEY_P1 },\n\t{ 0x02, SONYPI_EVENT_PKEY_P2 },\n\t{ 0x04, SONYPI_EVENT_PKEY_P3 },\n\t{ 0x20, SONYPI_EVENT_PKEY_P1 },\n\t{ 0, 0 }\n};\n\n \nstatic struct sonypi_event sonypi_blueev[] = {\n\t{ 0x55, SONYPI_EVENT_BLUETOOTH_PRESSED },\n\t{ 0x59, SONYPI_EVENT_BLUETOOTH_ON },\n\t{ 0x5a, SONYPI_EVENT_BLUETOOTH_OFF },\n\t{ 0, 0 }\n};\n\n \nstatic struct sonypi_event sonypi_wlessev[] = {\n\t{ 0x59, SONYPI_EVENT_IGNORE },\n\t{ 0x5a, SONYPI_EVENT_IGNORE },\n\t{ 0, 0 }\n};\n\n \nstatic struct sonypi_event sonypi_backev[] = {\n\t{ 0x20, SONYPI_EVENT_BACK_PRESSED },\n\t{ 0, 0 }\n};\n\n \nstatic struct sonypi_event sonypi_helpev[] = {\n\t{ 0x3b, SONYPI_EVENT_HELP_PRESSED },\n\t{ 0, 0 }\n};\n\n\n \nstatic struct sonypi_event sonypi_lidev[] = {\n\t{ 0x51, SONYPI_EVENT_LID_CLOSED },\n\t{ 0x50, SONYPI_EVENT_LID_OPENED },\n\t{ 0, 0 }\n};\n\n \nstatic struct sonypi_event sonypi_zoomev[] = {\n\t{ 0x39, SONYPI_EVENT_ZOOM_PRESSED },\n\t{ 0x10, SONYPI_EVENT_ZOOM_IN_PRESSED },\n\t{ 0x20, SONYPI_EVENT_ZOOM_OUT_PRESSED },\n\t{ 0x04, SONYPI_EVENT_ZOOM_PRESSED },\n\t{ 0, 0 }\n};\n\n \nstatic struct sonypi_event sonypi_thumbphraseev[] = {\n\t{ 0x3a, SONYPI_EVENT_THUMBPHRASE_PRESSED },\n\t{ 0, 0 }\n};\n\n \nstatic struct sonypi_event sonypi_meyeev[] = {\n\t{ 0x00, SONYPI_EVENT_MEYE_FACE },\n\t{ 0x01, SONYPI_EVENT_MEYE_OPPOSITE },\n\t{ 0, 0 }\n};\n\n \nstatic struct sonypi_event sonypi_memorystickev[] = {\n\t{ 0x53, SONYPI_EVENT_MEMORYSTICK_INSERT },\n\t{ 0x54, SONYPI_EVENT_MEMORYSTICK_EJECT },\n\t{ 0, 0 }\n};\n\n \nstatic struct sonypi_event sonypi_batteryev[] = {\n\t{ 0x20, SONYPI_EVENT_BATTERY_INSERT },\n\t{ 0x30, SONYPI_EVENT_BATTERY_REMOVE },\n\t{ 0, 0 }\n};\n\n \nstatic struct sonypi_event sonypi_volumeev[] = {\n\t{ 0x01, SONYPI_EVENT_VOLUME_INC_PRESSED },\n\t{ 0x02, SONYPI_EVENT_VOLUME_DEC_PRESSED },\n\t{ 0, 0 }\n};\n\n \nstatic struct sonypi_event sonypi_brightnessev[] = {\n\t{ 0x80, SONYPI_EVENT_BRIGHTNESS_PRESSED },\n\t{ 0, 0 }\n};\n\nstatic struct sonypi_eventtypes type1_events[] = {\n\t{ 0, 0xffffffff, sonypi_releaseev },\n\t{ 0x70, SONYPI_MEYE_MASK, sonypi_meyeev },\n\t{ 0x30, SONYPI_LID_MASK, sonypi_lidev },\n\t{ 0x60, SONYPI_CAPTURE_MASK, sonypi_captureev },\n\t{ 0x10, SONYPI_JOGGER_MASK, sonypi_joggerev },\n\t{ 0x20, SONYPI_FNKEY_MASK, sonypi_fnkeyev },\n\t{ 0x30, SONYPI_BLUETOOTH_MASK, sonypi_blueev },\n\t{ 0x40, SONYPI_PKEY_MASK, sonypi_pkeyev },\n\t{ 0x30, SONYPI_MEMORYSTICK_MASK, sonypi_memorystickev },\n\t{ 0x40, SONYPI_BATTERY_MASK, sonypi_batteryev },\n\t{ 0 },\n};\nstatic struct sonypi_eventtypes type2_events[] = {\n\t{ 0, 0xffffffff, sonypi_releaseev },\n\t{ 0x38, SONYPI_LID_MASK, sonypi_lidev },\n\t{ 0x11, SONYPI_JOGGER_MASK, sonypi_joggerev },\n\t{ 0x61, SONYPI_CAPTURE_MASK, sonypi_captureev },\n\t{ 0x21, SONYPI_FNKEY_MASK, sonypi_fnkeyev },\n\t{ 0x31, SONYPI_BLUETOOTH_MASK, sonypi_blueev },\n\t{ 0x08, SONYPI_PKEY_MASK, sonypi_pkeyev },\n\t{ 0x11, SONYPI_BACK_MASK, sonypi_backev },\n\t{ 0x21, SONYPI_HELP_MASK, sonypi_helpev },\n\t{ 0x21, SONYPI_ZOOM_MASK, sonypi_zoomev },\n\t{ 0x20, SONYPI_THUMBPHRASE_MASK, sonypi_thumbphraseev },\n\t{ 0x31, SONYPI_MEMORYSTICK_MASK, sonypi_memorystickev },\n\t{ 0x41, SONYPI_BATTERY_MASK, sonypi_batteryev },\n\t{ 0x31, SONYPI_PKEY_MASK, sonypi_pkeyev },\n\t{ 0 },\n};\nstatic struct sonypi_eventtypes type3_events[] = {\n\t{ 0, 0xffffffff, sonypi_releaseev },\n\t{ 0x21, SONYPI_FNKEY_MASK, sonypi_fnkeyev },\n\t{ 0x31, SONYPI_WIRELESS_MASK, sonypi_wlessev },\n\t{ 0x31, SONYPI_MEMORYSTICK_MASK, sonypi_memorystickev },\n\t{ 0x41, SONYPI_BATTERY_MASK, sonypi_batteryev },\n\t{ 0x31, SONYPI_PKEY_MASK, sonypi_pkeyev },\n\t{ 0x05, SONYPI_PKEY_MASK, sonypi_pkeyev },\n\t{ 0x05, SONYPI_ZOOM_MASK, sonypi_zoomev },\n\t{ 0x05, SONYPI_CAPTURE_MASK, sonypi_captureev },\n\t{ 0x05, SONYPI_PKEY_MASK, sonypi_volumeev },\n\t{ 0x05, SONYPI_PKEY_MASK, sonypi_brightnessev },\n\t{ 0 },\n};\n\n \n#define ITERATIONS_LONG\t\t10000\n#define ITERATIONS_SHORT\t10\n#define wait_on_command(command, iterations) {\t\t\t\t\\\n\tunsigned int n = iterations;\t\t\t\t\t\\\n\twhile (--n && (command))\t\t\t\t\t\\\n\t\tudelay(1);\t\t\t\t\t\t\\\n\tif (!n)\t\t\t\t\t\t\t\t\\\n\t\tdprintk(\"command failed at %s : %s (line %d)\\n\",\t\\\n\t\t\t\t__FILE__, __func__, __LINE__);\t\\\n}\n\nstatic u8 sony_pic_call1(u8 dev)\n{\n\tu8 v1, v2;\n\n\twait_on_command(inb_p(spic_dev.cur_ioport->io1.minimum + 4) & 2,\n\t\t\tITERATIONS_LONG);\n\toutb(dev, spic_dev.cur_ioport->io1.minimum + 4);\n\tv1 = inb_p(spic_dev.cur_ioport->io1.minimum + 4);\n\tv2 = inb_p(spic_dev.cur_ioport->io1.minimum);\n\tdprintk(\"sony_pic_call1(0x%.2x): 0x%.4x\\n\", dev, (v2 << 8) | v1);\n\treturn v2;\n}\n\nstatic u8 sony_pic_call2(u8 dev, u8 fn)\n{\n\tu8 v1;\n\n\twait_on_command(inb_p(spic_dev.cur_ioport->io1.minimum + 4) & 2,\n\t\t\tITERATIONS_LONG);\n\toutb(dev, spic_dev.cur_ioport->io1.minimum + 4);\n\twait_on_command(inb_p(spic_dev.cur_ioport->io1.minimum + 4) & 2,\n\t\t\tITERATIONS_LONG);\n\toutb(fn, spic_dev.cur_ioport->io1.minimum);\n\tv1 = inb_p(spic_dev.cur_ioport->io1.minimum);\n\tdprintk(\"sony_pic_call2(0x%.2x - 0x%.2x): 0x%.4x\\n\", dev, fn, v1);\n\treturn v1;\n}\n\nstatic u8 sony_pic_call3(u8 dev, u8 fn, u8 v)\n{\n\tu8 v1;\n\n\twait_on_command(inb_p(spic_dev.cur_ioport->io1.minimum + 4) & 2, ITERATIONS_LONG);\n\toutb(dev, spic_dev.cur_ioport->io1.minimum + 4);\n\twait_on_command(inb_p(spic_dev.cur_ioport->io1.minimum + 4) & 2, ITERATIONS_LONG);\n\toutb(fn, spic_dev.cur_ioport->io1.minimum);\n\twait_on_command(inb_p(spic_dev.cur_ioport->io1.minimum + 4) & 2, ITERATIONS_LONG);\n\toutb(v, spic_dev.cur_ioport->io1.minimum);\n\tv1 = inb_p(spic_dev.cur_ioport->io1.minimum);\n\tdprintk(\"sony_pic_call3(0x%.2x - 0x%.2x - 0x%.2x): 0x%.4x\\n\",\n\t\t\tdev, fn, v, v1);\n\treturn v1;\n}\n\n \nstatic int type3_handle_irq(const u8 data_mask, const u8 ev)\n{\n\t \n\tif (data_mask == 0x31) {\n\t\tif (ev == 0x5c || ev == 0x5f)\n\t\t\tsony_pic_call1(0xA0);\n\t\telse if (ev == 0x61)\n\t\t\tsony_pic_call1(0xB3);\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nstatic void sony_pic_detect_device_type(struct sony_pic_dev *dev)\n{\n\tstruct pci_dev *pcidev;\n\n\tpcidev = pci_get_device(PCI_VENDOR_ID_INTEL,\n\t\t\tPCI_DEVICE_ID_INTEL_82371AB_3, NULL);\n\tif (pcidev) {\n\t\tdev->model = SONYPI_DEVICE_TYPE1;\n\t\tdev->evport_offset = SONYPI_TYPE1_OFFSET;\n\t\tdev->event_types = type1_events;\n\t\tgoto out;\n\t}\n\n\tpcidev = pci_get_device(PCI_VENDOR_ID_INTEL,\n\t\t\tPCI_DEVICE_ID_INTEL_ICH6_1, NULL);\n\tif (pcidev) {\n\t\tdev->model = SONYPI_DEVICE_TYPE2;\n\t\tdev->evport_offset = SONYPI_TYPE2_OFFSET;\n\t\tdev->event_types = type2_events;\n\t\tgoto out;\n\t}\n\n\tpcidev = pci_get_device(PCI_VENDOR_ID_INTEL,\n\t\t\tPCI_DEVICE_ID_INTEL_ICH7_1, NULL);\n\tif (pcidev) {\n\t\tdev->model = SONYPI_DEVICE_TYPE3;\n\t\tdev->handle_irq = type3_handle_irq;\n\t\tdev->evport_offset = SONYPI_TYPE3_OFFSET;\n\t\tdev->event_types = type3_events;\n\t\tgoto out;\n\t}\n\n\tpcidev = pci_get_device(PCI_VENDOR_ID_INTEL,\n\t\t\tPCI_DEVICE_ID_INTEL_ICH8_4, NULL);\n\tif (pcidev) {\n\t\tdev->model = SONYPI_DEVICE_TYPE3;\n\t\tdev->handle_irq = type3_handle_irq;\n\t\tdev->evport_offset = SONYPI_TYPE3_OFFSET;\n\t\tdev->event_types = type3_events;\n\t\tgoto out;\n\t}\n\n\tpcidev = pci_get_device(PCI_VENDOR_ID_INTEL,\n\t\t\tPCI_DEVICE_ID_INTEL_ICH9_1, NULL);\n\tif (pcidev) {\n\t\tdev->model = SONYPI_DEVICE_TYPE3;\n\t\tdev->handle_irq = type3_handle_irq;\n\t\tdev->evport_offset = SONYPI_TYPE3_OFFSET;\n\t\tdev->event_types = type3_events;\n\t\tgoto out;\n\t}\n\n\t \n\tdev->model = SONYPI_DEVICE_TYPE2;\n\tdev->evport_offset = SONYPI_TYPE2_OFFSET;\n\tdev->event_types = type2_events;\n\nout:\n\tpci_dev_put(pcidev);\n\n\tpr_info(\"detected Type%d model\\n\",\n\t\tdev->model == SONYPI_DEVICE_TYPE1 ? 1 :\n\t\tdev->model == SONYPI_DEVICE_TYPE2 ? 2 : 3);\n}\n\n \n#define SONYPI_CAMERA_PICTURE\t\t5\n#define SONYPI_CAMERA_CONTROL\t\t0x10\n\n#define SONYPI_CAMERA_BRIGHTNESS\t\t0\n#define SONYPI_CAMERA_CONTRAST\t\t\t1\n#define SONYPI_CAMERA_HUE\t\t\t2\n#define SONYPI_CAMERA_COLOR\t\t\t3\n#define SONYPI_CAMERA_SHARPNESS\t\t\t4\n\n#define SONYPI_CAMERA_EXPOSURE_MASK\t\t0xC\n#define SONYPI_CAMERA_WHITE_BALANCE_MASK\t0x3\n#define SONYPI_CAMERA_PICTURE_MODE_MASK\t\t0x30\n#define SONYPI_CAMERA_MUTE_MASK\t\t\t0x40\n\n \n#define SONYPI_CAMERA_AGC\t\t\t6\n#define SONYPI_CAMERA_AGC_MASK\t\t\t0x30\n#define SONYPI_CAMERA_SHUTTER_MASK \t\t0x7\n\n#define SONYPI_CAMERA_SHUTDOWN_REQUEST\t\t7\n#define SONYPI_CAMERA_CONTROL\t\t\t0x10\n\n#define SONYPI_CAMERA_STATUS \t\t\t7\n#define SONYPI_CAMERA_STATUS_READY \t\t0x2\n#define SONYPI_CAMERA_STATUS_POSITION\t\t0x4\n\n#define SONYPI_DIRECTION_BACKWARDS \t\t0x4\n\n#define SONYPI_CAMERA_REVISION \t\t\t8\n#define SONYPI_CAMERA_ROMVERSION \t\t9\n\nstatic int __sony_pic_camera_ready(void)\n{\n\tu8 v;\n\n\tv = sony_pic_call2(0x8f, SONYPI_CAMERA_STATUS);\n\treturn (v != 0xff && (v & SONYPI_CAMERA_STATUS_READY));\n}\n\nstatic int __sony_pic_camera_off(void)\n{\n\tif (!camera) {\n\t\tpr_warn(\"camera control not enabled\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\twait_on_command(sony_pic_call3(0x90, SONYPI_CAMERA_PICTURE,\n\t\t\t\tSONYPI_CAMERA_MUTE_MASK),\n\t\t\tITERATIONS_SHORT);\n\n\tif (spic_dev.camera_power) {\n\t\tsony_pic_call2(0x91, 0);\n\t\tspic_dev.camera_power = 0;\n\t}\n\treturn 0;\n}\n\nstatic int __sony_pic_camera_on(void)\n{\n\tint i, j, x;\n\n\tif (!camera) {\n\t\tpr_warn(\"camera control not enabled\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (spic_dev.camera_power)\n\t\treturn 0;\n\n\tfor (j = 5; j > 0; j--) {\n\n\t\tfor (x = 0; x < 100 && sony_pic_call2(0x91, 0x1); x++)\n\t\t\tmsleep(10);\n\t\tsony_pic_call1(0x93);\n\n\t\tfor (i = 400; i > 0; i--) {\n\t\t\tif (__sony_pic_camera_ready())\n\t\t\t\tbreak;\n\t\t\tmsleep(10);\n\t\t}\n\t\tif (i)\n\t\t\tbreak;\n\t}\n\n\tif (j == 0) {\n\t\tpr_warn(\"failed to power on camera\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\twait_on_command(sony_pic_call3(0x90, SONYPI_CAMERA_CONTROL,\n\t\t\t\t0x5a),\n\t\t\tITERATIONS_SHORT);\n\n\tspic_dev.camera_power = 1;\n\treturn 0;\n}\n\n \nint sony_pic_camera_command(int command, u8 value)\n{\n\tif (!camera)\n\t\treturn -EIO;\n\n\tmutex_lock(&spic_dev.lock);\n\n\tswitch (command) {\n\tcase SONY_PIC_COMMAND_SETCAMERA:\n\t\tif (value)\n\t\t\t__sony_pic_camera_on();\n\t\telse\n\t\t\t__sony_pic_camera_off();\n\t\tbreak;\n\tcase SONY_PIC_COMMAND_SETCAMERABRIGHTNESS:\n\t\twait_on_command(sony_pic_call3(0x90, SONYPI_CAMERA_BRIGHTNESS, value),\n\t\t\t\tITERATIONS_SHORT);\n\t\tbreak;\n\tcase SONY_PIC_COMMAND_SETCAMERACONTRAST:\n\t\twait_on_command(sony_pic_call3(0x90, SONYPI_CAMERA_CONTRAST, value),\n\t\t\t\tITERATIONS_SHORT);\n\t\tbreak;\n\tcase SONY_PIC_COMMAND_SETCAMERAHUE:\n\t\twait_on_command(sony_pic_call3(0x90, SONYPI_CAMERA_HUE, value),\n\t\t\t\tITERATIONS_SHORT);\n\t\tbreak;\n\tcase SONY_PIC_COMMAND_SETCAMERACOLOR:\n\t\twait_on_command(sony_pic_call3(0x90, SONYPI_CAMERA_COLOR, value),\n\t\t\t\tITERATIONS_SHORT);\n\t\tbreak;\n\tcase SONY_PIC_COMMAND_SETCAMERASHARPNESS:\n\t\twait_on_command(sony_pic_call3(0x90, SONYPI_CAMERA_SHARPNESS, value),\n\t\t\t\tITERATIONS_SHORT);\n\t\tbreak;\n\tcase SONY_PIC_COMMAND_SETCAMERAPICTURE:\n\t\twait_on_command(sony_pic_call3(0x90, SONYPI_CAMERA_PICTURE, value),\n\t\t\t\tITERATIONS_SHORT);\n\t\tbreak;\n\tcase SONY_PIC_COMMAND_SETCAMERAAGC:\n\t\twait_on_command(sony_pic_call3(0x90, SONYPI_CAMERA_AGC, value),\n\t\t\t\tITERATIONS_SHORT);\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"sony_pic_camera_command invalid: %d\\n\", command);\n\t\tbreak;\n\t}\n\tmutex_unlock(&spic_dev.lock);\n\treturn 0;\n}\nEXPORT_SYMBOL(sony_pic_camera_command);\n\n \nstatic void __sony_pic_set_wwanpower(u8 state)\n{\n\tstate = !!state;\n\tif (spic_dev.wwan_power == state)\n\t\treturn;\n\tsony_pic_call2(0xB0, state);\n\tsony_pic_call1(0x82);\n\tspic_dev.wwan_power = state;\n}\n\nstatic ssize_t sony_pic_wwanpower_store(struct device *dev,\n\t\tstruct device_attribute *attr,\n\t\tconst char *buffer, size_t count)\n{\n\tunsigned long value;\n\tif (count > 31)\n\t\treturn -EINVAL;\n\n\tif (kstrtoul(buffer, 10, &value))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&spic_dev.lock);\n\t__sony_pic_set_wwanpower(value);\n\tmutex_unlock(&spic_dev.lock);\n\n\treturn count;\n}\n\nstatic ssize_t sony_pic_wwanpower_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buffer)\n{\n\tssize_t count;\n\tmutex_lock(&spic_dev.lock);\n\tcount = sysfs_emit(buffer, \"%d\\n\", spic_dev.wwan_power);\n\tmutex_unlock(&spic_dev.lock);\n\treturn count;\n}\n\n \nstatic void __sony_pic_set_bluetoothpower(u8 state)\n{\n\tstate = !!state;\n\tif (spic_dev.bluetooth_power == state)\n\t\treturn;\n\tsony_pic_call2(0x96, state);\n\tsony_pic_call1(0x82);\n\tspic_dev.bluetooth_power = state;\n}\n\nstatic ssize_t sony_pic_bluetoothpower_store(struct device *dev,\n\t\tstruct device_attribute *attr,\n\t\tconst char *buffer, size_t count)\n{\n\tunsigned long value;\n\tif (count > 31)\n\t\treturn -EINVAL;\n\n\tif (kstrtoul(buffer, 10, &value))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&spic_dev.lock);\n\t__sony_pic_set_bluetoothpower(value);\n\tmutex_unlock(&spic_dev.lock);\n\n\treturn count;\n}\n\nstatic ssize_t sony_pic_bluetoothpower_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buffer)\n{\n\tssize_t count = 0;\n\tmutex_lock(&spic_dev.lock);\n\tcount = sysfs_emit(buffer, \"%d\\n\", spic_dev.bluetooth_power);\n\tmutex_unlock(&spic_dev.lock);\n\treturn count;\n}\n\n \n \n#define SONY_PIC_FAN0_STATUS\t0x93\nstatic int sony_pic_set_fanspeed(unsigned long value)\n{\n\treturn ec_write(SONY_PIC_FAN0_STATUS, value);\n}\n\nstatic int sony_pic_get_fanspeed(u8 *value)\n{\n\treturn ec_read(SONY_PIC_FAN0_STATUS, value);\n}\n\nstatic ssize_t sony_pic_fanspeed_store(struct device *dev,\n\t\tstruct device_attribute *attr,\n\t\tconst char *buffer, size_t count)\n{\n\tunsigned long value;\n\tif (count > 31)\n\t\treturn -EINVAL;\n\n\tif (kstrtoul(buffer, 10, &value))\n\t\treturn -EINVAL;\n\n\tif (sony_pic_set_fanspeed(value))\n\t\treturn -EIO;\n\n\treturn count;\n}\n\nstatic ssize_t sony_pic_fanspeed_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buffer)\n{\n\tu8 value = 0;\n\tif (sony_pic_get_fanspeed(&value))\n\t\treturn -EIO;\n\n\treturn sysfs_emit(buffer, \"%d\\n\", value);\n}\n\n#define SPIC_ATTR(_name, _mode)\t\t\t\t\t\\\nstruct device_attribute spic_attr_##_name = __ATTR(_name,\t\\\n\t\t_mode, sony_pic_## _name ##_show,\t\t\\\n\t\tsony_pic_## _name ##_store)\n\nstatic SPIC_ATTR(bluetoothpower, 0644);\nstatic SPIC_ATTR(wwanpower, 0644);\nstatic SPIC_ATTR(fanspeed, 0644);\n\nstatic struct attribute *spic_attributes[] = {\n\t&spic_attr_bluetoothpower.attr,\n\t&spic_attr_wwanpower.attr,\n\t&spic_attr_fanspeed.attr,\n\tNULL\n};\n\nstatic const struct attribute_group spic_attribute_group = {\n\t.attrs = spic_attributes\n};\n\n \n#ifdef CONFIG_SONYPI_COMPAT\n\n \n#define SONYPI_BAT_FLAGS\t0x81\n#define SONYPI_LCD_LIGHT\t0x96\n#define SONYPI_BAT1_PCTRM\t0xa0\n#define SONYPI_BAT1_LEFT\t0xa2\n#define SONYPI_BAT1_MAXRT\t0xa4\n#define SONYPI_BAT2_PCTRM\t0xa8\n#define SONYPI_BAT2_LEFT\t0xaa\n#define SONYPI_BAT2_MAXRT\t0xac\n#define SONYPI_BAT1_MAXTK\t0xb0\n#define SONYPI_BAT1_FULL\t0xb2\n#define SONYPI_BAT2_MAXTK\t0xb8\n#define SONYPI_BAT2_FULL\t0xba\n#define SONYPI_TEMP_STATUS\t0xC1\n\nstruct sonypi_compat_s {\n\tstruct fasync_struct\t*fifo_async;\n\tstruct kfifo\t\tfifo;\n\tspinlock_t\t\tfifo_lock;\n\twait_queue_head_t\tfifo_proc_list;\n\tatomic_t\t\topen_count;\n};\nstatic struct sonypi_compat_s sonypi_compat = {\n\t.open_count = ATOMIC_INIT(0),\n};\n\nstatic int sonypi_misc_fasync(int fd, struct file *filp, int on)\n{\n\treturn fasync_helper(fd, filp, on, &sonypi_compat.fifo_async);\n}\n\nstatic int sonypi_misc_release(struct inode *inode, struct file *file)\n{\n\tatomic_dec(&sonypi_compat.open_count);\n\treturn 0;\n}\n\nstatic int sonypi_misc_open(struct inode *inode, struct file *file)\n{\n\t \n\tunsigned long flags;\n\n\tspin_lock_irqsave(&sonypi_compat.fifo_lock, flags);\n\n\tif (atomic_inc_return(&sonypi_compat.open_count) == 1)\n\t\tkfifo_reset(&sonypi_compat.fifo);\n\n\tspin_unlock_irqrestore(&sonypi_compat.fifo_lock, flags);\n\n\treturn 0;\n}\n\nstatic ssize_t sonypi_misc_read(struct file *file, char __user *buf,\n\t\t\t\tsize_t count, loff_t *pos)\n{\n\tssize_t ret;\n\tunsigned char c;\n\n\tif ((kfifo_len(&sonypi_compat.fifo) == 0) &&\n\t    (file->f_flags & O_NONBLOCK))\n\t\treturn -EAGAIN;\n\n\tret = wait_event_interruptible(sonypi_compat.fifo_proc_list,\n\t\t\t\t       kfifo_len(&sonypi_compat.fifo) != 0);\n\tif (ret)\n\t\treturn ret;\n\n\twhile (ret < count &&\n\t       (kfifo_out_locked(&sonypi_compat.fifo, &c, sizeof(c),\n\t\t\t  &sonypi_compat.fifo_lock) == sizeof(c))) {\n\t\tif (put_user(c, buf++))\n\t\t\treturn -EFAULT;\n\t\tret++;\n\t}\n\n\tif (ret > 0) {\n\t\tstruct inode *inode = file_inode(file);\n\t\tinode->i_atime = current_time(inode);\n\t}\n\n\treturn ret;\n}\n\nstatic __poll_t sonypi_misc_poll(struct file *file, poll_table *wait)\n{\n\tpoll_wait(file, &sonypi_compat.fifo_proc_list, wait);\n\tif (kfifo_len(&sonypi_compat.fifo))\n\t\treturn EPOLLIN | EPOLLRDNORM;\n\treturn 0;\n}\n\nstatic int ec_read16(u8 addr, u16 *value)\n{\n\tu8 val_lb, val_hb;\n\tif (ec_read(addr, &val_lb))\n\t\treturn -1;\n\tif (ec_read(addr + 1, &val_hb))\n\t\treturn -1;\n\t*value = val_lb | (val_hb << 8);\n\treturn 0;\n}\n\nstatic long sonypi_misc_ioctl(struct file *fp, unsigned int cmd,\n\t\t\t\t\t\t\tunsigned long arg)\n{\n\tint ret = 0;\n\tvoid __user *argp = (void __user *)arg;\n\tu8 val8;\n\tu16 val16;\n\tint value;\n\n\tmutex_lock(&spic_dev.lock);\n\tswitch (cmd) {\n\tcase SONYPI_IOCGBRT:\n\t\tif (sony_bl_props.dev == NULL) {\n\t\t\tret = -EIO;\n\t\t\tbreak;\n\t\t}\n\t\tif (sony_nc_int_call(sony_nc_acpi_handle, \"GBRT\", NULL,\n\t\t\t\t\t&value)) {\n\t\t\tret = -EIO;\n\t\t\tbreak;\n\t\t}\n\t\tval8 = ((value & 0xff) - 1) << 5;\n\t\tif (copy_to_user(argp, &val8, sizeof(val8)))\n\t\t\t\tret = -EFAULT;\n\t\tbreak;\n\tcase SONYPI_IOCSBRT:\n\t\tif (sony_bl_props.dev == NULL) {\n\t\t\tret = -EIO;\n\t\t\tbreak;\n\t\t}\n\t\tif (copy_from_user(&val8, argp, sizeof(val8))) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tvalue = (val8 >> 5) + 1;\n\t\tif (sony_nc_int_call(sony_nc_acpi_handle, \"SBRT\", &value,\n\t\t\t\t\tNULL)) {\n\t\t\tret = -EIO;\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tsony_bl_props.dev->props.brightness =\n\t\t    sony_backlight_get_brightness(sony_bl_props.dev);\n\t\tbreak;\n\tcase SONYPI_IOCGBAT1CAP:\n\t\tif (ec_read16(SONYPI_BAT1_FULL, &val16)) {\n\t\t\tret = -EIO;\n\t\t\tbreak;\n\t\t}\n\t\tif (copy_to_user(argp, &val16, sizeof(val16)))\n\t\t\tret = -EFAULT;\n\t\tbreak;\n\tcase SONYPI_IOCGBAT1REM:\n\t\tif (ec_read16(SONYPI_BAT1_LEFT, &val16)) {\n\t\t\tret = -EIO;\n\t\t\tbreak;\n\t\t}\n\t\tif (copy_to_user(argp, &val16, sizeof(val16)))\n\t\t\tret = -EFAULT;\n\t\tbreak;\n\tcase SONYPI_IOCGBAT2CAP:\n\t\tif (ec_read16(SONYPI_BAT2_FULL, &val16)) {\n\t\t\tret = -EIO;\n\t\t\tbreak;\n\t\t}\n\t\tif (copy_to_user(argp, &val16, sizeof(val16)))\n\t\t\tret = -EFAULT;\n\t\tbreak;\n\tcase SONYPI_IOCGBAT2REM:\n\t\tif (ec_read16(SONYPI_BAT2_LEFT, &val16)) {\n\t\t\tret = -EIO;\n\t\t\tbreak;\n\t\t}\n\t\tif (copy_to_user(argp, &val16, sizeof(val16)))\n\t\t\tret = -EFAULT;\n\t\tbreak;\n\tcase SONYPI_IOCGBATFLAGS:\n\t\tif (ec_read(SONYPI_BAT_FLAGS, &val8)) {\n\t\t\tret = -EIO;\n\t\t\tbreak;\n\t\t}\n\t\tval8 &= 0x07;\n\t\tif (copy_to_user(argp, &val8, sizeof(val8)))\n\t\t\tret = -EFAULT;\n\t\tbreak;\n\tcase SONYPI_IOCGBLUE:\n\t\tval8 = spic_dev.bluetooth_power;\n\t\tif (copy_to_user(argp, &val8, sizeof(val8)))\n\t\t\tret = -EFAULT;\n\t\tbreak;\n\tcase SONYPI_IOCSBLUE:\n\t\tif (copy_from_user(&val8, argp, sizeof(val8))) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\t__sony_pic_set_bluetoothpower(val8);\n\t\tbreak;\n\t \n\tcase SONYPI_IOCGFAN:\n\t\tif (sony_pic_get_fanspeed(&val8)) {\n\t\t\tret = -EIO;\n\t\t\tbreak;\n\t\t}\n\t\tif (copy_to_user(argp, &val8, sizeof(val8)))\n\t\t\tret = -EFAULT;\n\t\tbreak;\n\tcase SONYPI_IOCSFAN:\n\t\tif (copy_from_user(&val8, argp, sizeof(val8))) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tif (sony_pic_set_fanspeed(val8))\n\t\t\tret = -EIO;\n\t\tbreak;\n\t \n\tcase SONYPI_IOCGTEMP:\n\t\tif (ec_read(SONYPI_TEMP_STATUS, &val8)) {\n\t\t\tret = -EIO;\n\t\t\tbreak;\n\t\t}\n\t\tif (copy_to_user(argp, &val8, sizeof(val8)))\n\t\t\tret = -EFAULT;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\tmutex_unlock(&spic_dev.lock);\n\treturn ret;\n}\n\nstatic const struct file_operations sonypi_misc_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.read\t\t= sonypi_misc_read,\n\t.poll\t\t= sonypi_misc_poll,\n\t.open\t\t= sonypi_misc_open,\n\t.release\t= sonypi_misc_release,\n\t.fasync\t\t= sonypi_misc_fasync,\n\t.unlocked_ioctl\t= sonypi_misc_ioctl,\n\t.llseek\t\t= noop_llseek,\n};\n\nstatic struct miscdevice sonypi_misc_device = {\n\t.minor\t\t= MISC_DYNAMIC_MINOR,\n\t.name\t\t= \"sonypi\",\n\t.fops\t\t= &sonypi_misc_fops,\n};\n\nstatic void sonypi_compat_report_event(u8 event)\n{\n\tkfifo_in_locked(&sonypi_compat.fifo, (unsigned char *)&event,\n\t\t\tsizeof(event), &sonypi_compat.fifo_lock);\n\tkill_fasync(&sonypi_compat.fifo_async, SIGIO, POLL_IN);\n\twake_up_interruptible(&sonypi_compat.fifo_proc_list);\n}\n\nstatic int sonypi_compat_init(void)\n{\n\tint error;\n\n\tspin_lock_init(&sonypi_compat.fifo_lock);\n\terror =\n\t kfifo_alloc(&sonypi_compat.fifo, SONY_LAPTOP_BUF_SIZE, GFP_KERNEL);\n\tif (error) {\n\t\tpr_err(\"kfifo_alloc failed\\n\");\n\t\treturn error;\n\t}\n\n\tinit_waitqueue_head(&sonypi_compat.fifo_proc_list);\n\n\tif (minor != -1)\n\t\tsonypi_misc_device.minor = minor;\n\terror = misc_register(&sonypi_misc_device);\n\tif (error) {\n\t\tpr_err(\"misc_register failed\\n\");\n\t\tgoto err_free_kfifo;\n\t}\n\tif (minor == -1)\n\t\tpr_info(\"device allocated minor is %d\\n\",\n\t\t\tsonypi_misc_device.minor);\n\n\treturn 0;\n\nerr_free_kfifo:\n\tkfifo_free(&sonypi_compat.fifo);\n\treturn error;\n}\n\nstatic void sonypi_compat_exit(void)\n{\n\tmisc_deregister(&sonypi_misc_device);\n\tkfifo_free(&sonypi_compat.fifo);\n}\n#else\nstatic int sonypi_compat_init(void) { return 0; }\nstatic void sonypi_compat_exit(void) { }\nstatic void sonypi_compat_report_event(u8 event) { }\n#endif  \n\n \nstatic acpi_status\nsony_pic_read_possible_resource(struct acpi_resource *resource, void *context)\n{\n\tu32 i;\n\tstruct sony_pic_dev *dev = (struct sony_pic_dev *)context;\n\n\tswitch (resource->type) {\n\tcase ACPI_RESOURCE_TYPE_START_DEPENDENT:\n\t\t{\n\t\t\t \n\t\t\tstruct sony_pic_ioport *ioport = kzalloc(sizeof(*ioport), GFP_KERNEL);\n\t\t\tif (!ioport)\n\t\t\t\treturn AE_ERROR;\n\n\t\t\tlist_add(&ioport->list, &dev->ioports);\n\t\t\treturn AE_OK;\n\t\t}\n\n\tcase ACPI_RESOURCE_TYPE_END_DEPENDENT:\n\t\t \n\t\treturn AE_OK;\n\n\tcase ACPI_RESOURCE_TYPE_IRQ:\n\t\t{\n\t\t\tstruct acpi_resource_irq *p = &resource->data.irq;\n\t\t\tstruct sony_pic_irq *interrupt = NULL;\n\t\t\tif (!p->interrupt_count) {\n\t\t\t\t \n\t\t\t\tdprintk(\"Blank IRQ resource\\n\");\n\t\t\t\treturn AE_OK;\n\t\t\t}\n\t\t\tfor (i = 0; i < p->interrupt_count; i++) {\n\t\t\t\tif (!p->interrupts[i]) {\n\t\t\t\t\tpr_warn(\"Invalid IRQ %d\\n\",\n\t\t\t\t\t\tp->interrupts[i]);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tinterrupt = kzalloc(sizeof(*interrupt),\n\t\t\t\t\t\tGFP_KERNEL);\n\t\t\t\tif (!interrupt)\n\t\t\t\t\treturn AE_ERROR;\n\n\t\t\t\tlist_add(&interrupt->list, &dev->interrupts);\n\t\t\t\tinterrupt->irq.triggering = p->triggering;\n\t\t\t\tinterrupt->irq.polarity = p->polarity;\n\t\t\t\tinterrupt->irq.shareable = p->shareable;\n\t\t\t\tinterrupt->irq.interrupt_count = 1;\n\t\t\t\tinterrupt->irq.interrupts[0] = p->interrupts[i];\n\t\t\t}\n\t\t\treturn AE_OK;\n\t\t}\n\tcase ACPI_RESOURCE_TYPE_IO:\n\t\t{\n\t\t\tstruct acpi_resource_io *io = &resource->data.io;\n\t\t\tstruct sony_pic_ioport *ioport =\n\t\t\t\tlist_first_entry(&dev->ioports, struct sony_pic_ioport, list);\n\t\t\tif (!ioport->io1.minimum) {\n\t\t\t\tmemcpy(&ioport->io1, io, sizeof(*io));\n\t\t\t\tdprintk(\"IO1 at 0x%.4x (0x%.2x)\\n\", ioport->io1.minimum,\n\t\t\t\t\t\tioport->io1.address_length);\n\t\t\t}\n\t\t\telse if (!ioport->io2.minimum) {\n\t\t\t\tmemcpy(&ioport->io2, io, sizeof(*io));\n\t\t\t\tdprintk(\"IO2 at 0x%.4x (0x%.2x)\\n\", ioport->io2.minimum,\n\t\t\t\t\t\tioport->io2.address_length);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tpr_err(\"Unknown SPIC Type, more than 2 IO Ports\\n\");\n\t\t\t\treturn AE_ERROR;\n\t\t\t}\n\t\t\treturn AE_OK;\n\t\t}\n\n\tcase ACPI_RESOURCE_TYPE_END_TAG:\n\t\treturn AE_OK;\n\n\tdefault:\n\t\tdprintk(\"Resource %d isn't an IRQ nor an IO port\\n\",\n\t\t\tresource->type);\n\t\treturn AE_CTRL_TERMINATE;\n\n\t}\n}\n\nstatic int sony_pic_possible_resources(struct acpi_device *device)\n{\n\tint result = 0;\n\tacpi_status status = AE_OK;\n\n\tif (!device)\n\t\treturn -EINVAL;\n\n\t \n\t \n\tdprintk(\"Evaluating _STA\\n\");\n\tresult = acpi_bus_get_status(device);\n\tif (result) {\n\t\tpr_warn(\"Unable to read status\\n\");\n\t\tgoto end;\n\t}\n\n\tif (!device->status.enabled)\n\t\tdprintk(\"Device disabled\\n\");\n\telse\n\t\tdprintk(\"Device enabled\\n\");\n\n\t \n\tdprintk(\"Evaluating %s\\n\", METHOD_NAME__PRS);\n\tstatus = acpi_walk_resources(device->handle, METHOD_NAME__PRS,\n\t\t\tsony_pic_read_possible_resource, &spic_dev);\n\tif (ACPI_FAILURE(status)) {\n\t\tpr_warn(\"Failure evaluating %s\\n\", METHOD_NAME__PRS);\n\t\tresult = -ENODEV;\n\t}\nend:\n\treturn result;\n}\n\n \nstatic int sony_pic_disable(struct acpi_device *device)\n{\n\tacpi_status ret = acpi_evaluate_object(device->handle, \"_DIS\", NULL,\n\t\t\t\t\t       NULL);\n\n\tif (ACPI_FAILURE(ret) && ret != AE_NOT_FOUND)\n\t\treturn -ENXIO;\n\n\tdprintk(\"Device disabled\\n\");\n\treturn 0;\n}\n\n\n \nstatic int sony_pic_enable(struct acpi_device *device,\n\t\tstruct sony_pic_ioport *ioport, struct sony_pic_irq *irq)\n{\n\tacpi_status status;\n\tint result = 0;\n\t \n\tstruct {\n\t\tstruct acpi_resource res1;\n\t\tstruct acpi_resource res2;\n\t\tstruct acpi_resource res3;\n\t\tstruct acpi_resource res4;\n\t} *resource;\n\tstruct acpi_buffer buffer = { 0, NULL };\n\n\tif (!ioport || !irq)\n\t\treturn -EINVAL;\n\n\t \n\tresource = kzalloc(sizeof(*resource) + 1, GFP_KERNEL);\n\tif (!resource)\n\t\treturn -ENOMEM;\n\n\tbuffer.length = sizeof(*resource) + 1;\n\tbuffer.pointer = resource;\n\n\t \n\tif (spic_dev.model == SONYPI_DEVICE_TYPE1) {\n\n\t\t \n\t\tresource->res1.type = ACPI_RESOURCE_TYPE_IO;\n\t\tresource->res1.length = sizeof(struct acpi_resource);\n\t\tmemcpy(&resource->res1.data.io, &ioport->io1,\n\t\t\t\tsizeof(struct acpi_resource_io));\n\n\t\tresource->res2.type = ACPI_RESOURCE_TYPE_IO;\n\t\tresource->res2.length = sizeof(struct acpi_resource);\n\t\tmemcpy(&resource->res2.data.io, &ioport->io2,\n\t\t\t\tsizeof(struct acpi_resource_io));\n\n\t\t \n\t\tresource->res3.type = ACPI_RESOURCE_TYPE_IRQ;\n\t\tresource->res3.length = sizeof(struct acpi_resource);\n\t\tmemcpy(&resource->res3.data.irq, &irq->irq,\n\t\t\t\tsizeof(struct acpi_resource_irq));\n\t\t \n\t\tresource->res3.data.irq.shareable = ACPI_SHARED;\n\n\t\tresource->res4.type = ACPI_RESOURCE_TYPE_END_TAG;\n\t\tresource->res4.length = sizeof(struct acpi_resource);\n\t}\n\t \n\telse {\n\t\t \n\t\tresource->res1.type = ACPI_RESOURCE_TYPE_IO;\n\t\tresource->res1.length = sizeof(struct acpi_resource);\n\t\tmemcpy(&resource->res1.data.io, &ioport->io1,\n\t\t\t\tsizeof(struct acpi_resource_io));\n\n\t\t \n\t\tresource->res2.type = ACPI_RESOURCE_TYPE_IRQ;\n\t\tresource->res2.length = sizeof(struct acpi_resource);\n\t\tmemcpy(&resource->res2.data.irq, &irq->irq,\n\t\t\t\tsizeof(struct acpi_resource_irq));\n\t\t \n\t\tresource->res2.data.irq.shareable = ACPI_SHARED;\n\n\t\tresource->res3.type = ACPI_RESOURCE_TYPE_END_TAG;\n\t\tresource->res3.length = sizeof(struct acpi_resource);\n\t}\n\n\t \n\tdprintk(\"Evaluating _SRS\\n\");\n\tstatus = acpi_set_current_resources(device->handle, &buffer);\n\n\t \n\tif (ACPI_FAILURE(status)) {\n\t\tpr_err(\"Error evaluating _SRS\\n\");\n\t\tresult = -ENODEV;\n\t\tgoto end;\n\t}\n\n\t \n\tsony_pic_call1(0x82);\n\tsony_pic_call2(0x81, 0xff);\n\tsony_pic_call1(compat ? 0x92 : 0x82);\n\nend:\n\tkfree(resource);\n\treturn result;\n}\n\n \nstatic irqreturn_t sony_pic_irq(int irq, void *dev_id)\n{\n\tint i, j;\n\tu8 ev = 0;\n\tu8 data_mask = 0;\n\tu8 device_event = 0;\n\n\tstruct sony_pic_dev *dev = (struct sony_pic_dev *) dev_id;\n\n\tev = inb_p(dev->cur_ioport->io1.minimum);\n\tif (dev->cur_ioport->io2.minimum)\n\t\tdata_mask = inb_p(dev->cur_ioport->io2.minimum);\n\telse\n\t\tdata_mask = inb_p(dev->cur_ioport->io1.minimum +\n\t\t\t\tdev->evport_offset);\n\n\tdprintk(\"event ([%.2x] [%.2x]) at port 0x%.4x(+0x%.2x)\\n\",\n\t\t\tev, data_mask, dev->cur_ioport->io1.minimum,\n\t\t\tdev->evport_offset);\n\n\tif (ev == 0x00 || ev == 0xff)\n\t\treturn IRQ_HANDLED;\n\n\tfor (i = 0; dev->event_types[i].mask; i++) {\n\n\t\tif ((data_mask & dev->event_types[i].data) !=\n\t\t    dev->event_types[i].data)\n\t\t\tcontinue;\n\n\t\tif (!(mask & dev->event_types[i].mask))\n\t\t\tcontinue;\n\n\t\tfor (j = 0; dev->event_types[i].events[j].event; j++) {\n\t\t\tif (ev == dev->event_types[i].events[j].data) {\n\t\t\t\tdevice_event =\n\t\t\t\t\tdev->event_types[i].events[j].event;\n\t\t\t\t \n\t\t\t\tif (!device_event)\n\t\t\t\t\treturn IRQ_HANDLED;\n\t\t\t\tgoto found;\n\t\t\t}\n\t\t}\n\t}\n\t \n\tif (dev->handle_irq && dev->handle_irq(data_mask, ev) == 0)\n\t\treturn IRQ_HANDLED;\n\n\tdprintk(\"unknown event ([%.2x] [%.2x]) at port 0x%.4x(+0x%.2x)\\n\",\n\t\t\tev, data_mask, dev->cur_ioport->io1.minimum,\n\t\t\tdev->evport_offset);\n\treturn IRQ_HANDLED;\n\nfound:\n\tsony_laptop_report_input_event(device_event);\n\tsonypi_compat_report_event(device_event);\n\treturn IRQ_HANDLED;\n}\n\n \nstatic void sony_pic_remove(struct acpi_device *device)\n{\n\tstruct sony_pic_ioport *io, *tmp_io;\n\tstruct sony_pic_irq *irq, *tmp_irq;\n\n\tif (sony_pic_disable(device)) {\n\t\tpr_err(\"Couldn't disable device\\n\");\n\t\treturn;\n\t}\n\n\tfree_irq(spic_dev.cur_irq->irq.interrupts[0], &spic_dev);\n\trelease_region(spic_dev.cur_ioport->io1.minimum,\n\t\t\tspic_dev.cur_ioport->io1.address_length);\n\tif (spic_dev.cur_ioport->io2.minimum)\n\t\trelease_region(spic_dev.cur_ioport->io2.minimum,\n\t\t\t\tspic_dev.cur_ioport->io2.address_length);\n\n\tsonypi_compat_exit();\n\n\tsony_laptop_remove_input();\n\n\t \n\tsysfs_remove_group(&sony_pf_device->dev.kobj, &spic_attribute_group);\n\tsony_pf_remove();\n\n\tlist_for_each_entry_safe(io, tmp_io, &spic_dev.ioports, list) {\n\t\tlist_del(&io->list);\n\t\tkfree(io);\n\t}\n\tlist_for_each_entry_safe(irq, tmp_irq, &spic_dev.interrupts, list) {\n\t\tlist_del(&irq->list);\n\t\tkfree(irq);\n\t}\n\tspic_dev.cur_ioport = NULL;\n\tspic_dev.cur_irq = NULL;\n\n\tdprintk(SONY_PIC_DRIVER_NAME \" removed.\\n\");\n}\n\nstatic int sony_pic_add(struct acpi_device *device)\n{\n\tint result;\n\tstruct sony_pic_ioport *io, *tmp_io;\n\tstruct sony_pic_irq *irq, *tmp_irq;\n\n\tspic_dev.acpi_dev = device;\n\tstrcpy(acpi_device_class(device), \"sony/hotkey\");\n\tsony_pic_detect_device_type(&spic_dev);\n\tmutex_init(&spic_dev.lock);\n\n\t \n\tresult = sony_pic_possible_resources(device);\n\tif (result) {\n\t\tpr_err(\"Unable to read possible resources\\n\");\n\t\tgoto err_free_resources;\n\t}\n\n\t \n\tresult = sony_laptop_setup_input(device);\n\tif (result) {\n\t\tpr_err(\"Unable to create input devices\\n\");\n\t\tgoto err_free_resources;\n\t}\n\n\tresult = sonypi_compat_init();\n\tif (result)\n\t\tgoto err_remove_input;\n\n\t \n\tlist_for_each_entry_reverse(io, &spic_dev.ioports, list) {\n\t\tif (request_region(io->io1.minimum, io->io1.address_length,\n\t\t\t\t\t\"Sony Programmable I/O Device\")) {\n\t\t\tdprintk(\"I/O port1: 0x%.4x (0x%.4x) + 0x%.2x\\n\",\n\t\t\t\t\tio->io1.minimum, io->io1.maximum,\n\t\t\t\t\tio->io1.address_length);\n\t\t\t \n\t\t\tif (io->io2.minimum) {\n\t\t\t\tif (request_region(io->io2.minimum,\n\t\t\t\t\t\tio->io2.address_length,\n\t\t\t\t\t\t\"Sony Programmable I/O Device\")) {\n\t\t\t\t\tdprintk(\"I/O port2: 0x%.4x (0x%.4x) + 0x%.2x\\n\",\n\t\t\t\t\t\t\tio->io2.minimum, io->io2.maximum,\n\t\t\t\t\t\t\tio->io2.address_length);\n\t\t\t\t\tspic_dev.cur_ioport = io;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdprintk(\"Unable to get I/O port2: \"\n\t\t\t\t\t\t\t\"0x%.4x (0x%.4x) + 0x%.2x\\n\",\n\t\t\t\t\t\t\tio->io2.minimum, io->io2.maximum,\n\t\t\t\t\t\t\tio->io2.address_length);\n\t\t\t\t\trelease_region(io->io1.minimum,\n\t\t\t\t\t\t\tio->io1.address_length);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tspic_dev.cur_ioport = io;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (!spic_dev.cur_ioport) {\n\t\tpr_err(\"Failed to request_region\\n\");\n\t\tresult = -ENODEV;\n\t\tgoto err_remove_compat;\n\t}\n\n\t \n\tlist_for_each_entry_reverse(irq, &spic_dev.interrupts, list) {\n\t\tif (!request_irq(irq->irq.interrupts[0], sony_pic_irq,\n\t\t\t\t\t0, \"sony-laptop\", &spic_dev)) {\n\t\t\tdprintk(\"IRQ: %d - triggering: %d - \"\n\t\t\t\t\t\"polarity: %d - shr: %d\\n\",\n\t\t\t\t\tirq->irq.interrupts[0],\n\t\t\t\t\tirq->irq.triggering,\n\t\t\t\t\tirq->irq.polarity,\n\t\t\t\t\tirq->irq.shareable);\n\t\t\tspic_dev.cur_irq = irq;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!spic_dev.cur_irq) {\n\t\tpr_err(\"Failed to request_irq\\n\");\n\t\tresult = -ENODEV;\n\t\tgoto err_release_region;\n\t}\n\n\t \n\tresult = sony_pic_enable(device, spic_dev.cur_ioport, spic_dev.cur_irq);\n\tif (result) {\n\t\tpr_err(\"Couldn't enable device\\n\");\n\t\tgoto err_free_irq;\n\t}\n\n\tspic_dev.bluetooth_power = -1;\n\t \n\tresult = sony_pf_add();\n\tif (result)\n\t\tgoto err_disable_device;\n\n\tresult = sysfs_create_group(&sony_pf_device->dev.kobj, &spic_attribute_group);\n\tif (result)\n\t\tgoto err_remove_pf;\n\n\tpr_info(\"SPIC setup done.\\n\");\n\treturn 0;\n\nerr_remove_pf:\n\tsony_pf_remove();\n\nerr_disable_device:\n\tsony_pic_disable(device);\n\nerr_free_irq:\n\tfree_irq(spic_dev.cur_irq->irq.interrupts[0], &spic_dev);\n\nerr_release_region:\n\trelease_region(spic_dev.cur_ioport->io1.minimum,\n\t\t\tspic_dev.cur_ioport->io1.address_length);\n\tif (spic_dev.cur_ioport->io2.minimum)\n\t\trelease_region(spic_dev.cur_ioport->io2.minimum,\n\t\t\t\tspic_dev.cur_ioport->io2.address_length);\n\nerr_remove_compat:\n\tsonypi_compat_exit();\n\nerr_remove_input:\n\tsony_laptop_remove_input();\n\nerr_free_resources:\n\tlist_for_each_entry_safe(io, tmp_io, &spic_dev.ioports, list) {\n\t\tlist_del(&io->list);\n\t\tkfree(io);\n\t}\n\tlist_for_each_entry_safe(irq, tmp_irq, &spic_dev.interrupts, list) {\n\t\tlist_del(&irq->list);\n\t\tkfree(irq);\n\t}\n\tspic_dev.cur_ioport = NULL;\n\tspic_dev.cur_irq = NULL;\n\n\treturn result;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int sony_pic_suspend(struct device *dev)\n{\n\tif (sony_pic_disable(to_acpi_device(dev)))\n\t\treturn -ENXIO;\n\treturn 0;\n}\n\nstatic int sony_pic_resume(struct device *dev)\n{\n\tsony_pic_enable(to_acpi_device(dev),\n\t\t\tspic_dev.cur_ioport, spic_dev.cur_irq);\n\treturn 0;\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(sony_pic_pm, sony_pic_suspend, sony_pic_resume);\n\nstatic const struct acpi_device_id sony_pic_device_ids[] = {\n\t{SONY_PIC_HID, 0},\n\t{\"\", 0},\n};\n\nstatic struct acpi_driver sony_pic_driver = {\n\t.name = SONY_PIC_DRIVER_NAME,\n\t.class = SONY_PIC_CLASS,\n\t.ids = sony_pic_device_ids,\n\t.owner = THIS_MODULE,\n\t.ops = {\n\t\t.add = sony_pic_add,\n\t\t.remove = sony_pic_remove,\n\t\t},\n\t.drv.pm = &sony_pic_pm,\n};\n\nstatic const struct dmi_system_id sonypi_dmi_table[] __initconst = {\n\t{\n\t\t.ident = \"Sony Vaio\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Sony Corporation\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"PCG-\"),\n\t\t},\n\t},\n\t{\n\t\t.ident = \"Sony Vaio\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Sony Corporation\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"VGN-\"),\n\t\t},\n\t},\n\t{ }\n};\n\nstatic int __init sony_laptop_init(void)\n{\n\tint result;\n\n\tif (!no_spic && dmi_check_system(sonypi_dmi_table)) {\n\t\tresult = acpi_bus_register_driver(&sony_pic_driver);\n\t\tif (result) {\n\t\t\tpr_err(\"Unable to register SPIC driver\\n\");\n\t\t\tgoto out;\n\t\t}\n\t\tspic_drv_registered = 1;\n\t}\n\n\tresult = acpi_bus_register_driver(&sony_nc_driver);\n\tif (result) {\n\t\tpr_err(\"Unable to register SNC driver\\n\");\n\t\tgoto out_unregister_pic;\n\t}\n\n\treturn 0;\n\nout_unregister_pic:\n\tif (spic_drv_registered)\n\t\tacpi_bus_unregister_driver(&sony_pic_driver);\nout:\n\treturn result;\n}\n\nstatic void __exit sony_laptop_exit(void)\n{\n\tacpi_bus_unregister_driver(&sony_nc_driver);\n\tif (spic_drv_registered)\n\t\tacpi_bus_unregister_driver(&sony_pic_driver);\n}\n\nmodule_init(sony_laptop_init);\nmodule_exit(sony_laptop_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}