{
  "module_name": "huawei-wmi.c",
  "hash_id": "489718b866e04b1b5408ae9fcc37a759fa13ee11f6082fb0b220bea6ea8cf2e5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/x86/huawei-wmi.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/dmi.h>\n#include <linux/input.h>\n#include <linux/input/sparse-keymap.h>\n#include <linux/leds.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/platform_device.h>\n#include <linux/power_supply.h>\n#include <linux/sysfs.h>\n#include <linux/wmi.h>\n#include <acpi/battery.h>\n\n \n#define HWMI_METHOD_GUID \"ABBC0F5B-8EA1-11D1-A000-C90629100000\"\n#define HWMI_EVENT_GUID \"ABBC0F5C-8EA1-11D1-A000-C90629100000\"\n\n \n#define WMI0_EXPENSIVE_GUID \"39142400-C6A3-40fa-BADB-8A2652834100\"\n#define WMI0_EVENT_GUID \"59142400-C6A3-40fa-BADB-8A2652834100\"\n\n \n\nenum {\n\tBATTERY_THRESH_GET\t\t= 0x00001103,  \n\tBATTERY_THRESH_SET\t\t= 0x00001003,  \n\tFN_LOCK_GET\t\t\t= 0x00000604,  \n\tFN_LOCK_SET\t\t\t= 0x00000704,  \n\tMICMUTE_LED_SET\t\t\t= 0x00000b04,  \n};\n\nunion hwmi_arg {\n\tu64 cmd;\n\tu8 args[8];\n};\n\nstruct quirk_entry {\n\tbool battery_reset;\n\tbool ec_micmute;\n\tbool report_brightness;\n};\n\nstatic struct quirk_entry *quirks;\n\nstruct huawei_wmi_debug {\n\tstruct dentry *root;\n\tu64 arg;\n};\n\nstruct huawei_wmi {\n\tbool battery_available;\n\tbool fn_lock_available;\n\n\tstruct huawei_wmi_debug debug;\n\tstruct led_classdev cdev;\n\tstruct device *dev;\n\n\tstruct mutex wmi_lock;\n};\n\nstatic struct huawei_wmi *huawei_wmi;\n\nstatic const struct key_entry huawei_wmi_keymap[] = {\n\t{ KE_KEY,    0x281, { KEY_BRIGHTNESSDOWN } },\n\t{ KE_KEY,    0x282, { KEY_BRIGHTNESSUP } },\n\t{ KE_KEY,    0x284, { KEY_MUTE } },\n\t{ KE_KEY,    0x285, { KEY_VOLUMEDOWN } },\n\t{ KE_KEY,    0x286, { KEY_VOLUMEUP } },\n\t{ KE_KEY,    0x287, { KEY_MICMUTE } },\n\t{ KE_KEY,    0x289, { KEY_WLAN } },\n\t\n\t{ KE_KEY,    0x28a, { KEY_CONFIG } },\n\t\n\t{ KE_IGNORE, 0x293, { KEY_KBDILLUMTOGGLE } },\n\t{ KE_IGNORE, 0x294, { KEY_KBDILLUMUP } },\n\t{ KE_IGNORE, 0x295, { KEY_KBDILLUMUP } },\n\t\n\t{ KE_KEY,    0x2c1, { KEY_RESERVED } },\n\t{ KE_END,\t 0 }\n};\n\nstatic int battery_reset = -1;\nstatic int report_brightness = -1;\n\nmodule_param(battery_reset, bint, 0444);\nMODULE_PARM_DESC(battery_reset,\n\t\t\"Reset battery charge values to (0-0) before disabling it using (0-100)\");\nmodule_param(report_brightness, bint, 0444);\nMODULE_PARM_DESC(report_brightness,\n\t\t\"Report brightness keys.\");\n\n \n\nstatic int __init dmi_matched(const struct dmi_system_id *dmi)\n{\n\tquirks = dmi->driver_data;\n\treturn 1;\n}\n\nstatic struct quirk_entry quirk_unknown = {\n};\n\nstatic struct quirk_entry quirk_battery_reset = {\n\t.battery_reset = true,\n};\n\nstatic struct quirk_entry quirk_matebook_x = {\n\t.ec_micmute = true,\n\t.report_brightness = true,\n};\n\nstatic const struct dmi_system_id huawei_quirks[] = {\n\t{\n\t\t.callback = dmi_matched,\n\t\t.ident = \"Huawei MACH-WX9\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"HUAWEI\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"MACH-WX9\"),\n\t\t},\n\t\t.driver_data = &quirk_battery_reset\n\t},\n\t{\n\t\t.callback = dmi_matched,\n\t\t.ident = \"Huawei MateBook X\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"HUAWEI\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"HUAWEI MateBook X\")\n\t\t},\n\t\t.driver_data = &quirk_matebook_x\n\t},\n\t{  }\n};\n\n \n\nstatic int huawei_wmi_call(struct huawei_wmi *huawei,\n\t\t\t   struct acpi_buffer *in, struct acpi_buffer *out)\n{\n\tacpi_status status;\n\n\tmutex_lock(&huawei->wmi_lock);\n\tstatus = wmi_evaluate_method(HWMI_METHOD_GUID, 0, 1, in, out);\n\tmutex_unlock(&huawei->wmi_lock);\n\tif (ACPI_FAILURE(status)) {\n\t\tdev_err(huawei->dev, \"Failed to evaluate wmi method\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int huawei_wmi_cmd(u64 arg, u8 *buf, size_t buflen)\n{\n\tstruct huawei_wmi *huawei = huawei_wmi;\n\tstruct acpi_buffer out = { ACPI_ALLOCATE_BUFFER, NULL };\n\tstruct acpi_buffer in;\n\tunion acpi_object *obj;\n\tsize_t len;\n\tint err, i;\n\n\tin.length = sizeof(arg);\n\tin.pointer = &arg;\n\n\t \n\tfor (i = 0; i < 2; i++) {\n\t\terr = huawei_wmi_call(huawei, &in, &out);\n\t\tif (err)\n\t\t\tgoto fail_cmd;\n\n\t\tobj = out.pointer;\n\t\tif (!obj) {\n\t\t\terr = -EIO;\n\t\t\tgoto fail_cmd;\n\t\t}\n\n\t\tswitch (obj->type) {\n\t\t \n\t\tcase ACPI_TYPE_BUFFER:\n\t\t\tif (obj->buffer.length == 0x104) {\n\t\t\t\t\n\t\t\t\tobj->buffer.pointer += 4;\n\t\t\t\tlen = 0x100;\n\t\t\t} else {\n\t\t\t\tdev_err(huawei->dev, \"Bad buffer length, got %d\\n\", obj->buffer.length);\n\t\t\t\terr = -EIO;\n\t\t\t\tgoto fail_cmd;\n\t\t\t}\n\n\t\t\tbreak;\n\t\t \n\t\tcase ACPI_TYPE_PACKAGE:\n\t\t\tif (obj->package.count != 2) {\n\t\t\t\tdev_err(huawei->dev, \"Bad package count, got %d\\n\", obj->package.count);\n\t\t\t\terr = -EIO;\n\t\t\t\tgoto fail_cmd;\n\t\t\t}\n\n\t\t\tobj = &obj->package.elements[1];\n\t\t\tif (obj->type != ACPI_TYPE_BUFFER) {\n\t\t\t\tdev_err(huawei->dev, \"Bad package element type, got %d\\n\", obj->type);\n\t\t\t\terr = -EIO;\n\t\t\t\tgoto fail_cmd;\n\t\t\t}\n\t\t\tlen = obj->buffer.length;\n\n\t\t\tbreak;\n\t\t \n\t\tdefault:\n\t\t\tdev_err(huawei->dev, \"Unexpected obj type, got: %d\\n\", obj->type);\n\t\t\terr = -EIO;\n\t\t\tgoto fail_cmd;\n\t\t}\n\n\t\tif (!*obj->buffer.pointer)\n\t\t\tbreak;\n\t}\n\n\terr = (*obj->buffer.pointer) ? -ENODEV : 0;\n\n\tif (buf) {\n\t\tlen = min(buflen, len);\n\t\tmemcpy(buf, obj->buffer.pointer, len);\n\t}\n\nfail_cmd:\n\tkfree(out.pointer);\n\treturn err;\n}\n\n \n\nstatic int huawei_wmi_micmute_led_set(struct led_classdev *led_cdev,\n\t\tenum led_brightness brightness)\n{\n\t \n\tif (quirks && quirks->ec_micmute) {\n\t\tchar *acpi_method;\n\t\tacpi_handle handle;\n\t\tacpi_status status;\n\t\tunion acpi_object args[3];\n\t\tstruct acpi_object_list arg_list = {\n\t\t\t.pointer = args,\n\t\t\t.count = ARRAY_SIZE(args),\n\t\t};\n\n\t\thandle = ec_get_handle();\n\t\tif (!handle)\n\t\t\treturn -ENODEV;\n\n\t\targs[0].type = args[1].type = args[2].type = ACPI_TYPE_INTEGER;\n\t\targs[1].integer.value = 0x04;\n\n\t\tif (acpi_has_method(handle, \"SPIN\")) {\n\t\t\tacpi_method = \"SPIN\";\n\t\t\targs[0].integer.value = 0;\n\t\t\targs[2].integer.value = brightness ? 1 : 0;\n\t\t} else if (acpi_has_method(handle, \"WPIN\")) {\n\t\t\tacpi_method = \"WPIN\";\n\t\t\targs[0].integer.value = 1;\n\t\t\targs[2].integer.value = brightness ? 0 : 1;\n\t\t} else {\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\tstatus = acpi_evaluate_object(handle, acpi_method, &arg_list, NULL);\n\t\tif (ACPI_FAILURE(status))\n\t\t\treturn -ENODEV;\n\n\t\treturn 0;\n\t} else {\n\t\tunion hwmi_arg arg;\n\n\t\targ.cmd = MICMUTE_LED_SET;\n\t\targ.args[2] = brightness;\n\n\t\treturn huawei_wmi_cmd(arg.cmd, NULL, 0);\n\t}\n}\n\nstatic void huawei_wmi_leds_setup(struct device *dev)\n{\n\tstruct huawei_wmi *huawei = dev_get_drvdata(dev);\n\n\thuawei->cdev.name = \"platform::micmute\";\n\thuawei->cdev.max_brightness = 1;\n\thuawei->cdev.brightness_set_blocking = &huawei_wmi_micmute_led_set;\n\thuawei->cdev.default_trigger = \"audio-micmute\";\n\thuawei->cdev.brightness = ledtrig_audio_get(LED_AUDIO_MICMUTE);\n\thuawei->cdev.dev = dev;\n\thuawei->cdev.flags = LED_CORE_SUSPENDRESUME;\n\n\tdevm_led_classdev_register(dev, &huawei->cdev);\n}\n\n \n\nstatic int huawei_wmi_battery_get(int *start, int *end)\n{\n\tu8 ret[0x100];\n\tint err, i;\n\n\terr = huawei_wmi_cmd(BATTERY_THRESH_GET, ret, sizeof(ret));\n\tif (err)\n\t\treturn err;\n\n\t \n\ti = ARRAY_SIZE(ret) - 1;\n\tdo {\n\t\tif (start)\n\t\t\t*start = ret[i-1];\n\t\tif (end)\n\t\t\t*end = ret[i];\n\t} while (i > 2 && !ret[i--]);\n\n\treturn 0;\n}\n\nstatic int huawei_wmi_battery_set(int start, int end)\n{\n\tunion hwmi_arg arg;\n\tint err;\n\n\tif (start < 0 || end < 0 || start > 100 || end > 100)\n\t\treturn -EINVAL;\n\n\targ.cmd = BATTERY_THRESH_SET;\n\targ.args[2] = start;\n\targ.args[3] = end;\n\n\t \n\tif (quirks && quirks->battery_reset && start == 0 && end == 100) {\n\t\terr = huawei_wmi_battery_set(0, 0);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tmsleep(1000);\n\t}\n\n\terr = huawei_wmi_cmd(arg.cmd, NULL, 0);\n\n\treturn err;\n}\n\nstatic ssize_t charge_control_start_threshold_show(struct device *dev,\n\t\tstruct device_attribute *attr,\n\t\tchar *buf)\n{\n\tint err, start;\n\n\terr = huawei_wmi_battery_get(&start, NULL);\n\tif (err)\n\t\treturn err;\n\n\treturn sprintf(buf, \"%d\\n\", start);\n}\n\nstatic ssize_t charge_control_end_threshold_show(struct device *dev,\n\t\tstruct device_attribute *attr,\n\t\tchar *buf)\n{\n\tint err, end;\n\n\terr = huawei_wmi_battery_get(NULL, &end);\n\tif (err)\n\t\treturn err;\n\n\treturn sprintf(buf, \"%d\\n\", end);\n}\n\nstatic ssize_t charge_control_thresholds_show(struct device *dev,\n\t\tstruct device_attribute *attr,\n\t\tchar *buf)\n{\n\tint err, start, end;\n\n\terr = huawei_wmi_battery_get(&start, &end);\n\tif (err)\n\t\treturn err;\n\n\treturn sprintf(buf, \"%d %d\\n\", start, end);\n}\n\nstatic ssize_t charge_control_start_threshold_store(struct device *dev,\n\t\tstruct device_attribute *attr,\n\t\tconst char *buf, size_t size)\n{\n\tint err, start, end;\n\n\terr = huawei_wmi_battery_get(NULL, &end);\n\tif (err)\n\t\treturn err;\n\n\tif (sscanf(buf, \"%d\", &start) != 1)\n\t\treturn -EINVAL;\n\n\terr = huawei_wmi_battery_set(start, end);\n\tif (err)\n\t\treturn err;\n\n\treturn size;\n}\n\nstatic ssize_t charge_control_end_threshold_store(struct device *dev,\n\t\tstruct device_attribute *attr,\n\t\tconst char *buf, size_t size)\n{\n\tint err, start, end;\n\n\terr = huawei_wmi_battery_get(&start, NULL);\n\tif (err)\n\t\treturn err;\n\n\tif (sscanf(buf, \"%d\", &end) != 1)\n\t\treturn -EINVAL;\n\n\terr = huawei_wmi_battery_set(start, end);\n\tif (err)\n\t\treturn err;\n\n\treturn size;\n}\n\nstatic ssize_t charge_control_thresholds_store(struct device *dev,\n\t\tstruct device_attribute *attr,\n\t\tconst char *buf, size_t size)\n{\n\tint err, start, end;\n\n\tif (sscanf(buf, \"%d %d\", &start, &end) != 2)\n\t\treturn -EINVAL;\n\n\terr = huawei_wmi_battery_set(start, end);\n\tif (err)\n\t\treturn err;\n\n\treturn size;\n}\n\nstatic DEVICE_ATTR_RW(charge_control_start_threshold);\nstatic DEVICE_ATTR_RW(charge_control_end_threshold);\nstatic DEVICE_ATTR_RW(charge_control_thresholds);\n\nstatic int huawei_wmi_battery_add(struct power_supply *battery, struct acpi_battery_hook *hook)\n{\n\tint err = 0;\n\n\terr = device_create_file(&battery->dev, &dev_attr_charge_control_start_threshold);\n\tif (err)\n\t\treturn err;\n\n\terr = device_create_file(&battery->dev, &dev_attr_charge_control_end_threshold);\n\tif (err)\n\t\tdevice_remove_file(&battery->dev, &dev_attr_charge_control_start_threshold);\n\n\treturn err;\n}\n\nstatic int huawei_wmi_battery_remove(struct power_supply *battery, struct acpi_battery_hook *hook)\n{\n\tdevice_remove_file(&battery->dev, &dev_attr_charge_control_start_threshold);\n\tdevice_remove_file(&battery->dev, &dev_attr_charge_control_end_threshold);\n\n\treturn 0;\n}\n\nstatic struct acpi_battery_hook huawei_wmi_battery_hook = {\n\t.add_battery = huawei_wmi_battery_add,\n\t.remove_battery = huawei_wmi_battery_remove,\n\t.name = \"Huawei Battery Extension\"\n};\n\nstatic void huawei_wmi_battery_setup(struct device *dev)\n{\n\tstruct huawei_wmi *huawei = dev_get_drvdata(dev);\n\n\thuawei->battery_available = true;\n\tif (huawei_wmi_battery_get(NULL, NULL)) {\n\t\thuawei->battery_available = false;\n\t\treturn;\n\t}\n\n\tbattery_hook_register(&huawei_wmi_battery_hook);\n\tdevice_create_file(dev, &dev_attr_charge_control_thresholds);\n}\n\nstatic void huawei_wmi_battery_exit(struct device *dev)\n{\n\tstruct huawei_wmi *huawei = dev_get_drvdata(dev);\n\n\tif (huawei->battery_available) {\n\t\tbattery_hook_unregister(&huawei_wmi_battery_hook);\n\t\tdevice_remove_file(dev, &dev_attr_charge_control_thresholds);\n\t}\n}\n\n \n\nstatic int huawei_wmi_fn_lock_get(int *on)\n{\n\tu8 ret[0x100] = { 0 };\n\tint err, i;\n\n\terr = huawei_wmi_cmd(FN_LOCK_GET, ret, 0x100);\n\tif (err)\n\t\treturn err;\n\n\t \n\ti = 1;\n\tdo {\n\t\tif (on)\n\t\t\t*on = ret[i] - 1; \n\t} while (i < 0xff && !ret[i++]);\n\n\treturn 0;\n}\n\nstatic int huawei_wmi_fn_lock_set(int on)\n{\n\tunion hwmi_arg arg;\n\n\targ.cmd = FN_LOCK_SET;\n\targ.args[2] = on + 1; \n\n\treturn huawei_wmi_cmd(arg.cmd, NULL, 0);\n}\n\nstatic ssize_t fn_lock_state_show(struct device *dev,\n\t\tstruct device_attribute *attr,\n\t\tchar *buf)\n{\n\tint err, on;\n\n\terr = huawei_wmi_fn_lock_get(&on);\n\tif (err)\n\t\treturn err;\n\n\treturn sprintf(buf, \"%d\\n\", on);\n}\n\nstatic ssize_t fn_lock_state_store(struct device *dev,\n\t\tstruct device_attribute *attr,\n\t\tconst char *buf, size_t size)\n{\n\tint on, err;\n\n\tif (kstrtoint(buf, 10, &on) ||\n\t\t\ton < 0 || on > 1)\n\t\treturn -EINVAL;\n\n\terr = huawei_wmi_fn_lock_set(on);\n\tif (err)\n\t\treturn err;\n\n\treturn size;\n}\n\nstatic DEVICE_ATTR_RW(fn_lock_state);\n\nstatic void huawei_wmi_fn_lock_setup(struct device *dev)\n{\n\tstruct huawei_wmi *huawei = dev_get_drvdata(dev);\n\n\thuawei->fn_lock_available = true;\n\tif (huawei_wmi_fn_lock_get(NULL)) {\n\t\thuawei->fn_lock_available = false;\n\t\treturn;\n\t}\n\n\tdevice_create_file(dev, &dev_attr_fn_lock_state);\n}\n\nstatic void huawei_wmi_fn_lock_exit(struct device *dev)\n{\n\tstruct huawei_wmi *huawei = dev_get_drvdata(dev);\n\n\tif (huawei->fn_lock_available)\n\t\tdevice_remove_file(dev, &dev_attr_fn_lock_state);\n}\n\n \n\nstatic void huawei_wmi_debugfs_call_dump(struct seq_file *m, void *data,\n\t\tunion acpi_object *obj)\n{\n\tstruct huawei_wmi *huawei = m->private;\n\tint i;\n\n\tswitch (obj->type) {\n\tcase ACPI_TYPE_INTEGER:\n\t\tseq_printf(m, \"0x%llx\", obj->integer.value);\n\t\tbreak;\n\tcase ACPI_TYPE_STRING:\n\t\tseq_printf(m, \"\\\"%.*s\\\"\", obj->string.length, obj->string.pointer);\n\t\tbreak;\n\tcase ACPI_TYPE_BUFFER:\n\t\tseq_puts(m, \"{\");\n\t\tfor (i = 0; i < obj->buffer.length; i++) {\n\t\t\tseq_printf(m, \"0x%02x\", obj->buffer.pointer[i]);\n\t\t\tif (i < obj->buffer.length - 1)\n\t\t\t\tseq_puts(m, \",\");\n\t\t}\n\t\tseq_puts(m, \"}\");\n\t\tbreak;\n\tcase ACPI_TYPE_PACKAGE:\n\t\tseq_puts(m, \"[\");\n\t\tfor (i = 0; i < obj->package.count; i++) {\n\t\t\thuawei_wmi_debugfs_call_dump(m, huawei, &obj->package.elements[i]);\n\t\t\tif (i < obj->package.count - 1)\n\t\t\t\tseq_puts(m, \",\");\n\t\t}\n\t\tseq_puts(m, \"]\");\n\t\tbreak;\n\tdefault:\n\t\tdev_err(huawei->dev, \"Unexpected obj type, got %d\\n\", obj->type);\n\t\treturn;\n\t}\n}\n\nstatic int huawei_wmi_debugfs_call_show(struct seq_file *m, void *data)\n{\n\tstruct huawei_wmi *huawei = m->private;\n\tstruct acpi_buffer out = { ACPI_ALLOCATE_BUFFER, NULL };\n\tstruct acpi_buffer in;\n\tunion acpi_object *obj;\n\tint err;\n\n\tin.length = sizeof(u64);\n\tin.pointer = &huawei->debug.arg;\n\n\terr = huawei_wmi_call(huawei, &in, &out);\n\tif (err)\n\t\treturn err;\n\n\tobj = out.pointer;\n\tif (!obj) {\n\t\terr = -EIO;\n\t\tgoto fail_debugfs_call;\n\t}\n\n\thuawei_wmi_debugfs_call_dump(m, huawei, obj);\n\nfail_debugfs_call:\n\tkfree(out.pointer);\n\treturn err;\n}\n\nDEFINE_SHOW_ATTRIBUTE(huawei_wmi_debugfs_call);\n\nstatic void huawei_wmi_debugfs_setup(struct device *dev)\n{\n\tstruct huawei_wmi *huawei = dev_get_drvdata(dev);\n\n\thuawei->debug.root = debugfs_create_dir(\"huawei-wmi\", NULL);\n\n\tdebugfs_create_x64(\"arg\", 0644, huawei->debug.root,\n\t\t&huawei->debug.arg);\n\tdebugfs_create_file(\"call\", 0400,\n\t\thuawei->debug.root, huawei, &huawei_wmi_debugfs_call_fops);\n}\n\nstatic void huawei_wmi_debugfs_exit(struct device *dev)\n{\n\tstruct huawei_wmi *huawei = dev_get_drvdata(dev);\n\n\tdebugfs_remove_recursive(huawei->debug.root);\n}\n\n \n\nstatic void huawei_wmi_process_key(struct input_dev *idev, int code)\n{\n\tconst struct key_entry *key;\n\n\t \n\tif (code == 0x80) {\n\t\tstruct acpi_buffer response = { ACPI_ALLOCATE_BUFFER, NULL };\n\t\tunion acpi_object *obj;\n\t\tacpi_status status;\n\n\t\tstatus = wmi_query_block(WMI0_EXPENSIVE_GUID, 0, &response);\n\t\tif (ACPI_FAILURE(status))\n\t\t\treturn;\n\n\t\tobj = (union acpi_object *)response.pointer;\n\t\tif (obj && obj->type == ACPI_TYPE_INTEGER)\n\t\t\tcode = obj->integer.value;\n\n\t\tkfree(response.pointer);\n\t}\n\n\tkey = sparse_keymap_entry_from_scancode(idev, code);\n\tif (!key) {\n\t\tdev_info(&idev->dev, \"Unknown key pressed, code: 0x%04x\\n\", code);\n\t\treturn;\n\t}\n\n\tif (quirks && !quirks->report_brightness &&\n\t\t\t(key->sw.code == KEY_BRIGHTNESSDOWN ||\n\t\t\tkey->sw.code == KEY_BRIGHTNESSUP))\n\t\treturn;\n\n\tsparse_keymap_report_entry(idev, key, 1, true);\n}\n\nstatic void huawei_wmi_input_notify(u32 value, void *context)\n{\n\tstruct input_dev *idev = (struct input_dev *)context;\n\tstruct acpi_buffer response = { ACPI_ALLOCATE_BUFFER, NULL };\n\tunion acpi_object *obj;\n\tacpi_status status;\n\n\tstatus = wmi_get_event_data(value, &response);\n\tif (ACPI_FAILURE(status)) {\n\t\tdev_err(&idev->dev, \"Unable to get event data\\n\");\n\t\treturn;\n\t}\n\n\tobj = (union acpi_object *)response.pointer;\n\tif (obj && obj->type == ACPI_TYPE_INTEGER)\n\t\thuawei_wmi_process_key(idev, obj->integer.value);\n\telse\n\t\tdev_err(&idev->dev, \"Bad response type\\n\");\n\n\tkfree(response.pointer);\n}\n\nstatic int huawei_wmi_input_setup(struct device *dev, const char *guid)\n{\n\tstruct input_dev *idev;\n\tacpi_status status;\n\tint err;\n\n\tidev = devm_input_allocate_device(dev);\n\tif (!idev)\n\t\treturn -ENOMEM;\n\n\tidev->name = \"Huawei WMI hotkeys\";\n\tidev->phys = \"wmi/input0\";\n\tidev->id.bustype = BUS_HOST;\n\tidev->dev.parent = dev;\n\n\terr = sparse_keymap_setup(idev, huawei_wmi_keymap, NULL);\n\tif (err)\n\t\treturn err;\n\n\terr = input_register_device(idev);\n\tif (err)\n\t\treturn err;\n\n\tstatus = wmi_install_notify_handler(guid, huawei_wmi_input_notify, idev);\n\tif (ACPI_FAILURE(status))\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic void huawei_wmi_input_exit(struct device *dev, const char *guid)\n{\n\twmi_remove_notify_handler(guid);\n}\n\n \n\nstatic const struct wmi_device_id huawei_wmi_events_id_table[] = {\n\t{ .guid_string = WMI0_EVENT_GUID },\n\t{ .guid_string = HWMI_EVENT_GUID },\n\t{  }\n};\n\nstatic int huawei_wmi_probe(struct platform_device *pdev)\n{\n\tconst struct wmi_device_id *guid = huawei_wmi_events_id_table;\n\tint err;\n\n\tplatform_set_drvdata(pdev, huawei_wmi);\n\thuawei_wmi->dev = &pdev->dev;\n\n\twhile (*guid->guid_string) {\n\t\tif (wmi_has_guid(guid->guid_string)) {\n\t\t\terr = huawei_wmi_input_setup(&pdev->dev, guid->guid_string);\n\t\t\tif (err) {\n\t\t\t\tdev_err(&pdev->dev, \"Failed to setup input on %s\\n\", guid->guid_string);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\n\t\tguid++;\n\t}\n\n\tif (wmi_has_guid(HWMI_METHOD_GUID)) {\n\t\tmutex_init(&huawei_wmi->wmi_lock);\n\n\t\thuawei_wmi_leds_setup(&pdev->dev);\n\t\thuawei_wmi_fn_lock_setup(&pdev->dev);\n\t\thuawei_wmi_battery_setup(&pdev->dev);\n\t\thuawei_wmi_debugfs_setup(&pdev->dev);\n\t}\n\n\treturn 0;\n}\n\nstatic void huawei_wmi_remove(struct platform_device *pdev)\n{\n\tconst struct wmi_device_id *guid = huawei_wmi_events_id_table;\n\n\twhile (*guid->guid_string) {\n\t\tif (wmi_has_guid(guid->guid_string))\n\t\t\thuawei_wmi_input_exit(&pdev->dev, guid->guid_string);\n\n\t\tguid++;\n\t}\n\n\tif (wmi_has_guid(HWMI_METHOD_GUID)) {\n\t\thuawei_wmi_debugfs_exit(&pdev->dev);\n\t\thuawei_wmi_battery_exit(&pdev->dev);\n\t\thuawei_wmi_fn_lock_exit(&pdev->dev);\n\t}\n}\n\nstatic struct platform_driver huawei_wmi_driver = {\n\t.driver = {\n\t\t.name = \"huawei-wmi\",\n\t},\n\t.probe = huawei_wmi_probe,\n\t.remove_new = huawei_wmi_remove,\n};\n\nstatic __init int huawei_wmi_init(void)\n{\n\tstruct platform_device *pdev;\n\tint err;\n\n\thuawei_wmi = kzalloc(sizeof(struct huawei_wmi), GFP_KERNEL);\n\tif (!huawei_wmi)\n\t\treturn -ENOMEM;\n\n\tquirks = &quirk_unknown;\n\tdmi_check_system(huawei_quirks);\n\tif (battery_reset != -1)\n\t\tquirks->battery_reset = battery_reset;\n\tif (report_brightness != -1)\n\t\tquirks->report_brightness = report_brightness;\n\n\terr = platform_driver_register(&huawei_wmi_driver);\n\tif (err)\n\t\tgoto pdrv_err;\n\n\tpdev = platform_device_register_simple(\"huawei-wmi\", PLATFORM_DEVID_NONE, NULL, 0);\n\tif (IS_ERR(pdev)) {\n\t\terr = PTR_ERR(pdev);\n\t\tgoto pdev_err;\n\t}\n\n\treturn 0;\n\npdev_err:\n\tplatform_driver_unregister(&huawei_wmi_driver);\npdrv_err:\n\tkfree(huawei_wmi);\n\treturn err;\n}\n\nstatic __exit void huawei_wmi_exit(void)\n{\n\tstruct platform_device *pdev = to_platform_device(huawei_wmi->dev);\n\n\tplatform_device_unregister(pdev);\n\tplatform_driver_unregister(&huawei_wmi_driver);\n\n\tkfree(huawei_wmi);\n}\n\nmodule_init(huawei_wmi_init);\nmodule_exit(huawei_wmi_exit);\n\nMODULE_ALIAS(\"wmi:\"HWMI_METHOD_GUID);\nMODULE_DEVICE_TABLE(wmi, huawei_wmi_events_id_table);\nMODULE_AUTHOR(\"Ayman Bagabas <ayman.bagabas@gmail.com>\");\nMODULE_DESCRIPTION(\"Huawei WMI laptop extras driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}