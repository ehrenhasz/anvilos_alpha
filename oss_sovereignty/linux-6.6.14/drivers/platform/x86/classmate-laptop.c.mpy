{
  "module_name": "classmate-laptop.c",
  "hash_id": "839be4f898b7e2a0f7999b7233d8c3f520899053c3938f9cc87ddc3dfeab40ab",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/x86/classmate-laptop.c",
  "human_readable_source": "\n \n\n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/acpi.h>\n#include <linux/backlight.h>\n#include <linux/input.h>\n#include <linux/rfkill.h>\n\nMODULE_LICENSE(\"GPL\");\n\nstruct cmpc_accel {\n\tint sensitivity;\n\tint g_select;\n\tint inputdev_state;\n};\n\n#define CMPC_ACCEL_DEV_STATE_CLOSED\t0\n#define CMPC_ACCEL_DEV_STATE_OPEN\t1\n\n#define CMPC_ACCEL_SENSITIVITY_DEFAULT\t\t5\n#define CMPC_ACCEL_G_SELECT_DEFAULT\t\t0\n\n#define CMPC_ACCEL_HID\t\t\"ACCE0000\"\n#define CMPC_ACCEL_HID_V4\t\"ACCE0001\"\n#define CMPC_TABLET_HID\t\t\"TBLT0000\"\n#define CMPC_IPML_HID\t\"IPML200\"\n#define CMPC_KEYS_HID\t\t\"FNBT0000\"\n\n \n\ntypedef void (*input_device_init)(struct input_dev *dev);\n\nstatic int cmpc_add_acpi_notify_device(struct acpi_device *acpi, char *name,\n\t\t\t\t       input_device_init idev_init)\n{\n\tstruct input_dev *inputdev;\n\tint error;\n\n\tinputdev = input_allocate_device();\n\tif (!inputdev)\n\t\treturn -ENOMEM;\n\tinputdev->name = name;\n\tinputdev->dev.parent = &acpi->dev;\n\tidev_init(inputdev);\n\terror = input_register_device(inputdev);\n\tif (error) {\n\t\tinput_free_device(inputdev);\n\t\treturn error;\n\t}\n\tdev_set_drvdata(&acpi->dev, inputdev);\n\treturn 0;\n}\n\nstatic int cmpc_remove_acpi_notify_device(struct acpi_device *acpi)\n{\n\tstruct input_dev *inputdev = dev_get_drvdata(&acpi->dev);\n\tinput_unregister_device(inputdev);\n\treturn 0;\n}\n\n \nstatic acpi_status cmpc_start_accel_v4(acpi_handle handle)\n{\n\tunion acpi_object param[4];\n\tstruct acpi_object_list input;\n\tacpi_status status;\n\n\tparam[0].type = ACPI_TYPE_INTEGER;\n\tparam[0].integer.value = 0x3;\n\tparam[1].type = ACPI_TYPE_INTEGER;\n\tparam[1].integer.value = 0;\n\tparam[2].type = ACPI_TYPE_INTEGER;\n\tparam[2].integer.value = 0;\n\tparam[3].type = ACPI_TYPE_INTEGER;\n\tparam[3].integer.value = 0;\n\tinput.count = 4;\n\tinput.pointer = param;\n\tstatus = acpi_evaluate_object(handle, \"ACMD\", &input, NULL);\n\treturn status;\n}\n\nstatic acpi_status cmpc_stop_accel_v4(acpi_handle handle)\n{\n\tunion acpi_object param[4];\n\tstruct acpi_object_list input;\n\tacpi_status status;\n\n\tparam[0].type = ACPI_TYPE_INTEGER;\n\tparam[0].integer.value = 0x4;\n\tparam[1].type = ACPI_TYPE_INTEGER;\n\tparam[1].integer.value = 0;\n\tparam[2].type = ACPI_TYPE_INTEGER;\n\tparam[2].integer.value = 0;\n\tparam[3].type = ACPI_TYPE_INTEGER;\n\tparam[3].integer.value = 0;\n\tinput.count = 4;\n\tinput.pointer = param;\n\tstatus = acpi_evaluate_object(handle, \"ACMD\", &input, NULL);\n\treturn status;\n}\n\nstatic acpi_status cmpc_accel_set_sensitivity_v4(acpi_handle handle, int val)\n{\n\tunion acpi_object param[4];\n\tstruct acpi_object_list input;\n\n\tparam[0].type = ACPI_TYPE_INTEGER;\n\tparam[0].integer.value = 0x02;\n\tparam[1].type = ACPI_TYPE_INTEGER;\n\tparam[1].integer.value = val;\n\tparam[2].type = ACPI_TYPE_INTEGER;\n\tparam[2].integer.value = 0;\n\tparam[3].type = ACPI_TYPE_INTEGER;\n\tparam[3].integer.value = 0;\n\tinput.count = 4;\n\tinput.pointer = param;\n\treturn acpi_evaluate_object(handle, \"ACMD\", &input, NULL);\n}\n\nstatic acpi_status cmpc_accel_set_g_select_v4(acpi_handle handle, int val)\n{\n\tunion acpi_object param[4];\n\tstruct acpi_object_list input;\n\n\tparam[0].type = ACPI_TYPE_INTEGER;\n\tparam[0].integer.value = 0x05;\n\tparam[1].type = ACPI_TYPE_INTEGER;\n\tparam[1].integer.value = val;\n\tparam[2].type = ACPI_TYPE_INTEGER;\n\tparam[2].integer.value = 0;\n\tparam[3].type = ACPI_TYPE_INTEGER;\n\tparam[3].integer.value = 0;\n\tinput.count = 4;\n\tinput.pointer = param;\n\treturn acpi_evaluate_object(handle, \"ACMD\", &input, NULL);\n}\n\nstatic acpi_status cmpc_get_accel_v4(acpi_handle handle,\n\t\t\t\t     int16_t *x,\n\t\t\t\t     int16_t *y,\n\t\t\t\t     int16_t *z)\n{\n\tunion acpi_object param[4];\n\tstruct acpi_object_list input;\n\tstruct acpi_buffer output = { ACPI_ALLOCATE_BUFFER, NULL };\n\tint16_t *locs;\n\tacpi_status status;\n\n\tparam[0].type = ACPI_TYPE_INTEGER;\n\tparam[0].integer.value = 0x01;\n\tparam[1].type = ACPI_TYPE_INTEGER;\n\tparam[1].integer.value = 0;\n\tparam[2].type = ACPI_TYPE_INTEGER;\n\tparam[2].integer.value = 0;\n\tparam[3].type = ACPI_TYPE_INTEGER;\n\tparam[3].integer.value = 0;\n\tinput.count = 4;\n\tinput.pointer = param;\n\tstatus = acpi_evaluate_object(handle, \"ACMD\", &input, &output);\n\tif (ACPI_SUCCESS(status)) {\n\t\tunion acpi_object *obj;\n\t\tobj = output.pointer;\n\t\tlocs = (int16_t *) obj->buffer.pointer;\n\t\t*x = locs[0];\n\t\t*y = locs[1];\n\t\t*z = locs[2];\n\t\tkfree(output.pointer);\n\t}\n\treturn status;\n}\n\nstatic void cmpc_accel_handler_v4(struct acpi_device *dev, u32 event)\n{\n\tif (event == 0x81) {\n\t\tint16_t x, y, z;\n\t\tacpi_status status;\n\n\t\tstatus = cmpc_get_accel_v4(dev->handle, &x, &y, &z);\n\t\tif (ACPI_SUCCESS(status)) {\n\t\t\tstruct input_dev *inputdev = dev_get_drvdata(&dev->dev);\n\n\t\t\tinput_report_abs(inputdev, ABS_X, x);\n\t\t\tinput_report_abs(inputdev, ABS_Y, y);\n\t\t\tinput_report_abs(inputdev, ABS_Z, z);\n\t\t\tinput_sync(inputdev);\n\t\t}\n\t}\n}\n\nstatic ssize_t cmpc_accel_sensitivity_show_v4(struct device *dev,\n\t\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t\t      char *buf)\n{\n\tstruct acpi_device *acpi;\n\tstruct input_dev *inputdev;\n\tstruct cmpc_accel *accel;\n\n\tacpi = to_acpi_device(dev);\n\tinputdev = dev_get_drvdata(&acpi->dev);\n\taccel = dev_get_drvdata(&inputdev->dev);\n\n\treturn sprintf(buf, \"%d\\n\", accel->sensitivity);\n}\n\nstatic ssize_t cmpc_accel_sensitivity_store_v4(struct device *dev,\n\t\t\t\t\t       struct device_attribute *attr,\n\t\t\t\t\t       const char *buf, size_t count)\n{\n\tstruct acpi_device *acpi;\n\tstruct input_dev *inputdev;\n\tstruct cmpc_accel *accel;\n\tunsigned long sensitivity;\n\tint r;\n\n\tacpi = to_acpi_device(dev);\n\tinputdev = dev_get_drvdata(&acpi->dev);\n\taccel = dev_get_drvdata(&inputdev->dev);\n\n\tr = kstrtoul(buf, 0, &sensitivity);\n\tif (r)\n\t\treturn r;\n\n\t \n\tif (sensitivity < 1 || sensitivity > 127)\n\t\treturn -EINVAL;\n\n\taccel->sensitivity = sensitivity;\n\tcmpc_accel_set_sensitivity_v4(acpi->handle, sensitivity);\n\n\treturn strnlen(buf, count);\n}\n\nstatic struct device_attribute cmpc_accel_sensitivity_attr_v4 = {\n\t.attr = { .name = \"sensitivity\", .mode = 0660 },\n\t.show = cmpc_accel_sensitivity_show_v4,\n\t.store = cmpc_accel_sensitivity_store_v4\n};\n\nstatic ssize_t cmpc_accel_g_select_show_v4(struct device *dev,\n\t\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t\t   char *buf)\n{\n\tstruct acpi_device *acpi;\n\tstruct input_dev *inputdev;\n\tstruct cmpc_accel *accel;\n\n\tacpi = to_acpi_device(dev);\n\tinputdev = dev_get_drvdata(&acpi->dev);\n\taccel = dev_get_drvdata(&inputdev->dev);\n\n\treturn sprintf(buf, \"%d\\n\", accel->g_select);\n}\n\nstatic ssize_t cmpc_accel_g_select_store_v4(struct device *dev,\n\t\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t\t    const char *buf, size_t count)\n{\n\tstruct acpi_device *acpi;\n\tstruct input_dev *inputdev;\n\tstruct cmpc_accel *accel;\n\tunsigned long g_select;\n\tint r;\n\n\tacpi = to_acpi_device(dev);\n\tinputdev = dev_get_drvdata(&acpi->dev);\n\taccel = dev_get_drvdata(&inputdev->dev);\n\n\tr = kstrtoul(buf, 0, &g_select);\n\tif (r)\n\t\treturn r;\n\n\t \n\tif (g_select != 0 && g_select != 1)\n\t\treturn -EINVAL;\n\n\taccel->g_select = g_select;\n\tcmpc_accel_set_g_select_v4(acpi->handle, g_select);\n\n\treturn strnlen(buf, count);\n}\n\nstatic struct device_attribute cmpc_accel_g_select_attr_v4 = {\n\t.attr = { .name = \"g_select\", .mode = 0660 },\n\t.show = cmpc_accel_g_select_show_v4,\n\t.store = cmpc_accel_g_select_store_v4\n};\n\nstatic int cmpc_accel_open_v4(struct input_dev *input)\n{\n\tstruct acpi_device *acpi;\n\tstruct cmpc_accel *accel;\n\n\tacpi = to_acpi_device(input->dev.parent);\n\taccel = dev_get_drvdata(&input->dev);\n\n\tcmpc_accel_set_sensitivity_v4(acpi->handle, accel->sensitivity);\n\tcmpc_accel_set_g_select_v4(acpi->handle, accel->g_select);\n\n\tif (ACPI_SUCCESS(cmpc_start_accel_v4(acpi->handle))) {\n\t\taccel->inputdev_state = CMPC_ACCEL_DEV_STATE_OPEN;\n\t\treturn 0;\n\t}\n\treturn -EIO;\n}\n\nstatic void cmpc_accel_close_v4(struct input_dev *input)\n{\n\tstruct acpi_device *acpi;\n\tstruct cmpc_accel *accel;\n\n\tacpi = to_acpi_device(input->dev.parent);\n\taccel = dev_get_drvdata(&input->dev);\n\n\tcmpc_stop_accel_v4(acpi->handle);\n\taccel->inputdev_state = CMPC_ACCEL_DEV_STATE_CLOSED;\n}\n\nstatic void cmpc_accel_idev_init_v4(struct input_dev *inputdev)\n{\n\tset_bit(EV_ABS, inputdev->evbit);\n\tinput_set_abs_params(inputdev, ABS_X, -255, 255, 16, 0);\n\tinput_set_abs_params(inputdev, ABS_Y, -255, 255, 16, 0);\n\tinput_set_abs_params(inputdev, ABS_Z, -255, 255, 16, 0);\n\tinputdev->open = cmpc_accel_open_v4;\n\tinputdev->close = cmpc_accel_close_v4;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int cmpc_accel_suspend_v4(struct device *dev)\n{\n\tstruct input_dev *inputdev;\n\tstruct cmpc_accel *accel;\n\n\tinputdev = dev_get_drvdata(dev);\n\taccel = dev_get_drvdata(&inputdev->dev);\n\n\tif (accel->inputdev_state == CMPC_ACCEL_DEV_STATE_OPEN)\n\t\treturn cmpc_stop_accel_v4(to_acpi_device(dev)->handle);\n\n\treturn 0;\n}\n\nstatic int cmpc_accel_resume_v4(struct device *dev)\n{\n\tstruct input_dev *inputdev;\n\tstruct cmpc_accel *accel;\n\n\tinputdev = dev_get_drvdata(dev);\n\taccel = dev_get_drvdata(&inputdev->dev);\n\n\tif (accel->inputdev_state == CMPC_ACCEL_DEV_STATE_OPEN) {\n\t\tcmpc_accel_set_sensitivity_v4(to_acpi_device(dev)->handle,\n\t\t\t\t\t      accel->sensitivity);\n\t\tcmpc_accel_set_g_select_v4(to_acpi_device(dev)->handle,\n\t\t\t\t\t   accel->g_select);\n\n\t\tif (ACPI_FAILURE(cmpc_start_accel_v4(to_acpi_device(dev)->handle)))\n\t\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n#endif\n\nstatic int cmpc_accel_add_v4(struct acpi_device *acpi)\n{\n\tint error;\n\tstruct input_dev *inputdev;\n\tstruct cmpc_accel *accel;\n\n\taccel = kmalloc(sizeof(*accel), GFP_KERNEL);\n\tif (!accel)\n\t\treturn -ENOMEM;\n\n\taccel->inputdev_state = CMPC_ACCEL_DEV_STATE_CLOSED;\n\n\taccel->sensitivity = CMPC_ACCEL_SENSITIVITY_DEFAULT;\n\tcmpc_accel_set_sensitivity_v4(acpi->handle, accel->sensitivity);\n\n\terror = device_create_file(&acpi->dev, &cmpc_accel_sensitivity_attr_v4);\n\tif (error)\n\t\tgoto failed_sensitivity;\n\n\taccel->g_select = CMPC_ACCEL_G_SELECT_DEFAULT;\n\tcmpc_accel_set_g_select_v4(acpi->handle, accel->g_select);\n\n\terror = device_create_file(&acpi->dev, &cmpc_accel_g_select_attr_v4);\n\tif (error)\n\t\tgoto failed_g_select;\n\n\terror = cmpc_add_acpi_notify_device(acpi, \"cmpc_accel_v4\",\n\t\t\t\t\t    cmpc_accel_idev_init_v4);\n\tif (error)\n\t\tgoto failed_input;\n\n\tinputdev = dev_get_drvdata(&acpi->dev);\n\tdev_set_drvdata(&inputdev->dev, accel);\n\n\treturn 0;\n\nfailed_input:\n\tdevice_remove_file(&acpi->dev, &cmpc_accel_g_select_attr_v4);\nfailed_g_select:\n\tdevice_remove_file(&acpi->dev, &cmpc_accel_sensitivity_attr_v4);\nfailed_sensitivity:\n\tkfree(accel);\n\treturn error;\n}\n\nstatic void cmpc_accel_remove_v4(struct acpi_device *acpi)\n{\n\tdevice_remove_file(&acpi->dev, &cmpc_accel_sensitivity_attr_v4);\n\tdevice_remove_file(&acpi->dev, &cmpc_accel_g_select_attr_v4);\n\tcmpc_remove_acpi_notify_device(acpi);\n}\n\nstatic SIMPLE_DEV_PM_OPS(cmpc_accel_pm, cmpc_accel_suspend_v4,\n\t\t\t cmpc_accel_resume_v4);\n\nstatic const struct acpi_device_id cmpc_accel_device_ids_v4[] = {\n\t{CMPC_ACCEL_HID_V4, 0},\n\t{\"\", 0}\n};\n\nstatic struct acpi_driver cmpc_accel_acpi_driver_v4 = {\n\t.owner = THIS_MODULE,\n\t.name = \"cmpc_accel_v4\",\n\t.class = \"cmpc_accel_v4\",\n\t.ids = cmpc_accel_device_ids_v4,\n\t.ops = {\n\t\t.add = cmpc_accel_add_v4,\n\t\t.remove = cmpc_accel_remove_v4,\n\t\t.notify = cmpc_accel_handler_v4,\n\t},\n\t.drv.pm = &cmpc_accel_pm,\n};\n\n\n \nstatic acpi_status cmpc_start_accel(acpi_handle handle)\n{\n\tunion acpi_object param[2];\n\tstruct acpi_object_list input;\n\tacpi_status status;\n\n\tparam[0].type = ACPI_TYPE_INTEGER;\n\tparam[0].integer.value = 0x3;\n\tparam[1].type = ACPI_TYPE_INTEGER;\n\tinput.count = 2;\n\tinput.pointer = param;\n\tstatus = acpi_evaluate_object(handle, \"ACMD\", &input, NULL);\n\treturn status;\n}\n\nstatic acpi_status cmpc_stop_accel(acpi_handle handle)\n{\n\tunion acpi_object param[2];\n\tstruct acpi_object_list input;\n\tacpi_status status;\n\n\tparam[0].type = ACPI_TYPE_INTEGER;\n\tparam[0].integer.value = 0x4;\n\tparam[1].type = ACPI_TYPE_INTEGER;\n\tinput.count = 2;\n\tinput.pointer = param;\n\tstatus = acpi_evaluate_object(handle, \"ACMD\", &input, NULL);\n\treturn status;\n}\n\nstatic acpi_status cmpc_accel_set_sensitivity(acpi_handle handle, int val)\n{\n\tunion acpi_object param[2];\n\tstruct acpi_object_list input;\n\n\tparam[0].type = ACPI_TYPE_INTEGER;\n\tparam[0].integer.value = 0x02;\n\tparam[1].type = ACPI_TYPE_INTEGER;\n\tparam[1].integer.value = val;\n\tinput.count = 2;\n\tinput.pointer = param;\n\treturn acpi_evaluate_object(handle, \"ACMD\", &input, NULL);\n}\n\nstatic acpi_status cmpc_get_accel(acpi_handle handle,\n\t\t\t\t  unsigned char *x,\n\t\t\t\t  unsigned char *y,\n\t\t\t\t  unsigned char *z)\n{\n\tunion acpi_object param[2];\n\tstruct acpi_object_list input;\n\tstruct acpi_buffer output = { ACPI_ALLOCATE_BUFFER, NULL };\n\tunsigned char *locs;\n\tacpi_status status;\n\n\tparam[0].type = ACPI_TYPE_INTEGER;\n\tparam[0].integer.value = 0x01;\n\tparam[1].type = ACPI_TYPE_INTEGER;\n\tinput.count = 2;\n\tinput.pointer = param;\n\tstatus = acpi_evaluate_object(handle, \"ACMD\", &input, &output);\n\tif (ACPI_SUCCESS(status)) {\n\t\tunion acpi_object *obj;\n\t\tobj = output.pointer;\n\t\tlocs = obj->buffer.pointer;\n\t\t*x = locs[0];\n\t\t*y = locs[1];\n\t\t*z = locs[2];\n\t\tkfree(output.pointer);\n\t}\n\treturn status;\n}\n\nstatic void cmpc_accel_handler(struct acpi_device *dev, u32 event)\n{\n\tif (event == 0x81) {\n\t\tunsigned char x, y, z;\n\t\tacpi_status status;\n\n\t\tstatus = cmpc_get_accel(dev->handle, &x, &y, &z);\n\t\tif (ACPI_SUCCESS(status)) {\n\t\t\tstruct input_dev *inputdev = dev_get_drvdata(&dev->dev);\n\n\t\t\tinput_report_abs(inputdev, ABS_X, x);\n\t\t\tinput_report_abs(inputdev, ABS_Y, y);\n\t\t\tinput_report_abs(inputdev, ABS_Z, z);\n\t\t\tinput_sync(inputdev);\n\t\t}\n\t}\n}\n\nstatic ssize_t cmpc_accel_sensitivity_show(struct device *dev,\n\t\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t\t   char *buf)\n{\n\tstruct acpi_device *acpi;\n\tstruct input_dev *inputdev;\n\tstruct cmpc_accel *accel;\n\n\tacpi = to_acpi_device(dev);\n\tinputdev = dev_get_drvdata(&acpi->dev);\n\taccel = dev_get_drvdata(&inputdev->dev);\n\n\treturn sprintf(buf, \"%d\\n\", accel->sensitivity);\n}\n\nstatic ssize_t cmpc_accel_sensitivity_store(struct device *dev,\n\t\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t\t    const char *buf, size_t count)\n{\n\tstruct acpi_device *acpi;\n\tstruct input_dev *inputdev;\n\tstruct cmpc_accel *accel;\n\tunsigned long sensitivity;\n\tint r;\n\n\tacpi = to_acpi_device(dev);\n\tinputdev = dev_get_drvdata(&acpi->dev);\n\taccel = dev_get_drvdata(&inputdev->dev);\n\n\tr = kstrtoul(buf, 0, &sensitivity);\n\tif (r)\n\t\treturn r;\n\n\taccel->sensitivity = sensitivity;\n\tcmpc_accel_set_sensitivity(acpi->handle, sensitivity);\n\n\treturn strnlen(buf, count);\n}\n\nstatic struct device_attribute cmpc_accel_sensitivity_attr = {\n\t.attr = { .name = \"sensitivity\", .mode = 0660 },\n\t.show = cmpc_accel_sensitivity_show,\n\t.store = cmpc_accel_sensitivity_store\n};\n\nstatic int cmpc_accel_open(struct input_dev *input)\n{\n\tstruct acpi_device *acpi;\n\n\tacpi = to_acpi_device(input->dev.parent);\n\tif (ACPI_SUCCESS(cmpc_start_accel(acpi->handle)))\n\t\treturn 0;\n\treturn -EIO;\n}\n\nstatic void cmpc_accel_close(struct input_dev *input)\n{\n\tstruct acpi_device *acpi;\n\n\tacpi = to_acpi_device(input->dev.parent);\n\tcmpc_stop_accel(acpi->handle);\n}\n\nstatic void cmpc_accel_idev_init(struct input_dev *inputdev)\n{\n\tset_bit(EV_ABS, inputdev->evbit);\n\tinput_set_abs_params(inputdev, ABS_X, 0, 255, 8, 0);\n\tinput_set_abs_params(inputdev, ABS_Y, 0, 255, 8, 0);\n\tinput_set_abs_params(inputdev, ABS_Z, 0, 255, 8, 0);\n\tinputdev->open = cmpc_accel_open;\n\tinputdev->close = cmpc_accel_close;\n}\n\nstatic int cmpc_accel_add(struct acpi_device *acpi)\n{\n\tint error;\n\tstruct input_dev *inputdev;\n\tstruct cmpc_accel *accel;\n\n\taccel = kmalloc(sizeof(*accel), GFP_KERNEL);\n\tif (!accel)\n\t\treturn -ENOMEM;\n\n\taccel->sensitivity = CMPC_ACCEL_SENSITIVITY_DEFAULT;\n\tcmpc_accel_set_sensitivity(acpi->handle, accel->sensitivity);\n\n\terror = device_create_file(&acpi->dev, &cmpc_accel_sensitivity_attr);\n\tif (error)\n\t\tgoto failed_file;\n\n\terror = cmpc_add_acpi_notify_device(acpi, \"cmpc_accel\",\n\t\t\t\t\t    cmpc_accel_idev_init);\n\tif (error)\n\t\tgoto failed_input;\n\n\tinputdev = dev_get_drvdata(&acpi->dev);\n\tdev_set_drvdata(&inputdev->dev, accel);\n\n\treturn 0;\n\nfailed_input:\n\tdevice_remove_file(&acpi->dev, &cmpc_accel_sensitivity_attr);\nfailed_file:\n\tkfree(accel);\n\treturn error;\n}\n\nstatic void cmpc_accel_remove(struct acpi_device *acpi)\n{\n\tdevice_remove_file(&acpi->dev, &cmpc_accel_sensitivity_attr);\n\tcmpc_remove_acpi_notify_device(acpi);\n}\n\nstatic const struct acpi_device_id cmpc_accel_device_ids[] = {\n\t{CMPC_ACCEL_HID, 0},\n\t{\"\", 0}\n};\n\nstatic struct acpi_driver cmpc_accel_acpi_driver = {\n\t.owner = THIS_MODULE,\n\t.name = \"cmpc_accel\",\n\t.class = \"cmpc_accel\",\n\t.ids = cmpc_accel_device_ids,\n\t.ops = {\n\t\t.add = cmpc_accel_add,\n\t\t.remove = cmpc_accel_remove,\n\t\t.notify = cmpc_accel_handler,\n\t}\n};\n\n\n \nstatic acpi_status cmpc_get_tablet(acpi_handle handle,\n\t\t\t\t   unsigned long long *value)\n{\n\tunion acpi_object param;\n\tstruct acpi_object_list input;\n\tunsigned long long output;\n\tacpi_status status;\n\n\tparam.type = ACPI_TYPE_INTEGER;\n\tparam.integer.value = 0x01;\n\tinput.count = 1;\n\tinput.pointer = &param;\n\tstatus = acpi_evaluate_integer(handle, \"TCMD\", &input, &output);\n\tif (ACPI_SUCCESS(status))\n\t\t*value = output;\n\treturn status;\n}\n\nstatic void cmpc_tablet_handler(struct acpi_device *dev, u32 event)\n{\n\tunsigned long long val = 0;\n\tstruct input_dev *inputdev = dev_get_drvdata(&dev->dev);\n\n\tif (event == 0x81) {\n\t\tif (ACPI_SUCCESS(cmpc_get_tablet(dev->handle, &val))) {\n\t\t\tinput_report_switch(inputdev, SW_TABLET_MODE, !val);\n\t\t\tinput_sync(inputdev);\n\t\t}\n\t}\n}\n\nstatic void cmpc_tablet_idev_init(struct input_dev *inputdev)\n{\n\tunsigned long long val = 0;\n\tstruct acpi_device *acpi;\n\n\tset_bit(EV_SW, inputdev->evbit);\n\tset_bit(SW_TABLET_MODE, inputdev->swbit);\n\n\tacpi = to_acpi_device(inputdev->dev.parent);\n\tif (ACPI_SUCCESS(cmpc_get_tablet(acpi->handle, &val))) {\n\t\tinput_report_switch(inputdev, SW_TABLET_MODE, !val);\n\t\tinput_sync(inputdev);\n\t}\n}\n\nstatic int cmpc_tablet_add(struct acpi_device *acpi)\n{\n\treturn cmpc_add_acpi_notify_device(acpi, \"cmpc_tablet\",\n\t\t\t\t\t   cmpc_tablet_idev_init);\n}\n\nstatic void cmpc_tablet_remove(struct acpi_device *acpi)\n{\n\tcmpc_remove_acpi_notify_device(acpi);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int cmpc_tablet_resume(struct device *dev)\n{\n\tstruct input_dev *inputdev = dev_get_drvdata(dev);\n\n\tunsigned long long val = 0;\n\tif (ACPI_SUCCESS(cmpc_get_tablet(to_acpi_device(dev)->handle, &val))) {\n\t\tinput_report_switch(inputdev, SW_TABLET_MODE, !val);\n\t\tinput_sync(inputdev);\n\t}\n\treturn 0;\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(cmpc_tablet_pm, NULL, cmpc_tablet_resume);\n\nstatic const struct acpi_device_id cmpc_tablet_device_ids[] = {\n\t{CMPC_TABLET_HID, 0},\n\t{\"\", 0}\n};\n\nstatic struct acpi_driver cmpc_tablet_acpi_driver = {\n\t.owner = THIS_MODULE,\n\t.name = \"cmpc_tablet\",\n\t.class = \"cmpc_tablet\",\n\t.ids = cmpc_tablet_device_ids,\n\t.ops = {\n\t\t.add = cmpc_tablet_add,\n\t\t.remove = cmpc_tablet_remove,\n\t\t.notify = cmpc_tablet_handler,\n\t},\n\t.drv.pm = &cmpc_tablet_pm,\n};\n\n\n \n\nstatic acpi_status cmpc_get_brightness(acpi_handle handle,\n\t\t\t\t       unsigned long long *value)\n{\n\tunion acpi_object param;\n\tstruct acpi_object_list input;\n\tunsigned long long output;\n\tacpi_status status;\n\n\tparam.type = ACPI_TYPE_INTEGER;\n\tparam.integer.value = 0xC0;\n\tinput.count = 1;\n\tinput.pointer = &param;\n\tstatus = acpi_evaluate_integer(handle, \"GRDI\", &input, &output);\n\tif (ACPI_SUCCESS(status))\n\t\t*value = output;\n\treturn status;\n}\n\nstatic acpi_status cmpc_set_brightness(acpi_handle handle,\n\t\t\t\t       unsigned long long value)\n{\n\tunion acpi_object param[2];\n\tstruct acpi_object_list input;\n\tacpi_status status;\n\tunsigned long long output;\n\n\tparam[0].type = ACPI_TYPE_INTEGER;\n\tparam[0].integer.value = 0xC0;\n\tparam[1].type = ACPI_TYPE_INTEGER;\n\tparam[1].integer.value = value;\n\tinput.count = 2;\n\tinput.pointer = param;\n\tstatus = acpi_evaluate_integer(handle, \"GWRI\", &input, &output);\n\treturn status;\n}\n\nstatic int cmpc_bl_get_brightness(struct backlight_device *bd)\n{\n\tacpi_status status;\n\tacpi_handle handle;\n\tunsigned long long brightness;\n\n\thandle = bl_get_data(bd);\n\tstatus = cmpc_get_brightness(handle, &brightness);\n\tif (ACPI_SUCCESS(status))\n\t\treturn brightness;\n\telse\n\t\treturn -1;\n}\n\nstatic int cmpc_bl_update_status(struct backlight_device *bd)\n{\n\tacpi_status status;\n\tacpi_handle handle;\n\n\thandle = bl_get_data(bd);\n\tstatus = cmpc_set_brightness(handle, bd->props.brightness);\n\tif (ACPI_SUCCESS(status))\n\t\treturn 0;\n\telse\n\t\treturn -1;\n}\n\nstatic const struct backlight_ops cmpc_bl_ops = {\n\t.get_brightness = cmpc_bl_get_brightness,\n\t.update_status = cmpc_bl_update_status\n};\n\n \n\nstatic acpi_status cmpc_get_rfkill_wlan(acpi_handle handle,\n\t\t\t\t\tunsigned long long *value)\n{\n\tunion acpi_object param;\n\tstruct acpi_object_list input;\n\tunsigned long long output;\n\tacpi_status status;\n\n\tparam.type = ACPI_TYPE_INTEGER;\n\tparam.integer.value = 0xC1;\n\tinput.count = 1;\n\tinput.pointer = &param;\n\tstatus = acpi_evaluate_integer(handle, \"GRDI\", &input, &output);\n\tif (ACPI_SUCCESS(status))\n\t\t*value = output;\n\treturn status;\n}\n\nstatic acpi_status cmpc_set_rfkill_wlan(acpi_handle handle,\n\t\t\t\t\tunsigned long long value)\n{\n\tunion acpi_object param[2];\n\tstruct acpi_object_list input;\n\tacpi_status status;\n\tunsigned long long output;\n\n\tparam[0].type = ACPI_TYPE_INTEGER;\n\tparam[0].integer.value = 0xC1;\n\tparam[1].type = ACPI_TYPE_INTEGER;\n\tparam[1].integer.value = value;\n\tinput.count = 2;\n\tinput.pointer = param;\n\tstatus = acpi_evaluate_integer(handle, \"GWRI\", &input, &output);\n\treturn status;\n}\n\nstatic void cmpc_rfkill_query(struct rfkill *rfkill, void *data)\n{\n\tacpi_status status;\n\tacpi_handle handle;\n\tunsigned long long state;\n\tbool blocked;\n\n\thandle = data;\n\tstatus = cmpc_get_rfkill_wlan(handle, &state);\n\tif (ACPI_SUCCESS(status)) {\n\t\tblocked = state & 1 ? false : true;\n\t\trfkill_set_sw_state(rfkill, blocked);\n\t}\n}\n\nstatic int cmpc_rfkill_block(void *data, bool blocked)\n{\n\tacpi_status status;\n\tacpi_handle handle;\n\tunsigned long long state;\n\tbool is_blocked;\n\n\thandle = data;\n\tstatus = cmpc_get_rfkill_wlan(handle, &state);\n\tif (ACPI_FAILURE(status))\n\t\treturn -ENODEV;\n\t \n\tis_blocked = state & 1 ? false : true;\n\tif (is_blocked != blocked) {\n\t\tstate = blocked ? 0 : 1;\n\t\tstatus = cmpc_set_rfkill_wlan(handle, state);\n\t\tif (ACPI_FAILURE(status))\n\t\t\treturn -ENODEV;\n\t}\n\treturn 0;\n}\n\nstatic const struct rfkill_ops cmpc_rfkill_ops = {\n\t.query = cmpc_rfkill_query,\n\t.set_block = cmpc_rfkill_block,\n};\n\n \n\nstruct ipml200_dev {\n\tstruct backlight_device *bd;\n\tstruct rfkill *rf;\n};\n\nstatic int cmpc_ipml_add(struct acpi_device *acpi)\n{\n\tint retval;\n\tstruct ipml200_dev *ipml;\n\tstruct backlight_properties props;\n\n\tipml = kmalloc(sizeof(*ipml), GFP_KERNEL);\n\tif (ipml == NULL)\n\t\treturn -ENOMEM;\n\n\tmemset(&props, 0, sizeof(struct backlight_properties));\n\tprops.type = BACKLIGHT_PLATFORM;\n\tprops.max_brightness = 7;\n\tipml->bd = backlight_device_register(\"cmpc_bl\", &acpi->dev,\n\t\t\t\t\t     acpi->handle, &cmpc_bl_ops,\n\t\t\t\t\t     &props);\n\tif (IS_ERR(ipml->bd)) {\n\t\tretval = PTR_ERR(ipml->bd);\n\t\tgoto out_bd;\n\t}\n\n\tipml->rf = rfkill_alloc(\"cmpc_rfkill\", &acpi->dev, RFKILL_TYPE_WLAN,\n\t\t\t\t&cmpc_rfkill_ops, acpi->handle);\n\t \n\tif (ipml->rf) {\n\t\tretval = rfkill_register(ipml->rf);\n\t\tif (retval) {\n\t\t\trfkill_destroy(ipml->rf);\n\t\t\tipml->rf = NULL;\n\t\t}\n\t}\n\n\tdev_set_drvdata(&acpi->dev, ipml);\n\treturn 0;\n\nout_bd:\n\tkfree(ipml);\n\treturn retval;\n}\n\nstatic void cmpc_ipml_remove(struct acpi_device *acpi)\n{\n\tstruct ipml200_dev *ipml;\n\n\tipml = dev_get_drvdata(&acpi->dev);\n\n\tbacklight_device_unregister(ipml->bd);\n\n\tif (ipml->rf) {\n\t\trfkill_unregister(ipml->rf);\n\t\trfkill_destroy(ipml->rf);\n\t}\n\n\tkfree(ipml);\n}\n\nstatic const struct acpi_device_id cmpc_ipml_device_ids[] = {\n\t{CMPC_IPML_HID, 0},\n\t{\"\", 0}\n};\n\nstatic struct acpi_driver cmpc_ipml_acpi_driver = {\n\t.owner = THIS_MODULE,\n\t.name = \"cmpc\",\n\t.class = \"cmpc\",\n\t.ids = cmpc_ipml_device_ids,\n\t.ops = {\n\t\t.add = cmpc_ipml_add,\n\t\t.remove = cmpc_ipml_remove\n\t}\n};\n\n\n \nstatic int cmpc_keys_codes[] = {\n\tKEY_UNKNOWN,\n\tKEY_WLAN,\n\tKEY_SWITCHVIDEOMODE,\n\tKEY_BRIGHTNESSDOWN,\n\tKEY_BRIGHTNESSUP,\n\tKEY_VENDOR,\n\tKEY_UNKNOWN,\n\tKEY_CAMERA,\n\tKEY_BACK,\n\tKEY_FORWARD,\n\tKEY_UNKNOWN,\n\tKEY_WLAN,  \n\tKEY_MAX\n};\n\nstatic void cmpc_keys_handler(struct acpi_device *dev, u32 event)\n{\n\tstruct input_dev *inputdev;\n\tint code = KEY_MAX;\n\n\tif ((event & 0x0F) < ARRAY_SIZE(cmpc_keys_codes))\n\t\tcode = cmpc_keys_codes[event & 0x0F];\n\tinputdev = dev_get_drvdata(&dev->dev);\n\tinput_report_key(inputdev, code, !(event & 0x10));\n\tinput_sync(inputdev);\n}\n\nstatic void cmpc_keys_idev_init(struct input_dev *inputdev)\n{\n\tint i;\n\n\tset_bit(EV_KEY, inputdev->evbit);\n\tfor (i = 0; cmpc_keys_codes[i] != KEY_MAX; i++)\n\t\tset_bit(cmpc_keys_codes[i], inputdev->keybit);\n}\n\nstatic int cmpc_keys_add(struct acpi_device *acpi)\n{\n\treturn cmpc_add_acpi_notify_device(acpi, \"cmpc_keys\",\n\t\t\t\t\t   cmpc_keys_idev_init);\n}\n\nstatic void cmpc_keys_remove(struct acpi_device *acpi)\n{\n\tcmpc_remove_acpi_notify_device(acpi);\n}\n\nstatic const struct acpi_device_id cmpc_keys_device_ids[] = {\n\t{CMPC_KEYS_HID, 0},\n\t{\"\", 0}\n};\n\nstatic struct acpi_driver cmpc_keys_acpi_driver = {\n\t.owner = THIS_MODULE,\n\t.name = \"cmpc_keys\",\n\t.class = \"cmpc_keys\",\n\t.ids = cmpc_keys_device_ids,\n\t.ops = {\n\t\t.add = cmpc_keys_add,\n\t\t.remove = cmpc_keys_remove,\n\t\t.notify = cmpc_keys_handler,\n\t}\n};\n\n\n \n\nstatic int cmpc_init(void)\n{\n\tint r;\n\n\tr = acpi_bus_register_driver(&cmpc_keys_acpi_driver);\n\tif (r)\n\t\tgoto failed_keys;\n\n\tr = acpi_bus_register_driver(&cmpc_ipml_acpi_driver);\n\tif (r)\n\t\tgoto failed_bl;\n\n\tr = acpi_bus_register_driver(&cmpc_tablet_acpi_driver);\n\tif (r)\n\t\tgoto failed_tablet;\n\n\tr = acpi_bus_register_driver(&cmpc_accel_acpi_driver);\n\tif (r)\n\t\tgoto failed_accel;\n\n\tr = acpi_bus_register_driver(&cmpc_accel_acpi_driver_v4);\n\tif (r)\n\t\tgoto failed_accel_v4;\n\n\treturn r;\n\nfailed_accel_v4:\n\tacpi_bus_unregister_driver(&cmpc_accel_acpi_driver);\n\nfailed_accel:\n\tacpi_bus_unregister_driver(&cmpc_tablet_acpi_driver);\n\nfailed_tablet:\n\tacpi_bus_unregister_driver(&cmpc_ipml_acpi_driver);\n\nfailed_bl:\n\tacpi_bus_unregister_driver(&cmpc_keys_acpi_driver);\n\nfailed_keys:\n\treturn r;\n}\n\nstatic void cmpc_exit(void)\n{\n\tacpi_bus_unregister_driver(&cmpc_accel_acpi_driver_v4);\n\tacpi_bus_unregister_driver(&cmpc_accel_acpi_driver);\n\tacpi_bus_unregister_driver(&cmpc_tablet_acpi_driver);\n\tacpi_bus_unregister_driver(&cmpc_ipml_acpi_driver);\n\tacpi_bus_unregister_driver(&cmpc_keys_acpi_driver);\n}\n\nmodule_init(cmpc_init);\nmodule_exit(cmpc_exit);\n\nstatic const struct acpi_device_id cmpc_device_ids[] __maybe_unused = {\n\t{CMPC_ACCEL_HID, 0},\n\t{CMPC_ACCEL_HID_V4, 0},\n\t{CMPC_TABLET_HID, 0},\n\t{CMPC_IPML_HID, 0},\n\t{CMPC_KEYS_HID, 0},\n\t{\"\", 0}\n};\n\nMODULE_DEVICE_TABLE(acpi, cmpc_device_ids);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}