{
  "module_name": "hp_accel.c",
  "hash_id": "707a0dab061f3d6ac2b4ff00eb2ba03227fc9fea7456200741b16c2de3602d3d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/x86/hp/hp_accel.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/dmi.h>\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/platform_device.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n#include <linux/wait.h>\n#include <linux/poll.h>\n#include <linux/freezer.h>\n#include <linux/uaccess.h>\n#include <linux/leds.h>\n#include <linux/atomic.h>\n#include <linux/acpi.h>\n#include <linux/i8042.h>\n#include <linux/serio.h>\n#include \"../../../misc/lis3lv02d/lis3lv02d.h\"\n\n \n\n \nstruct delayed_led_classdev {\n\tstruct led_classdev led_classdev;\n\tstruct work_struct work;\n\tenum led_brightness new_brightness;\n\n\tunsigned int led;\t\t \n\tvoid (*set_brightness)(struct delayed_led_classdev *data, enum led_brightness value);\n};\n\nstatic inline void delayed_set_status_worker(struct work_struct *work)\n{\n\tstruct delayed_led_classdev *data =\n\t\t\tcontainer_of(work, struct delayed_led_classdev, work);\n\n\tdata->set_brightness(data, data->new_brightness);\n}\n\nstatic inline void delayed_sysfs_set(struct led_classdev *led_cdev,\n\t\t\t      enum led_brightness brightness)\n{\n\tstruct delayed_led_classdev *data = container_of(led_cdev,\n\t\t\t     struct delayed_led_classdev, led_classdev);\n\tdata->new_brightness = brightness;\n\tschedule_work(&data->work);\n}\n\n \n\n \n#define ACCEL_1 0x25\n#define ACCEL_2 0x26\n#define ACCEL_3 0x27\n#define ACCEL_4 0x28\n\n \nstatic const struct acpi_device_id lis3lv02d_device_ids[] = {\n\t{\"HPQ0004\", 0},  \n\t{\"HPQ6000\", 0},  \n\t{\"HPQ6007\", 0},  \n\t{\"\", 0},\n};\nMODULE_DEVICE_TABLE(acpi, lis3lv02d_device_ids);\n\n \nstatic int lis3lv02d_acpi_init(struct lis3lv02d *lis3)\n{\n\treturn 0;\n}\n\n \nstatic int lis3lv02d_acpi_read(struct lis3lv02d *lis3, int reg, u8 *ret)\n{\n\tstruct acpi_device *dev = lis3->bus_priv;\n\tunion acpi_object arg0 = { ACPI_TYPE_INTEGER };\n\tstruct acpi_object_list args = { 1, &arg0 };\n\tunsigned long long lret;\n\tacpi_status status;\n\n\targ0.integer.value = reg;\n\n\tstatus = acpi_evaluate_integer(dev->handle, \"ALRD\", &args, &lret);\n\tif (ACPI_FAILURE(status))\n\t\treturn -EINVAL;\n\t*ret = lret;\n\treturn 0;\n}\n\n \nstatic int lis3lv02d_acpi_write(struct lis3lv02d *lis3, int reg, u8 val)\n{\n\tstruct acpi_device *dev = lis3->bus_priv;\n\tunsigned long long ret;  \n\tunion acpi_object in_obj[2];\n\tstruct acpi_object_list args = { 2, in_obj };\n\n\tin_obj[0].type          = ACPI_TYPE_INTEGER;\n\tin_obj[0].integer.value = reg;\n\tin_obj[1].type          = ACPI_TYPE_INTEGER;\n\tin_obj[1].integer.value = val;\n\n\tif (acpi_evaluate_integer(dev->handle, \"ALWR\", &args, &ret) != AE_OK)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int lis3lv02d_dmi_matched(const struct dmi_system_id *dmi)\n{\n\tlis3_dev.ac = *((union axis_conversion *)dmi->driver_data);\n\tpr_info(\"hardware type %s found\\n\", dmi->ident);\n\n\treturn 1;\n}\n\n \n#define DEFINE_CONV(name, x, y, z)\t\t\t      \\\n\tstatic union axis_conversion lis3lv02d_axis_##name = \\\n\t\t{ .as_array = { x, y, z } }\nDEFINE_CONV(normal, 1, 2, 3);\nDEFINE_CONV(y_inverted, 1, -2, 3);\nDEFINE_CONV(x_inverted, -1, 2, 3);\nDEFINE_CONV(x_inverted_usd, -1, 2, -3);\nDEFINE_CONV(z_inverted, 1, 2, -3);\nDEFINE_CONV(xy_swap, 2, 1, 3);\nDEFINE_CONV(xy_rotated_left, -2, 1, 3);\nDEFINE_CONV(xy_rotated_left_usd, -2, 1, -3);\nDEFINE_CONV(xy_swap_inverted, -2, -1, 3);\nDEFINE_CONV(xy_rotated_right, 2, -1, 3);\nDEFINE_CONV(xy_swap_yz_inverted, 2, -1, -3);\n\n#define AXIS_DMI_MATCH(_ident, _name, _axis) {\t\t\\\n\t.ident = _ident,\t\t\t\t\\\n\t.callback = lis3lv02d_dmi_matched,\t\t\\\n\t.matches = {\t\t\t\t\t\\\n\t\tDMI_MATCH(DMI_PRODUCT_NAME, _name)\t\\\n\t},\t\t\t\t\t\t\\\n\t.driver_data = &lis3lv02d_axis_##_axis\t\t\\\n}\n\n#define AXIS_DMI_MATCH2(_ident, _class1, _name1,\t\\\n\t\t\t\t_class2, _name2,\t\\\n\t\t\t\t_axis) {\t\t\\\n\t.ident = _ident,\t\t\t\t\\\n\t.callback = lis3lv02d_dmi_matched,\t\t\\\n\t.matches = {\t\t\t\t\t\\\n\t\tDMI_MATCH(DMI_##_class1, _name1),\t\\\n\t\tDMI_MATCH(DMI_##_class2, _name2),\t\\\n\t},\t\t\t\t\t\t\\\n\t.driver_data = &lis3lv02d_axis_##_axis\t\t\\\n}\nstatic const struct dmi_system_id lis3lv02d_dmi_ids[] = {\n\t \n\tAXIS_DMI_MATCH(\"NC64x0\", \"HP Compaq nc64\", x_inverted),\n\tAXIS_DMI_MATCH(\"NC84x0\", \"HP Compaq nc84\", z_inverted),\n\tAXIS_DMI_MATCH(\"NX9420\", \"HP Compaq nx9420\", x_inverted),\n\tAXIS_DMI_MATCH(\"NW9440\", \"HP Compaq nw9440\", x_inverted),\n\tAXIS_DMI_MATCH(\"NC2510\", \"HP Compaq 2510\", y_inverted),\n\tAXIS_DMI_MATCH(\"NC2710\", \"HP Compaq 2710\", xy_swap),\n\tAXIS_DMI_MATCH(\"NC8510\", \"HP Compaq 8510\", xy_swap_inverted),\n\tAXIS_DMI_MATCH(\"HP2133\", \"HP 2133\", xy_rotated_left),\n\tAXIS_DMI_MATCH(\"HP2140\", \"HP 2140\", xy_swap_inverted),\n\tAXIS_DMI_MATCH(\"NC653x\", \"HP Compaq 653\", xy_rotated_left_usd),\n\tAXIS_DMI_MATCH(\"NC6730b\", \"HP Compaq 6730b\", xy_rotated_left_usd),\n\tAXIS_DMI_MATCH(\"NC6730s\", \"HP Compaq 6730s\", xy_swap),\n\tAXIS_DMI_MATCH(\"NC651xx\", \"HP Compaq 651\", xy_rotated_right),\n\tAXIS_DMI_MATCH(\"NC6710x\", \"HP Compaq 6710\", xy_swap_yz_inverted),\n\tAXIS_DMI_MATCH(\"NC6715x\", \"HP Compaq 6715\", y_inverted),\n\tAXIS_DMI_MATCH(\"NC693xx\", \"HP EliteBook 693\", xy_rotated_right),\n\tAXIS_DMI_MATCH(\"NC693xx\", \"HP EliteBook 853\", xy_swap),\n\tAXIS_DMI_MATCH(\"NC854xx\", \"HP EliteBook 854\", y_inverted),\n\tAXIS_DMI_MATCH(\"NC273xx\", \"HP EliteBook 273\", y_inverted),\n\t \n\tAXIS_DMI_MATCH2(\"HPDV5_I\",\n\t\t\tPRODUCT_NAME, \"HP Pavilion dv5\",\n\t\t\tBOARD_NAME, \"3603\",\n\t\t\tx_inverted),\n\t \n\tAXIS_DMI_MATCH2(\"HPDV5_A\",\n\t\t\tPRODUCT_NAME, \"HP Pavilion dv5\",\n\t\t\tBOARD_NAME, \"3600\",\n\t\t\ty_inverted),\n\tAXIS_DMI_MATCH(\"DV7\", \"HP Pavilion dv7\", x_inverted),\n\tAXIS_DMI_MATCH(\"HP8710\", \"HP Compaq 8710\", y_inverted),\n\tAXIS_DMI_MATCH(\"HDX18\", \"HP HDX 18\", x_inverted),\n\tAXIS_DMI_MATCH(\"HPB432x\", \"HP ProBook 432\", xy_rotated_left),\n\tAXIS_DMI_MATCH(\"HPB440G3\", \"HP ProBook 440 G3\", x_inverted_usd),\n\tAXIS_DMI_MATCH(\"HPB440G4\", \"HP ProBook 440 G4\", x_inverted),\n\tAXIS_DMI_MATCH(\"HPB442x\", \"HP ProBook 442\", xy_rotated_left),\n\tAXIS_DMI_MATCH(\"HPB450G0\", \"HP ProBook 450 G0\", x_inverted),\n\tAXIS_DMI_MATCH(\"HPB452x\", \"HP ProBook 452\", y_inverted),\n\tAXIS_DMI_MATCH(\"HPB522x\", \"HP ProBook 522\", xy_swap),\n\tAXIS_DMI_MATCH(\"HPB532x\", \"HP ProBook 532\", y_inverted),\n\tAXIS_DMI_MATCH(\"HPB655x\", \"HP ProBook 655\", xy_swap_inverted),\n\tAXIS_DMI_MATCH(\"Mini510x\", \"HP Mini 510\", xy_rotated_left_usd),\n\tAXIS_DMI_MATCH(\"HPB63xx\", \"HP ProBook 63\", xy_swap),\n\tAXIS_DMI_MATCH(\"HPB64xx\", \"HP ProBook 64\", xy_swap),\n\tAXIS_DMI_MATCH(\"HPB64xx\", \"HP EliteBook 84\", xy_swap),\n\tAXIS_DMI_MATCH(\"HPB65xx\", \"HP ProBook 65\", x_inverted),\n\tAXIS_DMI_MATCH(\"HPZBook15\", \"HP ZBook 15\", x_inverted),\n\tAXIS_DMI_MATCH(\"HPZBook17G5\", \"HP ZBook 17 G5\", x_inverted),\n\tAXIS_DMI_MATCH(\"HPZBook17\", \"HP ZBook 17\", xy_swap_yz_inverted),\n\t{ NULL, }\n \n};\n\nstatic void hpled_set(struct delayed_led_classdev *led_cdev, enum led_brightness value)\n{\n\tstruct acpi_device *dev = lis3_dev.bus_priv;\n\tunsigned long long ret;  \n\tunion acpi_object in_obj[1];\n\tstruct acpi_object_list args = { 1, in_obj };\n\n\tin_obj[0].type          = ACPI_TYPE_INTEGER;\n\tin_obj[0].integer.value = !!value;\n\n\tacpi_evaluate_integer(dev->handle, \"ALED\", &args, &ret);\n}\n\nstatic struct delayed_led_classdev hpled_led = {\n\t.led_classdev = {\n\t\t.name\t\t\t= \"hp::hddprotect\",\n\t\t.default_trigger\t= \"none\",\n\t\t.brightness_set\t\t= delayed_sysfs_set,\n\t\t.flags                  = LED_CORE_SUSPENDRESUME,\n\t},\n\t.set_brightness = hpled_set,\n};\n\nstatic bool hp_accel_i8042_filter(unsigned char data, unsigned char str,\n\t\t\t\t  struct serio *port)\n{\n\tstatic bool extended;\n\n\tif (str & I8042_STR_AUXDATA)\n\t\treturn false;\n\n\tif (data == 0xe0) {\n\t\textended = true;\n\t\treturn true;\n\t} else if (unlikely(extended)) {\n\t\textended = false;\n\n\t\tswitch (data) {\n\t\tcase ACCEL_1:\n\t\tcase ACCEL_2:\n\t\tcase ACCEL_3:\n\t\tcase ACCEL_4:\n\t\t\treturn true;\n\t\tdefault:\n\t\t\tserio_interrupt(port, 0xe0, 0);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nstatic int lis3lv02d_probe(struct platform_device *device)\n{\n\tint ret;\n\n\tlis3_dev.bus_priv = ACPI_COMPANION(&device->dev);\n\tlis3_dev.init = lis3lv02d_acpi_init;\n\tlis3_dev.read = lis3lv02d_acpi_read;\n\tlis3_dev.write = lis3lv02d_acpi_write;\n\n\t \n\tret = platform_get_irq_optional(device, 0);\n\tif (ret > 0)\n\t\tlis3_dev.irq = ret;\n\n\t \n\tif (lis3_dev.ac.x && lis3_dev.ac.y && lis3_dev.ac.z) {\n\t\tpr_info(\"Using custom axes %d,%d,%d\\n\",\n\t\t\tlis3_dev.ac.x, lis3_dev.ac.y, lis3_dev.ac.z);\n\t} else if (dmi_check_system(lis3lv02d_dmi_ids) == 0) {\n\t\tpr_info(\"laptop model unknown, using default axes configuration\\n\");\n\t\tlis3_dev.ac = lis3lv02d_axis_normal;\n\t}\n\n\t \n\tret = lis3lv02d_init_device(&lis3_dev);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (strstr(dev_name(&device->dev), \"HPQ6000\"))\n\t\ti8042_install_filter(hp_accel_i8042_filter);\n\n\tINIT_WORK(&hpled_led.work, delayed_set_status_worker);\n\tret = led_classdev_register(NULL, &hpled_led.led_classdev);\n\tif (ret) {\n\t\ti8042_remove_filter(hp_accel_i8042_filter);\n\t\tlis3lv02d_joystick_disable(&lis3_dev);\n\t\tlis3lv02d_poweroff(&lis3_dev);\n\t\tflush_work(&hpled_led.work);\n\t\tlis3lv02d_remove_fs(&lis3_dev);\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nstatic void lis3lv02d_remove(struct platform_device *device)\n{\n\ti8042_remove_filter(hp_accel_i8042_filter);\n\tlis3lv02d_joystick_disable(&lis3_dev);\n\tlis3lv02d_poweroff(&lis3_dev);\n\n\tled_classdev_unregister(&hpled_led.led_classdev);\n\tflush_work(&hpled_led.work);\n\n\tlis3lv02d_remove_fs(&lis3_dev);\n}\n\nstatic int __maybe_unused lis3lv02d_suspend(struct device *dev)\n{\n\t \n\tlis3lv02d_poweroff(&lis3_dev);\n\treturn 0;\n}\n\nstatic int __maybe_unused lis3lv02d_resume(struct device *dev)\n{\n\tlis3lv02d_poweron(&lis3_dev);\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(hp_accel_pm, lis3lv02d_suspend, lis3lv02d_resume);\n\n \nstatic struct platform_driver lis3lv02d_driver = {\n\t.probe\t= lis3lv02d_probe,\n\t.remove_new = lis3lv02d_remove,\n\t.driver\t= {\n\t\t.name\t= \"hp_accel\",\n\t\t.pm\t= &hp_accel_pm,\n\t\t.acpi_match_table = lis3lv02d_device_ids,\n\t},\n};\nmodule_platform_driver(lis3lv02d_driver);\n\nMODULE_DESCRIPTION(\"Glue between LIS3LV02Dx and HP ACPI BIOS and support for disk protection LED.\");\nMODULE_AUTHOR(\"Yan Burman, Eric Piel, Pavel Machek\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}