{
  "module_name": "hp-wmi.c",
  "hash_id": "8c924b78e28110df0e09e182f7802cae8dd4476967113584a74141d6694e6bdb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/x86/hp/hp-wmi.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/input.h>\n#include <linux/input/sparse-keymap.h>\n#include <linux/platform_device.h>\n#include <linux/platform_profile.h>\n#include <linux/hwmon.h>\n#include <linux/acpi.h>\n#include <linux/rfkill.h>\n#include <linux/string.h>\n#include <linux/dmi.h>\n\nMODULE_AUTHOR(\"Matthew Garrett <mjg59@srcf.ucam.org>\");\nMODULE_DESCRIPTION(\"HP laptop WMI hotkeys driver\");\nMODULE_LICENSE(\"GPL\");\n\nMODULE_ALIAS(\"wmi:95F24279-4D7B-4334-9387-ACCDC67EF61C\");\nMODULE_ALIAS(\"wmi:5FB7F034-2C63-45e9-BE91-3D44E2C707E4\");\n\n#define HPWMI_EVENT_GUID \"95F24279-4D7B-4334-9387-ACCDC67EF61C\"\n#define HPWMI_BIOS_GUID \"5FB7F034-2C63-45e9-BE91-3D44E2C707E4\"\n#define HP_OMEN_EC_THERMAL_PROFILE_OFFSET 0x95\n#define zero_if_sup(tmp) (zero_insize_support?0:sizeof(tmp)) \n\n \nstatic const char * const omen_thermal_profile_boards[] = {\n\t\"84DA\", \"84DB\", \"84DC\", \"8574\", \"8575\", \"860A\", \"87B5\", \"8572\", \"8573\",\n\t\"8600\", \"8601\", \"8602\", \"8605\", \"8606\", \"8607\", \"8746\", \"8747\", \"8749\",\n\t\"874A\", \"8603\", \"8604\", \"8748\", \"886B\", \"886C\", \"878A\", \"878B\", \"878C\",\n\t\"88C8\", \"88CB\", \"8786\", \"8787\", \"8788\", \"88D1\", \"88D2\", \"88F4\", \"88FD\",\n\t\"88F5\", \"88F6\", \"88F7\", \"88FE\", \"88FF\", \"8900\", \"8901\", \"8902\", \"8912\",\n\t\"8917\", \"8918\", \"8949\", \"894A\", \"89EB\"\n};\n\n \nstatic const char *const omen_thermal_profile_force_v0_boards[] = {\n\t\"8607\", \"8746\", \"8747\", \"8749\", \"874A\", \"8748\"\n};\n\n \nstatic const char * const victus_thermal_profile_boards[] = {\n\t\"8A25\"\n};\n\nenum hp_wmi_radio {\n\tHPWMI_WIFI\t= 0x0,\n\tHPWMI_BLUETOOTH\t= 0x1,\n\tHPWMI_WWAN\t= 0x2,\n\tHPWMI_GPS\t= 0x3,\n};\n\nenum hp_wmi_event_ids {\n\tHPWMI_DOCK_EVENT\t\t= 0x01,\n\tHPWMI_PARK_HDD\t\t\t= 0x02,\n\tHPWMI_SMART_ADAPTER\t\t= 0x03,\n\tHPWMI_BEZEL_BUTTON\t\t= 0x04,\n\tHPWMI_WIRELESS\t\t\t= 0x05,\n\tHPWMI_CPU_BATTERY_THROTTLE\t= 0x06,\n\tHPWMI_LOCK_SWITCH\t\t= 0x07,\n\tHPWMI_LID_SWITCH\t\t= 0x08,\n\tHPWMI_SCREEN_ROTATION\t\t= 0x09,\n\tHPWMI_COOLSENSE_SYSTEM_MOBILE\t= 0x0A,\n\tHPWMI_COOLSENSE_SYSTEM_HOT\t= 0x0B,\n\tHPWMI_PROXIMITY_SENSOR\t\t= 0x0C,\n\tHPWMI_BACKLIT_KB_BRIGHTNESS\t= 0x0D,\n\tHPWMI_PEAKSHIFT_PERIOD\t\t= 0x0F,\n\tHPWMI_BATTERY_CHARGE_PERIOD\t= 0x10,\n\tHPWMI_SANITIZATION_MODE\t\t= 0x17,\n\tHPWMI_CAMERA_TOGGLE\t\t= 0x1A,\n\tHPWMI_OMEN_KEY\t\t\t= 0x1D,\n\tHPWMI_SMART_EXPERIENCE_APP\t= 0x21,\n};\n\n \nstruct bios_args {\n\tu32 signature;\n\tu32 command;\n\tu32 commandtype;\n\tu32 datasize;\n\tu8 data[];\n};\n\nenum hp_wmi_commandtype {\n\tHPWMI_DISPLAY_QUERY\t\t= 0x01,\n\tHPWMI_HDDTEMP_QUERY\t\t= 0x02,\n\tHPWMI_ALS_QUERY\t\t\t= 0x03,\n\tHPWMI_HARDWARE_QUERY\t\t= 0x04,\n\tHPWMI_WIRELESS_QUERY\t\t= 0x05,\n\tHPWMI_BATTERY_QUERY\t\t= 0x07,\n\tHPWMI_BIOS_QUERY\t\t= 0x09,\n\tHPWMI_FEATURE_QUERY\t\t= 0x0b,\n\tHPWMI_HOTKEY_QUERY\t\t= 0x0c,\n\tHPWMI_FEATURE2_QUERY\t\t= 0x0d,\n\tHPWMI_WIRELESS2_QUERY\t\t= 0x1b,\n\tHPWMI_POSTCODEERROR_QUERY\t= 0x2a,\n\tHPWMI_SYSTEM_DEVICE_MODE\t= 0x40,\n\tHPWMI_THERMAL_PROFILE_QUERY\t= 0x4c,\n};\n\nenum hp_wmi_gm_commandtype {\n\tHPWMI_FAN_SPEED_GET_QUERY = 0x11,\n\tHPWMI_SET_PERFORMANCE_MODE = 0x1A,\n\tHPWMI_FAN_SPEED_MAX_GET_QUERY = 0x26,\n\tHPWMI_FAN_SPEED_MAX_SET_QUERY = 0x27,\n\tHPWMI_GET_SYSTEM_DESIGN_DATA = 0x28,\n};\n\nenum hp_wmi_command {\n\tHPWMI_READ\t= 0x01,\n\tHPWMI_WRITE\t= 0x02,\n\tHPWMI_ODM\t= 0x03,\n\tHPWMI_GM\t= 0x20008,\n};\n\nenum hp_wmi_hardware_mask {\n\tHPWMI_DOCK_MASK\t\t= 0x01,\n\tHPWMI_TABLET_MASK\t= 0x04,\n};\n\nstruct bios_return {\n\tu32 sigpass;\n\tu32 return_code;\n};\n\nenum hp_return_value {\n\tHPWMI_RET_WRONG_SIGNATURE\t= 0x02,\n\tHPWMI_RET_UNKNOWN_COMMAND\t= 0x03,\n\tHPWMI_RET_UNKNOWN_CMDTYPE\t= 0x04,\n\tHPWMI_RET_INVALID_PARAMETERS\t= 0x05,\n};\n\nenum hp_wireless2_bits {\n\tHPWMI_POWER_STATE\t= 0x01,\n\tHPWMI_POWER_SOFT\t= 0x02,\n\tHPWMI_POWER_BIOS\t= 0x04,\n\tHPWMI_POWER_HARD\t= 0x08,\n\tHPWMI_POWER_FW_OR_HW\t= HPWMI_POWER_BIOS | HPWMI_POWER_HARD,\n};\n\nenum hp_thermal_profile_omen_v0 {\n\tHP_OMEN_V0_THERMAL_PROFILE_DEFAULT     = 0x00,\n\tHP_OMEN_V0_THERMAL_PROFILE_PERFORMANCE = 0x01,\n\tHP_OMEN_V0_THERMAL_PROFILE_COOL        = 0x02,\n};\n\nenum hp_thermal_profile_omen_v1 {\n\tHP_OMEN_V1_THERMAL_PROFILE_DEFAULT\t= 0x30,\n\tHP_OMEN_V1_THERMAL_PROFILE_PERFORMANCE\t= 0x31,\n\tHP_OMEN_V1_THERMAL_PROFILE_COOL\t\t= 0x50,\n};\n\nenum hp_thermal_profile_victus {\n\tHP_VICTUS_THERMAL_PROFILE_DEFAULT\t\t= 0x00,\n\tHP_VICTUS_THERMAL_PROFILE_PERFORMANCE\t\t= 0x01,\n\tHP_VICTUS_THERMAL_PROFILE_QUIET\t\t\t= 0x03,\n};\n\nenum hp_thermal_profile {\n\tHP_THERMAL_PROFILE_PERFORMANCE\t= 0x00,\n\tHP_THERMAL_PROFILE_DEFAULT\t\t= 0x01,\n\tHP_THERMAL_PROFILE_COOL\t\t\t= 0x02,\n\tHP_THERMAL_PROFILE_QUIET\t\t= 0x03,\n};\n\n#define IS_HWBLOCKED(x) ((x & HPWMI_POWER_FW_OR_HW) != HPWMI_POWER_FW_OR_HW)\n#define IS_SWBLOCKED(x) !(x & HPWMI_POWER_SOFT)\n\nstruct bios_rfkill2_device_state {\n\tu8 radio_type;\n\tu8 bus_type;\n\tu16 vendor_id;\n\tu16 product_id;\n\tu16 subsys_vendor_id;\n\tu16 subsys_product_id;\n\tu8 rfkill_id;\n\tu8 power;\n\tu8 unknown[4];\n};\n\n \n#define HPWMI_MAX_RFKILL2_DEVICES\t7\n\nstruct bios_rfkill2_state {\n\tu8 unknown[7];\n\tu8 count;\n\tu8 pad[8];\n\tstruct bios_rfkill2_device_state device[HPWMI_MAX_RFKILL2_DEVICES];\n};\n\nstatic const struct key_entry hp_wmi_keymap[] = {\n\t{ KE_KEY, 0x02,    { KEY_BRIGHTNESSUP } },\n\t{ KE_KEY, 0x03,    { KEY_BRIGHTNESSDOWN } },\n\t{ KE_KEY, 0x270,   { KEY_MICMUTE } },\n\t{ KE_KEY, 0x20e6,  { KEY_PROG1 } },\n\t{ KE_KEY, 0x20e8,  { KEY_MEDIA } },\n\t{ KE_KEY, 0x2142,  { KEY_MEDIA } },\n\t{ KE_KEY, 0x213b,  { KEY_INFO } },\n\t{ KE_KEY, 0x2169,  { KEY_ROTATE_DISPLAY } },\n\t{ KE_KEY, 0x216a,  { KEY_SETUP } },\n\t{ KE_IGNORE, 0x21a4,  },  \n\t{ KE_IGNORE, 0x121a4, },  \n\t{ KE_KEY, 0x21a5,  { KEY_PROG2 } },  \n\t{ KE_KEY, 0x21a7,  { KEY_FN_ESC } },\n\t{ KE_KEY, 0x21a8,  { KEY_PROG2 } },  \n\t{ KE_KEY, 0x21a9,  { KEY_TOUCHPAD_OFF } },\n\t{ KE_KEY, 0x121a9, { KEY_TOUCHPAD_ON } },\n\t{ KE_KEY, 0x231b,  { KEY_HELP } },\n\t{ KE_END, 0 }\n};\n\nstatic struct input_dev *hp_wmi_input_dev;\nstatic struct input_dev *camera_shutter_input_dev;\nstatic struct platform_device *hp_wmi_platform_dev;\nstatic struct platform_profile_handler platform_profile_handler;\nstatic bool platform_profile_support;\nstatic bool zero_insize_support;\n\nstatic struct rfkill *wifi_rfkill;\nstatic struct rfkill *bluetooth_rfkill;\nstatic struct rfkill *wwan_rfkill;\n\nstruct rfkill2_device {\n\tu8 id;\n\tint num;\n\tstruct rfkill *rfkill;\n};\n\nstatic int rfkill2_count;\nstatic struct rfkill2_device rfkill2[HPWMI_MAX_RFKILL2_DEVICES];\n\n \nstatic const char * const tablet_chassis_types[] = {\n\t\"30\",  \n\t\"31\",  \n\t\"32\"   \n};\n\n#define DEVICE_MODE_TABLET\t0x06\n\n \nstatic inline int encode_outsize_for_pvsz(int outsize)\n{\n\tif (outsize > 4096)\n\t\treturn -EINVAL;\n\tif (outsize > 1024)\n\t\treturn 5;\n\tif (outsize > 128)\n\t\treturn 4;\n\tif (outsize > 4)\n\t\treturn 3;\n\tif (outsize > 0)\n\t\treturn 2;\n\treturn 1;\n}\n\n \nstatic int hp_wmi_perform_query(int query, enum hp_wmi_command command,\n\t\t\t\tvoid *buffer, int insize, int outsize)\n{\n\tstruct acpi_buffer input, output = { ACPI_ALLOCATE_BUFFER, NULL };\n\tstruct bios_return *bios_return;\n\tunion acpi_object *obj = NULL;\n\tstruct bios_args *args = NULL;\n\tint mid, actual_insize, actual_outsize;\n\tsize_t bios_args_size;\n\tint ret;\n\n\tmid = encode_outsize_for_pvsz(outsize);\n\tif (WARN_ON(mid < 0))\n\t\treturn mid;\n\n\tactual_insize = max(insize, 128);\n\tbios_args_size = struct_size(args, data, actual_insize);\n\targs = kmalloc(bios_args_size, GFP_KERNEL);\n\tif (!args)\n\t\treturn -ENOMEM;\n\n\tinput.length = bios_args_size;\n\tinput.pointer = args;\n\n\targs->signature = 0x55434553;\n\targs->command = command;\n\targs->commandtype = query;\n\targs->datasize = insize;\n\tmemcpy(args->data, buffer, flex_array_size(args, data, insize));\n\n\tret = wmi_evaluate_method(HPWMI_BIOS_GUID, 0, mid, &input, &output);\n\tif (ret)\n\t\tgoto out_free;\n\n\tobj = output.pointer;\n\tif (!obj) {\n\t\tret = -EINVAL;\n\t\tgoto out_free;\n\t}\n\n\tif (obj->type != ACPI_TYPE_BUFFER) {\n\t\tpr_warn(\"query 0x%x returned an invalid object 0x%x\\n\", query, ret);\n\t\tret = -EINVAL;\n\t\tgoto out_free;\n\t}\n\n\tbios_return = (struct bios_return *)obj->buffer.pointer;\n\tret = bios_return->return_code;\n\n\tif (ret) {\n\t\tif (ret != HPWMI_RET_UNKNOWN_COMMAND &&\n\t\t    ret != HPWMI_RET_UNKNOWN_CMDTYPE)\n\t\t\tpr_warn(\"query 0x%x returned error 0x%x\\n\", query, ret);\n\t\tgoto out_free;\n\t}\n\n\t \n\tif (!outsize)\n\t\tgoto out_free;\n\n\tactual_outsize = min(outsize, (int)(obj->buffer.length - sizeof(*bios_return)));\n\tmemcpy(buffer, obj->buffer.pointer + sizeof(*bios_return), actual_outsize);\n\tmemset(buffer + actual_outsize, 0, outsize - actual_outsize);\n\nout_free:\n\tkfree(obj);\n\tkfree(args);\n\treturn ret;\n}\n\nstatic int hp_wmi_get_fan_speed(int fan)\n{\n\tu8 fsh, fsl;\n\tchar fan_data[4] = { fan, 0, 0, 0 };\n\n\tint ret = hp_wmi_perform_query(HPWMI_FAN_SPEED_GET_QUERY, HPWMI_GM,\n\t\t\t\t       &fan_data, sizeof(char),\n\t\t\t\t       sizeof(fan_data));\n\n\tif (ret != 0)\n\t\treturn -EINVAL;\n\n\tfsh = fan_data[2];\n\tfsl = fan_data[3];\n\n\treturn (fsh << 8) | fsl;\n}\n\nstatic int hp_wmi_read_int(int query)\n{\n\tint val = 0, ret;\n\n\tret = hp_wmi_perform_query(query, HPWMI_READ, &val,\n\t\t\t\t   zero_if_sup(val), sizeof(val));\n\n\tif (ret)\n\t\treturn ret < 0 ? ret : -EINVAL;\n\n\treturn val;\n}\n\nstatic int hp_wmi_get_dock_state(void)\n{\n\tint state = hp_wmi_read_int(HPWMI_HARDWARE_QUERY);\n\n\tif (state < 0)\n\t\treturn state;\n\n\treturn !!(state & HPWMI_DOCK_MASK);\n}\n\nstatic int hp_wmi_get_tablet_mode(void)\n{\n\tchar system_device_mode[4] = { 0 };\n\tconst char *chassis_type;\n\tbool tablet_found;\n\tint ret;\n\n\tchassis_type = dmi_get_system_info(DMI_CHASSIS_TYPE);\n\tif (!chassis_type)\n\t\treturn -ENODEV;\n\n\ttablet_found = match_string(tablet_chassis_types,\n\t\t\t\t    ARRAY_SIZE(tablet_chassis_types),\n\t\t\t\t    chassis_type) >= 0;\n\tif (!tablet_found)\n\t\treturn -ENODEV;\n\n\tret = hp_wmi_perform_query(HPWMI_SYSTEM_DEVICE_MODE, HPWMI_READ,\n\t\t\t\t   system_device_mode, zero_if_sup(system_device_mode),\n\t\t\t\t   sizeof(system_device_mode));\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn system_device_mode[0] == DEVICE_MODE_TABLET;\n}\n\nstatic int omen_thermal_profile_set(int mode)\n{\n\tchar buffer[2] = {0, mode};\n\tint ret;\n\n\tret = hp_wmi_perform_query(HPWMI_SET_PERFORMANCE_MODE, HPWMI_GM,\n\t\t\t\t   &buffer, sizeof(buffer), 0);\n\n\tif (ret)\n\t\treturn ret < 0 ? ret : -EINVAL;\n\n\treturn mode;\n}\n\nstatic bool is_omen_thermal_profile(void)\n{\n\tconst char *board_name = dmi_get_system_info(DMI_BOARD_NAME);\n\n\tif (!board_name)\n\t\treturn false;\n\n\treturn match_string(omen_thermal_profile_boards,\n\t\t\t    ARRAY_SIZE(omen_thermal_profile_boards),\n\t\t\t    board_name) >= 0;\n}\n\nstatic int omen_get_thermal_policy_version(void)\n{\n\tunsigned char buffer[8] = { 0 };\n\tint ret;\n\n\tconst char *board_name = dmi_get_system_info(DMI_BOARD_NAME);\n\n\tif (board_name) {\n\t\tint matches = match_string(omen_thermal_profile_force_v0_boards,\n\t\t\tARRAY_SIZE(omen_thermal_profile_force_v0_boards),\n\t\t\tboard_name);\n\t\tif (matches >= 0)\n\t\t\treturn 0;\n\t}\n\n\tret = hp_wmi_perform_query(HPWMI_GET_SYSTEM_DESIGN_DATA, HPWMI_GM,\n\t\t\t\t   &buffer, sizeof(buffer), sizeof(buffer));\n\n\tif (ret)\n\t\treturn ret < 0 ? ret : -EINVAL;\n\n\treturn buffer[3];\n}\n\nstatic int omen_thermal_profile_get(void)\n{\n\tu8 data;\n\n\tint ret = ec_read(HP_OMEN_EC_THERMAL_PROFILE_OFFSET, &data);\n\n\tif (ret)\n\t\treturn ret;\n\n\treturn data;\n}\n\nstatic int hp_wmi_fan_speed_max_set(int enabled)\n{\n\tint ret;\n\n\tret = hp_wmi_perform_query(HPWMI_FAN_SPEED_MAX_SET_QUERY, HPWMI_GM,\n\t\t\t\t   &enabled, sizeof(enabled), 0);\n\n\tif (ret)\n\t\treturn ret < 0 ? ret : -EINVAL;\n\n\treturn enabled;\n}\n\nstatic int hp_wmi_fan_speed_max_get(void)\n{\n\tint val = 0, ret;\n\n\tret = hp_wmi_perform_query(HPWMI_FAN_SPEED_MAX_GET_QUERY, HPWMI_GM,\n\t\t\t\t   &val, zero_if_sup(val), sizeof(val));\n\n\tif (ret)\n\t\treturn ret < 0 ? ret : -EINVAL;\n\n\treturn val;\n}\n\nstatic int __init hp_wmi_bios_2008_later(void)\n{\n\tint state = 0;\n\tint ret = hp_wmi_perform_query(HPWMI_FEATURE_QUERY, HPWMI_READ, &state,\n\t\t\t\t       zero_if_sup(state), sizeof(state));\n\tif (!ret)\n\t\treturn 1;\n\n\treturn (ret == HPWMI_RET_UNKNOWN_CMDTYPE) ? 0 : -ENXIO;\n}\n\nstatic int __init hp_wmi_bios_2009_later(void)\n{\n\tu8 state[128];\n\tint ret = hp_wmi_perform_query(HPWMI_FEATURE2_QUERY, HPWMI_READ, &state,\n\t\t\t\t       zero_if_sup(state), sizeof(state));\n\tif (!ret)\n\t\treturn 1;\n\n\treturn (ret == HPWMI_RET_UNKNOWN_CMDTYPE) ? 0 : -ENXIO;\n}\n\nstatic int __init hp_wmi_enable_hotkeys(void)\n{\n\tint value = 0x6e;\n\tint ret = hp_wmi_perform_query(HPWMI_BIOS_QUERY, HPWMI_WRITE, &value,\n\t\t\t\t       sizeof(value), 0);\n\n\treturn ret <= 0 ? ret : -EINVAL;\n}\n\nstatic int hp_wmi_set_block(void *data, bool blocked)\n{\n\tenum hp_wmi_radio r = (long)data;\n\tint query = BIT(r + 8) | ((!blocked) << r);\n\tint ret;\n\n\tret = hp_wmi_perform_query(HPWMI_WIRELESS_QUERY, HPWMI_WRITE,\n\t\t\t\t   &query, sizeof(query), 0);\n\n\treturn ret <= 0 ? ret : -EINVAL;\n}\n\nstatic const struct rfkill_ops hp_wmi_rfkill_ops = {\n\t.set_block = hp_wmi_set_block,\n};\n\nstatic bool hp_wmi_get_sw_state(enum hp_wmi_radio r)\n{\n\tint mask = 0x200 << (r * 8);\n\n\tint wireless = hp_wmi_read_int(HPWMI_WIRELESS_QUERY);\n\n\t \n\tWARN_ONCE(wireless < 0, \"error executing HPWMI_WIRELESS_QUERY\");\n\n\treturn !(wireless & mask);\n}\n\nstatic bool hp_wmi_get_hw_state(enum hp_wmi_radio r)\n{\n\tint mask = 0x800 << (r * 8);\n\n\tint wireless = hp_wmi_read_int(HPWMI_WIRELESS_QUERY);\n\n\t \n\tWARN_ONCE(wireless < 0, \"error executing HPWMI_WIRELESS_QUERY\");\n\n\treturn !(wireless & mask);\n}\n\nstatic int hp_wmi_rfkill2_set_block(void *data, bool blocked)\n{\n\tint rfkill_id = (int)(long)data;\n\tchar buffer[4] = { 0x01, 0x00, rfkill_id, !blocked };\n\tint ret;\n\n\tret = hp_wmi_perform_query(HPWMI_WIRELESS2_QUERY, HPWMI_WRITE,\n\t\t\t\t   buffer, sizeof(buffer), 0);\n\n\treturn ret <= 0 ? ret : -EINVAL;\n}\n\nstatic const struct rfkill_ops hp_wmi_rfkill2_ops = {\n\t.set_block = hp_wmi_rfkill2_set_block,\n};\n\nstatic int hp_wmi_rfkill2_refresh(void)\n{\n\tstruct bios_rfkill2_state state;\n\tint err, i;\n\n\terr = hp_wmi_perform_query(HPWMI_WIRELESS2_QUERY, HPWMI_READ, &state,\n\t\t\t\t   zero_if_sup(state), sizeof(state));\n\tif (err)\n\t\treturn err;\n\n\tfor (i = 0; i < rfkill2_count; i++) {\n\t\tint num = rfkill2[i].num;\n\t\tstruct bios_rfkill2_device_state *devstate;\n\n\t\tdevstate = &state.device[num];\n\n\t\tif (num >= state.count ||\n\t\t    devstate->rfkill_id != rfkill2[i].id) {\n\t\t\tpr_warn(\"power configuration of the wireless devices unexpectedly changed\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\trfkill_set_states(rfkill2[i].rfkill,\n\t\t\t\t  IS_SWBLOCKED(devstate->power),\n\t\t\t\t  IS_HWBLOCKED(devstate->power));\n\t}\n\n\treturn 0;\n}\n\nstatic ssize_t display_show(struct device *dev, struct device_attribute *attr,\n\t\t\t    char *buf)\n{\n\tint value = hp_wmi_read_int(HPWMI_DISPLAY_QUERY);\n\n\tif (value < 0)\n\t\treturn value;\n\treturn sprintf(buf, \"%d\\n\", value);\n}\n\nstatic ssize_t hddtemp_show(struct device *dev, struct device_attribute *attr,\n\t\t\t    char *buf)\n{\n\tint value = hp_wmi_read_int(HPWMI_HDDTEMP_QUERY);\n\n\tif (value < 0)\n\t\treturn value;\n\treturn sprintf(buf, \"%d\\n\", value);\n}\n\nstatic ssize_t als_show(struct device *dev, struct device_attribute *attr,\n\t\t\tchar *buf)\n{\n\tint value = hp_wmi_read_int(HPWMI_ALS_QUERY);\n\n\tif (value < 0)\n\t\treturn value;\n\treturn sprintf(buf, \"%d\\n\", value);\n}\n\nstatic ssize_t dock_show(struct device *dev, struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\tint value = hp_wmi_get_dock_state();\n\n\tif (value < 0)\n\t\treturn value;\n\treturn sprintf(buf, \"%d\\n\", value);\n}\n\nstatic ssize_t tablet_show(struct device *dev, struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\tint value = hp_wmi_get_tablet_mode();\n\n\tif (value < 0)\n\t\treturn value;\n\treturn sprintf(buf, \"%d\\n\", value);\n}\n\nstatic ssize_t postcode_show(struct device *dev, struct device_attribute *attr,\n\t\t\t     char *buf)\n{\n\t \n\tint value = hp_wmi_read_int(HPWMI_POSTCODEERROR_QUERY);\n\n\tif (value < 0)\n\t\treturn value;\n\treturn sprintf(buf, \"0x%x\\n\", value);\n}\n\nstatic ssize_t als_store(struct device *dev, struct device_attribute *attr,\n\t\t\t const char *buf, size_t count)\n{\n\tu32 tmp;\n\tint ret;\n\n\tret = kstrtou32(buf, 10, &tmp);\n\tif (ret)\n\t\treturn ret;\n\n\tret = hp_wmi_perform_query(HPWMI_ALS_QUERY, HPWMI_WRITE, &tmp,\n\t\t\t\t       sizeof(tmp), 0);\n\tif (ret)\n\t\treturn ret < 0 ? ret : -EINVAL;\n\n\treturn count;\n}\n\nstatic ssize_t postcode_store(struct device *dev, struct device_attribute *attr,\n\t\t\t      const char *buf, size_t count)\n{\n\tu32 tmp = 1;\n\tbool clear;\n\tint ret;\n\n\tret = kstrtobool(buf, &clear);\n\tif (ret)\n\t\treturn ret;\n\n\tif (clear == false)\n\t\treturn -EINVAL;\n\n\t \n\tret = hp_wmi_perform_query(HPWMI_POSTCODEERROR_QUERY, HPWMI_WRITE, &tmp,\n\t\t\t\t       sizeof(tmp), 0);\n\tif (ret)\n\t\treturn ret < 0 ? ret : -EINVAL;\n\n\treturn count;\n}\n\nstatic int camera_shutter_input_setup(void)\n{\n\tint err;\n\n\tcamera_shutter_input_dev = input_allocate_device();\n\tif (!camera_shutter_input_dev)\n\t\treturn -ENOMEM;\n\n\tcamera_shutter_input_dev->name = \"HP WMI camera shutter\";\n\tcamera_shutter_input_dev->phys = \"wmi/input1\";\n\tcamera_shutter_input_dev->id.bustype = BUS_HOST;\n\n\t__set_bit(EV_SW, camera_shutter_input_dev->evbit);\n\t__set_bit(SW_CAMERA_LENS_COVER, camera_shutter_input_dev->swbit);\n\n\terr = input_register_device(camera_shutter_input_dev);\n\tif (err)\n\t\tgoto err_free_dev;\n\n\treturn 0;\n\n err_free_dev:\n\tinput_free_device(camera_shutter_input_dev);\n\tcamera_shutter_input_dev = NULL;\n\treturn err;\n}\n\nstatic DEVICE_ATTR_RO(display);\nstatic DEVICE_ATTR_RO(hddtemp);\nstatic DEVICE_ATTR_RW(als);\nstatic DEVICE_ATTR_RO(dock);\nstatic DEVICE_ATTR_RO(tablet);\nstatic DEVICE_ATTR_RW(postcode);\n\nstatic struct attribute *hp_wmi_attrs[] = {\n\t&dev_attr_display.attr,\n\t&dev_attr_hddtemp.attr,\n\t&dev_attr_als.attr,\n\t&dev_attr_dock.attr,\n\t&dev_attr_tablet.attr,\n\t&dev_attr_postcode.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(hp_wmi);\n\nstatic void hp_wmi_notify(u32 value, void *context)\n{\n\tstruct acpi_buffer response = { ACPI_ALLOCATE_BUFFER, NULL };\n\tu32 event_id, event_data;\n\tunion acpi_object *obj;\n\tacpi_status status;\n\tu32 *location;\n\tint key_code;\n\n\tstatus = wmi_get_event_data(value, &response);\n\tif (status != AE_OK) {\n\t\tpr_info(\"bad event status 0x%x\\n\", status);\n\t\treturn;\n\t}\n\n\tobj = (union acpi_object *)response.pointer;\n\n\tif (!obj)\n\t\treturn;\n\tif (obj->type != ACPI_TYPE_BUFFER) {\n\t\tpr_info(\"Unknown response received %d\\n\", obj->type);\n\t\tkfree(obj);\n\t\treturn;\n\t}\n\n\t \n\tlocation = (u32 *)obj->buffer.pointer;\n\tif (obj->buffer.length == 8) {\n\t\tevent_id = *location;\n\t\tevent_data = *(location + 1);\n\t} else if (obj->buffer.length == 16) {\n\t\tevent_id = *location;\n\t\tevent_data = *(location + 2);\n\t} else {\n\t\tpr_info(\"Unknown buffer length %d\\n\", obj->buffer.length);\n\t\tkfree(obj);\n\t\treturn;\n\t}\n\tkfree(obj);\n\n\tswitch (event_id) {\n\tcase HPWMI_DOCK_EVENT:\n\t\tif (test_bit(SW_DOCK, hp_wmi_input_dev->swbit))\n\t\t\tinput_report_switch(hp_wmi_input_dev, SW_DOCK,\n\t\t\t\t\t    hp_wmi_get_dock_state());\n\t\tif (test_bit(SW_TABLET_MODE, hp_wmi_input_dev->swbit))\n\t\t\tinput_report_switch(hp_wmi_input_dev, SW_TABLET_MODE,\n\t\t\t\t\t    hp_wmi_get_tablet_mode());\n\t\tinput_sync(hp_wmi_input_dev);\n\t\tbreak;\n\tcase HPWMI_PARK_HDD:\n\t\tbreak;\n\tcase HPWMI_SMART_ADAPTER:\n\t\tbreak;\n\tcase HPWMI_BEZEL_BUTTON:\n\t\tkey_code = hp_wmi_read_int(HPWMI_HOTKEY_QUERY);\n\t\tif (key_code < 0)\n\t\t\tbreak;\n\n\t\tif (!sparse_keymap_report_event(hp_wmi_input_dev,\n\t\t\t\t\t\tkey_code, 1, true))\n\t\t\tpr_info(\"Unknown key code - 0x%x\\n\", key_code);\n\t\tbreak;\n\tcase HPWMI_OMEN_KEY:\n\t\tif (event_data)  \n\t\t\tkey_code = event_data;\n\t\telse\n\t\t\tkey_code = hp_wmi_read_int(HPWMI_HOTKEY_QUERY);\n\n\t\tif (!sparse_keymap_report_event(hp_wmi_input_dev,\n\t\t\t\t\t\tkey_code, 1, true))\n\t\t\tpr_info(\"Unknown key code - 0x%x\\n\", key_code);\n\t\tbreak;\n\tcase HPWMI_WIRELESS:\n\t\tif (rfkill2_count) {\n\t\t\thp_wmi_rfkill2_refresh();\n\t\t\tbreak;\n\t\t}\n\n\t\tif (wifi_rfkill)\n\t\t\trfkill_set_states(wifi_rfkill,\n\t\t\t\t\t  hp_wmi_get_sw_state(HPWMI_WIFI),\n\t\t\t\t\t  hp_wmi_get_hw_state(HPWMI_WIFI));\n\t\tif (bluetooth_rfkill)\n\t\t\trfkill_set_states(bluetooth_rfkill,\n\t\t\t\t\t  hp_wmi_get_sw_state(HPWMI_BLUETOOTH),\n\t\t\t\t\t  hp_wmi_get_hw_state(HPWMI_BLUETOOTH));\n\t\tif (wwan_rfkill)\n\t\t\trfkill_set_states(wwan_rfkill,\n\t\t\t\t\t  hp_wmi_get_sw_state(HPWMI_WWAN),\n\t\t\t\t\t  hp_wmi_get_hw_state(HPWMI_WWAN));\n\t\tbreak;\n\tcase HPWMI_CPU_BATTERY_THROTTLE:\n\t\tpr_info(\"Unimplemented CPU throttle because of 3 Cell battery event detected\\n\");\n\t\tbreak;\n\tcase HPWMI_LOCK_SWITCH:\n\t\tbreak;\n\tcase HPWMI_LID_SWITCH:\n\t\tbreak;\n\tcase HPWMI_SCREEN_ROTATION:\n\t\tbreak;\n\tcase HPWMI_COOLSENSE_SYSTEM_MOBILE:\n\t\tbreak;\n\tcase HPWMI_COOLSENSE_SYSTEM_HOT:\n\t\tbreak;\n\tcase HPWMI_PROXIMITY_SENSOR:\n\t\tbreak;\n\tcase HPWMI_BACKLIT_KB_BRIGHTNESS:\n\t\tbreak;\n\tcase HPWMI_PEAKSHIFT_PERIOD:\n\t\tbreak;\n\tcase HPWMI_BATTERY_CHARGE_PERIOD:\n\t\tbreak;\n\tcase HPWMI_SANITIZATION_MODE:\n\t\tbreak;\n\tcase HPWMI_CAMERA_TOGGLE:\n\t\tif (!camera_shutter_input_dev)\n\t\t\tif (camera_shutter_input_setup()) {\n\t\t\t\tpr_err(\"Failed to setup camera shutter input device\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif (event_data == 0xff)\n\t\t\tinput_report_switch(camera_shutter_input_dev, SW_CAMERA_LENS_COVER, 1);\n\t\telse if (event_data == 0xfe)\n\t\t\tinput_report_switch(camera_shutter_input_dev, SW_CAMERA_LENS_COVER, 0);\n\t\telse\n\t\t\tpr_warn(\"Unknown camera shutter state - 0x%x\\n\", event_data);\n\t\tinput_sync(camera_shutter_input_dev);\n\t\tbreak;\n\tcase HPWMI_SMART_EXPERIENCE_APP:\n\t\tbreak;\n\tdefault:\n\t\tpr_info(\"Unknown event_id - %d - 0x%x\\n\", event_id, event_data);\n\t\tbreak;\n\t}\n}\n\nstatic int __init hp_wmi_input_setup(void)\n{\n\tacpi_status status;\n\tint err, val;\n\n\thp_wmi_input_dev = input_allocate_device();\n\tif (!hp_wmi_input_dev)\n\t\treturn -ENOMEM;\n\n\thp_wmi_input_dev->name = \"HP WMI hotkeys\";\n\thp_wmi_input_dev->phys = \"wmi/input0\";\n\thp_wmi_input_dev->id.bustype = BUS_HOST;\n\n\t__set_bit(EV_SW, hp_wmi_input_dev->evbit);\n\n\t \n\tval = hp_wmi_get_dock_state();\n\tif (!(val < 0)) {\n\t\t__set_bit(SW_DOCK, hp_wmi_input_dev->swbit);\n\t\tinput_report_switch(hp_wmi_input_dev, SW_DOCK, val);\n\t}\n\n\t \n\tval = hp_wmi_get_tablet_mode();\n\tif (!(val < 0)) {\n\t\t__set_bit(SW_TABLET_MODE, hp_wmi_input_dev->swbit);\n\t\tinput_report_switch(hp_wmi_input_dev, SW_TABLET_MODE, val);\n\t}\n\n\terr = sparse_keymap_setup(hp_wmi_input_dev, hp_wmi_keymap, NULL);\n\tif (err)\n\t\tgoto err_free_dev;\n\n\t \n\tinput_sync(hp_wmi_input_dev);\n\n\tif (!hp_wmi_bios_2009_later() && hp_wmi_bios_2008_later())\n\t\thp_wmi_enable_hotkeys();\n\n\tstatus = wmi_install_notify_handler(HPWMI_EVENT_GUID, hp_wmi_notify, NULL);\n\tif (ACPI_FAILURE(status)) {\n\t\terr = -EIO;\n\t\tgoto err_free_dev;\n\t}\n\n\terr = input_register_device(hp_wmi_input_dev);\n\tif (err)\n\t\tgoto err_uninstall_notifier;\n\n\treturn 0;\n\n err_uninstall_notifier:\n\twmi_remove_notify_handler(HPWMI_EVENT_GUID);\n err_free_dev:\n\tinput_free_device(hp_wmi_input_dev);\n\treturn err;\n}\n\nstatic void hp_wmi_input_destroy(void)\n{\n\twmi_remove_notify_handler(HPWMI_EVENT_GUID);\n\tinput_unregister_device(hp_wmi_input_dev);\n}\n\nstatic int __init hp_wmi_rfkill_setup(struct platform_device *device)\n{\n\tint err, wireless;\n\n\twireless = hp_wmi_read_int(HPWMI_WIRELESS_QUERY);\n\tif (wireless < 0)\n\t\treturn wireless;\n\n\terr = hp_wmi_perform_query(HPWMI_WIRELESS_QUERY, HPWMI_WRITE, &wireless,\n\t\t\t\t   sizeof(wireless), 0);\n\tif (err)\n\t\treturn err;\n\n\tif (wireless & 0x1) {\n\t\twifi_rfkill = rfkill_alloc(\"hp-wifi\", &device->dev,\n\t\t\t\t\t   RFKILL_TYPE_WLAN,\n\t\t\t\t\t   &hp_wmi_rfkill_ops,\n\t\t\t\t\t   (void *) HPWMI_WIFI);\n\t\tif (!wifi_rfkill)\n\t\t\treturn -ENOMEM;\n\t\trfkill_init_sw_state(wifi_rfkill,\n\t\t\t\t     hp_wmi_get_sw_state(HPWMI_WIFI));\n\t\trfkill_set_hw_state(wifi_rfkill,\n\t\t\t\t    hp_wmi_get_hw_state(HPWMI_WIFI));\n\t\terr = rfkill_register(wifi_rfkill);\n\t\tif (err)\n\t\t\tgoto register_wifi_error;\n\t}\n\n\tif (wireless & 0x2) {\n\t\tbluetooth_rfkill = rfkill_alloc(\"hp-bluetooth\", &device->dev,\n\t\t\t\t\t\tRFKILL_TYPE_BLUETOOTH,\n\t\t\t\t\t\t&hp_wmi_rfkill_ops,\n\t\t\t\t\t\t(void *) HPWMI_BLUETOOTH);\n\t\tif (!bluetooth_rfkill) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto register_bluetooth_error;\n\t\t}\n\t\trfkill_init_sw_state(bluetooth_rfkill,\n\t\t\t\t     hp_wmi_get_sw_state(HPWMI_BLUETOOTH));\n\t\trfkill_set_hw_state(bluetooth_rfkill,\n\t\t\t\t    hp_wmi_get_hw_state(HPWMI_BLUETOOTH));\n\t\terr = rfkill_register(bluetooth_rfkill);\n\t\tif (err)\n\t\t\tgoto register_bluetooth_error;\n\t}\n\n\tif (wireless & 0x4) {\n\t\twwan_rfkill = rfkill_alloc(\"hp-wwan\", &device->dev,\n\t\t\t\t\t   RFKILL_TYPE_WWAN,\n\t\t\t\t\t   &hp_wmi_rfkill_ops,\n\t\t\t\t\t   (void *) HPWMI_WWAN);\n\t\tif (!wwan_rfkill) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto register_wwan_error;\n\t\t}\n\t\trfkill_init_sw_state(wwan_rfkill,\n\t\t\t\t     hp_wmi_get_sw_state(HPWMI_WWAN));\n\t\trfkill_set_hw_state(wwan_rfkill,\n\t\t\t\t    hp_wmi_get_hw_state(HPWMI_WWAN));\n\t\terr = rfkill_register(wwan_rfkill);\n\t\tif (err)\n\t\t\tgoto register_wwan_error;\n\t}\n\n\treturn 0;\n\nregister_wwan_error:\n\trfkill_destroy(wwan_rfkill);\n\twwan_rfkill = NULL;\n\tif (bluetooth_rfkill)\n\t\trfkill_unregister(bluetooth_rfkill);\nregister_bluetooth_error:\n\trfkill_destroy(bluetooth_rfkill);\n\tbluetooth_rfkill = NULL;\n\tif (wifi_rfkill)\n\t\trfkill_unregister(wifi_rfkill);\nregister_wifi_error:\n\trfkill_destroy(wifi_rfkill);\n\twifi_rfkill = NULL;\n\treturn err;\n}\n\nstatic int __init hp_wmi_rfkill2_setup(struct platform_device *device)\n{\n\tstruct bios_rfkill2_state state;\n\tint err, i;\n\n\terr = hp_wmi_perform_query(HPWMI_WIRELESS2_QUERY, HPWMI_READ, &state,\n\t\t\t\t   zero_if_sup(state), sizeof(state));\n\tif (err)\n\t\treturn err < 0 ? err : -EINVAL;\n\n\tif (state.count > HPWMI_MAX_RFKILL2_DEVICES) {\n\t\tpr_warn(\"unable to parse 0x1b query output\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < state.count; i++) {\n\t\tstruct rfkill *rfkill;\n\t\tenum rfkill_type type;\n\t\tchar *name;\n\n\t\tswitch (state.device[i].radio_type) {\n\t\tcase HPWMI_WIFI:\n\t\t\ttype = RFKILL_TYPE_WLAN;\n\t\t\tname = \"hp-wifi\";\n\t\t\tbreak;\n\t\tcase HPWMI_BLUETOOTH:\n\t\t\ttype = RFKILL_TYPE_BLUETOOTH;\n\t\t\tname = \"hp-bluetooth\";\n\t\t\tbreak;\n\t\tcase HPWMI_WWAN:\n\t\t\ttype = RFKILL_TYPE_WWAN;\n\t\t\tname = \"hp-wwan\";\n\t\t\tbreak;\n\t\tcase HPWMI_GPS:\n\t\t\ttype = RFKILL_TYPE_GPS;\n\t\t\tname = \"hp-gps\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_warn(\"unknown device type 0x%x\\n\",\n\t\t\t\tstate.device[i].radio_type);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!state.device[i].vendor_id) {\n\t\t\tpr_warn(\"zero device %d while %d reported\\n\",\n\t\t\t\ti, state.count);\n\t\t\tcontinue;\n\t\t}\n\n\t\trfkill = rfkill_alloc(name, &device->dev, type,\n\t\t\t\t      &hp_wmi_rfkill2_ops, (void *)(long)i);\n\t\tif (!rfkill) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto fail;\n\t\t}\n\n\t\trfkill2[rfkill2_count].id = state.device[i].rfkill_id;\n\t\trfkill2[rfkill2_count].num = i;\n\t\trfkill2[rfkill2_count].rfkill = rfkill;\n\n\t\trfkill_init_sw_state(rfkill,\n\t\t\t\t     IS_SWBLOCKED(state.device[i].power));\n\t\trfkill_set_hw_state(rfkill,\n\t\t\t\t    IS_HWBLOCKED(state.device[i].power));\n\n\t\tif (!(state.device[i].power & HPWMI_POWER_BIOS))\n\t\t\tpr_info(\"device %s blocked by BIOS\\n\", name);\n\n\t\terr = rfkill_register(rfkill);\n\t\tif (err) {\n\t\t\trfkill_destroy(rfkill);\n\t\t\tgoto fail;\n\t\t}\n\n\t\trfkill2_count++;\n\t}\n\n\treturn 0;\nfail:\n\tfor (; rfkill2_count > 0; rfkill2_count--) {\n\t\trfkill_unregister(rfkill2[rfkill2_count - 1].rfkill);\n\t\trfkill_destroy(rfkill2[rfkill2_count - 1].rfkill);\n\t}\n\treturn err;\n}\n\nstatic int platform_profile_omen_get(struct platform_profile_handler *pprof,\n\t\t\t\t     enum platform_profile_option *profile)\n{\n\tint tp;\n\n\ttp = omen_thermal_profile_get();\n\tif (tp < 0)\n\t\treturn tp;\n\n\tswitch (tp) {\n\tcase HP_OMEN_V0_THERMAL_PROFILE_PERFORMANCE:\n\tcase HP_OMEN_V1_THERMAL_PROFILE_PERFORMANCE:\n\t\t*profile = PLATFORM_PROFILE_PERFORMANCE;\n\t\tbreak;\n\tcase HP_OMEN_V0_THERMAL_PROFILE_DEFAULT:\n\tcase HP_OMEN_V1_THERMAL_PROFILE_DEFAULT:\n\t\t*profile = PLATFORM_PROFILE_BALANCED;\n\t\tbreak;\n\tcase HP_OMEN_V0_THERMAL_PROFILE_COOL:\n\tcase HP_OMEN_V1_THERMAL_PROFILE_COOL:\n\t\t*profile = PLATFORM_PROFILE_COOL;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int platform_profile_omen_set(struct platform_profile_handler *pprof,\n\t\t\t\t     enum platform_profile_option profile)\n{\n\tint err, tp, tp_version;\n\n\ttp_version = omen_get_thermal_policy_version();\n\n\tif (tp_version < 0 || tp_version > 1)\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (profile) {\n\tcase PLATFORM_PROFILE_PERFORMANCE:\n\t\tif (tp_version == 0)\n\t\t\ttp = HP_OMEN_V0_THERMAL_PROFILE_PERFORMANCE;\n\t\telse\n\t\t\ttp = HP_OMEN_V1_THERMAL_PROFILE_PERFORMANCE;\n\t\tbreak;\n\tcase PLATFORM_PROFILE_BALANCED:\n\t\tif (tp_version == 0)\n\t\t\ttp = HP_OMEN_V0_THERMAL_PROFILE_DEFAULT;\n\t\telse\n\t\t\ttp = HP_OMEN_V1_THERMAL_PROFILE_DEFAULT;\n\t\tbreak;\n\tcase PLATFORM_PROFILE_COOL:\n\t\tif (tp_version == 0)\n\t\t\ttp = HP_OMEN_V0_THERMAL_PROFILE_COOL;\n\t\telse\n\t\t\ttp = HP_OMEN_V1_THERMAL_PROFILE_COOL;\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\terr = omen_thermal_profile_set(tp);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic int thermal_profile_get(void)\n{\n\treturn hp_wmi_read_int(HPWMI_THERMAL_PROFILE_QUERY);\n}\n\nstatic int thermal_profile_set(int thermal_profile)\n{\n\treturn hp_wmi_perform_query(HPWMI_THERMAL_PROFILE_QUERY, HPWMI_WRITE, &thermal_profile,\n\t\t\t\t\t\t\t   sizeof(thermal_profile), 0);\n}\n\nstatic int hp_wmi_platform_profile_get(struct platform_profile_handler *pprof,\n\t\t\t\t\tenum platform_profile_option *profile)\n{\n\tint tp;\n\n\ttp = thermal_profile_get();\n\tif (tp < 0)\n\t\treturn tp;\n\n\tswitch (tp) {\n\tcase HP_THERMAL_PROFILE_PERFORMANCE:\n\t\t*profile =  PLATFORM_PROFILE_PERFORMANCE;\n\t\tbreak;\n\tcase HP_THERMAL_PROFILE_DEFAULT:\n\t\t*profile =  PLATFORM_PROFILE_BALANCED;\n\t\tbreak;\n\tcase HP_THERMAL_PROFILE_COOL:\n\t\t*profile =  PLATFORM_PROFILE_COOL;\n\t\tbreak;\n\tcase HP_THERMAL_PROFILE_QUIET:\n\t\t*profile = PLATFORM_PROFILE_QUIET;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int hp_wmi_platform_profile_set(struct platform_profile_handler *pprof,\n\t\t\t\t\tenum platform_profile_option profile)\n{\n\tint err, tp;\n\n\tswitch (profile) {\n\tcase PLATFORM_PROFILE_PERFORMANCE:\n\t\ttp =  HP_THERMAL_PROFILE_PERFORMANCE;\n\t\tbreak;\n\tcase PLATFORM_PROFILE_BALANCED:\n\t\ttp =  HP_THERMAL_PROFILE_DEFAULT;\n\t\tbreak;\n\tcase PLATFORM_PROFILE_COOL:\n\t\ttp =  HP_THERMAL_PROFILE_COOL;\n\t\tbreak;\n\tcase PLATFORM_PROFILE_QUIET:\n\t\ttp = HP_THERMAL_PROFILE_QUIET;\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\terr = thermal_profile_set(tp);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic bool is_victus_thermal_profile(void)\n{\n\tconst char *board_name = dmi_get_system_info(DMI_BOARD_NAME);\n\n\tif (!board_name)\n\t\treturn false;\n\n\treturn match_string(victus_thermal_profile_boards,\n\t\t\t    ARRAY_SIZE(victus_thermal_profile_boards),\n\t\t\t    board_name) >= 0;\n}\n\nstatic int platform_profile_victus_get(struct platform_profile_handler *pprof,\n\t\t\t\t     enum platform_profile_option *profile)\n{\n\tint tp;\n\n\ttp = omen_thermal_profile_get();\n\tif (tp < 0)\n\t\treturn tp;\n\n\tswitch (tp) {\n\tcase HP_VICTUS_THERMAL_PROFILE_PERFORMANCE:\n\t\t*profile = PLATFORM_PROFILE_PERFORMANCE;\n\t\tbreak;\n\tcase HP_VICTUS_THERMAL_PROFILE_DEFAULT:\n\t\t*profile = PLATFORM_PROFILE_BALANCED;\n\t\tbreak;\n\tcase HP_VICTUS_THERMAL_PROFILE_QUIET:\n\t\t*profile = PLATFORM_PROFILE_QUIET;\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic int platform_profile_victus_set(struct platform_profile_handler *pprof,\n\t\t\t\t     enum platform_profile_option profile)\n{\n\tint err, tp;\n\n\tswitch (profile) {\n\tcase PLATFORM_PROFILE_PERFORMANCE:\n\t\ttp = HP_VICTUS_THERMAL_PROFILE_PERFORMANCE;\n\t\tbreak;\n\tcase PLATFORM_PROFILE_BALANCED:\n\t\ttp = HP_VICTUS_THERMAL_PROFILE_DEFAULT;\n\t\tbreak;\n\tcase PLATFORM_PROFILE_QUIET:\n\t\ttp = HP_VICTUS_THERMAL_PROFILE_QUIET;\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\terr = omen_thermal_profile_set(tp);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic int thermal_profile_setup(void)\n{\n\tint err, tp;\n\n\tif (is_omen_thermal_profile()) {\n\t\ttp = omen_thermal_profile_get();\n\t\tif (tp < 0)\n\t\t\treturn tp;\n\n\t\t \n\n\t\terr = omen_thermal_profile_set(tp);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tplatform_profile_handler.profile_get = platform_profile_omen_get;\n\t\tplatform_profile_handler.profile_set = platform_profile_omen_set;\n\n\t\tset_bit(PLATFORM_PROFILE_COOL, platform_profile_handler.choices);\n\t} else if (is_victus_thermal_profile()) {\n\t\ttp = omen_thermal_profile_get();\n\t\tif (tp < 0)\n\t\t\treturn tp;\n\n\t\t \n\t\terr = omen_thermal_profile_set(tp);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tplatform_profile_handler.profile_get = platform_profile_victus_get;\n\t\tplatform_profile_handler.profile_set = platform_profile_victus_set;\n\n\t\tset_bit(PLATFORM_PROFILE_QUIET, platform_profile_handler.choices);\n\t} else {\n\t\ttp = thermal_profile_get();\n\n\t\tif (tp < 0)\n\t\t\treturn tp;\n\n\t\t \n\t\terr = thermal_profile_set(tp);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tplatform_profile_handler.profile_get = hp_wmi_platform_profile_get;\n\t\tplatform_profile_handler.profile_set = hp_wmi_platform_profile_set;\n\n\t\tset_bit(PLATFORM_PROFILE_QUIET, platform_profile_handler.choices);\n\t\tset_bit(PLATFORM_PROFILE_COOL, platform_profile_handler.choices);\n\t}\n\n\tset_bit(PLATFORM_PROFILE_BALANCED, platform_profile_handler.choices);\n\tset_bit(PLATFORM_PROFILE_PERFORMANCE, platform_profile_handler.choices);\n\n\terr = platform_profile_register(&platform_profile_handler);\n\tif (err)\n\t\treturn err;\n\n\tplatform_profile_support = true;\n\n\treturn 0;\n}\n\nstatic int hp_wmi_hwmon_init(void);\n\nstatic int __init hp_wmi_bios_setup(struct platform_device *device)\n{\n\tint err;\n\t \n\twifi_rfkill = NULL;\n\tbluetooth_rfkill = NULL;\n\twwan_rfkill = NULL;\n\trfkill2_count = 0;\n\n\t \n\tif (!hp_wmi_bios_2009_later()) {\n\t\tif (hp_wmi_rfkill_setup(device))\n\t\t\thp_wmi_rfkill2_setup(device);\n\t}\n\n\terr = hp_wmi_hwmon_init();\n\n\tif (err < 0)\n\t\treturn err;\n\n\tthermal_profile_setup();\n\n\treturn 0;\n}\n\nstatic int __exit hp_wmi_bios_remove(struct platform_device *device)\n{\n\tint i;\n\n\tfor (i = 0; i < rfkill2_count; i++) {\n\t\trfkill_unregister(rfkill2[i].rfkill);\n\t\trfkill_destroy(rfkill2[i].rfkill);\n\t}\n\n\tif (wifi_rfkill) {\n\t\trfkill_unregister(wifi_rfkill);\n\t\trfkill_destroy(wifi_rfkill);\n\t}\n\tif (bluetooth_rfkill) {\n\t\trfkill_unregister(bluetooth_rfkill);\n\t\trfkill_destroy(bluetooth_rfkill);\n\t}\n\tif (wwan_rfkill) {\n\t\trfkill_unregister(wwan_rfkill);\n\t\trfkill_destroy(wwan_rfkill);\n\t}\n\n\tif (platform_profile_support)\n\t\tplatform_profile_remove();\n\n\treturn 0;\n}\n\nstatic int hp_wmi_resume_handler(struct device *device)\n{\n\t \n\tif (hp_wmi_input_dev) {\n\t\tif (test_bit(SW_DOCK, hp_wmi_input_dev->swbit))\n\t\t\tinput_report_switch(hp_wmi_input_dev, SW_DOCK,\n\t\t\t\t\t    hp_wmi_get_dock_state());\n\t\tif (test_bit(SW_TABLET_MODE, hp_wmi_input_dev->swbit))\n\t\t\tinput_report_switch(hp_wmi_input_dev, SW_TABLET_MODE,\n\t\t\t\t\t    hp_wmi_get_tablet_mode());\n\t\tinput_sync(hp_wmi_input_dev);\n\t}\n\n\tif (rfkill2_count)\n\t\thp_wmi_rfkill2_refresh();\n\n\tif (wifi_rfkill)\n\t\trfkill_set_states(wifi_rfkill,\n\t\t\t\t  hp_wmi_get_sw_state(HPWMI_WIFI),\n\t\t\t\t  hp_wmi_get_hw_state(HPWMI_WIFI));\n\tif (bluetooth_rfkill)\n\t\trfkill_set_states(bluetooth_rfkill,\n\t\t\t\t  hp_wmi_get_sw_state(HPWMI_BLUETOOTH),\n\t\t\t\t  hp_wmi_get_hw_state(HPWMI_BLUETOOTH));\n\tif (wwan_rfkill)\n\t\trfkill_set_states(wwan_rfkill,\n\t\t\t\t  hp_wmi_get_sw_state(HPWMI_WWAN),\n\t\t\t\t  hp_wmi_get_hw_state(HPWMI_WWAN));\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops hp_wmi_pm_ops = {\n\t.resume  = hp_wmi_resume_handler,\n\t.restore  = hp_wmi_resume_handler,\n};\n\n \nstatic struct platform_driver hp_wmi_driver __refdata = {\n\t.driver = {\n\t\t.name = \"hp-wmi\",\n\t\t.pm = &hp_wmi_pm_ops,\n\t\t.dev_groups = hp_wmi_groups,\n\t},\n\t.remove = __exit_p(hp_wmi_bios_remove),\n};\n\nstatic umode_t hp_wmi_hwmon_is_visible(const void *data,\n\t\t\t\t       enum hwmon_sensor_types type,\n\t\t\t\t       u32 attr, int channel)\n{\n\tswitch (type) {\n\tcase hwmon_pwm:\n\t\treturn 0644;\n\tcase hwmon_fan:\n\t\tif (hp_wmi_get_fan_speed(channel) >= 0)\n\t\t\treturn 0444;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\treturn 0;\n}\n\nstatic int hp_wmi_hwmon_read(struct device *dev, enum hwmon_sensor_types type,\n\t\t\t     u32 attr, int channel, long *val)\n{\n\tint ret;\n\n\tswitch (type) {\n\tcase hwmon_fan:\n\t\tret = hp_wmi_get_fan_speed(channel);\n\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\t*val = ret;\n\t\treturn 0;\n\tcase hwmon_pwm:\n\t\tswitch (hp_wmi_fan_speed_max_get()) {\n\t\tcase 0:\n\t\t\t \n\t\t\t*val = 2;\n\t\t\treturn 0;\n\t\tcase 1:\n\t\t\t \n\t\t\t*val = 0;\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\t \n\t\t\treturn -ENODATA;\n\t\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int hp_wmi_hwmon_write(struct device *dev, enum hwmon_sensor_types type,\n\t\t\t      u32 attr, int channel, long val)\n{\n\tswitch (type) {\n\tcase hwmon_pwm:\n\t\tswitch (val) {\n\t\tcase 0:\n\t\t\t \n\t\t\treturn hp_wmi_fan_speed_max_set(1);\n\t\tcase 2:\n\t\t\t \n\t\t\treturn hp_wmi_fan_speed_max_set(0);\n\t\tdefault:\n\t\t\t \n\t\t\treturn -EINVAL;\n\t\t}\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic const struct hwmon_channel_info * const info[] = {\n\tHWMON_CHANNEL_INFO(fan, HWMON_F_INPUT, HWMON_F_INPUT),\n\tHWMON_CHANNEL_INFO(pwm, HWMON_PWM_ENABLE),\n\tNULL\n};\n\nstatic const struct hwmon_ops ops = {\n\t.is_visible = hp_wmi_hwmon_is_visible,\n\t.read = hp_wmi_hwmon_read,\n\t.write = hp_wmi_hwmon_write,\n};\n\nstatic const struct hwmon_chip_info chip_info = {\n\t.ops = &ops,\n\t.info = info,\n};\n\nstatic int hp_wmi_hwmon_init(void)\n{\n\tstruct device *dev = &hp_wmi_platform_dev->dev;\n\tstruct device *hwmon;\n\n\thwmon = devm_hwmon_device_register_with_info(dev, \"hp\", &hp_wmi_driver,\n\t\t\t\t\t\t     &chip_info, NULL);\n\n\tif (IS_ERR(hwmon)) {\n\t\tdev_err(dev, \"Could not register hp hwmon device\\n\");\n\t\treturn PTR_ERR(hwmon);\n\t}\n\n\treturn 0;\n}\n\nstatic int __init hp_wmi_init(void)\n{\n\tint event_capable = wmi_has_guid(HPWMI_EVENT_GUID);\n\tint bios_capable = wmi_has_guid(HPWMI_BIOS_GUID);\n\tint err, tmp = 0;\n\n\tif (!bios_capable && !event_capable)\n\t\treturn -ENODEV;\n\n\tif (hp_wmi_perform_query(HPWMI_HARDWARE_QUERY, HPWMI_READ, &tmp,\n\t\t\t\t sizeof(tmp), sizeof(tmp)) == HPWMI_RET_INVALID_PARAMETERS)\n\t\tzero_insize_support = true;\n\n\tif (event_capable) {\n\t\terr = hp_wmi_input_setup();\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (bios_capable) {\n\t\thp_wmi_platform_dev =\n\t\t\tplatform_device_register_simple(\"hp-wmi\", PLATFORM_DEVID_NONE, NULL, 0);\n\t\tif (IS_ERR(hp_wmi_platform_dev)) {\n\t\t\terr = PTR_ERR(hp_wmi_platform_dev);\n\t\t\tgoto err_destroy_input;\n\t\t}\n\n\t\terr = platform_driver_probe(&hp_wmi_driver, hp_wmi_bios_setup);\n\t\tif (err)\n\t\t\tgoto err_unregister_device;\n\t}\n\n\treturn 0;\n\nerr_unregister_device:\n\tplatform_device_unregister(hp_wmi_platform_dev);\nerr_destroy_input:\n\tif (event_capable)\n\t\thp_wmi_input_destroy();\n\n\treturn err;\n}\nmodule_init(hp_wmi_init);\n\nstatic void __exit hp_wmi_exit(void)\n{\n\tif (wmi_has_guid(HPWMI_EVENT_GUID))\n\t\thp_wmi_input_destroy();\n\n\tif (camera_shutter_input_dev)\n\t\tinput_unregister_device(camera_shutter_input_dev);\n\n\tif (hp_wmi_platform_dev) {\n\t\tplatform_device_unregister(hp_wmi_platform_dev);\n\t\tplatform_driver_unregister(&hp_wmi_driver);\n\t}\n}\nmodule_exit(hp_wmi_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}