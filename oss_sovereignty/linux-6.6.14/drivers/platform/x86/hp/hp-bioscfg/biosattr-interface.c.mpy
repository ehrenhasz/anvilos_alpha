{
  "module_name": "biosattr-interface.c",
  "hash_id": "e0a56c4b1811a643a4425c743ab584e0163e189645c80794e360c0aab4de2f95",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/x86/hp/hp-bioscfg/biosattr-interface.c",
  "human_readable_source": "\n \n\n#include <linux/wmi.h>\n#include \"bioscfg.h\"\n\n \nstruct bios_args {\n\tu32 signature;\n\tu32 command;\n\tu32 commandtype;\n\tu32 datasize;\n\tu8 data[];\n};\n\n \nint hp_set_attribute(const char *a_name, const char *a_value)\n{\n\tint security_area_size;\n\tint a_name_size, a_value_size;\n\tu16 *buffer = NULL;\n\tu16 *start;\n\tint  buffer_size, instance, ret;\n\tchar *auth_token_choice;\n\n\tmutex_lock(&bioscfg_drv.mutex);\n\n\tinstance = hp_get_password_instance_for_type(SETUP_PASSWD);\n\tif (instance < 0) {\n\t\tret = -EINVAL;\n\t\tgoto out_set_attribute;\n\t}\n\n\t \n\tif (bioscfg_drv.spm_data.auth_token)\n\t\tauth_token_choice = bioscfg_drv.spm_data.auth_token;\n\telse\n\t\tauth_token_choice = bioscfg_drv.password_data[instance].current_password;\n\n\ta_name_size = hp_calculate_string_buffer(a_name);\n\ta_value_size = hp_calculate_string_buffer(a_value);\n\tsecurity_area_size = hp_calculate_security_buffer(auth_token_choice);\n\tbuffer_size = a_name_size + a_value_size + security_area_size;\n\n\tbuffer = kmalloc(buffer_size + 1, GFP_KERNEL);\n\tif (!buffer) {\n\t\tret = -ENOMEM;\n\t\tgoto out_set_attribute;\n\t}\n\n\t \n\tstart = buffer;\n\tstart = hp_ascii_to_utf16_unicode(start, a_name);\n\tif (!start) {\n\t\tret = -EINVAL;\n\t\tgoto out_set_attribute;\n\t}\n\n\tstart = hp_ascii_to_utf16_unicode(start, a_value);\n\tif (!start) {\n\t\tret = -EINVAL;\n\t\tgoto out_set_attribute;\n\t}\n\n\tret = hp_populate_security_buffer(start, auth_token_choice);\n\tif (ret < 0)\n\t\tgoto out_set_attribute;\n\n\tret = hp_wmi_set_bios_setting(buffer, buffer_size);\n\nout_set_attribute:\n\tkfree(buffer);\n\tmutex_unlock(&bioscfg_drv.mutex);\n\treturn ret;\n}\n\n \nint hp_wmi_perform_query(int query, enum hp_wmi_command command, void *buffer,\n\t\t\t u32 insize, u32 outsize)\n{\n\tstruct acpi_buffer input, output = { ACPI_ALLOCATE_BUFFER, NULL };\n\tstruct bios_return *bios_return;\n\tunion acpi_object *obj = NULL;\n\tstruct bios_args *args = NULL;\n\tint mid, actual_outsize, ret;\n\tsize_t bios_args_size;\n\n\tmid = hp_encode_outsize_for_pvsz(outsize);\n\tif (WARN_ON(mid < 0))\n\t\treturn mid;\n\n\tbios_args_size = struct_size(args, data, insize);\n\targs = kmalloc(bios_args_size, GFP_KERNEL);\n\tif (!args)\n\t\treturn -ENOMEM;\n\n\tinput.length = bios_args_size;\n\tinput.pointer = args;\n\n\t \n\targs->signature = 0x55434553;\n\targs->command = command;\n\targs->commandtype = query;\n\targs->datasize = insize;\n\tmemcpy(args->data, buffer, flex_array_size(args, data, insize));\n\n\tret = wmi_evaluate_method(HP_WMI_BIOS_GUID, 0, mid, &input, &output);\n\tif (ret)\n\t\tgoto out_free;\n\n\tobj = output.pointer;\n\tif (!obj) {\n\t\tret = -EINVAL;\n\t\tgoto out_free;\n\t}\n\n\tif (obj->type != ACPI_TYPE_BUFFER ||\n\t    obj->buffer.length < sizeof(*bios_return)) {\n\t\tpr_warn(\"query 0x%x returned wrong type or too small buffer\\n\", query);\n\t\tret = -EINVAL;\n\t\tgoto out_free;\n\t}\n\n\tbios_return = (struct bios_return *)obj->buffer.pointer;\n\tret = bios_return->return_code;\n\tif (ret) {\n\t\tif (ret != INVALID_CMD_VALUE && ret != INVALID_CMD_TYPE)\n\t\t\tpr_warn(\"query 0x%x returned error 0x%x\\n\", query, ret);\n\t\tgoto out_free;\n\t}\n\n\t \n\tif (!outsize)\n\t\tgoto out_free;\n\n\tactual_outsize = min_t(u32, outsize, obj->buffer.length - sizeof(*bios_return));\n\tmemcpy_and_pad(buffer, outsize, obj->buffer.pointer + sizeof(*bios_return),\n\t\t       actual_outsize, 0);\n\nout_free:\n\tret = hp_wmi_error_and_message(ret);\n\n\tkfree(obj);\n\tkfree(args);\n\treturn ret;\n}\n\nstatic void *utf16_empty_string(u16 *p)\n{\n\t*p++ = 2;\n\t*p++ = 0x00;\n\treturn p;\n}\n\n \nvoid *hp_ascii_to_utf16_unicode(u16 *p, const u8 *str)\n{\n\tint len = strlen(str);\n\tint ret;\n\n\t \n\tif (len == 0)\n\t\treturn utf16_empty_string(p);\n\n\t \n\t*p++ = len * 2;\n\tret = utf8s_to_utf16s(str, strlen(str), UTF16_HOST_ENDIAN, p, len);\n\tif (ret < 0) {\n\t\tdev_err(bioscfg_drv.class_dev, \"UTF16 conversion failed\\n\");\n\t\treturn NULL;\n\t}\n\n\tif (ret * sizeof(u16) > U16_MAX) {\n\t\tdev_err(bioscfg_drv.class_dev, \"Error string too long\\n\");\n\t\treturn NULL;\n\t}\n\n\tp += len;\n\treturn p;\n}\n\n \nint hp_wmi_set_bios_setting(u16 *input_buffer, u32 input_size)\n{\n\tunion acpi_object *obj;\n\tstruct acpi_buffer input = {input_size, input_buffer};\n\tstruct acpi_buffer output = {ACPI_ALLOCATE_BUFFER, NULL};\n\tint ret;\n\n\tret = wmi_evaluate_method(HP_WMI_SET_BIOS_SETTING_GUID, 0, 1, &input, &output);\n\n\tobj = output.pointer;\n\tif (!obj)\n\t\treturn -EINVAL;\n\n\tif (obj->type != ACPI_TYPE_INTEGER) {\n\t\tret = -EINVAL;\n\t\tgoto out_free;\n\t}\n\n\tret = obj->integer.value;\n\tif (ret) {\n\t\tret = hp_wmi_error_and_message(ret);\n\t\tgoto out_free;\n\t}\n\nout_free:\n\tkfree(obj);\n\treturn ret;\n}\n\nstatic int hp_attr_set_interface_probe(struct wmi_device *wdev, const void *context)\n{\n\tmutex_lock(&bioscfg_drv.mutex);\n\tmutex_unlock(&bioscfg_drv.mutex);\n\treturn 0;\n}\n\nstatic void hp_attr_set_interface_remove(struct wmi_device *wdev)\n{\n\tmutex_lock(&bioscfg_drv.mutex);\n\tmutex_unlock(&bioscfg_drv.mutex);\n}\n\nstatic const struct wmi_device_id hp_attr_set_interface_id_table[] = {\n\t{ .guid_string = HP_WMI_BIOS_GUID},\n\t{ }\n};\n\nstatic struct wmi_driver hp_attr_set_interface_driver = {\n\t.driver = {\n\t\t.name = DRIVER_NAME,\n\t},\n\t.probe = hp_attr_set_interface_probe,\n\t.remove = hp_attr_set_interface_remove,\n\t.id_table = hp_attr_set_interface_id_table,\n};\n\nint hp_init_attr_set_interface(void)\n{\n\treturn wmi_driver_register(&hp_attr_set_interface_driver);\n}\n\nvoid hp_exit_attr_set_interface(void)\n{\n\twmi_driver_unregister(&hp_attr_set_interface_driver);\n}\n\nMODULE_DEVICE_TABLE(wmi, hp_attr_set_interface_id_table);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}