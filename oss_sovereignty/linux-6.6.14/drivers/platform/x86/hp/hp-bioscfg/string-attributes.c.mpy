{
  "module_name": "string-attributes.c",
  "hash_id": "6fc25b3fa29fbbb4c45898325b7ab453999d6ab6b5fd2e944978be45926a1760",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/x86/hp/hp-bioscfg/string-attributes.c",
  "human_readable_source": "\n \n\n#include \"bioscfg.h\"\n\n#define WMI_STRING_TYPE \"HPBIOS_BIOSString\"\n\nGET_INSTANCE_ID(string);\n\nstatic ssize_t current_value_show(struct kobject *kobj, struct kobj_attribute *attr, char *buf)\n{\n\tint instance_id = get_string_instance_id(kobj);\n\n\tif (instance_id < 0)\n\t\treturn -EIO;\n\n\treturn  sysfs_emit(buf, \"%s\\n\",\n\t\t\t bioscfg_drv.string_data[instance_id].current_value);\n}\n\n \nstatic int validate_string_input(int instance_id, const char *buf)\n{\n\tint in_len = strlen(buf);\n\tstruct string_data *string_data = &bioscfg_drv.string_data[instance_id];\n\n\t \n\tif (string_data->common.is_readonly)\n\t\treturn -EIO;\n\n\tif (in_len < string_data->min_length || in_len > string_data->max_length)\n\t\treturn -ERANGE;\n\n\treturn 0;\n}\n\nstatic void update_string_value(int instance_id, char *attr_value)\n{\n\tstruct string_data *string_data = &bioscfg_drv.string_data[instance_id];\n\n\t \n\tstrscpy(string_data->current_value, attr_value, sizeof(string_data->current_value));\n}\n\n \n\nATTRIBUTE_S_COMMON_PROPERTY_SHOW(display_name, string);\nstatic struct kobj_attribute string_display_name =\n\t__ATTR_RO(display_name);\n\nATTRIBUTE_PROPERTY_STORE(current_value, string);\nstatic struct kobj_attribute string_current_val =\n\t__ATTR_RW_MODE(current_value, 0644);\n\nATTRIBUTE_N_PROPERTY_SHOW(min_length, string);\nstatic struct kobj_attribute string_min_length =\n\t__ATTR_RO(min_length);\n\nATTRIBUTE_N_PROPERTY_SHOW(max_length, string);\nstatic struct kobj_attribute string_max_length =\n\t__ATTR_RO(max_length);\n\nstatic ssize_t type_show(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t char *buf)\n{\n\treturn sysfs_emit(buf, \"string\\n\");\n}\n\nstatic struct kobj_attribute string_type =\n\t__ATTR_RO(type);\n\nstatic struct attribute *string_attrs[] = {\n\t&common_display_langcode.attr,\n\t&string_display_name.attr,\n\t&string_current_val.attr,\n\t&string_min_length.attr,\n\t&string_max_length.attr,\n\t&string_type.attr,\n\tNULL\n};\n\nstatic const struct attribute_group string_attr_group = {\n\t.attrs = string_attrs,\n};\n\nint hp_alloc_string_data(void)\n{\n\tbioscfg_drv.string_instances_count = hp_get_instance_count(HP_WMI_BIOS_STRING_GUID);\n\tbioscfg_drv.string_data = kcalloc(bioscfg_drv.string_instances_count,\n\t\t\t\t\t  sizeof(*bioscfg_drv.string_data), GFP_KERNEL);\n\tif (!bioscfg_drv.string_data) {\n\t\tbioscfg_drv.string_instances_count = 0;\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}\n\n \nstatic const acpi_object_type expected_string_types[] = {\n\t[NAME] = ACPI_TYPE_STRING,\n\t[VALUE] = ACPI_TYPE_STRING,\n\t[PATH] = ACPI_TYPE_STRING,\n\t[IS_READONLY] = ACPI_TYPE_INTEGER,\n\t[DISPLAY_IN_UI] = ACPI_TYPE_INTEGER,\n\t[REQUIRES_PHYSICAL_PRESENCE] = ACPI_TYPE_INTEGER,\n\t[SEQUENCE] = ACPI_TYPE_INTEGER,\n\t[PREREQUISITES_SIZE] = ACPI_TYPE_INTEGER,\n\t[PREREQUISITES] = ACPI_TYPE_STRING,\n\t[SECURITY_LEVEL] = ACPI_TYPE_INTEGER,\n\t[STR_MIN_LENGTH] = ACPI_TYPE_INTEGER,\n\t[STR_MAX_LENGTH] = ACPI_TYPE_INTEGER,\n};\n\nstatic int hp_populate_string_elements_from_package(union acpi_object *string_obj,\n\t\t\t\t\t\t    int string_obj_count,\n\t\t\t\t\t\t    int instance_id)\n{\n\tchar *str_value = NULL;\n\tint value_len;\n\tint ret = 0;\n\tu32 int_value = 0;\n\tint elem;\n\tint reqs;\n\tint eloc;\n\tint size;\n\tstruct string_data *string_data = &bioscfg_drv.string_data[instance_id];\n\n\tif (!string_obj)\n\t\treturn -EINVAL;\n\n\tfor (elem = 1, eloc = 1; elem < string_obj_count; elem++, eloc++) {\n\t\t \n\t\tif (eloc == STR_ELEM_CNT)\n\t\t\tgoto exit_string_package;\n\n\t\tswitch (string_obj[elem].type) {\n\t\tcase ACPI_TYPE_STRING:\n\t\t\tif (elem != PREREQUISITES) {\n\t\t\t\tret = hp_convert_hexstr_to_str(string_obj[elem].string.pointer,\n\t\t\t\t\t\t\t       string_obj[elem].string.length,\n\t\t\t\t\t\t\t       &str_value, &value_len);\n\n\t\t\t\tif (ret)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ACPI_TYPE_INTEGER:\n\t\t\tint_value = (u32)string_obj[elem].integer.value;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_warn(\"Unsupported object type [%d]\\n\", string_obj[elem].type);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (expected_string_types[eloc] != string_obj[elem].type) {\n\t\t\tpr_err(\"Error expected type %d for elem %d, but got type %d instead\\n\",\n\t\t\t       expected_string_types[eloc], elem, string_obj[elem].type);\n\t\t\tkfree(str_value);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\t \n\t\tswitch (eloc) {\n\t\tcase VALUE:\n\t\t\tstrscpy(string_data->current_value,\n\t\t\t\tstr_value, sizeof(string_data->current_value));\n\t\t\tbreak;\n\t\tcase PATH:\n\t\t\tstrscpy(string_data->common.path, str_value,\n\t\t\t\tsizeof(string_data->common.path));\n\t\t\tbreak;\n\t\tcase IS_READONLY:\n\t\t\tstring_data->common.is_readonly = int_value;\n\t\t\tbreak;\n\t\tcase DISPLAY_IN_UI:\n\t\t\tstring_data->common.display_in_ui = int_value;\n\t\t\tbreak;\n\t\tcase REQUIRES_PHYSICAL_PRESENCE:\n\t\t\tstring_data->common.requires_physical_presence = int_value;\n\t\t\tbreak;\n\t\tcase SEQUENCE:\n\t\t\tstring_data->common.sequence = int_value;\n\t\t\tbreak;\n\t\tcase PREREQUISITES_SIZE:\n\t\t\tif (int_value > MAX_PREREQUISITES_SIZE) {\n\t\t\t\tpr_warn(\"Prerequisites size value exceeded the maximum number of elements supported or data may be malformed\\n\");\n\t\t\t\tint_value = MAX_PREREQUISITES_SIZE;\n\t\t\t}\n\t\t\tstring_data->common.prerequisites_size = int_value;\n\n\t\t\t \n\t\t\tif (string_data->common.prerequisites_size == 0)\n\t\t\t\teloc++;\n\t\t\tbreak;\n\t\tcase PREREQUISITES:\n\t\t\tsize = min_t(u32, string_data->common.prerequisites_size,\n\t\t\t\t     MAX_PREREQUISITES_SIZE);\n\n\t\t\tfor (reqs = 0; reqs < size; reqs++) {\n\t\t\t\tif (elem >= string_obj_count) {\n\t\t\t\t\tpr_err(\"Error elem-objects package is too small\\n\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\n\t\t\t\tret = hp_convert_hexstr_to_str(string_obj[elem + reqs].string.pointer,\n\t\t\t\t\t\t\t       string_obj[elem + reqs].string.length,\n\t\t\t\t\t\t\t       &str_value, &value_len);\n\n\t\t\t\tif (ret)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tstrscpy(string_data->common.prerequisites[reqs],\n\t\t\t\t\tstr_value,\n\t\t\t\t\tsizeof(string_data->common.prerequisites[reqs]));\n\t\t\t\tkfree(str_value);\n\t\t\t\tstr_value = NULL;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase SECURITY_LEVEL:\n\t\t\tstring_data->common.security_level = int_value;\n\t\t\tbreak;\n\t\tcase STR_MIN_LENGTH:\n\t\t\tstring_data->min_length = int_value;\n\t\t\tbreak;\n\t\tcase STR_MAX_LENGTH:\n\t\t\tstring_data->max_length = int_value;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_warn(\"Invalid element: %d found in String attribute or data may be malformed\\n\", elem);\n\t\t\tbreak;\n\t\t}\n\n\t\tkfree(str_value);\n\t\tstr_value = NULL;\n\t}\n\nexit_string_package:\n\tkfree(str_value);\n\treturn 0;\n}\n\n \nint hp_populate_string_package_data(union acpi_object *string_obj,\n\t\t\t\t    int instance_id,\n\t\t\t\t    struct kobject *attr_name_kobj)\n{\n\tstruct string_data *string_data = &bioscfg_drv.string_data[instance_id];\n\n\tstring_data->attr_name_kobj = attr_name_kobj;\n\n\thp_populate_string_elements_from_package(string_obj,\n\t\t\t\t\t\t string_obj->package.count,\n\t\t\t\t\t\t instance_id);\n\n\thp_update_attribute_permissions(string_data->common.is_readonly,\n\t\t\t\t\t&string_current_val);\n\thp_friendly_user_name_update(string_data->common.path,\n\t\t\t\t     attr_name_kobj->name,\n\t\t\t\t     string_data->common.display_name,\n\t\t\t\t     sizeof(string_data->common.display_name));\n\treturn sysfs_create_group(attr_name_kobj, &string_attr_group);\n}\n\nstatic int hp_populate_string_elements_from_buffer(u8 *buffer_ptr, u32 *buffer_size,\n\t\t\t\t\t\t   int instance_id)\n{\n\tint ret = 0;\n\tstruct string_data *string_data = &bioscfg_drv.string_data[instance_id];\n\n\t \n\n\t\n\tret = hp_get_string_from_buffer(&buffer_ptr, buffer_size, string_data->current_value,\n\t\t\t\t\tsizeof(string_data->current_value));\n\tif (ret < 0)\n\t\tgoto buffer_exit;\n\n\t\n\tret = hp_get_common_data_from_buffer(&buffer_ptr, buffer_size, &string_data->common);\n\tif (ret < 0)\n\t\tgoto buffer_exit;\n\n\t\n\tret = hp_get_integer_from_buffer(&buffer_ptr, buffer_size,\n\t\t\t\t\t &string_data->min_length);\n\tif (ret < 0)\n\t\tgoto buffer_exit;\n\n\t\n\tret = hp_get_integer_from_buffer(&buffer_ptr, buffer_size,\n\t\t\t\t\t &string_data->max_length);\n\nbuffer_exit:\n\n\treturn ret;\n}\n\n \nint hp_populate_string_buffer_data(u8 *buffer_ptr, u32 *buffer_size,\n\t\t\t\t   int instance_id,\n\t\t\t\t   struct kobject *attr_name_kobj)\n{\n\tstruct string_data *string_data = &bioscfg_drv.string_data[instance_id];\n\tint ret = 0;\n\n\tstring_data->attr_name_kobj = attr_name_kobj;\n\n\tret = hp_populate_string_elements_from_buffer(buffer_ptr, buffer_size,\n\t\t\t\t\t\t      instance_id);\n\tif (ret < 0)\n\t\treturn ret;\n\n\thp_update_attribute_permissions(string_data->common.is_readonly,\n\t\t\t\t\t&string_current_val);\n\thp_friendly_user_name_update(string_data->common.path,\n\t\t\t\t     attr_name_kobj->name,\n\t\t\t\t     string_data->common.display_name,\n\t\t\t\t     sizeof(string_data->common.display_name));\n\n\treturn sysfs_create_group(attr_name_kobj, &string_attr_group);\n}\n\n \nvoid hp_exit_string_attributes(void)\n{\n\tint instance_id;\n\n\tfor (instance_id = 0; instance_id < bioscfg_drv.string_instances_count;\n\t     instance_id++) {\n\t\tstruct kobject *attr_name_kobj =\n\t\t\tbioscfg_drv.string_data[instance_id].attr_name_kobj;\n\n\t\tif (attr_name_kobj)\n\t\t\tsysfs_remove_group(attr_name_kobj, &string_attr_group);\n\t}\n\tbioscfg_drv.string_instances_count = 0;\n\n\tkfree(bioscfg_drv.string_data);\n\tbioscfg_drv.string_data = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}