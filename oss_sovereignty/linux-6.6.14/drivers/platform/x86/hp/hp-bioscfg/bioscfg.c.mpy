{
  "module_name": "bioscfg.c",
  "hash_id": "bd5e417625bbf221faa2328f415e6086776b6d95b7dacc17db7cc7560b8e1fd4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/x86/hp/hp-bioscfg/bioscfg.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/wmi.h>\n#include \"bioscfg.h\"\n#include \"../../firmware_attributes_class.h\"\n#include <linux/nls.h>\n#include <linux/errno.h>\n\nMODULE_AUTHOR(\"Jorge Lopez <jorge.lopez2@hp.com>\");\nMODULE_DESCRIPTION(\"HP BIOS Configuration Driver\");\nMODULE_LICENSE(\"GPL\");\n\nstruct bioscfg_priv bioscfg_drv = {\n\t.mutex = __MUTEX_INITIALIZER(bioscfg_drv.mutex),\n};\n\nstatic struct class *fw_attr_class;\n\nssize_t display_name_language_code_show(struct kobject *kobj,\n\t\t\t\t\tstruct kobj_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\treturn sysfs_emit(buf, \"%s\\n\", LANG_CODE_STR);\n}\n\nstruct kobj_attribute common_display_langcode =\n\t__ATTR_RO(display_name_language_code);\n\nint hp_get_integer_from_buffer(u8 **buffer, u32 *buffer_size, u32 *integer)\n{\n\tint *ptr = PTR_ALIGN((int *)*buffer, sizeof(int));\n\n\t \n\tif (*buffer_size < sizeof(int))\n\t\treturn -EINVAL;\n\n\t*integer = *(ptr++);\n\t*buffer = (u8 *)ptr;\n\t*buffer_size -= sizeof(int);\n\n\treturn 0;\n}\n\nint hp_get_string_from_buffer(u8 **buffer, u32 *buffer_size, char *dst, u32 dst_size)\n{\n\tu16 *src = (u16 *)*buffer;\n\tu16 src_size;\n\n\tu16 size;\n\tint i;\n\tint conv_dst_size;\n\n\tif (*buffer_size < sizeof(u16))\n\t\treturn -EINVAL;\n\n\tsrc_size = *(src++);\n\t \n\tsize = src_size / sizeof(u16);\n\n\t \n\tif (*buffer_size < src_size)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < size; i++)\n\t\tif (src[i] == '\\\\' ||\n\t\t    src[i] == '\\r' ||\n\t\t    src[i] == '\\n' ||\n\t\t    src[i] == '\\t')\n\t\t\tsize++;\n\n\t \n\tconv_dst_size = size;\n\tif (size > dst_size)\n\t\tconv_dst_size = dst_size - 1;\n\n\t \n\tutf16s_to_utf8s(src, src_size, UTF16_HOST_ENDIAN, dst, conv_dst_size);\n\tdst[conv_dst_size] = 0;\n\n\tfor (i = 0; i < conv_dst_size; i++) {\n\t\tif (*src == '\\\\' ||\n\t\t    *src == '\\r' ||\n\t\t    *src == '\\n' ||\n\t\t    *src == '\\t') {\n\t\t\tdst[i++] = '\\\\';\n\t\t\tif (i == conv_dst_size)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (*src == '\\r')\n\t\t\tdst[i] = 'r';\n\t\telse if (*src == '\\n')\n\t\t\tdst[i] = 'n';\n\t\telse if (*src == '\\t')\n\t\t\tdst[i] = 't';\n\t\telse if (*src == '\"')\n\t\t\tdst[i] = '\\'';\n\t\telse\n\t\t\tdst[i] = *src;\n\t\tsrc++;\n\t}\n\n\t*buffer = (u8 *)src;\n\t*buffer_size -= size * sizeof(u16);\n\n\treturn size;\n}\n\nint hp_get_common_data_from_buffer(u8 **buffer_ptr, u32 *buffer_size,\n\t\t\t\t   struct common_data *common_data)\n{\n\tint ret = 0;\n\tint reqs;\n\n\t\n\tret = hp_get_string_from_buffer(buffer_ptr, buffer_size, common_data->path,\n\t\t\t\t\tsizeof(common_data->path));\n\tif (ret < 0)\n\t\tgoto common_exit;\n\n\t\n\tret = hp_get_integer_from_buffer(buffer_ptr, buffer_size,\n\t\t\t\t\t &common_data->is_readonly);\n\tif (ret < 0)\n\t\tgoto common_exit;\n\n\t\n\tret = hp_get_integer_from_buffer(buffer_ptr, buffer_size,\n\t\t\t\t\t &common_data->display_in_ui);\n\tif (ret < 0)\n\t\tgoto common_exit;\n\n\t\n\tret = hp_get_integer_from_buffer(buffer_ptr, buffer_size,\n\t\t\t\t\t &common_data->requires_physical_presence);\n\tif (ret < 0)\n\t\tgoto common_exit;\n\n\t\n\tret = hp_get_integer_from_buffer(buffer_ptr, buffer_size,\n\t\t\t\t\t &common_data->sequence);\n\tif (ret < 0)\n\t\tgoto common_exit;\n\n\t\n\tret = hp_get_integer_from_buffer(buffer_ptr, buffer_size,\n\t\t\t\t\t &common_data->prerequisites_size);\n\tif (ret < 0)\n\t\tgoto common_exit;\n\n\tif (common_data->prerequisites_size > MAX_PREREQUISITES_SIZE) {\n\t\t \n\t\tpr_warn(\"Prerequisites size value exceeded the maximum number of elements supported or data may be malformed\\n\");\n\t\tcommon_data->prerequisites_size = MAX_PREREQUISITES_SIZE;\n\t}\n\n\t\n\tfor (reqs = 0; reqs < common_data->prerequisites_size; reqs++) {\n\t\tret = hp_get_string_from_buffer(buffer_ptr, buffer_size,\n\t\t\t\t\t\tcommon_data->prerequisites[reqs],\n\t\t\t\t\t\tsizeof(common_data->prerequisites[reqs]));\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\n\t\n\tret = hp_get_integer_from_buffer(buffer_ptr, buffer_size,\n\t\t\t\t\t &common_data->security_level);\n\ncommon_exit:\n\treturn ret;\n}\n\nint hp_enforce_single_line_input(char *buf, size_t count)\n{\n\tchar *p;\n\n\tp = memchr(buf, '\\n', count);\n\n\tif (p == buf + count - 1)\n\t\t*p = '\\0';  \n\telse if (p)\n\t\treturn -EINVAL;   \n\n\treturn 0;\n}\n\n \nvoid hp_set_reboot_and_signal_event(void)\n{\n\tbioscfg_drv.pending_reboot = true;\n\tkobject_uevent(&bioscfg_drv.class_dev->kobj, KOBJ_CHANGE);\n}\n\n \nsize_t hp_calculate_string_buffer(const char *str)\n{\n\tsize_t length = strlen(str);\n\n\t \n\tif (length == 0)\n\t\treturn 4;\n\n\t \n\treturn sizeof(u16) + strlen(str) * sizeof(u16);\n}\n\nint hp_wmi_error_and_message(int error_code)\n{\n\tchar *error_msg = NULL;\n\tint ret;\n\n\tswitch (error_code) {\n\tcase SUCCESS:\n\t\terror_msg = \"Success\";\n\t\tret = 0;\n\t\tbreak;\n\tcase CMD_FAILED:\n\t\terror_msg = \"Command failed\";\n\t\tret = -EINVAL;\n\t\tbreak;\n\tcase INVALID_SIGN:\n\t\terror_msg = \"Invalid signature\";\n\t\tret = -EINVAL;\n\t\tbreak;\n\tcase INVALID_CMD_VALUE:\n\t\terror_msg = \"Invalid command value/Feature not supported\";\n\t\tret = -EOPNOTSUPP;\n\t\tbreak;\n\tcase INVALID_CMD_TYPE:\n\t\terror_msg = \"Invalid command type\";\n\t\tret = -EINVAL;\n\t\tbreak;\n\tcase INVALID_DATA_SIZE:\n\t\terror_msg = \"Invalid data size\";\n\t\tret = -EINVAL;\n\t\tbreak;\n\tcase INVALID_CMD_PARAM:\n\t\terror_msg = \"Invalid command parameter\";\n\t\tret = -EINVAL;\n\t\tbreak;\n\tcase ENCRYP_CMD_REQUIRED:\n\t\terror_msg = \"Secure/encrypted command required\";\n\t\tret = -EACCES;\n\t\tbreak;\n\tcase NO_SECURE_SESSION:\n\t\terror_msg = \"No secure session established\";\n\t\tret = -EACCES;\n\t\tbreak;\n\tcase SECURE_SESSION_FOUND:\n\t\terror_msg = \"Secure session already established\";\n\t\tret = -EACCES;\n\t\tbreak;\n\tcase SECURE_SESSION_FAILED:\n\t\terror_msg = \"Secure session failed\";\n\t\tret = -EIO;\n\t\tbreak;\n\tcase AUTH_FAILED:\n\t\terror_msg = \"Other permission/Authentication failed\";\n\t\tret = -EACCES;\n\t\tbreak;\n\tcase INVALID_BIOS_AUTH:\n\t\terror_msg = \"Invalid BIOS administrator password\";\n\t\tret = -EINVAL;\n\t\tbreak;\n\tcase NONCE_DID_NOT_MATCH:\n\t\terror_msg = \"Nonce did not match\";\n\t\tret = -EINVAL;\n\t\tbreak;\n\tcase GENERIC_ERROR:\n\t\terror_msg = \"Generic/Other error\";\n\t\tret = -EIO;\n\t\tbreak;\n\tcase BIOS_ADMIN_POLICY_NOT_MET:\n\t\terror_msg = \"BIOS Admin password does not meet password policy requirements\";\n\t\tret = -EINVAL;\n\t\tbreak;\n\tcase BIOS_ADMIN_NOT_SET:\n\t\terror_msg = \"BIOS Setup password is not set\";\n\t\tret = -EPERM;\n\t\tbreak;\n\tcase P21_NO_PROVISIONED:\n\t\terror_msg = \"P21 is not provisioned\";\n\t\tret = -EPERM;\n\t\tbreak;\n\tcase P21_PROVISION_IN_PROGRESS:\n\t\terror_msg = \"P21 is already provisioned or provisioning is in progress and a signing key has already been sent\";\n\t\tret = -EINPROGRESS;\n\t\tbreak;\n\tcase P21_IN_USE:\n\t\terror_msg = \"P21 in use (cannot deprovision)\";\n\t\tret = -EPERM;\n\t\tbreak;\n\tcase HEP_NOT_ACTIVE:\n\t\terror_msg = \"HEP not activated\";\n\t\tret = -EPERM;\n\t\tbreak;\n\tcase HEP_ALREADY_SET:\n\t\terror_msg = \"HEP Transport already set\";\n\t\tret = -EINVAL;\n\t\tbreak;\n\tcase HEP_CHECK_STATE:\n\t\terror_msg = \"Check the current HEP state\";\n\t\tret = -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\terror_msg = \"Generic/Other error\";\n\t\tret = -EIO;\n\t\tbreak;\n\t}\n\n\tif (error_code)\n\t\tpr_warn_ratelimited(\"Returned error 0x%x, \\\"%s\\\"\\n\", error_code, error_msg);\n\n\treturn ret;\n}\n\nstatic ssize_t pending_reboot_show(struct kobject *kobj,\n\t\t\t\t   struct kobj_attribute *attr,\n\t\t\t\t   char *buf)\n{\n\treturn sysfs_emit(buf, \"%d\\n\", bioscfg_drv.pending_reboot);\n}\n\nstatic struct kobj_attribute pending_reboot = __ATTR_RO(pending_reboot);\n\n \nstatic int create_attributes_level_sysfs_files(void)\n{\n\treturn  sysfs_create_file(&bioscfg_drv.main_dir_kset->kobj,\n\t\t\t\t  &pending_reboot.attr);\n}\n\nstatic void attr_name_release(struct kobject *kobj)\n{\n\tkfree(kobj);\n}\n\nstatic const struct kobj_type attr_name_ktype = {\n\t.release\t= attr_name_release,\n\t.sysfs_ops\t= &kobj_sysfs_ops,\n};\n\n \nunion acpi_object *hp_get_wmiobj_pointer(int instance_id, const char *guid_string)\n{\n\tstruct acpi_buffer out = { ACPI_ALLOCATE_BUFFER, NULL };\n\tacpi_status status;\n\n\tstatus = wmi_query_block(guid_string, instance_id, &out);\n\treturn ACPI_SUCCESS(status) ? (union acpi_object *)out.pointer : NULL;\n}\n\n \nint hp_get_instance_count(const char *guid_string)\n{\n\tunion acpi_object *wmi_obj = NULL;\n\tint i = 0;\n\n\tdo {\n\t\tkfree(wmi_obj);\n\t\twmi_obj = hp_get_wmiobj_pointer(i, guid_string);\n\t\ti++;\n\t} while (wmi_obj);\n\n\treturn i - 1;\n}\n\n \nstatic int hp_alloc_attributes_data(int attr_type)\n{\n\tswitch (attr_type) {\n\tcase HPWMI_STRING_TYPE:\n\t\treturn hp_alloc_string_data();\n\n\tcase HPWMI_INTEGER_TYPE:\n\t\treturn hp_alloc_integer_data();\n\n\tcase HPWMI_ENUMERATION_TYPE:\n\t\treturn hp_alloc_enumeration_data();\n\n\tcase HPWMI_ORDERED_LIST_TYPE:\n\t\treturn hp_alloc_ordered_list_data();\n\n\tcase HPWMI_PASSWORD_TYPE:\n\t\treturn hp_alloc_password_data();\n\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nint hp_convert_hexstr_to_str(const char *input, u32 input_len, char **str, int *len)\n{\n\tint ret = 0;\n\tint new_len = 0;\n\tchar tmp[] = \"0x00\";\n\tchar *new_str = NULL;\n\tlong  ch;\n\tint i;\n\n\tif (input_len <= 0 || !input || !str || !len)\n\t\treturn -EINVAL;\n\n\t*len = 0;\n\t*str = NULL;\n\n\tnew_str = kmalloc(input_len, GFP_KERNEL);\n\tif (!new_str)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < input_len; i += 5) {\n\t\tstrncpy(tmp, input + i, strlen(tmp));\n\t\tif (kstrtol(tmp, 16, &ch) == 0) {\n\t\t\t\n\t\t\tif (ch == '\\\\' ||\n\t\t\t    ch == '\\r' ||\n\t\t\t    ch == '\\n' || ch == '\\t') {\n\t\t\t\tif (ch == '\\r')\n\t\t\t\t\tch = 'r';\n\t\t\t\telse if (ch == '\\n')\n\t\t\t\t\tch = 'n';\n\t\t\t\telse if (ch == '\\t')\n\t\t\t\t\tch = 't';\n\t\t\t\tnew_str[new_len++] = '\\\\';\n\t\t\t}\n\t\t\tnew_str[new_len++] = ch;\n\t\t\tif (ch == '\\0')\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (new_len) {\n\t\tnew_str[new_len] = '\\0';\n\t\t*str = krealloc(new_str, (new_len + 1) * sizeof(char),\n\t\t\t\tGFP_KERNEL);\n\t\tif (*str)\n\t\t\t*len = new_len;\n\t\telse\n\t\t\tret = -ENOMEM;\n\t} else {\n\t\tret = -EFAULT;\n\t}\n\n\tif (ret)\n\t\tkfree(new_str);\n\treturn ret;\n}\n\n \nint hp_encode_outsize_for_pvsz(int outsize)\n{\n\tif (outsize > 4096)\n\t\treturn -EINVAL;\n\tif (outsize > 1024)\n\t\treturn 5;\n\tif (outsize > 128)\n\t\treturn 4;\n\tif (outsize > 4)\n\t\treturn 3;\n\tif (outsize > 0)\n\t\treturn 2;\n\treturn 1;\n}\n\n \nvoid hp_friendly_user_name_update(char *path, const char *attr_name,\n\t\t\t\t  char *attr_display, int attr_size)\n{\n\tif (strstr(path, SCHEDULE_POWER_ON))\n\t\tsnprintf(attr_display, attr_size, \"%s - %s\", SCHEDULE_POWER_ON, attr_name);\n\telse\n\t\tstrscpy(attr_display, attr_name, attr_size);\n}\n\n \nvoid hp_update_attribute_permissions(bool is_readonly, struct kobj_attribute *current_val)\n{\n\tcurrent_val->attr.mode = is_readonly ? 0444 : 0644;\n}\n\n \nstatic void destroy_attribute_objs(struct kset *kset)\n{\n\tstruct kobject *pos, *next;\n\n\tlist_for_each_entry_safe(pos, next, &kset->list, entry)\n\t\tkobject_put(pos);\n}\n\n \nstatic void release_attributes_data(void)\n{\n\tmutex_lock(&bioscfg_drv.mutex);\n\n\thp_exit_string_attributes();\n\thp_exit_integer_attributes();\n\thp_exit_enumeration_attributes();\n\thp_exit_ordered_list_attributes();\n\thp_exit_password_attributes();\n\thp_exit_sure_start_attributes();\n\thp_exit_secure_platform_attributes();\n\n\tif (bioscfg_drv.authentication_dir_kset) {\n\t\tdestroy_attribute_objs(bioscfg_drv.authentication_dir_kset);\n\t\tkset_unregister(bioscfg_drv.authentication_dir_kset);\n\t\tbioscfg_drv.authentication_dir_kset = NULL;\n\t}\n\tif (bioscfg_drv.main_dir_kset) {\n\t\tsysfs_remove_file(&bioscfg_drv.main_dir_kset->kobj, &pending_reboot.attr);\n\t\tdestroy_attribute_objs(bioscfg_drv.main_dir_kset);\n\t\tkset_unregister(bioscfg_drv.main_dir_kset);\n\t\tbioscfg_drv.main_dir_kset = NULL;\n\t}\n\tmutex_unlock(&bioscfg_drv.mutex);\n}\n\n \nstatic int hp_add_other_attributes(int attr_type)\n{\n\tstruct kobject *attr_name_kobj;\n\tunion acpi_object *obj = NULL;\n\tint ret;\n\tchar *attr_name;\n\n\tattr_name_kobj = kzalloc(sizeof(*attr_name_kobj), GFP_KERNEL);\n\tif (!attr_name_kobj)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&bioscfg_drv.mutex);\n\n\t \n\tswitch (attr_type) {\n\tcase HPWMI_SECURE_PLATFORM_TYPE:\n\t\tattr_name_kobj->kset = bioscfg_drv.authentication_dir_kset;\n\t\tattr_name = SPM_STR;\n\t\tbreak;\n\n\tcase HPWMI_SURE_START_TYPE:\n\t\tattr_name_kobj->kset = bioscfg_drv.main_dir_kset;\n\t\tattr_name = SURE_START_STR;\n\t\tbreak;\n\n\tdefault:\n\t\tpr_err(\"Error: Unknown attr_type: %d\\n\", attr_type);\n\t\tret = -EINVAL;\n\t\tkfree(attr_name_kobj);\n\t\tgoto unlock_drv_mutex;\n\t}\n\n\tret = kobject_init_and_add(attr_name_kobj, &attr_name_ktype,\n\t\t\t\t   NULL, \"%s\", attr_name);\n\tif (ret) {\n\t\tpr_err(\"Error encountered [%d]\\n\", ret);\n\t\tgoto err_other_attr_init;\n\t}\n\n\t \n\tswitch (attr_type) {\n\tcase HPWMI_SECURE_PLATFORM_TYPE:\n\t\tret = hp_populate_secure_platform_data(attr_name_kobj);\n\t\tbreak;\n\n\tcase HPWMI_SURE_START_TYPE:\n\t\tret = hp_populate_sure_start_data(attr_name_kobj);\n\t\tbreak;\n\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\tif (ret)\n\t\tgoto err_other_attr_init;\n\n\tmutex_unlock(&bioscfg_drv.mutex);\n\treturn 0;\n\nerr_other_attr_init:\n\tkobject_put(attr_name_kobj);\nunlock_drv_mutex:\n\tmutex_unlock(&bioscfg_drv.mutex);\n\tkfree(obj);\n\treturn ret;\n}\n\nstatic int hp_init_bios_package_attribute(enum hp_wmi_data_type attr_type,\n\t\t\t\t\t  union acpi_object *obj,\n\t\t\t\t\t  const char *guid, int min_elements,\n\t\t\t\t\t  int instance_id)\n{\n\tstruct kobject *attr_name_kobj, *duplicate;\n\tunion acpi_object *elements;\n\tstruct kset *temp_kset;\n\n\tchar *str_value = NULL;\n\tint str_len;\n\tint ret = 0;\n\n\t \n\tif (obj->package.count < min_elements) {\n\t\tpr_err(\"ACPI-package does not have enough elements: %d < %d\\n\",\n\t\t       obj->package.count, min_elements);\n\t\tgoto pack_attr_exit;\n\t}\n\n\telements = obj->package.elements;\n\n\t \n\tif (elements[NAME].type != ACPI_TYPE_STRING) {\n\t\tpr_debug(\"incorrect element type\\n\");\n\t\tgoto pack_attr_exit;\n\t}\n\tif (strlen(elements[NAME].string.pointer) == 0) {\n\t\tpr_debug(\"empty attribute found\\n\");\n\t\tgoto pack_attr_exit;\n\t}\n\n\tif (attr_type == HPWMI_PASSWORD_TYPE)\n\t\ttemp_kset = bioscfg_drv.authentication_dir_kset;\n\telse\n\t\ttemp_kset = bioscfg_drv.main_dir_kset;\n\n\t \n\tret = hp_convert_hexstr_to_str(elements[NAME].string.pointer,\n\t\t\t\t       elements[NAME].string.length,\n\t\t\t\t       &str_value, &str_len);\n\n\tif (ret) {\n\t\tpr_debug(\"Failed to populate integer package data. Error [0%0x]\\n\",\n\t\t\t ret);\n\t\tkfree(str_value);\n\t\treturn ret;\n\t}\n\n\t \n\tduplicate = kset_find_obj(temp_kset, str_value);\n\tif (duplicate) {\n\t\tpr_debug(\"Duplicate attribute name found - %s\\n\", str_value);\n\t\t \n\t\tkobject_put(duplicate);\n\t\tgoto pack_attr_exit;\n\t}\n\n\t \n\tattr_name_kobj = kzalloc(sizeof(*attr_name_kobj), GFP_KERNEL);\n\tif (!attr_name_kobj) {\n\t\tret = -ENOMEM;\n\t\tgoto pack_attr_exit;\n\t}\n\n\tattr_name_kobj->kset = temp_kset;\n\n\tret = kobject_init_and_add(attr_name_kobj, &attr_name_ktype,\n\t\t\t\t   NULL, \"%s\", str_value);\n\n\tif (ret) {\n\t\tkobject_put(attr_name_kobj);\n\t\tgoto pack_attr_exit;\n\t}\n\n\t \n\tswitch (attr_type) {\n\tcase HPWMI_STRING_TYPE:\n\t\tret = hp_populate_string_package_data(elements,\n\t\t\t\t\t\t      instance_id,\n\t\t\t\t\t\t      attr_name_kobj);\n\t\tbreak;\n\tcase HPWMI_INTEGER_TYPE:\n\t\tret = hp_populate_integer_package_data(elements,\n\t\t\t\t\t\t       instance_id,\n\t\t\t\t\t\t       attr_name_kobj);\n\t\tbreak;\n\tcase HPWMI_ENUMERATION_TYPE:\n\t\tret = hp_populate_enumeration_package_data(elements,\n\t\t\t\t\t\t\t   instance_id,\n\t\t\t\t\t\t\t   attr_name_kobj);\n\t\tbreak;\n\tcase HPWMI_ORDERED_LIST_TYPE:\n\t\tret = hp_populate_ordered_list_package_data(elements,\n\t\t\t\t\t\t\t    instance_id,\n\t\t\t\t\t\t\t    attr_name_kobj);\n\t\tbreak;\n\tcase HPWMI_PASSWORD_TYPE:\n\t\tret = hp_populate_password_package_data(elements,\n\t\t\t\t\t\t\tinstance_id,\n\t\t\t\t\t\t\tattr_name_kobj);\n\t\tbreak;\n\tdefault:\n\t\tpr_debug(\"Unknown attribute type found: 0x%x\\n\", attr_type);\n\t\tbreak;\n\t}\n\npack_attr_exit:\n\tkfree(str_value);\n\treturn ret;\n}\n\nstatic int hp_init_bios_buffer_attribute(enum hp_wmi_data_type attr_type,\n\t\t\t\t\t union acpi_object *obj,\n\t\t\t\t\t const char *guid, int min_elements,\n\t\t\t\t\t int instance_id)\n{\n\tstruct kobject *attr_name_kobj, *duplicate;\n\tstruct kset *temp_kset;\n\tchar str[MAX_BUFF_SIZE];\n\n\tchar *temp_str = NULL;\n\tchar *str_value = NULL;\n\tu8 *buffer_ptr = NULL;\n\tint buffer_size;\n\tint ret = 0;\n\n\tbuffer_size = obj->buffer.length;\n\tbuffer_ptr = obj->buffer.pointer;\n\n\tret = hp_get_string_from_buffer(&buffer_ptr,\n\t\t\t\t\t&buffer_size, str, MAX_BUFF_SIZE);\n\n\tif (ret < 0)\n\t\tgoto buff_attr_exit;\n\n\tif (attr_type == HPWMI_PASSWORD_TYPE ||\n\t    attr_type == HPWMI_SECURE_PLATFORM_TYPE)\n\t\ttemp_kset = bioscfg_drv.authentication_dir_kset;\n\telse\n\t\ttemp_kset = bioscfg_drv.main_dir_kset;\n\n\t \n\tduplicate = kset_find_obj(temp_kset, str);\n\tif (duplicate) {\n\t\tpr_debug(\"Duplicate attribute name found - %s\\n\", str);\n\t\t \n\t\tkobject_put(duplicate);\n\t\tgoto buff_attr_exit;\n\t}\n\n\t \n\tattr_name_kobj = kzalloc(sizeof(*attr_name_kobj), GFP_KERNEL);\n\tif (!attr_name_kobj) {\n\t\tret = -ENOMEM;\n\t\tgoto buff_attr_exit;\n\t}\n\n\tattr_name_kobj->kset = temp_kset;\n\n\ttemp_str = str;\n\tif (attr_type == HPWMI_SECURE_PLATFORM_TYPE)\n\t\ttemp_str = \"SPM\";\n\n\tret = kobject_init_and_add(attr_name_kobj,\n\t\t\t\t   &attr_name_ktype, NULL, \"%s\", temp_str);\n\tif (ret) {\n\t\tkobject_put(attr_name_kobj);\n\t\tgoto buff_attr_exit;\n\t}\n\n\t \n\tswitch (attr_type) {\n\tcase HPWMI_STRING_TYPE:\n\t\tret = hp_populate_string_buffer_data(buffer_ptr,\n\t\t\t\t\t\t     &buffer_size,\n\t\t\t\t\t\t     instance_id,\n\t\t\t\t\t\t     attr_name_kobj);\n\t\tbreak;\n\tcase HPWMI_INTEGER_TYPE:\n\t\tret = hp_populate_integer_buffer_data(buffer_ptr,\n\t\t\t\t\t\t      &buffer_size,\n\t\t\t\t\t\t      instance_id,\n\t\t\t\t\t\t      attr_name_kobj);\n\t\tbreak;\n\tcase HPWMI_ENUMERATION_TYPE:\n\t\tret = hp_populate_enumeration_buffer_data(buffer_ptr,\n\t\t\t\t\t\t\t  &buffer_size,\n\t\t\t\t\t\t\t  instance_id,\n\t\t\t\t\t\t\t  attr_name_kobj);\n\t\tbreak;\n\tcase HPWMI_ORDERED_LIST_TYPE:\n\t\tret = hp_populate_ordered_list_buffer_data(buffer_ptr,\n\t\t\t\t\t\t\t   &buffer_size,\n\t\t\t\t\t\t\t   instance_id,\n\t\t\t\t\t\t\t   attr_name_kobj);\n\t\tbreak;\n\tcase HPWMI_PASSWORD_TYPE:\n\t\tret = hp_populate_password_buffer_data(buffer_ptr,\n\t\t\t\t\t\t       &buffer_size,\n\t\t\t\t\t\t       instance_id,\n\t\t\t\t\t\t       attr_name_kobj);\n\t\tbreak;\n\tdefault:\n\t\tpr_debug(\"Unknown attribute type found: 0x%x\\n\", attr_type);\n\t\tbreak;\n\t}\n\nbuff_attr_exit:\n\tkfree(str_value);\n\treturn ret;\n}\n\n \nstatic int hp_init_bios_attributes(enum hp_wmi_data_type attr_type, const char *guid)\n{\n\tunion acpi_object *obj = NULL;\n\tint min_elements;\n\n\t \n\tint instance_id = 0;\n\tint cur_instance_id = instance_id;\n\tint ret = 0;\n\n\tret = hp_alloc_attributes_data(attr_type);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (attr_type) {\n\tcase HPWMI_STRING_TYPE:\n\t\tmin_elements = STR_ELEM_CNT;\n\t\tbreak;\n\tcase HPWMI_INTEGER_TYPE:\n\t\tmin_elements = INT_ELEM_CNT;\n\t\tbreak;\n\tcase HPWMI_ENUMERATION_TYPE:\n\t\tmin_elements = ENUM_ELEM_CNT;\n\t\tbreak;\n\tcase HPWMI_ORDERED_LIST_TYPE:\n\t\tmin_elements = ORD_ELEM_CNT;\n\t\tbreak;\n\tcase HPWMI_PASSWORD_TYPE:\n\t\tmin_elements = PSWD_ELEM_CNT;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"Error: Unknown attr_type: %d\\n\", attr_type);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tobj = hp_get_wmiobj_pointer(instance_id, guid);\n\tif (!obj)\n\t\treturn -ENODEV;\n\n\tmutex_lock(&bioscfg_drv.mutex);\n\twhile (obj) {\n\t\t \n\t\tif (obj->type == ACPI_TYPE_PACKAGE) {\n\t\t\tret = hp_init_bios_package_attribute(attr_type, obj,\n\t\t\t\t\t\t\t     guid, min_elements,\n\t\t\t\t\t\t\t     cur_instance_id);\n\n\t\t} else if (obj->type == ACPI_TYPE_BUFFER) {\n\t\t\tret = hp_init_bios_buffer_attribute(attr_type, obj,\n\t\t\t\t\t\t\t    guid, min_elements,\n\t\t\t\t\t\t\t    cur_instance_id);\n\n\t\t} else {\n\t\t\tpr_err(\"Expected ACPI-package or buffer type, got: %d\\n\",\n\t\t\t       obj->type);\n\t\t\tret = -EIO;\n\t\t\tgoto err_attr_init;\n\t\t}\n\n\t\t \n\t\tif (ret >= 0)\n\t\t\tcur_instance_id++;\n\n\t\tkfree(obj);\n\t\tinstance_id++;\n\t\tobj = hp_get_wmiobj_pointer(instance_id, guid);\n\t}\n\nerr_attr_init:\n\tmutex_unlock(&bioscfg_drv.mutex);\n\tkfree(obj);\n\treturn ret;\n}\n\nstatic int __init hp_init(void)\n{\n\tint ret;\n\tint hp_bios_capable = wmi_has_guid(HP_WMI_BIOS_GUID);\n\tint set_bios_settings = wmi_has_guid(HP_WMI_SET_BIOS_SETTING_GUID);\n\n\tif (!hp_bios_capable) {\n\t\tpr_err(\"Unable to run on non-HP system\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (!set_bios_settings) {\n\t\tpr_err(\"Unable to set BIOS settings on HP systems\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tret = hp_init_attr_set_interface();\n\tif (ret)\n\t\treturn ret;\n\n\tret = fw_attributes_class_get(&fw_attr_class);\n\tif (ret)\n\t\tgoto err_unregister_class;\n\n\tbioscfg_drv.class_dev = device_create(fw_attr_class, NULL, MKDEV(0, 0),\n\t\t\t\t\t      NULL, \"%s\", DRIVER_NAME);\n\tif (IS_ERR(bioscfg_drv.class_dev)) {\n\t\tret = PTR_ERR(bioscfg_drv.class_dev);\n\t\tgoto err_unregister_class;\n\t}\n\n\tbioscfg_drv.main_dir_kset = kset_create_and_add(\"attributes\", NULL,\n\t\t\t\t\t\t\t&bioscfg_drv.class_dev->kobj);\n\tif (!bioscfg_drv.main_dir_kset) {\n\t\tret = -ENOMEM;\n\t\tpr_debug(\"Failed to create and add attributes\\n\");\n\t\tgoto err_destroy_classdev;\n\t}\n\n\tbioscfg_drv.authentication_dir_kset = kset_create_and_add(\"authentication\", NULL,\n\t\t\t\t\t\t\t\t  &bioscfg_drv.class_dev->kobj);\n\tif (!bioscfg_drv.authentication_dir_kset) {\n\t\tret = -ENOMEM;\n\t\tpr_debug(\"Failed to create and add authentication\\n\");\n\t\tgoto err_release_attributes_data;\n\t}\n\n\t \n\tret = create_attributes_level_sysfs_files();\n\tif (ret)\n\t\tpr_debug(\"Failed to create sysfs level attributes\\n\");\n\n\tret = hp_init_bios_attributes(HPWMI_STRING_TYPE, HP_WMI_BIOS_STRING_GUID);\n\tif (ret)\n\t\tpr_debug(\"Failed to populate string type attributes\\n\");\n\n\tret = hp_init_bios_attributes(HPWMI_INTEGER_TYPE, HP_WMI_BIOS_INTEGER_GUID);\n\tif (ret)\n\t\tpr_debug(\"Failed to populate integer type attributes\\n\");\n\n\tret = hp_init_bios_attributes(HPWMI_ENUMERATION_TYPE, HP_WMI_BIOS_ENUMERATION_GUID);\n\tif (ret)\n\t\tpr_debug(\"Failed to populate enumeration type attributes\\n\");\n\n\tret = hp_init_bios_attributes(HPWMI_ORDERED_LIST_TYPE, HP_WMI_BIOS_ORDERED_LIST_GUID);\n\tif (ret)\n\t\tpr_debug(\"Failed to populate ordered list object type attributes\\n\");\n\n\tret = hp_init_bios_attributes(HPWMI_PASSWORD_TYPE, HP_WMI_BIOS_PASSWORD_GUID);\n\tif (ret)\n\t\tpr_debug(\"Failed to populate password object type attributes\\n\");\n\n\tbioscfg_drv.spm_data.attr_name_kobj = NULL;\n\tret = hp_add_other_attributes(HPWMI_SECURE_PLATFORM_TYPE);\n\tif (ret)\n\t\tpr_debug(\"Failed to populate secure platform object type attribute\\n\");\n\n\tbioscfg_drv.sure_start_attr_kobj = NULL;\n\tret = hp_add_other_attributes(HPWMI_SURE_START_TYPE);\n\tif (ret)\n\t\tpr_debug(\"Failed to populate sure start object type attribute\\n\");\n\n\treturn 0;\n\nerr_release_attributes_data:\n\trelease_attributes_data();\n\nerr_destroy_classdev:\n\tdevice_destroy(fw_attr_class, MKDEV(0, 0));\n\nerr_unregister_class:\n\tfw_attributes_class_put();\n\thp_exit_attr_set_interface();\n\n\treturn ret;\n}\n\nstatic void __exit hp_exit(void)\n{\n\trelease_attributes_data();\n\tdevice_destroy(fw_attr_class, MKDEV(0, 0));\n\n\tfw_attributes_class_put();\n\thp_exit_attr_set_interface();\n}\n\nmodule_init(hp_init);\nmodule_exit(hp_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}