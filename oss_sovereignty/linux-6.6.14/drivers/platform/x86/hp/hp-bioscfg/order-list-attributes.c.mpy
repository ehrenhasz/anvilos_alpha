{
  "module_name": "order-list-attributes.c",
  "hash_id": "32783249828901104f348332f72a6f6a54a7076b8cdf85306c7831f5aaa2cb02",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/x86/hp/hp-bioscfg/order-list-attributes.c",
  "human_readable_source": "\n \n\n#include \"bioscfg.h\"\n\nGET_INSTANCE_ID(ordered_list);\n\nstatic ssize_t current_value_show(struct kobject *kobj, struct kobj_attribute *attr, char *buf)\n{\n\tint instance_id = get_ordered_list_instance_id(kobj);\n\n\tif (instance_id < 0)\n\t\treturn -EIO;\n\n\treturn sysfs_emit(buf, \"%s\\n\",\n\t\t\t bioscfg_drv.ordered_list_data[instance_id].current_value);\n}\n\nstatic int replace_char_str(u8 *buffer, char *repl_char, char *repl_with)\n{\n\tchar *src = buffer;\n\tint buflen = strlen(buffer);\n\tint item;\n\n\tif (buflen < 1)\n\t\treturn -EINVAL;\n\n\tfor (item = 0; item < buflen; item++)\n\t\tif (src[item] == *repl_char)\n\t\t\tsrc[item] = *repl_with;\n\n\treturn 0;\n}\n\n \nstatic int validate_ordered_list_input(int instance, char *buf)\n{\n\t \n\treturn replace_char_str(buf, SEMICOLON_SEP, COMMA_SEP);\n}\n\nstatic void update_ordered_list_value(int instance, char *attr_value)\n{\n\tstruct ordered_list_data *ordered_list_data = &bioscfg_drv.ordered_list_data[instance];\n\n\tstrscpy(ordered_list_data->current_value,\n\t\tattr_value,\n\t\tsizeof(ordered_list_data->current_value));\n}\n\nATTRIBUTE_S_COMMON_PROPERTY_SHOW(display_name, ordered_list);\nstatic struct kobj_attribute ordered_list_display_name =\n\t__ATTR_RO(display_name);\n\nATTRIBUTE_PROPERTY_STORE(current_value, ordered_list);\nstatic struct kobj_attribute ordered_list_current_val =\n\t__ATTR_RW_MODE(current_value, 0644);\n\nATTRIBUTE_VALUES_PROPERTY_SHOW(elements, ordered_list, SEMICOLON_SEP);\nstatic struct kobj_attribute ordered_list_elements_val =\n\t__ATTR_RO(elements);\n\nstatic ssize_t type_show(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t char *buf)\n{\n\treturn sysfs_emit(buf, \"ordered-list\\n\");\n}\n\nstatic struct kobj_attribute ordered_list_type =\n\t__ATTR_RO(type);\n\nstatic struct attribute *ordered_list_attrs[] = {\n\t&common_display_langcode.attr,\n\t&ordered_list_display_name.attr,\n\t&ordered_list_current_val.attr,\n\t&ordered_list_elements_val.attr,\n\t&ordered_list_type.attr,\n\tNULL\n};\n\nstatic const struct attribute_group ordered_list_attr_group = {\n\t.attrs = ordered_list_attrs,\n};\n\nint hp_alloc_ordered_list_data(void)\n{\n\tbioscfg_drv.ordered_list_instances_count =\n\t\thp_get_instance_count(HP_WMI_BIOS_ORDERED_LIST_GUID);\n\tbioscfg_drv.ordered_list_data = kcalloc(bioscfg_drv.ordered_list_instances_count,\n\t\t\t\t\t\tsizeof(*bioscfg_drv.ordered_list_data),\n\t\t\t\t\t\tGFP_KERNEL);\n\tif (!bioscfg_drv.ordered_list_data) {\n\t\tbioscfg_drv.ordered_list_instances_count = 0;\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}\n\n \nstatic const acpi_object_type expected_order_types[] = {\n\t[NAME]\t= ACPI_TYPE_STRING,\n\t[VALUE] = ACPI_TYPE_STRING,\n\t[PATH] = ACPI_TYPE_STRING,\n\t[IS_READONLY] = ACPI_TYPE_INTEGER,\n\t[DISPLAY_IN_UI] = ACPI_TYPE_INTEGER,\n\t[REQUIRES_PHYSICAL_PRESENCE] = ACPI_TYPE_INTEGER,\n\t[SEQUENCE] = ACPI_TYPE_INTEGER,\n\t[PREREQUISITES_SIZE] = ACPI_TYPE_INTEGER,\n\t[PREREQUISITES] = ACPI_TYPE_STRING,\n\t[SECURITY_LEVEL] = ACPI_TYPE_INTEGER,\n\t[ORD_LIST_SIZE] = ACPI_TYPE_INTEGER,\n\t[ORD_LIST_ELEMENTS] = ACPI_TYPE_STRING,\n};\n\nstatic int hp_populate_ordered_list_elements_from_package(union acpi_object *order_obj,\n\t\t\t\t\t\t\t  int order_obj_count,\n\t\t\t\t\t\t\t  int instance_id)\n{\n\tchar *str_value = NULL;\n\tint value_len = 0;\n\tint ret;\n\tu32 size;\n\tu32 int_value = 0;\n\tint elem;\n\tint olist_elem;\n\tint reqs;\n\tint eloc;\n\tchar *tmpstr = NULL;\n\tchar *part_tmp = NULL;\n\tint tmp_len = 0;\n\tchar *part = NULL;\n\tstruct ordered_list_data *ordered_list_data = &bioscfg_drv.ordered_list_data[instance_id];\n\n\tif (!order_obj)\n\t\treturn -EINVAL;\n\n\tfor (elem = 1, eloc = 1; eloc < ORD_ELEM_CNT; elem++, eloc++) {\n\n\t\tswitch (order_obj[elem].type) {\n\t\tcase ACPI_TYPE_STRING:\n\t\t\tif (elem != PREREQUISITES && elem != ORD_LIST_ELEMENTS) {\n\t\t\t\tret = hp_convert_hexstr_to_str(order_obj[elem].string.pointer,\n\t\t\t\t\t\t\t       order_obj[elem].string.length,\n\t\t\t\t\t\t\t       &str_value, &value_len);\n\t\t\t\tif (ret)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ACPI_TYPE_INTEGER:\n\t\t\tint_value = (u32)order_obj[elem].integer.value;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_warn(\"Unsupported object type [%d]\\n\", order_obj[elem].type);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (expected_order_types[eloc] != order_obj[elem].type) {\n\t\t\tpr_err(\"Error expected type %d for elem %d, but got type %d instead\\n\",\n\t\t\t       expected_order_types[eloc], elem, order_obj[elem].type);\n\t\t\tkfree(str_value);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\t \n\t\tswitch (eloc) {\n\t\tcase VALUE:\n\t\t\tstrscpy(ordered_list_data->current_value,\n\t\t\t\tstr_value, sizeof(ordered_list_data->current_value));\n\t\t\treplace_char_str(ordered_list_data->current_value, COMMA_SEP, SEMICOLON_SEP);\n\t\t\tbreak;\n\t\tcase PATH:\n\t\t\tstrscpy(ordered_list_data->common.path, str_value,\n\t\t\t\tsizeof(ordered_list_data->common.path));\n\t\t\tbreak;\n\t\tcase IS_READONLY:\n\t\t\tordered_list_data->common.is_readonly = int_value;\n\t\t\tbreak;\n\t\tcase DISPLAY_IN_UI:\n\t\t\tordered_list_data->common.display_in_ui = int_value;\n\t\t\tbreak;\n\t\tcase REQUIRES_PHYSICAL_PRESENCE:\n\t\t\tordered_list_data->common.requires_physical_presence = int_value;\n\t\t\tbreak;\n\t\tcase SEQUENCE:\n\t\t\tordered_list_data->common.sequence = int_value;\n\t\t\tbreak;\n\t\tcase PREREQUISITES_SIZE:\n\t\t\tif (int_value > MAX_PREREQUISITES_SIZE) {\n\t\t\t\tpr_warn(\"Prerequisites size value exceeded the maximum number of elements supported or data may be malformed\\n\");\n\t\t\t\tint_value = MAX_PREREQUISITES_SIZE;\n\t\t\t}\n\t\t\tordered_list_data->common.prerequisites_size = int_value;\n\n\t\t\t \n\t\t\tif (int_value == 0)\n\t\t\t\teloc++;\n\t\t\tbreak;\n\t\tcase PREREQUISITES:\n\t\t\tsize = min_t(u32, ordered_list_data->common.prerequisites_size,\n\t\t\t\t     MAX_PREREQUISITES_SIZE);\n\t\t\tfor (reqs = 0; reqs < size; reqs++) {\n\t\t\t\tret = hp_convert_hexstr_to_str(order_obj[elem + reqs].string.pointer,\n\t\t\t\t\t\t\t       order_obj[elem + reqs].string.length,\n\t\t\t\t\t\t\t       &str_value, &value_len);\n\n\t\t\t\tif (ret)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tstrscpy(ordered_list_data->common.prerequisites[reqs],\n\t\t\t\t\tstr_value,\n\t\t\t\t\tsizeof(ordered_list_data->common.prerequisites[reqs]));\n\n\t\t\t\tkfree(str_value);\n\t\t\t\tstr_value = NULL;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase SECURITY_LEVEL:\n\t\t\tordered_list_data->common.security_level = int_value;\n\t\t\tbreak;\n\n\t\tcase ORD_LIST_SIZE:\n\t\t\tif (int_value > MAX_ELEMENTS_SIZE) {\n\t\t\t\tpr_warn(\"Order List size value exceeded the maximum number of elements supported or data may be malformed\\n\");\n\t\t\t\tint_value = MAX_ELEMENTS_SIZE;\n\t\t\t}\n\t\t\tordered_list_data->elements_size = int_value;\n\n\t\t\t \n\t\t\tif (int_value == 0)\n\t\t\t\teloc++;\n\t\t\tbreak;\n\t\tcase ORD_LIST_ELEMENTS:\n\n\t\t\t \n\t\t\tret = hp_convert_hexstr_to_str(str_value, value_len, &tmpstr, &tmp_len);\n\t\t\tif (ret)\n\t\t\t\tgoto exit_list;\n\n\t\t\tpart_tmp = tmpstr;\n\t\t\tpart = strsep(&part_tmp, COMMA_SEP);\n\n\t\t\tfor (olist_elem = 0; olist_elem < MAX_ELEMENTS_SIZE && part; olist_elem++) {\n\t\t\t\tstrscpy(ordered_list_data->elements[olist_elem],\n\t\t\t\t\tpart,\n\t\t\t\t\tsizeof(ordered_list_data->elements[olist_elem]));\n\t\t\t\tpart = strsep(&part_tmp, COMMA_SEP);\n\t\t\t}\n\t\t\tordered_list_data->elements_size = olist_elem;\n\n\t\t\tkfree(str_value);\n\t\t\tstr_value = NULL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_warn(\"Invalid element: %d found in Ordered_List attribute or data may be malformed\\n\", elem);\n\t\t\tbreak;\n\t\t}\n\t\tkfree(tmpstr);\n\t\ttmpstr = NULL;\n\t\tkfree(str_value);\n\t\tstr_value = NULL;\n\t}\n\nexit_list:\n\tkfree(tmpstr);\n\tkfree(str_value);\n\treturn 0;\n}\n\n \nint hp_populate_ordered_list_package_data(union acpi_object *order_obj, int instance_id,\n\t\t\t\t\t  struct kobject *attr_name_kobj)\n{\n\tstruct ordered_list_data *ordered_list_data = &bioscfg_drv.ordered_list_data[instance_id];\n\n\tordered_list_data->attr_name_kobj = attr_name_kobj;\n\n\thp_populate_ordered_list_elements_from_package(order_obj,\n\t\t\t\t\t\t       order_obj->package.count,\n\t\t\t\t\t\t       instance_id);\n\thp_update_attribute_permissions(ordered_list_data->common.is_readonly,\n\t\t\t\t\t&ordered_list_current_val);\n\thp_friendly_user_name_update(ordered_list_data->common.path,\n\t\t\t\t     attr_name_kobj->name,\n\t\t\t\t     ordered_list_data->common.display_name,\n\t\t\t\t     sizeof(ordered_list_data->common.display_name));\n\treturn sysfs_create_group(attr_name_kobj, &ordered_list_attr_group);\n}\n\nstatic int hp_populate_ordered_list_elements_from_buffer(u8 *buffer_ptr, u32 *buffer_size,\n\t\t\t\t\t\t\t int instance_id)\n{\n\tint values;\n\tstruct ordered_list_data *ordered_list_data = &bioscfg_drv.ordered_list_data[instance_id];\n\tint ret = 0;\n\n\t \n\n\t\n\tret = hp_get_string_from_buffer(&buffer_ptr, buffer_size, ordered_list_data->current_value,\n\t\t\t\t\tsizeof(ordered_list_data->current_value));\n\tif (ret < 0)\n\t\tgoto buffer_exit;\n\n\treplace_char_str(ordered_list_data->current_value, COMMA_SEP, SEMICOLON_SEP);\n\n\t\n\tret = hp_get_common_data_from_buffer(&buffer_ptr, buffer_size,\n\t\t\t\t\t     &ordered_list_data->common);\n\tif (ret < 0)\n\t\tgoto buffer_exit;\n\n\t\n\tret = hp_get_integer_from_buffer(&buffer_ptr, buffer_size,\n\t\t\t\t\t &ordered_list_data->elements_size);\n\n\tif (ordered_list_data->elements_size > MAX_ELEMENTS_SIZE) {\n\t\t \n\t\tpr_warn(\"Ordered List size value exceeded the maximum number of elements supported or data may be malformed\\n\");\n\t\tordered_list_data->elements_size = MAX_ELEMENTS_SIZE;\n\t}\n\n\t\n\tfor (values = 0; values < ordered_list_data->elements_size; values++) {\n\t\tret = hp_get_string_from_buffer(&buffer_ptr, buffer_size,\n\t\t\t\t\t\tordered_list_data->elements[values],\n\t\t\t\t\t\tsizeof(ordered_list_data->elements[values]));\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\nbuffer_exit:\n\treturn ret;\n}\n\n \nint hp_populate_ordered_list_buffer_data(u8 *buffer_ptr, u32 *buffer_size, int instance_id,\n\t\t\t\t\t struct kobject *attr_name_kobj)\n{\n\tstruct ordered_list_data *ordered_list_data = &bioscfg_drv.ordered_list_data[instance_id];\n\tint ret = 0;\n\n\tordered_list_data->attr_name_kobj = attr_name_kobj;\n\n\t \n\tret = hp_populate_ordered_list_elements_from_buffer(buffer_ptr, buffer_size,\n\t\t\t\t\t\t\t    instance_id);\n\tif (ret < 0)\n\t\treturn ret;\n\n\thp_update_attribute_permissions(ordered_list_data->common.is_readonly,\n\t\t\t\t\t&ordered_list_current_val);\n\thp_friendly_user_name_update(ordered_list_data->common.path,\n\t\t\t\t     attr_name_kobj->name,\n\t\t\t\t     ordered_list_data->common.display_name,\n\t\t\t\t     sizeof(ordered_list_data->common.display_name));\n\n\treturn sysfs_create_group(attr_name_kobj, &ordered_list_attr_group);\n}\n\n \nvoid hp_exit_ordered_list_attributes(void)\n{\n\tint instance_id;\n\n\tfor (instance_id = 0; instance_id < bioscfg_drv.ordered_list_instances_count;\n\t     instance_id++) {\n\t\tstruct kobject *attr_name_kobj =\n\t\t\tbioscfg_drv.ordered_list_data[instance_id].attr_name_kobj;\n\n\t\tif (attr_name_kobj)\n\t\t\tsysfs_remove_group(attr_name_kobj,\n\t\t\t\t\t   &ordered_list_attr_group);\n\t}\n\tbioscfg_drv.ordered_list_instances_count = 0;\n\n\tkfree(bioscfg_drv.ordered_list_data);\n\tbioscfg_drv.ordered_list_data = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}