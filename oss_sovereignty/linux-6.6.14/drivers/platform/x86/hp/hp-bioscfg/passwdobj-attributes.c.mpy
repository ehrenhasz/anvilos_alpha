{
  "module_name": "passwdobj-attributes.c",
  "hash_id": "6c2351cf5f58b1e5c690bc37441974f0f6b499716799d2af9fa7f636a8cae7e0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/x86/hp/hp-bioscfg/passwdobj-attributes.c",
  "human_readable_source": "\n \n\n#include \"bioscfg.h\"\n#include <asm-generic/posix_types.h>\n\nGET_INSTANCE_ID(password);\n \nstatic int clear_passwords(const int instance)\n{\n\tstruct password_data *password_data = &bioscfg_drv.password_data[instance];\n\n\tif (!password_data->is_enabled)\n\t\treturn 0;\n\n\tmemset(password_data->current_password,\n\t       0, sizeof(password_data->current_password));\n\tmemset(password_data->new_password,\n\t       0, sizeof(password_data->new_password));\n\n\treturn 0;\n}\n\n \nint hp_clear_all_credentials(void)\n{\n\tint count = bioscfg_drv.password_instances_count;\n\tint instance;\n\n\t \n\tfor (instance = 0; instance < count; instance++)\n\t\tclear_passwords(instance);\n\n\t \n\tkfree(bioscfg_drv.spm_data.auth_token);\n\tbioscfg_drv.spm_data.auth_token = NULL;\n\n\treturn 0;\n}\n\nint hp_get_password_instance_for_type(const char *name)\n{\n\tint count = bioscfg_drv.password_instances_count;\n\tint instance;\n\n\tfor (instance = 0; instance < count; instance++)\n\t\tif (!strcmp(bioscfg_drv.password_data[instance].common.display_name, name))\n\t\t\treturn instance;\n\n\treturn -EINVAL;\n}\n\nstatic int validate_password_input(int instance_id, const char *buf)\n{\n\tint length;\n\tstruct password_data *password_data = &bioscfg_drv.password_data[instance_id];\n\n\tlength = strlen(buf);\n\tif (buf[length - 1] == '\\n')\n\t\tlength--;\n\n\tif (length > MAX_PASSWD_SIZE)\n\t\treturn INVALID_BIOS_AUTH;\n\n\tif (password_data->min_password_length > length ||\n\t    password_data->max_password_length < length)\n\t\treturn INVALID_BIOS_AUTH;\n\treturn SUCCESS;\n}\n\nATTRIBUTE_N_PROPERTY_SHOW(is_enabled, password);\nstatic struct kobj_attribute password_is_password_set = __ATTR_RO(is_enabled);\n\nstatic int store_password_instance(struct kobject *kobj, const char *buf,\n\t\t\t\t   size_t count, bool is_current)\n{\n\tchar *buf_cp;\n\tint id, ret = 0;\n\n\tbuf_cp = kstrdup(buf, GFP_KERNEL);\n\tif (!buf_cp)\n\t\treturn -ENOMEM;\n\n\tret = hp_enforce_single_line_input(buf_cp, count);\n\tif (!ret) {\n\t\tid = get_password_instance_id(kobj);\n\n\t\tif (id >= 0)\n\t\t\tret = validate_password_input(id, buf_cp);\n\t}\n\n\tif (!ret) {\n\t\tif (is_current)\n\t\t\tstrscpy(bioscfg_drv.password_data[id].current_password,\n\t\t\t\tbuf_cp,\n\t\t\t\tsizeof(bioscfg_drv.password_data[id].current_password));\n\t\telse\n\t\t\tstrscpy(bioscfg_drv.password_data[id].new_password,\n\t\t\t\tbuf_cp,\n\t\t\t\tsizeof(bioscfg_drv.password_data[id].new_password));\n\t}\n\n\tkfree(buf_cp);\n\treturn ret < 0 ? ret : count;\n}\n\nstatic ssize_t current_password_store(struct kobject *kobj,\n\t\t\t\t      struct kobj_attribute *attr,\n\t\t\t\t      const char *buf, size_t count)\n{\n\treturn store_password_instance(kobj, buf, count, true);\n}\n\nstatic struct kobj_attribute password_current_password = __ATTR_WO(current_password);\n\nstatic ssize_t new_password_store(struct kobject *kobj,\n\t\t\t\t  struct kobj_attribute *attr,\n\t\t\t\t  const char *buf, size_t count)\n{\n\treturn store_password_instance(kobj, buf, count, true);\n}\n\nstatic struct kobj_attribute password_new_password = __ATTR_WO(new_password);\n\nATTRIBUTE_N_PROPERTY_SHOW(min_password_length, password);\nstatic struct kobj_attribute password_min_password_length = __ATTR_RO(min_password_length);\n\nATTRIBUTE_N_PROPERTY_SHOW(max_password_length, password);\nstatic struct kobj_attribute password_max_password_length = __ATTR_RO(max_password_length);\n\nstatic ssize_t role_show(struct kobject *kobj, struct kobj_attribute *attr, char *buf)\n{\n\tif (!strcmp(kobj->name, SETUP_PASSWD))\n\t\treturn sysfs_emit(buf, \"%s\\n\", BIOS_ADMIN);\n\n\tif (!strcmp(kobj->name, POWER_ON_PASSWD))\n\t\treturn sysfs_emit(buf, \"%s\\n\", POWER_ON);\n\n\treturn -EIO;\n}\n\nstatic struct kobj_attribute password_role = __ATTR_RO(role);\n\nstatic ssize_t mechanism_show(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t      char *buf)\n{\n\tint i = get_password_instance_id(kobj);\n\n\tif (i < 0)\n\t\treturn i;\n\n\tif (bioscfg_drv.password_data[i].mechanism != PASSWORD)\n\t\treturn -EINVAL;\n\n\treturn sysfs_emit(buf, \"%s\\n\", PASSWD_MECHANISM_TYPES);\n}\n\nstatic struct kobj_attribute password_mechanism = __ATTR_RO(mechanism);\n\nATTRIBUTE_VALUES_PROPERTY_SHOW(encodings, password, SEMICOLON_SEP);\nstatic struct kobj_attribute password_encodings_val = __ATTR_RO(encodings);\n\nstatic struct attribute *password_attrs[] = {\n\t&password_is_password_set.attr,\n\t&password_min_password_length.attr,\n\t&password_max_password_length.attr,\n\t&password_current_password.attr,\n\t&password_new_password.attr,\n\t&password_role.attr,\n\t&password_mechanism.attr,\n\t&password_encodings_val.attr,\n\tNULL\n};\n\nstatic const struct attribute_group password_attr_group = {\n\t.attrs = password_attrs\n};\n\nint hp_alloc_password_data(void)\n{\n\tbioscfg_drv.password_instances_count = hp_get_instance_count(HP_WMI_BIOS_PASSWORD_GUID);\n\tbioscfg_drv.password_data = kcalloc(bioscfg_drv.password_instances_count,\n\t\t\t\t\t    sizeof(*bioscfg_drv.password_data), GFP_KERNEL);\n\tif (!bioscfg_drv.password_data) {\n\t\tbioscfg_drv.password_instances_count = 0;\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\n \nstatic const acpi_object_type expected_password_types[] = {\n\t[NAME] = ACPI_TYPE_STRING,\n\t[VALUE] = ACPI_TYPE_STRING,\n\t[PATH] = ACPI_TYPE_STRING,\n\t[IS_READONLY] = ACPI_TYPE_INTEGER,\n\t[DISPLAY_IN_UI] = ACPI_TYPE_INTEGER,\n\t[REQUIRES_PHYSICAL_PRESENCE] = ACPI_TYPE_INTEGER,\n\t[SEQUENCE] = ACPI_TYPE_INTEGER,\n\t[PREREQUISITES_SIZE] = ACPI_TYPE_INTEGER,\n\t[PREREQUISITES] = ACPI_TYPE_STRING,\n\t[SECURITY_LEVEL] = ACPI_TYPE_INTEGER,\n\t[PSWD_MIN_LENGTH] = ACPI_TYPE_INTEGER,\n\t[PSWD_MAX_LENGTH] = ACPI_TYPE_INTEGER,\n\t[PSWD_SIZE] = ACPI_TYPE_INTEGER,\n\t[PSWD_ENCODINGS] = ACPI_TYPE_STRING,\n\t[PSWD_IS_SET] = ACPI_TYPE_INTEGER,\n};\n\nstatic int hp_populate_password_elements_from_package(union acpi_object *password_obj,\n\t\t\t\t\t\t      int password_obj_count,\n\t\t\t\t\t\t      int instance_id)\n{\n\tchar *str_value = NULL;\n\tint value_len;\n\tint ret;\n\tu32 size;\n\tu32 int_value = 0;\n\tint elem;\n\tint reqs;\n\tint eloc;\n\tint pos_values;\n\tstruct password_data *password_data = &bioscfg_drv.password_data[instance_id];\n\n\tif (!password_obj)\n\t\treturn -EINVAL;\n\n\tfor (elem = 1, eloc = 1; elem < password_obj_count; elem++, eloc++) {\n\t\t \n\t\tif (eloc == PSWD_ELEM_CNT)\n\t\t\tgoto exit_package;\n\n\t\tswitch (password_obj[elem].type) {\n\t\tcase ACPI_TYPE_STRING:\n\t\t\tif (PREREQUISITES != elem && PSWD_ENCODINGS != elem) {\n\t\t\t\tret = hp_convert_hexstr_to_str(password_obj[elem].string.pointer,\n\t\t\t\t\t\t\t       password_obj[elem].string.length,\n\t\t\t\t\t\t\t       &str_value, &value_len);\n\t\t\t\tif (ret)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ACPI_TYPE_INTEGER:\n\t\t\tint_value = (u32)password_obj[elem].integer.value;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_warn(\"Unsupported object type [%d]\\n\", password_obj[elem].type);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (expected_password_types[eloc] != password_obj[elem].type) {\n\t\t\tpr_err(\"Error expected type %d for elem %d, but got type %d instead\\n\",\n\t\t\t       expected_password_types[eloc], elem, password_obj[elem].type);\n\t\t\tkfree(str_value);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\t \n\t\tswitch (eloc) {\n\t\tcase VALUE:\n\t\t\tbreak;\n\t\tcase PATH:\n\t\t\tstrscpy(password_data->common.path, str_value,\n\t\t\t\tsizeof(password_data->common.path));\n\t\t\tbreak;\n\t\tcase IS_READONLY:\n\t\t\tpassword_data->common.is_readonly = int_value;\n\t\t\tbreak;\n\t\tcase DISPLAY_IN_UI:\n\t\t\tpassword_data->common.display_in_ui = int_value;\n\t\t\tbreak;\n\t\tcase REQUIRES_PHYSICAL_PRESENCE:\n\t\t\tpassword_data->common.requires_physical_presence = int_value;\n\t\t\tbreak;\n\t\tcase SEQUENCE:\n\t\t\tpassword_data->common.sequence = int_value;\n\t\t\tbreak;\n\t\tcase PREREQUISITES_SIZE:\n\t\t\tif (int_value > MAX_PREREQUISITES_SIZE) {\n\t\t\t\tpr_warn(\"Prerequisites size value exceeded the maximum number of elements supported or data may be malformed\\n\");\n\t\t\t\tint_value = MAX_PREREQUISITES_SIZE;\n\t\t\t}\n\t\t\tpassword_data->common.prerequisites_size = int_value;\n\n\t\t\t \n\t\t\tif (int_value == 0)\n\t\t\t\teloc++;\n\t\t\tbreak;\n\t\tcase PREREQUISITES:\n\t\t\tsize = min_t(u32, password_data->common.prerequisites_size,\n\t\t\t\t     MAX_PREREQUISITES_SIZE);\n\n\t\t\tfor (reqs = 0; reqs < size; reqs++) {\n\t\t\t\tret = hp_convert_hexstr_to_str(password_obj[elem + reqs].string.pointer,\n\t\t\t\t\t\t\t       password_obj[elem + reqs].string.length,\n\t\t\t\t\t\t\t       &str_value, &value_len);\n\n\t\t\t\tif (ret)\n\t\t\t\t\tbreak;\n\n\t\t\t\tstrscpy(password_data->common.prerequisites[reqs],\n\t\t\t\t\tstr_value,\n\t\t\t\t\tsizeof(password_data->common.prerequisites[reqs]));\n\n\t\t\t\tkfree(str_value);\n\t\t\t\tstr_value = NULL;\n\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SECURITY_LEVEL:\n\t\t\tpassword_data->common.security_level = int_value;\n\t\t\tbreak;\n\t\tcase PSWD_MIN_LENGTH:\n\t\t\tpassword_data->min_password_length = int_value;\n\t\t\tbreak;\n\t\tcase PSWD_MAX_LENGTH:\n\t\t\tpassword_data->max_password_length = int_value;\n\t\t\tbreak;\n\t\tcase PSWD_SIZE:\n\n\t\t\tif (int_value > MAX_ENCODINGS_SIZE) {\n\t\t\t\tpr_warn(\"Password Encoding size value exceeded the maximum number of elements supported or data may be malformed\\n\");\n\t\t\t\tint_value = MAX_ENCODINGS_SIZE;\n\t\t\t}\n\t\t\tpassword_data->encodings_size = int_value;\n\n\t\t\t \n\t\t\tif (int_value == 0)\n\t\t\t\teloc++;\n\t\t\tbreak;\n\t\tcase PSWD_ENCODINGS:\n\t\t\tsize = min_t(u32, password_data->encodings_size, MAX_ENCODINGS_SIZE);\n\t\t\tfor (pos_values = 0; pos_values < size; pos_values++) {\n\t\t\t\tret = hp_convert_hexstr_to_str(password_obj[elem + pos_values].string.pointer,\n\t\t\t\t\t\t\t       password_obj[elem + pos_values].string.length,\n\t\t\t\t\t\t\t       &str_value, &value_len);\n\t\t\t\tif (ret)\n\t\t\t\t\tbreak;\n\n\t\t\t\tstrscpy(password_data->encodings[pos_values],\n\t\t\t\t\tstr_value,\n\t\t\t\t\tsizeof(password_data->encodings[pos_values]));\n\t\t\t\tkfree(str_value);\n\t\t\t\tstr_value = NULL;\n\n\t\t\t}\n\t\t\tbreak;\n\t\tcase PSWD_IS_SET:\n\t\t\tpassword_data->is_enabled = int_value;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_warn(\"Invalid element: %d found in Password attribute or data may be malformed\\n\", elem);\n\t\t\tbreak;\n\t\t}\n\n\t\tkfree(str_value);\n\t\tstr_value = NULL;\n\t}\n\nexit_package:\n\tkfree(str_value);\n\treturn 0;\n}\n\n \nint hp_populate_password_package_data(union acpi_object *password_obj, int instance_id,\n\t\t\t\t      struct kobject *attr_name_kobj)\n{\n\tstruct password_data *password_data = &bioscfg_drv.password_data[instance_id];\n\n\tpassword_data->attr_name_kobj = attr_name_kobj;\n\n\thp_populate_password_elements_from_package(password_obj,\n\t\t\t\t\t\t   password_obj->package.count,\n\t\t\t\t\t\t   instance_id);\n\n\thp_friendly_user_name_update(password_data->common.path,\n\t\t\t\t     attr_name_kobj->name,\n\t\t\t\t     password_data->common.display_name,\n\t\t\t\t     sizeof(password_data->common.display_name));\n\n\tif (!strcmp(attr_name_kobj->name, SETUP_PASSWD))\n\t\treturn sysfs_create_group(attr_name_kobj, &password_attr_group);\n\n\treturn sysfs_create_group(attr_name_kobj, &password_attr_group);\n}\n\nstatic int hp_populate_password_elements_from_buffer(u8 *buffer_ptr, u32 *buffer_size,\n\t\t\t\t\t\t     int instance_id)\n{\n\tint values;\n\tint isreadonly;\n\tstruct password_data *password_data = &bioscfg_drv.password_data[instance_id];\n\tint ret = 0;\n\n\t \n\n\t\n\tret = hp_get_string_from_buffer(&buffer_ptr, buffer_size, password_data->current_password,\n\t\t\t\t\tsizeof(password_data->current_password));\n\tif (ret < 0)\n\t\tgoto buffer_exit;\n\n\t\n\tret = hp_get_common_data_from_buffer(&buffer_ptr, buffer_size,\n\t\t\t\t\t     &password_data->common);\n\tif (ret < 0)\n\t\tgoto buffer_exit;\n\n\t\n\tret = hp_get_integer_from_buffer(&buffer_ptr, buffer_size,\n\t\t\t\t\t &password_data->min_password_length);\n\tif (ret < 0)\n\t\tgoto buffer_exit;\n\n\t\n\tret = hp_get_integer_from_buffer(&buffer_ptr, buffer_size,\n\t\t\t\t\t &password_data->max_password_length);\n\tif (ret < 0)\n\t\tgoto buffer_exit;\n\n\t\n\tret = hp_get_integer_from_buffer(&buffer_ptr, buffer_size,\n\t\t\t\t\t &password_data->encodings_size);\n\tif (ret < 0)\n\t\tgoto buffer_exit;\n\n\tif (password_data->encodings_size > MAX_ENCODINGS_SIZE) {\n\t\t \n\t\tpr_warn(\"Password Encoding size value exceeded the maximum number of elements supported or data may be malformed\\n\");\n\t\tpassword_data->encodings_size = MAX_ENCODINGS_SIZE;\n\t}\n\n\t\n\tfor (values = 0; values < password_data->encodings_size; values++) {\n\t\tret = hp_get_string_from_buffer(&buffer_ptr, buffer_size,\n\t\t\t\t\t\tpassword_data->encodings[values],\n\t\t\t\t\t\tsizeof(password_data->encodings[values]));\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\n\t\n\tret = hp_get_integer_from_buffer(&buffer_ptr, buffer_size, &isreadonly);\n\tif (ret < 0)\n\t\tgoto buffer_exit;\n\n\tpassword_data->is_enabled = isreadonly ? true : false;\n\nbuffer_exit:\n\treturn ret;\n}\n\n \nint hp_populate_password_buffer_data(u8 *buffer_ptr, u32 *buffer_size, int instance_id,\n\t\t\t\t     struct kobject *attr_name_kobj)\n{\n\tstruct password_data *password_data = &bioscfg_drv.password_data[instance_id];\n\tint ret = 0;\n\n\tpassword_data->attr_name_kobj = attr_name_kobj;\n\n\t \n\tret = hp_populate_password_elements_from_buffer(buffer_ptr, buffer_size,\n\t\t\t\t\t\t\tinstance_id);\n\tif (ret < 0)\n\t\treturn ret;\n\n\thp_friendly_user_name_update(password_data->common.path,\n\t\t\t\t     attr_name_kobj->name,\n\t\t\t\t     password_data->common.display_name,\n\t\t\t\t     sizeof(password_data->common.display_name));\n\tif (!strcmp(attr_name_kobj->name, SETUP_PASSWD))\n\t\treturn sysfs_create_group(attr_name_kobj, &password_attr_group);\n\n\treturn sysfs_create_group(attr_name_kobj, &password_attr_group);\n}\n\n \nvoid hp_exit_password_attributes(void)\n{\n\tint instance_id;\n\n\tfor (instance_id = 0; instance_id < bioscfg_drv.password_instances_count;\n\t     instance_id++) {\n\t\tstruct kobject *attr_name_kobj =\n\t\t\tbioscfg_drv.password_data[instance_id].attr_name_kobj;\n\n\t\tif (attr_name_kobj) {\n\t\t\tif (!strcmp(attr_name_kobj->name, SETUP_PASSWD))\n\t\t\t\tsysfs_remove_group(attr_name_kobj,\n\t\t\t\t\t\t   &password_attr_group);\n\t\t\telse\n\t\t\t\tsysfs_remove_group(attr_name_kobj,\n\t\t\t\t\t\t   &password_attr_group);\n\t\t}\n\t}\n\tbioscfg_drv.password_instances_count = 0;\n\tkfree(bioscfg_drv.password_data);\n\tbioscfg_drv.password_data = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}