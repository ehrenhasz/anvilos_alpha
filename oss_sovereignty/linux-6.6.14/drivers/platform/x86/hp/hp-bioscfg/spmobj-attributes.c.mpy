{
  "module_name": "spmobj-attributes.c",
  "hash_id": "a43ba64bd261862bcfda6ed4dc76478fd01e548496451ae2a6ff3dd7ca569ff2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/x86/hp/hp-bioscfg/spmobj-attributes.c",
  "human_readable_source": "\n \n\n#include \"bioscfg.h\"\n\nstatic const char * const spm_state_types[] = {\n\t\"not provisioned\",\n\t\"provisioned\",\n\t\"provisioning in progress\",\n};\n\nstatic const char * const spm_mechanism_types[] = {\n\t\"not provisioned\",\n\t\"signing-key\",\n\t\"endorsement-key\",\n};\n\nstruct secureplatform_provisioning_data {\n\tu8 state;\n\tu8 version[2];\n\tu8 reserved1;\n\tu32 features;\n\tu32 nonce;\n\tu8 reserved2[28];\n\tu8 sk_mod[MAX_KEY_MOD_SIZE];\n\tu8 kek_mod[MAX_KEY_MOD_SIZE];\n};\n\n \nsize_t hp_calculate_security_buffer(const char *authentication)\n{\n\tsize_t size, authlen;\n\n\tif (!authentication)\n\t\treturn sizeof(u16) * 2;\n\n\tauthlen = strlen(authentication);\n\tif (!authlen)\n\t\treturn sizeof(u16) * 2;\n\n\tsize = sizeof(u16) + authlen * sizeof(u16);\n\tif (!strstarts(authentication, BEAM_PREFIX))\n\t\tsize += strlen(UTF_PREFIX) * sizeof(u16);\n\n\treturn size;\n}\n\n \nint hp_populate_security_buffer(u16 *authbuf, const char *authentication)\n{\n\tu16 *auth = authbuf;\n\tchar *strprefix = NULL;\n\tint ret = 0;\n\n\tif (strstarts(authentication, BEAM_PREFIX)) {\n\t\t \n\t\t \n\t\tauth = hp_ascii_to_utf16_unicode(auth, authentication);\n\t\tif (!auth)\n\t\t\treturn -EINVAL;\n\n\t} else {\n\t\t \n\n\t\t \n\t\tstrprefix = kasprintf(GFP_KERNEL, \"%s%s\", UTF_PREFIX,\n\t\t\t\t      authentication);\n\t\tif (!strprefix)\n\t\t\treturn -ENOMEM;\n\n\t\tauth = hp_ascii_to_utf16_unicode(auth, strprefix);\n\t\tkfree(strprefix);\n\n\t\tif (!auth) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_buffer;\n\t\t}\n\t}\n\nout_buffer:\n\treturn ret;\n}\n\nstatic ssize_t update_spm_state(void)\n{\n\tstruct secureplatform_provisioning_data data;\n\tint ret;\n\n\tret = hp_wmi_perform_query(HPWMI_SECUREPLATFORM_GET_STATE,\n\t\t\t\t   HPWMI_SECUREPLATFORM, &data, 0,\n\t\t\t\t   sizeof(data));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tbioscfg_drv.spm_data.mechanism = data.state;\n\tif (bioscfg_drv.spm_data.mechanism)\n\t\tbioscfg_drv.spm_data.is_enabled = 1;\n\n\treturn 0;\n}\n\nstatic ssize_t statusbin(struct kobject *kobj,\n\t\t\t struct kobj_attribute *attr,\n\t\t\t struct secureplatform_provisioning_data *buf)\n{\n\tint ret = hp_wmi_perform_query(HPWMI_SECUREPLATFORM_GET_STATE,\n\t\t\t\t       HPWMI_SECUREPLATFORM, buf, 0,\n\t\t\t\t       sizeof(*buf));\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn sizeof(struct secureplatform_provisioning_data);\n}\n\n \nstatic ssize_t status_show(struct kobject *kobj, struct kobj_attribute\n\t\t\t   *attr, char *buf)\n{\n\tint ret, i;\n\tint len = 0;\n\tstruct secureplatform_provisioning_data data;\n\n\tret = statusbin(kobj, attr, &data);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\n\tlen += sysfs_emit_at(buf, len, \"{\\n\");\n\tlen += sysfs_emit_at(buf, len, \"\\t\\\"State\\\": \\\"%s\\\",\\n\",\n\t\t\t     spm_state_types[data.state]);\n\tlen += sysfs_emit_at(buf, len, \"\\t\\\"Version\\\": \\\"%d.%d\\\"\",\n\t\t\t     data.version[0], data.version[1]);\n\n\t \n\tif (data.state == 0) {\n\t\tlen += sysfs_emit_at(buf, len, \"\\n\");\n\t\tgoto status_exit;\n\t} else {\n\t\tlen += sysfs_emit_at(buf, len, \",\\n\");\n\t}\n\n\tlen += sysfs_emit_at(buf, len, \"\\t\\\"Nonce\\\": %d,\\n\", data.nonce);\n\tlen += sysfs_emit_at(buf, len, \"\\t\\\"FeaturesInUse\\\": %d,\\n\", data.features);\n\tlen += sysfs_emit_at(buf, len, \"\\t\\\"EndorsementKeyMod\\\": \\\"\");\n\n\tfor (i = 255; i >= 0; i--)\n\t\tlen += sysfs_emit_at(buf, len, \" %u\", data.kek_mod[i]);\n\n\tlen += sysfs_emit_at(buf, len, \" \\\",\\n\");\n\tlen += sysfs_emit_at(buf, len, \"\\t\\\"SigningKeyMod\\\": \\\"\");\n\n\tfor (i = 255; i >= 0; i--)\n\t\tlen += sysfs_emit_at(buf, len, \" %u\", data.sk_mod[i]);\n\n\t \n\tlen += sysfs_emit_at(buf, len, \" \\\"\\n\");\n\nstatus_exit:\n\tlen += sysfs_emit_at(buf, len, \"}\\n\");\n\n\treturn len;\n}\n\nstatic struct kobj_attribute password_spm_status = __ATTR_RO(status);\n\nATTRIBUTE_SPM_N_PROPERTY_SHOW(is_enabled, spm);\nstatic struct kobj_attribute password_spm_is_key_enabled = __ATTR_RO(is_enabled);\n\nstatic ssize_t key_mechanism_show(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t\t  char *buf)\n{\n\treturn sysfs_emit(buf, \"%s\\n\",\n\t\t\t  spm_mechanism_types[bioscfg_drv.spm_data.mechanism]);\n}\n\nstatic struct kobj_attribute password_spm_key_mechanism = __ATTR_RO(key_mechanism);\n\nstatic ssize_t sk_store(struct kobject *kobj,\n\t\t\tstruct kobj_attribute *attr,\n\t\t\tconst char *buf, size_t count)\n{\n\tint ret;\n\tint length;\n\n\tlength = count;\n\tif (buf[length - 1] == '\\n')\n\t\tlength--;\n\n\t \n\tbioscfg_drv.spm_data.signing_key = kmemdup(buf, length, GFP_KERNEL);\n\tif (!bioscfg_drv.spm_data.signing_key)\n\t\treturn -ENOMEM;\n\n\t \n\tret = hp_wmi_perform_query(HPWMI_SECUREPLATFORM_SET_SK,\n\t\t\t\t   HPWMI_SECUREPLATFORM,\n\t\t\t\t   (void *)bioscfg_drv.spm_data.signing_key,\n\t\t\t\t   count, 0);\n\n\tif (!ret) {\n\t\tbioscfg_drv.spm_data.mechanism = SIGNING_KEY;\n\t\thp_set_reboot_and_signal_event();\n\t}\n\n\tkfree(bioscfg_drv.spm_data.signing_key);\n\tbioscfg_drv.spm_data.signing_key = NULL;\n\n\treturn ret ? ret : count;\n}\n\nstatic struct kobj_attribute password_spm_signing_key = __ATTR_WO(sk);\n\nstatic ssize_t kek_store(struct kobject *kobj,\n\t\t\t struct kobj_attribute *attr,\n\t\t\t const char *buf, size_t count)\n{\n\tint ret;\n\tint length;\n\n\tlength = count;\n\tif (buf[length - 1] == '\\n')\n\t\tlength--;\n\n\t \n\tbioscfg_drv.spm_data.endorsement_key = kmemdup(buf, length, GFP_KERNEL);\n\tif (!bioscfg_drv.spm_data.endorsement_key) {\n\t\tret = -ENOMEM;\n\t\tgoto exit_kek;\n\t}\n\n\tret = hp_wmi_perform_query(HPWMI_SECUREPLATFORM_SET_KEK,\n\t\t\t\t   HPWMI_SECUREPLATFORM,\n\t\t\t\t   (void *)bioscfg_drv.spm_data.endorsement_key,\n\t\t\t\t   count, 0);\n\n\tif (!ret) {\n\t\tbioscfg_drv.spm_data.mechanism = ENDORSEMENT_KEY;\n\t\thp_set_reboot_and_signal_event();\n\t}\n\nexit_kek:\n\tkfree(bioscfg_drv.spm_data.endorsement_key);\n\tbioscfg_drv.spm_data.endorsement_key = NULL;\n\n\treturn ret ? ret : count;\n}\n\nstatic struct kobj_attribute password_spm_endorsement_key = __ATTR_WO(kek);\n\nstatic ssize_t role_show(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t char *buf)\n{\n\treturn sysfs_emit(buf, \"%s\\n\", BIOS_SPM);\n}\n\nstatic struct kobj_attribute password_spm_role = __ATTR_RO(role);\n\nstatic ssize_t auth_token_store(struct kobject *kobj,\n\t\t\t\tstruct kobj_attribute *attr,\n\t\t\t\tconst char *buf, size_t count)\n{\n\tint ret = 0;\n\tint length;\n\n\tlength = count;\n\tif (buf[length - 1] == '\\n')\n\t\tlength--;\n\n\t \n\tbioscfg_drv.spm_data.auth_token = kmemdup(buf, length, GFP_KERNEL);\n\tif (!bioscfg_drv.spm_data.auth_token) {\n\t\tret = -ENOMEM;\n\t\tgoto exit_token;\n\t}\n\n\treturn count;\n\nexit_token:\n\tkfree(bioscfg_drv.spm_data.auth_token);\n\tbioscfg_drv.spm_data.auth_token = NULL;\n\n\treturn ret;\n}\n\nstatic struct kobj_attribute password_spm_auth_token = __ATTR_WO(auth_token);\n\nstatic struct attribute *secure_platform_attrs[] = {\n\t&password_spm_is_key_enabled.attr,\n\t&password_spm_signing_key.attr,\n\t&password_spm_endorsement_key.attr,\n\t&password_spm_key_mechanism.attr,\n\t&password_spm_status.attr,\n\t&password_spm_role.attr,\n\t&password_spm_auth_token.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group secure_platform_attr_group = {\n\t.attrs = secure_platform_attrs,\n};\n\nvoid hp_exit_secure_platform_attributes(void)\n{\n\t \n\n\tkfree(bioscfg_drv.spm_data.endorsement_key);\n\tbioscfg_drv.spm_data.endorsement_key = NULL;\n\n\tkfree(bioscfg_drv.spm_data.signing_key);\n\tbioscfg_drv.spm_data.signing_key = NULL;\n\n\tkfree(bioscfg_drv.spm_data.auth_token);\n\tbioscfg_drv.spm_data.auth_token = NULL;\n\n\tif (bioscfg_drv.spm_data.attr_name_kobj)\n\t\tsysfs_remove_group(bioscfg_drv.spm_data.attr_name_kobj,\n\t\t\t\t   &secure_platform_attr_group);\n}\n\nint hp_populate_secure_platform_data(struct kobject *attr_name_kobj)\n{\n\t \n\tbioscfg_drv.spm_data.attr_name_kobj = attr_name_kobj;\n\n\tstrscpy(bioscfg_drv.spm_data.attribute_name, SPM_STR,\n\t\tsizeof(bioscfg_drv.spm_data.attribute_name));\n\n\tbioscfg_drv.spm_data.is_enabled = 0;\n\tbioscfg_drv.spm_data.mechanism = 0;\n\tbioscfg_drv.pending_reboot = false;\n\tupdate_spm_state();\n\n\tbioscfg_drv.spm_data.endorsement_key = NULL;\n\tbioscfg_drv.spm_data.signing_key = NULL;\n\tbioscfg_drv.spm_data.auth_token = NULL;\n\n\treturn sysfs_create_group(attr_name_kobj, &secure_platform_attr_group);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}