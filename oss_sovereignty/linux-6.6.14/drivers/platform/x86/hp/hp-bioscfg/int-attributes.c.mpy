{
  "module_name": "int-attributes.c",
  "hash_id": "ec798d1303bbff50151a4336a5ecf86947bb95198c8110d45074c061998809a3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/x86/hp/hp-bioscfg/int-attributes.c",
  "human_readable_source": "\n \n\n#include \"bioscfg.h\"\n\nGET_INSTANCE_ID(integer);\n\nstatic ssize_t current_value_show(struct kobject *kobj, struct kobj_attribute *attr, char *buf)\n{\n\tint instance_id = get_integer_instance_id(kobj);\n\n\tif (instance_id < 0)\n\t\treturn -EIO;\n\n\treturn sysfs_emit(buf, \"%d\\n\",\n\t\t\t  bioscfg_drv.integer_data[instance_id].current_value);\n}\n\n \nstatic int validate_integer_input(int instance_id, char *buf)\n{\n\tint in_val;\n\tint ret;\n\tstruct integer_data *integer_data = &bioscfg_drv.integer_data[instance_id];\n\n\t \n\tif (integer_data->common.is_readonly)\n\t\treturn -EIO;\n\n\tret = kstrtoint(buf, 10, &in_val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (in_val < integer_data->lower_bound ||\n\t    in_val > integer_data->upper_bound)\n\t\treturn -ERANGE;\n\n\treturn 0;\n}\n\nstatic void update_integer_value(int instance_id, char *attr_value)\n{\n\tint in_val;\n\tint ret;\n\tstruct integer_data *integer_data = &bioscfg_drv.integer_data[instance_id];\n\n\tret = kstrtoint(attr_value, 10, &in_val);\n\tif (ret == 0)\n\t\tinteger_data->current_value = in_val;\n\telse\n\t\tpr_warn(\"Invalid integer value found: %s\\n\", attr_value);\n}\n\nATTRIBUTE_S_COMMON_PROPERTY_SHOW(display_name, integer);\nstatic struct kobj_attribute integer_display_name =\n\t__ATTR_RO(display_name);\n\nATTRIBUTE_PROPERTY_STORE(current_value, integer);\nstatic struct kobj_attribute integer_current_val =\n\t__ATTR_RW_MODE(current_value, 0644);\n\nATTRIBUTE_N_PROPERTY_SHOW(lower_bound, integer);\nstatic struct kobj_attribute integer_lower_bound =\n\t__ATTR_RO(lower_bound);\n\nATTRIBUTE_N_PROPERTY_SHOW(upper_bound, integer);\nstatic struct kobj_attribute integer_upper_bound =\n\t__ATTR_RO(upper_bound);\n\nATTRIBUTE_N_PROPERTY_SHOW(scalar_increment, integer);\nstatic struct kobj_attribute integer_scalar_increment =\n\t__ATTR_RO(scalar_increment);\n\nstatic ssize_t type_show(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t char *buf)\n{\n\treturn sysfs_emit(buf, \"integer\\n\");\n}\n\nstatic struct kobj_attribute integer_type =\n\t__ATTR_RO(type);\n\nstatic struct attribute *integer_attrs[] = {\n\t&common_display_langcode.attr,\n\t&integer_display_name.attr,\n\t&integer_current_val.attr,\n\t&integer_lower_bound.attr,\n\t&integer_upper_bound.attr,\n\t&integer_scalar_increment.attr,\n\t&integer_type.attr,\n\tNULL\n};\n\nstatic const struct attribute_group integer_attr_group = {\n\t.attrs = integer_attrs,\n};\n\nint hp_alloc_integer_data(void)\n{\n\tbioscfg_drv.integer_instances_count = hp_get_instance_count(HP_WMI_BIOS_INTEGER_GUID);\n\tbioscfg_drv.integer_data = kcalloc(bioscfg_drv.integer_instances_count,\n\t\t\t\t\t   sizeof(*bioscfg_drv.integer_data), GFP_KERNEL);\n\n\tif (!bioscfg_drv.integer_data) {\n\t\tbioscfg_drv.integer_instances_count = 0;\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}\n\n \nstatic const acpi_object_type expected_integer_types[] = {\n\t[NAME] = ACPI_TYPE_STRING,\n\t[VALUE] = ACPI_TYPE_STRING,\n\t[PATH] = ACPI_TYPE_STRING,\n\t[IS_READONLY] = ACPI_TYPE_INTEGER,\n\t[DISPLAY_IN_UI] = ACPI_TYPE_INTEGER,\n\t[REQUIRES_PHYSICAL_PRESENCE] = ACPI_TYPE_INTEGER,\n\t[SEQUENCE] = ACPI_TYPE_INTEGER,\n\t[PREREQUISITES_SIZE] = ACPI_TYPE_INTEGER,\n\t[PREREQUISITES] = ACPI_TYPE_STRING,\n\t[SECURITY_LEVEL] = ACPI_TYPE_INTEGER,\n\t[INT_LOWER_BOUND] = ACPI_TYPE_INTEGER,\n\t[INT_UPPER_BOUND] = ACPI_TYPE_INTEGER,\n\t[INT_SCALAR_INCREMENT] = ACPI_TYPE_INTEGER,\n};\n\nstatic int hp_populate_integer_elements_from_package(union acpi_object *integer_obj,\n\t\t\t\t\t\t     int integer_obj_count,\n\t\t\t\t\t\t     int instance_id)\n{\n\tchar *str_value = NULL;\n\tint value_len;\n\tint ret;\n\tu32 int_value = 0;\n\tint elem;\n\tint reqs;\n\tint eloc;\n\tint size;\n\tstruct integer_data *integer_data = &bioscfg_drv.integer_data[instance_id];\n\n\tif (!integer_obj)\n\t\treturn -EINVAL;\n\n\tfor (elem = 1, eloc = 1; elem < integer_obj_count; elem++, eloc++) {\n\t\t \n\t\tif (eloc == INT_ELEM_CNT)\n\t\t\tgoto exit_integer_package;\n\n\t\tswitch (integer_obj[elem].type) {\n\t\tcase ACPI_TYPE_STRING:\n\t\t\tif (elem != PREREQUISITES) {\n\t\t\t\tret = hp_convert_hexstr_to_str(integer_obj[elem].string.pointer,\n\t\t\t\t\t\t\t       integer_obj[elem].string.length,\n\t\t\t\t\t\t\t       &str_value, &value_len);\n\t\t\t\tif (ret)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ACPI_TYPE_INTEGER:\n\t\t\tint_value = (u32)integer_obj[elem].integer.value;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_warn(\"Unsupported object type [%d]\\n\", integer_obj[elem].type);\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\tif (expected_integer_types[eloc] != integer_obj[elem].type) {\n\t\t\tpr_err(\"Error expected type %d for elem %d, but got type %d instead\\n\",\n\t\t\t       expected_integer_types[eloc], elem, integer_obj[elem].type);\n\t\t\tkfree(str_value);\n\t\t\treturn -EIO;\n\t\t}\n\t\t \n\t\tswitch (eloc) {\n\t\tcase VALUE:\n\t\t\tret = kstrtoint(str_value, 10, &int_value);\n\t\t\tif (ret)\n\t\t\t\tcontinue;\n\n\t\t\tinteger_data->current_value = int_value;\n\t\t\tbreak;\n\t\tcase PATH:\n\t\t\tstrscpy(integer_data->common.path, str_value,\n\t\t\t\tsizeof(integer_data->common.path));\n\t\t\tbreak;\n\t\tcase IS_READONLY:\n\t\t\tinteger_data->common.is_readonly = int_value;\n\t\t\tbreak;\n\t\tcase DISPLAY_IN_UI:\n\t\t\tinteger_data->common.display_in_ui = int_value;\n\t\t\tbreak;\n\t\tcase REQUIRES_PHYSICAL_PRESENCE:\n\t\t\tinteger_data->common.requires_physical_presence = int_value;\n\t\t\tbreak;\n\t\tcase SEQUENCE:\n\t\t\tinteger_data->common.sequence = int_value;\n\t\t\tbreak;\n\t\tcase PREREQUISITES_SIZE:\n\t\t\tif (int_value > MAX_PREREQUISITES_SIZE) {\n\t\t\t\tpr_warn(\"Prerequisites size value exceeded the maximum number of elements supported or data may be malformed\\n\");\n\t\t\t\tint_value = MAX_PREREQUISITES_SIZE;\n\t\t\t}\n\t\t\tinteger_data->common.prerequisites_size = int_value;\n\n\t\t\t \n\t\t\tif (integer_data->common.prerequisites_size == 0)\n\t\t\t\teloc++;\n\t\t\tbreak;\n\t\tcase PREREQUISITES:\n\t\t\tsize = min_t(u32, integer_data->common.prerequisites_size, MAX_PREREQUISITES_SIZE);\n\n\t\t\tfor (reqs = 0; reqs < size; reqs++) {\n\t\t\t\tif (elem >= integer_obj_count) {\n\t\t\t\t\tpr_err(\"Error elem-objects package is too small\\n\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\n\t\t\t\tret = hp_convert_hexstr_to_str(integer_obj[elem + reqs].string.pointer,\n\t\t\t\t\t\t\t       integer_obj[elem + reqs].string.length,\n\t\t\t\t\t\t\t       &str_value, &value_len);\n\n\t\t\t\tif (ret)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tstrscpy(integer_data->common.prerequisites[reqs],\n\t\t\t\t\tstr_value,\n\t\t\t\t\tsizeof(integer_data->common.prerequisites[reqs]));\n\t\t\t\tkfree(str_value);\n\t\t\t\tstr_value = NULL;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase SECURITY_LEVEL:\n\t\t\tinteger_data->common.security_level = int_value;\n\t\t\tbreak;\n\t\tcase INT_LOWER_BOUND:\n\t\t\tinteger_data->lower_bound = int_value;\n\t\t\tbreak;\n\t\tcase INT_UPPER_BOUND:\n\t\t\tinteger_data->upper_bound = int_value;\n\t\t\tbreak;\n\t\tcase INT_SCALAR_INCREMENT:\n\t\t\tinteger_data->scalar_increment = int_value;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_warn(\"Invalid element: %d found in Integer attribute or data may be malformed\\n\", elem);\n\t\t\tbreak;\n\t\t}\n\n\t\tkfree(str_value);\n\t\tstr_value = NULL;\n\t}\nexit_integer_package:\n\tkfree(str_value);\n\treturn 0;\n}\n\n \nint hp_populate_integer_package_data(union acpi_object *integer_obj,\n\t\t\t\t     int instance_id,\n\t\t\t\t     struct kobject *attr_name_kobj)\n{\n\tstruct integer_data *integer_data = &bioscfg_drv.integer_data[instance_id];\n\n\tinteger_data->attr_name_kobj = attr_name_kobj;\n\thp_populate_integer_elements_from_package(integer_obj,\n\t\t\t\t\t\t  integer_obj->package.count,\n\t\t\t\t\t\t  instance_id);\n\thp_update_attribute_permissions(integer_data->common.is_readonly,\n\t\t\t\t\t&integer_current_val);\n\thp_friendly_user_name_update(integer_data->common.path,\n\t\t\t\t     attr_name_kobj->name,\n\t\t\t\t     integer_data->common.display_name,\n\t\t\t\t     sizeof(integer_data->common.display_name));\n\treturn sysfs_create_group(attr_name_kobj, &integer_attr_group);\n}\n\nstatic int hp_populate_integer_elements_from_buffer(u8 *buffer_ptr, u32 *buffer_size,\n\t\t\t\t\t\t    int instance_id)\n{\n\tchar *dst = NULL;\n\tint dst_size = *buffer_size / sizeof(u16);\n\tstruct integer_data *integer_data = &bioscfg_drv.integer_data[instance_id];\n\tint ret = 0;\n\n\tdst = kcalloc(dst_size, sizeof(char), GFP_KERNEL);\n\tif (!dst)\n\t\treturn -ENOMEM;\n\n\t \n\n\t\n\tinteger_data->current_value = 0;\n\n\thp_get_string_from_buffer(&buffer_ptr, buffer_size, dst, dst_size);\n\tret = kstrtoint(dst, 10, &integer_data->current_value);\n\tif (ret)\n\t\tpr_warn(\"Unable to convert string to integer: %s\\n\", dst);\n\tkfree(dst);\n\n\t\n\tret = hp_get_common_data_from_buffer(&buffer_ptr, buffer_size, &integer_data->common);\n\tif (ret < 0)\n\t\tgoto buffer_exit;\n\n\t\n\tret = hp_get_integer_from_buffer(&buffer_ptr, buffer_size,\n\t\t\t\t\t &integer_data->lower_bound);\n\tif (ret < 0)\n\t\tgoto buffer_exit;\n\n\t\n\tret = hp_get_integer_from_buffer(&buffer_ptr, buffer_size,\n\t\t\t\t\t &integer_data->upper_bound);\n\tif (ret < 0)\n\t\tgoto buffer_exit;\n\n\t\n\tret = hp_get_integer_from_buffer(&buffer_ptr, buffer_size,\n\t\t\t\t\t &integer_data->scalar_increment);\n\nbuffer_exit:\n\treturn ret;\n}\n\n \nint hp_populate_integer_buffer_data(u8 *buffer_ptr, u32 *buffer_size, int instance_id,\n\t\t\t\t    struct kobject *attr_name_kobj)\n{\n\tstruct integer_data *integer_data = &bioscfg_drv.integer_data[instance_id];\n\tint ret = 0;\n\n\tinteger_data->attr_name_kobj = attr_name_kobj;\n\n\t \n\tret = hp_populate_integer_elements_from_buffer(buffer_ptr, buffer_size,\n\t\t\t\t\t\t       instance_id);\n\tif (ret < 0)\n\t\treturn ret;\n\n\thp_update_attribute_permissions(integer_data->common.is_readonly,\n\t\t\t\t\t&integer_current_val);\n\thp_friendly_user_name_update(integer_data->common.path,\n\t\t\t\t     attr_name_kobj->name,\n\t\t\t\t     integer_data->common.display_name,\n\t\t\t\t     sizeof(integer_data->common.display_name));\n\n\treturn sysfs_create_group(attr_name_kobj, &integer_attr_group);\n}\n\n \nvoid hp_exit_integer_attributes(void)\n{\n\tint instance_id;\n\n\tfor (instance_id = 0; instance_id < bioscfg_drv.integer_instances_count;\n\t     instance_id++) {\n\t\tstruct kobject *attr_name_kobj =\n\t\t\tbioscfg_drv.integer_data[instance_id].attr_name_kobj;\n\n\t\tif (attr_name_kobj)\n\t\t\tsysfs_remove_group(attr_name_kobj, &integer_attr_group);\n\t}\n\tbioscfg_drv.integer_instances_count = 0;\n\n\tkfree(bioscfg_drv.integer_data);\n\tbioscfg_drv.integer_data = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}