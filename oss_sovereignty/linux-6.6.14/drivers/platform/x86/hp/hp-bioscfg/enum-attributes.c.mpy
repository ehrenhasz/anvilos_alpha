{
  "module_name": "enum-attributes.c",
  "hash_id": "e76aec73ab66e8763ce97f151b4781d5107d78c1d1503085ab3b0d2942b5e17c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/x86/hp/hp-bioscfg/enum-attributes.c",
  "human_readable_source": "\n \n\n#include \"bioscfg.h\"\n\nGET_INSTANCE_ID(enumeration);\n\nstatic ssize_t current_value_show(struct kobject *kobj, struct kobj_attribute *attr, char *buf)\n{\n\tint instance_id = get_enumeration_instance_id(kobj);\n\n\tif (instance_id < 0)\n\t\treturn -EIO;\n\n\treturn sysfs_emit(buf, \"%s\\n\",\n\t\t\t bioscfg_drv.enumeration_data[instance_id].current_value);\n}\n\n \nstatic int validate_enumeration_input(int instance_id, const char *buf)\n{\n\tint i;\n\tint found = 0;\n\tstruct enumeration_data *enum_data = &bioscfg_drv.enumeration_data[instance_id];\n\n\t \n\tif (enum_data->common.is_readonly)\n\t\treturn -EIO;\n\n\tfor (i = 0; i < enum_data->possible_values_size && !found; i++)\n\t\tif (!strcmp(enum_data->possible_values[i], buf))\n\t\t\tfound = 1;\n\n\tif (!found)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic void update_enumeration_value(int instance_id, char *attr_value)\n{\n\tstruct enumeration_data *enum_data = &bioscfg_drv.enumeration_data[instance_id];\n\n\tstrscpy(enum_data->current_value,\n\t\tattr_value,\n\t\tsizeof(enum_data->current_value));\n}\n\nATTRIBUTE_S_COMMON_PROPERTY_SHOW(display_name, enumeration);\nstatic struct kobj_attribute enumeration_display_name =\n\t\t__ATTR_RO(display_name);\n\nATTRIBUTE_PROPERTY_STORE(current_value, enumeration);\nstatic struct kobj_attribute enumeration_current_val =\n\t\t__ATTR_RW(current_value);\n\nATTRIBUTE_VALUES_PROPERTY_SHOW(possible_values, enumeration, SEMICOLON_SEP);\nstatic struct kobj_attribute enumeration_poss_val =\n\t\t__ATTR_RO(possible_values);\n\nstatic ssize_t type_show(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t char *buf)\n{\n\treturn sysfs_emit(buf, \"enumeration\\n\");\n}\n\nstatic struct kobj_attribute enumeration_type =\n\t\t__ATTR_RO(type);\n\nstatic struct attribute *enumeration_attrs[] = {\n\t&common_display_langcode.attr,\n\t&enumeration_display_name.attr,\n\t&enumeration_current_val.attr,\n\t&enumeration_poss_val.attr,\n\t&enumeration_type.attr,\n\tNULL\n};\n\nstatic const struct attribute_group enumeration_attr_group = {\n\t.attrs = enumeration_attrs,\n};\n\nint hp_alloc_enumeration_data(void)\n{\n\tbioscfg_drv.enumeration_instances_count =\n\t\thp_get_instance_count(HP_WMI_BIOS_ENUMERATION_GUID);\n\n\tbioscfg_drv.enumeration_data = kcalloc(bioscfg_drv.enumeration_instances_count,\n\t\t\t\t\t       sizeof(*bioscfg_drv.enumeration_data), GFP_KERNEL);\n\tif (!bioscfg_drv.enumeration_data) {\n\t\tbioscfg_drv.enumeration_instances_count = 0;\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}\n\n \nstatic const acpi_object_type expected_enum_types[] = {\n\t[NAME] = ACPI_TYPE_STRING,\n\t[VALUE] = ACPI_TYPE_STRING,\n\t[PATH] = ACPI_TYPE_STRING,\n\t[IS_READONLY] = ACPI_TYPE_INTEGER,\n\t[DISPLAY_IN_UI] = ACPI_TYPE_INTEGER,\n\t[REQUIRES_PHYSICAL_PRESENCE] = ACPI_TYPE_INTEGER,\n\t[SEQUENCE] = ACPI_TYPE_INTEGER,\n\t[PREREQUISITES_SIZE] = ACPI_TYPE_INTEGER,\n\t[PREREQUISITES] = ACPI_TYPE_STRING,\n\t[SECURITY_LEVEL] = ACPI_TYPE_INTEGER,\n\t[ENUM_CURRENT_VALUE] = ACPI_TYPE_STRING,\n\t[ENUM_SIZE] = ACPI_TYPE_INTEGER,\n\t[ENUM_POSSIBLE_VALUES] = ACPI_TYPE_STRING,\n};\n\nstatic int hp_populate_enumeration_elements_from_package(union acpi_object *enum_obj,\n\t\t\t\t\t\t\t int enum_obj_count,\n\t\t\t\t\t\t\t int instance_id)\n{\n\tchar *str_value = NULL;\n\tint value_len;\n\tu32 size = 0;\n\tu32 int_value = 0;\n\tint elem = 0;\n\tint reqs;\n\tint pos_values;\n\tint ret;\n\tint eloc;\n\tstruct enumeration_data *enum_data = &bioscfg_drv.enumeration_data[instance_id];\n\n\tfor (elem = 1, eloc = 1; elem < enum_obj_count; elem++, eloc++) {\n\t\t \n\t\tif (eloc == ENUM_ELEM_CNT)\n\t\t\tgoto exit_enumeration_package;\n\n\t\tswitch (enum_obj[elem].type) {\n\t\tcase ACPI_TYPE_STRING:\n\t\t\tif (PREREQUISITES != elem && ENUM_POSSIBLE_VALUES != elem) {\n\t\t\t\tret = hp_convert_hexstr_to_str(enum_obj[elem].string.pointer,\n\t\t\t\t\t\t\t       enum_obj[elem].string.length,\n\t\t\t\t\t\t\t       &str_value, &value_len);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ACPI_TYPE_INTEGER:\n\t\t\tint_value = (u32)enum_obj[elem].integer.value;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_warn(\"Unsupported object type [%d]\\n\", enum_obj[elem].type);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (expected_enum_types[eloc] != enum_obj[elem].type) {\n\t\t\tpr_err(\"Error expected type %d for elem %d, but got type %d instead\\n\",\n\t\t\t       expected_enum_types[eloc], elem, enum_obj[elem].type);\n\t\t\tkfree(str_value);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\t \n\t\tswitch (eloc) {\n\t\tcase NAME:\n\t\tcase VALUE:\n\t\t\tbreak;\n\t\tcase PATH:\n\t\t\tstrscpy(enum_data->common.path, str_value,\n\t\t\t\tsizeof(enum_data->common.path));\n\t\t\tbreak;\n\t\tcase IS_READONLY:\n\t\t\tenum_data->common.is_readonly = int_value;\n\t\t\tbreak;\n\t\tcase DISPLAY_IN_UI:\n\t\t\tenum_data->common.display_in_ui = int_value;\n\t\t\tbreak;\n\t\tcase REQUIRES_PHYSICAL_PRESENCE:\n\t\t\tenum_data->common.requires_physical_presence = int_value;\n\t\t\tbreak;\n\t\tcase SEQUENCE:\n\t\t\tenum_data->common.sequence = int_value;\n\t\t\tbreak;\n\t\tcase PREREQUISITES_SIZE:\n\t\t\tif (int_value > MAX_PREREQUISITES_SIZE) {\n\t\t\t\tpr_warn(\"Prerequisites size value exceeded the maximum number of elements supported or data may be malformed\\n\");\n\t\t\t\tint_value = MAX_PREREQUISITES_SIZE;\n\t\t\t}\n\t\t\tenum_data->common.prerequisites_size = int_value;\n\n\t\t\t \n\t\t\tif (int_value == 0)\n\t\t\t\teloc++;\n\t\t\tbreak;\n\n\t\tcase PREREQUISITES:\n\t\t\tsize = min_t(u32, enum_data->common.prerequisites_size, MAX_PREREQUISITES_SIZE);\n\t\t\tfor (reqs = 0; reqs < size; reqs++) {\n\t\t\t\tif (elem >= enum_obj_count) {\n\t\t\t\t\tpr_err(\"Error enum-objects package is too small\\n\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\n\t\t\t\tret = hp_convert_hexstr_to_str(enum_obj[elem + reqs].string.pointer,\n\t\t\t\t\t\t\t       enum_obj[elem + reqs].string.length,\n\t\t\t\t\t\t\t       &str_value, &value_len);\n\n\t\t\t\tif (ret)\n\t\t\t\t\treturn -EINVAL;\n\n\t\t\t\tstrscpy(enum_data->common.prerequisites[reqs],\n\t\t\t\t\tstr_value,\n\t\t\t\t\tsizeof(enum_data->common.prerequisites[reqs]));\n\n\t\t\t\tkfree(str_value);\n\t\t\t\tstr_value = NULL;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase SECURITY_LEVEL:\n\t\t\tenum_data->common.security_level = int_value;\n\t\t\tbreak;\n\n\t\tcase ENUM_CURRENT_VALUE:\n\t\t\tstrscpy(enum_data->current_value,\n\t\t\t\tstr_value, sizeof(enum_data->current_value));\n\t\t\tbreak;\n\t\tcase ENUM_SIZE:\n\t\t\tif (int_value > MAX_VALUES_SIZE) {\n\t\t\t\tpr_warn(\"Possible number values size value exceeded the maximum number of elements supported or data may be malformed\\n\");\n\t\t\t\tint_value = MAX_VALUES_SIZE;\n\t\t\t}\n\t\t\tenum_data->possible_values_size = int_value;\n\n\t\t\t \n\t\t\tif (int_value == 0)\n\t\t\t\teloc++;\n\t\t\tbreak;\n\n\t\tcase ENUM_POSSIBLE_VALUES:\n\t\t\tsize = enum_data->possible_values_size;\n\n\t\t\tfor (pos_values = 0; pos_values < size && pos_values < MAX_VALUES_SIZE;\n\t\t\t     pos_values++) {\n\t\t\t\tif (elem >= enum_obj_count) {\n\t\t\t\t\tpr_err(\"Error enum-objects package is too small\\n\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\n\t\t\t\tret = hp_convert_hexstr_to_str(enum_obj[elem + pos_values].string.pointer,\n\t\t\t\t\t\t\t       enum_obj[elem + pos_values].string.length,\n\t\t\t\t\t\t\t       &str_value, &value_len);\n\n\t\t\t\tif (ret)\n\t\t\t\t\treturn -EINVAL;\n\n\t\t\t\t \n\t\t\t\tif (size < MAX_VALUES_SIZE)\n\t\t\t\t\tstrscpy(enum_data->possible_values[pos_values],\n\t\t\t\t\t\tstr_value,\n\t\t\t\t\t\tsizeof(enum_data->possible_values[pos_values]));\n\n\t\t\t\tkfree(str_value);\n\t\t\t\tstr_value = NULL;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_warn(\"Invalid element: %d found in Enumeration attribute or data may be malformed\\n\", elem);\n\t\t\tbreak;\n\t\t}\n\n\t\tkfree(str_value);\n\t\tstr_value = NULL;\n\t}\n\nexit_enumeration_package:\n\tkfree(str_value);\n\treturn 0;\n}\n\n \nint hp_populate_enumeration_package_data(union acpi_object *enum_obj,\n\t\t\t\t\t int instance_id,\n\t\t\t\t\t struct kobject *attr_name_kobj)\n{\n\tstruct enumeration_data *enum_data = &bioscfg_drv.enumeration_data[instance_id];\n\n\tenum_data->attr_name_kobj = attr_name_kobj;\n\n\thp_populate_enumeration_elements_from_package(enum_obj,\n\t\t\t\t\t\t      enum_obj->package.count,\n\t\t\t\t\t\t      instance_id);\n\thp_update_attribute_permissions(enum_data->common.is_readonly,\n\t\t\t\t\t&enumeration_current_val);\n\t \n\thp_friendly_user_name_update(enum_data->common.path,\n\t\t\t\t     attr_name_kobj->name,\n\t\t\t\t     enum_data->common.display_name,\n\t\t\t\t     sizeof(enum_data->common.display_name));\n\treturn sysfs_create_group(attr_name_kobj, &enumeration_attr_group);\n}\n\nstatic int hp_populate_enumeration_elements_from_buffer(u8 *buffer_ptr, u32 *buffer_size,\n\t\t\t\t\t\t\tint instance_id)\n{\n\tint values;\n\tstruct enumeration_data *enum_data = &bioscfg_drv.enumeration_data[instance_id];\n\tint ret = 0;\n\n\t \n\n\t\n\tret = hp_get_string_from_buffer(&buffer_ptr, buffer_size, enum_data->current_value,\n\t\t\t\t\tsizeof(enum_data->current_value));\n\tif (ret < 0)\n\t\tgoto buffer_exit;\n\n\t\n\tret = hp_get_common_data_from_buffer(&buffer_ptr, buffer_size, &enum_data->common);\n\tif (ret < 0)\n\t\tgoto buffer_exit;\n\n\t\n\tret = hp_get_string_from_buffer(&buffer_ptr, buffer_size,\n\t\t\t\t\tenum_data->current_value,\n\t\t\t\t\tsizeof(enum_data->current_value));\n\tif (ret < 0)\n\t\tgoto buffer_exit;\n\n\t\n\tret = hp_get_integer_from_buffer(&buffer_ptr, buffer_size,\n\t\t\t\t\t &enum_data->possible_values_size);\n\n\tif (enum_data->possible_values_size > MAX_VALUES_SIZE) {\n\t\t \n\t\tpr_warn(\"Enum Possible size value exceeded the maximum number of elements supported or data may be malformed\\n\");\n\t\tenum_data->possible_values_size = MAX_VALUES_SIZE;\n\t}\n\n\t\n\tfor (values = 0; values < enum_data->possible_values_size; values++) {\n\t\tret = hp_get_string_from_buffer(&buffer_ptr, buffer_size,\n\t\t\t\t\t\tenum_data->possible_values[values],\n\t\t\t\t\t\tsizeof(enum_data->possible_values[values]));\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\nbuffer_exit:\n\treturn ret;\n}\n\n \nint hp_populate_enumeration_buffer_data(u8 *buffer_ptr, u32 *buffer_size,\n\t\t\t\t\tint instance_id,\n\t\t\t\t\tstruct kobject *attr_name_kobj)\n{\n\tstruct enumeration_data *enum_data = &bioscfg_drv.enumeration_data[instance_id];\n\tint ret = 0;\n\n\tenum_data->attr_name_kobj = attr_name_kobj;\n\n\t \n\tret = hp_populate_enumeration_elements_from_buffer(buffer_ptr, buffer_size,\n\t\t\t\t\t\t\t   instance_id);\n\tif (ret < 0)\n\t\treturn ret;\n\n\thp_update_attribute_permissions(enum_data->common.is_readonly,\n\t\t\t\t\t&enumeration_current_val);\n\t \n\thp_friendly_user_name_update(enum_data->common.path,\n\t\t\t\t     attr_name_kobj->name,\n\t\t\t\t     enum_data->common.display_name,\n\t\t\t\t     sizeof(enum_data->common.display_name));\n\n\treturn sysfs_create_group(attr_name_kobj, &enumeration_attr_group);\n}\n\n \nvoid hp_exit_enumeration_attributes(void)\n{\n\tint instance_id;\n\n\tfor (instance_id = 0; instance_id < bioscfg_drv.enumeration_instances_count;\n\t     instance_id++) {\n\t\tstruct enumeration_data *enum_data = &bioscfg_drv.enumeration_data[instance_id];\n\t\tstruct kobject *attr_name_kobj = enum_data->attr_name_kobj;\n\n\t\tif (attr_name_kobj)\n\t\t\tsysfs_remove_group(attr_name_kobj, &enumeration_attr_group);\n\t}\n\tbioscfg_drv.enumeration_instances_count = 0;\n\n\tkfree(bioscfg_drv.enumeration_data);\n\tbioscfg_drv.enumeration_data = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}