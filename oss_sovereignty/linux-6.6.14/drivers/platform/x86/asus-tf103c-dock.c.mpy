{
  "module_name": "asus-tf103c-dock.c",
  "hash_id": "bc0d82be1b5eea71e3ddedceff15e2e8d7fc5cc389c866c527dc922117f1fc7e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/x86/asus-tf103c-dock.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/delay.h>\n#include <linux/dmi.h>\n#include <linux/gpio/consumer.h>\n#include <linux/gpio/machine.h>\n#include <linux/hid.h>\n#include <linux/i2c.h>\n#include <linux/input.h>\n#include <linux/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/pm.h>\n#include <linux/workqueue.h>\n#include <asm/unaligned.h>\n\nstatic bool fnlock;\nmodule_param(fnlock, bool, 0644);\nMODULE_PARM_DESC(fnlock,\n\t\t \"By default the kbd toprow sends multimedia key presses. AltGr \"\n\t\t \"can be pressed to change this to F1-F12. Set this to 1 to \"\n\t\t \"change the default. Press AltGr + Esc to toggle at runtime.\");\n\n#define TF103C_DOCK_DEV_NAME\t\t\t\t\"NPCE69A:00\"\n\n#define TF103C_DOCK_HPD_DEBOUNCE\t\t\tmsecs_to_jiffies(20)\n\n \n#define TF103C_DOCK_TP_ADDR\t\t\t\t0x15\n\n \n#define TF103C_DOCK_KBD_ADDR\t\t\t\t0x16\n\n#define TF103C_DOCK_KBD_DATA_REG\t\t\t0x73\n#define TF103C_DOCK_KBD_DATA_MIN_LENGTH\t\t\t4\n#define TF103C_DOCK_KBD_DATA_MAX_LENGTH\t\t\t11\n#define TF103C_DOCK_KBD_DATA_MODIFIERS\t\t\t3\n#define TF103C_DOCK_KBD_DATA_KEYS\t\t\t5\n#define TF103C_DOCK_KBD_CMD_REG\t\t\t\t0x75\n\n#define TF103C_DOCK_KBD_CMD_ENABLE\t\t\t0x0800\n\n \n#define TF103C_DOCK_INTR_ADDR\t\t\t\t0x19\n#define TF103C_DOCK_INTR_DATA_REG\t\t\t0x6a\n\n#define TF103C_DOCK_INTR_DATA1_OBF_MASK\t\t\t0x01\n#define TF103C_DOCK_INTR_DATA1_KEY_MASK\t\t\t0x04\n#define TF103C_DOCK_INTR_DATA1_KBC_MASK\t\t\t0x08\n#define TF103C_DOCK_INTR_DATA1_AUX_MASK\t\t\t0x20\n#define TF103C_DOCK_INTR_DATA1_SCI_MASK\t\t\t0x40\n#define TF103C_DOCK_INTR_DATA1_SMI_MASK\t\t\t0x80\n \n#define TF103C_DOCK_INTR_DATA1_OOB_VALUE\t\t0xc1\n#define TF103C_DOCK_INTR_DATA2_OOB_VALUE\t\t0x04\n\n#define TF103C_DOCK_SMI_AC_EVENT\t\t\t0x31\n#define TF103C_DOCK_SMI_HANDSHAKING\t\t\t0x50\n#define TF103C_DOCK_SMI_EC_WAKEUP\t\t\t0x53\n#define TF103C_DOCK_SMI_BOOTBLOCK_RESET\t\t\t0x5e\n#define TF103C_DOCK_SMI_WATCHDOG_RESET\t\t\t0x5f\n#define TF103C_DOCK_SMI_ADAPTER_CHANGE\t\t\t0x60\n#define TF103C_DOCK_SMI_DOCK_INSERT\t\t\t0x61\n#define TF103C_DOCK_SMI_DOCK_REMOVE\t\t\t0x62\n#define TF103C_DOCK_SMI_PAD_BL_CHANGE\t\t\t0x63\n#define TF103C_DOCK_SMI_HID_STATUS_CHANGED\t\t0x64\n#define TF103C_DOCK_SMI_HID_WAKEUP\t\t\t0x65\n#define TF103C_DOCK_SMI_S3\t\t\t\t0x83\n#define TF103C_DOCK_SMI_S5\t\t\t\t0x85\n#define TF103C_DOCK_SMI_NOTIFY_SHUTDOWN\t\t\t0x90\n#define TF103C_DOCK_SMI_RESUME\t\t\t\t0x91\n\n \n#define TF103C_DOCK_EC_ADDR\t\t\t\t0x1b\n\n#define TF103C_DOCK_EC_CMD_REG\t\t\t\t0x0a\n#define TF103C_DOCK_EC_CMD_LEN\t\t\t\t9\n\nenum {\n\tTF103C_DOCK_FLAG_HID_OPEN,\n};\n\nstruct tf103c_dock_data {\n\tstruct delayed_work hpd_work;\n\tstruct irq_chip tp_irqchip;\n\tstruct irq_domain *tp_irq_domain;\n\tstruct i2c_client *ec_client;\n\tstruct i2c_client *intr_client;\n\tstruct i2c_client *kbd_client;\n\tstruct i2c_client *tp_client;\n\tstruct gpio_desc *pwr_en;\n\tstruct gpio_desc *irq_gpio;\n\tstruct gpio_desc *hpd_gpio;\n\tstruct input_dev *input;\n\tstruct hid_device *hid;\n\tunsigned long flags;\n\tint board_rev;\n\tint irq;\n\tint hpd_irq;\n\tint tp_irq;\n\tint last_press_0x13;\n\tint last_press_0x14;\n\tbool enabled;\n\tbool tp_enabled;\n\tbool altgr_pressed;\n\tbool esc_pressed;\n\tbool filter_esc;\n\tu8 kbd_buf[TF103C_DOCK_KBD_DATA_MAX_LENGTH];\n};\n\nstatic struct gpiod_lookup_table tf103c_dock_gpios = {\n\t.dev_id = \"i2c-\" TF103C_DOCK_DEV_NAME,\n\t.table = {\n\t\tGPIO_LOOKUP(\"INT33FC:00\",      55, \"dock_pwr_en\", GPIO_ACTIVE_HIGH),\n\t\tGPIO_LOOKUP(\"INT33FC:02\",       1, \"dock_irq\", GPIO_ACTIVE_HIGH),\n\t\tGPIO_LOOKUP(\"INT33FC:02\",      29, \"dock_hpd\", GPIO_ACTIVE_HIGH),\n\t\tGPIO_LOOKUP(\"gpio_crystalcove\", 2, \"board_rev\", GPIO_ACTIVE_HIGH),\n\t\t{}\n\t},\n};\n\n \nstatic const u8 tf103c_dock_enable_cmd[9] = { 8, 0x20, 0, 0, 0, 0, 0x20, 0, 0 };\nstatic const u8 tf103c_dock_usb_enable_cmd[9] = { 8, 0, 0, 0, 0, 0, 0, 0x40, 0 };\nstatic const u8 tf103c_dock_suspend_cmd[9] = { 8, 0, 0x20, 0, 0, 0x22, 0, 0, 0 };\n\n \n\nstatic u8 tf103c_dock_kbd_hid_desc[] = {\n\t0x05, 0x01,          \n\t0x09, 0x06,          \n\t0xA1, 0x01,          \n\t0x85, 0x11,          \n\t0x95, 0x08,          \n\t0x75, 0x01,          \n\t0x15, 0x00,          \n\t0x25, 0x01,          \n\t0x05, 0x07,          \n\t0x19, 0xE0,          \n\t0x29, 0xE7,          \n\t0x81, 0x02,          \n\t0x95, 0x01,          \n\t0x75, 0x08,          \n\t0x81, 0x01,          \n\t0x95, 0x06,          \n\t0x75, 0x08,          \n\t0x15, 0x00,          \n\t0x26, 0xFF, 0x00,    \n\t0x05, 0x07,          \n\t0x19, 0x00,          \n\t0x2A, 0xFF, 0x00,    \n\t0x81, 0x00,          \n\t0xC0                 \n};\n\nstatic int tf103c_dock_kbd_read(struct tf103c_dock_data *dock)\n{\n\tstruct i2c_client *client = dock->kbd_client;\n\tstruct device *dev = &dock->ec_client->dev;\n\tstruct i2c_msg msgs[2];\n\tu8 reg[2];\n\tint ret;\n\n\treg[0] = TF103C_DOCK_KBD_DATA_REG & 0xff;\n\treg[1] = TF103C_DOCK_KBD_DATA_REG >> 8;\n\n\tmsgs[0].addr = client->addr;\n\tmsgs[0].flags = 0;\n\tmsgs[0].len = sizeof(reg);\n\tmsgs[0].buf = reg;\n\n\tmsgs[1].addr = client->addr;\n\tmsgs[1].flags = I2C_M_RD;\n\tmsgs[1].len = TF103C_DOCK_KBD_DATA_MAX_LENGTH;\n\tmsgs[1].buf = dock->kbd_buf;\n\n\tret = i2c_transfer(client->adapter, msgs, ARRAY_SIZE(msgs));\n\tif (ret != ARRAY_SIZE(msgs)) {\n\t\tdev_err(dev, \"error %d reading kbd data\\n\", ret);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic void tf103c_dock_kbd_write(struct tf103c_dock_data *dock, u16 cmd)\n{\n\tstruct device *dev = &dock->ec_client->dev;\n\tu8 buf[4];\n\tint ret;\n\n\tput_unaligned_le16(TF103C_DOCK_KBD_CMD_REG, &buf[0]);\n\tput_unaligned_le16(cmd, &buf[2]);\n\n\tret = i2c_master_send(dock->kbd_client, buf, sizeof(buf));\n\tif (ret != sizeof(buf))\n\t\tdev_err(dev, \"error %d writing kbd cmd\\n\", ret);\n}\n\n \nstatic int tf103c_dock_hid_parse(struct hid_device *hid)\n{\n\treturn hid_parse_report(hid, tf103c_dock_kbd_hid_desc,\n\t\t\t\tsizeof(tf103c_dock_kbd_hid_desc));\n}\n\nstatic int tf103c_dock_hid_start(struct hid_device *hid)\n{\n\treturn 0;\n}\n\nstatic void tf103c_dock_hid_stop(struct hid_device *hid)\n{\n\thid->claimed = 0;\n}\n\nstatic int tf103c_dock_hid_open(struct hid_device *hid)\n{\n\tstruct tf103c_dock_data *dock = hid->driver_data;\n\n\tset_bit(TF103C_DOCK_FLAG_HID_OPEN, &dock->flags);\n\treturn 0;\n}\n\nstatic void tf103c_dock_hid_close(struct hid_device *hid)\n{\n\tstruct tf103c_dock_data *dock = hid->driver_data;\n\n\tclear_bit(TF103C_DOCK_FLAG_HID_OPEN, &dock->flags);\n}\n\n \nstatic int tf103c_dock_hid_raw_request(struct hid_device *hid, u8 reportnum,\n\t\t\t\t       u8 *buf, size_t len, u8 rtype, int reqtype)\n{\n\treturn 0;\n}\n\nstatic const struct hid_ll_driver tf103c_dock_hid_ll_driver = {\n\t.parse = tf103c_dock_hid_parse,\n\t.start = tf103c_dock_hid_start,\n\t.stop = tf103c_dock_hid_stop,\n\t.open = tf103c_dock_hid_open,\n\t.close = tf103c_dock_hid_close,\n\t.raw_request = tf103c_dock_hid_raw_request,\n};\n\nstatic const int tf103c_dock_toprow_codes[13][2] = {\n\t \n\t{ KEY_POWER,          KEY_F1 },\n\t{ KEY_RFKILL,         KEY_F2 },\n\t{ KEY_F21,            KEY_F3 },  \n\t{ KEY_BRIGHTNESSDOWN, KEY_F4 },\n\t{ KEY_BRIGHTNESSUP,   KEY_F5 },\n\t{ KEY_CAMERA,         KEY_F6 },\n\t{ KEY_CONFIG,         KEY_F7 },\n\t{ KEY_PREVIOUSSONG,   KEY_F8 },\n\t{ KEY_PLAYPAUSE,      KEY_F9 },\n\t{ KEY_NEXTSONG,       KEY_F10 },\n\t{ KEY_MUTE,           KEY_F11 },\n\t{ KEY_VOLUMEDOWN,     KEY_F12 },\n\t{ KEY_VOLUMEUP,       KEY_SYSRQ },\n};\n\nstatic void tf103c_dock_report_toprow_kbd_hook(struct tf103c_dock_data *dock)\n{\n\tu8 *esc, *buf = dock->kbd_buf;\n\tint size;\n\n\t \n\tdock->altgr_pressed = buf[TF103C_DOCK_KBD_DATA_MODIFIERS] & 0x40;\n\tbuf[TF103C_DOCK_KBD_DATA_MODIFIERS] &= ~0x40;\n\n\tinput_report_key(dock->input, KEY_RIGHTALT, dock->altgr_pressed);\n\tinput_sync(dock->input);\n\n\t \n\tbuf = buf + TF103C_DOCK_KBD_DATA_KEYS;\n\tsize = TF103C_DOCK_KBD_DATA_MAX_LENGTH - TF103C_DOCK_KBD_DATA_KEYS;\n\tesc = memchr(buf, 0x29, size);\n\tif (!dock->esc_pressed && esc) {\n\t\tif (dock->altgr_pressed) {\n\t\t\tfnlock = !fnlock;\n\t\t\tdock->filter_esc = true;\n\t\t}\n\t}\n\tif (esc && dock->filter_esc)\n\t\t*esc = 0;\n\telse\n\t\tdock->filter_esc = false;\n\n\tdock->esc_pressed = esc != NULL;\n}\n\nstatic void tf103c_dock_toprow_press(struct tf103c_dock_data *dock, int key_code)\n{\n\t \n\tif (dock->altgr_pressed) {\n\t\tinput_report_key(dock->input, KEY_RIGHTALT, false);\n\t\tinput_sync(dock->input);\n\t}\n\n\tinput_report_key(dock->input, key_code, true);\n\tinput_sync(dock->input);\n}\n\nstatic void tf103c_dock_toprow_release(struct tf103c_dock_data *dock, int key_code)\n{\n\tinput_report_key(dock->input, key_code, false);\n\tinput_sync(dock->input);\n\n\tif (dock->altgr_pressed) {\n\t\tinput_report_key(dock->input, KEY_RIGHTALT, true);\n\t\tinput_sync(dock->input);\n\t}\n}\n\nstatic void tf103c_dock_toprow_event(struct tf103c_dock_data *dock,\n\t\t\t\t\t    int toprow_index, int *last_press)\n{\n\tint key_code, fn = dock->altgr_pressed ^ fnlock;\n\n\tif (last_press && *last_press) {\n\t\ttf103c_dock_toprow_release(dock, *last_press);\n\t\t*last_press = 0;\n\t}\n\n\tif (toprow_index < 0)\n\t\treturn;\n\n\tkey_code = tf103c_dock_toprow_codes[toprow_index][fn];\n\ttf103c_dock_toprow_press(dock, key_code);\n\n\tif (last_press)\n\t\t*last_press = key_code;\n\telse\n\t\ttf103c_dock_toprow_release(dock, key_code);\n}\n\n \nstatic void tf103c_dock_kbd_interrupt(struct tf103c_dock_data *dock)\n{\n\tstruct device *dev = &dock->ec_client->dev;\n\tu8 *buf = dock->kbd_buf;\n\tint size;\n\n\tif (tf103c_dock_kbd_read(dock))\n\t\treturn;\n\n\tsize = buf[0] | buf[1] << 8;\n\tif (size < TF103C_DOCK_KBD_DATA_MIN_LENGTH ||\n\t    size > TF103C_DOCK_KBD_DATA_MAX_LENGTH) {\n\t\tdev_err(dev, \"error reported kbd pkt size %d is out of range %d-%d\\n\", size,\n\t\t\tTF103C_DOCK_KBD_DATA_MIN_LENGTH,\n\t\t\tTF103C_DOCK_KBD_DATA_MAX_LENGTH);\n\t\treturn;\n\t}\n\n\tswitch (buf[2]) {\n\tcase 0x11:\n\t\tif (size != 11)\n\t\t\tbreak;\n\n\t\ttf103c_dock_report_toprow_kbd_hook(dock);\n\n\t\tif (test_bit(TF103C_DOCK_FLAG_HID_OPEN, &dock->flags))\n\t\t\thid_input_report(dock->hid, HID_INPUT_REPORT, buf + 2, size - 2, 1);\n\t\treturn;\n\tcase 0x13:\n\t\tif (size != 5)\n\t\t\tbreak;\n\n\t\tswitch (buf[3] | buf[4] << 8) {\n\t\tcase 0:\n\t\t\ttf103c_dock_toprow_event(dock, -1, &dock->last_press_0x13);\n\t\t\treturn;\n\t\tcase 0x70:\n\t\t\ttf103c_dock_toprow_event(dock, 3, &dock->last_press_0x13);\n\t\t\treturn;\n\t\tcase 0x6f:\n\t\t\ttf103c_dock_toprow_event(dock, 4, &dock->last_press_0x13);\n\t\t\treturn;\n\t\tcase 0xb6:\n\t\t\ttf103c_dock_toprow_event(dock, 7, &dock->last_press_0x13);\n\t\t\treturn;\n\t\tcase 0xcd:\n\t\t\ttf103c_dock_toprow_event(dock, 8, &dock->last_press_0x13);\n\t\t\treturn;\n\t\tcase 0xb5:\n\t\t\ttf103c_dock_toprow_event(dock, 9, &dock->last_press_0x13);\n\t\t\treturn;\n\t\tcase 0xe2:\n\t\t\ttf103c_dock_toprow_event(dock, 10, &dock->last_press_0x13);\n\t\t\treturn;\n\t\tcase 0xea:\n\t\t\ttf103c_dock_toprow_event(dock, 11, &dock->last_press_0x13);\n\t\t\treturn;\n\t\tcase 0xe9:\n\t\t\ttf103c_dock_toprow_event(dock, 12, &dock->last_press_0x13);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tcase 0x14:\n\t\tif (size != 4)\n\t\t\tbreak;\n\n\t\tswitch (buf[3]) {\n\t\tcase 0:\n\t\t\ttf103c_dock_toprow_event(dock, -1, &dock->last_press_0x14);\n\t\t\treturn;\n\t\tcase 1:\n\t\t\ttf103c_dock_toprow_event(dock, 0, &dock->last_press_0x14);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\t}\n\n\tdev_warn(dev, \"warning unknown kbd data: %*ph\\n\", size, buf);\n}\n\n \n\nstatic const struct property_entry tf103c_dock_touchpad_props[] = {\n\tPROPERTY_ENTRY_BOOL(\"elan,clickpad\"),\n\t{ }\n};\n\nstatic const struct software_node tf103c_dock_touchpad_sw_node = {\n\t.properties = tf103c_dock_touchpad_props,\n};\n\n \nstatic void tf103c_dock_enable_touchpad(struct tf103c_dock_data *dock)\n{\n\tstruct i2c_board_info board_info = { };\n\tstruct device *dev = &dock->ec_client->dev;\n\tint ret;\n\n\tif (dock->tp_enabled) {\n\t\t \n\t\tret = device_reprobe(&dock->tp_client->dev);\n\t\tif (ret)\n\t\t\tdev_err_probe(dev, ret, \"reprobing tp-client\\n\");\n\t\treturn;\n\t}\n\n\tstrscpy(board_info.type, \"elan_i2c\", I2C_NAME_SIZE);\n\tboard_info.addr = TF103C_DOCK_TP_ADDR;\n\tboard_info.dev_name = TF103C_DOCK_DEV_NAME \"-tp\";\n\tboard_info.irq = dock->tp_irq;\n\tboard_info.swnode = &tf103c_dock_touchpad_sw_node;\n\n\tdock->tp_client = i2c_new_client_device(dock->ec_client->adapter, &board_info);\n\tif (IS_ERR(dock->tp_client)) {\n\t\tdev_err(dev, \"error %ld creating tp client\\n\", PTR_ERR(dock->tp_client));\n\t\treturn;\n\t}\n\n\tdock->tp_enabled = true;\n}\n\nstatic void tf103c_dock_disable_touchpad(struct tf103c_dock_data *dock)\n{\n\tif (!dock->tp_enabled)\n\t\treturn;\n\n\ti2c_unregister_device(dock->tp_client);\n\n\tdock->tp_enabled = false;\n}\n\n \nstatic void tf103c_dock_ec_cmd(struct tf103c_dock_data *dock, const u8 *cmd)\n{\n\tstruct device *dev = &dock->ec_client->dev;\n\tint ret;\n\n\tret = i2c_smbus_write_i2c_block_data(dock->ec_client, TF103C_DOCK_EC_CMD_REG,\n\t\t\t\t\t     TF103C_DOCK_EC_CMD_LEN, cmd);\n\tif (ret)\n\t\tdev_err(dev, \"error %d sending %*ph cmd\\n\", ret,\n\t\t\tTF103C_DOCK_EC_CMD_LEN, cmd);\n}\n\nstatic void tf103c_dock_sci(struct tf103c_dock_data *dock, u8 val)\n{\n\tstruct device *dev = &dock->ec_client->dev;\n\n\tswitch (val) {\n\tcase 2:\n\t\ttf103c_dock_toprow_event(dock, 1, NULL);\n\t\treturn;\n\tcase 4:\n\t\ttf103c_dock_toprow_event(dock, 2, NULL);\n\t\treturn;\n\tcase 8:\n\t\ttf103c_dock_toprow_event(dock, 5, NULL);\n\t\treturn;\n\tcase 17:\n\t\ttf103c_dock_toprow_event(dock, 6, NULL);\n\t\treturn;\n\t}\n\n\tdev_warn(dev, \"warning unknown SCI value: 0x%02x\\n\", val);\n}\n\nstatic void tf103c_dock_smi(struct tf103c_dock_data *dock, u8 val)\n{\n\tstruct device *dev = &dock->ec_client->dev;\n\n\tswitch (val) {\n\tcase TF103C_DOCK_SMI_EC_WAKEUP:\n\t\ttf103c_dock_ec_cmd(dock, tf103c_dock_enable_cmd);\n\t\ttf103c_dock_ec_cmd(dock, tf103c_dock_usb_enable_cmd);\n\t\ttf103c_dock_kbd_write(dock, TF103C_DOCK_KBD_CMD_ENABLE);\n\t\tbreak;\n\tcase TF103C_DOCK_SMI_PAD_BL_CHANGE:\n\t\t \n\t\tbreak;\n\tcase TF103C_DOCK_SMI_HID_STATUS_CHANGED:\n\t\ttf103c_dock_enable_touchpad(dock);\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(dev, \"warning unknown SMI value: 0x%02x\\n\", val);\n\t\tbreak;\n\t}\n}\n\nstatic irqreturn_t tf103c_dock_irq(int irq, void *data)\n{\n\tstruct tf103c_dock_data *dock = data;\n\tstruct device *dev = &dock->ec_client->dev;\n\tu8 intr_data[8];\n\tint ret;\n\n\tret = i2c_smbus_read_i2c_block_data(dock->intr_client, TF103C_DOCK_INTR_DATA_REG,\n\t\t\t\t\t    sizeof(intr_data), intr_data);\n\tif (ret != sizeof(intr_data)) {\n\t\tdev_err(dev, \"error %d reading intr data\\n\", ret);\n\t\treturn IRQ_NONE;\n\t}\n\n\tif (!(intr_data[1] & TF103C_DOCK_INTR_DATA1_OBF_MASK))\n\t\treturn IRQ_NONE;\n\n\t \n\tif (intr_data[0] == 3 && intr_data[1] == TF103C_DOCK_INTR_DATA1_OOB_VALUE &&\n\t\t\t\t intr_data[2] == TF103C_DOCK_INTR_DATA2_OOB_VALUE) {\n\t\t \n\t\tswitch (intr_data[3]) {\n\t\tcase 0x01:\n\t\t\thandle_nested_irq(dock->tp_irq);\n\t\t\tbreak;\n\t\tcase 0x11:\n\t\tcase 0x13:\n\t\tcase 0x14:\n\t\t\ttf103c_dock_kbd_interrupt(dock);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_warn(dev, \"warning unknown intr_data[3]: 0x%02x\\n\", intr_data[3]);\n\t\t\tbreak;\n\t\t}\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tif (intr_data[1] & TF103C_DOCK_INTR_DATA1_SCI_MASK) {\n\t\ttf103c_dock_sci(dock, intr_data[2]);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tif (intr_data[1] & TF103C_DOCK_INTR_DATA1_SMI_MASK) {\n\t\ttf103c_dock_smi(dock, intr_data[2]);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tdev_warn(dev, \"warning unknown intr data: %*ph\\n\", 8, intr_data);\n\treturn IRQ_NONE;\n}\n\n \nstatic void tf103c_dock_enable(struct tf103c_dock_data *dock)\n{\n\tif (dock->enabled)\n\t\treturn;\n\n\tif (dock->board_rev != 2)\n\t\tgpiod_set_value(dock->pwr_en, 1);\n\n\tmsleep(500);\n\tenable_irq(dock->irq);\n\n\tdock->enabled = true;\n}\n\nstatic void tf103c_dock_disable(struct tf103c_dock_data *dock)\n{\n\tif (!dock->enabled)\n\t\treturn;\n\n\tdisable_irq(dock->irq);\n\ttf103c_dock_disable_touchpad(dock);\n\tif (dock->board_rev != 2)\n\t\tgpiod_set_value(dock->pwr_en, 0);\n\n\tdock->enabled = false;\n}\n\nstatic void tf103c_dock_hpd_work(struct work_struct *work)\n{\n\tstruct tf103c_dock_data *dock =\n\t\tcontainer_of(work, struct tf103c_dock_data, hpd_work.work);\n\n\tif (gpiod_get_value(dock->hpd_gpio))\n\t\ttf103c_dock_enable(dock);\n\telse\n\t\ttf103c_dock_disable(dock);\n}\n\nstatic irqreturn_t tf103c_dock_hpd_irq(int irq, void *data)\n{\n\tstruct tf103c_dock_data *dock = data;\n\n\tmod_delayed_work(system_long_wq, &dock->hpd_work, TF103C_DOCK_HPD_DEBOUNCE);\n\treturn IRQ_HANDLED;\n}\n\nstatic void tf103c_dock_start_hpd(struct tf103c_dock_data *dock)\n{\n\tenable_irq(dock->hpd_irq);\n\t \n\tqueue_delayed_work(system_long_wq, &dock->hpd_work, TF103C_DOCK_HPD_DEBOUNCE);\n}\n\nstatic void tf103c_dock_stop_hpd(struct tf103c_dock_data *dock)\n{\n\tdisable_irq(dock->hpd_irq);\n\tcancel_delayed_work_sync(&dock->hpd_work);\n}\n\n \n\nstatic const struct dmi_system_id tf103c_dock_dmi_ids[] = {\n\t{\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"ASUSTeK COMPUTER INC.\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"TF103C\"),\n\t\t},\n\t},\n\t{ }\n};\n\nstatic void tf103c_dock_non_devm_cleanup(void *data)\n{\n\tstruct tf103c_dock_data *dock = data;\n\n\tif (dock->tp_irq_domain)\n\t\tirq_domain_remove(dock->tp_irq_domain);\n\n\tif (!IS_ERR_OR_NULL(dock->hid))\n\t\thid_destroy_device(dock->hid);\n\n\ti2c_unregister_device(dock->kbd_client);\n\ti2c_unregister_device(dock->intr_client);\n\tgpiod_remove_lookup_table(&tf103c_dock_gpios);\n}\n\nstatic int tf103c_dock_probe(struct i2c_client *client)\n{\n\tstruct i2c_board_info board_info = { };\n\tstruct device *dev = &client->dev;\n\tstruct gpio_desc *board_rev_gpio;\n\tstruct tf103c_dock_data *dock;\n\tenum gpiod_flags flags;\n\tint i, ret;\n\n\t \n\tif (!dmi_check_system(tf103c_dock_dmi_ids))\n\t\treturn -ENODEV;\n\n\tdock = devm_kzalloc(dev, sizeof(*dock), GFP_KERNEL);\n\tif (!dock)\n\t\treturn -ENOMEM;\n\n\tINIT_DELAYED_WORK(&dock->hpd_work, tf103c_dock_hpd_work);\n\n\t \n\tgpiod_add_lookup_table(&tf103c_dock_gpios);\n\n\tret = devm_add_action_or_reset(dev, tf103c_dock_non_devm_cleanup, dock);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tboard_rev_gpio = gpiod_get(dev, \"board_rev\", GPIOD_ASIS);\n\tif (IS_ERR(board_rev_gpio))\n\t\treturn dev_err_probe(dev, PTR_ERR(board_rev_gpio), \"requesting board_rev GPIO\\n\");\n\tdock->board_rev = gpiod_get_value_cansleep(board_rev_gpio) + 1;\n\tgpiod_put(board_rev_gpio);\n\n\t \n\tflags = (dock->board_rev == 2) ? GPIOD_OUT_HIGH : GPIOD_OUT_LOW;\n\tdock->pwr_en = devm_gpiod_get(dev, \"dock_pwr_en\", flags);\n\tif (IS_ERR(dock->pwr_en))\n\t\treturn dev_err_probe(dev, PTR_ERR(dock->pwr_en), \"requesting pwr_en GPIO\\n\");\n\n\tdock->irq_gpio = devm_gpiod_get(dev, \"dock_irq\", GPIOD_IN);\n\tif (IS_ERR(dock->irq_gpio))\n\t\treturn dev_err_probe(dev, PTR_ERR(dock->irq_gpio), \"requesting IRQ GPIO\\n\");\n\n\tdock->irq = gpiod_to_irq(dock->irq_gpio);\n\tif (dock->irq < 0)\n\t\treturn dev_err_probe(dev, dock->irq, \"getting dock IRQ\");\n\n\tret = devm_request_threaded_irq(dev, dock->irq, NULL, tf103c_dock_irq,\n\t\t\t\t\tIRQF_TRIGGER_LOW | IRQF_ONESHOT | IRQF_NO_AUTOEN,\n\t\t\t\t\t\"dock_irq\", dock);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"requesting dock IRQ\");\n\n\tdock->hpd_gpio = devm_gpiod_get(dev, \"dock_hpd\", GPIOD_IN);\n\tif (IS_ERR(dock->hpd_gpio))\n\t\treturn dev_err_probe(dev, PTR_ERR(dock->hpd_gpio), \"requesting HPD GPIO\\n\");\n\n\tdock->hpd_irq = gpiod_to_irq(dock->hpd_gpio);\n\tif (dock->hpd_irq < 0)\n\t\treturn dev_err_probe(dev, dock->hpd_irq, \"getting HPD IRQ\");\n\n\tret = devm_request_irq(dev, dock->hpd_irq, tf103c_dock_hpd_irq,\n\t\t\t       IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING | IRQF_NO_AUTOEN,\n\t\t\t       \"dock_hpd\", dock);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tdock->ec_client = client;\n\n\tstrscpy(board_info.type, \"tf103c-dock-intr\", I2C_NAME_SIZE);\n\tboard_info.addr = TF103C_DOCK_INTR_ADDR;\n\tboard_info.dev_name = TF103C_DOCK_DEV_NAME \"-intr\";\n\n\tdock->intr_client = i2c_new_client_device(client->adapter, &board_info);\n\tif (IS_ERR(dock->intr_client))\n\t\treturn dev_err_probe(dev, PTR_ERR(dock->intr_client), \"creating intr client\\n\");\n\n\tstrscpy(board_info.type, \"tf103c-dock-kbd\", I2C_NAME_SIZE);\n\tboard_info.addr = TF103C_DOCK_KBD_ADDR;\n\tboard_info.dev_name = TF103C_DOCK_DEV_NAME \"-kbd\";\n\n\tdock->kbd_client = i2c_new_client_device(client->adapter, &board_info);\n\tif (IS_ERR(dock->kbd_client))\n\t\treturn dev_err_probe(dev, PTR_ERR(dock->kbd_client), \"creating kbd client\\n\");\n\n\t \n\tdock->input = devm_input_allocate_device(dev);\n\tif (!dock->input)\n\t\treturn -ENOMEM;\n\n\tdock->input->name = \"Asus TF103C Dock Top Row Keys\";\n\tdock->input->phys = dev_name(dev);\n\tdock->input->dev.parent = dev;\n\tdock->input->id.bustype = BUS_I2C;\n\tdock->input->id.vendor =  \n\tdock->input->id.product =  \n\tdock->input->id.version = 0x0100;   \n\n\tfor (i = 0; i < ARRAY_SIZE(tf103c_dock_toprow_codes); i++) {\n\t\tinput_set_capability(dock->input, EV_KEY, tf103c_dock_toprow_codes[i][0]);\n\t\tinput_set_capability(dock->input, EV_KEY, tf103c_dock_toprow_codes[i][1]);\n\t}\n\tinput_set_capability(dock->input, EV_KEY, KEY_RIGHTALT);\n\n\tret = input_register_device(dock->input);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tdock->hid = hid_allocate_device();\n\tif (IS_ERR(dock->hid))\n\t\treturn dev_err_probe(dev, PTR_ERR(dock->hid), \"allocating hid dev\\n\");\n\n\tdock->hid->driver_data = dock;\n\tdock->hid->ll_driver = &tf103c_dock_hid_ll_driver;\n\tdock->hid->dev.parent = &client->dev;\n\tdock->hid->bus = BUS_I2C;\n\tdock->hid->vendor = 0x0b05;   \n\tdock->hid->product = 0x0103;  \n\tdock->hid->version = 0x0100;  \n\tstrscpy(dock->hid->name, \"Asus TF103C Dock Keyboard\", sizeof(dock->hid->name));\n\tstrscpy(dock->hid->phys, dev_name(dev), sizeof(dock->hid->phys));\n\n\tret = hid_add_device(dock->hid);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"adding hid dev\\n\");\n\n\t \n\tdock->tp_irqchip.name = KBUILD_MODNAME;\n\n\tdock->tp_irq_domain = irq_domain_add_linear(NULL, 1, &irq_domain_simple_ops, NULL);\n\tif (!dock->tp_irq_domain)\n\t\treturn -ENOMEM;\n\n\tdock->tp_irq = irq_create_mapping(dock->tp_irq_domain, 0);\n\tif (!dock->tp_irq)\n\t\treturn -ENOMEM;\n\n\tirq_set_chip_data(dock->tp_irq, dock);\n\tirq_set_chip_and_handler(dock->tp_irq, &dock->tp_irqchip, handle_simple_irq);\n\tirq_set_nested_thread(dock->tp_irq, true);\n\tirq_set_noprobe(dock->tp_irq);\n\n\tdev_info(dev, \"Asus TF103C board-revision: %d\\n\", dock->board_rev);\n\n\ttf103c_dock_start_hpd(dock);\n\n\tdevice_init_wakeup(dev, true);\n\ti2c_set_clientdata(client, dock);\n\treturn 0;\n}\n\nstatic void tf103c_dock_remove(struct i2c_client *client)\n{\n\tstruct tf103c_dock_data *dock = i2c_get_clientdata(client);\n\n\ttf103c_dock_stop_hpd(dock);\n\ttf103c_dock_disable(dock);\n}\n\nstatic int __maybe_unused tf103c_dock_suspend(struct device *dev)\n{\n\tstruct tf103c_dock_data *dock = dev_get_drvdata(dev);\n\n\ttf103c_dock_stop_hpd(dock);\n\n\tif (dock->enabled) {\n\t\ttf103c_dock_ec_cmd(dock, tf103c_dock_suspend_cmd);\n\n\t\tif (device_may_wakeup(dev))\n\t\t\tenable_irq_wake(dock->irq);\n\t}\n\n\treturn 0;\n}\n\nstatic int __maybe_unused tf103c_dock_resume(struct device *dev)\n{\n\tstruct tf103c_dock_data *dock = dev_get_drvdata(dev);\n\n\tif (dock->enabled) {\n\t\tif (device_may_wakeup(dev))\n\t\t\tdisable_irq_wake(dock->irq);\n\n\t\t \n\t\tif (gpiod_get_value(dock->hpd_gpio))\n\t\t\ttf103c_dock_ec_cmd(dock, tf103c_dock_enable_cmd);\n\t}\n\n\ttf103c_dock_start_hpd(dock);\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(tf103c_dock_pm_ops, tf103c_dock_suspend, tf103c_dock_resume);\n\nstatic const struct acpi_device_id tf103c_dock_acpi_match[] = {\n\t{\"NPCE69A\"},\n\t{ }\n};\nMODULE_DEVICE_TABLE(acpi, tf103c_dock_acpi_match);\n\nstatic struct i2c_driver tf103c_dock_driver = {\n\t.driver = {\n\t\t.name = \"asus-tf103c-dock\",\n\t\t.pm = &tf103c_dock_pm_ops,\n\t\t.acpi_match_table = tf103c_dock_acpi_match,\n\t},\n\t.probe = tf103c_dock_probe,\n\t.remove\t= tf103c_dock_remove,\n};\nmodule_i2c_driver(tf103c_dock_driver);\n\nMODULE_AUTHOR(\"Hans de Goede <hdegoede@redhat.com\");\nMODULE_DESCRIPTION(\"X86 Android tablets DSDT fixups driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}