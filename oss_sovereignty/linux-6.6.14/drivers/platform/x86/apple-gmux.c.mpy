{
  "module_name": "apple-gmux.c",
  "hash_id": "604c0ddf73b167e9f1afea07338fb43909a2d73d72e7875df7b6a8452d70d23c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/x86/apple-gmux.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/backlight.h>\n#include <linux/acpi.h>\n#include <linux/pnp.h>\n#include <linux/apple-gmux.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/pci.h>\n#include <linux/vga_switcheroo.h>\n#include <linux/debugfs.h>\n#include <acpi/video.h>\n#include <asm/io.h>\n\n \n\nstruct apple_gmux_config;\n\nstruct apple_gmux_data {\n\tu8 __iomem *iomem_base;\n\tunsigned long iostart;\n\tunsigned long iolen;\n\tconst struct apple_gmux_config *config;\n\tstruct mutex index_lock;\n\n\tstruct backlight_device *bdev;\n\n\t \n\tacpi_handle dhandle;\n\tint gpe;\n\tbool external_switchable;\n\tenum vga_switcheroo_client_id switch_state_display;\n\tenum vga_switcheroo_client_id switch_state_ddc;\n\tenum vga_switcheroo_client_id switch_state_external;\n\tenum vga_switcheroo_state power_state;\n\tstruct completion powerchange_done;\n\n\t \n\tu8 selected_port;\n\tstruct dentry *debug_dentry;\n};\n\nstatic struct apple_gmux_data *apple_gmux_data;\n\nstruct apple_gmux_config {\n\tu8 (*read8)(struct apple_gmux_data *gmux_data, int port);\n\tvoid (*write8)(struct apple_gmux_data *gmux_data, int port, u8 val);\n\tu32 (*read32)(struct apple_gmux_data *gmux_data, int port);\n\tvoid (*write32)(struct apple_gmux_data *gmux_data, int port, u32 val);\n\tconst struct vga_switcheroo_handler *gmux_handler;\n\tenum vga_switcheroo_handler_flags_t handler_flags;\n\tunsigned long resource_type;\n\tbool read_version_as_u32;\n\tchar *name;\n};\n\n#define GMUX_INTERRUPT_ENABLE\t\t0xff\n#define GMUX_INTERRUPT_DISABLE\t\t0x00\n\n#define GMUX_INTERRUPT_STATUS_ACTIVE\t0\n#define GMUX_INTERRUPT_STATUS_DISPLAY\t(1 << 0)\n#define GMUX_INTERRUPT_STATUS_POWER\t(1 << 2)\n#define GMUX_INTERRUPT_STATUS_HOTPLUG\t(1 << 3)\n\n#define GMUX_BRIGHTNESS_MASK\t\t0x00ffffff\n#define GMUX_MAX_BRIGHTNESS\t\tGMUX_BRIGHTNESS_MASK\n\n# define MMIO_GMUX_MAX_BRIGHTNESS\t0xffff\n\nstatic u8 gmux_pio_read8(struct apple_gmux_data *gmux_data, int port)\n{\n\treturn inb(gmux_data->iostart + port);\n}\n\nstatic void gmux_pio_write8(struct apple_gmux_data *gmux_data, int port,\n\t\t\t       u8 val)\n{\n\toutb(val, gmux_data->iostart + port);\n}\n\nstatic u32 gmux_pio_read32(struct apple_gmux_data *gmux_data, int port)\n{\n\treturn inl(gmux_data->iostart + port);\n}\n\nstatic void gmux_pio_write32(struct apple_gmux_data *gmux_data, int port,\n\t\t\t     u32 val)\n{\n\tint i;\n\tu8 tmpval;\n\n\tfor (i = 0; i < 4; i++) {\n\t\ttmpval = (val >> (i * 8)) & 0xff;\n\t\toutb(tmpval, gmux_data->iostart + port + i);\n\t}\n}\n\nstatic int gmux_index_wait_ready(struct apple_gmux_data *gmux_data)\n{\n\tint i = 200;\n\tu8 gwr = inb(gmux_data->iostart + GMUX_PORT_WRITE);\n\n\twhile (i && (gwr & 0x01)) {\n\t\tinb(gmux_data->iostart + GMUX_PORT_READ);\n\t\tgwr = inb(gmux_data->iostart + GMUX_PORT_WRITE);\n\t\tudelay(100);\n\t\ti--;\n\t}\n\n\treturn !!i;\n}\n\nstatic int gmux_index_wait_complete(struct apple_gmux_data *gmux_data)\n{\n\tint i = 200;\n\tu8 gwr = inb(gmux_data->iostart + GMUX_PORT_WRITE);\n\n\twhile (i && !(gwr & 0x01)) {\n\t\tgwr = inb(gmux_data->iostart + GMUX_PORT_WRITE);\n\t\tudelay(100);\n\t\ti--;\n\t}\n\n\tif (gwr & 0x01)\n\t\tinb(gmux_data->iostart + GMUX_PORT_READ);\n\n\treturn !!i;\n}\n\nstatic u8 gmux_index_read8(struct apple_gmux_data *gmux_data, int port)\n{\n\tu8 val;\n\n\tmutex_lock(&gmux_data->index_lock);\n\tgmux_index_wait_ready(gmux_data);\n\toutb((port & 0xff), gmux_data->iostart + GMUX_PORT_READ);\n\tgmux_index_wait_complete(gmux_data);\n\tval = inb(gmux_data->iostart + GMUX_PORT_VALUE);\n\tmutex_unlock(&gmux_data->index_lock);\n\n\treturn val;\n}\n\nstatic void gmux_index_write8(struct apple_gmux_data *gmux_data, int port,\n\t\t\t      u8 val)\n{\n\tmutex_lock(&gmux_data->index_lock);\n\toutb(val, gmux_data->iostart + GMUX_PORT_VALUE);\n\tgmux_index_wait_ready(gmux_data);\n\toutb(port & 0xff, gmux_data->iostart + GMUX_PORT_WRITE);\n\tgmux_index_wait_complete(gmux_data);\n\tmutex_unlock(&gmux_data->index_lock);\n}\n\nstatic u32 gmux_index_read32(struct apple_gmux_data *gmux_data, int port)\n{\n\tu32 val;\n\n\tmutex_lock(&gmux_data->index_lock);\n\tgmux_index_wait_ready(gmux_data);\n\toutb((port & 0xff), gmux_data->iostart + GMUX_PORT_READ);\n\tgmux_index_wait_complete(gmux_data);\n\tval = inl(gmux_data->iostart + GMUX_PORT_VALUE);\n\tmutex_unlock(&gmux_data->index_lock);\n\n\treturn val;\n}\n\nstatic void gmux_index_write32(struct apple_gmux_data *gmux_data, int port,\n\t\t\t       u32 val)\n{\n\tint i;\n\tu8 tmpval;\n\n\tmutex_lock(&gmux_data->index_lock);\n\n\tfor (i = 0; i < 4; i++) {\n\t\ttmpval = (val >> (i * 8)) & 0xff;\n\t\toutb(tmpval, gmux_data->iostart + GMUX_PORT_VALUE + i);\n\t}\n\n\tgmux_index_wait_ready(gmux_data);\n\toutb(port & 0xff, gmux_data->iostart + GMUX_PORT_WRITE);\n\tgmux_index_wait_complete(gmux_data);\n\tmutex_unlock(&gmux_data->index_lock);\n}\n\nstatic int gmux_mmio_wait(struct apple_gmux_data *gmux_data)\n{\n\tint i = 200;\n\tu8 gwr = ioread8(gmux_data->iomem_base + GMUX_MMIO_COMMAND_SEND);\n\n\twhile (i && gwr) {\n\t\tgwr = ioread8(gmux_data->iomem_base + GMUX_MMIO_COMMAND_SEND);\n\t\tudelay(100);\n\t\ti--;\n\t}\n\n\treturn !!i;\n}\n\nstatic u8 gmux_mmio_read8(struct apple_gmux_data *gmux_data, int port)\n{\n\tu8 val;\n\n\tmutex_lock(&gmux_data->index_lock);\n\tgmux_mmio_wait(gmux_data);\n\tiowrite8((port & 0xff), gmux_data->iomem_base + GMUX_MMIO_PORT_SELECT);\n\tiowrite8(GMUX_MMIO_READ | sizeof(val),\n\t\tgmux_data->iomem_base + GMUX_MMIO_COMMAND_SEND);\n\tgmux_mmio_wait(gmux_data);\n\tval = ioread8(gmux_data->iomem_base);\n\tmutex_unlock(&gmux_data->index_lock);\n\n\treturn val;\n}\n\nstatic void gmux_mmio_write8(struct apple_gmux_data *gmux_data, int port,\n\t\t\t      u8 val)\n{\n\tmutex_lock(&gmux_data->index_lock);\n\tgmux_mmio_wait(gmux_data);\n\tiowrite8(val, gmux_data->iomem_base);\n\n\tiowrite8(port & 0xff, gmux_data->iomem_base + GMUX_MMIO_PORT_SELECT);\n\tiowrite8(GMUX_MMIO_WRITE | sizeof(val),\n\t\tgmux_data->iomem_base + GMUX_MMIO_COMMAND_SEND);\n\n\tgmux_mmio_wait(gmux_data);\n\tmutex_unlock(&gmux_data->index_lock);\n}\n\nstatic u32 gmux_mmio_read32(struct apple_gmux_data *gmux_data, int port)\n{\n\tu32 val;\n\n\tmutex_lock(&gmux_data->index_lock);\n\tgmux_mmio_wait(gmux_data);\n\tiowrite8((port & 0xff), gmux_data->iomem_base + GMUX_MMIO_PORT_SELECT);\n\tiowrite8(GMUX_MMIO_READ | sizeof(val),\n\t\tgmux_data->iomem_base + GMUX_MMIO_COMMAND_SEND);\n\tgmux_mmio_wait(gmux_data);\n\tval = ioread32be(gmux_data->iomem_base);\n\tmutex_unlock(&gmux_data->index_lock);\n\n\treturn val;\n}\n\nstatic void gmux_mmio_write32(struct apple_gmux_data *gmux_data, int port,\n\t\t\t       u32 val)\n{\n\tmutex_lock(&gmux_data->index_lock);\n\tiowrite32be(val, gmux_data->iomem_base);\n\tiowrite8(port & 0xff, gmux_data->iomem_base + GMUX_MMIO_PORT_SELECT);\n\tiowrite8(GMUX_MMIO_WRITE | sizeof(val),\n\t\tgmux_data->iomem_base + GMUX_MMIO_COMMAND_SEND);\n\tgmux_mmio_wait(gmux_data);\n\tmutex_unlock(&gmux_data->index_lock);\n}\n\nstatic u8 gmux_read8(struct apple_gmux_data *gmux_data, int port)\n{\n\treturn gmux_data->config->read8(gmux_data, port);\n}\n\nstatic void gmux_write8(struct apple_gmux_data *gmux_data, int port, u8 val)\n{\n\treturn gmux_data->config->write8(gmux_data, port, val);\n}\n\nstatic u32 gmux_read32(struct apple_gmux_data *gmux_data, int port)\n{\n\treturn gmux_data->config->read32(gmux_data, port);\n}\n\nstatic void gmux_write32(struct apple_gmux_data *gmux_data, int port,\n\t\t\t     u32 val)\n{\n\treturn gmux_data->config->write32(gmux_data, port, val);\n}\n\n \n\nstatic int gmux_get_brightness(struct backlight_device *bd)\n{\n\tstruct apple_gmux_data *gmux_data = bl_get_data(bd);\n\treturn gmux_read32(gmux_data, GMUX_PORT_BRIGHTNESS) &\n\t       GMUX_BRIGHTNESS_MASK;\n}\n\nstatic int gmux_update_status(struct backlight_device *bd)\n{\n\tstruct apple_gmux_data *gmux_data = bl_get_data(bd);\n\tu32 brightness = backlight_get_brightness(bd);\n\n\tgmux_write32(gmux_data, GMUX_PORT_BRIGHTNESS, brightness);\n\n\treturn 0;\n}\n\nstatic const struct backlight_ops gmux_bl_ops = {\n\t.options = BL_CORE_SUSPENDRESUME,\n\t.get_brightness = gmux_get_brightness,\n\t.update_status = gmux_update_status,\n};\n\n \n\nstatic void gmux_read_switch_state(struct apple_gmux_data *gmux_data)\n{\n\tif (gmux_read8(gmux_data, GMUX_PORT_SWITCH_DDC) == 1)\n\t\tgmux_data->switch_state_ddc = VGA_SWITCHEROO_IGD;\n\telse\n\t\tgmux_data->switch_state_ddc = VGA_SWITCHEROO_DIS;\n\n\tif (gmux_read8(gmux_data, GMUX_PORT_SWITCH_DISPLAY) & 1)\n\t\tgmux_data->switch_state_display = VGA_SWITCHEROO_DIS;\n\telse\n\t\tgmux_data->switch_state_display = VGA_SWITCHEROO_IGD;\n\n\tif (gmux_read8(gmux_data, GMUX_PORT_SWITCH_EXTERNAL) == 2)\n\t\tgmux_data->switch_state_external = VGA_SWITCHEROO_IGD;\n\telse\n\t\tgmux_data->switch_state_external = VGA_SWITCHEROO_DIS;\n}\n\nstatic void gmux_write_switch_state(struct apple_gmux_data *gmux_data)\n{\n\tif (gmux_data->switch_state_ddc == VGA_SWITCHEROO_IGD)\n\t\tgmux_write8(gmux_data, GMUX_PORT_SWITCH_DDC, 1);\n\telse\n\t\tgmux_write8(gmux_data, GMUX_PORT_SWITCH_DDC, 2);\n\n\tif (gmux_data->switch_state_display == VGA_SWITCHEROO_IGD)\n\t\tgmux_write8(gmux_data, GMUX_PORT_SWITCH_DISPLAY, 2);\n\telse\n\t\tgmux_write8(gmux_data, GMUX_PORT_SWITCH_DISPLAY, 3);\n\n\tif (gmux_data->switch_state_external == VGA_SWITCHEROO_IGD)\n\t\tgmux_write8(gmux_data, GMUX_PORT_SWITCH_EXTERNAL, 2);\n\telse\n\t\tgmux_write8(gmux_data, GMUX_PORT_SWITCH_EXTERNAL, 3);\n}\n\nstatic int gmux_switchto(enum vga_switcheroo_client_id id)\n{\n\tapple_gmux_data->switch_state_ddc = id;\n\tapple_gmux_data->switch_state_display = id;\n\tif (apple_gmux_data->external_switchable)\n\t\tapple_gmux_data->switch_state_external = id;\n\n\tgmux_write_switch_state(apple_gmux_data);\n\n\treturn 0;\n}\n\nstatic int gmux_switch_ddc(enum vga_switcheroo_client_id id)\n{\n\tenum vga_switcheroo_client_id old_ddc_owner =\n\t\tapple_gmux_data->switch_state_ddc;\n\n\tif (id == old_ddc_owner)\n\t\treturn id;\n\n\tpr_debug(\"Switching DDC from %d to %d\\n\", old_ddc_owner, id);\n\tapple_gmux_data->switch_state_ddc = id;\n\n\tif (id == VGA_SWITCHEROO_IGD)\n\t\tgmux_write8(apple_gmux_data, GMUX_PORT_SWITCH_DDC, 1);\n\telse\n\t\tgmux_write8(apple_gmux_data, GMUX_PORT_SWITCH_DDC, 2);\n\n\treturn old_ddc_owner;\n}\n\n \n\nstatic int gmux_set_discrete_state(struct apple_gmux_data *gmux_data,\n\t\t\t\t   enum vga_switcheroo_state state)\n{\n\treinit_completion(&gmux_data->powerchange_done);\n\n\tif (state == VGA_SWITCHEROO_ON) {\n\t\tgmux_write8(gmux_data, GMUX_PORT_DISCRETE_POWER, 1);\n\t\tgmux_write8(gmux_data, GMUX_PORT_DISCRETE_POWER, 3);\n\t\tpr_debug(\"Discrete card powered up\\n\");\n\t} else {\n\t\tgmux_write8(gmux_data, GMUX_PORT_DISCRETE_POWER, 1);\n\t\tgmux_write8(gmux_data, GMUX_PORT_DISCRETE_POWER, 0);\n\t\tpr_debug(\"Discrete card powered down\\n\");\n\t}\n\n\tgmux_data->power_state = state;\n\n\tif (gmux_data->gpe >= 0 &&\n\t    !wait_for_completion_interruptible_timeout(&gmux_data->powerchange_done,\n\t\t\t\t\t\t       msecs_to_jiffies(200)))\n\t\tpr_warn(\"Timeout waiting for gmux switch to complete\\n\");\n\n\treturn 0;\n}\n\nstatic int gmux_set_power_state(enum vga_switcheroo_client_id id,\n\t\t\t\tenum vga_switcheroo_state state)\n{\n\tif (id == VGA_SWITCHEROO_IGD)\n\t\treturn 0;\n\n\treturn gmux_set_discrete_state(apple_gmux_data, state);\n}\n\nstatic enum vga_switcheroo_client_id gmux_get_client_id(struct pci_dev *pdev)\n{\n\t \n\tif (pdev->vendor == PCI_VENDOR_ID_INTEL)\n\t\treturn VGA_SWITCHEROO_IGD;\n\telse if (pdev->vendor == PCI_VENDOR_ID_NVIDIA &&\n\t\t pdev->device == 0x0863)\n\t\treturn VGA_SWITCHEROO_IGD;\n\telse\n\t\treturn VGA_SWITCHEROO_DIS;\n}\n\nstatic const struct vga_switcheroo_handler gmux_handler_no_ddc = {\n\t.switchto = gmux_switchto,\n\t.power_state = gmux_set_power_state,\n\t.get_client_id = gmux_get_client_id,\n};\n\nstatic const struct vga_switcheroo_handler gmux_handler_ddc = {\n\t.switchto = gmux_switchto,\n\t.switch_ddc = gmux_switch_ddc,\n\t.power_state = gmux_set_power_state,\n\t.get_client_id = gmux_get_client_id,\n};\n\nstatic const struct apple_gmux_config apple_gmux_pio = {\n\t.read8 = &gmux_pio_read8,\n\t.write8 = &gmux_pio_write8,\n\t.read32 = &gmux_pio_read32,\n\t.write32 = &gmux_pio_write32,\n\t.gmux_handler = &gmux_handler_ddc,\n\t.handler_flags = VGA_SWITCHEROO_CAN_SWITCH_DDC,\n\t.resource_type = IORESOURCE_IO,\n\t.read_version_as_u32 = false,\n\t.name = \"classic\"\n};\n\nstatic const struct apple_gmux_config apple_gmux_index = {\n\t.read8 = &gmux_index_read8,\n\t.write8 = &gmux_index_write8,\n\t.read32 = &gmux_index_read32,\n\t.write32 = &gmux_index_write32,\n\t.gmux_handler = &gmux_handler_no_ddc,\n\t.handler_flags = VGA_SWITCHEROO_NEEDS_EDP_CONFIG,\n\t.resource_type = IORESOURCE_IO,\n\t.read_version_as_u32 = true,\n\t.name = \"indexed\"\n};\n\nstatic const struct apple_gmux_config apple_gmux_mmio = {\n\t.read8 = &gmux_mmio_read8,\n\t.write8 = &gmux_mmio_write8,\n\t.read32 = &gmux_mmio_read32,\n\t.write32 = &gmux_mmio_write32,\n\t.gmux_handler = &gmux_handler_no_ddc,\n\t.handler_flags = VGA_SWITCHEROO_NEEDS_EDP_CONFIG,\n\t.resource_type = IORESOURCE_MEM,\n\t.read_version_as_u32 = true,\n\t.name = \"T2\"\n};\n\n\n \n\nstatic inline void gmux_disable_interrupts(struct apple_gmux_data *gmux_data)\n{\n\tgmux_write8(gmux_data, GMUX_PORT_INTERRUPT_ENABLE,\n\t\t    GMUX_INTERRUPT_DISABLE);\n}\n\nstatic inline void gmux_enable_interrupts(struct apple_gmux_data *gmux_data)\n{\n\tgmux_write8(gmux_data, GMUX_PORT_INTERRUPT_ENABLE,\n\t\t    GMUX_INTERRUPT_ENABLE);\n}\n\nstatic inline u8 gmux_interrupt_get_status(struct apple_gmux_data *gmux_data)\n{\n\treturn gmux_read8(gmux_data, GMUX_PORT_INTERRUPT_STATUS);\n}\n\nstatic void gmux_clear_interrupts(struct apple_gmux_data *gmux_data)\n{\n\tu8 status;\n\n\t \n\tstatus = gmux_interrupt_get_status(gmux_data);\n\tgmux_write8(gmux_data, GMUX_PORT_INTERRUPT_STATUS, status);\n\t \n\tif (gmux_data->config == &apple_gmux_mmio)\n\t\tacpi_execute_simple_method(gmux_data->dhandle, \"GMSP\", 0);\n}\n\nstatic void gmux_notify_handler(acpi_handle device, u32 value, void *context)\n{\n\tu8 status;\n\tstruct pnp_dev *pnp = (struct pnp_dev *)context;\n\tstruct apple_gmux_data *gmux_data = pnp_get_drvdata(pnp);\n\n\tstatus = gmux_interrupt_get_status(gmux_data);\n\tgmux_disable_interrupts(gmux_data);\n\tpr_debug(\"Notify handler called: status %d\\n\", status);\n\n\tgmux_clear_interrupts(gmux_data);\n\tgmux_enable_interrupts(gmux_data);\n\n\tif (status & GMUX_INTERRUPT_STATUS_POWER)\n\t\tcomplete(&gmux_data->powerchange_done);\n}\n\n \n\nstatic ssize_t gmux_selected_port_data_write(struct file *file,\n\t\tconst char __user *userbuf, size_t count, loff_t *ppos)\n{\n\tstruct apple_gmux_data *gmux_data = file->private_data;\n\n\tif (*ppos)\n\t\treturn -EINVAL;\n\n\tif (count == 1) {\n\t\tu8 data;\n\n\t\tif (copy_from_user(&data, userbuf, 1))\n\t\t\treturn -EFAULT;\n\n\t\tgmux_write8(gmux_data, gmux_data->selected_port, data);\n\t} else if (count == 4) {\n\t\tu32 data;\n\n\t\tif (copy_from_user(&data, userbuf, 4))\n\t\t\treturn -EFAULT;\n\n\t\tgmux_write32(gmux_data, gmux_data->selected_port, data);\n\t} else\n\t\treturn -EINVAL;\n\n\treturn count;\n}\n\nstatic ssize_t gmux_selected_port_data_read(struct file *file,\n\t\tchar __user *userbuf, size_t count, loff_t *ppos)\n{\n\tstruct apple_gmux_data *gmux_data = file->private_data;\n\tu32 data;\n\n\tdata = gmux_read32(gmux_data, gmux_data->selected_port);\n\n\treturn simple_read_from_buffer(userbuf, count, ppos, &data, sizeof(data));\n}\n\nstatic const struct file_operations gmux_port_data_ops = {\n\t.open = simple_open,\n\t.write = gmux_selected_port_data_write,\n\t.read = gmux_selected_port_data_read\n};\n\nstatic void gmux_init_debugfs(struct apple_gmux_data *gmux_data)\n{\n\tgmux_data->debug_dentry = debugfs_create_dir(KBUILD_MODNAME, NULL);\n\n\tdebugfs_create_u8(\"selected_port\", 0644, gmux_data->debug_dentry,\n\t\t\t&gmux_data->selected_port);\n\tdebugfs_create_file(\"selected_port_data\", 0644, gmux_data->debug_dentry,\n\t\t\tgmux_data, &gmux_port_data_ops);\n}\n\nstatic void gmux_fini_debugfs(struct apple_gmux_data *gmux_data)\n{\n\tdebugfs_remove_recursive(gmux_data->debug_dentry);\n}\n\nstatic int gmux_suspend(struct device *dev)\n{\n\tstruct pnp_dev *pnp = to_pnp_dev(dev);\n\tstruct apple_gmux_data *gmux_data = pnp_get_drvdata(pnp);\n\n\tgmux_disable_interrupts(gmux_data);\n\treturn 0;\n}\n\nstatic int gmux_resume(struct device *dev)\n{\n\tstruct pnp_dev *pnp = to_pnp_dev(dev);\n\tstruct apple_gmux_data *gmux_data = pnp_get_drvdata(pnp);\n\n\tgmux_enable_interrupts(gmux_data);\n\tgmux_write_switch_state(gmux_data);\n\tif (gmux_data->power_state == VGA_SWITCHEROO_OFF)\n\t\tgmux_set_discrete_state(gmux_data, gmux_data->power_state);\n\treturn 0;\n}\n\nstatic int is_thunderbolt(struct device *dev, void *data)\n{\n\treturn to_pci_dev(dev)->is_thunderbolt;\n}\n\nstatic int gmux_probe(struct pnp_dev *pnp, const struct pnp_device_id *id)\n{\n\tstruct apple_gmux_data *gmux_data;\n\tstruct resource *res;\n\tstruct backlight_properties props;\n\tstruct backlight_device *bdev = NULL;\n\tu8 ver_major, ver_minor, ver_release;\n\tbool register_bdev = true;\n\tint ret = -ENXIO;\n\tacpi_status status;\n\tunsigned long long gpe;\n\tenum apple_gmux_type type;\n\tu32 version;\n\n\tif (apple_gmux_data)\n\t\treturn -EBUSY;\n\n\tif (!apple_gmux_detect(pnp, &type)) {\n\t\tpr_info(\"gmux device not present\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tgmux_data = kzalloc(sizeof(*gmux_data), GFP_KERNEL);\n\tif (!gmux_data)\n\t\treturn -ENOMEM;\n\tpnp_set_drvdata(pnp, gmux_data);\n\n\tswitch (type) {\n\tcase APPLE_GMUX_TYPE_MMIO:\n\t\tgmux_data->config = &apple_gmux_mmio;\n\t\tmutex_init(&gmux_data->index_lock);\n\n\t\tres = pnp_get_resource(pnp, IORESOURCE_MEM, 0);\n\t\tgmux_data->iostart = res->start;\n\t\t \n\t\tgmux_data->iolen = 16;\n\t\tif (!request_mem_region(gmux_data->iostart, gmux_data->iolen,\n\t\t\t\t\t\"Apple gmux\")) {\n\t\t\tpr_err(\"gmux I/O already in use\\n\");\n\t\t\tgoto err_free;\n\t\t}\n\t\tgmux_data->iomem_base = ioremap(gmux_data->iostart, gmux_data->iolen);\n\t\tif (!gmux_data->iomem_base) {\n\t\t\tpr_err(\"couldn't remap gmux mmio region\");\n\t\t\tgoto err_release;\n\t\t}\n\t\tgoto get_version;\n\tcase APPLE_GMUX_TYPE_INDEXED:\n\t\tgmux_data->config = &apple_gmux_index;\n\t\tmutex_init(&gmux_data->index_lock);\n\t\tbreak;\n\tcase APPLE_GMUX_TYPE_PIO:\n\t\tgmux_data->config = &apple_gmux_pio;\n\t\tbreak;\n\t}\n\n\tres = pnp_get_resource(pnp, IORESOURCE_IO, 0);\n\tgmux_data->iostart = res->start;\n\tgmux_data->iolen = resource_size(res);\n\n\tif (!request_region(gmux_data->iostart, gmux_data->iolen,\n\t\t\t    \"Apple gmux\")) {\n\t\tpr_err(\"gmux I/O already in use\\n\");\n\t\tgoto err_free;\n\t}\n\nget_version:\n\tif (gmux_data->config->read_version_as_u32) {\n\t\tversion = gmux_read32(gmux_data, GMUX_PORT_VERSION_MAJOR);\n\t\tver_major = (version >> 24) & 0xff;\n\t\tver_minor = (version >> 16) & 0xff;\n\t\tver_release = (version >> 8) & 0xff;\n\t} else {\n\t\tver_major = gmux_read8(gmux_data, GMUX_PORT_VERSION_MAJOR);\n\t\tver_minor = gmux_read8(gmux_data, GMUX_PORT_VERSION_MINOR);\n\t\tver_release = gmux_read8(gmux_data, GMUX_PORT_VERSION_RELEASE);\n\t}\n\tpr_info(\"Found gmux version %d.%d.%d [%s]\\n\", ver_major, ver_minor,\n\t\tver_release, gmux_data->config->name);\n\n\tmemset(&props, 0, sizeof(props));\n\tprops.type = BACKLIGHT_PLATFORM;\n\n\t \n\tif (type == APPLE_GMUX_TYPE_MMIO)\n\t\tprops.max_brightness = MMIO_GMUX_MAX_BRIGHTNESS;\n\telse\n\t\tprops.max_brightness = gmux_read32(gmux_data, GMUX_PORT_MAX_BRIGHTNESS);\n\n#if IS_REACHABLE(CONFIG_ACPI_VIDEO)\n\tregister_bdev = acpi_video_get_backlight_type() == acpi_backlight_apple_gmux;\n#endif\n\tif (register_bdev) {\n\t\t \n\t\tif (WARN_ON(props.max_brightness > GMUX_MAX_BRIGHTNESS))\n\t\t\tprops.max_brightness = GMUX_MAX_BRIGHTNESS;\n\n\t\tbdev = backlight_device_register(\"gmux_backlight\", &pnp->dev,\n\t\t\t\t\t\t gmux_data, &gmux_bl_ops, &props);\n\t\tif (IS_ERR(bdev)) {\n\t\t\tret = PTR_ERR(bdev);\n\t\t\tgoto err_unmap;\n\t\t}\n\n\t\tgmux_data->bdev = bdev;\n\t\tbdev->props.brightness = gmux_get_brightness(bdev);\n\t\tbacklight_update_status(bdev);\n\t}\n\n\tgmux_data->power_state = VGA_SWITCHEROO_ON;\n\n\tgmux_data->dhandle = ACPI_HANDLE(&pnp->dev);\n\tif (!gmux_data->dhandle) {\n\t\tpr_err(\"Cannot find acpi handle for pnp device %s\\n\",\n\t\t       dev_name(&pnp->dev));\n\t\tret = -ENODEV;\n\t\tgoto err_notify;\n\t}\n\n\tstatus = acpi_evaluate_integer(gmux_data->dhandle, \"GMGP\", NULL, &gpe);\n\tif (ACPI_SUCCESS(status)) {\n\t\tgmux_data->gpe = (int)gpe;\n\n\t\tstatus = acpi_install_notify_handler(gmux_data->dhandle,\n\t\t\t\t\t\t     ACPI_DEVICE_NOTIFY,\n\t\t\t\t\t\t     &gmux_notify_handler, pnp);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tpr_err(\"Install notify handler failed: %s\\n\",\n\t\t\t       acpi_format_exception(status));\n\t\t\tret = -ENODEV;\n\t\t\tgoto err_notify;\n\t\t}\n\n\t\tstatus = acpi_enable_gpe(NULL, gmux_data->gpe);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tpr_err(\"Cannot enable gpe: %s\\n\",\n\t\t\t       acpi_format_exception(status));\n\t\t\tgoto err_enable_gpe;\n\t\t}\n\t} else {\n\t\tpr_warn(\"No GPE found for gmux\\n\");\n\t\tgmux_data->gpe = -1;\n\t}\n\n\t \n\tgmux_data->external_switchable =\n\t\t!bus_for_each_dev(&pci_bus_type, NULL, NULL, is_thunderbolt);\n\tif (!gmux_data->external_switchable)\n\t\tgmux_write8(gmux_data, GMUX_PORT_SWITCH_EXTERNAL, 3);\n\n\tapple_gmux_data = gmux_data;\n\tinit_completion(&gmux_data->powerchange_done);\n\tgmux_enable_interrupts(gmux_data);\n\tgmux_read_switch_state(gmux_data);\n\n\t \n\tret = vga_switcheroo_register_handler(gmux_data->config->gmux_handler,\n\t\t\tgmux_data->config->handler_flags);\n\tif (ret) {\n\t\tpr_err(\"Failed to register vga_switcheroo handler\\n\");\n\t\tgoto err_register_handler;\n\t}\n\n\tgmux_init_debugfs(gmux_data);\n\treturn 0;\n\nerr_register_handler:\n\tgmux_disable_interrupts(gmux_data);\n\tapple_gmux_data = NULL;\n\tif (gmux_data->gpe >= 0)\n\t\tacpi_disable_gpe(NULL, gmux_data->gpe);\nerr_enable_gpe:\n\tif (gmux_data->gpe >= 0)\n\t\tacpi_remove_notify_handler(gmux_data->dhandle,\n\t\t\t\t\t   ACPI_DEVICE_NOTIFY,\n\t\t\t\t\t   &gmux_notify_handler);\nerr_notify:\n\tbacklight_device_unregister(bdev);\nerr_unmap:\n\tif (gmux_data->iomem_base)\n\t\tiounmap(gmux_data->iomem_base);\nerr_release:\n\tif (gmux_data->config->resource_type == IORESOURCE_MEM)\n\t\trelease_mem_region(gmux_data->iostart, gmux_data->iolen);\n\telse\n\t\trelease_region(gmux_data->iostart, gmux_data->iolen);\nerr_free:\n\tkfree(gmux_data);\n\treturn ret;\n}\n\nstatic void gmux_remove(struct pnp_dev *pnp)\n{\n\tstruct apple_gmux_data *gmux_data = pnp_get_drvdata(pnp);\n\n\tgmux_fini_debugfs(gmux_data);\n\tvga_switcheroo_unregister_handler();\n\tgmux_disable_interrupts(gmux_data);\n\tif (gmux_data->gpe >= 0) {\n\t\tacpi_disable_gpe(NULL, gmux_data->gpe);\n\t\tacpi_remove_notify_handler(gmux_data->dhandle,\n\t\t\t\t\t   ACPI_DEVICE_NOTIFY,\n\t\t\t\t\t   &gmux_notify_handler);\n\t}\n\n\tbacklight_device_unregister(gmux_data->bdev);\n\n\tif (gmux_data->iomem_base) {\n\t\tiounmap(gmux_data->iomem_base);\n\t\trelease_mem_region(gmux_data->iostart, gmux_data->iolen);\n\t} else\n\t\trelease_region(gmux_data->iostart, gmux_data->iolen);\n\tapple_gmux_data = NULL;\n\tkfree(gmux_data);\n}\n\nstatic const struct pnp_device_id gmux_device_ids[] = {\n\t{GMUX_ACPI_HID, 0},\n\t{\"\", 0}\n};\n\nstatic const struct dev_pm_ops gmux_dev_pm_ops = {\n\t.suspend = gmux_suspend,\n\t.resume = gmux_resume,\n};\n\nstatic struct pnp_driver gmux_pnp_driver = {\n\t.name\t\t= \"apple-gmux\",\n\t.probe\t\t= gmux_probe,\n\t.remove\t\t= gmux_remove,\n\t.id_table\t= gmux_device_ids,\n\t.driver\t\t= {\n\t\t\t.pm = &gmux_dev_pm_ops,\n\t},\n};\n\nmodule_pnp_driver(gmux_pnp_driver);\nMODULE_AUTHOR(\"Seth Forshee <seth.forshee@canonical.com>\");\nMODULE_DESCRIPTION(\"Apple Gmux Driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DEVICE_TABLE(pnp, gmux_device_ids);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}