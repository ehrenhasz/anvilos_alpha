{
  "module_name": "asus-wireless.c",
  "hash_id": "fa35ab1f0787bc926a913dfd3b2abd6cf769e5e55b26c081e787e0e11b4e45be",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/x86/asus-wireless.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/types.h>\n#include <linux/acpi.h>\n#include <linux/input.h>\n#include <linux/pci_ids.h>\n#include <linux/leds.h>\n\nstruct hswc_params {\n\tu8 on;\n\tu8 off;\n\tu8 status;\n};\n\nstruct asus_wireless_data {\n\tstruct input_dev *idev;\n\tstruct acpi_device *adev;\n\tconst struct hswc_params *hswc_params;\n\tstruct workqueue_struct *wq;\n\tstruct work_struct led_work;\n\tstruct led_classdev led;\n\tint led_state;\n};\n\nstatic const struct hswc_params atk4001_id_params = {\n\t.on = 0x0,\n\t.off = 0x1,\n\t.status = 0x2,\n};\n\nstatic const struct hswc_params atk4002_id_params = {\n\t.on = 0x5,\n\t.off = 0x4,\n\t.status = 0x2,\n};\n\nstatic const struct acpi_device_id device_ids[] = {\n\t{\"ATK4001\", (kernel_ulong_t)&atk4001_id_params},\n\t{\"ATK4002\", (kernel_ulong_t)&atk4002_id_params},\n\t{\"\", 0},\n};\nMODULE_DEVICE_TABLE(acpi, device_ids);\n\nstatic acpi_status asus_wireless_method(acpi_handle handle, const char *method,\n\t\t\t\t\tint param, u64 *ret)\n{\n\tstruct acpi_object_list p;\n\tunion acpi_object obj;\n\tacpi_status s;\n\n\tacpi_handle_debug(handle, \"Evaluating method %s, parameter %#x\\n\",\n\t\t\t  method, param);\n\tobj.type = ACPI_TYPE_INTEGER;\n\tobj.integer.value = param;\n\tp.count = 1;\n\tp.pointer = &obj;\n\n\ts = acpi_evaluate_integer(handle, (acpi_string) method, &p, ret);\n\tif (ACPI_FAILURE(s))\n\t\tacpi_handle_err(handle,\n\t\t\t\t\"Failed to eval method %s, param %#x (%d)\\n\",\n\t\t\t\tmethod, param, s);\n\telse\n\t\tacpi_handle_debug(handle, \"%s returned %#llx\\n\", method, *ret);\n\n\treturn s;\n}\n\nstatic enum led_brightness led_state_get(struct led_classdev *led)\n{\n\tstruct asus_wireless_data *data;\n\tacpi_status s;\n\tu64 ret;\n\n\tdata = container_of(led, struct asus_wireless_data, led);\n\ts = asus_wireless_method(acpi_device_handle(data->adev), \"HSWC\",\n\t\t\t\t data->hswc_params->status, &ret);\n\tif (ACPI_SUCCESS(s) && ret == data->hswc_params->on)\n\t\treturn LED_FULL;\n\treturn LED_OFF;\n}\n\nstatic void led_state_update(struct work_struct *work)\n{\n\tstruct asus_wireless_data *data;\n\tu64 ret;\n\n\tdata = container_of(work, struct asus_wireless_data, led_work);\n\tasus_wireless_method(acpi_device_handle(data->adev), \"HSWC\",\n\t\t\t     data->led_state, &ret);\n}\n\nstatic void led_state_set(struct led_classdev *led, enum led_brightness value)\n{\n\tstruct asus_wireless_data *data;\n\n\tdata = container_of(led, struct asus_wireless_data, led);\n\tdata->led_state = value == LED_OFF ? data->hswc_params->off :\n\t\t\t\t\t     data->hswc_params->on;\n\tqueue_work(data->wq, &data->led_work);\n}\n\nstatic void asus_wireless_notify(struct acpi_device *adev, u32 event)\n{\n\tstruct asus_wireless_data *data = acpi_driver_data(adev);\n\n\tdev_dbg(&adev->dev, \"event=%#x\\n\", event);\n\tif (event != 0x88) {\n\t\tdev_notice(&adev->dev, \"Unknown ASHS event: %#x\\n\", event);\n\t\treturn;\n\t}\n\tinput_report_key(data->idev, KEY_RFKILL, 1);\n\tinput_sync(data->idev);\n\tinput_report_key(data->idev, KEY_RFKILL, 0);\n\tinput_sync(data->idev);\n}\n\nstatic int asus_wireless_add(struct acpi_device *adev)\n{\n\tstruct asus_wireless_data *data;\n\tconst struct acpi_device_id *id;\n\tint err;\n\n\tdata = devm_kzalloc(&adev->dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\tadev->driver_data = data;\n\tdata->adev = adev;\n\n\tdata->idev = devm_input_allocate_device(&adev->dev);\n\tif (!data->idev)\n\t\treturn -ENOMEM;\n\tdata->idev->name = \"Asus Wireless Radio Control\";\n\tdata->idev->phys = \"asus-wireless/input0\";\n\tdata->idev->id.bustype = BUS_HOST;\n\tdata->idev->id.vendor = PCI_VENDOR_ID_ASUSTEK;\n\tset_bit(EV_KEY, data->idev->evbit);\n\tset_bit(KEY_RFKILL, data->idev->keybit);\n\terr = input_register_device(data->idev);\n\tif (err)\n\t\treturn err;\n\n\tfor (id = device_ids; id->id[0]; id++) {\n\t\tif (!strcmp((char *) id->id, acpi_device_hid(adev))) {\n\t\t\tdata->hswc_params =\n\t\t\t\t(const struct hswc_params *)id->driver_data;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!data->hswc_params)\n\t\treturn 0;\n\n\tdata->wq = create_singlethread_workqueue(\"asus_wireless_workqueue\");\n\tif (!data->wq)\n\t\treturn -ENOMEM;\n\tINIT_WORK(&data->led_work, led_state_update);\n\tdata->led.name = \"asus-wireless::airplane\";\n\tdata->led.brightness_set = led_state_set;\n\tdata->led.brightness_get = led_state_get;\n\tdata->led.flags = LED_CORE_SUSPENDRESUME;\n\tdata->led.max_brightness = 1;\n\tdata->led.default_trigger = \"rfkill-none\";\n\terr = devm_led_classdev_register(&adev->dev, &data->led);\n\tif (err)\n\t\tdestroy_workqueue(data->wq);\n\n\treturn err;\n}\n\nstatic void asus_wireless_remove(struct acpi_device *adev)\n{\n\tstruct asus_wireless_data *data = acpi_driver_data(adev);\n\n\tif (data->wq) {\n\t\tdevm_led_classdev_unregister(&adev->dev, &data->led);\n\t\tdestroy_workqueue(data->wq);\n\t}\n}\n\nstatic struct acpi_driver asus_wireless_driver = {\n\t.name = \"Asus Wireless Radio Control Driver\",\n\t.class = \"hotkey\",\n\t.ids = device_ids,\n\t.ops = {\n\t\t.add = asus_wireless_add,\n\t\t.remove = asus_wireless_remove,\n\t\t.notify = asus_wireless_notify,\n\t},\n};\nmodule_acpi_driver(asus_wireless_driver);\n\nMODULE_DESCRIPTION(\"Asus Wireless Radio Control Driver\");\nMODULE_AUTHOR(\"Jo\u00e3o Paulo Rechi Vita <jprvita@gmail.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}