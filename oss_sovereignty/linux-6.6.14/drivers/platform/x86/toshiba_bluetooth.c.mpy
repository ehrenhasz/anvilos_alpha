{
  "module_name": "toshiba_bluetooth.c",
  "hash_id": "81cef811672a8696073e161597f3a85b2fec362e9b1f6d56248bf998d798adee",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/x86/toshiba_bluetooth.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/types.h>\n#include <linux/acpi.h>\n#include <linux/rfkill.h>\n\n#define BT_KILLSWITCH_MASK\t0x01\n#define BT_PLUGGED_MASK\t\t0x40\n#define BT_POWER_MASK\t\t0x80\n\nMODULE_AUTHOR(\"Jes Sorensen <Jes.Sorensen@gmail.com>\");\nMODULE_DESCRIPTION(\"Toshiba Laptop ACPI Bluetooth Enable Driver\");\nMODULE_LICENSE(\"GPL\");\n\nstruct toshiba_bluetooth_dev {\n\tstruct acpi_device *acpi_dev;\n\tstruct rfkill *rfk;\n\n\tbool killswitch;\n\tbool plugged;\n\tbool powered;\n};\n\nstatic int toshiba_bt_rfkill_add(struct acpi_device *device);\nstatic void toshiba_bt_rfkill_remove(struct acpi_device *device);\nstatic void toshiba_bt_rfkill_notify(struct acpi_device *device, u32 event);\n\nstatic const struct acpi_device_id bt_device_ids[] = {\n\t{ \"TOS6205\", 0},\n\t{ \"\", 0},\n};\nMODULE_DEVICE_TABLE(acpi, bt_device_ids);\n\n#ifdef CONFIG_PM_SLEEP\nstatic int toshiba_bt_resume(struct device *dev);\n#endif\nstatic SIMPLE_DEV_PM_OPS(toshiba_bt_pm, NULL, toshiba_bt_resume);\n\nstatic struct acpi_driver toshiba_bt_rfkill_driver = {\n\t.name =\t\t\"Toshiba BT\",\n\t.class =\t\"Toshiba\",\n\t.ids =\t\tbt_device_ids,\n\t.ops =\t\t{\n\t\t\t\t.add =\t\ttoshiba_bt_rfkill_add,\n\t\t\t\t.remove =\ttoshiba_bt_rfkill_remove,\n\t\t\t\t.notify =\ttoshiba_bt_rfkill_notify,\n\t\t\t},\n\t.owner = \tTHIS_MODULE,\n\t.drv.pm =\t&toshiba_bt_pm,\n};\n\nstatic int toshiba_bluetooth_present(acpi_handle handle)\n{\n\tacpi_status result;\n\tu64 bt_present;\n\n\t \n\tresult = acpi_evaluate_integer(handle, \"_STA\", NULL, &bt_present);\n\tif (ACPI_FAILURE(result)) {\n\t\tpr_err(\"ACPI call to query Bluetooth presence failed\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tif (!bt_present) {\n\t\tpr_info(\"Bluetooth device not present\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic int toshiba_bluetooth_status(acpi_handle handle)\n{\n\tacpi_status result;\n\tu64 status;\n\n\tresult = acpi_evaluate_integer(handle, \"BTST\", NULL, &status);\n\tif (ACPI_FAILURE(result)) {\n\t\tpr_err(\"Could not get Bluetooth device status\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\treturn status;\n}\n\nstatic int toshiba_bluetooth_enable(acpi_handle handle)\n{\n\tacpi_status result;\n\n\tresult = acpi_evaluate_object(handle, \"AUSB\", NULL, NULL);\n\tif (ACPI_FAILURE(result)) {\n\t\tpr_err(\"Could not attach USB Bluetooth device\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tresult = acpi_evaluate_object(handle, \"BTPO\", NULL, NULL);\n\tif (ACPI_FAILURE(result)) {\n\t\tpr_err(\"Could not power ON Bluetooth device\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int toshiba_bluetooth_disable(acpi_handle handle)\n{\n\tacpi_status result;\n\n\tresult = acpi_evaluate_object(handle, \"BTPF\", NULL, NULL);\n\tif (ACPI_FAILURE(result)) {\n\t\tpr_err(\"Could not power OFF Bluetooth device\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tresult = acpi_evaluate_object(handle, \"DUSB\", NULL, NULL);\n\tif (ACPI_FAILURE(result)) {\n\t\tpr_err(\"Could not detach USB Bluetooth device\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int toshiba_bluetooth_sync_status(struct toshiba_bluetooth_dev *bt_dev)\n{\n\tint status;\n\n\tstatus = toshiba_bluetooth_status(bt_dev->acpi_dev->handle);\n\tif (status < 0) {\n\t\tpr_err(\"Could not sync bluetooth device status\\n\");\n\t\treturn status;\n\t}\n\n\tbt_dev->killswitch = (status & BT_KILLSWITCH_MASK) ? true : false;\n\tbt_dev->plugged = (status & BT_PLUGGED_MASK) ? true : false;\n\tbt_dev->powered = (status & BT_POWER_MASK) ? true : false;\n\n\tpr_debug(\"Bluetooth status %d killswitch %d plugged %d powered %d\\n\",\n\t\t status, bt_dev->killswitch, bt_dev->plugged, bt_dev->powered);\n\n\treturn 0;\n}\n\n \nstatic int bt_rfkill_set_block(void *data, bool blocked)\n{\n\tstruct toshiba_bluetooth_dev *bt_dev = data;\n\tint ret;\n\n\tret = toshiba_bluetooth_sync_status(bt_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!bt_dev->killswitch)\n\t\treturn 0;\n\n\tif (blocked)\n\t\tret = toshiba_bluetooth_disable(bt_dev->acpi_dev->handle);\n\telse\n\t\tret = toshiba_bluetooth_enable(bt_dev->acpi_dev->handle);\n\n\treturn ret;\n}\n\nstatic void bt_rfkill_poll(struct rfkill *rfkill, void *data)\n{\n\tstruct toshiba_bluetooth_dev *bt_dev = data;\n\n\tif (toshiba_bluetooth_sync_status(bt_dev))\n\t\treturn;\n\n\t \n\trfkill_set_hw_state(bt_dev->rfk, !bt_dev->killswitch);\n}\n\nstatic const struct rfkill_ops rfk_ops = {\n\t.set_block = bt_rfkill_set_block,\n\t.poll = bt_rfkill_poll,\n};\n\n \nstatic void toshiba_bt_rfkill_notify(struct acpi_device *device, u32 event)\n{\n\tstruct toshiba_bluetooth_dev *bt_dev = acpi_driver_data(device);\n\n\tif (toshiba_bluetooth_sync_status(bt_dev))\n\t\treturn;\n\n\trfkill_set_hw_state(bt_dev->rfk, !bt_dev->killswitch);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int toshiba_bt_resume(struct device *dev)\n{\n\tstruct toshiba_bluetooth_dev *bt_dev;\n\tint ret;\n\n\tbt_dev = acpi_driver_data(to_acpi_device(dev));\n\n\tret = toshiba_bluetooth_sync_status(bt_dev);\n\tif (ret)\n\t\treturn ret;\n\n\trfkill_set_hw_state(bt_dev->rfk, !bt_dev->killswitch);\n\n\treturn 0;\n}\n#endif\n\nstatic int toshiba_bt_rfkill_add(struct acpi_device *device)\n{\n\tstruct toshiba_bluetooth_dev *bt_dev;\n\tint result;\n\n\tresult = toshiba_bluetooth_present(device->handle);\n\tif (result)\n\t\treturn result;\n\n\tpr_info(\"Toshiba ACPI Bluetooth device driver\\n\");\n\n\tbt_dev = kzalloc(sizeof(*bt_dev), GFP_KERNEL);\n\tif (!bt_dev)\n\t\treturn -ENOMEM;\n\tbt_dev->acpi_dev = device;\n\tdevice->driver_data = bt_dev;\n\tdev_set_drvdata(&device->dev, bt_dev);\n\n\tresult = toshiba_bluetooth_sync_status(bt_dev);\n\tif (result) {\n\t\tkfree(bt_dev);\n\t\treturn result;\n\t}\n\n\tbt_dev->rfk = rfkill_alloc(\"Toshiba Bluetooth\",\n\t\t\t\t   &device->dev,\n\t\t\t\t   RFKILL_TYPE_BLUETOOTH,\n\t\t\t\t   &rfk_ops,\n\t\t\t\t   bt_dev);\n\tif (!bt_dev->rfk) {\n\t\tpr_err(\"Unable to allocate rfkill device\\n\");\n\t\tkfree(bt_dev);\n\t\treturn -ENOMEM;\n\t}\n\n\trfkill_set_hw_state(bt_dev->rfk, !bt_dev->killswitch);\n\n\tresult = rfkill_register(bt_dev->rfk);\n\tif (result) {\n\t\tpr_err(\"Unable to register rfkill device\\n\");\n\t\trfkill_destroy(bt_dev->rfk);\n\t\tkfree(bt_dev);\n\t}\n\n\treturn result;\n}\n\nstatic void toshiba_bt_rfkill_remove(struct acpi_device *device)\n{\n\tstruct toshiba_bluetooth_dev *bt_dev = acpi_driver_data(device);\n\n\t \n\tif (bt_dev->rfk) {\n\t\trfkill_unregister(bt_dev->rfk);\n\t\trfkill_destroy(bt_dev->rfk);\n\t}\n\n\tkfree(bt_dev);\n\n\ttoshiba_bluetooth_disable(device->handle);\n}\n\nmodule_acpi_driver(toshiba_bt_rfkill_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}