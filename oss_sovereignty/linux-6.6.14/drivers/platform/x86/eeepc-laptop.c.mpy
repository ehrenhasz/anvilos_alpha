{
  "module_name": "eeepc-laptop.c",
  "hash_id": "84bd7b0cb4045f441fb5999e017e3644bfa0082fec43c66003ed7433256385db",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/x86/eeepc-laptop.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/types.h>\n#include <linux/platform_device.h>\n#include <linux/backlight.h>\n#include <linux/fb.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/slab.h>\n#include <linux/acpi.h>\n#include <linux/uaccess.h>\n#include <linux/input.h>\n#include <linux/input/sparse-keymap.h>\n#include <linux/rfkill.h>\n#include <linux/pci.h>\n#include <linux/pci_hotplug.h>\n#include <linux/leds.h>\n#include <linux/dmi.h>\n#include <acpi/video.h>\n\n#define EEEPC_LAPTOP_VERSION\t\"0.1\"\n#define EEEPC_LAPTOP_NAME\t\"Eee PC Hotkey Driver\"\n#define EEEPC_LAPTOP_FILE\t\"eeepc\"\n\n#define EEEPC_ACPI_CLASS\t\"hotkey\"\n#define EEEPC_ACPI_DEVICE_NAME\t\"Hotkey\"\n#define EEEPC_ACPI_HID\t\t\"ASUS010\"\n\nMODULE_AUTHOR(\"Corentin Chary, Eric Cooper\");\nMODULE_DESCRIPTION(EEEPC_LAPTOP_NAME);\nMODULE_LICENSE(\"GPL\");\n\nstatic bool hotplug_disabled;\n\nmodule_param(hotplug_disabled, bool, 0444);\nMODULE_PARM_DESC(hotplug_disabled,\n\t\t \"Disable hotplug for wireless device. \"\n\t\t \"If your laptop need that, please report to \"\n\t\t \"acpi4asus-user@lists.sourceforge.net.\");\n\n \n#define NOTIFY_BRN_MIN\t0x20\n#define NOTIFY_BRN_MAX\t0x2f\n\nenum {\n\tDISABLE_ASL_WLAN = 0x0001,\n\tDISABLE_ASL_BLUETOOTH = 0x0002,\n\tDISABLE_ASL_IRDA = 0x0004,\n\tDISABLE_ASL_CAMERA = 0x0008,\n\tDISABLE_ASL_TV = 0x0010,\n\tDISABLE_ASL_GPS = 0x0020,\n\tDISABLE_ASL_DISPLAYSWITCH = 0x0040,\n\tDISABLE_ASL_MODEM = 0x0080,\n\tDISABLE_ASL_CARDREADER = 0x0100,\n\tDISABLE_ASL_3G = 0x0200,\n\tDISABLE_ASL_WIMAX = 0x0400,\n\tDISABLE_ASL_HWCF = 0x0800\n};\n\nenum {\n\tCM_ASL_WLAN = 0,\n\tCM_ASL_BLUETOOTH,\n\tCM_ASL_IRDA,\n\tCM_ASL_1394,\n\tCM_ASL_CAMERA,\n\tCM_ASL_TV,\n\tCM_ASL_GPS,\n\tCM_ASL_DVDROM,\n\tCM_ASL_DISPLAYSWITCH,\n\tCM_ASL_PANELBRIGHT,\n\tCM_ASL_BIOSFLASH,\n\tCM_ASL_ACPIFLASH,\n\tCM_ASL_CPUFV,\n\tCM_ASL_CPUTEMPERATURE,\n\tCM_ASL_FANCPU,\n\tCM_ASL_FANCHASSIS,\n\tCM_ASL_USBPORT1,\n\tCM_ASL_USBPORT2,\n\tCM_ASL_USBPORT3,\n\tCM_ASL_MODEM,\n\tCM_ASL_CARDREADER,\n\tCM_ASL_3G,\n\tCM_ASL_WIMAX,\n\tCM_ASL_HWCF,\n\tCM_ASL_LID,\n\tCM_ASL_TYPE,\n\tCM_ASL_PANELPOWER,\t \n\tCM_ASL_TPD\n};\n\nstatic const char *cm_getv[] = {\n\t\"WLDG\", \"BTHG\", NULL, NULL,\n\t\"CAMG\", NULL, NULL, NULL,\n\tNULL, \"PBLG\", NULL, NULL,\n\t\"CFVG\", NULL, NULL, NULL,\n\t\"USBG\", NULL, NULL, \"MODG\",\n\t\"CRDG\", \"M3GG\", \"WIMG\", \"HWCF\",\n\t\"LIDG\",\t\"TYPE\", \"PBPG\",\t\"TPDG\"\n};\n\nstatic const char *cm_setv[] = {\n\t\"WLDS\", \"BTHS\", NULL, NULL,\n\t\"CAMS\", NULL, NULL, NULL,\n\t\"SDSP\", \"PBLS\", \"HDPS\", NULL,\n\t\"CFVS\", NULL, NULL, NULL,\n\t\"USBG\", NULL, NULL, \"MODS\",\n\t\"CRDS\", \"M3GS\", \"WIMS\", NULL,\n\tNULL, NULL, \"PBPS\", \"TPDS\"\n};\n\nstatic const struct key_entry eeepc_keymap[] = {\n\t{ KE_KEY, 0x10, { KEY_WLAN } },\n\t{ KE_KEY, 0x11, { KEY_WLAN } },\n\t{ KE_KEY, 0x12, { KEY_PROG1 } },\n\t{ KE_KEY, 0x13, { KEY_MUTE } },\n\t{ KE_KEY, 0x14, { KEY_VOLUMEDOWN } },\n\t{ KE_KEY, 0x15, { KEY_VOLUMEUP } },\n\t{ KE_KEY, 0x16, { KEY_DISPLAY_OFF } },\n\t{ KE_KEY, 0x1a, { KEY_COFFEE } },\n\t{ KE_KEY, 0x1b, { KEY_ZOOM } },\n\t{ KE_KEY, 0x1c, { KEY_PROG2 } },\n\t{ KE_KEY, 0x1d, { KEY_PROG3 } },\n\t{ KE_KEY, NOTIFY_BRN_MIN, { KEY_BRIGHTNESSDOWN } },\n\t{ KE_KEY, NOTIFY_BRN_MAX, { KEY_BRIGHTNESSUP } },\n\t{ KE_KEY, 0x30, { KEY_SWITCHVIDEOMODE } },\n\t{ KE_KEY, 0x31, { KEY_SWITCHVIDEOMODE } },\n\t{ KE_KEY, 0x32, { KEY_SWITCHVIDEOMODE } },\n\t{ KE_KEY, 0x37, { KEY_F13 } },  \n\t{ KE_KEY, 0x38, { KEY_F14 } },\n\t{ KE_IGNORE, 0x50, { KEY_RESERVED } },  \n\t{ KE_IGNORE, 0x51, { KEY_RESERVED } },  \n\t{ KE_END, 0 },\n};\n\n \nstruct eeepc_laptop {\n\tacpi_handle handle;\t\t \n\tu32 cm_supported;\t\t \n\tbool cpufv_disabled;\n\tbool hotplug_disabled;\n\tu16 event_count[128];\t\t \n\n\tstruct platform_device *platform_device;\n\tstruct acpi_device *device;\t\t \n\tstruct backlight_device *backlight_device;\n\n\tstruct input_dev *inputdev;\n\n\tstruct rfkill *wlan_rfkill;\n\tstruct rfkill *bluetooth_rfkill;\n\tstruct rfkill *wwan3g_rfkill;\n\tstruct rfkill *wimax_rfkill;\n\n\tstruct hotplug_slot hotplug_slot;\n\tstruct mutex hotplug_lock;\n\n\tstruct led_classdev tpd_led;\n\tint tpd_led_wk;\n\tstruct workqueue_struct *led_workqueue;\n\tstruct work_struct tpd_led_work;\n};\n\n \nstatic int write_acpi_int(acpi_handle handle, const char *method, int val)\n{\n\tacpi_status status;\n\n\tstatus = acpi_execute_simple_method(handle, (char *)method, val);\n\n\treturn (status == AE_OK ? 0 : -1);\n}\n\nstatic int read_acpi_int(acpi_handle handle, const char *method, int *val)\n{\n\tacpi_status status;\n\tunsigned long long result;\n\n\tstatus = acpi_evaluate_integer(handle, (char *)method, NULL, &result);\n\tif (ACPI_FAILURE(status)) {\n\t\t*val = -1;\n\t\treturn -1;\n\t} else {\n\t\t*val = result;\n\t\treturn 0;\n\t}\n}\n\nstatic int set_acpi(struct eeepc_laptop *eeepc, int cm, int value)\n{\n\tconst char *method = cm_setv[cm];\n\n\tif (method == NULL)\n\t\treturn -ENODEV;\n\tif ((eeepc->cm_supported & (0x1 << cm)) == 0)\n\t\treturn -ENODEV;\n\n\tif (write_acpi_int(eeepc->handle, method, value))\n\t\tpr_warn(\"Error writing %s\\n\", method);\n\treturn 0;\n}\n\nstatic int get_acpi(struct eeepc_laptop *eeepc, int cm)\n{\n\tconst char *method = cm_getv[cm];\n\tint value;\n\n\tif (method == NULL)\n\t\treturn -ENODEV;\n\tif ((eeepc->cm_supported & (0x1 << cm)) == 0)\n\t\treturn -ENODEV;\n\n\tif (read_acpi_int(eeepc->handle, method, &value))\n\t\tpr_warn(\"Error reading %s\\n\", method);\n\treturn value;\n}\n\nstatic int acpi_setter_handle(struct eeepc_laptop *eeepc, int cm,\n\t\t\t      acpi_handle *handle)\n{\n\tconst char *method = cm_setv[cm];\n\tacpi_status status;\n\n\tif (method == NULL)\n\t\treturn -ENODEV;\n\tif ((eeepc->cm_supported & (0x1 << cm)) == 0)\n\t\treturn -ENODEV;\n\n\tstatus = acpi_get_handle(eeepc->handle, (char *)method,\n\t\t\t\t handle);\n\tif (status != AE_OK) {\n\t\tpr_warn(\"Error finding %s\\n\", method);\n\t\treturn -ENODEV;\n\t}\n\treturn 0;\n}\n\n\n \nstatic int parse_arg(const char *buf, int *val)\n{\n\tif (sscanf(buf, \"%i\", val) != 1)\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic ssize_t store_sys_acpi(struct device *dev, int cm,\n\t\t\t      const char *buf, size_t count)\n{\n\tstruct eeepc_laptop *eeepc = dev_get_drvdata(dev);\n\tint rv, value;\n\n\trv = parse_arg(buf, &value);\n\tif (rv < 0)\n\t\treturn rv;\n\trv = set_acpi(eeepc, cm, value);\n\tif (rv < 0)\n\t\treturn -EIO;\n\treturn count;\n}\n\nstatic ssize_t show_sys_acpi(struct device *dev, int cm, char *buf)\n{\n\tstruct eeepc_laptop *eeepc = dev_get_drvdata(dev);\n\tint value = get_acpi(eeepc, cm);\n\n\tif (value < 0)\n\t\treturn -EIO;\n\treturn sprintf(buf, \"%d\\n\", value);\n}\n\n#define EEEPC_ACPI_SHOW_FUNC(_name, _cm)\t\t\t\t\\\n\tstatic ssize_t _name##_show(struct device *dev,\t\t\t\\\n\t\t\t\t    struct device_attribute *attr,\t\\\n\t\t\t\t    char *buf)\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\treturn show_sys_acpi(dev, _cm, buf);\t\t\t\\\n\t}\n\n#define EEEPC_ACPI_STORE_FUNC(_name, _cm)\t\t\t\t\\\n\tstatic ssize_t _name##_store(struct device *dev,\t\t\\\n\t\t\t\t     struct device_attribute *attr,\t\\\n\t\t\t\t     const char *buf, size_t count)\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\treturn store_sys_acpi(dev, _cm, buf, count);\t\t\\\n\t}\n\n#define EEEPC_CREATE_DEVICE_ATTR_RW(_name, _cm)\t\t\t\t\\\n\tEEEPC_ACPI_SHOW_FUNC(_name, _cm)\t\t\t\t\\\n\tEEEPC_ACPI_STORE_FUNC(_name, _cm)\t\t\t\t\\\n\tstatic DEVICE_ATTR_RW(_name)\n\n#define EEEPC_CREATE_DEVICE_ATTR_WO(_name, _cm)\t\t\t\t\\\n\tEEEPC_ACPI_STORE_FUNC(_name, _cm)\t\t\t\t\\\n\tstatic DEVICE_ATTR_WO(_name)\n\nEEEPC_CREATE_DEVICE_ATTR_RW(camera, CM_ASL_CAMERA);\nEEEPC_CREATE_DEVICE_ATTR_RW(cardr, CM_ASL_CARDREADER);\nEEEPC_CREATE_DEVICE_ATTR_WO(disp, CM_ASL_DISPLAYSWITCH);\n\nstruct eeepc_cpufv {\n\tint num;\n\tint cur;\n};\n\nstatic int get_cpufv(struct eeepc_laptop *eeepc, struct eeepc_cpufv *c)\n{\n\tc->cur = get_acpi(eeepc, CM_ASL_CPUFV);\n\tif (c->cur < 0)\n\t\treturn -ENODEV;\n\n\tc->num = (c->cur >> 8) & 0xff;\n\tc->cur &= 0xff;\n\tif (c->num == 0 || c->num > 12)\n\t\treturn -ENODEV;\n\treturn 0;\n}\n\nstatic ssize_t available_cpufv_show(struct device *dev,\n\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t    char *buf)\n{\n\tstruct eeepc_laptop *eeepc = dev_get_drvdata(dev);\n\tstruct eeepc_cpufv c;\n\tint i;\n\tssize_t len = 0;\n\n\tif (get_cpufv(eeepc, &c))\n\t\treturn -ENODEV;\n\tfor (i = 0; i < c.num; i++)\n\t\tlen += sprintf(buf + len, \"%d \", i);\n\tlen += sprintf(buf + len, \"\\n\");\n\treturn len;\n}\n\nstatic ssize_t cpufv_show(struct device *dev,\n\t\t\t  struct device_attribute *attr,\n\t\t\t  char *buf)\n{\n\tstruct eeepc_laptop *eeepc = dev_get_drvdata(dev);\n\tstruct eeepc_cpufv c;\n\n\tif (get_cpufv(eeepc, &c))\n\t\treturn -ENODEV;\n\treturn sprintf(buf, \"%#x\\n\", (c.num << 8) | c.cur);\n}\n\nstatic ssize_t cpufv_store(struct device *dev,\n\t\t\t   struct device_attribute *attr,\n\t\t\t   const char *buf, size_t count)\n{\n\tstruct eeepc_laptop *eeepc = dev_get_drvdata(dev);\n\tstruct eeepc_cpufv c;\n\tint rv, value;\n\n\tif (eeepc->cpufv_disabled)\n\t\treturn -EPERM;\n\tif (get_cpufv(eeepc, &c))\n\t\treturn -ENODEV;\n\trv = parse_arg(buf, &value);\n\tif (rv < 0)\n\t\treturn rv;\n\tif (value < 0 || value >= c.num)\n\t\treturn -EINVAL;\n\trv = set_acpi(eeepc, CM_ASL_CPUFV, value);\n\tif (rv)\n\t\treturn rv;\n\treturn count;\n}\n\nstatic ssize_t cpufv_disabled_show(struct device *dev,\n\t\t\t  struct device_attribute *attr,\n\t\t\t  char *buf)\n{\n\tstruct eeepc_laptop *eeepc = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%d\\n\", eeepc->cpufv_disabled);\n}\n\nstatic ssize_t cpufv_disabled_store(struct device *dev,\n\t\t\t   struct device_attribute *attr,\n\t\t\t   const char *buf, size_t count)\n{\n\tstruct eeepc_laptop *eeepc = dev_get_drvdata(dev);\n\tint rv, value;\n\n\trv = parse_arg(buf, &value);\n\tif (rv < 0)\n\t\treturn rv;\n\n\tswitch (value) {\n\tcase 0:\n\t\tif (eeepc->cpufv_disabled)\n\t\t\tpr_warn(\"cpufv enabled (not officially supported on this model)\\n\");\n\t\teeepc->cpufv_disabled = false;\n\t\treturn count;\n\tcase 1:\n\t\treturn -EPERM;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\n\nstatic DEVICE_ATTR_RW(cpufv);\nstatic DEVICE_ATTR_RO(available_cpufv);\nstatic DEVICE_ATTR_RW(cpufv_disabled);\n\nstatic struct attribute *platform_attributes[] = {\n\t&dev_attr_camera.attr,\n\t&dev_attr_cardr.attr,\n\t&dev_attr_disp.attr,\n\t&dev_attr_cpufv.attr,\n\t&dev_attr_available_cpufv.attr,\n\t&dev_attr_cpufv_disabled.attr,\n\tNULL\n};\n\nstatic const struct attribute_group platform_attribute_group = {\n\t.attrs = platform_attributes\n};\n\nstatic int eeepc_platform_init(struct eeepc_laptop *eeepc)\n{\n\tint result;\n\n\teeepc->platform_device = platform_device_alloc(EEEPC_LAPTOP_FILE, PLATFORM_DEVID_NONE);\n\tif (!eeepc->platform_device)\n\t\treturn -ENOMEM;\n\tplatform_set_drvdata(eeepc->platform_device, eeepc);\n\n\tresult = platform_device_add(eeepc->platform_device);\n\tif (result)\n\t\tgoto fail_platform_device;\n\n\tresult = sysfs_create_group(&eeepc->platform_device->dev.kobj,\n\t\t\t\t    &platform_attribute_group);\n\tif (result)\n\t\tgoto fail_sysfs;\n\treturn 0;\n\nfail_sysfs:\n\tplatform_device_del(eeepc->platform_device);\nfail_platform_device:\n\tplatform_device_put(eeepc->platform_device);\n\treturn result;\n}\n\nstatic void eeepc_platform_exit(struct eeepc_laptop *eeepc)\n{\n\tsysfs_remove_group(&eeepc->platform_device->dev.kobj,\n\t\t\t   &platform_attribute_group);\n\tplatform_device_unregister(eeepc->platform_device);\n}\n\n \n \nstatic void tpd_led_update(struct work_struct *work)\n{\n\tstruct eeepc_laptop *eeepc;\n\n\teeepc = container_of(work, struct eeepc_laptop, tpd_led_work);\n\n\tset_acpi(eeepc, CM_ASL_TPD, eeepc->tpd_led_wk);\n}\n\nstatic void tpd_led_set(struct led_classdev *led_cdev,\n\t\t\tenum led_brightness value)\n{\n\tstruct eeepc_laptop *eeepc;\n\n\teeepc = container_of(led_cdev, struct eeepc_laptop, tpd_led);\n\n\teeepc->tpd_led_wk = (value > 0) ? 1 : 0;\n\tqueue_work(eeepc->led_workqueue, &eeepc->tpd_led_work);\n}\n\nstatic enum led_brightness tpd_led_get(struct led_classdev *led_cdev)\n{\n\tstruct eeepc_laptop *eeepc;\n\n\teeepc = container_of(led_cdev, struct eeepc_laptop, tpd_led);\n\n\treturn get_acpi(eeepc, CM_ASL_TPD);\n}\n\nstatic int eeepc_led_init(struct eeepc_laptop *eeepc)\n{\n\tint rv;\n\n\tif (get_acpi(eeepc, CM_ASL_TPD) == -ENODEV)\n\t\treturn 0;\n\n\teeepc->led_workqueue = create_singlethread_workqueue(\"led_workqueue\");\n\tif (!eeepc->led_workqueue)\n\t\treturn -ENOMEM;\n\tINIT_WORK(&eeepc->tpd_led_work, tpd_led_update);\n\n\teeepc->tpd_led.name = \"eeepc::touchpad\";\n\teeepc->tpd_led.brightness_set = tpd_led_set;\n\tif (get_acpi(eeepc, CM_ASL_TPD) >= 0)  \n\t\teeepc->tpd_led.brightness_get = tpd_led_get;\n\teeepc->tpd_led.max_brightness = 1;\n\n\trv = led_classdev_register(&eeepc->platform_device->dev,\n\t\t\t\t   &eeepc->tpd_led);\n\tif (rv) {\n\t\tdestroy_workqueue(eeepc->led_workqueue);\n\t\treturn rv;\n\t}\n\n\treturn 0;\n}\n\nstatic void eeepc_led_exit(struct eeepc_laptop *eeepc)\n{\n\tled_classdev_unregister(&eeepc->tpd_led);\n\tif (eeepc->led_workqueue)\n\t\tdestroy_workqueue(eeepc->led_workqueue);\n}\n\n \nstatic bool eeepc_wlan_rfkill_blocked(struct eeepc_laptop *eeepc)\n{\n\tif (get_acpi(eeepc, CM_ASL_WLAN) == 1)\n\t\treturn false;\n\treturn true;\n}\n\nstatic void eeepc_rfkill_hotplug(struct eeepc_laptop *eeepc, acpi_handle handle)\n{\n\tstruct pci_dev *port;\n\tstruct pci_dev *dev;\n\tstruct pci_bus *bus;\n\tbool blocked = eeepc_wlan_rfkill_blocked(eeepc);\n\tbool absent;\n\tu32 l;\n\n\tif (eeepc->wlan_rfkill)\n\t\trfkill_set_sw_state(eeepc->wlan_rfkill, blocked);\n\n\tmutex_lock(&eeepc->hotplug_lock);\n\tpci_lock_rescan_remove();\n\n\tif (!eeepc->hotplug_slot.ops)\n\t\tgoto out_unlock;\n\n\tport = acpi_get_pci_dev(handle);\n\tif (!port) {\n\t\tpr_warn(\"Unable to find port\\n\");\n\t\tgoto out_unlock;\n\t}\n\n\tbus = port->subordinate;\n\n\tif (!bus) {\n\t\tpr_warn(\"Unable to find PCI bus 1?\\n\");\n\t\tgoto out_put_dev;\n\t}\n\n\tif (pci_bus_read_config_dword(bus, 0, PCI_VENDOR_ID, &l)) {\n\t\tpr_err(\"Unable to read PCI config space?\\n\");\n\t\tgoto out_put_dev;\n\t}\n\n\tabsent = (l == 0xffffffff);\n\n\tif (blocked != absent) {\n\t\tpr_warn(\"BIOS says wireless lan is %s, but the pci device is %s\\n\",\n\t\t\tblocked ? \"blocked\" : \"unblocked\",\n\t\t\tabsent ? \"absent\" : \"present\");\n\t\tpr_warn(\"skipped wireless hotplug as probably inappropriate for this model\\n\");\n\t\tgoto out_put_dev;\n\t}\n\n\tif (!blocked) {\n\t\tdev = pci_get_slot(bus, 0);\n\t\tif (dev) {\n\t\t\t \n\t\t\tpci_dev_put(dev);\n\t\t\tgoto out_put_dev;\n\t\t}\n\t\tdev = pci_scan_single_device(bus, 0);\n\t\tif (dev) {\n\t\t\tpci_bus_assign_resources(bus);\n\t\t\tpci_bus_add_device(dev);\n\t\t}\n\t} else {\n\t\tdev = pci_get_slot(bus, 0);\n\t\tif (dev) {\n\t\t\tpci_stop_and_remove_bus_device(dev);\n\t\t\tpci_dev_put(dev);\n\t\t}\n\t}\nout_put_dev:\n\tpci_dev_put(port);\n\nout_unlock:\n\tpci_unlock_rescan_remove();\n\tmutex_unlock(&eeepc->hotplug_lock);\n}\n\nstatic void eeepc_rfkill_hotplug_update(struct eeepc_laptop *eeepc, char *node)\n{\n\tacpi_status status = AE_OK;\n\tacpi_handle handle;\n\n\tstatus = acpi_get_handle(NULL, node, &handle);\n\n\tif (ACPI_SUCCESS(status))\n\t\teeepc_rfkill_hotplug(eeepc, handle);\n}\n\nstatic void eeepc_rfkill_notify(acpi_handle handle, u32 event, void *data)\n{\n\tstruct eeepc_laptop *eeepc = data;\n\n\tif (event != ACPI_NOTIFY_BUS_CHECK)\n\t\treturn;\n\n\teeepc_rfkill_hotplug(eeepc, handle);\n}\n\nstatic int eeepc_register_rfkill_notifier(struct eeepc_laptop *eeepc,\n\t\t\t\t\t  char *node)\n{\n\tacpi_status status;\n\tacpi_handle handle;\n\n\tstatus = acpi_get_handle(NULL, node, &handle);\n\n\tif (ACPI_FAILURE(status))\n\t\treturn -ENODEV;\n\n\tstatus = acpi_install_notify_handler(handle,\n\t\t\t\t\t     ACPI_SYSTEM_NOTIFY,\n\t\t\t\t\t     eeepc_rfkill_notify,\n\t\t\t\t\t     eeepc);\n\tif (ACPI_FAILURE(status))\n\t\tpr_warn(\"Failed to register notify on %s\\n\", node);\n\n\t \n\teeepc_rfkill_hotplug(eeepc, handle);\n\treturn 0;\n}\n\nstatic void eeepc_unregister_rfkill_notifier(struct eeepc_laptop *eeepc,\n\t\t\t\t\t     char *node)\n{\n\tacpi_status status = AE_OK;\n\tacpi_handle handle;\n\n\tstatus = acpi_get_handle(NULL, node, &handle);\n\n\tif (ACPI_FAILURE(status))\n\t\treturn;\n\n\tstatus = acpi_remove_notify_handler(handle,\n\t\t\t\t\t     ACPI_SYSTEM_NOTIFY,\n\t\t\t\t\t     eeepc_rfkill_notify);\n\tif (ACPI_FAILURE(status))\n\t\tpr_err(\"Error removing rfkill notify handler %s\\n\",\n\t\t\tnode);\n\t\t \n\teeepc_rfkill_hotplug(eeepc, handle);\n}\n\nstatic int eeepc_get_adapter_status(struct hotplug_slot *hotplug_slot,\n\t\t\t\t    u8 *value)\n{\n\tstruct eeepc_laptop *eeepc;\n\tint val;\n\n\teeepc = container_of(hotplug_slot, struct eeepc_laptop, hotplug_slot);\n\tval = get_acpi(eeepc, CM_ASL_WLAN);\n\n\tif (val == 1 || val == 0)\n\t\t*value = val;\n\telse\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic const struct hotplug_slot_ops eeepc_hotplug_slot_ops = {\n\t.get_adapter_status = eeepc_get_adapter_status,\n\t.get_power_status = eeepc_get_adapter_status,\n};\n\nstatic int eeepc_setup_pci_hotplug(struct eeepc_laptop *eeepc)\n{\n\tint ret = -ENOMEM;\n\tstruct pci_bus *bus = pci_find_bus(0, 1);\n\n\tif (!bus) {\n\t\tpr_err(\"Unable to find wifi PCI bus\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\teeepc->hotplug_slot.ops = &eeepc_hotplug_slot_ops;\n\n\tret = pci_hp_register(&eeepc->hotplug_slot, bus, 0, \"eeepc-wifi\");\n\tif (ret) {\n\t\tpr_err(\"Unable to register hotplug slot - %d\\n\", ret);\n\t\tgoto error_register;\n\t}\n\n\treturn 0;\n\nerror_register:\n\teeepc->hotplug_slot.ops = NULL;\n\treturn ret;\n}\n\n \nstatic int eeepc_rfkill_set(void *data, bool blocked)\n{\n\tacpi_handle handle = data;\n\n\treturn write_acpi_int(handle, NULL, !blocked);\n}\n\nstatic const struct rfkill_ops eeepc_rfkill_ops = {\n\t.set_block = eeepc_rfkill_set,\n};\n\nstatic int eeepc_new_rfkill(struct eeepc_laptop *eeepc,\n\t\t\t    struct rfkill **rfkill,\n\t\t\t    const char *name,\n\t\t\t    enum rfkill_type type, int cm)\n{\n\tacpi_handle handle;\n\tint result;\n\n\tresult = acpi_setter_handle(eeepc, cm, &handle);\n\tif (result < 0)\n\t\treturn result;\n\n\t*rfkill = rfkill_alloc(name, &eeepc->platform_device->dev, type,\n\t\t\t       &eeepc_rfkill_ops, handle);\n\n\tif (!*rfkill)\n\t\treturn -EINVAL;\n\n\trfkill_init_sw_state(*rfkill, get_acpi(eeepc, cm) != 1);\n\tresult = rfkill_register(*rfkill);\n\tif (result) {\n\t\trfkill_destroy(*rfkill);\n\t\t*rfkill = NULL;\n\t\treturn result;\n\t}\n\treturn 0;\n}\n\nstatic char EEEPC_RFKILL_NODE_1[] = \"\\\\_SB.PCI0.P0P5\";\nstatic char EEEPC_RFKILL_NODE_2[] = \"\\\\_SB.PCI0.P0P6\";\nstatic char EEEPC_RFKILL_NODE_3[] = \"\\\\_SB.PCI0.P0P7\";\n\nstatic void eeepc_rfkill_exit(struct eeepc_laptop *eeepc)\n{\n\teeepc_unregister_rfkill_notifier(eeepc, EEEPC_RFKILL_NODE_1);\n\teeepc_unregister_rfkill_notifier(eeepc, EEEPC_RFKILL_NODE_2);\n\teeepc_unregister_rfkill_notifier(eeepc, EEEPC_RFKILL_NODE_3);\n\tif (eeepc->wlan_rfkill) {\n\t\trfkill_unregister(eeepc->wlan_rfkill);\n\t\trfkill_destroy(eeepc->wlan_rfkill);\n\t\teeepc->wlan_rfkill = NULL;\n\t}\n\n\tif (eeepc->hotplug_slot.ops)\n\t\tpci_hp_deregister(&eeepc->hotplug_slot);\n\n\tif (eeepc->bluetooth_rfkill) {\n\t\trfkill_unregister(eeepc->bluetooth_rfkill);\n\t\trfkill_destroy(eeepc->bluetooth_rfkill);\n\t\teeepc->bluetooth_rfkill = NULL;\n\t}\n\tif (eeepc->wwan3g_rfkill) {\n\t\trfkill_unregister(eeepc->wwan3g_rfkill);\n\t\trfkill_destroy(eeepc->wwan3g_rfkill);\n\t\teeepc->wwan3g_rfkill = NULL;\n\t}\n\tif (eeepc->wimax_rfkill) {\n\t\trfkill_unregister(eeepc->wimax_rfkill);\n\t\trfkill_destroy(eeepc->wimax_rfkill);\n\t\teeepc->wimax_rfkill = NULL;\n\t}\n}\n\nstatic int eeepc_rfkill_init(struct eeepc_laptop *eeepc)\n{\n\tint result = 0;\n\n\tmutex_init(&eeepc->hotplug_lock);\n\n\tresult = eeepc_new_rfkill(eeepc, &eeepc->wlan_rfkill,\n\t\t\t\t  \"eeepc-wlan\", RFKILL_TYPE_WLAN,\n\t\t\t\t  CM_ASL_WLAN);\n\n\tif (result && result != -ENODEV)\n\t\tgoto exit;\n\n\tresult = eeepc_new_rfkill(eeepc, &eeepc->bluetooth_rfkill,\n\t\t\t\t  \"eeepc-bluetooth\", RFKILL_TYPE_BLUETOOTH,\n\t\t\t\t  CM_ASL_BLUETOOTH);\n\n\tif (result && result != -ENODEV)\n\t\tgoto exit;\n\n\tresult = eeepc_new_rfkill(eeepc, &eeepc->wwan3g_rfkill,\n\t\t\t\t  \"eeepc-wwan3g\", RFKILL_TYPE_WWAN,\n\t\t\t\t  CM_ASL_3G);\n\n\tif (result && result != -ENODEV)\n\t\tgoto exit;\n\n\tresult = eeepc_new_rfkill(eeepc, &eeepc->wimax_rfkill,\n\t\t\t\t  \"eeepc-wimax\", RFKILL_TYPE_WIMAX,\n\t\t\t\t  CM_ASL_WIMAX);\n\n\tif (result && result != -ENODEV)\n\t\tgoto exit;\n\n\tif (eeepc->hotplug_disabled)\n\t\treturn 0;\n\n\tresult = eeepc_setup_pci_hotplug(eeepc);\n\t \n\tif (result == -EBUSY)\n\t\tresult = 0;\n\n\teeepc_register_rfkill_notifier(eeepc, EEEPC_RFKILL_NODE_1);\n\teeepc_register_rfkill_notifier(eeepc, EEEPC_RFKILL_NODE_2);\n\teeepc_register_rfkill_notifier(eeepc, EEEPC_RFKILL_NODE_3);\n\nexit:\n\tif (result && result != -ENODEV)\n\t\teeepc_rfkill_exit(eeepc);\n\treturn result;\n}\n\n \nstatic int eeepc_hotk_thaw(struct device *device)\n{\n\tstruct eeepc_laptop *eeepc = dev_get_drvdata(device);\n\n\tif (eeepc->wlan_rfkill) {\n\t\tint wlan;\n\n\t\t \n\t\twlan = get_acpi(eeepc, CM_ASL_WLAN);\n\t\tif (wlan >= 0)\n\t\t\tset_acpi(eeepc, CM_ASL_WLAN, wlan);\n\t}\n\n\treturn 0;\n}\n\nstatic int eeepc_hotk_restore(struct device *device)\n{\n\tstruct eeepc_laptop *eeepc = dev_get_drvdata(device);\n\n\t \n\tif (eeepc->wlan_rfkill) {\n\t\teeepc_rfkill_hotplug_update(eeepc, EEEPC_RFKILL_NODE_1);\n\t\teeepc_rfkill_hotplug_update(eeepc, EEEPC_RFKILL_NODE_2);\n\t\teeepc_rfkill_hotplug_update(eeepc, EEEPC_RFKILL_NODE_3);\n\t}\n\n\tif (eeepc->bluetooth_rfkill)\n\t\trfkill_set_sw_state(eeepc->bluetooth_rfkill,\n\t\t\t\t    get_acpi(eeepc, CM_ASL_BLUETOOTH) != 1);\n\tif (eeepc->wwan3g_rfkill)\n\t\trfkill_set_sw_state(eeepc->wwan3g_rfkill,\n\t\t\t\t    get_acpi(eeepc, CM_ASL_3G) != 1);\n\tif (eeepc->wimax_rfkill)\n\t\trfkill_set_sw_state(eeepc->wimax_rfkill,\n\t\t\t\t    get_acpi(eeepc, CM_ASL_WIMAX) != 1);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops eeepc_pm_ops = {\n\t.thaw = eeepc_hotk_thaw,\n\t.restore = eeepc_hotk_restore,\n};\n\nstatic struct platform_driver platform_driver = {\n\t.driver = {\n\t\t.name = EEEPC_LAPTOP_FILE,\n\t\t.pm = &eeepc_pm_ops,\n\t}\n};\n\n \n\n#define EEEPC_EC_SC00      0x61\n#define EEEPC_EC_FAN_PWM   (EEEPC_EC_SC00 + 2)  \n#define EEEPC_EC_FAN_HRPM  (EEEPC_EC_SC00 + 5)  \n#define EEEPC_EC_FAN_LRPM  (EEEPC_EC_SC00 + 6)  \n\n#define EEEPC_EC_SFB0      0xD0\n#define EEEPC_EC_FAN_CTRL  (EEEPC_EC_SFB0 + 3)  \n\nstatic inline int eeepc_pwm_to_lmsensors(int value)\n{\n\treturn value * 255 / 100;\n}\n\nstatic inline int eeepc_lmsensors_to_pwm(int value)\n{\n\tvalue = clamp_val(value, 0, 255);\n\treturn value * 100 / 255;\n}\n\nstatic int eeepc_get_fan_pwm(void)\n{\n\tu8 value = 0;\n\n\tec_read(EEEPC_EC_FAN_PWM, &value);\n\treturn eeepc_pwm_to_lmsensors(value);\n}\n\nstatic void eeepc_set_fan_pwm(int value)\n{\n\tvalue = eeepc_lmsensors_to_pwm(value);\n\tec_write(EEEPC_EC_FAN_PWM, value);\n}\n\nstatic int eeepc_get_fan_rpm(void)\n{\n\tu8 high = 0;\n\tu8 low = 0;\n\n\tec_read(EEEPC_EC_FAN_HRPM, &high);\n\tec_read(EEEPC_EC_FAN_LRPM, &low);\n\treturn high << 8 | low;\n}\n\n#define EEEPC_EC_FAN_CTRL_BIT\t0x02\n#define EEEPC_FAN_CTRL_MANUAL\t1\n#define EEEPC_FAN_CTRL_AUTO\t2\n\nstatic int eeepc_get_fan_ctrl(void)\n{\n\tu8 value = 0;\n\n\tec_read(EEEPC_EC_FAN_CTRL, &value);\n\tif (value & EEEPC_EC_FAN_CTRL_BIT)\n\t\treturn EEEPC_FAN_CTRL_MANUAL;\n\telse\n\t\treturn EEEPC_FAN_CTRL_AUTO;\n}\n\nstatic void eeepc_set_fan_ctrl(int manual)\n{\n\tu8 value = 0;\n\n\tec_read(EEEPC_EC_FAN_CTRL, &value);\n\tif (manual == EEEPC_FAN_CTRL_MANUAL)\n\t\tvalue |= EEEPC_EC_FAN_CTRL_BIT;\n\telse\n\t\tvalue &= ~EEEPC_EC_FAN_CTRL_BIT;\n\tec_write(EEEPC_EC_FAN_CTRL, value);\n}\n\nstatic ssize_t store_sys_hwmon(void (*set)(int), const char *buf, size_t count)\n{\n\tint rv, value;\n\n\trv = parse_arg(buf, &value);\n\tif (rv < 0)\n\t\treturn rv;\n\tset(value);\n\treturn count;\n}\n\nstatic ssize_t show_sys_hwmon(int (*get)(void), char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", get());\n}\n\n#define EEEPC_SENSOR_SHOW_FUNC(_name, _get)\t\t\t\t\\\n\tstatic ssize_t _name##_show(struct device *dev,\t\t\t\\\n\t\t\t\t    struct device_attribute *attr,\t\\\n\t\t\t\t    char *buf)\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\treturn show_sys_hwmon(_get, buf);\t\t\t\\\n\t}\n\n#define EEEPC_SENSOR_STORE_FUNC(_name, _set)\t\t\t\t\\\n\tstatic ssize_t _name##_store(struct device *dev,\t\t\\\n\t\t\t\t     struct device_attribute *attr,\t\\\n\t\t\t\t     const char *buf, size_t count)\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\treturn store_sys_hwmon(_set, buf, count);\t\t\\\n\t}\n\n#define EEEPC_CREATE_SENSOR_ATTR_RW(_name, _get, _set)\t\t\t\\\n\tEEEPC_SENSOR_SHOW_FUNC(_name, _get)\t\t\t\t\\\n\tEEEPC_SENSOR_STORE_FUNC(_name, _set)\t\t\t\t\\\n\tstatic DEVICE_ATTR_RW(_name)\n\n#define EEEPC_CREATE_SENSOR_ATTR_RO(_name, _get)\t\t\t\\\n\tEEEPC_SENSOR_SHOW_FUNC(_name, _get)\t\t\t\t\\\n\tstatic DEVICE_ATTR_RO(_name)\n\nEEEPC_CREATE_SENSOR_ATTR_RO(fan1_input, eeepc_get_fan_rpm);\nEEEPC_CREATE_SENSOR_ATTR_RW(pwm1, eeepc_get_fan_pwm,\n\t\t\t    eeepc_set_fan_pwm);\nEEEPC_CREATE_SENSOR_ATTR_RW(pwm1_enable, eeepc_get_fan_ctrl,\n\t\t\t    eeepc_set_fan_ctrl);\n\nstatic struct attribute *hwmon_attrs[] = {\n\t&dev_attr_pwm1.attr,\n\t&dev_attr_fan1_input.attr,\n\t&dev_attr_pwm1_enable.attr,\n\tNULL\n};\nATTRIBUTE_GROUPS(hwmon);\n\nstatic int eeepc_hwmon_init(struct eeepc_laptop *eeepc)\n{\n\tstruct device *dev = &eeepc->platform_device->dev;\n\tstruct device *hwmon;\n\n\thwmon = devm_hwmon_device_register_with_groups(dev, \"eeepc\", NULL,\n\t\t\t\t\t\t       hwmon_groups);\n\tif (IS_ERR(hwmon)) {\n\t\tpr_err(\"Could not register eeepc hwmon device\\n\");\n\t\treturn PTR_ERR(hwmon);\n\t}\n\treturn 0;\n}\n\n \nstatic int read_brightness(struct backlight_device *bd)\n{\n\tstruct eeepc_laptop *eeepc = bl_get_data(bd);\n\n\treturn get_acpi(eeepc, CM_ASL_PANELBRIGHT);\n}\n\nstatic int set_brightness(struct backlight_device *bd, int value)\n{\n\tstruct eeepc_laptop *eeepc = bl_get_data(bd);\n\n\treturn set_acpi(eeepc, CM_ASL_PANELBRIGHT, value);\n}\n\nstatic int update_bl_status(struct backlight_device *bd)\n{\n\treturn set_brightness(bd, bd->props.brightness);\n}\n\nstatic const struct backlight_ops eeepcbl_ops = {\n\t.get_brightness = read_brightness,\n\t.update_status = update_bl_status,\n};\n\nstatic int eeepc_backlight_notify(struct eeepc_laptop *eeepc)\n{\n\tstruct backlight_device *bd = eeepc->backlight_device;\n\tint old = bd->props.brightness;\n\n\tbacklight_force_update(bd, BACKLIGHT_UPDATE_HOTKEY);\n\n\treturn old;\n}\n\nstatic int eeepc_backlight_init(struct eeepc_laptop *eeepc)\n{\n\tstruct backlight_properties props;\n\tstruct backlight_device *bd;\n\n\tmemset(&props, 0, sizeof(struct backlight_properties));\n\tprops.type = BACKLIGHT_PLATFORM;\n\tprops.max_brightness = 15;\n\tbd = backlight_device_register(EEEPC_LAPTOP_FILE,\n\t\t\t\t       &eeepc->platform_device->dev, eeepc,\n\t\t\t\t       &eeepcbl_ops, &props);\n\tif (IS_ERR(bd)) {\n\t\tpr_err(\"Could not register eeepc backlight device\\n\");\n\t\teeepc->backlight_device = NULL;\n\t\treturn PTR_ERR(bd);\n\t}\n\teeepc->backlight_device = bd;\n\tbd->props.brightness = read_brightness(bd);\n\tbd->props.power = FB_BLANK_UNBLANK;\n\tbacklight_update_status(bd);\n\treturn 0;\n}\n\nstatic void eeepc_backlight_exit(struct eeepc_laptop *eeepc)\n{\n\tbacklight_device_unregister(eeepc->backlight_device);\n\teeepc->backlight_device = NULL;\n}\n\n\n \nstatic int eeepc_input_init(struct eeepc_laptop *eeepc)\n{\n\tstruct input_dev *input;\n\tint error;\n\n\tinput = input_allocate_device();\n\tif (!input)\n\t\treturn -ENOMEM;\n\n\tinput->name = \"Asus EeePC extra buttons\";\n\tinput->phys = EEEPC_LAPTOP_FILE \"/input0\";\n\tinput->id.bustype = BUS_HOST;\n\tinput->dev.parent = &eeepc->platform_device->dev;\n\n\terror = sparse_keymap_setup(input, eeepc_keymap, NULL);\n\tif (error) {\n\t\tpr_err(\"Unable to setup input device keymap\\n\");\n\t\tgoto err_free_dev;\n\t}\n\n\terror = input_register_device(input);\n\tif (error) {\n\t\tpr_err(\"Unable to register input device\\n\");\n\t\tgoto err_free_dev;\n\t}\n\n\teeepc->inputdev = input;\n\treturn 0;\n\nerr_free_dev:\n\tinput_free_device(input);\n\treturn error;\n}\n\nstatic void eeepc_input_exit(struct eeepc_laptop *eeepc)\n{\n\tif (eeepc->inputdev)\n\t\tinput_unregister_device(eeepc->inputdev);\n\teeepc->inputdev = NULL;\n}\n\n \nstatic void eeepc_input_notify(struct eeepc_laptop *eeepc, int event)\n{\n\tif (!eeepc->inputdev)\n\t\treturn;\n\tif (!sparse_keymap_report_event(eeepc->inputdev, event, 1, true))\n\t\tpr_info(\"Unknown key %x pressed\\n\", event);\n}\n\nstatic void eeepc_acpi_notify(struct acpi_device *device, u32 event)\n{\n\tstruct eeepc_laptop *eeepc = acpi_driver_data(device);\n\tint old_brightness, new_brightness;\n\tu16 count;\n\n\tif (event > ACPI_MAX_SYS_NOTIFY)\n\t\treturn;\n\tcount = eeepc->event_count[event % 128]++;\n\tacpi_bus_generate_netlink_event(device->pnp.device_class,\n\t\t\t\t\tdev_name(&device->dev), event,\n\t\t\t\t\tcount);\n\n\t \n\tif (event < NOTIFY_BRN_MIN || event > NOTIFY_BRN_MAX) {\n\t\teeepc_input_notify(eeepc, event);\n\t\treturn;\n\t}\n\n\t \n\tif (!eeepc->backlight_device)\n\t\treturn;\n\n\t \n\told_brightness = eeepc_backlight_notify(eeepc);\n\n\t \n\tnew_brightness = event - NOTIFY_BRN_MIN;\n\n\tif (new_brightness < old_brightness) {\n\t\tevent = NOTIFY_BRN_MIN;  \n\t} else if (new_brightness > old_brightness) {\n\t\tevent = NOTIFY_BRN_MAX;  \n\t} else {\n\t\t \n\t}\n\teeepc_input_notify(eeepc, event);\n}\n\nstatic void eeepc_dmi_check(struct eeepc_laptop *eeepc)\n{\n\tconst char *model;\n\n\tmodel = dmi_get_system_info(DMI_PRODUCT_NAME);\n\tif (!model)\n\t\treturn;\n\n\t \n\tif (strcmp(model, \"701\") == 0 || strcmp(model, \"702\") == 0) {\n\t\teeepc->cpufv_disabled = true;\n\t\tpr_info(\"model %s does not officially support setting cpu speed\\n\",\n\t\t\tmodel);\n\t\tpr_info(\"cpufv disabled to avoid instability\\n\");\n\t}\n\n\t \n\tif (strcmp(model, \"1005HA\") == 0 || strcmp(model, \"1201N\") == 0 ||\n\t    strcmp(model, \"1005PE\") == 0) {\n\t\teeepc->hotplug_disabled = true;\n\t\tpr_info(\"wlan hotplug disabled\\n\");\n\t}\n}\n\nstatic void cmsg_quirk(struct eeepc_laptop *eeepc, int cm, const char *name)\n{\n\tint dummy;\n\n\t \n\tif (!(eeepc->cm_supported & (1 << cm))\n\t    && !read_acpi_int(eeepc->handle, cm_getv[cm], &dummy)) {\n\t\tpr_info(\"%s (%x) not reported by BIOS, enabling anyway\\n\",\n\t\t\tname, 1 << cm);\n\t\teeepc->cm_supported |= 1 << cm;\n\t}\n}\n\nstatic void cmsg_quirks(struct eeepc_laptop *eeepc)\n{\n\tcmsg_quirk(eeepc, CM_ASL_LID, \"LID\");\n\tcmsg_quirk(eeepc, CM_ASL_TYPE, \"TYPE\");\n\tcmsg_quirk(eeepc, CM_ASL_PANELPOWER, \"PANELPOWER\");\n\tcmsg_quirk(eeepc, CM_ASL_TPD, \"TPD\");\n}\n\nstatic int eeepc_acpi_init(struct eeepc_laptop *eeepc)\n{\n\tunsigned int init_flags;\n\tint result;\n\n\tresult = acpi_bus_get_status(eeepc->device);\n\tif (result)\n\t\treturn result;\n\tif (!eeepc->device->status.present) {\n\t\tpr_err(\"Hotkey device not present, aborting\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tinit_flags = DISABLE_ASL_WLAN | DISABLE_ASL_DISPLAYSWITCH;\n\tpr_notice(\"Hotkey init flags 0x%x\\n\", init_flags);\n\n\tif (write_acpi_int(eeepc->handle, \"INIT\", init_flags)) {\n\t\tpr_err(\"Hotkey initialization failed\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tif (read_acpi_int(eeepc->handle, \"CMSG\", &eeepc->cm_supported)) {\n\t\tpr_err(\"Get control methods supported failed\\n\");\n\t\treturn -ENODEV;\n\t}\n\tcmsg_quirks(eeepc);\n\tpr_info(\"Get control methods supported: 0x%x\\n\", eeepc->cm_supported);\n\n\treturn 0;\n}\n\nstatic void eeepc_enable_camera(struct eeepc_laptop *eeepc)\n{\n\t \n\tif (get_acpi(eeepc, CM_ASL_CAMERA) == 0)\n\t\tset_acpi(eeepc, CM_ASL_CAMERA, 1);\n}\n\nstatic bool eeepc_device_present;\n\nstatic int eeepc_acpi_add(struct acpi_device *device)\n{\n\tstruct eeepc_laptop *eeepc;\n\tint result;\n\n\tpr_notice(EEEPC_LAPTOP_NAME \"\\n\");\n\teeepc = kzalloc(sizeof(struct eeepc_laptop), GFP_KERNEL);\n\tif (!eeepc)\n\t\treturn -ENOMEM;\n\teeepc->handle = device->handle;\n\tstrcpy(acpi_device_name(device), EEEPC_ACPI_DEVICE_NAME);\n\tstrcpy(acpi_device_class(device), EEEPC_ACPI_CLASS);\n\tdevice->driver_data = eeepc;\n\teeepc->device = device;\n\n\teeepc->hotplug_disabled = hotplug_disabled;\n\n\teeepc_dmi_check(eeepc);\n\n\tresult = eeepc_acpi_init(eeepc);\n\tif (result)\n\t\tgoto fail_platform;\n\teeepc_enable_camera(eeepc);\n\n\t \n\tresult = eeepc_platform_init(eeepc);\n\tif (result)\n\t\tgoto fail_platform;\n\n\tif (acpi_video_get_backlight_type() == acpi_backlight_vendor) {\n\t\tresult = eeepc_backlight_init(eeepc);\n\t\tif (result)\n\t\t\tgoto fail_backlight;\n\t}\n\n\tresult = eeepc_input_init(eeepc);\n\tif (result)\n\t\tgoto fail_input;\n\n\tresult = eeepc_hwmon_init(eeepc);\n\tif (result)\n\t\tgoto fail_hwmon;\n\n\tresult = eeepc_led_init(eeepc);\n\tif (result)\n\t\tgoto fail_led;\n\n\tresult = eeepc_rfkill_init(eeepc);\n\tif (result)\n\t\tgoto fail_rfkill;\n\n\teeepc_device_present = true;\n\treturn 0;\n\nfail_rfkill:\n\teeepc_led_exit(eeepc);\nfail_led:\nfail_hwmon:\n\teeepc_input_exit(eeepc);\nfail_input:\n\teeepc_backlight_exit(eeepc);\nfail_backlight:\n\teeepc_platform_exit(eeepc);\nfail_platform:\n\tkfree(eeepc);\n\n\treturn result;\n}\n\nstatic void eeepc_acpi_remove(struct acpi_device *device)\n{\n\tstruct eeepc_laptop *eeepc = acpi_driver_data(device);\n\n\teeepc_backlight_exit(eeepc);\n\teeepc_rfkill_exit(eeepc);\n\teeepc_input_exit(eeepc);\n\teeepc_led_exit(eeepc);\n\teeepc_platform_exit(eeepc);\n\n\tkfree(eeepc);\n}\n\n\nstatic const struct acpi_device_id eeepc_device_ids[] = {\n\t{EEEPC_ACPI_HID, 0},\n\t{\"\", 0},\n};\nMODULE_DEVICE_TABLE(acpi, eeepc_device_ids);\n\nstatic struct acpi_driver eeepc_acpi_driver = {\n\t.name = EEEPC_LAPTOP_NAME,\n\t.class = EEEPC_ACPI_CLASS,\n\t.owner = THIS_MODULE,\n\t.ids = eeepc_device_ids,\n\t.flags = ACPI_DRIVER_ALL_NOTIFY_EVENTS,\n\t.ops = {\n\t\t.add = eeepc_acpi_add,\n\t\t.remove = eeepc_acpi_remove,\n\t\t.notify = eeepc_acpi_notify,\n\t},\n};\n\n\nstatic int __init eeepc_laptop_init(void)\n{\n\tint result;\n\n\tresult = platform_driver_register(&platform_driver);\n\tif (result < 0)\n\t\treturn result;\n\n\tresult = acpi_bus_register_driver(&eeepc_acpi_driver);\n\tif (result < 0)\n\t\tgoto fail_acpi_driver;\n\n\tif (!eeepc_device_present) {\n\t\tresult = -ENODEV;\n\t\tgoto fail_no_device;\n\t}\n\n\treturn 0;\n\nfail_no_device:\n\tacpi_bus_unregister_driver(&eeepc_acpi_driver);\nfail_acpi_driver:\n\tplatform_driver_unregister(&platform_driver);\n\treturn result;\n}\n\nstatic void __exit eeepc_laptop_exit(void)\n{\n\tacpi_bus_unregister_driver(&eeepc_acpi_driver);\n\tplatform_driver_unregister(&platform_driver);\n}\n\nmodule_init(eeepc_laptop_init);\nmodule_exit(eeepc_laptop_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}