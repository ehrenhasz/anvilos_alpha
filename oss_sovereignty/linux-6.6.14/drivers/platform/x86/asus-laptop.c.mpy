{
  "module_name": "asus-laptop.c",
  "hash_id": "11d11ea64b6a301338e9c88fec481b1c7124616b9d9530dca9fae0d329700d9d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/x86/asus-laptop.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/types.h>\n#include <linux/err.h>\n#include <linux/proc_fs.h>\n#include <linux/backlight.h>\n#include <linux/fb.h>\n#include <linux/leds.h>\n#include <linux/platform_device.h>\n#include <linux/uaccess.h>\n#include <linux/input.h>\n#include <linux/input/sparse-keymap.h>\n#include <linux/rfkill.h>\n#include <linux/slab.h>\n#include <linux/dmi.h>\n#include <linux/acpi.h>\n#include <acpi/video.h>\n\n#define ASUS_LAPTOP_VERSION\t\"0.42\"\n\n#define ASUS_LAPTOP_NAME\t\"Asus Laptop Support\"\n#define ASUS_LAPTOP_CLASS\t\"hotkey\"\n#define ASUS_LAPTOP_DEVICE_NAME\t\"Hotkey\"\n#define ASUS_LAPTOP_FILE\tKBUILD_MODNAME\n#define ASUS_LAPTOP_PREFIX\t\"\\\\_SB.ATKD.\"\n\nMODULE_AUTHOR(\"Julien Lerouge, Karol Kozimor, Corentin Chary\");\nMODULE_DESCRIPTION(ASUS_LAPTOP_NAME);\nMODULE_LICENSE(\"GPL\");\n\n \nstatic uint wapf = 1;\nmodule_param(wapf, uint, 0444);\nMODULE_PARM_DESC(wapf, \"WAPF value\");\n\nstatic char *wled_type = \"unknown\";\nstatic char *bled_type = \"unknown\";\n\nmodule_param(wled_type, charp, 0444);\nMODULE_PARM_DESC(wled_type, \"Set the wled type on boot \"\n\t\t \"(unknown, led or rfkill). \"\n\t\t \"default is unknown\");\n\nmodule_param(bled_type, charp, 0444);\nMODULE_PARM_DESC(bled_type, \"Set the bled type on boot \"\n\t\t \"(unknown, led or rfkill). \"\n\t\t \"default is unknown\");\n\nstatic int wlan_status = 1;\nstatic int bluetooth_status = 1;\nstatic int wimax_status = -1;\nstatic int wwan_status = -1;\nstatic int als_status;\n\nmodule_param(wlan_status, int, 0444);\nMODULE_PARM_DESC(wlan_status, \"Set the wireless status on boot \"\n\t\t \"(0 = disabled, 1 = enabled, -1 = don't do anything). \"\n\t\t \"default is -1\");\n\nmodule_param(bluetooth_status, int, 0444);\nMODULE_PARM_DESC(bluetooth_status, \"Set the wireless status on boot \"\n\t\t \"(0 = disabled, 1 = enabled, -1 = don't do anything). \"\n\t\t \"default is -1\");\n\nmodule_param(wimax_status, int, 0444);\nMODULE_PARM_DESC(wimax_status, \"Set the wireless status on boot \"\n\t\t \"(0 = disabled, 1 = enabled, -1 = don't do anything). \"\n\t\t \"default is -1\");\n\nmodule_param(wwan_status, int, 0444);\nMODULE_PARM_DESC(wwan_status, \"Set the wireless status on boot \"\n\t\t \"(0 = disabled, 1 = enabled, -1 = don't do anything). \"\n\t\t \"default is -1\");\n\nmodule_param(als_status, int, 0444);\nMODULE_PARM_DESC(als_status, \"Set the ALS status on boot \"\n\t\t \"(0 = disabled, 1 = enabled). \"\n\t\t \"default is 0\");\n\n \n#define ATKD_BRNUP_MIN\t\t0x10\n#define ATKD_BRNUP_MAX\t\t0x1f\n#define ATKD_BRNDOWN_MIN\t0x20\n#define ATKD_BRNDOWN_MAX\t0x2f\n#define ATKD_BRNDOWN\t\t0x20\n#define ATKD_BRNUP\t\t0x2f\n#define ATKD_LCD_ON\t0x33\n#define ATKD_LCD_OFF\t0x34\n\n \n#define WL_HWRS\t\t0x80\n#define BT_HWRS\t\t0x100\n\n \n#define WL_RSTS\t\t0x01\t \n#define BT_RSTS\t\t0x02\t \n#define WM_RSTS\t\t0x08     \n#define WW_RSTS\t\t0x20     \n\n \n#define TYPE_UNKNOWN\t0\n#define TYPE_LED\t1\n#define TYPE_RFKILL\t2\n\n \n#define METHOD_MLED\t\t\"MLED\"\n#define METHOD_TLED\t\t\"TLED\"\n#define METHOD_RLED\t\t\"RLED\"\t \n#define METHOD_PLED\t\t\"PLED\"\t \n#define METHOD_GLED\t\t\"GLED\"\t \n\n \n#define METHOD_LEDD\t\t\"SLCM\"\n\n \n#define METHOD_WLAN\t\t\"WLED\"\n#define METHOD_BLUETOOTH\t\"BLED\"\n\n \n#define METHOD_WWAN\t\t\"GSMC\"\n#define METHOD_WIMAX\t\t\"WMXC\"\n\n#define METHOD_WL_STATUS\t\"RSTS\"\n\n \n#define METHOD_BRIGHTNESS_SET\t\"SPLV\"\n#define METHOD_BRIGHTNESS_GET\t\"GPLV\"\n\n \n#define METHOD_SWITCH_DISPLAY\t\"SDSP\"\n\n#define METHOD_ALS_CONTROL\t\"ALSC\"  \n#define METHOD_ALS_LEVEL\t\"ALSL\"  \n\n \n \n#define METHOD_GPS_ON\t\t\"SDON\"\n#define METHOD_GPS_OFF\t\t\"SDOF\"\n#define METHOD_GPS_STATUS\t\"GPST\"\n\n \n#define METHOD_KBD_LIGHT_SET\t\"SLKB\"\n#define METHOD_KBD_LIGHT_GET\t\"GLKB\"\n\n \n#define DEVICE_NAME_PEGA\t\"Lucid\"\n\n#define METHOD_PEGA_ENABLE\t\"ENPR\"\n#define METHOD_PEGA_DISABLE\t\"DAPR\"\n#define PEGA_WLAN\t0x00\n#define PEGA_BLUETOOTH\t0x01\n#define PEGA_WWAN\t0x02\n#define PEGA_ALS\t0x04\n#define PEGA_ALS_POWER\t0x05\n\n#define METHOD_PEGA_READ\t\"RDLN\"\n#define PEGA_READ_ALS_H\t0x02\n#define PEGA_READ_ALS_L\t0x03\n\n#define PEGA_ACCEL_NAME \"pega_accel\"\n#define PEGA_ACCEL_DESC \"Pegatron Lucid Tablet Accelerometer\"\n#define METHOD_XLRX \"XLRX\"\n#define METHOD_XLRY \"XLRY\"\n#define METHOD_XLRZ \"XLRZ\"\n#define PEGA_ACC_CLAMP 512  \n#define PEGA_ACC_RETRIES 3\n\n \nstruct asus_led {\n\tint wk;\n\tstruct work_struct work;\n\tstruct led_classdev led;\n\tstruct asus_laptop *asus;\n\tconst char *method;\n};\n\n \nstruct asus_rfkill {\n\t \n\tint control_id;\n\tstruct rfkill *rfkill;\n\tstruct asus_laptop *asus;\n};\n\n \nstruct asus_laptop {\n\tchar *name;\t\t \n\n\tstruct acpi_table_header *dsdt_info;\n\tstruct platform_device *platform_device;\n\tstruct acpi_device *device;\t\t \n\tstruct backlight_device *backlight_device;\n\n\tstruct input_dev *inputdev;\n\tstruct key_entry *keymap;\n\tstruct input_dev *pega_accel_poll;\n\n\tstruct asus_led wled;\n\tstruct asus_led bled;\n\tstruct asus_led mled;\n\tstruct asus_led tled;\n\tstruct asus_led rled;\n\tstruct asus_led pled;\n\tstruct asus_led gled;\n\tstruct asus_led kled;\n\tstruct workqueue_struct *led_workqueue;\n\n\tint wled_type;\n\tint bled_type;\n\tint wireless_status;\n\tbool have_rsts;\n\tbool is_pega_lucid;\n\tbool pega_acc_live;\n\tint pega_acc_x;\n\tint pega_acc_y;\n\tint pega_acc_z;\n\n\tstruct asus_rfkill wlan;\n\tstruct asus_rfkill bluetooth;\n\tstruct asus_rfkill wwan;\n\tstruct asus_rfkill wimax;\n\tstruct asus_rfkill gps;\n\n\tacpi_handle handle;\t \n\tu32 ledd_status;\t \n\tu8 light_level;\t\t \n\tu8 light_switch;\t \n\tu16 event_count[128];\t \n};\n\nstatic const struct key_entry asus_keymap[] = {\n\t \n\t{KE_KEY, 0x02, { KEY_SCREENLOCK } },\n\t{KE_KEY, 0x05, { KEY_WLAN } },\n\t{KE_KEY, 0x08, { KEY_F13 } },\n\t{KE_KEY, 0x09, { KEY_PROG2 } },  \n\t{KE_KEY, 0x17, { KEY_ZOOM } },\n\t{KE_KEY, 0x1f, { KEY_BATTERY } },\n\t \n\t{KE_KEY, ATKD_BRNDOWN, { KEY_BRIGHTNESSDOWN } },\n\t{KE_KEY, ATKD_BRNUP, { KEY_BRIGHTNESSUP } },\n\t{KE_KEY, 0x30, { KEY_VOLUMEUP } },\n\t{KE_KEY, 0x31, { KEY_VOLUMEDOWN } },\n\t{KE_KEY, 0x32, { KEY_MUTE } },\n\t{KE_KEY, 0x33, { KEY_DISPLAYTOGGLE } },  \n\t{KE_KEY, 0x34, { KEY_DISPLAY_OFF } },  \n\t{KE_KEY, 0x40, { KEY_PREVIOUSSONG } },\n\t{KE_KEY, 0x41, { KEY_NEXTSONG } },\n\t{KE_KEY, 0x43, { KEY_STOPCD } },  \n\t{KE_KEY, 0x45, { KEY_PLAYPAUSE } },\n\t{KE_KEY, 0x4c, { KEY_MEDIA } },  \n\t{KE_KEY, 0x50, { KEY_EMAIL } },\n\t{KE_KEY, 0x51, { KEY_WWW } },\n\t{KE_KEY, 0x55, { KEY_CALC } },\n\t{KE_IGNORE, 0x57, },   \n\t{KE_IGNORE, 0x58, },   \n\t{KE_KEY, 0x5C, { KEY_SCREENLOCK } },   \n\t{KE_KEY, 0x5D, { KEY_WLAN } },  \n\t{KE_KEY, 0x5E, { KEY_WLAN } },  \n\t{KE_KEY, 0x5F, { KEY_WLAN } },  \n\t{KE_KEY, 0x60, { KEY_TOUCHPAD_ON } },\n\t{KE_KEY, 0x61, { KEY_SWITCHVIDEOMODE } },  \n\t{KE_KEY, 0x62, { KEY_SWITCHVIDEOMODE } },  \n\t{KE_KEY, 0x63, { KEY_SWITCHVIDEOMODE } },  \n\t{KE_KEY, 0x64, { KEY_SWITCHVIDEOMODE } },  \n\t{KE_KEY, 0x65, { KEY_SWITCHVIDEOMODE } },  \n\t{KE_KEY, 0x66, { KEY_SWITCHVIDEOMODE } },  \n\t{KE_KEY, 0x67, { KEY_SWITCHVIDEOMODE } },  \n\t{KE_KEY, 0x6A, { KEY_TOUCHPAD_TOGGLE } },  \n\t{KE_KEY, 0x6B, { KEY_TOUCHPAD_TOGGLE } },  \n\t{KE_KEY, 0x6C, { KEY_SLEEP } },  \n\t{KE_KEY, 0x6D, { KEY_SLEEP } },  \n\t{KE_IGNORE, 0x6E, },   \n\t{KE_KEY, 0x7D, { KEY_BLUETOOTH } },  \n\t{KE_KEY, 0x7E, { KEY_BLUETOOTH } },  \n\t{KE_KEY, 0x82, { KEY_CAMERA } },\n\t{KE_KEY, 0x88, { KEY_RFKILL  } },  \n\t{KE_KEY, 0x8A, { KEY_PROG1 } },  \n\t{KE_KEY, 0x8C, { KEY_SWITCHVIDEOMODE } },  \n\t{KE_KEY, 0x8D, { KEY_SWITCHVIDEOMODE } },  \n\t{KE_KEY, 0x8E, { KEY_SWITCHVIDEOMODE } },  \n\t{KE_KEY, 0x8F, { KEY_SWITCHVIDEOMODE } },  \n\t{KE_KEY, 0x90, { KEY_SWITCHVIDEOMODE } },  \n\t{KE_KEY, 0x91, { KEY_SWITCHVIDEOMODE } },  \n\t{KE_KEY, 0x92, { KEY_SWITCHVIDEOMODE } },  \n\t{KE_KEY, 0x93, { KEY_SWITCHVIDEOMODE } },  \n\t{KE_KEY, 0x95, { KEY_MEDIA } },\n\t{KE_KEY, 0x99, { KEY_PHONE } },\n\t{KE_KEY, 0xA0, { KEY_SWITCHVIDEOMODE } },  \n\t{KE_KEY, 0xA1, { KEY_SWITCHVIDEOMODE } },  \n\t{KE_KEY, 0xA2, { KEY_SWITCHVIDEOMODE } },  \n\t{KE_KEY, 0xA3, { KEY_SWITCHVIDEOMODE } },  \n\t{KE_KEY, 0xA4, { KEY_SWITCHVIDEOMODE } },  \n\t{KE_KEY, 0xA5, { KEY_SWITCHVIDEOMODE } },  \n\t{KE_KEY, 0xA6, { KEY_SWITCHVIDEOMODE } },  \n\t{KE_KEY, 0xA7, { KEY_SWITCHVIDEOMODE } },  \n\t{KE_KEY, 0xB5, { KEY_CALC } },\n\t{KE_KEY, 0xC4, { KEY_KBDILLUMUP } },\n\t{KE_KEY, 0xC5, { KEY_KBDILLUMDOWN } },\n\t{KE_END, 0},\n};\n\n\n \nstatic int write_acpi_int_ret(acpi_handle handle, const char *method, int val,\n\t\t\t      struct acpi_buffer *output)\n{\n\tstruct acpi_object_list params;\t \n\tunion acpi_object in_obj;\t \n\tacpi_status status;\n\n\tif (!handle)\n\t\treturn -1;\n\n\tparams.count = 1;\n\tparams.pointer = &in_obj;\n\tin_obj.type = ACPI_TYPE_INTEGER;\n\tin_obj.integer.value = val;\n\n\tstatus = acpi_evaluate_object(handle, (char *)method, &params, output);\n\tif (status == AE_OK)\n\t\treturn 0;\n\telse\n\t\treturn -1;\n}\n\nstatic int write_acpi_int(acpi_handle handle, const char *method, int val)\n{\n\treturn write_acpi_int_ret(handle, method, val, NULL);\n}\n\nstatic int acpi_check_handle(acpi_handle handle, const char *method,\n\t\t\t     acpi_handle *ret)\n{\n\tacpi_status status;\n\n\tif (method == NULL)\n\t\treturn -ENODEV;\n\n\tif (ret)\n\t\tstatus = acpi_get_handle(handle, (char *)method,\n\t\t\t\t\t ret);\n\telse {\n\t\tacpi_handle dummy;\n\n\t\tstatus = acpi_get_handle(handle, (char *)method,\n\t\t\t\t\t &dummy);\n\t}\n\n\tif (status != AE_OK) {\n\t\tif (ret)\n\t\t\tpr_warn(\"Error finding %s\\n\", method);\n\t\treturn -ENODEV;\n\t}\n\treturn 0;\n}\n\nstatic bool asus_check_pega_lucid(struct asus_laptop *asus)\n{\n\treturn !strcmp(asus->name, DEVICE_NAME_PEGA) &&\n\t   !acpi_check_handle(asus->handle, METHOD_PEGA_ENABLE, NULL) &&\n\t   !acpi_check_handle(asus->handle, METHOD_PEGA_DISABLE, NULL) &&\n\t   !acpi_check_handle(asus->handle, METHOD_PEGA_READ, NULL);\n}\n\nstatic int asus_pega_lucid_set(struct asus_laptop *asus, int unit, bool enable)\n{\n\tchar *method = enable ? METHOD_PEGA_ENABLE : METHOD_PEGA_DISABLE;\n\treturn write_acpi_int(asus->handle, method, unit);\n}\n\nstatic int pega_acc_axis(struct asus_laptop *asus, int curr, char *method)\n{\n\tint i, delta;\n\tunsigned long long val;\n\tfor (i = 0; i < PEGA_ACC_RETRIES; i++) {\n\t\tacpi_evaluate_integer(asus->handle, method, NULL, &val);\n\n\t\t \n\t\tdelta = abs(curr - (short)val);\n\t\tif (delta < 128 && !(val & ~0xffff))\n\t\t\tbreak;\n\t}\n\treturn clamp_val((short)val, -PEGA_ACC_CLAMP, PEGA_ACC_CLAMP);\n}\n\nstatic void pega_accel_poll(struct input_dev *input)\n{\n\tstruct device *parent = input->dev.parent;\n\tstruct asus_laptop *asus = dev_get_drvdata(parent);\n\n\t \n\tif (!asus->pega_acc_live) {\n\t\tasus->pega_acc_live = true;\n\t\tinput_report_abs(input, ABS_X, 0);\n\t\tinput_report_abs(input, ABS_Y, 0);\n\t\tinput_report_abs(input, ABS_Z, 0);\n\t\tinput_sync(input);\n\t\treturn;\n\t}\n\n\tasus->pega_acc_x = pega_acc_axis(asus, asus->pega_acc_x, METHOD_XLRX);\n\tasus->pega_acc_y = pega_acc_axis(asus, asus->pega_acc_y, METHOD_XLRY);\n\tasus->pega_acc_z = pega_acc_axis(asus, asus->pega_acc_z, METHOD_XLRZ);\n\n\t \n\tinput_report_abs(input, ABS_X, -asus->pega_acc_x);\n\tinput_report_abs(input, ABS_Y, -asus->pega_acc_y);\n\tinput_report_abs(input, ABS_Z,  asus->pega_acc_z);\n\tinput_sync(input);\n}\n\nstatic void pega_accel_exit(struct asus_laptop *asus)\n{\n\tif (asus->pega_accel_poll) {\n\t\tinput_unregister_device(asus->pega_accel_poll);\n\t\tasus->pega_accel_poll = NULL;\n\t}\n}\n\nstatic int pega_accel_init(struct asus_laptop *asus)\n{\n\tint err;\n\tstruct input_dev *input;\n\n\tif (!asus->is_pega_lucid)\n\t\treturn -ENODEV;\n\n\tif (acpi_check_handle(asus->handle, METHOD_XLRX, NULL) ||\n\t    acpi_check_handle(asus->handle, METHOD_XLRY, NULL) ||\n\t    acpi_check_handle(asus->handle, METHOD_XLRZ, NULL))\n\t\treturn -ENODEV;\n\n\tinput = input_allocate_device();\n\tif (!input)\n\t\treturn -ENOMEM;\n\n\tinput->name = PEGA_ACCEL_DESC;\n\tinput->phys = PEGA_ACCEL_NAME \"/input0\";\n\tinput->dev.parent = &asus->platform_device->dev;\n\tinput->id.bustype = BUS_HOST;\n\n\tinput_set_abs_params(input, ABS_X,\n\t\t\t     -PEGA_ACC_CLAMP, PEGA_ACC_CLAMP, 0, 0);\n\tinput_set_abs_params(input, ABS_Y,\n\t\t\t     -PEGA_ACC_CLAMP, PEGA_ACC_CLAMP, 0, 0);\n\tinput_set_abs_params(input, ABS_Z,\n\t\t\t     -PEGA_ACC_CLAMP, PEGA_ACC_CLAMP, 0, 0);\n\n\terr = input_setup_polling(input, pega_accel_poll);\n\tif (err)\n\t\tgoto exit;\n\n\tinput_set_poll_interval(input, 125);\n\tinput_set_min_poll_interval(input, 50);\n\tinput_set_max_poll_interval(input, 2000);\n\n\terr = input_register_device(input);\n\tif (err)\n\t\tgoto exit;\n\n\tasus->pega_accel_poll = input;\n\treturn 0;\n\nexit:\n\tinput_free_device(input);\n\treturn err;\n}\n\n \nstatic int asus_led_set(struct asus_laptop *asus, const char *method,\n\t\t\t int value)\n{\n\tif (!strcmp(method, METHOD_MLED))\n\t\tvalue = !value;\n\telse if (!strcmp(method, METHOD_GLED))\n\t\tvalue = !value + 1;\n\telse\n\t\tvalue = !!value;\n\n\treturn write_acpi_int(asus->handle, method, value);\n}\n\n \n \nstatic void asus_led_cdev_set(struct led_classdev *led_cdev,\n\t\t\t enum led_brightness value)\n{\n\tstruct asus_led *led = container_of(led_cdev, struct asus_led, led);\n\tstruct asus_laptop *asus = led->asus;\n\n\tled->wk = !!value;\n\tqueue_work(asus->led_workqueue, &led->work);\n}\n\nstatic void asus_led_cdev_update(struct work_struct *work)\n{\n\tstruct asus_led *led = container_of(work, struct asus_led, work);\n\tstruct asus_laptop *asus = led->asus;\n\n\tasus_led_set(asus, led->method, led->wk);\n}\n\nstatic enum led_brightness asus_led_cdev_get(struct led_classdev *led_cdev)\n{\n\treturn led_cdev->brightness;\n}\n\n \nstatic int asus_kled_lvl(struct asus_laptop *asus)\n{\n\tunsigned long long kblv;\n\tstruct acpi_object_list params;\n\tunion acpi_object in_obj;\n\tacpi_status rv;\n\n\tparams.count = 1;\n\tparams.pointer = &in_obj;\n\tin_obj.type = ACPI_TYPE_INTEGER;\n\tin_obj.integer.value = 2;\n\n\trv = acpi_evaluate_integer(asus->handle, METHOD_KBD_LIGHT_GET,\n\t\t\t\t   &params, &kblv);\n\tif (ACPI_FAILURE(rv)) {\n\t\tpr_warn(\"Error reading kled level\\n\");\n\t\treturn -ENODEV;\n\t}\n\treturn kblv;\n}\n\nstatic int asus_kled_set(struct asus_laptop *asus, int kblv)\n{\n\tif (kblv > 0)\n\t\tkblv = (1 << 7) | (kblv & 0x7F);\n\telse\n\t\tkblv = 0;\n\n\tif (write_acpi_int(asus->handle, METHOD_KBD_LIGHT_SET, kblv)) {\n\t\tpr_warn(\"Keyboard LED display write failed\\n\");\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic void asus_kled_cdev_set(struct led_classdev *led_cdev,\n\t\t\t      enum led_brightness value)\n{\n\tstruct asus_led *led = container_of(led_cdev, struct asus_led, led);\n\tstruct asus_laptop *asus = led->asus;\n\n\tled->wk = value;\n\tqueue_work(asus->led_workqueue, &led->work);\n}\n\nstatic void asus_kled_cdev_update(struct work_struct *work)\n{\n\tstruct asus_led *led = container_of(work, struct asus_led, work);\n\tstruct asus_laptop *asus = led->asus;\n\n\tasus_kled_set(asus, led->wk);\n}\n\nstatic enum led_brightness asus_kled_cdev_get(struct led_classdev *led_cdev)\n{\n\tstruct asus_led *led = container_of(led_cdev, struct asus_led, led);\n\tstruct asus_laptop *asus = led->asus;\n\n\treturn asus_kled_lvl(asus);\n}\n\nstatic void asus_led_exit(struct asus_laptop *asus)\n{\n\tled_classdev_unregister(&asus->wled.led);\n\tled_classdev_unregister(&asus->bled.led);\n\tled_classdev_unregister(&asus->mled.led);\n\tled_classdev_unregister(&asus->tled.led);\n\tled_classdev_unregister(&asus->pled.led);\n\tled_classdev_unregister(&asus->rled.led);\n\tled_classdev_unregister(&asus->gled.led);\n\tled_classdev_unregister(&asus->kled.led);\n\n\tif (asus->led_workqueue) {\n\t\tdestroy_workqueue(asus->led_workqueue);\n\t\tasus->led_workqueue = NULL;\n\t}\n}\n\n \nstatic int asus_led_register(struct asus_laptop *asus,\n\t\t\t     struct asus_led *led,\n\t\t\t     const char *name, const char *method)\n{\n\tstruct led_classdev *led_cdev = &led->led;\n\n\tif (!method || acpi_check_handle(asus->handle, method, NULL))\n\t\treturn 0;  \n\n\tled->asus = asus;\n\tled->method = method;\n\n\tINIT_WORK(&led->work, asus_led_cdev_update);\n\tled_cdev->name = name;\n\tled_cdev->brightness_set = asus_led_cdev_set;\n\tled_cdev->brightness_get = asus_led_cdev_get;\n\tled_cdev->max_brightness = 1;\n\treturn led_classdev_register(&asus->platform_device->dev, led_cdev);\n}\n\nstatic int asus_led_init(struct asus_laptop *asus)\n{\n\tint r = 0;\n\n\t \n\tif (asus->is_pega_lucid)\n\t\treturn 0;\n\n\t \n\tasus->led_workqueue = create_singlethread_workqueue(\"led_workqueue\");\n\tif (!asus->led_workqueue)\n\t\treturn -ENOMEM;\n\n\tif (asus->wled_type == TYPE_LED)\n\t\tr = asus_led_register(asus, &asus->wled, \"asus::wlan\",\n\t\t\t\t      METHOD_WLAN);\n\tif (r)\n\t\tgoto error;\n\tif (asus->bled_type == TYPE_LED)\n\t\tr = asus_led_register(asus, &asus->bled, \"asus::bluetooth\",\n\t\t\t\t      METHOD_BLUETOOTH);\n\tif (r)\n\t\tgoto error;\n\tr = asus_led_register(asus, &asus->mled, \"asus::mail\", METHOD_MLED);\n\tif (r)\n\t\tgoto error;\n\tr = asus_led_register(asus, &asus->tled, \"asus::touchpad\", METHOD_TLED);\n\tif (r)\n\t\tgoto error;\n\tr = asus_led_register(asus, &asus->rled, \"asus::record\", METHOD_RLED);\n\tif (r)\n\t\tgoto error;\n\tr = asus_led_register(asus, &asus->pled, \"asus::phone\", METHOD_PLED);\n\tif (r)\n\t\tgoto error;\n\tr = asus_led_register(asus, &asus->gled, \"asus::gaming\", METHOD_GLED);\n\tif (r)\n\t\tgoto error;\n\tif (!acpi_check_handle(asus->handle, METHOD_KBD_LIGHT_SET, NULL) &&\n\t    !acpi_check_handle(asus->handle, METHOD_KBD_LIGHT_GET, NULL)) {\n\t\tstruct asus_led *led = &asus->kled;\n\t\tstruct led_classdev *cdev = &led->led;\n\n\t\tled->asus = asus;\n\n\t\tINIT_WORK(&led->work, asus_kled_cdev_update);\n\t\tcdev->name = \"asus::kbd_backlight\";\n\t\tcdev->brightness_set = asus_kled_cdev_set;\n\t\tcdev->brightness_get = asus_kled_cdev_get;\n\t\tcdev->max_brightness = 3;\n\t\tr = led_classdev_register(&asus->platform_device->dev, cdev);\n\t}\nerror:\n\tif (r)\n\t\tasus_led_exit(asus);\n\treturn r;\n}\n\n \nstatic int asus_read_brightness(struct backlight_device *bd)\n{\n\tstruct asus_laptop *asus = bl_get_data(bd);\n\tunsigned long long value;\n\tacpi_status rv;\n\n\trv = acpi_evaluate_integer(asus->handle, METHOD_BRIGHTNESS_GET,\n\t\t\t\t   NULL, &value);\n\tif (ACPI_FAILURE(rv)) {\n\t\tpr_warn(\"Error reading brightness\\n\");\n\t\treturn 0;\n\t}\n\n\treturn value;\n}\n\nstatic int asus_set_brightness(struct backlight_device *bd, int value)\n{\n\tstruct asus_laptop *asus = bl_get_data(bd);\n\n\tif (write_acpi_int(asus->handle, METHOD_BRIGHTNESS_SET, value)) {\n\t\tpr_warn(\"Error changing brightness\\n\");\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}\n\nstatic int update_bl_status(struct backlight_device *bd)\n{\n\tint value = bd->props.brightness;\n\n\treturn asus_set_brightness(bd, value);\n}\n\nstatic const struct backlight_ops asusbl_ops = {\n\t.get_brightness = asus_read_brightness,\n\t.update_status = update_bl_status,\n};\n\nstatic int asus_backlight_notify(struct asus_laptop *asus)\n{\n\tstruct backlight_device *bd = asus->backlight_device;\n\tint old = bd->props.brightness;\n\n\tbacklight_force_update(bd, BACKLIGHT_UPDATE_HOTKEY);\n\n\treturn old;\n}\n\nstatic int asus_backlight_init(struct asus_laptop *asus)\n{\n\tstruct backlight_device *bd;\n\tstruct backlight_properties props;\n\n\tif (acpi_check_handle(asus->handle, METHOD_BRIGHTNESS_GET, NULL) ||\n\t    acpi_check_handle(asus->handle, METHOD_BRIGHTNESS_SET, NULL))\n\t\treturn 0;\n\n\tmemset(&props, 0, sizeof(struct backlight_properties));\n\tprops.max_brightness = 15;\n\tprops.type = BACKLIGHT_PLATFORM;\n\n\tbd = backlight_device_register(ASUS_LAPTOP_FILE,\n\t\t\t\t       &asus->platform_device->dev, asus,\n\t\t\t\t       &asusbl_ops, &props);\n\tif (IS_ERR(bd)) {\n\t\tpr_err(\"Could not register asus backlight device\\n\");\n\t\tasus->backlight_device = NULL;\n\t\treturn PTR_ERR(bd);\n\t}\n\n\tasus->backlight_device = bd;\n\tbd->props.brightness = asus_read_brightness(bd);\n\tbd->props.power = FB_BLANK_UNBLANK;\n\tbacklight_update_status(bd);\n\treturn 0;\n}\n\nstatic void asus_backlight_exit(struct asus_laptop *asus)\n{\n\tbacklight_device_unregister(asus->backlight_device);\n\tasus->backlight_device = NULL;\n}\n\n \n\n \nstatic ssize_t infos_show(struct device *dev, struct device_attribute *attr,\n\t\t\t  char *page)\n{\n\tstruct asus_laptop *asus = dev_get_drvdata(dev);\n\tint len = 0;\n\tunsigned long long temp;\n\tchar buf[16];\t\t \n\tacpi_status rv;\n\n\t \n\n\tlen += sprintf(page, ASUS_LAPTOP_NAME \" \" ASUS_LAPTOP_VERSION \"\\n\");\n\tlen += sprintf(page + len, \"Model reference    : %s\\n\", asus->name);\n\t \n\trv = acpi_evaluate_integer(asus->handle, \"SFUN\", NULL, &temp);\n\tif (ACPI_SUCCESS(rv))\n\t\tlen += sprintf(page + len, \"SFUN value         : %#x\\n\",\n\t\t\t       (uint) temp);\n\t \n\trv = acpi_evaluate_integer(asus->handle, \"HWRS\", NULL, &temp);\n\tif (ACPI_SUCCESS(rv))\n\t\tlen += sprintf(page + len, \"HWRS value         : %#x\\n\",\n\t\t\t       (uint) temp);\n\t \n\trv = acpi_evaluate_integer(asus->handle, \"ASYM\", NULL, &temp);\n\tif (ACPI_SUCCESS(rv))\n\t\tlen += sprintf(page + len, \"ASYM value         : %#x\\n\",\n\t\t\t       (uint) temp);\n\tif (asus->dsdt_info) {\n\t\tsnprintf(buf, 16, \"%d\", asus->dsdt_info->length);\n\t\tlen += sprintf(page + len, \"DSDT length        : %s\\n\", buf);\n\t\tsnprintf(buf, 16, \"%d\", asus->dsdt_info->checksum);\n\t\tlen += sprintf(page + len, \"DSDT checksum      : %s\\n\", buf);\n\t\tsnprintf(buf, 16, \"%d\", asus->dsdt_info->revision);\n\t\tlen += sprintf(page + len, \"DSDT revision      : %s\\n\", buf);\n\t\tsnprintf(buf, 7, \"%s\", asus->dsdt_info->oem_id);\n\t\tlen += sprintf(page + len, \"OEM id             : %s\\n\", buf);\n\t\tsnprintf(buf, 9, \"%s\", asus->dsdt_info->oem_table_id);\n\t\tlen += sprintf(page + len, \"OEM table id       : %s\\n\", buf);\n\t\tsnprintf(buf, 16, \"%x\", asus->dsdt_info->oem_revision);\n\t\tlen += sprintf(page + len, \"OEM revision       : 0x%s\\n\", buf);\n\t\tsnprintf(buf, 5, \"%s\", asus->dsdt_info->asl_compiler_id);\n\t\tlen += sprintf(page + len, \"ASL comp vendor id : %s\\n\", buf);\n\t\tsnprintf(buf, 16, \"%x\", asus->dsdt_info->asl_compiler_revision);\n\t\tlen += sprintf(page + len, \"ASL comp revision  : 0x%s\\n\", buf);\n\t}\n\n\treturn len;\n}\nstatic DEVICE_ATTR_RO(infos);\n\nstatic ssize_t sysfs_acpi_set(struct asus_laptop *asus,\n\t\t\t      const char *buf, size_t count,\n\t\t\t      const char *method)\n{\n\tint rv, value;\n\n\trv = kstrtoint(buf, 0, &value);\n\tif (rv < 0)\n\t\treturn rv;\n\n\tif (write_acpi_int(asus->handle, method, value))\n\t\treturn -ENODEV;\n\treturn count;\n}\n\n \nstatic ssize_t ledd_show(struct device *dev, struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct asus_laptop *asus = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"0x%08x\\n\", asus->ledd_status);\n}\n\nstatic ssize_t ledd_store(struct device *dev, struct device_attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct asus_laptop *asus = dev_get_drvdata(dev);\n\tint rv, value;\n\n\trv = kstrtoint(buf, 0, &value);\n\tif (rv < 0)\n\t\treturn rv;\n\n\tif (write_acpi_int(asus->handle, METHOD_LEDD, value)) {\n\t\tpr_warn(\"LED display write failed\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tasus->ledd_status = (u32) value;\n\treturn count;\n}\nstatic DEVICE_ATTR_RW(ledd);\n\n \nstatic int asus_wireless_status(struct asus_laptop *asus, int mask)\n{\n\tunsigned long long status;\n\tacpi_status rv = AE_OK;\n\n\tif (!asus->have_rsts)\n\t\treturn (asus->wireless_status & mask) ? 1 : 0;\n\n\trv = acpi_evaluate_integer(asus->handle, METHOD_WL_STATUS,\n\t\t\t\t   NULL, &status);\n\tif (ACPI_FAILURE(rv)) {\n\t\tpr_warn(\"Error reading Wireless status\\n\");\n\t\treturn -EINVAL;\n\t}\n\treturn !!(status & mask);\n}\n\n \nstatic int asus_wlan_set(struct asus_laptop *asus, int status)\n{\n\tif (write_acpi_int(asus->handle, METHOD_WLAN, !!status)) {\n\t\tpr_warn(\"Error setting wlan status to %d\\n\", status);\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}\n\nstatic ssize_t wlan_show(struct device *dev, struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct asus_laptop *asus = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%d\\n\", asus_wireless_status(asus, WL_RSTS));\n}\n\nstatic ssize_t wlan_store(struct device *dev, struct device_attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct asus_laptop *asus = dev_get_drvdata(dev);\n\n\treturn sysfs_acpi_set(asus, buf, count, METHOD_WLAN);\n}\nstatic DEVICE_ATTR_RW(wlan);\n\n \nstatic int asus_bluetooth_set(struct asus_laptop *asus, int status)\n{\n\tif (write_acpi_int(asus->handle, METHOD_BLUETOOTH, !!status)) {\n\t\tpr_warn(\"Error setting bluetooth status to %d\\n\", status);\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}\n\nstatic ssize_t bluetooth_show(struct device *dev, struct device_attribute *attr,\n\t\t\t      char *buf)\n{\n\tstruct asus_laptop *asus = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%d\\n\", asus_wireless_status(asus, BT_RSTS));\n}\n\nstatic ssize_t bluetooth_store(struct device *dev,\n\t\t\t       struct device_attribute *attr, const char *buf,\n\t\t\t       size_t count)\n{\n\tstruct asus_laptop *asus = dev_get_drvdata(dev);\n\n\treturn sysfs_acpi_set(asus, buf, count, METHOD_BLUETOOTH);\n}\nstatic DEVICE_ATTR_RW(bluetooth);\n\n \nstatic int asus_wimax_set(struct asus_laptop *asus, int status)\n{\n\tif (write_acpi_int(asus->handle, METHOD_WIMAX, !!status)) {\n\t\tpr_warn(\"Error setting wimax status to %d\\n\", status);\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}\n\nstatic ssize_t wimax_show(struct device *dev, struct device_attribute *attr,\n\t\t\t  char *buf)\n{\n\tstruct asus_laptop *asus = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%d\\n\", asus_wireless_status(asus, WM_RSTS));\n}\n\nstatic ssize_t wimax_store(struct device *dev, struct device_attribute *attr,\n\t\t\t   const char *buf, size_t count)\n{\n\tstruct asus_laptop *asus = dev_get_drvdata(dev);\n\n\treturn sysfs_acpi_set(asus, buf, count, METHOD_WIMAX);\n}\nstatic DEVICE_ATTR_RW(wimax);\n\n \nstatic int asus_wwan_set(struct asus_laptop *asus, int status)\n{\n\tif (write_acpi_int(asus->handle, METHOD_WWAN, !!status)) {\n\t\tpr_warn(\"Error setting wwan status to %d\\n\", status);\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}\n\nstatic ssize_t wwan_show(struct device *dev, struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct asus_laptop *asus = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%d\\n\", asus_wireless_status(asus, WW_RSTS));\n}\n\nstatic ssize_t wwan_store(struct device *dev, struct device_attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct asus_laptop *asus = dev_get_drvdata(dev);\n\n\treturn sysfs_acpi_set(asus, buf, count, METHOD_WWAN);\n}\nstatic DEVICE_ATTR_RW(wwan);\n\n \nstatic void asus_set_display(struct asus_laptop *asus, int value)\n{\n\t \n\tif (write_acpi_int(asus->handle, METHOD_SWITCH_DISPLAY, value))\n\t\tpr_warn(\"Error setting display\\n\");\n\treturn;\n}\n\n \nstatic ssize_t display_store(struct device *dev, struct device_attribute *attr,\n\t\t\t     const char *buf, size_t count)\n{\n\tstruct asus_laptop *asus = dev_get_drvdata(dev);\n\tint rv, value;\n\n\trv = kstrtoint(buf, 0, &value);\n\tif (rv < 0)\n\t\treturn rv;\n\n\tasus_set_display(asus, value);\n\treturn count;\n}\nstatic DEVICE_ATTR_WO(display);\n\n \nstatic void asus_als_switch(struct asus_laptop *asus, int value)\n{\n\tint ret;\n\n\tif (asus->is_pega_lucid) {\n\t\tret = asus_pega_lucid_set(asus, PEGA_ALS, value);\n\t\tif (!ret)\n\t\t\tret = asus_pega_lucid_set(asus, PEGA_ALS_POWER, value);\n\t} else {\n\t\tret = write_acpi_int(asus->handle, METHOD_ALS_CONTROL, value);\n\t}\n\tif (ret)\n\t\tpr_warn(\"Error setting light sensor switch\\n\");\n\n\tasus->light_switch = value;\n}\n\nstatic ssize_t ls_switch_show(struct device *dev, struct device_attribute *attr,\n\t\t\t      char *buf)\n{\n\tstruct asus_laptop *asus = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%d\\n\", asus->light_switch);\n}\n\nstatic ssize_t ls_switch_store(struct device *dev,\n\t\t\t       struct device_attribute *attr, const char *buf,\n\t\t\t       size_t count)\n{\n\tstruct asus_laptop *asus = dev_get_drvdata(dev);\n\tint rv, value;\n\n\trv = kstrtoint(buf, 0, &value);\n\tif (rv < 0)\n\t\treturn rv;\n\n\tasus_als_switch(asus, value ? 1 : 0);\n\treturn count;\n}\nstatic DEVICE_ATTR_RW(ls_switch);\n\nstatic void asus_als_level(struct asus_laptop *asus, int value)\n{\n\tif (write_acpi_int(asus->handle, METHOD_ALS_LEVEL, value))\n\t\tpr_warn(\"Error setting light sensor level\\n\");\n\tasus->light_level = value;\n}\n\nstatic ssize_t ls_level_show(struct device *dev, struct device_attribute *attr,\n\t\t\t     char *buf)\n{\n\tstruct asus_laptop *asus = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%d\\n\", asus->light_level);\n}\n\nstatic ssize_t ls_level_store(struct device *dev, struct device_attribute *attr,\n\t\t\t      const char *buf, size_t count)\n{\n\tstruct asus_laptop *asus = dev_get_drvdata(dev);\n\tint rv, value;\n\n\trv = kstrtoint(buf, 0, &value);\n\tif (rv < 0)\n\t\treturn rv;\n\n\tvalue = (0 < value) ? ((15 < value) ? 15 : value) : 0;\n\t \n\tasus_als_level(asus, value);\n\n\treturn count;\n}\nstatic DEVICE_ATTR_RW(ls_level);\n\nstatic int pega_int_read(struct asus_laptop *asus, int arg, int *result)\n{\n\tstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };\n\tint err = write_acpi_int_ret(asus->handle, METHOD_PEGA_READ, arg,\n\t\t\t\t     &buffer);\n\tif (!err) {\n\t\tunion acpi_object *obj = buffer.pointer;\n\t\tif (obj && obj->type == ACPI_TYPE_INTEGER)\n\t\t\t*result = obj->integer.value;\n\t\telse\n\t\t\terr = -EIO;\n\t}\n\treturn err;\n}\n\nstatic ssize_t ls_value_show(struct device *dev, struct device_attribute *attr,\n\t\t\t     char *buf)\n{\n\tstruct asus_laptop *asus = dev_get_drvdata(dev);\n\tint err, hi, lo;\n\n\terr = pega_int_read(asus, PEGA_READ_ALS_H, &hi);\n\tif (!err)\n\t\terr = pega_int_read(asus, PEGA_READ_ALS_L, &lo);\n\tif (!err)\n\t\treturn sprintf(buf, \"%d\\n\", 10 * hi + lo);\n\treturn err;\n}\nstatic DEVICE_ATTR_RO(ls_value);\n\n \nstatic int asus_gps_status(struct asus_laptop *asus)\n{\n\tunsigned long long status;\n\tacpi_status rv;\n\n\trv = acpi_evaluate_integer(asus->handle, METHOD_GPS_STATUS,\n\t\t\t\t   NULL, &status);\n\tif (ACPI_FAILURE(rv)) {\n\t\tpr_warn(\"Error reading GPS status\\n\");\n\t\treturn -ENODEV;\n\t}\n\treturn !!status;\n}\n\nstatic int asus_gps_switch(struct asus_laptop *asus, int status)\n{\n\tconst char *meth = status ? METHOD_GPS_ON : METHOD_GPS_OFF;\n\n\tif (write_acpi_int(asus->handle, meth, 0x02))\n\t\treturn -ENODEV;\n\treturn 0;\n}\n\nstatic ssize_t gps_show(struct device *dev, struct device_attribute *attr,\n\t\t\tchar *buf)\n{\n\tstruct asus_laptop *asus = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%d\\n\", asus_gps_status(asus));\n}\n\nstatic ssize_t gps_store(struct device *dev, struct device_attribute *attr,\n\t\t\t const char *buf, size_t count)\n{\n\tstruct asus_laptop *asus = dev_get_drvdata(dev);\n\tint rv, value;\n\tint ret;\n\n\trv = kstrtoint(buf, 0, &value);\n\tif (rv < 0)\n\t\treturn rv;\n\tret = asus_gps_switch(asus, !!value);\n\tif (ret)\n\t\treturn ret;\n\trfkill_set_sw_state(asus->gps.rfkill, !value);\n\treturn count;\n}\nstatic DEVICE_ATTR_RW(gps);\n\n \nstatic int asus_gps_rfkill_set(void *data, bool blocked)\n{\n\tstruct asus_laptop *asus = data;\n\n\treturn asus_gps_switch(asus, !blocked);\n}\n\nstatic const struct rfkill_ops asus_gps_rfkill_ops = {\n\t.set_block = asus_gps_rfkill_set,\n};\n\nstatic int asus_rfkill_set(void *data, bool blocked)\n{\n\tstruct asus_rfkill *rfk = data;\n\tstruct asus_laptop *asus = rfk->asus;\n\n\tif (rfk->control_id == WL_RSTS)\n\t\treturn asus_wlan_set(asus, !blocked);\n\telse if (rfk->control_id == BT_RSTS)\n\t\treturn asus_bluetooth_set(asus, !blocked);\n\telse if (rfk->control_id == WM_RSTS)\n\t\treturn asus_wimax_set(asus, !blocked);\n\telse if (rfk->control_id == WW_RSTS)\n\t\treturn asus_wwan_set(asus, !blocked);\n\n\treturn -EINVAL;\n}\n\nstatic const struct rfkill_ops asus_rfkill_ops = {\n\t.set_block = asus_rfkill_set,\n};\n\nstatic void asus_rfkill_terminate(struct asus_rfkill *rfk)\n{\n\tif (!rfk->rfkill)\n\t\treturn ;\n\n\trfkill_unregister(rfk->rfkill);\n\trfkill_destroy(rfk->rfkill);\n\trfk->rfkill = NULL;\n}\n\nstatic void asus_rfkill_exit(struct asus_laptop *asus)\n{\n\tasus_rfkill_terminate(&asus->wwan);\n\tasus_rfkill_terminate(&asus->bluetooth);\n\tasus_rfkill_terminate(&asus->wlan);\n\tasus_rfkill_terminate(&asus->gps);\n}\n\nstatic int asus_rfkill_setup(struct asus_laptop *asus, struct asus_rfkill *rfk,\n\t\t\t     const char *name, int control_id, int type,\n\t\t\t     const struct rfkill_ops *ops)\n{\n\tint result;\n\n\trfk->control_id = control_id;\n\trfk->asus = asus;\n\trfk->rfkill = rfkill_alloc(name, &asus->platform_device->dev,\n\t\t\t\t   type, ops, rfk);\n\tif (!rfk->rfkill)\n\t\treturn -EINVAL;\n\n\tresult = rfkill_register(rfk->rfkill);\n\tif (result) {\n\t\trfkill_destroy(rfk->rfkill);\n\t\trfk->rfkill = NULL;\n\t}\n\n\treturn result;\n}\n\nstatic int asus_rfkill_init(struct asus_laptop *asus)\n{\n\tint result = 0;\n\n\tif (asus->is_pega_lucid)\n\t\treturn -ENODEV;\n\n\tif (!acpi_check_handle(asus->handle, METHOD_GPS_ON, NULL) &&\n\t    !acpi_check_handle(asus->handle, METHOD_GPS_OFF, NULL) &&\n\t    !acpi_check_handle(asus->handle, METHOD_GPS_STATUS, NULL))\n\t\tresult = asus_rfkill_setup(asus, &asus->gps, \"asus-gps\",\n\t\t\t\t\t   -1, RFKILL_TYPE_GPS,\n\t\t\t\t\t   &asus_gps_rfkill_ops);\n\tif (result)\n\t\tgoto exit;\n\n\n\tif (!acpi_check_handle(asus->handle, METHOD_WLAN, NULL) &&\n\t    asus->wled_type == TYPE_RFKILL)\n\t\tresult = asus_rfkill_setup(asus, &asus->wlan, \"asus-wlan\",\n\t\t\t\t\t   WL_RSTS, RFKILL_TYPE_WLAN,\n\t\t\t\t\t   &asus_rfkill_ops);\n\tif (result)\n\t\tgoto exit;\n\n\tif (!acpi_check_handle(asus->handle, METHOD_BLUETOOTH, NULL) &&\n\t    asus->bled_type == TYPE_RFKILL)\n\t\tresult = asus_rfkill_setup(asus, &asus->bluetooth,\n\t\t\t\t\t   \"asus-bluetooth\", BT_RSTS,\n\t\t\t\t\t   RFKILL_TYPE_BLUETOOTH,\n\t\t\t\t\t   &asus_rfkill_ops);\n\tif (result)\n\t\tgoto exit;\n\n\tif (!acpi_check_handle(asus->handle, METHOD_WWAN, NULL))\n\t\tresult = asus_rfkill_setup(asus, &asus->wwan, \"asus-wwan\",\n\t\t\t\t\t   WW_RSTS, RFKILL_TYPE_WWAN,\n\t\t\t\t\t   &asus_rfkill_ops);\n\tif (result)\n\t\tgoto exit;\n\n\tif (!acpi_check_handle(asus->handle, METHOD_WIMAX, NULL))\n\t\tresult = asus_rfkill_setup(asus, &asus->wimax, \"asus-wimax\",\n\t\t\t\t\t   WM_RSTS, RFKILL_TYPE_WIMAX,\n\t\t\t\t\t   &asus_rfkill_ops);\n\tif (result)\n\t\tgoto exit;\n\nexit:\n\tif (result)\n\t\tasus_rfkill_exit(asus);\n\n\treturn result;\n}\n\nstatic int pega_rfkill_set(void *data, bool blocked)\n{\n\tstruct asus_rfkill *rfk = data;\n\n\tint ret = asus_pega_lucid_set(rfk->asus, rfk->control_id, !blocked);\n\treturn ret;\n}\n\nstatic const struct rfkill_ops pega_rfkill_ops = {\n\t.set_block = pega_rfkill_set,\n};\n\nstatic int pega_rfkill_setup(struct asus_laptop *asus, struct asus_rfkill *rfk,\n\t\t\t     const char *name, int controlid, int rfkill_type)\n{\n\treturn asus_rfkill_setup(asus, rfk, name, controlid, rfkill_type,\n\t\t\t\t &pega_rfkill_ops);\n}\n\nstatic int pega_rfkill_init(struct asus_laptop *asus)\n{\n\tint ret = 0;\n\n\tif(!asus->is_pega_lucid)\n\t\treturn -ENODEV;\n\n\tret = pega_rfkill_setup(asus, &asus->wlan, \"pega-wlan\",\n\t\t\t\tPEGA_WLAN, RFKILL_TYPE_WLAN);\n\tif(ret)\n\t\tgoto exit;\n\n\tret = pega_rfkill_setup(asus, &asus->bluetooth, \"pega-bt\",\n\t\t\t\tPEGA_BLUETOOTH, RFKILL_TYPE_BLUETOOTH);\n\tif(ret)\n\t\tgoto exit;\n\n\tret = pega_rfkill_setup(asus, &asus->wwan, \"pega-wwan\",\n\t\t\t\tPEGA_WWAN, RFKILL_TYPE_WWAN);\n\nexit:\n\tif (ret)\n\t\tasus_rfkill_exit(asus);\n\n\treturn ret;\n}\n\n \nstatic void asus_input_notify(struct asus_laptop *asus, int event)\n{\n\tif (!asus->inputdev)\n\t\treturn ;\n\tif (!sparse_keymap_report_event(asus->inputdev, event, 1, true))\n\t\tpr_info(\"Unknown key %x pressed\\n\", event);\n}\n\nstatic int asus_input_init(struct asus_laptop *asus)\n{\n\tstruct input_dev *input;\n\tint error;\n\n\tinput = input_allocate_device();\n\tif (!input)\n\t\treturn -ENOMEM;\n\n\tinput->name = \"Asus Laptop extra buttons\";\n\tinput->phys = ASUS_LAPTOP_FILE \"/input0\";\n\tinput->id.bustype = BUS_HOST;\n\tinput->dev.parent = &asus->platform_device->dev;\n\n\terror = sparse_keymap_setup(input, asus_keymap, NULL);\n\tif (error) {\n\t\tpr_err(\"Unable to setup input device keymap\\n\");\n\t\tgoto err_free_dev;\n\t}\n\terror = input_register_device(input);\n\tif (error) {\n\t\tpr_warn(\"Unable to register input device\\n\");\n\t\tgoto err_free_dev;\n\t}\n\n\tasus->inputdev = input;\n\treturn 0;\n\nerr_free_dev:\n\tinput_free_device(input);\n\treturn error;\n}\n\nstatic void asus_input_exit(struct asus_laptop *asus)\n{\n\tif (asus->inputdev)\n\t\tinput_unregister_device(asus->inputdev);\n\tasus->inputdev = NULL;\n}\n\n \nstatic void asus_acpi_notify(struct acpi_device *device, u32 event)\n{\n\tstruct asus_laptop *asus = acpi_driver_data(device);\n\tu16 count;\n\n\t \n\tcount = asus->event_count[event % 128]++;\n\tacpi_bus_generate_netlink_event(asus->device->pnp.device_class,\n\t\t\t\t\tdev_name(&asus->device->dev), event,\n\t\t\t\t\tcount);\n\n\tif (event >= ATKD_BRNUP_MIN && event <= ATKD_BRNUP_MAX)\n\t\tevent = ATKD_BRNUP;\n\telse if (event >= ATKD_BRNDOWN_MIN &&\n\t\t event <= ATKD_BRNDOWN_MAX)\n\t\tevent = ATKD_BRNDOWN;\n\n\t \n\tif (event == ATKD_BRNDOWN || event == ATKD_BRNUP) {\n\t\tif (asus->backlight_device != NULL) {\n\t\t\t \n\t\t\tasus_backlight_notify(asus);\n\t\t\treturn ;\n\t\t}\n\t}\n\n\t \n\tif (asus->pega_accel_poll && event == 0xEA) {\n\t\tkobject_uevent(&asus->pega_accel_poll->dev.kobj, KOBJ_CHANGE);\n\t\treturn ;\n\t}\n\n\tasus_input_notify(asus, event);\n}\n\nstatic struct attribute *asus_attributes[] = {\n\t&dev_attr_infos.attr,\n\t&dev_attr_wlan.attr,\n\t&dev_attr_bluetooth.attr,\n\t&dev_attr_wimax.attr,\n\t&dev_attr_wwan.attr,\n\t&dev_attr_display.attr,\n\t&dev_attr_ledd.attr,\n\t&dev_attr_ls_value.attr,\n\t&dev_attr_ls_level.attr,\n\t&dev_attr_ls_switch.attr,\n\t&dev_attr_gps.attr,\n\tNULL\n};\n\nstatic umode_t asus_sysfs_is_visible(struct kobject *kobj,\n\t\t\t\t    struct attribute *attr,\n\t\t\t\t    int idx)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct asus_laptop *asus = dev_get_drvdata(dev);\n\tacpi_handle handle = asus->handle;\n\tbool supported;\n\n\tif (asus->is_pega_lucid) {\n\t\t \n\t\tif (attr == &dev_attr_ls_switch.attr)\n\t\t\tsupported = true;\n\t\telse if (attr == &dev_attr_ls_level.attr)\n\t\t\tsupported = false;\n\t\telse\n\t\t\tgoto normal;\n\n\t\treturn supported ? attr->mode : 0;\n\t}\n\nnormal:\n\tif (attr == &dev_attr_wlan.attr) {\n\t\tsupported = !acpi_check_handle(handle, METHOD_WLAN, NULL);\n\n\t} else if (attr == &dev_attr_bluetooth.attr) {\n\t\tsupported = !acpi_check_handle(handle, METHOD_BLUETOOTH, NULL);\n\n\t} else if (attr == &dev_attr_display.attr) {\n\t\tsupported = !acpi_check_handle(handle, METHOD_SWITCH_DISPLAY, NULL);\n\n\t} else if (attr == &dev_attr_wimax.attr) {\n\t\tsupported =\n\t\t\t!acpi_check_handle(asus->handle, METHOD_WIMAX, NULL);\n\n\t} else if (attr == &dev_attr_wwan.attr) {\n\t\tsupported = !acpi_check_handle(asus->handle, METHOD_WWAN, NULL);\n\n\t} else if (attr == &dev_attr_ledd.attr) {\n\t\tsupported = !acpi_check_handle(handle, METHOD_LEDD, NULL);\n\n\t} else if (attr == &dev_attr_ls_switch.attr ||\n\t\t   attr == &dev_attr_ls_level.attr) {\n\t\tsupported = !acpi_check_handle(handle, METHOD_ALS_CONTROL, NULL) &&\n\t\t\t!acpi_check_handle(handle, METHOD_ALS_LEVEL, NULL);\n\t} else if (attr == &dev_attr_ls_value.attr) {\n\t\tsupported = asus->is_pega_lucid;\n\t} else if (attr == &dev_attr_gps.attr) {\n\t\tsupported = !acpi_check_handle(handle, METHOD_GPS_ON, NULL) &&\n\t\t\t    !acpi_check_handle(handle, METHOD_GPS_OFF, NULL) &&\n\t\t\t    !acpi_check_handle(handle, METHOD_GPS_STATUS, NULL);\n\t} else {\n\t\tsupported = true;\n\t}\n\n\treturn supported ? attr->mode : 0;\n}\n\n\nstatic const struct attribute_group asus_attr_group = {\n\t.is_visible\t= asus_sysfs_is_visible,\n\t.attrs\t\t= asus_attributes,\n};\n\nstatic int asus_platform_init(struct asus_laptop *asus)\n{\n\tint result;\n\n\tasus->platform_device = platform_device_alloc(ASUS_LAPTOP_FILE, PLATFORM_DEVID_NONE);\n\tif (!asus->platform_device)\n\t\treturn -ENOMEM;\n\tplatform_set_drvdata(asus->platform_device, asus);\n\n\tresult = platform_device_add(asus->platform_device);\n\tif (result)\n\t\tgoto fail_platform_device;\n\n\tresult = sysfs_create_group(&asus->platform_device->dev.kobj,\n\t\t\t\t    &asus_attr_group);\n\tif (result)\n\t\tgoto fail_sysfs;\n\n\treturn 0;\n\nfail_sysfs:\n\tplatform_device_del(asus->platform_device);\nfail_platform_device:\n\tplatform_device_put(asus->platform_device);\n\treturn result;\n}\n\nstatic void asus_platform_exit(struct asus_laptop *asus)\n{\n\tsysfs_remove_group(&asus->platform_device->dev.kobj, &asus_attr_group);\n\tplatform_device_unregister(asus->platform_device);\n}\n\nstatic struct platform_driver platform_driver = {\n\t.driver = {\n\t\t.name = ASUS_LAPTOP_FILE,\n\t},\n};\n\n \nstatic int asus_laptop_get_info(struct asus_laptop *asus)\n{\n\tstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };\n\tunion acpi_object *model = NULL;\n\tunsigned long long bsts_result;\n\tchar *string = NULL;\n\tacpi_status status;\n\n\t \n\tstatus = acpi_get_table(ACPI_SIG_DSDT, 1, &asus->dsdt_info);\n\tif (ACPI_FAILURE(status))\n\t\tpr_warn(\"Couldn't get the DSDT table header\\n\");\n\n\t \n\tif (write_acpi_int_ret(asus->handle, \"INIT\", 0, &buffer)) {\n\t\tpr_err(\"Hotkey initialization failed\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tstatus =\n\t    acpi_evaluate_integer(asus->handle, \"BSTS\", NULL, &bsts_result);\n\tif (ACPI_FAILURE(status))\n\t\tpr_warn(\"Error calling BSTS\\n\");\n\telse if (bsts_result)\n\t\tpr_notice(\"BSTS called, 0x%02x returned\\n\",\n\t\t       (uint) bsts_result);\n\n\t \n\tif (write_acpi_int(asus->handle, \"CWAP\", wapf))\n\t\tpr_err(\"Error calling CWAP(%d)\\n\", wapf);\n\t \n\tif (buffer.pointer) {\n\t\tmodel = buffer.pointer;\n\t\tswitch (model->type) {\n\t\tcase ACPI_TYPE_STRING:\n\t\t\tstring = model->string.pointer;\n\t\t\tbreak;\n\t\tcase ACPI_TYPE_BUFFER:\n\t\t\tstring = model->buffer.pointer;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstring = \"\";\n\t\t\tbreak;\n\t\t}\n\t}\n\tasus->name = kstrdup(string, GFP_KERNEL);\n\tif (!asus->name) {\n\t\tkfree(buffer.pointer);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (string)\n\t\tpr_notice(\"  %s model detected\\n\", string);\n\n\tif (!acpi_check_handle(asus->handle, METHOD_WL_STATUS, NULL))\n\t\tasus->have_rsts = true;\n\n\tkfree(model);\n\n\treturn AE_OK;\n}\n\nstatic int asus_acpi_init(struct asus_laptop *asus)\n{\n\tint result = 0;\n\n\tresult = acpi_bus_get_status(asus->device);\n\tif (result)\n\t\treturn result;\n\tif (!asus->device->status.present) {\n\t\tpr_err(\"Hotkey device not present, aborting\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tresult = asus_laptop_get_info(asus);\n\tif (result)\n\t\treturn result;\n\n\tif (!strcmp(bled_type, \"led\"))\n\t\tasus->bled_type = TYPE_LED;\n\telse if (!strcmp(bled_type, \"rfkill\"))\n\t\tasus->bled_type = TYPE_RFKILL;\n\n\tif (!strcmp(wled_type, \"led\"))\n\t\tasus->wled_type = TYPE_LED;\n\telse if (!strcmp(wled_type, \"rfkill\"))\n\t\tasus->wled_type = TYPE_RFKILL;\n\n\tif (bluetooth_status >= 0)\n\t\tasus_bluetooth_set(asus, !!bluetooth_status);\n\n\tif (wlan_status >= 0)\n\t\tasus_wlan_set(asus, !!wlan_status);\n\n\tif (wimax_status >= 0)\n\t\tasus_wimax_set(asus, !!wimax_status);\n\n\tif (wwan_status >= 0)\n\t\tasus_wwan_set(asus, !!wwan_status);\n\n\t \n\tif (!acpi_check_handle(asus->handle, METHOD_KBD_LIGHT_SET, NULL))\n\t\tasus_kled_set(asus, 1);\n\n\t \n\tasus->ledd_status = 0xFFF;\n\n\t \n\tasus->light_switch = !!als_status;\n\tasus->light_level = 5;\t \n\n\tif (asus->is_pega_lucid) {\n\t\tasus_als_switch(asus, asus->light_switch);\n\t} else if (!acpi_check_handle(asus->handle, METHOD_ALS_CONTROL, NULL) &&\n\t\t   !acpi_check_handle(asus->handle, METHOD_ALS_LEVEL, NULL)) {\n\t\tasus_als_switch(asus, asus->light_switch);\n\t\tasus_als_level(asus, asus->light_level);\n\t}\n\n\treturn result;\n}\n\nstatic void asus_dmi_check(void)\n{\n\tconst char *model;\n\n\tmodel = dmi_get_system_info(DMI_PRODUCT_NAME);\n\tif (!model)\n\t\treturn;\n\n\t \n\tif (strncmp(model, \"L1400B\", 6) == 0) {\n\t\twlan_status = -1;\n\t}\n}\n\nstatic bool asus_device_present;\n\nstatic int asus_acpi_add(struct acpi_device *device)\n{\n\tstruct asus_laptop *asus;\n\tint result;\n\n\tpr_notice(\"Asus Laptop Support version %s\\n\",\n\t\t  ASUS_LAPTOP_VERSION);\n\tasus = kzalloc(sizeof(struct asus_laptop), GFP_KERNEL);\n\tif (!asus)\n\t\treturn -ENOMEM;\n\tasus->handle = device->handle;\n\tstrcpy(acpi_device_name(device), ASUS_LAPTOP_DEVICE_NAME);\n\tstrcpy(acpi_device_class(device), ASUS_LAPTOP_CLASS);\n\tdevice->driver_data = asus;\n\tasus->device = device;\n\n\tasus_dmi_check();\n\n\tresult = asus_acpi_init(asus);\n\tif (result)\n\t\tgoto fail_platform;\n\n\t \n\tasus->is_pega_lucid = asus_check_pega_lucid(asus);\n\tresult = asus_platform_init(asus);\n\tif (result)\n\t\tgoto fail_platform;\n\n\tif (acpi_video_get_backlight_type() == acpi_backlight_vendor) {\n\t\tresult = asus_backlight_init(asus);\n\t\tif (result)\n\t\t\tgoto fail_backlight;\n\t}\n\n\tresult = asus_input_init(asus);\n\tif (result)\n\t\tgoto fail_input;\n\n\tresult = asus_led_init(asus);\n\tif (result)\n\t\tgoto fail_led;\n\n\tresult = asus_rfkill_init(asus);\n\tif (result && result != -ENODEV)\n\t\tgoto fail_rfkill;\n\n\tresult = pega_accel_init(asus);\n\tif (result && result != -ENODEV)\n\t\tgoto fail_pega_accel;\n\n\tresult = pega_rfkill_init(asus);\n\tif (result && result != -ENODEV)\n\t\tgoto fail_pega_rfkill;\n\n\tasus_device_present = true;\n\treturn 0;\n\nfail_pega_rfkill:\n\tpega_accel_exit(asus);\nfail_pega_accel:\n\tasus_rfkill_exit(asus);\nfail_rfkill:\n\tasus_led_exit(asus);\nfail_led:\n\tasus_input_exit(asus);\nfail_input:\n\tasus_backlight_exit(asus);\nfail_backlight:\n\tasus_platform_exit(asus);\nfail_platform:\n\tkfree(asus);\n\n\treturn result;\n}\n\nstatic void asus_acpi_remove(struct acpi_device *device)\n{\n\tstruct asus_laptop *asus = acpi_driver_data(device);\n\n\tasus_backlight_exit(asus);\n\tasus_rfkill_exit(asus);\n\tasus_led_exit(asus);\n\tasus_input_exit(asus);\n\tpega_accel_exit(asus);\n\tasus_platform_exit(asus);\n\n\tkfree(asus->name);\n\tkfree(asus);\n}\n\nstatic const struct acpi_device_id asus_device_ids[] = {\n\t{\"ATK0100\", 0},\n\t{\"ATK0101\", 0},\n\t{\"\", 0},\n};\nMODULE_DEVICE_TABLE(acpi, asus_device_ids);\n\nstatic struct acpi_driver asus_acpi_driver = {\n\t.name = ASUS_LAPTOP_NAME,\n\t.class = ASUS_LAPTOP_CLASS,\n\t.owner = THIS_MODULE,\n\t.ids = asus_device_ids,\n\t.flags = ACPI_DRIVER_ALL_NOTIFY_EVENTS,\n\t.ops = {\n\t\t.add = asus_acpi_add,\n\t\t.remove = asus_acpi_remove,\n\t\t.notify = asus_acpi_notify,\n\t\t},\n};\n\nstatic int __init asus_laptop_init(void)\n{\n\tint result;\n\n\tresult = platform_driver_register(&platform_driver);\n\tif (result < 0)\n\t\treturn result;\n\n\tresult = acpi_bus_register_driver(&asus_acpi_driver);\n\tif (result < 0)\n\t\tgoto fail_acpi_driver;\n\tif (!asus_device_present) {\n\t\tresult = -ENODEV;\n\t\tgoto fail_no_device;\n\t}\n\treturn 0;\n\nfail_no_device:\n\tacpi_bus_unregister_driver(&asus_acpi_driver);\nfail_acpi_driver:\n\tplatform_driver_unregister(&platform_driver);\n\treturn result;\n}\n\nstatic void __exit asus_laptop_exit(void)\n{\n\tacpi_bus_unregister_driver(&asus_acpi_driver);\n\tplatform_driver_unregister(&platform_driver);\n}\n\nmodule_init(asus_laptop_init);\nmodule_exit(asus_laptop_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}