{
  "module_name": "core.c",
  "hash_id": "c6ffaedbd2778f15a8166bc17d826b6301b2976c17073e10f2d86dfaab6d3556",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/x86/x86-android-tablets/core.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/acpi.h>\n#include <linux/dmi.h>\n#include <linux/gpio/driver.h>\n#include <linux/gpio/machine.h>\n#include <linux/irq.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/serdev.h>\n#include <linux/string.h>\n\n#include \"x86-android-tablets.h\"\n \n#include \"../../../gpio/gpiolib.h\"\n#include \"../../../gpio/gpiolib-acpi.h\"\n\nstatic int gpiochip_find_match_label(struct gpio_chip *gc, void *data)\n{\n\treturn gc->label && !strcmp(gc->label, data);\n}\n\nint x86_android_tablet_get_gpiod(const char *label, int pin, struct gpio_desc **desc)\n{\n\tstruct gpio_desc *gpiod;\n\tstruct gpio_chip *chip;\n\n\tchip = gpiochip_find((void *)label, gpiochip_find_match_label);\n\tif (!chip) {\n\t\tpr_err(\"error cannot find GPIO chip %s\\n\", label);\n\t\treturn -ENODEV;\n\t}\n\n\tgpiod = gpiochip_get_desc(chip, pin);\n\tif (IS_ERR(gpiod)) {\n\t\tpr_err(\"error %ld getting GPIO %s %d\\n\", PTR_ERR(gpiod), label, pin);\n\t\treturn PTR_ERR(gpiod);\n\t}\n\n\t*desc = gpiod;\n\treturn 0;\n}\n\nint x86_acpi_irq_helper_get(const struct x86_acpi_irq_data *data)\n{\n\tstruct irq_fwspec fwspec = { };\n\tstruct irq_domain *domain;\n\tstruct acpi_device *adev;\n\tstruct gpio_desc *gpiod;\n\tunsigned int irq_type;\n\tacpi_handle handle;\n\tacpi_status status;\n\tint irq, ret;\n\n\tswitch (data->type) {\n\tcase X86_ACPI_IRQ_TYPE_APIC:\n\t\t \n\t\tacpi_unregister_gsi(data->index);\n\t\tirq = acpi_register_gsi(NULL, data->index, data->trigger, data->polarity);\n\t\tif (irq < 0)\n\t\t\tpr_err(\"error %d getting APIC IRQ %d\\n\", irq, data->index);\n\n\t\treturn irq;\n\tcase X86_ACPI_IRQ_TYPE_GPIOINT:\n\t\t \n\t\tret = x86_android_tablet_get_gpiod(data->chip, data->index, &gpiod);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tirq = gpiod_to_irq(gpiod);\n\t\tif (irq < 0) {\n\t\t\tpr_err(\"error %d getting IRQ %s %d\\n\", irq, data->chip, data->index);\n\t\t\treturn irq;\n\t\t}\n\n\t\tirq_type = acpi_dev_get_irq_type(data->trigger, data->polarity);\n\t\tif (irq_type != IRQ_TYPE_NONE && irq_type != irq_get_trigger_type(irq))\n\t\t\tirq_set_irq_type(irq, irq_type);\n\n\t\treturn irq;\n\tcase X86_ACPI_IRQ_TYPE_PMIC:\n\t\tstatus = acpi_get_handle(NULL, data->chip, &handle);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tpr_err(\"error could not get %s handle\\n\", data->chip);\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\tadev = acpi_fetch_acpi_dev(handle);\n\t\tif (!adev) {\n\t\t\tpr_err(\"error could not get %s adev\\n\", data->chip);\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\tfwspec.fwnode = acpi_fwnode_handle(adev);\n\t\tdomain = irq_find_matching_fwspec(&fwspec, data->domain);\n\t\tif (!domain) {\n\t\t\tpr_err(\"error could not find IRQ domain for %s\\n\", data->chip);\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\treturn irq_create_mapping(domain, data->index);\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic int i2c_client_count;\nstatic int pdev_count;\nstatic int serdev_count;\nstatic struct i2c_client **i2c_clients;\nstatic struct platform_device **pdevs;\nstatic struct serdev_device **serdevs;\nstatic struct gpio_keys_button *buttons;\nstatic struct gpiod_lookup_table * const *gpiod_lookup_tables;\nstatic const struct software_node *bat_swnode;\nstatic void (*exit_handler)(void);\n\nstatic __init int x86_instantiate_i2c_client(const struct x86_dev_info *dev_info,\n\t\t\t\t\t     int idx)\n{\n\tconst struct x86_i2c_client_info *client_info = &dev_info->i2c_client_info[idx];\n\tstruct i2c_board_info board_info = client_info->board_info;\n\tstruct i2c_adapter *adap;\n\tacpi_handle handle;\n\tacpi_status status;\n\n\tboard_info.irq = x86_acpi_irq_helper_get(&client_info->irq_data);\n\tif (board_info.irq < 0)\n\t\treturn board_info.irq;\n\n\tstatus = acpi_get_handle(NULL, client_info->adapter_path, &handle);\n\tif (ACPI_FAILURE(status)) {\n\t\tpr_err(\"Error could not get %s handle\\n\", client_info->adapter_path);\n\t\treturn -ENODEV;\n\t}\n\n\tadap = i2c_acpi_find_adapter_by_handle(handle);\n\tif (!adap) {\n\t\tpr_err(\"error could not get %s adapter\\n\", client_info->adapter_path);\n\t\treturn -ENODEV;\n\t}\n\n\ti2c_clients[idx] = i2c_new_client_device(adap, &board_info);\n\tput_device(&adap->dev);\n\tif (IS_ERR(i2c_clients[idx]))\n\t\treturn dev_err_probe(&adap->dev, PTR_ERR(i2c_clients[idx]),\n\t\t\t\t      \"creating I2C-client %d\\n\", idx);\n\n\treturn 0;\n}\n\nstatic __init int x86_instantiate_serdev(const struct x86_serdev_info *info, int idx)\n{\n\tstruct acpi_device *ctrl_adev, *serdev_adev;\n\tstruct serdev_device *serdev;\n\tstruct device *ctrl_dev;\n\tint ret = -ENODEV;\n\n\tctrl_adev = acpi_dev_get_first_match_dev(info->ctrl_hid, info->ctrl_uid, -1);\n\tif (!ctrl_adev) {\n\t\tpr_err(\"error could not get %s/%s ctrl adev\\n\",\n\t\t       info->ctrl_hid, info->ctrl_uid);\n\t\treturn -ENODEV;\n\t}\n\n\tserdev_adev = acpi_dev_get_first_match_dev(info->serdev_hid, NULL, -1);\n\tif (!serdev_adev) {\n\t\tpr_err(\"error could not get %s serdev adev\\n\", info->serdev_hid);\n\t\tgoto put_ctrl_adev;\n\t}\n\n\t \n\tctrl_dev = acpi_get_first_physical_node(ctrl_adev);\n\tif (!ctrl_dev)\t{\n\t\tpr_err(\"error could not get %s/%s ctrl physical dev\\n\",\n\t\t       info->ctrl_hid, info->ctrl_uid);\n\t\tgoto put_serdev_adev;\n\t}\n\n\t \n\tctrl_dev = device_find_child_by_name(ctrl_dev, info->ctrl_devname);\n\tif (!ctrl_dev) {\n\t\tpr_err(\"error could not get %s/%s %s ctrl dev\\n\",\n\t\t       info->ctrl_hid, info->ctrl_uid, info->ctrl_devname);\n\t\tgoto put_serdev_adev;\n\t}\n\n\tserdev = serdev_device_alloc(to_serdev_controller(ctrl_dev));\n\tif (!serdev) {\n\t\tret = -ENOMEM;\n\t\tgoto put_serdev_adev;\n\t}\n\n\tACPI_COMPANION_SET(&serdev->dev, serdev_adev);\n\tacpi_device_set_enumerated(serdev_adev);\n\n\tret = serdev_device_add(serdev);\n\tif (ret) {\n\t\tdev_err(&serdev->dev, \"error %d adding serdev\\n\", ret);\n\t\tserdev_device_put(serdev);\n\t\tgoto put_serdev_adev;\n\t}\n\n\tserdevs[idx] = serdev;\n\nput_serdev_adev:\n\tacpi_dev_put(serdev_adev);\nput_ctrl_adev:\n\tacpi_dev_put(ctrl_adev);\n\treturn ret;\n}\n\nstatic void x86_android_tablet_cleanup(void)\n{\n\tint i;\n\n\tfor (i = 0; i < serdev_count; i++) {\n\t\tif (serdevs[i])\n\t\t\tserdev_device_remove(serdevs[i]);\n\t}\n\n\tkfree(serdevs);\n\n\tfor (i = 0; i < pdev_count; i++)\n\t\tplatform_device_unregister(pdevs[i]);\n\n\tkfree(pdevs);\n\tkfree(buttons);\n\n\tfor (i = 0; i < i2c_client_count; i++)\n\t\ti2c_unregister_device(i2c_clients[i]);\n\n\tkfree(i2c_clients);\n\n\tif (exit_handler)\n\t\texit_handler();\n\n\tfor (i = 0; gpiod_lookup_tables && gpiod_lookup_tables[i]; i++)\n\t\tgpiod_remove_lookup_table(gpiod_lookup_tables[i]);\n\n\tsoftware_node_unregister(bat_swnode);\n}\n\nstatic __init int x86_android_tablet_init(void)\n{\n\tconst struct x86_dev_info *dev_info;\n\tconst struct dmi_system_id *id;\n\tstruct gpio_chip *chip;\n\tint i, ret = 0;\n\n\tid = dmi_first_match(x86_android_tablet_ids);\n\tif (!id)\n\t\treturn -ENODEV;\n\n\tdev_info = id->driver_data;\n\n\t \n\tif (dev_info->invalid_aei_gpiochip) {\n\t\tchip = gpiochip_find(dev_info->invalid_aei_gpiochip,\n\t\t\t\t     gpiochip_find_match_label);\n\t\tif (!chip) {\n\t\t\tpr_err(\"error cannot find GPIO chip %s\\n\", dev_info->invalid_aei_gpiochip);\n\t\t\treturn -ENODEV;\n\t\t}\n\t\tacpi_gpiochip_free_interrupts(chip);\n\t}\n\n\t \n\tfor (i = 0; dev_info->modules && dev_info->modules[i]; i++)\n\t\trequest_module(dev_info->modules[i]);\n\n\tbat_swnode = dev_info->bat_swnode;\n\tif (bat_swnode) {\n\t\tret = software_node_register(bat_swnode);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tgpiod_lookup_tables = dev_info->gpiod_lookup_tables;\n\tfor (i = 0; gpiod_lookup_tables && gpiod_lookup_tables[i]; i++)\n\t\tgpiod_add_lookup_table(gpiod_lookup_tables[i]);\n\n\tif (dev_info->init) {\n\t\tret = dev_info->init();\n\t\tif (ret < 0) {\n\t\t\tx86_android_tablet_cleanup();\n\t\t\treturn ret;\n\t\t}\n\t\texit_handler = dev_info->exit;\n\t}\n\n\ti2c_clients = kcalloc(dev_info->i2c_client_count, sizeof(*i2c_clients), GFP_KERNEL);\n\tif (!i2c_clients) {\n\t\tx86_android_tablet_cleanup();\n\t\treturn -ENOMEM;\n\t}\n\n\ti2c_client_count = dev_info->i2c_client_count;\n\tfor (i = 0; i < i2c_client_count; i++) {\n\t\tret = x86_instantiate_i2c_client(dev_info, i);\n\t\tif (ret < 0) {\n\t\t\tx86_android_tablet_cleanup();\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tpdevs = kcalloc(dev_info->pdev_count + 1, sizeof(*pdevs), GFP_KERNEL);\n\tif (!pdevs) {\n\t\tx86_android_tablet_cleanup();\n\t\treturn -ENOMEM;\n\t}\n\n\tpdev_count = dev_info->pdev_count;\n\tfor (i = 0; i < pdev_count; i++) {\n\t\tpdevs[i] = platform_device_register_full(&dev_info->pdev_info[i]);\n\t\tif (IS_ERR(pdevs[i])) {\n\t\t\tx86_android_tablet_cleanup();\n\t\t\treturn PTR_ERR(pdevs[i]);\n\t\t}\n\t}\n\n\tserdevs = kcalloc(dev_info->serdev_count, sizeof(*serdevs), GFP_KERNEL);\n\tif (!serdevs) {\n\t\tx86_android_tablet_cleanup();\n\t\treturn -ENOMEM;\n\t}\n\n\tserdev_count = dev_info->serdev_count;\n\tfor (i = 0; i < serdev_count; i++) {\n\t\tret = x86_instantiate_serdev(&dev_info->serdev_info[i], i);\n\t\tif (ret < 0) {\n\t\t\tx86_android_tablet_cleanup();\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (dev_info->gpio_button_count) {\n\t\tstruct gpio_keys_platform_data pdata = { };\n\t\tstruct gpio_desc *gpiod;\n\n\t\tbuttons = kcalloc(dev_info->gpio_button_count, sizeof(*buttons), GFP_KERNEL);\n\t\tif (!buttons) {\n\t\t\tx86_android_tablet_cleanup();\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tfor (i = 0; i < dev_info->gpio_button_count; i++) {\n\t\t\tret = x86_android_tablet_get_gpiod(dev_info->gpio_button[i].chip,\n\t\t\t\t\t\t\t   dev_info->gpio_button[i].pin, &gpiod);\n\t\t\tif (ret < 0) {\n\t\t\t\tx86_android_tablet_cleanup();\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tbuttons[i] = dev_info->gpio_button[i].button;\n\t\t\tbuttons[i].gpio = desc_to_gpio(gpiod);\n\t\t}\n\n\t\tpdata.buttons = buttons;\n\t\tpdata.nbuttons = dev_info->gpio_button_count;\n\n\t\tpdevs[pdev_count] = platform_device_register_data(NULL, \"gpio-keys\",\n\t\t\t\t\t\t\t\t  PLATFORM_DEVID_AUTO,\n\t\t\t\t\t\t\t\t  &pdata, sizeof(pdata));\n\t\tif (IS_ERR(pdevs[pdev_count])) {\n\t\t\tx86_android_tablet_cleanup();\n\t\t\treturn PTR_ERR(pdevs[pdev_count]);\n\t\t}\n\t\tpdev_count++;\n\t}\n\n\treturn 0;\n}\n\nmodule_init(x86_android_tablet_init);\nmodule_exit(x86_android_tablet_cleanup);\n\nMODULE_AUTHOR(\"Hans de Goede <hdegoede@redhat.com>\");\nMODULE_DESCRIPTION(\"X86 Android tablets DSDT fixups driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}