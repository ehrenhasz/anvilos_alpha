{
  "module_name": "fujitsu-laptop.c",
  "hash_id": "8b28a6f81a8f903496a0ac8588b6ba7ff7d42d3e774cd452a66f79aab87c2782",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/x86/fujitsu-laptop.c",
  "human_readable_source": "\n \n\n \n\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/acpi.h>\n#include <linux/bitops.h>\n#include <linux/dmi.h>\n#include <linux/backlight.h>\n#include <linux/fb.h>\n#include <linux/input.h>\n#include <linux/input/sparse-keymap.h>\n#include <linux/kfifo.h>\n#include <linux/leds.h>\n#include <linux/platform_device.h>\n#include <acpi/video.h>\n\n#define FUJITSU_DRIVER_VERSION\t\t\"0.6.0\"\n\n#define FUJITSU_LCD_N_LEVELS\t\t8\n\n#define ACPI_FUJITSU_CLASS\t\t\"fujitsu\"\n#define ACPI_FUJITSU_BL_HID\t\t\"FUJ02B1\"\n#define ACPI_FUJITSU_BL_DRIVER_NAME\t\"Fujitsu laptop FUJ02B1 ACPI brightness driver\"\n#define ACPI_FUJITSU_BL_DEVICE_NAME\t\"Fujitsu FUJ02B1\"\n#define ACPI_FUJITSU_LAPTOP_HID\t\t\"FUJ02E3\"\n#define ACPI_FUJITSU_LAPTOP_DRIVER_NAME\t\"Fujitsu laptop FUJ02E3 ACPI hotkeys driver\"\n#define ACPI_FUJITSU_LAPTOP_DEVICE_NAME\t\"Fujitsu FUJ02E3\"\n\n#define ACPI_FUJITSU_NOTIFY_CODE\t0x80\n\n \n#define FUNC_FLAGS\t\t\tBIT(12)\n#define FUNC_LEDS\t\t\t(BIT(12) | BIT(0))\n#define FUNC_BUTTONS\t\t\t(BIT(12) | BIT(1))\n#define FUNC_BACKLIGHT\t\t\t(BIT(12) | BIT(2))\n\n \n#define UNSUPPORTED_CMD\t\t\t0x80000000\n\n \n#define FLAG_RFKILL\t\t\tBIT(5)\n#define FLAG_LID\t\t\tBIT(8)\n#define FLAG_DOCK\t\t\tBIT(9)\n#define FLAG_TOUCHPAD_TOGGLE\t\tBIT(26)\n#define FLAG_MICMUTE\t\t\tBIT(29)\n#define FLAG_SOFTKEYS\t\t\t(FLAG_RFKILL | FLAG_TOUCHPAD_TOGGLE | FLAG_MICMUTE)\n\n \n#define FUNC_LED_OFF\t\t\tBIT(0)\n#define FUNC_LED_ON\t\t\t(BIT(0) | BIT(16) | BIT(17))\n#define LOGOLAMP_POWERON\t\tBIT(13)\n#define LOGOLAMP_ALWAYS\t\t\tBIT(14)\n#define KEYBOARD_LAMPS\t\t\tBIT(8)\n#define RADIO_LED_ON\t\t\tBIT(5)\n#define ECO_LED\t\t\t\tBIT(16)\n#define ECO_LED_ON\t\t\tBIT(19)\n\n \n#define BACKLIGHT_PARAM_POWER\t\tBIT(2)\n#define BACKLIGHT_OFF\t\t\t(BIT(0) | BIT(1))\n#define BACKLIGHT_ON\t\t\t0\n\n \n#define KEY1_CODE\t\t\t0x410\n#define KEY2_CODE\t\t\t0x411\n#define KEY3_CODE\t\t\t0x412\n#define KEY4_CODE\t\t\t0x413\n#define KEY5_CODE\t\t\t0x420\n\n \n#define MAX_HOTKEY_RINGBUFFER_SIZE\t100\n#define RINGBUFFERSIZE\t\t\t40\n\n \nstatic int use_alt_lcd_levels = -1;\nstatic bool disable_brightness_adjust;\n\n \nstruct fujitsu_bl {\n\tstruct input_dev *input;\n\tchar phys[32];\n\tstruct backlight_device *bl_device;\n\tunsigned int max_brightness;\n\tunsigned int brightness_level;\n};\n\nstatic struct fujitsu_bl *fujitsu_bl;\n\n \nstruct fujitsu_laptop {\n\tstruct input_dev *input;\n\tchar phys[32];\n\tstruct platform_device *pf_device;\n\tstruct kfifo fifo;\n\tspinlock_t fifo_lock;\n\tint flags_supported;\n\tint flags_state;\n};\n\nstatic struct acpi_device *fext;\n\n \n\nstatic int call_fext_func(struct acpi_device *device,\n\t\t\t  int func, int op, int feature, int state)\n{\n\tunion acpi_object params[4] = {\n\t\t{ .integer.type = ACPI_TYPE_INTEGER, .integer.value = func },\n\t\t{ .integer.type = ACPI_TYPE_INTEGER, .integer.value = op },\n\t\t{ .integer.type = ACPI_TYPE_INTEGER, .integer.value = feature },\n\t\t{ .integer.type = ACPI_TYPE_INTEGER, .integer.value = state }\n\t};\n\tstruct acpi_object_list arg_list = { 4, params };\n\tunsigned long long value;\n\tacpi_status status;\n\n\tstatus = acpi_evaluate_integer(device->handle, \"FUNC\", &arg_list,\n\t\t\t\t       &value);\n\tif (ACPI_FAILURE(status)) {\n\t\tacpi_handle_err(device->handle, \"Failed to evaluate FUNC\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tacpi_handle_debug(device->handle,\n\t\t\t  \"FUNC 0x%x (args 0x%x, 0x%x, 0x%x) returned 0x%x\\n\",\n\t\t\t  func, op, feature, state, (int)value);\n\treturn value;\n}\n\n \n\nstatic int set_lcd_level(struct acpi_device *device, int level)\n{\n\tstruct fujitsu_bl *priv = acpi_driver_data(device);\n\tacpi_status status;\n\tchar *method;\n\n\tswitch (use_alt_lcd_levels) {\n\tcase -1:\n\t\tif (acpi_has_method(device->handle, \"SBL2\"))\n\t\t\tmethod = \"SBL2\";\n\t\telse\n\t\t\tmethod = \"SBLL\";\n\t\tbreak;\n\tcase 1:\n\t\tmethod = \"SBL2\";\n\t\tbreak;\n\tdefault:\n\t\tmethod = \"SBLL\";\n\t\tbreak;\n\t}\n\n\tacpi_handle_debug(device->handle, \"set lcd level via %s [%d]\\n\", method,\n\t\t\t  level);\n\n\tif (level < 0 || level >= priv->max_brightness)\n\t\treturn -EINVAL;\n\n\tstatus = acpi_execute_simple_method(device->handle, method, level);\n\tif (ACPI_FAILURE(status)) {\n\t\tacpi_handle_err(device->handle, \"Failed to evaluate %s\\n\",\n\t\t\t\tmethod);\n\t\treturn -ENODEV;\n\t}\n\n\tpriv->brightness_level = level;\n\n\treturn 0;\n}\n\nstatic int get_lcd_level(struct acpi_device *device)\n{\n\tstruct fujitsu_bl *priv = acpi_driver_data(device);\n\tunsigned long long state = 0;\n\tacpi_status status = AE_OK;\n\n\tacpi_handle_debug(device->handle, \"get lcd level via GBLL\\n\");\n\n\tstatus = acpi_evaluate_integer(device->handle, \"GBLL\", NULL, &state);\n\tif (ACPI_FAILURE(status))\n\t\treturn 0;\n\n\tpriv->brightness_level = state & 0x0fffffff;\n\n\treturn priv->brightness_level;\n}\n\nstatic int get_max_brightness(struct acpi_device *device)\n{\n\tstruct fujitsu_bl *priv = acpi_driver_data(device);\n\tunsigned long long state = 0;\n\tacpi_status status = AE_OK;\n\n\tacpi_handle_debug(device->handle, \"get max lcd level via RBLL\\n\");\n\n\tstatus = acpi_evaluate_integer(device->handle, \"RBLL\", NULL, &state);\n\tif (ACPI_FAILURE(status))\n\t\treturn -1;\n\n\tpriv->max_brightness = state;\n\n\treturn priv->max_brightness;\n}\n\n \n\nstatic int bl_get_brightness(struct backlight_device *b)\n{\n\tstruct acpi_device *device = bl_get_data(b);\n\n\treturn b->props.power == FB_BLANK_POWERDOWN ? 0 : get_lcd_level(device);\n}\n\nstatic int bl_update_status(struct backlight_device *b)\n{\n\tstruct acpi_device *device = bl_get_data(b);\n\n\tif (fext) {\n\t\tif (b->props.power == FB_BLANK_POWERDOWN)\n\t\t\tcall_fext_func(fext, FUNC_BACKLIGHT, 0x1,\n\t\t\t\t       BACKLIGHT_PARAM_POWER, BACKLIGHT_OFF);\n\t\telse\n\t\t\tcall_fext_func(fext, FUNC_BACKLIGHT, 0x1,\n\t\t\t\t       BACKLIGHT_PARAM_POWER, BACKLIGHT_ON);\n\t}\n\n\treturn set_lcd_level(device, b->props.brightness);\n}\n\nstatic const struct backlight_ops fujitsu_bl_ops = {\n\t.get_brightness = bl_get_brightness,\n\t.update_status = bl_update_status,\n};\n\nstatic ssize_t lid_show(struct device *dev, struct device_attribute *attr,\n\t\t\tchar *buf)\n{\n\tstruct fujitsu_laptop *priv = dev_get_drvdata(dev);\n\n\tif (!(priv->flags_supported & FLAG_LID))\n\t\treturn sprintf(buf, \"unknown\\n\");\n\tif (priv->flags_state & FLAG_LID)\n\t\treturn sprintf(buf, \"open\\n\");\n\telse\n\t\treturn sprintf(buf, \"closed\\n\");\n}\n\nstatic ssize_t dock_show(struct device *dev, struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct fujitsu_laptop *priv = dev_get_drvdata(dev);\n\n\tif (!(priv->flags_supported & FLAG_DOCK))\n\t\treturn sprintf(buf, \"unknown\\n\");\n\tif (priv->flags_state & FLAG_DOCK)\n\t\treturn sprintf(buf, \"docked\\n\");\n\telse\n\t\treturn sprintf(buf, \"undocked\\n\");\n}\n\nstatic ssize_t radios_show(struct device *dev, struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\tstruct fujitsu_laptop *priv = dev_get_drvdata(dev);\n\n\tif (!(priv->flags_supported & FLAG_RFKILL))\n\t\treturn sprintf(buf, \"unknown\\n\");\n\tif (priv->flags_state & FLAG_RFKILL)\n\t\treturn sprintf(buf, \"on\\n\");\n\telse\n\t\treturn sprintf(buf, \"killed\\n\");\n}\n\nstatic DEVICE_ATTR_RO(lid);\nstatic DEVICE_ATTR_RO(dock);\nstatic DEVICE_ATTR_RO(radios);\n\nstatic struct attribute *fujitsu_pf_attributes[] = {\n\t&dev_attr_lid.attr,\n\t&dev_attr_dock.attr,\n\t&dev_attr_radios.attr,\n\tNULL\n};\n\nstatic const struct attribute_group fujitsu_pf_attribute_group = {\n\t.attrs = fujitsu_pf_attributes\n};\n\nstatic struct platform_driver fujitsu_pf_driver = {\n\t.driver = {\n\t\t   .name = \"fujitsu-laptop\",\n\t\t   }\n};\n\n \n\nstatic const struct key_entry keymap_backlight[] = {\n\t{ KE_KEY, true, { KEY_BRIGHTNESSUP } },\n\t{ KE_KEY, false, { KEY_BRIGHTNESSDOWN } },\n\t{ KE_END, 0 }\n};\n\nstatic int acpi_fujitsu_bl_input_setup(struct acpi_device *device)\n{\n\tstruct fujitsu_bl *priv = acpi_driver_data(device);\n\tint ret;\n\n\tpriv->input = devm_input_allocate_device(&device->dev);\n\tif (!priv->input)\n\t\treturn -ENOMEM;\n\n\tsnprintf(priv->phys, sizeof(priv->phys), \"%s/video/input0\",\n\t\t acpi_device_hid(device));\n\n\tpriv->input->name = acpi_device_name(device);\n\tpriv->input->phys = priv->phys;\n\tpriv->input->id.bustype = BUS_HOST;\n\tpriv->input->id.product = 0x06;\n\n\tret = sparse_keymap_setup(priv->input, keymap_backlight, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\treturn input_register_device(priv->input);\n}\n\nstatic int fujitsu_backlight_register(struct acpi_device *device)\n{\n\tstruct fujitsu_bl *priv = acpi_driver_data(device);\n\tconst struct backlight_properties props = {\n\t\t.brightness = priv->brightness_level,\n\t\t.max_brightness = priv->max_brightness - 1,\n\t\t.type = BACKLIGHT_PLATFORM\n\t};\n\tstruct backlight_device *bd;\n\n\tbd = devm_backlight_device_register(&device->dev, \"fujitsu-laptop\",\n\t\t\t\t\t    &device->dev, device,\n\t\t\t\t\t    &fujitsu_bl_ops, &props);\n\tif (IS_ERR(bd))\n\t\treturn PTR_ERR(bd);\n\n\tpriv->bl_device = bd;\n\n\treturn 0;\n}\n\nstatic int acpi_fujitsu_bl_add(struct acpi_device *device)\n{\n\tstruct fujitsu_bl *priv;\n\tint ret;\n\n\tif (acpi_video_get_backlight_type() != acpi_backlight_vendor)\n\t\treturn -ENODEV;\n\n\tpriv = devm_kzalloc(&device->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tfujitsu_bl = priv;\n\tstrcpy(acpi_device_name(device), ACPI_FUJITSU_BL_DEVICE_NAME);\n\tstrcpy(acpi_device_class(device), ACPI_FUJITSU_CLASS);\n\tdevice->driver_data = priv;\n\n\tpr_info(\"ACPI: %s [%s]\\n\",\n\t\tacpi_device_name(device), acpi_device_bid(device));\n\n\tif (get_max_brightness(device) <= 0)\n\t\tpriv->max_brightness = FUJITSU_LCD_N_LEVELS;\n\tget_lcd_level(device);\n\n\tret = acpi_fujitsu_bl_input_setup(device);\n\tif (ret)\n\t\treturn ret;\n\n\treturn fujitsu_backlight_register(device);\n}\n\n \n\nstatic void acpi_fujitsu_bl_notify(struct acpi_device *device, u32 event)\n{\n\tstruct fujitsu_bl *priv = acpi_driver_data(device);\n\tint oldb, newb;\n\n\tif (event != ACPI_FUJITSU_NOTIFY_CODE) {\n\t\tacpi_handle_info(device->handle, \"unsupported event [0x%x]\\n\",\n\t\t\t\t event);\n\t\tsparse_keymap_report_event(priv->input, -1, 1, true);\n\t\treturn;\n\t}\n\n\toldb = priv->brightness_level;\n\tget_lcd_level(device);\n\tnewb = priv->brightness_level;\n\n\tacpi_handle_debug(device->handle,\n\t\t\t  \"brightness button event [%i -> %i]\\n\", oldb, newb);\n\n\tif (oldb == newb)\n\t\treturn;\n\n\tif (!disable_brightness_adjust)\n\t\tset_lcd_level(device, newb);\n\n\tsparse_keymap_report_event(priv->input, oldb < newb, 1, true);\n}\n\n \n\nstatic const struct key_entry keymap_default[] = {\n\t{ KE_KEY, KEY1_CODE,            { KEY_PROG1 } },\n\t{ KE_KEY, KEY2_CODE,            { KEY_PROG2 } },\n\t{ KE_KEY, KEY3_CODE,            { KEY_PROG3 } },\n\t{ KE_KEY, KEY4_CODE,            { KEY_PROG4 } },\n\t{ KE_KEY, KEY5_CODE,            { KEY_RFKILL } },\n\t \n\t{ KE_KEY, FLAG_RFKILL,          { KEY_RFKILL } },\n\t{ KE_KEY, FLAG_TOUCHPAD_TOGGLE, { KEY_TOUCHPAD_TOGGLE } },\n\t{ KE_KEY, FLAG_MICMUTE,         { KEY_MICMUTE } },\n\t{ KE_END, 0 }\n};\n\nstatic const struct key_entry keymap_s64x0[] = {\n\t{ KE_KEY, KEY1_CODE, { KEY_SCREENLOCK } },\t \n\t{ KE_KEY, KEY2_CODE, { KEY_HELP } },\t\t \n\t{ KE_KEY, KEY3_CODE, { KEY_PROG3 } },\n\t{ KE_KEY, KEY4_CODE, { KEY_PROG4 } },\n\t{ KE_END, 0 }\n};\n\nstatic const struct key_entry keymap_p8010[] = {\n\t{ KE_KEY, KEY1_CODE, { KEY_HELP } },\t\t \n\t{ KE_KEY, KEY2_CODE, { KEY_PROG2 } },\n\t{ KE_KEY, KEY3_CODE, { KEY_SWITCHVIDEOMODE } },\t \n\t{ KE_KEY, KEY4_CODE, { KEY_WWW } },\t\t \n\t{ KE_END, 0 }\n};\n\nstatic const struct key_entry *keymap = keymap_default;\n\nstatic int fujitsu_laptop_dmi_keymap_override(const struct dmi_system_id *id)\n{\n\tpr_info(\"Identified laptop model '%s'\\n\", id->ident);\n\tkeymap = id->driver_data;\n\treturn 1;\n}\n\nstatic const struct dmi_system_id fujitsu_laptop_dmi_table[] = {\n\t{\n\t\t.callback = fujitsu_laptop_dmi_keymap_override,\n\t\t.ident = \"Fujitsu Siemens S6410\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"FUJITSU SIEMENS\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"LIFEBOOK S6410\"),\n\t\t},\n\t\t.driver_data = (void *)keymap_s64x0\n\t},\n\t{\n\t\t.callback = fujitsu_laptop_dmi_keymap_override,\n\t\t.ident = \"Fujitsu Siemens S6420\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"FUJITSU SIEMENS\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"LIFEBOOK S6420\"),\n\t\t},\n\t\t.driver_data = (void *)keymap_s64x0\n\t},\n\t{\n\t\t.callback = fujitsu_laptop_dmi_keymap_override,\n\t\t.ident = \"Fujitsu LifeBook P8010\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"FUJITSU\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"LifeBook P8010\"),\n\t\t},\n\t\t.driver_data = (void *)keymap_p8010\n\t},\n\t{}\n};\n\nstatic int acpi_fujitsu_laptop_input_setup(struct acpi_device *device)\n{\n\tstruct fujitsu_laptop *priv = acpi_driver_data(device);\n\tint ret;\n\n\tpriv->input = devm_input_allocate_device(&device->dev);\n\tif (!priv->input)\n\t\treturn -ENOMEM;\n\n\tsnprintf(priv->phys, sizeof(priv->phys), \"%s/input0\",\n\t\t acpi_device_hid(device));\n\n\tpriv->input->name = acpi_device_name(device);\n\tpriv->input->phys = priv->phys;\n\tpriv->input->id.bustype = BUS_HOST;\n\n\tdmi_check_system(fujitsu_laptop_dmi_table);\n\tret = sparse_keymap_setup(priv->input, keymap, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\treturn input_register_device(priv->input);\n}\n\nstatic int fujitsu_laptop_platform_add(struct acpi_device *device)\n{\n\tstruct fujitsu_laptop *priv = acpi_driver_data(device);\n\tint ret;\n\n\tpriv->pf_device = platform_device_alloc(\"fujitsu-laptop\", PLATFORM_DEVID_NONE);\n\tif (!priv->pf_device)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(priv->pf_device, priv);\n\n\tret = platform_device_add(priv->pf_device);\n\tif (ret)\n\t\tgoto err_put_platform_device;\n\n\tret = sysfs_create_group(&priv->pf_device->dev.kobj,\n\t\t\t\t &fujitsu_pf_attribute_group);\n\tif (ret)\n\t\tgoto err_del_platform_device;\n\n\treturn 0;\n\nerr_del_platform_device:\n\tplatform_device_del(priv->pf_device);\nerr_put_platform_device:\n\tplatform_device_put(priv->pf_device);\n\n\treturn ret;\n}\n\nstatic void fujitsu_laptop_platform_remove(struct acpi_device *device)\n{\n\tstruct fujitsu_laptop *priv = acpi_driver_data(device);\n\n\tsysfs_remove_group(&priv->pf_device->dev.kobj,\n\t\t\t   &fujitsu_pf_attribute_group);\n\tplatform_device_unregister(priv->pf_device);\n}\n\nstatic int logolamp_set(struct led_classdev *cdev,\n\t\t\tenum led_brightness brightness)\n{\n\tstruct acpi_device *device = to_acpi_device(cdev->dev->parent);\n\tint poweron = FUNC_LED_ON, always = FUNC_LED_ON;\n\tint ret;\n\n\tif (brightness < LED_HALF)\n\t\tpoweron = FUNC_LED_OFF;\n\n\tif (brightness < LED_FULL)\n\t\talways = FUNC_LED_OFF;\n\n\tret = call_fext_func(device, FUNC_LEDS, 0x1, LOGOLAMP_POWERON, poweron);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn call_fext_func(device, FUNC_LEDS, 0x1, LOGOLAMP_ALWAYS, always);\n}\n\nstatic enum led_brightness logolamp_get(struct led_classdev *cdev)\n{\n\tstruct acpi_device *device = to_acpi_device(cdev->dev->parent);\n\tint ret;\n\n\tret = call_fext_func(device, FUNC_LEDS, 0x2, LOGOLAMP_ALWAYS, 0x0);\n\tif (ret == FUNC_LED_ON)\n\t\treturn LED_FULL;\n\n\tret = call_fext_func(device, FUNC_LEDS, 0x2, LOGOLAMP_POWERON, 0x0);\n\tif (ret == FUNC_LED_ON)\n\t\treturn LED_HALF;\n\n\treturn LED_OFF;\n}\n\nstatic int kblamps_set(struct led_classdev *cdev,\n\t\t       enum led_brightness brightness)\n{\n\tstruct acpi_device *device = to_acpi_device(cdev->dev->parent);\n\n\tif (brightness >= LED_FULL)\n\t\treturn call_fext_func(device, FUNC_LEDS, 0x1, KEYBOARD_LAMPS,\n\t\t\t\t      FUNC_LED_ON);\n\telse\n\t\treturn call_fext_func(device, FUNC_LEDS, 0x1, KEYBOARD_LAMPS,\n\t\t\t\t      FUNC_LED_OFF);\n}\n\nstatic enum led_brightness kblamps_get(struct led_classdev *cdev)\n{\n\tstruct acpi_device *device = to_acpi_device(cdev->dev->parent);\n\tenum led_brightness brightness = LED_OFF;\n\n\tif (call_fext_func(device,\n\t\t\t   FUNC_LEDS, 0x2, KEYBOARD_LAMPS, 0x0) == FUNC_LED_ON)\n\t\tbrightness = LED_FULL;\n\n\treturn brightness;\n}\n\nstatic int radio_led_set(struct led_classdev *cdev,\n\t\t\t enum led_brightness brightness)\n{\n\tstruct acpi_device *device = to_acpi_device(cdev->dev->parent);\n\n\tif (brightness >= LED_FULL)\n\t\treturn call_fext_func(device, FUNC_FLAGS, 0x5, RADIO_LED_ON,\n\t\t\t\t      RADIO_LED_ON);\n\telse\n\t\treturn call_fext_func(device, FUNC_FLAGS, 0x5, RADIO_LED_ON,\n\t\t\t\t      0x0);\n}\n\nstatic enum led_brightness radio_led_get(struct led_classdev *cdev)\n{\n\tstruct acpi_device *device = to_acpi_device(cdev->dev->parent);\n\tenum led_brightness brightness = LED_OFF;\n\n\tif (call_fext_func(device, FUNC_FLAGS, 0x4, 0x0, 0x0) & RADIO_LED_ON)\n\t\tbrightness = LED_FULL;\n\n\treturn brightness;\n}\n\nstatic int eco_led_set(struct led_classdev *cdev,\n\t\t       enum led_brightness brightness)\n{\n\tstruct acpi_device *device = to_acpi_device(cdev->dev->parent);\n\tint curr;\n\n\tcurr = call_fext_func(device, FUNC_LEDS, 0x2, ECO_LED, 0x0);\n\tif (brightness >= LED_FULL)\n\t\treturn call_fext_func(device, FUNC_LEDS, 0x1, ECO_LED,\n\t\t\t\t      curr | ECO_LED_ON);\n\telse\n\t\treturn call_fext_func(device, FUNC_LEDS, 0x1, ECO_LED,\n\t\t\t\t      curr & ~ECO_LED_ON);\n}\n\nstatic enum led_brightness eco_led_get(struct led_classdev *cdev)\n{\n\tstruct acpi_device *device = to_acpi_device(cdev->dev->parent);\n\tenum led_brightness brightness = LED_OFF;\n\n\tif (call_fext_func(device, FUNC_LEDS, 0x2, ECO_LED, 0x0) & ECO_LED_ON)\n\t\tbrightness = LED_FULL;\n\n\treturn brightness;\n}\n\nstatic int acpi_fujitsu_laptop_leds_register(struct acpi_device *device)\n{\n\tstruct fujitsu_laptop *priv = acpi_driver_data(device);\n\tstruct led_classdev *led;\n\tint ret;\n\n\tif (call_fext_func(device,\n\t\t\t   FUNC_LEDS, 0x0, 0x0, 0x0) & LOGOLAMP_POWERON) {\n\t\tled = devm_kzalloc(&device->dev, sizeof(*led), GFP_KERNEL);\n\t\tif (!led)\n\t\t\treturn -ENOMEM;\n\n\t\tled->name = \"fujitsu::logolamp\";\n\t\tled->brightness_set_blocking = logolamp_set;\n\t\tled->brightness_get = logolamp_get;\n\t\tret = devm_led_classdev_register(&device->dev, led);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif ((call_fext_func(device,\n\t\t\t    FUNC_LEDS, 0x0, 0x0, 0x0) & KEYBOARD_LAMPS) &&\n\t    (call_fext_func(device, FUNC_BUTTONS, 0x0, 0x0, 0x0) == 0x0)) {\n\t\tled = devm_kzalloc(&device->dev, sizeof(*led), GFP_KERNEL);\n\t\tif (!led)\n\t\t\treturn -ENOMEM;\n\n\t\tled->name = \"fujitsu::kblamps\";\n\t\tled->brightness_set_blocking = kblamps_set;\n\t\tled->brightness_get = kblamps_get;\n\t\tret = devm_led_classdev_register(&device->dev, led);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tif (priv->flags_supported & BIT(17)) {\n\t\tled = devm_kzalloc(&device->dev, sizeof(*led), GFP_KERNEL);\n\t\tif (!led)\n\t\t\treturn -ENOMEM;\n\n\t\tled->name = \"fujitsu::radio_led\";\n\t\tled->brightness_set_blocking = radio_led_set;\n\t\tled->brightness_get = radio_led_get;\n\t\tled->default_trigger = \"rfkill-any\";\n\t\tret = devm_led_classdev_register(&device->dev, led);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tif ((call_fext_func(device, FUNC_LEDS, 0x0, 0x0, 0x0) & BIT(14)) &&\n\t    (call_fext_func(device,\n\t\t\t    FUNC_LEDS, 0x2, ECO_LED, 0x0) != UNSUPPORTED_CMD)) {\n\t\tled = devm_kzalloc(&device->dev, sizeof(*led), GFP_KERNEL);\n\t\tif (!led)\n\t\t\treturn -ENOMEM;\n\n\t\tled->name = \"fujitsu::eco_led\";\n\t\tled->brightness_set_blocking = eco_led_set;\n\t\tled->brightness_get = eco_led_get;\n\t\tret = devm_led_classdev_register(&device->dev, led);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int acpi_fujitsu_laptop_add(struct acpi_device *device)\n{\n\tstruct fujitsu_laptop *priv;\n\tint ret, i = 0;\n\n\tpriv = devm_kzalloc(&device->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tWARN_ONCE(fext, \"More than one FUJ02E3 ACPI device was found.  Driver may not work as intended.\");\n\tfext = device;\n\n\tstrcpy(acpi_device_name(device), ACPI_FUJITSU_LAPTOP_DEVICE_NAME);\n\tstrcpy(acpi_device_class(device), ACPI_FUJITSU_CLASS);\n\tdevice->driver_data = priv;\n\n\t \n\tspin_lock_init(&priv->fifo_lock);\n\tret = kfifo_alloc(&priv->fifo, RINGBUFFERSIZE * sizeof(int),\n\t\t\t  GFP_KERNEL);\n\tif (ret)\n\t\treturn ret;\n\n\tpr_info(\"ACPI: %s [%s]\\n\",\n\t\tacpi_device_name(device), acpi_device_bid(device));\n\n\twhile (call_fext_func(device, FUNC_BUTTONS, 0x1, 0x0, 0x0) != 0 &&\n\t       i++ < MAX_HOTKEY_RINGBUFFER_SIZE)\n\t\t;  \n\tacpi_handle_debug(device->handle, \"Discarded %i ringbuffer entries\\n\",\n\t\t\t  i);\n\n\tpriv->flags_supported = call_fext_func(device, FUNC_FLAGS, 0x0, 0x0,\n\t\t\t\t\t       0x0);\n\n\t \n\tif (priv->flags_supported == UNSUPPORTED_CMD)\n\t\tpriv->flags_supported = 0;\n\n\tif (priv->flags_supported)\n\t\tpriv->flags_state = call_fext_func(device, FUNC_FLAGS, 0x4, 0x0,\n\t\t\t\t\t\t   0x0);\n\n\t \n\tacpi_handle_info(device->handle, \"BTNI: [0x%x]\\n\",\n\t\t\t call_fext_func(device, FUNC_BUTTONS, 0x0, 0x0, 0x0));\n\n\t \n\tif (fujitsu_bl && fujitsu_bl->bl_device &&\n\t    acpi_video_get_backlight_type() == acpi_backlight_vendor) {\n\t\tif (call_fext_func(fext, FUNC_BACKLIGHT, 0x2,\n\t\t\t\t   BACKLIGHT_PARAM_POWER, 0x0) == BACKLIGHT_OFF)\n\t\t\tfujitsu_bl->bl_device->props.power = FB_BLANK_POWERDOWN;\n\t\telse\n\t\t\tfujitsu_bl->bl_device->props.power = FB_BLANK_UNBLANK;\n\t}\n\n\tret = acpi_fujitsu_laptop_input_setup(device);\n\tif (ret)\n\t\tgoto err_free_fifo;\n\n\tret = acpi_fujitsu_laptop_leds_register(device);\n\tif (ret)\n\t\tgoto err_free_fifo;\n\n\tret = fujitsu_laptop_platform_add(device);\n\tif (ret)\n\t\tgoto err_free_fifo;\n\n\treturn 0;\n\nerr_free_fifo:\n\tkfifo_free(&priv->fifo);\n\n\treturn ret;\n}\n\nstatic void acpi_fujitsu_laptop_remove(struct acpi_device *device)\n{\n\tstruct fujitsu_laptop *priv = acpi_driver_data(device);\n\n\tfujitsu_laptop_platform_remove(device);\n\n\tkfifo_free(&priv->fifo);\n}\n\nstatic void acpi_fujitsu_laptop_press(struct acpi_device *device, int scancode)\n{\n\tstruct fujitsu_laptop *priv = acpi_driver_data(device);\n\tint ret;\n\n\tret = kfifo_in_locked(&priv->fifo, (unsigned char *)&scancode,\n\t\t\t      sizeof(scancode), &priv->fifo_lock);\n\tif (ret != sizeof(scancode)) {\n\t\tdev_info(&priv->input->dev, \"Could not push scancode [0x%x]\\n\",\n\t\t\t scancode);\n\t\treturn;\n\t}\n\tsparse_keymap_report_event(priv->input, scancode, 1, false);\n\tdev_dbg(&priv->input->dev, \"Push scancode into ringbuffer [0x%x]\\n\",\n\t\tscancode);\n}\n\nstatic void acpi_fujitsu_laptop_release(struct acpi_device *device)\n{\n\tstruct fujitsu_laptop *priv = acpi_driver_data(device);\n\tint scancode, ret;\n\n\twhile (true) {\n\t\tret = kfifo_out_locked(&priv->fifo, (unsigned char *)&scancode,\n\t\t\t\t       sizeof(scancode), &priv->fifo_lock);\n\t\tif (ret != sizeof(scancode))\n\t\t\treturn;\n\t\tsparse_keymap_report_event(priv->input, scancode, 0, false);\n\t\tdev_dbg(&priv->input->dev,\n\t\t\t\"Pop scancode from ringbuffer [0x%x]\\n\", scancode);\n\t}\n}\n\nstatic void acpi_fujitsu_laptop_notify(struct acpi_device *device, u32 event)\n{\n\tstruct fujitsu_laptop *priv = acpi_driver_data(device);\n\tunsigned long flags;\n\tint scancode, i = 0;\n\tunsigned int irb;\n\n\tif (event != ACPI_FUJITSU_NOTIFY_CODE) {\n\t\tacpi_handle_info(device->handle, \"Unsupported event [0x%x]\\n\",\n\t\t\t\t event);\n\t\tsparse_keymap_report_event(priv->input, -1, 1, true);\n\t\treturn;\n\t}\n\n\tif (priv->flags_supported)\n\t\tpriv->flags_state = call_fext_func(device, FUNC_FLAGS, 0x4, 0x0,\n\t\t\t\t\t\t   0x0);\n\n\twhile ((irb = call_fext_func(device,\n\t\t\t\t     FUNC_BUTTONS, 0x1, 0x0, 0x0)) != 0 &&\n\t       i++ < MAX_HOTKEY_RINGBUFFER_SIZE) {\n\t\tscancode = irb & 0x4ff;\n\t\tif (sparse_keymap_entry_from_scancode(priv->input, scancode))\n\t\t\tacpi_fujitsu_laptop_press(device, scancode);\n\t\telse if (scancode == 0)\n\t\t\tacpi_fujitsu_laptop_release(device);\n\t\telse\n\t\t\tacpi_handle_info(device->handle,\n\t\t\t\t\t \"Unknown GIRB result [%x]\\n\", irb);\n\t}\n\n\t \n\tif (priv->flags_supported & (FLAG_SOFTKEYS)) {\n\t\tflags = call_fext_func(device, FUNC_FLAGS, 0x1, 0x0, 0x0);\n\t\tflags &= (FLAG_SOFTKEYS);\n\t\tfor_each_set_bit(i, &flags, BITS_PER_LONG)\n\t\t\tsparse_keymap_report_event(priv->input, BIT(i), 1, true);\n\t}\n}\n\n \n\nstatic const struct acpi_device_id fujitsu_bl_device_ids[] = {\n\t{ACPI_FUJITSU_BL_HID, 0},\n\t{\"\", 0},\n};\n\nstatic struct acpi_driver acpi_fujitsu_bl_driver = {\n\t.name = ACPI_FUJITSU_BL_DRIVER_NAME,\n\t.class = ACPI_FUJITSU_CLASS,\n\t.ids = fujitsu_bl_device_ids,\n\t.ops = {\n\t\t.add = acpi_fujitsu_bl_add,\n\t\t.notify = acpi_fujitsu_bl_notify,\n\t\t},\n};\n\nstatic const struct acpi_device_id fujitsu_laptop_device_ids[] = {\n\t{ACPI_FUJITSU_LAPTOP_HID, 0},\n\t{\"\", 0},\n};\n\nstatic struct acpi_driver acpi_fujitsu_laptop_driver = {\n\t.name = ACPI_FUJITSU_LAPTOP_DRIVER_NAME,\n\t.class = ACPI_FUJITSU_CLASS,\n\t.ids = fujitsu_laptop_device_ids,\n\t.ops = {\n\t\t.add = acpi_fujitsu_laptop_add,\n\t\t.remove = acpi_fujitsu_laptop_remove,\n\t\t.notify = acpi_fujitsu_laptop_notify,\n\t\t},\n};\n\nstatic const struct acpi_device_id fujitsu_ids[] __used = {\n\t{ACPI_FUJITSU_BL_HID, 0},\n\t{ACPI_FUJITSU_LAPTOP_HID, 0},\n\t{\"\", 0}\n};\nMODULE_DEVICE_TABLE(acpi, fujitsu_ids);\n\nstatic int __init fujitsu_init(void)\n{\n\tint ret;\n\n\tret = acpi_bus_register_driver(&acpi_fujitsu_bl_driver);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\n\tret = platform_driver_register(&fujitsu_pf_driver);\n\tif (ret)\n\t\tgoto err_unregister_acpi;\n\n\t \n\n\tret = acpi_bus_register_driver(&acpi_fujitsu_laptop_driver);\n\tif (ret)\n\t\tgoto err_unregister_platform_driver;\n\n\tpr_info(\"driver \" FUJITSU_DRIVER_VERSION \" successfully loaded\\n\");\n\n\treturn 0;\n\nerr_unregister_platform_driver:\n\tplatform_driver_unregister(&fujitsu_pf_driver);\nerr_unregister_acpi:\n\tacpi_bus_unregister_driver(&acpi_fujitsu_bl_driver);\n\n\treturn ret;\n}\n\nstatic void __exit fujitsu_cleanup(void)\n{\n\tacpi_bus_unregister_driver(&acpi_fujitsu_laptop_driver);\n\n\tplatform_driver_unregister(&fujitsu_pf_driver);\n\n\tacpi_bus_unregister_driver(&acpi_fujitsu_bl_driver);\n\n\tpr_info(\"driver unloaded\\n\");\n}\n\nmodule_init(fujitsu_init);\nmodule_exit(fujitsu_cleanup);\n\nmodule_param(use_alt_lcd_levels, int, 0644);\nMODULE_PARM_DESC(use_alt_lcd_levels, \"Interface used for setting LCD brightness level (-1 = auto, 0 = force SBLL, 1 = force SBL2)\");\nmodule_param(disable_brightness_adjust, bool, 0644);\nMODULE_PARM_DESC(disable_brightness_adjust, \"Disable LCD brightness adjustment\");\n\nMODULE_AUTHOR(\"Jonathan Woithe, Peter Gruber, Tony Vroon\");\nMODULE_DESCRIPTION(\"Fujitsu laptop extras support\");\nMODULE_VERSION(FUJITSU_DRIVER_VERSION);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}