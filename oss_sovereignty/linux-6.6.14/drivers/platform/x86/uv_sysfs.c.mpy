{
  "module_name": "uv_sysfs.c",
  "hash_id": "227ca1b35adc050b8f40adef7635da661152901feca792847bd9a06c3181d4f9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/x86/uv_sysfs.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/device.h>\n#include <linux/slab.h>\n#include <linux/kobject.h>\n#include <asm/uv/bios.h>\n#include <asm/uv/uv.h>\n#include <asm/uv/uv_hub.h>\n#include <asm/uv/uv_geo.h>\n\n#define INVALID_CNODE -1\n\nstruct kobject *sgi_uv_kobj;\nstatic struct kset *uv_pcibus_kset;\nstatic struct kset *uv_hubs_kset;\nstatic struct uv_bios_hub_info *hub_buf;\nstatic struct uv_bios_port_info **port_buf;\nstatic struct uv_hub **uv_hubs;\nstatic struct uv_pci_top_obj **uv_pci_objs;\nstatic int num_pci_lines;\nstatic int num_cnodes;\nstatic int *prev_obj_to_cnode;\nstatic int uv_bios_obj_cnt;\nstatic signed short uv_master_nasid = -1;\nstatic void *uv_biosheap;\n\nstatic const char *uv_type_string(void)\n{\n\tif (is_uv5_hub())\n\t\treturn \"9.0\";\n\telse if (is_uv4a_hub())\n\t\treturn \"7.1\";\n\telse if (is_uv4_hub())\n\t\treturn \"7.0\";\n\telse if (is_uv3_hub())\n\t\treturn \"5.0\";\n\telse if (is_uv2_hub())\n\t\treturn \"3.0\";\n\telse if (uv_get_hubless_system())\n\t\treturn \"0.1\";\n\telse\n\t\treturn \"unknown\";\n}\n\nstatic int ordinal_to_nasid(int ordinal)\n{\n\tif (ordinal < num_cnodes && ordinal >= 0)\n\t\treturn UV_PNODE_TO_NASID(uv_blade_to_pnode(ordinal));\n\telse\n\t\treturn -1;\n}\n\nstatic union geoid_u cnode_to_geoid(int cnode)\n{\n\tunion geoid_u geoid;\n\n\tuv_bios_get_geoinfo(ordinal_to_nasid(cnode), (u64)sizeof(union geoid_u), (u64 *)&geoid);\n\treturn geoid;\n}\n\nstatic int location_to_bpos(char *location, int *rack, int *slot, int *blade)\n{\n\tchar type, r, b, h;\n\tint idb, idh;\n\n\tif (sscanf(location, \"%c%03d%c%02d%c%2d%c%d\",\n\t\t\t &r, rack, &type, slot, &b, &idb, &h, &idh) != 8)\n\t\treturn -1;\n\t*blade = idb * 2 + idh;\n\n\treturn 0;\n}\n\nstatic int cache_obj_to_cnode(struct uv_bios_hub_info *obj)\n{\n\tint cnode;\n\tunion geoid_u geoid;\n\tint obj_rack, obj_slot, obj_blade;\n\tint rack, slot, blade;\n\n\tif (!obj->f.fields.this_part && !obj->f.fields.is_shared)\n\t\treturn 0;\n\n\tif (location_to_bpos(obj->location, &obj_rack, &obj_slot, &obj_blade))\n\t\treturn -1;\n\n\tfor (cnode = 0; cnode < num_cnodes; cnode++) {\n\t\tgeoid = cnode_to_geoid(cnode);\n\t\track = geo_rack(geoid);\n\t\tslot = geo_slot(geoid);\n\t\tblade = geo_blade(geoid);\n\t\tif (obj_rack == rack && obj_slot == slot && obj_blade == blade)\n\t\t\tprev_obj_to_cnode[obj->id] = cnode;\n\t}\n\n\treturn 0;\n}\n\nstatic int get_obj_to_cnode(int obj_id)\n{\n\treturn prev_obj_to_cnode[obj_id];\n}\n\nstruct uv_hub {\n\tstruct kobject kobj;\n\tstruct uv_bios_hub_info *hub_info;\n\tstruct uv_port **ports;\n};\n\n#define to_uv_hub(kobj_ptr) container_of(kobj_ptr, struct uv_hub, kobj)\n\nstatic ssize_t hub_name_show(struct uv_bios_hub_info *hub_info, char *buf)\n{\n\treturn sysfs_emit(buf, \"%s\\n\", hub_info->name);\n}\n\nstatic ssize_t hub_location_show(struct uv_bios_hub_info *hub_info, char *buf)\n{\n\treturn sysfs_emit(buf, \"%s\\n\", hub_info->location);\n}\n\nstatic ssize_t hub_partition_show(struct uv_bios_hub_info *hub_info, char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", hub_info->f.fields.this_part);\n}\n\nstatic ssize_t hub_shared_show(struct uv_bios_hub_info *hub_info, char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", hub_info->f.fields.is_shared);\n}\nstatic ssize_t hub_nasid_show(struct uv_bios_hub_info *hub_info, char *buf)\n{\n\tint cnode = get_obj_to_cnode(hub_info->id);\n\n\treturn sprintf(buf, \"%d\\n\", ordinal_to_nasid(cnode));\n}\nstatic ssize_t hub_cnode_show(struct uv_bios_hub_info *hub_info, char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", get_obj_to_cnode(hub_info->id));\n}\n\nstruct hub_sysfs_entry {\n\tstruct attribute attr;\n\tssize_t (*show)(struct uv_bios_hub_info *hub_info, char *buf);\n\tssize_t (*store)(struct uv_bios_hub_info *hub_info, const char *buf, size_t sz);\n};\n\nstatic struct hub_sysfs_entry name_attribute =\n\t__ATTR(name, 0444, hub_name_show, NULL);\nstatic struct hub_sysfs_entry location_attribute =\n\t__ATTR(location, 0444, hub_location_show, NULL);\nstatic struct hub_sysfs_entry partition_attribute =\n\t__ATTR(this_partition, 0444, hub_partition_show, NULL);\nstatic struct hub_sysfs_entry shared_attribute =\n\t__ATTR(shared, 0444, hub_shared_show, NULL);\nstatic struct hub_sysfs_entry nasid_attribute =\n\t__ATTR(nasid, 0444, hub_nasid_show, NULL);\nstatic struct hub_sysfs_entry cnode_attribute =\n\t__ATTR(cnode, 0444, hub_cnode_show, NULL);\n\nstatic struct attribute *uv_hub_attrs[] = {\n\t&name_attribute.attr,\n\t&location_attribute.attr,\n\t&partition_attribute.attr,\n\t&shared_attribute.attr,\n\t&nasid_attribute.attr,\n\t&cnode_attribute.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(uv_hub);\n\nstatic void hub_release(struct kobject *kobj)\n{\n\tstruct uv_hub *hub = to_uv_hub(kobj);\n\n\tkfree(hub);\n}\n\nstatic ssize_t hub_type_show(struct kobject *kobj, struct attribute *attr,\n\t\t\t\tchar *buf)\n{\n\tstruct uv_hub *hub = to_uv_hub(kobj);\n\tstruct uv_bios_hub_info *bios_hub_info = hub->hub_info;\n\tstruct hub_sysfs_entry *entry;\n\n\tentry = container_of(attr, struct hub_sysfs_entry, attr);\n\n\tif (!entry->show)\n\t\treturn -EIO;\n\n\treturn entry->show(bios_hub_info, buf);\n}\n\nstatic const struct sysfs_ops hub_sysfs_ops = {\n\t.show = hub_type_show,\n};\n\nstatic const struct kobj_type hub_attr_type = {\n\t.release\t= hub_release,\n\t.sysfs_ops\t= &hub_sysfs_ops,\n\t.default_groups\t= uv_hub_groups,\n};\n\nstatic int uv_hubs_init(void)\n{\n\ts64 biosr;\n\tu64 sz;\n\tint i, ret;\n\n\tprev_obj_to_cnode = kmalloc_array(uv_bios_obj_cnt, sizeof(*prev_obj_to_cnode),\n\t\t\t\t\t GFP_KERNEL);\n\tif (!prev_obj_to_cnode)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < uv_bios_obj_cnt; i++)\n\t\tprev_obj_to_cnode[i] = INVALID_CNODE;\n\n\tuv_hubs_kset = kset_create_and_add(\"hubs\", NULL, sgi_uv_kobj);\n\tif (!uv_hubs_kset) {\n\t\tret = -ENOMEM;\n\t\tgoto err_hubs_kset;\n\t}\n\tsz = uv_bios_obj_cnt * sizeof(*hub_buf);\n\thub_buf = kzalloc(sz, GFP_KERNEL);\n\tif (!hub_buf) {\n\t\tret = -ENOMEM;\n\t\tgoto err_hub_buf;\n\t}\n\n\tbiosr = uv_bios_enum_objs((u64)uv_master_nasid, sz, (u64 *)hub_buf);\n\tif (biosr) {\n\t\tret = -EINVAL;\n\t\tgoto err_enum_objs;\n\t}\n\n\tuv_hubs = kcalloc(uv_bios_obj_cnt, sizeof(*uv_hubs), GFP_KERNEL);\n\tif (!uv_hubs) {\n\t\tret = -ENOMEM;\n\t\tgoto err_enum_objs;\n\t}\n\n\tfor (i = 0; i < uv_bios_obj_cnt; i++) {\n\t\tuv_hubs[i] = kzalloc(sizeof(*uv_hubs[i]), GFP_KERNEL);\n\t\tif (!uv_hubs[i]) {\n\t\t\ti--;\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_hubs;\n\t\t}\n\n\t\tuv_hubs[i]->hub_info = &hub_buf[i];\n\t\tcache_obj_to_cnode(uv_hubs[i]->hub_info);\n\n\t\tuv_hubs[i]->kobj.kset = uv_hubs_kset;\n\n\t\tret = kobject_init_and_add(&uv_hubs[i]->kobj, &hub_attr_type,\n\t\t\t\t\t  NULL, \"hub_%u\", hub_buf[i].id);\n\t\tif (ret)\n\t\t\tgoto err_hubs;\n\t\tkobject_uevent(&uv_hubs[i]->kobj, KOBJ_ADD);\n\t}\n\treturn 0;\n\nerr_hubs:\n\tfor (; i >= 0; i--)\n\t\tkobject_put(&uv_hubs[i]->kobj);\n\tkfree(uv_hubs);\nerr_enum_objs:\n\tkfree(hub_buf);\nerr_hub_buf:\n\tkset_unregister(uv_hubs_kset);\nerr_hubs_kset:\n\tkfree(prev_obj_to_cnode);\n\treturn ret;\n\n}\n\nstatic void uv_hubs_exit(void)\n{\n\tint i;\n\n\tfor (i = 0; i < uv_bios_obj_cnt; i++)\n\t\tkobject_put(&uv_hubs[i]->kobj);\n\n\tkfree(uv_hubs);\n\tkfree(hub_buf);\n\tkset_unregister(uv_hubs_kset);\n\tkfree(prev_obj_to_cnode);\n}\n\nstruct uv_port {\n\tstruct kobject kobj;\n\tstruct uv_bios_port_info *port_info;\n};\n\n#define to_uv_port(kobj_ptr) container_of(kobj_ptr, struct uv_port, kobj)\n\nstatic ssize_t uv_port_conn_hub_show(struct uv_bios_port_info *port, char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", port->conn_id);\n}\n\nstatic ssize_t uv_port_conn_port_show(struct uv_bios_port_info *port, char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", port->conn_port);\n}\n\nstruct uv_port_sysfs_entry {\n\tstruct attribute attr;\n\tssize_t (*show)(struct uv_bios_port_info *port_info, char *buf);\n\tssize_t (*store)(struct uv_bios_port_info *port_info, const char *buf, size_t size);\n};\n\nstatic struct uv_port_sysfs_entry uv_port_conn_hub_attribute =\n\t__ATTR(conn_hub, 0444, uv_port_conn_hub_show, NULL);\nstatic struct uv_port_sysfs_entry uv_port_conn_port_attribute =\n\t__ATTR(conn_port, 0444, uv_port_conn_port_show, NULL);\n\nstatic struct attribute *uv_port_attrs[] = {\n\t&uv_port_conn_hub_attribute.attr,\n\t&uv_port_conn_port_attribute.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(uv_port);\n\nstatic void uv_port_release(struct kobject *kobj)\n{\n\tstruct uv_port *port = to_uv_port(kobj);\n\n\tkfree(port);\n}\n\nstatic ssize_t uv_port_type_show(struct kobject *kobj, struct attribute *attr,\n\t\t\t\tchar *buf)\n{\n\tstruct uv_port *port = to_uv_port(kobj);\n\tstruct uv_bios_port_info *port_info = port->port_info;\n\tstruct uv_port_sysfs_entry *entry;\n\n\tentry = container_of(attr, struct uv_port_sysfs_entry, attr);\n\n\tif (!entry->show)\n\t\treturn -EIO;\n\n\treturn entry->show(port_info, buf);\n}\n\nstatic const struct sysfs_ops uv_port_sysfs_ops = {\n\t.show = uv_port_type_show,\n};\n\nstatic const struct kobj_type uv_port_attr_type = {\n\t.release\t= uv_port_release,\n\t.sysfs_ops\t= &uv_port_sysfs_ops,\n\t.default_groups\t= uv_port_groups,\n};\n\nstatic int uv_ports_init(void)\n{\n\ts64 biosr;\n\tint j = 0, k = 0, ret, sz;\n\n\tport_buf = kcalloc(uv_bios_obj_cnt, sizeof(*port_buf), GFP_KERNEL);\n\tif (!port_buf)\n\t\treturn -ENOMEM;\n\n\tfor (j = 0; j < uv_bios_obj_cnt; j++) {\n\t\tsz = hub_buf[j].ports * sizeof(*port_buf[j]);\n\t\tport_buf[j] = kzalloc(sz, GFP_KERNEL);\n\t\tif (!port_buf[j]) {\n\t\t\tret = -ENOMEM;\n\t\t\tj--;\n\t\t\tgoto err_port_info;\n\t\t}\n\t\tbiosr = uv_bios_enum_ports((u64)uv_master_nasid, (u64)hub_buf[j].id, sz,\n\t\t\t\t\t(u64 *)port_buf[j]);\n\t\tif (biosr) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_port_info;\n\t\t}\n\t}\n\tfor (j = 0; j < uv_bios_obj_cnt; j++) {\n\t\tuv_hubs[j]->ports = kcalloc(hub_buf[j].ports,\n\t\t\t\t\t   sizeof(*uv_hubs[j]->ports), GFP_KERNEL);\n\t\tif (!uv_hubs[j]->ports) {\n\t\t\tret = -ENOMEM;\n\t\t\tj--;\n\t\t\tgoto err_ports;\n\t\t}\n\t}\n\tfor (j = 0; j < uv_bios_obj_cnt; j++) {\n\t\tfor (k = 0; k < hub_buf[j].ports; k++) {\n\t\t\tuv_hubs[j]->ports[k] = kzalloc(sizeof(*uv_hubs[j]->ports[k]), GFP_KERNEL);\n\t\t\tif (!uv_hubs[j]->ports[k]) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tk--;\n\t\t\t\tgoto err_kobj_ports;\n\t\t\t}\n\t\t\tuv_hubs[j]->ports[k]->port_info = &port_buf[j][k];\n\t\t\tret = kobject_init_and_add(&uv_hubs[j]->ports[k]->kobj, &uv_port_attr_type,\n\t\t\t\t\t&uv_hubs[j]->kobj, \"port_%d\", port_buf[j][k].port);\n\t\t\tif (ret)\n\t\t\t\tgoto err_kobj_ports;\n\t\t\tkobject_uevent(&uv_hubs[j]->ports[k]->kobj, KOBJ_ADD);\n\t\t}\n\t}\n\treturn 0;\n\nerr_kobj_ports:\n\tfor (; j >= 0; j--) {\n\t\tfor (; k >= 0; k--)\n\t\t\tkobject_put(&uv_hubs[j]->ports[k]->kobj);\n\t\tif (j > 0)\n\t\t\tk = hub_buf[j-1].ports - 1;\n\t}\n\tj = uv_bios_obj_cnt - 1;\nerr_ports:\n\tfor (; j >= 0; j--)\n\t\tkfree(uv_hubs[j]->ports);\n\tj = uv_bios_obj_cnt - 1;\nerr_port_info:\n\tfor (; j >= 0; j--)\n\t\tkfree(port_buf[j]);\n\tkfree(port_buf);\n\treturn ret;\n}\n\nstatic void uv_ports_exit(void)\n{\n\tint j, k;\n\n\tfor (j = 0; j < uv_bios_obj_cnt; j++) {\n\t\tfor (k = hub_buf[j].ports - 1; k >= 0; k--)\n\t\t\tkobject_put(&uv_hubs[j]->ports[k]->kobj);\n\t}\n\tfor (j = 0; j < uv_bios_obj_cnt; j++) {\n\t\tkfree(uv_hubs[j]->ports);\n\t\tkfree(port_buf[j]);\n\t}\n\tkfree(port_buf);\n}\n\nstruct uv_pci_top_obj {\n\tstruct kobject kobj;\n\tchar *type;\n\tchar *location;\n\tint iio_stack;\n\tchar *ppb_addr;\n\tint slot;\n};\n\n#define to_uv_pci_top_obj(kobj_ptr) container_of(kobj_ptr, struct uv_pci_top_obj, kobj)\n\nstatic ssize_t uv_pci_type_show(struct uv_pci_top_obj *top_obj, char *buf)\n{\n\treturn sysfs_emit(buf, \"%s\\n\", top_obj->type);\n}\n\nstatic ssize_t uv_pci_location_show(struct uv_pci_top_obj *top_obj, char *buf)\n{\n\treturn sysfs_emit(buf, \"%s\\n\", top_obj->location);\n}\n\nstatic ssize_t uv_pci_iio_stack_show(struct uv_pci_top_obj *top_obj, char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", top_obj->iio_stack);\n}\n\nstatic ssize_t uv_pci_ppb_addr_show(struct uv_pci_top_obj *top_obj, char *buf)\n{\n\treturn sysfs_emit(buf, \"%s\\n\", top_obj->ppb_addr);\n}\n\nstatic ssize_t uv_pci_slot_show(struct uv_pci_top_obj *top_obj, char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", top_obj->slot);\n}\n\nstruct uv_pci_top_sysfs_entry {\n\tstruct attribute attr;\n\tssize_t (*show)(struct uv_pci_top_obj *top_obj, char *buf);\n\tssize_t (*store)(struct uv_pci_top_obj *top_obj, const char *buf, size_t size);\n};\n\nstatic struct uv_pci_top_sysfs_entry uv_pci_type_attribute =\n\t__ATTR(type, 0444, uv_pci_type_show, NULL);\nstatic struct uv_pci_top_sysfs_entry uv_pci_location_attribute =\n\t__ATTR(location, 0444, uv_pci_location_show, NULL);\nstatic struct uv_pci_top_sysfs_entry uv_pci_iio_stack_attribute =\n\t__ATTR(iio_stack, 0444, uv_pci_iio_stack_show, NULL);\nstatic struct uv_pci_top_sysfs_entry uv_pci_ppb_addr_attribute =\n\t__ATTR(ppb_addr, 0444, uv_pci_ppb_addr_show, NULL);\nstatic struct uv_pci_top_sysfs_entry uv_pci_slot_attribute =\n\t__ATTR(slot, 0444, uv_pci_slot_show, NULL);\n\nstatic void uv_pci_top_release(struct kobject *kobj)\n{\n\tstruct uv_pci_top_obj *top_obj = to_uv_pci_top_obj(kobj);\n\n\tkfree(top_obj->type);\n\tkfree(top_obj->location);\n\tkfree(top_obj->ppb_addr);\n\tkfree(top_obj);\n}\n\nstatic ssize_t pci_top_type_show(struct kobject *kobj,\n\t\t\tstruct attribute *attr, char *buf)\n{\n\tstruct uv_pci_top_obj *top_obj = to_uv_pci_top_obj(kobj);\n\tstruct uv_pci_top_sysfs_entry *entry;\n\n\tentry = container_of(attr, struct uv_pci_top_sysfs_entry, attr);\n\n\tif (!entry->show)\n\t\treturn -EIO;\n\n\treturn entry->show(top_obj, buf);\n}\n\nstatic const struct sysfs_ops uv_pci_top_sysfs_ops = {\n\t.show = pci_top_type_show,\n};\n\nstatic const struct kobj_type uv_pci_top_attr_type = {\n\t.release\t= uv_pci_top_release,\n\t.sysfs_ops\t= &uv_pci_top_sysfs_ops,\n};\n\nstatic int init_pci_top_obj(struct uv_pci_top_obj *top_obj, char *line)\n{\n\tchar *start;\n\tchar type[11], location[14], ppb_addr[15];\n\tint str_cnt, ret;\n\tunsigned int tmp_match[2];\n\n\t\n\tif (strlen(line) < 36)\n\t\treturn -EINVAL;\n\n\t\n\tstr_cnt = sscanf(line, \"pcibus %4x:%2x\", &tmp_match[0], &tmp_match[1]);\n\tif (str_cnt < 2)\n\t\treturn -EINVAL;\n\n\t \n\tline[6] = '_';\n\n\t \n\tline[14] = '\\0';\n\n\t\n\tstart = &line[15];\n\n\ttop_obj->iio_stack = -1;\n\ttop_obj->slot = -1;\n\n\t \n\tif (start[0] == 'r') {\n\t\tstr_cnt = sscanf(start, \"%13s %10[^(] %*s %*s %d)\",\n\t\t\t\tlocation, type, &top_obj->iio_stack);\n\t\tif (str_cnt < 2)\n\t\t\treturn -EINVAL;\n\t\ttop_obj->type = kstrdup(type, GFP_KERNEL);\n\t\tif (!top_obj->type)\n\t\t\treturn -ENOMEM;\n\t\ttop_obj->location = kstrdup(location, GFP_KERNEL);\n\t\tif (!top_obj->location) {\n\t\t\tkfree(top_obj->type);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\t \n\telse if (start[0] == 'P') {\n\t\tstr_cnt = sscanf(start, \"%10s %*s %14s %*s %d)\",\n\t\t\t\ttype, ppb_addr, &top_obj->slot);\n\t\tif (str_cnt < 2)\n\t\t\treturn -EINVAL;\n\t\ttop_obj->type = kstrdup(type, GFP_KERNEL);\n\t\tif (!top_obj->type)\n\t\t\treturn -ENOMEM;\n\t\ttop_obj->ppb_addr = kstrdup(ppb_addr, GFP_KERNEL);\n\t\tif (!top_obj->ppb_addr) {\n\t\t\tkfree(top_obj->type);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t} else\n\t\treturn -EINVAL;\n\n\ttop_obj->kobj.kset = uv_pcibus_kset;\n\n\tret = kobject_init_and_add(&top_obj->kobj, &uv_pci_top_attr_type, NULL, \"%s\", line);\n\tif (ret)\n\t\tgoto err_add_sysfs;\n\n\tif (top_obj->type) {\n\t\tret = sysfs_create_file(&top_obj->kobj, &uv_pci_type_attribute.attr);\n\t\tif (ret)\n\t\t\tgoto err_add_sysfs;\n\t}\n\tif (top_obj->location) {\n\t\tret = sysfs_create_file(&top_obj->kobj, &uv_pci_location_attribute.attr);\n\t\tif (ret)\n\t\t\tgoto err_add_sysfs;\n\t}\n\tif (top_obj->iio_stack >= 0) {\n\t\tret = sysfs_create_file(&top_obj->kobj, &uv_pci_iio_stack_attribute.attr);\n\t\tif (ret)\n\t\t\tgoto err_add_sysfs;\n\t}\n\tif (top_obj->ppb_addr) {\n\t\tret = sysfs_create_file(&top_obj->kobj, &uv_pci_ppb_addr_attribute.attr);\n\t\tif (ret)\n\t\t\tgoto err_add_sysfs;\n\t}\n\tif (top_obj->slot >= 0) {\n\t\tret = sysfs_create_file(&top_obj->kobj, &uv_pci_slot_attribute.attr);\n\t\tif (ret)\n\t\t\tgoto err_add_sysfs;\n\t}\n\n\tkobject_uevent(&top_obj->kobj, KOBJ_ADD);\n\treturn 0;\n\nerr_add_sysfs:\n\tkobject_put(&top_obj->kobj);\n\treturn ret;\n}\n\nstatic int pci_topology_init(void)\n{\n\tchar *pci_top_str, *start, *found, *count;\n\tsize_t sz;\n\ts64 biosr;\n\tint l = 0, k = 0;\n\tint len, ret;\n\n\tuv_pcibus_kset = kset_create_and_add(\"pcibuses\", NULL, sgi_uv_kobj);\n\tif (!uv_pcibus_kset)\n\t\treturn -ENOMEM;\n\n\tfor (sz = PAGE_SIZE; sz < 16 * PAGE_SIZE; sz += PAGE_SIZE) {\n\t\tpci_top_str = kmalloc(sz, GFP_KERNEL);\n\t\tif (!pci_top_str) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_pci_top_str;\n\t\t}\n\t\tbiosr = uv_bios_get_pci_topology((u64)sz, (u64 *)pci_top_str);\n\t\tif (biosr == BIOS_STATUS_SUCCESS) {\n\t\t\tlen = strnlen(pci_top_str, sz);\n\t\t\tfor (count = pci_top_str; count < pci_top_str + len; count++) {\n\t\t\t\tif (*count == '\\n')\n\t\t\t\t\tl++;\n\t\t\t}\n\t\t\tnum_pci_lines = l;\n\n\t\t\tuv_pci_objs = kcalloc(num_pci_lines,\n\t\t\t\t\t     sizeof(*uv_pci_objs), GFP_KERNEL);\n\t\t\tif (!uv_pci_objs) {\n\t\t\t\tkfree(pci_top_str);\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto err_pci_top_str;\n\t\t\t}\n\t\t\tstart = pci_top_str;\n\t\t\twhile ((found = strsep(&start, \"\\n\")) != NULL) {\n\t\t\t\tuv_pci_objs[k] = kzalloc(sizeof(*uv_pci_objs[k]), GFP_KERNEL);\n\t\t\t\tif (!uv_pci_objs[k]) {\n\t\t\t\t\tret = -ENOMEM;\n\t\t\t\t\tgoto err_pci_obj;\n\t\t\t\t}\n\t\t\t\tret = init_pci_top_obj(uv_pci_objs[k], found);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto err_pci_obj;\n\t\t\t\tk++;\n\t\t\t\tif (k == num_pci_lines)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tkfree(pci_top_str);\n\t\tif (biosr == BIOS_STATUS_SUCCESS || biosr == BIOS_STATUS_UNIMPLEMENTED)\n\t\t\tbreak;\n\t}\n\n\treturn 0;\nerr_pci_obj:\n\tk--;\n\tfor (; k >= 0; k--)\n\t\tkobject_put(&uv_pci_objs[k]->kobj);\n\tkfree(uv_pci_objs);\n\tkfree(pci_top_str);\nerr_pci_top_str:\n\tkset_unregister(uv_pcibus_kset);\n\treturn ret;\n}\n\nstatic void pci_topology_exit(void)\n{\n\tint k;\n\n\tfor (k = 0; k < num_pci_lines; k++)\n\t\tkobject_put(&uv_pci_objs[k]->kobj);\n\tkset_unregister(uv_pcibus_kset);\n\tkfree(uv_pci_objs);\n}\n\nstatic ssize_t partition_id_show(struct kobject *kobj,\n\t\t\tstruct kobj_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%ld\\n\", sn_partition_id);\n}\n\nstatic ssize_t coherence_id_show(struct kobject *kobj,\n\t\t\tstruct kobj_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%ld\\n\", sn_coherency_id);\n}\n\nstatic ssize_t uv_type_show(struct kobject *kobj,\n\t\t\tstruct kobj_attribute *attr, char *buf)\n{\n\treturn sysfs_emit(buf, \"%s\\n\", uv_type_string());\n}\n\nstatic ssize_t uv_archtype_show(struct kobject *kobj,\n\t\t\tstruct kobj_attribute *attr, char *buf)\n{\n\treturn uv_get_archtype(buf, PAGE_SIZE);\n}\n\nstatic ssize_t uv_hub_type_show(struct kobject *kobj,\n\t\t\tstruct kobj_attribute *attr, char *buf)\n{\n\treturn sysfs_emit(buf, \"0x%x\\n\", uv_hub_type());\n}\n\nstatic ssize_t uv_hubless_show(struct kobject *kobj,\n\t\t\tstruct kobj_attribute *attr, char *buf)\n{\n\treturn sysfs_emit(buf, \"0x%x\\n\", uv_get_hubless_system());\n}\n\nstatic struct kobj_attribute partition_id_attr =\n\t__ATTR(partition_id, 0444, partition_id_show, NULL);\nstatic struct kobj_attribute coherence_id_attr =\n\t__ATTR(coherence_id, 0444, coherence_id_show, NULL);\nstatic struct kobj_attribute uv_type_attr =\n\t__ATTR(uv_type, 0444, uv_type_show, NULL);\nstatic struct kobj_attribute uv_archtype_attr =\n\t__ATTR(archtype, 0444, uv_archtype_show, NULL);\nstatic struct kobj_attribute uv_hub_type_attr =\n\t__ATTR(hub_type, 0444, uv_hub_type_show, NULL);\nstatic struct kobj_attribute uv_hubless_attr =\n\t__ATTR(hubless, 0444, uv_hubless_show, NULL);\n\nstatic struct attribute *base_attrs[] = {\n\t&partition_id_attr.attr,\n\t&coherence_id_attr.attr,\n\t&uv_type_attr.attr,\n\t&uv_archtype_attr.attr,\n\t&uv_hub_type_attr.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group base_attr_group = {\n\t.attrs = base_attrs\n};\n\nstatic int initial_bios_setup(void)\n{\n\tu64 v;\n\ts64 biosr;\n\n\tbiosr = uv_bios_get_master_nasid((u64)sizeof(uv_master_nasid), (u64 *)&uv_master_nasid);\n\tif (biosr)\n\t\treturn -EINVAL;\n\n\tbiosr = uv_bios_get_heapsize((u64)uv_master_nasid, (u64)sizeof(u64), &v);\n\tif (biosr)\n\t\treturn -EINVAL;\n\n\tuv_biosheap = vmalloc(v);\n\tif (!uv_biosheap)\n\t\treturn -ENOMEM;\n\n\tbiosr = uv_bios_install_heap((u64)uv_master_nasid, v, (u64 *)uv_biosheap);\n\tif (biosr) {\n\t\tvfree(uv_biosheap);\n\t\treturn -EINVAL;\n\t}\n\n\tbiosr = uv_bios_obj_count((u64)uv_master_nasid, sizeof(u64), &v);\n\tif (biosr) {\n\t\tvfree(uv_biosheap);\n\t\treturn -EINVAL;\n\t}\n\tuv_bios_obj_cnt = (int)v;\n\n\treturn 0;\n}\n\nstatic struct attribute *hubless_base_attrs[] = {\n\t&partition_id_attr.attr,\n\t&uv_type_attr.attr,\n\t&uv_archtype_attr.attr,\n\t&uv_hubless_attr.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group hubless_base_attr_group = {\n\t.attrs = hubless_base_attrs\n};\n\n\nstatic int __init uv_sysfs_hubless_init(void)\n{\n\tint ret;\n\n\tret = sysfs_create_group(sgi_uv_kobj, &hubless_base_attr_group);\n\tif (ret) {\n\t\tpr_warn(\"sysfs_create_group hubless_base_attr_group failed\\n\");\n\t\tkobject_put(sgi_uv_kobj);\n\t}\n\treturn ret;\n}\n\nstatic int __init uv_sysfs_init(void)\n{\n\tint ret = 0;\n\n\tif (!is_uv_system() && !uv_get_hubless_system())\n\t\treturn -ENODEV;\n\n\tnum_cnodes = uv_num_possible_blades();\n\n\tif (!sgi_uv_kobj)\n\t\tsgi_uv_kobj = kobject_create_and_add(\"sgi_uv\", firmware_kobj);\n\tif (!sgi_uv_kobj) {\n\t\tpr_warn(\"kobject_create_and_add sgi_uv failed\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (uv_get_hubless_system())\n\t\treturn uv_sysfs_hubless_init();\n\n\tret = sysfs_create_group(sgi_uv_kobj, &base_attr_group);\n\tif (ret) {\n\t\tpr_warn(\"sysfs_create_group base_attr_group failed\\n\");\n\t\tgoto err_create_group;\n\t}\n\n\tret = initial_bios_setup();\n\tif (ret)\n\t\tgoto err_bios_setup;\n\n\tret = uv_hubs_init();\n\tif (ret)\n\t\tgoto err_hubs_init;\n\n\tret = uv_ports_init();\n\tif (ret)\n\t\tgoto err_ports_init;\n\n\tret = pci_topology_init();\n\tif (ret)\n\t\tgoto err_pci_init;\n\n\treturn 0;\n\nerr_pci_init:\n\tuv_ports_exit();\nerr_ports_init:\n\tuv_hubs_exit();\nerr_hubs_init:\n\tvfree(uv_biosheap);\nerr_bios_setup:\n\tsysfs_remove_group(sgi_uv_kobj, &base_attr_group);\nerr_create_group:\n\tkobject_put(sgi_uv_kobj);\n\treturn ret;\n}\n\nstatic void __exit uv_sysfs_hubless_exit(void)\n{\n\tsysfs_remove_group(sgi_uv_kobj, &hubless_base_attr_group);\n\tkobject_put(sgi_uv_kobj);\n}\n\nstatic void __exit uv_sysfs_exit(void)\n{\n\tif (!is_uv_system()) {\n\t\tif (uv_get_hubless_system())\n\t\t\tuv_sysfs_hubless_exit();\n\t\treturn;\n\t}\n\n\tpci_topology_exit();\n\tuv_ports_exit();\n\tuv_hubs_exit();\n\tvfree(uv_biosheap);\n\tsysfs_remove_group(sgi_uv_kobj, &base_attr_group);\n\tkobject_put(sgi_uv_kobj);\n}\n\n#ifndef MODULE\ndevice_initcall(uv_sysfs_init);\n#else\nmodule_init(uv_sysfs_init);\n#endif\nmodule_exit(uv_sysfs_exit);\n\nMODULE_AUTHOR(\"Hewlett Packard Enterprise\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}