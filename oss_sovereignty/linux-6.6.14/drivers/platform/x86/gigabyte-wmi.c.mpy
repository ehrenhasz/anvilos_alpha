{
  "module_name": "gigabyte-wmi.c",
  "hash_id": "1fc66b9d9b8a07d4fa0d43bc366173cd1dda77b024f2355ebb2430f9eb9d3032",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/x86/gigabyte-wmi.c",
  "human_readable_source": "\n \n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/acpi.h>\n#include <linux/hwmon.h>\n#include <linux/module.h>\n#include <linux/wmi.h>\n\n#define GIGABYTE_WMI_GUID\t\"DEADBEEF-2001-0000-00A0-C90629100000\"\n#define NUM_TEMPERATURE_SENSORS\t6\n\nstatic u8 usable_sensors_mask;\n\nenum gigabyte_wmi_commandtype {\n\tGIGABYTE_WMI_BUILD_DATE_QUERY       =   0x1,\n\tGIGABYTE_WMI_MAINBOARD_TYPE_QUERY   =   0x2,\n\tGIGABYTE_WMI_FIRMWARE_VERSION_QUERY =   0x4,\n\tGIGABYTE_WMI_MAINBOARD_NAME_QUERY   =   0x5,\n\tGIGABYTE_WMI_TEMPERATURE_QUERY      = 0x125,\n};\n\nstruct gigabyte_wmi_args {\n\tu32 arg1;\n};\n\nstatic int gigabyte_wmi_perform_query(struct wmi_device *wdev,\n\t\t\t\t      enum gigabyte_wmi_commandtype command,\n\t\t\t\t      struct gigabyte_wmi_args *args, struct acpi_buffer *out)\n{\n\tconst struct acpi_buffer in = {\n\t\t.length = sizeof(*args),\n\t\t.pointer = args,\n\t};\n\n\tacpi_status ret = wmidev_evaluate_method(wdev, 0x0, command, &in, out);\n\n\tif (ACPI_FAILURE(ret))\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic int gigabyte_wmi_query_integer(struct wmi_device *wdev,\n\t\t\t\t      enum gigabyte_wmi_commandtype command,\n\t\t\t\t      struct gigabyte_wmi_args *args, u64 *res)\n{\n\tunion acpi_object *obj;\n\tstruct acpi_buffer result = { ACPI_ALLOCATE_BUFFER, NULL };\n\tint ret;\n\n\tret = gigabyte_wmi_perform_query(wdev, command, args, &result);\n\tif (ret)\n\t\treturn ret;\n\tobj = result.pointer;\n\tif (obj && obj->type == ACPI_TYPE_INTEGER)\n\t\t*res = obj->integer.value;\n\telse\n\t\tret = -EIO;\n\tkfree(result.pointer);\n\treturn ret;\n}\n\nstatic int gigabyte_wmi_temperature(struct wmi_device *wdev, u8 sensor, long *res)\n{\n\tstruct gigabyte_wmi_args args = {\n\t\t.arg1 = sensor,\n\t};\n\tu64 temp;\n\tacpi_status ret;\n\n\tret = gigabyte_wmi_query_integer(wdev, GIGABYTE_WMI_TEMPERATURE_QUERY, &args, &temp);\n\tif (ret == 0) {\n\t\tif (temp == 0)\n\t\t\treturn -ENODEV;\n\t\t*res = (s8)temp * 1000; \n\t}\n\treturn ret;\n}\n\nstatic int gigabyte_wmi_hwmon_read(struct device *dev, enum hwmon_sensor_types type,\n\t\t\t\t   u32 attr, int channel, long *val)\n{\n\tstruct wmi_device *wdev = dev_get_drvdata(dev);\n\n\treturn gigabyte_wmi_temperature(wdev, channel, val);\n}\n\nstatic umode_t gigabyte_wmi_hwmon_is_visible(const void *data, enum hwmon_sensor_types type,\n\t\t\t\t\t     u32 attr, int channel)\n{\n\treturn usable_sensors_mask & BIT(channel) ? 0444  : 0;\n}\n\nstatic const struct hwmon_channel_info * const gigabyte_wmi_hwmon_info[] = {\n\tHWMON_CHANNEL_INFO(temp,\n\t\t\t   HWMON_T_INPUT,\n\t\t\t   HWMON_T_INPUT,\n\t\t\t   HWMON_T_INPUT,\n\t\t\t   HWMON_T_INPUT,\n\t\t\t   HWMON_T_INPUT,\n\t\t\t   HWMON_T_INPUT),\n\tNULL\n};\n\nstatic const struct hwmon_ops gigabyte_wmi_hwmon_ops = {\n\t.read = gigabyte_wmi_hwmon_read,\n\t.is_visible = gigabyte_wmi_hwmon_is_visible,\n};\n\nstatic const struct hwmon_chip_info gigabyte_wmi_hwmon_chip_info = {\n\t.ops = &gigabyte_wmi_hwmon_ops,\n\t.info = gigabyte_wmi_hwmon_info,\n};\n\nstatic u8 gigabyte_wmi_detect_sensor_usability(struct wmi_device *wdev)\n{\n\tint i;\n\tlong temp;\n\tu8 r = 0;\n\n\tfor (i = 0; i < NUM_TEMPERATURE_SENSORS; i++) {\n\t\tif (!gigabyte_wmi_temperature(wdev, i, &temp))\n\t\t\tr |= BIT(i);\n\t}\n\treturn r;\n}\n\nstatic int gigabyte_wmi_probe(struct wmi_device *wdev, const void *context)\n{\n\tstruct device *hwmon_dev;\n\n\tusable_sensors_mask = gigabyte_wmi_detect_sensor_usability(wdev);\n\tif (!usable_sensors_mask) {\n\t\tdev_info(&wdev->dev, \"No temperature sensors usable\");\n\t\treturn -ENODEV;\n\t}\n\n\thwmon_dev = devm_hwmon_device_register_with_info(&wdev->dev, \"gigabyte_wmi\", wdev,\n\t\t\t\t\t\t\t &gigabyte_wmi_hwmon_chip_info, NULL);\n\n\treturn PTR_ERR_OR_ZERO(hwmon_dev);\n}\n\nstatic const struct wmi_device_id gigabyte_wmi_id_table[] = {\n\t{ GIGABYTE_WMI_GUID, NULL },\n\t{ }\n};\n\nstatic struct wmi_driver gigabyte_wmi_driver = {\n\t.driver = {\n\t\t.name = \"gigabyte-wmi\",\n\t},\n\t.id_table = gigabyte_wmi_id_table,\n\t.probe = gigabyte_wmi_probe,\n};\nmodule_wmi_driver(gigabyte_wmi_driver);\n\nMODULE_DEVICE_TABLE(wmi, gigabyte_wmi_id_table);\nMODULE_AUTHOR(\"Thomas Wei\u00dfschuh <thomas@weissschuh.net>\");\nMODULE_DESCRIPTION(\"Gigabyte WMI temperature driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}