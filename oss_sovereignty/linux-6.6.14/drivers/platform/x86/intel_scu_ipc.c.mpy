{
  "module_name": "intel_scu_ipc.c",
  "hash_id": "4d159e4fe1029a2867f8929939efae7dfb9e134c4b05c8319e68a46212da6292",
  "original_prompt": "Ingested from linux-6.6.14/drivers/platform/x86/intel_scu_ipc.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\n#include <asm/intel_scu_ipc.h>\n\n \n#define IPCMSG_PCNTRL         0xff  \n\n \n#define IPC_CMD_PCNTRL_W      0  \n#define IPC_CMD_PCNTRL_R      1  \n#define IPC_CMD_PCNTRL_M      2  \n\n \n\n#define IPC_WWBUF_SIZE    20\t\t \n#define IPC_RWBUF_SIZE    20\t\t \n#define IPC_IOC\t          0x100\t\t \n\nstruct intel_scu_ipc_dev {\n\tstruct device dev;\n\tstruct resource mem;\n\tstruct module *owner;\n\tint irq;\n\tvoid __iomem *ipc_base;\n\tstruct completion cmd_complete;\n};\n\n#define IPC_STATUS\t\t0x04\n#define IPC_STATUS_IRQ\t\tBIT(2)\n#define IPC_STATUS_ERR\t\tBIT(1)\n#define IPC_STATUS_BUSY\t\tBIT(0)\n\n \n#define IPC_WRITE_BUFFER\t0x80\n#define IPC_READ_BUFFER\t\t0x90\n\n \n#define IPC_TIMEOUT\t\t(10 * HZ)\n\nstatic struct intel_scu_ipc_dev *ipcdev;  \nstatic DEFINE_MUTEX(ipclock);  \n\nstatic struct class intel_scu_ipc_class = {\n\t.name = \"intel_scu_ipc\",\n};\n\n \nstruct intel_scu_ipc_dev *intel_scu_ipc_dev_get(void)\n{\n\tstruct intel_scu_ipc_dev *scu = NULL;\n\n\tmutex_lock(&ipclock);\n\tif (ipcdev) {\n\t\tget_device(&ipcdev->dev);\n\t\t \n\t\tif (!try_module_get(ipcdev->owner))\n\t\t\tput_device(&ipcdev->dev);\n\t\telse\n\t\t\tscu = ipcdev;\n\t}\n\n\tmutex_unlock(&ipclock);\n\treturn scu;\n}\nEXPORT_SYMBOL_GPL(intel_scu_ipc_dev_get);\n\n \nvoid intel_scu_ipc_dev_put(struct intel_scu_ipc_dev *scu)\n{\n\tif (scu) {\n\t\tmodule_put(scu->owner);\n\t\tput_device(&scu->dev);\n\t}\n}\nEXPORT_SYMBOL_GPL(intel_scu_ipc_dev_put);\n\nstruct intel_scu_ipc_devres {\n\tstruct intel_scu_ipc_dev *scu;\n};\n\nstatic void devm_intel_scu_ipc_dev_release(struct device *dev, void *res)\n{\n\tstruct intel_scu_ipc_devres *dr = res;\n\tstruct intel_scu_ipc_dev *scu = dr->scu;\n\n\tintel_scu_ipc_dev_put(scu);\n}\n\n \nstruct intel_scu_ipc_dev *devm_intel_scu_ipc_dev_get(struct device *dev)\n{\n\tstruct intel_scu_ipc_devres *dr;\n\tstruct intel_scu_ipc_dev *scu;\n\n\tdr = devres_alloc(devm_intel_scu_ipc_dev_release, sizeof(*dr), GFP_KERNEL);\n\tif (!dr)\n\t\treturn NULL;\n\n\tscu = intel_scu_ipc_dev_get();\n\tif (!scu) {\n\t\tdevres_free(dr);\n\t\treturn NULL;\n\t}\n\n\tdr->scu = scu;\n\tdevres_add(dev, dr);\n\n\treturn scu;\n}\nEXPORT_SYMBOL_GPL(devm_intel_scu_ipc_dev_get);\n\n \nstatic inline void ipc_command(struct intel_scu_ipc_dev *scu, u32 cmd)\n{\n\treinit_completion(&scu->cmd_complete);\n\twritel(cmd | IPC_IOC, scu->ipc_base);\n}\n\n \nstatic inline void ipc_data_writel(struct intel_scu_ipc_dev *scu, u32 data, u32 offset)\n{\n\twritel(data, scu->ipc_base + IPC_WRITE_BUFFER + offset);\n}\n\n \nstatic inline u8 ipc_read_status(struct intel_scu_ipc_dev *scu)\n{\n\treturn __raw_readl(scu->ipc_base + IPC_STATUS);\n}\n\n \nstatic inline u8 ipc_data_readb(struct intel_scu_ipc_dev *scu, u32 offset)\n{\n\treturn readb(scu->ipc_base + IPC_READ_BUFFER + offset);\n}\n\n \nstatic inline u32 ipc_data_readl(struct intel_scu_ipc_dev *scu, u32 offset)\n{\n\treturn readl(scu->ipc_base + IPC_READ_BUFFER + offset);\n}\n\n \nstatic inline int busy_loop(struct intel_scu_ipc_dev *scu)\n{\n\tu8 status;\n\tint err;\n\n\terr = readx_poll_timeout(ipc_read_status, scu, status, !(status & IPC_STATUS_BUSY),\n\t\t\t\t 100, jiffies_to_usecs(IPC_TIMEOUT));\n\tif (err)\n\t\treturn err;\n\n\treturn (status & IPC_STATUS_ERR) ? -EIO : 0;\n}\n\n \nstatic inline int ipc_wait_for_interrupt(struct intel_scu_ipc_dev *scu)\n{\n\tint status;\n\n\twait_for_completion_timeout(&scu->cmd_complete, IPC_TIMEOUT);\n\n\tstatus = ipc_read_status(scu);\n\tif (status & IPC_STATUS_BUSY)\n\t\treturn -ETIMEDOUT;\n\n\tif (status & IPC_STATUS_ERR)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic int intel_scu_ipc_check_status(struct intel_scu_ipc_dev *scu)\n{\n\treturn scu->irq > 0 ? ipc_wait_for_interrupt(scu) : busy_loop(scu);\n}\n\nstatic struct intel_scu_ipc_dev *intel_scu_ipc_get(struct intel_scu_ipc_dev *scu)\n{\n\tu8 status;\n\n\tif (!scu)\n\t\tscu = ipcdev;\n\tif (!scu)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tstatus = ipc_read_status(scu);\n\tif (status & IPC_STATUS_BUSY) {\n\t\tdev_dbg(&scu->dev, \"device is busy\\n\");\n\t\treturn ERR_PTR(-EBUSY);\n\t}\n\n\treturn scu;\n}\n\n \nstatic int pwr_reg_rdwr(struct intel_scu_ipc_dev *scu, u16 *addr, u8 *data,\n\t\t\tu32 count, u32 op, u32 id)\n{\n\tint nc;\n\tu32 offset = 0;\n\tint err;\n\tu8 cbuf[IPC_WWBUF_SIZE];\n\tu32 *wbuf = (u32 *)&cbuf;\n\n\tmemset(cbuf, 0, sizeof(cbuf));\n\n\tmutex_lock(&ipclock);\n\tscu = intel_scu_ipc_get(scu);\n\tif (IS_ERR(scu)) {\n\t\tmutex_unlock(&ipclock);\n\t\treturn PTR_ERR(scu);\n\t}\n\n\tfor (nc = 0; nc < count; nc++, offset += 2) {\n\t\tcbuf[offset] = addr[nc];\n\t\tcbuf[offset + 1] = addr[nc] >> 8;\n\t}\n\n\tif (id == IPC_CMD_PCNTRL_R) {\n\t\tfor (nc = 0, offset = 0; nc < count; nc++, offset += 4)\n\t\t\tipc_data_writel(scu, wbuf[nc], offset);\n\t\tipc_command(scu, (count * 2) << 16 | id << 12 | 0 << 8 | op);\n\t} else if (id == IPC_CMD_PCNTRL_W) {\n\t\tfor (nc = 0; nc < count; nc++, offset += 1)\n\t\t\tcbuf[offset] = data[nc];\n\t\tfor (nc = 0, offset = 0; nc < count; nc++, offset += 4)\n\t\t\tipc_data_writel(scu, wbuf[nc], offset);\n\t\tipc_command(scu, (count * 3) << 16 | id << 12 | 0 << 8 | op);\n\t} else if (id == IPC_CMD_PCNTRL_M) {\n\t\tcbuf[offset] = data[0];\n\t\tcbuf[offset + 1] = data[1];\n\t\tipc_data_writel(scu, wbuf[0], 0);  \n\t\tipc_command(scu, 4 << 16 | id << 12 | 0 << 8 | op);\n\t}\n\n\terr = intel_scu_ipc_check_status(scu);\n\tif (!err && id == IPC_CMD_PCNTRL_R) {  \n\t\t \n\t\tmemcpy_fromio(cbuf, scu->ipc_base + 0x90, 16);\n\t\tfor (nc = 0; nc < count; nc++)\n\t\t\tdata[nc] = ipc_data_readb(scu, nc);\n\t}\n\tmutex_unlock(&ipclock);\n\treturn err;\n}\n\n \nint intel_scu_ipc_dev_ioread8(struct intel_scu_ipc_dev *scu, u16 addr, u8 *data)\n{\n\treturn pwr_reg_rdwr(scu, &addr, data, 1, IPCMSG_PCNTRL, IPC_CMD_PCNTRL_R);\n}\nEXPORT_SYMBOL(intel_scu_ipc_dev_ioread8);\n\n \nint intel_scu_ipc_dev_iowrite8(struct intel_scu_ipc_dev *scu, u16 addr, u8 data)\n{\n\treturn pwr_reg_rdwr(scu, &addr, &data, 1, IPCMSG_PCNTRL, IPC_CMD_PCNTRL_W);\n}\nEXPORT_SYMBOL(intel_scu_ipc_dev_iowrite8);\n\n \nint intel_scu_ipc_dev_readv(struct intel_scu_ipc_dev *scu, u16 *addr, u8 *data,\n\t\t\t    size_t len)\n{\n\treturn pwr_reg_rdwr(scu, addr, data, len, IPCMSG_PCNTRL, IPC_CMD_PCNTRL_R);\n}\nEXPORT_SYMBOL(intel_scu_ipc_dev_readv);\n\n \nint intel_scu_ipc_dev_writev(struct intel_scu_ipc_dev *scu, u16 *addr, u8 *data,\n\t\t\t     size_t len)\n{\n\treturn pwr_reg_rdwr(scu, addr, data, len, IPCMSG_PCNTRL, IPC_CMD_PCNTRL_W);\n}\nEXPORT_SYMBOL(intel_scu_ipc_dev_writev);\n\n \nint intel_scu_ipc_dev_update(struct intel_scu_ipc_dev *scu, u16 addr, u8 data,\n\t\t\t     u8 mask)\n{\n\tu8 tmp[2] = { data, mask };\n\treturn pwr_reg_rdwr(scu, &addr, tmp, 1, IPCMSG_PCNTRL, IPC_CMD_PCNTRL_M);\n}\nEXPORT_SYMBOL(intel_scu_ipc_dev_update);\n\n \nint intel_scu_ipc_dev_simple_command(struct intel_scu_ipc_dev *scu, int cmd,\n\t\t\t\t     int sub)\n{\n\tu32 cmdval;\n\tint err;\n\n\tmutex_lock(&ipclock);\n\tscu = intel_scu_ipc_get(scu);\n\tif (IS_ERR(scu)) {\n\t\tmutex_unlock(&ipclock);\n\t\treturn PTR_ERR(scu);\n\t}\n\n\tcmdval = sub << 12 | cmd;\n\tipc_command(scu, cmdval);\n\terr = intel_scu_ipc_check_status(scu);\n\tmutex_unlock(&ipclock);\n\tif (err)\n\t\tdev_err(&scu->dev, \"IPC command %#x failed with %d\\n\", cmdval, err);\n\treturn err;\n}\nEXPORT_SYMBOL(intel_scu_ipc_dev_simple_command);\n\n \nint intel_scu_ipc_dev_command_with_size(struct intel_scu_ipc_dev *scu, int cmd,\n\t\t\t\t\tint sub, const void *in, size_t inlen,\n\t\t\t\t\tsize_t size, void *out, size_t outlen)\n{\n\tsize_t outbuflen = DIV_ROUND_UP(outlen, sizeof(u32));\n\tsize_t inbuflen = DIV_ROUND_UP(inlen, sizeof(u32));\n\tu32 cmdval, inbuf[4] = {};\n\tint i, err;\n\n\tif (inbuflen > 4 || outbuflen > 4)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&ipclock);\n\tscu = intel_scu_ipc_get(scu);\n\tif (IS_ERR(scu)) {\n\t\tmutex_unlock(&ipclock);\n\t\treturn PTR_ERR(scu);\n\t}\n\n\tmemcpy(inbuf, in, inlen);\n\tfor (i = 0; i < inbuflen; i++)\n\t\tipc_data_writel(scu, inbuf[i], 4 * i);\n\n\tcmdval = (size << 16) | (sub << 12) | cmd;\n\tipc_command(scu, cmdval);\n\terr = intel_scu_ipc_check_status(scu);\n\n\tif (!err) {\n\t\tu32 outbuf[4] = {};\n\n\t\tfor (i = 0; i < outbuflen; i++)\n\t\t\toutbuf[i] = ipc_data_readl(scu, 4 * i);\n\n\t\tmemcpy(out, outbuf, outlen);\n\t}\n\n\tmutex_unlock(&ipclock);\n\tif (err)\n\t\tdev_err(&scu->dev, \"IPC command %#x failed with %d\\n\", cmdval, err);\n\treturn err;\n}\nEXPORT_SYMBOL(intel_scu_ipc_dev_command_with_size);\n\n \nstatic irqreturn_t ioc(int irq, void *dev_id)\n{\n\tstruct intel_scu_ipc_dev *scu = dev_id;\n\tint status = ipc_read_status(scu);\n\n\twritel(status | IPC_STATUS_IRQ, scu->ipc_base + IPC_STATUS);\n\tcomplete(&scu->cmd_complete);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void intel_scu_ipc_release(struct device *dev)\n{\n\tstruct intel_scu_ipc_dev *scu;\n\n\tscu = container_of(dev, struct intel_scu_ipc_dev, dev);\n\tif (scu->irq > 0)\n\t\tfree_irq(scu->irq, scu);\n\tiounmap(scu->ipc_base);\n\trelease_mem_region(scu->mem.start, resource_size(&scu->mem));\n\tkfree(scu);\n}\n\n \nstruct intel_scu_ipc_dev *\n__intel_scu_ipc_register(struct device *parent,\n\t\t\t const struct intel_scu_ipc_data *scu_data,\n\t\t\t struct module *owner)\n{\n\tint err;\n\tstruct intel_scu_ipc_dev *scu;\n\tvoid __iomem *ipc_base;\n\n\tmutex_lock(&ipclock);\n\t \n\tif (ipcdev) {\n\t\terr = -EBUSY;\n\t\tgoto err_unlock;\n\t}\n\n\tscu = kzalloc(sizeof(*scu), GFP_KERNEL);\n\tif (!scu) {\n\t\terr = -ENOMEM;\n\t\tgoto err_unlock;\n\t}\n\n\tscu->owner = owner;\n\tscu->dev.parent = parent;\n\tscu->dev.class = &intel_scu_ipc_class;\n\tscu->dev.release = intel_scu_ipc_release;\n\n\tif (!request_mem_region(scu_data->mem.start, resource_size(&scu_data->mem),\n\t\t\t\t\"intel_scu_ipc\")) {\n\t\terr = -EBUSY;\n\t\tgoto err_free;\n\t}\n\n\tipc_base = ioremap(scu_data->mem.start, resource_size(&scu_data->mem));\n\tif (!ipc_base) {\n\t\terr = -ENOMEM;\n\t\tgoto err_release;\n\t}\n\n\tscu->ipc_base = ipc_base;\n\tscu->mem = scu_data->mem;\n\tscu->irq = scu_data->irq;\n\tinit_completion(&scu->cmd_complete);\n\n\tif (scu->irq > 0) {\n\t\terr = request_irq(scu->irq, ioc, 0, \"intel_scu_ipc\", scu);\n\t\tif (err)\n\t\t\tgoto err_unmap;\n\t}\n\n\t \n\tdev_set_name(&scu->dev, \"intel_scu_ipc\");\n\terr = device_register(&scu->dev);\n\tif (err) {\n\t\tput_device(&scu->dev);\n\t\tgoto err_unlock;\n\t}\n\n\t \n\tipcdev = scu;\n\tmutex_unlock(&ipclock);\n\n\treturn scu;\n\nerr_unmap:\n\tiounmap(ipc_base);\nerr_release:\n\trelease_mem_region(scu_data->mem.start, resource_size(&scu_data->mem));\nerr_free:\n\tkfree(scu);\nerr_unlock:\n\tmutex_unlock(&ipclock);\n\n\treturn ERR_PTR(err);\n}\nEXPORT_SYMBOL_GPL(__intel_scu_ipc_register);\n\n \nvoid intel_scu_ipc_unregister(struct intel_scu_ipc_dev *scu)\n{\n\tmutex_lock(&ipclock);\n\tif (!WARN_ON(!ipcdev)) {\n\t\tipcdev = NULL;\n\t\tdevice_unregister(&scu->dev);\n\t}\n\tmutex_unlock(&ipclock);\n}\nEXPORT_SYMBOL_GPL(intel_scu_ipc_unregister);\n\nstatic void devm_intel_scu_ipc_unregister(struct device *dev, void *res)\n{\n\tstruct intel_scu_ipc_devres *dr = res;\n\tstruct intel_scu_ipc_dev *scu = dr->scu;\n\n\tintel_scu_ipc_unregister(scu);\n}\n\n \nstruct intel_scu_ipc_dev *\n__devm_intel_scu_ipc_register(struct device *parent,\n\t\t\t      const struct intel_scu_ipc_data *scu_data,\n\t\t\t      struct module *owner)\n{\n\tstruct intel_scu_ipc_devres *dr;\n\tstruct intel_scu_ipc_dev *scu;\n\n\tdr = devres_alloc(devm_intel_scu_ipc_unregister, sizeof(*dr), GFP_KERNEL);\n\tif (!dr)\n\t\treturn NULL;\n\n\tscu = __intel_scu_ipc_register(parent, scu_data, owner);\n\tif (IS_ERR(scu)) {\n\t\tdevres_free(dr);\n\t\treturn scu;\n\t}\n\n\tdr->scu = scu;\n\tdevres_add(parent, dr);\n\n\treturn scu;\n}\nEXPORT_SYMBOL_GPL(__devm_intel_scu_ipc_register);\n\nstatic int __init intel_scu_ipc_init(void)\n{\n\treturn class_register(&intel_scu_ipc_class);\n}\nsubsys_initcall(intel_scu_ipc_init);\n\nstatic void __exit intel_scu_ipc_exit(void)\n{\n\tclass_unregister(&intel_scu_ipc_class);\n}\nmodule_exit(intel_scu_ipc_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}